{
    "hands_on_practices": [
        {
            "introduction": "构建有限元系统矩阵的核心步骤是计算单元积分，这通常需要通过数值积分（即求积）来完成。为了保证计算的精确性，所选求积法则的阶数必须足以精确积分被积函数（在本例中是基函数梯度的乘积）。此练习  旨在通过分析刚度矩阵的被积函数，确定所需的最小求积阶数，从而帮助您掌握有限元方法中数值积分的基本准则，这是确保中子扩散和泄漏项被精确离散化的前提。",
            "id": "4217915",
            "problem": "在均匀反应堆组件内的二维中子扩散问题中，考虑一个通过对参考三角形进行仿射映射得到的单个三角形有限元 $K$。假设使用多项式次数为 $p$ 的标量拉格朗日基函数 $\\{N_i\\}$ 的连续有限元法，对具有元内常数扩散系数 $D$ 的扩散算子进行离散化。单元刚度矩阵项由下式给出：\n$$\na_{ij}^{K} = \\int_{K} D\\, \\nabla N_i \\cdot \\nabla N_j \\, d\\mathbf{x}.\n$$\n假设从参考元到物理元的映射是仿射的，因此雅可比矩阵在 $K$ 上为常数。您可以利用以下事实：一个在三角形上被称为 $m$ 次的高斯求积法则，能够精确积分所有总次数至多为 $m$ 的多项式。确定在三角形上使用高斯求积法则精确计算 $a_{ij}^{K}$ 所需的最小多项式精确次数，并从第一性原理证明您的选择。将您的最终答案表示为关于 $p$ 的无单位的闭式表达式。最终答案必须是单个符号表达式。",
            "solution": "该问题要求确定使用高斯求积法则精确计算单元刚度矩阵项 $a_{ij}^{K}$ 所需的最小多项式精确次数（记为 $m$）。刚度矩阵项由以下积分给出：\n$$\na_{ij}^{K} = \\int_{K} D\\, \\nabla N_i \\cdot \\nabla N_j \\, d\\mathbf{x}\n$$\n其中 $K$ 是一个三角形有限元，$D$ 是一个常数扩散系数，$\\{N_i\\}$ 是多项式次数为 $p$ 的标量拉格朗日基函数。\n\n为了找到数值求积所需的精确次数，我们必须首先确定被积函数 $I(\\mathbf{x}) = D\\, \\nabla N_i(\\mathbf{x}) \\cdot \\nabla N_j(\\mathbf{x})$ 的多项式次数。\n\n根据定义，基函数 $N_i(\\mathbf{x})$ 是在单元 $K$ 上的总次数为 $p$ 的多项式。设二维域中的空间坐标为 $\\mathbf{x} = (x_1, x_2)$。一个次数为 $p$ 的一般多项式可以写成形如 $c_{ab} x_1^a x_2^b$ 的项之和，其中 $a+b \\le p$。\n\n基函数 $N_i(\\mathbf{x})$ 的梯度是一个向量场，由下式给出：\n$$\n\\nabla N_i = \\left( \\frac{\\partial N_i}{\\partial x_1}, \\frac{\\partial N_i}{\\partial x_2} \\right)\n$$\n一个总次数为 $p$ 的多项式对其任一变量的偏导数，结果是一个总次数至多为 $p-1$ 的多项式。例如，$\\frac{\\partial}{\\partial x_1} (x_1^a x_2^b) = a x_1^{a-1} x_2^b$，新的总次数为 $(a-1)+b = (a+b)-1 \\le p-1$。因此，梯度向量 $\\nabla N_i$ 的每个分量都是一个次数至多为 $p-1$ 的多项式。$\\nabla N_j$ 也是如此。\n\n接下来，我们考虑两个梯度向量的点积：\n$$\n\\nabla N_i \\cdot \\nabla N_j = \\left(\\frac{\\partial N_i}{\\partial x_1}\\right) \\left(\\frac{\\partial N_j}{\\partial x_1}\\right) + \\left(\\frac{\\partial N_i}{\\partial x_2}\\right) \\left(\\frac{\\partial N_j}{\\partial x_2}\\right)\n$$\n这个和中的每一项都是两个次数至多为 $p-1$ 的多项式的乘积。两个多项式乘积的次数是它们各自次数的和。因此，两个次数至多为 $p-1$ 的多项式的乘积是一个次数至多为 $(p-1) + (p-1) = 2p-2$ 的多项式。两个这样的多项式之和也是一个次数至多为 $2p-2$ 的多项式。\n因此，表达式 $\\nabla N_i \\cdot \\nabla N_j$ 是一个总次数至多为 $2p-2$ 的多项式。\n\n完整的被积函数是 $I(\\mathbf{x}) = D \\nabla N_i \\cdot \\nabla N_j$。题目说明扩散系数 $D$ 是常数。将一个多项式乘以一个非零常数不会改变其次数。因此，被积函数 $I(\\mathbf{x})$ 是一个次数至多为 $2p-2$ 的多项式。\n\n如果一个高斯求积法则能够精确地积分任何总次数最高为 $m$ 的多项式，那么它就具有 $m$ 次的精确性。为了确保 $a_{ij}^{K}$ 的积分被精确计算，该求积法则必须能够精确积分被积函数 $D \\nabla N_i \\cdot \\nabla N_j$。由于该被积函数是一个次数至多为 $2p-2$ 的多项式，所以求积法则的精确次数 $m$ 必须至少为 $2p-2$。\n\n因此，所需的最小精确次数为 $m = 2p-2$。\n\n需要注意的是，这个结果与从参考元到物理元的仿射映射无关。仿射映射 $\\mathbf{x}=F(\\hat{\\mathbf{x}})=\\mathbf{J}\\hat{\\mathbf{x}}+\\mathbf{b}$ 保持函数的多项式次数不变，并且梯度点积的变换会在参考元被积函数中引入一个常数矩阵因子 $(\\mathbf{J}^T \\mathbf{J})^{-1}$，这不会改变表达式在参考坐标系下的多项式次数。推理过程保持不变：参考基函数 $\\hat{N}_i$（它们是次数为 $p$ 的多项式）的梯度是次数为 $p-1$ 的多项式，它们的二次组合得到一个次数为 $2(p-1) = 2p-2$ 的多项式。",
            "answer": "$$\\boxed{2p-2}$$"
        },
        {
            "introduction": "掌握了矩阵组装的基本数值原理后，我们将其应用于一个实际的二维稳态问题。在真实反应堆中，材料的扩散特性可能是各向异性的，即中子在不同方向上的扩散能力不同。此练习  要求您编写一个二维连续有限元程序，求解具有各向异性扩散张量 $\\mathbf{D}$ 的中子扩散方程。通过计算并分析中子流密度 $\\mathbf{J}$ 与负通量梯度 $-\\nabla \\phi$ 之间的夹角，您将亲身体验并量化各向异性效应，从而深刻理解有限元方法如何捕捉复杂物理现象。",
            "id": "4217883",
            "problem": "考虑在二维方形区域上的稳态单能中子扩散近似，该区域具有各向异性扩散特性。令介质区域 $\\Omega = [0,1] \\times [0,1]$（单位为米），通过与笛卡尔坐标轴对齐的协调三角剖分进行离散化。稳态扩散模型旨在求解一个标量中子通量 $\\phi: \\Omega \\rightarrow \\mathbb{R}$，它满足以下强形式方程\n$$\n-\\nabla \\cdot \\left( \\mathbf{D} \\, \\nabla \\phi \\right) + \\Sigma_a \\, \\phi = Q \\quad \\text{in } \\Omega,\n$$\n并带有真空边界条件\n$$\n\\phi = 0 \\quad \\text{on } \\partial \\Omega.\n$$\n此处，$\\mathbf{D} \\in \\mathbb{R}^{2 \\times 2}$ 是对称正定扩散张量，$\\Sigma_a$ 是宏观吸收截面，$Q$ 是体积源。粒子流密度由 Fick 定律定义为\n$$\n\\mathbf{J} = -\\mathbf{D} \\, \\nabla \\phi.\n$$\n你需要使用连续有限元法（CFEM），在结构化三角剖分上采用一阶拉格朗日基函数（分片线性、全局连续）来近似 $\\phi$。从粒子平衡律和粒子流的定义出发，推导弱形式，并简述 CFEM 系统的组装过程。假设系数 $\\mathbf{D}$、$\\Sigma_a$ 和 $Q$ 在整个区域 $\\Omega$ 上为常数。在边界 $\\partial \\Omega$ 上施加狄利克雷边界条件 $\\phi=0$。使用均匀的结构化网格，每个空间方向上有 $N_x=N_y=20$ 个子区间，每个正方形被分割成两个与网格对齐的全等三角形。\n\n为分析各向异性对流方向的影响，考虑主方向与网格对齐的扩散张量，即\n$$\n\\mathbf{D} = \\begin{bmatrix} D_x  0 \\\\ 0  D_y \\end{bmatrix},\n$$\n其中 $D_x>0$ 且 $D_y>0$。对每个三角形单元，计算单元上的常数梯度 $\\nabla \\phi_e$ 和对应的单元流密度 $\\mathbf{J}_e = -\\mathbf{D} \\, \\nabla \\phi_e$。通过以下公式定义单元上流密度 $\\mathbf{J}_e$ 与负梯度 $-\\nabla \\phi_e$ 之间的失准角 $\\theta_e$\n$$\n\\theta_e = \\arccos\\left( \\frac{\\mathbf{J}_e \\cdot \\left(-\\nabla \\phi_e\\right)}{\\|\\mathbf{J}_e\\|_2 \\, \\|\\nabla \\phi_e\\|_2} \\right) \\quad \\text{（单位为弧度）}.\n$$\n如果 $\\|\\nabla \\phi_e\\|_2  10^{-12}$，则在计算平均值时排除该单元 $e$，以避免除以零。对于每组参数，报告所有符合条件的单元的平均失准角，以度为单位表示，并四舍五入到小数点后六位。\n\n使用以下模型参数（为演示而设的科学上合理的数值）：$\\Sigma_a = 0.1 \\ \\text{m}^{-1}$ 和 $Q = 1.0 \\ \\text{neutrons} \\cdot \\text{m}^{-3} \\cdot \\text{s}^{-1}$。考虑四个测试用例，这些用例改变各向异性比率，同时保持主方向与网格对齐：\n- 测试 1：$D_x=1.0$, $D_y=1.0$（各向同性基准）。\n- 测试 2：$D_x=5.0$, $D_y=1.0$（中等各向异性）。\n- 测试 3：$D_x=0.2$, $D_y=1.0$（中等各向异性反转）。\n- 测试 4：$D_x=10.0$, $D_y=1.0$（强各向异性）。\n\n角度单位要求：所有报告的角度必须以度为单位。你的程序的最终输出必须为单行，包含一个 Python 风格的列表，其中包含与上述测试顺序对应的四个平均失准角，每个角都四舍五入到小数点后六位，例如，\n$[\\alpha_1,\\alpha_2,\\alpha_3,\\alpha_4]$,\n其中每个 $\\alpha_i$ 是一个浮点数。\n\n你的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表（例如，$[result1,result2,result3,result4]$）。",
            "solution": "用户提供了一个有效的问题陈述。我将继续进行解答。\n\n### 1. 理论公式推导\n\n该问题要求在二维方形区域 $\\Omega = [0,1] \\times [0,1]$ 上求解稳态单能中子扩散方程。\n\n**强形式：**\n控制偏微分方程（PDE）为：\n$$\n-\\nabla \\cdot \\left( \\mathbf{D} \\, \\nabla \\phi \\right) + \\Sigma_a \\, \\phi = Q \\quad \\text{in } \\Omega\n$$\n并带有齐次狄利克雷（真空）边界条件：\n$$\n\\phi = 0 \\quad \\text{on } \\partial \\Omega\n$$\n此处，$\\phi$ 是标量中子通量，$\\mathbf{D}$ 是各向异性扩散张量，$\\Sigma_a$ 是宏观吸收截面，$Q$ 是体积中子源。所有系数均假定在整个区域上为常数。\n\n**弱形式：**\n为推导弱形式，我们将强形式方程乘以一个属于 Sobolev 空间 $H_0^1(\\Omega)$ 的测试函数 $v$。该空间由平方可积、一阶导数平方可积且在边界 $\\partial\\Omega$ 上为零的函数组成。然后我们在整个区域 $\\Omega$ 上进行积分：\n$$\n\\int_\\Omega \\left( -\\nabla \\cdot (\\mathbf{D} \\nabla \\phi) \\right) v \\, d\\Omega + \\int_\\Omega (\\Sigma_a \\phi) v \\, d\\Omega = \\int_\\Omega Q v \\, d\\Omega\n$$\n对扩散项应用分部积分（格林第一恒等式），得到：\n$$\n\\int_\\Omega (\\mathbf{D} \\nabla \\phi) \\cdot \\nabla v \\, d\\Omega - \\int_{\\partial\\Omega} v (\\mathbf{D} \\nabla \\phi) \\cdot \\mathbf{n} \\, dS + \\int_\\Omega \\Sigma_a \\phi v \\, d\\Omega = \\int_\\Omega Q v \\, d\\Omega\n$$\n由于测试函数 $v$ 在边界 $\\partial\\Omega$ 上为零，边界积分消失。这就得到了弱形式：寻找 $\\phi \\in H_0^1(\\Omega)$，使得对于所有 $v \\in H_0^1(\\Omega)$：\n$$\n\\int_\\Omega (\\mathbf{D} \\nabla \\phi) \\cdot \\nabla v \\, d\\Omega + \\int_\\Omega \\Sigma_a \\phi v \\, d\\Omega = \\int_\\Omega Q v \\, d\\Omega\n$$\n此方程形如 $a(\\phi, v) = L(v)$，其中 $a(\\cdot, \\cdot)$ 是代表扩散和吸收的双线性形式，$L(\\cdot)$ 是代表源的线性形式。\n\n### 2. 有限元离散化\n\n我们用结构化三角网格对区域 $\\Omega$ 进行离散化。解 $\\phi$ 由函数 $\\phi_h$ 近似，该函数是一阶拉格朗日基函数 $N_i(x,y)$ 的线性组合：\n$$\n\\phi_h(x, y) = \\sum_j \\phi_j N_j(x, y)\n$$\n其中 $\\phi_j$ 是网格节点上的未知通量值，求和遍及所有通量未知的节点（即内部节点）。基函数 $N_j$ 是一个“帽函数”，在节点 $j$ 处等于 $1$，在所有其他节点处等于 $0$。\n\n将 $\\phi_h$ 代入弱形式，并选择基函数 $N_i$ 作为测试函数（伽辽金法），我们得到一个线性代数方程组：\n$$\n\\mathbf{K} \\boldsymbol{\\phi} = \\mathbf{f}\n$$\n其中 $\\boldsymbol{\\phi}$ 是未知节点通量值的向量。全局刚度矩阵 $\\mathbf{K}$ 和全局载荷向量 $\\mathbf{f}$ 的各项由以下公式给出：\n$$\nK_{ij} = a(N_j, N_i) = \\int_\\Omega (\\mathbf{D} \\nabla N_j) \\cdot \\nabla N_i \\, d\\Omega + \\int_\\Omega \\Sigma_a N_j N_i \\, d\\Omega\n$$\n$$\nf_i = L(N_i) = \\int_\\Omega Q N_i \\, d\\Omega\n$$\n\n### 3. 系统组装\n\n全局矩阵和向量是通过对网格中每个单元 $e$ 的贡献求和来组装的。对于单个三角形单元 $e$，计算其局部刚度矩阵 $\\mathbf{K}^e$ 和局部载荷向量 $\\mathbf{f}^e$。\n\n单元刚度矩阵 $\\mathbf{K}^e$ 有两个组成部分：\n1.  **扩散（刚度）部分**：由于 $\\mathbf{D}$ 是常数，且线性基函数的梯度在单元上是常数，该项为：\n    $$\n    (\\mathbf{K}^e_{\\text{stiff}})_{ij} = (\\nabla N_i^e)^T \\mathbf{D} (\\nabla N_j^e) A_e\n    $$\n    其中 $\\nabla N_i^e$ 是第 $i$ 个局部基函数的常数梯度，$A_e$ 是单元面积。对于对角张量 $\\mathbf{D} = \\text{diag}(D_x, D_y)$，这可以使用三角形的几何性质来计算。\n2.  **吸收（质量）部分**：线性基函数乘积在三角形上的积分是已知的：\n    $$\n    (\\mathbf{K}^e_{\\text{mass}})_{ij} = \\Sigma_a \\int_e N_j^e N_i^e \\, d\\Omega = \\frac{\\Sigma_a A_e}{12} (1 + \\delta_{ij})\n    $$\n\n单元载荷向量 $\\mathbf{f}^e$ 计算如下：\n$$\n(f^e)_i = Q \\int_e N_i^e \\, d\\Omega = \\frac{Q A_e}{3}\n$$\n然后，将这些局部贡献组装成全局系统，由于齐次狄利克雷边界条件，只考虑内部（自由）自由度。然后求解得到的稀疏、对称、正定的线性系统，以获得节点通量值。\n\n### 4. 后处理与失准角计算\n\n一旦求得节点通量向量 $\\boldsymbol{\\phi}$，近似解 $\\phi_h$ 就已知了。对于每个单元 $e$，通量梯度 $\\nabla \\phi_e$ 是常数，其计算方式为该单元节点通量值加权的基函数梯度的线性组合：\n$$\n\\nabla \\phi_e = \\sum_{j=1}^3 \\phi_j^e \\nabla N_j^e\n$$\n然后使用 Fick 定律计算单元上的中子流密度 $\\mathbf{J}_e$：\n$$\n\\mathbf{J}_e = -\\mathbf{D} \\nabla \\phi_e\n$$\n流密度 $\\mathbf{J}_e$ 与负梯度 $-\\nabla \\phi_e$ 之间的失准角 $\\theta_e$ 量化了扩散各向异性的影响。它使用点积公式计算：\n$$\n\\theta_e = \\arccos\\left( \\frac{\\mathbf{J}_e \\cdot \\left(-\\nabla \\phi_e\\right)}{\\|\\mathbf{J}_e\\|_2 \\, \\|\\nabla \\phi_e\\|_2} \\right) = \\arccos\\left( \\frac{(\\nabla\\phi_e)^T \\mathbf{D} (\\nabla\\phi_e)}{\\|\\mathbf{D} \\nabla\\phi_e\\|_2 \\, \\|\\nabla\\phi_e\\|_2} \\right)\n$$\n梯度范数接近零 $(\\|\\nabla \\phi_e\\|_2  10^{-12})$ 的单元被排除。对每个测试用例，计算所有符合条件的单元的角度平均值（转换为度）。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import lil_matrix\nfrom scipy.sparse.linalg import spsolve\n\ndef calculate_mean_angle(Dx, Dy):\n    \"\"\"\n    Solves the 2D neutron diffusion equation using CFEM and calculates the mean\n    misalignment angle between current and negative flux gradient.\n\n    Args:\n        Dx (float): Diffusion coefficient in the x-direction.\n        Dy (float): Diffusion coefficient in the y-direction.\n\n    Returns:\n        float: The mean misalignment angle in degrees.\n    \"\"\"\n    # Model and Mesh Parameters\n    Nx, Ny = 20, 20\n    Lx, Ly = 1.0, 1.0\n    Sigma_a = 0.1\n    Q = 1.0\n    D_tensor = np.array([[Dx, 0], [0, Dy]])\n\n    # 1. Mesh Generation\n    hx, hy = Lx / Nx, Ly / Ny\n    num_nodes = (Nx + 1) * (Ny + 1)\n    nodes = np.array([[i * hx, j * hy] for j in range(Ny + 1) for i in range(Nx + 1)])\n\n    elements = []\n    for j in range(Ny):\n        for i in range(Nx):\n            n1 = j * (Nx + 1) + i          # bottom-left\n            n2 = j * (Nx + 1) + (i + 1)    # bottom-right\n            n3 = (j + 1) * (Nx + 1) + i      # top-left\n            n4 = (j + 1) * (Nx + 1) + (i + 1)  # top-right\n            # Split square into two triangles along the main diagonal\n            elements.append([n1, n2, n4])\n            elements.append([n1, n4, n3])\n    elements = np.array(elements, dtype=np.int32)\n\n    # 2. Map global indices to interior degrees of freedom\n    num_dof = (Nx - 1) * (Ny - 1)\n    node_map = -np.ones(num_nodes, dtype=int)\n    dof_idx = 0\n    for j in range(1, Ny):\n        for i in range(1, Nx):\n            glob_idx = j * (Nx + 1) + i\n            node_map[glob_idx] = dof_idx\n            dof_idx += 1\n\n    # 3. Assembly of the linear system\n    K = lil_matrix((num_dof, num_dof), dtype=np.float64)\n    f = np.zeros(num_dof, dtype=np.float64)\n\n    mass_local_template = (Sigma_a / 12.0) * np.array([[2, 1, 1], [1, 2, 1], [1, 1, 2]], dtype=np.float64)\n\n    for elem_nodes in elements:\n        v = nodes[elem_nodes]\n        p1, p2, p3 = v[0], v[1], v[2]\n        \n        area = 0.5 * abs(p1[0] * (p2[1] - p3[1]) + p2[0] * (p3[1] - p1[1]) + p3[0] * (p1[1] - p2[1]))\n        if area  1e-15: continue\n        \n        b = np.array([p2[1] - p3[1], p3[1] - p1[1], p1[1] - p2[1]])\n        c = np.array([p3[0] - p2[0], p1[0] - p3[0], p2[0] - p1[0]])\n        \n        K_stiff_local = (1 / (4 * area)) * (Dx * np.outer(b, b) + Dy * np.outer(c, c))\n        K_mass_local = mass_local_template * area\n        K_local = K_stiff_local + K_mass_local\n        \n        f_local = (Q * area / 3.0) * np.ones(3)\n        \n        for r_local in range(3):\n            glob_r = elem_nodes[r_local]\n            dof_r = node_map[glob_r]\n            if dof_r != -1:  # If row corresponds to an interior node\n                f[dof_r] += f_local[r_local]\n                for c_local in range(3):\n                    glob_c = elem_nodes[c_local]\n                    dof_c = node_map[glob_c]\n                    if dof_c != -1:  # If col corresponds to an interior node\n                        K[dof_r, dof_c] += K_local[r_local, c_local]\n\n    # 4. Solve the linear system\n    K_csc = K.tocsc()\n    phi_interior = spsolve(K_csc, f)\n    \n    phi_full = np.zeros(num_nodes)\n    phi_full[node_map != -1] = phi_interior\n\n    # 5. Post-processing to compute misalignment angles\n    angles_rad = []\n    for elem_nodes in elements:\n        v = nodes[elem_nodes]\n        p1, p2, p3 = v[0], v[1], v[2]\n        \n        area = 0.5 * abs(p1[0] * (p2[1] - p3[1]) + p2[0] * (p3[1] - p1[1]) + p3[0] * (p1[1] - p2[1]))\n        if area  1e-15: continue\n        \n        b = np.array([p2[1] - p3[1], p3[1] - p1[1], p1[1] - p2[1]])\n        c = np.array([p3[0] - p2[0], p1[0] - p3[0], p2[0] - p1[0]])\n        \n        elem_phi_vals = phi_full[elem_nodes]\n        \n        grad_phi_x = np.dot(elem_phi_vals, b) / (2 * area)\n        grad_phi_y = np.dot(elem_phi_vals, c) / (2 * area)\n        grad_phi = np.array([grad_phi_x, grad_phi_y])\n        \n        norm_grad = np.linalg.norm(grad_phi)\n        \n        if norm_grad  1e-12:\n            continue\n            \n        J = -D_tensor @ grad_phi\n        norm_J = np.linalg.norm(J)\n        \n        if norm_J  1e-12:\n            continue\n        \n        cos_theta = (grad_phi @ D_tensor @ grad_phi) / (norm_J * norm_grad)\n        \n        # Clip to handle potential floating point inaccuracies\n        cos_theta = np.clip(cos_theta, -1.0, 1.0)\n        \n        angle_rad = np.arccos(cos_theta)\n        angles_rad.append(angle_rad)\n        \n    mean_angle_rad = np.mean(angles_rad) if angles_rad else 0.0\n    mean_angle_deg = np.degrees(mean_angle_rad)\n    \n    return mean_angle_deg\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        (1.0, 1.0),  # Test 1: Isotropic\n        (5.0, 1.0),  # Test 2: Moderate anisotropy\n        (0.2, 1.0),  # Test 3: Moderate anisotropy inverted\n        (10.0, 1.0), # Test 4: Strong anisotropy\n    ]\n\n    results = []\n    for Dx, Dy in test_cases:\n        result = calculate_mean_angle(Dx, Dy)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join([f'{r:.6f}' for r in results])}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "反应堆分析不仅限于稳态，更常涉及瞬态过程。在求解含时演化的扩散方程时，质量矩阵 $\\mathbf{M}$ 的形式以及时间积分方案的稳定性变得至关重要。此练习  是一个综合性的编程实践，旨在引导您深入探讨“一致质量矩阵”（通过精确积分得到）与“集总质量矩阵”（一种对角近似）之间的区别。您将通过实现一个瞬态求解器，分析这两种方法对显式时间积分格式的稳定性、计算精度以及解的物理特性（如正定性）的影响，从而为动态模拟中的数值方案选择提供实践依据。",
            "id": "4217929",
            "problem": "考虑一维板中的瞬态单群中子扩散方程，其边界条件为零通量（真空）。控制方程为标准形式：$$\\frac{1}{v}\\frac{\\partial \\phi}{\\partial t} = D \\frac{\\partial^2 \\phi}{\\partial x^2} - \\Sigma_a \\phi,$$ 其中 $x \\in [0,L]$，$t \\ge 0$，$v$ 是中子速度，$D$ 是扩散系数，$\\Sigma_a$ 是宏观吸收截面，$\\phi(x,t)$ 是标量中子通量。两边乘以 $v$ 得到：$$\\frac{\\partial \\phi}{\\partial t} = \\alpha \\frac{\\partial^2 \\phi}{\\partial x^2} - \\beta \\phi,$$ 其中 $\\alpha = vD$ 且 $\\beta = v\\Sigma_a$。施加齐次狄利克雷边界条件 $\\phi(0,t)=0$ 和 $\\phi(L,t)=0$，以及与边界兼容的初始条件 $\\phi(x,0) = \\sin\\left(\\frac{\\pi x}{L}\\right)$。使用连续有限元法 (FEM)，在 $[0,L]$ 上的 $N$ 个等长单元的均匀网格上采用分段线性基函数，推导出半离散系统：$$\\mathbf{M}\\,\\dot{\\boldsymbol{\\Phi}}(t) + \\mathbf{K}\\,\\boldsymbol{\\Phi}(t) = \\mathbf{0},$$ 其中 $\\mathbf{M}$ 是质量矩阵，$\\mathbf{K}$ 是组合的刚度-反应矩阵。一致质量矩阵使用精确的单元积分，而集总质量矩阵通过对一致矩阵进行行求和以创建对角近似来形成。时间积分采用显式前向欧拉法：$$\\boldsymbol{\\Phi}^{n+1} = \\boldsymbol{\\Phi}^n - \\Delta t\\,\\mathbf{M}^{-1}\\mathbf{K}\\,\\boldsymbol{\\Phi}^n.$$\n\n从弱形式以及通过标准伽辽金投影、分部积分和施加狄利克雷边界得到的单元矩阵定义出发，开发一个程序，该程序：\n\n-   为 $[0,L]$ 上的 $N$ 个线性单元装配内部块的一致质量矩阵 $\\mathbf{M}$ 和组合的刚度-反应矩阵 $\\mathbf{K}$。\n-   通过对 $\\mathbf{M}$ 进行行求和，形成集总质量矩阵 $\\mathbf{M}_{\\mathrm{lump}}$。\n-   对于一致质量和集总质量两种情况，从问题 $\\mathbf{K}\\mathbf{u}=\\lambda\\,\\mathbf{M}\\mathbf{u}$ 中计算广义特征值 $\\lambda$，找出每种情况下的最大特征值 $\\lambda_{\\max}$，并利用不等式 $0\\le \\Delta t \\lambda \\le 2$（对所有特征值成立）来表征显式欧拉法的稳定性极限。\n-   使用 $\\mathbf{M}$ 或 $\\mathbf{M}_{\\mathrm{lump}}$，通过显式欧拉法从初始条件 $\\phi(x,0) = \\sin\\left(\\frac{\\pi x}{L}\\right)$ 演化半离散系统，直至指定的最终时间 $T$，并通过与离散正弦向量的质量内积来测量沿解析第一模态的模态振幅。将数值振幅与时间步进器实际达到的离散时间 $t = n\\Delta t$ 处的解析连续介质振幅 $\\exp\\left(-(\\alpha(\\pi/L)^2+\\beta)\\,t\\right)$进行比较。在两种情况下都使用一致质量内积来测量振幅，以便精度比较使用一个共同的度量标准。\n\n您的程序必须执行三个测试用例，这三个用例共同构成一个测试套件，涵盖一个一般情况、一个边界稳定性条件和一个与正性相关的边缘情况。所有物理参数必须使用以下单位：\n-   $L$ 单位为米 (m)，\n-   $D$ 单位为米 (m)，\n-   $v$ 单位为米每秒 (m/s)，\n-   $\\Sigma_a$ 单位为反米 ($\\mathrm{m}^{-1}$)，\n-   $T$ 和 $\\Delta t$ 单位为秒 (s)。\n\n测试套件参数为：\n\n-   测试用例 1（精度，一般情况）：\n    -   $L = 1.0\\,\\mathrm{m}$，\n    -   $D = 1.0\\times 10^{-4}\\,\\mathrm{m}$，\n    -   $\\Sigma_a = 1.0\\times 10^{-2}\\,\\mathrm{m}^{-1}$，\n    -   $v = 1000.0\\,\\mathrm{m/s}$，\n    -   $N = 40$，\n    -   最终时间 $T = 0.5\\,\\mathrm{s}$，\n    -   时间步长选择为 $\\Delta t = \\mu \\cdot \\frac{2}{\\lambda_{\\max,\\mathrm{cons}}}$，其中 $\\mu = 0.2$，$\\lambda_{\\max,\\mathrm{cons}}$ 是一致质量矩阵的最大广义特征值。输出在时间 $t=n\\Delta t \\le T$ 时的模态振幅绝对误差对：$[\\mathrm{err}_{\\mathrm{cons}}, \\mathrm{err}_{\\mathrm{lump}}]$，其中每个误差都是无量纲的。\n\n-   测试用例 2（稳定性，边界条件）：\n    -   $L = 1.0\\,\\mathrm{m}$，\n    -   $D = 1.0\\times 10^{-4}\\,\\mathrm{m}$，\n    -   $\\Sigma_a = 1.0\\times 10^{-2}\\,\\mathrm{m}^{-1}$，\n    -   $v = 1000.0\\,\\mathrm{m/s}$，\n    -   $N = 40$，\n    -   选择 $\\Delta t = \\mu \\cdot \\frac{2}{\\lambda_{\\max,\\mathrm{cons}}}$，其中 $\\mu = 1.01$。输出布尔值对 $[\\mathrm{stable}_{\\mathrm{cons}}, \\mathrm{stable}_{\\mathrm{lump}}]$，指示显式欧拉格式在每种情况下是否稳定（如果对于相应的质量矩阵，$\\Delta t \\le 2/\\lambda_{\\max}$ 则为 true，否则为 false）。\n\n-   测试用例 3（正性，边缘情况）：\n    -   $L = 1.0\\,\\mathrm{m}$，\n    -   $D = 1.0\\times 10^{-4}\\,\\mathrm{m}$，\n    -   $\\Sigma_a = 0.0\\,\\mathrm{m}^{-1}$，\n    -   $v = 1000.0\\,\\mathrm{m/s}$，\n    -   $N = 6$，\n    -   最终时间 $T = 0.2\\,\\mathrm{s}$，\n    -   选择 $\\Delta t = \\mu \\cdot \\frac{2}{\\lambda_{\\max,\\mathrm{cons}}}$，其中 $\\mu = 0.9$。演化一致质量和集总质量的半离散系统，并输出布尔值对 $[\\mathrm{positive}_{\\mathrm{cons}}, \\mathrm{positive}_{\\mathrm{lump}}]$，指示所有节点值是否保持非负（如果没有节点值超出数值容差范围变为负值，则为 true；无量纲）。\n\n您的程序应生成单行输出，其中包含一个逗号分隔的列表，该列表包含在方括号中的三个子列表，按所述测试用例的顺序排列：例如，输出格式必须完全是 $$[[\\mathrm{err}_{\\mathrm{cons}},\\mathrm{err}_{\\mathrm{lump}}],[\\mathrm{stable}_{\\mathrm{cons}},\\mathrm{stable}_{\\mathrm{lump}}],[\\mathrm{positive}_{\\mathrm{cons}},\\mathrm{positive}_{\\mathrm{lump}}]].$$\n\n科学真实性和推导要求：\n-   从弱形式出发，该弱形式通过将控制方程乘以一个检验函数并在 $[0,L]$ 上积分，对扩散项使用分部积分，并强制施加齐次狄利克雷边界条件得到。\n-   使用一维线性有限元的标准单元矩阵：一致单元质量矩阵和单元扩散刚度矩阵，并将反应项作为按 $\\beta$ 缩放的类质量贡献添加。\n-   通过对一致内部质量矩阵进行行求和以获得对角近似，来定义集总质量矩阵。\n-   使用广义特征值问题 $\\mathbf{K}\\mathbf{u}=\\lambda\\,\\mathbf{M}\\mathbf{u}$ 来评估显式欧拉稳定性极限 $\\Delta t \\le \\frac{2}{\\lambda_{\\max}}$ 并计算瞬态模态衰减。\n-   以精确格式报告所要求的输出，数值为无量纲或布尔值，并确保在参数定义中遵守物理单位，但在输出中不需要。",
            "solution": "该问题陈述经评估有效。它在科学上基于核反应堆物理和数值分析的原理，作为一个初边值问题是适定的，客观的，并为获得唯一解提供了所有必要的信息。\n\n### 1. 弱形式的推导\n\n给定的瞬态单群中子扩散控制方程为：\n$$\n\\frac{\\partial \\phi}{\\partial t} = \\alpha \\frac{\\partial^2 \\phi}{\\partial x^2} - \\beta \\phi, \\quad x \\in [0, L]\n$$\n伴有齐次狄利克雷边界条件 $\\phi(0,t) = 0$ 和 $\\phi(L,t) = 0$。参数定义为 $\\alpha = vD$ 和 $\\beta = v\\Sigma_a$。\n\n为推导弱形式，我们将方程乘以一个来自索伯列夫空间 $H_0^1([0,L])$ 的检验函数 $w(x)$，该空间由平方可积、其导数也平方可积且在边界 $x=0$ 和 $x=L$ 处为零的函数组成。然后在空间域 $[0,L]$ 上积分：\n$$\n\\int_0^L w(x) \\frac{\\partial \\phi}{\\partial t} dx = \\int_0^L w(x) \\left( \\alpha \\frac{\\partial^2 \\phi}{\\partial x^2} - \\beta \\phi \\right) dx\n$$\n我们对扩散项应用分部积分：\n$$\n\\int_0^L w(x) \\alpha \\frac{\\partial^2 \\phi}{\\partial x^2} dx = \\left[ w(x) \\alpha \\frac{\\partial \\phi}{\\partial x} \\right]_0^L - \\int_0^L \\alpha \\frac{\\partial w}{\\partial x} \\frac{\\partial \\phi}{\\partial x} dx\n$$\n由于检验函数 $w(x) \\in H_0^1([0,L])$，我们有 $w(0) = w(L) = 0$。因此，边界项 $\\left[ w(x) \\alpha \\frac{\\partial \\phi}{\\partial x} \\right]_0^L$ 为零。于是，弱形式为：寻找 $\\phi(x,t)$，使得对于所有 $w(x) \\in H_0^1([0,L])$：\n$$\n\\int_0^L w \\frac{\\partial \\phi}{\\partial t} dx + \\int_0^L \\alpha \\frac{\\partial w}{\\partial x} \\frac{\\partial \\phi}{\\partial x} dx + \\int_0^L \\beta w \\phi dx = 0\n$$\n\n### 2. 有限元离散化\n\n我们将域 $[0,L]$ 离散为 $N$ 个长度为 $h=L/N$ 的均匀单元。我们使用分段线性基函数 $N_j(x)$ 来近似标量通量 $\\phi(x,t)$：\n$$\n\\phi(x,t) \\approx \\phi_h(x,t) = \\sum_{j=1}^{N-1} \\Phi_j(t) N_j(x)\n$$\n求和遍及 $N-1$ 个内部节点，因为节点 $0$ 和 $N$ 处的通量由边界条件固定为 $0$。函数 $N_j(x)$ 是标准的“帽子”函数，其中 $N_j(x)$ 在节点 $x_j$ 处为 $1$，在所有其他节点处为 $0$。\n\n使用伽辽金方法，我们选择检验函数 $w(x)$ 为基函数 $N_i(x)$，$i=1, \\dots, N-1$。将 $\\phi_h(x,t)$ 的展开式代入弱形式，得到一个常微分方程组：\n$$\n\\sum_{j=1}^{N-1} \\left( \\int_0^L N_i N_j dx \\right) \\frac{d\\Phi_j}{dt} + \\sum_{j=1}^{N-1} \\left( \\int_0^L \\alpha \\frac{dN_i}{dx}\\frac{dN_j}{dx} dx \\right) \\Phi_j + \\sum_{j=1}^{N-1} \\left( \\int_0^L \\beta N_i N_j dx \\right) \\Phi_j = 0\n$$\n该系统可以写成矩阵形式：\n$$\n\\mathbf{M} \\frac{d\\boldsymbol{\\Phi}}{dt} + (\\mathbf{S} + \\beta\\mathbf{M}) \\boldsymbol{\\Phi} = \\mathbf{0}\n$$\n其中 $\\boldsymbol{\\Phi}(t) = [\\Phi_1(t), \\dots, \\Phi_{N-1}(t)]^T$ 是节点通量值的向量。矩阵由其分量定义：\n-   一致质量矩阵: $M_{ij} = \\int_0^L N_i(x) N_j(x) dx$\n-   刚度矩阵: $S_{ij} = \\int_0^L \\alpha \\frac{dN_i(x)}{dx} \\frac{dN_j(x)}{dx} dx$\n\n通过定义组合的刚度-反应矩阵 $\\mathbf{K} = \\mathbf{S} + \\beta\\mathbf{M}$，我们得到指定的半离散系统：\n$$\n\\mathbf{M} \\dot{\\boldsymbol{\\Phi}}(t) + \\mathbf{K} \\boldsymbol{\\Phi}(t) = \\mathbf{0}\n$$\n\n### 3. 矩阵装配\n\n全局矩阵由单元级的贡献装配而成。对于一个长度为 $h$ 的通用单元，局部基函数导出以下单元矩阵：\n-   单元质量矩阵: $\\mathbf{m}^e = \\frac{h}{6} \\begin{pmatrix} 2  1 \\\\ 1  2 \\end{pmatrix}$\n-   单元刚度矩阵: $\\mathbf{s}^e = \\frac{\\alpha}{h} \\begin{pmatrix} 1  -1 \\\\ -1  1 \\end{pmatrix}$\n\n为 $N-1$ 个内部自由度装配这些矩阵，得到三对角全局矩阵：\n-   全局一致质量矩阵 $\\mathbf{M}$:\n    -   $M_{ii} = \\frac{4h}{6} = \\frac{2h}{3}$\n    -   $M_{i, i\\pm 1} = \\frac{h}{6}$\n-   全局刚度矩阵 $\\mathbf{S}$:\n    -   $S_{ii} = \\frac{2\\alpha}{h}$\n    -   $S_{i, i\\pm 1} = -\\frac{\\alpha}{h}$\n-   全局刚度-反应矩阵 $\\mathbf{K} = \\mathbf{S} + \\beta\\mathbf{M}$:\n    -   $K_{ii} = \\frac{2\\alpha}{h} + \\beta\\frac{2h}{3}$\n    -   $K_{i, i\\pm 1} = -\\frac{\\alpha}{h} + \\beta\\frac{h}{6}$\n\n集总质量矩阵 $\\mathbf{M}_{\\mathrm{lump}}$ 是通过将一致质量矩阵 $\\mathbf{M}$ 的行相加，并将总和放在对角线上形成的。对于 $(N-1) \\times (N-1)$ 的内部矩阵 $\\mathbf{M}$，行和为 $M_{1, \\mathrm{sum}} = M_{N-1, \\mathrm{sum}} = \\frac{4h}{6} + \\frac{h}{6} = \\frac{5h}{6}$ 且对于 $i=2, \\dots, N-2$，$M_{i, \\mathrm{sum}} = \\frac{h}{6} + \\frac{4h}{6} + \\frac{h}{6} = h$。$\\mathbf{M}_{\\mathrm{lump}}$ 是一个具有这些值的对角矩阵。\n\n### 4. 时间积分与稳定性分析\n\n半离散系统使用显式前向欧拉法进行时间积分：\n$$\n\\mathbf{M} \\frac{\\boldsymbol{\\Phi}^{n+1} - \\boldsymbol{\\Phi}^n}{\\Delta t} = -\\mathbf{K} \\boldsymbol{\\Phi}^n \\implies \\boldsymbol{\\Phi}^{n+1} = \\boldsymbol{\\Phi}^n - \\Delta t \\mathbf{M}^{-1} \\mathbf{K} \\boldsymbol{\\Phi}^n\n$$\n该格式的稳定性由系统矩阵 $\\mathbf{A} = \\mathbf{M}^{-1}\\mathbf{K}$ 的特征值决定。这些特征值通过求解广义特征值问题 $\\mathbf{K}\\mathbf{u} = \\lambda \\mathbf{M}\\mathbf{u}$ 得到。由于 $\\mathbf{M}$ 和 $\\mathbf{K}$ 是对称正定的，特征值 $\\lambda_i$ 是实数且为正。前向欧拉法的稳定性条件要求对于所有特征值 $\\lambda_i$，都有 $|1 - \\Delta t \\lambda_i| \\le 1$，这简化为 $\\Delta t \\lambda_i \\le 2$。此条件必须对最大特征值成立，从而得到稳定性极限：\n$$\n\\Delta t \\le \\frac{2}{\\lambda_{\\mathrm{max}}}\n$$\n此条件必须对一致质量 ($\\mathbf{M}$) 和集总质量 ($\\mathbf{M}_{\\mathrm{lump}}$) 系统分别进行评估，它们会产生不同的最大特征值。\n\n### 5. 解的分析与实现\n\n-   **初始条件**: 初始节点向量 $\\boldsymbol{\\Phi}^0$ 通过在内部节点处评估初始条件 $\\phi(x,0) = \\sin(\\frac{\\pi x}{L})$ 得到：$\\Phi_j(0) = \\sin(\\frac{\\pi x_j}{L})$，$j=1, \\dots, N-1$。这对应于离散系统的第一本征模。\n-   **模态振幅**: 第一模态的解析解为 $\\phi(x,t) = A(t)\\sin(\\frac{\\pi x}{L})$，其中振幅为 $A(t) = \\exp\\left(-\\left(\\alpha(\\frac{\\pi}{L})^2+\\beta\\right)t\\right)$。解向量 $\\boldsymbol{\\Phi}^n$ 沿第一模态形状 $\\mathbf{u}_1 = \\boldsymbol{\\Phi}^0$ 的数值振幅使用一致质量内积 $\\langle \\mathbf{v}, \\mathbf{w} \\rangle_{\\mathbf{M}} = \\mathbf{v}^T \\mathbf{M} \\mathbf{w}$ 来测量：\n    $$\n    A^n_{\\mathrm{num}} = \\frac{\\langle \\boldsymbol{\\Phi}^n, \\mathbf{u}_1 \\rangle_{\\mathbf{M}}}{\\langle \\mathbf{u}_1, \\mathbf{u}_1 \\rangle_{\\mathbf{M}}} = \\frac{(\\boldsymbol{\\Phi}^n)^T \\mathbf{M} \\mathbf{u}_1}{\\mathbf{u}_1^T \\mathbf{M} \\mathbf{u}_1}\n    $$\n    误差是在最终时间步处的绝对差 $|A^n_{\\mathrm{num}} - A(t_n)|$。\n-   **正性**: 对于情况 3，在每个步骤中检查时间演化的解向量 $\\boldsymbol{\\Phi}^n$。如果任何节点值 $\\Phi_j^n$ 变得小于一个小的数值容差（例如 $-10^{-12}$），则认为解不为正。已知一致质量有限元法在某些条件下即使格式稳定也可能违反正性，而集总质量法通常可以纠正这一点。\n\n实现将遵循这些原则，构造矩阵，求解特征值问题以确定时间步长和稳定性，执行时间积分，并最终为三个测试用例中的每一个计算所需的度量。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import eigh\n\ndef solve():\n    \"\"\"\n    Solves the 1D time-dependent neutron diffusion equation using FEM\n    and evaluates accuracy, stability, and positivity for three test cases.\n    \"\"\"\n\n    test_cases = [\n        # Case 1: Accuracy\n        {'L': 1.0, 'D': 1.0e-4, 'Sigma_a': 1.0e-2, 'v': 1000.0, 'N': 40, 'T': 0.5, 'mu': 0.2, 'case': 'accuracy'},\n        # Case 2: Stability\n        {'L': 1.0, 'D': 1.0e-4, 'Sigma_a': 1.0e-2, 'v': 1000.0, 'N': 40, 'T': 0, 'mu': 1.01, 'case': 'stability'},\n        # Case 3: Positivity\n        {'L': 1.0, 'D': 1.0e-4, 'Sigma_a': 0.0, 'v': 1000.0, 'N': 6, 'T': 0.2, 'mu': 0.9, 'case': 'positivity'}\n    ]\n\n    all_results = []\n\n    for params in test_cases:\n        L = params['L']\n        D = params['D']\n        Sigma_a = params['Sigma_a']\n        v = params['v']\n        N = params['N']\n        T = params['T']\n        mu = params['mu']\n        case = params['case']\n\n        alpha = v * D\n        beta = v * Sigma_a\n        h = L / N\n        dim = N - 1\n\n        # Assemble M (consistent mass) and K (stiffness-reaction) matrices\n        M_cons = np.zeros((dim, dim))\n        S = np.zeros((dim, dim))\n\n        diag_M = 4.0 * h / 6.0\n        offdiag_M = h / 6.0\n        diag_S = 2.0 * alpha / h\n        offdiag_S = -alpha / h\n\n        np.fill_diagonal(M_cons, diag_M)\n        np.fill_diagonal(S, diag_S)\n\n        if dim > 1:\n            np.fill_diagonal(M_cons[1:], offdiag_M)\n            np.fill_diagonal(M_cons[:, 1:], offdiag_M)\n            np.fill_diagonal(S[1:], offdiag_S)\n            np.fill_diagonal(S[:, 1:], offdiag_S)\n\n        K = S + beta * M_cons\n\n        # Form lumped mass matrix\n        M_lump = np.diag(M_cons.sum(axis=1))\n\n        # Compute generalized eigenvalues and max eigenvalue for both systems\n        eigvals_cons = eigh(K, M_cons, eigvals_only=True)\n        lambda_max_cons = np.max(eigvals_cons)\n\n        eigvals_lump = eigh(K, M_lump, eigvals_only=True)\n        lambda_max_lump = np.max(eigvals_lump)\n        \n        dt = mu * 2.0 / lambda_max_cons\n        \n        # Initial condition\n        nodes = np.linspace(h, L - h, dim)\n        phi0 = np.sin(np.pi * nodes / L)\n\n        if case == 'accuracy':\n            num_steps = int(T / dt)\n            final_t = num_steps * dt\n\n            # Evolve with consistent mass\n            phi_cons = phi0.copy()\n            for _ in range(num_steps):\n                rhs = -K @ phi_cons\n                phi_update = np.linalg.solve(M_cons, rhs)\n                phi_cons += dt * phi_update\n            \n            # Evolve with lumped mass\n            phi_lump = phi0.copy()\n            M_lump_inv = np.diag(1.0 / np.diag(M_lump))\n            for _ in range(num_steps):\n                rhs = -K @ phi_lump\n                phi_update = M_lump_inv @ rhs\n                phi_lump += dt * phi_update\n\n            # Measure modal amplitude and error\n            u1_vec = phi0\n            norm_factor = u1_vec.T @ M_cons @ u1_vec\n            \n            amp_cons_num = (phi_cons.T @ M_cons @ u1_vec) / norm_factor\n            amp_lump_num = (phi_lump.T @ M_cons @ u1_vec) / norm_factor\n\n            lambda_analytic = alpha * (np.pi / L)**2 + beta\n            amp_analytic = np.exp(-lambda_analytic * final_t)\n            \n            err_cons = abs(amp_cons_num - amp_analytic)\n            err_lump = abs(amp_lump_num - amp_analytic)\n            all_results.append([err_cons, err_lump])\n\n        elif case == 'stability':\n            stable_cons = dt * lambda_max_cons = 2.0\n            stable_lump = dt * lambda_max_lump = 2.0\n            all_results.append([stable_cons, stable_lump])\n\n        elif case == 'positivity':\n            num_steps = int(T / dt)\n            \n            # Check positivity for consistent mass\n            positive_cons = True\n            phi_cons = phi0.copy()\n            for _ in range(num_steps):\n                rhs = -K @ phi_cons\n                phi_update = np.linalg.solve(M_cons, rhs)\n                phi_cons += dt * phi_update\n                if np.any(phi_cons  -1e-12):\n                    positive_cons = False\n                    break\n            \n            # Check positivity for lumped mass\n            positive_lump = True\n            phi_lump = phi0.copy()\n            M_lump_inv = np.diag(1.0 / np.diag(M_lump))\n            for _ in range(num_steps):\n                rhs = -K @ phi_lump\n                phi_update = M_lump_inv @ rhs\n                phi_lump += dt * phi_update\n                if np.any(phi_lump  -1e-12):\n                    positive_lump = False\n                    break\n            all_results.append([positive_cons, positive_lump])\n\n    # Format the final output string\n    def format_val(v):\n        if isinstance(v, bool):\n            return str(v).lower()\n        return str(v)\n\n    sublist_strs = []\n    for sublist in all_results:\n        sublist_strs.append(f\"[{','.join(map(format_val, sublist))}]\")\n    \n    print(f\"[{','.join(sublist_strs)}]\")\n\nsolve()\n```"
        }
    ]
}