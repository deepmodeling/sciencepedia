{
    "hands_on_practices": [
        {
            "introduction": "The finite element method transforms differential equations into a system of algebraic equations by integrating a \"weak form\" over each element. These integrals are almost always computed numerically, and the accuracy of the entire simulation hinges on the accuracy of this numerical integration, or quadrature. This first exercise  dives into the heart of this process, asking you to determine the exact quadrature rule needed to correctly assemble the mass matrix. You will also contrast this with the practical technique of \"mass lumping,\" providing a foundational understanding of a key trade-off between accuracy and computational efficiency in reactor physics codes.",
            "id": "4217887",
            "problem": "In a one-dimensional pin-cell model of steady neutron diffusion for nuclear reactor simulation, consider a continuous Galerkin finite element method (CGFEM) discretization on a single affine physical element $K = [x_{e}, x_{e+1}]$ of size $h = x_{e+1} - x_{e}$. The macroscopic absorption cross section $\\Sigma_{a}$ is constant on $K$. Let the trial and test spaces be spanned by Lagrange shape functions $\\{N_{i}\\}_{i=1}^{n_{\\text{dof}}}$ of polynomial degree $p$ defined on the reference interval $\\hat{K} = [-1,1]$, and mapped to $K$ by an affine map $F : \\hat{K} \\to K$ so that $x = F(\\xi)$ and $dx = J\\,d\\xi$ with constant Jacobian $J = h/2$. The element-level absorption mass matrix entries are\n$$\nM_{ij} = \\int_{K} \\Sigma_{a}\\,N_{i}(x)\\,N_{j}(x)\\,dx.\n$$\nStarting from the weak form of the neutron diffusion equation and the affine mapping described above, determine the minimal number $n$ of points in a Gauss–Legendre quadrature on $\\hat{K} = [-1,1]$ required to evaluate $M_{ij}$ exactly for all indices $i$ and $j$. Express your final answer as a closed-form analytic expression in terms of the polynomial degree $p$. Then, in words, contrast this exact-integration requirement with mass-lumped approximations that diagonalize $M$ via nodal quadrature on $\\hat{K}$ with $p+1$ nodes, highlighting implications for the spectral properties of the absorption operator in reactor calculations. No numerical estimate is required for the contrast. The final answer must be a single symbolic expression; do not include units, and no rounding is needed.",
            "solution": "The problem is valid as it is scientifically grounded, well-posed, and objective. It poses a standard question in the numerical analysis of finite element methods applied to neutron diffusion, a core topic in nuclear reactor simulation. All necessary information is provided, and the terms used are precise and standard within the field.\n\nThe primary task is to determine the minimal number of Gauss-Legendre quadrature points, denoted by $n$, required for the exact evaluation of the element-level absorption mass matrix entries $M_{ij}$. The secondary task is to contrast this with mass-lumped approximations.\n\nFirst, we analyze the integral for the mass matrix entry $M_{ij}$. It is defined on the physical element $K = [x_e, x_{e+1}]$ as:\n$$\nM_{ij} = \\int_{K} \\Sigma_{a}\\,N_{i}(x)\\,N_{j}(x)\\,dx\n$$\nHere, $\\Sigma_{a}$ is the constant macroscopic absorption cross section on the element $K$. The functions $N_i(x)$ and $N_j(x)$ are Lagrange basis functions of polynomial degree $p$.\n\nTo perform the integration using a standard quadrature rule, we map the integral from the physical element $K$ to the reference element $\\hat{K} = [-1, 1]$. The problem states this is done via an affine map $x = F(\\xi)$, for which the differential element transforms as $dx = J\\,d\\xi$, with a constant Jacobian $J = \\frac{h}{2}$, where $h = x_{e+1} - x_e$. Let $\\hat{N}_i(\\xi)$ and $\\hat{N}_j(\\xi)$ be the basis functions on the reference element, such that $N_i(x) = \\hat{N}_i(F^{-1}(x))$. The integral becomes:\n$$\nM_{ij} = \\int_{-1}^{1} \\Sigma_{a}\\,\\hat{N}_{i}(\\xi)\\,\\hat{N}_{j}(\\xi)\\,J\\,d\\xi\n$$\nSince $\\Sigma_{a}$ and the Jacobian $J = \\frac{h}{2}$ are constants, we can factor them out of the integral:\n$$\nM_{ij} = \\frac{\\Sigma_{a} h}{2} \\int_{-1}^{1} \\hat{N}_{i}(\\xi)\\,\\hat{N}_{j}(\\xi)\\,d\\xi\n$$\nThe integrand, which must be integrated exactly, is the product $\\hat{N}_{i}(\\xi)\\,\\hat{N}_{j}(\\xi)$. Since the affine mapping preserves polynomial degree, the reference basis functions $\\hat{N}_{i}(\\xi)$ and $\\hat{N}_{j}(\\xi)$ are also polynomials of degree $p$ in the variable $\\xi$. The product of two polynomials of degree $p$ is a polynomial of degree at most $p+p = 2p$. Let the degree of the integrand polynomial be $D$. Thus, $D = 2p$.\n\nA Gauss-Legendre quadrature rule with $n$ points is capable of integrating polynomials of degree up to $2n-1$ exactly. To ensure exact integration of our integrand, the degree of exactness of the quadrature rule must be greater than or equal to the degree of the polynomial being integrated. This gives the condition:\n$$\n2n - 1 \\ge D\n$$\nSubstituting $D = 2p$, we get:\n$$\n2n - 1 \\ge 2p\n$$\nSolving for $n$, we find:\n$$\n2n \\ge 2p + 1\n$$\n$$\nn \\ge p + \\frac{1}{2}\n$$\nSince the number of quadrature points $n$ must be an integer, the minimal integer value of $n$ that satisfies this inequality is $p+1$.\nTherefore, a minimum of $n=p+1$ Gauss-Legendre quadrature points are required to compute the mass matrix entries $M_{ij}$ exactly.\n\nFor the second part of the problem, we contrast this exact integration scheme with mass-lumping. The exact integration yields what is known as a \"consistent\" mass matrix, which is generally dense (for $p \\ge 1$), symmetric, and positive-definite.\n\nMass lumping via nodal quadrature, as described in the problem, uses the $p+1$ nodal points of the Lagrange basis functions themselves as the quadrature points. Let these nodal points on the reference element be $\\{\\hat{\\xi}_k\\}_{k=1}^{p+1}$. By the definition of Lagrange basis functions, $\\hat{N}_i(\\hat{\\xi}_k) = \\delta_{ik}$, where $\\delta_{ik}$ is the Kronecker delta. The integral is approximated as a sum:\n$$\nM_{ij} = \\frac{\\Sigma_a h}{2} \\int_{-1}^{1} \\hat{N}_i(\\xi) \\hat{N}_j(\\xi) d\\xi \\approx \\frac{\\Sigma_a h}{2} \\sum_{k=1}^{p+1} w_k \\hat{N}_i(\\hat{\\xi}_k) \\hat{N}_j(\\hat{\\xi}_k)\n$$\nwhere $w_k$ are the quadrature weights. Substituting the Kronecker delta property:\n$$\nM_{ij}^{\\text{lumped}} = \\frac{\\Sigma_a h}{2} \\sum_{k=1}^{p+1} w_k \\delta_{ik} \\delta_{jk}\n$$\nThis sum is non-zero only when $i=j=k$. Consequently, the resulting lumped mass matrix $M^{\\text{lumped}}$ is diagonal, with entries $M_{ii}^{\\text{lumped}} = \\frac{\\Sigma_a h}{2} w_i > 0$. This diagonal structure dramatically simplifies computations, especially the inversion of the mass matrix required in time-dependent problems.\n\nThe implications for the spectral properties of the absorption operator are significant. The continuous absorption operator is a multiplication by $\\Sigma_a$, and its spectrum is simply the range of values taken by $\\Sigma_a$.\nThe consistent mass matrix, while providing a higher-order accurate representation, is known to have eigenvalues that can overestimate the spectrum of the continuous operator. That is, the largest eigenvalue of the (normalized) consistent mass matrix can be larger than the maximum physical value of $\\Sigma_a$ in the domain. This spectral overestimation can negatively affect the stability of time-integration schemes and the convergence rate of iterative solvers common in reactor physics calculations (e.g., power iteration for the $k_{\\text{eff}}$ eigenvalue).\nIn contrast, the lumped mass matrix, being diagonal, has eigenvalues that are simply its diagonal entries. While the integration itself is inexact, this procedure can be constructed to preserve certain physical properties. For example, some lumping schemes guarantee that the matrix eigenvalues remain within the physical bounds of the coefficient $\\Sigma_a$. This avoids spectral overestimation and can lead to more robust and physically consistent numerical behavior, such as preserving the positivity of the neutron flux. The trade-off is a reduction in formal accuracy compared to the consistent mass formulation, but the computational benefits and improved spectral properties often make mass lumping an attractive option in practical large-scale reactor simulations.",
            "answer": "$$\\boxed{p+1}$$"
        },
        {
            "introduction": "The choice between a \"consistent\" mass matrix, which arises from exact integration, and a \"lumped\" mass matrix, a diagonal approximation, has profound effects on time-dependent simulations. This choice impacts the numerical stability of the time-stepping scheme, the formal accuracy of the solution, and even the physical realism, such as maintaining the positivity of the neutron flux. In this hands-on coding practice , you will implement a transient solver to directly observe and quantify these effects, gaining crucial insights into designing robust and efficient numerical schemes for reactor dynamics.",
            "id": "4217929",
            "problem": "Consider the time-dependent one-group neutron diffusion equation in a one-dimensional slab with zero-flux (vacuum) boundary conditions. The governing equation is the standard form $$\\frac{1}{v}\\frac{\\partial \\phi}{\\partial t} = D \\frac{\\partial^2 \\phi}{\\partial x^2} - \\Sigma_a \\phi,$$ where $x \\in [0,L]$, $t \\ge 0$, $v$ is the neutron speed, $D$ is the diffusion coefficient, $\\Sigma_a$ is the macroscopic absorption cross section, and $\\phi(x,t)$ is the scalar neutron flux. Multiply by $v$ to obtain $$\\frac{\\partial \\phi}{\\partial t} = \\alpha \\frac{\\partial^2 \\phi}{\\partial x^2} - \\beta \\phi,$$ with $\\alpha = vD$ and $\\beta = v\\Sigma_a$. Impose homogeneous Dirichlet boundary conditions $\\phi(0,t)=0$ and $\\phi(L,t)=0$, and an initial condition $\\phi(x,0) = \\sin\\left(\\frac{\\pi x}{L}\\right)$, which is compatible with the boundaries. Use the continuous Finite Element Method (FEM) with piecewise linear basis functions on a uniform mesh of $N$ equal elements over $[0,L]$ to derive the semi-discrete system $$\\mathbf{M}\\,\\dot{\\boldsymbol{\\Phi}}(t) + \\mathbf{K}\\,\\boldsymbol{\\Phi}(t) = \\mathbf{0},$$ where $\\mathbf{M}$ is the mass matrix and $\\mathbf{K}$ is the combined stiffness-reaction matrix. The consistent mass matrix uses the exact element integrals, while the lumped mass matrix is formed by row-summing the consistent matrix to create a diagonal approximation. Time integration is performed with the explicit forward Euler method, $$\\boldsymbol{\\Phi}^{n+1} = \\boldsymbol{\\Phi}^n - \\Delta t\\,\\mathbf{M}^{-1}\\mathbf{K}\\,\\boldsymbol{\\Phi}^n.$$\n\nStarting from the weak form and the definitions of the element matrices obtained by standard Galerkin projection with integration by parts and enforcing the Dirichlet boundaries, develop a program that:\n\n- Assembles the interior-block consistent mass matrix $\\mathbf{M}$ and the combined stiffness-reaction matrix $\\mathbf{K}$ for $N$ linear elements on $[0,L]$.\n- Forms the lumped mass matrix $\\mathbf{M}_{\\mathrm{lump}}$ by row-summing $\\mathbf{M}$.\n- Computes the generalized eigenvalues $\\lambda$ from the problem $\\mathbf{K}\\mathbf{u}=\\lambda\\,\\mathbf{M}\\mathbf{u}$ for both the consistent and lumped mass cases, identifies the largest eigenvalue $\\lambda_{\\max}$ in each case, and uses it to characterize the stability limit for explicit Euler via the inequality $0\\le \\Delta t \\lambda \\le 2$ for all eigenvalues.\n- Evolves the semi-discrete system with explicit Euler using either $\\mathbf{M}$ or $\\mathbf{M}_{\\mathrm{lump}}$ up to a specified final time $T$ from the initial condition $\\phi(x,0) = \\sin\\left(\\frac{\\pi x}{L}\\right)$, and measures the modal amplitude along the analytic first mode by the mass inner product with the discrete sine vector. Compare the numerical amplitude to the analytic continuum amplitude $\\exp\\left(-(\\alpha(\\pi/L)^2+\\beta)\\,t\\right)$ at the discrete time $t = n\\Delta t$ actually reached by the time stepper. Use the consistent mass inner product to measure amplitude in both cases so that the accuracy comparison uses a common metric.\n\nYour program must execute three test cases that together serve as a test suite covering a general case, a boundary stability condition, and an edge case related to positivity. All physical parameters must be used with the following units:\n- $L$ in meters (m),\n- $D$ in meters (m),\n- $v$ in meters per second (m/s),\n- $\\Sigma_a$ in inverse meters ($\\mathrm{m}^{-1}$),\n- $T$ and $\\Delta t$ in seconds (s).\n\nThe test suite parameters are:\n\n- Test case $1$ (accuracy, general case):\n  - $L = 1.0\\,\\mathrm{m}$,\n  - $D = 1.0\\times 10^{-4}\\,\\mathrm{m}$,\n  - $\\Sigma_a = 1.0\\times 10^{-2}\\,\\mathrm{m}^{-1}$,\n  - $v = 1000.0\\,\\mathrm{m/s}$,\n  - $N = 40$,\n  - final time $T = 0.5\\,\\mathrm{s}$,\n  - time step chosen as $\\Delta t = \\mu \\cdot \\frac{2}{\\lambda_{\\max,\\mathrm{cons}}}$ with $\\mu = 0.2$, where $\\lambda_{\\max,\\mathrm{cons}}$ is the largest generalized eigenvalue for the consistent mass matrix. Output the pair of absolute errors in the modal amplitude at time $t=n\\Delta t \\le T$: $[\\mathrm{err}_{\\mathrm{cons}}, \\mathrm{err}_{\\mathrm{lump}}]$, where each error is dimensionless.\n\n- Test case $2$ (stability, boundary condition):\n  - $L = 1.0\\,\\mathrm{m}$,\n  - $D = 1.0\\times 10^{-4}\\,\\mathrm{m}$,\n  - $\\Sigma_a = 1.0\\times 10^{-2}\\,\\mathrm{m}^{-1}$,\n  - $v = 1000.0\\,\\mathrm{m/s}$,\n  - $N = 40$,\n  - choose $\\Delta t = \\mu \\cdot \\frac{2}{\\lambda_{\\max,\\mathrm{cons}}}$ with $\\mu = 1.01$. Output the pair of booleans $[\\mathrm{stable}_{\\mathrm{cons}}, \\mathrm{stable}_{\\mathrm{lump}}]$ indicating whether the explicit Euler scheme is stable in each case (true if $\\Delta t \\le 2/\\lambda_{\\max}$ for the corresponding mass matrix, otherwise false).\n\n- Test case $3$ (positivity, edge case):\n  - $L = 1.0\\,\\mathrm{m}$,\n  - $D = 1.0\\times 10^{-4}\\,\\mathrm{m}$,\n  - $\\Sigma_a = 0.0\\,\\mathrm{m}^{-1}$,\n  - $v = 1000.0\\,\\mathrm{m/s}$,\n  - $N = 6$,\n  - final time $T = 0.2\\,\\mathrm{s}$,\n  - choose $\\Delta t = \\mu \\cdot \\frac{2}{\\lambda_{\\max,\\mathrm{cons}}}$ with $\\mu = 0.9$. Evolve both consistent and lumped mass semi-discrete systems and output the pair of booleans $[\\mathrm{positive}_{\\mathrm{cons}}, \\mathrm{positive}_{\\mathrm{lump}}]$ indicating whether all nodal values remained nonnegative (true if no nodal value is negative beyond numerical tolerance; dimensionless).\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets with three sublists, in the order of the test cases described: for example, the output format must be exactly `[[err_cons,err_lump],[stable_cons,stable_lump],[positive_cons,positive_lump]]`.\n\nScientific realism and derivation requirements:\n- Start from the weak form obtained by multiplying the governing equation by a test function and integrating over $[0,L]$, using integration by parts for the diffusion term, and enforce homogeneous Dirichlet boundary conditions.\n- Use standard element matrices for one-dimensional linear finite elements: the consistent element mass matrix and the element diffusion stiffness matrix, and add the reaction term as a mass-like contribution scaled by $\\beta$.\n- Define the lumped mass matrix by row-summing the consistent interior mass matrix to obtain a diagonal approximation.\n- Use the generalized eigenvalue problem $\\mathbf{K}\\mathbf{u}=\\lambda\\,\\mathbf{M}\\mathbf{u}$ to assess the explicit Euler stability limit $\\Delta t \\le \\frac{2}{\\lambda_{\\max}}$ and compute transient modal decay.\n- Report the requested outputs in the exact format, with numerical values dimensionless or booleans as specified, and ensure that physical units are adhered to in the parameter definitions but not required in the outputs.",
            "solution": "The problem statement is assessed to be valid. It is scientifically grounded in the principles of nuclear reactor physics and numerical analysis, well-posed as an initial-boundary value problem, objective, and provides all necessary information for a unique solution.\n\n### 1. Derivation of the Weak Form\n\nThe governing time-dependent one-group neutron diffusion equation is given as:\n$$\n\\frac{\\partial \\phi}{\\partial t} = \\alpha \\frac{\\partial^2 \\phi}{\\partial x^2} - \\beta \\phi, \\quad x \\in [0, L]\n$$\nwith homogeneous Dirichlet boundary conditions $\\phi(0,t) = 0$ and $\\phi(L,t) = 0$. The parameters are defined as $\\alpha = vD$ and $\\beta = v\\Sigma_a$.\n\nTo derive the weak form, we multiply the equation by a test function $w(x)$ from the Sobolev space $H_0^1([0,L])$, which consists of functions that are square-integrable, have square-integrable derivatives, and are zero at the boundaries $x=0$ and $x=L$. We then integrate over the spatial domain $[0,L]$:\n$$\n\\int_0^L w(x) \\frac{\\partial \\phi}{\\partial t} dx = \\int_0^L w(x) \\left( \\alpha \\frac{\\partial^2 \\phi}{\\partial x^2} - \\beta \\phi \\right) dx\n$$\nWe apply integration by parts to the diffusion term:\n$$\n\\int_0^L w(x) \\alpha \\frac{\\partial^2 \\phi}{\\partial x^2} dx = \\left[ w(x) \\alpha \\frac{\\partial \\phi}{\\partial x} \\right]_0^L - \\int_0^L \\alpha \\frac{\\partial w}{\\partial x} \\frac{\\partial \\phi}{\\partial x} dx\n$$\nSince the test function $w(x) \\in H_0^1([0,L])$, we have $w(0) = w(L) = 0$. Therefore, the boundary term $\\left[ w(x) \\alpha \\frac{\\partial \\phi}{\\partial x} \\right]_0^L$ vanishes. The weak formulation is then to find $\\phi(x,t)$ such that for all $w(x) \\in H_0^1([0,L])$:\n$$\n\\int_0^L w \\frac{\\partial \\phi}{\\partial t} dx + \\int_0^L \\alpha \\frac{\\partial w}{\\partial x} \\frac{\\partial \\phi}{\\partial x} dx + \\int_0^L \\beta w \\phi dx = 0\n$$\n\n### 2. Finite Element Discretization\n\nWe discretize the domain $[0,L]$ into $N$ uniform elements of length $h=L/N$. We approximate the scalar flux $\\phi(x,t)$ using piecewise linear basis functions $N_j(x)$:\n$$\n\\phi(x,t) \\approx \\phi_h(x,t) = \\sum_{j=1}^{N-1} \\Phi_j(t) N_j(x)\n$$\nThe sum is over the $N-1$ interior nodes, as the flux at nodes $0$ and $N$ is fixed at $0$ by the boundary conditions. The functions $N_j(x)$ are the standard \"hat\" functions, where $N_j(x)$ is $1$ at node $x_j$ and $0$ at all other nodes.\n\nUsing the Galerkin method, we choose the test functions $w(x)$ to be the basis functions $N_i(x)$ for $i=1, \\dots, N-1$. Substituting the expansion of $\\phi_h(x,t)$ into the weak form gives a system of ordinary differential equations:\n$$\n\\sum_{j=1}^{N-1} \\left( \\int_0^L N_i N_j dx \\right) \\frac{d\\Phi_j}{dt} + \\sum_{j=1}^{N-1} \\left( \\int_0^L \\alpha \\frac{dN_i}{dx}\\frac{dN_j}{dx} dx \\right) \\Phi_j + \\sum_{j=1}^{N-1} \\left( \\int_0^L \\beta N_i N_j dx \\right) \\Phi_j = 0\n$$\nThis system can be written in matrix form as:\n$$\n\\mathbf{M} \\frac{d\\boldsymbol{\\Phi}}{dt} + (\\mathbf{S} + \\beta\\mathbf{M}) \\boldsymbol{\\Phi} = \\mathbf{0}\n$$\nwhere $\\boldsymbol{\\Phi}(t) = [\\Phi_1(t), \\dots, \\Phi_{N-1}(t)]^T$ is the vector of nodal flux values. The matrices are defined by their components:\n-   Consistent Mass Matrix: $M_{ij} = \\int_0^L N_i(x) N_j(x) dx$\n-   Stiffness Matrix: $S_{ij} = \\int_0^L \\alpha \\frac{dN_i(x)}{dx} \\frac{dN_j(x)}{dx} dx$\n\nBy defining the combined stiffness-reaction matrix $\\mathbf{K} = \\mathbf{S} + \\beta\\mathbf{M}$, we arrive at the specified semi-discrete system:\n$$\n\\mathbf{M} \\dot{\\boldsymbol{\\Phi}}(t) + \\mathbf{K} \\boldsymbol{\\Phi}(t) = \\mathbf{0}\n$$\n\n### 3. Matrix Assembly\n\nThe global matrices are assembled from element-level contributions. For a generic element of length $h$, the local basis functions lead to the following element matrices:\n-   Element Mass Matrix: $\\mathbf{m}^e = \\frac{h}{6} \\begin{pmatrix} 2 & 1 \\\\ 1 & 2 \\end{pmatrix}$\n-   Element Stiffness Matrix: $\\mathbf{s}^e = \\frac{\\alpha}{h} \\begin{pmatrix} 1 & -1 \\\\ -1 & 1 \\end{pmatrix}$\n\nAssembling these for the $N-1$ interior degrees of freedom results in tridiagonal global matrices:\n-   Global Consistent Mass Matrix $\\mathbf{M}$:\n    -   $M_{ii} = \\frac{4h}{6} = \\frac{2h}{3}$\n    -   $M_{i, i\\pm 1} = \\frac{h}{6}$\n-   Global Stiffness Matrix $\\mathbf{S}$:\n    -   $S_{ii} = \\frac{2\\alpha}{h}$\n    -   $S_{i, i\\pm 1} = -\\frac{\\alpha}{h}$\n-   Global Stiffness-Reaction Matrix $\\mathbf{K} = \\mathbf{S} + \\beta\\mathbf{M}$:\n    -   $K_{ii} = \\frac{2\\alpha}{h} + \\beta\\frac{2h}{3}$\n    -   $K_{i, i\\pm 1} = -\\frac{\\alpha}{h} + \\beta\\frac{h}{6}$\n\nThe lumped mass matrix $\\mathbf{M}_{\\mathrm{lump}}$ is formed by summing the rows of the consistent mass matrix $\\mathbf{M}$ and placing the sums on the diagonal. For the $(N-1) \\times (N-1)$ interior matrix $\\mathbf{M}$, the row sums are $M_{1, \\mathrm{sum}} = M_{N-1, \\mathrm{sum}} = \\frac{4h}{6} + \\frac{h}{6} = \\frac{5h}{6}$ and $M_{i, \\mathrm{sum}} = \\frac{h}{6} + \\frac{4h}{6} + \\frac{h}{6} = h$ for $i=2, \\dots, N-2$. $\\mathbf{M}_{\\mathrm{lump}}$ is a diagonal matrix with these values.\n\n### 4. Time Integration and Stability Analysis\n\nThe semi-discrete system is integrated in time using the explicit forward Euler method:\n$$\n\\mathbf{M} \\frac{\\boldsymbol{\\Phi}^{n+1} - \\boldsymbol{\\Phi}^n}{\\Delta t} = -\\mathbf{K} \\boldsymbol{\\Phi}^n \\implies \\boldsymbol{\\Phi}^{n+1} = \\boldsymbol{\\Phi}^n - \\Delta t \\mathbf{M}^{-1} \\mathbf{K} \\boldsymbol{\\Phi}^n\n$$\nThe stability of this scheme is governed by the eigenvalues of the system matrix $\\mathbf{A} = \\mathbf{M}^{-1}\\mathbf{K}$. These are found by solving the generalized eigenvalue problem $\\mathbf{K}\\mathbf{u} = \\lambda \\mathbf{M}\\mathbf{u}$. Since $\\mathbf{M}$ and $\\mathbf{K}$ are symmetric and positive definite, the eigenvalues $\\lambda_i$ are real and positive. The stability condition for forward Euler requires that $|1 - \\Delta t \\lambda_i| \\le 1$ for all eigenvalues $\\lambda_i$, which simplifies to $\\Delta t \\lambda_i \\le 2$. This must hold for the largest eigenvalue, leading to the stability limit:\n$$\n\\Delta t \\le \\frac{2}{\\lambda_{\\mathrm{max}}}\n$$\nThis condition must be evaluated for both the consistent mass ($\\mathbf{M}$) and lumped mass ($\\mathbf{M}_{\\mathrm{lump}}$) systems, which yield different maximum eigenvalues.\n\n### 5. Solution Analysis and Implementation\n\n-   **Initial Condition**: The initial nodal vector $\\boldsymbol{\\Phi}^0$ is obtained by evaluating the initial condition $\\phi(x,0) = \\sin(\\frac{\\pi x}{L})$ at the interior nodes: $\\Phi_j(0) = \\sin(\\frac{\\pi x_j}{L})$ for $j=1, \\dots, N-1$. This corresponds to the first eigenmode of the discrete system.\n-   **Modal Amplitude**: The analytic solution for the first mode is $\\phi(x,t) = A(t)\\sin(\\frac{\\pi x}{L})$ where the amplitude is $A(t) = \\exp\\left(-\\left(\\alpha(\\frac{\\pi}{L})^2+\\beta\\right)t\\right)$. The numerical amplitude of the solution vector $\\boldsymbol{\\Phi}^n$ along the first mode shape $\\mathbf{u}_1 = \\boldsymbol{\\Phi}^0$ is measured using the consistent mass inner product $\\langle \\mathbf{v}, \\mathbf{w} \\rangle_{\\mathbf{M}} = \\mathbf{v}^T \\mathbf{M} \\mathbf{w}$:\n    $$\n    A^n_{\\mathrm{num}} = \\frac{\\langle \\boldsymbol{\\Phi}^n, \\mathbf{u}_1 \\rangle_{\\mathbf{M}}}{\\langle \\mathbf{u}_1, \\mathbf{u}_1 \\rangle_{\\mathbf{M}}} = \\frac{(\\boldsymbol{\\Phi}^n)^T \\mathbf{M} \\mathbf{u}_1}{\\mathbf{u}_1^T \\mathbf{M} \\mathbf{u}_1}\n    $$\n    The error is the absolute difference $|A^n_{\\mathrm{num}} - A(t_n)|$ at the final time step.\n-   **Positivity**: For case 3, the time-evolved solution vectors $\\boldsymbol{\\Phi}^n$ are checked at each step. The solution is considered non-positive if any nodal value $\\Phi_j^n$ becomes negative beyond a small numerical tolerance (e.g., $-10^{-12}$). The consistent mass FEM is known to potentially violate positivity under certain conditions even when the scheme is stable, whereas lumping often remedies this.\n\nThe implementation will follow these principles, constructing the matrices, solving the eigenvalue problem to determine time steps and stability, performing the time integration, and finally computing the required metrics for each of the three test cases.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import eigh\n\ndef solve():\n    \"\"\"\n    Solves the 1D time-dependent neutron diffusion equation using FEM\n    and evaluates accuracy, stability, and positivity for three test cases.\n    \"\"\"\n\n    test_cases = [\n        # Case 1: Accuracy\n        {'L': 1.0, 'D': 1.0e-4, 'Sigma_a': 1.0e-2, 'v': 1000.0, 'N': 40, 'T': 0.5, 'mu': 0.2, 'case': 'accuracy'},\n        # Case 2: Stability\n        {'L': 1.0, 'D': 1.0e-4, 'Sigma_a': 1.0e-2, 'v': 1000.0, 'N': 40, 'T': 0, 'mu': 1.01, 'case': 'stability'},\n        # Case 3: Positivity\n        {'L': 1.0, 'D': 1.0e-4, 'Sigma_a': 0.0, 'v': 1000.0, 'N': 6, 'T': 0.2, 'mu': 0.9, 'case': 'positivity'}\n    ]\n\n    all_results = []\n\n    for params in test_cases:\n        L = params['L']\n        D = params['D']\n        Sigma_a = params['Sigma_a']\n        v = params['v']\n        N = params['N']\n        T = params['T']\n        mu = params['mu']\n        case = params['case']\n\n        alpha = v * D\n        beta = v * Sigma_a\n        h = L / N\n        dim = N - 1\n\n        # Assemble M (consistent mass) and K (stiffness-reaction) matrices\n        M_cons = np.zeros((dim, dim))\n        S = np.zeros((dim, dim))\n\n        diag_M = 4.0 * h / 6.0\n        offdiag_M = h / 6.0\n        diag_S = 2.0 * alpha / h\n        offdiag_S = -alpha / h\n\n        np.fill_diagonal(M_cons, diag_M)\n        np.fill_diagonal(S, diag_S)\n\n        if dim > 1:\n            np.fill_diagonal(M_cons[1:], offdiag_M)\n            np.fill_diagonal(M_cons[:, 1:], offdiag_M)\n            np.fill_diagonal(S[1:], offdiag_S)\n            np.fill_diagonal(S[:, 1:], offdiag_S)\n\n        K = S + beta * M_cons\n\n        # Form lumped mass matrix\n        M_lump = np.diag(M_cons.sum(axis=1))\n\n        # Compute generalized eigenvalues and max eigenvalue for both systems\n        eigvals_cons = eigh(K, M_cons, eigvals_only=True)\n        lambda_max_cons = np.max(eigvals_cons)\n\n        eigvals_lump = eigh(K, M_lump, eigvals_only=True)\n        lambda_max_lump = np.max(eigvals_lump)\n        \n        dt = mu * 2.0 / lambda_max_cons\n        \n        # Initial condition\n        nodes = np.linspace(h, L - h, dim)\n        phi0 = np.sin(np.pi * nodes / L)\n\n        if case == 'accuracy':\n            num_steps = int(T / dt)\n            final_t = num_steps * dt\n\n            # Evolve with consistent mass\n            phi_cons = phi0.copy()\n            for _ in range(num_steps):\n                rhs = -K @ phi_cons\n                phi_update = np.linalg.solve(M_cons, rhs)\n                phi_cons += dt * phi_update\n            \n            # Evolve with lumped mass\n            phi_lump = phi0.copy()\n            M_lump_inv = np.diag(1.0 / np.diag(M_lump))\n            for _ in range(num_steps):\n                rhs = -K @ phi_lump\n                phi_update = M_lump_inv @ rhs\n                phi_lump += dt * phi_update\n\n            # Measure modal amplitude and error\n            u1_vec = phi0\n            norm_factor = u1_vec.T @ M_cons @ u1_vec\n            \n            amp_cons_num = (phi_cons.T @ M_cons @ u1_vec) / norm_factor\n            amp_lump_num = (phi_lump.T @ M_cons @ u1_vec) / norm_factor\n\n            lambda_analytic = alpha * (np.pi / L)**2 + beta\n            amp_analytic = np.exp(-lambda_analytic * final_t)\n            \n            err_cons = abs(amp_cons_num - amp_analytic)\n            err_lump = abs(amp_lump_num - amp_analytic)\n            all_results.append([err_cons, err_lump])\n\n        elif case == 'stability':\n            stable_cons = dt * lambda_max_cons = 2.0\n            stable_lump = dt * lambda_max_lump = 2.0\n            all_results.append([stable_cons, stable_lump])\n\n        elif case == 'positivity':\n            num_steps = int(T / dt)\n            \n            # Check positivity for consistent mass\n            positive_cons = True\n            phi_cons = phi0.copy()\n            for _ in range(num_steps):\n                rhs = -K @ phi_cons\n                phi_update = np.linalg.solve(M_cons, rhs)\n                phi_cons += dt * phi_update\n                if np.any(phi_cons  -1e-12):\n                    positive_cons = False\n                    break\n            \n            # Check positivity for lumped mass\n            positive_lump = True\n            phi_lump = phi0.copy()\n            M_lump_inv = np.diag(1.0 / np.diag(M_lump))\n            for _ in range(num_steps):\n                rhs = -K @ phi_lump\n                phi_update = M_lump_inv @ rhs\n                phi_lump += dt * phi_update\n                if np.any(phi_lump  -1e-12):\n                    positive_lump = False\n                    break\n            all_results.append([positive_cons, positive_lump])\n\n    # Format the final output string\n    def format_val(v):\n        if isinstance(v, bool):\n            return str(v).lower()\n        return str(v)\n\n    sublist_strs = []\n    for sublist in all_results:\n        sublist_strs.append(f\"[{','.join(map(format_val, sublist))}]\")\n    \n    print(f\"[{','.join(sublist_strs)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "In many realistic reactor materials, neutrons do not diffuse equally in all directions. This physical reality, known as anisotropy, is modeled using a tensor diffusion coefficient $\\mathbf{D}$. A key consequence of Fick's law, $\\mathbf{J} = -\\mathbf{D} \\nabla \\phi$, is that when $\\mathbf{D}$ is a tensor, the neutron current $\\mathbf{J}$ is no longer necessarily anti-parallel to the flux gradient $\\nabla \\phi$. This coding exercise  challenges you to build a 2D FEM solver that can handle an anisotropic diffusion tensor, allowing you to visualize and quantify this fundamental aspect of neutron transport in complex materials.",
            "id": "4217883",
            "problem": "Consider the steady mono-energetic neutron diffusion approximation on a two-dimensional square domain with anisotropic diffusion. Let $\\Omega = [0,1] \\times [0,1]$ (in meters) be discretized by a conforming triangulation aligned with the Cartesian axes. The steady diffusion model seeks a scalar neutron flux $\\phi: \\Omega \\rightarrow \\mathbb{R}$ that satisfies the strong form\n$$\n-\\nabla \\cdot \\left( \\mathbf{D} \\, \\nabla \\phi \\right) + \\Sigma_a \\, \\phi = Q \\quad \\text{in } \\Omega,\n$$\nwith vacuum boundary conditions\n$$\n\\phi = 0 \\quad \\text{on } \\partial \\Omega.\n$$\nHere $\\mathbf{D} \\in \\mathbb{R}^{2 \\times 2}$ is the symmetric positive definite diffusion tensor, $\\Sigma_a$ is the macroscopic absorption cross section, and $Q$ is a volumetric source. The particle current density is defined by Fick’s law as\n$$\n\\mathbf{J} = -\\mathbf{D} \\, \\nabla \\phi.\n$$\nYou are to use a Continuous Finite Element Method (CFEM) with first-order Lagrange basis (piecewise linear, globally continuous) on a structured triangulation to approximate $\\phi$. Start from the neutron balance law and the definition of particle current, derive the weak formulation, and outline the assembly of the CFEM system. Assume constant coefficients $\\mathbf{D}$, $\\Sigma_a$, and $Q$ over $\\Omega$. Impose the Dirichlet boundary condition $\\phi=0$ on $\\partial \\Omega$. Use a uniform structured mesh with $N_x=N_y=20$ subdivisions per spatial direction, splitting each square into two congruent triangles aligned with the mesh.\n\nTo analyze anisotropy effects on current directions, consider diffusion tensors with principal directions aligned with the mesh, that is,\n$$\n\\mathbf{D} = \\begin{bmatrix} D_x  0 \\\\ 0  D_y \\end{bmatrix},\n$$\nwith $D_x0$ and $D_y0$. For each triangular element, compute the constant elementwise gradient $\\nabla \\phi_e$ and the corresponding elementwise current $\\mathbf{J}_e = -\\mathbf{D} \\, \\nabla \\phi_e$. Define the elementwise misalignment angle $\\theta_e$ between $\\mathbf{J}_e$ and $-\\nabla \\phi_e$ by\n$$\n\\theta_e = \\arccos\\left( \\frac{\\mathbf{J}_e \\cdot \\left(-\\nabla \\phi_e\\right)}{\\|\\mathbf{J}_e\\|_2 \\, \\|\\nabla \\phi_e\\|_2} \\right) \\quad \\text{(in radians)}.\n$$\nExclude any element $e$ from averaging if $\\|\\nabla \\phi_e\\|_2  10^{-12}$ to avoid division by zero. For each parameter set, report the mean misalignment angle over all included elements, expressed in degrees, rounded to six digits after the decimal point.\n\nUse the following model parameters (scientifically plausible for demonstration): $\\Sigma_a = 0.1 \\ \\text{m}^{-1}$ and $Q = 1.0 \\ \\text{neutrons} \\cdot \\text{m}^{-3} \\cdot \\text{s}^{-1}$. Consider four test cases that vary the anisotropy ratio while keeping principal directions aligned with the mesh:\n- Test $1$: $D_x=1.0$, $D_y=1.0$ (isotropic baseline).\n- Test $2$: $D_x=5.0$, $D_y=1.0$ (moderate anisotropy).\n- Test $3$: $D_x=0.2$, $D_y=1.0$ (moderate anisotropy inverted).\n- Test $4$: $D_x=10.0$, $D_y=1.0$ (strong anisotropy).\n\nAngle unit requirement: All reported angles must be in degrees. The final output of your program must be a single line containing a Python-style list of the four mean misalignment angles corresponding to the tests in the order given above, each rounded to six digits after the decimal point, for example,\n$[\\alpha_1,\\alpha_2,\\alpha_3,\\alpha_4]$,\nwhere each $\\alpha_i$ is a floating-point number.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[result1,result2,result3,result4]$).",
            "solution": "The user has provided a valid problem statement. I will proceed with the solution.\n\n### 1. Theoretical Formulation\n\nThe problem requires solving the steady-state, mono-energetic neutron diffusion equation on a two-dimensional square domain $\\Omega = [0,1] \\times [0,1]$.\n\n**Strong Form:**\nThe governing partial differential equation (PDE) is:\n$$\n-\\nabla \\cdot \\left( \\mathbf{D} \\, \\nabla \\phi \\right) + \\Sigma_a \\, \\phi = Q \\quad \\text{in } \\Omega\n$$\nwith homogeneous Dirichlet (vacuum) boundary conditions:\n$$\n\\phi = 0 \\quad \\text{on } \\partial \\Omega\n$$\nHere, $\\phi$ is the scalar neutron flux, $\\mathbf{D}$ is the anisotropic diffusion tensor, $\\Sigma_a$ is the macroscopic absorption cross-section, and $Q$ is the volumetric neutron source. All coefficients are assumed to be constant over the domain.\n\n**Weak Formulation:**\nTo derive the weak formulation, we multiply the strong form by a test function $v$ belonging to the Sobolev space $H_0^1(\\Omega)$, which consists of functions that are square-integrable, have square-integrable first derivatives, and are zero on the boundary $\\partial\\Omega$. We then integrate over the domain $\\Omega$:\n$$\n\\int_\\Omega \\left( -\\nabla \\cdot (\\mathbf{D} \\nabla \\phi) \\right) v \\, d\\Omega + \\int_\\Omega (\\Sigma_a \\phi) v \\, d\\Omega = \\int_\\Omega Q v \\, d\\Omega\n$$\nApplying integration by parts (Green's first identity) to the diffusion term gives:\n$$\n\\int_\\Omega (\\mathbf{D} \\nabla \\phi) \\cdot \\nabla v \\, d\\Omega - \\int_{\\partial\\Omega} v (\\mathbf{D} \\nabla \\phi) \\cdot \\mathbf{n} \\, dS + \\int_\\Omega \\Sigma_a \\phi v \\, d\\Omega = \\int_\\Omega Q v \\, d\\Omega\n$$\nSince the test function $v$ is zero on the boundary $\\partial\\Omega$, the boundary integral vanishes. This yields the weak formulation: Find $\\phi \\in H_0^1(\\Omega)$ such that for all $v \\in H_0^1(\\Omega)$:\n$$\n\\int_\\Omega (\\mathbf{D} \\nabla \\phi) \\cdot \\nabla v \\, d\\Omega + \\int_\\Omega \\Sigma_a \\phi v \\, d\\Omega = \\int_\\Omega Q v \\, d\\Omega\n$$\nThis equation is of the form $a(\\phi, v) = L(v)$, where $a(\\cdot, \\cdot)$ is a bilinear form representing diffusion and absorption, and $L(\\cdot)$ is a linear form representing the source.\n\n### 2. Finite Element Discretization\n\nWe discretize the domain $\\Omega$ with a structured triangular mesh. The solution $\\phi$ is approximated by a function $\\phi_h$ which is a linear combination of first-order Lagrange basis functions $N_i(x,y)$:\n$$\n\\phi_h(x, y) = \\sum_j \\phi_j N_j(x, y)\n$$\nwhere $\\phi_j$ are the unknown flux values at the mesh nodes and the sum is over all nodes for which the flux is unknown (i.e., interior nodes). The basis function $N_j$ is a \"hat\" function, equal to $1$ at node $j$ and $0$ at all other nodes.\n\nSubstituting $\\phi_h$ into the weak form and choosing the test functions to be the basis functions $N_i$ (Galerkin method), we obtain a system of linear algebraic equations:\n$$\n\\mathbf{K} \\boldsymbol{\\phi} = \\mathbf{f}\n$$\nwhere $\\boldsymbol{\\phi}$ is the vector of unknown nodal flux values. The entries of the global stiffness matrix $\\mathbf{K}$ and the global load vector $\\mathbf{f}$ are given by:\n$$\nK_{ij} = a(N_j, N_i) = \\int_\\Omega (\\mathbf{D} \\nabla N_j) \\cdot \\nabla N_i \\, d\\Omega + \\int_\\Omega \\Sigma_a N_j N_i \\, d\\Omega\n$$\n$$\nf_i = L(N_i) = \\int_\\Omega Q N_i \\, d\\Omega\n$$\n\n### 3. System Assembly\n\nThe global matrix and vector are assembled by summing contributions from each element $e$ in the mesh. For a single triangular element $e$, the local stiffness matrix $\\mathbf{K}^e$ and local load vector $\\mathbf{f}^e$ are computed.\n\nThe element stiffness matrix $\\mathbf{K}^e$ has two components:\n1.  **Diffusion (Stiffness) part**: Since $\\mathbf{D}$ is constant and the gradients of linear basis functions are constant over an element, this term is:\n    $$\n    (\\mathbf{K}^e_{\\text{stiff}})_{ij} = (\\nabla N_i^e)^T \\mathbf{D} (\\nabla N_j^e) A_e\n    $$\n    where $\\nabla N_i^e$ is the constant gradient of the $i$-th local basis function and $A_e$ is the element area. For a diagonal tensor $\\mathbf{D} = \\text{diag}(D_x, D_y)$, this can be calculated using geometric properties of the triangle.\n2.  **Absorption (Mass) part**: The integral of the product of linear basis functions over a triangle is known:\n    $$\n    (\\mathbf{K}^e_{\\text{mass}})_{ij} = \\Sigma_a \\int_e N_j^e N_i^e \\, d\\Omega = \\frac{\\Sigma_a A_e}{12} (1 + \\delta_{ij})\n    $$\n\nThe element load vector $\\mathbf{f}^e$ is computed as:\n$$\n(f^e)_i = Q \\int_e N_i^e \\, d\\Omega = \\frac{Q A_e}{3}\n$$\nThese local contributions are then assembled into the global system, considering only the interior (free) degrees of freedom due to the homogeneous Dirichlet boundary condition. The resulting sparse, symmetric, positive-definite linear system is then solved for the nodal flux values.\n\n### 4. Post-processing and Misalignment Angle Calculation\n\nOnce the nodal flux vector $\\boldsymbol{\\phi}$ is found, the approximate solution $\\phi_h$ is known. For each element $e$, the flux gradient $\\nabla \\phi_e$ is constant and is calculated as a linear combination of the basis function gradients weighted by the nodal flux values of that element:\n$$\n\\nabla \\phi_e = \\sum_{j=1}^3 \\phi_j^e \\nabla N_j^e\n$$\nThe element-wise neutron current density $\\mathbf{J}_e$ is then computed using Fick's Law:\n$$\n\\mathbf{J}_e = -\\mathbf{D} \\nabla \\phi_e\n$$\nThe misalignment angle $\\theta_e$ between the current $\\mathbf{J}_e$ and the negative gradient $-\\nabla \\phi_e$ quantifies the effect of diffusion anisotropy. It is calculated using the dot product formula:\n$$\n\\theta_e = \\arccos\\left( \\frac{\\mathbf{J}_e \\cdot \\left(-\\nabla \\phi_e\\right)}{\\|\\mathbf{J}_e\\|_2 \\, \\|\\nabla \\phi_e\\|_2} \\right) = \\arccos\\left( \\frac{(\\nabla\\phi_e)^T \\mathbf{D} (\\nabla\\phi_e)}{\\|\\mathbf{D} \\nabla\\phi_e\\|_2 \\, \\|\\nabla\\phi_e\\|_2} \\right)\n$$\nElements with a near-zero gradient norm $(\\|\\nabla \\phi_e\\|_2  10^{-12})$ are excluded. The mean of these angles (converted to degrees) over all included elements is computed for each test case.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import lil_matrix\nfrom scipy.sparse.linalg import spsolve\n\ndef calculate_mean_angle(Dx, Dy):\n    \"\"\"\n    Solves the 2D neutron diffusion equation using CFEM and calculates the mean\n    misalignment angle between current and negative flux gradient.\n\n    Args:\n        Dx (float): Diffusion coefficient in the x-direction.\n        Dy (float): Diffusion coefficient in the y-direction.\n\n    Returns:\n        float: The mean misalignment angle in degrees.\n    \"\"\"\n    # Model and Mesh Parameters\n    Nx, Ny = 20, 20\n    Lx, Ly = 1.0, 1.0\n    Sigma_a = 0.1\n    Q = 1.0\n    D_tensor = np.array([[Dx, 0], [0, Dy]])\n\n    # 1. Mesh Generation\n    hx, hy = Lx / Nx, Ly / Ny\n    num_nodes = (Nx + 1) * (Ny + 1)\n    nodes = np.array([[i * hx, j * hy] for j in range(Ny + 1) for i in range(Nx + 1)])\n\n    elements = []\n    for j in range(Ny):\n        for i in range(Nx):\n            n1 = j * (Nx + 1) + i          # bottom-left\n            n2 = j * (Nx + 1) + (i + 1)    # bottom-right\n            n3 = (j + 1) * (Nx + 1) + i      # top-left\n            n4 = (j + 1) * (Nx + 1) + (i + 1)  # top-right\n            # Split square into two triangles along the main diagonal\n            elements.append([n1, n2, n4])\n            elements.append([n1, n4, n3])\n    elements = np.array(elements, dtype=np.int32)\n\n    # 2. Map global indices to interior degrees of freedom\n    num_dof = (Nx - 1) * (Ny - 1)\n    node_map = -np.ones(num_nodes, dtype=int)\n    dof_idx = 0\n    for j in range(1, Ny):\n        for i in range(1, Nx):\n            glob_idx = j * (Nx + 1) + i\n            node_map[glob_idx] = dof_idx\n            dof_idx += 1\n\n    # 3. Assembly of the linear system\n    K = lil_matrix((num_dof, num_dof), dtype=np.float64)\n    f = np.zeros(num_dof, dtype=np.float64)\n\n    mass_local_template = (Sigma_a / 12.0) * np.array([[2, 1, 1], [1, 2, 1], [1, 1, 2]], dtype=np.float64)\n\n    for elem_nodes in elements:\n        v = nodes[elem_nodes]\n        p1, p2, p3 = v[0], v[1], v[2]\n        \n        area = 0.5 * abs(p1[0] * (p2[1] - p3[1]) + p2[0] * (p3[1] - p1[1]) + p3[0] * (p1[1] - p2[1]))\n        if area  1e-15: continue\n        \n        b = np.array([p2[1] - p3[1], p3[1] - p1[1], p1[1] - p2[1]])\n        c = np.array([p3[0] - p2[0], p1[0] - p3[0], p2[0] - p1[0]])\n        \n        K_stiff_local = (1 / (4 * area)) * (Dx * np.outer(b, b) + Dy * np.outer(c, c))\n        K_mass_local = mass_local_template * area\n        K_local = K_stiff_local + K_mass_local\n        \n        f_local = (Q * area / 3.0) * np.ones(3)\n        \n        for r_local in range(3):\n            glob_r = elem_nodes[r_local]\n            dof_r = node_map[glob_r]\n            if dof_r != -1:  # If row corresponds to an interior node\n                f[dof_r] += f_local[r_local]\n                for c_local in range(3):\n                    glob_c = elem_nodes[c_local]\n                    dof_c = node_map[glob_c]\n                    if dof_c != -1:  # If col corresponds to an interior node\n                        K[dof_r, dof_c] += K_local[r_local, c_local]\n\n    # 4. Solve the linear system\n    K_csc = K.tocsc()\n    phi_interior = spsolve(K_csc, f)\n    \n    phi_full = np.zeros(num_nodes)\n    phi_full[node_map != -1] = phi_interior\n\n    # 5. Post-processing to compute misalignment angles\n    angles_rad = []\n    for elem_nodes in elements:\n        v = nodes[elem_nodes]\n        p1, p2, p3 = v[0], v[1], v[2]\n        \n        area = 0.5 * abs(p1[0] * (p2[1] - p3[1]) + p2[0] * (p3[1] - p1[1]) + p3[0] * (p1[1] - p2[1]))\n        if area  1e-15: continue\n        \n        b = np.array([p2[1] - p3[1], p3[1] - p1[1], p1[1] - p2[1]])\n        c = np.array([p3[0] - p2[0], p1[0] - p3[0], p2[0] - p1[0]])\n        \n        elem_phi_vals = phi_full[elem_nodes]\n        \n        grad_phi_x = np.dot(elem_phi_vals, b) / (2 * area)\n        grad_phi_y = np.dot(elem_phi_vals, c) / (2 * area)\n        grad_phi = np.array([grad_phi_x, grad_phi_y])\n        \n        norm_grad = np.linalg.norm(grad_phi)\n        \n        if norm_grad  1e-12:\n            continue\n            \n        J = -D_tensor @ grad_phi\n        norm_J = np.linalg.norm(J)\n        \n        if norm_J  1e-12:\n            continue\n        \n        cos_theta = (grad_phi @ D_tensor @ grad_phi) / (norm_J * norm_grad)\n        \n        # Clip to handle potential floating point inaccuracies\n        cos_theta = np.clip(cos_theta, -1.0, 1.0)\n        \n        angle_rad = np.arccos(cos_theta)\n        angles_rad.append(angle_rad)\n        \n    mean_angle_rad = np.mean(angles_rad) if angles_rad else 0.0\n    mean_angle_deg = np.degrees(mean_angle_rad)\n    \n    return mean_angle_deg\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        (1.0, 1.0),  # Test 1: Isotropic\n        (5.0, 1.0),  # Test 2: Moderate anisotropy\n        (0.2, 1.0),  # Test 3: Moderate anisotropy inverted\n        (10.0, 1.0), # Test 4: Strong anisotropy\n    ]\n\n    results = []\n    for Dx, Dy in test_cases:\n        result = calculate_mean_angle(Dx, Dy)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join([f'{r:.6f}' for r in results])}]\")\n\nsolve()\n\n```"
        }
    ]
}