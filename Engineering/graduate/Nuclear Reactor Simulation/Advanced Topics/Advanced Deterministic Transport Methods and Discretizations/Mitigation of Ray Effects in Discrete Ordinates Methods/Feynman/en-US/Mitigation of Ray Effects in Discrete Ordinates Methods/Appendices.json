{
    "hands_on_practices": [
        {
            "introduction": "The first line of defense against ray effects lies in the fundamental design of the angular discretization itself. Certain discrete directions, particularly those aligned with the Cartesian axes, can act as conduits for numerical errors and exacerbate the artificial streaking characteristic of ray effects. This exercise challenges you to explore how modern quadrature sets are explicitly constructed to prevent this issue by analyzing the symbolic structure of a standard $S_{12}$ level-symmetric quadrature . By examining its definitional constraints, you will verify a key design principle used to build more robust discrete ordinates schemes.",
            "id": "4235200",
            "problem": "Consider the three-dimensional Discrete Ordinates method (order-$N$ level-symmetric quadrature, denoted $S_N$) for neutron transport in nuclear reactor simulation. Angular integration is over the unit sphere using direction cosines $(\\mu,\\eta,\\xi)$ with $\\mu^{2}+\\eta^{2}+\\xi^{2}=1$, and quadrature weights are strictly positive. A level-symmetric quadrature partitions the first-octant directions into levels whose members are generated by permutations of a level-defining triple and extended to the full sphere by sign symmetries, so that the full quadrature has $N(N+2)$ directions. The construction is constrained by the exactness of angular moments up to degree $N-1$ (equivalently, orthogonality conditions with spherical harmonics up to total degree $N-1$), and by the normalization and symmetry of the quadrature.\n\nYou are tasked to construct an $S_{12}$ level-symmetric quadrature symbolically, enumerating explicit first-octant direction cosines and their multiplicities without computing numerical abscissae or weights. Use the following scientifically standard structure:\n\n- Let $L=\\frac{N}{2}=6$ denote the number of levels in the first octant.\n- For $5$ of the levels (type-$A$), define triples of the form $(\\alpha_{\\ell},\\alpha_{\\ell},\\beta_{\\ell})$ with $\\ell\\in\\{1,2,3,4,5\\}$, where $\\alpha_{\\ell},\\beta_{\\ell}\\in(0,1)$ and $2\\alpha_{\\ell}^{2}+\\beta_{\\ell}^{2}=1$. Each type-$A$ level produces $3$ distinct first-octant directions via permutations of the entries.\n- For $1$ of the levels (type-$B$), define a triple $(\\gamma_{1},\\gamma_{2},\\gamma_{3})$ with $\\gamma_{1},\\gamma_{2},\\gamma_{3}\\in(0,1)$, all distinct, and $\\gamma_{1}^{2}+\\gamma_{2}^{2}+\\gamma_{3}^{2}=1$. The type-$B$ level produces $6$ distinct first-octant directions via all permutations.\n- Assign a single weight $w_{\\ell}>0$ to each level, used for each permutation in that level. Impose the moment constraints that ensure exactness for all monomials $\\mu^{r}\\eta^{s}\\xi^{t}$ with $r+s+t\\leq N-1$ under the surface-area measure on the sphere, together with the symmetry conditions implied by sign changes and permutations.\n\nThis construction yields $3\\times 5+6=21$ first-octant directions and $N(N+2)=168$ total directions after applying sign symmetries.\n\nUsing only the symbolic construction above and the defining constraints of level-symmetric quadrature, identify whether any of the constructed directions align with the Cartesian axes (that is, whether any direction has $(\\mu,\\eta,\\xi)$ equal to $(\\pm 1,0,0)$, $(0,\\pm 1,0)$, or $(0,0,\\pm 1)$), which are known to exacerbate ray artifacts in Discrete Ordinates transport.\n\nCompute the total number of axis-aligned directions contained in the full $S_{12}$ level-symmetric quadrature as constructed. Express your final answer as an integer with no units. No rounding is required.",
            "solution": "The objective is to determine the total number of axis-aligned directions within a specifically constructed $S_{12}$ level-symmetric quadrature. An axis-aligned direction is defined as a vector where two of the three Cartesian components are zero. On the unit sphere, these directions are $(\\pm 1, 0, 0)$, $(0, \\pm 1, 0)$, and $(0, 0, \\pm 1)$. There are $6$ such directions in total.\n\nThe problem describes the construction of the full quadrature set, which contains $N(N+2) = 12(12+2) = 168$ directions. This set is generated from a basis of $21$ unique directions in the first octant. The generation process involves applying sign symmetries to these first-octant directions. Let a first-octant direction be denoted by a triple of direction cosines $(\\mu_0, \\eta_0, \\xi_0)$, where by definition of the first octant, $\\mu_0 \\ge 0$, $\\eta_0 \\ge 0$, and $\\xi_0 \\ge 0$. The full set of directions generated from this single first-octant direction is given by the set $\\{(\\pm \\mu_0, \\pm \\eta_0, \\pm \\xi_0)\\}$, with the number of unique directions depending on whether any of the components are zero.\n\nFor a direction $(\\mu, \\eta, \\xi)$ in the full quadrature to be axis-aligned, for instance $(\\pm 1, 0, 0)$, its components must have absolute values $(|\\mu|, |\\eta|, |\\xi|) = (1, 0, 0)$. Since the absolute values of the components are invariant under sign changes, this requires that the corresponding first-octant direction $(\\mu_0, \\eta_0, \\xi_0)$ must be a permutation of $(1, 0, 0)$. Therefore, the core of the problem is to ascertain whether any of the specified first-octant directions can have components equal to $0$ or $1$.\n\nThe construction of the first-octant directions is partitioned into two types of levels.\n\n1.  **Type-A Levels**: There are $5$ such levels, for $\\ell \\in \\{1, 2, 3, 4, 5\\}$. The direction cosines for any direction in these levels are permutations of the triple $(\\alpha_{\\ell}, \\alpha_{\\ell}, \\beta_{\\ell})$. The problem explicitly states the constraints on these values: $\\alpha_{\\ell} \\in (0,1)$ and $\\beta_{\\ell} \\in (0,1)$. The notation $(0,1)$ represents the open interval, meaning $0 < \\alpha_{\\ell} < 1$ and $0 < \\beta_{\\ell} < 1$. Consequently, none of the components $\\alpha_{\\ell}$ or $\\beta_{\\ell}$ can be equal to $0$ or $1$. Thus, no direction derived from a Type-A level can be a permutation of $(1,0,0)$.\n\n2.  **Type-B Level**: There is $1$ such level. The direction cosines for any direction in this level are permutations of the triple $(\\gamma_1, \\gamma_2, \\gamma_3)$. The problem states the constraints on these values: $\\gamma_{1}, \\gamma_{2}, \\gamma_{3} \\in (0,1)$, and they are all distinct. Again, this means $0 < \\gamma_i < 1$ for $i \\in \\{1, 2, 3\\}$. As with the Type-A levels, none of the components can be equal to $0$ or $1$. Thus, no direction derived from the Type-B level can be a permutation of $(1,0,0)$.\n\nThe entire set of first-octant directions is composed exclusively of directions from Type-A and Type-B levels. The constraints provided in the problem statement, $\\alpha_{\\ell}, \\beta_{\\ell}, \\gamma_i \\in (0,1)$, are definitive. They strictly forbid any component of a first-octant direction from being $0$ or $1$.\n\nLet $(\\mu_0, \\eta_0, \\xi_0)$ be any of the $21$ first-octant directions. Based on the analysis above, we have $\\mu_0 > 0$, $\\eta_0 > 0$, and $\\xi_0 > 0$. When generating the full quadrature by applying sign symmetries, we obtain directions of the form $(\\pm \\mu_0, \\pm \\eta_0, \\pm \\xi_0)$. Since $\\mu_0, \\eta_0, \\xi_0$ are all non-zero, none of the components of these generated directions can be zero.\n\nAn axis-aligned direction, however, must have two zero components. Since no direction in the entire $S_{12}$ set as constructed can have any zero components, it is impossible for any of them to be axis-aligned. This feature of constructing quadrature sets with components strictly within $(0,1)$ is intentional in many modern Discrete Ordinates methods, precisely to avoid placing ordinates on the axes and thereby mitigate ray effects.\n\nTherefore, the total number of axis-aligned directions in the specified $S_{12}$ quadrature is $0$.",
            "answer": "$$\\boxed{0}$$"
        },
        {
            "introduction": "While discretization choices are crucial, the characteristics of the physical problem being modeled also play a significant role in the severity of ray effects. Highly localized phenomena, often represented by idealized point sources for mathematical convenience, are a primary trigger for these artifacts. This hands-on programming exercise allows you to quantitatively demonstrate how a more physically realistic, distributed volumetric source inherently mitigates ray effects . By comparing the angular variance of the flux from a point source versus a volumetric source, you will see how spreading the source's influence across multiple lines-of-sight naturally leads to a smoother, more accurate angular flux distribution.",
            "id": "4235231",
            "problem": "Consider the steady-state, monoenergetic linear transport equation in a homogeneous, infinite medium with pure absorption (no scattering), expressed as $\\boldsymbol{\\Omega}\\cdot\\nabla \\psi(\\mathbf{r},\\boldsymbol{\\Omega}) + \\Sigma_t \\psi(\\mathbf{r},\\boldsymbol{\\Omega}) = q(\\mathbf{r})/(4\\pi)$, where $\\psi(\\mathbf{r},\\boldsymbol{\\Omega})$ is the angular flux, $\\Sigma_t$ is the total macroscopic cross section, $\\boldsymbol{\\Omega}$ is the unit direction vector, and $q(\\mathbf{r})$ is an isotropic source density. In the discrete ordinates ($S_N$) method, ray effects manifest as artificial angular streaking caused by concentrating flux into a limited set of discrete directions. A distributed volumetric source can mitigate these effects by spreading directional contributions over many ordinates. Your task is to demonstrate this mitigation quantitatively by computing the angular variance of $\\psi(\\boldsymbol{\\Omega})$ at a fixed observation location for two source configurations: an isotropic point source and a uniform volumetric cube source. Work in three-dimensional space.\n\nFundamental base and assumptions:\n- Use the linear transport equation above as the base model with pure absorption, zero scattering, and an infinite medium.\n- The isotropic point source has total emission rate $S_0$ in particles per second, located at the origin.\n- The uniform volumetric source occupies a cube of side $a$ centered at the origin and has strength $s_v$ in particles per cubic centimeter per second, chosen so that the total emission rate equals the point source, i.e., $s_v a^3 = S_0$.\n- The observation point is at position $\\mathbf{r}_{\\text{obs}}$ and is outside the cube for all test cases.\n\nDiscrete approximation and algorithmic definitions:\n1. Discrete ordinates quadrature:\n   - Construct a product quadrature over the unit sphere by combining Gauss–Legendre nodes in $\\mu = \\cos\\theta$ on $[-1, 1]$ with $N_\\mu$ nodes and weights, and uniform azimuthal angles $\\phi$ over $[0, 2\\pi)$ with $N_\\phi$ equally spaced nodes. The direction vectors are $\\boldsymbol{\\Omega}_n = (\\sin\\theta_i\\cos\\phi_j, \\sin\\theta_i\\sin\\phi_j, \\mu_i)$ with weights $w_n = w^{(\\mu)}_i \\cdot \\Delta\\phi$, where $\\Delta\\phi = 2\\pi/N_\\phi$ and $w^{(\\mu)}_i$ are the Gauss–Legendre weights. The weights must sum to $4\\pi$.\n   - Angles must be in radians.\n\n2. Angular flux construction at $\\mathbf{r}_{\\text{obs}}$:\n   - For a source point at position $\\mathbf{r}_s$, its contribution magnitude to the angular flux at $\\mathbf{r}_{\\text{obs}}$ along the line-of-sight direction $\\widehat{\\mathbf{d}} = (\\mathbf{r}_{\\text{obs}} - \\mathbf{r}_s)/\\lVert \\mathbf{r}_{\\text{obs}} - \\mathbf{r}_s\\rVert$ and path length $L = \\lVert \\mathbf{r}_{\\text{obs}} - \\mathbf{r}_s\\rVert$ is given by the line attenuation and geometric dilution: $A(\\mathbf{r}_s) = \\left(\\frac{Q_s}{4\\pi}\\right) \\frac{e^{-\\Sigma_t L}}{L^2}$, where $Q_s$ is the emission rate assigned to the source point (for the point source, $Q_s = S_0$ and there is one source point; for the volumetric source discretized into $M$ subpoints, $Q_s = S_0/M$ for each subpoint).\n   - In the discrete ordinates approximation, assign the contribution from $\\mathbf{r}_s$ to the single quadrature direction $\\boldsymbol{\\Omega}_{n^*}$ that minimizes the angular separation to $\\widehat{\\mathbf{d}}$; equivalently, choose $n^* = \\underset{n}{\\arg\\max}\\, \\boldsymbol{\\Omega}_n\\cdot \\widehat{\\mathbf{d}}$. Accumulate $A(\\mathbf{r}_s)$ into $\\psi_n$ for $n=n^*$.\n   - For the point source configuration, there is a single $\\mathbf{r}_s = \\mathbf{0}$.\n   - For the volumetric configuration, approximate the uniform source by a Cartesian grid of $M = N^3$ points, centered within the cube, uniformly spaced, covering the cube of side $a$.\n\n3. Angular variance metric:\n   - Let $\\{\\psi_n\\}_{n=1}^N$ be the constructed discrete angular flux values and $\\{w_n\\}_{n=1}^N$ the corresponding quadrature weights, with $\\sum_{n=1}^N w_n = 4\\pi$.\n   - Compute the weighted mean $\\mu_\\psi = \\frac{1}{4\\pi}\\sum_{n=1}^N w_n \\psi_n$.\n   - Compute the weighted variance $V_\\psi = \\frac{1}{4\\pi}\\sum_{n=1}^N w_n \\left(\\psi_n - \\mu_\\psi\\right)^2$.\n   - Report the normalized angular variance (coefficient of variation squared) $C = \\frac{V_\\psi}{\\mu_\\psi^2}$, which is dimensionless.\n   - Define the variance reduction ratio $\\rho = \\frac{C_{\\text{vol}}}{C_{\\text{point}}}$, where $C_{\\text{vol}}$ and $C_{\\text{point}}$ are the normalized variances for the volumetric and point sources, respectively. Values $\\rho < 1$ indicate mitigation of ray effects.\n\nUnits and numerical details:\n- Lengths must be in centimeters (cm).\n- Cross section $\\Sigma_t$ must be in inverse centimeters ($\\text{cm}^{-1}$).\n- Source emission rate $S_0$ must be in particles per second ($\\text{s}^{-1}$), but you should set $S_0 = 1$ so the final outputs are dimensionless and independent of arbitrary scaling.\n- Angles must be in radians.\n\nTest suite:\nFor each test case, apply the algorithm above to compute $\\rho$ at the given observation point. Use the specified quadrature sizes and volumetric cube parameters. Aggregate the results for all test cases into a single output line as specified below.\n\n- Test case $1$ (general case, moderate absorption, medium quadrature):\n  - $\\Sigma_t = 0.1\\,\\text{cm}^{-1}$,\n  - $\\mathbf{r}_{\\text{obs}} = (10.0,\\,4.0,\\,2.0)\\,\\text{cm}$,\n  - $N_\\mu = 8$, $N_\\phi = 16$,\n  - Cube side $a = 6.0\\,\\text{cm}$,\n  - Volumetric discretization $M = 1000$ (i.e., $N=10$ per side).\n\n- Test case $2$ (coarse quadrature, stronger ray effects expected):\n  - $\\Sigma_t = 0.1\\,\\text{cm}^{-1}$,\n  - $\\mathbf{r}_{\\text{obs}} = (10.0,\\,4.0,\\,2.0)\\,\\text{cm}$,\n  - $N_\\mu = 4$, $N_\\phi = 8$,\n  - Cube side $a = 6.0\\,\\text{cm}$,\n  - Volumetric discretization $M = 216$ (i.e., $N=6$ per side).\n\n- Test case $3$ (near-point volumetric source, boundary condition):\n  - $\\Sigma_t = 0.1\\,\\text{cm}^{-1}$,\n  - $\\mathbf{r}_{\\text{obs}} = (10.0,\\,4.0,\\,2.0)\\,\\text{cm}$,\n  - $N_\\mu = 8$, $N_\\phi = 16$,\n  - Cube side $a = 0.5\\,\\text{cm}$,\n  - Volumetric discretization $M = 1000$ (i.e., $N=10$ per side).\n\n- Test case $4$ (higher absorption, robustness check):\n  - $\\Sigma_t = 0.7\\,\\text{cm}^{-1}$,\n  - $\\mathbf{r}_{\\text{obs}} = (10.0,\\,4.0,\\,2.0)\\,\\text{cm}$,\n  - $N_\\mu = 8$, $N_\\phi = 16$,\n  - Cube side $a = 6.0\\,\\text{cm}$,\n  - Volumetric discretization $M = 1000$ (i.e., $N=10$ per side).\n\nFinal output format:\n- Your program should produce a single line of output containing the variance reduction ratios for the above four test cases, as a comma-separated list enclosed in square brackets, e.g., $\\left[\\rho_1,\\rho_2,\\rho_3,\\rho_4\\right]$. Each $\\rho_i$ must be a floating-point number (dimensionless). The program must run as-is, with no user input, and must compute all quantities internally following the stated definitions and units.",
            "solution": "The solution proceeds by first constructing a discrete representation of the angular domain and then simulating the particle transport from two different source configurations to a fixed observation point. The core idea is to show that a spatially distributed source deposits flux across a wider range of discrete angular directions, thereby reducing the angular variance compared to a highly localized point source.\n\nThe first step is the discretization of the continuous angular variable $\\boldsymbol{\\Omega}$ into a finite set of $N = N_\\mu \\times N_\\phi$ directions $\\{\\boldsymbol{\\Omega}_n\\}$ with corresponding weights $\\{w_n\\}$. A product quadrature is employed. The polar angle cosine $\\mu = \\cos\\theta \\in [-1, 1]$ is discretized using an $N_\\mu$-point Gauss-Legendre quadrature, yielding a set of nodes $\\{\\mu_i\\}_{i=1}^{N_\\mu}$ and weights $\\{w^{(\\mu)}_i\\}_{i=1}^{N_\\mu}$. The polar angles are then $\\theta_i = \\arccos(\\mu_i)$. The sum of these weights is $\\sum_{i=1}^{N_\\mu} w^{(\\mu)}_i = 2$. The azimuthal angle $\\phi \\in [0, 2\\pi)$ is discretized into $N_\\phi$ uniformly spaced angles $\\{\\phi_j\\}_{j=0}^{N_\\phi-1}$, where $\\phi_j = j \\cdot \\Delta\\phi$ and the angular bin width is $\\Delta\\phi = 2\\pi/N_\\phi$. A discrete direction $\\boldsymbol{\\Omega}_n$, corresponding to a pair $(\\mu_i, \\phi_j)$, is given in Cartesian coordinates by:\n$$ \\boldsymbol{\\Omega}_n = (\\sin\\theta_i\\cos\\phi_j, \\sin\\theta_i\\sin\\phi_j, \\mu_i) = (\\sqrt{1-\\mu_i^2}\\cos\\phi_j, \\sqrt{1-\\mu_i^2}\\sin\\phi_j, \\mu_i) $$\nThe weight $w_n$ associated with this direction is the product of the polar and azimuthal weights, $w_n = w^{(\\mu)}_i \\cdot \\Delta\\phi$. The total sum of all weights is $\\sum_{n=1}^{N} w_n = \\sum_{i=1}^{N_\\mu} w^{(\\mu)}_i \\sum_{j=0}^{N_\\phi-1} \\Delta\\phi = 2 \\cdot (N_\\phi \\cdot \\frac{2\\pi}{N_\\phi}) = 4\\pi$, correctly normalizing over the unit sphere.\n\nThe second step is the angular flux calculation. The angular flux $\\psi(\\mathbf{r}_{\\text{obs}}, \\boldsymbol{\\Omega})$ at the observation point $\\mathbf{r}_{\\text{obs}}$ is constructed by summing the contributions from all source locations. For a source element of strength $Q_s$ at position $\\mathbf{r}_s$, the uncollided flux contribution along the line-of-sight is based on geometric $1/L^2$ dilution and exponential attenuation. The path length is $L = \\lVert \\mathbf{r}_{\\text{obs}} - \\mathbf{r}_s\\rVert$. The contribution's magnitude is:\n$$ A(\\mathbf{r}_s) = \\left(\\frac{Q_s}{4\\pi}\\right) \\frac{e^{-\\Sigma_t L}}{L^2} $$\nIn the discrete ordinates method, this continuous contribution, which travels in the exact direction $\\widehat{\\mathbf{d}} = (\\mathbf{r}_{\\text{obs}}-\\mathbf{r}_s)/L$, is assigned to the single discrete ordinate $\\boldsymbol{\\Omega}_{n^*}$ that is \"closest\" in angle. This is found by maximizing the dot product:\n$$ n^* = \\underset{n}{\\arg\\max}\\ (\\boldsymbol{\\Omega}_n \\cdot \\widehat{\\mathbf{d}}) $$\nThe discrete angular flux array, initialized to zeros, $\\{\\psi_n = 0\\}_{n=1}^N$, is then updated by accumulating these contributions: $\\psi_{n^*} \\leftarrow \\psi_{n^*} + A(\\mathbf{r}_s)$. This process is repeated for all source locations. Two source models are considered:\n1.  A single point source at the origin, $\\mathbf{r}_s = \\mathbf{0}$, with total strength $Q_s = S_0$. This results in a single non-zero contribution to one specific ordinate $\\psi_{n^*}$, which is characteristic of the ray effect.\n2.  A volumetric source where the cube of side $a$ is discretized into $M=N^3$ identical sub-cubes. Each sub-cube is represented by a point source at its center, $\\mathbf{r}_{s_k}$. The total source strength $S_0$ is distributed equally among these points, so each has strength $Q_s = S_0/M$. The flux is calculated by summing the contributions from all $M$ points. Since each point $\\mathbf{r}_{s_k}$ defines a slightly different line-of-sight direction $\\widehat{\\mathbf{d}}_k$, the total flux is spread over multiple discrete ordinates, mitigating the ray effect.\n\nThe third step is angular variance quantification. To quantify the smoothness of the angular flux distribution, a normalized variance is computed. Given the set of discrete flux values $\\{\\psi_n\\}$ and weights $\\{w_n\\}$, the weighted mean angular flux (equivalent to the scalar flux divided by $4\\pi$) is calculated:\n$$ \\mu_\\psi = \\frac{1}{4\\pi}\\sum_{n=1}^N w_n \\psi_n $$\nNext, the weighted variance is computed:\n$$ V_\\psi = \\frac{1}{4\\pi}\\sum_{n=1}^N w_n \\left(\\psi_n - \\mu_\\psi\\right)^2 $$\nFinally, the dimensionless normalized angular variance, or squared coefficient of variation, is given by:\n$$ C = \\frac{V_\\psi}{\\mu_\\psi^2} $$\nThis metric $C$ is computed for both the point source ($C_{\\text{point}}$) and the volumetric source ($C_{\\text{vol}}$).\n\nThe final step is the computation of the variance reduction ratio. The effectiveness of the volumetric source in mitigating ray effects is measured by the ratio $\\rho$:\n$$ \\rho = \\frac{C_{\\text{vol}}}{C_{\\text{point}}} $$\nA value of $\\rho < 1$ indicates that the volumetric source produces a smoother angular flux distribution (lower relative variance) than the point source, demonstrating the mitigation of ray effects. The algorithm implements these steps for each test case to compute the corresponding $\\rho_i$. For all calculations, the total source strength is set to $S_0=1$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom numpy.polynomial.legendre import leggauss\n\nclass RayEffectMitigationSimulator:\n    \"\"\"\n    Simulates particle transport from different sources to quantify ray effect mitigation.\n    \"\"\"\n    def __init__(self, sigma_t, r_obs, N_mu, N_phi, a, M):\n        \"\"\"\n        Initializes the simulator with parameters for a single test case.\n        \"\"\"\n        self.sigma_t = sigma_t\n        self.r_obs = np.array(r_obs, dtype=float)\n        self.N_mu = N_mu\n        self.N_phi = N_phi\n        self.a = a\n        self.M = M\n        self.S0 = 1.0  # Normalized total source strength, as per problem.\n\n        # Generate the discrete ordinates quadrature set upon initialization.\n        self.omegas, self.weights = self._generate_quadrature_set()\n\n    def _generate_quadrature_set(self):\n        \"\"\"\n        Constructs the product quadrature set (directions and weights).\n        \"\"\"\n        # Get N_mu Gauss-Legendre nodes (mu) and weights (w_mu) on [-1, 1].\n        # The sum of numpy's `leggauss` weights is 2.\n        mu_nodes, mu_weights = leggauss(self.N_mu)\n        \n        # Generate N_phi uniform azimuthal angles on [0, 2*pi).\n        phi_nodes = np.linspace(0.0, 2.0 * np.pi, self.N_phi, endpoint=False)\n        delta_phi = 2.0 * np.pi / self.N_phi\n        \n        num_directions = self.N_mu * self.N_phi\n        omegas = np.zeros((num_directions, 3))\n        weights = np.zeros(num_directions)\n        \n        idx = 0\n        for i in range(self.N_mu):\n            mu = mu_nodes[i]\n            w_mu = mu_weights[i]\n            # sin(theta) = sqrt(1 - cos^2(theta))\n            sin_theta = np.sqrt(1.0 - mu**2)\n            for j in range(self.N_phi):\n                phi = phi_nodes[j]\n                \n                # Convert from spherical to Cartesian coordinates for the direction vector.\n                omegas[idx, 0] = sin_theta * np.cos(phi)\n                omegas[idx, 1] = sin_theta * np.sin(phi)\n                omegas[idx, 2] = mu\n                \n                # The weight for this direction is the product of polar and azimuthal weights.\n                weights[idx] = w_mu * delta_phi\n                idx += 1\n        \n        return omegas, weights\n\n    def _calculate_normalized_variance(self, source_type):\n        \"\"\"\n        Calculates the normalized angular variance for a given source configuration.\n        \"\"\"\n        # 1. Generate source points and their individual strengths.\n        if source_type == 'point':\n            source_points = np.array([[0.0, 0.0, 0.0]])\n            q_s = self.S0\n        elif source_type == 'volumetric':\n            N = int(round(self.M**(1./3.)))\n            if N**3 != self.M:\n                # This check ensures M is a perfect cube as expected.\n                raise ValueError(f\"M={self.M} is not a perfect cube.\")\n            \n            # Create coordinates for sub-source points at the center of each sub-volume.\n            coords1d = np.linspace(-self.a / 2.0 + self.a / (2.0 * N), self.a / 2.0 - self.a / (2.0 * N), N)\n            x, y, z = np.meshgrid(coords1d, coords1d, coords1d, indexing='ij')\n            source_points = np.vstack([x.ravel(), y.ravel(), z.ravel()]).T\n            q_s = self.S0 / self.M\n        else:\n            raise ValueError(\"Invalid source type specified.\")\n\n        # 2. Calculate the discrete angular flux psi_n.\n        num_directions = len(self.weights)\n        psi_n = np.zeros(num_directions)\n\n        for r_s in source_points:\n            d = self.r_obs - r_s\n            L = np.linalg.norm(d)\n            if L == 0.0: continue # Observer is at a source point. Skip.\n            \n            d_hat = d / L\n            \n            # Calculate contribution magnitude: geometric dilution and attenuation.\n            A = (q_s / (4.0 * np.pi)) * np.exp(-self.sigma_t * L) / (L**2)\n\n            # Find the discrete ordinate that best matches the line-of-sight direction.\n            dot_products = self.omegas @ d_hat\n            n_star = np.argmax(dot_products)\n            \n            # Accumulate the contribution to the corresponding angular flux bin.\n            psi_n[n_star] += A\n        \n        # 3. Compute the normalized variance C.\n        # Weighted mean of the angular flux.\n        mu_psi = np.sum(self.weights * psi_n) / (4.0 * np.pi)\n        \n        # According to the problem, C = V / mu^2. If mu is zero, C is undefined.\n        # However, for the given test cases, mu_psi will be non-zero.\n        if mu_psi == 0.0:\n            return np.nan\n\n        # Weighted variance of the angular flux.\n        V_psi = np.sum(self.weights * (psi_n - mu_psi)**2) / (4.0 * np.pi)\n        \n        # Normalized variance (squared coefficient of variation).\n        C = V_psi / (mu_psi**2)\n        \n        return C\n\n    def compute_reduction_ratio(self):\n        \"\"\"\n        Computes the variance reduction ratio rho = C_vol / C_point.\n        \"\"\"\n        C_point = self._calculate_normalized_variance('point')\n        C_vol = self._calculate_normalized_variance('volumetric')\n\n        if C_point == 0.0:\n            return np.nan # C_point should be large and positive, but handle this case.\n\n        rho = C_vol / C_point\n        return rho\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (sigma_t, r_obs, N_mu, N_phi, a, M)\n        {'sigma_t': 0.1, 'r_obs': (10.0, 4.0, 2.0), 'N_mu': 8, 'N_phi': 16, 'a': 6.0, 'M': 1000},\n        {'sigma_t': 0.1, 'r_obs': (10.0, 4.0, 2.0), 'N_mu': 4, 'N_phi': 8, 'a': 6.0, 'M': 216},\n        {'sigma_t': 0.1, 'r_obs': (10.0, 4.0, 2.0), 'N_mu': 8, 'N_phi': 16, 'a': 0.5, 'M': 1000},\n        {'sigma_t': 0.7, 'r_obs': (10.0, 4.0, 2.0), 'N_mu': 8, 'N_phi': 16, 'a': 6.0, 'M': 1000},\n    ]\n\n    results = []\n    for params in test_cases:\n        # Instantiate the simulator for the current test case.\n        simulator = RayEffectMitigationSimulator(**params)\n        # Compute the variance reduction ratio.\n        rho = simulator.compute_reduction_ratio()\n        results.append(rho)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "For challenging problems where ray effects persist, particularly in regions near localized sources, advanced hybrid methods offer a powerful solution. These techniques strategically combine the computational efficiency of the $S_N$ method in most of the domain with a more accurate, higher-fidelity solver in the regions where it is most needed. This numerical experiment guides you through the implementation of a simple hybrid model, demonstrating not only its superior accuracy but also the critical importance of enforcing physical conservation laws—in this case, reaction rate balance—at the interface between the two models to obtain an unbiased and reliable solution .",
            "id": "4235152",
            "problem": "Consider a two-dimensional square domain of side length $L$ centered at the origin. A monochromatic line source of strength $Q$ located at the origin emits neutrons into a homogeneous, purely absorbing medium with macroscopic total cross section $\\Sigma_t$ (no scattering). Let the scalar flux be denoted by $\\phi(\\mathbf{r})$ and the neutron current density by $\\mathbf{J}(\\mathbf{r})$. Angles must be treated in radians. All outputs in this problem are dimensionless real numbers.\n\nFundamental balance in steady-state neutron transport with no scattering and source $Q\\delta(\\mathbf{r})$ implies, for $r = \\lVert \\mathbf{r} \\rVert > 0$, a reference solution with radial symmetry. In two-dimensional polar geometry, the radially outward current magnitude equals the scalar flux, and the reference scalar flux is given by\n$$\n\\phi_{\\text{ref}}(r) = \\frac{Q}{2\\pi r} e^{-\\Sigma_t r}.\n$$\nThe reaction rate density is $\\Sigma_t \\phi(\\mathbf{r})$, and the total reaction rate over any region $\\mathcal{D}$ is $\\int_{\\mathcal{D}} \\Sigma_t \\phi(\\mathbf{r}) \\, dA$.\n\nWe consider a simplified discrete ordinates method ($S_N$) representation subject to ray effects. Let $N$ be the number of discrete directions with azimuthal angles\n$$\n\\theta_k = \\frac{2\\pi k}{N}, \\quad k = 0,1,\\dots,N-1,\n$$\nuniformly spaced on the unit circle. For any point $\\mathbf{r} = (x,y)$ with polar angle $\\theta = \\arctan2(y,x)$, define the minimal wrapped angular discrepancy to the discrete set,\n$$\n\\Delta\\theta_{\\min}(\\theta) = \\min_{k} \\left| \\mathrm{wrap}(\\theta - \\theta_k) \\right|,\n$$\nwhere $\\mathrm{wrap}(\\alpha)$ maps an angle $\\alpha$ to $[-\\pi, \\pi)$ via $\\mathrm{wrap}(\\alpha) = \\mathrm{Arg}(e^{\\mathrm{i}\\alpha})$. Introduce a fixed angular band half-width\n$$\n\\delta_\\theta = f \\frac{\\pi}{N},\n$$\nwith a specified dimensionless factor $f \\in (0,1)$, so that the pure $S_N$ ray-affected scalar flux approximation is defined by\n$$\n\\phi_{S_N}(\\mathbf{r}) =\n\\begin{cases}\n\\displaystyle \\frac{Q}{2\\pi r} e^{-\\Sigma_t r} \\cdot \\frac{1}{N}, & \\text{if } \\Delta\\theta_{\\min}(\\theta) \\le \\delta_\\theta, \\\\\n0, & \\text{otherwise,}\n\\end{cases}\n$$\nwhich concentrates flux only in $N$ narrow angular bands aligned with the discrete directions, thereby inducing ray effects. This construction serves as a mathematically well-defined surrogate capturing the bias introduced by insufficient angular resolution.\n\nTo mitigate ray effects while avoiding bias, we adopt a hybrid method that uses the analytic reference solution in a circular inner region of radius $r_h$ and the ray-affected $S_N$ approximation outside, scaled by a factor chosen to enforce reaction rate balance across the coupling interface $r=r_h$. Specifically, define\n$$\n\\phi_{\\text{hyb}}(\\mathbf{r}) =\n\\begin{cases}\n\\phi_{\\text{ref}}(r), & r < r_h, \\\\\ns \\, \\phi_{S_N}(\\mathbf{r}), & r \\ge r_h,\n\\end{cases}\n$$\nwhere the scalar $s$ is selected such that the total reaction rate in the outer region computed by the hybrid equals the total reaction rate in the outer region computed by the reference solution, i.e.,\n$$\n\\Sigma_t \\int_{r \\ge r_h} s \\, \\phi_{S_N}(\\mathbf{r}) \\, dA\n=\n\\Sigma_t \\int_{r \\ge r_h} \\phi_{\\text{ref}}(r) \\, dA.\n$$\nSolving for $s$ yields\n$$\ns = \\frac{\\displaystyle \\Sigma_t \\int_{r \\ge r_h} \\phi_{\\text{ref}}(r) \\, dA}{\\displaystyle \\Sigma_t \\int_{r \\ge r_h} \\phi_{S_N}(\\mathbf{r}) \\, dA}.\n$$\nThis enforces reaction rate balance across the coupling interface and eliminates global bias introduced by naive hybridization.\n\nNumerically, approximate all integrals with a uniform Cartesian grid on $[-L/2,L/2]^2$ having $G \\times G$ cell centers. Use the cell area $\\Delta A = (L/G)^2$, and define a small exclusion radius $\\varepsilon$ to avoid the $r=0$ singularity in error norms and outer-region integrals. For each model (pure $S_N$ and hybrid), compute the grid-based $L^2$ relative error of $\\phi$ with respect to $\\phi_{\\text{ref}}$ over the set $\\{ \\mathbf{r} : r \\ge \\varepsilon \\}$,\n$$\nE[\\phi] = \\frac{\\left( \\sum_{r \\ge \\varepsilon} \\left( \\phi(\\mathbf{r}) - \\phi_{\\text{ref}}(r) \\right)^2 \\Delta A \\right)^{1/2}}{\\left( \\sum_{r \\ge \\varepsilon} \\phi_{\\text{ref}}(r)^2 \\Delta A \\right)^{1/2}}.\n$$\nLet $E_{S_N}$ denote the error of the pure $S_N$ model and $E_{\\text{hyb}}$ that of the hybrid model. Define the hybridization error ratio\n$$\n\\rho = \\frac{E_{\\text{hyb}}}{E_{S_N}},\n$$\nwhich indicates improvement when $\\rho < 1$.\n\nAdditionally, quantify the reaction rate balance across the coupling interface by computing the outer-region reaction rate deviation for the pure $S_N$ and hybrid models,\n$$\n\\Delta R_{S_N} = \\Sigma_t \\sum_{r \\ge r_h} \\phi_{S_N}(\\mathbf{r}) \\Delta A - \\Sigma_t \\sum_{r \\ge r_h} \\phi_{\\text{ref}}(r) \\Delta A,\n$$\n$$\n\\Delta R_{\\text{hyb}} = \\Sigma_t \\sum_{r \\ge r_h} \\phi_{\\text{hyb}}(\\mathbf{r}) \\Delta A - \\Sigma_t \\sum_{r \\ge r_h} \\phi_{\\text{ref}}(r) \\Delta A,\n$$\nwhich should satisfy $\\Delta R_{\\text{hyb}} \\approx 0$ if reaction rate balance is properly enforced.\n\nImplement a complete, runnable program that:\n- Constructs the numerical grid and computes $\\phi_{\\text{ref}}$, $\\phi_{S_N}$, and $\\phi_{\\text{hyb}}$ for each test case.\n- Uses the fixed values $L = 1$, $G = 401$, $Q = 1$, $f = 0.35$, and $\\varepsilon = L/(2G)$.\n- Computes $E_{S_N}$, $E_{\\text{hyb}}$, $\\rho$, $\\Delta R_{S_N}$, and $\\Delta R_{\\text{hyb}}$ as defined above.\n\nTest suite:\n- Case 1 (happy path, severe ray effects): $N = 4$, $\\Sigma_t = 1.0$, $r_h = 0.10$.\n- Case 2 (increased angular resolution): $N = 8$, $\\Sigma_t = 1.0$, $r_h = 0.10$.\n- Case 3 (lower attenuation length, broader outer contribution): $N = 8$, $\\Sigma_t = 0.5$, $r_h = 0.10$.\n- Case 4 (larger hybrid region and many directions): $N = 32$, $\\Sigma_t = 1.0$, $r_h = 0.20$.\n- Case 5 (edge case, highly absorbing medium): $N = 4$, $\\Sigma_t = 2.0$, $r_h = 0.05$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each test case must contribute a list of three floats in the order $[\\rho, \\Delta R_{S_N}, \\Delta R_{\\text{hyb}}]$, and the final output must be a list of these lists, for example, $[[\\rho_1,\\Delta R_{S_N,1},\\Delta R_{\\text{hyb},1}],[\\rho_2,\\dots],\\dots]$.",
            "solution": "The problem has been validated and is determined to be self-contained, scientifically grounded, and well-posed. It presents a well-defined numerical experiment to compare a simplified discrete ordinates model with a hybrid model for neutron transport, focusing on the mitigation of ray effects. The solution proceeds by implementing the specified numerical models and metrics.\n\nThe core of the task is to perform a numerical simulation on a two-dimensional Cartesian grid. The methodology involves these primary steps: grid generation, evaluation of different flux models ($\\phi_{\\text{ref}}$, $\\phi_{S_N}$, $\\phi_{\\text{hyb}}$) at each grid point, and computation of performance metrics ($\\rho$, $\\Delta R_{S_N}$, $\\Delta R_{\\text{hyb}}$) based on these flux fields.\n\nFirst, we establish the computational domain. A uniform Cartesian grid is defined on the square $[-L/2, L/2]^2$, where the side length is $L=1$. The grid consists of $G \\times G$ cells, with $G=401$. The simulation is performed at the cell centers. The coordinates of the cell centers $(x_i, y_j)$ are generated accordingly, with a uniform spacing of $\\Delta x = \\Delta y = L/G$. The area element for numerical integration is thus $\\Delta A = (L/G)^2$. For each cell center $(x_i, y_j)$, we compute its polar coordinates, the radius $r = \\sqrt{x_i^2 + y_j^2}$ and the angle $\\theta = \\arctan2(y_j, x_i)$. These arrays of coordinates form the basis for all subsequent calculations.\n\nNext, we evaluate the three scalar flux models on this grid.\n\n1.  **Reference Flux ($\\phi_{\\text{ref}}$)**: The analytical reference flux is given by $\\phi_{\\text{ref}}(r) = \\frac{Q}{2\\pi r} e^{-\\Sigma_t r}$, with source strength $Q=1$. This formula is applied to the grid of radii $r$. The singularity at $r=0$ (the grid origin) is handled by ensuring it is excluded from summary calculations by the problem-defined exclusion radius $\\varepsilon = L/(2G)$.\n\n2.  **Discrete Ordinates Flux ($\\phi_{S_N}$)**: This model simulates ray effects. For a given number of discrete directions $N$, a set of angles $\\theta_k = \\frac{2\\pi k}{N}$ for $k \\in \\{0, 1, \\dots, N-1\\}$ is defined. For each grid point with polar angle $\\theta$, we must find its minimal angular distance to this set of discrete directions. This requires computing the minimal wrapped angular discrepancy, $\\Delta\\theta_{\\min}(\\theta) = \\min_{k} \\left| \\mathrm{wrap}(\\theta - \\theta_k) \\right|$. The function $\\mathrm{wrap}(\\alpha)$ maps an angle $\\alpha$ to the interval $[-\\pi, \\pi)$, implemented as $\\mathrm{wrap}(\\alpha) = (\\alpha + \\pi) \\pmod{2\\pi} - \\pi$. The flux $\\phi_{S_N}$ is non-zero only within narrow angular bands of half-width $\\delta_\\theta = f \\frac{\\pi}{N}$ (with $f=0.35$) around each $\\theta_k$. If a point $(r, \\theta)$ satisfies $\\Delta\\theta_{\\min}(\\theta) \\le \\delta_\\theta$, its flux is $\\phi_{S_N}(\\mathbf{r}) = \\phi_{\\text{ref}}(r) / N$; otherwise, $\\phi_{S_N}(\\mathbf{r})=0$. This partitions the domain into regions of non-zero flux aligned with the discrete ordinates, and regions of zero flux, which is the hallmark of ray effects.\n\n3.  **Hybrid Flux ($\\phi_{\\text{hyb}}$)**: This model combines the previous two to mitigate ray effects. It uses the accurate reference solution $\\phi_{\\text{ref}}$ in an inner circular region $r < r_h$ and a scaled version of the $S_N$ solution, $s \\cdot \\phi_{S_N}$, in the outer region $r \\ge r_h$. The scaling factor $s$ is chosen to enforce reaction rate conservation across the coupling interface at $r=r_h$. It is calculated as the ratio of the total reaction rate in the outer region from the reference solution to that from the $S_N$ solution. Since the macroscopic cross section $\\Sigma_t$ is constant, it cancels out, yielding $s = \\frac{\\int_{r \\ge r_h} \\phi_{\\text{ref}}(r) \\, dA}{\\int_{r \\ge r_h} \\phi_{S_N}(\\mathbf{r}) \\, dA}$. Numerically, the integrals are replaced by summations over the grid cells in the region $r \\ge r_h$.\n    $$\n    s = \\frac{\\sum_{r_{ij} \\ge r_h} \\phi_{\\text{ref}}(r_{ij}) \\Delta A}{\\sum_{r_{ij} \\ge r_h} \\phi_{S_N}(\\mathbf{r}_{ij}) \\Delta A}\n    $$\n    With $s$ determined, the hybrid flux $\\phi_{\\text{hyb}}$ is constructed pointwise on the grid based on the radial condition.\n\nFinally, we compute the required performance metrics for each test case.\n\n-   **Hybridization Error Ratio ($\\rho$)**: This metric compares the accuracy of the hybrid model to the $S_N$ model. It is the ratio $\\rho = E_{\\text{hyb}} / E_{S_N}$ of their respective grid-based $L^2$ relative errors. The $L^2$ error for a generic flux $\\phi$ is computed as:\n    $$\n    E[\\phi] = \\frac{\\left( \\sum_{r_{ij} \\ge \\varepsilon} \\left( \\phi(\\mathbf{r}_{ij}) - \\phi_{\\text{ref}}(r_{ij}) \\right)^2 \\Delta A \\right)^{1/2}}{\\left( \\sum_{r_{ij} \\ge \\varepsilon} \\phi_{\\text{ref}}(r_{ij})^2 \\Delta A \\right)^{1/2}}\n    $$\n    The summations are carried out over all grid points outside the exclusion radius $\\varepsilon$.\n\n-   **Reaction Rate Deviation ($\\Delta R$)**: These metrics quantify the reaction rate imbalance in the outer region ($r \\ge r_h$) for the $S_N$ and hybrid models relative to the reference solution. They are computed as:\n    $$\n    \\Delta R_{S_N} = \\Sigma_t \\sum_{r_{ij} \\ge r_h} \\phi_{S_N}(\\mathbf{r}_{ij}) \\Delta A - \\Sigma_t \\sum_{r_{ij} \\ge r_h} \\phi_{\\text{ref}}(r_{ij}) \\Delta A\n    $$\n    $$\n    \\Delta R_{\\text{hyb}} = \\Sigma_t \\sum_{r_{ij} \\ge r_h} \\phi_{\\text{hyb}}(\\mathbf{r}_{ij}) \\Delta A - \\Sigma_t \\sum_{r_{ij} \\ge r_h} \\phi_{\\text{ref}}(r_{ij}) \\Delta A\n    $$\n    By the definition of the scaling factor $s$, the value of $\\Delta R_{\\text{hyb}}$ is expected to be numerically zero, demonstrating that the hybrid method successfully enforces the reaction rate balance condition.\n\nThis entire procedure is automated in a script. For each set of parameters ($N$, $\\Sigma_t$, $r_h$) from the test suite, the script computes the grid-based flux fields and then evaluates the metrics $[\\rho, \\Delta R_{S_N}, \\Delta R_{\\text{hyb}}]$. The collected results are then formatted into the required output structure.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the neutron transport problem for multiple test cases, evaluating\n    the performance of a hybrid mitigation method for ray effects.\n    \"\"\"\n    # Fixed parameters from the problem statement\n    L = 1.0\n    G = 401\n    Q = 1.0\n    f = 0.35\n    epsilon = L / (2.0 * G)\n    delta_A = (L / G)**2\n\n    # Test suite\n    test_cases = [\n        # (N, Sigma_t, r_h)\n        (4, 1.0, 0.10),\n        (8, 1.0, 0.10),\n        (8, 0.5, 0.10),\n        (32, 1.0, 0.20),\n        (4, 2.0, 0.05),\n    ]\n\n    # Set up the numerical grid\n    # Cell centers are from -L/2 + dx/2 to L/2 - dx/2\n    grid_1d = np.linspace(-L/2 + L/(2*G), L/2 - L/(2*G), G)\n    x, y = np.meshgrid(grid_1d, grid_1d)\n\n    # Convert to polar coordinates\n    r = np.sqrt(x**2 + y**2)\n    theta = np.arctan2(y, x)\n\n    all_results = []\n    \n    for N, Sigma_t, r_h in test_cases:\n        # --- 1. Calculate Flux Fields ---\n\n        # Reference Flux (phi_ref)\n        # Avoid division by zero at r=0. This point is excluded later by epsilon mask.\n        r_safe = np.copy(r)\n        # The central grid point is at (0,0) since G is odd.\n        r_safe[r == 0] = 1e-12  # A small non-zero value\n        phi_ref = (Q / (2 * np.pi * r_safe)) * np.exp(-Sigma_t * r_safe)\n\n        # S_N Flux (phi_SN)\n        theta_k = (2 * np.pi * np.arange(N)) / N\n        \n        # Calculate minimal wrapped angular discrepancy\n        # Use broadcasting to compare each grid theta with all theta_k\n        delta_theta_all_k = theta[:, :, np.newaxis] - theta_k[np.newaxis, np.newaxis, :]\n        # Wrap angles to [-pi, pi)\n        wrapped_delta_theta = (delta_theta_all_k + np.pi) % (2 * np.pi) - np.pi\n        delta_theta_min = np.min(np.abs(wrapped_delta_theta), axis=2)\n        \n        # Check if points fall within the angular bands\n        delta_theta_band_half_width = f * np.pi / N\n        in_band_mask = delta_theta_min <= delta_theta_band_half_width\n        \n        phi_SN = np.zeros_like(phi_ref)\n        phi_SN[in_band_mask] = phi_ref[in_band_mask] / N\n\n        # Hybrid Flux (phi_hyb)\n        outer_region_mask = r >= r_h\n        \n        # Calculate scaling factor 's'\n        # Integrals are approximated by sums over the grid\n        integral_ref_outer = np.sum(phi_ref[outer_region_mask]) * delta_A\n        integral_SN_outer = np.sum(phi_SN[outer_region_mask]) * delta_A\n        \n        s = integral_ref_outer / integral_SN_outer if integral_SN_outer > 0 else 0.0\n        \n        # Construct the hybrid flux field\n        phi_hyb = np.copy(phi_ref)  # Inner region uses phi_ref\n        phi_hyb[outer_region_mask] = s * phi_SN[outer_region_mask]\n\n        # --- 2. Calculate Performance Metrics ---\n\n        error_region_mask = r >= epsilon\n        \n        # L2 relative error calculations\n        # Denominator of the L2 relative error (norm of phi_ref)\n        norm_phi_ref_sq = np.sum(phi_ref[error_region_mask]**2) * delta_A\n        \n        if norm_phi_ref_sq == 0:\n            E_SN, E_hyb = 0.0, 0.0\n        else:\n            # L2 error for S_N model\n            err_sq_SN = np.sum((phi_SN[error_region_mask] - phi_ref[error_region_mask])**2) * delta_A\n            E_SN = np.sqrt(err_sq_SN / norm_phi_ref_sq)\n            \n            # L2 error for hybrid model\n            err_sq_hyb = np.sum((phi_hyb[error_region_mask] - phi_ref[error_region_mask])**2) * delta_A\n            E_hyb = np.sqrt(err_sq_hyb / norm_phi_ref_sq)\n            \n        # Hybridization error ratio (rho)\n        rho = E_hyb / E_SN if E_SN > 0 else 0.0\n        \n        # Reaction Rate Deviation calculations\n        # These are based on the integral approximations used to find 's'\n        R_ref_outer = Sigma_t * integral_ref_outer\n        R_SN_outer = Sigma_t * integral_SN_outer\n        \n        delta_R_SN = R_SN_outer - R_ref_outer\n        \n        # Explicit calculation for delta_R_hyb as a verification\n        R_hyb_outer = np.sum(phi_hyb[outer_region_mask]) * delta_A * Sigma_t\n        delta_R_hyb = R_hyb_outer - R_ref_outer\n        \n        all_results.append([rho, delta_R_SN, delta_R_hyb])\n\n    # Final print statement in the exact required format.\n    # The repr() function provides a string representation of the list of lists.\n    # The problem example shows no spaces, so remove them.\n    print(str(all_results).replace(\" \", \"\"))\n\nsolve()\n```"
        }
    ]
}