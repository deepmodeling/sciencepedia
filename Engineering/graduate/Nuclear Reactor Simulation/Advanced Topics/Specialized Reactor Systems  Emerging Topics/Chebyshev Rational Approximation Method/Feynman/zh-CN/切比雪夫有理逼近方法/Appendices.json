{
    "hands_on_practices": [
        {
            "introduction": "在反应堆燃耗等物理模拟中，核素密度等状态变量必须是实数。切比雪夫有理逼近法 (CRAM) 通过复数运算实现，但其设计精妙之处在于，通过共轭对称的极点和留数对，确保了对实数输入的计算结果仍为实数。本练习  要求您编写单元测试来从数值上验证这一关键特性，从而加深对 CRAM 方法内在稳定性的理解。",
            "id": "4216692",
            "problem": "您的任务是验证一个关键的数值属性，该属性是核反应堆模拟中使用的切比雪夫有理逼近方法（CRAM）的基础，特别是在燃料消耗计算中，用于燃耗算子的矩阵指数的数值评估。所使用的基本原理是复共轭代数和有理函数的标准性质。\n\n考虑CRAM中使用的一种部分分式形式的有理函数，其中复极点和留数成共轭对出现。设该有理函数由标量映射 $r : \\mathbb{C} \\to \\mathbb{C}$ 定义，\n$$\nr(x) = \\alpha_0 + \\sum_{k=1}^{m} \\left( \\frac{\\alpha_k}{x - \\theta_k} + \\frac{\\overline{\\alpha_k}}{x - \\overline{\\theta_k}} \\right),\n$$\n其中 $x \\in \\mathbb{R}$，$\\alpha_0 \\in \\mathbb{R}$，$(\\alpha_k, \\theta_k)$ 是复数，$\\overline{\\alpha_k}$ 和 $\\overline{\\theta_k}$ 表示它们的复共轭。在CRAM中，这种结构保证了对于实数输入 $x$，每对共轭项的总和为一个实值，这一事实对于从实值初始密度获得实值核素密度至关重要。\n\n您的任务是编写一个完整的、可运行的程序，构建单元测试，以验证输出结果在机器精度下为实值，并在共轭对称性被破坏时检测到其失效。测试应纯粹以数学术语来构建，但该场景与真实的核反应堆燃料消耗计算一致，其中 $x$ 对应于衰变常数和时间步长的标量积，是无量纲的。无需物理单位。\n\n机器精度的定义：令 $\\epsilon$ 表示双精度算术的机器ε，即 $\\epsilon = 2^{-52}$。对于一个计算出的复数值 $y$，定义一个绝对容差\n$$\n\\tau(y) = 10^3 \\, \\epsilon \\, \\left( 1 + |y| \\right).\n$$\n如果一个计算值 $y$ 的虚部满足 $|\\operatorname{Im}(y)| \\le \\tau(y)$，则认为它在机器精度下是实数。\n\n您将使用以下确定性测试参数套件。基本的共轭对由 $m = 6$ 个复数对和一个实数标量偏移 $\\alpha_0$ 给出：\n- 实数偏移：$\\alpha_0 = 0.1$。\n- 当 $k=1,\\dots,6$ 时的极点 $(\\theta_k)$ 和留数 $(\\alpha_k)$：\n  - $k=1$: $\\theta_1 = -0.1 + 0.3 i$, $\\alpha_1 = 0.2 + 0.05 i$。\n  - $k=2$: $\\theta_2 = -0.5 + 0.8 i$, $\\alpha_2 = 0.1 + 0.2 i$。\n  - $k=3$: $\\theta_3 = -1.2 + 1.5 i$, $\\alpha_3 = 0.05 + 0.3 i$。\n  - $k=4$: $\\theta_4 = -3.0 + 2.7 i$, $\\alpha_4 = 0.02 + 0.25 i$。\n  - $k=5$: $\\theta_5 = -5.5 + 3.8 i$, $\\alpha_5 = 0.01 + 0.15 i$。\n  - $k=6$: $\\theta_6 = -8.0 + 5.0 i$, $\\alpha_6 = 0.005 + 0.1 i$。\n- 完整的极点和留数集是通过为每一对 $k$ 添加其共轭对应项来构成的，即对每个 $k$ 也包括 $\\overline{\\theta_k}$ 和 $\\overline{\\alpha_k}$。\n\n定义四个测试用例如下：\n- 测试用例1（对实数输入的精确共轭对称性）：使用上述精确的共轭对。在以下实数输入上计算 $r(x)$\n  $$\n  x \\in \\{-10^{-12}, -10^{-6}, -10^{-3}, -0.1, -1.0, -10.0, -10^{3}\\}.\n  $$\n  当且仅当在指定输入上 $|\\operatorname{Im}(r(x))|$ 的最大值对于每个输入都小于或等于 $\\tau(r(x))$ 时，测试结果为布尔值true。\n- 测试用例2（破坏的共轭对称性检测）：仅修改对应于 $k=1$ 的共轭留数，通过向 $\\overline{\\alpha_1}$ 添加一个小的虚数微扰 $\\delta = 10^{-6}$，即用 $\\overline{\\alpha_1} + i \\delta$ 替换 $\\overline{\\alpha_1}$，同时保持所有其他对不变。在与测试用例1相同的输入上计算 $r(x)$。当且仅当在所有输入上 $|\\operatorname{Im}(r(x))|$ 的最大值严格超过 $10^3 \\epsilon$ 时，测试结果为布尔值true。\n- 测试用例3（包括零和极大数量级的边界输入）：使用精确的共轭对。在以下输入上计算 $r(x)$\n  $$\n  x \\in \\{0.0, -10^{-9}, -10^{-3}, -1.0, -10^{6}, -10^{12}\\}.\n  $$\n  当且仅当在所有输入上 $|\\operatorname{Im}(r(x))|$ 的最大值对于每个输入都小于或等于 $\\tau(r(x))$ 时，测试结果为布尔值true。\n- 测试用例4（与反应堆消耗算子一致的对角矩阵求值）：考虑对角实矩阵 $A = \\operatorname{diag}(a_1,\\dots,a_5)$，其对角线元素为\n  $$\n  (a_1,\\dots,a_5) = (-10^{-3}, -0.2, -1.5, -10.0, -100.0).\n  $$\n  通过在其谱上进行逐元素求值，来计算该对角矩阵上的有理映射，即计算 $r(a_j)$ 对 $j=1,\\dots,5$。当且仅当对 $j=1,\\dots,5$ 中的每一个 $j$，$|\\operatorname{Im}(r(a_j))|$ 的最大值都小于或等于 $\\tau(r(a_j))$ 时，测试结果为布尔值true。\n\n您的程序应输出单行结果，其中包含一个用方括号括起来的逗号分隔列表（例如，“[result1,result2,result3,result4]”）。每个结果应为布尔值，按顺序对应上述四个测试用例。不应打印任何其他输出。",
            "solution": "该问题要求对使用共轭对称性构建的有理函数的一个基本性质进行数值验证，该方法用于核反应堆物理模拟中的切比雪夫有理逼近方法（CRAM）。具体来说，我们必须验证对于实数输入 $x$，有理函数 $r(x)$ 产生实数输出，并且当共轭对称性被破坏时，该性质会受到影响。\n\n有理函数由下式给出：\n$$\nr(x) = \\alpha_0 + \\sum_{k=1}^{m} \\left( \\frac{\\alpha_k}{x - \\theta_k} + \\frac{\\overline{\\alpha_k}}{x - \\overline{\\theta_k}} \\right)\n$$\n其中 $x, \\alpha_0 \\in \\mathbb{R}$ 且 $\\alpha_k, \\theta_k \\in \\mathbb{C}$。符号 $\\overline{z}$ 表示 $z$ 的复共轭。\n\n核心数学原理是，使用这种共轭对对称性构建的函数将实数映射到实数。我们可以通过检查实数输入 $x$ 的 $r(x)$ 的复共轭来证明这一点。由于 $x$ 是实数，所以 $\\overline{x} = x$。\n$r(x)$ 的共轭是：\n$$\n\\overline{r(x)} = \\overline{\\alpha_0 + \\sum_{k=1}^{m} \\left( \\frac{\\alpha_k}{x - \\theta_k} + \\frac{\\overline{\\alpha_k}}{x - \\overline{\\theta_k}} \\right)}\n$$\n利用复共轭的性质（$\\overline{z_1 + z_2} = \\overline{z_1} + \\overline{z_2}$，$\\overline{z_1 / z_2} = \\overline{z_1} / \\overline{z_2}$，以及 $\\overline{\\overline{z}} = z$）：\n$$\n\\overline{r(x)} = \\overline{\\alpha_0} + \\sum_{k=1}^{m} \\left( \\overline{\\left(\\frac{\\alpha_k}{x - \\theta_k}\\right)} + \\overline{\\left(\\frac{\\overline{\\alpha_k}}{x - \\overline{\\theta_k}}\\right)} \\right)\n$$\n$$\n\\overline{r(x)} = \\alpha_0 + \\sum_{k=1}^{m} \\left( \\frac{\\overline{\\alpha_k}}{\\overline{x} - \\overline{\\theta_k}} + \\frac{\\overline{\\overline{\\alpha_k}}}{\\overline{x} - \\overline{\\overline{\\theta_k}}} \\right)\n$$\n因为 $\\overline{x} = x$ 且 $\\overline{\\alpha_0} = \\alpha_0$（因为它是实数），所以上式简化为：\n$$\n\\overline{r(x)} = \\alpha_0 + \\sum_{k=1}^{m} \\left( \\frac{\\overline{\\alpha_k}}{x - \\overline{\\theta_k}} + \\frac{\\alpha_k}{x - \\theta_k} \\right) = r(x)\n$$\n一个复数 $y$ 是实数，当且仅当 $y = \\overline{y}$。既然我们已经证明了对于实数 $x$，$\\overline{r(x)} = r(x)$，那么 $r(x)$ 必须是一个实数。\n\n在有限精度浮点运算的数值计算中，由于舍入误差，$r(x)$ 的计算虚部可能不完全为零。因此，我们必须测试虚部在定义的容差范围内是否可忽略不计。问题提供了一个特定的容差标准：一个计算出的复数值 $y$ 被认为是实数，如果其虚部满足 $|\\operatorname{Im}(y)| \\le \\tau(y)$，其中绝对容差 $\\tau(y)$ 由下式给出：\n$$\n\\tau(y) = 10^3 \\, \\epsilon \\, \\left( 1 + |y| \\right)\n$$\n这里，$\\epsilon = 2^{-52}$ 是双精度的机器ε。这是一种混合绝对-相对容差，对于接近零或非常大的 $y$ 值都具有鲁棒性。因子 $10^3$ 用于容纳求和中多次算术运算导致的浮点误差累积。\n\n四个测试用例旨在在不同条件下验证此性质。实现将按以下步骤进行：\n\n1.  将创建一个核心函数 `evaluate_r(x, ...)` 来为标量或向量输入 `x` 计算 $r(x)$。该函数将模型参数 $\\alpha_0$、$\\alpha_k$、$\\theta_k$ 作为参数，并将包含一个标志来处理测试用例2所需的对称性破缺修改。\n\n2.  **测试用例1** 使用精确的共轭对称参数为一组实数输入计算 $r(x)$。测试验证对于集合中的每个输入 $x_i$，计算值 $y_i = r(x_i)$ 在机器精度下是实数，即 $|\\operatorname{Im}(y_i)| \\le \\tau(y_i)$。最终结果是所有这些单独检查的逻辑与。\n\n3.  **测试用例2** 对其中一个共轭留数 $\\overline{\\alpha_1}$ 引入一个小的微扰，从而破坏了完美的对称性。该测试旨在检测此失效。预期 $r(x)$ 的虚部将变得显著。如果虚部的最大绝对值（在所有输入上）超过一个固定的小的阈值 $10^3 \\epsilon$，则测试通过。\n\n4.  **测试用例3** 类似于测试用例1，但使用了一组不同的输入，包括零和数量级非常大的值，以测试该性质在边界条件下的鲁棒性。成功标准与测试用例1相同。\n\n5.  **测试用例4** 将有理函数应用于对角矩阵的特征值。在矩阵函数的背景下，对于一个可对角化的矩阵 $A=PDP^{-1}$，$r(A)$ 为 $PD_rP^{-1}$，其中 $D_r$ 是对角矩阵，其元素为每个特征值 $\\lambda_i$ 的 $r(\\lambda_i)$。对于对角矩阵 $A$，这简化为在其对角线元素上进行逐元素求值。成功标准再次与测试用例1相同，应用于每个对角元素的结果。\n\n最终程序将使用提供的参数系统地执行这四个测试，并为每个测试报告一个布尔结果，将整个逻辑封装在一个独立的脚本中。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Executes the four test cases for verifying the real-valued property\n    of a CRAM rational approximation.\n    \"\"\"\n    \n    # Define machine epsilon for double precision\n    epsilon = np.finfo(np.float64).eps\n\n    # Define the base parameters for the rational function\n    alpha_0 = 0.1\n    m = 6\n    # Poles (theta_k) and residues (alpha_k) for k=1,...,6\n    thetas = np.array([\n        -0.1 + 0.3j,\n        -0.5 + 0.8j,\n        -1.2 + 1.5j,\n        -3.0 + 2.7j,\n        -5.5 + 3.8j,\n        -8.0 + 5.0j\n    ], dtype=np.complex128)\n    \n    alphas = np.array([\n        0.2 + 0.05j,\n        0.1 + 0.2j,\n        0.05 + 0.3j,\n        0.02 + 0.25j,\n        0.01 + 0.15j,\n        0.005 + 0.1j\n    ], dtype=np.complex128)\n\n    def evaluate_r(x, a0, ak_list, thk_list, break_symmetry=False, delta=0.0):\n        \"\"\"\n        Evaluates the rational function r(x).\n        \n        Args:\n            x (np.ndarray): Real-valued inputs.\n            a0 (float): Real offset term.\n            ak_list (np.ndarray): Complex residues alpha_k.\n            thk_list (np.ndarray): Complex poles theta_k.\n            break_symmetry (bool): If True, breaks symmetry for test case 2.\n            delta (float): Perturbation for test case 2.\n\n        Returns:\n            np.ndarray: Complex-valued results r(x).\n        \"\"\"\n        x = np.asarray(x, dtype=np.float64)\n        total_sum = np.zeros_like(x, dtype=np.complex128)\n        \n        ak_conj_list = np.conj(ak_list)\n        if break_symmetry:\n            ak_conj_list[0] += 1j * delta\n            \n        thk_conj_list = np.conj(thk_list)\n        \n        # Vectorized calculation for efficiency\n        # Reshape x to (N, 1) to broadcast against (M,) arrays of poles/residues\n        x_reshaped = x[:, np.newaxis]\n        \n        # Calculate sum of terms for primary poles and residues\n        term1_sum = np.sum(ak_list / (x_reshaped - thk_list), axis=1)\n        \n        # Calculate sum of terms for conjugate poles and residues\n        term2_sum = np.sum(ak_conj_list / (x_reshaped - thk_conj_list), axis=1)\n        \n        return a0 + term1_sum + term2_sum\n\n    def tolerance(y):\n        \"\"\"Calculates the tolerance tau(y).\"\"\"\n        return 1e3 * epsilon * (1.0 + np.abs(y))\n\n    results = []\n\n    # Test Case 1: Exact conjugate symmetry on real inputs\n    x1 = np.array([-1e-12, -1e-6, -1e-3, -0.1, -1.0, -10.0, -1e3])\n    y1 = evaluate_r(x1, alpha_0, alphas, thetas)\n    tau1 = tolerance(y1)\n    result1 = np.all(np.abs(y1.imag) = tau1)\n    results.append(result1)\n\n    # Test Case 2: Broken conjugate symmetry detection\n    delta_pert = 1e-6\n    x2 = x1  # Same inputs as Test Case 1\n    y2 = evaluate_r(x2, alpha_0, alphas, thetas, break_symmetry=True, delta=delta_pert)\n    result2 = np.max(np.abs(y2.imag)) > 1e3 * epsilon\n    results.append(result2)\n\n    # Test Case 3: Boundary inputs including zero and very large magnitude\n    x3 = np.array([0.0, -1e-9, -1e-3, -1.0, -1e6, -1e12])\n    y3 = evaluate_r(x3, alpha_0, alphas, thetas)\n    tau3 = tolerance(y3)\n    result3 = np.all(np.abs(y3.imag) = tau3)\n    results.append(result3)\n\n    # Test Case 4: Diagonal matrix evaluation\n    x4 = np.array([-1e-3, -0.2, -1.5, -10.0, -100.0])\n    y4 = evaluate_r(x4, alpha_0, alphas, thetas)\n    tau4 = tolerance(y4)\n    result4 = np.all(np.abs(y4.imag) = tau4)\n    results.append(result4)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "标准的 CRAM 在整个能谱范围内提供一致的逼近精度，但在许多实际的燃耗计算中，精确模拟长寿命核素（对应于嬗变矩阵的近零特征值）的行为至关重要。本练习  将挑战您超越现成的 CRAM 方法，通过施加在零点处的值和导数匹配等特定数学约束，亲手构建一个定制化的低阶有理函数。这个过程将揭示如何为特定的物理需求“量身定做”数值算法。",
            "id": "4216709",
            "problem": "在用于核燃料燃耗的中子诱发嬗变和放射性衰变模拟中，核素数密度矢量 $\\mathbf{N}(t)$ 满足 Bateman 嬗变方程 $\\frac{d\\mathbf{N}}{dt} = \\mathbf{A}(t)\\,\\mathbf{N}(t)$，其中 $\\mathbf{A}(t)$ 是随时间变化的嬗变-衰变矩阵，其特征值的实部为非正数。在时长为 $t0$ 且在此期间 $\\mathbf{A}$ 保持不变的时间步长内，其形式解为 $\\mathbf{N}(t+\\Delta t) = \\exp(t\\,\\mathbf{A})\\,\\mathbf{N}(t)$。在实践中，切比雪夫有理近似法 (CRAM) 用一个关于 $\\mathbf{A}$ 的有理函数来代替 $\\exp(t\\,\\mathbf{A})$，以在 $\\mathbf{A}$ 的整个谱上实现高精度和高稳定性。\n\n长寿命核素对应于小的衰变常数，这些衰变常数映射到 $\\mathbf{A}$ 在负实轴上 $\\lambda=0$ 附近的特征值 $\\lambda$。为优先保证此类模式的精度，考虑标量目标函数 $f(\\lambda) = \\exp(-t\\,\\lambda)$（对于 $\\lambda \\ge 0$），它通过映射 $\\lambda \\mapsto -\\lambda$ 来表示 $\\exp(t\\,\\mathbf{A})$ 在实非负 $\\lambda$ 上的作用。\n\n构建一个 $f(\\lambda)$ 的 [1/1] 次加权有理近似式 $R(\\lambda)$，通过施加以下设计约束来优先保证 $\\lambda=0$ 附近的精度：\n- 在 $\\lambda=0$ 处保持值精确：$R(0) = f(0)$。\n- 在 $\\lambda=0$ 处保持斜率精确：$R'(0) = f'(0)$。\n- 在一个小的正横坐标 $\\sigma0$ 处进行加权近零插值：$R(\\sigma) = f(\\sigma)$，其中 $\\sigma$ 由从业者选择，以反映对 $\\lambda=0$ 附近的期望强调程度。\n\n假设其一般形式为 $R(\\lambda) = \\frac{1 + a\\,\\lambda}{1 + b\\,\\lambda}$，其中 $a$ 和 $b$ 为实系数。推导 $R(\\lambda)$ 关于 $t$ 和 $\\sigma$ 的显式解析表达式。请以单个闭式表达式的形式提供最终答案。无需进行数值计算，也不应进行舍入。最终答案不得包含单位。",
            "solution": "问题要求构建一个针对函数 $f(\\lambda) = \\exp(-t\\,\\lambda)$ 的特定 [1/1] 次加权有理近似式 $R(\\lambda)$。该近似式必须在 $\\lambda=0$ 和一个小的正横坐标 $\\sigma  0$ 处满足一组插值和导数匹配条件。\n\n首先，我们对问题陈述进行验证。\n\n### 步骤 1：提取已知条件\n- **目标函数**：$f(\\lambda) = \\exp(-t\\,\\lambda)$，对于 $\\lambda \\ge 0$。\n- **有理近似式形式**：$R(\\lambda) = \\frac{1 + a\\,\\lambda}{1 + b\\,\\lambda}$，其中 $a$ 和 $b$ 为实系数。\n- **约束条件**：\n    1.  $R(0) = f(0)$（在 $\\lambda=0$ 处值精确）\n    2.  $R'(0) = f'(0)$（在 $\\lambda=0$ 处斜率精确）\n    3.  $R(\\sigma) = f(\\sigma)$，对于 $\\sigma  0$（在 $\\lambda=\\sigma$ 处插值）\n- **目标**：用 $t$ 和 $\\sigma$ 推导出 $R(\\lambda)$ 的显式解析表达式。\n\n### 步骤 2：使用提取的已知条件进行验证\n该问题具有坚实的科学基础，属于为求解核工程中出现的常微分方程组而设的数值方法这一成熟领域。使用有理近似法处理矩阵指数是一种标准而强大的技术（例如，Padé 近似法、CRAM）。该问题是适定的：它提供了一个具有两个未知参数 $a$ 和 $b$ 的近似式的特定形式，并施加了三个约束条件。正如我们将看到的，$R(\\lambda)$ 的选定形式自动满足了一个约束，剩下两个独立的约束来确定这两个未知数。该问题是客观的、数学上精确的，并且不含任何矛盾或模糊之处。\n\n### 结论与行动\n问题有效。我们开始推导。\n\n### 有理近似式的推导\n\n目标函数为 $f(\\lambda) = \\exp(-t\\,\\lambda)$。其关于 $\\lambda$ 的一阶导数为 $f'(\\lambda) = -t\\,\\exp(-t\\,\\lambda)$。\n\n提出的有理近似式为 $R(\\lambda) = \\frac{1 + a\\,\\lambda}{1 + b\\,\\lambda}$。使用商法则求其一阶导数：\n$$\nR'(\\lambda) = \\frac{d}{d\\lambda} \\left( \\frac{1 + a\\,\\lambda}{1 + b\\,\\lambda} \\right) = \\frac{a(1 + b\\,\\lambda) - (1 + a\\,\\lambda)b}{(1 + b\\,\\lambda)^2} = \\frac{a + ab\\,\\lambda - b - ab\\,\\lambda}{(1 + b\\,\\lambda)^2} = \\frac{a - b}{(1 + b\\,\\lambda)^2}\n$$\n\n现在我们应用给定的三个约束来确定系数 $a$ 和 $b$。\n\n**约束 1：$R(0) = f(0)$**\n我们在 $\\lambda=0$ 处计算两个函数的值：\n$$\nf(0) = \\exp(-t \\cdot 0) = \\exp(0) = 1\n$$\n$$\nR(0) = \\frac{1 + a \\cdot 0}{1 + b \\cdot 0} = \\frac{1}{1} = 1\n$$\n因此，由于 $R(\\lambda)$ 的指定形式，对于任意选择的 $a$ 和 $b$，条件 $R(0) = f(0)$ 都成立。此约束虽然在上下文中很重要，但它被自动满足，并未产生关于 $a$ 或 $b$ 的方程。\n\n**约束 2：$R'(0) = f'(0)$**\n我们在 $\\lambda=0$ 处计算导数值：\n$$\nf'(0) = -t\\,\\exp(-t \\cdot 0) = -t\n$$\n$$\nR'(0) = \\frac{a - b}{(1 + b \\cdot 0)^2} = a - b\n$$\n令二者相等，得到我们第一个联系 $a$ 和 $b$ 的方程：\n$$\na - b = -t \\implies a = b - t\n$$\n\n**约束 3：$R(\\sigma) = f(\\sigma)$**\n我们在 $\\lambda=\\sigma$ 处计算函数的值：\n$$\nf(\\sigma) = \\exp(-t\\,\\sigma)\n$$\n$$\nR(\\sigma) = \\frac{1 + a\\,\\sigma}{1 + b\\,\\sigma}\n$$\n令二者相等，得到我们第二个方程：\n$$\n\\frac{1 + a\\,\\sigma}{1 + b\\,\\sigma} = \\exp(-t\\,\\sigma)\n$$\n\n现在，我们求解这个包含两个未知数 $a$ 和 $b$ 的二元方程组。我们将第二个约束中得到的 $a$ 的表达式代入第三个约束得到的方程中：\n$$\n\\frac{1 + (b - t)\\sigma}{1 + b\\,\\sigma} = \\exp(-t\\,\\sigma)\n$$\n我们继续求解 $b$：\n$$\n1 + b\\,\\sigma - t\\,\\sigma = (1 + b\\,\\sigma)\\exp(-t\\,\\sigma)\n$$\n$$\n1 + b\\,\\sigma - t\\,\\sigma = \\exp(-t\\,\\sigma) + b\\,\\sigma\\,\\exp(-t\\,\\sigma)\n$$\n合并含 $b$ 的项：\n$$\nb\\,\\sigma - b\\,\\sigma\\,\\exp(-t\\,\\sigma) = t\\,\\sigma - 1 + \\exp(-t\\,\\sigma)\n$$\n$$\nb\\,\\sigma(1 - \\exp(-t\\,\\sigma)) = t\\,\\sigma - 1 + \\exp(-t\\,\\sigma)\n$$\n解出 $b$：\n$$\nb = \\frac{t\\,\\sigma - 1 + \\exp(-t\\,\\sigma)}{\\sigma(1 - \\exp(-t\\,\\sigma))}\n$$\n现在我们用 $a = b - t$ 求出 $a$：\n$$\na = \\frac{t\\,\\sigma - 1 + \\exp(-t\\,\\sigma)}{\\sigma(1 - \\exp(-t\\,\\sigma))} - t\n$$\n$$\na = \\frac{t\\,\\sigma - 1 + \\exp(-t\\,\\sigma) - t\\,\\sigma(1 - \\exp(-t\\,\\sigma))}{\\sigma(1 - \\exp(-t\\,\\sigma))}\n$$\n$$\na = \\frac{t\\,\\sigma - 1 + \\exp(-t\\,\\sigma) - t\\,\\sigma + t\\,\\sigma\\,\\exp(-t\\,\\sigma)}{\\sigma(1 - \\exp(-t\\,\\sigma))}\n$$\n$$\na = \\frac{-1 + \\exp(-t\\,\\sigma) + t\\,\\sigma\\,\\exp(-t\\,\\sigma)}{\\sigma(1 - \\exp(-t\\,\\sigma))} = \\frac{\\exp(-t\\,\\sigma)(1+t\\,\\sigma) - 1}{\\sigma(1 - \\exp(-t\\,\\sigma))}\n$$\n确定了系数 $a$ 和 $b$ 后，我们将它们代回 $R(\\lambda)$ 的表达式中：\n$$\nR(\\lambda) = \\frac{1 + a\\,\\lambda}{1 + b\\,\\lambda} = \\frac{1 + \\lambda \\left( \\frac{\\exp(-t\\,\\sigma)(1+t\\,\\sigma) - 1}{\\sigma(1 - \\exp(-t\\,\\sigma))} \\right)}{1 + \\lambda \\left( \\frac{t\\,\\sigma - 1 + \\exp(-t\\,\\sigma)}{\\sigma(1 - \\exp(-t\\,\\sigma))} \\right)}\n$$\n为简化此繁分数，我们将分子和分母同乘以 $\\sigma(1 - \\exp(-t\\,\\sigma))$：\n$$\nR(\\lambda) = \\frac{\\sigma(1 - \\exp(-t\\,\\sigma)) + \\lambda(\\exp(-t\\,\\sigma)(1+t\\,\\sigma) - 1)}{\\sigma(1 - \\exp(-t\\,\\sigma)) + \\lambda(t\\,\\sigma - 1 + \\exp(-t\\,\\sigma))}\n$$\n这个表达式可以被重排成一个更具揭示性的结构。\n分子：\n$$\nN(\\lambda) = \\sigma - \\sigma\\,\\exp(-t\\,\\sigma) + \\lambda\\,t\\,\\sigma\\,\\exp(-t\\,\\sigma) + \\lambda\\,\\exp(-t\\,\\sigma) - \\lambda\n$$\n$$\nN(\\lambda) = (\\sigma-\\lambda)(1-\\exp(-t\\,\\sigma)) + \\lambda-\\lambda\\exp(-t\\,\\sigma) + \\lambda\\,t\\,\\sigma\\,\\exp(-t\\,\\sigma) + \\lambda\\,\\exp(-t\\,\\sigma) - \\lambda = (\\sigma-\\lambda)(1-\\exp(-t\\,\\sigma)) + \\lambda\\,t\\,\\sigma\\,\\exp(-t\\,\\sigma)\n$$\n分母：\n$$\nD(\\lambda) = \\sigma - \\sigma\\,\\exp(-t\\,\\sigma) + \\lambda\\,t\\,\\sigma - \\lambda + \\lambda\\,\\exp(-t\\,\\sigma)\n$$\n$$\nD(\\lambda) = (\\sigma-\\lambda)(1-\\exp(-t\\,\\sigma)) + \\lambda - \\lambda\\exp(-t\\,\\sigma) + \\lambda\\,t\\,\\sigma + \\lambda\\,\\exp(-t\\,\\sigma) - \\lambda = (\\sigma-\\lambda)(1-\\exp(-t\\,\\sigma)) + \\lambda\\,t\\,\\sigma\n$$\n合并这些项，得到有理近似式 $R(\\lambda)$ 的最终简化表达式：\n$$\nR(\\lambda) = \\frac{(\\sigma-\\lambda)(1-\\exp(-t\\,\\sigma)) + \\lambda\\,t\\,\\sigma\\,\\exp(-t\\,\\sigma)}{(\\sigma-\\lambda)(1-\\exp(-t\\,\\sigma)) + \\lambda\\,t\\,\\sigma}\n$$\n这就是所求的用 $\\lambda$、$t$ 和 $\\sigma$ 表示的近似式的闭式表达式。",
            "answer": "$$\n\\boxed{\\frac{(\\sigma-\\lambda)(1-\\exp(-t\\,\\sigma)) + \\lambda\\,t\\,\\sigma\\,\\exp(-t\\,\\sigma)}{(\\sigma-\\lambda)(1-\\exp(-t\\,\\sigma)) + \\lambda\\,t\\,\\sigma}}\n$$"
        },
        {
            "introduction": "在科学计算中，算法的选择常常需要在精度和计算成本之间做出权衡。CRAM 的阶数越高，精度通常也越高，但计算开销也随之增加。本练习  旨在解决这一实际工程问题，要求您实现一个自适应方案，该方案利用格氏圆盘等廉价的谱估计方法来动态判断问题的“难度”，并智能地选择最合适的 CRAM 阶数，从而在确保精度的同时优化计算性能。",
            "id": "4216710",
            "problem": "要求您设计并实现一个自适应选择方案，该方案能针对一个由实数方阵表示的给定线性算子，决定是使用16阶($16$)切比雪夫有理逼近方法（CRAM-16）还是32阶($32$)切比雪夫有理逼近方法（CRAM-32），来近似计算在核反应堆模拟中应用于状态向量的矩阵指数。该选择必须基于一个有理论依据且计算成本低的误差代理，且该代理的计算无需显式计算CRAM-16或CRAM-32。\n\n物理和数学背景如下。在许多反应堆物理模型中，状态向量 $y(t)$（例如，核素密度或多群中子通量）的时间演化由一个刚性线性常微分方程组控制\n$$\n\\frac{d}{dt} y(t) \\;=\\; -A\\,y(t),\n$$\n其中 $A \\in \\mathbb{R}^{n \\times n}$ 是一个矩阵，其元素为物理速率，单位为 $\\mathrm{s}^{-1}$，$t$ 是时间，单位为秒。在时间 $t$ 的精确解是\n$$\ny(t) \\;=\\; \\exp\\big(-\\,A\\,t\\big)\\,y(0).\n$$\n切比雪夫有理逼近方法（CRAM）通过一个有理函数在正实轴上逼近标量函数 $f(z) = \\exp(-z)$，然后通过泛函演算将此逼近提升至矩阵，从而为刚性矩阵 $A$ 高效且稳定地逼近 $\\exp(-A t)$。更高阶的CRAM（如CRAM-32）通常在正实轴上比低阶CRAM（如CRAM-16）产生更小的一致逼近误差，但计算成本更高。这里的目标是在进行任何CRAM计算之前，使用一个从 $tA$ 的谱中导出的廉价代理，在CRAM-16和CRAM-32之间进行选择。\n\n您的任务是实现以下内容：\n\n1. 定义一个误差代理，该代理为缩放算子 $tA$ 在正实轴上的谱分布范围提供一个上界。您可以使用以下任何经过充分测试且计算成本低的界：\n   - 基于盖尔什戈林圆盘（Gershgorin disc）的界：\n     $$\n     \\mu_G \\;=\\; t \\cdot \\max_{1 \\le i \\le n} \\sum_{j=1}^{n} \\big|a_{ij}\\big|,\n     $$\n     其中 $a_{ij}$ 是 $A$ 的第 $(i,j)$ 个元素。\n   - 使用算子范数的矩阵范数界：\n     $$\n     \\mu_1 \\;=\\; t \\cdot \\lVert A \\rVert_{1}, \\quad \\mu_{\\infty} \\;=\\; t \\cdot \\lVert A \\rVert_{\\infty},\n     $$\n     其中 $\\lVert \\cdot \\rVert_{1}$ 是最大绝对列和，$\\lVert \\cdot \\rVert_{\\infty}$ 是最大绝对行和。\n   - 一个可选的改进方法，通过几步幂迭代来估计 $tA$ 在 $2$-范数意义下的谱半径：\n     $$\n     \\mu_{2,\\mathrm{est}} \\;\\approx\\; \\frac{\\lVert (tA) v \\rVert_{2}}{\\lVert v \\rVert_{2}},\n     $$\n     对于一个非零向量 $v$，该向量通过与 $tA$ 的重复乘法进行更新，其中 $\\lVert \\cdot \\rVert_{2}$ 是欧几里得范数。\n\n2. 使用这些代理，根据以下原则定义阈值 $\\tau_{\\mathrm{low}}$ 和 $\\tau_{\\mathrm{high}}$：当 $tA$ 的谱在正实轴上紧密聚集在原点附近时（代理值较小），CRAM-16是足够的；当谱沿着正实轴延伸得更远时（代理值较大），则首选CRAM-32。对于介于两个阈值之间的模糊代理值，使用可选的幂迭代改进方法来做出最终决定。\n\n3. 实现一个函数，该函数接收一个元素单位为 $\\mathrm{s}^{-1}$ 的实数矩阵 $A$ 和一个单位为秒的时间步长 $t$，并根据上述自适应规则返回整数 $16$ 或 $32$。\n\n您的程序必须能够直接运行，并为以下测试套件生成结果。对于每个测试用例，都给定一个矩阵 $A$ 和一个时间 $t$：\n- 测试用例 1（理想情况，弱耦合慢速率）：\n  $$\n  A_1 \\;=\\; \\begin{bmatrix}\n  0.10  -0.02  0.00 \\\\\n  0.02  0.07  -0.01 \\\\\n  0.00  0.01  0.03\n  \\end{bmatrix}, \\quad t_1 \\;=\\; 0.10 \\text{ s}.\n  $$\n- 测试用例 2（刚性系统，快速移除率）：\n  $$\n  A_2 \\;=\\; \\begin{bmatrix}\n  10^{5}  -10^{3}  0  0 \\\\\n  10^{3}  10^{5}  -10^{3}  0 \\\\\n  0  10^{3}  10^{5}  -10^{3} \\\\\n  0  0  10^{3}  10^{5}\n  \\end{bmatrix}, \\quad t_2 \\;=\\; 10^{-3} \\text{ s}.\n  $$\n- 测试用例 3（近单位步长，极小时间）：\n  $$\n  A_3 \\;=\\; \\begin{bmatrix}\n  0.50  -0.20  0.10  0.00  0.00 \\\\\n  0.10  0.40  -0.15  0.05  0.00 \\\\\n  0.00  0.10  0.60  -0.25  0.05 \\\\\n  0.00  0.00  0.10  0.30  -0.10 \\\\\n  0.00  0.00  0.00  0.05  0.20\n  \\end{bmatrix}, \\quad t_3 \\;=\\; 10^{-8} \\text{ s}.\n  $$\n- 测试用例 4（非正常耦合，中到大有效尺度）：\n  $$\n  A_4 \\;=\\; \\begin{bmatrix}\n  10  -50  0 \\\\\n  0  10  -50 \\\\\n  0  0  10\n  \\end{bmatrix}, \\quad t_4 \\;=\\; 0.60 \\text{ s}.\n  $$\n- 测试用例 5（临界耦合与时间）：\n  $$\n  A_5 \\;=\\; \\begin{bmatrix}\n  5  -1  0  0  0 \\\\\n  1  5  -1  0  0 \\\\\n  0  1  5  -1  0 \\\\\n  0  0  1  5  -1 \\\\\n  0  0  0  1  5\n  \\end{bmatrix}, \\quad t_5 \\;=\\; 1.50 \\text{ s}.\n  $$\n\n所有矩阵元素 $a_{ij}$ 的单位均为 $\\mathrm{s}^{-1}$，所有时间 $t$ 的单位均为 $\\mathrm{s}$。如果出现任何角度量，您必须使用弧度，但在这些测试用例中没有出现角度。\n\n您的程序应生成单行输出，其中包含五个测试用例所选的阶数，格式为用方括号括起来的逗号分隔列表，例如，\n$$\n[\\dots]\n$$\n其中每个条目是相应测试用例的整数 $16$ 或 $32$。输出必须严格遵守此格式，不得包含任何额外文本。",
            "solution": "该解决方案基于第一性原理构建，它将底层物理、矩阵指数、有理逼近理论以及廉价的谱界定技术联系起来。\n\n1. 从刚性线性初值问题开始\n$$\n\\frac{d}{dt} y(t) \\;=\\; -A\\,y(t),\n$$\n其中 $A \\in \\mathbb{R}^{n \\times n}$ 是一个元素单位为 $\\mathrm{s}^{-1}$ 的实数矩阵。其精确解为\n$$\ny(t) \\;=\\; \\exp\\big(-A\\,t\\big)\\,y(0).\n$$\n当 $A$ 是刚性的（具有大特征值或强非正常耦合）时，如果不小心处理，直接计算矩阵指数可能会成本高昂或不稳定。\n\n2. 切比雪夫有理逼近方法（CRAM）构造一个有理函数 $R_n(z)$，该函数在正实轴上一致地逼近 $f(z) = \\exp(-z)$。$n$ 阶CRAM（例如 $n = 16$ 或 $n = 32$）使用 $R_n(z)$ 的部分分式分解，其中包含共轭复数极点-留数对，通过求解形如\n$$\n\\left( tA - \\theta_k I \\right) w_k \\;=\\; y(0).\n$$\n的移位线性系统来高效地计算 $R_n(tA)$。更高的 $n$ 通常会产生更小的一致逼近误差\n$$\n\\varepsilon_n \\;=\\; \\sup_{x \\in [0,\\infty)} \\big| \\exp(-x) - R_n(x) \\big|,\n$$\n其中 $\\varepsilon_{32} \\ll \\varepsilon_{16}$，但代价是需要进行更多的线性求解。\n\n3. 为了在进行任何CRAM计算之前自适应地选择阶数，我们使用谱代理来界定谱 $\\sigma(tA)$ 在正实轴上的分布范围。矩阵泛函演算表明 $R_n(tA)$ 的误差满足\n$$\n\\big\\| \\exp(-tA) - R_n(tA) \\big\\| \\;\\le\\; \\sup_{\\lambda \\in \\sigma(tA)} \\big| \\exp(-\\lambda) - R_n(\\lambda) \\big| \\;\\le\\; \\sup_{x \\in [0, \\mu]} \\big| \\exp(-x) - R_n(x) \\big|,\n$$\n其中 $\\mu$ 是 $\\sigma(tA)$ 在正实轴上实部位置的任意上界。因此，如果 $\\mu$ 很小，低阶CRAM就能达到期望的误差水平；如果 $\\mu$ 很大，则高阶CRAM更可取。\n\n4. 我们通过廉价且保守的界来获得 $\\mu$：\n   - 盖尔什戈林圆盘定理（Gershgorin circle theorem）得出，A的每个特征值 $\\lambda$ 至少位于一个以 $a_{ii}$ 为中心、半径为 $R_i = \\sum_{j \\ne i} |a_{ij}|$ 的圆盘内。对于正实轴上的非负尺度，一个简单的界是\n     $$\n     \\mu_G \\;=\\; t \\cdot \\max_{i} \\sum_{j} |a_{ij}|,\n     $$\n     这等于 $t$ 乘以最大绝对行和。这同时捕捉了对角线和耦合的强度。\n   - 算子范数给出\n     $$\n     \\mu_1 \\;=\\; t \\lVert A \\rVert_1, \\quad \\mu_{\\infty} \\;=\\; t \\lVert A \\rVert_{\\infty},\n     $$\n     两者计算成本都很低。为方便和保守起见，可以使用 $\\mu \\;=\\; \\max\\{\\mu_G, \\mu_1, \\mu_{\\infty}\\}$ 或简单地使用 $\\mu_G$ （因为 $\\mu_G = t\\lVert A \\rVert_{\\infty}$）。\n   - 在 $\\mu$ 既不大也不小的模糊区域，可通过几次幂迭代在 $2$-范数意义下改进估计：\n     $$\n     v_{k+1} \\;=\\; \\frac{tA\\,v_k}{\\lVert tA\\,v_k \\rVert_2}, \\quad \\mu_{2,\\mathrm{est}} \\;\\approx\\; \\frac{\\lVert tA\\,v_k \\rVert_2}{\\lVert v_k \\rVert_2}.\n     $$\n     这可以估计出 $2$-范数意义下的算子范数，对于非正常矩阵很有信息价值。\n\n5. 决策逻辑。选择阈值 $\\tau_{\\mathrm{low}}$ 和 $\\tau_{\\mathrm{high}}$ 以反映CRAM-16和CRAM-32的典型一致误差断点。具体数值取决于已发表的极小化极大误差曲线；这里我们设定保守值以体现其意图：如果 $\\mu \\le \\tau_{\\mathrm{low}}$，选择CRAM-16；如果 $\\mu \\ge \\tau_{\\mathrm{high}}$，选择CRAM-32；如果 $\\tau_{\\mathrm{low}}  \\mu  \\tau_{\\mathrm{high}}$，则使用改进后的估计值 $\\mu_{2,\\mathrm{est}}$ 并与一个中间阈值比较来决定。与实际构建CRAM-32相比，该方案的计算量微不足道，并且在各种刚性和非正常性范围内都具有鲁棒性。\n\n6. 测试套件覆盖范围：\n   - 测试用例1是一个弱耦合、慢速率的系统，且 $t$ 很小，因此 $\\mu$ 非常小，CRAM-16足够。\n   - 测试用例2具有非常大的移除率和小 $t$，但 $t\\lVert A \\rVert_{\\infty}$ 足够大，为了精度应选择CRAM-32。\n   - 测试用例3使用极小的时间，使步长接近单位矩阵，适合选择CRAM-16。\n   - 测试用例4是非正常的，具有强非对角耦合和中等时间，产生较大的 $\\mu$，适合选择CRAM-32。\n   - 测试用例5位于下阈值附近，根据保守界，选择CRAM-16。\n\n7. 实现细节。计算 $\\mu_G = t \\max_i \\sum_j |a_{ij}|$ 并与 $\\tau_{\\mathrm{low}}$ 和 $\\tau_{\\mathrm{high}}$ 进行比较。如果需要，运行几次（例如20次）幂迭代来估计 $\\mu_{2,\\mathrm{est}}$ 并与一个中间点阈值进行比较。每个测试用例的最终输出是整数 $16$ 或 $32$。除了单位为 $\\mathrm{s}^{-1}$ 的矩阵元素和单位为 $\\mathrm{s}$ 的时间外，不打印任何物理量；因此，输出是无量纲整数。\n\n这种基于原理的选择利用了紧密相连的基础理论：$\\exp(-tA)$ 在刚性线性反应堆模型中的作用，CRAM在正实轴上的一致有理逼近误差，以及经典的谱界（盖尔什戈林圆盘和算子范数），从而以可忽略的计算开销决定合适的逼近阶数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef gershgorin_row_sum_bound(A: np.ndarray) - float:\n    \"\"\"\n    Compute the maximum absolute row sum of A, which equals the infinity norm ||A||_inf.\n    This serves as a Gershgorin-based bound on the spectral spread relevant to the positive real axis.\n    \"\"\"\n    return np.max(np.sum(np.abs(A), axis=1))\n\ndef power_iteration_norm_estimate(M: np.ndarray, iterations: int = 20, seed: int = 0) - float:\n    \"\"\"\n    Estimate the operator 2-norm of matrix M using power iteration on M^T M implicitly\n    by repeatedly applying M to a vector and measuring amplification.\n    For non-normal matrices this is an estimate; it is inexpensive and often informative.\n    \"\"\"\n    rng = np.random.default_rng(seed)\n    v = rng.standard_normal(M.shape[1])\n    v_norm = np.linalg.norm(v)\n    if v_norm == 0.0:\n        v = np.ones(M.shape[1])\n        v_norm = np.linalg.norm(v)\n    v = v / v_norm\n    for _ in range(iterations):\n        w = M @ v\n        w_norm = np.linalg.norm(w)\n        if w_norm == 0.0:\n            # M annihilates v; return zero estimate\n            return 0.0\n        v = w / w_norm\n    # Final amplification factor of the last step as a proxy\n    return np.linalg.norm(M @ v) / np.linalg.norm(v)\n\ndef choose_cram_order(A: np.ndarray, t: float,\n                      tau_low: float = 12.0,\n                      tau_high: float = 30.0,\n                      mid_factor: float = 20.0) - int:\n    \"\"\"\n    Adaptive selection between CRAM-16 and CRAM-32 using cheap spectral proxies.\n\n    Parameters:\n        A: Real square matrix with entries in s^{-1}.\n        t: Time step in seconds.\n        tau_low: Lower threshold for proxy deciding CRAM-16.\n        tau_high: Upper threshold for proxy deciding CRAM-32.\n        mid_factor: Midpoint threshold used with power iteration when proxy is ambiguous.\n\n    Returns:\n        16 or 32 indicating selected CRAM order.\n    \"\"\"\n    # Cheap Gershgorin (infinity norm) bound scaled by t\n    mu_g = t * gershgorin_row_sum_bound(A)\n\n    if mu_g = tau_low:\n        return 16\n    if mu_g >= tau_high:\n        return 32\n\n    # Ambiguous region: refine using a few steps of power iteration on t*A\n    M = t * A\n    mu2_est = power_iteration_norm_estimate(M, iterations=20, seed=42)\n\n    # Decide using mid_factor as a middle threshold\n    if mu2_est = mid_factor:\n        return 16\n    else:\n        return 32\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Each case is (A, t)\n        (\n            np.array([\n                [0.10, -0.02, 0.00],\n                [0.02,  0.07, -0.01],\n                [0.00,  0.01,  0.03]\n            ], dtype=float),\n            0.10\n        ),\n        (\n            np.array([\n                [1e5, -1e3, 0.0, 0.0],\n                [1e3,  1e5, -1e3, 0.0],\n                [0.0,  1e3,  1e5, -1e3],\n                [0.0,  0.0,  1e3,  1e5]\n            ], dtype=float),\n            1e-3\n        ),\n        (\n            np.array([\n                [0.50, -0.20,  0.10,  0.00,  0.00],\n                [0.10,  0.40, -0.15,  0.05,  0.00],\n                [0.00,  0.10,  0.60, -0.25,  0.05],\n                [0.00,  0.00,  0.10,  0.30, -0.10],\n                [0.00,  0.00,  0.00,  0.05,  0.20]\n            ], dtype=float),\n            1e-8\n        ),\n        (\n            np.array([\n                [10.0, -50.0,   0.0],\n                [ 0.0,  10.0, -50.0],\n                [ 0.0,   0.0,  10.0]\n            ], dtype=float),\n            0.60\n        ),\n        (\n            np.array([\n                [5.0, -1.0,  0.0,  0.0,  0.0],\n                [1.0,  5.0, -1.0,  0.0,  0.0],\n                [0.0,  1.0,  5.0, -1.0,  0.0],\n                [0.0,  0.0,  1.0,  5.0, -1.0],\n                [0.0,  0.0,  0.0,  1.0,  5.0]\n            ], dtype=float),\n            1.50\n        )\n    ]\n\n    results = []\n    for A, t in test_cases:\n        order = choose_cram_order(A, t,\n                                  tau_low=12.0,\n                                  tau_high=30.0,\n                                  mid_factor=20.0)\n        results.append(order)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}