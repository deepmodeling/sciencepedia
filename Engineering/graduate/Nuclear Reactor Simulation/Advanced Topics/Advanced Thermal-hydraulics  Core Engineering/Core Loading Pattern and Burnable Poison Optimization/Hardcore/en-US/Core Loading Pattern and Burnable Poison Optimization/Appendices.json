{
    "hands_on_practices": [
        {
            "introduction": "This first practice introduces the fundamental parameters that characterize a nuclear fuel assembly: the infinite multiplication factor ($k_{\\infty}$) and the pin power peaking factor ($PF$). You will explore how the strategic placement of non-fissile burnable poison (BP) pins within the fuel lattice directly influences these key performance and safety metrics. This exercise provides a hands-on feel for the trade-offs in lattice design using a simplified, but physically representative, frozen-flux model.",
            "id": "4219374",
            "problem": "You are given a simplified, but scientifically faithful, two-group infinite-lattice model of a square fuel assembly in a nuclear reactor core. The goal is to quantify how moving two Burnable Poison (BP) pins from interior positions to corner positions changes the assembly infinite multiplication factor and the pin power peaking factor, using lattice-calculated macroscopic constants and provided flux maps. You must implement a program that computes these changes for a specified test suite of cases and prints a single aggregated output line.\n\nThe fundamental base is the stationary neutron balance in an infinite medium, represented in a two-energy-group approximation. Let the square assembly have a grid of $N \\times N$ pins indexed by integer coordinates $(i,j)$ with $i,j \\in \\{0,1,\\dots,N-1\\}$. For each pin $(i,j)$, and each energy group $g \\in \\{1,2\\}$, let the scalar flux be denoted by $\\phi_g(i,j)$, and let the macroscopic absorption and production parameters of the assigned pin material $m(i,j)$ be denoted by $\\Sigma_{a,g}(m)$ and $\\nu\\Sigma_{f,g}(m)$, respectively. All macroscopic cross-sections are in $\\mathrm{cm}^{-1}$.\n\nWe define the infinite multiplication factor, $k_{\\infty}$, from first principles as the ratio of total neutron production rate to total absorption rate in the infinite medium:\n$$\nk_{\\infty} \\equiv \\frac{\\sum_{i=0}^{N-1}\\sum_{j=0}^{N-1}\\sum_{g=1}^{2} \\nu\\Sigma_{f,g}(m(i,j)) \\, \\phi_g(i,j)}{\\sum_{i=0}^{N-1}\\sum_{j=0}^{N-1}\\sum_{g=1}^{2} \\Sigma_{a,g}(m(i,j)) \\, \\phi_g(i,j)}.\n$$\nWe consider a “frozen flux” approximation for small reconfigurations: the flux maps $\\{\\phi_g(i,j)\\}$ are taken from a reference lattice calculation of the baseline configuration (with the BP pins at interior positions), and are reused as weights when evaluating reaction-rate changes under the pin move. This corresponds to a first-order computation consistent with perturbative reasoning when the material perturbation is modest and leakage is negligible.\n\nFor pin power peaking, we adopt the standard lattice proxy that pin power is proportional to the fission source density, which is proportional to $\\sum_{g=1}^{2} \\nu\\Sigma_{f,g}(m(i,j)) \\, \\phi_g(i,j)$. The assembly pin power peaking factor, $PF$, is then defined by\n$$\nPF \\equiv \\frac{\\max_{i,j} \\left( \\sum_{g=1}^{2} \\nu\\Sigma_{f,g}(m(i,j)) \\, \\phi_g(i,j) \\right)}{\\frac{1}{N^2} \\sum_{i=0}^{N-1}\\sum_{j=0}^{N-1}\\left( \\sum_{g=1}^{2} \\nu\\Sigma_{f,g}(m(i,j)) \\, \\phi_g(i,j) \\right)}.\n$$\n\nYour program must:\n- Construct the baseline material map $m_{\\mathrm{base}}(i,j)$ with two BP pins at specified interior coordinates and all other pins as fuel.\n- Construct the moved material map $m_{\\mathrm{moved}}(i,j)$ by moving those two BP pins to specified corner coordinates, converting the interior locations to fuel.\n- Generate two-group flux maps $\\phi_1(i,j)$ and $\\phi_2(i,j)$ using the provided parametric form that mimics lattice-calculated flux shapes, and normalize each group so that $\\sum_{i,j}\\phi_g(i,j)=1$ for $g \\in \\{1,2\\}$.\n- Compute $k_{\\infty}$ for baseline and moved maps under the frozen-flux approximation and report $\\Delta k_{\\infty} \\equiv k_{\\infty}^{\\mathrm{moved}} - k_{\\infty}^{\\mathrm{base}}$.\n- Compute $PF$ for baseline and moved maps and report $\\Delta PF \\equiv PF^{\\mathrm{moved}} - PF^{\\mathrm{base}}$.\n\nFlux map generation: For each group $g$, let $\\gamma_g$ be a nonnegative shape parameter. For pin $(i,j)$, define the squared radial index relative to the assembly center as\n$$\nr^2(i,j) \\equiv \\left(i - \\frac{N-1}{2}\\right)^2 + \\left(j - \\frac{N-1}{2}\\right)^2.\n$$\nDefine the raw flux by\n$$\n\\phi^{\\mathrm{raw}}_g(i,j) \\equiv \\max\\!\\left(\\varepsilon, \\, 1 - \\gamma_g \\, r^2(i,j)\\right),\n$$\nwith $\\varepsilon = 10^{-8}$, and normalize to obtain $\\phi_g(i,j) \\equiv \\phi^{\\mathrm{raw}}_g(i,j) \\big/ \\left( \\sum_{p,q} \\phi^{\\mathrm{raw}}_g(p,q)\\right)$, ensuring $\\sum_{i,j}\\phi_g(i,j)=1$ for each group.\n\nMaterials: Fuel pins have macroscopic parameters $\\Sigma_{a,1}(\\mathrm{fuel})$, $\\Sigma_{a,2}(\\mathrm{fuel})$, $\\nu\\Sigma_{f,1}(\\mathrm{fuel})$, and $\\nu\\Sigma_{f,2}(\\mathrm{fuel})$. Burnable Poison (BP) pins have $\\Sigma_{a,1}(\\mathrm{BP})$, $\\Sigma_{a,2}(\\mathrm{BP})$, and $\\nu\\Sigma_{f,g}(\\mathrm{BP}) = 0$ for $g \\in \\{1,2\\}$ to represent the non-fissile absorber.\n\nTest suite and parameters:\n- Case $1$ (happy path):\n  - $N = 5$.\n  - Interior BP pins at $(2,2)$ and $(2,3)$; moved to corners $(0,0)$ and $(0,4)$.\n  - Flux shape parameters: $\\gamma_1 = 0.02$, $\\gamma_2 = 0.06$.\n  - Fuel: $\\Sigma_{a,1}(\\mathrm{fuel}) = 0.02$, $\\Sigma_{a,2}(\\mathrm{fuel}) = 0.08$, $\\nu\\Sigma_{f,1}(\\mathrm{fuel}) = 0.005$, $\\nu\\Sigma_{f,2}(\\mathrm{fuel}) = 0.12$.\n  - BP: $\\Sigma_{a,1}(\\mathrm{BP}) = 0.03$, $\\Sigma_{a,2}(\\mathrm{BP}) = 0.20$, $\\nu\\Sigma_{f,1}(\\mathrm{BP}) = 0.0$, $\\nu\\Sigma_{f,2}(\\mathrm{BP}) = 0.0$.\n- Case $2$ (boundary condition: uniform flux):\n  - $N = 5$.\n  - Interior BP pins at $(2,2)$ and $(1,3)$; moved to corners $(0,0)$ and $(4,4)$.\n  - Flux shape parameters: $\\gamma_1 = 0.0$, $\\gamma_2 = 0.0$.\n  - Fuel and BP macroscopic parameters identical to Case $1$.\n- Case $3$ (stronger thermal absorption in BP, larger assembly):\n  - $N = 7$.\n  - Interior BP pins at $(3,3)$ and $(3,4)$; moved to corners $(0,6)$ and $(6,0)$.\n  - Flux shape parameters: $\\gamma_1 = 0.01$, $\\gamma_2 = 0.04$.\n  - Fuel: $\\Sigma_{a,1}(\\mathrm{fuel}) = 0.025$, $\\Sigma_{a,2}(\\mathrm{fuel}) = 0.09$, $\\nu\\Sigma_{f,1}(\\mathrm{fuel}) = 0.004$, $\\nu\\Sigma_{f,2}(\\mathrm{fuel}) = 0.11$.\n  - BP: $\\Sigma_{a,1}(\\mathrm{BP}) = 0.035$, $\\Sigma_{a,2}(\\mathrm{BP}) = 0.30$, $\\nu\\Sigma_{f,1}(\\mathrm{BP}) = 0.0$, $\\nu\\Sigma_{f,2}(\\mathrm{BP}) = 0.0$.\n\nComputational requirements:\n- Use the provided parametric flux model and normalize each group’s flux to satisfy $\\sum_{i,j}\\phi_g(i,j)=1$ for $g \\in \\{1,2\\}$.\n- Compute $k_{\\infty}$ and $PF$ for baseline and moved configurations as defined above.\n- Report $\\Delta k_{\\infty}$ and $\\Delta PF$ for each case. Both quantities are dimensionless and must be expressed as decimals.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, ordered as $[\\Delta k_{\\infty}^{(1)}, \\Delta PF^{(1)}, \\Delta k_{\\infty}^{(2)}, \\Delta PF^{(2)}, \\Delta k_{\\infty}^{(3)}, \\Delta PF^{(3)}]$, where the superscript indicates the case number. No additional text should be printed.",
            "solution": "The problem requires the quantification of changes in the infinite multiplication factor, $k_{\\infty}$, and the pin power peaking factor, $PF$, in a simplified two-group nuclear fuel assembly model. These changes result from relocating two Burnable Poison (BP) pins from interior positions to corner positions. The analysis is performed under a \"frozen flux\" approximation, a standard perturbative approach where the neutron flux distribution is assumed to remain unchanged by the material perturbation.\n\nThe solution is implemented by following a structured, step-by-step computational procedure for each test case provided.\n\n### 1. Flux Map Generation\n\nThe neutron flux distribution within the assembly is modeled for two energy groups, a fast group ($g=1$) and a thermal group ($g=2$). For an $N \\times N$ assembly grid with pin coordinates $(i,j)$ for $i,j \\in \\{0, 1, \\dots, N-1\\}$, the flux shape is parametrically defined.\n\nFirst, the squared radial distance of each pin from the geometric center of the assembly is calculated. The center is located at coordinates $(\\frac{N-1}{2}, \\frac{N-1}{2})$. The squared radial index is:\n$$\nr^2(i,j) = \\left(i - \\frac{N-1}{2}\\right)^2 + \\left(j - \\frac{N-1}{2}\\right)^2\n$$\nNext, a raw (un-normalized) flux map for each group $g$ is generated using a parabolic depression model controlled by a shape parameter $\\gamma_g$:\n$$\n\\phi^{\\mathrm{raw}}_g(i,j) = \\max\\!\\left(\\varepsilon, \\, 1 - \\gamma_g \\, r^2(i,j)\\right)\n$$\nwhere $\\varepsilon = 10^{-8}$ is a small positive constant to ensure the flux is strictly positive. This shape reflects the self-shielding effect where flux is typically lower in the center of a fuel assembly. A value of $\\gamma_g = 0$ results in a spatially uniform flux.\n\nFinally, each raw flux map is normalized such that the sum of all pin fluxes in a group equals one. This is crucial for their use as weighting functions in reaction rate calculations. The normalized flux $\\phi_g(i,j)$ is:\n$$\n\\phi_g(i,j) = \\frac{\\phi^{\\mathrm{raw}}_g(i,j)}{\\sum_{p=0}^{N-1}\\sum_{q=0}^{N-1} \\phi^{\\mathrm{raw}}_g(p,q)}\n$$\nThis process yields two $N \\times N$ matrices, $\\phi_1$ and $\\phi_2$, representing the normalized fast and thermal flux distributions. Crucially, under the frozen flux approximation, these flux maps, calculated based on the baseline configuration's parameters, are used for calculations of both the baseline and the moved configurations.\n\n### 2. Material and Cross-Section Mapping\n\nTwo material configurations are considered: a 'baseline' and a 'moved' configuration. In the baseline, two BP pins are at specified interior locations, with all other pins being fuel. In the moved configuration, these BP pins are relocated to corner positions, and their former interior positions are filled with fuel.\n\nFor each configuration, we construct $N \\times N$ maps for all relevant macroscopic cross-sections: $\\Sigma_{a,1}(\\mathbf{r})$, $\\Sigma_{a,2}(\\mathbf{r})$, $\\nu\\Sigma_{f,1}(\\mathbf{r})$, and $\\nu\\Sigma_{f,2}(\\mathbf{r})$, where $\\mathbf{r}$ denotes the pin location $(i,j)$. Each element $(i,j)$ of a cross-section map is assigned the value corresponding to the material (fuel or BP) at that location. For instance, the map for the group $1$ absorption cross-section, $\\Sigma_{a,1}(\\mathbf{r})$, will contain $\\Sigma_{a,1}(\\mathrm{fuel})$ at fuel pin locations and $\\Sigma_{a,1}(\\mathrm{BP})$ at BP pin locations.\n\n### 3. Calculation of Infinite Multiplication Factor ($k_{\\infty}$)\n\nThe infinite multiplication factor, $k_{\\infty}$, is the ratio of the total rate of neutron production to the total rate of neutron absorption across the entire assembly. Using the generated flux and cross-section maps, these rates are calculated as sums over all pins and both energy groups.\n\nThe total production rate, $P$, is:\n$$\nP = \\sum_{i=0}^{N-1}\\sum_{j=0}^{N-1} \\left( \\nu\\Sigma_{f,1}(i,j) \\, \\phi_1(i,j) + \\nu\\Sigma_{f,2}(i,j) \\, \\phi_2(i,j) \\right)\n$$\nThe total absorption rate, $A$, is:\n$$\nA = \\sum_{i=0}^{N-1}\\sum_{j=0}^{N-1} \\left( \\Sigma_{a,1}(i,j) \\, \\phi_1(i,j) + \\Sigma_{a,2}(i,j) \\, \\phi_2(i,j) \\right)\n$$\nFrom these, we compute $k_{\\infty}$:\n$$\nk_{\\infty} = \\frac{P}{A}\n$$\nThis calculation is performed for both the baseline configuration ($k_{\\infty}^{\\mathrm{base}}$) and the moved configuration ($k_{\\infty}^{\\mathrm{moved}}$), using the respective cross-section maps but the same frozen flux maps.\n\n### 4. Calculation of Pin Power Peaking Factor ($PF$)\n\nThe pin power peaking factor, $PF$, measures the power of the most-loaded pin relative to the average pin power. In this model, pin power is proportional to the fission source density, $S(i,j)$.\n\nFirst, we compute the pin-wise fission source density map:\n$$\nS(i,j) = \\nu\\Sigma_{f,1}(i,j) \\, \\phi_1(i,j) + \\nu\\Sigma_{f,2}(i,j) \\, \\phi_2(i,j)\n$$\nThe maximum pin power is the maximum value in this map:\n$$\nS_{\\max} = \\max_{i,j} S(i,j)\n$$\nThe average pin power is the total production rate $P$ divided by the number of pins, $N^2$:\n$$\nS_{\\mathrm{avg}} = \\frac{1}{N^2} \\sum_{i=0}^{N-1}\\sum_{j=0}^{N-1} S(i,j) = \\frac{P}{N^2}\n$$\nThe pin power peaking factor is the ratio of the maximum to the average:\n$$\nPF = \\frac{S_{\\max}}{S_{\\mathrm{avg}}}\n$$\nSimilar to $k_{\\infty}$, $PF^{\\mathrm{base}}$ and $PF^{\\mathrm{moved}}$ are calculated for the two configurations.\n\n### 5. Final Output Calculation\n\nThe final required outputs are the differences in these parameters between the moved and baseline configurations:\n$$\n\\Delta k_{\\infty} = k_{\\infty}^{\\mathrm{moved}} - k_{\\infty}^{\\mathrm{base}}\n$$\n$$\n\\Delta PF = PF^{\\mathrm{moved}} - PF^{\\mathrm{base}}\n$$\nThis entire procedure is repeated for each of the three test cases specified, and the resulting six values are aggregated into the final output format.\nMoving a strongly absorbing, non-fissile BP pin from a high-flux interior region to a lower-flux corner region is expected to increase reactivity (positive $\\Delta k_{\\infty}$) because less absorption occurs in the region of highest neutron importance. This move also tends to flatten the power distribution, as high-power central pins are replaced by fuel, but the change in $PF$ can be complex, depending on the flux shape and the specific locations involved.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the nuclear fuel assembly problem for a suite of test cases.\n    \"\"\"\n\n    test_cases = [\n        # Case 1 (happy path)\n        {\n            \"N\": 5,\n            \"bp_base_locs\": [(2, 2), (2, 3)],\n            \"bp_moved_locs\": [(0, 0), (0, 4)],\n            \"gamma1\": 0.02, \"gamma2\": 0.06,\n            \"fuel_props\": {\"Sa1\": 0.02, \"Sa2\": 0.08, \"nuSf1\": 0.005, \"nuSf2\": 0.12},\n            \"bp_props\": {\"Sa1\": 0.03, \"Sa2\": 0.20, \"nuSf1\": 0.0, \"nuSf2\": 0.0},\n        },\n        # Case 2 (boundary condition: uniform flux)\n        {\n            \"N\": 5,\n            \"bp_base_locs\": [(2, 2), (1, 3)],\n            \"bp_moved_locs\": [(0, 0), (4, 4)],\n            \"gamma1\": 0.0, \"gamma2\": 0.0,\n            \"fuel_props\": {\"Sa1\": 0.02, \"Sa2\": 0.08, \"nuSf1\": 0.005, \"nuSf2\": 0.12},\n            \"bp_props\": {\"Sa1\": 0.03, \"Sa2\": 0.20, \"nuSf1\": 0.0, \"nuSf2\": 0.0},\n        },\n        # Case 3 (stronger thermal absorption in BP, larger assembly)\n        {\n            \"N\": 7,\n            \"bp_base_locs\": [(3, 3), (3, 4)],\n            \"bp_moved_locs\": [(0, 6), (6, 0)],\n            \"gamma1\": 0.01, \"gamma2\": 0.04,\n            \"fuel_props\": {\"Sa1\": 0.025, \"Sa2\": 0.09, \"nuSf1\": 0.004, \"nuSf2\": 0.11},\n            \"bp_props\": {\"Sa1\": 0.035, \"Sa2\": 0.30, \"nuSf1\": 0.0, \"nuSf2\": 0.0},\n        },\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        N = case[\"N\"]\n        \n        # Step 1: Generate frozen flux maps based on baseline parameters\n        phi1_map, phi2_map = generate_flux_maps(N, case[\"gamma1\"], case[\"gamma2\"])\n\n        # Step 2: Calculate metrics for baseline configuration\n        k_inf_base, pf_base = calculate_metrics(\n            N, case[\"bp_base_locs\"], phi1_map, phi2_map, case[\"fuel_props\"], case[\"bp_props\"]\n        )\n\n        # Step 3: Calculate metrics for moved configuration\n        k_inf_moved, pf_moved = calculate_metrics(\n            N, case[\"bp_moved_locs\"], phi1_map, phi2_map, case[\"fuel_props\"], case[\"bp_props\"]\n        )\n\n        # Step 4: Compute the deltas\n        delta_k_inf = k_inf_moved - k_inf_base\n        delta_pf = pf_moved - pf_base\n\n        results.extend([delta_k_inf, delta_pf])\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(f'{r:.10f}' for r in results)}]\")\n\n\ndef generate_flux_maps(N, gamma1, gamma2):\n    \"\"\"\n    Generates normalized two-group flux maps based on a parametric model.\n    \"\"\"\n    epsilon = 1e-8\n    indices = np.arange(N)\n    i, j = np.meshgrid(indices, indices, indexing='ij')\n\n    center = (N - 1) / 2.0\n    r_squared = (i - center)**2 + (j - center)**2\n\n    phi_raw_1 = np.maximum(epsilon, 1 - gamma1 * r_squared)\n    phi_raw_2 = np.maximum(epsilon, 1 - gamma2 * r_squared)\n\n    phi1_map = phi_raw_1 / np.sum(phi_raw_1)\n    phi2_map = phi_raw_2 / np.sum(phi_raw_2)\n\n    return phi1_map, phi2_map\n\n\ndef calculate_metrics(N, bp_locs, phi1_map, phi2_map, fuel_props, bp_props):\n    \"\"\"\n    Calculates k_inf and PF for a given material configuration and flux maps.\n    \"\"\"\n    # Create material map: 0 for fuel, 1 for BP\n    material_map = np.zeros((N, N), dtype=int)\n    for r, c in bp_locs:\n        material_map[r, c] = 1\n\n    # Create full cross-section maps using advanced indexing\n    Sa1_map = np.array([fuel_props[\"Sa1\"], bp_props[\"Sa1\"]])[material_map]\n    Sa2_map = np.array([fuel_props[\"Sa2\"], bp_props[\"Sa2\"]])[material_map]\n    nuSf1_map = np.array([fuel_props[\"nuSf1\"], bp_props[\"nuSf1\"]])[material_map]\n    nuSf2_map = np.array([fuel_props[\"nuSf2\"], bp_props[\"nuSf2\"]])[material_map]\n\n    # Calculate total production and absorption rates\n    total_production = np.sum(nuSf1_map * phi1_map + nuSf2_map * phi2_map)\n    total_absorption = np.sum(Sa1_map * phi1_map + Sa2_map * phi2_map)\n\n    # Calculate k_inf\n    k_inf = total_production / total_absorption if total_absorption != 0 else 0.0\n    \n    # Calculate pin power peaking factor (PF)\n    # Pin power is proportional to fission source density\n    pin_power_map = nuSf1_map * phi1_map + nuSf2_map * phi2_map\n    \n    if total_production  0:\n        max_pin_power = np.max(pin_power_map)\n        avg_pin_power = total_production / (N * N)\n        pf = max_pin_power / avg_pin_power\n    else: # Should not happen with fuel in the assembly\n        pf = 1.0\n\n    return k_inf, pf\n\nsolve()\n```"
        },
        {
            "introduction": "This exercise explores the crucial non-linear phenomenon of burnable poison self-shielding, a step beyond the linear analysis of poison placement . You will model how the poison's effective absorption cross section dynamically changes with the local neutron flux, which is in turn affected by moderator conditions. Solving this coupled problem reveals how moderator density feedback alters the poison's reactivity hold-down, a vital aspect of reactor safety and control.",
            "id": "4219370",
            "problem": "Consider a homogeneous infinite-medium unit cell representing a fuel-moderator lattice containing burnable poison. Assume a single, thermal-energy group for neutron balance and a simplified self-shielding model for the burnable poison. The goal is to compute how changes in moderator number density affect the thermal neutron flux, the poison effective microscopic absorption cross section, and the resulting reactivity hold-down introduced by the poison. All quantities in this problem are to be treated as dimensionless normalized parameters, and all outputs must be reported as dimensionless floating-point numbers.\n\nFundamental base and definitions:\n- Use the one-group diffusion balance in an infinite medium: the thermal group balance reduces to a source-removal relation derived from the neutron diffusion equation, namely that the volume-averaged thermal neutron flux $ \\phi $ satisfies $ \\Sigma_{r} \\, \\phi = S $, where $ \\Sigma_{r} $ is the macroscopic removal cross section and $ S $ is the effective thermal source. In an infinite homogeneous medium with zero spatial gradient, $ \\Sigma_{r} $ reduces to an effective absorption term in this simplified context.\n- Let the thermal source $ S $ be proportional to the moderator number density because the slowing-down source is dominated by scattering interactions, so $ S = S_{0} \\, \\rho_{m} $, where $ S_{0} $ is a constant normalization and $ \\rho_{m} $ is the moderator density multiplier relative to a nominal condition.\n- The total thermal absorption macroscopic cross section $ \\Sigma_{a,\\text{tot}} $ is a sum of contributions from fuel, moderator, and burnable poison: $ \\Sigma_{a,\\text{tot}} = \\Sigma_{a,\\text{fuel}} + \\Sigma_{a,\\text{mod}} + \\Sigma_{a,\\text{poison,eff}} $. Assume that $ \\Sigma_{a,\\text{mod}} = \\rho_{m} \\, \\Sigma_{a,\\text{mod,nom}} $ scales linearly with moderator density.\n- The burnable poison effective macroscopic absorption cross section is $ \\Sigma_{a,\\text{poison,eff}} = N_{p} \\, \\sigma_{p,\\text{eff}} $, where $ N_{p} $ is the dimensionless poison number density multiplier and $ \\sigma_{p,\\text{eff}} $ is the effective microscopic absorption cross section.\n- Model poison self-shielding using a simplified collision-probability-inspired nonlinear attenuation relation: $ \\sigma_{p,\\text{eff}} = \\dfrac{\\sigma_{p}}{1 + b \\, \\phi \\, \\sigma_{p}} $, where $ \\sigma_{p} $ is the unshielded microscopic absorption parameter and $ b $ is a dimensionless lump-geometry and resonance saturation parameter. This captures the reduction of the effective cross section due to flux depression inside absorbers and the spectral insensitivity of a single thermal group. This relation implies a coupling between $ \\phi $ and $ \\sigma_{p,\\text{eff}} $.\n- With these definitions, the thermal flux $ \\phi $ is determined by the fixed-point relation $ \\phi = \\dfrac{S_{0} \\, \\rho_{m}}{\\Sigma_{a,\\text{fuel}} + \\rho_{m} \\, \\Sigma_{a,\\text{mod,nom}} + N_{p} \\, \\sigma_{p,\\text{eff}}(\\phi)} $, which must be solved consistently because $ \\sigma_{p,\\text{eff}} $ depends on $ \\phi $.\n- Use the infinite-medium one-group effective multiplication factor definition $ k = \\dfrac{\\nu \\Sigma_{f}}{\\Sigma_{a,\\text{tot}}} $, where $ \\nu \\Sigma_{f} $ is the dimensionless (normalized) effective neutron production term. The reactivity is $ \\rho = \\dfrac{k - 1}{k} = 1 - \\dfrac{\\Sigma_{a,\\text{tot}}}{\\nu \\Sigma_{f}} $. Define the poison reactivity hold-down as the difference between the reactivity with poison and the reactivity without poison at the same moderator density: $ \\Delta \\rho_{\\text{hold}}(\\rho_{m}) = \\rho_{\\text{with poison}}(\\rho_{m}) - \\rho_{\\text{without poison}}(\\rho_{m}) $, which is typically negative.\n\nTask:\n- For each test case, given a nominal moderator density $ \\rho_{m,0} $ and a perturbed moderator density $ \\rho_{m,1} $, compute:\n  1. The change in the burnable poison effective microscopic absorption cross section $ \\Delta \\sigma_{p,\\text{eff}} = \\sigma_{p,\\text{eff}}(\\rho_{m,1}) - \\sigma_{p,\\text{eff}}(\\rho_{m,0}) $.\n  2. The change in poison reactivity hold-down $ \\Delta \\left( \\Delta \\rho_{\\text{hold}} \\right) = \\Delta \\rho_{\\text{hold}}(\\rho_{m,1}) - \\Delta \\rho_{\\text{hold}}(\\rho_{m,0}) $.\n\nAlgorithmic requirements:\n- For each $ \\rho_{m} \\in \\{ \\rho_{m,0}, \\rho_{m,1} \\} $:\n  - Compute $ \\Sigma_{a,\\text{mod}} = \\rho_{m} \\, \\Sigma_{a,\\text{mod,nom}} $.\n  - Solve the fixed-point equation for $ \\phi $:\n    $$ \\phi = \\dfrac{S_{0} \\, \\rho_{m}}{\\Sigma_{a,\\text{fuel}} + \\rho_{m} \\, \\Sigma_{a,\\text{mod,nom}} + N_{p} \\, \\dfrac{\\sigma_{p}}{1 + b \\, \\phi \\, \\sigma_{p}}} $$\n    using simple iteration until the relative change in $ \\phi $ is below a tolerance (e.g., $ 10^{-10} $), or a maximum iteration cap is reached (e.g., $ 10000 $ iterations). Initialize the iteration with $ \\phi^{(0)} = \\dfrac{S_{0} \\, \\rho_{m}}{\\Sigma_{a,\\text{fuel}} + \\rho_{m} \\, \\Sigma_{a,\\text{mod,nom}} + N_{p} \\, \\sigma_{p}} $.\n  - After convergence, compute $ \\sigma_{p,\\text{eff}} = \\dfrac{\\sigma_{p}}{1 + b \\, \\phi \\, \\sigma_{p}} $ and $ \\Sigma_{a,\\text{tot}} = \\Sigma_{a,\\text{fuel}} + \\rho_{m} \\, \\Sigma_{a,\\text{mod,nom}} + N_{p} \\, \\sigma_{p,\\text{eff}} $.\n  - Compute the reactivity with poison $ \\rho_{\\text{with poison}} = 1 - \\dfrac{\\Sigma_{a,\\text{tot}}}{\\nu \\Sigma_{f}} $ and the reactivity without poison $ \\rho_{\\text{without poison}} = 1 - \\dfrac{\\Sigma_{a,\\text{fuel}} + \\rho_{m} \\, \\Sigma_{a,\\text{mod,nom}}}{\\nu \\Sigma_{f}} $. Then compute $ \\Delta \\rho_{\\text{hold}}(\\rho_{m}) = \\rho_{\\text{with poison}} - \\rho_{\\text{without poison}} $.\n- Return the pair $ [\\Delta \\sigma_{p,\\text{eff}}, \\Delta (\\Delta \\rho_{\\text{hold}})] $ for each test case as floats.\n\nTest suite:\nEach test case is a tuple $ (\\rho_{m,0}, \\rho_{m,1}, N_{p}, \\sigma_{p}, b, \\Sigma_{a,\\text{fuel}}, \\Sigma_{a,\\text{mod,nom}}, \\Sigma_{s,\\text{mod,nom}}, \\nu \\Sigma_{f}, S_{0}) $. Note that $ \\Sigma_{s,\\text{mod,nom}} $ does not explicitly appear in the single-group removal balance but is included to reflect that $ S_{0} $ is a normalization proxy for moderation strength; you must still pass it through your program to ensure consistent interface, even if not used in the computation.\n\nProvide the following four test cases:\n- Case $ 1 $ (general case): $ (1.0, 0.9, 0.02, 12.0, 0.3, 0.08, 0.01, 1.0, 0.12, 1.0) $.\n- Case $ 2 $ (low moderator boundary): $ (1.0, 0.5, 0.02, 12.0, 0.3, 0.08, 0.01, 1.0, 0.12, 1.0) $.\n- Case $ 3 $ (strong poison, high moderator): $ (1.0, 1.2, 0.05, 12.0, 0.3, 0.08, 0.01, 1.0, 0.12, 1.0) $.\n- Case $ 4 $ (weak poison, moderate moderator decrease): $ (1.0, 0.8, 0.005, 12.0, 0.6, 0.08, 0.01, 1.0, 0.12, 1.0) $.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element corresponds to a test case and is itself a two-element list $ [\\Delta \\sigma_{p,\\text{eff}}, \\Delta (\\Delta \\rho_{\\text{hold}})] $. For example, an output with two test cases would look like $ [[x_{1},y_{1}],[x_{2},y_{2}]] $. The actual values must be computed by your program for the specified four test cases.",
            "solution": "The problem is valid. It presents a well-posed, scientifically grounded scenario in nuclear reactor physics, providing all necessary parameters, definitions, and a clear computational algorithm. The physical model, though simplified to a one-group, infinite-medium representation, captures the essential feedback between thermal neutron flux and burnable poison self-shielding, and its consequent effect on reactor reactivity. The use of a simple iterative scheme to solve the non-linear fixed-point equation for the neutron flux is a standard numerical technique appropriate for this context. The convergence of this specific iterative scheme is assured as the iteration function is monotonically increasing and bounded.\n\nThe objective is to quantify how a change in moderator density affects two key parameters: the effective microscopic absorption cross section of the burnable poison, $ \\sigma_{p,\\text{eff}} $, and the reactivity hold-down provided by the poison, $ \\Delta \\rho_{\\text{hold}} $. This analysis is performed for two moderator density conditions, a nominal state $ \\rho_{m,0} $ and a perturbed state $ \\rho_{m,1} $.\n\nThe core of the problem lies in the coupled relationship between the thermal neutron flux, $ \\phi $, and the effective poison cross section, $ \\sigma_{p,\\text{eff}} $. The flux is determined by the neutron balance equation, where absorption balances the source:\n$$ (\\Sigma_{a,\\text{fuel}} + \\Sigma_{a,\\text{mod}} + \\Sigma_{a,\\text{poison,eff}}) \\, \\phi = S $$\nThe terms in this equation are defined as follows:\n- The thermal source, $ S $, is proportional to the moderator density multiplier $ \\rho_{m} $: $ S = S_{0} \\, \\rho_{m} $.\n- The moderator absorption cross section, $ \\Sigma_{a,\\text{mod}} $, also scales with moderator density: $ \\Sigma_{a,\\text{mod}} = \\rho_{m} \\, \\Sigma_{a,\\text{mod,nom}} $.\n- The effective macroscopic poison absorption cross section, $ \\Sigma_{a,\\text{poison,eff}} $, depends on the effective microscopic cross section: $ \\Sigma_{a,\\text{poison,eff}} = N_{p} \\, \\sigma_{p,\\text{eff}} $.\n- The effective microscopic poison cross section, $ \\sigma_{p,\\text{eff}} $, is a function of the flux $ \\phi $ due to self-shielding:\n$$ \\sigma_{p,\\text{eff}}(\\phi) = \\dfrac{\\sigma_{p}}{1 + b \\, \\phi \\, \\sigma_{p}} $$\nwhere $ \\sigma_p $ is the unshielded cross section and $ b $ is a self-shielding factor.\n\nSubstituting these definitions into the balance equation yields a fixed-point equation for $ \\phi $:\n$$ \\phi = \\dfrac{S_{0} \\, \\rho_{m}}{\\Sigma_{a,\\text{fuel}} + \\rho_{m} \\, \\Sigma_{a,\\text{mod,nom}} + N_{p} \\, \\sigma_{p,\\text{eff}}(\\phi)} $$\n$$ \\phi = \\dfrac{S_{0} \\, \\rho_{m}}{\\Sigma_{a,\\text{fuel}} + \\rho_{m} \\, \\Sigma_{a,\\text{mod,nom}} + N_{p} \\, \\dfrac{\\sigma_{p}}{1 + b \\, \\phi \\, \\sigma_{p}}} $$\nThis non-linear equation must be solved for $ \\phi $ for each given moderator density $ \\rho_m $. The problem specifies a simple iterative method. Starting with an initial guess $ \\phi^{(0)} $, successive approximations are computed using:\n$$ \\phi^{(i+1)} = \\frac{S_{0} \\, \\rho_{m}}{\\Sigma_{a,\\text{fuel}} + \\rho_{m} \\, \\Sigma_{a,\\text{mod,nom}} + N_{p} \\, \\frac{\\sigma_{p}}{1 + b \\, \\phi^{(i)} \\, \\sigma_{p}}} $$\nThe iteration is initialized with the flux value that would be obtained without self-shielding ($ b=0 $):\n$$ \\phi^{(0)} = \\dfrac{S_{0} \\, \\rho_{m}}{\\Sigma_{a,\\text{fuel}} + \\rho_{m} \\, \\Sigma_{a,\\text{mod,nom}} + N_{p} \\, \\sigma_{p}} $$\nThe process continues until the relative difference $ |(\\phi^{(i+1)} - \\phi^{(i)}) / \\phi^{(i+1)}| $ falls below a specified tolerance of $ 10^{-10} $.\n\nOnce the converged flux $ \\phi $ is found for a given $ \\rho_m $, the remaining quantities can be calculated directly.\n$ 1 $. The effective microscopic poison cross section is:\n$$ \\sigma_{p,\\text{eff}} = \\dfrac{\\sigma_{p}}{1 + b \\, \\phi \\, \\sigma_{p}} $$\n$ 2 $. The poison reactivity hold-down, $ \\Delta \\rho_{\\text{hold}} $, is the difference in reactivity between the system with and without the poison. Reactivity $ \\rho $ is defined as $ \\rho = 1 - \\dfrac{\\Sigma_{a,\\text{tot}}}{\\nu \\Sigma_{f}} $.\nThe reactivity with poison is:\n$$ \\rho_{\\text{with poison}} = 1 - \\dfrac{\\Sigma_{a,\\text{fuel}} + \\rho_{m} \\, \\Sigma_{a,\\text{mod,nom}} + N_{p} \\, \\sigma_{p,\\text{eff}}}{\\nu \\Sigma_{f}} $$\nThe reactivity without poison is:\n$$ \\rho_{\\text{without poison}} = 1 - \\dfrac{\\Sigma_{a,\\text{fuel}} + \\rho_{m} \\, \\Sigma_{a,\\text{mod,nom}}}{\\nu \\Sigma_{f}} $$\nThe hold-down is therefore:\n$$ \\Delta \\rho_{\\text{hold}}(\\rho_m) = \\rho_{\\text{with poison}} - \\rho_{\\text{without poison}} = - \\frac{N_{p} \\, \\sigma_{p,\\text{eff}}}{\\nu \\Sigma_{f}} $$\nThis procedure is performed for both the initial moderator density, $ \\rho_{m,0} $, and the perturbed density, $ \\rho_{m,1} $, yielding the pairs ($ \\sigma_{p,\\text{eff}}(\\rho_{m,0}), \\Delta \\rho_{\\text{hold}}(\\rho_{m,0}) $) and ($ \\sigma_{p,\\text{eff}}(\\rho_{m,1}), \\Delta \\rho_{\\text{hold}}(\\rho_{m,1}) $).\n\nFinally, the required changes are computed:\n- Change in effective cross section: $ \\Delta \\sigma_{p,\\text{eff}} = \\sigma_{p,\\text{eff}}(\\rho_{m,1}) - \\sigma_{p,\\text{eff}}(\\rho_{m,0}) $.\n- Change in reactivity hold-down: $ \\Delta (\\Delta \\rho_{\\text{hold}}) = \\Delta \\rho_{\\text{hold}}(\\rho_{m,1}) - \\Delta \\rho_{\\text{hold}}(\\rho_{m,0}) $.\n\nThis entire sequence of calculations is repeated for each test case provided in the problem statement. The parameter $ \\Sigma_{s,\\text{mod,nom}} $ is provided for interface consistency but is correctly noted as not participating in the one-group absorption-source balance equations.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    \"\"\"\n\n    # Test cases defined as tuples:\n    # (rho_m0, rho_m1, Np, sigma_p, b, Sigma_a_fuel, Sigma_a_mod_nom, \n    #  Sigma_s_mod_nom, nu_Sigma_f, S0)\n    test_cases = [\n        (1.0, 0.9, 0.02, 12.0, 0.3, 0.08, 0.01, 1.0, 0.12, 1.0),\n        (1.0, 0.5, 0.02, 12.0, 0.3, 0.08, 0.01, 1.0, 0.12, 1.0),\n        (1.0, 1.2, 0.05, 12.0, 0.3, 0.08, 0.01, 1.0, 0.12, 1.0),\n        (1.0, 0.8, 0.005, 12.0, 0.6, 0.08, 0.01, 1.0, 0.12, 1.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        # Unpack problem parameters\n        (rho_m0, rho_m1, Np, sigma_p, b, Sigma_a_fuel, Sigma_a_mod_nom,\n         Sigma_s_mod_nom, nu_Sigma_f, S0) = case\n\n        # Package parameters for the calculation function\n        params = (Np, sigma_p, b, Sigma_a_fuel, Sigma_a_mod_nom, nu_Sigma_f, S0)\n\n        # Calculate properties for the initial moderator density\n        sigma_eff_0, hold_down_0 = calculate_properties(rho_m0, params)\n        \n        # Calculate properties for the perturbed moderator density\n        sigma_eff_1, hold_down_1 = calculate_properties(rho_m1, params)\n\n        # Calculate the final required differences\n        delta_sigma_p_eff = sigma_eff_1 - sigma_eff_0\n        delta_delta_rho_hold = hold_down_1 - hold_down_0\n\n        results.append([delta_sigma_p_eff, delta_delta_rho_hold])\n\n    # Print the final results in the specified format\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef calculate_properties(rho_m, params):\n    \"\"\"\n    Calculates the effective poison cross section and reactivity hold-down \n    for a given moderator density and set of physical parameters.\n\n    Args:\n        rho_m (float): The moderator density multiplier.\n        params (tuple): A tuple of physical parameters.\n\n    Returns:\n        (float, float): A tuple containing the calculated\n                        sigma_p_eff and delta_rho_hold.\n    \"\"\"\n    # Unpack parameters\n    Np, sigma_p, b, Sigma_a_fuel, Sigma_a_mod_nom, nu_Sigma_f, S0 = params\n\n    # Set numerical parameters for iteration\n    TOL = 1.0e-10\n    MAX_ITER = 10000\n\n    # Calculate terms that depend on moderator density\n    S = S0 * rho_m\n    Sigma_a_mod = rho_m * Sigma_a_mod_nom\n\n    # --- Fixed-point iteration to find the thermal flux (phi) ---\n\n    # Initial guess for phi (assuming no self-shielding)\n    phi_old = S / (Sigma_a_fuel + Sigma_a_mod + Np * sigma_p)\n    \n    phi_new = 0.0\n    for _ in range(MAX_ITER):\n        # Denominator of the self-shielded cross section expression\n        den_sigma_eff = 1.0 + b * phi_old * sigma_p\n        \n        # Denominator of the flux equation\n        sigma_p_eff_iter = sigma_p / den_sigma_eff\n        den_phi = Sigma_a_fuel + Sigma_a_mod + Np * sigma_p_eff_iter\n\n        # Iteration step\n        phi_new = S / den_phi\n\n        # Check for convergence\n        if phi_new  1e-12 and abs(phi_new - phi_old) / phi_new  TOL:\n            break\n        elif phi_new = 1e-12 and abs(phi_new - phi_old)  TOL:\n            break\n\n        phi_old = phi_new\n    \n    phi = phi_new\n\n    # --- Post-convergence calculations ---\n\n    # Effective microscopic poison absorption cross section\n    sigma_p_eff = sigma_p / (1.0 + b * phi * sigma_p)\n\n    # Total macroscopic absorption cross section with poison\n    Sigma_a_tot_with_poison = Sigma_a_fuel + Sigma_a_mod + Np * sigma_p_eff\n    \n    # Total macroscopic absorption cross section without poison\n    Sigma_a_tot_without_poison = Sigma_a_fuel + Sigma_a_mod\n\n    # Reactivity with poison\n    rho_with_poison = 1.0 - Sigma_a_tot_with_poison / nu_Sigma_f\n    \n    # Reactivity without poison\n    rho_without_poison = 1.0 - Sigma_a_tot_without_poison / nu_Sigma_f\n\n    # Poison reactivity hold-down\n    delta_rho_hold = rho_with_poison - rho_without_poison\n\n    return sigma_p_eff, delta_rho_hold\n\n# Execute the solver\nsolve()\n```"
        },
        {
            "introduction": "This final practice graduates from analyzing specific physical effects  to learning a powerful, general method for design optimization: adjoint-based sensitivity analysis. You will compute the adjoint flux for a core model and use it to derive the first-order sensitivity of the effective multiplication factor ($k_{\\mathrm{eff}}$) to changes in poison concentration. This technique allows for the efficient calculation of reactivity impacts without running a full core simulation for every small design change, forming the foundation of modern optimization algorithms.",
            "id": "4219387",
            "problem": "You are tasked with computing the adjoint neutron flux to evaluate the first-order sensitivity of the effective multiplication factor $k_{\\mathrm{eff}}$ to changes in burnable poison density in a one-dimensional coarse-mesh diffusion model of a nuclear reactor core. The reactor core is represented as a uniform grid of $N$ nodes with spacing $h$ in $\\mathrm{cm}$ and reflective boundary conditions. The physical model is the steady-state, one-group neutron diffusion approximation, discretized using finite differences with interface diffusion coefficients.\n\nBegin from the following fundamental base:\n\n- The steady-state one-group neutron balance in diffusion approximation can be represented by a generalized eigenvalue problem on the discretized mesh,\n$$\nL(\\boldsymbol{\\theta}) \\, \\boldsymbol{\\phi} = \\lambda \\, M(\\boldsymbol{\\theta}) \\, \\boldsymbol{\\phi},\n$$\nwhere $L$ is the loss operator containing neutron diffusion and absorption, $M$ is the production operator containing neutron generation by fission, $\\boldsymbol{\\phi}$ is the neutron flux vector, $\\lambda$ is the generalized eigenvalue equal to $1/k_{\\mathrm{eff}}$, and $\\boldsymbol{\\theta}$ are material parameters. Reflective boundary conditions are imposed.\n\n- The adjoint eigenproblem is\n$$\nL(\\boldsymbol{\\theta})^{\\mathsf{T}} \\, \\boldsymbol{\\phi}^{\\ast} = \\lambda \\, M(\\boldsymbol{\\theta})^{\\mathsf{T}} \\, \\boldsymbol{\\phi}^{\\ast},\n$$\nwhere $\\boldsymbol{\\phi}^{\\ast}$ is the adjoint flux and ${}^{\\mathsf{T}}$ denotes the transpose.\n\n- The burnable poison density parameter $p$ enters linearly in the macroscopic absorption cross section via\n$$\n\\Sigma_{a,i}(p) = \\Sigma_{a,i}^{\\mathrm{base}} + p \\, \\Sigma_{p,i},\n$$\nwhere $\\Sigma_{a,i}^{\\mathrm{base}}$ is the base absorption in node $i$ and $\\Sigma_{p,i}$ is the poison macroscopic absorption cross section contribution in node $i$. All cross sections are in $\\mathrm{cm}^{-1}$, and the diffusion coefficient $D_i$ is in $\\mathrm{cm}$. The fission production cross section is $\\nu \\Sigma_{f,i}$ in $\\mathrm{cm}^{-1}$. The mesh spacing is $h$ in $\\mathrm{cm}$.\n\n- The discrete loss operator $L$ is built using harmonic-mean interface diffusion coefficients $D_{i+\\frac{1}{2}}$ and reflective boundaries, with entries\n$$\nL_{i,i} = \\frac{D_{i-\\frac{1}{2}} + D_{i+\\frac{1}{2}}}{h^2} + \\Sigma_{a,i}(p), \\quad\nL_{i,i-1} = -\\frac{D_{i-\\frac{1}{2}}}{h^2}, \\quad\nL_{i,i+1} = -\\frac{D_{i+\\frac{1}{2}}}{h^2},\n$$\nwhere $D_{-\\frac{1}{2}} = 0$ and $D_{N-\\frac{1}{2}} = 0$ enforce reflective boundaries, and $D_{i+\\frac{1}{2}} = \\dfrac{2}{\\frac{1}{D_i} + \\frac{1}{D_{i+1}}}$ for $i = 0, \\dots, N-2$. The production operator $M$ is diagonal with $M_{i,i} = \\nu \\Sigma_{f,i}$.\n\nYour program must:\n\n- Construct $L$ and $M$ for each test case at a baseline poison density $p_0$.\n- Solve the forward generalized eigenproblem for the smallest positive real eigenvalue $\\lambda$ and the associated right eigenvector $\\boldsymbol{\\phi}$, and compute $k_{\\mathrm{eff}} = 1/\\lambda$.\n- Solve the adjoint generalized eigenproblem to obtain $\\boldsymbol{\\phi}^{\\ast}$ for the same $\\lambda$.\n- Using first principles, derive and implement the first-order sensitivity of $k_{\\mathrm{eff}}$ to $p$, expressed in terms of the adjoint and forward solutions and the operator derivative $\\frac{\\partial L}{\\partial p}$ evaluated at $p_0$. Treat $p$ as dimensionless. Do not assume any pre-normalization of $\\boldsymbol{\\phi}$ or $\\boldsymbol{\\phi}^{\\ast}$; any required inner products must be computed explicitly.\n- Predict the change $\\Delta k_{\\mathrm{eff}}$ for a small perturbation $\\delta p$ using the first-order sensitivity.\n- Validate the prediction by directly recomputing $k_{\\mathrm{eff}}$ at $p_1 = p_0 + \\delta p$ and taking the difference with the baseline.\n\nPhysical and numerical units:\n- Use $\\mathrm{cm}$ for $h$ and $D_i$, and $\\mathrm{cm}^{-1}$ for all cross sections. The effective multiplication factor $k_{\\mathrm{eff}}$ and its changes are dimensionless. Express all final outputs as decimal floats (dimensionless).\n\nTest suite:\nImplement the following three test cases. For each case, the final result must be the absolute error between the adjoint-based first-order prediction $\\Delta k_{\\mathrm{eff}}^{\\mathrm{pred}}$ and the directly computed change $\\Delta k_{\\mathrm{eff}}^{\\mathrm{dir}}$.\n\n- Case $1$ (happy path, interior poison):\n  - $N = 12$, $h = 15$ $\\mathrm{cm}$.\n  - $D_i = 1.2$ $\\mathrm{cm}$ for all $i$.\n  - $\\Sigma_{a,i}^{\\mathrm{base}} = 0.006$ $\\mathrm{cm}^{-1}$ for all $i$.\n  - $\\nu \\Sigma_{f,i} = 0.045$ $\\mathrm{cm}^{-1}$ for all $i$.\n  - $\\Sigma_{p,i} = 0$ $\\mathrm{cm}^{-1}$ for all $i$ except $i \\in \\{5,6\\}$ where $\\Sigma_{p,i} = 0.020$ $\\mathrm{cm}^{-1}$.\n  - $p_0 = 0.8$, $\\delta p = 0.01$.\n\n- Case $2$ (boundary condition and zero poison derivative edge case):\n  - $N = 8$, $h = 20$ $\\mathrm{cm}$.\n  - $D_i = 1.4$ $\\mathrm{cm}$ for all $i$.\n  - $\\Sigma_{a,i}^{\\mathrm{base}} = 0.006$ $\\mathrm{cm}^{-1}$ for all $i$.\n  - $\\nu \\Sigma_{f,i} = 0.050$ $\\mathrm{cm}^{-1}$ for all $i$.\n  - $\\Sigma_{p,i} = 0$ $\\mathrm{cm}^{-1}$ for all $i$.\n  - $p_0 = 1.0$, $\\delta p = 0.05$.\n\n- Case $3$ (heterogeneous diffusion, poison at boundaries, negative perturbation):\n  - $N = 10$, $h = 12$ $\\mathrm{cm}$.\n  - $D_i = 1.0 + 0.6 \\frac{i}{N-1}$ $\\mathrm{cm}$ for $i = 0, \\dots, N-1$.\n  - $\\Sigma_{a,i}^{\\mathrm{base}} = 0.005$ $\\mathrm{cm}^{-1}$ for all $i$.\n  - $\\nu \\Sigma_{f,i} = 0.040$ $\\mathrm{cm}^{-1}$ for all $i$.\n  - $\\Sigma_{p,i} = 0$ $\\mathrm{cm}^{-1}$ for all $i$ except $i \\in \\{0,9\\}$ where $\\Sigma_{p,i} = 0.030$ $\\mathrm{cm}^{-1}$.\n  - $p_0 = 0.5$, $\\delta p = -0.02$.\n\nFinal output format:\nYour program should produce a single line of output containing the three absolute errors as a comma-separated list of decimal floats enclosed in square brackets, for example, $[e_1,e_2,e_3]$, where $e_j = \\left|\\Delta k_{\\mathrm{eff},j}^{\\mathrm{pred}} - \\Delta k_{\\mathrm{eff},j}^{\\mathrm{dir}}\\right|$ for case $j$. There must be no additional text in the output.",
            "solution": "The user-provided problem is assessed to be valid. It is scientifically grounded in established reactor physics principles, is mathematically well-posed, and all necessary parameters and definitions are provided for a unique and meaningful solution. No contradictions, ambiguities, or factual unsoundness were found.\n\nThe core of the problem is to compute the first-order sensitivity of the effective multiplication factor, $k_{\\mathrm{eff}}$, with respect to a change in the burnable poison density, $p$. This requires the derivation of the sensitivity coefficient using first-order perturbation theory, which relies on the forward and adjoint neutron flux.\n\nFirst, we formally derive the sensitivity expression. The system is described by the one-group, steady-state neutron diffusion equation, discretized as a generalized eigenvalue problem:\n$$\nL(p) \\, \\boldsymbol{\\phi}(p) = \\lambda(p) \\, M \\, \\boldsymbol{\\phi}(p)\n$$\nwhere $\\boldsymbol{\\phi}$ is the vector of neutron fluxes at each spatial node, $L$ is the neutron loss operator (diffusion and absorption), $M$ is the neutron production operator (fission), $\\lambda = 1/k_{\\mathrm{eff}}$ is the eigenvalue, and $p$ is the poison density parameter. Notably, $M$ does not depend on $p$.\n\nThe corresponding adjoint eigenproblem is given by:\n$$\nL(p)^{\\mathsf{T}} \\, \\boldsymbol{\\phi}^{\\ast}(p) = \\lambda(p) \\, M^{\\mathsf{T}} \\, \\boldsymbol{\\phi}^{\\ast}(p)\n$$\nwhere $\\boldsymbol{\\phi}^{\\ast}$ is the adjoint flux vector. In this problem, the discretized operator $L$ and the production operator $M$ (which is diagonal) are both real and symmetric, so $L^{\\mathsf{T}} = L$ and $M^{\\mathsf{T}} = M$. Consequently, the forward and adjoint problems are identical, and their eigenvectors $\\boldsymbol{\\phi}$ and $\\boldsymbol{\\phi}^{\\ast}$ are the same.\n\nTo find the sensitivity, we differentiate the forward eigenvalue equation with respect to $p$:\n$$\n\\frac{\\partial L}{\\partial p} \\boldsymbol{\\phi} + L \\frac{\\partial \\boldsymbol{\\phi}}{\\partial p} = \\frac{\\partial \\lambda}{\\partial p} M \\boldsymbol{\\phi} + \\lambda M \\frac{\\partial \\boldsymbol{\\phi}}{\\partial p}\n$$\nWe then take the inner product of this equation with the adjoint flux $\\boldsymbol{\\phi}^{\\ast}$, where the inner product is defined as $\\langle \\mathbf{y}, \\mathbf{x} \\rangle = \\mathbf{y}^{\\mathsf{T}}\\mathbf{x}$.\n$$\n\\langle \\boldsymbol{\\phi}^{\\ast}, \\frac{\\partial L}{\\partial p} \\boldsymbol{\\phi} \\rangle + \\langle \\boldsymbol{\\phi}^{\\ast}, L \\frac{\\partial \\boldsymbol{\\phi}}{\\partial p} \\rangle = \\frac{\\partial \\lambda}{\\partial p} \\langle \\boldsymbol{\\phi}^{\\ast}, M \\boldsymbol{\\phi} \\rangle + \\lambda \\langle \\boldsymbol{\\phi}^{\\ast}, M \\frac{\\partial \\boldsymbol{\\phi}}{\\partial p} \\rangle\n$$\nBy the definition of the adjoint operator, $\\langle \\boldsymbol{\\phi}^{\\ast}, L \\mathbf{v} \\rangle = \\langle L^{\\mathsf{T}} \\boldsymbol{\\phi}^{\\ast}, \\mathbf{v} \\rangle$. Using this property and the adjoint equation $L^{\\mathsf{T}}\\boldsymbol{\\phi}^{\\ast} = \\lambda M^{\\mathsf{T}}\\boldsymbol{\\phi}^{\\ast}$, we can rewrite the second term on the left-hand side:\n$$\n\\langle \\boldsymbol{\\phi}^{\\ast}, L \\frac{\\partial \\boldsymbol{\\phi}}{\\partial p} \\rangle = \\langle L^{\\mathsf{T}} \\boldsymbol{\\phi}^{\\ast}, \\frac{\\partial \\boldsymbol{\\phi}}{\\partial p} \\rangle = \\langle \\lambda M^{\\mathsf{T}} \\boldsymbol{\\phi}^{\\ast}, \\frac{\\partial \\boldsymbol{\\phi}}{\\partial p} \\rangle = \\lambda \\langle \\boldsymbol{\\phi}^{\\ast}, M \\frac{\\partial \\boldsymbol{\\phi}}{\\partial p} \\rangle\n$$\nThe last step holds because $M$ is symmetric ($M^{\\mathsf{T}} = M$). Substituting this back, we find that the terms involving the derivative of the flux, $\\frac{\\partial \\boldsymbol{\\phi}}{\\partial p}$, cancel out:\n$$\n\\langle \\boldsymbol{\\phi}^{\\ast}, \\frac{\\partial L}{\\partial p} \\boldsymbol{\\phi} \\rangle + \\lambda \\langle \\boldsymbol{\\phi}^{\\ast}, M \\frac{\\partial \\boldsymbol{\\phi}}{\\partial p} \\rangle = \\frac{\\partial \\lambda}{\\partial p} \\langle \\boldsymbol{\\phi}^{\\ast}, M \\boldsymbol{\\phi} \\rangle + \\lambda \\langle \\boldsymbol{\\phi}^{\\ast}, M \\frac{\\partial \\boldsymbol{\\phi}}{\\partial p} \\rangle\n$$\n$$\n\\implies \\langle \\boldsymbol{\\phi}^{\\ast}, \\frac{\\partial L}{\\partial p} \\boldsymbol{\\phi} \\rangle = \\frac{\\partial \\lambda}{\\partial p} \\langle \\boldsymbol{\\phi}^{\\ast}, M \\boldsymbol{\\phi} \\rangle\n$$\nSolving for $\\frac{\\partial \\lambda}{\\partial p}$ gives the sensitivity of the eigenvalue:\n$$\n\\frac{\\partial \\lambda}{\\partial p} = \\frac{\\langle \\boldsymbol{\\phi}^{\\ast}, \\frac{\\partial L}{\\partial p} \\boldsymbol{\\phi} \\rangle}{\\langle \\boldsymbol{\\phi}^{\\ast}, M \\boldsymbol{\\phi} \\rangle}\n$$\nThe problem asks for the sensitivity of $k_{\\mathrm{eff}} = 1/\\lambda$. Using the chain rule, $\\frac{\\partial \\lambda}{\\partial p} = -\\frac{1}{k_{\\mathrm{eff}}^2} \\frac{\\partial k_{\\mathrm{eff}}}{\\partial p}$. Substituting this and rearranging gives the desired sensitivity of $k_{\\mathrm{eff}}$:\n$$\n\\frac{\\partial k_{\\mathrm{eff}}}{\\partial p} = -k_{\\mathrm{eff}}^2 \\frac{\\langle \\boldsymbol{\\phi}^{\\ast}, \\frac{\\partial L}{\\partial p} \\boldsymbol{\\phi} \\rangle}{\\langle \\boldsymbol{\\phi}^{\\ast}, M \\boldsymbol{\\phi} \\rangle}\n$$\nThe operator derivative $\\frac{\\partial L}{\\partial p}$ is found by differentiating the elements of $L$. Only the diagonal absorption term depends on $p$: $L_{i,i}(p) = \\dots + \\Sigma_{a,i}^{\\mathrm{base}} + p \\, \\Sigma_{p,i}$. Thus, $\\frac{\\partial L_{i,i}}{\\partial p} = \\Sigma_{p,i}$. The derivative matrix $\\frac{\\partial L}{\\partial p}$ is diagonal with entries $\\Sigma_{p,i}$. The inner products become sums:\n$$\n\\frac{\\partial k_{\\mathrm{eff}}}{\\partial p} = -k_{\\mathrm{eff}}^2 \\frac{\\sum_{i=0}^{N-1} \\phi^{\\ast}_i \\Sigma_{p,i} \\phi_i}{\\sum_{i=0}^{N-1} \\phi^{\\ast}_i (\\nu \\Sigma_{f,i}) \\phi_i}\n$$\nThe predicted change in $k_{\\mathrm{eff}}$ from a small perturbation $\\delta p$ is then $\\Delta k_{\\mathrm{eff}}^{\\mathrm{pred}} = \\frac{\\partial k_{\\mathrm{eff}}}{\\partial p} \\delta p$.\n\nThe numerical implementation proceeds as follows:\n1.  For a given set of parameters at the baseline poison density $p_0$, construct the symmetric loss matrix $L(p_0)$ and the diagonal production matrix $M$. The off-diagonal elements of $L$ are built from the harmonic mean of diffusion coefficients at cell interfaces, and the reflective boundary conditions are enforced by setting the diffusion terms to zero at the outer boundaries.\n2.  Solve the generalized eigenvalue problem $L(p_0) \\boldsymbol{\\phi}_0 = \\lambda_0 M \\boldsymbol{\\phi}_0$ for the smallest eigenvalue $\\lambda_0$ and its corresponding eigenvector $\\boldsymbol{\\phi}_0$. This is done using a numerical eigensolver for symmetric matrices. The baseline effective multiplication factor is $k_{\\mathrm{eff},0} = 1/\\lambda_0$.\n3.  As $L$ and $M$ are symmetric, the adjoint flux is identical to the forward flux, $\\boldsymbol{\\phi}^{\\ast}_0 = \\boldsymbol{\\phi}_0$.\n4.  Compute the sensitivity $\\frac{\\partial k_{\\mathrm{eff}}}{\\partial p}$ at $p_0$ using the derived formula, the fluxes $\\boldsymbol{\\phi}_0$, $\\boldsymbol{\\phi}^{\\ast}_0$, and $k_{\\mathrm{eff},0}$.\n5.  Calculate the predicted change $\\Delta k_{\\mathrm{eff}}^{\\mathrm{pred}} = \\frac{\\partial k_{\\mathrm{eff}}}{\\partial p} \\delta p$.\n6.  For validation, directly compute the perturbed state. Construct a new loss matrix $L(p_1)$ for $p_1 = p_0 + \\delta p$.\n7.  Solve the new eigenproblem $L(p_1) \\boldsymbol{\\phi}_1 = \\lambda_1 M \\boldsymbol{\\phi}_1$ to find the perturbed eigenvalue $\\lambda_1$ and $k_{\\mathrm{eff},1} = 1/\\lambda_1$.\n8.  The directly computed change is $\\Delta k_{\\mathrm{eff}}^{\\mathrm{dir}} = k_{\\mathrm{eff},1} - k_{\\mathrm{eff},0}$.\n9.  The final result for each case is the absolute error $e = |\\Delta k_{\\mathrm{eff}}^{\\mathrm{pred}} - \\Delta k_{\\mathrm{eff}}^{\\mathrm{dir}}|$. This error quantifies the accuracy of the first-order approximation. It is expected to be small for a small perturbation $\\delta p$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import eigh\n\ndef build_matrices(N, h, D_vec, Sigma_a_base, nu_Sigma_f, Sigma_p, p):\n    \"\"\"\n    Constructs the loss (L) and production (M) matrices for the 1D diffusion problem.\n\n    Args:\n        N (int): Number of nodes.\n        h (float): Node spacing in cm.\n        D_vec (np.ndarray): Vector of diffusion coefficients for each node in cm.\n        Sigma_a_base (np.ndarray): Vector of base absorption cross sections in cm^-1.\n        nu_Sigma_f (np.ndarray): Vector of neutron production cross sections in cm^-1.\n        Sigma_p (np.ndarray): Vector of poison absorption cross sections in cm^-1.\n        p (float): Dimensionless poison density parameter.\n\n    Returns:\n        tuple[np.ndarray, np.ndarray]: A tuple containing the L and M matrices.\n    \"\"\"\n    L = np.zeros((N, N))\n    M = np.diag(nu_Sigma_f)\n\n    # Calculate interface diffusion coefficients using harmonic mean\n    D_interface = np.zeros(N - 1)\n    for i in range(N - 1):\n        D_interface[i] = 2.0 / (1.0 / D_vec[i] + 1.0 / D_vec[i+1])\n\n    # Calculate current absorption cross sections\n    Sigma_a = Sigma_a_base + p * Sigma_p\n\n    # Populate the tridiagonal L matrix\n    # Diagonal elements\n    h2 = h * h\n    for i in range(N):\n        # Absorption term\n        L[i, i] = Sigma_a[i]\n        # Diffusion term from the right interface (i, i+1)\n        if i  N - 1:\n            L[i, i] += D_interface[i] / h2\n        # Diffusion term from the left interface (i-1, i)\n        if i  0:\n            L[i, i] += D_interface[i-1] / h2\n\n    # Off-diagonal elements\n    for i in range(N - 1):\n        L[i, i+1] = -D_interface[i] / h2\n        L[i+1, i] = -D_interface[i] / h2\n        \n    return L, M\n\ndef solve_eigenproblem(L, M):\n    \"\"\"\n    Solves the generalized eigenvalue problem L*phi = lambda*M*phi.\n\n    Args:\n        L (np.ndarray): The loss matrix.\n        M (np.ndarray): The production matrix.\n\n    Returns:\n        tuple[float, np.ndarray]: A tuple containing the fundamental eigenvalue (lambda_0)\n                                  and the corresponding eigenvector (flux phi_0).\n    \"\"\"\n    # eigh is for symmetric/Hermitian matrices, which L and M are.\n    # It returns eigenvalues in ascending order.\n    eigenvalues, eigenvectors = eigh(L, M)\n    \n    # The fundamental mode corresponds to the smallest positive eigenvalue.\n    lambda_0 = eigenvalues[0]\n    phi_0 = eigenvectors[:, 0]\n    \n    # Normalize flux to be positive (physical convention)\n    if np.sum(phi_0)  0:\n        phi_0 *= -1.0\n        \n    return lambda_0, phi_0\n\ndef solve():\n    \"\"\"\n    Main function to execute the problem for all test cases.\n    \"\"\"\n    test_cases = [\n        # Case 1\n        {\n            \"N\": 12, \"h\": 15.0,\n            \"D_func\": lambda N: np.full(N, 1.2),\n            \"Sigma_a_base_func\": lambda N: np.full(N, 0.006),\n            \"nu_Sigma_f_func\": lambda N: np.full(N, 0.045),\n            \"Sigma_p_func\": lambda N: np.array([0.020 if i in {5, 6} else 0.0 for i in range(N)]),\n            \"p0\": 0.8, \"delta_p\": 0.01\n        },\n        # Case 2\n        {\n            \"N\": 8, \"h\": 20.0,\n            \"D_func\": lambda N: np.full(N, 1.4),\n            \"Sigma_a_base_func\": lambda N: np.full(N, 0.006),\n            \"nu_Sigma_f_func\": lambda N: np.full(N, 0.050),\n            \"Sigma_p_func\": lambda N: np.zeros(N),\n            \"p0\": 1.0, \"delta_p\": 0.05\n        },\n        # Case 3\n        {\n            \"N\": 10, \"h\": 12.0,\n            \"D_func\": lambda N: 1.0 + 0.6 * np.arange(N) / (N - 1),\n            \"Sigma_a_base_func\": lambda N: np.full(N, 0.005),\n            \"nu_Sigma_f_func\": lambda N: np.full(N, 0.040),\n            \"Sigma_p_func\": lambda N: np.array([0.030 if i in {0, 9} else 0.0 for i in range(N)]),\n            \"p0\": 0.5, \"delta_p\": -0.02\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        N = case[\"N\"]\n        h = case[\"h\"]\n        p0 = case[\"p0\"]\n        delta_p = case[\"delta_p\"]\n        p1 = p0 + delta_p\n\n        # Generate material properties\n        D_vec = case[\"D_func\"](N)\n        Sigma_a_base = case[\"Sigma_a_base_func\"](N)\n        nu_Sigma_f = case[\"nu_Sigma_f_func\"](N)\n        Sigma_p = case[\"Sigma_p_func\"](N)\n\n        # 1. Baseline Calculation (at p0)\n        L0, M = build_matrices(N, h, D_vec, Sigma_a_base, nu_Sigma_f, Sigma_p, p0)\n        lambda0, phi0 = solve_eigenproblem(L0, M)\n        k_eff0 = 1.0 / lambda0\n        \n        # In this problem, L and M are symmetric, so phi* = phi\n        phi_star0 = phi0\n\n        # 2. Sensitivity Calculation\n        # dL/dp is a diagonal matrix with Sigma_p on the diagonal\n        dL_dp_matrix = np.diag(Sigma_p)\n        \n        numerator = phi_star0.T @ dL_dp_matrix @ phi0\n        denominator = phi_star0.T @ M @ phi0\n        \n        # Avoid division by zero if there's no fission\n        if np.isclose(denominator, 0.0):\n            dk_eff_dp = 0.0\n        else:\n            dk_eff_dp = -k_eff0**2 * (numerator / denominator)\n\n        delta_k_eff_pred = dk_eff_dp * delta_p\n\n        # 3. Direct Calculation (at p1 = p0 + delta_p)\n        L1, _ = build_matrices(N, h, D_vec, Sigma_a_base, nu_Sigma_f, Sigma_p, p1)\n        lambda1, _ = solve_eigenproblem(L1, M)\n        k_eff1 = 1.0 / lambda1\n        \n        delta_k_eff_dir = k_eff1 - k_eff0\n\n        # 4. Compute Absolute Error\n        error = abs(delta_k_eff_pred - delta_k_eff_dir)\n        results.append(error)\n\n    # Format and print the final output\n    print(f\"[{','.join(f'{r:.12e}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}