{
    "hands_on_practices": [
        {
            "introduction": "反应堆堆芯装载模式的优化始于燃料组件层面。第一个实践提供了一个基础练习，用于评估可燃毒物棒布局的局部效应 。通过使用简化的栅格模型计算无限增殖因数 ($k_{\\infty}$) 和棒功率峰值的变化，您将获得关于反应性控制和功率分布管理之间基本权衡的实践经验。",
            "id": "4219374",
            "problem": "给定一个简化的、但在科学上可信的、用于模拟核反应堆堆芯中方形燃料组件的双群无穷栅格模型。目标是使用栅格计算的宏观常数和给定的通量密度图，量化将两根可燃毒物（BP）棒从内部位置移动到角落位置后，对组件的无穷增殖因数和棒功率峰值因子的影响。您必须实现一个程序，为指定的测试用例集计算这些变化，并打印单行聚合输出。\n\n其基本原理是无穷介质中的稳态中子平衡，采用双能群近似表示。设方形组件具有 $N \\times N$ 的燃料棒网格，通过整数坐标 $(i,j)$ 进行索引，其中 $i,j \\in \\{0,1,\\dots,N-1\\}$。对于每根燃料棒 $(i,j)$ 和每个能群 $g \\in \\{1,2\\}$，设标量通量密度表示为 $\\phi_g(i,j)$，指定燃料棒材料 $m(i,j)$ 的宏观吸收和产生参数分别表示为 $\\Sigma_{a,g}(m)$ 和 $\\nu\\Sigma_{f,g}(m)$。所有宏观截面的单位均为 $\\mathrm{cm}^{-1}$。\n\n我们从第一性原理出发，将无穷增殖因数 $k_{\\infty}$ 定义为无穷介质中总中子产生率与总中子吸收率之比：\n$$\nk_{\\infty} \\equiv \\frac{\\sum_{i=0}^{N-1}\\sum_{j=0}^{N-1}\\sum_{g=1}^{2} \\nu\\Sigma_{f,g}(m(i,j)) \\, \\phi_g(i,j)}{\\sum_{i=0}^{N-1}\\sum_{j=0}^{N-1}\\sum_{g=1}^{2} \\Sigma_{a,g}(m(i,j)) \\, \\phi_g(i,j)}.\n$$\n对于小的重构，我们考虑“冻结通量”近似：通量密度图 $\\{\\phi_g(i,j)\\}$ 取自基准构型（BP 棒位于内部位置）的参考栅格计算，并在评估燃料棒移动下的反应率变化时作为权重重复使用。当材料微扰不大且泄漏可忽略时，这对应于与微扰理论一致的一阶计算。\n\n对于棒功率峰值，我们采用标准的栅格代理方法，即棒功率与裂变源密度成正比，而裂变源密度又与 $\\sum_{g=1}^{2} \\nu\\Sigma_{f,g}(m(i,j)) \\, \\phi_g(i,j)$ 成正比。则组件的棒功率峰值因子 $PF$ 定义为：\n$$\nPF \\equiv \\frac{\\max_{i,j} \\left( \\sum_{g=1}^{2} \\nu\\Sigma_{f,g}(m(i,j)) \\, \\phi_g(i,j) \\right)}{\\frac{1}{N^2} \\sum_{i=0}^{N-1}\\sum_{j=0}^{N-1}\\left( \\sum_{g=1}^{2} \\nu\\Sigma_{f,g}(m(i,j)) \\, \\phi_g(i,j) \\right)}.\n$$\n\n您的程序必须：\n- 构建基准材料分布图 $m_{\\mathrm{base}}(i,j)$，其中两根 BP 棒位于指定的内部坐标，所有其他棒均为燃料。\n- 通过将这两根 BP 棒移动到指定的角落坐标，并将原来的内部位置转换为燃料，来构建移动后的材料分布图 $m_{\\mathrm{moved}}(i,j)$。\n- 使用提供的参数化形式生成双群通量密度图 $\\phi_1(i,j)$ 和 $\\phi_2(i,j)$，该形式模仿了栅格计算的通量密度形状，并对每个群进行归一化，使得对于 $g \\in \\{1,2\\}$，满足 $\\sum_{i,j}\\phi_g(i,j)=1$。\n- 在冻结通量近似下，计算基准和移动后分布图的 $k_{\\infty}$，并报告 $\\Delta k_{\\infty} \\equiv k_{\\infty}^{\\mathrm{moved}} - k_{\\infty}^{\\mathrm{base}}$。\n- 计算基准和移动后分布图的 $PF$，并报告 $\\Delta PF \\equiv PF^{\\mathrm{moved}} - PF^{\\mathrm{base}}$。\n\n通量密度图生成：对于每个群 $g$，令 $\\gamma_g$ 为一个非负形状参数。对于燃料棒 $(i,j)$，定义其相对于组件中心的径向指数平方为\n$$\nr^2(i,j) \\equiv \\left(i - \\frac{N-1}{2}\\right)^2 + \\left(j - \\frac{N-1}{2}\\right)^2.\n$$\n定义原始通量密度为\n$$\n\\phi^{\\mathrm{raw}}_g(i,j) \\equiv \\max\\!\\left(\\varepsilon, \\, 1 - \\gamma_g \\, r^2(i,j)\\right),\n$$\n其中 $\\varepsilon = 10^{-8}$，并进行归一化以获得 $\\phi_g(i,j) \\equiv \\phi^{\\mathrm{raw}}_g(i,j) \\big/ \\left( \\sum_{p,q} \\phi^{\\mathrm{raw}}_g(p,q)\\right)$，确保每个群都满足 $\\sum_{i,j}\\phi_g(i,j)=1$。\n\n材料：燃料棒具有宏观参数 $\\Sigma_{a,1}(\\mathrm{fuel})$、$\\Sigma_{a,2}(\\mathrm{fuel})$、$\\nu\\Sigma_{f,1}(\\mathrm{fuel})$ 和 $\\nu\\Sigma_{f,2}(\\mathrm{fuel})$。可燃毒物（BP）棒具有 $\\Sigma_{a,1}(\\mathrm{BP})$、$\\Sigma_{a,2}(\\mathrm{BP})$，且对于 $g \\in \\{1,2\\}$，$\\nu\\Sigma_{f,g}(\\mathrm{BP}) = 0$ 以表示其为非裂变吸收体。\n\n测试套件和参数：\n- 案例 1（正常情况）：\n  - $N = 5$。\n  - 内部 BP 棒位于 $(2,2)$ 和 $(2,3)$；移动到角落 $(0,0)$ 和 $(0,4)$。\n  - 通量密度形状参数：$\\gamma_1 = \\beta = 0.02$，$\\gamma_2 = \\alpha = 0.06$。\n  - 燃料：$\\Sigma_{a,1}(\\mathrm{fuel}) = 0.02$，$\\Sigma_{a,2}(\\mathrm{fuel}) = 0.08$，$\\nu\\Sigma_{f,1}(\\mathrm{fuel}) = 0.005$，$\\nu\\Sigma_{f,2}(\\mathrm{fuel}) = 0.12$。\n  - BP：$\\Sigma_{a,1}(\\mathrm{BP}) = 0.03$，$\\Sigma_{a,2}(\\mathrm{BP}) = 0.20$，$\\nu\\Sigma_{f,1}(\\mathrm{BP}) = 0.0$，$\\nu\\Sigma_{f,2}(\\mathrm{BP}) = 0.0$。\n- 案例 2（边界条件：均匀通量）：\n  - $N = 5$。\n  - 内部 BP 棒位于 $(2,2)$ 和 $(1,3)$；移动到角落 $(0,0)$ 和 $(4,4)$。\n  - 通量密度形状参数：$\\gamma_1 = \\beta = 0.0$，$\\gamma_2 = \\alpha = 0.0$。\n  - 燃料和 BP 的宏观参数与案例 1 相同。\n- 案例 3（BP 中热中子吸收更强，组件更大）：\n  - $N = 7$。\n  - 内部 BP 棒位于 $(3,3)$ 和 $(3,4)$；移动到角落 $(0,6)$ 和 $(6,0)$。\n  - 通量密度形状参数：$\\gamma_1 = \\beta = 0.01$，$\\gamma_2 = \\alpha = 0.04$。\n  - 燃料：$\\Sigma_{a,1}(\\mathrm{fuel}) = 0.025$，$\\Sigma_{a,2}(\\mathrm{fuel}) = 0.09$，$\\nu\\Sigma_{f,1}(\\mathrm{fuel}) = 0.004$，$\\nu\\Sigma_{f,2}(\\mathrm{fuel}) = 0.11$。\n  - BP：$\\Sigma_{a,1}(\\mathrm{BP}) = 0.035$，$\\Sigma_{a,2}(\\mathrm{BP}) = 0.30$，$\\nu\\Sigma_{f,1}(\\mathrm{BP}) = 0.0$，$\\nu\\Sigma_{f,2}(\\mathrm{BP}) = 0.0$。\n\n计算要求：\n- 使用提供的参数化通量密度模型，并对每个群的通量密度进行归一化，以满足对于 $g \\in \\{1,2\\}$，$\\sum_{i,j}\\phi_g(i,j)=1$。\n- 如上定义，计算基准和移动后构型的 $k_{\\infty}$ 和 $PF$。\n- 报告每个案例的 $\\Delta k_{\\infty}$ 和 $\\Delta PF$。这两个量都是无量纲的，必须表示为小数。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个逗号分隔的列表，用方括号括起来，顺序为 $[\\Delta k_{\\infty}^{(1)}, \\Delta PF^{(1)}, \\Delta k_{\\infty}^{(2)}, \\Delta PF^{(2)}, \\Delta k_{\\infty}^{(3)}, \\Delta PF^{(3)}]$，其中上标表示案例编号。不应打印任何额外文本。",
            "solution": "该问题要求在一个简化的双群核燃料组件模型中，量化无穷增殖因数 $k_{\\infty}$ 和棒功率峰值因子 $PF$ 的变化。这些变化是由于将两根可燃毒物（BP）棒从内部位置移动到角落位置所引起的。分析在“冻结通量”近似下进行，这是一种标准的微扰方法，其中假设中子通量密度分布不会因材料微扰而改变。\n\n解决方案是为每个提供的测试案例，遵循一个结构化的、分步的计算过程。\n\n### 1. 通量密度图生成\n\n组件内的中子通量密度分布是针对两个能群建模的：快中子群（$g=1$）和热中子群（$g=2$）。对于一个 $N \\times N$ 的组件网格，其中棒坐标为 $(i,j)$ 且 $i,j \\in \\{0, 1, \\dots, N-1\\}$，通量密度形状由参数化定义。\n\n首先，计算每根棒到组件几何中心的径向距离的平方。中心位于坐标 $(\\frac{N-1}{2}, \\frac{N-1}{2})$。径向指数的平方为：\n$$\nr^2(i,j) = \\left(i - \\frac{N-1}{2}\\right)^2 + \\left(j - \\frac{N-1}{2}\\right)^2\n$$\n接下来，使用由形状参数 $\\gamma_g$ 控制的抛物线凹陷模型，为每个群 $g$ 生成一个原始（未归一化）的通量密度图：\n$$\n\\phi^{\\mathrm{raw}}_g(i,j) = \\max\\!\\left(\\varepsilon, \\, 1 - \\gamma_g \\, r^2(i,j)\\right)\n$$\n其中 $\\varepsilon = 10^{-8}$ 是一个小的正常数，以确保通量密度严格为正。这种形状反映了自屏效应，即燃料组件中心的通量密度通常较低。$\\gamma_g = 0$ 的值会导致空间上均匀的通量密度。\n\n最后，对每个原始通量密度图进行归一化，使得一个群中所有棒的通量密度之和等于一。这对于将其用作反应率计算中的权重函数至关重要。归一化后的通量密度 $\\phi_g(i,j)$ 为：\n$$\n\\phi_g(i,j) = \\frac{\\phi^{\\mathrm{raw}}_g(i,j)}{\\sum_{p=0}^{N-1}\\sum_{q=0}^{N-1} \\phi^{\\mathrm{raw}}_g(p,q)}\n$$\n这个过程产生两个 $N \\times N$ 矩阵，$\\phi_1$ 和 $\\phi_2$，分别代表归一化后的快中子和热中子通量密度分布。关键在于，根据冻结通量近似，这些基于基准构型参数计算出的通量密度图，将同时用于基准构型和移动后构型的计算。\n\n### 2. 材料和截面映射\n\n考虑两种材料构型：'基准'构型和'移动后'构型。在基准构型中，两根 BP 棒位于指定的内部位置，所有其他棒均为燃料。在移动后构型中，这些 BP 棒被重新安置到角落位置，其原来的内部位置则被燃料填充。\n\n对于每种构型，我们为所有相关的宏观截面构建 $N \\times N$ 的分布图：$\\Sigma_{a,1}(\\mathbf{r})$、$\\Sigma_{a,2}(\\mathbf{r})$、$\\nu\\Sigma_{f,1}(\\mathbf{r})$ 和 $\\nu\\Sigma_{f,2}(\\mathbf{r})$，其中 $\\mathbf{r}$ 表示棒的位置 $(i,j)$。截面图的每个元素 $(i,j)$ 被赋予对应于该位置材料（燃料或 BP）的值。例如，对于第 1 群的吸收截面图 $\\Sigma_{a,1}(\\mathbf{r})$，在燃料棒位置将包含 $\\Sigma_{a,1}(\\mathrm{fuel})$，在 BP 棒位置将包含 $\\Sigma_{a,1}(\\mathrm{BP})$。\n\n### 3. 无穷增殖因数 ($k_{\\infty}$) 的计算\n\n无穷增殖因数 $k_{\\infty}$ 是整个组件中总中子产生率与总中子吸收率之比。使用生成的通量密度图和截面图，这些率被计算为所有棒和两个能群上的总和。\n\n总产生率 $P$ 为：\n$$\nP = \\sum_{i=0}^{N-1}\\sum_{j=0}^{N-1} \\left( \\nu\\Sigma_{f,1}(i,j) \\, \\phi_1(i,j) + \\nu\\Sigma_{f,2}(i,j) \\, \\phi_2(i,j) \\right)\n$$\n总吸收率 $A$ 为：\n$$\nA = \\sum_{i=0}^{N-1}\\sum_{j=0}^{N-1} \\left( \\Sigma_{a,1}(i,j) \\, \\phi_1(i,j) + \\Sigma_{a,2}(i,j) \\, \\phi_2(i,j) \\right)\n$$\n由此，我们计算 $k_{\\infty}$：\n$$\nk_{\\infty} = \\frac{P}{A}\n$$\n此计算分别对基准构型（$k_{\\infty}^{\\mathrm{base}}$）和移动后构型（$k_{\\infty}^{\\mathrm{moved}}$）进行，使用它们各自的截面图，但使用相同的冻结通量密度图。\n\n### 4. 棒功率峰值因子 ($PF$) 的计算\n\n棒功率峰值因子 $PF$ 衡量的是负载最重的棒的功率相对于平均棒功率的比例。在此模型中，棒功率与裂变源密度 $S(i,j)$ 成正比。\n\n首先，我们计算棒的裂变源密度图：\n$$\nS(i,j) = \\nu\\Sigma_{f,1}(i,j) \\, \\phi_1(i,j) + \\nu\\Sigma_{f,2}(i,j) \\, \\phi_2(i,j)\n$$\n最大棒功率是此图中的最大值：\n$$\nS_{\\max} = \\max_{i,j} S(i,j)\n$$\n平均棒功率是总产生率 $P$ 除以棒的数量 $N^2$：\n$$\nS_{\\mathrm{avg}} = \\frac{1}{N^2} \\sum_{i=0}^{N-1}\\sum_{j=0}^{N-1} S(i,j) = \\frac{P}{N^2}\n$$\n棒功率峰值因子是最大值与平均值之比：\n$$\nPF = \\frac{S_{\\max}}{S_{\\mathrm{avg}}}\n$$\n与 $k_{\\infty}$ 类似，为两种构型计算 $PF^{\\mathrm{base}}$ 和 $PF^{\\mathrm{moved}}$。\n\n### 5. 最终输出计算\n\n最终要求的输出是移动后构型与基准构型之间这些参数的差异：\n$$\n\\Delta k_{\\infty} = k_{\\infty}^{\\mathrm{moved}} - k_{\\infty}^{\\mathrm{base}}\n$$\n$$\n\\Delta PF = PF^{\\mathrm{moved}} - PF^{\\mathrm{base}}\n$$\n对指定的三个测试案例中的每一个都重复此整个过程，并将得到的六个值汇总成最终的输出格式。\n将强吸收、非裂变的可燃毒物棒从高通量密度的内部区域移动到低通量密度的角落区域，预计会增加反应性（$\\Delta k_{\\infty}$ 为正），因为在中子重要性最高的区域吸收减少了。此举也倾向于使功率分布变得更平坦，因为高功率的中心棒被燃料替代，但 $PF$ 的变化可能很复杂，取决于通量密度形状和涉及的具体位置。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the nuclear fuel assembly problem for a suite of test cases.\n    \"\"\"\n\n    test_cases = [\n        # Case 1 (happy path)\n        {\n            \"N\": 5,\n            \"bp_base_locs\": [(2, 2), (2, 3)],\n            \"bp_moved_locs\": [(0, 0), (0, 4)],\n            \"gamma1\": 0.02, \"gamma2\": 0.06,\n            \"fuel_props\": {\"Sa1\": 0.02, \"Sa2\": 0.08, \"nuSf1\": 0.005, \"nuSf2\": 0.12},\n            \"bp_props\": {\"Sa1\": 0.03, \"Sa2\": 0.20, \"nuSf1\": 0.0, \"nuSf2\": 0.0},\n        },\n        # Case 2 (boundary condition: uniform flux)\n        {\n            \"N\": 5,\n            \"bp_base_locs\": [(2, 2), (1, 3)],\n            \"bp_moved_locs\": [(0, 0), (4, 4)],\n            \"gamma1\": 0.0, \"gamma2\": 0.0,\n            \"fuel_props\": {\"Sa1\": 0.02, \"Sa2\": 0.08, \"nuSf1\": 0.005, \"nuSf2\": 0.12},\n            \"bp_props\": {\"Sa1\": 0.03, \"Sa2\": 0.20, \"nuSf1\": 0.0, \"nuSf2\": 0.0},\n        },\n        # Case 3 (stronger thermal absorption in BP, larger assembly)\n        {\n            \"N\": 7,\n            \"bp_base_locs\": [(3, 3), (3, 4)],\n            \"bp_moved_locs\": [(0, 6), (6, 0)],\n            \"gamma1\": 0.01, \"gamma2\": 0.04,\n            \"fuel_props\": {\"Sa1\": 0.025, \"Sa2\": 0.09, \"nuSf1\": 0.004, \"nuSf2\": 0.11},\n            \"bp_props\": {\"Sa1\": 0.035, \"Sa2\": 0.30, \"nuSf1\": 0.0, \"nuSf2\": 0.0},\n        },\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        N = case[\"N\"]\n        \n        # Step 1: Generate frozen flux maps based on baseline parameters\n        phi1_map, phi2_map = generate_flux_maps(N, case[\"gamma1\"], case[\"gamma2\"])\n\n        # Step 2: Calculate metrics for baseline configuration\n        k_inf_base, pf_base = calculate_metrics(\n            N, case[\"bp_base_locs\"], phi1_map, phi2_map, case[\"fuel_props\"], case[\"bp_props\"]\n        )\n\n        # Step 3: Calculate metrics for moved configuration\n        k_inf_moved, pf_moved = calculate_metrics(\n            N, case[\"bp_moved_locs\"], phi1_map, phi2_map, case[\"fuel_props\"], case[\"bp_props\"]\n        )\n\n        # Step 4: Compute the deltas\n        delta_k_inf = k_inf_moved - k_inf_base\n        delta_pf = pf_moved - pf_base\n\n        results.extend([delta_k_inf, delta_pf])\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(f'{r:.10f}' for r in results)}]\")\n\n\ndef generate_flux_maps(N, gamma1, gamma2):\n    \"\"\"\n    Generates normalized two-group flux maps based on a parametric model.\n    \"\"\"\n    epsilon = 1e-8\n    indices = np.arange(N)\n    i, j = np.meshgrid(indices, indices, indexing='ij')\n\n    center = (N - 1) / 2.0\n    r_squared = (i - center)**2 + (j - center)**2\n\n    phi_raw_1 = np.maximum(epsilon, 1 - gamma1 * r_squared)\n    phi_raw_2 = np.maximum(epsilon, 1 - gamma2 * r_squared)\n\n    phi1_map = phi_raw_1 / np.sum(phi_raw_1)\n    phi2_map = phi_raw_2 / np.sum(phi_raw_2)\n\n    return phi1_map, phi2_map\n\n\ndef calculate_metrics(N, bp_locs, phi1_map, phi2_map, fuel_props, bp_props):\n    \"\"\"\n    Calculates k_inf and PF for a given material configuration and flux maps.\n    \"\"\"\n    # Create material map: 0 for fuel, 1 for BP\n    material_map = np.zeros((N, N), dtype=int)\n    for r, c in bp_locs:\n        material_map[r, c] = 1\n\n    # Create full cross-section maps using advanced indexing\n    Sa1_map = np.array([fuel_props[\"Sa1\"], bp_props[\"Sa1\"]])[material_map]\n    Sa2_map = np.array([fuel_props[\"Sa2\"], bp_props[\"Sa2\"]])[material_map]\n    nuSf1_map = np.array([fuel_props[\"nuSf1\"], bp_props[\"nuSf1\"]])[material_map]\n    nuSf2_map = np.array([fuel_props[\"nuSf2\"], bp_props[\"nuSf2\"]])[material_map]\n\n    # Calculate total production and absorption rates\n    total_production = np.sum(nuSf1_map * phi1_map + nuSf2_map * phi2_map)\n    total_absorption = np.sum(Sa1_map * phi1_map + Sa2_map * phi2_map)\n\n    # Calculate k_inf\n    k_inf = total_production / total_absorption if total_absorption != 0 else 0.0\n    \n    # Calculate pin power peaking factor (PF)\n    # Pin power is proportional to fission source density\n    pin_power_map = nuSf1_map * phi1_map + nuSf2_map * phi2_map\n    \n    if total_production > 0:\n        max_pin_power = np.max(pin_power_map)\n        avg_pin_power = total_production / (N * N)\n        pf = max_pin_power / avg_pin_power\n    else: # Should not happen with fuel in the assembly\n        pf = 1.0\n\n    return k_inf, pf\n\nsolve()\n```"
        },
        {
            "introduction": "可燃毒物的有效性并非恒定不变；它关键地取决于其局部环境，这种现象被称为自屏效应。本实践深入探讨了这种非线性行为，探索慢化剂密度的变化如何改变热中子通量，并因此改变毒物的有效截面及其反应性抑制能力 。掌握这一概念对于在反应堆的整个运行周期内准确预测含毒物燃料的性能至关重要。",
            "id": "4219370",
            "problem": "考虑一个代表含有可燃毒物的燃料-慢化剂栅格的均匀无限介质晶胞。假设中子平衡采用单热能群，并对可燃毒物使用简化的自屏效应模型。目标是计算慢化剂数密度的变化如何影响热中子通量、毒物的有效微观吸收截面以及由毒物引入的反应性抑制。本问题中所有量均视为无量纲归一化参数，所有输出必须以无量纲浮点数形式报告。\n\n基本原理和定义：\n- 使用无限介质中的单群扩散平衡：热群平衡简化为由中子扩散方程导出的源-移出关系，即体积平均热中子通量 $ \\phi $ 满足 $ \\Sigma_{r} \\, \\phi = S $，其中 $ \\Sigma_{r} $ 是宏观移出截面，$ S $ 是有效热源。在空间梯度为零的无限均匀介质中，在此简化情境下，$ \\Sigma_{r} $ 简化为一个有效吸收项。\n- 设热源 $ S $ 与慢化剂数密度成正比，因为慢化源主要由散射相互作用决定，所以 $ S = S_{0} \\, \\rho_{m} $，其中 $ S_{0} $ 是一个归一化常数，$ \\rho_{m} $ 是相对于标称工况的慢化剂密度乘子。\n- 总热吸收宏观截面 $ \\Sigma_{a,\\text{tot}} $ 是燃料、慢化剂和可燃毒物贡献的总和：$ \\Sigma_{a,\\text{tot}} = \\Sigma_{a,\\text{fuel}} + \\Sigma_{a,\\text{mod}} + \\Sigma_{a,\\text{poison,eff}} $。假设 $ \\Sigma_{a,\\text{mod}} = \\rho_{m} \\, \\Sigma_{a,\\text{mod,nom}} $ 与慢化剂密度线性相关。\n- 可燃毒物有效宏观吸收截面为 $ \\Sigma_{a,\\text{poison,eff}} = N_{p} \\, \\sigma_{p,\\text{eff}} $，其中 $ N_{p} $ 是无量纲毒物数密度乘子，$ \\sigma_{p,\\text{eff}} $ 是有效微观吸收截面。\n- 使用一个简化的、受碰撞概率启发的非线性衰减关系来模拟毒物自屏效应：$ \\sigma_{p,\\text{eff}} = \\dfrac{\\sigma_{p}}{1 + b \\, \\phi \\, \\sigma_{p}} $，其中 $ \\sigma_{p} $ 是未屏的微观吸收参数，$ b $ 是一个无量纲的块体几何与共振饱和参数。该关系式捕捉了由于吸收体内部通量凹陷以及单热能群的谱不敏感性而导致的有效截面降低。此关系意味着 $ \\phi $ 和 $ \\sigma_{p,\\text{eff}} $ 之间存在耦合。\n- 根据这些定义，热中子通量 $ \\phi $ 由不动点关系 $ \\phi = \\dfrac{S_{0} \\, \\rho_{m}}{\\Sigma_{a,\\text{fuel}} + \\rho_{m} \\, \\Sigma_{a,\\text{mod,nom}} + N_{p} \\, \\sigma_{p,\\text{eff}}(\\phi)} $ 决定，由于 $ \\sigma_{p,\\text{eff}} $ 依赖于 $ \\phi $，该方程必须被一致地求解。\n- 使用无限介质单群有效增殖因数定义 $ k = \\dfrac{\\nu \\Sigma_{f}}{\\Sigma_{a,\\text{tot}}} $，其中 $ \\nu \\Sigma_{f} $ 是无量纲（归一化）的有效中子产生项。反应性为 $ \\rho = \\dfrac{k - 1}{k} = 1 - \\dfrac{\\Sigma_{a,\\text{tot}}}{\\nu \\Sigma_{f}} $。将毒物反应性抑制定义为在相同慢化剂密度下，有毒物时的反应性与无毒物时的反应性之差：$ \\Delta \\rho_{\\text{hold}}(\\rho_{m}) = \\rho_{\\text{with poison}}(\\rho_{m}) - \\rho_{\\text{without poison}}(\\rho_{m}) $，该值通常为负。\n\n任务：\n- 对于每个测试用例，给定标称慢化剂密度 $ \\rho_{m,0} $ 和一个受扰动的慢化剂密度 $ \\rho_{m,1} $，计算：\n  1. 可燃毒物有效微观吸收截面的变化量 $ \\Delta \\sigma_{p,\\text{eff}} = \\sigma_{p,\\text{eff}}(\\rho_{m,1}) - \\sigma_{p,\\text{eff}}(\\rho_{m,0}) $。\n  2. 毒物反应性抑制的变化量 $ \\Delta \\left( \\Delta \\rho_{\\text{hold}} \\right) = \\Delta \\rho_{\\text{hold}}(\\rho_{m,1}) - \\Delta \\rho_{\\text{hold}}(\\rho_{m,0}) $。\n\n算法要求：\n- 对于每个 $ \\rho_{m} \\in \\{ \\rho_{m,0}, \\rho_{m,1} \\} $：\n  - 计算 $ \\Sigma_{a,\\text{mod}} = \\rho_{m} \\, \\Sigma_{a,\\text{mod,nom}} $。\n  - 求解 $ \\phi $ 的不动点方程：\n    $$ \\phi = \\dfrac{S_{0} \\, \\rho_{m}}{\\Sigma_{a,\\text{fuel}} + \\rho_{m} \\, \\Sigma_{a,\\text{mod,nom}} + N_{p} \\, \\dfrac{\\sigma_{p}}{1 + b \\, \\phi \\, \\sigma_{p}}} $$\n    使用简单迭代法，直到 $ \\phi $ 的相对变化小于一个容差（例如，$ 10^{-10} $），或达到最大迭代次数上限（例如，$ 10000 $ 次迭代）。使用 $ \\phi^{(0)} = \\dfrac{S_{0} \\, \\rho_{m}}{\\Sigma_{a,\\text{fuel}} + \\rho_{m} \\, \\Sigma_{a,\\text{mod,nom}} + N_{p} \\, \\sigma_{p}} $ 初始化迭代。\n  - 收敛后，计算 $ \\sigma_{p,\\text{eff}} = \\dfrac{\\sigma_{p}}{1 + b \\, \\phi \\, \\sigma_{p}} $ 和 $ \\Sigma_{a,\\text{tot}} = \\Sigma_{a,\\text{fuel}} + \\rho_{m} \\, \\Sigma_{a,\\text{mod,nom}} + N_{p} \\, \\sigma_{p,\\text{eff}} $。\n  - 计算含毒物时的反应性 $ \\rho_{\\text{with poison}} = 1 - \\dfrac{\\Sigma_{a,\\text{tot}}}{\\nu \\Sigma_{f}} $ 和不含毒物时的反应性 $ \\rho_{\\text{without poison}} = 1 - \\dfrac{\\Sigma_{a,\\text{fuel}} + \\rho_{m} \\, \\Sigma_{a,\\text{mod,nom}}}{\\nu \\Sigma_{f}} $。然后计算 $ \\Delta \\rho_{\\text{hold}}(\\rho_{m}) = \\rho_{\\text{with poison}} - \\rho_{\\text{without poison}} $。\n- 为每个测试用例返回数对 $ [\\Delta \\sigma_{p,\\text{eff}}, \\Delta (\\Delta \\rho_{\\text{hold}})] $，其值为浮点数。\n\n测试套件：\n每个测试用例是一个元组 $ (\\rho_{m,0}, \\rho_{m,1}, N_{p}, \\sigma_{p}, b, \\Sigma_{a,\\text{fuel}}, \\Sigma_{a,\\text{mod,nom}}, \\Sigma_{s,\\text{mod,nom}}, \\nu \\Sigma_{f}, S_{0}) $。注意，$ \\Sigma_{s,\\text{mod,nom}} $ 并未显式出现在单群移出平衡中，但包含它是为了反映 $ S_{0} $ 是慢化强度的一个归一化代理；即使计算中未使用，您仍必须在程序中传递它以确保接口一致。\n\n提供以下四个测试用例：\n- 案例 $ 1 $ (一般情况): $ (1.0, 0.9, 0.02, 12.0, 0.3, 0.08, 0.01, 1.0, 0.12, 1.0) $。\n- 案例 $ 2 $ (低慢化剂边界): $ (1.0, 0.5, 0.02, 12.0, 0.3, 0.08, 0.01, 1.0, 0.12, 1.0) $。\n- 案例 $ 3 $ (强毒物，高慢化剂): $ (1.0, 1.2, 0.05, 12.0, 0.3, 0.08, 0.01, 1.0, 0.12, 1.0) $。\n- 案例 $ 4 $ (弱毒物，中度慢化剂减少): $ (1.0, 0.8, 0.005, 12.0, 0.6, 0.08, 0.01, 1.0, 0.12, 1.0) $。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个元素对应一个测试用例，并且本身是一个双元素列表 $ [\\Delta \\sigma_{p,\\text{eff}}, \\Delta (\\Delta \\rho_{\\text{hold}})] $。例如，包含两个测试用例的输出应如下所示：$ [[x_{1},y_{1}],[x_{2},y_{2}]] $。实际值必须由您的程序根据指定的四个测试用例计算得出。",
            "solution": "该问题是有效的。它在核反应堆物理领域提出了一个适定的、有科学依据的情景，提供了所有必要的参数、定义和清晰的计算算法。该物理模型虽然简化为单群、无限介质的表示，但捕捉了热中子通量与可燃毒物自屏效应之间的本质反馈，及其对反应堆反应性的随之产生的影响。使用简单迭代方案求解中子通量的非线性不动点方程是适用于此情境的标准数值技术。由于迭代函数是单调递增且有界的，该特定迭代方案的收敛性得到保证。\n\n目标是量化慢化剂密度的变化如何影响两个关键参数：可燃毒物的有效微观吸收截面 $ \\sigma_{p,\\text{eff}} $ 和由毒物提供的反应性抑制 $ \\Delta \\rho_{\\text{hold}} $。此分析针对两种慢化剂密度条件进行：标称状态 $ \\rho_{m,0} $ 和扰动状态 $ \\rho_{m,1} $。\n\n问题的核心在于热中子通量 $ \\phi $ 与有效毒物截面 $ \\sigma_{p,\\text{eff}} $ 之间的耦合关系。通量由中子平衡方程确定，其中吸收与源相平衡：\n$$ (\\Sigma_{a,\\text{fuel}} + \\Sigma_{a,\\text{mod}} + \\Sigma_{a,\\text{poison,eff}}) \\, \\phi = S $$\n该方程中的各项定义如下：\n- 热源 $ S $ 与慢化剂密度乘子 $ \\rho_{m} $ 成正比：$ S = S_{0} \\, \\rho_{m} $。\n- 慢化剂吸收截面 $ \\Sigma_{a,\\text{mod}} $ 也与慢化剂密度成比例：$ \\Sigma_{a,\\text{mod}} = \\rho_{m} \\, \\Sigma_{a,\\text{mod,nom}} $。\n- 有效宏观毒物吸收截面 $ \\Sigma_{a,\\text{poison,eff}} $ 依赖于有效微观截面：$ \\Sigma_{a,\\text{poison,eff}} = N_{p} \\, \\sigma_{p,\\text{eff}} $。\n- 有效微观毒物截面 $ \\sigma_{p,\\text{eff}} $ 由于自屏效应而是通量 $ \\phi $ 的函数：\n$$ \\sigma_{p,\\text{eff}}(\\phi) = \\dfrac{\\sigma_{p}}{1 + b \\, \\phi \\, \\sigma_{p}} $$\n其中 $ \\sigma_p $ 是未屏截面，$ b $ 是自屏因子。\n\n将这些定义代入平衡方程，得到关于 $ \\phi $ 的不动点方程：\n$$ \\phi = \\dfrac{S_{0} \\, \\rho_{m}}{\\Sigma_{a,\\text{fuel}} + \\rho_{m} \\, \\Sigma_{a,\\text{mod,nom}} + N_{p} \\, \\sigma_{p,\\text{eff}}(\\phi)} $$\n$$ \\phi = \\dfrac{S_{0} \\, \\rho_{m}}{\\Sigma_{a,\\text{fuel}} + \\rho_{m} \\, \\Sigma_{a,\\text{mod,nom}} + N_{p} \\, \\dfrac{\\sigma_{p}}{1 + b \\, \\phi \\, \\sigma_{p}}} $$\n对于每个给定的慢化剂密度 $ \\rho_m $，必须求解这个非线性方程以得到 $ \\phi $。问题指定了一种简单的迭代方法。从一个初始猜测值 $ \\phi^{(0)} $ 开始，使用以下公式计算逐次逼近值：\n$$ \\phi^{(i+1)} = \\frac{S_{0} \\, \\rho_{m}}{\\Sigma_{a,\\text{fuel}} + \\rho_{m} \\, \\Sigma_{a,\\text{mod,nom}} + N_{p} \\, \\frac{\\sigma_{p}}{1 + b \\, \\phi^{(i)} \\, \\sigma_{p}}} $$\n迭代的初始值使用在没有自屏效应（$ b=0 $）时获得的通量值进行初始化：\n$$ \\phi^{(0)} = \\dfrac{S_{0} \\, \\rho_{m}}{\\Sigma_{a,\\text{fuel}} + \\rho_{m} \\, \\Sigma_{a,\\text{mod,nom}} + N_{p} \\, \\sigma_{p}} $$\n该过程持续进行，直到相对差异 $ |(\\phi^{(i+1)} - \\phi^{(i)}) / \\phi^{(i+1)}| $ 小于指定的容差 $ 10^{-10} $。\n\n一旦对于给定的 $ \\rho_m $ 找到了收敛的通量 $ \\phi $，其余的量可以直接计算。\n$ 1 $. 有效微观毒物截面为：\n$$ \\sigma_{p,\\text{eff}} = \\dfrac{\\sigma_{p}}{1 + b \\, \\phi \\, \\sigma_{p}} $$\n$ 2 $. 毒物反应性抑制 $ \\Delta \\rho_{\\text{hold}} $ 是有毒物系统与无毒物系统之间的反应性差异。反应性 $ \\rho $ 定义为 $ \\rho = 1 - \\dfrac{\\Sigma_{a,\\text{tot}}}{\\nu \\Sigma_{f}} $。\n含毒物时的反应性为：\n$$ \\rho_{\\text{with poison}} = 1 - \\dfrac{\\Sigma_{a,\\text{fuel}} + \\rho_{m} \\, \\Sigma_{a,\\text{mod,nom}} + N_{p} \\, \\sigma_{p,\\text{eff}}}{\\nu \\Sigma_{f}} $$\n无毒物时的反应性为：\n$$ \\rho_{\\text{without poison}} = 1 - \\dfrac{\\Sigma_{a,\\text{fuel}} + \\rho_{m} \\, \\Sigma_{a,\\text{mod,nom}}}{\\nu \\Sigma_{f}} $$\n因此，抑制值为：\n$$ \\Delta \\rho_{\\text{hold}}(\\rho_m) = \\rho_{\\text{with poison}} - \\rho_{\\text{without poison}} = - \\frac{N_{p} \\, \\sigma_{p,\\text{eff}}}{\\nu \\Sigma_{f}} $$\n对初始慢化剂密度 $ \\rho_{m,0} $ 和扰动后密度 $ \\rho_{m,1} $ 均执行此过程，得到数对 ($ \\sigma_{p,\\text{eff}}(\\rho_{m,0}), \\Delta \\rho_{\\text{hold}}(\\rho_{m,0}) $) 和 ($ \\sigma_{p,\\text{eff}}(\\rho_{m,1}), \\Delta \\rho_{\\text{hold}}(\\rho_{m,1}) $)。\n\n最后，计算所需的变化量：\n- 有效截面的变化量：$ \\Delta \\sigma_{p,\\text{eff}} = \\sigma_{p,\\text{eff}}(\\rho_{m,1}) - \\sigma_{p,\\text{eff}}(\\rho_{m,0}) $。\n- 反应性抑制的变化量：$ \\Delta (\\Delta \\rho_{\\text{hold}}) = \\Delta \\rho_{\\text{hold}}(\\rho_{m,1}) - \\Delta \\rho_{\\text{hold}}(\\rho_{m,0}) $。\n\n对问题陈述中提供的每个测试用例重复这整个计算序列。参数 $ \\Sigma_{s,\\text{mod,nom}} $ 是为了接口一致性而提供的，但已正确指出其不参与单群吸收-源平衡方程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    \"\"\"\n\n    # Test cases defined as tuples:\n    # (rho_m0, rho_m1, Np, sigma_p, b, Sigma_a_fuel, Sigma_a_mod_nom, \n    #  Sigma_s_mod_nom, nu_Sigma_f, S0)\n    test_cases = [\n        (1.0, 0.9, 0.02, 12.0, 0.3, 0.08, 0.01, 1.0, 0.12, 1.0),\n        (1.0, 0.5, 0.02, 12.0, 0.3, 0.08, 0.01, 1.0, 0.12, 1.0),\n        (1.0, 1.2, 0.05, 12.0, 0.3, 0.08, 0.01, 1.0, 0.12, 1.0),\n        (1.0, 0.8, 0.005, 12.0, 0.6, 0.08, 0.01, 1.0, 0.12, 1.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        # Unpack problem parameters\n        (rho_m0, rho_m1, Np, sigma_p, b, Sigma_a_fuel, Sigma_a_mod_nom,\n         Sigma_s_mod_nom, nu_Sigma_f, S0) = case\n\n        # Package parameters for the calculation function\n        params = (Np, sigma_p, b, Sigma_a_fuel, Sigma_a_mod_nom, nu_Sigma_f, S0)\n\n        # Calculate properties for the initial moderator density\n        sigma_eff_0, hold_down_0 = calculate_properties(rho_m0, params)\n        \n        # Calculate properties for the perturbed moderator density\n        sigma_eff_1, hold_down_1 = calculate_properties(rho_m1, params)\n\n        # Calculate the final required differences\n        delta_sigma_p_eff = sigma_eff_1 - sigma_eff_0\n        delta_delta_rho_hold = hold_down_1 - hold_down_0\n\n        results.append([delta_sigma_p_eff, delta_delta_rho_hold])\n\n    # Print the final results in the specified format\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef calculate_properties(rho_m, params):\n    \"\"\"\n    Calculates the effective poison cross section and reactivity hold-down \n    for a given moderator density and set of physical parameters.\n\n    Args:\n        rho_m (float): The moderator density multiplier.\n        params (tuple): A tuple of physical parameters.\n\n    Returns:\n        (float, float): A tuple containing the calculated\n                        sigma_p_eff and delta_rho_hold.\n    \"\"\"\n    # Unpack parameters\n    Np, sigma_p, b, Sigma_a_fuel, Sigma_a_mod_nom, nu_Sigma_f, S0 = params\n\n    # Set numerical parameters for iteration\n    TOL = 1.0e-10\n    MAX_ITER = 10000\n\n    # Calculate terms that depend on moderator density\n    S = S0 * rho_m\n    Sigma_a_mod = rho_m * Sigma_a_mod_nom\n\n    # --- Fixed-point iteration to find the thermal flux (phi) ---\n\n    # Initial guess for phi (assuming no self-shielding)\n    phi_old = S / (Sigma_a_fuel + Sigma_a_mod + Np * sigma_p)\n    \n    phi_new = 0.0\n    for _ in range(MAX_ITER):\n        # Denominator of the self-shielded cross section expression\n        den_sigma_eff = 1.0 + b * phi_old * sigma_p\n        \n        # Denominator of the flux equation\n        sigma_p_eff_iter = sigma_p / den_sigma_eff\n        den_phi = Sigma_a_fuel + Sigma_a_mod + Np * sigma_p_eff_iter\n\n        # Iteration step\n        phi_new = S / den_phi\n\n        # Check for convergence\n        if phi_new > 1e-12 and abs(phi_new - phi_old) / phi_new  TOL:\n            break\n        elif phi_new = 1e-12 and abs(phi_new - phi_old)  TOL:\n            break\n\n        phi_old = phi_new\n    \n    phi = phi_new\n\n    # --- Post-convergence calculations ---\n\n    # Effective microscopic poison absorption cross section\n    sigma_p_eff = sigma_p / (1.0 + b * phi * sigma_p)\n\n    # Total macroscopic absorption cross section with poison\n    Sigma_a_tot_with_poison = Sigma_a_fuel + Sigma_a_mod + Np * sigma_p_eff\n    \n    # Total macroscopic absorption cross section without poison\n    Sigma_a_tot_without_poison = Sigma_a_fuel + Sigma_a_mod\n\n    # Reactivity with poison\n    rho_with_poison = 1.0 - Sigma_a_tot_with_poison / nu_Sigma_f\n    \n    # Reactivity without poison\n    rho_without_poison = 1.0 - Sigma_a_tot_without_poison / nu_Sigma_f\n\n    # Poison reactivity hold-down\n    delta_rho_hold = rho_with_poison - rho_without_poison\n\n    return sigma_p_eff, delta_rho_hold\n\n# Execute the solver\nsolve()\n```"
        },
        {
            "introduction": "为了高效地优化整个反应堆堆芯，我们需要比简单的试错法更强大的方法。这项高级实践介绍了基于伴随函数的灵敏度分析，这是现代反应堆设计自动化的基石 。您将为一个简化的堆芯模型计算伴随通量，以精确确定堆芯的有效增殖因数 ($k_{\\mathrm{eff}}$) 对毒物浓度变化的敏感程度，从而为优化提供了直接途径。",
            "id": "4219387",
            "problem": "您的任务是计算伴随中子通量，用以评估在一维粗网格扩散模型的核反应堆堆芯中，有效增殖因子 $k_{\\mathrm{eff}}$ 对可燃毒物密度变化的一阶灵敏度。反应堆堆芯由一个包含 $N$ 个节点的均匀网格表示，节点间距为 $h$（单位：$\\mathrm{cm}$），并采用反射边界条件。物理模型为稳态、单群中子扩散近似，使用带有界面扩散系数的有限差分法进行离散化。\n\n从以下基本原理开始：\n\n- 在扩散近似下，稳态单群中子平衡可以在离散化网格上表示为一个广义特征值问题，\n$$\nL(\\boldsymbol{\\theta}) \\, \\boldsymbol{\\phi} = \\lambda \\, M(\\boldsymbol{\\theta}) \\, \\boldsymbol{\\phi},\n$$\n其中 $L$ 是包含中子扩散和吸收的损失算子，$M$ 是包含裂变中子产生的产生算子，$\\boldsymbol{\\phi}$ 是中子通量矢量，$\\lambda$ 是等于 $1/k_{\\mathrm{eff}}$ 的广义特征值，$\\boldsymbol{\\theta}$ 是材料参数。施加了反射边界条件。\n\n- 伴随特征值问题为\n$$\nL(\\boldsymbol{\\theta})^{\\mathsf{T}} \\, \\boldsymbol{\\phi}^{\\ast} = \\lambda \\, M(\\boldsymbol{\\theta})^{\\mathsf{T}} \\, \\boldsymbol{\\phi}^{\\ast},\n$$\n其中 $\\boldsymbol{\\phi}^{\\ast}$ 是伴随通量，${}^{\\mathsf{T}}$ 表示转置。\n\n- 可燃毒物密度参数 $p$ 通过以下方式线性地进入宏观吸收截面\n$$\n\\Sigma_{a,i}(p) = \\Sigma_{a,i}^{\\mathrm{base}} + p \\, \\Sigma_{p,i},\n$$\n其中 $\\Sigma_{a,i}^{\\mathrm{base}}$ 是节点 $i$ 的基础吸收截面，$\\Sigma_{p,i}$ 是节点 $i$ 中毒物的宏观吸收截面贡献。所有截面的单位均为 $\\mathrm{cm}^{-1}$，扩散系数 $D_i$ 的单位为 $\\mathrm{cm}$。裂变产生截面为 $\\nu \\Sigma_{f,i}$，单位为 $\\mathrm{cm}^{-1}$。网格间距为 $h$，单位为 $\\mathrm{cm}$。\n\n- 离散损失算子 $L$ 使用调和平均界面扩散系数 $D_{i+\\frac{1}{2}}$ 和反射边界构建，其矩阵元为\n$$\nL_{i,i} = \\frac{D_{i-\\frac{1}{2}} + D_{i+\\frac{1}{2}}}{h^2} + \\Sigma_{a,i}(p), \\quad\nL_{i,i-1} = -\\frac{D_{i-\\frac{1}{2}}}{h^2}, \\quad\nL_{i,i+1} = -\\frac{D_{i+\\frac{1}{2}}}{h^2},\n$$\n其中 $D_{-\\frac{1}{2}} = 0$ 和 $D_{N-\\frac{1}{2}} = 0$ 强制施加反射边界，并且对于 $i = 0, \\dots, N-2$，$D_{i+\\frac{1}{2}} = \\dfrac{2}{\\frac{1}{D_i} + \\frac{1}{D_{i+1}}}$。产生算子 $M$ 是对角矩阵，其元素为 $M_{i,i} = \\nu \\Sigma_{f,i}$。\n\n您的程序必须：\n\n- 针对每个测试用例，在基准毒物密度 $p_0$ 下构建 $L$ 和 $M$。\n- 求解正向广义特征值问题，得到最小的正实数特征值 $\\lambda$ 和相应的右特征矢量 $\\boldsymbol{\\phi}$，并计算 $k_{\\mathrm{eff}} = 1/\\lambda$。\n- 求解伴随广义特征值问题，以获得与同一 $\\lambda$ 对应的 $\\boldsymbol{\\phi}^{\\ast}$。\n- 使用第一性原理，推导并实现 $k_{\\mathrm{eff}}$ 对 $p$ 的一阶灵敏度，该灵敏度用在 $p_0$ 处求值的伴随解、正向解以及算子导数 $\\frac{\\partial L}{\\partial p}$ 来表示。将 $p$ 视为无量纲量。不要假设 $\\boldsymbol{\\phi}$ 或 $\\boldsymbol{\\phi}^{\\ast}$ 经过任何预归一化；任何所需的内积都必须显式计算。\n- 使用一阶灵敏度预测对于小微扰 $\\delta p$ 所引起的变化量 $\\Delta k_{\\mathrm{eff}}$。\n- 通过在 $p_1 = p_0 + \\delta p$ 处直接重新计算 $k_{\\mathrm{eff}}$ 并与基准值求差来验证该预测。\n\n物理和数值单位：\n- 对 $h$ 和 $D_i$ 使用 $\\mathrm{cm}$，对所有截面使用 $\\mathrm{cm}^{-1}$。有效增殖因子 $k_{\\mathrm{eff}}$ 及其变化是无量纲的。将所有最终输出表示为十进制浮点数（无量纲）。\n\n测试套件：\n实现以下三个测试用例。对于每个用例，最终结果必须是基于伴随的一阶预测值 $\\Delta k_{\\mathrm{eff}}^{\\mathrm{pred}}$ 与直接计算的变化量 $\\Delta k_{\\mathrm{eff}}^{\\mathrm{dir}}$ 之间的绝对误差。\n\n- 用例 1（理想路径，内部毒物）：\n  - $N = 12$, $h = 15$ $\\mathrm{cm}$。\n  - 对所有 $i$，$D_i = 1.2$ $\\mathrm{cm}$。\n  - 对所有 $i$，$\\Sigma_{a,i}^{\\mathrm{base}} = 0.006$ $\\mathrm{cm}^{-1}$。\n  - 对所有 $i$，$\\nu \\Sigma_{f,i} = 0.045$ $\\mathrm{cm}^{-1}$。\n  - 对所有 $i$（$i \\in \\{5,6\\}$ 除外），$\\Sigma_{p,i} = 0$ $\\mathrm{cm}^{-1}$，在 $i \\in \\{5,6\\}$ 处 $\\Sigma_{p,i} = 0.020$ $\\mathrm{cm}^{-1}$。\n  - $p_0 = 0.8$, $\\delta p = 0.01$。\n\n- 用例 2（边界条件和零毒物导数边缘情况）：\n  - $N = 8$, $h = 20$ $\\mathrm{cm}$。\n  - 对所有 $i$，$D_i = 1.4$ $\\mathrm{cm}$。\n  - 对所有 $i$，$\\Sigma_{a,i}^{\\mathrm{base}} = 0.006$ $\\mathrm{cm}^{-1}$。\n  - 对所有 $i$，$\\nu \\Sigma_{f,i} = 0.050$ $\\mathrm{cm}^{-1}$。\n  - 对所有 $i$，$\\Sigma_{p,i} = 0$ $\\mathrm{cm}^{-1}$。\n  - $p_0 = 1.0$, $\\delta p = 0.05$。\n\n- 用例 3（非均匀扩散，边界处毒物，负微扰）：\n  - $N = 10$, $h = 12$ $\\mathrm{cm}$。\n  - 对于 $i = 0, \\dots, N-1$，$D_i = 1.0 + 0.6 \\frac{i}{N-1}$ $\\mathrm{cm}$。\n  - 对所有 $i$，$\\Sigma_{a,i}^{\\mathrm{base}} = 0.005$ $\\mathrm{cm}^{-1}$。\n  - 对所有 $i$，$\\nu \\Sigma_{f,i} = 0.040$ $\\mathrm{cm}^{-1}$。\n  - 对所有 $i$（$i \\in \\{0,9\\}$ 除外），$\\Sigma_{p,i} = 0$ $\\mathrm{cm}^{-1}$，在 $i \\in \\{0,9\\}$ 处 $\\Sigma_{p,i} = 0.030$ $\\mathrm{cm}^{-1}$。\n  - $p_0 = 0.5$, $\\delta p = -0.02$。\n\n最终输出格式：\n您的程序应产生单行输出，其中包含三个绝对误差，形式为用方括号括起来的逗号分隔的十进制浮点数列表，例如 $[e_1,e_2,e_3]$，其中 $e_j = \\left|\\Delta k_{\\mathrm{eff},j}^{\\mathrm{pred}} - \\Delta k_{\\mathrm{eff},j}^{\\mathrm{dir}}\\right|$ 对应于用例 $j$。输出中不得包含任何额外文本。",
            "solution": "用户提供的问题经评估有效。它在科学上基于已建立的反应堆物理原理，在数学上是适定的，并且为获得唯一且有意义的解提供了所有必要的参数和定义。未发现任何矛盾、歧义或事实不准确之处。\n\n问题的核心是计算有效增殖因子 $k_{\\mathrm{eff}}$ 相对于可燃毒物密度 $p$ 变化的一阶灵敏度。这需要使用依赖于正向和伴随中子通量的一阶微扰理论来推导灵敏度系数。\n\n首先，我们形式上推导灵敏度表达式。该系统由单群稳态中子扩散方程描述，离散化为一个广义特征值问题：\n$$\nL(p) \\, \\boldsymbol{\\phi}(p) = \\lambda(p) \\, M \\, \\boldsymbol{\\phi}(p)\n$$\n其中 $\\boldsymbol{\\phi}$ 是每个空间节点的中子通量矢量，$L$ 是中子损失算子（扩散和吸收），$M$ 是中子产生算子（裂变），$\\lambda = 1/k_{\\mathrm{eff}}$ 是特征值，$p$ 是毒物密度参数。值得注意的是，$M$ 不依赖于 $p$。\n\n相应的伴随特征值问题由下式给出：\n$$\nL(p)^{\\mathsf{T}} \\, \\boldsymbol{\\phi}^{\\ast}(p) = \\lambda(p) \\, M^{\\mathsf{T}} \\, \\boldsymbol{\\phi}^{\\ast}(p)\n$$\n其中 $\\boldsymbol{\\phi}^{\\ast}$ 是伴随通量矢量。在此问题中，离散化算子 $L$ 和产生算子 $M$（它是对角矩阵）都是实对称的，因此 $L^{\\mathsf{T}} = L$ 且 $M^{\\mathsf{T}} = M$。因此，正向和伴随问题是相同的，它们的特征矢量 $\\boldsymbol{\\phi}$ 和 $\\boldsymbol{\\phi}^{\\ast}$ 也相同。\n\n为了找到灵敏度，我们对正向特征值方程关于 $p$ 求导：\n$$\n\\frac{\\partial L}{\\partial p} \\boldsymbol{\\phi} + L \\frac{\\partial \\boldsymbol{\\phi}}{\\partial p} = \\frac{\\partial \\lambda}{\\partial p} M \\boldsymbol{\\phi} + \\lambda M \\frac{\\partial \\boldsymbol{\\phi}}{\\partial p}\n$$\n然后，我们用伴随通量 $\\boldsymbol{\\phi}^{\\ast}$ 对此方程作内积，其中内积定义为 $\\langle \\mathbf{y}, \\mathbf{x} \\rangle = \\mathbf{y}^{\\mathsf{T}}\\mathbf{x}$。\n$$\n\\langle \\boldsymbol{\\phi}^{\\ast}, \\frac{\\partial L}{\\partial p} \\boldsymbol{\\phi} \\rangle + \\langle \\boldsymbol{\\phi}^{\\ast}, L \\frac{\\partial \\boldsymbol{\\phi}}{\\partial p} \\rangle = \\frac{\\partial \\lambda}{\\partial p} \\langle \\boldsymbol{\\phi}^{\\ast}, M \\boldsymbol{\\phi} \\rangle + \\lambda \\langle \\boldsymbol{\\phi}^{\\ast}, M \\frac{\\partial \\boldsymbol{\\phi}}{\\partial p} \\rangle\n$$\n根据伴随算子的定义，$\\langle \\boldsymbol{\\phi}^{\\ast}, L \\mathbf{v} \\rangle = \\langle L^{\\mathsf{T}} \\boldsymbol{\\phi}^{\\ast}, \\mathbf{v} \\rangle$。利用此性质和伴随方程 $L^{\\mathsf{T}}\\boldsymbol{\\phi}^{\\ast} = \\lambda M^{\\mathsf{T}}\\boldsymbol{\\phi}^{\\ast}$，我们可以重写左侧第二项：\n$$\n\\langle \\boldsymbol{\\phi}^{\\ast}, L \\frac{\\partial \\boldsymbol{\\phi}}{\\partial p} \\rangle = \\langle L^{\\mathsf{T}} \\boldsymbol{\\phi}^{\\ast}, \\frac{\\partial \\boldsymbol{\\phi}}{\\partial p} \\rangle = \\langle \\lambda M^{\\mathsf{T}} \\boldsymbol{\\phi}^{\\ast}, \\frac{\\partial \\boldsymbol{\\phi}}{\\partial p} \\rangle = \\lambda \\langle \\boldsymbol{\\phi}^{\\ast}, M \\frac{\\partial \\boldsymbol{\\phi}}{\\partial p} \\rangle\n$$\n最后一步成立，因为 $M$ 是对称的（$M^{\\mathsf{T}} = M$）。将其代回后，我们发现包含通量导数 $\\frac{\\partial \\boldsymbol{\\phi}}{\\partial p}$ 的项相互抵消：\n$$\n\\langle \\boldsymbol{\\phi}^{\\ast}, \\frac{\\partial L}{\\partial p} \\boldsymbol{\\phi} \\rangle + \\lambda \\langle \\boldsymbol{\\phi}^{\\ast}, M \\frac{\\partial \\boldsymbol{\\phi}}{\\partial p} \\rangle = \\frac{\\partial \\lambda}{\\partial p} \\langle \\boldsymbol{\\phi}^{\\ast}, M \\boldsymbol{\\phi} \\rangle + \\lambda \\langle \\boldsymbol{\\phi}^{\\ast}, M \\frac{\\partial \\boldsymbol{\\phi}}{\\partial p} \\rangle\n$$\n$$\n\\implies \\langle \\boldsymbol{\\phi}^{\\ast}, \\frac{\\partial L}{\\partial p} \\boldsymbol{\\phi} \\rangle = \\frac{\\partial \\lambda}{\\partial p} \\langle \\boldsymbol{\\phi}^{\\ast}, M \\boldsymbol{\\phi} \\rangle\n$$\n解出 $\\frac{\\partial \\lambda}{\\partial p}$ 得到特征值的灵敏度：\n$$\n\\frac{\\partial \\lambda}{\\partial p} = \\frac{\\langle \\boldsymbol{\\phi}^{\\ast}, \\frac{\\partial L}{\\partial p} \\boldsymbol{\\phi} \\rangle}{\\langle \\boldsymbol{\\phi}^{\\ast}, M \\boldsymbol{\\phi} \\rangle}\n$$\n问题要求的是 $k_{\\mathrm{eff}} = 1/\\lambda$ 的灵敏度。使用链式法则，$\\frac{\\partial \\lambda}{\\partial p} = -\\frac{1}{k_{\\mathrm{eff}}^2} \\frac{\\partial k_{\\mathrm{eff}}}{\\partial p}$。代入并重新整理得到所需的 $k_{\\mathrm{eff}}$ 灵敏度：\n$$\n\\frac{\\partial k_{\\mathrm{eff}}}{\\partial p} = -k_{\\mathrm{eff}}^2 \\frac{\\langle \\boldsymbol{\\phi}^{\\ast}, \\frac{\\partial L}{\\partial p} \\boldsymbol{\\phi} \\rangle}{\\langle \\boldsymbol{\\phi}^{\\ast}, M \\boldsymbol{\\phi} \\rangle}\n$$\n算子导数 $\\frac{\\partial L}{\\partial p}$ 是通过对 $L$ 的元素求导得到的。只有对角线上的吸收项依赖于 $p$：$L_{i,i}(p) = \\dots + \\Sigma_{a,i}^{\\mathrm{base}} + p \\, \\Sigma_{p,i}$。因此，$\\frac{\\partial L_{i,i}}{\\partial p} = \\Sigma_{p,i}$。导数矩阵 $\\frac{\\partial L}{\\partial p}$ 是一个对角矩阵，其对角元为 $\\Sigma_{p,i}$。内积变成求和：\n$$\n\\frac{\\partial k_{\\mathrm{eff}}}{\\partial p} = -k_{\\mathrm{eff}}^2 \\frac{\\sum_{i=0}^{N-1} \\phi^{\\ast}_i \\Sigma_{p,i} \\phi_i}{\\sum_{i=0}^{N-1} \\phi^{\\ast}_i (\\nu \\Sigma_{f,i}) \\phi_i}\n$$\n由小微扰 $\\delta p$ 引起的 $k_{\\mathrm{eff}}$ 预测变化量则为 $\\Delta k_{\\mathrm{eff}}^{\\mathrm{pred}} = \\frac{\\partial k_{\\mathrm{eff}}}{\\partial p} \\delta p$。\n\n数值实现过程如下：\n1.  对于给定的一组参数，在基准毒物密度 $p_0$ 下，构建对称的损失矩阵 $L(p_0)$ 和对角的产生矩阵 $M$。$L$ 的非对角元素由单元界面处扩散系数的调和平均值构建，并通过在外部边界处将扩散项设为零来强制施加反射边界条件。\n2.  求解广义特征值问题 $L(p_0) \\boldsymbol{\\phi}_0 = \\lambda_0 M \\boldsymbol{\\phi}_0$，得到最小特征值 $\\lambda_0$ 及其对应的特征矢量 $\\boldsymbol{\\phi}_0$。这可以通过对称矩阵的数值特征求解器完成。基准有效增殖因子为 $k_{\\mathrm{eff},0} = 1/\\lambda_0$。\n3.  由于 $L$ 和 $M$ 是对称的，伴随通量与正向通量相同，即 $\\boldsymbol{\\phi}^{\\ast}_0 = \\boldsymbol{\\phi}_0$。\n4.  使用推导出的公式、通量 $\\boldsymbol{\\phi}_0$、$\\boldsymbol{\\phi}^{\\ast}_0$ 和 $k_{\\mathrm{eff},0}$，计算在 $p_0$ 处的灵敏度 $\\frac{\\partial k_{\\mathrm{eff}}}{\\partial p}$。\n5.  计算预测的变化量 $\\Delta k_{\\mathrm{eff}}^{\\mathrm{pred}} = \\frac{\\partial k_{\\mathrm{eff}}}{\\partial p} \\delta p$。\n6.  为了验证，直接计算微扰后的状态。为 $p_1 = p_0 + \\delta p$ 构建一个新的损失矩阵 $L(p_1)$。\n7.  求解新的特征值问题 $L(p_1) \\boldsymbol{\\phi}_1 = \\lambda_1 M \\boldsymbol{\\phi}_1$，以找到微扰后的特征值 $\\lambda_1$ 和 $k_{\\mathrm{eff},1} = 1/\\lambda_1$。\n8.  直接计算的变化量是 $\\Delta k_{\\mathrm{eff}}^{\\mathrm{dir}} = k_{\\mathrm{eff},1} - k_{\\mathrm{eff},0}$。\n9.  每个用例的最终结果是绝对误差 $e = |\\Delta k_{\\mathrm{eff}}^{\\mathrm{pred}} - \\Delta k_{\\mathrm{eff}}^{\\mathrm{dir}}|$。这个误差量化了一阶近似的准确性。对于小的微扰 $\\delta p$，该误差预计会很小。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import eigh\n\ndef build_matrices(N, h, D_vec, Sigma_a_base, nu_Sigma_f, Sigma_p, p):\n    \"\"\"\n    Constructs the loss (L) and production (M) matrices for the 1D diffusion problem.\n\n    Args:\n        N (int): Number of nodes.\n        h (float): Node spacing in cm.\n        D_vec (np.ndarray): Vector of diffusion coefficients for each node in cm.\n        Sigma_a_base (np.ndarray): Vector of base absorption cross sections in cm^-1.\n        nu_Sigma_f (np.ndarray): Vector of neutron production cross sections in cm^-1.\n        Sigma_p (np.ndarray): Vector of poison absorption cross sections in cm^-1.\n        p (float): Dimensionless poison density parameter.\n\n    Returns:\n        tuple[np.ndarray, np.ndarray]: A tuple containing the L and M matrices.\n    \"\"\"\n    L = np.zeros((N, N))\n    M = np.diag(nu_Sigma_f)\n\n    # Calculate interface diffusion coefficients using harmonic mean\n    D_interface = np.zeros(N - 1)\n    for i in range(N - 1):\n        D_interface[i] = 2.0 / (1.0 / D_vec[i] + 1.0 / D_vec[i+1])\n\n    # Calculate current absorption cross sections\n    Sigma_a = Sigma_a_base + p * Sigma_p\n\n    # Populate the tridiagonal L matrix\n    # Diagonal elements\n    h2 = h * h\n    for i in range(N):\n        # Absorption term\n        L[i, i] = Sigma_a[i]\n        # Diffusion term from the right interface (i, i+1)\n        if i  N - 1:\n            L[i, i] += D_interface[i] / h2\n        # Diffusion term from the left interface (i-1, i)\n        if i > 0:\n            L[i, i] += D_interface[i-1] / h2\n\n    # Off-diagonal elements\n    for i in range(N - 1):\n        L[i, i+1] = -D_interface[i] / h2\n        L[i+1, i] = -D_interface[i] / h2\n        \n    return L, M\n\ndef solve_eigenproblem(L, M):\n    \"\"\"\n    Solves the generalized eigenvalue problem L*phi = lambda*M*phi.\n\n    Args:\n        L (np.ndarray): The loss matrix.\n        M (np.ndarray): The production matrix.\n\n    Returns:\n        tuple[float, np.ndarray]: A tuple containing the fundamental eigenvalue (lambda_0)\n                                  and the corresponding eigenvector (flux phi_0).\n    \"\"\"\n    # eigh is for symmetric/Hermitian matrices, which L and M are.\n    # It returns eigenvalues in ascending order.\n    eigenvalues, eigenvectors = eigh(L, M)\n    \n    # The fundamental mode corresponds to the smallest positive eigenvalue.\n    lambda_0 = eigenvalues[0]\n    phi_0 = eigenvectors[:, 0]\n    \n    # Normalize flux to be positive (physical convention)\n    if np.sum(phi_0)  0:\n        phi_0 *= -1.0\n        \n    return lambda_0, phi_0\n\ndef solve():\n    \"\"\"\n    Main function to execute the problem for all test cases.\n    \"\"\"\n    test_cases = [\n        # Case 1\n        {\n            \"N\": 12, \"h\": 15.0,\n            \"D_func\": lambda N: np.full(N, 1.2),\n            \"Sigma_a_base_func\": lambda N: np.full(N, 0.006),\n            \"nu_Sigma_f_func\": lambda N: np.full(N, 0.045),\n            \"Sigma_p_func\": lambda N: np.array([0.020 if i in {5, 6} else 0.0 for i in range(N)]),\n            \"p0\": 0.8, \"delta_p\": 0.01\n        },\n        # Case 2\n        {\n            \"N\": 8, \"h\": 20.0,\n            \"D_func\": lambda N: np.full(N, 1.4),\n            \"Sigma_a_base_func\": lambda N: np.full(N, 0.006),\n            \"nu_Sigma_f_func\": lambda N: np.full(N, 0.050),\n            \"Sigma_p_func\": lambda N: np.zeros(N),\n            \"p0\": 1.0, \"delta_p\": 0.05\n        },\n        # Case 3\n        {\n            \"N\": 10, \"h\": 12.0,\n            \"D_func\": lambda N: 1.0 + 0.6 * np.arange(N) / (N - 1),\n            \"Sigma_a_base_func\": lambda N: np.full(N, 0.005),\n            \"nu_Sigma_f_func\": lambda N: np.full(N, 0.040),\n            \"Sigma_p_func\": lambda N: np.array([0.030 if i in {0, 9} else 0.0 for i in range(N)]),\n            \"p0\": 0.5, \"delta_p\": -0.02\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        N = case[\"N\"]\n        h = case[\"h\"]\n        p0 = case[\"p0\"]\n        delta_p = case[\"delta_p\"]\n        p1 = p0 + delta_p\n\n        # Generate material properties\n        D_vec = case[\"D_func\"](N)\n        Sigma_a_base = case[\"Sigma_a_base_func\"](N)\n        nu_Sigma_f = case[\"nu_Sigma_f_func\"](N)\n        Sigma_p = case[\"Sigma_p_func\"](N)\n\n        # 1. Baseline Calculation (at p0)\n        L0, M = build_matrices(N, h, D_vec, Sigma_a_base, nu_Sigma_f, Sigma_p, p0)\n        lambda0, phi0 = solve_eigenproblem(L0, M)\n        k_eff0 = 1.0 / lambda0\n        \n        # In this problem, L and M are symmetric, so phi* = phi\n        phi_star0 = phi0\n\n        # 2. Sensitivity Calculation\n        # dL/dp is a diagonal matrix with Sigma_p on the diagonal\n        dL_dp_matrix = np.diag(Sigma_p)\n        \n        numerator = phi_star0.T @ dL_dp_matrix @ phi0\n        denominator = phi_star0.T @ M @ phi0\n        \n        # Avoid division by zero if there's no fission\n        if np.isclose(denominator, 0.0):\n            dk_eff_dp = 0.0\n        else:\n            dk_eff_dp = -k_eff0**2 * (numerator / denominator)\n\n        delta_k_eff_pred = dk_eff_dp * delta_p\n\n        # 3. Direct Calculation (at p1 = p0 + delta_p)\n        L1, _ = build_matrices(N, h, D_vec, Sigma_a_base, nu_Sigma_f, Sigma_p, p1)\n        lambda1, _ = solve_eigenproblem(L1, M)\n        k_eff1 = 1.0 / lambda1\n        \n        delta_k_eff_dir = k_eff1 - k_eff0\n\n        # 4. Compute Absolute Error\n        error = abs(delta_k_eff_pred - delta_k_eff_dir)\n        results.append(error)\n\n    # Format and print the final output\n    print(f\"[{','.join(f'{r:.12e}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}