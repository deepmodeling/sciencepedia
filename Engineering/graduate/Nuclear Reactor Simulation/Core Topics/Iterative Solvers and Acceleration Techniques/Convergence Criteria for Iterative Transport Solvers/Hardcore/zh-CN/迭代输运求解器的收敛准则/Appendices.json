{
    "hands_on_practices": [
        {
            "introduction": "迭代求解器的收敛速度直接由其迭代算子的谱半径 $q$ 决定。本练习将这个抽象的数学属性转化为一个具体的预测：要达到期望的精度，需要多少次迭代。通过完成这个练习 ，您将掌握估算计算成本和理解为何某些物理问题（例如高散射问题）收敛缓慢的基础。",
            "id": "4218825",
            "problem": "在单能、稳态、各向同性散射的均匀平板中子输运问题中，考虑应用于离散纵标法（SN）的标准不动点源迭代（SI）方法。设线性迭代用误差更新 $e^{(k+1)} = \\mathcal{M} e^{(k)}$ 来表示，其中 $\\mathcal{M}$ 是迭代算子，$e^{(k)}$ 是第 k 次迭代时相对于不动点的误差。假设一个与 $\\mathcal{M}$ 的谱性质相容的矩阵范数，并定义谱半径 $\\rho(\\mathcal{M}) = q$，其中 $0  q  1$，因此误差的范数（以及在相容范数下的残差）每次迭代最多收缩一个因子 $q$。对残差范数 $\\|r^{(n)}\\|$ 施加一个收敛判据，要求 $\\|r^{(n)}\\| \\le \\theta \\|r^{(0)}\\|$，其中 $0  \\theta  1$ 是一个目标缩减因子。\n\n仅从谱半径的定义和相容矩阵范数的次乘性质出发，推导为实现 $\\|r^{(n)}\\| \\le \\theta \\|r^{(0)}\\|$ 所需的最小整数迭代次数 $n$ 的表达式，该表达式用 $\\theta$ 和 $q$ 表示。然后，通过取散射比 $c = 0.95$ 并使用标准SI结论 $q \\approx c$，来解释此结果对于高散射介质的意义。计算保证残差缩减因子达到 $\\theta = 1.0 \\times 10^{-8}$ 的最小 $n$ 值。\n\n将最终答案表示为一个无单位的整数。除了整数要求外，不需要其他取整说明；报告满足该判据的最小整数 $n$。",
            "solution": "首先验证问题以确保其具有科学依据、是适定的，并且提供了所有必要信息。该问题描述了求解中子输运方程的标准源迭代（SI）方法，利用了迭代算子、谱半径和收敛判据等既定概念。所提供的参数在物理上是现实的，问题在数学上是明确的。该问题被认为是有效的。\n\n问题的核心是确定满足给定收敛判据所需的最小迭代次数 $n$。误差的迭代过程由 $e^{(k+1)} = \\mathcal{M} e^{(k)}$ 给出，其中 $\\mathcal{M}$ 是迭代算子。该算子的谱半径为 $\\rho(\\mathcal{M}) = q$。问题指出，对于一个相容范数，残差范数每次迭代最多收缩一个因子 $q$。我们可以将此关系表示为一个不等式：\n$$\n\\|r^{(k+1)}\\| \\le q \\|r^{(k)}\\|\n$$\n其中 $r^{(k)}$ 是第 $k$ 次迭代的残差。我们可以从初始残差 $r^{(0)}$ 开始递归地应用这个不等式：\n对于迭代 $k=1$：\n$$\n\\|r^{(1)}\\| \\le q \\|r^{(0)}\\|\n$$\n对于迭代 $k=2$：\n$$\n\\|r^{(2)}\\| \\le q \\|r^{(1)}\\| \\le q (q \\|r^{(0)}\\|) = q^2 \\|r^{(0)}\\|\n$$\n通过归纳法，对于任意迭代次数 $n$，残差范数的界为：\n$$\n\\|r^{(n)}\\| \\le q^n \\|r^{(0)}\\|\n$$\n这个不等式提供了 $n$ 次迭代后残差范数的最坏情况下的界。\n\n指定的收敛判据是 $\\|r^{(n)}\\| \\le \\theta \\|r^{(0)}\\|$，对于给定的缩减因子 $\\theta$，其中 $0  \\theta  1$。为保证满足此判据，我们要求我们推导的不等式的上界小于或等于目标值：\n$$\nq^n \\|r^{(0)}\\| \\le \\theta \\|r^{(0)}\\|\n$$\n假设初始残差非零，即 $\\|r^{(0)}\\| > 0$，我们可以在不等式两边同除以 $\\|r^{(0)}\\|$ 而不改变不等式方向：\n$$\nq^n \\le \\theta\n$$\n为了求解 $n$，我们对两边取自然对数。由于 $q$ 和 $\\theta$ 都是介于 $0$ 和 $1$ 之间的正数，它们的对数都是负数。\n$$\n\\ln(q^n) \\le \\ln(\\theta)\n$$\n使用对数的性质 $\\ln(a^b) = b \\ln(a)$，我们得到：\n$$\nn \\ln(q) \\le \\ln(\\theta)\n$$\n为了解出 $n$，我们必须除以 $\\ln(q)$。由于 $0  q  1$，$\\ln(q)$ 是一个负数。不等式两边同除以一个负数会反转不等号的方向：\n$$\nn \\ge \\frac{\\ln(\\theta)}{\\ln(q)}\n$$\n这就是推导出的迭代次数 $n$ 的表达式。问题要求的是所需的*最小整数*迭代次数。这对应于大于或等于右侧值的最小整数，也就是上取整函数的定义。\n$$\nn = \\left\\lceil \\frac{\\ln(\\theta)}{\\ln(q)} \\right\\rceil\n$$\n对于解释部分，我们考虑一个散射比 $c$ 接近于 $1$ 的高散射介质。问题使用了标准结论，即对于光学厚介质中的源迭代，谱半径 $q$ 近似等于散射比，即 $q \\approx c$。当 $c \\to 1$ 时，$q$ 也趋近于 $1$。因此，$\\ln(q)$ 从负方向趋近于 $0$。对于给定的容差，$\\ln(\\theta)$ 是一个固定的负数。因此，比率 $\\frac{\\ln(\\theta)}{\\ln(q)}$ 变成一个很大的正数。这表明收敛需要非常大的迭代次数 $n$，这是源迭代方法在高散射、低吸收物理系统中收敛缓慢的数学表现。\n\n最后，我们根据给定值计算最小整数 $n$：\n散射比 $c = 0.95$，这意味着 $q \\approx 0.95$。\n目标残差缩减因子 $\\theta = 1.0 \\times 10^{-8}$。\n\n我们将这些值代入我们推导的表达式中：\n$$\nn \\ge \\frac{\\ln(1.0 \\times 10^{-8})}{\\ln(0.95)}\n$$\n计算对数值：\n$$\n\\ln(1.0 \\times 10^{-8}) \\approx -18.420680744\n$$\n$$\n\\ln(0.95) \\approx -0.05129329438\n$$\n现在，我们进行除法运算：\n$$\nn \\ge \\frac{-18.420680744}{-0.05129329438} \\approx 359.13548...\n$$\n由于 $n$ 必须是整数，我们对此结果取上取整，以找到保证满足该判据的最小迭代次数：\n$$\nn = \\lceil 359.13548... \\rceil = 360\n$$\n因此，至少需要 $360$ 次迭代。",
            "answer": "$$\\boxed{360}$$"
        },
        {
            "introduction": "在理解了收敛速度之后，一个关键问题是：“收敛”的解对于我们希望计算的物理量意味着什么？本练习  旨在连接输运方程的数学残差与一个重要物理量（如吸收反应率）的精度。它通过一个精心设计的思想实验，揭示了确保收敛判据能真实反映您所关心的物理量的精度是何等重要。",
            "id": "4218841",
            "problem": "给定一个基于一维平板中具有各向同性散射的稳态单能中子输运的基准问题。离散的栅元中子平衡表示为产生等于损失。在线性化菱形差分类似的离散化下，每个栅元上的平衡可以表示为关于栅元平均标量通量向量 $\\phi \\in \\mathbb{R}^N$ 的线性系统，\n$$\nA \\phi = q,\n$$\n其中 $A \\in \\mathbb{R}^{N \\times N}$ 是输运-损失算子，$q \\in \\mathbb{R}^N$ 是外源向量。矩阵 $A$ 结合了吸收、散射移除和一个对称三对角泄漏算子。具体来说，设 $N$ 为空间栅元数，栅元宽度 $h$ 均匀，单位为厘米，吸收截面 $\\Sigma_a$ 的单位为厘米的倒数，散射截面 $\\Sigma_s$ 的单位为厘米的倒数，类扩散泄漏系数 $D$ 的单位为厘米。定义泄漏矩阵 $L \\in \\mathbb{R}^{N \\times N}$ 如下\n$$\nL_{i,i} = \\begin{cases}\n\\frac{D}{h^2},  i = 0 \\ \\text{or} \\ i = N - 1, \\\\\n\\frac{2D}{h^2},  \\text{otherwise},\n\\end{cases}\n\\quad\nL_{i,i+1} = L_{i+1,i} = -\\frac{D}{h^2} \\ \\text{for} \\ 0 \\le i \\le N-2,\n\\quad\nL_{i,j} = 0 \\ \\text{otherwise},\n$$\n并定义\n$$\nA = L + \\operatorname{diag}(\\Sigma_a \\mathbf{1}) - \\operatorname{diag}(\\Sigma_s \\mathbf{1}),\n$$\n其中 $\\mathbf{1} \\in \\mathbb{R}^N$ 是全一向量。精确标量通量 $\\phi^\\star$ 是 $A \\phi^\\star = q$ 的解。对于一个近似通量 $\\phi$，其栅元平衡残差向量定义为\n$$\nr(\\phi) = q - A \\phi,\n$$\n该向量衡量了每个栅元中源与损失之间的净不平衡。\n\n考虑吸收反应率向量 $R(\\phi) = \\Sigma_a \\phi$，并定义相对吸收反应率误差为无量纲量\n$$\n\\varepsilon_R(\\phi) = \\frac{\\| R(\\phi) - R(\\phi^\\star) \\|_2}{\\| R(\\phi^\\star) \\|_2}.\n$$\n您将使用形式为 $\\phi_\\alpha = \\alpha \\, \\phi^\\star$ 的近似通量（对于给定的 $\\alpha \\in \\mathbb{R}$），当标量通量的尺度被低估或高估时，这可以代表来自迭代输运求解器的中间迭代结果。\n\n您的任务是，对于每个测试用例，计算栅元平衡残差范数 $\\| r(\\phi_\\alpha) \\|_2$，将其与残差容差 $\\tau$ 进行比较，然后评估满足残差容差是否意味着吸收反应率误差低于期望的分数。对于给定的 $\\alpha$，定义容差\n$$\n\\tau = c \\, \\| q \\|_2,\n$$\n其中 $c > 0$，以及期望误差分数 $\\delta > 0$（表示为小数，而非百分号）。\n\n对于此基准问题，使用以下物理上合理且自洽的参数：\n- 栅元数 $N = 10$，\n- 栅元宽度 $h = 1$ 厘米，\n- 吸收截面 $\\Sigma_a = 0.10$ 厘米的倒数，\n- 散射截面 $\\Sigma_s = 0.08$ 厘米的倒数，\n- 泄漏系数 $D = 0.50$ 厘米，\n- 外源向量 $q$ 是均匀的，对于 $i = 0, 1, \\dots, N-1$，$q_i = 1.0$。\n\n对于每个测试用例 $(\\alpha, c, \\delta)$，构造 $\\phi_\\alpha = \\alpha \\phi^\\star$，计算残差 $r(\\phi_\\alpha)$ 及其二范数 $\\| r(\\phi_\\alpha) \\|_2$，以及相对吸收反应率误差 $\\varepsilon_R(\\phi_\\alpha)$。然后确定以下蕴含关系的布尔值\n$$\n\\| r(\\phi_\\alpha) \\|_2 \\le \\tau \\ \\Rightarrow \\ \\varepsilon_R(\\phi_\\alpha) \\le \\delta.\n$$\n如果蕴含关系成立，则返回 True，否则返回 False。请注意，如果 $\\| r(\\phi_\\alpha) \\|_2 > \\tau$，则该蕴含关系虚真。\n\n测试套件：\n使用以下四个测试用例，它们涵盖了蕴含逻辑的不同方面，包括一般情况、边界情况、容差不够严格的情况以及虚真情况：\n1. $(\\alpha, c, \\delta) = (0.99, 0.012, 0.015)$,\n2. $(\\alpha, c, \\delta) = (0.97, 0.030, 0.030)$,\n3. $(\\alpha, c, \\delta) = (0.95, 0.051, 0.040)$,\n4. $(\\alpha, c, \\delta) = (0.80, 0.150, 0.020)$.\n\n最终输出格式：\n您的程序应生成一行输出，其中包含四个测试用例的布尔结果值，格式为用方括号括起来的逗号分隔列表（例如，“[True,False,True,True]”）。",
            "solution": "我们从对方向和体积积分得到的稳态单能中子输运方程开始，从而得出每个栅元的离散平衡，即产生等于损失。在适用于迭代输运求解器的线性离散化中，未知标量通量向量 $\\phi$ 满足线性系统\n$$\nA \\phi = q,\n$$\n其中 $A$ 结合了流/泄漏、吸收和散射移除。使用所述的 $D$ 和 $h$ 构建的泄漏矩阵 $L$ 引起相邻栅元之间的耦合，并导致损失；对角项 $\\Sigma_a$ 和 $\\Sigma_s$ 代表材料相互作用。精确解 $\\phi^\\star$ 满足 $A \\phi^\\star = q$。对于任何近似通量 $\\phi$，残差向量\n$$\nr(\\phi) = q - A \\phi\n$$\n是栅元平衡残差：它衡量了产生项（当散射项移至 $A$ 的左侧时，隐式包含了 $q + \\Sigma_s \\phi$）与损失项（$ \\Sigma_a \\phi + L \\phi$）之间的差异，这里通过线性系统残差紧凑地表示。\n\n反应率是标量通量的线性泛函。吸收反应率向量是\n$$\nR(\\phi) = \\Sigma_a \\phi,\n$$\n相对吸收反应率误差是\n$$\n\\varepsilon_R(\\phi) = \\frac{\\| R(\\phi) - R(\\phi^\\star) \\|_2}{\\| R(\\phi^\\star) \\|_2}.\n$$\n为了分析残差容差如何控制反应率误差，考虑误差 $e = \\phi - \\phi^\\star$。代入残差定义，\n$$\nr(\\phi) = q - A \\phi = A \\phi^\\star - A \\phi = -A (\\phi - \\phi^\\star) = -A e.\n$$\n因此，\n$$\ne = -A^{-1} r(\\phi).\n$$\n应用吸收反应率算子可得\n$$\nR(\\phi) - R(\\phi^\\star) = \\Sigma_a (\\phi - \\phi^\\star) = -\\Sigma_a A^{-1} r(\\phi).\n$$\n取二范数并使用次乘性可得出界\n$$\n\\| R(\\phi) - R(\\phi^\\star) \\|_2 \\le \\| \\Sigma_a A^{-1} \\|_2 \\, \\| r(\\phi) \\|_2.\n$$\n除以 $\\| R(\\phi^\\star) \\|_2$ 可得\n$$\n\\varepsilon_R(\\phi) \\le \\frac{\\| \\Sigma_a A^{-1} \\|_2}{\\| R(\\phi^\\star) \\|_2} \\, \\| r(\\phi) \\|_2.\n$$\n因此，保证 $\\varepsilon_R(\\phi) \\le \\delta$ 的一个充分条件是\n$$\n\\| r(\\phi) \\|_2 \\le \\tau_\\text{suff} \\equiv \\delta \\, \\frac{\\| R(\\phi^\\star) \\|_2}{\\| \\Sigma_a A^{-1} \\|_2}.\n$$\n这从第一性原理上展示了残差容差如何通过算子范数来控制反应率误差。\n\n对于标量 $\\alpha$ 的特定测试构造 $\\phi_\\alpha = \\alpha \\phi^\\star$，代入残差：\n$$\nr(\\phi_\\alpha) = q - A (\\alpha \\phi^\\star) = q - \\alpha A \\phi^\\star = q - \\alpha q = (1 - \\alpha) q.\n$$\n因此，\n$$\n\\| r(\\phi_\\alpha) \\|_2 = |1 - \\alpha| \\, \\| q \\|_2.\n$$\n反应率误差变为\n$$\nR(\\phi_\\alpha) - R(\\phi^\\star) = \\Sigma_a (\\alpha \\phi^\\star - \\phi^\\star) = (\\alpha - 1) \\Sigma_a \\phi^\\star,\n$$\n所以\n$$\n\\varepsilon_R(\\phi_\\alpha) = \\frac{\\| (\\alpha - 1) \\Sigma_a \\phi^\\star \\|_2}{\\| \\Sigma_a \\phi^\\star \\|_2} = | \\alpha - 1 |.\n$$\n这个精确关系表明，在此构造中，满足残差容差 $\\| r(\\phi_\\alpha) \\|_2 \\le \\tau$ 蕴含 $\\varepsilon_R(\\phi_\\alpha) \\le \\delta$，当且仅当\n$$\n|1 - \\alpha| \\, \\| q \\|_2 \\le \\tau \\quad \\text{and} \\quad |1 - \\alpha| \\le \\delta.\n$$\n如果设 $\\tau = c \\, \\| q \\|_2$，那么只要 $|1 - \\alpha| \\le c$，$ \\| r(\\phi_\\alpha) \\|_2 \\le \\tau$ 就成立。因此，对于这类近似通量，选择 $c \\ge |1 - \\alpha|$ 可确保满足残差标准，选择 $\\delta \\ge |1 - \\alpha|$ 可确保满足反应率误差标准。当两者同时满足时，蕴含关系 $\\| r(\\phi_\\alpha) \\|_2 \\le \\tau \\Rightarrow \\varepsilon_R(\\phi_\\alpha) \\le \\delta$ 成立。如果 $\\| r(\\phi_\\alpha) \\|_2 > \\tau$，则无论 $\\delta$ 取何值，该蕴含关系都虚真。\n\n算法设计：\n1. 根据指定的 $D$ 和 $h$ 构造 $L$，然后组装 $A = L + \\operatorname{diag}(\\Sigma_a \\mathbf{1}) - \\operatorname{diag}(\\Sigma_s \\mathbf{1})$。\n2. 将 $q$ 构造成一个均匀的全一向量，使用鲁棒的线性求解器求解 $A \\phi^\\star = q$ 得到 $\\phi^\\star$。\n3. 对于每个测试用例 $(\\alpha, c, \\delta)$，计算 $\\phi_\\alpha = \\alpha \\phi^\\star$、残差 $r(\\phi_\\alpha) = q - A \\phi_\\alpha$ 及其二范数 $\\| r(\\phi_\\alpha) \\|_2$。计算 $\\tau = c \\, \\| q \\|_2$。\n4. 计算 $\\varepsilon_R(\\phi_\\alpha) = \\| \\Sigma_a (\\phi_\\alpha - \\phi^\\star) \\|_2 / \\| \\Sigma_a \\phi^\\star \\|_2$。\n5. 评估蕴含关系：如果 $\\| r(\\phi_\\alpha) \\|_2 \\le \\tau$ 蕴含 $\\varepsilon_R(\\phi_\\alpha) \\le \\delta$，则返回 True，否则返回 False。如果 $\\| r(\\phi_\\alpha) \\|_2 > \\tau$，则返回 True，因为蕴含关系虚真。\n6. 将所有测试用例的布尔结果汇总成指定输出格式的单个列表。\n\n测试套件覆盖范围：\n- 一个一般情况，其中容差和期望分数超过了实际由残差导出的尺度，结果为 True。\n- 一个边界情况，其中两个标准都恰好满足，结果为 True。\n- 一个残差容差已满足但期望分数过于严格的情况，结果为 False。\n- 一个虚真情况，其中残差容差未满足，结果为 True。\n\n这种有原则的方法与迭代输运求解器中的收敛准则一致：残差范数提供了一个实用的停止条件，而通过基于算子的估计来界定反应率误差则提供了理论保证。特定的缩放通量测试提供了精确的关系，具体地展示了蕴含关系的行为。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef build_leakage_matrix(N, D, h):\n    \"\"\"\n    Build the symmetric tridiagonal leakage matrix L of size N x N:\n    L_{i,i} = D/h^2 for boundaries, 2D/h^2 for interior,\n    L_{i,i+1} = L_{i+1,i} = -D/h^2.\n    \"\"\"\n    L = np.zeros((N, N), dtype=float)\n    coef = D / (h**2)\n    for i in range(N):\n        if i == 0 or i == N - 1:\n            L[i, i] = coef\n        else:\n            L[i, i] = 2.0 * coef\n        if i  N - 1:\n            L[i, i + 1] = -coef\n            L[i + 1, i] = -coef\n    return L\n\ndef solve_benchmark_and_check():\n    # Benchmark parameters\n    N = 10       # number of cells\n    h = 1.0      # cm\n    Sigma_a = 0.10  # 1/cm\n    Sigma_s = 0.08  # 1/cm\n    D = 0.50        # cm\n\n    # Build A = L + diag(Sigma_a) - diag(Sigma_s)\n    L = build_leakage_matrix(N, D, h)\n    A = L + np.diag(np.full(N, Sigma_a)) - np.diag(np.full(N, Sigma_s))\n\n    # External source vector q (uniform ones)\n    q = np.ones(N, dtype=float)\n\n    # Solve for exact flux phi_star\n    phi_star = np.linalg.solve(A, q)\n\n    # Precompute norms used in tolerances and errors\n    q_norm = np.linalg.norm(q, 2)\n    R_star = Sigma_a * phi_star\n    R_star_norm = np.linalg.norm(R_star, 2)\n\n    # Test cases: (alpha, c, delta)\n    test_cases = [\n        (0.99, 0.012, 0.015),  # Happy path: residual within tau and error within delta\n        (0.97, 0.030, 0.030),  # Boundary: equality case\n        (0.95, 0.051, 0.040),  # Residual within tau but error above desired fraction\n        (0.80, 0.150, 0.020),  # Vacuous true: residual exceeds tau\n    ]\n\n    results = []\n    for alpha, c, delta in test_cases:\n        # Construct approximate flux\n        phi_alpha = alpha * phi_star\n\n        # Compute residual and its norm\n        r = q - A @ phi_alpha\n        r_norm = np.linalg.norm(r, 2)\n\n        # Residual tolerance\n        tau = c * q_norm\n\n        # Compute relative absorption reaction-rate error\n        R_err = Sigma_a * (phi_alpha - phi_star)\n        R_err_norm = np.linalg.norm(R_err, 2)\n        epsilon_R = R_err_norm / R_star_norm if R_star_norm != 0.0 else 0.0\n\n        # Implication: if residual = tau then epsilon_R = delta\n        if r_norm = tau:\n            results.append(epsilon_R = delta)\n        else:\n            # Implication is vacuously true when premise is false\n            results.append(True)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef solve():\n    solve_benchmark_and_check()\n\nsolve()\n```"
        },
        {
            "introduction": "标准的收敛判据有时会产生误导，尤其是在复杂的输运问题中，解的不同部分可能以不同的速率收敛。本练习  通过一个简化模型，演示了一个常见陷阱：当解的整体幅度稳定而其空间形状仍在演变时，迭代可能会被过早地判断为收敛。它引入了一个基于香农熵的更复杂的判据，提供了一个强有力的工具来确保解的形状也达到真正的收敛。",
            "id": "4218894",
            "problem": "考虑一个增殖介质中的稳态中子输运问题，其平衡方程可以算符形式写成一个特征值问题。中子通量形状由一个线性输运-裂变算符的主特征向量决定，许多迭代求解器旨在寻找一个线性映射的不动点，该映射近似了离散相空间中的散射、流输和裂变平衡。设离散迭代的每一步由一个作用于非负通量向量的线性算符表示。当存在多个近简并模时，最大和次大特征值之间的谱隙很小，这会减慢次要形状分量的衰减，并可能导致尽管源的幅度迅速稳定，形状收敛却很慢。\n\n以此为基础，将离散输运求解器的迭代过程建模为一个行随机的分块结构算符。将大小为 $N$ 的状态空间划分为两个大小为 $m=N/2$ 的相等区块。定义一个行随机转移矩阵 $P \\in \\mathbb{R}^{N \\times N}$ 如下\n$$\nP_{ij} = \n\\begin{cases}\n\\frac{1-\\delta}{m},  \\text{如果 } i \\text{ 和 } j \\text{ 在同一区块},\\\\\n\\frac{\\delta}{m},  \\text{如果 } i \\text{ 和 } j \\text{ 在不同区块},\n\\end{cases}\n$$\n其中耦合参数 $\\delta \\in (0,1/2)$。最大特征值为 $1$，次大特征值为 $1-2\\delta$，当 $\\delta$ 很小时，它与 $1$ 近简并。将归一化通量分布的迭代解释为列向量更新\n$$\n\\phi_{n+1} = P^{\\top} \\phi_n,\n$$\n其中 $\\phi_n \\in \\mathbb{R}^N$，$\\phi_n \\ge 0$，且对所有 $n$ 都有 $\\sum_{i=1}^N \\phi_n(i) = 1$。\n\n实现两个终止准则：\n- 相对残差 (RR)：在满足以下条件的最小迭代指数 $n \\ge 1$ 处终止\n$$\nr_n = \\left\\| \\phi_{n+1} - \\phi_n \\right\\|_2 \\le \\varepsilon_R,\n$$\n其中 $r_n$ 是无量纲的，$\\varepsilon_R > 0$ 是用户指定的。\n- 熵变 (EC) 增强准则：在满足 $r_n \\le \\varepsilon_R$ 并且同时 Shannon 熵变幅值满足以下条件的最小迭代指数 $n \\ge 1$ 处终止\n$$\n\\Delta H_n = \\left| \\left( -\\sum_{i=1}^N \\phi_{n+1}(i) \\log \\phi_{n+1}(i) \\right) - \\left( -\\sum_{i=1}^N \\phi_n(i) \\log \\phi_n(i) \\right) \\right| \\le \\varepsilon_H,\n$$\n其中 $\\varepsilon_H > 0$ 是用户指定的，并使用自然对数。Shannon 熵 (SE) $H(\\phi) = -\\sum_{i=1}^N \\phi(i) \\log \\phi(i)$ 独立于幅度监控通量形状的变化，并且是无量纲的。\n\n构建一个测试用例，其中多个近简并模减慢了收敛速度（小 $\\delta$），并证明熵监控通过持续迭代直到通量形状稳定，从而防止了在 RR 准则下的过早终止。设计并实现一个完整的程序，该程序：\n1. 为给定的 $N$ 和 $\\delta$ 构建 $P$。\n2. 以指定方式（例如，集中在一个区块或在所有状态上均匀分布）初始化 $\\phi_0$，并将其归一化以使 $\\sum_i \\phi_0(i) = 1$。\n3. 迭代 $\\phi_{n+1} = P^{\\top} \\phi_n$，计算 $r_n$ 和 $\\Delta H_n$，并记录满足 RR 的第一个 $n$ 和满足 EC 增强终止条件的第一个 $n$。\n4. 对于每个测试用例，报告 RR 和 EC 增强准则的迭代次数，以及一个布尔标志，指示 RR 是否过早终止（定义为 RR 的终止严格早于 EC 增强准则）。\n\n此问题中不需要物理单位，因为所有量都是无量纲的概率和信息度量。不涉及角度。\n\n使用以下测试套件，它涵盖了不同的情况：\n- 测试 A（模式良好分离，理想路径）：$N=12$，$\\delta=0.05$，$\\varepsilon_R=1\\times 10^{-6}$，$\\varepsilon_H=1\\times 10^{-6}$，$\\phi_0$ 在第一个区块上均匀分布（前 $m$ 个位置的条目等于 $1/m$，其余为零）。\n- 测试 B（近简并模，形状收敛缓慢）：$N=12$，$\\delta=0.001$，$\\varepsilon_R=1\\times 10^{-3}$，$\\varepsilon_H=2\\times 10^{-4}$，$\\phi_0$ 在第一个区块上均匀分布。\n- 测试 C（边界情况，稳态初始分布）：$N=12$，$\\delta=0.005$，$\\varepsilon_R=1\\times 10^{-4}$，$\\varepsilon_H=1\\times 10^{-4}$，$\\phi_0$ 在所有状态上均匀分布（条目等于 $1/N$）。\n\n您的程序应生成单行输出，其中包含所有测试的结果，形式为用方括号括起来的逗号分隔列表。每个测试结果本身必须是一个包含三个元素的列表 $\\left[\\text{RR\\_iters}, \\text{EC\\_iters}, \\text{premature}\\right]$，其中 $\\text{RR\\_iters}$ 和 $\\text{EC\\_iters}$ 分别是 RR 和 EC 增强准则下达到终止的迭代次数的整数，而 $\\text{premature}$ 是一个布尔值，指示 RR 是否比 EC 增强准则更早终止。例如，输出应如下所示\n$$\n\\left[ [a_1,b_1,c_1],[a_2,b_2,c_2],[a_3,b_3,c_3] \\right],\n$$\n其中对于测试 A、B 和 C，$a_i$、$b_i$ 是整数，$c_i$ 是布尔值。",
            "solution": "该问题是有效的。它提出了一个数学上合理且适定的迭代过程模型，该模型类似于数值中子输运中的迭代过程。所有参数、条件和目标都已明确定义，并且其前提与线性代数和数值分析的既定原则一致。\n\n此问题的核心是分析和比较一个线性迭代方案的两种不同终止准则，尤其是在模拟核反应堆模拟中通量形状缓慢收敛的场景下。该迭代由线性更新规则 $\\phi_{n+1} = P^{\\top} \\phi_n$ 描述，它模拟了大小为 $N$ 的状态空间上离散化中子通量分布 $\\phi_n$ 的演化。\n\n算符 $P$ 是一个 $N \\times N$ 的行随机矩阵，表示状态之间的转移。其结构是分块的，状态空间被划分为两个大小为 $m=N/2$ 的相等区块。转移概率定义为：\n$$\nP_{ij} = \n\\begin{cases}\n\\frac{1-\\delta}{m},  \\text{如果状态 } i \\text{ 和 } j \\text{ 在同一区块},\\\\\n\\frac{\\delta}{m},  \\text{如果状态 } i \\text{ 和 } j \\text{ 在不同区块}。\n\\end{cases}\n$$\n参数 $\\delta \\in (0, 1/2)$ 控制了两个区块之间的耦合程度。由于 $P$ 是对称的，迭代等价于 $\\phi_{n+1} = P \\phi_n$。由于 $P$ 是随机矩阵，$\\phi_n$ 作为概率分布的性质（非负项且总和为 1）在此迭代中得以保持。\n\n迭代的收敛速率由 $P$ 的特征谱决定。作为一个行随机矩阵，其最大特征值为 $\\lambda_1 = 1$，对应的特征向量是均匀分布 $\\phi_{final}(i) = 1/N$，即稳态。次大特征值为 $\\lambda_2 = 1-2\\delta$。谱隙 $\\lambda_1-\\lambda_2 = 2\\delta$ 决定了次要模的衰减速率。当 $\\delta$ 很小时，谱隙很小，$\\lambda_2$ 接近 $1$，系统表现出近简并模，导致分布 $\\phi_n$ 的形状向最终均匀形状的收敛非常缓慢。\n\n提出了两种终止准则来评估收敛性：\n\n$1$. **相对残差 (RR) 准则**：该准则监控两次迭代之间解向量的变化。当残差的 $L_2$-范数在首次迭代 $n \\ge 1$ 时低于阈值 $\\varepsilon_R$ 时，触发终止：\n$$\nr_n = \\left\\| \\phi_{n+1} - \\phi_n \\right\\|_2 \\le \\varepsilon_R\n$$\n这个准则简单常用，但可能具有误导性。在谱隙较小的问题中，变化的幅度 $r_n$ 可能会变得非常小，而解的形状仍远未达到其收敛形式。\n\n$2$. **熵变 (EC) 增强准则**：该准则通过对分布的信息论性质变化的条件来补充 RR 检查。它要求在首次迭代 $n \\ge 1$ 时，同时满足 RR 条件和 Shannon-Jaynes 熵变幅值低于阈值 $\\varepsilon_H$ 时终止：\n$$\nr_n \\le \\varepsilon_R \\quad \\text{且} \\quad \\left| \\Delta H_n \\right| \\le \\varepsilon_H\n$$\nShannon 熵定义为 $H(\\phi) = -\\sum_{i=1}^N \\phi(i) \\ln \\phi(i)$，其中如果 $\\phi(i)=0$，则该项取为 $0$。变化量为 $\\Delta H_n = H(\\phi_{n+1}) - H(\\phi_n)$。熵是衡量概率分布“扩展”或“无序”程度的全局性度量。一个稳定的、收敛的形状意味着熵变为零。通过监控 $\\Delta H_n$，此准则对分布形状的缓慢收敛更为敏感，从而防止过早终止。\n\n算法实现过程如下：\n$1$. 对每个由 $N$、$\\delta$、$\\varepsilon_R$、$\\varepsilon_H$ 和初始分布 $\\phi_0$ 指定的测试用例，构建转移矩阵 $P$。\n$2$. 创建并归一化初始通量向量 $\\phi_0$。\n$3$. 启动一个迭代循环。对于每次迭代 $n=1, 2, \\dots$，根据 $\\phi_{n-1}$ 计算下一个状态 $\\phi_n$。\n$4$. 计算度量 $r_{n-1} = \\|\\phi_n - \\phi_{n-1}\\|_2$ 和 $\\Delta H_{n-1} = |H(\\phi_n) - H(\\phi_{n-1})|$。请注意，问题要求基于从 $\\phi_n$ 和 $\\phi_{n+1}$ 计算的度量找到最小索引 $n \\ge 1$，因此我们将相应地跟踪迭代索引。\n$5$. 对于每次迭代 $n$，我们检查是否 $r_n \\le \\varepsilon_R$。如果这是第一次满足此条件，我们将 $n$ 记录为 RR 的终止迭代次数。\n$6$. 我们还检查是否同时满足 $r_n \\le \\varepsilon_R$ 和 $|\\Delta H_n| \\le \\varepsilon_H$。如果这是第一次满足此组合条件，我们将 $n$ 记录为 EC 增强准则的终止迭代次数。\n$7$. 循环继续，直到找到两种准则的终止计数或达到最大迭代限制。\n$8$. 最后，如果 RR 准则在比 EC 准则严格更小的迭代次数时终止，则将一个布尔标志设置为 `True`，表示过早终止。\n\n此过程应用于三个旨在探究不同收敛机制的测试用例：\n- **测试 A：** 一个良好分离的案例（较大的 $\\delta$），预计两种准则会产生相似的结果。\n- **测试 B：** 一个近简并的案例（较小的 $\\delta$），预计 RR 会过早终止。\n- **测试 C：** 一个边界案例，其中初始分布已经是稳态，对于两种准则，收敛都应该是即时的（$n=1$）。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef shannon_entropy(phi: np.ndarray) - float:\n    \"\"\"Computes the Shannon-Jaynes entropy H(phi) = -sum(p_i * log(p_i)).\"\"\"\n    # The limit of x*log(x) as x->0 is 0. We sum only over non-zero elements.\n    phi_positive = phi[phi  0]\n    return -np.sum(phi_positive * np.log(phi_positive))\n\ndef run_simulation(N: int, delta: float, eps_R: float, eps_H: float, phi0_type: str, max_iter: int = 20000):\n    \"\"\"\n    Runs a single simulation for a given set of parameters.\n    \n    Returns:\n        A list [RR_iters, EC_iters, premature_flag].\n    \"\"\"\n    m = N // 2\n    \n    # 1. Build the transition matrix P\n    val_same_block = (1 - delta) / m\n    val_diff_block = delta / m\n    \n    P_A = np.full((m, m), val_same_block)\n    P_B = np.full((m, m), val_diff_block)\n    \n    P = np.block([\n        [P_A, P_B],\n        [P_B, P_A]\n    ])\n    \n    # 2. Initialize the flux vector phi_0\n    phi_current = np.zeros(N)\n    if phi0_type == \"first_block\":\n        phi_current[:m] = 1.0 / m\n    elif phi0_type == \"uniform\":\n        phi_current.fill(1.0 / N)\n\n    # 3. Iterate and check termination criteria\n    rr_iters = None\n    ec_iters = None\n    \n    # Check for immediate convergence (Test Case C)\n    if np.allclose(P @ phi_current, phi_current):\n        return [1, 1, False]\n\n    for n in range(1, max_iter + 1):\n        phi_next = P @ phi_current\n        \n        # Calculate residual r_n\n        r_n = np.linalg.norm(phi_next - phi_current, 2)\n        \n        # Calculate entropy change delta_H_n\n        h_current = shannon_entropy(phi_current)\n        h_next = shannon_entropy(phi_next)\n        delta_h_n = np.abs(h_next - h_current)\n\n        # Check RR criterion\n        if rr_iters is None and r_n = eps_R:\n            rr_iters = n\n        \n        # Check EC augmented criterion\n        if ec_iters is None and r_n = eps_R and delta_h_n = eps_H:\n            ec_iters = n\n\n        # Break if both criteria have terminated\n        if rr_iters is not None and ec_iters is not None:\n            break\n            \n        phi_current = phi_next\n\n    # 4. Report results\n    if rr_iters is None or ec_iters is None:\n        raise RuntimeError(f\"Simulation did not converge within {max_iter} iterations.\")\n\n    premature = rr_iters  ec_iters\n    \n    return [rr_iters, ec_iters, premature]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test A (well-separated modes)\n        {\"N\": 12, \"delta\": 0.05, \"eps_R\": 1e-6, \"eps_H\": 1e-6, \"phi0_type\": \"first_block\"},\n        # Test B (near-degenerate modes)\n        {\"N\": 12, \"delta\": 0.001, \"eps_R\": 1e-3, \"eps_H\": 2e-4, \"phi0_type\": \"first_block\"},\n        # Test C (stationary initial distribution)\n        {\"N\": 12, \"delta\": 0.005, \"eps_R\": 1e-4, \"eps_H\": 1e-4, \"phi0_type\": \"uniform\"},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_simulation(\n            N=case[\"N\"], \n            delta=case[\"delta\"], \n            eps_R=case[\"eps_R\"], \n            eps_H=case[\"eps_H\"], \n            phi0_type=case[\"phi0_type\"]\n        )\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # The str() on a list gives a string like '[1, 2, True]', which is what's needed.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}