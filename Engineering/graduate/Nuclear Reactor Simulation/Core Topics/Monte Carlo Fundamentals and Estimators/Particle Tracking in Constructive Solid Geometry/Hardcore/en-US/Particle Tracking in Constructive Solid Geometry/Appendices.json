{
    "hands_on_practices": [
        {
            "introduction": "Before writing complex code, it is crucial to master the fundamental mathematics of particle tracking. This exercise grounds your understanding by having you manually calculate the free-flight distance of a particle to the boundary of a CSG object . By solving for the intersection points between a ray and various primitive surfaces, you will develop the core analytical skills needed to design and verify any automated tracking algorithm.",
            "id": "4240618",
            "problem": "A neutron is tracked in a reactor-physics Monte Carlo setting using Constructive Solid Geometry (CSG). The geometry region $\\mathcal{R}$ is defined by a Boolean combination of primitives:\n- a right circular cylinder aligned with the $z$-axis of radius $10\\,\\text{cm}$, that is, the set $\\{(x,y,z): x^{2}+y^{2} \\leq 100\\}$,\n- intersected with the axial slab $\\{(x,y,z): 0 \\leq z \\leq 20\\,\\text{cm}\\}$,\n- with a spherical void subtracted, where the sphere has center at $(3\\,\\text{cm}, 2\\,\\text{cm}, 8\\,\\text{cm})$ and radius $2\\,\\text{cm}$.\n\nFormally,\n$$\n\\mathcal{R}=\\Big(\\{(x,y,z): x^{2}+y^{2} \\leq 100\\}\\ \\cap\\ \\{(x,y,z): 0 \\leq z \\leq 20\\}\\Big)\\ \\setminus\\ \\{(x,y,z): (x-3)^{2}+(y-2)^{2}+(z-8)^{2} \\leq 4\\}.\n$$\nA neutron starts at position $p_{0}=(0\\,\\text{cm}, 0\\,\\text{cm}, 5\\,\\text{cm})$ and is tracked along the ray\n$$\nr(t)=p_{0}+t\\,\\hat{u},\n$$\nwhere $t \\geq 0$ is the path length in $\\text{cm}$ and $\\hat{u}$ is the unit direction vector obtained by normalizing $v=(3,2,3)$.\n\nStarting only from the definitions of the geometric surfaces and the parametric representation of the ray, determine the free-flight distance $t^{\\ast}$ to the first boundary of $\\mathcal{R}$ encountered by the neutron along the ray. Your answer must be given as a single exact analytic expression in centimeters. Do not approximate or round; express the final result in closed form.",
            "solution": "The problem as stated is scientifically grounded, well-posed, objective, and contains all necessary information for a unique solution. The region $\\mathcal{R}$ is a standard Constructive Solid Geometry (CSG) object. The particle tracking is a ray-tracing problem. We first verify that the starting position $p_{0}=(0, 0, 5)$ is within the region $\\mathcal{R}$.\nThe region is defined by the intersection of a solid cylinder and a slab, with a spherical void subtracted.\n1.  Cylinder condition: $x^{2}+y^{2} \\leq 100$. For $p_{0}$, we have $0^{2}+0^{2}=0 \\leq 100$. The point is inside the cylinder.\n2.  Slab condition: $0 \\leq z \\leq 20$. For $p_{0}$, we have $0 \\leq 5 \\leq 20$. The point is inside the slab.\n3.  Sphere condition: $(x-3)^{2}+(y-2)^{2}+(z-8)^{2}  4$. For $p_{0}$, we have $(0-3)^{2}+(0-2)^{2}+(5-8)^{2} = 9+4+9=22$. Since $22  4$, the point is outside the spherical void.\nSince all conditions are met, the starting point $p_{0}$ lies within the material region $\\mathcal{R}$. The task is to find the shortest positive path length $t^{\\ast}$ from $p_{0}$ to any boundary of $\\mathcal{R}$ along the specified direction.\n\nThe neutron's path is a ray $r(t) = p_{0} + t\\,\\hat{u}$ for $t \\geq 0$.\nThe starting position is $p_{0} = (0, 0, 5)$.\nThe direction vector is $v = (3, 2, 3)$. Its magnitude is $\\|v\\| = \\sqrt{3^{2}+2^{2}+3^{2}} = \\sqrt{9+4+9} = \\sqrt{22}$.\nThe unit direction vector is $\\hat{u} = \\frac{v}{\\|v\\|} = \\frac{1}{\\sqrt{22}}(3, 2, 3)$.\nThe parametric equation of the ray is:\n$$\nr(t) = (x(t), y(t), z(t)) = \\left( \\frac{3t}{\\sqrt{22}}, \\frac{2t}{\\sqrt{22}}, 5 + \\frac{3t}{\\sqrt{22}} \\right).\n$$\nThe boundaries of $\\mathcal{R}$ are defined by the surfaces of the cylinder, the slab, and the sphere. We must find the smallest positive $t$ for which $r(t)$ intersects one of these surfaces.\n\n1.  **Intersection with the cylinder surface:**\n    The cylinder surface is given by $x^{2}+y^{2}=100$. Substituting the ray equations:\n    $$\n    \\left(\\frac{3t}{\\sqrt{22}}\\right)^{2} + \\left(\\frac{2t}{\\sqrt{22}}\\right)^{2} = 100\n    $$\n    $$\n    \\frac{9t^{2}}{22} + \\frac{4t^{2}}{22} = 100\n    $$\n    $$\n    \\frac{13t^{2}}{22} = 100 \\implies t^{2} = \\frac{2200}{13}\n    $$\n    Since we require $t  0$, the distance to the cylinder wall is $t_{cyl} = \\sqrt{\\frac{2200}{13}} = 10\\sqrt{\\frac{22}{13}}$.\n\n2.  **Intersection with the slab planes:**\n    The slab is defined by $0 \\leq z \\leq 20$. The boundary planes are $z=0$ and $z=20$. The particle moves from $z_0=5$ with a positive $z$-component of velocity, so it can only hit the $z=20$ plane in the forward direction.\n    Intersection with the top plane, $z(t)=20$:\n    $$\n    5 + \\frac{3t}{\\sqrt{22}} = 20 \\implies \\frac{3t}{\\sqrt{22}} = 15 \\implies t = \\frac{15\\sqrt{22}}{3} = 5\\sqrt{22}\n    $$\n    Let this distance be $t_{z} = 5\\sqrt{22}$.\n    For the bottom plane, $z(t)=0$, we get $5 + \\frac{3t}{\\sqrt{22}} = 0$, which yields a negative $t=-\\frac{5\\sqrt{22}}{3}$. This corresponds to an intersection in the backward direction and is not a valid free-flight distance.\n\n3.  **Intersection with the spherical void:**\n    The sphere has center $c=(3, 2, 8)$ and radius $R=2$. The surface equation is $(x-3)^{2}+(y-2)^{2}+(z-8)^{2}=4$.\n    We seek $t$ such that $\\|r(t)-c\\|^{2} = R^{2}$. This can be written as $\\|(p_{0}-c) + t\\hat{u}\\|^{2} = R^{2}$.\n    Expanding the dot product: $\\|p_{0}-c\\|^{2} + 2t (\\hat{u} \\cdot (p_{0}-c)) + t^{2}\\|\\hat{u}\\|^{2} = R^{2}$.\n    Let $\\Delta p = p_{0}-c = (0-3, 0-2, 5-8) = (-3, -2, -3)$.\n    The coefficients for the quadratic equation $t^2 + 2(\\hat{u}\\cdot\\Delta p) t + (\\|\\Delta p\\|^2 - R^2) = 0$ are:\n    $\\|\\Delta p\\|^{2} = (-3)^{2} + (-2)^{2} + (-3)^{2} = 9+4+9=22$.\n    $\\hat{u} \\cdot \\Delta p = \\frac{1}{\\sqrt{22}}(3, 2, 3) \\cdot (-3, -2, -3) = \\frac{1}{\\sqrt{22}}(-9-4-9) = \\frac{-22}{\\sqrt{22}} = -\\sqrt{22}$.\n    $R^{2} = 2^{2} = 4$.\n    The quadratic equation for $t$ is:\n    $$\n    t^{2} + 2(-\\sqrt{22})t + (22-4) = 0\n    $$\n    $$\n    t^{2} - 2\\sqrt{22}t + 18 = 0\n    $$\n    Using the quadratic formula $t = \\frac{-b \\pm \\sqrt{b^{2}-4ac}}{2a}$:\n    $$\n    t = \\frac{2\\sqrt{22} \\pm \\sqrt{(-2\\sqrt{22})^{2} - 4(1)(18)}}{2} = \\frac{2\\sqrt{22} \\pm \\sqrt{4 \\cdot 22 - 72}}{2}\n    $$\n    $$\n    t = \\frac{2\\sqrt{22} \\pm \\sqrt{88 - 72}}{2} = \\frac{2\\sqrt{22} \\pm \\sqrt{16}}{2} = \\frac{2\\sqrt{22} \\pm 4}{2} = \\sqrt{22} \\pm 2\n    $$\n    This gives two positive solutions, $t_{sph,1} = \\sqrt{22}-2$ and $t_{sph,2} = \\sqrt{22}+2$. These correspond to the distances for entering and exiting the sphere, respectively. Since the neutron starts outside the sphere, the first intersection distance is the smaller one, $t_{sph} = \\sqrt{22}-2$.\n\n4.  **Determination of the free-flight distance:**\n    The free-flight distance $t^{\\ast}$ is the minimum of the positive intersection distances calculated:\n    $$\n    t^{\\ast} = \\min(t_{cyl}, t_{z}, t_{sph}) = \\min\\left(10\\sqrt{\\frac{22}{13}}, 5\\sqrt{22}, \\sqrt{22}-2\\right)\n    $$\n    We must compare these values analytically.\n    We know that $4  \\sqrt{22}  5$. Therefore, $t_{sph} = \\sqrt{22}-2$ is a positive value between $2$ and $3$.\n    -   Compare $t_{sph}$ and $t_{z}$:\n        $t_{sph} = \\sqrt{22}-2  \\sqrt{22}  5\\sqrt{22} = t_{z}$. Thus, $t_{sph}  t_{z}$.\n    -   Compare $t_{sph}$ and $t_{cyl}$:\n        $t_{sph} = \\sqrt{22}-2$ and $t_{cyl} = 10\\sqrt{\\frac{22}{13}}$. Since both are positive, we can compare their squares.\n        $(t_{sph})^{2} = (\\sqrt{22}-2)^{2} = 22 - 4\\sqrt{22} + 4 = 26 - 4\\sqrt{22}$.\n        $(t_{cyl})^{2} = \\left(10\\sqrt{\\frac{22}{13}}\\right)^{2} = 100 \\cdot \\frac{22}{13} = \\frac{2200}{13}$.\n        Since $4  \\sqrt{22}  5$, we have $16  4\\sqrt{22}  20$.\n        This implies $26-20  26-4\\sqrt{22}  26-16$, so $6  (t_{sph})^{2}  10$.\n        For $(t_{cyl})^{2} = \\frac{2200}{13}$, we note that $13 \\times 100 = 1300$, so $\\frac{2200}{13}  100$.\n        Clearly, $6  (t_{sph})^{2}  10  100  (t_{cyl})^{2}$.\n        Since the distances are positive, we can conclude that $t_{sph}  t_{cyl}$.\n\nThe smallest distance is $t_{sph}$. The first boundary encountered by the neutron is the surface of the spherical void. The free-flight distance is $t^{\\ast} = \\sqrt{22}-2$.",
            "answer": "$$\\boxed{\\sqrt{22}-2}$$"
        },
        {
            "introduction": "A cornerstone of any CSG-based code is the ability to determine a point's location relative to a complex solid. This practice moves from theory to implementation, tasking you with creating a robust point classification algorithm that accounts for the realities of finite-precision arithmetic . Mastering this \"inside/outside/on\" test, including the logic for combining classifications through Boolean operations, is essential for building reliable simulation tools.",
            "id": "4240630",
            "problem": "A three-dimensional constructive solid geometry region is built from basic implicit primitives and Boolean set operations to represent a pin cell in a nuclear reactor simulation. Consider a Cartesian coordinate system with axes $x$, $y$, and $z$ measured in meters. A primitive solid is defined by an inequality $g(\\mathbf{x}) \\le 0$, where $\\mathbf{x} = (x,y,z)$ and $g$ is a continuous scalar field. A point is inside the primitive when the inequality holds, outside when the inequality is strictly violated, and on the boundary when the inequality holds with equality. The core constructive primitives used in this problem are half-spaces and right circular cylinders. A half-space associated with a plane with unit normal $\\mathbf{n}$ and scalar offset $d$ is defined by $g(\\mathbf{x}) = \\mathbf{n} \\cdot \\mathbf{x} - d \\le 0$. A right circular cylinder aligned with the $z$-axis with radius $R$ is defined by $g(\\mathbf{x}) = \\sqrt{x^2 + y^2} - R \\le 0$. The finite height version of the cylinder is generated by intersecting the infinite cylinder with two axial half-spaces. Composite solids are created from primitives using the set union operation $\\cup$, the set intersection operation $\\cap$, and the set difference operation $\\setminus$, interpreted in the standard set-theoretic sense.\n\nIn particle tracking for nuclear reactor simulation, the classification of a point relative to a composite constructive solid geometry region must be robust under finite precision. Given a numerical tolerance $\\varepsilon  0$ (in meters), your task is to derive, justify, and implement a robust point classification algorithm that, for any composite region built from the specified primitives and Boolean operations, returns an integer code indicating the relation of a point $\\mathbf{x}$ to the region:\n- $1$ if $\\mathbf{x}$ is inside,\n- $0$ if $\\mathbf{x}$ is on or within tolerance of the boundary,\n- $-1$ if $\\mathbf{x}$ is outside.\n\nYou must start your derivation from the following foundations:\n- The mathematical definitions of inside, boundary, and outside for an implicit primitive $g(\\mathbf{x}) \\le 0$.\n- The standard semantics of the Boolean set operations $\\cup$, $\\cap$, and $\\setminus$ applied to sets defined by these primitives.\n- The requirement that the boundary classification reflects finite precision by incorporating a numerical tolerance $\\varepsilon$ into the decision criteria, ensuring decisions are physically and numerically plausible for Monte Carlo particle tracking.\n\nConstruct the pin cell geometry as follows, with all lengths expressed in meters:\n- Let $L = 0.01$ be the half-edge length of an axis-aligned cube region $A$ defined by the six half-spaces $x \\le L$, $x \\ge -L$, $y \\le L$, $y \\ge -L$, $z \\le L$, and $z \\ge -L$.\n- Let $R = 0.0045$ be the radius of a right circular cylinder $B$ aligned with the $z$-axis. Limit the cylinder height to the cube height by intersecting the cylinder with the two half-spaces $z \\le L$ and $z \\ge -L$, creating a finite cylinder.\n- Define the moderator region $M$ as the set difference $M = A \\setminus B$.\n\nUse the tolerance $\\varepsilon = 5 \\times 10^{-7}$ meters. Implement a program that classifies the following test points $\\mathbf{x}$ in meters relative to $M$:\n1. $\\mathbf{x}_1 = (0.008, 0.0, 0.0)$.\n2. $\\mathbf{x}_2 = (0.002, 0.0, 0.0)$.\n3. $\\mathbf{x}_3 = (R + 2.5 \\times 10^{-7}, 0.0, 0.0)$.\n4. $\\mathbf{x}_4 = (L - 3.0 \\times 10^{-7}, 0.0, 0.0)$.\n5. $\\mathbf{x}_5 = (R + 3.0 \\times 10^{-7}, 0.0, L - 4.0 \\times 10^{-7})$.\n6. $\\mathbf{x}_6 = (0.02, 0.0, 0.0)$.\n\nEnsure the classification decision incorporates the tolerance $\\varepsilon$ in a way that is scientifically consistent with the implicit definitions and Boolean set semantics. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example, $[c_1,c_2,c_3,c_4,c_5,c_6]$, where each $c_i$ is the integer code for the point $\\mathbf{x}_i$ relative to $M$.\n\nAll coordinates and the tolerance must be handled in meters. Angles are not used in this problem. The required final output format is exactly one line: a comma-separated list enclosed in square brackets containing the six integer classification codes for the six test points in the order specified.",
            "solution": "The problem requires the development and implementation of a robust algorithm to classify a point's position relative to a composite solid defined using Constructive Solid Geometry (CSG). The classification must account for finite numerical precision by incorporating a tolerance, $\\varepsilon$. The possible classifications for a point $\\mathbf{x}$ are inside ($1$), on or within tolerance of the boundary ($0$), or outside ($-1$).\n\nThe solution is derived in three main steps: first, establishing a robust classification rule for a single primitive solid; second, deriving rules for combining these classifications under Boolean set operations; and third, applying these principles to the specific pin cell geometry.\n\n**Step 1: Robust Classification for a Primitive Solid**\n\nA primitive solid is defined by an inequality $g(\\mathbf{x}) \\le 0$, where $\\mathbf{x} = (x, y, z)$ is a point in $\\mathbb{R}^3$. For the primitives used in this problem (half-spaces with unit normal vectors and right circular cylinders), the function $g(\\mathbf{x})$ can be interpreted as the signed distance from the point $\\mathbf{x}$ to the boundary of the solid. A negative value indicates the point is inside, a positive value indicates it is outside, and zero indicates it is precisely on the boundary.\n\nTo create a classification that is robust to finite-precision arithmetic, we introduce a tolerance band of width $2\\varepsilon$ around the true boundary. The true boundary is the set of points where $g(\\mathbf{x}) = 0$. The tolerance region is the set of points where $|g(\\mathbf{x})| \\le \\varepsilon$.\n\nBased on this, we define the three classification regions for a primitive solid:\n- **Inside (Code $1$)**: The point is \"safely\" inside the solid, meaning it is inside the true boundary by a margin greater than $\\varepsilon$. This corresponds to $g(\\mathbf{x})  -\\varepsilon$.\n- **Outside (Code $-1$)**: The point is \"safely\" outside the solid, meaning it is outside the true boundary by a margin greater than $\\varepsilon$. This corresponds to $g(\\mathbf{x})  \\varepsilon$.\n- **On Boundary (Code $0$)**: The point is on or near the boundary, lying within the tolerance band. This corresponds to $-\\varepsilon \\le g(\\mathbf{x}) \\le \\varepsilon$.\n\nLet $C(\\mathbf{x})$ denote the classification code for a point $\\mathbf{x}$ with respect to a primitive defined by $g(\\mathbf{x}) \\le 0$. The rule is:\n$$\nC(\\mathbf{x}) = \\begin{cases} \n1  \\text{if } g(\\mathbf{x})  -\\varepsilon \\\\\n-1  \\text{if } g(\\mathbf{x})  \\varepsilon \\\\\n0  \\text{if } -\\varepsilon \\le g(\\mathbf{x}) \\le \\varepsilon \n\\end{cases}\n$$\n\n**Step 2: Classification Rules for CSG Boolean Operations**\n\nComposite solids are formed by applying set operations to simpler solids. Let $S_1$ and $S_2$ be two solids, and let $c_1$ and $c_2$ be the classification codes of a point $\\mathbf{x}$ with respect to $S_1$ and $S_2$, respectively. We need to find the classification code for the composite solids $S_1 \\cap S_2$, $S_1 \\cup S_2$, and $S_1 \\setminus S_2$.\n\n- **Intersection ($S_1 \\cap S_2$)**: A point is inside the intersection only if it is inside both $S_1$ and $S_2$. A point is outside the intersection if it is outside either $S_1$ or $S_2$. A point is on the boundary of the intersection if it is on the boundary of one solid while being inside or on the boundary of the other. This logic is captured by the minimum function:\n  $$c_{S_1 \\cap S_2} = \\min(c_1, c_2)$$\n\n- **Union ($S_1 \\cup S_2$)**: A point is inside the union if it is inside either $S_1$ or $S_2$. A point is outside the union only if it is outside both solids. A point is on the boundary if it is on one boundary while being outside or on the boundary of the other. This logic is captured by the maximum function:\n  $$c_{S_1 \\cup S_2} = \\max(c_1, c_2)$$\n\n- **Difference ($S_1 \\setminus S_2$)**: The set difference is equivalent to the intersection with the complement, $S_1 \\setminus S_2 = S_1 \\cap S_2^c$. The complement $S_2^c$ of a solid $S_2$ defined by $g_2(\\mathbf{x}) \\le 0$ has its inside/outside regions flipped. If a point has classification $c_2$ for $S_2$, its classification for $S_2^c$ is $-c_2$. Applying the intersection rule:\n  $$c_{S_1 \\setminus S_2} = \\min(c_1, -c_2)$$\n\n**Step 3: Application to the Pin Cell Geometry**\n\nThe moderator region is defined as $M = A \\setminus B$, where $A$ is a cube and $B$ is a finite cylinder.\n\n- **Region A (Cube)**: The cube is defined as the intersection of six half-spaces:\n  $g_1(\\mathbf{x}) = x - L \\le 0$\n  $g_2(\\mathbf{x}) = -x - L \\le 0$ (from $x \\ge -L$)\n  $g_3(\\mathbf{x}) = y - L \\le 0$\n  $g_4(\\mathbf{x}) = -y - L \\le 0$ (from $y \\ge -L$)\n  $g_5(\\mathbf{x}) = z - L \\le 0$\n  $g_6(\\mathbf{x}) = -z - L \\le 0$ (from $z \\ge -L$)\n  \n  Since $A$ is an intersection, its classification code $c_A$ is the minimum of the codes for its constituent primitives:\n  $$c_A(\\mathbf{x}) = \\min_{i=1..6} C_i(\\mathbf{x})$$\n  where $C_i(\\mathbf{x})$ is the classification based on $g_i(\\mathbf{x})$.\n\n- **Region B (Finite Cylinder)**: The finite cylinder is the intersection of an infinite cylinder and two axial half-spaces:\n  $g_7(\\mathbf{x}) = \\sqrt{x^2 + y^2} - R \\le 0$\n  $g_8(\\mathbf{x}) = z - L \\le 0$\n  $g_9(\\mathbf{x}) = -z - L \\le 0$\n  \n  Similarly, its classification code $c_B$ is the minimum of the codes of these three primitives:\n  $$c_B(\\mathbf{x}) = \\min(C_7(\\mathbf{x}), C_8(\\mathbf{x}), C_9(\\mathbf{x}))$$\n\n- **Region M (Moderator)**: The moderator is the set difference $A \\setminus B$. Using the derived rule, its classification code $c_M$ is:\n  $$c_M(\\mathbf{x}) = \\min(c_A(\\mathbf{x}), -c_B(\\mathbf{x}))$$\n\nThis completes the derivation of the algorithm. The implementation will involve defining functions for each primitive's $g(\\mathbf{x})$, a general primitive classification function, and then combining the results according to the CSG tree structure to classify each test point. The constants are $L=0.01$, $R=0.0045$, and $\\varepsilon = 5 \\times 10^{-7}$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the robust point classification problem for the specified pin cell geometry.\n    \"\"\"\n    \n    # Define constants from the problem statement\n    L = 0.01  # half-edge length of the cube, in meters\n    R = 0.0045  # radius of the cylinder, in meters\n    EPS = 5e-7  # numerical tolerance, in meters\n\n    # Define the test points from the problem statement\n    test_cases = [\n        (0.008, 0.0, 0.0),\n        (0.002, 0.0, 0.0),\n        (R + 2.5e-7, 0.0, 0.0),\n        (L - 3.0e-7, 0.0, 0.0),\n        (R + 3.0e-7, 0.0, L - 4.0e-7),\n        (0.02, 0.0, 0.0)\n    ]\n\n    def classify_primitive(d, eps):\n        \"\"\"\n        Classifies a point based on its signed distance 'd' to a primitive's surface.\n        \n        Args:\n            d (float): The value of the implicit function g(x), representing signed distance.\n            eps (float): The numerical tolerance.\n            \n        Returns:\n            int: 1 for inside, 0 for on boundary, -1 for outside.\n        \"\"\"\n        if d  -eps:\n            return 1  # Safely inside\n        elif d  eps:\n            return -1 # Safely outside\n        else:\n            return 0  # On or within tolerance of the boundary\n\n    def classify_point_in_moderator(point):\n        \"\"\"\n        Classifies a point relative to the moderator region M = A \\ B.\n        \n        Args:\n            point (tuple): The (x, y, z) coordinates of the point.\n            \n        Returns:\n            int: The classification code for the point relative to M.\n        \"\"\"\n        x, y, z = point\n\n        # --- Classification for Region A (Cube) ---\n        # A is the intersection of 6 half-spaces.\n        # The classification for an intersection is the minimum of the component classifications.\n        \n        # g(x) = x - L = 0\n        c1 = classify_primitive(x - L, EPS)\n        # g(x) = -x - L = 0  (from x = -L)\n        c2 = classify_primitive(-x - L, EPS)\n        # g(y) = y - L = 0\n        c3 = classify_primitive(y - L, EPS)\n        # g(y) = -y - L = 0 (from y = -L)\n        c4 = classify_primitive(-y - L, EPS)\n        # g(z) = z - L = 0\n        c5 = classify_primitive(z - L, EPS)\n        # g(z) = -z - L = 0 (from z = -L)\n        c6 = classify_primitive(-z - L, EPS)\n        \n        c_A = min(c1, c2, c3, c4, c5, c6)\n\n        # --- Classification for Region B (Finite Cylinder) ---\n        # B is the intersection of an infinite cylinder and two half-spaces.\n        \n        # g(r) = sqrt(x^2 + y^2) - R = 0\n        c7 = classify_primitive(np.sqrt(x**2 + y**2) - R, EPS)\n        # g(z) = z - L = 0\n        c8 = classify_primitive(z - L, EPS)\n        # g(z) = -z - L = 0\n        c9 = classify_primitive(-z - L, EPS)\n        \n        c_B = min(c7, c8, c9)\n\n        # --- Classification for Region M = A \\ B ---\n        # The classification for a set difference (S1 \\ S2) is min(c1, -c2).\n        c_M = min(c_A, -c_B)\n        \n        return c_M\n\n    results = []\n    for case in test_cases:\n        result = classify_point_in_moderator(case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "With the geometric foundations in place, we can now simulate a key step in a particle's life: determining its next event. This exercise integrates deterministic distance-to-boundary calculations with the stochastic nature of particle collisions, a core process in Monte Carlo transport methods . By implementing a \"next-event estimator,\" you will learn to decide whether a particle first hits a geometric boundary or undergoes a physical interaction within the material, a fundamental decision in transport simulation.",
            "id": "4240629",
            "problem": "You are tasked with implementing a distance-to-boundary and next-event decision algorithm for neutral particle tracking in a Constructive Solid Geometry (CSG) cell, suitable for nuclear reactor simulation. The model is purely geometric and stochastic, grounded in first principles. A particle travels in straight-line segments between events. Events are either a collision inside the material or a surface crossing that changes the particle’s current CSG region. The objective is to compute which event occurs first and at what distance, using physically plausible geometry and stochastic sampling.\n\nThe fundamental base you must use is:\n- Straight-line kinematics for particle rays: a particle at position $\\mathbf{r}_0$ with unit direction $\\hat{\\mathbf{u}}$ follows the parametric path $\\mathbf{r}(s) = \\mathbf{r}_0 + s \\hat{\\mathbf{u}}$ for path length $s \\geq 0$.\n- Collision occurrence is modeled by a Poisson process with macroscopic total cross-section $\\Sigma_t$ (in $\\mathrm{m}^{-1}$). The free path length to collision $S_c$ is distributed as the exponential distribution with rate $\\Sigma_t$. By inverse-transform sampling for a uniform variate $\\xi \\in (0,1)$, the sampled free path length is $S_c = -\\ln(1-\\xi)/\\Sigma_t$, expressed in meters.\n- Constructive Solid Geometry is expressed via implicit surfaces defining primitives with Boolean set operations.\n\nGeometry definition:\n- Let $A$ be the intersection of a right circular cylinder of radius $R$ centered on the $z$-axis and an axial slab bounded by planes at $z=z_{\\min}$ and $z=z_{\\max}$. Formally,\n$$\nA = \\left\\{(x,y,z) \\,\\middle|\\, x^2 + y^2 \\le R^2 \\right\\} \\cap \\left\\{(x,y,z) \\,\\middle|\\, z_{\\min} \\le z \\le z_{\\max} \\right\\}.\n$$\n- Let $B$ be a spherical void centered at the origin with radius $r_v$,\n$$\nB = \\left\\{(x,y,z) \\,\\middle|\\, x^2 + y^2 + z^2 \\le r_v^2 \\right\\}.\n$$\n- The material-filled tracking cell $C$ is the CSG difference $C = A \\setminus B$, namely points that are inside $A$ and not inside $B$.\n\nEvent logic:\n- The next event along the ray $\\mathbf{r}(s) = \\mathbf{r}_0 + s \\hat{\\mathbf{u}}$ occurs at distance $s^\\star = \\min\\{S_c, S_b\\}$, where $S_b$ is the smallest positive distance to any boundary of $C$ that toggles membership in $C$.\n- A boundary crossing event occurs if $S_b  S_c$, and a collision event occurs if $S_c  S_b$. Ties may be broken by favoring boundary crossing.\n- You must assume the particle starts inside $C$ (i.e., inside $A$ and outside $B$), with $\\hat{\\mathbf{u}}$ being a unit vector. Distances must be computed in meters and reported rounded to six decimal places.\n\nDistance-to-boundary rules to implement:\n- Cylinder lateral surface ($x^2 + y^2 = R^2$): Solve for the smallest positive $s$ satisfying $(x_0 + s u_x)^2 + (y_0 + s u_y)^2 = R^2$. If $(u_x^2 + u_y^2) = 0$, there is no intersection with the cylinder lateral surface.\n- Planes ($z=z_{\\min}$ and $z=z_{\\max}$): Solve for $s = (z_\\text{plane} - z_0)/u_z$. If $u_z = 0$, ignore that plane.\n- Sphere surface ($x^2 + y^2 + z^2 = r_v^2$): Solve for the smallest positive $s$ satisfying $\\|\\mathbf{r}_0 + s \\hat{\\mathbf{u}}\\|^2 = r_v^2$. If the discriminant is negative, there is no intersection.\n\nAll calculations should handle numerical stability appropriately, treating roots with negative or near-zero values as non-physical for forward flight. Use a small tolerance for positivity tests.\n\nSurface identifier mapping for output:\n- Cylinder lateral surface: $0$.\n- Plane at $z=z_{\\min}$: $1$.\n- Plane at $z=z_{\\max}$: $2$.\n- Sphere surface: $3$.\n\nProgram requirements:\n- Implement the above distance-to-boundary and next-event logic.\n- For each test case, output a list of three values: the event type code (integer $0$ for collision, integer $1$ for boundary crossing), the event distance $s^\\star$ in meters rounded to six decimal places (float), and the surface identifier (integer for boundary crossing; $-1$ for collision).\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element corresponds to one test case in order and is itself a list of the three values as specified.\n\nTest suite and parameters:\n- Geometry constants (use these exactly):\n  - Cylinder radius $R = 0.5$ meters.\n  - Axial bounds $z_{\\min} = -0.6$ meters and $z_{\\max} = 0.6$ meters.\n  - Sphere (void) radius $r_v = 0.1$ meters.\n- Test cases (each is a tuple $(\\mathbf{r}_0, \\hat{\\mathbf{u}}, \\Sigma_t, \\xi)$):\n  1. $(\\mathbf{r}_0 = (0.10, 0.20, 0.00), \\hat{\\mathbf{u}} \\propto (1.0, 1.0, 0.5), \\Sigma_t = 2.0\\,\\mathrm{m}^{-1}, \\xi = 0.30)$, where $\\hat{\\mathbf{u}}$ must be normalized prior to use.\n  2. $(\\mathbf{r}_0 = (0.20, 0.00, 0.55), \\hat{\\mathbf{u}} = (0.0, 0.0, 1.0), \\Sigma_t = 5.0\\,\\mathrm{m}^{-1}, \\xi = 0.95)$.\n  3. $(\\mathbf{r}_0 = (0.499, 0.000, 0.000), \\hat{\\mathbf{u}} = (0.0, 1.0, 0.0), \\Sigma_t = 100.0\\,\\mathrm{m}^{-1}, \\xi = 0.05)$.\n  4. $(\\mathbf{r}_0 = (0.15, 0.00, 0.00), \\hat{\\mathbf{u}} = (-1.0, 0.0, 0.0), \\Sigma_t = 0.5\\,\\mathrm{m}^{-1}, \\xi = 0.40)$.\n  5. $(\\mathbf{r}_0 = (0.12, 0.00, 0.00), \\hat{\\mathbf{u}} = (1.0, 0.0, 0.0), \\Sigma_t = 2.0\\,\\mathrm{m}^{-1}, \\xi = 0.90)$.\n\nAngle unit specification:\n- Direction vectors are dimensionless and must be normalized to unit length before distance calculations; angles are not directly used.\n\nFinal output format:\n- Your program must print a single line exactly formatted as a comma-separated list of five elements enclosed in square brackets.\n- Each element must be a list of three values in the order described: $[\\text{event\\_type}, \\text{distance\\_m\\_rounded\\_to\\_six\\_decimals}, \\text{surface\\_id}]$.\n- Example shape (not actual values): $[[0,0.123456,-1],[1,0.654321,2],[1,0.100000,0],[1,0.050000,3],[0,0.010000,-1]]$.",
            "solution": "The user has provided a well-defined problem in the domain of computational physics, specifically neutral particle tracking within a Constructive Solid Geometry (CSG) volume. The task is to determine the next event for a particle—either a collision within the material or a crossing of a geometric boundary—based on its starting position, direction, and the material's properties.\n\n### Step 1: Extract Givens\n\n-   **Particle Kinematics**: Path is $\\mathbf{r}(s) = \\mathbf{r}_0 + s \\hat{\\mathbf{u}}$ for distance $s \\geq 0$, where $\\mathbf{r}_0$ is the start position and $\\hat{\\mathbf{u}}$ is the unit direction vector.\n-   **Collision Sampling**: The distance to collision, $S_c$, is sampled from an exponential distribution with rate $\\Sigma_t$ (macroscopic total cross-section). The sampling formula is $S_c = -\\ln(1-\\xi)/\\Sigma_t$ for a uniform random variate $\\xi \\in (0,1)$.\n-   **Geometry Definition**:\n    -   $A = \\left\\{(x,y,z) \\,\\middle|\\, x^2 + y^2 \\le R^2 \\right\\} \\cap \\left\\{(x,y,z) \\,\\middle|\\, z_{\\min} \\le z \\le z_{\\max} \\right\\}$ (a finite cylinder).\n    -   $B = \\left\\{(x,y,z) \\,\\middle|\\, x^2 + y^2 + z^2 \\le r_v^2 \\right\\}$ (a sphere).\n    -   The tracking cell is $C = A \\setminus B$.\n-   **Event Logic**: The next event occurs at distance $s^\\star = \\min\\{S_c, S_b\\}$, where $S_b$ is the minimum positive distance to any boundary of cell $C$. A boundary crossing is favored in case of a tie ($S_b = S_c$). The particle is assumed to start inside $C$.\n-   **Distance-to-Boundary Rules**: Specific quadratic and linear equations are provided to find the intersection distance $s$ for the ray with each primitive surface (cylinder, planes, sphere).\n-   **Numerical Stability**: A small positive tolerance should be used for positivity tests. Negative or near-zero roots are considered non-physical for forward travel.\n-   **Surface Identifiers**: Cylinder lateral=$0$, $z_{\\min}$ plane=$1$, $z_{\\max}$ plane=$2$, Sphere=$3$.\n-   **Geometric Constants**: $R = 0.5\\,\\mathrm{m}$, $z_{\\min} = -0.6\\,\\mathrm{m}$, $z_{\\max} = 0.6\\,\\mathrm{m}$, $r_v = 0.1\\,\\mathrm{m}$.\n-   **Test Cases**: Five test cases are given, each providing $(\\mathbf{r}_0, \\hat{\\mathbf{u}}, \\Sigma_t, \\xi)$.\n    1.  $(\\mathbf{r}_0 = (0.10, 0.20, 0.00), \\hat{\\mathbf{u}} \\propto (1.0, 1.0, 0.5), \\Sigma_t = 2.0\\,\\mathrm{m}^{-1}, \\xi = 0.30)$\n    2.  $(\\mathbf{r}_0 = (0.20, 0.00, 0.55), \\hat{\\mathbf{u}} = (0.0, 0.0, 1.0), \\Sigma_t = 5.0\\,\\mathrm{m}^{-1}, \\xi = 0.95)$\n    3.  $(\\mathbf{r}_0 = (0.499, 0.000, 0.000), \\hat{\\mathbf{u}} = (0.0, 1.0, 0.0), \\Sigma_t = 100.0\\,\\mathrm{m}^{-1}, \\xi = 0.05)$\n    4.  $(\\mathbf{r}_0 = (0.15, 0.00, 0.00), \\hat{\\mathbf{u}} = (-1.0, 0.0, 0.0), \\Sigma_t = 0.5\\,\\mathrm{m}^{-1}, \\xi = 0.40)$\n    5.  $(\\mathbf{r}_0 = (0.12, 0.00, 0.00), \\hat{\\mathbf{u}} = (1.0, 0.0, 0.0), \\Sigma_t = 2.0\\,\\mathrm{m}^{-1}, \\xi = 0.90)$\n-   **Output Format**: For each case, `[event_type, distance, surface_id]`, where `event_type` is $0$ for collision, $1$ for boundary crossing; `distance` is rounded to 6 decimal places; and `surface_id` is $-1$ for collision. The final output is a single-line string representing a list of these results.\n\n### Step 2: Validate Using Extracted Givens\n\nThe problem is subjected to rigorous validation.\n\n-   **Scientifically Grounded**: The problem is fundamentally sound. It models neutral particle transport using standard, well-established principles: straight-line flight, stochastic collisions governed by a Poisson process (exponential free paths), and CSG for geometric representation. These are cornerstone concepts in Monte Carlo methods for nuclear reactor analysis.\n-   **Well-Posed**: The problem is clearly specified. The geometry is defined by unambiguous implicit equations. The event logic, based on finding the minimum of a set of distances, is well-defined. The initial condition that the particle starts inside the valid region $C$ is explicitly stated and has been verified for all test cases. All parameters required for a unique solution are provided for each case.\n-   **Objective**: The problem is expressed with mathematical precision and contains no subjective or ambiguous language.\n\nThe problem does not exhibit any of the defined flaws (e.g., scientific unsoundness, incompleteness, contradiction, or vagueness). It is a standard, formalizable problem in computational physics.\n\n### Step 3: Verdict and Action\n\nThe problem is **valid**. A solution will be developed and implemented as specified.\n\n### Algorithmic Solution\n\nThe solution involves determining two key quantities for each test case: the stochastic distance to the next collision, $S_c$, and the deterministic distance to the nearest geometric boundary, $S_b$. The smaller of these two determines the particle's next event.\n\nLet the particle's state be defined by its position $\\mathbf{r}_0 = (x_0, y_0, z_0)$ and its unit direction vector $\\hat{\\mathbf{u}} = (u_x, u_y, u_z)$.\n\n1.  **Calculate Distance to Collision ($S_c$)**:\n    This distance is sampled using the inverse-transform method for the exponential distribution. Given the macroscopic total cross-section $\\Sigma_t$ and a uniform random variate $\\xi \\in (0,1)$, the distance is:\n    $$ S_c = -\\frac{\\ln(1-\\xi)}{\\Sigma_t} $$\n\n2.  **Calculate Distance to Boundaries ($S_b$)**:\n    We must find the smallest positive distance $s  \\epsilon$ (where $\\epsilon$ is a small tolerance, e.g., $10^{-9}$) from the particle's current position to any of the surfaces that define the cell $C = A \\setminus B$. We analyze each primitive surface individually.\n\n    -   **Cylinder Lateral Surface ($x^2 + y^2 = R^2$)**:\n        Substituting the ray equation $\\mathbf{r}(s) = \\mathbf{r}_0 + s\\hat{\\mathbf{u}}$ into the cylinder equation yields a quadratic equation in $s$: $as^2 + bs + c = 0$, where:\n        $$ a = u_x^2 + u_y^2 $$\n        $$ b = 2(x_0 u_x + y_0 u_y) $$\n        $$ c = x_0^2 + y_0^2 - R^2 $$\n        If $a \\approx 0$, the particle is moving parallel to the $z$-axis and, since it starts inside the cylinder, will never intersect the lateral surface. Otherwise, we solve the quadratic equation. The discriminant is $\\Delta = b^2 - 4ac$. If $\\Delta  0$, there is no intersection. If $\\Delta \\ge 0$, the roots are $s = (-b \\pm \\sqrt{\\Delta})/(2a)$. The smallest root $s  \\epsilon$ corresponds to the distance to this surface.\n\n    -   **Axial Planes ($z=z_{\\min}, z=z_{\\max}$)**:\n        The intersection with a plane $z=z_{\\text{plane}}$ is found by solving $z_0 + s u_z = z_{\\text{plane}}$. If $u_z \\neq 0$, the distance is:\n        $$ s = \\frac{z_{\\text{plane}} - z_0}{u_z} $$\n        We consider this distance only if $s  \\epsilon$. Two such planes exist, at $z_{\\min}$ and $z_{\\max}$.\n\n    -   **Sphere Surface ($x^2+y^2+z^2=r_v^2$)**:\n        Substituting the ray equation into the sphere equation $\\|\\mathbf{r}_0 + s\\hat{\\mathbf{u}}\\|^2 = r_v^2$ yields another quadratic equation in $s$: $as^2 + bs + c = 0$. Since $\\hat{\\mathbf{u}}$ is a unit vector ($\\|\\hat{\\mathbf{u}}\\|^2 = 1$), the coefficients are:\n        $$ a = 1 $$\n        $$ b = 2 (\\mathbf{r}_0 \\cdot \\hat{\\mathbf{u}}) $$\n        $$ c = \\|\\mathbf{r}_0\\|^2 - r_v^2 $$\n        Again, we solve for $s$ using the quadratic formula. The particle starts outside the sphere, so $c0$. A positive (forward) intersection is possible only if the ray is directed towards the sphere, which generally corresponds to $\\mathbf{r}_0 \\cdot \\hat{\\mathbf{u}}  0$. The smallest root $s  \\epsilon$ is the required distance.\n\n    The overall distance to boundary, $S_b$, is the minimum of all valid, positive distances calculated for these four surfaces. The surface corresponding to this minimum distance is the one that will be hit.\n\n3.  **Determine Final Event**:\n    The final step is to compare $S_c$ and $S_b$.\n    -   If $S_c  S_b$, the event is a **collision**. The event distance is $s^\\star = S_c$, the event type code is $0$, and the surface identifier is $-1$.\n    -   If $S_b \\le S_c$, the event is a **boundary crossing** (favoring boundary crossing in a tie). The event distance is $s^\\star = S_b$, the event type code is $1$, and the surface identifier is that of the surface hit ($0, 1, 2,$ or $3$).\n\nThe procedure is applied to each test case, and the results are formatted as specified.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to process all test cases for the particle tracking problem.\n    \"\"\"\n\n    # --- Geometric and physical constants from the problem statement ---\n    R = 0.5  # Cylinder radius in meters\n    Z_MIN = -0.6  # Lower z-plane bound in meters\n    Z_MAX = 0.6  # Upper z-plane bound in meters\n    R_V = 0.1  # Sphere void radius in meters\n    \n    # Numerical tolerance for floating-point comparisons\n    EPSILON = 1e-9\n\n    def compute_event(r0, u_unnorm, sigma_t, xi):\n        \"\"\"\n        Calculates the next event (collision or boundary cross) for a single particle.\n\n        Args:\n            r0 (tuple): Initial position vector (x, y, z).\n            u_unnorm (tuple): Unnormalized direction vector.\n            sigma_t (float): Macroscopic total cross-section in m^-1.\n            xi (float): Uniform random variate for collision sampling.\n\n        Returns:\n            list: [event_type, event_distance, surface_id]\n        \"\"\"\n        r0 = np.array(r0, dtype=float)\n        u_unnorm = np.array(u_unnorm, dtype=float)\n\n        # 1. Normalize the direction vector\n        norm_u = np.linalg.norm(u_unnorm)\n        if norm_u  EPSILON:\n             # This case should not occur with the given test data.\n             # Represents a stationary particle. Treat as no event.\n             return [0, float('inf'), -1]\n        u = u_unnorm / norm_u\n\n        # 2. Calculate the stochastic distance to collision (Sc)\n        # The problem specifies using ln(1-xi). Since xi is a U(0,1) variate,\n        # 1-xi is also a U(0,1) variate.\n        s_c = -np.log(1 - xi) / sigma_t\n\n        # 3. Calculate deterministic distances to all boundaries\n        boundary_distances = []\n\n        # Distance to cylinder lateral surface (x^2 + y^2 = R^2), ID=0\n        a_cyl = u[0]**2 + u[1]**2\n        if a_cyl  EPSILON:\n            b_cyl = 2 * (r0[0] * u[0] + r0[1] * u[1])\n            c_cyl = r0[0]**2 + r0[1]**2 - R**2\n            delta_cyl = b_cyl**2 - 4 * a_cyl * c_cyl\n            if delta_cyl = 0:\n                sqrt_delta = np.sqrt(delta_cyl)\n                s1 = (-b_cyl - sqrt_delta) / (2 * a_cyl)\n                s2 = (-b_cyl + sqrt_delta) / (2 * a_cyl)\n                if s1  EPSILON:\n                    boundary_distances.append((s1, 0))\n                elif s2  EPSILON:\n                    boundary_distances.append((s2, 0))\n\n        # Distances to axial planes (z=Z_MIN, z=Z_MAX), ID=1, 2\n        if abs(u[2])  EPSILON:\n            # Plane z = Z_MIN\n            s_zmin = (Z_MIN - r0[2]) / u[2]\n            if s_zmin  EPSILON:\n                boundary_distances.append((s_zmin, 1))\n            # Plane z = Z_MAX\n            s_zmax = (Z_MAX - r0[2]) / u[2]\n            if s_zmax  EPSILON:\n                boundary_distances.append((s_zmax, 2))\n\n        # Distance to sphere surface (x^2 + y^2 + z^2 = R_V^2), ID=3\n        # Equation: s^2 + 2(r0 . u)s + (|r0|^2 - R_V^2) = 0\n        b_sph = 2 * np.dot(r0, u)\n        c_sph = np.dot(r0, r0) - R_V**2\n        delta_sph = b_sph**2 - 4 * c_sph  # a=1\n        if delta_sph = 0:\n            sqrt_delta = np.sqrt(delta_sph)\n            s1 = (-b_sph - sqrt_delta) / 2\n            s2 = (-b_sph + sqrt_delta) / 2\n            if s1  EPSILON:\n                # Smallest positive root is the first intersection\n                boundary_distances.append((s1, 3))\n            elif s2  EPSILON:\n                # This occurs if starting on or inside the sphere and moving out.\n                # Since we start outside, this is a sanity check.\n                boundary_distances.append((s2, 3))\n\n        # 4. Determine distance to nearest boundary (Sb)\n        if not boundary_distances:\n            s_b = float('inf')\n            surface_id = -1\n        else:\n            s_b, surface_id = min(boundary_distances, key=lambda item: item[0])\n            \n        # 5. Compare Sc and Sb to determine the event\n        # Per problem statement, favor boundary crossing on ties (Sb = Sc)\n        if s_c  s_b:\n            # Collision event\n            event_type = 0\n            event_distance = s_c\n            final_surface_id = -1\n        else:\n            # Boundary crossing event\n            event_type = 1\n            event_distance = s_b\n            final_surface_id = surface_id\n\n        return [event_type, round(event_distance, 6), final_surface_id]\n\n    # --- Test suite from the problem statement ---\n    test_cases = [\n        # (r0, u_unnormalized, sigma_t, xi)\n        ((0.10, 0.20, 0.00), (1.0, 1.0, 0.5), 2.0, 0.30),\n        ((0.20, 0.00, 0.55), (0.0, 0.0, 1.0), 5.0, 0.95),\n        ((0.499, 0.000, 0.000), (0.0, 1.0, 0.0), 100.0, 0.05),\n        ((0.15, 0.00, 0.00), (-1.0, 0.0, 0.0), 0.5, 0.40),\n        ((0.12, 0.00, 0.00), (1.0, 0.0, 0.0), 2.0, 0.90),\n    ]\n\n    results = []\n    for case in test_cases:\n        r0, u_unnorm, sigma_t, xi = case\n        result = compute_event(r0, u_unnorm, sigma_t, xi)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}