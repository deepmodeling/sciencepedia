{
    "hands_on_practices": [
        {
            "introduction": "在我们能够追踪粒子路径之前，我们常常需要回答一个更基本的问题：粒子当前在什么位置？本练习将指导您实现一个鲁棒的算法，以确定一个点是在一个复杂的构造实体几何（CSG）对象的内部、外部，还是在边界上。掌握这一点对于初始化粒子状态和处理边界条件至关重要，尤其是在需要考虑有限精度计算带来的挑战时。",
            "id": "4240630",
            "problem": "一个三维构造实体几何区域由基本的隐式图元和布尔集合运算构建而成，用于表示核反应堆模拟中的一个燃料棒栅元。考虑一个笛卡尔坐标系，其坐标轴 $x$、$y$ 和 $z$ 以米为单位。一个基本实体由不等式 $g(\\mathbf{x}) \\le 0$ 定义，其中 $\\mathbf{x} = (x,y,z)$，$g$ 是一个连续标量场。当不等式成立时，点位于基本体内部；当不等式严格不成立时，点位于外部；当不等式以等式形式成立时，点位于边界上。本问题中使用的核心构造图元是半空间和直圆柱体。一个与单位法向量为 $\\mathbf{n}$、标量偏移为 $d$ 的平面相关联的半空间，由 $g(\\mathbf{x}) = \\mathbf{n} \\cdot \\mathbf{x} - d \\le 0$ 定义。一个与 $z$ 轴对齐、半径为 $R$ 的直圆柱体，由 $g(\\mathbf{x}) = \\sqrt{x^2 + y^2} - R \\le 0$ 定义。有限高度的圆柱体是通过将无限圆柱体与两个轴向半空间相交生成的。复合实体是通过使用并集运算 $\\cup$、交集运算 $\\cap$ 和差集运算 $\\setminus$ 从基本图元创建的，这些运算在标准的集合论意义上进行解释。\n\n在核反应堆模拟的粒子输运中，点相对于复合构造实体几何区域的分类必须在有限精度下是鲁棒的。给定一个数值容差 $\\varepsilon > 0$（单位为米），您的任务是推导、论证并实现一个鲁棒的点分类算法。该算法对于任何由指定图元和布尔运算构建的复合区域，都能返回一个整数代码，以指示点 $\\mathbf{x}$ 与该区域的关系：\n- $1$ 如果 $\\mathbf{x}$ 在内部，\n- $0$ 如果 $\\mathbf{x}$ 在边界上或在边界的容差范围内，\n- $-1$ 如果 $\\mathbf{x}$ 在外部。\n\n您必须从以下基础出发进行推导：\n- 针对隐式图元 $g(\\mathbf{x}) \\le 0$ 的内部、边界和外部的数学定义。\n- 应用于由这些图元定义的集合的布尔集合运算 $\\cup$、$\\cap$ 和 $\\setminus$ 的标准语义。\n- 边界分类必须通过将数值容差 $\\varepsilon$ 纳入决策标准来反映有限精度，确保决策对于蒙特卡洛粒子输运在物理上和数值上都是合理的。\n\n按如下方式构造燃料棒栅元几何形状，所有长度均以米表示：\n- 令 $L = 0.01$ 为一个轴对齐的立方体区域 $A$ 的半边长，该区域由六个半空间 $x \\le L$、$x \\ge -L$、$y \\le L$、$y \\ge -L$、$z \\le L$ 和 $z \\ge -L$ 定义。\n- 令 $R = 0.0045$ 为一个与 $z$ 轴对齐的直圆柱体 $B$ 的半径。通过将该圆柱体与两个半空间 $z \\le L$ 和 $z \\ge -L$ 相交，将圆柱体的高度限制在立方体的高度范围内，从而创建一个有限圆柱体。\n- 将慢化剂区域 $M$ 定义为集合差 $M = A \\setminus B$。\n\n使用容差 $\\varepsilon = 5 \\times 10^{-7}$ 米。实现一个程序，对以下测试点 $\\mathbf{x}$（单位为米）相对于区域 $M$ 进行分类：\n1. $\\mathbf{x}_1 = (0.008, 0.0, 0.0)$。\n2. $\\mathbf{x}_2 = (0.002, 0.0, 0.0)$。\n3. $\\mathbf{x}_3 = (R + 2.5 \\times 10^{-7}, 0.0, 0.0)$。\n4. $\\mathbf{x}_4 = (L - 3.0 \\times 10^{-7}, 0.0, 0.0)$。\n5. $\\mathbf{x}_5 = (R + 3.0 \\times 10^{-7}, 0.0, L - 4.0 \\times 10^{-7})$。\n6. $\\mathbf{x}_6 = (0.02, 0.0, 0.0)$。\n\n确保分类决策以一种与隐式定义和布尔集合语义在科学上一致的方式，包含了容差 $\\varepsilon$。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，例如 $[c_1,c_2,c_3,c_4,c_5,c_6]$，其中每个 $c_i$ 是点 $\\mathbf{x}_i$ 相对于 $M$ 的整数代码。\n\n所有坐标和容差都必须以米为单位处理。本问题不使用角度。要求的最终输出格式仅为一行：一个用方括号括起来的逗号分隔列表，按指定顺序列出六个测试点的六个整数分类代码。",
            "solution": "该问题要求开发并实现一个鲁棒算法，用以分类一个点相对于使用构造实体几何（CSG）定义的复合实体的位置。该分类必须通过引入一个容差 $\\varepsilon$ 来考虑有限的数值精度。一个点 $\\mathbf{x}$ 可能的分类为：内部（$1$）、在边界上或边界的容差范围内（$0$），或外部（$-1$）。\n\n解决方案的推导分为三个主要步骤：首先，为单个基本实体建立一个鲁棒的分类规则；其次，推导在布尔集合运算下组合这些分类的规则；第三，将这些原则应用于特定的燃料棒栅元几何形状。\n\n**步骤 1：基本实体的鲁棒分类**\n\n一个基本实体由不等式 $g(\\mathbf{x}) \\le 0$ 定义，其中 $\\mathbf{x} = (x, y, z)$ 是 $\\mathbb{R}^3$ 中的一个点。对于本问题中使用的基本图元（具有单位法向量的半空间和直圆柱体），函数 $g(\\mathbf{x})$ 可以解释为点 $\\mathbf{x}$ 到实体边界的有向距离。负值表示点在内部，正值表示点在外部，零表示点恰好在边界上。\n\n为了创建一个对有限精度算术鲁棒的分类，我们在真实边界周围引入一个宽度为 $2\\varepsilon$ 的容差带。真实边界是满足 $g(\\mathbf{x}) = 0$ 的点集。容差区域是满足 $|g(\\mathbf{x})| \\le \\varepsilon$ 的点集。\n\n基于此，我们为一个基本实体定义三个分类区域：\n- **内部（代码 $1$）**：点“安全地”位于实体内部，意味着它在真实边界内部，且距离大于 $\\varepsilon$。这对应于 $g(\\mathbf{x})  -\\varepsilon$。\n- **外部（代码 $-1$）**：点“安全地”位于实体外部，意味着它在真实边界外部，且距离大于 $\\varepsilon$。这对应于 $g(\\mathbf{x}) > \\varepsilon$。\n- **在边界上（代码 $0$）**：点位于边界上或附近，即落在容差带内。这对应于 $-\\varepsilon \\le g(\\mathbf{x}) \\le \\varepsilon$。\n\n令 $C(\\mathbf{x})$ 表示点 $\\mathbf{x}$ 相对于由 $g(\\mathbf{x}) \\le 0$ 定义的基本图元的分类代码。规则如下：\n$$\nC(\\mathbf{x}) = \\begin{cases} \n1  \\text{如果 } g(\\mathbf{x})  -\\varepsilon \\\\\n-1 \\text{如果 } g(\\mathbf{x}) > \\varepsilon \\\\\n0  \\text{如果 } -\\varepsilon \\le g(\\mathbf{x}) \\le \\varepsilon \n\\end{cases}\n$$\n\n**步骤 2：CSG 布尔运算的分类规则**\n\n复合实体是通过对更简单的实体应用集合运算形成的。设 $S_1$ 和 $S_2$ 为两个实体， $c_1$ 和 $c_2$ 分别是点 $\\mathbf{x}$ 相对于 $S_1$ 和 $S_2$ 的分类代码。我们需要找到复合实体 $S_1 \\cap S_2$、$S_1 \\cup S_2$ 和 $S_1 \\setminus S_2$ 的分类代码。\n\n- **交集 ($S_1 \\cap S_2$)**：一个点只有在同时位于 $S_1$ 和 $S_2$ 内部时，才位于交集的内部。如果一个点位于 $S_1$ 或 $S_2$ 的外部，则它位于交集的外部。如果一个点位于一个实体的边界上，同时位于另一个实体的内部或边界上，则它位于交集的边界上。这个逻辑可以用最小值函数来捕捉：\n  $$c_{S_1 \\cap S_2} = \\min(c_1, c_2)$$\n\n- **并集 ($S_1 \\cup S_2$)**：如果一个点位于 $S_1$ 或 $S_2$ 的内部，则它位于并集的内部。一个点只有在同时位于两个实体外部时，才位于并集的外部。如果一个点位于一个实体的边界上，同时位于另一个实体的外部或边界上，则它位于并集的边界上。这个逻辑可以用最大值函数来捕捉：\n  $$c_{S_1 \\cup S_2} = \\max(c_1, c_2)$$\n\n- **差集 ($S_1 \\setminus S_2$)**：集合差等价于与补集的交集，即 $S_1 \\setminus S_2 = S_1 \\cap S_2^c$。对于由 $g_2(\\mathbf{x}) \\le 0$ 定义的实体 $S_2$，其补集 $S_2^c$ 的内部/外部区域是翻转的。如果一个点对于 $S_2$ 的分类是 $c_2$，那么它对于 $S_2^c$ 的分类就是 $-c_2$。应用交集规则：\n  $$c_{S_1 \\setminus S_2} = \\min(c_1, -c_2)$$\n\n**步骤 3：应用于燃料棒栅元几何形状**\n\n慢化剂区域定义为 $M = A \\setminus B$，其中 $A$ 是一个立方体，$B$ 是一个有限圆柱体。\n\n- **区域 A (立方体)**：该立方体定义为六个半空间的交集：\n  $g_1(\\mathbf{x}) = x - L \\le 0$\n  $g_2(\\mathbf{x}) = -x - L \\le 0$ (由 $x \\ge -L$ 得出)\n  $g_3(\\mathbf{x}) = y - L \\le 0$\n  $g_4(\\mathbf{x}) = -y - L \\le 0$ (由 $y \\ge -L$ 得出)\n  $g_5(\\mathbf{x}) = z - L \\le 0$\n  $g_6(\\mathbf{x}) = -z - L \\le 0$ (由 $z \\ge -L$ 得出)\n  \n  由于 $A$ 是一个交集，其分类代码 $c_A$ 是其组成图元的分类代码的最小值：\n  $$c_A(\\mathbf{x}) = \\min_{i=1..6} C_i(\\mathbf{x})$$\n  其中 $C_i(\\mathbf{x})$ 是基于 $g_i(\\mathbf{x})$ 的分类。\n\n- **区域 B (有限圆柱体)**：该有限圆柱体是一个无限圆柱体和两个轴向半空间的交集：\n  $g_7(\\mathbf{x}) = \\sqrt{x^2 + y^2} - R \\le 0$\n  $g_8(\\mathbf{x}) = z - L \\le 0$\n  $g_9(\\mathbf{x}) = -z - L \\le 0$\n  \n  类似地，其分类代码 $c_B$ 是这三个图元代码的最小值：\n  $$c_B(\\mathbf{x}) = \\min(C_7(\\mathbf{x}), C_8(\\mathbf{x}), C_9(\\mathbf{x}))$$\n\n- **区域 M (慢化剂)**：慢化剂是集合差 $A \\setminus B$。使用推导出的规则，其分类代码 $c_M$ 为：\n  $$c_M(\\mathbf{x}) = \\min(c_A(\\mathbf{x}), -c_B(\\mathbf{x}))$$\n\n至此，算法的推导完成。实现将涉及为每个图元的 $g(\\mathbf{x})$ 定义函数，一个通用的图元分类函数，然后根据 CSG 树结构组合结果，以对每个测试点进行分类。常量值为 $L=0.01$、$R=0.0045$ 和 $\\varepsilon = 5 \\times 10^{-7}$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the robust point classification problem for the specified pin cell geometry.\n    \"\"\"\n    \n    # Define constants from the problem statement\n    L = 0.01  # half-edge length of the cube, in meters\n    R = 0.0045  # radius of the cylinder, in meters\n    EPS = 5e-7  # numerical tolerance, in meters\n\n    # Define the test points from the problem statement\n    test_cases = [\n        (0.008, 0.0, 0.0),\n        (0.002, 0.0, 0.0),\n        (R + 2.5e-7, 0.0, 0.0),\n        (L - 3.0e-7, 0.0, 0.0),\n        (R + 3.0e-7, 0.0, L - 4.0e-7),\n        (0.02, 0.0, 0.0)\n    ]\n\n    def classify_primitive(d, eps):\n        \"\"\"\n        Classifies a point based on its signed distance 'd' to a primitive's surface.\n        \n        Args:\n            d (float): The value of the implicit function g(x), representing signed distance.\n            eps (float): The numerical tolerance.\n            \n        Returns:\n            int: 1 for inside, 0 for on boundary, -1 for outside.\n        \"\"\"\n        if d  -eps:\n            return 1  # Safely inside\n        elif d  eps:\n            return -1 # Safely outside\n        else:\n            return 0  # On or within tolerance of the boundary\n\n    def classify_point_in_moderator(point):\n        \"\"\"\n        Classifies a point relative to the moderator region M = A \\ B.\n        \n        Args:\n            point (tuple): The (x, y, z) coordinates of the point.\n            \n        Returns:\n            int: The classification code for the point relative to M.\n        \"\"\"\n        x, y, z = point\n\n        # --- Classification for Region A (Cube) ---\n        # A is the intersection of 6 half-spaces.\n        # The classification for an intersection is the minimum of the component classifications.\n        \n        # g(x) = x - L = 0\n        c1 = classify_primitive(x - L, EPS)\n        # g(x) = -x - L = 0  (from x = -L)\n        c2 = classify_primitive(-x - L, EPS)\n        # g(y) = y - L = 0\n        c3 = classify_primitive(y - L, EPS)\n        # g(y) = -y - L = 0 (from y = -L)\n        c4 = classify_primitive(-y - L, EPS)\n        # g(z) = z - L = 0\n        c5 = classify_primitive(z - L, EPS)\n        # g(z) = -z - L = 0 (from z = -L)\n        c6 = classify_primitive(-z - L, EPS)\n        \n        c_A = min(c1, c2, c3, c4, c5, c6)\n\n        # --- Classification for Region B (Finite Cylinder) ---\n        # B is the intersection of an infinite cylinder and two half-spaces.\n        \n        # g(r) = sqrt(x^2 + y^2) - R = 0\n        c7 = classify_primitive(np.sqrt(x**2 + y**2) - R, EPS)\n        # g(z) = z - L = 0\n        c8 = classify_primitive(z - L, EPS)\n        # g(z) = -z - L = 0\n        c9 = classify_primitive(-z - L, EPS)\n        \n        c_B = min(c7, c8, c9)\n\n        # --- Classification for Region M = A \\ B ---\n        # The classification for a set difference (S1 \\ S2) is min(c1, -c2).\n        c_M = min(c_A, -c_B)\n        \n        return c_M\n\n    results = []\n    for case in test_cases:\n        result = classify_point_in_moderator(case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "粒子追踪的核心是确定一个粒子在撞击边界前能行进多远。本练习要求您从第一性原理出发，精确计算一个中子飞行到其在CSG定义区域内遇到的第一个表面的距离。这个纸笔练习能够加深您对底层解析几何的理解，以及在多个相交表面中选择最近交点的逻辑。",
            "id": "4240618",
            "problem": "一个中子在使用构造实体几何（CSG）的反应堆物理蒙特卡罗模拟环境中被追踪。几何区域 $\\mathcal{R}$ 由基本几何体的布尔组合定义：\n- 一个与 $z$ 轴对齐、半径为 $10\\,\\text{cm}$ 的正圆柱体，即集合 $\\{(x,y,z): x^{2}+y^{2} \\leq 100\\}$，\n- 与轴向平板 $\\{(x,y,z): 0 \\leq z \\leq 20\\,\\text{cm}\\}$ 相交，\n- 并从中减去一个球形空腔，该球体的球心位于 $(3\\,\\text{cm}, 2\\,\\text{cm}, 8\\,\\text{cm})$，半径为 $2\\,\\text{cm}$。\n\n形式上，\n$$\n\\mathcal{R}=\\Big(\\{(x,y,z): x^{2}+y^{2} \\leq 100\\}\\ \\cap\\ \\{(x,y,z): 0 \\leq z \\leq 20\\}\\Big)\\ \\setminus\\ \\{(x,y,z): (x-3)^{2}+(y-2)^{2}+(z-8)^{2} \\leq 4\\}.\n$$\n一个中子从位置 $p_{0}=(0\\,\\text{cm}, 0\\,\\text{cm}, 5\\,\\text{cm})$ 开始，并沿着射线被追踪\n$$\nr(t)=p_{0}+t\\,\\hat{u},\n$$\n其中 $t \\ge 0$ 是以 $\\text{cm}$ 为单位的路程长度，$\\hat{u}$ 是通过将向量 $v=(3,2,3)$ 归一化得到的单位方向向量。\n\n仅从几何表面的定义和射线的参数表示出发，确定中子沿射线遇到的第一个 $\\mathcal{R}$ 边界的自由飞行距离 $t^{\\ast}$。您的答案必须以厘米为单位，给出一个单一的精确解析表达式。不要进行近似或四舍五入；以封闭形式表示最终结果。",
            "solution": "所述问题具有科学依据、是适定的、客观的，并包含获得唯一解所需的所有信息。区域 $\\mathcal{R}$ 是一个标准的构造实体几何（CSG）对象。粒子追踪是一个射线追踪问题。我们首先验证起始位置 $p_{0}=(0, 0, 5)$ 是否在区域 $\\mathcal{R}$ 内部。\n该区域由一个实心圆柱体和一个平板的交集，并从中减去一个球形空腔所定义。\n1.  圆柱体条件：$x^{2}+y^{2} \\leq 100$。对于 $p_{0}$，我们有 $0^{2}+0^{2}=0 \\leq 100$。该点在圆柱体内部。\n2.  平板条件：$0 \\leq z \\leq 20$。对于 $p_{0}$，我们有 $0 \\leq 5 \\leq 20$。该点在平板内部。\n3.  球体条件：$(x-3)^{2}+(y-2)^{2}+(z-8)^{2} > 4$。对于 $p_{0}$，我们有 $(0-3)^{2}+(0-2)^{2}+(5-8)^{2} = 9+4+9=22$。由于 $22 > 4$，该点在球形空腔外部。\n由于所有条件都满足，起始点 $p_{0}$ 位于材料区域 $\\mathcal{R}$ 内部。任务是找到从 $p_{0}$ 沿指定方向到 $\\mathcal{R}$ 任一边界的最短正路程长度 $t^{\\ast}$。\n\n中子的路径是一条射线 $r(t) = p_{0} + t\\,\\hat{u}$，其中 $t \\ge 0$。\n起始位置为 $p_{0} = (0, 0, 5)$。\n方向向量为 $v = (3, 2, 3)$。其模长为 $\\|v\\| = \\sqrt{3^{2}+2^{2}+3^{2}} = \\sqrt{9+4+9} = \\sqrt{22}$。\n单位方向向量为 $\\hat{u} = \\frac{v}{\\|v\\|} = \\frac{1}{\\sqrt{22}}(3, 2, 3)$。\n射线的参数方程为：\n$$\nr(t) = (x(t), y(t), z(t)) = \\left( \\frac{3t}{\\sqrt{22}}, \\frac{2t}{\\sqrt{22}}, 5 + \\frac{3t}{\\sqrt{22}} \\right).\n$$\n$\\mathcal{R}$ 的边界由圆柱体、平板和球体的表面定义。我们必须找到使 $r(t)$ 与这些表面之一相交的最小正数 $t$。\n\n1.  **与圆柱面的交点：**\n    圆柱面由 $x^{2}+y^{2}=100$ 给出。代入射线方程：\n    $$\n    \\left(\\frac{3t}{\\sqrt{22}}\\right)^{2} + \\left(\\frac{2t}{\\sqrt{22}}\\right)^{2} = 100\n    $$\n    $$\n    \\frac{9t^{2}}{22} + \\frac{4t^{2}}{22} = 100\n    $$\n    $$\n    \\frac{13t^{2}}{22} = 100 \\implies t^{2} = \\frac{2200}{13}\n    $$\n    由于我们要求 $t > 0$，到圆柱壁的距离为 $t_{cyl} = \\sqrt{\\frac{2200}{13}} = 10\\sqrt{\\frac{22}{13}}$。\n\n2.  **与平板平面的交点：**\n    平板由 $0 \\leq z \\leq 20$ 定义。边界面为 $z=0$ 和 $z=20$。粒子从 $z_0=5$ 开始，其速度的 z 分量为正，因此在前进方向上它只能撞击 $z=20$ 平面。\n    与顶面 $z(t)=20$ 的交点：\n    $$\n    5 + \\frac{3t}{\\sqrt{22}} = 20 \\implies \\frac{3t}{\\sqrt{22}} = 15 \\implies t = \\frac{15\\sqrt{22}}{3} = 5\\sqrt{22}\n    $$\n    设此距离为 $t_{z} = 5\\sqrt{22}$。\n    对于底面 $z(t)=0$，我们得到 $5 + \\frac{3t}{\\sqrt{22}} = 0$，这会得出一个负值 $t=-\\frac{5\\sqrt{22}}{3}$。这对应于后向的交点，不是一个有效的自由飞行距离。\n\n3.  **与球形空腔的交点：**\n    球体的球心为 $c=(3, 2, 8)$，半径为 $R=2$。其表面方程为 $(x-3)^{2}+(y-2)^{2}+(z-8)^{2}=4$。\n    我们寻求满足 $\\|r(t)-c\\|^{2} = R^{2}$ 的 $t$。这可以写成 $\\|(p_{0}-c) + t\\hat{u}\\|^{2} = R^{2}$。\n    展开点积：$\\|p_{0}-c\\|^{2} + 2t (\\hat{u} \\cdot (p_{0}-c)) + t^{2}\\|\\hat{u}\\|^{2} = R^{2}$。\n    令 $\\Delta p = p_{0}-c = (0-3, 0-2, 5-8) = (-3, -2, -3)$。\n    二次方程 $t^2 + 2(\\hat{u}\\cdot\\Delta p) t + (\\|\\Delta p\\|^2 - R^2) = 0$ 的系数为：\n    $\\|\\Delta p\\|^{2} = (-3)^{2} + (-2)^{2} + (-3)^{2} = 9+4+9=22$。\n    $\\hat{u} \\cdot \\Delta p = \\frac{1}{\\sqrt{22}}(3, 2, 3) \\cdot (-3, -2, -3) = \\frac{1}{\\sqrt{22}}(-9-4-9) = \\frac{-22}{\\sqrt{22}} = -\\sqrt{22}$。\n    $R^{2} = 2^{2} = 4$。\n    关于 $t$ 的二次方程是：\n    $$\n    t^{2} + 2(-\\sqrt{22})t + (22-4) = 0\n    $$\n    $$\n    t^{2} - 2\\sqrt{22}t + 18 = 0\n    $$\n    使用求根公式 $t = \\frac{-b \\pm \\sqrt{b^{2}-4ac}}{2a}$：\n    $$\n    t = \\frac{2\\sqrt{22} \\pm \\sqrt{(-2\\sqrt{22})^{2} - 4(1)(18)}}{2} = \\frac{2\\sqrt{22} \\pm \\sqrt{4 \\cdot 22 - 72}}{2}\n    $$\n    $$\n    t = \\frac{2\\sqrt{22} \\pm \\sqrt{88 - 72}}{2} = \\frac{2\\sqrt{22} \\pm \\sqrt{16}}{2} = \\frac{2\\sqrt{22} \\pm 4}{2} = \\sqrt{22} \\pm 2\n    $$\n    这给出两个正解，$t_{sph,1} = \\sqrt{22}-2$ 和 $t_{sph,2} = \\sqrt{22}+2$。它们分别对应于进入和离开球体的距离。由于中子从球体外部开始，第一个交点距离是较小的一个，即 $t_{sph} = \\sqrt{22}-2$。\n\n4.  **确定自由飞行距离：**\n    自由飞行距离 $t^{\\ast}$ 是计算出的正交点距离中的最小值：\n    $$\n    t^{\\ast} = \\min(t_{cyl}, t_{z}, t_{sph}) = \\min\\left(10\\sqrt{\\frac{22}{13}}, 5\\sqrt{22}, \\sqrt{22}-2\\right)\n    $$\n    我们必须对这些值进行解析比较。\n    我们知道 $4  \\sqrt{22}  5$。因此，$t_{sph} = \\sqrt{22}-2$ 是一个介于 2 和 3 之间的正值。\n    -   比较 $t_{sph}$ 和 $t_{z}$：\n        $t_{sph} = \\sqrt{22}-2  \\sqrt{22}  5\\sqrt{22} = t_{z}$。因此，$t_{sph}  t_{z}$。\n    -   比较 $t_{sph}$ 和 $t_{cyl}$：\n        $t_{sph} = \\sqrt{22}-2$ 和 $t_{cyl} = 10\\sqrt{\\frac{22}{13}}$。由于两者都为正，我们可以比较它们的平方。\n        $(t_{sph})^{2} = (\\sqrt{22}-2)^{2} = 22 - 4\\sqrt{22} + 4 = 26 - 4\\sqrt{22}$。\n        $(t_{cyl})^{2} = \\left(10\\sqrt{\\frac{22}{13}}\\right)^{2} = 100 \\cdot \\frac{22}{13} = \\frac{2200}{13}$。\n        由于 $4  \\sqrt{22}  5$，我们有 $16  4\\sqrt{22}  20$。\n        这意味着 $26-20  26-4\\sqrt{22}  26-16$，所以 $6  (t_{sph})^{2}  10$。\n        对于 $(t_{cyl})^{2} = \\frac{2200}{13}$，我们注意到 $13 \\times 100 = 1300$，所以 $\\frac{2200}{13} > 100$。\n        显然，$6  (t_{sph})^{2}  10  100  (t_{cyl})^{2}$。\n        由于距离是正的，我们可以得出结论 $t_{sph}  t_{cyl}$。\n\n最小距离是 $t_{sph}$。中子遇到的第一个边界是球形空腔的表面。自由飞行距离是 $t^{\\ast} = \\sqrt{22}-2$。",
            "answer": "$$\\boxed{\\sqrt{22}-2}$$"
        },
        {
            "introduction": "在完整的蒙特卡罗模拟中，粒子的路径是一系列事件，而不仅仅是几何穿越。这项动手编程任务将几何追踪与随机物理过程相结合，要求您决定一个粒子的“命运”：它是会首先与材料发生碰撞，还是会穿过一个边界？实现这种“下一事件”逻辑是构建一个真实的粒子输运代码的关键一步。",
            "id": "4240629",
            "problem": "您的任务是为构造实体几何（CSG）单元中的中性粒子追踪实现一个边界距离和下一事件决策算法，该算法需适用于核反应堆模拟。此模型纯粹是几何和随机的，基于第一性原理。粒子在事件之间沿直线段传播。事件要么是材料内部的碰撞，要么是改变粒子当前CSG区域的表面穿越。目标是利用物理上合理的几何形状和随机抽样，计算哪个事件首先发生以及发生的距离。\n\n您必须使用的基本原理是：\n- 粒子射线的直线运动学：位于位置 $\\mathbf{r}_0$、单位方向为 $\\hat{\\mathbf{u}}$ 的粒子遵循参数路径 $\\mathbf{r}(s) = \\mathbf{r}_0 + s \\hat{\\mathbf{u}}$，其中路径长度 $s \\ge 0$。\n- 碰撞的发生由一个泊松过程建模，其宏观总截面为 $\\Sigma_t$（单位为 $\\mathrm{m}^{-1}$）。到碰撞的自由程长度 $S_c$ 服从速率为 $\\Sigma_t$ 的指数分布。通过对均匀分布随机变量 $\\xi \\in (0,1)$ 进行逆变换采样，抽样得到的自由程长度为 $S_c = -\\ln(1-\\xi)/\\Sigma_t$，单位为米。\n- 构造实体几何通过定义了布尔集合运算的基本体的隐式表面来表达。\n\n几何定义：\n- 设 $A$ 是一个以z轴为中心、半径为 $R$ 的直立圆柱体与一个由平面 $z=z_{\\min}$ 和 $z=z_{\\max}$ 限定的轴向平板的交集。形式上，\n$$\nA = \\left\\{(x,y,z) \\,\\middle|\\, x^2 + y^2 \\le R^2 \\right\\} \\cap \\left\\{(x,y,z) \\,\\middle|\\, z_{\\min} \\le z \\le z_{\\max} \\right\\}.\n$$\n- 设 $B$ 是一个以原点为中心、半径为 $r_v$ 的球形空腔，\n$$\nB = \\left\\{(x,y,z) \\,\\middle|\\, x^2 + y^2 + z^2 \\le r_v^2 \\right\\}.\n$$\n- 充满材料的追踪单元 $C$ 是CSG差集 $C = A \\setminus B$，即在 $A$ 内部但不在 $B$ 内部的点。\n\n事件逻辑：\n- 沿着射线 $\\mathbf{r}(s) = \\mathbf{r}_0 + s \\hat{\\mathbf{u}}$ 的下一个事件发生在距离 $s^\\star = \\min\\{S_c, S_b\\}$ 处，其中 $S_b$ 是到任何能切换其在 $C$ 中成员资格的 $C$ 边界的最小正距离。\n- 如果 $S_b  S_c$，则发生穿过边界事件；如果 $S_c  S_b$，则发生碰撞事件。若距离相等，则优先选择穿过边界。\n- 您必须假设粒子起始于 $C$ 内部（即，在 $A$ 内部且在 $B$ 外部），$\\hat{\\mathbf{u}}$ 是一个单位向量。距离必须以米为单位计算，并报告四舍五入到六位小数的结果。\n\n需要实现的边界距离规则：\n- 圆柱侧表面 ($x^2 + y^2 = R^2$)：求解满足 $(x_0 + s u_x)^2 + (y_0 + s u_y)^2 = R^2$ 的最小正数 $s$。如果 $(u_x^2 + u_y^2) = 0$，则与圆柱侧表面没有交点。\n- 平面 ($z=z_{\\min}$ 和 $z=z_{\\max}$)：求解 $s = (z_\\text{plane} - z_0)/u_z$。如果 $u_z = 0$，则忽略该平面。\n- 球面 ($x^2 + y^2 + z^2 = r_v^2$)：求解满足 $\\|\\mathbf{r}_0 + s \\hat{\\mathbf{u}}\\|^2 = r_v^2$ 的最小正数 $s$。如果判别式为负，则没有交点。\n\n所有计算都应适当处理数值稳定性，将值为负或接近零的根视为对于前向飞行而言是非物理的。对正值检验使用一个小的容差。\n\n用于输出的表面标识符映射：\n- 圆柱侧表面：$0$。\n- $z=z_{\\min}$ 处的平面：$1$。\n- $z=z_{\\max}$ 处的平面：$2$。\n- 球面：$3$。\n\n程序要求：\n- 实现上述边界距离和下一事件逻辑。\n- 对于每个测试用例，输出一个包含三个值的列表：事件类型代码（整数$0$表示碰撞，整数$1$表示穿过边界）、事件距离 $s^\\star$（单位为米，浮点数，四舍五入到六位小数），以及表面标识符（对于穿过边界是整数；对于碰撞是$-1$）。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，每个元素按顺序对应一个测试用例，并且本身是按规定由三个值组成的列表。\n\n测试套件和参数：\n- 几何常数（请精确使用这些值）：\n  - 圆柱半径 $R = 0.5$ 米。\n  - 轴向边界 $z_{\\min} = -0.6$ 米和 $z_{\\max} = 0.6$ 米。\n  - 球体（空腔）半径 $r_v = 0.1$ 米。\n- 测试用例（每个都是一个元组 $(\\mathbf{r}_0, \\hat{\\mathbf{u}}, \\Sigma_t, \\xi)$）：\n  1. $(\\mathbf{r}_0 = (0.10, 0.20, 0.00), \\hat{\\mathbf{u}} \\propto (1.0, 1.0, 0.5), \\Sigma_t = 2.0\\,\\mathrm{m}^{-1}, \\xi = 0.30)$，其中 $\\hat{\\mathbf{u}}$ 在使用前必须进行归一化。\n  2. $(\\mathbf{r}_0 = (0.20, 0.00, 0.55), \\hat{\\mathbf{u}} = (0.0, 0.0, 1.0), \\Sigma_t = 5.0\\,\\mathrm{m}^{-1}, \\xi = 0.95)$。\n  3. $(\\mathbf{r}_0 = (0.499, 0.000, 0.000), \\hat{\\mathbf{u}} = (0.0, 1.0, 0.0), \\Sigma_t = 100.0\\,\\mathrm{m}^{-1}, \\xi = 0.05)$。\n  4. $(\\mathbf{r}_0 = (0.15, 0.00, 0.00), \\hat{\\mathbf{u}} = (-1.0, 0.0, 0.0), \\Sigma_t = 0.5\\,\\mathrm{m}^{-1}, \\xi = 0.40)$。\n  5. $(\\mathbf{r}_0 = (0.12, 0.00, 0.00), \\hat{\\mathbf{u}} = (1.0, 0.0, 0.0), \\Sigma_t = 2.0\\,\\mathrm{m}^{-1}, \\xi = 0.90)$。\n\n角度单位说明：\n- 方向向量是无量纲的，在进行距离计算前必须归一化为单位长度；不直接使用角度。\n\n最终输出格式：\n- 您的程序必须打印单行，其格式严格为一个包含五个元素的逗号分隔列表，并用方括号括起。\n- 每个元素必须是按所述顺序包含三个值的列表：$[\\text{event\\_type}, \\text{distance\\_m\\_rounded\\_to\\_six\\_decimals}, \\text{surface\\_id}]$。\n- 示例形状（非实际值）：$[[0,0.123456,-1],[1,0.654321,2],[1,0.100000,0],[1,0.050000,3],[0,0.010000,-1]]$。",
            "solution": "用户在计算物理领域，特别是构造实体几何（CSG）体积内的中性粒子追踪方面，提供了一个定义明确的问题。任务是根据粒子的起始位置、方向和材料属性，确定粒子的下一个事件——要么是材料内的碰撞，要么是穿越几何边界。\n\n### 第1步：提取已知信息\n\n- **粒子运动学**：路径为 $\\mathbf{r}(s) = \\mathbf{r}_0 + s \\hat{\\mathbf{u}}$，距离 $s \\ge 0$，其中 $\\mathbf{r}_0$ 是起始位置，$\\hat{\\mathbf{u}}$ 是单位方向向量。\n- **碰撞抽样**：到碰撞的距离 $S_c$ 从速率为 $\\Sigma_t$（宏观总截面）的指数分布中抽样。对于均匀分布的随机变量 $\\xi \\in (0,1)$，抽样公式为 $S_c = -\\ln(1-\\xi)/\\Sigma_t$。\n- **几何定义**：\n    - $A = \\left\\{(x,y,z) \\,\\middle|\\, x^2 + y^2 \\le R^2 \\right\\} \\cap \\left\\{(x,y,z) \\,\\middle|\\, z_{\\min} \\le z \\le z_{\\max} \\right\\}$（一个有限圆柱体）。\n    - $B = \\left\\{(x,y,z) \\,\\middle|\\, x^2 + y^2 + z^2 \\le r_v^2 \\right\\}$（一个球体）。\n    - 追踪单元为 $C = A \\setminus B$。\n- **事件逻辑**：下一个事件发生在距离 $s^\\star = \\min\\{S_c, S_b\\}$ 处，其中 $S_b$ 是到单元 $C$ 任何边界的最小正距离。在距离相等（$S_b = S_c$）的情况下，优先选择穿过边界。假设粒子从 $C$ 内部开始。\n- **边界距离规则**：提供了特定的二次和线性方程，用于找到射线与每个基本表面（圆柱体、平面、球体）的交点距离 $s$。\n- **数值稳定性**：应使用一个小的正容差进行正值检验。对于前向飞行，负的或接近零的根被认为是非物理的。\n- **表面标识符**：圆柱侧面=$0$， $z_{\\min}$ 平面=$1$， $z_{\\max}$ 平面=$2$，球体=$3$。\n- **几何常数**：$R = 0.5\\,\\mathrm{m}$，$z_{\\min} = -0.6\\,\\mathrm{m}$，$z_{\\max} = 0.6\\,\\mathrm{m}$，$r_v = 0.1\\,\\mathrm{m}$。\n- **测试用例**：给出了五个测试用例，每个都提供了 $(\\mathbf{r}_0, \\hat{\\mathbf{u}}, \\Sigma_t, \\xi)$。\n    1. $(\\mathbf{r}_0 = (0.10, 0.20, 0.00), \\hat{\\mathbf{u}} \\propto (1.0, 1.0, 0.5), \\Sigma_t = 2.0\\,\\mathrm{m}^{-1}, \\xi = 0.30)$\n    2. $(\\mathbf{r}_0 = (0.20, 0.00, 0.55), \\hat{\\mathbf{u}} = (0.0, 0.0, 1.0), \\Sigma_t = 5.0\\,\\mathrm{m}^{-1}, \\xi = 0.95)$\n    3. $(\\mathbf{r}_0 = (0.499, 0.000, 0.000), \\hat{\\mathbf{u}} = (0.0, 1.0, 0.0), \\Sigma_t = 100.0\\,\\mathrm{m}^{-1}, \\xi = 0.05)$\n    4. $(\\mathbf{r}_0 = (0.15, 0.00, 0.00), \\hat{\\mathbf{u}} = (-1.0, 0.0, 0.0), \\Sigma_t = 0.5\\,\\mathrm{m}^{-1}, \\xi = 0.40)$\n    5. $(\\mathbf{r}_0 = (0.12, 0.00, 0.00), \\hat{\\mathbf{u}} = (1.0, 0.0, 0.0), \\Sigma_t = 2.0\\,\\mathrm{m}^{-1}, \\xi = 0.90)$\n- **输出格式**：对于每个案例，输出 `[event_type, distance, surface_id]`，其中 `event_type` 对于碰撞为$0$，对于穿过边界为$1$；`distance` 四舍五入到6位小数；`surface_id` 对于碰撞为$-1$。最终输出是一个表示这些结果列表的单行字符串。\n\n### 第2步：使用提取的已知信息进行验证\n\n对问题进行严格验证。\n\n- **科学基础扎实**：该问题在根本上是合理的。它使用标准的、公认的原理来模拟中性粒子输运：直线飞行、由泊松过程（指数自由程）控制的随机碰撞，以及用于几何表示的CSG。这些都是核反应堆分析中蒙特卡罗方法的基石概念。\n- **问题适定**：问题被清晰地说明。几何形状由无歧义的隐式方程定义。基于寻找一组距离的最小值的事件逻辑是明确的。粒子在有效区域 $C$ 内开始的初始条件被明确说明，并已对所有测试用例进行了验证。为每个案例提供了唯一解所需的所有参数。\n- **客观性**：问题以数学精度表达，不含主观或模糊的语言。\n\n该问题没有表现出任何已定义的缺陷（例如，科学上不合理、不完整、矛盾或模糊）。这是一个计算物理学中的标准、可形式化的问题。\n\n### 第3步：结论与行动\n\n问题是**有效的**。将按规定开发和实现一个解决方案。\n\n### 算法解决方案\n\n解决方案涉及为每个测试用例确定两个关键量：到下一次碰撞的随机距离 $S_c$，以及到最近几何边界的确定性距离 $S_b$。这两者中较小的一个决定了粒子的下一个事件。\n\n设粒子的状态由其位置 $\\mathbf{r}_0 = (x_0, y_0, z_0)$ 和其单位方向向量 $\\hat{\\mathbf{u}} = (u_x, u_y, u_z)$ 定义。\n\n1.  **计算到碰撞的距离 ($S_c$)**：\n    该距离使用指数分布的逆变换法进行抽样。给定宏观总截面 $\\Sigma_t$ 和一个均匀分布的随机变量 $\\xi \\in (0,1)$，距离为：\n    $$ S_c = -\\frac{\\ln(1-\\xi)}{\\Sigma_t} $$\n\n2.  **计算到边界的距离 ($S_b$)**：\n    我们必须找到从粒子当前位置到定义单元 $C = A \\setminus B$ 的任何表面的最小正距离 $s > \\epsilon$（其中 $\\epsilon$ 是一个小的容差，例如 $10^{-9}$）。我们分别分析每个基本表面。\n\n    -   **圆柱侧表面 ($x^2 + y^2 = R^2$)**：\n        将射线方程 $\\mathbf{r}(s) = \\mathbf{r}_0 + s\\hat{\\mathbf{u}}$ 代入圆柱方程，得到一个关于 $s$ 的二次方程：$as^2 + bs + c = 0$，其中：\n        $$ a = u_x^2 + u_y^2 $$\n        $$ b = 2(x_0 u_x + y_0 u_y) $$\n        $$ c = x_0^2 + y_0^2 - R^2 $$\n        如果 $a \\approx 0$，粒子平行于 $z$ 轴移动，并且由于它起始于圆柱内部，将永远不会与侧表面相交。否则，我们解这个二次方程。判别式为 $\\Delta = b^2 - 4ac$。如果 $\\Delta  0$，没有交点。如果 $\\Delta \\ge 0$，根为 $s = (-b \\pm \\sqrt{\\Delta})/(2a)$。最小的根 $s > \\epsilon$ 对应于到此表面的距离。\n\n    -   **轴向平面 ($z=z_{\\min}, z=z_{\\max}$)**：\n        与平面 $z=z_{\\text{plane}}$ 的交点通过求解 $z_0 + s u_z = z_{\\text{plane}}$ 找到。如果 $u_z \\neq 0$，距离为：\n        $$ s = \\frac{z_{\\text{plane}} - z_0}{u_z} $$\n        我们只考虑 $s > \\epsilon$ 的情况。存在两个这样的平面，分别在 $z_{\\min}$ 和 $z_{\\max}$。\n\n    -   **球面 ($x^2+y^2+z^2=r_v^2$)**：\n        将射线方程代入球面方程 $\\|\\mathbf{r}_0 + s\\hat{\\mathbf{u}}\\|^2 = r_v^2$ 得到另一个关于 $s$ 的二次方程：$as^2 + bs + c = 0$。由于 $\\hat{\\mathbf{u}}$ 是一个单位向量（$\\|\\hat{\\mathbf{u}}\\|^2 = 1$），系数为：\n        $$ a = 1 $$\n        $$ b = 2 (\\mathbf{r}_0 \\cdot \\hat{\\mathbf{u}}) $$\n        $$ c = \\|\\mathbf{r}_0\\|^2 - r_v^2 $$\n        同样，我们使用二次公式求解 $s$。粒子从球体外部开始，所以 $c>0$。只有当射线朝向球体时，才可能有正的（前向）交点，这通常对应于 $\\mathbf{r}_0 \\cdot \\hat{\\mathbf{u}}  0$。最小的根 $s > \\epsilon$ 是所需的距离。\n\n    到边界的总距离 $S_b$ 是为这四个表面计算出的所有有效正距离中的最小值。与此最小值对应的表面就是将要撞击的表面。\n\n3.  **确定最终事件**：\n    最后一步是比较 $S_c$ 和 $S_b$。\n    -   如果 $S_c  S_b$，事件是一次**碰撞**。事件距离为 $s^\\star = S_c$，事件类型代码为 $0$，表面标识符为 $-1$。\n    -   如果 $S_b \\le S_c$，事件是一次**穿过边界**（在相等时优先选择穿过边界）。事件距离为 $s^\\star = S_b$，事件类型代码为 $1$，表面标识符是被撞击表面的标识符（$0, 1, 2,$ 或 $3$）。\n\n该过程应用于每个测试用例，并按规定格式化结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to process all test cases for the particle tracking problem.\n    \"\"\"\n\n    # --- Geometric and physical constants from the problem statement ---\n    R = 0.5  # Cylinder radius in meters\n    Z_MIN = -0.6  # Lower z-plane bound in meters\n    Z_MAX = 0.6  # Upper z-plane bound in meters\n    R_V = 0.1  # Sphere void radius in meters\n    \n    # Numerical tolerance for floating-point comparisons\n    EPSILON = 1e-9\n\n    def compute_event(r0, u_unnorm, sigma_t, xi):\n        \"\"\"\n        Calculates the next event (collision or boundary cross) for a single particle.\n\n        Args:\n            r0 (tuple): Initial position vector (x, y, z).\n            u_unnorm (tuple): Unnormalized direction vector.\n            sigma_t (float): Macroscopic total cross-section in m^-1.\n            xi (float): Uniform random variate for collision sampling.\n\n        Returns:\n            list: [event_type, event_distance, surface_id]\n        \"\"\"\n        r0 = np.array(r0, dtype=float)\n        u_unnorm = np.array(u_unnorm, dtype=float)\n\n        # 1. Normalize the direction vector\n        norm_u = np.linalg.norm(u_unnorm)\n        if norm_u  EPSILON:\n             # This case should not occur with the given test data.\n             # Represents a stationary particle. Treat as no event.\n             return [0, float('inf'), -1]\n        u = u_unnorm / norm_u\n\n        # 2. Calculate the stochastic distance to collision (Sc)\n        # The problem specifies using ln(1-xi). Since xi is a U(0,1) variate,\n        # 1-xi is also a U(0,1) variate.\n        s_c = -np.log(1 - xi) / sigma_t\n\n        # 3. Calculate deterministic distances to all boundaries\n        boundary_distances = []\n\n        # Distance to cylinder lateral surface (x^2 + y^2 = R^2), ID=0\n        a_cyl = u[0]**2 + u[1]**2\n        if a_cyl  EPSILON:\n            b_cyl = 2 * (r0[0] * u[0] + r0[1] * u[1])\n            c_cyl = r0[0]**2 + r0[1]**2 - R**2\n            delta_cyl = b_cyl**2 - 4 * a_cyl * c_cyl\n            if delta_cyl = 0:\n                sqrt_delta = np.sqrt(delta_cyl)\n                s1 = (-b_cyl - sqrt_delta) / (2 * a_cyl)\n                s2 = (-b_cyl + sqrt_delta) / (2 * a_cyl)\n                if s1  EPSILON:\n                    boundary_distances.append((s1, 0))\n                elif s2  EPSILON:\n                    boundary_distances.append((s2, 0))\n\n        # Distances to axial planes (z=Z_MIN, z=Z_MAX), ID=1, 2\n        if abs(u[2])  EPSILON:\n            # Plane z = Z_MIN\n            s_zmin = (Z_MIN - r0[2]) / u[2]\n            if s_zmin  EPSILON:\n                boundary_distances.append((s_zmin, 1))\n            # Plane z = Z_MAX\n            s_zmax = (Z_MAX - r0[2]) / u[2]\n            if s_zmax  EPSILON:\n                boundary_distances.append((s_zmax, 2))\n\n        # Distance to sphere surface (x^2 + y^2 + z^2 = R_V^2), ID=3\n        # Equation: s^2 + 2(r0 . u)s + (|r0|^2 - R_V^2) = 0\n        b_sph = 2 * np.dot(r0, u)\n        c_sph = np.dot(r0, r0) - R_V**2\n        delta_sph = b_sph**2 - 4 * c_sph  # a=1\n        if delta_sph = 0:\n            sqrt_delta = np.sqrt(delta_sph)\n            s1 = (-b_sph - sqrt_delta) / 2\n            s2 = (-b_sph + sqrt_delta) / 2\n            if s1  EPSILON:\n                # Smallest positive root is the first intersection\n                boundary_distances.append((s1, 3))\n            elif s2  EPSILON:\n                # This occurs if starting on or inside the sphere and moving out.\n                # Since we start outside, this is a sanity check.\n                boundary_distances.append((s2, 3))\n\n        # 4. Determine distance to nearest boundary (Sb)\n        if not boundary_distances:\n            s_b = float('inf')\n            surface_id = -1\n        else:\n            s_b, surface_id = min(boundary_distances, key=lambda item: item[0])\n            \n        # 5. Compare Sc and Sb to determine the event\n        # Per problem statement, favor boundary crossing on ties (Sb = Sc)\n        if s_c  s_b:\n            # Collision event\n            event_type = 0\n            event_distance = s_c\n            final_surface_id = -1\n        else:\n            # Boundary crossing event\n            event_type = 1\n            event_distance = s_b\n            final_surface_id = surface_id\n\n        return [event_type, round(event_distance, 6), final_surface_id]\n\n    # --- Test suite from the problem statement ---\n    test_cases = [\n        # (r0, u_unnormalized, sigma_t, xi)\n        ((0.10, 0.20, 0.00), (1.0, 1.0, 0.5), 2.0, 0.30),\n        ((0.20, 0.00, 0.55), (0.0, 0.0, 1.0), 5.0, 0.95),\n        ((0.499, 0.000, 0.000), (0.0, 1.0, 0.0), 100.0, 0.05),\n        ((0.15, 0.00, 0.00), (-1.0, 0.0, 0.0), 0.5, 0.40),\n        ((0.12, 0.00, 0.00), (1.0, 0.0, 0.0), 2.0, 0.90),\n    ]\n\n    results = []\n    for case in test_cases:\n        r0, u_unnorm, sigma_t, xi = case\n        result = compute_event(r0, u_unnorm, sigma_t, xi)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}