{
    "hands_on_practices": [
        {
            "introduction": "构建任何粒子输运模拟器的第一步是教会它如何在几何空间中“导航”。本练习将重点关注射线追踪中的一项基本算法：计算粒子从当前位置沿其飞行路径到最近表面的距离。掌握这一步对于精确模拟粒子泄漏和确定碰撞位置至关重要，是所有蒙特卡洛模拟的几何基础。",
            "id": "4218147",
            "problem": "在连续能量蒙特卡洛（MC）中子输运中，粒子径迹会沿自由飞行距离推进，直到遇到碰撞或边界穿越。边界穿越查询可归结为三维欧几里得几何中的射线-表面相交问题。考虑一个位置为 $x_0 \\in \\mathbb{R}^3$、方向为 $\\mathbf{u} \\in \\mathbb{R}^3$ 的粒子，其径迹由 $x(s) = x_0 + s \\mathbf{u}$（$s \\ge 0$）参数化。该算法必须在以下有效的几何假设下，确定径迹在最大飞行距离 $R_{\\max} > 0$ 内最近的表面穿越点：存在一组有限的解析曲面，这些曲面选自一个目录，包括平面、球面和轴向有限延伸的直圆柱体，所有这些曲面都有定义明确的隐式方程。连续能量蒙特卡洛方法可以扩展到由构造实体几何（CSG）描述的几何体，但对于本问题，曲面是直接给出的，任务仅限于计算与列表中任一单个曲面的最近穿越点。\n\n你的任务：\n\n1) 实现一个边界穿越算法，在给定 $x_0$、$\\mathbf{u}$、一个有限的曲面列表、一个数值容差 $\\epsilon > 0$ 和一个最大飞行距离 $R_{\\max} > 0$ 的情况下，返回具有最小有效正相交距离 $s \\in (\\epsilon, R_{\\max}]$ 的曲面标识符以及相应的距离 $s$。如果在 $(\\epsilon, R_{\\max}]$ 范围内没有曲面与射线相交，则返回数对 $(-1, R_{\\max})$。所有距离必须以米为单位表示，并四舍五入到六位小数。\n\n2) 证明在所述的有效几何假设下，该算法会在有限步数内终止。\n\n数学和算法要求：\n\n- 粒子方向 $\\mathbf{u}$ 应被视为一个普通向量；允许进行归一化，但非必需。算法必须仅依赖于欧几里得几何的第一性原理（例如，点积和范数）以及最多二次多项式的解析求根。问题必须在不使用快捷公式的情况下进行构建；从 $x(s) = x_0 + s \\mathbf{u}$ 和曲面的隐式定义推导出相交条件。\n\n- 曲面：\n  - 平面：由一个点 $p \\in \\mathbb{R}^3$ 和一个单位法向量 $n \\in \\mathbb{R}^3$ 通过隐式方程 $n \\cdot (x - p) = 0$ 指定。\n  - 球面：由一个球心 $c \\in \\mathbb{R}^3$ 和半径 $r > 0$ 通过隐式方程 $\\|x - c\\|^2 = r^2$ 指定。\n  - 圆柱体（轴向有限）：与z轴对齐的直圆柱体，由半径 $r > 0$、轴向边界 $z_{\\min}  z_{\\max}$ 指定，其侧面隐式方程为 $x_x^2 + x_y^2 = r^2$，同时满足轴向约束 $z_{\\min} \\le x_z \\le z_{\\max}$。\n\n- 算法必须舍弃 $s \\le \\epsilon$ 的交点，以避免在边界上起始时的自相交，并舍弃 $s > R_{\\max}$ 的交点。对于圆柱体侧面，只有当撞击点的z坐标位于 $[z_{\\min}, z_{\\max}]$ 区间内时，该交点才有效。\n\n- 物理和数值单位：距离以米为单位报告；角度（如果存在）应以弧度处理。将每个报告的距离四舍五入到六位小数。\n\n- 最终输出格式：你的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表，列表中的每个结果本身是一个双元素列表 $[id, d]$，由整数标识符和以米为单位且保留六位小数的浮点数距离组成，例如 $[[0,1.234567],[1,0.500000],[-1,10.000000]]$。\n\n测试套件：\n\n实现该算法，并在以下测试用例上进行评估。在每个用例中，都指定了 $x_0$、$\\mathbf{u}$、$\\epsilon$ 和 $R_{\\max}$，并且曲面以带标识符的列表形式给出。\n\n- 用例1（球体内的常规路径）：曲面：一个标识符为 $0$ 的单一球面，球心 $c = (0, 0, 0)$，半径 $r = 2$。射线：$x_0 = (0, 0, 1)$，$\\mathbf{u} = (0, 0, 1)$，$\\epsilon = 10^{-9}$，$R_{\\max} = 100$。预期最近的穿越点会出现在一个有限的 $s$ 值处。\n\n- 用例2（从平面边界开始）：曲面：两个平面，标识符为 $0$ 和 $1$。平面 $0$：点 $p = (0, 0, 0)$，法向量 $n = (0, 0, 1)$。平面 $1$：点 $p = (0, 0, 5)$，法向量 $n = (0, 0, 1)$。射线：$x_0 = (0, 0, 0)$，$\\mathbf{u} = (0, 0, 1)$，$\\epsilon = 10^{-9}$，$R_{\\max} = 100$。与平面0的交点发生在 $s = 0$ 处，必须被舍弃；下一个有效的穿越点是有限的。\n\n- 用例3（范围内无相交的平行射线）：曲面：一个标识符为 $0$ 的单一平面，点 $p = (1, 0, 0)$，法向量 $n = (1, 0, 0)$。射线：$x_0 = (0, 0, 0)$，$\\mathbf{u} = (0, 1, 0)$，$\\epsilon = 10^{-9}$，$R_{\\max} = 10$。射线与平面平行；在 $(\\epsilon, R_{\\max}]$ 范围内不应找到交点。\n\n- 用例4（与球面无相交）：曲面：一个标识符为 $0$ 的单一球面，球心 $c = (0, 0, 0)$，半径 $r = 1$。射线：$x_0 = (0, 2, 0)$，$\\mathbf{u} = (1, 0, 0)$，$\\epsilon = 10^{-9}$，$R_{\\max} = 10$。射线未与球面相交；在 $(\\epsilon, R_{\\max}]$ 范围内不应找到交点。\n\n- 用例5（有限圆柱侧面撞击）：曲面：一个标识符为 $0$ 的单一有限圆柱侧面，半径 $r = 1$，轴向边界 $z_{\\min} = 0$, $z_{\\max} = 3$。射线：$x_0 = (0.5, 0, 1)$，$\\mathbf{u} = (1, 0, 0)$，$\\epsilon = 10^{-9}$，$R_{\\max} = 100$。与侧面的最近有效穿越点发生在一个有限的 $s$ 值处，并且必须满足轴向约束。\n\n你的实现必须生成单行输出，包含按给定顺序排列的五个用例的 $[id, d]$ 对列表。",
            "solution": "问题要求开发一个边界穿越算法，这是连续能量蒙特卡洛粒子输运方法的基础。该算法必须确定粒子轨迹（建模为一条几何射线）与一组预定义的解析曲面之间的最近交点。\n\n**1. 算法框架与问题表述**\n\n设粒子轨迹为一条由参数方程 $x(d) = x_0 + d\\mathbf{v}$ 定义的射线，其中 $x_0 \\in \\mathbb{R}^3$ 是初始位置，$\\mathbf{v} \\in \\mathbb{R}^3$ 是单位方向向量（$\\|\\mathbf{v}\\| = 1$），$d \\ge 0$ 是从 $x_0$ 沿射线方向的距离。首先将输入的方向向量 $\\mathbf{u}$ 归一化以得到 $\\mathbf{v} = \\mathbf{u} / \\|\\mathbf{u}\\|$，从而确保参数 $d$ 代表以米为单位的真实物理距离。这一归一化步骤是允许的，它可以简化后续的几何计算。\n\n问题在于找到最小的有效相交距离 $d_{\\min}$ 和相应的曲面标识符 $id_{\\min}$。如果距离 $d$ 满足 $d \\in (\\epsilon, R_{\\max}]$，则认为该距离有效，其中 $\\epsilon > 0$ 是一个小的容差，用于避免在起始点发生自相交，而 $R_{\\max} > 0$ 是当前输运步骤的最大飞行距离。\n\n算法流程如下：\n1. 将迄今为止找到的最小距离初始化为最大允许距离，$d_{\\min} \\leftarrow R_{\\max}$，并将相应的曲面标识符初始化为一个哨兵值，$id_{\\min} \\leftarrow -1$。\n2. 对于所提供的有限列表中的每个曲面，计算一组有序的正相交距离 $\\{d_i\\}$。\n3. 对每个计算出的距离 $d_i$ 进行有效性检查。如果 $d_i \\in (\\epsilon, d_{\\min})$，则该相交是有效的。\n4. 如果找到一个有效的相交，更新状态：$d_{\\min} \\leftarrow d_i$ 且 $id_{\\min} \\leftarrow$ 当前曲面标识符。后续曲面的搜索范围现在缩小到 $(\\epsilon, d_{\\min})$。\n5. 遍历所有曲面后，数对 $(id_{\\min}, d_{\\min})$ 即为结果。\n\n**2. 射线-曲面相交距离的推导**\n\n算法的核心是针对每种类型的曲面解析计算相交距离 $d$。这是通过将射线方程代入曲面的隐式方程并求解 $d$ 来实现的。\n\n**2.1. 射线-平面相交**\n平面由一个点 $p \\in \\mathbb{R}^3$ 和一个单位法向量 $n \\in \\mathbb{R}^3$ 定义。其隐式方程为 $n \\cdot (x - p) = 0$。\n将射线方程 $x(d) = x_0 + d\\mathbf{v}$ 代入：\n$$n \\cdot ((x_0 + d\\mathbf{v}) - p) = 0$$\n展开点积：\n$$n \\cdot (x_0 - p) + d(n \\cdot \\mathbf{v}) = 0$$\n求解 $d$：\n$$d = \\frac{n \\cdot (p - x_0)}{n \\cdot \\mathbf{v}}$$\n仅当分母 $n \\cdot \\mathbf{v} \\neq 0$ 时，此表达式才有定义。\n- 如果 $|n \\cdot \\mathbf{v}|$ 小于一个数值精度容差，则认为射线与平面平行。在这种情况下，不会发生相交，除非射线位于平面内（即 $n \\cdot (p - x_0) = 0$），但这不属于离散的穿越事件，因此对于 $d > 0$ 的情况予以忽略。\n- 如果 $n \\cdot \\mathbf{v} \\neq 0$，则计算出一个唯一的相交距离 $d$。\n\n**2.2. 射线-球面相交**\n球面由一个球心 $c \\in \\mathbb{R}^3$ 和一个半径 $r > 0$ 定义。其隐式方程为 $\\|x - c\\|^2 = r^2$。\n令 $\\Delta x_c = x_0 - c$。代入射线方程 $x(d) = x_0 + d\\mathbf{v} = c + \\Delta x_c + d\\mathbf{v}$：\n$$\\|(\\Delta x_c + d\\mathbf{v})\\|^2 - r^2 = 0$$\n展开平方范数，即向量与其自身的点积：\n$$(\\Delta x_c + d\\mathbf{v}) \\cdot (\\Delta x_c + d\\mathbf{v}) - r^2 = 0$$\n$$\\|\\Delta x_c\\|^2 + 2d(\\Delta x_c \\cdot \\mathbf{v}) + d^2\\|\\mathbf{v}\\|^2 - r^2 = 0$$\n由于 $\\mathbf{v}$ 是单位向量，$\\|\\mathbf{v}\\|^2 = 1$。这产生了一个关于 $d$ 的二次方程，形式为 $ad^2 + bd + c_{_Q} = 0$：\n$$d^2 + (2(\\Delta x_c \\cdot \\mathbf{v}))d + (\\|\\Delta x_c\\|^2 - r^2) = 0$$\n系数为：$a=1$，$b=2((x_0-c)\\cdot\\mathbf{v})$，以及 $c_{_Q}=\\|x_0-c\\|^2 - r^2$。\n判别式为 $\\mathcal{D} = b^2 - 4ac_{_Q}$。\n- 如果 $\\mathcal{D}  0$，则没有实数根，射线未与球面相交。\n- 如果 $\\mathcal{D} \\ge 0$，则存在一个或两个实数根，由二次方程求根公式给出：\n$$d = \\frac{-b \\pm \\sqrt{\\mathcal{D}}}{2a} = -\\frac{b}{2} \\pm \\frac{\\sqrt{\\mathcal{D}}}{2}$$\n令 $b' = b/2 = (x_0-c)\\cdot\\mathbf{v}$ 且 $c' = c_{_Q}$。方程为 $d^2+2b'd+c'=0$，解为 $d = -b' \\pm \\sqrt{b'^2-c'}$。\n两个可能的距离是 $d_1 = -b' - \\sqrt{b'^2 - c'}$ 和 $d_2 = -b' + \\sqrt{b'^2 - c'}$。在这些根中，大于 $\\epsilon$ 的最小正距离被选为候选相交距离。\n\n**2.3. 射线-圆柱体相交**\n与z轴对齐的直圆柱体由半径 $r > 0$ 和轴向边界 $z_{\\min}, z_{\\max}$ 定义。其侧面的隐式方程为 $x_x^2 + x_y^2 = r^2$，其中 $z_{\\min} \\le x_z \\le z_{\\max}$。\n射线的各分量为 $x_x(d) = x_{0x} + dv_x$ 和 $x_y(d) = x_{0y} + dv_y$。将它们代入侧面方程：\n$$(x_{0x} + dv_x)^2 + (x_{0y} + dv_y)^2 - r^2 = 0$$\n展开并按 $d$ 的幂次收集项：\n$$d^2(v_x^2 + v_y^2) + d(2(x_{0x}v_x + x_{0y}v_y)) + (x_{0x}^2 + x_{0y}^2 - r^2) = 0$$\n这是一个二次方程 $ad^2 + bd + c_{_Q} = 0$，其系数为：\n- $a = v_x^2 + v_y^2$\n- $b = 2(x_{0x}v_x + x_{0y}v_y)$\n- $c_{_Q} = x_{0x}^2 + x_{0y}^2 - r^2$\n与球面情况类似，使用二次公式找到根 $d_i$。如果 $a \\approx 0$（即射线几乎平行于z轴），方程退化为线性方程。\n对于每个有效根 $d_i > \\epsilon$，需要进行进一步检查。交点的z坐标 $z_{hit} = x_{0z} + d_i v_z$ 必须位于圆柱体的轴向边界内：\n$$z_{\\min} \\le z_{hit} \\le z_{\\max}$$\n只有满足此条件，相交距离 $d_i$ 才被认为是有效的。满足条件的最小 $d_i$ 是该曲面的候选距离。\n\n**3. 终止性证明**\n问题陈述保证了曲面的集合是有限的。设其数量为 $N$。该算法包含一个迭代 $N$ 次的单循环。在每次迭代中，执行的工作量相对于问题规模（除 $N$ 外）是恒定的。对于每种曲面类型（平面、球面、圆柱体），算法执行一个固定的步骤序列：\n- 向量运算（归一化、点积、范数），这些对于三维向量是常数时间操作。\n- 求解最多一个一次或二次多项式方程。这也需要常数数量的算术运算。\n- 固定次数的比较，以验证所得的距离。\n\n因此，总操作数与 $N$ 成正比。由于 $N$ 是有限的，该算法保证在有限的步数内执行并终止。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Numerical tolerance for floating point comparisons, e.g., checking for parallelism.\nZERO_TOLERANCE = 1e-12\n\ndef _find_valid_roots(a, b, c, epsilon):\n    \"\"\"\n    Solves a quadratic equation ad^2 + bd + c = 0 and returns a list of \n    valid roots d > epsilon.\n    \"\"\"\n    roots = []\n    \n    if abs(a)  ZERO_TOLERANCE:\n        # Linear equation: bd + c = 0\n        if abs(b) > ZERO_TOLERANCE:\n            d = -c / b\n            if d > epsilon:\n                roots.append(d)\n    else:\n        # Quadratic equation\n        discriminant = b**2 - 4 * a * c\n        if discriminant >= 0:\n            sqrt_disc = np.sqrt(discriminant)\n            d1 = (-b - sqrt_disc) / (2 * a)\n            d2 = (-b + sqrt_disc) / (2 * a)\n            \n            # Roots should be sorted to check the smallest positive one first\n            sorted_roots = sorted([d1, d2])\n            for d in sorted_roots:\n                if d > epsilon:\n                    roots.append(d)\n    return roots\n\ndef _intersect_plane(x0, v, p, n, epsilon):\n    \"\"\"Calculates intersection distance with a plane.\"\"\"\n    nv_dot = n.dot(v)\n    if abs(nv_dot)  ZERO_TOLERANCE:\n        return []  # Ray is parallel to the plane\n    \n    d = n.dot(p - x0) / nv_dot\n    if d > epsilon:\n        return [d]\n    return []\n\ndef _intersect_sphere(x0, v, c, r, epsilon):\n    \"\"\"Calculates intersection distance(s) with a sphere.\"\"\"\n    delta_x = x0 - c\n    \n    # Coefficients for ad^2 + bd + c = 0\n    # Since v is normalized, a = v.dot(v) = 1\n    a = 1.0\n    b = 2 * delta_x.dot(v)\n    c_q = delta_x.dot(delta_x) - r**2\n    \n    return _find_valid_roots(a, b, c_q, epsilon)\n\ndef _intersect_cylinder_side(x0, v, r, z_min, z_max, epsilon):\n    \"\"\"Calculates intersection distance(s) with a finite z-aligned cylinder side.\"\"\"\n    # Coefficients for ad^2 + bd + c = 0\n    a = v[0]**2 + v[1]**2\n    b = 2 * (x0[0]*v[0] + x0[1]*v[1])\n    c_q = x0[0]**2 + x0[1]**2 - r**2\n    \n    potential_distances = _find_valid_roots(a, b, c_q, epsilon)\n    \n    valid_distances = []\n    for d in potential_distances:\n        # Check if the hit point is within the axial bounds\n        z_hit = x0[2] + d * v[2]\n        if z_min = z_hit = z_max:\n            valid_distances.append(d)\n            \n    return valid_distances\n\ndef find_nearest_crossing(x0, u, surfaces, epsilon, R_max):\n    \"\"\"\n    Finds the nearest valid surface crossing for a particle track.\n\n    Args:\n        x0 (np.ndarray): Particle starting position.\n        u (np.ndarray): Particle direction vector (not necessarily normalized).\n        surfaces (list): A list of surface description dictionaries.\n        epsilon (float): Small positive distance to avoid self-intersection.\n        R_max (float): Maximum flight distance.\n\n    Returns:\n        tuple: (surface_id, distance) for the nearest crossing. \n               If no crossing, returns (-1, R_max).\n    \"\"\"\n    norm_u = np.linalg.norm(u)\n    if norm_u  ZERO_TOLERANCE:\n        return -1, R_max # No movement\n    v = u / norm_u\n\n    min_dist = R_max\n    min_id = -1\n\n    for surface in surfaces:\n        s_id = surface['id']\n        s_type = surface['type']\n        params = surface['params']\n        \n        distances = []\n        if s_type == 'plane':\n            distances = _intersect_plane(x0, v, params['p'], params['n'], epsilon)\n        elif s_type == 'sphere':\n            distances = _intersect_sphere(x0, v, params['c'], params['r'], epsilon)\n        elif s_type == 'cylinder_side':\n            distances = _intersect_cylinder_side(x0, v, params['r'], params['z_min'], params['z_max'], epsilon)\n        \n        for d in distances:\n            if d  min_dist:\n                min_dist = d\n                min_id = s_id\n    \n    return min_id, min_dist\n\ndef solve():\n    \"\"\"\n    Defines and runs the test suite for the boundary crossing algorithm.\n    \"\"\"\n    test_cases = [\n        # Case 1 (happy path inside a sphere)\n        {\n            'x0': np.array([0.0, 0.0, 1.0]), 'u': np.array([0.0, 0.0, 1.0]),\n            'epsilon': 1e-9, 'R_max': 100.0,\n            'surfaces': [\n                {'id': 0, 'type': 'sphere', 'params': {'c': np.array([0.0, 0.0, 0.0]), 'r': 2.0}}\n            ]\n        },\n        # Case 2 (boundary start on a plane)\n        {\n            'x0': np.array([0.0, 0.0, 0.0]), 'u': np.array([0.0, 0.0, 1.0]),\n            'epsilon': 1e-9, 'R_max': 100.0,\n            'surfaces': [\n                {'id': 0, 'type': 'plane', 'params': {'p': np.array([0.0, 0.0, 0.0]), 'n': np.array([0.0, 0.0, 1.0])}},\n                {'id': 1, 'type': 'plane', 'params': {'p': np.array([0.0, 0.0, 5.0]), 'n': np.array([0.0, 0.0, 1.0])}}\n            ]\n        },\n        # Case 3 (parallel ray with no intersection)\n        {\n            'x0': np.array([0.0, 0.0, 0.0]), 'u': np.array([0.0, 1.0, 0.0]),\n            'epsilon': 1e-9, 'R_max': 10.0,\n            'surfaces': [\n                {'id': 0, 'type': 'plane', 'params': {'p': np.array([1.0, 0.0, 0.0]), 'n': np.array([1.0, 0.0, 0.0])}}\n            ]\n        },\n        # Case 4 (no intersection with a sphere)\n        {\n            'x0': np.array([0.0, 2.0, 0.0]), 'u': np.array([1.0, 0.0, 0.0]),\n            'epsilon': 1e-9, 'R_max': 10.0,\n            'surfaces': [\n                {'id': 0, 'type': 'sphere', 'params': {'c': np.array([0.0, 0.0, 0.0]), 'r': 1.0}}\n            ]\n        },\n        # Case 5 (finite cylinder side hit)\n        {\n            'x0': np.array([0.5, 0.0, 1.0]), 'u': np.array([1.0, 0.0, 0.0]),\n            'epsilon': 1e-9, 'R_max': 100.0,\n            'surfaces': [\n                {'id': 0, 'type': 'cylinder_side', 'params': {'r': 1.0, 'z_min': 0.0, 'z_max': 3.0}}\n            ]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        res_id, res_dist = find_nearest_crossing(\n            case['x0'], case['u'], case['surfaces'], case['epsilon'], case['R_max']\n        )\n        results.append([res_id, res_dist])\n\n    results_str = [f\"[{item[0]},{item[1]:.6f}]\" for item in results]\n    print(f\"[{','.join(results_str)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在粒子学会如何在几何中移动之后，下一步是模拟其物理相互作用，并验证我们的模拟是否遵守了基本的守恒定律。本练习将指导您构建一个完整但简化的蒙特卡洛模拟循环，包括源的产生、自由程的抽样、碰撞物理（吸收和散射）以及关键物理量的统计。通过验证能量平衡（即源能量 $=$ 沉积能量 $+$ 泄漏能量），我们可以系统地检验整个模拟逻辑的正确性，这是一种经典且强大的代码验证方法。",
            "id": "4218173",
            "problem": "考虑一个半径为 $R$ 的均匀球形区域，其边界为真空，其中包含一种经历弹性散射和吸收的虚拟核素。一组独立的中子历史从球心处一个各向同性的点源发射，该源具有以兆电子伏（MeV）表示的单能动能 $E_0$。目标是构建一个连续能量蒙特卡罗算法，通过直接模拟来验证能量守恒恒等式：在蒙特卡罗估计量的统计不确定性范围内，总沉积能量等于总源能量减去总泄漏能量。\n\n使用以下科学标准基础：\n- 积分形式的线性玻尔兹曼输运方程能量平衡表明，对于一个具有真空边界的孤立系统，由源引入的动能被分配到沉积在介质中的能量和穿过边界带出的能量之间。\n- 在中子与质量比为 $A$（靶核质量除以中子质量）的静止靶核发生弹性散射，且散射在质心系中是各向同性的情况下，出射中子在实验室系中的能量 $E'$ 由下式给出\n$$\n\\frac{E'}{E} \\;=\\; \\frac{A^2 + 1 + 2 A \\mu_{\\text{cm}}}{(A+1)^2},\n$$\n其中 $E$ 是入射能量，$\\mu_{\\text{cm}} = \\cos\\theta_{\\text{cm}}$ 是质心系中散射角的余弦。实验室散射角 $\\theta_{\\text{lab}}$ 满足\n$$\n\\tan\\theta_{\\text{lab}} \\;=\\; \\frac{\\sin\\theta_{\\text{cm}}}{\\cos\\theta_{\\text{cm}} + 1/A},\n$$\n因此\n$$\n\\mu_{\\text{lab}} \\;=\\; \\cos\\theta_{\\text{lab}} \\;=\\; \\frac{\\mu_{\\text{cm}} + 1/A}{\\sqrt{1 + 2\\mu_{\\text{cm}}/A + 1/A^2}}.\n$$\n- 在吸收反应中，中子动能作为热量局部沉积。在弹性散射中，每次碰撞作为材料加热沉积的能量等于能量损失 $E - E'$。对于真空边界，任何到达边界的中子都会泄漏出去，并携带其当前的动能。\n\n设宏观截面是能量 $E$ 的连续函数，单位为反厘米（$\\text{cm}^{-1}$）：\n- 散射宏观截面为 $\\Sigma_s(E) = \\Sigma_{s0}$（常数）。\n- 吸收宏观截面为 $\\Sigma_a(E) = \\dfrac{\\Sigma_{a0}}{\\sqrt{E/\\text{MeV}}}$，表示一种类 $1/v$ 的行为，其中能量以兆电子伏为单位测量。总宏观截面为 $\\Sigma_t(E) = \\Sigma_s(E) + \\Sigma_a(E)$。\n到下一次碰撞的自由程从均值为 $1/\\Sigma_t(E)$ 的指数分布中抽样，即 $s = -\\ln u / \\Sigma_t(E)$，其中 $u$ 在 $(0,1)$ 上均匀分布。\n\n几何与运动学：\n- 中子从原点开始，方向是各向同性的。沿当前方向到球形边界的距离是方程 $t^2 + 2 (\\boldsymbol{r}\\cdot\\boldsymbol{u}) t + ( \\|\\boldsymbol{r}\\|^2 - R^2 ) = 0$ 的正根，其中 $\\boldsymbol{r}$ 是当前位置，$\\boldsymbol{u}$ 是当前单位方向向量。\n- 如果抽样的自由程距离 $s$ 超过边界距离 $d_{\\text{exit}}$，中子会泄漏，并将其当前能量 $E$ 带出系统。\n- 如果在穿过边界之前发生碰撞，则其为吸收的概率是 $\\Sigma_a(E)/\\Sigma_t(E)$，否则为弹性散射。在吸收情况下，沉积能量 $E$ 并终止该历史。在弹性散射情况下，将 $E - E'$ 作为热量沉积，通过极角余弦 $\\mu_{\\text{lab}}$ 和均匀的方位角旋转来更新方向，将能量设置为 $E'$，并继续该历史。\n\n任务：\n1. 实现一个连续能量蒙特卡罗模拟，对每个历史 $i$ 记录源能量 $S_i = E_0$、总沉积能量 $D_i$（弹性散射事件中 $E - E'$ 的总和加上吸收事件中的 $E$）和泄漏能量 $L_i$（穿过边界时的能量）。定义每个历史的能量平衡残差 $B_i = S_i - D_i - L_i$，单位为 MeV。\n2. 对于 $N$ 个历史，使用通常的无偏估计量来估计样本均值 $\\bar{B} = \\dfrac{1}{N}\\sum_{i=1}^N B_i$ 和样本标准差 $s_B$。使用中心极限定理（CLT），通过检查不等式来验证能量守恒恒等式\n$$\n|\\bar{B}| \\;\\le\\; z \\,\\frac{s_B}{\\sqrt{N}},\n$$\n其中 $z = 3$，即在三个标准误差范围内。如果 $s_B = 0$，则将 $|\\bar{B}| \\le \\varepsilon$（其中 $\\varepsilon$ 是一个小的数值容差）视为验证通过。\n3. 对每个指定的测试案例，报告一个布尔结果，指示该恒等式是否在统计不确定性范围内得到验证。\n\n单位：\n- 能量必须以兆电子伏（MeV）处理和记录。\n- 距离以厘米（$\\text{cm}$）为单位。\n- 截面以反厘米（$\\text{cm}^{-1}$）为单位。\n- 角度必须以弧度进行抽样和操作。\n\n测试套件：\n为以下参数集提供结果，每个参数集作为一个独立的测试案例：\n- 案例 A（一般混合相互作用）：$N = 8000$, $R = 50\\,\\text{cm}$, $\\Sigma_{s0} = 0.20\\,\\text{cm}^{-1}$, $\\Sigma_{a0} = 0.05\\,\\text{cm}^{-1}$, $A = 12$, $E_0 = 2.0\\,\\text{MeV}$。\n- 案例 B（纯吸收介质）：$N = 10000$, $R = 50\\,\\text{cm}$, $\\Sigma_{s0} = 0.00\\,\\text{cm}^{-1}$, $\\Sigma_{a0} = 0.10\\,\\text{cm}^{-1}$, $A = 12$, $E_0 = 2.0\\,\\text{MeV}$。\n- 案例 C（纯散射氢，小球体）：$N = 10000$, $R = 10\\,\\text{cm}$, $\\Sigma_{s0} = 0.10\\,\\text{cm}^{-1}$, $\\Sigma_{a0} = 0.00\\,\\text{cm}^{-1}$, $A = 1$, $E_0 = 2.0\\,\\text{MeV}$。\n- 案例 D（近真空，大球体）：$N = 10000$, $R = 100\\,\\text{cm}$, $\\Sigma_{s0} = 0.005\\,\\text{cm}^{-1}$, $\\Sigma_{a0} = 0.00\\,\\text{cm}^{-1}$, $A = 1$, $E_0 = 2.0\\,\\text{MeV}$。\n\n要求的最终输出格式：\n您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，“[$\\text{result1}$,$\\text{result2}$,$\\text{result3}$,$\\text{result4}$]”），其中每个结果是一个布尔值，指示能量守恒恒等式是否在相应测试案例的三个标准误差范围内得到验证。",
            "solution": "该问题要求构建一个连续能量蒙特卡罗中子输运模拟，以验证有限球形介质内的能量守恒恒等式。该恒等式指出，由源引入的总能量必须等于沉积在介质内的能量与从系统中泄漏出去的能量之和。验证将通过检查每个历史的能量平衡残差的均值在统计上是否与零无法区分来进行。\n\n该解决方案基于应用于中性粒子线性玻尔兹曼输运方程的能量守恒原理。对于具有源 $S(\\boldsymbol{r}, E, \\boldsymbol{\\Omega})$ 的稳态系统，能量平衡可以表示为：\n$$\n\\int_V d\\boldsymbol{r} \\int_{4\\pi} d\\boldsymbol{\\Omega} \\int_0^\\infty dE \\, E \\, S(\\boldsymbol{r}, E, \\boldsymbol{\\Omega}) \\;=\\; \\int_V d\\boldsymbol{r} \\int_0^\\infty dE \\, E_{\\text{dep}}(\\boldsymbol{r}, E) + \\int_{\\partial V} d\\boldsymbol{s} \\int_0^\\infty dE \\, E \\, (\\boldsymbol{n} \\cdot \\boldsymbol{\\Omega}) \\, \\Psi(\\boldsymbol{r}_s, E, \\boldsymbol{\\Omega})\n$$\n其中左侧是总源能量，右侧第一项是总沉积能量，第二项是穿过表面 $\\partial V$ 的总泄漏能量。蒙特卡罗方法通过模拟大量单个粒子历史来提供估计这些积分量的方法。问题指出，必须记录每个历史的平衡 $S_i - D_i - L_i$，其中 $S_i$ 是源能量，$D_i$ 是总沉积能量，$L_i$ 是历史 $i$ 的泄漏能量。根据构造，对于具有完美算术的直接模拟，这个残差 $B_i = S_i - D_i - L_i$ 对每个历史都恒等于零。因此，该任务变成了一个代码验证问题，测试实现是否在每一步都正确地守恒能量，从而使计算出的残差在浮点精度范围内为零。\n\n该算法通过模拟 $N$ 个独立的中子历史来进行。每个历史追踪一个中子从源发射到因吸收或泄漏而终止的全过程。\n\n1.  **源粒子初始化**：每个中子历史 $i$ 从球心处的一个粒子开始，$\\boldsymbol{r} = (0,0,0)$。源能量固定为 $S_i = E_0$。初始行进方向，即单位向量 $\\boldsymbol{u}$，从各向同性分布中抽样。这是通过从 $[-1, 1]$ 中均匀抽样极角余弦 $\\mu_z = \\cos\\theta$ 和从 $[0, 2\\pi]$ 中均匀抽样方位角 $\\phi$ 来实现的，然后构造方向向量 $\\boldsymbol{u} = (\\sqrt{1-\\mu_z^2}\\cos\\phi, \\sqrt{1-\\mu_z^2}\\sin\\phi, \\mu_z)$。对于每个历史，沉积能量 $D_i$ 和泄漏能量 $L_i$ 的计数器都初始化为 0。\n\n2.  **中子输运循环**：模拟的核心是一个循环，它将中子从一个事件推进到下一个事件。在循环的每一步中，中子位于位置 $\\boldsymbol{r}$，具有能量 $E$ 和方向 $\\boldsymbol{u}$。\n    -   **截面评估**：总宏观截面 $\\Sigma_t(E)$ 计算为散射截面 $\\Sigma_s(E) = \\Sigma_{s0}$ 和吸收截面 $\\Sigma_a(E) = \\Sigma_{a0}/\\sqrt{E}$ 的和。\n    -   **到碰撞的距离**：到下一次可能碰撞的路径长度 $s$ 从平均自由程为 $1/\\Sigma_t(E)$ 的指数概率分布中抽样。这是通过抽样一个均匀随机数 $\\xi_1 \\in (0,1)$ 并计算 $s = -\\ln(\\xi_1) / \\Sigma_t(E)$ 来完成的。如果 $\\Sigma_t(E) = 0$，则路径长度为无穷大。\n    -   **到边界的距离**：从当前位置 $\\boldsymbol{r}$ 沿当前方向 $\\boldsymbol{u}$ 到半径为 $R$ 的球形边界的距离 $d_{\\text{exit}}$ 被确定。这是一元二次方程 $t^2 + 2(\\boldsymbol{r}\\cdot\\boldsymbol{u})t + (\\|\\boldsymbol{r}\\|^2 - R^2) = 0$ 的正根，即 $d_{\\text{exit}} = -(\\boldsymbol{r}\\cdot\\boldsymbol{u}) + \\sqrt{(\\boldsymbol{r}\\cdot\\boldsymbol{u})^2 - (\\|\\boldsymbol{r}\\|^2 - R^2)}$。\n    -   **事件确定**：将抽样得到的到碰撞的距离 $s$ 与到边界的距离 $d_{\\text{exit}}$ 进行比较。\n        -   如果 $s \\ge d_{\\text{exit}}$，中子在没有碰撞的情况下到达边界。它从系统中泄漏出去。该历史的泄漏能量被设置为中子当前的能量，$L_i = E$，并且历史被终止。\n        -   如果 $s  d_{\\text{exit}}$，中子行进距离 $s$ 并发生一次碰撞。粒子的位置更新为 $\\boldsymbol{r}' = \\boldsymbol{r} + s\\boldsymbol{u}$。\n\n3.  **碰撞物理**：如果发生碰撞，其类型将通过概率确定。\n    -   抽样一个随机数 $\\xi_2 \\in (0,1)$。\n    -   如果 $\\xi_2  \\Sigma_a(E) / \\Sigma_t(E)$，碰撞是**吸收**。中子的全部动能 $E$ 沉积在材料中。沉积能量计数器更新为 $D_i \\leftarrow D_i + E$，并且历史被终止。\n    -   否则，碰撞是**弹性散射**。中子损失一些能量并改变方向。\n        -   **能量运动学**：出射能量 $E'$ 由散射运动学确定。对于质心（CM）系中的各向同性散射，质心散射角的余弦 $\\mu_{\\text{cm}}$ 从 $[-1, 1]$ 中均匀抽样。实验室系中的新能量是 $E' = E \\frac{A^2 + 1 + 2A\\mu_{\\text{cm}}}{(A+1)^2}$。\n        -   **能量沉积**：中子损失的能量作为热量沉积。计数器更新为：$D_i \\leftarrow D_i + (E - E')$。然后中子的能量更新为 $E'$。\n        -   **方向运动学**：中子的方向向量 $\\boldsymbol{u}$ 被更新。实验室散射角的余弦是 $\\mu_{\\text{lab}} = \\frac{\\mu_{\\text{cm}} + 1/A}{\\sqrt{1 + 2\\mu_{\\text{cm}}/A + 1/A^2}}$。抽样一个随机的方位散射角 $\\phi_{\\text{azimuth}} \\in [0, 2\\pi]$。旧的方向向量 $\\boldsymbol{u}$ 通过极角 $\\theta_{\\text{lab}} = \\arccos(\\mu_{\\text{lab}})$ 和方位角 $\\phi_{\\text{azimuth}}$ 旋转以获得新的方向 $\\boldsymbol{u}'$。中子的方向更新为 $\\boldsymbol{u}'$。\n        -   然后输运循环从第 2 步继续，使用更新后的粒子状态（$\\boldsymbol{r}', E', \\boldsymbol{u}'$）。\n\n4.  **计数与统计分析**：在每个历史 $i$ 终止后，计算能量平衡残差：$B_i = S_i - D_i - L_i$。由于计数方式（动能的每一次变化都被记为沉积或最终泄漏），这个值在数值上应该非常接近于零。\n    在所有 $N$ 个历史完成后，分析残差样本 $\\{B_1, B_2, \\dots, B_N\\}$。计算样本均值 $\\bar{B} = \\frac{1}{N}\\sum_{i=1}^N B_i$ 和无偏样本标准差 $s_B = \\sqrt{\\frac{1}{N-1}\\sum_{i=1}^N (B_i - \\bar{B})^2}$。\n    如果平均残差在平均值的三个标准误差内与零一致，即 $|\\bar{B}| \\le 3 \\frac{s_B}{\\sqrt{N}}$，则认为能量守恒恒等式得到验证。\n    在数值误差非常小以至于计算出的 $s_B$ 为零的特殊情况下，通过检查 $|\\bar{B}|$ 是否小于一个小的容差 $\\varepsilon$（例如 $\\varepsilon = 10^{-12}$）来执行验证。这确认了该实现在浮点精度内保持了能量守恒。对提供的每个测试案例重复此过程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef rotate_direction(direction_vec, mu_lab, phi_azimuth):\n    \"\"\"\n    Rotates a direction vector by a polar angle (specified by its cosine mu_lab)\n    and an azimuthal angle phi_azimuth.\n    Uses the MCNP standard rotation formula.\n    \"\"\"\n    u, v, w = direction_vec\n    sin_theta_lab = np.sqrt(1.0 - mu_lab**2)\n    cos_phi = np.cos(phi_azimuth)\n    sin_phi = np.sin(phi_azimuth)\n\n    # Handle the case where the initial direction is nearly aligned with the z-axis\n    # to avoid division by zero in the standard formula.\n    if np.abs(w) > 1.0 - 1e-9:\n        u_prime = sin_theta_lab * cos_phi\n        v_prime = sin_theta_lab * sin_phi\n        w_prime = mu_lab * np.sign(w)\n    else:\n        # Standard rotation formula\n        temp = np.sqrt(1.0 - w**2)\n        u_prime = u * mu_lab + (sin_theta_lab / temp) * (u * w * cos_phi - v * sin_phi)\n        v_prime = v * mu_lab + (sin_theta_lab / temp) * (v * w * cos_phi + u * sin_phi)\n        w_prime = w * mu_lab - sin_theta_lab * temp * cos_phi\n\n    return np.array([u_prime, v_prime, w_prime], dtype=np.float64)\n\ndef simulate_history(R, Sigma_s0, Sigma_a0, A, E0, rng):\n    \"\"\"\n    Simulates a single neutron history from source to termination.\n    Returns the energy balance residual for the history.\n    \"\"\"\n    # Particle state variables\n    pos = np.zeros(3, dtype=np.float64)\n    energy = np.float64(E0)\n\n    # Sample isotropic source direction\n    mu_z = 2.0 * rng.random() - 1.0\n    phi = 2.0 * np.pi * rng.random()\n    sin_theta = np.sqrt(1.0 - mu_z**2)\n    direction = np.array([sin_theta * np.cos(phi),\n                          sin_theta * np.sin(phi),\n                          mu_z], dtype=np.float64)\n\n    # History tallies\n    deposited_energy = np.float64(0.0)\n    leakage_energy = np.float64(0.0)\n\n    while True:\n        # Check for particle termination by energy threshold (unlikely here)\n        if energy = 0.0:\n            break\n\n        # Macroscopic cross sections\n        sigma_s = np.float64(Sigma_s0)\n        sigma_a = np.float64(Sigma_a0 / np.sqrt(energy)) if energy > 0 else np.inf\n        sigma_t = sigma_s + sigma_a\n\n        # Sample distance to collision\n        if sigma_t == 0.0:\n            dist_to_collision = np.inf\n        else:\n            dist_to_collision = -np.log(rng.random()) / sigma_t\n\n        # Calculate distance to sphere boundary\n        r_dot_u = np.dot(pos, direction)\n        r_sq = np.dot(pos, pos)\n        discriminant = r_dot_u**2 - (r_sq - R**2)\n        dist_to_boundary = -r_dot_u + np.sqrt(discriminant)\n        \n        # Determine event: leakage or collision\n        if dist_to_collision >= dist_to_boundary:\n            leakage_energy = energy\n            break  # History terminates\n        else:\n            # Move particle to collision site\n            pos += dist_to_collision * direction\n\n            # Determine collision type: absorption or scattering\n            prob_absorption = sigma_a / sigma_t\n            if rng.random()  prob_absorption:\n                deposited_energy += energy\n                break  # History terminates\n            else:\n                # Elastic scattering\n                # Sample CM scattering cosine\n                mu_cm = 2.0 * rng.random() - 1.0\n\n                # Calculate new energy\n                a_plus_1_sq = (A + 1.0)**2\n                energy_prime = energy * (A**2 + 1.0 + 2.0 * A * mu_cm) / a_plus_1_sq\n\n                # Deposit energy loss\n                deposited_energy += (energy - energy_prime)\n\n                # Update particle energy\n                energy = energy_prime\n\n                # Update particle direction\n                mu_lab_num = mu_cm + 1.0 / A\n                mu_lab_den = np.sqrt(1.0 + 2.0 * mu_cm / A + 1.0 / A**2)\n                mu_lab = mu_lab_num / mu_lab_den\n                \n                phi_scatter = 2.0 * np.pi * rng.random()\n                direction = rotate_direction(direction, mu_lab, phi_scatter)\n\n    # Calculate and return the energy balance residual\n    residual = E0 - deposited_energy - leakage_energy\n    return residual\n\ndef run_simulation(N, R, Sigma_s0, Sigma_a0, A, E0):\n    \"\"\"\n    Runs N histories for a given problem configuration and verifies the energy balance.\n    \"\"\"\n    rng = np.random.default_rng(seed=12345)\n    residuals = np.zeros(N, dtype=np.float64)\n\n    for i in range(N):\n        residuals[i] = simulate_history(R, Sigma_s0, Sigma_a0, A, E0, rng)\n    \n    mean_B = np.mean(residuals)\n    std_B = np.std(residuals, ddof=1)\n\n    if std_B == 0.0:\n        # If std dev is numerically zero, all residuals are identical.\n        # Check if the mean (and thus all residuals) is near zero.\n        epsilon = 1e-12 \n        return np.abs(mean_B) = epsilon\n    else:\n        # Standard statistical check\n        z = 3.0\n        standard_error = std_B / np.sqrt(N)\n        return np.abs(mean_B) = z * standard_error\n\ndef solve():\n    \"\"\"\n    Main function to define, run, and report results for all test cases.\n    \"\"\"\n    test_cases = [\n        # Case A\n        {'N': 8000, 'R': 50.0, 'Sigma_s0': 0.20, 'Sigma_a0': 0.05, 'A': 12.0, 'E0': 2.0},\n        # Case B\n        {'N': 10000, 'R': 50.0, 'Sigma_s0': 0.00, 'Sigma_a0': 0.10, 'A': 12.0, 'E0': 2.0},\n        # Case C\n        {'N': 10000, 'R': 10.0, 'Sigma_s0': 0.10, 'Sigma_a0': 0.00, 'A': 1.0, 'E0': 2.0},\n        # Case D\n        {'N': 10000, 'R': 100.0, 'Sigma_s0': 0.005, 'Sigma_a0': 0.00, 'A': 1.0, 'E0': 2.0},\n    ]\n\n    results = []\n    for case_params in test_cases:\n        is_verified = run_simulation(**case_params)\n        # The output format requires Python's True/False to be converted to lowercase.\n        results.append(str(is_verified).lower())\n    \n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "在掌握了粒子追踪和基本物理模拟的基础上，我们现在可以解决更高级、更真实的反应堆物理问题。本练习将探讨在未分辨共振能区中的共振自屏敝现象，这是一个关键效应，使用平均截面的简单模型无法准确捕捉。通过将有偏差的确定论计算与基于概率表的更精确的蒙特卡洛模拟进行比较，本练习展示了随机方法在处理复杂、波动的物理数据方面的独特威力。",
            "id": "4218148",
            "problem": "构建一个自包含的程序，用于量化在均匀化栅元模型中，估算燃料吸收反应率密度时，用平均截面替代未分辨共振区截面的概率表抽样法所引入的偏差。从中子输运和蒙特卡罗（MC）模拟的第一性原理出发，推导估算逻辑，并在一个通用的、物理上合理的模型下实现这两种方法。\n\n假设在未分辨共振区中，栅元燃料区采用均匀化无限介质近似，其中能量为 $E$ 处的标量通量由一个均匀各向同性的体积源与总宏观截面造成的移出之间的平衡来建模。具体来说，假设标量通量由 $\\phi(E) = S(E) / \\Sigma_{t}(E)$ 给出，其中 $S(E)$ 是单位能量单位体积的源强度，$\\Sigma_{t}(E)$ 是总宏观截面。燃料吸收反应率密度由基本关系式 $R_{a} = \\int \\phi(E) \\, \\Sigma_{a,f}(E) \\, dE$ 定义，其中 $\\Sigma_{a,f}(E)$ 是燃料吸收宏观截面。所有反应率密度的单位均为 $\\text{s}^{-1}\\text{cm}^{-3}$，能量单位为电子伏特 (eV)。本问题不涉及角度。\n\n在未分辨共振区的能量区间 $[E_{\\min}, E_{\\max}]$ 上，使用与 $1/E$ 成正比的归一化慢化谱 $f(E)$ 对源谱进行建模，即 $f(E) = C / E$，其中 $C$ 的选择需满足 $\\int_{E_{\\min}}^{E_{\\max}} f(E) \\, dE = 1$。设体积源为 $S(E) = Q \\, f(E)$，其中 $Q$ 是总源率密度，单位为 $\\text{s}^{-1}\\text{cm}^{-3}$。\n\n按如下方式对未分辨共振区的燃料宏观截面进行建模。依赖于能量的燃料平均总宏观截面为 $\\overline{\\Sigma}_{f}(E) = B + A E^{-\\alpha}$，其中 $A > 0$，$\\alpha > 0$ 且 $B \\ge 0$。燃料吸收是燃料总截面的一个固定比例：$\\Sigma_{a,f}(E) = p_{a} \\, \\Sigma_{f}(E)$，其中 $0  p_{a}  1$。用于移出效应的总宏观截面为 $\\Sigma_{t}(E) = \\Sigma_{b} + \\Sigma_{f}(E)$，其中 $\\Sigma_{b}$ 是一个不依赖于能量的本底宏观截面，用于计入慢化剂和结构材料的影响。在概率表方法中，未分辨共振涨落由每个能量点上 $\\Sigma_{f}(E)$ 的一个分布表示，其均值为 $\\overline{\\Sigma}_{f}(E)$，变异系数依赖于 $\\Sigma_{b}$。使用均值为 $\\overline{\\Sigma}_{f}(E)$ 且变异系数为\n$$\n\\mathrm{cv}_{b} = \\frac{\\mathrm{cv}_{0}}{\\sqrt{1 + \\Sigma_{b} / \\Sigma_{\\mathrm{ref}}}},\n$$\n的对数正态分布来描述 $\\Sigma_{f}(E)$，其中 $\\mathrm{cv}_{0} > 0$ 和 $\\Sigma_{\\mathrm{ref}} > 0$ 是常数。对于均值为 $m$、变异系数为 $c$ 的对数正态分布，其对数参数为 $\\sigma^{2} = \\ln(1 + c^{2})$ 和 $\\mu = \\ln(m) - \\frac{1}{2}\\sigma^{2}$。在平均截面方法中，确定性地设置 $\\Sigma_{f}(E) = \\overline{\\Sigma}_{f}(E)$。\n\n在这些假设下：\n- 反应率密度的概率表估算值是期望\n$$\nR_{a}^{\\mathrm{PT}} = Q \\, \\mathbb{E}_{E \\sim f}\\left[ \\mathbb{E}_{\\Sigma_{f} \\sim \\mathrm{LogNormal}(\\mu(E),\\sigma^{2}(E))} \\left( \\frac{p_{a} \\, \\Sigma_{f}}{\\Sigma_{b} + \\Sigma_{f}} \\right) \\right].\n$$\n- 平均截面估算值为\n$$\nR_{a}^{\\mathrm{AVG}} = Q \\, \\mathbb{E}_{E \\sim f}\\left[ \\frac{p_{a} \\, \\overline{\\Sigma}_{f}(E)}{\\Sigma_{b} + \\overline{\\Sigma}_{f}(E)} \\right].\n$$\n\n相对偏差 $\\delta$ 定义为小数形式（而非使用百分号）：\n$$\n\\delta = \\frac{R_{a}^{\\mathrm{AVG}} - R_{a}^{\\mathrm{PT}}}{R_{a}^{\\mathrm{PT}}}.\n$$\n\n您的程序必须：\n- 使用 $N$ 个样本实现 $R_{a}^{\\mathrm{PT}}$ 的蒙特卡罗估算器，通过从 $f(E)$ 中抽取能量 $E$ 并从相应的对数正态分布中抽取 $\\Sigma_{f}$，然后对量 $p_{a} \\, \\Sigma_{f} / (\\Sigma_{b} + \\Sigma_{f})$进行平均，再乘以 $Q$。\n- 使用合适的求积法，在 $[E_{\\min}, E_{\\max}]$ 区间上实现 $R_{a}^{\\mathrm{AVG}}$ 的数值积分，被积函数为 $f(E) \\, p_{a} \\, \\overline{\\Sigma}_{f}(E) / (\\Sigma_{b} + \\overline{\\Sigma}_{f}(E))$，结果再乘以 $Q$。\n- 计算并返回每个测试用例的相对偏差 $\\delta$。\n\n使用以下测试套件，该套件检验了典型、高本底和低本底三种情况：\n1. 正常情况：$E_{\\min} = 10 \\,\\mathrm{eV}$，$E_{\\max} = 1000 \\,\\mathrm{eV}$，$Q = 10^{6} \\,\\mathrm{s}^{-1}\\mathrm{cm}^{-3}$，$A = 0.6 \\,\\mathrm{cm}^{-1} \\,\\mathrm{eV}^{\\alpha}$，$\\alpha = 0.5$，$B = 0.1 \\,\\mathrm{cm}^{-1}$，$\\Sigma_{b} = 0.5 \\,\\mathrm{cm}^{-1}$，$p_{a} = 0.3$，$\\mathrm{cv}_{0} = 0.8$，$\\Sigma_{\\mathrm{ref}} = 1.0 \\,\\mathrm{cm}^{-1}$，$N = 200000$，seed $= 12345$。\n2. 高本底情况：与情况1相同，除了 $\\Sigma_{b} = 5.0 \\,\\mathrm{cm}^{-1}$，seed $= 23456$。\n3. 低本底情况：与情况1相同，除了 $\\Sigma_{b} = 0.05 \\,\\mathrm{cm}^{-1}$，seed $= 34567$。\n\n您的程序应产生单行输出，其中包含一个由方括号括起来的逗号分隔列表（例如，“[result1,result2,result3]”），每个结果是对应测试用例的相对偏差 $\\delta$，以浮点数形式表示。不应打印任何其他文本。",
            "solution": "目标是量化在计算燃料吸收反应率时，用平均截面替代由概率表表示的未分辨共振区截面所引入的相对偏差 $\\delta$。相对偏差定义为 $\\delta = (R_{a}^{\\mathrm{AVG}} - R_{a}^{\\mathrm{PT}}) / R_{a}^{\\mathrm{PT}}$，其中 $R_{a}^{\\mathrm{AVG}}$ 是使用平均截面计算的反应率密度，而 $R_{a}^{\\mathrm{PT}}$ 是使用概率表方法计算的反应率。\n\n首先，我们建立计算平均截面反应率 $R_{a}^{\\mathrm{AVG}}$ 的步骤。问题将此量定义为对源能谱 $f(E)$ 的期望：\n$$\nR_{a}^{\\mathrm{AVG}} = Q \\, \\mathbb{E}_{E \\sim f}\\left[ \\frac{p_{a} \\, \\overline{\\Sigma}_{f}(E)}{\\Sigma_{b} + \\overline{\\Sigma}_{f}(E)} \\right]\n$$\n根据期望的定义，这可以写成在能量范围 $[E_{\\min}, E_{\\max}]$ 上的定积分：\n$$\nR_{a}^{\\mathrm{AVG}} = Q \\int_{E_{\\min}}^{E_{\\max}} \\frac{p_{a} \\, \\overline{\\Sigma}_{f}(E)}{\\Sigma_{b} + \\overline{\\Sigma}_{f}(E)} f(E) \\, dE\n$$\n代入给定的源谱函数形式 $f(E) = C/E$（其中 $C = 1/\\ln(E_{\\max}/E_{\\min})$ 是归一化常数）和平均燃料截面 $\\overline{\\Sigma}_{f}(E) = B + A E^{-\\alpha}$，我们得到待计算的积分为：\n$$\nR_{a}^{\\mathrm{AVG}} = Q \\int_{E_{\\min}}^{E_{\\max}} \\left[ \\frac{p_{a} (B + A E^{-\\alpha})}{\\Sigma_{b} + B + A E^{-\\alpha}} \\right] \\frac{C}{E} \\, dE\n$$\n该积分没有直接的解析解，因此使用数值求积法进行计算。实现将使用 `scipy.integrate` 库中的高精度自适应求积法。\n\n接下来，我们设计估算概率表反应率 $R_{a}^{\\mathrm{PT}}$ 的方法。该量由一个嵌套期望定义：\n$$\nR_{a}^{\\mathrm{PT}} = Q \\, \\mathbb{E}_{E \\sim f}\\left[ \\mathbb{E}_{\\Sigma_{f} \\sim \\mathrm{LogNormal}(\\mu(E),\\sigma^{2}(E))} \\left( \\frac{p_{a} \\, \\Sigma_{f}}{\\Sigma_{b} + \\Sigma_{f}} \\right) \\right]\n$$\n这种结构非常适合用蒙特卡罗方法进行评估。全期望定律允许我们通过从能量 $E$ 和燃料截面 $\\Sigma_{f}$ 的联合概率分布中抽样来估算嵌套期望。估算算法分 $N$ 次试验进行，如下所示：\n\n1.  对于每次试验 $i \\in \\{1, ..., N\\}$，首先从源分布 $f(E) \\propto 1/E$ 中抽取一个能量 $E_i$。这通过逆变换采样法实现。累积分布函数 (CDF) 为 $F(E) = \\int_{E_{\\min}}^{E} f(e) \\, de = \\frac{\\ln(E/E_{\\min})}{\\ln(E_{\\max}/E_{\\min})}$。令 $F(E_i)$ 等于一个均匀分布的随机变量 $u_i \\sim U(0,1)$ 并求解 $E_i$，得到抽样公式：\n    $$\n    E_i = E_{\\min} \\left(\\frac{E_{\\max}}{E_{\\min}}\\right)^{u_i}\n    $$\n\n2.  对于每个抽取的能量 $E_i$，我们确定燃料截面 $\\Sigma_f$ 的对数正态分布的参数。该分布的均值是依赖于能量的平均截面，$m(E_i) = \\overline{\\Sigma}_{f}(E_i) = B + A E_i^{-\\alpha}$。变异系数 $c = \\mathrm{cv}_b$ 在能量上是常数：$\\mathrm{cv}_{b} = \\mathrm{cv}_{0} / \\sqrt{1 + \\Sigma_{b} / \\Sigma_{\\mathrm{ref}}}$。其对应的正态分布的参数 $\\mu(E_i)$ 和 $\\sigma^2$ 使用对数正态分布的标准公式计算：\n    $$\n    \\sigma^2 = \\ln(1 + c^2)\n    $$\n    $$\n    \\mu(E_i) = \\ln(m(E_i)) - \\frac{1}{2}\\sigma^2\n    $$\n\n3.  在能量 $E_i$ 处的分布参数完全确定后，从分布 $\\mathrm{LogNormal}(\\mu(E_i), \\sigma^2)$ 中抽取燃料截面的一个值 $\\Sigma_{f,i}$。\n\n4.  使用抽样值 $E_i$ 和 $\\Sigma_{f,i}$，计算第 $i$ 次试验的目标量的值：\n    $$\n    v_i = \\frac{p_{a} \\, \\Sigma_{f,i}}{\\Sigma_{b} + \\Sigma_{f,i}}\n    $$\n\n总期望的蒙特卡罗估计值是这些值的样本均值：\n$$\n\\mathbb{E}[\\dots] \\approx \\frac{1}{N} \\sum_{i=1}^{N} v_i\n$$\n最后，将此估计值乘以总源率密度 $Q$，即可得到概率表反应率：\n$$\nR_{a}^{\\mathrm{PT}} \\approx Q \\left(\\frac{1}{N} \\sum_{i=1}^{N} v_i\\right)\n$$\n\n该程序实现了这两种不同的计算路径。对于每个测试用例，它通过数值求积法计算 $R_{a}^{\\mathrm{AVG}}$，并通过所述的蒙特卡罗算法估算 $R_{a}^{\\mathrm{PT}}$，使用指定的样本数 $N$ 和随机种子以保证可复现性。然后计算并报告相对偏差 $\\delta$。这种基于物理的第一性原理方法正确地量化了自屏效应，即共振峰内的通量凹陷（通过概率表方法捕捉）导致与简化的平均截面方法相比，有效吸收率更低。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import quad\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: Happy path\n        {'E_min': 10.0, 'E_max': 1000.0, 'Q': 1e6, 'A': 0.6, 'alpha': 0.5, 'B': 0.1,\n         'Sigma_b': 0.5, 'p_a': 0.3, 'cv_0': 0.8, 'Sigma_ref': 1.0, 'N': 200000, 'seed': 12345},\n        # Case 2: High background\n        {'E_min': 10.0, 'E_max': 1000.0, 'Q': 1e6, 'A': 0.6, 'alpha': 0.5, 'B': 0.1,\n         'Sigma_b': 5.0, 'p_a': 0.3, 'cv_0': 0.8, 'Sigma_ref': 1.0, 'N': 200000, 'seed': 23456},\n        # Case 3: Low background\n        {'E_min': 10.0, 'E_max': 1000.0, 'Q': 1e6, 'A': 0.6, 'alpha': 0.5, 'B': 0.1,\n         'Sigma_b': 0.05, 'p_a': 0.3, 'cv_0': 0.8, 'Sigma_ref': 1.0, 'N': 200000, 'seed': 34567}\n    ]\n\n    results = []\n    for params in test_cases:\n        # Calculate the relative bias for each case.\n        result = calculate_bias(**params)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef calculate_bias(E_min, E_max, Q, A, alpha, B, Sigma_b, p_a, cv_0, Sigma_ref, N, seed):\n    \"\"\"\n    Calculates the relative bias between average-cross-section and probability-table\n    methods for estimating fuel absorption reaction rate density.\n\n    Args:\n        E_min (float): Minimum energy in eV.\n        E_max (float): Maximum energy in eV.\n        Q (float): Total source rate density in s^-1 cm^-3.\n        A (float): Parameter for average fuel cross section.\n        alpha (float): Parameter for average fuel cross section.\n        B (float): Parameter for average fuel cross section.\n        Sigma_b (float): Background macroscopic cross section in cm^-1.\n        p_a (float): Absorption probability for fuel.\n        cv_0 (float): Base coefficient of variation.\n        Sigma_ref (float): Reference cross section for cv calculation in cm^-1.\n        N (int): Number of Monte Carlo samples.\n        seed (int): Seed for the random number generator.\n\n    Returns:\n        float: The relative bias delta.\n    \"\"\"\n    # Normalization constant for the 1/E source spectrum f(E)\n    C = 1.0 / np.log(E_max / E_min)\n\n    # --- 1. Calculation of R_a^AVG using numerical quadrature ---\n    \n    # Define the average fuel cross section as a function of energy\n    def avg_sigma_f(E):\n        return B + A * E**(-alpha)\n\n    # Define the integrand for the R_a^AVG calculation\n    def integrand_avg(E):\n        sigma_f_bar = avg_sigma_f(E)\n        # Integrand is f(E) * g(E), where g(E) is the quantity being averaged\n        quantity = (p_a * sigma_f_bar) / (Sigma_b + sigma_f_bar)\n        pdf = C / E\n        return quantity * pdf\n\n    # Numerically integrate over the energy range\n    integral_avg, _ = quad(integrand_avg, E_min, E_max)\n    R_a_AVG = Q * integral_avg\n\n    # --- 2. Calculation of R_a^PT using Monte Carlo simulation ---\n\n    # Initialize a random number generator for reproducibility\n    rng = np.random.default_rng(seed)\n\n    # Step 2a: Sample N energies from the f(E) = C/E distribution\n    # Using inverse transform sampling: E = E_min * (E_max / E_min)^u, where u ~ U(0,1)\n    u_samples = rng.uniform(0.0, 1.0, size=N)\n    E_samples = E_min * (E_max / E_min)**u_samples\n\n    # Step 2b: Determine parameters for the lognormal distribution of Sigma_f\n    # Coefficient of variation for Sigma_f, constant over energy for a given case\n    cv_b = cv_0 / np.sqrt(1 + Sigma_b / Sigma_ref)\n    \n    # Variance of the underlying normal distribution, also constant\n    lognormal_sigma_sq = np.log(1 + cv_b**2)\n    lognormal_sigma = np.sqrt(lognormal_sigma_sq)\n\n    # Mean of Sigma_f at each sampled energy\n    mean_sigma_f_samples = avg_sigma_f(E_samples)\n    \n    # Mean (mu) of the underlying normal distribution at each sampled energy\n    lognormal_mu_samples = np.log(mean_sigma_f_samples) - 0.5 * lognormal_sigma_sq\n\n    # Step 2c: Sample Sigma_f from LogNormal(mu(E), sigma^2)\n    # numpy's lognormal takes mu and sigma (std dev of underlying normal)\n    sigma_f_samples = rng.lognormal(mean=lognormal_mu_samples, sigma=lognormal_sigma, size=N)\n\n    # Step 2d: Calculate the quantity of interest for each sample\n    quantity_pt_samples = (p_a * sigma_f_samples) / (Sigma_b + sigma_f_samples)\n\n    # Estimate the expectation by averaging over all samples\n    expectation_pt = np.mean(quantity_pt_samples)\n    \n    # Calculate the total reaction rate for the probability-table method\n    R_a_PT = Q * expectation_pt\n    \n    # --- 3. Calculation of Relative Bias ---\n    if R_a_PT == 0:\n        # Avoid division by zero, though physically R_a_PT should be positive\n        return np.inf if R_a_AVG > R_a_PT else 0.0\n\n    delta = (R_a_AVG - R_a_PT) / R_a_PT\n    \n    return delta\n\nsolve()\n```"
        }
    ]
}