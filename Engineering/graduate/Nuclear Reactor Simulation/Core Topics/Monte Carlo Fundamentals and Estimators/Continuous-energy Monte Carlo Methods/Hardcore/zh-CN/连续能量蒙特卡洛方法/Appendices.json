{
    "hands_on_practices": [
        {
            "introduction": "蒙特卡罗粒子输运模拟的基石，是能够正确追踪粒子在几何模型中的运动轨迹。本练习聚焦于核心的“射线追踪”算法：计算沿粒子飞行方向到最近几何面边界的距离。掌握这项技能至关重要，因为它决定了粒子的下一步事件是在当前区域内发生碰撞，还是穿越边界进入一个新区域 。",
            "id": "4218147",
            "problem": "在连续能量蒙特卡洛（MC）中子输运中，粒子轨迹沿自由飞行距离前进，直到遇到碰撞或边界穿越。边界穿越查询可简化为三维欧几里得几何中的射线与曲面相交问题。考虑一个位置为 $x_0 \\in \\mathbb{R}^3$、方向为 $\\mathbf{u} \\in \\mathbb{R}^3$ 的粒子，其轨迹由 $s \\ge 0$ 的参数方程 $x(s) = x_0 + s \\mathbf{u}$ 描述。该算法必须在以下有效几何假设下，确定轨迹在最大飞行距离 $R_{\\max} > 0$ 内最近的曲面穿越点：几何体由一组有限的解析曲面构成，这些曲面选自一个目录，包括平面、球面和轴向有限长度的直立圆柱体，且所有曲面都具有明确定义的隐式方程。连续能量蒙特卡洛方法可扩展到由构造实体几何（CSG）描述的几何体，但在此问题中，曲面是直接给出的，任务仅限于计算与列表中任一单个曲面的最近穿越点。\n\n您的任务：\n\n1) 实现一个边界穿越算法，给定 $x_0$、$\\mathbf{u}$、一个有限的曲面列表、一个数值公差 $\\epsilon > 0$ 以及一个最大飞行距离 $R_{\\max} > 0$，返回具有最小有效正相交距离 $s \\in (\\epsilon, R_{\\max}]$ 的曲面标识符及相应的距离 $s$。如果射线在 $(\\epsilon, R_{\\max}]$ 区间内没有与任何曲面相交，则返回数对 $(-1, R_{\\max})$。所有距离必须以米为单位表示，并四舍五入到六位小数。\n\n2) 证明在所述的有效几何假设下，该算法能在有限步内终止。\n\n数学和算法要求：\n\n- 粒子方向 $\\mathbf{u}$应被视为一个通用向量；允许进行归一化，但非必需。该算法必须仅依赖于欧几里得几何的第一性原理（例如，点积和范数）以及最多二次多项式的解析求根。问题必须在不使用快捷公式的情况下进行构建；需从 $x(s) = x_0 + s \\mathbf{u}$ 和曲面的隐式定义推导相交条件。\n\n- 曲面：\n  - 平面：由一个点 $p \\in \\mathbb{R}^3$ 和一个单位法向量 $n \\in \\mathbb{R}^3$ 通过隐式方程 $n \\cdot (x - p) = 0$ 指定。\n  - 球面：由一个中心 $c \\in \\mathbb{R}^3$ 和半径 $r > 0$ 通过隐式方程 $\\|x - c\\|^2 = r^2$ 指定。\n  - 圆柱体（轴向有限）：与 $z$ 轴对齐的直立圆柱体，由半径 $r > 0$、轴向边界 $z_{\\min}  z_{\\max}$ 指定，其侧面隐式方程为 $x_x^2 + x_y^2 = r^2$，并附带轴向约束 $z_{\\min} \\le x_z \\le z_{\\max}$。\n\n- 算法必须丢弃 $s \\le \\epsilon$ 的相交点，以避免在边界上起始时的自相交，并丢弃 $s > R_{\\max}$ 的相交点。对于圆柱体侧面，只有当撞击点的 $z$ 坐标位于 $[z_{\\min}, z_{\\max}]$ 区间内时，相交才有效。\n\n- 物理和数值单位：距离以米报告；角度（如有）应以弧度处理。将每个报告的距离四舍五入到六位小数。\n\n- 最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个结果本身是一个包含两个元素的列表 $[id, d]$，由整数标识符和以米为单位、保留六位小数的浮点数距离组成，例如：$[[0,1.234567],[1,0.500000],[-1,10.000000]]$。\n\n测试套件：\n\n实现该算法并在以下测试案例上进行评估。在每个案例中，都指定了 $x_0$、$\\mathbf{u}$、$\\epsilon$ 和 $R_{\\max}$，并且曲面以带标识符的列表形式给出。\n\n- 案例 1（在球面内的常规路径）：曲面：一个标识符为 $0$ 的球面，中心 $c = (0, 0, 0)$，半径 $r = 2$。射线：$x_0 = (0, 0, 1)$，$\\mathbf{u} = (0, 0, 1)$，$\\epsilon = 10^{-9}$，$R_{\\max} = 100$。预期最近的穿越点在一个有限的 $s$ 处。\n\n- 案例 2（在平面上从边界开始）：曲面：两个平面，标识符为 $0$ 和 $1$。平面 $0$：点 $p = (0, 0, 0)$，法向量 $n = (0, 0, 1)$。平面 $1$：点 $p = (0, 0, 5)$，法向量 $n = (0, 0, 1)$。射线：$x_0 = (0, 0, 0)$，$\\mathbf{u} = (0, 0, 1)$，$\\epsilon = 10^{-9}$，$R_{\\max} = 100$。与平面 $0$ 的相交发生在 $s = 0$ 处，必须丢弃；下一个有效的穿越点是有限的。\n\n- 案例 3（平行射线在范围内无相交）：曲面：一个标识符为 $0$ 的平面，点 $p = (1, 0, 0)$，法向量 $n = (1, 0, 0)$。射线：$x_0 = (0, 0, 0)$，$\\mathbf{u} = (0, 1, 0)$，$\\epsilon = 10^{-9}$，$R_{\\max} = 10$。射线与平面平行；在 $(\\epsilon, R_{\\max}]$ 范围内应找不到相交点。\n\n- 案例 4（与球面无相交）：曲面：一个标识符为 $0$ 的球面，中心 $c = (0, 0, 0)$，半径 $r = 1$。射线：$x_0 = (0, 2, 0)$，$\\mathbf{u} = (1, 0, 0)$，$\\epsilon = 10^{-9}$，$R_{\\max} = 10$。射线未击中球面；在 $(\\epsilon, R_{\\max}]$ 范围内应找不到相交点。\n\n- 案例 5（击中有限圆柱体侧面）：曲面：一个标识符为 $0$ 的有限圆柱体侧面，半径 $r = 1$，轴向边界 $z_{\\min} = 0$，$z_{\\max} = 3$。射线：$x_0 = (0.5, 0, 1)$，$\\mathbf{u} = (1, 0, 0)$，$\\epsilon = 10^{-9}$，$R_{\\max} = 100$。与侧面最近的有效穿越点发生在一个有限的 $s$ 处，且必须满足轴向约束。\n\n您的实现必须生成单行文本，其中包含按给定顺序排列的五个案例的 $[id, d]$ 对列表。",
            "solution": "该问题要求开发一种边界穿越算法，这是连续能量蒙特卡洛粒子输运方法的基础。该算法必须确定粒子轨迹（建模为几何射线）与一组预定义的解析曲面之间的最近相交点。\n\n**1. 算法框架与问题公式化**\n\n设粒子轨迹为一条由参数方程 $x(d) = x_0 + d\\mathbf{v}$ 定义的射线，其中 $x_0 \\in \\mathbb{R}^3$ 是初始位置，$\\mathbf{v} \\in \\mathbb{R}^3$ 是单位方向向量（$\\|\\mathbf{v}\\| = 1$），$d \\ge 0$ 是从 $x_0$ 沿射线的距离。首先将输入的方向向量 $\\mathbf{u}$ 归一化以得到 $\\mathbf{v} = \\mathbf{u} / \\|\\mathbf{u}\\|$，从而确保参数 $d$ 代表真实的物理距离（单位：米）。此归一化步骤是允许的，它可以简化后续的几何计算。\n\n问题在于找到最小的有效相交距离 $d_{\\min}$ 及相应的曲面标识符 $id_{\\min}$。如果距离 $d$ 满足 $d \\in (\\epsilon, R_{\\max}]$，则认为该距离有效。其中 $\\epsilon > 0$ 是一个小的公差，用于避免在起点发生自相交；$R_{\\max} > 0$ 是当前输运步骤的最大飞行距离。\n\n算法流程如下：\n1. 将迄今找到的最小距离初始化为最大允许距离，$d_{\\min} \\leftarrow R_{\\max}$，并将相应的曲面标识符初始化为一个哨兵值，$id_{\\min} \\leftarrow -1$。\n2. 对于提供的有限列表中的每个曲面，计算一个有序的正相交距离集合 $\\{d_i\\}$。\n3. 对每个计算出的距离 $d_i$，检查其有效性。如果 $d_i \\in (\\epsilon, d_{\\min})$，则该相交有效。\n4. 如果找到一个有效的相交点，则更新状态：$d_{\\min} \\leftarrow d_i$ 且 $id_{\\min} \\leftarrow$ 当前曲面标识符。后续曲面的搜索范围现在缩减为 $(\\epsilon, d_{\\min})$。\n5. 遍历所有曲面后，数对 $(id_{\\min}, d_{\\min})$ 即为结果。\n\n**2. 射线-曲面相交距离的推导**\n\n该算法的核心是针对每种曲面类型，解析计算相交距离 $d$。这通过将射线方程代入曲面的隐式方程并求解 $d$ 来实现。\n\n**2.1. 射线-平面相交**\n平面由一个点 $p \\in \\mathbb{R}^3$ 和一个单位法向量 $n \\in \\mathbb{R}^3$ 定义。其隐式方程为 $n \\cdot (x - p) = 0$。\n代入射线方程 $x(d) = x_0 + d\\mathbf{v}$：\n$$n \\cdot ((x_0 + d\\mathbf{v}) - p) = 0$$\n展开点积：\n$$n \\cdot (x_0 - p) + d(n \\cdot \\mathbf{v}) = 0$$\n求解 $d$：\n$$d = \\frac{n \\cdot (p - x_0)}{n \\cdot \\mathbf{v}}$$\n仅当分母 $n \\cdot \\mathbf{v} \\neq 0$ 时，此表达式才有定义。\n- 如果 $|n \\cdot \\mathbf{v}|$ 小于数值精度公差，则认为射线与平面平行。在这种情况下，除非射线位于平面内（即 $n \\cdot (p - x_0) = 0$），否则不会发生相交。而射线在平面内不属于离散的穿越事件，因此对于 $d > 0$ 的情况予以忽略。\n- 如果 $n \\cdot \\mathbf{v} \\neq 0$，则计算出一个唯一的相交距离 $d$。\n\n**2.2. 射线-球面相交**\n球面由一个中心 $c \\in \\mathbb{R}^3$ 和一个半径 $r > 0$ 定义。其隐式方程为 $\\|x - c\\|^2 = r^2$。\n令 $\\Delta x_c = x_0 - c$。代入射线方程 $x(d) = x_0 + d\\mathbf{v} = c + \\Delta x_c + d\\mathbf{v}$：\n$$\\|(\\Delta x_c + d\\mathbf{v})\\|^2 - r^2 = 0$$\n展开平方范数，即向量与其自身的点积：\n$$(\\Delta x_c + d\\mathbf{v}) \\cdot (\\Delta x_c + d\\mathbf{v}) - r^2 = 0$$\n$$\\|\\Delta x_c\\|^2 + 2d(\\Delta x_c \\cdot \\mathbf{v}) + d^2\\|\\mathbf{v}\\|^2 - r^2 = 0$$\n由于 $\\mathbf{v}$ 是单位向量，$\\|\\mathbf{v}\\|^2 = 1$。这产生了一个关于 $d$ 的二次方程，形式为 $ad^2 + bd + c_{_Q} = 0$：\n$$d^2 + (2(\\Delta x_c \\cdot \\mathbf{v}))d + (\\|\\Delta x_c\\|^2 - r^2) = 0$$\n系数为：$a=1$，$b=2((x_0-c)\\cdot\\mathbf{v})$，以及 $c_{_Q}=\\|x_0-c\\|^2 - r^2$。\n判别式为 $\\mathcal{D} = b^2 - 4ac_{_Q}$。\n- 如果 $\\mathcal{D}  0$，方程没有实数根，射线未击中球面。\n- 如果 $\\mathcal{D} \\ge 0$，则有一个或两个实数根，由二次求根公式给出：\n$$d = \\frac{-b \\pm \\sqrt{\\mathcal{D}}}{2a} = -\\frac{b}{2} \\pm \\frac{\\sqrt{\\mathcal{D}}}{2}$$\n令 $b' = b/2 = (x_0-c)\\cdot\\mathbf{v}$ 且 $c' = c_{_Q}$。方程为 $d^2+2b'd+c'=0$，解为 $d = -b' \\pm \\sqrt{b'^2-c'}$。\n两个可能的距离是 $d_1 = -b' - \\sqrt{b'^2 - c'}$ 和 $d_2 = -b' + \\sqrt{b'^2 - c'}$。在这些根中，大于 $\\epsilon$ 的最小正距离被选为候选相交距离。\n\n**2.3. 射线-圆柱体相交**\n与 $z$ 轴对齐的直立圆柱体由半径 $r > 0$ 和轴向边界 $z_{\\min}, z_{\\max}$ 定义。其侧面隐式方程为 $x_x^2 + x_y^2 = r^2$，其中 $z_{\\min} \\le x_z \\le z_{\\max}$。\n射线的各分量为 $x_x(d) = x_{0x} + dv_x$ 和 $x_y(d) = x_{0y} + dv_y$。将它们代入侧面方程：\n$$(x_{0x} + dv_x)^2 + (x_{0y} + dv_y)^2 - r^2 = 0$$\n展开并按 $d$ 的幂次收集项：\n$$d^2(v_x^2 + v_y^2) + d(2(x_{0x}v_x + x_{0y}v_y)) + (x_{0x}^2 + x_{0y}^2 - r^2) = 0$$\n这是一个二次方程 $ad^2 + bd + c_{_Q} = 0$，其系数为：\n- $a = v_x^2 + v_y^2$\n- $b = 2(x_{0x}v_x + x_{0y}v_y)$\n- $c_{_Q} = x_{0x}^2 + x_{0y}^2 - r^2$\n与球面情况类似，使用二次求根公式找到根 $d_i$。如果 $a \\approx 0$（即射线几乎与 $z$ 轴平行），该方程退化为线性方程。\n对于每个有效的根 $d_i > \\epsilon$，需要进行进一步检查。相交点的 $z$ 坐标 $z_{hit} = x_{0z} + d_i v_z$ 必须位于圆柱体的轴向边界内：\n$$z_{\\min} \\le z_{hit} \\le z_{\\max}$$\n只有满足此条件，相交距离 $d_i$ 才被认为是有效的。符合条件的最小 $d_i$ 即为此曲面的候选距离。\n\n**3. 终止性证明**\n问题陈述保证了曲面集合是有限的。设其数量为 $N$。该算法包含一个迭代 $N$ 次的单循环。在每次迭代中，所执行的工作量相对于问题规模（除 $N$ 外）是恒定的。对于每种曲面类型（平面、球面、圆柱体），算法执行一个固定的步骤序列：\n- 向量运算（归一化、点积、范数），这些对于三维向量是常数时间操作。\n- 求解一个最多为一次或二次的多项式方程。这也需要常数数量的算术运算。\n- 固定次数的比较，以验证所得的一个或多个距离。\n\n因此，总操作数与 $N$ 成正比。由于 $N$ 是有限的，该算法保证在有限步内执行完毕并终止。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Numerical tolerance for floating point comparisons, e.g., checking for parallelism.\nZERO_TOLERANCE = 1e-12\n\ndef _find_valid_roots(a, b, c, epsilon):\n    \"\"\"\n    Solves a quadratic equation ad^2 + bd + c = 0 and returns a list of \n    valid roots d  epsilon.\n    \"\"\"\n    roots = []\n    \n    if abs(a)  ZERO_TOLERANCE:\n        # Linear equation: bd + c = 0\n        if abs(b)  ZERO_TOLERANCE:\n            d = -c / b\n            if d  epsilon:\n                roots.append(d)\n    else:\n        # Quadratic equation\n        discriminant = b**2 - 4 * a * c\n        if discriminant = 0:\n            sqrt_disc = np.sqrt(discriminant)\n            d1 = (-b - sqrt_disc) / (2 * a)\n            d2 = (-b + sqrt_disc) / (2 * a)\n            \n            # Roots should be sorted to check the smallest positive one first\n            sorted_roots = sorted([d1, d2])\n            for d in sorted_roots:\n                if d  epsilon:\n                    roots.append(d)\n    return roots\n\ndef _intersect_plane(x0, v, p, n, epsilon):\n    \"\"\"Calculates intersection distance with a plane.\"\"\"\n    nv_dot = n.dot(v)\n    if abs(nv_dot)  ZERO_TOLERANCE:\n        return []  # Ray is parallel to the plane\n    \n    d = n.dot(p - x0) / nv_dot\n    if d  epsilon:\n        return [d]\n    return []\n\ndef _intersect_sphere(x0, v, c, r, epsilon):\n    \"\"\"Calculates intersection distance(s) with a sphere.\"\"\"\n    delta_x = x0 - c\n    \n    # Coefficients for ad^2 + bd + c = 0\n    # Since v is normalized, a = v.dot(v) = 1\n    a = 1.0\n    b = 2 * delta_x.dot(v)\n    c_q = delta_x.dot(delta_x) - r**2\n    \n    return _find_valid_roots(a, b, c_q, epsilon)\n\ndef _intersect_cylinder_side(x0, v, r, z_min, z_max, epsilon):\n    \"\"\"Calculates intersection distance(s) with a finite z-aligned cylinder side.\"\"\"\n    # Coefficients for ad^2 + bd + c = 0\n    a = v[0]**2 + v[1]**2\n    b = 2 * (x0[0]*v[0] + x0[1]*v[1])\n    c_q = x0[0]**2 + x0[1]**2 - r**2\n    \n    potential_distances = _find_valid_roots(a, b, c_q, epsilon)\n    \n    valid_distances = []\n    for d in potential_distances:\n        # Check if the hit point is within the axial bounds\n        z_hit = x0[2] + d * v[2]\n        if z_min = z_hit = z_max:\n            valid_distances.append(d)\n            \n    return valid_distances\n\ndef find_nearest_crossing(x0, u, surfaces, epsilon, R_max):\n    \"\"\"\n    Finds the nearest valid surface crossing for a particle track.\n\n    Args:\n        x0 (np.ndarray): Particle starting position.\n        u (np.ndarray): Particle direction vector (not necessarily normalized).\n        surfaces (list): A list of surface description dictionaries.\n        epsilon (float): Small positive distance to avoid self-intersection.\n        R_max (float): Maximum flight distance.\n\n    Returns:\n        tuple: (surface_id, distance) for the nearest crossing. \n               If no crossing, returns (-1, R_max).\n    \"\"\"\n    norm_u = np.linalg.norm(u)\n    if norm_u  ZERO_TOLERANCE:\n        return -1, R_max # No movement\n    v = u / norm_u\n\n    min_dist = R_max\n    min_id = -1\n\n    for surface in surfaces:\n        s_id = surface['id']\n        s_type = surface['type']\n        params = surface['params']\n        \n        distances = []\n        if s_type == 'plane':\n            distances = _intersect_plane(x0, v, params['p'], params['n'], epsilon)\n        elif s_type == 'sphere':\n            distances = _intersect_sphere(x0, v, params['c'], params['r'], epsilon)\n        elif s_type == 'cylinder_side':\n            distances = _intersect_cylinder_side(x0, v, params['r'], params['z_min'], params['z_max'], epsilon)\n        \n        for d in distances:\n            if d  min_dist:\n                min_dist = d\n                min_id = s_id\n    \n    return min_id, min_dist\n\ndef solve():\n    \"\"\"\n    Defines and runs the test suite for the boundary crossing algorithm.\n    \"\"\"\n    test_cases = [\n        # Case 1 (happy path inside a sphere)\n        {\n            'x0': np.array([0.0, 0.0, 1.0]), 'u': np.array([0.0, 0.0, 1.0]),\n            'epsilon': 1e-9, 'R_max': 100.0,\n            'surfaces': [\n                {'id': 0, 'type': 'sphere', 'params': {'c': np.array([0.0, 0.0, 0.0]), 'r': 2.0}}\n            ]\n        },\n        # Case 2 (boundary start on a plane)\n        {\n            'x0': np.array([0.0, 0.0, 0.0]), 'u': np.array([0.0, 0.0, 1.0]),\n            'epsilon': 1e-9, 'R_max': 100.0,\n            'surfaces': [\n                {'id': 0, 'type': 'plane', 'params': {'p': np.array([0.0, 0.0, 0.0]), 'n': np.array([0.0, 0.0, 1.0])}},\n                {'id': 1, 'type': 'plane', 'params': {'p': np.array([0.0, 0.0, 5.0]), 'n': np.array([0.0, 0.0, 1.0])}}\n            ]\n        },\n        # Case 3 (parallel ray with no intersection)\n        {\n            'x0': np.array([0.0, 0.0, 0.0]), 'u': np.array([0.0, 1.0, 0.0]),\n            'epsilon': 1e-9, 'R_max': 10.0,\n            'surfaces': [\n                {'id': 0, 'type': 'plane', 'params': {'p': np.array([1.0, 0.0, 0.0]), 'n': np.array([1.0, 0.0, 0.0])}}\n            ]\n        },\n        # Case 4 (no intersection with a sphere)\n        {\n            'x0': np.array([0.0, 2.0, 0.0]), 'u': np.array([1.0, 0.0, 0.0]),\n            'epsilon': 1e-9, 'R_max': 10.0,\n            'surfaces': [\n                {'id': 0, 'type': 'sphere', 'params': {'c': np.array([0.0, 0.0, 0.0]), 'r': 1.0}}\n            ]\n        },\n        # Case 5 (finite cylinder side hit)\n        {\n            'x0': np.array([0.5, 0.0, 1.0]), 'u': np.array([1.0, 0.0, 0.0]),\n            'epsilon': 1e-9, 'R_max': 100.0,\n            'surfaces': [\n                {'id': 0, 'type': 'cylinder_side', 'params': {'r': 1.0, 'z_min': 0.0, 'z_max': 3.0}}\n            ]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        res_id, res_dist = find_nearest_crossing(\n            case['x0'], case['u'], case['surfaces'], case['epsilon'], case['R_max']\n        )\n        results.append([res_id, res_dist])\n\n    results_str = [f\"[{item[0]},{item[1]:.6f}]\" for item in results]\n    print(f\"[{','.join(results_str)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在掌握了粒子运动追踪的基本方法后，下一步是构建一个完整（尽管简化）的模拟循环。本练习将粒子追踪与碰撞物理（例如散射和吸收）相结合，形成一个首尾贯通的粒子历史模拟过程。我们的目标是通过检验一项基本物理定律——能量守恒，来验证整个模拟程序的正确性，这是开发任何可靠模拟代码时都不可或缺的关键验证步骤 。",
            "id": "4218173",
            "problem": "考虑一个半径为 $R$ 的均匀球形区域，其边界为真空，其中包含一种会发生弹性散射和吸收的虚拟核素。一组独立的中子历史从球心处由一个各向同性点源发射，该源的单能动能为 $E_0$，单位为兆电子伏特 (MeV)。目标是构建一个连续能量蒙特卡罗算法，通过直接模拟来验证能量守恒恒等式：在蒙特卡罗估计量的统计不确定性范围内，总沉积能量等于总源能量减去总泄漏能量。\n\n使用以下科学标准依据：\n- 积分形式的线性玻尔兹曼输运方程能量平衡表明，对于一个具有真空边界的孤立系统，由源引入的动能被分配到沉积在介质中的能量和携带出边界的能量之间。\n- 当一个中子与一个质量比为 $A$（靶核质量除以中子质量）的静止靶核发生弹性散射，且在质心系中散射是各向同性的，那么在实验室系中出射中子的能量 $E'$ 由下式给出\n$$\n\\frac{E'}{E} \\;=\\; \\frac{A^2 + 1 + 2 A \\mu_{\\text{cm}}}{(A+1)^2},\n$$\n其中 $E$ 是入射能量，$\\mu_{\\text{cm}} = \\cos\\theta_{\\text{cm}}$ 是质心系中的散射角余弦。实验室系散射角 $\\theta_{\\text{lab}}$ 满足\n$$\n\\tan\\theta_{\\text{lab}} \\;=\\; \\frac{\\sin\\theta_{\\text{cm}}}{\\cos\\theta_{\\text{cm}} + 1/A},\n$$\n因此\n$$\n\\mu_{\\text{lab}} \\;=\\; \\cos\\theta_{\\text{lab}} \\;=\\; \\frac{\\mu_{\\text{cm}} + 1/A}{\\sqrt{1 + 2\\mu_{\\text{cm}}/A + 1/A^2}}.\n$$\n- 在吸收反应中，中子的动能作为热量在局部沉积。在弹性散射中，每次碰撞中作为材料加热而沉积的能量等于能量损失 $E - E'$。对于真空边界，任何到达边界的中子都会携带其当前动能泄漏出去。\n\n设宏观截面是能量 $E$ 的连续函数，单位为反厘米 ($\\text{cm}^{-1}$):\n- 散射宏观截面为 $\\Sigma_s(E) = \\Sigma_{s0}$ (常数)。\n- 吸收宏观截面为 $\\Sigma_a(E) = \\dfrac{\\Sigma_{a0}}{\\sqrt{E/\\text{MeV}}}$，表示一种类 $1/v$ 行为，其中能量以兆电子伏特为单位测量。总宏观截面为 $\\Sigma_t(E) = \\Sigma_s(E) + \\Sigma_a(E)$。\n到下一次碰撞的自由程距离从均值为 $1/\\Sigma_t(E)$ 的指数分布中抽样，即 $s = -\\ln u / \\Sigma_t(E)$，其中 $u$ 在 $(0,1)$ 上均匀分布。\n\n几何与运动学：\n- 中子从原点开始，方向是各向同性的。沿当前方向到球形边界的距离是 $t^2 + 2 (\\boldsymbol{r}\\cdot\\boldsymbol{u}) t + ( \\|\\boldsymbol{r}\\|^2 - R^2 ) = 0$ 的正根，其中 $\\boldsymbol{r}$ 是当前位置，$\\boldsymbol{u}$ 是当前单位方向矢量。\n- 如果抽样的自由程距离 $s$ 超过边界距离 $d_{\\text{exit}}$，中子会泄漏并将其当前能量 $E$ 带出系统。\n- 如果在穿过边界之前发生碰撞，则以概率 $\\Sigma_a(E)/\\Sigma_t(E)$ 发生吸收，否则发生弹性散射。在吸收中，沉积能量 $E$ 并终止该历史。在弹性散射中，将 $E - E'$ 作为热量沉积，通过使用极向余弦 $\\mu_{\\text{lab}}$ 和一个均匀方位角进行旋转来更新方向，将能量设置为 $E'$，并继续该历史。\n\n任务：\n1. 实现一个连续能量蒙特卡罗模拟，该模拟对每个历史 $i$ 进行统计：源能量 $S_i = E_0$，总沉积能量 $D_i$（所有弹性散射事件的 $E - E'$ 之和加上吸收事件的 $E$），以及泄漏能量 $L_i$（穿过边界时的能量）。定义单个历史的能量平衡残差 $B_i = S_i - D_i - L_i$，单位为 MeV。\n2. 对于 $N$ 个历史，使用通常的无偏估计量来估计样本均值 $\\bar{B} = \\dfrac{1}{N}\\sum_{i=1}^N B_i$ 和样本标准差 $s_B$。使用中心极限定理 (CLT)，通过检验不等式\n$$\n|\\bar{B}| \\;\\le\\; z \\,\\frac{s_B}{\\sqrt{N}},\n$$\n（其中 $z = 3$，即在三个标准误差内）来验证能量守恒恒等式。如果 $s_B = 0$，则将 $|\\bar{B}| \\le \\varepsilon$（其中 $\\varepsilon$ 是一个小的数值容差）视为验证通过。\n3. 对每个指定的测试用例，报告一个布尔值结果，指明该恒等式是否在统计不确定性范围内得到验证。\n\n单位：\n- 能量必须以兆电子伏特 (MeV) 为单位进行处理和统计。\n- 距离以厘米 ($\\text{cm}$) 为单位。\n- 截面以反厘米 ($\\text{cm}^{-1}$) 为单位。\n- 角度必须以弧度为单位进行抽样和操作。\n\n测试套件：\n为以下参数集提供结果，每个参数集作为一个独立的测试用例：\n- 用例 A (一般混合相互作用): $N = 8000$, $R = 50\\,\\text{cm}$, $\\Sigma_{s0} = 0.20\\,\\text{cm}^{-1}$, $\\Sigma_{a0} = 0.05\\,\\text{cm}^{-1}$, $A = 12$, $E_0 = 2.0\\,\\text{MeV}$。\n- 用例 B (纯吸收介质): $N = 10000$, $R = 50\\,\\text{cm}$, $\\Sigma_{s0} = 0.00\\,\\text{cm}^{-1}$, $\\Sigma_{a0} = 0.10\\,\\text{cm}^{-1}$, $A = 12$, $E_0 = 2.0\\,\\text{MeV}$。\n- 用例 C (纯散射氢，小球): $N = 10000$, $R = 10\\,\\text{cm}$, $\\Sigma_{s0} = 0.10\\,\\text{cm}^{-1}$, $\\Sigma_{a0} = 0.00\\,\\text{cm}^{-1}$, $A = 1$, $E_0 = 2.0\\,\\text{MeV}$。\n- 用例 D (近真空，大球): $N = 10000$, $R = 100\\,\\text{cm}$, $\\Sigma_{s0} = 0.005\\,\\text{cm}^{-1}$, $\\Sigma_{a0} = 0.00\\,\\text{cm}^{-1}$, $A = 1$, $E_0 = 2.0\\,\\text{MeV}$。\n\n要求的最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，“[$\\text{result1}$,$\\text{result2}$,$\\text{result3}$,$\\text{result4}$]”），每个结果都是一个布尔值，指示能量守恒恒等式是否在相应测试用例的三个标准误差内得到验证。",
            "solution": "该问题要求构建一个连续能量蒙特卡罗中子输运模拟，以验证有限球形介质内的能量守恒恒等式。该恒等式指出，由源引入的总能量必须等于介质内沉积的能量与从系统泄漏出去的能量之和。验证将通过检查单个历史的能量平衡残差的均值在统计上是否与零无法区分来执行。\n\n该解决方案建立在中性粒子线性玻尔兹曼输运方程所应用的能量守恒原理之上。对于具有源 $S(\\boldsymbol{r}, E, \\boldsymbol{\\Omega})$ 的稳态系统，能量平衡可以表示为：\n$$\n\\int_V d\\boldsymbol{r} \\int_{4\\pi} d\\boldsymbol{\\Omega} \\int_0^\\infty dE \\, E \\, S(\\boldsymbol{r}, E, \\boldsymbol{\\Omega}) \\;=\\; \\int_V d\\boldsymbol{r} \\int_0^\\infty dE \\, E_{\\text{dep}}(\\boldsymbol{r}, E) + \\int_{\\partial V} d\\boldsymbol{s} \\int_0^\\infty dE \\, E \\, (\\boldsymbol{n} \\cdot \\boldsymbol{\\Omega}) \\, \\Psi(\\boldsymbol{r}_s, E, \\boldsymbol{\\Omega})\n$$\n其中左边是总源能量，右边第一项是总沉积能量，第二项是穿过表面 $\\partial V$ 的总泄漏能量。蒙特卡罗方法提供了一种通过模拟大量单个粒子历史来估计这些积分量的方法。问题指出，必须统计每个历史的平衡量 $S_i - D_i - L_i$，其中 $S_i$ 是源能量，$D_i$ 是总沉积能量，$L_i$ 是历史 $i$ 的泄漏能量。根据构造，对于具有完美算术的模拟仿真，这个残差 $B_i = S_i - D_i - L_i$ 对每个历史都恒等于零。因此，该任务变成了一个代码验证问题，测试实现是否在每一步都正确地守恒能量，以至于计算出的残差在浮点精度范围内为零。\n\n该算法通过模拟 $N$ 个独立的中子历史来进行。每个历史追踪一个中子从其在源处发射到因吸收或泄漏而终止的整个过程。\n\n1.  **源粒子初始化**：每个中子历史 $i$ 都以一个位于球心 $\\boldsymbol{r} = (0,0,0)$ 的粒子开始。源能量固定为 $S_i = E_0$。初始行进方向，即单位矢量 $\\boldsymbol{u}$，从一个各向同性分布中抽样。这通过从 $[-1, 1]$ 中均匀抽样极角余弦 $\\mu_z = \\cos\\theta$ 和从 $[0, 2\\pi]$ 中均匀抽样方位角 $\\phi$ 来实现，然后构建方向矢量 $\\boldsymbol{u} = (\\sqrt{1-\\mu_z^2}\\cos\\phi, \\sqrt{1-\\mu_z^2}\\sin\\phi, \\mu_z)$。对于每个历史，沉积能量 $D_i$ 和泄漏能量 $L_i$ 的统计量都初始化为 $0$。\n\n2.  **中子输运循环**：模拟的核心是一个循环，它将中子从一个事件推进到下一个事件。在循环的每一步中，中子位于位置 $\\boldsymbol{r}$，具有能量 $E$ 和方向 $\\boldsymbol{u}$。\n    -   **截面评估**：总宏观截面 $\\Sigma_t(E)$ 计算为散射截面 $\\Sigma_s(E) = \\Sigma_{s0}$ 和吸收截面 $\\Sigma_a(E) = \\Sigma_{a0}/\\sqrt{E}$ 的和。\n    -   **到碰撞点的距离**：到下一次可能碰撞的路径长度 $s$ 从一个平均自由程为 $1/\\Sigma_t(E)$ 的指数概率分布中抽样。这通过抽样一个均匀随机数 $\\xi_1 \\in (0,1)$ 并计算 $s = -\\ln(\\xi_1) / \\Sigma_t(E)$ 来完成。如果 $\\Sigma_t(E) = 0$，则路径长度为无穷大。\n    -   **到边界的距离**：从当前位置 $\\boldsymbol{r}$ 沿当前方向 $\\boldsymbol{u}$ 到半径为 $R$ 的球形边界的距离 $d_{\\text{exit}}$ 被确定。这是一元二次方程 $t^2 + 2(\\boldsymbol{r}\\cdot\\boldsymbol{u})t + (\\|\\boldsymbol{r}\\|^2 - R^2) = 0$ 的正根，即 $d_{\\text{exit}} = -(\\boldsymbol{r}\\cdot\\boldsymbol{u}) + \\sqrt{(\\boldsymbol{r}\\cdot\\boldsymbol{u})^2 - (\\|\\boldsymbol{r}\\|^2 - R^2)}$。\n    -   **事件判定**：将抽样的到碰撞点的距离 $s$ 与到边界的距离 $d_{\\text{exit}}$ 进行比较。\n        -   如果 $s \\ge d_{\\text{exit}}$，中子在未碰撞的情况下到达边界。它从系统中泄漏。该历史的泄漏能量被设置为中子的当前能量 $L_i = E$，并且该历史被终止。\n        -   如果 $s  d_{\\text{exit}}$，中子行进距离 $s$ 并发生碰撞。粒子的位置更新为 $\\boldsymbol{r}' = \\boldsymbol{r} + s\\boldsymbol{u}$。\n\n3.  **碰撞物理**：如果发生碰撞，其类型将以概率方式确定。\n    -   抽样一个随机数 $\\xi_2 \\in (0,1)$。\n    -   如果 $\\xi_2  \\Sigma_a(E) / \\Sigma_t(E)$，则碰撞为**吸收**。中子的全部动能 $E$ 沉积在材料中。更新沉积能量的统计量，$D_i \\leftarrow D_i + E$，并终止该历史。\n    -   否则，碰撞为**弹性散射**。中子损失部分能量并改变方向。\n        -   **能量运动学**：出射能量 $E'$ 由散射运动学确定。对于质心 (CM) 系中的各向同性散射，从 $[-1, 1]$ 中均匀抽样质心系散射角的余弦 $\\mu_{\\text{cm}}$。实验室系中的新能量为 $E' = E \\frac{A^2 + 1 + 2A\\mu_{\\text{cm}}}{(A+1)^2}$。\n        -   **能量沉积**：中子损失的能量作为热量沉积。更新统计量：$D_i \\leftarrow D_i + (E - E')$。然后将中子的能量更新为 $E'$。\n        -   **方向运动学**：更新中子的方向矢量 $\\boldsymbol{u}$。实验室系散射角的余弦为 $\\mu_{\\text{lab}} = \\frac{\\mu_{\\text{cm}} + 1/A}{\\sqrt{1 + 2\\mu_{\\text{cm}}/A + 1/A^2}}$。抽样一个随机的方位散射角 $\\phi_{\\text{azimuth}} \\in [0, 2\\pi]$。旧的方向矢量 $\\boldsymbol{u}$ 通过极角 $\\theta_{\\text{lab}} = \\arccos(\\mu_{\\text{lab}})$ 和方位角 $\\phi_{\\text{azimuth}}$ 旋转以获得新方向 $\\boldsymbol{u}'$。中子的方向更新为 $\\boldsymbol{u}'$。\n        -   然后，输运循环从步骤 2 继续，使用更新后的粒子状态 ($\\boldsymbol{r}', E', \\boldsymbol{u}'$)。\n\n4.  **统计与统计分析**：在每个历史 $i$ 终止后，计算能量平衡残差：$B_i = S_i - D_i - L_i$。由于统计方式是，动能的每一次变化都记为沉积或最终泄漏，因此该值在数值上应非常接近于零。\n    在所有 $N$ 个历史完成后，对残差样本 $\\{B_1, B_2, \\dots, B_N\\}$ 进行分析。计算样本均值 $\\bar{B} = \\frac{1}{N}\\sum_{i=1}^N B_i$ 和无偏样本标准差 $s_B = \\sqrt{\\frac{1}{N-1}\\sum_{i=1}^N (B_i - \\bar{B})^2}$。\n    如果平均残差在均值的三个标准误差内与零一致，即 $|\\bar{B}| \\le 3 \\frac{s_B}{\\sqrt{N}}$，则认为能量守恒恒等式得到验证。\n    在特殊情况下，如果数值误差小到计算出的 $s_B$ 为零，则通过检查 $|\\bar{B}|$ 是否小于一个小的容差 $\\varepsilon$（例如 $\\varepsilon = 10^{-12}$）来进行验证。这证实了该实现在浮点精度内保持了能量守恒。对每个提供的测试用例重复此过程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef rotate_direction(direction_vec, mu_lab, phi_azimuth):\n    \"\"\"\n    Rotates a direction vector by a polar angle (specified by its cosine mu_lab)\n    and an azimuthal angle phi_azimuth.\n    Uses the MCNP standard rotation formula.\n    \"\"\"\n    u, v, w = direction_vec\n    sin_theta_lab = np.sqrt(1.0 - mu_lab**2)\n    cos_phi = np.cos(phi_azimuth)\n    sin_phi = np.sin(phi_azimuth)\n\n    # Handle the case where the initial direction is nearly aligned with the z-axis\n    # to avoid division by zero in the standard formula.\n    if np.abs(w)  1.0 - 1e-9:\n        u_prime = sin_theta_lab * cos_phi\n        v_prime = sin_theta_lab * sin_phi\n        w_prime = mu_lab * np.sign(w)\n    else:\n        # Standard rotation formula\n        temp = np.sqrt(1.0 - w**2)\n        u_prime = u * mu_lab + (sin_theta_lab / temp) * (u * w * cos_phi - v * sin_phi)\n        v_prime = v * mu_lab + (sin_theta_lab / temp) * (v * w * cos_phi + u * sin_phi)\n        w_prime = w * mu_lab - sin_theta_lab * temp * cos_phi\n\n    return np.array([u_prime, v_prime, w_prime], dtype=np.float64)\n\ndef simulate_history(R, Sigma_s0, Sigma_a0, A, E0, rng):\n    \"\"\"\n    Simulates a single neutron history from source to termination.\n    Returns the energy balance residual for the history.\n    \"\"\"\n    # Particle state variables\n    pos = np.zeros(3, dtype=np.float64)\n    energy = np.float64(E0)\n\n    # Sample isotropic source direction\n    mu_z = 2.0 * rng.random() - 1.0\n    phi = 2.0 * np.pi * rng.random()\n    sin_theta = np.sqrt(1.0 - mu_z**2)\n    direction = np.array([sin_theta * np.cos(phi),\n                          sin_theta * np.sin(phi),\n                          mu_z], dtype=np.float64)\n\n    # History tallies\n    deposited_energy = np.float64(0.0)\n    leakage_energy = np.float64(0.0)\n\n    while True:\n        # Check for particle termination by energy threshold (unlikely here)\n        if energy = 0.0:\n            break\n\n        # Macroscopic cross sections\n        sigma_s = np.float64(Sigma_s0)\n        sigma_a = np.float64(Sigma_a0 / np.sqrt(energy)) if energy  0 else np.inf\n        sigma_t = sigma_s + sigma_a\n\n        # Sample distance to collision\n        if sigma_t == 0.0:\n            dist_to_collision = np.inf\n        else:\n            dist_to_collision = -np.log(rng.random()) / sigma_t\n\n        # Calculate distance to sphere boundary\n        r_dot_u = np.dot(pos, direction)\n        r_sq = np.dot(pos, pos)\n        discriminant = r_dot_u**2 - (r_sq - R**2)\n        dist_to_boundary = -r_dot_u + np.sqrt(discriminant)\n        \n        # Determine event: leakage or collision\n        if dist_to_collision = dist_to_boundary:\n            leakage_energy = energy\n            break  # History terminates\n        else:\n            # Move particle to collision site\n            pos += dist_to_collision * direction\n\n            # Determine collision type: absorption or scattering\n            prob_absorption = sigma_a / sigma_t\n            if rng.random()  prob_absorption:\n                deposited_energy += energy\n                break  # History terminates\n            else:\n                # Elastic scattering\n                # Sample CM scattering cosine\n                mu_cm = 2.0 * rng.random() - 1.0\n\n                # Calculate new energy\n                a_plus_1_sq = (A + 1.0)**2\n                energy_prime = energy * (A**2 + 1.0 + 2.0 * A * mu_cm) / a_plus_1_sq\n\n                # Deposit energy loss\n                deposited_energy += (energy - energy_prime)\n\n                # Update particle energy\n                energy = energy_prime\n\n                # Update particle direction\n                mu_lab_num = mu_cm + 1.0 / A\n                mu_lab_den = np.sqrt(1.0 + 2.0 * mu_cm / A + 1.0 / A**2)\n                mu_lab = mu_lab_num / mu_lab_den\n                \n                phi_scatter = 2.0 * np.pi * rng.random()\n                direction = rotate_direction(direction, mu_lab, phi_scatter)\n\n    # Calculate and return the energy balance residual\n    residual = E0 - deposited_energy - leakage_energy\n    return residual\n\ndef run_simulation(N, R, Sigma_s0, Sigma_a0, A, E0):\n    \"\"\"\n    Runs N histories for a given problem configuration and verifies the energy balance.\n    \"\"\"\n    rng = np.random.default_rng(seed=12345)\n    residuals = np.zeros(N, dtype=np.float64)\n\n    for i in range(N):\n        residuals[i] = simulate_history(R, Sigma_s0, Sigma_a0, A, E0, rng)\n    \n    mean_B = np.mean(residuals)\n    std_B = np.std(residuals, ddof=1)\n\n    if std_B == 0.0:\n        # If std dev is numerically zero, all residuals are identical.\n        # Check if the mean (and thus all residuals) is near zero.\n        epsilon = 1e-12 \n        return np.abs(mean_B) = epsilon\n    else:\n        # Standard statistical check\n        z = 3.0\n        standard_error = std_B / np.sqrt(N)\n        return np.abs(mean_B) = z * standard_error\n\ndef solve():\n    \"\"\"\n    Main function to define, run, and report results for all test cases.\n    \"\"\"\n    test_cases = [\n        # Case A\n        {'N': 8000, 'R': 50.0, 'Sigma_s0': 0.20, 'Sigma_a0': 0.05, 'A': 12.0, 'E0': 2.0},\n        # Case B\n        {'N': 10000, 'R': 50.0, 'Sigma_s0': 0.00, 'Sigma_a0': 0.10, 'A': 12.0, 'E0': 2.0},\n        # Case C\n        {'N': 10000, 'R': 10.0, 'Sigma_s0': 0.10, 'Sigma_a0': 0.00, 'A': 1.0, 'E0': 2.0},\n        # Case D\n        {'N': 10000, 'R': 100.0, 'Sigma_s0': 0.005, 'Sigma_a0': 0.00, 'A': 1.0, 'E0': 2.0},\n    ]\n\n    results = []\n    for case_params in test_cases:\n        is_verified = run_simulation(**case_params)\n        # The output format requires Python's True/False to be converted to lowercase.\n        results.append(str(is_verified).lower())\n    \n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "在拥有一个经过验证的模拟框架后，我们现在可以利用它来探索更复杂的物理现象。本练习将深入探讨“非分辨共振区”，在这一能量区间，使用简单的平均截面会导致显著的计算偏差。通过实现并比较概率表方法与平均截面方法，你将亲手量化“共振自屏效应”这一关键概念，并理解为何精确的反应堆分析必须采用更高级的截面处理技术 。",
            "id": "4218148",
            "problem": "构建一个独立的程序，用于在一个均匀化的栅元模型中，量化在估算燃料吸收反应率密度时，用平均截面替代未分辨共振截面的概率表抽样所引入的偏差。从中子输运和蒙特卡洛（MC）模拟的第一性原理推导估算逻辑，并在一个共同的、物理上合理的模型下实现这两种方法。\n\n假设在未分辨共振区中，栅元燃料区采用均匀化的无限介质近似，其中能量为 $E$ 处的标量通量由均匀、各向同性的体积源与总宏观截面移除之间的平衡来建模。具体来说，假设标量通量由 $\\phi(E) = S(E) / \\Sigma_{t}(E)$ 给出，其中 $S(E)$ 是单位能量、单位体积的源强度，$\\Sigma_{t}(E)$ 是总宏观截面。燃料吸收反应率密度由基本关系 $R_{a} = \\int \\phi(E) \\, \\Sigma_{a,f}(E) \\, dE$ 定义，其中 $\\Sigma_{a,f}(E)$ 是燃料吸收宏观截面。所有反应率密度的单位均为 $\\text{s}^{-1}\\text{cm}^{-3}$，能量单位为电子伏特 (eV)。本问题不涉及角度。\n\n在未分辨区的能量区间 $[E_{\\min}, E_{\\max}]$ 上，使用一个归一化的慢化谱 $f(E)$ 对源谱进行建模，该谱与 $1/E$ 成正比，即 $f(E) = C / E$，其中 $C$ 的选择应满足 $\\int_{E_{\\min}}^{E_{\\max}} f(E) \\, dE = 1$。令体积源为 $S(E) = Q \\, f(E)$，其中 $Q$ 是总源率密度，单位为 $\\text{s}^{-1}\\text{cm}^{-3}$。\n\n在未分辨区中，燃料宏观截面的模型如下。依赖于能量的燃料平均总宏观截面为 $\\overline{\\Sigma}_{f}(E) = B + A E^{-\\alpha}$，其中 $A > 0$，$\\alpha > 0$ 且 $B \\ge 0$。燃料吸收是燃料总截面的一个固定比例：$\\Sigma_{a,f}(E) = p_{a} \\, \\Sigma_{f}(E)$，其中 $0  p_{a}  1$。用于移除的总宏观截面为 $\\Sigma_{t}(E) = \\Sigma_{b} + \\Sigma_{f}(E)$，其中 $\\Sigma_{b}$ 是一个与能量无关的本底宏观截面，用于考虑慢化剂和结构材料。在概率表方法中，未分辨共振的涨落由每个能量点上 $\\Sigma_{f}(E)$ 的一个分布来表示，其均值为 $\\overline{\\Sigma}_{f}(E)$，变异系数取决于 $\\Sigma_{b}$。对 $\\Sigma_{f}(E)$ 使用对数正态分布，其均值为 $\\overline{\\Sigma}_{f}(E)$，变异系数为\n$$\n\\mathrm{cv}_{b} = \\frac{\\mathrm{cv}_{0}}{\\sqrt{1 + \\Sigma_{b} / \\Sigma_{\\mathrm{ref}}}},\n$$\n其中 $\\mathrm{cv}_{0} > 0$ 和 $\\Sigma_{\\mathrm{ref}} > 0$ 是常数。对于均值为 $m$、变异系数为 $c$ 的对数正态分布，其对数参数为\n$$\n\\sigma^{2} = \\ln(1 + c^{2})\n$$\n和\n$$\n\\mu = \\ln(m) - \\frac{1}{2}\\sigma^{2}\n$$。在平均截面方法中，确定性地设置 $\\Sigma_{f}(E) = \\overline{\\Sigma}_{f}(E)$。\n\n在这些假设下：\n- 反应率密度的概率表估计值为期望\n$$\nR_{a}^{\\mathrm{PT}} = Q \\, \\mathbb{E}_{E \\sim f}\\left[ \\mathbb{E}_{\\Sigma_{f} \\sim \\mathrm{LogNormal}(\\mu(E),\\sigma^{2}(E))} \\left( \\frac{p_{a} \\, \\Sigma_{f}}{\\Sigma_{b} + \\Sigma_{f}} \\right) \\right].\n$$\n- 平均截面估计值为\n$$\nR_{a}^{\\mathrm{AVG}} = Q \\, \\mathbb{E}_{E \\sim f}\\left[ \\frac{p_{a} \\, \\overline{\\Sigma}_{f}(E)}{\\Sigma_{b} + \\overline{\\Sigma}_{f}(E)} \\right].\n$$\n\n将相对偏差定义为小数（而非百分号形式），公式如下\n$$\n\\delta = \\frac{R_{a}^{\\mathrm{AVG}} - R_{a}^{\\mathrm{PT}}}{R_{a}^{\\mathrm{PT}}}.\n$$\n\n您的程序必须：\n- 使用 $N$ 个样本为 $R_{a}^{\\mathrm{PT}}$ 实现一个蒙特卡洛估计器，通过从 $f(E)$ 中抽取能量 $E$，并从相应的对数正态分布中抽取 $\\Sigma_{f}$，然后对量 $p_{a} \\, \\Sigma_{f} / (\\Sigma_{b} + \\Sigma_{f})$ 进行平均，再乘以 $Q$。\n- 对 $R_{a}^{\\mathrm{AVG}}$ 在 $[E_{\\min}, E_{\\max}]$ 区间上实现一个数值积分，使用合适的数值求积法，被积函数为 $f(E) \\, p_{a} \\, \\overline{\\Sigma}_{f}(E) / (\\Sigma_{b} + \\overline{\\Sigma}_{f}(E))$，再乘以 $Q$。\n- 计算并为每个测试用例返回相对偏差 $\\delta$。\n\n使用以下测试套件，该套件涵盖了典型、高本底和低本底三种情况：\n1. 正常路径用例：$E_{\\min} = 10 \\,\\mathrm{eV}$，$E_{\\max} = 1000 \\,\\mathrm{eV}$，$Q = 10^{6} \\,\\mathrm{s}^{-1}\\mathrm{cm}^{-3}$，$A = 0.6 \\,\\mathrm{cm}^{-1} \\,\\mathrm{eV}^{\\alpha}$，$\\alpha = 0.5$，$B = 0.1 \\,\\mathrm{cm}^{-1}$，$\\Sigma_{b} = 0.5 \\,\\mathrm{cm}^{-1}$，$p_{a} = 0.3$，$\\mathrm{cv}_{0} = 0.8$，$\\Sigma_{\\mathrm{ref}} = 1.0 \\,\\mathrm{cm}^{-1}$，$N = 200000$，seed $= 12345$。\n2. 高本底用例：与用例1相同，除了 $\\Sigma_{b} = 5.0 \\,\\mathrm{cm}^{-1}$，seed $= 23456$。\n3. 低本底用例：与用例1相同，除了 $\\Sigma_{b} = 0.05 \\,\\mathrm{cm}^{-1}$，seed $= 34567$。\n\n您的程序应产生单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表（例如，\"[result1,result2,result3]\"），每个结果是对应测试用例的相对偏差 $\\delta$，表示为浮点数。不应打印任何其他文本。",
            "solution": "目标是量化在计算燃料吸收反应率时，当由概率表表示的未分辨共振截面被其平均值替代时所引入的相对偏差 $\\delta$。相对偏差定义为 $\\delta = (R_{a}^{\\mathrm{AVG}} - R_{a}^{\\mathrm{PT}}) / R_{a}^{\\mathrm{PT}}$，其中 $R_{a}^{\\mathrm{AVG}}$ 是使用平均截面计算的反应率密度，而 $R_{a}^{\\mathrm{PT}}$ 是使用概率表方法计算的反应率。\n\n首先，我们建立计算平均截面反应率 $R_{a}^{\\mathrm{AVG}}$ 的步骤。问题将此量定义为对源能谱 $f(E)$ 的期望：\n$$\nR_{a}^{\\mathrm{AVG}} = Q \\, \\mathbb{E}_{E \\sim f}\\left[ \\frac{p_{a} \\, \\overline{\\Sigma}_{f}(E)}{\\Sigma_{b} + \\overline{\\Sigma}_{f}(E)} \\right]\n$$\n根据期望的定义，这可以写成在能量范围 $[E_{\\min}, E_{\\max}]$ 上的定积分：\n$$\nR_{a}^{\\mathrm{AVG}} = Q \\int_{E_{\\min}}^{E_{\\max}} \\frac{p_{a} \\, \\overline{\\Sigma}_{f}(E)}{\\Sigma_{b} + \\overline{\\Sigma}_{f}(E)} f(E) \\, dE\n$$\n代入给定的源谱函数形式 $f(E) = C/E$（其中 $C = 1/\\ln(E_{\\max}/E_{\\min})$ 是归一化常数）和平均燃料截面 $\\overline{\\Sigma}_{f}(E) = B + A E^{-\\alpha}$，我们得到需要计算的积分：\n$$\nR_{a}^{\\mathrm{AVG}} = Q \\int_{E_{\\min}}^{E_{\\max}} \\left[ \\frac{p_{a} (B + A E^{-\\alpha})}{\\Sigma_{b} + B + A E^{-\\alpha}} \\right] \\frac{C}{E} \\, dE\n$$\n该积分没有直接的解析解，因此使用数值求积法进行计算。实现将使用 `scipy.integrate` 库中的高精度自适应求积方法。\n\n接下来，我们设计估算概率表反应率 $R_{a}^{\\mathrm{PT}}$ 的方法。该量由一个嵌套期望定义：\n$$\nR_{a}^{\\mathrm{PT}} = Q \\, \\mathbb{E}_{E \\sim f}\\left[ \\mathbb{E}_{\\Sigma_{f} \\sim \\mathrm{LogNormal}(\\mu(E),\\sigma^{2}(E))} \\left( \\frac{p_{a} \\, \\Sigma_{f}}{\\Sigma_{b} + \\Sigma_{f}} \\right) \\right]\n$$\n这种结构非常适合通过蒙特卡洛方法进行评估。全期望定律允许我们通过从能量 $E$ 和燃料截面 $\\Sigma_{f}$ 的联合概率分布中抽样来估算该嵌套期望。估算算法按如下方式进行 $N$ 次试验：\n\n1.  对于每次试验 $i \\in \\{1, ..., N\\}$，首先从源分布 $f(E) \\propto 1/E$ 中抽取一个能量 $E_i$。这通过逆变换采样方法实现。累积分布函数（CDF）为\n    $$\n    F(E) = \\int_{E_{\\min}}^{E} f(e) \\, de = \\frac{\\ln(E/E_{\\min})}{\\ln(E_{\\max}/E_{\\min})}\n    $$\n    将 $F(E_i)$ 设为等于一个均匀随机变量 $u_i \\sim U(0,1)$ 并求解 $E_i$，得到抽样公式：\n    $$\n    E_i = E_{\\min} \\left(\\frac{E_{\\max}}{E_{\\min}}\\right)^{u_i}\n    $$\n\n2.  对于每个抽样得到的能量 $E_i$，我们确定燃料截面 $\\Sigma_f$ 的对数正态分布的参数。分布的均值是与能量相关的平均截面，$m(E_i) = \\overline{\\Sigma}_{f}(E_i) = B + A E_i^{-\\alpha}$。变异系数 $c = \\mathrm{cv}_b$ 被给定为相对于能量是恒定的：$\\mathrm{cv}_{b} = \\mathrm{cv}_{0} / \\sqrt{1 + \\Sigma_{b} / \\Sigma_{\\mathrm{ref}}}$。底层正态分布的参数 $\\mu(E_i)$ 和 $\\sigma^2$ 使用对数正态分布的标准公式计算：\n    $$\n    \\sigma^2 = \\ln(1 + c^2)\n    $$\n    $$\n    \\mu(E_i) = \\ln(m(E_i)) - \\frac{1}{2}\\sigma^2\n    $$\n\n3.  在能量 $E_i$ 处的分布参数完全定义后，从分布 $\\mathrm{LogNormal}(\\mu(E_i), \\sigma^2)$ 中抽取一个燃料截面值 $\\Sigma_{f,i}$。\n\n4.  使用抽样值 $E_i$ 和 $\\Sigma_{f,i}$，计算第 $i$ 次试验中我们感兴趣的量的值：\n    $$\n    v_i = \\frac{p_{a} \\, \\Sigma_{f,i}}{\\Sigma_{b} + \\Sigma_{f,i}}\n    $$\n\n总期望的蒙特卡洛估计值是这些值的样本均值：\n$$\n\\mathbb{E}[\\dots] \\approx \\frac{1}{N} \\sum_{i=1}^{N} v_i\n$$\n最后，通过将此估计值乘以总源率密度 $Q$ 来获得概率表反应率：\n$$\nR_{a}^{\\mathrm{PT}} \\approx Q \\left(\\frac{1}{N} \\sum_{i=1}^{N} v_i\\right)\n$$\n\n程序实现了这两个不同的计算路径。对于每个测试用例，它通过数值求积法计算 $R_{a}^{\\mathrm{AVG}}$，并通过所述的蒙特卡洛算法（使用指定的样本数 $N$ 和随机种子以保证可复现性）估计 $R_{a}^{\\mathrm{PT}}$。然后计算并报告相对偏差 $\\delta$。这种基于物理的、第一性原理的方法正确地量化了自屏效应，即共振区内的通量凹陷（由概率表方法捕获）导致与简化的平均截面方法相比，有效吸收率更低。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import quad\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: Happy path\n        {'E_min': 10.0, 'E_max': 1000.0, 'Q': 1e6, 'A': 0.6, 'alpha': 0.5, 'B': 0.1,\n         'Sigma_b': 0.5, 'p_a': 0.3, 'cv_0': 0.8, 'Sigma_ref': 1.0, 'N': 200000, 'seed': 12345},\n        # Case 2: High background\n        {'E_min': 10.0, 'E_max': 1000.0, 'Q': 1e6, 'A': 0.6, 'alpha': 0.5, 'B': 0.1,\n         'Sigma_b': 5.0, 'p_a': 0.3, 'cv_0': 0.8, 'Sigma_ref': 1.0, 'N': 200000, 'seed': 23456},\n        # Case 3: Low background\n        {'E_min': 10.0, 'E_max': 1000.0, 'Q': 1e6, 'A': 0.6, 'alpha': 0.5, 'B': 0.1,\n         'Sigma_b': 0.05, 'p_a': 0.3, 'cv_0': 0.8, 'Sigma_ref': 1.0, 'N': 200000, 'seed': 34567}\n    ]\n\n    results = []\n    for params in test_cases:\n        # Calculate the relative bias for each case.\n        result = calculate_bias(**params)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef calculate_bias(E_min, E_max, Q, A, alpha, B, Sigma_b, p_a, cv_0, Sigma_ref, N, seed):\n    \"\"\"\n    Calculates the relative bias between average-cross-section and probability-table\n    methods for estimating fuel absorption reaction rate density.\n\n    Args:\n        E_min (float): Minimum energy in eV.\n        E_max (float): Maximum energy in eV.\n        Q (float): Total source rate density in s^-1 cm^-3.\n        A (float): Parameter for average fuel cross section.\n        alpha (float): Parameter for average fuel cross section.\n        B (float): Parameter for average fuel cross section.\n        Sigma_b (float): Background macroscopic cross section in cm^-1.\n        p_a (float): Absorption probability for fuel.\n        cv_0 (float): Base coefficient of variation.\n        Sigma_ref (float): Reference cross section for cv calculation in cm^-1.\n        N (int): Number of Monte Carlo samples.\n        seed (int): Seed for the random number generator.\n\n    Returns:\n        float: The relative bias delta.\n    \"\"\"\n    # Normalization constant for the 1/E source spectrum f(E)\n    C = 1.0 / np.log(E_max / E_min)\n\n    # --- 1. Calculation of R_a^AVG using numerical quadrature ---\n    \n    # Define the average fuel cross section as a function of energy\n    def avg_sigma_f(E):\n        return B + A * E**(-alpha)\n\n    # Define the integrand for the R_a^AVG calculation\n    def integrand_avg(E):\n        sigma_f_bar = avg_sigma_f(E)\n        # Integrand is f(E) * g(E), where g(E) is the quantity being averaged\n        quantity = (p_a * sigma_f_bar) / (Sigma_b + sigma_f_bar)\n        pdf = C / E\n        return quantity * pdf\n\n    # Numerically integrate over the energy range\n    integral_avg, _ = quad(integrand_avg, E_min, E_max)\n    R_a_AVG = Q * integral_avg\n\n    # --- 2. Calculation of R_a^PT using Monte Carlo simulation ---\n\n    # Initialize a random number generator for reproducibility\n    rng = np.random.default_rng(seed)\n\n    # Step 2a: Sample N energies from the f(E) = C/E distribution\n    # Using inverse transform sampling: E = E_min * (E_max / E_min)^u, where u ~ U(0,1)\n    u_samples = rng.uniform(0.0, 1.0, size=N)\n    E_samples = E_min * (E_max / E_min)**u_samples\n\n    # Step 2b: Determine parameters for the lognormal distribution of Sigma_f\n    # Coefficient of variation for Sigma_f, constant over energy for a given case\n    cv_b = cv_0 / np.sqrt(1 + Sigma_b / Sigma_ref)\n    \n    # Variance of the underlying normal distribution, also constant\n    lognormal_sigma_sq = np.log(1 + cv_b**2)\n    lognormal_sigma = np.sqrt(lognormal_sigma_sq)\n\n    # Mean of Sigma_f at each sampled energy\n    mean_sigma_f_samples = avg_sigma_f(E_samples)\n    \n    # Mean (mu) of the underlying normal distribution at each sampled energy\n    lognormal_mu_samples = np.log(mean_sigma_f_samples) - 0.5 * lognormal_sigma_sq\n\n    # Step 2c: Sample Sigma_f from LogNormal(mu(E), sigma^2)\n    # numpy's lognormal takes mu and sigma (std dev of underlying normal)\n    sigma_f_samples = rng.lognormal(mean=lognormal_mu_samples, sigma=lognormal_sigma, size=N)\n\n    # Step 2d: Calculate the quantity of interest for each sample\n    quantity_pt_samples = (p_a * sigma_f_samples) / (Sigma_b + sigma_f_samples)\n\n    # Estimate the expectation by averaging over all samples\n    expectation_pt = np.mean(quantity_pt_samples)\n    \n    # Calculate the total reaction rate for the probability-table method\n    R_a_PT = Q * expectation_pt\n    \n    # --- 3. Calculation of Relative Bias ---\n    if R_a_PT == 0:\n        # Avoid division by zero, though physically R_a_PT should be positive\n        return np.inf if R_a_AVG  R_a_PT else 0.0\n\n    delta = (R_a_AVG - R_a_PT) / R_a_PT\n    \n    return delta\n\nsolve()\n```"
        }
    ]
}