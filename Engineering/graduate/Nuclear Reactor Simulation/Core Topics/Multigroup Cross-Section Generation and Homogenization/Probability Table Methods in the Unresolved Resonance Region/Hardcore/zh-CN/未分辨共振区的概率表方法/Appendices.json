{
    "hands_on_practices": [
        {
            "introduction": "本实践旨在巩固使用概率表方法计算群平均截面的核心技能。通过从第一性原理出发，您将推导并应用自屏效应公式，以量化背景截面 $\\sigma_0$ 的变化对群平均俘获截面的影响，从而加深对共振自屏物理机制的理解。 这项练习是理解和应用未分辨共振区中自屏效应的基础。",
            "id": "4242843",
            "problem": "给定一个核反应堆模拟问题，其重点关注非共振区 (URR) 概率表方法。目标是从第一性原理出发，计算当本底截面按指定百分比增加时，群平均微观俘获截面如何变化。非共振区 (URR) 使用概率表进行处理，这些概率表为一个能量群内微观反应截面的分布提供了离散近似。概率表由多个分区组成，每个分区都有相关的概率、微观总截面和微观俘获截面。本底截面表示为$\\sigma_0$，单位为靶恩 (barn)，代表了其他材料和几何泄漏对共振自屏的稀释效应。\n\n从输运慢化平衡（该平衡意味着窄能量群中的能谱近似与微观总截面和本底项之和成反比）以及通量加权群平均的定义出发，推导在单个能量群中使用离散概率表和所述物理假设计算群平均微观俘获截面的表达式。然后，对于给定的增量分数 $\\delta$（以小数形式表示），计算当本底截面从 $\\sigma_0$ 变为 $\\sigma_0(1+\\delta)$ 时，群平均俘获截面的变化量 $\\Delta\\sigma_{c,g}$。所有截面都必须以靶恩为单位处理。最终的数值答案必须是表示 $\\Delta\\sigma_{c,g}$（单位为靶恩）的浮点数，并采用指定的输出格式。\n\n推导的起始假设和核心定义：\n- 在慢化近似和稀释条件下，窄能量群中的中子通量与微观总截面和有效本底项之和的倒数成正比。使用此比例关系作为群内核函数形状。\n- 群平均微观反应截面定义为群上的通量加权平均值。\n- 单个能量群的 URR 概率表是一组包含 $N$ 个分区的集合。每个分区 $i$ 都有一个概率 $p_i$、一个微观总截面 $\\sigma_{t,i}$（单位：靶恩）和一个微观俘获截面 $\\sigma_{c,i}$（单位：靶恩）。概率满足 $\\sum_{i=1}^N p_i = 1$。\n\n任务：\n- 根据所述原理推导算法，用于计算在给定 URR 概率表和本底截面 $\\sigma_0$ 的情况下，单个能量群中的群平均微观俘获截面，然后计算 $\\Delta\\sigma_{c,g} = \\sigma_{c,g}\\big(\\sigma_0(1+\\delta)\\big) - \\sigma_{c,g}(\\sigma_0)$（单位：靶恩）。\n- 在一个程序中实现推导出的算法，以评估下面列出的每个测试用例的 $\\Delta\\sigma_{c,g}$。\n\n测试套件：\n使用以下 URR 概率表和本底变化情景。对于每个表，条目以三元组列表 $[p_i,\\sigma_{t,i},\\sigma_{c,i}]$ 的形式给出，其中 $p_i$ 是无量纲的，$\\sigma_{t,i}$ 和 $\\sigma_{c,i}$ 的单位是靶恩。\n\n- 表 A（中等相关性，四个分区）：\n  - 分区 $1$: $[0.1,150,80]$\n  - 分区 $2$: $[0.2,60,15]$\n  - 分区 $3$: $[0.4,30,3]$\n  - 分区 $4$: $[0.3,80,25]$\n\n- 表 B（强正相关性，四个分区）：\n  - 分区 $1$: $[0.25,10,1]$\n  - 分区 $2$: $[0.25,100,50]$\n  - 分区 $3$: $[0.25,300,150]$\n  - 分区 $4$: $[0.25,1000,600]$\n\n评估以下情况，每种情况产生一个浮点数结果（单位：靶恩）：\n- 情况 $1$：表 A，$\\sigma_0 = 5$ 靶恩，$\\delta = 0.1$。\n- 情况 $2$：表 A，$\\sigma_0 = 0.1$ 靶恩，$\\delta = 0.5$。\n- 情况 $3$：表 A，$\\sigma_0 = 100$ 靶恩，$\\delta = 1.0$。\n- 情况 $4$：表 B，$\\sigma_0 = 1$ 靶恩，$\\delta = 0.2$。\n- 情况 $5$：表 B，$\\sigma_0 = 10$ 靶恩，$\\delta = 0.0$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的每个条目是对应情况下 $\\Delta\\sigma_{c,g}$ 的浮点数值（单位：靶恩），顺序与上面列出的一致。例如，输出必须类似于 $[\\text{result1},\\text{result2},\\text{result3},\\text{result4},\\text{result5}]$，不含任何额外文本。所有数值结果都是单位为靶恩的浮点数。不涉及角度。增加百分比 $\\delta$ 以小数形式提供，不带百分号。",
            "solution": "该问题要求推导并实现一个算法，以计算由于本底截面 $\\sigma_0$ 的变化而引起的群平均微观俘获截面的变化量 $\\Delta\\sigma_{c,g}$。推导过程基于所提供的基本原理。\n\n让能量群用下标 $g$ 表示。微观总截面是 $\\sigma_t(E)$，微观俘获截面是 $\\sigma_c(E)$，两者都是能量 $E$ 的函数。本底截面 $\\sigma_0$ 在群内是常数。\n\n首先，我们建立群平均微观俘获截面 $\\sigma_{c,g}$ 的公式。问题陈述了两个核心假设：\n1. 群平均微观反应截面定义为群上的通量加权平均值。对于俘获截面，即为：\n$$ \\sigma_{c,g} = \\frac{\\int_{g} \\sigma_c(E) \\phi(E) dE}{\\int_{g} \\phi(E) dE} $$\n其中 $\\phi(E)$ 是能量 $E$ 处的中子通量，积分范围是群 $g$ 的能量区间。\n\n2. 在一个窄能量群中，中子通量近似与微观总截面和本底项之和的倒数成正比。这是均匀混合物慢化理论中窄共振 (NR) 近似的结果。\n$$ \\phi(E) \\propto \\frac{1}{\\sigma_t(E) + \\sigma_0} $$\n我们可以将其写为 $\\phi(E) = \\frac{C}{\\sigma_t(E) + \\sigma_0}$，其中 $C$ 是某个归一化常数。\n\n将 $\\phi(E)$ 的表达式代入 $\\sigma_{c,g}$ 的定义中：\n$$ \\sigma_{c,g} = \\frac{\\int_{g} \\sigma_c(E) \\frac{C}{\\sigma_t(E) + \\sigma_0} dE}{\\int_{g} \\frac{C}{\\sigma_t(E) + \\sigma_0} dE} $$\n常数 $C$ 从分子和分母中约去：\n$$ \\sigma_{c,g} = \\frac{\\int_{g} \\frac{\\sigma_c(E)}{\\sigma_t(E) + \\sigma_0} dE}{\\int_{g} \\frac{1}{\\sigma_t(E) + \\sigma_0} dE} $$\n\n概率表方法用离散的概率分布取代了非共振区 (URR) 内截面连续、复杂的能量依赖关系。我们不再对能量 $E$ 进行积分，而是对截面值的概率分布进行平均。单个能量群的概率表由一组 $N$ 个分区组成，其中每个分区 $i$ 由一个概率 $p_i$、一个总截面 $\\sigma_{t,i}$ 和一个俘获截面 $\\sigma_{c,i}$ 来表征。概率被归一化，使得 $\\sum_{i=1}^N p_i = 1$。\n\n这种离散表示允许我们将能量积分替换为对 $N$ 个分区的加权和。函数 $f(\\sigma_t(E), \\sigma_c(E))$ 在群上的积分可以通过使用概率表计算该函数的期望值来近似：\n$$ \\int_g f(\\sigma_t(E), \\sigma_c(E)) dE \\propto \\sum_{i=1}^N p_i f(\\sigma_{t,i}, \\sigma_{c,i}) $$\n将此近似应用于我们 $\\sigma_{c,g}$ 的表达式，分子变为 $\\sum_{i=1}^N p_i \\frac{\\sigma_{c,i}}{\\sigma_{t,i} + \\sigma_0}$，分母变为 $\\sum_{i=1}^N p_i \\frac{1}{\\sigma_{t,i} + \\sigma_0}$。\n\n因此，对于给定的本底 $\\sigma_0$，群平均微观俘获截面为：\n$$ \\sigma_{c,g}(\\sigma_0) = \\frac{\\sum_{i=1}^N p_i \\frac{\\sigma_{c,i}}{\\sigma_{t,i} + \\sigma_0}}{\\sum_{i=1}^N p_i \\frac{1}{\\sigma_{t,i} + \\sigma_0}} $$\n这个公式正确地解释了共振自屏现象。项 $\\frac{1}{\\sigma_{t,i} + \\sigma_0}$ 充当权重因子，对具有高总截面的截面频带（通量被压低的地方）赋予较低的权重。\n\n问题要求计算当本底截面 $\\sigma_0$ 增加一个分数 $\\delta$ 时 $\\sigma_{c,g}$ 的变化。新的本底截面 $\\sigma'_{0}$ 是：\n$$ \\sigma'_{0} = \\sigma_0 (1 + \\delta) $$\n变化量 $\\Delta\\sigma_{c,g}$ 是用新本底计算的群平均俘获截面与用原先本底计算的截面之差：\n$$ \\Delta\\sigma_{c,g} = \\sigma_{c,g}(\\sigma'_{0}) - \\sigma_{c,g}(\\sigma_0) $$\n$$ \\Delta\\sigma_{c,g} = \\frac{\\sum_{i=1}^N \\frac{p_i \\sigma_{c,i}}{\\sigma_{t,i} + \\sigma_0(1+\\delta)}}{\\sum_{i=1}^N \\frac{p_i}{\\sigma_{t,i} + \\sigma_0(1+\\delta)}} - \\frac{\\sum_{i=1}^N \\frac{p_i \\sigma_{c,i}}{\\sigma_{t,i} + \\sigma_0}}{\\sum_{i=1}^N \\frac{p_i}{\\sigma_{t,i} + \\sigma_0}} $$\n\n这是需要实现的最终表达式。增加 $\\sigma_0$ 会减弱自屏效应，因为它使得总有效截面 $\\sigma_t + \\sigma_0$ 在各个概率频带上更加均匀。这会“拉平”通量，导致群平均截面更接近其无限稀释值 ($\\sum p_i \\sigma_{c,i}$)。因此，对于 $\\delta > 0$，我们预期 $\\Delta\\sigma_{c,g} > 0$。对于 $\\delta = 0$，$\\Delta\\sigma_{c,g}$ 必须恰好为 $0$。\n\n算法如下：\n1. 对于每个测试用例，确定概率表 ($\\{p_i, \\sigma_{t,i}, \\sigma_{c,i}\\}$) 、初始本底截面 $\\sigma_0$ 和分数变化量 $\\delta$。\n2. 使用推导出的公式计算初始群平均俘获截面 $\\sigma_{c,g}(\\sigma_0)$。\n3. 计算新的本底截面 $\\sigma'_{0} = \\sigma_0(1+\\delta)$。\n4. 使用新的本底截面计算最终群平均俘获截面 $\\sigma_{c,g}(\\sigma'_{0})$。\n5. 计算差值 $\\Delta\\sigma_{c,g} = \\sigma_{c,g}(\\sigma'_{0}) - \\sigma_{c,g}(\\sigma_0)$。\n6. 存储此结果并对所有测试用例重复此过程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the change in the group-averaged microscopic capture cross section\n    based on the URR probability table method for a given change in the\n    background cross section.\n    \"\"\"\n\n    # Define the probability tables from the problem statement.\n    # Each row is [p_i, sigma_t_i, sigma_c_i]\n    table_A = np.array([\n        [0.1, 150.0, 80.0],\n        [0.2, 60.0, 15.0],\n        [0.4, 30.0, 3.0],\n        [0.3, 80.0, 25.0]\n    ])\n\n    table_B = np.array([\n        [0.25, 10.0, 1.0],\n        [0.25, 100.0, 50.0],\n        [0.25, 300.0, 150.0],\n        [0.25, 1000.0, 600.0]\n    ])\n\n    # Define the test cases from the problem statement.\n    # Each entry is a tuple: (table, sigma_0, delta)\n    test_cases = [\n        (table_A, 5.0, 0.1),\n        (table_A, 0.1, 0.5),\n        (table_A, 100.0, 1.0),\n        (table_B, 1.0, 0.2),\n        (table_B, 10.0, 0.0)\n    ]\n\n    def calculate_group_capture_xs(table: np.ndarray, sigma_0: float) -> float:\n        \"\"\"\n        Calculates the group-averaged microscopic capture cross section.\n        \n        Args:\n            table: A numpy array representing the URR probability table.\n            sigma_0: The background cross section in barns.\n\n        Returns:\n            The group-averaged capture cross section in barns.\n        \"\"\"\n        p = table[:, 0]\n        sigma_t = table[:, 1]\n        sigma_c = table[:, 2]\n\n        # Denominator of the flux weighting factor (sigma_t_i + sigma_0)\n        weight_denom = sigma_t + sigma_0\n        \n        # Numerator of the group-averaged cross section formula:\n        # Sum(p_i * sigma_c_i / (sigma_t_i + sigma_0))\n        numerator = np.sum(p * sigma_c / weight_denom)\n\n        # Denominator of the group-averaged cross section formula:\n        # Sum(p_i / (sigma_t_i + sigma_0))\n        denominator = np.sum(p / weight_denom)\n        \n        # The case of a zero denominator is physically unrealistic with positive\n        # cross sections and probabilities, but included for robustness.\n        if denominator == 0.0:\n            # Fallback to infinitely dilute average, though this should not be reached.\n            return np.sum(p * sigma_c)\n\n        return numerator / denominator\n\n    results = []\n    for table, sigma_0, delta in test_cases:\n        # 1. Calculate the initial group-averaged capture cross section\n        sigma_c_g_initial = calculate_group_capture_xs(table, sigma_0)\n\n        # 2. Calculate the new background cross section\n        sigma_0_new = sigma_0 * (1.0 + delta)\n\n        # 3. Calculate the final group-averaged capture cross section\n        sigma_c_g_final = calculate_group_capture_xs(table, sigma_0_new)\n\n        # 4. Compute the change (Delta sigma_c,g)\n        delta_sigma_c_g = sigma_c_g_final - sigma_c_g_initial\n        results.append(delta_sigma_c_g)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在掌握了基本的自屏截面计算后，我们进一步探讨概率表方法中一个关键的物理假设：分波道截面与总截面之间的相关性。 这个练习将通过对比相关与不相关两种模型，揭示忽略这种物理相关性会如何引入系统性偏差，并量化这种偏差在不同自屏效应强度下的表现。",
            "id": "4242791",
            "problem": "您的任务是使用概率表方法为未分辨共振区 (URR) 构建和分析一个最小的概率表示例，并量化当忽略俘获截面和总截面之间的相关性时，在俘获反应率中引入的偏差。其物理基础如下：在 URR 中，总截面和各通道截面中的共振涨落通过随机方式表示。俘获反应率密度根据第一性原理定义为 $R_\\gamma = N \\int \\phi(E) \\, \\sigma_\\gamma(E) \\, \\mathrm{d}E$，其中 $N$ 是核素数密度，$\\phi(E)$ 是作为能量函数的中子通量，而 $\\sigma_\\gamma(E)$ 是俘获截面。在使用 Bondarenko 自屏模型的概率表方法中，群内核通量形状与总截面和本底截面之和成反比，即 $\\phi(E) \\propto 1/(\\sigma_t(E) + \\sigma_0)$，其中 $\\sigma_t(E)$ 是总截面，$\\sigma_0$ 是表征其他核素和几何形状自屏程度的本底截面。未分辨共振区表现出 $\\sigma_\\gamma$ 和 $\\sigma_t$ 之间的相关性，因为两者都受相同的共振结构控制；忽略这种相关性会导致高 $\\sigma_\\gamma$ 值与低 $\\sigma_t$ 值一同被抽样，这会人为地提高通量权重并使反应率产生偏差。\n\n从基本的反应率定义和给定的通量比例关系出发，推导在保留相关性时一个能群内的适当的通量加权有效俘获截面，然后推导当 $\\sigma_\\gamma$ 独立于 $\\sigma_t$ 抽样时（即忽略相关性）的相应表达式。使用这些推导，针对指定的数值概率表，计算在几个 $\\sigma_0$ 值下俘获反应率的分数偏差，定义为十进制量 $b = (\\sigma_{\\gamma,\\text{eff}}^{\\text{uncorr}} - \\sigma_{\\gamma,\\text{eff}}^{\\text{corr}}) / \\sigma_{\\gamma,\\text{eff}}^{\\text{corr}}$。\n\n您必须编写一个完整、可运行的程序，该程序：\n- 实现一个单未分辨能箱的双态概率表：\n  - 状态 $1$（“本底”）：概率 $p_1 = 0.9$，总截面 $\\sigma_{t,1} = 5$ 靶恩，俘获截面 $\\sigma_{\\gamma,1} = 0.2$ 靶恩。\n  - 状态 $2$（“共振”）：概率 $p_2 = 0.1$，总截面 $\\sigma_{t,2} = 100$ 靶恩，俘获截面 $\\sigma_{\\gamma,2} = 1.0$ 靶恩。\n- 使用 Bondarenko 自屏假设 $\\phi \\propto 1/(\\sigma_t + \\sigma_0)$ 作为群内通量加权的通量形状基础。\n- 当保留 $\\sigma_\\gamma$ 和 $\\sigma_t$ 之间的相关性时（即每个状态的 $\\sigma_\\gamma$ 与其自身的 $\\sigma_t$ 配对），计算通量加权有效俘获截面 $\\sigma_{\\gamma,\\text{eff}}^{\\text{corr}}$。\n- 在假设 $\\sigma_\\gamma$ 独立于 $\\sigma_t$（即忽略相关性）的情况下计算 $\\sigma_{\\gamma,\\text{eff}}^{\\text{uncorr}}$，然后计算如上定义的分数偏差 $b$。\n- 为以下本底截面（单位：靶恩）生成数值结果：$\\sigma_0 \\in \\{0, 0.01, 5, 100, 10^6\\}$。\n\n科学真实性要求：\n- 所有截面必须以靶恩为单位表示。\n- 偏差必须表示为十进制数（不带百分号）。\n- 您的推导必须从 $R_\\gamma = N \\int \\phi(E)\\sigma_\\gamma(E)\\,\\mathrm{d}E$ 和给定的通量比例关系开始，然后逻辑地推导出群有效公式。\n\n测试套件：\n- 使用上面给出的五个 $\\sigma_0$ 值来展示：\n  - 一个低 $\\sigma_0$ 的情况（例如 $\\sigma_0 = 0$ 和 $\\sigma_0 = 0.01$），此时偏差为大的正值（即非相关处理会过高预测）。\n  - 中等 $\\sigma_0$（例如 $\\sigma_0 = 5$ 和 $\\sigma_0 = 100$），显示偏差减小。\n  - 一个非常大的 $\\sigma_0$（例如 $\\sigma_0 = 10^6$），显示偏差趋于 $0$，正如当本底占主导地位并掩盖共振效应时所预期的那样。\n- 可量化的输出必须是浮点数：程序应计算并返回五个 $\\sigma_0$ 值对应的五个偏差 $b$ 的列表。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，$[b_1,b_2,b_3,b_4,b_5]$）。",
            "solution": "首先验证问题，确认其科学基础扎实、提法恰当且信息完整。所有用于获得唯一解的必要数据和定义均已提供。该物理模型基于核反应堆物理学中公认的标准原理，特别是用于未分辨共振区的概率表方法和 Bondarenko 自屏模型。\n\n目标是推导在两种不同假设（相关和非相关截面）下通量加权有效俘获截面的表达式，并为一个给定的双态概率表计算由此产生的分数偏差。\n\n起点是俘获反应的反应率密度 $R_\\gamma$ 在宽度为 $\\Delta E$ 的能群内的定义：\n$$ R_\\gamma = N \\int_{\\Delta E} \\phi(E) \\sigma_\\gamma(E) \\, \\mathrm{d}E $$\n其中 $N$ 是核素数密度，$\\phi(E)$ 是中子通量谱，$\\sigma_\\gamma(E)$ 是微观俘获截面。群有效俘获截面 $\\sigma_{\\gamma, \\text{eff}}$ 的定义使得反应率可以用群平均通量 $\\bar{\\phi} = \\frac{1}{\\Delta E} \\int_{\\Delta E} \\phi(E) \\, \\mathrm{d}E$ 来表示。\n$$ R_\\gamma = N \\bar{\\phi} \\sigma_{\\gamma, \\text{eff}} \\Delta E $$\n通过令两个 $R_\\gamma$ 表达式相等，我们找到有效截面的形式化定义：\n$$ \\sigma_{\\gamma, \\text{eff}} = \\frac{\\int_{\\Delta E} \\phi(E) \\sigma_\\gamma(E) \\, \\mathrm{d}E}{\\int_{\\Delta E} \\phi(E) \\, \\mathrm{d}E} = \\frac{\\langle \\phi \\sigma_\\gamma \\rangle}{\\langle \\phi \\rangle} $$\n其中尖括号表示在能群上的平均。\n\n概率表方法将能量的连续函数 $\\sigma_t(E)$ 和 $\\sigma_\\gamma(E)$ 离散化为有限数量的状态，用索引 $i$ 表示。每个状态在能群内出现的概率为 $p_i$，并具有相关的截面值 $\\sigma_{t,i}$ 和 $\\sigma_{\\gamma,i}$。积分被概率加权和所取代：\n$$ \\sigma_{\\gamma, \\text{eff}} = \\frac{\\sum_i p_i \\phi_i \\sigma_{\\gamma,i}}{\\sum_j p_j \\phi_j} $$\n问题指定了 Bondarenko 自屏模型的通量，其中群内的通量形状被认为与总宏观截面成反比。对于单个核素，其微观等效形式为 $\\phi(E) \\propto 1/(\\sigma_t(E) + \\sigma_0)$，其中 $\\sigma_0$ 是代表所有其他材料的本底截面。因此，对于每个状态 $i$，通量加权因子为 $\\phi_i = C/(\\sigma_{t,i} + \\sigma_0)$，其中 $C$ 是一个比例常数，会从分子和分母中约去。\n$$ \\sigma_{\\gamma, \\text{eff}} = \\frac{\\sum_i p_i \\left( \\frac{C}{\\sigma_{t,i} + \\sigma_0} \\right) \\sigma_{\\gamma,i}}{\\sum_j p_j \\left( \\frac{C}{\\sigma_{t,j} + \\sigma_0} \\right)} = \\frac{\\sum_i p_i \\frac{\\sigma_{\\gamma,i}}{\\sigma_{t,i} + \\sigma_0}}{\\sum_j p_j \\frac{1}{\\sigma_{t,j} + \\sigma_0}} $$\n这是用于后续推导的通用公式。\n\n提供的双态概率表是：\n状态 1：$p_1 = 0.9$，$\\sigma_{t,1} = 5$ 靶恩，$\\sigma_{\\gamma,1} = 0.2$ 靶恩。\n状态 2：$p_2 = 0.1$，$\\sigma_{t,2} = 100$ 靶恩，$\\sigma_{\\gamma,2} = 1.0$ 靶恩。\n\n要测试的本底截面为 $\\sigma_0 \\in \\{0, 0.01, 5, 100, 10^6\\}$ 靶恩。\n\n**情况 1：相关有效截面 ($\\sigma_{\\gamma,\\text{eff}}^{\\text{corr}}$)**\n在相关情况下，配对 $(\\sigma_{t,i}, \\sigma_{\\gamma,i})$ 是内在地联系在一起的。这是物理上正确的表示，因为两种截面都由相同的底层共振参数决定。我们直接将通用公式应用于给定的两个状态（$i=1, 2$）：\n$$ \\sigma_{\\gamma,\\text{eff}}^{\\text{corr}} = \\frac{p_1 \\frac{\\sigma_{\\gamma,1}}{\\sigma_{t,1} + \\sigma_0} + p_2 \\frac{\\sigma_{\\gamma,2}}{\\sigma_{t,2} + \\sigma_0}}{p_1 \\frac{1}{\\sigma_{t,1} + \\sigma_0} + p_2 \\frac{1}{\\sigma_{t,2} + \\sigma_0}} $$\n\n**情况 2：非相关有效截面 ($\\sigma_{\\gamma,\\text{eff}}^{\\text{uncorr}}$)**\n在非相关情况下，我们假设 $\\sigma_\\gamma$ 的值是独立于 $\\sigma_t$ 的值选择的。这意味着观察到特定配对 $(\\sigma_{t,j}, \\sigma_{\\gamma,k})$ 的联合概率是它们边际概率的乘积，即 $p(\\sigma_{t,j}) p(\\sigma_{\\gamma,k})$。在我们的模型中，$\\sigma_{t,j}$ 的边际概率是 $p_j$，$\\sigma_{\\gamma,k}$ 的边际概率是 $p_k$。有效截面的求和现在必须遍及所有 $2 \\times 2 = 4$ 个独立配对：\n$$ \\sigma_{\\gamma,\\text{eff}}^{\\text{uncorr}} = \\frac{\\sum_{j=1}^2 \\sum_{k=1}^2 p_j p_k \\frac{\\sigma_{\\gamma,k}}{\\sigma_{t,j} + \\sigma_0}}{\\sum_{j=1}^2 \\sum_{k=1}^2 p_j p_k \\frac{1}{\\sigma_{t,j} + \\sigma_0}} $$\n由于对 $j$ 和 $k$ 的求和是独立的，分子和分母可以被因式分解：\n$$ \\sigma_{\\gamma,\\text{eff}}^{\\text{uncorr}} = \\frac{\\left( \\sum_{k=1}^2 p_k \\sigma_{\\gamma,k} \\right) \\left( \\sum_{j=1}^2 p_j \\frac{1}{\\sigma_{t,j} + \\sigma_0} \\right)}{\\left( \\sum_{k=1}^2 p_k \\right) \\left( \\sum_{j=1}^2 p_j \\frac{1}{\\sigma_{t,j} + \\sigma_0} \\right)} $$\n由于 $\\sum_k p_k = p_1 + p_2 = 1$，表达式显著简化：\n$$ \\sigma_{\\gamma,\\text{eff}}^{\\text{uncorr}} = \\sum_{k=1}^2 p_k \\sigma_{\\gamma,k} = \\langle \\sigma_\\gamma \\rangle $$\n这表明，忽略相关性将有效俘获截面简化为其简单的概率加权平均值，而与自屏效应无关。对于给定的数据：\n$$ \\sigma_{\\gamma,\\text{eff}}^{\\text{uncorr}} = p_1 \\sigma_{\\gamma,1} + p_2 \\sigma_{\\gamma,2} = (0.9)(0.2) + (0.1)(1.0) = 0.18 + 0.1 = 0.28 \\text{ 靶恩} $$\n对于所有 $\\sigma_0$ 值，这个值是恒定的。\n\n**分数偏差计算**\n分数偏差定义为 $b = (\\sigma_{\\gamma,\\text{eff}}^{\\text{uncorr}} - \\sigma_{\\gamma,\\text{eff}}^{\\text{corr}}) / \\sigma_{\\gamma,\\text{eff}}^{\\text{corr}}$。我们现在为每个给定的 $\\sigma_0$ 值计算 $\\sigma_{\\gamma,\\text{eff}}^{\\text{corr}}$ 和 $b$。\n\n对于 $\\sigma_0 = 0$ 靶恩：\n分子, $N = \\frac{(0.9)(0.2)}{5+0} + \\frac{(0.1)(1.0)}{100+0} = 0.036 + 0.001 = 0.037$\n分母, $D = \\frac{0.9}{5+0} + \\frac{0.1}{100+0} = 0.18 + 0.001 = 0.181$\n$\\sigma_{\\gamma,\\text{eff}}^{\\text{corr}} = N/D = 0.037 / 0.181 \\approx 0.20442$ 靶恩\n$b = (0.28 - 0.20442) / 0.20442 \\approx 0.36972$\n\n对于 $\\sigma_0 = 0.01$ 靶恩：\n$N = \\frac{0.18}{5.01} + \\frac{0.1}{100.01} \\approx 0.0359281 + 0.0009999 = 0.0369280$\n$D = \\frac{0.9}{5.01} + \\frac{0.1}{100.01} \\approx 0.1796407 + 0.0009999 = 0.1806406$\n$\\sigma_{\\gamma,\\text{eff}}^{\\text{corr}} = N/D \\approx 0.204427$ 靶恩\n$b = (0.28 - 0.204427) / 0.204427 \\approx 0.36968$\n\n对于 $\\sigma_0 = 5$ 靶恩：\n$N = \\frac{0.18}{5+5} + \\frac{0.1}{100+5} = \\frac{0.18}{10} + \\frac{0.1}{105} = 0.018 + 0.00095238 \\approx 0.01895238$\n$D = \\frac{0.9}{10} + \\frac{0.1}{105} = 0.09 + 0.00095238 \\approx 0.09095238$\n$\\sigma_{\\gamma,\\text{eff}}^{\\text{corr}} = N/D \\approx 0.208376$ 靶恩\n$b = (0.28 - 0.208376) / 0.208376 \\approx 0.34373$\n\n对于 $\\sigma_0 = 100$ 靶恩：\n$N = \\frac{0.18}{5+100} + \\frac{0.1}{100+100} = \\frac{0.18}{105} + \\frac{0.1}{200} \\approx 0.00171429 + 0.0005 = 0.00221429$\n$D = \\frac{0.9}{105} + \\frac{0.1}{200} \\approx 0.00857143 + 0.0005 = 0.00907143$\n$\\sigma_{\\gamma,\\text{eff}}^{\\text{corr}} = N/D \\approx 0.244094$ 靶恩\n$b = (0.28 - 0.244094) / 0.244094 \\approx 0.14710$\n\n对于 $\\sigma_0 = 10^6$ 靶恩：\n在 $\\sigma_0 \\to \\infty$ 的极限下，所有状态 $i$ 的通量加权因子 $1/(\\sigma_{t,i} + \\sigma_0)$ 都变得相等。$\\sigma_{\\gamma,\\text{eff}}^{\\text{corr}}$ 表达式的分母变为 $\\frac{1}{\\sigma_0} (p_1+p_2)$，分子变为 $\\frac{1}{\\sigma_0} (p_1 \\sigma_{\\gamma,1}+p_2 \\sigma_{\\gamma,2})$。因此，$\\sigma_{\\gamma,\\text{eff}}^{\\text{corr}} \\to \\langle \\sigma_\\gamma \\rangle = \\sigma_{\\gamma,\\text{eff}}^{\\text{uncorr}}$，偏差 $b \\to 0$。\n$N = \\frac{0.18}{1000005} + \\frac{0.1}{1000100} \\approx 1.79991 \\times 10^{-7} + 9.9990 \\times 10^{-8} \\approx 2.79981 \\times 10^{-7}$\n$D = \\frac{0.9}{1000005} + \\frac{0.1}{1000100} \\approx 8.99955 \\times 10^{-7} + 9.9990 \\times 10^{-8} \\approx 9.99945 \\times 10^{-7}$\n$\\sigma_{\\gamma,\\text{eff}}^{\\text{corr}} = N/D \\approx 0.279994$ 靶恩\n$b = (0.28 - 0.279994) / 0.279994 \\approx 0.0000214$\n\n物理上的解释是，对于低 $\\sigma_0$（强自屏），通量在高截面共振态（状态 2）中受到严重压低。由于俘获截面在此状态下也最高，正确的相关计算恰当地考虑了这种通量压低效应，从而得出了较低的有效俘获率。非相关模型未能做到这一点，它将状态 2 的高俘获截面与一个压低程度较小的通量进行平均，导致显著的过高预测（大的正偏差）。随着 $\\sigma_0$ 的增加，外部本底截面在总截面中占主导地位，通量变得更平坦（$\\phi(E) \\approx \\text{const.}$），自屏效应减弱，两种模型都收敛到相同的结果，导致偏差趋近于零。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Constructs a two-state probability table for an unresolved resonance region,\n    derives and calculates effective capture cross sections with and without\n    correlation, and computes the fractional bias for several background\n    cross sections.\n    \"\"\"\n\n    # Define the probability table for a single energy group.\n    # State 1 (\"background\")\n    p1 = 0.9\n    sigma_t1 = 5.0  # barns\n    sigma_g1 = 0.2  # barns\n\n    # State 2 (\"resonance\")\n    p2 = 0.1\n    sigma_t2 = 100.0 # barns\n    sigma_g2 = 1.0   # barns\n\n    # Background cross sections to test (in barns)\n    sigma_0_values = [0.0, 0.01, 5.0, 100.0, 1e6]\n\n    results = []\n\n    # Calculate the uncorrelated effective capture cross section.\n    # This is the simple probability-weighted average, constant for all sigma_0.\n    sigma_g_uncorr = p1 * sigma_g1 + p2 * sigma_g2\n\n    for sigma_0 in sigma_0_values:\n        # Calculate the correlated effective capture cross section.\n        # Numerator: sum(p_i * sigma_g_i / (sigma_t_i + sigma_0))\n        num_corr = (p1 * sigma_g1 / (sigma_t1 + sigma_0)) + \\\n                   (p2 * sigma_g2 / (sigma_t2 + sigma_0))\n        \n        # Denominator: sum(p_i / (sigma_t_i + sigma_0))\n        den_corr = (p1 / (sigma_t1 + sigma_0)) + \\\n                   (p2 / (sigma_t2 + sigma_0))\n        \n        if den_corr == 0:\n            # Should not happen with positive cross sections\n            sigma_g_corr = sigma_g_uncorr\n        else:\n            sigma_g_corr = num_corr / den_corr\n\n        # Calculate fractional bias b = (uncorr - corr) / corr\n        if sigma_g_corr == 0:\n             # Avoid division by zero, bias is undefined or infinite.\n             # Based on problem, this case is not expected.\n             bias = float('inf')\n        else:\n            bias = (sigma_g_uncorr - sigma_g_corr) / sigma_g_corr\n        \n        results.append(bias)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "最后的实践将我们从物理模型带入到实际的数值计算挑战中。在程序实现中，概率表通常仅在离散的能量点上给出，因此必须进行插值； 本练习旨在比较两种不同的插值方案，并分析它们在强自屏和弱自屏条件下对最终群平均截面计算精度的影响，这对于保证计算代码的准确性至关重要。",
            "id": "4242816",
            "problem": "给定一个简化的、但物理上一致的模型问题，用于量化和比较在核反应堆模拟的非弹性共振区（URR）中，应用于概率表的两种插值方案的效果。目标是计算群平均俘获截面，并评估不同插值策略对结果的影响。\n\n基本原理。使用以下与URR相关的基础性假设和经过充分检验的近似：\n- 窄共振自屏敝近似：在每个概率表栅元内，标量中子通量与总截面和一个能谱无关的本底（或稀释）截面之和成反比。具体来说，对于栅元索引 $j$，通量权重意味着 $\\phi_j \\propto 1/(\\sigma_{t,j} + \\sigma_0)$，其中 $\\sigma_{t,j}$ 是栅元 $j$ 中的总截面，$\\sigma_0$ 是本底截面。\n- 在给定能量下的有效俘获截面是使用上述通量权重对概率表栅元进行平均得到的俘获截面。\n- 在一个能量区间上的群平均截面是使用预设的能谱形状 $w(E)$ 对能量进行的通量加权平均。\n\n设置。考虑一个由 $E_1 = 20\\,\\text{keV}$ 和 $E_2 = 40\\,\\text{keV}$ 界定的单个能群。对于两个列表给出的能量点 $E_1$ 和 $E_2$，给定含有 $N = 5$ 个等概率栅元的概率表，其概率为 $w_j = 0.2$，$j \\in \\{1,2,3,4,5\\}$。每个栅元包含一个总截面和一个俘获截面，单位均为靶（barns）。数据如下：\n- 在 $E_1$ 处：$\\sigma_{t}^{(1)} = [8.0, 12.0, 20.0, 60.0, 150.0]$ 和 $\\sigma_{c}^{(1)} = [0.2, 0.5, 1.5, 6.0, 20.0]$。\n- 在 $E_2$ 处：$\\sigma_{t}^{(2)} = [6.0, 9.0, 15.0, 40.0, 100.0]$ 和 $\\sigma_{c}^{(2)} = [0.15, 0.35, 1.0, 4.0, 13.0]$。\n\n定义两种插值方案来计算群内的有效俘获截面：\n1. 能量线性后平均插值（方法A）。使用概率表和本底截面 $\\sigma_0$ 计算在 $E_1$ 和 $E_2$ 处的自屏敝有效俘获截面。然后，对于任意 $E \\in [E_1,E_2]$，在能量上对这些有效俘获截面进行线性插值：$\\sigma_{c,\\mathrm{eff}}^{A}(E)$ 定义为一个连接端点有效值的关于 $E$ 的线性函数。\n2. 概率空间预平均插值（方法B）。对于每个栅元 $j$，在目标能量 $E$ 处，对 $E_1$ 和 $E_2$ 之间的栅元总截面和俘获截面进行线性插值。然后使用相同的自屏敝通量权重和 $\\sigma_0$ 计算有效俘获截面 $\\sigma_{c,\\mathrm{eff}}^{B}(E)$。\n\n对于群平均，使用形状函数 $w(E) = E^{-s}$（其中 $s \\ge 0$），并按如下方式计算群平均俘获截面\n$$\n\\langle \\sigma_c \\rangle = \\frac{\\int_{E_1}^{E_2} \\sigma_{c,\\mathrm{eff}}(E)\\, w(E)\\, dE}{\\int_{E_1}^{E_2} w(E)\\, dE}.\n$$\n\n任务。对于下面的每个测试案例，执行以下操作：\n- 使用方法A计算群平均俘获截面（单位为靶），记为 $\\langle \\sigma_c \\rangle_A$。\n- 使用方法B计算群平均俘获截面（单位为靶），记为 $\\langle \\sigma_c \\rangle_B$。\n- 计算相对差异（一个无量纲小数），定义为\n$$\n\\delta = \\frac{|\\langle \\sigma_c \\rangle_B - \\langle \\sigma_c \\rangle_A|}{\\langle \\sigma_c \\rangle_B}.\n$$\n- 使用标准 $\\delta \\le \\tau$（容差 $\\tau = 0.005$）来判断较简单的方法A是否可接受。\n\n所有能量积分必须以高精度进行数值计算。您必须使用具有足够点数的确定性求积法以确保数值稳定性。本底截面 $\\sigma_0$ 的单位是靶。能量权重 $w(E)$ 使用的 $E$ 的单位是 $\\text{keV}$，最终的群平均俘获截面必须以靶为单位表示。相对差异 $\\delta$ 必须表示为小数（而非百分比）。将报告的群平均俘获截面四舍五入到6位小数，相对差异四舍五入到6位小数。\n\n测试套件。使用以下5个测试案例，每个案例由 $(\\sigma_0, s)$ 指定：\n- 案例 1：$(10000.0, 1.0)$。\n- 案例 2：$(10.0, 1.0)$。\n- 案例 3：$(0.1, 1.0)$。\n- 案例 4：$(10.0, 0.0)$。\n- 案例 5：$(10.0, 2.0)$。\n\n输出规格。您的程序应生成单行输出，其中包含所有测试案例的结果，格式为一个用方括号括起来的逗号分隔列表。每个测试案例的结果必须是一个包含四个元素的列表，形式为 $[\\langle \\sigma_c \\rangle_A,\\langle \\sigma_c \\rangle_B,\\delta,\\mathrm{flag}]$，其中如果 $\\delta \\le \\tau$，则 $\\mathrm{flag}$ 为整数 $1$，否则为 $0$。例如，总输出格式必须为\n$[[x_1,y_1,d_1,f_1],[x_2,y_2,d_2,f_2],\\dots]$\n其中所有的 $x_i$ 和 $y_i$ 以靶为单位，四舍五入到6位小数，所有的 $d_i$ 四舍五入到6位小数，每个 $f_i$ 为一个整数。",
            "solution": "我们从使用概率表在非弹性共振区（URR）中自屏敝的基本定义开始。对于单个能量 $E$ 和本底截面 $\\sigma_0$，窄共振近似指出，栅元 $j$ 中的标量通量与 $\\phi_j(E) \\propto 1/(\\sigma_{t,j}(E) + \\sigma_0)$ 成比例，其中 $\\sigma_{t,j}(E)$ 是该栅元的总截面。给定一组栅元概率 $\\{w_j\\}_{j=1}^N$ 且 $\\sum_j w_j = 1$，有效俘获截面通过对栅元的通量加权平均来定义：\n$$\n\\sigma_{c,\\mathrm{eff}}(E;\\sigma_0) = \\frac{\\sum_{j=1}^N w_j \\, \\sigma_{c,j}(E)\\, \\frac{1}{\\sigma_{t,j}(E) + \\sigma_0}}{\\sum_{j=1}^N w_j \\, \\frac{1}{\\sigma_{t,j}(E) + \\sigma_0}}.\n$$\n该表达式源于反应率密度 $R_{c,j} \\propto \\sigma_{c,j}\\phi_j$ 的标准关系，并与稳态下的反应率平均保持一致。\n\n为了获得能量上的群平均俘获截面，我们采用能谱权重 $w(E) = E^{-s}$（其中 $s \\ge 0$），并计算\n$$\n\\langle \\sigma_c \\rangle = \\frac{\\int_{E_1}^{E_2} \\sigma_{c,\\mathrm{eff}}(E;\\sigma_0)\\, E^{-s}\\, dE}{\\int_{E_1}^{E_2} E^{-s}\\, dE}.\n$$\n分母提供了适当的归一化，并因 $\\sigma_{c,\\mathrm{eff}}(E;\\sigma_0)$ 的存在而分离出分子中的物理效应。\n\n我们比较 $E_1$ 和 $E_2$ 之间的两种插值策略：\n\n- 方法A（能量线性后平均）。首先计算端点值：\n$$\n\\sigma_{c,\\mathrm{eff}}^{(1)} = \\sigma_{c,\\mathrm{eff}}(E_1;\\sigma_0), \\quad\n\\sigma_{c,\\mathrm{eff}}^{(2)} = \\sigma_{c,\\mathrm{eff}}(E_2;\\sigma_0).\n$$\n定义线性能量插值因子\n$$\n\\alpha(E) = \\frac{E_2 - E}{E_2 - E_1}.\n$$\n然后对于任意 $E \\in [E_1,E_2]$，定义\n$$\n\\sigma_{c,\\mathrm{eff}}^{A}(E) = \\alpha(E)\\, \\sigma_{c,\\mathrm{eff}}^{(1)} + \\left(1 - \\alpha(E)\\right)\\, \\sigma_{c,\\mathrm{eff}}^{(2)}.\n$$\n最后计算群平均值\n$$\n\\langle \\sigma_c \\rangle_A = \\frac{\\int_{E_1}^{E_2} \\sigma_{c,\\mathrm{eff}}^{A}(E)\\, E^{-s}\\, dE}{\\int_{E_1}^{E_2} E^{-s}\\, dE}.\n$$\n\n- 方法B（概率空间预平均）。对于每个栅元 $j$，对各栅元的截面进行线性插值：\n$$\n\\sigma_{t,j}(E) = \\alpha(E)\\, \\sigma_{t,j}^{(1)} + \\left(1-\\alpha(E)\\right)\\, \\sigma_{t,j}^{(2)}, \\quad\n\\sigma_{c,j}(E) = \\alpha(E)\\, \\sigma_{c,j}^{(1)} + \\left(1-\\alpha(E)\\right)\\, \\sigma_{c,j}^{(2)}.\n$$\n在自屏敝表达式中使用这些值以获得 $\\sigma_{c,\\mathrm{eff}}^{B}(E) = \\sigma_{c,\\mathrm{eff}}(E;\\sigma_0)$，然后计算\n$$\n\\langle \\sigma_c \\rangle_B = \\frac{\\int_{E_1}^{E_2} \\sigma_{c,\\mathrm{eff}}^{B}(E)\\, E^{-s}\\, dE}{\\int_{E_1}^{E_2} E^{-s}\\, dE}.\n$$\n\n插值选择的影响由相对差异量化\n$$\n\\delta = \\frac{\\left|\\langle \\sigma_c \\rangle_B - \\langle \\sigma_c \\rangle_A\\right|}{\\langle \\sigma_c \\rangle_B}.\n$$\n当 $\\delta \\le \\tau$（容差 $\\tau = 0.005$）时，我们接受方法A，否则需要使用方法B。\n\n算法设计。我们实现以下步骤：\n- 用数组 $\\{\\sigma_{t,j}^{(1)}\\}_{j=1}^N$、$\\{\\sigma_{c,j}^{(1)}\\}_{j=1}^N$、$\\{\\sigma_{t,j}^{(2)}\\}_{j=1}^N$、$\\{\\sigma_{c,j}^{(2)}\\}_{j=1}^N$ 和权重 $w_j = 1/N$ 来表示在 $E_1$ 和 $E_2$ 处的概率表。\n- 提供一个函数，根据上述通量加权有理表达式，从各栅元的截面和 $\\sigma_0$ 计算 $\\sigma_{c,\\mathrm{eff}}(E;\\sigma_0)$。这是窄共振近似的核心实现。\n- 对于方法A，一次性计算出 $\\sigma_{c,\\mathrm{eff}}^{(1)}$ 和 $\\sigma_{c,\\mathrm{eff}}^{(2)}$，然后使用 $\\alpha(E)$ 将 $\\sigma_{c,\\mathrm{eff}}^{A}(E)$ 定义为关于 $E$ 的线性函数。\n- 对于方法B，在每个求积横坐标 $E$ 处，计算经过栅元插值的 $\\sigma_{t,j}(E)$ 和 $\\sigma_{c,j}(E)$，然后直接从相同的通量加权公式计算 $\\sigma_{c,\\mathrm{eff}}^{B}(E)$。\n- 使用在 $[E_1,E_2]$ 上的高阶高斯求积法执行能量积分。设 $\\{x_q, w_q\\}_{q=1}^Q$ 为映射到 $[E_1,E_2]$ 上的横坐标和权重，则近似为\n$$\n\\int_{E_1}^{E_2} f(E)\\, dE \\approx \\sum_{q=1}^Q f(x_q)\\, w_q.\n$$\n我们使用足够大的 $Q$ 以确保在所有测试案例中的稳定性。\n- 对于每个测试案例 $(\\sigma_0, s)$，评估 $\\langle \\sigma_c \\rangle_A$ 和 $\\langle \\sigma_c \\rangle_B$，计算 $\\delta$，并判断方法A的可接受性。\n- 将 $\\langle \\sigma_c \\rangle_A$ 和 $\\langle \\sigma_c \\rangle_B$ 四舍五入到6位小数（单位为靶），并将 $\\delta$ 四舍五入到6位小数。如果 $\\delta \\le 0.005$，可接受性标志为整数 $1$，否则为 $0$。\n\n每种方法为何以及何时可接受。如果本底截面 $\\sigma_0 \\to \\infty$（无限稀释），那么通量权重将变得与栅元无关，因为\n$$\n\\frac{1}{\\sigma_{t,j}(E) + \\sigma_0} \\approx \\frac{1}{\\sigma_0} \\quad \\text{for all } j,\n$$\n有效俘获截面简化为 $\\sigma_{c,j}(E)$ 的概率加权算术平均值。在该极限下，线性性质确保了两种插值顺序是等价的，从而得出 $\\delta \\to 0$。更一般地，当群内的 $\\sigma_{t,j}(E)$ 和 $\\sigma_{c,j}(E)$ 随 $E$ 近似线性变化，且自屏敝畸变较弱（中等至较大的 $\\sigma_0$）时，$\\sigma_{c,\\mathrm{eff}}(E;\\sigma_0)$ 近似于 $E$ 的线性函数，此时方法A是可接受的。相反，对于较小的 $\\sigma_0$（强自屏敝），通量权重对 $\\sigma_{t,j}(E)$ 的非线性依赖性导致 $\\sigma_{c,\\mathrm{eff}}(E;\\sigma_0)$ 成为 $E$ 的非线性函数。在这种情况下，在概率空间中进行预平均（方法B）保留了栅元分辨的非线性，并产生更准确的群平均值，而方法A的偏差可能会超出容差。\n\n该程序实现了这些原理，评估了指定的测试套件，并打印出所需的列表\n$$\n\\big[\\,[\\langle \\sigma_c \\rangle_A,\\langle \\sigma_c \\rangle_B,\\delta,\\mathrm{flag}],\\dots\\big]\n$$\n截面值采用要求的四舍五入规则和单位（靶）。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom numpy.polynomial.legendre import leggauss\n\ndef compute_sigma_c_eff(sig_t, sig_c, probs, sigma0):\n    \"\"\"\n    Compute effective capture cross section with narrow resonance self-shielding:\n    sigma_c_eff = sum_j w_j * sigma_c_j / (sigma_t_j + sigma0) / sum_j w_j / (sigma_t_j + sigma0)\n    All inputs are 1D numpy arrays.\n    \"\"\"\n    inv_denom = 1.0 / (sig_t + sigma0)\n    num = np.sum(probs * sig_c * inv_denom)\n    den = np.sum(probs * inv_denom)\n    return num / den\n\ndef group_average_sigma(method, E1, E2, s, sigma0, probs, sig_t1, sig_c1, sig_t2, sig_c2, quad_n=200):\n    \"\"\"\n    Compute group-averaged capture cross section for a given method over [E1,E2] with weight w(E)=E^{-s}.\n    method: 'A' or 'B'\n    \"\"\"\n    # Quadrature setup on [E1,E2]\n    # Use Gauss-Legendre nodes on [-1,1] mapped to [E1,E2]\n    xi, wi = leggauss(quad_n)\n    # Map to [E1, E2]\n    Emid = 0.5 * (E1 + E2)\n    Ehalf = 0.5 * (E2 - E1)\n    Es = Emid + Ehalf * xi  # energies\n    dE = Ehalf * wi         # differential weights\n\n    # Precompute endpoint effective values for method A\n    if method == 'A':\n        eff1 = compute_sigma_c_eff(sig_t1, sig_c1, probs, sigma0)\n        eff2 = compute_sigma_c_eff(sig_t2, sig_c2, probs, sigma0)\n\n    num = 0.0\n    den = 0.0\n    for E, wE in zip(Es, dE):\n        weight_E = (E ** (-s))  # spectral weight\n        if method == 'A':\n            alpha = (E2 - E) / (E2 - E1)\n            sigma_eff = alpha * eff1 + (1.0 - alpha) * eff2\n        elif method == 'B':\n            alpha = (E2 - E) / (E2 - E1)\n            sig_tE = alpha * sig_t1 + (1.0 - alpha) * sig_t2\n            sig_cE = alpha * sig_c1 + (1.0 - alpha) * sig_c2\n            sigma_eff = compute_sigma_c_eff(sig_tE, sig_cE, probs, sigma0)\n        else:\n            raise ValueError(\"Unknown method\")\n        num += sigma_eff * weight_E * wE\n        den += weight_E * wE\n\n    return num / den\n\ndef solve():\n    # Energy bounds in keV\n    E1 = 20.0\n    E2 = 40.0\n\n    # Probability table with N=5 equiprobable bins\n    probs = np.array([0.2, 0.2, 0.2, 0.2, 0.2], dtype=float)\n\n    # Cross sections at E1 (barns)\n    sig_t1 = np.array([8.0, 12.0, 20.0, 60.0, 150.0], dtype=float)\n    sig_c1 = np.array([0.2, 0.5, 1.5, 6.0, 20.0], dtype=float)\n\n    # Cross sections at E2 (barns)\n    sig_t2 = np.array([6.0, 9.0, 15.0, 40.0, 100.0], dtype=float)\n    sig_c2 = np.array([0.15, 0.35, 1.0, 4.0, 13.0], dtype=float)\n\n    # Test suite: (sigma0, s)\n    test_cases = [\n        (10000.0, 1.0),\n        (10.0, 1.0),\n        (0.1, 1.0),\n        (10.0, 0.0),\n        (10.0, 2.0),\n    ]\n\n    tau = 0.005  # tolerance for acceptability\n\n    results_str = []\n    for sigma0, s in test_cases:\n        # Group averages for both methods\n        gA = group_average_sigma('A', E1, E2, s, sigma0, probs, sig_t1, sig_c1, sig_t2, sig_c2, quad_n=200)\n        gB = group_average_sigma('B', E1, E2, s, sigma0, probs, sig_t1, sig_c1, sig_t2, sig_c2, quad_n=200)\n        # Relative difference\n        rel = abs(gB - gA) / gB if gB != 0.0 else 0.0\n        flag = 1 if rel = tau else 0\n        # Format with required rounding\n        results_str.append(f\"[{gA:.6f},{gB:.6f},{rel:.6f},{flag}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results_str)}]\")\n\nsolve()\n```"
        }
    ]
}