{
    "hands_on_practices": [
        {
            "introduction": "在反应堆模拟中，通常会使用在离散温度点上预先计算好的截面数据库。本实践旨在探究当所需温度位于数据库温度点之间时，使用简单的线性插值是否足够准确。通过直接计算多普勒展宽截面，并将其与插值结果进行比较，我们可以量化这种近似带来的误差，从而理解为何需要更精确的在线（On-the-fly）计算方法 。",
            "id": "4239879",
            "problem": "核反应堆模拟必须在列表化数据库中不存在请求的温度时，实时计算中子截面的温度展宽。考虑一个在零温度下由单能级布莱特-维格纳（SLBW）形式描述的单个分离共振。目标是在请求的温度下计算多普勒展宽截面，并将其与两个列表化温度之间的朴素线性插值进行比较。制定并实施一个程序，对于给定测试套件中的每种情况，使用自由气体多普勒核计算共振能量处的展宽截面，并量化与线性插值的偏差。\n\n起点和定义：\n- SLBW 零温度共振截面被建模为洛伦兹函数\n$$\n\\sigma_0(E) = \\sigma_\\text{peak} \\frac{(\\Gamma/2)^2}{(E - E_r)^2 + (\\Gamma/2)^2},\n$$\n其中 $E$ 是能量，单位为电子伏特（eV），$E_r$ 是共振能量，单位为 eV，$\\Gamma$ 是总宽度，单位为 eV，$\\sigma_\\text{peak}$ 是在 $E = E_r$ 处的峰值截面，单位为靶恩（barns）。\n- 靶核的热运动被假定遵循麦克斯韦-玻尔兹曼分布，导致多普勒展宽，表现为能量平方根（也称为 $u$-）空间中的高斯卷积。定义 $u = \\sqrt{E}$，以及自由气体多普勒核\n$$\nG(u,u';T,A) = \\frac{1}{\\sqrt{\\pi}\\,\\mu(T,A)} \\exp\\!\\left(-\\frac{(u'-u)^2}{\\mu(T,A)^2}\\right),\n$$\n其中 $u$-空间中的核宽度参数为\n$$\n\\mu(T,A) = \\sqrt{\\frac{\\theta(T)}{A}},\n\\quad\n\\theta(T) = k_B T \\text{ in eV},\n$$\n$k_B$ 是玻尔兹曼常数，$A$ 是靶核与中子的质量比（无量纲）。温度 $T$ 下的展宽截面则为\n$$\n\\sigma(E,T) = \\int_0^\\infty \\sigma_0(u'^2)\\, G(u,u';T,A)\\, \\mathrm{d}u'.\n$$\n- 考虑的温度为 $T_1 = 800$ 开尔文（K）、$T = 873$ K 和 $T_2 = 900$ K。玻尔兹曼常数必须使用电子伏特每开尔文为单位，即 $k_B = 8.617333262145\\times 10^{-5}$ eV/K。\n- 对于每个测试用例，截面的评估能量为 $E = E_r$。\n\n需要实现的任务：\n1. 使用上述基本原理，通过实时多普勒展宽（即 $u$-空间中的高斯卷积）计算 $\\sigma(E_r, T)$。\n2. 类似地计算 $\\sigma(E_r, T_1)$ 和 $\\sigma(E_r, T_2)$。\n3. 计算在两个列表化温度之间对 $T$ 进行线性插值的值：\n$$\n\\sigma_\\text{lin}(E_r, T) = \\sigma(E_r, T_1) + \\frac{T - T_1}{T_2 - T_1}\\left[\\sigma(E_r, T_2) - \\sigma(E_r, T_1)\\right].\n$$\n4. 使用以下公式量化在 $E = E_r$ 处实时展宽值与线性插值之间的差异：\n   - 绝对差异，单位为靶恩，\n   $$\n   \\Delta_\\text{abs} = \\sigma(E_r, T) - \\sigma_\\text{lin}(E_r, T),\n   $$\n   - 相对差异，以小数表示，\n   $$\n   \\Delta_\\text{frac} = \\frac{\\Delta_\\text{abs}}{\\sigma(E_r, T)}.\n   $$\n\n物理单位和数值报告：\n- 能量 $E$、$E_r$ 和宽度 $\\Gamma$ 的单位是电子伏特（eV）。\n- 温度 $T$ 的单位是开尔文（K）。\n- 截面和差异 $\\Delta_\\text{abs}$ 的单位是靶恩。\n- 相对差异 $\\Delta_\\text{frac}$ 必须以小数形式报告（不带百分号）。\n- 所有浮点输出均需四舍五入至六位小数。\n\n测试套件：\n对于每组参数，使用指定的 $A$、$\\Gamma$ 和 $\\sigma_\\text{peak}$ 在 $E = E_r$ 处进行评估：\n- 情况 1（重核素，窄共振，高峰值）：$A = 238$，$E_r = 6.670$ eV，$\\Gamma = 0.030$ eV，$\\sigma_\\text{peak} = 3000.0$ 靶恩。\n- 情况 2（中等质量，中等宽度）：$A = 56$，$E_r = 2.000$ eV，$\\Gamma = 0.300$ eV，$\\sigma_\\text{peak} = 100.0$ 靶恩。\n- 情况 3（轻核素，宽共振）：$A = 1$，$E_r = 1.000$ eV，$\\Gamma = 0.500$ eV，$\\sigma_\\text{peak} = 20.0$ 靶恩。\n- 情况 4（重核素，极窄共振，极高峰值）：$A = 238$，$E_r = 0.500$ eV，$\\Gamma = 0.001$ eV，$\\sigma_\\text{peak} = 10000.0$ 靶恩。\n\n算法要求：\n- 在 $u$-空间中实现高斯卷积积分，其中 $u = \\sqrt{E}$ 且 $\\mu(T,A) = \\sqrt{\\theta(T)/A}$，$\\theta(T) = k_B T$（以eV为单位）。积分区间为 $u' \\in [0,\\infty)$；为了数值稳定性和效率，可将积分区间截断为 $u' \\in [\\max(0,u-8\\mu), u+8\\mu]$，因为超出 $\\pm 8\\mu$ 的高斯尾部可以忽略不计。\n- 使用适合光滑高斯加权洛伦兹函数的稳健数值积分方法。\n\n最终输出格式：\n- 您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表。每个测试用例贡献一个二元列表 $[\\Delta_\\text{abs}, \\Delta_\\text{frac}]$，顺序如此。例如，\n$[[\\Delta_\\text{abs,1},\\Delta_\\text{frac,1}],[\\Delta_\\text{abs,2},\\Delta_\\text{frac,2}],\\dots]$。",
            "solution": "该问题要求计算单个共振的多普勒展宽中子截面，并与线性温度插值进行比较。该过程基于核反应堆物理的既定原理。\n\n计算的基础是孤立共振在绝对零度（$T=0$ K）下的单能级布莱特-维格纳（SLBW）公式，由洛伦兹函数给出：\n$$\n\\sigma_0(E) = \\sigma_\\text{peak} \\frac{(\\Gamma/2)^2}{(E - E_r)^2 + (\\Gamma/2)^2}\n$$\n这里，$E$ 是中子能量，$E_r$ 是共振中心能量，$\\Gamma$ 是总共振宽度，$\\sigma_\\text{peak}$ 是在 $E = E_r$ 处出现的最大截面值。所有能量单位均为电子伏特（eV），截面单位为靶恩。\n\n在有限温度下，靶核处于热运动状态。在自由气体模型中，这种运动由速度的麦克斯韦-玻尔兹曼分布描述。对观测截面的影响是一种展宽现象，数学上表示为零温截面与多普勒核的卷积。这种卷积最方便地在能量平方根空间（或称 $u$-空间）中表示，其中 $u = \\sqrt{E}$。在温度 $T$ 下的展宽截面 $\\sigma(E,T)$ 由下式给出：\n$$\n\\sigma(E,T) = \\int_0^\\infty \\sigma_0(u'^2)\\, G(u,u';T,A)\\, \\mathrm{d}u'\n$$\n函数 $G(u,u';T,A)$ 是自由气体多普勒核，它在 $u$-空间中是一个高斯函数：\n$$\nG(u,u';T,A) = \\frac{1}{\\sqrt{\\pi}\\,\\mu(T,A)} \\exp\\!\\left(-\\frac{(u'-u)^2}{\\mu(T,A)^2}\\right)\n$$\n高斯核的宽度参数 $\\mu(T,A)$ 包含了热运动的物理学：\n$$\n\\mu(T,A) = \\sqrt{\\frac{\\theta(T)}{A}}\n$$\n其中 $\\theta(T) = k_B T$ 是热能，单位为 eV，$k_B$ 是玻尔兹曼常数（$8.617333262145\\times 10^{-5}$ eV/K），$A$ 是靶核质量与中子质量之比。核中的变量 $u$ 对应于评估能量 $E$（即 $u=\\sqrt{E}$），而 $u'$ 是积分变量，代表进行卷积的整个能量谱。\n\n问题要求在共振能量处进行评估，即 $E = E_r$。因此，我们设置 $u = u_r = \\sqrt{E_r}$。对于给定的温度 $T$，需要计算的积分为：\n$$\n\\sigma(E_r,T) = \\int_0^\\infty \\sigma_0(u'^2)\\, G(u_r,u';T,A)\\, \\mathrm{d}u'\n$$\n代入 $\\sigma_0$ 和 $G$ 的表达式，被积函数变为：\n$$\n\\text{Integrand}(u') = \\left( \\sigma_\\text{peak} \\frac{(\\Gamma/2)^2}{(u'^2 - E_r)^2 + (\\Gamma/2)^2} \\right) \\left( \\frac{1}{\\sqrt{\\pi}\\,\\mu(T,A)} \\exp\\!\\left(-\\frac{(u'-u_r)^2}{\\mu(T,A)^2}\\right) \\right)\n$$\n这个定积分必须进行数值计算。像 Python 中 `scipy.integrate.quad` 提供的自适应求积等稳健方法适合此任务。积分在 $u'$ 从 $0$ 到 $\\infty$ 的范围内进行。为提高数值效率，问题允许将积分范围截断为 $[\\max(0, u_r - 8\\mu), u_r + 8\\mu]$，因为高斯核在此区间外的贡献可以忽略不计。\n\n对于每个测试用例，总体算法如下：\n1.  对于三个温度中的每一个，即 $T_1 = 800$ K，$T = 873$ K 和 $T_2 = 900$ K，通过数值求解上面定义的卷积积分，计算在共振峰值处的相应展宽截面 $\\sigma(E_r, T_1)$、$\\sigma(E_r, T)$ 和 $\\sigma(E_r, T_2)$。\n\n2.  使用在两侧温度点 $T_1$ 和 $T_2$ 计算的值，计算在 $T=873$ K 处的线性插值截面：\n$$\n\\sigma_\\text{lin}(E_r, T) = \\sigma(E_r, T_1) + \\frac{T - T_1}{T_2 - T_1}\\left[\\sigma(E_r, T_2) - \\sigma(E_r, T_1)\\right]\n$$\n\n3.  通过计算精确展宽值与插值之间的绝对和相对差异，来量化这种线性近似引入的误差：\n    -   绝对差异：$\\Delta_\\text{abs} = \\sigma(E_r, T) - \\sigma_\\text{lin}(E_r, T)$\n    -   相对差异：$\\Delta_\\text{frac} = \\frac{\\Delta_\\text{abs}}{\\sigma(E_r, T)}$\n\n4.  最终结果 $\\Delta_\\text{abs}$ 和 $\\Delta_\\text{frac}$ 会为每个测试用例收集起来，并以六位小数的精度报告。此分析展示了截面对温度的非线性依赖关系，以及在某些核模拟环境中使用的简单插值方案的潜在不准确性。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import integrate\n\ndef solve():\n    \"\"\"\n    Solves the Doppler broadening problem for the given test cases.\n    \"\"\"\n    \n    # Define constants and fixed temperatures\n    KB = 8.617333262145e-5  # Boltzmann constant in eV/K\n    T1 = 800.0  # K\n    T = 873.0   # K\n    T2 = 900.0  # K\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (A, Er, Gamma, sigma_peak)\n        (238.0, 6.670, 0.030, 3000.0),\n        (56.0, 2.000, 0.300, 100.0),\n        (1.0, 1.000, 0.500, 20.0),\n        (238.0, 0.500, 0.001, 10000.0),\n    ]\n\n    # List to store the results for all cases\n    all_results = []\n\n    def zero_temp_xs(u_prime_sq, Er, Gamma, sigma_peak):\n        \"\"\"\n        Calculates the zero-temperature SLBW cross section.\n        u_prime_sq is u'^2, which is the energy E.\n        \"\"\"\n        half_gamma_sq = (Gamma / 2.0)**2\n        return sigma_peak * half_gamma_sq / ((u_prime_sq - Er)**2 + half_gamma_sq)\n\n    def calculate_broadened_xs(Er, Gamma, sigma_peak, A, temp):\n        \"\"\"\n        Computes the Doppler-broadened cross section at E=Er for a given temperature.\n        \"\"\"\n        # Thermal energy theta\n        theta = KB * temp\n        \n        # Kernel width parameter mu\n        mu = np.sqrt(theta / A)\n        \n        # u-space evaluation point\n        u_r = np.sqrt(Er)\n        \n        # Define the integrand for the convolution\n        def integrand(u_prime):\n            # Gaussian kernel G(u_r, u_prime; T, A)\n            gaussian_kernel = (1.0 / (np.sqrt(np.pi) * mu)) * np.exp(-((u_prime - u_r)**2) / mu**2)\n            \n            # Zero-temperature cross section sigma_0(u_prime^2)\n            sigma_0_val = zero_temp_xs(u_prime**2, Er, Gamma, sigma_peak)\n            \n            return sigma_0_val * gaussian_kernel\n\n        # Integration limits\n        u_min = max(0.0, u_r - 8.0 * mu)\n        u_max = u_r + 8.0 * mu\n        \n        # Perform numerical integration\n        result, _ = integrate.quad(integrand, u_min, u_max, epsabs=1e-12, epsrel=1e-12)\n        \n        return result\n\n    for case in test_cases:\n        A, Er, Gamma, sigma_peak = case\n        \n        # 1. Compute on-the-fly broadened cross section at T\n        sigma_T = calculate_broadened_xs(Er, Gamma, sigma_peak, A, T)\n        \n        # 2. Compute broadened cross sections at T1 and T2\n        sigma_T1 = calculate_broadened_xs(Er, Gamma, sigma_peak, A, T1)\n        sigma_T2 = calculate_broadened_xs(Er, Gamma, sigma_peak, A, T2)\n        \n        # 3. Compute the linearly interpolated value\n        sigma_lin = sigma_T1 + (T - T1) / (T2 - T1) * (sigma_T2 - sigma_T1)\n        \n        # 4. Quantify the differences\n        delta_abs = sigma_T - sigma_lin\n        delta_frac = delta_abs / sigma_T if sigma_T != 0 else 0.0\n        \n        # Store results rounded to six decimal places\n        all_results.append(f\"[{delta_abs:.6f},{delta_frac:.6f}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在认识到在线计算的必要性之后，下一个挑战便是如何确保计算过程的数值稳定性。将洛伦兹共振峰型与高斯热运动核进行卷积（即形成福格特（Voigt）分布）在数值上很容易出错，尤其是在处理窄共振时。本实践通过对比一种朴素的数值积分方法与一种经过优化的稳定算法，揭示并解决了精度损失等问题，突显了在截面计算中采用鲁棒算法的重要性 。",
            "id": "4239886",
            "problem": "考虑一个静态各向同性介质中的单共振吸收截面，其通过洛伦兹线型与热多普勒展宽的卷积来近似。设未展宽的截面被建模为一个面积归一化的洛伦兹函数，由下式给出：$$\\ell(x;\\gamma)=\\frac{1}{\\pi}\\frac{\\gamma}{x^2+\\gamma^2},$$ 其中 $x=E-E_r$ 是能量相对于共振能量 $E_r$ 的偏移量，单位为电子伏特 (eV)，而 $\\gamma$ 是半峰半宽，单位也为电子伏特 (eV)。物理截面（单位为靶恩）为：$$\\sigma_0(E)=S_{\\text{area}}\\ \\ell(E-E_r;\\gamma),$$ 其中 $S_{\\text{area}}$ 的单位是靶恩$\\cdot$电子伏特，它缩放线型下的面积以匹配共振的物理强度。\n\n假设对于给定能量 $E$ 和温度的实时计算，多普勒展宽可以表示为与能量空间中的高斯函数的卷积，$$g(x;\\sigma)=\\frac{1}{\\sigma\\sqrt{2\\pi}}\\exp\\left(-\\frac{x^2}{2\\sigma^2}\\right),$$ 其中 $\\sigma$ 是一个热展宽参数，单位为电子伏特 (eV)。那么，在能量 $E$ 处的多普勒展宽截面就是 Voigt 卷积，$$\\sigma_D(E)=\\int_{-\\infty}^{\\infty}\\sigma_0(E')\\ g(E-E';\\sigma)\\ \\mathrm{d}E'=\\int_{-\\infty}^{\\infty}S_{\\text{area}}\\ \\ell(E'-E_r;\\gamma)\\ g(E-E';\\sigma)\\ \\mathrm{d}E'.$$\n\n当 $\\gamma$ 很小时，被积函数在 $E'\\approx E_r$ 附近出现尖峰；当 $\\sigma$ 很小时，高斯因子在 $E'\\approx E$ 附近出现尖峰。在 $E\\approx E_r$ 附近，卷积的数值积分可能会因为累加大量大贡献值之间的小差异而遭受有效数字损失，特别是在原始 $E'$ 空间中进行求和而没有进行仔细缩放时。一个数学上等效的重新参数化和缩放可以缓解这个问题。定义平移和缩放后的变量 $$y=\\frac{E'-E_r}{\\sigma},\\quad y_0=\\frac{E-E_r}{\\sigma},$$ 使得 $$g(E-E';\\sigma)=\\frac{1}{\\sqrt{2\\pi}}\\exp\\left(-\\frac{(y-y_0)^2}{2}\\right),\\quad \\ell(E'-E_r;\\gamma)=\\ell(\\sigma y;\\gamma)=\\frac{1}{\\pi}\\frac{\\gamma}{(\\sigma y)^2+\\gamma^2}.$$ 在这个 $y$ 空间中，卷积变为 $$\\sigma_D(E)=S_{\\text{area}}\\ \\sigma\\ \\int_{-\\infty}^{\\infty}\\frac{1}{\\pi}\\frac{\\gamma}{(\\sigma y)^2+\\gamma^2}\\ \\frac{1}{\\sqrt{2\\pi}}\\exp\\left(-\\frac{(y-y_0)^2}{2}\\right)\\ \\mathrm{d}y.$$ 可以通过以下方式构建一个数值稳定的累加方案：(i) 通过将指数项因式分解为 $$\\exp\\left(-\\frac{(y-y_0)^2}{2}\\right)=\\exp\\left(-\\frac{y^2}{2}\\right)\\exp\\left(-\\frac{y_0^2}{2}\\right)\\exp(y\\,y_0),$$ 来平移高斯函数以消除近对称相消，以及 (ii) 在对称的 $y$ 网格上执行补偿求和（例如 Kahan 求和），以减少在存在宽动态范围时的舍入误差。作为一个高精度参考，Voigt 线型可以通过 Faddeeva 函数获得一个精确表示，$$V(x;\\sigma,\\gamma)=\\frac{1}{\\sigma\\sqrt{2\\pi}}\\ \\Re\\left[w\\!\\left(\\frac{x+i\\gamma}{\\sigma\\sqrt{2}}\\right)\\right],$$ 其中 $w(z)$ 是缩放的复误差函数。展宽后的截面则为 $$\\sigma_D^{\\text{ref}}(E)=S_{\\text{area}}\\ V(E-E_r;\\sigma,\\gamma).$$\n\n您的任务是编写一个完整的程序，该程序：\n- 为 $\\sigma_D(E)$ 实现三种计算方案：\n  $1.$ 一种使用均匀 $E'$ 网格和简单求和的朴素 $E'$ 空间矩形积分。\n  $2.$ 一种使用变量 $y$、上述指数因式分解以及 Kahan 补偿求和的稳定 $y$ 空间积分。\n  $3.$ 一种使用基于 Faddeeva 函数的 Voigt 表示的高精度参考计算。\n- 对每个测试用例，计算朴素方案和稳定方案相对于参考方案的相对误差，定义为 $$\\varepsilon=\\left|\\frac{\\sigma_D^{\\text{approx}}(E)-\\sigma_D^{\\text{ref}}(E)}{\\sigma_D^{\\text{ref}}(E)}\\right|.$$\n- 将所有相对误差在一行中输出，形式为方括号内以逗号分隔的列表（例如 $$[\\varepsilon_1,\\varepsilon_2,\\varepsilon_3]$$）。不要打印任何额外文本。\n\n假设能量单位为电子伏特 (eV)，宽度单位为电子伏特 (eV)，截面单位为靶恩。所有相对误差均表示为无量纲浮点数。使用以下测试套件，它涵盖了一个“理想路径”情况、一个近共振边缘情况、一个远翼情况和一个窄洛伦兹线型情况：\n- 测试用例 1：$S_{\\text{area}}=100$, $E_r=6.67$, $\\gamma=0.03$, $\\sigma=0.02$, $E=6.67$。\n- 测试用例 2：$S_{\\text{area}}=100$, $E_r=6.67$, $\\gamma=0.03$, $\\sigma=0.001$, $E=6.670000001$ (即 $E=E_r+10^{-9}$)。\n- 测试用例 3：$S_{\\text{area}}=100$, $E_r=6.67$, $\\gamma=0.03$, $\\sigma=0.05$, $E=6.87$ (即 $E=E_r+0.20$)。\n- 测试用例 4：$S_{\\text{area}}=100$, $E_r=6.67$, $\\gamma=0.001$, $\\sigma=0.01$, $E=6.67$。\n\n在您的实现中：\n- 在 $E'$ 中使用一个以 $E_r$ 为中心的对称有限区间进行积分，其宽度应足够大以捕捉洛伦兹因子和高斯因子的有效支撑集。一个合理的选择是设置半宽 $L$ 为 $$L=\\max\\{8\\sigma,\\ 30\\gamma\\},$$ 并在 $E'\\in[E_r-L,\\ E_r+L]$ 上积分。\n- 对两种积分方法都使用包含 $N$ 个点的均匀网格；确保朴素方案和稳定方案的 $N$ 值相同，以便它们的采样分辨率可以直接比较。设 $N$ 为一个固定的值，其选择旨在平衡运行时间和准确性。\n- 对于稳定的 $y$ 空间积分，在 $y\\in[-L/\\sigma,\\ L/\\sigma]$ 上使用变换 $E' = E_r + \\sigma y$，并包含雅可比因子 $\\sigma$。\n\n您的程序应生成单行输出，其中包含测试套件的相对误差，按用例顺序排列，每个用例贡献两个浮点数，分别对应朴素方案和稳定方案。最终输出格式必须为 $$[\\varepsilon_{1,\\text{naive}},\\varepsilon_{1,\\text{stabilized}},\\varepsilon_{2,\\text{naive}},\\varepsilon_{2,\\text{stabilized}},\\varepsilon_{3,\\text{naive}},\\varepsilon_{3,\\text{stabilized}},\\varepsilon_{4,\\text{naive}},\\varepsilon_{4,\\text{stabilized}}].$$",
            "solution": "用户要求编写一个程序，使用三种不同的数值方案计算单个核共振的多普勒展宽截面，并评估它们的相对误差。该问题在科学上是合理的、提法得当，并为严格的实现提供了足够的细节。它涉及核反应堆物理学中的一个标准课题——截面的实时计算，并突出了一个与积分中有效数字损失相关的真实数值挑战。因此，该问题被认为是有效的，有必要提供完整的解决方案。\n\n问题的核心是计算定义了多普勒展宽截面 $\\sigma_D(E)$ 的卷积积分：\n$$\n\\sigma_D(E) = \\int_{-\\infty}^{\\infty}\\sigma_0(E')\\ g(E-E';\\sigma)\\ \\mathrm{d}E'\n$$\n在这里，$\\sigma_0(E)$ 是未展宽的截面，由洛伦兹线型建模，而 $g(x;\\sigma)$ 是代表热运动的高斯核。\n$$\n\\sigma_0(E) = S_{\\text{area}} \\cdot \\ell(E-E_r;\\gamma) = S_{\\text{area}} \\cdot \\frac{1}{\\pi}\\frac{\\gamma}{(E-E_r)^2+\\gamma^2}\n$$\n$$\ng(x;\\sigma) = \\frac{1}{\\sigma\\sqrt{2\\pi}}\\exp\\left(-\\frac{x^2}{2\\sigma^2}\\right)\n$$\n其中 $S_{\\text{area}}$ 是共振强度，$E_r$ 是共振能量，$\\gamma$ 是共振的固有半宽 (HWHM)，$\\sigma$ 是热展宽参数。\n\n我们将实现并比较三种评估此积分的方法。\n\n**方法 1：朴素的 $E'$ 空间积分**\n\n该方法使用简单的矩形积分规则直接近似卷积积分。积分域被截断为一个有限的对称区间 $[E_r-L, E_r+L]$，其中 $L = \\max\\{8\\sigma, 30\\gamma\\}$ 被选得足够大，以包含来自洛伦兹函数和高斯函数的显著贡献。我们将此区间划分为 $N$ 个点，记为 $E'_i$，具有均匀的步长 $\\Delta E' = 2L/(N-1)$。然后，该积分由以下总和近似：\n$$\n\\sigma_{D,\\text{naive}}(E) \\approx \\sum_{i=0}^{N-1} \\sigma_0(E'_i) \\ g(E-E'_i;\\sigma) \\ \\Delta E'\n$$\n这种方法简单直接，但可能会遭受数值不稳定的影响。在对被积函数求和时，特别是对于 $E \\approx E_r$ 的情况，来自 $E'  E$ 和 $E'  E$ 的贡献可能几乎相等且符号相反，如果不小心处理，会导致相减抵消和精度损失。\n\n**方法 2：稳定的 $y$ 空间积分**\n\n为了增强数值稳定性，我们进行变量替换 $y = (E'-E_r)/\\sigma$，这将积分网格中心置于新变量 $y=0$ 处，并按热展宽 $\\sigma$ 进行缩放。此变换的雅可比行列式为 $\\mathrm{d}E' = \\sigma\\,\\mathrm{d}y$。积分变为：\n$$\n\\sigma_D(E) = \\frac{S_{\\text{area}}\\sigma}{\\pi\\sqrt{2\\pi}} \\int_{-L/\\sigma}^{L/\\sigma} \\frac{\\gamma}{(\\sigma y)^2+\\gamma^2} \\exp\\left(-\\frac{(y-y_0)^2}{2}\\right) \\mathrm{d}y\n$$\n其中 $y_0 = (E-E_r)/\\sigma$。对于数值计算，指数项被因式分解以避免当 $y$ 和 $y_0$ 都很大时潜在的浮点溢出和精度损失：\n$$\n\\exp\\left(-\\frac{(y-y_0)^2}{2}\\right) = \\exp\\left(-\\frac{y_0^2}{2}\\right) \\exp(y y_0) \\exp\\left(-\\frac{y^2}{2}\\right)\n$$\n项 $\\exp(-y_0^2/2)$ 相对于积分变量 $y$ 是常数，可以从求和中提出。积分在均匀网格 $y_i \\in [-L/\\sigma, L/\\sigma]$ 上执行，步长为 $\\Delta y$。\n\n为了通过减轻舍入误差累积来进一步提高准确性（在对大量具有宽动态范围的浮点值求和时普遍存在），我们采用 Kahan 补偿求和。该算法维护一个运行的补偿项，以解释每次加法中丢失的低位比特。对于一个值序列 $v_i$，其总和计算如下：\n`sum = 0`, `c = 0`\n对于每个 `v_i`:\n  `y_term = v_i - c`\n  `t = sum + y_term`\n  `c = (t - sum) - y_term`\n  `sum = t`\n\n稳定计算的最终表达式为：\n$$\n\\sigma_{D,\\text{stabilized}}(E) \\approx \\frac{S_{\\text{area}}\\sigma}{\\pi\\sqrt{2\\pi}} \\exp\\left(-\\frac{y_0^2}{2}\\right) \\left( \\sum_{i=0}^{N-1} \\left[ \\frac{\\gamma}{(\\sigma y_i)^2+\\gamma^2} \\exp(y_i y_0) \\exp\\left(-\\frac{y_i^2}{2}\\right) \\right]_{\\text{Kahan}} \\right) \\Delta y\n$$\n\n**方法 3：使用 Faddeeva 函数的参考计算**\n\n洛伦兹函数和高斯函数的卷积产生 Voigt 线型，它可以使用 Faddeeva 函数 $w(z) = e^{-z^2}\\text{erfc}(-iz)$ 进行解析表示。这提供了一个高精度的参考，可以用来与数值积分进行比较。Voigt 线型 $V(x;\\sigma,\\gamma)$ 由下式给出：\n$$\nV(x;\\sigma,\\gamma) = \\frac{1}{\\sigma\\sqrt{2\\pi}}\\ \\Re\\left[w\\left(\\frac{x+i\\gamma}{\\sigma\\sqrt{2}}\\right)\\right]\n$$\n然后，多普勒展宽截面可以直接计算为：\n$$\n\\sigma_{D,\\text{ref}}(E) = S_{\\text{area}} \\cdot V(E-E_r; \\sigma, \\gamma)\n$$\n我们将使用 `scipy.special.wofz` 函数，它是 Faddeeva 函数 $w(z)$ 的一个数值实现。\n\n**误差分析**\n\n对于每个测试用例，将计算朴素方案和稳定方案相对于参考方案的相对误差 $\\varepsilon$：\n$$\n\\varepsilon = \\left|\\frac{\\sigma_D^{\\text{approx}}(E) - \\sigma_D^{\\text{ref}}(E)}{\\sigma_D^{\\text{ref}}(E)}\\right|\n$$\n方法 1 和方法 2 都将使用固定数量的积分点 $N=20001$，以确保对它们的内在准确性和稳定性进行公平比较。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import wofz\n\ndef solve():\n    \"\"\"\n    Computes Doppler-broadened cross sections using three methods and their relative errors.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # S_area, Er, gamma, sigma, E\n        (100.0, 6.67, 0.03, 0.02, 6.67),\n        (100.0, 6.67, 0.03, 0.001, 6.670000001),\n        (100.0, 6.67, 0.03, 0.05, 6.87),\n        (100.0, 6.67, 0.001, 0.01, 6.67),\n    ]\n\n    results = []\n    N = 20001 # Number of quadrature points\n\n    for case in test_cases:\n        S_area, Er, gamma, sigma, E = case\n        \n        # --- Method 3: Reference Calculation (Faddeeva Function) ---\n        x = E - Er\n        # Argument for the Faddeeva function w(z)\n        z = (x + 1j * gamma) / (sigma * np.sqrt(2))\n        \n        # Voigt profile V(x, sigma, gamma)\n        V = np.real(wofz(z)) / (sigma * np.sqrt(2 * np.pi))\n        sigma_ref = S_area * V\n\n        # Define integration limits\n        L = max(8 * sigma, 30 * gamma)\n\n        # --- Method 1: Naive E'-space Quadrature ---\n        e_prime_grid = np.linspace(Er - L, Er + L, N)\n        delta_ep = 2 * L / (N - 1)\n\n        def lorentzian(val, g):\n            return (1 / np.pi) * g / (val**2 + g**2)\n\n        def gaussian(val, s):\n            return (1 / (s * np.sqrt(2 * np.pi))) * np.exp(-val**2 / (2 * s**2))\n\n        integrand_naive = S_area * lorentzian(e_prime_grid - Er, gamma) * gaussian(E - e_prime_grid, sigma)\n        sigma_naive = np.sum(integrand_naive) * delta_ep\n        \n        # --- Method 2: Stabilized y-space Quadrature with Kahan Summation ---\n        y_grid = np.linspace(-L / sigma, -L / sigma + (N-1)*(2*L/(sigma*(N-1))), N) # Avoids endpoint imprecision\n        delta_y = 2 * L / (sigma * (N-1))\n        y0 = (E - Er) / sigma\n\n        def kahan_sum(arr):\n            s = 0.0\n            c = 0.0\n            for val in arr:\n                y_term = val - c\n                t = s + y_term\n                c = (t - s) - y_term\n                s = t\n            return s\n            \n        # Terms inside the Kahan sum, using the factored exponential\n        terms_to_sum = (gamma / ((sigma * y_grid)**2 + gamma**2)) * \\\n                       np.exp(-y_grid**2 / 2) * \\\n                       np.exp(y_grid * y0)\n        \n        sum_k = kahan_sum(terms_to_sum)\n\n        # Prefactor combines all constant terms\n        prefactor = (S_area * sigma / (np.pi * np.sqrt(2 * np.pi))) * np.exp(-y0**2 / 2)\n        \n        sigma_stabilized = prefactor * sum_k * delta_y\n\n        # --- Calculate Relative Errors ---\n        if sigma_ref != 0:\n            err_naive = abs((sigma_naive - sigma_ref) / sigma_ref)\n            err_stabilized = abs((sigma_stabilized - sigma_ref) / sigma_ref)\n        else: # Handle cases where reference is zero (not expected here)\n            err_naive = 0.0 if sigma_naive == 0.0 else np.inf\n            err_stabilized = 0.0 if sigma_stabilized == 0.0 else np.inf\n\n        results.append(err_naive)\n        results.append(err_stabilized)\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "尽管精确的在线计算是可靠的，但每次温度发生微小变化都重新进行完整的卷积计算，其代价是十分高昂的。最后的这项实践将探讨一种在大型模拟程序中广泛应用的优化策略：基于温度的缓存方案。通过对展宽截面函数按温度进行泰勒展开，我们能够近似计算小幅温度阶跃后的截面值，并为其建立严格的误差界限，从而在计算效率和模拟精度之间取得理想的平衡 。",
            "id": "4239871",
            "problem": "考虑在对数能量空间中建模的一维微观截面的多普勒展宽。设 $u = \\ln(E/E_{\\mathrm{ref}})$ 是无量纲对数能量变量，其中 $E$ 的单位为电子伏特，$E_{\\mathrm{ref}}$ 是一个固定的参考能量。未展宽的截面是一个函数 $\\sigma(u)$，单位为靶（barn）。在绝对温度 $T$（单位为开尔文）下的理想化多普勒展宽算符被建模为与一个温度依赖宽度的高斯核的卷积。具体来说，对于一个给定的常数 $\\alpha$（单位为反比开尔文），定义标准差 $s(T) = \\sqrt{\\alpha T}$ 和核函数\n$$\nK(u;T) = \\frac{1}{\\sqrt{2\\pi}\\,s(T)} \\exp\\!\\left(-\\frac{u^2}{2 s(T)^2}\\right).\n$$\n那么，在温度 $T$ 下的多普勒展宽截面为\n$$\n\\sigma_T(u) = \\int_{-\\infty}^{\\infty} \\sigma(u')\\,K(u-u';T)\\,du'.\n$$\n在核反应堆模拟的即时（on-the-fly）使用中，连续输运扫描之间遇到的温度可能会有微小的增量。一种缓存方案旨在重用先前在基准温度 $T_0$ 下计算的展宽值，以近似计算在 $T_1 = T_0 + \\Delta T$ 下的展宽值，而无需在 $T_1$ 下显式地重新计算卷积，同时对近似误差进行限制。\n\n设计并实现一个程序，该程序：\n1. 使用 $\\sigma_T(u)$ 在 $T_0$ 附近关于 $T$ 的一阶泰勒展开：\n$$\n\\sigma_{T_1}(u) \\approx \\sigma_{T_0}(u) + \\Delta T \\left.\\frac{\\partial \\sigma_T(u)}{\\partial T}\\right|_{T=T_0},\n$$\n其中，关于 $T$ 的导数通过在积分号下对核函数进行微分来评估：\n$$\n\\frac{\\partial \\sigma_T(u)}{\\partial T} = \\int_{-\\infty}^{\\infty} \\sigma(u')\\,\\frac{\\partial K(u-u';T)}{\\partial T}\\,du'.\n$$\n同样，二阶导数出现在泰勒余项中：\n$$\n\\frac{\\partial^2 \\sigma_T(u)}{\\partial T^2} = \\int_{-\\infty}^{\\infty} \\sigma(u')\\,\\frac{\\partial^2 K(u-u';T)}{\\partial T^2}\\,du'.\n$$\n2. 基于依赖关系 $s(T)=\\sqrt{\\alpha T}$，推导并使用 $\\frac{\\partial K(u;T)}{\\partial T}$ 和 $\\frac{\\partial^2 K(u;T)}{\\partial T^2}$ 的闭式表达式，除了基本的高斯微分外，不调用任何快捷公式。\n3. 实现如下缓存方案：在一组离散的 $u$ 值上计算并存储 $\\sigma_{T_0}(u)$ 和 $\\left.\\frac{\\partial \\sigma_T(u)}{\\partial T}\\right|_{T_0}$，并用它们来近似 $\\sigma_{T_1}(u)$。使用二阶泰勒余项建立一个严格的绝对近似误差界：\n$$\n\\left|\\sigma_{T_1}(u) - \\left[\\sigma_{T_0}(u) + \\Delta T \\left.\\frac{\\partial \\sigma_T(u)}{\\partial T}\\right|_{T_0}\\right]\\right| \\le \\frac{(\\Delta T)^2}{2} \\left|\\left.\\frac{\\partial^2 \\sigma_T(u)}{\\partial T^2}\\right|_{T_0}\\right|.\n$$\n4. 使用间距为 $\\Delta u$ 的均匀网格 $u_j$ 对 $u$ 上的积分进行离散化，并采用线性卷积，确保积分近似包含因子 $\\Delta u$ 以保证单位一致。假设对于所考虑的温度，$u$ 的域足够宽，使得高斯核在边界处可以忽略不计。\n5. 使用以下科学上合理的截面模型：\n$$\n\\sigma(u) = A_1 \\exp\\!\\left(-\\frac{(u-u_1)^2}{2 b_1^2}\\right) + A_2 \\exp\\!\\left(-\\frac{(u-u_2)^2}{2 b_2^2}\\right) + \\sigma_{\\mathrm{bg}},\n$$\n参数为 $A_1 = 50$ 靶, $u_1 = -0.5$, $b_1 = 0.05$, $A_2 = 20$ 靶, $u_2 = 0.8$, $b_2 = 0.1$, 以及 $\\sigma_{\\mathrm{bg}} = 1$ 靶。\n6. 使用 $\\alpha = 10^{-4}$ (反比开尔文)。\n7. 对于下面提供的每个测试用例，在 $u$ 网格上计算以下量：\n   - 遍及 $u$ 的最大绝对泰勒余项界，等于 $\\max_u \\left(\\frac{(\\Delta T)^2}{2} \\left|\\left.\\frac{\\partial^2 \\sigma_T(u)}{\\partial T^2}\\right|_{T_0}\\right|\\right)$，以靶为单位表示。\n   - 遍及 $u$ 的最大绝对实际误差，等于 $\\max_u \\left|\\sigma_{T_1}(u) - \\left[\\sigma_{T_0}(u) + \\Delta T \\left.\\frac{\\partial \\sigma_T(u)}{\\partial T}\\right|_{T_0}\\right]\\right|$，以靶为单位表示。\n   - 一个布尔决策，指示缓存方案是否可接受，定义为误差界小于或等于指定的绝对容差 $\\varepsilon$（单位为靶）。\n8. 使用一个在 $u \\in [-3,3]$ 范围内，具有 $N = 2048$ 个点的均匀网格，并按下面指定的精确格式输出每个测试用例的结果。\n\n推导基础和约束：\n- 从高斯卷积的基本形式和通过 $s(T) = \\sqrt{\\alpha T}$ 对 $K(u;T)$ 进行关于 $T$ 的链式法则微分出发。\n- 除了高斯导数恒等式和泰勒余项定理外，不提供任何快捷公式。\n- 确保数值实现通过在离散卷积中乘以 $\\Delta u$ 与积分的单位保持一致。\n\n测试套件参数值：\n- 情况 1：$T_0 = 300$ 开尔文, $\\Delta T = 5$ 开尔文, $\\varepsilon = 0.02$ 靶。\n- 情况 2：$T_0 = 900$ 开尔文, $\\Delta T = 10$ 开尔文, $\\varepsilon = 0.04$ 靶。\n- 情况 3：$T_0 = 300$ 开尔文, $\\Delta T = 0$ 开尔文, $\\varepsilon = 10^{-8}$ 靶。\n- 情况 4：$T_0 = 300$ 开尔文, $\\Delta T = 50$ 开尔文, $\\varepsilon = 0.2$ 靶。\n- 情况 5：$T_0 = 50$ 开尔文, $\\Delta T = 5$ 开尔文, $\\varepsilon = 0.02$ 靶。\n\n最终输出格式：\n你的程序应生成一行输出，其中包含一个逗号分隔的列表，列表被方括号包围，每个测试用例的结果本身是一个包含三个元素的列表，顺序为 $[\\text{bound}, \\text{actual}, \\text{ok}]$。例如：\n$[[b_1,a_1,o_1],[b_2,a_2,o_2],\\dots]$。\n所有绝对误差必须以靶为单位表示为十进制数，布尔值 $o_i$ 必须是 $\\text{True}$ 或 $\\text{False}$（不带百分号）。",
            "solution": "问题陈述已经过分析，并被认为是有效的。它科学地基于核反应堆物理学原理，特别是中子截面多普勒展宽的建模。该问题设定良好，提供了所有必要的参数、一个清晰的物理模型和一组具体的计算任务。语言客观，设置在内部一致且物理上合理。\n\n问题的核心是使用在基准温度 $T_0$ 附近的一阶泰勒展开来近似在温度 $T_1 = T_0 + \\Delta T$ 下的多普勒展宽截面 $\\sigma_{T_1}(u)$，并对该近似的误差进行限定。展宽截面 $\\sigma_T(u)$ 由未展宽截面 $\\sigma(u)$ 与一个其宽度依赖于温度的高斯核 $K(u;T)$ 的卷积定义。\n\n解决方案主要分为三个部分：\n1.  高斯核的一阶和二阶温度导数 $\\frac{\\partial K}{\\partial T}$ 和 $\\frac{\\partial^2 K}{\\partial T^2}$ 的解析推导。\n2.  设计一个数值算法来计算卷积积分和所需的误差度量。\n3.  实现该算法以解决给定的测试用例。\n\n**1. 核函数导数的推导**\n\n高斯核由下式给出\n$$\nK(u;T) = \\frac{1}{\\sqrt{2\\pi}\\,s(T)} \\exp\\!\\left(-\\frac{u^2}{2 s(T)^2}\\right)\n$$\n其中标准差 $s(T)$ 定义为 $s(T) = \\sqrt{\\alpha T}$。我们可以将核函数明确地表示为温度 $T$ 的函数：\n$$\nK(u;T) = \\frac{1}{\\sqrt{2\\pi \\alpha T}} \\exp\\!\\left(-\\frac{u^2}{2 \\alpha T}\\right)\n$$\n\n**一阶导数, $\\frac{\\partial K(u;T)}{\\partial T}$**\n我们使用乘法法则对 $K(u;T)$ 关于 $T$ 求导。设 $f(T) = (2\\pi \\alpha T)^{-1/2}$ 和 $g(T) = \\exp\\!\\left(-\\frac{u^2}{2 \\alpha T}\\right)$。\n导数为：\n$$\n\\frac{df}{dT} = -\\frac{1}{2}(2\\pi \\alpha T)^{-3/2} \\cdot (2\\pi \\alpha) = -\\frac{1}{2T} (2\\pi \\alpha T)^{-1/2}\n$$\n$$\n\\frac{dg}{dT} = \\exp\\!\\left(-\\frac{u^2}{2 \\alpha T}\\right) \\cdot \\left(\\frac{u^2}{2 \\alpha T^2}\\right)\n$$\n应用乘法法则, $\\frac{\\partial K}{\\partial T} = \\frac{df}{dT}g(T) + f(T)\\frac{dg}{dT}$:\n$$\n\\frac{\\partial K}{\\partial T} = \\left(-\\frac{1}{2T} \\frac{1}{\\sqrt{2\\pi \\alpha T}}\\right) \\exp\\!\\left(-\\frac{u^2}{2 \\alpha T}\\right) + \\frac{1}{\\sqrt{2\\pi \\alpha T}} \\left(\\frac{u^2}{2 \\alpha T^2} \\exp\\!\\left(-\\frac{u^2}{2 \\alpha T}\\right)\\right)\n$$\n提出原始核函数 $K(u;T)$：\n$$\n\\frac{\\partial K}{\\partial T} = K(u;T) \\left(-\\frac{1}{2T} + \\frac{u^2}{2 \\alpha T^2}\\right)\n$$\n代入 $s(T)^2 = \\alpha T$，我们得到一阶导数的最终形式：\n$$\n\\frac{\\partial K(u;T)}{\\partial T} = \\frac{1}{2T} K(u;T) \\left(\\frac{u^2}{s(T)^2} - 1\\right)\n$$\n\n**二阶导数, $\\frac{\\partial^2 K(u;T)}{\\partial T^2}$**\n我们对 $\\frac{\\partial K}{\\partial T}$ 关于 $T$ 求导，再次对表达式 $\\frac{\\partial K}{\\partial T} = K(u;T) \\left(-\\frac{1}{2T} + \\frac{u^2}{2\\alpha T^2}\\right)$ 使用乘法法则：\n$$\n\\frac{\\partial^2 K}{\\partial T^2} = \\frac{\\partial}{\\partial T}\\left(K(u;T)\\right) \\left(-\\frac{1}{2T} + \\frac{u^2}{2\\alpha T^2}\\right) + K(u;T) \\frac{\\partial}{\\partial T}\\left(-\\frac{1}{2T} + \\frac{u^2}{2\\alpha T^2}\\right)\n$$\n代入 $\\frac{\\partial K}{\\partial T}$ 的表达式并计算二阶导数项：\n$$\n\\frac{\\partial^2 K}{\\partial T^2} = \\left( K(u;T) \\left(-\\frac{1}{2T} + \\frac{u^2}{2\\alpha T^2}\\right) \\right) \\left(-\\frac{1}{2T} + \\frac{u^2}{2\\alpha T^2}\\right) + K(u;T) \\left(\\frac{1}{2T^2} - \\frac{2u^2}{2\\alpha T^3}\\right)\n$$\n提出 $K(u;T)$ 并化简：\n$$\n\\frac{\\partial^2 K}{\\partial T^2} = K(u;T) \\left[ \\left(-\\frac{1}{2T} + \\frac{u^2}{2\\alpha T^2}\\right)^2 + \\frac{1}{2T^2} - \\frac{u^2}{\\alpha T^3} \\right]\n$$\n$$\n= K(u;T) \\left[ \\frac{1}{4T^2} - \\frac{u^2}{2\\alpha T^3} + \\frac{u^4}{4\\alpha^2 T^4} + \\frac{1}{2T^2} - \\frac{u^2}{\\alpha T^3} \\right]\n$$\n$$\n= K(u;T) \\left[ \\frac{u^4}{4\\alpha^2 T^4} - \\frac{3u^2}{2\\alpha T^3} + \\frac{3}{4T^2} \\right]\n$$\n提出 $\\frac{1}{4T^2}$ 并代入 $s(T)^2 = \\alpha T$：\n$$\n\\frac{\\partial^2 K(u;T)}{\\partial T^2} = \\frac{K(u;T)}{4T^2} \\left[ \\frac{u^4}{(\\alpha T)^2} - \\frac{6u^2}{\\alpha T} + 3 \\right] = \\frac{1}{4T^2} K(u;T) \\left(\\frac{u^4}{s(T)^4} - \\frac{6u^2}{s(T)^2} + 3\\right)\n$$\n这些推导出的 $\\frac{\\partial K}{\\partial T}$ 和 $\\frac{\\partial^2 K}{\\partial T^2}$ 表达式用于定义相应的卷积核。\n\n**2. 数值算法**\n\n展宽截面 $\\sigma_T(u)$ 及其温度导数通过卷积积分计算：\n$$\n\\sigma_T(u) = (\\sigma * K_T)(u), \\quad \\frac{\\partial \\sigma_T(u)}{\\partial T} = \\left(\\sigma * \\frac{\\partial K_T}{\\partial T}\\right)(u), \\quad \\frac{\\partial^2 \\sigma_T(u)}{\\partial T^2} = \\left(\\sigma * \\frac{\\partial^2 K_T}{\\partial T^2}\\right)(u)\n$$\n其中 $K_T(u) = K(u;T)$。这些卷积使用快速傅里叶变换（FFT）进行数值实现，这提供了一种基于卷积定理 $\\mathcal{F}\\{f*g\\} = \\mathcal{F}\\{f\\} \\cdot \\mathcal{F}\\{g\\}$ 的高效方法。离散卷积计算必须乘以网格间距 $\\Delta u$ 以近似积分。\n\n每个测试用例 $(T_0, \\Delta T, \\varepsilon)$ 的算法如下：\n1.  **网格和函数设置**：在区间 $[-3, 3]$ 内建立一个具有 $N=2048$ 个点的对数能量 $u$ 的均匀网格。网格间距为 $\\Delta u = 6/(N-1)$。根据指定的函数形式在该网格上评估未展宽截面 $\\sigma(u)$。\n2.  **在 $T_0$ 下的核函数计算**：使用基准温度 $T_0$ 计算标准差 $s_0 = \\sqrt{\\alpha T_0}$。然后使用推导的公式在 $u$-网格上计算离散核函数 $K(u;T_0)$, $\\left.\\frac{\\partial K(u;T)}{\\partial T}\\right|_{T_0}$, 和 $\\left.\\frac{\\partial^2 K(u;T)}{\\partial T^2}\\right|_{T_0}$。\n3.  **在 $T_0$ 下的卷积**：使用基于FFT的卷积（`scipy.signal.fftconvolve`）计算展宽截面 $\\sigma_{T_0}(u)$ 及其导数 $\\left.\\frac{\\partial \\sigma_T}{\\partial T}\\right|_{T_0}$ 和 $\\left.\\frac{\\partial^2 \\sigma_T}{\\partial T^2}\\right|_{T_0}$。每个卷积结果乘以 $\\Delta u$。\n4.  **在 $T_1$ 下的计算**：为了找到实际误差，在 $T_1 = T_0 + \\Delta T$ 下计算“真实”的展宽截面 $\\sigma_{T_1}(u)$。这涉及计算核函数 $K(u;T_1)$ 并将其与 $\\sigma(u)$ 进行卷积。\n5.  **误差和界限计算**：\n    *   计算一阶泰勒近似：$\\sigma_{\\text{approx}}(u) = \\sigma_{T_0}(u) + \\Delta T \\left.\\frac{\\partial \\sigma_T(u)}{\\partial T}\\right|_{T_0}$。\n    *   最大实际误差是 $|\\sigma_{T_1}(u) - \\sigma_{\\text{approx}}(u)|$ 在整个网格上的最大值。\n    *   最大误差界计算为 $\\max_u \\left(\\frac{(\\Delta T)^2}{2} \\left|\\left.\\frac{\\partial^2 \\sigma_T(u)}{\\partial T^2}\\right|_{T_0}\\right|\\right)$。\n6.  **可接受性检查**：如果计算出的最大误差界小于或等于指定的容差 $\\varepsilon$，则认为缓存方案是可接受的。\n\n此过程系统地应用于每个测试用例，以产生所需的输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.signal import fftconvolve\n\ndef solve():\n    \"\"\"\n    Solves the Doppler broadening problem by implementing a Taylor-based caching scheme\n    and evaluating its accuracy and error bounds for several test cases.\n    \"\"\"\n\n    # Define constants and problem parameters.\n    A1 = 50.0  # barns\n    u1 = -0.5\n    b1 = 0.05\n    A2 = 20.0  # barns\n    u2 = 0.8\n    b2 = 0.1\n    sigma_bg = 1.0  # barns\n    alpha = 1e-4  # 1/Kelvin\n    N = 2048\n    u_min, u_max = -3.0, 3.0\n\n    # Define the unbroadened cross section function.\n    def get_sigma_unbroadened(u_grid):\n        \"\"\"Computes the unbroadened cross section on a given grid.\"\"\"\n        term1 = A1 * np.exp(-(u_grid - u1)**2 / (2 * b1**2))\n        term2 = A2 * np.exp(-(u_grid - u2)**2 / (2 * b2**2))\n        return term1 + term2 + sigma_bg\n\n    # Define the kernel and its temperature derivatives.\n    def get_kernels(u_grid, T):\n        \"\"\"Computes the Gaussian kernel and its 1st and 2nd T-derivatives.\"\"\"\n        if T = 0:\n            raise ValueError(\"Temperature must be positive.\")\n        \n        s2 = alpha * T\n        s = np.sqrt(s2)\n\n        # Gaussian kernel K(u;T)\n        K = (1 / (np.sqrt(2 * np.pi) * s)) * np.exp(-u_grid**2 / (2 * s2))\n\n        # First derivative dK/dT\n        factor_dK = (1 / (2 * T)) * (u_grid**2 / s2 - 1)\n        dK_dT = K * factor_dK\n        \n        # Second derivative d^2K/dT^2\n        factor_d2K = (1 / (4 * T**2)) * (u_grid**4 / s2**2 - 6 * u_grid**2 / s2 + 3)\n        d2K_dT2 = K * factor_d2K\n        \n        return K, dK_dT, d2K_dT2\n\n    def process_case(T0, dT, epsilon):\n        \"\"\"\n        Processes a single test case: computes error bound, actual error, and admissibility.\n        \"\"\"\n        u_grid = np.linspace(u_min, u_max, N)\n        du = u_grid[1] - u_grid[0]\n        \n        sigma_u = get_sigma_unbroadened(u_grid)\n\n        # --- Calculations at T0 ---\n        K_T0, dK_dT_T0, d2K_dT2_T0 = get_kernels(u_grid, T0)\n        \n        # Convolutions at T0. Multiply by du to approximate the integral.\n        sigma_T0 = fftconvolve(sigma_u, K_T0, mode='same') * du\n        dsigma_dT_T0 = fftconvolve(sigma_u, dK_dT_T0, mode='same') * du\n        d2sigma_dT2_T0 = fftconvolve(sigma_u, d2K_dT2_T0, mode='same') * du\n        \n        # --- \"True\" calculation at T1 for actual error benchmark ---\n        T1 = T0 + dT\n        \n        if np.isclose(T1, T0):\n            sigma_T1 = sigma_T0\n        else:\n            K_T1, _, _ = get_kernels(u_grid, T1)\n            sigma_T1 = fftconvolve(sigma_u, K_T1, mode='same') * du\n\n        # --- Taylor approximation, actual error, and error bound ---\n        sigma_approx = sigma_T0 + dT * dsigma_dT_T0\n        \n        max_actual_error = np.max(np.abs(sigma_T1 - sigma_approx))\n        \n        max_error_bound = (dT**2 / 2) * np.max(np.abs(d2sigma_dT2_T0))\n        \n        is_admissible = max_error_bound = epsilon\n        \n        # Handle the special case where dT is zero\n        if np.isclose(dT, 0.0):\n            max_actual_error = 0.0\n            max_error_bound = 0.0\n            is_admissible = max_error_bound = epsilon\n\n        return [max_error_bound, max_actual_error, is_admissible]\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (T0, Delta T, epsilon)\n        (300.0, 5.0, 0.02),\n        (900.0, 10.0, 0.04),\n        (300.0, 0.0, 1e-8),\n        (300.0, 50.0, 0.2),\n        (50.0, 5.0, 0.02),\n    ]\n\n    results = []\n    for case in test_cases:\n        T0, dT, epsilon = case\n        result = process_case(T0, dT, epsilon)\n        results.append(result)\n\n    # Format the final output string as specified.\n    result_strings = []\n    for bound, actual, ok in results:\n        result_strings.append(f'[{bound},{actual},{ok}]')\n        \n    final_output = f\"[{','.join(result_strings)}]\"\n    \n    # Final print statement in the exact required format.\n    print(final_output)\n\nsolve()\n```"
        }
    ]
}