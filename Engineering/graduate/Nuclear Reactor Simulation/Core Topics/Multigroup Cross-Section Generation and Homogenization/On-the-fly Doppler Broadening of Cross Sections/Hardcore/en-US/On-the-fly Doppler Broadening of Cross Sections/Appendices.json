{
    "hands_on_practices": [
        {
            "introduction": "Before diving into complex algorithms, it is crucial to solidify the foundational physics of Doppler broadening. This first practice guides you through the direct numerical computation of the convolution integral that defines the broadening effect, highlighting the non-linear relationship between temperature and cross section shape . By comparing your result with a simple linear interpolation, you will gain a first-hand appreciation for why accurate, on-the-fly methods are indispensable in modern reactor analysis.",
            "id": "4239879",
            "problem": "A nuclear reactor simulation must compute on-the-fly temperature broadening of neutron cross sections when requested temperatures are not present in tabulated libraries. Consider a single resolved resonance described at zero temperature by the Single-Level Breit-Wigner (SLBW) form. The objective is to compute the Doppler-broadened cross section at a requested temperature and compare it to a naive linear interpolation between two tabulated temperatures. Formulate and implement a program that, for each case in a given test suite, computes the broadened cross section at the resonance energy using the free-gas Doppler kernel and quantifies the deviation from linear interpolation.\n\nStarting point and definitions:\n- The SLBW zero-temperature resonance cross section is modeled as a Lorentzian function\n$$\n\\sigma_0(E) = \\sigma_\\text{peak} \\frac{(\\Gamma/2)^2}{(E - E_r)^2 + (\\Gamma/2)^2},\n$$\nwhere $E$ is energy in electronvolts (eV), $E_r$ is the resonance energy in eV, $\\Gamma$ is the total width in eV, and $\\sigma_\\text{peak}$ is the peak cross section in barns at $E = E_r$.\n- The thermal motion of target nuclei is assumed to obey the Maxwell-Boltzmann distribution, leading to Doppler broadening represented by a Gaussian convolution in the square-root-of-energy (also called $u$-) space. Define $u = \\sqrt{E}$, and the free-gas Doppler kernel\n$$\nG(u,u';T,A) = \\frac{1}{\\sqrt{\\pi}\\,\\mu(T,A)} \\exp\\!\\left(-\\frac{(u'-u)^2}{\\mu(T,A)^2}\\right),\n$$\nwhere the kernel width parameter in $u$-space is\n$$\n\\mu(T,A) = \\sqrt{\\frac{\\theta(T)}{A}},\n\\quad\n\\theta(T) = k_B T \\text{ in eV},\n$$\nwith $k_B$ the Boltzmann constant and $A$ the target-to-neutron mass ratio (dimensionless). The broadened cross section at temperature $T$ is then\n$$\n\\sigma(E,T) = \\int_0^\\infty \\sigma_0(u'^2)\\, G(u,u';T,A)\\, \\mathrm{d}u'.\n$$\n- The temperatures considered are $T_1 = 800$ Kelvin (K), $T = 873$ K, and $T_2 = 900$ K. Boltzmann’s constant must be used in electronvolts per Kelvin, $k_B = 8.617333262145\\times 10^{-5}$ eV/K.\n- The energy at which the cross section is to be evaluated is $E = E_r$ for each test case.\n\nTasks to implement:\n1. Using the above fundamental base, compute $\\sigma(E_r, T)$ via on-the-fly Doppler broadening (the Gaussian convolution in $u$-space).\n2. Compute $\\sigma(E_r, T_1)$ and $\\sigma(E_r, T_2)$ similarly.\n3. Compute the linearly interpolated value at $T$ between the two tabulated temperatures:\n$$\n\\sigma_\\text{lin}(E_r, T) = \\sigma(E_r, T_1) + \\frac{T - T_1}{T_2 - T_1}\\left[\\sigma(E_r, T_2) - \\sigma(E_r, T_1)\\right].\n$$\n4. Quantify the difference between the on-the-fly broadened value and the linear interpolation at $E = E_r$ using:\n   - The absolute difference in barns,\n   $$\n   \\Delta_\\text{abs} = \\sigma(E_r, T) - \\sigma_\\text{lin}(E_r, T),\n   $$\n   - The fractional difference as a decimal,\n   $$\n   \\Delta_\\text{frac} = \\frac{\\Delta_\\text{abs}}{\\sigma(E_r, T)}.\n   $$\n\nPhysical units and numerical reporting:\n- Energies $E$, $E_r$, and widths $\\Gamma$ are in electronvolts (eV).\n- Temperature $T$ is in Kelvin (K).\n- Cross sections and differences $\\Delta_\\text{abs}$ are in barns.\n- Fractional differences $\\Delta_\\text{frac}$ must be reported as decimals (no percentage sign).\n- Report all floating-point outputs rounded to six decimal places.\n\nTest suite:\nFor each parameter set, evaluate at $E = E_r$ with the specified $A$, $\\Gamma$, and $\\sigma_\\text{peak}$:\n- Case 1 (heavy nuclide, narrow resonance, high peak): $A = 238$, $E_r = 6.670$ eV, $\\Gamma = 0.030$ eV, $\\sigma_\\text{peak} = 3000.0$ barns.\n- Case 2 (medium mass, moderate width): $A = 56$, $E_r = 2.000$ eV, $\\Gamma = 0.300$ eV, $\\sigma_\\text{peak} = 100.0$ barns.\n- Case 3 (light nuclide, broad resonance): $A = 1$, $E_r = 1.000$ eV, $\\Gamma = 0.500$ eV, $\\sigma_\\text{peak} = 20.0$ barns.\n- Case 4 (heavy nuclide, extremely narrow resonance, very high peak): $A = 238$, $E_r = 0.500$ eV, $\\Gamma = 0.001$ eV, $\\sigma_\\text{peak} = 10000.0$ barns.\n\nAlgorithmic requirements:\n- Implement the Gaussian convolution integral in $u$-space with $u = \\sqrt{E}$ and $\\mu(T,A) = \\sqrt{\\theta(T)/A}$, $\\theta(T) = k_B T$ in eV. Perform the integral over $u' \\in [0,\\infty)$; for numerical stability and efficiency, it is acceptable to truncate the integral to $u' \\in [\\max(0,u-8\\mu), u+8\\mu]$, since the Gaussian tails beyond $\\pm 8\\mu$ are negligible.\n- Use robust numerical integration suitable for smooth Gaussian-weighted Lorentzians.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each test case contributes a two-element list $[\\Delta_\\text{abs}, \\Delta_\\text{frac}]$ in that order. For example,\n$[[\\Delta_\\text{abs,1},\\Delta_\\text{frac,1}],[\\Delta_\\text{abs,2},\\Delta_\\text{frac,2}],\\dots]$.",
            "solution": "The problem requires the computation of Doppler-broadened neutron cross sections for a single resonance and a comparison against linear temperature interpolation. The process is based on established principles of nuclear reactor physics.\n\nThe foundation of the calculation is the Single-Level Breit-Wigner (SLBW) formula for the cross section of an isolated resonance at absolute zero temperature ($T=0$ K), given by a Lorentzian function:\n$$\n\\sigma_0(E) = \\sigma_\\text{peak} \\frac{(\\Gamma/2)^2}{(E - E_r)^2 + (\\Gamma/2)^2}\n$$\nHere, $E$ is the neutron energy, $E_r$ is the energy at which the resonance is centered, $\\Gamma$ is the total resonance width, and $\\sigma_\\text{peak}$ is the maximum cross section value, occurring at $E = E_r$. All energies are in electronvolts (eV) and the cross section is in barns.\n\nAt finite temperatures, target nuclei are in thermal motion. In the free-gas model, this motion is described by a Maxwell-Boltzmann distribution of velocities. The effect on the observed cross section is a broadening phenomenon, mathematically represented by a convolution of the zero-temperature cross section with a Doppler kernel. This convolution is most conveniently expressed in the square-root-of-energy space, or $u$-space, where $u = \\sqrt{E}$. The broadened cross section $\\sigma(E,T)$ at a temperature $T$ is given by:\n$$\n\\sigma(E,T) = \\int_0^\\infty \\sigma_0(u'^2)\\, G(u,u';T,A)\\, \\mathrm{d}u'\n$$\nThe function $G(u,u';T,A)$ is the free-gas Doppler kernel, which is a Gaussian function in $u$-space:\n$$\nG(u,u';T,A) = \\frac{1}{\\sqrt{\\pi}\\,\\mu(T,A)} \\exp\\!\\left(-\\frac{(u'-u)^2}{\\mu(T,A)^2}\\right)\n$$\nThe width parameter of the Gaussian kernel, $\\mu(T,A)$, encapsulates the physics of thermal motion:\n$$\n\\mu(T,A) = \\sqrt{\\frac{\\theta(T)}{A}}\n$$\nwhere $\\theta(T) = k_B T$ is the thermal energy in eV, $k_B$ is the Boltzmann constant ($8.617333262145\\times 10^{-5}$ eV/K), and $A$ is the ratio of the target nucleus mass to the neutron mass. The variable $u$ in the kernel corresponds to the evaluation energy $E$ (i.e., $u=\\sqrt{E}$), while $u'$ is the integration variable representing the full spectrum of energies over which the convolution is performed.\n\nThe problem requires evaluation at the resonance energy, $E = E_r$. Therefore, we set $u = u_r = \\sqrt{E_r}$. The integral to compute for a given temperature $T$ is:\n$$\n\\sigma(E_r,T) = \\int_0^\\infty \\sigma_0(u'^2)\\, G(u_r,u';T,A)\\, \\mathrm{d}u'\n$$\nSubstituting the expressions for $\\sigma_0$ and $G$, the integrand becomes:\n$$\n\\text{Integrand}(u') = \\left( \\sigma_\\text{peak} \\frac{(\\Gamma/2)^2}{(u'^2 - E_r)^2 + (\\Gamma/2)^2} \\right) \\left( \\frac{1}{\\sqrt{\\pi}\\,\\mu(T,A)} \\exp\\!\\left(-\\frac{(u'-u_r)^2}{\\mu(T,A)^2}\\right) \\right)\n$$\nThis definite integral must be evaluated numerically. A robust method such as adaptive quadrature, provided by `scipy.integrate.quad` in Python, is suitable for this task. The integration is performed over $u'$ from $0$ to $\\infty$. For numerical efficiency, the problem permits truncating the integration range to $[\\max(0, u_r - 8\\mu), u_r + 8\\mu]$, as the Gaussian kernel's contribution is negligible outside this interval.\n\nThe overall algorithm proceeds as follows for each test case:\n1.  For each of the three temperatures, $T_1 = 800$ K, $T = 873$ K, and $T_2 = 900$ K, calculate the corresponding broadened cross section at the resonance peak, $\\sigma(E_r, T_1)$, $\\sigma(E_r, T)$, and $\\sigma(E_r, T_2)$, by numerically solving the convolution integral defined above.\n\n2.  Calculate a linearly interpolated cross section at $T=873$ K using the values computed at the bracketing temperatures $T_1$ and $T_2$:\n$$\n\\sigma_\\text{lin}(E_r, T) = \\sigma(E_r, T_1) + \\frac{T - T_1}{T_2 - T_1}\\left[\\sigma(E_r, T_2) - \\sigma(E_r, T_1)\\right]\n$$\n\n3.  Quantify the error introduced by this linear approximation by calculating the absolute and fractional differences between the accurately broadened value and the interpolated value:\n    -   Absolute difference: $\\Delta_\\text{abs} = \\sigma(E_r, T) - \\sigma_\\text{lin}(E_r, T)$\n    -   Fractional difference: $\\Delta_\\text{frac} = \\frac{\\Delta_\\text{abs}}{\\sigma(E_r, T)}$\n\n4.  The final results, $\\Delta_\\text{abs}$ and $\\Delta_\\text{frac}$, are collected for each test case and reported with a precision of six decimal places. This analysis demonstrates the non-linear dependence of the cross section on temperature and the potential inaccuracies of simple interpolation schemes used in some nuclear simulation contexts.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import integrate\n\ndef solve():\n    \"\"\"\n    Solves the Doppler broadening problem for the given test cases.\n    \"\"\"\n    \n    # Define constants and fixed temperatures\n    KB = 8.617333262145e-5  # Boltzmann constant in eV/K\n    T1 = 800.0  # K\n    T = 873.0   # K\n    T2 = 900.0  # K\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (A, Er, Gamma, sigma_peak)\n        (238.0, 6.670, 0.030, 3000.0),\n        (56.0, 2.000, 0.300, 100.0),\n        (1.0, 1.000, 0.500, 20.0),\n        (238.0, 0.500, 0.001, 10000.0),\n    ]\n\n    # List to store the results for all cases\n    all_results = []\n\n    def zero_temp_xs(u_prime_sq, Er, Gamma, sigma_peak):\n        \"\"\"\n        Calculates the zero-temperature SLBW cross section.\n        u_prime_sq is u'^2, which is the energy E.\n        \"\"\"\n        half_gamma_sq = (Gamma / 2.0)**2\n        return sigma_peak * half_gamma_sq / ((u_prime_sq - Er)**2 + half_gamma_sq)\n\n    def calculate_broadened_xs(Er, Gamma, sigma_peak, A, temp):\n        \"\"\"\n        Computes the Doppler-broadened cross section at E=Er for a given temperature.\n        \"\"\"\n        # Thermal energy theta\n        theta = KB * temp\n        \n        # Kernel width parameter mu\n        mu = np.sqrt(theta / A)\n        \n        # u-space evaluation point\n        u_r = np.sqrt(Er)\n        \n        # Define the integrand for the convolution\n        def integrand(u_prime):\n            # Gaussian kernel G(u_r, u_prime; T, A)\n            gaussian_kernel = (1.0 / (np.sqrt(np.pi) * mu)) * np.exp(-((u_prime - u_r)**2) / mu**2)\n            \n            # Zero-temperature cross section sigma_0(u_prime^2)\n            sigma_0_val = zero_temp_xs(u_prime**2, Er, Gamma, sigma_peak)\n            \n            return sigma_0_val * gaussian_kernel\n\n        # Integration limits\n        u_min = max(0.0, u_r - 8.0 * mu)\n        u_max = u_r + 8.0 * mu\n        \n        # Perform numerical integration\n        result, _ = integrate.quad(integrand, u_min, u_max, epsabs=1e-12, epsrel=1e-12)\n        \n        return result\n\n    for case in test_cases:\n        A, Er, Gamma, sigma_peak = case\n        \n        # 1. Compute on-the-fly broadened cross section at T\n        sigma_T = calculate_broadened_xs(Er, Gamma, sigma_peak, A, T)\n        \n        # 2. Compute broadened cross sections at T1 and T2\n        sigma_T1 = calculate_broadened_xs(Er, Gamma, sigma_peak, A, T1)\n        sigma_T2 = calculate_broadened_xs(Er, Gamma, sigma_peak, A, T2)\n        \n        # 3. Compute the linearly interpolated value\n        sigma_lin = sigma_T1 + (T - T1) / (T2 - T1) * (sigma_T2 - sigma_T1)\n        \n        # 4. Quantify the differences\n        delta_abs = sigma_T - sigma_lin\n        delta_frac = delta_abs / sigma_T if sigma_T != 0 else 0.0\n        \n        # Store results rounded to six decimal places\n        all_results.append(f\"[{delta_abs:.6f},{delta_frac:.6f}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "While direct numerical integration is instructive, high-performance simulation codes often rely on more efficient methods like the Fast Fourier Transform (FFT) to perform convolutions. This exercise challenges you to implement Doppler broadening using the convolution theorem in logarithmic energy space, a standard technique in the field . In doing so, you will also confront and quantify a critical numerical artifact—aliasing—learning how to ensure the accuracy of this powerful method.",
            "id": "4239867",
            "problem": "You must design and implement a complete algorithm and program that performs on-the-fly Doppler broadening of microscopic cross sections using a convolution in the logarithmic energy variable, while quantifying aliasing error introduced by insufficient grid length when using the Fast Fourier Transform (FFT). The goal is to construct the Doppler-broadened cross section on an equispaced grid in the logarithmic energy variable and to assess the error caused by periodic wrap-around (aliasing) in FFT-based convolution.\n\nBegin from fundamental definitions and well-tested facts appropriate to neutron transport and thermal motion. The logarithmic energy variable is defined as $y = \\ln(E/E_{\\mathrm{ref}})$, where $E$ is the neutron energy and $E_{\\mathrm{ref}}$ is a chosen reference energy. The unbroadened microscopic cross section is specified as a single Lorentzian resonance plus a constant background in energy $E$:\n$$\n\\tilde{\\sigma}_0(E) = \\sigma_{\\mathrm{bg}} + A_{\\mathrm{res}} \\frac{(\\Gamma/2)^2}{(E - E_0)^2 + (\\Gamma/2)^2},\n$$\nwhere $\\tilde{\\sigma}_0$ is measured in barns, $E$ and $E_0$ in electronvolts, and $\\Gamma$ in electronvolts.\n\nYou must derive, using first principles, the Doppler broadening kernel in terms of the logarithmic energy shift $y$ by starting from the Maxwell–Boltzmann distribution of target velocities and the non-relativistic relation between the relative motion and the observed energy shift. Specifically, start from the one-dimensional Maxwell–Boltzmann distribution for the component of target velocity $u$ along the beam direction, with standard deviation $\\sqrt{k_B T / m_t}$, where $k_B$ is the Boltzmann constant, $T$ is temperature in kelvin, and $m_t$ is the target nucleus mass. Using the non-relativistic kinetic energy relation $E = \\frac{1}{2} m_n v_n^2$ for a neutron of mass $m_n$ and speed $v_n$, and the small-Doppler approximation relating fractional energy change to the line-of-sight target velocity, produce a normalized kernel $g_T(y)$ for the logarithmic energy shift, ensuring that the kernel integrates to unity in $y$:\n$$\n\\int_{-\\infty}^{\\infty} g_T(y)\\,dy = 1.\n$$\nDo not include any shortcut formulas in the problem statement; the derivation of the kernel’s functional form, including its width parameter in terms of $T$, $E_{\\mathrm{ref}}$, $m_n$, and $m_t$, must be done in the solution using fundamental definitions and approximations.\n\nAlgorithmic requirements:\n- Construct an equispaced grid in $y$ with $N$ points covering a symmetric interval $[-Y_{\\max}, Y_{\\max}]$.\n- Sample $\\tilde{\\sigma}_0(y)$ by mapping $y \\mapsto E = E_{\\mathrm{ref}} e^y$ and applying the resonance formula above.\n- Construct the Doppler kernel $g_T(y)$ from the derivation and normalize it so that its discrete approximation satisfies $\\sum_j g_T(y_j)\\,\\Delta y \\approx 1$, where $\\Delta y$ is the grid spacing.\n- Compute the Doppler-broadened cross section $\\tilde{\\sigma}(y,T)$ as the convolution of $\\tilde{\\sigma}_0(y)$ with $g_T(y)$ on the $y$-grid. Implement two versions:\n  1. A periodic (circular) convolution using the Fast Fourier Transform (FFT) that assumes the functions are periodic on the finite interval, with correct scaling by $\\Delta y$ so the discrete convolution approximates the integral.\n  2. An aperiodic (linear) convolution by zero-padding both $\\tilde{\\sigma}_0(y)$ and $g_T(y)$ to a sufficiently large length before FFT-based convolution, and then extracting the segment aligned to the original grid, again with correct scaling by $\\Delta y$.\n- Quantify aliasing error attributable to insufficient grid length by comparing the circular convolution result against the zero-padded linear convolution result restricted to the original grid. Use the following two metrics:\n  1. The maximum absolute aliasing error in barns:\n     $$\n     \\max_j \\left| \\tilde{\\sigma}_{\\mathrm{circ}}(y_j,T) - \\tilde{\\sigma}_{\\mathrm{lin}}(y_j,T) \\right|.\n     $$\n  2. The relative $L^2$ aliasing error (dimensionless):\n     $$\n     \\frac{\\left\\| \\tilde{\\sigma}_{\\mathrm{circ}}(\\cdot,T) - \\tilde{\\sigma}_{\\mathrm{lin}}(\\cdot,T) \\right\\|_2}{\\left\\| \\tilde{\\sigma}_{\\mathrm{lin}}(\\cdot,T) \\right\\|_2}.\n     $$\n  Report both metrics for each test case. The first metric must be expressed in barns. The second metric must be a pure decimal number with no unit.\n\nPhysical constants and units:\n- Use $k_B$ in joules per kelvin, $m_n$ and $m_u$ in kilograms, and the electronvolt-to-joule conversion $1\\,\\mathrm{eV} = 1.602176634\\times 10^{-19}\\,\\mathrm{J}$.\n- Express cross sections in barns throughout. The aliasing error maximum must be reported in barns. The relative $L^2$ error must be reported as a decimal number without a unit.\n\nTest suite:\nImplement your program to compute and report the two aliasing metrics for each of the following parameter sets. In all cases, set the target mass to $m_t = A m_u$, where $A$ is the mass number.\n\n- Case 1 (adequate grid):\n  - $E_0 = 6.67\\,\\mathrm{eV}$, $\\Gamma = 0.03\\,\\mathrm{eV}$, $A_{\\mathrm{res}} = 1200\\,\\mathrm{barns}$, $\\sigma_{\\mathrm{bg}} = 10\\,\\mathrm{barns}$.\n  - $E_{\\mathrm{ref}} = E_0$.\n  - $T = 600\\,\\mathrm{K}$, $A = 238$.\n  - Grid: $N = 4096$, $Y_{\\max} = 2.0$.\n\n- Case 2 (insufficient grid length, broad kernel):\n  - $E_0 = 6.67\\,\\mathrm{eV}$, $\\Gamma = 0.03\\,\\mathrm{eV}$, $A_{\\mathrm{res}} = 1200\\,\\mathrm{barns}$, $\\sigma_{\\mathrm{bg}} = 10\\,\\mathrm{barns}$.\n  - $E_{\\mathrm{ref}} = E_0$.\n  - $T = 1200\\,\\mathrm{K}$, $A = 238$.\n  - Grid: $N = 512$, $Y_{\\max} = 0.2$.\n\n- Case 3 (edge case, narrow kernel but small domain):\n  - $E_0 = 6.67\\,\\mathrm{eV}$, $\\Gamma = 0.03\\,\\mathrm{eV}$, $A_{\\mathrm{res}} = 1200\\,\\mathrm{barns}$, $\\sigma_{\\mathrm{bg}} = 10\\,\\mathrm{barns}$.\n  - $E_{\\mathrm{ref}} = E_0$.\n  - $T = 300\\,\\mathrm{K}$, $A = 238$.\n  - Grid: $N = 2048$, $Y_{\\max} = 0.2$.\n\nOutput specification:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each entry is itself a two-element list of the form $[\\mathrm{max\\_absolute\\_aliasing\\_error\\_in\\_barns}, \\mathrm{relative\\_L2\\_aliasing\\_error}]$ corresponding to the cases above, in order. For example:\n$[[x_1,y_1],[x_2,y_2],[x_3,y_3]]$.",
            "solution": "The problem requires the design and implementation of an algorithm to perform on-the-fly Doppler broadening of a microscopic neutron cross section and to quantify the aliasing error that arises from using circular convolution with the Fast Fourier Transform (FFT) on a finite grid. The solution proceeds in two main stages: first, the derivation of the Doppler broadening kernel from fundamental physical principles, and second, the development of a numerical algorithm to compute the broadened cross section and assess aliasing errors.\n\n**1. Derivation of the Doppler Broadening Kernel**\n\nThe Doppler broadening of a cross section arises from the thermal motion of target nuclei in a material. A neutron of energy $E$ incident on a stationary target nucleus would interact based on the cross section $\\tilde{\\sigma}_0(E)$. However, if the target nucleus is moving, the effective interaction energy is shifted. We model this effect to derive a broadening kernel.\n\nThe problem specifies using the one-dimensional Maxwell-Boltzmann distribution for the component of the target nucleus velocity, $u$, along the direction of the incident neutron. This distribution is a Gaussian probability density function (PDF) with a mean of $0$ and a variance of $k_B T / m_t$, where $k_B$ is the Boltzmann constant, $T$ is the absolute temperature, and $m_t$ is the mass of the target nucleus. The PDF for $u$ is:\n$$\nP(u) = \\sqrt{\\frac{m_t}{2\\pi k_B T}} \\exp\\left(-\\frac{m_t u^2}{2 k_B T}\\right)\n$$\n\nThe energy of the neutron as perceived by the moving nucleus, the effective energy $E'$, differs from its lab-frame energy $E$. Using a non-relativistic approximation for a neutron of mass $m_n$ and speed $v_n = \\sqrt{2E/m_n}$, the effective energy is approximately $E' \\approx E - u\\sqrt{2m_n E}$, assuming $u \\ll v_n$. The energy shift is $\\Delta E = E' - E \\approx -u\\sqrt{2m_n E}$.\n\nThe problem is formulated in terms of the logarithmic energy variable $y = \\ln(E/E_{\\mathrm{ref}})$. A small shift in energy $\\Delta E$ around an energy $E_c$ corresponds to a shift in logarithmic energy $\\Delta y = \\ln((E_c+\\Delta E)/E_c) \\approx \\Delta E / E_c$. We are interested in the broadening of a resonance centered at $E_0$. Thus, it is a standard and valid approximation to evaluate the energy-dependent terms in the shift at $E_c = E_0$. The logarithmic energy shift is then:\n$$\n\\delta y \\approx \\frac{\\Delta E}{E_0} \\approx -\\frac{u\\sqrt{2m_n E_0}}{E_0} = -u\\sqrt{\\frac{2m_n}{E_0}}\n$$\nWe can express the velocity component $u$ in terms of the logarithmic energy shift $\\delta y$:\n$$\nu \\approx -\\delta y \\sqrt{\\frac{E_0}{2m_n}}\n$$\nTo find the PDF of the shift $\\delta y$, denoted $g_T(\\delta y)$, we perform a change of variables on the PDF of $u$:\n$$\ng_T(\\delta y) = P(u(\\delta y)) \\left|\\frac{du}{d(\\delta y)}\\right|\n$$\nThe Jacobian of the transformation is $|\\frac{du}{d(\\delta y)}| = \\sqrt{E_0/(2m_n)}$. Substituting $u(\\delta y)$ and the Jacobian into the expression for $P(u)$ yields:\n$$\ng_T(\\delta y) = \\sqrt{\\frac{m_t}{2\\pi k_B T}} \\exp\\left(-\\frac{m_t}{2k_B T} \\left( -\\delta y \\sqrt{\\frac{E_0}{2m_n}} \\right)^2 \\right) \\sqrt{\\frac{E_0}{2m_n}}\n= \\frac{1}{\\sqrt{2\\pi}} \\sqrt{\\frac{m_t E_0}{2 k_B T m_n}} \\exp\\left(-\\frac{m_t E_0}{4 k_B T m_n}(\\delta y)^2\\right)\n$$\nThis is a zero-mean Gaussian distribution for the shift $\\delta y$. The general form is $g_T(\\delta y) = \\frac{1}{\\sqrt{2\\pi \\sigma_y^2}} \\exp(-\\frac{(\\delta y)^2}{2\\sigma_y^2})$. By comparing terms, we identify the variance of the logarithmic energy shift, $\\sigma_y^2$:\n$$\n\\frac{1}{2\\sigma_y^2} = \\frac{m_t E_0}{4 k_B T m_n} \\implies \\sigma_y^2 = \\frac{2 k_B T m_n}{m_t E_0}\n$$\nIn the test cases, the reference energy is set to the resonance energy, $E_{\\mathrm{ref}} = E_0$. Thus, we can write the variance as:\n$$\n\\sigma_y^2 = \\frac{2 m_n k_B T}{m_t E_{\\mathrm{ref}}}\n$$\nThe Doppler broadening kernel for the logarithmic energy shift $y$ is therefore:\n$$\ng_T(y) = \\frac{1}{\\sigma_y \\sqrt{2\\pi}} \\exp\\left(-\\frac{y^2}{2\\sigma_y^2}\\right)\n$$\nThis kernel is normalized such that $\\int_{-\\infty}^{\\infty} g_T(y) dy = 1$. The Doppler-broadened cross section $\\tilde{\\sigma}(y,T)$ is obtained by convolving the unbroadened cross section $\\tilde{\\sigma}_0(y)$ with this kernel:\n$$\n\\tilde{\\sigma}(y,T) = (\\tilde{\\sigma}_0 * g_T)(y) = \\int_{-\\infty}^{\\infty} \\tilde{\\sigma}_0(y') g_T(y - y') dy'\n$$\n\n**2. Numerical Algorithm**\n\nThe convolution is computed numerically on a discrete grid. Aliasing error is quantified by comparing a circular convolution to a more accurate linear convolution.\n\n**a. Grid and Function Preparation**\nAn equispaced grid in the logarithmic energy variable $y$ is created with $N$ points over the interval $[-Y_{\\max}, Y_{\\max}]$. To be compatible with FFT conventions, we define the grid as $y_j = -Y_{\\max} + j \\Delta y$ for $j=0, 1, \\dots, N-1$, where the spacing is $\\Delta y = 2Y_{\\max}/N$.\nThe unbroadened cross section $\\tilde{\\sigma}_0(y)$ is sampled on this grid by first mapping each $y_j$ back to energy $E_j = E_{\\mathrm{ref}} e^{y_j}$ and then evaluating the given Lorentzian formula:\n$$\n\\tilde{\\sigma}_0(E_j) = \\sigma_{\\mathrm{bg}} + A_{\\mathrm{res}} \\frac{(\\Gamma/2)^2}{(E_j - E_0)^2 + (\\Gamma/2)^2}\n$$\nThe Doppler kernel $g_T(y)$ is also sampled on this grid. To improve numerical stability, especially on grids that do not span a sufficient range to capture the full kernel, the discrete kernel is normalized such that its Riemann sum approximates unity: $g_{T,j} \\leftarrow g_{T,j} / (\\sum_k g_{T,k} \\Delta y)$.\n\n**b. Circular Convolution**\nThe convolution theorem states that convolution in the spatial domain is equivalent to multiplication in the frequency domain. A circular convolution is computed efficiently using the FFT:\n$$\n\\tilde{\\sigma}_{\\mathrm{circ}}(y_j, T) \\approx \\Delta y \\cdot \\mathcal{F}^{-1}\\left[ \\mathcal{F}[\\tilde{\\sigma}_0(y_k)] \\cdot \\mathcal{F}[g_T'(y_k)] \\right]_j\n$$\nwhere $\\mathcal{F}$ and $\\mathcal{F}^{-1}$ represent the discrete FFT and its inverse, respectively. The term $g_T'(y_k)$ is the kernel $g_T(y_k)$ after being shifted so its peak (at $y=0$) is at the start of the array, as required by the FFT algorithm. The factor $\\Delta y$ correctly scales the result of the discrete-domain operation to approximate the continuous-domain convolution integral. This method implicitly assumes the functions are periodic over the interval $[-Y_{\\max}, Y_{\\max}]$, which can lead to \"wrap-around\" or aliasing errors if the functions are not negligible at the boundaries.\n\n**c. Linear Convolution (Aperiodic)**\nTo obtain a reference solution free from aliasing, we compute a linear convolution. This is achieved by padding both the signal $\\tilde{\\sigma}_0(y)$ and the shifted kernel $g_T'(y)$ with zeros to a length $M \\ge 2N-1$. Performing the FFT-based convolution on these padded arrays prevents wrap-around. The resulting convoluted signal has length $M$; we extract the first $N$ points, which correspond to the linear convolution result on the original grid.\n$$\n\\tilde{\\sigma}_{\\mathrm{lin}}(y_j, T) \\approx \\Delta y \\cdot \\left( \\mathcal{F}^{-1}\\left[ \\mathcal{F}[\\tilde{\\sigma}_{0,\\text{pad}}(y_k)] \\cdot \\mathcal{F}[g'_{T,\\text{pad}}(y_k)] \\right] \\right)_j, \\quad \\text{for } j=0, \\dots, N-1.\n$$\n\n**d. Aliasing Error Quantification**\nThe aliasing error is the difference between the circular and linear convolution results. We compute two metrics:\n1.  **Maximum Absolute Aliasing Error**: The largest deviation in barns at any grid point.\n    $$\n    \\max_j \\left| \\tilde{\\sigma}_{\\mathrm{circ}}(y_j,T) - \\tilde{\\sigma}_{\\mathrm{lin}}(y_j,T) \\right|\n    $$\n2.  **Relative $L^2$ Aliasing Error**: The vector 2-norm of the error vector, normalized by the 2-norm of the linear convolution result.\n    $$\n    \\frac{\\left\\| \\tilde{\\sigma}_{\\mathrm{circ}} - \\tilde{\\sigma}_{\\mathrm{lin}} \\right\\|_2}{\\left\\| \\tilde{\\sigma}_{\\mathrm{lin}} \\right\\|_2} = \\frac{\\sqrt{\\sum_j (\\tilde{\\sigma}_{\\mathrm{circ}}(y_j,T) - \\tilde{\\sigma}_{\\mathrm{lin}}(y_j,T))^2}}{\\sqrt{\\sum_j \\tilde{\\sigma}_{\\mathrm{lin}}(y_j,T)^2}}\n    $$\nThis procedure is applied to each test case to demonstrate how the choice of grid parameters ($N$, $Y_{\\max}$) and physical parameters ($T$) affects the magnitude of the aliasing error. A larger temperature $T$ broadens the kernel $g_T(y)$, and a smaller grid extent $Y_{\\max}$ increases the truncation of both the cross section and the kernel, both of which are expected to increase aliasing.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the Doppler broadening simulation and error analysis.\n    \"\"\"\n\n    # Physical constants\n    K_B = 1.380649e-23  # Boltzmann constant in J/K\n    M_N = 1.67492749804e-27  # Neutron mass in kg\n    M_U = 1.66053906660e-27  # Atomic mass unit in kg\n    EV_TO_J = 1.602176634e-19  # Electronvolt to Joule conversion\n\n    def run_case(params):\n        \"\"\"\n        Processes a single test case for Doppler broadening and aliasing error analysis.\n        \n        Args:\n            params (dict): A dictionary containing all parameters for the case.\n\n        Returns:\n            list: A list containing the max absolute aliasing error and relative L2 error.\n        \"\"\"\n        # Unpack parameters\n        E0 = params[\"E0\"]\n        Gamma = params[\"Gamma\"]\n        A_res = params[\"A_res\"]\n        sigma_bg = params[\"sigma_bg\"]\n        E_ref = params[\"E_ref\"]\n        T = params[\"T\"]\n        A = params[\"A\"]\n        N = params[\"N\"]\n        Y_max = params[\"Y_max\"]\n\n        # --- 1. Grid and Function Setup ---\n        delta_y = 2.0 * Y_max / N\n        y_grid = np.linspace(-Y_max, Y_max, N, endpoint=False)\n        \n        # Unbroadened cross section sigma_0(y)\n        E_grid = E_ref * np.exp(y_grid)\n        lorentzian_term = (Gamma / 2.0)**2 / ((E_grid - E0)**2 + (Gamma / 2.0)**2)\n        sigma0_y = sigma_bg + A_res * lorentzian_term\n        \n        # Doppler broadening kernel g_T(y)\n        m_t = A * M_U\n        E_ref_J = E_ref * EV_TO_J\n        \n        # Variance of the logarithmic energy shift\n        # sigma_y^2 = (2 * k_B * T * m_n) / (m_t * E_ref)\n        sigma_y_sq = (2.0 * K_B * T * M_N) / (m_t * E_ref_J)\n        sigma_y = np.sqrt(sigma_y_sq)\n        \n        # Evaluate kernel on grid\n        g_y = (1.0 / (sigma_y * np.sqrt(2.0 * np.pi))) * np.exp(-y_grid**2 / (2.0 * sigma_y_sq))\n        \n        # Normalize the discrete kernel to ensure its sum approximates the integral of 1\n        g_y /= np.sum(g_y) * delta_y\n        \n        # --- 2. Convolution Computations ---\n        # The kernel needs to be shifted for FFT-based convolution\n        g_y_shifted = np.fft.ifftshift(g_y)\n\n        # a) Circular convolution\n        sigma0_fft = np.fft.fft(sigma0_y)\n        g_fft = np.fft.fft(g_y_shifted)\n        sigma_circ_fft = sigma0_fft * g_fft\n        sigma_circ_y = np.real(np.fft.ifft(sigma_circ_fft) * delta_y)\n\n        # b) Linear convolution via zero-padding\n        M = 2 * N\n        \n        sigma0_padded = np.pad(sigma0_y, (0, M - N), 'constant')\n        g_padded = np.pad(g_y_shifted, (0, M - N), 'constant')\n\n        sigma0_padded_fft = np.fft.fft(sigma0_padded)\n        g_padded_fft = np.fft.fft(g_padded)\n        \n        sigma_lin_padded_fft = sigma0_padded_fft * g_padded_fft\n        sigma_lin_padded_y = np.real(np.fft.ifft(sigma_lin_padded_fft) * delta_y)\n        \n        # Extract the relevant part of the linear convolution result\n        sigma_lin_y = sigma_lin_padded_y[:N]\n\n        # --- 3. Quantify Aliasing Error ---\n        # Maximum absolute aliasing error in barns\n        max_abs_err = np.max(np.abs(sigma_circ_y - sigma_lin_y))\n        \n        # Relative L2 aliasing error\n        diff_vec = sigma_circ_y - sigma_lin_y\n        l2_norm_diff = np.linalg.norm(diff_vec)\n        l2_norm_lin = np.linalg.norm(sigma_lin_y)\n        \n        # Avoid division by zero if the cross section is zero everywhere (unlikely)\n        if l2_norm_lin == 0:\n            rel_l2_err = 0.0\n        else:\n            rel_l2_err = l2_norm_diff / l2_norm_lin\n            \n        return [max_abs_err, rel_l2_err]\n\n    # Test cases from the problem statement\n    test_cases = [\n        # Case 1: adequate grid\n        {\n            \"E0\": 6.67, \"Gamma\": 0.03, \"A_res\": 1200.0, \"sigma_bg\": 10.0,\n            \"E_ref\": 6.67, \"T\": 600.0, \"A\": 238.0,\n            \"N\": 4096, \"Y_max\": 2.0\n        },\n        # Case 2: insufficient grid length, broad kernel\n        {\n            \"E0\": 6.67, \"Gamma\": 0.03, \"A_res\": 1200.0, \"sigma_bg\": 10.0,\n            \"E_ref\": 6.67, \"T\": 1200.0, \"A\": 238.0,\n            \"N\": 512, \"Y_max\": 0.2\n        },\n        # Case 3: edge case, narrow kernel but small domain\n        {\n            \"E0\": 6.67, \"Gamma\": 0.03, \"A_res\": 1200.0, \"sigma_bg\": 10.0,\n            \"E_ref\": 6.67, \"T\": 300.0, \"A\": 238.0,\n            \"N\": 2048, \"Y_max\": 0.2\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_case(case)\n        results.append(result)\n\n    # Format the final output string exactly as specified\n    formatted_results = f\"[{','.join(str(res) for res in results)}]\"\n    print(formatted_results)\n\nsolve()\n```"
        },
        {
            "introduction": "In a dynamic reactor simulation, temperature fields evolve incrementally, and re-computing every cross section from scratch at each time step can be prohibitively expensive. This practice explores a powerful optimization strategy: a caching scheme based on a Taylor series expansion in temperature, which allows for rapid updates to broadened cross sections . You will not only implement this approximation but also derive a rigorous error bound to intelligently decide when the cached value is sufficiently accurate, a key skill in balancing computational speed and fidelity.",
            "id": "4239871",
            "problem": "Consider the Doppler broadening of a one-dimensional microscopic cross section modeled in logarithmic energy space. Let $u = \\ln(E/E_{\\mathrm{ref}})$ be the dimensionless logarithmic energy variable with $E$ measured in electronvolts and $E_{\\mathrm{ref}}$ a fixed reference energy. The unbroadened cross section is a function $\\sigma(u)$, measured in barns. An idealized Doppler broadening operator at absolute temperature $T$ (in Kelvin) is modeled as a convolution with a Gaussian kernel of temperature-dependent width. Specifically, for a given constant $\\alpha$ (with units of inverse Kelvin), define the standard deviation $s(T) = \\sqrt{\\alpha T}$ and the kernel\n$$\nK(u;T) = \\frac{1}{\\sqrt{2\\pi}\\,s(T)} \\exp\\!\\left(-\\frac{u^2}{2 s(T)^2}\\right).\n$$\nThe Doppler-broadened cross section at temperature $T$ is then\n$$\n\\sigma_T(u) = \\int_{-\\infty}^{\\infty} \\sigma(u')\\,K(u-u';T)\\,du'.\n$$\nIn on-the-fly usage within a nuclear reactor simulation, temperatures encountered between successive transport sweeps can differ by small increments. A caching scheme seeks to reuse previously computed broadened values at a base temperature $T_0$ to approximate the broadened values at $T_1 = T_0 + \\Delta T$ without recomputing the convolution at $T_1$ explicitly, while bounding the approximation error.\n\nDesign and implement a program that:\n1. Uses the Taylor expansion of $\\sigma_T(u)$ with respect to $T$ around $T_0$ to first order:\n$$\n\\sigma_{T_1}(u) \\approx \\sigma_{T_0}(u) + \\Delta T \\left.\\frac{\\partial \\sigma_T(u)}{\\partial T}\\right|_{T=T_0},\n$$\nwhere the derivative with respect to $T$ is evaluated via differentiation of the kernel under the integral sign:\n$$\n\\frac{\\partial \\sigma_T(u)}{\\partial T} = \\int_{-\\infty}^{\\infty} \\sigma(u')\\,\\frac{\\partial K(u-u';T)}{\\partial T}\\,du'.\n$$\nSimilarly, the second derivative appears in the Taylor remainder:\n$$\n\\frac{\\partial^2 \\sigma_T(u)}{\\partial T^2} = \\int_{-\\infty}^{\\infty} \\sigma(u')\\,\\frac{\\partial^2 K(u-u';T)}{\\partial T^2}\\,du'.\n$$\n2. Derives and uses closed-form expressions for $\\frac{\\partial K(u;T)}{\\partial T}$ and $\\frac{\\partial^2 K(u;T)}{\\partial T^2}$ based on the dependence $s(T)=\\sqrt{\\alpha T}$, without invoking any shortcut formulas beyond fundamental Gaussian differentiation.\n3. Implements a caching scheme as follows: compute and store $\\sigma_{T_0}(u)$ and $\\left.\\frac{\\partial \\sigma_T(u)}{\\partial T}\\right|_{T_0}$ at a discretized set of $u$ values, and use them to approximate $\\sigma_{T_1}(u)$. Establish a rigorous bound on the absolute approximation error using the second-order Taylor remainder:\n$$\n\\left|\\sigma_{T_1}(u) - \\left[\\sigma_{T_0}(u) + \\Delta T \\left.\\frac{\\partial \\sigma_T(u)}{\\partial T}\\right|_{T_0}\\right]\\right| \\le \\frac{(\\Delta T)^2}{2} \\left|\\left.\\frac{\\partial^2 \\sigma_T(u)}{\\partial T^2}\\right|_{T_0}\\right|.\n$$\n4. Discretizes the integral in $u$ using a uniform grid $u_j$ with spacing $\\Delta u$ and linear convolution, ensuring the integral approximation includes the factor $\\Delta u$ so that units are consistent. Assume the domain of $u$ is sufficiently wide such that the Gaussian kernel is negligible at the boundaries for the temperatures considered.\n5. Uses the following scientifically plausible cross section model:\n$$\n\\sigma(u) = A_1 \\exp\\!\\left(-\\frac{(u-u_1)^2}{2 b_1^2}\\right) + A_2 \\exp\\!\\left(-\\frac{(u-u_2)^2}{2 b_2^2}\\right) + \\sigma_{\\mathrm{bg}},\n$$\nwith parameters $A_1 = 50$ barns, $u_1 = -0.5$, $b_1 = 0.05$, $A_2 = 20$ barns, $u_2 = 0.8$, $b_2 = 0.1$, and $\\sigma_{\\mathrm{bg}} = 1$ barn.\n6. Uses $\\alpha = 10^{-4}$ (inverse Kelvin).\n7. For each test case provided below, computes on the $u$ grid the following quantities:\n   - The maximum absolute Taylor remainder bound across $u$, equal to $\\max_u \\left(\\frac{(\\Delta T)^2}{2} \\left|\\left.\\frac{\\partial^2 \\sigma_T(u)}{\\partial T^2}\\right|_{T_0}\\right|\\right)$, expressed in barns.\n   - The maximum absolute actual error across $u$, equal to $\\max_u \\left|\\sigma_{T_1}(u) - \\left[\\sigma_{T_0}(u) + \\Delta T \\left.\\frac{\\partial \\sigma_T(u)}{\\partial T}\\right|_{T_0}\\right]\\right|$, expressed in barns.\n   - A boolean decision indicating whether the caching scheme is admissible, defined as the bound being less than or equal to a specified absolute tolerance $\\varepsilon$ (in barns).\n8. Uses a uniform grid $u \\in [-3,3]$ with $N = 2048$ points and outputs results per test case in the exact format specified below.\n\nDerivation basis and constraints:\n- Start from the fundamental form of Gaussian convolution and the chain-rule differentiation of $K(u;T)$ with respect to $T$ via $s(T) = \\sqrt{\\alpha T}$.\n- Provide no shortcut formulas beyond the Gaussian derivative identities and the Taylor remainder theorem.\n- Ensure numerical implementation is consistent with the integral’s units by multiplying by $\\Delta u$ in discrete convolution.\n\nTest suite parameter values:\n- Case $1$: $T_0 = 300$ Kelvin, $\\Delta T = 5$ Kelvin, $\\varepsilon = 0.02$ barns.\n- Case $2$: $T_0 = 900$ Kelvin, $\\Delta T = 10$ Kelvin, $\\varepsilon = 0.04$ barns.\n- Case $3$: $T_0 = 300$ Kelvin, $\\Delta T = 0$ Kelvin, $\\varepsilon = 10^{-8}$ barns.\n- Case $4$: $T_0 = 300$ Kelvin, $\\Delta T = 50$ Kelvin, $\\varepsilon = 0.2$ barns.\n- Case $5$: $T_0 = 50$ Kelvin, $\\Delta T = 5$ Kelvin, $\\varepsilon = 0.02$ barns.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case’s result is itself a list of three elements in the order $[\\text{bound}, \\text{actual}, \\text{ok}]$. For example:\n$[[b_1,a_1,o_1],[b_2,a_2,o_2],\\dots]$.\nAll absolute errors must be expressed in barns as decimal numbers, and the boolean $o_i$ must be either $\\text{True}$ or $\\text{False}$ (without percentage signs).",
            "solution": "The problem statement has been analyzed and is deemed valid. It is scientifically grounded in the principles of nuclear reactor physics, specifically the modeling of Doppler broadening of neutron cross sections. The problem is well-posed, providing all necessary parameters, a clear physical model, and a concrete set of computational tasks. The language is objective and the setup is internally consistent and physically plausible.\n\nThe core of the problem is to approximate a Doppler-broadened cross section $\\sigma_{T_1}(u)$ at a temperature $T_1 = T_0 + \\Delta T$ using a first-order Taylor expansion around a base temperature $T_0$, and to bound the error of this approximation. The broadened cross section $\\sigma_T(u)$ is defined by the convolution of an unbroadened cross section $\\sigma(u)$ with a Gaussian kernel $K(u;T)$ whose width depends on temperature.\n\nThe solution proceeds in three main parts:\n1.  Analytical derivation of the first and second temperature derivatives of the Gaussian kernel, $\\frac{\\partial K}{\\partial T}$ and $\\frac{\\partial^2 K}{\\partial T^2}$.\n2.  Design of a numerical algorithm to compute the convolution integrals and the required error metrics.\n3.  Implementation of the algorithm to solve for the given test cases.\n\n**1. Derivation of Kernel Derivatives**\n\nThe Gaussian kernel is given by\n$$\nK(u;T) = \\frac{1}{\\sqrt{2\\pi}\\,s(T)} \\exp\\!\\left(-\\frac{u^2}{2 s(T)^2}\\right)\n$$\nwhere the standard deviation $s(T)$ is defined as $s(T) = \\sqrt{\\alpha T}$. We can express the kernel explicitly as a function of temperature $T$:\n$$\nK(u;T) = \\frac{1}{\\sqrt{2\\pi \\alpha T}} \\exp\\!\\left(-\\frac{u^2}{2 \\alpha T}\\right)\n$$\n\n**First Derivative, $\\frac{\\partial K(u;T)}{\\partial T}$**\nWe differentiate $K(u;T)$ with respect to $T$ using the product rule. Let $f(T) = (2\\pi \\alpha T)^{-1/2}$ and $g(T) = \\exp\\!\\left(-\\frac{u^2}{2 \\alpha T}\\right)$.\nThe derivatives are:\n$$\n\\frac{df}{dT} = -\\frac{1}{2}(2\\pi \\alpha T)^{-3/2} \\cdot (2\\pi \\alpha) = -\\frac{1}{2T} (2\\pi \\alpha T)^{-1/2}\n$$\n$$\n\\frac{dg}{dT} = \\exp\\!\\left(-\\frac{u^2}{2 \\alpha T}\\right) \\cdot \\left(\\frac{u^2}{2 \\alpha T^2}\\right)\n$$\nApplying the product rule, $\\frac{\\partial K}{\\partial T} = \\frac{df}{dT}g(T) + f(T)\\frac{dg}{dT}$:\n$$\n\\frac{\\partial K}{\\partial T} = \\left(-\\frac{1}{2T} \\frac{1}{\\sqrt{2\\pi \\alpha T}}\\right) \\exp\\!\\left(-\\frac{u^2}{2 \\alpha T}\\right) + \\frac{1}{\\sqrt{2\\pi \\alpha T}} \\left(\\frac{u^2}{2 \\alpha T^2} \\exp\\!\\left(-\\frac{u^2}{2 \\alpha T}\\right)\\right)\n$$\nFactoring out the original kernel $K(u;T)$:\n$$\n\\frac{\\partial K}{\\partial T} = K(u;T) \\left(-\\frac{1}{2T} + \\frac{u^2}{2 \\alpha T^2}\\right)\n$$\nSubstituting $s(T)^2 = \\alpha T$, we obtain the final form for the first derivative:\n$$\n\\frac{\\partial K(u;T)}{\\partial T} = \\frac{1}{2T} K(u;T) \\left(\\frac{u^2}{s(T)^2} - 1\\right)\n$$\n\n**Second Derivative, $\\frac{\\partial^2 K(u;T)}{\\partial T^2}$**\nWe differentiate $\\frac{\\partial K}{\\partial T}$ with respect to $T$, again using the product rule on the expression $\\frac{\\partial K}{\\partial T} = K(u;T) \\left(-\\frac{1}{2T} + \\frac{u^2}{2\\alpha T^2}\\right)$:\n$$\n\\frac{\\partial^2 K}{\\partial T^2} = \\frac{\\partial}{\\partial T}\\left(K(u;T)\\right) \\left(-\\frac{1}{2T} + \\frac{u^2}{2\\alpha T^2}\\right) + K(u;T) \\frac{\\partial}{\\partial T}\\left(-\\frac{1}{2T} + \\frac{u^2}{2\\alpha T^2}\\right)\n$$\nSubstituting the expression for $\\frac{\\partial K}{\\partial T}$ and evaluating the second derivative term:\n$$\n\\frac{\\partial^2 K}{\\partial T^2} = \\left( K(u;T) \\left(-\\frac{1}{2T} + \\frac{u^2}{2\\alpha T^2}\\right) \\right) \\left(-\\frac{1}{2T} + \\frac{u^2}{2\\alpha T^2}\\right) + K(u;T) \\left(\\frac{1}{2T^2} - \\frac{2u^2}{2\\alpha T^3}\\right)\n$$\nFactoring out $K(u;T)$ and simplifying:\n$$\n\\frac{\\partial^2 K}{\\partial T^2} = K(u;T) \\left[ \\left(-\\frac{1}{2T} + \\frac{u^2}{2\\alpha T^2}\\right)^2 + \\frac{1}{2T^2} - \\frac{u^2}{\\alpha T^3} \\right]\n$$\n$$\n= K(u;T) \\left[ \\frac{1}{4T^2} - \\frac{u^2}{2\\alpha T^3} + \\frac{u^4}{4\\alpha^2 T^4} + \\frac{1}{2T^2} - \\frac{u^2}{\\alpha T^3} \\right]\n$$\n$$\n= K(u;T) \\left[ \\frac{u^4}{4\\alpha^2 T^4} - \\frac{3u^2}{2\\alpha T^3} + \\frac{3}{4T^2} \\right]\n$$\nFactoring out $\\frac{1}{4T^2}$ and substituting $s(T)^2 = \\alpha T$:\n$$\n\\frac{\\partial^2 K(u;T)}{\\partial T^2} = \\frac{K(u;T)}{4T^2} \\left[ \\frac{u^4}{(\\alpha T)^2} - \\frac{6u^2}{\\alpha T} + 3 \\right] = \\frac{1}{4T^2} K(u;T) \\left(\\frac{u^4}{s(T)^4} - \\frac{6u^2}{s(T)^2} + 3\\right)\n$$\nThese derived expressions for $\\frac{\\partial K}{\\partial T}$ and $\\frac{\\partial^2 K}{\\partial T^2}$ are used to define the corresponding kernels for convolution.\n\n**2. Numerical Algorithm**\n\nThe broadened cross section $\\sigma_T(u)$ and its temperature derivatives are computed via convolution integrals:\n$$\n\\sigma_T(u) = (\\sigma * K_T)(u), \\quad \\frac{\\partial \\sigma_T(u)}{\\partial T} = \\left(\\sigma * \\frac{\\partial K_T}{\\partial T}\\right)(u), \\quad \\frac{\\partial^2 \\sigma_T(u)}{\\partial T^2} = \\left(\\sigma * \\frac{\\partial^2 K_T}{\\partial T^2}\\right)(u)\n$$\nwhere $K_T(u) = K(u;T)$. These convolutions are implemented numerically using the Fast Fourier Transform (FFT), which provides an efficient method based on the convolution theorem, $\\mathcal{F}\\{f*g\\} = \\mathcal{F}\\{f\\} \\cdot \\mathcal{F}\\{g\\}$. The discrete convolution calculation must be scaled by the grid spacing $\\Delta u$ to approximate the integral.\n\nThe algorithm for each test case $(T_0, \\Delta T, \\varepsilon)$ is as follows:\n1.  **Grid and Function Setup**: A uniform grid for the logarithmic energy $u$ is established in the interval $[-3, 3]$ with $N=2048$ points. The grid spacing is $\\Delta u = 6/(N-1)$. The unbroadened cross section $\\sigma(u)$ is evaluated on this grid according to its specified functional form.\n2.  **Kernel Computation at $T_0$**: The base temperature $T_0$ is used to compute the standard deviation $s_0 = \\sqrt{\\alpha T_0}$. The discrete kernels $K(u;T_0)$, $\\left.\\frac{\\partial K(u;T)}{\\partial T}\\right|_{T_0}$, and $\\left.\\frac{\\partial^2 K(u;T)}{\\partial T^2}\\right|_{T_0}$ are then computed on the $u$-grid using the derived formulas.\n3.  **Convolution at $T_0$**: The FFT-based convolution (`scipy.signal.fftconvolve`) is used to compute the broadened cross section $\\sigma_{T_0}(u)$ and its derivatives $\\left.\\frac{\\partial \\sigma_T}{\\partial T}\\right|_{T_0}$ and $\\left.\\frac{\\partial^2 \\sigma_T}{\\partial T^2}\\right|_{T_0}$. Each convolution result is multiplied by $\\Delta u$.\n4.  **Computation at $T_1$**: To find the actual error, the \"true\" broadened cross section $\\sigma_{T_1}(u)$ is computed at $T_1 = T_0 + \\Delta T$. This involves calculating the kernel $K(u;T_1)$ and convolving it with $\\sigma(u)$.\n5.  **Error and Bound Calculation**:\n    *   The first-order Taylor approximation is computed: $\\sigma_{\\text{approx}}(u) = \\sigma_{T_0}(u) + \\Delta T \\left.\\frac{\\partial \\sigma_T(u)}{\\partial T}\\right|_{T_0}$.\n    *   The maximum actual error is the maximum value of $|\\sigma_{T_1}(u) - \\sigma_{\\text{approx}}(u)|$ over the grid.\n    *   The maximum error bound is calculated as $\\max_u \\left(\\frac{(\\Delta T)^2}{2} \\left|\\left.\\frac{\\partial^2 \\sigma_T(u)}{\\partial T^2}\\right|_{T_0}\\right|\\right)$.\n6.  **Admissibility Check**: The caching scheme is deemed admissible if the calculated maximum error bound is less than or equal to the specified tolerance $\\varepsilon$.\n\nThis procedure is systematically applied to each test case to produce the required outputs.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.signal import fftconvolve\n\ndef solve():\n    \"\"\"\n    Solves the Doppler broadening problem by implementing a Taylor-based caching scheme\n    and evaluating its accuracy and error bounds for several test cases.\n    \"\"\"\n\n    # Define constants and problem parameters.\n    A1 = 50.0  # barns\n    u1 = -0.5\n    b1 = 0.05\n    A2 = 20.0  # barns\n    u2 = 0.8\n    b2 = 0.1\n    sigma_bg = 1.0  # barns\n    alpha = 1e-4  # 1/Kelvin\n    N = 2048\n    u_min, u_max = -3.0, 3.0\n\n    # Define the unbroadened cross section function.\n    def get_sigma_unbroadened(u_grid):\n        \"\"\"Computes the unbroadened cross section on a given grid.\"\"\"\n        term1 = A1 * np.exp(-(u_grid - u1)**2 / (2 * b1**2))\n        term2 = A2 * np.exp(-(u_grid - u2)**2 / (2 * b2**2))\n        return term1 + term2 + sigma_bg\n\n    # Define the kernel and its temperature derivatives.\n    def get_kernels(u_grid, T):\n        \"\"\"Computes the Gaussian kernel and its 1st and 2nd T-derivatives.\"\"\"\n        if T = 0:\n            raise ValueError(\"Temperature must be positive.\")\n        \n        s2 = alpha * T\n        s = np.sqrt(s2)\n\n        # Gaussian kernel K(u;T)\n        K = (1 / (np.sqrt(2 * np.pi) * s)) * np.exp(-u_grid**2 / (2 * s2))\n\n        # First derivative dK/dT\n        factor_dK = (1 / (2 * T)) * (u_grid**2 / s2 - 1)\n        dK_dT = K * factor_dK\n        \n        # Second derivative d^2K/dT^2\n        factor_d2K = (1 / (4 * T**2)) * (u_grid**4 / s2**2 - 6 * u_grid**2 / s2 + 3)\n        d2K_dT2 = K * factor_d2K\n        \n        return K, dK_dT, d2K_dT2\n\n    def process_case(T0, dT, epsilon):\n        \"\"\"\n        Processes a single test case: computes error bound, actual error, and admissibility.\n        \"\"\"\n        u_grid = np.linspace(u_min, u_max, N)\n        du = u_grid[1] - u_grid[0]\n        \n        sigma_u = get_sigma_unbroadened(u_grid)\n\n        # --- Calculations at T0 ---\n        K_T0, dK_dT_T0, d2K_dT2_T0 = get_kernels(u_grid, T0)\n        \n        # Convolutions at T0. Multiply by du to approximate the integral.\n        sigma_T0 = fftconvolve(sigma_u, K_T0, mode='same') * du\n        dsigma_dT_T0 = fftconvolve(sigma_u, dK_dT_T0, mode='same') * du\n        d2sigma_dT2_T0 = fftconvolve(sigma_u, d2K_dT2_T0, mode='same') * du\n        \n        # --- \"True\" calculation at T1 for actual error benchmark ---\n        T1 = T0 + dT\n        \n        if np.isclose(T1, T0):\n            sigma_T1 = sigma_T0\n        else:\n            K_T1, _, _ = get_kernels(u_grid, T1)\n            sigma_T1 = fftconvolve(sigma_u, K_T1, mode='same') * du\n\n        # --- Taylor approximation, actual error, and error bound ---\n        sigma_approx = sigma_T0 + dT * dsigma_dT_T0\n        \n        max_actual_error = np.max(np.abs(sigma_T1 - sigma_approx))\n        \n        max_error_bound = (dT**2 / 2) * np.max(np.abs(d2sigma_dT2_T0))\n        \n        is_admissible = max_error_bound = epsilon\n        \n        # Handle the special case where dT is zero\n        if np.isclose(dT, 0.0):\n            max_actual_error = 0.0\n            max_error_bound = 0.0\n            is_admissible = max_error_bound = epsilon\n\n        return [max_error_bound, max_actual_error, is_admissible]\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (T0, Delta T, epsilon)\n        (300.0, 5.0, 0.02),\n        (900.0, 10.0, 0.04),\n        (300.0, 0.0, 1e-8),\n        (300.0, 50.0, 0.2),\n        (50.0, 5.0, 0.02),\n    ]\n\n    results = []\n    for case in test_cases:\n        T0, dT, epsilon = case\n        result = process_case(T0, dT, epsilon)\n        results.append(result)\n\n    # Format the final output string as specified.\n    result_strings = []\n    for bound, actual, ok in results:\n        result_strings.append(f'[{bound},{actual},{ok}]')\n        \n    final_output = f\"[{','.join(result_strings)}]\"\n    \n    # Final print statement in the exact required format.\n    print(final_output)\n\nsolve()\n```"
        }
    ]
}