{
    "hands_on_practices": [
        {
            "introduction": "The $P_n$ approximation is fundamentally a spectral method that represents the angular dependence of neutron flux using a basis of orthogonal polynomials. This first practice takes you back to the mathematical foundation by deriving the first few of these essential basis functions, the Legendre polynomials, from scratch. By using the Rodrigues formula and verifying their orthogonality, you will gain a concrete understanding of the properties that make these polynomials uniquely suited for transport theory applications. ",
            "id": "4256614",
            "problem": "In one-dimensional slab-geometry neutron transport, the Spherical Harmonics ($P_{n}$) approximation expands the angular dependence of the neutron angular flux in terms of Legendre polynomials in the direction cosine variable $\\mu \\in [-1,1]$. Starting from the fundamental definition of the Legendre polynomials via the Rodrigues construction and viewing them as the orthogonal eigenfunctions associated with the Legendre differential operator on $[-1,1]$ with unit weight, derive the first four Legendre polynomials $P_{0}(\\mu)$ through $P_{3}(\\mu)$. Then, confirm that the normalization is consistent with transport conventions, namely that $P_{l}(1)=1$ for $l=0,1,2,3$ and that the weight-$1$ orthogonality on $[-1,1]$ holds so that the self-inner-products satisfy $\\int_{-1}^{1} P_{l}(\\mu)^{2} \\, d\\mu = \\frac{2}{2l+1}$ for $l=0,1,2,3$, and the cross-inner-products $\\int_{-1}^{1} P_{l}(\\mu) P_{m}(\\mu) \\, d\\mu=0$ for $l \\neq m$ with $l,m \\in \\{0,1,2,3\\}$. Provide the four polynomials explicitly in closed form as functions of $\\mu$. The final answer must be the four polynomials collected as a single row matrix. No rounding is required.",
            "solution": "The problem requires the derivation of the first four Legendre polynomials, $P_{0}(\\mu)$ through $P_{3}(\\mu)$, starting from the Rodrigues construction. These polynomials are fundamental in the $P_{n}$ approximation method for the neutron transport equation, where they form an orthogonal basis for expanding the angular dependence of the neutron flux over the domain of the direction cosine, $\\mu \\in [-1, 1]$. After deriving the polynomials, their normalization and orthogonality properties, which are crucial for their use in transport theory, must be explicitly verified.\n\nThe Rodrigues' formula for the Legendre polynomials, $P_{l}(\\mu)$, is given by:\n$$ P_{l}(\\mu) = \\frac{1}{2^{l} l!} \\frac{d^{l}}{d\\mu^{l}} (\\mu^2 - 1)^l $$\nWe will apply this formula for $l=0, 1, 2, 3$.\n\nFor $l=0$:\n$$ P_{0}(\\mu) = \\frac{1}{2^{0} 0!} \\frac{d^{0}}{d\\mu^{0}} (\\mu^2 - 1)^0 = \\frac{1}{1 \\cdot 1} \\cdot 1 = 1 $$\n\nFor $l=1$:\n$$ P_{1}(\\mu) = \\frac{1}{2^{1} 1!} \\frac{d}{d\\mu} (\\mu^2 - 1)^1 = \\frac{1}{2} (2\\mu) = \\mu $$\n\nFor $l=2$:\n$$ P_{2}(\\mu) = \\frac{1}{2^{2} 2!} \\frac{d^2}{d\\mu^2} (\\mu^2 - 1)^2 = \\frac{1}{8} \\frac{d^2}{d\\mu^2} (\\mu^4 - 2\\mu^2 + 1) $$\nThe first derivative is $\\frac{d}{d\\mu}(\\mu^4 - 2\\mu^2 + 1) = 4\\mu^3 - 4\\mu$.\nThe second derivative is $\\frac{d}{d\\mu}(4\\mu^3 - 4\\mu) = 12\\mu^2 - 4$.\nThus,\n$$ P_{2}(\\mu) = \\frac{1}{8} (12\\mu^2 - 4) = \\frac{4}{8} (3\\mu^2 - 1) = \\frac{1}{2} (3\\mu^2 - 1) $$\n\nFor $l=3$:\n$$ P_{3}(\\mu) = \\frac{1}{2^{3} 3!} \\frac{d^3}{d\\mu^3} (\\mu^2 - 1)^3 = \\frac{1}{8 \\cdot 6} \\frac{d^3}{d\\mu^3} (\\mu^6 - 3\\mu^4 + 3\\mu^2 - 1) $$\nThe first derivative is $6\\mu^5 - 12\\mu^3 + 6\\mu$.\nThe second derivative is $30\\mu^4 - 36\\mu^2 + 6$.\nThe third derivative is $120\\mu^3 - 72\\mu$.\nThus,\n$$ P_{3}(\\mu) = \\frac{1}{48} (120\\mu^3 - 72\\mu) = \\frac{24}{48} (5\\mu^3 - 3\\mu) = \\frac{1}{2} (5\\mu^3 - 3\\mu) $$\n\nThe first four Legendre polynomials are:\n$P_0(\\mu) = 1$\n$P_1(\\mu) = \\mu$\n$P_2(\\mu) = \\frac{1}{2}(3\\mu^2 - 1)$\n$P_3(\\mu) = \\frac{1}{2}(5\\mu^3 - 3\\mu)$\n\nNext, we verify the normalization condition $P_{l}(1)=1$ for $l = 0, 1, 2, 3$.\nFor $l=0$: $P_{0}(1) = 1$.\nFor $l=1$: $P_{1}(1) = 1$.\nFor $l=2$: $P_{2}(1) = \\frac{1}{2}(3(1)^2 - 1) = \\frac{1}{2}(2) = 1$.\nFor $l=3$: $P_{3}(1) = \\frac{1}{2}(5(1)^3 - 3(1)) = \\frac{1}{2}(2) = 1$.\nThe normalization condition is satisfied.\n\nFinally, we verify the orthogonality relations on the interval $[-1,1]$ with a weight of $1$.\n\nFirst, the self-inner-products: $\\int_{-1}^{1} P_{l}(\\mu)^2 \\, d\\mu = \\frac{2}{2l+1}$.\nFor $l=0$: $\\int_{-1}^{1} P_{0}(\\mu)^2 \\, d\\mu = \\int_{-1}^{1} 1^2 \\, d\\mu = [\\mu]_{-1}^{1} = 1 - (-1) = 2$. The formula gives $\\frac{2}{2(0)+1} = 2$.\nFor $l=1$: $\\int_{-1}^{1} P_{1}(\\mu)^2 \\, d\\mu = \\int_{-1}^{1} \\mu^2 \\, d\\mu = \\left[\\frac{\\mu^3}{3}\\right]_{-1}^{1} = \\frac{1}{3} - \\frac{-1}{3} = \\frac{2}{3}$. The formula gives $\\frac{2}{2(1)+1} = \\frac{2}{3}$.\nFor $l=2$: $\\int_{-1}^{1} P_{2}(\\mu)^2 \\, d\\mu = \\int_{-1}^{1} \\left(\\frac{1}{2}(3\\mu^2 - 1)\\right)^2 \\, d\\mu = \\frac{1}{4} \\int_{-1}^{1} (9\\mu^4 - 6\\mu^2 + 1) \\, d\\mu = \\frac{1}{4} \\left[ \\frac{9\\mu^5}{5} - 2\\mu^3 + \\mu \\right]_{-1}^{1} = \\frac{1}{4} \\left( (\\frac{9}{5} - 2 + 1) - (-\\frac{9}{5} + 2 - 1) \\right) = \\frac{1}{4} \\left( \\frac{4}{5} - (-\\frac{4}{5}) \\right) = \\frac{1}{4} \\left(\\frac{8}{5}\\right) = \\frac{2}{5}$. The formula gives $\\frac{2}{2(2)+1} = \\frac{2}{5}$.\nFor $l=3$: $\\int_{-1}^{1} P_{3}(\\mu)^2 \\, d\\mu = \\int_{-1}^{1} \\left(\\frac{1}{2}(5\\mu^3 - 3\\mu)\\right)^2 \\, d\\mu = \\frac{1}{4} \\int_{-1}^{1} (25\\mu^6 - 30\\mu^4 + 9\\mu^2) \\, d\\mu = \\frac{1}{4} \\left[ \\frac{25\\mu^7}{7} - 6\\mu^5 + 3\\mu^3 \\right]_{-1}^{1} = \\frac{1}{4} \\left( (\\frac{25}{7} - 6 + 3) - (-\\frac{25}{7} + 6 - 3) \\right) = \\frac{1}{4} \\left( \\frac{4}{7} - (-\\frac{4}{7}) \\right) = \\frac{1}{4} \\left(\\frac{8}{7}\\right) = \\frac{2}{7}$. The formula gives $\\frac{2}{2(3)+1} = \\frac{2}{7}$.\nAll self-inner-products are correct.\n\nSecond, the cross-inner-products: $\\int_{-1}^{1} P_{l}(\\mu) P_{m}(\\mu) \\, d\\mu = 0$ for $l \\neq m$.\nWe note that $P_l(\\mu)$ is an even function for even $l$ and an odd function for odd $l$. The integral of a product of an even and an odd function over a symmetric interval like $[-1,1]$ is zero.\nCases with mixed parity ($l$ even, $m$ odd, or vice versa):\n$\\int_{-1}^{1} P_{0}(\\mu)P_{1}(\\mu) \\, d\\mu = 0$\n$\\int_{-1}^{1} P_{0}(\\mu)P_{3}(\\mu) \\, d\\mu = 0$\n$\\int_{-1}^{1} P_{1}(\\mu)P_{2}(\\mu) \\, d\\mu = 0$\n$\\int_{-1}^{1} P_{2}(\\mu)P_{3}(\\mu) \\, d\\mu = 0$\nThese are all zero due to the parity of the integrands.\n\nCases with same parity:\nFor $l=0, m=2$:\n$\\int_{-1}^{1} P_{0}(\\mu)P_{2}(\\mu) \\, d\\mu = \\int_{-1}^{1} (1) \\left(\\frac{1}{2}(3\\mu^2 - 1)\\right) \\, d\\mu = \\frac{1}{2} [\\mu^3 - \\mu]_{-1}^{1} = \\frac{1}{2} ((1-1) - (-1 - (-1))) = 0$.\nFor $l=1, m=3$:\n$\\int_{-1}^{1} P_{1}(\\mu)P_{3}(\\mu) \\, d\\mu = \\int_{-1}^{1} (\\mu) \\left(\\frac{1}{2}(5\\mu^3 - 3\\mu)\\right) \\, d\\mu = \\frac{1}{2} \\int_{-1}^{1} (5\\mu^4 - 3\\mu^2) \\, d\\mu = \\frac{1}{2} [\\mu^5 - \\mu^3]_{-1}^{1} = \\frac{1}{2} ((1-1) - (-1 - (-1))) = 0$.\nThe orthogonality is confirmed for all pairs with $l, m \\in \\{0, 1, 2, 3\\}$ and $l \\neq m$.\n\nThe derivation and verification are complete. The four polynomials are provided in the final answer.",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix} 1 & \\mu & \\frac{1}{2}(3\\mu^2 - 1) & \\frac{1}{2}(5\\mu^3 - 3\\mu) \\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "While $P_n$ transport codes solve for the angular moments $\\phi_{\\ell}(x)$, the physically meaningful quantity is the angular flux $\\psi(x, \\mu)$. This exercise guides you through the crucial process of reconstructing the approximate flux from its moments. More importantly, it confronts a well-known pitfall of the $P_n$ method: the truncated series is not guaranteed to be non-negative, potentially violating physical reality. This practice provides a computational method to test for this unphysical behavior. ",
            "id": "4256647",
            "problem": "Consider one-speed, steady-state neutron transport in one-dimensional slab geometry, where the angular flux $\\psi(x,\\mu)$ depends on the spatial coordinate $x$ and the direction cosine $\\mu \\in [-1,1]$. The spherical harmonics (SH) approach approximates angular dependence using Legendre polynomials $P_{\\ell}(\\mu)$, and transport solvers often compute a finite set of Legendre moments $\\{\\phi_{\\ell}(x)\\}_{\\ell=0}^{N}$, where each moment is defined by the fundamental relation $\\phi_{\\ell}(x) = \\int_{-1}^{1} \\psi(x,\\mu) P_{\\ell}(\\mu)\\,d\\mu$. The Legendre polynomials satisfy the well-tested orthogonality property $\\int_{-1}^{1} P_{\\ell}(\\mu) P_{m}(\\mu)\\,d\\mu = \\frac{2}{2\\ell+1}\\delta_{\\ell m}$, where $\\delta_{\\ell m}$ is the Kronecker delta. Physical angular flux must satisfy $\\psi(x,\\mu) \\ge 0$ for all $\\mu \\in [-1,1]$ and all $x$.\n\nStarting only from these facts, derive how to reconstruct an approximate angular flux $\\psi_{N}(x,\\mu)$ from the computed moments $\\{\\phi_{\\ell}(x)\\}_{\\ell=0}^{N}$ using a truncated expansion in Legendre polynomials for $N=3$. Then implement this reconstruction and assess the positivity of $\\psi_{3}(x,\\mu)$ across the entire angular domain $\\mu \\in [-1,1]$ by evaluating the reconstructed $\\psi_{3}(x,\\mu)$ on a uniform grid of $M=1001$ points in $\\mu$ and checking whether the minimum value is nonnegative.\n\nYour program must:\n- Implement the reconstruction algorithm that maps a given list of moments $\\{\\phi_{0},\\phi_{1},\\phi_{2},\\phi_{3}\\}$ at a fixed spatial coordinate $x$ to the truncated-angular-flux approximation $\\psi_{3}(x,\\mu)$ using Legendre polynomials up to order $3$.\n- Evaluate $\\psi_{3}(x,\\mu)$ on a uniform grid in $\\mu$ with $M=1001$ points over $[-1,1]$.\n- Return a boolean indicating whether the reconstructed flux is nonnegative at all sampled angles, i.e., whether $\\min_{\\mu \\in [-1,1]} \\psi_{3}(x,\\mu) \\ge 0$.\n\nNo physical units are required because $\\mu$ is dimensionless by definition (cosine of polar angle), and no angles explicitly appear in the input; thus no angle unit specification is needed. The positivity check must be exact in the sense of the numerical grid described.\n\nUse the following test suite of moment sets at a single spatial location $x$:\n- Test $1$ (isotropic positive reference): $\\{\\phi_{0},\\phi_{1},\\phi_{2},\\phi_{3}\\} = \\{1.0, 0.0, 0.0, 0.0\\}$.\n- Test $2$ (strong first-moment anisotropy): $\\{\\phi_{0},\\phi_{1},\\phi_{2},\\phi_{3}\\} = \\{1.0, 0.6, 0.0, 0.0\\}$.\n- Test $3$ (linearly anisotropic but positive underlying distribution with $A=0.7$, $\\alpha=0.8$): $\\{\\phi_{0},\\phi_{1},\\phi_{2},\\phi_{3}\\} = \\{1.4, 0.37333333333333335, 0.0, 0.0\\}$.\n- Test $4$ (even anisotropy via $P_{2}$ component with $A=0.9$, $\\beta=1.5$): $\\{\\phi_{0},\\phi_{1},\\phi_{2},\\phi_{3}\\} = \\{1.8, 0.0, 0.54, 0.0\\}$.\n- Test $5$ (boundary-linear case with $A=0.5$, $\\alpha=1.0$): $\\{\\phi_{0},\\phi_{1},\\phi_{2},\\phi_{3}\\} = \\{1.0, 0.3333333333333333, 0.0, 0.0\\}$.\n- Test $6$ (non-realizable moment set with zero scalar flux): $\\{\\phi_{0},\\phi_{1},\\phi_{2},\\phi_{3}\\} = \\{0.0, 0.3, 0.0, 0.0\\}$.\n- Test $7$ (mixed higher-order anisotropy): $\\{\\phi_{0},\\phi_{1},\\phi_{2},\\phi_{3}\\} = \\{1.0, 0.2, 0.1, -0.05\\}$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[result1,result2,\\dots]$), where each entry is a boolean corresponding to the positivity assessment for the respective test case, in the order listed above.",
            "solution": "The problem requires the derivation of a method to reconstruct an approximate angular neutron flux, $\\psi_N(x, \\mu)$, from a given set of its Legendre moments, $\\{\\phi_{\\ell}(x)\\}_{\\ell=0}^{N}$, and then to implement this reconstruction for $N=3$ to assess its positivity. The problem is set in one-dimensional slab geometry, where $\\psi$ depends on position $x$ and the cosine of the polar angle, $\\mu \\in [-1,1]$. The derivation will be performed at a fixed spatial coordinate $x$, so the dependence on $x$ will be omitted for notational simplicity, e.g., $\\psi(\\mu)$ and $\\phi_{\\ell}$.\n\nThe foundation of the spherical harmonics ($P_N$) method is the approximation of the angular flux $\\psi(\\mu)$ by a truncated series of Legendre polynomials, $P_{\\ell}(\\mu)$:\n$$\n\\psi_N(\\mu) = \\sum_{\\ell=0}^{N} c_{\\ell} P_{\\ell}(\\mu)\n$$\nHere, $\\psi_N(\\mu)$ is the $N$-th order approximation to the true flux $\\psi(\\mu)$, and $\\{c_{\\ell}\\}_{\\ell=0}^{N}$ are the unknown expansion coefficients we must determine.\n\nThe problem provides the definition of the Legendre moments of the flux:\n$$\n\\phi_m = \\int_{-1}^{1} \\psi(\\mu) P_m(\\mu) \\,d\\mu\n$$\nTo connect the given moments $\\{\\phi_m\\}$ to the unknown coefficients $\\{c_\\ell\\}$, we enforce the condition that the moments of the approximated flux $\\psi_N(\\mu)$ must be equal to the given moments for all orders up to $N$:\n$$\n\\phi_m = \\int_{-1}^{1} \\psi_N(\\mu) P_m(\\mu) \\,d\\mu \\quad \\text{for } m = 0, 1, \\dots, N\n$$\nSubstituting the series expansion for $\\psi_N(\\mu)$ into this equation gives:\n$$\n\\phi_m = \\int_{-1}^{1} \\left( \\sum_{\\ell=0}^{N} c_{\\ell} P_{\\ell}(\\mu) \\right) P_m(\\mu) \\,d\\mu\n$$\nBy linearity of the integral, we can interchange the summation and integration:\n$$\n\\phi_m = \\sum_{\\ell=0}^{N} c_{\\ell} \\int_{-1}^{1} P_{\\ell}(\\mu) P_m(\\mu) \\,d\\mu\n$$\nThe problem statement provides the orthogonality property of the Legendre polynomials:\n$$\n\\int_{-1}^{1} P_{\\ell}(\\mu) P_m(\\mu) \\,d\\mu = \\frac{2}{2\\ell+1} \\delta_{\\ell m}\n$$\nwhere $\\delta_{\\ell m}$ is the Kronecker delta, which is $1$ if $\\ell = m$ and $0$ otherwise.\n\nSubstituting this orthogonality relation into the equation for $\\phi_m$:\n$$\n\\phi_m = \\sum_{\\ell=0}^{N} c_{\\ell} \\left( \\frac{2}{2\\ell+1} \\delta_{\\ell m} \\right)\n$$\nFor a given $m$ (where $0 \\le m \\le N$), the sum over $\\ell$ collapses to a single non-zero term, which occurs when $\\ell=m$:\n$$\n\\phi_m = c_m \\left( \\frac{2}{2m+1} \\right)\n$$\nWe can now solve for the unknown coefficient $c_m$:\n$$\nc_m = \\frac{2m+1}{2} \\phi_m\n$$\nThis provides a direct relationship between the expansion coefficients and the given moments. By substituting this expression for $c_\\ell$ back into the original series for $\\psi_N(\\mu)$, we obtain the final reconstruction formula:\n$$\n\\psi_N(\\mu) = \\sum_{\\ell=0}^{N} \\frac{2\\ell+1}{2} \\phi_{\\ell} P_{\\ell}(\\mu)\n$$\nThe problem specifies an approximation of order $N=3$. Therefore, the reconstruction formula to be implemented is:\n$$\n\\psi_3(\\mu) = \\frac{1}{2}\\phi_0 P_0(\\mu) + \\frac{3}{2}\\phi_1 P_1(\\mu) + \\frac{5}{2}\\phi_2 P_2(\\mu) + \\frac{7}{2}\\phi_3 P_3(\\mu)\n$$\nThe first four Legendre polynomials are:\n- $P_0(\\mu) = 1$\n- $P_1(\\mu) = \\mu$\n- $P_2(\\mu) = \\frac{1}{2}(3\\mu^2 - 1)$\n- $P_3(\\mu) = \\frac{1}{2}(5\\mu^3 - 3\\mu)$\n\nThe numerical task is to evaluate this expression for $\\psi_3(\\mu)$ for a given set of moments $\\{\\phi_0, \\phi_1, \\phi_2, \\phi_3\\}$ over a uniform grid of $M=1001$ points in the domain $\\mu \\in [-1,1]$. After computing the values of $\\psi_3(\\mu)$ on this grid, we find the minimum value. If this minimum is greater than or equal to $0$, the reconstructed flux is considered non-negative, and the assessment is positive (True). Otherwise, it is negative (False). The physical axiom $\\psi(x,\\mu) \\ge 0$ is not always preserved by the truncated $P_N$ approximation, and this procedure is designed to test for this violation.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import legendre\n\ndef solve():\n    \"\"\"\n    Solves the problem by reconstructing the angular flux from moments\n    for a series of test cases and checking for positivity.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test 1: Isotropic positive reference\n        [1.0, 0.0, 0.0, 0.0],\n        # Test 2: Strong first-moment anisotropy\n        [1.0, 0.6, 0.0, 0.0],\n        # Test 3: Linearly anisotropic but positive underlying distribution\n        [1.4, 0.37333333333333335, 0.0, 0.0],\n        # Test 4: Even anisotropy via P2 component\n        [1.8, 0.0, 0.54, 0.0],\n        # Test 5: Boundary-linear case\n        [1.0, 0.3333333333333333, 0.0, 0.0],\n        # Test 6: Non-realizable moment set with zero scalar flux\n        [0.0, 0.3, 0.0, 0.0],\n        # Test 7: Mixed higher-order anisotropy\n        [1.0, 0.2, 0.1, -0.05],\n    ]\n\n    def check_positivity_for_moments(moments, M=1001, N=3):\n        \"\"\"\n        Reconstructs the P3-approximated angular flux from Legendre moments\n        and checks if it is non-negative over the angular domain.\n\n        Args:\n            moments (list or np.ndarray): A list of Legendre moments [phi_0, phi_1, phi_2, phi_3].\n            M (int): The number of points in the uniform angular grid.\n            N (int): The order of the P_N approximation.\n\n        Returns:\n            bool: True if the minimum of the reconstructed flux is >= 0.0, False otherwise.\n        \"\"\"\n        # Create a uniform grid of M points for the direction cosine mu in [-1, 1].\n        mu_grid = np.linspace(-1.0, 1.0, M)\n        \n        # Initialize the reconstructed flux array.\n        psi_N = np.zeros_like(mu_grid)\n        \n        # The reconstruction formula is:\n        # psi_N(mu) = sum_{l=0 to N} (2*l + 1) / 2 * phi_l * P_l(mu)\n        for l in range(N + 1):\n            # Get the Legendre polynomial of order l.\n            # scipy.special.legendre(l) returns a callable poly1d object.\n            P_l = legendre(l)\n            phi_l = moments[l]\n            psi_N += (2 * l + 1) / 2.0 * phi_l * P_l(mu_grid)\n            \n        # Find the minimum value of the reconstructed flux on the grid.\n        min_psi = np.min(psi_N)\n        \n        # Return True if the minimum value is non-negative, False otherwise.\n        # A small tolerance is not used as per problem specification.\n        return min_psi >= 0.0\n\n    results = []\n    for case in test_cases:\n        is_positive = check_positivity_for_moments(case)\n        results.append(is_positive)\n\n    # Final print statement in the exact required format \"[True,False,True,...]\".\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "In practical applications, choosing the approximation order $N$ involves a trade-off between accuracy and computational cost. This exercise provides a quantitative approach to making this decision. Using a hypothetical but instructive model for the decay of angular moments, you will derive and implement a formula to estimate the minimum $P_n$ order required to achieve a specified error tolerance in the scalar flux. This practice illuminates the convergence behavior of the $P_n$ method and its dependence on the smoothness of the underlying angular flux. ",
            "id": "4256628",
            "problem": "Consider the steady-state, monoenergetic, one-dimensional slab formulation of the linear Boltzmann transport equation, in a homogeneous medium with constant total cross section and no spatial variation in material properties. The angular flux is denoted by $\\psi(x,\\mu)$, where $x$ is the spatial coordinate and $\\mu\\in[-1,1]$ is the cosine of the polar angle. The scalar flux is defined as the angular integral $\\phi(x)=\\int_{-1}^{1}\\psi(x,\\mu)\\,d\\mu$. In a Spherical Harmonics approximation of order $N$ (the $P_{N}$ approximation), the angular flux is represented by a finite series in Legendre polynomials, equivalently by the angular moments up to degree $N$.\n\nAssume a manufactured exact angular solution whose Legendre (spherical harmonics in one-dimensional slab) moments satisfy a known algebraic decay $|\\psi_{\\ell}(x)|=C\\,\\ell^{-p}$ for all integers $\\ell\\ge 1$, with constants $C>0$ and $p>0$ independent of $x$. Assume further that the $P_{N}$ closure is the standard zero closure at $\\ell=N+1$ and that the resulting scalar flux error at any $x$ admits a stability bound of the form\n$$\n\\left|\\phi(x)-\\phi^{(N)}(x)\\right|\\le \\kappa\\,\\left|\\psi_{N+1}(x)\\right|,\n$$\nwhere $\\phi^{(N)}(x)$ is the scalar flux produced by the $P_{N}$ approximation and $\\kappa>0$ is a coupling constant reflecting the strength of near-neighbor streaming/scattering couplings in the moment system. This bound is consistent with the tridiagonal recurrence structure of the Legendre moment transport equations in one-dimensional slab geometry.\n\nYour task is to write a complete, runnable program that, given $(p,C,\\epsilon,\\kappa)$ for several test cases, computes the smallest nonnegative integer $N$ such that the above error bound guarantees that the absolute scalar flux error does not exceed a target accuracy $\\epsilon>0$ everywhere (spatial dependence is immaterial here because the bound is uniform in $x$ under the manufactured solutionâ€™s assumptions). If no finite $N$ can guarantee the target accuracy under the stated decay model (for instance, if $p\\le 0$ so that the first neglected moment does not decay), the program must return $-1$ for that test case.\n\nStarting only from the following foundational bases:\n- The definition of the scalar flux $\\phi(x)=\\int_{-1}^{1}\\psi(x,\\mu)\\,d\\mu$.\n- The Spherical Harmonics ($P_{N}$) representation of $\\psi$ as a series of angular moments.\n- The manufactured angular moment decay $|\\psi_{\\ell}|=C\\,\\ell^{-p}$.\n- The stability bound $\\left|\\phi-\\phi^{(N)}\\right|\\le \\kappa\\,\\left|\\psi_{N+1}\\right|$ implied by the tridiagonal moment couplings under zero closure at $\\ell=N+1$.\n\nDerive from first principles how to determine the minimal $N$ in terms of $(p,C,\\epsilon,\\kappa)$. Implement your derived method in code, and for each test case compute the required $N$. The program must be purely mathematical and logical; there are no physical units required in this problem.\n\nTest Suite:\n- Case $1$: $p=3$, $C=1$, $\\kappa=1$, $\\epsilon=10^{-3}$.\n- Case $2$: $p=2.1$, $C=1$, $\\kappa=1$, $\\epsilon=10^{-6}$.\n- Case $3$: $p=5$, $C=2$, $\\kappa=0.5$, $\\epsilon=10^{-6}$.\n- Case $4$: $p=0$, $C=1$, $\\kappa=1$, $\\epsilon=10^{-4}$.\n- Case $5$: $p=10$, $C=1$, $\\kappa=1$, $\\epsilon=10^{-12}$.\n\nAnswer Specification:\n- For each test case, output a single integer: the smallest $N\\in\\{0,1,2,\\dots\\}$ satisfying the derived condition, or $-1$ if impossible under the given parameters.\n- The final output must be a single line containing a comma-separated list of the five integers enclosed in square brackets, in the same order as the test suite (for example, $[n_{1},n_{2},n_{3},n_{4},n_{5}]$).",
            "solution": "The problem requires finding the smallest non-negative integer order $N$ of a $P_N$ approximation such that the absolute error in the scalar flux, $|\\phi(x) - \\phi^{(N)}(x)|$, is guaranteed to be no greater than a specified tolerance $\\epsilon$. The derivation proceeds from the given first principles.\n\nThe condition to be satisfied is:\n$$\n\\left|\\phi(x)-\\phi^{(N)}(x)\\right| \\le \\epsilon\n$$\nfor a given tolerance $\\epsilon > 0$.\n\nThe problem provides a stability bound that relates the scalar flux error to the first neglected Legendre moment of the angular flux, $\\psi_{N+1}(x)$:\n$$\n\\left|\\phi(x)-\\phi^{(N)}(x)\\right| \\le \\kappa\\,\\left|\\psi_{N+1}(x)\\right|\n$$\nwhere $\\kappa > 0$ is a known constant. To ensure our error condition is met, it is sufficient to require that the upper bound also satisfies the condition:\n$$\n\\kappa\\,\\left|\\psi_{N+1}(x)\\right| \\le \\epsilon\n$$\n\nWe are given a model for the magnitude of the angular moments of a manufactured solution, which states that for any integer $\\ell \\ge 1$, the moments decay algebraically:\n$$\n\\left|\\psi_{\\ell}(x)\\right| = C\\,\\ell^{-p}\n$$\nThe constants $C > 0$ and $p > 0$ are given and are independent of the spatial variable $x$. This uniformity in $x$ allows us to treat the inequality without spatial dependence. We can find the magnitude of the first neglected moment, $\\psi_{N+1}$, by setting $\\ell = N+1$:\n$$\n\\left|\\psi_{N+1}(x)\\right| = C\\,(N+1)^{-p}\n$$\nThis holds for $N+1 \\ge 1$, which is true for any non-negative integer $N$.\n\nSubstituting this expression back into our sufficiency condition yields an inequality for the required approximation order $N$:\n$$\n\\kappa\\,C\\,(N+1)^{-p} \\le \\epsilon\n$$\nOur task is to find the smallest non-negative integer $N$ that satisfies this inequality for the given parameters $(p, C, \\kappa, \\epsilon)$.\n\nWe must first analyze the role of the decay parameter $p$. The problem states that if no finite $N$ can guarantee the target accuracy (e.g., if $p \\le 0$ such that the moment does not decay), the result should be $-1$. Let us examine this case.\nIf $p = 0$, the inequality becomes $\\kappa\\,C \\le \\epsilon$. The left-hand side is a constant value. If this condition is false, no value of $N$ can ever satisfy the inequality. If $p < 0$, let $p' = -p > 0$. The inequality becomes $\\kappa\\,C\\,(N+1)^{p'} \\le \\epsilon$. In this case, the left-hand side is an increasing function of $N$. If the accuracy requirement is not met for $N=0$, it will certainly not be met for any larger $N$. Therefore, for any $p \\le 0$, the error bound does not necessarily decrease as $N$ increases, and thus convergence to an arbitrarily small $\\epsilon$ cannot be guaranteed. Conforming to the problem's specification, for any case where $p \\le 0$, the required order is undefined, and we must report $-1$.\n\nNow, let us consider the primary case where $p > 0$. All parameters $\\kappa, C, \\epsilon, p$ are positive real numbers. We can algebraically solve the inequality for $N$:\n$$\n\\kappa\\,C\\,(N+1)^{-p} \\le \\epsilon\n$$\nDividing by $\\kappa\\,C$ (which is positive):\n$$\n(N+1)^{-p} \\le \\frac{\\epsilon}{\\kappa C}\n$$\nTaking the reciprocal of both sides reverses the inequality sign as both sides are positive:\n$$\n(N+1)^p \\ge \\frac{\\kappa C}{\\epsilon}\n$$\nTaking the $p$-th root of both sides (a monotonic operation for positive bases):\n$$\nN+1 \\ge \\left(\\frac{\\kappa C}{\\epsilon}\\right)^{1/p}\n$$\nFinally, isolating $N$:\n$$\nN \\ge \\left(\\frac{\\kappa C}{\\epsilon}\\right)^{1/p} - 1\n$$\nThis inequality provides a lower bound for $N$. We are seeking the smallest non-negative integer $N$ that satisfies this condition. Let $N_{min} = \\left(\\frac{\\kappa C}{\\epsilon}\\right)^{1/p} - 1$. The smallest integer $N$ satisfying $N \\ge N_{min}$ is given by the ceiling function, $\\lceil N_{min} \\rceil$. However, the order of approximation $N$ cannot be negative, so it must be a non-negative integer, i.e., $N \\in \\{0, 1, 2, \\dots\\}$. Therefore, the final answer is the greater of $0$ and $\\lceil N_{min} \\rceil$.\nThis can be expressed as:\n$$\nN = \\max\\left(0, \\left\\lceil \\left(\\frac{\\kappa C}{\\epsilon}\\right)^{1/p} - 1 \\right\\rceil\\right)\n$$\nThis formula correctly handles the case where the right-hand side is negative (implying $N=0$ is sufficient) and ensures the result is a non-negative integer.\n\nIn summary, the algorithm is:\n1.  Given parameters $(p, C, \\kappa, \\epsilon)$.\n2.  If $p \\le 0$, the required $N$ is $-1$.\n3.  If $p > 0$, compute $N_{min} = \\left(\\frac{\\kappa C}{\\epsilon}\\right)^{1/p} - 1$.\n4.  The result is the smallest non-negative integer $N$ such that $N \\ge N_{min}$, which is calculated as $\\max(0, \\lceil N_{min} \\rceil)$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem for a suite of test cases, calculating the minimum\n    P_N order N required to meet a given error tolerance.\n    \"\"\"\n\n    # Test cases are provided as tuples of (p, C, kappa, epsilon).\n    test_cases = [\n        (3, 1, 1, 1e-3),    # Case 1\n        (2.1, 1, 1, 1e-6),  # Case 2\n        (5, 2, 0.5, 1e-6),  # Case 3\n        (0, 1, 1, 1e-4),    # Case 4\n        (10, 1, 1, 1e-12),  # Case 5\n    ]\n\n    results = []\n    for case in test_cases:\n        p, C, kappa, epsilon = case\n        result = compute_required_N(p, C, kappa, epsilon)\n        results.append(result)\n\n    # The final output must be a single line containing a comma-separated\n    # list of the five integers enclosed in square brackets.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef compute_required_N(p, C, kappa, epsilon):\n    \"\"\"\n    Calculates the smallest non-negative integer N based on the derived formula.\n\n    The problem requires finding the smallest non-negative integer N such that:\n    kappa * C * (N + 1)**(-p) <= epsilon\n\n    Args:\n        p (float): The decay exponent of the angular moments.\n        C (float): The decay coefficient of the angular moments.\n        kappa (float): The stability coupling constant.\n        epsilon (float): The target absolute error tolerance.\n\n    Returns:\n        int: The smallest non-negative integer N, or -1 if no such N exists.\n    \"\"\"\n    # According to the problem statement and derivation, if p <= 0, the\n    # error bound does not necessarily decay with N, so convergence to an\n    # arbitrary epsilon is not guaranteed. In this case, we return -1.\n    if p <= 0:\n        return -1\n\n    # For p > 0, we solve the inequality for N:\n    # (N + 1)**p >= (kappa * C) / epsilon\n    # N + 1 >= ((kappa * C) / epsilon)**(1/p)\n    # N >= ((kappa * C) / epsilon)**(1/p) - 1\n\n    # Calculate the lower bound for N.\n    # Note: All parameters kappa, C, epsilon are given as positive.\n    n_lower_bound = (kappa * C / epsilon)**(1 / p) - 1\n\n    # The required N must be an integer. The smallest integer satisfying\n    # N >= n_lower_bound is the ceiling of n_lower_bound.\n    # We use np.ceil for this calculation.\n    n_integer = np.ceil(n_lower_bound)\n\n    # The order N must also be non-negative. If the calculated integer value\n    # is negative, it means that even N=0 already satisfies the condition.\n    # The smallest non-negative integer is thus max(0, n_integer).\n    required_n = int(max(0, n_integer))\n\n    return required_n\n\n# Execute the main solver function.\nsolve()\n```"
        }
    ]
}