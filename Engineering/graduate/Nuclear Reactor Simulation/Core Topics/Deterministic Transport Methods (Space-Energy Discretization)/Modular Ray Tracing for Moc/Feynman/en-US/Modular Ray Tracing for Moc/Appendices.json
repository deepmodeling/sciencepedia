{
    "hands_on_practices": [
        {
            "introduction": "The foundation of the Method of Characteristics (MOC) is the set of rays or 'tracks' used to discretize the transport equation. The quality of the MOC solution is highly sensitive to how these tracks are generated, as a poorly constructed set can introduce systematic biases. This first exercise  explores the critical task of creating a canonical track set for a periodic lattice, focusing on a sophisticated technique to prevent numerical bias by staggering the tracks to avoid systematic alignment with geometric features.",
            "id": "4236041",
            "problem": "Consider a two-dimensional square-lattice fuel assembly composed of $I \\times J$ identical pin cells of pitch $a$, occupying the rectangular domain $\\Omega = [0, L_x] \\times [0, L_y]$ with $L_x = I a$ and $L_y = J a$. The Method of Characteristics (MOC) formulates the steady-state neutron transport along straight characteristic lines with prescribed azimuthal angles $\\varphi_m$ and uniform normal spacing $\\Delta$ between parallel tracks. Assume periodic boundary conditions on $\\partial \\Omega$ and the intent to perform modular ray tracing, whereby track segments through identical pin-cell modules are reused.\n\nA canonical track set must be defined for each azimuthal angle $\\varphi_m$ that:\n\n- respects the geometric definition of parallel characteristic lines for direction $\\varphi_m$,\n- uses a uniform spacing $\\Delta$ measured perpendicular to the tracks,\n- covers the entire domain under periodic boundary conditions without duplicate or missing coverage, and\n- avoids systematic alignment of tracks with pin-cell boundaries $x = n a$ or $y = n a$ (with $n \\in \\mathbb{Z}$), which could bias flux tallies when aggregating over tracks and angles.\n\nWhich option below correctly specifies the family of characteristic tracks and a stagger rule for offsets that satisfies these requirements?\n\nA. For each angle $\\varphi_m$, define the unit direction $\\mathbf{s}_m = (\\cos \\varphi_m, \\sin \\varphi_m)$ and the unit normal $\\mathbf{n}_m = (-\\sin \\varphi_m, \\cos \\varphi_m)$. The family of parallel tracks is given by $\\mathbf{n}_m \\cdot \\mathbf{r} = b_m + k \\Delta$ for $\\mathbf{r} = (x,y)$ and $k \\in \\mathbb{Z}$ spanning the projection range of $\\Omega$ onto $\\mathbf{n}_m$, with periodic wrap-around at $\\partial \\Omega$. Choose a staggered offset $b_m = a \\{ m \\alpha \\}$, where $\\{ \\cdot \\}$ denotes the fractional part and $\\alpha$ is any irrational number (e.g., $\\alpha = (\\sqrt{5}-1)/2$), so that $b_m / a$ is irrational for all $m$ and offsets are equidistributed modulo $a$ across the angle set, preventing systematic alignment with pin boundaries.\n\nB. For each angle $\\varphi_m$, define the track family by $\\mathbf{s}_m \\cdot \\mathbf{r} = k \\Delta$ with $\\mathbf{s}_m = (\\cos \\varphi_m, \\sin \\varphi_m)$ and $k \\in \\mathbb{Z}$. Set $b_m = 0$ for all $m$ to preserve symmetry, and rely on periodic boundary conditions for coverage.\n\nC. For each angle $\\varphi_m$, use $\\mathbf{n}_m \\cdot \\mathbf{r} = k \\Delta$ with $\\mathbf{n}_m = (-\\sin \\varphi_m, \\cos \\varphi_m)$ and $k \\in \\mathbb{Z}$. To stagger, set $b_m = a/2$ for odd $m$ and $b_m = 0$ for even $m$, which alternates the track origins relative to the pin boundaries.\n\nD. For each angle $\\varphi_m$, define $\\mathbf{n}_m \\cdot \\mathbf{r} = b_m + k \\Delta$ with $\\mathbf{n}_m = (-\\sin \\varphi_m, \\cos \\varphi_m)$ and $k \\in \\mathbb{Z}$. Choose $b_m = r_m \\Delta$, where $r_m \\in \\mathbb{Z}$ is an integer index depending on $m$, to ensure offsets are integer multiples of the spacing $\\Delta$ for consistency across angles.\n\nAnswer by selecting the correct option and justify which construction satisfies the geometric and statistical requirements for unbiased flux tallies under periodic boundary conditions in modular ray tracing for MOC, starting from the characteristic-line formulation and basic sampling principles of equidistribution on the lattice.",
            "solution": "The problem asks for a correct specification of characteristic tracks for the Method of Characteristics (MOC) in a two-dimensional domain with a periodic square lattice of pitch $a$. The specification must satisfy four requirements: correct geometric definition, uniform track spacing, complete coverage under periodic boundary conditions, and avoidance of systematic alignment with the lattice to prevent numerical bias.\n\nFirst, let us establish the mathematical representation of a family of parallel tracks. A direction of motion is given by the unit vector $\\mathbf{s}_m = (\\cos \\varphi_m, \\sin \\varphi_m)$ for an azimuthal angle $\\varphi_m$. The characteristic tracks are lines parallel to this direction. A line is defined by all points $\\mathbf{r} = (x,y)$ whose projection onto the line's normal vector is constant. A unit vector normal to $\\mathbf{s}_m$ is $\\mathbf{n}_m = (-\\sin \\varphi_m, \\cos \\varphi_m)$. Therefore, a single track is described by the equation $\\mathbf{n}_m \\cdot \\mathbf{r} = d$, where $d$ is the signed perpendicular distance from the origin to the track.\n\nTo satisfy the first two requirements—a family of parallel lines with uniform normal spacing $\\Delta$—the distances $d$ must form an arithmetic progression with step $\\Delta$. This can be expressed as $\\mathbf{n}_m \\cdot \\mathbf{r} = b_m + k \\Delta$ for an integer index $k \\in \\mathbb{Z}$. Here, $b_m$ is a base offset for the entire family of tracks corresponding to angle $\\varphi_m$.\n\nThe third requirement is complete coverage of the domain $\\Omega = [0, L_x] \\times [0, L_y]$ under periodic boundary conditions. The formulation $\\mathbf{n}_m \\cdot \\mathbf{r} = b_m + k \\Delta$ combined with periodic wrap-around of tracks exiting $\\partial\\Omega$ is the standard construction that ensures this coverage. The number of tracks and the range of $k$ are chosen to tile the domain, but the fundamental track definition is sound.\n\nThe fourth and most critical requirement is the avoidance of systematic alignment with the pin-cell boundaries, which are located at $x=na$ and $y=na$ for integers $n$. If, for many angles, the tracks are always in the same relative positions within the pin cells (e.g., always through the center, or always along the edges), the resulting volume-averaged flux tallies will be biased. This numerical artifact is a form of the ray effect. To mitigate this, the track positions relative to the pin-cell lattice must be varied across the set of discrete angles. This is achieved by carefully choosing the angle-dependent offset, $b_m$. The sequence of offsets $b_m$ should ideally distribute the tracks as uniformly as possible modulo the lattice pitch $a$.\n\nWith this theoretical framework, we can now evaluate each option.\n\n**Option A:**\n- **Track Family Definition**: The tracks are defined by $\\mathbf{n}_m \\cdot \\mathbf{r} = b_m + k \\Delta$ with $\\mathbf{n}_m = (-\\sin \\varphi_m, \\cos \\varphi_m)$. This is the correct geometric formulation for a family of parallel lines with uniform normal spacing $\\Delta$.\n- **Stagger Rule**: The offset is chosen as $b_m = a \\{ m \\alpha \\}$, where $\\{ \\cdot \\}$ is the fractional part and $\\alpha$ is an irrational number. This is a sophisticated and statistically robust method. According to Weyl's criterion, the sequence $x_m = \\{ m \\alpha \\}$ for $m=1, 2, 3, \\ldots$ is equidistributed in the interval $[0, 1)$ if $\\alpha$ is irrational. This means that as we consider more angles in our quadrature set, the normalized offsets $b_m/a$ will uniformly cover the interval $[0, 1)$. Consequently, the track families are uniformly shifted relative to the pin-cell lattice, effectively eliminating systematic alignment and the associated bias. This is a quasi-Monte Carlo approach that provides excellent statistical properties for the track sampling. The golden ratio, $\\alpha = (\\sqrt{5}-1)/2$, is a common choice for its excellent distribution properties. This method satisfies all four requirements.\n- **Verdict**: **Correct**.\n\n**Option B:**\n- **Track Family Definition**: The tracks are defined by $\\mathbf{s}_m \\cdot \\mathbf{r} = k \\Delta$. The vector $\\mathbf{s}_m = (\\cos \\varphi_m, \\sin \\varphi_m)$ is the direction of neutron travel. The equation $\\mathbf{s}_m \\cdot \\mathbf{r} = \\text{constant}$ defines a line *perpendicular* to the direction of travel, not parallel to it. This would represent a wavefront, not a particle trajectory or characteristic track. This formulation is geometrically incorrect for MOC.\n- **Stagger Rule**: It proposes $b_m = 0$ for all $m$, meaning no staggering. This is the worst-case scenario for bias, as it maximizes the potential for systematic alignment of tracks with the lattice, which is exactly what requirement 4 is intended to prevent.\n- **Verdict**: **Incorrect**.\n\n**Option C:**\n- **Track Family Definition**: The formulation $\\mathbf{n}_m \\cdot \\mathbf{r} = k \\Delta$ is stated, which implies $b_m=0$, but the stagger rule then contradicts this. Assuming the intended formulation is $\\mathbf{n}_m \\cdot \\mathbf{r} = b_m + k \\Delta$.\n- **Stagger Rule**: The offset is set to $b_m=a/2$ for odd $m$ and $b_m=0$ for even $m$. This introduces a minimal, deterministic staggering. While it is better than no staggering at all, it is a very weak scheme. The tracks are only ever in one of two positions relative to the cell lattice origin. This is still a highly systematic pattern and does not guarantee the avoidance of bias. For certain combinations of angles and lattice geometries, this simple alternation can still lead to significant statistical correlations and biased results. It does not provide the uniform \"sweeping\" of the cell that a more random-like sequence would.\n- **Verdict**: **Incorrect**.\n\n**Option D:**\n- **Track Family Definition**: The form $\\mathbf{n}_m \\cdot \\mathbf{r} = b_m + k \\Delta$ is correct.\n- **Stagger Rule**: The offset is chosen as $b_m = r_m \\Delta$, where $r_m$ is an integer. Let's analyze the set of track positions. The line equations are $y \\cos \\varphi_m - x \\sin \\varphi_m = r_m \\Delta + k \\Delta$. Since both $r_m$ and $k$ are integers, their sum $k' = r_m + k$ is also an integer that spans $\\mathbb{Z}$. Thus, the set of lines is $\\{ \\mathbf{r} | \\mathbf{n}_m \\cdot \\mathbf{r} = k' \\Delta, k' \\in \\mathbb{Z} \\}$. This is exactly the same set of lines as if we had chosen the offset $b_m=0$. Shifting the entire family of equally-spaced parallel lines by an integer multiple of their spacing results in the very same family of lines. Therefore, this \"stagger rule\" has no effect whatsoever and is equivalent to having no staggering.\n- **Verdict**: **Incorrect**.\n\nIn conclusion, Option A is the only one that presents a geometrically correct formulation for the characteristic tracks and couples it with a statistically sound and effective staggering strategy based on equidistribution theory to satisfy all the stated requirements for an unbiased modular MOC calculation.",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "Once a set of characteristic rays is established, the next step is to perform the transport sweep: integrating the Boltzmann equation along each ray to calculate the neutron flux. This hands-on coding exercise  guides you through a simplified MOC calculation for a single pin cell, demonstrating how path lengths through different materials are used to solve for the angular flux. By implementing the core MOC formulas, you will directly observe how the level of angular discretization, a key user-defined parameter, impacts the accuracy of the computed scalar flux.",
            "id": "4236063",
            "problem": "Consider a two-dimensional steady-state neutron transport problem in a single pin cell modeled as a square of side length $P$ (in $\\mathrm{cm}$) centered at the origin, containing a circular fuel region of radius $R_f$ (in $\\mathrm{cm}$) centered at the origin and surrounded by moderator. The angular neutron flux $\\psi(\\mathbf{r}, \\varphi)$ satisfies the steady-state linear Boltzmann transport equation along straight characteristics,\n$$\n\\frac{d \\psi(s)}{d s} + \\Sigma_t \\, \\psi(s) = q,\n$$\nwhere $s$ is the path length along a characteristic ray, $\\Sigma_t$ is the total macroscopic cross section (in $\\mathrm{cm}^{-1}$) of the region traversed by the ray segment, and $q$ is an isotropic, homogeneous volumetric neutron source (in $\\mathrm{neutrons} \\cdot \\mathrm{cm}^{-3} \\cdot \\mathrm{s}^{-1}$) in that region. The boundary condition at the square boundary is vacuum, i.e., $\\psi = 0$ for incoming directions at the boundary. Assume two regions: fuel with parameters $(\\Sigma_{t,f}, q_f)$ and moderator with parameters $(\\Sigma_{t,m}, q_m)$, both homogeneous and isotropic within their respective subdomains.\n\nUnder the Method of Characteristics (MOC), the solution along a straight ray entering from vacuum traversing a piecewise homogeneous medium is obtained by successive application of the one-dimensional exponential attenuation solution. For a ray that enters the square boundary and passes through the moderator for a path length $s_m(\\varphi)$ and then the fuel for a path length $s_f(\\varphi)$ (all lengths in $\\mathrm{cm}$), the angular flux at the point of interest (the cell center at $\\mathbf{r} = \\mathbf{0}$) in direction $\\varphi$ (angle in radians) is\n$$\n\\psi(\\mathbf{0}, \\varphi) = \\left( \\frac{q_m}{\\Sigma_{t,m}} \\left[ 1 - e^{-\\Sigma_{t,m} s_m(\\varphi)} \\right] \\right) e^{-\\Sigma_{t,f} s_f(\\varphi)} + \\frac{q_f}{\\Sigma_{t,f}} \\left[ 1 - e^{-\\Sigma_{t,f} s_f(\\varphi)} \\right].\n$$\nIn this geometry, the ray passing through the center and directed at azimuth $\\varphi$ first traverses the fuel for a path length $s_f(\\varphi) = R_f$ (in $\\mathrm{cm}$, independent of $\\varphi$ due to circular symmetry), after which it traverses the moderator until it reaches the square boundary. The moderator path length $s_m(\\varphi)$ (in $\\mathrm{cm}$) is the distance along the line from the fuel-moderator interface point $\\mathbf{r}_b = R_f (\\cos \\varphi, \\sin \\varphi)$ to the square boundary $x = \\pm P/2$ or $y = \\pm P/2$, whichever is intercepted first, computed along direction $\\mathbf{n}(\\varphi) = (\\cos \\varphi, \\sin \\varphi)$. Specifically, if $n_x = \\cos \\varphi$ and $n_y = \\sin \\varphi$, then\n$$\nt_x(\\varphi) = \n\\begin{cases}\n\\frac{\\frac{P}{2} - R_f \\cos \\varphi}{\\cos \\varphi}, & \\text{if } \\cos \\varphi > 0, \\\\\n\\frac{-\\frac{P}{2} - R_f \\cos \\varphi}{\\cos \\varphi}, & \\text{if } \\cos \\varphi < 0, \\\\\n+\\infty, & \\text{if } \\cos \\varphi = 0,\n\\end{cases}\n\\quad\nt_y(\\varphi) = \n\\begin{cases}\n\\frac{\\frac{P}{2} - R_f \\sin \\varphi}{\\sin \\varphi}, & \\text{if } \\sin \\varphi > 0, \\\\\n\\frac{-\\frac{P}{2} - R_f \\sin \\varphi}{\\sin \\varphi}, & \\text{if } \\sin \\varphi < 0, \\\\\n+\\infty, & \\text{if } \\sin \\varphi = 0,\n\\end{cases}\n$$\nand\n$$\ns_m(\\varphi) = \\min \\left( t_x(\\varphi), \\, t_y(\\varphi) \\right).\n$$\n\nDefine the azimuthally averaged scalar flux at the center as the average of $\\psi(\\mathbf{0}, \\varphi)$ over the full azimuthal range,\n$$\n\\phi = \\frac{1}{2\\pi} \\int_{0}^{2\\pi} \\psi(\\mathbf{0}, \\varphi) \\, d\\varphi,\n$$\nwith angle $\\varphi$ expressed in radians.\n\nYour task is to implement a modular ray-tracing program for this geometry that:\n- Computes $s_m(\\varphi)$ using geometry functions,\n- Computes $\\psi(\\mathbf{0}, \\varphi)$ using the piecewise-homogeneous Method of Characteristics formulation,\n- Approximates the azimuthal integral with a discrete uniform midpoint rule using $N_\\varphi$ equi-spaced azimuthal angles,\n$$\n\\phi_{N_\\varphi} = \\frac{1}{N_\\varphi} \\sum_{k=0}^{N_\\varphi-1} \\psi\\!\\left(\\mathbf{0}, \\varphi_k\\right),\n\\quad \\text{where} \\quad \\varphi_k = \\frac{2\\pi}{N_\\varphi}\\left(k+\\frac{1}{2}\\right).\n$$\n\nCompare the results for $N_\\varphi = 4$ and $N_\\varphi = 8$ to a reference obtained with a high-order quadrature ($N_\\varphi = N_{\\mathrm{ref}}$) and report the relative error,\n$$\n\\varepsilon(N_\\varphi) = \\left| \\frac{\\phi_{N_\\varphi} - \\phi_{N_{\\mathrm{ref}}}}{\\phi_{N_{\\mathrm{ref}}}} \\right|.\n$$\n\nAngles must be handled in radians. All lengths must be in $\\mathrm{cm}$, cross sections in $\\mathrm{cm}^{-1}$, sources in $\\mathrm{neutrons} \\cdot \\mathrm{cm}^{-3} \\cdot \\mathrm{s}^{-1}$. The scalar flux here is the azimuthal average of the angular flux and its magnitude should be understood in $\\mathrm{neutrons} \\cdot \\mathrm{cm}^{-2} \\cdot \\mathrm{s}^{-1}$ per unit azimuth.\n\nImplement the program to evaluate the following test suite of pin cell configurations, each defined by $(P, R_f, \\Sigma_{t,f}, q_f, \\Sigma_{t,m}, q_m)$:\n- Test Case 1 (typical geometry, moderately absorbing fuel, weakly absorbing moderator): $(P = 1.26, \\, R_f = 0.54, \\, \\Sigma_{t,f} = 0.8, \\, q_f = 1.0, \\, \\Sigma_{t,m} = 0.2, \\, q_m = 0.1)$.\n- Test Case 2 (large fuel radius, strongly absorbing fuel, very weakly absorbing moderator): $(P = 1.26, \\, R_f = 0.62, \\, \\Sigma_{t,f} = 1.5, \\, q_f = 1.0, \\, \\Sigma_{t,m} = 0.05, \\, q_m = 0.02)$.\n- Test Case 3 (small fuel radius, weakly absorbing fuel, strongly absorbing moderator): $(P = 1.26, \\, R_f = 0.40, \\, \\Sigma_{t,f} = 0.2, \\, q_f = 1.0, \\, \\Sigma_{t,m} = 2.0, \\, q_m = 0.2)$.\n\nUse $N_{\\mathrm{ref}} = 4096$ for the reference quadrature to approximate the azimuthal integral.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case contributes a two-element list $[\\varepsilon(4), \\varepsilon(8)]$ with no spaces. For example, the output format should be:\n$$\n\\texttt{[[e1\\_4,e1\\_8],[e2\\_4,e2\\_8],[e3\\_4,e3\\_8]]}\n$$\nwhere each $e\\_i\\_N$ is a decimal number (in plain float notation).",
            "solution": "The problem has been validated and is deemed to be scientifically grounded, well-posed, and objective. It presents a standard problem in nuclear reactor physics—calculating the neutron flux in a pin cell using the Method of Characteristics (MOC)—with all necessary physical parameters, mathematical formulas, and computational requirements clearly defined. The problem is free of contradictions, ambiguities, or factual unsoundness. Therefore, a solution can be derived.\n\nThe solution involves implementing a numerical algorithm to calculate the azimuthally averaged scalar neutron flux at the center of a two-dimensional square pin cell. This is achieved by first computing the angular flux $\\psi(\\mathbf{0}, \\varphi)$ for a discrete set of azimuthal angles $\\varphi$ and then averaging these values. The core of the task is to implement the MOC formulation for a ray arriving at the cell center, which requires calculating geometric path lengths and applying the analytical solution to the one-dimensional transport equation.\n\nThe overall process can be decomposed into four main steps:\n1.  Calculation of the moderator path length, $s_m(\\varphi)$.\n2.  Calculation of the angular flux at the center, $\\psi(\\mathbf{0}, \\varphi)$.\n3.  Numerical approximation of the azimuthally averaged scalar flux, $\\phi$.\n4.  Computation of the relative error against a high-fidelity reference value.\n\n**Step 1: Moderator Path Length Calculation**\n\nThe problem provides the geometry for calculating the path length $s_m(\\varphi)$ of a ray traversing the moderator before entering the fuel region to arrive at the cell center. To calculate the angular flux $\\psi(\\mathbf{0}, \\varphi)$ at the origin in direction $\\varphi$, we trace the characteristic line backward from the origin. This is equivalent to tracing a ray forward from the boundary, passing through the moderator, then the fuel, and terminating at the origin.\n\nThe path length in the fuel, $s_f(\\varphi)$, is simply the fuel radius $R_f$, due to the circular fuel region being centered at the origin. The path length in the moderator, $s_m(\\varphi)$, is the distance from the square boundary to the fuel-moderator interface along the ray's path. This distance is a function of the angle $\\varphi$.\n\nThe problem defines $s_m(\\varphi)$ as the distance from a point on the fuel boundary, $\\mathbf{r}_b = R_f (\\cos \\varphi, \\sin \\varphi)$, to the square cell boundary ($x = \\pm P/2$ or $y = \\pm P/2$) along the outward direction $\\mathbf{n}(\\varphi) = (\\cos \\varphi, \\sin \\varphi)$. This is geometrically equivalent to the required moderator path length for an incoming ray.\n\nLet $n_x = \\cos \\varphi$ and $n_y = \\sin \\varphi$. The path lengths to the vertical ($x=\\pm P/2$) and horizontal ($y=\\pm P/2$) boundaries, denoted $t_x(\\varphi)$ and $t_y(\\varphi)$ respectively, are given by:\n$$\nt_x(\\varphi) = \n\\begin{cases}\n\\frac{P/2 - R_f n_x}{n_x} & \\text{if } n_x > 0 \\\\\n\\frac{-P/2 - R_f n_x}{n_x} & \\text{if } n_x < 0 \\\\\n+\\infty & \\text{if } n_x = 0\n\\end{cases}\n$$\n$$\nt_y(\\varphi) = \n\\begin{cases}\n\\frac{P/2 - R_f n_y}{n_y} & \\text{if } n_y > 0 \\\\\n\\frac{-P/2 - R_f n_y}{n_y} & \\text{if } n_y < 0 \\\\\n+\\infty & \\text{if } n_y = 0\n\\end{cases}\n$$\nThe ray terminates at the first boundary it intersects, so the moderator path length is the minimum of these two values:\n$$\ns_m(\\varphi) = \\min(t_x(\\varphi), t_y(\\varphi))\n$$\nIn implementation, cases where $n_x$ or $n_y$ are very close to zero must be handled carefully to avoid division by zero, for which the path length is effectively infinite.\n\n**Step 2: Angular Flux Calculation**\n\nThe angular flux $\\psi(\\mathbf{0}, \\varphi)$ at the center is found by integrating the transport equation along the characteristic line ending at $\\mathbf{r}=\\mathbf{0}$. Given a vacuum boundary condition ($\\psi=0$ for incoming rays), the solution is built up by considering the source contributions from each homogeneous region, attenuated by the material they traverse.\nA ray arriving at the center from direction $\\varphi$ first traverses a length $s_m(\\varphi)$ of moderator and then a length $s_f = R_f$ of fuel.\n\nThe flux entering the fuel region, after traversing the moderator, is:\n$$\n\\psi_{\\text{mod} \\to \\text{fuel}} = \\frac{q_m}{\\Sigma_{t,m}} \\left( 1 - e^{-\\Sigma_{t,m} s_m(\\varphi)} \\right)\n$$\nThis is because the incoming flux at the cell boundary is zero. This flux is then attenuated as it crosses the fuel region over a distance $s_f$. The contribution to the final flux from the moderator source is:\n$$\n\\psi_{\\text{contrib, m}} = \\psi_{\\text{mod} \\to \\text{fuel}} \\cdot e^{-\\Sigma_{t,f} s_f} = \\frac{q_m}{\\Sigma_{t,m}} \\left( 1 - e^{-\\Sigma_{t,m} s_m(\\varphi)} \\right) e^{-\\Sigma_{t,f} s_f}\n$$\nAdditionally, there is a source contribution from within the fuel region itself, attenuated only by the fuel material:\n$$\n\\psi_{\\text{contrib, f}} = \\frac{q_f}{\\Sigma_{t,f}} \\left( 1 - e^{-\\Sigma_{t,f} s_f} \\right)\n$$\nThe total angular flux at the center is the sum of these two contributions, matching the formula provided in the problem statement:\n$$\n\\psi(\\mathbf{0}, \\varphi) = \\psi_{\\text{contrib, m}} + \\psi_{\\text{contrib, f}} = \\left( \\frac{q_m}{\\Sigma_{t,m}} \\left[ 1 - e^{-\\Sigma_{t,m} s_m(\\varphi)} \\right] \\right) e^{-\\Sigma_{t,f} s_f} + \\frac{q_f}{\\Sigma_{t,f}} \\left[ 1 - e^{-\\Sigma_{t,f} s_f} \\right]\n$$\nThis calculation is performed for each required angle $\\varphi$.\n\n**Step 3: Azimuthally Averaged Scalar Flux Approximation**\n\nThe azimuthally averaged scalar flux $\\phi$ is defined by the integral:\n$$\n\\phi = \\frac{1}{2\\pi} \\int_{0}^{2\\pi} \\psi(\\mathbf{0}, \\varphi) \\, d\\varphi\n$$\nWe are instructed to approximate this integral using a discrete sum based on the midpoint rule with $N_\\varphi$ equi-spaced angular intervals. The discrete angles are chosen at the midpoint of each interval:\n$$\n\\varphi_k = \\frac{2\\pi}{N_\\varphi}\\left(k+\\frac{1}{2}\\right) \\quad \\text{for} \\quad k = 0, 1, \\dots, N_\\varphi-1\n$$\nThe integral is then approximated as a sum. The term $d\\varphi$ is approximated by the constant angular width $\\Delta\\varphi = 2\\pi/N_\\varphi$.\n$$\n\\phi \\approx \\phi_{N_\\varphi} = \\frac{1}{2\\pi} \\sum_{k=0}^{N_\\varphi-1} \\psi(\\mathbf{0}, \\varphi_k) \\Delta\\varphi = \\frac{1}{2\\pi} \\sum_{k=0}^{N_\\varphi-1} \\psi(\\mathbf{0}, \\varphi_k) \\frac{2\\pi}{N_\\varphi} = \\frac{1}{N_\\varphi} \\sum_{k=0}^{N_\\varphi-1} \\psi(\\mathbf{0}, \\varphi_k)\n$$\nThis formula is implemented by generating the set of $N_\\varphi$ angles, calculating $\\psi(\\mathbf{0}, \\varphi_k)$ for each, summing the results, and dividing by $N_\\varphi$. This calculation must be performed for $N_\\varphi=4$, $N_\\varphi=8$, and the reference case $N_\\varphi=N_{\\text{ref}}=4096$.\n\n**Step 4: Relative Error Calculation**\n\nFinally, for each test case, we compute the relative error of the low-order approximations ($\\phi_4$ and $\\phi_8$) with respect to the high-fidelity reference solution $\\phi_{N_{\\text{ref}}}$. The relative error $\\varepsilon(N_\\varphi)$ is defined as:\n$$\n\\varepsilon(N_\\varphi) = \\left| \\frac{\\phi_{N_\\varphi} - \\phi_{N_{\\mathrm{ref}}}}{\\phi_{N_{\\mathrm{ref}}}} \\right|\n$$\nThe program calculates $\\varepsilon(4)$ and $\\varepsilon(8)$ for each of the three test suites of pin cell parameters provided. These error pairs are then formatted into the specified output string.\n\nThe implementation will follow a modular design, with separate functions for calculating $s_m(\\varphi)$, $\\psi(\\mathbf{0}, \\varphi)$, and $\\phi_{N_\\varphi}$ to ensure clarity and correctness.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_moderator_path_length(phi, P, R_f):\n    \"\"\"\n    Calculates the path length s_m(phi) in the moderator.\n\n    Args:\n        phi (float): Azimuthal angle in radians.\n        P (float): Side length of the square cell in cm.\n        R_f (float): Radius of the fuel region in cm.\n\n    Returns:\n        float: The moderator path length s_m in cm.\n    \"\"\"\n    nx = np.cos(phi)\n    ny = np.sin(phi)\n    \n    # Use a small tolerance to check for angles parallel to axes\n    tolerance = 1e-15\n\n    # Calculate path length to vertical boundaries (x = +/- P/2)\n    if abs(nx) < tolerance:\n        tx = np.inf\n    elif nx > 0:\n        tx = (P / 2.0 - R_f * nx) / nx\n    else: # nx < 0\n        tx = (-P / 2.0 - R_f * nx) / nx\n\n    # Calculate path length to horizontal boundaries (y = +/- P/2)\n    if abs(ny) < tolerance:\n        ty = np.inf\n    elif ny > 0:\n        ty = (P / 2.0 - R_f * ny) / ny\n    else: # ny < 0\n        ty = (-P / 2.0 - R_f * ny) / ny\n\n    return min(tx, ty)\n\ndef calculate_angular_flux(phi, params):\n    \"\"\"\n    Calculates the angular flux psi(0, phi) at the cell center.\n\n    Args:\n        phi (float): Azimuthal angle in radians.\n        params (tuple): A tuple containing the pin cell parameters\n                        (P, R_f, Sigma_tf, q_f, Sigma_tm, q_m).\n\n    Returns:\n        float: The angular flux psi(0, phi).\n    \"\"\"\n    P, R_f, Sigma_tf, q_f, Sigma_tm, q_m = params\n    \n    s_f = R_f\n    s_m = calculate_moderator_path_length(phi, P, R_f)\n\n    # Contribution from moderator source, attenuated through moderator and fuel\n    # Handle non-zero cross section case\n    if Sigma_tm > 0:\n        psi_contrib_m_source = (q_m / Sigma_tm) * (1.0 - np.exp(-Sigma_tm * s_m))\n    else: # Limit as Sigma_tm -> 0 is q_m * s_m\n        psi_contrib_m_source = q_m * s_m\n    \n    psi_contrib_m = psi_contrib_m_source * np.exp(-Sigma_tf * s_f)\n\n    # Contribution from fuel source, attenuated through fuel\n    if Sigma_tf > 0:\n        psi_contrib_f = (q_f / Sigma_tf) * (1.0 - np.exp(-Sigma_tf * s_f))\n    else: # Limit as Sigma_tf -> 0 is q_f * s_f\n        psi_contrib_f = q_f * s_f\n        \n    return psi_contrib_m + psi_contrib_f\n\ndef calculate_scalar_flux_avg(params, N_phi):\n    \"\"\"\n    Approximates the azimuthally averaged scalar flux at the center.\n\n    Args:\n        params (tuple): Pin cell parameters.\n        N_phi (int): Number of equi-spaced azimuthal angles.\n\n    Returns:\n        float: The approximated scalar flux average phi_N.\n    \"\"\"\n    angles = (2.0 * np.pi / N_phi) * (np.arange(N_phi) + 0.5)\n    psi_sum = 0.0\n    for phi in angles:\n        psi_sum += calculate_angular_flux(phi, params)\n    \n    return psi_sum / N_phi\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and generate the final output.\n    \"\"\"\n    test_cases = [\n        (1.26, 0.54, 0.8, 1.0, 0.2, 0.1),\n        (1.26, 0.62, 1.5, 1.0, 0.05, 0.02),\n        (1.26, 0.40, 0.2, 1.0, 2.0, 0.2)\n    ]\n    \n    N_ref = 4096\n    N_vals = [4, 8]\n    \n    all_results = []\n    \n    for case_params in test_cases:\n        phi_ref = calculate_scalar_flux_avg(case_params, N_ref)\n        \n        case_errors = []\n        for N in N_vals:\n            phi_N = calculate_scalar_flux_avg(case_params, N)\n            relative_error = abs((phi_N - phi_ref) / phi_ref)\n            case_errors.append(relative_error)\n        \n        all_results.append(case_errors)\n        \n    # Format the output string as specified: [[e1_4,e1_8],[e2_4,e2_8],[e3_4,e3_8]]\n    # Use format(num, 'f') to ensure plain float notation.\n    outer_parts = []\n    for errors in all_results:\n        inner_str = f\"[{format(errors[0], 'f')},{format(errors[1], 'f')}]\"\n        outer_parts.append(inner_str)\n    \n    final_output = f\"[{','.join(outer_parts)}]\"\n    \n    print(final_output)\n\nsolve()\n\n```"
        },
        {
            "introduction": "While uniform ray spacing is simple to implement, it is not always efficient, as it may over-resolve simple regions while under-resolving complex ones with curved boundaries. This final practice  introduces an advanced technique used in modern MOC codes: adaptive ray spacing. You will derive and implement a rule that adjusts the density of rays based on the local curvature of material interfaces, a key strategy for optimizing both the accuracy and computational performance of a ray tracing module.",
            "id": "4236066",
            "problem": "Consider a modular ray tracing module for the Method of Characteristics (MOC) in nuclear reactor simulation. In this context, a bundle of parallel characteristic rays traverses a two-dimensional cross section containing curved material interfaces. The goal is to determine an adaptive transverse spacing between rays, denoted by $\\,\\Delta\\,$, such that the geometric error in the along-ray intersection length induced by approximating a curved boundary locally by a straight chord remains below a specified target.\n\nStart from the following fundamental base of differential geometry and geometry of circles:\n\n- Curvature $\\,\\kappa\\,$ of a smooth curve at a point equals the reciprocal of the radius $\\,R\\,$ of its osculating circle, i.e., $\\,\\kappa = \\dfrac{1}{R}\\,$.\n- For a circular arc subtended by a chord of length $\\,\\Delta\\,$, the sagitta (maximum deviation between the arc and the chord) is\n$$\ns(\\Delta, R) \\;=\\; R \\;-\\; \\sqrt{R^2 - \\left(\\dfrac{\\Delta}{2}\\right)^2}\\,,\n$$\nand for sufficiently small $\\,\\Delta\\,$ relative to $\\,R\\,$, the second-order Taylor expansion yields the well-tested approximation\n$$\ns(\\Delta, R) \\;\\approx\\; \\dfrac{\\Delta^2}{8R}\\;=\\;\\dfrac{\\kappa\\,\\Delta^2}{8}\\,.\n$$\n\nAssume a characteristic ray intersects the curved boundary at an incidence angle $\\,\\alpha\\,$ measured with respect to the boundary normal. A normal-position error $\\,s\\,$ maps to an along-ray intersection length error $\\,e\\,$ via projection,\n$$\ne \\;=\\; \\dfrac{s}{\\left|\\cos\\alpha\\right|}\\,.\n$$\nSuppose a target bound $\\,\\varepsilon\\,$ on the along-ray intersection length error is prescribed.\n\nTask A (Derivation): Derive, from the above base, a relation for the adaptive ray spacing $\\,\\Delta\\,$ as a function of curvature $\\,\\kappa\\,$, incidence angle $\\,\\alpha\\,$, and target error $\\,\\varepsilon\\,$ that ensures $\\,e \\le \\varepsilon\\,$ for small $\\,\\Delta\\,$. Show that $\\,\\Delta\\,$ scales as $\\,\\Delta \\propto \\kappa^{-1/2}\\,$ and provide the explicit proportionality with constants.\n\nTask B (Algorithm Design): Using the derived relation, design a robust computation for $\\,\\Delta\\,$ that includes a practical upper bound $\\,\\Delta_{\\max}\\,$ to prevent overly sparse rays in weakly curved or flat regions. If $\\,\\kappa = 0\\,$, define $\\,\\Delta\\,$ to be $\\,\\Delta_{\\max}\\,$. All distances must be expressed in meters, and all angles must be in radians.\n\nTask C (Implementation and Test Suite): Implement a complete, runnable program that:\n- Computes $\\,\\Delta\\,$ for a fixed set of test cases.\n- Uses the formula from Task A with the practical rule from Task B.\n- Produces a single line of output containing the results as a comma-separated list enclosed in square brackets, for example $\\,\\left[\\text{result}_1,\\text{result}_2,\\text{result}_3\\right]\\,$.\n\nThe test suite consists of the following parameter sets $\\,(\\kappa,\\alpha,\\varepsilon,\\Delta_{\\max})\\,$:\n- Case $\\,1\\,$ (typical curvature and angle): $\\,\\left(1.0,\\;\\dfrac{\\pi}{4},\\;1.0\\times 10^{-4},\\;0.05\\right)\\,$.\n- Case $\\,2\\,$ (high curvature): $\\,\\left(100.0,\\;\\dfrac{\\pi}{6},\\;1.0\\times 10^{-4},\\;0.05\\right)\\,$.\n- Case $\\,3\\,$ (flat boundary): $\\,\\left(0.0,\\;\\dfrac{\\pi}{4},\\;1.0\\times 10^{-4},\\;0.10\\right)\\,$.\n- Case $\\,4\\,$ (near-tangent incidence): $\\,\\left(10.0,\\;89.0\\times\\dfrac{\\pi}{180},\\;1.0\\times 10^{-4},\\;0.05\\right)\\,$.\n- Case $\\,5\\,$ (limit by maximum spacing): $\\,\\left(2.0,\\;\\dfrac{\\pi}{3},\\;1.0\\times 10^{-3},\\;0.02\\right)\\,$.\n\nFor each case, compute the adaptive spacing $\\,\\Delta\\,$ in meters. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example $\\,\\left[\\Delta_1,\\Delta_2,\\Delta_3,\\Delta_4,\\Delta_5\\right]\\,$, where each $\\,\\Delta_i\\,$ is a floating-point number representing meters. No additional text should be printed.",
            "solution": "**Problem Validation**\n\n**Step 1: Extract Givens**\nThe givens extracted verbatim from the problem statement are:\n- Adaptive transverse ray spacing: $\\Delta$\n- Curvature: $\\kappa = \\dfrac{1}{R}$, where $R$ is the radius of the osculating circle.\n- Sagitta for a circular arc: $s(\\Delta, R) = R - \\sqrt{R^2 - \\left(\\dfrac{\\Delta}{2}\\right)^2}$.\n- Second-order Taylor approximation for sagitta: $s(\\Delta, R) \\approx \\dfrac{\\Delta^2}{8R} = \\dfrac{\\kappa\\,\\Delta^2}{8}$.\n- Incidence angle: $\\alpha$, measured with respect to the boundary normal.\n- Along-ray intersection length error, $e$, resulting from a normal-position error, $s$: $e = \\dfrac{s}{\\left|\\cos\\alpha\\right|}$.\n- Target bound on the along-ray intersection length error: $\\varepsilon$. The goal is to ensure $e \\le \\varepsilon$.\n- A practical upper bound on ray spacing: $\\Delta_{\\max}$.\n- Condition for flat boundaries: If $\\kappa = 0$, then $\\Delta = \\Delta_{\\max}$.\n- Test Case $1$: $(\\kappa, \\alpha, \\varepsilon, \\Delta_{\\max}) = \\left(1.0, \\dfrac{\\pi}{4}, 1.0 \\times 10^{-4}, 0.05\\right)$.\n- Test Case $2$: $(\\kappa, \\alpha, \\varepsilon, \\Delta_{\\max}) = \\left(100.0, \\dfrac{\\pi}{6}, 1.0 \\times 10^{-4}, 0.05\\right)$.\n- Test Case $3$: $(\\kappa, \\alpha, \\varepsilon, \\Delta_{\\max}) = \\left(0.0, \\dfrac{\\pi}{4}, 1.0 \\times 10^{-4}, 0.10\\right)$.\n- Test Case $4$: $(\\kappa, \\alpha, \\varepsilon, \\Delta_{\\max}) = \\left(10.0, 89.0 \\times \\dfrac{\\pi}{180}, 1.0 \\times 10^{-4}, 0.05\\right)$.\n- Test Case $5$: $(\\kappa, \\alpha, \\varepsilon, \\Delta_{\\max}) = \\left(2.0, \\dfrac{\\pi}{3}, 1.0 \\times 10^{-3}, 0.02\\right)$.\n- All distances are in meters, all angles are in radians.\n\n**Step 2: Validate Using Extracted Givens**\nThe problem is assessed against the validation criteria:\n- **Scientifically Grounded**: The problem is firmly based on established principles of differential geometry (curvature, osculating circle, sagitta) and their application to numerical methods in physics (Method of Characteristics for particle transport). The relationships provided are standard approximations used in this field. The problem is scientifically sound.\n- **Well-Posed**: The problem is well-posed. It clearly defines all variables and provides all necessary equations and constants to derive a unique solution for the adaptive ray spacing $\\Delta$. The tasks are specific, and the test cases provide all required input parameters.\n- **Objective**: The problem is stated in precise, objective language. It uses formal mathematical definitions and avoids any subjective, speculative, or opinion-based claims.\n\nThe problem does not exhibit any of the invalidity flaws. It is based on correct scientific premises, is formalizable, self-contained, physically realistic within the context of numerical simulation, and well-structured.\n\n**Step 3: Verdict and Action**\nThe problem statement is valid. A complete solution will be provided.\n\n**Solution Derivation and Algorithm Design**\n\n**Task A: Derivation**\nThe objective is to derive an expression for the adaptive ray spacing $\\Delta$ as a function of curvature $\\kappa$, incidence angle $\\alpha$, and target error $\\varepsilon$. The derivation begins with the relationships provided.\n\nThe maximum geometric deviation between the curved boundary and the approximating straight chord of length $\\Delta$ is given by the sagitta, $s$. For small $\\Delta$ relative to the radius of curvature $R$, this is approximated by:\n$$\ns \\approx \\dfrac{\\kappa \\Delta^2}{8}\n$$\nThis sagitta represents the maximum normal-position error that arises from this geometric approximation.\n\nThe along-ray intersection length error, $e$, is related to a normal-position error, which we take to be the sagitta $s$, by the projection formula:\n$$\ne = \\dfrac{s}{|\\cos\\alpha|}\n$$\nThe condition to be satisfied is that this length error must not exceed the specified tolerance $\\varepsilon$:\n$$\ne \\le \\varepsilon\n$$\nSubstituting the expressions for $e$ and then $s$ into this inequality, we have:\n$$\n\\dfrac{s}{|\\cos\\alpha|} \\le \\varepsilon\n$$\n$$\n\\dfrac{\\left(\\dfrac{\\kappa \\Delta^2}{8}\\right)}{|\\cos\\alpha|} \\le \\varepsilon\n$$\nWe now solve for $\\Delta$. This inequality must hold for the maximum spacing $\\Delta$ that meets the criterion, so we can treat it as an equality for the boundary case.\n$$\n\\dfrac{\\kappa \\Delta^2}{8 |\\cos\\alpha|} = \\varepsilon\n$$\nRearranging the terms to isolate $\\Delta^2$:\n$$\n\\Delta^2 = \\dfrac{8 \\varepsilon |\\cos\\alpha|}{\\kappa}\n$$\nTaking the square root of both sides gives the desired relation for the adaptive ray spacing:\n$$\n\\Delta = \\sqrt{\\dfrac{8 \\varepsilon |\\cos\\alpha|}{\\kappa}}\n$$\nThis formula is valid for $\\kappa > 0$. From this expression, it is evident that $\\Delta$ is proportional to $\\kappa^{-1/2}$:\n$$\n\\Delta = \\left( \\sqrt{8 \\varepsilon |\\cos\\alpha|} \\right) \\kappa^{-1/2}\n$$\nThe term $\\sqrt{8 \\varepsilon |\\cos\\alpha|}$ is the explicit proportionality constant, which itself depends on the error tolerance $\\varepsilon$ and the incidence angle $\\alpha$.\n\n**Task B: Algorithm Design**\nA robust computational algorithm for $\\Delta$ must handle the full range of possible inputs for $\\kappa$, including the special case of flat boundaries where $\\kappa = 0$, and incorporate the practical upper limit $\\Delta_{\\max}$.\n\nThe algorithm proceeds as follows:\n$1$. Given the inputs: curvature $\\kappa$, incidence angle $\\alpha$, error tolerance $\\varepsilon$, and maximum spacing $\\Delta_{\\max}$.\n$2$. Check for the case of a flat or nearly flat boundary. If $\\kappa = 0$ (or is numerically indistinguishable from zero), the derived formula is undefined due to division by zero. As per the problem specification, the spacing is set to the maximum allowed value:\n   $$\n   \\text{If } \\kappa = 0, \\text{ then } \\Delta = \\Delta_{\\max}\n   $$\n$3$. For a curved boundary where $\\kappa > 0$, calculate the ideal spacing, let's call it $\\Delta_{\\text{calc}}$, using the formula derived in Task A:\n   $$\n   \\Delta_{\\text{calc}} = \\sqrt{\\dfrac{8 \\varepsilon |\\cos\\alpha|}{\\kappa}}\n   $$\n   The absolute value $|\\cos\\alpha|$ ensures correctness for any angle $\\alpha$, although in this context $\\alpha$ typically lies in $[0, \\pi/2]$, where $\\cos\\alpha \\ge 0$.\n$4$. To prevent overly sparse rays in regions of very low curvature (large $\\Delta_{\\text{calc}}$), the calculated spacing must be limited by the practical upper bound $\\Delta_{\\max}$. The final adaptive spacing $\\Delta$ is therefore the minimum of the calculated value and the maximum allowed value:\n   $$\n   \\Delta = \\min(\\Delta_{\\text{calc}}, \\Delta_{\\max})\n   $$\nThis two-step logic (handling $\\kappa=0$ and then applying the cap $\\Delta_{\\max}$) provides a robust procedure for computing the adaptive ray spacing for all valid inputs. The implementation will combine these steps.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the adaptive ray spacing for a set of test cases based on\n    curvature, incidence angle, error tolerance, and a maximum spacing limit.\n    \"\"\"\n    # The test suite consists of the following parameter sets (κ, α, ε, Δ_max).\n    # κ: curvature (1/m)\n    # α: incidence angle (radians)\n    # ε: target error (m)\n    # Δ_max: maximum spacing (m)\n    test_cases = [\n        # Case 1 (typical curvature and angle)\n        (1.0, np.pi / 4.0, 1.0e-4, 0.05),\n        # Case 2 (high curvature)\n        (100.0, np.pi / 6.0, 1.0e-4, 0.05),\n        # Case 3 (flat boundary)\n        (0.0, np.pi / 4.0, 1.0e-4, 0.10),\n        # Case 4 (near-tangent incidence)\n        (10.0, 89.0 * np.pi / 180.0, 1.0e-4, 0.05),\n        # Case 5 (limit by maximum spacing)\n        (2.0, np.pi / 3.0, 1.0e-3, 0.02),\n    ]\n\n    results = []\n    for case in test_cases:\n        kappa, alpha, epsilon, delta_max = case\n\n        if kappa == 0.0:\n            # For a flat boundary, curvature is zero. The derived formula is\n            # undefined. Per the problem statement, use the maximum spacing.\n            delta = delta_max\n        else:\n            # Calculate the ideal spacing based on the derived formula from Task A.\n            # Δ = sqrt( (8 * ε * |cos(α)|) / κ )\n            # The use of np.abs() for cos(alpha) is for robustness, though alpha\n            # in this context is typically in [0, pi/2].\n            numerator = 8.0 * epsilon * np.abs(np.cos(alpha))\n            delta_calc = np.sqrt(numerator / kappa)\n\n            # Apply the practical upper bound from Task B. The final spacing\n            # is the minimum of the calculated value and the max allowed value.\n            delta = min(delta_calc, delta_max)\n        \n        results.append(delta)\n\n    # The final print statement must produce only the single-line format\n    # specified in the problem statement.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}