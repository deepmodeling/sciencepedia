{
    "hands_on_practices": [
        {
            "introduction": "在中子输运理论中，一个关键要求是角度求积格式能够精确处理各向同性散射源。这在数学上转化为离散二阶矩张量必须是各向同性的。本练习将通过对称性论证，揭示水平对称（Level-Symmetric, LS）求积集的设计如何从构造上保证这一重要属性，而无需预先知道具体的权重值。",
            "id": "4248060",
            "problem": "在用于核反应堆模拟的三维中子输运中，离散纵标法在单位球面上选择一组有限的方向，并赋予相关的非负权重，以近似角积分。为使角向求积能够正确传递各向同性散射，方向余弦的离散二阶矩张量必须复现连续的各向同性二阶矩。考虑一个候选的八阶水平对称组 ($LS_8$)，其每个卦限由按对称类型分组的十个方向构成，每个对称类型内的权重以及所有卦限间的权重均相同：\n\n- A类（每卦限一个）：方向余弦相等的方向 $\\left(p,p,p\\right)$，其中 $p>0$ 且 $3p^{2}=1$。\n\n- B类（每卦限三个）：$\\left(u,u,v\\right)$ 的三种排列，其中 $u>0$，$v>0$ 且 $2u^{2}+v^{2}=1$。为确定起见，取 $u=\\sqrt{\\frac{1}{5}}$ 和 $v=\\sqrt{\\frac{3}{5}}$。\n\n- C类（每卦限六个）：$\\left(a,b,c\\right)$ 的六种排列，其中 $a>0$，$b>0$，$c>0$ 且 $a^{2}+b^{2}+c^{2}=1$。为确定起见，取 $a=\\sqrt{\\frac{1}{10}}$，$b=\\sqrt{\\frac{3}{10}}$ 和 $c=\\sqrt{\\frac{6}{10}}$。\n\n设 A类、B类 和 C类 方向各自对应的非负权重分别为 $w_{A}$、$w_{B}$ 和 $w_{C}$。全球面权重归一化条件为\n$$\n\\sum_{i} w_{i} \\;=\\; 8\\left(w_{A}+3w_{B}+6w_{C}\\right)\\;=\\;4\\pi,\n$$\n其中因子 $8$ 是因为有八个卦限。\n\n定义离散二阶矩张量为\n$$\n\\mathbf{T} \\;=\\; \\sum_{i} w_{i}\\,\\vec{\\Omega}_{i}\\,\\vec{\\Omega}_{i},\n$$\n其中 $\\vec{\\Omega}_{i}$ 是第 $i$ 个求积方向的单位方向向量，$\\vec{\\Omega}_{i}\\,\\vec{\\Omega}_{i}$ 表示并矢（外）积。仅使用上述约束和对称性论证，计算 $\\mathbf{T}$ 并评估各向同性误差张量\n$$\n\\Delta \\;=\\; \\mathbf{T} - \\frac{4\\pi}{3}\\,\\mathbf{I},\n$$\n其中 $\\mathbf{I}$ 是单位张量。将误差的 Frobenius 范数，\n$$\n\\|\\Delta\\|_{F} \\;=\\; \\sqrt{\\mathrm{tr}\\!\\left(\\Delta^{\\mathsf{T}}\\Delta\\right)},\n$$\n作为一个实数报告。最终答案无需四舍五入。",
            "solution": "离散二阶矩张量为 $\\mathbf{T} = \\sum_{i} w_{i}\\,\\vec{\\Omega}_{i}\\,\\vec{\\Omega}_{i}$。其分量为 $T_{jk} = \\sum_{i} w_{i} \\mu_{ij} \\mu_{ik}$。\n\n**非对角分量**：考虑 $T_{xy} = \\sum w_i \\mu_{ix} \\mu_{iy}$。由于水平对称求积组的反射对称性，对于集合中任意方向 $(\\mu_x, \\mu_y, \\mu_z)$，方向 $(-\\mu_x, \\mu_y, \\mu_z)$ 也必定存在且权重相同。它们的贡献 $w(\\mu_x \\mu_y) + w(-\\mu_x \\mu_y)$ 相互抵消。因此，所有非对角分量均为零，$\\mathbf{T}$ 是一个对角矩阵。\n\n**对角分量**：考虑 $T_{xx} = \\sum w_i \\mu_{ix}^2$。由于坐标置换对称性，交换所有方向的 $x$ 和 $y$ 坐标后，整个方向与权重集保持不变，但求和式 $T_{xx}$ 变为 $T_{yy}$。因此 $T_{xx} = T_{yy}$。同理可得 $T_{xx} = T_{zz}$。所以 $T_{xx} = T_{yy} = T_{zz} = k$，其中 $k$ 为某个常数。张量是各向同性的：$\\mathbf{T} = k\\mathbf{I}$。\n\n**确定 k 的值**：张量的迹为 $\\mathrm{tr}(\\mathbf{T}) = 3k$。根据其定义，迹也等于 $\\sum_i w_i \\mathrm{tr}(\\vec{\\Omega}_i \\vec{\\Omega}_i^{\\mathsf{T}}) = \\sum_i w_i |\\vec{\\Omega}_i|^2 = \\sum_i w_i$。由于权重归一化为 $\\sum_i w_i = 4\\pi$，可得 $3k = 4\\pi$，即 $k = \\frac{4\\pi}{3}$。\n\n因此，$\\mathbf{T} = \\frac{4\\pi}{3} \\mathbf{I}$。该结果仅依赖于求积组的对称性。\n\n**误差计算**：各向同性误差张量为 $\\Delta = \\mathbf{T} - \\frac{4\\pi}{3}\\mathbf{I} = \\mathbf{0}$。其 Frobenius 范数 $\\|\\Delta\\|_{F}$ 也为零。",
            "answer": "$$\n\\boxed{0}\n$$"
        },
        {
            "introduction": "虽然水平对称求积格式被设计为对低阶多项式精确，但它们对于任意函数并非总是精确的。本练习提供了一个具体的例子，用一个简单的 LS 求积格式来计算一个四阶多项式的积分。通过分别计算近似求和与精确的解析积分，您将能够亲手量化求积误差，从而对“矩精确性”的局限有更深刻的理解。",
            "id": "4233286",
            "problem": "在用于核反应堆模拟的三维中子输运中，单位球面上的角积分通过使用水平对称求积的逐点求和来近似。设方向函数定义为 $f(\\vec{\\Omega}) = \\mu^{4} + \\eta^{4} + \\xi^{4}$，其中 $\\mu$、$\\eta$ 和 $\\xi$ 是 $\\vec{\\Omega}$ 相对于笛卡尔坐标轴的方向余弦。考虑一个单层水平对称（LS）求积，其构造如下：使用对应于方向余弦矢量 $(\\mu,\\eta,\\xi) = \\left(\\frac{1}{\\sqrt{3}}, \\frac{1}{\\sqrt{3}}, \\frac{1}{\\sqrt{3}}\\right)$ 的所有符号组合的八个方向，并为每个方向分配相等的权重 $w$，使得该求积对于常数在全立体角上的积分是精确的。\n\n使用此求积，计算离散求积和\n$$\nQ \\equiv \\sum_{i=1}^{8} w\\, f(\\vec{\\Omega}_{i}),\n$$\n以及在整个球面上的解析积分\n$$\nI \\equiv \\int_{4\\pi} f(\\vec{\\Omega})\\, d\\Omega,\n$$\n然后，计算差值\n$$\nD \\equiv Q - I.\n$$\n你的推导应基于立体角积分的基本定义和方向余弦的定义。以球面度为单位表示 $D$ 的最终值。无需四舍五入；报告精确值。",
            "solution": "问题要求计算函数 $f(\\vec{\\Omega}) = \\mu^{4} + \\eta^{4} + \\xi^{4}$ 在单位球面上离散求积和 $Q$ 与解析积分 $I$ 之间的差值 $D$。矢量 $\\vec{\\Omega}$ 的方向余弦由 $\\mu$、$\\eta$ 和 $\\xi$ 给出。\n需要计算的总量是 $D \\equiv Q - I$。我们将分别计算 $Q$ 和 $I$，然后求出它们的差值。\n\n首先，我们确定求积权重 $w$ 的值。问题陈述，单层水平对称（LS）求积由8个方向构成，每个方向具有相等的权重 $w$。该求积对于常数函数在 $4\\pi$ 球面度的全立体角上的积分是精确的。我们选择常数函数 $g(\\vec{\\Omega}) = 1$。\n这个常数函数的解析积分是：\n$$ \\int_{4\\pi} 1 \\, d\\Omega = 4\\pi $$\n相应的求积和是：\n$$ \\sum_{i=1}^{8} w_{i} g(\\vec{\\Omega}_{i}) = \\sum_{i=1}^{8} w \\cdot 1 = 8w $$\n根据对常数精确的条件，我们令积分与和相等：\n$$ 8w = 4\\pi $$\n解出 $w$，我们得到每个求积点的权重：\n$$ w = \\frac{4\\pi}{8} = \\frac{\\pi}{2} $$\n\n接下来，我们计算离散求积和 $Q$。\n$$ Q \\equiv \\sum_{i=1}^{8} w f(\\vec{\\Omega}_{i}) $$\n求积点 $\\vec{\\Omega}_{i}$ 是对应于方向余弦矢量 $(\\frac{1}{\\sqrt{3}}, \\frac{1}{\\sqrt{3}}, \\frac{1}{\\sqrt{3}})$ 的所有符号组合的8个方向。这意味着对于任何方向 $i$，其分量 $(\\mu_i, \\eta_i, \\xi_i)$ 满足 $|\\mu_i| = \\frac{1}{\\sqrt{3}}$， $|\\eta_i| = \\frac{1}{\\sqrt{3}}$，以及 $|\\xi_i| = \\frac{1}{\\sqrt{3}}$。\n让我们在这8个点中的任意一点计算函数 $f(\\vec{\\Omega})$ 的值。由于函数定义中的幂是偶数，方向余弦的符号不影响结果。\n$$ f(\\vec{\\Omega}_{i}) = \\mu_{i}^{4} + \\eta_{i}^{4} + \\xi_{i}^{4} = \\left(\\pm\\frac{1}{\\sqrt{3}}\\right)^{4} + \\left(\\pm\\frac{1}{\\sqrt{3}}\\right)^{4} + \\left(\\pm\\frac{1}{\\sqrt{3}}\\right)^{4} $$\n$$ f(\\vec{\\Omega}_{i}) = \\left(\\frac{1}{3}\\right)^{2} + \\left(\\frac{1}{3}\\right)^{2} + \\left(\\frac{1}{3}\\right)^{2} = \\frac{1}{9} + \\frac{1}{9} + \\frac{1}{9} = \\frac{3}{9} = \\frac{1}{3} $$\n对于所有8个求积方向，函数值是恒定的。我们现在可以计算 $Q$：\n$$ Q = \\sum_{i=1}^{8} w f(\\vec{\\Omega}_{i}) = 8 \\cdot w \\cdot f(\\vec{\\Omega}_{i}) = 8 \\cdot \\left(\\frac{\\pi}{2}\\right) \\cdot \\left(\\frac{1}{3}\\right) = \\frac{4\\pi}{3} $$\n\n现在，我们计算解析积分 $I$。\n$$ I \\equiv \\int_{4\\pi} f(\\vec{\\Omega}) \\, d\\Omega = \\int_ {4\\pi} (\\mu^{4} + \\eta^{4} + \\xi^{4}) \\, d\\Omega $$\n由于球体的对称性，$\\mu^4$、$\\eta^4$ 和 $\\xi^4$ 在全立体角上的积分是相同的。\n$$ \\int_{4\\pi} \\mu^{4} \\, d\\Omega = \\int_{4\\pi} \\eta^{4} \\, d\\Omega = \\int_{4\\pi} \\xi^{4} \\, d\\Omega $$\n因此，积分 $I$ 可以写为：\n$$ I = 3 \\int_{4\\pi} \\mu^{4} \\, d\\Omega $$\n为了计算这个积分，我们使用球坐标。立体角元为 $d\\Omega = \\sin\\theta \\, d\\theta \\, d\\phi$，其中 $\\theta \\in [0, \\pi]$ 是极角，$\\phi \\in [0, 2\\pi]$ 是方位角。方向余弦 $\\mu$ 等价于 $\\cos\\theta$。\n$$ \\int_{4\\pi} \\mu^{4} \\, d\\Omega = \\int_{0}^{2\\pi} \\int_{0}^{\\pi} (\\cos\\theta)^{4} \\sin\\theta \\, d\\theta \\, d\\phi $$\n对 $\\phi$ 的积分是平凡的：\n$$ \\int_{0}^{2\\pi} d\\phi = 2\\pi $$\n所以我们有：\n$$ \\int_{4\\pi} \\mu^{4} \\, d\\Omega = 2\\pi \\int_{0}^{\\pi} \\cos^{4}\\theta \\sin\\theta \\, d\\theta $$\n我们进行变量替换。令 $u = \\cos\\theta$，这意味着 $du = -\\sin\\theta \\, d\\theta$。积分限从 $\\theta=0$ 变为 $u=1$，从 $\\theta=\\pi$ 变为 $u=-1$。\n$$ 2\\pi \\int_{1}^{-1} u^{4} (-du) = 2\\pi \\int_{-1}^{1} u^{4} \\, du = 2\\pi \\left[ \\frac{u^{5}}{5} \\right]_{-1}^{1} $$\n$$ = 2\\pi \\left( \\frac{1^{5}}{5} - \\frac{(-1)^{5}}{5} \\right) = 2\\pi \\left( \\frac{1}{5} - \\left(-\\frac{1}{5}\\right) \\right) = 2\\pi \\left( \\frac{2}{5} \\right) = \\frac{4\\pi}{5} $$\n现在我们可以计算 $I$：\n$$ I = 3 \\cdot \\left(\\frac{4\\pi}{5}\\right) = \\frac{12\\pi}{5} $$\n\n最后，我们计算差值 $D = Q - I$。\n$$ D = \\frac{4\\pi}{3} - \\frac{12\\pi}{5} $$\n为了对这两个分数做减法，我们找到公分母，即 $15$。\n$$ D = \\frac{5 \\cdot 4\\pi}{15} - \\frac{3 \\cdot 12\\pi}{15} = \\frac{20\\pi}{15} - \\frac{36\\pi}{15} = \\frac{20\\pi - 36\\pi}{15} = -\\frac{16\\pi}{15} $$\n该结果表示这个特定的单层求积对于方向余弦四阶矩的误差。$D$ 的单位是球面度，因为积分和求和都是在立体角上进行的，且 $f(\\vec{\\Omega})$ 是无量纲的。",
            "answer": "$$\n\\boxed{-\\frac{16\\pi}{15}}\n$$"
        },
        {
            "introduction": "将理论知识应用于实践是科学研究的关键一步。本练习要求您编写一个计算验证套件，来测试给定的求积格式是否满足其应有的矩条件。通过测试一个正确定义的求积集以及几个被刻意设计的有缺陷的求积集，您将获得开发数值模拟程序时验证代码正确性的实践经验，并直观地看到设计缺陷如何导致验证失败。",
            "id": "4233267",
            "problem": "考虑用于核反应堆模拟的离散纵标 (DO) 方法中的中子输运三维角度积分。角度域为单位球面，记为 $\\Omega = \\{(\\mu,\\eta,\\xi)\\in\\mathbb{R}^3 \\mid \\mu^2+\\eta^2+\\xi^2=1\\}$，其中 $(\\mu,\\eta,\\xi)$ 是方向余弦。用于离散纵标 ($S_N$) 方法的水平对称求积由单位球面 $\\Omega$ 上的有限方向集 $\\{(\\mu_n,\\eta_n,\\xi_n)\\}_{n=1}^M$ 以及相应的非负权重 $\\{w_n\\}_{n=1}^M$ 组成，其加权和可用于近似角度积分：\n$$\n\\int_{\\Omega} f(\\mu,\\eta,\\xi)\\, \\mathrm{d}\\Omega \\approx \\sum_{n=1}^M w_n f(\\mu_n,\\eta_n,\\xi_n).\n$$\n根据单位球面的旋转对称性和恒等式 $\\mu^2+\\eta^2+\\xi^2=1$，最高为二次的典范多项式的精确积分满足以下条件：\n- 常数项：$\\int_{\\Omega} 1\\, \\mathrm{d}\\Omega = 4\\pi$。\n- 线性项：$\\int_{\\Omega} \\mu\\, \\mathrm{d}\\Omega = \\int_{\\Omega} \\eta\\, \\mathrm{d}\\Omega = \\int_{\\Omega} \\xi\\, \\mathrm{d}\\Omega = 0$。\n- 二次项：$\\int_{\\Omega} \\mu^2\\, \\mathrm{d}\\Omega = \\int_{\\Omega} \\eta^2\\, \\mathrm{d}\\Omega = \\int_{\\Omega} \\xi^2\\, \\mathrm{d}\\Omega = \\frac{4\\pi}{3}$，以及交叉项 $\\int_{\\Omega} \\mu\\eta\\, \\mathrm{d}\\Omega = \\int_{\\Omega} \\mu\\xi\\, \\mathrm{d}\\Omega = \\int_{\\Omega} \\eta\\xi\\, \\mathrm{d}\\Omega = 0$。\n\n基于这些事实和单位球面的定义，设计并实现一个验证套件。该套件给定一个水平对称求积 $\\{(\\mu_n,\\eta_n,\\xi_n),w_n\\}$，会为上述典范测试被积函数计算离散矩，并将其与解析值进行比较。该验证应报告矩条件的残差，并在机器精度范围内断言其精确性。\n\n您的程序必须：\n1. 构建以下三个求积测试用例：\n   - 用例 A（正常路径）：$S_2$ 水平对称求积，包含 $M=8$ 个方向，位于立方体顶点 $(\\pm a,\\pm a,\\pm a)$ 处，其中 $a = 1/\\sqrt{3}$，每个方向的权重为 $w = \\pi/2$。已知由于对称性以及 $a$ 和 $w$ 的选择，该求积能够在 $\\Omega$ 上精确积分所有最高为二次的多项式。\n   - 用例 B（近精确边界）：与用例 A 具有相同的几何结构，但所有权重均按因子 $1+\\delta$（其中 $\\delta = 10^{-8}$）进行统一缩放。这会故意引入一个小的归一化误差。\n   - 用例 C（边缘失效）：八个相同的方向，均为 $(a,a,a)$，其中 $a = 1/\\sqrt{3}$，每个方向的权重为 $w=\\pi/2$。这保留了总权重 $\\sum_n w_n = 4\\pi$，但破坏了奇数矩对称性。\n\n2. 对每个用例，评估最高为二次的十个典范被积函数的残差：\n   - $f_0=1$,\n   - $f_1=\\mu$, $f_2=\\eta$, $f_3=\\xi$,\n   - $f_4=\\mu^2$, $f_5=\\eta^2$, $f_6=\\xi^2$,\n   - $f_7=\\mu\\eta$, $f_8=\\mu\\xi$, $f_9=\\eta\\xi$。\n   对每个被积函数 $f_k$，计算残差 $r_k = \\left|\\sum_{n=1}^M w_n f_k(\\mu_n,\\eta_n,\\xi_n) - I_k\\right|$，其中 $I_k$ 是上文指定的相应精确积分值。\n\n3. 使用容差 $T = 1\\times 10^{-12}$。一个求积通过当且仅当 $\\max_k r_k \\leq T$。\n\n4. 最终输出必须为单行，其中包含三个用例的结果列表。每个用例的结果是一个数对 $[\\text{pass}, R]$，其中 $\\text{pass}$ 是一个布尔值，$R=\\max_k r_k$ 是一个实数。输出格式必须为：\n   $$\n   [[\\text{pass}_A, R_A],[\\text{pass}_B, R_B],[\\text{pass}_C, R_C]]\n   $$\n   以这种逗号分隔的括号列表格式精确打印为单行。\n\n不涉及物理单位。由于方向余弦是无单位的，因此角度也被视为无量纲。程序必须是自包含的，不需要任何输入，并严格按照指定的输出格式生成结果。\n\n该测试套件涵盖：\n- 一般正确性（用例 A），\n- 归一化的边界扰动（用例 B），\n- 破坏对称性的显著边缘情况（用例 C）。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果（例如，$ [[\\text{pass}_A,R_A],[\\text{pass}_B,R_B],[\\text{pass}_C,R_C]] $）。",
            "solution": "该验证套件通过计算一组典范多项式（最高到二次）的离散求积和，并将其与已知的解析积分值进行比较，来测试一个求积组是否满足基本的矩条件。这些解析值源于单位球面的对称性：\n- $\\int 1 \\,d\\Omega = 4\\pi$\n- 当 $k,l,m$ 中至少一个为奇数时，$\\int \\mu^k\\eta^l\\xi^m \\,d\\Omega = 0$\n- $\\int \\mu^2 \\,d\\Omega = \\int \\eta^2 \\,d\\Omega = \\int \\xi^2 \\,d\\Omega = 4\\pi/3$\n\n程序实现了三个测试用例：\n- **用例 A（正常路径）**: 一个标准的 $S_2$ 水平对称求积。其构造的对称性（符号变换和坐标置换）以及正确的权重选择，确保所有最高为二次的矩都被精确满足。因此，其最大残差应在机器精度范围内，测试会通过。\n- **用例 B（近精确边界）**: 此用例的权重被轻微缩放了 $(1+10^{-8})$。这破坏了零阶矩（总权重）的精确性。奇数阶矩因对称性仍为零，但偶数阶矩会有一个与 $4\\pi \\times 10^{-8}$ 成比例的误差，该误差远大于 $10^{-12}$ 的容差。因此，测试会失败。\n- **用例 C（边缘失效）**: 此用例通过将所有方向设为同一点来破坏对称性。虽然总权重仍然是 $4\\pi$，但奇数阶矩（如线性矩 $\\sum w_n\\mu_n$）不再为零，导致巨大的残差。因此，测试会失败。\n\n以下 Python 代码实现了这个验证流程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef build_S2_valid():\n    \"\"\"\n    Build the S2 level-symmetric quadrature:\n    Directions: all sign combinations of (a,a,a) with a=1/sqrt(3).\n    Weights: w = pi/2 for each of the 8 directions.\n    \"\"\"\n    a = 1.0 / np.sqrt(3.0)\n    w = np.pi / 2.0\n    # All 8 sign combinations\n    signs = np.array([\n        [+1, +1, +1],\n        [+1, +1, -1],\n        [+1, -1, +1],\n        [+1, -1, -1],\n        [-1, +1, +1],\n        [-1, +1, -1],\n        [-1, -1, +1],\n        [-1, -1, -1],\n    ], dtype=float)\n    dirs = signs * a\n    weights = np.full((dirs.shape[0],), w, dtype=float)\n    return dirs, weights\n\ndef build_S2_perturbed(delta=1e-8):\n    \"\"\"\n    Same directions as S2 valid, but the weights are uniformly scaled by (1+delta).\n    \"\"\"\n    dirs, weights = build_S2_valid()\n    return dirs, weights * (1.0 + delta)\n\ndef build_edge_failure():\n    \"\"\"\n    Eight identical directions all equal to (a,a,a), weights w = pi/2.\n    This breaks odd symmetry while keeping total weight = 4*pi.\n    \"\"\"\n    a = 1.0 / np.sqrt(3.0)\n    w = np.pi / 2.0\n    dirs = np.tile(np.array([a, a, a], dtype=float), (8, 1))\n    weights = np.full((dirs.shape[0],), w, dtype=float)\n    return dirs, weights\n\ndef canonical_integrands(mu, eta, xi):\n    \"\"\"\n    Evaluate the ten canonical integrands at given direction cosines.\n    Returns a vector [f0, f1, ..., f9].\n    \"\"\"\n    return np.array([\n        1.0,                 # f0 = 1\n        mu,                  # f1 = mu\n        eta,                 # f2 = eta\n        xi,                  # f3 = xi\n        mu*mu,               # f4 = mu^2\n        eta*eta,             # f5 = eta^2\n        xi*xi,               # f6 = xi^2\n        mu*eta,              # f7 = mu*eta\n        mu*xi,               # f8 = mu*xi\n        eta*xi               # f9 = eta*xi\n    ], dtype=float)\n\ndef exact_integrals():\n    \"\"\"\n    Exact integrals for the ten canonical integrands over the unit sphere.\n    [4π, 0, 0, 0, 4π/3, 4π/3, 4π/3, 0, 0, 0]\n    \"\"\"\n    four_pi = 4.0 * np.pi\n    four_pi_over_three = four_pi / 3.0\n    return np.array([\n        four_pi,            # I0\n        0.0,                # I1\n        0.0,                # I2\n        0.0,                # I3\n        four_pi_over_three, # I4\n        four_pi_over_three, # I5\n        four_pi_over_three, # I6\n        0.0,                # I7\n        0.0,                # I8\n        0.0                 # I9\n    ], dtype=float)\n\ndef validate_quadrature(dirs, weights, tol=1e-12):\n    \"\"\"\n    Compute residuals for canonical integrands and return pass flag and max residual.\n    \"\"\"\n    # Accumulate discrete sums for each integrand\n    sums = np.zeros(10, dtype=float)\n    for (mu, eta, xi), w in zip(dirs, weights):\n        f = canonical_integrands(mu, eta, xi)\n        sums += w * f\n\n    I = exact_integrals()\n    residuals = np.abs(sums - I)\n    max_residual = float(np.max(residuals))\n    passed = bool(max_residual = tol)\n    return passed, max_residual\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (\"CaseA_S2_valid\", build_S2_valid),\n        (\"CaseB_S2_perturbed\", lambda: build_S2_perturbed(delta=1e-8)),\n        (\"CaseC_edge_failure\", build_edge_failure),\n    ]\n\n    results = []\n    for name, builder in test_cases:\n        dirs, weights = builder()\n        passed, max_residual = validate_quadrature(dirs, weights, tol=1e-12)\n        # Append [boolean, float] for each case\n        results.append([passed, max_residual])\n    \n    # Custom formatter to match the required output style exactly\n    output_str = \"[\"\n    for i, item in enumerate(results):\n        # Format boolean as lowercase 'true' or 'false'\n        pass_str = \"true\" if item[0] else \"false\"\n        # Format float with sufficient precision\n        res_str = f\"{item[1]:.17g}\"\n        output_str += f\"[{pass_str},{res_str}]\"\n        if i  len(results) - 1:\n            output_str += \",\"\n    output_str += \"]\"\n    print(output_str)\n\n# The prompt asks for a self-contained script that runs. \n# Due to the execution environment, we call the main function.\nsolve()\n```"
        }
    ]
}