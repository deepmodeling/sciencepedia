{
    "hands_on_practices": [
        {
            "introduction": "标准的贝特曼方程解虽然形式优雅，但它依赖于所有移除速率常数都互不相同的假设。本练习要求您推导一个基本“简并”情况的解，即当两个核素具有相同的移除速率常数时 。理解这种情况对于开发数值稳定的燃耗求解器至关重要，并揭示了耦合线性系统的一个关键数学特征。",
            "id": "4254339",
            "problem": "考虑核反应堆中稳定中子场内的双核素嬗变链。核素 $1$ 以分支比 $b$（其中 $0 \\leq b \\leq 1$）嬗变为核素 $2$，两种核素都通过一个由有效移除常数表征的有效一级过程从系统中移除。在此背景下，一种核素的有效移除常数 $\\lambda^{\\mathrm{eff}}$ 是其放射性衰变常数与在稳定中子通量下的中子诱发反应率之和，并被视为与时间无关。设核素 $1$ 和核素 $2$ 的有效移除常数分别表示为 $\\lambda_{1}^{\\mathrm{eff}}$ 和 $\\lambda_{2}^{\\mathrm{eff}}$。\n\n您必须使用的基本依据是，在一级动力学下控制此类链中同位素损耗的线性常微分方程（ODE）组，以及求解线性常微分方程和评估极限的标准方法。\n\n假设初始库存量为 $N_{1}(0)=N_{10}$ 和 $N_{2}(0)=N_{20}$。对于有效移除常数相同的特殊情况，即 $\\lambda_{1}^{\\mathrm{eff}}=\\lambda_{2}^{\\mathrm{eff}}=\\lambda$，请从第一性原理出发，通过求解控制性常微分方程，推导核素 $2$ 的随时间变化的库存量 $N_{2}(t)$ 的闭式表达式。作为基于相同基本依据的一致性检验，请从非简并情况 $\\lambda_{1}^{\\mathrm{eff}} \\neq \\lambda_{2}^{\\mathrm{eff}}$ 出发，通过取极限 $\\lambda_{2}^{\\mathrm{eff}} \\to \\lambda_{1}^{\\mathrm{eff}}$ 来恢复此表达式，并明确验证 $t \\exp(-\\lambda t)$ 项的出现。\n\n请以 $N_{10}$、$N_{20}$、$b$、$\\lambda$ 和 $t$ 的形式，提供 $N_{2}(t)$ 的单一闭式解析表达式作为您的最终答案。无需进行数值计算，也无需四舍五入。最终答案中不要包含单位。",
            "solution": "问题陈述经评估有效。它在科学上基于核反应动力学原理，特别是用于同位素嬗变和损耗的贝特曼方程（Bateman equations）。该问题是适定的，提供了一个具有指定初始条件的线性常微分方程组，确保存在唯一且有意义的解。语言客观精确，设定内部一致且完整。\n\n该问题描述了一个由一级动力学控制的双核素嬗变链 $1 \\to 2$。核素 $1$ 的浓度 $N_1(t)$ 和核素 $2$ 的浓度 $N_2(t)$ 作为时间 $t$ 的函数，由以下线性常微分方程（ODE）组描述：\n$$\n\\frac{dN_1(t)}{dt} = -\\lambda_{1}^{\\mathrm{eff}} N_1(t)\n$$\n$$\n\\frac{dN_2(t)}{dt} = b \\lambda_{1}^{\\mathrm{eff}} N_1(t) - \\lambda_{2}^{\\mathrm{eff}} N_2(t)\n$$\n此处，$\\lambda_{1}^{\\mathrm{eff}}$ 和 $\\lambda_{2}^{\\mathrm{eff}}$ 分别是核素 $1$ 和核素 $2$ 的有效移除常数，$b$ 是核素 $1$ 嬗变为核素 $2$ 的分支比。核素 $2$ 的生产率是核素 $1$ 总移除率的一部分，比例为 $b$。初始条件为 $N_1(0) = N_{10}$ 和 $N_2(0) = N_{20}$。\n\n$N_1(t)$ 的第一个常微分方程是一个简单的可分离方程。其解通过直接积分得到：\n$$\n\\int_{N_{10}}^{N_1(t)} \\frac{dN_1}{N_1} = -\\int_0^t \\lambda_{1}^{\\mathrm{eff}} dt'\n$$\n$$\n\\ln\\left(\\frac{N_1(t)}{N_{10}}\\right) = -\\lambda_{1}^{\\mathrm{eff}} t\n$$\n$$\nN_1(t) = N_{10} \\exp(-\\lambda_{1}^{\\mathrm{eff}} t)\n$$\n\n我们被要求找出在有效移除常数相同的特殊情况下 $N_2(t)$ 的解，即 $\\lambda_{1}^{\\mathrm{eff}} = \\lambda_{2}^{\\mathrm{eff}} = \\lambda$。\n\n**方法一：简并情况（$\\lambda_{1}^{\\mathrm{eff}} = \\lambda_{2}^{\\mathrm{eff}} = \\lambda$）的直接求解**\n\n对于这种情况，方程组变为：\n$$\nN_1(t) = N_{10} \\exp(-\\lambda t)\n$$\n$$\n\\frac{dN_2(t)}{dt} = b \\lambda N_1(t) - \\lambda N_2(t)\n$$\n将 $N_1(t)$ 的表达式代入第二个方程得到：\n$$\n\\frac{dN_2(t)}{dt} + \\lambda N_2(t) = b \\lambda N_{10} \\exp(-\\lambda t)\n$$\n这是一个形式为 $y' + P(t)y = Q(t)$ 的一阶线性非齐次常微分方程。我们可以使用积分因子法求解。积分因子 $I(t)$ 由下式给出：\n$$\nI(t) = \\exp\\left(\\int \\lambda dt\\right) = \\exp(\\lambda t)\n$$\n将常微分方程两边乘以积分因子，我们得到：\n$$\n\\exp(\\lambda t) \\frac{dN_2}{dt} + \\lambda \\exp(\\lambda t) N_2(t) = \\exp(\\lambda t) \\left[ b \\lambda N_{10} \\exp(-\\lambda t) \\right]\n$$\n左侧是乘积 $N_2(t)I(t)$ 的导数：\n$$\n\\frac{d}{dt} \\left[ N_2(t) \\exp(\\lambda t) \\right] = b \\lambda N_{10}\n$$\n我们将两边对时间从 $0$ 到 $t$ 进行积分：\n$$\n\\int_0^t \\frac{d}{d\\tau} \\left[ N_2(\\tau) \\exp(\\lambda \\tau) \\right] d\\tau = \\int_0^t b \\lambda N_{10} d\\tau\n$$\n$$\n\\left[ N_2(\\tau) \\exp(\\lambda \\tau) \\right]_0^t = \\left[ b \\lambda N_{10} \\tau \\right]_0^t\n$$\n$$\nN_2(t) \\exp(\\lambda t) - N_2(0) \\exp(0) = b \\lambda N_{10} t - 0\n$$\n使用初始条件 $N_2(0) = N_{20}$：\n$$\nN_2(t) \\exp(\\lambda t) = N_{20} + b \\lambda N_{10} t\n$$\n最后，通过乘以 $\\exp(-\\lambda t)$ 来求解 $N_2(t)$：\n$$\nN_2(t) = (N_{20} + b \\lambda N_{10} t) \\exp(-\\lambda t)\n$$\n\n**方法二：通过取极限 $\\lambda_{2}^{\\mathrm{eff}} \\to \\lambda_{1}^{\\mathrm{eff}}$ 进行验证**\n\n作为一致性检验，我们首先推导非简并情况（$\\lambda_{1}^{\\mathrm{eff}} \\neq \\lambda_{2}^{\\mathrm{eff}}$）的解，然后取极限。$N_2(t)$ 的常微分方程为：\n$$\n\\frac{dN_2(t)}{dt} + \\lambda_{2}^{\\mathrm{eff}} N_2(t) = b \\lambda_{1}^{\\mathrm{eff}} N_{10} \\exp(-\\lambda_{1}^{\\mathrm{eff}} t)\n$$\n积分因子为 $I(t) = \\exp(\\lambda_{2}^{\\mathrm{eff}} t)$。将常微分方程乘以 $I(t)$ 得到：\n$$\n\\frac{d}{dt} \\left[ N_2(t) \\exp(\\lambda_{2}^{\\mathrm{eff}} t) \\right] = b \\lambda_{1}^{\\mathrm{eff}} N_{10} \\exp(-\\lambda_{1}^{\\mathrm{eff}} t) \\exp(\\lambda_{2}^{\\mathrm{eff}} t) = b \\lambda_{1}^{\\mathrm{eff}} N_{10} \\exp((\\lambda_{2}^{\\mathrm{eff}} - \\lambda_{1}^{\\mathrm{eff}}) t)\n$$\n从 $0$ 到 $t$ 积分：\n$$\nN_2(t) \\exp(\\lambda_{2}^{\\mathrm{eff}} t) - N_{20} = \\int_0^t b \\lambda_{1}^{\\mathrm{eff}} N_{10} \\exp((\\lambda_{2}^{\\mathrm{eff}} - \\lambda_{1}^{\\mathrm{eff}}) \\tau) d\\tau\n$$\n$$\nN_2(t) \\exp(\\lambda_{2}^{\\mathrm{eff}} t) - N_{20} = b \\lambda_{1}^{\\mathrm{eff}} N_{10} \\left[ \\frac{\\exp((\\lambda_{2}^{\\mathrm{eff}} - \\lambda_{1}^{\\mathrm{eff}}) t) - 1}{\\lambda_{2}^{\\mathrm{eff}} - \\lambda_{1}^{\\mathrm{eff}}} \\right]\n$$\n求解 $N_2(t)$：\n$$\nN_2(t) = N_{20} \\exp(-\\lambda_{2}^{\\mathrm{eff}} t) + b \\lambda_{1}^{\\mathrm{eff}} N_{10} \\frac{\\exp(-\\lambda_{1}^{\\mathrm{eff}} t) - \\exp(-\\lambda_{2}^{\\mathrm{eff}} t)}{\\lambda_{2}^{\\mathrm{eff}} - \\lambda_{1}^{\\mathrm{eff}}}\n$$\n现在，我们评估当 $\\lambda_{2}^{\\mathrm{eff}} \\to \\lambda_{1}^{\\mathrm{eff}}$ 时该表达式的极限。令 $\\lambda_{1}^{\\mathrm{eff}} = \\lambda$ 和 $\\lambda_{2}^{\\mathrm{eff}} = \\lambda + \\epsilon$，其中 $\\epsilon \\to 0$。\n$$\nN_2(t) = N_{20} \\exp(-(\\lambda+\\epsilon) t) + b \\lambda N_{10} \\frac{\\exp(-\\lambda t) - \\exp(-(\\lambda+\\epsilon) t)}{\\epsilon}\n$$\n当 $\\epsilon \\to 0$ 时，第一项变为 $N_{20} \\exp(-\\lambda t)$。第二项需要仔细评估极限：\n$$\n\\lim_{\\epsilon \\to 0} \\left[ b \\lambda N_{10} \\frac{\\exp(-\\lambda t) - \\exp(-\\lambda t)\\exp(-\\epsilon t)}{\\epsilon} \\right] = b \\lambda N_{10} \\exp(-\\lambda t) \\lim_{\\epsilon \\to 0} \\left[ \\frac{1 - \\exp(-\\epsilon t)}{\\epsilon} \\right]\n$$\n该极限为 $\\frac{0}{0}$ 的不定式。我们应用洛必达法则，对分数的分子和分母关于 $\\epsilon$ 求导：\n$$\n\\lim_{\\epsilon \\to 0} \\frac{\\frac{d}{d\\epsilon}(1 - \\exp(-\\epsilon t))}{\\frac{d}{d\\epsilon}(\\epsilon)} = \\lim_{\\epsilon \\to 0} \\frac{-(-t)\\exp(-\\epsilon t)}{1} = \\lim_{\\epsilon \\to 0} t \\exp(-\\epsilon t) = t\n$$\n这一步明确地展示了线性因子 $t$ 的出现。将此结果代回 $N_2(t)$ 的表达式：\n$$\n\\lim_{\\lambda_{2}^{\\mathrm{eff}} \\to \\lambda_{1}^{\\mathrm{eff}}} N_2(t) = N_{20} \\exp(-\\lambda t) + b \\lambda N_{10} \\exp(-\\lambda t) \\cdot t\n$$\n合并各项，我们得到：\n$$\nN_2(t) = (N_{20} + b \\lambda N_{10} t) \\exp(-\\lambda t)\n$$\n这个结果与方法一中直接求解得到的结果完全相同，证实了该数学框架的一致性。$t \\exp(-\\lambda t)$ 项是线性系统中共振现象的特征，它是在相等特征值（移除常数）的极限下，通过解决不定式而自然产生的。",
            "answer": "$$\n\\boxed{(N_{20} + b \\lambda N_{10} t) \\exp(-\\lambda t)}\n$$"
        },
        {
            "introduction": "为了处理真实反应堆中的大规模核素网络，我们需要从单个的常微分方程转向更强大的矩阵形式。本练习将介绍燃耗矩阵 $\\mathbf{A}$ 及其使用矩阵指数的解析解 。通过解析证明和数值编程，您将验证一个基本的物理原理——封闭系统内核素总数守恒——并了解它如何在数学上体现在燃耗矩阵的结构中。",
            "id": "4254316",
            "problem": "考虑一个用于核反应堆模拟的封闭同位素嬗变网络，该网络被建模为关于数密度的一阶常微分方程（ODE）组。设数密度向量表示为 $\\mathbf{N}(t) \\in \\mathbb{R}^{n}$，其中每个分量 $N_{i}(t)$ 代表时刻 $t$ 时同位素 $i$ 的数密度。假设转变是线性的，速率为常数，并且网络内核素总数守恒（没有外部损失或增益）。定义转移矩阵 $\\mathbf{A} \\in \\mathbb{R}^{n \\times n}$，按照惯例，$\\mathbf{A}_{ij}$ 是从同位素 $j$ 转移到同位素 $i$ 的速率系数。根据一个没有损失项的封闭网络的构造，$\\mathbf{A}$ 的每一列之和为零：对于每种同位素 $j$，$\\sum_{i=1}^{n} \\mathbf{A}_{ij} = 0$，这意味着从同位素 $j$ 的总流出量等于流入其他同位素的总量。\n\n该动力学系统由以下基本燃耗模型给出\n$$\n\\frac{d\\mathbf{N}}{dt} = \\mathbf{A}\\,\\mathbf{N}\\,,\n$$\n其中 $t$ 是以秒为单位的时间，速率系数的单位是 $\\text{s}^{-1}$。每个测试都指定了初始条件 $\\mathbf{N}(0)$。\n\n任务 1（解析）：从给定的 ODE 和表示为 $\\mathbf{1}^{\\top}\\mathbf{A}=\\mathbf{0}^{\\top}$ 的封闭网络性质出发（其中 $\\mathbf{1}$ 是全一向量，$\\mathbf{0}$ 是零向量），证明核素守恒定律成立；具体来说，证明对于所有 $t \\geq 0$，总数密度 $\\mathbf{1}^{\\top}\\mathbf{N}(t)$ 不随时间变化。您的推导必须从给定的 ODE 和 $\\mathbf{A}$ 的既定结构性质开始，并使用公认的线性代数事实进行。不要引入任何外部损失项，也不要假设任何捷径解法公式作为起点。\n\n任务 2（数值验证）：实现一个程序，对于以下每个测试用例，通过矩阵指数计算 $\\mathbf{N}(t)$，并数值验证核素守恒是否成立。对于每个测试用例，您必须返回两个布尔结果：\n- 首先，在数值容差 $\\epsilon = 10^{-10}$ 内验证结构性质 $\\mathbf{1}^{\\top}\\mathbf{A}=\\mathbf{0}^{\\top}$。\n- 其次，在相同的容差 $\\epsilon = 10^{-10}$ 内验证 $\\mathbf{1}^{\\top}\\mathbf{N}(t) = \\mathbf{1}^{\\top}\\mathbf{N}(0)$。\n\n使用 $\\mathbf{N}(t) = \\exp(\\mathbf{A} t)\\,\\mathbf{N}(0)$ 和标准浮点运算。数值容差意味着绝对差必须小于或等于 $\\epsilon \\cdot \\max\\{1, |\\mathbf{1}^{\\top}\\mathbf{N}(0)|\\}$。\n\n测试套件（单位：时间 $t$ 以秒计，速率以 $\\text{s}^{-1}$ 计，数密度以任意一致的单位计）：\n- 案例 1 (三同位素线性链，终端同位素稳定): \n  $$\n  \\mathbf{A} = \n  \\begin{bmatrix}\n  -0.1  0  0 \\\\\n  0.1  -0.2  0 \\\\\n  0  0.2  0\n  \\end{bmatrix},\\quad\n  \\mathbf{N}(0) = \n  \\begin{bmatrix}\n  1.0 \\\\ 0.0 \\\\ 0.0\n  \\end{bmatrix},\\quad\n  t = 10.0.\n  $$\n- 案例 2 (五同位素分支网络，终端同位素稳定):\n  $$\n  \\mathbf{A} =\n  \\begin{bmatrix}\n  -0.4  0  0  0  0 \\\\\n  0.28  -0.5  0  0  0 \\\\\n  0.12  0  -0.25  0  0 \\\\\n  0  0.5  0.25  -0.3  0 \\\\\n  0  0  0  0.3  0\n  \\end{bmatrix},\\quad\n  \\mathbf{N}(0) =\n  \\begin{bmatrix}\n  1.0 \\\\ 0.0 \\\\ 0.0 \\\\ 0.0 \\\\ 0.0\n  \\end{bmatrix},\\quad\n  t = 4.0.\n  $$\n- 案例 3 (三同位素循环网络，无稳定终端同位素，闭合循环):\n  $$\n  \\mathbf{A} =\n  \\begin{bmatrix}\n  -5.0  0  3.0 \\\\\n  5.0  -7.0  0 \\\\\n  0  7.0  -3.0\n  \\end{bmatrix},\\quad\n  \\mathbf{N}(0) =\n  \\begin{bmatrix}\n  0.2 \\\\ 0.3 \\\\ 0.5\n  \\end{bmatrix},\\quad\n  t = 1.0.\n  $$\n- 案例 4 (零速率边界情况，恒等演化):\n  $$\n  \\mathbf{A} =\n  \\begin{bmatrix}\n  0  0  0  0 \\\\\n  0  0  0  0 \\\\\n  0  0  0  0 \\\\\n  0  0  0  0\n  \\end{bmatrix},\\quad\n  \\mathbf{N}(0) =\n  \\begin{bmatrix}\n  0.1 \\\\ 0.2 \\\\ 0.3 \\\\ 0.4\n  \\end{bmatrix},\\quad\n  t = 123.0.\n  $$\n- 案例 5 (刚性四同位素线性链，快速转变):\n  $$\n  \\mathbf{A} =\n  \\begin{bmatrix}\n  -100.0  0  0  0 \\\\\n  100.0  -200.0  0  0 \\\\\n  0  200.0  -50.0  0 \\\\\n  0  0  50.0  0\n  \\end{bmatrix},\\quad\n  \\mathbf{N}(0) =\n  \\begin{bmatrix}\n  1.0 \\\\ 0.0 \\\\ 0.0 \\\\ 0.0\n  \\end{bmatrix},\\quad\n  t = 0.1.\n  $$\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。对于每个案例，按顺序输出两个布尔值：首先是 $\\mathbf{1}^{\\top}\\mathbf{A}=\\mathbf{0}^{\\top}$ 的结构验证，然后是 $\\mathbf{1}^{\\top}\\mathbf{N}(t) = \\mathbf{1}^{\\top}\\mathbf{N}(0)$ 的守恒验证。最终输出必须按案例顺序将所有案例的结果聚合到一个扁平列表中，例如 $\\left[\\text{result}_{1,1},\\text{result}_{1,2},\\text{result}_{2,1},\\text{result}_{2,2},\\ldots\\right]$。",
            "solution": "该问题是有效的，因为它具有科学依据、是适定的且客观的。它提出了一个用于同位素嬗变网络的标准模型，并要求进行标准的解析证明和相应的数值验证。所有数据和条件都已提供且一致。\n\n**任务 1：核素守恒的解析证明**\n\n时刻 $t$ 系统中所有同位素的总数密度由总和 $S(t) = \\sum_{i=1}^{n} N_{i}(t)$ 给出。这可以用向量表示法表示为全一向量 $\\mathbf{1} \\in \\mathbb{R}^{n}$ 与数密度向量 $\\mathbf{N}(t) \\in \\mathbb{R}^{n}$ 的点积：\n$$\nS(t) = \\mathbf{1}^{\\top}\\mathbf{N}(t)\n$$\n为证明总数密度不随时间变化，我们必须证明其时间导数对于所有 $t \\geq 0$ 均为零。我们计算 $S(t)$ 对时间 $t$ 的导数：\n$$\n\\frac{dS}{dt} = \\frac{d}{dt} \\left( \\mathbf{1}^{\\top}\\mathbf{N}(t) \\right)\n$$\n由于向量 $\\mathbf{1}$ 由常数项组成，我们可以将微分算子移到点积内部，仅作用于 $\\mathbf{N}(t)$：\n$$\n\\frac{dS}{dt} = \\mathbf{1}^{\\top} \\frac{d\\mathbf{N}}{dt}\n$$\n问题陈述提供了该网络的控制常微分方程（ODE）组：\n$$\n\\frac{d\\mathbf{N}}{dt} = \\mathbf{A}\\,\\mathbf{N}\n$$\n将 $\\mathbf{N}$ 的时间导数的这个表达式代入我们关于 $\\frac{dS}{dt}$ 的方程中，得到：\n$$\n\\frac{dS}{dt} = \\mathbf{1}^{\\top} (\\mathbf{A}\\,\\mathbf{N})\n$$\n使用矩阵-向量乘法的结合律，我们可以将各项重新组合为：\n$$\n\\frac{dS}{dt} = (\\mathbf{1}^{\\top}\\mathbf{A})\\,\\mathbf{N}\n$$\n问题陈述定义了一个封闭网络，其中原子核总数是守恒的。该性质在数学上表示为转移矩阵 $\\mathbf{A}$ 的每一列之和为零的条件。用向量表示法，这被记为 $\\mathbf{1}^{\\top}\\mathbf{A} = \\mathbf{0}^{\\top}$，其中 $\\mathbf{0}^{\\top}$ 是零行向量。将此条件代入我们的方程中得到：\n$$\n\\frac{dS}{dt} = \\mathbf{0}^{\\top} \\mathbf{N}\n$$\n零向量与任何向量 $\\mathbf{N}$ 的点积是标量零：\n$$\n\\frac{dS}{dt} = 0\n$$\n由于 $S(t)$ 的时间导数对于所有 $t \\geq 0$ 都为零，函数 $S(t)$ 必定是一个常数。该常数的值由 $t=0$ 时的初始条件确定。因此，对于所有 $t \\geq 0$：\n$$\nS(t) = S(0)\n$$\n这在向量表示法中正是核素守恒定律：\n$$\n\\mathbf{1}^{\\top}\\mathbf{N}(t) = \\mathbf{1}^{\\top}\\mathbf{N}(0)\n$$\n解析证明到此完成。\n\n**任务 2：数值验证程序**\n\n数值验证包括对每个测试用例进行的两项检查，使用标准浮点运算执行。所有比较的容差为 $\\epsilon = 10^{-10}$。\n\n1.  **结构性质验证**：必须验证条件 $\\mathbf{1}^{\\top}\\mathbf{A} = \\mathbf{0}^{\\top}$。这等同于检查矩阵 $\\mathbf{A}$ 的每一列之和是否为零。对于从 $1$ 到 $n$ 的每一列 $j$，我们计算其和 $c_j = \\sum_{i=1}^{n} \\mathbf{A}_{ij}$。如果每一列和的绝对值小于或等于绝对容差 $\\epsilon$，则验证测试成功：\n    $$\n    |c_j| \\le \\epsilon \\quad \\text{for all } j \\in \\{1, 2, \\ldots, n\\}\n    $$\n\n2.  **核素守恒验证**：必须验证守恒定律 $\\mathbf{1}^{\\top}\\mathbf{N}(t) = \\mathbf{1}^{\\top}\\mathbf{N}(0)$。这涉及以下步骤：\n    a.  计算初始总数密度，$S_0 = \\mathbf{1}^{\\top}\\mathbf{N}(0) = \\sum_{i=1}^{n} N_i(0)$。\n    b.  线性 ODE 系统的解由 $\\mathbf{N}(t) = \\exp(\\mathbf{A}t)\\mathbf{N}(0)$ 给出，其中 $\\exp(\\cdot)$ 是矩阵指数。首先计算矩阵 $\\mathbf{A}t$，然后计算其指数，这将使用 `scipy.linalg.expm` 函数来执行。\n    c.  通过将得到的矩阵 $\\exp(\\mathbf{A}t)$ 与初始条件向量 $\\mathbf{N}(0)$ 相乘，计算出时刻 $t$ 的数密度向量 $\\mathbf{N}(t)$。\n    d.  计算最终总数密度，$S_t = \\mathbf{1}^{\\top}\\mathbf{N}(t) = \\sum_{i=1}^{n} N_i(t)$。\n    e.  如果 $S_t$ 和 $S_0$ 之间的绝对差在指定的容差界限内，则验证测试成功。容差规则定义为：\n    $$\n    |S_t - S_0| \\le \\epsilon \\cdot \\max\\{1, |S_0|\\}\n    $$\n这种混合绝对-相对容差准则能恰当地处理初始总和 $S_0$ 可能很小或为零的情况。\n\n以下 Python 实现将对所有指定的测试用例执行这两项验证，并报告布尔结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import expm\n\ndef solve():\n    \"\"\"\n    Solves the isotope transmutation problem by performing an analytical proof\n    and numerical verification for several test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (three-isotope linear chain, stable terminal isotope)\n        (\n            np.array([\n                [-0.1, 0.0, 0.0],\n                [0.1, -0.2, 0.0],\n                [0.0, 0.2, 0.0]\n            ]),\n            np.array([1.0, 0.0, 0.0]),\n            10.0\n        ),\n        # Case 2 (five-isotope branching network, stable terminal isotope)\n        (\n            np.array([\n                [-0.4, 0.0, 0.0, 0.0, 0.0],\n                [0.28, -0.5, 0.0, 0.0, 0.0],\n                [0.12, 0.0, -0.25, 0.0, 0.0],\n                [0.0, 0.5, 0.25, -0.3, 0.0],\n                [0.0, 0.0, 0.0, 0.3, 0.0]\n            ]),\n            np.array([1.0, 0.0, 0.0, 0.0, 0.0]),\n            4.0\n        ),\n        # Case 3 (three-isotope cyclic network, no stable terminal isotope)\n        (\n            np.array([\n                [-5.0, 0.0, 3.0],\n                [5.0, -7.0, 0.0],\n                [0.0, 7.0, -3.0]\n            ]),\n            np.array([0.2, 0.3, 0.5]),\n            1.0\n        ),\n        # Case 4 (zero-rate boundary case, identity evolution)\n        (\n            np.array([\n                [0.0, 0.0, 0.0, 0.0],\n                [0.0, 0.0, 0.0, 0.0],\n                [0.0, 0.0, 0.0, 0.0],\n                [0.0, 0.0, 0.0, 0.0]\n            ]),\n            np.array([0.1, 0.2, 0.3, 0.4]),\n            123.0\n        ),\n        # Case 5 (stiff four-isotope linear chain, fast transitions)\n        (\n            np.array([\n                [-100.0, 0.0, 0.0, 0.0],\n                [100.0, -200.0, 0.0, 0.0],\n                [0.0, 200.0, -50.0, 0.0],\n                [0.0, 0.0, 50.0, 0.0]\n            ]),\n            np.array([1.0, 0.0, 0.0, 0.0]),\n            0.1\n        ),\n    ]\n\n    results = []\n    epsilon = 1e-10\n\n    for A, N0, t in test_cases:\n        # 1. Structural Verification: Check if 1^T * A = 0^T\n        # This is equivalent to checking if the sum of each column is zero.\n        column_sums = np.sum(A, axis=0)\n        # The check is against an absolute tolerance epsilon, as the target is 0.\n        structural_property_holds = np.all(np.abs(column_sums) = epsilon)\n        results.append(structural_property_holds)\n\n        # 2. Species Conservation Verification: Check if 1^T * N(t) = 1^T * N(0)\n        # Calculate initial total number density\n        S0 = np.sum(N0)\n\n        # Calculate N(t) = exp(A*t) * N(0)\n        At = A * t\n        exp_At = expm(At)\n        Nt = exp_At @ N0\n\n        # Calculate final total number density\n        St = np.sum(Nt)\n\n        # Define the tolerance based on the problem specification\n        tolerance = epsilon * max(1.0, abs(S0))\n        \n        conservation_holds = np.abs(St - S0) = tolerance\n        results.append(conservation_holds)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "除了求解核素库存量，反应堆分析中的一个关键任务是理解输出量如何响应输入数据的变化。这个高级实践介绍了伴随灵敏度分析方法，这是一种计算此类灵敏度的高效技术 。通过聚焦于关键的碘-氙链，您将推导并实现一个基于伴随方法的计算，这是现代反应堆设计、优化和不确定性量化的基石。",
            "id": "4254355",
            "problem": "您的任务是推导、实现并测试一个基于伴随方法的灵敏度分析。该分析针对一个代表核反应堆中恒定辐照下碘-135和氙-135存量的双核素 Bateman 系统。目标是时间步末的氙-135存量，关心的参数是氙-135的微观中子俘获截面。在该时间区间内，所有物理参数均不随时间变化。\n\n基本原理：使用 Bateman 衰变方程作为核素演化的控制律。该方程指出，每种核素存量的时间变化率等于其所有产生率之和减去其所有移除率之和。产生和移除机制包括放射性衰变、恒定中子通量下的中子诱发反应，以及在整个时间步内建模为恒定源项的裂变产额。\n\n正向模型定义：考虑状态向量 $\\mathbf{N}(t) = \\begin{bmatrix} N_{135\\mathrm{I}}(t) \\\\ N_{135\\mathrm{Xe}}(t) \\end{bmatrix}$，其中 $N_{135\\mathrm{I}}(t)$ 和 $N_{135\\mathrm{Xe}}(t)$ 分别是时刻 $t$ 的碘-135和氙-135的原子数。控制常微分方程为\n$$\n\\frac{d}{dt}\\mathbf{N}(t) = \\mathbf{A}(\\sigma_{135\\mathrm{Xe}})\\,\\mathbf{N}(t) + \\mathbf{s},\n$$\n其中\n$$\n\\mathbf{A}(\\sigma_{135\\mathrm{Xe}}) = \n\\begin{bmatrix}\n-\\lambda_{135\\mathrm{I}}  0 \\\\\n\\lambda_{135\\mathrm{I}}  -\\lambda_{135\\mathrm{Xe}} - \\phi\\,\\sigma_{135\\mathrm{Xe}}\n\\end{bmatrix},\n\\quad\n\\mathbf{s} = \n\\begin{bmatrix}\ny_{135\\mathrm{I}}\\,R_f \\\\\ny_{135\\mathrm{Xe}}\\,R_f\n\\end{bmatrix}.\n$$\n此处，$\\lambda_{135\\mathrm{I}}$ 和 $\\lambda_{135\\mathrm{Xe}}$ 是衰变常数，$\\phi$ 是恒定中子通量，$\\sigma_{135\\mathrm{Xe}}$ 是氙-135的微观俘获截面， $y_{135\\mathrm{I}}$ 和 $y_{135\\mathrm{Xe}}$ 是碘-135和氙-135的独立裂变产额， $R_f$ 是总裂变率。$t=0$ 时的初始条件为 $\\mathbf{N}(0) = \\begin{bmatrix} N_{135\\mathrm{I}}(0) \\\\ N_{135\\mathrm{Xe}}(0) \\end{bmatrix}$。\n\n目标泛函：令关心量为时间步末的氙存量\n$$\nJ(\\sigma_{135\\mathrm{Xe}}) = N_{135\\mathrm{Xe}}(T),\n$$\n其中 $T$ 是最终时间。\n\n灵敏度目标：从第一性原理出发，不使用预先编译的灵敏度公式，推导与正向系统和目标 $J$ 相关的连续伴随方程，并在假设 $\\phi$ 恒定且 $\\mathbf{s}$ 不依赖于 $\\sigma_{135\\mathrm{Xe}}$ 的条件下，推导梯度 $\\frac{dJ}{d\\sigma_{135\\mathrm{Xe}}}$ 的数学正确表达式。\n\n实现任务：实现一个程序，该程序能够\n- 对给定的参数，在 $t\\in[0,T]$ 上求解 $\\mathbf{N}(t)$ 的正向问题。\n- 使用推导出的方程，在 $t\\in[0,T]$ 上向后求解连续伴随问题。\n- 使用推导出的伴随灵敏度表达式计算梯度 $\\frac{dJ}{d\\sigma_{135\\mathrm{Xe}}}$。\n- 通过对 $\\sigma_{135\\mathrm{Xe}}$ 施加足够小的扰动，使用中心有限差分近似来验证梯度 $\\frac{dJ}{d\\sigma_{135\\mathrm{Xe}}}$。\n- 对每个测试用例，比较伴随梯度和有限差分梯度，并返回一个布尔值，指示它们是否在指定容差范围内一致。\n\n物理单位和数值要求：\n- 时间 $t$ 和 $T$ 的单位必须是秒。\n- 中子通量 $\\phi$ 的单位必须是 中子/平方厘米/秒。\n- 截面 $\\sigma_{135\\mathrm{Xe}}$ 的单位必须是平方厘米。\n- 存量 $N_{135\\mathrm{I}}$ 和 $N_{135\\mathrm{Xe}}$ 的单位必须是原子数。\n- 裂变率 $R_f$ 的单位必须是 裂变/秒。\n- 衰变常数 $\\lambda_{135\\mathrm{I}}$ 和 $\\lambda_{135\\mathrm{Xe}}$ 的单位必须是 1/秒。\n- 裂变产额 $y_{135\\mathrm{I}}$ 和 $y_{135\\mathrm{Xe}}$ 是无量纲的（每次裂变产生的原子数）。\n\n测试套件：您的程序必须评估以下参数集。在每种情况下，伴随梯度和有限差分梯度一致性的容差为 $10^{-4}$ 的相对误差，或者当两个梯度都接近零时，为 $10^{-12}$ 的绝对误差。\n\n- 用例 1（典型辐照，非零产额）：\n  - $\\lambda_{135\\mathrm{I}} = \\ln(2)/23760\\ \\mathrm{s}^{-1}$,\n  - $\\lambda_{135\\mathrm{Xe}} = \\ln(2)/32800\\ \\mathrm{s}^{-1}$,\n  - $\\phi = 10^{13}\\ \\mathrm{n}/\\mathrm{cm}^2/\\mathrm{s}$,\n  - $\\sigma_{135\\mathrm{Xe}} = 2\\times 10^{-18}\\ \\mathrm{cm}^2$,\n  - $y_{135\\mathrm{I}} = 0.063$,\n  - $y_{135\\mathrm{Xe}} = 0.002$,\n  - $R_f = 10^{18}\\ \\mathrm{s}^{-1}$,\n  - $N_{135\\mathrm{I}}(0) = 0\\ \\mathrm{atoms}$,\n  - $N_{135\\mathrm{Xe}}(0) = 0\\ \\mathrm{atoms}$,\n  - $T = 43200\\ \\mathrm{s}$。\n\n- 用例 2（零通量边界）：\n  - 与用例 1 相同，除了 $\\phi = 0\\ \\mathrm{n}/\\mathrm{cm}^2/\\mathrm{s}$ 和 $T = 43200\\ \\mathrm{s}$。\n\n- 用例 3（零时间边界）：\n  - 与用例 1 相同，除了 $T = 0\\ \\mathrm{s}$。\n\n- 用例 4（预装载氙，无产额）：\n  - $\\lambda_{135\\mathrm{I}} = \\ln(2)/23760\\ \\mathrm{s}^{-1}$,\n  - $\\lambda_{135\\mathrm{Xe}} = \\ln(2)/32800\\ \\mathrm{s}^{-1}$,\n  - $\\phi = 5\\times 10^{13}\\ \\mathrm{n}/\\mathrm{cm}^2/\\mathrm{s}$,\n  - $\\sigma_{135\\mathrm{Xe}} = 2\\times 10^{-18}\\ \\mathrm{cm}^2$,\n  - $y_{135\\mathrm{I}} = 0$,\n  - $y_{135\\mathrm{Xe}} = 0$,\n  - $R_f = 0\\ \\mathrm{s}^{-1}$,\n  - $N_{135\\mathrm{I}}(0) = 0\\ \\mathrm{atoms}$,\n  - $N_{135\\mathrm{Xe}}(0) = 10^{20}\\ \\mathrm{atoms}$,\n  - $T = 3600\\ \\mathrm{s}$。\n\n最终输出格式：您的程序应生成单行输出，其中包含四个测试用例的结果，格式为一个由方括号括起来的逗号分隔的布尔值列表（例如，$[\\mathrm{True},\\mathrm{False},\\mathrm{True},\\mathrm{True}]$）。每个布尔值指示伴随方法计算的梯度 $\\frac{dJ}{d\\sigma_{135\\mathrm{Xe}}}$ 是否在该用例的指定容差下与有限差分近似值一致。",
            "solution": "用户在核反应堆物理领域提供了一个定义明确的问题，具体要求对一个简化的双核素损耗系统推导并实现基于伴随方法的灵敏度分析。\n\n### 第 1 步：提取已知条件\n- **状态向量：** $\\mathbf{N}(t) = \\begin{bmatrix} N_{135\\mathrm{I}}(t) \\\\ N_{135\\mathrm{Xe}}(t) \\end{bmatrix}$ 代表碘-135和氙-135的存量。\n- **控制方程（正向模型）：** $\\frac{d}{dt}\\mathbf{N}(t) = \\mathbf{A}(\\sigma_{135\\mathrm{Xe}})\\,\\mathbf{N}(t) + \\mathbf{s}$。\n- **损耗矩阵：** $\\mathbf{A}(\\sigma_{135\\mathrm{Xe}}) = \\begin{bmatrix} -\\lambda_{135\\mathrm{I}}  0 \\\\ \\lambda_{135\\mathrm{I}}  -\\lambda_{135\\mathrm{Xe}} - \\phi\\,\\sigma_{135\\mathrm{Xe}} \\end{bmatrix}$。\n- **源向量：** $\\mathbf{s} = \\begin{bmatrix} y_{135\\mathrm{I}}\\,R_f \\\\ y_{135\\mathrm{Xe}}\\,R_f \\end{bmatrix}$。\n- **初始条件：** $\\mathbf{N}(0) = \\begin{bmatrix} N_{135\\mathrm{I}}(0) \\\\ N_{135\\mathrm{Xe}}(0) \\end{bmatrix}$。\n- **目标泛函：** $J(\\sigma_{135\\mathrm{Xe}}) = N_{135\\mathrm{Xe}}(T)$。\n- **关心参数：** $\\alpha = \\sigma_{135\\mathrm{Xe}}$，氙-135的微观俘获截面。\n- **约束/假设：** $\\phi$ 是恒定的；$\\mathbf{s}$ 不依赖于 $\\sigma_{135\\mathrm{Xe}}$。\n- **目标：** 推导并实现连续伴随方程以求得梯度 $\\frac{dJ}{d\\sigma_{135\\mathrm{Xe}}}$。\n- **验证：** 将伴随法推导的梯度与中心有限差分近似进行比较。\n- **测试用例：** 提供了四组特定的物理参数和条件用于测试。\n- **容差：** 一致性定义为相对误差小于 $10^{-4}$，或在梯度接近零时绝对误差小于 $10^{-12}$。\n\n### 第 2 步：使用提取的已知条件进行验证\n根据指定标准对问题进行验证。\n- **科学依据：** 该问题使用 Bateman 方程描述碘-氙链，这是反应堆物理学中的一个基石模型。方程、参数和物理背景都是标准的，且符合事实。\n- **适定性：** 该问题是一个标准的常系数线性常微分方程组的初值问题，是适定的。目标和灵敏度参数定义清晰，确保可以推导和计算出唯一且有意义的解。\n- **目标：** 问题陈述使用了精确的数学和物理术语，没有歧义或主观内容。\n- **缺陷检查表：** 该问题未违反任何指定的无效标准。它具有科学合理性、可形式化、完整性、物理现实性和良好结构。特殊情况（$T=0$ 和 $\\phi=0$）是有效的，并且对验证很有用。\n\n### 第 3 步：结论和行动\n问题是**有效的**。将逐步制定解决方案。\n\n### 伴随方程和灵敏度表达式的推导\n\n推导从第一性原理出发，使用拉格朗日乘子法（也称为伴随方法）对由常微分方程（ODE）控制的系统进行灵敏度分析。\n\n**1. 正向问题和目标泛函**\n系统由以下正向问题描述：\n$$\n\\frac{d\\mathbf{N}}{dt} = \\mathbf{A}(\\alpha)\\mathbf{N}(t) + \\mathbf{s}, \\quad \\mathbf{N}(0) = \\mathbf{N}_0\n$$\n其中 $\\alpha = \\sigma_{135\\mathrm{Xe}}$ 是关心的参数。目标泛函是最终时间 $T$ 时的氙-135存量：\n$$\nJ(\\alpha) = N_{135\\mathrm{Xe}}(T) = \\mathbf{h}^T\\mathbf{N}(T), \\quad \\text{其中} \\quad \\mathbf{h} = \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix}\n$$\n\n**2. 拉格朗日公式**\n我们引入一个任意的矢量值时间函数，即伴随状态向量 $\\mathbf{N}^*(t)$，并构造增广泛函或拉格朗日量 $\\mathcal{L}$：\n$$\n\\mathcal{L}(\\mathbf{N}, \\mathbf{N}^*, \\alpha) = J(\\mathbf{N}(T), \\alpha) - \\int_0^T (\\mathbf{N}^*(t))^T \\left( \\frac{d\\mathbf{N}}{dt} - \\mathbf{A}(\\alpha)\\mathbf{N}(t) - \\mathbf{s} \\right) dt\n$$\n如果 $\\mathbf{N}(t)$ 是正向方程的解，则括号中的项为零，因此 $\\mathcal{L} = J$。因此，我们可以通过计算 $\\mathcal{L}$ 的全导数来计算 $J$ 相对于 $\\alpha$ 的全导数。\n\n**3. 变分法**\n我们寻求 $\\mathcal{L}$ 相对于状态向量 $\\mathbf{N}$ 变化的变分。对包含 $\\frac{d\\mathbf{N}}{dt}$ 的项使用分部积分法：\n$$\n\\int_0^T (\\mathbf{N}^*)^T \\frac{d\\mathbf{N}}{dt} dt = \\left[(\\mathbf{N}^*)^T\\mathbf{N}\\right]_0^T - \\int_0^T \\left(\\frac{d\\mathbf{N}^*}{dt}\\right)^T\\mathbf{N} dt\n$$\n将此代入拉格朗日量得到：\n$$\n\\mathcal{L} = \\mathbf{h}^T\\mathbf{N}(T) - \\left( (\\mathbf{N}^*(T))^T\\mathbf{N}(T) - (\\mathbf{N}^*(0))^T\\mathbf{N}(0) \\right) + \\int_0^T \\left( \\left(\\frac{d\\mathbf{N}^*}{dt}\\right)^T\\mathbf{N} + (\\mathbf{N}^*)^T(\\mathbf{A}\\mathbf{N} + \\mathbf{s}) \\right) dt\n$$\n重新整理各项：\n$$\n\\mathcal{L} = \\left(\\mathbf{h}^T - (\\mathbf{N}^*(T))^T\\right)\\mathbf{N}(T) + (\\mathbf{N}^*(0))^T\\mathbf{N}(0) + \\int_0^T \\left( \\left(\\frac{d\\mathbf{N}^*}{dt}\\right)^T + (\\mathbf{N}^*)^T\\mathbf{A} \\right)\\mathbf{N} dt + \\int_0^T (\\mathbf{N}^*)^T\\mathbf{s} dt\n$$\n伴随方法的核心思想是选择 $\\mathbf{N}^*(t)$ 以消除涉及 $\\mathbf{N}$ 灵敏度（即 $\\frac{d\\mathbf{N}}{d\\alpha}$）的项。通过将 $\\mathcal{L}$ 表达式中 $\\mathbf{N}$ 的系数设为零，我们定义了伴随系统。这种选择确保了 $\\mathcal{L}$ 相对于 $\\mathbf{N}$ 的变分为零。这导致了以下伴随状态向量 $\\mathbf{N}^*$ 的方程组：\n\n- **伴随 ODE：** 对于所有 $t \\in (0, T)$，积分内乘以 $\\mathbf{N}(t)$ 的项必须为零：\n  $$\n  \\left(\\frac{d\\mathbf{N}^*}{dt}\\right)^T + (\\mathbf{N}^*)^T\\mathbf{A} = 0 \\quad \\implies \\quad \\frac{d\\mathbf{N}^*}{dt} + \\mathbf{A}^T\\mathbf{N}^* = \\mathbf{0}\n  $$\n- **伴随终值条件：** 在 $t=T$ 处乘以 $\\mathbf{N}(T)$ 的边界项必须为零：\n  $$\n  \\mathbf{h}^T - (\\mathbf{N}^*(T))^T = 0 \\quad \\implies \\quad \\mathbf{N}^*(T) = \\mathbf{h} = \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix}\n  $$\n在 $t=0$ 处的项涉及 $\\mathbf{N}(0)$，它是一个固定的初始条件，而不是优化中的变量，因此其变分为零。所得系统是关于 $\\mathbf{N}^*$ 的一个终值问题，通常通过从 $t=T$ 到 $t=0$ 的时间逆向积分来求解。\n\n**4. 灵敏度表达式**\n如此定义伴随系统后，泛函 $J$ 对参数 $\\alpha$ 的全导数就是拉格朗日量 $\\mathcal{L}$ 对 $\\alpha$ 的偏导数：\n$$\n\\frac{dJ}{d\\alpha} = \\frac{\\partial\\mathcal{L}}{\\partial\\alpha} = \\frac{\\partial J}{\\partial \\alpha} + \\int_0^T (\\mathbf{N}^*)^T \\left( \\frac{\\partial\\mathbf{A}}{\\partial\\alpha}\\mathbf{N} + \\frac{\\partial\\mathbf{s}}{\\partial\\alpha} \\right) dt\n$$\n在我们的特定问题中，$J = N_{135\\mathrm{Xe}}(T)$ 不显式依赖于 $\\alpha = \\sigma_{135\\mathrm{Xe}}$，因此 $\\frac{\\partial J}{\\partial \\alpha} = 0$。源向量 $\\mathbf{s}$ 也被给定为独立于 $\\alpha$，因此 $\\frac{\\partial\\mathbf{s}}{\\partial\\alpha} = \\mathbf{0}$。灵敏度表达式简化为：\n$$\n\\frac{dJ}{d\\alpha} = \\int_0^T (\\mathbf{N}^*(t))^T \\frac{\\partial\\mathbf{A}}{\\partial\\alpha} \\mathbf{N}(t) dt\n$$\n我们需要矩阵 $\\mathbf{A}$ 对 $\\alpha = \\sigma_{135\\mathrm{Xe}}$ 的偏导数：\n$$\n\\mathbf{A}(\\sigma_{135\\mathrm{Xe}}) = \\begin{bmatrix} -\\lambda_{135\\mathrm{I}}  0 \\\\ \\lambda_{135\\mathrm{I}}  -\\lambda_{135\\mathrm{Xe}} - \\phi\\,\\sigma_{135\\mathrm{Xe}} \\end{bmatrix} \\quad \\implies \\quad \\frac{\\partial\\mathbf{A}}{\\partial\\sigma_{135\\mathrm{Xe}}} = \\begin{bmatrix} 0  0 \\\\ 0  -\\phi \\end{bmatrix}\n$$\n将此代入灵敏度公式：\n$$\n\\frac{dJ}{d\\sigma_{135\\mathrm{Xe}}} = \\int_0^T \\begin{bmatrix} N_{135\\mathrm{I}}^*(t)  N_{135\\mathrm{Xe}}^*(t) \\end{bmatrix} \\begin{bmatrix} 0  0 \\\\ 0  -\\phi \\end{bmatrix} \\begin{bmatrix} N_{135\\mathrm{I}}(t) \\\\ N_{135\\mathrm{Xe}}(t) \\end{bmatrix} dt\n$$\n$$\n\\frac{dJ}{d\\sigma_{135\\mathrm{Xe}}} = \\int_0^T (-\\phi) N_{135\\mathrm{Xe}}^*(t) N_{135\\mathrm{Xe}}(t) dt\n$$\n这就是灵敏度的最终表达式。它表明，最终氙存量对其自身俘获截面的灵敏度是正向氙存量、伴随氙存量（或“重要性”）以及中子通量负值三者乘积的时间积分。\n\n### 实现策略\n计算和验证灵敏度的算法如下：\n1.  **正向求解：** 从 $t=0$ 到 $t=T$ 求解初始条件为 $\\mathbf{N}(0)=\\mathbf{N}_0$ 的正向 ODE 系统 $\\frac{d\\mathbf{N}}{dt} = \\mathbf{A}\\mathbf{N} + \\mathbf{s}$。这通过使用 `scipy.integrate.solve_ivp` 来完成。解 $\\mathbf{N}(t)$ 被存储为密集输出（一个插值函数）。\n2.  **伴随求解：** 从 $t=T$ 到 $t=0$ 求解终值条件为 $\\mathbf{N}^*(T) = \\mathbf{h}$ 的伴随 ODE 系统 $\\frac{d\\mathbf{N}^*}{dt} = -\\mathbf{A}^T\\mathbf{N}^*$。这种时间逆向积分也由 `scipy.integrate.solve_ivp` 处理，只需将时间跨度指定为 $[T, 0]$。解 $\\mathbf{N}^*(t)$ 也被存储为密集输出。\n3.  **伴随梯度计算：** 使用数值积分方法 `scipy.integrate.quad` 计算灵敏度的定积分 $\\frac{dJ}{d\\sigma_{135\\mathrm{Xe}}} = -\\int_0^T \\phi N_{135\\mathrm{Xe}}(t) N_{135\\mathrm{Xe}}^*(t) dt$。被积函数是使用插值的正向解和伴随解构造的。\n4.  **有限差分梯度计算：** 为了验证结果，使用中心有限差分格式来近似梯度：\n    $$\n    \\frac{dJ}{d\\sigma_{135\\mathrm{Xe}}} \\approx \\frac{J(\\sigma_{135\\mathrm{Xe}} + h) - J(\\sigma_{135\\mathrm{Xe}} - h)}{2h}\n    $$\n    其中 $h$ 是一个小扰动。这需要用扰动后的截面 $\\sigma_{135\\mathrm{Xe}} \\pm h$ 再次求解正向问题两次。一个相对扰动，例如 $h = 10^{-7}\\sigma_{135\\mathrm{Xe}}$，是合适的。\n5.  **比较：** 使用问题陈述中指定的相对和绝对误差容差，比较伴随方法得到的梯度与有限差分近似值。为每个测试用例生成一个布尔结果。\n\n提供的 Python 代码实现了这个完整的算法。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp, quad\nimport math\n\ndef calculate_sensitivity(params: dict):\n    \"\"\"\n    Calculates the adjoint and finite-difference sensitivity for a given set of parameters.\n    \"\"\"\n    # Unpack parameters\n    lambda_i = params['lambda_i']\n    lambda_xe = params['lambda_xe']\n    phi = params['phi']\n    sigma_xe = params['sigma_xe']\n    y_i = params['y_i']\n    y_xe = params['y_xe']\n    R_f = params['R_f']\n    N_i_0 = params['N_i_0']\n    N_xe_0 = params['N_xe_0']\n    T = params['T']\n\n    # Handle the T=0 edge case where the integral is zero.\n    if T == 0:\n        # J = N_xe(0), which is independent of sigma_xe. Gradient is 0.\n        # Adjoint integral is over [0,0], which is 0.\n        return 0.0, 0.0\n\n    # ----- 1. Forward Problem -----\n    # dN/dt = A * N + s\n    A = np.array([\n        [-lambda_i, 0],\n        [lambda_i, -lambda_xe - phi * sigma_xe]\n    ])\n    s = np.array([y_i * R_f, y_xe * R_f])\n    N0 = np.array([N_i_0, N_xe_0])\n\n    def forward_rhs(t, N):\n        return A @ N + s\n\n    # Solve from t=0 to t=T\n    sol_forward = solve_ivp(forward_rhs, [0, T], N0, dense_output=True, method='RK45', rtol=1e-9, atol=1e-9)\n    N_func = sol_forward.sol\n\n    # ----- 2. Adjoint Problem -----\n    # dN*/dt = -A.T * N*, with N*(T) = h\n    h = np.array([0, 1])  # For objective J = N_xe(T)\n    A_T = A.T\n    def adjoint_rhs(t, N_star):\n        return -A_T @ N_star\n\n    # Solve backwards in time from T to 0\n    sol_adjoint = solve_ivp(adjoint_rhs, [T, 0], h, dense_output=True, method='RK45', rtol=1e-9, atol=1e-9)\n    N_star_func = sol_adjoint.sol\n\n    # ----- 3. Adjoint-based Sensitivity Calculation -----\n    # dJ/d(sigma_xe) = integral_0^T (N*)^T @ (dA/d(sigma_xe)) @ N dt\n    # (dA/d(sigma_xe)) is [[0, 0], [0, -phi]]\n    # The integrand is -phi * N_xe*(t) * N_xe(t)\n    \n    if phi == 0:\n        adjoint_gradient = 0.0\n    else:\n        def integrand(t):\n            N_t = N_func(t)\n            N_star_t = N_star_func(t)\n            return -phi * N_star_t[1] * N_t[1]\n\n        adjoint_gradient, _ = quad(integrand, 0, T)\n\n    # ----- 4. Finite Difference Sensitivity Verification -----\n    def get_J(sigma_xe_perturbed):\n        A_p = np.array([\n            [-lambda_i, 0],\n            [lambda_i, -lambda_xe - phi * sigma_xe_perturbed]\n        ])\n        def forward_rhs_p(t, N):\n            return A_p @ N + s\n        \n        # Use high precision for FD calculation\n        sol_p = solve_ivp(forward_rhs_p, [0, T], N0, method='RK45', rtol=1e-11, atol=1e-11)\n        return sol_p.y[1, -1] # Return N_xe(T)\n\n    # Use a small relative step for perturbation\n    h_fd = 1e-7 * sigma_xe if sigma_xe != 0 else 1e-24\n\n    J_plus = get_J(sigma_xe + h_fd)\n    J_minus = get_J(sigma_xe - h_fd)\n    \n    fd_gradient = (J_plus - J_minus) / (2 * h_fd)\n\n    return adjoint_gradient, fd_gradient\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        # Case 1: typical irradiation, nonzero production\n        {\n            'lambda_i': math.log(2) / 23760,\n            'lambda_xe': math.log(2) / 32800,\n            'phi': 1e13,\n            'sigma_xe': 2e-18,\n            'y_i': 0.063,\n            'y_xe': 0.002,\n            'R_f': 1e18,\n            'N_i_0': 0.0,\n            'N_xe_0': 0.0,\n            'T': 43200.0,\n        },\n        # Case 2: zero flux boundary\n        {\n            'lambda_i': math.log(2) / 23760,\n            'lambda_xe': math.log(2) / 32800,\n            'phi': 0.0,\n            'sigma_xe': 2e-18,\n            'y_i': 0.063,\n            'y_xe': 0.002,\n            'R_f': 1e18,\n            'N_i_0': 0.0,\n            'N_xe_0': 0.0,\n            'T': 43200.0,\n        },\n        # Case 3: zero time boundary\n        {\n            'lambda_i': math.log(2) / 23760,\n            'lambda_xe': math.log(2) / 32800,\n            'phi': 1e13,\n            'sigma_xe': 2e-18,\n            'y_i': 0.063,\n            'y_xe': 0.002,\n            'R_f': 1e18,\n            'N_i_0': 0.0,\n            'N_xe_0': 0.0,\n            'T': 0.0,\n        },\n        # Case 4: preloaded xenon, no production\n        {\n            'lambda_i': math.log(2) / 23760,\n            'lambda_xe': math.log(2) / 32800,\n            'phi': 5e13,\n            'sigma_xe': 2e-18,\n            'y_i': 0.0,\n            'y_xe': 0.0,\n            'R_f': 0.0,\n            'N_i_0': 0.0,\n            'N_xe_0': 1e20,\n            'T': 3600.0,\n        }\n    ]\n\n    results = []\n    rel_tol = 1e-4\n    abs_tol = 1e-12\n\n    for case in test_cases:\n        adjoint_grad, fd_grad = calculate_sensitivity(case)\n        \n        # Check for agreement based on problem specification\n        # Use FD gradient as the reference value for what is \"near zero\"\n        if abs(fd_grad)  abs_tol:\n            is_agreed = abs(adjoint_grad - fd_grad)  abs_tol\n        else:\n            relative_error = abs((adjoint_grad - fd_grad) / fd_grad)\n            is_agreed = relative_error  rel_tol\n        \n        results.append(is_agreed)\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}