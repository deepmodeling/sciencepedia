{
    "hands_on_practices": [
        {
            "introduction": "化学机械平坦化（CMP）的一个核心特性是其平坦化不同尺寸图形的能力。本练习将通过一个解析推导，深入探讨平坦化效率这一基本概念。通过对一个简单的正弦形貌进行建模，我们将推导出平坦化效率与图形波长及平坦化长度之间的关系，从而揭示CMP为何能像一个低通滤波器一样，更有效地去除短波长（高频）的形貌特征。",
            "id": "4114474",
            "problem": "一片正在进行化学机械平坦化（CMP）的晶圆，其在一个空间维度上由相对于瞬时平均平面的高度场 $h(x,t)$ 建模。材料去除遵循普雷斯顿方程（Preston's equation）给出的局部去除速率 $RR = k P V$，其中 $k$ 是普雷斯顿系数，$P$ 是局部接触压力，$V$ 是相对滑动速度。施加的压力有一个均匀分量 $P_{0}$ 和一个由柔度引起的扰动 $\\delta p(x,t)$，使得 $P(x,t) = P_{0} + \\delta p(x,t)$。因此，高度 $h(x,t)$ 相对于平均平面的偏差的演化遵循 $\\partial h/\\partial t = -k V\\,\\delta p(x,t)$。为了描述抛光垫的横向应力再分布，假设一个由特征平坦化长度 $L$ 正则化的线性弹性基底，这在小斜率区域内得到了压力对高度的响应，即一维亥姆霍兹型关系\n$$\n\\left(1 - L^{2}\\frac{\\partial^{2}}{\\partial x^{2}}\\right)\\delta p(x,t) = S\\left(-\\frac{\\partial^{2} h(x,t)}{\\partial x^{2}}\\right),\n$$\n其中 $S$ 是一个有效刚度参数，关联了局部曲率和局部压力。\n假设初始形貌是正弦形的，$h(x,0) = H_{0}\\sin\\!\\left(2\\pi x/\\lambda\\right)$，并保持正弦形式，但振幅 $H(t)$ 随时间变化，即 $h(x,t) = H(t)\\sin\\!\\left(2\\pi x/\\lambda\\right)$。定义平坦化效率 $\\eta$ 为正弦振幅的分数衰减率与全面去除速率之比，\n$$\n\\eta \\equiv \\frac{-\\frac{1}{H}\\frac{\\mathrm{d}H}{\\mathrm{d}t}}{k P_{0} V}.\n$$\n推导 $\\eta$ 作为波长 $\\lambda$、平坦化长度 $L$ 和模型参数的函数的闭合形式解析表达式。此外，使用您推导的表达式，在渐近区域 $\\lambda \\gg L$ 和 $\\lambda \\ll L$ 中推断 $\\eta$ 随 $\\lambda$ 的标度关系。将您关于 $\\eta(\\lambda)$ 的最终答案表示为单个闭合形式的解析表达式。无需进行数值计算。",
            "solution": "在尝试求解之前，对问题进行验证。\n\n### 问题验证\n\n**步骤1：提取已知条件**\n- 高度场：$h(x,t)$\n- 局部去除速率的普雷斯顿方程：$RR = k P V$\n- 普雷斯顿系数：$k$\n- 局部接触压力：$P(x,t) = P_{0} + \\delta p(x,t)$\n- 均匀压力分量：$P_{0}$\n- 压力扰动：$\\delta p(x,t)$\n- 相对滑动速度：$V$\n- 高度偏差的演化方程：$\\frac{\\partial h}{\\partial t} = -k V\\,\\delta p(x,t)$\n- 压力-高度关系：$\\left(1 - L^{2}\\frac{\\partial^{2}}{\\partial x^{2}}\\right)\\delta p(x,t) = S\\left(-\\frac{\\partial^{2} h(x,t)}{\\partial x^{2}}\\right)$\n- 平坦化长度：$L$\n- 有效刚度：$S$\n- 初始形貌：$h(x,0) = H_{0}\\sin\\!\\left(\\frac{2\\pi x}{\\lambda}\\right)$\n- 假设的解形式：$h(x,t) = H(t)\\sin\\!\\left(\\frac{2\\pi x}{\\lambda}\\right)$\n- 平坦化效率定义：$\\eta \\equiv \\frac{-\\frac{1}{H}\\frac{\\mathrm{d}H}{\\mathrm{d}t}}{k P_{0} V}$\n\n**步骤2：使用提取的已知条件进行验证**\n该问题提出了一个用于化学机械平坦化（CMP）的公认但简化的连续介质模型。\n- **科学依据（关键）：** 该模型牢固地基于半导体制造领域的公认原理。普雷斯顿方程是CMP中材料去除的基石性经验关系。亥姆霍兹型压力方程是模拟抛光垫柔度和刚度影响的标准方法，代表一个线性弹性基底。“平坦化长度”的概念是此类模型中的一个关键参数。该问题具有科学依据。\n- **适定性：** 该问题提供了一个具有指定初始条件和关于解形式的简化假设的线性偏微分方程组的封闭系统。目标是推导一个明确定义的参数，即平坦化效率 $\\eta$。这构成一个适定的数学物理问题。\n- **客观性（关键）：** 问题以精确、客观和定量的语言陈述，没有歧义或主观内容。所有参数和函数都有明确定义。\n- **完整性和一致性：** 问题是自洽的。它提供了进行推导所需的所有必要方程、变量和定义。没有内部矛盾。\n- **其他缺陷：** 该问题没有表现出任何其他缺陷。它并非微不足道，因为它需要系统性地应用所提供的模型方程。在简化物理模型的背景下，它并非不切实际。\n\n**步骤3：结论与行动**\n问题被判定为**有效**。将进行求解。\n\n### 推导\n\n目标是找到平坦化效率 $\\eta$ 的闭合形式表达式，其定义为：\n$$\n\\eta \\equiv \\frac{-\\frac{1}{H}\\frac{\\mathrm{d}H}{\\mathrm{d}t}}{k P_{0} V}\n$$\n这需要求出振幅的分数衰减率 $-\\frac{1}{H}\\frac{\\mathrm{d}H}{\\mathrm{d}t}$。\n\n给定表面高度轮廓 $h(x,t)$ 的形式：\n$$\nh(x,t) = H(t)\\sin\\left(\\frac{2\\pi x}{\\lambda}\\right)\n$$\n我们定义空间波数 $k_x = \\frac{2\\pi}{\\lambda}$。那么高度轮廓为 $h(x,t) = H(t)\\sin(k_x x)$。\n\n首先，我们确定 $h(x,t)$ 的时间和空间导数：\n时间导数为：\n$$\n\\frac{\\partial h}{\\partial t} = \\frac{\\partial}{\\partial t}\\left[H(t)\\sin(k_x x)\\right] = \\frac{\\mathrm{d}H(t)}{\\mathrm{d}t}\\sin(k_x x)\n$$\n空间二阶导数为：\n$$\n\\frac{\\partial h}{\\partial x} = H(t) k_x \\cos(k_x x)\n$$\n$$\n\\frac{\\partial^{2}h}{\\partial x^{2}} = -H(t) k_x^{2} \\sin(k_x x) = -k_x^2 h(x,t)\n$$\n\n接下来，我们使用给定的亥姆霍兹型关系来找到与高度轮廓 $h(x,t)$ 对应的压力扰动 $\\delta p(x,t)$。\n$$\n\\left(1 - L^{2}\\frac{\\partial^{2}}{\\partial x^{2}}\\right)\\delta p(x,t) = S\\left(-\\frac{\\partial^{2} h(x,t)}{\\partial x^{2}}\\right)\n$$\n代入 $h(x,t)$ 的二阶导数表达式：\n$$\n\\left(1 - L^{2}\\frac{\\partial^{2}}{\\partial x^{2}}\\right)\\delta p(x,t) = S\\left(-(-k_x^2 h(x,t))\\right) = S k_x^2 h(x,t)\n$$\n由于右侧是关于 $x$ 的正弦函数，压力扰动 $\\delta p(x,t)$ 也必须是具有相同波数的正弦函数，即 $\\delta p(x,t) \\propto \\sin(k_x x)$。对于这样的函数，算子 $\\frac{\\partial^2}{\\partial x^2}$ 等效于乘以 $-k_x^2$。将此应用于 $\\delta p(x,t)$：\n$$\n\\left(1 - L^{2}(-k_x^2)\\right)\\delta p(x,t) = S k_x^2 h(x,t)\n$$\n$$\n(1 + L^{2}k_x^2)\\delta p(x,t) = S k_x^2 h(x,t)\n$$\n解出 $\\delta p(x,t)$ 以 $h(x,t)$ 表示：\n$$\n\\delta p(x,t) = \\frac{S k_x^2}{1 + L^{2}k_x^2} h(x,t)\n$$\n\n现在，我们将 $\\delta p(x,t)$ 的这个表达式代入高度演化方程：\n$$\n\\frac{\\partial h}{\\partial t} = -k V \\delta p(x,t)\n$$\n$$\n\\frac{\\partial h}{\\partial t} = -k V \\left(\\frac{S k_x^2}{1 + L^{2}k_x^2}\\right) h(x,t)\n$$\n代入 $\\frac{\\partial h}{\\partial t}$ 和 $h(x,t)$ 的表达式：\n$$\n\\frac{\\mathrm{d}H(t)}{\\mathrm{d}t}\\sin(k_x x) = -k V \\left(\\frac{S k_x^2}{1 + L^{2}k_x^2}\\right) H(t)\\sin(k_x x)\n$$\n为了使该方程对所有 $x$ 成立，我们可以消去项 $\\sin(k_x x)$（在它不为零的 $x$ 处），这就得到了关于振幅 $H(t)$ 的常微分方程：\n$$\n\\frac{\\mathrm{d}H(t)}{\\mathrm{d}t} = -k V \\left(\\frac{S k_x^2}{1 + L^{2}k_x^2}\\right) H(t)\n$$\n为了求得分数衰减率，我们除以 $H(t)$：\n$$\n\\frac{1}{H(t)}\\frac{\\mathrm{d}H(t)}{\\mathrm{d}t} = -k V \\frac{S k_x^2}{1 + L^{2}k_x^2}\n$$\n效率 $\\eta$ 所需的量是 $-\\frac{1}{H}\\frac{\\mathrm{d}H}{\\mathrm{d}t}$：\n$$\n-\\frac{1}{H(t)}\\frac{\\mathrm{d}H(t)}{\\mathrm{d}t} = k V \\frac{S k_x^2}{1 + L^{2}k_x^2}\n$$\n\n最后，我们将此结果代入 $\\eta$ 的定义：\n$$\n\\eta = \\frac{-\\frac{1}{H}\\frac{\\mathrm{d}H}{\\mathrm{d}t}}{k P_{0} V} = \\frac{k V \\frac{S k_x^2}{1 + L^{2}k_x^2}}{k P_{0} V}\n$$\n项 $k$ 和 $V$ 相消，剩下：\n$$\n\\eta = \\frac{S}{P_0} \\frac{k_x^2}{1 + L^2 k_x^2}\n$$\n为了用给定的参数 $\\lambda$ 和 $L$ 表示，我们代入 $k_x = \\frac{2\\pi}{\\lambda}$：\n$$\n\\eta = \\frac{S}{P_0} \\frac{\\left(\\frac{2\\pi}{\\lambda}\\right)^2}{1 + L^2 \\left(\\frac{2\\pi}{\\lambda}\\right)^2}\n$$\n为了得到更优美的形式，我们可以将分子和分母同除以 $k_x^2 = \\left(\\frac{2\\pi}{\\lambda}\\right)^2$：\n$$\n\\eta = \\frac{S}{P_0} \\frac{1}{\\frac{1}{k_x^2} + L^2} = \\frac{S}{P_0} \\frac{1}{\\left(\\frac{\\lambda}{2\\pi}\\right)^2 + L^2}\n$$\n这就是 $\\eta$ 的最终闭合形式表达式。\n\n现在我们可以按要求分析渐近标度关系。\n1.  对于长波长，$\\lambda \\gg L$：在此极限下，$\\frac{\\lambda}{2\\pi} \\gg L$，所以分母由与波长相关的项主导：$\\left(\\frac{\\lambda}{2\\pi}\\right)^2 + L^2 \\approx \\left(\\frac{\\lambda}{2\\pi}\\right)^2 = \\frac{\\lambda^2}{4\\pi^2}$。\n    效率变为 $\\eta \\approx \\frac{S}{P_0} \\frac{4\\pi^2}{\\lambda^2}$。标度关系为 $\\eta \\propto \\lambda^{-2}$。对于非常长的波长，平坦化效率非常低。\n2.  对于短波长，$\\lambda \\ll L$：在此极限下，$\\frac{\\lambda}{2\\pi} \\ll L$，所以分母由常数项主导：$\\left(\\frac{\\lambda}{2\\pi}\\right)^2 + L^2 \\approx L^2$。\n    效率变为 $\\eta \\approx \\frac{S}{P_0 L^2}$。效率饱和到一个常数值，与波长无关。标度关系为 $\\eta \\propto \\lambda^0$。\n\n所要求的最终答案是 $\\eta(\\lambda)$ 的单个闭合形式解析表达式。",
            "answer": "$$\n\\boxed{\\frac{S}{P_0} \\frac{1}{\\left(\\frac{\\lambda}{2\\pi}\\right)^2 + L^2}}\n$$"
        },
        {
            "introduction": "在真实的集成电路中，图形的布局远比简单的正弦波复杂，其密度变化会显著影响去除速率。本练习将在基本物理原理的基础上，构建一个数值模拟来预测复杂图形上的形貌演化。通过引入加权密度模型，您将探索局部图形密度如何通过卷积效应影响去除速率，这是在芯片级别实现平坦度的关键因素。",
            "id": "4114506",
            "problem": "要求您构建一个基于加权密度模型的一维化学机械平坦化（CMP）形貌演化仿真。其基本原理必须从 Preston 方程出发，该方程指出局部去除速率与施加的压力和相对速度的乘积成正比。具体来说，请使用以下基本定律和定义：\n\n- Preston 方程：局部去除速率满足 $RR(x) \\propto P \\cdot V$。\n- 厚度守恒：薄膜厚度 $h(x,t)$ 随时间根据局部去除速率减小，因此 $\\dfrac{\\partial h(x,t)}{\\partial t} = -RR(x)$。\n- 加权密度定义：有效局部图形密度 $\\rho(x)$ 定义为二元图形指示符 $p(x)$ 与域上的归一化高斯核 $G_{\\sigma}(x)$ 的卷积。高斯核必须被归一化，使得 $\\int G_{\\sigma}(x)\\,dx = 1$；在离散周期性设置中，其总和必须为 $1$。\n- CMP 去除速率的加权密度模型为 $RR(x) = k \\, P \\, V \\, g(\\rho(x))$，其中 $k$ 是 Preston 系数，$P$ 是施加的压力，$V$ 是相对速度，$g$ 是一个指定的密度-去除率修正函数。\n\n您必须在一个由 $N$ 个网格点组成的一维周期性域上模拟 $h(x,t)$ 的演化，该域代表了芯片上的一条线。二元图形指示符 $p(x)$ 编码了具有指定占空比的特征条纹。该域由两半组成：\n\n- 左半部分是“密集区”，占空比为 $D_{\\mathrm{dense}}$。\n- 右半部分是“稀疏区”，占空比为 $D_{\\mathrm{sparse}}$。\n\n在每一半内部，构建一个周期为 $\\Lambda$ 个网格点的周期性条纹图形，其中每个周期的前 $D\\cdot\\Lambda$ 个点 $p(x)=1$，该周期中余下的点 $p(x)=0$。在左半部分，$D$ 等于 $D_{\\mathrm{dense}}$；在右半部分，$D$ 等于 $D_{\\mathrm{sparse}}$。\n\n通过循环（周期性）卷积定义有效密度\n$$\n\\rho(x) = (p * G_{\\sigma})(x),\n$$\n其中 $G_{\\sigma}(x)$ 是一个带宽为 $\\sigma$ 个网格点且总和为一的离散循环高斯核。使用特定的去除修正函数\n$$\ng(\\rho) = 1 - \\alpha \\, \\rho^{\\beta},\n$$\n其中参数 $\\alpha$ 和 $\\beta$ 按每个测试用例给出。初始薄膜厚度是均匀的，$h(x,0) = H_0$。\n\n使用与基本定律一致的显式格式来演化厚度：\n$$\nh(x,t + \\Delta t) = h(x,t) - RR(x)\\,\\Delta t,\n$$\n对于从 $0$ 到 $T$ 的时间 $t$，步长为 $\\Delta t$。计算侵蚀量 $E(x) = H_0 - h(x,T)$，单位为 $\\mathrm{nm}$。\n\n为了比较密集区和稀疏区，计算内部窗口上的平均侵蚀量以避免边界效应：\n- 密集窗口：索引 $i$ 满足 $i \\in [\\lfloor 0.1 N \\rfloor, \\lfloor 0.4 N \\rfloor]$。\n- 稀疏窗口：索引 $i$ 满足 $i \\in [\\lfloor 0.6 N \\rfloor, \\lfloor 0.9 N \\rfloor]$。\n\n对于每个测试用例，将密集和稀疏窗口中预测的平均侵蚀量与提供的测量值进行比较，并报告每个比较是否在指定的绝对容差范围内。具体来说，定义布尔结果：\n- 密集区比较：$| \\overline{E}_{\\mathrm{dense}} - E_{\\mathrm{dense,meas}} | \\le \\tau$。\n- 稀疏区比较：$| \\overline{E}_{\\mathrm{sparse}} - E_{\\mathrm{sparse,meas}} | \\le \\tau$。\n\n所有物理量必须使用明确的单位：\n- 以 $\\mathrm{nm}$ 报告侵蚀量。\n- 使用 $P$ 单位 $\\mathrm{kPa}$。\n- 使用 $V$ 单位 $\\mathrm{m/s}$。\n- 使用 $k$ 单位 $\\mathrm{nm}/(\\mathrm{kPa}\\cdot\\mathrm{m})$。\n- 使用时间单位 $\\mathrm{s}$。\n\n域和离散化：\n- 使用一个包含 $N=1000$ 个网格点的周期性域（无量纲网格索引）。\n- 使用以网格点为单位的条纹周期 $\\Lambda$（无量纲）。\n- 使用以网格点为单位的高斯带宽 $\\sigma$（无量纲）。\n- 使用时间步长 $\\Delta t$（单位 $\\mathrm{s}$）和总抛光时间 $T$（单位 $\\mathrm{s}$）。\n\n输出规格：\n- 您的程序应生成单行输出，包含用方括号括起来的逗号分隔的结果列表。每个测试用例贡献一个包含两个布尔值的列表，顺序为 $[\\text{dense},\\text{sparse}]$。例如：$[[\\text{True},\\text{False}],[\\text{True},\\text{True}]]$。\n\n测试套件：\n使用 $N = 1000$ 和以下参数集。每个案例是一个元组 $(k, P, V, \\alpha, \\beta, \\sigma, \\Lambda, D_{\\mathrm{dense}}, D_{\\mathrm{sparse}}, H_0, T, \\Delta t, \\tau, E_{\\mathrm{dense,meas}}, E_{\\mathrm{sparse,meas}})$：\n\n- 案例 1（正常路径）：$(0.25\\,\\mathrm{nm}/(\\mathrm{kPa}\\cdot\\mathrm{m}),\\,10\\,\\mathrm{kPa},\\,0.5\\,\\mathrm{m/s},\\,0.6,\\,1.0,\\,5,\\,20,\\,0.7,\\,0.2,\\,1000\\,\\mathrm{nm},\\,120\\,\\mathrm{s},\\,0.5\\,\\mathrm{s},\\,5\\,\\mathrm{nm},\\,90\\,\\mathrm{nm},\\,130\\,\\mathrm{nm})$。\n\n- 案例 2（边界情况；零压力）：$(0.25\\,\\mathrm{nm}/(\\mathrm{kPa}\\cdot\\mathrm{m}),\\,0\\,\\mathrm{kPa},\\,0.5\\,\\mathrm{m/s},\\,0.6,\\,1.0,\\,5,\\,20,\\,0.7,\\,0.2,\\,1000\\,\\mathrm{nm},\\,120\\,\\mathrm{s},\\,0.5\\,\\mathrm{s},\\,0.5\\,\\mathrm{nm},\\,0\\,\\mathrm{nm},\\,0\\,\\mathrm{nm})$。\n\n- 案例 3（强密度敏感性）：$(0.25\\,\\mathrm{nm}/(\\mathrm{kPa}\\cdot\\mathrm{m}),\\,10\\,\\mathrm{kPa},\\,0.5\\,\\mathrm{m/s},\\,0.9,\\,2.0,\\,5,\\,20,\\,0.7,\\,0.2,\\,1000\\,\\mathrm{nm},\\,120\\,\\mathrm{s},\\,0.5\\,\\mathrm{s},\\,5\\,\\mathrm{nm},\\,85\\,\\mathrm{nm},\\,145\\,\\mathrm{nm})$。\n\n- 案例 4（宽加权；近乎均匀的有效密度）：$(0.25\\,\\mathrm{nm}/(\\mathrm{kPa}\\cdot\\mathrm{m}),\\,10\\,\\mathrm{kPa},\\,0.5\\,\\mathrm{m/s},\\,0.6,\\,1.0,\\,200,\\,20,\\,0.7,\\,0.2,\\,1000\\,\\mathrm{nm},\\,120\\,\\mathrm{s},\\,0.5\\,\\mathrm{s},\\,3\\,\\mathrm{nm},\\,110\\,\\mathrm{nm},\\,110\\,\\mathrm{nm})$。\n\n您的任务：\n- 实现仿真并根据指定要求精确计算每个案例的布尔比较结果。\n- 所有侵蚀量值以 $\\mathrm{nm}$ 表示。\n- 以单行形式生成最终输出：一个包含四个双元素列表的列表 $[[b_{1,d},b_{1,s}],[b_{2,d},b_{2,s}],[b_{3,d},b_{3,s}],[b_{4,d},b_{4,s}]]$，其中每个 $b$ 为 $\\mathrm{True}$ 或 $\\mathrm{False}$。",
            "solution": "用户提供了一个问题，要求实现一维化学机械平坦化（CMP）形貌演化的仿真。解决方案必须基于从 Preston 方程推导出的加权密度模型。\n\n### 问题验证\n所提供的问题陈述已经过严格验证，并被确定为**有效**。它在科学上基于已建立的 CMP 建模原则，定义、方程和参数完整且一致，问题阐述清晰，并且以客观、可形式化的语言表达。所有单位都一致，数值参数和测试用例在物理上是现实的。该问题要求逐步实现一个明确定义的仿真，并且不包含任何会妨碍唯一解的歧义或矛盾。\n\n### 基于原则的解决方案设计\n\n薄膜厚度演化 $h(x,t)$ 的仿真是根据指定的物理模型进行的。该模型的核心是局部材料去除速率 $RR(x)$，假定其在整个抛光时间 $T$ 内是恒定的。\n\n**1. 去除速率公式**\n\n局部去除速率由加权密度模型给出：\n$$\nRR(x) = k \\, P \\, V \\, g(\\rho(x))\n$$\n其中 $k$ 是 Preston 系数，$P$ 是施加的压力，$V$ 是相对抛光速度，$g(\\rho(x))$ 是一个基于有效局部图形密度 $\\rho(x)$ 来修正去除速率的函数。具体的修正函数是：\n$$\ng(\\rho) = 1 - \\alpha \\, \\rho^{\\beta}\n$$\n参数 $k, P, V, \\alpha,$ 和 $\\beta$ 在每个测试用例中都已提供。\n\n由于 $RR(x)$ 与时间 $t$ 和厚度 $h$ 无关，由微分方程 $\\frac{\\partial h}{\\partial t} = -RR(x)$ 和初始条件 $h(x,0) = H_0$ 给出的薄膜厚度演化可以直接在总抛光时间 $T$ 上积分：\n$$\nh(x,T) = h(x,0) - \\int_0^T RR(x) \\, dt = H_0 - RR(x) \\cdot T\n$$\n因此，总侵蚀量，定义为被去除的材料量，是：\n$$\nE(x) = H_0 - h(x,T) = RR(x) \\cdot T\n$$\n问题中提供的显式时间步进格式，$h(x,t + \\Delta t) = h(x,t) - RR(x)\\,\\Delta t$，与此直接积分是一致的，因为将所有从 $t=0$ 到 $T$ 的时间步长的去除量相加，得到的总去除量为 $RR(x) \\cdot T$。\n\n**2. 域和图形定义**\n\n仿真域是一个一维周期性网格，包含 $N=1000$ 个点。这个网格代表了半导体芯片上的一条线扫描。该域被划分为两半：\n-   **密集区**：左半部分（索引 $i \\in [0, N/2 - 1]$），具有较高的特征占空比 $D_{\\mathrm{dense}}$。\n-   **稀疏区**：右半部分（索引 $i \\in [N/2, N - 1]$），具有较低的特征占空比 $D_{\\mathrm{sparse}}$。\n\n一个二元图形指示符数组 $p(x)$ 代表了特征的存在（$1$）或不存在（$0$）。在每一半中，$p(x)$ 是通过重复一个长度为 $\\Lambda$ 的基本周期性图形来构建的。对于给定的占空比 $D$ 和周期 $\\Lambda$，基本图形包含 $\\lfloor D \\cdot \\Lambda \\rfloor$ 个值为 $1$ 的点，后面跟着 $(\\Lambda - \\lfloor D \\cdot \\Lambda \\rfloor)$ 个值为 $0$ 的点。这个瓦片被重复以填充域的相应一半。\n\n**3. 有效图形密度计算**\n\n关键的物理概念是，局部去除速率不依赖于逐点的图形 $p(x)$，而是依赖于空间平均或“有效”的图形密度 $\\rho(x)$。这模拟了诸如抛光垫弯曲和浆料传输等具有特征长度尺度的物理效应。这个有效密度是通过二元图形 $p(x)$ 与一个归一化的离散高斯核 $G_{\\sigma}(x)$ 的循环卷积计算得出的：\n$$\n\\rho(x) = (p * G_{\\sigma})(x)\n$$\n高斯核 $G_{\\sigma}(x)$ 在大小为 $N$ 的周期域上以 $x=0$ 为中心，具有 $\\sigma$ 的带宽（标准差），并被归一化以使其元素总和为 $1$。对于离散网格点 $i \\in [0, N-1]$，核定义为：\n$$\nG_{\\sigma}(i) = C \\cdot \\exp\\left(-\\frac{d(i,0)^2}{2\\sigma^2}\\right)\n$$\n其中 $d(i,0) = \\min(i, N-i)$ 是与原点的周期性距离，而 $C$ 是确保 $\\sum_{i=0}^{N-1} G_{\\sigma}(i) = 1$ 的归一化常数。循环卷积可以通过使用快速傅里叶变换（FFT）根据卷积定理高效计算：\n$$\n\\rho = \\mathcal{F}^{-1}\\{\\mathcal{F}\\{p\\} \\cdot \\mathcal{F}\\{G_{\\sigma}\\}\\}\n$$\n其中 $\\mathcal{F}$ 和 $\\mathcal{F}^{-1}$ 分别表示正向和反向 FFT。\n\n**4. 分析与验证**\n\n计算出侵蚀量数组 $E(x)$ 后，将仿真结果与测量数据进行比较。为避免密集/稀疏边界和周期性环绕点附近的边缘效应，在指定的内部窗口上计算平均侵蚀量：\n-   $\\overline{E}_{\\mathrm{dense}} = \\mathrm{mean}(E(i))$ for $i \\in [\\lfloor 0.1 N \\rfloor, \\lfloor 0.4 N \\rfloor]$\n-   $\\overline{E}_{\\mathrm{sparse}} = \\mathrm{mean}(E(i))$ for $i \\in [\\lfloor 0.6 N \\rfloor, \\lfloor 0.9 N \\rfloor]$\n\n然后将这些计算出的平均侵蚀量值与提供的测量值 $E_{\\mathrm{dense,meas}}$ 和 $E_{\\mathrm{sparse,meas}}$ 进行比较。如果绝对差在给定的容差 $\\tau$ 之内，则宣告匹配：\n-   密集区比较：$|\\overline{E}_{\\mathrm{dense}} - E_{\\mathrm{dense,meas}}| \\le \\tau$\n-   稀疏区比较：$|\\overline{E}_{\\mathrm{sparse}} - E_{\\mathrm{sparse,meas}}| \\le \\tau$\n\n每个测试用例的最终输出是一个包含这两个比较结果的布尔值列表。\n\n**实现总结**\n\n对于每个测试用例，算法按以下步骤进行：\n1.  解包所有输入参数。\n2.  基于 $D_{\\mathrm{dense}}$、$D_{\\mathrm{sparse}}$ 和 $\\Lambda$ 构建 $N$ 点的二元图形数组 $p(x)$。\n3.  基于 $\\sigma$ 和 $N$ 构建归一化的离散循环高斯核 $G_{\\sigma}(x)$。\n4.  通过基于 FFT 的循环卷积计算有效密度数组 $\\rho(x)$。\n5.  计算局部去除速率数组 $RR(x)$。\n6.  计算总侵蚀量数组 $E(x) = RR(x) \\cdot T$。\n7.  计算密集和稀疏窗口上的平均侵蚀量。\n8.  与测量数据进行布尔比较，使用容差 $\\tau$。\n9.  格式化并存储结果 `[布尔值, 布尔值]` 对。\n处理完所有案例后，将收集到的结果格式化为指定的单个字符串。",
            "answer": "```python\nimport numpy as np\n\ndef run_simulation(params):\n    \"\"\"\n    Runs a single 1D CMP simulation for a given set of parameters.\n\n    Args:\n        params (tuple): A tuple containing all parameters for the simulation case.\n          The order is (k, P, V, alpha, beta, sigma, Lambda, D_dense, D_sparse,\n                         H0, T, dt, tau, E_dense_meas, E_sparse_meas).\n\n    Returns:\n        list: A list of two booleans [dense_comparison, sparse_comparison].\n    \"\"\"\n    (k, P, V, alpha, beta, sigma, Lambda, D_dense, D_sparse,\n     H0, T, dt, tau, E_dense_meas, E_sparse_meas) = params\n\n    N = 1000  # Number of grid points\n\n    # Step 1: Construct the binary pattern indicator p(x)\n    p = np.zeros(N)\n    N_half = N // 2\n\n    # Dense half (left)\n    if Lambda > 0:\n        w_dense = int(D_dense * Lambda)\n        tile_dense = np.zeros(Lambda)\n        tile_dense[:w_dense] = 1\n        num_tiles_dense = N_half // Lambda\n        if N_half % Lambda != 0:\n            # This case is not expected based on problem description (500 is multiple of 20)\n            # but handle it for robustness.\n            raise ValueError(\"Size of half-domain must be a multiple of Lambda.\")\n        p_dense = np.tile(tile_dense, num_tiles_dense)\n        p[:N_half] = p_dense\n\n    # Sparse half (right)\n    if Lambda > 0:\n        w_sparse = int(D_sparse * Lambda)\n        tile_sparse = np.zeros(Lambda)\n        tile_sparse[:w_sparse] = 1\n        num_tiles_sparse = N_half // Lambda\n        if N_half % Lambda != 0:\n            raise ValueError(\"Size of half-domain must be a multiple of Lambda.\")\n        p_sparse = np.tile(tile_sparse, num_tiles_sparse)\n        p[N_half:] = p_sparse\n\n    # Step 2: Construct the discrete circular Gaussian kernel G_sigma(x)\n    indices = np.arange(N)\n    distances = np.minimum(indices, N - indices)\n    \n    # Handle sigma=0 case to avoid division by zero, although not in test cases.\n    # It would correspond to a delta function.\n    if sigma > 0:\n        G_sigma = np.exp(-distances**2 / (2 * sigma**2))\n    else:\n        G_sigma = np.zeros(N)\n        G_sigma[0] = 1.0\n\n    G_sigma /= np.sum(G_sigma)\n\n    # Step 3: Compute the effective density rho(x) via circular convolution\n    p_fft = np.fft.fft(p)\n    G_fft = np.fft.fft(G_sigma)\n    rho = np.real(np.fft.ifft(p_fft * G_fft))\n    \n    # Step 4: Calculate the removal rate RR(x)\n    g_rho = 1 - alpha * rho**beta\n    RR = k * P * V * g_rho\n    \n    # Step 5: Calculate the final erosion E(x)\n    # E(x) = H0 - h(x, T) = H0 - (H0 - RR(x) * T) = RR(x) * T\n    erosion = RR * T\n\n    # Step 6: Compute average erosion in dense and sparse windows\n    dense_win_start = int(0.1 * N)\n    dense_win_end = int(0.4 * N)\n    sparse_win_start = int(0.6 * N)\n    sparse_win_end = int(0.9 * N)\n    \n    # Python slicing is exclusive on the right, but the spec is inclusive.\n    avg_E_dense = np.mean(erosion[dense_win_start : dense_win_end + 1])\n    avg_E_sparse = np.mean(erosion[sparse_win_start : sparse_win_end + 1])\n\n    # Step 7: Perform boolean comparisons\n    is_dense_match = abs(avg_E_dense - E_dense_meas) = tau\n    is_sparse_match = abs(avg_E_sparse - E_sparse_meas) = tau\n\n    # Ensure python bool type instead of numpy.bool_\n    return [bool(is_dense_match), bool(is_sparse_match)]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (k, P, V, alpha, beta, sigma, Lambda, D_dense, D_sparse, H0, T, dt, tau, E_dense_meas, E_sparse_meas)\n        (0.25, 10, 0.5, 0.6, 1.0, 5, 20, 0.7, 0.2, 1000, 120, 0.5, 5, 90, 130), # Case 1\n        (0.25, 0, 0.5, 0.6, 1.0, 5, 20, 0.7, 0.2, 1000, 120, 0.5, 0.5, 0, 0),    # Case 2\n        (0.25, 10, 0.5, 0.9, 2.0, 5, 20, 0.7, 0.2, 1000, 120, 0.5, 5, 85, 145), # Case 3\n        (0.25, 10, 0.5, 0.6, 1.0, 200, 20, 0.7, 0.2, 1000, 120, 0.5, 3, 110, 110),# Case 4\n    ]\n\n    results = []\n    for case in test_cases:\n        case_result = run_simulation(case)\n        # Format each two-element list into its string representation '[True,False]'\n        # to correctly build the final output string.\n        results.append(str(case_result).replace(\" \", \"\"))\n    \n    # Final print statement in the exact required format.\n    # The map(str,...) is now redundant as we manually stringified, but kept for structure.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "成功的制造不仅依赖于对物理过程的精确建模，还依赖于对工艺变异的有效控制。最后一个练习将从确定性物理模型转向制造业的现实挑战：随机性。您将建立一个随机模型来设计最优的终点检测策略，以在最小化侵蚀和控制欠抛光风险之间取得平衡，这个练习介绍了在量产环境中设计稳健工艺流程的关键概念。",
            "id": "4114508",
            "problem": "考虑一个用于半导体制造中阻挡层去除的简化但科学合理的化学机械平坦化 (CMP) 模型。目标是设计一个基于时间的终点策略，在满足欠抛光的概率性风险约束的同时，最小化预期侵蚀。假设以下基本原理作为建模基础：\n\n- 化学机械平坦化 (CMP) 在工艺条件固定时，以恒定的去除速率移除材料。如果真实阻挡层厚度为 $T_{0}$ (单位 nm)，阻挡层去除速率为 $R_{b}$ (单位 nm/s)，那么理想清除时间（刚好移除阻挡层所需的时间）为 $t_{\\mathrm{clear}} = T_{0} / R_{b}$ (单位 s)。\n- 抛光前计量通过一次带噪声的测量来估计阻挡层厚度：$T_{0}^{\\mathrm{hat}} = T_{0} + \\varepsilon$，其中 $\\varepsilon$ 是一个独立的、零均值的高斯随机变量，其标准差为 $\\sigma_{m}$ (单位 nm)，即 $\\varepsilon \\sim \\mathcal{N}(0,\\sigma_{m}^{2})$。\n- 去除策略是基于时间的：选择一个抛光时间 $t = T_{0}^{\\mathrm{hat}}/R_{b} + m$，其中 $m \\ge 0$ 是一个待设计的过抛光裕量 (单位 s)。\n- 如果 $t  t_{\\mathrm{clear}}$，阻挡层未被完全移除（欠抛光）。如果 $t \\ge t_{\\mathrm{clear}}$，阻挡层被清除，额外的时间 $(t - t_{\\mathrm{clear}})$ 为过抛光时间。侵蚀被建模为与过抛光时间成正比，具有恒定的侵蚀速率 $R_{e}$ (单位 nm/s)，因此单次试验的侵蚀厚度为 $E = R_{e} \\max\\{t - t_{\\mathrm{clear}}, 0\\}$ (单位 nm)。\n\n给定在晶圆的不同位置上，真实阻挡层厚度 $T_{0}$ 服从正态分布 $T_{0} \\sim \\mathcal{N}(\\mu_{T}, \\sigma_{T}^{2})$ (单位 nm)，且与测量噪声 $\\varepsilon$ 相互独立。在抛光前，您不能直接观测到 $T_{0}$；只能观测到一次 $T_{0}^{\\mathrm{hat}}$。决策策略必须是根据上述规则应用于所有位点的固定裕量 $m$。\n\n您的任务是确定最优过抛光裕量 $m^{\\star}$ (单位 s)，该裕量能够最小化预期侵蚀厚度 $\\mathbb{E}[E]$ (单位 nm)，同时满足欠抛光概率不超过指定容差 $\\alpha \\in (0,1)$ 的概率性终点风险约束：\n$$\n\\mathbb{P}\\left(t  t_{\\mathrm{clear}}\\right) \\le \\alpha.\n$$\n请基于所述基本原理和概率论进行推导，以：\n1) 描述随机变量 $\\Delta = t - t_{\\mathrm{clear}}$ 的分布。\n2) 用 $m$、$R_{b}$ 和 $\\sigma_{m}$ 表示欠抛光概率 $\\mathbb{P}(\\Delta  0)$。\n3) 确定满足风险约束的最小 $m$。\n4) 在此选择下，计算所得的最小预期侵蚀 $\\mathbb{E}[E]$。\n\n您的程序必须为下面的每个测试用例计算并输出配对 $[m^{\\star}, \\mathbb{E}[E]_{\\mathrm{min}}]$，其中 $m^{\\star}$ 的单位是 s，$\\mathbb{E}[E]_{\\mathrm{min}}$ 的单位是 nm。每个浮点数输出必须四舍五入到六位小数。\n\n每个测试用例的输入是元组 $(\\mu_{T}, \\sigma_{T}, \\sigma_{m}, R_{b}, R_{e}, \\alpha)$，其单位为 $(\\mathrm{nm}, \\mathrm{nm}, \\mathrm{nm}, \\mathrm{nm/s}, \\mathrm{nm/s}, \\text{无单位})$。请注意，所有物理速率和厚度在科学上都是合理的，并且模型假设在相关阶段速率恒定。\n\n测试套件（按此顺序使用以下五个用例）：\n- 用例 1：$(\\mu_{T}, \\sigma_{T}, \\sigma_{m}, R_{b}, R_{e}, \\alpha) = (30, 3, 5, 1.0, 0.2, 0.05)$\n- 用例 2：$(\\mu_{T}, \\sigma_{T}, \\sigma_{m}, R_{b}, R_{e}, \\alpha) = (15, 1, 2, 1.2, 0.1, 0.5)$\n- 用例 3：$(\\mu_{T}, \\sigma_{T}, \\sigma_{m}, R_{b}, R_{e}, \\alpha) = (40, 5, 0.1, 1.5, 0.05, 0.01)$\n- 用例 4：$(\\mu_{T}, \\sigma_{T}, \\sigma_{m}, R_{b}, R_{e}, \\alpha) = (25, 4, 10, 0.8, 0.25, 0.1)$\n- 用例 5：$(\\mu_{T}, \\sigma_{T}, \\sigma_{m}, R_{b}, R_{e}, \\alpha) = (50, 8, 7, 0.5, 0.2, 10^{-6})$\n\n最终输出格式：您的程序应生成单行输出，其中包含一个由五个项目组成的逗号分隔列表，每个项目都是包含六位小数的双元素列表 $[m^{\\star}, \\mathbb{E}[E]_{\\mathrm{min}}]$，所有内容都包含在一对顶层方括号中。例如，包含两个用例的输出应如下所示：$[[m_{1},e_{1}],[m_{2},e_{2}]]$。对于本问题，输出必须是 $[[m^{\\star}_{1},e_{1}],[m^{\\star}_{2},e_{2}],[m^{\\star}_{3},e_{3}],[m^{\\star}_{4},e_{4}],[m^{\\star}_{5},e_{5}]]$ 形式的单行，且不含空格。",
            "solution": "所述问题在科学上是合理的、适定的，并包含了唯一解所需的所有信息。这是一个应用于半导体制造的统计过程控制中的标准问题。我们开始进行求解。\n\n目标是找到最优过抛光裕量 $m^{\\star}$，它在满足欠抛光概率约束的条件下，最小化预期侵蚀 $\\mathbb{E}[E]$。解决方案需要如问题陈述中所概述的四步推导。\n\n**1. 描述随机变量 $\\Delta = t - t_{\\mathrm{clear}}$ 的分布**\n\n总抛光时间 $t$ 由策略定义：\n$$t = \\frac{T_{0}^{\\mathrm{hat}}}{R_{b}} + m$$\n其中 $T_{0}^{\\mathrm{hat}}$ 是真实阻挡层厚度 $T_{0}$ 的带噪声测量值，$R_{b}$ 是阻挡层去除速率，$m$ 是过抛光裕量。测量值由 $T_{0}^{\\mathrm{hat}} = T_{0} + \\varepsilon$ 给出，其中测量噪声 $\\varepsilon$ 是一个随机变量，服从分布 $\\varepsilon \\sim \\mathcal{N}(0, \\sigma_{m}^{2})$。\n\n理想清除时间 $t_{\\mathrm{clear}}$ 是精确移除真实阻挡层厚度 $T_{0}$ 所需的时间：\n$$t_{\\mathrm{clear}} = \\frac{T_{0}}{R_{b}}$$\n随机变量 $\\Delta$ 表示所施加的抛光时间与理想清除时间之差。代入 $t$ 和 $t_{\\mathrm{clear}}$ 的定义：\n$$\\Delta = t - t_{\\mathrm{clear}} = \\left(\\frac{T_{0}^{\\mathrm{hat}}}{R_{b}} + m\\right) - \\frac{T_{0}}{R_{b}}$$\n代入 $T_{0}^{\\mathrm{hat}} = T_{0} + \\varepsilon$：\n$$\\Delta = \\left(\\frac{T_{0} + \\varepsilon}{R_{b}} + m\\right) - \\frac{T_{0}}{R_{b}} = \\frac{T_{0}}{R_{b}} + \\frac{\\varepsilon}{R_{b}} + m - \\frac{T_{0}}{R_{b}}$$\n涉及真实厚度 $T_{0}$ 的项相互抵消，从而得到 $\\Delta$ 的简化表达式：\n$$\\Delta = m + \\frac{\\varepsilon}{R_{b}}$$\n这是一个关键结果：时间差 $\\Delta$ 的分布仅取决于过抛光裕量 $m$ 和测量噪声 $\\varepsilon$ 的分布，而与真实厚度 $T_{0}$ 的分布无关。因此，分析的这一部分不需要给定的参数 $\\mu_{T}$ 和 $\\sigma_{T}$。\n\n由于 $\\varepsilon \\sim \\mathcal{N}(0, \\sigma_{m}^{2})$，$\\Delta$ 是一个高斯随机变量的线性变换，因此它本身也是高斯分布的。其均值 $\\mu_{\\Delta}$ 和方差 $\\sigma_{\\Delta}^{2}$ 为：\n$$\\mu_{\\Delta} = \\mathbb{E}[\\Delta] = \\mathbb{E}\\left[m + \\frac{\\varepsilon}{R_{b}}\\right] = m + \\frac{\\mathbb{E}[\\varepsilon]}{R_{b}} = m + \\frac{0}{R_{b}} = m$$\n$$\\sigma_{\\Delta}^{2} = \\mathrm{Var}(\\Delta) = \\mathrm{Var}\\left(m + \\frac{\\varepsilon}{R_{b}}\\right) = \\frac{1}{R_{b}^{2}}\\mathrm{Var}(\\varepsilon) = \\frac{\\sigma_{m}^{2}}{R_{b}^{2}}$$\n因此，$\\Delta$ 的分布为：\n$$\\Delta \\sim \\mathcal{N}\\left(m, \\left(\\frac{\\sigma_{m}}{R_{b}}\\right)^{2}\\right)$$\n\n**2. 表示欠抛光概率 $\\mathbb{P}(\\Delta  0)$**\n\n如果施加的抛光时间 $t$ 小于理想清除时间 $t_{\\mathrm{clear}}$，就会发生欠抛光，这等价于条件 $\\Delta  0$。我们可以使用上面推导出的 $\\Delta$ 的分布来计算这个概率。设 $\\Phi(z)$ 为标准正态分布 $\\mathcal{N}(0,1)$ 的累积分布函数 (CDF)。\n$$\\mathbb{P}(\\Delta  0) = \\mathbb{P}\\left(\\frac{\\Delta - \\mu_{\\Delta}}{\\sigma_{\\Delta}}  \\frac{0 - m}{\\sigma_{m}/R_{b}}\\right)$$\n$$\\mathbb{P}(\\Delta  0) = \\Phi\\left(-\\frac{m R_{b}}{\\sigma_{m}}\\right)$$\n\n**3. 确定满足风险约束的最小 $m$**\n\n问题指定了关于欠抛光概率的风险约束：\n$$\\mathbb{P}(t  t_{\\mathrm{clear}}) \\le \\alpha \\implies \\mathbb{P}(\\Delta  0) \\le \\alpha$$\n代入概率的表达式：\n$$\\Phi\\left(-\\frac{m R_{b}}{\\sigma_{m}}\\right) \\le \\alpha$$\n由于累积分布函数 $\\Phi$ 是单调递增的，我们可以对其两边应用其反函数，即分位数函数 $\\Phi^{-1}$：\n$$-\\frac{m R_{b}}{\\sigma_{m}} \\le \\Phi^{-1}(\\alpha)$$\n解出 $m$（并注意 $R_{b} > 0, \\sigma_{m} > 0$）：\n$$m \\ge -\\frac{\\sigma_{m}}{R_{b}}\\Phi^{-1}(\\alpha)$$\n使用标准正态分布的对称性质 $\\Phi^{-1}(\\alpha) = -\\Phi^{-1}(1-\\alpha)$，我们得到：\n$$m \\ge \\frac{\\sigma_{m}}{R_{b}}\\Phi^{-1}(1-\\alpha)$$\n我们的目标是最小化预期侵蚀 $\\mathbb{E}[E]$。我们将看到，$\\mathbb{E}[E]$ 是 $m$ 的一个单调递增函数。因此，为了在满足约束的同时最小化 $\\mathbb{E}[E]$，我们必须选择 $m$ 的最小可能值。这在不等式变为等式时发生。因此，最优裕量 $m^{\\star}$ 为：\n$$m^{\\star} = \\frac{\\sigma_{m}}{R_{b}}\\Phi^{-1}(1-\\alpha)$$\n由于 $\\alpha \\in (0,1)$，对于典型的风险容差（$\\alpha  0.5$），我们有 $1-\\alpha > 0.5$ 和 $\\Phi^{-1}(1-\\alpha) > 0$，这确保了按要求 $m^{\\star} \\ge 0$。\n\n**4. 计算最小预期侵蚀 $\\mathbb{E}[E]$**\n\n侵蚀厚度 $E$ 由 $E = R_{e} \\max\\{t - t_{\\mathrm{clear}}, 0\\}$ 给出，可以写成：\n$$E = R_{e} \\max\\{\\Delta, 0\\}$$\n预期侵蚀为 $\\mathbb{E}[E] = R_{e} \\mathbb{E}[\\max\\{\\Delta, 0\\}]$。这需要计算一个修正高斯随机变量的期望。对于一个一般的高斯随机变量 $X \\sim \\mathcal{N}(\\mu, \\sigma^2)$，这个期望是一个标准结果：\n$$\\mathbb{E}[\\max\\{X, 0\\}] = \\mu \\Phi\\left(\\frac{\\mu}{\\sigma}\\right) + \\sigma \\phi\\left(\\frac{\\mu}{\\sigma}\\right)$$\n其中 $\\phi(z) = (2\\pi)^{-1/2} e^{-z^2/2}$ 是标准正态分布的概率密度函数 (PDF)。\n\n在我们的例子中，随机变量是 $\\Delta \\sim \\mathcal{N}(\\mu_{\\Delta}, \\sigma_{\\Delta}^{2})$，其中 $\\mu_{\\Delta} = m^{\\star}$ 且 $\\sigma_{\\Delta} = \\sigma_{m}/R_{b}$。我们定义 $z_{\\alpha} = \\Phi^{-1}(1-\\alpha)$。\n在最优策略下，$\\Delta$ 的均值为 $\\mu_{\\Delta} = m^{\\star} = \\sigma_{\\Delta} z_{\\alpha}$。因此，比率 $\\mu_{\\Delta}/\\sigma_{\\Delta}$ 就是 $z_{\\alpha}$。\n将这些代入期望的公式中：\n$$\\mathbb{E}[\\max\\{\\Delta, 0\\}] = \\mu_{\\Delta} \\Phi(z_{\\alpha}) + \\sigma_{\\Delta} \\phi(z_{\\alpha})$$\n根据分位数函数的定义，$\\Phi(z_{\\alpha}) = \\Phi(\\Phi^{-1}(1-\\alpha)) = 1-\\alpha$。\n$$\\mathbb{E}[\\max\\{\\Delta, 0\\}] = m^{\\star}(1-\\alpha) + \\frac{\\sigma_{m}}{R_{b}}\\phi(z_{\\alpha})$$\n最后，最小预期侵蚀 $\\mathbb{E}[E]_{\\mathrm{min}}$ 为：\n$$\\mathbb{E}[E]_{\\mathrm{min}} = R_{e} \\left[ m^{\\star}(1-\\alpha) + \\frac{\\sigma_{m}}{R_{b}}\\phi(\\Phi^{-1}(1-\\alpha)) \\right]$$\n这些关于 $m^{\\star}$ 和 $\\mathbb{E}[E]_{\\mathrm{min}}$ 的公式可以直接实现，以解决给定的测试用例。请注意，最终的表达式不依赖于 $\\mu_{T}$ 或 $\\sigma_{T}$，因为在考虑过抛光持续时间 $\\Delta$ 时，它们对抛光时间计算的影响被抵消了。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import norm\n\ndef solve():\n    \"\"\"\n    Computes the optimal over-polish margin and resulting minimum expected erosion\n    for a series of CMP process scenarios.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (mu_T, sigma_T, sigma_m, R_b, R_e, alpha)\n    test_cases = [\n        (30.0, 3.0, 5.0, 1.0, 0.2, 0.05),\n        (15.0, 1.0, 2.0, 1.2, 0.1, 0.5),\n        (40.0, 5.0, 0.1, 1.5, 0.05, 0.01),\n        (25.0, 4.0, 10.0, 0.8, 0.25, 0.1),\n        (50.0, 8.0, 7.0, 0.5, 0.2, 1e-6)\n    ]\n\n    results = []\n    for case in test_cases:\n        # Unpack parameters for the current test case.\n        # mu_T and sigma_T are not required for the calculation as shown in the derivation.\n        _mu_T, _sigma_T, sigma_m, R_b, R_e, alpha = case\n\n        # 1. Calculate the (1-alpha) quantile of the standard normal distribution.\n        # This value is often denoted as z_alpha.\n        # z_alpha = Phi^{-1}(1 - alpha)\n        z_alpha = norm.ppf(1 - alpha)\n\n        # 2. Calculate the optimal over-polish margin m_star.\n        # m_star = (sigma_m / R_b) * z_alpha\n        m_star = (sigma_m / R_b) * z_alpha\n\n        # 3. Calculate the value of the standard normal PDF at z_alpha.\n        # phi_z_alpha = phi(z_alpha)\n        phi_z_alpha = norm.pdf(z_alpha)\n\n        # 4. Compute the minimum expected erosion E_E_min.\n        # E_E_min = R_e * [m_star * (1-alpha) + (sigma_m / R_b) * phi(z_alpha)]\n        term1 = m_star * (1 - alpha)\n        term2 = (sigma_m / R_b) * phi_z_alpha\n        E_E_min = R_e * (term1 + term2)\n        \n        # Round the results to six decimal places as required.\n        m_star_rounded = round(m_star, 6)\n        E_E_min_rounded = round(E_E_min, 6)\n        \n        results.append(f\"[{m_star_rounded:.6f},{E_E_min_rounded:.6f}]\")\n\n    # Final print statement in the exact required format.\n    # e.g., [[m*1,e1],[m*2,e2],...]\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}