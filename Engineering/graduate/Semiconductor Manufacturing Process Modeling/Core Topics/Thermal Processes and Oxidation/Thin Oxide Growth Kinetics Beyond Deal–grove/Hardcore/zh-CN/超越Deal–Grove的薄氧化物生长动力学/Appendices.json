{
    "hands_on_practices": [
        {
            "introduction": "经典的Deal-Grove模型在描述超薄氧化层生长时常常失效，一个重要的物理原因是在硅/二氧化硅界面处存在一个结构不同的过渡层。该界面层本身具有有限的输运阻力，这在经典模型中被忽略了。本练习将指导您通过稳态下耦合菲克扩散定律和界面反应动力学，推导出该输运阻力如何修正整体氧化速率，这是一个典型的串联阻力问题，有助于加深对输运与反应竞争机制的理解。",
            "id": "4175855",
            "problem": "在晶体硅的干法氧化薄氧化层区域中，由于硅/二氧化硅界面处存在一个界面亚氧化层，其有限的输运阻力导致了对经典Deal–Grove模型的偏离。考虑一个在温度$T$下的稳态等温过程，其中气相和体二氧化硅的输运阻力可以忽略不计，但一个厚度为$\\delta_i$、扩散系数为$D_i(T)$的亚氧化物界面层对氧化剂向反应性硅界面的输运构成了有限的屏障。设界面层外边缘的氧化剂浓度为$C_0$，内禀界面反应速率系数（在一个抑制了输运限制的独立实验中测得）为$m(T)$，由界面反应通量$J = m(T)\\,C_i$定义，其中$C_i$是硅界面处的氧化剂浓度。氧化物生长速率$v$与氧化剂通量$J$的关系为$v = J/N_1$，其中$N_1$是每单位体积二氧化硅中并入的氧化剂分子数密度。\n\n仅从穿越界面层的一维扩散的菲克第一定律和反应界面处的线性动力学边界条件出发，推导一个考虑了界面层有限输运阻力的校正后初始氧化物生长速率$v_{\\mathrm{corr}}(T)$的表达式。然后，使用以下参数对$v_{\\mathrm{corr}}(T)$进行数值计算：\n- $m(T) = 1.2 \\times 10^{-6}\\ \\mathrm{cm/s}$，\n- $\\delta_i = 0.70\\ \\mathrm{nm}$，\n- $D_i(T) = 5.0 \\times 10^{-14}\\ \\mathrm{cm^2/s}$，\n- $C_0 = 1.0 \\times 10^{19}\\ \\mathrm{cm^{-3}}$，\n- $N_1 = 2.21 \\times 10^{22}\\ \\mathrm{cm^{-3}}$。\n\n将您计算的$v_{\\mathrm{corr}}(T)$最终答案以$\\mathrm{nm/s}$为单位表示，并将结果四舍五入到四位有效数字。",
            "solution": "首先对用户提供的问题进行严格的验证过程。\n\n### 步骤 1：提取已知条件\n问题陈述中明确给出的数据、变量和条件如下：\n-   **体系**：晶体硅在薄氧化层区域的稳态等温干法氧化。\n-   **温度**：$T$。\n-   **输运阻力**：气相和体二氧化硅的阻力可以忽略不计。\n-   **界面亚氧化层厚度**：$\\delta_i$。\n-   **界面亚氧化层扩散系数**：$D_i(T)$。\n-   **界面层外边缘的氧化剂浓度**：$C_0$。\n-   **内禀界面反应速率系数**：$m(T)$。\n-   **界面反应通量定义**：$J = m(T) C_i$，其中$C_i$是硅界面处的氧化剂浓度。\n-   **生长速率定义**：$v = J/N_1$，其中$N_1$是每单位体积二氧化硅中并入的氧化剂分子数密度。\n-   **数值参数**：\n    -   $m(T) = 1.2 \\times 10^{-6}\\ \\mathrm{cm/s}$\n    -   $\\delta_i = 0.70\\ \\mathrm{nm}$\n    -   $D_i(T) = 5.0 \\times 10^{-14}\\ \\mathrm{cm^2/s}$\n    -   $C_0 = 1.0 \\times 10^{19}\\ \\mathrm{cm^{-3}}$\n    -   $N_1 = 2.21 \\times 10^{22}\\ \\mathrm{cm^{-3}}$\n\n### 步骤 2：使用提取的已知条件进行验证\n根据所需标准对问题进行评估：\n-   **科学依据**：该问题描述了半导体制造中一个公认的物理现象——薄氧化层生长的初始输运限制区域，该区域偏离了经典的Deal–Grove模型。使用菲克第一定律描述扩散和界面处的线性反应速率是输运现象和表面动力学中标准且成熟的原理。该模型是一个物理上合理的简化。\n-   **适定性**：该问题是适定的。它提供了两个物理定律（扩散和反应），在稳态假设下可以结合起来唯一地确定氧化剂通量，并因此确定氧化物生长速率。推导和数值计算所需的所有参数都已提供。\n-   **客观性**：措辞精确、定量，没有主观或含糊的语言。\n-   **完整性与一致性**：该问题是自洽的。经过标准的单位转换（$\\mathrm{nm}$到$\\mathrm{cm}$）后，所提供的参数在量纲上是一致的，其量级对于硅氧化过程是物理上现实的。不存在矛盾之处。\n\n### 步骤 3：结论与行动\n该问题被判定为**有效**。它具有科学依据，是适定的，并且提供了所有必要的信息。现在将进行解答推导。\n\n### 校正后氧化物生长速率的推导\n目标是通过同时考虑跨界面层的扩散和硅表面的反应来求得稳态氧化剂通量$J$。设$x$为垂直于界面的空间坐标，其中$x=0$在亚氧化物层的外边缘，$x=\\delta_i$在反应性硅界面。氧化剂浓度表示为$C(x)$。\n\n边界条件为：\n1.  在$x=0$处，浓度为$C(0) = C_0$。\n2.  在$x=\\delta_i$处，浓度为$C(\\delta_i) = C_i$。\n\n在稳态条件下，氧化剂通量$J$在整个层中是恒定的。根据一维扩散的菲克第一定律，该通量由下式给出：\n$$\nJ = -D_i(T) \\frac{dC}{dx}\n$$\n由于$J$和$D_i(T)$是常数，我们可以将此方程从$x=0$到$x=\\delta_i$对整个界面层进行积分：\n$$\n\\int_{0}^{\\delta_i} J \\, dx = \\int_{C_0}^{C_i} -D_i(T) \\, dC\n$$\n$$\nJ \\delta_i = -D_i(T) (C_i - C_0)\n$$\n这给出了扩散限制通量的表达式：\n$$\nJ = \\frac{D_i(T)}{\\delta_i} (C_0 - C_i)\n$$\n在反应界面（$x=\\delta_i$）处，通量被化学反应消耗掉。问题陈述该反应通量由线性动力学定律描述：\n$$\nJ = m(T) C_i\n$$\n我们现在得到了一个关于两个未知数$J$和$C_i$的方程组。为了找到一个只依赖于已知参数的$J$的表达式，我们消去未知的界面浓度$C_i$。从反应速率方程中，我们将$C_i$表示为：\n$$\nC_i = \\frac{J}{m(T)}\n$$\n将此代入扩散通量方程：\n$$\nJ = \\frac{D_i(T)}{\\delta_i} \\left(C_0 - \\frac{J}{m(T)}\\right)\n$$\n现在我们求解这个关于$J$的方程：\n$$\nJ = \\frac{D_i(T) C_0}{\\delta_i} - \\frac{D_i(T) J}{\\delta_i m(T)}\n$$\n$$\nJ + \\frac{D_i(T) J}{\\delta_i m(T)} = \\frac{D_i(T) C_0}{\\delta_i}\n$$\n$$\nJ \\left(1 + \\frac{D_i(T)}{\\delta_i m(T)}\\right) = \\frac{D_i(T) C_0}{\\delta_i}\n$$\n$$\nJ = \\frac{\\frac{D_i(T) C_0}{\\delta_i}}{1 + \\frac{D_i(T)}{\\delta_i m(T)}} = \\frac{D_i(T) C_0}{\\delta_i} \\left(\\frac{\\delta_i m(T)}{\\delta_i m(T) + D_i(T)}\\right)\n$$\n简化表达式得到总通量$J$：\n$$\nJ = \\frac{m(T) D_i(T) C_0}{m(T) \\delta_i + D_i(T)}\n$$\n为了得到一个物理上更直观的形式，我们可以将分子和分母同除以$D_i(T)$：\n$$\nJ = \\frac{m(T) C_0}{1 + \\frac{m(T) \\delta_i}{D_i(T)}}\n$$\n氧化物生长速率$v$与通量$J$的关系为$v = J/N_1$。因此，校正后的初始生长速率$v_{\\mathrm{corr}}(T)$为：\n$$\nv_{\\mathrm{corr}}(T) = \\frac{J}{N_1} = \\frac{1}{N_1} \\left( \\frac{m(T) C_0}{1 + \\frac{m(T) \\delta_i}{D_i(T)}} \\right)\n$$\n这就是所要求的解析表达式。\n\n### 数值计算\n接下来，我们使用所提供的参数来计算此表达式的值。首先，我们必须确保所有单位都一致。我们将使用cgs单位制（厘米、克、秒）。\n给定的参数是：\n-   $m(T) = 1.2 \\times 10^{-6}\\ \\mathrm{cm/s}$\n-   $\\delta_i = 0.70\\ \\mathrm{nm} = 0.70 \\times 10^{-7}\\ \\mathrm{cm}$\n-   $D_i(T) = 5.0 \\times 10^{-14}\\ \\mathrm{cm^2/s}$\n-   $C_0 = 1.0 \\times 10^{19}\\ \\mathrm{cm^{-3}}$\n-   $N_1 = 2.21 \\times 10^{22}\\ \\mathrm{cm^{-3}}$\n\n首先，计算分母中的无量纲项，它代表了反应速率与扩散速率之比：\n$$\n\\frac{m(T) \\delta_i}{D_i(T)} = \\frac{(1.2 \\times 10^{-6}\\ \\mathrm{cm/s}) \\times (0.70 \\times 10^{-7}\\ \\mathrm{cm})}{5.0 \\times 10^{-14}\\ \\mathrm{cm^2/s}} = \\frac{0.84 \\times 10^{-13}\\ \\mathrm{cm^2/s}}{5.0 \\times 10^{-14}\\ \\mathrm{cm^2/s}} = 1.68\n$$\n现在，将这个值代入$v_{\\mathrm{corr}}(T)$的表达式中：\n$$\nv_{\\mathrm{corr}}(T) = \\frac{1}{N_1} \\left( \\frac{m(T) C_0}{1 + 1.68} \\right) = \\frac{m(T) C_0}{2.68 N_1}\n$$\n$$\nv_{\\mathrm{corr}}(T) = \\frac{(1.2 \\times 10^{-6}\\ \\mathrm{cm/s}) \\times (1.0 \\times 10^{19}\\ \\mathrm{cm^{-3}})}{2.68 \\times (2.21 \\times 10^{22}\\ \\mathrm{cm^{-3}})}\n$$\n$$\nv_{\\mathrm{corr}}(T) = \\frac{1.2 \\times 10^{13}}{5.9228 \\times 10^{22}}\\ \\mathrm{cm/s} \\approx 2.02606 \\times 10^{-10}\\ \\mathrm{cm/s}\n$$\n问题要求答案以$\\mathrm{nm/s}$为单位。我们使用转换因子$1\\ \\mathrm{cm} = 10^7\\ \\mathrm{nm}$：\n$$\nv_{\\mathrm{corr}}(T) = (2.02606 \\times 10^{-10}\\ \\mathrm{cm/s}) \\times (10^7\\ \\mathrm{nm/cm}) = 2.02606 \\times 10^{-3}\\ \\mathrm{nm/s}\n$$\n将结果四舍五入到四位有效数字，得到：\n$$\nv_{\\mathrm{corr}}(T) = 2.026 \\times 10^{-3}\\ \\mathrm{nm/s}\n$$",
            "answer": "$$\\boxed{2.026 \\times 10^{-3}}$$"
        },
        {
            "introduction": "除了建立详细的物理模型，唯象模型是拟合实验数据的强大工具，特别是在描述Deal-Grove模型失效的初始快速氧化阶段。本练习将带您应用Massoud模型，它通过一个指数衰减项来描述初始生长速率的增强。您将学习如何通过线性化近似，将复杂的非线性关系简化，并使用基本的线性回归技术从假设的实验数据中提取关键的动力学参数。",
            "id": "4175856",
            "problem": "给定三个独立的干法热氧化测量数据集，温度为 $800\\,^{\\circ}\\mathrm{C}$，针对厚度 $x$ 限制在 $x  5\\,\\mathrm{nm}$ 的薄二氧化硅膜。每个数据集由成对的测量值 $(t_i,x_i)$ 组成，其中 $t_i$ 是时间（单位为 $\\mathrm{s}$），$x_i$ 是氧化层厚度（单位为 $\\mathrm{nm}$）。目标是通过对 Massoud 等人提出的薄氧化层生长动力学在小厚度范围内进行线性化，来估计参数 $C$（无量纲）和 $x_0$（单位为 $\\mathrm{nm}$）。\n\n基本依据和建模假设：\n- 通过氧化物的扩散遵循菲克第一定律，界面反应动力学由经典的 Deal–Grove 模型描述，在反应限制区域内，在固定温度下，该模型产生一个恒定的基础速率 $K_0 = B/A$。假设在 $800\\,^{\\circ}\\mathrm{C}$ 时，$K_0$ 是已知且恒定的。\n- 对于非常薄的氧化层，反应速率会受到一个与厚度相关的因子的增强，该因子随 $x$ 的增加而迅速衰减，其特征在于一个未知的振幅 $C$（无量纲）和一个特征衰减厚度 $x_0$（单位为 $\\mathrm{nm}$）。在 $x$ 很小的极限下，根据这些假设，瞬时生长速率 $\\mathrm{d}x/\\mathrm{d}t$ 可以在 $x=0$ 附近对 $x$ 进行线性化。\n\n任务：\n1. 从反应限制近似和厚度依赖性增强随特征长度衰减的概念出发，推导出一个在小 $x$ 范围内有效的瞬时生长速率 $\\mathrm{d}x/\\mathrm{d}t$ 与氧化层厚度 $x$ 之间的线性化关系。将线性化形式表示为 $\\mathrm{d}x/\\mathrm{d}t \\approx m\\,x + b$，并将斜率 $m$ 和截距 $b$ 与 $K_0$、$C$ 和 $x_0$ 联系起来。\n2. 设计一个算法，在给定带噪声的 $(t_i,x_i)$ 数据的情况下：\n   - 使用 $(t_i,x_i)$ 上的有限差分法估计每个测量点的 $\\mathrm{d}x/\\mathrm{d}t$。\n   - 选择与观测到的 $x_i$ 值中最小的一半相关联的点子集，以在拟合中强制执行小 $x$ 线性化区域。\n   - 对估计的 $\\mathrm{d}x/\\mathrm{d}t$ 与 $x$ 进行最小二乘线性回归，以获得 $m$ 和 $b$ 的数值估计。\n   - 使用您推导出的关系，从 $m$ 和 $b$ 计算 $C$（无量纲）和 $x_0$（单位为 $\\mathrm{nm}$）。\n\n对所有数据集使用以下常数：\n- $800\\,^{\\circ}\\mathrm{C}$ 时的基础反应限制速率：$K_0 = 0.02\\,\\mathrm{nm/s}$。\n\n测试套件（所有时间单位为 $\\mathrm{s}$，厚度单位为 $\\mathrm{nm}$）：\n- 数据集 1（理想情况；中等衰减尺度）：\n  - $x$: $[0.2, 0.5, 1.0, 2.0, 3.5, 5.0]$\n  - $t$: $[2.6296, 7.0870, 16.0369, 39.9750, 90.2980, 153.6000]$\n- 数据集 2（边缘情况；非常大的衰减尺度 $x_0$ 导致初始速率几乎恒定）：\n  - $x$: $[0.1, 1.0, 3.0, 5.0]$\n  - $t$: $[1.2505, 12.5440, 37.9250, 63.9200]$\n- 数据集 3（边界条件；最少点数且 $x_0$ 较小）：\n  - $x$: $[0.2, 0.8, 1.5]$\n  - $t$: $[4.3160, 20.9560, 46.6800]$\n\n输出规范：\n- 对每个数据集，计算并返回一对 $(C, x_0)$。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果按数据集 1、数据集 2、数据集 3 的顺序排列，即：$[C_1, x_{0,1}, C_2, x_{0,2}, C_3, x_{0,3}]$。\n- 将 $C$ 表示为无量纲浮点数，将 $x_0$ 表示为单位为 $\\mathrm{nm}$ 的浮点数。将每个输出值四舍五入到六位小数。",
            "solution": "该问题被评估为有效，因为它在科学上基于半导体物理学的既定原理（特别是 Deal-Grove 和 Massoud 的热氧化模型），问题设定良好，目标明确，数据充分，并且表述客观，没有歧义。\n\n根据要求，解答过程分为两部分：首先，推导线性化的生长动力学；其次，实现一个数值算法，以根据所提供的数据估计模型参数。\n\n**第1部分：线性化生长速率的推导**\n\n在反应限制区域（适用于非常薄的氧化层）的标准 Deal-Grove 模型假设了一个恒定的生长速率：\n$$\n\\frac{\\mathrm{d}x}{\\mathrm{d}t} \\approx \\frac{B}{A} = K_0\n$$\n其中 $x$ 是氧化层厚度，$t$ 是时间，$K_0$ 是线性速率常数，给定为 $K_0 = 0.02\\,\\mathrm{nm/s}$。\n\n问题指出，对于厚度低于约 $5\\,\\mathrm{nm}$ 的情况，该速率会受到一个随厚度增加而衰减的因子的增强。这是 Massoud 模型的特征。这种增强的标准数学形式是在基础速率上增加一个指数衰减项。因此，总生长速率可以建模为：\n$$\n\\frac{\\mathrm{d}x}{\\mathrm{d}t} = K_0 + \\text{enhancement}\n$$\n增强项本身通常与一个基础速率成正比并呈指数衰减。我们可以将总速率表示为：\n$$\n\\frac{\\mathrm{d}x}{\\mathrm{d}t} = K_0 \\left(1 + C \\exp\\left(-\\frac{x}{x_0}\\right)\\right)\n$$\n在这里，$C$ 是一个无量纲常数，表示在 $x=0$ 时的速率增强幅度，$x_0$ 是特征衰减长度，单位为 $\\mathrm{nm}$。\n\n为了对小 $x$（即 $x \\ll x_0$）的这个表达式进行线性化，我们对指数项在 $x=0$ 附近进行一阶泰勒级数展开：\n$$\n\\exp\\left(-\\frac{x}{x_0}\\right) \\approx \\exp(0) + \\left. \\frac{\\mathrm{d}}{\\mathrm{d}x}\\left(\\exp\\left(-\\frac{x}{x_0}\\right)\\right) \\right|_{x=0} \\cdot x\n$$\n其导数为：\n$$\n\\frac{\\mathrm{d}}{\\mathrm{d}x}\\left(\\exp\\left(-\\frac{x}{x_0}\\right)\\right) = -\\frac{1}{x_0}\\exp\\left(-\\frac{x}{x_0}\\right)\n$$\n在 $x=0$ 处计算此导数，得到的值为 $-1/x_0$。将此代入泰勒展开式：\n$$\n\\exp\\left(-\\frac{x}{x_0}\\right) \\approx 1 - \\frac{x}{x_0}\n$$\n现在，我们将此线性近似代回到完整的生长速率方程中：\n$$\n\\frac{\\mathrm{d}x}{\\mathrm{d}t} \\approx K_0 \\left(1 + C \\left(1 - \\frac{x}{x_0}\\right)\\right)\n$$\n展开各项，我们得到：\n$$\n\\frac{\\mathrm{d}x}{\\mathrm{d}t} \\approx K_0 \\left(1 + C - \\frac{C}{x_0}x\\right)\n$$\n$$\n\\frac{\\mathrm{d}x}{\\mathrm{d}t} \\approx \\left(-\\frac{K_0 C}{x_0}\\right)x + K_0(1+C)\n$$\n此表达式符合所期望的线性形式 $\\mathrm{d}x/\\mathrm{d}t \\approx mx + b$。通过比较系数，我们建立以下关系：\n$$\nm = -\\frac{K_0 C}{x_0} \\quad (\\text{斜率})\n$$\n$$\nb = K_0(1+C) \\quad (\\text{y轴截距})\n$$\n我们的目标是从实验确定的斜率 $m$ 和截距 $b$ 中求出 $C$ 和 $x_0$。我们可以重新整理这两个方程。从关于 $b$ 的方程：\n$$\nb = K_0 + K_0 C \\implies K_0 C = b - K_0\n$$\n$$\nC = \\frac{b - K_0}{K_0} = \\frac{b}{K_0} - 1\n$$\n现在，将 $K_0 C$ 的表达式代入关于 $m$ 的方程：\n$$\nm = -\\frac{b - K_0}{x_0}\n$$\n解出 $x_0$：\n$$\nx_0 = -\\frac{b - K_0}{m} = \\frac{K_0 - b}{m}\n$$\n一旦从实验数据中估计出 $m$ 和 $b$，这两个关系式就允许直接计算 $C$ 和 $x_0$。\n\n**第2部分：参数估计的算法设计**\n\n从给定的数据集 $(t_i, x_i)$ 估计 $m$ 和 $b$ 的算法执行如下：\n\n1.  **估计生长速率**：对于每个测量点 $(t_i, x_i)$，必须从离散数据中估计瞬时生长速率 $(\\mathrm{d}x/\\mathrm{d}t)_i$。我们使用有限差分近似：\n    *   对于第一个点（$i=0$）：使用前向差分，$(\\frac{\\mathrm{d}x}{\\mathrm{d}t})_0 \\approx \\frac{x_1 - x_0}{t_1 - t_0}$。\n    *   对于内部点（$0  i  N-1$）：为获得更好的精度，使用中心差分，$(\\frac{\\mathrm{d}x}{\\mathrm{d}t})_i \\approx \\frac{x_{i+1} - x_{i-1}}{t_{i+1} - t_{i-1}}$。\n    *   对于最后一个点（$i=N-1$）：使用后向差分，$(\\frac{\\mathrm{d}x}{\\mathrm{d}t})_{N-1} \\approx \\frac{x_{N-1} - x_{N-2}}{t_{N-1} - t_{N-2}}$。\n    这样就产生了一组估计的速率 $\\{(\\mathrm{d}x/\\mathrm{d}t)_i\\}$。\n\n2.  **选择数据子集**：线性化仅对小 $x$ 有效。问题指定使用与“观测到的 $x_i$ 值中最小的一半”相对应的点子集。由于输入数据 $x_i$ 是按升序排序的，这对应于数据点的前半部分。对于大小为 $N$ 的数据集，我们选择前 $k = \\lceil N/2 \\rceil$ 个点。这为我们提供了数据子集 $(x_j, (\\mathrm{d}x/\\mathrm{d}t)_j)$，其中 $j = 0, \\ldots, k-1$。\n\n3.  **执行线性回归**：对所选子集执行最小二乘线性回归，以拟合模型 $(\\mathrm{d}x/\\mathrm{d}t) = mx + b$。这将找到最小化估计速率与线性模型之间残差平方和的参数 $m$ 和 $b$。标准的数值软件包提供了此功能。\n\n4.  **计算 C 和 x_0**：使用回归得到的 $m$ 和 $b$ 值以及已知的 $K_0$ 值，利用推导出的公式计算物理参数：\n    $$\n    C = \\frac{b}{K_0} - 1\n    $$\n    $$\n    x_0 = \\frac{K_0 - b}{m}\n    $$\n对提供的三个数据集中的每一个重复此过程，以获得 $(C_1, x_{0,1})$、$(C_2, x_{0,2})$ 和 $(C_3, x_{0,3})$。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for thin oxide growth parameters C and x0 using a linearized Massoud model.\n    \"\"\"\n    \n    # Base reaction-limited rate constant at 800 C\n    K0 = 0.02  # in nm/s\n\n    # Test suite of datasets\n    test_cases = [\n        {\n            \"x\": np.array([0.2, 0.5, 1.0, 2.0, 3.5, 5.0]),  # nm\n            \"t\": np.array([2.6296, 7.0870, 16.0369, 39.9750, 90.2980, 153.6000])  # s\n        },\n        {\n            \"x\": np.array([0.1, 1.0, 3.0, 5.0]),\n            \"t\": np.array([1.2505, 12.5440, 37.9250, 63.9200])\n        },\n        {\n            \"x\": np.array([0.2, 0.8, 1.5]),\n            \"t\": np.array([4.3160, 20.9560, 46.6800])\n        }\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        x_data = case[\"x\"]\n        t_data = case[\"t\"]\n        n_points = len(x_data)\n\n        # Step 1: Estimate growth rate dx/dt using finite differences\n        dxdt = np.zeros(n_points)\n        if n_points > 1:\n            # Forward difference for the first point\n            dxdt[0] = (x_data[1] - x_data[0]) / (t_data[1] - t_data[0])\n            # Backward difference for the last point\n            dxdt[-1] = (x_data[-1] - x_data[-2]) / (t_data[-1] - t_data[-2])\n        \n        # Central difference for interior points\n        for i in range(1, n_points - 1):\n            dxdt[i] = (x_data[i+1] - x_data[i-1]) / (t_data[i+1] - t_data[i-1])\n\n        # Step 2: Select the subset of points for linearization\n        # Using the smallest half of the observed x_i values.\n        # Since x is sorted, this is the first half of the points.\n        # The number of points is ceil(N/2).\n        subset_size = int(np.ceil(n_points / 2.0))\n        \n        # Handle cases with very few points for regression\n        if subset_size  2 and n_points >= 2:\n            subset_size = 2 # Need at least 2 points for a line fit\n        \n        x_subset = x_data[:subset_size]\n        dxdt_subset = dxdt[:subset_size]\n\n        # Step 3: Perform least-squares linear regression (dxdt = m*x + b)\n        # polyfit returns [slope, intercept] for degree 1\n        if len(x_subset)  2:\n            # Cannot perform regression with less than 2 points.\n            # This case should not be reached with the given data and logic.\n            # Appending NaNs to indicate failure for this case.\n            C = np.nan\n            x0 = np.nan\n        else:\n            m, b = np.polyfit(x_subset, dxdt_subset, 1)\n\n            # Step 4: Compute C and x0 from m and b\n            # C = b/K0 - 1\n            # x0 = (K0 - b) / m\n            C = b / K0 - 1.0\n            \n            # Avoid division by zero if m is numerically zero\n            if np.isclose(m, 0):\n                x0 = np.inf\n            else:\n                x0 = (K0 - b) / m\n        \n        results.extend([C, x0])\n\n    # Format the final output string as specified\n    output_str = f\"[{','.join([f'{val:.6f}' for val in results])}]\"\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "当面对多种描述同一物理过程的竞争模型时，工艺工程师或科学家的一项核心任务是确定哪一个模型在给定数据下能最好地反映物理现实。本练习将引导您超越简单的曲线拟合，进入严谨的模型选择领域。通过将多个模型（抛物线模型、完整的Deal-Grove模型和Massoud修正模型）拟合到同一数据集，并应用Akaike信息准则（$AIC$）和Bayesian信息准则（$BIC$）等统计工具，您将学习如何权衡模型的拟合优度与复杂度，从而做出科学合理的选择。",
            "id": "4175857",
            "problem": "考虑硅氧化形成二氧化硅的过程，该过程处于薄氧化层范围，即氧化层厚度小于$5$纳米。经典的 Deal–Grove 模型假设氧化剂通过氧化层进行准稳态扩散，并在硅/氧化物界面发生界面消耗。在薄氧化层范围内，由于有限的界面反应速率和近表面的动力学增强效应，模型表现出与经典假设的偏差。从扩散-反应平衡和通量守恒出发，推导三种相互竞争的氧化动力学模型的控制关系，这些关系是时间 $t$ 和厚度 $x$ 的函数：(i) 扩散限制的 Deal–Grove 模型，(ii) 有限界面反应速率（有限-$k$）模型，以及 (iii) 适用于极薄氧化层且随 $x$ 衰减的唯象增强模型（Massoud 校正模型）。您的推导必须基于基本定律和核心定义：质量守恒、菲克扩散定律和一级界面反应速率。将这些模型表示为 $x(t)$ 的时间演化规则，使其适合与观测数据进行拟合，并确保每个模型的参数及其物理单位都得到明确定义。\n\n使用推导出的模型，对以下用于干氧氧化的氧化数据测试套件进行非线性最小二乘法参数估计。时间 $t$ 必须以秒为单位，厚度 $x$ 以纳米为单位，所有拟合参数必须在内部与这些单位保持一致。\n\n测试套件：\n- 情况 $1$（具有强早期增强效应的极薄氧化层）：时间 $t = [0,2,4,8,16,32]$ 秒，观测厚度 $x = [0.6,0.9,1.2,1.7,2.3,3.1]$ 纳米。\n- 情况 $2$（反应限制行为在早期占主导）：时间 $t = [0,10,20,40,80,120]$ 秒，观测厚度 $x = [0.7,1.0,1.25,1.65,2.1,2.4]$ 纳米。\n- 情况 $3$（数据极少的超薄氧化层）：时间 $t = [0,2,4,6,8]$ 秒，观测厚度 $x = [0.3,0.5,0.65,0.78,0.90]$ 纳米。\n\n待拟合模型的定义和约束：\n- 模型 $1$：Deal–Grove 扩散限制模型，参数化以捕捉扩散限制行为，采用适合 $x  5$ 纳米的最小参数化。使用初始厚度参数 $x_0$ 以避免在 $t=0$ 时的奇异行为。参数必须为正，并以正确的单位表示。\n- 模型 $2$：Massoud 校正的唯象模型，增加一个随 $x$ 衰减的短程增强项。包含一个初始厚度参数 $x_0$，并确保所有参数均为正值且单位正确。\n- 模型 $3$：从有限界面反应速率推导出的有限-$k$ 界面反应模型，带有一个初始厚度参数 $x_0$。所有参数必须为正值且单位正确。\n\n假设测量误差独立且同分布，并具有恒定方差。对于每种情况和每个模型，计算赤池信息准则 (AIC) 和贝叶斯信息准则 (BIC)。赤池信息准则 (AIC) 和贝叶斯信息准则 (BIC) 定义如下：对于 $n$ 个数据点、$p$ 个拟合参数和残差平方和 $\\mathrm{RSS}$，使用\n$$ \\mathrm{AIC} = n \\ln\\left(\\frac{\\mathrm{RSS}}{n}\\right) + 2p, \\quad \\mathrm{BIC} = n \\ln\\left(\\frac{\\mathrm{RSS}}{n}\\right) + p \\ln(n). $$\n您必须在每种情况下通过最小的 $\\mathrm{AIC}$ 来选择偏好的模型；如果出现平局（数值上在 $10^{-6}$ 的容差范围内），则选择具有最小 $\\mathrm{BIC}$ 的模型。\n\n您的程序必须为每个模型估计参数，计算所有三种情况下所有三个模型的 $\\mathrm{AIC}$ 和 $\\mathrm{BIC}$，并报告每种情况下偏好的模型索引。使用以下模型到索引的映射：模型 $1$ 是 Deal–Grove 扩散限制模型，模型 $2$ 是 Massoud 校正模型，模型 $3$ 是有限-$k$ 模型。\n\n最终输出规格：\n您的程序应生成一行输出，其中包含情况 $1$、情况 $2$ 和情况 $3$ 的偏好模型索引，格式为一个逗号分隔的列表，并用方括号括起来（例如 $[2,3,1]$）。这些值必须是整数。所有数值结果均需使用以秒和纳米表示的所提供数据进行计算，并且参数必须在正值约束下进行拟合。",
            "solution": "该问题要求推导三种薄氧化层生长动力学模型，然后使用所提供的数据集进行参数估计和模型选择。验证和解决方案如下所示。\n\n### 问题验证\n\n**步骤 1：提取已知条件**\n\n- **主题**：超出 Deal–Grove 模型的薄氧化层（$x  5$ nm）生长动力学。\n- **物理系统**：硅氧化形成二氧化硅。\n- **基本原理**：质量守恒、菲克扩散定律、一级界面反应速率。\n- **待推导的模型**：\n    1.  `(i)` Deal–Grove 扩散限制模型。\n    2.  `(ii)` 有限-$k$ 界面反应速率模型。（这被解释为完整的 Deal–Grove 模型）。\n    3.  `(iii)` Massoud 校正的唯象增强模型。\n- **模型约束**：\n    - **模型 1（Deal–Grove 扩散限制）**：最小参数化，初始厚度 $x_0$，正参数。\n    - **模型 2（Massoud 校正）**：增加一个随 $x$ 衰减的短程增强项，初始厚度 $x_0$，正参数。\n    - **模型 3（有限-$k$）**：从有限界面反应速率推导，初始厚度 $x_0$，正参数。\n- **数据（测试套件）**：\n    - **情况 1**：$t = [0,2,4,8,16,32]$ 秒，$x = [0.6,0.9,1.2,1.7,2.3,3.1]$ 纳米。标记为“具有强早期增强效应的极薄氧化层”。\n    - **情况 2**：$t = [0,10,20,40,80,120]$ 秒，$x = [0.7,1.0,1.25,1.65,2.1,2.4]$ 纳米。标记为“反应限制行为在早期占主导”。\n    - **情况 3**：$t = [0,2,4,6,8]$ 秒，$x = [0.3,0.5,0.65,0.78,0.90]$ 纳米。标记为“数据极少的超薄氧化层”。\n- **单位**：时间 $t$ 以秒为单位，厚度 $x$ 以纳米为单位。\n- **分析任务**：通过非线性最小二乘法进行参数估计。假设测量误差独立且同分布。\n- **模型选择标准**：\n    - 计算赤池信息准则 (AIC) 和贝叶斯信息准则 (BIC)。\n    - 定义：$\\mathrm{AIC} = n \\ln(\\frac{\\mathrm{RSS}}{n}) + 2p$, $\\mathrm{BIC} = n \\ln(\\frac{\\mathrm{RSS}}{n}) + p \\ln(n)$，其中 $n$ 是数据点数，$p$ 是参数数量，$\\mathrm{RSS}$ 是残差平方和。\n    - 选择规则：选择 AIC 最小的模型。如果 AIC 值相等（在 $10^{-6}$ 的容差范围内），则选择 BIC 最小的模型。\n- **输出**：一个逗号分隔的列表，包含情况 1、2 和 3 的偏好模型索引。模型索引为 1 (Deal-Grove 扩散限制)、2 (Massoud 校正) 和 3 (有限-$k$)。\n\n**步骤 2：使用提取的已知条件进行验证**\n\n- **科学基础**：该问题明确地位于半导体工艺建模领域，这是材料科学和电气工程的一个子领域。所涉及的模型（Deal-Grove, Massoud）在该领域是经典模型。其底层原理（扩散、反应动力学）是物理化学的基本定律。该问题在科学上是合理的。\n- **良态问题**：问题提供了具体的数据集，并要求使用明确定义的统计标准（AIC, BIC）进行参数拟合和模型选择。这些模型一旦被公式化，便可导出一个可解的数值优化问题。最佳拟合参数的存在性和唯一性取决于数据质量和模型形式，这是数据分析中的一个标准挑战，但总体任务是良态的。\n- **客观性**：问题以精确、量化的方式陈述。数据以数值形式提供。任务和评估标准是客观且明确的。\n- **完整性**：问题提供了进行求解所需的所有必要数据、定义（AIC, BIC）和约束。虽然“有限-$k$”和“Massoud 校正”模型的具体形式需要根据标准文献进行解释，但这对于该领域的研究生级别问题来说是合理预期。这种解释受到所提供描述的限制。\n- **一致性**：给定的条件在内部是一致的。单位已经指定。数据值对于薄氧化层生长是物理上合理的。不存在矛盾。\n\n**步骤 3：结论与行动**\n\n问题陈述是有效的。它具有科学依据、良态、客观且自洽。因此，将提供一个解决方案。\n\n### 氧化模型的推导\n\n在硅 ($Si$) 衬底上生长二氧化硅 ($\\text{SiO}_2$) 的过程涉及氧化剂（例如 $\\text{O}_2$ 或 $\\text{H}_2\\text{O}$）从环境气体中，穿过已有的氧化层，传输到 $Si/\\text{SiO}_2$ 界面，并在那里发生反应形成新的氧化物。\n\n**基本通量和生长速率**\n\n令 $x$ 为时刻 $t$ 的氧化层厚度。氧化层生长速率 $\\frac{dx}{dt}$ 与在 $Si/\\text{SiO}_2$ 界面消耗的氧化剂通量 $F$ 成正比。如果 $N_1$ 是单位体积氧化物中掺入的氧化剂分子数，则质量守恒定律规定：\n$$ N_1 \\frac{dx}{dt} = F $$\nDeal-Grove 模型假设一个准稳态条件，即通量在整个氧化层中是恒定的。此通量由两个串联过程决定：通过氧化层的扩散和在界面处的反应。\n\n$1$. **扩散通量**：根据菲克第一定律，扩散通量 $F_{diff}$ 与穿过氧化层的氧化剂浓度梯度成正比。假设浓度分布是线性的，我们有：\n$$ F_{diff} = D \\frac{C_s - C_i}{x} $$\n其中 $D$ 是氧化剂在 $\\text{SiO}_2$ 中的扩散系数，$C_s$ 是外表面（氧化物/环境界面）的氧化剂浓度，$C_i$ 是内界面 ($Si/\\text{SiO}_2$) 的氧化剂浓度。\n\n$2$. **反应通量**：在 $Si/\\text{SiO}_2$ 界面氧化剂的消耗被建模为一级化学反应：\n$$ F_{react} = k_s C_i $$\n其中 $k_s$ 是界面反应速率常数。\n\n**模型 3：完整的 Deal-Grove 模型（有限-$k$ 模型）**\n\n问题的“有限-$k$”模型被解释为完整的 Deal-Grove 模型，它同时考虑了有限的扩散阻力和有限的界面反应阻力。在准稳态近似下，$F = F_{diff} = F_{react}$。\n$$ D \\frac{C_s - C_i}{x} = k_s C_i $$\n我们求解不可观测的界面浓度 $C_i$：\n$$ D C_s - D C_i = x k_s C_i \\Rightarrow C_i (D + x k_s) = D C_s \\Rightarrow C_i = \\frac{D C_s}{D + x k_s} $$\n将 $C_i$ 代入反应通量表达式，得到总通量 $F$：\n$$ F = k_s C_i = k_s \\frac{D C_s}{D + x k_s} = \\frac{k_s C_s}{1 + (k_s/D)x} $$\n生长速率则为：\n$$ \\frac{dx}{dt} = \\frac{F}{N_1} = \\frac{1}{N_1} \\frac{k_s C_s}{1 + (k_s/D)x} $$\n通过定义 Deal-Grove 参数 $A = 2D/k_s$ 和 $B = 2DC_s/N_1$，此方程通常写作 $\\frac{dx}{dt} = \\frac{B}{A + 2x}$。参数 $B/A = k_s C_s/N_1$ 代表线性（反应限制）速率常数，而 $B$ 是抛物线（扩散限制）速率常数。\n\n为了求出 $x(t)$，我们对这个微分方程进行积分：\n$$ \\int_{x_0}^{x(t)} (A + 2x') dx' = \\int_0^t B dt' $$\n其中 $x_0$ 是 $t=0$ 时的初始氧化层厚度。\n$$ [Ax' + (x')^2]_{x_0}^{x(t)} = B t $$\n$$ (A x(t) + x(t)^2) - (A x_0 + x_0^2) = B t $$\n这可以重新整理为关于 $x(t)$ 的二次方程：$x(t)^2 + A x(t) - (B t + A x_0 + x_0^2) = 0$。使用二次公式求解 $x(t)$，得到用于拟合的显式形式：\n$$ x(t; x_0, A, B) = \\frac{-A + \\sqrt{A^2 + 4(B t + A x_0 + x_0^2)}}{2} = \\frac{-A + \\sqrt{(A + 2x_0)^2 + 4Bt}}{2} $$\n需要拟合的参数是初始厚度 $x_0$ 和 Deal-Grove 常数 $A$ 和 $B$。所有参数必须为正。这对应于模型 3。\n\n**模型 1：扩散限制的 Deal-Grove 模型**\n\n该模型代表了 Deal-Grove 模型对于较厚氧化层的渐近行为，此时扩散是速率限制步骤。在此区域，扩散阻力远大于反应阻力，对应于 $2x \\gg A$。生长速率方程简化为：\n$$ \\frac{dx}{dt} \\approx \\frac{B}{2x} $$\n这是抛物线生长定律。我们对其积分以求得 $x(t)$：\n$$ \\int_{x_0}^{x(t)} 2x' dx' = \\int_0^t B dt' $$\n$$ [ (x')^2 ]_{x_0}^{x(t)} = B t $$\n$$ x(t)^2 - x_0^2 = B t $$\n这给出了用于拟合的显式函数形式：\n$$ x(t; x_0, B) = \\sqrt{x_0^2 + B t} $$\n需要拟合的参数是初始厚度 $x_0$ 和抛物线速率常数 $B$。两者都必须为正。这对应于模型 1。\n\n**模型 2：Massoud 校正的唯象模型**\n\nDeal-Grove 模型未能准确描述极薄氧化层（$x  5$ nm）初始快速氧化阶段。Massoud 等人提出了一个唯象校正，即在生长速率中增加一个随厚度指数衰减的增强项。\n$$ \\frac{dx}{dt} = \\left(\\frac{dx}{dt}\\right)_{DG} + R_{enhancement} $$\n增强项通常为 $R_{enhancement} = C_M e^{-x/L_M}$，其中 $C_M$ 是一个增强前置因子，$L_M$ 是一个特征衰减长度。对于极薄氧化层区域，Deal-Grove 速率 $(\\frac{dx}{dt})_{DG} = \\frac{B}{A+2x}$ 通常被其线性区形式 $(\\frac{dx}{dt})_{DG} \\approx B/A = K_L$ 所近似。这种简化产生了一个对于稀疏数据拟合易于处理的模型。因此，该模型方程为一个常微分方程 (ODE)：\n$$ \\frac{dx}{dt} = K_M + C_M e^{-x/L_M} $$\n这里我们使用 $K_M$ 来表示基础线性速率常数。该模型有四个正参数需要拟合：初始厚度 $x_0$（作为初始条件 $x(0)=x_0$）、线性速率常数 $K_M$、增强幅度 $C_M$ 和增强衰减长度 $L_M$。这个常微分方程没有简单的 $x(t)$ 闭合解，必须在参数估计时进行数值求解。这对应于模型 2。\n\n**参数估计与模型选择**\n\n对于每个测试案例和三种模型中的每一种，通过最小化残差平方和（$\\mathrm{RSS}$）来估计参数：\n$$ \\mathrm{RSS} = \\sum_{i=1}^{n} (x_{obs, i} - x_{model}(t_i; \\vec{p}))^2 $$\n其中 $x_{obs, i}$ 是在时间 $t_i$ 观测到的厚度，$x_{model}(t_i; \\vec{p})$ 是由参数矢量为 $\\vec{p}$ 的模型预测的厚度。为了在三个候选模型中选择最佳模型，我们使用惩罚模型复杂度的信息准则。对于一个有 $p$ 个参数拟合到 $n$ 个数据点的模型，赤池信息准则（$\\mathrm{AIC}$）和贝叶斯信息准则（$\\mathrm{BIC}$）计算如下：\n$$ \\mathrm{AIC} = n \\ln\\left(\\frac{\\mathrm{RSS}}{n}\\right) + 2p $$\n$$ \\mathrm{BIC} = n \\ln\\left(\\frac{\\mathrm{RSS}}{n}\\right) + p \\ln(n) $$\n偏好的模型是具有最低 $\\mathrm{AIC}$ 值的模型。如果出现数值上的平局，则选择具有较低 $\\mathrm{BIC}$ 值的模型。此过程在拟合优度（低 $\\mathrm{RSS}$）和简约原则（较少参数）之间取得了平衡。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import curve_fit\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Main function to perform parameter estimation and model selection for\n    thin oxide growth kinetics.\n    \"\"\"\n    # Test suite of oxidation data\n    # Case 1: Very-thin oxide with strong early-time enhancement\n    # Case 2: Reaction-limited behavior dominating early times\n    # Case 3: Ultra-thin oxide with minimal data\n    test_cases = [\n        {\n            \"id\": 1,\n            \"t\": np.array([0, 2, 4, 8, 16, 32], dtype=float),\n            \"x\": np.array([0.6, 0.9, 1.2, 1.7, 2.3, 3.1], dtype=float),\n            \"p0\": {\n                1: [0.6, 0.3],\n                2: [0.6, 0.05, 0.15, 1.0],\n                3: [0.6, 5.0, 0.3]\n            }\n        },\n        {\n            \"id\": 2,\n            \"t\": np.array([0, 10, 20, 40, 80, 120], dtype=float),\n            \"x\": np.array([0.7, 1.0, 1.25, 1.65, 2.1, 2.4], dtype=float),\n            \"p0\": {\n                1: [0.7, 0.04],\n                2: [0.7, 0.01, 0.02, 1.0],\n                3: [0.7, 10.0, 0.04]\n            }\n        },\n        {\n            \"id\": 3,\n            \"t\": np.array([0, 2, 4, 6, 8], dtype=float),\n            \"x\": np.array([0.3, 0.5, 0.65, 0.78, 0.90], dtype=float),\n            \"p0\": {\n                1: [0.3, 0.09],\n                2: [0.3, 0.06, 0.04, 1.0],\n                3: [0.3, 10.0, 0.09]\n            }\n        }\n    ]\n\n    # --- Model Definitions ---\n    \n    # Model 1: Deal-Grove diffusion-limited (parabolic) model\n    def model_1_dg_parabolic(t, x0, B):\n        \"\"\"x(t) = sqrt(x0^2 + B*t)\"\"\"\n        # Ensure argument is non-negative\n        arg = x0**2 + B * t\n        # Use np.maximum to avoid nan for small numerical errors making arg negative\n        return np.sqrt(np.maximum(0, arg))\n\n    # Model 2: Massoud-corrected phenomenological model (ODE based)\n    def model_2_massoud_ode(t, x, K_M, C_M, L_M):\n        \"\"\"dx/dt = K_M + C_M * exp(-x/L_M)\"\"\"\n        return K_M + C_M * np.exp(-x / L_M)\n\n    def model_2_wrapper(t_eval, x0, K_M, C_M, L_M):\n        \"\"\"Wrapper for curve_fit to solve the ODE\"\"\"\n        if x0 = 0 or K_M = 0 or C_M = 0 or L_M = 0:\n             return np.full_like(t_eval, np.inf)\n        t_span = [0, np.max(t_eval)]\n        sol = solve_ivp(\n            model_2_massoud_ode,\n            t_span,\n            [x0],\n            args=(K_M, C_M, L_M),\n            dense_output=True,\n            method='RK45'\n        )\n        # solve_ivp returns values at requested points t_eval if dense_output=True\n        return sol.sol(t_eval)[0]\n\n    # Model 3: Full Deal-Grove model (finite-k)\n    def model_3_dg_full(t, x0, A, B):\n        \"\"\"x(t) = (-A + sqrt((A+2x0)^2 + 4Bt))/2\"\"\"\n        # Ensure argument is non-negative\n        arg = (A + 2*x0)**2 + 4 * B * t\n        return (-A + np.sqrt(np.maximum(0, arg))) / 2.0\n\n    models = [\n        {\"func\": model_1_dg_parabolic, \"p\": 2, \"name\": \"DG-Parabolic\"},\n        {\"func\": model_2_wrapper, \"p\": 4, \"name\": \"Massoud\"},\n        {\"func\": model_3_dg_full, \"p\": 3, \"name\": \"DG-Full\"}\n    ]\n\n    preferred_model_indices = []\n\n    for case in test_cases:\n        t_data, x_data = case[\"t\"], case[\"x\"]\n        n = len(t_data)\n        results = []\n\n        for i, model_info in enumerate(models):\n            model_index = i + 1\n            func = model_info[\"func\"]\n            p_count = model_info[\"p\"]\n            p0 = case[\"p0\"][model_index]\n            \n            # All parameters must be positive.\n            bounds = ([1e-9] * p_count, [np.inf] * p_count)\n\n            try:\n                # Use curve_fit for parameter estimation\n                popt, _ = curve_fit(func, t_data, x_data, p0=p0, bounds=bounds, method='trf', max_nfev=5000)\n                \n                # Calculate RSS\n                x_fit = func(t_data, *popt)\n                rss = np.sum((x_data - x_fit)**2)\n\n                # Avoid log(0)\n                if rss = 0:\n                    aic = bic = np.inf\n                else: \n                    # Calculate AIC and BIC\n                    term = n * np.log(rss / n)\n                    aic = term + 2 * p_count\n                    bic = term + p_count * np.log(n)\n                \n                results.append({\"model_index\": model_index, \"aic\": aic, \"bic\": bic})\n\n            except (RuntimeError, ValueError):\n                # If fit fails, treat it as infinitely bad\n                results.append({\"model_index\": model_index, \"aic\": np.inf, \"bic\": np.inf})\n\n        # Select the best model based on AIC, with BIC as a tie-breaker\n        if not results:\n            preferred_model_indices.append(0) # Error case\n            continue\n\n        # Sort by AIC, then by BIC\n        # Use a tolerance for AIC tie-breaking\n        best_model = sorted(results, key=lambda r: r['aic'])[0]\n        min_aic = best_model['aic']\n        \n        tied_models = [r for r in results if abs(r['aic'] - min_aic)  1e-6]\n        \n        if len(tied_models) > 1:\n            best_model = sorted(tied_models, key=lambda r: r['bic'])[0]\n        \n        preferred_model_indices.append(best_model['model_index'])\n        \n    # Print final output in the required format\n    print(f\"[{','.join(map(str, preferred_model_indices))}]\")\n\nsolve()\n```"
        }
    ]
}