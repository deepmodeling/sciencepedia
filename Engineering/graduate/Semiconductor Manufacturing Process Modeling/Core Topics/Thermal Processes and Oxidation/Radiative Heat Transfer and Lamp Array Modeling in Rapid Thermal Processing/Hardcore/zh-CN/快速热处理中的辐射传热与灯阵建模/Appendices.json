{
    "hands_on_practices": [
        {
            "introduction": "在任何精确的快速热处理（RTP）模型中，首要步骤是准确表征辐射源——灯阵的发射特性。此练习将灯丝理想化为黑体，并要求您基于普朗克定律计算在特定波长范围内发射的能量占总能量的比例。由于半导体晶圆对不同波长的辐射吸收率不同，掌握这种带限发射分数的计算是精确模拟晶圆吸收能量的基础 ()。",
            "id": "4158476",
            "problem": "用于快速热处理（RTP）的钨卤灯阵列可被理想化为一组类黑体发射器，其灯丝温度约为 $T \\approx 3000\\,\\mathrm{K}$。对于晶圆-灯管耦合的辐射传热建模，一个关键量是在波长区间 $[\\lambda_1,\\lambda_2]$ 内发射的总黑体发射功率的带限分数。从适用于半导体制造过程建模的基本辐射定律出发，实现一个程序来计算无量纲分数\n$F(\\lambda_1,\\lambda_2;T) = \\dfrac{\\int_{\\lambda_1}^{\\lambda_2} E_\\lambda^{b}(T)\\, d\\lambda}{\\sigma T^4}$，\n其中 $E_\\lambda^{b}(T)$ 是光谱黑体发射功率，$\\sigma$ 是 Stefan–Boltzmann 常数。你的推导必须从 Planck 定律和总黑体发射功率的定义（Stefan–Boltzmann 定律）开始，并为与灯阵列建模相关的近红外区域的波段积分，发展一种数值稳健的策略。不要假定任何预先制表的黑体分数函数；相反，应推导出一个数值稳定的积分表达式，并指定一个具体的数值求积策略来对给定参数进行求值。\n\n你使用的所有物理常数必须是标准值并明确说明，所有计算必须在国际单位制（SI）中进行。最终报告的量 $F(\\lambda_1,\\lambda_2;T)$ 是无量纲的，并且必须以十进制数的形式返回。\n\n你的程序必须对以下参数集测试套件评估 $F(\\lambda_1,\\lambda_2;T)$，每个参数集指定为 $(\\lambda_1,\\lambda_2,T)$：\n\n- A例（类钨温度下的近红外波段）：$(0.8\\,\\mu\\mathrm{m},\\,2.5\\,\\mu\\mathrm{m},\\,3000\\,\\mathrm{K})$。\n- B例（完整性检查，全光谱）：$(0\\,\\mu\\mathrm{m},\\,+\\infty\\,\\mu\\mathrm{m},\\,3000\\,\\mathrm{K})$。\n- C例（类钨温度下的可见光波段）：$(0.4\\,\\mu\\mathrm{m},\\,0.7\\,\\mu\\mathrm{m},\\,3000\\,\\mathrm{K})$。\n- D例（稍冷灯管的近红外波段）：$(0.8\\,\\mu\\mathrm{m},\\,2.5\\,\\mu\\mathrm{m},\\,2800\\,\\mathrm{K})$。\n- E例（简并波段）：$(1.0\\,\\mu\\mathrm{m},\\,1.0\\,\\mu\\mathrm{m},\\,3000\\,\\mathrm{K})$。\n\n将 $+\\infty$ 解释为数学上的无穷大。不涉及角度。所有波长在使用前必须从微米内部转换为米。每个案例的输出必须是介于 $0$ 和 $1$ 之间的单个浮点数。\n\n你的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，“[resultA,resultB,resultC,resultD,resultE]”）。每个浮点结果必须四舍五入到 $8$ 位有效数字。不应打印其他任何文本。",
            "solution": "该问题要求计算总黑体发射功率的带限分数，这是辐射传热分析中的一个基本量，尤其与快速热处理（RTP）系统的建模相关。解决过程始于对问题陈述的验证，该陈述被认为是科学上合理、适定且客观的。该问题基于热物理学的既定原理，并直接适用于指定的工程背景。所有提供的参数都是现实的，要求也是自洽的。\n\n问题的核心是评估无量纲分数 $F(\\lambda_1, \\lambda_2; T)$，其定义为：\n$$\nF(\\lambda_1,\\lambda_2;T) = \\frac{\\int_{\\lambda_1}^{\\lambda_2} E_\\lambda^{b}(T)\\, d\\lambda}{\\int_{0}^{\\infty} E_\\lambda^{b}(T)\\, d\\lambda}\n$$\n分母表示总黑体发射功率，根据 Stefan–Boltzmann 定律，它等于 $\\sigma T^4$。项 $E_\\lambda^{b}(T)$ 是光谱黑体发射功率，由 Planck 定律描述：\n$$\nE_\\lambda^{b}(T) = \\frac{2\\pi h c^2}{\\lambda^5 \\left(\\exp\\left(\\frac{hc}{\\lambda k_B T}\\right) - 1\\right)}\n$$\n其中 $h$ 是 Planck 常数，$c$ 是真空中的光速，$k_B$ 是 Boltzmann 常数，$T$ 是绝对温度，$\\lambda$ 是波长。\n\n对此表达式进行直接数值积分容易产生数值不稳定性，原因在于小波长处的 $\\lambda^5$ 项以及指数项中潜在的浮点溢出或下溢。一种稳健的数值策略需要重新构建积分。这通过变量替换来实现积分的无量纲化。我们定义一个无量纲变量 $x$ 为：\n$$\nx = \\frac{hc}{\\lambda k_B T}\n$$\n由此，我们可以用 $x$ 表示 $\\lambda$ 及其微分 $d\\lambda$：\n$$\n\\lambda = \\frac{hc}{x k_B T} \\quad \\implies \\quad d\\lambda = -\\frac{hc}{x^2 k_B T} dx\n$$\n积分限也随之改变。当 $\\lambda$ 从 $\\lambda_1$ 变化到 $\\lambda_2$ 时，$x$ 从 $x_1 = \\frac{hc}{\\lambda_2 k_B T}$ 变化到 $x_2 = \\frac{hc}{\\lambda_1 k_B T}$。\n\n将这些代入 $F(\\lambda_1, \\lambda_2; T)$ 的分子中的积分：\n$$\n\\int_{\\lambda_1}^{\\lambda_2} E_\\lambda^{b}(T)\\, d\\lambda = \\int_{x_2}^{x_1} \\frac{2\\pi h c^2}{\\left(\\frac{hc}{x k_B T}\\right)^5 \\left(e^x - 1\\right)} \\left(-\\frac{hc}{x^2 k_B T}\\right) dx\n$$\n通过反转积分限以抵消负号并简化代数项，我们得到：\n$$\n\\int_{x_1}^{x_2} \\frac{2\\pi h c^2 (k_B T)^5 x^5}{(hc)^5 (e^x - 1)} \\frac{h c}{x^2 k_B T} dx = \\left(\\frac{2\\pi k_B^4}{h^3 c^2}\\right) T^4 \\int_{x_1}^{x_2} \\frac{x^3}{e^x - 1} dx\n$$\n分母，即总发射功率，是通过令 $\\lambda_1 \\to 0$ 和 $\\lambda_2 \\to \\infty$ 得到的，这对应于 $x_2 \\to \\infty$ 和 $x_1 \\to 0$：\n$$\n\\sigma T^4 = \\int_{0}^{\\infty} E_\\lambda^{b}(T)\\, d\\lambda = \\left(\\frac{2\\pi k_B^4}{h^3 c^2}\\right) T^4 \\int_{0}^{\\infty} \\frac{x^3}{e^x - 1} dx\n$$\n定积分 $\\int_{0}^{\\infty} \\frac{x^3}{e^x - 1} dx$ 是与 Bose-Einstein 积分相关的标准形式，其值为 $\\frac{\\pi^4}{15}$。这使得我们可以根据基本常数推导出 Stefan-Boltzmann 常数 $\\sigma$：\n$$\n\\sigma = \\frac{2\\pi k_B^4}{h^3 c^2} \\frac{\\pi^4}{15} = \\frac{2\\pi^5 k_B^4}{15 h^3 c^2}\n$$\n\n现在，分数 $F(\\lambda_1, \\lambda_2; T)$ 可以表示为两个变换后积分的比值：\n$$\nF(\\lambda_1,\\lambda_2;T) = \\frac{\\left(\\frac{2\\pi k_B^4}{h^3 c^2}\\right) T^4 \\int_{x_1}^{x_2} \\frac{x^3}{e^x - 1} dx}{\\left(\\frac{2\\pi k_B^4}{h^3 c^2}\\right) T^4 \\int_{0}^{\\infty} \\frac{x^3}{e^x - 1} dx} = \\frac{\\int_{x_1}^{x_2} \\frac{x^3}{e^x - 1} dx}{\\frac{\\pi^4}{15}}\n$$\n这给出了待实现的最终数值稳定表达式：\n$$\nF(\\lambda_1,\\lambda_2;T) = \\frac{15}{\\pi^4} \\int_{\\frac{hc}{\\lambda_2 k_B T}}^{\\frac{hc}{\\lambda_1 k_B T}} \\frac{x^3}{e^x - 1} dx\n$$\n被积函数 $f(x) = \\frac{x^3}{e^x - 1}$ 是良态的，对于有限且非零的 $\\lambda_1, \\lambda_2$，积分在有限区间上进行。\n\n对于数值实现，使用以下 SI 单位的物理常数（2018 CODATA 值）：\n- Planck 常数, $h = 6.62607015 \\times 10^{-34}$ J·s\n- 光速, $c = 299792458$ m/s\n- Boltzmann 常数, $k_B = 1.380649 \\times 10^{-23}$ J/K\n\n指定的数值求积策略是使用 `scipy.integrate` 库中的 `quad` 函数。该函数采用基于 QUADPACK FORTRAN 库的自适应求积方案，该方案对于包括在端点处具有可积奇点的各种被积函数都具有鲁棒性。它还可以处理无穷积分限，这对于 B 例是必需的。\n\n测试用例如下处理：\n- **A、C、D 例**：使用有限、非零的积分限进行标准评估。波长从 $\\mu$m 转换为 m。\n- **B 例 $(\\lambda_1=0, \\lambda_2=\\infty)$**：$x$ 的积分限变为 $(\\infty, 0)$，因此积分为 $\\int_0^\\infty$。数值积分器将计算此值，结果应为 $1.0$，作为归一化的验证。\n- **E 例 $(\\lambda_1=\\lambda_2)$**：积分限相同 ($x_1=x_2$)，因此积分为零。这通过条件检查直接返回 $0.0$ 来处理。\n\n为保证数值精度，项 $e^x - 1$ 使用 `numpy.expm1(x)` 计算，该函数在 $x$ 值很小时能保持精度。还包括一个安全措施来处理被积函数中 $x$ 值非常大时可能发生的溢出，此时函数值会迅速趋于零。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import integrate\n\ndef solve():\n    \"\"\"\n    Solves the blackbody radiation fraction problem for a suite of test cases.\n    The implementation follows the derivation of a numerically stable integral\n    representation of the band-limited emission fraction.\n    \"\"\"\n\n    # Physical Constants (2018 CODATA values, SI units)\n    H = 6.62607015e-34      # Planck constant (J.s)\n    C = 299792458.0         # Speed of light in vacuum (m/s)\n    K_B = 1.380649e-23      # Boltzmann constant (J/K)\n\n    # Second radiation constant, C2 = h*c/k_B (m.K)\n    C2 = H * C / K_B\n\n    def integrand(x):\n        \"\"\"\n        The non-dimensionalized integrand for the blackbody radiation function.\n        f(x) = x^3 / (exp(x) - 1).\n        \"\"\"\n        # Handle the limit at x=0, which is 0.\n        if x == 0:\n            return 0.0\n        # Prevent overflow for large x, where the integrand approaches zero.\n        # np.exp(709.78) is near floating point limit.\n        if x > 709.0:\n            return 0.0\n        # np.expm1(x) provides better precision for exp(x)-1 when x is small.\n        return x**3 / np.expm1(x)\n\n    def calculate_F(lambda1_micron, lambda2_micron, T_kelvin):\n        \"\"\"\n        Calculates the fraction of blackbody radiation F in the band [lambda1, lambda2]\n        at temperature T.\n\n        Args:\n            lambda1_micron (float): Start wavelength in micrometers.\n            lambda2_micron (float): End wavelength in micrometers.\n            T_kelvin (float): Temperature in Kelvin.\n\n        Returns:\n            float: The dimensionless fraction F.\n        \"\"\"\n        # Case E: Degenerate band of zero width\n        if lambda1_micron == lambda2_micron:\n            return 0.0\n        \n        # Convert wavelengths from micrometers to meters\n        lambda1_m = lambda1_micron * 1e-6\n        lambda2_m = lambda2_micron * 1e-6\n\n        # Calculate the dimensionless integration limits x = hc / (lambda * k_B * T)\n        # Note the inverse relationship between lambda and x.\n        \n        # Upper limit x2 corresponds to lower wavelength lambda1\n        if lambda1_m == 0.0:\n            x2 = np.inf\n        else:\n            x2 = C2 / (lambda1_m * T_kelvin)\n\n        # Lower limit x1 corresponds to upper wavelength lambda2\n        if np.isinf(lambda2_m):\n            x1 = 0.0\n        else:\n            x1 = C2 / (lambda2_m * T_kelvin)\n        \n        # The integral is over [x1, x2]\n        integral_val, _ = integrate.quad(integrand, x1, x2)\n        \n        # The total integral from 0 to infinity is pi^4 / 15\n        normalization_constant = 15.0 / (np.pi**4)\n        \n        return normalization_constant * integral_val\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (lambda1_micron, lambda2_micron, T_kelvin)\n    test_cases = [\n        (0.8, 2.5, 3000.0),      # Case A\n        (0.0, np.inf, 3000.0),   # Case B\n        (0.4, 0.7, 3000.0),      # Case C\n        (0.8, 2.5, 2800.0),      # Case D\n        (1.0, 1.0, 3000.0),      # Case E\n    ]\n\n    results = []\n    for case in test_cases:\n        lambda1, lambda2, T = case\n        fraction = calculate_F(lambda1, lambda2, T)\n        # Format the result to 8 significant figures\n        results.append(f\"{fraction:.8g}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "理解了辐射源的特性后，下一步是模拟能量如何从灯阵传输到晶圆，这由几何“角系数” $F_{ij}$ 决定。在真实的复杂几何结构中，角系数的解析解极为罕见，因此数值计算成为必要工具。本练习旨在通过一个经典的验证案例，让您亲手实现一个数值积分器，并将其计算结果与已知的解析解进行比较，从而验证数值模型的准确性 ()，这是建立对更复杂模型信心的关键一步。",
            "id": "4158599",
            "problem": "您正在为半导体晶圆的快速热处理（rapid thermal processing）过程中的辐射交换进行建模，其中，一个钨卤灯组件在局部被理想化为一个与差分晶圆片共轴的圆形发射盘。为验证灯阵列建模中使用的辐射角系数的数值实现，您需要复现一个具有已知闭式解的经典配置，并报告其相对误差。\n\n从第一性原理出发，使用从表面 $A_1$ 到表面 $A_2$ 的漫灰体辐射角系数的定义：\n$$\nF_{1 \\to 2} \\;=\\; \\frac{1}{A_1} \\int_{A_1} \\int_{A_2} \\frac{\\cos \\theta_1 \\, \\cos \\theta_2}{\\pi \\, r^2} \\, V \\; \\mathrm{d}A_2 \\, \\mathrm{d}A_1,\n$$\n其中 $r$ 是面元中心之间的距离，$\\theta_1$ 和 $\\theta_2$ 分别是视线与发射点和接收点局部表面法线之间的夹角，而 $V$ 是二元可见性函数，如果两点相互可见，则其值为 $1$，否则为 $0$。在这个验证问题中，没有遮挡物，因此对于所有相互可见的点对，$V = 1$。\n\n考虑以下与快速热处理灯阵列建模直接相关的几何结构：一个差分晶圆片（建模为一个无穷小的平面区域）位于 $z=0$ 平面的原点，其法线沿 $+\\hat{z}$ 方向；一个半径为 $R$ 的共轴圆形灯盘代表，位于 $z=h$ 平面，其法线沿 $-\\hat{z}$ 方向。该圆盘以 $z$ 轴为中心，并且从晶圆片上可以完全看到整个圆盘。在此几何结构中，辐射角系数是无量纲的（答案中无需提供物理单位）。\n\n您的任务是：\n- 实现一个从差分晶圆片到圆形盘的角系数数值估算器，该估算器直接基于上述积分定义，并针对该几何形状进行适当的特化，而不引用任何预先制表的公式。该数值估算器应对各种 $(R,h)$ 值（其中 $R \\ge 0$ 且 $h > 0$）具有鲁棒性。\n- 独立地，从第一性原理推导并计算该几何形状对应的解析闭式角系数，作为基准真相（ground truth）。\n- 对每个测试用例，计算相对误差，其定义为\n$$\n\\varepsilon \\;=\\; \\frac{\\lvert F_{\\text{num}} - F_{\\text{ana}} \\rvert}{\\max\\left( \\lvert F_{\\text{ana}} \\rvert, \\delta \\right)},\n$$\n其中 $F_{\\text{num}}$ 是数值估算的角系数，$F_{\\text{ana}}$ 是解析推导的角系数，而 $\\delta$ 是一个小的正常数，仅用于在 $F_{\\text{ana}} = 0$ 时避免除以零。使用 $\\delta = 10^{-12}$。\n\n测试套件：\n- 用例 1：$R = 0.05$，$h = 0.05$。\n- 用例 2：$R = 0.05$，$h = 0.10$。\n- 用例 3：$R = 0.10$，$h = 1.00$。\n- 用例 4：$R = 0.00$，$h = 0.05$。\n- 用例 5：$R = 0.10$，$h = 0.01$。\n\n所有半径和距离的单位均为米，但输出是无量纲的。您的程序应生成单行输出，其中包含五个测试用例的相对误差，按顺序以逗号分隔的列表形式呈现，并用方括号括起来，每个值都以科学记数法四舍五入到八位有效数字。例如，输出格式必须是\n“[x1,x2,x3,x4,x5]”\n其中每个 $x_i$ 都以科学记数法打印（例如，$1.23456789e-06$）。不应打印任何额外文本。",
            "solution": "该问题是有效的。它在科学上基于辐射传热的原理，问题陈述清晰，信息充分，可得到唯一解，并以客观、正式的语言表述。我们将着手进行求解。\n\n解决方案分四步进行：\n1.  将通用角系数积分特化至给定几何形状。\n2.  推导角系数的解析（闭式）解 $F_{\\text{ana}}$。\n3.  构建基于积分的数值估算器 $F_{\\text{num}}$。\n4.  计算每个测试用例的相对误差 $\\varepsilon$。\n\n### 1. 角系数积分的特化\n\n从表面 $A_1$ 到表面 $A_2$ 的角系数通用定义如下：\n$$\nF_{1 \\to 2} \\;=\\; \\frac{1}{A_1} \\int_{A_1} \\int_{A_2} \\frac{\\cos \\theta_1 \\, \\cos \\theta_2}{\\pi \\, r^2} \\, V \\; \\mathrm{d}A_2 \\, \\mathrm{d}A_1\n$$\n在本问题中，表面 $A_1$ 是一个差分晶圆片，我们可以表示为 $\\mathrm{d}A_1$。当 $A_1 \\to \\mathrm{d}A_1$ 时，外部对 $A_1$ 的积分被移除，项 $1/A_1$ 变为 $1/\\mathrm{d}A_1$。因此，从微分面积到有限面积 $A_2$ 的角系数为：\n$$\nF_{\\mathrm{d}A_1 \\to A_2} \\;=\\; \\int_{A_2} \\frac{\\cos \\theta_1 \\, \\cos \\theta_2}{\\pi \\, r^2} \\, \\mathrm{d}A_2\n$$\n这里，假定可见性 $V=1$。\n\n我们建立一个坐标系。差分片 $\\mathrm{d}A_1$ 位于 $z=0$ 平面的原点 $(0, 0, 0)$，其表面法向量为 $\\mathbf{n}_1 = \\hat{\\mathbf{k}}$。表面 $A_2$ 是一个半径为 $R$ 的圆形盘，位于 $z=h$ 平面，以 $z$ 轴为中心。其指向晶圆片的法向量为 $\\mathbf{n}_2 = -\\hat{\\mathbf{k}}$。\n\n我们考虑圆盘 $A_2$ 上的一个面元 $\\mathrm{d}A_2$。在 $z=h$ 平面中使用极坐标 $(\\rho, \\phi)$，$\\mathrm{d}A_2$ 的位置向量是 $\\mathbf{p}_2 = \\rho \\cos\\phi \\, \\hat{\\mathbf{i}} + \\rho \\sin\\phi \\, \\hat{\\mathbf{j}} + h \\, \\hat{\\mathbf{k}}$，其中 $0 \\le \\rho \\le R$ 且 $0 \\le \\phi  2\\pi$。微分面积为 $\\mathrm{d}A_2 = \\rho\\,\\mathrm{d}\\rho\\,\\mathrm{d}\\phi$。\n\n从 $\\mathrm{d}A_1$ 中心（原点）到 $\\mathrm{d}A_2$ 中心的向量是 $\\mathbf{r} = \\mathbf{p}_2$。距离 $r$ 是其模：\n$$\nr = |\\mathbf{r}| = \\sqrt{(\\rho \\cos\\phi)^2 + (\\rho \\sin\\phi)^2 + h^2} = \\sqrt{\\rho^2 + h^2}\n$$\n角 $\\theta_1$ 是法线 $\\mathbf{n}_1$ 与视线向量 $\\mathbf{r}$ 之间的夹角。\n$$\n\\cos \\theta_1 = \\frac{\\mathbf{r} \\cdot \\mathbf{n}_1}{|\\mathbf{r}| |\\mathbf{n}_1|} = \\frac{(\\rho \\cos\\phi \\, \\hat{\\mathbf{i}} + \\rho \\sin\\phi \\, \\hat{\\mathbf{j}} + h \\, \\hat{\\mathbf{k}}) \\cdot (\\hat{\\mathbf{k}})}{\\sqrt{\\rho^2+h^2} \\cdot 1} = \\frac{h}{\\sqrt{\\rho^2+h^2}}\n$$\n角 $\\theta_2$ 是法线 $\\mathbf{n}_2$ 与从 $\\mathrm{d}A_2$ 指向 $\\mathrm{d}A_1$ 的视线向量（即 $-\\mathbf{r}$）之间的夹角。\n$$\n\\cos \\theta_2 = \\frac{(-\\mathbf{r}) \\cdot \\mathbf{n}_2}{|-\\mathbf{r}| |\\mathbf{n}_2|} = \\frac{(-\\rho \\cos\\phi \\, \\hat{\\mathbf{i}} - \\rho \\sin\\phi \\, \\hat{\\mathbf{j}} - h \\, \\hat{\\mathbf{k}}) \\cdot (-\\hat{\\mathbf{k}})}{\\sqrt{\\rho^2+h^2} \\cdot 1} = \\frac{h}{\\sqrt{\\rho^2+h^2}}\n$$\n将这些表达式代入角系数积分中：\n$$\nF_{\\mathrm{d}A_1 \\to A_2} = \\int_{0}^{2\\pi} \\int_{0}^{R} \\frac{1}{\\pi} \\left( \\frac{h}{\\sqrt{\\rho^2+h^2}} \\right) \\left( \\frac{h}{\\sqrt{\\rho^2+h^2}} \\right) \\frac{1}{(\\sqrt{\\rho^2+h^2})^2} (\\rho \\, \\mathrm{d}\\rho \\, \\mathrm{d}\\phi)\n$$\n$$\nF_{\\mathrm{d}A_1 \\to A_2} = \\frac{1}{\\pi} \\int_{0}^{2\\pi} \\int_{0}^{R} \\frac{h^2}{(\\rho^2+h^2)^2} \\rho \\, \\mathrm{d}\\rho \\, \\mathrm{d}\\phi\n$$\n被积函数与方位角 $\\phi$ 无关。对 $\\phi$ 积分得到一个因子 $2\\pi$：\n$$\nF_{\\mathrm{d}A_1 \\to A_2} = \\frac{2\\pi}{\\pi} \\int_{0}^{R} \\frac{h^2 \\rho}{(\\rho^2+h^2)^2} \\, \\mathrm{d}\\rho = 2h^2 \\int_{0}^{R} \\frac{\\rho}{(\\rho^2+h^2)^2} \\, \\mathrm{d}\\rho\n$$\n这个最终的一维积分为解析解和数值解提供了基础。\n\n### 2. 解析解 ($F_{\\text{ana}}$)\n\n为求得解析解，我们求解上述推导出的积分。我们使用换元法，令 $u = \\rho^2 + h^2$，这意味着 $\\mathrm{d}u = 2\\rho \\, \\mathrm{d}\\rho$，或 $\\rho \\, \\mathrm{d}\\rho = \\frac{1}{2}\\mathrm{d}u$。积分限从 $\\rho=0 \\to \\rho=R$ 变为 $u=h^2 \\to u=R^2+h^2$。\n$$\nF_{\\text{ana}} = 2h^2 \\int_{h^2}^{R^2+h^2} \\frac{1}{u^2} \\left( \\frac{1}{2}\\mathrm{d}u \\right) = h^2 \\int_{h^2}^{R^2+h^2} u^{-2} \\, \\mathrm{d}u\n$$\n$$\nF_{\\text{ana}} = h^2 \\left[ -u^{-1} \\right]_{h^2}^{R^2+h^2} = h^2 \\left( -\\frac{1}{R^2+h^2} - \\left(-\\frac{1}{h^2}\\right) \\right)\n$$\n$$\nF_{\\text{ana}} = h^2 \\left( \\frac{1}{h^2} - \\frac{1}{R^2+h^2} \\right) = 1 - \\frac{h^2}{R^2+h^2}\n$$\n$$\nF_{\\text{ana}} = \\frac{(R^2+h^2) - h^2}{R^2+h^2} = \\frac{R^2}{R^2+h^2}\n$$\n这就是角系数的闭式解析表达式。\n\n### 3. 数值估算器 ($F_{\\text{num}}$)\n\n数值估算器 $F_{\\text{num}}$ 是通过使用高精度数值求积方法直接计算一维积分来实现的。我们将使用 `scipy.integrate.quad` 函数，它是一个用于此目的的鲁棒工具。需要对 $\\rho$ 在区间 $[0, R]$ 上积分的函数是：\n$$\nf(\\rho; h) = \\frac{2h^2 \\rho}{(\\rho^2+h^2)^2}\n$$\n因此，对于每组参数 $(R, h)$，数值角系数计算如下：\n$$\nF_{\\text{num}}(R, h) = \\int_{0}^{R} f(\\rho; h) \\, \\mathrm{d}\\rho \\approx \\text{quad}(f, 0, R, \\text{args}=(h))\n$$\n这种方法遵循了问题中“直接基于积分定义”和“针对该几何形状进行适当的特化”的要求。\n\n### 4. 相对误差计算\n\n对于每个测试用例，我们计算 $F_{\\text{ana}}$ 和 $F_{\\text{num}}$。然后根据给定的公式计算相对误差 $\\varepsilon$：\n$$\n\\varepsilon \\;=\\; \\frac{\\lvert F_{\\text{num}} - F_{\\text{ana}} \\rvert}{\\max\\left( \\lvert F_{\\text{ana}} \\rvert, \\delta \\right)}\n$$\n其中 $\\delta = 10^{-12}$。分母的设计是为了避免在 $F_{\\text{ana}}$ 为零时（即 $R=0$ 的测试用例）出现除以零的情况。计算出的五个误差值将被格式化并打印出来。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import quad\n\ndef solve():\n    \"\"\"\n    Calculates the relative error between numerical and analytical view factors\n    for five test cases and prints the results in the required format.\n    \"\"\"\n    \n    # Define test cases as a list of (R, h) tuples.\n    test_cases = [\n        (0.05, 0.05),  # Case 1\n        (0.05, 0.10),  # Case 2\n        (0.10, 1.00),  # Case 3\n        (0.00, 0.05),  # Case 4\n        (0.10, 0.01),  # Case 5\n    ]\n    \n    # Small constant for relative error calculation to avoid division by zero.\n    delta = 1.0e-12\n\n    results = []\n    \n    for R, h in test_cases:\n        # 1. Analytical Solution (F_ana)\n        # The closed-form solution is F_ana = R^2 / (R^2 + h^2).\n        # This is derived by analytically solving the view factor integral.\n        # Check for h  0 as per problem constraints.\n        if h = 0:\n            raise ValueError(\"Height h must be positive.\")\n        \n        # The formula is robust and handles R=0 correctly.\n        F_ana = R**2 / (R**2 + h**2)\n        \n        # 2. Numerical Solution (F_num)\n        # The numerical solution is obtained by integrating the simplified\n        # 1D view factor kernel using scipy.integrate.quad.\n        # The integrand is f(rho) = 2*h^2*rho / (rho^2 + h^2)^2.\n        \n        # Handle the R=0 case directly, as the integration interval is [0, 0].\n        if R == 0:\n            F_num = 0.0\n        else:\n            integrand = lambda rho, h_val: (2 * h_val**2 * rho) / (rho**2 + h_val**2)**2\n            # quad returns a tuple (result, error_estimate). We need the result.\n            F_num, _ = quad(integrand, 0, R, args=(h,))\n\n        # 3. Relative Error Calculation\n        # epsilon = |F_num - F_ana| / max(|F_ana|, delta)\n        abs_error = abs(F_num - F_ana)\n        denominator = max(abs(F_ana), delta)\n        relative_error = abs_error / denominator\n        \n        results.append(relative_error)\n\n    # Final print statement in the exact required format.\n    # The format specifier \"{:.7e}\" provides 8 significant figures.\n    formatted_results = [f\"{res:.7e}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "本章的最终练习将前面的概念融会贯通，解决一个贴近实际的系统级设计问题。它综合了辐射交换（通过耦合系数 $k_{ij}$）、稳态能量平衡以及数值优化方法。您的任务将从“分析”转向“设计”：通过求解一个反问题，确定各灯环需要设置多少功率 $P_i$，才能在晶圆上实现均匀的目标温度，这体现了RTP工艺控制中的核心挑战 ()。",
            "id": "4158567",
            "problem": "考虑一个快速热处理场景，其中一个圆形半导体晶圆由三个同心灯环加热。该晶圆半径为 $R$，并被离散为 $N$ 个同心环形控制体积（节点）。每个灯环 $i \\in \\{1,2,3\\}$ 的半径为 $R_i$，位于晶圆平面上方的高度为 $H_i$，并将其电功率 $P_i$ 的一部分 $\\eta_i$ 作为热辐射发射出去。晶圆被建模为发射率为 $\\varepsilon_w$ 的漫射灰体表面。假设腔室中充满了温度为 $T_{\\mathrm{gas}}$ 的静态气体，并具有均匀的对流传热系数 $h_c$。环境（腔室壁）的温度为 $T_{\\mathrm{env}}$。角度必须以弧度处理。\n\n从第一性原理出发，起点如下：\n- Stefan–Boltzmann 定律：温度为 $T$ 的表面节点与温度为 $T_{\\mathrm{env}}$ 的环境之间的单位面积净辐射热交换为 $q_{\\mathrm{rad}} = \\varepsilon_w \\sigma \\left(T^4 - T_{\\mathrm{env}}^4\\right)$，其中 $\\sigma$ 是 Stefan–Boltzmann 常数。\n- 来自各向同性点源的辐照度定义：接收器处的辐照度与距离的平方成反比，并包含一个等于入射角余弦的投影因子。\n- 每个环形节点的稳态能量守恒：吸收的辐射功率等于向环境的辐射发射和向气体的对流损失之和。\n\n将第 $i$ 个灯环建模为在晶圆上方高度 $H_i$、半径为 $R_i$ 的圆上均匀分布的一组各向同性点源。设平均半径为 $r_j$ 的节点 $j$ 位于晶圆平面上。对于方位角为 $\\alpha \\in [0,2\\pi)$ 的环形元件，该元件与节点之间的距离为 $d(\\alpha) = \\sqrt{H_i^2 + R_i^2 + r_j^2 - 2 R_i r_j \\cos\\alpha}$，入射余弦为 $H_i/d(\\alpha)$。环形元件的无穷小功率为 $\\mathrm{d}P_i = \\eta_i P_i \\mathrm{d}\\alpha / (2\\pi)$。\n\n综上所述，由灯 $i$ 引起的节点 $j$ 处的辐照度通过对环进行积分得到，并与下式成正比\n$$\nE_{ij} \\propto \\eta_i P_i H_i \\int_{0}^{2\\pi} \\frac{1}{d(\\alpha)^3}\\,\\mathrm{d}\\alpha.\n$$\n假设晶圆吸收入射辐射的一小部分 $\\varepsilon_w$（根据灰体表面的 Kirchhoff 定律），并将每个面积为 $A_j$ 的环形区域 $j$ 视为一个整体，则节点 $j$ 从灯 $i$ 吸收的功率与 $P_i$ 呈线性关系。因此，存在一个耦合系数 $k_{ij}$，使得节点 $j$ 从所有灯吸收的功率为 $\\sum_{i=1}^{3} k_{ij} P_i$。\n\n在稳态下，强制执行逐节点的能量平衡：\n$$\n\\sum_{i=1}^{3} k_{ij} P_i = \\varepsilon_w \\sigma A_j \\left(T_j^4 - T_{\\mathrm{env}}^4\\right) + h_c A_j \\left(T_j - T_{\\mathrm{gas}}\\right),\n$$\n其中 $T_j$ 是节点温度。对于在指定目标温度 $T_{\\mathrm{t}}$ 下的逆向设计，要求所有 $j$ 的 $T_j \\approx T_{\\mathrm{t}}$，误差在 $\\pm 5\\ \\mathrm{K}$ 以内。\n\n您的任务是实现一个完整的程序，该程序：\n1. 通过使用均匀的方位角离散化，对辐照度的环形积分进行数值评估，从而从第一性原理构建几何耦合系数 $k_{ij}$。对 $\\alpha$ 使用弧度制。\n2. 在目标温度 $T_{\\mathrm{t}}$ 下为每个节点建立稳态能量平衡，从而得到一个关于未知灯功率 $P_i$ 的线性系统。使用非负最小二乘法求解 $P = [P_1,P_2,P_3]$ 的非负逆问题，以便在最小二乘意义上使目标在所有节点上得到匹配。\n3. 使用计算出的灯功率求解每个节点的非线性能量平衡，以验证得到的节点温度 $T_j$，并计算最大偏差 $\\max_j |T_j - T_{\\mathrm{t}}|$（单位：K）。\n4. 对于每个测试用例，输出三个灯的功率（单位：W）和与 $T_{\\mathrm{t}}$ 的最大偏差（单位：K），后跟一个布尔值，指示是否满足偏差要求 $\\leq 5\\ \\mathrm{K}$。功率必须以瓦特（W）表示，温度以开尔文（K）表示。\n\n在整个过程中使用 Stefan–Boltzmann 常数 $\\sigma = 5.670374419\\times 10^{-8}\\ \\mathrm{W\\,m^{-2}\\,K^{-4}}$ 和国际单位制（SI）。所有角度必须以弧度为单位。\n\n测试套件：\n- 用例 1 (happy path)：$R = 0.10\\ \\mathrm{m}$, $N = 11$, $R_1 = 0.03\\ \\mathrm{m}$, $R_2 = 0.06\\ \\mathrm{m}$, $R_3 = 0.09\\ \\mathrm{m}$, $H_1 = H_2 = H_3 = 0.08\\ \\mathrm{m}$, $\\eta_1=\\eta_2=\\eta_3=0.75$, $\\varepsilon_w = 0.70$, $h_c = 10\\ \\mathrm{W\\,m^{-2}\\,K^{-1}}$, $T_{\\mathrm{env}} = 500\\ \\mathrm{K}$, $T_{\\mathrm{gas}} = 500\\ \\mathrm{K}$, $T_{\\mathrm{t}}=1000\\ \\mathrm{K}$。\n- 用例 2 (boundary emissivity)：与用例 1 相同，但 $\\varepsilon_w = 0.30$。\n- 用例 3 (geometric edge case)：$R = 0.10\\ \\mathrm{m}$, $N = 11$, $R_1 = 0.02\\ \\mathrm{m}$, $R_2 = 0.04\\ \\mathrm{m}$, $R_3 = 0.08\\ \\mathrm{m}$, $H_1 = H_2 = H_3 = 0.05\\ \\mathrm{m}$, $\\eta_1=0.70$, $\\eta_2=0.75$, $\\eta_3=0.80$, $\\varepsilon_w = 0.60$, $h_c = 8\\ \\mathrm{W\\,m^{-2}\\,K^{-1}}$, $T_{\\mathrm{env}} = 500\\ \\mathrm{K}$, $T_{\\mathrm{gas}} = 500\\ \\mathrm{K}$, $T_{\\mathrm{t}}=1000\\ \\mathrm{K}$。\n\n数值要求：\n- 使用至少 $M=720$ 个方位角点来近似计算每个灯-节点耦合的积分。\n- 在半径 $r_j = \\left(j - \\tfrac{1}{2}\\right)\\Delta r$（其中 $j=1,\\dots,N$，$ \\Delta r = R/N$）处分布晶圆节点，并使用精确的环形面积 $A_j = \\pi\\left((r_j+\\tfrac{\\Delta r}{2})^2 - (r_j-\\tfrac{\\Delta r}{2})^2\\right)$。\n- 在计算出 $P_i$ 后验证温度 $T_j$ 时，在 $T \\in [300\\ \\mathrm{K}, 1400\\ \\mathrm{K}]$ 的范围内对每个节点的非线性平衡进行稳健求解。\n\n最终输出格式：\n- 您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例贡献一个形如 $[P_1,P_2,P_3,\\Delta_{\\max},compliant]$ 的列表，其中 $P_i$ 单位为 W，$\\Delta_{\\max}$ 单位为 K。例如，输出应如下所示：\n$[[P1_case1,P2_case1,P3_case1,\\Delta_max_case1,True],[P1_case2,\\dots],[P1_case3,\\dots]]$。\n所有数值输出必须是浮点数（功率和偏差四舍五入到三位小数）或布尔值。整个输出必须作为单行打印。",
            "solution": "用户提供的问题是一个定义明确、有科学依据的计算传热学任务，专门针对半导体制造过程建模。它要求在一个快速热处理（RTP）系统中确定最佳灯功率，以实现均匀的晶圆温度。该问题是自洽的，提供了所有必需的物理参数、常数和控制方程。验证是成功的。\n\n该解决方案是通过遵循一系列源自热科学和数值方法第一性原理的步骤来实现的。\n\n**1. 系统离散化和几何参数**\n\n该模型首先对物理系统进行离散化。半径为 $R$ 的圆形晶圆被划分为 $N$ 个同心环形控制体积，或称节点。第 $j$ 个节点（$j=1, \\dots, N$）由其平均半径 $r_j$ 和面积 $A_j$ 来表征。\n- 每个环的径向宽度为 $\\Delta r = R/N$。\n- 第 $j$ 个节点的平均半径定义在环的中心：$r_j = (j - 1/2) \\Delta r$。\n- 第 $j$ 个环的面积，其内径为 $(j-1)\\Delta r$，外径为 $j\\Delta r$，精确值为 $A_j = \\pi((j\\Delta r)^2 - ((j-1)\\Delta r)^2)$。这可以简化为 $A_j = 2\\pi r_j \\Delta r$。\n\n**2. 辐射耦合矩阵 ($\\mathbf{K}$) 的构建**\n\n中心任务是在提供给每个灯环的电功率 $P_i$ 和每个晶圆节点 $j$ 吸收的热功率之间建立线性关系。这种关系由一组耦合系数 $k_{ij}$ 捕捉。\n\n每个灯环 $i$ 被建模为在半径 $R_i$ 和高度 $H_i$ 处的一个连续的各向同性点源圆环。环上方位角为 $\\alpha$ 的一个无穷小段发射总环功率的一部分。从此段辐射出的功率为 $\\mathrm{d}P_i^{\\mathrm{rad}} = \\eta_i P_i \\frac{\\mathrm{d}\\alpha}{2\\pi}$。对于一个各向同性源，辐射强度（单位立体角的功率）为 $I = \\mathrm{d}P_i^{\\mathrm{rad}} / (4\\pi)$。\n\n来自此源元件的晶圆上一点（半径为 $r_j$）的无穷小辐照度 $\\mathrm{d}E_{ij}$ 由反比平方定律给出，并包含一个投影因子（$\\cos\\theta$）：\n$$ \\mathrm{d}E_{ij}(\\alpha) = I \\frac{\\cos\\theta}{d(\\alpha)^2} $$\n其中 $d(\\alpha)$ 是源元件到晶圆点的距离，$\\theta$ 是入射角。几何关系决定了：\n- 距离：$d(\\alpha) = \\sqrt{H_i^2 + R_i^2 + r_j^2 - 2 R_i r_j \\cos\\alpha}$\n- 入射余弦：$\\cos\\theta = H_i / d(\\alpha)$\n\n将这些代入辐照度方程，并在整个环上（$\\alpha$ 从 $0$ 到 $2\\pi$）积分，得到来自灯环 $i$ 在半径 $r_j$ 处的总辐照度 $E_{ij}$：\n$$ E_{ij} = \\int_{0}^{2\\pi} \\frac{\\eta_i P_i \\mathrm{d}\\alpha / (2\\pi)}{4\\pi} \\frac{H_i/d(\\alpha)}{d(\\alpha)^2} = \\frac{\\eta_i H_i P_i}{8\\pi^2} \\int_{0}^{2\\pi} \\frac{1}{\\left(H_i^2 + R_i^2 + r_j^2 - 2 R_i r_j \\cos\\alpha\\right)^{3/2}} \\, \\mathrm{d}\\alpha $$\n晶圆节点 $j$ 从灯 $i$ 吸收的功率为 $Q_{\\mathrm{abs}, ij} = \\varepsilon_w A_j E_{ij}$，其中 $\\varepsilon_w$ 是晶圆的发射率（根据灰体表面的 Kirchhoff 定律，也是吸收率）。此吸收功率与 $P_i$ 呈线性关系，因此我们可以写成 $Q_{\\mathrm{abs}, ij} = k_{ij} P_i$。耦合系数 $k_{ij}$ 因此为：\n$$ k_{ij} = \\frac{\\varepsilon_w A_j \\eta_i H_i}{8\\pi^2} \\int_{0}^{2\\pi} \\frac{1}{\\left(H_i^2 + R_i^2 + r_j^2 - 2 R_i r_j \\cos\\alpha\\right)^{3/2}} \\, \\mathrm{d}\\alpha $$\n这个定积分通过数值方法计算。我们将角度 $\\alpha$ 离散为 $M$ 个点，$\\alpha_k = k \\cdot (2\\pi/M)$，其中 $k=0, \\dots, M-1$，步长为 $\\Delta\\alpha = 2\\pi/M$。积分由黎曼和近似：\n$$ \\int_{0}^{2\\pi} f(\\alpha) \\, \\mathrm{d}\\alpha \\approx \\sum_{k=0}^{M-1} f(\\alpha_k) \\Delta\\alpha $$\n对每个灯-节点对 $(i,j)$ 执行此计算，得到 $N \\times 3$ 的耦合矩阵 $\\mathbf{K}$。\n\n**3. 逆问题：灯功率计算**\n\n为了在整个晶圆上实现均匀的目标温度 $T_t$，每个节点吸收的功率必须平衡在该温度下的热损失。节点 $j$ 在温度 $T_t$ 下的总热损失是辐射损失和对流损失之和：\n$$ Q_j^{\\mathrm{target}} = \\varepsilon_w \\sigma A_j (T_t^4 - T_{\\mathrm{env}}^4) + h_c A_j (T_t - T_{\\mathrm{gas}}) $$\n其中 $\\sigma$ 是 Stefan–Boltzmann 常数。\n\n节点 $j$ 的总吸收功率是所有灯贡献的总和：$\\sum_{i=1}^{3} k_{ij} P_i$。将此等同于每个节点的目标损失，得到一个线性方程组：\n$$ \\sum_{i=1}^{3} k_{ij} P_i = Q_j^{\\mathrm{target}} \\quad \\text{for } j=1, \\dots, N $$\n用矩阵表示法，即 $\\mathbf{K} \\mathbf{P} = \\mathbf{Q}^{\\mathrm{target}}$，其中 $\\mathbf{P} = [P_1, P_2, P_3]^T$ 是未知灯功率的向量，$\\mathbf{Q}^{\\mathrm{target}}$ 是 $N \\times 1$ 的目标热损失向量。由于 $N=11$ 且灯的数量为 $3$，这是一个超定系统。为了找到一个物理上有意义的解，其中功率为非负（$P_i \\ge 0$），我们求解非负最小二乘（NNLS）问题：\n$$ \\min_{\\mathbf{P} \\ge 0} || \\mathbf{K} \\mathbf{P} - \\mathbf{Q}^{\\mathrm{target}} ||_2^2 $$\n该解提供了最优的、非负的功率 $P_1, P_2, P_3$，它们在所有节点上最好地实现了目标热负荷。\n\n**4. 正向问题：温度验证**\n\n利用计算出的灯功率 $\\mathbf{P}^*$，我们必须验证实际的温度分布。每个节点 $j$ 实际吸收的功率为 $Q_j^{\\mathrm{actual}} = \\sum_{i=1}^{3} k_{ij} P_i^*$。然后，通过求解非线性能量平衡方程来找到每个节点的实际稳态温度 $T_j$：\n$$ Q_j^{\\mathrm{actual}} = \\varepsilon_w \\sigma A_j (T_j^4 - T_{\\mathrm{env}}^4) + h_c A_j (T_j - T_{\\mathrm{gas}}) $$\n这等效于找到函数 $f(T_j) = 0$ 的根，其中：\n$$ f(T_j) = \\varepsilon_w \\sigma A_j T_j^4 + h_c A_j T_j - \\left( Q_j^{\\mathrm{actual}} + \\varepsilon_w \\sigma A_j T_{\\mathrm{env}}^4 + h_c A_j T_{\\mathrm{gas}} \\right) $$\n该函数对于 $T_j  0$ 是单调的，保证了唯一的正解。我们使用数值求根算法，如 Brent 方法，在指定的范围 $[300\\ \\mathrm{K}, 1400\\ \\mathrm{K}]$ 内找到每个 $T_j$。\n\n最后，通过与目标的最大偏差来评估温度均匀性：\n$$ \\Delta_{\\max} = \\max_{j=1, \\dots, N} |T_j - T_t| $$\n如果此偏差不超过 $5\\ \\mathrm{K}$，则该过程符合要求。每个测试用例的最终输出包括计算出的功率 $[P_1, P_2, P_3]$、最大偏差 $\\Delta_{\\max}$ 和合规状态。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import nnls, brentq\n\ndef solve():\n    \"\"\"\n    Main function to solve the RTP lamp power design problem for all test cases.\n    \"\"\"\n    # Define physical constant\n    SIGMA = 5.670374419e-8  # Stefan-Boltzmann constant, W m^-2 K^-4\n\n    # Define numerical parameters\n    M = 720  # Number of azimuthal points for integration\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (happy path)\n        {\n            \"R\": 0.10, \"N\": 11,\n            \"R_lamps\": np.array([0.03, 0.06, 0.09]),\n            \"H_lamps\": np.array([0.08, 0.08, 0.08]),\n            \"eta_lamps\": np.array([0.75, 0.75, 0.75]),\n            \"epsilon_w\": 0.70, \"h_c\": 10.0,\n            \"T_env\": 500.0, \"T_gas\": 500.0, \"T_t\": 1000.0\n        },\n        # Case 2 (boundary emissivity)\n        {\n            \"R\": 0.10, \"N\": 11,\n            \"R_lamps\": np.array([0.03, 0.06, 0.09]),\n            \"H_lamps\": np.array([0.08, 0.08, 0.08]),\n            \"eta_lamps\": np.array([0.75, 0.75, 0.75]),\n            \"epsilon_w\": 0.30, \"h_c\": 10.0,\n            \"T_env\": 500.0, \"T_gas\": 500.0, \"T_t\": 1000.0\n        },\n        # Case 3 (geometric edge case)\n        {\n            \"R\": 0.10, \"N\": 11,\n            \"R_lamps\": np.array([0.02, 0.04, 0.08]),\n            \"H_lamps\": np.array([0.05, 0.05, 0.05]),\n            \"eta_lamps\": np.array([0.70, 0.75, 0.80]),\n            \"epsilon_w\": 0.60, \"h_c\": 8.0,\n            \"T_env\": 500.0, \"T_gas\": 500.0, \"T_t\": 1000.0\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        # Unpack case parameters\n        R = case[\"R\"]\n        N = case[\"N\"]\n        R_lamps = case[\"R_lamps\"]\n        H_lamps = case[\"H_lamps\"]\n        eta_lamps = case[\"eta_lamps\"]\n        epsilon_w = case[\"epsilon_w\"]\n        h_c = case[\"h_c\"]\n        T_env = case[\"T_env\"]\n        T_gas = case[\"T_gas\"]\n        T_t = case[\"T_t\"]\n        \n        num_lamps = len(R_lamps)\n\n        # Step 1: Wafer discretization\n        dr = R / N\n        r_nodes = (np.arange(1, N + 1) - 0.5) * dr\n        # Exact area of each annulus is 2*pi*r_j*dr\n        A_nodes = 2 * np.pi * r_nodes * dr\n\n        # Step 2: Construct the coupling matrix K\n        K_matrix = np.zeros((N, num_lamps))\n        \n        alpha_k = np.linspace(0, 2 * np.pi, M, endpoint=False)\n        d_alpha = 2 * np.pi / M\n\n        for i in range(num_lamps):  # For each lamp ring\n            for j in range(N):  # For each wafer node\n                R_i, H_i, r_j = R_lamps[i], H_lamps[i], r_nodes[j]\n                \n                # Distance squared from source element to wafer point\n                dist_sq = H_i**2 + R_i**2 + r_j**2 - 2 * R_i * r_j * np.cos(alpha_k)\n                \n                # Integrand is 1 / d(alpha)^3\n                integrand = dist_sq**(-1.5)\n                \n                # Numerical integration using Riemann sum\n                integral_val = np.sum(integrand) * d_alpha\n                \n                # Calculate the coupling coefficient k_ij\n                k_ij = (epsilon_w * A_nodes[j] * eta_lamps[i] * H_i) / (8 * np.pi**2) * integral_val\n                K_matrix[j, i] = k_ij\n\n        # Step 3: Solve inverse problem for lamp powers P\n        # Calculate target heat loss vector Q_target for T_t\n        rad_loss = epsilon_w * SIGMA * A_nodes * (T_t**4 - T_env**4)\n        conv_loss = h_c * A_nodes * (T_t - T_gas)\n        Q_target = rad_loss + conv_loss\n\n        # Solve the Nonnegative Least Squares problem: min ||K*P - Q_target||_2^2 s.t. P = 0\n        P_lamps, _ = nnls(K_matrix, Q_target)\n\n        # Step 4: Verify temperatures and compute deviation\n        # Calculate actual absorbed power Q_actual = K * P\n        Q_actual = K_matrix @ P_lamps\n        \n        T_nodes = np.zeros(N)\n        for j in range(N):\n            A_j = A_nodes[j]\n            Q_abs_j = Q_actual[j]\n\n            # Define the energy balance equation f(T) = 0 for the root finder\n            def energy_balance(T):\n                power_out = epsilon_w * SIGMA * A_j * (T**4 - T_env**4) + h_c * A_j * (T - T_gas)\n                return power_out - Q_abs_j\n\n            # Solve for T_j using Brent's method in the specified range\n            T_nodes[j] = brentq(energy_balance, 300.0, 1400.0)\n\n        # Compute maximum deviation from target temp and check compliance\n        delta_max = np.max(np.abs(T_nodes - T_t))\n        is_compliant = delta_max = 5.0\n\n        # Store results for this case in the required format\n        result_list = [round(p, 3) for p in P_lamps]\n        result_list.append(round(delta_max, 3))\n        result_list.append(is_compliant)\n        results.append(result_list)\n\n    # Construct the final output string to match the exact format requested\n    # (no spaces within or between list elements)\n    inner_strs = []\n    for res_list in results:\n        # String representation for one case: [P1,P2,P3,delta,compliant]\n        s = f\"[{res_list[0]},{res_list[1]},{res_list[2]},{res_list[3]},{str(res_list[4])}]\"\n        inner_strs.append(s)\n    \n    final_output_str = f\"[{','.join(inner_strs)}]\"\n\n    print(final_output_str)\n\nsolve()\n```"
        }
    ]
}