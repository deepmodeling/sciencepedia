{
    "hands_on_practices": [
        {
            "introduction": "我们从最简单但也是最根本的模型开始。这项练习旨在建立一项核心技能：将一级可逆反应转化为微分方程，并在非等温退火（半导体制造中的常见情景）条件下进行数值求解。通过这个练习，您将掌握使用阿伦尼乌斯定律描述速率常数，并为更复杂的动力学系统打下坚实的基础。",
            "id": "4121849",
            "problem": "考虑半导体在热处理过程中的一个双态掺杂系统。令 $x(t)$ 表示在时间 $t$ 时电活性掺杂剂的比例，而 $1 - x(t)$ 表示处于非活性状态的比例。假设非活性和活性状态之间存在一级可逆动力学，其速率常数与温度相关。激活速率常数 $k_a(T)$ 和失活速率常数 $k_d(T)$ 遵循 Arrhenius 定律，具有指前因子和活化能。具体来说，对于任意温度 $T$，速率常数由 $k_a(T)$ 和 $k_d(T)$ 给出，每个速率常数都对 $T$ 具有标准的 Arrhenius 依赖性，其中能量以电子伏特表示，Boltzmann 常数（记为 $k_B$）以电子伏特每开尔文表示。\n\n从质量作用动力学和速率常数的 Arrhenius 温度依赖性出发，推导在一般的非等温温度历史 $T(t)$ 下 $x(t)$ 的控制方程。然后，对于一个由线性升温和恒温保持组成的温度曲线，\n- 对于 $0 \\le t \\le t_{\\mathrm{ramp}}$，其中 $t_{\\mathrm{ramp}} = (T_1 - T_0)/\\beta$，令 $T(t) = T_0 + \\beta t$；\n- 对于 $t_{\\mathrm{ramp}}  t \\le t_{\\mathrm{ramp}} + t_{\\mathrm{hold}}$，令 $T(t) = T_1$，\n计算在 $t_{\\mathrm{final}} = t_{\\mathrm{ramp}} + t_{\\mathrm{hold}}$ 时的最终活性比例 $x(t_{\\mathrm{final}})$。\n\n所有能量必须以电子伏特为单位，所有温度以开尔文为单位，时间以秒为单位，升温速率以开尔文每秒为单位。使用 $k_B = 8.617333262145 \\times 10^{-5}$ 电子伏特每开尔文。量 $x(t)$ 是无量纲的。\n\n您的程序必须对下述每个测试场景随时间数值计算 $x(t)$，并为每种情况返回最终值 $x(t_{\\mathrm{final}})$。每种情况的数值答案必须四舍五入到六位小数。您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，“[result1,result2,result3]”）。\n\n测试套件（每种情况为 $(T_0, T_1, \\beta, t_{\\mathrm{hold}}, A_a, E_a, A_d, E_d, x(0))$，其中 $A_a$ 和 $A_d$ 是指前因子（单位 $\\mathrm{s}^{-1}$），$E_a$ 和 $E_d$ 是活化能（单位电子伏特），$\\beta$ 是升温速率（单位 $\\mathrm{K/s}$），$T_0$ 和 $T_1$ 的单位是 $\\mathrm{K}$，$t_{\\mathrm{hold}}$ 的单位是 $\\mathrm{s}$，而 $x(0)$ 是无量纲的）：\n\n- 情况 1（一般的激活主导的非等温退火）： $(900,\\;1050,\\;10,\\;60,\\;10^9,\\;1.5,\\;5\\times 10^7,\\;2.5,\\;0.0)$。\n- 情况 2（快速升温并短暂保持）： $(900,\\;1050,\\;100,\\;5,\\;10^9,\\;1.5,\\;5\\times 10^7,\\;2.5,\\;0.0)$。\n- 情况 3（从完全激活的初始状态开始失活）： $(1100,\\;1200,\\;20,\\;120,\\;0.0,\\;1.0,\\;10^9,\\;2.0,\\;1.0)$。\n- 情况 4（作为边界情况的等温保持）： $(1000,\\;1000,\\;10,\\;30,\\;5\\times 10^8,\\;1.6,\\;2\\times 10^7,\\;2.4,\\;0.2)$。\n\n您的程序必须使用与温度相关的速率来实现动力学，并以上述指定的确切格式生成最终输出。输出是四舍五入到六位小数的浮点数，无量纲。",
            "solution": "该问题要求在非等温热处理过程中，推导并数值求解半导体中掺杂剂激活的动力学模型。对问题陈述的验证确认了其科学基础扎实、问题定义明确，并包含了继续进行所需的所有信息。\n\n首先，我们从第一性原理出发，建立控制微分方程。该系统包含掺杂原子的两种状态：活性和非活性。令 $x(t)$ 为在时间 $t$ 处于活性状态的掺杂剂比例。因此，处于非活性状态的比例是 $1 - x(t)$。掺杂剂的总浓度 $C_{total}$ 是恒定的。活性掺杂剂的浓度为 $C_a(t) = x(t) C_{total}$，非活性掺杂剂的浓度为 $C_i(t) = (1-x(t))C_{total}$。\n\n问题陈述指出，这些状态之间的转变遵循一级可逆动力学：\n$$\n\\text{非活性} \\underset{k_d}{\\stackrel{k_a}{\\rightleftharpoons}} \\text{活性}\n$$\n此处，$k_a$ 是激活反应（非活性 $\\rightarrow$ 活性）的速率常数，$k_d$ 是失活反应（活性 $\\rightarrow$ 非活性）的速率常数。\n\n根据质量作用定律，活性掺杂剂浓度的变化率 $\\frac{dC_a}{dt}$ 由从非活性状态生成的速率减去损失到非活性状态的速率给出：\n$$\n\\frac{dC_a}{dt} = k_a C_i - k_d C_a\n$$\n将 $C_a$ 和 $C_i$ 的表达式用活性比例 $x(t)$ 代入：\n$$\n\\frac{d(x(t) C_{total})}{dt} = k_a(T(t)) (1 - x(t)) C_{total} - k_d(T(t)) x(t) C_{total}\n$$\n由于 $C_{total}$ 是一个常数，导数得以简化，并且我们可以将整个方程除以 $C_{total}$：\n$$\n\\frac{dx}{dt} = k_a(T(t)) (1 - x(t)) - k_d(T(t)) x(t)\n$$\n这就是活性掺杂剂比例 $x(t)$ 的控制一阶常微分方程（ODE）。速率常数 $k_a$ 和 $k_d$ 与温度相关，因此通过温度历史 $T(t)$ 而与时间相关。\n\n速率常数的温度依赖性由 Arrhenius 方程描述：\n$$\nk_a(T) = A_a \\exp\\left(-\\frac{E_a}{k_B T}\\right)\n$$\n$$\nk_d(T) = A_d \\exp\\left(-\\frac{E_d}{k_B T}\\right)\n$$\n其中 $A_a$ 和 $A_d$ 是指前因子（单位 $\\mathrm{s}^{-1}$），$E_a$ 和 $E_d$ 是活化能（单位电子伏特，eV），$k_B$ 是 Boltzmann 常数，给定为 $8.617333262145 \\times 10^{-5} \\, \\mathrm{eV} \\cdot \\mathrm{K}^{-1}$。\n\n温度曲线 $T(t)$ 被指定为一个两阶段过程：线性升温，然后是等温保持。\n对于升温阶段，其中 $0 \\le t \\le t_{\\mathrm{ramp}}$：\n$$\nT(t) = T_0 + \\beta t\n$$\n对于保持阶段，其中 $t_{\\mathrm{ramp}}  t \\le t_{\\mathrm{final}}$：\n$$\nT(t) = T_1\n$$\n升温阶段的持续时间为 $t_{\\mathrm{ramp}} = (T_1 - T_0)/\\beta$，总处理时间为 $t_{\\mathrm{final}} = t_{\\mathrm{ramp}} + t_{\\mathrm{hold}}$。请注意，对于 $T_0 = T_1$ 的等温过程，$t_{\\mathrm{ramp}}$ 正确地计算为 $0$ 秒。\n\n该控制 ODE 可以表示为标准线性形式 $\\frac{dx}{dt} + P(t)x = Q(t)$：\n$$\n\\frac{dx}{dt} + [k_a(T(t)) + k_d(T(t))] x(t) = k_a(T(t))\n$$\n由于在升温阶段温度 $T(t)$ 不是恒定的，ODE 的系数 $P(t) = k_a(T(t)) + k_d(T(t))$ 和 $Q(t) = k_a(T(t))$ 是时间的显式函数。这使得该 ODE 成为非自治的，通常无法得到解析解。因此，需要采用数值方法。\n\n该问题被表述为一个初值问题（IVP），其 ODE 为 $\\frac{dx}{dt} = f(t, x)$，并为每种情况提供了初始条件 $x(0) = x_0$。我们将在时间区间 $[0, t_{\\mathrm{final}}]$ 上数值求解这个 IVP。SciPy 库中的 `scipy.integrate.solve_ivp` 函数是实现此目的的强大工具。它实现了多种自适应步长算法，适用于刚性和非刚性 ODE。化学动力学问题通常是刚性的，因此建议使用像‘Radau’或‘BDF’这样的方法以保证稳定性和准确性。\n\n计算过程如下：\n1. 对于每个测试用例，提取所有参数： $(T_0, T_1, \\beta, t_{\\mathrm{hold}}, A_a, E_a, A_d, E_d, x(0))$。\n2. 定义一个函数，例如 `dxdt(t, y, params)`，用于计算 ODE 的右侧。该函数将：\n   a. 解包参数。\n   b. 根据 $T(t)$ 的分段定义，确定当前时间 $t$ 的温度 $T$。\n   c. 使用 Arrhenius 方程计算 $k_a(T)$ 和 $k_d(T)$。\n   d. 返回 $\\frac{dx}{dt} = k_a (1 - x) - k_d x$ 的值。请注意，`solve_ivp` 期望状态变量 `y` 是一个数组，因此我们使用 `x = y[0]`。\n3. 将积分的时间跨度设置为 $[0, t_{\\mathrm{final}}]$，初始条件设置为 $[x(0)]$。\n4. 使用步骤 2 中的函数、时间跨度、初始条件和参数调用 `solve_ivp`。\n5. `solve_ivp` 的结果对象将包含在不同时间点的解。最终的活性比例 $x(t_{\\mathrm{final}})$ 是解数组中的最后一个值，即 `sol.y[0, -1]`。\n6. 根据要求，将此最终值四舍五入到六位小数。\n7. 对所有测试用例重复此过程，并将结果汇总为指定的输出格式。",
            "answer": "```python\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Solves the dopant activation kinetics ODE for a set of test cases.\n    \"\"\"\n    \n    # Constants\n    K_B = 8.617333262145e-5  # Boltzmann constant in eV/K\n\n    # Test suite: (T0, T1, beta, t_hold, Aa, Ea, Ad, Ed, x0)\n    test_cases = [\n        (900.0, 1050.0, 10.0, 60.0, 1e9, 1.5, 5e7, 2.5, 0.0),\n        (900.0, 1050.0, 100.0, 5.0, 1e9, 1.5, 5e7, 2.5, 0.0),\n        (1100.0, 1200.0, 20.0, 120.0, 0.0, 1.0, 1e9, 2.0, 1.0),\n        (1000.0, 1000.0, 10.0, 30.0, 5e8, 1.6, 2e7, 2.4, 0.2),\n    ]\n\n    results = []\n\n    def dxdt(t, y, T0, T1, beta, t_ramp, Aa, Ea, Ad, Ed):\n        \"\"\"\n        RHS of the ODE dx/dt for the active dopant fraction x.\n        \"\"\"\n        x = y[0]\n\n        # Determine temperature T at time t\n        if t = t_ramp:\n            T = T0 + beta * t\n        else:\n            T = T1\n        \n        # Prevent division by zero if T is ever 0, though not expected here\n        if T == 0:\n            return [0.0]\n\n        # Calculate Arrhenius rate constants\n        # Aa = 0 implies ka = 0, exp can be avoided\n        k_a = Aa * np.exp(-Ea / (K_B * T)) if Aa > 0.0 else 0.0\n        # Ad = 0 implies kd = 0\n        k_d = Ad * np.exp(-Ed / (K_B * T)) if Ad > 0.0 else 0.0\n\n        # Return rate of change of active fraction\n        return [k_a * (1 - x) - k_d * x]\n\n    for case in test_cases:\n        T0, T1, beta, t_hold, Aa, Ea, Ad, Ed, x0 = case\n\n        # Calculate time for the temperature ramp\n        # If beta is zero, but T0 != T1, t_ramp would be infinite, but problem spec avoids this.\n        # If T0 == T1, it's an isothermal case, and t_ramp is correctly 0.\n        if beta > 0:\n            t_ramp = (T1 - T0) / beta\n        else:\n            t_ramp = 0.0\n\n        t_final = t_ramp + t_hold\n        \n        # Ensure t_final is non-zero to avoid integration errors\n        if t_final == 0:\n            results.append(round(x0, 6))\n            continue\n\n        # Set up parameters for the ODE solver\n        params = (T0, T1, beta, t_ramp, Aa, Ea, Ad, Ed)\n        \n        # Initial condition\n        y0 = [x0]\n        \n        # Time span for integration\n        t_span = [0, t_final]\n\n        # Solve the ODE. 'Radau' is a good choice for potentially stiff problems\n        # like chemical kinetics.\n        sol = solve_ivp(\n            dxdt,\n            t_span,\n            y0,\n            args=params,\n            method='Radau',\n            dense_output=True\n        )\n\n        # The solution at the final time point\n        x_final = sol.sol(t_final)[0]\n        \n        # Append the rounded result\n        results.append(round(x_final, 6))\n\n    # Print results in the specified format\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == '__main__':\n    solve()\n```"
        },
        {
            "introduction": "在第一个模型的基础上，我们现在探索一种更复杂的钝化机制：团簇化。这个问题引入了非线性动力学，要求您求解一个描述多原子团簇形成的常微分方程，从而更深入地理解高浓度下的掺杂剂钝化行为。这个练习强调了质量作用定律在描述多体相互作用时的重要性。",
            "id": "4121856",
            "problem": "引入半导体的掺杂剂可以以电活性替代位态存在，也可以以由$n$个掺杂原子组成的电非活性团簇存在。令$s(t)$表示在时间$t$时处于替代位的总掺杂剂的分数，令$c(t)$表示每个掺杂原子的团簇数，因此掺杂剂守恒要求$s(t) + n\\,c(t) = 1$且$c(t) \\ge 0$。团簇的形成和溶解遵循质量作用动力学：团簇形成速率与$s(t)^n$成正比，团簇溶解速率与$c(t)$成正比，其速率常数依赖于温度并遵循阿伦尼乌斯定律。温度曲线$T(t)$在指定的时间节点上是分段线性的。目标是从质量作用和守恒定律出发，推导出$c(t)$的控制常微分方程（ODE），然后针对给定的退火程序进行数值求解，以获得每次退火结束时的失活掺杂剂分数$f_{\\mathrm{deact}}(t) = n\\,c(t)$。所有量$s(t)$和$c(t)$都是通过总掺杂剂含量归一化的无量纲分数，时间单位是秒，温度单位是开尔文，活化能单位是电子伏特。阿伦尼乌斯指前因子的单位是秒的倒数。在阿伦尼乌斯表达式中使用的玻尔兹曼常数必须是$k_{\\mathrm{B}} = 8.617333262145\\times 10^{-5}$电子伏特/开尔文。\n\n起始点和定义：\n- 掺杂剂守恒：$s(t) + n\\,c(t) = 1$ 对所有$t$成立。\n- 质量作用动力学：$\\dfrac{dc}{dt} = k_{\\mathrm{on}}(T(t))\\,s(t)^n - k_{\\mathrm{off}}(T(t))\\,c(t)$，其中$k_{\\mathrm{on}}(T) = k_{\\mathrm{on},0}\\,\\exp\\!\\left(-\\dfrac{E_{\\mathrm{a,on}}}{k_{\\mathrm{B}}\\,T}\\right)$ 且 $k_{\\mathrm{off}}(T) = k_{\\mathrm{off},0}\\,\\exp\\!\\left(-\\dfrac{E_{\\mathrm{a,off}}}{k_{\\mathrm{B}}\\,T}\\right)$。\n- 初始条件：$c(0) = 0$（所有掺杂剂初始时均处于替代位），所以$s(0) = 1$。\n- 失活分数：$f_{\\mathrm{deact}}(t) = n\\,c(t)$。\n\n任务：\n1. 使用守恒关系消去$s(t)$，推导出仅含$c(t)$和$T(t)$的$c(t)$的ODE。\n2. 为该ODE实现一个数值求解器，其中$T(t)$由时间-温度节点定义为分段线性函数，使用一个鲁棒的刚性ODE方法。\n3. 对于下面的每个测试用例，计算$f_{\\mathrm{deact}}(t_{\\mathrm{final}})$作为十进制数（无百分号），其中$t_{\\mathrm{final}}$是最后一个时间节点。\n\n测试套件（每个案例提供$n$、$k_{\\mathrm{on},0}$、$E_{\\mathrm{a,on}}$、$k_{\\mathrm{off},0}$、$E_{\\mathrm{a,off}}$和时间-温度节点）：\n- 案例1（等温退火）：$n=2$，$k_{\\mathrm{on},0} = 10^{9}\\,\\mathrm{s}^{-1}$，$E_{\\mathrm{a,on}} = 3.0\\,\\mathrm{eV}$，$k_{\\mathrm{off},0} = 10^{11}\\,\\mathrm{s}^{-1}$，$E_{\\mathrm{a,off}} = 3.2\\,\\mathrm{eV}$，节点 $\\{(0, 1100), (1000, 1100)\\}$。\n- 案例2（升温后保持）：$n=2$，$k_{\\mathrm{on},0} = 10^{9}\\,\\mathrm{s}^{-1}$，$E_{\\mathrm{a,on}} = 3.0\\,\\mathrm{eV}$，$k_{\\mathrm{off},0} = 10^{11}\\,\\mathrm{s}^{-1}$，$E_{\\mathrm{a,off}} = 3.2\\,\\mathrm{eV}$，节点 $\\{(0, 300), (600, 1200), (1200, 1200)\\}$。\n- 案例3（具有更强溶解作用的尖峰退火）：$n=2$，$k_{\\mathrm{on},0} = 10^{9}\\,\\mathrm{s}^{-1}$，$E_{\\mathrm{a,on}} = 3.0\\,\\mathrm{eV}$，$k_{\\mathrm{off},0} = 5\\times 10^{12}\\,\\mathrm{s}^{-1}$，$E_{\\mathrm{a,off}} = 3.0\\,\\mathrm{eV}$，节点 $\\{(0, 300), (50, 1300), (60, 1300), (120, 800)\\}$。\n- 案例4（低温长时退火，三原子团簇）：$n=3$，$k_{\\mathrm{on},0} = 10^{9}\\,\\mathrm{s}^{-1}$，$E_{\\mathrm{a,on}} = 3.2\\,\\mathrm{eV}$，$k_{\\mathrm{off},0} = 10^{11}\\,\\mathrm{s}^{-1}$，$E_{\\mathrm{a,off}} = 3.2\\,\\mathrm{eV}$，节点 $\\{(0, 300), (50, 900), (5050, 900)\\}$。\n- 案例5（无团簇形成的边缘情况）：$n=2$，$k_{\\mathrm{on},0} = 0\\,\\mathrm{s}^{-1}$，$E_{\\mathrm{a,on}} = 3.0\\,\\mathrm{eV}$，$k_{\\mathrm{off},0} = 10^{11}\\,\\mathrm{s}^{-1}$，$E_{\\mathrm{a,off}} = 3.2\\,\\mathrm{eV}$，节点 $\\{(0, 1100), (1000, 1100)\\}$。\n\n数值和输出要求：\n- 使用一个能够处理刚性问题的ODE积分器和对给定节点间的$T(t)$进行连续分段线性插值。\n- 确保数值解满足$c(t) \\ge 0$和$s(t) = 1 - n\\,c(t) \\ge 0$；如果数值漂移可能导致$s(t)  0$，则在速率评估中强制$s(t) = 0$。\n- 你的程序应产生单行输出，包含一个方括号括起来的、按上述案例顺序排列的逗号分隔结果列表，例如$[r_1,r_2,r_3,r_4,r_5]$，其中每个$r_i$是$f_{\\mathrm{deact}}(t_{\\mathrm{final}})$的最终十进制数值。",
            "solution": "该问题要求推导和数值求解一个控制半导体中掺杂剂失活动力学的常微分方程（ODE）。\n\n首先，我们推导归一化团簇浓度$c(t)$的控制ODE。该系统由两个量描述：$s(t)$，处于电活性替代位态的掺杂原子分数；以及$c(t)$，每个总掺杂原子的团簇数。分布在替代位和大小为$n$的团簇之间的掺杂原子的守恒关系由以下公式给出：\n$$s(t) + n\\,c(t) = 1$$\n该方程表明，处于替代位的原子分数$s(t)$加上团簇内的原子分数$n\\,c(t)$之和必须为1。根据该守恒定律，我们可以将替代位分数$s(t)$表示为团簇浓度$c(t)$的函数：\n$$s(t) = 1 - n\\,c(t)$$\n团簇的动力学由质量作用动力学描述。团簇浓度的变化率$\\dfrac{dc}{dt}$是团簇形成和溶解的净结果。问题指明速率方程为：\n$$\\dfrac{dc}{dt} = k_{\\mathrm{on}}(T(t))\\,s(t)^n - k_{\\mathrm{off}}(T(t))\\,c(t)$$\n形成项与$s(t)^n$成正比，这模拟了一个需要$n$个替代位原子形成一个团簇的反应。溶解项与$c(t)$成正比，模拟了团簇的一阶衰变。速率常数$k_{\\mathrm{on}}$和$k_{\\mathrm{off}}$是温度依赖的。\n\n为了得到关于$c(t)$的单一ODE，我们将守恒定律中$s(t)$的表达式代入速率方程。这样就消去了$s(t)$，得到了只包含$c(t)$和随时间变化的温度$T(t)$的ODE：\n$$\\dfrac{dc}{dt} = k_{\\mathrm{on}}(T(t))\\,(1 - n\\,c(t))^n - k_{\\mathrm{off}}(T(t))\\,c(t)$$\n这是一个一阶非线性ODE。初始条件给定为$c(0) = 0$，这表示在退火开始时，所有掺杂原子都处于替代位态（$s(0)=1$）。\n\n为了数值求解这个ODE，我们必须考虑其具体特性。温度曲线$T(t)$由一系列时间-温度节点$\\{(t_i, T_i)\\}$定义。在这些节点之间，$T(t)$是分段线性的。对于区间$[t_i, t_{i+1}]$中的任意时间$t$，温度通过线性插值计算：\n$$T(t) = T_i + (T_{i+1} - T_i) \\frac{t - t_i}{t_{i+1} - t_i}$$\n速率常数$k_{\\mathrm{on}}$和$k_{\\mathrm{off}}$遵循阿伦尼乌斯定律，表现出对温度的强指数依赖性：\n$$k_{\\mathrm{on}}(T) = k_{\\mathrm{on},0}\\,\\exp\\!\\left(-\\frac{E_{\\mathrm{a,on}}}{k_{\\mathrm{B}}\\,T}\\right) \\quad \\text{和} \\quad k_{\\mathrm{off}}(T) = k_{\\mathrm{off},0}\\,\\exp\\!\\left(-\\frac{E_{\\mathrm{a,off}}}{k_{\\mathrm{B}}\\,T}\\right)$$\n其中$k_{\\mathrm{B}} = 8.617333262145\\times 10^{-5}\\,\\mathrm{eV} \\cdot \\mathrm{K}^{-1}$是玻尔兹曼常数。\n快速变化的温度和阿伦尼乌斯定律的指数特性相结合，意味着在模拟过程中速率常数可以变化多个数量级。这导致反应动力学存在巨大的时间尺度差异，使得该ODE成为“刚性”的。标准的显式ODE求解器为了保持稳定性，将被迫采用极小的时间步长，从而导致效率低下。因此，需要一个专为刚性问题设计的数值积分器。`scipy.integrate`库中的`solve_ivp`函数提供了这类方法；我们将使用`'Radau'`方法，它是一种鲁棒的高阶隐式龙格-库塔积分器，适用于刚性ODE。\n\n传递给求解器的ODE右端（RHS）函数，我们将其表示为$f(t, c)$，是：\n$$f(t, c) = k_{\\mathrm{on}}(T(t))\\,(\\max(0, 1 - n\\,c))^n - k_{\\mathrm{off}}(T(t))\\,c$$\n在此表达式中，我们包含项$\\max(0, 1 - n\\,c)$来强制施加物理约束，即替代位分数$s(t) = 1 - n\\,c(t)$不能为负。如果数值不准确性导致$c(t)$暂时超过其物理最大值$1/n$，这可以防止求解器探索到非物理状态。另一个约束$c(t) \\ge 0$由ODE的物理性质自然保证：当$c=0$时，溶解项为零，而形成项为非负，因此$\\frac{dc}{dt} \\ge 0$，防止解变为负值。\n\n每个测试用例的计算流程如下：\n1. 设置物理参数：$n$、$k_{\\mathrm{on},0}$、$E_{\\mathrm{a,on}}$、$k_{\\mathrm{off},0}$和$E_{\\mathrm{a,off}}$。\n2. 根据给定的时间-温度节点，实现一个用于$T(t)$的分段线性插值函数。\n3. 定义ODE右端函数$f(t, c)$，其中包含随时间变化的温度和速率常数，以及对$s(t)$的物理约束。\n4. 使用`scipy.integrate.solve_ivp`和`'Radau'`方法，从初始条件$c(0)=0$开始，对ODE进行积分，直至最终时间$t_{\\mathrm{final}}$。\n5. 求解器返回$c(t_{\\mathrm{final}})$的值。\n6. 计算最终的失活分数$f_{\\mathrm{deact}}(t_{\\mathrm{final}}) = n \\cdot c(t_{\\mathrm{final}})$。\n\n将此过程系统地应用于五个测试用例中的每一个，以获得所需结果。",
            "answer": "```python\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Solves the dopant clustering ODE for a series of test cases and\n    prints the final deactivated fraction for each case.\n    \"\"\"\n    \n    # Physical constant\n    KB_EV_K = 8.617333262145e-5  # Boltzmann constant in eV/K\n\n    # Test cases as defined in the problem statement\n    test_cases = [\n        {\n            \"id\": 1, \"n\": 2, \"kon0\": 1e9, \"Ea_on\": 3.0, \"koff0\": 1e11, \"Ea_off\": 3.2,\n            \"nodes\": np.array([[0, 1100], [1000, 1100]])\n        },\n        {\n            \"id\": 2, \"n\": 2, \"kon0\": 1e9, \"Ea_on\": 3.0, \"koff0\": 1e11, \"Ea_off\": 3.2,\n            \"nodes\": np.array([[0, 300], [600, 1200], [1200, 1200]])\n        },\n        {\n            \"id\": 3, \"n\": 2, \"kon0\": 1e9, \"Ea_on\": 3.0, \"koff0\": 5e12, \"Ea_off\": 3.0,\n            \"nodes\": np.array([[0, 300], [50, 1300], [60, 1300], [120, 800]])\n        },\n        {\n            \"id\": 4, \"n\": 3, \"kon0\": 1e9, \"Ea_on\": 3.2, \"koff0\": 1e11, \"Ea_off\": 3.2,\n            \"nodes\": np.array([[0, 300], [50, 900], [5050, 900]])\n        },\n        {\n            \"id\": 5, \"n\": 2, \"kon0\": 0.0, \"Ea_on\": 3.0, \"koff0\": 1e11, \"Ea_off\": 3.2,\n            \"nodes\": np.array([[0, 1100], [1000, 1100]])\n        },\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        # Unpack parameters for the current case\n        n = case[\"n\"]\n        kon0 = case[\"kon0\"]\n        Ea_on = case[\"Ea_on\"]\n        koff0 = case[\"koff0\"]\n        Ea_off = case[\"Ea_off\"]\n        nodes = case[\"nodes\"]\n        \n        time_points = nodes[:, 0]\n        temp_points = nodes[:, 1]\n        \n        t_final = time_points[-1]\n        \n        # If the total duration is zero, no change occurs from the initial state\n        if t_final == 0:\n            c_final = 0.0\n            f_deact = n * c_final\n            results.append(f_deact)\n            continue\n\n        # Create a piecewise linear-interpolated temperature function T(t)\n        def T_interp(t):\n            return np.interp(t, time_points, temp_points)\n\n        def dcdt(t, c_vec):\n            \"\"\"\n            The right-hand side of the ODE: dc/dt = f(t, c)\n            \"\"\"\n            c = c_vec[0]\n            T = T_interp(t)\n            \n            # Avoid division by zero, although not expected with given data\n            if T == 0:\n                return [0.0]\n\n            # Calculate Arrhenius rate constants\n            kon = kon0 * np.exp(-Ea_on / (KB_EV_K * T))\n            koff = koff0 * np.exp(-Ea_off / (KB_EV_K * T))\n\n            # Substitutional fraction, with physical constraint s >= 0\n            s = 1.0 - n * c\n            s = max(0.0, s)\n\n            # Rate of change of cluster concentration\n            rate = kon * (s**n) - koff * c\n            return [rate]\n\n        # Initial condition: c(0) = 0\n        c0 = [0.0]\n        t_span = (0, t_final)\n\n        # Solve the stiff ODE using Radau method\n        sol = solve_ivp(dcdt, t_span, c0, method='Radau', t_eval=[t_final])\n        \n        c_final = sol.y[0, -1]\n        \n        # Calculate the final deactivated fraction\n        f_deact = n * c_final\n        results.append(f_deact)\n\n    # Print the results in the required format\n    print(f\"[{','.join(f'{r:.12f}' for r in results)}]\")\n\nif __name__ == '__main__':\n    solve()\n```"
        },
        {
            "introduction": "现在，我们将所学原理应用于一个真实的工艺模拟挑战。这项练习涉及一个由掺杂剂和点缺陷组成的耦合反应网络，用于模拟一个多步骤的工艺流程。您的任务是利用该动力学模型来预测不同工艺序列的结果，并找出最优序列，从而展示工艺建模在实际工程优化中的强大能力。",
            "id": "4121922",
            "problem": "考虑一个反应网络，该网络捕捉了半导体制造过程中晶体硅内掺杂剂的激活与失活过程。多个离子注入步骤会引入掺杂原子和点缺陷，随后在指定温度下进行热退火。您的任务是推导、实现并求解一个具有阿伦尼乌斯温度依赖性的质量作用动力学模型，以预测最终的电激活掺杂剂比例，并利用此预测来确定所提供序列中注入和退火的最佳顺序。\n\n基本原理和假设：\n- 使用化学动力学的质量作用定律来描述物种之间的反应。如果 $A$ 和 $B$ 反应生成 $C$，双分子速率常数为 $k$，则正向反应速率为 $r = k [A][B]$。\n- 使用阿伦尼乌斯定律描述速率常数的温度依赖性，$k(T) = k_0 \\exp\\!\\left(-\\dfrac{E_a}{k_B T}\\right)$，其中 $k_0$ 是指前因子，$E_a$ 是活化能，$k_B$ 是玻尔兹曼常数，$T$ 是绝对温度。\n- 忽略空间梯度和扩散；在一个充分混合的体积元中进行建模，因此所有物种都由密度表示，单位为 $\\text{cm}^{-3}$。\n\n物种：\n- $D_i$：间隙掺杂剂密度（非激活态），单位 $\\text{cm}^{-3}$。\n- $D_s$：替位掺杂剂密度（激活态），单位 $\\text{cm}^{-3}$。\n- $X$：掺杂剂-间隙原子复合物密度（非激活态团簇），单位 $\\text{cm}^{-3}$。\n- $I$：自间隙原子密度，单位 $\\text{cm}^{-3}$。\n- $V$：空位密度，单位 $\\text{cm}^{-3}$。\n\n反应：\n- 间隙机制激活及其逆反应：\n  $$D_i + I \\xrightarrow{k_1(T)} D_s,\\quad D_s \\xrightarrow{k_{1r}(T)} D_i + I.$$\n- 通过形成复合物失活及其逆反应：\n  $$D_s + I \\xrightarrow{k_2(T)} X,\\quad X \\xrightarrow{k_{2r}(T)} D_s + I.$$\n- 间隙原子-空位复合：\n  $$I + V \\xrightarrow{k_3(T)} \\varnothing.$$\n\n写出质量作用常微分方程（将在您的解法中推导）：\n- $\\dfrac{d D_i}{d t}$, $\\dfrac{d D_s}{d t}$, $\\dfrac{d X}{d t}$, $\\dfrac{d I}{d t}$, $\\dfrac{d V}{d t}$ 作为反应速率的函数。\n\n温度依赖性：\n- 使用 $k_B = 8.617\\times 10^{-5}\\,\\text{eV/K}$。\n- 阿伦尼乌斯指前因子和活化能的参数化如下（选择的参数在科学上是合理的，并且是自洽的）：\n  - $k_1$：$k_{1,0} = 1.0\\times 10^{-13}\\,\\text{cm}^3/\\text{s}$，$E_{a,1} = 0.80\\,\\text{eV}$。\n  - $k_{1r}$：$k_{1r,0} = 1.0\\times 10^{4}\\,\\text{s}^{-1}$，$E_{a,1r} = 2.20\\,\\text{eV}$。\n  - $k_2$：$k_{2,0} = 5.0\\times 10^{-14}\\,\\text{cm}^3/\\text{s}$，$E_{a,2} = 1.20\\,\\text{eV}$。\n  - $k_{2r}$：$k_{2r,0} = 5.0\\times 10^{2}\\,\\text{s}^{-1}$，$E_{a,2r} = 2.60\\,\\text{eV}$。\n  - $k_3$：$k_{3,0} = 2.0\\times 10^{-12}\\,\\text{cm}^3/\\text{s}$，$E_{a,3} = 0.50\\,\\text{eV}$。\n\n注入步骤：\n- 剂量为 $D$ 的注入会立即将 $D_i$ 增加 $f_i D$，将 $D_s$ 增加 $(1 - f_i) D$，并将点缺陷增加为 $I \\leftarrow I + \\alpha_I D$，$V \\leftarrow V + \\alpha_V D$，其中 $f_i$ 是最初处于间隙位置的掺杂剂比例，$\\alpha_I$ 和 $\\alpha_V$ 代表每个掺杂原子产生的损伤。这些是瞬时变化，没有时间演化。\n\n退火步骤：\n- 在温度 $T$、持续时间 $\\tau$ 的退火过程中，系统在恒定温度 $T$ 下，根据动力学常微分方程进行演化，时间范围为 $t \\in [0,\\tau]$，初始条件由退火步骤之前的状态设定。\n\n目标：\n- 对于每个工艺序列，计算最终的激活比例，定义为\n  $$\\phi = \\frac{D_s}{D_i + D_s + X},$$\n  该值在序列结束时进行评估。此外，计算在所提供的序列中使 $\\phi$ 最大化的最佳序列索引，使用从1开始的索引，并通过选择最小索引来解决平局问题。\n\n单位和输出：\n- 所有密度必须以 $\\text{cm}^{-3}$ 处理，温度以 $\\text{K}$，持续时间以 $\\text{s}$。\n- 将每个激活比例 $\\phi$ 表示为四舍五入到三位小数的十进制数。\n- 您的程序应生成单行输出，其中包含一个逗号分隔的列表，用方括号括起来，顺序为 $[\\phi_1,\\phi_2,\\phi_3,\\text{best}]$，其中 $\\phi_i$ 是三个测试序列的最终激活比例，$\\text{best}$ 是最佳序列索引（一个整数）。\n\n测试套件（三个序列）：\n- 序列1（分阶段激活）：\n  - 初始缺陷：$I_0 = 0\\,\\text{cm}^{-3}$，$V_0 = 0\\,\\text{cm}^{-3}$。\n  - 步骤1：注入，剂量 $3.0\\times 10^{19}\\,\\text{cm}^{-3}$，$f_i = 0.95$，$\\alpha_I = 0.20$，$\\alpha_V = 0.20$。\n  - 步骤2：退火，$T = 1173\\,\\text{K}$，持续时间 $\\tau = 600\\,\\text{s}$。\n  - 步骤3：注入，剂量 $2.0\\times 10^{19}\\,\\text{cm}^{-3}$，$f_i = 0.95$，$\\alpha_I = 0.20$，$\\alpha_V = 0.20$。\n  - 步骤4：退火，$T = 1273\\,\\text{K}$，持续时间 $\\tau = 120\\,\\text{s}$。\n- 序列2（连续注入后长时退火）：\n  - 初始缺陷：$I_0 = 0\\,\\text{cm}^{-3}$，$V_0 = 0\\,\\text{cm}^{-3}$。\n  - 步骤1：注入，剂量 $3.0\\times 10^{19}\\,\\text{cm}^{-3}$，$f_i = 0.95$，$\\alpha_I = 0.20$，$\\alpha_V = 0.20$。\n  - 步骤2：注入，剂量 $2.0\\times 10^{19}\\,\\text{cm}^{-3}$，$f_i = 0.95$，$\\alpha_I = 0.20$，$\\alpha_V = 0.20$。\n  - 步骤3：退火，$T = 1223\\,\\text{K}$，持续时间 $\\tau = 900\\,\\text{s}$。\n- 序列3（初始缺陷和混合的尖峰/均热退火）：\n  - 初始缺陷：$I_0 = 5.0\\times 10^{18}\\,\\text{cm}^{-3}$，$V_0 = 5.0\\times 10^{18}\\,\\text{cm}^{-3}$。\n  - 步骤1：注入，剂量 $3.0\\times 10^{19}\\,\\text{cm}^{-3}$，$f_i = 0.95$，$\\alpha_I = 0.20$，$\\alpha_V = 0.20$。\n  - 步骤2：退火，$T = 1173\\,\\text{K}$，持续时间 $\\tau = 60\\,\\text{s}$。\n  - 步骤3：注入，剂量 $2.0\\times 10^{19}\\,\\text{cm}^{-3}$，$f_i = 0.95$，$\\alpha_I = 0.20$，$\\alpha_V = 0.20$。\n  - 步骤4：退火，$T = 1373\\,\\text{K}$，持续时间 $\\tau = 30\\,\\text{s}$。\n\n实现要求：\n- 对每个退火步骤，使用适合刚性系统的方法数值求解常微分方程。\n- 将所有提供的测试序列的结果汇总成所需的单行输出格式。",
            "solution": "该问题要求建立并数值求解一个质量作用动力学模型，以模拟在离子注入和热退火序列中硅中掺杂剂的激活与失活过程。目标是确定几个工艺序列的最终电激活掺杂剂比例，并找出能使该比例最大化的最佳序列。\n\n该模型基于一个耦合常微分方程（ODE）系统，该系统描述了在一个充分混合的体积元内各种物种浓度随时间的演化。浓度的空间依赖性被忽略。\n\n反应网络中涉及的物种有：\n- $D_i$：间隙掺杂剂浓度（非激活态），单位为 $\\text{cm}^{-3}$。\n- $D_s$：替位掺杂剂浓度（电激活态），单位为 $\\text{cm}^{-3}$。\n- $X$：掺杂剂-间隙原子复合物浓度（非激活态），单位为 $\\text{cm}^{-3}$。\n- $I$：自间隙点缺陷浓度，单位为 $\\text{cm}^{-3}$。\n- $V$：空位点缺陷浓度，单位为 $\\text{cm}^{-3}$。\n\n在任何时刻 $t$，系统的状态由浓度向量 $y(t) = ([D_i], [D_s], [X], [I], [V])$ 描述。\n\n控制系统动力学的反应是：\n1. 间隙机制激活/失活：$D_i + I \\rightleftharpoons_{k_{1r}(T)}^{k_1(T)} D_s$\n2. 复合物形成/分解：$D_s + I \\rightleftharpoons_{k_{2r}(T)}^{k_2(T)} X$\n3. 间隙原子-空位复合：$I + V \\xrightarrow{k_3(T)} \\varnothing$（湮灭）\n\n根据质量作用定律，这些反应的速率由以下公式给出：\n- $R_1 = k_1(T) [D_i] [I]$\n- $R_{1r} = k_{1r}(T) [D_s]$\n- $R_2 = k_2(T) [D_s] [I]$\n- $R_{2r} = k_{2r}(T) [X]$\n- $R_3 = k_3(T) [I] [V]$\n\n从这些速率，我们可以推导出描述每种物种浓度变化率的ODE系统。每种物种的变化率是产生它的反应速率之和减去消耗它的反应速率之和。\n\n最终得到的五个耦合一阶ODE系统如下：\n$$ \\frac{d[D_i]}{dt} = -R_1 + R_{1r} = -k_1 [D_i][I] + k_{1r} [D_s] $$\n$$ \\frac{d[D_s]}{dt} = R_1 - R_{1r} - R_2 + R_{2r} = k_1 [D_i][I] - k_{1r} [D_s] - k_2 [D_s][I] + k_{2r} [X] $$\n$$ \\frac{d[X]}{dt} = R_2 - R_{2r} = k_2 [D_s][I] - k_{2r} [X] $$\n$$ \\frac{d[I]}{dt} = -R_1 + R_{1r} - R_2 + R_{2r} - R_3 = -k_1 [D_i][I] + k_{1r} [D_s] - k_2 [D_s][I] + k_{2r} [X] - k_3 [I][V] $$\n$$ \\frac{d[V]}{dt} = -R_3 = -k_3 [I][V] $$\n\n一个关键的一致性检查是验证退火过程中总掺杂原子的守恒。总掺杂浓度为 $D_{tot} = [D_i] + [D_s] + [X]$。其时间导数为 $\\frac{dD_{tot}}{dt} = \\frac{d[D_i]}{dt} + \\frac{d[D_s]}{dt} + \\frac{d[X]}{dt}$。将推导出的ODE相加，所有项都相互抵消，得到 $\\frac{dD_{tot}}{dt} = 0$，这证实了总掺杂浓度在热退火期间是一个守恒量，符合预期。\n\n速率常数 $k_j$ 的温度依赖性由阿伦尼乌斯方程给出：\n$$ k_j(T) = k_{j,0} \\exp\\left(-\\frac{E_{a,j}}{k_B T}\\right) $$\n其中 $k_{j,0}$ 是指前因子，$E_{a,j}$ 是反应 $j$ 的活化能，$T$ 是绝对温度（单位为开尔文），$k_B$ 是玻尔兹曼常数，给定值为 $8.617 \\times 10^{-5}\\,\\text{eV/K}$。每个反应的具体参数在问题描述中提供。\n\n模拟通过顺序处理每个给定序列的步骤来进行：\n1.  **注入步骤：** 这被建模为浓度的瞬时变化。对于剂量为 $D$，间隙分数为 $f_i$，损伤因子为 $\\alpha_I$ 和 $\\alpha_V$ 的注入，状态向量更新如下：\n    - $[D_i] \\leftarrow [D_i] + f_i D$\n    - $[D_s] \\leftarrow [D_s] + (1 - f_i) D$\n    - $[I] \\leftarrow [I] + \\alpha_I D$\n    - $[V] \\leftarrow [V] + \\alpha_V D$\n2.  **退火步骤：** 此步骤涉及在恒定温度 $T$ 下，在时间区间 $[0, \\tau]$ 内求解ODE系统。首先，为指定温度 $T$ 计算速率常数 $k_j(T)$。然后，使用数值ODE求解器来积分该系统。由于这类动力学系统中可能存在广泛的时间尺度，它们通常是刚性的。因此，需要一种适合刚性问题的数值方法，例如后向差分公式（BDF）。积分的初始条件是上一步结束时的状态向量。求解器得到的最终状态向量成为下一步的初始状态。\n\n在一个序列中的所有步骤完成后，使用最终浓度计算最终的激活掺杂剂比例 $\\phi$：\n$$ \\phi = \\frac{[D_s]_{final}}{[D_i]_{final} + [D_s]_{final} + [X]_{final}} $$\n\n对三个测试序列中的每一个都重复此过程。最后，将产生最高 $\\phi$ 值的序列确定为最佳序列。然后按要求格式化结果。\n\n实现将利用 `scipy.integrate.solve_ivp` 函数，并使用 `method='BDF'` 选项来处理退火步骤中的刚性ODE系统。系统状态将使用一个NumPy数组来跟踪，该数组在每次注入和退火步骤后都会更新。",
            "answer": "```python\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Solves the dopant activation/deactivation kinetics problem for three\n    different process sequences.\n    \"\"\"\n\n    # --- Constants and Parameters ---\n    KB = 8.617e-5  # Boltzmann constant in eV/K\n\n    # Arrhenius parameters: (k_0, E_a)\n    # k_0 units: cm^3/s for bimolecular, 1/s for unimolecular\n    # E_a units: eV\n    PARAMS = {\n        'k1': (1.0e-13, 0.80),\n        'k1r': (1.0e4, 2.20),\n        'k2': (5.0e-14, 1.20),\n        'k2r': (5.0e2, 2.60),\n        'k3': (2.0e-12, 0.50),\n    }\n\n    # --- Test Sequences Definition ---\n    # Structure: list of sequences, where each sequence is a list of steps.\n    # Each step is a dictionary defining its type and parameters.\n    # Species order in state vector: [Di, Ds, X, I, V]\n    \n    sequences = [\n        # Sequence 1\n        [\n            {'type': 'implant', 'dose': 3.0e19, 'fi': 0.95, 'alpha_I': 0.20, 'alpha_V': 0.20},\n            {'type': 'anneal', 'T': 1173, 'tau': 600},\n            {'type': 'implant', 'dose': 2.0e19, 'fi': 0.95, 'alpha_I': 0.20, 'alpha_V': 0.20},\n            {'type': 'anneal', 'T': 1273, 'tau': 120}\n        ],\n        # Sequence 2\n        [\n            {'type': 'implant', 'dose': 3.0e19, 'fi': 0.95, 'alpha_I': 0.20, 'alpha_V': 0.20},\n            {'type': 'implant', 'dose': 2.0e19, 'fi': 0.95, 'alpha_I': 0.20, 'alpha_V': 0.20},\n            {'type': 'anneal', 'T': 1223, 'tau': 900}\n        ],\n        # Sequence 3\n        [\n            {'type': 'implant', 'dose': 3.0e19, 'fi': 0.95, 'alpha_I': 0.20, 'alpha_V': 0.20},\n            {'type': 'anneal', 'T': 1173, 'tau': 60},\n            {'type': 'implant', 'dose': 2.0e19, 'fi': 0.95, 'alpha_I': 0.20, 'alpha_V': 0.20},\n            {'type': 'anneal', 'T': 1373, 'tau': 30}\n        ]\n    ]\n\n    initial_conditions = [\n        np.array([0.0, 0.0, 0.0, 0.0, 0.0]), # Seq 1: Di, Ds, X, I, V\n        np.array([0.0, 0.0, 0.0, 0.0, 0.0]), # Seq 2\n        np.array([0.0, 0.0, 0.0, 5.0e18, 5.0e18]) # Seq 3\n    ]\n\n    def get_rate_constants(T):\n        \"\"\"Calculates Arrhenius rate constants for a given temperature T.\"\"\"\n        k = {}\n        for key, (k0, Ea) in PARAMS.items():\n            k[key] = k0 * np.exp(-Ea / (KB * T))\n        return k['k1'], k['k1r'], k['k2'], k['k2r'], k['k3']\n\n    def ode_system(t, y, k1, k1r, k2, k2r, k3):\n        \"\"\"\n        Defines the system of ordinary differential equations for dopant kinetics.\n        y = [Di, Ds, X, I, V]\n        \"\"\"\n        # Ensure concentrations do not go negative during calculations\n        Di, Ds, X, I, V = np.maximum(y, 0)\n        \n        # Reaction rates\n        R1 = k1 * Di * I\n        R1r = k1r * Ds\n        R2 = k2 * Ds * I\n        R2r = k2r * X\n        R3 = k3 * I * V\n\n        # ODEs\n        dDi_dt = -R1 + R1r\n        dDs_dt = R1 - R1r - R2 + R2r\n        dX_dt = R2 - R2r\n        dI_dt = -R1 + R1r - R2 + R2r - R3\n        dV_dt = -R3\n        \n        return [dDi_dt, dDs_dt, dX_dt, dI_dt, dV_dt]\n\n    final_phis = []\n\n    for i, sequence in enumerate(sequences):\n        # Initialize state vector from the problem's initial conditions\n        y = np.copy(initial_conditions[i])\n\n        for step in sequence:\n            if step['type'] == 'implant':\n                dose = step['dose']\n                fi = step['fi']\n                alpha_I = step['alpha_I']\n                alpha_V = step['alpha_V']\n                \n                y[0] += fi * dose         # Di\n                y[1] += (1 - fi) * dose   # Ds\n                y[3] += alpha_I * dose    # I\n                y[4] += alpha_V * dose    # V\n            \n            elif step['type'] == 'anneal':\n                T = step['T']\n                tau = step['tau']\n                \n                # Calculate rate constants for the anneal temperature\n                k_tuple = get_rate_constants(T)\n                \n                # Solve the ODE system for the anneal duration\n                sol = solve_ivp(\n                    fun=ode_system,\n                    t_span=[0, tau],\n                    y0=y,\n                    method='BDF',  # Suitable for stiff systems\n                    args=k_tuple,\n                    dense_output=False\n                )\n                \n                # Update state vector with the final concentrations\n                y = sol.y[:, -1]\n\n        # Calculate final active fraction phi\n        Di_f, Ds_f, X_f = y[0], y[1], y[2]\n        total_dopant = Di_f + Ds_f + X_f\n        \n        # Handle case where total_dopant is zero to avoid division by zero\n        phi = (Ds_f / total_dopant) if total_dopant > 0 else 0.0\n        final_phis.append(phi)\n\n    # Determine the optimal sequence (1-based index)\n    best_idx = np.argmax(final_phis) + 1\n\n    # Format the output string\n    phi_strings = [f\"{phi:.3f}\" for phi in final_phis]\n    output_list = phi_strings + [str(best_idx)]\n    \n    print(f\"[{','.join(output_list)}]\")\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}