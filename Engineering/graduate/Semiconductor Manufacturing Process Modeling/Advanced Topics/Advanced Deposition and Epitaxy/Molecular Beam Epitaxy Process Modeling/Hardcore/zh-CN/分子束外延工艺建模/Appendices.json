{
    "hands_on_practices": [
        {
            "introduction": "分子束外延（MBE）技术的核心依赖于从蒸发源（effusion cell）中精确地产生原子或分子通量。本练习将气源材料的温度和蒸气压等宏观属性，通过气体动理论的基本原理，与发射的粒子通量联系起来。通过从头推导赫兹-克努森（Hertz-Knudsen）方程，您将从最根本的层面深入、定量地理解蒸发源的工作机制。",
            "id": "4142758",
            "problem": "一个用于分子束外延（MBE）的镓蒸发源在运行时，其内部的镓表面与温度为 $T=1100\\ \\text{K}$ 的单原子蒸气处于热力学平衡状态。一个镓原子的质量为 $m=69.7\\ \\text{amu}$。镓表面上方的平衡蒸气压为 $p_{\\text{eq}}=1.0\\times 10^{-2}\\ \\text{Torr}$。小孔侧的真空度足够高，因此那里的环境压力可以视为 $p\\approx 0$。蒸发系数（有时也称为适应系数）为 $\\alpha=1$。\n\n从气体动理论、理想气体定律以及分子速率的麦克斯韦-玻尔兹曼分布出发，推导在小孔处的净发射粒子数通量密度作为 $p_{\\text{eq}}$、$p$、$m$ 和 $T$ 的函数表达式，然后在给定条件下计算其值。使用 $1\\ \\text{Torr}=133.322\\ \\text{Pa}$ 和 $1\\ \\text{amu}=1.66053906660\\times 10^{-27}\\ \\text{kg}$。将最终数值答案以 $\\text{原子}\\ \\text{m}^{-2}\\ \\text{s}^{-1}$ 为单位表示，并四舍五入至四位有效数字。",
            "solution": "首先验证该问题，以确保其科学上可靠、提法恰当且客观。\n\n### 第1步：提取已知条件\n- 系统：分子束外延（MBE）中使用的镓蒸发源。\n- 内部状态：镓表面与单原子蒸气之间处于热力学平衡。\n- 温度：$T = 1100\\ \\text{K}$。\n- 镓原子质量：$m = 69.7\\ \\text{amu}$。\n- 平衡蒸气压：$p_{\\text{eq}} = 1.0 \\times 10^{-2}\\ \\text{Torr}$。\n- 小孔处的环境压力：$p \\approx 0$。\n- 蒸发系数：$\\alpha = 1$。\n- 换算常数：$1\\ \\text{Torr} = 133.322\\ \\text{Pa}$。\n- 换算常数：$1\\ \\text{amu} = 1.66053906660 \\times 10^{-27}\\ \\text{kg}$。\n- 任务1：推导净发射粒子数通量密度 $J_{\\text{net}}$ 作为 $p_{\\text{eq}}$、$p$、$m$ 和 $T$ 的函数表达式。\n- 任务2：计算 $J_{\\text{net}}$ 的数值，单位为 原子 $\\text{m}^{-2}\\ \\text{s}^{-1}$。\n- 取值要求：四位有效数字。\n\n### 第2步：使用提取的已知条件进行验证\n该问题具有科学合理性，它基于气体动理论、理想气体定律和麦克斯韦-玻尔兹曼分布等已确立的原理，并应用于一个标准的物理系统（蒸发源）。所提供的值对于 MBE 应用是切合实际的。该问题是良构的，为得到唯一解提供了所有必要信息。语言客观、精确。因此，该问题被认定为有效。\n\n### 第3步：结论与行动\n问题有效。将提供完整解答。\n\n### 通量密度表达式的推导\n从孔口发射的净粒子数通量密度 $J_{\\text{net}}$ 是离开蒸发源的粒子通量 $J_{\\text{out}}$ 与从环境真空进入蒸发源的粒子通量 $J_{\\text{in}}$ 之差。\n$$J_{\\text{net}} = J_{\\text{out}} - J_{\\text{in}}$$\n我们首先推导一个通用表达式，用于描述在压力 $P$ 和温度 $T$ 下，理想气体中的粒子撞击表面的通量密度 $J$。该通量密度表示单位时间内穿过单位面积的粒子数。\n\n根据气体动理论，粒子数密度 $n$ 通过理想气体定律与压力 $P$ 和温度 $T$ 相关联：\n$$P = n k_B T \\implies n = \\frac{P}{k_B T}$$\n其中 $k_B$ 是玻尔兹曼常数。\n\n气体中粒子的速度由麦克斯韦-玻尔兹曼速度分布描述。对于处于热平衡状态的气体，速度矢量 $\\mathbf{v} = (v_x, v_y, v_z)$ 的概率分布函数为：\n$$f(\\mathbf{v}) = \\left(\\frac{m}{2\\pi k_B T}\\right)^{3/2} \\exp\\left(-\\frac{m(v_x^2+v_y^2+v_z^2)}{2k_B T}\\right)$$\n单位体积内，速度在 $\\mathbf{v}$ 附近的无穷小范围 $d^3\\mathbf{v} = dv_x dv_y dv_z$ 内的粒子数为 $n f(\\mathbf{v})d^3\\mathbf{v}$。\n\n假设小孔位于 $xy$ 平面内。在时间 $dt$ 内，速度为 $\\mathbf{v}$ 的粒子穿过该平面上一个无穷小面积 $dA$ 的数量，等于底为 $dA$、高为 $v_z dt$ 的斜柱体中所含的粒子数。这个数量是 $(v_z dt dA) \\times (n f(\\mathbf{v}) d^3\\mathbf{v})$。我们关心的是通量，即单位时间单位面积穿过的粒子数。我们必须对所有朝向小孔运动的粒子的可能速度进行积分，即那些 $v_z > 0$ 的粒子。\n\n因此，通量密度 $J$ 由以下积分给出：\n$$J = \\int_{-\\infty}^{\\infty} dv_x \\int_{-\\infty}^{\\infty} dv_y \\int_{0}^{\\infty} dv_z \\, v_z \\, n \\, f(\\mathbf{v})$$\n代入 $n$ 和 $f(\\mathbf{v})$ 的表达式：\n$$J = n \\left(\\frac{m}{2\\pi k_B T}\\right)^{3/2} \\int_{-\\infty}^{\\infty} dv_x \\int_{-\\infty}^{\\infty} dv_y \\int_{0}^{\\infty} dv_z \\, v_z \\exp\\left(-\\frac{m(v_x^2+v_y^2+v_z^2)}{2k_B T}\\right)$$\n该积分可以分为三个部分：\n$$J = n \\left(\\frac{m}{2\\pi k_B T}\\right)^{3/2} \\left[\\int_{-\\infty}^{\\infty} \\exp\\left(-\\frac{mv_x^2}{2k_B T}\\right) dv_x\\right] \\left[\\int_{-\\infty}^{\\infty} \\exp\\left(-\\frac{mv_y^2}{2k_B T}\\right) dv_y\\right] \\left[\\int_{0}^{\\infty} v_z \\exp\\left(-\\frac{mv_z^2}{2k_B T}\\right) dv_z\\right]$$\n前两个是标准高斯积分，形式为 $\\int_{-\\infty}^{\\infty} \\exp(-ax^2)dx = \\sqrt{\\pi/a}$。当 $a = \\frac{m}{2k_B T}$ 时，每个积分的计算结果为 $\\sqrt{\\frac{2\\pi k_B T}{m}}$。\n\n第三个积分使用换元法计算。令 $u = \\frac{mv_z^2}{2k_B T}$，则 $du = \\frac{mv_z}{k_B T} dv_z$，或 $v_z dv_z = \\frac{k_B T}{m} du$。$u$ 的积分上下限为从 $0$ 到 $\\infty$。\n$$\\int_{0}^{\\infty} v_z \\exp\\left(-\\frac{mv_z^2}{2k_B T}\\right) dv_z = \\int_{0}^{\\infty} \\frac{k_B T}{m} \\exp(-u) du = \\frac{k_B T}{m} [-\\exp(-u)]_{0}^{\\infty} = \\frac{k_B T}{m} (0 - (-1)) = \\frac{k_B T}{m}$$\n将这三个积分的结果代回 $J$ 的表达式中：\n$$J = n \\left(\\frac{m}{2\\pi k_B T}\\right)^{3/2} \\left(\\sqrt{\\frac{2\\pi k_B T}{m}}\\right)^2 \\left(\\frac{k_B T}{m}\\right)$$\n$$J = n \\left(\\frac{m}{2\\pi k_B T}\\right)^{3/2} \\left(\\frac{2\\pi k_B T}{m}\\right) \\left(\\frac{k_B T}{m}\\right) = n \\left(\\frac{m}{2\\pi k_B T}\\right)^{1/2} \\left(\\frac{k_B T}{m}\\right) = n \\sqrt{\\frac{k_B T}{2\\pi m}}$$\n现在，代入 $n = P/(k_B T)$：\n$$J = \\frac{P}{k_B T} \\sqrt{\\frac{k_B T}{2\\pi m}} = \\frac{P}{\\sqrt{2\\pi m k_B T}}$$\n这就是用于计算粒子撞击表面通量的赫兹-克努森（Hertz-Knudsen）方程。\n\n离开蒸发源的通量 $J_{\\text{out}}$ 由内部的平衡条件决定。蒸发系数 $\\alpha=1$ 表示从表面蒸发的速率等于维持平衡蒸气压 $p_{\\text{eq}}$ 所需的通量。因此，$J_{\\text{out}}$ 对应于压力为 $p_{\\text{eq}}$、温度为 $T$ 的气体产生的通量。\n$$J_{\\text{out}} = \\frac{p_{\\text{eq}}}{\\sqrt{2\\pi m k_B T}}$$\n进入蒸发源的通量 $J_{\\text{in}}$ 由外部环境条件决定，其中压力为 $p$，温度假定为 $T$。\n$$J_{\\text{in}} = \\frac{p}{\\sqrt{2\\pi m k_B T}}$$\n因此，净发射通量密度为：\n$$J_{\\text{net}} = J_{\\text{out}} - J_{\\text{in}} = \\frac{p_{\\text{eq}} - p}{\\sqrt{2\\pi m k_B T}}$$\n这就是所求的表达式。\n\n### 数值计算\n题目说明环境压力可忽略不计，$p \\approx 0$。净通量表达式简化为：\n$$J_{\\text{net}} = \\frac{p_{\\text{eq}}}{\\sqrt{2\\pi m k_B T}}$$\n现在我们代入国际单位制（SI）下的给定值。\n- 压力 $p_{\\text{eq}}$:\n$$p_{\\text{eq}} = 1.0 \\times 10^{-2}\\ \\text{Torr} \\times \\frac{133.322\\ \\text{Pa}}{1\\ \\text{Torr}} = 1.33322\\ \\text{Pa}$$\n- 质量 $m$:\n$$m = 69.7\\ \\text{amu} \\times \\frac{1.66053906660 \\times 10^{-27}\\ \\text{kg}}{1\\ \\text{amu}} = 1.1573962 \\times 10^{-25}\\ \\text{kg}$$\n- 温度 $T$:\n$$T = 1100\\ \\text{K}$$\n- 玻尔兹曼常数 $k_B$:\n$$k_B \\approx 1.380649 \\times 10^{-23}\\ \\text{J K}^{-1}$$\n\n首先，我们计算分母 $\\sqrt{2\\pi m k_B T}$：\n$$2\\pi m k_B T = 2\\pi \\times (1.1573962 \\times 10^{-25}\\ \\text{kg}) \\times (1.380649 \\times 10^{-23}\\ \\text{J K}^{-1}) \\times (1100\\ \\text{K})$$\n$$2\\pi m k_B T \\approx (6.283185) \\times (1.1573962 \\times 10^{-25}) \\times (1.5187139 \\times 10^{-20})\\ \\text{kg J}$$\n$$2\\pi m k_B T \\approx 1.104426 \\times 10^{-44}\\ \\text{kg}^2 \\text{m}^2 \\text{s}^{-2}$$\n取平方根：\n$$\\sqrt{2\\pi m k_B T} \\approx \\sqrt{1.104426 \\times 10^{-44}\\ \\text{kg}^2 \\text{m}^2 \\text{s}^{-2}} \\approx 1.050917 \\times 10^{-22}\\ \\text{kg m s}^{-1}$$\n最后，我们计算净通量密度 $J_{\\text{net}}$：\n$$J_{\\text{net}} = \\frac{1.33322\\ \\text{Pa}}{1.050917 \\times 10^{-22}\\ \\text{kg m s}^{-1}} = \\frac{1.33322\\ \\text{N m}^{-2}}{1.050917 \\times 10^{-22}\\ \\text{kg m s}^{-1}}$$\n$$J_{\\text{net}} \\approx 1.268633 \\times 10^{22}\\ \\text{m}^{-2} \\text{s}^{-1}$$\n根据要求四舍五入至四位有效数字，我们得到：\n$$J_{\\text{net}} \\approx 1.269 \\times 10^{22}\\ \\text{原子}\\ \\text{m}^{-2}\\ \\text{s}^{-1}$$",
            "answer": "$$\\boxed{1.269 \\times 10^{22}}$$"
        },
        {
            "introduction": "MBE中的“分子束”之所以成为可能，是因为原子可以从源头传播到衬底而不与背景气体分子发生碰撞。本练习将运用源于气体动理论的平均自由程概念，来量化保证无碰撞输运所需的真空质量。您将计算典型超高真空（UHV）条件下的平均自由程，为MBE技术所要求的严苛真空条件提供一个切实的理论依据。",
            "id": "4142821",
            "problem": "在分子束外延（MBE）中，分子束在超高真空背景中的传输可以使用气体动理论进行建模。考虑一种稀薄的氮气背景气体，可近似为分子直径为 $d$ 的相同硬球。从理想气体定律 $p = n k_{B} T$（其中 $p$ 是压强，$n$ 是数密度，$k_{B}$ 是玻尔兹曼常数，$T$ 是温度）和硬球碰撞框架出发。在不使用任何简便公式的情况下，推导氮分子的平均自由程 $\\lambda$（用 $p$、$T$、$d$ 和基本常数表示）。然后，使用与理想稀疏硬球气体一致的空间泊松过程模型——其中沿直线路径的碰撞是每单位长度具有恒定平均发生率的独立点事件——推导氮分子在穿过路径长度 $L$ 而不发生碰撞的生存概率 $S(L)$ 的表达式。\n\n使用您推导的表达式，计算在温度 $T=300\\ \\text{K}$、压强 $p=10^{-7}\\ \\text{Torr}$（使用 $1\\ \\text{Torr}=133.322\\ \\text{Pa}$）和分子直径 $d=3.7\\times 10^{-10}\\ \\text{m}$ 条件下氮气的平均自由程。以米为单位报告平均自由程。然后计算长度为 $L=0.6\\ \\text{m}$ 的束流路径的生存概率 $S(L)$。为了过程建模，如果 $S(L) \\geq 0.99$，则将该路径定义为“有效无碰撞”。将最终生存概率 $S(L)$ 表示为小数，并将您的答案四舍五入到四位有效数字。",
            "solution": "稀薄理想气体中的分子平均自由程可以从气体动理论推导得出。对于直径为 $d$ 的相同硬球，其几何碰撞截面为 $\\sigma = \\pi d^{2}$。在数密度为 $n$ 的气体中，一个以速率 $v$ 运动的标记分子与具有速度分布的背景分子碰撞的单位时间碰撞率为\n$$\nR = n\\,\\sigma\\,\\langle v_{\\text{rel}} \\rangle,\n$$\n其中 $\\langle v_{\\text{rel}} \\rangle$ 是从麦克斯韦-玻尔兹曼速度分布中抽取的两个分子之间的平均相对速率。对于处于热平衡状态的相同分子，气体动理论中一个经过充分检验的结果是 $\\langle v_{\\text{rel}} \\rangle = \\sqrt{2}\\,\\langle v \\rangle$，其中 $\\langle v \\rangle$ 是单个分子的平均速率。平均自由时间为 $\\tau = 1/R$，平均自由程 $\\lambda$ 是在时间 $\\tau$ 内行进的距离，即\n$$\n\\lambda = \\langle v \\rangle \\tau = \\frac{\\langle v \\rangle}{n\\,\\sigma\\,\\langle v_{\\text{rel}} \\rangle} = \\frac{1}{\\sqrt{2}\\,n\\,\\sigma}.\n$$\n使用理想气体定律 $p = n k_{B} T$，我们得到标准的气体动理论表达式\n$$\n\\lambda = \\frac{k_{B} T}{\\sqrt{2}\\,\\pi d^{2}\\,p}.\n$$\n\n为了获得分子在沿直线路径行进长度 $L$ 而不发生碰撞的生存概率，我们将沿路径的碰撞事件建模为空间泊松过程，这适用于具有均匀分布的散射体和每单位长度恒定风险率的稀薄气体。在长度 $L$ 上遇到的平均碰撞次数为\n$$\n\\mu(L) = \\frac{L}{\\lambda}.\n$$\n对于泊松过程，观察到零个事件的概率是 $\\exp(-\\mu)$。因此，生存概率为\n$$\nS(L) = \\exp\\!\\left(-\\frac{L}{\\lambda}\\right).\n$$\n\n现在我们对给定的氮气背景进行数值计算。参数如下：温度 $T=300\\ \\text{K}$，压强 $p = 10^{-7}\\ \\text{Torr}$，分子直径 $d = 3.7 \\times 10^{-10}\\ \\text{m}$，以及玻尔兹曼常数 $k_{B} = 1.380649 \\times 10^{-23}\\ \\text{J K}^{-1}$。首先使用 $1\\ \\text{Torr} = 133.322\\ \\text{Pa}$ 将压强转换为帕斯卡：\n$$\np = 10^{-7}\\times 133.322\\ \\text{Pa} = 1.33322 \\times 10^{-5}\\ \\text{Pa}.\n$$\n计算碰撞截面\n$$\n\\sigma = \\pi d^{2} = \\pi \\left(3.7 \\times 10^{-10}\\ \\text{m}\\right)^{2} = \\pi \\left(1.369 \\times 10^{-19}\\ \\text{m}^{2}\\right) = 4.3008403428 \\times 10^{-19}\\ \\text{m}^{2}.\n$$\n则平均自由程为\n$$\n\\lambda = \\frac{k_{B} T}{\\sqrt{2}\\,\\sigma\\,p} = \\frac{1.380649 \\times 10^{-23}\\ \\text{J K}^{-1} \\times 300\\ \\text{K}}{\\sqrt{2}\\times 4.3008403428 \\times 10^{-19}\\ \\text{m}^{2}\\times 1.33322 \\times 10^{-5}\\ \\text{Pa}}.\n$$\n数值计算分母，\n$$\n\\sqrt{2}\\,\\sigma\\,p \\approx 1.4142135624 \\times 4.3008403428 \\times 10^{-19}\\ \\text{m}^{2} \\times 1.33322 \\times 10^{-5}\\ \\text{Pa} \\approx 8.109057 \\times 10^{-24}\\ \\text{Pa m}^{2}.\n$$\n分子为\n$$\nk_{B} T = 1.380649 \\times 10^{-23} \\times 300 = 4.141947 \\times 10^{-21}\\ \\text{Pa m}^{3}.\n$$\n因此，\n$$\n\\lambda = \\frac{4.141947 \\times 10^{-21}}{8.109057 \\times 10^{-24}}\\ \\text{m} \\approx 5.1078 \\times 10^{2}\\ \\text{m}.\n$$\n因此，平均自由程约为 $5.11 \\times 10^{2}\\ \\text{m}$。\n\n对于长度为 $L = 0.6\\ \\text{m}$ 的束流路径，生存概率为\n$$\nS(L) = \\exp\\!\\left(-\\frac{L}{\\lambda}\\right) = \\exp\\!\\left(-\\frac{0.6}{510.78}\\right) \\approx \\exp(-1.17468\\times 10^{-3}) \\approx 0.998826.\n$$\n由于 $S(L) \\approx 0.998826 \\geq 0.99$，根据所述标准，该 $0.6\\ \\text{m}$ 的束流路径是有效无碰撞的。所要求的最终答案是四舍五入到四位有效数字的生存概率：\n$$\nS(L) \\approx 0.9988.\n$$",
            "answer": "$$\\boxed{0.9988}$$"
        },
        {
            "introduction": "要实现原子级精确的薄膜生长，不仅需要稳定的通量，还需要对生长速率进行动态控制，以制造量子阱等复杂结构。这项高级实践介绍了模型预测控制（MPC），这是一种现代控制策略，它使用过程的动态模型来优化未来时间范围内的输入通量。通过建立并求解一个带约束的优化问题，您将体验到物理模型如何转化为强大的实时过程控制算法，从而弥合理论与前沿工程实践之间的鸿沟。",
            "id": "4142797",
            "problem": "考虑通过控制入射原子通量来调节分子束外延 (MBE) 的生长速率。设有效吸附通量状态由一个离散时间线性递推模型描述，该模型从一阶吸附限制动态和零阶保持器采样推导而来：从连续时间常微分方程 (ODE) $dx(t)/dt = -(x(t) - u(t))/\\tau$ 开始，其中 $x(t)$ 是有效吸附通量，$u(t)$ 是入射束通量，$\\tau$ 是时间常数，使用采样周期 $T_s$ 得到离散时间线性时不变模型 $x_{k+1} = a x_k + b u_k$，其中 $a = \\exp(-T_s/\\tau)$ 且 $b = 1 - a$。可测量的生长速率为 $y_k = c x_k$，其中 $c$ 是一个将有效通量映射到单层/秒的转换因子。\n\n控制输入序列是入射通量 $u_k$，单位为原子/平方厘米·秒，控制增量为 $\\Delta u_k = u_k - u_{k-1}$。假设在时间 $k=0$ 时处于初始稳态，使得 $x_0 = u_0$，并将调节目标定义为生长速率从初始值 $y_0 = c u_0$ 阶跃变化到一个恒定设定点 $r$（单位为单层/秒）。\n\n设计一个时域 $N = 20$ 的有限时域模型预测控制 (MPC) 问题，该问题最小化一个包含跟踪误差和输入增量代价的二次代价函数，同时受制于执行器饱和和摆率约束，并禁止在预测时域内出现超出设定点的过冲。MPC 代价函数为\n$$\nJ = \\sum_{i=1}^{N} q \\left(y_i - r\\right)^2 + \\sum_{k=0}^{N-1} r_{\\Delta} \\left(\\Delta u_k\\right)^2,\n$$\n其中 $q > 0$ 和 $r_{\\Delta} > 0$ 是标量权重。约束条件为\n- 通量界限 $u_{\\min} \\le u_k \\le u_{\\max}$，对于时域内的所有 $k$，\n- 摆率界限 $\\Delta u_{\\min} \\le \\Delta u_k \\le \\Delta u_{\\max}$，对于时域内的所有 $k$，\n- 过冲避免 $y_i \\le r$，对于所有 $i = 1,\\dots,N$。\n\n假设 $u_k = u_0 + \\sum_{j=0}^{k} \\Delta u_j$，用控制增量 $\\Delta u_0,\\dots,\\Delta u_{N-1}$ 来表示预测。将所得的约束二次优化问题以紧凑形式构建（决策变量为控制增量向量），并进行数值求解。\n\n您的程序必须为下述每个测试用例计算最优入射通量轨迹 $\\{u_k\\}_{k=0}^{N-1}$（单位为原子/平方厘米·秒），以实现指定的无过冲的生长速率阶跃变化，并计算一个布尔标志，指示在预测的生长速率轨迹中是否检测到过冲。当且仅当对于所有 $i=1,\\dots,N$，$y_i \\le r$ 在 $10^{-9}$ 的严格数值公差下成立时，过冲标志必须为 $false$。将每个通量轨迹输出为包含 $N$ 个浮点数的列表，单位为原子/平方厘米·秒。将所有测试用例的结果汇总到一行，形式为方括号括起来的逗号分隔列表。此顶层列表的每个元素本身必须是一个双元素列表：第一个元素是过冲布尔值，第二个元素是包含 $N$ 个通量值的列表。输出值中不得出现单位字符串，必须是纯数字。\n\n使用以下参数值测试套件：\n\n- 测试用例 1 (一般情况):\n  - $T_s = 0.5$ 秒,\n  - $\\tau = 2.0$ 秒,\n  - $c = 10^{-14}$ 单层/秒 每 (原子/平方厘米·秒),\n  - $u_0 = 1.0 \\times 10^{14}$ 原子/平方厘米·秒,\n  - $r = 1.2$ 单层/秒,\n  - $u_{\\min} = 0.8 \\times 10^{14}$ 原子/平方厘米·秒,\n  - $u_{\\max} = 1.5 \\times 10^{14}$ 原子/平方厘米·秒,\n  - $\\Delta u_{\\min} = -0.05 \\times 10^{14}$ 原子/平方厘米·秒,\n  - $\\Delta u_{\\max} = 0.05 \\times 10^{14}$ 原子/平方厘米·秒,\n  - $q = 1.0$,\n  - $r_{\\Delta} = 1.0 \\times 10^{-28}$。\n\n- 测试用例 2 (慢动态和严格的摆率界限):\n  - $T_s = 0.5$ 秒,\n  - $\\tau = 4.0$ 秒,\n  - $c = 10^{-14}$ 单层/秒 每 (原子/平方厘米·秒),\n  - $u_0 = 1.0 \\times 10^{14}$ 原子/平方厘米·秒,\n  - $r = 1.3$ 单层/秒,\n  - $u_{\\min} = 0.8 \\times 10^{14}$ 原子/平方厘米·秒,\n  - $u_{\\max} = 1.5 \\times 10^{14}$ 原子/平方厘米·秒,\n  - $\\Delta u_{\\min} = -0.01 \\times 10^{14}$ 原子/平方厘米·秒,\n  - $\\Delta u_{\\max} = 0.01 \\times 10^{14}$ 原子/平方厘米·秒,\n  - $q = 1.0$,\n  - $r_{\\Delta} = 1.0 \\times 10^{-28}$。\n\n- 测试用例 3 (无阶跃变化的边界情况):\n  - $T_s = 0.5$ 秒,\n  - $\\tau = 1.0$ 秒,\n  - $c = 10^{-14}$ 单层/秒 每 (原子/平方厘米·秒),\n  - $u_0 = 1.0 \\times 10^{14}$ 原子/平方厘米·秒,\n  - $r = 1.0$ 单层/秒,\n  - $u_{\\min} = 0.8 \\times 10^{14}$ 原子/平方厘米·秒,\n  - $u_{\\max} = 1.5 \\times 10^{14}$ 原子/平方厘米·秒,\n  - $\\Delta u_{\\min} = -0.05 \\times 10^{14}$ 原子/平方厘米·秒,\n  - $\\Delta u_{\\max} = 0.05 \\times 10^{14}$ 原子/平方厘米·秒,\n  - $q = 1.0$,\n  - $r_{\\Delta} = 1.0 \\times 10^{-28}$。\n\n您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表形式的结果（例如，\"[[result_case_1_boolean,[u_0,u_1,...,u_19]],[result_case_2_boolean,[...]],...]\"）。所有通量值必须以原子/平方厘米·秒为单位，表示为普通浮点数。不使用角度。不使用百分比。",
            "solution": "经评估，用户提供的问题是有效的。这是一个在过程控制系统工程领域，特别是模型预测控制 (MPC) 领域的提法恰当、有科学依据的问题。问题陈述是自洽的，其参数对于分子束外延是物理上合理的，并且目标定义清晰。我们将继续构建并解决该问题。\n\n任务是设计一个有限时域 MPC 控制器来调节 MBE 过程中的生长速率。该控制器必须最小化一个包含跟踪误差和控制代价的二次代价函数，同时遵守执行器水平、摆率的约束，并避免生长速率设定点的任何过冲。这可以构建为一个二次规划 (QP) 问题。优化的决策变量将是未来的控制增量序列 $\\Delta u_k$。\n\n令预测时域 $N$ 内的控制增量向量表示为 $\\Delta \\mathbf{U} = [\\Delta u_0, \\Delta u_1, \\dots, \\Delta u_{N-1}]^T$。我们的目标是用这个向量来表示代价函数和约束。\n\n**1. 预测模型构建**\n\n系统由线性时不变 (LTI) 状态空间模型描述：\n$$\nx_{k+1} = a x_k + b u_k \\\\\ny_k = c x_k\n$$\n其中 $a = \\exp(-T_s/\\tau)$ 且 $b = 1-a$。系统初始处于稳态，其中对于 $k  0$，入射通量为 $u_k = u_{ss}$。问题将此初始通量指定为 $u_0$。为避免歧义，我们称此初始稳态值为 $u_{ss}$。因此，初始状态为 $x_0 = u_{ss}$，这意味着初始生长速率为 $y_0 = c x_0 = c u_{ss}$，我们将其表示为 $y_{ss}$。\n\n对于 $k \\ge 0$ 的未来控制输入 $u_k$ 由控制增量序列 $\\Delta u_k = u_k - u_{k-1}$ 决定，从值 $u_{-1} = u_{ss}$ 开始。问题给出的关系是 $u_k = u_{ss} + \\sum_{j=0}^{k} \\Delta u_j$。这与 $k \\ge 1$ 时的 $u_k = u_{k-1} + \\Delta u_k$ 以及 $u_0 = u_{ss} + \\Delta u_0$ 是一致的。\n\n未来时间步 $i$ ($i=1, \\dots, N$) 的状态可以通过展开递推关系找到：\n$$\nx_i = a^i x_0 + \\sum_{k=0}^{i-1} a^{i-1-k} b u_k\n$$\n代入 $x_0 = u_{ss}$ 和 $u_k = u_{ss} + \\sum_{j=0}^{k} \\Delta u_j$，经过代数操作和求和重新排序，我们得到状态 $x_i$ 和控制增量之间的直接关系：\n$$\nx_i = u_{ss} + \\sum_{j=0}^{i-1} (1 - a^{i-j}) \\Delta u_j\n$$\n相应的输出预测为 $y_i = c x_i$：\n$$\ny_i = c u_{ss} + c \\sum_{j=0}^{i-1} (1 - a^{i-j}) \\Delta u_j\n$$\n我们可以将整个预测输出序列 $\\mathbf{Y} = [y_1, y_2, \\dots, y_N]^T$ 表示为紧凑的矩阵形式：\n$$\n\\mathbf{Y} = \\mathbf{1} y_{ss} + \\mathbf{S}_{\\Delta} \\Delta \\mathbf{U}\n$$\n其中 $\\mathbf{1}$ 是一个 $N \\times 1$ 的全一向量，$\\mathbf{S}_{\\Delta}$ 是一个 $N \\times N$ 的下三角矩阵，其元素（行 $i$ 和列 $j$ 使用从0开始的索引）由下式给出：\n$$\n(\\mathbf{S}_{\\Delta})_{ij} = \\begin{cases} c(1 - a^{i-j+1})  \\text{if } j \\le i \\\\ 0  \\text{if } j  i \\end{cases}\n$$\n\n**2. 二次规划 (QP) 代价函数**\n\n要最小化的代价函数是：\n$$\nJ = \\sum_{i=1}^{N} q (y_i - r)^2 + \\sum_{k=0}^{N-1} r_{\\Delta} (\\Delta u_k)^2\n$$\n令 $\\mathbf{R}$ 是一个每个元素都是设定点 $r$ 的 $N \\times 1$ 向量。代价可以写成向量形式：\n$$\nJ = q (\\mathbf{Y} - \\mathbf{R})^T (\\mathbf{Y} - \\mathbf{R}) + r_{\\Delta} \\Delta \\mathbf{U}^T \\mathbf{I} \\Delta \\mathbf{U}\n$$\n代入预测模型 $\\mathbf{Y} = \\mathbf{1} y_{ss} + \\mathbf{S}_{\\Delta} \\Delta \\mathbf{U}$：\n$$\nJ = q (\\mathbf{S}_{\\Delta} \\Delta \\mathbf{U} + \\mathbf{1} y_{ss} - \\mathbf{R})^T (\\mathbf{S}_{\\Delta} \\Delta \\mathbf{U} + \\mathbf{1} y_{ss} - \\mathbf{R}) + r_{\\Delta} \\Delta \\mathbf{U}^T \\Delta \\mathbf{U}\n$$\n展开此表达式，我们得到标准的 QP 代价形式 $\\frac{1}{2}\\Delta \\mathbf{U}^T \\mathbf{H} \\Delta \\mathbf{U} + \\mathbf{f}^T \\Delta \\mathbf{U} + \\text{const}$。常数项不影响最小值的位置，可以忽略。\nHessian 矩阵 $\\mathbf{H}$ 是：\n$$\n\\mathbf{H} = 2 (q \\mathbf{S}_{\\Delta}^T \\mathbf{S}_{\\Delta} + r_{\\Delta} \\mathbf{I})\n$$\n线性项向量 $\\mathbf{f}$ 是：\n$$\n\\mathbf{f} = 2 q \\mathbf{S}_{\\Delta}^T (\\mathbf{1} y_{ss} - \\mathbf{R})\n$$\n由于 $q > 0$ 和 $r_{\\Delta} > 0$，Hessian 矩阵 $\\mathbf{H}$ 是对称正定的，这确保了 QP 问题是凸的并且有唯一的最小值。\n\n**3. 线性约束构建**\n\n所有约束必须表示为 $\\mathbf{A}_{ineq} \\Delta \\mathbf{U} \\le \\mathbf{b}_{ineq}$ 形式的线性不等式。\n\n- **摆率约束**：$\\Delta u_{\\min} \\le \\Delta u_k \\le \\Delta u_{\\max}$，对于 $k=0, \\dots, N-1$。这些是关于决策变量的箱式约束：\n  $$\n  \\mathbf{I} \\Delta \\mathbf{U} \\le \\mathbf{1} \\Delta u_{\\max} \\\\\n  -\\mathbf{I} \\Delta \\mathbf{U} \\le -\\mathbf{1} \\Delta u_{\\min}\n  $$\n- **通量（执行器）约束**：$u_{\\min} \\le u_k \\le u_{\\max}$，对于 $k=0, \\dots, N-1$。输入轨迹 $\\mathbf{U} = [u_0, \\dots, u_{N-1}]^T$ 通过 $\\mathbf{U} = \\mathbf{1} u_{ss} + \\mathbf{L} \\Delta \\mathbf{U}$ 与 $\\Delta \\mathbf{U}$ 相关，其中 $\\mathbf{L}$ 是一个 $N \\times N$ 的全一下三角矩阵。约束为：\n  $$\n  \\mathbf{L} \\Delta \\mathbf{U} \\le \\mathbf{1} (u_{\\max} - u_{ss}) \\\\\n  -\\mathbf{L} \\Delta \\mathbf{U} \\le -\\mathbf{1} (u_{\\min} - u_{ss})\n  $$\n- **过冲避免约束**：$y_i \\le r$，对于 $i=1, \\dots, N$。向量形式为 $\\mathbf{Y} \\le \\mathbf{R}$。代入预测模型：\n  $$\n  \\mathbf{1} y_{ss} + \\mathbf{S}_{\\Delta} \\Delta \\mathbf{U} \\le \\mathbf{R} \\implies \\mathbf{S}_{\\Delta} \\Delta \\mathbf{U} \\le \\mathbf{R} - \\mathbf{1} y_{ss}\n  $$\n\n这 $5N$ 个线性不等式可以堆叠成一个单一的矩阵不等式 $\\mathbf{A}_{ineq} \\Delta \\mathbf{U} \\le \\mathbf{b}_{ineq}$，其中：\n$$\n\\mathbf{A}_{ineq} = \\begin{pmatrix} \\mathbf{I} \\\\ -\\mathbf{I} \\\\ \\mathbf{L} \\\\ -\\mathbf{L} \\\\ \\mathbf{S}_{\\Delta} \\end{pmatrix}, \\quad\n\\mathbf{b}_{ineq} = \\begin{pmatrix} \\mathbf{1} \\Delta u_{\\max} \\\\ -\\mathbf{1}\\Delta u_{\\min} \\\\ \\mathbf{1}(u_{\\max} - u_{ss}) \\\\ \\mathbf{1}(u_{ss} - u_{\\min}) \\\\ \\mathbf{R} - \\mathbf{1}y_{ss} \\end{pmatrix}\n$$\n\n**4. 数值解**\n\n完整的问题是最小化 $\\frac{1}{2}\\Delta \\mathbf{U}^T \\mathbf{H} \\Delta \\mathbf{U} + \\mathbf{f}^T \\Delta \\mathbf{U}$，约束条件为 $\\mathbf{A}_{ineq} \\Delta \\mathbf{U} \\le \\mathbf{b}_{ineq}$。这是一个标准的 QP 问题，可以使用数值优化库高效求解。我们将使用 `scipy.optimize.minimize` 函数和 'SLSQP'（序列最小二乘规划）方法，该方法适用于约束非线性（因此也适用于二次）优化。\n\n一旦找到最优控制增量序列 $\\Delta \\mathbf{U}^*$，最优通量轨迹通过 $\\mathbf{U}^* = \\mathbf{1} u_{ss} + \\mathbf{L} \\Delta \\mathbf{U}^*$ 重构。然后，预测的输出轨迹为 $\\mathbf{Y}^* = \\mathbf{1} y_{ss} + \\mathbf{S}_{\\Delta} \\Delta \\mathbf{U}^*$，并以 $10^{-9}$ 的公差检查其相对于设定点 $r$ 是否有超调。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import minimize\nimport sys\n\n# Ensure Python version is 3.12, as float-to-string conversion behavior can vary.\nif sys.version_info.major != 3 or sys.version_info.minor != 12:\n    # Using a warning instead of an error to allow for minor version differences\n    # if they don't affect the output format.\n    # print(\"Warning: This script is designed for Python 3.12. Output format may differ.\", file=sys.stderr)\n    pass\n\n\ndef solve_mpc_case(params):\n    \"\"\"\n    Solves one instance of the MBE growth rate control problem.\n    \"\"\"\n    Ts = params[\"Ts\"]\n    tau = params[\"tau\"]\n    c = params[\"c\"]\n    u0 = params[\"u0\"]\n    r = params[\"r\"]\n    u_min = params[\"u_min\"]\n    u_max = params[\"u_max\"]\n    du_min = params[\"du_min\"]\n    du_max = params[\"du_max\"]\n    q = params[\"q\"]\n    r_delta = params[\"r_delta\"]\n    N = 20\n    \n    # Model parameters\n    a = np.exp(-Ts / tau)\n    uss = u0\n    yss = c * uss\n\n    # Build prediction matrices\n    # S_delta: maps delta_u to changes in y\n    S_delta = np.zeros((N, N))\n    for i in range(N):\n        for j in range(i + 1):\n            S_delta[i, j] = c * (1 - a**(i - j + 1))\n            \n    # L: maps delta_u to u by cumulative sum\n    L = np.tril(np.ones((N, N)))\n    \n    # Formulate the QP problem: min 1/2 * x'Hx + f'x\n    # H: Hessian matrix\n    H = 2 * (q * (S_delta.T @ S_delta) + r_delta * np.identity(N))\n    \n    # f: Linear term vector\n    E_vec = np.full(N, yss - r)\n    f = 2 * q * (S_delta.T @ E_vec)\n    \n    # Objective function for scipy.optimize.minimize\n    def objective(delta_u):\n        # We can drop the constant term from the full cost function\n        cost = 0.5 * delta_u.T @ H @ delta_u + f.T @ delta_u\n        return cost\n        \n    # Assemble linear inequality constraints: A_ineq * x = b_ineq\n    # This is equivalent to b_ineq - A_ineq * x = 0 for the solver interface.\n    \n    # 1. Slew rate constraints: du_min = delta_u = du_max\n    A1 = np.identity(N)\n    b1 = np.full(N, du_max)\n    A2 = -np.identity(N)\n    b2 = np.full(N, -du_min)\n    \n    # 2. Flux bounds: u_min = u = u_max\n    # u = uss + L * delta_u = L * delta_u = u_max - uss\n    #                         -L * delta_u = uss - u_min\n    A3 = L\n    b3 = np.full(N, u_max - uss)\n    A4 = -L\n    b4 = np.full(N, uss - u_min)\n    \n    # 3. Overshoot constraint: y = r\n    # y = yss + S_delta * delta_u = S_delta * delta_u = r - yss\n    A5 = S_delta\n    b5 = np.full(N, r - yss)\n    \n    # Combine into a single matrix inequality\n    A_ineq = np.vstack([A1, A2, A3, A4, A5])\n    b_ineq = np.concatenate([b1, b2, b3, b4, b5])\n    \n    constraints = [{'type': 'ineq', 'fun': lambda delta_u: b_ineq - A_ineq @ delta_u}]\n    \n    # Initial guess for the solver\n    delta_u_initial = np.zeros(N)\n    \n    # Solve the QP\n    result = minimize(objective, delta_u_initial, method='SLSQP', constraints=constraints, options={'disp': False})\n    \n    if not result.success:\n        raise RuntimeError(f\"Optimization failed: {result.message}\")\n        \n    delta_u_opt = result.x\n    \n    # Reconstruct optimal input and output trajectories\n    u_opt = uss + L @ delta_u_opt\n    y_opt = yss + S_delta @ delta_u_opt\n    \n    # Check for overshoot with a tolerance of 1e-9\n    overshoot_detected = np.any(y_opt  r + 1e-9)\n    \n    return [overshoot_detected, u_opt.tolist()]\n\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"Ts\": 0.5, \"tau\": 2.0, \"c\": 1e-14, \"u0\": 1.0e14, \"r\": 1.2,\n            \"u_min\": 0.8e14, \"u_max\": 1.5e14, \"du_min\": -0.05e14, \"du_max\": 0.05e14,\n            \"q\": 1.0, \"r_delta\": 1.0e-28\n        },\n        {\n            \"Ts\": 0.5, \"tau\": 4.0, \"c\": 1e-14, \"u0\": 1.0e14, \"r\": 1.3,\n            \"u_min\": 0.8e14, \"u_max\": 1.5e14, \"du_min\": -0.01e14, \"du_max\": 0.01e14,\n            \"q\": 1.0, \"r_delta\": 1.0e-28\n        },\n        {\n            \"Ts\": 0.5, \"tau\": 1.0, \"c\": 1e-14, \"u0\": 1.0e14, \"r\": 1.0,\n            \"u_min\": 0.8e14, \"u_max\": 1.5e14, \"du_min\": -0.05e14, \"du_max\": 0.05e14,\n            \"q\": 1.0, \"r_delta\": 1.0e-28\n        },\n    ]\n\n    results = []\n    for case_params in test_cases:\n        result = solve_mpc_case(case_params)\n        results.append(result)\n\n    # Format the final output string according to the spec\n    # e.g., \"[[false,[...]],[true,[...]]]\"\n    result_strings = []\n    for res_bool, res_list in results:\n        bool_str = str(res_bool).lower()\n        # Python's default float-to-string for large numbers may not use\n        # scientific notation. We use str() to get the required \"plain\" format.\n        list_str = '[' + ','.join(map(str, res_list)) + ']'\n        result_strings.append(f\"[{bool_str},{list_str}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(result_strings)}]\")\n\nsolve()\n```"
        }
    ]
}