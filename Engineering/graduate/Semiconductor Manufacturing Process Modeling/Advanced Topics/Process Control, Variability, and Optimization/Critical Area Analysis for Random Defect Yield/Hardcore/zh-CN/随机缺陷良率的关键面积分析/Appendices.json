{
    "hands_on_practices": [
        {
            "introduction": "理解随机缺陷良率的核心在于将缺陷尺寸分布与几何关键区域模型相结合。本练习将引导你从第一性原理出发，通过对缺陷半径的概率分布进行积分，计算平均故障数，最终推导出闭合形式的良率表达式 ()。这个基本功的训练对于掌握更复杂的良率模型至关重要。",
            "id": "4117668",
            "problem": "半导体晶圆上一段长度为 $L$ 的长互连线段，容易因随机出现的半径为 $r \\ge 0$ 的圆形颗粒缺陷而导致开路故障。假设缺陷在平面上根据平均面密度为 $D$（单位面积的缺陷数）的均匀泊松点过程（PPP）出现，并且每个缺陷的半径 $r$ 是独立同分布的，其概率密度函数为 $p(r) = \\lambda \\exp(-\\lambda r)$（其中 $r \\ge 0$），$\\lambda  0$ 是指数分布的率参数。对于一条窄互连线，其宽度与所关注的缺陷尺寸相比很小，半径为 $r$ 的缺陷的开路故障临界区可以通过几何走廊模型近似为\n$$A_c^{\\text{open}}(r) = 2 r L,$$\n该模型代表了会导致线路被切断的缺陷中心位置的度量。忽略末端效应，并假设独立致命缺陷风险的线性叠加，请从第一性原理推导缺陷限制产率 $Y$（即线路中致命缺陷数量为零的概率）作为 $D$、$L$ 和 $\\lambda$ 的函数的解析表达式。请将最终答案表示为单个闭式表达式，无需进行数值计算或四舍五入。",
            "solution": "该问题要求推导长互连线的缺陷限制产率 $Y$。该互连线受到随机位置和尺寸的颗粒缺陷导致的故障影响。产率定义为线路中致命缺陷数量为零的概率。\n\n推导过程基于所提供的模型从第一性原理进行。\n\n首先，我们已知缺陷中心位置在平面上遵循一个均匀泊松点过程（PPP），其平均面密度为 $D$。PPP 的一个关键性质是，在任何给定面积 $A$ 的区域内发现的点数 $N$ 是一个服从泊松分布的随机变量，其均值为 $\\mu = D A$。因此，在该区域中发现 $k$ 个点的概率为：\n$$P(N=k) = \\frac{\\mu^k \\exp(-\\mu)}{k!} = \\frac{(DA)^k \\exp(-DA)}{k!}$$\n\n其次，并非每个缺陷都是致命的。一个缺陷只有当其中心位于特定的“临界区”内时，才会导致开路故障。问题指出，缺陷的尺寸，即其半径 $r$，是一个随机变量。开路故障的临界区 $A_c^{\\text{open}}(r)$ 是这个随机半径 $r$ 的函数。问题给出的函数是：\n$$A_c^{\\text{open}}(r) = 2 r L$$\n其中 $L$ 是互连线的长度。\n\n第三，缺陷半径本身也是随机变量，根据指数分布独立同分布（i.i.d.），其概率密度函数（PDF）为：\n$$p(r) = \\lambda \\exp(-\\lambda r) \\quad \\text{for } r \\ge 0$$\n其中 $\\lambda  0$ 是率参数。\n\n现在，求解产率的问题变成了确定*致命*缺陷的统计特性。当一个均匀 PPP 被一个独立过程“筛选”（在本例中，即只保留致命的缺陷）时，所得到的致命缺陷过程也是一个泊松过程。致命缺陷的数量，我们称之为 $N_f$，遵循一个均值为 $\\mu_f$ 的泊松分布。产率 $Y$ 是致命缺陷数量为零的概率，即 $P(N_f=0)$。对于泊松分布，这个概率是：\n$$Y = P(N_f=0) = \\frac{\\mu_f^0 \\exp(-\\mu_f)}{0!} = \\exp(-\\mu_f)$$\n\n问题的核心是求出致命缺陷的平均数 $\\mu_f$。这个量通常被称为“平均故障数”。它可以通过将缺陷密度 $D$ 乘以*平均临界区* $\\langle A_c \\rangle$ 来计算。平均临界区是临界区函数 $A_c^{\\text{open}}(r)$ 对缺陷半径的概率分布 $p(r)$ 进行平均的结果。\n$$\\mu_f = D \\cdot \\langle A_c \\rangle$$\n平均临界区通过期望积分求得：\n$$\\langle A_c \\rangle = E[A_c^{\\text{open}}(r)] = \\int_{0}^{\\infty} A_c^{\\text{open}}(r) p(r) dr$$\n\n我们将给定的 $A_c^{\\text{open}}(r)$ 和 $p(r)$ 的表达式代入此积分：\n$$\\langle A_c \\rangle = \\int_{0}^{\\infty} (2 r L) (\\lambda \\exp(-\\lambda r)) dr$$\n\n我们可以从积分中提出常数 $2$、$L$ 和 $\\lambda$：\n$$\\langle A_c \\rangle = 2 L \\lambda \\int_{0}^{\\infty} r \\exp(-\\lambda r) dr$$\n\n剩下的积分 $\\int_{0}^{\\infty} r \\exp(-\\lambda r) dr$ 是一个标准形式。我们可以用分部积分法 $\\int u dv = uv - \\int v du$ 来求解。\n令 $u = r$ 且 $dv = \\exp(-\\lambda r) dr$。\n则 $du = dr$ 且 $v = -\\frac{1}{\\lambda}\\exp(-\\lambda r)$。\n\n$$\\int_{0}^{\\infty} r \\exp(-\\lambda r) dr = \\left[ r \\left(-\\frac{1}{\\lambda}\\exp(-\\lambda r)\\right) \\right]_{0}^{\\infty} - \\int_{0}^{\\infty} \\left(-\\frac{1}{\\lambda}\\exp(-\\lambda r)\\right) dr$$\n第一项，即边界项，计算结果为 $0$：\n$$\\lim_{r \\to \\infty} \\left(-\\frac{r}{\\lambda \\exp(\\lambda r)}\\right) - \\left(0 \\cdot \\left(-\\frac{1}{\\lambda}\\exp(0)\\right)\\right) = 0 - 0 = 0$$\n根据洛必达法则，无穷远处的极限为 $0$。\n\n第二项变为：\n$$\\int_{0}^{\\infty} \\frac{1}{\\lambda}\\exp(-\\lambda r) dr = \\frac{1}{\\lambda} \\int_{0}^{\\infty} \\exp(-\\lambda r) dr = \\frac{1}{\\lambda} \\left[ -\\frac{1}{\\lambda}\\exp(-\\lambda r) \\right]_{0}^{\\infty}$$\n$$\\frac{1}{\\lambda} \\left[ 0 - \\left(-\\frac{1}{\\lambda}\\right) \\right] = \\frac{1}{\\lambda} \\left( \\frac{1}{\\lambda} \\right) = \\frac{1}{\\lambda^2}$$\n因此，该积分的值为 $\\frac{1}{\\lambda^2}$。\n\n或者，我们认识到 PDF 为 $p(r) = \\lambda \\exp(-\\lambda r)$ 的指数分布的均值为 $E[r] = \\frac{1}{\\lambda}$。我们需要计算的积分与此相关。\n$$E[r] = \\int_{0}^{\\infty} r p(r) dr = \\int_{0}^{\\infty} r (\\lambda \\exp(-\\lambda r)) dr = \\lambda \\int_{0}^{\\infty} r \\exp(-\\lambda r) dr$$\n由于 $E[r] = \\frac{1}{\\lambda}$，我们有：\n$$\\frac{1}{\\lambda} = \\lambda \\int_{0}^{\\infty} r \\exp(-\\lambda r) dr$$\n$$\\implies \\int_{0}^{\\infty} r \\exp(-\\lambda r) dr = \\frac{1}{\\lambda^2}$$\n\n现在我们将此结果代回到平均临界区 $\\langle A_c \\rangle$ 的表达式中：\n$$\\langle A_c \\rangle = 2 L \\lambda \\left( \\frac{1}{\\lambda^2} \\right) = \\frac{2L}{\\lambda}$$\n\n接下来，我们计算致命缺陷的平均数 $\\mu_f$：\n$$\\mu_f = D \\cdot \\langle A_c \\rangle = D \\cdot \\frac{2L}{\\lambda} = \\frac{2DL}{\\lambda}$$\n\n最后，我们将 $\\mu_f$ 的这个表达式代入产率 $Y$ 的公式中：\n$$Y = \\exp(-\\mu_f) = \\exp\\left(-\\frac{2DL}{\\lambda}\\right)$$\n\n这就是缺陷限制产率关于给定参数 $D$、$L$ 和 $\\lambda$ 的解析表达式。",
            "answer": "$$\n\\boxed{\\exp\\left(-\\frac{2DL}{\\lambda}\\right)}\n$$"
        },
        {
            "introduction": "现实世界中的芯片良率不仅受灾难性缺陷的影响，还受到工艺参数连续波动的制约。本练习将探讨如何构建一个更全面的良率模型，该模型同时考虑了灾难性的开路缺陷和由接触电阻等参数变化引起的参数筛选 ()。通过这个实践，你将学会如何将物理上独立的失效机制（离散的泊松缺陷和连续的对数正态参数分布）在统计上正确地结合起来，以估算最终的出货良率。",
            "id": "4117703",
            "problem": "分析一个先进工艺节点的逻辑芯片的随机缺陷和参数筛选。假设以下基于物理原理的依据。\n\n- 导致灾难性开路的空间随机致命缺陷被建模为芯片上的均匀泊松点过程。如果根据关键区域分析，每个芯片上导致开路的缺陷命中的期望数量为 $\\lambda$，那么在芯片上观察到零个此类命中的概率为 $\\exp(-\\lambda)$。\n- 已执行关键区域分析，通过汇总逐层贡献并对缺陷尺寸分布进行积分，得到每个芯片上导致开路的缺陷命中的期望计数为 $\\lambda = 0.25$。\n- 单个接触点的接触电阻 $R$ (单位为 $\\Omega$) 服从对数正态分布：$\\ln R \\sim \\mathcal{N}(\\mu,\\sigma^{2})$，其参数为 $\\mu = \\ln(10)$ 和 $\\sigma = 0.25$。同一芯片上的接触点是独立同分布的 (i.i.d.)。\n- 最终电学测试对每个芯片进行简单的筛选，方法是随机均匀地选择 $N=2$ 个接触点，如果任何一个被选中的接触点的电阻高于筛选阈值 $R_{s} = 15\\,\\Omega$，则标记该芯片。与灾难性开路随机缺陷相关的事件和与参数筛选相关的事件是相互独立的。\n\n仅使用灾难性缺陷的泊松模型的基本规则、独立事件的基本概率，以及对数正态分布和标准正态分布的累积分布函数 (CDF) 的性质，确定出货良率，其定义为一个芯片既没有灾难性开路命中又通过筛选测试的概率。\n\n以下哪项是出货良率？\n\nA) $0.779$\n\nB) $0.948$\n\nC) $0.738$\n\nD) $0.699$",
            "solution": "问题陈述已经过验证，被认为是科学上合理的、问题定义明确的且客观的。它包含了所有必要信息，可以根据概率论和半导体良率建模的既定原则推导出唯一解。\n\n问题要求计算出货良率，其定义为一个芯片既没有灾难性开路命中又通过参数筛选测试的概率。设 $Y_{\\text{ship}}$ 为出货良率。设 $E_{\\text{cat}}$ 为芯片没有灾难性开路命中的事件。设 $E_{\\text{screen}}$ 为芯片通过筛选测试的事件。出货良率是这两个事件交集的概率：\n$$\nY_{\\text{ship}} = P(E_{\\text{cat}} \\cap E_{\\text{screen}})\n$$\n问题陈述指出，与灾难性缺陷相关的事件和与参数筛选相关的事件是相互独立的。因此，交集的概率是它们各自概率的乘积：\n$$\nY_{\\text{ship}} = P(E_{\\text{cat}}) \\times P(E_{\\text{screen}})\n$$\n我们将分别计算这两个概率。\n\n首先，我们计算芯片没有灾难性开路命中的概率 $P(E_{\\text{cat}})$。这对应于随机缺陷良率，我们可以表示为 $Y_{\\text{rand}}$。此类缺陷的数量被建模为泊松过程，每个芯片的期望命中数为 $\\lambda$。观察到 $k$ 个命中的概率由泊松概率质量函数给出 $P(k) = \\frac{\\lambda^k e^{-\\lambda}}{k!}$。观察到零个命中 ($k=0$) 的概率是：\n$$\nY_{\\text{rand}} = P(E_{\\text{cat}}) = P(k=0) = \\frac{\\lambda^0 e^{-\\lambda}}{0!} = e^{-\\lambda}\n$$\n鉴于导致开路的期望命中计数为 $\\lambda = 0.25$，该良率分量为：\n$$\nY_{\\text{rand}} = \\exp(-0.25) \\approx 0.77880078\n$$\n\n接下来，我们计算芯片通过筛选测试的概率 $P(E_{\\text{screen}})$。这是参数良率，我们可以表示为 $Y_{\\text{param}}$。该测试包括测量随机均匀选择的 $N=2$ 个接触点的电阻。如果*任何*一个被选中的接触点的电阻 $R$ 大于筛选阈值 $R_s = 15\\,\\Omega$，则该芯片被标记（测试失败）。因此，一个芯片当且仅当*所有*被选中的接触点的电阻都小于或等于该阈值时，才通过测试。\n设 $p$ 为单个随机选择的接触点通过此测试的概率，即 $p = P(R \\le R_s)$。问题陈述指出，接触点是独立同分布的 (i.i.d.)。因此，$N=2$ 个被选中的接触点都通过测试的概率是：\n$$\nY_{\\text{param}} = P(E_{\\text{screen}}) = p^N = p^2\n$$\n为了求出 $Y_{\\text{param}}$，我们必须首先计算 $p$。接触电阻 $R$ 服从对数正态分布，因此其自然对数 $\\ln R$ 服从正态分布 $\\mathcal{N}(\\mu, \\sigma^2)$，参数为 $\\mu = \\ln(10)$ 和 $\\sigma = 0.25$。\n概率 $p$ 为：\n$$\np = P(R \\le R_s) = P(R \\le 15)\n$$\n由于对数函数是单调递增的，这个不等式等价于：\n$$\np = P(\\ln R \\le \\ln 15)\n$$\n为了求出这个概率，我们对正态变量 $\\ln R$ 进行标准化。设 $Z$ 为一个标准正态变量，$Z \\sim \\mathcal{N}(0, 1)$。标准化公式为 $Z = \\frac{\\ln R - \\mu}{\\sigma}$。\n$$\np = P\\left(\\frac{\\ln R - \\mu}{\\sigma} \\le \\frac{\\ln 15 - \\mu}{\\sigma}\\right) = P\\left(Z \\le \\frac{\\ln 15 - \\ln 10}{0.25}\\right)\n$$\n使用对数性质 $\\ln a - \\ln b = \\ln(a/b)$：\n$$\np = P\\left(Z \\le \\frac{\\ln(15/10)}{0.25}\\right) = P\\left(Z \\le \\frac{\\ln(1.5)}{0.25}\\right)\n$$\n这个概率由标准正态分布的累积分布函数 (CDF) 给出，记为 $\\Phi(z)$。\n我们来计算参数 $z$：\n$$\nz = \\frac{\\ln(1.5)}{0.25} \\approx \\frac{0.405465}{0.25} \\approx 1.62186\n$$\n所以，$p = \\Phi(1.62186)$。使用标准正态分布表或计算器，我们得到：\n$$\np \\approx 0.94758\n$$\n现在我们可以计算参数良率 $Y_{\\text{param}}$：\n$$\nY_{\\text{param}} = p^2 \\approx (0.94758)^2 \\approx 0.89791\n$$\n\n最后，我们可以通过将两个良率分量相乘来计算总出货良率 $Y_{\\text{ship}}$：\n$$\nY_{\\text{ship}} = Y_{\\text{rand}} \\times Y_{\\text{param}} \\approx 0.77880 \\times 0.89791 \\approx 0.69931\n$$\n四舍五入到三位小数，出货良率为 $0.699$。\n\n现在我们评估每个选项：\n\nA) $0.779$\n这个值约等于 $Y_{\\text{rand}} = \\exp(-0.25) \\approx 0.7788$。如果完全忽略参数筛选良率，即有效假设 $Y_{\\text{param}}=1$，则会得到此结果。这是一个不完整的计算。**错误**。\n\nB) $0.948$\n这个值约等于 $p = P(R \\le 15) \\approx 0.9476$。这是单个接触点通过电阻测试的概率。如果忽略灾难性缺陷良率 ($Y_{\\text{rand}}=1$) 并且假设筛选测试只涉及一个接触点 ($N=1$)，则会得到此结果。这在多个方面都是不正确的。**错误**。\n\nC) $0.738$\n这个值约等于 $Y_{\\text{rand}} \\times p \\approx 0.7788 \\times 0.9476 \\approx 0.7380$。如果在正确计算了灾难性良率和单接触点通过概率后，错误地假设参数筛选只测试了 $N=1$ 个接触点，而不是规定的 $N=2$ 个，则会得到此结果。**错误**。\n\nD) $0.699$\n这个值与我们计算出的出货良率 $Y_{\\text{ship}} \\approx 0.69931$ 在四舍五入到三位小数后相符。该计算正确地结合了灾难性泊松良率模型和基于 $N=2$ 个独立接触点的对数正态分布的参数良率。**正确**。",
            "answer": "$$\\boxed{D}$$"
        },
        {
            "introduction": "对于现代集成电路中极其复杂的布线，通过解析方法计算关键区域是不可行的，因此必须依赖蒙特卡洛等计算方法。本练习介绍了一种高级的计算技术——分层抽样，用于提高关键区域分析（CAA）的效率 ()。你将通过编程实践，对比分层抽样与简单随机抽样的方差，从而理解为何这种方差缩减技术对于在不同线密度的区域中高效估算整体敏感区域至关重要。",
            "id": "4117689",
            "problem": "考虑一个矩形集成电路金属布线，为了进行随机缺陷成品率的关键区域分析（CAA），该布线被划分为有限数量的、具有不同线密度的不相交的层（区域）。假设缺陷中心在布线表面上均匀随机分布，如果一个半径为 $r$ 的缺陷的中心落入由导电线中心线与一个半径为 $r$ 的圆盘的几何闵可夫斯基和所定义的“敏感区域”内，则该缺陷将导致失效（一个“致命”事件）。在半导体成品率建模中广泛使用的小缺陷、细线近似下，第 $h$ 层中的敏感区域分数可近似为\n$$\np_h \\approx \\min\\{1,\\,2\\,r\\,L_h\\},\n$$\n其中 $L_h$ 是第 $h$ 层中单位面积的线长（线密度），$r$ 是缺陷半径，两者均以微米（$\\mu\\mathrm{m}$）为单位。那么第 $h$ 层的敏感区域为 $A_{c,h} \\approx p_h\\,A_h$，其中 $A_h$ 是该层的面积。令 $A_{\\text{tot}} = \\sum_{h=1}^H A_h$，$W_h = A_h/A_{\\text{tot}}$，且 $p = \\sum_{h=1}^H W_h\\,p_h$ 表示总体敏感区域分数。对缺陷中心位置进行采样，相当于抽取一个伯努利随机变量 $X$，如果中心落在敏感区域内，则 $X$ 等于 1，否则等于 0。\n\n你需要实现分层抽样来估计总体敏感区域分数 $p$，并将其方差与简单随机抽样（SRS）的方差进行比较。在总样本量为 $n$ 的简单随机抽样中，估计量 $\\hat{p}_{\\text{SRS}}$ 是样本均值，其方差为 $p\\,(1-p)/n$。在分层抽样中，你将 $n$ 个样本划分为各层的非负实数分配 $n_h$，满足 $\\sum_{h=1}^H n_h = n$，并通过各层样本均值的加权组合来估计 $p$。分层估计量的方差为\n$$\n\\operatorname{Var}(\\hat{p}_{\\text{strat}}) = \\sum_{h=1}^H \\frac{W_h^2\\,\\sigma_h^2}{n_h},\n$$\n其中 $\\sigma_h^2 = p_h\\,(1-p_h)$。对于固定的 $n$，使 $\\operatorname{Var}(\\hat{p}_{\\text{strat}})$ 最小化的最优（Neyman）分配与层的敏感区域因子 $W_h\\,\\sigma_h$ 成正比，即 $n_h^\\star \\propto W_h\\,\\sigma_h$。\n\n任务：\n- 对于每个测试用例，使用给定的近似从 $L_h$ 和 $r$ 计算 $p_h$，然后计算 $W_h$、$p$、$\\operatorname{Var}(\\hat{p}_{\\text{SRS}})$，以及在连续最优分配 $n_h^\\star = n\\,W_h\\,\\sigma_h/\\sum_{j=1}^H W_j\\,\\sigma_j$ 下的最优分层方差 $\\operatorname{Var}(\\hat{p}_{\\text{strat,opt}})$（不要将 $n_h^\\star$ 四舍五入为整数）。最后，计算方差比 $\\rho = \\operatorname{Var}(\\hat{p}_{\\text{strat,opt}})/\\operatorname{Var}(\\hat{p}_{\\text{SRS}})$。\n- 将所有概率表示为小数值（不带百分号），面积以平方微米（$\\mu\\mathrm{m}^2$）表示。最终输出是无量纲的方差和比率。\n\n你的程序必须生成单行输出，其中包含按给定顺序排列的每个测试用例的三元组 $[\\operatorname{Var}(\\hat{p}_{\\text{SRS}}),\\operatorname{Var}(\\hat{p}_{\\text{strat,opt}}),\\rho]$，形式为浮点数列表；将所有测试用例的三元组聚合到一个列表中，并以方括号括起来的逗号分隔列表形式打印，例如 $[[v_{1,\\text{SRS}},v_{1,\\text{strat}},\\rho_1],[v_{2,\\text{SRS}},v_{2,\\text{strat}},\\rho_2]]$。\n\n使用以下具有科学真实参数的测试套件。在每个用例中，缺陷半径 $r$ 的单位是微米（$\\mu\\mathrm{m}$），面积 $A_h$ 的单位是平方微米（$\\mu\\mathrm{m}^2$），线密度 $L_h$ 的单位是微米/平方微米（$\\mu\\mathrm{m}/\\mu\\mathrm{m}^2$），样本量 $n$ 是无量纲的。\n\n- 测试用例 1：$H=3$，$r=0.02$，$A=[10000,\\,10000,\\,10000]$，$L=[1.0,\\,2.0,\\,4.0]$，$n=10000$。\n- 测试用例 2：$H=4$，$r=0.01$，$A=[5000,\\,5000,\\,5000,\\,5000]$，$L=[2.0,\\,2.0,\\,2.0,\\,2.0]$，$n=8000$。\n- 测试用例 3：$H=3$，$r=0.03$，$A=[40000,\\,10000,\\,5000]$，$L=[0.5,\\,4.0,\\,6.0]$，$n=5000$。\n- 测试用例 4：$H=2$，$r=0.005$，$A=[20000,\\,20000]$，$L=[0.2,\\,8.0]$，$n=2000$。\n\n你的程序应生成单行输出，其中包含以方括号括起来的逗号分隔列表形式的结果（例如，$[ [v_{1,\\text{SRS}},v_{1,\\text{strat}},\\rho_1], [v_{2,\\text{SRS}},v_{2,\\text{strat}},\\rho_2], [v_{3,\\text{SRS}},v_{3,\\text{strat}},\\rho_3], [v_{4,\\text{SRS}},v_{4,\\text{strat}},\\rho_4] ]$）。",
            "solution": "问题陈述已经过评估，被认为是有效的。它在科学上基于已建立的统计抽样理论和半导体成品率建模，问题提出得当，提供了所有必要信息，并以精确、客观的语言陈述。没有矛盾、歧义或事实不准确之处。\n\n目标是计算在两种不同抽样方案下（简单随机抽样（SRS）和最优分配的分层抽样）对总体敏感区域分数 $p$ 的估计量的方差。然后通过两种方差的比率来量化分层抽样的效率。\n\n分析过程是对每个测试用例按顺序应用所提供的公式。\n\n**1. 层级参数**\n\n对于每个层 $h \\in \\{1, \\dots, H\\}$，敏感区域分数 $p_h$ 由缺陷半径 $r$ 和线密度 $L_h$ 决定。该分数是一个半径为 $r$、中心位置在第 $h$ 层内均匀随机分布的缺陷成为“致命”缺陷的概率。它可近似为：\n$$\np_h = \\min\\{1, 2rL_h\\}\n$$\n每一层内的总体被建模为参数为 $p_h$ 的伯努利分布。第 $h$ 层的该分布的方差是：\n$$\n\\sigma_h^2 = p_h(1-p_h)\n$$\n相应的标准差为 $\\sigma_h = \\sqrt{p_h(1-p_h)}$。\n\n**2. 总体过程参数**\n\n将各层组合起来代表整个布线。布线的总面积是 $A_{\\text{tot}} = \\sum_{h=1}^H A_h$。每层的权重 $W_h$ 是其面积分数：\n$$\nW_h = \\frac{A_h}{A_{\\text{tot}}}\n$$\n总体敏感区域分数 $p$ 是各层分数的加权平均：\n$$\np = \\sum_{h=1}^H W_h p_h\n$$\n\n**3. 简单随机抽样（SRS）估计量的方差**\n\n在SRS下，整个布线被视为一个单一总体。抽取一个大小为 $n$ 的样本， $p$ 的估计量是样本均值 $\\hat{p}_{\\text{SRS}}$。该估计量的方差由伯努利总体样本均值方差的标准公式给出：\n$$\n\\operatorname{Var}(\\hat{p}_{\\text{SRS}}) = \\frac{p(1-p)}{n}\n$$\n\n**4. 最优分层抽样估计量的方差**\n\n在分层抽样中，总样本量 $n$ 被分配到各个层中，从第 $h$ 层抽取 $n_h$ 个样本，其中 $\\sum_{h=1}^H n_h = n$。分层估计量 $\\hat{p}_{\\text{strat}}$ 的方差是：\n$$\n\\operatorname{Var}(\\hat{p}_{\\text{strat}}) = \\sum_{h=1}^H \\frac{W_h^2 \\sigma_h^2}{n_h}\n$$\n为了在总样本量 $n$ 固定的情况下最小化该方差，使用 Neyman 分配。最优连续分配 $n_h^\\star$ 与 $W_h \\sigma_h$ 成正比：\n$$\nn_h^\\star = n \\frac{W_h \\sigma_h}{\\sum_{j=1}^H W_j \\sigma_j}\n$$\n将此最优分配代回方差公式，得到分层估计量的最小可能方差 $\\operatorname{Var}(\\hat{p}_{\\text{strat,opt}})$：\n$$\n\\operatorname{Var}(\\hat{p}_{\\text{strat,opt}}) = \\sum_{h=1}^H \\frac{W_h^2 \\sigma_h^2}{n \\frac{W_h \\sigma_h}{\\sum_{j=1}^H W_j \\sigma_j}} = \\sum_{h=1}^H \\frac{W_h \\sigma_h (\\sum_{j=1}^H W_j \\sigma_j)}{n} = \\frac{(\\sum_{j=1}^H W_j \\sigma_j) (\\sum_{h=1}^H W_h \\sigma_h)}{n}\n$$\n这可以简化为一个更简洁且计算上更高效的形式：\n$$\n\\operatorname{Var}(\\hat{p}_{\\text{strat,opt}}) = \\frac{1}{n} \\left( \\sum_{h=1}^H W_h \\sigma_h \\right)^2\n$$\n\n**5. 方差比**\n\n最后，最优分层抽样相对于SRS的相对效率通过它们的方差之比来衡量：\n$$\n\\rho = \\frac{\\operatorname{Var}(\\hat{p}_{\\text{strat,opt}})}{\\operatorname{Var}(\\hat{p}_{\\text{SRS}})}\n$$\n$\\rho  1$ 的值表示分层抽样更有效（即，对于相同的总样本量，提供更精确的估计）。根据柯西-施瓦茨不等式，可以证明 $\\operatorname{Var}(\\hat{p}_{\\text{strat,opt}}) \\le \\operatorname{Var}(\\hat{p}_{\\text{SRS}})$，所以我们预期 $\\rho \\le 1$。等式成立的充要条件是，各层相对于我们感兴趣的量是同质的，在这种情况下意味着 $\\sigma_h$ 在所有层中是常数，或者 Neyman 分配比例 $W_h\\sigma_h/\\sum_j W_j\\sigma_j$ 恰好等于层的权重 $W_h$。后一种情况在 $\\sigma_h$ 为常数时发生。\n\n对每个测试用例应用以下计算步骤以得出所需结果：\n1.  给定 $r$ 以及向量 $A$ 和 $L$，计算各层概率的向量 $p_h$。\n2.  计算 $A_{\\text{tot}}$ 和各层权重的向量 $W_h$。\n3.  计算总体概率 $p$。\n4.  使用 $p$ 和 $n$ 计算SRS方差 $\\operatorname{Var}(\\hat{p}_{\\text{SRS}})$。\n5.  计算各层标准差的向量 $\\sigma_h$。\n6.  使用 $W_h$、$\\sigma_h$ 和 $n$ 计算最优分层抽样方差 $\\operatorname{Var}(\\hat{p}_{\\text{strat,opt}})$。\n7.  计算方差比 $\\rho$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes and compares the variance of Simple Random Sampling (SRS) and\n    optimal Stratified Sampling estimators for critical area analysis in\n    semiconductor yield modeling.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each tuple contains: (r, A, L, n)\n    # r: defect radius (um)\n    # A: list of stratum areas (um^2)\n    # L: list of line densities (um/um^2)\n    # n: total sample size\n    test_cases = [\n        (0.02, [10000., 10000., 10000.], [1.0, 2.0, 4.0], 10000),\n        (0.01, [5000., 5000., 5000., 5000.], [2.0, 2.0, 2.0, 2.0], 8000),\n        (0.03, [40000., 10000., 5000.], [0.5, 4.0, 6.0], 5000),\n        (0.005, [20000., 20000.], [0.2, 8.0], 2000),\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        r, A_list, L_list, n = case\n        \n        # Convert lists to NumPy arrays for vectorized operations\n        A_h = np.array(A_list, dtype=float)\n        L_h = np.array(L_list, dtype=float)\n\n        # Step 1: Compute stratum sensitive area fractions, p_h\n        # p_h = min(1, 2*r*L_h)\n        p_h = np.minimum(1.0, 2.0 * r * L_h)\n\n        # Step 2: Compute total area and stratum weights, W_h\n        # A_tot = sum(A_h)\n        # W_h = A_h / A_tot\n        A_tot = np.sum(A_h)\n        W_h = A_h / A_tot\n\n        # Step 3: Compute overall sensitive area fraction, p\n        # p = sum(W_h * p_h)\n        p = np.sum(W_h * p_h)\n\n        # Step 4: Compute variance of the SRS estimator\n        # Var(p_srs) = p * (1 - p) / n\n        var_srs = p * (1.0 - p) / n\n\n        # Step 5: Compute stratum standard deviations, sigma_h\n        # sigma_h = sqrt(p_h * (1 - p_h))\n        # Add a small epsilon to prevent sqrt of negative due to floating point error if p_h is 1.0\n        sigma_h = np.sqrt(p_h * (1.0 - p_h) + 1e-18)\n\n        # Step 6: Compute variance of the optimal stratified estimator\n        # Var(p_strat_opt) = (sum(W_h * sigma_h))^2 / n\n        sum_W_sigma = np.sum(W_h * sigma_h)\n        var_strat_opt = (sum_W_sigma**2) / n\n\n        # Step 7: Compute the variance ratio, rho\n        # rho = Var(p_strat_opt) / Var(p_srs)\n        # Handle the case where var_srs is zero (p=0 or p=1), which implies all p_h\n        # are identical (0 or 1), making var_strat_opt also zero. In this case,\n        # there is no variance to reduce, so the \"gain\" is neutral, ratio is 1.\n        if var_srs > 0:\n            rho = var_strat_opt / var_srs\n        else:\n            rho = 1.0\n            \n        all_results.append([var_srs, var_strat_opt, rho])\n\n    # Final print statement in the exact required format.\n    # e.g., [[v1_srs, v1_strat, rho1], [v2_srs, v2_strat, rho2]]\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```"
        }
    ]
}