{
    "hands_on_practices": [
        {
            "introduction": "Surface evolution is often driven by local curvature, making its accurate calculation from a discrete set of points a critical task for both stringer and cell-based methods. This practice guides you through computing curvature using a local quadratic fit, a common technique in numerical solvers. By analyzing the results, you will gain insight into the fundamental trade-off between approximation accuracy and sensitivity to numerical noise .",
            "id": "4170884",
            "problem": "In a two-dimensional cross-section of an evolving surface during a semiconductor etch, a Stringer-based discretization represents the interface by ordered points (\"string points\") that move according to a local geometric velocity. In a companion Cell-Based method, field quantities are stored on an Eulerian grid and sampled to recover local geometric descriptors for the string. At a particular time, consider a local neighborhood around a string point at $x=0$ where the interface can be expressed as a graph $y(x)$ in a small window. Three neighboring samples collected by the Cell-Based method provide the following data, in nanometers (nm): $(-10, 5.2)$, $(0, 5.0)$, $(10, 5.4)$.\n\nUsing a local quadratic fit $y(x) = a x^{2} + b x + c$ to these three neighboring points, compute the curvature $\\kappa$ at the string point $x=0$ by starting from the geometric definition of curvature for a planar curve. Assume the curvature is positive when the interface is locally convex upward. Express the final curvature in $\\mathrm{nm}^{-1}$ and round your answer to four significant figures.\n\nThen, discuss the accuracy order of this quadratic-fit curvature estimator under uniform spacing $h$ and sufficiently smooth $y(x)$, and analyze its sensitivity to point spacing and measurement noise in the Stringer framework. Your discussion must begin from foundational geometric definitions and Taylor expansions, and must explicitly connect the estimator’s scaling with $h$ and the conditioning of the local fit to the expected error behavior in curvature-driven surface evolution models such as those used in Cell-Based and Stringer coupling.",
            "solution": "The first step is to determine the coefficients of the local quadratic fit $y(x) = a x^{2} + b x + c$ using the three provided data points: $P_1(-10, 5.2)$, $P_2(0, 5.0)$, and $P_3(10, 5.4)$. The coordinates are given in nanometers, so $x$ and $y(x)$ have units of $\\mathrm{nm}$. The coefficients $a$, $b$, and $c$ will have units of $\\mathrm{nm}^{-1}$, dimensionless, and $\\mathrm{nm}$ respectively.\n\nWe substitute each point into the quadratic equation:\n1. For $P_1(-10, 5.2)$: $y(-10) = a(-10)^{2} + b(-10) + c = 5.2$, which simplifies to $100a - 10b + c = 5.2$.\n2. For $P_2(0, 5.0)$: $y(0) = a(0)^{2} + b(0) + c = 5.0$, which gives $c = 5.0$.\n3. For $P_3(10, 5.4)$: $y(10) = a(10)^{2} + b(10) + c = 5.4$, which simplifies to $100a + 10b + c = 5.4$.\n\nSubstituting $c = 5.0$ into the equations for $P_1$ and $P_3$:\n1. $100a - 10b + 5.0 = 5.2 \\implies 100a - 10b = 0.2$\n2. $100a + 10b + 5.0 = 5.4 \\implies 100a + 10b = 0.4$\n\nThis is a system of two linear equations in $a$ and $b$. Adding the two equations yields:\n$(100a - 10b) + (100a + 10b) = 0.2 + 0.4$\n$200a = 0.6$\n$a = \\frac{0.6}{200} = 0.003$\n\nSubtracting the first equation from the second yields:\n$(100a + 10b) - (100a - 10b) = 0.4 - 0.2$\n$20b = 0.2$\n$b = \\frac{0.2}{20} = 0.01$\n\nThe local quadratic approximation of the interface is therefore:\n$y(x) = 0.003x^{2} + 0.01x + 5.0$\n\nThe geometric definition of curvature $\\kappa$ for a planar curve given as a graph $y(x)$ is:\n$$\\kappa(x) = \\frac{y''(x)}{\\left(1 + [y'(x)]^2\\right)^{3/2}}$$\nThe problem specifies that positive curvature corresponds to a surface that is convex upward, which matches the sign convention of this formula for a positive $y''(x)$.\n\nWe compute the first and second derivatives of $y(x)$:\n$y'(x) = \\frac{d}{dx}(0.003x^{2} + 0.01x + 5.0) = 0.006x + 0.01$\n$y''(x) = \\frac{d}{dx}(0.006x + 0.01) = 0.006$\n\nWe need to evaluate the curvature at the string point $x=0$. First, we evaluate the derivatives at $x=0$:\n$y'(0) = 0.006(0) + 0.01 = 0.01$\n$y''(0) = 0.006$\n\nNow, we substitute these values into the curvature formula:\n$\\kappa(0) = \\frac{y''(0)}{\\left(1 + [y'(0)]^2\\right)^{3/2}} = \\frac{0.006}{\\left(1 + (0.01)^2\\right)^{3/2}}$\n$\\kappa(0) = \\frac{0.006}{(1 + 0.0001)^{3/2}} = \\frac{0.006}{(1.0001)^{3/2}}$\n\nCalculating the numerical value:\n$\\kappa(0) \\approx \\frac{0.006}{1.00015000375} \\approx 0.005999100049...$\nThe units of $x$ and $y$ are $\\mathrm{nm}$, so $y'$ is dimensionless and $y''$ has units of $\\mathrm{nm}^{-1}$. Thus, $\\kappa$ has units of $\\mathrm{nm}^{-1}$.\nRounding the result to four significant figures gives $0.005999 \\, \\mathrm{nm}^{-1}$.\n\nNext, we address the discussion on the accuracy and sensitivity of this method.\nLet us consider a general case with three points sampled from a sufficiently smooth function $y(x)$ at $x_0-h$, $x_0$, and $x_0+h$. Without loss of generality, we set $x_0=0$. The points are $(-h, y_{-1})$, $(0, y_0)$, and $(h, y_1)$. The quadratic fit $y_{fit}(x) = ax^2+bx+c$ through these points gives coefficients:\n$c = y_0$\n$b = \\frac{y_1 - y_{-1}}{2h}$\n$a = \\frac{y_1 - 2y_0 + y_{-1}}{2h^2}$\n\nThe derivatives at $x=0$ are estimated as:\n$y'_{est}(0) = b = \\frac{y_1 - y_{-1}}{2h}$\n$y''_{est}(0) = 2a = \\frac{y_1 - 2y_0 + y_{-1}}{h^2}$\nThese are the standard second-order central difference formulas for the first and second derivatives.\n\nTo analyze the accuracy order, we use Taylor expansions of $y(x)$ around $x=0$:\n$y(h) = y_1 = y(0) + y'(0)h + \\frac{1}{2}y''(0)h^2 + \\frac{1}{6}y'''(0)h^3 + \\frac{1}{24}y''''(0)h^4 + O(h^5)$\n$y(-h) = y_{-1} = y(0) - y'(0)h + \\frac{1}{2}y''(0)h^2 - \\frac{1}{6}y'''(0)h^3 + \\frac{1}{24}y''''(0)h^4 - O(h^5)$\n\nFor the first derivative estimator:\n$y'_{est}(0) = \\frac{1}{2h} [ (y(0) + y'(0)h + \\dots) - (y(0) - y'(0)h + \\dots) ] = \\frac{1}{2h} [2y'(0)h + \\frac{1}{3}y'''(0)h^3 + O(h^5)] = y'(0) + \\frac{1}{6}y'''(0)h^2 + O(h^4)$\nThe truncation error is $y'_{est}(0) - y'(0) = O(h^2)$, so the estimator is second-order accurate.\n\nFor the second derivative estimator:\n$y''_{est}(0) = \\frac{1}{h^2} [ (y(0) + \\dots) - 2y(0) + (y(0) - \\dots) ] = \\frac{1}{h^2} [ y''(0)h^2 + \\frac{1}{12}y''''(0)h^4 + O(h^6) ] = y''(0) + \\frac{1}{12}y''''(0)h^2 + O(h^4)$\nThe truncation error is $y''_{est}(0) - y''(0) = O(h^2)$, so this estimator is also second-order accurate.\n\nSince both derivative estimators are second-order accurate, the resulting curvature estimator $\\kappa_{est}$ will also be second-order accurate, i.e., $\\kappa_{est} = \\kappa + O(h^2)$, provided $y(x)$ is sufficiently smooth (at least $C^4$).\n\nNow, we analyze the sensitivity to measurement noise. Let the measured y-values be $\\tilde{y}_i = y_i + \\epsilon_i$, where $\\epsilon_i$ are independent random errors with mean $0$ and variance $\\sigma^2$. The error in the estimated second derivative due to this noise is:\n$E_{y''} = \\frac{(\\tilde{y}_1 - 2\\tilde{y}_0 + \\tilde{y}_{-1})}{h^2} - y''_{est,true} = \\frac{\\epsilon_1 - 2\\epsilon_0 + \\epsilon_{-1}}{h^2}$\nThe variance of this error is:\n$\\mathrm{Var}(E_{y''}) = \\frac{1}{h^4} \\mathrm{Var}(\\epsilon_1 - 2\\epsilon_0 + \\epsilon_{-1}) = \\frac{1}{h^4} (\\mathrm{Var}(\\epsilon_1) + 4\\mathrm{Var}(\\epsilon_0) + \\mathrm{Var}(\\epsilon_{-1})) = \\frac{\\sigma^2 + 4\\sigma^2 + \\sigma^2}{h^4} = \\frac{6\\sigma^2}{h^4}$\nThe standard deviation of the error in $y''$ thus scales as $\\sigma/h^2$. Similarly, the standard deviation of the error in $y'$ scales as $\\sigma/h$.\n\nThis analysis reveals a critical trade-off in the choice of string point spacing $h$.\n1.  **Truncation Error**: To minimize the truncation error, which is $O(h^2)$, one must choose a small $h$. This is necessary to accurately resolve fine geometric features of the surface.\n2.  **Noise Amplification**: To minimize the effect of measurement noise (e.g., from sampling on the Cell-Based grid), one must choose a large $h$. The calculation of curvature, being dependent on the second derivative, is extremely sensitive to noise, with error amplification proportional to $1/h^2$.\n\nThis trade-off is fundamental to numerical differentiation. The conditioning of the local quadratic fit is poor for small $h$, as the points become nearly collinear, making the determination of the quadratic term (`a`) highly sensitive to small perturbations in the y-values. This is precisely what the $1/h^2$ scaling reflects.\n\nIn the context of curvature-driven surface evolution models, such as those used in coupled Stringer/Cell-Based methods, this sensitivity has profound implications. The normal velocity of the string points is often proportional to the local curvature, $v_n \\propto \\kappa$. If $h$ is small, any small noise in the string point positions will be hugely amplified into large, oscillating errors in the calculated curvature. These noisy curvature values then lead to large, noisy velocities, which cause erratic and unstable movement of the string points. This can destroy the smoothness of the simulated interface and cause the simulation to fail. This is a form of numerical instability. To mitigate this, practitioners often employ regularization techniques, such as using wider stencils (e.g., a 5-point fit), applying digital filters to the string point coordinates or the calculated curvature values, or using more sophisticated, variationally-derived curvature estimators that are more robust to noise.",
            "answer": "$$\\boxed{0.005999}$$"
        },
        {
            "introduction": "In deposition processes, the final profile of the fabricated feature is determined by the interaction between the incoming material flux and the local surface orientation. This exercise applies the principles of ballistic transport to a practical scenario involving a tilted wafer. You will derive an anisotropy metric that quantifies the asymmetry in film thickness, connecting the abstract geometry of surface normals to a measurable manufacturing outcome .",
            "id": "4170893",
            "problem": "A two-dimensional cross-section of a trench feature in a semiconductor wafer is modeled for Physical Vapor Deposition (PVD) using both the stringer method (polygonal facet representation with edge-based unit normals) and the cell-based method (grid-based implicit surface with normals extracted from the gradient of a signed distance function). Consider a trench of large width relative to the source collimation cone such that local line-of-sight deposition dominates and there is no occlusion of either sidewall. The wafer is tilted by an angle $\\theta$ relative to the source axis so that the collimated flux direction, expressed in the trench cross-section coordinates, is $\\mathbf{s} = (\\sin\\theta,\\cos\\theta)$. The trench has symmetric tapered sidewalls, each tilted inward by an angle $\\zeta$ from the vertical, so the right sidewall unit normal is $\\mathbf{n}_{R} = (\\sin\\zeta,\\cos\\zeta)$, the left sidewall unit normal is $\\mathbf{n}_{L} = (-\\sin\\zeta,\\cos\\zeta)$, and the bottom facet unit normal is $\\mathbf{n}_{B} = (0,1)$. The sticking probability is unity and the source produces a constant directed number flux density $F$. Assume the ballistic deposition rate at a point on a facet is proportional to the non-negative projection of the flux onto the facet’s local unit normal, namely $R(\\mathbf{n}) \\propto \\max\\!\\big(0,\\,\\mathbf{s}\\cdot\\mathbf{n}\\big)$, which is the fundamental collimated line-of-sight deposition law.\n\nUnder these conditions, and using either the stringer method or the cell-based method to provide the same local unit normals on these planar facets, the time-integrated thickness on each facet over a deposition interval $\\tau$ is proportional to $\\max\\!\\big(0,\\,\\mathbf{s}\\cdot\\mathbf{n}\\big)\\,\\tau$. Define the anisotropy metric\n$$A(\\theta,\\zeta) \\equiv \\frac{T_{R} - T_{L}}{T_{B}},$$\nwhere $T_{R}$, $T_{L}$, and $T_{B}$ are the normal-incidence thicknesses on the right sidewall, left sidewall, and bottom facet, respectively, after time $\\tau$. Work from the fundamental ballistic projection law and the given geometry to derive a closed-form analytic expression for $A(\\theta,\\zeta)$ that is valid for angles satisfying $0 < \\theta < \\frac{\\pi}{2}$ and $0 < \\zeta < \\frac{\\pi}{2} - \\theta$ so that all three facets are illuminated without occlusion and $\\mathbf{s}\\cdot\\mathbf{n}_{R} > 0$, $\\mathbf{s}\\cdot\\mathbf{n}_{L} > 0$, and $\\mathbf{s}\\cdot\\mathbf{n}_{B} > 0$.\n\nExpress your final answer as a single closed-form analytic expression in terms of $\\theta$ and $\\zeta$, using radians. Do not include units in the final answer.",
            "solution": "The anisotropy metric is defined as:\n$$A(\\theta, \\zeta) \\equiv \\frac{T_{R} - T_{L}}{T_{B}}$$\nwhere $T_{R}$, $T_{L}$, and $T_{B}$ represent the time-integrated thicknesses grown normal to the right sidewall, left sidewall, and bottom facet, respectively.\n\nThe fundamental law of ballistic deposition provided states that the deposition rate on a surface with unit normal $\\mathbf{n}$ from a collimated flux with direction $\\mathbf{s}$ is proportional to the non-negative projection of the flux vector onto the normal vector. The time-integrated thickness $T$ over an interval $\\tau$ is therefore proportional to this projection. We can write this relationship using a proportionality constant, $k$:\n$$T(\\mathbf{n}) = k \\cdot \\max(0, \\mathbf{s} \\cdot \\mathbf{n})$$\nThe problem specifies angular constraints $0 < \\theta < \\frac{\\pi}{2}$ and $0 < \\zeta < \\frac{\\pi}{2} - \\theta$, which ensure that the dot products $\\mathbf{s}\\cdot\\mathbf{n}_R$, $\\mathbf{s}\\cdot\\mathbf{n}_L$, and $\\mathbf{s}\\cdot\\mathbf{n}_B$ are all positive. Therefore, the $\\max(0, \\dots)$ operator can be removed, and the thickness on each facet is directly proportional to the dot product of the flux direction vector and the facet's unit normal vector.\n\nThe given vectors are:\nFlux direction: $\\mathbf{s} = (\\sin\\theta, \\cos\\theta)$\nRight sidewall normal: $\\mathbf{n}_{R} = (\\sin\\zeta, \\cos\\zeta)$\nLeft sidewall normal: $\\mathbf{n}_{L} = (-\\sin\\zeta, \\cos\\zeta)$\nBottom facet normal: $\\mathbf{n}_{B} = (0, 1)$\n\nWe now calculate the dot products for each facet.\n\n1.  Thickness on the right sidewall, $T_R$:\n    $T_R = k \\, (\\mathbf{s} \\cdot \\mathbf{n}_R) = k \\, ((\\sin\\theta, \\cos\\theta) \\cdot (\\sin\\zeta, \\cos\\zeta))$\n    $T_R = k \\, (\\sin\\theta \\sin\\zeta + \\cos\\theta \\cos\\zeta)$\n    Using the trigonometric identity for the cosine of a difference, $\\cos(A - B) = \\cos A \\cos B + \\sin A \\sin B$, we identify $A=\\theta$ and $B=\\zeta$:\n    $T_R = k \\cos(\\theta - \\zeta)$\n\n2.  Thickness on the left sidewall, $T_L$:\n    $T_L = k \\, (\\mathbf{s} \\cdot \\mathbf{n}_L) = k \\, ((\\sin\\theta, \\cos\\theta) \\cdot (-\\sin\\zeta, \\cos\\zeta))$\n    $T_L = k \\, (-\\sin\\theta \\sin\\zeta + \\cos\\theta \\cos\\zeta)$\n    Using the trigonometric identity for the cosine of a sum, $\\cos(A + B) = \\cos A \\cos B - \\sin A \\sin B$, we identify $A=\\theta$ and $B=\\zeta$:\n    $T_L = k \\cos(\\theta + \\zeta)$\n\n3.  Thickness on the bottom facet, $T_B$:\n    $T_B = k \\, (\\mathbf{s} \\cdot \\mathbf{n}_B) = k \\, ((\\sin\\theta, \\cos\\theta) \\cdot (0, 1))$\n    $T_B = k \\, (\\sin\\theta \\cdot 0 + \\cos\\theta \\cdot 1)$\n    $T_B = k \\cos\\theta$\n\nNow, we substitute these expressions for $T_R$, $T_L$, and $T_B$ into the definition of the anisotropy metric $A(\\theta, \\zeta)$:\n$$A(\\theta, \\zeta) = \\frac{T_{R} - T_{L}}{T_{B}} = \\frac{k \\cos(\\theta - \\zeta) - k \\cos(\\theta + \\zeta)}{k \\cos\\theta}$$\nThe proportionality constant $k$ cancels from the numerator and denominator:\n$$A(\\theta, \\zeta) = \\frac{\\cos(\\theta - \\zeta) - \\cos(\\theta + \\zeta)}{\\cos\\theta}$$\n\nTo simplify the numerator, we use the trigonometric sum-to-product identity $\\cos(X) - \\cos(Y) = -2 \\sin\\left(\\frac{X+Y}{2}\\right) \\sin\\left(\\frac{X-Y}{2}\\right)$. Let $X = \\theta - \\zeta$ and $Y = \\theta + \\zeta$.\nThen $\\frac{X+Y}{2} = \\frac{(\\theta - \\zeta) + (\\theta + \\zeta)}{2} = \\frac{2\\theta}{2} = \\theta$, and $\\frac{X-Y}{2} = \\frac{(\\theta - \\zeta) - (\\theta + \\zeta)}{2} = \\frac{-2\\zeta}{2} = -\\zeta$.\nThe numerator becomes:\n$\\cos(\\theta - \\zeta) - \\cos(\\theta + \\zeta) = -2 \\sin(\\theta) \\sin(-\\zeta)$\nSince $\\sin(-\\zeta) = -\\sin(\\zeta)$, this simplifies to:\n$-2 \\sin(\\theta) (-\\sin(\\zeta)) = 2 \\sin\\theta \\sin\\zeta$\n\nSubstituting this simplified numerator back into the expression for $A(\\theta, \\zeta)$:\n$$A(\\theta, \\zeta) = \\frac{2 \\sin\\theta \\sin\\zeta}{\\cos\\theta}$$\nRecognizing that $\\frac{\\sin\\theta}{\\cos\\theta} = \\tan\\theta$, the final expression is:\n$$A(\\theta, \\zeta) = 2 \\tan\\theta \\sin\\zeta$$\nThis is the closed-form analytic expression for the anisotropy metric under the given conditions and constraints.",
            "answer": "$$\\boxed{2 \\tan\\theta \\sin\\zeta}$$"
        },
        {
            "introduction": "Simulations of semiconductor processes must account for the interaction between evolving surfaces and fixed structures, such as patterned masks. This requires enforcing appropriate boundary conditions where the stringer points meet a rigid edge. This coding practice challenges you to derive and implement the constrained velocity for common physical scenarios like sticking and slipping, a crucial step in building a robust and realistic process model .",
            "id": "4170931",
            "problem": "Consider a two-dimensional cross-section of a semiconductor feature in a process model where the evolving material surface is represented by a discrete set of points connected as segments (a \"string\" representation), while the underlying physics can also be interpreted in a cell-based (finite-volume) framework. In the absence of constraints, each surface point evolves according to the kinematic law $$\\dot{\\mathbf{x}} = V_n \\,\\mathbf{n}_s,$$ where $\\mathbf{x}$ is the position, $V_n$ is the local normal speed (e.g., due to etch or deposition), and $\\mathbf{n}_s$ is the unit normal to the surface at that point. For points attached to a rigid mask edge, motion must satisfy boundary constraints. Two physically meaningful cases are:\n\n- No motion (perfect sticking): the point remains fixed with $$\\dot{\\mathbf{x}} = \\mathbf{0}.$$\n- Slip constrained to the rigid mask edge: the point is allowed to move only along the mask edge tangent $\\mathbf{t}_m$ (unit vector), with no motion through the mask characterized by the mask edge normal $\\mathbf{m}_n$ (unit vector), enforcing $$\\mathbf{m}_n \\cdot \\dot{\\mathbf{x}} = 0.$$ The slip velocity may be either the projection of the unconstrained velocity onto the mask tangent or a specified slip speed $u_t$ along $\\mathbf{t}_m$.\n\nAt mask corners, where two rigid mask edges intersect with normals $\\mathbf{m}_{n,1}$ and $\\mathbf{m}_{n,2}$ and tangents $\\mathbf{t}_{m,1}$ and $\\mathbf{t}_{m,2}$, the admissible motion subspace is the intersection of the two tangent directions. In two dimensions, this intersection is generically trivial (the zero vector), resulting in $$\\dot{\\mathbf{x}} = \\mathbf{0}.$$\n\nStarting from the fundamental kinematic law $$\\dot{\\mathbf{x}} = V_n \\,\\mathbf{n}_s,$$ and the holonomic constraint formulation for rigid boundaries $$\\mathbf{m}_n \\cdot \\dot{\\mathbf{x}} = 0,$$ derive, from first principles of constrained motion, the formulae to compute the constrained velocity $\\dot{\\mathbf{x}}$ of a boundary string point in the following cases:\n1. Perfect sticking to the rigid mask.\n2. Slip constrained to the mask edge with velocity given by a projection of the unconstrained velocity onto $\\mathbf{t}_m$.\n3. Slip constrained to the mask edge with a specified slip speed $u_t$ along $\\mathbf{t}_m$.\n4. Mask corner where two rigid edges meet.\n\nThen implement these constraints in a program that, for each test case, computes the updated position $$\\mathbf{x}_{\\text{new}} = \\mathbf{x} + \\dot{\\mathbf{x}}\\,\\Delta t$$ using a given time step $\\Delta t$, and verifies that the constraint is satisfied to numerical tolerance. Treat all vectors as two-dimensional, and assume all inputs use International System of Units (SI units). You must:\n- Express positions in meters, speeds in meters per second, and time in seconds.\n- Use angles only implicitly through provided vectors; do not compute or require angles explicitly.\n- Normalize any input vectors intended as unit vectors.\n- Use a numerical tolerance of $10^{-12}$ for constraint verification.\n\nYour program must solve the following test suite of cases:\n- Case A (sticking): $\\mathbf{x} = [5.0\\times 10^{-7},\\,2.0\\times 10^{-7}]$, $V_n = 4.0\\times 10^{-8}$, $\\mathbf{n}_s = [0,\\,1]$, $\\mathbf{t}_m = [1,\\,0]$, $\\mathbf{m}_n = [0,\\,1]$, type = \"stick\", $\\Delta t = 0.1$.\n- Case B (slip via projection): $\\mathbf{x} = [0.0,\\,0.0]$, $V_n = 1.0\\times 10^{-7}$, $\\mathbf{n}_s = [1/\\sqrt{2},\\,1/\\sqrt{2}]$, $\\mathbf{t}_m = [\\sqrt{3}/2,\\,1/2]$, $\\mathbf{m}_n = [-1/2,\\,\\sqrt{3}/2]$, type = \"slip_projected\", $\\Delta t = 0.2$.\n- Case C (specified slip): $\\mathbf{x} = [1.0\\times 10^{-6},\\,0.0]$, $V_n = 2.0\\times 10^{-8}$, $\\mathbf{n}_s = [1,\\,0]$, $\\mathbf{t}_m = [0,\\,1]$, $\\mathbf{m}_n = [1,\\,0]$, type = \"slip_specified\", $u_t = 1.2\\times 10^{-7}$, $\\Delta t = 0.05$.\n- Case D (corner, no motion): $\\mathbf{x} = [1.0\\times 10^{-7},\\,1.0\\times 10^{-7}]$, $V_n = 2.0\\times 10^{-7}$, $\\mathbf{n}_s = [1/\\sqrt{2},\\,-1/\\sqrt{2}]$, $\\mathbf{t}_{m,1} = [1,\\,0]$, $\\mathbf{m}_{n,1} = [0,\\,1]$, $\\mathbf{t}_{m,2} = [0,\\,1]$, $\\mathbf{m}_{n,2} = [1,\\,0]$, type = \"corner\", $\\Delta t = 0.05$.\n- Case E (projection with non-unit tangent, normalization required): $\\mathbf{x} = [-2.0\\times 10^{-6},\\,3.0\\times 10^{-6}]$, $V_n = 2.0\\times 10^{-7}$, $\\mathbf{n}_s = [1,\\,0]$, $\\mathbf{t}_m = [2,\\,0]$ (note: not unit length), $\\mathbf{m}_n = [0,\\,1]$, type = \"slip_projected\", $\\Delta t = 0.05$.\n\nFor each case, compute:\n- The updated position $\\mathbf{x}_{\\text{new}}$ in meters, as a list $[x_{\\text{new}}, y_{\\text{new}}]$.\n- A boolean indicating whether the enforced constraint is satisfied within $10^{-12}$.\n\nYour program should produce a single line of output containing the results for all five cases as a comma-separated list enclosed in square brackets, where each element is a list of the form $[x_{\\text{new}}, y_{\\text{new}}, \\text{constraint\\_ok}]$. For example: \"[[x1,y1,True],[x2,y2,False],...]\".",
            "solution": "The problem requires the derivation of formulae for the constrained velocity of a surface point at a rigid mask boundary, followed by a numerical implementation. The starting point for all cases is the unconstrained velocity of a surface point, given by the kinematic law:\n$$\n\\dot{\\mathbf{x}}_u = V_n \\mathbf{n}_s\n$$\nwhere $\\dot{\\mathbf{x}}_u$ is the unconstrained velocity vector, $V_n$ is the local normal speed, and $\\mathbf{n}_s$ is the unit normal vector to the surface at the point $\\mathbf{x}$. All vectors are considered two-dimensional, i.e., $\\mathbf{v} = [v_x, v_y]$. When a point is on a rigid mask boundary, its motion is constrained. The constraint is expressed as a holonomic constraint on the velocity:\n$$\n\\mathbf{m}_n \\cdot \\dot{\\mathbf{x}}_c = 0\n$$\nwhere $\\dot{\\mathbf{x}}_c$ is the constrained velocity and $\\mathbf{m}_n$ is the unit normal vector to the mask, pointing away from the permissible region of motion. This condition ensures the point does not move \"through\" the mask. Geometrically, this means the constrained velocity $\\dot{\\mathbf{x}}_c$ must be parallel to the mask edge, whose direction is given by the unit tangent vector $\\mathbf{t}_m$. In two dimensions, $\\mathbf{t}_m$ and $\\mathbf{m}_n$ are orthogonal, so $\\mathbf{t}_m \\cdot \\mathbf{m}_n = 0$.\n\nWe will now derive the expression for the constrained velocity $\\dot{\\mathbf{x}}_c$ for each of the four specified cases.\n\n**Case 1: Perfect sticking to the rigid mask**\n\nThis is the simplest case. The problem statement defines this condition as \"no motion\". This corresponds to a Dirichlet boundary condition on the velocity. Therefore, the constrained velocity is the zero vector:\n$$\n\\dot{\\mathbf{x}}_c = \\mathbf{0}\n$$\nThe constraint $\\mathbf{m}_n \\cdot \\dot{\\mathbf{x}}_c = 0$ is trivially satisfied since $\\mathbf{m}_n \\cdot \\mathbf{0} = 0$. The physical interpretation is that the point is perfectly adhered to the mask and cannot move, regardless of the unconstrained surface evolution speed $V_n$. The new position after a time step $\\Delta t$ is simply the original position: $\\mathbf{x}_{\\text{new}} = \\mathbf{x} + \\mathbf{0} \\cdot \\Delta t = \\mathbf{x}$.\n\n**Case 2: Slip constrained to the mask edge (projected velocity)**\n\nIn this scenario, the point is free to slide along the mask edge. The velocity is constrained to be parallel to the mask tangent $\\mathbf{t}_m$. The problem specifies that the velocity's magnitude and direction are determined by the projection of the unconstrained velocity, $\\dot{\\mathbf{x}}_u$, onto the tangent direction $\\mathbf{t}_m$.\n\nThe projection of a vector $\\mathbf{v}$ onto a unit vector $\\mathbf{u}$ is given by the formula $(\\mathbf{v} \\cdot \\mathbf{u})\\mathbf{u}$. Applying this to our problem, the constrained velocity $\\dot{\\mathbf{x}}_c$ is the projection of $\\dot{\\mathbf{x}}_u$ onto $\\mathbf{t}_m$:\n$$\n\\dot{\\mathbf{x}}_c = (\\dot{\\mathbf{x}}_u \\cdot \\mathbf{t}_m) \\mathbf{t}_m\n$$\nSubstituting $\\dot{\\mathbf{x}}_u = V_n \\mathbf{n}_s$, we obtain:\n$$\n\\dot{\\mathbf{x}}_c = ( (V_n \\mathbf{n}_s) \\cdot \\mathbf{t}_m ) \\mathbf{t}_m = V_n (\\mathbf{n}_s \\cdot \\mathbf{t}_m) \\mathbf{t}_m\n$$\nThis velocity vector is, by construction, a scalar multiple of $\\mathbf{t}_m$. The constraint of no motion through the mask is satisfied because $\\mathbf{t}_m$ is orthogonal to $\\mathbf{m}_n$:\n$$\n\\mathbf{m}_n \\cdot \\dot{\\mathbf{x}}_c = \\mathbf{m}_n \\cdot (V_n (\\mathbf{n}_s \\cdot \\mathbf{t}_m) \\mathbf{t}_m) = V_n (\\mathbf{n}_s \\cdot \\mathbf{t}_m) (\\mathbf{m}_n \\cdot \\mathbf{t}_m) = V_n (\\mathbf{n}_s \\cdot \\mathbf{t}_m) (0) = 0\n$$\n\n**Case 3: Slip constrained to the mask edge (specified slip speed)**\n\nSimilar to the previous case, the motion is constrained to the direction of the mask tangent $\\mathbf{t}_m$. However, instead of the magnitude being determined by projection, it is given by a specified slip speed, $u_t$. The direction of slip along the tangent (+$\\mathbf{t}_m$ or -$\\mathbf{t}_m$) is determined by the component of the unconstrained velocity along the tangent. If the unconstrained velocity has a positive component along $\\mathbf{t}_m$, the point slips in the direction of $\\mathbf{t}_m$; if the component is negative, it slips opposite to $\\mathbf{t}_m$.\n\nThe signed component of $\\dot{\\mathbf{x}}_u$ along $\\mathbf{t}_m$ is given by the dot product $\\dot{\\mathbf{x}}_u \\cdot \\mathbf{t}_m$. The direction of slip is therefore $\\text{sign}(\\dot{\\mathbf{x}}_u \\cdot \\mathbf{t}_m) \\mathbf{t}_m$, where the $\\text{sign}$ function returns $+1$, $-1$, or $0$. The velocity is the speed $u_t$ multiplied by this direction vector:\n$$\n\\dot{\\mathbf{x}}_c = u_t \\cdot \\text{sign}(\\dot{\\mathbf{x}}_u \\cdot \\mathbf{t}_m) \\mathbf{t}_m\n$$\nSubstituting $\\dot{\\mathbf{x}}_u = V_n \\mathbf{n}_s$:\n$$\n\\dot{\\mathbf{x}}_c = u_t \\cdot \\text{sign}((V_n \\mathbf{n}_s) \\cdot \\mathbf{t}_m) \\mathbf{t}_m\n$$\nIf the tangential component of the unconstrained velocity is zero, i.e., $(\\dot{\\mathbf{x}}_u \\cdot \\mathbf{t}_m) = 0$, then $\\text{sign}(0)=0$ and the slip velocity is zero. The constraint $\\mathbf{m}_n \\cdot \\dot{\\mathbf{x}}_c = 0$ is satisfied by the same logic as in Case 2, since $\\dot{\\mathbf{x}}_c$ is parallel to $\\mathbf{t}_m$.\n\n**Case 4: Mask corner**\n\nAt a corner, the point is simultaneously on two different mask edges. These edges have distinct unit normal vectors, $\\mathbf{m}_{n,1}$ and $\\mathbf{m}_{n,2}$, and distinct unit tangent vectors, $\\mathbf{t}_{m,1}$ and $\\mathbf{t}_{m,2}$. For the point to remain on both edges, its velocity $\\dot{\\mathbf{x}}_c$ must satisfy both constraints simultaneously:\n$$\n\\mathbf{m}_{n,1} \\cdot \\dot{\\mathbf{x}}_c = 0 \\quad \\text{and} \\quad \\mathbf{m}_{n,2} \\cdot \\dot{\\mathbf{x}}_c = 0\n$$\nThe first condition implies that $\\dot{\\mathbf{x}}_c$ must be parallel to $\\mathbf{t}_{m,1}$ (since $\\mathbf{t}_{m,1}$ is the null space of $\\mathbf{m}_{n,1}$ in this context). The second condition implies that $\\dot{\\mathbf{x}}_c$ must also be parallel to $\\mathbf{t}_{m,2}$.\nSo, there must exist scalars $k_1$ and $k_2$ such that:\n$$\n\\dot{\\mathbf{x}}_c = k_1 \\mathbf{t}_{m,1} \\quad \\text{and} \\quad \\dot{\\mathbf{x}}_c = k_2 \\mathbf{t}_{m,2}\n$$\nThis requires $k_1 \\mathbf{t}_{m,1} = k_2 \\mathbf{t}_{m,2}$. In a two-dimensional space, if the vectors $\\mathbf{t}_{m,1}$ and $\\mathbf{t}_{m,2}$ are linearly independent (i.e., not parallel, which is true for any genuine corner), the only solution to this equation is the trivial one: $k_1 = 0$ and $k_2 = 0$.\nTherefore, the only possible constrained velocity is the zero vector:\n$$\n\\dot{\\mathbf{x}}_c = \\mathbf{0}\n$$\nThis is effectively a \"sticking\" condition imposed by the geometry of the corner. Both boundary constraints are trivially satisfied.",
            "answer": "```python\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Solves for the updated position and constraint satisfaction for several test cases\n    of a surface point evolution under different boundary conditions.\n    \"\"\"\n\n    # Numerical tolerance for constraint verification\n    TOL = 1e-12\n\n    # Test suite definition\n    test_cases = [\n        {\n            'name': 'Case A (sticking)',\n            'type': 'stick',\n            'x': np.array([5.0e-7, 2.0e-7]),\n            'Vn': 4.0e-8,\n            'ns': np.array([0.0, 1.0]),\n            'tm': np.array([1.0, 0.0]),\n            'mn': np.array([0.0, 1.0]),\n            'dt': 0.1\n        },\n        {\n            'name': 'Case B (slip via projection)',\n            'type': 'slip_projected',\n            'x': np.array([0.0, 0.0]),\n            'Vn': 1.0e-7,\n            'ns': np.array([1/math.sqrt(2), 1/math.sqrt(2)]),\n            'tm': np.array([math.sqrt(3)/2, 1/2]),\n            'mn': np.array([-1/2, math.sqrt(3)/2]),\n            'dt': 0.2\n        },\n        {\n            'name': 'Case C (specified slip)',\n            'type': 'slip_specified',\n            'x': np.array([1.0e-6, 0.0]),\n            'Vn': 2.0e-8,\n            'ns': np.array([1.0, 0.0]),\n            'tm': np.array([0.0, 1.0]),\n            'mn': np.array([1.0, 0.0]),\n            'ut': 1.2e-7,\n            'dt': 0.05\n        },\n        {\n            'name': 'Case D (corner, no motion)',\n            'type': 'corner',\n            'x': np.array([1.0e-7, 1.0e-7]),\n            'Vn': 2.0e-7,\n            'ns': np.array([1/math.sqrt(2), -1/math.sqrt(2)]),\n            't_m1': np.array([1.0, 0.0]),\n            'm_n1': np.array([0.0, 1.0]),\n            't_m2': np.array([0.0, 1.0]),\n            'm_n2': np.array([1.0, 0.0]),\n            'dt': 0.05\n        },\n        {\n            'name': 'Case E (projection with non-unit tangent)',\n            'type': 'slip_projected',\n            'x': np.array([-2.0e-6, 3.0e-6]),\n            'Vn': 2.0e-7,\n            'ns': np.array([1.0, 0.0]),\n            'tm': np.array([2.0, 0.0]), # Not unit length\n            'mn': np.array([0.0, 1.0]),\n            'dt': 0.05\n        }\n    ]\n\n    results = []\n\n    def normalize(v):\n        \"\"\"Normalizes a 2D numpy vector, handling the zero vector case.\"\"\"\n        norm = np.linalg.norm(v)\n        if norm == 0:\n            return v\n        return v / norm\n\n    for case in test_cases:\n        v_c = np.array([0.0, 0.0])\n        constraint_ok = False\n\n        # --- Calculate Constrained Velocity ---\n\n        if case['type'] == 'stick':\n            # Velocity is zero for a sticking point.\n            v_c = np.array([0.0, 0.0])\n            # Constraint verification based on velocity magnitude.\n            constraint_ok = np.linalg.norm(v_c) < TOL\n        \n        elif case['type'] == 'corner':\n            # Velocity is zero for a corner point.\n            v_c = np.array([0.0, 0.0])\n            m_n1 = normalize(case['m_n1'])\n            m_n2 = normalize(case['m_n2'])\n            # Verify both holonomic constraints.\n            check1 = abs(np.dot(m_n1, v_c)) < TOL\n            check2 = abs(np.dot(m_n2, v_c)) < TOL\n            constraint_ok = check1 and check2\n\n        elif case['type'] == 'slip_projected':\n            ns = normalize(case['ns'])\n            tm = normalize(case['tm'])\n            mn = normalize(case['mn'])\n            Vn = case['Vn']\n            \n            v_u = Vn * ns\n            v_c = np.dot(v_u, tm) * tm\n            \n            # Verify the holonomic constraint.\n            constraint_ok = abs(np.dot(mn, v_c)) < TOL\n\n        elif case['type'] == 'slip_specified':\n            ns = normalize(case['ns'])\n            tm = normalize(case['tm'])\n            mn = normalize(case['mn'])\n            Vn = case['Vn']\n            ut = case['ut']\n            \n            v_u = Vn * ns\n            tangential_comp = np.dot(v_u, tm)\n            \n            v_c = ut * np.sign(tangential_comp) * tm\n            \n            # Verify the holonomic constraint.\n            constraint_ok = abs(np.dot(mn, v_c)) < TOL\n\n        # --- Update Position and Store Result ---\n        \n        x = case['x']\n        dt = case['dt']\n        x_new = x + v_c * dt\n        \n        results.append([x_new[0], x_new[1], constraint_ok])\n\n    # Format the output string to match the required format precisely,\n    # without spaces inside the inner lists.\n    formatted_results = [str(r).replace(\" \", \"\") for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}