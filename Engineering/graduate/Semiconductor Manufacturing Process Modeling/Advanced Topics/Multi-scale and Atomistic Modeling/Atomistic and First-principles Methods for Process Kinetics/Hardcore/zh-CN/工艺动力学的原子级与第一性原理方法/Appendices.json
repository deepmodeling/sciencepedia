{
    "hands_on_practices": [
        {
            "introduction": "在进行任何第一性原理计算之前，首要任务是确保数值结果的可靠性。该练习将指导您完成一个核心步骤：收敛性测试。您将学习如何通过系统地改变平面波截断能 $E_{\\text{cut}}$ 和 $k$ 点网格来评估总能量和力的收敛性，并找到在满足精度要求下计算成本最低的参数组合。掌握这一实践是在保证计算结果物理意义的同时，有效利用计算资源的关键。",
            "id": "4109418",
            "problem": "您将基于第一性原理建模代理，为块状硅设计并实现一套收敛性评估方案，该方案适用于平面波密度泛函理论 (DFT) 和 Monkhorst-Pack 布里渊区积分。目标是确定满足能量和力公差的最低计算设置，并为过渡态能垒计算提出标准，所有这些都在一个可复现的代理框架内完成。\n\n其基本原理如下。平面波密度泛函理论 (DFT) 依赖于变分原理，其中 Kohn-Sham 总能量是一个上限，随着基组完备性的增加而单调递减。对于赝势，平面波基组的完备性由动能截断能 $E_{\\text{cut}}$ 控制，总能量和力中的系统误差随 $E_{\\text{cut}}$ 的增大而减小。布里渊区积分使用 Monkhorst-Pack 网格进行，表示为 $N \\times N \\times N$ 的网格，其中积分误差随 $N$ 的增大而减小。对于像硅这样的有带隙半导体，被积函数是光滑的，求积误差随 $N$ 代数衰减。这些原理启发了以下针对块状硅的代理误差模型：\n\n- 由平面波基组引起的单位原子总能量误差：$\\Delta E_{\\text{basis}}(E_{\\text{cut}}) = a_E \\, E_{\\text{cut}}^{-p_E}$，其中 $a_E = 10$，$p_E = 1.75$，单位为电子伏特每原子 ($\\text{eV/atom}$)。\n- 由平面波基组引起的最大力分量误差：$\\Delta F_{\\text{basis}}(E_{\\text{cut}}) = a_F \\, E_{\\text{cut}}^{-p_F}$，其中 $a_F = 3$，$p_F = 1.2$，单位为 $\\text{eV/\\AA}$。\n- 由 $k$ 点采样引起的单位原子总能量误差：$\\Delta E_{k}(N) = b_E \\, N^{-q_E}$，其中 $b_E = 0.08$，$q_E = 2$，单位为 $\\text{eV/atom}$。\n- 由 $k$ 点采样引起的最大力分量误差：$\\Delta F_{k}(N) = b_F \\, N^{-q_F}$，其中 $b_F = 0.06$，$q_F = 2$，单位为 $\\text{eV/\\AA}$。\n\n假设总误差按正交叠加：\n$$\n\\Delta E_{\\text{tot}}(E_{\\text{cut}},N) = \\sqrt{\\Delta E_{\\text{basis}}(E_{\\text{cut}})^2 + \\Delta E_{k}(N)^2},\n\\quad\n\\Delta F_{\\text{tot}}(E_{\\text{cut}},N) = \\sqrt{\\Delta F_{\\text{basis}}(E_{\\text{cut}})^2 + \\Delta F_{k}(N)^2}.\n$$\n\n对于能垒计算，例如半导体工艺中的微动弹性带 (Nudged Elastic Band, NEB) 路径，相似镜像之间的系统误差是相关的。使用固定的相关系数 $\\rho = 0.8$ 对两个镜像之间的能量差的能垒不确定性进行建模：\n$$\n\\Delta E_{\\text{barrier}}(E_{\\text{cut}},N) = \\sqrt{2\\,(1-\\rho)} \\, \\Delta E_{\\text{tot}}(E_{\\text{cut}},N).\n$$\n\n设在可行设置上要最小化的计算成本度量为：\n$$\nC(E_{\\text{cut}},N) = \\gamma \\, E_{\\text{cut}}^{3/2} \\, N^3,\n$$\n其中 $\\gamma$ 是一个无关紧要的正常数；您应在所有满足公差的配对 $(E_{\\text{cut}},N)$ 中最小化 $E_{\\text{cut}}^{3/2} \\, N^3$。\n\n您的程序必须在离散集合 $\\{200,225,250,275,300,325,350,375,400,450,500,600,800,1000,1200,1400,1600\\}$ (单位 $\\text{eV}$) 中搜索 $E_{\\text{cut}}$，并在 $\\{2,3,4,\\dots,20\\}$ 中搜索 $N$，并为每个测试用例选择满足以下条件的配对 $(E_{\\text{cut}},N)$：\n- 同时满足 $\\Delta E_{\\text{tot}}(E_{\\text{cut}},N) \\le \\varepsilon_E$ 和 $\\Delta F_{\\text{tot}}(E_{\\text{cut}},N) \\le \\varepsilon_F$，并且\n- 在所有满足条件的配对中最小化 $E_{\\text{cut}}^{3/2} \\, N^3$。\n\n对于能垒标准，要求是 $\\Delta E_{\\text{barrier}}(E_{\\text{cut}},N) \\le \\min(\\beta \\, H, \\theta)$，其中 $H$ 是名义能垒高度，$\\beta$ 是一个分数公差（无单位，用作小数），$\\theta$ 是一个以 $\\text{eV}$ 为单位的绝对公差。报告所选的 $(E_{\\text{cut}},N)$ 是否也满足此能垒标准。\n\n单位：\n- 所有能量必须以电子伏特 ($\\text{eV}$) 处理和报告，适用时，单位原子的能量明确表示为 $\\text{eV/atom}$。\n- 所有力必须以电子伏特每埃 ($\\text{eV/\\AA}$) 处理和报告。\n- 不涉及角度。\n\n用于覆盖典型、边界和边缘场景的测试套件：\n- 案例 1：$\\varepsilon_E = 1.0 \\times 10^{-3}$ $\\text{eV/atom}$，$\\varepsilon_F = 1.0 \\times 10^{-2}$ $\\text{eV/\\AA}$，$H = 0.47$ $\\text{eV}$，$\\beta = 0.05$，$\\theta = 2.0 \\times 10^{-2}$ $\\text{eV}$。\n- 案例 2：$\\varepsilon_E = 5.0 \\times 10^{-4}$ $\\text{eV/atom}$，$\\varepsilon_F = 5.0 \\times 10^{-3}$ $\\text{eV/\\AA}$，$H = 0.80$ $\\text{eV}$，$\\beta = 0.02$，$\\theta = 1.0 \\times 10^{-2}$ $\\text{eV}$。\n- 案例 3：$\\varepsilon_E = 3.0 \\times 10^{-3}$ $\\text{eV/atom}$，$\\varepsilon_F = 3.0 \\times 10^{-2}$ $\\text{eV/\\AA}$，$H = 0.10$ $\\text{eV}$，$\\beta = 0.10$，$\\theta = 5.0 \\times 10^{-2}$ $\\text{eV}$。\n\n程序要求：\n- 实现上述代理模型和选择逻辑。\n- 对于每个案例，输出所选的 $E_{\\text{cut}}$ (单位 $\\text{eV}$)、$N$、达到的 $\\Delta E_{\\text{tot}}$ (单位 $\\text{eV/atom}$)、达到的 $\\Delta F_{\\text{tot}}$ (单位 $\\text{eV/\\AA}$)、预测的 $\\Delta E_{\\text{barrier}}$ (单位 $\\text{eV}$) 以及一个布尔值，指示是否满足能垒标准。\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，每个案例由一个列表表示，顺序为 $[E_{\\text{cut}},N,\\Delta E_{\\text{tot}},\\Delta F_{\\text{tot}},\\Delta E_{\\text{barrier}},\\text{pass}]$。例如，$[[\\dots],[\\dots],[\\dots]]$。\n- 所有浮点数输出表示为小数点后六位。\n\n您的解决方案必须是一个完整、可运行的 Python 程序，实现此逻辑并生成指定的单行输出。",
            "solution": "所提出的问题是计算材料科学领域一个适定 (well-posed) 的练习，具体涉及第一性原理计算参数的优化。它在科学上以密度泛函理论 (DFT) 的原理为基础，并且是客观且内部一致的。因此，我们可以着手给出一个正式的解决方案。\n\n目标是确定计算参数的最佳配对，即平面波动能截断能 $E_{\\text{cut}}$ 和 Monkhorst-Pack 网格尺寸 $N$，该配对在满足总能量和原子力的指定精度公差的同时，最小化一个已定义的计算成本度量。该问题提供了代理模型，这些模型解析地描述了系统误差相对于这些参数的收敛行为。\n\n误差贡献定义如下：\n- 由于有限平面波基组引起的单位原子总能量误差被建模为相对于能量截断 $E_{\\text{cut}}$ 的幂律衰减：\n$$\n\\Delta E_{\\text{basis}}(E_{\\text{cut}}) = a_E \\, E_{\\text{cut}}^{-p_E}\n$$\n其中 $a_E = 10 \\text{ eV} \\cdot \\text{eV}^{p_E}/\\text{atom}$ 且 $p_E = 1.75$。\n\n- 由于基组引起的最大力分量的误差也类似地建模：\n$$\n\\Delta F_{\\text{basis}}(E_{\\text{cut}}) = a_F \\, E_{\\text{cut}}^{-p_F}\n$$\n其中 $a_F = 3 \\text{ eV/\\AA} \\cdot \\text{eV}^{p_F}$ 且 $p_F = 1.2$。\n\n- 在 $N \\times N \\times N$ Monkhorst-Pack 网格上进行离散布里渊区积分所产生的单位原子总能量误差为：\n$$\n\\Delta E_{k}(N) = b_E \\, N^{-q_E}\n$$\n其中 $b_E = 0.08 \\text{ eV/atom}$ 且 $q_E = 2$。\n\n- 由 $k$ 点采样引起的最大力分量误差为：\n$$\n\\Delta F_{k}(N) = b_F \\, N^{-q_F}\n$$\n其中 $b_F = 0.06 \\text{ eV/\\AA}$ 且 $q_F = 2$。\n\n假设来自基组和 $k$ 点采样的误差是独立的，则能量和力的总误差通过将各个贡献分量进行正交叠加来计算：\n$$\n\\Delta E_{\\text{tot}}(E_{\\text{cut}},N) = \\sqrt{\\Delta E_{\\text{basis}}(E_{\\text{cut}})^2 + \\Delta E_{k}(N)^2}\n$$\n$$\n\\Delta F_{\\text{tot}}(E_{\\text{cut}},N) = \\sqrt{\\Delta F_{\\text{basis}}(E_{\\text{cut}})^2 + \\Delta F_{k}(N)^2}\n$$\n\n要最小化的计算成本由以下函数给出：\n$$\nC(E_{\\text{cut}},N) = \\gamma \\, E_{\\text{cut}}^{3/2} \\, N^3\n$$\n其中 $\\gamma$ 是一个比例常数。最小化 $C(E_{\\text{cut}},N)$ 等同于最小化 $E_{\\text{cut}}^{3/2} \\, N^3$ 这一项。\n\n该求解方法涉及在预设的离散参数空间上进行系统性搜索。能量截断的可能值集合为 $E_{\\text{cut}} \\in \\{200, 225, 250, 275, 300, 325, 350, 375, 400, 450, 500, 600, 800, 1000, 1200, 1400, 1600\\}$ $\\text{eV}$，而 $k$ 点网格密度的可能值集合为 $N \\in \\{2, 3, \\dots, 20\\}$。\n\n对于由一组公差 $(\\varepsilon_E, \\varepsilon_F)$ 定义的每个测试用例，算法如下：\n1.  初始化一个最小成本变量 $C_{\\min}$ 为一个接近无穷大的值，并将最优参数集设置为空状态。\n2.  遍历来自各自搜索空间的每一个可能的配对 $(E_{\\text{cut}}, N)$。\n3.  对每个配对，使用提供的模型计算总能量误差 $\\Delta E_{\\text{tot}}(E_{\\text{cut}}, N)$ 和总力误差 $\\Delta F_{\\text{tot}}(E_{\\text{cut}}, N)$。\n4.  检查计算出的误差是否满足给定的公差约束：$\\Delta E_{\\text{tot}} \\le \\varepsilon_E$ 和 $\\Delta F_{\\text{tot}} \\le \\varepsilon_F$。\n5.  如果满足约束条件，则该配对 $(E_{\\text{cut}}, N)$ 被视为“可行”。计算其相关的成本代理 $C_0(E_{\\text{cut}}, N) = E_{\\text{cut}}^{3/2} N^3$。\n6.  如果此成本 $C_0$ 小于当前的最小成本 $C_{\\min}$，则更新 $C_{\\min} = C_0$ 并将当前的配对 $(E_{\\text{cut}}, N)$ 及其相关误差 $(\\Delta E_{\\text{tot}}, \\Delta F_{\\text{tot}})$ 存储为新的最优解。\n7.  在穷尽搜索空间后，所存储的最优配对 $(E_{\\text{cut}}^{\\text{opt}}, N^{\\text{opt}})$ 就是以最低计算成本满足标准的解决方案。\n\n最后，对于确定的最优参数，我们评估它们对过渡态能垒计算的适用性。计算出的能量垒的不确定性 $\\Delta E_{\\text{barrier}}$ 由下式给出：\n$$\n\\Delta E_{\\text{barrier}}(E_{\\text{cut}},N) = \\sqrt{2(1-\\rho)} \\, \\Delta E_{\\text{tot}}(E_{\\text{cut}},N)\n$$\n其中指定了误差相关系数 $\\rho = 0.8$。然后将这个计算出的不确定性与一个定义为 $\\min(\\beta H, \\theta)$ 的公差进行比较，其中 $H$ 是名义能垒高度，$\\beta$ 是一个分数公差，$\\theta$ 是一个以 $\\text{eV}$ 为单位的绝对公差。一个布尔值将指示最优参数是否也满足此能垒标准。\n\n这个结构化的程序保证在给定的模型和搜索空间内，找到满足基态性质和过渡态能量所需精度且计算效率最高的参数。实现将对提供的每个测试用例遵循此逻辑。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for optimal DFT parameters based on surrogate error models.\n    \"\"\"\n\n    # --- Model Parameters ---\n    # Basis set error model: a * E_cut^(-p)\n    a_E = 10.0\n    p_E = 1.75\n    a_F = 3.0\n    p_F = 1.2\n    \n    # k-point sampling error model: b * N^(-q)\n    b_E = 0.08\n    q_E = 2.0\n    b_F = 0.06\n    q_F = 2.0\n    \n    # Barrier uncertainty model\n    rho = 0.8\n    barrier_factor = np.sqrt(2 * (1 - rho))\n\n    # --- Search Space ---\n    e_cut_values = [200, 225, 250, 275, 300, 325, 350, 375, 400, 450, 500, 600, 800, 1000, 1200, 1400, 1600]\n    n_values = list(range(2, 21))\n\n    # --- Test Cases ---\n    test_cases = [\n        # (eps_E, eps_F, H, beta, theta)\n        (1.0e-3, 1.0e-2, 0.47, 0.05, 2.0e-2),\n        (5.0e-4, 5.0e-3, 0.80, 0.02, 1.0e-2),\n        (3.0e-3, 3.0e-2, 0.10, 0.10, 5.0e-2),\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        eps_E, eps_F, H, beta, theta = case\n        \n        min_cost = float('inf')\n        optimal_params = None\n\n        for e_cut in e_cut_values:\n            # Pre-calculate basis set errors for this e_cut\n            delta_e_basis = a_E * (e_cut ** -p_E)\n            delta_f_basis = a_F * (e_cut ** -p_F)\n\n            for n_val in n_values:\n                # Calculate k-point errors\n                delta_e_k = b_E * (n_val ** -q_E)\n                delta_f_k = b_F * (n_val ** -q_F)\n\n                # Calculate total errors in quadrature\n                delta_e_tot = np.sqrt(delta_e_basis**2 + delta_e_k**2)\n                delta_f_tot = np.sqrt(delta_f_basis**2 + delta_f_k**2)\n\n                # Check if tolerances are met\n                if delta_e_tot = eps_E and delta_f_tot = eps_F:\n                    # This is a feasible parameter set, calculate its cost\n                    cost = (e_cut ** 1.5) * (n_val ** 3)\n                    \n                    if cost  min_cost:\n                        min_cost = cost\n                        optimal_params = {\n                            \"e_cut\": e_cut,\n                            \"n\": n_val,\n                            \"dE_tot\": delta_e_tot,\n                            \"dF_tot\": delta_f_tot\n                        }\n        \n        # After searching, process the optimal parameters\n        if optimal_params:\n            # Calculate barrier uncertainty for the optimal parameter set\n            delta_e_barrier = barrier_factor * optimal_params[\"dE_tot\"]\n            \n            # Determine if the barrier criterion is met\n            barrier_tolerance = min(beta * H, theta)\n            barrier_pass = delta_e_barrier = barrier_tolerance\n\n            # Format the results for this case into a list\n            case_result_list = [\n                optimal_params[\"e_cut\"],\n                optimal_params[\"n\"],\n                optimal_params[\"dE_tot\"],\n                optimal_params[\"dF_tot\"],\n                delta_e_barrier,\n                barrier_pass,\n            ]\n            \n            # Format the list into the required string representation\n            e_str = str(case_result_list[0])\n            n_str = str(case_result_list[1])\n            de_tot_str = f\"{case_result_list[2]:.6f}\"\n            df_tot_str = f\"{case_result_list[3]:.6f}\"\n            de_barr_str = f\"{case_result_list[4]:.6f}\"\n            pass_str = str(case_result_list[5]) # 'True' or 'False'\n            \n            case_result_string = f\"[{e_str},{n_str},{de_tot_str},{df_tot_str},{de_barr_str},{pass_str.lower()}]\"\n            all_results.append(case_result_string)\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "当使用周期性超胞（supercell）模型来模拟孤立缺陷时，缺陷与其周期性镜像之间的相互作用会引入系统性误差，即“有限尺寸效应”。本练习将教授您一种标准方法来校正这种误差。通过对一系列不同尺寸超胞的计算结果进行外推，我们可以得到无限大（$L \\to \\infty$）极限下的真实迁移势垒，从而获得更精确的动力学参数。",
            "id": "4109420",
            "problem": "考虑一个在半导体制造过程建模中，通过密度泛函理论（DFT）在Born–Oppenheimer势能面上沿微扰弹性带（NEB）路径计算出的迁移势垒。在一个线性尺寸为 $L$ 的周期性超胞中，周期性边界条件会引起缺陷镜像之间的相互作用，从而对势垒产生扰动。对于三维晶体中的局域性迁移事件，连续介质弹性力学和线性响应原理表明，对于足够大的 $L$，领头阶的镜像相互作用修正由一个长波模式主导，其贡献可以通过将势垒视为 $x = 1/L$ 的函数并对 $x$ 进行回归分析来捕捉。目标是从有限尺寸的数据中推断出势垒的无限大尺寸极限，并量化每个有限尺寸 $L$ 下的镜像相互作用误差。\n\n基于以下基础理论：\n- Born–Oppenheimer 近似通过最小化电子能量来定义原子核的势能面。\n- 在尺寸为 $L$ 的超胞中使用周期性边界条件会复制缺陷，产生镜像相互作用。对于局域性扰动，其领头的长程贡献可以用粗粒化的弹性和静电响应来表示。这种响应意味着在 $L$ 很大时，势垒对 $x = 1/L$ 存在平滑的依赖关系。\n- 根据带有不确定性的多次计算得出的统计上可靠的估计，应以每个数据点方差的倒数作为其权重。\n\n任务：\n给定一组超胞尺寸 $L_i$（单位为 $\\text{\\AA}$）、相应的迁移势垒值 $E_i$（单位为 $\\text{eV}$）和单标准差不确定度 $\\sigma_i$（单位为 $\\text{eV}$），将 $x_i = 1/L_i$ 作为自变量，$E_i$ 作为因变量。使用权重 $w_i = 1/\\sigma_i^2$ 进行加权线性回归，以获得 $x=0$ 时的最佳拟合截距 $E_\\infty$（即无限大尺寸势垒，单位为 $\\text{eV}$）和最佳拟合斜率 $a$（单位为 $\\text{eV}\\cdot\\text{\\AA}$）。然后，对每个输入的 $L_i$，计算镜像相互作用误差 $\\Delta_i = E_i - E_\\infty$（单位为 $\\text{eV}$）。所有报告的能量必须以 $\\text{eV}$ 表示，$L$ 必须以 $\\text{\\AA}$ 表示。将所有输出四舍五入到 $6$ 位小数。\n\n您必须使用带权重的最小二乘法正规方程组，从第一性原理出发实现加权线性回归。不要假定任何预先推导的快捷公式；应从加权最小二乘法最小化的目标函数定义出发，逻辑地构建解决方案，并求解最优参数。\n\n测试套件：\n您必须硬编码并解决以下 $4$ 个测试用例。每个测试用例包含 $(L, E, \\sigma)$ 三元组数组，其中 $L$ 的单位是 $\\text{\\AA}$，$E$ 和 $\\sigma$ 的单位是 $\\text{eV}$。\n\n- 测试用例 1（不同尺寸，相同不确定度）：\n  - $L = [20, 30, 40, 60]$\n  - $E = [0.520, 0.505, 0.500, 0.495]$\n  - $\\sigma = [0.003, 0.003, 0.003, 0.003]$\n\n- 测试用例 2（不同尺寸，异方差不确定度）：\n  - $L = [15, 25, 50, 80]$\n  - $E = [0.620, 0.590, 0.575, 0.570]$\n  - $\\sigma = [0.010, 0.006, 0.004, 0.004]$\n\n- 测试用例 3（定义一条直线所需的最少数据）：\n  - $L = [30, 90]$\n  - $E = [0.700, 0.680]$\n  - $\\sigma = [0.005, 0.005]$\n\n- 测试用例 4（几乎与尺寸无关的势垒）：\n  - $L = [40, 80, 160]$\n  - $E = [0.400, 0.399, 0.399]$\n  - $\\sigma = [0.002, 0.002, 0.002]$\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个由方括号括起来的、以逗号分隔的结果列表。每个测试用例的结果本身应该是一个列表，包含无限大尺寸势垒 $E_\\infty$（单位为 $\\text{eV}$）、斜率 $a$（单位为 $\\text{eV}\\cdot\\text{\\AA}$），以及与输入 $L$ 顺序相同的镜像相互作用误差 $\\Delta_i$（单位为 $\\text{eV}$）。例如，对于一个包含 $3$ 个 $L$ 值的测试用例，其子列表必须有 $5$ 个条目：$[E_\\infty, a, \\Delta_1, \\Delta_2, \\Delta_3]$，所有数值均四舍五入到 $6$ 位小数。因此，总体输出必须是一个包含 $4$ 个此类子列表的列表（每个测试用例一个），并打印为单行，例如 $[[\\dots],[\\dots],[\\dots],[\\dots]]$。",
            "solution": "从有限尺寸的超胞计算中确定无限大尺寸迁移势垒 $E_\\infty$ 的问题，是计算材料科学中的一个经典回归问题。该问题是有效的、有科学依据且适定的。所提供的模型，即能量势垒 $E$ 是超胞尺寸倒数 $x=1/L$ 的线性函数，是用于校正周期性边界条件下由镜像相互作用引起的有限尺寸效应的标准一阶近似。该任务要求从第一性原理出发进行加权线性回归，我们将在实现之前推导其公式。\n\n迁移势垒 $E$ 作为超胞尺寸倒数 $x=1/L$ 的函数模型由以下线性关系给出：\n$$ E(x) = E_\\infty + a \\cdot x $$\n此处，$E_\\infty$ 是截距，代表无限大超胞极限下（$L \\to \\infty$，因此 $x \\to 0$）的势垒。斜率 $a$ 量化了线性尺寸依赖修正的强度。待确定的参数是 $\\beta_0 = E_\\infty$ 和 $\\beta_1 = a$。\n\n我们给定一组 $N$ 个数据点 $(x_i, E_i)$，其中 $x_i = 1/L_i$，以及每个能量测量值 $E_i$ 的不确定度 $\\sigma_i$。对于正态分布的误差，最大似然原理指出，最佳拟合参数是那些能使加权残差平方和（通常记为 $\\chi^2$）最小化的参数。权重 $w_i$ 由方差的倒数给出，即 $w_i = 1/\\sigma_i^2$。需要最小化的目标函数 $S(\\beta_0, \\beta_1)$ 是：\n$$ S(\\beta_0, \\beta_1) = \\sum_{i=1}^{N} w_i (E_i - (\\beta_0 + \\beta_1 x_i))^2 $$\n为了找到使 $S$ 最小化的 $\\beta_0$ 和 $\\beta_1$ 的值，我们必须将 $S$ 对每个参数的偏导数设为零：\n$$ \\frac{\\partial S}{\\partial \\beta_0} = -2 \\sum_{i=1}^{N} w_i (E_i - \\beta_0 - \\beta_1 x_i) = 0 $$\n$$ \\frac{\\partial S}{\\partial \\beta_1} = -2 \\sum_{i=1}^{N} w_i x_i (E_i - \\beta_0 - \\beta_1 x_i) = 0 $$\n重新整理这两个方程，得到一个关于 $\\beta_0$ 和 $\\beta_1$ 的线性方程组，称为正规方程组：\n$$ \\left( \\sum_{i=1}^{N} w_i \\right) \\beta_0 + \\left( \\sum_{i=1}^{N} w_i x_i \\right) \\beta_1 = \\sum_{i=1}^{N} w_i E_i $$\n$$ \\left( \\sum_{i=1}^{N} w_i x_i \\right) \\beta_0 + \\left( \\sum_{i=1}^{N} w_i x_i^2 \\right) \\beta_1 = \\sum_{i=1}^{N} w_i x_i E_i $$\n为简化起见，我们定义以下总和：\n- $S_w = \\sum w_i$\n- $S_{wx} = \\sum w_i x_i$\n- $S_{wxx} = \\sum w_i x_i^2$\n- $S_{wE} = \\sum w_i E_i$\n- $S_{wxE} = \\sum w_i x_i E_i$\n\n该方程组可以写成矩阵形式：\n$$\n\\begin{pmatrix}\nS_w  S_{wx} \\\\\nS_{wx}  S_{wxx}\n\\end{pmatrix}\n\\begin{pmatrix}\n\\beta_0 \\\\\n\\beta_1\n\\end{pmatrix}\n=\n\\begin{pmatrix}\nS_{wE} \\\\\nS_{wxE}\n\\end{pmatrix}\n$$\n这个 $2 \\times 2$ 方程组可以求解 $\\beta_0$ 和 $\\beta_1$。设 $\\mathcal{D}$ 为左侧矩阵的行列式，$\\mathcal{D} = S_w S_{wxx} - (S_{wx})^2$。通过矩阵求逆或克莱姆法则得到的解是：\n$$ \\beta_0 = E_\\infty = \\frac{S_{wxx} S_{wE} - S_{wx} S_{wxE}}{\\mathcal{D}} $$\n$$ \\beta_1 = a = \\frac{S_w S_{wxE} - S_{wx} S_{wE}}{\\mathcal{D}} $$\n这构成了加权最小二乘解的第一性原理推导。\n\n当只有两个数据点（$N=2$）时，会出现一个特殊情况。在这种情况下，回归直线必须精确地穿过这两个点，因为这是实现最小可能残差和（为零）的唯一方法。参数可以从两个点 $(x_1, E_1)$ 和 $(x_2, E_2)$ 的坐标直接确定：\n$$ \\beta_1 = a = \\frac{E_2 - E_1}{x_2 - x_1} $$\n$$ \\beta_0 = E_\\infty = E_1 - \\beta_1 x_1 $$\n实现将使用这些推导出的公式来计算每个测试用例的参数。一旦求得 $E_\\infty$，就根据问题定义计算每个数据点的镜像相互作用误差：$\\Delta_i = E_i - E_\\infty$。\n\nPython代码将实现一个函数，该函数以列表 $L$、$E$ 和 $\\sigma$ 作为输入，计算必要的总和，求解 $E_\\infty$ 和 $a$，然后计算 $\\Delta_i$ 的值。此过程将应用于所提供的四个测试用例中的每一个。所有最终数值将按要求格式化为六位小数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_regression_and_errors(L, E, sigma):\n    \"\"\"\n    Performs weighted linear regression based on first principles to find the\n    infinite-size energy barrier and image interaction errors.\n\n    Args:\n        L (list or np.ndarray): Supercell sizes in Angstroms.\n        E (list or np.ndarray): Corresponding migration barriers in eV.\n        sigma (list or np.ndarray): Uncertainties of the barriers in eV.\n\n    Returns:\n        list: A list containing the infinite-size barrier E_inf (eV),\n              the slope a (eV * Angstrom), and the image interaction errors\n              Delta_i (eV) for each input point.\n    \"\"\"\n    # Convert inputs to numpy arrays for vectorized operations, ensuring float type\n    # for precision in division.\n    L = np.array(L, dtype=np.float64)\n    E = np.array(E, dtype=np.float64)\n    sigma = np.array(sigma, dtype=np.float64)\n\n    # Transform independent variable: x = 1/L\n    x = 1.0 / L\n    # Define weights as inverse variance: w = 1/sigma^2\n    w = 1.0 / (sigma**2)\n\n    # For the case of exactly two data points, the regression line must pass\n    # through both points. This gives an exact analytical solution.\n    if len(L) == 2:\n        a = (E[1] - E[0]) / (x[1] - x[0])\n        E_inf = E[0] - a * x[0]\n    else:\n        # For N > 2 points, solve the normal equations for weighted least squares.\n        # Calculate the required sums.\n        S_w = np.sum(w)\n        S_wx = np.sum(w * x)\n        S_wxx = np.sum(w * x**2)\n        S_wE = np.sum(w * E)\n        S_wxE = np.sum(w * x * E)\n        \n        # Solve the 2x2 system of normal equations for the parameters E_inf and a.\n        # The system is:\n        # | S_w   S_wx  | | E_inf |   | S_wE  |\n        # | S_wx  S_wxx | |   a   | = | S_wxE |\n        determinant = S_w * S_wxx - S_wx**2\n        \n        # E_inf is the intercept (beta_0)\n        E_inf = (S_wxx * S_wE - S_wx * S_wxE) / determinant\n        # a is the slope (beta_1)\n        a = (S_w * S_wxE - S_wx * S_wE) / determinant\n\n    # Calculate the image interaction error Delta_i = E_i - E_inf for each point.\n    delta_i = E - E_inf\n    \n    # Collate results: E_inf, a, followed by all Delta_i values.\n    result = [E_inf, a] + delta_i.tolist()\n    \n    return result\n\ndef solve():\n    \"\"\"\n    Main function to run the analysis for all test cases and print the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1: Different sizes, equal uncertainties\n        ([20, 30, 40, 60],\n         [0.520, 0.505, 0.500, 0.495],\n         [0.003, 0.003, 0.003, 0.003]),\n        # Test case 2: Different sizes, heteroscedastic uncertainties\n        ([15, 25, 50, 80],\n         [0.620, 0.590, 0.575, 0.570],\n         [0.010, 0.006, 0.004, 0.004]),\n        # Test case 3: Minimal data to define a line\n        ([30, 90],\n         [0.700, 0.680],\n         [0.005, 0.005]),\n        # Test case 4: Nearly size-independent barrier\n        ([40, 80, 160],\n         [0.400, 0.399, 0.399],\n         [0.002, 0.002, 0.002]),\n    ]\n\n    all_results_str = []\n    for case in test_cases:\n        L_vals, E_vals, sigma_vals = case\n        \n        # Calculate results for the current case\n        result_values = calculate_regression_and_errors(L_vals, E_vals, sigma_vals)\n        \n        # Format each number to a string with 6 decimal places.\n        formatted_nums = [f\"{val:.6f}\" for val in result_values]\n        # Create a string representation of the list, e.g., \"[1.23,4.56]\".\n        list_str = f\"[{','.join(formatted_nums)}]\"\n        all_results_str.append(list_str)\n\n    # Final print statement must produce a single line in the format of a list of lists.\n    print(f\"[{','.join(all_results_str)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "从第一性原理计算中获得的能量和势垒并非精确值，而是带有不确定性的估计。为了对工艺动力学做出可靠的预测，我们必须将这些不确定性传递到最终的宏观可观测量中，例如扩散系数。本练习将通过蒙特卡洛（Monte Carlo）采样方法，向您展示如何量化激活能 $E_a$ 和指前因子 $\\nu$ 的不确定性对扩散系数 $D$ 的影响，并最终确定其置信区间。这个实践连接了原子尺度的计算与宏观工艺模型，是现代不确定性量化方法的绝佳入门。",
            "id": "4109414",
            "problem": "在半导体制造过程建模中，一个常见的建模任务是将原子级模拟中估计的参数不确定性传播到介观可观测量。考虑一个单机制的表面或体扩散过程，其动力学蒙特卡洛 (Kinetic Monte Carlo, KMC) 跳跃速率 $k$ 服从阿伦尼乌斯形式 $k = \\nu \\exp\\!\\left(-\\frac{E_a}{k_B T}\\right)$，其中 $E_a$ 是活化能，$\\nu$ 是指前因子（尝试频率），$k_B$ 是玻尔兹曼常数，$T$ 是以开尔文为单位的绝对温度。对于维度为 $d$、跳跃长度为 $a$ 的晶格上的随机行走，扩散系数建模为 $D = \\frac{a^2 k}{2 d}$，单位为米²/秒。假设密度泛函理论 (Density Functional Theory, DFT) 分析得出不确定的参数估计，其模型如下：$E_a$ 服从均值为 $\\mu_{E_a}$、标准差为 $\\sigma_{E_a}$ 的正态分布，并根据物理约束截断为 $E_a \\ge 0$；$\\ln \\nu$ 服从均值为 $\\mu_{\\ln \\nu}$、标准差为 $\\sigma_{\\ln \\nu}$ 的正态分布（因此 $\\nu$ 服从对数正态分布）。\n\n您的任务是实现蒙特卡洛采样，将 $E_a$ 和 $\\nu$ 的不确定性传播到扩散系数 $D$ 中，并报告 $D$ 的等尾 $95\\%$ 置信区间。使用 $k_B = 8.617333262 \\times 10^{-5}$ 电子伏特/开尔文，$E_a$ 单位为电子伏特，$T$ 单位为开尔文，$a$ 单位为米，$\\nu$ 单位为 1/秒，确保计算出的 $D$ 单位为米²/秒。对于每个测试用例，生成 $N$ 个独立样本 $\\{E_a^{(i)}, \\nu^{(i)}\\}_{i=1}^N$，其中 $E_a^{(i)} \\sim \\mathcal{N}(\\mu_{E_a}, \\sigma_{E_a}^2)$ 截断为 $E_a^{(i)} \\ge 0$，$\\ln \\nu^{(i)} \\sim \\mathcal{N}(\\mu_{\\ln \\nu}, \\sigma_{\\ln \\nu}^2)$。计算 $k^{(i)} = \\nu^{(i)} \\exp\\!\\left(-\\frac{E_a^{(i)}}{k_B T}\\right)$ 和 $D^{(i)} = \\frac{a^2 k^{(i)}}{2 d}$，然后报告 $D$ 的等尾 $95\\%$ 置信区间的下界和上界（即 $\\{D^{(i)}\\}$ 经验分布的 $2.5\\%$ 和 $97.5\\%$ 分位数）。每个界限值以米²/秒为单位表示，并四舍五入至三位有效数字。\n\n测试套件：\n- 用例 1：$T = 800$ 开尔文, $a = 2.5 \\times 10^{-10}$ 米, $d = 2$, $\\mu_{E_a} = 0.45$ 电子伏特, $\\sigma_{E_a} = 0.05$ 电子伏特, $\\mu_{\\ln \\nu} = \\ln(10^{13})$, $\\sigma_{\\ln \\nu} = 0.4$, $N = 40000$。\n- 用例 2：$T = 300$ 开尔文, $a = 2.5 \\times 10^{-10}$ 米, $d = 2$, $\\mu_{E_a} = 0.90$ 电子伏特, $\\sigma_{E_a} = 0.10$ 电子伏特, $\\mu_{\\ln \\nu} = \\ln(5 \\times 10^{12})$, $\\sigma_{\\ln \\nu} = 0.3$, $N = 60000$。\n- 用例 3：$T = 1000$ 开尔文, $a = 2.5 \\times 10^{-10}$ 米, $d = 1$, $\\mu_{E_a} = 0.20$ 电子伏特, $\\sigma_{E_a} = 0.02$ 电子伏特, $\\mu_{\\ln \\nu} = \\ln(10^{12})$, $\\sigma_{\\ln \\nu} = 0.2$, $N = 50000$。\n- 用例 4：$T = 1200$ 开尔文, $a = 5.43 \\times 10^{-10}$ 米, $d = 3$, $\\mu_{E_a} = 3.50$ 电子伏特, $\\sigma_{E_a} = 0.30$ 电子伏特, $\\mu_{\\ln \\nu} = \\ln(10^{13})$, $\\sigma_{\\ln \\nu} = 0.5$, $N = 80000$。\n- 用例 5：$T = 600$ 开尔文, $a = 3.0 \\times 10^{-10}$ 米, $d = 2$, $\\mu_{E_a} = 0.60$ 电子伏特, $\\sigma_{E_a} = 0.15$ 电子伏特, $\\mu_{\\ln \\nu} = \\ln(2 \\times 10^{13})$, $\\sigma_{\\ln \\nu} = 1.0$, $N = 70000$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含所有测试用例的置信区间界限，格式为逗号分隔的列表的列表。每个内部列表包含两个浮点数，分别对应 $D$ 的 $95\\%$ 置信区间的下界和上界，单位为米²/秒，四舍五入至三位有效数字，并用方括号括起来（例如 $[[\\text{lower}_1,\\text{upper}_1],[\\text{lower}_2,\\text{upper}_2],\\dots]$）。",
            "solution": "起点是热激活动力学的阿伦尼乌斯描述，它是在反应物与活化络合物之间存在准平衡的假设下，从过渡态理论 (Transition State Theory, TST) 推导出来的。在 TST 中，克服能垒 $E_a$ 的速率常数与尝试频率 $\\nu$ 成比例，该频率考虑了初始态附近的振动动力学，并乘以一个抑制势垒穿越的指数玻尔兹曼因子。具体来说，动力学蒙特卡洛 (KMC) 的跳跃速率建模为 $k = \\nu \\exp\\!\\left(-\\frac{E_a}{k_B T}\\right)$，其中 $k_B$ 是玻尔兹曼常数，$T$ 是绝对温度。该模型在原子级过程（如表面吸附原子扩散和体晶体中的点缺陷迁移）中得到了充分验证。\n\n对于维度为 $d$、跳跃长度为 $a$ 的晶格随机行走，根据扩散系数 $D$ 的定义，均方位移随时间线性增长，即 $\\langle r^2(t) \\rangle = 2 d D t$。对于速率为 $k$ 的泊松跳跃序列，每次跳跃使行走者位移长度 $a$，从而得出有效扩散系数 $D = \\frac{a^2 k}{2 d}$。该系数通过将均方位移的增长率 $\\frac{d}{dt}\\langle r^2\\rangle = a^2 k$ 与爱因斯坦关系式 $\\frac{d}{dt}\\langle r^2\\rangle = 2 d D$ 等同起来而得到。\n\n从密度泛函理论 (DFT) 推导出的参数的不确定性被建模为概率分布。通常将活化能 $E_a$ 建模为正态随机变量以反映拟合和方法上的不确定性；然而，物理约束要求 $E_a \\ge 0$，我们通过截断来强制执行此约束。指前因子 $\\nu$ 反映了振动频率和熵因子，通常被建模为对数正态分布，因此 $\\ln \\nu$ 服从正态分布。设 $E_a \\sim \\mathcal{N}(\\mu_{E_a}, \\sigma_{E_a}^2)$ 截断为 $E_a \\ge 0$，且 $\\ln \\nu \\sim \\mathcal{N}(\\mu_{\\ln \\nu}, \\sigma_{\\ln \\nu}^2)$，二者独立。\n\n为将这些不确定性传播到 $D$，我们使用蒙特卡洛采样：\n- 从各自的正态分布中抽取 $N$ 个独立样本对 $\\left(E_a^{(i)}, \\ln \\nu^{(i)}\\right)$；通过截断强制 $E_a^{(i)} \\ge 0$，并转换 $\\nu^{(i)} = \\exp\\!\\left(\\ln \\nu^{(i)}\\right)$。\n- 计算跳跃速率 $k^{(i)} = \\nu^{(i)} \\exp\\!\\left(-\\frac{E_a^{(i)}}{k_B T}\\right)$。\n- 计算 $D^{(i)} = \\frac{a^2 k^{(i)}}{2 d}$，单位为米²/秒，其中 $a$ 的单位为米，$T$ 的单位为开尔文。使用 $k_B = 8.617333262 \\times 10^{-5}$ 电子伏特/开尔文，以使单位为电子伏特的 $E_a$ 与单位为电子伏特的 $k_B T$ 保持一致。\n- $\\{D^{(i)}\\}_{i=1}^N$ 的经验分布近似于给定参数不确定性下 $D$ 的后验预测分布。等尾 $95\\%$ 置信区间由 $2.5\\%$ 和 $97.5\\%$ 的经验分位数给出：$q_{0.025}$ 和 $q_{0.975}$。\n- 将每个界限值四舍五入至三位有效数字，以生成单位为米²/秒的最终数值结果。\n\n算法设计：\n- 使用固定的随机种子以确保可复现性。\n- 通过正态分布生成 $E_a$ 样本，并通过将负样本替换为 $0$ 来进行截断。鉴于对于实际情况中 $\\mu_{E_a} \\gg 0$ 时左尾概率很小，这种做法是可接受的，并且强制执行了物理约束。\n- 通过正态分布生成 $\\ln \\nu$ 样本，然后取指数得到 $\\nu$ 样本。\n- 为提高效率，使用数值数组进行向量化计算 $k$ 和 $D$。\n- 使用确定性的分位数函数计算经验分位数。\n- 通过乘以 10 的幂进行缩放，实现将浮点数四舍五入到三位有效数字。具体而言，对于 $x  0$，定义 $e = \\lfloor \\log_{10}(x) \\rfloor$，$s = 10^{e - s_f + 1}$，其中 $s_f = 3$，然后返回 $\\operatorname{round}(x/s) \\cdot s$；对于 $x = 0$，返回 $0$。这确保了三位有效数字，同时保留了浮点数类型。\n- 将该程序应用于提供的每个测试用例，使用其指定的参数（$T$、$a$、$d$、$\\mu_{E_a}$、$\\sigma_{E_a}$、$\\mu_{\\ln \\nu}$、$\\sigma_{\\ln \\nu}$、$N$）。\n\n最终输出为单行文本，包含每个测试用例的一对界限值 $[\\text{lower}, \\text{upper}]$ 的列表，即 $[[q_{0.025}^{(1)}, q_{0.975}^{(1)}],[q_{0.025}^{(2)}, q_{0.975}^{(2)}],\\dots]$。根据要求，每个界限值都四舍五入至三位有效数字，并以米²/秒为单位表示。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef round_sig(x: float, sig: int = 3) - float:\n    \"\"\"\n    Round a positive float to 'sig' significant figures while returning a float.\n    For x == 0, returns 0.0.\n    \"\"\"\n    if x == 0.0 or not np.isfinite(x):\n        # For infinite or NaN, return as-is (though such values should not occur here).\n        return float(x)\n    ax = abs(x)\n    if ax == 0.0:\n        return 0.0\n    e = int(np.floor(np.log10(ax)))\n    scale = 10.0 ** (e - sig + 1)\n    rounded = round(ax / scale) * scale\n    return np.copysign(rounded, x)\n\ndef credible_interval_D(T, a, d, mu_Ea, sigma_Ea, mu_ln_nu, sigma_ln_nu, N, rng):\n    \"\"\"\n    Compute equal-tailed 95% credible interval for diffusion coefficient D given parameters.\n    Units:\n      - T in K\n      - a in m\n      - d dimensionless\n      - mu_Ea, sigma_Ea in eV\n      - mu_ln_nu, sigma_ln_nu dimensionless (natural log of s^-1)\n      - N number of samples\n    Returns (lower, upper) in m^2/s as floats (rounded to 3 significant figures).\n    \"\"\"\n    # Boltzmann constant in eV/K\n    kB_eV_per_K = 8.617333262e-5\n\n    # Sample Ea from Normal and truncate at 0 (physical constraint Ea >= 0)\n    Ea_samples = rng.normal(loc=mu_Ea, scale=sigma_Ea, size=N)\n    Ea_samples = np.maximum(Ea_samples, 0.0)\n\n    # Sample ln(nu) from Normal, then exponentiate to get nu (log-normal)\n    ln_nu_samples = rng.normal(loc=mu_ln_nu, scale=sigma_ln_nu, size=N)\n    nu_samples = np.exp(ln_nu_samples)\n\n    # Compute hop rates: k = nu * exp(-Ea / (kB * T))\n    beta = 1.0 / (kB_eV_per_K * T)  # 1 / (eV)\n    # Guard against overflow/underflow: exponent argument is negative, safe for realistic values.\n    k_samples = nu_samples * np.exp(-Ea_samples * beta)\n\n    # Diffusion coefficient: D = a^2 * k / (2 * d)\n    D_samples = (a * a) * k_samples / (2.0 * d)\n\n    # Compute equal-tailed 95% credible interval\n    lower, upper = np.quantile(D_samples, [0.025, 0.975], method=\"linear\")\n\n    # Round to three significant figures\n    lower_rounded = round_sig(float(lower), sig=3)\n    upper_rounded = round_sig(float(upper), sig=3)\n\n    return lower_rounded, upper_rounded\n\ndef solve():\n    # Fixed random seed for reproducibility\n    rng = np.random.default_rng(seed=42)\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (T [K], a [m], d, mu_Ea [eV], sigma_Ea [eV], mu_ln_nu, sigma_ln_nu, N)\n    test_cases = [\n        (800.0, 2.5e-10, 2, 0.45, 0.05, np.log(1.0e13), 0.4, 40000),\n        (300.0, 2.5e-10, 2, 0.90, 0.10, np.log(5.0e12), 0.3, 60000),\n        (1000.0, 2.5e-10, 1, 0.20, 0.02, np.log(1.0e12), 0.2, 50000),\n        (1200.0, 5.43e-10, 3, 3.50, 0.30, np.log(1.0e13), 0.5, 80000),\n        (600.0, 3.0e-10, 2, 0.60, 0.15, np.log(2.0e13), 1.0, 70000),\n    ]\n\n    results = []\n    for case in test_cases:\n        T, a, d, mu_Ea, sigma_Ea, mu_ln_nu, sigma_ln_nu, N = case\n        lower, upper = credible_interval_D(T, a, d, mu_Ea, sigma_Ea, mu_ln_nu, sigma_ln_nu, N, rng)\n        results.append([lower, upper])\n\n    # Final print statement in the exact required format.\n    # Produce a single line of output with the nested list of credible intervals.\n    # Ensure plain representation of floats.\n    print(f\"[{','.join('[' + ','.join(map(str, pair)) + ']' for pair in results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}