{
    "hands_on_practices": [
        {
            "introduction": "在深入研究应力对器件性能的复杂影响之前，我们首先需要解决一个基本问题：我们如何测量薄膜中的应力？本练习将引导你推导并应用Stoney方程，这是将宏观可测量的晶圆曲率与微观薄膜应力联系起来的关键工具。通过这个实践，你不仅能掌握一个核心的应力表征方法，还将学习如何进行严谨的测量不确定度分析，这是任何实验和建模工作中都不可或缺的技能。",
            "id": "4132811",
            "problem": "一项微电子工艺流程仿真需要等双轴薄膜应力来参数化后续热处理步骤中与应力相关的扩散和图形变形。在一个沉积步骤之后，测量得到一个圆形硅片具有均匀的曲率。将该硅片视为一个各向同性、均匀的板，并将沉积的薄膜视为一个比基底薄得多的均匀、等双轴应力层。仅从线性弹性力学和经典各向同性板弯曲理论出发，推导薄膜应力与测得的硅片曲率之间的关系。\n\n假设晶体硅基底和氮化硅薄膜具有以下测量值和材料参数：\n- 测得的曲率（定义为 $k = 1/R$，其中 $R$ 是曲率半径）：$k = 1.000 \\times 10^{-3} \\,\\mathrm{m}^{-1}$，标准不确定度 $u_k = 5.00 \\times 10^{-6} \\,\\mathrm{m}^{-1}$。\n- 基底厚度：$t_s = 775 \\,\\mu\\mathrm{m}$，标准不确定度 $u_{t_s} = 1.00 \\,\\mu\\mathrm{m}$。\n- 薄膜厚度：$t_f = 100 \\,\\mathrm{nm}$，标准不确定度 $u_{t_f} = 0.50 \\,\\mathrm{nm}$。\n- 基底杨氏模量：$E_s = 130 \\,\\mathrm{GPa}$，标准不确定度 $u_{E_s} = 1.00 \\,\\mathrm{GPa}$。\n- 基底泊松比：$\\nu_s = 0.28$，标准不确定度 $u_{\\nu_s} = 0.010$。\n\n使用与《测量不确定度表示指南》（GUM）一致的不确定度传播定律，假设所有输入量都是独立且不相关的，传播不确定度以获得计算出的薄膜应力的标准不确定度。清楚地说明所使用的任何理想化假设。\n\n计算薄膜应力的数值及其标准不确定度。将应力及其不确定度均以兆帕（MPa）为单位表示。将应力四舍五入至四位有效数字，将标准不确定度四舍五入至两位有效数字。最终答案必须以一对数字的形式给出，分别对应应力及其标准不确定度。",
            "solution": "该问题具有科学依据，提法恰当且客观。它提出了一个薄膜力学中的标准问题，具有物理上合理的参数，并要求基于线性弹性力学和板理论的基本原理进行推导和计算，然后进行标准的不确定度分析。所有必要信息都已提供，没有矛盾或含糊之处。因此，该问题被认为是有效的，并将提供完整的解答。\n\n主要任务是推导薄膜中的内应力 $\\sigma_f$ 与其在厚得多的基底中引起的曲率 $k$ 之间的关系。这个关系式就是著名的Stoney方程。推导从经典板理论和线性弹性力学的原理出发，并基于以下几个关键的理想化假设：\n1.  薄膜比基底薄得多，即 $t_f \\ll t_s$。这使我们可以忽略薄膜本身的抗弯刚度，并假设复合结构的中性弯曲面位于基底的中面。\n2.  基底被视为一个均匀、各向同性、线性弹性的板。\n3.  变形很小，这与线性弹性力学的假设一致。\n4.  薄膜具有均匀、等双轴的应力 $\\sigma_f$。\n5.  引起的曲率 $k$ 在整个硅片上是均匀的。\n\n设基底的厚度为 $t_s$，杨氏模量为 $E_s$，泊松比为 $\\nu_s$。设薄膜的厚度为 $t_f$。薄膜中的等双轴应力 $\\sigma_f$ 在界面处对基底施加一个单位长度上的力 $F'$，其大小为 $F' = \\sigma_f t_f$。\n\n这个力作用在界面上，但基底是围绕其中性轴弯曲的。由于 $t_f \\ll t_s$ 的近似，中性轴位于基底的中心，距离界面为 $t_s/2$。因此，这个力在基底中产生了一个单位长度上的弯矩 $M'$：\n$$\nM' = F' \\cdot \\frac{t_s}{2} = (\\sigma_f t_f) \\frac{t_s}{2}\n$$\n根据经典板理论，对于处于等双轴弯曲（$k_x = k_y = k$）下的各向同性材料，施加的单位长度弯矩 $M'$ 与产生的曲率 $k$ 之间的关系是：\n$$\nM' = D k (1 + \\nu_s)\n$$\n其中 $D$ 是板的抗弯刚度，定义为：\n$$\nD = \\frac{E_s t_s^3}{12(1-\\nu_s^2)}\n$$\n将 $D$ 的表达式代入弯矩-曲率关系式中：\n$$\nM' = \\frac{E_s t_s^3}{12(1-\\nu_s^2)} k (1 + \\nu_s) = \\frac{E_s t_s^3 k (1 + \\nu_s)}{12(1-\\nu_s)(1+\\nu_s)} = \\frac{E_s t_s^3 k}{12(1-\\nu_s)}\n$$\n现在，我们将弯矩 $M'$ 的两个表达式相等：\n$$\n(\\sigma_f t_f) \\frac{t_s}{2} = \\frac{E_s t_s^3 k}{12(1-\\nu_s)}\n$$\n求解薄膜应力 $\\sigma_f$，我们得到Stoney方程：\n$$\n\\sigma_f = \\frac{E_s t_s^2 k}{6(1-\\nu_s)t_f}\n$$\n这就是所要求的关系式。$\\sigma_f$ 的正值对应于薄膜中的拉应力，这会导致硅片弯曲成凹形（正曲率）。\n\n接下来，我们使用所提供的数据计算薄膜应力的数值。所有数值都转换为国际单位制（SI）基本单位（米，帕斯卡）。\n- $k = 1.000 \\times 10^{-3} \\,\\mathrm{m}^{-1}$\n- $t_s = 775 \\,\\mu\\mathrm{m} = 775 \\times 10^{-6} \\,\\mathrm{m}$\n- $t_f = 100 \\,\\mathrm{nm} = 100 \\times 10^{-9} \\,\\mathrm{m}$\n- $E_s = 130 \\,\\mathrm{GPa} = 130 \\times 10^9 \\,\\mathrm{Pa}$\n- $\\nu_s = 0.28$\n\n将这些值代入Stoney方程：\n$$\n\\sigma_f = \\frac{(130 \\times 10^9 \\,\\mathrm{Pa}) (775 \\times 10^{-6} \\,\\mathrm{m})^2 (1.000 \\times 10^{-3} \\,\\mathrm{m}^{-1})}{6(1 - 0.28)(100 \\times 10^{-9} \\,\\mathrm{m})}\n$$\n$$\n\\sigma_f = \\frac{(1.30 \\times 10^{11}) \\cdot (6.00625 \\times 10^{-7}) \\cdot (1.000 \\times 10^{-3})}{6(0.72)(1.00 \\times 10^{-7})} \\,\\mathrm{Pa}\n$$\n$$\n\\sigma_f = \\frac{7.808125 \\times 10^1}{0.432} \\,\\mathrm{Pa} \\approx 1.807436 \\times 10^8 \\,\\mathrm{Pa} = 180.7436 \\,\\mathrm{MPa}\n$$\n按要求四舍五入至四位有效数字，薄膜应力为 $\\sigma_f \\approx 180.7 \\,\\mathrm{MPa}$。\n\n最后，我们传播不确定度。函数为 $\\sigma_f = \\sigma_f(E_s, t_s, k, t_f, \\nu_s)$。对于独立的输入量，合成标准不确定度的平方 $u^2(\\sigma_f)$ 由不确定度传播定律给出：\n$$\nu^2(\\sigma_f) = \\sum_i \\left( \\frac{\\partial \\sigma_f}{\\partial x_i} u_{x_i} \\right)^2\n$$\n使用相对不确定度进行计算会更方便。两边同除以 $\\sigma_f^2$：\n$$\n\\left(\\frac{u(\\sigma_f)}{\\sigma_f}\\right)^2 = \\left(\\frac{u_{E_s}}{E_s}\\right)^2 + \\left(2\\frac{u_{t_s}}{t_s}\\right)^2 + \\left(\\frac{u_k}{k}\\right)^2 + \\left(\\frac{u_{t_f}}{t_f}\\right)^2 + \\left(\\frac{u_{\\nu_s}}{1-\\nu_s}\\right)^2\n$$\n我们计算每一项的相对不确定度平方：\n- $u_{E_s}/E_s = (1.00 \\,\\mathrm{GPa}) / (130 \\,\\mathrm{GPa}) = 1/130$。项：$(1/130)^2 \\approx 5.917 \\times 10^{-5}$。\n- $u_{t_s}/t_s = (1.00 \\,\\mu\\mathrm{m}) / (775 \\,\\mu\\mathrm{m}) = 1/775$。项：$(2 \\cdot 1/775)^2 \\approx 6.660 \\times 10^{-6}$。\n- $u_k/k = (5.00 \\times 10^{-6} \\,\\mathrm{m}^{-1}) / (1.000 \\times 10^{-3} \\,\\mathrm{m}^{-1}) = 0.005$。项：$(0.005)^2 = 2.500 \\times 10^{-5}$。\n- $u_{t_f}/t_f = (0.50 \\,\\mathrm{nm}) / (100 \\,\\mathrm{nm}) = 0.005$。项：$(0.005)^2 = 2.500 \\times 10^{-5}$。\n- $u_{\\nu_s}/(1-\\nu_s) = 0.010 / (1 - 0.28) = 0.010/0.72$。项：$(0.010/0.72)^2 \\approx 1.929 \\times 10^{-4}$。\n\n将各项相加：\n$$\n\\left(\\frac{u(\\sigma_f)}{\\sigma_f}\\right)^2 \\approx (5.917 + 0.666 + 2.500 + 2.500 + 19.29) \\times 10^{-5} = 3.0873 \\times 10^{-4}\n$$\n因此，相对不确定度为：\n$$\n\\frac{u(\\sigma_f)}{\\sigma_f} = \\sqrt{3.0873 \\times 10^{-4}} \\approx 0.01757\n$$\n应力的绝对标准不确定度 $u(\\sigma_f)$ 为：\n$$\nu(\\sigma_f) = \\sigma_f \\cdot \\frac{u(\\sigma_f)}{\\sigma_f} \\approx (180.7436 \\,\\mathrm{MPa}) \\cdot (0.01757) \\approx 3.176 \\,\\mathrm{MPa}\n$$\n按要求将标准不确定度四舍五入至两位有效数字，得到 $u(\\sigma_f) \\approx 3.2 \\,\\mathrm{MPa}$。\n\n计算出的薄膜应力为 $180.7 \\,\\mathrm{MPa}$，其标准不确定度为 $3.2 \\,\\mathrm{MPa}$。",
            "answer": "$$\n\\boxed{\\begin{pmatrix} 180.7 & 3.2 \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "虽然Stoney方程等简化模型在初步分析中很有用，但精确的工艺模拟必须考虑真实材料的复杂性。作为一种单晶材料，硅的力学行为是各向异性的，其弹性响应取决于晶向。本练习将带你直面这一挑战，学习如何在工艺流程中（如晶圆旋转或切割）发生坐标系变化时，正确地变换四阶刚度张量 $C_{ijkl}$，以确保应力计算的准确性。",
            "id": "4132792",
            "problem": "一块单晶硅片表现出立方各向异性弹性，其特性由在与晶轴 $[100]$、$[010]$ 和 $[001]$ 对齐的晶体参考系中的四阶刚度张量 $C_{ijkl}$ 来表征。该晶片经过一个制造工艺流程，在流程中的不同步骤之间，由于晶片旋转和切割等操作，它会进行机械重新定向。工艺流程模拟必须通过根据晶片在每一步的方向对刚度张量进行变换，来包含这些重定向对弹性响应的影响。\n\n你需要实现一个程序，对于应用于晶片的一系列指定的刚性旋转，计算在实验室坐标系中的变换后刚度张量 $C'_{pqrs}$，并报告选定的分量，以供下游工艺模型使用。\n\n从以下基本原理开始：\n- 线性弹性力学中的柯西应力-应变关系为 $\\sigma_{ij} = C_{ijkl}\\,\\varepsilon_{kl}$，其中 $\\sigma_{ij}$ 是二阶柯西应力张量，$\\varepsilon_{kl}$ 是二阶无穷小应变张量，$C_{ijkl}$ 是四阶刚度张量。\n- 根据线性代数和刚体运动学的法则，二阶张量和向量的分量在正常正交基变换下进行变换。使用这些原理推导当晶片被一个正常正交旋转操作时，四阶刚度张量的变换法则。\n\n假设与数据：\n- 立方硅在室温下的晶体坐标系刚度由三个独立常数指定：$C_{11} = 165.7$ 吉帕斯卡 (GPa)，$C_{12} = 63.9$ GPa，以及 $C_{44} = 79.6$ GPa。使用这些值在晶体坐标系中构建 $C_{ijkl}$。克罗内克 δ (Kronecker delta) 为 $\\delta_{ij}$，晶轴是标准基向量 $\\mathbf{e}_1 = (1,0,0)$、$\\mathbf{e}_2 = (0,1,0)$、$\\mathbf{e}_3 = (0,0,1)$。\n- 所有旋转都是行列式为 $+1$ 的正常正交旋转，围绕实验室坐标轴 $\\hat{x}$、$\\hat{y}$ 和 $\\hat{z}$ 进行，并按给定的顺序应用。使用右手定则确定旋转方向。\n- 角度值以度为单位提供；你必须使用度并在内部需要时转换为弧度。\n- 所有刚度分量均以吉帕斯卡 (GPa) 为单位报告。\n\n任务：\n1. 从所述基本原理出发，推导四阶刚度张量在刚性旋转下的正确变换，确保与二阶张量的变换规则一致。\n2. 实现一个函数，用于根据 $C_{11}$、$C_{12}$ 和 $C_{44}$，使用 $\\delta_{ij}$ 和晶轴的标准张量构造方法，构建立方晶体的晶体坐标系四阶刚度张量 $C_{ijkl}$。\n3. 实现绕 $\\hat{x}$、$\\hat{y}$ 和 $\\hat{z}$ 轴按给定角度（度）旋转的旋转矩阵，并按给定顺序组合多次旋转，为每个工艺步骤序列形成从晶体坐标系到实验室坐标系的总旋转。\n4. 应用推导出的变换以获得实验室坐标系刚度 $C'_{pqrs}$，并提取分量 $C'_{1111}$、$C'_{1122}$ 和 $C'_{1212}$，以吉帕斯卡 (GPa) 表示。将每个报告值四舍五入到六位小数。\n\n测试套件：\n使用以下四个测试用例，每个用例由按顺序应用于晶片的一系列旋转定义：\n- 用例 A（基线，无旋转）：一个空序列。\n- 用例 B（四重对称性检查）：绕 $\\hat{z}$ 轴单次旋转 $90$ 度。\n- 用例 C（一般平面内旋转）：绕 $\\hat{z}$ 轴单次旋转 $45$ 度。\n- 用例 D（复合工艺重定向）：绕 $\\hat{z}$ 轴旋转 $30$ 度，然后绕 $\\hat{x}$ 轴旋转 $180$ 度。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个用例由一个包含三个浮点数 $[C'_{1111}, C'_{1122}, C'_{1212}]$ 的列表表示，单位为 GPa，四舍五入到六位小数。因此，总输出是一个列表的列表，按 A、B、C、D 的顺序排列。例如，输出应如下所示：\n[[a11,a12,a66],[b11,b12,b66],[c11,c12,c66],[d11,d12,d66]]\n其中每个符号代表一个 GPa 单位的浮点数，保留六位小数。",
            "solution": "问题陈述已经过严格审查，并被确定为 **有效**。其科学基础是连续介质力学原理，问题提法完善，数据完整且一致，并且在客观、正式的语言中表述。这些任务在计算上是可行的，并与半导体工艺模拟领域相关。\n\n### 1. 四阶刚度张量变换法则的推导\n\n在线性弹性材料中，柯西应力张量 $\\sigma$ 与无穷小应变张量 $\\varepsilon$ 之间的关系由广义胡克定律给出：\n$$ \\sigma_{ij} = C_{ijkl} \\varepsilon_{kl} $$\n其中 $C_{ijkl}$ 是四阶刚度张量。此方程是一个张量关系，其形式在坐标系变换下必须保持不变。\n\n让我们考虑两个笛卡尔坐标系：实验室坐标系，其基向量为 $\\{\\mathbf{e}_p\\}$；以及晶体坐标系，其基向量为 $\\{\\mathbf{e'}_i\\}$。晶体坐标系是通过对实验室坐标系进行刚性旋转得到的。设该旋转由一个正常正交矩阵 $R$ 描述，其分量为 $R_{ip} = \\mathbf{e'}_i \\cdot \\mathbf{e}_p$。一个向量 $\\mathbf{v}$ 在这两个坐标系中的分量通过 $v'_i = R_{ij} v_j$ 相关联。\n\n二阶张量（如应力 $\\sigma$ 和应变 $\\varepsilon$）的分量根据以下法则进行变换：\n$$ \\sigma'_{pq} = R_{pi} R_{qj} \\sigma_{ij} $$\n$$ \\varepsilon'_{rs} = R_{rk} R_{sl} \\varepsilon_{kl} $$\n此处，带撇号的分量在晶体坐标系中，不带撇号的分量在实验室坐标系中。\n\n本构关系在晶体坐标系中定义，在该坐标系中，刚度张量 $C^{crys}$ 具有其最简单的形式，由常数 $C_{11}、C_{12}、C_{44}$ 指定。\n$$ \\sigma'_{pq} = C^{crys}_{pqrs} \\varepsilon'_{rs} $$\n为了找到在实验室坐标系中的本构关系 $\\sigma_{ij} = C^{lab}_{ijkl} \\varepsilon_{kl}$，我们将变换法则代入晶体坐标系方程中：\n$$ R_{pi} R_{qj} \\sigma_{ij} = C^{crys}_{pqrs} (R_{rk} R_{sl} \\varepsilon_{kl}) $$\n为了分离出 $\\sigma_{ab}$，我们使用旋转矩阵的正交性 $R_{ap} R_{pi} = \\delta_{ai}$，前乘以其逆矩阵（转置矩阵）：\n$$ (R_{ap} R_{bq}) (R_{pi} R_{qj} \\sigma_{ij}) = (R_{ap} R_{bq}) C^{crys}_{pqrs} R_{rk} R_{sl} \\varepsilon_{kl} $$\n$$ \\delta_{ai} \\delta_{bj} \\sigma_{ij} = (R_{ap} R_{bq} R_{rk} R_{sl}) C^{crys}_{pqrs} \\varepsilon_{kl} $$\n$$ \\sigma_{ab} = (R_{ap} R_{bq} R_{rk} R_{sl} C^{crys}_{pqrs}) \\varepsilon_{kl} $$\n通过将其与 $\\sigma_{ab} = C^{lab}_{abkl} \\varepsilon_{kl}$ 进行比较，我们确定实验室坐标系刚度张量的分量为：\n$$ C^{lab}_{abkl} = R_{ap} R_{bq} R_{rk} R_{sl} C^{crys}_{pqrs} $$\n这是四阶刚度张量的变换法则。正确识别矩阵 $R$ 至关重要。问题描述了应用于晶片的一系列旋转。这对应于晶体的主动旋转。如果晶轴被矩阵 $M$ 旋转，则从实验室坐标系到新晶体坐标系的向量分量变换矩阵为 $R=M^{-1}=M^T$。然而，更直接的方法是将张量分量从晶体坐标系变换到实验室坐标系。设 $M$ 是将向量分量从晶体的局部坐标系变换到实验室坐标系的旋转矩阵。那么刚度张量分量变换如下：\n$$ C^{lab}_{pqrs} = M_{pi} M_{qj} M_{rk} M_{sl} C^{crys}_{ijkl} $$\n这将是我们将要实现的方程。\n\n### 2. 立方刚度张量的构建\n\n对于具有立方对称性的晶体，刚度张量 $C_{ijkl}$ 只有三个独立的非零分量：$C_{1111}$、$C_{1122}$ 和 $C_{1212}$。根据给定的常数 $C_{11}$、$C_{12}$ 和 $C_{44}$，可以构建出完整的张量。立方刚度张量的一个通用且稳健的表示方法如下：\n$$ C_{ijkl} = C_{12} \\delta_{ij} \\delta_{kl} + C_{44} (\\delta_{ik}\\delta_{jl} + \\delta_{il}\\delta_{jk}) + (C_{11} - C_{12} - 2C_{44}) \\sum_{m=1}^{3} \\delta_{im} \\delta_{jm} \\delta_{km} \\delta_{lm} $$\n其中 $\\delta_{ij}$ 是克罗内克 δ。求和项仅对 $C_{mmmm} = C_{1111}, C_{2222}, C_{3333}$ 形式的对角分量非零。该公式能正确生成张量的所有分量，例如：\n- $C_{1111} = C_{12} + 2C_{44} + (C_{11} - C_{12} - 2C_{44}) = C_{11}$\n- $C_{1122} = C_{12} + 0 + 0 = C_{12}$\n- $C_{1212} = 0 + C_{44}(\\delta_{11}\\delta_{22} + \\delta_{12}\\delta_{21}) + 0 = C_{44}$\n此构造将通过迭代 $3 \\times 3 \\times 3 \\times 3$ 张量的所有 $3^4 = 81$ 个分量，并根据索引 $i, j, k, l$ 赋值来实现。\n\n### 3. 旋转矩阵的组合\n\n问题指定了绕固定的实验室坐标轴 $\\hat{x}, \\hat{y}, \\hat{z}$ 的旋转序列。对于按顺序应用的旋转序列 $M_1, M_2, \\dots, M_n$，最终方向由复合旋转矩阵 $M_{total}$ 描述：\n$$ M_{total} = M_n \\dots M_2 M_1 $$\n绕标准轴旋转角度 $\\theta$ 的旋转矩阵为：\n$$ R_x(\\theta) = \\begin{pmatrix} 1 & 0 & 0 \\\\ 0 & \\cos\\theta & -\\sin\\theta \\\\ 0 & \\sin\\theta & \\cos\\theta \\end{pmatrix} $$\n$$ R_y(\\theta) = \\begin{pmatrix} \\cos\\theta & 0 & \\sin\\theta \\\\ 0 & 1 & 0 \\\\ -\\sin\\theta & 0 & \\cos\\theta \\end{pmatrix} $$\n$$ R_z(\\theta) = \\begin{pmatrix} \\cos\\theta & -\\sin\\theta & 0 \\\\ \\sin\\theta & \\cos\\theta & 0 \\\\ 0 & 0 & 1 \\end{pmatrix} $$\n以度为单位提供的角度将被转换为弧度以用于三角函数：$\\theta_{rad} = \\theta_{deg} \\times \\frac{\\pi}{180}$。复合矩阵 $M_{total}$ 将作为张量变换方程中的变换矩阵 $M$。\n\n### 4. 计算策略\n\n解决方案将使用 NumPy 库在 Python 中实现。\n1.  **刚度张量构建：** 一个 `build_stiffness_tensor` 函数将使用提供的 $C_{11}, C_{12}, C_{44}$ 值和第 2 节的公式创建用于 $C^{crys}_{ijkl}$ 的 $3 \\times 3 \\times 3 \\times 3$ NumPy 数组。\n2.  **旋转矩阵计算：** 一个 `get_rotation_matrix` 函数将为给定的轴和角度（以度为单位）生成相应的 $3 \\times 3$ 旋转矩阵。\n3.  **变换循环：** 对于每个测试用例：\n    a. 将总旋转矩阵 $M$ 初始化为 $3 \\times 3$ 单位矩阵。\n    b. 对于指定序列中的每次旋转，计算基本旋转矩阵并通过左乘更新总旋转：$M \\leftarrow M_{step} \\cdot M$。\n    c. 使用 `numpy.einsum` 将最终的变换矩阵 $M$ 应用于 $C^{crys}$ 以计算 $C^{lab}$，该函数对于此类张量缩并非常高效：\n    `C_lab = np.einsum('pi,qj,rk,sl,ijkl->pqrs', M, M, M, M, C_crys)`\n4.  **结果提取：** 计算出 $C^{lab}$ 后，使用基于 0 的索引提取所需的分量：$C'_{1111} \\equiv C^{lab}[0,0,0,0]$，$C'_{1122} \\equiv C^{lab}[0,0,1,1]$，以及 $C'_{1212} \\equiv C^{lab}[0,1,0,1]$。\n5.  **输出格式化：** 提取的值将被四舍五入到六位小数，并格式化为指定的列表的列表字符串表示形式。基线情况（无旋转）可作为验证检查，因为它应返回原始的弹性常数。绕 $\\hat{z}$ 轴旋转 $90^\\circ$ 的情况测试了实现对立方对称性的处理，因为张量必须保持不变。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef build_stiffness_tensor(c11, c12, c44):\n    \"\"\"\n    Builds the 4th-order stiffness tensor for a cubic crystal.\n    \n    Args:\n        c11 (float): C11 elastic constant in GPa.\n        c12 (float): C12 elastic constant in GPa.\n        c44 (float): C44 elastic constant in GPa.\n\n    Returns:\n        np.ndarray: A 3x3x3x3 numpy array representing the stiffness tensor C_ijkl.\n    \"\"\"\n    C = np.zeros((3, 3, 3, 3))\n    \n    # Anisotropy factor\n    anisotropy_factor = c11 - c12 - 2 * c44\n    \n    for i in range(3):\n        for j in range(3):\n            for k in range(3):\n                for l in range(3):\n                    # C12 part\n                    if i == j and k == l:\n                        C[i, j, k, l] += c12\n                    \n                    # C44 part\n                    if i == k and j == l:\n                        C[i, j, k, l] += c44\n                    if i == l and j == k:\n                        C[i, j, k, l] += c44\n\n                    # Anisotropy part (only for C_iiii)\n                    if i == j == k == l:\n                        C[i, j, k, l] += anisotropy_factor\n    return C\n\n\ndef get_rotation_matrix(axis, angle_deg):\n    \"\"\"\n    Generates a 3x3 rotation matrix for a given axis and angle.\n    \n    Args:\n        axis (str): The axis of rotation ('x', 'y', or 'z').\n        angle_deg (float): The angle of rotation in degrees.\n    \n    Returns:\n        np.ndarray: The 3x3 rotation matrix.\n    \"\"\"\n    angle_rad = np.deg2rad(angle_deg)\n    c = np.cos(angle_rad)\n    s = np.sin(angle_rad)\n    \n    if axis == 'x':\n        return np.array([[1, 0, 0], [0, c, -s], [0, s, c]])\n    elif axis == 'y':\n        return np.array([[c, 0, s], [0, 1, 0], [-s, 0, c]])\n    elif axis == 'z':\n        return np.array([[c, -s, 0], [s, c, 0], [0, 0, 1]])\n    else:\n        raise ValueError(\"Invalid rotation axis. Must be 'x', 'y', or 'z'.\")\n\ndef transform_stiffness_tensor(C_crys, M):\n    \"\"\"\n    Transforms the stiffness tensor from the crystal to the lab frame.\n    \n    Args:\n        C_crys (np.ndarray): The 3x3x3x3 stiffness tensor in the crystal frame.\n        M (np.ndarray): The 3x3 rotation matrix from crystal to lab frame.\n    \n    Returns:\n        np.ndarray: The 3x3x3x3 stiffness tensor in the lab frame.\n    \"\"\"\n    # C'_pqrs = M_pi * M_qj * M_rk * M_sl * C_ijkl\n    C_lab = np.einsum('pi,qj,rk,sl,ijkl->pqrs', M, M, M, M, C_crys, optimize=True)\n    return C_lab\n\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases.\n    \"\"\"\n    # Silicon stiffness constants in GPa\n    C11 = 165.7\n    C12 = 63.9\n    C44 = 79.6\n\n    # Build the stiffness tensor in the crystal frame\n    C_crystal = build_stiffness_tensor(C11, C12, C44)\n\n    # Define the test cases from the problem statement.\n    test_cases = {\n        'A': [],\n        'B': [('z', 90.0)],\n        'C': [('z', 45.0)],\n        'D': [('z', 30.0), ('x', 180.0)]\n    }\n\n    results = []\n\n    # Process each test case in order A, B, C, D\n    for case_id in sorted(test_cases.keys()):\n        rotations = test_cases[case_id]\n        \n        # Start with identity matrix for the total rotation\n        M_total = np.identity(3)\n        \n        # Compose rotations\n        for axis, angle in rotations:\n            M_step = get_rotation_matrix(axis, angle)\n            # The new rotation is applied to the already rotated object,\n            # so we left-multiply. M_total = M_n * ... * M_1\n            M_total = np.dot(M_step, M_total)\n\n        # Transform the stiffness tensor\n        C_lab = transform_stiffness_tensor(C_crystal, M_total)\n\n        # Extract required components (using 0-based indexing)\n        c_1111 = C_lab[0, 0, 0, 0]\n        c_1122 = C_lab[0, 0, 1, 1]\n        c_1212 = C_lab[0, 1, 0, 1]\n\n        # Round to 6 decimal places and store\n        case_results = [\n            round(c_1111, 6),\n            round(c_1122, 6),\n            round(c_1212, 6)\n        ]\n        results.append(case_results)\n\n    # Format the final output string as a list of lists.\n    # str() includes spaces, so we remove them to match the required format.\n    final_output = str(results).replace(\" \", \"\")\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "本章的最终练习将前面所学的概念整合到一个动态的、多步骤的工艺流程模拟中。在真实的制造过程中，应力并非一成不变，它会随着时间和热处理而演化。本练习旨在模拟这一过程，你将推导应力随时间松弛的模型，实现应力状态在不同工艺步骤间的传递，并最终将计算出的应力与关键的器件性能参数——电子迁移率——直接关联起来。",
            "id": "4132784",
            "problem": "要求您实现一种有原则的方法，在工艺流程模拟中跨越离散的工艺步骤来传递应力相关的电子迁移率状态变量，并使用具有受控外施应力的测试结构来验证该方法。该问题必须通过从第一性原理和半导体工艺建模及连续介质力学中广为接受的模型推导，然后设计一个算法来跨步骤传播状态来解决。\n\n从以下基本原理和事实开始：\n\n1. 连续介质热激活弛豫：在温度为 $T$、持续时间为 $\\Delta t$ 的等温步骤下，内部单轴残余应力状态 $\\sigma_{x}(t)$ 会朝着外部控制的外施单轴应力 $\\sigma_{\\mathrm{app}}$ 演化，遵循与麦克斯韦型弛豫一致的一阶线性常微分方程：\n$$\n\\frac{d \\sigma_{x}}{dt} = - \\frac{\\sigma_{x} - \\sigma_{\\mathrm{app}}}{\\tau(T)},\n$$\n其中弛豫时间服从阿伦尼乌斯动力学：\n$$\n\\tau(T) = \\tau_{0} \\exp\\!\\left(\\frac{E_{a}}{k_{B} T}\\right),\n$$\n其中 $E_{a}$ 是活化能，$k_{B}$ 是玻尔兹曼常数，$\\tau_{0}$ 是指前因子。\n\n2. 各向同性张量不变量和小应力迁移率微扰：对于小弹性应力，标量电子迁移率 $\\mu_{n}$ 是应力的各向同性函数，因此可以在柯西应力张量 $\\boldsymbol{\\sigma}$ 的不变量中展开到一阶。对于与沟道方向（$x$轴）对齐的单轴应力状态 $\\boldsymbol{\\sigma} = \\mathrm{diag}(\\sigma_{x}, 0, 0)$，对标量输运系数有一阶影响的两个独立不变量是静水应力 $\\sigma_{h} = \\mathrm{tr}(\\boldsymbol{\\sigma})/3$ 和偏应力第二不变量的平方根 $\\sqrt{J_{2}}$，其中 $J_{2} = \\tfrac{1}{2}\\,\\mathbf{s}:\\mathbf{s}$ 且 $\\mathbf{s} = \\boldsymbol{\\sigma} - \\sigma_{h}\\mathbf{I}$。对于单轴情况，$\\sqrt{J_{2}} = |\\sigma_{x}|/\\sqrt{3}$。假设电子迁移率关于零应力的一阶线性化使用这些不变量，其常数系数待确定。\n\n3. 单位：所有量必须使用国际单位制（SI）。具体来说，应力单位为帕斯卡（Pa），温度单位为开尔文（K），时间单位为秒（s），迁移率单位为平方米/伏特·秒（m$^{2}$/V·s）。如果 $E_{a}$ 以电子伏特（eV）为单位提供，则玻尔兹曼常数 $k_{B}$ 必须使用电子伏特/开尔文（eV/K）。\n\n任务要求：\n\na) 推导一个解析的、针对每一步的 $\\sigma_{x}$ 更新规则，该规则在给定步骤中恒定的 $T$、$\\Delta t$ 和 $\\sigma_{\\mathrm{app}}$ 的情况下，将状态从工艺步骤的开始传播到结束，其形式应适合稳定的数值实现和多步骤的组合。\n\nb) 基于不变量展开的前提，推导电子迁移率 $\\mu_{n}$ 作为单轴应力 $\\sigma_{x}$ 函数的一阶小应力关系，使用对应于静水压力和畸变分量的两个系数。\n\nc) 设计一个算法，对于每个测试结构，在流程开始时初始化内部应力状态 $\\sigma_{x}$，然后在工艺步骤序列中应用每步更新规则以获得最终应力，并最后根据推导的基于不变量的表达式计算最终电子迁移率 $\\mu_{n}$。除了通过物理弛豫动力学外，严格地将状态从一个步骤传递到下一个步骤，不丢失历史信息。\n\nd) 使用受控应力测试结构进行验证：使用提供的测试套件，其中每个测试结构在指定的温度和持续时间下经受已知的施加单轴应力序列 $\\sigma_{\\mathrm{app}}$。受控的应力值作为验证激励；您的程序必须计算每种情况下的最终电子迁移率。\n\n使用的数值数据和常数：\n\n- 零应力下的参考电子迁移率：$\\mu_{n,0} = 0.045$ m$^{2}$/V·s。\n- 线性化不变量模型中电子的静水压力和畸变系数：$a_{h}^{(n)} = 1.0\\times 10^{-11}$ Pa$^{-1}$ 和 $a_{d}^{(n)} = 2.0\\times 10^{-11}$ Pa$^{-1}$。\n- 阿伦尼乌斯参数：$\\tau_{0} = 1.0\\times 10^{-7}$ s，$E_{a} = 1.5$ eV，$k_{B} = 8.617333262145\\times 10^{-5}$ eV/K。\n- 对于单轴应力 $\\boldsymbol{\\sigma} = \\mathrm{diag}(\\sigma_{x}, 0, 0)$，在评估迁移率微扰时，您必须使用 $\\sigma_{h} = \\sigma_{x}/3$ 和 $\\sqrt{J_{2}} = |\\sigma_{x}|/\\sqrt{3}$。\n\n测试套件：\n\n每个测试案例由一个初始内部单轴应力 $\\sigma_{x}(0)$（单位 Pa）和一系列工艺步骤定义，每个步骤由一个三元组 $(T, \\Delta t, \\sigma_{\\mathrm{app}})$ 给出，其中 $T$ 单位为 K，$\\Delta t$ 单位为 s，$\\sigma_{\\mathrm{app}}$ 单位为 Pa。\n\n- 案例1（理想路径，带有中等弛豫的拉伸偏置）：\n  - 初始 $\\sigma_{x}(0) = 0$ Pa。\n  - 步骤：\n    1) $(800,\\ 1200,\\ +2.0\\times 10^{8})$,\n    2) $(300,\\ 600,\\ +2.0\\times 10^{8})$.\n\n- 案例2（边界情况，全程施加零应力）：\n  - 初始 $\\sigma_{x}(0) = 0$ Pa。\n  - 步骤：\n    1) $(900,\\ 3600,\\ 0)$,\n    2) $(300,\\ 100,\\ 0)$.\n\n- 案例3（从压缩初始状态向拉伸状态的快速高温弛豫）：\n  - 初始 $\\sigma_{x}(0) = -1.0\\times 10^{8}$ Pa。\n  - 步骤：\n    1) $(1100,\\ 100,\\ +3.0\\times 10^{8})$,\n    2) $(1100,\\ 1000,\\ +3.0\\times 10^{8})$.\n\n- 案例4（恒温下交替的拉伸/压缩步骤，伴随部分跟踪）：\n  - 初始 $\\sigma_{x}(0) = 0$ Pa。\n  - 步骤：\n    1) $(800,\\ 200,\\ +2.0\\times 10^{8})$,\n    2) $(800,\\ 200,\\ -2.0\\times 10^{8})$,\n    3) $(800,\\ 200,\\ +2.0\\times 10^{8})$.\n\n所需输出和单位：\n\n- 对于每个测试案例，计算最后一步结束时的最终电子迁移率 $\\mu_{n}$，单位为 m$^{2}$/V·s，四舍五入到八位小数。\n- 您的程序应生成一行输出，其中包含用方括号括起来的逗号分隔结果列表（例如，“[0.04500000,0.04512345,0.04498765,0.04567890]”）。\n\n角度单位不适用。所有结果表示为十进制数，不带任何百分号。\n\n您的最终程序必须是自包含的，并且可以按原样运行，不得读取任何输入。它必须实现上述基于物理的推导和算法，以生成指定测试套件所需的输出。",
            "solution": "问题陈述已经过分析并确定为有效。它在科学上基于连续介质力学和半导体物理的既定原理，在数学上是适定的，并提供了一套自包含且明确的数据和要求。因此，我们可以着手解决。\n\n解决方案按要求分为四个部分：a) 应力更新规则的推导，b) 迁移率模型的推导，c) 计算算法的制定，以及 d) 应用于指定的测试案例。\n\na) 应力更新规则的推导\n\n内部单轴应力 $\\sigma_{x}$ 的演化由一阶线性常微分方程控制：\n$$\n\\frac{d \\sigma_{x}}{dt} = - \\frac{\\sigma_{x} - \\sigma_{\\mathrm{app}}}{\\tau(T)}\n$$\n对于单个工艺步骤，温度 $T$ 和外部施加的应力 $\\sigma_{\\mathrm{app}}$ 是恒定的。因此，弛豫时间 $\\tau(T)$ 在该步骤的持续时间 $\\Delta t$ 内也是恒定的。我们可以将方程重写为：\n$$\n\\frac{d \\sigma_{x}}{dt} + \\frac{1}{\\tau} \\sigma_{x} = \\frac{\\sigma_{\\mathrm{app}}}{\\tau}\n$$\n这是一个标准的非齐次线性一阶微分方程。其解可以使用积分因子 $I(t) = \\exp(\\int \\frac{dt}{\\tau}) = \\exp(t/\\tau)$ 来求得。将方程乘以 $I(t)$ 得到：\n$$\n\\exp(t/\\tau) \\frac{d \\sigma_{x}}{dt} + \\frac{1}{\\tau} \\exp(t/\\tau) \\sigma_{x} = \\frac{\\sigma_{\\mathrm{app}}}{\\tau} \\exp(t/\\tau)\n$$\n左侧是乘积的导数，即 $\\frac{d}{dt} \\left( \\sigma_{x}(t) \\exp(t/\\tau) \\right)$。因此：\n$$\n\\frac{d}{dt} \\left( \\sigma_{x}(t) \\exp(t/\\tau) \\right) = \\frac{\\sigma_{\\mathrm{app}}}{\\tau} \\exp(t/\\tau)\n$$\n我们在时间区间从 $t=0$ 到 $t=\\Delta t$ 上积分，这对应于工艺步骤的开始和结束。设步骤开始时的应力为 $\\sigma_{x, \\text{start}}$。\n$$\n\\int_{0}^{\\Delta t} \\frac{d}{dt} \\left( \\sigma_{x}(t) \\exp(t/\\tau) \\right) dt = \\int_{0}^{\\Delta t} \\frac{\\sigma_{\\mathrm{app}}}{\\tau} \\exp(t/\\tau) dt\n$$\n$$\n\\left[ \\sigma_{x}(t) \\exp(t/\\tau) \\right]_{0}^{\\Delta t} = \\left[ \\sigma_{\\mathrm{app}} \\exp(t/\\tau) \\right]_{0}^{\\Delta t}\n$$\n$$\n\\sigma_{x}(\\Delta t) \\exp(\\Delta t/\\tau) - \\sigma_{x}(0) \\exp(0) = \\sigma_{\\mathrm{app}} \\exp(\\Delta t/\\tau) - \\sigma_{\\mathrm{app}} \\exp(0)\n$$\n令 $\\sigma_{x, \\text{end}} = \\sigma_{x}(\\Delta t)$ 和 $\\sigma_{x, \\text{start}} = \\sigma_{x}(0)$，我们有：\n$$\n\\sigma_{x, \\text{end}} \\exp(\\Delta t/\\tau) - \\sigma_{x, \\text{start}} = \\sigma_{\\mathrm{app}} (\\exp(\\Delta t/\\tau) - 1)\n$$\n通过乘以 $\\exp(-\\Delta t/\\tau)$ 来求解 $\\sigma_{x, \\text{end}}$：\n$$\n\\sigma_{x, \\text{end}} = \\sigma_{x, \\text{start}} \\exp\\left(-\\frac{\\Delta t}{\\tau}\\right) + \\sigma_{\\mathrm{app}} \\left(1 - \\exp\\left(-\\frac{\\Delta t}{\\tau}\\right)\\right)\n$$\n这个方程可以重新整理成一个数值上稳定且物理上直观的形式。它将最终应力描述为初始应力和施加应力的凸组合，权重由指数衰减因子决定。一种更常见的形式是：\n$$\n\\sigma_{x, \\text{end}} = \\sigma_{\\mathrm{app}} + (\\sigma_{x, \\text{start}} - \\sigma_{\\mathrm{app}}) \\exp\\left(-\\frac{\\Delta t}{\\tau(T)}\\right)\n$$\n此处，弛豫时间 $\\tau(T)$ 遵循阿伦尼乌斯定律：\n$$\n\\tau(T) = \\tau_{0} \\exp\\left(\\frac{E_{a}}{k_{B} T}\\right)\n$$\n其中常数 $\\tau_0 = 1.0\\times 10^{-7}$ s, $E_a = 1.5$ eV, and $k_B = 8.617333262145\\times 10^{-5}$ eV/K。此更新规则将应力状态跨一个离散工艺步骤进行传播。\n\nb) 迁移率模型的推导\n\n问题假定对于小应力，标量电子迁移率 $\\mu_{n}$ 可以表示为柯西应力张量 $\\boldsymbol{\\sigma}$ 的不变量的一阶展开。所选的不变量是静水应力 $\\sigma_{h}$ 和偏应力第二不变量的平方根 $\\sqrt{J_2}$。迁移率相对变化的一般一阶模型是：\n$$\n\\frac{\\mu_{n} - \\mu_{n,0}}{\\mu_{n,0}} = a_{h}^{(n)} \\sigma_{h} + a_{d}^{(n)} \\sqrt{J_{2}}\n$$\n其中 $\\mu_{n,0}$ 是零应力下的参考迁移率，而 $a_{h}^{(n)}$ 和 $a_{d}^{(n)}$ 是静水压力和畸变压迁移率系数，给定值为 $a_{h}^{(n)} = 1.0\\times 10^{-11}$ Pa$^{-1}$ 和 $a_{d}^{(n)} = 2.0\\times 10^{-11}$ Pa$^{-1}$。\n\n这给出了迁移率为：\n$$\n\\mu_{n}(\\boldsymbol{\\sigma}) = \\mu_{n,0} \\left( 1 + a_{h}^{(n)} \\sigma_{h} + a_{d}^{(n)} \\sqrt{J_{2}} \\right)\n$$\n我们现在必须为指定的单轴应力状态 $\\boldsymbol{\\sigma} = \\mathrm{diag}(\\sigma_{x}, 0, 0)$ 计算不变量。\n\n静水应力是应力张量迹的三分之一：\n$$\n\\sigma_{h} = \\frac{1}{3} \\mathrm{tr}(\\boldsymbol{\\sigma}) = \\frac{1}{3} (\\sigma_{x} + 0 + 0) = \\frac{\\sigma_{x}}{3}\n$$\n偏应力张量 $\\mathbf{s}$ 定义为 $\\mathbf{s} = \\boldsymbol{\\sigma} - \\sigma_{h}\\mathbf{I}$：\n$$\n\\mathbf{s} = \\begin{pmatrix} \\sigma_{x} & 0 & 0 \\\\ 0 & 0 & 0 \\\\ 0 & 0 & 0 \\end{pmatrix} - \\frac{\\sigma_{x}}{3} \\begin{pmatrix} 1 & 0 & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix} = \\begin{pmatrix} 2\\sigma_{x}/3 & 0 & 0 \\\\ 0 & -\\sigma_{x}/3 & 0 \\\\ 0 & 0 & -\\sigma_{x}/3 \\end{pmatrix}\n$$\n第二不变量 $J_2$ 由 $J_2 = \\frac{1}{2} \\mathbf{s}:\\mathbf{s} = \\frac{1}{2}\\sum_{i,j} s_{ij}s_{ji}$ 给出。对于对角张量，这简化为 $J_2 = \\frac{1}{2}\\sum_{i} s_{ii}^2$：\n$$\nJ_2 = \\frac{1}{2} \\left[ \\left(\\frac{2\\sigma_{x}}{3}\\right)^2 + \\left(-\\frac{\\sigma_{x}}{3}\\right)^2 + \\left(-\\frac{\\sigma_{x}}{3}\\right)^2 \\right] = \\frac{1}{2} \\left( \\frac{4\\sigma_{x}^2}{9} + \\frac{\\sigma_{x}^2}{9} + \\frac{\\sigma_{x}^2}{9} \\right) = \\frac{1}{2} \\left( \\frac{6\\sigma_{x}^2}{9} \\right) = \\frac{\\sigma_{x}^2}{3}\n$$\n因此，该不变量的平方根是：\n$$\n\\sqrt{J_2} = \\sqrt{\\frac{\\sigma_{x}^2}{3}} = \\frac{|\\sigma_{x}|}{\\sqrt{3}}\n$$\n两个不变量都与问题陈述中提供的值一致。将这些表达式代入迁移率方程，得到电子迁移率作为单轴应力 $\\sigma_x$ 函数的最终模型：\n$$\n\\mu_{n}(\\sigma_{x}) = \\mu_{n,0} \\left( 1 + a_{h}^{(n)} \\frac{\\sigma_{x}}{3} + a_{d}^{(n)} \\frac{|\\sigma_{x}|}{\\sqrt{3}} \\right)\n$$\n该表达式将用于从最终应力状态计算最终迁移率。\n\nc) 算法设计\n\n为给定测试案例计算最终电子迁移率的算法如下：\n1.  用提供的初始应力 $\\sigma_{x}(0)$ 初始化内部应力的状态变量 $\\sigma_{x,\\text{current}}$。\n2.  遍历工艺步骤序列，其中每个步骤 $i$ 由一个元组 $(T_i, \\Delta t_i, \\sigma_{\\mathrm{app}, i})$ 定义。\n3.  对于每个步骤 $i$：\n    a. 检索步骤参数 $T_i$、$\\Delta t_i$ 和 $\\sigma_{\\mathrm{app}, i}$。\n    b. 使用阿伦尼乌斯方程计算弛豫时间 $\\tau(T_i)$：$\\tau(T_i) = \\tau_{0} \\exp(E_{a} / (k_{B} T_i))$。\n    c. 应用推导的更新规则找到步骤结束时的应力 $\\sigma_{x, \\text{end}}$。此步骤的初始应力是前一步的最终应力 $\\sigma_{x, \\text{current}}$。\n       $$ \\sigma_{x, \\text{end}} = \\sigma_{\\mathrm{app}, i} + (\\sigma_{x, \\text{current}} - \\sigma_{\\mathrm{app}, i}) \\exp\\left(-\\frac{\\Delta t_i}{\\tau(T_i)}\\right) $$\n    d. 为下一次迭代更新状态变量：$\\sigma_{x,\\text{current}} \\leftarrow \\sigma_{x, \\text{end}}$。\n4.  处理完所有步骤后，最终的内部应力为 $\\sigma_{x,\\text{final}} = \\sigma_{x,\\text{current}}$。\n5.  使用最终应力 $\\sigma_{x,\\text{final}}$ 计算最终电子迁移率 $\\mu_{n,\\text{final}}$，使用推导的迁移率模型：\n    $$ \\mu_{n,\\text{final}} = \\mu_{n,0} \\left( 1 + a_{h}^{(n)} \\frac{\\sigma_{x,\\text{final}}}{3} + a_{d}^{(n)} \\frac{|\\sigma_{x,\\text{final}}|}{\\sqrt{3}} \\right) $$\n6.  然后将结果 $\\mu_{n,\\text{final}}$ 格式化为所需的精度。\n\nd) 实现与验证\n\n上述算法在一个 Python 程序中实现。该程序顺序处理四个指定的测试案例。对于每个案例，它初始化应力，通过工艺流程迭代应用每步更新规则来传播应力状态，并最终从最终应力计算电子迁移率。问题陈述中提供的数值常数（$\\mu_{n,0} = 0.045$ m$^2$/V·s, $a_{h}^{(n)}$, $a_{d}^{(n)}$, $\\tau_{0}$, $E_{a}$, $k_{B}$）直接用于计算。输出是每个测试案例的最终迁移率值的列表，四舍五入到八位小数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of propagating stress state and calculating final electron mobility.\n    \"\"\"\n    \n    # Numerical data and constants in SI units\n    MU_N0 = 0.045  # Reference electron mobility [m^2/V·s]\n    A_H_N = 1.0e-11  # Hydrostatic piezomobility coefficient [Pa^-1]\n    A_D_N = 2.0e-11  # Distortional piezomobility coefficient [Pa^-1]\n    TAU0 = 1.0e-7    # Arrhenius pre-exponential factor [s]\n    EA = 1.5         # Activation energy [eV]\n    KB = 8.617333262145e-5  # Boltzmann constant [eV/K]\n\n    # Test suite from the problem statement\n    # Each case: (initial_sigma_x_0, list of steps)\n    # Each step: (Temperature T [K], duration delta_t [s], applied_stress sigma_app [Pa])\n    test_cases = [\n        # Case 1\n        (0.0, [\n            (800.0, 1200.0, 2.0e8),\n            (300.0, 600.0, 2.0e8),\n        ]),\n        # Case 2\n        (0.0, [\n            (900.0, 3600.0, 0.0),\n            (300.0, 100.0, 0.0),\n        ]),\n        # Case 3\n        (-1.0e8, [\n            (1100.0, 100.0, 3.0e8),\n            (1100.0, 1000.0, 3.0e8),\n        ]),\n        # Case 4\n        (0.0, [\n            (800.0, 200.0, 2.0e8),\n            (800.0, 200.0, -2.0e8),\n            (800.0, 200.0, 2.0e8),\n        ]),\n    ]\n\n    results = []\n    \n    for initial_sigma, steps in test_cases:\n        current_sigma_x = initial_sigma\n        \n        # Propagate stress through the process steps\n        for T, delta_t, sigma_app in steps:\n            # Calculate relaxation time using Arrhenius law\n            # Note: T must be > 0\n            if T == 0:\n                # In a physically realistic scenario, T > 0.\n                # If T -> 0, tau -> infinity, stress is frozen.\n                # exp(-delta_t / tau) -> 1.\n                decay_factor = 1.0\n            else:\n                tau = TAU0 * np.exp(EA / (KB * T))\n                # Protect against underflow/overflow if delta_t/tau is very large\n                # For large x, exp(-x) -> 0. Let's use numpy's robust exp.\n                decay_factor = np.exp(-delta_t / tau)\n\n            # Update stress using the derived analytical solution\n            # sigma_end = sigma_app + (sigma_start - sigma_app) * exp(-delta_t / tau)\n            current_sigma_x = sigma_app + (current_sigma_x - sigma_app) * decay_factor\n\n        final_sigma_x = current_sigma_x\n\n        # Calculate final electron mobility using the derived invariant-based model\n        # mu_n = mu_n0 * (1 + a_h * sigma_x / 3 + a_d * |sigma_x| / sqrt(3))\n        mobility_change = A_H_N * final_sigma_x / 3.0 + A_D_N * np.abs(final_sigma_x) / np.sqrt(3.0)\n        final_mobility = MU_N0 * (1.0 + mobility_change)\n        \n        results.append(f\"{final_mobility:.8f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}