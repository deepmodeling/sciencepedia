{
    "hands_on_practices": [
        {
            "introduction": "A cornerstone of experimental electrochemistry is the ability to translate measurable quantities, like voltage, into fundamental thermodynamic properties. This practice focuses on such a translation, demonstrating how the thermodynamic factor, $\\Theta$, can be directly extracted from the electromotive force (EMF) of a concentration cell. You will apply numerical differentiation to hypothetical EMF data to compute $\\Theta$ and explore the critical distinction between the molal and molar concentration scales, a subtlety that becomes paramount in the concentrated electrolytes used in modern batteries .",
            "id": "3957469",
            "problem": "You are given electromotive force (EMF) data as a function of the natural logarithm of molality at a fixed temperature for the salt lithium hexafluorophosphate (LiPF$_6$) in the mixed solvent Ethylene Carbonate (EC) and Diethyl Carbonate (DEC). The goal is to compute the thermodynamic factor in the molal concentration scale and to quantify the impact of performing the analysis in the molar concentration scale. The thermodynamic factor is a dimensionless quantity defined by the logarithmic sensitivity of activity to the chosen concentration measure and is central to transport modeling in automated battery design and simulation.\n\nFundamental base:\n- The electrochemical potential of an ionic species is given by the definition of chemical potential, where the activity appears logarithmically in the potential.\n- The Nernst equation relates the measured EMF between two solutions to the ratio of activities.\n- Electroneutrality in binary electrolytes and consistent activity definitions are applied.\n- The molality $m$ (in $\\mathrm{mol/kg}$ solvent) and molarity $c$ (in $\\mathrm{mol/L}$ solution) are distinct concentration scales and are related by solution density and salt molar mass in a scientifically consistent manner.\n\nYour program must:\n1. Start from the above fundamental base to construct an algorithm that, given EMF data $E$ tabulated versus $\\ln m$ at fixed temperature $T$, estimates the thermodynamic factor on the molal scale, denoted $\\Theta_m(m)$, by differentiating the EMF with respect to $\\ln m$ and normalizing by thermodynamic constants.\n2. Convert the result to the molar scale $\\Theta_c(c)$ by applying a mathematically rigorous change of variables between $m$ and $c$ using an explicit, physically plausible density model for EC:DEC with LiPF$_6$.\n3. Use numerically stable differentiation on nonuniform grids and interpolate derivatives to the specified evaluation points.\n\nDefinitions and modeling assumptions for this problem:\n- Let $R$ denote the universal gas constant and $F$ denote Faraday's constant. Let $T$ be the absolute temperature in $\\mathrm{K}$.\n- Let $\\rho(m)$ denote the solution density in $\\mathrm{kg/L}$ modeled as a smooth function of $m$ that is strictly positive over the tested range.\n- Let $M_s$ denote the salt molar mass in $\\mathrm{kg/mol}$.\n- The thermodynamic factor on the molal scale is defined as the dimensionless derivative $\\Theta_m(m)$, obtained from the EMF sensitivity to $\\ln m$ at fixed $T$.\n- The molarity $c$ and molality $m$ are related by\n$$\nc(m) = \\frac{m \\, \\rho(m)}{1 + m M_s},\n$$\nand the change-of-variables factor required to convert derivatives from $\\ln m$ to $\\ln c$ must be derived by differentiating $\\ln c(m)$ with respect to $\\ln m$.\n- You must use the following physically plausible density model for EC:DEC with dissolved LiPF$_6$:\n$$\n\\rho(m) = 1.25 + 0.04 m - 0.002 m^2 \\quad \\text{in } \\mathrm{kg/L},\n$$\nvalid for $m \\in [0.1, 2.0]$. Its derivative with respect to $m$ is\n$$\n\\frac{d\\rho}{dm} = 0.04 - 0.004 m.\n$$\n- Use $M_s = 0.1519 \\, \\mathrm{kg/mol}$ for LiPF$_6$ and $T = 298.15 \\, \\mathrm{K}$.\n- EMF values are in $\\mathrm{V}$ and must be treated consistently with the Nernst relation. All outputs for $\\Theta$ are dimensionless.\n\nTest suite (three cases):\n- Case 1 (near-ideal behavior, happy path): Molality grid $m = [0.1, 0.2, 0.5, 1.0, 1.5]$. EMF data constructed by\n$$\nE(m) = E_0 + \\frac{R T}{F} \\ln m,\n$$\nwith $E_0 = 0.15 \\, \\mathrm{V}$. Evaluate $\\Theta_m$ and $\\Theta_c$ at $m^\\star = 1.0$.\n- Case 2 (moderate nonideality, central region): Molality grid $m = [0.2, 0.5, 1.0, 1.3, 1.6]$. EMF data constructed by\n$$\nE(m) = E_0 + \\frac{R T}{F} \\left(\\ln m + \\ln \\gamma_1(m)\\right), \\quad \\ln \\gamma_1(m) = -\\frac{0.5 \\sqrt{m}}{1 + 0.8 m},\n$$\nwith $E_0 = 0.05 \\, \\mathrm{V}$. Evaluate $\\Theta_m$ and $\\Theta_c$ at $m^\\star = 1.0$.\n- Case 3 (stronger nonideality at higher concentration, edge case): Molality grid $m = [0.5, 1.0, 1.5, 2.0]$. EMF data constructed by\n$$\nE(m) = E_0 + \\frac{R T}{F} \\left(\\ln m + \\ln \\gamma_2(m)\\right), \\quad \\ln \\gamma_2(m) = \\frac{0.2 m}{1 + 0.5 m},\n$$\nwith $E_0 = 0.03 \\, \\mathrm{V}$. Evaluate $\\Theta_m$ and $\\Theta_c$ at $m^\\star = 1.5$.\n\nAlgorithmic requirements:\n- Implement a numerically stable estimation of the derivative $\\frac{dE}{d \\ln m}$ by using finite differences on the given nonuniform grids. To do so, compute the derivative of $E$ with respect to $x = \\ln m$ using central differences where possible and one-sided differences at boundaries. If $m^\\star$ is not exactly a grid point, interpolate the derivative to $m^\\star$ on the $m$ domain.\n- Compute the molal thermodynamic factor by appropriately normalizing the derivative with constants $R$, $T$, and $F$.\n- Compute the molar thermodynamic factor by analytically relating $\\frac{d \\ln a}{d \\ln c}$ to $\\frac{d \\ln a}{d \\ln m}$ via the derivative of $\\ln c(m)$ with respect to $\\ln m$ and applying the chain rule. Explicitly use the provided $\\rho(m)$ and $\\frac{d\\rho}{dm}$.\n\nAnswer specification:\n- For each case, return a pair of floats $[\\Theta_m(m^\\star), \\Theta_c(c(m^\\star))]$.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each entry corresponds to a case and is itself a two-element list. For example, an output with three cases must look like:\n$$\n\\texttt{[[\\theta\\_m^1,\\theta\\_c^1],[\\theta\\_m^2,\\theta\\_c^2],[\\theta\\_m^3,\\theta\\_c^3]]}\n$$\n- All $\\Theta$ values must be dimensionless decimal floats. Round each reported float to six decimal places.",
            "solution": "The problem statement is validated as scientifically grounded, well-posed, objective, and complete. It is based on fundamental principles of thermodynamics and electrochemistry, provides all necessary constants, models, and data, and is formulated with precision. No flaws are identified.\n\nThe solution proceeds in three steps: first, establishing the theoretical relationship between the electromotive force ($E$) and the molal thermodynamic factor ($\\Theta_m$); second, deriving the conversion factor to relate the molal thermodynamic factor ($\\Theta_m$) to the molar thermodynamic factor ($\\Theta_c$); and third, outlining the numerical algorithm to implement these calculations.\n\n**1. Derivation of the Molal Thermodynamic Factor ($\\Theta_m$) from EMF Data**\n\nThe problem concerns a concentration cell where the electromotive force ($E$) is a function of the molality ($m$) of the salt $\\text{LiPF}_6$. The chemical potential of the salt, $\\mu$, determines the cell potential. The activity of the salt, $a$, is related to its molality $m$ and mean molal activity coefficient $\\gamma_\\pm$ by $a = (m \\gamma_\\pm)^\\nu$, where $\\nu$ is the number of ions produced per formula unit of salt. For $\\text{LiPF}_6$, $\\nu=2$.\n\nThe Nernst equation relates the EMF to the activity. The problem provides a simplified form of this relationship for the cell in question:\n$$E(m) = E_0 + \\frac{R T}{F} (\\ln m + \\ln \\gamma(m))$$\nwhere $R$ is the universal gas constant, $T$ is the absolute temperature, $F$ is Faraday's constant, and $\\gamma(m)$ represents the effective activity coefficient for the process being measured. The term $\\ln m + \\ln \\gamma(m)$ is equivalent to $\\ln a_s$, where $a_s$ is the activity of the electroactive species on the molal scale. The prefactor $\\frac{RT}{F}$ suggests a one-electron process, consistent with measuring the activity of a single ion like $\\text{Li}^+$.\n\nThe thermodynamic factor on the molal scale, $\\Theta_m(m)$, is defined as the logarithmic derivative of the salt's activity with respect to molality. While formal definitions involve the mean ionic activity coefficient, the problem's structure implies that $\\Theta_m$ should be derived from the sensitivity of the measured EMF. We define $\\Theta_m$ in a way that is consistent with the provided EMF expression. Let's differentiate $E$ with respect to the natural logarithm of molality, $x = \\ln m$:\n$$\\frac{dE}{d \\ln m} = \\frac{d}{d \\ln m} \\left[ E_0 + \\frac{R T}{F} \\ln a_s \\right] = \\frac{R T}{F} \\frac{d \\ln a_s}{d \\ln m}$$\nThe problem asks to obtain the dimensionless thermodynamic factor, $\\Theta_m(m)$, by normalizing this derivative. This normalization is achieved by multiplying by $\\frac{F}{RT}$:\n$$\\Theta_m(m) = \\frac{F}{RT} \\frac{dE}{d \\ln m}$$\nSubstituting the form of the test case EMFs, where $a_s = m\\gamma(m)$:\n$$\\Theta_m(m) = \\frac{d \\ln(m\\gamma(m))}{d \\ln m} = \\frac{d(\\ln m + \\ln \\gamma(m))}{d \\ln m} = 1 + \\frac{d \\ln \\gamma(m)}{d \\ln m}$$\nThis confirms our approach is consistent with standard definitions. The core of the first computational step is thus to numerically evaluate $\\frac{dE}{d \\ln m}$ and scale it appropriately.\n\n**2. Conversion to the Molar Thermodynamic Factor ($\\Theta_c$)**\n\nThe second task is to convert $\\Theta_m$ to its equivalent on the molar concentration scale, $\\Theta_c$. The molarity $c$ (in $\\mathrm{mol/L}$) and molality $m$ (in $\\mathrm{mol/kg}$) are related via the solution density $\\rho$ (in $\\mathrm{kg/L}$) and the salt molar mass $M_s$ (in $\\mathrm{kg/mol}$):\n$$c(m) = \\frac{m \\, \\rho(m)}{1 + m M_s}$$\nThe fundamental activity $a_s$ is a property of the state of the solution and is independent of the choice of concentration scale. Therefore, the thermodynamic factors, defined as the logarithmic derivative of activity with respect to concentration, are related by the chain rule:\n$$\\Theta_c(c) \\equiv \\frac{d \\ln a_s}{d \\ln c} = \\frac{d \\ln a_s}{d \\ln m} \\cdot \\frac{d \\ln m}{d \\ln c} = \\Theta_m(m) \\left( \\frac{d \\ln c}{d \\ln m} \\right)^{-1}$$\nTo find the conversion factor, we compute the derivative $\\frac{d \\ln c}{d \\ln m}$. It is most convenient to start by taking the logarithm of the expression for $c(m)$:\n$$\\ln c = \\ln m + \\ln \\rho(m) - \\ln(1 + m M_s)$$\nNow, we differentiate with respect to $\\ln m$. Using the relation $d(\\ln m) = \\frac{1}{m} dm$:\n$$\\frac{d \\ln c}{d \\ln m} = m \\frac{d(\\ln c)}{dm} = m \\frac{d}{dm} \\left[ \\ln m + \\ln \\rho(m) - \\ln(1 + m M_s) \\right]$$\n$$ = m \\left[ \\frac{1}{m} + \\frac{1}{\\rho(m)} \\frac{d\\rho}{dm} - \\frac{M_s}{1 + m M_s} \\right] $$\n$$ = 1 + \\frac{m}{\\rho(m)} \\frac{d\\rho}{dm} - \\frac{m M_s}{1 + m M_s} $$\nThis expression provides the required conversion factor using the provided density model $\\rho(m)$ and its derivative $\\frac{d\\rho}{dm}$. The molar thermodynamic factor is then:\n$$\\Theta_c(c(m)) = \\Theta_m(m) \\left( 1 + \\frac{m}{\\rho(m)} \\frac{d\\rho}{dm} - \\frac{m M_s}{1 + m M_s} \\right)^{-1}$$\n\n**3. Numerical Algorithm Design**\n\nThe complete algorithm is as follows:\nFor each test case with a molality grid $\\{m_i\\}$, corresponding EMF data $\\{E_i\\}$, and an evaluation molality $m^\\star$:\n1.  **Prepare Data**: Calculate $x_i = \\ln m_i$ for each grid point. The data points are $(x_i, E_i)$.\n2.  **Numerical Differentiation**: Compute the derivative $\\frac{dE}{d \\ln m}$ at each grid point $m_i$. Let the result be $D_i$.\n    - For interior points ($0  i  N-1$): Use the second-order central difference formula:\n      $$D_i = \\frac{E_{i+1} - E_{i-1}}{x_{i+1} - x_{i-1}}$$\n    - For the first point ($i=0$): Use the first-order forward difference formula:\n      $$D_0 = \\frac{E_1 - E_0}{x_1 - x_0}$$\n    - For the last point ($i=N-1$): Use the first-order backward difference formula:\n      $$D_{N-1} = \\frac{E_{N-1} - E_{N-2}}{x_{N-1} - x_{N-2}}$$\n3.  **Interpolation**: If $m^\\star$ is not a grid point, linearly interpolate the computed derivative values $\\{D_i\\}$ on the molality grid $\\{m_i\\}$ to find the derivative $D^\\star$ at $m^\\star$. If $m^\\star$ is a grid point, the corresponding $D_i$ is used directly.\n4.  **Calculate $\\Theta_m(m^\\star)$**: Apply the normalization derived in Section 1:\n    $$\\Theta_m(m^\\star) = D^\\star \\cdot \\frac{F}{R T}$$\n    using the given constants $T = 298.15 \\, \\mathrm{K}$, $R = 8.314462618 \\, \\mathrm{J/(mol \\cdot K)}$, and $F = 96485.33212 \\, \\mathrm{C/mol}$.\n5.  **Calculate $\\Theta_c(c(m^\\star))$**:\n    a. Evaluate the density $\\rho(m^\\star)$ and its derivative $\\frac{d\\rho}{dm}(m^\\star)$ using the provided models:\n       $$\\rho(m^\\star) = 1.25 + 0.04 m^\\star - 0.002 (m^\\star)^2$$\n       $$\\frac{d\\rho}{dm}(m^\\star) = 0.04 - 0.004 m^\\star$$\n    b. Compute the conversion factor at $m^\\star$ using the formula from Section 2:\n       $$ \\text{factor} = 1 + \\frac{m^\\star}{\\rho(m^\\star)} \\frac{d\\rho}{dm}(m^\\star) - \\frac{m^\\star M_s}{1 + m^\\star M_s} $$\n       where $M_s = 0.1519 \\, \\mathrm{kg/mol}$.\n    c. Compute the molar thermodynamic factor:\n       $$ \\Theta_c(c(m^\\star)) = \\frac{\\Theta_m(m^\\star)}{\\text{factor}} $$\n6.  **Store and Format Output**: Store the pair $[\\Theta_m(m^\\star), \\Theta_c(c(m^\\star))]$, rounded to six decimal places, and repeat for all cases. The final output is a list of these pairs.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the thermodynamic factor in molal and molar scales\n    from EMF data for concentrated electrolytes.\n    \"\"\"\n    # Define physical constants\n    R = 8.314462618  # J/(mol.K)\n    F = 96485.33212   # C/mol\n    T = 298.15         # K\n    M_s = 0.1519       # kg/mol for LiPF6\n\n    # Pre-calculate a constant group\n    RT_F = R * T / F  # Volts\n\n    # --- Model Definitions ---\n    def rho(m):\n        \"\"\"Solution density model in kg/L.\"\"\"\n        return 1.25 + 0.04 * m - 0.002 * m**2\n\n    def d_rho_dm(m):\n        \"\"\"Derivative of the density model w.r.t. molality.\"\"\"\n        return 0.04 - 0.004 * m\n\n    # --- Test Case Definitions ---\n    # Case 1: Ideal behavior\n    def E1(m, E0=0.15):\n        return E0 + RT_F * np.log(m)\n\n    # Case 2: Moderate nonideality\n    def E2(m, E0=0.05):\n        ln_gamma = -0.5 * np.sqrt(m) / (1.0 + 0.8 * m)\n        return E0 + RT_F * (np.log(m) + ln_gamma)\n\n    # Case 3: Stronger nonideality\n    def E3(m, E0=0.03):\n        ln_gamma = 0.2 * m / (1.0 + 0.5 * m)\n        return E0 + RT_F * (np.log(m) + ln_gamma)\n\n    test_cases = [\n        {\n            \"m_grid\": np.array([0.1, 0.2, 0.5, 1.0, 1.5]),\n            \"m_star\": 1.0,\n            \"E_func\": E1\n        },\n        {\n            \"m_grid\": np.array([0.2, 0.5, 1.0, 1.3, 1.6]),\n            \"m_star\": 1.0,\n            \"E_func\": E2\n        },\n        {\n            \"m_grid\": np.array([0.5, 1.0, 1.5, 2.0]),\n            \"m_star\": 1.5,\n            \"E_func\": E3\n        }\n    ]\n\n    # --- Main Calculation Loop ---\n    final_results = []\n    for case in test_cases:\n        m_grid = case[\"m_grid\"]\n        m_star = case[\"m_star\"]\n        E_func = case[\"E_func\"]\n\n        # Step 1: Prepare data\n        x_grid = np.log(m_grid)\n        E_grid = E_func(m_grid)\n\n        # Step 2: Numerical Differentiation of E w.r.t. ln(m)\n        dE_dlnm_grid = np.zeros_like(m_grid)\n        n_points = len(m_grid)\n\n        # First point (forward difference)\n        dE_dlnm_grid[0] = (E_grid[1] - E_grid[0]) / (x_grid[1] - x_grid[0])\n\n        # Last point (backward difference)\n        dE_dlnm_grid[-1] = (E_grid[-1] - E_grid[-2]) / (x_grid[-1] - x_grid[-2])\n\n        # Interior points (central difference)\n        for i in range(1, n_points - 1):\n            dE_dlnm_grid[i] = (E_grid[i+1] - E_grid[i-1]) / (x_grid[i+1] - x_grid[i-1])\n\n        # Step 3: Interpolate for the derivative at m_star\n        dE_dlnm_star = np.interp(m_star, m_grid, dE_dlnm_grid)\n\n        # Step 4: Calculate molal thermodynamic factor\n        theta_m = dE_dlnm_star / RT_F\n\n        # Step 5: Calculate molar thermodynamic factor\n        # Evaluate density and its derivative at m_star\n        rho_star = rho(m_star)\n        d_rho_dm_star = d_rho_dm(m_star)\n\n        # Calculate the conversion factor from ln(m) to ln(c) derivative\n        conversion_factor = (\n            1 + (m_star / rho_star) * d_rho_dm_star - (m_star * M_s) / (1 + m_star * M_s)\n        )\n\n        # Calculate theta_c\n        theta_c = theta_m / conversion_factor\n\n        # Round results\n        result_pair = [round(theta_m, 6), round(theta_c, 6)]\n        final_results.append(result_pair)\n\n    # Format final output string\n    output_str_parts = []\n    for pair in final_results:\n        output_str_parts.append(f\"[{pair[0]},{pair[1]}]\")\n    \n    print(f\"[{','.join(output_str_parts)}]\")\n\n\nsolve()\n```"
        },
        {
            "introduction": "Experimental measurements provide discrete data points, but battery simulations require continuous functions to model electrolyte behavior across a range of conditions. This exercise bridges that gap by tasking you with constructing a smooth, continuous model for the thermodynamic factor from a set of data points. You will then use this model to perform a \"forward\" calculation, predicting the EMF of a concentration cell and comparing your prediction to known values, thereby validating the accuracy and predictive power of your model .",
            "id": "3957443",
            "problem": "You are building a small, self-contained evaluator for the thermodynamic factor in concentrated electrolytes, specifically Lithium Hexafluorophosphate (LiPF$_6$), in the context of automated battery design and simulation. The evaluator must fit a smooth function to the thermodynamic factor data and then predict the electromotive force (EMF) between electrolyte reservoirs at different concentrations, comparing the prediction to provided measurements.\n\nStart from a fundamental base. Use the definition of the thermodynamic factor and the concentrated solution theory relation for the electrolyte potential under open-circuit, zero-current conditions. The thermodynamic factor for a binary electrolyte is defined as the dimensionless quantity $\\Theta(c)$ that modulates the response of the mean ionic activity coefficient to concentration, and the electrolyte potential difference in a concentration cell with identical reversible electrodes is given by an integral of $\\Theta(c)$ along $\\ln c$. The desired EMF from concentration $c_1$ to $c_2$ is obtained by integrating a potential gradient derived from the Nernst relation for ions together with the concentrated solution framework. You must not assume any simplified dilute solution behavior or ideality; the response must be driven by the fitted smooth $\\Theta(c)$.\n\nYour program must: \n- Fit a smooth function $\\hat{\\Theta}(c)$ to given measurements of $\\Theta(c)$ for LiPF$_6$ in the solvent of interest at $T=298.15$ K, strictly using a smooth representation of $\\ln \\Theta$ as a cubic spline function of $\\ln c$ to ensure positivity and smoothness.\n- Use the fitted $\\hat{\\Theta}(c)$ to predict EMF values for specified concentration pairs via numerical quadrature of the governing integral in zero-current conditions.\n- Compare the predicted EMF values to the provided measured EMF values and report the absolute deviations for each case, along with the maximum deviation over the full set.\n\nThe fundamental relationships you must use are:\n- Define the thermodynamic factor as $\\Theta(c)$ entering the concentrated solution theory expression for the electrolyte potential gradient under zero current, where the gradient is proportional to $\\Theta(c)\\nabla \\ln c$.\n- For a binary $1{:}1$ electrolyte under open circuit, the EMF between reservoirs at concentrations $c_1$ and $c_2$ is\n$$\nE(c_1,c_2) \\;=\\; \\frac{2RT}{F}\\,(1 - t_+)\\,\\int_{\\ln c_1}^{\\ln c_2} \\Theta\\!\\big(c(s)\\big)\\,ds,\n$$\nwhere $R$ is the universal gas constant, $T$ is absolute temperature, $F$ is Faraday’s constant, $t_+$ is the cation transference number, and $s=\\ln c$ with $c(s)=e^s$. Express $E$ in volts.\n\nUse the following numerical constants and data:\n- $R = 8.314$ J mol$^{-1}$ K$^{-1}$, $T = 298.15$ K, $F = 96485$ C mol$^{-1}$, $t_+ = 0.38$ (dimensionless).\n- Concentration unit: mol m$^{-3}$.\n- EMF unit: volts (V).\n- Provided $\\Theta(c)$ measurements at $T=298.15$ K:\n    - $c=200$ mol m$^{-3}$, $\\Theta=1.16706$;\n    - $c=400$ mol m$^{-3}$, $\\Theta=1.41778$;\n    - $c=600$ mol m$^{-3}$, $\\Theta=1.72610$;\n    - $c=800$ mol m$^{-3}$, $\\Theta=2.06182$;\n    - $c=1000$ mol m$^{-3}$, $\\Theta=2.40000$;\n    - $c=1200$ mol m$^{-3}$, $\\Theta=2.72500$;\n    - $c=1400$ mol m$^{-3}$, $\\Theta=3.02800$;\n    - $c=1600$ mol m$^{-3}$, $\\Theta=3.30800$;\n    - $c=1800$ mol m$^{-3}$, $\\Theta=3.56600$.\n- Test suite concentration pairs and their measured EMFs (computed independently at $T=298.15$ K):\n    1. $(c_1,c_2)=(400,1200)$, measured $E=0.068429$ V.\n    2. $(c_1,c_2)=(600,1000)$, measured $E=0.033229$ V.\n    3. $(c_1,c_2)=(200,1800)$, measured $E=0.137479$ V.\n    4. $(c_1,c_2)=(800,1400)$, measured $E=0.044887$ V.\n    5. $(c_1,c_2)=(1000,1000)$, measured $E=0.000000$ V.\n    6. $(c_1,c_2)=(1600,600)$, measured $E=-0.075728$ V.\n\nYour algorithmic specification:\n- Transform $x=\\ln c$ and $y=\\ln \\Theta$ for the given data points, fit a cubic smoothing spline $y=\\hat{y}(x)$ with smoothing parameter equal to zero (exactly interpolating the provided points) to produce a smooth, twice continuously differentiable representation. Then form $\\hat{\\Theta}(c)=\\exp\\!\\big(\\hat{y}(\\ln c)\\big)$, which is strictly positive and smooth.\n- For each pair $(c_1,c_2)$, compute the predicted EMF by numerically evaluating \n$$\n\\hat{E}(c_1,c_2) \\;=\\; \\frac{2RT}{F}\\,(1 - t_+)\\,\\int_{\\ln c_1}^{\\ln c_2} \\hat{\\Theta}\\!\\big(e^s\\big)\\,ds,\n$$\nusing robust one-dimensional quadrature over $s$.\n- Compute the absolute deviation $|\\,\\hat{E}(c_1,c_2) - E_{\\mathrm{meas}}(c_1,c_2)\\,|$ for each test case.\n- Report the maximum absolute deviation over all test cases.\n\nAngle units do not apply. There are no percentages. All outputs must be floats in volts. Express the final deviations in volts and round each to six decimal places.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with seven entries corresponding to the absolute deviations for the six test cases followed by the maximum deviation over the set, each rounded to six decimal places. For example, the output format must be like $[\\mathrm{d}_1,\\mathrm{d}_2,\\mathrm{d}_3,\\mathrm{d}_4,\\mathrm{d}_5,\\mathrm{d}_6,\\max(\\mathrm{d}_i)]$ in volts.",
            "solution": "The problem statement has been critically validated and is determined to be valid. It is scientifically grounded in established electrochemical theory, is mathematically and algorithmically well-posed, is objective, and provides a complete and consistent set of data and constraints necessary for a unique solution.\n\nThe problem requires the evaluation of the electromotive force (EMF) in a concentration cell containing a binary $1{:}1$ electrolyte, LiPF$_6$. The solution is based on concentrated solution theory, which departs from idealized dilute solution assumptions. The core of the model is the thermodynamic factor, $\\Theta(c)$, a dimensionless quantity that accounts for non-ideal interactions by relating the mean ionic activity coefficient to changes in concentration.\n\nThe fundamental relationship for the EMF, $E$, between two reservoirs at concentrations $c_1$ and $c_2$ under open-circuit (zero-current) conditions for a cell with electrodes reversible to the cation is given by:\n$$\nE(c_1, c_2) = \\frac{2RT}{F}(1 - t_+) \\int_{\\ln c_1}^{\\ln c_2} \\Theta(c(s)) \\, ds\n$$\nwhere $s = \\ln c$. The constants are:\n- Universal gas constant, $R = 8.314 \\, \\text{J} \\, \\text{mol}^{-1} \\, \\text{K}^{-1}$\n- Absolute temperature, $T = 298.15 \\, \\text{K}$\n- Faraday's constant, $F = 96485 \\, \\text{C} \\, \\text{mol}^{-1}$\n- Cation transference number, $t_+ = 0.38$\n\nThe pre-factor $\\frac{2RT}{F}(1 - t_+)$ combines thermodynamic constants with the transport properties of the electrolyte.\n\nThe solution methodology proceeds in three steps:\n\n1.  **Constructing the Thermodynamic Factor Function $\\hat{\\Theta}(c)$**\n    The provided discrete measurements of $\\Theta(c)$ must be converted into a continuous, smooth function $\\hat{\\Theta}(c)$ that is valid over the concentration range of interest. The problem specifies a robust method to ensure the fitted function remains strictly positive and smooth. We first perform a change of variables on the given data points $(c_i, \\Theta_i)$:\n    $$\n    x_i = \\ln c_i \\\\\n    y_i = \\ln \\Theta_i\n    $$\n    A cubic spline, $\\hat{y}(x)$, is then fitted to these transformed points $(x_i, y_i)$. Specifically, an interpolating cubic spline is used, which corresponds to a smoothing spline with a smoothing parameter of zero. This ensures the spline passes exactly through each transformed data point and is twice continuously differentiable ($C^2$). The final continuous function for the thermodynamic factor, $\\hat{\\Theta}(c)$, is obtained by transforming back:\n    $$\n    \\hat{\\Theta}(c) = \\exp(\\hat{y}(\\ln c))\n    $$\n    This approach guarantees that $\\hat{\\Theta}(c)  0$ for all $c  0$.\n\n2.  **Predicting the Electromotive Force $\\hat{E}(c_1, c_2)$**\n    With the continuous function $\\hat{\\Theta}(c)$ established, the predicted EMF, $\\hat{E}(c_1, c_2)$, for each given concentration pair $(c_1, c_2)$ is calculated by numerically evaluating the governing integral. Substituting $\\hat{\\Theta}(c)$ into the EMF equation and using the integration variable $s = \\ln c$, we have:\n    $$\n    \\hat{E}(c_1, c_2) = \\frac{2RT}{F}(1 - t_+) \\int_{\\ln c_1}^{\\ln c_2} \\exp(\\hat{y}(s)) \\, ds\n    $$\n    This definite integral is computed using a standard numerical quadrature algorithm, which provides a highly accurate approximation for smooth integrands, such as the one derived from our spline model. If $c_1 = c_2$, the integral limits are identical, and the EMF is correctly predicted as $0 \\, \\text{V}$ without numerical integration. If $c_1  c_2$, the integral yields a negative value, correctly predicting a negative EMF.\n\n3.  **Calculating Deviations**\n    For each test case, the absolute deviation, $d_i$, between the predicted EMF, $\\hat{E}_i$, and the provided measured EMF, $E_{\\text{meas},i}$, is calculated:\n    $$\n    d_i = |\\hat{E}(c_{1,i}, c_{2,i}) - E_{\\text{meas},i}|\n    $$\n    Finally, the maximum absolute deviation across all test cases, $\\max(d_i)$, is identified. The final output consists of the list of individual deviations and the maximum deviation, all rounded to the specified precision.\n\nThe implementation will utilize the `numpy` library for numerical data handling, `scipy.interpolate.CubicSpline` to perform the exact interpolating spline fit, and `scipy.integrate.quad` for robust numerical integration.",
            "answer": "```python\nimport numpy as np\nfrom scipy.interpolate import CubicSpline\nfrom scipy.integrate import quad\n\ndef solve():\n    \"\"\"\n    Fits a thermodynamic factor model and predicts EMF for LiPF6 electrolyte.\n    \"\"\"\n    # 1. Define constants and provided data\n    R = 8.314  # J mol^-1 K^-1\n    T = 298.15  # K\n    F = 96485  # C mol^-1\n    t_plus = 0.38  # Cation transference number (dimensionless)\n\n    # Provided thermodynamic factor data (c in mol m^-3)\n    theta_data = np.array([\n        [200, 1.16706],\n        [400, 1.41778],\n        [600, 1.72610],\n        [800, 2.06182],\n        [1000, 2.40000],\n        [1200, 2.72500],\n        [1400, 3.02800],\n        [1600, 3.30800],\n        [1800, 3.56600],\n    ])\n\n    # Test suite: (c1, c2, measured_EMF in V)\n    test_cases = [\n        (400, 1200, 0.068429),\n        (600, 1000, 0.033229),\n        (200, 1800, 0.137479),\n        (800, 1400, 0.044887),\n        (1000, 1000, 0.000000),\n        (1600, 600, -0.075728),\n    ]\n\n    # 2. Construct the thermodynamic factor function using spline interpolation\n    c_values = theta_data[:, 0]\n    theta_values = theta_data[:, 1]\n\n    # Transform data to x = ln(c) and y = ln(Theta)\n    x_data = np.log(c_values)\n    y_data = np.log(theta_values)\n\n    # Create the interpolating cubic spline for y(x) = ln(Theta(ln(c)))\n    # This is equivalent to a smoothing spline with smoothing factor s=0.\n    ln_theta_spline = CubicSpline(x_data, y_data)\n\n    # Define the integrand function for EMF calculation.\n    # The integration variable is s = ln(c).\n    # The integrand is Theta(c(s)) = exp(y(s)).\n    integrand = lambda s: np.exp(ln_theta_spline(s))\n\n    # 3. Predict EMF for each test case and calculate deviations\n    deviations = []\n    prefactor = (2 * R * T / F) * (1 - t_plus)\n\n    for c1, c2, e_meas in test_cases:\n        # Handle the trivial case to avoid unnecessary integration\n        if c1 == c2:\n            integral_val = 0.0\n        else:\n            # Numerically integrate using scipy.integrate.quad\n            # The limits are ln(c1) and ln(c2)\n            integral_val, _ = quad(integrand, np.log(c1), np.log(c2))\n\n        # Calculate predicted EMF\n        e_pred = prefactor * integral_val\n\n        # Calculate absolute deviation\n        deviation = abs(e_pred - e_meas)\n        deviations.append(deviation)\n\n    # 4. Determine the maximum deviation\n    max_deviation = max(deviations) if deviations else 0.0\n\n    # 5. Format and print the final results\n    # The final list contains the 6 deviations plus the max deviation.\n    final_results = deviations + [max_deviation]\n\n    # Format output to six decimal places as required\n    formatted_results = [f\"{res:.6f}\" for res in final_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Moving beyond empirical fits, this advanced practice delves into physically-grounded modeling using the renowned Pitzer equations, which are extensively used to describe ionic interactions in concentrated solutions. Your task mirrors a realistic research scenario: fitting Pitzer parameters to experimental activity coefficient data using weighted nonlinear regression. More importantly, you will then perform a full uncertainty propagation analysis, a crucial skill for any scientist, to quantify the confidence in the derived thermodynamic factor and its dependence on experimental precision .",
            "id": "3957461",
            "problem": "You are tasked to design a program that, for symmetric $1:1$ electrolytes at fixed temperature in water, infers Pitzer interaction parameters from experimental mean activity coefficient data and then propagates parameter uncertainty to the thermodynamic factor. The program must implement a weighted nonlinear regression and perform linear uncertainty propagation.\n\nFundamental base and definitions:\n\n- The mean activity coefficient $\\gamma_{\\pm}(m)$ for a symmetric $1:1$ electrolyte in the Pitzer framework (molality basis) is modeled using the following well-tested representation:\n  $$\\ln \\gamma_{\\pm}(m) = -A_{\\gamma} \\frac{\\sqrt{m}}{1 + b \\sqrt{m}} + 2 m \\left( \\beta^{(0)} + \\beta^{(1)} \\, g(\\alpha \\sqrt{m}) \\right) + 2 m^{2} C_{\\phi},$$\n  where $m$ is molality in $\\mathrm{mol}\\,\\mathrm{kg}^{-1}$, $A_{\\gamma}$, $b$, and $\\alpha$ are known constants for water at $T = 298.15\\,\\mathrm{K}$, and $(\\beta^{(0)}, \\beta^{(1)}, C_{\\phi})$ are Pitzer parameters to be regressed from data.\n- The Brønsted function $g(x)$ is defined by:\n  $$g(x) = \\frac{1 - e^{-x}}{x}.$$\n- For a symmetric $1:1$ electrolyte, the ionic strength $I$ equals the molality $m$, so $I = m$.\n- The thermodynamic factor $\\Theta(m)$ is defined by the core thermodynamic relation:\n  $$\\Theta(m) = 1 + m \\, \\frac{d \\ln \\gamma_{\\pm}(m)}{d m},$$\n  where $\\Theta(m)$ is dimensionless.\n\nConstants for water at $T = 298.15\\,\\mathrm{K}$ to be used:\n- $A_{\\gamma} = 1.2$ (dimensionless, natural-logarithm base),\n- $b = 1.2$ in $\\mathrm{kg}^{1/2}\\,\\mathrm{mol}^{-1/2}$,\n- $\\alpha = 2.0$ in $\\mathrm{kg}^{1/2}\\,\\mathrm{mol}^{-1/2}$.\n\nWeighted nonlinear regression specification:\n- Given experimental pairs $\\{ m_i, \\gamma_{\\pm,i}, \\sigma_i \\}$ with $i = 1, \\dots, N$ and $\\sigma_i$ denoting the standard uncertainty of $\\gamma_{\\pm,i}$, estimate $(\\beta^{(0)}, \\beta^{(1)}, C_{\\phi})$ by minimizing the weighted sum of squares:\n  $$\\chi^2 = \\sum_{i=1}^{N} \\left( \\frac{\\gamma_{\\pm}^{\\text{model}}(m_i; \\beta^{(0)}, \\beta^{(1)}, C_{\\phi}) - \\gamma_{\\pm,i}}{\\sigma_i} \\right)^2,$$\n  where $\\gamma_{\\pm}^{\\text{model}}(m) = \\exp\\left( \\ln \\gamma_{\\pm}(m) \\right)$.\n- Compute the parameter covariance matrix $\\Sigma$ using the Jacobian of the residuals at the solution and the standard weighted least squares linearization:\n  $$\\Sigma = s^2 \\left( J^{\\top} J \\right)^{-1}, \\quad s^2 = \\frac{\\chi^2}{N - P},$$\n  where $P = 3$ is the number of parameters and $J$ is the Jacobian of the residual vector with respect to the parameters.\n\nUncertainty propagation to $\\Theta(m)$:\n- Using linear error analysis, propagate parameter uncertainty to $\\Theta(m)$ at a specified $m^\\star$ via:\n  $$\\mathrm{Var}\\left[ \\Theta(m^\\star) \\right] = \\mathbf{J}_{\\Theta}(m^\\star) \\, \\Sigma \\, \\mathbf{J}_{\\Theta}(m^\\star)^{\\top},$$\n  where $\\mathbf{J}_{\\Theta}(m^\\star) = \\left[ \\frac{\\partial \\Theta}{\\partial \\beta^{(0)}}, \\frac{\\partial \\Theta}{\\partial \\beta^{(1)}}, \\frac{\\partial \\Theta}{\\partial C_{\\phi}} \\right]_{m = m^\\star}$ is the gradient of $\\Theta$ with respect to the parameters evaluated at the fitted parameter values and $m = m^\\star$. Report the propagated standard uncertainty $u_{\\Theta}(m^\\star) = \\sqrt{\\mathrm{Var}\\left[ \\Theta(m^\\star) \\right]}$.\n\nData and test suite:\n- Case $1$ (happy path): experimental $\\{ m_i, \\gamma_{\\pm,i}, \\sigma_i \\}$ for a symmetric $1:1$ electrolyte\n  - $m$ in $\\mathrm{mol}\\,\\mathrm{kg}^{-1}$: $[0.05, 0.10, 0.50, 1.00, 2.00]$,\n  - $\\gamma_{\\pm}$ (dimensionless): $[0.835, 0.803, 0.780, 0.846, 1.028]$,\n  - $\\sigma$ (dimensionless): $[0.005, 0.005, 0.006, 0.006, 0.010]$,\n  - target $m^{\\star} = 0.20$ in $\\mathrm{mol}\\,\\mathrm{kg}^{-1}$.\n- Case $2$ (boundary coverage at higher $m$): experimental $\\{ m_i, \\gamma_{\\pm,i}, \\sigma_i \\}$\n  - $m$: $[0.05, 0.10, 0.50, 1.00, 2.00]$,\n  - $\\gamma_{\\pm}$: $[0.832, 0.799, 0.776, 0.840, 1.036]$,\n  - $\\sigma$: $[0.005, 0.005, 0.006, 0.006, 0.010]$,\n  - target $m^{\\star} = 1.50$ in $\\mathrm{mol}\\,\\mathrm{kg}^{-1}$.\n- Case $3$ (edge case with stronger short-range interactions): experimental $\\{ m_i, \\gamma_{\\pm,i}, \\sigma_i \\}$\n  - $m$: $[0.05, 0.10, 0.50, 1.00, 2.00]$,\n  - $\\gamma_{\\pm}$: $[0.837, 0.806, 0.789, 0.850, 1.016]$,\n  - $\\sigma$: $[0.005, 0.005, 0.006, 0.006, 0.010]$,\n  - target $m^{\\star} = 0.80$ in $\\mathrm{mol}\\,\\mathrm{kg}^{-1}$.\n\nProgram requirements and output:\n- Implement the weighted nonlinear regression and linear uncertainty propagation as specified above.\n- Compute for each case the pair $(\\Theta(m^\\star), u_{\\Theta}(m^\\star))$. Both quantities are dimensionless.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order $[\\Theta_1, u_{\\Theta,1}, \\Theta_2, u_{\\Theta,2}, \\Theta_3, u_{\\Theta,3}]$, with each value rounded to six decimal places and no units shown.",
            "solution": "The problem requires the implementation of a numerical procedure to infer Pitzer interaction parameters from experimental mean activity coefficient data for a symmetric $1:1$ electrolyte. Following this regression, the uncertainty in the estimated parameters must be propagated to the thermodynamic factor, a key quantity in electrolyte thermodynamics. The process involves weighted nonlinear least squares for parameter estimation and linear error propagation for the uncertainty analysis.\n\nThe foundation of the model is the Pitzer equation for the natural logarithm of the mean molal activity coefficient, $\\gamma_{\\pm}$, for a symmetric $1:1$ electrolyte at a fixed temperature ($T = 298.15\\,\\mathrm{K}$). The equation is given as:\n$$\n\\ln \\gamma_{\\pm}(m) = -A_{\\gamma} \\frac{\\sqrt{m}}{1 + b \\sqrt{m}} + 2 m \\left( \\beta^{(0)} + \\beta^{(1)} \\, g(\\alpha \\sqrt{m}) \\right) + 2 m^{2} C_{\\phi}\n$$\nHere, $m$ is the molality of the electrolyte in $\\mathrm{mol}\\,\\mathrm{kg}^{-1}$. The parameters $A_{\\gamma} = 1.2$, $b = 1.2\\,\\mathrm{kg}^{1/2}\\,\\mathrm{mol}^{-1/2}$, and $\\alpha = 2.0\\,\\mathrm{kg}^{1/2}\\,\\mathrm{mol}^{-1/2}$ are given constants. The function $g(x)$ is the Brønsted function, defined as:\n$$\ng(x) = \\frac{1 - e^{-x}}{x}\n$$\nThe parameters to be determined via regression are the Pitzer interaction coefficients: $\\boldsymbol{p} = [\\beta^{(0)}, \\beta^{(1)}, C_{\\phi}]^{\\top}$.\n\n**1. Weighted Nonlinear Regression**\n\nGiven a set of $N$ experimental data points $\\{ m_i, \\gamma_{\\pm,i}, \\sigma_i \\}$, where $\\sigma_i$ is the standard uncertainty of the measured activity coefficient $\\gamma_{\\pm,i}$, the parameters $\\boldsymbol{p}$ are estimated by minimizing the weighted sum of squared residuals, $\\chi^2$:\n$$\n\\chi^2(\\boldsymbol{p}) = \\sum_{i=1}^{N} \\left( \\frac{\\gamma_{\\pm}^{\\text{model}}(m_i; \\boldsymbol{p}) - \\gamma_{\\pm,i}}{\\sigma_i} \\right)^2\n$$\nwhere $\\gamma_{\\pm}^{\\text{model}}(m; \\boldsymbol{p}) = \\exp(\\ln \\gamma_{\\pm}(m; \\boldsymbol{p}))$ is the value predicted by the Pitzer model. This is a nonlinear least-squares problem, which can be solved numerically using an iterative algorithm such as the Trust Region Reflective method. Such algorithms typically require the Jacobian of the residual vector with respect to the parameters. The $i$-th component of the residual vector is $r_i(\\boldsymbol{p}) = [\\gamma_{\\pm}^{\\text{model}}(m_i; \\boldsymbol{p}) - \\gamma_{\\pm,i}] / \\sigma_i$.\n\nThe Jacobian matrix $J$ has elements $J_{ij} = \\partial r_i / \\partial p_j$. Using the chain rule:\n$$\n\\frac{\\partial r_i}{\\partial p_j} = \\frac{1}{\\sigma_i} \\frac{\\partial \\gamma_{\\pm}^{\\text{model}}(m_i; \\boldsymbol{p})}{\\partial p_j} = \\frac{1}{\\sigma_i} \\gamma_{\\pm}^{\\text{model}}(m_i; \\boldsymbol{p}) \\frac{\\partial \\ln \\gamma_{\\pm}(m_i; \\boldsymbol{p})}{\\partial p_j}\n$$\nThe partial derivatives of $\\ln \\gamma_{\\pm}$ with respect to the parameters are:\n$$\n\\frac{\\partial \\ln \\gamma_{\\pm}}{\\partial \\beta^{(0)}} = 2m\n$$\n$$\n\\frac{\\partial \\ln \\gamma_{\\pm}}{\\partial \\beta^{(1)}} = 2m \\, g(\\alpha \\sqrt{m})\n$$\n$$\n\\frac{\\partial \\ln \\gamma_{\\pm}}{\\partial C_{\\phi}} = 2m^2\n$$\nThese expressions allow for the analytical construction of the Jacobian matrix required by the optimization algorithm.\n\n**2. Parameter Covariance Matrix**\n\nOnce the optimal parameters $\\hat{\\boldsymbol{p}}$ that minimize $\\chi^2$ are found, their statistical uncertainty is described by the covariance matrix $\\Sigma$. Under the assumption of linearity of the model near the solution, the covariance matrix is estimated as:\n$$\n\\Sigma = s^2 (J^{\\top} J)^{-1}\n$$\nwhere $J$ is the Jacobian evaluated at the optimal parameters $\\hat{\\boldsymbol{p}}$. The quantity $s^2$ is the variance of the fit residuals, often estimated as the reduced chi-squared:\n$$\ns^2 = \\frac{\\chi^2(\\hat{\\boldsymbol{p}})}{N - P}\n$$\nwhere $N$ is the number of data points and $P=3$ is the number of fitted parameters.\n\n**3. Thermodynamic Factor and Uncertainty Propagation**\n\nThe thermodynamic factor $\\Theta(m)$ is a measure of the non-ideality gradient of the solution and is defined as:\n$$\n\\Theta(m) = 1 + m \\frac{d \\ln \\gamma_{\\pm}(m)}{d m}\n$$\nTo compute $\\Theta(m)$, we must first find the derivative of $\\ln \\gamma_{\\pm}(m)$ with respect to molality $m$:\n$$\n\\frac{d \\ln \\gamma_{\\pm}}{d m} = \\frac{d}{dm} \\left( -A_{\\gamma} \\frac{\\sqrt{m}}{1 + b \\sqrt{m}} \\right) + \\frac{d}{dm} \\left( 2 m \\beta^{(0)} \\right) + \\frac{d}{dm} \\left( 2 m \\beta^{(1)} g(\\alpha \\sqrt{m}) \\right) + \\frac{d}{dm} \\left( 2 m^2 C_{\\phi} \\right)\n$$\nEvaluating each derivative term by term gives:\n$$\n\\frac{d \\ln \\gamma_{\\pm}}{d m} = -\\frac{A_{\\gamma}}{2\\sqrt{m}(1 + b \\sqrt{m})^2} + 2\\beta^{(0)} + \\beta^{(1)} \\left( g(\\alpha\\sqrt{m}) + e^{-\\alpha\\sqrt{m}} \\right) + 4m C_{\\phi}\n$$\nSubstituting this into the definition of $\\Theta(m)$ yields the full expression:\n$$\n\\Theta(m; \\boldsymbol{p}) = 1 - \\frac{A_{\\gamma}\\sqrt{m}}{2(1+b\\sqrt{m})^2} + 2m\\beta^{(0)} + m\\beta^{(1)}\\left(g(\\alpha\\sqrt{m}) + e^{-\\alpha\\sqrt{m}}\\right) + 4m^2 C_{\\phi}\n$$\nThe uncertainty in the fitted parameters $\\boldsymbol{p}$ propagates to the calculated value of $\\Theta(m)$. Using first-order Taylor expansion (linear error propagation), the variance of $\\Theta$ at a specific molality $m^\\star$ can be approximated as:\n$$\n\\mathrm{Var}\\left[ \\Theta(m^\\star) \\right] = \\mathbf{J}_{\\Theta}(m^\\star) \\, \\Sigma \\, \\mathbf{J}_{\\Theta}(m^\\star)^{\\top}\n$$\nHere, $\\mathbf{J}_{\\Theta}(m^\\star)$ is the gradient (a row vector) of $\\Theta$ with respect to the parameters, evaluated at $\\hat{\\boldsymbol{p}}$ and $m=m^\\star$:\n$$\n\\mathbf{J}_{\\Theta}(m^\\star) = \\left[ \\frac{\\partial \\Theta}{\\partial \\beta^{(0)}}, \\frac{\\partial \\Theta}{\\partial \\beta^{(1)}}, \\frac{\\partial \\Theta}{\\partial C_{\\phi}} \\right]_{m=m^\\star}\n$$\nThe partial derivatives are:\n$$\n\\frac{\\partial \\Theta}{\\partial \\beta^{(0)}} = 2m\n$$\n$$\n\\frac{\\partial \\Theta}{\\partial \\beta^{(1)}} = m \\left( g(\\alpha\\sqrt{m}) + e^{-\\alpha\\sqrt{m}} \\right)\n$$\n$$\n\\frac{\\partial \\Theta}{\\partial C_{\\phi}} = 4m^2\n$$\nThe standard uncertainty in $\\Theta(m^\\star)$ is then $u_{\\Theta}(m^\\star) = \\sqrt{\\mathrm{Var}\\left[ \\Theta(m^\\star) \\right]}$.\n\n**4. Algorithmic Implementation**\n\nFor each case provided:\n1.  The experimental data $\\{ m_i, \\gamma_{\\pm,i}, \\sigma_i \\}$ and target molality $m^\\star$ are defined.\n2.  A nonlinear least-squares solver (`scipy.optimize.least_squares`) is used to find the optimal parameters $\\hat{\\boldsymbol{p}} = [\\hat{\\beta}^{(0)}, \\hat{\\beta}^{(1)}, \\hat{C}_{\\phi}]$ by minimizing $\\chi^2$. An initial guess of $[0,0,0]$ is used for the parameters. The analytical Jacobian is provided to the solver for accuracy and efficiency.\n3.  The parameter covariance matrix $\\Sigma$ is computed from the Jacobian at the solution and the reduced chi-squared value.\n4.  The value of the thermodynamic factor, $\\Theta(m^\\star)$, is calculated using the fitted parameters $\\hat{\\boldsymbol{p}}$.\n5.  The gradient vector $\\mathbf{J}_{\\Theta}(m^\\star)$ is computed.\n6.  The variance $\\mathrm{Var}[\\Theta(m^\\star)]$ and standard uncertainty $u_{\\Theta}(m^\\star)$ are calculated using the formulas for linear error propagation.\n7.  The pair $(\\Theta(m^\\star), u_{\\Theta}(m^\\star))$ is stored.\n\nThis procedure is repeated for all three test cases, and the final results are formatted as requested.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import least_squares\n\ndef solve():\n    \"\"\"\n    Solves the Pitzer parameter regression and uncertainty propagation problem.\n    \"\"\"\n    \n    # Constants for water at T = 298.15 K\n    A_gamma = 1.2  # Dimensionless, natural-logarithm base\n    b = 1.2        # kg^(1/2) mol^(-1/2)\n    alpha = 2.0    # kg^(1/2) mol^(-1/2)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"m_data\": np.array([0.05, 0.10, 0.50, 1.00, 2.00]),\n            \"gamma_data\": np.array([0.835, 0.803, 0.780, 0.846, 1.028]),\n            \"sigma_data\": np.array([0.005, 0.005, 0.006, 0.006, 0.010]),\n            \"m_star\": 0.20\n        },\n        {\n            \"m_data\": np.array([0.05, 0.10, 0.50, 1.00, 2.00]),\n            \"gamma_data\": np.array([0.832, 0.799, 0.776, 0.840, 1.036]),\n            \"sigma_data\": np.array([0.005, 0.005, 0.006, 0.006, 0.010]),\n            \"m_star\": 1.50\n        },\n        {\n            \"m_data\": np.array([0.05, 0.10, 0.50, 1.00, 2.00]),\n            \"gamma_data\": np.array([0.837, 0.806, 0.789, 0.850, 1.016]),\n            \"sigma_data\": np.array([0.005, 0.005, 0.006, 0.006, 0.010]),\n            \"m_star\": 0.80\n        }\n    ]\n\n    results = []\n    \n    # --- Model Functions ---\n\n    def g_func(x):\n        \"\"\"Brønsted function g(x) = (1 - exp(-x))/x.\"\"\"\n        # Note: In this problem, m  0, so x = alpha * sqrt(m)  0.\n        # No division by zero will occur.\n        return (1.0 - np.exp(-x)) / x\n\n    def ln_gamma_pm_model(m, params):\n        \"\"\"Pitzer model for ln(gamma_pm).\"\"\"\n        beta0, beta1, Cphi = params\n        sqrt_m = np.sqrt(m)\n        term1 = -A_gamma * sqrt_m / (1.0 + b * sqrt_m)\n        term2 = 2.0 * m * (beta0 + beta1 * g_func(alpha * sqrt_m))\n        term3 = 2.0 * m**2 * Cphi\n        return term1 + term2 + term3\n\n    def gamma_pm_model(m, params):\n        \"\"\"Pitzer model for gamma_pm.\"\"\"\n        return np.exp(ln_gamma_pm_model(m, params))\n\n    def residuals(params, m_data, gamma_data, sigma_data):\n        \"\"\"Weighted residuals for least-squares fitting.\"\"\"\n        model_gamma = gamma_pm_model(m_data, params)\n        return (model_gamma - gamma_data) / sigma_data\n\n    def jacobian_residuals(params, m_data, gamma_data, sigma_data):\n        \"\"\"Jacobian of the residuals w.r.t. parameters.\"\"\"\n        N = len(m_data)\n        P = len(params)\n        J = np.zeros((N, P))\n        \n        model_gamma_vals = gamma_pm_model(m_data, params)\n        \n        # Derivatives of ln(gamma_pm) w.r.t. parameters\n        d_ln_gamma_d_beta0 = 2.0 * m_data\n        d_ln_gamma_d_beta1 = 2.0 * m_data * g_func(alpha * np.sqrt(m_data))\n        d_ln_gamma_d_Cphi = 2.0 * m_data**2\n\n        # Jacobian columns\n        J[:, 0] = (1.0 / sigma_data) * model_gamma_vals * d_ln_gamma_d_beta0\n        J[:, 1] = (1.0 / sigma_data) * model_gamma_vals * d_ln_gamma_d_beta1\n        J[:, 2] = (1.0 / sigma_data) * model_gamma_vals * d_ln_gamma_d_Cphi\n        \n        return J\n\n    def theta_model(m, params):\n        \"\"\"Thermodynamic factor Theta(m).\"\"\"\n        beta0, beta1, Cphi = params\n        sqrt_m = np.sqrt(m)\n        x = alpha * sqrt_m\n\n        term1 = -A_gamma * sqrt_m / (2.0 * (1.0 + b * sqrt_m)**2)\n        term2 = 2.0 * m * beta0\n        term3 = m * beta1 * (g_func(x) + np.exp(-x))\n        term4 = 4.0 * m**2 * Cphi\n\n        return 1.0 + term1 + term2 + term3 + term4\n\n    def grad_theta(m):\n        \"\"\"Gradient of Theta(m) w.r.t. parameters.\"\"\"\n        sqrt_m = np.sqrt(m)\n        x = alpha * sqrt_m\n\n        d_theta_d_beta0 = 2.0 * m\n        d_theta_d_beta1 = m * (g_func(x) + np.exp(-x))\n        d_theta_d_Cphi = 4.0 * m**2\n        \n        return np.array([d_theta_d_beta0, d_theta_d_beta1, d_theta_d_Cphi])\n\n    # --- Main Loop ---\n    for case in test_cases:\n        m_data = case[\"m_data\"]\n        gamma_data = case[\"gamma_data\"]\n        sigma_data = case[\"sigma_data\"]\n        m_star = case[\"m_star\"]\n\n        # 1. Perform weighted nonlinear regression\n        p0 = [0.0, 0.0, 0.0]  # Initial guess for parameters\n        ls_result = least_squares(\n            residuals,\n            p0,\n            jac=jacobian_residuals,\n            args=(m_data, gamma_data, sigma_data),\n            method='trf'\n        )\n        \n        p_fit = ls_result.x\n        \n        # 2. Compute parameter covariance matrix\n        J = ls_result.jac\n        N = len(m_data)\n        P = len(p_fit)\n        \n        # The cost is 0.5 * sum(residual^2). chi2 is sum(residual^2).\n        chi2 = 2.0 * ls_result.cost\n        s_squared = chi2 / (N - P)\n        \n        try:\n            cov_matrix = s_squared * np.linalg.inv(J.T @ J)\n        except np.linalg.LinAlgError:\n            # In case of singularity, use pseudo-inverse\n            cov_matrix = s_squared * np.linalg.pinv(J.T @ J)\n\n        # 3. Compute Theta and its uncertainty\n        theta_val = theta_model(m_star, p_fit)\n        \n        # 4. Propagate uncertainty\n        J_theta = grad_theta(m_star)\n        var_theta = J_theta @ cov_matrix @ J_theta.T\n        u_theta = np.sqrt(var_theta)\n\n        results.extend([theta_val, u_theta])\n        \n    # Final print statement in the exact required format.\n    # Format to six decimal places.\n    print(f\"[{','.join(f'{x:.6f}' for x in results)}]\")\n\nsolve()\n```"
        }
    ]
}