{
    "hands_on_practices": [
        {
            "introduction": "A core challenge in battery design is to understand how macroscopic performance emerges from microscopic structure. This exercise provides a practical guide to building a simplified yet powerful predictive model, directly linking key design parameters like particle size distribution and porosity to an electrode's rate capability . By synthesizing fundamental electrochemical principles, you will develop a tool to assess design viability under high-current conditions.",
            "id": "3895234",
            "problem": "Consider a porous electrode for a lithium-ion battery whose microstructure is characterized by Scanning Electron Microscopy (SEM) yielding a discrete Particle Size Distribution (PSD) and whose transport in the liquid electrolyte phase is described by a tortuosity correlation. Starting from the following fundamental bases: (i) Ohm’s law in electrolytes, (ii) the definition of tortuosity in porous media applied to effective transport properties, (iii) the geometric relation of specific surface area of packed spheres, and (iv) Butler–Volmer kinetics for interfacial charge transfer, derive and implement a program to compute the effective ionic conductivity and specific surface area and to predict whether an electrode can sustain a constant-current discharge at a nominal two times the capacity rate (two-C rate), under separate allowable budgets for electrolyte ohmic drop and interfacial kinetic overpotential.\n\nUse the following fundamental bases and definitions as the starting point for the derivation:\n- Ohm’s law in electrolytes: in one dimension, the ionic current density $i_{e}$ is related to the electrolyte potential $\\phi_{e}$ via $i_{e} = - \\kappa \\frac{d \\phi_{e}}{d x}$, where $\\kappa$ is the intrinsic electrolyte ionic conductivity in $\\mathrm{S/m}$, and $x$ is the through-thickness coordinate in $\\mathrm{m}$. In a porous medium, the effective transport is reduced due to reduced cross-sectional area available for the electrolyte and increased path length.\n- Porous-media transport scaling: the effective ionic conductivity $\\kappa_{\\text{eff}}$ is defined from the formation factor such that $\\kappa_{\\text{eff}} = \\kappa \\frac{\\varepsilon}{\\tau}$, where $\\varepsilon$ is the volume fraction of electrolyte (porosity, dimensionless), and $\\tau$ is the tortuosity factor (dimensionless).\n- Tortuosity correlation: the tortuosity factor is correlated to porosity by $\\tau = \\varepsilon^{-\\beta}$, with $\\beta$ a positive exponent (dimensionless).\n- Specific surface area of packed spheres: for spherical particles with a number-based PSD, the surface-area-to-volume specific surface area $a_{s}$ in $\\mathrm{m^{-1}}$ is given by $a_{s} = \\frac{6 \\varepsilon_{s}}{d_{32}}$, where $\\varepsilon_{s}$ is the solid phase volume fraction (dimensionless) and $d_{32}$ is the Sauter mean particle diameter defined by $d_{32} = \\frac{\\sum_{i} w_{i} d_{i}^{3}}{\\sum_{i} w_{i} d_{i}^{2}}$ for number fractions $w_{i}$ and diameters $d_{i}$ in $\\mathrm{m}$.\n- Interfacial charge-transfer kinetics (Butler–Volmer, symmetric case): the interfacial current density per unit active surface area $j$ in $\\mathrm{A/m^{2}}$ relates to the interfacial overpotential $\\eta$ via $j = 2 i_{0} \\sinh\\left(\\frac{F \\eta}{2 R T}\\right)$, where $i_{0}$ is the exchange current density per unit active surface area in $\\mathrm{A/m^{2}}$, $F$ is the Faraday constant in $\\mathrm{C/mol}$, $R$ is the Universal gas constant in $\\mathrm{J/(mol \\cdot K)}$, and $T$ is absolute temperature in $\\mathrm{K}$. The geometric current density $i$ in $\\mathrm{A/m^{2}}$ is related to $j$ by $i = a_{s} j$.\n\nFrom these, derive:\n- The effective ionic conductivity $\\kappa_{\\text{eff}}$ in $\\mathrm{S/m}$ from $\\kappa_{\\text{eff}} = \\kappa \\frac{\\varepsilon}{\\tau} = \\kappa \\varepsilon^{1+\\beta}$.\n- The specific surface area $a_{s}$ in $\\mathrm{m^{-1}}$ from the Sauter mean diameter of the PSD using $a_{s} = \\frac{6 \\varepsilon_{s}}{d_{32}}$ with $d_{32} = \\frac{\\sum_{i} w_{i} d_{i}^{3}}{\\sum_{i} w_{i} d_{i}^{2}}$.\n- The maximum geometric current density that can be supported independently by electrolyte ohmic budget $\\Delta \\phi_{e,\\max}$ in $\\mathrm{V}$ over electrode thickness $L$ in $\\mathrm{m}$, and by kinetic overpotential budget $\\Delta \\phi_{k,\\max}$ in $\\mathrm{V}$:\n  - Electrolyte-limited current: $$i_{\\max}^{(\\text{elec})} = \\frac{\\kappa_{\\text{eff}} \\Delta \\phi_{e,\\max}}{L}.$$\n  - Kinetics-limited current: $$i_{\\max}^{(\\text{kin})} = a_{s} \\cdot \\left[ 2 i_{0} \\sinh\\left(\\frac{F \\Delta \\phi_{k,\\max}}{2 R T}\\right) \\right].$$\n- The applied two-C geometric current density $i_{2\\mathrm{C}}$ in $\\mathrm{A/m^{2}}$ from the areal capacity $Q_{A}$ in $\\mathrm{C/m^{2}}$ as $i_{2\\mathrm{C}} = \\frac{Q_{A}}{1800}$, since a two-C discharge nominally completes in $1800$ seconds.\n- The predicted rate margin at two-C, defined as the ratio of the most limiting sustainable current to the applied two-C current: $$\\mathcal{R} = \\frac{\\min\\left( i_{\\max}^{(\\text{elec})}, i_{\\max}^{(\\text{kin})} \\right)}{i_{2\\mathrm{C}}}.$$\n- A viability boolean flag indicating whether the electrode can sustain two-C, defined by $\\mathrm{viable} = (\\mathcal{R} \\geq 1)$.\n\nImplement a program that, for each test case in the suite below, computes $\\kappa_{\\text{eff}}$ in $\\mathrm{S/m}$, $a_{s}$ in $\\mathrm{m^{-1}}$, and the two-C rate margin $\\mathcal{R}$ (dimensionless), and returns also the viability boolean. All calculations must be performed at temperature $T = 298 \\, \\mathrm{K}$, with $F = 96485 \\, \\mathrm{C/mol}$ and $R = 8.314 \\, \\mathrm{J/(mol \\cdot K)}$. Use separate allowable budgets $\\Delta \\phi_{e,\\max} = 0.1 \\, \\mathrm{V}$ and $\\Delta \\phi_{k,\\max} = 0.1 \\, \\mathrm{V}$. Express $\\kappa_{\\text{eff}}$ in $\\mathrm{S/m}$, $a_{s}$ in $\\mathrm{m^{-1}}$, and $\\mathcal{R}$ as a decimal float. The viability must be a boolean.\n\nTest suite (each case is a tuple of parameters):\n- Case $1$ (representative microstructure):\n  - Diameters $d_{i}$ in $\\mathrm{m}$: $[6 \\times 10^{-6}, 8 \\times 10^{-6}, 10 \\times 10^{-6}, 12 \\times 10^{-6}]$.\n  - Number fractions $w_{i}$: $[0.2, 0.3, 0.3, 0.2]$.\n  - Porosity $\\varepsilon = 0.35$.\n  - Tortuosity exponent $\\beta = 1.5$.\n  - Intrinsic electrolyte conductivity $\\kappa = 1.2 \\, \\mathrm{S/m}$.\n  - Electrode thickness $L = 70 \\times 10^{-6} \\, \\mathrm{m}$.\n  - Solid volume fraction $\\varepsilon_{s} = 0.55$.\n  - Exchange current density $i_{0} = 3.5 \\, \\mathrm{A/m^{2}}$.\n  - Areal capacity $Q_{A} = 144000 \\, \\mathrm{C/m^{2}}$.\n- Case $2$ (low porosity, thicker electrode):\n  - Diameters $d_{i}$ in $\\mathrm{m}$: $[8 \\times 10^{-6}, 12 \\times 10^{-6}, 16 \\times 10^{-6}, 20 \\times 10^{-6}]$.\n  - Number fractions $w_{i}$: $[0.1, 0.4, 0.3, 0.2]$.\n  - Porosity $\\varepsilon = 0.15$.\n  - Tortuosity exponent $\\beta = 2.0$.\n  - Intrinsic electrolyte conductivity $\\kappa = 0.8 \\, \\mathrm{S/m}$.\n  - Electrode thickness $L = 100 \\times 10^{-6} \\, \\mathrm{m}$.\n  - Solid volume fraction $\\varepsilon_{s} = 0.75$.\n  - Exchange current density $i_{0} = 3.0 \\, \\mathrm{A/m^{2}}$.\n  - Areal capacity $Q_{A} = 250000 \\, \\mathrm{C/m^{2}}$.\n- Case $3$ (fine particles, high porosity):\n  - Diameters $d_{i}$ in $\\mathrm{m}$: $[1.2 \\times 10^{-6}, 1.5 \\times 10^{-6}, 2.0 \\times 10^{-6}]$.\n  - Number fractions $w_{i}$: $[0.4, 0.4, 0.2]$.\n  - Porosity $\\varepsilon = 0.60$.\n  - Tortuosity exponent $\\beta = 1.5$.\n  - Intrinsic electrolyte conductivity $\\kappa = 1.0 \\, \\mathrm{S/m}$.\n  - Electrode thickness $L = 50 \\times 10^{-6} \\, \\mathrm{m}$.\n  - Solid volume fraction $\\varepsilon_{s} = 0.40$.\n  - Exchange current density $i_{0} = 2.0 \\, \\mathrm{A/m^{2}}$.\n  - Areal capacity $Q_{A} = 80000 \\, \\mathrm{C/m^{2}}$.\n- Case $4$ (coarse particles, modest porosity, slow kinetics):\n  - Diameters $d_{i}$ in $\\mathrm{m}$: $[25 \\times 10^{-6}, 30 \\times 10^{-6}, 35 \\times 10^{-6}]$.\n  - Number fractions $w_{i}$: $[0.3, 0.5, 0.2]$.\n  - Porosity $\\varepsilon = 0.40$.\n  - Tortuosity exponent $\\beta = 1.5$.\n  - Intrinsic electrolyte conductivity $\\kappa = 1.4 \\, \\mathrm{S/m}$.\n  - Electrode thickness $L = 75 \\times 10^{-6} \\, \\mathrm{m}$.\n  - Solid volume fraction $\\varepsilon_{s} = 0.50$.\n  - Exchange current density $i_{0} = 1 \\times 10^{-4} \\, \\mathrm{A/m^{2}}$.\n  - Areal capacity $Q_{A} = 120000 \\, \\mathrm{C/m^{2}}$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case’s result is a list of the form $[\\kappa_{\\text{eff}}, a_{s}, \\mathcal{R}, \\mathrm{viable}]$. The units are $\\mathrm{S/m}$ for $\\kappa_{\\text{eff}}$, $\\mathrm{m^{-1}}$ for $a_{s}$, and dimensionless for $\\mathcal{R}$; the viability is a boolean. No other text should be printed.",
            "solution": "We begin from the fundamental laws and definitions. Ohm’s law for ionic conduction in the electrolyte phase gives $i_{e} = - \\kappa \\frac{d \\phi_{e}}{d x}$, for an electrolyte of intrinsic conductivity $\\kappa$ in $\\mathrm{S/m}$. In porous media, the effective transport is reduced because only a fraction $\\varepsilon$ of the cross section is available for the electrolyte and the paths are elongated due to microstructural complexity, described by a tortuosity factor $\\tau$. The standard formation-factor scaling yields the effective ionic conductivity $\\kappa_{\\text{eff}} = \\kappa \\frac{\\varepsilon}{\\tau}$. A widely used correlation for tortuosity in terms of porosity is $\\tau = \\varepsilon^{-\\beta}$, with a positive exponent $\\beta$ (often related to a Bruggeman-type exponent). Combining these yields\n$$\n\\kappa_{\\text{eff}} = \\kappa \\frac{\\varepsilon}{\\varepsilon^{-\\beta}} = \\kappa \\varepsilon^{1+\\beta}.\n$$\nThis expresses the effective ionic conductivity in a porous electrolyte as a function of the porosity and a tortuosity exponent.\n\nNext, for the specific surface area of packed spherical particles, we relate the surface area per unit electrode volume to the particle size distribution. For a number-based distribution with diameters $\\{d_{i}\\}$ and weights $\\{w_{i}\\}$ with $\\sum_{i} w_{i} = 1$, the Sauter mean diameter $d_{32}$ is defined by\n$$\nd_{32} = \\frac{\\sum_{i} w_{i} d_{i}^{3}}{\\sum_{i} w_{i} d_{i}^{2}}.\n$$\nFor spherical particles, the surface-area-to-volume ratio per unit electrode volume is\n$$\na_{s} = \\frac{6 \\varepsilon_{s}}{d_{32}},\n$$\nwhere $\\varepsilon_{s}$ is the solid phase volume fraction. This follows from the identity for a single sphere of diameter $d$: surface area $A = \\pi d^{2}$ and volume $V = \\frac{\\pi d^{3}}{6}$, so $A/V = 6/d$, and extends linearly using the number-based PSD to define the appropriate mean diameter.\n\nFor the interfacial kinetics, we use Butler–Volmer with symmetry factor $\\frac{1}{2}$, giving the interfacial current density per unit active surface area\n$$\nj = 2 i_{0} \\sinh\\left(\\frac{F \\eta}{2 R T} \\right),\n$$\nwhere $i_{0}$ is the exchange current density per unit surface area. The geometric current density (per electrode geometric area) is $i = a_{s} j$, which relates the overall current to the interfacial flux via the available surface area.\n\nWe impose separate allowable budgets for electrolyte ohmic drop and kinetic overpotential, $\\Delta \\phi_{e,\\max}$ and $\\Delta \\phi_{k,\\max}$ respectively. For one-dimensional transport across an electrode of thickness $L$, the electrolyte-limited maximum geometric current density is obtained from Ohm’s law integrated across the thickness,\n$$\ni_{\\max}^{(\\text{elec})} = \\frac{\\kappa_{\\text{eff}} \\Delta \\phi_{e,\\max}}{L}.\n$$\nFor the kinetics-limited maximum geometric current density, we use the Butler–Volmer expression at the overpotential budget $\\Delta \\phi_{k,\\max}$,\n$$\ni_{\\max}^{(\\text{kin})} = a_{s} \\cdot \\left[ 2 i_{0} \\sinh\\left(\\frac{F \\Delta \\phi_{k,\\max}}{2 R T} \\right) \\right].\n$$\nWe then compare these independent limits to the required two-C current. A two-C discharge completes in $1800$ seconds, so the geometric current density associated with an areal capacity $Q_{A}$ (in $\\mathrm{C/m^{2}}$) is\n$$\ni_{2\\mathrm{C}} = \\frac{Q_{A}}{1800}.\n$$\nWe define the rate margin,\n$$\n\\mathcal{R} = \\frac{\\min\\left( i_{\\max}^{(\\text{elec})}, i_{\\max}^{(\\text{kin})} \\right)}{i_{2\\mathrm{C}}}.\n$$\nIf $\\mathcal{R} \\geq 1$, the electrode can sustain two-C; otherwise it cannot. This yields a boolean viability: $\\mathrm{viable} = (\\mathcal{R} \\geq 1)$.\n\nAlgorithmically, the computation proceeds as follows for each test case:\n1. Compute $d_{32}$ from the given diameters $\\{d_{i}\\}$ and weights $\\{w_{i}\\}$ via $d_{32} = \\frac{\\sum_{i} w_{i} d_{i}^{3}}{\\sum_{i} w_{i} d_{i}^{2}}$.\n2. Compute $a_{s} = \\frac{6 \\varepsilon_{s}}{d_{32}}$.\n3. Compute $\\kappa_{\\text{eff}} = \\kappa \\varepsilon^{1+\\beta}$.\n4. Compute $i_{\\max}^{(\\text{elec})} = \\frac{\\kappa_{\\text{eff}} \\Delta \\phi_{e,\\max}}{L}$.\n5. Compute $i_{\\max}^{(\\text{kin})} = a_{s} \\cdot \\left[ 2 i_{0} \\sinh\\left(\\frac{F \\Delta \\phi_{k,\\max}}{2 R T} \\right) \\right]$.\n6. Compute $i_{2\\mathrm{C}} = \\frac{Q_{A}}{1800}$.\n7. Compute $\\mathcal{R} = \\frac{\\min\\left( i_{\\max}^{(\\text{elec})}, i_{\\max}^{(\\text{kin})} \\right)}{i_{2\\mathrm{C}}}$ and $\\mathrm{viable} = (\\mathcal{R} \\geq 1)$.\n\nNumerical constants used are $F = 96485 \\, \\mathrm{C/mol}$, $R = 8.314 \\, \\mathrm{J/(mol \\cdot K)}$, and $T = 298 \\, \\mathrm{K}$. The budgets are $\\Delta \\phi_{e,\\max} = 0.1 \\, \\mathrm{V}$ and $\\Delta \\phi_{k,\\max} = 0.1 \\, \\mathrm{V}$, and units must be consistent: diameters in $\\mathrm{m}$, thickness in $\\mathrm{m}$, conductivities in $\\mathrm{S/m}$, areal capacity in $\\mathrm{C/m^{2}}$, and current densities in $\\mathrm{A/m^{2}}$. The outputs are $\\kappa_{\\text{eff}}$ in $\\mathrm{S/m}$, $a_{s}$ in $\\mathrm{m^{-1}}$, and $\\mathcal{R}$ dimensionless, along with the boolean viability.\n\nApplying this procedure to the provided test suite will produce, for each case, a list $[\\kappa_{\\text{eff}}, a_{s}, \\mathcal{R}, \\mathrm{viable}]$, and the program aggregates these into a single output line formatted as a comma-separated list enclosed in square brackets.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_sauter_mean_diameter(diams, weights):\n    \"\"\"\n    Compute Sauter mean diameter d32 for a number-based PSD.\n    diams: array of diameters [m]\n    weights: array of number fractions (sum to 1)\n    \"\"\"\n    diams = np.array(diams, dtype=float)\n    weights = np.array(weights, dtype=float)\n    # Ensure weights sum to 1 (tolerant normalization)\n    if not np.isclose(weights.sum(), 1.0):\n        weights = weights / weights.sum()\n    num = np.sum(weights * diams**3)\n    den = np.sum(weights * diams**2)\n    return num / den\n\ndef rate_capability_case(psd_diams, psd_weights, eps, beta, kappa, L, eps_s, i0, Q_A,\n                         delta_phi_e_max=0.1, delta_phi_k_max=0.1, T=298.0):\n    \"\"\"\n    Compute kappa_eff [S/m], a_s [1/m], rate margin R, and viability boolean for one case.\n    \"\"\"\n    F = 96485.0  # C/mol\n    Rgas = 8.314  # J/(mol*K)\n\n    # Sauter mean diameter and specific surface area\n    d32 = compute_sauter_mean_diameter(psd_diams, psd_weights)\n    a_s = 6.0 * eps_s / d32  # [1/m]\n\n    # Effective ionic conductivity using kappa_eff = kappa * eps^(1+beta)\n    kappa_eff = kappa * (eps ** (1.0 + beta))\n\n    # Electrolyte-limited current density\n    i_max_elec = (kappa_eff * delta_phi_e_max) / L\n\n    # Kinetics-limited current density\n    arg = (F * delta_phi_k_max) / (2.0 * Rgas * T)\n    i_max_kin = a_s * (2.0 * i0 * np.sinh(arg))\n\n    # Two-C geometric current density\n    i_2C = Q_A / 1800.0\n\n    # Rate margin and viability\n    limiting_i = min(i_max_elec, i_max_kin)\n    rate_margin = limiting_i / i_2C\n    viable = rate_margin >= 1.0\n\n    return kappa_eff, a_s, rate_margin, viable\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1\n        {\n            \"psd_diams\": [6e-6, 8e-6, 10e-6, 12e-6],\n            \"psd_weights\": [0.2, 0.3, 0.3, 0.2],\n            \"eps\": 0.35,\n            \"beta\": 1.5,\n            \"kappa\": 1.2,\n            \"L\": 70e-6,\n            \"eps_s\": 0.55,\n            \"i0\": 3.5,\n            \"Q_A\": 144000.0,\n        },\n        # Case 2\n        {\n            \"psd_diams\": [8e-6, 12e-6, 16e-6, 20e-6],\n            \"psd_weights\": [0.1, 0.4, 0.3, 0.2],\n            \"eps\": 0.15,\n            \"beta\": 2.0,\n            \"kappa\": 0.8,\n            \"L\": 100e-6,\n            \"eps_s\": 0.75,\n            \"i0\": 3.0,\n            \"Q_A\": 250000.0,\n        },\n        # Case 3\n        {\n            \"psd_diams\": [1.2e-6, 1.5e-6, 2.0e-6],\n            \"psd_weights\": [0.4, 0.4, 0.2],\n            \"eps\": 0.60,\n            \"beta\": 1.5,\n            \"kappa\": 1.0,\n            \"L\": 50e-6,\n            \"eps_s\": 0.40,\n            \"i0\": 2.0,\n            \"Q_A\": 80000.0,\n        },\n        # Case 4\n        {\n            \"psd_diams\": [25e-6, 30e-6, 35e-6],\n            \"psd_weights\": [0.3, 0.5, 0.2],\n            \"eps\": 0.40,\n            \"beta\": 1.5,\n            \"kappa\": 1.4,\n            \"L\": 75e-6,\n            \"eps_s\": 0.50,\n            \"i0\": 1e-4,\n            \"Q_A\": 120000.0,\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        kappa_eff, a_s, rate_margin, viable = rate_capability_case(\n            case[\"psd_diams\"],\n            case[\"psd_weights\"],\n            case[\"eps\"],\n            case[\"beta\"],\n            case[\"kappa\"],\n            case[\"L\"],\n            case[\"eps_s\"],\n            case[\"i0\"],\n            case[\"Q_A\"],\n            delta_phi_e_max=0.1,\n            delta_phi_k_max=0.1,\n            T=298.0\n        )\n        results.append([kappa_eff, a_s, rate_margin, viable])\n\n    # Final print statement in the exact required format.\n    # Convert booleans and floats to strings, preserve Python default formatting.\n    def item_to_str(item):\n        if isinstance(item, list):\n            return \"[\" + \",\".join(item_to_str(x) for x in item) + \"]\"\n        else:\n            return str(item)\n\n    print(\"[\" + \",\".join(item_to_str(res) for res in results) + \"]\")\n\nsolve()\n```"
        },
        {
            "introduction": "A simulation model is only as reliable as its input parameters, many of which are difficult to measure directly. This practice introduces the sophisticated framework of Bayesian inference to estimate crucial kinetic and transport parameters, such as the solid-state diffusivity $D_{s}$ and exchange current density $i_{0}$, by fitting a model to experimental voltage data . You will derive the core component of a Metropolis-Hastings algorithm, a cornerstone technique for quantifying parameter uncertainty and creating robust digital twins.",
            "id": "3895229",
            "problem": "Consider a lithium-ion battery electrode modeled by the Single Particle Model (SPM), where the solid-phase lithium concentration in a representative spherical particle of radius $R$ evolves under Fick's second law with diffusion coefficient $D_{s}$ and is driven at the surface by the interfacial reaction current density governed by Butler–Volmer kinetics with exchange current density $i_{0}$. Under a known applied current profile $I(t)$ and known electrode and electrolyte properties, a high-fidelity simulator computes a deterministic terminal voltage trajectory $\\{f_{k}(D_{s}, i_{0})\\}_{k=1}^{N}$ at sampling times $\\{t_{k}\\}_{k=1}^{N}$, where $f_{k}(D_{s}, i_{0})$ denotes the predicted voltage at time $t_{k}$ given parameters $D_{s}$ and $i_{0}$. Assume an additive measurement model for the voltage data,\n$$\nV_{k} = f_{k}(D_{s}, i_{0}) + \\varepsilon_{k}, \\quad k=1,\\dots,N,\n$$\nwith independent Gaussian noise $\\varepsilon_{k} \\sim \\mathcal{N}(0, \\sigma^{2})$, where $\\sigma^{2}$ is known.\n\nYou are tasked with performing Bayesian parameter estimation for the two parameters $D_{s}$ and $i_{0}$. Let the prior distributions be specified on the logarithms of these parameters:\n$$\n\\ln D_{s} \\sim \\mathcal{N}(\\mu_{D}, \\sigma_{D}^{2}), \\qquad \\ln i_{0} \\sim \\mathcal{N}(\\mu_{i}, \\sigma_{i}^{2}),\n$$\nand assume prior independence. Define the parameter vector in log-space as $\\boldsymbol{\\eta} = (\\eta_{D}, \\eta_{i})^{\\top}$ with $\\eta_{D} = \\ln D_{s}$ and $\\eta_{i} = \\ln i_{0}$.\n\nStarting from first principles—namely, Fick's second law for solid diffusion in a spherical particle, Butler–Volmer kinetics relating interfacial current density to exchange current density, and the Gaussian measurement model—explain the Bayesian formulation for estimating $D_{s}$ and $i_{0}$ from the voltage data $\\{V_{k}\\}_{k=1}^{N}$, and derive the posterior distribution up to a proportionality constant. Then, consider a Metropolis–Hastings (MH) algorithm that proposes in log-space via a symmetric Gaussian random walk:\n$$\n\\eta_{D}' = \\eta_{D} + \\xi_{D}, \\qquad \\eta_{i}' = \\eta_{i} + \\xi_{i},\n$$\nwhere $\\xi_{D} \\sim \\mathcal{N}(0, s_{D}^{2})$, $\\xi_{i} \\sim \\mathcal{N}(0, s_{i}^{2})$, independently. The proposed parameters in the original space are $(D_{s}', i_{0}') = (\\exp(\\eta_{D}'), \\exp(\\eta_{i}'))$.\n\nDerive a closed-form expression for the Metropolis–Hastings acceptance probability $\\alpha$ for moving from the current state $(D_{s}, i_{0})$ to the proposed state $(D_{s}', i_{0}')$ under this symmetric proposal in log-space. Your final answer must be a single analytic expression for $\\alpha$ in terms of $\\{V_{k}\\}_{k=1}^{N}$, $\\{f_{k}(D_{s}, i_{0})\\}_{k=1}^{N}$, $\\{f_{k}(D_{s}', i_{0}')\\}_{k=1}^{N}$, $\\sigma^{2}$, $\\mu_{D}$, $\\sigma_{D}^{2}$, $\\mu_{i}$, and $\\sigma_{i}^{2}$. No numerical evaluation is required, and no rounding is needed. Express the final acceptance probability as a closed-form expression.",
            "solution": "The problem presented is a well-defined task in Bayesian parameter estimation applied to a standard electrochemical model of a lithium-ion battery. All components—the physical model (Single Particle Model), the statistical framework (Bayesian inference with Gaussian noise), and the numerical method (Metropolis-Hastings MCMC)—are sound and clearly specified. The givens are self-contained and consistent, allowing for a direct and rigorous derivation. Therefore, the problem is valid.\n\nThe process to solve this problem involves two main parts: first, formulating the posterior probability distribution for the parameters of interest, and second, deriving the acceptance probability for the specified Metropolis-Hastings algorithm.\n\nFirst, we establish the Bayesian framework. The goal is to find the posterior distribution of the parameters given the data. Let the parameter vector be $\\boldsymbol{\\theta} = (D_{s}, i_{0})^{\\top}$ and the observed voltage data be $\\mathbf{V} = \\{V_{k}\\}_{k=1}^{N}$. According to Bayes' theorem, the posterior probability is proportional to the product of the likelihood and the prior:\n$$\np(\\boldsymbol{\\theta} | \\mathbf{V}) \\propto p(\\mathbf{V} | \\boldsymbol{\\theta}) \\, p(\\boldsymbol{\\theta})\n$$\nThe problem is defined in terms of the log-parameters $\\boldsymbol{\\eta} = (\\eta_{D}, \\eta_{i})^{\\top} = (\\ln D_{s}, \\ln i_{0})^{\\top}$. It is more convenient to work in this log-space. The posterior for $\\boldsymbol{\\eta}$ is:\n$$\np(\\boldsymbol{\\eta} | \\mathbf{V}) \\propto p(\\mathbf{V} | \\boldsymbol{\\eta}) \\, p(\\boldsymbol{\\eta})\n$$\n\nThe likelihood function, $p(\\mathbf{V} | \\boldsymbol{\\eta})$, is derived from the measurement model $V_{k} = f_{k}(D_{s}, i_{0}) + \\varepsilon_{k}$, where $\\varepsilon_{k} \\sim \\mathcal{N}(0, \\sigma^{2})$ are independent and identically distributed Gaussian noise terms. The probability density for a single measurement $V_k$ given the parameters is:\n$$\np(V_{k} | \\boldsymbol{\\eta}) = \\frac{1}{\\sqrt{2\\pi\\sigma^{2}}} \\exp\\left( -\\frac{(V_k - f_k(\\exp(\\eta_{D}), \\exp(\\eta_{i})))^2}{2\\sigma^2} \\right)\n$$\nDue to the independence of the noise terms $\\varepsilon_k$, the joint likelihood for the entire dataset $\\mathbf{V}$ is the product of the individual likelihoods:\n$$\np(\\mathbf{V} | \\boldsymbol{\\eta}) = \\prod_{k=1}^{N} p(V_{k} | \\boldsymbol{\\eta}) = \\left(\\frac{1}{2\\pi\\sigma^{2}}\\right)^{N/2} \\exp\\left( -\\frac{1}{2\\sigma^{2}} \\sum_{k=1}^{N} (V_k - f_k(\\exp(\\eta_{D}), \\exp(\\eta_{i})))^2 \\right)\n$$\n\nThe prior distribution, $p(\\boldsymbol{\\eta})$, is given for the log-parameters. We have $\\eta_{D} = \\ln D_{s} \\sim \\mathcal{N}(\\mu_{D}, \\sigma_{D}^{2})$ and $\\eta_{i} = \\ln i_{0} \\sim \\mathcal{N}(\\mu_{i}, \\sigma_{i}^{2})$. Due to prior independence, the joint prior density is the product of the individual densities:\n$$\np(\\boldsymbol{\\eta}) = p(\\eta_{D}) p(\\eta_{i}) = \\frac{1}{\\sqrt{2\\pi\\sigma_{D}^{2}}} \\exp\\left( -\\frac{(\\eta_{D} - \\mu_{D})^2}{2\\sigma_{D}^2} \\right) \\frac{1}{\\sqrt{2\\pi\\sigma_{i}^{2}}} \\exp\\left( -\\frac{(\\eta_{i} - \\mu_{i})^2}{2\\sigma_{i}^2} \\right)\n$$\n\nCombining the likelihood and the prior, the posterior distribution for $\\boldsymbol{\\eta}$, up to a proportionality constant, is:\n$$\np(\\boldsymbol{\\eta} | \\mathbf{V}) \\propto \\exp\\left( -\\frac{1}{2\\sigma^{2}} \\sum_{k=1}^{N} (V_k - f_k(\\exp(\\eta_{D}), \\exp(\\eta_{i})))^2 -\\frac{(\\eta_{D} - \\mu_{D})^2}{2\\sigma_{D}^2} -\\frac{(\\eta_{i} - \\mu_{i})^2}{2\\sigma_{i}^2} \\right)\n$$\nLet's denote the unnormalized posterior as $\\pi(\\boldsymbol{\\eta}) = p(\\mathbf{V} | \\boldsymbol{\\eta}) p(\\boldsymbol{\\eta})$.\n\nNext, we derive the Metropolis-Hastings (MH) acceptance probability, $\\alpha$. The MH algorithm is a Markov chain Monte Carlo (MCMC) method used to draw samples from a probability distribution. Given the current state $\\boldsymbol{\\eta}$, a new state $\\boldsymbol{\\eta}'$ is proposed from a proposal distribution $q(\\boldsymbol{\\eta}' | \\boldsymbol{\\eta})$. The proposed move is accepted with probability:\n$$\n\\alpha(\\boldsymbol{\\eta}', \\boldsymbol{\\eta}) = \\min \\left( 1, \\frac{\\pi(\\boldsymbol{\\eta}') q(\\boldsymbol{\\eta} | \\boldsymbol{\\eta}')}{\\pi(\\boldsymbol{\\eta}) q(\\boldsymbol{\\eta}' | \\boldsymbol{\\eta})} \\right)\n$$\nThe problem specifies a symmetric Gaussian random walk proposal in log-space: $\\eta_{D}' = \\eta_{D} + \\xi_{D}$ and $\\eta_{i}' = \\eta_{i} + \\xi_{i}$, where $\\xi_{D} \\sim \\mathcal{N}(0, s_{D}^{2})$ and $\\xi_{i} \\sim \\mathcal{N}(0, s_{i}^{2})$. The density of the proposal distribution is:\n$$\nq(\\boldsymbol{\\eta}' | \\boldsymbol{\\eta}) \\propto \\exp\\left( -\\frac{(\\eta_{D}' - \\eta_{D})^2}{2s_{D}^2} - \\frac{(\\eta_{i}' - \\eta_{i})^2}{2s_{i}^2} \\right)\n$$\nTo check for symmetry, we examine $q(\\boldsymbol{\\eta} | \\boldsymbol{\\eta}')$:\n$$\nq(\\boldsymbol{\\eta} | \\boldsymbol{\\eta}') \\propto \\exp\\left( -\\frac{(\\eta_{D} - \\eta_{D}')^2}{2s_{D}^2} - \\frac{(\\eta_{i} - \\eta_{i}')^2}{2s_{i}^2} \\right)\n$$\nSince $(\\eta_D - \\eta_D')^2 = (\\eta_D' - \\eta_D)^2$ and $(\\eta_i - \\eta_i')^2 = (\\eta_i' - \\eta_i)^2$, the proposal distribution is symmetric, i.e., $q(\\boldsymbol{\\eta} | \\boldsymbol{\\eta}') = q(\\boldsymbol{\\eta}' | \\boldsymbol{\\eta})$. This simplifies the acceptance probability to:\n$$\n\\alpha(\\boldsymbol{\\eta}', \\boldsymbol{\\eta}) = \\min \\left( 1, \\frac{\\pi(\\boldsymbol{\\eta}')}{\\pi(\\boldsymbol{\\eta})} \\right) = \\min \\left( 1, \\frac{p(\\mathbf{V} | \\boldsymbol{\\eta}') p(\\boldsymbol{\\eta}')}{p(\\mathbf{V} | \\boldsymbol{\\eta}) p(\\boldsymbol{\\eta})} \\right)\n$$\nThe ratio of the posteriors can be calculated in log-space to avoid numerical underflow. Let the current state be $(D_{s}, i_{0})$ and the proposed state be $(D_{s}', i_{0}')$. These correspond to $\\boldsymbol{\\eta} = (\\ln D_{s}, \\ln i_{0})^{\\top}$ and $\\boldsymbol{\\eta}' = (\\ln D_{s}', \\ln i_{0}')^{\\top}$.\n\nThe ratio of the likelihoods is:\n$$\n\\frac{p(\\mathbf{V} | \\boldsymbol{\\eta}')}{p(\\mathbf{V} | \\boldsymbol{\\eta})} = \\frac{\\exp\\left( -\\frac{1}{2\\sigma^{2}} \\sum_{k=1}^{N} (V_k - f_k(D_{s}', i_{0}'))^2 \\right)}{\\exp\\left( -\\frac{1}{2\\sigma^{2}} \\sum_{k=1}^{N} (V_k - f_k(D_{s}, i_{0}))^2 \\right)} = \\exp\\left( \\frac{1}{2\\sigma^{2}} \\left[ \\sum_{k=1}^{N} (V_k - f_k(D_s, i_0))^2 - \\sum_{k=1}^{N} (V_k - f_k(D_s', i_0'))^2 \\right] \\right)\n$$\nThe ratio of the priors is:\n$$\n\\frac{p(\\boldsymbol{\\eta}')}{p(\\boldsymbol{\\eta})} = \\frac{\\exp\\left( -\\frac{(\\ln D_s' - \\mu_{D})^2}{2\\sigma_{D}^2} -\\frac{(\\ln i_0' - \\mu_{i})^2}{2\\sigma_{i}^2} \\right)}{\\exp\\left( -\\frac{(\\ln D_s - \\mu_{D})^2}{2\\sigma_{D}^2} -\\frac{(\\ln i_0 - \\mu_{i})^2}{2\\sigma_{i}^2} \\right)} = \\exp\\left( \\frac{(\\ln D_s - \\mu_D)^2 - (\\ln D_s' - \\mu_D)^2}{2\\sigma_D^2} + \\frac{(\\ln i_0 - \\mu_i)^2 - (\\ln i_0' - \\mu_i)^2}{2\\sigma_i^2} \\right)\n$$\nCombining these two ratios, the argument of the $\\min$ function is:\n$$\n\\frac{\\pi(\\boldsymbol{\\eta'})}{\\pi(\\boldsymbol{\\eta})} = \\exp\\left( \\frac{1}{2\\sigma^{2}}\\sum_{k=1}^{N}\\left[ (V_k - f_k(D_s, i_0))^2 - (V_k - f_k(D_s', i_0'))^2 \\right] + \\frac{(\\ln D_s - \\mu_D)^2 - (\\ln D_s' - \\mu_D)^2}{2\\sigma_D^2} + \\frac{(\\ln i_0 - \\mu_i)^2 - (\\ln i_0' - \\mu_i)^2}{2\\sigma_i^2} \\right)\n$$\nThe acceptance probability $\\alpha$ is the minimum of $1$ and this expression. This is the final closed-form expression.",
            "answer": "$$ \\boxed{ \\min\\left(1, \\exp\\left( \\frac{1}{2\\sigma^{2}}\\sum_{k=1}^{N}\\left[ (V_k - f_k(D_s, i_0))^{2} - (V_k - f_k(D_s', i_0'))^{2} \\right] + \\frac{(\\ln D_s - \\mu_D)^{2} - (\\ln D_s' - \\mu_D)^{2}}{2\\sigma_D^{2}} + \\frac{(\\ln i_0 - \\mu_i)^{2} - (\\ln i_0' - \\mu_i)^{2}}{2\\sigma_i^{2}} \\right)\\right) } $$"
        },
        {
            "introduction": "To automate and accelerate the search for optimal battery designs, we must move beyond brute-force parameter sweeps and employ gradient-based optimization. The main challenge is to efficiently compute the sensitivity—or gradient—of performance objectives with respect to design variables . This advanced practice dives into the computational engine of optimization by implementing and comparing the tangent linear and discrete adjoint methods for a simplified battery model.",
            "id": "3895195",
            "problem": "You are given a simplified, nondimensionalized, discretized Pseudo-Two-Dimensional (P2D) model of a positive electrode domain under a prescribed pulse current test. The task is to implement tangent linear (forward) sensitivity for the particle radius $R_{p}$ and the electrode porosity $\\varepsilon_{p}$, and compare these to adjoint-based gradients for the same objective. All quantities are nondimensional; report the final results in dimensionless units.\n\nFundamental base and model definitions:\n- Conservation of mass in the solid particles is represented by a two-state linearized spherical diffusion approximation, where $c_{s,\\mathrm{avg}}$ denotes the average solid concentration and $c_{s,\\mathrm{surf}}$ denotes the surface solid concentration. The characteristic solid diffusion coefficient is $D_{s}$.\n- Conservation of mass in the electrolyte is modeled as a one-dimensional diffusion equation across the positive electrode thickness discretized into $N$ nodes, with effective diffusion coefficient $D_{e,\\mathrm{eff}} = D_{e} \\varepsilon_{p}^{b}$, where $D_{e}$ is the reference electrolyte diffusion coefficient and $b$ is the Bruggeman coefficient.\n- The interfacial reaction flux $j(t)$ is related to the applied current $I(t)$ via the specific surface area $a_{s} = 3 \\varepsilon_{p}/R_{p}$, leading to $j(t) = I(t) / a_{s} = I(t) R_{p} / (3 \\varepsilon_{p})$.\n- The terminal voltage $V(t)$ is modeled as $V(t) = U_{0} + \\alpha c_{s,\\mathrm{surf}}(t) - \\delta \\overline{c}_{e}(t)$, with $\\overline{c}_{e}(t)$ the arithmetic mean of the electrolyte concentration across the $N$ nodes. Constants $U_{0}$, $\\alpha$, and $\\delta$ are given.\n\nState-space representation:\nLet the state vector be $x(t) \\in \\mathbb{R}^{2+N}$ with $x = [c_{s,\\mathrm{avg}}, c_{s,\\mathrm{surf}}, c_{e,1}, \\ldots, c_{e,N}]^{\\top}$. The dynamics are:\n- $c_{s,\\mathrm{avg}}'(t) = - j(t)$.\n- $c_{s,\\mathrm{surf}}'(t) = \\frac{D_{s}}{R_{p}^{2}} \\left(c_{s,\\mathrm{avg}}(t) - c_{s,\\mathrm{surf}}(t)\\right) - j(t)$.\n- $c_{e}'(t) = D_{e} \\varepsilon_{p}^{b} L c_{e}(t) - \\gamma j(t) \\mathbf{1}$, where $L \\in \\mathbb{R}^{N \\times N}$ is the standard second-difference Laplacian with zero-flux (Neumann) boundary conditions on the two ends of the discretized domain, $\\mathbf{1}$ is the $N$-dimensional vector of ones, and $\\gamma$ is a constant.\n\nInitial conditions:\n- $c_{s,\\mathrm{avg}}(0) = 0$, $c_{s,\\mathrm{surf}}(0) = 0$, and $c_{e,i}(0) = 1$ for all $i \\in \\{1, \\ldots, N\\}$.\n\nPulse current test:\n- Let the total simulation time be $T$, the time step be $\\Delta t$, and the discrete times be $t_{k} = k \\Delta t$ for $k \\in \\{0, 1, \\ldots, K\\}$ with $K = T / \\Delta t$.\n- The applied current is $I(t) = 0$ for $t \\in [0, t_{1})$, $I(t) = I_{0}$ for $t \\in [t_{1}, t_{2})$, and $I(t) = 0$ for $t \\in [t_{2}, T]$, with $t_{1}$ and $t_{2}$ specified.\n\nObjective functional:\n- Let the reference voltage trace $V_{\\mathrm{ref}}(t)$ be generated by the same model under baseline parameters $(R_{p}^{\\mathrm{ref}}, \\varepsilon_{p}^{\\mathrm{ref}})$. The objective to differentiate is\n$$\nJ(R_{p}, \\varepsilon_{p}) = \\frac{1}{2} \\sum_{k=0}^{K} w \\left(V(t_{k}) - V_{\\mathrm{ref}}(t_{k})\\right)^{2} \\Delta t,\n$$\nwith constant weight $w$.\n\nSensitivity and adjoint requirements:\n- Implement the tangent linear sensitivity equations for the discrete-time explicit Euler integrator of the given model, computing $\\frac{\\partial J}{\\partial R_{p}}$ and $\\frac{\\partial J}{\\partial \\varepsilon_{p}}$.\n- Implement the discrete adjoint method consistent with explicit Euler time-stepping to compute the same gradients.\n- Compare the two gradient computations by reporting the absolute difference for each parameter in each test case.\n\nDiscretization details:\n- Use explicit Euler time-stepping: $x_{k+1} = x_{k} + \\Delta t \\, f(x_{k}, R_{p}, \\varepsilon_{p}, t_{k})$.\n- Use a one-dimensional Laplacian $L$ with zero-flux boundary conditions on a uniform grid of $N$ nodes over a unit-length domain, i.e., grid spacing $d = 1/N$. For interior nodes, use the standard second difference stencil scaled by $1/d^{2}$; for boundary nodes, use mirrored values to impose zero-flux conditions.\n\nConstants to use:\n- $N = 5$, $D_{s} = 0.1$, $D_{e} = 0.2$, $b = 1.5$, $\\gamma = 0.05$, $U_{0} = 0.0$, $\\alpha = 0.8$, $\\delta = 0.3$.\n- $T = 1.0$, $\\Delta t = 0.001$, $I_{0} = 1.0$, $t_{1} = 0.2$, $t_{2} = 0.7$, $w = 1.0$.\n- Baseline reference parameters: $R_{p}^{\\mathrm{ref}} = 1.0$, $\\varepsilon_{p}^{\\mathrm{ref}} = 0.5$.\n\nTest suite:\n- Case $1$: $R_{p} = 1.0$, $\\varepsilon_{p} = 0.5$ (baseline \"happy path\").\n- Case $2$: $R_{p} = 0.3$, $\\varepsilon_{p} = 0.5$ (small particle radius).\n- Case $3$: $R_{p} = 1.0$, $\\varepsilon_{p} = 0.9$ (high porosity).\n- Case $4$: $R_{p} = 1.0$, $\\varepsilon_{p} = 0.1$ (low porosity).\n\nFinal output format:\n- Your program should produce a single line of output containing a comma-separated list enclosed in square brackets. The list must contain the absolute differences between the tangent and adjoint gradients for $(R_{p}, \\varepsilon_{p})$ in the order\n$$\n[\\left|\\frac{\\partial J}{\\partial R_{p}}\\right|_{\\mathrm{tan}} - \\left|\\frac{\\partial J}{\\partial R_{p}}\\right|_{\\mathrm{adj}}, \\left|\\frac{\\partial J}{\\partial \\varepsilon_{p}}\\right|_{\\mathrm{tan}} - \\left|\\frac{\\partial J}{\\partial \\varepsilon_{p}}\\right|_{\\mathrm{adj}}, \\ldots]\n$$\nfor the four cases listed above. Express the differences as raw floating-point numbers (dimensionless).\n\nAll mathematical entities must be presented in LaTeX using inline formatting with dollar signs, and every acronym must be expanded at its first appearance.",
            "solution": "The solution involves three main stages: first, simulating the model forward in time to obtain the state and voltage trajectories (the primal solution); second, calculating the gradients using the tangent linear model; and third, calculating a second set of gradients using the discrete adjoint method.\n\n**1. Primal Problem: Forward Simulation**\n\nThe system dynamics can be written in a compact form $x' = f(x, p, t)$, where $p = [R_p, \\varepsilon_p]^{\\top}$ is the parameter vector. We discretize this using the Explicit Euler method over a time grid $t_k = k \\Delta t$ for $k=0, \\ldots, K$:\n$$ x_{k+1} = x_k + \\Delta t \\, f(x_k, p, t_k) $$\nThis equation is solved iteratively starting from the initial condition $x_0 = [0, 0, 1, \\ldots, 1]^{\\top}$. At each time step $t_k$, the state $x_k$ is used to compute the voltage $V_k$. The full histories $x_{\\mathrm{hist}}=[x_0, \\ldots, x_K]$ and $V_{\\mathrm{hist}}=[V_0, \\ldots, V_K]$ are stored. This process is first performed for the reference parameters $p_{\\mathrm{ref}} = [R_p^{\\mathrm{ref}}, \\varepsilon_p^{\\mathrm{ref}}]^{\\top}$ to generate $V_{\\mathrm{ref}}(t_k)$.\n\n**2. Tangent Linear Model (Forward Sensitivity Analysis)**\n\nThe tangent linear model computes the sensitivity of the state vector with respect to a parameter $p_j \\in \\{R_p, \\varepsilon_p\\}$, denoted by $s^{(j)}_k = \\frac{ d x_k }{ d p_j }$. Differentiating the Euler step with respect to $p_j$ yields the propagation rule for the sensitivities:\n$$ s^{(j)}_{k+1} = \\frac{d x_{k+1}}{d p_j} = \\frac{d}{d p_j} \\left( x_k + \\Delta t \\, f(x_k, p, t_k) \\right) = \\frac{d x_k}{d p_j} + \\Delta t \\left( \\frac{\\partial f}{\\partial x}\\bigg|_{x_k} \\frac{d x_k}{d p_j} + \\frac{\\partial f}{\\partial p_j}\\bigg|_{x_k} \\right) $$\n$$ s^{(j)}_{k+1} = \\left( I + \\Delta t \\frac{\\partial f}{\\partial x}\\bigg|_{x_k} \\right) s^{(j)}_k + \\Delta t \\frac{\\partial f}{\\partial p_j}\\bigg|_{x_k} $$\nwhere $I$ is the identity matrix. The initial sensitivity is $s^{(j)}_0 = \\frac{d x_0}{d p_j} = 0$ as $x_0$ is constant. This equation is solved forward in time for $k=0, \\ldots, K-1$ alongside the primal solution.\n\nThe total derivative of the objective function $J$ with respect to $p_j$ is given by the chain rule:\n$$ \\frac{d J}{d p_j} = \\sum_{k=0}^{K} \\frac{\\partial J}{\\partial x_k} \\frac{d x_k}{d p_j} = \\sum_{k=0}^{K} \\frac{\\partial J}{\\partial x_k} s^{(j)}_k $$\nwhere $\\frac{\\partial J}{\\partial x_k} = w \\left(V(t_{k}) - V_{\\mathrm{ref}}(t_{k})\\right) \\frac{\\partial V_k}{\\partial x_k} \\Delta t$. The term $\\frac{\\partial V_k}{\\partial x_k}$ is a row vector derived from the voltage equation: $\\frac{\\partial V_k}{\\partial x_k} = [0, \\alpha, -\\delta/N, \\ldots, -\\delta/N]$. The gradient is computed by accumulating the dot product of $\\frac{\\partial J}{\\partial x_k}$ and $s^{(j)}_k$ at each step.\n\n**3. Discrete Adjoint Method (Backward Sensitivity Analysis)**\n\nThe adjoint method offers a more computationally efficient way to compute gradients when the number of parameters is large. We define an adjoint vector $\\lambda_k \\in \\mathbb{R}^{1 \\times (2+N)}$ for each time step. The adjoint equations are derived to propagate the sensitivity of the final objective function backwards in time. For the discrete explicit Euler scheme, the adjoint recurrence is:\n$$ \\lambda_k = \\lambda_{k+1} \\left( I + \\Delta t \\frac{\\partial f}{\\partial x}\\bigg|_{x_k} \\right) + \\frac{\\partial J}{\\partial x_k} $$\nThis equation is solved backwards from $k=K-1$ down to $0$. The terminal condition is $\\lambda_K = \\frac{\\partial J}{\\partial x_K}$. Since the summation in $J$ includes $k=K$, $\\frac{\\partial J}{\\partial x_K}$ is non-zero. For $k > K$, we can consider $\\lambda_{k>K}=0$. The `dJ/dx` partials are the same as in the tangent method.\n\nOnce the adjoints are known, the gradient is computed by summing the contributions from each time step:\n$$ \\frac{d J}{d p_j} = \\sum_{k=0}^{K-1} \\lambda_{k+1} \\left( \\Delta t \\frac{\\partial f}{\\partial p_j}\\bigg|_{x_k} \\right) $$\nThis summation is performed during the backward sweep. The key advantage is that one backward pass yields the gradients with respect to all parameters simultaneously.\n\n**Implementation Details**\n\nThe Jacobians $\\frac{\\partial f}{\\partial x}$, $\\frac{\\partial f}{\\partial R_p}$, and $\\frac{\\partial f}{\\partial \\varepsilon_p}$ are derived analytically from the state equations. The Laplacian $L$ is constructed for $N=5$ nodes with zero-flux boundary conditions. The Python implementation encapsulates these principles to compute the gradients for each test case and report the specified difference, which is expected to be near zero, confirming the correctness of both implementations.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    # Define constants from the problem statement\n    N = 5\n    DS = 0.1\n    DE = 0.2\n    B = 1.5\n    GAMMA = 0.05\n    U0 = 0.0\n    ALPHA = 0.8\n    DELTA = 0.3\n    T = 1.0\n    DT = 0.001\n    I0 = 1.0\n    T1 = 0.2\n    T2 = 0.7\n    W = 1.0\n    RP_REF = 1.0\n    EPSP_REF = 0.5\n\n    # Define test cases\n    test_cases = [\n        (1.0, 0.5), # Case 1: Baseline\n        (0.3, 0.5), # Case 2: Small particle radius\n        (1.0, 0.9), # Case 3: High porosity\n        (1.0, 0.1), # Case 4: Low porosity\n    ]\n\n    # --- Setup ---\n    K = int(T / DT)\n    time_grid = np.linspace(0, T, K + 1)\n    state_dim = 2 + N\n    d = 1.0 / N\n\n    # Construct the 1D Laplacian matrix with zero-flux Neumann boundary conditions\n    L = np.zeros((N, N))\n    fill_val = 1 / (d * d)\n    for i in range(N):\n        if i > 0:\n            L[i, i - 1] = fill_val\n        L[i, i] = -2 * fill_val\n        if i  N - 1:\n            L[i, i + 1] = fill_val\n    L[0, 0] = -1 * fill_val\n    L[N - 1, N - 1] = -1 * fill_val\n    \n    # Pre-compute the current pulse profile\n    I_hist = np.array([I0 if T1 = t  T2 else 0.0 for t in time_grid])\n\n    # Gradient of voltage V w.r.t. state x (a row vector)\n    dVdx_row = np.zeros(state_dim)\n    dVdx_row[1] = ALPHA\n    dVdx_row[2:] = -DELTA / N\n\n    def get_state_derivatives(x, p, I_val):\n        \"\"\"Computes dx/dt = f(x, p, t) and related quantities.\"\"\"\n        R_p, eps_p = p\n        \n        j = I_val * R_p / (3 * eps_p) if eps_p != 0 else 0.0\n        \n        f = np.zeros(state_dim)\n        f[0] = -j\n        f[1] = (DS / R_p**2) * (x[0] - x[1]) - j if R_p != 0 else -j\n        f[2:] = DE * (eps_p**B) * (L @ x[2:]) - GAMMA * j\n        return f\n\n    def run_forward_model(p):\n        \"\"\"Solves the primal problem x_{k+1} = x_k + dt*f(x_k, p, t_k).\"\"\"\n        R_p, eps_p = p\n        x_hist = np.zeros((K + 1, state_dim))\n        V_hist = np.zeros(K + 1)\n\n        # Initial conditions\n        x_hist[0, 2:] = 1.0\n        V_hist[0] = U0 + ALPHA * x_hist[0, 1] - DELTA * np.mean(x_hist[0, 2:])\n        \n        for k in range(K):\n            f_k = get_state_derivatives(x_hist[k], p, I_hist[k])\n            x_hist[k+1] = x_hist[k] + DT * f_k\n            V_hist[k+1] = U0 + ALPHA * x_hist[k+1, 1] - DELTA * np.mean(x_hist[k+1, 2:])\n        \n        return x_hist, V_hist\n\n    # --- Generate Reference Voltage Trace ---\n    _, V_ref_hist = run_forward_model((RP_REF, EPSP_REF))\n    \n    all_results = []\n    \n    for R_p, eps_p in test_cases:\n        p_case = (R_p, eps_p)\n        \n        # --- 1. Primal Solve ---\n        x_hist, V_hist = run_forward_model(p_case)\n        \n        # Helper function to get Jacobians\n        def get_jacobians(x, p, I_val):\n            R_p, eps_p = p\n            \n            # df/dx\n            dfdx = np.zeros((state_dim, state_dim))\n            if R_p != 0:\n                dfdx[1, 0] = DS / R_p**2\n                dfdx[1, 1] = -DS / R_p**2\n            dfdx[2:, 2:] = DE * (eps_p**B) * L\n\n            # df/dRp\n            dfdRp = np.zeros(state_dim)\n            dj_dRp = I_val / (3 * eps_p) if eps_p != 0 else 0.0\n            if R_p != 0:\n                dfdRp[0] = -dj_dRp\n                dfdRp[1] = -2 * DS * (x[0] - x[1]) / R_p**3 - dj_dRp\n                dfdRp[2:] = -GAMMA * dj_dRp\n            \n            # df/depsp\n            dfdepsp = np.zeros(state_dim)\n            if eps_p != 0:\n                dj_depsp = -I_val * R_p / (3 * eps_p**2)\n                dfdepsp[0] = -dj_depsp\n                dfdepsp[1] = -dj_depsp\n                dfdepsp[2:] = DE * B * (eps_p**(B - 1)) * (L @ x[2:]) - GAMMA * dj_depsp\n\n            return dfdx, dfdRp, dfdepsp\n\n        # --- 2. Tangent Linear Model ---\n        s_Rp = np.zeros(state_dim)\n        s_epsp = np.zeros(state_dim)\n        \n        grad_Rp_tan = 0.0\n        grad_epsp_tan = 0.0\n        \n        Id = np.identity(state_dim)\n        \n        for k in range(K + 1):\n            dJdxk_row = W * (V_hist[k] - V_ref_hist[k]) * DT * dVdx_row\n            grad_Rp_tan += np.dot(dJdxk_row, s_Rp)\n            grad_epsp_tan += np.dot(dJdxk_row, s_epsp)\n            \n            if k  K:\n                dfdx, dfdRp, dfdepsp = get_jacobians(x_hist[k], p_case, I_hist[k])\n                Fk_dx = Id + DT * dfdx\n                \n                s_Rp = Fk_dx @ s_Rp + DT * dfdRp\n                s_epsp = Fk_dx @ s_epsp + DT * dfdepsp\n\n        # --- 3. Discrete Adjoint Method ---\n        grad_Rp_adj = 0.0\n        grad_epsp_adj = 0.0\n\n        dJdxK_row = W * (V_hist[K] - V_ref_hist[K]) * DT * dVdx_row\n        lambda_next = dJdxK_row\n        \n        for k in range(K - 1, -1, -1):\n            dfdx, dfdRp, dfdepsp = get_jacobians(x_hist[k], p_case, I_hist[k])\n            \n            Fk_dRp = DT * dfdRp\n            Fk_depsp = DT * dfdepsp\n\n            # Accumulate gradient contribution from step k\n            grad_Rp_adj += np.dot(lambda_next, Fk_dRp)\n            grad_epsp_adj += np.dot(lambda_next, Fk_depsp)\n            \n            # Update adjoint for next (backward) step\n            Fk_dx = Id + DT * dfdx\n            dJdxk_row = W * (V_hist[k] - V_ref_hist[k]) * DT * dVdx_row\n            lambda_curr = lambda_next @ Fk_dx + dJdxk_row\n            lambda_next = lambda_curr\n\n        # --- 4. Compare and Store Results ---\n        # As per the LaTeX formula: |grad_tan| - |grad_adj|\n        diff_Rp = abs(grad_Rp_tan) - abs(grad_Rp_adj)\n        diff_epsp = abs(grad_epsp_tan) - abs(grad_epsp_adj)\n        all_results.extend([diff_Rp, diff_epsp])\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```"
        }
    ]
}