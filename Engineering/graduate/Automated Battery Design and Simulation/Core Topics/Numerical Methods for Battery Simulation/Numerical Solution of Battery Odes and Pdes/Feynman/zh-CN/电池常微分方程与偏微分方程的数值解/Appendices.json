{
    "hands_on_practices": [
        {
            "introduction": "数值模拟的准确性在很大程度上取决于空间网格对物理现象的解析能力。在电池模型中，陡峭的浓度或电势梯度频繁出现，尤其是在电极/电解液界面和隔膜附近。本练习  提供了一种量化网格分辨率与求解精度之间关系的方法，帮助您评估为了准确捕捉关键物理特征（如隔膜处的电解质耗尽）所需的网格密度。这是验证任何仿真模型的有效性和可靠性的基本步骤。",
            "id": "3933739",
            "problem": "考虑一个在锂离子电池域中建立的一维电解质输运问题，该问题旨在捕捉隔膜附近的陡峭梯度。设空间域为 $x \\in [0,L]$（$L$ 的单位为米），时间域为 $t \\in [0,t_{\\mathrm{peak}}]$（$t_{\\mathrm{peak}}$ 的单位为秒）。电解质浓度场 $c_e(x,t)$（单位为 $\\mathrm{mol/m^3}$）在质量守恒和菲克扩散 (Fickian diffusion) 以及一个局域化的体积消耗项下演化，由以下偏微分方程 (PDE) 控制：\n$$\n\\frac{\\partial c_e}{\\partial t} = D_e \\frac{\\partial^2 c_e}{\\partial x^2} + S(x) f(t),\n$$\n其中 $D_e$ 是电解质扩散系数（单位为 $\\mathrm{m^2/s}$），$S(x)$ 是一个空间局域化的源项（单位为 $\\mathrm{mol/(m^3 \\cdot s)}$），$f(t)$ 是一个代表瞬态峰值电流事件的无量纲标量时间调制。假设无通量边界条件：\n$$\n\\frac{\\partial c_e}{\\partial x}(0,t) = 0, \\quad \\frac{\\partial c_e}{\\partial x}(L,t) = 0,\n$$\n以及均匀初始条件：\n$$\nc_e(x,0) = c_0.\n$$\n为模拟隔膜附近陡峭的电解质梯度，将隔膜位置设置在 $x_{\\mathrm{sep}} = L/2$，并将空间源分布定义为一个以 $x_{\\mathrm{sep}}$ 为中心的窄高斯函数：\n$$\nS(x) = -A_s \\exp\\left( -\\frac{(x - x_{\\mathrm{sep}})^2}{2 \\sigma_x^2} \\right),\n$$\n其振幅 $A_s$ 的单位为 $\\mathrm{mol/(m^3 \\cdot s)}$，空间宽度 $\\sigma_x$ 的单位为米。峰值电流由一个在 $t_{\\mathrm{peak}}$ 达到峰值的时间高斯调制表示：\n$$\nf(t) = \\exp\\left( -\\frac{(t - t_{\\mathrm{peak}})^2}{2 \\sigma_t^2} \\right),\n$$\n其时间宽度 $\\sigma_t$ 的单位为秒。这种设置在峰值电流时间点附近，于隔膜周围产生了物理上真实的、$c_e$ 的局域性耗尽。\n\n从控制 PDE、适当的边界和初始条件以及基本定义（质量守恒、菲克扩散通量 $J = -D_e \\frac{\\partial c_e}{\\partial x}$）出发，在间距为 $\\Delta x$ 的均匀空间网格上对问题进行离散化，并使用时间步长 $\\Delta t$ 从 $t=0$ 积分到 $t=t_{\\mathrm{peak}}$。使用一种时间上无条件稳定、二阶精确的方法来推进求解，并在离散二阶导数算子中一致地施加无通量条件。对于每个空间分辨率 $\\Delta x$，通过在数值网格上进行线性插值，计算隔膜位置处的电解质浓度 $c_e(x_{\\mathrm{sep}}, t_{\\mathrm{peak}})$。\n\n将参考解 $c_e^{\\mathrm{ref}}(x_{\\mathrm{sep}}, t_{\\mathrm{peak}})$ 定义为使用非常精细的网格间距 $\\Delta x_{\\mathrm{ref}}$ 和相同的时间离散化计算出的数值解。对于每个测试用例的网格间距 $\\Delta x$，计算峰值电流下的绝对误差：\n$$\nE(\\Delta x) = \\left| c_e(x_{\\mathrm{sep}}, t_{\\mathrm{peak}}; \\Delta x) - c_e^{\\mathrm{ref}}(x_{\\mathrm{sep}}, t_{\\mathrm{peak}}; \\Delta x_{\\mathrm{ref}}) \\right|.\n$$\n您必须以 $\\mathrm{mol/m^3}$ 为单位表示最终误差 $E(\\Delta x)$，并四舍五入到六位小数。\n\n使用以下科学上合理的参数值：$L = 1.0 \\times 10^{-4} \\ \\mathrm{m}$，$x_{\\mathrm{sep}} = L/2$，$D_e = 1.0 \\times 10^{-10} \\ \\mathrm{m^2/s}$，$c_0 = 1000 \\ \\mathrm{mol/m^3}$，$A_s = 50 \\ \\mathrm{mol/(m^3 \\cdot s)}$，$\\sigma_x = 5.0 \\times 10^{-6} \\ \\mathrm{m}$，$t_{\\mathrm{peak}} = 10.0 \\ \\mathrm{s}$，$\\sigma_t = 2.0 \\ \\mathrm{s}$，以及均匀时间步长 $\\Delta t = 0.05 \\ \\mathrm{s}$。参考网格间距为 $\\Delta x_{\\mathrm{ref}} = 6.25 \\times 10^{-7} \\ \\mathrm{m}$。\n\n测试组：\n- Case 1 (理想情况): $\\Delta x = 2.0 \\times 10^{-5} \\ \\mathrm{m}$。\n- Case 2 (中等分辨率): $\\Delta x = 1.0 \\times 10^{-5} \\ \\mathrm{m}$。\n- Case 3 (接近梯度尺度): $\\Delta x = 5.0 \\times 10^{-6} \\ \\mathrm{m}$。\n- Case 4 (精细): $\\Delta x = 2.5 \\times 10^{-6} \\ \\mathrm{m}$。\n- Case 5 (非常精细): $\\Delta x = 1.25 \\times 10^{-6} \\ \\mathrm{m}$。\n\n角度单位不适用。百分比不适用。\n\n您的程序应生成单行输出，其中包含五个测试用例的误差，格式为方括号括起来的逗号分隔列表，每个误差都四舍五入到六位小数，并以 $\\mathrm{mol/m^3}$ 为单位，例如，“[e1,e2,e3,e4,e5]”。",
            "solution": "用户提供了一个适定的问题陈述，该问题是关于一维瞬态扩散反应过程，其科学基础是电池中电解质的输运物理学。问题是完整的，所有必要的参数、初始条件和边界条件都已指定。任务是通过对几个空间网格分辨率求解控制偏微分方程 (PDE)，并将结果与高分辨率参考解进行比较，来进行数值收敛性研究。问题有效。\n\n电解质浓度 $c_e(x,t)$ 的控制 PDE 为：\n$$\n\\frac{\\partial c_e}{\\partial t} = D_e \\frac{\\partial^2 c_e}{\\partial x^2} + S(x) f(t)\n$$\n服从初始条件 $c_e(x,0) = c_0$ 和无通量边界条件 $\\frac{\\partial c_e}{\\partial x}(0,t) = 0$ 及 $\\frac{\\partial c_e}{\\partial x}(L,t) = 0$。\n\n求解方法采用线法 (Method of Lines, MOL)，即首先对空间域进行离散化，将 PDE 转化为一个关于时间的耦合常微分方程 (ODEs) 组。然后使用合适的时间步进数值格式对该系统进行积分。\n\n**1. 空间离散化**\n将空间域 $x \\in [0, L]$ 离散化为一个具有 $N_x$ 个区间的均匀网格，间距为 $\\Delta x = L/N_x$。网格点为 $x_i = i \\Delta x$，其中 $i = 0, 1, \\dots, N_x$。在网格点 $x_i$ 和时间 $t$ 的浓度表示为 $c_i(t) \\approx c_e(x_i, t)$。\n\n使用二阶精确的中心差分格式来近似二阶空间导数，即拉普拉斯项：\n$$\n\\frac{\\partial^2 c_e}{\\partial x^2} \\bigg|_{x_i} \\approx \\frac{c_{i-1}(t) - 2c_i(t) + c_{i+1}(t)}{\\Delta x^2}\n$$\n这适用于内部网格点 $i=1, 2, \\dots, N_x-1$。\n\n**2. 边界条件施加**\n使用“虚拟点”法来施加无通量（齐次 Neumann）边界条件，这种方法可以保持空间格式的二阶精度。\n在左边界（$x_0=0$），条件 $\\frac{\\partial c_e}{\\partial x}(0,t) = 0$ 被离散化为 $\\frac{c_1 - c_{-1}}{2\\Delta x} = 0$，这意味着虚拟点的浓度为 $c_{-1} = c_1$。将其代入 $i=0$ 的中心差分格式中，得到：\n$$\n\\frac{\\partial^2 c_e}{\\partial x^2} \\bigg|_{x_0} \\approx \\frac{c_{-1} - 2c_0 + c_1}{\\Delta x^2} = \\frac{2c_1 - 2c_0}{\\Delta x^2}\n$$\n类似地，在右边界（$x_{N_x}=L$），该条件意味着 $c_{N_x+1} = c_{N_x-1}$，从而得到近似：\n$$\n\\frac{\\partial^2 c_e}{\\partial x^2} \\bigg|_{x_{N_x}} \\approx \\frac{c_{N_x-1} - 2c_{N_x} + c_{N_x+1}}{\\Delta x^2} = \\frac{2c_{N_x-1} - 2c_{N_x}}{\\Delta x^2}\n$$\n\n令 $\\vec{c}(t) = [c_0(t), c_1(t), \\dots, c_{N_x}(t)]^T$ 为网格点上的浓度向量，离散化的 PDE 系统可以写成矩阵形式：\n$$\n\\frac{d\\vec{c}}{dt} = \\frac{D_e}{\\Delta x^2} \\mathbf{L} \\vec{c} + \\vec{S} f(t)\n$$\n其中 $\\mathbf{L}$ 是一个 $(N_x+1) \\times (N_x+1)$ 的三对角矩阵，代表带有 Neumann 边界条件的离散拉普拉斯算子，而 $\\vec{S}$ 是每个网格点上空间源项值的向量。\n\n**3. 时间积分**\n问题要求使用一种时间上无条件稳定、二阶精确的方法。Crank-Nicolson 方法是理想的选择。将此方法应用于半离散系统，得到：\n$$\n\\frac{\\vec{c}^{n+1} - \\vec{c}^n}{\\Delta t} = \\frac{1}{2} \\left[ \\left(\\mathbf{A}\\vec{c}^{n+1} + \\vec{g}(t^{n+1})\\right) + \\left(\\mathbf{A}\\vec{c}^n + \\vec{g}(t^n)\\right) \\right]\n$$\n其中 $\\vec{c}^n$ 是在时间 $t^n = n\\Delta t$ 的解，$\\mathbf{A} = \\frac{D_e}{\\Delta x^2} \\mathbf{L}$，以及 $\\vec{g}(t) = \\vec{S}f(t)$。\n\n为了求解下一个时间步的未知浓度向量 $\\vec{c}^{n+1}$，我们重新整理方程，得到一个线性方程组：\n$$\n\\left(\\mathbf{I} - \\frac{\\Delta t}{2}\\mathbf{A}\\right) \\vec{c}^{n+1} = \\left(\\mathbf{I} + \\frac{\\Delta t}{2}\\mathbf{A}\\right) \\vec{c}^n + \\frac{\\Delta t}{2} \\left(\\vec{g}(t^{n+1}) + \\vec{g}(t^n)\\right)\n$$\n其中 $\\mathbf{I}$ 是单位矩阵。左侧的矩阵 $\\left(\\mathbf{I} - \\frac{\\Delta t}{2}\\mathbf{A}\\right)$ 是三对角的。这类系统可以在每个时间步使用 Thomas 算法（三对角矩阵算法）非常高效地求解，该算法在像 SciPy 这样的数值库中很容易获得。\n\n**4. 实现与误差计算**\n数值解的实现首先是建立空间网格和初始浓度分布。然后在一个从 $t=0$ 到 $t=t_{\\mathrm{peak}}$ 的循环中进行时间积分。在每一步中，计算右侧向量，并求解三对角线性系统以找到下一个时间步的浓度。\n\n在最后一个时间步之后，解向量 $\\vec{c}$ 代表浓度分布 $c_e(x, t_{\\mathrm{peak}})$。通过在最终的网格值上进行线性插值，找到特定位置 $x_{\\mathrm{sep}} = L/2$ 处的浓度。\n\n首先使用非常精细的参考网格间距 $\\Delta x_{\\mathrm{ref}}$ 计算参考解 $c_e^{\\mathrm{ref}}(x_{\\mathrm{sep}}, t_{\\mathrm{peak}})$。然后，对于每个测试用例 $\\Delta x$，计算相应的数值解 $c_e(x_{\\mathrm{sep}}, t_{\\mathrm{peak}}; \\Delta x)$。绝对误差按规定计算：\n$$\nE(\\Delta x) = \\left| c_e(x_{\\mathrm{sep}}, t_{\\mathrm{peak}}; \\Delta x) - c_e^{\\mathrm{ref}}(x_{\\mathrm{sep}}, t_{\\mathrm{peak}}; \\Delta x_{\\mathrm{ref}}) \\right|\n$$\n然后将五个测试用例所得的误差按要求格式化。",
            "answer": "```python\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef solve():\n    \"\"\"\n    Solves a 1D transient diffusion PDE for a battery electrolyte concentration\n    and computes the numerical error for different spatial resolutions.\n    \"\"\"\n    #\n    # Global Parameters\n    #\n    L = 1.0e-4           # m, domain length\n    D_e = 1.0e-10        # m^2/s, electrolyte diffusivity\n    c_0 = 1000.0         # mol/m^3, initial concentration\n    A_s = 50.0           # mol/(m^3*s), source amplitude\n    sigma_x = 5.0e-6     # m, spatial width of source\n    t_peak = 10.0        # s, peak time\n    sigma_t = 2.0        # s, temporal width of source\n    delta_t = 0.05       # s, time step\n    x_sep = L / 2.0      # m, separator location\n    \n    #\n    # Test Suite Parameters\n    #\n    delta_x_ref = 6.25e-7  # m, reference mesh spacing\n    test_delta_x = [2.0e-5, 1.0e-5, 5.0e-6, 2.5e-6, 1.25e-6]\n\n    #\n    # Helper Functions\n    #\n    def S_func(x):\n        \"\"\"Spatial source term profile.\"\"\"\n        return -A_s * np.exp(-(x - x_sep)**2 / (2 * sigma_x**2))\n\n    def f_func(t):\n        \"\"\"Temporal modulation of the source term.\"\"\"\n        return np.exp(-(t - t_peak)**2 / (2 * sigma_t**2))\n\n    def solve_pde(delta_x):\n        \"\"\"\n        Solves the PDE for a given spatial step dx using Crank-Nicolson method.\n        Returns the interpolated concentration at x_sep and t_peak.\n        \"\"\"\n        # 1. Grid Setup\n        Nx = int(round(L / delta_x))\n        x_grid = np.linspace(0, L, Nx + 1)\n        \n        t_steps = int(round(t_peak / delta_t))\n        \n        # 2. Initial Condition\n        c = np.full(Nx + 1, c_0)\n        \n        # 3. Pre-compute constant terms\n        S_vec = S_func(x_grid)\n        alpha = D_e * delta_t / (2 * delta_x**2)\n        \n        # 4. Construct Crank-Nicolson LHS matrix (for solve_banded)\n        # This matrix is (I - alpha * L), where L is the discrete Laplacian.\n        M_lhs_banded = np.zeros((3, Nx + 1))\n        # Main diagonal\n        M_lhs_banded[1, :] = 1 + 2 * alpha\n        # Upper diagonal\n        M_lhs_banded[0, 1:] = -alpha\n        # Lower diagonal\n        M_lhs_banded[2, :-1] = -alpha\n        # Apply Neumann BCs\n        M_lhs_banded[0, 1] = -2 * alpha\n        M_lhs_banded[2, Nx - 1] = -2 * alpha\n        \n        # 5. Time Integration Loop\n        for n in range(t_steps):\n            t_n = n * delta_t\n            t_n_plus_1 = (n + 1) * delta_t\n            \n            # Construct RHS vector: b = (I + alpha*L)*c_n + source_term\n            # 5a. Diffusion part: (I + alpha*L) * c_n\n            rhs_diff = np.zeros(Nx + 1)\n            # Interior points\n            rhs_diff[1:-1] = alpha * c[:-2] + (1 - 2*alpha) * c[1:-1] + alpha * c[2:]\n            # Boundary points (Neumann)\n            rhs_diff[0]  = (1 - 2*alpha) * c[0] + 2*alpha * c[1]\n            rhs_diff[-1] = 2*alpha * c[-2] + (1 - 2*alpha) * c[-1]\n            \n            # 5b. Source part\n            source_contribution = (delta_t / 2) * S_vec * \\\n                                  (f_func(t_n) + f_func(t_n_plus_1))\n            \n            # 5c. Total RHS\n            b = rhs_diff + source_contribution\n            \n            # 5d. Solve the tridiagonal system for the next time step\n            c = solve_banded((1, 1), M_lhs_banded, b)\n            \n        # 6. Interpolate final result at the separator location\n        c_at_sep = np.interp(x_sep, x_grid, c)\n        \n        return c_at_sep\n\n    #\n    # Main Execution Logic\n    #\n    \n    # Compute the reference solution\n    c_ref = solve_pde(delta_x_ref)\n    \n    results = []\n    # Loop through test cases, compute solution and error\n    for dx in test_delta_x:\n        c_test = solve_pde(dx)\n        error = abs(c_test - c_ref)\n        results.append(error)\n\n    # Format output as specified\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在确保了空间离散化的充分性之后，下一个关键选择是时间积分方案。由于电池模型通常包含时间尺度差异巨大的多个过程，表现出“刚性”（stiffness），这使得显式时间积分方法因其苛刻的稳定性条件而变得不切实际。本练习  将指导您实现并比较几种在电池建模中广泛应用的隐式方法，包括隐式欧拉法、Crank-Nicolson法和二阶向后差分公式（BDF2）。通过评估它们在精度、稳定性和物理保真度（如浓度正定性）方面的表现，您将掌握为特定问题选择合适求解器的核心技能。",
            "id": "3933711",
            "problem": "考虑一个由质量守恒和菲克扩散控制的一维电解质区域。设 $c(x,t)$ 表示电解质中的盐浓度，单位为 $\\mathrm{mol/m^3}$，其定义在空间区间 $x \\in [0,L]$ 和时间区间 $t \\in [0,T]$ 上。在充电脉冲作用下，$c(x,t)$ 的演化由以下抛物线型偏微分方程 (PDE) 建模：\n$$\n\\frac{\\partial c}{\\partial t}(x,t) \\;=\\; D \\,\\frac{\\partial^2 c}{\\partial x^2}(x,t) \\;-\\; s(t),\n$$\n其中 $D$ 是扩散系数，单位为 $\\mathrm{m^2/s}$，$s(t)$ 是一个均匀的体积汇项，单位为 $\\mathrm{mol/(m^3\\cdot s)}$，表示充电脉冲期间盐的净消耗。边界条件为零通量 (诺伊曼) 条件，\n$$\n\\frac{\\partial c}{\\partial x}(0,t) \\;=\\; 0, \\qquad \\frac{\\partial c}{\\partial x}(L,t) \\;=\\; 0,\n$$\n初始条件是均匀的，\n$$\nc(x,0) \\;=\\; c_0.\n$$\n充电脉冲由一个分段常数汇项表示，\n$$\ns(t) \\;=\\; \n\\begin{cases}\ns_0,   t_{\\mathrm{on}} \\le t  t_{\\mathrm{off}},\\\\\n0,   \\text{其它情况}.\n\\end{cases}\n$$\n从上述物理定律和定义出发，请使用强制零通量边界条件的二阶中心差分来离散化空间域，并推导以下三种隐式方法的全离散时间步进更新式：\n- 隐式欧拉法，\n- Crank–Nicolson 方法，\n- 二阶向后微分公式 (BDF2，定义为多项式系数能产生二阶精度的向后微分公式 (BDF))。\n\n使用这些更新式来实现一个数值程序，该程序针对每种方法和每个测试用例，推进离散浓度场，检测电解质耗尽，并计算准确性和稳定性指标。\n\n定义和指标：\n- 电解质耗尽阈值 $c_{\\min,*}$ 是一个指定的浓度，单位为 $\\mathrm{mol/m^3}$。使用离散时间网格，将耗尽时间 $\\tau_{\\mathrm{dep}}$ 定义为离散浓度的空间最小值首次低于 $c_{\\min,*}$ 的最早时间。如果在 $[0,T]$ 内未发生耗尽，则设 $\\tau_{\\mathrm{dep}}=T$。\n- 方法 $M$ 的最终时刻相对 $L^2$ 误差为\n$$\n\\mathcal{E}_{L^2}(M) \\;=\\; \\frac{\\left\\|c_M(\\cdot,T) \\;-\\; c_{\\mathrm{ref}}(\\cdot,T)\\right\\|_2}{\\left\\|c_{\\mathrm{ref}}(\\cdot,T)\\right\\|_2},\n$$\n其中 $c_{\\mathrm{ref}}(\\cdot,T)$ 是一个使用时间步长 $\\Delta t_{\\mathrm{ref}} = 10^{-3}\\,\\mathrm{s}$ 的隐式欧拉法计算出的高保真度参考解。\n- 方法 $M$ 的耗尽时间绝对误差为\n$$\n\\left|\\tau_{\\mathrm{dep}}(M) \\;-\\; \\tau_{\\mathrm{dep}}(\\mathrm{ref})\\right| \\quad \\text{单位为} \\quad \\mathrm{s}.\n$$\n- 正性违背标志是一个整数，如果所有节点和所有时间步的 $c(x,t)\\ge 0$，则为 $0$；如果在任何时间步有任何节点变为负值，则为 $1$。\n- 脉冲期间单调性违背计数是在区间 $[t_{\\mathrm{on}}, t_{\\mathrm{off}})$ 内，离散浓度的空间最小值相比于前一个时间步有所增加的离散时间步数。\n\n科学和数值要求：\n- 以指定单位表示所有量：$c$ 的单位为 $\\mathrm{mol/m^3}$，$D$ 的单位为 $\\mathrm{m^2/s}$，$L$ 的单位为 $\\mathrm{m}$，$t$ 的单位为 $\\mathrm{s}$，$s(t)$ 的单位为 $\\mathrm{mol/(m^3\\cdot s)}$。\n- 从 PDE 和边界条件推导离散算子和更新式，不要引用简化的公式。空间算子必须与零通量边界条件下的二阶导数一致。\n- 时间步进的实现必须对扩散算子是全隐式的。根据每种方法的时间离散化方式，一致地处理源项。\n\n测试套件：\n为以下三个测试用例实现程序，每个用例由元组 $(D, L, N, T, \\Delta t, s_0, t_{\\mathrm{on}}, t_{\\mathrm{off}}, c_0, c_{\\min,*})$ 定义：\n- 用例 A：$(2.0\\times 10^{-10},\\, 1.0\\times 10^{-4},\\, 50,\\, 2.0,\\, 0.02,\\, 50.0,\\, 0.5,\\, 1.5,\\, 1000.0,\\, 800.0)$\n- 用例 B：$(1.0\\times 10^{-10},\\, 1.0\\times 10^{-4},\\, 60,\\, 2.0,\\, 0.2,\\, 300.0,\\, 0.4,\\, 1.8,\\, 1000.0,\\, 700.0)$\n- 用例 C：$(5.0\\times 10^{-11},\\, 1.5\\times 10^{-4},\\, 40,\\, 1.5,\\, 0.05,\\, 600.0,\\, 0.2,\\, 0.8,\\, 1200.0,\\, 900.0)$\n\n对于每个测试用例，使用隐式欧拉法和时间步长 $\\Delta t_{\\mathrm{ref}} = 10^{-3}$ 计算高保真度参考解，然后使用该用例指定的 $\\Delta t$ 运行三种方法。对于每种方法和每个用例，计算：\n- 耗尽时间绝对误差，单位为 $\\mathrm{s}$，\n- 最终时刻相对 $L^2$ 误差 (无量纲)，\n- 正性违背标志 (整数 $0$ 或 $1$)，\n- 脉冲期间单调性违背计数 (整数)。\n\n最终输出规范：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。该列表必须按测试用例排序 ($A$，然后 $B$，然后 $C$)。在每个测试用例中，按方法排序：隐式欧拉法、Crank–Nicolson、BDF2。在每种方法中，按上面列出的顺序列出指标。具体来说，输出应为：\n$$\n[\\text{A-IE-dep\\_err},\\text{A-IE-relL2},\\text{A-IE-neg},\\text{A-IE-mono},\\text{A-CN-dep\\_err},\\text{A-CN-relL2},\\text{A-CN-neg},\\text{A-CN-mono},\\text{A-BDF2-dep\\_err},\\text{A-BDF2-relL2},\\text{A-BDF2-neg},\\text{A-BDF2-mono},\\text{B-IE-dep\\_err},\\ldots,\\text{C-BDF2-mono}]\n$$\n其中耗尽时间误差的单位为 $\\mathrm{s}$，相对 $L^2$ 误差是无量纲浮点数，标志和计数是整数。不应打印任何其他文本。",
            "solution": "The user wants to solve a one-dimensional reaction-diffusion PDE using three different implicit time-stepping schemes and evaluate their performance based on several metrics.\n\n### Step 1: Problem Validation\n\n**1.1. Extract Givens**\n\n- **PDE**: $\\frac{\\partial c}{\\partial t}(x,t) = D \\,\\frac{\\partial^2 c}{\\partial x^2}(x,t) - s(t)$\n- **Domain**: $x \\in [0,L]$, $t \\in [0,T]$\n- **Variables**: $c(x,t)$ is salt concentration ($\\mathrm{mol/m^3}$), $D$ is diffusion coefficient ($\\mathrm{m^2/s}$), $s(t)$ is a sink term ($\\mathrm{mol/(m^3\\cdot s)}$).\n- **Boundary Conditions (BCs)**: Zero-flux (Neumann), $\\frac{\\partial c}{\\partial x}(0,t) = 0$ and $\\frac{\\partial c}{\\partial x}(L,t) = 0$.\n- **Initial Condition (IC)**: Uniform, $c(x,0) = c_0$.\n- **Sink Term**: Piecewise-constant, $s(t) = s_0$ for $t_{\\mathrm{on}} \\le t  t_{\\mathrm{off}}$, and $0$ otherwise.\n- **Discretization Method**: Second-order central differences for space. Implicit Euler, Crank–Nicolson, and BDF2 for time.\n- **Metrics**:\n    - **Depletion Time $\\tau_{\\mathrm{dep}}$**: Earliest time $t$ where $\\min_x c(x,t)  c_{\\min,*}$. If no depletion, $\\tau_{\\mathrm{dep}} = T$.\n    - **Depletion-Time Absolute Error**: $|\\tau_{\\mathrm{dep}}(M) - \\tau_{\\mathrm{dep}}(\\mathrm{ref})|$.\n    - **Final-Time Relative $L^2$ Error**: $\\mathcal{E}_{L^2}(M) = \\frac{\\left\\|c_M(\\cdot,T) - c_{\\mathrm{ref}}(\\cdot,T)\\right\\|_2}{\\left\\|c_{\\mathrm{ref}}(\\cdot,T)\\right\\|_2}$.\n    - **Positivity Violation Flag**: $1$ if $c(x,t)  0$ at any point, $0$ otherwise.\n    - **Monotonicity Violation Count**: Number of time steps in $[t_{\\mathrm{on}}, t_{\\mathrm{off}})$ where $\\min_x c(x, t_{k+1})  \\min_x c(x, t_k)$.\n- **Reference Solution**: Computed with Implicit Euler using $\\Delta t_{\\mathrm{ref}} = 10^{-3}\\,\\mathrm{s}$.\n- **Test Cases**:\n    - A: $(D=2.0\\times 10^{-10}, L=1.0\\times 10^{-4}, N=50, T=2.0, \\Delta t=0.02, s_0=50.0, t_{\\mathrm{on}}=0.5, t_{\\mathrm{off}}=1.5, c_0=1000.0, c_{\\min,*}=800.0)$\n    - B: $(D=1.0\\times 10^{-10}, L=1.0\\times 10^{-4}, N=60, T=2.0, \\Delta t=0.2, s_0=300.0, t_{\\mathrm{on}}=0.4, t_{\\mathrm{off}}=1.8, c_0=1000.0, c_{\\min,*}=700.0)$\n    - C: $(D=5.0\\times 10^{-11}, L=1.5\\times 10^{-4}, N=40, T=1.5, \\Delta t=0.05, s_0=600.0, t_{\\mathrm{on}}=0.2, t_{\\mathrm{off}}=0.8, c_0=1200.0, c_{\\min,*}=900.0)$\n\n**1.2. Validate Using Extracted Givens**\n\n- **Scientifically Grounded**: The problem describes Fickian diffusion with a sink term, a fundamental model in transport phenomena and electrochemistry. It is scientifically valid.\n- **Well-Posed**: The problem is a well-posed parabolic PDE with defined initial and boundary conditions. The numerical tasks are standard.\n- **Objective**: The problem is stated using precise mathematical and physical terminology. The metrics are defined objectively.\n- **Completeness**: All necessary parameters, conditions, and definitions for solving the problem are provided.\n- **Consistency**: All given information is internally consistent.\n\n**1.3. Verdict and Action**\n\nThe problem is valid. We proceed to the solution.\n\n### Step 2: Derivation and Solution\n\n**2.1. Spatial Discretization**\n\nWe discretize the spatial domain $x \\in [0,L]$ into $N$ equally spaced nodes $x_i = i\\Delta x$ for $i=0, 1, \\dots, N-1$, where the grid spacing is $\\Delta x = L/(N-1)$. Let $c_i(t)$ be the numerical approximation of $c(x_i, t)$.\n\nThe second spatial derivative $\\frac{\\partial^2 c}{\\partial x^2}$ at an interior node $x_i$ ($1 \\le i \\le N-2$) is approximated using a second-order central difference:\n$$ \\frac{\\partial^2 c}{\\partial x^2}(x_i,t) \\approx \\frac{c_{i+1}(t) - 2c_i(t) + c_{i-1}(t)}{\\Delta x^2} $$\n\nTo enforce the zero-flux boundary conditions, we introduce ghost nodes $c_{-1}(t)$ and $c_{N}(t)$.\nAt the left boundary ($x=0$, $i=0$):\n$$ \\frac{\\partial c}{\\partial x}(0,t) \\approx \\frac{c_1(t) - c_{-1}(t)}{2\\Delta x} = 0 \\implies c_{-1}(t) = c_1(t) $$\nThe PDE at $i=0$ is then discretized as:\n$$ \\frac{d c_0}{d t} = D \\frac{c_1(t) - 2c_0(t) + c_{-1}(t)}{\\Delta x^2} - s(t) = D \\frac{2c_1(t) - 2c_0(t)}{\\Delta x^2} - s(t) $$\nAt the right boundary ($x=L$, $i=N-1$):\n$$ \\frac{\\partial c}{\\partial x}(L,t) \\approx \\frac{c_{N}(t) - c_{N-2}(t)}{2\\Delta x} = 0 \\implies c_{N}(t) = c_{N-2}(t) $$\nThe PDE at $i=N-1$ is discretized as:\n$$ \\frac{d c_{N-1}}{d t} = D \\frac{c_{N}(t) - 2c_{N-1}(t) + c_{N-2}(t)}{\\Delta x^2} - s(t) = D \\frac{2c_{N-2}(t) - 2c_{N-1}(t)}{\\Delta x^2} - s(t) $$\n\nThis method of lines (MOL) approach results in a system of $N$ ordinary differential equations (ODEs), which can be written in matrix form:\n$$ \\frac{d\\mathbf{c}}{dt} = \\mathbf{A}\\mathbf{c}(t) - s(t)\\mathbf{1} $$\nwhere $\\mathbf{c}(t) = [c_0(t), c_1(t), \\dots, c_{N-1}(t)]^T$ is the vector of concentrations, $\\mathbf{1}$ is a vector of ones, and $\\mathbf{A}$ is the $N \\times N$ spatial discretization matrix. Letting $\\alpha = D / \\Delta x^2$, the matrix $\\mathbf{A}$ is:\n$$\n\\mathbf{A} = \\alpha\n\\begin{pmatrix}\n-2  2  0  \\dots   0 \\\\\n1  -2  1  0  \\dots  0 \\\\\n0  1  -2  1  \\ddots  \\vdots \\\\\n\\vdots  \\ddots  \\ddots  \\ddots   0 \\\\\n0  \\dots  0  1  -2  1 \\\\\n0   \\dots  0  2  -2\n\\end{pmatrix}\n$$\n\n**2.2. Temporal Discretization**\n\nLet $\\mathbf{c}^k$ denote the numerical solution vector at time $t_k = k\\Delta t$, and let $\\mathbf{s}^k = s(t_k)\\mathbf{1}$. We derive the update rules for the three required implicit methods.\n\n**2.2.1. Implicit Euler (IE)**\nThis first-order method approximates the time derivative at $t_{k+1}$:\n$$ \\frac{\\mathbf{c}^{k+1} - \\mathbf{c}^k}{\\Delta t} = \\mathbf{A}\\mathbf{c}^{k+1} - \\mathbf{s}^{k+1} $$\nRearranging to solve for the unknown $\\mathbf{c}^{k+1}$, we get the linear system:\n$$ (\\mathbf{I} - \\Delta t \\mathbf{A})\\mathbf{c}^{k+1} = \\mathbf{c}^k - \\Delta t \\mathbf{s}^{k+1} $$\nwhere $\\mathbf{I}$ is the identity matrix.\n\n**2.2.2. Crank–Nicolson (CN)**\nThis second-order method is based on the trapezoidal rule, averaging the RHS at $t_k$ and $t_{k+1}$:\n$$ \\frac{\\mathbf{c}^{k+1} - \\mathbf{c}^k}{\\Delta t} = \\frac{1}{2} \\left( (\\mathbf{A}\\mathbf{c}^{k} - \\mathbf{s}^{k}) + (\\mathbf{A}\\mathbf{c}^{k+1} - \\mathbf{s}^{k+1}) \\right) $$\nGrouping terms with $\\mathbf{c}^{k+1}$ on the left-hand side yields the linear system:\n$$ \\left(\\mathbf{I} - \\frac{\\Delta t}{2}\\mathbf{A}\\right)\\mathbf{c}^{k+1} = \\left(\\mathbf{I} + \\frac{\\Delta t}{2}\\mathbf{A}\\right)\\mathbf{c}^k - \\frac{\\Delta t}{2}(\\mathbf{s}^k + \\mathbf{s}^{k+1}) $$\n\n**2.2.3. Backward Differentiation Formula of order 2 (BDF2)**\nBDF2 is a second-order, two-step method. The formula is:\n$$ \\frac{3\\mathbf{c}^{k+1} - 4\\mathbf{c}^k + \\mathbf{c}^{k-1}}{2\\Delta t} = \\mathbf{A}\\mathbf{c}^{k+1} - \\mathbf{s}^{k+1} $$\nThis is valid for $k \\ge 1$. For the very first step ($k=0$), a one-step method is required to generate $\\mathbf{c}^1$. We will use Implicit Euler for this startup step. For $k \\ge 1$, we rearrange the BDF2 formula to solve for $\\mathbf{c}^{k+1}$:\n$$ (3\\mathbf{I} - 2\\Delta t\\mathbf{A})\\mathbf{c}^{k+1} = 4\\mathbf{c}^k - \\mathbf{c}^{k-1} - 2\\Delta t \\mathbf{s}^{k+1} $$\nThis can be rewritten as:\n$$ \\left(\\mathbf{I} - \\frac{2}{3}\\Delta t\\mathbf{A}\\right)\\mathbf{c}^{k+1} = \\frac{4}{3}\\mathbf{c}^k - \\frac{1}{3}\\mathbf{c}^{k-1} - \\frac{2}{3}\\Delta t \\mathbf{s}^{k+1} $$\n\n**2.3. Algorithmic Implementation**\n\nFor each test case:\n1.  **Reference Solution**: A high-fidelity reference solution is computed using the Implicit Euler method with a very small time step, $\\Delta t_{\\mathrm{ref}} = 10^{-3}\\,\\mathrm{s}$, over the time interval $[0, T]$. During this simulation, the reference depletion time, $\\tau_{\\mathrm{dep}}(\\mathrm{ref})$, is recorded. The final concentration profile, $\\mathbf{c}_{\\mathrm{ref}}(T)$, is stored.\n2.  **Method Evaluation**: For each of the three methods (IE, CN, BDF2), a simulation is run using the time step $\\Delta t$ specified in the test case.\n3.  **Time-Stepping Loop**: For each simulation, an initial concentration vector $\\mathbf{c}^0 = c_0 \\mathbf{1}$ is created. The simulation proceeds in a time loop from $t=0$ to $t=T$. In each step, the appropriate linear system derived above is formed and solved for $\\mathbf{c}^{k+1}$ using a standard linear solver.\n4.  **Metrics Calculation**:\n    - During the simulation loop for a method $M$, we track the earliest time $t_k$ when $\\min(\\mathbf{c}^k)  c_{\\min,*}$ to find $\\tau_{\\mathrm{dep}}(M)$.\n    - We maintain a flag for positivity violation, setting it to $1$ if any component of $\\mathbf{c}^k$ ever becomes negative.\n    - We count monotonicity violations by checking if $\\min(\\mathbf{c}^{k+1})  \\min(\\mathbf{c}^k)$ during the pulse interval $[t_{\\mathrm{on}}, t_{\\mathrm{off}})$.\n    - After the loop completes, the final concentration $\\mathbf{c}_M(T)$ is obtained. The relative $L^2$ error $\\mathcal{E}_{L^2}(M)$ is computed by comparing $\\mathbf{c}_M(T)$ with $\\mathbf{c}_{\\mathrm{ref}}(T)$ using the discrete vector $2$-norm. The depletion-time absolute error is calculated as $|\\tau_{\\mathrm{dep}}(M) - \\tau_{\\mathrm{dep}}(\\mathrm{ref})|$.\n5.  **Output Aggregation**: The four computed metrics for each method and each test case are collected and formatted into a single comma-separated list as specified.\n\nThe provided numerical parameters for the test cases ensure that the time-stepping loops run for an integer number of steps. The matrices involved in the linear systems are tridiagonal (or nearly so), which allows for efficient solution, although a general-purpose dense solver is sufficient given the small size of $N$.",
            "answer": "```python\nimport numpy as np\n\ndef run_simulation(method, D, L, N, T, dt, s0, t_on, t_off, c0, c_min_star):\n    \"\"\"\n    Solves the 1D diffusion-reaction PDE for a given numerical method.\n\n    Returns:\n        tuple: (final concentration profile, depletion time, positivity violation flag, monotonicity violation count)\n    \"\"\"\n    dx = L / (N - 1)\n    \n    # Build the spatial discretization matrix A\n    A = np.diag(np.full(N, -2.0)) + np.diag(np.ones(N - 1), 1) + np.diag(np.ones(N - 1), -1)\n    A[0, 1] = 2.0\n    A[N - 1, N - 2] = 2.0\n    A *= D / (dx**2)\n\n    # Time integration setup\n    num_steps = int(round(T / dt))\n    time_points = np.linspace(0, T, num_steps + 1)\n\n    # Initial condition\n    c_current = np.full(N, c0, dtype=float)\n\n    # Sink term function\n    def s(t):\n        return s0 if t_on = t  t_off else 0.0\n\n    # Initialize metrics\n    depletion_time = T\n    positivity_violation = 0\n    monotonicity_violation_count = 0\n    \n    # Pre-compute matrices for linear solves\n    M_IE, M_CN_L, M_CN_R, M_BDF2 = None, None, None, None\n    if method == \"IE\" or (method == \"BDF2\"): # BDF2 uses IE for startup\n        M_IE = np.identity(N) - dt * A\n    if method == \"CN\":\n        M_CN_L = np.identity(N) - (dt / 2.0) * A\n        M_CN_R = np.identity(N) + (dt / 2.0) * A\n    if method == \"BDF2\":\n        M_BDF2 = np.identity(N) - (2.0 * dt / 3.0) * A\n    \n    c_prev = None  # For BDF2\n\n    # Time-stepping loop\n    for k in range(num_steps):\n        t_current = time_points[k]\n        t_next = time_points[k+1]\n        \n        s_current_val = s(t_current)\n        s_next_val = s(t_next)\n\n        min_c_before_step = np.min(c_current)\n\n        if method == \"IE\":\n            rhs = c_current - dt * s_next_val\n            c_next = np.linalg.solve(M_IE, rhs)\n        \n        elif method == \"CN\":\n            s_avg = (s_current_val + s_next_val) / 2.0\n            rhs = M_CN_R @ c_current - dt * s_avg\n            c_next = np.linalg.solve(M_CN_L, rhs)\n\n        elif method == \"BDF2\":\n            if k == 0:\n                # First step with Implicit Euler\n                rhs_ie = c_current - dt * s_next_val\n                c_next = np.linalg.solve(M_IE, rhs_ie)\n            else:\n                # Subsequent steps with BDF2\n                rhs = (4.0/3.0) * c_current - (1.0/3.0) * c_prev - (2.0 * dt / 3.0) * s_next_val\n                c_next = np.linalg.solve(M_BDF2, rhs)\n            c_prev = c_current.copy()\n        else: # Should not happen\n            c_next = c_current\n\n        # Update state\n        c_current = c_next\n\n        # Check metrics\n        if np.min(c_current)  c_min_star and depletion_time == T:\n            depletion_time = t_next\n        if np.any(c_current  0):\n            positivity_violation = 1\n        \n        if t_on = t_current  t_off:\n            if np.min(c_current) > min_c_before_step:\n                monotonicity_violation_count += 1\n\n    return c_current, depletion_time, positivity_violation, monotonicity_violation_count\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        # (D, L, N, T, dt, s0, t_on, t_off, c0, c_min_star)\n        (2.0e-10, 1.0e-4, 50, 2.0, 0.02, 50.0, 0.5, 1.5, 1000.0, 800.0), # Case A\n        (1.0e-10, 1.0e-4, 60, 2.0, 0.2, 300.0, 0.4, 1.8, 1000.0, 700.0), # Case B\n        (5.0e-11, 1.5e-4, 40, 1.5, 0.05, 600.0, 0.2, 0.8, 1200.0, 900.0), # Case C\n    ]\n\n    all_results = []\n    \n    for case_params in test_cases:\n        D, L, N, T, dt, s0, t_on, t_off, c0, c_min_star = case_params\n        N = int(N)\n\n        # 1. Compute reference solution\n        dt_ref = 1e-3\n        c_ref_T, tau_dep_ref, _, _ = run_simulation(\n            \"IE\", D, L, N, T, dt_ref, s0, t_on, t_off, c0, c_min_star\n        )\n        norm_c_ref_T = np.linalg.norm(c_ref_T)\n        \n        methods = [\"IE\", \"CN\", \"BDF2\"]\n        for method in methods:\n            # 2. Run simulation for the current method\n            c_M_T, tau_dep_M, pos_viol_M, mono_count_M = run_simulation(\n                method, D, L, N, T, dt, s0, t_on, t_off, c0, c_min_star\n            )\n            \n            # 3. Compute metrics\n            dep_err = abs(tau_dep_M - tau_dep_ref)\n            \n            if norm_c_ref_T > 1e-12:\n                rel_L2_err = np.linalg.norm(c_M_T - c_ref_T) / norm_c_ref_T\n            elif np.linalg.norm(c_M_T - c_ref_T)  1e-12:\n                rel_L2_err = 0.0\n            else: # Should not happen in this problem\n                rel_L2_err = np.linalg.norm(c_M_T - c_ref_T)\n\n            # Append results for this method\n            all_results.extend([dep_err, rel_L2_err, pos_viol_M, mono_count_M])\n\n    # Final print statement\n    formatted_results = [f'{x:.6f}' if isinstance(x, float) else str(x) for x in all_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "真实的电池模型通常耦合了多个物理过程，例如扩散和电化学反应，这些过程的时间尺度可能相差悬殊。算子分裂法是处理此类多物理场问题的一种强大而高效的技术，它允许对不同物理过程采用不同的数值方法。本练习  将演示如何构建一个半隐式分裂格式，将刚性的扩散部分（隐式处理）与非线性的反应动力学部分（显式处理）分离开来。通过分析这种简化所引入的“分裂误差”，您将深入了解前沿仿真工具中使用的先进数值策略及其对求解精度和效率的影响。",
            "id": "3933651",
            "problem": "考虑一个单粒子电极模型，其中嵌入物浓度通过在一维平板中的扩散而演化。该平板厚度为 $L$，空间坐标为 $x \\in [0,L]$，时间为 $t \\ge 0$。控制偏微分方程是菲克第二定律 (Fick's second law)，$ \\partial c/\\partial t = D \\, \\partial^2 c/\\partial x^2 $，其中 $c(x,t)$ 是固相浓度（单位为 $\\mathrm{mol/m^3}$），$D$ 是固态扩散系数（单位为 $\\mathrm{m^2/s}$）。$x=0$ 处的边界条件强制对称性，$\\partial c/\\partial x \\vert_{x=0} = 0$。$x=L$ 处的边界条件强制一个指定的摩尔通量 $J(t)$（单位为 $\\mathrm{mol/(m^2 \\cdot s)}$），$-D \\, \\partial c/\\partial x \\vert_{x=L} = J(t)$。假设初始条件为 $c(x,0) = c_0$。\n\n施加的电流密度 $j(t)$（单位为 $\\mathrm{A/m^2}$）和摩尔通量通过 $j(t) = F \\, J(t)$ 相关联，其中 $F$ 是法拉第常数（单位为 $\\mathrm{C/mol}$）。电极电压 $V(t)$（单位为 $\\mathrm{V}$）被建模为在表面浓度 $c_s(t) \\equiv c(L,t)$ 处评估的开路电位 $U(c_s)$、强制给定电流 $j(t)$ 的巴特勒-福尔默动力学 (Butler–Volmer kinetics) 的动力学过电位 $\\eta(t)$，以及一个欧姆压降 $R_{\\mathrm{ohm}} \\, j(t)$ 的总和：\n$$\nV(t) = U(c_s(t)) + \\eta(t) + R_{\\mathrm{ohm}} \\, j(t),\n$$\n其中 $R_{\\mathrm{ohm}}$ 是一个恒定的面积比欧姆电阻（单位为 $\\Omega \\cdot \\mathrm{m^2}$）。开路电位为 $U(c_s) = U_0 + \\frac{R T}{F} \\ln\\!\\left(\\frac{c_s}{c_{\\max} - c_s}\\right)$，其中 $U_0$ 是一个常数（单位为 $\\mathrm{V}$），$R$ 是通用气体常数（单位为 $\\mathrm{J/(mol \\cdot K)}$），$T$ 是绝对温度（单位为 $\\mathrm{K}$），$c_{\\max}$ 是最大浓度（单位为 $\\mathrm{mol/m^3}$）。假设对称的电化学传递系数和交换电流密度 $j_0(c_s) = F \\, k_0 \\, \\sqrt{c_e} \\, \\sqrt{c_s \\, (c_{\\max} - c_s)}$（单位为 $\\mathrm{A/m^2}$），其中 $k_0$ 是一个速率常数（单位为 $\\mathrm{m/s}$），$c_e$ 是电解质浓度（单位为 $\\mathrm{mol/m^3}$）。对于对称传递系数的巴特勒-福尔默关系要求动力学过电位 $\\eta(t)$ 满足 $j(t) = 2 j_0(c_s(t)) \\sinh\\!\\left(\\frac{\\alpha F \\eta(t)}{R T}\\right)$，其中 $\\alpha$ 是传递系数（无量纲）。\n\n任务A（推导）：从守恒定律和边界条件出发，推导一个时间步长为 $\\Delta t$ 的半隐式算子分裂时间离散化方法，该方法隐式处理扩散算子，显式处理动力学算子。令 $c^n(x)$ 表示在时间 $t_n$ 的浓度，$c^{n+1}(x)$ 表示在时间 $t_{n+1} = t_n + \\Delta t$ 的浓度。展示如何通过在边界 $x=L$ 处使用通量 $J(t_{n+1})$ 隐式求解扩散子问题来获得 $c^{n+1}(x)$，然后通过在前一个表面浓度 $c_s^n$ 处评估 $U$ 和 $j_0$ 来计算电压 $V_{\\mathrm{split}}^{n+1}$。通过在更新后的表面浓度 $c_s^{n+1}$ 处评估 $U$ 和 $j_0$ 来构建相应的完全耦合参考电压 $V_{\\mathrm{full}}^{n+1}$。明确推导由扩散方程在 $N$ 个单元的均匀网格上进行有限体积法后向欧拉离散化所产生的线性系统，其中在 $x=0$ 处为对称，在 $x=L$ 处为固定通量。您的推导必须基于基本的守恒和本构定律，并且必须清楚地区分算子分裂电压和完全耦合电压。\n\n任务B（实现）：在一个独立的、自包含的程序中实现所推导的方案。使用具有 $N$ 个节点的均匀空间网格和用于扩散的后向欧拉隐式时间步进。使用以下参数值，均采用国际单位制（SI）：$L = 5 \\times 10^{-6}$ m, $D = 1 \\times 10^{-14}$ $\\mathrm{m^2/s}$, $c_{\\max} = 3.1 \\times 10^{4}$ $\\mathrm{mol/m^3}$, $c_0 = 2.0 \\times 10^{4}$ $\\mathrm{mol/m^3}$, $k_0 = 1.0 \\times 10^{-11}$ $\\mathrm{m/s}$, $\\alpha = 0.5$, $c_e = 1.0 \\times 10^{3}$ $\\mathrm{mol/m^3}$, $U_0 = 1.0 \\times 10^{-1}$ $\\mathrm{V}$, $R_{\\mathrm{ohm}} = 1.0 \\times 10^{-2}$ $\\Omega \\cdot \\mathrm{m^2}$, $F = 9.6485 \\times 10^{4}$ $\\mathrm{C/mol}$, $R = 8.314$ $\\mathrm{J/(mol \\cdot K)}$, $T = 298$ $\\mathrm{K}$，以及 $N = 50$。\n\n任务C（评估）：对于每个时间步，使用相同的施加电流密度 $j(t_{n+1})$ 计算 $V_{\\mathrm{split}}^{n+1}$ 和 $V_{\\mathrm{full}}^{n+1}$。在整个仿真时域内，计算电压的均方根分裂误差，\n$$\n\\varepsilon_V = \\sqrt{\\frac{1}{M} \\sum_{n=1}^{M} \\left(V_{\\mathrm{split}}^{n} - V_{\\mathrm{full}}^{n}\\right)^2},\n$$\n其中 $M$ 是总时间步数。以伏特（V）为单位表示 $\\varepsilon_V$。\n\n测试套件和输出规范：您的程序必须运行以下四个科学上不同的测试用例，每个用例都有其自己的时间范围和施加的电流曲线 $j(t)$，并产生单行输出，列出四个 $\\varepsilon_V$ 的值，形式为用方括号括起来的逗号分隔列表，单位为伏特，并四舍五入到六位小数。\n\n- 测试1（正常路径）：$\\Delta t = 1.0 \\times 10^{-1}$ s, $T_{\\mathrm{end}} = 2.0 \\times 10^{2}$ s, 对所有 $t$, $j(t) = 5.0 \\times 10^{-1}$ $\\mathrm{A/m^2}$。\n- 测试2（方向反转脉冲）：$\\Delta t = 1.0 \\times 10^{-1}$ s, $T_{\\mathrm{end}} = 2.0 \\times 10^{2}$ s, $j(t)$ 是一个方波，在 $+5.0 \\times 10^{-1}$ $\\mathrm{A/m^2}$ 和 $-5.0 \\times 10^{-1}$ $\\mathrm{A/m^2}$ 之间交替，周期为 $2.0 \\times 10^{1}$ s，占空比为 $50\\%$，从 $+5.0 \\times 10^{-1}$ $\\mathrm{A/m^2}$ 开始。\n- 测试3（大时间步长）：$\\Delta t = 5.0 \\times 10^{-1}$ s, $T_{\\mathrm{end}} = 2.0 \\times 10^{2}$ s, 对所有 $t$, $j(t) = 5.0 \\times 10^{-1}$ $\\mathrm{A/m^2}$。\n- 测试4（小时间步长基准）：$\\Delta t = 1.0 \\times 10^{-2}$ s, $T_{\\mathrm{end}} = 5.0 \\times 10^{1}$ s, 对所有 $t$, $j(t) = 5.0 \\times 10^{-1}$ $\\mathrm{A/m^2}$。\n\n最终输出格式：您的程序应产生一行输出，包含四个结果，格式为用方括号括起来的逗号分隔列表，例如 $[v_1,v_2,v_3,v_4]$，其中每个 $v_i$ 是均方根分裂误差 $\\varepsilon_V$，单位为伏特（V），四舍五入到六位小数。",
            "solution": "问题陈述已经过仔细审查，并被确定为有效。其科学基础植根于电化学工程和质量传输原理，在数学上是适定的、客观的，并且是自包含的，为获得唯一解提供了所有必要的参数和条件。各项任务定义明确，构成了电池系统数值建模中的一个标准练习。\n\n### 任务 A：数值方案的推导\n\n此任务要求为给定的单粒子模型推导一个半隐式算子分裂方案。我们将首先使用有限体积法在空间上对控制扩散方程进行离散化，并使用隐式后向欧拉法在时间上进行离散化。然后，我们将构建完全耦合电压和算子分裂电压的表达式。\n\n**1. 使用有限体积法的空间离散化**\n\n控制偏微分方程是菲克第二定律：\n$$\n\\frac{\\partial c(x,t)}{\\partial t} = D \\frac{\\partial^2 c(x,t)}{\\partial x^2}\n$$\n我们将空间域 $x \\in [0, L]$ 离散化为 $N$ 个均匀的控制体积（CVs），每个宽度为 $\\Delta x = L/N$。对于 $i=1, \\dots, N$，第 $i$ 个控制体积的中心位于 $x_i = (i-0.5)\\Delta x$，范围为区间 $[(i-1)\\Delta x, i\\Delta x]$。令 $c_i(t)$ 为第 $i$ 个控制体积内的空间平均浓度。\n\n我们在第 $i$ 个控制体积上对 PDE 进行积分，从 $x_{i-1/2} = (i-1)\\Delta x$ 到 $x_{i+1/2} = i\\Delta x$：\n$$\n\\int_{x_{i-1/2}}^{x_{i+1/2}} \\frac{\\partial c}{\\partial t} \\, dx = \\int_{x_{i-1/2}}^{x_{i+1/2}} D \\frac{\\partial^2 c}{\\partial x^2} \\, dx\n$$\n应用莱布尼茨法则（Leibniz's rule）和微积分基本定理：\n$$\n\\frac{d}{dt} \\left( \\int_{x_{i-1/2}}^{x_{i+1/2}} c \\, dx \\right) = D \\left[ \\frac{\\partial c}{\\partial x} \\right]_{x_{i-1/2}}^{x_{i+1/2}}\n$$\n通过平均浓度 $c_i$ 乘以体积宽度 $\\Delta x$ 来近似浓度的积分，我们得到：\n$$\n\\Delta x \\frac{dc_i}{dt} = D \\left( \\left. \\frac{\\partial c}{\\partial x} \\right|_{x_{i+1/2}} - \\left. \\frac{\\partial c}{\\partial x} \\right|_{x_{i-1/2}} \\right)\n$$\n右侧的项可以被识别为单元界面的摩尔通量，$J_{\\text{face}} = -D \\, \\partial c/\\partial x$。\n$$\n\\frac{dc_i}{dt} = - \\frac{1}{\\Delta x} \\left( J_{i+1/2} - J_{i-1/2} \\right)\n$$\n我们使用相邻单元中心之间的中心差分来近似单元界面的梯度：\n$$\n\\left. \\frac{\\partial c}{\\partial x} \\right|_{x_{i+1/2}} \\approx \\frac{c_{i+1}(t) - c_i(t)}{\\Delta x}\n$$\n这给出了内部单元（$i = 2, \\dots, N-1$）的半离散化常微分方程（ODE）：\n$$\n\\frac{dc_i}{dt} = \\frac{D}{\\Delta x^2} \\left( (c_{i+1} - c_i) - (c_i - c_{i-1}) \\right) = \\frac{D}{\\Delta x^2} (c_{i+1} - 2c_i + c_{i-1})\n$$\n\n对于边界单元：\n- **在 $x=0$ 处（单元 $i=1$）：** 边界条件为 $\\partial c/\\partial x \\vert_{x=0} = 0$，这意味着零通量，$J_{1/2} = 0$。\n  $$\n  \\frac{dc_1}{dt} = - \\frac{1}{\\Delta x} (J_{3/2} - J_{1/2}) = - \\frac{1}{\\Delta x} J_{3/2} = - \\frac{1}{\\Delta x} \\left( -D \\frac{c_2 - c_1}{\\Delta x} \\right) = \\frac{D}{\\Delta x^2} (c_2 - c_1)\n  $$\n- **在 $x=L$ 处（单元 $i=N$）：** 边界条件为 $-D \\, \\partial c/\\partial x \\vert_{x=L} = J(t)$。单元 $N$ 的右界面在 $x_{N+1/2} = L$，所以 $J_{N+1/2} = J(t)$。\n  $$\n  \\frac{dc_N}{dt} = - \\frac{1}{\\Delta x} (J_{N+1/2} - J_{N-1/2}) = - \\frac{1}{\\Delta x} \\left( J(t) - (-D \\frac{c_N - c_{N-1}}{\\Delta x}) \\right) = \\frac{D}{\\Delta x^2} (c_{N-1} - c_N) - \\frac{J(t)}{\\Delta x}\n  $$\n\n**2. 隐式时间离散化（后向欧拉法）**\n\n我们使用后向欧拉法进行时间离散化，其中时间导数近似为 $(c_i^{n+1} - c_i^n)/\\Delta t$，所有空间项都在未来的时间步 $t_{n+1}$ 进行评估。令 $\\lambda = D \\Delta t / \\Delta x^2$ 为无量纲扩散数。\n\n- **对于 $i=1$：**\n  $$\n  \\frac{c_1^{n+1} - c_1^n}{\\Delta t} = \\frac{D}{\\Delta x^2}(c_2^{n+1} - c_1^{n+1}) \\implies (1+\\lambda)c_1^{n+1} - \\lambda c_2^{n+1} = c_1^n\n  $$\n- **对于 $i=2, \\dots, N-1$：**\n  $$\n  \\frac{c_i^{n+1} - c_i^n}{\\Delta t} = \\frac{D}{\\Delta x^2}(c_{i+1}^{n+1} - 2c_i^{n+1} + c_{i-1}^{n+1}) \\implies -\\lambda c_{i-1}^{n+1} + (1+2\\lambda)c_i^{n+1} - \\lambda c_{i+1}^{n+1} = c_i^n\n  $$\n- **对于 $i=N$：**\n  $$\n  \\frac{c_N^{n+1} - c_N^n}{\\Delta t} = \\frac{D}{\\Delta x^2}(c_{N-1}^{n+1} - c_N^{n+1}) - \\frac{J(t_{n+1})}{\\Delta x} \\implies -\\lambda c_{N-1}^{n+1} + (1+\\lambda)c_N^{n+1} = c_N^n - \\frac{J^{n+1} \\Delta t}{\\Delta x}\n  $$\n  这里，$J^{n+1} = J(t_{n+1}) = j(t_{n+1})/F$。\n\n这 $N$ 个线性方程构成一个三对角系统 $A \\mathbf{c}^{n+1} = \\mathbf{b}$，其中 $\\mathbf{c}^{n+1} = [c_1^{n+1}, c_2^{n+1}, \\dots, c_N^{n+1}]^T$。矩阵 $A$ 是一个 $N \\times N$ 的矩阵，具有以下结构：\n$$\nA = \\begin{pmatrix}\n1+\\lambda  -\\lambda  0  \\dots  0  0 \\\\\n-\\lambda  1+2\\lambda  -\\lambda  \\dots  0  0 \\\\\n0  \\ddots  \\ddots  \\ddots  \\vdots  \\vdots \\\\\n\\vdots  \\vdots  \\ddots  \\ddots  \\ddots  0 \\\\\n0  0  \\dots  -\\lambda  1+2\\lambda  -\\lambda \\\\\n0  0  \\dots  0  -\\lambda  1+\\lambda\n\\end{pmatrix}\n$$\n右侧向量 $\\mathbf{b}$ 是：\n$$\n\\mathbf{b} = \\begin{pmatrix} c_1^n \\\\ c_2^n \\\\ \\vdots \\\\ c_{N-1}^n \\\\ c_N^n - \\frac{j^{n+1} \\Delta t}{F \\Delta x} \\end{pmatrix}\n$$\n在每个时间步求解这个线性系统，可以得到浓度分布 $\\mathbf{c}^{n+1}$。\n\n**3. 算子分裂与电压计算**\n\n问题指定了一个算子分裂方案，其中扩散是隐式处理的，但动力学计算是相对于表面浓度显式执行的。这意味着电压计算滞后于浓度更新。我们将其与完全耦合的公式进行对比。\n\n在时间 $t_n$ 的表面浓度是 $c_s^n \\equiv c_N^n$。求解线性系统得到更新后的浓度分布 $\\mathbf{c}^{n+1}$，从中我们获得新的表面浓度 $c_s^{n+1} \\equiv c_N^{n+1}$。在新时间步的施加电流密度为 $j^{n+1} = j(t_{n+1})$。\n\n电压分量为：\n- **开路电位：** $U(c_s) = U_0 + \\frac{RT}{F} \\ln\\left(\\frac{c_s}{c_{\\max} - c_s}\\right)$\n- **交换电流密度：** $j_0(c_s) = F k_0 \\sqrt{c_e} \\sqrt{c_s (c_{\\max} - c_s)}$\n- **动力学过电位：** $\\eta(j, c_s) = \\frac{RT}{\\alpha F} \\text{asinh}\\left(\\frac{j}{2 j_0(c_s)}\\right)$\n\n**完全耦合电压 ($V_{\\mathrm{full}}^{n+1}$):**\n这是参考电压，使用在新的时间步 $t_{n+1}$ 评估的所有量来计算。\n$$\nV_{\\mathrm{full}}^{n+1} = U(c_s^{n+1}) + \\eta(j^{n+1}, c_s^{n+1}) + R_{\\mathrm{ohm}} j^{n+1}\n$$\n\n**算子分裂电压 ($V_{\\mathrm{split}}^{n+1}$):**\n该电压是使用*前一个*时间步的表面浓度 $c_s^n$ 来计算电位和动力学项，同时使用*新*时间步的电流。这代表了对模型非线性动力学部分的显式评估。\n$$\nV_{\\mathrm{split}}^{n+1} = U(c_s^{n}) + \\eta(j^{n+1}, c_s^{n}) + R_{\\mathrm{ohm}} j^{n+1}\n$$\n在电压计算中对表面浓度的这种显式处理引入了一个分裂误差，这是需要评估的量。一个时间步的整体算法如下：\n1.  给定 $\\mathbf{c}^n$，确定 $j^{n+1} = j(t_{n+1})$。\n2.  使用 $\\mathbf{c}^n$ 和 $j^{n+1}$ 构建向量 $\\mathbf{b}$。\n3.  求解系统 $A \\mathbf{c}^{n+1} = \\mathbf{b}$ 以找到 $\\mathbf{c}^{n+1}$。\n4.  提取旧的和新的表面浓度，$c_s^n = c_N^n$ 和 $c_s^{n+1} = c_N^{n+1}$。\n5.  使用 $c_s^{n+1}$ 和 $j^{n+1}$ 计算 $V_{\\mathrm{full}}^{n+1}$。\n6.  使用 $c_s^{n}$ 和 $j^{n+1}$ 计算 $V_{\\mathrm{split}}^{n+1}$。\n7.  存储结果并进入下一个时间步。",
            "answer": "```python\nimport numpy as np\nfrom scipy.linalg import solve_banded\nimport math\n\n# The problem asks for a single, self-contained program.\n# All logic is contained within the solve function as requested.\n\ndef solve():\n    \"\"\"\n    Main solver function that orchestrates the simulation for all test cases.\n    \"\"\"\n\n    # --- Task B: Parameter Definition (SI Units) ---\n    params = {\n        'L': 5e-6,         # m\n        'D': 1e-14,        # m^2/s\n        'c_max': 3.1e4,    # mol/m^3\n        'c_0': 2.0e4,      # mol/m^3\n        'k_0': 1.0e-11,    # m/s\n        'alpha': 0.5,      # dimensionless\n        'c_e': 1.0e3,      # mol/m^3\n        'U_0': 1.0e-1,     # V\n        'R_ohm': 1.0e-2,   # Ohm.m^2\n        'F': 96485.0,      # C/mol\n        'R': 8.314,        # J/(mol.K)\n        'T': 298.0,        # K\n        'N': 50            # number of grid cells\n    }\n    \n    # --- Test Suite Definition ---\n    # (dt, T_end, j_func, j_amp, j_period)\n    test_cases = [\n        (1.0e-1, 2.0e2, lambda t, amp, per: amp, 5.0e-1, None), # Test 1\n        (1.0e-1, 2.0e2, lambda t, amp, per: amp if (t % per)  (per / 2.0) else -amp, 5.0e-1, 2.0e1), # Test 2\n        (5.0e-1, 2.0e2, lambda t, amp, per: amp, 5.0e-1, None), # Test 3\n        (1.0e-2, 5.0e1, lambda t, amp, per: amp, 5.0e-1, None)  # Test 4\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        dt, T_end, j_func, j_amp, j_period = case\n        \n        # --- Run one simulation case ---\n        error = run_simulation(params, dt, T_end, j_func, j_amp, j_period)\n        all_results.append(f\"{error:.6f}\")\n\n    print(f\"[{','.join(all_results)}]\")\n\ndef run_simulation(params, dt, T_end, j_func, j_amp, j_period):\n    \"\"\"\n    Executes a single simulation run for a given test case.\n    \"\"\"\n    # Unpack parameters\n    L, D, c_max, c_0, k_0, alpha, c_e, U_0, R_ohm, F, R, T, N = params.values()\n\n    # --- Discretization Setup ---\n    dx = L / N\n    # Dimensionless diffusion number\n    lam = (D * dt) / (dx**2)\n    # Time steps\n    num_steps = int(round(T_end / dt))\n    \n    # --- Tridiagonal Matrix A for the linear system A*c^{n+1} = b ---\n    # Scipy's solve_banded expects bands in a (3, N) array:\n    # row 0: upper diagonal (shifted)\n    # row 1: main diagonal\n    # row 2: lower diagonal (shifted)\n    A_banded = np.zeros((3, N))\n    \n    # Main diagonal\n    A_banded[1, 0] = 1.0 + lam\n    A_banded[1, 1:N-1] = 1.0 + 2.0 * lam\n    A_banded[1, N-1] = 1.0 + lam\n    \n    # Upper diagonal (c_{i+1})\n    A_banded[0, 1:] = -lam\n    \n    # Lower diagonal (c_{i-1})\n    A_banded[2, :-1] = -lam\n\n    # -- Initial condition -- \n    c = np.full(N, c_0)\n\n    squared_errors = []\n\n    # --- Time-stepping loop ---\n    for n in range(num_steps):\n        t_np1 = (n + 1) * dt\n        \n        # Get previous surface concentration\n        c_s_n = c[N-1]\n        \n        # Get current density at new time step\n        j_np1 = j_func(t_np1, j_amp, j_period)\n        \n        # --- Construct RHS vector b ---\n        b = np.copy(c)\n        b[N-1] -= (j_np1 * dt) / (F * dx)\n        \n        # --- Solve diffusion sub-problem for c^{n+1} ---\n        c_np1 = solve_banded((1, 1), A_banded, b)\n        \n        # Get new surface concentration\n        c_s_np1 = c_np1[N-1]\n\n        # --- Calculate Voltages (Task C) ---\n        V_split = calculate_voltage(c_s_n, j_np1, params)\n        V_full = calculate_voltage(c_s_np1, j_np1, params)\n        \n        if V_split is not None and V_full is not None:\n             squared_errors.append((V_split - V_full)**2)\n        \n        # Update concentration for next step\n        c = c_np1\n        \n    # --- Compute RMS Splitting Error ---\n    if not squared_errors:\n        return 0.0 # Avoid division by zero if no valid steps were taken\n    \n    rms_error = np.sqrt(np.mean(squared_errors))\n    return rms_error\n\n\ndef calculate_voltage(c_s, j, params):\n    \"\"\"\n    Calculates the electrode voltage V based on surface concentration and current.\n    \"\"\"\n    # Unpack required parameters\n    c_max, k_0, alpha, c_e, U_0, R_ohm, F, R, T = \\\n        params['c_max'], params['k_0'], params['alpha'], params['c_e'], \\\n        params['U_0'], params['R_ohm'], params['F'], params['R'], params['T']\n\n    # Robustness: Clip c_s to be slightly away from 0 and c_max\n    # to prevent math domain errors in log and sqrt.\n    epsilon = 1e-9\n    c_s_clipped = np.clip(c_s, epsilon, c_max - epsilon)\n    \n    if not (epsilon = c_s = c_max - epsilon):\n        # This condition indicates a potential physical or numerical instability.\n        # For the purpose of this problem, we return None to exclude this data point\n        # from the RMS error calculation, though a real simulation might stop or adapt.\n        return None\n\n    # --- Open-Circuit Potential (U) ---\n    # U(c_s) = U_0 + (RT/F) * ln(c_s / (c_max - c_s))\n    U_cs = U_0 + (R * T / F) * math.log(c_s_clipped / (c_max - c_s_clipped))\n    \n    # --- Exchange Current Density (j0) ---\n    # j0(c_s) = F * k_0 * sqrt(c_e) * sqrt(c_s * (c_max - c_s))\n    j0_cs = F * k_0 * math.sqrt(c_e) * math.sqrt(c_s_clipped * (c_max - c_s_clipped))\n    \n    # --- Kinetic Overpotential (eta) ---\n    # j = 2 * j0 * sinh((alpha*F*eta)/(R*T))\n    # eta = (R*T / (alpha*F)) * asinh(j / (2*j0))\n    # Handle j0=0 case\n    if j0_cs > 0:\n        overpotential = (R * T / (alpha * F)) * math.asinh(j / (2.0 * j0_cs))\n    else:\n        # If j0 is zero, overpotential is theoretically infinite for non-zero j.\n        # This should not happen with proper clipping. Return None if it does.\n        return None\n\n    # --- Total Voltage V ---\n    # V = U(c_s) + eta + R_ohm * j\n    V_total = U_cs + overpotential + R_ohm * j\n    \n    return V_total\n\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}