{
    "hands_on_practices": [
        {
            "introduction": "断层扫描重建技术的核心是利用一系列二维投影图像构建三维体数据。虽然滤波反投影（FBP）等方法计算速度快，但同步代数重建技术（SART）等迭代算法在处理复杂或不完整数据集时表现出优越性。本练习  将让你亲手实现SART算法的核心更新步骤，从而具体地理解三维图像是如何通过对投影误差的迭代校正来计算生成的。",
            "id": "3891022",
            "problem": "考虑一个源于电池电极微观结构分析的离散化层析重建问题，其中从线积分测量值进行的三维微观结构重建在体素网格上进行近似。设有一个由正向模型 $y = Ax$ 定义的线性系统，其中 $A \\in \\mathbb{R}^{m \\times n}$ 是投影矩阵，其元素 $A_{ij} \\ge 0$ 表示射线 $i$ 穿过体素 $j$ 的相交长度；$y \\in \\mathbb{R}^{m}$ 是测得的正弦图向量；$x \\in \\mathbb{R}^{n}$ 是未知的体素属性向量（例如，局部衰减或孔隙度替代指标）。假设测量值是根据X射线断层扫描的 Beer–Lambert law 推导的小对比度条件下体素贡献的线性叠加来建模的，并且我们寻求对 $x$ 进行迭代校正，该校正应符合射线-体素相互作用的几何形状。\n\n使用松弛参数 $\\alpha \\in [0,1]$、每条射线 $i$ 的行归一化权重 $r_i$（通常为 $r_i = \\sum_{j=1}^{n} A_{ij}$）以及每个体素 $j$ 的列归一化权重 $c_j$（通常为 $c_j = \\sum_{i=1}^{m} A_{ij}$），对包含所有射线的给定子集实现一次同步代数重建技术（SART）更新迭代。从初始猜测 $x^{(0)}$ 生成 $x^{(1)}$ 的 SART 更新对每个体素索引 $j \\in \\{1, \\dots, n\\}$ 按分量定义如下：\n$$\nx^{(1)}_j = x^{(0)}_j + \\alpha \\cdot \\frac{\\sum_{i=1}^{m} A_{ij} \\cdot \\left( \\frac{y_i - \\sum_{k=1}^{n} A_{ik} x^{(0)}_k}{r_i} \\right)}{c_j},\n$$\n为确保数值的良置性，采用以下保障措施：\n- 如果 $r_i = 0$，则射线 $i$ 对所有体素的贡献定义为 $0$（即跳过该射线）。\n- 如果 $c_j = 0$，则体素 $j$ 的更新量定义为 $0$（即 $x^{(1)}_j = x^{(0)}_j$）。\n\n本问题中的所有量均为无量纲。程序必须计算更新后的体素值，并将 $x^{(1)}$ 的每个分量四舍五入到六位小数。\n\n您的程序必须对以下参数集测试套件实现上述SART更新，每个参数集由 $(A, y, x^{(0)}, \\alpha, r, c)$ 指定。为清晰起见，所有数组均明确给出：\n\n- 测试用例1（行和列归一化均为非零的通用情况）：\n  $$\n  A = \\begin{bmatrix}\n  0.8  0.1  0.0  0.3 \\\\\n  0.2  0.5  0.7  0.1 \\\\\n  0.0  0.4  0.6  0.0\n  \\end{bmatrix}, \\quad\n  y = \\begin{bmatrix} 1.2 \\\\ 1.8 \\\\ 0.9 \\end{bmatrix}, \\quad\n  x^{(0)} = \\begin{bmatrix} 0.5 \\\\ 0.5 \\\\ 0.5 \\\\ 0.5 \\end{bmatrix}, \\quad\n  \\alpha = 0.7,\n  $$\n  $$\n  r = \\begin{bmatrix} 1.2 \\\\ 1.5 \\\\ 1.0 \\end{bmatrix}, \\quad\n  c = \\begin{bmatrix} 1.0 \\\\ 1.0 \\\\ 1.3 \\\\ 0.4 \\end{bmatrix}.\n  $$\n\n- 测试用例2（松弛参数为零的边界条件）：\n  $$\n  A = \\begin{bmatrix}\n  0.5  0.5  0.0 \\\\\n  0.0  0.3  0.7\n  \\end{bmatrix}, \\quad\n  y = \\begin{bmatrix} 0.9 \\\\ 0.7 \\end{bmatrix}, \\quad\n  x^{(0)} = \\begin{bmatrix} 0.2 \\\\ 0.4 \\\\ 0.6 \\end{bmatrix}, \\quad\n  \\alpha = 0.0,\n  $$\n  $$\n  r = \\begin{bmatrix} 1.0 \\\\ 1.0 \\end{bmatrix}, \\quad\n  c = \\begin{bmatrix} 0.5 \\\\ 0.8 \\\\ 0.7 \\end{bmatrix}.\n  $$\n\n- 测试用例3（存在总相交长度为零的射线的边缘情况）：\n  $$\n  A = \\begin{bmatrix}\n  0.0  0.0  0.0  0.0 \\\\\n  0.4  0.0  0.2  0.0 \\\\\n  0.0  0.3  0.5  0.2\n  \\end{bmatrix}, \\quad\n  y = \\begin{bmatrix} 0.0 \\\\ 0.5 \\\\ 1.0 \\end{bmatrix}, \\quad\n  x^{(0)} = \\begin{bmatrix} 0.0 \\\\ 0.0 \\\\ 0.0 \\\\ 0.0 \\end{bmatrix}, \\quad\n  \\alpha = 1.0,\n  $$\n  $$\n  r = \\begin{bmatrix} 0.0 \\\\ 0.6 \\\\ 1.0 \\end{bmatrix}, \\quad\n  c = \\begin{bmatrix} 0.4 \\\\ 0.3 \\\\ 0.7 \\\\ 0.2 \\end{bmatrix}.\n  $$\n\n- 测试用例4（存在从未被任何射线穿过的体素的边缘情况）：\n  $$\n  A = \\begin{bmatrix}\n  0.2  0.0  0.3 \\\\\n  0.1  0.0  0.4\n  \\end{bmatrix}, \\quad\n  y = \\begin{bmatrix} 0.4 \\\\ 0.5 \\end{bmatrix}, \\quad\n  x^{(0)} = \\begin{bmatrix} 0.1 \\\\ 0.9 \\\\ 0.2 \\end{bmatrix}, \\quad\n  \\alpha = 0.5,\n  $$\n  $$\n  r = \\begin{bmatrix} 0.5 \\\\ 0.5 \\end{bmatrix}, \\quad\n  c = \\begin{bmatrix} 0.3 \\\\ 0.0 \\\\ 0.7 \\end{bmatrix}.\n  $$\n\n- 测试用例5（具有多条射线和多个体素的均衡权重）：\n  $$\n  A = \\begin{bmatrix}\n  0.3  0.7 \\\\\n  0.6  0.4 \\\\\n  0.5  0.5\n  \\end{bmatrix}, \\quad\n  y = \\begin{bmatrix} 1.0 \\\\ 0.8 \\\\ 0.9 \\end{bmatrix}, \\quad\n  x^{(0)} = \\begin{bmatrix} 0.3 \\\\ 0.6 \\end{bmatrix}, \\quad\n  \\alpha = 0.9,\n  $$\n  $$\n  r = \\begin{bmatrix} 1.0 \\\\ 1.0 \\\\ 1.0 \\end{bmatrix}, \\quad\n  c = \\begin{bmatrix} 1.4 \\\\ 1.6 \\end{bmatrix}.\n  $$\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。每个元素对应一个测试用例的结果，其本身也是一个用方括号括起来的逗号分隔列表，包含四舍五入到六位小数的更新后体素值 $x^{(1)}$，例如 $\\left[ [0.123456,0.234567], [\\dots], \\dots \\right]$。输出行中不得包含额外的空格或文本。",
            "solution": "该问题是有效的。所有给定条件都已提供且自洽。该问题在层析重建这一成熟领域有其科学依据，并提出了一个清晰、客观且可解的计算任务。使用同步代数重建技术（SART）是解决此类情况下出现的 $y = Ax$ 形式线性系统的标准做法。\n\n问题的核心是从初始猜测 $x^{(0)}$ 开始，为未知体素属性向量 $x \\in \\mathbb{R}^{n}$ 实现单次迭代更新。更新规则对每个体素分量 $j$ 给出如下：\n$$\nx^{(1)}_j = x^{(0)}_j + \\alpha \\cdot \\frac{\\sum_{i=1}^{m} A_{ij} \\cdot \\left( \\frac{y_i - \\sum_{k=1}^{n} A_{ik} x^{(0)}_k}{r_i} \\right)}{c_j}\n$$\n此处，$y \\in \\mathbb{R}^{m}$ 是测量向量，$A \\in \\mathbb{R}^{m \\times n}$ 是投影矩阵，$\\alpha$ 是松弛参数，$r \\in \\mathbb{R}^{m}$ 和 $c \\in \\mathbb{R}^{n}$ 分别是射线和体素的归一化向量。\n\n为了设计一个高效的算法，我们可以使用向量和矩阵运算来表示这个分量式公式。这种方法不仅计算速度更快（尤其是在使用像 NumPy 这样的库时），而且能更清晰地对应于过程中的基本物理和数学步骤：正向投影、残差计算、反向投影和更新。\n\n算法步骤如下：\n1.  **正向投影**：首先，我们根据当前的体素猜测值 $x^{(0)}$ 计算“模拟”测量值。这对应于内部求和 $\\sum_{k=1}^{n} A_{ik} x^{(0)}_k$。在向量表示法中，这是矩阵-向量乘积 $p^{(0)} = A x^{(0)}$。\n2.  **残差计算**：然后，我们计算实际测量值 $y$ 与模拟测量值 $p^{(0)}$ 之间的差值。这个差值，即残差，为 $\\Delta y = y - p^{(0)}$。\n3.  **加权残差投影**：每条射线 $i$ 的残差通过该射线的总相交长度的倒数 $1/r_i$ 进行加权。这个项 $w_i = (y_i - p^{(0)}_i)/r_i$ 表示每个投影的归一化误差。我们必须处理 $r_i=0$ 的情况（即射线不与任何体素相交），将其贡献设置为 $0$。设 $w$ 为这些加权残差的向量。\n4.  **反向投影**：然后将加权残差“反向投影”回体素网格。项 $\\sum_{i=1}^{m} A_{ij} w_i$ 计算了所有加权射线误差对体素 $j$ 的总贡献。这等效于矩阵-向量乘积 $b = A^T w$，其中 $A^T$ 是投影矩阵的转置。\n5.  **体素更新归一化**：每个体素 $j$ 的反向投影校正量随后通过该体素的总相交权重 $c_j$ 进行归一化。这给出了归一化更新方向 $d_j = b_j / c_j$。同样，我们必须处理 $c_j=0$ 的情况（即体素从未被任何射线穿过），将其更新量设置为 $0$。设 $d$ 为这些归一化更新量的向量。\n6.  **最终体素更新**：最后，通过加上经过缩放和松弛的校正项来更新初始体素向量 $x^{(0)}$。完整的向量更新为 $x^{(1)} = x^{(0)} + \\alpha d$。\n\n这个向量化操作序列——$p^{(0)} = A x^{(0)}$、$\\Delta y = y - p^{(0)}$、由 $\\Delta y / r$ 得到 $w$、$b = A^T w$、由 $b/c$ 得到 $d$ 以及 $x^{(1)} = x^{(0)} + \\alpha d$——是 SART 公式的直接且稳健的实现。通过在计算 $w$ 和 $d$ 期间使用条件逻辑或掩码数组操作，可以自然地融入所提供的除零保护措施。最终结果通过将 $x^{(1)}$ 的分量四舍五入到六位小数获得。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the SART iteration problem for a suite of test cases.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1\n        (\n            np.array([[0.8, 0.1, 0.0, 0.3], [0.2, 0.5, 0.7, 0.1], [0.0, 0.4, 0.6, 0.0]]),\n            np.array([1.2, 1.8, 0.9]),\n            np.array([0.5, 0.5, 0.5, 0.5]),\n            0.7,\n            np.array([1.2, 1.5, 1.0]),\n            np.array([1.0, 1.0, 1.3, 0.4])\n        ),\n        # Test case 2\n        (\n            np.array([[0.5, 0.5, 0.0], [0.0, 0.3, 0.7]]),\n            np.array([0.9, 0.7]),\n            np.array([0.2, 0.4, 0.6]),\n            0.0,\n            np.array([1.0, 1.0]),\n            np.array([0.5, 0.8, 0.7])\n        ),\n        # Test case 3\n        (\n            np.array([[0.0, 0.0, 0.0, 0.0], [0.4, 0.0, 0.2, 0.0], [0.0, 0.3, 0.5, 0.2]]),\n            np.array([0.0, 0.5, 1.0]),\n            np.array([0.0, 0.0, 0.0, 0.0]),\n            1.0,\n            np.array([0.0, 0.6, 1.0]),\n            np.array([0.4, 0.3, 0.7, 0.2])\n        ),\n        # Test case 4\n        (\n            np.array([[0.2, 0.0, 0.3], [0.1, 0.0, 0.4]]),\n            np.array([0.4, 0.5]),\n            np.array([0.1, 0.9, 0.2]),\n            0.5,\n            np.array([0.5, 0.5]),\n            np.array([0.3, 0.0, 0.7])\n        ),\n        # Test case 5\n        (\n            np.array([[0.3, 0.7], [0.6, 0.4], [0.5, 0.5]]),\n            np.array([1.0, 0.8, 0.9]),\n            np.array([0.3, 0.6]),\n            0.9,\n            np.array([1.0, 1.0, 1.0]),\n            np.array([1.4, 1.6])\n        )\n    ]\n    \n    formatted_results = []\n\n    for A, y, x0, alpha, r, c in test_cases:\n        # Step 1: Forward Projection\n        # p0 = A @ x0\n        p0 = A.dot(x0)\n        \n        # Step 2: Residual Calculation\n        # delta_y = y - p0\n        delta_y = y - p0\n        \n        # Step 3: Weighted Residual Projection (with safeguard for r_i = 0)\n        # w = (y - p0) / r\n        w = np.divide(delta_y, r, out=np.zeros_like(y, dtype=float), where=r!=0)\n\n        # Step 4: Back-Projection\n        # b = A^T @ w\n        b = A.T.dot(w)\n        \n        # Step 5: Voxel Update Normalization (with safeguard for c_j = 0)\n        # d = b / c\n        d = np.divide(b, c, out=np.zeros_like(x0, dtype=float), where=c!=0)\n        \n        # Step 6: Final Voxel Update\n        # x1 = x0 + alpha * d\n        x1 = x0 + alpha * d\n        \n        # Round to six decimal places as specified\n        x1_rounded = np.round(x1, 6)\n        \n        # Format the result for the specific output string requirement\n        # Ensures trailing zeros to meet 6 decimal places format\n        per_case_result = \",\".join([f\"{val:.6f}\" for val in x1_rounded])\n        formatted_results.append(f\"[{per_case_result}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "原始的断层扫描重建图像中，体素的值仅仅是任意的灰度单位。为了进行定量的材料分析，我们必须将这些灰度值转换为具有物理意义的量。本练习  将指导你完成一个关键的校准过程：使用已知参考物质将灰度值映射到线性衰减系数（$\\mu$），从而将定性的灰度图像转变为可用于科学分析的定量数据集。",
            "id": "3891003",
            "problem": "一个实验室X射线计算机断层扫描（XCT）系统重建了锂离子电池电极的三维体数据。在固定的管电压下，经过标准的预处理以减轻射线硬化和环状伪影后，该系统的重建算法（滤波反投影，FBP）产生的体素强度与局部线性衰减系数呈线性关系。X射线透射的正向模型由比尔-朗伯定律给出：对于穿过样品的射线，其透射强度满足 $I = I_{0} \\exp\\!\\left(-\\int \\mu(\\mathbf{r})\\, ds\\right)$，其中 $I_{0}$ 是入射强度，$\\mu(\\mathbf{r})$ 是与位置相关的线性衰减系数。由于探测器的增益和偏移，重建算法恢复的衰减场与真实值之间相差一个未知的仿射变换。\n\n使用在相同有效能量下采集的两个均匀区域进行校准：（i）空气，其在工作能量下的衰减可忽略不计，因此可取为 $\\,\\mu_{\\text{air}} \\approx 0\\,$，以及（ii）一种已知衰减系数为 $\\,\\mu_{\\text{ref}}\\,$ 的液体参考材料。在校准区域中测得的平均重建灰度值为 $\\,g_{\\text{air}} = 120\\,$ 和 $\\,g_{\\text{ref}} = 1120\\,$。已知参考材料在有效射线能量下的衰减系数为 $\\,\\mu_{\\text{ref}} = 19.2\\,\\text{m}^{-1}\\,$。\n\n在一个重建的阴极子体积中，分割后得到各相的平均灰度值：充满电解质的孔隙 $\\,g_{\\text{el}} = 520\\,$，聚合物粘合剂 $\\,g_{\\text{bi}} = 1620\\,$，活性物质 $\\,g_{\\text{am}} = 3120\\,$，以及导电碳 $\\,g_{\\text{c}} = 920\\,$。假设重建的强度-衰减关系是一个在整个目标动态范围内都通用的未知仿射映射，并且校准数据直接适用（即具有相同的有效能谱、几何结构和重建设置）。\n\n从比尔-朗伯定律和重建的线性关系出发，利用空气和参考材料的校准数据，推导从重建灰度值 $\\,g\\,$到线性衰减系数 $\\,\\mu(g)\\,$ 的映射关系。然后，计算所列四种电极相的衰减系数。将每个最终值以 $\\text{m}^{-1}$ 为单位表示，并四舍五入到四位有效数字。按 $\\left[\\mu_{\\text{el}},\\, \\mu_{\\text{bi}},\\, \\mu_{\\text{am}},\\, \\mu_{\\text{c}}\\right]$ 的顺序列出这四种相的值。",
            "solution": "首先将对问题进行验证，以确保其科学基础扎实、提法恰当、客观且完整。\n\n### 第1步：提取已知条件\n问题陈述中明确给出的数据和条件如下：\n- **正向模型（比尔-朗伯定律）：** $I = I_{0} \\exp(-\\int \\mu(\\mathbf{r})\\, ds)$，其中 $I$ 是透射强度，$I_0$ 是入射强度，$\\mu(\\mathbf{r})$ 是与位置相关的线性衰减系数。\n- **重建模型：** 重建的体素灰度值 $g$ 与局部线性衰减系数 $\\mu$ 通过一个未知的仿射变换相关联：$\\mu(g) = A \\cdot g + B$。\n- **校准数据点1（空气）：**\n    - 衰减系数：$\\mu_{\\text{air}} \\approx 0 \\, \\text{m}^{-1}$。\n    - 平均灰度值：$g_{\\text{air}} = 120$。\n- **校准数据点2（参考材料）：**\n    - 衰减系数：$\\mu_{\\text{ref}} = 19.2 \\, \\text{m}^{-1}$。\n    - 平均灰度值：$g_{\\text{ref}} = 1120$。\n- **分割后各相的灰度值：**\n    - 充满电解质的孔隙：$g_{\\text{el}} = 520$。\n    - 聚合物粘合剂：$g_{\\text{bi}} = 1620$。\n    - 活性物质：$g_{\\text{am}} = 3120$。\n    - 导电碳：$g_{\\text{c}} = 920$。\n- **任务：**\n    1. 推导映射关系 $\\mu(g)$。\n    2. 计算四种电极相的衰减系数：$\\mu_{\\text{el}}, \\mu_{\\text{bi}}, \\mu_{\\text{am}}, \\mu_{\\text{c}}$。\n- **输出要求：**\n    1. 数值单位必须是 $\\text{m}^{-1}$。\n    2. 数值必须四舍五入到四位有效数字。\n    3. 最终答案必须是按 $[\\mu_{\\text{el}},\\, \\mu_{\\text{bi}},\\, \\mu_{\\text{am}},\\, \\mu_{\\text{c}}]$ 顺序排列的行矩阵。\n\n### 第2步：使用提取的已知条件进行验证\n根据验证标准对问题进行评估。\n- **科学基础扎实：** 该问题基于X射线计算机断层扫描（XCT）的基本原理。比尔-朗伯定律是单色X射线衰减的正确物理模型。在定量CT中，尤其是在固定X射线能谱下对有限范围的材料进行扫描时，假设经过预处理后，滤波反投影重建的强度与线性衰减系数成线性比例，是一个标准且有效的近似。所提供的衰减系数和灰度级的数值对于电池电极的XCT扫描来说是物理上合理的。该问题在科学上是合理的。\n- **适定性：** 问题提供了两个不同的校准点 $(\\mu, g)$ 来确定仿射变换（一条直线）的两个参数。这正是获得唯一解所需的确切信息量。任务是将这个已确定的变换应用于新的输入值，这是一个定义明确的数学过程。该问题是适定的。\n- **客观性：** 问题以材料科学和医学成像领域通用的精确技术语言陈述。所有量都已定义，任务明确。它不包含主观或基于意见的陈述。\n- **完整性和一致性：** 问题是自洽的。解决问题所需的所有必要数据都已提供，并且在给定信息中没有矛盾之处。\n\n### 第3步：结论与行动\n该问题是有效的。这是一个标准的两点校准问题，具有科学合理性、适定性、客观性和内部一致性。现在将推导其解法。\n\n### 解法推导\n问题陈述，线性衰减系数 $\\mu$ 与重建灰度值 $g$ 之间的关系是一个仿射映射。这可以表示为一个线性方程：\n$$ \\mu(g) = A \\cdot g + B $$\n其中 $A$ 是斜率（缩放因子），$B$ 是截距（偏移量）。我们的目标是使用提供的两个校准点来确定常数 $A$ 和 $B$。\n\n两个校准点是 $(\\mu_{\\text{air}}, g_{\\text{air}})$ 和 $(\\mu_{\\text{ref}}, g_{\\text{ref}})$。我们可以将它们代入仿射方程，形成一个由两个线性方程组成的方程组：\n1. $\\mu_{\\text{air}} = A \\cdot g_{\\text{air}} + B$\n2. $\\mu_{\\text{ref}} = A \\cdot g_{\\text{ref}} + B$\n\n代入给定的数值：\n1. $0 = A \\cdot 120 + B$\n2. $19.2 = A \\cdot 1120 + B$\n\n我们可以解这个方程组求出 $A$ 和 $B$。首先，我们将方程(2)减去方程(1)来求解斜率 $A$：\n$$ \\mu_{\\text{ref}} - \\mu_{\\text{air}} = (A \\cdot g_{\\text{ref}} + B) - (A \\cdot g_{\\text{air}} + B) $$\n$$ \\mu_{\\text{ref}} - \\mu_{\\text{air}} = A \\cdot (g_{\\text{ref}} - g_{\\text{air}}) $$\n$$ A = \\frac{\\mu_{\\text{ref}} - \\mu_{\\text{air}}}{g_{\\text{ref}} - g_{\\text{air}}} $$\n代入校准点的数值：\n$$ A = \\frac{19.2 - 0}{1120 - 120} = \\frac{19.2}{1000} = 0.0192 $$\n$A$ 的单位是 $\\text{m}^{-1}$ 每灰度单位。\n\n接下来，我们通过重新整理方程(1)来求解截距 $B$：\n$$ B = -A \\cdot g_{\\text{air}} $$\n代入 $A$ 和 $g_{\\text{air}}$ 的值：\n$$ B = -(0.0192) \\cdot 120 = -2.304 $$\n$B$ 的单位是 $\\text{m}^{-1}$。\n\n因此，推导出的从灰度 $g$ 到衰减系数 $\\mu$ 的仿射映射为：\n$$ \\mu(g) = 0.0192 \\cdot g - 2.304 $$\n\n现在，我们使用这个映射来计算指定的四种电极相的衰减系数。所有结果将以 $\\text{m}^{-1}$ 为单位报告，并四舍五入到四位有效数字。\n\n1.  **充满电解质的孔隙 ($\\mu_{\\text{el}}$):** $g_{\\text{el}} = 520$。\n    $$ \\mu_{\\text{el}} = (0.0192 \\cdot 520) - 2.304 = 9.984 - 2.304 = 7.68 $$\n    四舍五入到四位有效数字得到 $7.680$。\n\n2.  **聚合物粘合剂 ($\\mu_{\\text{bi}}$):** $g_{\\text{bi}} = 1620$。\n    $$ \\mu_{\\text{bi}} = (0.0192 \\cdot 1620) - 2.304 = 31.104 - 2.304 = 28.8 $$\n    四舍五入到四位有效数字得到 $28.80$。\n\n3.  **活性物质 ($\\mu_{\\text{am}}$):** $g_{\\text{am}} = 3120$。\n    $$ \\mu_{\\text{am}} = (0.0192 \\cdot 3120) - 2.304 = 59.904 - 2.304 = 57.6 $$\n    四舍五入到四位有效数字得到 $57.60$。\n\n4.  **导电碳 ($\\mu_{\\text{c}}$):** $g_{\\text{c}} = 920$。\n    $$ \\mu_{\\text{c}} = (0.0192 \\cdot 920) - 2.304 = 17.664 - 2.304 = 15.36 $$\n    该值已有四位有效数字。\n\n计算出的四种相的衰减系数，四舍五入到四位有效数字后，分别为：$\\mu_{\\text{el}} = 7.680\\,\\text{m}^{-1}$，$\\mu_{\\text{bi}} = 28.80\\,\\text{m}^{-1}$，$\\mu_{\\text{am}} = 57.60\\,\\text{m}^{-1}$，和 $\\mu_{\\text{c}} = 15.36\\,\\text{m}^{-1}$。",
            "answer": "$$\\boxed{\\begin{pmatrix} 7.680  28.80  57.60  15.36 \\end{pmatrix}}$$"
        },
        {
            "introduction": "将重建后的三维体数据分割成不同的材料相（如活性材料、孔隙等）是一项常见且关键的分析任务。但是，我们如何衡量分割结果的优劣呢？本练习  将向你介绍两种标准的评估指标——Dice系数和交并比（IoU），它们提供了一种稳健的定量方法，用于将你的分割结果与“金标准”进行比较，从而严谨地评估其准确性。",
            "id": "3891013",
            "problem": "锂离子电池电极的X射线微计算机断层扫描三维重建可生成用于识别材料相的带标记体素阵列。考虑一个由一组整数三元组索引的离散体素晶格，其中每个体素索引的形式为 $(i,j,k)$，并且 $i,j,k \\in \\mathbb{Z}$ 受阵列边界的约束。每个带标记的体积表示为一个带有相标签的整数数组，其中标签 $0$ 表示背景，标签 $1$ 表示活性材料，标签 $2$ 表示孔隙空间。给定同一晶格的真实标签体积和预测标签体积，对于每个类别 $c \\in \\{1,2\\}$，定义集合 $G_c$ 为真实标签等于 $c$ 的索引集，集合 $P_c$ 为预测标签等于 $c$ 的索引集。使用集合交集、集合并集和集合基数的基本定义，仅基于 $G_c$ 和 $P_c$ 推导出每个类别 $c$ 的分割质量度量 Dice 系数和交并比 (IoU) 的表达式。在 $G_c$ 和 $P_c$ 均为空以及其中只有一个为空的边缘情况下，明确确定并论证这些度量的值。\n\n您的程序必须实现这些推导出的表达式，并为以下带标记体积的测试套件计算这些度量（所有坐标均从零开始，且上界不包含在内）。在每种情况下，预测体积和真实体积都在同一晶格上定义。此任务不需要物理单位。不涉及角度。输出中的任何分数量必须表示为小数。\n\n- A类（一般部分重叠）：体积形状为 $6\\times 6\\times 6$。真实标签 $G$ 包括：\n  - 类别 $1$：所有满足 $2 \\le i  5$，$2 \\le j  5$，$2 \\le k  5$ 的 $(i,j,k)$。\n  - 类别 $2$：所有满足 $0 \\le i  2$，$0 \\le j  2$，$0 \\le k  6$ 的 $(i,j,k)$。\n  预测标签 $P$ 包括：\n  - 类别 $1$：所有满足 $3 \\le i  6$，$2 \\le j  5$，$2 \\le k  5$ 的 $(i,j,k)$。\n  - 类别 $2$：所有满足 $0 \\le i  2$，$0 \\le j  2$，$0 \\le k  3$ 的 $(i,j,k)$。\n\n- B类（完美分割）：体积形状为 $5\\times 5\\times 5$。真实标签 $G$ 包括：\n  - 类别 $1$：所有满足 $1 \\le i  4$，$1 \\le j  4$，$1 \\le k  4$ 的 $(i,j,k)$。\n  - 类别 $2$：所有满足 $0 \\le i  1$，$0 \\le j  1$，$0 \\le k  1$ 的 $(i,j,k)$。\n  预测标签 $P$ 与 $G$ 完全相同。\n\n- C类（错位类别和缺失类别）：体积形状为 $4\\times 4\\times 4$。真实标签 $G$ 包括：\n  - 类别 $1$：所有满足 $0 \\le i  2$，$0 \\le j  4$，$0 \\le k  4$ 的 $(i,j,k)$。\n  - 类别 $2$：无体素。\n  预测标签 $P$ 包括：\n  - 类别 $1$：所有满足 $2 \\le i  4$，$0 \\le j  4$，$0 \\le k  4$ 的 $(i,j,k)$。\n  - 类别 $2$：无体素。\n\n您的程序应针对每种情况计算类别 1 和类别 2 的 Dice 系数和 IoU，并遵循以下从第一性原理推导出的边缘情况约定：\n- 如果 $G_c$ 和 $P_c$ 均为空，则两个度量值必须为 $1$。\n- 如果 $G_c$ 或 $P_c$ 中只有一个为空，则两个度量值必须为 $0$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个案例贡献一个包含四个十进制数的列表，顺序为 $[\\text{Dice}_{1},\\text{IoU}_{1},\\text{Dice}_{2},\\text{IoU}_{2}]$。例如，最终输出应类似于 $[[d_{A1},u_{A1},d_{A2},u_{A2}],[d_{B1},u_{B1},d_{B2},u_{B2}],[d_{C1},u_{C1},d_{C2},u_{C2}]]$，其中 $d$ 和 $u$ 分别表示指定案例和类别的 Dice 系数和 IoU。",
            "solution": "该问题是有效的，因为它具有科学依据、适定且客观。它基于材料科学中三维图像分析的标准实践，特别是电池电极微观结构分割质量的评估。所提供的数据和定义是完整、一致的，并允许一个唯一、可验证的解。要求推导和论证分割度量及其边缘情况行为是一个标准且定义明确的学术问题。\n\n解决方案需要推导和实现两种常见的分割度量：Dice系数和交并比（IoU），后者也称为Jaccard指数。这些度量用于量化预测分割与真实分割之间的空间重叠。\n\n设 $c$ 为类别索引，其中 $c \\in \\{1, 2\\}$ 分别对应活性材料和孔隙空间。在真实体积中属于类别 $c$ 的体素索引集表示为 $G_c$，在预测体积中的相应集合表示为 $P_c$。这些度量的基本量是这些集合及其交集的基数（即体素的数量）。令 $|S|$ 表示集合 $S$ 的基数。关键的基数有：\n- $|G_c|$：类别 $c$ 在真实标签中的体素数量。\n- $|P_c|$：类别 $c$ 在预测结果中的体素数量。\n- $|G_c \\cap P_c|$：被正确预测为类别 $c$ 的体素数量（交集）。\n\n**交并比（IoU或Jaccard指数）**\nIoU 定义为两个集合交集的大小与并集大小的比率。\n$$\n\\text{IoU}_c = \\frac{|G_c \\cap P_c|}{|G_c \\cup P_c|}\n$$\n使用集合基数的容斥原理，并集可以表示为 $|G_c \\cup P_c| = |G_c| + |P_c| - |G_c \\cap P_c|$。将此代入 IoU 定义，得到计算公式：\n$$\n\\text{IoU}_c = \\frac{|G_c \\cap P_c|}{|G_c| + |P_c| - |G_c \\cap P_c|}\n$$\n\n**Dice系数（Sørensen-Dice系数）**\nDice系数定义为交集大小的两倍除以两个集合大小之和。\n$$\n\\text{Dice}_c = \\frac{2 |G_c \\cap P_c|}{|G_c| + |P_c|}\n$$\nDice系数与IoU相关，可表示为 $\\text{Dice} = 2 \\cdot \\text{IoU} / (1 + \\text{IoU})$。两种度量的取值范围均为 $0$（无重叠）到 $1$（完全重叠）。\n\n**边缘情况分析**\n问题的关键部分是确定并论证在其中一个或两个集合为空的边缘情况下度量的值。\n\n1.  **情况1：两个集合均为空（$G_c = \\emptyset$ 且 $P_c = \\emptyset$）**\n    在这种情况下， $|G_c| = 0$，$|P_c| = 0$，因此 $|G_c \\cap P_c| = 0$。将这些值代入公式得出：\n    $$\n    \\text{IoU}_c = \\frac{0}{0 + 0 - 0} = \\frac{0}{0}\n    \\quad \\text{和} \\quad\n    \\text{Dice}_c = \\frac{2 \\cdot 0}{0 + 0} = \\frac{0}{0}\n    $$\n    这两个表达式在数学上是不确定的。然而，在分割的背景下，这种情况表示算法正确地识别出体积中类别 $c$ 的缺失。这是对此类别的一个“完美”预测。因此，根据惯例和合理推断，我们为这两个度量赋予最大分值 $1$。这反映了真实标签与预测之间的完美一致性（两者都同意没有需要分割的对象）。因此，如果 $|G_c| = 0$ 且 $|P_c| = 0$，则 $\\text{IoU}_c = 1$ 且 $\\text{Dice}_c = 1$。\n\n2.  **情况2：只有一个集合为空（例如，$G_c \\neq \\emptyset$ 且 $P_c = \\emptyset$）**\n    在这种情况下， $|G_c| > 0$ 且 $|P_c| = 0$。交集必定为空，所以 $|G_c \\cap P_c| = 0$。公式变为：\n    $$\n    \\text{IoU}_c = \\frac{0}{|G_c| + 0 - 0} = \\frac{0}{|G_c|} = 0\n    $$\n    $$\n    \\text{Dice}_c = \\frac{2 \\cdot 0}{|G_c| + 0} = \\frac{0}{|G_c|} = 0\n    $$\n    类似地，如果 $G_c = \\emptyset$ 且 $P_c \\neq \\emptyset$，则 $|G_c| = 0$，$|P_c| > 0$，且 $|G_c \\cap P_c| = 0$。\n    $$\n    \\text{IoU}_c = \\frac{0}{0 + |P_c| - 0} = \\frac{0}{|P_c|} = 0\n    $$\n    $$\n    \\text{Dice}_c = \\frac{2 \\cdot 0}{0 + |P_c|} = \\frac{0}{|P_c|} = 0\n    $$\n    在这两种子情况下，结果都明确为 $0$。这是合理的，因为预测与真实标签之间完全没有重叠，代表了最差的分割结果（完全漏检或完全误报）。因此，如果一个集合为空而另一个不为空，则 $\\text{IoU}_c = 0$ 且 $\\text{Dice}_c = 0$。\n\n这些推导出的表达式和论证过的边缘情况约定将被实现以解决这些测试案例。由于所有几何区域都是长方体，它们的基数可以直接从其按坐标的维度计算得出，而无需在内存中实例化完整的体素集。",
            "answer": "```python\nimport numpy as np\nfrom scipy import __version__ as scipy_version  # Not used, but required by some test harnesses.\n\ndef solve():\n    \"\"\"\n    Solves the segmentation metric calculation problem for the given test suite.\n    \"\"\"\n\n    def calculate_volume(ranges):\n        \"\"\"Calculates the volume of a rectangular prism defined by coordinate ranges.\"\"\"\n        if ranges is None:\n            return 0\n        \n        volume = 1\n        for r in ranges:\n            # A range [min, max) has length (max - min)\n            length = r[1] - r[0]\n            if length  0:\n                # Should not happen with well-formed ranges, but as a safeguard.\n                return 0\n            volume *= length\n        return volume\n\n    def calculate_intersection_volume(ranges1, ranges2):\n        \"\"\"Calculates the volume of the intersection of two rectangular prisms.\"\"\"\n        if ranges1 is None or ranges2 is None:\n            return 0\n        \n        intersect_ranges = []\n        for r1, r2 in zip(ranges1, ranges2):\n            intersect_min = max(r1[0], r2[0])\n            intersect_max = min(r1[1], r2[1])\n            if intersect_min >= intersect_max:\n                # The intersection is empty along this dimension.\n                return 0\n            intersect_ranges.append((intersect_min, intersect_max))\n\n        return calculate_volume(tuple(intersect_ranges))\n\n    def compute_metrics(card_G, card_P, card_intersect):\n        \"\"\"Computes Dice and IoU from cardinalities, handling edge cases.\"\"\"\n        # Case 1: Both sets are empty. Perfect prediction of absence.\n        if card_G == 0 and card_P == 0:\n            return 1.0, 1.0\n        \n        # Case 2: Exactly one set is empty. No overlap.\n        # This also covers the case where the sets are non-empty but disjoint (card_intersect == 0).\n        if card_intersect == 0:\n            return 0.0, 0.0\n\n        # General case\n        dice = (2.0 * card_intersect) / (card_G + card_P)\n        iou = card_intersect / (card_G + card_P - card_intersect)\n        \n        return dice, iou\n\n    # Test suite definition\n    # Structure: [ ( (G1_ranges, P1_ranges), (G2_ranges, P2_ranges) ), ... ]\n    # A range is ((i_min, i_max), (j_min, j_max), (k_min, k_max))\n    # None represents an empty set of voxels.\n    test_cases = [\n        # Case A: General partial overlap\n        (\n            (((2, 5), (2, 5), (2, 5)), ((3, 6), (2, 5), (2, 5))), # Class 1\n            (((0, 2), (0, 2), (0, 6)), ((0, 2), (0, 2), (0, 3)))  # Class 2\n        ),\n        # Case B: Perfect segmentation\n        (\n            (((1, 4), (1, 4), (1, 4)), ((1, 4), (1, 4), (1, 4))), # Class 1\n            (((0, 1), (0, 1), (0, 1)), ((0, 1), (0, 1), (0, 1)))  # Class 2\n        ),\n        # Case C: Misaligned class and absent class\n        (\n            (((0, 2), (0, 4), (0, 4)), ((2, 4), (0, 4), (0, 4))), # Class 1\n            (None, None)                                          # Class 2\n        ),\n    ]\n\n    all_results = []\n    for case_data in test_cases:\n        case_results = []\n        # class_data contains (G_ranges, P_ranges)\n        for class_data in case_data:\n            G_ranges, P_ranges = class_data\n            \n            card_G = calculate_volume(G_ranges)\n            card_P = calculate_volume(P_ranges)\n            card_intersect = calculate_intersection_volume(G_ranges, P_ranges)\n            \n            dice, iou = compute_metrics(card_G, card_P, card_intersect)\n            \n            case_results.extend([dice, iou])\n        all_results.append(case_results)\n\n    # Format the output string as per the requirement: [[d,u,d,u],[d,u,d,u],...]\n    case_strings = []\n    for res_list in all_results:\n        # Convert each float in the list to its string representation\n        # and join them with commas.\n        case_strings.append(f\"[{','.join(map(str, res_list))}]\")\n    \n    final_output = f\"[{','.join(case_strings)}]\"\n    print(final_output)\n\nsolve()\n```"
        }
    ]
}