{
    "hands_on_practices": [
        {
            "introduction": "在我们能够为特定目标属性反向设计微观结构之前，我们必须首先掌握一项基本技能：准确地从给定的微观结构中预测其宏观属性。这个“正向问题”是所有设计和优化的基础。本练习  将指导您实现一个有限体积法 (FVM) 求解器，用于计算非均质材料的有效电导率 $K^{\\text{eff}}$，这是一个关键的输运性质。通过亲手构建这个计算工具，您将深入理解微观结构细节如何决定材料的宏观功能，并为更复杂的逆向设计挑战奠定坚实的计算基础。",
            "id": "3921852",
            "problem": "给定一个在 $N \\times N$ 方形网格上表示的二维体素化微结构，该网格覆盖一个边长为 $L_x = L_y = 1\\,\\mathrm{m}$ 的单位正方形域。每个体素（单元）具有一个局域标量电导率 $k(\\mathbf{x})$（单位为 $\\mathrm{S/m}$），对应于两相中的一相。在沿 $x$ 方向施加电势差 $\\Delta \\phi = 1\\,\\mathrm{V}$ 的稳态直流传导条件下，且沿 $y$ 方向为零通量（诺伊曼）边界条件，其控制方程为电流密度守恒和局域线性本构关系，即 $ \\nabla \\cdot \\mathbf{J} = 0$ 和 $\\mathbf{J} = -k(\\mathbf{x}) \\nabla \\phi(\\mathbf{x})$，其中 $ \\phi$ 是电势，$\\mathbf{J}$ 是电流密度。\n\n您的任务是实现有限体积法（FVM）来计算微结构的有效电导率 $K^{\\text{eff}}$（单位为 $\\mathrm{S/m}$），该值由宏观关系式 $I = K^{\\text{eff}} A \\frac{\\Delta \\phi}{L_x}$ 定义，其中 $I$ 是在施加电势差 $\\Delta \\phi$ 时通过左边界的总电流，而 $A$ 是垂直于 $x$ 方向的横截面积。在此二维设置中，将域解释为在平面外方向具有单位厚度，因此 $A = L_y \\times 1 = 1\\,\\mathrm{m}^2$。离散化必须在 $x=0$ 处强制执行狄利克雷边界条件 $\\phi = 0\\,\\mathrm{V}$，在 $x=1$ 处强制执行 $\\phi = 1\\,\\mathrm{V}$，并在 $y=0$ 和 $y=1$ 处强制执行诺伊曼（零通量）边界条件。使用内部面上电导率的调和平均来近似相邻单元之间的通量。\n\n从静电学基本定律和上述定义出发，在尺寸为 $h=1/N$ 的均匀网格上推导并实现一个单元中心有限体积法离散化方案，其中单元中心位于 $(x_i, y_j) = \\left( \\frac{i+1/2}{N}, \\frac{j+1/2}{N} \\right)$，整数索引 $i,j \\in \\{0,\\dots,N-1\\}$。在您的算法中，对于电导率分别为 $k_1$ 和 $k_2$ 的单元之间的内部面，使用调和平均 $k_f = \\left( \\frac{1}{2} \\left( \\frac{1}{k_1} + \\frac{1}{k_2} \\right) \\right)^{-1}$ 来计算面电导。对于 $x=0$ 和 $x=1$ 处的边界，使用半单元距离 $h/2$ 和面面积 $h$ 来施加狄利克雷条件，这导致邻近边界的单元处的边界电导等于 $2\\,k$。在求解离散电势场 $\\phi_{i,j}$ 后，通过对边界通量求和来计算通过左边界的总电流 $I$，然后计算 $K^{\\text{eff}}$（单位为 $\\mathrm{S/m}$）。\n\n此外，通过将计算出的 $K^{\\text{eff}}(h)$ 与在更精细网格（$h_{\\text{ref}} = 1/N_{\\text{ref}}$）上获得的参考解 $K^{\\text{eff}}(h_{\\text{ref}})$ 进行比较，估算离散误差 $\\mathcal{E}(h)$ 作为网格尺寸 $h$ 的函数。报告绝对误差 $\\mathcal{E}(h) = \\left| K^{\\text{eff}}(h) - K^{\\text{eff}}(h_{\\text{ref}})\\right|$（单位为 $\\mathrm{S/m}$）。\n\n定义以下微结构和相电导率的测试套件，每个都将在指定的分辨率下进行采样：\n\n- 测试用例1（理想情况，异质夹杂物）：\n    - 几何形状：以 $(0.5, 0.5)$ 为中心、半径为 $r = 0.3$ 的圆形夹杂物。\n    - 相电导率：夹杂物相 $k_{\\text{in}} = 12.0\\,\\mathrm{S/m}$，基体相 $k_{\\text{out}} = 0.5\\,\\mathrm{S/m}$。\n    - 分辨率：$N \\in \\{16, 32, 64\\}$ 和参考分辨率 $N_{\\text{ref}} = 128$。\n\n- 测试用例2（高电导率条带，近逾渗边缘）：\n    - 几何形状：横跨整个高度的垂直条带，其中 $x \\in [0.4, 0.6]$。\n    - 相电导率：条带相 $k_{\\text{stripe}} = 50.0\\,\\mathrm{S/m}$，基体相 $k_{\\text{matrix}} = 1.0\\,\\mathrm{S/m}$。\n    - 分辨率：$N \\in \\{16, 32, 64\\}$ 和参考分辨率 $N_{\\text{ref}} = 128$。\n\n- 测试用例3（均匀介质，验证边界情况）：\n    - 几何形状：整个区域为单相。\n    - 相电导率：均匀电导率 $k_{\\text{uni}} = 3.0\\,\\mathrm{S/m}$。\n    - 分辨率：$N \\in \\{8, 16, 32\\}$ 和参考分辨率 $N_{\\text{ref}} = 128$。\n\n对于每个测试用例，通过在单元中心采样解析微结构定义来构建 $k(\\mathbf{x})$。为每个 $N$ 计算 $K^{\\text{eff}}(h)$ 和参考值 $K^{\\text{eff}}(h_{\\text{ref}})$，然后为每个 $N$ 计算误差 $\\mathcal{E}(h)$。\n\n最终所需的输出格式如下：您的程序应生成一行输出，其中包含一个结果列表，每个测试用例一个结果，其中每个测试用例的结果是一个浮点数列表（单位为 $\\mathrm{S/m}$），按 $[K^{\\text{eff}}(h_{\\text{ref}}), K^{\\text{eff}}(h_1), \\mathcal{E}(h_1), K^{\\text{eff}}(h_2), \\mathcal{E}(h_2), K^{\\text{eff}}(h_3), \\mathcal{E}(h_3)]$ 的顺序排列。例如，整体输出应类似于 $[[\\dots],[\\dots],[\\dots]]$，所有浮点数均以 $\\mathrm{S/m}$ 表示，且无附加文本。\n\n您的程序必须是自包含的，无需输入，并遵守指定的执行环境。所有 $K^{\\text{eff}}$ 和 $\\mathcal{E}(h)$ 的计算和报告值必须以 $\\mathrm{S/m}$ 为单位，并表示为十进制浮点数。",
            "solution": "该问题根据指定标准进行验证。\n\n### 步骤1：提取已知条件\n- **控制物理**：稳态直流传导，由电流密度守恒定律 $\\nabla \\cdot \\mathbf{J} = 0$ 和线性本构关系（欧姆定律）$\\mathbf{J} = -k(\\mathbf{x}) \\nabla \\phi(\\mathbf{x})$ 描述，其中 $\\phi$ 是电势，$\\mathbf{J}$ 是电流密度，$k(\\mathbf{x})$ 是局域标量电导率（单位 $\\mathrm{S/m}$）。\n- **区域**：一个二维单位正方形，$L_x = L_y = 1\\,\\mathrm{m}$，具有单位厚度。横截面积为 $A = L_y \\times 1 = 1\\,\\mathrm{m}^2$。\n- **边界条件 (BCs)**：\n    - 垂直边界上的狄利克雷边界条件：$\\phi(x=0) = 0\\,\\mathrm{V}$ 和 $\\phi(x=1) = 1\\,\\mathrm{V}$。施加的电势差为 $\\Delta \\phi = 1\\,\\mathrm{V}$。\n    - 水平边界上的诺伊曼边界条件：零通量，即在 $y=0$ 和 $y=1$ 处 $\\frac{\\partial \\phi}{\\partial y} = 0$。\n- **离散化**：在均匀的 $N \\times N$ 网格上采用单元中心有限体积法（FVM）。网格尺寸为 $h = 1/N$。单元中心位于 $(x_i, y_j) = \\left( \\frac{i+1/2}{N}, \\frac{j+1/2}{N} \\right)$，其中 $i,j \\in \\{0, \\dots, N-1\\}$。\n- **通量近似**：\n    - 对于电导率分别为 $k_1$ 和 $k_2$ 的单元之间的内部面，面电导率 $k_f$ 为调和平均值：$k_f = \\left( \\frac{1}{2} \\left( \\frac{1}{k_1} + \\frac{1}{k_2} \\right) \\right)^{-1}$。\n    - 对于狄利克雷边界面，规定面电导为 $2k$，其中 $k$ 是邻近边界单元的电导率。\n- **待求量**：有效电导率 $K^{\\text{eff}}$（单位 $\\mathrm{S/m}$），由宏观关系式 $I = K^{\\text{eff}} A \\frac{\\Delta \\phi}{L_x}$ 定义，其中 $I$ 是总电流。\n- **误差估计**：绝对误差 $\\mathcal{E}(h) = \\left| K^{\\text{eff}}(h) - K^{\\text{eff}}(h_{\\text{ref}})\\right|$ 将相对于在更精细网格（$h_{\\text{ref}}=1/N_{\\text{ref}}$）上获得的参考解来计算。\n- **测试用例**：定义了三种不同的异质微结构，具有特定的几何形状、相电导率和分辨率以供分析。\n\n### 步骤2：使用提取的已知条件进行验证\n- **科学依据**：该问题在基础上是合理的。它描述了异质介质中的稳态电传导，这是一个经典的椭圆边值问题，由方程 $\\nabla \\cdot (k(\\mathbf{x}) \\nabla \\phi(\\mathbf{x})) = 0$ 控制。FVM 是解决此类问题的标准且稳健的数值方法。使用调和平均计算电导率是一种物理上合适的选择，可确保电流密度法向分量在单元界面上的连续性。\n- **良定性**：该问题是良定的。在封闭域上结合狄利克雷和诺伊曼边界条件，确保了电势场 $\\phi(\\mathbf{x})$ 存在唯一、稳定的解。待求量 $K^{\\text{eff}}$ 由此解唯一确定。\n- **客观性和完整性**：该问题以精确、客观的语言陈述。所有参数、方程、边界条件和数值方案都已明确定义，使得问题自成体系且无歧义。各项定义内部一致。\n- **可行性**：物理参数和计算任务是现实且可行的。\n- **结构**：该问题结构良好，引导用户从第一性原理到数值实现和分析。它并非微不足道，需要对偏微分方程的数值方法进行实质性应用。\n\n### 步骤3：结论与行动\n该问题是**有效的**。现在将推导并实现一个严谨的解法。\n\n### 有限体积法的推导\n\n通过结合守恒定律和本构关系，得到控制偏微分方程：\n$$\n\\nabla \\cdot (-k(\\mathbf{x}) \\nabla \\phi(\\mathbf{x})) = 0\n$$\n我们采用单元中心有限体积法。我们将控制方程在一个控制体积 $\\Omega_{i,j}$ 上积分，该控制体积对应于以 $(x_i, y_j)$ 为中心的单元：\n$$\n\\int_{\\Omega_{i,j}} \\nabla \\cdot (-k \\nabla \\phi) \\, dV = 0\n$$\n应用散度定理，我们将体积分转换为控制体积边界 $\\partial\\Omega_{i,j}$ 上的面积分：\n$$\n\\oint_{\\partial\\Omega_{i,j}} (-k \\nabla \\phi) \\cdot \\mathbf{n} \\, dS = 0\n$$\n该方程表示电流守恒：流出任何控制体积的净电流为零。对于边长为 $h=1/N$ 且单位厚度的二维方形单元，该积分变为四个面（东、西、南、北）上的电流之和：\n$$\nI_e + I_w + I_n + I_s = 0\n$$\n其中 $I_f$ 是流出面 $f$ 的总电流。通过一个面的电流使用电势梯度的有限差分来近似。对于分隔单元 $(i,j)$ 和单元 $(i+1,j)$ 的东面，电流为：\n$$\nI_e = -k_e A_e \\frac{\\phi_{i+1,j} - \\phi_{i,j}}{h}\n$$\n其中 $A_e = h \\times 1 = h$ 是面面积。面电导率 $k_e$ 是相邻单元电导率 $k_{i,j}$ 和 $k_{i+1,j}$ 的调和平均值：\n$$\nk_e = \\frac{2 k_{i,j} k_{i+1,j}}{k_{i,j} + k_{i+1,j}}\n$$\n我们定义面电导为 $g_f = k_f A_f / \\delta$，其中 $\\delta$ 是单元中心之间的距离。对于内部面，$\\delta=h$ 且 $A_f=h$，因此电导就是 $g_f=k_f$。一个内部单元 $(i,j)$ 四个面上的电流为：\n- $I_e = g_e (\\phi_{i,j} - \\phi_{i+1,j})$\n- $I_w = g_w (\\phi_{i,j} - \\phi_{i-1,j})$\n- $I_n = g_n (\\phi_{i,j} - \\phi_{i,j+1})$\n- $I_s = g_s (\\phi_{i,j} - \\phi_{i,j-1})$\n\n将这些代入守恒方程，得到内部单元 $(i,j)$ 的离散代数方程：\n$$\n(g_e + g_w + g_n + g_s)\\phi_{i,j} - g_e \\phi_{i+1,j} - g_w \\phi_{i-1,j} - g_n \\phi_{i,j+1} - g_s \\phi_{i,j-1} = 0\n$$\n\n**边界条件：**\n1.  **$y=0$ 和 $y=1$ 处的诺伊曼（零通量）条件**：对于底部边界上的单元（$j=0$），通过南面的通量为零，因此 $I_s=0$，这意味着 $g_s=0$。类似地，对于顶部边界上的单元（$j=N-1$），$I_n=0$ 因而 $g_n=0$。\n\n2.  **$x=0$ 和 $x=1$ 处的狄利克雷（固定电势）条件**：对于左边界上的单元 $(0,j)$，电势固定为 $\\phi(x=0) = \\phi_L = 0\\,\\mathrm{V}$。从单元中心到边界的距离是 $h/2$。从边界流入单元的电流近似为：\n    $$\n    I_w = -k_{0,j} A_w \\frac{\\phi_{0,j} - \\phi_L}{h/2} = -k_{0,j} h \\frac{\\phi_{0,j} - 0}{h/2} = -2 k_{0,j} \\phi_{0,j}\n    $$\n    相应的西向电导为 $g_w = 2k_{0,j}$。单元 $(0,j)$ 的方程包含这个已知的边界电势，其值为零。\n    对于右边界上的单元 $(N-1,j)$，电势固定为 $\\phi(x=1) = \\phi_R = 1\\,\\mathrm{V}$。类似地，东向电导为 $g_e = 2k_{N-1,j}$。流向边界的电流为 $I_e = g_e(\\phi_{N-1,j} - \\phi_R)$。单元 $(N-1,j)$ 的方程变为：\n    $$\n    (g_e + g_w + g_n + g_s)\\phi_{N-1,j} - g_w \\phi_{N-2,j} - g_n \\phi_{N-1,j+1} - g_s \\phi_{N-1,j-1} = g_e \\phi_R = g_e\n    $$\n    这在线性系统的右侧引入了一个非零源项。\n\n**方程组与求解：**\n将所有 $N \\times N$ 个单元的方程组合起来，得到一个大型稀疏线性方程组 $M\\mathbf{\\Phi} = \\mathbf{b}$，其中 $\\mathbf{\\Phi}$ 是未知单元电势 $\\phi_{i,j}$ 的向量。矩阵 $M$ 是对角占优且对称的，保证了唯一解的存在。我们构建 $M$ 和 $\\mathbf{b}$，并使用稀疏线性代数求解器求解 $\\mathbf{\\Phi}$。\n\n**有效电导率 $K^{\\text{eff}}$ 的计算：**\n在求解电势场 $\\mathbf{\\Phi}$ 后，我们计算流经区域的总电流 $I$。根据守恒定律，在 $x=0$ 处进入的电流等于在 $x=1$ 处流出的电流。我们计算通过右边界流出的总电流：\n$$\nI = \\sum_{j=0}^{N-1} I_{e,j} = \\sum_{j=0}^{N-1} g_{e,j} (\\phi_R - \\phi_{N-1,j}) = \\sum_{j=0}^{N-1} 2 k_{N-1,j} (1 - \\phi_{N-1,j})\n$$\n问题通过 $I = K^{\\text{eff}} A \\frac{\\Delta \\phi}{L_x}$ 定义 $K^{\\text{eff}}$。给定 $A=1\\,\\mathrm{m}^2$、$L_x=1\\,\\mathrm{m}$ 和 $\\Delta\\phi=1\\,\\mathrm{V}$，这简化为 $K^{\\text{eff}} = I$。因此，有效电导率在数值上等于上面计算的总电流。对于电导率为 $k_{\\text{uni}}$ 的均匀介质，解析解为 $\\phi(x)=x$，我们的FVM方案能精确地恢复 $K^{\\text{eff}} = k_{\\text{uni}}$，这可作为对该方法的有力验证。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import lil_matrix\nfrom scipy.sparse.linalg import spsolve\n\ndef generate_k_map(N, case_params):\n    \"\"\"\n    Generates the conductivity map k(x, y) for a given microstructure.\n    \"\"\"\n    h = 1.0 / N\n    x = np.linspace(h / 2, 1.0 - h / 2, N)\n    y = np.linspace(h / 2, 1.0 - h / 2, N)\n    xx, yy = np.meshgrid(x, y)\n\n    case_type = case_params['type']\n    \n    if case_type == 'circle':\n        k_in = case_params['k_in']\n        k_out = case_params['k_out']\n        center = case_params['center']\n        radius = case_params['radius']\n        mask = (xx - center[0])**2 + (yy - center[1])**2 = radius**2\n        k_map = np.full((N, N), k_out)\n        k_map[mask] = k_in\n    elif case_type == 'stripe':\n        k_stripe = case_params['k_stripe']\n        k_matrix = case_params['k_matrix']\n        x_range = case_params['x_range']\n        mask = (xx >= x_range[0])  (xx = x_range[1])\n        k_map = np.full((N, N), k_matrix)\n        k_map[mask] = k_stripe\n    elif case_type == 'uniform':\n        k_uni = case_params['k_uni']\n        k_map = np.full((N, N), k_uni)\n    else:\n        raise ValueError(\"Unknown case type\")\n        \n    return k_map\n\ndef compute_Keff(N, k_map):\n    \"\"\"\n    Computes the effective conductivity of a microstructure using FVM.\n    \"\"\"\n    num_vars = N * N\n    M = lil_matrix((num_vars, num_vars))\n    b = np.zeros(num_vars)\n\n    # Flatten conductivity map for easier indexing\n    k_flat = k_map.flatten(order='C') # Row-major\n\n    for j in range(N):\n        for i in range(N):\n            p = j * N + i  # Linear index for cell (i, j)\n            k_center = k_map[j, i]\n            \n            # Diagonal term accumulator\n            diag_sum = 0.0\n            \n            # South neighbor (j-1)\n            if j > 0:\n                k_s = k_map[j-1, i]\n                g_s = (2.0 * k_center * k_s) / (k_center + k_s)\n                M[p, p - N] = -g_s\n                diag_sum += g_s\n            # else: no-flux (gs=0)\n            \n            # North neighbor (j+1)\n            if j  N - 1:\n                k_n = k_map[j+1, i]\n                g_n = (2.0 * k_center * k_n) / (k_center + k_n)\n                M[p, p + N] = -g_n\n                diag_sum += g_n\n            # else: no-flux (gn=0)\n            \n            # West neighbor (i-1)\n            if i > 0:\n                k_w = k_map[j, i-1]\n                g_w = (2.0 * k_center * k_w) / (k_center + k_w)\n                M[p, p - 1] = -g_w\n                diag_sum += g_w\n            else: # i=0, Dirichlet boundary phi=0\n                g_w = 2.0 * k_center\n                diag_sum += g_w\n                # Source term is g_w * phi_L = g_w * 0 = 0\n            \n            # East neighbor (i+1)\n            if i  N - 1:\n                k_e = k_map[j, i+1]\n                g_e = (2.0 * k_center * k_e) / (k_center + k_e)\n                M[p, p + 1] = -g_e\n                diag_sum += g_e\n            else: # i=N-1, Dirichlet boundary phi=1\n                g_e = 2.0 * k_center\n                diag_sum += g_e\n                b[p] = -g_e * 1.0\n            \n            M[p, p] = diag_sum\n\n    # Solve the linear system\n    M_csc = M.tocsc()\n    phi_vec = spsolve(M_csc, b)\n    phi_map = phi_vec.reshape((N, N))\n\n    # Calculate total current and K_eff\n    k_right_boundary = k_map[:, N-1]\n    phi_right_boundary = phi_map[:, N-1]\n    \n    # I = sum(g_e * (phi_R - phi_cell)) = sum(2*k * (1 - phi))\n    # With L=1, A=1, dPhi=1, K_eff = I\n    K_eff = np.sum(2.0 * k_right_boundary * (1.0 - phi_right_boundary))\n    \n    return K_eff\n\ndef solve():\n    test_suite = [\n        {\n            'params': {'type': 'circle', 'k_in': 12.0, 'k_out': 0.5, 'center': (0.5, 0.5), 'radius': 0.3},\n            'resolutions': [16, 32, 64],\n            'ref_resolution': 128\n        },\n        {\n            'params': {'type': 'stripe', 'k_stripe': 50.0, 'k_matrix': 1.0, 'x_range': [0.4, 0.6]},\n            'resolutions': [16, 32, 64],\n            'ref_resolution': 128\n        },\n        {\n            'params': {'type': 'uniform', 'k_uni': 3.0},\n            'resolutions': [8, 16, 32],\n            'ref_resolution': 128\n        }\n    ]\n\n    all_results = []\n\n    for test_case in test_suite:\n        params = test_case['params']\n        resolutions = test_case['resolutions']\n        N_ref = test_case['ref_resolution']\n        \n        # Compute reference solution\n        k_map_ref = generate_k_map(N_ref, params)\n        K_eff_ref = compute_Keff(N_ref, k_map_ref)\n        \n        case_results = [K_eff_ref]\n        \n        # Compute for other resolutions and calculate errors\n        for N in resolutions:\n            k_map = generate_k_map(N, params)\n            K_eff = compute_Keff(N, k_map)\n            error = abs(K_eff - K_eff_ref)\n            case_results.extend([K_eff, error])\n            \n        all_results.append(case_results)\n\n    # Format output as a list of lists of floats\n    print(all_results)\n\nsolve()\n```"
        },
        {
            "introduction": "在材料设计中，仅仅获得一个理想的属性值往往是不够的；我们还需要确保设计的可靠性。许多关键功能，例如电池电极的导电性，依赖于导电相形成一个贯穿整个体系的连接网络，即“逾渗”。本练习  运用逾渗理论和有限尺寸标度律，构建一个物理模型来估算在给定的相分数 $\\phi$ 和相关长度 $\\ell_c$ 下，一个微观结构样本包含贯穿簇的概率 $P_{\\mathrm{span}}$。通过这个实践，您将学习如何将抽象的物理理论转化为评估设计方案稳健性的实用工具，从而在不确定性中做出更明智的设计决策。",
            "id": "3921894",
            "problem": "您的任务是设计一个确定性程序，用于估算一个随机放置的立方体代表性体积单元（RVE）包含目标相的贯穿簇的概率。该程序需要给定相分数和表征微观结构中空间相关性的相关长度。该问题的背景是自动化电池设计与仿真，其中导电相的逾渗行为决定了其有效输运性质。目标是计算一个物理上有意义的贯穿概率近似值，该近似值严格遵循逾渗理论和有限尺寸标度，并利用此近似值分析逆向设计决策的可靠性。\n\n出发点和基本依据：使用以下来自逾渗理论和统计物理学的、经过充分检验的基础理论。\n- 在尺寸为 $L$ 的有限系统中，存在贯穿簇的概率由有限尺寸标度控制，并且是单个标度变量的普适函数，该标度变量源于系统相分数与临界相分数的偏差以及系统尺寸。\n- 对于三维逾渗，相关长度指数为 $\\nu \\approx 0.876$，意味着在热力学极限下，相关长度 $\\xi$ 随着 $\\lvert \\phi - \\phi_c \\rvert^{-\\nu}$ 发散。\n- 具有特征长度为 $\\ell_c$ 的正空间相关性的真实微观结构，相对于无限系统逾渗阈值，会表现出一个重整化的有效阈值。\n\n定义：\n- 令 $L$ 表示立方体 RVE 的边长（单位：$\\mu$m）。\n- 令 $\\phi \\in [0,1]$ 表示目标相的体积分数（无量纲）。\n- 令 $\\ell_c$ 表示微观结构相关长度（单位：$\\mu$m）。\n- 令 $\\phi_c^\\infty$ 表示三维格点逾渗的无限系统逾渗阈值，使用 $\\phi_c^\\infty = 0.3116$。\n- 令 $\\nu$ 表示三维相关长度指数，使用 $\\nu = 0.876$。\n\n需要实现的建模要求：\n- 构建一个有效阈值 $\\phi_c^{\\mathrm{eff}}$，该阈值通过一阶粗粒化校正来考虑有限相关长度 $\\ell_c$ 相对于域尺寸 $L$ 的影响。在存在正相关的情况下，该校正会降低阈值。具体定义为\n$$\n\\phi_c^{\\mathrm{eff}} = \\mathrm{clip}\\Big(\\phi_c^\\infty - \\kappa \\left(\\frac{\\ell_c}{L}\\right)^\\alpha,\\,0,\\,1\\Big),\n$$\n其中常数固定为 $\\kappa = 0.15$ 和 $\\alpha = 1.0$，且 $\\mathrm{clip}(x,0,1)$ 将值截断到区间 $[0,1]$ 内。\n- 定义有限尺寸标度变量\n$$\nx = \\left(\\phi - \\phi_c^{\\mathrm{eff}}\\right)\\, L^{1/\\nu}.\n$$\n- 使用一个以 $x=0$ 为中心、单位宽度的平滑、单调的 S 型函数（sigmoid function）将 $x$ 映射到贯穿概率，这与广延量（extensive quantities）的中心极限定理类型的涨落相符。实现\n$$\nP_{\\mathrm{span}} = \\frac{1}{2}\\left[1 + \\operatorname{erf}\\left(\\frac{x}{\\sqrt{2}\\,\\sigma}\\right)\\right],\n$$\n其中 $\\sigma = 1.0$，并将最终概率截断到区间 $[0,1]$ 内。强制执行边界条件：若 $\\phi \\le 0$，则 $P_{\\mathrm{span}}=0$；若 $\\phi \\ge 1$，则 $P_{\\mathrm{span}}=1$。\n- 所有量纲均保持一致：$L$ 和 $\\ell_c$ 的单位为 $\\mu$m，$\\phi$ 和 $P_{\\mathrm{span}}$ 为无量纲。\n\n实现任务：\n- 编写一个程序，对每个测试用例，使用上述步骤计算 $P_{\\mathrm{span}}$ 并返回一个确定性结果。将每个概率值四舍五入到 $6$ 位小数。\n\n测试套件：\n计算以下参数集 $(L,\\ell_c,\\phi)$ 的概率，其中 $L$ 和 $\\ell_c$ 的单位为 $\\mu$m，$\\phi$ 为无量纲：\n- 情况 1：$(50.0, 5.0, 0.35)$，一个高于无限阈值且具有中等相关性的常规“理想路径”。\n- 情况 2：$(50.0, 1.0, 0.3116)$，接近无限阈值且具有弱相关性。\n- 情况 3：$(50.0, 2.0, 0.25)$，低于阈值。\n- 情况 4：$(20.0, 20.0, 0.30)$，强相关性，其相关长度与域尺寸相当。\n- 情况 5：$(5.0, 2.0, 0.30)$，RVE 尺寸较小。\n- 情况 6：$(50.0, 5.0, 0.0)$，退化的下边界。\n- 情况 7：$(50.0, 5.0, 1.0)$，退化的上边界。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含测试套件的结果。结果是一个用方括号括起来的、以逗号分隔的浮点数列表，顺序与测试用例相同，每个值都四舍五入到 6 位小数（例如 $[p_1,p_2,\\dots,p_7]$）。不应打印任何其他文本。\n\n交付物：\n- 最终答案必须是一个完整的、可在 Python 中运行的程序，且符合指定的环境和库要求。",
            "solution": "该问题是有效的，因为它在科学上基于逾渗理论，提法明确，具有清晰的计算步骤，并且陈述客观。该问题提出了一个唯象上合理（尽管是简化的）模型，用于估算具有空间相关性的有限尺寸微观结构中的贯穿概率。所提供的常数和函数形式与统计物理学中有限尺寸标度的既定原理相符。\n\n解决方案是所提供模型的直接实现。对于给定的一组参数——RVE 边长 $L$、微观结构相关长度 $\\ell_c$ 和目标相体积分数 $\\phi$——贯穿概率 $P_{\\mathrm{span}}$ 的计算是基于有限尺寸标度原理，通过一个确定性的三步计算过程完成的。\n\n首先，我们计算有效逾渗阈值 $\\phi_c^{\\mathrm{eff}}$，它通过调整无限系统阈值 $\\phi_c^\\infty$ 来考虑有限系统尺寸和空间相关性的影响。问题指定了一阶粗粒化校正。以长度 $\\ell_c$ 为特征的正空间相关性意味着被占据的格点倾向于聚集，这有助于形成贯穿路径。这种效应会降低逾渗阈值。该模型通过将 $\\phi_c^{\\mathrm{eff}}$ 定义为以下形式来捕捉此效应：\n$$\n\\phi_c^{\\mathrm{eff}} = \\mathrm{clip}\\Big(\\phi_c^\\infty - \\kappa \\left(\\frac{\\ell_c}{L}\\right)^\\alpha,\\,0,\\,1\\Big)\n$$\n此处，$\\phi_c^\\infty$ 是已确立的无限系统逾渗阈值，给定为 $0.3116$。校正项 $\\kappa (\\ell_c/L)^\\alpha$ 降低了该阈值，降低的幅度取决于相关长度 $\\ell_c$ 与系统尺寸 $L$ 的比值。提供的常数为 $\\kappa = 0.15$ 和 $\\alpha = 1.0$。$\\mathrm{clip}$ 函数确保所得的有效阈值保持在物理上有意义的区间 $[0, 1]$ 内。\n\n其次，我们计算无量纲标度变量 $x$。在临界现象理论中，相变点附近的物理量并不独立地依赖于各个系统参数，而是通过单个标度变量的普适函数来表达。这个变量 $x$ 量化了与临界点的“距离”，并由系统尺寸 $L$ 进行标度。其定义如下：\n$$\nx = \\left(\\phi - \\phi_c^{\\mathrm{eff}}\\right)\\, L^{1/\\nu}\n$$\n此处，$(\\phi - \\phi_c^{\\mathrm{eff}})$ 是系统相分数与有效临界点的偏差。该偏差由 $L^{1/\\nu}$ 进行标度，其中 $\\nu$ 是相关长度的临界指数，对于三维逾渗，给定值为 $\\nu = 0.876$。正的 $x$ 表示系统处于逾渗区（超临界），而负的 $x$ 表示系统处于非逾渗区（亚临界）。$x=0$ 对应于有限系统的临界点。\n\n第三，我们将标度变量 $x$ 映射到贯穿概率 $P_{\\mathrm{span}}$。在有限系统中，从非逾渗状态到逾渗状态的转变不是一个急剧的过程，而是在以 $\\phi_c^{\\mathrm{eff}}$ 为中心的一系列 $\\phi$ 值范围内发生。这个过渡区域由一个平滑、单调的 S 型函数描述。问题指定使用正态分布的累积分布函数（CDF）来表达，通过误差函数 $\\operatorname{erf}$ 实现：\n$$\nP_{\\mathrm{span}} = \\frac{1}{2}\\left[1 + \\operatorname{erf}\\left(\\frac{x}{\\sqrt{2}\\,\\sigma}\\right)\\right]\n$$\n这种函数形式与中心极限定理应用于临界点附近广延量的涨落是一致的。参数 $\\sigma$ 代表过渡区域的宽度，给定值为 $\\sigma=1.0$。为保证鲁棒性，最终概率被截断到区间 $[0, 1]$ 内，并强制执行显式边界条件：如果 $\\phi \\le 0$，则 $P_{\\mathrm{span}}=0$；如果 $\\phi \\ge 1$，则 $P_{\\mathrm{span}}=1$。\n\n最终的算法包括对测试套件中提供的每组输入参数 $(L, \\ell_c, \\phi)$ 实现这三个步骤，并将结果四舍五入到指定的精度。",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import erf\n\ndef solve():\n    \"\"\"\n    Computes the spanning probability for a set of microstructure parameters\n    based on a finite-size scaling model from percolation theory.\n    \"\"\"\n\n    # Define the constants from the problem statement.\n    PHI_C_INF = 0.3116  # Infinite-system percolation threshold\n    NU = 0.876          # Correlation length exponent\n    KAPPA = 0.15        # Correlation correction coefficient\n    ALPHA = 1.0         # Correlation correction exponent\n    SIGMA = 1.0         # Width of the transition region\n\n    def calculate_p_span(L: float, ell_c: float, phi: float) -> float:\n        \"\"\"\n        Calculates the spanning probability for a single case.\n\n        Args:\n            L: RVE edge length (microns).\n            ell_c: Microstructure correlation length (microns).\n            phi: Target-phase volume fraction (dimensionless).\n\n        Returns:\n            The calculated spanning probability P_span, a float between 0 and 1.\n        \"\"\"\n        # Enforce the boundary conditions on the phase fraction phi.\n        if phi = 0.0:\n            return 0.0\n        if phi >= 1.0:\n            return 1.0\n\n        # Step 1: Calculate the effective percolation threshold phi_c_eff.\n        # The correction term accounts for positive spatial correlations.\n        correction = KAPPA * (ell_c / L)**ALPHA\n        phi_c_eff_raw = PHI_C_INF - correction\n        # Clip the result to the physically valid interval [0, 1].\n        phi_c_eff = np.clip(phi_c_eff_raw, 0.0, 1.0)\n\n        # Step 2: Define the finite-size scaling variable x.\n        # This variable measures the scaled distance from the effective threshold.\n        scaling_factor = L**(1.0 / NU)\n        x = (phi - phi_c_eff) * scaling_factor\n\n        # Step 3: Map the scaling variable x to the spanning probability P_span.\n        # This uses the CDF of a normal distribution (expressed via erf).\n        arg_erf = x / (np.sqrt(2.0) * SIGMA)\n        p_span_raw = 0.5 * (1.0 + erf(arg_erf))\n        # Clip the final probability for numerical robustness.\n        p_span = np.clip(p_span_raw, 0.0, 1.0)\n        \n        return p_span\n\n    # Define the test cases from the problem statement.\n    # Format: (L, ell_c, phi)\n    test_cases = [\n        (50.0, 5.0, 0.35),     # Case 1\n        (50.0, 1.0, 0.3116),   # Case 2\n        (50.0, 2.0, 0.25),     # Case 3\n        (20.0, 20.0, 0.30),    # Case 4\n        (5.0, 2.0, 0.30),      # Case 5\n        (50.0, 5.0, 0.0),      # Case 6\n        (50.0, 5.0, 1.0),      # Case 7\n    ]\n\n    results = []\n    for L_val, ell_c_val, phi_val in test_cases:\n        probability = calculate_p_span(L_val, ell_c_val, phi_val)\n        # Round the result to 6 decimal places as required.\n        results.append(f\"{probability:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "逆向设计的核心挑战在于如何从宏观的实验信号中推断出潜在的微观结构信息。电化学阻抗谱 (EIS) 是一种强大的表征技术，但其数据与微观结构参数（如孔隙率 $\\varepsilon$ 和曲折度 $\\mathcal{T}$）之间的关系是间接且复杂的。本练习  将引导您解决一个真实的逆向问题：从合成的 EIS 数据中恢复弛豫时间分布 (DRT)，并利用稀疏正则化技术识别出与扩散相关的特征时间常数 $\\tau_{\\text{diff}}$，最终估算出电极的曲折度 $\\widehat{\\mathcal{T}}$。这个实践将让您掌握如何构建和求解一个正则化逆问题，从而从间接测量中提取出难以直接观察的关键材料参数。",
            "id": "3921846",
            "problem": "您的任务是实现一个逆向设计程序，该程序能够从电化学阻抗数据中恢复稀疏的弛豫时间分布（DRT），然后将恢复的主导扩散时间常数映射到多孔电池电极的微观结构曲折度和孔隙率。弛豫时间分布（DRT）将阻抗响应的虚部表示为标准弛豫核的叠加。目标是从合成的阻抗数据中恢复稀疏的 DRT，并利用恢复的时间常数来估计不同孔隙率下的曲折度。\n\n基本物理原理和定义如下：\n- 通过电化学阻抗谱（EIS）测量的电极过程可以用特征弛豫时间的分布来表示。阻抗响应的虚部由下式建模：\n$$\nZ''(\\omega) = \\int_{-\\infty}^{+\\infty} \\gamma(\\tau) \\, \\frac{\\omega \\tau}{1 + (\\omega \\tau)^2} \\, d\\ln \\tau,\n$$\n其中 $Z''(\\omega)$ 是角频率为 $\\omega$ 时阻抗的虚部，$\\gamma(\\tau)$ 是一个描述弛豫时间为 $\\tau$ 时 DRT 幅值的非负测度，而 $\\frac{\\omega \\tau}{1 + (\\omega \\tau)^2}$ 是一阶过程的标准核。我们限制 $\\gamma(\\tau)$ 为非负，这与无源耗散过程一致。\n- 根据多孔介质的均质化和有效介质理论，有效扩散系数 $D_{\\text{eff}}$ 与体扩散系数 $D$、孔隙率 $\\varepsilon$（无量纲分数）和曲折度 $\\mathcal{T}$（无量纲）的关系如下：\n$$\nD_{\\text{eff}} = \\frac{D \\, \\varepsilon}{\\mathcal{T}}.\n$$\n- 对于厚度为 $L$ 的电极，主导扩散过程的弛豫时间 $\\tau_{\\text{diff}}$ 服从以下标度关系：\n$$\n\\tau_{\\text{diff}} \\approx \\frac{L^2}{D_{\\text{eff}}} = \\frac{L^2 \\, \\mathcal{T}}{D \\, \\varepsilon}.\n$$\n因此，根据恢复的扩散时间常数估算出的曲折度为：\n$$\n\\widehat{\\mathcal{T}} = \\frac{\\tau_{\\text{diff}} \\, D \\, \\varepsilon}{L^2}.\n$$\n\n将 DRT 的逆问题在 $\\ln \\tau$ 的均匀网格上离散化。设 $\\{\\tau_j\\}_{j=1}^{N_\\tau}$ 为以秒为单位的弛豫时间网格，$\\{\\omega_i\\}_{i=1}^{N_\\omega}$ 为以弧度/秒为单位的角频率网格。定义线性算子矩阵 $K \\in \\mathbb{R}^{N_\\omega \\times N_\\tau}$，其元素为：\n$$\nK_{ij} = \\frac{\\omega_i \\tau_j}{1 + (\\omega_i \\tau_j)^2}.\n$$\n给定数据 $y_i = Z''(\\omega_i)$，求解以下凸优化问题以获得离散化的 DRT 幅值 $\\gamma \\in \\mathbb{R}^{N_\\tau}$：\n$$\n\\min_{\\gamma \\ge 0} \\; \\frac{1}{2} \\left\\| K \\gamma - y \\right\\|_2^2 + \\lambda \\left\\| \\gamma \\right\\|_1,\n$$\n其中 $\\lambda > 0$ 促进稀疏性。实现一个带非负性投影的近端梯度（迭代软阈值算法）方案来解决此问题。\n\n恢复 $\\gamma$ 后，检测其峰值，并选择检测到的峰值中最大的弛豫时间作为主导扩散相关时间常数 $\\tau_{\\text{diff}}$。使用此值通过以下公式估计曲折度：\n$$\n\\widehat{\\mathcal{T}} = \\frac{\\tau_{\\text{diff}} \\, D \\, \\varepsilon}{L^2}.\n$$\n\n单位和精度要求：\n- 所有弛豫时间 $\\tau$ 必须以秒为单位。\n- 频率输入单位为赫兹（Hertz）；通过 $\\omega = 2\\pi f$ 转换为以弧度/秒为单位的角频率。\n- 厚度 $L$ 必须以米为单位，体扩散系数 $D$ 以 $\\mathrm{m}^2/\\mathrm{s}$ 为单位，孔隙率 $\\varepsilon$ 和曲折度 $\\mathcal{T}$ 是无量纲的。\n- 输出的曲折度估计值必须表示为浮点值（不带百分号）。\n\n测试套件规范：\n您必须通过对少数已知时间常数和幅值的理想化 DRT 峰进行求和来生成合成的 $Z''(\\omega)$：\n$$\nZ''(\\omega) = \\sum_{k=1}^{K} a_k \\frac{\\omega \\tau_k}{1 + (\\omega \\tau_k)^2},\n$$\n其中 $a_k \\ge 0$ 且 $\\tau_k > 0$。在每个测试案例中，添加独立的零均值高斯噪声，其标准差等于 $Z''(\\omega)$ 最大幅值的 $0.005$ 倍，以模拟测量噪声。\n\n对于所有测试案例，使用一个在 $f \\in [10^{-5}, 10^{3}]$ 赫兹范围内的均匀对数频率网格，包含 $N_\\omega = 60$ 个点。使用一个在 $\\tau \\in [10^{-4}, 10^{5}]$ 秒范围内，$\\ln \\tau$ 上均匀分布的 DRT 网格，包含 $N_\\tau = 200$ 个点。\n\n提供三个测试案例：\n\n- 案例 A（一般情况）：\n    - $L = 100 \\times 10^{-6}$ 米，$\\varepsilon = 0.4$，$D = 1 \\times 10^{-10}$ $\\mathrm{m}^2/\\mathrm{s}$。\n    - 真实曲折度 $\\mathcal{T}_{\\text{true}} = 2.5$。\n    - 扩散时间常数 $\\tau_{\\text{diff,true}} = \\dfrac{L^2 \\mathcal{T}_{\\text{true}}}{D \\varepsilon}$。\n    - 峰值：$(\\tau, a)$ 分别为 $(1, 0.3)$、$(\\tau_{\\text{diff,true}}, 0.5)$ 和 $(50, 0.1)$。\n\n- 案例 B（高孔隙率）：\n    - $L = 100 \\times 10^{-6}$ 米，$\\varepsilon = 0.8$，$D = 1 \\times 10^{-10}$ $\\mathrm{m}^2/\\mathrm{s}$。\n    - 真实曲折度 $\\mathcal{T}_{\\text{true}} = 1.5$。\n    - 扩散时间常数 $\\tau_{\\text{diff,true}} = \\dfrac{L^2 \\mathcal{T}_{\\text{true}}}{D \\varepsilon}$。\n    - 峰值：$(\\tau, a)$ 分别为 $(0.8, 0.25)$、$(\\tau_{\\text{diff,true}}, 0.5)$ 和 $(30, 0.15)$。\n\n- 案例 C（低孔隙率，较厚电极，长时间边缘情况）：\n    - $L = 150 \\times 10^{-6}$ 米，$\\varepsilon = 0.2$，$D = 1 \\times 10^{-10}$ $\\mathrm{m}^2/\\mathrm{s}$。\n    - 真实曲折度 $\\mathcal{T}_{\\text{true}} = 4.0$。\n    - 扩散时间常数 $\\tau_{\\text{diff,true}} = \\dfrac{L^2 \\mathcal{T}_{\\text{true}}}{D \\varepsilon}$。\n    - 峰值：$(\\tau, a)$ 分别为 $(2, 0.3)$、$(\\tau_{\\text{diff,true}}, 0.6)$ 和 $(70, 0.1)$。\n\n您的程序必须：\n- 构造核矩阵 $K$，为每个案例合成带噪声的 $Z''(\\omega)$，使用近端梯度迭代在规定约束下求解稀疏反演问题，检测恢复的 $\\gamma(\\tau)$ 的峰值，选择检测到的最大 $\\tau$ 作为 $\\tau_{\\text{diff}}$，并使用上述公式计算每个案例的 $\\widehat{\\mathcal{T}}$。\n- 使用一个随问题规模缩放的正则化强度 $\\lambda$（例如，基于 $K^\\top y$ 的无穷范数），以及一个基于梯度 Lipschitz 常数（即 $K^\\top K$ 的谱范数）的步长。\n- 通过为噪声生成使用固定的随机种子来确保可复现性。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含三个测试案例的估计曲折度，按案例 A、案例 B、案例 C 的顺序，以逗号分隔的列表形式包含在方括号内。例如，输出必须如下所示：\n$$\n[\\widehat{\\mathcal{T}}_{\\mathrm{A}},\\widehat{\\mathcal{T}}_{\\mathrm{B}},\\widehat{\\mathcal{T}}_{\\mathrm{C}}].\n$$\n每个条目都必须是一个浮点值。",
            "solution": "所提出的问题是有效的。这是一个在计算材料科学和电化学领域具有科学依据、适定且客观的问题。它要求实现一个逆向设计工作流程，从合成的电化学阻抗谱（EIS）数据中估计电池电极的一个关键微观结构参数——曲折度 $\\mathcal{T}$。该方法基于弛豫时间分布（DRT）的恢复及其与物理输运现象的联系。所有必需的物理模型、数学公式、数值参数和测试案例均已提供，构成了一个完整且一致的规范。\n\n解决方案是遵循从第一性原理推导的一系列步骤来开发的。首先，我们建立连接可测量的阻抗数据与潜在材料特性的物理和数学模型。其次，我们构建恢复 DRT 的逆问题。第三，我们详细说明用于解决此逆问题的数值算法。最后，我们描述从数值解中提取目标物理参数的过程。\n\n基本的物理模型是将阻抗的虚部 $Z''(\\omega)$ 表示为对弛豫时间分布 $\\gamma(\\tau)$ 的积分。这表示为：\n$$\nZ''(\\omega) = \\int_{-\\infty}^{+\\infty} \\gamma(\\tau) \\, K(\\omega, \\tau) \\, d\\ln \\tau, \\quad \\text{其中 } K(\\omega, \\tau) = \\frac{\\omega \\tau}{1 + (\\omega \\tau)^2}\n$$\n这里，$\\omega$ 是角频率，$\\tau$ 是弛豫时间，核函数 $K(\\omega, \\tau)$ 表示单个一阶德拜（Debye）弛豫过程的响应。函数 $\\gamma(\\tau)$ 是一个非负分布，量化了在特征时间 $\\tau$ 发生的各种过程的贡献。\n\n通过主导扩散过程，建立了与电极微观结构的联系。对于厚度为 $L$ 的多孔电极，活性物质的有效扩散系数 $D_{\\text{eff}}$ 通过有效介质关系与它的体扩散系数 $D$、电极孔隙率 $\\varepsilon$ 和曲折度 $\\mathcal{T}$ 相关联：\n$$\nD_{\\text{eff}} = \\frac{D \\varepsilon}{\\mathcal{T}}\n$$\n曲折度 $\\mathcal{T}$ 是一个大于或等于1的无量纲因子，它解释了离子必须通过多孔结构所走的曲折路径，使得有效路径长度比电极厚度更长。跨越此厚度的扩散特征时间尺度 $\\tau_{\\text{diff}}$ 由以下标度律给出：\n$$\n\\tau_{\\text{diff}} \\approx \\frac{L^2}{D_{\\text{eff}}} = \\frac{L^2 \\mathcal{T}}{D \\varepsilon}\n$$\n通过反转这个关系，如果我们能从阻抗数据中确定 $\\tau_{\\text{diff}}$，就可以得到曲折度的估计值 $\\widehat{\\mathcal{T}}$：\n$$\n\\widehat{\\mathcal{T}} = \\frac{\\tau_{\\text{diff}} D \\varepsilon}{L^2}\n$$\n问题的核心在于从一组带噪声的离散测量值 $Z''(\\omega)$ 中恢复 $\\gamma(\\tau)$。这是一个经典的不适定逆问题。为了解决这个问题，我们首先将积分方程离散化。我们定义一个包含 $N_\\omega$ 个角频率的网格 $\\{\\omega_i\\}_{i=1}^{N_\\omega}$ 和一个包含 $N_\\tau$ 个弛豫时间的网格 $\\{\\tau_j\\}_{j=1}^{N_\\tau}$（在对数域上均匀分布）。测量值为 $y_i = Z''(\\omega_i)$，我们寻求离散的 DRT 幅值 $\\gamma_j = \\gamma(\\tau_j)$。这将积分方程转化为一个线性方程组：\n$$\ny \\approx K \\gamma\n$$\n其中 $y \\in \\mathbb{R}^{N_\\omega}$，$\\gamma \\in \\mathbb{R}^{N_\\tau}$，而 $K \\in \\mathbb{R}^{N_\\omega \\times N_\\tau}$ 是核矩阵，其元素为 $K_{ij} = \\frac{\\omega_i \\tau_j}{1 + (\\omega_i \\tau_j)^2}$。\n\n由于问题的不适定性，一个朴素的最小二乘解会非常不稳定，并被噪声主导。我们引入正则化来获得一个稳定且有物理意义的解。问题指定了一个 L1 范数惩罚项，这会促进 $\\gamma$ 的稀疏解。这反映了电化学响应通常由少数几个不同的过程主导的物理直觉。物理耗散率的非负性要求约束条件 $\\gamma_j \\ge 0$。由此产生的优化问题是一个非负 LASSO 问题：\n$$\n\\min_{\\gamma \\ge 0} \\; \\frac{1}{2} \\left\\| K \\gamma - y \\right\\|_2^2 + \\lambda \\left\\| \\gamma \\right\\|_1\n$$\n其中 $\\lambda > 0$ 是在数据保真度与稀疏性之间取得平衡的正则化参数。\n\n这个凸优化问题使用近端梯度法来解决，具体来说是迭代软阈值算法（ISTA）。该算法迭代地对最小二乘项执行梯度下降步骤，然后进行一个强制稀疏性和非负性的近端映射步骤。更新规则是：\n$$\n\\gamma^{(k+1)} = \\text{prox}_{\\alpha g}(\\gamma^{(k)} - \\alpha \\nabla f(\\gamma^{(k)}))\n$$\n其中 $f(\\gamma) = \\frac{1}{2} \\| K \\gamma - y \\|_2^2$，而 $g(\\gamma)$ 包含了 L1 范数和非负性。梯度是 $\\nabla f(\\gamma) = K^\\top (K\\gamma - y)$。对于非负 LASSO 问题，近端算子 $\\text{prox}_{\\alpha \\lambda g}$ 简化为对梯度步骤结果 $z = \\gamma^{(k)} - \\alpha \\nabla f(\\gamma^{(k)})$ 进行元素级的操作：$\\text{prox}(z) = \\max(0, z - \\alpha\\lambda)$。因此，完整的更新步骤是：\n$$\n\\gamma^{(k+1)} = \\max\\left(0, \\left(\\gamma^{(k)} - \\alpha K^\\top(K\\gamma^{(k)} - y)\\right) - \\alpha\\lambda\\right)\n$$\n选择步长 $\\alpha$ 以确保收敛，通常 $\\alpha \\le 1/L_{f}$，其中 $L_f$ 是梯度 $\\nabla f$ 的 Lipschitz 常数。这个常数是 $K^\\top K$ 的最大特征值，等于 $K$ 的最大奇异值的平方，即 $L_f = \\sigma_{\\text{max}}(K)^2$。正则化参数 $\\lambda$ 根据数据进行缩放，具体来说是 $\\lambda \\propto \\|K^\\top y\\|_{\\infty}$，以适应不同问题的尺度。\n\n经过足够次数的迭代后，算法会收敛到一个稀疏的非负向量 $\\gamma$。从这个恢复的 DRT 中，我们识别出峰值。根据问题规范，与检测到的峰值对应的最大弛豫时间 $\\tau$ 被确定为扩散时间常数 $\\tau_{\\text{diff}}$。这个估计的 $\\tau_{\\text{diff}}$ 随后在最后一步中用于计算曲折度估计值 $\\widehat{\\mathcal{T}}$。整个过程应用于三个具有不同物理参数的独立测试案例，并报告所得的曲折度估计值。",
            "answer": "```python\nimport numpy as np\nfrom scipy.signal import find_peaks\n\ndef inverse_design_tortuosity():\n    \"\"\"\n    Solves for electrode tortuosity from synthetic impedance data.\n\n    This function implements the full workflow described in the problem statement.\n    It iterates through three test cases, and for each case:\n    1. Generates synthetic noisy impedance data based on true physical parameters.\n    2. Constructs the DRT kernel matrix.\n    3. Solves the sparse, non-negative regularized inverse problem using ISTA\n       to recover the Distribution of Relaxation Times (DRT).\n    4. Identifies peaks in the recovered DRT.\n    5. Selects the diffusion time constant based on the specified rule.\n    6. Computes the estimated tortuosity.\n    Finally, it prints the results for all cases in the required format.\n    \"\"\"\n\n    # --- Global Parameters ---\n    # Grids\n    N_FREQ = 60\n    N_TAU = 200\n    FREQ_MIN, FREQ_MAX = 1e-5, 1e3  # Hz\n    TAU_MIN, TAU_MAX = 1e-4, 1e5    # s\n\n    # Algorithm parameters\n    ISTA_ITERATIONS = 2000\n    LAMBDA_SCALE_FACTOR = 0.02\n    PEAK_HEIGHT_RATIO = 0.05\n\n    # Reproducibility\n    RANDOM_SEED = 42\n    np.random.seed(RANDOM_SEED)\n\n    # --- Grid Setup ---\n    # Frequencies (f in Hz, omega in rad/s)\n    f_grid = np.logspace(np.log10(FREQ_MIN), np.log10(FREQ_MAX), N_FREQ)\n    omega_grid = 2 * np.pi * f_grid\n    \n    # Relaxation times (tau in s)\n    tau_grid = np.logspace(np.log10(TAU_MIN), np.log10(TAU_MAX), N_TAU)\n\n    # --- Test Cases ---\n    test_cases = [\n        {\n            \"name\": \"Case A (general)\",\n            \"L\": 100e-6, \"epsilon\": 0.4, \"D\": 1e-10, \"T_true\": 2.5,\n            \"base_peaks\": [(1.0, 0.3), (50.0, 0.1)]\n        },\n        {\n            \"name\": \"Case B (high porosity)\",\n            \"L\": 100e-6, \"epsilon\": 0.8, \"D\": 1e-10, \"T_true\": 1.5,\n            \"base_peaks\": [(0.8, 0.25), (30.0, 0.15)]\n        },\n        {\n            \"name\": \"Case C (low porosity, thick)\",\n            \"L\": 150e-6, \"epsilon\": 0.2, \"D\": 1e-10, \"T_true\": 4.0,\n            \"base_peaks\": [(2.0, 0.3), (70.0, 0.1)]\n        }\n    ]\n    \n    estimated_tortuosities = []\n\n    # --- Main Loop ---\n    for case in test_cases:\n        L, epsilon, D, T_true = case[\"L\"], case[\"epsilon\"], case[\"D\"], case[\"T_true\"]\n\n        # 1. Calculate true diffusion time and complete the peak list\n        tau_diff_true = (L**2 * T_true) / (D * epsilon)\n        true_peaks = case[\"base_peaks\"] + [(tau_diff_true, 0.5 if case[\"name\"] != \"Case C (low porosity, thick)\" else 0.6)]\n\n        # 2. Generate synthetic impedance data Z''\n        Z_imag_true = np.zeros_like(omega_grid)\n        for tau_k, a_k in true_peaks:\n            Z_imag_true += a_k * (omega_grid * tau_k) / (1 + (omega_grid * tau_k)**2)\n        \n        noise_std = 0.005 * np.max(np.abs(Z_imag_true))\n        noise = np.random.normal(0, noise_std, size=Z_imag_true.shape)\n        y = Z_imag_true + noise\n\n        # 3. Construct kernel matrix K\n        K = (omega_grid[:, np.newaxis] * tau_grid[np.newaxis, :]) / \\\n            (1 + (omega_grid[:, np.newaxis] * tau_grid[np.newaxis, :])**2)\n\n        # 4. Set ISTA hyperparameters\n        # Step size (alpha) based on Lipschitz constant\n        s_max = np.linalg.svd(K, compute_uv=False)[0]\n        lipschitz_const = s_max**2\n        alpha = 1.0 / lipschitz_const\n        \n        # Regularization parameter (lambda) scaled by data\n        lambda_reg = LAMBDA_SCALE_FACTOR * np.linalg.norm(K.T @ y, ord=np.inf)\n\n        # 5. Solve for DRT (gamma) using ISTA\n        gamma = np.zeros(N_TAU)\n        for _ in range(ISTA_ITERATIONS):\n            grad = K.T @ (K @ gamma - y)\n            z = gamma - alpha * grad\n            gamma = np.maximum(z - alpha * lambda_reg, 0)\n        \n        # 6. Peak detection in the recovered DRT\n        peak_height_threshold = PEAK_HEIGHT_RATIO * np.max(gamma)\n        peak_indices, _ = find_peaks(gamma, height=peak_height_threshold)\n        \n        if len(peak_indices) == 0:\n            # Fallback if no peaks are detected (unlikely but robust)\n            # Use the tau corresponding to the max gamma value\n            tau_diff_est = tau_grid[np.argmax(gamma)]\n        else:\n            # 7. Select largest relaxation time among detected peaks\n            detected_taus = tau_grid[peak_indices]\n            tau_diff_est = np.max(detected_taus)\n\n        # 8. Compute estimated tortuosity\n        T_hat = (tau_diff_est * D * epsilon) / (L**2)\n        estimated_tortuosities.append(T_hat)\n\n    # --- Final Output ---\n    print(f\"[{','.join([f'{val:.6f}' for val in estimated_tortuosities])}]\")\n\nif __name__ == '__main__':\n    inverse_design_tortuosity()\n```"
        }
    ]
}