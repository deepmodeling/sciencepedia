{
    "hands_on_practices": [
        {
            "introduction": "The first practical step in any large-scale, image-based simulation is assessing its computational feasibility. This exercise provides a quantitative foundation for comparing two of the most common element types, tetrahedra and hexahedra, by estimating the memory footprint required to mesh a representative volume element at image resolution. Developing this skill is essential for planning computational studies and making informed decisions about meshing strategies that balance geometric fidelity with available hardware resources .",
            "id": "3919519",
            "problem": "A micro-computed tomography (micro-CT) segmented microstructure of a lithium-ion battery electrode is provided as a representative volume element (RVE). The RVE is a cube of edge length $L_x = L_y = L_z = 100\\,\\mu\\text{m}$. The image voxel pitch is $a = 0.5\\,\\mu\\text{m}$, and segmentation assigns each voxel one of three material labels: active solid, pore (electrolyte), or carbon-binder domain. The goal is to generate an image-based mesh that preserves the resolution of the image.\n\nDefine “equivalent resolution” as using the same nodal spacing $h$ in all directions for either tetrahedral or hexahedral discretizations, with $h = a$. For the hexahedral mesh, assume a structured grid aligned to the voxels so that each voxel corresponds to one hexahedral element. For the tetrahedral mesh, assume each voxel cube is partitioned into $6$ tetrahedra using a consistent cube-to-tetra triangulation with no additional interior points, so that the tetrahedral mesh uses the same node set as the hexahedral grid.\n\nAssume the mesh data structure stores only the following:\n- For each node, its three Cartesian coordinates as $64$-bit floating-point numbers, each of size $8$ bytes.\n- For each element, its connectivity stored as $32$-bit nonnegative integer node indices, each of size $4$ bytes, with $8$ indices for a hexahedron and $4$ indices for a tetrahedron.\n- For each element, one $32$-bit integer material label, size $4$ bytes.\n\nIgnore any other data (boundary conditions, solver vectors, ghost layers, metadata). Use binary base-2 units and express the memory footprint in gibibytes (GiB), where $1\\,\\text{GiB} = 2^{30}$ bytes.\n\nCompute:\n1. The hexahedral element count.\n2. The tetrahedral element count.\n3. The total mesh memory footprint for the hexahedral case (nodes plus elements) in GiB.\n4. The total mesh memory footprint for the tetrahedral case (nodes plus elements) in GiB.\n\nRound the two memory values to four significant figures. Report your final answer as a row matrix in the order $\\left(N_{\\text{hex}},\\,N_{\\text{tet}},\\,M_{\\text{hex}},\\,M_{\\text{tet}}\\right)$, where $N_{\\text{hex}}$ and $N_{\\text{tet}}$ are element counts and $M_{\\text{hex}}$ and $M_{\\text{tet}}$ are memory footprints in GiB.",
            "solution": "The problem requires the calculation of element counts and total memory footprints for two different mesh types, hexahedral and tetrahedral, generated from a micro-CT image of a battery electrode. The validation process confirms that the problem is well-posed, scientifically grounded, and contains sufficient information for a unique solution.\n\nFirst, we determine the number of voxels in the representative volume element (RVE). The RVE is a cube with side length $L = 100\\,\\mu\\text{m}$. The image voxel pitch, which also defines the mesh resolution, is $a = 0.5\\,\\mu\\text{m}$. The number of voxels along each dimension ($x$, $y$, $z$) is given by the ratio of the RVE length to the voxel pitch:\n$$N_{v} = \\frac{L}{a} = \\frac{100\\,\\mu\\text{m}}{0.5\\,\\mu\\text{m}} = 200$$\nThe total number of voxels in the cubic RVE is therefore:\n$$N_{\\text{voxel}} = N_{v}^3 = 200^3 = 8,000,000$$\n\nNext, we calculate the number of elements for each mesh type.\n1.  For the hexahedral mesh, each voxel corresponds to one hexahedral element. Thus, the number of hexahedral elements, $N_{\\text{hex}}$, is equal to the number of voxels.\n    $$N_{\\text{hex}} = N_{\\text{voxel}} = 8,000,000$$\n2.  For the tetrahedral mesh, each voxel cube is partitioned into $6$ tetrahedra. Therefore, the number of tetrahedral elements, $N_{\\text{tet}}$, is $6$ times the number of voxels.\n    $$N_{\\text{tet}} = 6 \\times N_{\\text{voxel}} = 6 \\times 8,000,000 = 48,000,000$$\n\nNow, we determine the total number of nodes in the mesh. A structured grid of $N_v \\times N_v \\times N_v$ voxels has $(N_v+1)$ nodes along each dimension. The problem states that both mesh types share the same set of nodes.\nThe number of nodes along each dimension is:\n$$N_{n} = N_{v} + 1 = 200 + 1 = 201$$\nThe total number of nodes, $N_{\\text{nodes}}$, is:\n$$N_{\\text{nodes}} = N_{n}^3 = 201^3 = 8,120,601$$\n\nWith the counts for nodes and elements established, we can calculate the memory footprint. The storage requirements per entity are specified.\nMemory per node ($S_{\\text{node}}$) consists of $3$ coordinates, each an $8$-byte floating-point number:\n$$S_{\\text{node}} = 3 \\times 8\\,\\text{bytes} = 24\\,\\text{bytes}$$\nTotal memory for all nodes ($M_{\\text{nodes}}$) is:\n$$M_{\\text{nodes}} = N_{\\text{nodes}} \\times S_{\\text{node}} = 8,120,601 \\times 24\\,\\text{bytes} = 194,894,424\\,\\text{bytes}$$\n\nMemory for the elements is calculated separately for each mesh type.\nFor a hexahedral element ($S_{\\text{hex\\_elem}}$), storage includes $8$ node indices ($4$ bytes each) and one material label ($4$ bytes):\n$$S_{\\text{hex\\_elem}} = (8 \\times 4\\,\\text{bytes}) + (1 \\times 4\\,\\text{bytes}) = 32 + 4 = 36\\,\\text{bytes}$$\nTotal memory for all hexahedral elements ($M_{\\text{hex\\_elems}})$ is:\n$$M_{\\text{hex\\_elems}} = N_{\\text{hex}} \\times S_{\\text{hex\\_elem}} = 8,000,000 \\times 36\\,\\text{bytes} = 288,000,000\\,\\text{bytes}$$\nThe total memory footprint for the hexahedral mesh, $M_{\\text{hex}}$, is the sum of node and element memory:\n$$M_{\\text{hex}} = M_{\\text{nodes}} + M_{\\text{hex\\_elems}} = 194,894,424 + 288,000,000 = 482,894,424\\,\\text{bytes}$$\n\nFor a tetrahedral element ($S_{\\text{tet\\_elem}}$), storage includes $4$ node indices ($4$ bytes each) and one material label ($4$ bytes):\n$$S_{\\text{tet\\_elem}} = (4 \\times 4\\,\\text{bytes}) + (1 \\times 4\\,\\text{bytes}) = 16 + 4 = 20\\,\\text{bytes}$$\nTotal memory for all tetrahedral elements ($M_{\\text{tet\\_elems}})$ is:\n$$M_{\\text{tet\\_elems}} = N_{\\text{tet}} \\times S_{\\text{tet\\_elem}} = 48,000,000 \\times 20\\,\\text{bytes} = 960,000,000\\,\\text{bytes}$$\nThe total memory footprint for the tetrahedral mesh, $M_{\\text{tet}}$, is the sum of node and element memory:\n$$M_{\\text{tet}} = M_{\\text{nodes}} + M_{\\text{tet\\_elems}} = 194,894,424 + 960,000,000 = 1,154,894,424\\,\\text{bytes}$$\n\nFinally, we convert these memory values from bytes to gibibytes (GiB), where $1\\,\\text{GiB} = 2^{30}$ bytes, and round to four significant figures.\n$$1\\,\\text{GiB} = 2^{30}\\,\\text{bytes} = 1,073,741,824\\,\\text{bytes}$$\nFor the hexahedral mesh:\n$$M_{\\text{hex}} (\\text{GiB}) = \\frac{482,894,424}{1,073,741,824} \\approx 0.4497138\\,\\text{GiB}$$\nRounding to four significant figures gives $0.4497\\,\\text{GiB}$.\n\nFor the tetrahedral mesh:\n$$M_{\\text{tet}} (\\text{GiB}) = \\frac{1,154,894,424}{1,073,741,824} \\approx 1.075580\\,\\text{GiB}$$\nRounding to four significant figures gives $1.076\\,\\text{GiB}$.\n\nThe four requested values are:\n1.  $N_{\\text{hex}} = 8,000,000$\n2.  $N_{\\text{tet}} = 48,000,000$\n3.  $M_{\\text{hex}} \\approx 0.4497\\,\\text{GiB}$\n4.  $M_{\\text{tet}} \\approx 1.076\\,\\text{GiB}$",
            "answer": "$$\\boxed{\\begin{pmatrix} 8000000 & 48000000 & 0.4497 & 1.076 \\end{pmatrix}}$$"
        },
        {
            "introduction": "While voxel-based meshes are simple to generate, their inherent \"staircasing\" artifacts can misrepresent the geometry of curved interfaces, which are critical in battery electrodes. This practice guides you in quantifying this geometric discretization error by comparing a voxelized sphere to its exact analytical form, focusing on key metrics like the surface-to-volume ratio ($S_v$) and mean curvature ($H$). Crucially, it demonstrates how these geometric inaccuracies propagate into the physical models that depend on them, such as the Butler-Volmer kinetics that govern interfacial reactions .",
            "id": "3919515",
            "problem": "You are given a three-dimensional porous electrode microstructure generated from a single spherical active-material inclusion embedded within an electrolyte domain. Your task is to implement a program that compares image-based voxel meshing to an idealized curved-element representation of the same geometry and quantifies the impact on interfacial kinetics predictions. The comparison requires computing the surface-to-volume ratio and a curvature metric from first principles.\n\nStarting points and definitions:\n- The surface-to-volume ratio $S_v$ is defined as $S_v = A/V$, where $A$ is the interfacial area between solid and electrolyte, and $V$ is the total volume of the domain. The quantity $S_v$ has units of $\\mathrm{m^{-1}}$.\n- Consider a smooth interface $\\Gamma$ represented as the zero-level set of a signed distance function $\\phi(\\mathbf{x})$, with $\\phi(\\mathbf{x}) < 0$ in the solid and $\\phi(\\mathbf{x}) > 0$ in the electrolyte. Define the unit normal field $\\mathbf{n} = \\nabla \\phi / \\|\\nabla \\phi\\|$. The curvature metric to be used is the mean curvature defined as the sum of principal curvatures, given by $H(\\mathbf{x}) = \\nabla \\cdot \\mathbf{n}$ on $\\Gamma$. The quantity $H$ has units of $\\mathrm{m^{-1}}$.\n- For a sphere of radius $R$ centered in the domain, the exact interfacial area is $A_{\\mathrm{exact}} = 4\\pi R^2$, the exact mean curvature (sum of principal curvatures) is $H_{\\mathrm{exact}} = 2/R$, and the exact $S_v$ is $S_{v,\\mathrm{exact}} = A_{\\mathrm{exact}}/V$.\n- Interfacial electrochemical kinetics are described by the Butler–Volmer (BV) relation. For a uniform overpotential $\\eta$, charge-transfer coefficients $\\alpha_a$ and $\\alpha_c$, temperature $T$, Faraday constant $F$, and gas constant $R_g$, the local area-based current density is\n$$\nj_{\\mathrm{area}}(\\mathbf{x}) = j_0(\\mathbf{x})\\left[\\exp\\left(\\frac{\\alpha_a F \\eta}{R_g T}\\right) - \\exp\\left(-\\frac{\\alpha_c F \\eta}{R_g T}\\right)\\right],\n$$\nwhere $j_0(\\mathbf{x})$ is the local exchange current density. To model curvature-dependent roughness effects in a dimensionally consistent way, assume\n$$\nj_0(\\mathbf{x}) = j_{0,\\mathrm{flat}}\\left(1 + \\ell_c \\, |H(\\mathbf{x})|\\right),\n$$\nwith $j_{0,\\mathrm{flat}}$ a flat-surface exchange current density in $\\mathrm{A\\,m^{-2}}$ and $\\ell_c$ a microscopic length scale in $\\mathrm{m}$. The total volumetric current density predicted for an electrode with uniform $\\eta$ is then\n$$\nj_{\\mathrm{vol}} = S_v \\, \\overline{j_{\\mathrm{area}}},\n$$\nwith $\\overline{j_{\\mathrm{area}}}$ the area-average of $j_{\\mathrm{area}}$ on $\\Gamma$, and $j_{\\mathrm{vol}}$ in $\\mathrm{A\\,m^{-3}}$.\n\nYou must implement two representations:\n- Voxel-based mesh: Discretize a cubic domain of side length $L$ into $N \\times N \\times N$ voxels. Define the solid region as the set of voxels whose centers lie within a sphere of radius $R$ centered in the domain. Compute\n    1. $A_{\\mathrm{voxel}}$ by counting interfacial faces between solid and electrolyte and multiplying by the voxel face area.\n    2. $S_{v,\\mathrm{voxel}} = A_{\\mathrm{voxel}} / L^3$.\n    3. $H_{\\mathrm{voxel}}$ by constructing a signed distance function $\\phi$ on the grid, smoothing it, computing $\\mathbf{n} = \\nabla \\phi / \\|\\nabla \\phi\\|$, and averaging $|\\nabla \\cdot \\mathbf{n}|$ over voxels within one voxel width of the interface (i.e., where $|\\phi| \\le h$, with $h = L/N$).\n    4. $j_{\\mathrm{vol,voxel}}$ using the BV relation and the curvature-dependent $j_0(\\mathbf{x})$ model evaluated with $H_{\\mathrm{voxel}}$.\n- Curved-element mesh: Use the exact sphere geometry to compute\n    1. $A_{\\mathrm{curved}} = 4\\pi R^2$,\n    2. $S_{v,\\mathrm{curved}} = A_{\\mathrm{curved}} / L^3$,\n    3. $H_{\\mathrm{curved}} = 2/R$,\n    4. $j_{\\mathrm{vol,curved}}$ using the BV relation and the curvature-dependent $j_0$ with $H_{\\mathrm{curved}}$.\n\nConstants for kinetics (use these exact values and units):\n- $j_{0,\\mathrm{flat}} = 1.5$ in $\\mathrm{A\\,m^{-2}}$,\n- $\\ell_c = 5.0\\times 10^{-7}$ in $\\mathrm{m}$,\n- $\\alpha_a = 0.5$ (dimensionless),\n- $\\alpha_c = 0.5$ (dimensionless),\n- $F = 96485$ in $\\mathrm{C\\,mol^{-1}}$,\n- $R_g = 8.314$ in $\\mathrm{J\\,mol^{-1}\\,K^{-1}}$,\n- $T = 298$ in $\\mathrm{K}$,\n- $\\eta = 0.02$ in $\\mathrm{V}$.\n\nUnits and numerical outputs:\n- Report $S_v$ in $\\mathrm{m^{-1}}$,\n- Report the curvature metric $H$ in $\\mathrm{m^{-1}}$,\n- Report volumetric current density $j_{\\mathrm{vol}}$ in $\\mathrm{A\\,m^{-3}}$.\n\nFor each test case, your program must compute and return the differences:\n- $\\Delta S_v = S_{v,\\mathrm{voxel}} - S_{v,\\mathrm{curved}}$,\n- $\\Delta H = H_{\\mathrm{voxel}} - H_{\\mathrm{curved}}$,\n- $\\Delta j_{\\mathrm{vol}} = j_{\\mathrm{vol,voxel}} - j_{\\mathrm{vol,curved}}$.\n\nTest suite:\nUse the following $4$ test cases, each specified by domain side length $L$ (in $\\mathrm{m}$), grid resolution $N$ (unitless), and sphere radius $R$ (in $\\mathrm{m}$):\n1. Case $1$: $L = 50\\times 10^{-6}$, $N = 64$, $R = 10\\times 10^{-6}$.\n2. Case $2$: $L = 50\\times 10^{-6}$, $N = 16$, $R = 10\\times 10^{-6}$.\n3. Case $3$: $L = 50\\times 10^{-6}$, $N = 64$, $R = 3\\times 10^{-6}$.\n4. Case $4$: $L = 50\\times 10^{-6}$, $N = 64$, $R = 20\\times 10^{-6}$.\n\nAlgorithmic requirements:\n- Implement the voxel-based area $A_{\\mathrm{voxel}}$ by counting axis-aligned neighboring voxel pairs that differ in phase and multiplying by $h^2$, where $h = L/N$.\n- Construct the signed distance $\\phi$ using Euclidean distance transforms of the binary phase map, and smooth $\\phi$ with a small Gaussian filter before computing $\\mathbf{n}$ and $H$ to mitigate staircasing artifacts.\n- Use central differences via spatial gradients to compute $\\nabla \\phi$ and $\\nabla \\cdot \\mathbf{n}$ with correct physical scaling by $h$.\n\nFinal output format:\nYour program should produce a single line of output containing the results for the $4$ test cases as a comma-separated list of lists, where each inner list is ordered as $[\\Delta S_v,\\Delta H,\\Delta j_{\\mathrm{vol}}]$ in the units specified. For example, the output should have the form\n$[[\\Delta S_v^{(1)},\\Delta H^{(1)},\\Delta j_{\\mathrm{vol}}^{(1)}],[\\Delta S_v^{(2)},\\Delta H^{(2)},\\Delta j_{\\mathrm{vol}}^{(2)}],[\\Delta S_v^{(3)},\\Delta H^{(3)},\\Delta j_{\\mathrm{vol}}^{(3)}],[\\Delta S_v^{(4)},\\Delta H^{(4)},\\Delta j_{\\mathrm{vol}}^{(4)}]]$.",
            "solution": "The problem statement has been meticulously reviewed and is determined to be valid. It is scientifically sound, self-contained, well-posed, and free from any listed flaws. It presents a well-defined computational task in the field of battery simulation, comparing an idealized analytical model with a common numerical approximation based on voxelization.\n\nThe solution proceeds by first establishing the analytical expressions for the geometric and kinetic quantities for the idealized curved-element representation of the sphere. Subsequently, it details the numerical algorithm for computing the same quantities for the voxel-based representation. Finally, the differences between the two representations are calculated as specified.\n\nThe problem revolves around a single spherical inclusion of active material of radius $R$ centered within a cubic domain of side length $L$ and total volume $V = L^3$.\n\n**1. Curved-Element (Analytical) Representation**\n\nFor a perfect sphere, the geometric and kinetic properties are known analytically. These serve as the ground truth for our comparison.\n\nThe interfacial area between the spherical solid and the electrolyte is given by the surface area of a sphere:\n$$A_{\\mathrm{curved}} = 4\\pi R^2$$\nThe surface-to-volume ratio, $S_v$, is this area divided by the total domain volume:\n$$S_{v,\\mathrm{curved}} = \\frac{A_{\\mathrm{curved}}}{V} = \\frac{4\\pi R^2}{L^3}$$\nThe mean curvature, $H$, defined as the sum of the two principal curvatures $(\\kappa_1 + \\kappa_2)$, is constant over the entire surface of a sphere. For a sphere of radius $R$, both principal curvatures are $1/R$, so:\n$$H_{\\mathrm{curved}} = \\frac{1}{R} + \\frac{1}{R} = \\frac{2}{R}$$\nThe Butler-Volmer equation describes the local current density, $j_{\\mathrm{area}}$, as a function of the local exchange current density, $j_0$. The model provided posits a curvature-dependent $j_0$:\n$$j_0(\\mathbf{x}) = j_{0,\\mathrm{flat}}\\left(1 + \\ell_c \\, |H(\\mathbf{x})|\\right)$$\nSince the curvature $H_{\\mathrm{curved}}$ is uniform across the idealized spherical interface, the exchange current density is also uniform:\n$$j_{0,\\mathrm{curved}} = j_{0,\\mathrm{flat}}\\left(1 + \\ell_c \\, H_{\\mathrm{curved}}\\right)$$\nThe term $|H_{\\mathrm{curved}}|$ simplifies to $H_{\\mathrm{curved}}$ as both $R$ and $2$ are positive. The area-averaged current density, $\\overline{j_{\\mathrm{area}}}$, is then calculated using the constant kinetic parameters: overpotential $\\eta$, charge-transfer coefficients $\\alpha_a$ and $\\alpha_c$, temperature $T$, Faraday constant $F$, and gas constant $R_g$.\n$$\\overline{j_{\\mathrm{area,curved}}} = j_{0,\\mathrm{curved}}\\left[\\exp\\left(\\frac{\\alpha_a F \\eta}{R_g T}\\right) - \\exp\\left(-\\frac{\\alpha_c F \\eta}{R_g T}\\right)\\right]$$\nThe total volumetric current density, $j_{\\mathrm{vol}}$, is the product of the surface-to-volume ratio and the area-averaged surface current density:\n$$j_{\\mathrm{vol,curved}} = S_{v,\\mathrm{curved}} \\, \\overline{j_{\\mathrm{area,curved}}}$$\n\n**2. Voxel-Based (Numerical) Representation**\n\nThis approach discretizes the domain into a Cartesian grid of $N \\times N \\times N$ voxels, each of size $h = L/N$.\n\nA voxel is considered part of the solid phase if its center $(x_i, y_j, z_k)$ satisfies the condition $x_i^2 + y_j^2 + z_k^2 \\le R^2$. This creates a binary phase map representing the geometry.\n\nThe interfacial area, $A_{\\mathrm{voxel}}$, is approximated by counting the number of faces shared between a solid voxel and an electrolyte voxel and multiplying by the area of a voxel face, $h^2$. This is performed by iterating through the grid and summing the differences between adjacent voxels along each of the three principal axes ($x$, $y$, $z$).\n$$A_{\\mathrm{voxel}} = h^2 \\left( \\sum_{i,j,k} |\\text{phase}_{i+1,j,k} - \\text{phase}_{i,j,k}| + \\sum_{i,j,k} |\\text{phase}_{i,j+1,k} - \\text{phase}_{i,j,k}| + \\sum_{i,j,k} |\\text{phase}_{i,j,k+1} - \\text{phase}_{i,j,k}| \\right)$$\nThe corresponding surface-to-volume ratio is:\n$$S_{v,\\mathrm{voxel}} = \\frac{A_{\\mathrm{voxel}}}{L^3}$$\nThe mean curvature, $H_{\\mathrm{voxel}}$, is computed numerically. The procedure begins by constructing a signed distance function (SDF), $\\phi$, on the grid. This is achieved using Euclidean distance transforms from both the solid and electrolyte phases. The value of $\\phi$ at each voxel center is its shortest Euclidean distance to the interface, with a negative sign inside the solid and a positive sign in the electrolyte.\nTo compute a stable curvature, which involves second derivatives of the geometry, the raw SDF $\\phi$ is first smoothed using a Gaussian filter. This regularization step mitigates the numerical instabilities arising from the staircase-like discrete interface. Let the smoothed SDF be $\\phi_s$.\nThe unit normal vector field, $\\mathbf{n}$, is the normalized gradient of the smoothed SDF:\n$$\\mathbf{n} = \\frac{\\nabla \\phi_s}{\\|\\nabla \\phi_s\\|}$$\nThe gradients are computed using a second-order central difference scheme, with the correct physical scaling factor $h$. The mean curvature field is the divergence of the normal field:\n$$H(\\mathbf{x}) = \\nabla \\cdot \\mathbf{n} = \\frac{\\partial n_x}{\\partial x} + \\frac{\\partial n_y}{\\partial y} + \\frac{\\partial n_z}{\\partial z}$$\nAgain, each partial derivative is computed using central differences. The final scalar value, $H_{\\mathrm{voxel}}$, is obtained by averaging the absolute value of the computed mean curvature, $|H(\\mathbf{x})|$, over all voxels considered to be at the interface. The interface region is defined as the set of voxels where the value of the original (unsmoothed) SDF satisfies $|\\phi| \\le h$.\n$$H_{\\mathrm{voxel}} = \\text{mean}(|H(\\mathbf{x})|) \\quad \\forall \\mathbf{x} \\text{ s.t. } |\\phi(\\mathbf{x})| \\le h$$\nWith the numerically determined $S_{v,\\mathrm{voxel}}$ and $H_{\\mathrm{voxel}}$, the volumetric current density $j_{\\mathrm{vol,voxel}}$ is calculated analogously to the curved-element case. The single scalar value $H_{\\mathrm{voxel}}$ is used in the model for the exchange current density:\n$$j_{0,\\mathrm{voxel}} = j_{0,\\mathrm{flat}}\\left(1 + \\ell_c \\, H_{\\mathrm{voxel}}\\right)$$\n$$\\overline{j_{\\mathrm{area,voxel}}} = j_{0,\\mathrm{voxel}}\\left[\\exp\\left(\\frac{\\alpha_a F \\eta}{R_g T}\\right) - \\exp\\left(-\\frac{\\alpha_c F \\eta}{R_g T}\\right)\\right]$$\n$$j_{\\mathrm{vol,voxel}} = S_{v,\\mathrm{voxel}} \\, \\overline{j_{\\mathrm{area,voxel}}}$$\n\n**3. Difference Metrics**\n\nThe purpose of this exercise is to quantify the error introduced by the voxel-based approximation. This is achieved by calculating the differences between the numerical and analytical results for each test case $(L, N, R)$:\n$$\\Delta S_v = S_{v,\\mathrm{voxel}} - S_{v,\\mathrm{curved}}$$\n$$\\Delta H = H_{\\mathrm{voxel}} - H_{\\mathrm{curved}}$$\n$$\\Delta j_{\\mathrm{vol}} = j_{\\mathrm{vol,voxel}} - j_{\\mathrm{vol,curved}}$$\nThese differences provide a direct measure of the discretization error on the key geometric and kinetic indicators.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.ndimage import distance_transform_edt, gaussian_filter\n\ndef compute_deltas(L, N, R, j0_flat, ell_c, alpha_a, alpha_c, F, Rg, T, eta):\n    \"\"\"\n    Computes differences in Sv, H, and j_vol between voxel and curved representations.\n    \"\"\"\n    # --- Part 1: Curved-element (Analytical) Calculations ---\n    V = L**3\n    A_curved = 4.0 * np.pi * R**2\n    S_v_curved = A_curved / V\n    H_curved = 2.0 / R\n\n    bv_term = np.exp((alpha_a * F * eta) / (Rg * T)) - np.exp(-(alpha_c * F * eta) / (Rg * T))\n    \n    j0_curved = j0_flat * (1.0 + ell_c * H_curved)  # H_curved is positive for R > 0\n    j_area_curved = j0_curved * bv_term\n    j_vol_curved = S_v_curved * j_area_curved\n\n    # --- Part 2: Voxel-based (Numerical) Calculations ---\n    h = L / N\n    \n    # 2.1. Grid and Phase Map Generation\n    coords_1d = np.arange(-L/2 + h/2, L/2, h)\n    xx, yy, zz = np.meshgrid(coords_1d, coords_1d, coords_1d, indexing='ij')\n    phase_map = (xx**2 + yy**2 + zz**2 <= R**2).astype(np.int8)\n\n    # 2.2. Voxel-based Area and Sv\n    diff_x = np.abs(np.diff(phase_map, axis=0))\n    diff_y = np.abs(np.diff(phase_map, axis=1))\n    diff_z = np.abs(np.diff(phase_map, axis=2))\n    A_voxel = (np.sum(diff_x) + np.sum(diff_y) + np.sum(diff_z)) * h**2\n    S_v_voxel = A_voxel / V\n\n    # 2.3. Voxel-based Mean Curvature H\n    # The `sampling` argument in distance_transform_edt ensures output is in physical units\n    dist_from_solid = distance_transform_edt(phase_map == 0, sampling=h)\n    dist_from_electrolyte = distance_transform_edt(phase_map == 1, sampling=h)\n    phi_raw = dist_from_electrolyte - dist_from_solid\n\n    # Smooth the SDF with a Gaussian filter (sigma in voxel units)\n    # sigma=1 is a standard choice for \"small\" filter\n    phi_smooth = gaussian_filter(phi_raw, sigma=1.0)\n    \n    # Compute gradient of smoothed SDF. np.gradient uses central differences.\n    grad_phi = np.gradient(phi_smooth, h) # Spacing h\n    \n    # Compute normal vector field\n    norm_grad_phi = np.sqrt(grad_phi[0]**2 + grad_phi[1]**2 + grad_phi[2]**2)\n    epsilon = 1e-15  # Avoid division by zero\n    nx = grad_phi[0] / (norm_grad_phi + epsilon)\n    ny = grad_phi[1] / (norm_grad_phi + epsilon)\n    nz = grad_phi[2] / (norm_grad_phi + epsilon)\n\n    # Compute divergence of the normal field (Mean Curvature)\n    dnx_dx = np.gradient(nx, h, axis=0)\n    dny_dy = np.gradient(ny, h, axis=1)\n    dnz_dz = np.gradient(nz, h, axis=2)\n    divergence_n = dnx_dx + dny_dy + dnz_dz\n\n    # Average absolute curvature over the interface region\n    interface_mask = np.abs(phi_raw) <= h\n    \n    if np.sum(interface_mask) > 0:\n        H_voxel = np.mean(np.abs(divergence_n[interface_mask]))\n    else:  # This case should not occur for the given test problems\n        H_voxel = 0.0\n\n    # 2.4. Voxel-based Volumetric Current Density\n    # Use the single averaged H_voxel value as per the problem statement\n    j0_voxel = j0_flat * (1.0 + ell_c * H_voxel)\n    j_area_voxel = j0_voxel * bv_term\n    j_vol_voxel = S_v_voxel * j_area_voxel\n\n    # --- Part 3: Compute Differences ---\n    delta_Sv = S_v_voxel - S_v_curved\n    delta_H = H_voxel - H_curved\n    delta_j = j_vol_voxel - j_vol_curved\n    \n    return [delta_Sv, delta_H, delta_j]\n\ndef solve():\n    # Define constants from the problem statement\n    j0_flat = 1.5           # A/m^2\n    ell_c = 5.0e-7          # m\n    alpha_a = 0.5           # dimensionless\n    alpha_c = 0.5           # dimensionless\n    F = 96485.0             # C/mol\n    Rg = 8.314              # J/(mol*K)\n    T = 298.0               # K\n    eta = 0.02              # V\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (L, N, R)\n        (50e-6, 64, 10e-6), # Case 1\n        (50e-6, 16, 10e-6), # Case 2\n        (50e-6, 64, 3e-6),  # Case 3\n        (50e-6, 64, 20e-6), # Case 4\n    ]\n\n    results = []\n    for L, N, R in test_cases:\n        case_deltas = compute_deltas(L, N, R, j0_flat, ell_c, alpha_a, alpha_c, F, Rg, T, eta)\n        results.append(case_deltas)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "This practice brings together the concepts of meshing and physical modeling in a complete simulation workflow. You will implement a numerical solver for a steady-state reaction-diffusion equation on an image-defined pore geometry to investigate a real-world phenomenon: transport limitation in confined spaces. By analyzing how a narrow pore \"throat\" impacts concentration gradients and creates reaction heterogeneity, you will gain hands-on experience in using image-based simulation to connect microscopic structural features to macroscopic electrochemical performance and explore potential design mitigations .",
            "id": "3919446",
            "problem": "You are given the task of numerically analyzing confinement effects on diffusion and reaction within an electrolyte-filled pore channel representative of a porous battery electrode microstructure. Starting from the foundational base formed by Fick's law of diffusion and species conservation, derive and implement a two-dimensional image-based meshing and numerical simulation of steady-state transport and first-order reaction. The governing equations and boundary conditions must be formulated and discretized on a grid derived from a binary image representing the pore geometry, and the metrics of heterogeneity and utilization must be computed to evaluate the effects of narrow pore throats and proposed mitigations by design.\n\nFundamental base:\n- Fick's law for diffusive flux: $ \\mathbf{J} = - D(\\mathbf{x}) \\nabla c(\\mathbf{x}) $.\n- Steady-state species conservation with first-order volumetric reaction rate: $ \\nabla \\cdot \\mathbf{J} - k(\\mathbf{x}) \\, c(\\mathbf{x}) = 0 $.\nCombining both yields the steady-state reaction-diffusion equation: $ - \\nabla \\cdot \\left( D(\\mathbf{x}) \\nabla c(\\mathbf{x}) \\right) + k(\\mathbf{x}) \\, c(\\mathbf{x}) = 0 $.\n\nGeometry and image-based meshing:\n- Construct a binary image of a rectangular domain of dimensions $ L_x \\times L_y $ where $ L_x $ and $ L_y $ are the domain lengths in meters. Discretize into $ N_x \\times N_y $ grid cells with uniform spacing $ \\Delta x = L_x / N_x $ and $ \\Delta y = L_y / N_y $.\n- The pore geometry is defined as a channel centered at $ y = L_y/2 $ with width $ w(x) $ that is wide except for a central throat region of length $ L_\\text{throat} $ centered at $ x = L_x/2 $. Specifically, let $ w(x) = w_\\text{throat} $ for $ x \\in [L_x/2 - L_\\text{throat}/2, \\, L_x/2 + L_\\text{throat}/2] $, and $ w(x) = w_\\text{wide} $ elsewhere. The binary image mask $ \\chi(i,j) \\in \\{0,1\\} $ marks pore cells where $ \\chi = 1 $ and solid (non-transport) cells where $ \\chi = 0 $.\n\nTransport and reaction parameters:\n- The concentration field $ c(\\mathbf{x}) $ is in mol per cubic meter. The diffusivity $ D(\\mathbf{x}) $ is in square meters per second, and the reaction rate constant $ k(\\mathbf{x}) $ is in inverse seconds.\n- Inside the pore, $ D(\\mathbf{x}) = D_0 $ except within the throat region where $ D(\\mathbf{x}) = D_0 \\, m_\\text{throat} $, with $ m_\\text{throat} $ being a dimensionless multiplier to represent a local coating or porosity enhancement as a mitigation design.\n- The reaction rate constant is uniform within the pore, $ k(\\mathbf{x}) = k_0 $; optionally, a mitigation can set $ k(\\mathbf{x}) = k_0 \\, m_{k,\\text{throat}} $ within the throat to grade the reaction.\n\nBoundary conditions:\n- Apply Dirichlet boundary conditions: $ c = c_\\text{left} $ on the left domain boundary ($ x = 0 $) and $ c = c_\\text{right} $ on the right boundary ($ x = L_x $), only where these boundaries intersect pore cells ($ \\chi = 1 $).\n- Apply homogeneous Neumann (no-flux) boundary conditions at the top and bottom boundaries ($ y = 0 $ and $ y = L_y $), and treat solid walls ($ \\chi = 0 $ adjacent to $ \\chi = 1 $) as impermeable no-flux interfaces.\n\nDiscretization requirements:\n- Derive a second-order accurate discrete system using the Finite Difference (FD) method for the Partial Differential Equation (PDE), on the active pore cells indicated by the binary image mask. Use face-based harmonic averaging for diffusivity to preserve flux continuity: for two adjacent pore cells with diffusivities $ D_1 $ and $ D_2 $, the face diffusivity must be $ D_f = \\left( \\frac{1}{2} \\left( \\frac{1}{D_1} + \\frac{1}{D_2} \\right) \\right)^{-1} $.\n- For a Dirichlet boundary face with prescribed concentration $ c_b $, the discrete flux contribution across the face must be included using the local cell diffusivity at that boundary, yielding a term proportional to $ \\frac{D_\\text{cell}}{\\Delta x^2} c_b $ or $ \\frac{D_\\text{cell}}{\\Delta y^2} c_b $ depending on orientation. For homogeneous Neumann faces, impose zero flux by omitting any neighbor coupling across that face.\n- Assemble the linear system $ \\mathbf{A} \\mathbf{c} = \\mathbf{b} $ over the pore cells, with the reaction term contributing $ k(\\mathbf{x}) $ to the diagonal entries.\n\nMetrics to compute:\n- Compute the local volumetric reaction rate $ r(\\mathbf{x}) = k(\\mathbf{x}) \\, c(\\mathbf{x}) $ within the pore (in mol per cubic meter per second).\n- Compute the heterogeneity metric as the Coefficient of Variation (CV): $ \\mathrm{CV} = \\frac{\\sigma_r}{\\mu_r} $, where $ \\sigma_r $ is the standard deviation and $ \\mu_r $ is the mean of $ r(\\mathbf{x}) $ over all pore cells ($ \\chi = 1 $). This is dimensionless.\n- Compute the injection flux from the left boundary by summing diffusive fluxes across all left boundary faces intersecting the pore. For a left boundary face at cell $ (i,j) $ with $ i = 0 $, use $ J_\\text{left}(j) = \\frac{D(i,j)}{\\Delta x} \\left[ c_\\text{left} - c(i,j) \\right] $ in mol per square meter per second, and integrate along the boundary by multiplying by the face length $ \\Delta y $, then summing over $ j $. Compute the total volumetric reaction consumption $ R = \\sum_{i,j} k(i,j) \\, c(i,j) \\, \\Delta x \\, \\Delta y $ in mol per second. The utilization fraction is $ U = R / \\left( \\sum_j J_\\text{left}(j) \\, \\Delta y \\right) $, which is dimensionless and must be reported as a decimal.\n- All reported metrics must be dimensionless decimals.\n\nUnits:\n- Express all lengths in meters, diffusivity in square meters per second, reaction rate constants in inverse seconds, and concentration in mol per cubic meter. The final requested outputs are dimensionless and must be reported as decimal numbers.\n\nTest suite:\nImplement the following parameter sets, representing a happy path, confinement-dominated cases, and mitigation designs. The domain and base parameters are shared unless otherwise noted.\n- Shared domain and base parameters: $ L_x = 100 \\times 10^{-6} $ m, $ L_y = 50 \\times 10^{-6} $ m, $ N_x = 200 $, $ N_y = 100 $, $ D_0 = 1.0 \\times 10^{-10} $ m$^2$/s, $ k_0 = 100 $ s$^{-1} $, $ c_\\text{left} = 1000 $ mol/m$^3$, $ c_\\text{right} = 0 $ mol/m$^3$, $ L_\\text{throat} = 0.2 \\, L_x $, $ w_\\text{wide} = 0.8 \\, L_y $, $ m_{k,\\text{throat}} = 1 $.\n- Case $1$ (happy path): $ w_\\text{throat} = 0.3 \\, L_y $, $ m_\\text{throat} = 1 $.\n- Case $2$ (narrow throat, confinement): $ w_\\text{throat} = 0.05 \\, L_y $, $ m_\\text{throat} = 1 $.\n- Case $3$ (mitigation by widening): $ w_\\text{throat} = 0.15 \\, L_y $, $ m_\\text{throat} = 1 $.\n- Case $4$ (mitigation by local diffusivity enhancement): $ w_\\text{throat} = 0.05 \\, L_y $, $ m_\\text{throat} = 3.0 $.\n- Case $5$ (extreme edge case, single-cell throat): $ w_\\text{throat} = \\Delta y $, $ m_\\text{throat} = 1 $.\n\nAnswer specification:\n- For each test case, compute $ \\mathrm{CV} $ and $ U $ as defined above and return the pair $ [\\mathrm{CV}, U] $. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element corresponds to one test case and is itself a two-element list. For example: $ [ [\\mathrm{CV}_1, U_1], [\\mathrm{CV}_2, U_2], \\dots ] $.",
            "solution": "The problem presented is a comprehensive and well-posed exercise in computational transport phenomena, specifically focusing on the numerical solution of a two-dimensional, steady-state reaction-diffusion partial differential equation (PDE) on a complex domain defined by a binary image. The problem is scientifically grounded in the principles of mass conservation and Fickian diffusion, and its parameters are physically realistic for electrochemical systems. The specified numerical method, the Finite Difference Method (FDM) on a cell-centered grid using harmonic averaging for interface diffusivity, is a standard and robust technique for this class of problems. The boundary conditions are clearly defined, and the metrics for performance evaluation—heterogeneity and utilization—are relevant and unambiguously specified. The problem is therefore deemed valid.\n\nThe solution will be developed by first deriving the discretized form of the governing PDE and then outlining the computational algorithm to construct and solve the resulting linear system.\n\nThe governing PDE combines Fick's law, $ \\mathbf{J} = -D(\\mathbf{x}) \\nabla c(\\mathbf{x}) $, with the steady-state species conservation equation, $ \\nabla \\cdot \\mathbf{J} - k(\\mathbf{x}) c(\\mathbf{x}) = 0 $, to yield:\n$$\n- \\nabla \\cdot \\left( D(\\mathbf{x}) \\nabla c(\\mathbf{x}) \\right) + k(\\mathbf{x}) c(\\mathbf{x}) = 0\n$$\nwhere $c(\\mathbf{x})$ is the species concentration, $D(\\mathbf{x})$ is the spatially varying diffusivity, and $k(\\mathbf{x})$ is the first-order reaction rate constant.\n\nTo solve this PDE numerically, we employ a cell-centered finite volume method, which is equivalent to the finite difference method for this structured grid problem. We discretize the domain into a grid of $N_x \\times N_y$ cells, each of volume $ \\Delta V = \\Delta x \\Delta y $ (for a unit depth). For a given cell $(i,j)$, we integrate the PDE over its control volume $ \\Omega_{ij} $.\n$$\n\\int_{\\Omega_{ij}} \\left( - \\nabla \\cdot (D \\nabla c) + k c \\right) \\, dV = 0\n$$\nApplying the divergence theorem to the first term, we obtain a balance of fluxes across the cell faces and the volumetric reaction within the cell:\n$$\n- \\oint_{\\partial \\Omega_{ij}} (D \\nabla c) \\cdot \\mathbf{n} \\, dS + \\int_{\\Omega_{ij}} k c \\, dV = 0\n$$\nApproximating the integrals for a cell $(i,j)$ with cell-centered values $c_{i,j}$, $D_{i,j}$, and $k_{i,j}$, the equation becomes:\n$$\n- (J_e - J_w)\\Delta y - (J_n - J_s)\\Delta x + k_{i,j} c_{i,j} \\Delta x \\Delta y = 0\n$$\nHere, $J_e, J_w, J_n, J_s$ are the flux densities on the east, west, north, and south faces of the cell, respectively. These are approximated using second-order finite differences. For example, the flux on the east face between cell $(i,j)$ and $(i+1,j)$ is:\n$$\nJ_e \\approx -D_{i+1/2, j} \\frac{c_{i+1,j} - c_{i,j}}{\\Delta x}\n$$\nThe face diffusivity $D_{i+1/2, j}$ is calculated using the harmonic mean of the diffusivities of the adjacent cells, as specified, to ensure flux continuity:\n$$\nD_{i+1/2, j} = \\left( \\frac{1}{2} \\left( \\frac{1}{D_{i,j}} + \\frac{1}{D_{i+1,j}} \\right) \\right)^{-1} = \\frac{2 D_{i,j} D_{i+1,j}}{D_{i,j} + D_{i+1,j}}\n$$\nSubstituting the flux approximations for all four faces into the balance equation and dividing by the cell volume $ \\Delta x \\Delta y $ leads to the discrete algebraic equation for cell $(i,j)$:\n$$\n\\frac{1}{\\Delta x^2} \\left( D_{i-1/2, j}(c_{i,j} - c_{i-1,j}) - D_{i+1/2, j}(c_{i+1,j} - c_{i,j}) \\right) + \\frac{1}{\\Delta y^2} \\left( D_{i, j-1/2}(c_{i,j} - c_{i,j-1}) - D_{i, j+1/2}(c_{i,j+1} - c_{i,j}) \\right) + k_{i,j} c_{i,j} = 0\n$$\nRearranging this equation to group terms by concentration variables gives the stencil for the linear system. For a central node $c_{i,j}$, the equation is:\n$$\n\\left( \\frac{D_{i+1/2,j}}{\\Delta x^2} + \\frac{D_{i-1/2,j}}{\\Delta x^2} + \\frac{D_{i,j+1/2}}{\\Delta y^2} + \\frac{D_{i,j-1/2}}{\\Delta y^2} + k_{i,j} \\right) c_{i,j} - \\frac{D_{i+1/2,j}}{\\Delta x^2}c_{i+1,j} - \\frac{D_{i-1/2,j}}{\\Delta x^2}c_{i-1,j} - \\frac{D_{i,j+1/2}}{\\Delta y^2}c_{i,j+1} - \\frac{D_{i,j-1/2}}{\\Delta y^2}c_{i,j-1} = 0\n$$\nThis linear equation is formulated for every active pore cell in the domain, identified by the mask $ \\chi(i,j)=1 $. The collection of these equations forms a large, sparse linear system of the form $ \\mathbf{A} \\mathbf{c} = \\mathbf{b} $, where $ \\mathbf{c} $ is a vector of the unknown concentrations in the pore cells.\n\nThe matrix $ \\mathbf{A} $ and vector $ \\mathbf{b} $ are constructed as follows:\n1.  **Unknowns**: The set of unknowns comprises the concentrations $c_{i,j}$ for all cells $(i,j)$ where $\\chi(i,j)=1$. We map each 2D grid index $(i,j)$ to a single linear index $p$.\n2.  **Internal Cells**: For an internal pore cell surrounded by other pore cells, the equation above defines the $p$-th row of matrix $ \\mathbf{A} $. The diagonal element $A_{p,p}$ is the coefficient of $c_{i,j}$, and the off-diagonal elements are the negative coefficients of the neighboring concentrations. The corresponding entry $b_p$ is $0$.\n3.  **Boundary Conditions**:\n    *   **No-flux (Neumann)**: For a pore cell adjacent to a solid wall ($\\chi=0$) or a top/bottom domain boundary, the flux across that face is zero. This is achieved by setting the corresponding face diffusivity to zero (e.g., $D_{i+1/2,j}=0$ if cell $(i+1,j)$ is solid). The corresponding term vanishes from the equation, correctly implementing the no-flux condition.\n    *   **Fixed Concentration (Dirichlet)**: At the left ($x=0$) and right ($x=L_x$) boundaries, the concentration is prescribed as $c_\\text{left}$ and $c_\\text{right}$, respectively. For a cell $(0,j)$ at the left boundary, the term involving the west-side neighbor $c_{-1,j}$ becomes a known quantity. Following the problem's prescription, the face diffusivity is approximated by the cell diffusivity, $D_{-1/2,j} \\approx D_{0,j}$, and the term $\\frac{D_{0,j}}{\\Delta x^2} c_\\text{left}$ is moved to the right-hand side of the equation, contributing to the vector $ \\mathbf{b} $. A similar treatment applies to the right boundary.\n\nThe computational procedure to solve the problem for each test case is as follows:\n1.  **Setup**: Define the domain and discretization parameters ($L_x, L_y, N_x, N_y, \\Delta x, \\Delta y$).\n2.  **Geometry and Parameters**: For a given case, construct the binary mask $\\chi_{i,j}$ by checking if each cell's center $(x_c, y_c) = ((i+0.5)\\Delta x, (j+0.5)\\Delta y)$ falls within the specified channel geometry: $|y_c - L_y/2| \\le w(x_c)/2$. Then, construct the corresponding diffusivity $D_{i,j}$ and reaction rate $k_{i,j}$ arrays.\n3.  **Matrix Assembly**: Create a mapping from active cell coordinates $(i,j)$ to linear indices $p=0, \\dots, N_p-1$, where $N_p$ is the total number of pore cells. Initialize a sparse matrix $\\mathbf{A}$ and a vector $\\mathbf{b}$. Iterate through each active cell and populate the corresponding row in $\\mathbf{A}$ and $\\mathbf{b}$ based on its neighbors and boundary conditions, as derived above.\n4.  **Solve**: Solve the linear system $ \\mathbf{A} \\mathbf{c} = \\mathbf{b} $ for the concentration vector $\\mathbf{c}$ using a sparse linear algebra solver. Map the solution vector back to a 2D grid $c_{i,j}$.\n5.  **Metrics Calculation**:\n    *   Compute the local reaction rate for all pore cells: $r_{i,j} = k_{i,j} c_{i,j}$.\n    *   Calculate the heterogeneity metric, the Coefficient of Variation ($ \\mathrm{CV} $), from the mean $\\mu_r$ and standard deviation $\\sigma_r$ of the reaction rates: $\\mathrm{CV} = \\sigma_r / \\mu_r$.\n    *   Calculate the total reaction consumption rate $ R = \\sum_{i,j | \\chi=1} k_{i,j} c_{i,j} \\Delta x \\Delta y $.\n    *   Calculate the total influx from the left boundary $J_\\text{in} = \\sum_{j | \\chi(0,j)=1} \\frac{D_{0,j}}{\\Delta x}(c_\\text{left} - c_{0,j}) \\Delta y$.\n    *   Compute the utilization fraction $ U = R / J_\\text{in} $.\nThe resulting pair $[\\mathrm{CV}, U]$ is stored for each case. The final output is an aggregation of these results.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import lil_matrix\nfrom scipy.sparse.linalg import spsolve\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation for all test cases and print the results.\n    \"\"\"\n    \n    # Shared domain and base parameters\n    shared_params = {\n        'Lx': 100e-6, 'Ly': 50e-6,\n        'Nx': 200, 'Ny': 100,\n        'D0': 1.0e-10, 'k0': 100.0,\n        'c_left': 1000.0, 'c_right': 0.0,\n        'L_throat': 0.2 * 100e-6,\n        'w_wide': 0.8 * 50e-6,\n        'm_k_throat': 1.0\n    }\n\n    dx = shared_params['Lx'] / shared_params['Nx']\n    \n    # Test cases\n    test_cases = [\n        {'w_throat': 0.3 * 50e-6, 'm_throat': 1.0},        # Case 1\n        {'w_throat': 0.05 * 50e-6, 'm_throat': 1.0},       # Case 2\n        {'w_throat': 0.15 * 50e-6, 'm_throat': 1.0},       # Case 3\n        {'w_throat': 0.05 * 50e-6, 'm_throat': 3.0},       # Case 4\n        {'w_throat': shared_params['Ly'] / shared_params['Ny'], 'm_throat': 1.0} # Case 5\n    ]\n\n    results = []\n    for case_params in test_cases:\n        params = {**shared_params, **case_params}\n        cv, u = run_simulation(params)\n        results.append([cv, u])\n    \n    # Format the final output string\n    formatted_results = [f\"[{cv:.6f},{u:.6f}]\" for cv, u in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\n\ndef run_simulation(params):\n    \"\"\"\n    Performs a single reaction-diffusion simulation for a given parameter set.\n    \"\"\"\n    Lx, Ly = params['Lx'], params['Ly']\n    Nx, Ny = params['Nx'], params['Ny']\n    dx, dy = Lx / Nx, Ly / Ny\n    \n    # === 1. Geometry and Parameter Maps ===\n    \n    # Create coordinate arrays for cell centers\n    x = (np.arange(Nx) + 0.5) * dx\n    y = (np.arange(Ny) + 0.5) * dy\n    \n    # Define throat region in x\n    x_throat_min = Lx/2 - params['L_throat']/2\n    x_throat_max = Lx/2 + params['L_throat']/2\n    \n    # Create binary mask `chi`, D_map, and k_map\n    chi = np.zeros((Nx, Ny), dtype=int)\n    D_map = np.zeros((Nx, Ny))\n    k_map = np.zeros((Nx, Ny))\n    \n    is_throat_x = (x >= x_throat_min) & (x < x_throat_max)\n    \n    for i in range(Nx):\n        width = params['w_throat'] if is_throat_x[i] else params['w_wide']\n        is_pore_y = np.abs(y - Ly/2) <= width/2\n        \n        chi[i, :] = is_pore_y.astype(int)\n        \n        D_val = params['D0'] * (params['m_throat'] if is_throat_x[i] else 1.0)\n        k_val = params['k0'] * (params['m_k_throat'] if is_throat_x[i] else 1.0)\n        \n        D_map[i, :] = D_val * is_pore_y\n        k_map[i, :] = k_val * is_pore_y\n\n    # === 2. Matrix Assembly ===\n    \n    # Map (i,j) grid indices of active cells to a linear index p\n    pore_indices = np.where(chi == 1)\n    num_pores = len(pore_indices[0])\n    ij_to_p = { (i, j): p for p, (i, j) in enumerate(zip(*pore_indices)) }\n\n    A = lil_matrix((num_pores, num_pores))\n    b = np.zeros(num_pores)\n\n    dx2, dy2 = dx**2, dy**2\n\n    for i, j in zip(*pore_indices):\n        p = ij_to_p[(i, j)]\n        \n        diag_sum = 0\n        \n        # Neighbors: (di, dj), coefficient pre-factor\n        neighbors = [\n            ((1, 0), 1/dx2),  # East\n            ((-1, 0), 1/dx2), # West\n            ((0, 1), 1/dy2),  # North\n            ((0, -1), 1/dy2)  # South\n        ]\n\n        for (di, dj), prefactor in neighbors:\n            ni, nj = i + di, j + dj\n            \n            # Check domain boundaries\n            if not (0 <= ni < Nx and 0 <= nj < Ny):\n                # Dirichlet BCs on West/East boundary\n                if ni < 0: # West boundary\n                    c_boundary = params['c_left']\n                    d_face = D_map[i, j] # Use cell diff as per spec\n                    term = d_face * prefactor\n                    diag_sum += term\n                    b[p] += term * c_boundary\n                elif ni >= Nx: # East boundary\n                    c_boundary = params['c_right']\n                    d_face = D_map[i, j]\n                    term = d_face * prefactor\n                    diag_sum += term\n                    b[p] += term * c_boundary\n                # Neumann (no-flux) on North/South, do nothing.\n                continue\n\n            # Check for internal solid-pore interface\n            if chi[ni, nj] == 1:\n                # Harmonic mean for face diffusivity\n                d1, d2 = D_map[i, j], D_map[ni, nj]\n                d_face = 2 * d1 * d2 / (d1 + d2) if (d1 + d2) > 0 else 0\n                term = d_face * prefactor\n                \n                diag_sum += term\n                A[p, ij_to_p[(ni, nj)]] = -term\n            # If chi[ni, nj] == 0, it's a no-flux wall, so d_face = 0. Do nothing.\n\n        # Add reaction term to diagonal\n        diag_sum += k_map[i, j]\n        A[p, p] = diag_sum\n\n    # === 3. Solve the system ===\n    A_csr = A.tocsr()\n    c_vector = spsolve(A_csr, b)\n\n    # === 4. Post-processing and Metrics Calculation ===\n    c_grid = np.zeros((Nx, Ny))\n    c_grid[pore_indices] = c_vector\n\n    # Local reaction rates\n    r_grid = k_map * c_grid\n    pore_r = r_grid[pore_indices]\n    \n    # CV\n    mu_r = np.mean(pore_r)\n    sigma_r = np.std(pore_r)\n    cv = sigma_r / mu_r if mu_r > 0 else 0.0\n\n    # Utilization\n    total_reaction = np.sum(pore_r) * dx * dy\n\n    left_bnd_j = np.where(chi[0, :] == 1)[0]\n    D_left = D_map[0, left_bnd_j]\n    c_left_cells = c_grid[0, left_bnd_j]\n    \n    J_left = (D_left / dx) * (params['c_left'] - c_left_cells)\n    total_influx = np.sum(J_left) * dy\n    \n    utilization = total_reaction / total_influx if total_influx > 0 else 0.0\n    \n    return cv, utilization\n\n# Run the main function when the script is executed.\nif __name__ == \"__main__\":\n    solve()\n\n```"
        }
    ]
}