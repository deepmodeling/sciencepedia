{
    "hands_on_practices": [
        {
            "introduction": "构建数据驱动的降阶模型（ROM）的第一步，是从高保真度的模拟数据中提取一个低维基。本练习将引导您完成本征正交分解（Proper Orthogonal Decomposition, POD）的完整工作流程，从生成快照到使用奇异值分解（Singular Value Decomposition, SVD）创建最优基。您将实现一个常见的基于能量的准则来选择模型的阶数，并直接观察ROM的精度与其计算成本之间的基本权衡关系 。",
            "id": "3943087",
            "problem": "您的任务是为一个线性扩散过程实现基于投影的降阶模型的阶数选择。该过程代表了自动化电池设计和模拟中的固相锂浓度动力学。请从以下基本框架开始。\n\n考虑由以下抛物线型偏微分方程建模的固相浓度一维扩散过程：$$\\frac{\\partial c(x,t)}{\\partial t} = D \\frac{\\partial^2 c(x,t)}{\\partial x^2} + s(t),$$ 其中，$c(x,t)$ 是浓度，$D$ 是扩散系数，$s(t)$ 是一个空间均匀的源项，代表与施加电流成正比的嵌入速率。假设为零通量 (Neumann) 边界条件：$$\\frac{\\partial c(0,t)}{\\partial x} = 0,\\quad \\frac{\\partial c(L,t)}{\\partial x} = 0,$$ 以及初始条件 $c(x,0) = 0$。\n\n使用线方法，通过 $n$ 个等距节点对空间域 $[0,L]$ 进行离散化，以获得一个半离散线性时不变系统。令 $\\Delta x$ 为空间步长，状态向量为 $\\mathbf{x}(t) \\in \\mathbb{R}^n$，用于近似网格点上的 $c(x,t)$。该半离散动力学可写作：$$\\frac{d\\mathbf{x}(t)}{dt} = A \\mathbf{x}(t) + B u(t),$$ 其中，$A \\in \\mathbb{R}^{n \\times n}$ 是表示带有零通量边界调整的空间二阶导数的三对角矩阵，$B \\in \\mathbb{R}^{n}$ 是一个均匀源向量，$u(t)$ 是对应于嵌入速率的标量输入。将输出定义为空间平均值：$$y(t) = C \\mathbf{x}(t),$$ 其中 $C = \\frac{1}{n} [1,1,\\dots,1] \\in \\mathbb{R}^{1 \\times n}$。使用显式欧拉时间步进法，时间步长 $h$ 满足扩散方程的典型稳定性极限。具体来说，离散时间更新为：$$\\mathbf{x}_{k+1} = \\mathbf{x}_k + h(A \\mathbf{x}_k + B u_k),$$ 输出为：$$y_k = C \\mathbf{x}_k.$$\n\n通过堆叠 $m$ 个连续时间步的状态向量，从训练模拟中收集一个快照矩阵 $X \\in \\mathbb{R}^{n \\times m}$：$$X = [\\mathbf{x}_1, \\mathbf{x}_2, \\dots, \\mathbf{x}_m].$$ 计算 $X$ 的奇异值分解 (SVD; Singular Value Decomposition)：$$X = U \\Sigma V^\\top,$$ 其中 $U \\in \\mathbb{R}^{n \\times k}$ 包含左奇异向量，$\\Sigma \\in \\mathbb{R}^{k \\times k}$ 是对角矩阵，其奇异值为 $\\sigma_1 \\ge \\sigma_2 \\ge \\dots \\ge \\sigma_k \\ge 0$，$V \\in \\mathbb{R}^{m \\times k}$ 包含右奇异向量，且 $k = \\min(n,m)$。通过选择 $U$ 的前 $r$ 列，构建一个本征正交分解 (POD; Proper Orthogonal Decomposition) 基 $\\Phi_r \\in \\mathbb{R}^{n \\times r}$。使用 Galerkin 投影获得降阶模型 (ROM; Reduced-Order Model)：$$A_r = \\Phi_r^\\top A \\Phi_r,\\quad B_r = \\Phi_r^\\top B,\\quad C_r = C \\Phi_r,$$ 以及降阶动力学：$$\\mathbf{z}_{k+1} = \\mathbf{z}_k + h(A_r \\mathbf{z}_k + B_r u_k),\\quad y_k^{\\text{ROM}} = C_r \\mathbf{z}_k,$$ 其中 $\\mathbf{z}_k \\in \\mathbb{R}^r$ 是降阶状态。\n\n通过以下容差准则实现阶数选择：$$\\frac{\\sum_{i=1}^r \\sigma_i^2}{\\sum_{i=1}^k \\sigma_i^2} \\ge \\tau,$$ 即，对于给定的容差 $\\tau$（$0 \\le \\tau \\le 1$），选择使上述不等式成立的最小整数 $r$。如果 $\\tau = 1$，则设 $r = k$。如果 $\\tau = 0$，则设 $r = 1$。\n\n通过执行以下操作，分析容差 $\\tau$ 如何影响降阶模型的精度和计算成本：\n\n1. 在 $m$ 步的训练时域上，使用由正弦波组合构成的平滑输入 $u_k^{\\text{train}}$ 来生成训练快照。使用这些快照计算 SVD 和 POD 基。\n2. 使用一个由分段常数脉冲组成的不同评估输入 $u_k^{\\text{eval}}$，在相同步数上评估 ROM 精度，并计算输出序列 $y_k^{\\text{ROM}}$ 与全阶输出 $y_k$ 的对比。\n3. 将 ROM 精度度量定义为在整个评估时域上的相对均方根误差：$$\\varepsilon_{\\text{rel}} = \\sqrt{\\frac{\\sum_{k=1}^{m} \\left(y_k^{\\text{ROM}} - y_k\\right)^2}{\\sum_{k=1}^{m} y_k^2}}.$$ 将其报告为无量纲浮点数。\n4. 将在线模拟中每个时间步的计算成本代理定义为降阶稠密矩阵向量乘法次数与全阶三对角乘法次数之比：$$\\rho_{\\text{cost}} = \\frac{r^2}{3n}.$$ 此代理是无量纲的，它捕捉了稠密降阶动力学和带状全阶动力学之间的差异。\n\n使用以下物理上合理且自洽的参数：\n- 空间节点数 $n = 50$。\n- 域长度 $L = 5 \\times 10^{-6}$ 米。\n- 扩散系数 $D = 1 \\times 10^{-14}$ 平方米/秒。\n- 空间步长 $\\Delta x = \\frac{L}{n-1}$。\n- 时间步长 $h = 0.4 \\frac{\\Delta x^2}{D}$ 秒（保证显式欧拉法对扩散算子的稳定性）。\n- 训练和评估步数 $m = 300$。\n- 均匀源向量 $B = \\beta \\mathbf{1}$，其中 $\\beta = 1$（用于数值分析的无量纲缩放）。\n- 初始条件 $\\mathbf{x}_0 = \\mathbf{0}$。\n\n构建训练输入为：$$u_k^{\\text{train}} = a \\sin\\left(2\\pi \\frac{k}{m}\\right) + b \\sin\\left(4\\pi \\frac{k}{m}\\right),$$ 其中 $a = 1$ 且 $b = 0.5$。将评估输入构建为以下分段常数序列：对于 $k \\in \\{1,\\dots,m\\}$，$$u_k^{\\text{eval}} = \\begin{cases} u_1 & \\text{if } k \\le \\frac{m}{3}, \\\\ u_2 & \\text{if } \\frac{m}{3}  k \\le \\frac{2m}{3}, \\\\ u_3  \\text{if } k > \\frac{2m}{3}, \\end{cases}$$ 其中 $u_1 = 1$，$u_2 = -0.5$，$u_3 = 0.2$。\n\n测试套件和答案规范：\n- 使用以下容差值作为测试用例：$\\tau \\in \\{0, 0.1, 0.5, 0.9, 0.99, 1\\}$。\n- 对于每个 $\\tau$ 值，计算所选的阶数 $r$、相对误差 $\\varepsilon_{\\text{rel}}$ 和计算成本代理 $\\rho_{\\text{cost}}$，如上所定义。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例的结果本身就是一个形如 $[r,\\varepsilon_{\\text{rel}},\\rho_{\\text{cost}}]$ 的列表。例如，输出格式必须与以下完全一样：$[[r_1,\\varepsilon_1,\\rho_1],[r_2,\\varepsilon_2,\\rho_2],\\dots]$。\n\n所有计算都应使用实数进行。最终输出为无量纲的浮点数或整数，最终输出中不需要物理单位。",
            "solution": "用户提供了一个全面的问题陈述，用于实现和评估一维线性扩散过程的基于投影的降阶模型（ROM）。该任务涉及数值方法和模型降阶中的几个标准步骤：空间离散化、时间积分、快照生成、通过奇异值分解（SVD）进行的本征正交分解（POD）、Galerkin投影，以及最后对不同阶数下生成的降阶模型进行评估。阶数选择将基于应用于奇异值的能量容差准则进行。\n\n### 步骤1：提取给定信息\n- **控制偏微分方程：** $\\frac{\\partial c(x,t)}{\\partial t} = D \\frac{\\partial^2 c(x,t)}{\\partial x^2} + s(t)$\n- **边界条件：** 在 $x=0$ 和 $x=L$ 处的零通量 (Neumann) 边界条件：$\\frac{\\partial c(0,t)}{\\partial x} = 0, \\frac{\\partial c(L,t)}{\\partial x} = 0$。\n- **初始条件：** $c(x,0) = 0$。\n- **全阶模型（FOM）：** 半离散系统 $\\frac{d\\mathbf{x}(t)}{dt} = A \\mathbf{x}(t) + B u(t)$，输出为 $y(t) = C \\mathbf{x}(t)$。\n- **时间离散化：** 显式欧拉法，$\\mathbf{x}_{k+1} = \\mathbf{x}_k + h(A \\mathbf{x}_k + B u_k)$，输出为 $y_k = C \\mathbf{x}_k$。\n- **参数：**\n    - 空间节点：$n = 50$。\n    - 域长度：$L = 5 \\times 10^{-6}$ m。\n    - 扩散系数：$D = 1 \\times 10^{-14}$ m²/s。\n    - 空间步长：$\\Delta x = \\frac{L}{n-1}$。\n    - 时间步长：$h = 0.4 \\frac{\\Delta x^2}{D}$。\n    - 模拟步数：$m = 300$。\n    - 源向量：$B = \\beta \\mathbf{1}$，其中 $\\beta = 1$。\n    - 输出向量：$C = \\frac{1}{n} [1,1,\\dots,1]$。\n    - 初始状态：$\\mathbf{x}_0 = \\mathbf{0}$。\n- **训练输入：** 对于 $k \\in \\{1, \\dots, m\\}$，$u_k^{\\text{train}} = \\sin(2\\pi \\frac{k}{m}) + 0.5 \\sin(4\\pi \\frac{k}{m})$。\n- **评估输入：** 对于 $k \\in \\{1, \\dots, m\\}$，分段常数 $u_k^{\\text{eval}}$：当 $k \\le m/3$ 时为 $1$，当 $m/3  k \\le 2m/3$ 时为 $-0.5$，当 $k > 2m/3$ 时为 $0.2$。\n- **模型降阶：**\n    - 快照矩阵：$X = [\\mathbf{x}_1, \\dots, \\mathbf{x}_m]$。\n    - POD基 $\\Phi_r$ 来自 $X$ 的前 $r$ 个左奇异向量。\n    - Galerkin 投影：$A_r = \\Phi_r^\\top A \\Phi_r, B_r = \\Phi_r^\\top B, C_r = C \\Phi_r$。\n- **阶数选择：** 最小整数 $r$ 满足 $\\frac{\\sum_{i=1}^r \\sigma_i^2}{\\sum_{i=1}^k \\sigma_i^2} \\ge \\tau$。特殊情况：$\\tau=0$ 时 $r=1$，$\\tau=1$ 时 $r=k$，其中 $k=\\min(n,m)$。\n- **度量指标：**\n    - 相对误差：$\\varepsilon_{\\text{rel}} = \\sqrt{\\frac{\\sum_{k=1}^{m} (y_k^{\\text{ROM}} - y_k)^2}{\\sum_{k=1}^{m} y_k^2}}$。\n    - 成本代理：$\\rho_{\\text{cost}} = \\frac{r^2}{3n}$。\n- **测试用例：** $\\tau \\in \\{0, 0.1, 0.5, 0.9, 0.99, 1\\}$。\n- **输出格式：** 列表的逗号分隔列表：$[[r_1,\\varepsilon_1,\\rho_1],[r_2,\\varepsilon_2,\\rho_2],\\dots]$。\n\n### 步骤2：使用提取的给定信息进行验证\n该问题在科学上和数学上是合理的。\n1. **科学依据：** 扩散方程、Neumann边界条件以及通过POD-Galerkin进行的模型降阶是工程和物理学中标准且成熟的技术。所选参数对于锂离子电池建模在物理上是合理的。时间步长 $h = 0.4 \\frac{\\Delta x^2}{D}$ 遵守了显式欧拉法应用于扩散问题的稳定性极限，即 $h \\le 0.5 \\frac{\\Delta x^2}{D}$。\n2. **适定性：** 所有必要的参数、方程、初始/边界条件和程序都已定义。从带有Neumann边界条件的二阶导数算子构造系统矩阵 $A$ 是数值偏微分方程中的标准程序。问题是自包含的，没有矛盾。度量指标是明确的。\n3. **客观性：** 问题陈述使用了精确的数学和算法语言，不含主观性或个人观点。\n4. **未检测到其他缺陷：** 该问题并非微不足道、不切实际或无法验证。\n\n### 步骤3：结论与行动\n问题有效。将开发一个完整的解决方案。\n\n### 解决方案设计\n解决方案通过系统地实现问题陈述中描述的步骤来展开。\n1. **FOM 构建：** 第一步是为全阶模型（FOM）构建矩阵。空间域被离散化为 $n$ 个节点。系统矩阵 $A$ 被构建为一个 $n \\times n$ 矩阵，表示拉普拉斯算子 $D \\frac{\\partial^2}{\\partial x^2}$ 的有限差分近似。对于内部节点，这导致了标准的 $[1, -2, 1]$ 模板。零通量Neumann边界条件通过使用二阶精度的虚拟点法实现，从而修改了矩阵的第一行和最后一行。向量 $B$ 和 $C$ 按定义构建。\n2. **快照生成：** 使用FOM和指定的正弦输入 $u_k^{\\text{train}}$ 运行训练模拟。在 $m$ 个时间步中的每一步都保存状态向量 $\\mathbf{x}_k$。这些状态向量被堆叠成列，形成 $n \\times m$ 的快照矩阵 $X$。模拟从零初始条件 $\\mathbf{x}_0=\\mathbf{0}$ 开始，并根据显式欧拉规则演化。\n3. **SVD 和基生成：** 计算快照矩阵 $X$ 的奇异值分解（SVD），得到左奇异向量 $U$、奇异值 $\\sigma_i$ 和右奇异向量。$U$ 的列构成本征正交分解（POD）模态，它们是快照数据在最小二乘意义下的最优正交基。\n4. **评估数据生成：** 为了对降阶模型进行无偏评估，将执行一次单独的评估。通过使用一个不同的、分段常数输入信号 $u_k^{\\text{eval}}$ 模拟FOM，计算出真实的系统输出 $y_k$。该序列将作为比较降阶模型的“基准真相”。\n5. **ROM 创建和评估循环：** 解决方案的核心是遍历指定的容差值 $\\tau$。对于每个 $\\tau$：\n    a. **阶数选择：** 使用奇异值来确定所需的ROM阶数 $r$。奇异值的平方 $\\sigma_i^2$ 代表每个POD模态的“能量”。选择的阶数 $r$ 是其累积能量达到总能量分数 $\\tau$ 的最小模态数。对于 $\\tau=0$ 和 $\\tau=1$ 的特殊情况按规定处理。\n    b. **ROM 构建：** 通过取 $U$ 的前 $r$ 列形成一个大小为 $n \\times r$ 的POD基 $\\Phi_r$。然后通过Galerkin投影将FOM矩阵投影到这个基上，以创建降阶系统矩阵 $A_r$、$B_r$ 和 $C_r$。\n    c. **ROM 模拟：** 使用评估输入 $u_k^{\\text{eval}}$ 模拟降阶模型，以生成ROM输出序列 $y_k^{\\text{ROM}}$。\n    d. **度量计算：** 根据其定义计算相对均方根误差 $\\varepsilon_{\\text{rel}}$ 和计算成本代理 $\\rho_{\\text{cost}}$。结果 $(r, \\varepsilon_{\\text{rel}}, \\rho_{\\text{cost}})$ 被存储起来。\n6. **最终输出：** 遍历所有容差值后，将收集到的结果格式化为问题指定的单个字符串并打印。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and evaluates a projection-based reduced-order model for a 1D diffusion process.\n    \"\"\"\n    # --- 1. Define Parameters and Constants ---\n    n = 50          # Number of spatial nodes\n    L = 5e-6        # Domain length (m)\n    D = 1e-14       # Diffusion coefficient (m^2/s)\n    m = 300         # Number of time steps\n    beta = 1.0      # Source term scaling\n    \n    # Discretization parameters\n    dx = L / (n - 1)\n    h = 0.4 * dx**2 / D\n    \n    # Test cases for tolerance\n    test_cases = [0.0, 0.1, 0.5, 0.9, 0.99, 1.0]\n\n    # --- 2. Construct Full-Order Model (FOM) Matrices ---\n    # A matrix (D * Laplacian with Neumann BCs)\n    A_stencil = np.zeros((n, n))\n    diag_main = np.full(n, -2.0)\n    diag_off = np.full(n - 1, 1.0)\n    np.fill_diagonal(A_stencil, diag_main)\n    np.fill_diagonal(A_stencil[1:], diag_off, wrap=False)\n    np.fill_diagonal(A_stencil[:, 1:], diag_off, wrap=False)\n    # Apply Neumann boundary conditions via ghost point method\n    A_stencil[0, 1] = 2.0\n    A_stencil[n - 1, n - 2] = 2.0\n    A = (D / dx**2) * A_stencil\n\n    # B vector (uniform source)\n    B = beta * np.ones(n)\n\n    # C vector (spatial average)\n    C = (1.0 / n) * np.ones((1, n))\n\n    # --- 3. Generate Training Data (Snapshots) ---\n    # Training input signal, u_k for k in {1, ..., m}\n    a_train, b_train = 1.0, 0.5\n    k_steps = np.arange(1, m + 1)\n    u_train = a_train * np.sin(2 * np.pi * k_steps / m) + b_train * np.sin(4 * np.pi * k_steps / m)\n\n    # Simulate FOM to get snapshots X = [x_1, ..., x_m]\n    X = np.zeros((n, m))\n    x_current = np.zeros(n)  # Initial condition x_0\n    for k in range(m):\n        # Explicit Euler update: x_{k+1} = x_k + h * (A*x_k + B*u_{k+1})\n        x_current = x_current + h * (A @ x_current + B * u_train[k])\n        X[:, k] = x_current\n\n    # --- 4. SVD of Snapshot Matrix ---\n    # Decompose X = U * Sigma * Vh. Use full_matrices=False for efficiency (n  m)\n    U, s, Vh = np.linalg.svd(X, full_matrices=False)\n    \n    # --- 5. Generate Evaluation Data (FOM Ground Truth) ---\n    # Evaluation input signal, u_k for k in {1, ..., m}\n    u_eval = np.zeros(m)\n    third_m = m // 3\n    u_eval[0:third_m] = 1.0\n    u_eval[third_m:2 * third_m] = -0.5\n    u_eval[2 * third_m:m] = 0.2\n\n    # Simulate FOM with evaluation input to get the true output y_k\n    y_fom_list = []\n    x_fom = np.zeros(n)\n    for k in range(m):\n        x_fom = x_fom + h * (A @ x_fom + B * u_eval[k])\n        y_fom_list.append(C @ x_fom)\n    y_fom = np.array(y_fom_list).flatten()\n    \n    # Pre-calculate singular value energies for rank selection\n    s_sq = s**2\n    total_energy = np.sum(s_sq)\n    cumulative_energy_ratio = np.cumsum(s_sq) / total_energy\n    \n    # --- 6. Loop over Tolerances to Build and Evaluate ROMs ---\n    results = []\n    k_max_rank = U.shape[1] # max possible rank is min(n, m)\n\n    for tau in test_cases:\n        # a) Rank Selection\n        if tau == 0.0:\n            r = 1\n        elif tau == 1.0:\n            r = k_max_rank\n        else:\n            # Find smallest r such that cumulative energy = tau * total_energy\n            r = np.searchsorted(cumulative_energy_ratio, tau, side='left') + 1\n\n        # b) Build ROM via Galerkin Projection\n        Phi_r = U[:, :r]\n        Ar = Phi_r.T @ A @ Phi_r\n        Br = Phi_r.T @ B\n        Cr = C @ Phi_r\n\n        # c) Simulate ROM with evaluation input\n        y_rom_list = []\n        z_rom = np.zeros(r) # Initial reduced state\n        for k in range(m):\n            z_rom = z_rom + h * (Ar @ z_rom + Br * u_eval[k])\n            y_rom_list.append(Cr @ z_rom)\n        y_rom = np.array(y_rom_list).flatten()\n\n        # d) Calculate Metrics\n        # Relative root-mean-square error\n        err_num = np.sum((y_rom - y_fom)**2)\n        err_den = np.sum(y_fom**2)\n        \n        eps_rel = 0.0 if err_den == 0 else np.sqrt(err_num / err_den)\n\n        # Computational cost proxy\n        rho_cost = (r**2) / (3.0 * n)\n\n        results.append([r, eps_rel, rho_cost])\n    \n    # --- 7. Format and Print Final Output ---\n    output_str = \",\".join(map(str, results))\n    print(f\"[{output_str}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "有了合适的基之后，最后一步便是将全阶系统的算子投影以创建ROM。在本练习  中，您将执行这个核心的伽辽金投影（Galerkin projection），计算降阶后的质量和刚度矩阵。更重要的是，您将分析不同基向量的选择——包括那些病态的基——如何直接影响所得ROM的谱特性，而这些特性最终决定了模型的稳定性和准确性。",
            "id": "3943055",
            "problem": "考虑 Doyle–Fuller–Newman (DFN) 电池模型的一个半离散子模型，该模型由球对称固体颗粒中的质量守恒和菲克扩散得到。经过线性化和空间离散化，状态向量 $x(t) \\in \\mathbb{R}^n$ 的演化由以下方程控制\n$$\nM \\,\\dot{x}(t) + A \\, x(t) = f(t),\n$$\n其中 $M \\in \\mathbb{R}^{n \\times n}$ 是对称正定质量矩阵，$A \\in \\mathbb{R}^{n \\times n}$ 是由扩散算子和边界条件产生的对称正定刚度矩阵，$f(t)$ 是一个输入。在一个基于投影的降阶模型中，使用一个满列秩的试验基 $V \\in \\mathbb{R}^{n \\times r}$ (其中 $r \\ll n$) 来近似 $x(t) \\approx V z(t)$，从而得到降阶矩阵\n$$\nM_r = V^\\top M V, \\quad A_r = V^\\top A V,\n$$\n以及降阶动力学方程 $M_r \\,\\dot{z}(t) + A_r \\, z(t) = V^\\top f(t)$。降阶算子的条件数和刚度可以通过 $(A_r, M_r)$ 的广义谱来分析，即求解以下方程的特征值 $\\lambda$\n$$\nA_r u = \\lambda \\, M_r u,\n$$\n当 $M_r$ 可逆时，这等价于 $M_r^{-1} A_r$ 的谱。\n\n您的任务是实现一个程序，对下面的每个测试用例计算：\n- 降阶矩阵 $M_r$ 和 $A_r$。\n- $M_r$ 在 $2$-范数下的谱条件数，定义为其最大特征值与最小特征值之比。\n- $(A_r, M_r)$ 的最小和最大广义特征值。\n- 特征值范围，定义为最大广义特征值与最小广义特征值之比。\n\n所有计算必须使用浮点运算。无需报告物理单位。角度不适用。所有浮点输出均需四舍五入至八位小数。\n\n基本原理：\n- 控制体中的质量守恒，在空间离散化后，对于具有适当边界条件的扩散主导子问题，意味着 $M \\dot{x}(t) + A x(t) = f(t)$，其中 $M$ 和 $A$ 是对称正定的。\n- 对于任何满列秩的 $V$，伽辽金投影 (Galerkin projection) 得到 $M_r = V^\\top M V$ 和 $A_r = V^\\top A V$。\n- 对于对称正定的 $M_r$ 和 $A_r$，矩阵对 $(A_r, M_r)$ 的广义特征值是实数且为正。\n\n测试套件：\n设 $n = 5$。在所有情况下使用以下全阶矩阵：\n$$\nM = \\mathrm{diag}(0.8,\\,1.0,\\,1.2,\\,1.0,\\,0.9),\n$$\n$$\nA =\n\\begin{bmatrix}\n2  -1  0  0  0 \\\\\n-1  2  -1  0  0 \\\\\n0  -1  2  -1  0 \\\\\n0  0  -1  2  -1 \\\\\n0  0  0  -1  2\n\\end{bmatrix}.\n$$\n对于以下每种情况，使用指定的基 $V$：\n\n- 情况 1 (非标准正交的低维基，$r=2$)：\n$$\nV_1 =\n\\begin{bmatrix}\n1  1 \\\\\n1  2 \\\\\n1  3 \\\\\n1  2 \\\\\n1  1\n\\end{bmatrix}.\n$$\n\n- 情况 2 (典范坐标子空间，$r=4$)：\n$$\nV_2 =\n\\begin{bmatrix}\n1  0  0  0 \\\\\n0  1  0  0 \\\\\n0  0  1  0 \\\\\n0  0  0  1 \\\\\n0  0  0  0\n\\end{bmatrix}.\n$$\n\n- 情况 3 (近似线性相关的基，$r=3$)：\n设 $\\varepsilon = 10^{-6}$。定义\n$$\nv_1 = \\begin{bmatrix}1\\\\1\\\\1\\\\1\\\\1\\end{bmatrix}, \\quad\nv_2 = v_1 + \\varepsilon \\begin{bmatrix}1\\\\-1\\\\1\\\\-1\\\\1\\end{bmatrix} =\n\\begin{bmatrix}1+\\varepsilon\\\\1-\\varepsilon\\\\1+\\varepsilon\\\\1-\\varepsilon\\\\1+\\varepsilon\\end{bmatrix}, \\quad\nv_3 = \\begin{bmatrix}1\\\\0\\\\0\\\\0\\\\0\\end{bmatrix},\n$$\n并设\n$$\nV_3 = \\begin{bmatrix} v_1  v_2  v_3 \\end{bmatrix}.\n$$\n\n- 情况 4 (全阶，$r=5$)：\n$$\nV_4 = I_5,\n$$\n$5 \\times 5$ 的单位矩阵。\n\n对于每种情况 $i \\in \\{1,2,3,4\\}$，计算：\n- $r_i$，降阶维度。\n- $\\kappa_i$，$M_{r_i}$ 在 $2$-范数下的谱条件数。\n- $\\lambda_{\\min,i}$ 和 $\\lambda_{\\max,i}$，矩阵对 $(A_{r_i}, M_{r_i})$ 的最小和最大广义特征值。\n- $s_i = \\lambda_{\\max,i} / \\lambda_{\\min,i}$，特征值范围。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个列表，该列表内含四个子列表，按顺序对应每个测试用例。每个子列表必须是\n$$\n[r_i,\\, \\kappa_i,\\, \\lambda_{\\min,i},\\, \\lambda_{\\max,i},\\, s_i],\n$$\n其中所有浮点数条目都四舍五入到八位小数，并精确打印小数点后八位数字。顶层列表必须用方括号括起来，内部列表也必须用方括号括起来。例如，整体形状应如下所示\n$$\n\\big[ [\\cdot,\\cdot,\\cdot,\\cdot,\\cdot], [\\cdot,\\cdot,\\cdot,\\cdot,\\cdot], [\\cdot,\\cdot,\\cdot,\\cdot,\\cdot], [\\cdot,\\cdot,\\cdot,\\cdot,\\cdot] \\big].\n$$",
            "solution": "该问题经评估有效。其科学基础是线性时不变系统的模型降阶原理，特别是使用了伽辽金投影。整个设定在数学上是一致且适定的。所提供的矩阵 $M$ 和 $A$ 如所述，是对称正定的，确保了所有后续计算都是明确定义的。任务涉及标准的数值线性代数运算，这些运算存在稳定的算法。问题是客观的，没有歧义。\n\n该问题要求对给定全阶线性系统 $M \\dot{x}(t) + A x(t) = f(t)$ 的几个基于投影的降阶模型（ROM）进行分析。状态向量为 $x(t) \\in \\mathbb{R}^n$，质量矩阵 $M \\in \\mathbb{R}^{n \\times n}$ 和刚度矩阵 $A \\in \\mathbb{R}^{n \\times n}$ 是对称正定（SPD）的，$f(t)$ 是输入向量。\n\n基于投影的 ROM 的核心原理是用一个低维表示来近似高维状态向量 $x(t)$。选择一个试验基，由矩阵 $V \\in \\mathbb{R}^{n \\times r}$ 的列向量表示，其中 $r$ 是降阶后的维度，通常 $r \\ll n$。假设基向量是线性无关的，因此 $V$ 具有满列秩。近似形式为 $x(t) \\approx V z(t)$，其中 $z(t) \\in \\mathbb{R}^r$ 是降阶状态变量（或广义坐标）的向量。\n\n将此近似代入原始系统方程会产生一个残差 $R(t) = M V \\dot{z}(t) + A V z(t) - f(t)$。伽辽金投影法要求此残差与由基 $V$ 张成的子空间正交。此正交性条件表示为 $V^\\top R(t) = 0$，从而得出：\n$$\nV^\\top (M V \\dot{z}(t) + A V z(t) - f(t)) = 0\n$$\n重新整理此方程可得到降阶模型：\n$$\n(V^\\top M V) \\dot{z}(t) + (V^\\top A V) z(t) = V^\\top f(t)\n$$\n这是一个形式为 $M_r \\dot{z}(t) + A_r z(t) = f_r(t)$ 的更小的线性系统，其中降阶质量矩阵为 $M_r = V^\\top M V \\in \\mathbb{R}^{r \\times r}$，降阶刚度矩阵为 $A_r = V^\\top A V \\in \\mathbb{R}^{r \\times r}$。\n\n鉴于 $M$ 和 $A$ 是对称正定（SPD）且 $V$ 是满列秩的，降阶矩阵 $M_r$ 和 $A_r$ 也是 SPD 的。对于任何非零向量 $u \\in \\mathbb{R}^r$，$v = V u \\in \\mathbb{R}^n$ 也是非零的。因此，$u^\\top M_r u = (V u)^\\top M (V u) = v^\\top M v  0$，因为 $M$ 是 SPD 的。同样的逻辑也适用于 $A_r$。\n\n降阶系统的特性通过其矩阵进行分析。\n1.  每种情况下的降阶维度 $r_i$ 是基矩阵 $V_i$ 的列数。\n2.  降阶质量矩阵的谱条件数 $\\kappa(M_r)$ 影响时间积分方案的稳定性。对于一个 SPD 矩阵 $M_r$，它被定义为其最大特征值与最小特征值之比：$\\kappa(M_r) = \\lambda_{\\max}(M_r) / \\lambda_{\\min}(M_r)$。大的条件数表明，质量矩阵 $M$ “看待” $V$ 中所选的基向量为近似线性相关。\n3.  降阶系统的动态行为由矩阵对 $(A_r, M_r)$ 的广义特征值决定。这些是标量 $\\lambda$，对于非零特征向量 $u$，它们是广义特征值问题 $A_r u = \\lambda M_r u$ 的解。由于 $A_r$ 和 $M_r$ 是 SPD 的，所有广义特征值都是实数且为正。最小和最大特征值 $\\lambda_{\\min}$ 和 $\\lambda_{\\max}$ 分别对应于降阶系统的最慢和最快模式。\n4.  特征值范围 $s = \\lambda_{\\max} / \\lambda_{\\min}$ 是衡量降阶系统刚度的一个指标。大的范围表示一个刚性系统，这可能对数值模拟构成挑战。\n\n每个测试用例的计算过程如下：\n- 定义全阶矩阵 $M$ 和 $A$，以及基矩阵 $V_i$。\n- 根据 $V_i$ 的形状确定降阶维度 $r_i$。\n- 计算 $M_{r_i} = V_i^\\top M V_i$ 和 $A_{r_i} = V_i^\\top A V_i$。\n- 计算 $M_{r_i}$ 的特征值，以找到其最大和最小特征值，然后计算条件数 $\\kappa_i$。\n- 求解 $(A_{r_i}, M_{r_i})$ 的广义特征值问题，以找到广义特征值集合。\n- 确定这些广义特征值中的最小值 ($\\lambda_{\\min,i}$) 和最大值 ($\\lambda_{\\max,i}$)。\n- 计算范围 $s_i = \\lambda_{\\max,i} / \\lambda_{\\min,i}$。\n- 收集并格式化每种情况下的这五个值。\n\n此过程将应用于四个指定的测试用例，每个用例都具有不同的基矩阵 $V_i$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import eigh\n\ndef solve():\n    \"\"\"\n    Computes reduced matrices and their spectral properties for four test cases\n    of a projection-based reduced-order model.\n    \"\"\"\n\n    # Define the full-order matrices, n=5\n    M = np.diag([0.8, 1.0, 1.2, 1.0, 0.9])\n    A = np.array([\n        [2, -1, 0, 0, 0],\n        [-1, 2, -1, 0, 0],\n        [0, -1, 2, -1, 0],\n        [0, 0, -1, 2, -1],\n        [0, 0, 0, -1, 2]\n    ])\n\n    # Define the basis matrices for each test case\n    # Case 1: non-orthonormal, r=2\n    V1 = np.array([\n        [1, 1],\n        [1, 2],\n        [1, 3],\n        [1, 2],\n        [1, 1]\n    ], dtype=float)\n\n    # Case 2: canonical coordinate subspace, r=4\n    V2 = np.array([\n        [1, 0, 0, 0],\n        [0, 1, 0, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n        [0, 0, 0, 0]\n    ], dtype=float)\n\n    # Case 3: nearly linearly dependent basis, r=3\n    epsilon = 1e-6\n    v1 = np.array([1, 1, 1, 1, 1], dtype=float)\n    v2 = v1 + epsilon * np.array([1, -1, 1, -1, 1], dtype=float)\n    v3 = np.array([1, 0, 0, 0, 0], dtype=float)\n    V3 = np.vstack([v1, v2, v3]).T\n\n    # Case 4: full-order, r=5\n    V4 = np.eye(5)\n\n    test_cases = [V1, V2, V3, V4]\n    \n    all_results = []\n\n    for V in test_cases:\n        # 1. Get reduced dimension\n        r = V.shape[1]\n\n        # 2. Compute reduced matrices\n        Mr = V.T @ M @ V\n        Ar = V.T @ A @ V\n\n        # 3. Compute spectral condition number of Mr\n        # eigvalsh returns sorted eigenvalues for a symmetric matrix\n        eigs_Mr = np.linalg.eigvalsh(Mr)\n        kappa = eigs_Mr[-1] / eigs_Mr[0]\n\n        # 4. Compute generalized eigenvalues of (Ar, Mr)\n        # eigh for generalized problems also returns sorted eigenvalues\n        gen_eigs = eigh(Ar, Mr, eigvals_only=True)\n        lambda_min = gen_eigs[0]\n        lambda_max = gen_eigs[-1]\n        \n        # 5. Compute eigenvalue spread\n        spread = lambda_max / lambda_min\n        \n        all_results.append(\n            [r, kappa, lambda_min, lambda_max, spread]\n        )\n\n    # Format the final output string as specified in the problem\n    output_str = \"[\"\n    for i, res in enumerate(all_results):\n        r, k, lmin, lmax, s = res\n        output_str += f\"[{r},{k:.8f},{lmin:.8f},{lmax:.8f},{s:.8f}]\"\n        if i  len(all_results) - 1:\n            output_str += \",\"\n    output_str += \"]\"\n    \n    print(output_str)\n\nsolve()\n```"
        }
    ]
}