{
    "hands_on_practices": [
        {
            "introduction": "投影降阶模型的核心在于“投影”这一数学操作。本实践将聚焦于这一基本步骤。我们将从一个由质量矩阵 $M$ 和刚度矩阵 $A$ 定义的全阶模型出发，使用一个给定的基矩阵 $V$，通过伽辽金投影（Galerkin projection）将其降维成一个小型系统。通过使用不同的基矩阵进行实验 ，你将亲手体验基向量的选择如何直接影响降阶模型的数值属性，例如其条件数和刚度。这些属性对于仿真过程的稳定性和准确性至关重要。",
            "id": "3943055",
            "problem": "考虑一个 Doyle–Fuller–Newman (DFN) 电池模型的半离散子模型，该模型由球对称固体颗粒中的质量守恒和菲克扩散得到。经过线性化和空间离散化后，状态向量 $x(t) \\in \\mathbb{R}^n$ 的演化由下式决定：\n$$\nM \\,\\dot{x}(t) + A \\, x(t) = f(t),\n$$\n其中 $M \\in \\mathbb{R}^{n \\times n}$ 是一个对称正定质量矩阵，$A \\in \\mathbb{R}^{n \\times n}$ 是一个由扩散算子和边界条件产生的对称正定刚度矩阵，$f(t)$ 是一个输入。在基于投影的降阶模型中，使用一个满列秩的试探基 $V \\in \\mathbb{R}^{n \\times r}$（其中 $r \\ll n$）来近似 $x(t) \\approx V z(t)$，从而得到降阶矩阵：\n$$\nM_r = V^\\top M V, \\quad A_r = V^\\top A V,\n$$\n以及降阶动力学方程 $M_r \\,\\dot{z}(t) + A_r \\, z(t) = V^\\top f(t)$。降阶算子的条件和刚度可以通过 $(A_r, M_r)$ 的广义谱进行分析，即求解以下方程的特征值 $\\lambda$：\n$$\nA_r u = \\lambda \\, M_r u,\n$$\n当 $M_r$ 可逆时，这等价于 $M_r^{-1} A_r$ 的谱。\n\n您的任务是实现一个程序，对下面的每个测试用例，计算：\n- 降阶矩阵 $M_r$ 和 $A_r$。\n- $M_r$ 在 $2$-范数下的谱条件数，定义为其最大特征值与最小特征值之比。\n- $(A_r, M_r)$ 的最小和最大广义特征值。\n- 特征值分布范围，定义为最大广义特征值与最小广义特征值之比。\n\n所有计算必须使用浮点运算。无需报告物理单位。不涉及角度。所有浮点输出均需四舍五入到八位小数。\n\n基本原理：\n- 控制体积内的质量守恒，在经过空间离散化后，对于具有适当边界条件的扩散主导子问题，可得到方程 $M \\dot{x}(t) + A x(t) = f(t)$，其中 $M$ 和 $A$ 为对称正定矩阵。\n- 对于任何满列秩的 $V$，伽辽金投影可得到 $M_r = V^\\top M V$ 和 $A_r = V^\\top A V$。\n- 对于对称正定的 $M_r$ 和 $A_r$，矩阵对 $(A_r, M_r)$ 的广义特征值是实数且为正。\n\n测试套件：\n设 $n = 5$。在所有情况下使用以下全阶矩阵：\n$$\nM = \\mathrm{diag}(0.8,\\,1.0,\\,1.2,\\,1.0,\\,0.9),\n$$\n$$\nA =\n\\begin{bmatrix}\n2  -1  0  0  0 \\\\\n-1  2  -1  0  0 \\\\\n0  -1  2  -1  0 \\\\\n0  0  -1  2  -1 \\\\\n0  0  0  -1  2\n\\end{bmatrix}.\n$$\n对于以下每个情况，使用指定的基 $V$：\n\n- 情况 $1$（非正交、低维基，$r=2$）：\n$$\nV_1 =\n\\begin{bmatrix}\n1  1 \\\\\n1  2 \\\\\n1  3 \\\\\n1  2 \\\\\n1  1\n\\end{bmatrix}.\n$$\n\n- 情况 $2$（规范坐标子空间，$r=4$）：\n$$\nV_2 =\n\\begin{bmatrix}\n1  0  0  0 \\\\\n0  1  0  0 \\\\\n0  0  1  0 \\\\\n0  0  0  1 \\\\\n0  0  0  0\n\\end{bmatrix}.\n$$\n\n- 情况 $3$（近线性相关基，$r=3$）：\n设 $\\varepsilon = 10^{-6}$。定义\n$$\nv_1 = \\begin{bmatrix}1\\\\1\\\\1\\\\1\\\\1\\end{bmatrix}, \\quad\nv_2 = v_1 + \\varepsilon \\begin{bmatrix}1\\\\-1\\\\1\\\\-1\\\\1\\end{bmatrix} =\n\\begin{bmatrix}1+\\varepsilon\\\\1-\\varepsilon\\\\1+\\varepsilon\\\\1-\\varepsilon\\\\1+\\varepsilon\\end{bmatrix}, \\quad\nv_3 = \\begin{bmatrix}1\\\\0\\\\0\\\\0\\\\0\\end{bmatrix},\n$$\n并设\n$$\nV_3 = \\begin{bmatrix} v_1  v_2  v_3 \\end{bmatrix}.\n$$\n\n- 情况 $4$（全阶，$r=5$）：\n$$\nV_4 = I_5,\n$$\n$5 \\times 5$ 单位矩阵。\n\n对每个情况 $i \\in \\{1,2,3,4\\}$，计算：\n- $r_i$，降阶维度。\n- $\\kappa_i$，$M_{r_i}$ 在 $2$-范数下的谱条件数。\n- $\\lambda_{\\min,i}$ 和 $\\lambda_{\\max,i}$，矩阵对 $(A_{r_i}, M_{r_i})$ 的最小和最大广义特征值。\n- $s_i = \\lambda_{\\max,i} / \\lambda_{\\min,i}$，特征值分布范围。\n\n最终输出格式：\n您的程序应生成一行输出，其中包含一个列表，该列表包含四个内部列表，按顺序对应每个测试用例。每个内部列表必须是\n$$\n[r_i,\\, \\kappa_i,\\, \\lambda_{\\min,i},\\, \\lambda_{\\max,i},\\, s_i],\n$$\n其中所有浮点数条目均四舍五入到八位小数，并精确打印小数点后八位。顶级列表必须用方括号括起来，内部列表也必须用方括号括起来。例如，整体结构应如下所示：\n$$\n\\big[ [\\cdot,\\cdot,\\cdot,\\cdot,\\cdot], [\\cdot,\\cdot,\\cdot,\\cdot,\\cdot], [\\cdot,\\cdot,\\cdot,\\cdot,\\cdot], [\\cdot,\\cdot,\\cdot,\\cdot,\\cdot] \\big].\n$$",
            "solution": "该问题被评估为有效。它科学地基于线性时不变系统的模型降阶原理，特别是使用了伽辽金投影。其设定在数学上是一致且适定的。所提供的矩阵 $M$ 和 $A$ 如所述是对称正定的，确保所有后续计算都是良定义的。任务涉及标准的数值线性代数运算，对此存在稳定的算法。该问题客观且无歧义。\n\n该问题要求对一个给定的全阶线性系统 $\\dot{x}(t) + A x(t) = f(t)$ 的几个基于投影的降阶模型 (ROM) 进行分析。状态向量为 $x(t) \\in \\mathbb{R}^n$，质量矩阵 $M \\in \\mathbb{R}^{n \\times n}$ 和刚度矩阵 $A \\in \\mathbb{R}^{n \\times n}$ 是对称正定 (SPD) 的，$f(t)$ 是一个输入向量。\n\n基于投影的 ROM 的核心原理是用低维表示来近似高维状态向量 $x(t)$。选择一个试探基，由矩阵 $V \\in \\mathbb{R}^{n \\times r}$ 的列向量表示，其中 $r$ 是降阶维度，通常 $r \\ll n$。假设基向量是线性无关的，因此 $V$ 具有满列秩。近似形式为 $x(t) \\approx V z(t)$，其中 $z(t) \\in \\mathbb{R}^r$ 是降阶状态变量（或广义坐标）的向量。\n\n将此近似代入原始系统方程会产生一个残差 $R(t) = M V \\dot{z}(t) + A V z(t) - f(t)$。伽辽金投影法要求此残差与由基 $V$ 张成的子空间正交。此正交条件表示为 $V^\\top R(t) = 0$，这导致：\n$$\nV^\\top (M V \\dot{z}(t) + A V z(t) - f(t)) = 0\n$$\n重新整理此方程得到降阶模型：\n$$\n(V^\\top M V) \\dot{z}(t) + (V^\\top A V) z(t) = V^\\top f(t)\n$$\n这是一个形式为 $M_r \\dot{z}(t) + A_r z(t) = f_r(t)$ 的较小线性系统，其中降阶质量矩阵为 $M_r = V^\\top M V \\in \\mathbb{R}^{r \\times r}$，降阶刚度矩阵为 $A_r = V^\\top A V \\in \\mathbb{R}^{r \\times r}$。\n\n鉴于 $M$ 和 $A$ 是对称正定 (SPD) 且 $V$ 具有满列秩，降阶矩阵 $M_r$ 和 $A_r$ 也是对称正定的。对于任何非零向量 $u \\in \\mathbb{R}^r$，$v = V u \\in \\mathbb{R}^n$ 也是非零的。因此，$u^\\top M_r u = (V u)^\\top M (V u) = v^\\top M v > 0$，因为 $M$ 是对称正定的。同样的逻辑也适用于 $A_r$。\n\n降阶系统的特性通过其矩阵进行分析。\n1.  每个情况的降阶维度 $r_i$ 是基矩阵 $V_i$ 的列数。\n2.  降阶质量矩阵的谱条件数 $\\kappa(M_r)$ 影响时间积分方案的稳定性。对于一个对称正定矩阵 $M_r$，它定义为其最大特征值与最小特征值之比：$\\kappa(M_r) = \\lambda_{\\max}(M_r) / \\lambda_{\\min}(M_r)$。一个大的条件数表明，在质量矩阵 $M$看来，所选的基向量 $V$ 是近线性相关的。\n3.  降阶系统的动态行为由矩阵对 $(A_r, M_r)$ 的广义特征值决定。这些是标量 $\\lambda$，它们是对于非零特征向量 $u$ 求解广义特征值问题 $A_r u = \\lambda M_r u$ 的解。由于 $A_r$ 和 $M_r$ 是对称正定的，所有广义特征值都是实数且为正。最小和最大特征值 $\\lambda_{\\min}$ 和 $\\lambda_{\\max}$ 分别对应于降阶系统的最慢和最快模式。\n4.  特征值分布范围 $s = \\lambda_{\\max} / \\lambda_{\\min}$ 是降阶系统刚度的一种度量。大的分布范围表示系统是刚性的，这会给数值模拟带来挑战。\n\n每个测试用例的计算步骤如下：\n- 定义全阶矩阵 $M$ 和 $A$ 以及基矩阵 $V_i$。\n- 根据 $V_i$ 的形状确定降阶维度 $r_i$。\n- 计算 $M_{r_i} = V_i^\\top M V_i$ 和 $A_{r_i} = V_i^\\top A V_i$。\n- 计算 $M_{r_i}$ 的特征值以找到其最大和最小特征值，然后计算条件数 $\\kappa_i$。\n- 求解 $(A_{r_i}, M_{r_i})$ 的广义特征值问题以找到广义特征值集合。\n- 确定这些广义特征值中的最小值 ($\\lambda_{\\min,i}$) 和最大值 ($\\lambda_{\\max,i}$)。\n- 计算分布范围 $s_i = \\lambda_{\\max,i} / \\lambda_{\\min,i}$。\n- 收集并格式化每个情况的这五个值。\n\n此过程将应用于四个指定的测试用例，每个用例都有不同的基矩阵 $V_i$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import eigh\n\ndef solve():\n    \"\"\"\n    Computes reduced matrices and their spectral properties for four test cases\n    of a projection-based reduced-order model.\n    \"\"\"\n\n    # Define the full-order matrices, n=5\n    M = np.diag([0.8, 1.0, 1.2, 1.0, 0.9])\n    A = np.array([\n        [2, -1, 0, 0, 0],\n        [-1, 2, -1, 0, 0],\n        [0, -1, 2, -1, 0],\n        [0, 0, -1, 2, -1],\n        [0, 0, 0, -1, 2]\n    ])\n\n    # Define the basis matrices for each test case\n    # Case 1: non-orthonormal, r=2\n    V1 = np.array([\n        [1, 1],\n        [1, 2],\n        [1, 3],\n        [1, 2],\n        [1, 1]\n    ], dtype=float)\n\n    # Case 2: canonical coordinate subspace, r=4\n    V2 = np.array([\n        [1, 0, 0, 0],\n        [0, 1, 0, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n        [0, 0, 0, 0]\n    ], dtype=float)\n\n    # Case 3: nearly linearly dependent basis, r=3\n    epsilon = 1e-6\n    v1 = np.array([1, 1, 1, 1, 1], dtype=float)\n    v2 = v1 + epsilon * np.array([1, -1, 1, -1, 1], dtype=float)\n    v3 = np.array([1, 0, 0, 0, 0], dtype=float)\n    V3 = np.vstack([v1, v2, v3]).T\n\n    # Case 4: full-order, r=5\n    V4 = np.eye(5)\n\n    test_cases = [V1, V2, V3, V4]\n    \n    all_results = []\n\n    for V in test_cases:\n        # 1. Get reduced dimension\n        r = V.shape[1]\n\n        # 2. Compute reduced matrices\n        Mr = V.T @ M @ V\n        Ar = V.T @ A @ V\n\n        # 3. Compute spectral condition number of Mr\n        # eigvalsh returns sorted eigenvalues for a symmetric matrix\n        eigs_Mr = np.linalg.eigvalsh(Mr)\n        kappa = eigs_Mr[-1] / eigs_Mr[0]\n\n        # 4. Compute generalized eigenvalues of (Ar, Mr)\n        # eigh for generalized problems also returns sorted eigenvalues\n        gen_eigs = eigh(Ar, Mr, eigvals_only=True)\n        lambda_min = gen_eigs[0]\n        lambda_max = gen_eigs[-1]\n        \n        # 5. Compute eigenvalue spread\n        spread = lambda_max / lambda_min\n        \n        all_results.append(\n            [r, kappa, lambda_min, lambda_max, spread]\n        )\n\n    # Format the final output string as specified in the problem\n    output_str = \"[\"\n    for i, res in enumerate(all_results):\n        r, k, lmin, lmax, s = res\n        output_str += f\"[{r},{k:.8f},{lmin:.8f},{lmax:.8f},{s:.8f}]\"\n        if i  len(all_results) - 1:\n            output_str += \",\"\n    output_str += \"]\"\n    \n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "上一个练习假设基矩阵 $V$ 是已知的。但在实际应用中，我们如何获得这个基呢？本实践将展示一个完整的、数据驱动的工作流程，从零开始构建并验证一个降阶模型。我们将采用一种基于奇异值分解（SVD）的强大技术——本征正交分解（Proper Orthogonal Decomposition, POD），从仿真数据（“快照”）中提取一个最优基。你还将实现一个标准，根据期望的精度容差自动选择模型的阶数（rank）。这个练习  将理论与应用联系起来，引导你完成为电池扩散模型创建实用降阶模型的全过程。你将学会如何平衡模型的准确性和计算速度，这是自动化设计与仿真中的核心挑战。",
            "id": "3943087",
            "problem": "您的任务是为代表自动化电池设计与仿真中固相锂浓度动力学的线性扩散过程，实现一个基于投影的降阶模型的阶数选择。请从以下基本原理开始。\n\n考虑由以下抛物线型偏微分方程建模的固相浓度一维扩散过程：$$\\frac{\\partial c(x,t)}{\\partial t} = D \\frac{\\partial^2 c(x,t)}{\\partial x^2} + s(t),$$ 其中 $c(x,t)$ 是浓度，$D$ 是扩散系数，$s(t)$ 是一个空间均匀的源项，代表与施加电流成正比的嵌入率。假设零通量（Neumann）边界条件：$$\\frac{\\partial c(0,t)}{\\partial x} = 0,\\quad \\frac{\\partial c(L,t)}{\\partial x} = 0,$$ 以及初始条件 $c(x,0) = 0$。\n\n使用 $n$ 个等距节点对空间域 $[0,L]$ 进行离散化，通过线法得到一个半离散线性时不变系统。令 $\\Delta x$ 为空间步长，状态向量为 $\\mathbf{x}(t) \\in \\mathbb{R}^n$，用于逼近网格点上的 $c(x,t)$。该半离散动力学可写作 $$\\frac{d\\mathbf{x}(t)}{dt} = A \\mathbf{x}(t) + B u(t),$$ 其中 $A \\in \\mathbb{R}^{n \\times n}$ 是代表带有零通量边界调整的空间二阶导数的三对角矩阵，$B \\in \\mathbb{R}^{n}$ 是一个均匀源向量，$u(t)$ 是对应于嵌入率的标量输入。将输出定义为空间平均值 $$y(t) = C \\mathbf{x}(t),$$ 其中 $C = \\frac{1}{n} [1,1,\\dots,1] \\in \\mathbb{R}^{1 \\times n}$。使用显式欧拉时间步进法，时间步长 $h$ 满足扩散方程的典型稳定性极限。具体来说，离散时间更新公式为 $$\\mathbf{x}_{k+1} = \\mathbf{x}_k + h(A \\mathbf{x}_k + B u_k),$$ 输出为 $$y_k = C \\mathbf{x}_k.$$\n\n通过在 $m$ 个连续时间步上堆叠状态向量，从训练仿真中收集一个快照矩阵 $X \\in \\mathbb{R}^{n \\times m}$：$$X = [\\mathbf{x}_1, \\mathbf{x}_2, \\dots, \\mathbf{x}_m].$$ 计算 $X$ 的奇异值分解 (SVD; Singular Value Decomposition)：$$X = U \\Sigma V^\\top,$$ 其中 $U \\in \\mathbb{R}^{n \\times k}$ 包含左奇异向量，$\\Sigma \\in \\mathbb{R}^{k \\times k}$ 是对角矩阵，其对角线元素为奇异值 $\\sigma_1 \\ge \\sigma_2 \\ge \\dots \\ge \\sigma_k \\ge 0$，$V \\in \\mathbb{R}^{m \\times k}$ 包含右奇异向量，其中 $k = \\min(n,m)$。通过选择 $U$ 的前 $r$ 列来构建一个本征正交分解 (POD; Proper Orthogonal Decomposition) 基 $\\Phi_r \\in \\mathbb{R}^{n \\times r}$。使用 Galerkin 投影得到降阶模型 (ROM; Reduced-Order Model)：$$A_r = \\Phi_r^\\top A \\Phi_r,\\quad B_r = \\Phi_r^\\top B,\\quad C_r = C \\Phi_r,$$ 以及降阶动力学 $$\\mathbf{z}_{k+1} = \\mathbf{z}_k + h(A_r \\mathbf{z}_k + B_r u_k),\\quad y_k^{\\text{ROM}} = C_r \\mathbf{z}_k,$$ 其中 $\\mathbf{z}_k \\in \\mathbb{R}^r$ 是降阶状态。\n\n通过容差准则实现阶数选择 $$\\frac{\\sum_{i=1}^r \\sigma_i^2}{\\sum_{i=1}^k \\sigma_i^2} \\ge \\tau,$$ 即，选择使上述不等式对于给定的容差 $\\tau$ ($0 \\le \\tau \\le 1$) 成立的最小整数 $r$。如果 $\\tau = 1$，则设 $r = k$。如果 $\\tau = 0$，则设 $r = 1$。\n\n通过执行以下操作，分析容差 $\\tau$ 如何影响 ROM 的精度和计算成本：\n\n1. 在 $m$ 步的训练时域上，使用由正弦波组合构成的平滑输入 $u_k^{\\text{train}}$ 生成训练快照。使用这些快照计算 SVD 和 POD 基。\n2. 在相同步数上，使用由分段常数脉冲组成的独特评估输入 $u_k^{\\text{eval}}$ 来评估 ROM 精度，并计算输出序列 $y_k^{\\text{ROM}}$ 与全阶输出 $y_k$ 的对比。\n3. 将 ROM 精度度量定义为在整个评估时域上的相对均方根误差：$$\\varepsilon_{\\text{rel}} = \\sqrt{\\frac{\\sum_{k=1}^{m} \\left(y_k^{\\text{ROM}} - y_k\\right)^2}{\\sum_{k=1}^{m} y_k^2}}.$$ 将此结果报告为无量纲浮点数。\n4. 将在线仿真的每时间步计算成本代理指标定义为降阶稠密矩阵-向量乘法计数与全阶三对角矩阵乘法计数之比：$$\\rho_{\\text{cost}} = \\frac{r^2}{3n}.$$ 该代理指标是无量纲的，并捕捉了稠密的降阶动力学与带状的全阶动力学之间的差异。\n\n使用以下物理上合理且自洽的参数：\n- 空间节点数 $n = 50$。\n- 域长度 $L = 5 \\times 10^{-6}$ 米。\n- 扩散系数 $D = 1 \\times 10^{-14}$ 平方米/秒。\n- 空间步长 $\\Delta x = \\frac{L}{n-1}$。\n- 时间步长 $h = 0.4 \\frac{\\Delta x^2}{D}$ 秒（保证扩散算子显式欧拉法的稳定性）。\n- 训练和评估步数 $m = 300$。\n- 均匀源向量 $B = \\beta \\mathbf{1}$，其中 $\\beta = 1$（用于数值分析的无量纲缩放）。\n- 初始条件 $\\mathbf{x}_0 = \\mathbf{0}$。\n\n将训练输入构造为 $$u_k^{\\text{train}} = a \\sin\\left(2\\pi \\frac{k}{m}\\right) + b \\sin\\left(4\\pi \\frac{k}{m}\\right),$$ 其中 $a = 1$ 且 $b = 0.5$。将评估输入构造为以下分段常数序列：对于 $k \\in \\{1,\\dots,m\\}$，$$u_k^{\\text{eval}} = \\begin{cases} u_1  \\text{if } k \\le \\frac{m}{3}, \\\\ u_2  \\text{if } \\frac{m}{3}  k \\le \\frac{2m}{3}, \\\\ u_3  \\text{if } k > \\frac{2m}{3}, \\end{cases}$$ 其中 $u_1 = 1$，$u_2 = -0.5$，且 $u_3 = 0.2$。\n\n测试套件与答案规范：\n- 使用以下容差值作为测试用例：$\\tau \\in \\{0, 0.1, 0.5, 0.9, 0.99, 1\\}$。\n- 对于每个 $\\tau$ 值，计算所选的阶数 $r$、相对误差 $\\varepsilon_{\\text{rel}}$ 以及如上定义的计算成本代理指标 $\\rho_{\\text{cost}}$。\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，每个测试用例的结果本身就是一个形如 $[r,\\varepsilon_{\\text{rel}},\\rho_{\\text{cost}}]$ 的列表。例如，输出格式必须与以下完全相同：$[[r_1,\\varepsilon_1,\\rho_1],[r_2,\\varepsilon_2,\\rho_2],\\dots]$。\n\n所有计算都应使用实数进行。最终输出为无量纲的浮点数或整数，最终输出中不需要物理单位。",
            "solution": "用户为实现和评估一维线性扩散过程的基于投影的降阶模型（ROM）提供了一个全面的问题陈述。该任务涉及数值方法和模型降阶中的几个标准步骤：空间离散化、时间积分、快照生成、通过奇异值分解（SVD）进行的本征正交分解（POD）、Galerkin投影，以及最后对不同阶数下所得ROM的评估。阶数选择将基于应用于奇异值的能量容差准则来执行。\n\n### 第一步：提取已知条件\n- **控制偏微分方程：** $\\frac{\\partial c(x,t)}{\\partial t} = D \\frac{\\partial^2 c(x,t)}{\\partial x^2} + s(t)$\n- **边界条件：** 在 $x=0$ 和 $x=L$ 处为零通量（Neumann）：$\\frac{\\partial c(0,t)}{\\partial x} = 0, \\frac{\\partial c(L,t)}{\\partial x} = 0$。\n- **初始条件：** $c(x,0) = 0$。\n- **全阶模型（FOM）：** 半离散系统 $\\frac{d\\mathbf{x}(t)}{dt} = A \\mathbf{x}(t) + B u(t)$，输出为 $y(t) = C \\mathbf{x}(t)$。\n- **时间离散化：** 显式欧拉法，$\\mathbf{x}_{k+1} = \\mathbf{x}_k + h(A \\mathbf{x}_k + B u_k)$，输出为 $y_k = C \\mathbf{x}_k$。\n- **参数：**\n    - 空间节点：$n = 50$。\n    - 域长度：$L = 5 \\times 10^{-6}$ m。\n    - 扩散系数：$D = 1 \\times 10^{-14}$ m²/s。\n    - 空间步长：$\\Delta x = \\frac{L}{n-1}$。\n    - 时间步长：$h = 0.4 \\frac{\\Delta x^2}{D}$。\n    - 仿真步数：$m = 300$。\n    - 源向量：$B = \\beta \\mathbf{1}$，其中 $\\beta = 1$。\n    - 输出向量：$C = \\frac{1}{n} [1,1,\\dots,1]$。\n    - 初始状态：$\\mathbf{x}_0 = \\mathbf{0}$。\n- **训练输入：** $u_k^{\\text{train}} = \\sin(2\\pi \\frac{k}{m}) + 0.5 \\sin(4\\pi \\frac{k}{m})$，对于 $k \\in \\{1, \\dots, m\\}$。\n- **评估输入：** 分段常数 $u_k^{\\text{eval}}$，对于 $k \\in \\{1, \\dots, m\\}$：当 $k \\le m/3$ 时为 $1$，当 $m/3  k \\le 2m/3$ 时为 $-0.5$，当 $k > 2m/3$ 时为 $0.2$。\n- **模型降阶：**\n    - 快照矩阵：$X = [\\mathbf{x}_1, \\dots, \\mathbf{x}_m]$。\n    - 来自 $X$ 的前 $r$ 个左奇异向量的 POD 基 $\\Phi_r$。\n    - Galerkin 投影：$A_r = \\Phi_r^\\top A \\Phi_r, B_r = \\Phi_r^\\top B, C_r = C \\Phi_r$。\n- **阶数选择：** 最小整数 $r$ 使得 $\\frac{\\sum_{i=1}^r \\sigma_i^2}{\\sum_{i=1}^k \\sigma_i^2} \\ge \\tau$。特殊情况：对于 $\\tau=0$，$r=1$；对于 $\\tau=1$，$r=k$，其中 $k=\\min(n,m)$。\n- **度量指标：**\n    - 相对误差：$\\varepsilon_{\\text{rel}} = \\sqrt{\\frac{\\sum_{k=1}^{m} (y_k^{\\text{ROM}} - y_k)^2}{\\sum_{k=1}^{m} y_k^2}}$。\n    - 成本代理指标：$\\rho_{\\text{cost}} = \\frac{r^2}{3n}$。\n- **测试用例：** $\\tau \\in \\{0, 0.1, 0.5, 0.9, 0.99, 1\\}$。\n- **输出格式：** 列表的逗号分隔列表：$[[r_1,\\varepsilon_1,\\rho_1],[r_2,\\varepsilon_2,\\rho_2],\\dots]$。\n\n### 第二步：使用提取的已知条件进行验证\n该问题在科学上和数学上是合理的。\n1.  **科学依据充分：** 扩散方程、Neumann 边界条件以及通过 POD-Galerkin 进行模型降阶是工程学和物理学中标准且成熟的技术。所选参数对于锂离子电池建模是物理上合理的。时间步长 $h = 0.4 \\frac{\\Delta x^2}{D}$ 遵守了扩散问题显式欧拉法的稳定性极限，即 $h \\le 0.5 \\frac{\\Delta x^2}{D}$。\n2.  **良构的：** 所有必要的参数、方程、初始/边界条件和程序都已定义。根据带有 Neumann 边界条件的二阶导数算子构造系统矩阵 $A$ 是数值偏微分方程中的标准程序。问题是自洽且无矛盾的。度量指标是明确的。\n3.  **客观性：** 问题使用精确的数学和算法语言陈述，不含主观性或个人观点。\n4.  **未检测到其他缺陷：** 问题并非无足轻重、不切实际或无法验证。\n\n### 第三步：结论与行动\n问题有效。将开发一个完整的解决方案。\n\n### 解决方案设计\n\n解决方案通过系统地实现问题陈述中描述的步骤来展开。\n\n1.  **全阶模型构建：** 第一步是为全阶模型（FOM）构建矩阵。空间域被离散化为 $n$ 个节点。系统矩阵 $A$ 被构建为一个 $n \\times n$ 矩阵，表示拉普拉斯算子 $D \\frac{\\partial^2}{\\partial x^2}$ 的有限差分近似。对于内部节点，这导致了标准的 $[1, -2, 1]$ 模板。零通量 Neumann 边界条件通过二阶精确的虚拟点法实现，从而修改了矩阵的第一行和最后一行。$B$ 和 $C$ 向量按定义构建。\n\n2.  **快照生成：** 使用 FOM 和指定的正弦输入 $u_k^{\\text{train}}$ 运行训练仿真。在 $m$ 个时间步的每一步都保存状态向量 $\\mathbf{x}_k$。这些状态向量按列堆叠，形成 $n \\times m$ 的快照矩阵 $X$。仿真从零初始条件 $\\mathbf{x}_0=\\mathbf{0}$ 开始，并根据显式欧拉法则演化。\n\n3.  **SVD与基生成：** 计算快照矩阵 $X$ 的奇异值分解（SVD），得到左奇异向量 $U$、奇异值 $\\sigma_i$ 和右奇异向量。$U$ 的列构成了 POD 模态，它们是快照数据在最小二乘意义下的最优正交基。\n\n4.  **评估数据生成：** 为了对 ROM 进行无偏评估，执行了单独的评估。通过使用一个独特的、分段常数的输入信号 $u_k^{\\text{eval}}$ 仿真 FOM，计算出真实的系统输出 $y_k$。该序列将作为比较 ROM 的“真实值”。\n\n5.  **ROM创建与评估循环：** 解决方案的核心是一个遍历指定容差值 $\\tau$ 的循环。对于每个 $\\tau$：\n    a.  **阶数选择：** 使用奇异值确定所需的 ROM 阶数 $r$。奇异值的平方 $\\sigma_i^2$ 代表每个 POD 模态的“能量”。阶数 $r$ 被选为使其累积能量满足总能量分数 $\\tau$ 的最小模态数。对 $\\tau=0$ 和 $\\tau=1$ 的特殊情况按规定处理。\n    b.  **ROM 构建：** 通过取 $U$ 的前 $r$ 列形成一个大小为 $n \\times r$ 的 POD 基 $\\Phi_r$。然后通过 Galerkin 投影将 FOM 矩阵投影到该基上，以创建降阶系统矩阵 $A_r$、$B_r$ 和 $C_r$。\n    c.  **ROM 仿真：** 使用评估输入 $u_k^{\\text{eval}}$ 仿真降阶模型，以生成 ROM 输出序列 $y_k^{\\text{ROM}}$。\n    d.  **度量计算：** 根据其定义计算相对均方根误差 $\\varepsilon_{\\text{rel}}$ 和计算成本代理指标 $\\rho_{\\text{cost}}$。结果 $(r, \\varepsilon_{\\text{rel}}, \\rho_{\\text{cost}})$ 被存储。\n\n6.  **最终输出：** 遍历所有容差值后，将收集到的结果按问题指定格式化为单个字符串并打印。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and evaluates a projection-based reduced-order model for a 1D diffusion process.\n    \"\"\"\n    # --- 1. Define Parameters and Constants ---\n    n = 50          # Number of spatial nodes\n    L = 5e-6        # Domain length (m)\n    D = 1e-14       # Diffusion coefficient (m^2/s)\n    m = 300         # Number of time steps\n    beta = 1.0      # Source term scaling\n    \n    # Discretization parameters\n    dx = L / (n - 1)\n    h = 0.4 * dx**2 / D\n    \n    # Test cases for tolerance\n    test_cases = [0.0, 0.1, 0.5, 0.9, 0.99, 1.0]\n\n    # --- 2. Construct Full-Order Model (FOM) Matrices ---\n    # A matrix (D * Laplacian with Neumann BCs)\n    A_stencil = np.zeros((n, n))\n    diag_main = np.full(n, -2.0)\n    diag_off = np.full(n - 1, 1.0)\n    np.fill_diagonal(A_stencil, diag_main)\n    np.fill_diagonal(A_stencil[1:], diag_off, wrap=False)\n    np.fill_diagonal(A_stencil[:, 1:], diag_off, wrap=False)\n    # Apply Neumann boundary conditions via ghost point method\n    A_stencil[0, 1] = 2.0\n    A_stencil[n - 1, n - 2] = 2.0\n    A = (D / dx**2) * A_stencil\n\n    # B vector (uniform source)\n    B = beta * np.ones(n)\n\n    # C vector (spatial average)\n    C = (1.0 / n) * np.ones((1, n))\n\n    # --- 3. Generate Training Data (Snapshots) ---\n    # Training input signal, u_k for k in {1, ..., m}\n    a_train, b_train = 1.0, 0.5\n    k_steps = np.arange(1, m + 1)\n    u_train = a_train * np.sin(2 * np.pi * k_steps / m) + b_train * np.sin(4 * np.pi * k_steps / m)\n\n    # Simulate FOM to get snapshots X = [x_1, ..., x_m]\n    X = np.zeros((n, m))\n    x_current = np.zeros(n)  # Initial condition x_0\n    for k in range(m):\n        # Explicit Euler update: x_{k+1} = x_k + h * (A*x_k + B*u_{k+1})\n        x_current = x_current + h * (A @ x_current + B * u_train[k])\n        X[:, k] = x_current\n\n    # --- 4. SVD of Snapshot Matrix ---\n    # Decompose X = U * Sigma * Vh. Use full_matrices=False for efficiency (n  m)\n    U, s, Vh = np.linalg.svd(X, full_matrices=False)\n    \n    # --- 5. Generate Evaluation Data (FOM Ground Truth) ---\n    # Evaluation input signal, u_k for k in {1, ..., m}\n    u_eval = np.zeros(m)\n    third_m = m // 3\n    u_eval[0:third_m] = 1.0\n    u_eval[third_m:2 * third_m] = -0.5\n    u_eval[2 * third_m:m] = 0.2\n\n    # Simulate FOM with evaluation input to get the true output y_k\n    y_fom_list = []\n    x_fom = np.zeros(n)\n    for k in range(m):\n        x_fom = x_fom + h * (A @ x_fom + B * u_eval[k])\n        y_fom_list.append(C @ x_fom)\n    y_fom = np.array(y_fom_list).flatten()\n    \n    # Pre-calculate singular value energies for rank selection\n    s_sq = s**2\n    total_energy = np.sum(s_sq)\n    cumulative_energy_ratio = np.cumsum(s_sq) / total_energy\n    \n    # --- 6. Loop over Tolerances to Build and Evaluate ROMs ---\n    results = []\n    k_max_rank = U.shape[1] # max possible rank is min(n, m)\n\n    for tau in test_cases:\n        # a) Rank Selection\n        if tau == 0.0:\n            r = 1\n        elif tau == 1.0:\n            r = k_max_rank\n        else:\n            # Find smallest r such that cumulative energy >= tau * total_energy\n            r = np.searchsorted(cumulative_energy_ratio, tau, side='left') + 1\n\n        # b) Build ROM via Galerkin Projection\n        Phi_r = U[:, :r]\n        Ar = Phi_r.T @ A @ Phi_r\n        Br = Phi_r.T @ B\n        Cr = C @ Phi_r\n\n        # c) Simulate ROM with evaluation input\n        y_rom_list = []\n        z_rom = np.zeros(r) # Initial reduced state\n        for k in range(m):\n            z_rom = z_rom + h * (Ar @ z_rom + Br * u_eval[k])\n            y_rom_list.append(Cr @ z_rom)\n        y_rom = np.array(y_rom_list).flatten()\n\n        # d) Calculate Metrics\n        # Relative root-mean-square error\n        err_num = np.sum((y_rom - y_fom)**2)\n        err_den = np.sum(y_fom**2)\n        \n        eps_rel = 0.0 if err_den == 0 else np.sqrt(err_num / err_den)\n\n        # Computational cost proxy\n        rho_cost = (r**2) / (3.0 * n)\n\n        results.append([r, eps_rel, rho_cost])\n    \n    # --- 7. Format and Print Final Output ---\n    output_str = \",\".join(map(str, results))\n    print(f\"[{output_str}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "我们之前的实践默认使用了标准的欧几里得内积，这相当于质量矩阵是单位矩阵。然而，许多高保真模型，特别是那些基于有限元方法（Finite Element Method, FEM）的模型，会产生非对角的“一致”质量矩阵。本实践将处理这一关键的现实问题。我们将实现一个数值稳定的算法——带重正交化的改进格拉姆-施密特（Modified Gram-Schmidt）过程，以创建一个相对于由质量矩阵 $M$ 定义的能量内积正交的基。这个被称为 $M$-正交归一性（$M$-orthonormality）的条件，能够确保降阶后的质量矩阵成为单位阵，从而简化降阶系统。掌握 $M$-正交归一化  对于将降阶技术稳健地应用于电池仿真中常见的各类物理模型至关重要。本实践将加深你对数值线性代数在构建性能优良且物理一致的降阶模型中所扮演角色的理解。",
            "id": "3943080",
            "problem": "考虑一个多孔电极中的输运与电化学动力学半离散模型，该模型通过在具有 $n$ 个节点的均匀网格上使用线性形函数，对长度为 $L$ 的一维平板进行一致的空间离散化而得到。所得的常微分方程组可以写成 $M \\,\\dot{x}(t) = A\\,x(t) + f(t)$ 的形式，其中 $M \\in \\mathbb{R}^{n \\times n}$ 是一个对称正定质量矩阵，它体现了有限元空间的加权 $L^2$ 内积；$A \\in \\mathbb{R}^{n \\times n}$ 是一个类刚度矩阵；$f(t)$ 是一个源项。在基于投影的降阶建模中，降阶基 $V \\in \\mathbb{R}^{n \\times r}$ 必须满足 $M$-正交归一性条件 $V^\\top M V = I_r$，其中 $I_r$ 是大小为 $r$ 的单位矩阵。$M$-正交归一性是关于内积 $\\langle u, v \\rangle_M = u^\\top M v$ 定义的。\n\n从对称正定矩阵诱导的内积的核心定义和正交投影的概念出发，实现一个数值稳定的修正 Gram-Schmidt 过程，将一组给定的候选向量 $W = [w_1, w_2, \\dots, w_k] \\in \\mathbb{R}^{n \\times k}$ 转换为一个 $M$-正交归一基 $Q = [q_1, q_2, \\dots, q_r] \\in \\mathbb{R}^{n \\times r}$（其中 $r \\leq k$），使得 $q_i^\\top M q_j = \\delta_{ij}$，其中 $\\delta_{ij}$ 是克罗内克 δ。如果某个候选向量在正交化过程中变得 $M$-近似线性相关，则应将其舍弃。该算法必须执行一次再正交化步骤以提高数值稳定性。\n\n使用以下经过充分检验的公式来构建均匀网格的一致有限元质量矩阵：对于每个长度为 $h = L/(n-1)$ 的单元，其局部质量矩阵为 $(h/6)\\begin{bmatrix}2  1 \\\\ 1  2\\end{bmatrix}$，而全局质量矩阵 $M$ 是通过对 $n-1$ 个单元进行标准组装得到的。这将产生一个对称正定、非对角的矩阵 $M$。\n\n定义以下测试套件。对于每种情况，按照所述方法组装一致质量矩阵来构建 $M$，并按指示确定性地构建 $W$。三角函数中的角度必须解释为弧度。\n\n- 情况 1 (一般情况，良态)：$n=8$, $L=1$。令 $x_i = \\frac{i}{n-1}$，其中 $i=0,1,\\dots,n-1$。定义 $W$，其列向量 $w_1$ 的元素为 $w_{1,i} = \\sin(\\pi x_i)$，列向量 $w_2$ 的元素为 $w_{2,i} = \\sin(2\\pi x_i)$，列向量 $w_3$ 的元素为 $w_{3,i} = \\cos(\\pi x_i)$。\n\n- 情况 2 (近线性相关)：$n=10$, $L=1$。令 $x_i = \\frac{i}{n-1}$，其中 $i=0,1,\\dots,n-1$。定义 $W$，其列向量 $w_1$ 的元素为 $w_{1,i} = \\sin(\\pi x_i)$，列向量 $w_2$ 的元素为 $w_{2,i} = w_{1,i} + 10^{-8}\\sin(2\\pi x_i)$，列向量 $w_3$ 的元素为 $w_{3,i} = \\cos(\\pi x_i)$。\n\n- 情况 3 (边界情况，零列)：$n=6$, $L=1$。令 $x_i = \\frac{i}{n-1}$，其中 $i=0,1,\\dots,n-1$。定义 $W$，其列向量 $w_1$ 的元素为 $w_{1,i} = 0$，列向量 $w_2$ 的元素为 $w_{2,i} = \\sin(\\pi x_i)$，列向量 $w_3$ 的元素为 $w_{3,i} = \\cos(2\\pi x_i)$。\n\n对于每种情况，计算：\n1. 使用修正 Gram-Schmidt 过程计算 $M$-正交归一基 $Q$，该过程包含一次再正交化步骤，并使用 $10^{-10}$ 的 $M$-范数容差来决定是否舍弃候选向量。\n2. 正交归一性残差 $\\|Q^\\top M Q - I_r\\|_F$ 的弗罗贝尼乌斯范数，结果为浮点数。\n3. 整数秩 $r$（被接受的向量数量）。\n\n您的程序应生成单行输出，其中包含三种情况的结果，这些结果按以下顺序聚合为一个用方括号括起来的逗号分隔列表：情况 1 的残差、情况 1 的秩、情况 2 的残差、情况 2 的秩、情况 3 的残差、情况 3 的秩。例如，它应打印一行类似 \"[0.0000001,3,0.000002,2,0.0,2]\" 的内容。由于这些量是无量纲的，因此不需要单位。",
            "solution": "用户要求实现一个数值稳定的修正 Gram-Schmidt (MGS) 过程，以从一组给定的候选向量生成一个 $M$-正交归一基。这个过程是基于投影的降阶建模的基石，特别是对于从有限元 (FE) 离散化（如此处描述的电池模型）派生的系统。基 $Q = [q_1, q_2, \\dots, q_r]$ 必须满足 $M$-正交归一性条件 $q_i^\\top M q_j = \\delta_{ij}$，其中 $M$ 是一个定义了加权内积的对称正定 (SPD) 矩阵。该实现必须包含一次用于提高数值稳定性的再正交化步骤，以及一个舍弃近似线性相关向量的机制。\n\n### 基于原理的设计\n\n**1. $M$-内积与 $M$-范数**\n\n对于一个 SPD 矩阵 $M \\in \\mathbb{R}^{n \\times n}$，两个向量 $u, v \\in \\mathbb{R}^n$ 之间的 $M$-内积定义为：\n$$\n\\langle u, v \\rangle_M = u^\\top M v\n$$\n内积的良定义性质（线性、对称性、正定性）由矩阵 $M$ 的性质保证。该内积诱导出 $M$-范数，它是向量大小的相应度量：\n$$\n\\|u\\|_M = \\sqrt{\\langle u, u \\rangle_M} = \\sqrt{u^\\top M u}\n$$\n在 Gram-Schmidt 过程中，这些定义取代了标准的欧几里得内积 ($u^\\top v$) 和范数 ($\\|u\\|_2$)。\n\n**2. 有限元质量矩阵组装**\n\n问题指定了用于长度为 $L$、具有 $n$ 个节点的一维均匀网格的一致质量矩阵 $M$。节点间距（单元长度）为 $h = L/(n-1)$。对于连接一对节点的每个单元，其局部质量矩阵为 $M_{\\text{local}} = \\frac{h}{6}\\begin{bmatrix}2  1 \\\\ 1  2\\end{bmatrix}$。全局质量矩阵 $M$ 通过以下方式形成：首先分配一个大小为 $n \\times n$ 的零矩阵，然后遍历 $n-1$ 个单元，将局部矩阵的元素加到相应的全局索引位置上。对于连接全局节点 $i$ 和 $i+1$ 的单元，其贡献被添加到子矩阵 $M([i, i+1], [i, i+1])$ 中。这个“组装”过程会产生一个 SPD、三对角的全局矩阵 $M$，其结构如下：\n$$\nM_{ij} = \\begin{cases}\n    2h/3  \\text{if } i=j \\text{ and } 1 \\le i \\le n-2 \\text{ (interior nodes)} \\\\\n    h/3   \\text{if } i=j \\text{ and } i=0 \\text{ or } i=n-1 \\text{ (boundary nodes)} \\\\\n    h/6   \\text{if } |i-j|=1 \\\\\n    0       \\text{otherwise}\n\\end{cases}\n$$\n\n**3. 带再正交化的修正 Gram-Schmidt (MGS) 过程**\n\n选择 MGS 算法是因为其相比经典版本具有更优越的数值稳定性。该算法迭代地对向量进行正交化和归一化。增加一次再正交化步骤以减轻因浮点运算仍可能发生的正交性损失。\n\n给定一组候选向量 $W = [w_1, w_2, \\dots, w_k]$，算法按以下步骤进行：\n\n1.  令 $V$ 为输入向量 $W$ 的一个可变副本。初始化一个空列表 $Q_{\\text{list}}$，用于存储生成的 $M$-正交归一基向量。\n2.  从 $i = 0$ 到 $k-1$ 遍历 $V$ 的各列：\n    a. 令 $v$ 为当前向量 $V[:, i]$。通过前面的步骤，该向量已经与 $Q_{\\text{list}}$ 中所有已有的基向量 $M$-正交。\n    b. **线性相关性检查**：计算向量的 $M$-范数 $\\rho = \\|v\\|_M$。如果 $\\rho$ 小于指定的容差 ($10^{-10}$)，则认为该向量与现有基数值上线性相关。该向量被舍弃，算法继续处理 $V$ 中的下一个向量。\n    c. **归一化**：如果 $\\rho$ 大于容差，则将向量归一化以创建一个新的基向量 $q$：\n       $$\n       q = \\frac{v}{\\rho}\n       $$\n       将 $q$ 追加到列表 $Q_{\\text{list}}$ 中。\n    d. **对剩余向量进行正交化**：对于每个后续向量 $u = V[:, j]$（其中 $j > i$），移除其沿着新基向量 $q$ 的分量。为实现再正交化，此步骤执行两次。\n       i.  **第一次处理**：计算投影系数并相减：\n           $$\n           u \\leftarrow u - \\langle u, q \\rangle_M \\, q\n           $$\n       ii. **第二次处理（再正交化）**：重复相减操作，以移除因数值误差产生的任何残余分量：\n           $$\n           u \\leftarrow u - \\langle u, q \\rangle_M \\, q\n           $$\n           更新后的向量 $u$ 替换 $V$ 中第 $j$ 列的旧版本。\n3.  处理完 $W$ 中的所有向量后，通过将 $Q_{\\text{list}}$ 中的向量按列堆叠来构建最终的基 $Q$。秩 $r$ 是此列表中的向量数量。\n\n**4. 评估指标**\n\n对于每个测试用例，该过程的成功与否由两个指标量化：\n\n*   **秩 ($r$)**：最终基 $Q$ 中的向量数量，它反映了由 $W$ 中线性无关向量张成的空间维度。\n*   **正交归一性残差**：残差矩阵的弗罗贝尼乌斯范数 $\\|Q^\\top M Q - I_r\\|_F$。该值衡量矩阵 $Q^\\top M Q$ 与单位矩阵 $I_r$ 的接近程度。接近零的值表示一个高质量的 $M$-正交归一基。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef assemble_mass_matrix(n: int, L: float) -> np.ndarray:\n    \"\"\"\n    Assembles the 1D finite element consistent mass matrix for linear shape functions\n    on a uniform mesh.\n\n    Args:\n        n: The number of nodes.\n        L: The length of the domain.\n\n    Returns:\n        The (n x n) global mass matrix M.\n    \"\"\"\n    if n  2:\n        return np.array([[L/3]]) if n == 1 else np.empty((0, 0))\n    \n    h = L / (n - 1)\n    M = np.zeros((n, n))\n    \n    # Local mass matrix for an element of length h\n    m_local = (h / 6.0) * np.array([[2, 1],\n                                     [1, 2]])\n\n    # Assembly loop over elements\n    for i in range(n - 1):\n        # Global indices for the current element\n        idx = np.array([i, i + 1])\n        M[np.ix_(idx, idx)] += m_local\n        \n    return M\n\ndef mgs_orthonormalization(W: np.ndarray, M: np.ndarray, tol: float) -> np.ndarray:\n    \"\"\"\n    Performs M-orthonormalization on a set of vectors W using the\n    modified Gram-Schmidt algorithm with one re-orthogonalization pass.\n\n    Args:\n        W: An (n x k) matrix where columns are the vectors to be orthonormalized.\n        M: The (n x n) symmetric positive-definite matrix defining the inner product.\n        tol: The tolerance for the M-norm to detect linear dependence.\n\n    Returns:\n        An (n x r) matrix Q where columns form an M-orthonormal basis (r = k).\n    \"\"\"\n    n, k = W.shape\n    V = W.copy().astype(np.float64)\n    Q_list = []\n\n    for i in range(k):\n        v_i = V[:, i]\n        \n        # Compute M-norm\n        m_norm_sq = v_i.T @ M @ v_i\n        if m_norm_sq  0: # Should not happen with SPD M, but for safety\n             m_norm = 0.0\n        else:\n             m_norm = np.sqrt(m_norm_sq)\n\n        # Check for linear dependence\n        if m_norm  tol:\n            continue\n\n        # Normalize to get the new basis vector\n        q = v_i / m_norm\n        Q_list.append(q)\n\n        # Orthogonalize remaining vectors against the new basis vector q\n        # with one re-orthogonalization pass.\n        for j in range(i + 1, k):\n            v_j = V[:, j]\n            \n            # First pass\n            coeff1 = q.T @ M @ v_j\n            v_j = v_j - coeff1 * q\n            \n            # Re-orthogonalization pass\n            coeff2 = q.T @ M @ v_j\n            v_j = v_j - coeff2 * q\n            \n            V[:, j] = v_j\n\n    if not Q_list:\n        return np.empty((n, 0))\n    \n    return np.stack(Q_list, axis=1)\n\ndef solve():\n    \"\"\"\n    Main solver function to run the test cases and print the results.\n    \"\"\"\n    test_cases = [\n        {\n            \"n\": 8, \"L\": 1.0,\n            \"W_funcs\": [\n                lambda x: np.sin(np.pi * x),\n                lambda x: np.sin(2 * np.pi * x),\n                lambda x: np.cos(np.pi * x)\n            ]\n        },\n        {\n            \"n\": 10, \"L\": 1.0,\n            \"W_funcs\": [\n                lambda x: np.sin(np.pi * x),\n                lambda x: np.sin(np.pi * x) + 1e-8 * np.sin(2 * np.pi * x),\n                lambda x: np.cos(np.pi * x)\n            ]\n        },\n        {\n            \"n\": 6, \"L\": 1.0,\n            \"W_funcs\": [\n                lambda x: np.zeros_like(x),\n                lambda x: np.sin(np.pi * x),\n                lambda x: np.cos(2 * np.pi * x)\n            ]\n        }\n    ]\n    \n    results = []\n    tol = 1e-10\n\n    for case in test_cases:\n        n, L, W_funcs = case[\"n\"], case[\"L\"], case[\"W_funcs\"]\n        x = np.linspace(0, L, n, dtype=np.float64)\n        \n        # Construct the candidate vectors matrix W\n        W = np.stack([func(x) for func in W_funcs], axis=1)\n        \n        # Construct the mass matrix M\n        M = assemble_mass_matrix(n, L)\n        \n        # Perform M-orthonormalization\n        Q = mgs_orthonormalization(W, M, tol)\n        \n        # Get the rank\n        r = Q.shape[1]\n        \n        # Compute the residual\n        if r > 0:\n            residual_matrix = Q.T @ M @ Q - np.identity(r)\n            residual_norm = np.linalg.norm(residual_matrix, 'fro')\n        else:\n            residual_norm = 0.0\n\n        results.append(residual_norm)\n        results.append(r)\n\n    # Print the final output in the required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}