{
    "hands_on_practices": [
        {
            "introduction": "Ensuring the numerical accuracy of Density Functional Theory (DFT) calculations is the bedrock of reliable materials prediction. This exercise focuses on a critical aspect of this process: convergence testing, specifically for layered electrode materials. You will derive the exfoliation energy from fundamental thermodynamic principles and implement a protocol to systematically assess how this energy converges with respect to simulation parameters like vacuum spacing and k-point sampling .",
            "id": "3904861",
            "problem": "You are designing an automated procedure to extract the exfoliation energy per unit area for a layered electrode material from Density Functional Theory (DFT) slab calculations and to assess convergence with respect to interlayer vacuum spacing and reciprocal-space sampling. Start from the following fundamental bases: (i) Density Functional Theory (DFT) ground-state energy is a variational quantity obtained as the minimum of a Kohn–Sham energy functional over electron densities, (ii) the reversible work required to separate a bound configuration into non-interacting fragments equals the difference in their ground-state energies, and (iii) periodic boundary conditions and discrete Brillouin-zone sampling introduce systematic errors that decay with increased vacuum and denser sampling. Use these bases to derive the exfoliation energy per area of a bilayer relative to two isolated monolayers and design convergence criteria.\n\nAssume a layered electrode material represented by periodic slabs with interlayer vacuum thickness $L$ (in $\\text{\\AA}$) and a uniform $k$-point grid of size $(k_x,k_y,k_z)$ with the total number of points $N = k_x k_y k_z$. Let the primitive surface area be $A$ (in $\\text{\\AA}^2$). Denote the infinite-vacuum, infinitely-dense $k$-point monolayer energy as $E_m^0$ (in $\\text{eV}$), and the corresponding bilayer energy as $E_b^0$ (in $\\text{eV}$). For finite $L$ and finite $N$, model the leading errors in the computed monolayer and bilayer energies as well-tested decays:\n$$\\Delta E_{\\text{vac}}(L) = \\frac{c}{L^3}, \\quad \\Delta E_{k}(N) = \\frac{d}{N^p},$$\nwith $c$ and $d$ positive constants (in $\\text{eV}\\cdot \\text{\\AA}^3$ and $\\text{eV}$, respectively), and exponent $p > 1$. The computed monolayer and bilayer energies are thus\n$$E_m(L,N) = E_m^0 + \\frac{c_m}{L^3} + \\frac{d_m}{N^p}, \\quad E_b(L,N) = E_b^0 + \\frac{c_b}{L^3} + \\frac{d_b}{N^p}.$$\nFrom first principles of reversible work and additivity of non-interacting fragments, formulate the exfoliation energy per area and implement it numerically using only the computed total energies $E_m(L,N)$ and $E_b(L,N)$ and the surface area $A$. The exfoliation energy must be expressed in Joules per square meter and reported rounded to three decimal places.\n\nConvergence assessment must be separated along each numerical axis:\n- Vacuum convergence at fixed $k$-grid: compare the exfoliation energy computed at $L_1$ and $L_2$ with the denser $k$-grid, and declare convergence if the absolute difference is below a given tolerance $\\tau_{\\text{vac}}$ (in $\\text{J}/\\text{m}^2$).\n- $k$-point convergence at fixed $L$: compare the exfoliation energy computed at $N_1$ and $N_2$ with the larger $L$, and declare convergence if the absolute difference is below a given tolerance $\\tau_{k}$ (in $\\text{J}/\\text{m}^2$).\n\nUse the following scientifically plausible and self-consistent parameters, constants, and test suite. All quantities are to be treated exactly as specified:\n- Physical constants and material parameters:\n  - Surface area $A = 8.0$ $\\text{\\AA}^2$.\n  - Infinite-limit monolayer energy $E_m^0 = -100.0$ $\\text{eV}$.\n  - Infinite-limit bilayer energy $E_b^0 = -200.17475$ $\\text{eV}$.\n  - Vacuum error coefficients $c_m = 0.25$ $\\text{eV}\\cdot \\text{\\AA}^3$, $c_b = 0.35$ $\\text{eV}\\cdot \\text{\\AA}^3$.\n  - $k$-point error coefficients $d_m = 0.03$ $\\text{eV}$, $d_b = 0.045$ $\\text{eV}$, and exponent $p = 1.2$.\n  - Unit conversion factor from electronvolt per square Angstrom to Joule per square meter: $u = 16.0218$.\n\n- Test suite of three cases. For each case, you are given $(L_1,L_2)$, $(k_x^{(1)},k_y^{(1)},k_z^{(1)})$, $(k_x^{(2)},k_y^{(2)},k_z^{(2)})$, $\\tau_{\\text{vac}}$, and $\\tau_k$. You must:\n  1. Compute the exfoliation energy at $(L_2,(k_x^{(2)},k_y^{(2)},k_z^{(2)}))$ in $\\text{J}/\\text{m}^2$, rounded to three decimal places.\n  2. Assess vacuum convergence using $(L_1,L_2)$ at the denser $k$-grid $(k_x^{(2)},k_y^{(2)},k_z^{(2)})$ and $\\tau_{\\text{vac}}$.\n  3. Assess $k$-point convergence using $(k_x^{(1)},k_y^{(1)},k_z^{(1)})$, $(k_x^{(2)},k_y^{(2)},k_z^{(2)})$ at the larger vacuum $L_2$ and $\\tau_k$.\n\n  The cases are:\n  - Case $1$: $(L_1,L_2) = (12,16)$, $(k_x^{(1)},k_y^{(1)},k_z^{(1)}) = (9,9,1)$, $(k_x^{(2)},k_y^{(2)},k_z^{(2)}) = (12,12,1)$, $\\tau_{\\text{vac}} = 0.001$, $\\tau_k = 0.001$.\n  - Case $2$: $(L_1,L_2) = (6,8)$, $(k_x^{(1)},k_y^{(1)},k_z^{(1)}) = (3,3,1)$, $(k_x^{(2)},k_y^{(2)},k_z^{(2)}) = (6,6,1)$, $\\tau_{\\text{vac}} = 0.0005$, $\\tau_k = 0.001$.\n  - Case $3$: $(L_1,L_2) = (20,24)$, $(k_x^{(1)},k_y^{(1)},k_z^{(1)}) = (18,18,1)$, $(k_x^{(2)},k_y^{(2)},k_z^{(2)}) = (21,21,1)$, $\\tau_{\\text{vac}} = 0.0002$, $\\tau_k = 0.0002$.\n\nYour program must implement the above model, compute the exfoliation energy for each case at $(L_2,(k_x^{(2)},k_y^{(2)},k_z^{(2)}))$, test the two convergence criteria, and produce a single line of output containing the results as a comma-separated list enclosed in square brackets. For each case, the output must include the exfoliation energy value (in $\\text{J}/\\text{m}^2$, rounded to three decimal places), the vacuum convergence boolean, and the $k$-point convergence boolean, flattened into one list in the order of the cases, for example $[e_1,b_{1,\\text{vac}},b_{1,k},e_2,b_{2,\\text{vac}},b_{2,k},e_3,b_{3,\\text{vac}},b_{3,k}]$ where $e_i$ are floats and $b_{i,\\cdot}$ are booleans.",
            "solution": "The problem requires the formulation and implementation of a procedure to calculate the exfoliation energy of a layered material and assess its numerical convergence with respect to simulation parameters. The derivation is founded on the principles of Density Functional Theory (DFT) and thermodynamics.\n\nThe exfoliation of a bilayer into two non-interacting monolayers is a physical process that can be characterized by the reversible work required. According to fundamental thermodynamics, this work is equal to the change in the system's ground-state energy. Let $E_b$ be the ground-state energy of the bilayer and $E_m$ be the ground-state energy of a single monolayer. The initial state is the bilayer, with energy $E_b$. The final state consists of two separated, non-interacting monolayers, with a total energy of $2E_m$. The exfoliation energy, $E_{\\text{exf}}$, is therefore:\n$$E_{\\text{exf}} = E_{\\text{final}} - E_{\\text{initial}} = 2E_m - E_b$$\nFor a stable, bound bilayer, $E_b < 2E_m$, making $E_{\\text{exf}}$ a positive quantity, representing the energy cost of separation. The problem requires the exfoliation energy per unit area, $e_{\\text{exf}}$, which is obtained by dividing by the surface area of the primitive cell, $A$:\n$$e_{\\text{exf}} = \\frac{E_{\\text{exf}}}{A} = \\frac{2E_m - E_b}{A}$$\nIn practice, DFT calculations are performed using finite numerical parameters, which introduce systematic errors. The problem provides models for the computed energies of the monolayer, $E_m(L, N)$, and the bilayer, $E_b(L, N)$, as functions of the interlayer vacuum spacing $L$ and the total number of $k$-points $N$. These models are:\n$$E_m(L,N) = E_m^0 + \\frac{c_m}{L^3} + \\frac{d_m}{N^p}$$\n$$E_b(L,N) = E_b^0 + \\frac{c_b}{L^3} + \\frac{d_b}{N^p}$$\nHere, $E_m^0$ and $E_b^0$ are the true ground-state energies in the limit of infinite vacuum and infinitely dense $k$-point sampling. The terms proportional to $L^{-3}$ model the spurious electrostatic interactions between periodic images of the slab, while the terms proportional to $N^{-p}$ model the error from discretizing the Brillouin zone integration.\n\nSubstituting these expressions into the formula for the exfoliation energy per area yields:\n$$e_{\\text{exf}}(L, N) = \\frac{1}{A} \\left[ 2 \\left( E_m^0 + \\frac{c_m}{L^3} + \\frac{d_m}{N^p} \\right) - \\left( E_b^0 + \\frac{c_b}{L^3} + \\frac{d_b}{N^p} \\right) \\right]$$\nThis expression can be rearranged by grouping terms corresponding to the ideal energy and the error contributions:\n$$e_{\\text{exf}}(L, N) = \\frac{1}{A} \\left[ (2E_m^0 - E_b^0) + (2c_m - c_b)\\frac{1}{L^3} + (2d_m - d_b)\\frac{1}{N^p} \\right]$$\nThe first term, $(2E_m^0 - E_b^0)/A$, represents the true physical exfoliation energy per area. The subsequent terms represent the combined numerical error in the exfoliation energy arising from finite vacuum and $k$-point sampling. The final result must be converted from electronvolts per square Angstrom ($\\text{eV}/\\text{\\AA}^2$) to Joules per square meter ($\\text{J}/\\text{m}^2$) by multiplying by the given unit conversion factor, $u = 16.0218$. The complete formula for the computed exfoliation energy in the desired units is:\n$$e_{\\text{exf, J/m^2}}(L, N) = u \\cdot e_{\\text{exf}}(L, N) = \\frac{u}{A} \\left[ (2E_m^0 - E_b^0) + \\frac{2c_m - c_b}{L^3} + \\frac{2d_m - d_b}{N^p} \\right]$$\nTo ensure the reliability of the computed energy, we must assess its convergence. The problem specifies two independent convergence checks.\n\n1.  **Vacuum Convergence**: This test assesses the sensitivity of the result to the vacuum spacing $L$. It is performed at a fixed, dense $k$-point grid ($N_2 = k_x^{(2)}k_y^{(2)}k_z^{(2)}$) by comparing the exfoliation energies calculated at two different vacuum spacings, $L_1$ and $L_2$. The absolute difference is calculated:\n    $$\\Delta_{\\text{vac}} = |e_{\\text{exf, J/m^2}}(L_2, N_2) - e_{\\text{exf, J/m^2}}(L_1, N_2)|$$\n    Convergence is achieved if this difference is below a specified tolerance, $\\tau_{\\text{vac}}$: $\\Delta_{\\text{vac}} < \\tau_{\\text{vac}}$.\n\n2.  **$k$-point Convergence**: This test assesses the sensitivity to the density of the reciprocal-space grid. It is performed at a fixed, large vacuum spacing ($L_2$) by comparing the energies calculated with two different $k$-point grids, yielding $N_1 = k_x^{(1)}k_y^{(1)}k_z^{(1)}$ and $N_2$ total points. The absolute difference is:\n    $$\\Delta_{k} = |e_{\\text{exf, J/m^2}}(L_2, N_2) - e_{\\text{exf, J/m^2}}(L_2, N_1)|$$\n    Convergence is achieved if this difference is below its tolerance, $\\tau_k$: $\\Delta_k < \\tau_k$.\n\nThe numerical implementation will involve creating a function that computes $e_{\\text{exf, J/m^2}}(L, N)$ using the given parameters. This function is then called with the appropriate arguments for each test case to compute the target exfoliation energy at $(L_2, N_2)$, to perform the two convergence checks, and to format the results as specified.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of calculating exfoliation energy and its convergence\n    for a layered material based on a DFT model.\n    \"\"\"\n\n    # Physical constants and material parameters\n    A = 8.0  # Surface area in Å^2\n    E_m0 = -100.0  # Infinite-limit monolayer energy in eV\n    E_b0 = -200.17475  # Infinite-limit bilayer energy in eV\n    c_m = 0.25  # Monolayer vacuum error coefficient in eV*Å^3\n    c_b = 0.35  # Bilayer vacuum error coefficient in eV*Å^3\n    d_m = 0.03  # Monolayer k-point error coefficient in eV\n    d_b = 0.045  # Bilayer k-point error coefficient in eV\n    p = 1.2  # k-point error exponent\n    u = 16.0218  # Conversion factor from eV/Å^2 to J/m^2\n\n    # Pre-calculate constant terms for the exfoliation energy expression\n    E_exf0_term = 2 * E_m0 - E_b0\n    c_exf_term = 2 * c_m - c_b\n    d_exf_term = 2 * d_m - d_b\n    u_over_A = u / A\n\n    def calculate_exfoliation_energy(L, N):\n        \"\"\"\n        Calculates the exfoliation energy per area in J/m^2 for a given\n        vacuum spacing L and total number of k-points N.\n        \n        Args:\n            L (float): Interlayer vacuum thickness in Å.\n            N (int): Total number of k-points.\n\n        Returns:\n            float: Exfoliation energy in J/m^2.\n        \"\"\"\n        energy_ev_per_a2 = (E_exf0_term + \n                              c_exf_term / (L**3) + \n                              d_exf_term / (N**p))\n        \n        return u_over_A * energy_ev_per_a2\n\n    # Test suite of cases\n    test_cases = [\n        {'L': (12, 16), 'k': ((9, 9, 1), (12, 12, 1)), 'tau_vac': 0.001, 'tau_k': 0.001},\n        {'L': (6, 8), 'k': ((3, 3, 1), (6, 6, 1)), 'tau_vac': 0.0005, 'tau_k': 0.001},\n        {'L': (20, 24), 'k': ((18, 18, 1), (21, 21, 1)), 'tau_vac': 0.0002, 'tau_k': 0.0002},\n    ]\n\n    results = []\n    for case in test_cases:\n        L1, L2 = case['L']\n        k1_dims, k2_dims = case['k']\n        tau_vac, tau_k = case['tau_vac'], case['tau_k']\n\n        N1 = k1_dims[0] * k1_dims[1] * k1_dims[2]\n        N2 = k2_dims[0] * k2_dims[1] * k2_dims[2]\n\n        # 1. Compute the exfoliation energy at (L2, N2)\n        e_target = calculate_exfoliation_energy(L2, N2)\n        e_rounded = round(e_target, 3)\n\n        # 2. Assess vacuum convergence at the denser k-grid (N2)\n        e_vac_ref = calculate_exfoliation_energy(L1, N2)\n        delta_vac = abs(e_target - e_vac_ref)\n        is_vac_converged = delta_vac  tau_vac\n\n        # 3. Assess k-point convergence at the larger vacuum (L2)\n        e_k_ref = calculate_exfoliation_energy(L2, N1)\n        delta_k = abs(e_target - e_k_ref)\n        is_k_converged = delta_k  tau_k\n        \n        results.extend([e_rounded, is_vac_converged, is_k_converged])\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "While DFT provides ground-state energies at zero Kelvin, real-world batteries operate at finite temperatures. This practice bridges that gap by demonstrating how to calculate the open-circuit voltage, a key performance metric, under realistic operating conditions. You will learn to augment static DFT energies with contributions from lattice vibrations and configurational entropy to construct the Gibbs free energy landscape .",
            "id": "3904866",
            "problem": "You are asked to implement a principled computational workflow to include vibrational free energy and configurational entropy corrections into the finite-temperature Gibbs free energy $G(T)$ of lithium-intercalation electrode materials, and to use this to predict open-circuit voltages at finite temperature. The scenario is grounded in Density Functional Theory (DFT), a quantum mechanical method used to obtain $E_{\\mathrm{DFT}}$ total energies, and Statistical Mechanics for vibrational and configurational contributions. Your program must compute $G(T)$ for given compositions, combine it into a reaction free energy for a lithium insertion step using the chemical potential of lithium metal, and then translate this into a voltage.\n\nStart from the following foundational facts and definitions:\n- Gibbs free energy is defined as $G = U - T S + p V$. For condensed-phase solids at ambient conditions, the $pV$ term is negligible, so $G(T)$ can be approximated as $G(T) \\approx E_{\\mathrm{DFT}} + F_{\\mathrm{vib}}(T) - T S_{\\mathrm{conf}}(x)$, where $E_{\\mathrm{DFT}}$ is the total energy from Density Functional Theory (DFT), $F_{\\mathrm{vib}}(T)$ is the vibrational Helmholtz free energy at temperature $T$, and $S_{\\mathrm{conf}}(x)$ is the configurational entropy associated with lithium/vacancy mixing at fractional occupancy $x$ on a set of equivalent sites.\n- In the harmonic approximation for phonons, each normal mode with angular frequency $\\omega_i$ contributes to the vibrational Helmholtz free energy as\n$$\nF_{\\mathrm{vib}}(T) = \\sum_{i} \\left( \\frac{1}{2}\\hbar \\omega_i + k_B T \\ln\\left(1 - e^{-\\hbar \\omega_i / (k_B T)} \\right) \\right),\n$$\nwhere $k_B$ is the Boltzmann constant, and $\\hbar$ is the reduced Planck constant. If frequencies are provided in cycles per second $f_i$, then $\\omega_i = 2 \\pi f_i$.\n- For a binary ideal mixing of lithium and vacancy on $N_{\\mathrm{sites}}$ equivalent sites per formula unit, the configurational entropy is\n$$\nS_{\\mathrm{conf}}(x) = -k_B N_{\\mathrm{sites}} \\left[ x \\ln x + (1-x) \\ln (1-x) \\right],\n$$\nfor $0  x  1$, and $S_{\\mathrm{conf}}(0) = S_{\\mathrm{conf}}(1) = 0$ by continuity.\n- For the lithium insertion reaction from $x_2$ to $x_1$ in the host,\n$$\n\\Delta G(T) = G_{\\mathrm{host}}(x_1,T) - G_{\\mathrm{host}}(x_2,T) - (x_1 - x_2)\\,\\mu_{\\mathrm{Li}}(T),\n$$\nwhere $\\mu_{\\mathrm{Li}}(T)$ is the chemical potential of lithium metal per atom (approximated via DFT and vibrational contributions), and\n$$\nG_{\\mathrm{host}}(x,T) = E_{\\mathrm{DFT}}^{\\mathrm{host}}(x) + F_{\\mathrm{vib}}^{\\mathrm{host}}(x,T) - T S_{\\mathrm{conf}}(x).\n$$\n- The open-circuit voltage at temperature $T$ is given by\n$$\nV(T) = -\\frac{\\Delta G(T)}{x_1 - x_2}.\n$$\nWhen all energies are tracked in electronvolts per formula unit and per atom, this expression yields the voltage in volts because $1\\,\\mathrm{eV}$ per electron corresponds to $1\\,\\mathrm{V}$.\n\nYour program must implement the above principles with the following numerical and physical inputs and conventions:\n- Use $k_B = 8.617333262\\times 10^{-5}\\,\\mathrm{eV/K}$ and $\\hbar = 6.582119569\\times 10^{-16}\\,\\mathrm{eV\\cdot s}$. Use $\\omega = 2\\pi f$ and $1\\,\\mathrm{THz} = 10^{12}\\,\\mathrm{Hz}$. All vibrational frequencies are given in terahertz (THz).\n- Host composition is parameterized by the lithium fraction $x$ per formula unit, with $N_{\\mathrm{sites}} = 1$ site per formula unit. Use the following Density Functional Theory (DFT) total energies for the host in electronvolts (per formula unit):\n    - $E_{\\mathrm{DFT}}^{\\mathrm{host}}(0.0) = -100.000\\,\\mathrm{eV}$,\n    - $E_{\\mathrm{DFT}}^{\\mathrm{host}}(0.5) = -102.500\\,\\mathrm{eV}$,\n    - $E_{\\mathrm{DFT}}^{\\mathrm{host}}(0.95) = -104.100\\,\\mathrm{eV}$,\n    - $E_{\\mathrm{DFT}}^{\\mathrm{host}}(1.0) = -104.200\\,\\mathrm{eV}$.\n- Vibrational frequencies (in THz) for the host at each composition $x$ (per formula unit, harmonic normal modes):\n    - For $x=0.0$: $[5.0,\\,8.0,\\,12.0,\\,15.0,\\,3.0,\\,7.0,\\,10.0,\\,14.0,\\,18.0]$,\n    - For $x=0.5$: $[4.5,\\,7.5,\\,11.5,\\,14.5,\\,2.5,\\,6.5,\\,9.5,\\,13.5,\\,17.0]$,\n    - For $x=0.95$: $[4.2,\\,7.0,\\,11.0,\\,14.0,\\,2.2,\\,6.2,\\,9.2,\\,13.2,\\,16.5]$,\n    - For $x=1.0$: $[4.0,\\,6.8,\\,10.8,\\,13.8,\\,2.0,\\,6.0,\\,9.0,\\,13.0,\\,16.0]$.\n- Lithium metal (per atom) DFT energy and vibrational frequencies (in THz):\n    - $E_{\\mathrm{DFT}}^{\\mathrm{Li}} = -1.600\\,\\mathrm{eV}$,\n    - frequencies $[2.0,\\,4.0,\\,6.0]$.\n\nAlgorithmic requirements:\n- Implement a robust evaluation of $F_{\\mathrm{vib}}(T)$ that returns the zero-point energy $\\sum_i \\frac{1}{2}\\hbar\\omega_i$ at $T=0$, and otherwise uses the full harmonic free energy expression. Avoid numerical issues by implementing a threshold for very small $T$.\n- Implement $S_{\\mathrm{conf}}(x)$ with numerically stable handling of $x=0$ and $x=1$ so that $S_{\\mathrm{conf}}(0)=S_{\\mathrm{conf}}(1)=0$.\n\nTest Suite:\nCompute voltages in volts (V), rounded to six decimal places, for the following four cases:\n1. $T = 300\\,\\mathrm{K}$, $x_2=0.0$, $x_1=0.5$.\n2. $T = 1\\,\\mathrm{K}$, $x_2=0.0$, $x_1=0.5$.\n3. $T = 1000\\,\\mathrm{K}$, $x_2=0.5$, $x_1=1.0$.\n4. $T = 300\\,\\mathrm{K}$, $x_2=0.95$, $x_1=1.0$.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[v_1,v_2,v_3,v_4]$), where each $v_i$ is the predicted voltage in volts rounded to six decimal places. No other text should be printed. All internal computations must use the provided constants and units consistently, and the final answers must be expressed in $\\mathrm{V}$.",
            "solution": "The problem requires the implementation of a computational workflow to determine the open-circuit voltage of a lithium-intercalation electrode at finite temperatures. The methodology is rooted in the principles of density functional theory (DFT) for total energy calculations and statistical mechanics for thermal and entropic contributions to the Gibbs free energy. The solution will be constructed following a rigorous, step-by-step derivation based on the provided physical models and data.\n\nThe Gibbs free energy, $G(T)$, for a solid phase at temperature $T$ under negligible pressure is approximated by the Helmholtz free energy, $A(T) = U - TS$. In our model, this is further decomposed as:\n$$\nG(T) \\approx G(x,T) = E_{\\mathrm{DFT}}(x) + F_{\\mathrm{vib}}(x,T) - T S_{\\mathrm{conf}}(x)\n$$\nHere, $x$ is the fractional occupancy of lithium, $E_{\\mathrm{DFT}}(x)$ is the static total energy at $T=0\\,\\mathrm{K}$ obtained from DFT, $F_{\\mathrm{vib}}(x,T)$ is the vibrational Helmholtz free energy, and $S_{\\mathrm{conf}}(x)$ is the configurational entropy arising from the statistical arrangement of lithium ions and vacancies.\n\nThe computational procedure is structured as follows:\n\n1.  **Modeling of Thermodynamic Quantities:** We first establish robust functions to compute the constituent thermodynamic quantities for any given composition and temperature.\n\n    -   **Vibrational Helmholtz Free Energy, $F_{\\mathrm{vib}}(T)$:** Within the harmonic approximation, the vibrational free energy for a set of normal modes with angular frequencies $\\{\\omega_i\\}$ is given by:\n        $$\n        F_{\\mathrm{vib}}(T) = \\sum_{i} \\left( \\frac{1}{2}\\hbar \\omega_i + k_B T \\ln\\left(1 - e^{-\\hbar \\omega_i / (k_B T)} \\right) \\right)\n        $$\n        The first term, $\\sum_i \\frac{1}{2}\\hbar \\omega_i$, is the temperature-independent zero-point energy (ZPE). The second term represents the thermal contribution to the free energy. The implementation must handle the conversion of input frequencies $f_i$ (in THz) to angular frequencies $\\omega_i = 2 \\pi f_i$. Numerically, for very small $T$, the argument of the logarithm approaches $0$, which can lead to instability. At $T \\to 0\\,\\mathrm{K}$, the logarithmic term vanishes, and $F_{\\mathrm{vib}}(0)$ correctly reduces to the ZPE. Our implementation respects this limit and uses numerically stable library functions (i.e., `numpy.log1p`) to evaluate the logarithmic term accurately. The physical constants used are the Boltzmann constant $k_B=8.617333262\\times 10^{-5}\\,\\mathrm{eV/K}$ and the reduced Planck constant $\\hbar = 6.582119569\\times 10^{-16}\\,\\mathrm{eV\\cdot s}$.\n\n    -   **Configurational Entropy, $S_{\\mathrm{conf}}(x)$:** For an ideal solid solution of lithium and vacancies on $N_{\\mathrm{sites}}$ equivalent sites per formula unit, the configurational entropy is given by the Boltzmann formula for mixing:\n        $$\n        S_{\\mathrm{conf}}(x) = -k_B N_{\\mathrm{sites}} \\left[ x \\ln x + (1-x) \\ln (1-x) \\right]\n        $$\n        This expression is valid for $x \\in (0,1)$. For the pure phases, $x=0$ and $x=1$, there is no configurational disorder, so $S_{\\mathrm{conf}}(0)=S_{\\mathrm{conf}}(1)=0$. The implementation must explicitly handle these endpoint conditions to avoid numerical errors from evaluating $\\ln(0)$. The problem specifies $N_{\\mathrm{sites}} = 1$.\n\n2.  **Calculation of Chemical Potentials and Gibbs Free Energies:**\n\n    -   **Chemical Potential of Lithium Metal, $\\mu_{\\mathrm{Li}}(T)$:** The reference for the lithium chemical potential is taken as pure lithium metal. Its Gibbs free energy per atom is calculated as:\n        $$\n        \\mu_{\\mathrm{Li}}(T) = G_{\\mathrm{Li}}(T) = E_{\\mathrm{DFT}}^{\\mathrm{Li}} + F_{\\mathrm{vib}}^{\\mathrm{Li}}(T)\n        $$\n        Here, $E_{\\mathrm{DFT}}^{\\mathrm{Li}}$ and the vibrational frequencies for Li metal are provided. The configurational entropy for a pure element is zero.\n\n    -   **Gibbs Free Energy of the Host Material, $G_{\\mathrm{host}}(x,T)$:** Using the functions developed in the first step and the provided DFT energies and vibrational frequencies for the host material at various compositions $x$, we compute the total Gibbs free energy per formula unit:\n        $$\n        G_{\\mathrm{host}}(x,T) = E_{\\mathrm{DFT}}^{\\mathrm{host}}(x) + F_{\\mathrm{vib}}^{\\mathrm{host}}(x,T) - T S_{\\mathrm{conf}}(x)\n        $$\n\n3.  **Determination of the Open-Circuit Voltage:** The electromotive force, or open-circuit voltage ($V$), is determined by the change in Gibbs free energy for the electrochemical reaction. For the insertion of $(x_1 - x_2)$ moles of lithium into the host material, the reaction is $\\mathrm{Host}(x_2) + (x_1 - x_2)\\mathrm{Li} \\rightarrow \\mathrm{Host}(x_1)$. The change in Gibbs free energy for this process is:\n    $$\n    \\Delta G(T) = G_{\\mathrm{host}}(x_1,T) - G_{\\mathrm{host}}(x_2,T) - (x_1 - x_2)\\,\\mu_{\\mathrm{Li}}(T)\n    $$\n    The voltage is the negative of the free energy change per mole of charge transferred. With all energies in electronvolts (eV) and considering the transfer of $(x_1 - x_2)$ electrons (for $(x_1 - x_2)$ Li$^+$ ions), the voltage in volts (V) is:\n    $$\n    V(T) = -\\frac{\\Delta G(T)}{x_1 - x_2} = -\\left( \\frac{G_{\\mathrm{host}}(x_1,T) - G_{\\mathrm{host}}(x_2,T)}{x_1 - x_2} - \\mu_{\\mathrm{Li}}(T) \\right)\n    $$\n    The term $\\frac{G_{\\mathrm{host}}(x_1,T) - G_{\\mathrm{host}}(x_2,T)}{x_1 - x_2}$ is a finite-difference approximation of the chemical potential of lithium in the host, $\\mu_{\\mathrm{Li}}^{\\mathrm{host}}(T)$.\n\nThe final program implements this entire workflow. It defines the physical constants and input data, implements the functions for $F_{\\mathrm{vib}}(T)$ and $S_{\\mathrm{conf}}(x)$, and then combines them to calculate $G_{\\mathrm{host}}(x,T)$ and $\\mu_{\\mathrm{Li}}(T)$. Finally, it iterates through the specified test cases, computes the voltage for each, rounds the result to six decimal places, and prints the formatted output.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes open-circuit voltages at finite temperature for a Li-intercalation electrode.\n    The calculation is based on DFT total energies and statistical mechanics for\n    vibrational and configurational contributions to the Gibbs free energy.\n    \"\"\"\n\n    # Define the physical constants provided in the problem statement.\n    k_B = 8.617333262e-5  # Boltzmann constant in eV/K\n    hbar = 6.582119569e-16 # Reduced Planck constant in eV*s\n\n    # Define the input data for the host material.\n    E_dft_host = {\n        0.0: -100.000,\n        0.5: -102.500,\n        0.95: -104.100,\n        1.0: -104.200,\n    }\n    freqs_host = {\n        0.0: np.array([5.0, 8.0, 12.0, 15.0, 3.0, 7.0, 10.0, 14.0, 18.0]),\n        0.5: np.array([4.5, 7.5, 11.5, 14.5, 2.5, 6.5, 9.5, 13.5, 17.0]),\n        0.95: np.array([4.2, 7.0, 11.0, 14.0, 2.2, 6.2, 9.2, 13.2, 16.5]),\n        1.0: np.array([4.0, 6.8, 10.8, 13.8, 2.0, 6.0, 9.0, 13.0, 16.0]),\n    }\n    N_sites = 1\n\n    # Define the input data for Lithium metal.\n    E_dft_li = -1.600\n    freqs_li = np.array([2.0, 4.0, 6.0])\n\n    def calculate_F_vib(T, freqs_thz):\n        \"\"\"\n        Calculates the vibrational Helmholtz free energy F_vib(T) in the harmonic approximation.\n        \n        Args:\n            T (float): Temperature in Kelvin.\n            freqs_thz (np.ndarray): Array of vibrational frequencies in THz.\n\n        Returns:\n            float: Vibrational free energy in eV.\n        \"\"\"\n        # omega = 2 * pi * f\n        omegas = 2 * np.pi * freqs_thz * 1e12  # Angular frequencies in rad/s\n\n        # Zero-point energy (ZPE) = sum(0.5 * hbar * omega)\n        zpe = 0.5 * hbar * np.sum(omegas)\n\n        # At T=0, F_vib is just the ZPE. Use a small threshold for numerical stability.\n        if T  1e-6:\n            return zpe\n\n        # Thermal contribution to free energy\n        k_B_T = k_B * T\n        hbar_omegas = hbar * omegas\n        \n        # Argument of the exponential: x = hbar * omega / (k_B * T)\n        # Avoid division by zero if k_B_T is zero, though already handled by T check.\n        exponents = hbar_omegas / k_B_T\n        \n        # Use np.log1p for better numerical precision for log(1-y) where y is small.\n        # log(1 - exp(-x)) = log1p(-exp(-x))\n        thermal_terms = k_B_T * np.log1p(-np.exp(-exponents))\n        thermal_F = np.sum(thermal_terms)\n        \n        return zpe + thermal_F\n\n    def calculate_S_conf(x):\n        \"\"\"\n        Calculates the configurational entropy S_conf(x) for ideal binary mixing.\n\n        Args:\n            x (float): Lithium fraction, between 0 and 1.\n\n        Returns:\n            float: Configurational entropy in eV/K.\n        \"\"\"\n        # For pure phases (x=0 or x=1), entropy is 0. Use tolerance for float comparison.\n        if x  1e-9 or x > (1.0 - 1e-9):\n            return 0.0\n        \n        return -k_B * N_sites * (x * np.log(x) + (1 - x) * np.log(1 - x))\n\n    def calculate_G_host(x, T):\n        \"\"\"\n        Calculates the Gibbs free energy G(x, T) for the host material.\n        \n        Args:\n            x (float): Lithium fraction.\n            T (float): Temperature in Kelvin.\n            \n        Returns:\n            float: Gibbs free energy in eV.\n        \"\"\"\n        E_dft = E_dft_host[x]\n        freqs = freqs_host[x]\n        \n        F_vib = calculate_F_vib(T, freqs)\n        S_conf = calculate_S_conf(x)\n        \n        return E_dft + F_vib - T * S_conf\n\n    def calculate_mu_li(T):\n        \"\"\"\n        Calculates the chemical potential mu(T) for lithium metal.\n\n        Args:\n            T (float): Temperature in Kelvin.\n\n        Returns:\n            float: Chemical potential of Li metal in eV/atom.\n        \"\"\"\n        F_vib = calculate_F_vib(T, freqs_li)\n        # S_conf for a pure element is 0.\n        return E_dft_li + F_vib\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (300, 0.0, 0.5),   # Case 1\n        (1, 0.0, 0.5),     # Case 2\n        (1000, 0.5, 1.0),  # Case 3\n        (300, 0.95, 1.0),  # Case 4\n    ]\n\n    results = []\n    for T, x2, x1 in test_cases:\n        # Calculate Gibbs free energies for the host at initial and final compositions\n        G_host_x1 = calculate_G_host(x1, T)\n        G_host_x2 = calculate_G_host(x2, T)\n        \n        # Calculate the chemical potential of the Li reservoir\n        mu_li_T = calculate_mu_li(T)\n        \n        # Calculate the change in Gibbs free energy for the reaction\n        delta_x = x1 - x2\n        delta_G = G_host_x1 - G_host_x2 - delta_x * mu_li_T\n        \n        # Calculate the voltage\n        voltage = -delta_G / delta_x\n        \n        # Round to six decimal places as specified\n        results.append(round(voltage, 6))\n\n    # Format the final list of results into the required output string.\n    # Using .6f ensures that numbers like 2.0 are printed as 2.000000.\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Beyond predicting macroscopic properties, DFT is a powerful tool for uncovering the fundamental physics governing charge transport in electrodes. This practice delves into identifying small polarons, where a charge carrier localizes itself by distorting the surrounding lattice. You will design and implement a quantitative diagnostic that combines information from the charge density and local structural changes to confirm the presence of this crucial quasiparticle .",
            "id": "3904815",
            "problem": "You are tasked with designing and implementing a programmatic diagnostic to confirm small polaron localization in electrode materials using Density Functional Theory (DFT). The diagnostic must be grounded in the physical picture that a localized charge in a crystal produces a spatially concentrated change in electron density and induces local structural distortions. The task must begin from the following fundamental base: Kohn-Sham Density Functional Theory (DFT) defines the ground-state electron density $\\rho(\\mathbf{r})$ of an interacting electron system; the presence or removal of an electron produces a change $\\Delta \\rho(\\mathbf{r}) = \\rho_{\\text{charged}}(\\mathbf{r}) - \\rho_{\\text{neutral}}(\\mathbf{r})$. A small polaron is a quasi-particle consisting of a charge localized over a small number of atomic sites together with a local lattice distortion due to electron–phonon coupling. From this base, derive a mathematically precise diagnostic that combines a measure of spatial localization of the charge density difference and a measure of local distortion magnitude. Implement this diagnostic in a program that takes discrete data and outputs a boolean per case indicating whether a polaron is localized.\n\nYou will work with a discrete approximation in which the domain is partitioned into $N$ disjoint basins or cells $\\{\\Omega_i\\}_{i=1}^N$. The charge difference per cell is defined as $\\Delta q_i = \\int_{\\Omega_i} \\Delta \\rho(\\mathbf{r})\\,\\mathrm{d}^3 r$ measured in electrons. Because both electron ($\\Delta q_i > 0$) and hole ($\\Delta q_i  0$) polarons are possible, your localization measure must depend on $|\\Delta q_i|$. You are also given local bond lengths around the candidate polaron site for the reference (undistorted) and the relaxed (distorted) structures. Bond lengths are provided in angstroms and must be treated consistently as such.\n\nYour derived diagnostic must produce a boolean decision for each test case using the following thresholds, which you must apply to your derived measures without shortcutting their derivation:\n- The effective number of sites over which the charge is localized must be less than or equal to $S_{\\mathrm{max}} = 3.0$.\n- The average local bond-length distortion magnitude must be greater than or equal to $D_{\\mathrm{min}} = 0.02$.\n\nAngles are not involved. Bond lengths are in angstroms. Distortion is dimensionless by construction. The final output for each test case must be a boolean indicating whether both conditions are satisfied based on your derived measures.\n\nYour program must implement the diagnostic for the following test suite. Each test case provides $(N, \\{\\Delta q_i\\}_{i=1}^N, \\{d^{(0)}_j\\}_{j=1}^M, \\{d_j\\}_{j=1}^M)$ where $N$ is the number of cells, $\\Delta q_i$ are the per-cell charge differences in electrons, $d^{(0)}_j$ are the reference bond lengths in angstroms, and $d_j$ are the relaxed bond lengths in angstroms. The number of bonds $M$ equals $6$ for all cases.\n\n- Case A (happy path: electron polaron localized with significant distortion): $N = 12$, $\\{\\Delta q_i\\} = [0.02, 0.01, 0.01, 0.02, 0.02, 0.80, 0.06, 0.02, 0.01, 0.00, 0.00, 0.01]$, $\\{d^{(0)}_j\\} = [2.00, 2.00, 2.00, 2.00, 2.00, 2.00]$ angstrom, $\\{d_j\\} = [2.10, 2.06, 1.94, 1.95, 2.00, 2.00]$ angstrom.\n- Case B (delocalized charge with minimal distortion): $N = 12$, $\\{\\Delta q_i\\} = [0.083, 0.083, 0.083, 0.083, 0.083, 0.083, 0.083, 0.083, 0.083, 0.083, 0.083, 0.083]$, $\\{d^{(0)}_j\\} = [2.00, 2.00, 2.00, 2.00, 2.00, 2.00]$ angstrom, $\\{d_j\\} = [2.01, 2.01, 1.99, 1.99, 2.00, 2.00]$ angstrom.\n- Case C (hole polaron localized with significant distortion): $N = 12$, $\\{\\Delta q_i\\} = [-0.02, -0.01, -0.01, -0.02, -0.02, -0.75, -0.08, -0.03, -0.02, 0.00, 0.00, -0.01]$, $\\{d^{(0)}_j\\} = [2.00, 2.00, 2.00, 2.00, 2.00, 2.00]$ angstrom, $\\{d_j\\} = [1.90, 1.95, 2.06, 2.05, 2.00, 2.00]$ angstrom.\n- Case D (borderline density localization but insufficient distortion): $N = 12$, $\\{\\Delta q_i\\} = [0.02, 0.01, 0.01, 0.02, 0.02, 0.80, 0.06, 0.02, 0.01, 0.00, 0.00, 0.01]$, $\\{d^{(0)}_j\\} = [2.00, 2.00, 2.00, 2.00, 2.00, 2.00]$ angstrom, $\\{d_j\\} = [2.01, 2.00, 1.99, 2.00, 2.00, 2.00]$ angstrom.\n- Case E (two-site polaron with moderate distortion): $N = 12$, $\\{\\Delta q_i\\} = [0.00, 0.00, 0.00, 0.48, 0.48, 0.01, 0.01, 0.00, 0.00, 0.00, 0.00, 0.00]$, $\\{d^{(0)}_j\\} = [2.00, 2.00, 2.00, 2.00, 2.00, 2.00]$ angstrom, $\\{d_j\\} = [2.08, 2.06, 1.94, 1.94, 2.00, 2.00]$ angstrom.\n\nYour program must:\n- Derive from first principles a normalization of $\\{|\\Delta q_i|\\}$ to a discrete probability distribution over $N$ cells, a mathematically justified localization index based on this distribution, and a distortion metric based on the provided bond lengths.\n- Determine polaron localization as a boolean per case by checking whether the derived effective support size is less than or equal to $S_{\\mathrm{max}}$ and whether the derived average distortion is greater than or equal to $D_{\\mathrm{min}}$.\n- Produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example, $[\\text{result}_A,\\text{result}_B,\\text{result}_C,\\text{result}_D,\\text{result}_E]$.\n\nThe final output type for each case is a boolean. Bond lengths must be treated in angstroms. Distortion must be dimensionless. No angles are involved. The program must not read external files or take input and must operate only on the provided test suite.",
            "solution": "The problem statement has been analyzed and is deemed to be valid. It is scientifically grounded in the principles of Density Functional Theory and the physics of small polarons. The problem is well-posed, providing a self-contained set of data and clear objectives, requiring the derivation of physically meaningful metrics from first principles. The language is objective and the provided numerical data are physically plausible. The task is to derive a diagnostic and apply it, which constitutes a non-trivial but solvable problem in computational materials science.\n\nThe objective is to formulate a quantitative diagnostic for small polaron localization based on two criteria: the spatial localization of the charge density difference, $\\Delta\\rho(\\mathbf{r})$, and the magnitude of the associated local lattice distortion. We are given discrete data for charge and bond lengths and must produce a boolean decision for several test cases.\n\nFirst, we derive a metric for charge localization. The problem provides the net charge difference, $\\Delta q_i$, within $N$ discrete cells, where $\\Delta q_i = \\int_{\\Omega_i} \\Delta \\rho(\\mathbf{r})\\,\\mathrm{d}^3 r$. A localized polaron implies that the majority of the excess charge (for an electron polaron, $\\sum_i \\Delta q_i \\approx +1$) or charge deficit (for a hole polaron, $\\sum_i \\Delta q_i \\approx -1$) is concentrated in a small number of cells. To create a universal metric applicable to both electron and hole polarons, we must work with the magnitude of the charge difference, $|\\Delta q_i|$.\n\nWe can conceptualize the distribution of the charge change magnitude as a discrete probability distribution. Let us define a set of non-negative weights $w_i = |\\Delta q_i|$ for each cell $i=1, \\dots, N$. To form a probability distribution $\\{p_i\\}$, we normalize these weights:\n$$\np_i = \\frac{w_i}{\\sum_{k=1}^N w_k} = \\frac{|\\Delta q_i|}{\\sum_{k=1}^N |\\Delta q_k|}\n$$\nThis quantity $p_i$ represents the fraction of the total magnitude of charge redistribution occurring in cell $i$. By construction, $p_i \\ge 0$ and $\\sum_{i=1}^N p_i = 1$.\n\nA highly localized charge distribution corresponds to a probability distribution that is sharply peaked, whereas a delocalized charge corresponds to a uniform-like distribution. A standard and physically meaningful way to quantify the degree of localization of a distribution is through its information entropy. The Shannon entropy of the distribution $\\{p_i\\}$ is given by:\n$$\nH = -\\sum_{i=1}^N p_i \\ln p_i\n$$\nwhere the term $p_i \\ln p_i$ is taken to be $0$ if $p_i=0$. The entropy $H$ is minimal ($H=0$) for a perfectly localized distribution where all charge is in one cell ($p_k=1$ for some $k$, and $p_{i \\ne k}=0$). It is maximal ($H=\\ln N$) for a perfectly delocalized distribution where the charge is spread evenly across all $N$ cells ($p_i=1/N$ for all $i$).\n\nTo interpret this entropy as an \"effective number of sites\" over which the charge is spread, we define the localization index $S$ as the exponential of the entropy:\n$$\nS = \\exp(H) = \\exp\\left(-\\sum_{i=1}^N p_i \\ln p_i\\right)\n$$\nThis quantity, sometimes known as the perplexity or number of effective modes, ranges from $S=1$ for perfect localization on a single site to $S=N$ for perfect delocalization over $N$ sites. The first condition for polaron localization is that this effective number of sites must be below a given threshold, $S_{\\mathrm{max}}$:\n$$\nS \\le S_{\\mathrm{max}} = 3.0\n$$\n\nSecond, we derive a metric for the local lattice distortion. We are given $M$ reference bond lengths, $\\{d_j^{(0)}\\}_{j=1}^M$, and the corresponding bond lengths in the relaxed (charged) structure, $\\{d_j\\}_{j=1}^M$. The problem requires a dimensionless measure of the average distortion magnitude.\n\nFor each bond $j$, the change in length is $\\Delta d_j = d_j - d_j^{(0)}$. To make this change dimensionless and independent of the absolute bond length, we compute the fractional distortion:\n$$\n\\delta_j = \\frac{d_j - d_j^{(0)}}{d_j^{(0)}}\n$$\nSince distortion can involve both bond elongation ($\\delta_j > 0$) and compression ($\\delta_j  0$), and we are interested in the overall magnitude of the structural change, we consider the absolute value of the fractional distortion, $|\\delta_j|$.\n\nTo obtain a single metric representing the average local distortion, we take the arithmetic mean of these magnitudes over all $M$ bonds:\n$$\nD = \\frac{1}{M}\\sum_{j=1}^M |\\delta_j| = \\frac{1}{M}\\sum_{j=1}^M \\left| \\frac{d_j - d_j^{(0)}}{d_j^{(0)}} \\right|\n$$\nThis metric $D$ is a dimensionless, positive-semidefinite quantity that quantifies the average magnitude of bond length changes around the polaron site. The second condition for polaron localization is that this average distortion must be above a given threshold, $D_{\\mathrm{min}}$:\n$$\nD \\ge D_{\\mathrm{min}} = 0.02\n$$\n\nThe final polaron diagnostic is a boolean AND of these two conditions. A system is determined to host a localized small polaron if and only if both the charge is sufficiently localized ($S \\le S_{\\mathrm{max}}$) and the lattice distortion is sufficiently large ($D \\ge D_{\\mathrm{min}}$). This combined criterion correctly captures the dual nature of the polaron as a quasiparticle of both charge and lattice-distortion character. The logic will now be implemented and applied to the provided test cases.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ... # Scipy is available but not required for this implementation.\n\ndef solve():\n    \"\"\"\n    Derives and applies a diagnostic for small polaron localization based on DFT data.\n    The diagnostic evaluates two conditions:\n    1. Charge Localization: The effective number of sites for charge spread must be low.\n    2. Lattice Distortion: The average local bond distortion must be high.\n    A polaron is considered localized if both conditions are met.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = {\n        \"Case A\": {\n            \"N\": 12,\n            \"delta_q\": np.array([0.02, 0.01, 0.01, 0.02, 0.02, 0.80, 0.06, 0.02, 0.01, 0.00, 0.00, 0.01]),\n            \"d0\": np.array([2.00, 2.00, 2.00, 2.00, 2.00, 2.00]),\n            \"d\": np.array([2.10, 2.06, 1.94, 1.95, 2.00, 2.00]),\n        },\n        \"Case B\": {\n            \"N\": 12,\n            \"delta_q\": np.array([0.083, 0.083, 0.083, 0.083, 0.083, 0.083, 0.083, 0.083, 0.083, 0.083, 0.083, 0.083]),\n            \"d0\": np.array([2.00, 2.00, 2.00, 2.00, 2.00, 2.00]),\n            \"d\": np.array([2.01, 2.01, 1.99, 1.99, 2.00, 2.00]),\n        },\n        \"Case C\": {\n            \"N\": 12,\n            \"delta_q\": np.array([-0.02, -0.01, -0.01, -0.02, -0.02, -0.75, -0.08, -0.03, -0.02, 0.00, 0.00, -0.01]),\n            \"d0\": np.array([2.00, 2.00, 2.00, 2.00, 2.00, 2.00]),\n            \"d\": np.array([1.90, 1.95, 2.06, 2.05, 2.00, 2.00]),\n        },\n        \"Case D\": {\n            \"N\": 12,\n            \"delta_q\": np.array([0.02, 0.01, 0.01, 0.02, 0.02, 0.80, 0.06, 0.02, 0.01, 0.00, 0.00, 0.01]),\n            \"d0\": np.array([2.00, 2.00, 2.00, 2.00, 2.00, 2.00]),\n            \"d\": np.array([2.01, 2.00, 1.99, 2.00, 2.00, 2.00]),\n        },\n        \"Case E\": {\n            \"N\": 12,\n            \"delta_q\": np.array([0.00, 0.00, 0.00, 0.48, 0.48, 0.01, 0.01, 0.00, 0.00, 0.00, 0.00, 0.00]),\n            \"d0\": np.array([2.00, 2.00, 2.00, 2.00, 2.00, 2.00]),\n            \"d\": np.array([2.08, 2.06, 1.94, 1.94, 2.00, 2.00]),\n        },\n    }\n\n    # Define thresholds from the problem statement\n    S_max = 3.0\n    D_min = 0.02\n\n    def check_polaron_localization(delta_q, d0, d):\n        \"\"\"\n        Calculates the localization index S and distortion metric D for a single case.\n        Returns a boolean indicating if the polaron is localized.\n        \"\"\"\n        # 1. Calculate the charge localization index S\n        abs_delta_q = np.abs(delta_q)\n        total_abs_q = np.sum(abs_delta_q)\n\n        # Handle the edge case of no charge difference\n        if total_abs_q == 0:\n            # If there's no charge, it's perfectly delocalized over all sites.\n            # Could be N, but this case isn't physically interesting for a polaron search.\n            # In any case, it's not localized on a few sites.\n            S = float('inf') \n        else:\n            p = abs_delta_q / total_abs_q\n            # Filter out p_i = 0 to avoid log(0) errors. The term p_i*log(p_i) is 0 for p_i=0.\n            p_nonzero = p[p > 0]\n            # Calculate Shannon entropy H\n            H = -np.sum(p_nonzero * np.log(p_nonzero))\n            # Calculate localization index S (effective number of sites)\n            S = np.exp(H)\n        \n        is_charge_localized = (S = S_max)\n\n        # 2. Calculate the lattice distortion metric D\n        # Use np.divide to handle potential division by zero if a bond length is 0,\n        # although physically d0 should always be positive.\n        fractional_distortion = np.divide(d - d0, d0)\n        D = np.mean(np.abs(fractional_distortion))\n        \n        is_distorted = (D >= D_min)\n\n        # 3. Final polaron diagnostic\n        is_polaron_localized = is_charge_localized and is_distorted\n        \n        return is_polaron_localized\n\n    results = []\n    # The order of cases must be preserved for the final output.\n    case_order = [\"Case A\", \"Case B\", \"Case C\", \"Case D\", \"Case E\"]\n    for case_name in case_order:\n        case_data = test_cases[case_name]\n        result = check_polaron_localization(case_data[\"delta_q\"], case_data[\"d0\"], case_data[\"d\"])\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # The output format for booleans in Python's str() is 'True' or 'False'.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}