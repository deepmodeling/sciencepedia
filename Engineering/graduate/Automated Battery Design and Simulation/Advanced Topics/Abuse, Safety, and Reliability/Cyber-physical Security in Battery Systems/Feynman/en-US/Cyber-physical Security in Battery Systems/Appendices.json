{
    "hands_on_practices": [
        {
            "introduction": "Effective control of battery systems often relies on model-based predictive control (MPC), but a critical vulnerability arises when the controller's internal model naively trusts sensor data that may be compromised. This practice provides a direct, hands-on demonstration of this risk by simulating a scenario where a small, malicious bias on a current sensor deceives an MPC into violating thermal safety limits. By building and comparing a naive controller with a corrected, robust version, you will gain a concrete understanding of why a controller's predictions must be based on its own commanded actions, not potentially corrupted measurements.",
            "id": "3903073",
            "problem": "Consider a single-lumped thermal model of a battery module subjected to charging current, with dynamics derived from conservation of energy and Newtonian cooling. The thermal energy balance is modeled as follows. Let $T(t)$ denote the bulk temperature in Kelvin, $I(t)$ the charging current in Ampere, $R$ the equivalent internal resistance in Ohm, $h$ the effective heat transfer coefficient in Watt per Kelvin, $C_{\\mathrm{th}}$ the lumped thermal capacitance in Joule per Kelvin, and $T_{\\mathrm{amb}}$ the ambient temperature in Kelvin. The continuous-time energy balance is\n$$\nC_{\\mathrm{th}} \\frac{dT}{dt} = I(t)^2 R - h \\left( T(t) - T_{\\mathrm{amb}} \\right).\n$$\nAssume a forward Euler time discretization with time-step $dt$ seconds, so the discrete-time update is\n$$\nT_{k+1} = T_k + \\frac{dt}{C_{\\mathrm{th}}}\\left( I_k^2 R - h \\left( T_k - T_{\\mathrm{amb}} \\right) \\right),\n$$\nwhere $T_k$ is the temperature at discrete time index $k$, and $I_k$ is the applied current in Ampere.\n\nA sensor attack introduces a biased current measurement. The measured current is modeled as\n$$\nI_m = I + b,\n$$\nwhere $I$ is the true current and $b$ is a bias in Ampere, constant over the horizon, representing a targeted under-reporting attack when $b < 0$.\n\nA naive Model Predictive Control (MPC) scheme is assumed to choose a constant charging current $I$ over a finite horizon of $N$ steps to maximize the current subject to an estimated thermal safety constraint that the predicted temperature remains below a safety limit $T_{\\max}$ Kelvin. The naive scheme relies on nominal measurements by substituting $I_m$ for $I$ inside the prediction model, implicitly assuming $b=0$. That is, for candidate constant $I$, it predicts temperature using $I_m = I + b$ instead of the true $I$, and accepts the largest candidate that keeps the predicted temperature within the constraint.\n\nConstruct a counterexample demonstrating that this naive MPC can violate the true thermal constraint under a small but targeted negative bias $b$ in the current measurement, even when the predicted temperature appears safe. Then, implement a corrected design that eliminates this violation by replacing the reliance on $I_m$ in the prediction and enforcing robust constraint tightening against the bias magnitude, specifically by evaluating the thermal constraint with the commanded current $I$ and not the measured $I_m$. The corrected controller must select the largest constant $I$ whose predicted temperature using the true commanded input remains below $T_{\\max}$ for the entire horizon.\n\nYour program must:\n- Implement the discrete-time thermal model and simulate the temperature trajectory for a constant current $I$ over $N$ steps.\n- Implement the naive controller that selects $I$ by predicting with $I_m = \\max(I+b,0)$ in the model.\n- Implement the corrected controller that selects $I$ by predicting with the true commanded current $I$ in the model.\n- For each test case below, report the maximum true temperature over the horizon for the naive controller and for the corrected controller, both expressed in Kelvin, rounded to two decimal places. Also report boolean indicators of constraint violation with the true temperature relative to $T_{\\max}$ for each controller.\n\nAll angles, if any were involved, would have to be in radians, but this problem has no angles. All physical units are in the International System of Units (SI). The final output format must be a single line containing the results for all test cases as a comma-separated list enclosed in square brackets, where each test case result is a list formatted as\n$$\n[\\text{max\\_T\\_naive},\\, \\text{max\\_T\\_corrected},\\, \\text{naive\\_violated},\\, \\text{corrected\\_violated}],\n$$\nwith temperatures in Kelvin and booleans indicating violation.\n\nTest suite parameter sets:\n- Case A (happy path, no bias): $C_{\\mathrm{th}} = 600\\,\\mathrm{J/K}$, $R = 0.02\\,\\Omega$, $h = 1.5\\,\\mathrm{W/K}$, $T_{\\mathrm{amb}} = 298\\,\\mathrm{K}$, $T_0 = 298\\,\\mathrm{K}$, $T_{\\max} = 313\\,\\mathrm{K}$, $dt = 1\\,\\mathrm{s}$, $N = 1200$, $I_{\\max} = 50\\,\\mathrm{A}$, grid step $\\Delta I = 0.5\\,\\mathrm{A}$, $b = 0\\,\\mathrm{A}$.\n- Case B (counterexample, targeted small bias): $C_{\\mathrm{th}} = 600\\,\\mathrm{J/K}$, $R = 0.02\\,\\Omega$, $h = 1.5\\,\\mathrm{W/K}$, $T_{\\mathrm{amb}} = 298\\,\\mathrm{K}$, $T_0 = 298\\,\\mathrm{K}$, $T_{\\max} = 313\\,\\mathrm{K}$, $dt = 1\\,\\mathrm{s}$, $N = 1200$, $I_{\\max} = 50\\,\\mathrm{A}$, grid step $\\Delta I = 0.5\\,\\mathrm{A}$, $b = -1.0\\,\\mathrm{A}$.\n- Case C (boundary bias near threshold): $C_{\\mathrm{th}} = 600\\,\\mathrm{J/K}$, $R = 0.02\\,\\Omega$, $h = 1.5\\,\\mathrm{W/K}$, $T_{\\mathrm{amb}} = 298\\,\\mathrm{K}$, $T_0 = 298\\,\\mathrm{K}$, $T_{\\max} = 313\\,\\mathrm{K}$, $dt = 1\\,\\mathrm{s}$, $N = 1200$, $I_{\\max} = 50\\,\\mathrm{A}$, grid step $\\Delta I = 0.5\\,\\mathrm{A}$, $b = -0.5\\,\\mathrm{A}$.\n- Case D (edge case with high thermal mass and cooling): $C_{\\mathrm{th}} = 2000\\,\\mathrm{J/K}$, $R = 0.02\\,\\Omega$, $h = 4.0\\,\\mathrm{W/K}$, $T_{\\mathrm{amb}} = 298\\,\\mathrm{K}$, $T_0 = 298\\,\\mathrm{K}$, $T_{\\max} = 313\\,\\mathrm{K}$, $dt = 1\\,\\mathrm{s}$, $N = 1200$, $I_{\\max} = 50\\,\\mathrm{A}$, grid step $\\Delta I = 0.5\\,\\mathrm{A}$, $b = -1.0\\,\\mathrm{A}$.\n\nImplementation notes:\n- The controller selects the largest constant current $I$ from the grid $\\{0, \\Delta I, 2\\Delta I, \\ldots, I_{\\max}\\}$ whose predicted temperature sequence never exceeds $T_{\\max}$. The naive prediction uses $I_m = \\max(I+b,0)$ inside the heating term, while the corrected prediction uses the commanded $I$ inside the heating term.\n- The true temperature evolution is always simulated using the commanded $I$ (the actuator is assumed uncompromised), and the maximum true temperature is compared against $T_{\\max}$ to compute violation booleans.\n- Express maximum temperatures in Kelvin, rounded to two decimal places. Booleans must be exact logical values.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for the test cases in the exact order A, B, C, D. For example, the output should look like\n$$\n[[300.00,300.00,\\text{False},\\text{False}],[\\dots],[\\dots],[\\dots]]\n$$\nbut with the actual numerical values for each case.",
            "solution": "The problem requires a critical comparison between a naive and a corrected Model Predictive Control (MPC) strategy for managing the thermal state of a battery. The core of the problem is to demonstrate a security vulnerability where a small, malicious bias in a sensor measurement can lead a naive controller to violate safety constraints, and to implement a robust controller that mitigates this vulnerability.\n\nThe physical system is a battery module described by a single-lumped thermal model. The energy balance is given by the differential equation:\n$$\nC_{\\mathrm{th}} \\frac{dT}{dt} = I(t)^2 R - h \\left( T(t) - T_{\\mathrm{amb}} \\right)\n$$\nwhere $T(t)$ is the temperature, $I(t)$ is the current, $C_{\\mathrm{th}}$ is the thermal capacitance, $R$ is the internal resistance, $h$ is the heat transfer coefficient, and $T_{\\mathrm{amb}}$ is the ambient temperature.\n\nUsing a forward Euler discretization with a time step of $dt$, the discrete-time temperature update rule is:\n$$\nT_{k+1} = T_k + \\frac{dt}{C_{\\mathrm{th}}}\\left( I_k^2 R - h \\left( T_k - T_{\\mathrm{amb}} \\right) \\right)\n$$\nThis equation forms the basis for both simulation and prediction.\n\nA sensor attack introduces a bias $b$ to the current measurement, such that the measured current $I_m$ is related to the true current $I$ by $I_m = I + b$. For an under-reporting attack, $b < 0$.\n\nThe task is to implement and evaluate two control strategies.\n\n1.  **Simulation of Temperature Trajectory:**\n    A core function is created to simulate the temperature evolution over a horizon of $N$ steps. This function takes a constant current $I_{heat}$ (representing the current used in the Joule heating term $I^2R$) and the system parameters, and iteratively applies the discrete-time update rule to compute the temperature trajectory $T_0, T_1, \\dots, T_N$. The maximum temperature over this trajectory is then recorded. This function is versatile and can be used for both predicting future temperatures and simulating the true system response.\n\n2.  **Naive Controller Logic:**\n    The naive controller aims to select the maximum possible constant charging current $I$ from a discrete grid $\\{\\Delta I, 2\\Delta I, \\dots, I_{\\max}\\}$ that it believes is safe. Its belief is based on a prediction model that is compromised by the sensor attack. It substitutes the measured current, $I_m = \\max(I+b, 0)$, for the true current in its internal prediction model. Specifically, for each candidate current $I$, it predicts the temperature trajectory using $I_m$ in the heating term:\n    $$\n    T_{k+1, \\text{pred}} = T_{k, \\text{pred}} + \\frac{dt}{C_{\\mathrm{th}}}\\left( I_m^2 R - h \\left( T_{k, \\text{pred}} - T_{\\mathrm{amb}} \\right) \\right)\n    $$\n    It checks if the maximum predicted temperature $\\max(T_{\\text{pred}})$ remains below the safety limit $T_{\\max}$. The controller selects the largest candidate $I$ that satisfies this condition. The flaw is that it trusts the biased measurement for a safety-critical decision. When $b < 0$, $I_m < I$, causing the controller to underestimate the heat generation $I^2 R$ and thus potentially select a current that is truly unsafe.\n\n3.  **Corrected Controller Logic:**\n    The corrected, or robust, controller rectifies the flaw of the naive controller. It understands that sensor measurements can be unreliable and should not be used for predicting the consequences of its own actions. Instead, it uses the commanded (actuated) current $I$ directly in its prediction model. For each candidate current $I$, it predicts the temperature using $I$ itself:\n    $$\n    T_{k+1, \\text{pred}} = T_{k, \\text{pred}} + \\frac{dt}{C_{\\mathrm{th}}}\\left( I^2 R - h \\left( T_{k, \\text{pred}} - T_{\\mathrm{amb}} \\right) \\right)\n    $$\n    This prediction accurately reflects the physical consequences of applying current $I$. The controller selects the largest candidate $I$ from the grid for which the predicted temperature trajectory does not exceed $T_{\\max}$. This design is robust to the sensor measurement bias because the prediction loop is closed on the command signal, not the compromised sensor signal.\n\n4.  **Evaluation and Counterexample (Case B):**\n    For each test case, we first determine the currents selected by both the naive ($I_{\\text{naive}}$) and corrected ($I_{\\text{corrected}}$) controllers. Then, we simulate the **true** physical system's response to each of these currents. The true response is always governed by the actual commanded current $I$, not $I_m$.\n    \n    Let's analyze Test Case B: $C_{\\mathrm{th}} = 600\\,\\mathrm{J/K}$, $R = 0.02\\,\\Omega$, $h = 1.5\\,\\mathrm{W/K}$, $T_{\\mathrm{amb}} = 298\\,\\mathrm{K}$, $T_{\\max} = 313\\,\\mathrm{K}$, and a bias $b = -1.0\\,\\mathrm{A}$.\n    - **Corrected Controller**: It seeks the largest $I$ such that the true temperature, which approaches the steady-state $T_{ss} = I^2 R/h + T_{\\mathrm{amb}}$, remains below $T_{\\max} = 313\\,\\mathrm{K}$. The condition $I^2 (0.02)/(1.5) + 298 \\le 313$ implies $I \\le \\sqrt{15 \\times 1.5 / 0.02} = \\sqrt{1125} \\approx 33.54\\,\\mathrm{A}$. The largest current on the grid with step $\\Delta I = 0.5\\,\\mathrm{A}$ is $I_{\\text{corrected}} = 33.5\\,\\mathrm{A}$. The true maximum temperature for this current approaches $312.96\\,\\mathrm{K}$, which is safe.\n    - **Naive Controller**: It predicts safety using $I_m = I - 1.0$. It seeks the largest $I$ where the prediction is safe. The predicted steady state is $(I-1.0)^2 R/h + T_{\\mathrm{amb}} \\le 313\\,\\mathrm{K}$, which implies $I-1.0 \\le 33.54\\,\\mathrm{A}$, or $I \\le 34.54\\,\\mathrm{A}$. The controller selects the largest grid current satisfying this, $I_{\\text{naive}} = 34.5\\,\\mathrm{A}$. It *believes* this is safe because its prediction uses an effective current of $33.5\\,\\mathrm{A}$.\n    - **True Outcome**: The system is actually subjected to $I = 34.5\\,\\mathrm{A}$. The true steady-state temperature is $(34.5)^2 (0.02)/(1.5) + 298 \\approx 313.87\\,\\mathrm{K}$. Since the time horizon of $N=1200$ steps is long enough (three times the thermal time constant $\\tau = C_{th}/h = 400\\,\\mathrm{s}$), the temperature will exceed the $313\\,\\mathrm{K}$ limit. This demonstrates the failure: the naive controller, deceived by the sensor bias, applies a current that violates the safety constraint.\n\nThe final program implements this logic for all specified test cases, reporting the maximum true temperature achieved and the corresponding constraint violation status for both controllers.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        # Case A (happy path, no bias)\n        (600, 0.02, 1.5, 298, 298, 313, 1, 1200, 50, 0.5, 0.0),\n        # Case B (counterexample, targeted small bias)\n        (600, 0.02, 1.5, 298, 298, 313, 1, 1200, 50, 0.5, -1.0),\n        # Case C (boundary bias near threshold)\n        (600, 0.02, 1.5, 298, 298, 313, 1, 1200, 50, 0.5, -0.5),\n        # Case D (edge case with high thermal mass and cooling)\n        (2000, 0.02, 4.0, 298, 298, 313, 1, 1200, 50, 0.5, -1.0),\n    ]\n\n    def simulate_temperature(I_heat, C_th, R, h, T_amb, T0, dt, N):\n        \"\"\"\n        Simulates the battery temperature over N steps for a constant heating current.\n        \"\"\"\n        T_trajectory = np.zeros(N + 1)\n        T_trajectory[0] = T0\n        T_k = T0\n        for k in range(N):\n            dT_dt = (I_heat**2 * R - h * (T_k - T_amb)) / C_th\n            T_k = T_k + dt * dT_dt\n            T_trajectory[k+1] = T_k\n        return T_trajectory\n\n    def find_current(params, use_naive_prediction):\n        \"\"\"\n        Finds the largest safe current based on the specified prediction model.\n        \"\"\"\n        C_th, R, h, T_amb, T0, T_max, dt, N, I_max, delta_I, b = params\n        \n        candidate_currents = np.arange(I_max, -delta_I, -delta_I)\n        chosen_I = 0.0\n\n        for I_cand in candidate_currents:\n            if use_naive_prediction:\n                I_pred = max(I_cand + b, 0.0)\n            else:\n                I_pred = I_cand\n            \n            predicted_trajectory = simulate_temperature(I_pred, C_th, R, h, T_amb, T0, dt, N)\n            \n            if np.max(predicted_trajectory) <= T_max:\n                chosen_I = I_cand\n                break\n        return chosen_I\n\n    results = []\n    for params in test_cases:\n        C_th, R, h, T_amb, T0, T_max, dt, N, I_max, delta_I, b = params\n\n        # 1. Determine current chosen by naive controller\n        I_naive = find_current(params, use_naive_prediction=True)\n        \n        # 2. Determine current chosen by corrected controller\n        I_corrected = find_current(params, use_naive_prediction=False)\n\n        # 3. Simulate TRUE temperature evolution for naive controller's choice\n        true_T_trajectory_naive = simulate_temperature(I_naive, C_th, R, h, T_amb, T0, dt, N)\n        max_T_naive = np.max(true_T_trajectory_naive)\n        naive_violated = max_T_naive > T_max\n\n        # 4. Simulate TRUE temperature evolution for corrected controller's choice\n        true_T_trajectory_corrected = simulate_temperature(I_corrected, C_th, R, h, T_amb, T0, dt, N)\n        max_T_corrected = np.max(true_T_trajectory_corrected)\n        corrected_violated = max_T_corrected > T_max\n\n        results.append(\n            f\"[{max_T_naive:.2f},{max_T_corrected:.2f},{naive_violated},{corrected_violated}]\"\n        )\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Once we understand that sensor data can be misleading, the next logical step is to develop methods for detecting anomalous behavior. This practice introduces a powerful model-based technique using reachable sets, which formally define the envelope of all possible safe states for a system. You will learn to determine if a new measurement falls outside this certified safe-operating region and to quantify the statistical confidence of your anomaly detection, providing a rigorous foundation for building intelligent and secure battery monitoring systems.",
            "id": "3903065",
            "problem": "A grid-connected modular lithium-ion battery pack is monitored by a state estimator that outputs a reachable set for the cell-averaged cyber-physical state vector $x \\in \\mathbb{R}^{2}$ consisting of state-of-charge and temperature, denoted $x = [\\mathrm{SOC}, T]^{\\top}$. Over a fixed prediction horizon and under bounded actuation and thermal inputs, the automated design tool certifies that the reachable set at the sampling instant is the ellipsoid\n$$\n\\mathcal{E} = \\left\\{ x \\in \\mathbb{R}^{2} : (x - \\mu)^{\\top} S^{-1} (x - \\mu) \\leq 1 \\right\\},\n$$\nwith center $\\mu = \\begin{pmatrix} 0.6 \\\\ 300 \\end{pmatrix}$ and shape matrix $S = \\mathrm{diag}(0.01, 9)$, where state-of-charge is unitless in the interval $[0,1]$ and temperature $T$ is measured in Kelvin. A sensor suite provides a measurement $y \\in \\mathbb{R}^{2}$ of the state with zero-mean Gaussian noise, modeled as $y = x + v$, where $v \\sim \\mathcal{N}(0, R)$ with covariance $R = \\mathrm{diag}(0.0004, 1)$. At the current time, the measured state is\n$$\ny = \\begin{pmatrix} 0.75 \\\\ 300 \\end{pmatrix}.\n$$\n\nAssume an anomaly detector that declares an anomaly if and only if the measured state $y$ lies outside the predicted reachable set $\\mathcal{E}$. To quantify the detection confidence under the Gaussian measurement model, define the test statistic as the minimum squared Mahalanobis distance from $y$ to the reachable set,\n$$\nd^{\\star} = \\min_{x \\in \\mathcal{E}} (y - x)^{\\top} R^{-1} (y - x).\n$$\nUnder the null hypothesis that the true state $x$ lies in $\\mathcal{E}$ and the measurement noise is Gaussian with covariance $R$, use the whitened noise model to express the worst-case false-alarm probability as the upper bound $\\exp(-d^{\\star}/2)$ for dimension $n = 2$, and define the detection confidence as $c = 1 - \\exp(-d^{\\star}/2)$.\n\nTasks:\n- Determine whether $y \\in \\mathcal{E}$ or $y \\notin \\mathcal{E}$.\n- Compute the detection confidence $c$ as defined above.\n\nExpress the final answer as the value of $c$ (dimensionless). Round your answer to four significant figures. Do not include any units in your final answer.",
            "solution": "We begin with the definition of the reachable set $\\mathcal{E}$ as an ellipsoid\n$$\n\\mathcal{E} = \\left\\{ x \\in \\mathbb{R}^{2} : (x - \\mu)^{\\top} S^{-1} (x - \\mu) \\leq 1 \\right\\},\n$$\nwhere $\\mu = \\begin{pmatrix} 0.6 \\\\ 300 \\end{pmatrix}$ and $S = \\mathrm{diag}(0.01, 9)$. The measurement model is $y = x + v$ with $v \\sim \\mathcal{N}(0, R)$ and $R = \\mathrm{diag}(0.0004, 1)$.\n\nStep $1$: Membership test of $y$ in $\\mathcal{E}$. The membership condition is\n$$\nq(y) \\equiv (y - \\mu)^{\\top} S^{-1} (y - \\mu) \\leq 1.\n$$\nCompute $y - \\mu$:\n$$\ny - \\mu = \\begin{pmatrix} 0.75 - 0.6 \\\\ 300 - 300 \\end{pmatrix} = \\begin{pmatrix} 0.15 \\\\ 0 \\end{pmatrix}.\n$$\nCompute $S^{-1} = \\mathrm{diag}(100, 1/9)$. Then\n$$\nq(y) = \\begin{pmatrix} 0.15 & 0 \\end{pmatrix} \\begin{pmatrix} 100 & 0 \\\\ 0 & 1/9 \\end{pmatrix} \\begin{pmatrix} 0.15 \\\\ 0 \\end{pmatrix} = 100 \\cdot (0.15)^{2} + \\frac{1}{9} \\cdot 0^{2} = 100 \\cdot 0.0225 = 2.25.\n$$\nSince $q(y) = 2.25 > 1$, we conclude $y \\notin \\mathcal{E}$, so the detector declares an anomaly.\n\nStep $2$: Compute the minimum squared Mahalanobis distance $d^{\\star} = \\min_{x \\in \\mathcal{E}} (y - x)^{\\top} R^{-1} (y - x)$.\n\nWe use the following fundamental setup. Let $W = R^{-1} = \\mathrm{diag}(1/0.0004, 1/1) = \\mathrm{diag}(2500, 1)$. We must solve the convex optimization problem\n$$\n\\min_{x} \\ (y - x)^{\\top} W (y - x) \\quad \\text{subject to} \\quad (x - \\mu)^{\\top} S^{-1} (x - \\mu) \\leq 1.\n$$\nThe Lagrangian for the boundary case (since $y \\notin \\mathcal{E}$, the minimizer lies on the boundary) is\n$$\n\\mathcal{L}(x, \\lambda) = (y - x)^{\\top} W (y - x) + \\lambda \\left[(x - \\mu)^{\\top} S^{-1} (x - \\mu) - 1 \\right], \\quad \\lambda \\geq 0.\n$$\nSetting the gradient with respect to $x$ to zero gives\n$$\n-2 W (y - x) + 2 \\lambda S^{-1} (x - \\mu) = 0 \\quad \\Rightarrow \\quad W (x - y) + \\lambda S^{-1} (x - \\mu) = 0.\n$$\nThis yields the linear system\n$$\n\\left( W + \\lambda S^{-1} \\right) x = W y + \\lambda S^{-1} \\mu.\n$$\nBecause $W$ and $S^{-1}$ are diagonal and $y - \\mu$ is aligned with the first coordinate axis, the optimal $x^{\\star}$ is also aligned along the first axis, with the second coordinate equal to the center $\\mu_{2}$. Intuitively, and formally by symmetry, the closest point on the ellipsoid to $y$ in this weighted norm is the boundary point along the ray from $\\mu$ through $y$. The ellipsoid boundary is given by\n$$\n\\frac{(x_{1} - \\mu_{1})^{2}}{0.01} + \\frac{(x_{2} - \\mu_{2})^{2}}{9} = 1.\n$$\nSince $y_{2} = \\mu_{2}$, the nearest boundary point satisfies $x_{2}^{\\star} = \\mu_{2}$ and\n$$\n\\frac{(x_{1}^{\\star} - \\mu_{1})^{2}}{0.01} = 1 \\quad \\Rightarrow \\quad |x_{1}^{\\star} - \\mu_{1}| = \\sqrt{0.01} = 0.1,\n$$\nwith the sign chosen to be in the direction of $y_{1} - \\mu_{1} > 0$, hence\n$$\nx_{1}^{\\star} = \\mu_{1} + 0.1 = 0.6 + 0.1 = 0.7, \\quad x_{2}^{\\star} = \\mu_{2} = 300.\n$$\nTherefore, the minimizing boundary point is $x^{\\star} = \\begin{pmatrix} 0.7 \\\\ 300 \\end{pmatrix}$, and the minimum squared Mahalanobis distance is\n$$\nd^{\\star} = (y - x^{\\star})^{\\top} W (y - x^{\\star}) = \\begin{pmatrix} 0.05 \\\\ 0 \\end{pmatrix}^{\\top} \\begin{pmatrix} 2500 & 0 \\\\ 0 & 1 \\end{pmatrix} \\begin{pmatrix} 0.05 \\\\ 0 \\end{pmatrix} = 2500 \\cdot (0.05)^{2} + 1 \\cdot 0^{2} = 2500 \\cdot 0.0025 = 6.25.\n$$\n\nStep $3$: Detection confidence. Under the whitened model, if $z = R^{-1/2} v \\sim \\mathcal{N}(0, I_{2})$, then $\\|z\\|^{2}$ has a chi-square distribution with $2$ degrees of freedom. The worst-case false-alarm probability for observing a point at least as incompatible with $\\mathcal{E}$ as $y$ is upper bounded by the tail probability\n$$\np_{\\mathrm{fa}} \\leq \\Pr\\left( \\chi^{2}_{2} \\geq d^{\\star} \\right) = \\exp\\!\\left( -\\frac{d^{\\star}}{2} \\right),\n$$\nwhere we used the fact that for $k = 2$, the survival function is $\\Pr(\\chi^{2}_{2} \\ge t) = \\exp(-t/2)$. Thus the detection confidence is\n$$\nc = 1 - \\exp\\!\\left( -\\frac{d^{\\star}}{2} \\right) = 1 - \\exp\\!\\left( -\\frac{6.25}{2} \\right) = 1 - \\exp(-3.125).\n$$\nCompute the numerical value:\n$$\n\\exp(-3.125) \\approx 0.0439369 \\quad \\Rightarrow \\quad c \\approx 1 - 0.0439369 = 0.9560631.\n$$\nRounded to four significant figures, the confidence is\n$$\nc \\approx 0.9561.\n$$",
            "answer": "$$\\boxed{0.9561}$$"
        },
        {
            "introduction": "While detecting attacks is crucial, the ultimate goal of cyber-physical security is to design systems that are inherently resilient and can maintain safety even when under attack. This practice delves into the principles of robust control by showing how to systematically 'tighten' the safety constraints used by a model predictive controller. You will derive the precise safety margin required to guarantee that physical constraints on voltage and temperature are never violated, proactively accounting for the worst-case effects of both model uncertainty and malicious actuator attacks.",
            "id": "3903132",
            "problem": "Consider a linearized discrete-time cyber-physical model of a lithium-ion battery cell around a fixed operating point, used within a nominal open-loop Model Predictive Control (MPC) planner. The nominal prediction model is\n$$\n\\hat{x}_{k+1} = A \\hat{x}_{k} + B u_{k},\n$$\nwhere $\\hat{x}_{k} \\in \\mathbb{R}^{n}$ is the predicted state, $u_{k} \\in \\mathbb{R}$ is the planned actuator command (current setpoint), $A \\in \\mathbb{R}^{n \\times n}$ and $B \\in \\mathbb{R}^{n \\times 1}$ are known system matrices obtained from first-principles linearization and system identification. The actual closed-loop system subject to a bounded actuator attack and bounded model uncertainty evolves as\n$$\nx_{k+1} = A x_{k} + B\\left(u_{k} + a_{k}\\right) + w_{k},\n$$\nwith $x_{k} \\in \\mathbb{R}^{n}$ the actual state, $a_{k} \\in \\mathbb{R}$ an actuator attack signal, and $w_{k} \\in \\mathbb{R}^{n}$ an additive lumped uncertainty accounting for model mismatch and unmodeled disturbances over the sampling interval. Assume the following bounds, known a priori:\n$$\n|a_{k}| \\le \\bar{a}, \\quad \\|w_{k}\\|_{2} \\le \\bar{w}, \\quad \\text{for all } k \\in \\{0,1,\\dots,N-1\\},\n$$\nwhere $\\bar{a} \\ge 0$ and $\\bar{w} \\ge 0$ are given constants, and $\\|\\cdot\\|_{2}$ denotes the Euclidean norm for vectors and the induced $2$-norm for matrices. The initial condition is matched, $\\hat{x}_{0} = x_{0}$.\n\nThe outputs of interest are the cell terminal voltage and the core temperature,\n$$\nV_{\\text{cell},k} = c_{V}^{\\top} x_{k}, \\quad T_{k} = c_{T}^{\\top} x_{k},\n$$\nwith $c_{V}, c_{T} \\in \\mathbb{R}^{n}$ known from the linearization and thermal-electrochemical coupling. Denote $C \\in \\mathbb{R}^{2 \\times n}$ with rows $c_{V}^{\\top}$ and $c_{T}^{\\top}$, and define the componentwise output constraints\n$$\nV_{\\text{cell},k} \\le V_{\\max}, \\quad T_{k} \\le T_{\\max}, \\quad \\text{for all } k \\in \\{1,\\dots,N\\}.\n$$\n\nTo robustly enforce these constraints under all admissible attack and uncertainty sequences over the horizon of length $N \\in \\mathbb{N}$, the nominal MPC planner applies a componentwise constraint tightening $\\delta = [\\delta_{V} \\ \\delta_{T}]^{\\top} \\in \\mathbb{R}^{2}_{\\ge 0}$ to the predicted outputs so that the predictions satisfy\n$$\nc_{V}^{\\top} \\hat{x}_{k} \\le V_{\\max} - \\delta_{V}, \\quad c_{T}^{\\top} \\hat{x}_{k} \\le T_{\\max} - \\delta_{T}, \\quad \\text{for all } k \\in \\{1,\\dots,N\\}.\n$$\nBy construction, this tightening must guarantee that the actual outputs satisfy $V_{\\text{cell},k} \\le V_{\\max}$ and $T_{k} \\le T_{\\max}$ for all $k \\in \\{1,\\dots,N\\}$ and for all admissible sequences $\\{a_{k}\\}$ and $\\{w_{k}\\}$.\n\nStarting only from the definitions above, properties of the Euclidean norm and the induced $2$-norm (triangle inequality and submultiplicativity), and the linear time-invariant state transition, derive the minimal componentwise tightening $\\delta$ that ensures robust satisfaction of the output constraints over the entire horizon. Express your final answer as a single closed-form analytic row vector in terms of $A$, $B$, $c_{V}$, $c_{T}$, $\\bar{a}$, $\\bar{w}$, and $N$, using the induced $2$-norm. No numerical evaluation is required. Provide the final expression for the tightening as a row matrix $\\begin{pmatrix}\\delta_{V} & \\delta_{T}\\end{pmatrix}$. No rounding is needed, and no units should be included in the final expression.",
            "solution": "The problem requires the derivation of the minimal componentwise constraint tightening, $\\delta = [\\delta_{V} \\ \\delta_{T}]^{\\top}$, for a nominal Model Predictive Control (MPC) planner to ensure robust satisfaction of output constraints for a battery system under actuator attacks and model uncertainty.\n\nLet us define the state estimation error as $e_{k} = x_{k} - \\hat{x}_{k}$, where $x_{k}$ is the actual state and $\\hat{x}_{k}$ is the predicted state. The initial condition is $x_{0} = \\hat{x}_{0}$, which implies $e_{0} = 0$.\n\nThe dynamics of the error can be found by subtracting the nominal model from the actual system model:\n$$\nx_{k+1} - \\hat{x}_{k+1} = \\left(A x_{k} + B(u_{k} + a_{k}) + w_{k}\\right) - \\left(A \\hat{x}_{k} + B u_{k}\\right)\n$$\n$$\ne_{k+1} = A(x_{k} - \\hat{x}_{k}) + B a_{k} + w_{k}\n$$\n$$\ne_{k+1} = A e_{k} + B a_{k} + w_{k}\n$$\nThis is a linear time-invariant recurrence relation for the error $e_k$. We can unroll this recurrence starting from the initial condition $e_{0} = 0$:\n$$\ne_{1} = A e_{0} + B a_{0} + w_{0} = B a_{0} + w_{0}\n$$\n$$\ne_{2} = A e_{1} + B a_{1} + w_{1} = A(B a_{0} + w_{0}) + B a_{1} + w_{1} = A B a_{0} + A w_{0} + B a_{1} + w_{1}\n$$\nBy induction, the general solution for $e_{k}$ at any time step $k \\ge 1$ is given by:\n$$\ne_{k} = A^{k} e_{0} + \\sum_{j=0}^{k-1} A^{k-1-j} \\left( B a_{j} + w_{j} \\right)\n$$\nSince $e_{0}=0$, this simplifies to:\n$$\ne_{k} = \\sum_{j=0}^{k-1} A^{k-1-j} (B a_{j} + w_{j})\n$$\n\nThe actual outputs are $y_k = C x_k$, where $C$ has rows $c_V^\\top$ and $c_T^\\top$. The componentwise constraints are $c_V^\\top x_k \\le V_{\\max}$ and $c_T^\\top x_k \\le T_{\\max}$. Let us consider a generic output constraint $c_i^\\top x_k \\le Y_{\\max}$, where $i \\in \\{V, T\\}$.\nThe MPC planner enforces the tightened constraint $c_i^\\top \\hat{x}_k \\le Y_{\\max} - \\delta_i$.\nTo guarantee robust satisfaction, the actual output must satisfy the original constraint under all admissible attacks $\\{a_k\\}$ and uncertainties $\\{w_k\\}$. We can write the actual output in terms of the prediction and the error:\n$$\nc_i^\\top x_k = c_i^\\top (\\hat{x}_k + e_k) = c_i^\\top \\hat{x}_k + c_i^\\top e_k\n$$\nSubstituting the tightened constraint that the planner enforces:\n$$\nc_i^\\top x_k \\le (Y_{\\max} - \\delta_i) + c_i^\\top e_k\n$$\nTo ensure that $c_i^\\top x_k \\le Y_{\\max}$ is always satisfied, we must have:\n$$\n(Y_{\\max} - \\delta_i) + c_i^\\top e_k \\le Y_{\\max} \\quad \\implies \\quad c_i^\\top e_k \\le \\delta_i\n$$\nThis inequality must hold for all $k \\in \\{1,\\dots,N\\}$ and for all admissible sequences of attacks $\\{a_j\\}_{j=0}^{k-1}$ and uncertainties $\\{w_j\\}_{j=0}^{k-1}$. Therefore, the tightening $\\delta_i$ must be greater than or equal to the maximum possible value of $c_i^\\top e_k$ over the entire horizon and all possible disturbances. The minimal tightening is the tightest such bound:\n$$\n\\delta_i = \\max_{k \\in \\{1,\\dots,N\\}} \\left( \\sup_{\\{a_j\\}, \\{w_j\\}} c_i^\\top e_k \\right)\n$$\nwhere the supremum is taken over all sequences satisfying $|a_j| \\le \\bar{a}$ and $\\|w_j\\|_2 \\le \\bar{w}$.\n\nLet's compute the supremum of $c_i^\\top e_k$ for a fixed $k$. Substituting the expression for $e_k$:\n$$\nc_i^\\top e_k = c_i^\\top \\left( \\sum_{j=0}^{k-1} \\left( A^{k-1-j} B a_j + A^{k-1-j} w_j \\right) \\right) = \\sum_{j=0}^{k-1} \\left( c_i^\\top A^{k-1-j} B a_j + c_i^\\top A^{k-1-j} w_j \\right)\n$$\nSince the choices of $a_j$ and $w_j$ at each time step $j$ are independent, the supremum of the sum is the sum of the suprema of each term:\n$$\n\\sup_{\\{a_j\\},\\{w_j\\}} c_i^\\top e_k = \\sum_{j=0}^{k-1} \\left( \\sup_{|a_j| \\le \\bar{a}} (c_i^\\top A^{k-1-j} B a_j) + \\sup_{\\|w_j\\|_2 \\le \\bar{w}} (c_i^\\top A^{k-1-j} w_j) \\right)\n$$\nFor the first term, $c_i^\\top A^{k-1-j} B$ is a scalar. The expression $s \\cdot a_j$ subject to $|a_j| \\le \\bar{a}$ is maximized when $a_j$ takes its maximum magnitude with the same sign as $s$, leading to a supremum of $|s| \\bar{a}$. Thus:\n$$\n\\sup_{|a_j| \\le \\bar{a}} (c_i^\\top A^{k-1-j} B a_j) = |c_i^\\top A^{k-1-j} B| \\bar{a}\n$$\nFor the second term, let the row vector be $v_j^\\top = c_i^\\top A^{k-1-j}$. We want to find $\\sup_{\\|w_j\\|_2 \\le \\bar{w}} v_j^\\top w_j$. By the Cauchy-Schwarz inequality, $v_j^\\top w_j \\le \\|v_j\\|_2 \\|w_j\\|_2$. The maximum is achieved when $w_j$ is aligned with $v_j$, i.e., $w_j = \\bar{w} \\frac{v_j}{\\|v_j\\|_2}$. The supremum is $\\|v_j\\|_2 \\bar{w}$. The vector $v_j$ is the transpose of $v_j^\\top$, so $v_j = (A^{k-1-j})^\\top c_i$. Therefore:\n$$\n\\sup_{\\|w_j\\|_2 \\le \\bar{w}} (c_i^\\top A^{k-1-j} w_j) = \\|(A^{k-1-j})^\\top c_i\\|_2 \\bar{w}\n$$\nCombining these results, the worst-case deviation for output $i$ at time $k$ is:\n$$\nd_{i,k} \\triangleq \\sup_{\\{a_j\\},\\{w_j\\}} c_i^\\top e_k = \\sum_{j=0}^{k-1} \\left( |c_i^\\top A^{k-1-j} B| \\bar{a} + \\|(A^{k-1-j})^\\top c_i\\|_2 \\bar{w} \\right)\n$$\nTo simplify the expression, let's change the summation index to $m = k-1-j$. As $j$ goes from $0$ to $k-1$, $m$ goes from $k-1$ to $0$.\n$$\nd_{i,k} = \\sum_{m=0}^{k-1} \\left( |c_i^\\top A^m B| \\bar{a} + \\|(A^m)^\\top c_i\\|_2 \\bar{w} \\right)\n$$\nThe minimal tightening $\\delta_i$ must be valid for all $k \\in \\{1,\\dots,N\\}$, so $\\delta_i = \\max_{k \\in \\{1,\\dots,N\\}} d_{i,k}$.\nThe terms in the summation are non-negative, since $\\bar{a} \\ge 0$, $\\bar{w} \\ge 0$, the absolute value is non-negative, and the norm is non-negative. Therefore, $d_{i,k}$ is a monotonically non-decreasing function of $k$:\n$$\nd_{i, k+1} = d_{i,k} + \\left( |c_i^\\top A^k B| \\bar{a} + \\|(A^k)^\\top c_i\\|_2 \\bar{w} \\right) \\ge d_{i,k}\n$$\nThe maximum value of $d_{i,k}$ over the horizon $\\{1,\\dots,N\\}$ must occur at the final step, $k=N$.\n$$\n\\delta_i = d_{i,N} = \\sum_{m=0}^{N-1} \\left( |c_i^\\top A^m B| \\bar{a} + \\|(A^m)^\\top c_i\\|_2 \\bar{w} \\right)\n$$\nApplying this general formula for the voltage ($i=V$) and temperature ($i=T$) constraints, we get:\n$$\n\\delta_V = \\sum_{m=0}^{N-1} \\left( \\bar{a} |c_V^\\top A^m B| + \\bar{w} \\|(A^m)^\\top c_V\\|_2 \\right)\n$$\n$$\n\\delta_T = \\sum_{m=0}^{N-1} \\left( \\bar{a} |c_T^\\top A^m B| + \\bar{w} \\|(A^m)^\\top c_T\\|_2 \\right)\n$$\nThe final answer is requested as a row matrix $\\begin{pmatrix} \\delta_V & \\delta_T \\end{pmatrix}$.",
            "answer": "$$\n\\boxed{\\begin{pmatrix} \\sum_{m=0}^{N-1} \\left( \\bar{a} |c_V^\\top A^m B| + \\bar{w} \\|(A^m)^\\top c_V\\|_2 \\right) & \\sum_{m=0}^{N-1} \\left( \\bar{a} |c_T^\\top A^m B| + \\bar{w} \\|(A^m)^\\top c_T\\|_2 \\right) \\end{pmatrix}}\n$$"
        }
    ]
}