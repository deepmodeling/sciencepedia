{
    "hands_on_practices": [
        {
            "introduction": "电池梯次利用的第一步是判断其是否适合预期的二次应用场景，这不仅仅是简单的容量测量。本实践  要求您计算一个面向特定应用的健康状态（$\\mathrm{SOH}_{\\text{app}}$），该指标同时考虑了剩余容量和功率输出能力，后者对于高功率任务至关重要。通过这个练习，您将掌握如何基于应用需求，对回收电池进行更全面的性能评估。",
            "id": "3929204",
            "problem": "在一个自动化电池设计与仿真工作流程中，正在评估一个单体锂离子电池在助力应用中的梯次利用。该应用要求以等于两倍C倍率的峰值电流进行短时脉冲放电。该电池的额定容量为 $Q_{\\text{rated}}=3.0\\ \\mathrm{Ah}$，老化后测量容量为 $Q_{\\text{aged}}=2.4\\ \\mathrm{Ah}$。由于老化，其直流（DC）内阻相对于额定直流内阻增加了 $30\\%$。该电池的额定直流内阻为 $R_{\\text{DC,rated}}=30\\ \\mathrm{m}\\Omega$。在工作荷电状态下，脉冲期间的开路电压（OCV）近似恒定，为 $V_{\\text{OCV}}=3.6\\ \\mathrm{V}$。该应用施加了一个电压降限制，使得脉冲期间由电阻损耗引起的端电压降不得超过开路电压的 $10\\%$，即允许的压降分数为 $\\eta_{\\max}=0.10$。\n\n使用以下基本依据：\n- 用于计算电阻压降的欧姆定律 $V=I R$。\n- C倍率定义：当容量以 $\\mathrm{Ah}$ 为单位时， $1\\ \\mathrm{C}$ 的C倍率对应于数值为 $Q$ 的电流（单位为 $\\mathrm{A}$），因此 $2\\ \\mathrm{C}$ 脉冲电流要求为 $I_{\\text{req}}=2\\,Q_{\\text{rated}}$。\n- 将用于梯次利用筛选的特定应用的健康状态（SOH）定义为容量保持率和电压降约束下的瞬时电流能力中更为保守的一项，即\n$$\n\\mathrm{SOH}_{\\text{app}}=\\min\\!\\left(\\frac{Q_{\\text{aged}}}{Q_{\\text{rated}}},\\ \\min\\!\\left(1,\\ \\frac{I_{\\max}}{I_{\\text{req}}}\\right)\\right),\n$$\n其中 $I_{\\max}$ 是满足电压降限制 $I\\,R_{\\text{DC,aged}}\\leq \\eta_{\\max}\\,V_{\\text{OCV}}$ 的最大允许放电电流，$R_{\\text{DC,aged}}$ 是老化后的直流内阻。\n\n假设温度恒定，并且在短脉冲期间OCV没有明显变化，因此电阻压降模型有效。计算该电池的特定应用健康状态 $\\mathrm{SOH}_{\\text{app}}$。将最终答案表示为无单位小数，并四舍五入到四位有效数字。",
            "solution": "该问题是有效的，因为它具有科学依据、定义明确且客观。它提出了一个评估电池在梯次利用应用中适用性的标准工程场景。所有必要的数据和定义都已提供，所要求的计算基于电路和电池特性表征的基本原理。\n\n目标是计算特定应用的健康状态（$\\mathrm{SOH}_{\\text{app}}$）。控制方程如下所示：\n$$\n\\mathrm{SOH}_{\\text{app}}=\\min\\!\\left(\\frac{Q_{\\text{aged}}}{Q_{\\text{rated}}},\\ \\min\\!\\left(1,\\ \\frac{I_{\\max}}{I_{\\text{req}}}\\right)\\right)\n$$\n该公式表明，$\\mathrm{SOH}_{\\text{app}}$ 是两个指标中更保守的（即最小值）一个：一个基于容量保持率，另一个基于电流输送能力。我们将依次计算这两个指标。\n\n首先，我们计算容量保持率项，即老化后容量 $Q_{\\text{aged}}$ 与额定容量 $Q_{\\text{rated}}$ 的比值。\n给定值为：\n- 额定容量，$Q_{\\text{rated}} = 3.0\\ \\mathrm{Ah}$\n- 老化后容量，$Q_{\\text{aged}} = 2.4\\ \\mathrm{Ah}$\n\n容量保持率为：\n$$\n\\frac{Q_{\\text{aged}}}{Q_{\\text{rated}}} = \\frac{2.4\\ \\mathrm{Ah}}{3.0\\ \\mathrm{Ah}} = 0.8\n$$\n\n其次，我们评估电流能力项 $\\min\\!\\left(1,\\ \\frac{I_{\\max}}{I_{\\text{req}}}\\right)$。这需要计算应用所需电流 $I_{\\text{req}}$ 和在给定约束下电池可供应的最大电流 $I_{\\max}$。\n\n所需电流 $I_{\\text{req}}$ 是相对于额定容量的两倍C倍率（$2\\ \\mathrm{C}$）的脉冲电流。根据定义，对于容量为 $Q_{\\text{rated}}$（单位 $\\mathrm{Ah}$）的电池，$1\\ \\mathrm{C}$ 电流的数值为 $Q_{\\text{rated}}$（单位 $\\mathrm{A}$）。\n对于 $Q_{\\text{rated}} = 3.0\\ \\mathrm{Ah}$，所需的 $2\\ \\mathrm{C}$ 电流为：\n$$\nI_{\\text{req}} = 2 \\times 3.0\\ \\mathrm{A} = 6.0\\ \\mathrm{A}\n$$\n\n最大允许电流 $I_{\\max}$ 由电压降的约束决定。由内阻引起的电压降 $\\Delta V_{\\text{drop}}$ 不得超过开路电压 $V_{\\text{OCV}}$ 的一个分数 $\\eta_{\\max}$。使用欧姆定律，这可以表示为：\n$$\n\\Delta V_{\\text{drop}} = I R \\leq \\eta_{\\max} V_{\\text{OCV}}\n$$\n此处的电阻是老化后的直流内阻 $R_{\\text{DC,aged}}$。最大电流 $I_{\\max}$ 是使该不等式变为等式时的电流：\n$$\nI_{\\max} R_{\\text{DC,aged}} = \\eta_{\\max} V_{\\text{OCV}}\n$$\n我们需要计算 $R_{\\text{DC,aged}}$。额定直流内阻为 $R_{\\text{DC,rated}} = 30\\ \\mathrm{m}\\Omega = 0.030\\ \\Omega$。该电阻随老化增加了 $30\\%$。\n$$\nR_{\\text{DC,aged}} = R_{\\text{DC,rated}} \\times (1 + \\frac{30}{100}) = 0.030\\ \\Omega \\times (1 + 0.30) = 0.030\\ \\Omega \\times 1.30 = 0.039\\ \\Omega\n$$\n利用给定值 $\\eta_{\\max} = 0.10$ 和 $V_{\\text{OCV}} = 3.6\\ \\mathrm{V}$，我们现在可以求解 $I_{\\max}$：\n$$\nI_{\\max} = \\frac{\\eta_{\\max} V_{\\text{OCV}}}{R_{\\text{DC,aged}}} = \\frac{0.10 \\times 3.6\\ \\mathrm{V}}{0.039\\ \\Omega} = \\frac{0.36}{0.039}\\ \\mathrm{A} = \\frac{360}{39}\\ \\mathrm{A} = \\frac{120}{13}\\ \\mathrm{A}\n$$\n现在我们计算最大电流与所需电流的比值：\n$$\n\\frac{I_{\\max}}{I_{\\text{req}}} = \\frac{\\frac{120}{13}\\ \\mathrm{A}}{6.0\\ \\mathrm{A}} = \\frac{120}{13 \\times 6} = \\frac{20}{13}\n$$\n因此，电流能力指标为：\n$$\n\\min\\!\\left(1,\\ \\frac{I_{\\max}}{I_{\\text{req}}}\\right) = \\min\\!\\left(1,\\ \\frac{20}{13}\\right)\n$$\n由于 $\\frac{20}{13} \\approx 1.538 > 1$，所以最小值为 $1$。这表明该电池的电流输送能力对于此应用不是一个限制因素，因为它在满足电压降约束的同时，可以提供比要求更大的电流。\n\n最后，我们将计算出的两个指标代回到 $\\mathrm{SOH}_{\\text{app}}$ 的表达式中：\n$$\n\\mathrm{SOH}_{\\text{app}} = \\min\\!\\left(0.8, 1\\right) = 0.8\n$$\n因此，对于此特定应用，老化电池的性能受其降低的容量限制，而非其功率能力。问题要求答案以无单位小数表示，并四舍五入到四位有效数字。\n$$\n\\mathrm{SOH}_{\\text{app}} = 0.8000\n$$",
            "answer": "$$\n\\boxed{0.8000}\n$$"
        },
        {
            "introduction": "当一块电池被确定为梯次利用的候选对象后，为其创建一个精确的数字模型对于性能预测和控制至关重要。然而，由于老化电池的数据有限，选择一个复杂度适中的模型以避免过拟合是关键。本练习  将指导您使用诸如 AIC 和 BIC 等基于信息的准则，系统地选择最合适的等效电路模型（ECM），从而在模型保真度与简约性之间取得平衡。",
            "id": "3929200",
            "problem": "一个自动化的电池设计工作流必须对一个老化锂离子电池的电化学阻抗谱（EIS）数据集进行拟合，该电池正在为二次利用进行筛选。目标是选择一个合适的等效电路模型（ECM），同时减轻在异构、回收电池的小样本接收评估中常见的过拟合风险。候选的ECM包括：一个单电阻-电容支路模型（$1$-$\\mathrm{RC}$）、一个双电阻-电容支路模型（$2$-$\\mathrm{RC}$）和一个有限长度Warburg扩散元件ECM（Warburg）。EIS测量提供了$n$个频率点下的复阻抗，每个复数数据点贡献两个标量分量（实部和虚部）。假设模型与数据之间的残差是独立同分布的高斯随机变量，其实部和虚部具有相等的方差，并且模型参数通过最大似然估计（在给定的噪声模型下，等同于非线性最小二乘法）得到。接收评估的数据集有$n = 30$个频率点。拟合后，每个ECM的实部和虚部残差平方和以及自由参数的数量如下：\n- $1$-$\\mathrm{RC}$: $k_1 = 3$, $\\mathrm{RSS}_1 = 0.018$,\n- $2$-$\\mathrm{RC}$: $k_2 = 5$, $\\mathrm{RSS}_2 = 0.0100$,\n- Warburg: $k_W = 6$, $\\mathrm{RSS}_W = 0.0094$.\n从所述高斯噪声模型的最大似然原理出发，构建一个基于信息的模型选择准则，该准则使用拟合残差来平衡拟合优度与模型复杂度，并注意考虑EIS数据的复数值特性。然后，在简约性以减轻小样本二次利用筛选中过拟合风险的实际目标下，使用此准则从三个ECM中进行选择。哪个选项正确地指定了该准则，使用了适当的样本量定义来应用它，得出了三个模型的正确数值排序，并用与二次利用应用相关的过拟合风险论证来证明所选模型的合理性？\n\nA. 使用由$AIC_m = 2 k_m + N \\ln\\!\\big(\\mathrm{RSS}_m/N\\big)$定义的Akaike信息准则（AIC），其中$N = 2 n$因为EIS数据是复数值。当$n=30$时，数值结果得出$AIC_W  AIC_2  AIC_1$，因此选择Warburg模型；AIC中较弱的惩罚是合适的，因为它对于识别真实模型是一致的，并且当$\\mathrm{RSS}$的改善适中时不会过拟合。\n\nB. 使用由$BIC_m = k_m \\ln N + N \\ln\\!\\big(\\mathrm{RSS}_m/N\\big)$定义的Bayesian信息准则（BIC），其中$N = 2 n$以反映每个复数数据点的两个标量分量。当$n=30$时，数值结果得出$BIC_2  BIC_W \\ll BIC_1$，因此选择$2$-$\\mathrm{RC}$模型；BIC中更强的惩罚能更好地减轻小样本二次利用接收评估中的过拟合，因为增加一个Warburg元件带来的微小$\\mathrm{RSS}$增益不足以证明在异构回收电池中增加额外参数负担的合理性。\n\nC. 使用由$AIC_m = 2 k_m + n \\ln\\!\\big(\\mathrm{RSS}_m/n\\big)$定义的Akaike信息准则（AIC），将$n$个复数频率视为$n$个标量观测值。当$n=30$时，数值结果得出$AIC_W  AIC_2  AIC_1$，因此选择Warburg模型；因为扩散在老化电池中是物理上合理的，优先考虑最低的$\\mathrm{RSS}$可以避免过拟合问题。\n\nD. 使用由$BIC_m = k_m \\ln n + n \\ln\\!\\big(\\mathrm{RSS}_m/n\\big)$定义的Bayesian信息准则（BIC），取$n$为样本量。当$n=30$时，惩罚足够大，以至于尽管$1$-$\\mathrm{RC}$的$\\mathrm{RSS}$较高，但仍偏好该模型；这种简约性消除了过拟合风险，并确保了在二次利用电池包中的稳健部署。",
            "solution": "在尝试求解之前，首先对问题陈述进行验证，以确保其科学上合理、适定且完整。\n\n### 问题验证\n\n**步骤1：提取给定条件**\n\n- **背景**：用于筛选老化锂离子电池以进行二次利用的自动化电池设计工作流。\n- **数据**：电化学阻抗谱（EIS）数据集。\n- **频率点数**：$n = 30$。\n- **数据结构**：每个频率点产生一个复阻抗值，贡献两个标量分量（实部和虚部）。\n- **目标**：从三个候选模型中选择一个等效电路模型（ECM），平衡拟合优度与模型复杂度以减轻过拟合。\n- **噪声模型**：模型与数据之间的残差是独立同分布（i.i.d.）的高斯随机变量。实部和虚部的方差相等。\n- **估计方法**：最大似然估计，在指定的噪声模型下等同于非线性最小二乘法。\n- **候选模型及拟合结果**：\n    1.  模型 $1$ ($1$-$\\mathrm{RC}$):\n        -   自由参数数量: $k_1 = 3$。\n        -   残差平方和: $\\mathrm{RSS}_1 = 0.018$。\n    2.  模型 $2$ ($2$-$\\mathrm{RC}$):\n        -   自由参数数量: $k_2 = 5$。\n        -   残差平方和: $\\mathrm{RSS}_2 = 0.0100$。\n    3.  模型 $W$ (Warburg):\n        -   自由参数数量: $k_W = 6$。\n        -   残差平方和: $\\mathrm{RSS}_W = 0.0094$。\n\n**步骤2：使用提取的给定条件进行验证**\n\n- **科学依据**：该问题在电化学和电池工程领域有充分的依据。EIS是表征电池的标准技术，而ECM（包括RC支路和Warburg元件）是解释EIS数据的标准工具。最大似然、AIC和BIC等统计概念是模型选择的标准方法。该问题解决了电池回收和二次利用领域中一个相关且实际的挑战。\n- **适定性**：该问题是适定的。它提供了所有必要的数值数据（每个模型$m$的$n$, $k_m$, $\\mathrm{RSS}_m$）和明确的目标。对噪声的假设已明确说明，从而可以唯一地推导出所需的统计准则。\n- **客观性**：问题陈述是客观的，并使用了精确的技术语言。它没有主观或含糊的术语。\n- **缺陷分析**：\n    1.  **科学/事实不健全**：无。\n    2.  **非形式化/不相关**：无。该问题可以直接形式化。\n    3.  **不完整/矛盾的设置**：无。所有需要的数据都存在且一致。\n    4.  **不切实际/不可行**：无。给定的参数和RSS值对于真实的EIS数据是合理的。\n    5.  **不适定/结构不良**：无。\n    6.  **伪深刻/琐碎**：无。该问题需要仔细应用统计原理，特别是关于复数值数据的样本量定义。\n    7.  **超出科学可验证性**：无。其原理和计算是可验证的。\n\n**步骤3：结论与行动**\n\n问题陈述是**有效的**。将推导解答。\n\n### 推导与解答\n\n问题的核心是通过平衡模型的拟合优度（低$\\mathrm{RSS}$）和其复杂性（低参数数量$k$）来选择模型。从最大似然原理导出的信息准则为这种权衡提供了正式的基础。\n\n**1. 构建信息准则**\n\n问题指出，模型参数是通过最大似然估计得到的，假设残差是i.i.d.高斯分布，方差为$\\sigma^2$。EIS数据包含$n$个复数，但拟合是在$2n$个标量分量（实部和虚部）上进行的。因此，标量观测值的总数是$N = 2n$。给定$n=30$，我们有$N=60$。\n\n对于一个有$k_m$个参数的模型$m$，其最大化对数似然$\\ln(\\hat{\\mathcal{L}}_m)$由下式给出：\n$$ \\ln(\\hat{\\mathcal{L}}_m) = -\\frac{N}{2} \\ln(2\\pi) - \\frac{N}{2} - \\frac{N}{2} \\ln\\left(\\frac{\\mathrm{RSS}_m}{N}\\right) $$\n其中$\\mathrm{RSS}_m$是模型$m$的残差平方和。\n\n信息准则通常定义为$-2 \\ln(\\hat{\\mathcal{L}}_m) + \\text{惩罚项}$。项$-\\frac{N}{2} \\ln(2\\pi) - \\frac{N}{2}$在所有模型中是常数，为了比较可以舍去。\n\n- **Akaike信息准则 (AIC)**：惩罚项为$2k_m$。\n$$ \\mathrm{AIC}_m = -2 \\ln(\\hat{\\mathcal{L}}_m) + 2k_m \\propto N \\ln\\left(\\frac{\\mathrm{RSS}_m}{N}\\right) + 2k_m $$\nAIC值最小的模型是首选。\n\n- **Bayesian信息准则 (BIC)**：惩罚项为$k_m \\ln(N)$。\n$$ \\mathrm{BIC}_m = -2 \\ln(\\hat{\\mathcal{L}}_m) + k_m \\ln(N) \\propto N \\ln\\left(\\frac{\\mathrm{RSS}_m}{N}\\right) + k_m \\ln(N) $$\nBIC值最小的模型是首选。\n\nBIC对复杂度的惩罚比AIC更强，特别是对于较大的$N$，因为其惩罚项$k_m \\ln(N)$随样本量增长，而AIC的惩罚项$2k_m$是恒定的。对于小样本量和避免过拟合至关重要的问题（如本题所述），BIC因其简约性通常是更合适的选择。\n\n**2. 应用准则**\n\n我们有$N = 2n = 60$。每个模型的参数为：\n- $1$-$\\mathrm{RC}$: $k_1 = 3$, $\\mathrm{RSS}_1 = 0.018$\n- $2$-$\\mathrm{RC}$: $k_2 = 5$, $\\mathrm{RSS}_2 = 0.0100$\n- Warburg: $k_W = 6$, $\\mathrm{RSS}_W = 0.0094$\n\n我们为每个模型计算AIC和BIC的值。常数项$N\\ln(2\\pi)+N$被省略，因为它不影响排序。\n\n**AIC计算：** $AIC_m = 2k_m + N \\ln(\\mathrm{RSS}_m/N)$\n- $\\mathrm{AIC}_1 = 2(3) + 60 \\ln(0.018/60) = 6 + 60 \\ln(0.0003) \\approx 6 + 60(-8.1117) = 6 - 486.70 = -480.70$\n- $\\mathrm{AIC}_2 = 2(5) + 60 \\ln(0.0100/60) = 10 + 60 \\ln(0.000166...) \\approx 10 + 60(-8.6995) = 10 - 521.97 = -511.97$\n- $\\mathrm{AIC}_W = 2(6) + 60 \\ln(0.0094/60) = 12 + 60 \\ln(0.000156...) \\approx 12 + 60(-8.7617) = 12 - 525.70 = -513.70$\n\n按AIC排序：$\\mathrm{AIC}_W  \\mathrm{AIC}_2  \\mathrm{AIC}_1$。AIC选择Warburg模型。\n\n**BIC计算：** $BIC_m = k_m \\ln(N) + N \\ln(\\mathrm{RSS}_m/N)$, 其中 $\\ln(N) = \\ln(60) \\approx 4.0943$。\n- $\\mathrm{BIC}_1 = 3 \\ln(60) + 60 \\ln(0.018/60) \\approx 3(4.0943) - 486.70 = 12.28 - 486.70 = -474.42$\n- $\\mathrm{BIC}_2 = 5 \\ln(60) + 60 \\ln(0.0100/60) \\approx 5(4.0943) - 521.97 = 20.47 - 521.97 = -501.50$\n- $\\mathrm{BIC}_W = 6 \\ln(60) + 60 \\ln(0.0094/60) \\approx 6(4.0943) - 525.70 = 24.57 - 525.70 = -501.13$\n\n按BIC排序：$\\mathrm{BIC}_2  \\mathrm{BIC}_W \\ll \\mathrm{BIC}_1$。BIC选择$2$-$\\mathrm{RC}$模型。$2$-$\\mathrm{RC}$和Warburg模型的得分非常接近，但$2$-$\\mathrm{RC}$更优。Warburg模型在$\\mathrm{RSS}$上的微小改进不足以克服BIC对额外参数的惩罚。\n\n**3. 模型选择与论证**\n\n问题明确指出，目标是为筛选具有*小样本*数据集的*异构、回收电池*时减轻过拟合。这一背景强烈支持选择一个简约模型。BIC为一致性而设计，并且比AIC更强烈地偏好更简单的模型。在这种情况下，风险在于像Warburg ECM这样的复杂模型可能会很好地拟合这个特定小数据集的噪声，但无法泛化到异构群体中的其他电池。BIC结果表明，从$2$-$\\mathrm{RC}$到Warburg模型的拟合改进（$\\mathrm{RSS}$减少了$6\\%$）不足以证明增加一个参数（$k_W = 6$ vs $k_2=5$）的合理性，考虑到惩罚项$\\ln(N) \\approx 4.09$。因此，更强地体现简约原则的BIC是合适的准则，而$2$-$\\mathrm{RC}$模型是正确的选择。\n\n### 逐项分析\n\n**A. 使用由$AIC_m = 2 k_m + N \\ln\\!\\big(\\mathrm{RSS}_m/N\\big)$定义的Akaike信息准则（AIC），其中$N = 2 n$因为EIS数据是复数值。当$n=30$时，数值结果得出$AIC_W  AIC_2  AIC_1$，因此选择Warburg模型；AIC中较弱的惩罚是合适的，因为它对于识别真实模型是一致的，并且当$\\mathrm{RSS}$的改善适中时不会过拟合。**\n\n- **分析**：AIC的公式和$N=2n$的计算是正确的。数值排序也是正确的。然而，其论证是有缺陷的。AIC已知在小样本中倾向于选择过于复杂的模型，并且在统计上不是一致的（即，如果真实模型在候选集中，当$N \\to \\infty$时，它不保证选择真实模型）。声称它因“较弱的惩罚”而“不会过拟合”与事实相反；其较弱的惩罚使其与BIC相比*更*容易过拟合。\n- **结论**：**不正确**。\n\n**B. 使用由$BIC_m = k_m \\ln N + N \\ln\\!\\big(\\mathrm{RSS}_m/N\\big)$定义的Bayesian信息准则（BIC），其中$N = 2 n$以反映每个复数数据点的两个标量分量。当$n=30$时，数值结果得出$BIC_2  BIC_W \\ll BIC_1$，因此选择$2$-$\\mathrm{RC}$模型；BIC中更强的惩罚能更好地减轻小样本二次利用接收评估中的过拟合，因为增加一个Warburg元件带来的微小$\\mathrm{RSS}$增益不足以证明在异构回收电池中增加额外参数负担的合理性。**\n\n- **分析**：BIC的公式和$N=2n$的使用是正确的。我们的计算证实了数值排序$BIC_2  BIC_W \\ll BIC_1$。其论证完全合理：BIC更强的惩罚项（$k \\ln N$）促进了简约性，这对于减轻过拟合和确保模型稳健性至关重要，特别是对于所述的用小数据集筛选异构电池的应用。该推理正确地指出，在BIC下，Warburg模型的边际$\\mathrm{RSS}$改进不足以证明其更高复杂度的合理性。\n- **结论**：**正确**。\n\n**C. 使用由$AIC_m = 2 k_m + n \\ln\\!\\big(\\mathrm{RSS}_m/n\\big)$定义的Akaike信息准则（AIC），将$n$个复数频率视为$n$个标量观测值。当$n=30$时，数值结果得出$AIC_W  AIC_2  AIC_1$，因此选择Warburg模型；因为扩散在老化电池中是物理上合理的，优先考虑最低的$\\mathrm{RSS}$可以避免过拟合问题。**\n\n- **分析**：此选项犯了三个主要错误。首先，它错误地使用了样本量$N=n=30$而不是$N=2n=60$。似然函数是基于$2n$个标量残差的。其次，声称的对于$N=30$的数值排序$AIC_W  AIC_2  AIC_1$是错误的；我的计算显示$AIC_2 \\approx -230.19$ 和 $AIC_W \\approx -230.05$，所以$AIC_2  AIC_W$。第三，其论证从根本上是错误的：“优先考虑最低的RSS可以避免过拟合问题”正是过拟合的定义，而不是避免它的方法。\n- **结论**：**不正确**。\n\n**D. 使用由$BIC_m = k_m \\ln n + n \\ln\\!\\big(\\mathrm{RSS}_m/n\\big)$定义的Bayesian信息准则（BIC），取$n$为样本量。当$n=30$时，惩罚足够大，以至于尽管$1$-$\\mathrm{RC}$的$\\mathrm{RSS}$较高，但仍偏好该模型；这种简约性消除了过拟合风险，并确保了在二次利用电池包中的稳健部署。**\n\n- **分析**：此选项也错误地使用了样本量$N=n=30$。此外，其关于BIC会偏好$1$-$\\mathrm{RC}$模型的结论是错误的。即使使用不正确的样本量，我们的计算也显示排序是$BIC_2  BIC_W  BIC_1$。由于其非常高的$\\mathrm{RSS}$，$1$-$\\mathrm{RC}$模型的BIC得分要差得多（更大）。该模型对数据的拟合很差，没有合理的信息准则会选择它。\n- **结论**：**不正确**。",
            "answer": "$$\\boxed{B}$$"
        },
        {
            "introduction": "由于老化历史未知，梯次利用电池的模型参数本质上具有不确定性。为了做出可靠的预测，我们必须理解这种参数不确定性如何影响端电压等性能输出。本项高级实践  介绍了多项式混沌展开（PCE）方法，用以量化并传播这些不确定性，使您能够构建更稳健、更可信的电池仿真模型。",
            "id": "3929174",
            "problem": "您的任务是对用于梯次利用的锂离子电池的等效电路模型 (ECM) 中的不确定参数传播进行建模，以量化在指定工作循环内端电压的变化性。单个戴维南支路的 ECM 包括一个欧姆电阻、一个电阻-电容对和一个开路电压函数。假设由于老化和先前的使用，电池具有不确定参数，并且这些不确定性是独立的，并在指定范围内服从均匀分布。\n\n从以下基础出发，推导一个算法并用代码实现：\n\n1. 使用由电荷守恒和线性网络理论推导出的关系所定义的 ECM。设端电压由 $V(t) = \\mathrm{OCV}(s(t)) - R_0 I(t) - V_1(t)$ 给出，其中 $R_0$ 是欧姆电阻，$I(t)$ 是施加的电流（放电为正），$s(t)$ 是荷电状态 (SOC)，$V_1(t)$ 是电容支路电压。SOC 的演变遵循 $s(t+\\Delta t) = s(t) - \\frac{I(t)\\Delta t}{Q}$，其中 $Q$ 是以库仑为单位的容量。电容支路电压遵循 $V_1(t+\\Delta t) = V_1(t) \\exp\\!\\left(-\\frac{\\Delta t}{R_1 C_1}\\right) + R_1 \\left(1 - \\exp\\!\\left(-\\frac{\\Delta t}{R_1 C_1}\\right)\\right) I(t)$，其中 $R_1$ 和 $C_1$ 是戴维南支路的电阻和电容值。开路电压在局部近似为线性函数 $\\mathrm{OCV}(s) = V_0 + \\alpha (s - s_0)$，其中 $V_0$ 是标称电压，$\\alpha$ 是斜率参数，$s_0$ 是参考 SOC。每次更新后，将 $s(t)$ 限制在区间 $[0,1]$ 内。\n\n2. 将 ECM 参数 $(R_0, R_1, C_1, Q)$ 视为不确定且独立的，每个参数都在给定区间上服从均匀分布。使用总阶数 $p = 2$ 的多元勒让德多项式的多项式混沌展开 (PCE) 来模拟这些不确定性到输出 $V(t)$ 的传播。对每个输入变量，使用 $\\phi_n(x) = \\sqrt{2n+1}\\,P_n(x)$ 构建关于 $[-1,1]$ 上均匀分布的标准正交基，其中 $P_n$ 是勒让德多项式。\n\n3. 使用非侵入式回归（最小二乘法），基于输入随机变量的一组独立同分布 (i.i.d.) 样本，计算每个时间步的 $V(t)$ 的 PCE 系数。在标准正交基中，每个时间 $t_k$ 的方差等于该时间所有非常数 PCE 系数的平方和。计算工作循环内的时间平均方差为 $\\overline{\\mathrm{Var}}(V) = \\frac{1}{T} \\sum_{k=1}^{T} \\mathrm{Var}(V(t_k))$。\n\n所有物理量必须使用适当的单位处理：\n- $V(t)$, $V_0$ 单位为伏特 ($\\mathrm{V}$)。\n- $I(t)$ 单位为安培 ($\\mathrm{A}$)。\n- $R_0$, $R_1$ 单位为欧姆 ($\\Omega$)。\n- $C_1$ 单位为法拉 ($\\mathrm{F}$)。\n- $Q$ 单位为库仑 ($\\mathrm{C}$)。\n- 时间单位为秒 ($\\mathrm{s}$)。\n- 最终输出是电压的时间平均方差，单位为 $\\mathrm{V}^2$，必须表示为十进制浮点数。\n\n实现该算法并计算以下三个测试用例的 $\\overline{\\mathrm{Var}}(V)$。在所有用例中，使用 $s_0 = 0.5$, $V_0 = 3.7\\,\\mathrm{V}$, $\\alpha = 0.12\\,\\mathrm{V}$ 每单位 SOC，并用 $V_1(0) = 0\\,\\mathrm{V}$ 初始化电容支路电压。使用总阶数 $p = 2$ 的标准正交 PCE，以及至少 $S$ 个随机样本，其中 $S$ 根据每个用例指定。使用 $T$ 个时间步，具有恒定的步长 $\\Delta t$ 和提供的分段恒定电流 $I(t_k)$。\n\n- 测试用例 1（正常情况）：\n  - 不确定性范围：$R_0 \\in [0.003, 0.006]\\,\\Omega$, $R_1 \\in [0.002, 0.008]\\,\\Omega$, $C_1 \\in [1500, 3000]\\,\\mathrm{F}$, $Q \\in [9000, 11000]\\,\\mathrm{C}$。\n  - 工作循环长度：$T = 20$，$\\Delta t = 1\\,\\mathrm{s}$。\n  - 初始 SOC：$s(0) = 0.6$。\n  - 电流剖面（单位 $\\mathrm{A}$）：$[2, -1, 3, 0, 2, -2, 4, 1, -3, 0, 1, -1, 2, 0, -2, 3, -3, 0, 2, -1]$。\n  - 样本数：$S = 300$。\n\n- 测试用例 2（边界情况，不确定性范围窄且包含近静置片段）：\n  - 不确定性范围：$R_0 \\in [0.0045, 0.005]\\,\\Omega$, $R_1 \\in [0.004, 0.0045]\\,\\Omega$, $C_1 \\in [1800, 1900]\\,\\mathrm{F}$, $Q \\in [10500, 10600]\\,\\mathrm{C}$。\n  - 工作循环长度：$T = 10$，$\\Delta t = 1\\,\\mathrm{s}$。\n  - 初始 SOC：$s(0) = 0.8$。\n  - 电流剖面（单位 $\\mathrm{A}$）：$[0, 0, 0, 1, -1, 0, 1, -1, 0, 0]$。\n  - 样本数：$S = 200$。\n\n- 测试用例 3（边缘情况，电流较大且不确定性范围宽）：\n  - 不确定性范围：$R_0 \\in [0.002, 0.008]\\,\\Omega$, $R_1 \\in [0.001, 0.010]\\,\\Omega$, $C_1 \\in [1200, 3500]\\,\\mathrm{F}$, $Q \\in [8000, 12000]\\,\\mathrm{C}$。\n  - 工作循环长度：$T = 24$，$\\Delta t = 0.5\\,\\mathrm{s}$。\n  - 初始 SOC：$s(0) = 0.5$。\n  - 电流剖面（单位 $\\mathrm{A}$）：$[5, -5, 4, -4, 3, -3, 2, -2, 0, 6, -6, 5, -5, 4, -4, 3, -3, 2, -2, 0, 7, -7, 6, -6]$。\n  - 样本数：$S = 400$。\n\n您的程序应生成单行输出，其中包含三个测试用例的时间平均方差，格式为方括号内以逗号分隔的列表，按上述用例顺序排列，每个值以 $\\mathrm{V}^2$ 为单位，表示为十进制浮点数。例如：$[\\text{result1},\\text{result2},\\text{result3}]$。",
            "solution": "该问题被评估为有效。它在科学上基于标准的电池建模技术（等效电路模型）和不确定性量化方法（多项式混沌展开）。该问题是适定的，提供了所有必要的参数、方程和初始条件来指定一个唯一的计算任务。其参数和条件对于梯次利用电池应用领域是物理上现实的。\n\n目标是计算锂离子电池在指定工作循环内的端电压的时间平均方差，同时考虑到其等效电路模型 (ECM) 的四个关键参数是不确定的。所规定的方法是一种非侵入式多项式混沌展开 (PCE)。解决方案通过以下推理步骤得出。\n\n### 1. 等效电路模型和状态空间公式\n电池的电气行为由一阶戴维南 ECM 描述。端电压 $V(t)$ 由以下公式给出：\n$$V(t) = \\mathrm{OCV}(s(t)) - R_0 I(t) - V_1(t)$$\n其中 $s(t)$ 是荷电状态 (SOC)，$I(t)$ 是电流（放电为正），$R_0$ 是欧姆电阻，$V_1(t)$ 是并联电阻-电容 ($R_1C_1$) 支路上的电压。\n\n开路电压 (OCV) 是 SOC 的函数，局部近似为线性关系：\n$$\\mathrm{OCV}(s) = V_0 + \\alpha (s - s_0)$$\n其中 $V_0$、$\\alpha$ 和 $s_0$ 是给定的常数。\n\n系统的状态由两个变量描述：SOC $s(t)$ 和电容电压 $V_1(t)$。它们在步长为 $\\Delta t$ 的离散时间内的演变由以下方程控制，这些方程源自电荷守恒和 RC 电路的阶跃响应：\n$$s(t_k + \\Delta t) = s(t_k) - \\frac{I(t_k)\\Delta t}{Q}$$\n$$V_1(t_k + \\Delta t) = V_1(t_k) \\exp\\!\\left(-\\frac{\\Delta t}{R_1 C_1}\\right) + R_1 \\left(1 - \\exp\\!\\left(-\\frac{\\Delta t}{R_1 C_1}\\right)\\right) I(t_k)$$\n这里，$t_k = k\\Delta t$ 并且 $I(t_k)$ 是在区间 $[t_k, t_k+\\Delta t)$ 上施加的恒定电流。SOC 在物理上被限制在区间 $[0, 1]$ 内。\n\n不确定参数是向量 $\\vec{\\theta} = [R_0, R_1, C_1, Q]$。每个分量 $\\theta_i$ 都被假定为在指定区间 $[a_i, b_i]$ 上均匀分布的独立随机变量。\n\n### 2. 用于不确定性传播的多项式混沌展开\nPCE 是一种谱方法，用于将一个随机变量表示为正交多项式的级数展开。由于不确定参数 $\\vec{\\theta}$，模型输出端电压 $V(t)$ 成为一个随机过程。其核心思想是根据一组标准化的独立随机变量 $\\vec{\\xi} = [\\xi_0, \\xi_1, \\xi_2, \\xi_3]$ 来表示 $V(t)$，其中每个 $\\xi_i$ 都遵循一个典型的概率分布。由于我们的物理参数 $\\theta_i$ 在 $[a_i, b_i]$ 上是均匀分布的，我们使用仿射变换将它们映射到标准均匀变量 $\\xi_i \\in [-1, 1]$：\n$$\\theta_i = \\frac{b_i - a_i}{2} \\xi_i + \\frac{b_i + a_i}{2}$$\n现在，端电压是时间和这些标准随机变量的函数，$V(t, \\vec{\\xi})$。我们用一个总阶数 $p=2$ 的截断 PCE 来近似这个函数：\n$$V(t, \\vec{\\xi}) \\approx \\hat{V}(t, \\vec{\\xi}) = \\sum_{j=0}^{N_P-1} c_j(t) \\Psi_j(\\vec{\\xi})$$\n其中 $c_j(t)$ 是与时间相关的确定性系数，$\\Psi_j(\\vec{\\xi})$ 是多元正交基多项式。对于 $d=4$ 个变量和总阶数 $p=2$，基函数的数量为 $N_P = \\frac{(p+d)!}{p!d!} = \\frac{6!}{2!4!} = 15$。\n\n基函数 $\\Psi_j(\\vec{\\xi})$ 是由单变量标准正交多项式 $\\phi_{\\alpha_i}(\\xi_i)$ 的乘积构成的。对于 $[-1,1]$ 上的均匀分布，合适的多项式是勒让德多项式 $P_n(x)$。标准正交基函数是 $\\phi_n(x) = \\sqrt{2n+1}P_n(x)$。一个多元基函数 $\\Psi_j(\\vec{\\xi})$ 对应一个总次数 $|\\vec{\\alpha}_j| = \\sum_i \\alpha_{j,i} \\le p$ 的多重索引 $\\vec{\\alpha}_j = (\\alpha_{j,0}, \\alpha_{j,1}, \\alpha_{j,2}, \\alpha_{j,3})$：\n$$\\Psi_j(\\vec{\\xi}) = \\prod_{i=0}^{3} \\phi_{\\alpha_{j,i}}(\\xi_i) = \\prod_{i=0}^{3} \\sqrt{2\\alpha_{j,i}+1} P_{\\alpha_{j,i}}(\\xi_i)$$\n\n### 3. 用于系数计算的非侵入式回归\nPCE 系数 $c_j(t)$ 使用非侵入式回归方法计算。此方法将 ECM 仿真视为一个“黑箱”模型，我们在随机输入空间的特定点上查询它。步骤如下：\n1.  **抽样**：从4维标准均匀分布 $[-1,1]^4$ 中生成 $S$ 个独立同分布 (i.i.d.) 的样本 $\\vec{\\xi}^{(1)}, \\dots, \\vec{\\xi}^{(S)}$。\n2.  **模型评估**：对每个样本 $\\vec{\\xi}^{(i)}$，计算相应的物理参数 $\\vec{\\theta}^{(i)}$ 并运行完整的时域 ECM 仿真。这将产生 $S$ 条端电压轨迹，$V^{(i)}(t_k)$，其中 $k=0, \\dots, T-1$。\n3.  **线性系统构建**：在每个时间步 $t_k$，我们有一组 $S$ 个输入-输出对 $(\\vec{\\xi}^{(i)}, V^{(i)}(t_k))$。我们可以将所有样本的 PCE 近似写成矩阵形式：$\\mathbf{Y}_k \\approx \\mathbf{\\Phi} \\mathbf{c}_k$，其中：\n    *   $\\mathbf{Y}_k$ 是一个大小为 $S$ 的向量，包含模型输出 $V^{(i)}(t_k)$。\n    *   $\\mathbf{\\Phi}$ 是 $S \\times N_P$ 的设计矩阵，其中每个元素 $\\Phi_{ij} = \\Psi_j(\\vec{\\xi}^{(i)})$ 是第 $j$ 个基函数在第 $i$ 个样本点上的评价值。\n    *   $\\mathbf{c}_k$ 是在时间 $t_k$ 的 $N_P$ 个未知 PCE 系数的向量。\n4.  **最小二乘解**：由于样本数量 $S$ 被选择为大于系数数量 $N_P$，该系统是超定的。系数 $\\mathbf{c}_k$ 通过求解线性最小二乘问题找到，该问题最小化了平方误差 $||\\mathbf{Y}_k - \\mathbf{\\Phi} \\mathbf{c}_k||_2^2$。解由 $\\mathbf{c}_k = (\\mathbf{\\Phi}^T \\mathbf{\\Phi})^\\dagger \\mathbf{\\Phi}^T \\mathbf{Y}_k$ 给出，其中 $\\dagger$ 表示 Moore-Penrose 伪逆。\n\n### 4. 方差计算\n使用标准正交基的一个关键优势是简化了统计矩的计算。模型输出的期望值（均值）就是第一个系数，对应于常数基函数 $\\Psi_0=1$：\n$$\\mathbb{E}[V(t_k)] \\approx c_0(t_k)$$\n方差是所有其他系数的平方和：\n$$\\mathrm{Var}(V(t_k)) = \\mathbb{E}[(V(t_k)-\\mathbb{E}[V(t_k)])^2] \\approx \\sum_{j=1}^{N_P-1} c_j(t_k)^2$$\n最终要求的量是时间平均方差，通过对工作循环中的 $T$ 个时间步进行计算：\n$$\\overline{\\mathrm{Var}}(V) = \\frac{1}{T} \\sum_{k=0}^{T-1} \\mathrm{Var}(V(t_k))$$\n\n### 5. 算法实现\n对每个测试用例，算法按以下步骤进行：\n1.  初始化常数（$V_0, \\alpha, s_0, p=2$）和特定于测试用例的参数（参数范围、初始 SOC、工作循环细节）。为保证可复现性，设置随机种子。\n2.  生成4维标准均匀随机向量 $\\vec{\\xi}$ 的 $S$ 个样本。\n3.  生成 $d=4$ 和 $p=2$ 的多重索引 $\\vec{\\alpha}_j$。共有 $N_P=15$ 个这样的索引。\n4.  通过在 $\\vec{\\xi}$ 的 $S$ 个样本上评估15个多元标准正交勒让德多项式，构建 $S \\times 15$ 的设计矩阵 $\\mathbf{\\Phi}$。\n5.  初始化一个 $S \\times T$ 矩阵，用于存储蒙特卡洛模拟的结果。\n6.  循环 $S$ 次：\n    a. 对于当前样本 $\\vec{\\xi}^{(i)}$，将其转换为物理参数集 $\\vec{\\theta}^{(i)} = [R_0, R_1, C_1, Q]^{(i)}$。\n    b. 使用 $\\vec{\\theta}^{(i)}$ 和给定的电流剖面，运行 ECM 仿真 $T$ 个时间步。将得到的 $T$ 个电压值存储在结果矩阵中。\n7.  初始化一个数组，用于存储每个时间步的方差。\n8.  循环 $T$ 次（对于每个时间步 $k=0, \\dots, T-1$）：\n    a. 提取该时间步的 $S$ 个电压输出向量 $\\mathbf{Y}_k$。\n    b. 求解线性最小二乘系统 $\\mathbf{Y}_k \\approx \\mathbf{\\Phi} \\mathbf{c}_k$ 以获得系数向量 $\\mathbf{c}_k$。\n    c. 通过对第二个到最后一个系数的平方求和，计算该步的方差，即 $\\sum_{j=1}^{14} c_{j,k}^2$。存储此值。\n9.  计算存储的方差的平均值，以获得最终的时间平均方差 $\\overline{\\mathrm{Var}}(V)$。\n对三个测试用例中的每一个重复此过程。",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import legendre\n\ndef get_multi_indices(d, p_total):\n    \"\"\"\n    Generates multi-indices for multivariate polynomials of d variables\n    up to a total polynomial order p_total.\n    \"\"\"\n    if d == 1:\n        return [[i] for i in range(p_total + 1)]\n    \n    indices = []\n    for i in range(p_total + 1):\n        sub_indices = get_multi_indices(d - 1, p_total - i)\n        for sub_index in sub_indices:\n            indices.append([i] + sub_index)\n    return indices\n\ndef build_pce_design_matrix(xi_samples, multi_indices, p_order):\n    \"\"\"\n    Builds the PCE design matrix Phi from samples of standard variables.\n    \"\"\"\n    S, d = xi_samples.shape\n    num_coeffs = len(multi_indices)\n    \n    # Pre-compute Legendre polynomials and normalization factors\n    polys = [legendre(i) for i in range(p_order + 1)]\n    ortho_factors = np.sqrt(2 * np.arange(p_order + 1) + 1)\n    \n    Phi = np.ones((S, num_coeffs))\n\n    # Pre-evaluate polynomial values for all samples to speed up computation\n    # poly_evals[deg, dim, sample_idx]\n    poly_evals = np.array([[polys[deg](xi_samples[:, i]) for i in range(d)] for deg in range(p_order + 1)])\n    \n    for k, idx in enumerate(multi_indices):\n        # The first index (0,0,0,0) results in a column of ones, handled by initialization.\n        if k == 0:\n            continue\n        \n        term_product = np.ones(S)\n        for i in range(d):\n            poly_degree = idx[i]\n            # phi_n(x) = sqrt(2n+1) * Pn(x)\n            term_product *= ortho_factors[poly_degree] * poly_evals[poly_degree, i, :]\n        Phi[:, k] = term_product\n        \n    return Phi\n\ndef run_ecm_simulation(params, T, dt, I_profile, s_init, v1_init, V0, alpha, s0):\n    \"\"\"\n    Runs a time-domain simulation of the ECM for a single parameter set.\n    \"\"\"\n    R0, R1, C1, Q = params\n    \n    s_current = s_init\n    v1_current = v1_init\n    V_out_series = np.zeros(T)\n\n    # Avoid division by zero if R1 or C1 is zero.\n    tau = R1 * C1\n    exp_term = np.exp(-dt / tau) if tau > 0 else 0.0\n\n    for k in range(T):\n        I_k = I_profile[k]\n\n        # Calculate terminal voltage at current time step t_k\n        ocv = V0 + alpha * (s_current - s0)\n        v_terminal = ocv - R0 * I_k - v1_current\n        V_out_series[k] = v_terminal\n\n        # Update state for next time step t_{k+1}\n        s_next = s_current - (I_k * dt) / Q\n        s_next = np.clip(s_next, 0.0, 1.0) # Clamp SOC\n        \n        v1_next = v1_current * exp_term + R1 * (1 - exp_term) * I_k\n\n        # Advance to the next state\n        s_current = s_next\n        v1_current = v1_next\n        \n    return V_out_series\n\ndef solve_case(case_data):\n    \"\"\"\n    Solves a single test case for the time-averaged voltage variance.\n    \"\"\"\n    param_ranges = case_data['ranges']\n    T = case_data['T']\n    dt = case_data['dt']\n    I_profile = case_data['I']\n    s_init = case_data['s_init']\n    S = case_data['S']\n\n    # Shared constants\n    V0 = 3.7\n    alpha = 0.12\n    s0 = 0.5\n    v1_init = 0.0\n    p_order = 2\n    d = 4 # Number of uncertain parameters\n\n    # For reproducibility of sampling\n    np.random.seed(42)\n\n    # Step 1: Generate samples in standard uniform space [-1, 1]\n    xi_samples = np.random.uniform(-1, 1, size=(S, d))\n\n    # Step 2: Transform samples to physical parameter space\n    theta_samples = np.zeros_like(xi_samples)\n    for i, (a, b) in enumerate(param_ranges):\n        theta_samples[:, i] = (b - a) / 2.0 * xi_samples[:, i] + (b + a) / 2.0\n    \n    # Step 3: Build PCE design matrix\n    multi_indices = get_multi_indices(d, p_order)\n    Phi = build_pce_design_matrix(xi_samples, multi_indices, p_order)\n\n    # Step 4: Run Monte Carlo simulations\n    V_mc_results = np.zeros((S, T))\n    for i in range(S):\n        V_mc_results[i, :] = run_ecm_simulation(\n            params=theta_samples[i, :],\n            T=T, dt=dt, I_profile=I_profile, s_init=s_init,\n            v1_init=v1_init, V0=V0, alpha=alpha, s0=s0\n        )\n\n    # Step 5: Compute PCE coefficients and variance for each time step\n    variances_over_time = np.zeros(T)\n    for k in range(T):\n        Y_k = V_mc_results[:, k]\n        # Solve for coefficients using least squares\n        coeffs, _, _, _ = np.linalg.lstsq(Phi, Y_k, rcond=None)\n        # Variance is the sum of squares of non-constant coefficients\n        variances_over_time[k] = np.sum(coeffs[1:]**2)\n    \n    # Step 6: Compute time-averaged variance\n    avg_variance = np.mean(variances_over_time)\n    return avg_variance\n\ndef solve():\n    \"\"\"\n    Main solver function that orchestrates the solution for all test cases.\n    \"\"\"\n    test_cases = [\n        { # Test Case 1\n            'ranges': [(0.003, 0.006), (0.002, 0.008), (1500, 3000), (9000, 11000)],\n            'T': 20, 'dt': 1.0, 's_init': 0.6, 'S': 300,\n            'I': np.array([2, -1, 3, 0, 2, -2, 4, 1, -3, 0, 1, -1, 2, 0, -2, 3, -3, 0, 2, -1]),\n        },\n        { # Test Case 2\n            'ranges': [(0.0045, 0.005), (0.004, 0.0045), (1800, 1900), (10500, 10600)],\n            'T': 10, 'dt': 1.0, 's_init': 0.8, 'S': 200,\n            'I': np.array([0, 0, 0, 1, -1, 0, 1, -1, 0, 0]),\n        },\n        { # Test Case 3\n            'ranges': [(0.002, 0.008), (0.001, 0.010), (1200, 3500), (8000, 12000)],\n            'T': 24, 'dt': 0.5, 's_init': 0.5, 'S': 400,\n            'I': np.array([5, -5, 4, -4, 3, -3, 2, -2, 0, 6, -6, 5, -5, 4, -4, 3, -3, 2, -2, 0, 7, -7, 6, -6]),\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        result = solve_case(case)\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}