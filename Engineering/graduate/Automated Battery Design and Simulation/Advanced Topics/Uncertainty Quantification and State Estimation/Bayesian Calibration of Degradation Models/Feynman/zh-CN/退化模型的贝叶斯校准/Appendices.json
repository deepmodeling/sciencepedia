{
    "hands_on_practices": [
        {
            "introduction": "贝叶斯校准的核心目标之一是量化参数的不确定性。本练习将通过一个基础问题，介绍如何使用拉普拉斯近似（Laplace approximation）来估计后验不确定性。这种方法将费雪信息矩阵（Fisher Information Matrix）与后验协方差联系起来，为理解数据如何减少我们对模型参数的不确定性提供了一个计算上高效且直观的切入点 。",
            "id": "3895848",
            "problem": "您的任务是在无量纲归一化下，针对包含固体电解质界面（SEI）效应的简化锂离子电池单颗粒模型（SPM），推导并实现费雪信息的计算。无量纲端电压的测量模型由一个确定性预测与加性高斯噪声组合定义。确定性预测包括欧姆压降、电荷转移效应、扩散限制传输和 SEI 膜电阻增长的贡献。由于通过适当的参考尺度进行了归一化，所有量都是无量纲的，因此在计算中任何地方都不得使用物理单位。\n\n考虑一个恒流实验，其无量纲电流为 $I$，观测时间为 $\\{t_i\\}_{i=1}^N$。无量纲的预测端电压模型为\n$$\nV_i(\\theta) = U_0 - I \\left( R_{\\mathrm{ohm}} + R_{\\mathrm{ct},0} + \\frac{\\gamma}{D_s} + R_{f,0} + k_{\\mathrm{SEI}} \\sqrt{t_i} \\right),\n$$\n其中 $U_0$、$R_{\\mathrm{ohm}}$、$R_{\\mathrm{ct},0}$ 和 $\\gamma$ 是已知的正常数，未知参数向量为\n$$\n\\theta = \\begin{bmatrix} k_{\\mathrm{SEI}} \\\\ R_{f,0} \\\\ D_s \\end{bmatrix},\n$$\n其中 $k_{\\mathrm{SEI}}$ 是 SEI 生长系数，$R_{f,0}$ 是初始 SEI 膜电阻项，$D_s$ 是无量纲固体扩散系数。观测值满足\n$$\ny_i = V_i(\\theta) + \\varepsilon_i,\n$$\n其中噪声 $\\varepsilon_i \\sim \\mathcal{N}(0,\\sigma^2)$ 是独立同分布的，噪声水平 $\\sigma > 0$ 已知。\n\n从独立观测值的高斯似然出发，并根据费雪信息是对数似然函数关于 $\\theta$ 的负 Hessian 矩阵的期望这一定义，推导在标称参数值 $\\theta_0$ 处的费雪信息矩阵表达式，并为给定模型计算该矩阵。然后，在高斯先验 $\\theta \\sim \\mathcal{N}(\\theta_0, \\Sigma_{\\mathrm{prior}})$ 和已知的对角协方差矩阵 $\\Sigma_{\\mathrm{prior}}$ 的条件下，推导后验协方差的 Laplace 近似，\n$$\n\\Sigma_{\\mathrm{post}} \\approx \\left( \\Sigma_{\\mathrm{prior}}^{-1} + \\mathcal{I}(\\theta_0) \\right)^{-1},\n$$\n其中 $\\mathcal{I}(\\theta_0)$ 是在 $\\theta_0$ 处的费雪信息矩阵。实现一个程序，为每个测试用例计算 $\\Sigma_{\\mathrm{post}}$ 的对角线元素。\n\n您的推导必须从独立高斯噪声的对数似然开始，然后计算模型预测关于 $\\theta$ 的梯度，形成雅可比矩阵 $J(\\theta_0)$（其 $(i,j)$ 项是在 $\\theta_0$ 处求值的 $\\partial V_i(\\theta)/\\partial \\theta_j$），并接着用它来评估费雪信息。所有结果都必须从这些基础出发进行推导，不得直接引用。所有计算和输出都必须是无量纲形式。\n\n使用以下测试套件。每个测试用例指定了已知常数、实验设计、标称参数 $\\theta_0$ 和先验协方差。对于每种情况，计算后验协方差近似，并按 $[k_{\\mathrm{SEI}}, R_{f,0}, D_s]$ 的顺序列出其三个对角线元素作为浮点数列表：\n\n- 测试用例 1 (一般情况，信息量中等):\n  - 已知常数: $U_0 = 3.8$, $R_{\\mathrm{ohm}} = 0.02$, $R_{\\mathrm{ct},0} = 0.05$, $\\gamma = 0.2$。\n  - 实验: $I = 1.0$，时间 $t = [0.01, 0.1, 1.0, 3.0, 10.0]$，噪声 $\\sigma = 0.005$。\n  - 标称参数: $\\theta_0 = [1 \\times 10^{-3}, 0.1, 0.5]$。\n  - 先验协方差 (对角): $\\Sigma_{\\mathrm{prior}} = \\mathrm{diag}([1 \\times 10^{-4}, 1 \\times 10^{-2}, 1 \\times 10^{-1}])$。\n\n- 测试用例 2 (边界时间包括 t=0，低噪声):\n  - 已知常数: $U_0 = 3.8$, $R_{\\mathrm{ohm}} = 0.02$, $R_{\\mathrm{ct},0} = 0.05$, $\\gamma = 0.2$。\n  - 实验: $I = 2.0$，时间 $t = [0.0, 0.1, 0.4, 1.6, 6.4]$，噪声 $\\sigma = 0.001$。\n  - 标称参数: $\\theta_0 = [5 \\times 10^{-4}, 0.05, 0.3]$。\n  - 先验协方差 (对角): $\\Sigma_{\\mathrm{prior}} = \\mathrm{diag}([1 \\times 10^{-5}, 5 \\times 10^{-3}, 5 \\times 10^{-2}])$。\n\n- 测试用例 3 (边缘情况，零电流导致信息简并):\n  - 已知常数: $U_0 = 3.8$, $R_{\\mathrm{ohm}} = 0.02$, $R_{\\mathrm{ct},0} = 0.05$, $\\gamma = 0.2$。\n  - 实验: $I = 0.0$，时间 $t = [0.1, 1.0, 10.0]$，噪声 $\\sigma = 0.01$。\n  - 标称参数: $\\theta_0 = [1 \\times 10^{-3}, 0.1, 0.5]$。\n  - 先验协方差 (对角): $\\Sigma_{\\mathrm{prior}} = \\mathrm{diag}([1 \\times 10^{-4}, 1 \\times 10^{-2}, 1 \\times 10^{-1}])$。\n\n- 测试用例 4 (高噪声，弱信息):\n  - 已知常数: $U_0 = 3.8$, $R_{\\mathrm{ohm}} = 0.02$, $R_{\\mathrm{ct},0} = 0.05$, $\\gamma = 0.2$。\n  - 实验: $I = 1.0$，时间 $t = [0.1, 0.2, 0.4]$，噪声 $\\sigma = 0.1$。\n  - 标称参数: $\\theta_0 = [1 \\times 10^{-3}, 0.1, 1.0]$。\n  - 先验协方差 (对角): $\\Sigma_{\\mathrm{prior}} = \\mathrm{diag}([1 \\times 10^{-3}, 1 \\times 10^{-1}, 1.0])$。\n\n您的程序应生成单行输出，其中包含一个由方括号括起来的、逗号分隔的列表之列表，例如 \"[[v11,v12,v13],[v21,v22,v23],...]\"。每个内部列表包含对应测试用例的 $\\Sigma_{\\mathrm{post}}$ 的三个对角线元素，顺序与 $[k_{\\mathrm{SEI}}, R_{f,0}, D_s]$ 对应。所有输出都必须是无量纲浮点数。",
            "solution": "用户提供了一个有效的问题陈述。任务是为一个简化的电池退化模型推导并计算其参数的后验协方差的 Laplace 近似。推导将从第一性原理出发，始于测量模型的对数似然。\n\n### 1. 费雪信息矩阵的推导\n\n问题假设了一个测量模型，其中每个观测值 $y_i$ 是确定性模型预测 $V_i(\\theta)$ 和随机噪声项 $\\varepsilon_i$ 的和。噪声项被假定为遵循高斯分布的独立同分布变量，即 $\\varepsilon_i \\sim \\mathcal{N}(0, \\sigma^2)$，其方差 $\\sigma^2$ 已知。需要推断的参数向量是 $\\theta = [k_{\\mathrm{SEI}}, R_{f,0}, D_s]^T$。\n\n在给定参数 $\\theta$ 的情况下，单个观测值 $y_i$ 的概率密度函数 (PDF) 为：\n$$\np(y_i|\\theta) = \\frac{1}{\\sqrt{2\\pi\\sigma^2}} \\exp\\left(-\\frac{(y_i - V_i(\\theta))^2}{2\\sigma^2}\\right)\n$$\n对于一组 $N$ 个独立观测值 $Y = \\{y_1, \\dots, y_N\\}$，联合似然 $L(\\theta|Y)$ 是各个 PDF 的乘积。处理对数似然 $\\ell(\\theta|Y) = \\log L(\\theta|Y)$ 更为方便：\n$$\n\\ell(\\theta|Y) = \\sum_{i=1}^{N} \\log p(y_i|\\theta) = \\sum_{i=1}^{N} \\left[ -\\frac{1}{2}\\log(2\\pi\\sigma^2) - \\frac{(y_i - V_i(\\theta))^2}{2\\sigma^2} \\right]\n$$\n$$\n\\ell(\\theta|Y) = -\\frac{N}{2}\\log(2\\pi\\sigma^2) - \\frac{1}{2\\sigma^2}\\sum_{i=1}^{N} (y_i - V_i(\\theta))^2\n$$\n费雪信息矩阵 (FIM)，记作 $\\mathcal{I}(\\theta)$，定义为对数似然函数关于参数 $\\theta$ 的 Hessian 矩阵的负期望。FIM 的第 $(j,k)$ 个元素是：\n$$\n\\mathcal{I}_{jk}(\\theta) = -\\mathbb{E}\\left[\\frac{\\partial^2 \\ell(\\theta|Y)}{\\partial \\theta_j \\partial \\theta_k}\\right]\n$$\n其中参数 $\\theta_j$ 是向量 $\\theta$ 的第 $j$ 个元素。\n\n首先，我们求对数似然的梯度（得分函数）：\n$$\n\\frac{\\partial \\ell}{\\partial \\theta_j} = \\frac{\\partial}{\\partial \\theta_j} \\left( -\\frac{1}{2\\sigma^2}\\sum_{i=1}^{N} (y_i - V_i(\\theta))^2 \\right) = \\frac{1}{\\sigma^2}\\sum_{i=1}^{N} (y_i - V_i(\\theta)) \\frac{\\partial V_i(\\theta)}{\\partial \\theta_j}\n$$\n接下来，我们通过对 $\\theta_k$ 求导来计算 Hessian 矩阵：\n$$\n\\frac{\\partial^2 \\ell}{\\partial \\theta_j \\partial \\theta_k} = \\frac{1}{\\sigma^2}\\sum_{i=1}^{N} \\frac{\\partial}{\\partial \\theta_k} \\left( (y_i - V_i(\\theta)) \\frac{\\partial V_i(\\theta)}{\\partial \\theta_j} \\right)\n$$\n$$\n\\frac{\\partial^2 \\ell}{\\partial \\theta_j \\partial \\theta_k} = \\frac{1}{\\sigma^2}\\sum_{i=1}^{N} \\left[ -\\frac{\\partial V_i(\\theta)}{\\partial \\theta_k} \\frac{\\partial V_i(\\theta)}{\\partial \\theta_j} + (y_i - V_i(\\theta)) \\frac{\\partial^2 V_i(\\theta)}{\\partial \\theta_j \\partial \\theta_k} \\right]\n$$\n对数据分布取期望 $\\mathbb{E}[\\cdot]$，我们利用 $\\mathbb{E}[y_i] = V_i(\\theta)$ 这一事实，这意味着 $\\mathbb{E}[y_i - V_i(\\theta)] = 0$。这简化了 Hessian 矩阵的期望：\n$$\n\\mathbb{E}\\left[\\frac{\\partial^2 \\ell}{\\partial \\theta_j \\partial \\theta_k}\\right] = -\\frac{1}{\\sigma^2}\\sum_{i=1}^{N} \\frac{\\partial V_i(\\theta)}{\\partial \\theta_j} \\frac{\\partial V_i(\\theta)}{\\partial \\theta_k}\n$$\n应用 FIM 的定义，我们得到：\n$$\n\\mathcal{I}_{jk}(\\theta) = - \\left( -\\frac{1}{\\sigma^2}\\sum_{i=1}^{N} \\frac{\\partial V_i(\\theta)}{\\partial \\theta_j} \\frac{\\partial V_i(\\theta)}{\\partial \\theta_k} \\right) = \\frac{1}{\\sigma^2}\\sum_{i=1}^{N} \\frac{\\partial V_i(\\theta)}{\\partial \\theta_j} \\frac{\\partial V_i(\\theta)}{\\partial \\theta_k}\n$$\n这个表达式可以方便地写成矩阵形式。设 $J(\\theta)$ 是一个 $N \\times 3$ 的雅可比矩阵，其中元素 $J_{ij}(\\theta) = \\frac{\\partial V_i(\\theta)}{\\partial \\theta_j}$。那么 FIM 是：\n$$\n\\mathcal{I}(\\theta) = \\frac{1}{\\sigma^2} J(\\theta)^T J(\\theta)\n$$\n\n### 2. 模型的雅可比矩阵\n\n电压模型由以下公式给出：\n$$\nV_i(\\theta) = U_0 - I \\left( R_{\\mathrm{ohm}} + R_{\\mathrm{ct},0} + \\frac{\\gamma}{D_s} + R_{f,0} + k_{\\mathrm{SEI}} \\sqrt{t_i} \\right)\n$$\n参数向量为 $\\theta = [\\theta_1, \\theta_2, \\theta_3]^T = [k_{\\mathrm{SEI}}, R_{f,0}, D_s]^T$。我们计算 $V_i$ 对每个参数的偏导数：\n$$\n\\frac{\\partial V_i}{\\partial \\theta_1} = \\frac{\\partial V_i}{\\partial k_{\\mathrm{SEI}}} = -I \\sqrt{t_i}\n$$\n$$\n\\frac{\\partial V_i}{\\partial \\theta_2} = \\frac{\\partial V_i}{\\partial R_{f,0}} = -I\n$$\n$$\n\\frac{\\partial V_i}{\\partial \\theta_3} = \\frac{\\partial V_i}{\\partial D_s} = -I \\frac{\\partial}{\\partial D_s}\\left(\\frac{\\gamma}{D_s}\\right) = -I \\left(-\\frac{\\gamma}{D_s^2}\\right) = \\frac{I \\gamma}{D_s^2}\n$$\n雅可比矩阵 $J(\\theta)$ 的第 $i$ 行是 $V_i(\\theta)$ 梯度的转置，即 $\\nabla_\\theta V_i(\\theta)^T$：\n$$\nJ(\\theta)_{i,:} = \\left[ -I \\sqrt{t_i}, \\quad -I, \\quad \\frac{I \\gamma}{D_s^2} \\right]\n$$\n\n### 3. 后验协方差近似\n\n问题要求使用 Laplace 近似计算后验协方差，给定高斯先验 $\\theta \\sim \\mathcal{N}(\\theta_0, \\Sigma_{\\mathrm{prior}})$。Bayes 定理指出，后验分布与似然和先验的乘积成正比：$p(\\theta|Y) \\propto L(Y|\\theta)p(\\theta)$。Laplace 近似用一个以以后验众数为中心的高斯分布来近似后验分布，其协方差矩阵是在众数点求值的对数后验概率负 Hessian 矩阵的逆。\n\n对数后验概率为 $\\log p(\\theta|Y) = \\ell(\\theta|Y) + \\log p(\\theta) + \\text{const.}$。对数后验概率的负 Hessian 矩阵是：\n$$\n-\\frac{\\partial^2 \\log p(\\theta|Y)}{\\partial\\theta\\partial\\theta^T} = -\\frac{\\partial^2 \\ell(\\theta|Y)}{\\partial\\theta\\partial\\theta^T} - \\frac{\\partial^2 \\log p(\\theta)}{\\partial\\theta\\partial\\theta^T}\n$$\n对于高斯先验，其对数的 Hessian 矩阵是常数：$-\\frac{\\partial^2 \\log p(\\theta)}{\\partial\\theta\\partial\\theta^T} = \\Sigma_{\\mathrm{prior}}^{-1}$。用先验均值 $\\theta_0$ 来近似后验众数，并取期望，可得到后验精度矩阵：\n$$\n\\Sigma_{\\mathrm{post}}^{-1} \\approx \\mathbb{E}\\left[-\\left.\\frac{\\partial^2 \\ell}{\\partial\\theta\\partial\\theta^T}\\right|_{\\theta_0}\\right] + \\Sigma_{\\mathrm{prior}}^{-1} = \\mathcal{I}(\\theta_0) + \\Sigma_{\\mathrm{prior}}^{-1}\n$$\n因此，后验协方差矩阵为：\n$$\n\\Sigma_{\\mathrm{post}} \\approx \\left( \\mathcal{I}(\\theta_0) + \\Sigma_{\\mathrm{prior}}^{-1} \\right)^{-1}\n$$\n\n### 4. 计算步骤\n\n对于每个测试用例，算法如下：\n1.  初始化已知常数和实验设计参数：$\\gamma$、$I$、$\\{t_i\\}$、$\\sigma$、$\\theta_0 = [k_{\\mathrm{SEI},0}, R_{f,0,0}, D_{s,0}]^T$，以及 $\\Sigma_{\\mathrm{prior}}$ 的对角元素。\n2.  通过在每个时间点 $t_i$ 处计算 $\\theta_0$ 点的偏导数值，构建 $N \\times 3$ 的雅可比矩阵 $J(\\theta_0)$。\n3.  计算费雪信息矩阵 $\\mathcal{I}(\\theta_0) = \\frac{1}{\\sigma^2} J(\\theta_0)^T J(\\theta_0)$。\n4.  构建先验精度矩阵 $\\Sigma_{\\mathrm{prior}}^{-1}$，这是一个对角矩阵，其对角线元素是给定的 $\\Sigma_{\\mathrm{prior}}$ 对角线元素的倒数。\n5.  计算后验精度矩阵 $M = \\mathcal{I}(\\theta_0) + \\Sigma_{\\mathrm{prior}}^{-1}$。\n6.  对 $M$ 求逆以获得后验协方差近似：$\\Sigma_{\\mathrm{post}} = M^{-1}$。\n7.  提取 $\\Sigma_{\\mathrm{post}}$ 的对角线元素，它们对应于 $k_{\\mathrm{SEI}}$、$R_{f,0}$ 和 $D_s$ 的后验方差。\n此过程在提供的 Python 代码中直接实现。当 $I=0$ 时会出现一种特殊情况，这会使雅可比矩阵成为零矩阵，导致 $\\mathcal{I}(\\theta_0) = 0$。在这种情况下，后验协方差 $\\Sigma_{\\mathrm{post}}$ 变得与先验协方差 $\\Sigma_{\\mathrm{prior}}$ 相同，这反映了零电流实验没有为模型参数提供任何新信息。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the diagonal of the Laplace-approximated posterior covariance matrix\n    for parameters of a simplified battery model for several test cases.\n    \"\"\"\n    test_cases = [\n        # Test Case 1\n        {\n            \"constants\": {\"gamma\": 0.2},\n            \"experiment\": {\"I\": 1.0, \"t\": [0.01, 0.1, 1.0, 3.0, 10.0], \"sigma\": 0.005},\n            \"theta0\": [1e-3, 0.1, 0.5],\n            \"prior_cov_diag\": [1e-4, 1e-2, 1e-1],\n        },\n        # Test Case 2\n        {\n            \"constants\": {\"gamma\": 0.2},\n            \"experiment\": {\"I\": 2.0, \"t\": [0.0, 0.1, 0.4, 1.6, 6.4], \"sigma\": 0.001},\n            \"theta0\": [5e-4, 0.05, 0.3],\n            \"prior_cov_diag\": [1e-5, 5e-3, 5e-2],\n        },\n        # Test Case 3\n        {\n            \"constants\": {\"gamma\": 0.2},\n            \"experiment\": {\"I\": 0.0, \"t\": [0.1, 1.0, 10.0], \"sigma\": 0.01},\n            \"theta0\": [1e-3, 0.1, 0.5],\n            \"prior_cov_diag\": [1e-4, 1e-2, 1e-1],\n        },\n        # Test Case 4\n        {\n            \"constants\": {\"gamma\": 0.2},\n            \"experiment\": {\"I\": 1.0, \"t\": [0.1, 0.2, 0.4], \"sigma\": 0.1},\n            \"theta0\": [1e-3, 0.1, 1.0],\n            \"prior_cov_diag\": [1e-3, 1e-1, 1.0],\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        # Extract parameters for the current test case\n        gamma = case[\"constants\"][\"gamma\"]\n        I = case[\"experiment\"][\"I\"]\n        t = np.array(case[\"experiment\"][\"t\"], dtype=float)\n        sigma = case[\"experiment\"][\"sigma\"]\n        k_sei0, r_f0_0, d_s0 = case[\"theta0\"]\n        prior_cov_diag = np.array(case[\"prior_cov_diag\"], dtype=float)\n\n        # Number of observation times\n        N = len(t)\n\n        # 1. Construct the Jacobian matrix J(theta_0)\n        # J is an N x 3 matrix where J_ij = dV_i / d(theta_j)\n        # theta = [k_sei, r_f0, d_s]\n        \n        # Column 1: Derivatives with respect to k_sei\n        # dV/dk_sei = -I * sqrt(t_i)\n        col1 = -I * np.sqrt(t)\n\n        # Column 2: Derivatives with respect to r_f0\n        # dV/dr_f0 = -I\n        col2 = -I * np.ones(N)\n\n        # Column 3: Derivatives with respect to d_s\n        # dV/d_ds = I * gamma / d_s^2\n        col3 = (I * gamma / (d_s0**2)) * np.ones(N)\n\n        # Assemble the N x 3 Jacobian matrix\n        J = np.vstack([col1, col2, col3]).T\n\n        # 2. Compute the Fisher Information Matrix I(theta_0)\n        # I = (1/sigma^2) * J^T @ J\n        fisher_info = (1 / sigma**2) * (J.T @ J)\n\n        # 3. Construct the prior precision matrix (inverse of prior covariance)\n        # Since Sigma_prior is diagonal, its inverse is also diagonal\n        prior_precision = np.diag(1.0 / prior_cov_diag)\n\n        # 4. Compute the posterior precision matrix\n        # M = Sigma_prior^-1 + I(theta_0)\n        M = prior_precision + fisher_info\n\n        # 5. Invert M to get the posterior covariance matrix Sigma_post\n        try:\n            post_cov = np.linalg.inv(M)\n        except np.linalg.LinAlgError:\n            # This case should not be reached with a proper prior\n            post_cov = np.full((3, 3), np.nan)\n\n        # 6. Extract the diagonal entries of Sigma_post\n        diag_post_cov = np.diagonal(post_cov).tolist()\n        results.append(diag_post_cov)\n\n    # Format and print the final output as specified\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在电池寿命测试等长期实验中，我们经常会遇到数据不完整的问题，例如部分样本在实验结束时仍未失效。这种“右删失”（right-censored）数据在分析时需要特殊处理。本练习将演示如何在贝叶斯框架下正确处理删失数据，构建适用于混合失效与删失数据的似然函数，这是准确校准电池失效模型和进行可靠性分析的一项关键技能 。",
            "id": "3895926",
            "problem": "一个自动化的电池循环平台被用于在锂离子电池设计工作流程中，校准在激进快充模式下由析锂引起的随机失效时间。假设在该模式下，每个电池的失效时间 $T$ 都是独立的，并服从具有恒定风险率参数 $\\lambda$ 的指数分布，其概率密度函数为 $f(t \\mid \\lambda)$，生存函数为 $S(t \\mid \\lambda)$。在生存分析中，当测试在预定的审查时间 $t_{c}$ 停止，而电池到该时间仍未失效时，就会发生右审查；一个右审查观测值对似然函数的贡献是在 $t_{c}$ 时的生存率。\n\n该平台同时运行 $8$ 个并联测试。五个电池在时间 $t = \\{120, 350, 600, 700, 760\\}$ 小时失效，而三个电池在停止时间 $t_{c} = 800$ 小时仍未失效（在 $t_{c}$ 处被右审查）。你的目标是使用形状参数为 $\\alpha$、速率参数为 $\\beta$ 的 Gamma 先验对 $\\lambda$ 进行贝叶斯校准，其中 Gamma 密度为 $p(\\lambda \\mid \\alpha, \\beta) \\propto \\lambda^{\\alpha - 1} \\exp(-\\beta \\lambda)$。假设 $\\alpha = 2$ 且 $\\beta = 500$（速率参数的单位为小时）。\n\n从指数模型的基本定义——即 $f(t \\mid \\lambda) = \\lambda \\exp(-\\lambda t)$ 和 $S(t \\mid \\lambda) = \\exp(-\\lambda t)$——以及混合了失效和审查观测值的似然函数是失效观测的密度乘积与审查观测的生存率乘积这一右审查规则出发，推导 $\\lambda$ 的后验分布，并求出 $\\lambda$ 的最大后验（MAP；Maximum A Posteriori）估计值。将 MAP 估计值的最终答案以 $\\mathrm{h}^{-1}$ 为单位表示，并四舍五入到四位有效数字。你的最终答案必须是一个实数。",
            "solution": "目标是根据一组失效时间和右审查数据，找到指数失效时间模型的风险率参数 $\\lambda$ 的最大后验（MAP）估计。这将通过贝叶斯校准来实现。\n\n首先，我们必须为观测数据构建似然函数。数据包括 $k=5$ 个在时间 $t_i$ 发生的失效和 $m=3$ 个在审查时间 $t_c$ 的右审查观测值。测试的电池总数为 $N=k+m=8$。\n失效时间集合为 $T_{fail} = \\{120, 350, 600, 700, 760\\}$ 小时。\n审查时间为 $t_c = 800$ 小时。\n\n失效时间 $T$ 由指数分布建模，其概率密度函数（PDF）为 $f(t \\mid \\lambda) = \\lambda \\exp(-\\lambda t)$，生存函数为 $S(t \\mid \\lambda) = \\exp(-\\lambda t)$。\n\n对于 $k=5$ 个失效的电池中的每一个，其对似然函数的贡献是其失效时间 $t_i$ 处的概率密度函数（PDF）值。\n对于 $m=3$ 个在测试停止时间 $t_c$ 之前未失效的电池，其观测值是右审查的。其对似然函数的贡献是存活超过 $t_c$ 的概率，由生存函数 $S(t_c \\mid \\lambda)$ 给出。\n\n假设失效事件是独立的，总似然函数 $L(\\lambda \\mid \\text{data})$ 是各个贡献的乘积：\n$$L(\\lambda \\mid \\text{data}) = \\left( \\prod_{i=1}^{k} f(t_i \\mid \\lambda) \\right) \\times \\left( S(t_c \\mid \\lambda) \\right)^m$$\n代入给定的 PDF 和生存函数表达式：\n$$L(\\lambda \\mid \\text{data}) = \\left( \\prod_{i=1}^{5} \\lambda \\exp(-\\lambda t_i) \\right) \\times \\left( \\exp(-\\lambda t_c) \\right)^3$$\n这可以被简化为：\n$$L(\\lambda \\mid \\text{data}) = \\lambda^5 \\left( \\prod_{i=1}^{5} \\exp(-\\lambda t_i) \\right) \\times \\exp(-3 \\lambda t_c)$$\n$$L(\\lambda \\mid \\text{data}) = \\lambda^5 \\exp\\left(-\\lambda \\sum_{i=1}^{5} t_i\\right) \\exp(-3 \\lambda t_c)$$\n$$L(\\lambda \\mid \\text{data}) = \\lambda^5 \\exp\\left(-\\lambda \\left( \\sum_{i=1}^{5} t_i + 3 t_c \\right) \\right)$$\n我们来计算观测到的总时间。失效时间的总和是：\n$$\\sum_{i=1}^{5} t_i = 120 + 350 + 600 + 700 + 760 = 2530 \\text{ 小时}$$\n由审查观测贡献的总时间是：\n$$3 t_c = 3 \\times 800 = 2400 \\text{ 小时}$$\n设 $T_{\\text{total}} = \\sum_{i=1}^{5} t_i + 3 t_c = 2530 + 2400 = 4930$ 小时。\n现在，似然函数可以写为：\n$$L(\\lambda \\mid \\text{data}) = \\lambda^5 \\exp(-4930 \\lambda)$$\n\n接下来，我们定义 $\\lambda$ 的先验分布。问题指定了一个 Gamma 先验，$p(\\lambda \\mid \\alpha, \\beta)$，其形状参数 $\\alpha=2$，速率参数 $\\beta=500$ 小时。先验的概率密度正比于：\n$$p(\\lambda) \\propto \\lambda^{\\alpha - 1} \\exp(-\\beta \\lambda) = \\lambda^{2-1} \\exp(-500 \\lambda) = \\lambda^{1} \\exp(-500 \\lambda)$$\n\n根据贝叶斯定理，$\\lambda$ 的后验分布 $p(\\lambda \\mid \\text{data})$ 正比于似然函数与先验的乘积：\n$$p(\\lambda \\mid \\text{data}) \\propto L(\\lambda \\mid \\text{data}) \\times p(\\lambda)$$\n$$p(\\lambda \\mid \\text{data}) \\propto \\left( \\lambda^5 \\exp(-4930 \\lambda) \\right) \\times \\left( \\lambda^{1} \\exp(-500 \\lambda) \\right)$$\n合并各项：\n$$p(\\lambda \\mid \\text{data}) \\propto \\lambda^{5+1} \\exp(-(4930+500)\\lambda)$$\n$$p(\\lambda \\mid \\text{data}) \\propto \\lambda^6 \\exp(-5430 \\lambda)$$\n这是一个 Gamma 分布的核。后验分布是一个 Gamma 分布，$p(\\lambda \\mid \\text{data}) \\sim \\text{Gamma}(\\alpha', \\beta')$，其密度正比于 $\\lambda^{\\alpha' - 1} \\exp(-\\beta' \\lambda)$。\n\n通过将推导出的后验形式与通用的 Gamma 核进行比较，我们可以确定后验参数 $\\alpha'$ 和 $\\beta'$：\n$$\\alpha' - 1 = 6 \\implies \\alpha' = 7$$\n$$\\beta' = 5430 \\text{ 小时}$$\n因此，后验分布是 $\\text{Gamma}(7, 5430)$。这是预料之中的，因为 Gamma 分布是指数分布速率参数的共轭先验。\n\n$\\lambda$ 的 MAP 估计，记为 $\\lambda_{\\text{MAP}}$，是后验分布的众数。对于一个 $\\alpha' > 1$ 的 Gamma 分布 $\\text{Gamma}(\\alpha', \\beta')$，其众数由以下公式给出：\n$$\\text{众数} = \\frac{\\alpha' - 1}{\\beta'}$$\n在我们的例子中，$\\alpha' = 7$，满足条件 $\\alpha' > 1$。因此，MAP 估计为：\n$$\\lambda_{\\text{MAP}} = \\frac{7 - 1}{5430} = \\frac{6}{5430}$$\n现在，我们计算数值：\n$$\\lambda_{\\text{MAP}} = \\frac{6}{5430} \\approx 0.001104972375... \\text{ h}^{-1}$$\n问题要求答案四舍五入到四位有效数字。\n$$\\lambda_{\\text{MAP}} \\approx 0.001105 \\text{ h}^{-1}$$\n\n风险率参数 $\\lambda$ 的 MAP 估计为 $0.001105$ $\\mathrm{h}^{-1}$。",
            "answer": "$$\\boxed{0.001105}$$"
        },
        {
            "introduction": "科学建模常常需要在不同复杂度的模型之间做出选择。我们应该选择一个基于物理原理的简化参数模型，还是一个更灵活的非参数模型？本项高级练习将指导您使用贝叶斯模型选择的核心工具——边缘似然（marginal likelihood）或称“模型证据”（model evidence）。通过计算和比较一个参数化SEI生长模型和一个非参数化高斯过程（Gaussian Process）模型的证据，您将学习如何量化数据对不同模型的支持程度，并理解边缘似然如何自然地权衡模型拟合度与复杂度 。",
            "id": "3895902",
            "problem": "您的任务是实现一个非参数高斯过程 (GP) 速率模型和一个参数化固体电解质界面 (SEI) 速率模型之间的原则性比较，方法是在贝叶斯框架下计算边际似然。该物理系统是一个锂离子电池负极，其上形成固体电解质界面 (SEI) 层，我们需要观测 SEI 生长速率随时间的变化。\n\n从以下基本原理和定义开始：\n- 关于模型证据的贝叶斯定理指出，对于观测数据 $\\mathbf{y}$ 和具有潜在参数 $\\boldsymbol{\\theta}$ 的模型 $\\mathcal{M}$，边际似然（也称为模型证据）定义为 $$p(\\mathbf{y} \\mid \\mathcal{M}) = \\int p(\\mathbf{y} \\mid \\boldsymbol{\\theta}, \\mathcal{M}) \\, p(\\boldsymbol{\\theta} \\mid \\mathcal{M}) \\, d\\boldsymbol{\\theta}.$$\n- 高斯观测模型假设存在加性独立同分布噪声：对于观测时间 $\\mathbf{t} = [t_1,\\dots,t_n]^T$，有 $$y_i = f(t_i) + \\varepsilon_i,$$ 且 $$\\varepsilon_i \\sim \\mathcal{N}(0, \\sigma^2),$$ 其中 $\\sigma > 0$ 是已知的，而 $f(\\cdot)$ 是潜在速率函数。\n- 高斯过程 (GP) 定义为一组随机变量的集合，其任何有限子集都呈多元高斯分布。一个具有协方差函数 $k(\\cdot,\\cdot)$ 的零均值 GP 先验意味着 $$\\mathbf{f} = [f(t_1),\\dots,f(t_n)]^T \\sim \\mathcal{N}(\\mathbf{0}, \\mathbf{K}),$$ 其中 $\\mathbf{K}_{ij} = k(t_i, t_j)$。\n\n在您的设计中，您不得使用简化公式。请使用有效的线性代数操作和高斯积分的性质，从这些基础出发推导所需的量。\n\n需要实现的模型定义：\n1. 非参数高斯过程 (GP) 速率模型：\n   - 对 $f(\\cdot)$ 使用零均值 GP 先验，其平方指数核函数为 $$k(t, t') = s_f^2 \\exp\\left(-\\frac{(t - t')^2}{2 \\ell^2}\\right),$$ 其中 $s_f^2$ 是信号方差，$\\ell$ 是特征长度尺度。\n   - 观测模型为 $y_i = f(t_i) + \\varepsilon_i$，其中 $\\varepsilon_i \\sim \\mathcal{N}(0,\\sigma^2)$。\n\n2. 参数化 SEI 速率模型：\n   - 使用参数化形式 $$f(t) = \\theta_1 t^{-1/2} + \\theta_2,$$ 该形式捕捉了典型的扩散限制 SEI 生长行为外加一个基线偏移。\n   - 对参数向量 $\\boldsymbol{\\theta} = [\\theta_1, \\theta_2]^T$ 施加零均值高斯先验，其协方差为 $$\\boldsymbol{\\Sigma}_0 = \\mathrm{diag}(s_1^2, s_2^2).$$\n   - 观测模型为 $y_i = f(t_i) + \\varepsilon_i$，其中 $\\varepsilon_i \\sim \\mathcal{N}(0,\\sigma^2)$。\n\n您的程序必须为每个提供的测试用例计算 GP 模型和参数化 SEI 模型的边际似然的自然对数，然后计算定义为 $$\\Delta = \\log p(\\mathbf{y} \\mid \\text{GP}) - \\log p(\\mathbf{y} \\mid \\text{Parametric})$$ 的差值。\n\n科学真实性和单位：\n- 观测时间 $\\mathbf{t}$ 必须以秒 ($\\mathrm{s}$) 为单位。\n- 观测到的 SEI 速率值 $\\mathbf{y}$ 必须以摩尔每平方米每秒 ($\\mathrm{mol}\\,\\mathrm{m}^{-2}\\,\\mathrm{s}^{-1}$) 为单位。\n- 噪声标准差 $\\sigma$ 必须以 $\\mathrm{mol}\\,\\mathrm{m}^{-2}\\,\\mathrm{s}^{-1}$ 为单位指定。\n- GP 信号方差 $s_f^2$ 必须以 $(\\mathrm{mol}\\,\\mathrm{m}^{-2}\\,\\mathrm{s}^{-1})^2$ 为单位指定，长度尺度 $\\ell$ 以秒 ($\\mathrm{s}$) 为单位。\n- SEI 参数先验方差 $s_1^2$ 和 $s_2^2$ 必须分别以 $(\\mathrm{mol}\\,\\mathrm{m}^{-2}\\,\\mathrm{s}^{-1/2})^2$ 和 $(\\mathrm{mol}\\,\\mathrm{m}^{-2}\\,\\mathrm{s}^{-1})^2$ 为单位指定，以使单位与 $f(t)$ 的单位 $\\mathrm{mol}\\,\\mathrm{m}^{-2}\\,\\mathrm{s}^{-1}$ 保持一致。\n\n为保证可复现性的数据生成：\n- 对于每个测试用例，通过 $$y_i = \\theta_1 t_i^{-1/2} + \\theta_2 + \\varepsilon_i$$ 确定性地构建 $\\mathbf{y}$，其中 $\\varepsilon_i$ 是每个测试用例提供的固定序列（非随机）。\n\n需要实现的测试套件：\n- 测试用例 1 (均衡、信息量适中的数据)：\n  - 时间：$\\mathbf{t} = [300, 600, 1200, 2400, 4800]$ $\\mathrm{s}$。\n  - 真实参数：$\\theta_1 = 1.5 \\times 10^{-7}$ $\\mathrm{mol}\\,\\mathrm{m}^{-2}\\,\\mathrm{s}^{-1/2}$，$\\theta_2 = 2.0 \\times 10^{-8}$ $\\mathrm{mol}\\,\\mathrm{m}^{-2}\\,\\mathrm{s}^{-1}$。\n  - 噪声标准差：$\\sigma = 1.0 \\times 10^{-8}$ $\\mathrm{mol}\\,\\mathrm{m}^{-2}\\,\\mathrm{s}^{-1}$。\n  - 固定噪声序列：$\\boldsymbol{\\varepsilon} = [1.0, -1.0, 0.5, -0.2, 0.3] \\times 10^{-8}$ $\\mathrm{mol}\\,\\mathrm{m}^{-2}\\,\\mathrm{s}^{-1}$。\n  - SEI 先验方差：$s_1^2 = (1.0 \\times 10^{-7})^2$, $s_2^2 = (5.0 \\times 10^{-8})^2$。\n  - GP 超参数：$s_f^2 = (1.0 \\times 10^{-7})^2$，$\\ell = 1000$ $\\mathrm{s}$。\n\n- 测试用例 2 (小样本，高灵活性 GP)：\n  - 时间：$\\mathbf{t} = [1000, 2000, 3000]$ $\\mathrm{s}$。\n  - 真实参数：$\\theta_1 = 1.0 \\times 10^{-7}$ $\\mathrm{mol}\\,\\mathrm{m}^{-2}\\,\\mathrm{s}^{-1/2}$，$\\theta_2 = 1.0 \\times 10^{-8}$ $\\mathrm{mol}\\,\\mathrm{m}^{-2}\\,\\mathrm{s}^{-1}$。\n  - 噪声标准差：$\\sigma = 5.0 \\times 10^{-8}$ $\\mathrm{mol}\\,\\mathrm{m}^{-2}\\,\\mathrm{s}^{-1}$。\n  - 固定噪声序列：$\\boldsymbol{\\varepsilon} = [2.0, -1.0, 0.5] \\times 10^{-8}$ $\\mathrm{mol}\\,\\mathrm{m}^{-2}\\,\\mathrm{s}^{-1}$。\n  - SEI 先验方差：$s_1^2 = (5.0 \\times 10^{-7})^2$, $s_2^2 = (1.0 \\times 10^{-7})^2$。\n  - GP 超参数：$s_f^2 = (1.0 \\times 10^{-7})^2$，$\\ell = 10$ $\\mathrm{s}$。\n\n- 测试用例 3 (密集采样，近乎常数的 GP 先验)：\n  - 时间：$\\mathbf{t} = [500, 1000, 1500, 2000, 2500, 3000]$ $\\mathrm{s}$。\n  - 真实参数：$\\theta_1 = 2.0 \\times 10^{-7}$ $\\mathrm{mol}\\,\\mathrm{m}^{-2}\\,\\mathrm{s}^{-1/2}$，$\\theta_2 = 0.0$ $\\mathrm{mol}\\,\\mathrm{m}^{-2}\\,\\mathrm{s}^{-1}$。\n  - 噪声标准差：$\\sigma = 5.0 \\times 10^{-9}$ $\\mathrm{mol}\\,\\mathrm{m}^{-2}\\,\\mathrm{s}^{-1}$。\n  - 固定噪声序列：$\\boldsymbol{\\varepsilon} = [-0.2, 0.1, -0.1, 0.0, 0.2, -0.3] \\times 10^{-8}$ $\\mathrm{mol}\\,\\mathrm{m}^{-2}\\,\\mathrm{s}^{-1}$。\n  - SEI 先验方差：$s_1^2 = (1.0 \\times 10^{-7})^2$, $s_2^2 = (1.0 \\times 10^{-8})^2$。\n  - GP 超参数：$s_f^2 = (1.0 \\times 10^{-7})^2$，$\\ell = 10000$ $\\mathrm{s}$。\n\n算法要求：\n- 使用上述基础推导适用于高斯先验和高斯似然的边际似然的闭式表达式。\n- 使用适合正定协方差矩阵的矩阵分解，实现行列式的对数和二次型的数值稳定计算。\n- 输出必须以自然对数单位计算，并且是确定性的。\n\n最终输出格式：\n- 您的程序应生成一行输出，其中包含三个测试用例的 $\\Delta$ 值，格式为用方括号括起来的逗号分隔列表（例如，“[delta1,delta2,delta3]”）。\n- 每个元素必须是一个浮点数。\n\n解释要求：\n- 尽管您的程序仅输出数值，但您的内部解决方案必须对灵活性与可识别性之间的权衡进行推理：GP 模型因其无限维先验而更具灵活性，可以适应复杂的模式；而参数化 SEI 模型的参数较少，更易于识别。边际似然内在地图平衡了数据拟合和模型复杂度。您的解决方案必须将这些概念与计算出的证据值联系起来。\n\n在适用时，所有量都应使用指定的物理单位作答，并确保所有计算都遵守这些单位。",
            "solution": "用户要求对锂离子电池负极中 SEI 生长速率的两种模型进行原则性比较：一种是非参数高斯过程 (GP) 模型，另一种是参数化物理模型。该比较将通过为每个模型计算贝叶斯边际似然来进行。本文首先验证问题，然后从基本原理推导必要的公式，最后提供实现策略。\n\n### 问题验证\n\n**步骤 1：提取已知条件**\n\n- **贝叶斯定理的边际似然：** $p(\\mathbf{y} \\mid \\mathcal{M}) = \\int p(\\mathbf{y} \\mid \\boldsymbol{\\theta}, \\mathcal{M}) \\, p(\\boldsymbol{\\theta} \\mid \\mathcal{M}) \\, d\\boldsymbol{\\theta}$。\n- **观测模型：** 高斯模型，具有独立同分布噪声，$y_i = f(t_i) + \\varepsilon_i$，其中 $\\varepsilon_i \\sim \\mathcal{N}(0, \\sigma^2)$ 且 $\\sigma > 0$ 是已知的。\n- **高斯过程 (GP) 先验：** 零均值，$\\mathbf{f} = [f(t_1),\\dots,f(t_n)]^T \\sim \\mathcal{N}(\\mathbf{0}, \\mathbf{K})$，其中 $\\mathbf{K}_{ij} = k(t_i, t_j)$。\n\n- **模型 1：非参数 GP 速率模型**\n  - 先验：对 $f(\\cdot)$ 的零均值 GP。\n  - 核函数：平方指数核，$k(t, t') = s_f^2 \\exp\\left(-\\frac{(t - t')^2}{2 \\ell^2}\\right)$。\n  - 超参数：信号方差 $s_f^2$，特征长度尺度 $\\ell$。\n\n- **模型 2：参数化 SEI 速率模型**\n  - 函数形式：$f(t) = \\theta_1 t^{-1/2} + \\theta_2$。\n  - 先验：对 $\\boldsymbol{\\theta} = [\\theta_1, \\theta_2]^T$ 的零均值高斯先验，协方差为 $\\boldsymbol{\\Sigma}_0 = \\mathrm{diag}(s_1^2, s_2^2)$。\n  - 超参数：先验方差 $s_1^2$, $s_2^2$。\n\n- **比较指标：** $\\Delta = \\log p(\\mathbf{y} \\mid \\text{GP}) - \\log p(\\mathbf{y} \\mid \\text{Parametric})$。\n\n- **数据生成：** $y_i = \\theta_1 t_i^{-1/2} + \\theta_2 + \\varepsilon_i$，其中 $\\varepsilon_i$ 作为固定序列提供。\n\n- **单位：**\n  - $\\mathbf{t}$ 单位为秒 ($\\mathrm{s}$)。\n  - $\\mathbf{y}$ 单位为 $\\mathrm{mol}\\,\\mathrm{m}^{-2}\\,\\mathrm{s}^{-1}$。\n  - $\\sigma$ 单位为 $\\mathrm{mol}\\,\\mathrm{m}^{-2}\\,\\mathrm{s}^{-1}$。\n  - $s_f^2$ 单位为 $(\\mathrm{mol}\\,\\mathrm{m}^{-2}\\,\\mathrm{s}^{-1})^2$。\n  - $\\ell$ 单位为 $\\mathrm{s}$。\n  - $s_1^2$ 单位为 $(\\mathrm{mol}\\,\\mathrm{m}^{-2}\\,\\mathrm{s}^{-1/2})^2$。\n  - $s_2^2$ 单位为 $(\\mathrm{mol}\\,\\mathrm{m}^{-2}\\,\\mathrm{s}^{-1})^2$。\n\n- **测试用例：** 三个不同的测试用例都已完全指定，包含所有必要的参数和数据生成值。\n\n**步骤 2：使用提取的已知条件进行验证**\n\n根据已建立的验证标准对问题进行评估。\n1.  **科学基础：** 该问题使用标准的贝叶斯统计方法（边际似然）来比较两种成熟的建模方法（参数化物理模型和非参数高斯过程）。所选的参数形式 $f(t) \\propto t^{-1/2}$ 是扩散限制生长过程的特征，这是 SEI 层形成的一个物理上合理的模型。所有指定的单位在量纲上都是一致的。该问题具有科学合理性。\n2.  **适定性：** 模型被完全指定（先验、似然和所有超参数均已给出）。对于高斯先验和高斯似然，边际似然积分是可解析处理的，可以得到一个唯一、稳定且有意义的结果。该问题是适定的。\n3.  **客观性：** 问题陈述使用精确的数学语言编写，没有任何主观或模棱两可的术语。\n4.  **缺陷清单：** 详细检查确认该问题没有指定的任何缺陷。它不是科学上不合理、不可形式化、不完整、矛盾、不现实或不适定的。参数的先验指定使问题成为直接计算而非推断任务，这对于直接模型比较练习来说是有效的设置。\n\n**步骤 3：结论与行动**\n\n该问题是**有效的**。将提供一个完整、合理的解决方案。\n\n### 边际似然的推导\n\n问题的核心是计算边际似然 $p(\\mathbf{y} \\mid \\mathcal{M})$，它量化了在给定模型 $\\mathcal{M}$ 的情况下观测到数据 $\\mathbf{y}$ 的概率。这个值，也称为模型证据，通过平衡模型拟合度与模型复杂度，自然地体现了奥卡姆剃刀原理。一个过于复杂的模型，其先验概率会稀疏地分布在大量可能的数据集上，即使它能很好地拟合观测数据，也会导致较低的证据值。\n\n所提出的两个模型都是线性高斯模型，这意味着观测数据 $\\mathbf{y}$ 可以表示为高斯分布潜在变量的线性变换，并加上高斯噪声。这种结构确保了 $\\mathbf{y}$ 的边际分布也是高斯分布，其参数可以解析推导。\n\n**1. 非参数 GP 模型的边际似然**\n\nGP 模型是分层定义的：\n1.  在观测时间 $\\mathbf{t}$ 处，对潜在函数值 $\\mathbf{f} = [f(t_1), \\dots, f(t_n)]^T$ 施加一个先验。由于 GP 先验是零均值的，因此：\n    $$p(\\mathbf{f} \\mid \\text{GP}) = \\mathcal{N}(\\mathbf{f} \\mid \\mathbf{0}, \\mathbf{K})$$\n    其中 $\\mathbf{K}$ 是 $n \\times n$ 的协方差矩阵，其元素为 $\\mathbf{K}_{ij} = k(t_i, t_j) = s_f^2 \\exp\\left(-\\frac{(t_i - t_j)^2}{2 \\ell^2}\\right)$。\n\n2.  观测模型指定了给定潜在函数值 $\\mathbf{f}$ 的数据 $\\mathbf{y}$ 的似然：\n    $$p(\\mathbf{y} \\mid \\mathbf{f}) = \\mathcal{N}(\\mathbf{y} \\mid \\mathbf{f}, \\sigma^2 \\mathbf{I})$$\n    其中 $\\mathbf{I}$ 是 $n \\times n$ 的单位矩阵，$\\sigma^2$ 是噪声方差。\n\n边际似然是通过对潜在函数值 $\\mathbf{f}$ 进行积分得到的：\n$$p(\\mathbf{y} \\mid \\text{GP}) = \\int p(\\mathbf{y} \\mid \\mathbf{f}) \\, p(\\mathbf{f} \\mid \\text{GP}) \\, d\\mathbf{f}$$\n这是两个高斯分布的卷积。$\\mathbf{y}$ 的结果分布也是高斯分布。其均值为 $E[\\mathbf{y}] = E[\\mathbf{f} + \\boldsymbol{\\varepsilon}] = E[\\mathbf{f}] + E[\\boldsymbol{\\varepsilon}] = \\mathbf{0} + \\mathbf{0} = \\mathbf{0}$。其协方差为 $\\text{Cov}(\\mathbf{y}) = \\text{Cov}(\\mathbf{f} + \\boldsymbol{\\varepsilon}) = \\text{Cov}(\\mathbf{f}) + \\text{Cov}(\\boldsymbol{\\varepsilon}) = \\mathbf{K} + \\sigma^2\\mathbf{I}$，因为 $\\mathbf{f}$ 和 $\\boldsymbol{\\varepsilon}$ 是独立的。\n\n因此，GP 模型的边际似然由多元高斯概率密度函数给出：\n$$p(\\mathbf{y} \\mid \\text{GP}) = \\mathcal{N}(\\mathbf{y} \\mid \\mathbf{0}, \\mathbf{C}_y^{\\text{GP}})$$\n其中数据协方差矩阵为 $\\mathbf{C}_y^{\\text{GP}} = \\mathbf{K} + \\sigma^2\\mathbf{I}$。\n\n**2. 参数化 SEI 模型的边际似然**\n\n参数化模型也是分层定义的：\n1.  对模型参数 $\\boldsymbol{\\theta} = [\\theta_1, \\theta_2]^T$ 施加一个先验：\n    $$p(\\boldsymbol{\\theta} \\mid \\text{Parametric}) = \\mathcal{N}(\\boldsymbol{\\theta} \\mid \\mathbf{0}, \\boldsymbol{\\Sigma}_0)$$\n    其中 $\\boldsymbol{\\Sigma}_0 = \\mathrm{diag}(s_1^2, s_2^2)$。\n\n2.  潜在函数是参数的线性函数：$f(t_i; \\boldsymbol{\\theta}) = \\theta_1 t_i^{-1/2} + \\theta_2$。这可以写成矩阵形式 $\\mathbf{f} = \\mathbf{\\Phi}\\boldsymbol{\\theta}$，其中 $\\mathbf{\\Phi}$ 是一个 $n \\times 2$ 的设计矩阵，其第 $i$ 行为 $[t_i^{-1/2}, 1]$。\n\n3.  观测模型同样是 $p(\\mathbf{y} \\mid \\boldsymbol{\\theta}) = \\mathcal{N}(\\mathbf{y} \\mid \\mathbf{\\Phi}\\boldsymbol{\\theta}, \\sigma^2\\mathbf{I})$。\n\n边际似然是通过对参数 $\\boldsymbol{\\theta}$ 进行积分得到的：\n$$p(\\mathbf{y} \\mid \\text{Parametric}) = \\int p(\\mathbf{y} \\mid \\boldsymbol{\\theta}) \\, p(\\boldsymbol{\\theta} \\mid \\text{Parametric}) \\, d\\boldsymbol{\\theta}$$\n向量 $\\mathbf{y}$ 是两个独立高斯随机变量的和：$\\mathbf{\\Phi}\\boldsymbol{\\theta}$ 和 $\\boldsymbol{\\varepsilon}$。$\\mathbf{\\Phi}\\boldsymbol{\\theta}$ 的分布是高斯分布，其均值为 $E[\\mathbf{\\Phi}\\boldsymbol{\\theta}] = \\mathbf{\\Phi}E[\\boldsymbol{\\theta}] = \\mathbf{0}$，协方差为 $\\text{Cov}(\\mathbf{\\Phi}\\boldsymbol{\\theta}) = \\mathbf{\\Phi}\\text{Cov}(\\boldsymbol{\\theta})\\mathbf{\\Phi}^T = \\mathbf{\\Phi}\\boldsymbol{\\Sigma}_0\\mathbf{\\Phi}^T$。\n因此，$\\mathbf{y}$ 的分布是高斯分布，其均值为 $E[\\mathbf{y}] = \\mathbf{0}$，协方差为 $\\text{Cov}(\\mathbf{y}) = \\text{Cov}(\\mathbf{\\Phi}\\boldsymbol{\\theta}) + \\text{Cov}(\\boldsymbol{\\varepsilon}) = \\mathbf{\\Phi}\\boldsymbol{\\Sigma}_0\\mathbf{\\Phi}^T + \\sigma^2\\mathbf{I}$。\n\n因此，参数化模型的边际似然为：\n$$p(\\mathbf{y} \\mid \\text{Parametric}) = \\mathcal{N}(\\mathbf{y} \\mid \\mathbf{0}, \\mathbf{C}_y^{\\text{Parametric}})$$\n其中数据协方差矩阵为 $\\mathbf{C}_y^{\\text{Parametric}} = \\mathbf{\\Phi}\\boldsymbol{\\Sigma}_0\\mathbf{\\Phi}^T + \\sigma^2\\mathbf{I}$。\n\n**3. 对数边际似然的数值稳定计算**\n\n对于一个通用的 $n$ 维多元高斯分布 $\\mathcal{N}(\\mathbf{y} \\mid \\boldsymbol{\\mu}, \\mathbf{C})$，其对数概率密度为：\n$$\\log p(\\mathbf{y}) = -\\frac{n}{2}\\log(2\\pi) - \\frac{1}{2}\\log\\det(\\mathbf{C}) - \\frac{1}{2}(\\mathbf{y}-\\boldsymbol{\\mu})^T\\mathbf{C}^{-1}(\\mathbf{y}-\\boldsymbol{\\mu})$$\n在我们的情况下，两个模型的均值 $\\boldsymbol{\\mu}$ 均为 $\\mathbf{0}$。主要的计算挑战在于计算对数行列式 $\\log\\det(\\mathbf{C}_y)$ 和二次型 $\\mathbf{y}^T\\mathbf{C}_y^{-1}\\mathbf{y}$，其中 $\\mathbf{C}_y$ 是一个 $n \\times n$ 的正定协方差矩阵。\n直接计算行列式和逆矩阵在数值上不稳定且计算成本高。一个更优的方法是使用 Cholesky 分解，$\\mathbf{C}_y = \\mathbf{L}\\mathbf{L}^T$，其中 $\\mathbf{L}$ 是一个下三角矩阵。\n\n-   **对数行列式：** $\\log\\det(\\mathbf{C}_y) = \\log\\det(\\mathbf{L}\\mathbf{L}^T) = \\log(\\det(\\mathbf{L})^2) = 2\\log\\det(\\mathbf{L})$。三角矩阵的行列式是其对角元素的乘积，所以 $\\det(\\mathbf{L}) = \\prod_i L_{ii}$。因此，\n    $$\\log\\det(\\mathbf{C}_y) = 2 \\sum_{i=1}^n \\log(L_{ii})$$\n\n-   **二次型：** 二次型项可以重写为 $\\mathbf{y}^T (\\mathbf{L}\\mathbf{L}^T)^{-1} \\mathbf{y} = \\mathbf{y}^T (\\mathbf{L}^T)^{-1} \\mathbf{L}^{-1} \\mathbf{y} = (\\mathbf{L}^{-1}\\mathbf{y})^T (\\mathbf{L}^{-1}\\mathbf{y})$。令 $\\mathbf{z} = \\mathbf{L}^{-1}\\mathbf{y}$。这个向量 $\\mathbf{z}$ 可以通过求解三角系统 $\\mathbf{Lz} = \\mathbf{y}$（使用高效的前向替换）来找到。二次型就是 $\\mathbf{z}$ 的欧几里得范数的平方：\n    $$\\mathbf{y}^T\\mathbf{C}_y^{-1}\\mathbf{y} = \\mathbf{z}^T\\mathbf{z} = ||\\mathbf{z}||_2^2$$\n\n综合这些，对数边际似然的最终表达式为：\n$$\\log p(\\mathbf{y} \\mid \\mathcal{M}) = -\\frac{n}{2}\\log(2\\pi) - \\sum_{i=1}^n \\log(L_{ii}) - \\frac{1}{2}\\mathbf{z}^T\\mathbf{z}$$\n这个公式将用于 GP 和参数化模型，分别使用它们各自的数据协方差矩阵 $\\mathbf{C}_y$。\n\n**4. 测试用例结果的解释**\n量 $\\Delta = \\log p(\\mathbf{y} \\mid \\text{GP}) - \\log p(\\mathbf{y} \\mid \\text{Parametric})$ 是对数贝叶斯因子。一个正的 $\\Delta$ 表明数据为 GP 模型提供了更多的证据，而一个负的 $\\Delta$ 则偏好参数化模型。\n- **测试用例 1** 使用了适量的数据点和一个与数据时间跨度相当的 GP 长度尺度 ($\\ell = 1000\\,\\mathrm{s}$)。这建立了一个均衡的比较。\n- **测试用例 2** 数据点很少 ($n=3$) 且 GP 长度尺度非常短 ($\\ell=10\\,\\mathrm{s}$)。短的长度尺度对应于一个非常灵活、“摆动”的 GP 先验。在数据有限的情况下，这样一个复杂的模型很可能会因为过拟合而被边际似然惩罚，从而可能偏好更简单的参数化模型。\n- **测试用例 3** 数据更密集，GP 长度尺度非常长 ($\\ell=10000\\,\\mathrm{s}$)。长的长度尺度使 GP 先验非常平滑，接近一个常数函数。由于真实数据是以 $\\theta_2=0$ 生成的，底层函数是一个简单的衰减曲线。非常平滑的 GP 在结构上可能不如参数化的 $t^{-1/2}$ 形式匹配，但其简单性（低有效复杂度）可能仍然会得到一个有竞争力的证据分数。\n\n算法将计算这些值，从而在这些原则的指导下进行量化的模型比较。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import cholesky, solve_triangular\n\ndef solve():\n    \"\"\"\n    Solves the Bayesian model comparison problem for the given test cases.\n    \"\"\"\n\n    test_cases = [\n        # Test Case 1 (balanced, moderately informative data)\n        {\n            \"t\": np.array([300, 600, 1200, 2400, 4800]), # s\n            \"true_theta1\": 1.5e-7, # mol m^-2 s^-1/2\n            \"true_theta2\": 2.0e-8, # mol m^-2 s^-1\n            \"sigma\": 1.0e-8, # mol m^-2 s^-1\n            \"eps\": np.array([1.0, -1.0, 0.5, -0.2, 0.3]) * 1e-8, # mol m^-2 s^-1\n            \"s1_sq\": (1.0e-7)**2, # (mol m^-2 s^-1/2)^2\n            \"s2_sq\": (5.0e-8)**2, # (mol m^-2 s^-1)^2\n            \"sf_sq\": (1.0e-7)**2, # (mol m^-2 s^-1)^2\n            \"l\": 1000.0, # s\n        },\n        # Test Case 2 (small sample, highly flexible GP)\n        {\n            \"t\": np.array([1000, 2000, 3000]), # s\n            \"true_theta1\": 1.0e-7, # mol m^-2 s^-1/2\n            \"true_theta2\": 1.0e-8, # mol m^-2 s^-1\n            \"sigma\": 5.0e-8, # mol m^-2 s^-1\n            \"eps\": np.array([2.0, -1.0, 0.5]) * 1e-8, # mol m^-2 s^-1\n            \"s1_sq\": (5.0e-7)**2, # (mol m^-2 s^-1/2)^2\n            \"s2_sq\": (1.0e-7)**2, # (mol m^-2 s^-1)^2\n            \"sf_sq\": (1.0e-7)**2, # (mol m^-2 s^-1)^2\n            \"l\": 10.0, # s\n        },\n        # Test Case 3 (dense sampling, nearly constant GP prior)\n        {\n            \"t\": np.array([500, 1000, 1500, 2000, 2500, 3000]), # s\n            \"true_theta1\": 2.0e-7, # mol m^-2 s^-1/2\n            \"true_theta2\": 0.0, # mol m^-2 s^-1\n            \"sigma\": 5.0e-9, # mol m^-2 s^-1\n            \"eps\": np.array([-0.2, 0.1, -0.1, 0.0, 0.2, -0.3]) * 1e-8, # mol m^-2 s^-1\n            \"s1_sq\": (1.0e-7)**2, # (mol m^-2 s^-1/2)^2\n            \"s2_sq\": (1.0e-8)**2, # (mol m^-2 s^-1)^2\n            \"sf_sq\": (1.0e-7)**2, # (mol m^-2 s^-1)^2\n            \"l\": 10000.0, # s\n        }\n    ]\n\n    def compute_log_marginal_likelihood(y, C_y):\n        \"\"\"\n        Computes the log marginal likelihood for a zero-mean Gaussian model.\n\n        Args:\n            y (np.ndarray): The observation vector.\n            C_y (np.ndarray): The data covariance matrix.\n\n        Returns:\n            float: The natural logarithm of the marginal likelihood.\n        \"\"\"\n        n = len(y)\n        # Cholesky decomposition for stable computation\n        # L L^T = C_y\n        try:\n            L = cholesky(C_y, lower=True)\n        except np.linalg.LinAlgError:\n            return -np.inf # Matrix not positive definite\n\n        # Log-determinant term: log(det(C_y)) = 2 * sum(log(diag(L)))\n        log_det_C = 2 * np.sum(np.log(np.diag(L)))\n\n        # Quadratic form: y^T C_y^-1 y\n        # Solve L z = y for z\n        z = solve_triangular(L, y, lower=True)\n        # Quadratic form is z^T z\n        quadratic_form = np.dot(z, z)\n\n        # Assemble the log marginal likelihood\n        log_ml = -0.5 * (n * np.log(2 * np.pi) + log_det_C + quadratic_form)\n        return log_ml\n\n    def log_ml_gp(t, y, sf_sq, l, sigma):\n        \"\"\"Computes log marginal likelihood for the GP model.\"\"\"\n        n = len(t)\n        sigma_sq = sigma**2\n        \n        # Build kernel matrix K\n        t_col = t.reshape(-1, 1)\n        sq_dist = (t_col - t_col.T)**2\n        K = sf_sq * np.exp(-0.5 * sq_dist / l**2)\n\n        # Data covariance C_y = K + sigma^2 * I\n        C_y_gp = K + sigma_sq * np.identity(n)\n        \n        return compute_log_marginal_likelihood(y, C_y_gp)\n\n    def log_ml_parametric(t, y, s1_sq, s2_sq, sigma):\n        \"\"\"Computes log marginal likelihood for the parametric SEI model.\"\"\"\n        n = len(t)\n        sigma_sq = sigma**2\n\n        # Build design matrix Phi\n        Phi = np.vstack((t**-0.5, np.ones(n))).T\n\n        # Prior covariance Sigma0\n        Sigma0 = np.diag([s1_sq, s2_sq])\n\n        # Data covariance C_y = Phi Sigma0 Phi^T + sigma^2 I\n        C_y_param = Phi @ Sigma0 @ Phi.T + sigma_sq * np.identity(n)\n        \n        return compute_log_marginal_likelihood(y, C_y_param)\n\n    results = []\n    for case in test_cases:\n        # 1. Generate data y\n        t = case[\"t\"]\n        f_true = case[\"true_theta1\"] * t**-0.5 + case[\"true_theta2\"]\n        y = f_true + case[\"eps\"]\n\n        # 2. Compute log marginal likelihood for GP model\n        log_ml_gp_val = log_ml_gp(t, y, case[\"sf_sq\"], case[\"l\"], case[\"sigma\"])\n        \n        # 3. Compute log marginal likelihood for parametric model\n        log_ml_param_val = log_ml_parametric(t, y, case[\"s1_sq\"], case[\"s2_sq\"], case[\"sigma\"])\n\n        # 4. Compute the difference Delta\n        delta = log_ml_gp_val - log_ml_param_val\n        results.append(delta)\n    \n    # Final print statement in the exact required format\n    print(f\"[{','.join(f'{r:.10f}' for r in results)}]\")\n\nsolve()\n\n```"
        }
    ]
}