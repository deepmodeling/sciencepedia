{
    "hands_on_practices": [
        {
            "introduction": "局部灵敏度分析是理解模型参数微小变化如何影响输出的关键。本练习将通过一个核心的电化学模型——Butler-Volmer 方程，指导你推导出容量对交换电流密度的局部灵敏度 。这个过程不仅能加深你对电化学动力学的理解，还能锻炼你在处理复杂耦合系统时应用隐式微分等数学技巧的能力。",
            "id": "3948524",
            "problem": "一个自动化的电池设计和仿真工作流，通过在电荷转移控制动力学条件下，评估放电容量对交换电流密度变化的响应，来筛选候选的负极化学体系。考虑一个面积为 $A$ 的单平面电极，在温度 $T$ 下恒温运行，并施加固定的电极电势 $\\phi$。其界面平衡电势为 $U$，在持续时间为 $\\tau$ 的短暂放电窗口内近似保持不变。界面过电势定义为 $\\eta = \\phi - U - i R_{s}$，其中 $R_{s}$ 是一个集总串联电阻，$i = A j$ 是总电流，$j$ 是界面电流密度。忽略浓差极化和传质限制，动力学由 Butler–Volmer 关系式控制，\n$$\nj = j_{0} \\left[\\exp\\!\\left(\\frac{\\alpha_{a} F \\eta}{R T}\\right) - \\exp\\!\\left(-\\frac{\\alpha_{c} F \\eta}{R T}\\right)\\right],\n$$\n其中 $j_{0}$ 是交换电流密度，$F$ 是法拉第常数，$R$ 是普适气体常数，$\\alpha_{a}$ 和 $\\alpha_{c}$ 分别是阳极和阴极电荷转移系数。在窗口 $\\tau$ 内的放电容量定义为电荷 $Q = A \\int_{0}^{\\tau} j(t)\\,\\mathrm{d}t$。假设在 $\\tau$ 期间为准稳态操作，因此在与上述关系式一致的工作点上，$j$ 不随时间变化。将 $A$、$T$、$R_{s}$、$\\phi$、$U$、$\\alpha_{a}$ 和 $\\alpha_{c}$ 视为相对于 $j_{0}$ 的常数。\n\n从上述基本定义出发，推导一个闭式解析表达式，用于表示在工作点处求值的、放电容量相对于交换电流密度的局部灵敏度，即导数 $\\frac{\\partial Q}{\\partial j_{0}}$。您的表达式必须明确显示其对 $\\alpha_{a}$、$\\alpha_{c}$ 和过电势 $\\eta$ 的依赖关系，并包含通过串联电阻 $R_{s}$ 实现的 $\\eta$ 与 $j$ 之间的耦合关系。所有量均使用国际单位制 (SI)。将最终答案表示为单个闭式解析表达式，且最终表达式中不包含单位。无需进行数值四舍五入。",
            "solution": "用户要求推导放电容量 $Q$ 相对于交换电流密度 $j_{0}$ 的局部灵敏度。该灵敏度表示为偏导数 $\\frac{\\partial Q}{\\partial j_{0}}$。推导必须从所提供的基本定义开始。\n\n首先，我们建立放电容量 $Q$ 和界面电流密度 $j$ 之间的关系。问题将容量定义为 $Q = A \\int_{0}^{\\tau} j(t)\\,\\mathrm{d}t$，其中 $A$ 是电极面积，$\\tau$ 是放电持续时间。一个关键的简化假设是系统在准稳态条件下运行，这意味着电流密度 $j$ 在时间间隔 $\\tau$ 内是恒定的。因此，该积分简化为：\n$$\nQ = A j \\tau\n$$\n参数 $A$ 和 $\\tau$ 相对于 $j_{0}$ 是常数。为了求得 $\\frac{\\partial Q}{\\partial j_{0}}$，我们可以应用链式法则：\n$$\n\\frac{\\partial Q}{\\partial j_{0}} = \\frac{\\partial (A \\tau j)}{\\partial j_{0}} = A \\tau \\frac{\\partial j}{\\partial j_{0}}\n$$\n因此，问题的核心是确定电流密度 $j$ 相对于交换电流密度 $j_{0}$ 的偏导数。\n\n该系统由两个耦合方程描述。第一个是关于电流密度 $j$ 的 Butler-Volmer 方程：\n$$\nj = j_{0} \\left[\\exp\\left(\\frac{\\alpha_{a} F \\eta}{R T}\\right) - \\exp\\left(-\\frac{\\alpha_{c} F \\eta}{R T}\\right)\\right] \\quad (1)\n$$\n第二个方程定义了界面过电势 $\\eta$：\n$$\n\\eta = \\phi - U - i R_{s}\n$$\n代入 $i = A j$（其中 $j$ 是电流密度），我们得到：\n$$\n\\eta = \\phi - U - A R_s j \\quad (2)\n$$\n在这个系统中，$j$ 和 $\\eta$ 都是自变量 $j_{0}$ 的函数，而所有其他量（$A$、$T$、$R_s$、$\\phi$、$U$、$\\alpha_a$、$\\alpha_c$、$F$、$R$）相对于 $j_0$ 都被视为常数。为了求得 $\\frac{\\partial j}{\\partial j_{0}}$，我们必须使用隐式微分。\n\n我们对方程 (1) 关于 $j_{0}$ 求导。对右侧应用乘法法则，我们得到：\n$$\n\\frac{\\partial j}{\\partial j_{0}} = \\frac{\\partial}{\\partial j_{0}} \\left( j_{0} \\right) \\left[\\exp\\left(\\frac{\\alpha_{a} F \\eta}{R T}\\right) - \\exp\\left(-\\frac{\\alpha_{c} F \\eta}{R T}\\right)\\right] + j_{0} \\frac{\\partial}{\\partial j_{0}} \\left[\\exp\\left(\\frac{\\alpha_{a} F \\eta}{R T}\\right) - \\exp\\left(-\\frac{\\alpha_{c} F \\eta}{R T}\\right)\\right]\n$$\n第一项得以简化。通过认识到方括号中的项根据方程 (1) 等于 $j/j_0$，我们得到：\n$$\n\\frac{\\partial j}{\\partial j_{0}} = 1 \\cdot \\frac{j}{j_{0}} + j_{0} \\frac{\\partial}{\\partial j_{0}} \\left[\\exp\\left(\\frac{\\alpha_{a} F \\eta}{R T}\\right) - \\exp\\left(-\\frac{\\alpha_{c} F \\eta}{R T}\\right)\\right]\n$$\n现在，我们对第二项应用链式法则，因为 $\\eta$ 是 $j_{0}$ 的函数：\n$$\n\\frac{\\partial j}{\\partial j_{0}} = \\frac{j}{j_{0}} + j_{0} \\left[ \\exp\\left(\\frac{\\alpha_{a} F \\eta}{R T}\\right) \\cdot \\frac{\\alpha_{a} F}{R T} \\frac{\\partial \\eta}{\\partial j_{0}} - \\exp\\left(-\\frac{\\alpha_{c} F \\eta}{R T}\\right) \\cdot \\left(-\\frac{\\alpha_{c} F}{R T}\\right) \\frac{\\partial \\eta}{\\partial j_{0}} \\right]\n$$\n提取公因式得到：\n$$\n\\frac{\\partial j}{\\partial j_{0}} = \\frac{j}{j_{0}} + j_{0} \\frac{F}{R T} \\left[ \\alpha_{a} \\exp\\left(\\frac{\\alpha_{a} F \\eta}{R T}\\right) + \\alpha_{c} \\exp\\left(-\\frac{\\alpha_{c} F \\eta}{R T}\\right) \\right] \\frac{\\partial \\eta}{\\partial j_{0}} \\quad (3)\n$$\n这个方程包含未知导数 $\\frac{\\partial \\eta}{\\partial j_{0}}$。我们通过对方程 (2) 关于 $j_{0}$ 求导来找到它：\n$$\n\\frac{\\partial \\eta}{\\partial j_{0}} = \\frac{\\partial}{\\partial j_{0}} (\\phi - U - A R_s j)\n$$\n由于 $\\phi$、$U$、$A$ 和 $R_s$ 相对于 $j_{0}$ 是常数，这简化为：\n$$\n\\frac{\\partial \\eta}{\\partial j_{0}} = -A R_s \\frac{\\partial j}{\\partial j_{0}} \\quad (4)\n$$\n现在，我们将方程 (4) 代入方程 (3)：\n$$\n\\frac{\\partial j}{\\partial j_{0}} = \\frac{j}{j_{0}} + j_{0} \\frac{F}{R T} \\left[ \\alpha_{a} \\exp\\left(\\frac{\\alpha_{a} F \\eta}{R T}\\right) + \\alpha_{c} \\exp\\left(-\\frac{\\alpha_{c} F \\eta}{R T}\\right) \\right] \\left( -A R_s \\frac{\\partial j}{\\partial j_{0}} \\right)\n$$\n现在我们可以求解 $\\frac{\\partial j}{\\partial j_{0}}$。我们将所有包含 $\\frac{\\partial j}{\\partial j_{0}}$ 的项移到一边：\n$$\n\\frac{\\partial j}{\\partial j_{0}} + A R_s j_{0} \\frac{F}{R T} \\left[ \\alpha_{a} \\exp\\left(\\frac{\\alpha_{a} F \\eta}{R T}\\right) + \\alpha_{c} \\exp\\left(-\\frac{\\alpha_{c} F \\eta}{R T}\\right) \\right] \\frac{\\partial j}{\\partial j_{0}} = \\frac{j}{j_{0}}\n$$\n提取 $\\frac{\\partial j}{\\partial j_{0}}$：\n$$\n\\frac{\\partial j}{\\partial j_{0}} \\left( 1 + A R_s j_{0} \\frac{F}{R T} \\left[ \\alpha_{a} \\exp\\left(\\frac{\\alpha_{a} F \\eta}{R T}\\right) + \\alpha_{c} \\exp\\left(-\\frac{\\alpha_{c} F \\eta}{R T}\\right) \\right] \\right) = \\frac{j}{j_{0}}\n$$\n分离出 $\\frac{\\partial j}{\\partial j_{0}}$ 得到：\n$$\n\\frac{\\partial j}{\\partial j_{0}} = \\frac{j/j_{0}}{1 + A R_s j_{0} \\frac{F}{R T} \\left[ \\alpha_{a} \\exp\\left(\\frac{\\alpha_{a} F \\eta}{R T}\\right) + \\alpha_{c} \\exp\\left(-\\frac{\\alpha_{c} F \\eta}{R T}\\right) \\right]}\n$$\n最后，我们将此结果代回容量灵敏度的表达式 $\\frac{\\partial Q}{\\partial j_{0}} = A \\tau \\frac{\\partial j}{\\partial j_{0}}$：\n$$\n\\frac{\\partial Q}{\\partial j_{0}} = \\frac{A \\tau (j/j_{0})}{1 + A R_s j_{0} \\frac{F}{R T} \\left[ \\alpha_{a} \\exp\\left(\\frac{\\alpha_{a} F \\eta}{R T}\\right) + \\alpha_{c} \\exp\\left(-\\frac{\\alpha_{c} F \\eta}{R T}\\right) \\right]}\n$$\n为了得到以指定变量表示的最终表达式，我们使用方程 (1) 中的定义替换分子中的项 $j/j_0$：\n$$\n\\frac{j}{j_{0}} = \\exp\\left(\\frac{\\alpha_{a} F \\eta}{R T}\\right) - \\exp\\left(-\\frac{\\alpha_{c} F \\eta}{R T}\\right)\n$$\n代入此式可得到灵敏度的最终闭式解析表达式：\n$$\n\\frac{\\partial Q}{\\partial j_{0}} = \\frac{A \\tau \\left[\\exp\\left(\\frac{\\alpha_{a} F \\eta}{R T}\\right) - \\exp\\left(-\\frac{\\alpha_{c} F \\eta}{R T}\\right)\\right]}{1 + A R_s j_{0} \\frac{F}{R T} \\left[ \\alpha_{a} \\exp\\left(\\frac{\\alpha_{a} F \\eta}{R T}\\right) + \\alpha_{c} \\exp\\left(-\\frac{\\alpha_{c} F \\eta}{R T}\\right) \\right]}\n$$\n此表达式在工作点处求值，该工作点由对于给定的 $j_0$ 同时满足方程 (1) 和 (2) 的特定 $\\eta$ 和 $j$ 值定义。该表达式正确地显示了对 $\\alpha_a$、$\\alpha_c$ 和 $\\eta$ 的显式依赖关系，并包含了串联电阻 $R_s$ 的影响。",
            "answer": "$$\n\\boxed{\\frac{A \\tau \\left[\\exp\\left(\\frac{\\alpha_{a} F \\eta}{R T}\\right) - \\exp\\left(-\\frac{\\alpha_{c} F \\eta}{R T}\\right)\\right]}{1 + A R_{s} j_{0} \\frac{F}{R T} \\left[\\alpha_{a} \\exp\\left(\\frac{\\alpha_{a} F \\eta}{R T}\\right) + \\alpha_{c} \\exp\\left(-\\frac{\\alpha_{c} F \\eta}{R T}\\right)\\right]}}\n$$"
        },
        {
            "introduction": "与关注单点扰动的局部灵敏度不同，全局灵敏度分析（GSA）评估参数在整个不确定性范围内的影响。本练习要求你通过编写代码，为一个简化的电池热模型实现基于 Sobol 指数的 GSA 。通过亲手实现蒙特卡洛采样和 Jansen 估计器，你将学会如何量化和排序不同因素（如散热条件和产热速率）对电池最高温度的总体影响。",
            "id": "3948598",
            "problem": "您的任务是实现一个简化电池热管理模型的蒙特卡洛全局灵敏度分析，并根据参数的总 Sobol 指数对其进行排序。背景是自动化电池设计和仿真；目标是量化冷却边界条件和内部热源在固定时间范围内对最高电芯温度的影响。\n\n假设有一个单一的、热集总的电池电芯，其内部生热是恒定的。该电芯通过对流方式冷却至周围环境。从积分能量平衡和牛顿冷却定律出发，采用集总电容模型，其中电池电芯温度随时间演变的规律如下：\n$$\nm c_p \\frac{d T(t)}{dt} = q - h A \\left(T(t) - T_{\\text{amb}}\\right),\n$$\n其中 $m$ 是质量，$c_p$ 是比热容，$q$ 是总内部生热率，$h$ 是对流传热系数，$A$ 是有效冷却面积，$T_{\\text{amb}}$ 是环境温度。假设初始条件为 $T(0) = T_{\\text{amb}}$ 且 $q$ 恒定，求解在时间 $t = \\tau$ 时的绝对温度，以定义热管理有效性指标：\n$$\nf(h, q, T_{\\text{amb}}, A) = T(\\tau) = T_{\\text{amb}} + \\frac{q}{h A}\\left(1 - e^{- \\frac{h A}{m c_p} \\tau}\\right).\n$$\n所有物理单位都应统一处理如下：$m$ 的单位是 $\\mathrm{kg}$，$c_p$ 的单位是 $\\mathrm{J}\\cdot\\mathrm{kg}^{-1}\\cdot\\mathrm{K}^{-1}$，$q$ 的单位是 $\\mathrm{W}$，$h$ 的单位是 $\\mathrm{W}\\cdot\\mathrm{m}^{-2}\\cdot\\mathrm{K}^{-1}$，$A$ 的单位是 $\\mathrm{m}^2$，$T_{\\text{amb}}$ 的单位是 $\\mathrm{K}$，$\\tau$ 的单位是 $\\mathrm{s}$。程序的输出不会直接报告温度；相反，它将提供参数排名。尽管如此，模型必须在内部以 $\\mathrm{K}$ 为单位计算 $f$。\n\n使用基于方差的 Sobol 方法进行全局灵敏度分析。设不确定性输入向量为\n$$\n\\mathbf{X} = \\left(h, q, T_{\\text{amb}}, A\\right) \\in \\mathbb{R}^4,\n$$\n其分量在指定范围内服从独立的均匀分布。对于参数 $i$ 的总 Sobol 指数，记为 $S_{T_i}$，使用 Jansen 估计量。抽取两个独立的蒙特卡洛样本矩阵 $\\mathbf{A}$ 和 $\\mathbf{B}$，形状为 $N \\times d$（其中 $d = 4$），每个列都从其参数范围内独立且均匀地采样。对于每个参数 $i \\in \\{0,1,2,3\\}$，构造混合矩阵 $\\mathbf{A}_{B}^{(i)}$，该矩阵取自 $\\mathbf{B}$ 的所有列，但第 $i$ 列必须来自 $\\mathbf{A}$。在 $\\mathbf{A}$ 和每个 $\\mathbf{A}_{B}^{(i)}$ 上评估模型 $f$，以获得向量 $Y_{\\mathbf{A}}$ 和 $Y_{\\mathbf{A}_{B}^{(i)}}$。使用以下公式估计输出方差：\n$$\n\\operatorname{Var}(Y) \\approx \\frac{1}{N} \\sum_{j=1}^{N} Y_{\\mathbf{A},j}^2 - \\left(\\frac{1}{N} \\sum_{j=1}^{N} Y_{\\mathbf{A},j}\\right)^2,\n$$\n并使用以下公式估计总 Sobol 指数：\n$$\nS_{T_i} \\approx \\frac{\\sum_{j=1}^{N} \\left(Y_{\\mathbf{A},j} - Y_{\\mathbf{A}_{B}^{(i)},j}\\right)^2}{2 N \\operatorname{Var}(Y)}.\n$$\n如果 $\\operatorname{Var}(Y) = 0$，则定义所有 $S_{T_i} = 0$。\n\n您的程序必须：\n- 按规定实现模型 $f$。\n- 按规定实现 Jansen 总效应估计量。\n- 对每个测试用例，在其定义的范围内使用伪随机均匀采样。\n- 对每个测试用例，根据总 Sobol 指数的降序对参数进行排序。平局必须按参数索引的升序打破。\n\n参数索引必须严格如下：\n- $i = 0$ 对应于 $h$，单位为 $\\mathrm{W}\\cdot\\mathrm{m}^{-2}\\cdot\\mathrm{K}^{-1}$。\n- $i = 1$ 对应于 $q$，单位为 $\\mathrm{W}$。\n- $i = 2$ 对应于 $T_{\\text{amb}}$，单位为 $\\mathrm{K}$。\n- $i = 3$ 对应于 $A$，单位为 $\\mathrm{m}^2$。\n\n对所有测试用例使用以下常量：\n- $m = 0.5$，单位为 $\\mathrm{kg}$。\n- $c_p = 900$，单位为 $\\mathrm{J}\\cdot\\mathrm{kg}^{-1}\\cdot\\mathrm{K}^{-1}$。\n- $\\tau = 600$，单位为 $\\mathrm{s}$。\n\n测试套件：\n- 测试用例 1 (一般情况)：$N = 4096$，种子 $= 2025$，参数范围 $h \\in [10, 100]$，$q \\in [1, 20]$，$T_{\\text{amb}} \\in [293, 313]$，$A \\in [0.01, 0.05]$。\n- 测试用例 2 (小样本边界情况)：$N = 128$，种子 $= 2026$，参数范围 $h \\in [10, 100]$，$q \\in [1, 20]$，$T_{\\text{amb}} \\in [293, 313]$，$A \\in [0.01, 0.05]$。\n- 测试用例 3 (内部生热可忽略的边缘情况)：$N = 2048$，种子 $= 2027$，参数范围 $h \\in [5, 150]$，$q \\in [0, 0.1]$，$T_{\\text{amb}} \\in [293, 313]$，$A \\in [0.01, 0.05]$。\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的每个元素是代表该测试用例中按总 Sobol 指数降序排列的参数索引的整数列表。例如，生成以下形式的输出：\n$$\n[\\,[i_{1,1}, i_{1,2}, i_{1,3}, i_{1,4}],\\,[i_{2,1}, i_{2,2}, i_{2,3}, i_{2,4}],\\,[i_{3,1}, i_{3,2}, i_{3,3}, i_{3,4}]\\,],\n$$\n其中 $[i_{k,1}, i_{k,2}, i_{k,3}, i_{k,4}]$ 是测试用例 $k \\in \\{1,2,3\\}$ 的排名。",
            "solution": "用户希望对一个简化的电池热模型进行全局灵敏度分析。\n\n### 步骤1：提取给定信息\n\n*   **模型方程：** 一个热集总电池电芯的温度 $T(t)$ 演变遵循常微分方程 $m c_p \\frac{d T(t)}{dt} = q - h A \\left(T(t) - T_{\\text{amb}}\\right)$。\n*   **初始条件：** $T(0) = T_{\\text{amb}}$。\n*   **模型输出函数：** 在时间 $t=\\tau$ 的解由 $f(h, q, T_{\\text{amb}}, A) = T(\\tau) = T_{\\text{amb}} + \\frac{q}{h A}\\left(1 - e^{- \\frac{h A}{m c_p} \\tau}\\right)$ 给出。\n*   **输入参数（不确定）：** $\\mathbf{X} = \\left(h, q, T_{\\text{amb}}, A\\right)$，其中 $h$（对流传热系数，索引 $0$），$q$（内部生热率，索引 $1$），$T_{\\text{amb}}$（环境温度，索引 $2$），以及 $A$（有效冷却面积，索引 $3$）。这些参数被假定为在给定范围内独立且均匀分布。\n*   **固定常数：** $m = 0.5 \\, \\mathrm{kg}$，$c_p = 900 \\, \\mathrm{J}\\cdot\\mathrm{kg}^{-1}\\cdot\\mathrm{K}^{-1}$，$\\tau = 600 \\, \\mathrm{s}$。\n*   **灵敏度分析方法：** 基于方差的 Sobol 方法，用于计算总灵敏度指数 $S_{T_i}$。\n*   **估计量：** Jansen 估计量。\n*   **采样：** 两个独立的蒙特卡洛样本矩阵 $\\mathbf{A}$ 和 $\\mathbf{B}$，形状为 $N \\times d$（其中 $d=4$）。\n*   **混合矩阵构造：** 对于每个参数 $i$，矩阵 $\\mathbf{A}_{B}^{(i)}$ 通过取 $\\mathbf{B}$ 的所有列，除了第 $i$ 列，该列取自 $\\mathbf{A}$ 来构造。\n*   **方差估计：** $\\operatorname{Var}(Y) \\approx \\frac{1}{N} \\sum_{j=1}^{N} Y_{\\mathbf{A},j}^2 - \\left(\\frac{1}{N} \\sum_{j=1}^{N} Y_{\\mathbf{A},j}\\right)^2$，其中 $Y_{\\mathbf{A}}$ 是在矩阵 $\\mathbf{A}$ 上评估的模型输出向量。\n*   **总 Sobol 指数估计：** $S_{T_i} \\approx \\frac{\\sum_{j=1}^{N} \\left(Y_{\\mathbf{A},j} - Y_{\\mathbf{A}_{B}^{(i)},j}\\right)^2}{2 N \\operatorname{Var}(Y)}$。如果 $\\operatorname{Var}(Y)=0$，则 $S_{T_i}=0$。\n*   **排序规则：** 参数按其总 Sobol 指数 $S_{T_i}$ 的降序排列。平局由参数索引（$0, 1, 2, 3$）的升序打破。\n*   **测试用例：**\n    1.  $N = 4096$，种子 $= 2025$，范围：$h \\in [10, 100]$，$q \\in [1, 20]$，$T_{\\text{amb}} \\in [293, 313]$，$A \\in [0.01, 0.05]$。\n    2.  $N = 128$，种子 $= 2026$，范围：$h \\in [10, 100]$，$q \\in [1, 20]$，$T_{\\text{amb}} \\in [293, 313]$，$A \\in [0.01, 0.05]$。\n    3.  $N = 2048$，种子 $= 2027$，范围：$h \\in [5, 150]$，$q \\in [0, 0.1]$，$T_{\\text{amb}} \\in [293, 313]$，$A \\in [0.01, 0.05]$。\n\n### 步骤2：使用提取的给定信息进行验证\n\n*   **科学依据：** 该问题在科学上是合理的。它采用了集总电容模型，这是热工学中对毕渥数较低物体的标准且恰当的简化。控制常微分方程及其解析解都是正确的。使用 Jansen 估计量的 Sobol 方法是一种用于全局灵敏度分析的、成熟且严谨的技术。所有物理常数和参数范围都是现实的。\n*   **适定性：** 该问题是适定的。它提供了一个唯一的模型函数，一个明确定义的灵敏度指数计算算法，所有必要的常数，每个输入的特定参数范围，以及用于可复现性的随机种子。平局打破规则确保了唯一的排名。\n*   **客观性：** 问题以精确、客观和量化的术语陈述，没有歧义或主观论断。\n\n### 步骤3：结论与行动\n\n该问题是**有效的**。可以通过忠实地实现指定的模型和数值方法来构建解决方案。\n\n### 基于原则的解决方案设计\n\n该解决方案的实现遵循了规定的蒙特卡洛模拟和基于方差的灵敏度分析原则。\n\n1.  **模型实现：** 分析的核心是模型函数 $f(h, q, T_{\\text{amb}}, A)$。该函数通过使用 `numpy` 进行向量化计算来实现数值效率，使其能够同时为整个包含 $N$ 个输入样本的矩阵评估模型。该函数为给定的输入向量 $h, q, T_{\\text{amb}}, A$ 计算 $T(\\tau) = T_{\\text{amb}} + \\frac{q}{h A}\\left(1 - e^{- \\frac{h A \\tau}{m c_p}}\\right)$。\n\n2.  **蒙特卡洛采样：** 对于每个测试用例，过程始于设置指定的伪随机数生成器种子以确保可复现性。生成两个独立的样本矩阵 $\\mathbf{A}$ 和 $\\mathbf{B}$。每个矩阵有 $N$ 行和 $d=4$ 列。每一列对应四个输入参数之一（$h, q, T_{\\text{amb}}, A$），其值从由参数指定范围定义的独立均匀分布中抽取。\n\n3.  **用于总 Sobol 指数的 Jansen 估计量：** 总 Sobol 指数 $S_{T_i}$ 量化了输入参数 $X_i$ 对输出方差的总贡献，包括其与所有其他参数的相互作用。我们按规定实现 Jansen 估计量：\n    *   首先，对矩阵 $\\mathbf{A}$ 中的所有样本点评估模型，得到输出向量 $Y_{\\mathbf{A}}$。\n    *   使用提供的公式从 $Y_{\\mathbf{A}}$ 估计输出的总方差 $\\operatorname{Var}(Y)$，这等同于有偏样本方差。对 $\\operatorname{Var}(Y)=0$ 的情况进行了检查。\n    *   然后，对于每个参数 $i \\in \\{0, 1, 2, 3\\}$，构造一个“混合”矩阵 $\\mathbf{A}_{B}^{(i)}$。根据问题的明确指示，该矩阵由矩阵 $\\mathbf{B}$ 的所有列组成，除了第 $i$ 列，该列取自矩阵 $\\mathbf{A}$。\n    *   在此混合矩阵上评估模型，以产生输出向量 $Y_{\\mathbf{A}_{B}^{(i)}}$。\n    *   然后使用提供的公式计算总 Sobol 指数 $S_{T_i}$：$S_{T_i} \\approx \\frac{\\sum_{j=1}^{N} \\left(Y_{\\mathbf{A},j} - Y_{\\mathbf{A}_{B}^{(i)},j}\\right)^2}{2 N \\operatorname{Var}(Y)}$。该公式量化了当仅第 $i$ 个参数的值在两个不同样本之间变化，而所有其他参数也在变化时，输出平均变化的程度。\n\n4.  **参数排序：** 计算出四个总 Sobol 指数（$S_{T_0}, S_{T_1}, S_{T_2}, S_{T_3}$）后，对相应的参数索引（$0, 1, 2, 3$）进行排序。主要排序标准是 $S_{T_i}$ 的值，按降序排列。用于打破任何平局的次要标准是参数索引 $i$，按升序排列。这是通过基于元组键 `(-S_Ti, i)` 对索引进行排序来实现的。\n\n5.  **执行与格式化：** 整个过程被封装在一个函数中，该函数遍历三个指定的测试用例。对于每个用例，它执行采样、估计和排序，并存储得到的排序索引列表。最后，将所有用例的结果格式化为单个字符串，表示一个整数列表的列表，不含空格，符合要求的输出格式。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Performs global sensitivity analysis on a battery thermal model and ranks\n    parameters based on their total Sobol indices for a suite of test cases.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (N, seed, parameter_ranges)\n    test_cases = [\n        # Case 1 (general case)\n        (4096, 2025, [(10, 100), (1, 20), (293, 313), (0.01, 0.05)]),\n        # Case 2 (small-sample boundary)\n        (128, 2026, [(10, 100), (1, 20), (293, 313), (0.01, 0.05)]),\n        # Case 3 (edge case with negligible internal heat)\n        (2048, 2027, [(5, 150), (0, 0.1), (293, 313), (0.01, 0.05)]),\n    ]\n\n    # Global constants for the model\n    m = 0.5  # kg\n    cp = 900.0  # J/kg/K\n    tau = 600.0  # s\n    d = 4  # Number of parameters\n\n    def model_f(h, q, T_amb, A):\n        \"\"\"\n        Calculates the battery cell temperature at time tau.\n        This is a vectorized implementation using numpy.\n        \n        Args:\n            h (np.ndarray): Convective heat transfer coefficient vector.\n            q (np.ndarray): Internal heat generation rate vector.\n            T_amb (np.ndarray): Ambient temperature vector.\n            A (np.ndarray): Cooling area vector.\n\n        Returns:\n            np.ndarray: Final temperature T(tau) vector.\n        \"\"\"\n        # To prevent division by zero, although problem ranges make it impossible\n        hA = h * A\n        # The term is set to a large number to ensure the result is T_amb when hA is zero.\n        # This is a safe guard not strictly needed for the given parameter ranges.\n        safe_hA = np.where(hA == 0, 1e12, hA)\n        \n        term1 = q / safe_hA\n        exponent = -safe_hA * tau / (m * cp)\n        exp_term = np.exp(exponent)\n        \n        return T_amb + term1 * (1 - exp_term)\n\n    def analyze_case(N, seed, param_ranges):\n        \"\"\"\n        Performs the sensitivity analysis for a single case.\n        \"\"\"\n        np.random.seed(seed)\n        \n        # Generate two independent N x d sample matrices, A and B\n        A_matrix = np.zeros((N, d))\n        B_matrix = np.zeros((N, d))\n        \n        for i in range(d):\n            low, high = param_ranges[i]\n            A_matrix[:, i] = np.random.uniform(low, high, size=N)\n            B_matrix[:, i] = np.random.uniform(low, high, size=N)\n            \n        # Evaluate the model on matrix A\n        Y_A = model_f(A_matrix[:, 0], A_matrix[:, 1], A_matrix[:, 2], A_matrix[:, 3])\n        \n        # Estimate the variance of the output Y based on Y_A samples\n        # Var(Y) = E[Y^2] - (E[Y])^2\n        var_Y = np.mean(Y_A**2) - (np.mean(Y_A))**2\n\n        total_sobol_indices = []\n\n        if var_Y == 0:\n            # If variance is zero, all sensitivities are zero.\n            # Ranking follows the tie-breaking rule (ascending index).\n            return list(range(d))\n\n        # Calculate total Sobol index for each parameter\n        for i in range(d):\n            # Construct the mixed matrix A_B^(i) as per the problem description:\n            # \"all columns from B except the i-th, which must come from A\"\n            A_B_i = B_matrix.copy()\n            A_B_i[:, i] = A_matrix[:, i]\n            \n            # Evaluate the model on the mixed matrix\n            Y_A_B_i = model_f(A_B_i[:, 0], A_B_i[:, 1], A_B_i[:, 2], A_B_i[:, 3])\n            \n            # Estimate the total Sobol index using the Jansen estimator formula\n            # S_Ti = (1 / (2*N)) * sum((Y_A - Y_A_B_i)^2) / Var(Y)\n            numerator = np.sum((Y_A - Y_A_B_i)**2)\n            S_Ti = numerator / (2 * N * var_Y)\n            total_sobol_indices.append(S_Ti)\n\n        # Rank parameters by descending Sobol index, breaking ties with ascending index\n        param_indices = list(range(d))\n        ranked_indices = sorted(param_indices, key=lambda idx: (-total_sobol_indices[idx], idx))\n        \n        return ranked_indices\n\n    results = []\n    for case in test_cases:\n        N_val, seed_val, ranges_val = case\n        ranking = analyze_case(N_val, seed_val, ranges_val)\n        results.append(ranking)\n\n    # Format the final output string to match [[i1,i2,..],[i1,i2,..]] with no spaces.\n    inner_strs = [f\"[{','.join(map(str, r))}]\" for r in results]\n    final_output = f\"[{','.join(inner_strs)}]\"\n    \n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "计算出的灵敏度有多可靠？在自动化设计和仿真流程中，验证伴随法等复杂方法得到的梯度至关重要，同时必须将真实的物理灵敏度与数值伪影（如离散化误差）区分开。这个思想练习引导你设计一套稳健的验证方案，它结合了梯度检查  和网格收敛性分析  的原理。通过这个练习，你将学会如何批判性地评估和确保计算结果的科学严谨性，这是任何高级计算科学家必备的技能。",
            "id": "3948575",
            "problem": "在一个自动化的电池设计与仿真工作流中，考虑一个多孔电极锂离子电池模型，其状态向量 $u$ 在一个以网格尺寸 $h$ 为特征的时空网格上求解一个以残差形式 $R_h(u_h,p)=0$ 写出的离散化控制方程组。令 $p$ 表示一个标量设计参数，例如负极孔隙率或反应速率常数。令 $J_h(u_h,p)$ 表示一个离散化的目标泛函，例如达到截止电压前的放电能量。你可以通过两种方式计算 $J$ 相对于 $p$ 的局部灵敏度（梯度）：(i) 伴随法推导的梯度，记为 $g_h^{\\mathrm{adj}}=\\partial J_h/\\partial p$，与离散残差 $R_h$ 一致；以及 (ii) 有限差分检验，记为 $g_h^{\\mathrm{FD}}(\\varepsilon)$，通过在同一网格上对 $p$ 施加一个小的扰动 $p\\mapsto p+\\varepsilon$ 从 $J_h$ 计算得出。假设离散化的阶数为 $q$，因此在渐近区域中状态和泛函误差为 $\\mathcal{O}(h^q)$，并且有限差分近似会产生截断误差 $\\mathcal{O}(\\varepsilon)$（前向差分）或 $\\mathcal{O}(\\varepsilon^2)$（中心差分）以及随 $\\mathcal{O}(1/\\varepsilon)$ 增长的舍入误差。\n\n你的任务是选择一个最鲁棒的方案，通过在不同网格上以科学上可辩护的方式比较伴随法推导的梯度和有限差分检验，将物理灵敏度（连续极限 $\\mathrm{d}J/\\mathrm{d}p$）与由离散化、求解器容差和有限差分步长效应产生的数值伪影分离开来，并且不先验地假设任何一种计算是精确的。该方案必须仅依赖于灵敏度的基本定义、网格细化下的收敛性以及差分计算中的误差平衡，并且必须用可量化的证据来确定差异是由物理（真实灵敏度）还是由数值（伪影）引起的。\n\n哪个选项最能实现这一目标？\n\n- A. 构建一个具有固定细化比的网格细化序列（例如 $h, h/r, h/r^2$，其中 $r>1$）。在每个网格上，求解 $R_h(u_h,p)=0$，并收紧非线性、线性和时间积分容差，以使求解器误差低于截断误差（使容差随 $h^q$ 缩放）。使用与 $R_h$ 和 $J_h$ 一致的离散伴随法计算 $g_h^{\\mathrm{adj}}$。独立地，在同一网格上使用复步长方法（采用一个与 $h$ 无关的小 $|\\varepsilon|$）或中心差分（通过步长扫描以确定一个截断误差和舍入误差达到平衡的 $\\varepsilon$ 平台区）来计算 $g_h^{\\mathrm{FD}}(\\varepsilon)$。对于每个 $h$，验证 $|g_h^{\\mathrm{adj}}-g_h^{\\mathrm{FD}}|$ 足够小；然后对 $g_h^{\\mathrm{adj}}$ 和 $g_h^{\\mathrm{FD}}$ 应用理查森外推法来估计共同的连续极限 $g^\\ast=\\lim_{h\\to 0} \\mathrm{d}J_h/\\mathrm{d}p$。将随 $h\\to 0$ 消失的差异归因于离散伪影，将随 $\\varepsilon$ 优化消失的差异归因于差分伪影，将持续存在的差异归因于伴随实现或建模不一致。报告 $g^\\ast$ 及其从观察到的 $h^q$ 衰减中估计出的不确定性。\n- B. 在一个单一的细网格（小 $h$）上，计算 $g_h^{\\mathrm{adj}}$ 和一个使用固定 $\\varepsilon$（例如，参数单位下的 $\\varepsilon=10^{-4}$）的前向有限差分 $g_h^{\\mathrm{FD}}(\\varepsilon)$。如果 $|g_h^{\\mathrm{adj}}-g_h^{\\mathrm{FD}}|/|g_h^{\\mathrm{FD}}|  5\\%$，则接受 $g_h^{\\mathrm{adj}}$ 为物理值；否则，收紧非线性求解器容差，直到差异降至 $5\\%$ 以下，然后接受。\n- C. 构建一个电池的粗糙代理模型，并使用蒙特卡洛方法在该代理模型上计算 $p$ 的基于方差的全局 Sobol 灵敏度指数。如果该代理模型对 $p$ 的一阶指数非零，并且在符号上与单一网格上的 $g_h^{\\mathrm{adj}}$ 定性一致，则接受伴随梯度为物理值；否则，断定数值伪影占主导地位。\n- D. 将在最细可用网格上计算的 $g_h^{\\mathrm{adj}}$ 与在较粗网格上使用中心差分和固定小 $\\varepsilon$ 计算的 $g_{h/2}^{\\mathrm{FD}}$ 进行比较，同时对两次运行均保持默认求解器容差。如果两个数值在选定的容差范围内一致，则接受该结果为物理值；否则，选择幅度较小的那个，认为其受数值误差污染较少，并将其报告为物理灵敏度。",
            "solution": "该问题陈述是计算模型数值验证与确认方面的一个有效练习。它提出了一个明确定义的问题，即在一个常见的计算科学场景中，如何确定最鲁棒的方法来区分物理灵敏度和数值伪影。所有提供的信息在科学上和数学上都是合理的，代表了偏微分方程约束优化和灵敏度分析中的一个标准问题。\n\n### 步骤 1：提取已知条件\n- 控制方程：离散化的残差形式 $R_h(u_h,p)=0$\n- 状态向量：$u$；离散状态向量：$u_h$\n- 设计参数：标量 $p$\n- 目标泛函：$J_h(u_h,p)$\n- 时空网格特征尺寸：$h$\n- 离散泛函的伴随法推导梯度：$g_h^{\\mathrm{adj}}=\\partial J_h/\\partial p$\n- 离散泛函的有限差分 (FD) 梯度：$g_h^{\\mathrm{FD}}(\\varepsilon)$\n- 离散误差阶数：状态和泛函为 $\\mathcal{O}(h^q)$\n- 有限差分误差分量：截断误差（$\\mathcal{O}(\\varepsilon)$ 或 $\\mathcal{O}(\\varepsilon^2)$）和舍入误差（$\\mathcal{O}(1/\\varepsilon)$）\n- 目标：找到一个鲁棒的方案，将物理灵敏度 $\\mathrm{d}J/\\mathrm{d}p$ 与数值伪影分离开来。\n\n### 步骤 2：使用提取的已知条件进行验证\n该问题在科学上是合理的、适定的和客观的。它描述了计算科学中的一个典型挑战：确保计算出的模型灵敏度反映物理现实而非数值误差。离散伴随、有限差分检验、网格收敛和误差分析等概念都是数值分析的标准支柱。该问题不存在验证标准中列出的任何缺陷。\n\n**结论：该问题有效。**\n\n### 正确方案的推导\n目标是确定连续灵敏度 $\\mathrm{d}J/\\mathrm{d}p$，它代表了真实的物理响应。我们可以计算的量，$g_h^{\\mathrm{adj}}$ 和 $g_h^{\\mathrm{FD}}(\\varepsilon)$，是受多种误差源影响的近似值。一个鲁棒的方案必须系统地识别、量化和减轻这些误差中的每一个。\n\n计算出的梯度的总误差可以分解如下：\n$$\n\\text{总误差} = (\\text{计算出的梯度} - \\frac{\\mathrm{d}J}{\\mathrm{d}p})\n$$\n这可以分解为几个组成部分。对于伴随梯度 $g_h^{\\mathrm{adj}}$：\n$$\ng_h^{\\mathrm{adj}} - \\frac{\\mathrm{d}J}{\\mathrm{d}p} = \\underbrace{(g_h^{\\mathrm{adj}} - \\frac{\\partial J_h}{\\partial p})}_{\\text{伴随误差}} + \\underbrace{(\\frac{\\partial J_h}{\\partial p} - \\frac{\\mathrm{d}J}{\\mathrm{d}p})}_{\\text{离散误差}}\n$$\n“伴随误差”项既包括伴随实现中的错误，也包括由不精确数值求解（求解器误差）引起的误差。“离散误差”是使用尺寸为 $h$ 的网格所固有的，并预期其行为与 $\\mathcal{O}(h^q)$ 类似。\n\n对于有限差分梯度 $g_h^{\\mathrm{FD}}(\\varepsilon)$：\n$$\ng_h^{\\mathrm{FD}}(\\varepsilon) - \\frac{\\mathrm{d}J}{\\mathrm{d}p} = \\underbrace{(g_h^{\\mathrm{FD}}(\\varepsilon) - \\frac{\\partial J_h}{\\partial p})}_{\\text{有限差分误差}} + \\underbrace{(\\frac{\\partial J_h}{\\partial p} - \\frac{\\mathrm{d}J}{\\mathrm{d}p})}_{\\text{离散误差}}\n$$\n“有限差分误差”包括有限差分截断误差（依赖于 $\\varepsilon$）和舍入误差（也依赖于 $\\varepsilon$），以及来自扰动解的求解器误差。\n\n一个科学上可辩护的方案必须系统地解决这些误差：\n1.  **求解器误差：** $R_h(u_h,p)=0$ 的解是迭代求得的。求解器容差必须设置得足够紧，以使 $u_h$ 及随后的 $J_h$ 中的误差远小于离散误差 $\\mathcal{O}(h^q)$。一个标准方法是随 $h$ 缩放容差，例如，作为 $\\mathcal{O}(h^{q+1})$。\n2.  **伴随实现和有限差分误差：** 对于一个固定的网格 $h$，伴随梯度 $g_h^{\\mathrm{adj}}$ 应该是离散导数 $\\partial J_h / \\partial p$ 的一个高度精确（如果不是精确的话）的表示。有限差分梯度 $g_h^{\\mathrm{FD}}(\\varepsilon)$ 是对同一数量的近似。因此，比较它们是验证伴随实现的一个强大工具。为了使这种比较有意义，必须通过优化选择 $\\varepsilon$ 来最小化有限差分近似本身的误差。这可以通过步长扫描来找到截断误差和舍入误差平衡的“谷底”，或者通过使用像复步长导数这样的方法，它对舍入误差免疫，并允许使用非常小的 $\\varepsilon$，从而几乎消除了截断误差。在给定网格上，$g_h^{\\mathrm{adj}}$ 和优化后的 $g_h^{\\mathrm{FD}}$ 之间任何剩余的显著差异都指向代码中的错误。\n3.  **离散误差：** 这是离散世界（在网格 $h$ 上）和连续世界（物理现实）之间的误差。当试图确定物理灵敏度时，这是最基本的误差源。量化和消除它的唯一严谨方法是进行系统的网格细化研究。通过在一系列网格（$h, h/r, h/r^2, \\dots$）上计算验证过的梯度（来自步骤 2），可以观察到梯度向一个极限的收敛。观察到的收敛率应与理论阶数 $q$ 相匹配，这为代码正确且结果正在收敛到真实的连续解提供了强有力的证据。\n4.  **外推至连续统：** 一旦确定了收敛性，就可以对计算出的梯度序列使用理查森外推法，以产生一个在 $h=0$ 处极限的高阶估计。这个外推值 $g^\\ast$ 是物理灵敏度 $\\mathrm{d}J/\\mathrm{d}p$ 的最佳估计。这个过程还为该值提供了一个定量的误差估计。\n\n这四个步骤构成了一个鲁棒且完整的方案。我们现在对照这个框架来评估给定的选项。\n\n### 逐项分析\n\n**A. 构建一个具有固定细化比的网格细化序列（例如 $h, h/r, h/r^2$，其中 $r1$）。在每个网格上，求解 $R_h(u_h,p)=0$，并收紧非线性、线性和时间积分容差，以使求解器误差低于截断误差（使容差随 $h^q$ 缩放）。使用与 $R_h$ 和 $J_h$ 一致的离散伴随法计算 $g_h^{\\mathrm{adj}}$。独立地，在同一网格上使用复步长方法（采用一个与 $h$ 无关的小 $|\\varepsilon|$）或中心差分（通过步长扫描以确定一个截断误差和舍入误差达到平衡的 $\\varepsilon$ 平台区）来计算 $g_h^{\\mathrm{FD}}(\\varepsilon)$。对于每个 $h$，验证 $|g_h^{\\mathrm{adj}}-g_h^{\\mathrm{FD}}|$ 足够小；然后对 $g_h^{\\mathrm{adj}}$ 和 $g_h^{\\mathrm{FD}}$ 应用理查森外推法来估计共同的连续极限 $g^\\ast=\\lim_{h\\to 0} \\mathrm{d}J_h/\\mathrm{d}p$。将随 $h\\to 0$ 消失的差异归因于离散伪影，将随 $\\varepsilon$ 优化消失的差异归因于差分伪影，将持续存在的差异归因于伴随实现或建模不一致。报告 $g^\\ast$ 及其从观察到的 $h^q$ 衰减中估计出的不确定性。**\n\n此选项精确地描述了上面推导出的鲁棒方案。它解决了：\n-   通过随网格细化收紧容差来处理求解器误差。\n-   通过在每个网格上使用最佳实践（复步长或 $\\varepsilon$ 扫描）进行比较来处理有限差分误差和伴随验证。\n-   通过执行系统的网格细化研究来处理离散误差。\n-   通过使用理查森外推法找到连续极限 $g^\\ast$ 来估计物理灵敏度。\n-   系统的误差归因。\n此程序是计算科学中验证的黄金标准。\n\n**结论：正确**\n\n**B. 在一个单一的细网格（小 $h$）上，计算 $g_h^{\\mathrm{adj}}$ 和一个使用固定 $\\varepsilon$（例如，参数单位下的 $\\varepsilon=10^{-4}$）的前向有限差分 $g_h^{\\mathrm{FD}}(\\varepsilon)$。如果 $|g_h^{\\mathrm{adj}}-g_h^{\\mathrm{FD}}|/|g_h^{\\mathrm{FD}}|  5\\%$，则接受 $g_h^{\\mathrm{adj}}$ 为物理值；否则，收紧非线性求解器容差，直到差异降至 $5\\%$ 以下，然后接受。**\n\n该方案由于几个原因在科学上是不合理的：\n-   **单一网格：** 它没有试图量化或消除离散误差。结果本质上是依赖于网格的，不能声称是“物理的”。\n-   **任意参数：** 它使用一个固定的、任意的步长 $\\varepsilon$ 和一个任意的 $5\\%$ 的相对容差。这些选择没有正当理由。\n-   **错误的逻辑：** 它错误地假设任何大于 $5\\%$ 的差异都是由求解器容差引起的，并且可以通过收紧它们来“修复”。差异可能是由于伴随中的错误、$\\varepsilon$ 的选择不当，或者仅仅是模型的现实情况。调整参数以达到预设的目标不是科学验证。\n-   **次优方法：** 它使用前向差分，其截断误差（$\\mathcal{O}(\\varepsilon)$）比中心差分（$\\mathcal{O}(\\varepsilon^2)$）大。\n\n**结论：不正确**\n\n**C. 构建一个电池的粗糙代理模型，并使用蒙特卡洛方法在该代理模型上计算 $p$ 的基于方差的全局 Sobol 灵敏度指数。如果该代理模型对 $p$ 的一阶指数非零，并且在符号上与单一网格上的 $g_h^{\\mathrm{adj}}$ 定性一致，则接受伴随梯度为物理值；否则，断定数值伪影占主导地位。**\n\n该方案基于一个基本的概念错误：\n-   **局部灵敏度与全局灵敏度：** 它试图使用一个*全局*灵敏度度量（Sobol 指数）来验证一个*局部*灵敏度（在单一点的梯度 $\\mathrm{d}J/\\mathrm{d}p$），而全局灵敏度度量量化的是一个参数在其整个变化范围内的平均效应。这两个量度量的是不同的东西，不可直接比较。一个参数在某一点的局部灵敏度可以为零，但全局上很重要，反之亦然。\n-   **无意义的比较：** 一阶 Sobol 指数 $S_p$ 根据定义是非负的（$S_p \\ge 0$）。将其“符号”与一个可以是正、负或零的梯度的符号进行比较是无稽之谈。\n-   **代理模型和网格误差：** 该方案通过使用“粗糙代理模型”和“单一网格”使问题更加复杂，引入了未量化的代理模型误差和离散误差。\n\n**结论：不正确**\n\n**D. 将在最细可用网格上计算的 $g_h^{\\mathrm{adj}}$ 与在较粗网格上使用中心差分和固定小 $\\varepsilon$ 计算的 $g_{h/2}^{\\mathrm{FD}}$ 进行比较，同时对两次运行均保持默认求解器容差。如果两个数值在选定的容差范围内一致，则接受该结果为物理值；否则，选择幅度较小的那个，认为其受数值误差污染较少，并将其报告为物理灵敏度。**\n\n该方案是一系列临时且不正确的启发式方法的集合：\n-   **不一致的比较：** 它比较了在不同网格（$h$ vs. $h/2$）上用不同方法（$g^{\\mathrm{adj}}$ vs. $g^{\\mathrm{FD}}$）计算的量。这两个数值应该相等没有理论基础。验证需要在*相同*网格上比较不同方法。\n-   **未受控制的误差：** 它使用“默认求解器容差”和“固定小 $\\varepsilon$”，未能控制求解器和有限差分误差。\n-   **毫无根据的启发式方法：** “选择幅度较小的那个”的规则是完全任意的，在数值分析中没有根据。数值误差既可以增加也可以减少计算结果的幅度。\n\n**结论：不正确**",
            "answer": "$$\\boxed{A}$$"
        }
    ]
}