{
    "hands_on_practices": [
        {
            "introduction": "Model-based estimation in a digital Battery Management System (BMS) requires translating the continuous-time physics of a battery into discrete-time equations that a microprocessor can solve. This foundational exercise guides you through this crucial step. By deriving the exact discrete-time update for a single resistor-capacitor (RC) branch, a core component of many Equivalent Circuit Models (ECMs), you will practice applying linear systems theory to bridge the gap between physical differential equations and their implementation in code .",
            "id": "3896581",
            "problem": "Consider a single polarization branch of an Equivalent Circuit Model (ECM) used in a Battery Management System (BMS) for State of Charge (SOC) and State of Health (SOH) estimation. The polarization voltage state is denoted by $v_{p}(t)$, the branch resistance and capacitance are $R_{p}  0$ and $C_{p}  0$, respectively, and the applied current is $i(t)$, with the sign convention that positive $i(t)$ corresponds to discharge. The continuous-time dynamics of the polarization voltage are given by the linear time-invariant ordinary differential equation\n$$\n\\frac{d}{dt} v_{p}(t) = -\\frac{1}{R_{p} C_{p}}\\, v_{p}(t) + \\frac{1}{C_{p}}\\, i(t).\n$$\nLet the sampling period be $T_{s}  0$, and define sampling instants $t_{k} = k T_{s}$ for integer $k \\geq 0$. Assume a zero-order hold (ZOH) on the input current over each sampling interval, i.e., $i(t) = i_{k}$ for all $t \\in [t_{k}, t_{k+1})$. Using only fundamental properties of linear time-invariant systems and the matrix exponential, derive the exact discrete-time state transition that maps $v_{p,k} \\triangleq v_{p}(t_{k})$ and $i_{k}$ to $v_{p,k+1} \\triangleq v_{p}(t_{k+1})$ under the ZOH assumption. Express your final result as a single closed-form analytic expression in terms of $v_{p,k}$, $i_{k}$, $R_{p}$, $C_{p}$, and $T_{s}$. No numerical evaluation is required. Do not include physical units in your final expression. The final answer must be a single expression.",
            "solution": "The problem of deriving the exact discrete-time state transition for the given continuous-time system is determined to be valid. The problem is scientifically grounded in the principles of circuit theory and linear time-invariant (LTI) systems, is well-posed with sufficient information for a unique solution, and is expressed in objective, formal language. We may, therefore, proceed with the derivation.\n\nThe continuous-time dynamics of the polarization voltage $v_{p}(t)$ are given by the linear ordinary differential equation (ODE):\n$$\n\\frac{d}{dt} v_{p}(t) = -\\frac{1}{R_{p} C_{p}}\\, v_{p}(t) + \\frac{1}{C_{p}}\\, i(t)\n$$\nThis is a scalar LTI state-space model of the form $\\frac{d}{dt}x(t) = Ax(t) + Bu(t)$, where the state is $x(t) = v_{p}(t)$, the input is $u(t) = i(t)$, and the system matrices are the scalars:\n$$\nA = -\\frac{1}{R_{p} C_{p}}\n$$\n$$\nB = \\frac{1}{C_{p}}\n$$\nThe problem requires finding the relationship between the state at time $t_{k+1}$ and the state at time $t_k$, where $t_{k+1} = t_k + T_s$. The general solution to an LTI system over a time interval $[t_k, t_{k+1}]$ is given by the variation of parameters formula, which utilizes the matrix exponential (in this case, the scalar exponential):\n$$\nx(t_{k+1}) = e^{A(t_{k+1} - t_k)} x(t_k) + \\int_{t_k}^{t_{k+1}} e^{A(t_{k+1} - \\tau)} B u(\\tau) \\,d\\tau\n$$\nSubstituting the problem-specific variables and definitions $x(t_k) = v_{p,k}$, $u(\\tau) = i(\\tau)$, and $t_{k+1} - t_k = T_s$, we get:\n$$\nv_{p,k+1} = e^{A T_s} v_{p,k} + \\int_{t_k}^{t_{k+1}} e^{A(t_{k+1} - \\tau)} B i(\\tau) \\,d\\tau\n$$\nThe problem specifies a zero-order hold (ZOH) on the input current, meaning the current $i(t)$ is constant over the sampling interval, i.e., $i(t) = i_k$ for all $t \\in [t_{k}, t_{k+1})$. Since $B$ and $i_k$ are constant over the integration interval, they can be moved outside the integral:\n$$\nv_{p,k+1} = e^{A T_s} v_{p,k} + \\left( \\int_{t_k}^{t_{k+1}} e^{A(t_{k+1} - \\tau)} \\,d\\tau \\right) B i_k\n$$\nTo evaluate the integral, we perform a change of variables. Let $s = t_{k+1} - \\tau$. Then, $ds = -d\\tau$. The limits of integration change from $\\tau = t_k$ to $s = t_{k+1} - t_k = T_s$, and from $\\tau = t_{k+1}$ to $s = t_{k+1} - t_{k+1} = 0$. The integral becomes:\n$$\n\\int_{t_k}^{t_{k+1}} e^{A(t_{k+1} - \\tau)} \\,d\\tau = \\int_{T_s}^{0} e^{As} (-ds) = \\int_{0}^{T_s} e^{As} \\,ds\n$$\nThe integral of the exponential function is given by $\\int e^{As} ds = A^{-1}e^{As}$ for an invertible scalar or matrix $A$. Since $R_p  0$ and $C_p  0$, our scalar $A = -1/(R_p C_p)$ is non-zero and therefore invertible. Thus, we can evaluate the definite integral:\n$$\n\\int_{0}^{T_s} e^{As} \\,ds = \\left[ A^{-1} e^{As} \\right]_{0}^{T_s} = A^{-1} (e^{A T_s} - e^{A \\cdot 0}) = A^{-1} (e^{A T_s} - 1)\n$$\nSubstituting this result back into the expression for $v_{p,k+1}$:\n$$\nv_{p,k+1} = e^{A T_s} v_{p,k} + A^{-1} (e^{A T_s} - 1) B i_k\n$$\nThis is the general form for the exact discretization of a single-input LTI system under a ZOH. We now substitute the specific expressions for $A$, $B$, and $A^{-1}$:\n$$\nA = -\\frac{1}{R_{p} C_{p}}\n$$\n$$\nB = \\frac{1}{C_{p}}\n$$\n$$\nA^{-1} = -R_{p} C_{p}\n$$\nThe term multiplying $v_{p,k}$ is:\n$$\ne^{A T_s} = \\exp\\left(-\\frac{T_s}{R_p C_p}\\right)\n$$\nThe term multiplying $i_k$ is:\n$$\nA^{-1} (e^{A T_s} - 1) B = (-R_p C_p) \\left( \\exp\\left(-\\frac{T_s}{R_p C_p}\\right) - 1 \\right) \\left( \\frac{1}{C_p} \\right)\n$$\nSimplifying this coefficient gives:\n$$\n-R_p \\left( \\exp\\left(-\\frac{T_s}{R_p C_p}\\right) - 1 \\right) = R_p \\left( 1 - \\exp\\left(-\\frac{T_s}{R_p C_p}\\right) \\right)\n$$\nCombining these results, we obtain the final closed-form analytic expression for the discrete-time state transition:\n$$\nv_{p,k+1} = \\exp\\left(-\\frac{T_s}{R_p C_p}\\right) v_{p,k} + R_p \\left( 1 - \\exp\\left(-\\frac{T_s}{R_p C_p}\\right) \\right) i_k\n$$\nThis expression exactly maps the state $v_{p,k}$ and input $i_k$ at time step $k$ to the state $v_{p,k+1}$ at time step $k+1$.",
            "answer": "$$\n\\boxed{\\exp\\left(-\\frac{T_{s}}{R_{p} C_{p}}\\right) v_{p,k} + R_{p} \\left( 1 - \\exp\\left(-\\frac{T_{s}}{R_{p} C_{p}}\\right) \\right) i_{k}}\n$$"
        },
        {
            "introduction": "The Extended Kalman Filter (EKF) is a cornerstone of modern state estimation, enabling the fusion of sensor data with a non-linear model to produce reliable estimates of a battery's internal states. A critical step in the EKF algorithm is the linearization of the measurement model, which is accomplished by deriving the measurement Jacobian matrix. This practice challenges you to formulate this Jacobian for a comprehensive electro-thermal model, integrating measurements from multiple sensors to estimate not only the State of Charge (SOC) but also key State of Health (SOH) parameters and sensor biases .",
            "id": "3896602",
            "problem": "Consider a lithium-ion cell in a Battery Management System (BMS) employing an Extended Kalman Filter (EKF) for model-based State of Charge (SOC) and State of Health (SOH) estimation. The cell is described by a first-order Thevenin equivalent-circuit model coupled to a lumped thermal model. The state vector is defined as $$\\mathbf{x} = \\begin{pmatrix} z  v_{p}  T_{c}  T_{s}  R_{0}  b_{i} \\end{pmatrix}^{\\top},$$ where $z$ is the SOC ($0 \\le z \\le 1$), $v_{p}$ is the polarization voltage across the resistor-capacitor (RC) network, $T_{c}$ is the core temperature, $T_{s}$ is the surface temperature, $R_{0}$ is the ohmic resistance representing an SOH-dependent parameter, and $b_{i}$ is the current sensor bias. The EKF input is the measured current $$u = i_{m},$$ where the true current is related to the measured current by $$i = i_{m} - b_{i}.$$ The terminal voltage is given by $$V = \\mathrm{OCV}(z, T_{c}) - R_{0}\\,i - v_{p},$$ where $\\mathrm{OCV}(z, T_{c})$ denotes the Open Circuit Voltage (OCV) as a function of $z$ and $T_{c}$, assumed differentiable in each argument. The multi-sensor measurement vector combines voltage, current-derived SOC, and two temperatures as $$\\mathbf{y} = \\begin{pmatrix} V_{m} \\\\ T_{c,m} \\\\ T_{s,m} \\\\ z_{cc,m} \\end{pmatrix},$$ with the following measurement relations: \n- Terminal voltage sensor: $$V_{m} = \\mathrm{OCV}(z, T_{c}) - R_{0}\\,(u - b_{i}) - v_{p} + n_{v},$$ \n- Core temperature sensor: $$T_{c,m} = T_{c} + n_{Tc},$$ \n- Surface temperature sensor: $$T_{s,m} = T_{s} + n_{Ts},$$ \n- Coulomb-counted SOC sensor: $$z_{cc,m} = z + n_{z},$$ where $n_{v}$, $n_{Tc}$, $n_{Ts}$, and $n_{z}$ are zero-mean measurement noises. The nominal capacity $Q_{n}$ and Coulombic efficiency $\\eta$ are known constants used in the separate Coulomb counting process that generates $z_{cc,m}$ from $i_{m}$, but do not explicitly enter the measurement function other than through $z_{cc,m}$.\n\nStarting from the above physically grounded model and definitions, formulate the EKF measurement function $$\\mathbf{h}(\\mathbf{x}, u) = \\begin{pmatrix} h_{1}(\\mathbf{x},u) \\\\ h_{2}(\\mathbf{x},u) \\\\ h_{3}(\\mathbf{x},u) \\\\ h_{4}(\\mathbf{x},u) \\end{pmatrix}$$ that maps the state to the expected measurements, and derive the measurement Jacobian matrix $$\\mathbf{H}(\\mathbf{x},u) = \\frac{\\partial \\mathbf{h}}{\\partial \\mathbf{x}}.$$ Express your final answer as a single closed-form analytic matrix in terms of $z$, $T_{c}$, $v_{p}$, $R_{0}$, $b_{i}$, $u$, and symbolic partial derivatives of $\\mathrm{OCV}$ with respect to its arguments. Do not assume any specific parametric form for $\\mathrm{OCV}(z,T_{c})$. The final answer must be a single analytic expression. No rounding is required. Units are not required for the final expression.",
            "solution": "The Extended Kalman Filter (EKF) measurement model relates the state vector to the expected values of the measurements through a function $\\mathbf{h}(\\mathbf{x},u)$, with the measurement Jacobian $\\mathbf{H}(\\mathbf{x},u)$ defined as the matrix of partial derivatives of $\\mathbf{h}$ with respect to the state $\\mathbf{x}$. We begin from the fundamental definitions given.\n\nThe system employs a Thevenin equivalent-circuit model for the electrical domain. The terminal voltage $V$ satisfies \n$$V = \\mathrm{OCV}(z,T_{c}) - R_{0}\\,i - v_{p},$$ \nbased on Kirchhoff's Voltage Law applied to the series connection of the OCV source, the ohmic resistance $R_{0}$, and the RC polarization branch represented by the polarization voltage $v_{p}$. The true current $i$ is related to the measured current $i_{m}$ via the sensor bias state $b_{i}$:\n$$i = i_{m} - b_{i} = u - b_{i},$$\nwhere $u$ is chosen as the measured current input.\n\nThe thermal domain is represented by lumped temperatures $T_{c}$ and $T_{s}$, measured directly by their respective sensors. The multi-sensor fusion also leverages an auxiliary SOC measurement produced by Coulomb counting. Coulomb counting integrates the measured current to estimate SOC via the fundamental definition of SOC as normalized charge:\n$$\\frac{d z}{d t} = -\\frac{\\eta}{Q_{n}}\\, i,$$\nwhere $Q_{n}$ is the nominal capacity and $\\eta$ is the Coulombic efficiency. An external process (outside the EKF measurement function) integrates this to produce $z_{cc,m}$, which we treat as a direct measurement of $z$ corrupted by noise. Thus, in the EKF measurement equation, $z_{cc,m}$ maps to $z$.\n\nTherefore, the measurement function components are:\n- Terminal voltage measurement model (excluding explicit noise for the deterministic mapping):\n$$h_{1}(\\mathbf{x},u) = \\mathrm{OCV}(z, T_{c}) - R_{0}\\,(u - b_{i}) - v_{p}.$$\n- Core temperature measurement model:\n$$h_{2}(\\mathbf{x},u) = T_{c}.$$\n- Surface temperature measurement model:\n$$h_{3}(\\mathbf{x},u) = T_{s}.$$\n- Coulomb-counted SOC measurement model:\n$$h_{4}(\\mathbf{x},u) = z.$$\n\nWe now derive the measurement Jacobian $\\mathbf{H}(\\mathbf{x},u) = \\frac{\\partial \\mathbf{h}}{\\partial \\mathbf{x}}$. The state vector is $\\mathbf{x} = \\begin{pmatrix} z  v_{p}  T_{c}  T_{s}  R_{0}  b_{i} \\end{pmatrix}^{\\top}$, so we compute the partial derivatives of each $h_{i}$ with respect to each state component.\n\nFor $h_{1}(\\mathbf{x},u)$:\n- $\\frac{\\partial h_{1}}{\\partial z} = \\frac{\\partial\\, \\mathrm{OCV}(z,T_{c})}{\\partial z}$ by the chain rule applied to $\\mathrm{OCV}$.\n- $\\frac{\\partial h_{1}}{\\partial v_{p}} = -1$ because $h_{1}$ contains $-v_{p}$ linearly.\n- $\\frac{\\partial h_{1}}{\\partial T_{c}} = \\frac{\\partial\\, \\mathrm{OCV}(z,T_{c})}{\\partial T_{c}}$ by the chain rule.\n- $\\frac{\\partial h_{1}}{\\partial T_{s}} = 0$ since $h_{1}$ does not depend on $T_{s}$.\n- $\\frac{\\partial h_{1}}{\\partial R_{0}} = -(u - b_{i})$ because $h_{1}$ contains $-R_{0}(u - b_{i})$ linearly.\n- $\\frac{\\partial h_{1}}{\\partial b_{i}} = R_{0}$ because $\\frac{\\partial}{\\partial b_{i}}[-R_{0}(u - b_{i})] = R_{0}$.\n\nFor $h_{2}(\\mathbf{x},u) = T_{c}$:\n- $\\frac{\\partial h_{2}}{\\partial z} = 0$, $\\frac{\\partial h_{2}}{\\partial v_{p}} = 0$, $\\frac{\\partial h_{2}}{\\partial T_{c}} = 1$, $\\frac{\\partial h_{2}}{\\partial T_{s}} = 0$, $\\frac{\\partial h_{2}}{\\partial R_{0}} = 0$, $\\frac{\\partial h_{2}}{\\partial b_{i}} = 0$.\n\nFor $h_{3}(\\mathbf{x},u) = T_{s}$:\n- $\\frac{\\partial h_{3}}{\\partial z} = 0$, $\\frac{\\partial h_{3}}{\\partial v_{p}} = 0$, $\\frac{\\partial h_{3}}{\\partial T_{c}} = 0$, $\\frac{\\partial h_{3}}{\\partial T_{s}} = 1$, $\\frac{\\partial h_{3}}{\\partial R_{0}} = 0$, $\\frac{\\partial h_{3}}{\\partial b_{i}} = 0$.\n\nFor $h_{4}(\\mathbf{x},u) = z$:\n- $\\frac{\\partial h_{4}}{\\partial z} = 1$, $\\frac{\\partial h_{4}}{\\partial v_{p}} = 0$, $\\frac{\\partial h_{4}}{\\partial T_{c}} = 0$, $\\frac{\\partial h_{4}}{\\partial T_{s}} = 0$, $\\frac{\\partial h_{4}}{\\partial R_{0}} = 0$, $\\frac{\\partial h_{4}}{\\partial b_{i}} = 0$.\n\nCollecting these into the Jacobian matrix, with the measurement ordering $(V_{m}, T_{c,m}, T_{s,m}, z_{cc,m})$ and the state ordering $(z, v_{p}, T_{c}, T_{s}, R_{0}, b_{i})$, we obtain:\n$$\n\\mathbf{H}(\\mathbf{x},u) \n= \n\\begin{pmatrix}\n\\frac{\\partial\\, \\mathrm{OCV}(z,T_{c})}{\\partial z}  -1  \\frac{\\partial\\, \\mathrm{OCV}(z,T_{c})}{\\partial T_{c}}  0  -(u - b_{i})  R_{0} \\\\\n0  0  1  0  0  0 \\\\\n0  0  0  1  0  0 \\\\\n1  0  0  0  0  0\n\\end{pmatrix}.\n$$\n\nThis $\\mathbf{H}(\\mathbf{x},u)$ is the required EKF measurement Jacobian for the multi-sensor fusion of voltage, current-derived SOC, and temperature measurements under the given model assumptions. It is expressed in closed form with symbolic partial derivatives of $\\mathrm{OCV}$, does not assume any particular parameterization of $\\mathrm{OCV}$, and is consistent with the physically grounded measurement definitions.",
            "answer": "$$\\boxed{\n\\begin{pmatrix}\n\\frac{\\partial\\, \\mathrm{OCV}(z,T_{c})}{\\partial z}  -1  \\frac{\\partial\\, \\mathrm{OCV}(z,T_{c})}{\\partial T_{c}}  0  -(u - b_{i})  R_{0} \\\\\n0  0  1  0  0  0 \\\\\n0  0  0  1  0  0 \\\\\n1  0  0  0  0  0\n\\end{pmatrix}\n}$$"
        },
        {
            "introduction": "Developing a high-fidelity model is only the first step; validating its accuracy is equally critical to ensure the reliability of any BMS algorithm. This practice delves into the essential process of model validation through residual analysis. You will implement a portmanteau statistical test, such as the Ljung-Box test, to determine if the errors (residuals) between your model's predictions and measured data are random white noise, which signifies a well-fitted model, or if they contain uncaptured dynamics, indicating the model needs refinement .",
            "id": "3896580",
            "problem": "A Battery Management System (BMS) relies on model-based State of Charge (SOC) and State of Health (SOH) estimation, which requires validating the residuals of a fitted model for whiteness and serial independence. Consider an Equivalent Circuit Model (ECM) with a single Thevenin branch identified from Hybrid Pulse Power Characterization (HPPC) current–voltage data. The ECM uses a linear open-circuit voltage map and one resistor–capacitor polarization branch. The validation task is to assess the whiteness and independence of residuals using a portmanteau hypothesis test derived from first principles.\n\nAssume a single-cell ECM with the following elements. The terminal voltage $U(t)$ at discrete time index $k$ with sampling interval $\\Delta t$ satisfies\n$$U[k] = U_{\\mathrm{oc}}(z[k]) - R_0 I[k] - v_{\\mathrm{rc}}[k],$$\nwhere $I[k]$ is the current (positive for discharge), $R_0$ is the ohmic resistance, $v_{\\mathrm{rc}}[k]$ is the polarization branch voltage, and $U_{\\mathrm{oc}}(z)$ is the open-circuit voltage map as a function of SOC $z$. The SOC obeys coulomb counting,\n$$z[k] = z[k-1] - \\frac{I[k-1]\\Delta t}{Q \\cdot 3600},$$\nwith $Q$ being the nominal capacity in ampere-hours. The polarization branch obeys a first-order dynamic,\n$$v_{\\mathrm{rc}}[k] = a \\, v_{\\mathrm{rc}}[k-1] + b \\, I[k-1],$$\nfor constants $a$ and $b$ that depend on the resistor–capacitor branch and $\\Delta t$. The open-circuit voltage map is linear,\n$$U_{\\mathrm{oc}}(z) = U_{\\min} + k_{\\mathrm{oc}} z.$$\nThe residual sequence $r[k]$ is defined by\n$$r[k] = U_{\\mathrm{meas}}[k] - U[k],$$\nwhere $U_{\\mathrm{meas}}[k]$ is the measured terminal voltage.\n\nTo validate whiteness and serial independence of the residuals $r[k]$, design and implement a statistical test that is based on the sample autocorrelation function and asymptotic distribution results for portmanteau statistics. The hypothesis test should decide whether to reject the null hypothesis of white, serially independent residuals at a prescribed significance level. You must derive the test from the definitions of sample mean and sample autocorrelation, and use the known asymptotic distribution to compute a $p$-value.\n\nUse the following scientifically realistic and self-consistent parameterization, units, and signals. All physical quantities are to be expressed in International System of Units (SI) unless stated otherwise, and angles are not used.\n\n- Sampling interval: $\\Delta t = 1\\,\\mathrm{s}$.\n- Simulation length: $N = 1200$ samples.\n- Nominal capacity: $Q = 2.5\\,\\mathrm{Ah}$.\n- Ohmic resistance: $R_0 = 0.01\\,\\Omega$.\n- Polarization resistance: $R_1 = 0.015\\,\\Omega$.\n- Polarization time constant: $\\tau_1 = 100\\,\\mathrm{s}$.\n- Open-circuit voltage parameters: $U_{\\min} = 3.6\\,\\mathrm{V}$, $k_{\\mathrm{oc}} = 0.4\\,\\mathrm{V}$ per unit SOC.\n- Initial SOC: $z[0] = 0.8$ (dimensionless).\n- The Thevenin branch coefficients satisfy $a = \\exp\\!\\left(-\\frac{\\Delta t}{\\tau_1}\\right)$ and $b = R_1 \\left(1 - a\\right)$.\n\nConstruct an HPPC-like current profile $I[k]$ consisting of rest segments and pulses:\n- Begin with $60$ samples of rest $I[k] = 0\\,\\mathrm{A}$,\n- Then apply a discharge pulse of $10$ samples at $I[k] = 5\\,\\mathrm{A}$,\n- Follow with $60$ samples of rest,\n- Then a charge pulse of $10$ samples at $I[k] = -3\\,\\mathrm{A}$,\n- Repeat this pattern until reaching $N$ samples; truncate the last segment as needed.\n\nFrom this base, define the measured voltage sequences for three test cases:\n- Case A (ideal identification): $U_{\\mathrm{meas}}[k] = U[k]$. Residuals are exactly zero.\n- Case B (colored residual): $U_{\\mathrm{meas}}[k] = U[k] + A_{\\sin} \\sin\\!\\left(2\\pi f k \\Delta t\\right)$ with $A_{\\sin} = 0.03\\,\\mathrm{V}$ and $f = 0.02\\,\\mathrm{Hz}$.\n- Case C (white residual): $U_{\\mathrm{meas}}[k] = U[k] + \\epsilon[k]$ with $\\epsilon[k]$ an independent and identically distributed Gaussian sequence of mean zero and standard deviation $\\sigma = 0.01\\,\\mathrm{V}$. Use a fixed random seed for reproducibility.\n\nYour program must:\n- Simulate the ECM using the specified parameters and current profile,\n- Compute the residuals $r[k]$ for each case,\n- Implement a portmanteau test of serial independence (for example, a Ljung–Box-type test derived from first principles) using a maximum lag $h = 20$,\n- Evaluate the null hypothesis of white, serially independent residuals at significance level $\\alpha = 0.05$,\n- For residual sequences with negligible variance, treat them as white (return a $p$-value of $1$).\n\nYour test suite is the set of three cases A, B, and C described above. For each case, your program must produce a boolean indicating whether the null hypothesis is not rejected at the given $\\alpha$ (that is, whether the residuals are accepted as white and serially independent). The final output must be a single line containing a comma-separated Python list with three booleans enclosed in square brackets, in the order $[\\text{Case A}, \\text{Case B}, \\text{Case C}]$ (for example, $[{\\mathrm{True}},{\\mathrm{False}},{\\mathrm{True}}]$). No other text may be printed.",
            "solution": "The problem requires the design and implementation of a statistical test to validate the whiteness and serial independence of residuals from a battery Equivalent Circuit Model (ECM). This is a fundamental task in system identification, ensuring that a model has captured all systematic dynamics and that the remaining error is unpredictable noise. The solution involves three stages: simulating the ECM, defining and deriving the statistical test from first principles, and applying the test to the specified cases.\n\nFirst, we establish the mathematical model of the battery cell. The problem provides a first-order Thevenin ECM. The state of the system at discrete time index $k$ is described by the State of Charge (SOC), $z[k]$, and the polarization voltage, $v_{\\mathrm{rc}}[k]$. The state-update equations are given by:\n$$z[k] = z[k-1] - \\frac{I[k-1]\\Delta t}{Q \\cdot 3600}$$\n$$v_{\\mathrm{rc}}[k] = a \\, v_{\\mathrm{rc}}[k-1] + b \\, I[k-1]$$\nHere, $I[k]$ is the applied current at time $k$, $\\Delta t$ is the sampling interval, and $Q$ is the nominal capacity. The coefficients $a$ and $b$ are derived from the physical parameters of the polarization branch: $a = \\exp(-\\Delta t / \\tau_1)$ and $b = R_1 (1 - a)$, where $\\tau_1$ is the polarization time constant and $R_1$ is the polarization resistance. The SOC update equation represents coulomb counting, and the polarization voltage equation describes a first-order discrete-time response.\n\nThe model's output, the terminal voltage $U[k]$, is an algebraic function of the current state and the current input:\n$$U[k] = U_{\\mathrm{oc}}(z[k]) - R_0 I[k] - v_{\\mathrm{rc}}[k]$$\nwhere $R_0$ is the ohmic resistance and $U_{\\mathrm{oc}}(z[k])$ is the open-circuit voltage (OCV), modeled as a linear function of SOC:\n$$U_{\\mathrm{oc}}(z) = U_{\\min} + k_{\\mathrm{oc}} z$$\nTo simulate the model, we first generate the specified Hybrid Pulse Power Characterization (HPPC) current profile $I[k]$ for all time steps $k \\in [0, N-1]$, where $N=1200$. Then, starting with the initial conditions $z[0]=0.8$ and $v_{\\mathrm{rc}}[0]=0$ (assuming the cell starts in a rested state), we iteratively compute the states $z[k]$ and $v_{\\mathrm{rc}}[k]$ and the corresponding model voltage $U[k]$ for $k=1, \\dots, N-1$.\n\nThe core of the problem is the validation of the model's residuals, $r[k] = U_{\\mathrm{meas}}[k] - U[k]$, where $U_{\\mathrm{meas}}[k]$ is the measured voltage. The objective is to test the null hypothesis, $H_0$, that the residual sequence $r[k]$ is a white noise process. A white noise process is a sequence of uncorrelated random variables with a mean of zero and constant variance. If $H_0$ holds, the model is considered adequate.\n\nTo test for serial correlation, we use a portmanteau test based on the sample autocorrelation function (ACF). First, we compute the sample mean of the residuals:\n$$\\bar{r} = \\frac{1}{N} \\sum_{k=1}^{N} r[k]$$\nNext, we compute the sample autocovariance at lag $j$, $\\hat{\\gamma}_j$, and the corresponding sample autocorrelation, $\\hat{\\rho}_j$:\n$$\\hat{\\gamma}_j = \\frac{1}{N} \\sum_{k=j+1}^{N} (r[k] - \\bar{r})(r[k-j] - \\bar{r})$$\n$$\\hat{\\rho}_j = \\frac{\\hat{\\gamma}_j}{\\hat{\\gamma}_0}$$\nwhere $\\hat{\\gamma}_0$ is the sample variance of the residuals (normalized by $N$).\n\nThe Ljung-Box test provides a statistic, $Q_{\\mathrm{LB}}$, that aggregates the autocorrelations up to a maximum lag $h$:\n$$Q_{\\mathrm{LB}} = N(N+2) \\sum_{j=1}^{h} \\frac{\\hat{\\rho}_j^2}{N-j}$$\nUnder the null hypothesis $H_0$, the $Q_{\\mathrm{LB}}$ statistic is asymptotically distributed as a chi-squared ($\\chi^2$) random variable with $h$ degrees of freedom. For this problem, the maximum lag is specified as $h=20$.\n\nThe statistical decision is made by calculating the $p$-value, which is the probability of observing a test statistic at least as large as the one computed, assuming $H_0$ is true:\n$$p\\text{-value} = P(\\chi^2(h)  Q_{\\mathrm{LB}})$$\nWe compare this $p$-value to a pre-defined significance level, $\\alpha=0.05$. If the $p$-value is less than $\\alpha$, we reject the null hypothesis, concluding that the residuals are serially correlated (i.e., not white). If the $p$-value is greater than or equal to $\\alpha$, we do not reject the null hypothesis, and the residuals are accepted as being white and serially independent.\n\nThe procedure is applied to three cases:\n1.  **Case A (Ideal):** The residuals are $r[k] = 0$ for all $k$. The variance is zero. As per the problem's rule for sequences with negligible variance, these residuals are considered white. This corresponds to a $p$-value of $1$, and thus the null hypothesis is not rejected.\n2.  **Case B (Colored Residual):** The residuals are a deterministic sinusoidal signal, $r[k] = A_{\\sin} \\sin(2\\pi f k \\Delta t)$. Such a signal is highly autocorrelated. We expect the sample autocorrelations $\\hat{\\rho}_j$ to be large, leading to a large $Q_{\\mathrm{LB}}$ statistic and a very small $p$-value ($p  \\alpha$), causing the rejection of $H_0$.\n3.  **Case C (White Residual):** The residuals are an independent and identically distributed Gaussian sequence with mean zero. This is the canonical example of white noise. The Ljung-Box test is designed for this scenario, and we expect it to not reject the null hypothesis (i.e., $p \\geq \\alpha$).\n\nThe final program implements this entire workflow: it simulates the model, generates the residuals for each of the three cases, computes the Ljung-Box statistic and corresponding $p$-value, and returns a boolean indicating whether the null hypothesis is not rejected for each case.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import chi2\n\ndef portmanteau_test(residuals: np.ndarray, h: int, alpha: float) - bool:\n    \"\"\"\n    Performs a Ljung-Box portmanteau test for whiteness of a residual series.\n\n    Args:\n        residuals: The sequence of residuals to test.\n        h: The maximum lag for the test.\n        alpha: The significance level.\n\n    Returns:\n        True if the null hypothesis (residuals are white noise) is not rejected,\n        False otherwise.\n    \"\"\"\n    N = len(residuals)\n\n    # Per instruction: for negligible variance, treat as white.\n    if np.std(residuals)  1e-9:\n        # p-value is effectively 1, so null hypothesis is not rejected.\n        return True\n\n    r_bar = np.mean(residuals)\n    # Sample variance (autocovariance at lag 0)\n    gamma_0 = np.sum((residuals - r_bar)**2) / N\n    \n    # This case should be covered by the std check, but for robustness:\n    if gamma_0 == 0:\n        return True\n\n    rho_sq = np.zeros(h)\n    for j in range(1, h + 1):\n        # Sample autocovariance at lag j\n        gamma_j = np.sum((residuals[j:] - r_bar) * (residuals[:-j] - r_bar)) / N\n        rho_j = gamma_j / gamma_0\n        rho_sq[j - 1] = rho_j**2\n\n    # Ljung-Box statistic\n    denominators = N - np.arange(1, h + 1)\n    Q_LB = N * (N + 2) * np.sum(rho_sq / denominators)\n    \n    # Degrees of freedom for the chi-squared distribution is h\n    dof = h\n    \n    # The p-value is the probability of observing a value = Q_LB\n    # from a chi-squared distribution with 'dof' degrees of freedom.\n    # We use the survival function (1 - CDF).\n    p_value = chi2.sf(Q_LB, dof)\n    \n    # Do not reject the null hypothesis if p_value is = alpha\n    return p_value = alpha\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation and hypothesis tests.\n    \"\"\"\n    # Model parameters\n    dt = 1.0  # s\n    N = 1200 # samples\n    Q = 2.5   # Ah\n    R0 = 0.01 # Ohm\n    R1 = 0.015 # Ohm\n    tau1 = 100.0 # s\n    U_min = 3.6  # V\n    k_oc = 0.4   # V/SOC\n    z0 = 0.8  # dimensionless\n\n    # Test parameters\n    h = 20    # max lag for portmanteau test\n    alpha = 0.05 # significance level\n\n    # Derived model parameters\n    a = np.exp(-dt / tau1)\n    b = R1 * (1.0 - a)\n\n    # Generate HPPC-like current profile\n    I = np.zeros(N)\n    pattern = np.concatenate([\n        np.zeros(60),          # Rest\n        np.full(10, 5.0),      # Discharge pulse\n        np.zeros(60),          # Rest\n        np.full(10, -3.0)      # Charge pulse\n    ])\n    len_pattern = len(pattern)\n    num_repeats = N // len_pattern\n    I[:num_repeats * len_pattern] = np.tile(pattern, num_repeats)\n    remaining_len = N % len_pattern\n    if remaining_len  0:\n        I[num_repeats * len_pattern:] = pattern[:remaining_len]\n\n    # Simulate the base ECM to get the model voltage U[k]\n    z = np.zeros(N)\n    v_rc = np.zeros(N)\n    U_model = np.zeros(N)\n    \n    # Initial conditions\n    z[0] = z0\n    v_rc[0] = 0.0  # Assume starting from a rested state\n    U_oc_k = U_min + k_oc * z[0]\n    U_model[0] = U_oc_k - R0 * I[0] - v_rc[0]\n\n    for k in range(1, N):\n        # State updates (depend on k-1)\n        z[k] = z[k-1] - (I[k-1] * dt) / (Q * 3600.0)\n        v_rc[k] = a * v_rc[k-1] + b * I[k-1]\n        \n        # Output equation (depends on state at k and input at k)\n        U_oc_k = U_min + k_oc * z[k]\n        U_model[k] = U_oc_k - R0 * I[k] - v_rc[k]\n\n    # --- Test Cases ---\n    \n    # Case A: Ideal identification (zero residuals)\n    residuals_A = U_model - U_model # Exactly zero\n\n    # Case B: Colored residual (sinusoidal error)\n    t = np.arange(N) * dt\n    A_sin = 0.03 # V\n    f_sin = 0.02 # Hz\n    sin_error = A_sin * np.sin(2 * np.pi * f_sin * t)\n    U_meas_B = U_model + sin_error\n    residuals_B = U_meas_B - U_model\n\n    # Case C: White residual (Gaussian noise)\n    rng = np.random.default_rng(seed=42) # Fixed seed for reproducibility\n    sigma_noise = 0.01 # V\n    white_error = rng.normal(loc=0.0, scale=sigma_noise, size=N)\n    U_meas_C = U_model + white_error\n    residuals_C = U_meas_C - U_model\n\n    test_cases_residuals = [residuals_A, residuals_B, residuals_C]\n    \n    results = []\n    for r in test_cases_residuals:\n        # returns True if null hypothesis is NOT rejected (i.e., accepted as white)\n        is_white = portmanteau_test(r, h, alpha)\n        results.append(is_white)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}