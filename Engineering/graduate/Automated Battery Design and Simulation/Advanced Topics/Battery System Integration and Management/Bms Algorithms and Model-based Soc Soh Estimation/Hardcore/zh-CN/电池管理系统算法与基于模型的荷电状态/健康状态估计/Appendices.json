{
    "hands_on_practices": [
        {
            "introduction": "电池的物理动态通常由连续时间微分方程描述，但电池管理系统（BMS）中的微控制器在离散时间步长下运行。因此，将连续时间模型精确地转换为离散时间形式，是实现高保真度仿真和状态估计的关键第一步。本练习 () 将指导您推导等效电路模型（ECM）中一个基本构建模块——RC电路的精确离散时间状态转移方程，这对于确保算法的准确性至关重要。",
            "id": "3896581",
            "problem": "考虑一个在电池管理系统 (BMS) 中用于估算荷电状态 (SOC) 和健康状态 (SOH) 的等效电路模型 (ECM) 的单个极化支路。极化电压状态表示为 $v_{p}(t)$，支路电阻和电容分别为 $R_{p} > 0$ 和 $C_{p} > 0$，施加的电流为 $i(t)$，其符号约定为正的 $i(t)$ 对应于放电。极化电压的连续时间动态特性由以下线性时不变常微分方程给出\n$$\n\\frac{d}{dt} v_{p}(t) = -\\frac{1}{R_{p} C_{p}}\\, v_{p}(t) + \\frac{1}{C_{p}}\\, i(t).\n$$\n设采样周期为 $T_{s} > 0$，并为整数 $k \\geq 0$ 定义采样时刻 $t_{k} = k T_{s}$。假设在每个采样区间上对输入电流使用零阶保持器 (ZOH)，即对于所有 $t \\in [t_{k}, t_{k+1})$，有 $i(t) = i_{k}$。仅使用线性时不变系统的基本性质和矩阵指数，在 ZOH 假设下，推导将 $v_{p,k} \\triangleq v_{p}(t_{k})$ 和 $i_{k}$ 映射到 $v_{p,k+1} \\triangleq v_{p}(t_{k+1})$ 的精确离散时间状态转移。将您的最终结果表示为关于 $v_{p,k}$、$i_{k}$、$R_{p}$、$C_{p}$ 和 $T_{s}$ 的单个闭式解析表达式。无需进行数值计算。最终表达式中不要包含物理单位。最终答案必须是单个表达式。",
            "solution": "推导给定连续时间系统的精确离散时间状态转移这一问题被确定是有效的。该问题基于电路理论和线性时不变 (LTI) 系统的原理，是适定的，有充分的信息可以得到唯一解，并以客观、正式的语言表述。因此，我们可以进行推导。\n\n极化电压 $v_{p}(t)$ 的连续时间动态特性由以下线性常微分方程 (ODE) 给出：\n$$\n\\frac{d}{dt} v_{p}(t) = -\\frac{1}{R_{p} C_{p}}\\, v_{p}(t) + \\frac{1}{C_{p}}\\, i(t)\n$$\n这是一个形式为 $\\frac{d}{dt}x(t) = Ax(t) + Bu(t)$ 的标量 LTI 状态空间模型，其中状态为 $x(t) = v_{p}(t)$，输入为 $u(t) = i(t)$，系统矩阵为以下标量：\n$$\nA = -\\frac{1}{R_{p} C_{p}}\n$$\n$$\nB = \\frac{1}{C_{p}}\n$$\n该问题要求找到时刻 $t_{k+1}$ 的状态与时刻 $t_k$ 的状态之间的关系，其中 $t_{k+1} = t_k + T_s$。LTI 系统在时间区间 $[t_k, t_{k+1}]$ 上的通解由常数变易法公式给出，该公式利用了矩阵指数（在本例中为标量指数）：\n$$\nx(t_{k+1}) = e^{A(t_{k+1} - t_k)} x(t_k) + \\int_{t_k}^{t_{k+1}} e^{A(t_{k+1} - \\tau)} B u(\\tau) \\,d\\tau\n$$\n代入问题特定的变量和定义 $x(t_k) = v_{p,k}$、$u(\\tau) = i(\\tau)$ 和 $t_{k+1} - t_k = T_s$，我们得到：\n$$\nv_{p,k+1} = e^{A T_s} v_{p,k} + \\int_{t_k}^{t_{k+1}} e^{A(t_{k+1} - \\tau)} B i(\\tau) \\,d\\tau\n$$\n问题指明对输入电流使用零阶保持器 (ZOH)，意味着电流 $i(t)$ 在采样区间内是恒定的，即对于所有 $t \\in [t_{k}, t_{k+1})$，有 $i(t) = i_k$。由于 $B$ 和 $i_k$ 在积分区间内是常数，它们可以被移到积分号外面：\n$$\nv_{p,k+1} = e^{A T_s} v_{p,k} + \\left( \\int_{t_k}^{t_{k+1}} e^{A(t_{k+1} - \\tau)} \\,d\\tau \\right) B i_k\n$$\n为了计算该积分，我们进行变量替换。令 $s = t_{k+1} - \\tau$。那么，$ds = -d\\tau$。积分上下限从 $\\tau = t_k$ 变为 $s = t_{k+1} - t_k = T_s$，从 $\\tau = t_{k+1}$ 变为 $s = t_{k+1} - t_{k+1} = 0$。该积分变为：\n$$\n\\int_{t_k}^{t_{k+1}} e^{A(t_{k+1} - \\tau)} \\,d\\tau = \\int_{T_s}^{0} e^{As} (-ds) = \\int_{0}^{T_s} e^{As} \\,ds\n$$\n对于一个可逆的标量或矩阵 $A$，指数函数的积分为 $\\int e^{As} ds = A^{-1}e^{As}$。由于 $R_p > 0$ 且 $C_p > 0$，我们的标量 $A = -1/(R_p C_p)$ 是非零的，因此是可逆的。因此，我们可以计算该定积分：\n$$\n\\int_{0}^{T_s} e^{As} \\,ds = \\left[ A^{-1} e^{As} \\right]_{0}^{T_s} = A^{-1} (e^{A T_s} - e^{A \\cdot 0}) = A^{-1} (e^{A T_s} - 1)\n$$\n将此结果代回 $v_{p,k+1}$ 的表达式中：\n$$\nv_{p,k+1} = e^{A T_s} v_{p,k} + A^{-1} (e^{A T_s} - 1) B i_k\n$$\n这是在 ZOH 条件下单输入 LTI 系统精确离散化的一般形式。现在我们代入 $A$、$B$ 和 $A^{-1}$ 的具体表达式：\n$$\nA = -\\frac{1}{R_{p} C_{p}}\n$$\n$$\nB = \\frac{1}{C_{p}}\n$$\n$$\nA^{-1} = -R_{p} C_{p}\n$$\n乘以 $v_{p,k}$ 的项是：\n$$\ne^{A T_s} = \\exp\\left(-\\frac{T_s}{R_p C_p}\\right)\n$$\n乘以 $i_k$ 的项是：\n$$\nA^{-1} (e^{A T_s} - 1) B = (-R_p C_p) \\left( \\exp\\left(-\\frac{T_s}{R_p C_p}\\right) - 1 \\right) \\left( \\frac{1}{C_p} \\right)\n$$\n化简该系数可得：\n$$\n-R_p \\left( \\exp\\left(-\\frac{T_s}{R_p C_p}\\right) - 1 \\right) = R_p \\left( 1 - \\exp\\left(-\\frac{T_s}{R_p C_p}\\right) \\right)\n$$\n综合这些结果，我们得到离散时间状态转移的最终闭式解析表达式：\n$$\nv_{p,k+1} = \\exp\\left(-\\frac{T_s}{R_p C_p}\\right) v_{p,k} + R_p \\left( 1 - \\exp\\left(-\\frac{T_s}{R_p C_p}\\right) \\right) i_k\n$$\n该表达式精确地将时间步 $k$ 的状态 $v_{p,k}$ 和输入 $i_k$ 映射到时间步 $k+1$ 的状态 $v_{p,k+1}$。",
            "answer": "$$\n\\boxed{\\exp\\left(-\\frac{T_{s}}{R_{p} C_{p}}\\right) v_{p,k} + R_{p} \\left( 1 - \\exp\\left(-\\frac{T_{s}}{R_{p} C_{p}}\\right) \\right) i_{k}}\n$$"
        },
        {
            "introduction": "从实验数据中辨识出电池模型的参数后，我们必须验证其准确性，以确保它能可靠地预测电池行为。本练习 () 介绍了一种强大的统计方法——Ljung-Box检验，用于分析模型的预测误差（即残差）。通过编程实现该检验并确认残差序列具有随机白噪声的特性，我们可以确信模型已经捕捉了电池的主要动态特性，为后续的SOC和SOH估计算法奠定了坚实基础。",
            "id": "3896580",
            "problem": "电池管理系统（BMS）依赖于基于模型的荷电状态（SOC）和健康状态（SOH）估计，这需要验证拟合模型的残差是否具有白性和序列独立性。考虑一个具有单戴维南支路的等效电路模型（ECM），该模型通过混合脉冲功率特性（HPPC）的电流-电压数据进行辨识。该ECM使用线性的开路电压映射和一个电阻-电容极化支路。验证任务是使用从第一性原理推导出的综合假设检验来评估残差的白性和独立性。\n\n假设单个电芯的ECM包含以下元件。在离散时间索引 $k$ 处，端电压 $U(t)$ 满足\n$$U[k] = U_{\\mathrm{oc}}(z[k]) - R_0 I[k] - v_{\\mathrm{rc}}[k],$$\n其中 $I[k]$ 是电流（放电为正），$R_0$ 是欧姆内阻，$v_{\\mathrm{rc}}[k]$ 是极化支路电压，$U_{\\mathrm{oc}}(z)$ 是作为SOC $z$ 函数的开路电压映射。SOC遵循库仑计数法则，\n$$z[k] = z[k-1] - \\frac{I[k-1]\\Delta t}{Q \\cdot 3600},$$\n其中 $Q$ 是以安时为单位的标称容量。极化支路遵循一阶动态特性，\n$$v_{\\mathrm{rc}}[k] = a \\, v_{\\mathrm{rc}}[k-1] + b \\, I[k-1],$$\n对于常数 $a$ 和 $b$，其值取决于电阻-电容支路和 $\\Delta t$。开路电压映射是线性的，\n$$U_{\\mathrm{oc}}(z) = U_{\\min} + k_{\\mathrm{oc}} z.$$\n残差序列 $r[k]$ 定义为\n$$r[k] = U_{\\mathrm{meas}}[k] - U[k],$$\n其中 $U_{\\mathrm{meas}}[k]$ 是测量的端电压。\n\n为了验证残差 $r[k]$ 的白性和序列独立性，请设计并实现一个基于样本自相关函数和综合统计量的渐近分布结果的统计检验。该假设检验应在给定的显著性水平下，决定是否拒绝残差为白色、序列独立的零假设。您必须从样本均值和样本自相关的定义出发推导此检验，并使用已知的渐近分布来计算 $p$ 值。\n\n请使用以下科学上真实且自洽的参数化、单位和信号。除非另有说明，所有物理量均以国际单位制（SI）表示，且不使用角度。\n\n- 采样间隔：$\\Delta t = 1\\,\\mathrm{s}$。\n- 仿真长度：$N = 1200$ 个样本。\n- 标称容量：$Q = 2.5\\,\\mathrm{Ah}$。\n- 欧姆内阻：$R_0 = 0.01\\,\\Omega$。\n- 极化电阻：$R_1 = 0.015\\,\\Omega$。\n- 极化时间常数：$\\tau_1 = 100\\,\\mathrm{s}$。\n- 开路电压参数：$U_{\\min} = 3.6\\,\\mathrm{V}$，$k_{\\mathrm{oc}} = 0.4\\,\\mathrm{V}$ 每单位SOC。\n- 初始SOC：$z[0] = 0.8$ (无量纲)。\n- 戴维南支路系数满足 $a = \\exp\\!\\left(-\\frac{\\Delta t}{\\tau_1}\\right)$ 和 $b = R_1 \\left(1 - a\\right)$。\n\n构建一个类似HPPC的电流曲线 $I[k]$，包含静置段和脉冲：\n- 以 $60$ 个样本的静置 $I[k] = 0\\,\\mathrm{A}$ 开始，\n- 然后施加一个 $10$ 个样本的放电脉冲，电流为 $I[k] = 5\\,\\mathrm{A}$，\n- 接着是 $60$ 个样本的静置，\n- 然后是一个 $10$ 个样本的充电脉冲，电流为 $I[k] = -3\\,\\mathrm{A}$，\n- 重复此模式直至达到 $N$ 个样本；根据需要截断最后一段。\n\n基于此，定义三个测试案例的测量电压序列：\n- 案例A（理想辨识）：$U_{\\mathrm{meas}}[k] = U[k]$。残差完全为零。\n- 案例B（有色残差）：$U_{\\mathrm{meas}}[k] = U[k] + A_{\\sin} \\sin\\!\\left(2\\pi f k \\Delta t\\right)$，其中 $A_{\\sin} = 0.03\\,\\mathrm{V}$，$f = 0.02\\,\\mathrm{Hz}$。\n- 案例C（白色残差）：$U_{\\mathrm{meas}}[k] = U[k] + \\epsilon[k]$，其中 $\\epsilon[k]$ 是一个均值为零、标准差为 $\\sigma = 0.01\\,\\mathrm{V}$ 的独立同分布高斯序列。使用固定的随机种子以保证可复现性。\n\n您的程序必须：\n- 使用指定的参数和电流曲线仿真ECM，\n- 计算每种情况下的残差 $r[k]$，\n- 使用最大延迟 $h = 20$ 实现一个序列独立性的综合检验（例如，一个从第一性原理推导的Ljung-Box型检验），\n- 在显著性水平 $\\alpha = 0.05$ 下评估残差为白色、序列独立的零假设，\n- 对于方差可忽略的残差序列，将其视为白色（返回 $p$ 值为 $1$）。\n\n您的测试套件是上述描述的三个案例A、B和C的集合。对于每个案例，您的程序必须生成一个布尔值，表示在给定的 $\\alpha$ 水平下是否不拒绝零假设（即，残差是否被接受为白色和序列独立的）。最终输出必须是单行文本，包含一个逗号分隔的Python列表，其中有三个布尔值，并用方括号括起，顺序为 $[\\text{案例 A}, \\text{案例 B}, \\text{案例 C}]$（例如，`[True,False,True]`）。不得打印任何其他文本。",
            "solution": "该问题要求设计并实现一个统计检验，用以验证电池等效电路模型（ECM）残差的白性和序列独立性。这是系统辨识中的一项基本任务，旨在确保模型已捕获所有系统性动态，且剩余误差是不可预测的噪声。解决方案包括三个阶段：仿真ECM、从第一性原理定义和推导统计检验、以及将该检验应用于指定的案例。\n\n首先，我们建立电池单元的数学模型。问题提供了一个一阶戴维南ECM。在离散时间索引 $k$ 处，系统的状态由荷电状态（SOC）$z[k]$ 和极化电压 $v_{\\mathrm{rc}}[k]$ 描述。状态更新方程由下式给出：\n$$z[k] = z[k-1] - \\frac{I[k-1]\\Delta t}{Q \\cdot 3600}$$\n$$v_{\\mathrm{rc}}[k] = a \\, v_{\\mathrm{rc}}[k-1] + b \\, I[k-1]$$\n此处，$I[k]$ 是在时间 $k$ 施加的电流，$\\Delta t$ 是采样间隔，$Q$ 是标称容量。系数 $a$ 和 $b$ 从极化支路的物理参数推导得出：$a = \\exp(-\\Delta t / \\tau_1)$ 和 $b = R_1 (1 - a)$，其中 $\\tau_1$ 是极化时间常数，$R_1$ 是极化电阻。SOC更新方程代表库仑计数，而极化电压方程描述了一阶离散时间响应。\n\n模型的输出，即端电压 $U[k]$，是当前状态和当前输入的代数函数：\n$$U[k] = U_{\\mathrm{oc}}(z[k]) - R_0 I[k] - v_{\\mathrm{rc}}[k]$$\n其中 $R_0$ 是欧姆内阻，$U_{\\mathrm{oc}}(z[k])$ 是开路电压（OCV），建模为SOC的线性函数：\n$$U_{\\mathrm{oc}}(z) = U_{\\min} + k_{\\mathrm{oc}} z$$\n为了仿真该模型，我们首先生成指定的混合脉冲功率特性（HPPC）电流曲线 $I[k]$，覆盖所有时间步长 $k \\in [0, N-1]$，其中 $N=1200$。然后，从初始条件 $z[0]=0.8$ 和 $v_{\\mathrm{rc}}[0]=0$（假设电芯从静置状态开始）出发，我们迭代计算状态 $z[k]$ 和 $v_{\\mathrm{rc}}[k]$ 以及相应的模型电压 $U[k]$，其中 $k=1, \\dots, N-1$。\n\n问题的核心是验证模型的残差 $r[k] = U_{\\mathrm{meas}}[k] - U[k]$，其中 $U_{\\mathrm{meas}}[k]$ 是测量的电压。目标是检验零假设 $H_0$，即残差序列 $r[k]$ 是一个白噪声过程。白噪声过程是一个均值为零、方差恒定的不相关随机变量序列。如果 $H_0$ 成立，则认为该模型是充分的。\n\n为了检验序列相关性，我们使用基于样本自相关函数（ACF）的综合检验。首先，我们计算残差的样本均值：\n$$\\bar{r} = \\frac{1}{N} \\sum_{k=1}^{N} r[k]$$\n接下来，我们计算延迟为 $j$ 时的样本自协方差 $\\hat{\\gamma}_j$ 和相应的样本自相关 $\\hat{\\rho}_j$：\n$$\\hat{\\gamma}_j = \\frac{1}{N} \\sum_{k=j+1}^{N} (r[k] - \\bar{r})(r[k-j] - \\bar{r})$$\n$$\\hat{\\rho}_j = \\frac{\\hat{\\gamma}_j}{\\hat{\\gamma}_0}$$\n其中 $\\hat{\\gamma}_0$ 是残差的样本方差（由 $N$ 归一化）。\n\nLjung-Box检验提供了一个统计量 $Q_{\\mathrm{LB}}$，它汇总了直到最大延迟 $h$ 的所有自相关：\n$$Q_{\\mathrm{LB}} = N(N+2) \\sum_{j=1}^{h} \\frac{\\hat{\\rho}_j^2}{N-j}$$\n在零假设 $H_0$ 下，$Q_{\\mathrm{LB}}$ 统计量渐近服从自由度为 $h$ 的卡方（$\\chi^2$）分布。对于本问题，最大延迟指定为 $h=20$。\n\n通过计算 $p$ 值来做出统计决策，该值是在假设 $H_0$ 为真的前提下，观测到至少与计算出的检验统计量一样大的值的概率：\n$$p\\text{-值} = P(\\chi^2(h) > Q_{\\mathrm{LB}})$$\n我们将此 $p$ 值与预定义的显著性水平 $\\alpha=0.05$ 进行比较。如果 $p$ 值小于 $\\alpha$，我们拒绝零假设，结论是残差存在序列相关（即非白噪声）。如果 $p$ 值大于或等于 $\\alpha$，我们不拒绝零假设，并接受残差为白色且序列独立。\n\n此过程应用于三个案例：\n1.  **案例A（理想情况）：** 残差对于所有 $k$ 均为 $r[k] = 0$。方差为零。根据问题对可忽略方差序列的规定，这些残差被认为是白噪声。这对应于 $p$ 值为1，因此不拒绝零假设。\n2.  **案例B（有色残差）：** 残差是一个确定性的正弦信号，$r[k] = A_{\\sin} \\sin(2\\pi f k \\Delta t)$。这种信号具有高度自相关性。我们预期样本自相关 $\\hat{\\rho}_j$ 会很大，从而导致一个大的 $Q_{\\mathrm{LB}}$ 统计量和一个非常小的 $p$ 值（$p  \\alpha$），导致拒绝 $H_0$。\n3.  **案例C（白色残差）：** 残差是一个均值为零的独立同分布高斯序列。这是白噪声的典型例子。Ljung-Box检验就是为这种情况设计的，我们预期它不会拒绝零假设（即 $p \\geq \\alpha$）。\n\n最终的程序实现了这整个工作流程：它仿真模型，为三个案例中的每一个生成残差，计算Ljung-Box统计量和相应的 $p$ 值，并为每个案例返回一个布尔值，指示是否不拒绝零假设。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import chi2\n\ndef portmanteau_test(residuals: np.ndarray, h: int, alpha: float) -> bool:\n    \"\"\"\n    Performs a Ljung-Box portmanteau test for whiteness of a residual series.\n\n    Args:\n        residuals: The sequence of residuals to test.\n        h: The maximum lag for the test.\n        alpha: The significance level.\n\n    Returns:\n        True if the null hypothesis (residuals are white noise) is not rejected,\n        False otherwise.\n    \"\"\"\n    N = len(residuals)\n\n    # Per instruction: for negligible variance, treat as white.\n    if np.std(residuals)  1e-9:\n        # p-value is effectively 1, so null hypothesis is not rejected.\n        return True\n\n    r_bar = np.mean(residuals)\n    # Sample variance (autocovariance at lag 0)\n    gamma_0 = np.sum((residuals - r_bar)**2) / N\n    \n    # This case should be covered by the std check, but for robustness:\n    if gamma_0 == 0:\n        return True\n\n    rho_sq = np.zeros(h)\n    for j in range(1, h + 1):\n        # Sample autocovariance at lag j\n        gamma_j = np.sum((residuals[j:] - r_bar) * (residuals[:-j] - r_bar)) / N\n        rho_j = gamma_j / gamma_0\n        rho_sq[j - 1] = rho_j**2\n\n    # Ljung-Box statistic\n    denominators = N - np.arange(1, h + 1)\n    Q_LB = N * (N + 2) * np.sum(rho_sq / denominators)\n    \n    # Degrees of freedom for the chi-squared distribution is h\n    dof = h\n    \n    # The p-value is the probability of observing a value >= Q_LB\n    # from a chi-squared distribution with 'dof' degrees of freedom.\n    # We use the survival function (1 - CDF).\n    p_value = chi2.sf(Q_LB, dof)\n    \n    # Do not reject the null hypothesis if p_value is >= alpha\n    return p_value >= alpha\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation and hypothesis tests.\n    \"\"\"\n    # Model parameters\n    dt = 1.0  # s\n    N = 1200 # samples\n    Q = 2.5   # Ah\n    R0 = 0.01 # Ohm\n    R1 = 0.015 # Ohm\n    tau1 = 100.0 # s\n    U_min = 3.6  # V\n    k_oc = 0.4   # V/SOC\n    z0 = 0.8  # dimensionless\n\n    # Test parameters\n    h = 20    # max lag for portmanteau test\n    alpha = 0.05 # significance level\n\n    # Derived model parameters\n    a = np.exp(-dt / tau1)\n    b = R1 * (1.0 - a)\n\n    # Generate HPPC-like current profile\n    I = np.zeros(N)\n    pattern = np.concatenate([\n        np.zeros(60),          # Rest\n        np.full(10, 5.0),      # Discharge pulse\n        np.zeros(60),          # Rest\n        np.full(10, -3.0)      # Charge pulse\n    ])\n    len_pattern = len(pattern)\n    num_repeats = N // len_pattern\n    I[:num_repeats * len_pattern] = np.tile(pattern, num_repeats)\n    remaining_len = N % len_pattern\n    if remaining_len > 0:\n        I[num_repeats * len_pattern:] = pattern[:remaining_len]\n\n    # Simulate the base ECM to get the model voltage U[k]\n    z = np.zeros(N)\n    v_rc = np.zeros(N)\n    U_model = np.zeros(N)\n    \n    # Initial conditions\n    z[0] = z0\n    v_rc[0] = 0.0  # Assume starting from a rested state\n    U_oc_k = U_min + k_oc * z[0]\n    U_model[0] = U_oc_k - R0 * I[0] - v_rc[0]\n\n    for k in range(1, N):\n        # State updates (depend on k-1)\n        z[k] = z[k-1] - (I[k-1] * dt) / (Q * 3600.0)\n        v_rc[k] = a * v_rc[k-1] + b * I[k-1]\n        \n        # Output equation (depends on state at k and input at k)\n        U_oc_k = U_min + k_oc * z[k]\n        U_model[k] = U_oc_k - R0 * I[k] - v_rc[k]\n\n    # --- Test Cases ---\n    \n    # Case A: Ideal identification (zero residuals)\n    residuals_A = U_model - U_model # Exactly zero\n\n    # Case B: Colored residual (sinusoidal error)\n    t = np.arange(N) * dt\n    A_sin = 0.03 # V\n    f_sin = 0.02 # Hz\n    sin_error = A_sin * np.sin(2 * np.pi * f_sin * t)\n    U_meas_B = U_model + sin_error\n    residuals_B = U_meas_B - U_model\n\n    # Case C: White residual (Gaussian noise)\n    rng = np.random.default_rng(seed=42) # Fixed seed for reproducibility\n    sigma_noise = 0.01 # V\n    white_error = rng.normal(loc=0.0, scale=sigma_noise, size=N)\n    U_meas_C = U_model + white_error\n    residuals_C = U_meas_C - U_model\n\n    test_cases_residuals = [residuals_A, residuals_B, residuals_C]\n    \n    results = []\n    for r in test_cases_residuals:\n        # returns True if null hypothesis is NOT rejected (i.e., accepted as white)\n        is_white = portmanteau_test(r, h, alpha)\n        results.append(is_white)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "即使拥有完美的单体电池模型，在将其应用于由多个电池组成的电池包时，也会因电芯之间的不一致性而出现新的挑战。本练习 () 深入探讨了这一实际问题，要求您通过编程量化当使用简化的“平均电芯”模型时所产生的SOC估计偏差。这项实践突显了在实际BMS设计中考虑电芯异质性的重要性，并揭示了天真估计方法可能导致的潜在风险。",
            "id": "3896539",
            "problem": "给定一个由 $N$ 个电化学电池串联组成的电池包。每个电池 $i$ 具有以安培小时 (Ah) 为单位的电荷容量 $C_i$，以欧姆 ($\\Omega$) 为单位的内阻 $R_i$，并遵循一个以伏特 (V) 为单位的开路电压函数 $U(s)$，该函数取决于其充电状态 $s \\in [0,1]$。该电池包以安培 (A) 为单位的恒定电流 $I$ 放电，放电时长对应于以安培小时 (Ah) 为单位的总放电电荷量 $Q$。假设每个电池都从满电状态开始，因此对于所有 $i$，都有 $s_{i,0} = 1$。所有电池的开路电压函数形状相同；具体来说，假设该函数为二次函数 $U(s) = a_0 + a_1 s + a_2 s^2$，其中 $a_0$、$a_1$ 和 $a_2$ 是以伏特 (V) 为单位的常数。\n\n基本原理和定义：\n- 充电状态由电荷平衡定义。对于恒流放电，从电池 $i$ 中移出电荷 $Q$ 后，其剩余充电状态为 $s_i = 1 - \\frac{Q}{C_i}$，并裁剪到区间 $[0,1]$ 以确保物理可行性。\n- 电池 $i$ 在负载下的端电压为 $V_i = U(s_i) - I R_i$。\n- 电池包端电压是串联电池电压的总和：$V_{\\text{pack}} = \\sum_{i=1}^N V_i$。\n- 一个朴素估计器仅使用单一测量的电池包端电压，并假设有 $N$ 个具有平均容量 $\\bar{C} = \\frac{1}{N}\\sum_{i=1}^N C_i$ 和平均电阻 $\\bar{R} = \\frac{1}{N}\\sum_{i=1}^N R_i$ 的相同电池，以及开路电压函数 $U(\\cdot)$，通过以下公式计算估计的充电状态 $\\hat{s}$\n$$\nU(\\hat{s}) - I \\bar{R} = \\frac{V_{\\text{pack}}}{N},\n$$\n以至于\n$$\n\\hat{s} = U^{-1}\\!\\left(\\frac{V_{\\text{pack}}}{N} + I \\bar{R}\\right).\n$$\n- 电池包的真实充电状态定义为电荷加权平均值：\n$$\ns_{\\text{true}} = \\frac{\\sum_{i=1}^N C_i s_i}{\\sum_{i=1}^N C_i}.\n$$\n- 将估计偏差定义为 $b = \\hat{s} - s_{\\text{true}}$。该偏差是无量纲的。\n\n您的任务是实现一个程序，对于一组给定的参数 $(N, \\{C_i\\}, \\{R_i\\}, I, Q)$ 和开路电压参数 $(a_0, a_1, a_2)$，计算上述指定的偏差 $b$。请使用以下固定的开路电压参数：\n- $a_0 = 3.0$ V,\n- $a_1 = 0.95$ V,\n- $a_2 = 0.30$ V.\n\n二次反函数 $U^{-1}(v)$ 定义为 $a_2 s^2 + a_1 s + a_0 - v = 0$ 在 $[0,1]$ 内的物理可行根。如果由于数值问题，两个二次根都在 $[0,1]$ 之外，则将结果裁剪到区间 $[0,1]$。\n\n单位和量纲：\n- $C_i$ 以 Ah 表示，$R_i$ 以 $\\Omega$ 表示，$I$ 以 A 表示，$Q$ 以 Ah 表示，电压以 V 表示。\n- 偏差 $b$ 是无量纲的；请以十进制数输出。\n\n测试套件：\n为以下每组参数计算偏差 $b$。在每种情况下，所有电池的初始充电状态均为 $s_{i,0} = 1$。容量和电阻以列表形式给出，并与电池索引对齐。\n1. $N = 4$, $\\{C_i\\} = [3.0, 3.2, 2.9, 3.1]$ Ah, $\\{R_i\\} = [0.0025, 0.0030, 0.0020, 0.0028]$ $\\Omega$, $I = 5.0$ A, $Q = 1.0$ Ah。\n2. $N = 3$, $\\{C_i\\} = [3.0, 3.5, 2.8]$ Ah, $\\{R_i\\} = [0.0030, 0.0030, 0.0030]$ $\\Omega$, $I = 0.0$ A, $Q = 1.2$ Ah。\n3. $N = 5$, $\\{C_i\\} = [3.0, 3.0, 3.0, 3.0, 3.0]$ Ah, $\\{R_i\\} = [0.0030, 0.0030, 0.0030, 0.0030, 0.0030]$ $\\Omega$, $I = 4.0$ A, $Q = 0.5$ Ah。\n4. $N = 4$, $\\{C_i\\} = [2.5, 3.0, 3.5, 2.8]$ Ah, $\\{R_i\\} = [0.0040, 0.0020, 0.0035, 0.0025]$ $\\Omega$, $I = 10.0$ A, $Q = 2.0$ Ah。\n5. $N = 3$, $\\{C_i\\} = [3.1, 2.9, 3.2]$ Ah, $\\{R_i\\} = [0.0025, 0.0035, 0.0028]$ $\\Omega$, $I = 7.0$ A, $Q = 0.01$ Ah。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含五个测试用例的偏差，格式为方括号括起来的逗号分隔列表（例如，$[b_1,b_2,b_3,b_4,b_5]$）。结果必须以此精确格式打印，其中每个 $b_k$ 是一个十进制数，表示第 $k$ 个测试用例的偏差，单位为无量纲。",
            "solution": "问题陈述已经过验证，被认为是科学合理的、定义明确的且客观的。它在电池建模和状态估计领域提出了一个清晰、独立且可解决的问题。所有必要的参数和定义都已提供，不存在内部矛盾、事实错误或含糊不清之处。该问题与电池管理系统 (BMS) 算法的主题直接相关。因此，将提供一个解决方案。\n\n任务是为五个给定场景计算估计偏差 $b = \\hat{s} - s_{\\text{true}}$。该偏差量化了一个朴素充电状态 (SOC) 估计器的误差，该估计器假设电池包中的所有电池都是相同的，而真实情况是电荷加权平均 SOC。计算过程遵循一系列明确定义的步骤。\n\n首先，开路电压 (OCV) 函数 $U(s) = a_0 + a_1 s + a_2 s^2$ 的固定参数为：\n- $a_0 = 3.0$ V\n- $a_1 = 0.95$ V\n- $a_2 = 0.30$ V\n\n让我们详细说明单个测试用例的计算过程，其参数为 $N$、$\\{C_i\\}_{i=1}^N$、$\\{R_i\\}_{i=1}^N$、电流 $I$ 和放电电荷量 $Q$。\n\n**步骤 1：计算单个电池的充电状态 ($s_i$)**\n\n每个电池 $i$ 都从满电状态开始，$s_{i,0} = 1$。在以恒定电流 $I$ 从电池包中放出总电荷 $Q$ (以 Ah 为单位) 后，电池 $i$ 的充电状态会根据其个体容量 $C_i$ 进行更新。给出的公式为 $s_i = 1 - \\frac{Q}{C_i}$。根据问题定义，该值必须在物理上限制在区间 $[0, 1]$ 内。因此，正确的计算方法是：\n$$\ns_i = \\max\\left(0, \\min\\left(1, 1 - \\frac{Q}{C_i}\\right)\\right)\n$$\n此计算对每个电池 $i = 1, \\dots, N$ 执行。\n\n**步骤 2：计算电池包的真实充电状态 ($s_{\\text{true}}$)**\n\n电池包的真实充电状态定义为单个电池 SOC 的电荷加权平均值。这反映了电池包中相对于其总容量的剩余总电荷。\n$$\ns_{\\text{true}} = \\frac{\\sum_{i=1}^N C_i s_i}{\\sum_{i=1}^N C_i}\n$$\n这里，$s_i$ 的值是在步骤 1 中计算得出的。\n\n**步骤 3：计算电池包端电压 ($V_{\\text{pack}}$)**\n\n整个电池包的端电压是各个串联电池端电压的总和。每个电池 $i$ 的电压由其开路电压 $U(s_i)$ 减去其内阻 $R_i$ 上的电压降得出。\n计算过程如下：\n- 对于每个电池 $i$，计算其 OCV：$U(s_i) = a_0 + a_1 s_i + a_2 s_i^2$。\n- 对于每个电池 $i$，计算其端电压：$V_i = U(s_i) - I R_i$。\n- 将单个电池电压相加，得到电池包电压：$V_{\\text{pack}} = \\sum_{i=1}^N V_i$。\n\n**步骤 4：计算估计的充电状态 ($\\hat{s}$)**\n\n朴素估计器将电池包视为由 $N$ 个具有平均容量 $\\bar{C}$ 和平均电阻 $\\bar{R}$ 的相同电池组成。平均电阻为：\n$$\n\\bar{R} = \\frac{1}{N}\\sum_{i=1}^N R_i\n$$\n估计器使用测量的电池包电压 $V_{\\text{pack}}$ 来推断平均电池电压 $\\frac{V_{\\text{pack}}}{N}$。然后，它对该值进行平均欧姆压降校正，以估计这个假设的平均电池的 OCV，我们将其表示为 $\\hat{U}$：\n$$\n\\hat{U} = \\frac{V_{\\text{pack}}}{N} + I \\bar{R}\n$$\n然后通过反转 OCV 函数找到估计的 SOC $\\hat{s}$：$\\hat{s} = U^{-1}(\\hat{U})$。这需要求解关于 $\\hat{s}$ 的二次方程 $a_2 \\hat{s}^2 + a_1 \\hat{s} + a_0 = \\hat{U}$。整理后得到：\n$$\na_2 \\hat{s}^2 + a_1 \\hat{s} + (a_0 - \\hat{U}) = 0\n$$\n应用二次公式，$\\hat{s}$ 的解为：\n$$\n\\hat{s} = \\frac{-a_1 \\pm \\sqrt{a_1^2 - 4a_2(a_0 - \\hat{U})}}{2a_2}\n$$\n给定参数 $a_1 = 0.95 > 0$ 和 $a_2 = 0.30 > 0$，抛物线 $U(s)$ 的顶点位于 $s = -a_1 / (2 a_2)  0$。因此，$U(s)$ 在物理域 $s \\in [0, 1]$ 上是严格递增的。物理上有意义的根是较大的那个，对应于分子中的 `'+'` 号。\n$$\n\\hat{s}_{\\text{raw}} = \\frac{-a_1 + \\sqrt{a_1^2 - 4a_2(a_0 - \\hat{U})}}{2a_2}\n$$\n根据问题的规定，将此结果裁剪到区间 $[0, 1]$ 以确保物理上的合理性。\n$$\n\\hat{s} = \\max\\left(0, \\min\\left(1, \\hat{s}_{\\text{raw}}\\right)\\right)\n$$\n\n**步骤 5：计算估计偏差 ($b$)**\n\n最后，估计偏差计算为估计的 SOC 与真实的 SOC 之差。\n$$\nb = \\hat{s} - s_{\\text{true}}\n$$\n\n一个特殊情况是测试用例 3，其中所有电池都相同 ($C_i = C$ 和 $R_i = R$ 对于所有 $i$)。在这种情况下，$s_i = s$，$\\bar{R} = R$，$s_{\\text{true}} = s$，并且 $V_{\\text{pack}} = N(U(s) - IR)$。估计器随后计算 $\\hat{U} = \\frac{N(U(s) - IR)}{N} + IR = U(s)$，这导致 $\\hat{s} = U^{-1}(U(s)) = s$。因此，偏差 $b = \\hat{s} - s_{\\text{true}} = s - s = 0$。这可以作为实现的一个有用的验证点。\n\n以下程序为所有五个测试用例实现了此过程。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates the state of charge estimation bias for a series-connected battery pack\n    under five different test scenarios.\n    \"\"\"\n    # Fixed open-circuit voltage parameters (in V)\n    A0, A1, A2 = 3.0, 0.95, 0.30\n\n    test_cases = [\n        # 1. N=4, {C_i}=[3.0, 3.2, 2.9, 3.1] Ah, {R_i}=[0.0025, 0.0030, 0.0020, 0.0028] Ohm, I=5.0 A, Q=1.0 Ah\n        {'N': 4, 'C': [3.0, 3.2, 2.9, 3.1], 'R': [0.0025, 0.0030, 0.0020, 0.0028], 'I': 5.0, 'Q': 1.0},\n        # 2. N=3, {C_i}=[3.0, 3.5, 2.8] Ah, {R_i}=[0.0030, 0.0030, 0.0030] Ohm, I=0.0 A, Q=1.2 Ah\n        {'N': 3, 'C': [3.0, 3.5, 2.8], 'R': [0.0030, 0.0030, 0.0030], 'I': 0.0, 'Q': 1.2},\n        # 3. N=5, {C_i}=[3.0, 3.0, 3.0, 3.0, 3.0] Ah, {R_i}=[0.0030, 0.0030, 0.0030, 0.0030, 0.0030] Ohm, I=4.0 A, Q=0.5 Ah\n        {'N': 5, 'C': [3.0, 3.0, 3.0, 3.0, 3.0], 'R': [0.0030, 0.0030, 0.0030, 0.0030, 0.0030], 'I': 4.0, 'Q': 0.5},\n        # 4. N=4, {C_i}=[2.5, 3.0, 3.5, 2.8] Ah, {R_i}=[0.0040, 0.0020, 0.0035, 0.0025] Ohm, I=10.0 A, Q=2.0 Ah\n        {'N': 4, 'C': [2.5, 3.0, 3.5, 2.8], 'R': [0.0040, 0.0020, 0.0035, 0.0025], 'I': 10.0, 'Q': 2.0},\n        # 5. N=3, {C_i}=[3.1, 2.9, 3.2] Ah, {R_i}=[0.0025, 0.0035, 0.0028] Ohm, I=7.0 A, Q=0.01 Ah\n        {'N': 3, 'C': [3.1, 2.9, 3.2], 'R': [0.0025, 0.0035, 0.0028], 'I': 7.0, 'Q': 0.01}\n    ]\n\n    results = []\n\n    for case in test_cases:\n        N = case['N']\n        C_vec = np.array(case['C'])\n        R_vec = np.array(case['R'])\n        I = case['I']\n        Q = case['Q']\n\n        # Step 1: Calculate individual cell SOCs, clipping to [0, 1]\n        s_i_vec = np.clip(1.0 - Q / C_vec, 0.0, 1.0)\n\n        # Step 2: Calculate the true pack SOC (charge-weighted average)\n        s_true = np.sum(C_vec * s_i_vec) / np.sum(C_vec)\n\n        # Step 3: Calculate the total pack terminal voltage\n        # OCV for each cell\n        U_i_vec = A0 + A1 * s_i_vec + A2 * s_i_vec**2\n        # Terminal voltage for each cell\n        V_i_vec = U_i_vec - I * R_vec\n        # Total pack voltage\n        V_pack = np.sum(V_i_vec)\n\n        # Step 4: Calculate the estimated SOC\n        # Average resistance\n        R_bar = np.mean(R_vec)\n        # Estimated OCV of the hypothetical average cell\n        U_hat_arg = (V_pack / N) + I * R_bar\n        \n        # Solve the quadratic A2*s^2 + A1*s + (A0 - U_hat_arg) = 0 for s\n        discriminant = A1**2 - 4 * A2 * (A0 - U_hat_arg)\n        # Handle potential floating-point-induced negative values, though not expected here\n        if discriminant  0:\n            discriminant = 0.0\n            \n        s_hat_raw = (-A1 + np.sqrt(discriminant)) / (2 * A2)\n        # Clip result to [0, 1] as required\n        s_hat = np.clip(s_hat_raw, 0.0, 1.0)\n        \n        # Step 5: Calculate the estimation bias\n        bias = s_hat - s_true\n        results.append(bias)\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}