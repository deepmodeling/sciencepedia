{
    "hands_on_practices": [
        {
            "introduction": "相变材料（PCM）的核心功能是在接近恒定的温度下吸收大量潜热。在设计复杂的热管理系统之前，理解如何量化这种储能能力至关重要。第一个练习  提供了一个基础实践，旨在计算相变材料在升温并经过其熔化区间时的总焓变，这个过程结合了显热和潜热两个部分。",
            "id": "3939072",
            "problem": "在自动化电池设计与仿真中，相变材料（PCM）常被集成到电池包外壳中，通过以显热和潜热的形式储存能量来缓冲瞬态热释放。考虑一种相变材料，在所研究的温度范围内，其质量密度为 $\\rho$，比热容为恒定的 $c_p$。设其熔化潜热为 $L$，并假设熔化分数 $g(T)$ 在一个有限的熔化区间内随温度线性变化，于 $40\\,^{\\circ}\\mathrm{C}$ 开始熔化，于 $45\\,^{\\circ}\\mathrm{C}$ 完成熔化。名义熔化温度为 $T_m=42\\,^{\\circ}\\mathrm{C}$。该相变材料从 $35\\,^{\\circ}\\mathrm{C}$ 开始升温至 $50\\,^{\\circ}\\mathrm{C}$。\n\n从相变介质的比焓定义（即显热贡献与通过熔化分数演变累积的潜热贡献之和）出发，推导并计算在此温度变化过程中单位体积的焓增量。你可以假设滞后和过冷效应可忽略不计，并且线性熔化分数模型意味着当 $T  40\\,^{\\circ}\\mathrm{C}$ 时 $g(T)=0$，当 $T > 45\\,^{\\circ}\\mathrm{C}$ 时 $g(T)=1$，在此之间 $g(T)$ 线性变化。\n\n使用 $\\rho=900\\ \\mathrm{kg\\ m}^{-3}$，$L=200\\ \\mathrm{kJ\\ kg}^{-1}$，$c_p=2.0\\ \\mathrm{kJ\\ kg}^{-1}\\mathrm{K}^{-1}$ 以及 $T_m=42\\,^{\\circ}\\mathrm{C}$。将最终的单位体积焓增量以 $\\mathrm{MJ\\ m}^{-3}$ 为单位表示，并将答案四舍五入至四位有效数字。",
            "solution": "问题要求计算一种相变材料（PCM）在经历特定温度变化过程后，单位体积的总焓增量。求解过程需要从比焓的基本定义出发，该定义包含了显热和潜热的储存。\n\n材料的比焓 $h$ 是其温度 $T$ 的函数。对于相变材料，比焓的变化量 $dh$ 可以表示为显热部分和潜热部分之和：\n$$dh = c_p dT + L dg$$\n其中 $c_p$ 是比热容，$L$ 是熔化潜热，$g(T)$ 是熔化分数，表示材料中已从固相转变为液相的部分。\n\n通过使用链式法则将熔化分数的变化量 $dg$ 表示为温度变化量 $dT$ 的函数，$dg = \\frac{dg}{dT} dT$，我们可以将 $dh$ 的表达式写为：\n$$dh = \\left(c_p + L \\frac{dg}{dT}\\right) dT$$\n括号内的项被称为表观比热容，$c_{p,app}(T) = c_p + L \\frac{dg}{dT}$，它将显热和潜热效应都作为温度的函数来考虑。\n\n当材料从初始温度 $T_{initial}$ 加热到最终温度 $T_{final}$ 时，总比焓增量 $\\Delta h$ 可以通过对该微分表达式进行积分得到：\n$$\\Delta h = \\int_{T_{initial}}^{T_{final}} c_{p,app}(T) dT = \\int_{T_{initial}}^{T_{final}} \\left(c_p + L \\frac{dg}{dT}\\right) dT$$\n\n问题指明熔化分数 $g(T)$ 是温度的分段线性函数。设 $T_{onset} = 40\\,^{\\circ}\\mathrm{C}$ 且 $T_{complete} = 45\\,^{\\circ}\\mathrm{C}$。\n熔化分数 $g(T)$ 定义如下：\n1.  当 $T \\le T_{onset}$ 时：材料完全是固态，所以 $g(T) = 0$。\n2.  当 $T_{onset} \\le T \\le T_{complete}$ 时：材料正在熔化，$g(T)$ 从 0 线性变化到 1。其函数为：\n    $$g(T) = \\frac{T - T_{onset}}{T_{complete} - T_{onset}} = \\frac{T - 40}{45 - 40} = \\frac{T - 40}{5}$$\n3.  当 $T > T_{complete}$ 时：材料完全是液态，所以 $g(T) = 1$。\n\n根据这个定义，我们可以求出导数 $\\frac{dg}{dT}$：\n$$\\frac{dg}{dT} = \\begin{cases} 0   \\text{对于 } T  40\\,^{\\circ}\\mathrm{C} \\text{ 或 } T > 45\\,^{\\circ}\\mathrm{C} \\\\ \\frac{1}{5}\\ (^\\circ\\mathrm{C})^{-1}  \\text{对于 } 40\\,^{\\circ}\\mathrm{C} \\le T \\le 45\\,^{\\circ}\\mathrm{C} \\end{cases}$$\n温度以摄氏度给出。由于比热容的单位是每开尔文，我们注意到以摄氏度表示的温差 $\\Delta T$ 等于以开尔文表示的温差。导数 $\\frac{dg}{dT}$ 的单位是 $\\mathrm{K}^{-1}$ 或 $(^\\circ\\mathrm{C})^{-1}$。给定的名义熔化温度值 $T_m=42\\,^{\\circ}\\mathrm{C}$ 在计算中并未使用，因为 $g(T)$ 的行为由开始和完成熔化的温度明确定义。\n\n我们需要计算 $\\Delta h$ 从 $T_{initial} = 35\\,^{\\circ}\\mathrm{C}$ 到 $T_{final} = 50\\,^{\\circ}\\mathrm{C}$ 的积分。我们将积分根据 $\\frac{dg}{dT}$ 的分段定义分成三部分：\n$$\\Delta h = \\int_{35}^{50} \\left(c_p + L \\frac{dg}{dT}\\right) dT = \\int_{35}^{40} \\left(c_p + L \\frac{dg}{dT}\\right) dT + \\int_{40}^{45} \\left(c_p + L \\frac{dg}{dT}\\right) dT + \\int_{45}^{50} \\left(c_p + L \\frac{dg}{dT}\\right) dT$$\n\n分段计算如下：\n1.  从 $35\\,^{\\circ}\\mathrm{C}$ 到 $40\\,^{\\circ}\\mathrm{C}$：$\\frac{dg}{dT} = 0$。\n    $$\\int_{35}^{40} c_p dT = c_p [T]_{35}^{40} = c_p(40 - 35) = 5c_p$$\n2.  从 $40\\,^{\\circ}\\mathrm{C}$ 到 $45\\,^{\\circ}\\mathrm{C}$：$\\frac{dg}{dT} = \\frac{1}{5}$。\n    $$\\int_{40}^{45} \\left(c_p + \\frac{L}{5}\\right) dT = \\left(c_p + \\frac{L}{5}\\right) [T]_{40}^{45} = \\left(c_p + \\frac{L}{5}\\right)(45 - 40) = 5\\left(c_p + \\frac{L}{5}\\right) = 5c_p + L$$\n3.  从 $45\\,^{\\circ}\\mathrm{C}$ 到 $50\\,^{\\circ}\\mathrm{C}$：$\\frac{dg}{dT} = 0$。\n    $$\\int_{45}^{50} c_p dT = c_p [T]_{45}^{50} = c_p(50 - 45) = 5c_p$$\n\n总比焓增量是这三部分贡献之和：\n$$\\Delta h = 5c_p + (5c_p + L) + 5c_p = 15c_p + L$$\n这个结果在物理上是直观的：它等于将温度升高 $15\\,^{\\circ}\\mathrm{C}$（从 $35\\,^{\\circ}\\mathrm{C}$ 到 $50\\,^{\\circ}\\mathrm{C}$）所需的显热，再加上完全熔化所需的全部熔化潜热。\n\n现在，我们代入给定值：$c_p = 2.0\\ \\mathrm{kJ\\ kg}^{-1}\\mathrm{K}^{-1}$ 和 $L = 200\\ \\mathrm{kJ\\ kg}^{-1}$。\n$$\\Delta h = (15\\ \\mathrm{K}) \\times (2.0\\ \\mathrm{kJ\\ kg}^{-1}\\mathrm{K}^{-1}) + 200\\ \\mathrm{kJ\\ kg}^{-1}$$\n$$\\Delta h = 30\\ \\mathrm{kJ\\ kg}^{-1} + 200\\ \\mathrm{kJ\\ kg}^{-1} = 230\\ \\mathrm{kJ\\ kg}^{-1}$$\n\n问题要求的是单位体积的焓增量 $\\Delta H_v$，它是比焓增量 $\\Delta h$ 与质量密度 $\\rho$ 的乘积。\n$$\\Delta H_v = \\rho \\cdot \\Delta h$$\n使用给定的密度 $\\rho = 900\\ \\mathrm{kg\\ m}^{-3}$：\n$$\\Delta H_v = (900\\ \\mathrm{kg\\ m}^{-3}) \\times (230\\ \\mathrm{kJ\\ kg}^{-1}) = 207000\\ \\mathrm{kJ\\ m}^{-3}$$\n\n最后，我们将单位转换为兆焦耳每立方米 ($\\mathrm{MJ\\ m}^{-3}$) 并四舍五入到四位有效数字。由于 $1\\ \\mathrm{MJ} = 1000\\ \\mathrm{kJ}$：\n$$\\Delta H_v = 207000\\ \\mathrm{kJ\\ m}^{-3} \\times \\frac{1\\ \\mathrm{MJ}}{1000\\ \\mathrm{kJ}} = 207\\ \\mathrm{MJ\\ m}^{-3}$$\n四舍五入到四位有效数字得到 $207.0\\ \\mathrm{MJ\\ m}^{-3}$。",
            "answer": "$$\\boxed{207.0}$$"
        },
        {
            "introduction": "虽然相变材料具有高能量密度，但其较低的导热系数可能成为一个显著的瓶颈，限制了其从电池吸热的速率。一个常见的解决方案是通过嵌入导电填料来制造复合材料。这个实践  提出了一个真实的工程设计挑战：模拟和优化复合相变材料中的填料浓度，以满足电池模块的峰值温度约束，突显了在提高导热系数和不可避免地降低潜热储存能力之间的关键权衡。",
            "id": "3939032",
            "problem": "考虑一个电池模组，其与一块含有分散导电填料的复合相变材料（PCM）板进行热接触。目标是选择合适的填料体积分数，以平衡增强的导热能力和降低的潜热容量，从而在固定的复合材料质量预算下，将电池峰值温度维持在规定的最高温度以下。\n\n基本原理和建模假设：\n- 集总电池温度的能量守恒由热力学第一定律和傅里叶热传导定律给出：总焓的变化率等于内部生热减去流向环境的热量。\n- 复合相变材料被视为一种均匀介质，其有效属性取决于填料体积分数，这与球形夹杂物的经典有效介质理论一致。\n- 潜热吸收通过在有限熔化区间内的有效热容进行建模（焓法）。\n\n几何与边界条件：\n- 电池表面是一个面积为 $A$ 的平板，与厚度为 $t$ 的复合相变材料板完美热接触。\n- 该板的另一侧通过一个大型散热器保持在环境温度 $T_{\\text{amb}}$。\n- 假设热量在板内进行一维传导，穿过接触面的热流由一个额外的接触热阻 $R_{\\text{contact}}$ 来表示。\n\n复合材料属性作为填料体积分数 $\\phi$ 的函数：\n- 设 $k_m$ 和 $k_f$ 分别为相变材料基体和填料的热导率。有效热导率 $k_{\\text{eff}}(\\phi)$ 遵循球形夹杂物的麦克斯韦-欧肯（Maxwell–Eucken）模型：\n$$\nk_{\\text{eff}}(\\phi) = k_m \\, \\frac{k_f + 2 k_m - 2 \\phi (k_m - k_f)}{k_f + 2 k_m + \\phi (k_m - k_f)}.\n$$\n- 设 $\\rho_m$ 和 $\\rho_f$ 分别为相变材料基体和填料的密度。有效复合材料密度为：\n$$\n\\rho_{\\text{eff}}(\\phi) = (1-\\phi) \\rho_m + \\phi \\rho_f.\n$$\n- 设 $c_m$ 和 $c_f$ 分别为相变材料基体和填料的定压比热容。复合材料的有效显热比热容为：\n$$\nc_{\\text{sens,eff}}(\\phi) = (1-\\phi) c_m + \\phi c_f.\n$$\n- 复合材料单位质量的潜热根据以下公式减少：\n$$\nL_{\\text{eff}}(\\phi) = (1-\\phi) L,\n$$\n其中 $L$ 是纯相变材料基体的潜热。\n\n热阻与质量预算：\n- 复合材料的质量预算固定为 $M_c$。板的厚度由质量预算和有效密度决定：\n$$\nt(\\phi) = \\frac{M_c}{\\rho_{\\text{eff}}(\\phi) \\, A}.\n$$\n- 电池与环境之间通过板和接触面的总热阻为：\n$$\nR_{\\text{th}}(\\phi) = \\frac{t(\\phi)}{k_{\\text{eff}}(\\phi) \\, A} + R_{\\text{contact}}.\n$$\n\n电池与相变材料的热模型：\n- 设 $m_b$ 为电池质量， $c_b$ 为其比热容。电池温度 $T(t)$ 被建模为集总且空间均匀的。电池内部的生热率 $q(t)$ 是给定的非负值。\n- 耦合的电池-相变材料系统的有效热容 $C_{\\text{eff}}(T,\\phi)$ 采用焓法，熔化区间宽度为 $\\Delta T$，中心为熔化温度 $T_m$，因此：\n$$\nC_{\\text{eff}}(T,\\phi) = m_b c_b + M_c c_{\\text{sens,eff}}(\\phi) + \\chi(T) \\, \\frac{M_c L_{\\text{eff}}(\\phi)}{\\Delta T},\n$$\n其中指示函数 $\\chi(T)$ 在 $|T - T_m| \\le \\Delta T/2$ 时等于 $1$，否则等于 $0$。\n- 能量平衡给出了温度演化方程：\n$$\nC_{\\text{eff}}(T,\\phi) \\, \\frac{dT}{dt} = q(t) - \\frac{T(t) - T_{\\text{amb}}}{R_{\\text{th}}(\\phi)}.\n$$\n- 初始条件：$T(0) = T_{\\text{amb}}$。\n\n优化问题：\n- 给定允许的最高峰值温度 $T_{\\max}$ 和填料分数上限 $\\phi_{\\max}$，选择 $\\phi \\in [0,\\phi_{\\max}]$ 以在指定时间范围内满足峰值温度约束 $T_{\\text{peak}}(\\phi) \\le T_{\\max}$，同时遵守质量预算 $M_c$。在所有可行的 $\\phi$ 中，选择最小的 $\\phi$ 以最小化填料用量。如果在 $[0,\\phi_{\\max}]$ 范围内没有可行的 $\\phi$，则报告无解。\n\n数值要求：\n- 使用上述焓法的指示函数形式，通过对微分方程进行常数时间步长 $\\Delta t$ 的显式时间步进，来实现温度演化。\n- 对每个测试用例，在 $[0,\\phi_{\\max}]$ 范围内的均匀网格上以分辨率 $\\Delta \\phi$ 搜索 $\\phi$，并确定最小的可行 $\\phi$。\n\n您的程序必须解决以下三个测试用例。所有量都必须使用指定的单位。\n\n全局常量（所有测试用例共享）：\n- $A = 0.01 \\, \\mathrm{m^2}$。\n- $T_{\\text{amb}} = 298.15 \\, \\mathrm{K}$。\n- $R_{\\text{contact}} = 0.001 \\, \\mathrm{K/W}$。\n- $m_b = 0.8 \\, \\mathrm{kg}$，$c_b = 1000 \\, \\mathrm{J/(kg \\cdot K)}$。\n- PCM基体属性：$k_m = 0.25 \\, \\mathrm{W/(m \\cdot K)}$，$\\rho_m = 900 \\, \\mathrm{kg/m^3}$，$c_m = 2000 \\, \\mathrm{J/(kg \\cdot K)}$，$L = 250000 \\, \\mathrm{J/kg}$，$T_m = 305 \\, \\mathrm{K}$，$\\Delta T = 6 \\, \\mathrm{K}$。\n- 填料属性：$k_f = 200 \\, \\mathrm{W/(m \\cdot K)}$，$\\rho_f = 2000 \\, \\mathrm{kg/m^3}$，$c_f = 800 \\, \\mathrm{J/(kg \\cdot K)}$。\n- 时间步进：$\\Delta t = 0.5 \\, \\mathrm{s}$，总时长 $t_f$ 按各测试用例指定。\n- 填料搜索网格分辨率：$\\Delta \\phi = 0.001$。\n\n测试套件：\n1. 用例1（理想路径）：\n   - 质量预算 $M_c = 0.6 \\, \\mathrm{kg}$。\n   - 生热 $q(t) = Q_0$（当 $0 \\le t \\le \\tau$），否则 $q(t) = 0$。其中 $Q_0 = 80 \\, \\mathrm{W}$，$\\tau = 600 \\, \\mathrm{s}$。\n   - 最大填料分数 $\\phi_{\\max} = 0.35$。\n   - 温度约束 $T_{\\max} = 315 \\, \\mathrm{K}$。\n   - 模拟时长 $t_f = 1200 \\, \\mathrm{s}$。\n\n2. 用例2（严格约束，可能不可行）：\n   - 质量预算 $M_c = 0.6 \\, \\mathrm{kg}$。\n   - 生热 $q(t) = Q_0$（当 $0 \\le t \\le \\tau$），否则 $q(t) = 0$。其中 $Q_0 = 150 \\, \\mathrm{W}$，$\\tau = 600 \\, \\mathrm{s}$。\n   - 最大填料分数 $\\phi_{\\max} = 0.50$。\n   - 温度约束 $T_{\\max} = 313 \\, \\mathrm{K}$。\n   - 模拟时长 $t_f = 1200 \\, \\mathrm{s}$。\n\n3. 用例3（低热量，预计不发生熔化）：\n   - 质量预算 $M_c = 0.3 \\, \\mathrm{kg}$。\n   - 生热 $q(t) = Q_0$（当 $0 \\le t \\le \\tau$），否则 $q(t) = 0$。其中 $Q_0 = 30 \\, \\mathrm{W}$，$\\tau = 300 \\, \\mathrm{s}$。\n   - 最大填料分数 $\\phi_{\\max} = 0.30$。\n   - 温度约束 $T_{\\max} = 310 \\, \\mathrm{K}$。\n   - 模拟时长 $t_f = 900 \\, \\mathrm{s}$。\n\n最终输出格式：\n- 你的程序应生成一行输出，其中包含三个测试用例的最优填料体积分数，格式为逗号分隔的Python风格列表。如果可行，每个条目四舍五入到小数点后四位；如果 $[0,\\phi_{\\max}]$ 范围内没有 $\\phi$ 满足峰值温度约束，则为整数 $-1$。例如：$[0.1234,-1,0.0000]$。",
            "solution": "所呈现的问题是热工程领域一个适定的优化任务，具体涉及使用复合相变材料（PCM）对电池模组进行热管理。该问题在科学上基于能量守恒和热传递原理，并提供了所有必要的参数和本构模型。问题表述客观，没有矛盾或含糊之处。因此，该问题被认为是有效的，可以构建解决方案。\n\n目标是在给定范围 $[0, \\phi_{\\max}]$ 内找到最小的填料体积分数 $\\phi$，以确保电池的峰值温度 $T_{\\text{peak}}$ 不超过指定的最高温度 $T_{\\max}$。对最优 $\\phi$ 的搜索必须在分辨率为 $\\Delta\\phi$ 的离散网格上进行。\n\n求解方法包括以下步骤：\n1.  **参数离散化与搜索**：将连续的设计变量 $\\phi$ 离散化为一系列候选值组成的均匀网格，$\\phi_j = j \\Delta\\phi$，从 $\\phi=0$ 开始直至 $\\phi_{\\max}$。按顺序在此网格上进行搜索。\n2.  **系统特性计算**：对于每个候选值 $\\phi$，计算复合相变材料的有效属性以及系统的总热阻。\n3.  **瞬态热模拟**：使用显式时间步进法对控制常微分方程（ODE）进行数值积分，以模拟电池的温度演化过程 $T(t)$。\n4.  **约束评估**：从模拟中确定峰值温度 $T_{\\text{peak}}(\\phi) = \\max_{t \\in [0, t_f]} T(t)$。将此值与约束条件 $T_{\\text{peak}}(\\phi) \\le T_{\\max}$进行核对。\n5.  **最优选择**：由于搜索是从最小的 $\\phi$ 值开始向上进行的，第一个满足温度约束的 $\\phi$ 值即为所求的最小解。如果在离散化搜索空间内完成搜索后仍未找到可行的 $\\phi$，则不存在解。\n\n问题的核心在于由填料分数 $\\phi$ 控制的权衡关系。增加 $\\phi$ 会增强热导率，但会降低潜热容量。这种平衡决定了系统的热性能。\n\n**1. 作为 $\\phi$ 函数的复合材料属性**\n\n对于给定的填料体积分数 $\\phi$，复合材料的有效属性使用所提供的模型计算：\n-   **有效热导率** ($k_{\\text{eff}}$)：麦克斯韦-欧肯（Maxwell–Eucken）模型描述了含有分散球形填料的基体的热导率。\n    $$k_{\\text{eff}}(\\phi) = k_m \\, \\frac{k_f + 2 k_m - 2 \\phi (k_m - k_f)}{k_f + 2 k_m + \\phi (k_m - k_f)}$$\n    增加 $\\phi$ 会提高 $k_{\\text{eff}}$，因为填料的热导率 $k_f$ 远大于基体的热导率 $k_m$。\n-   **有效密度** ($\\rho_{\\text{eff}}$)：基于体积分数的简单混合法则。\n    $$\\rho_{\\text{eff}}(\\phi) = (1-\\phi) \\rho_m + \\phi \\rho_f$$\n    由于 $\\rho_f  \\rho_m$，$\\rho_{\\text{eff}}$ 随 $\\phi$ 的增加而增加。\n-   **有效显热比热容** ($c_{\\text{sens,eff}}$)：基于质量分数的混合法则，在此问题结构下简化为所提供的形式。\n    $$c_{\\text{sens,eff}}(\\phi) = (1-\\phi) c_m + \\phi c_f$$\n-   **有效潜热** ($L_{\\text{eff}}$)：潜热容量与PCM基体的质量分数成正比。题目给出了一个更简单的、基于单位复合材料质量的直接折减公式：\n    $$L_{\\text{eff}}(\\phi) = (1-\\phi) L$$\n    这表明添加填料会直接降低复合材料单位质量的潜热储存能力。\n\n**2. 热阻与质量预算**\n\n固定的质量预算 $M_c$ 将板的厚度 $t$ 与复合材料密度 $\\rho_{\\text{eff}}(\\phi)$ 联系起来：\n$$t(\\phi) = \\frac{M_c}{\\rho_{\\text{eff}}(\\phi) \\, A}$$\n更高的 $\\phi$ 会导致复合材料密度更大，因此在相同质量下板的厚度更薄。电池与环境散热器之间的总热阻 $R_{\\text{th}}(\\phi)$ 是板的导热热阻与接触热阻之和：\n$$R_{\\text{th}}(\\phi) = \\frac{t(\\phi)}{k_{\\text{eff}}(\\phi) \\, A} + R_{\\text{contact}} = \\frac{M_c}{\\rho_{\\text{eff}}(\\phi) k_{\\text{eff}}(\\phi) A^2} + R_{\\text{contact}}$$\n增加 $\\phi$ 会同时增加 $\\rho_{\\text{eff}}$ 和 $k_{\\text{eff}}$。乘积 $\\rho_{\\text{eff}} k_{\\text{eff}}$ 的增长通常快于线性增长，导致 $R_{\\text{th}}$ 减小。这改善了稳态散热性能。\n\n**3. 控制微分方程与数值积分**\n\n集总电容电池-PCM系统的热行为由能量平衡方程控制：\n$$C_{\\text{eff}}(T,\\phi) \\, \\frac{dT}{dt} = q(t) - \\frac{T(t) - T_{\\text{amb}}}{R_{\\text{th}}(\\phi)}$$\n有效热容 $C_{\\text{eff}}(T, \\phi)$ 包括来自电池、复合材料显热以及熔化过程中吸收的潜热的贡献：\n$$C_{\\text{eff}}(T,\\phi) = m_b c_b + M_c c_{\\text{sens,eff}}(\\phi) + \\chi(T) \\, \\frac{M_c L_{\\text{eff}}(\\phi)}{\\Delta T}$$\n其中指示函数 $\\chi(T)$ 在 $T_m - \\Delta T/2 \\le T \\le T_m + \\Delta T/2$ 时为 $1$，否则为 $0$。该项代表了相变期间热容的大幅增加。\n\n为求解 $T(t)$，我们重排该常微分方程：\n$$\\frac{dT}{dt} = \\frac{1}{C_{\\text{eff}}(T, \\phi)} \\left( q(t) - \\frac{T(t) - T_{\\text{amb}}}{R_{\\text{th}}(\\phi)} \\right)$$\n按照要求，此方程使用显式前向欧拉法进行数值积分。给定时间 $t_i$ 时的温度 $T_i$，在下一个时间步 $t_{i+1} = t_i + \\Delta t$ 时的温度 $T_{i+1}$ 为：\n$$T_{i+1} = T_i + \\Delta t \\cdot \\left[ \\frac{1}{C_{\\text{eff}}(T_i, \\phi)} \\left( q(t_i) - \\frac{T_i - T_{\\text{amb}}}{R_{\\text{th}}(\\phi)} \\right) \\right]$$\n模拟从初始条件 $T_0 = T(0) = T_{\\text{amb}}$ 开始，一直进行到最终时间 $t_f$。在此过程中记录峰值温度 $T_{\\text{peak}}$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Global constants as per problem statement\nA = 0.01  # m^2\nT_AMB = 298.15  # K\nR_CONTACT = 0.001  # K/W\nM_B = 0.8  # kg\nC_B = 1000.0  # J/(kg.K)\n\n# PCM matrix properties\nK_M = 0.25  # W/(m.K)\nRHO_M = 900.0  # kg/m^3\nC_M = 2000.0  # J/(kg.K)\nL = 250000.0  # J/kg\nT_M = 305.0  # K\nDELTA_T_MELT = 6.0  # K\n\n# Filler properties\nK_F = 200.0  # W/(m.K)\nRHO_F = 2000.0  # kg/m^3\nC_F = 800.0  # J/(kg.K)\n\n# Numerical parameters\nDT = 0.5  # s\nDELTA_PHI = 0.001\n\ndef run_simulation(phi, params):\n    \"\"\"\n    Simulates the temperature evolution for a given filler fraction phi and returns the peak temperature.\n    \n    Args:\n        phi (float): The filler volume fraction.\n        params (dict): A dictionary of case-specific parameters.\n\n    Returns:\n        float: The peak temperature reached during the simulation.\n    \"\"\"\n    # Unpack case-specific parameters\n    m_c = params['M_c']\n    q0 = params['Q0']\n    tau = params['tau']\n    t_f = params['t_f']\n    \n    # 1. Calculate effective properties for the given phi\n    # Effective thermal conductivity (Maxwell-Eucken)\n    k_eff_num = K_F + 2 * K_M - 2 * phi * (K_M - K_F)\n    k_eff_den = K_F + 2 * K_M + phi * (K_M - K_F)\n    k_eff = K_M * k_eff_num / k_eff_den\n    \n    # Effective density (Rule of mixtures)\n    rho_eff = (1 - phi) * RHO_M + phi * RHO_F\n    \n    # Effective sensible specific heat (Rule of mixtures) as given in problem\n    c_sens_eff = (1-phi) * C_M + phi * C_F\n\n    # Effective latent heat\n    l_eff = (1 - phi) * L\n    \n    # 2. Calculate derived quantities\n    # Slab thickness from mass budget\n    t_phi = m_c / (rho_eff * A)\n    \n    # Total thermal resistance\n    r_th = t_phi / (k_eff * A) + R_CONTACT\n    \n    # 3. Time-stepping simulation\n    num_steps = int(t_f / DT)\n    T = T_AMB\n    T_peak = T_AMB\n    \n    T_melt_min = T_M - DELTA_T_MELT / 2\n    T_melt_max = T_M + DELTA_T_MELT / 2\n    \n    # Pre-calculate constant part of C_eff and latent term\n    c_sens_total = M_B * C_B + m_c * c_sens_eff\n    c_latent_term = m_c * l_eff / DELTA_T_MELT if DELTA_T_MELT  0 else 0\n    \n    for i in range(num_steps):\n        current_time = i * DT\n        \n        # Heat generation pulse\n        q_t = q0 if current_time = tau else 0.0\n        \n        # Effective heat capacity (Enthalpy method) based on indicator function chi(T)\n        is_melting = 1.0 if T_melt_min = T = T_melt_max else 0.0\n        c_eff = c_sens_total + is_melting * c_latent_term\n        \n        # Temperature derivative from the energy balance ODE\n        if c_eff  1e-9: # Avoid division by zero, though c_eff should always be positive\n            dT_dt = (q_t - (T - T_AMB) / r_th) / c_eff\n        else:\n            dT_dt = 0.0\n\n        # Update temperature using Explicit Euler method\n        T += dT_dt * DT\n        \n        # Update peak temperature\n        if T  T_peak:\n            T_peak = T\n            \n    return T_peak\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        { # Case 1\n            'M_c': 0.6, 'Q0': 80.0, 'tau': 600.0, 'phi_max': 0.35, \n            'T_max': 315.0, 't_f': 1200.0\n        },\n        { # Case 2\n            'M_c': 0.6, 'Q0': 150.0, 'tau': 600.0, 'phi_max': 0.50,\n            'T_max': 313.0, 't_f': 1200.0\n        },\n        { # Case 3\n            'M_c': 0.3, 'Q0': 30.0, 'tau': 300.0, 'phi_max': 0.30,\n            'T_max': 310.0, 't_f': 900.0\n        }\n    ]\n\n    results = []\n    \n    for case_params in test_cases:\n        phi_max = case_params['phi_max']\n        t_max_constraint = case_params['T_max']\n        \n        # Create a uniform grid for phi from 0 to phi_max\n        num_phi_steps = int(round(phi_max / DELTA_PHI)) + 1\n        phi_grid = np.linspace(0, phi_max, num_phi_steps)\n        \n        found_solution = False\n        for phi in phi_grid:\n            peak_temp = run_simulation(phi, case_params)\n            \n            # Check if the peak temperature constraint is satisfied\n            if peak_temp = t_max_constraint:\n                results.append(f\"{phi:.4f}\")\n                found_solution = True\n                break  # Found the smallest feasible phi, move to next case\n        \n        if not found_solution:\n            results.append(\"-1\")\n            \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "模拟相变现象带来了一个显著的数值挑战，因为材料性质的急剧、局部变化会导致刚性（stiff）的控制方程。虽然简单的显式求解器可能足以应对某些情况，但它们通常需要极小的时间步长来保证稳定性。这个高级实践  将指导您使用牛顿迭代法（Newton's method）实现一个鲁棒的隐式求解器，这项技术对于高效、准确地处理相变材料热模拟中固有的非线性和刚性问题至关重要。",
            "id": "3939148",
            "problem": "您正在设计一个鲁棒的隐式时间步进器，用于对嵌入在相变材料（PCM）中的电池模块进行热管理。您将采用集总参数焓法。令 $T$ 表示温度（单位：开尔文），$h(T)$ 表示比焓（单位：焦耳每千克），$H(T) = m \\, h(T)$ 表示质量为 $m$（单位：千克）的总焓（单位：焦耳）。PCM 通过一个平滑的液相分数函数来建模，以表示熔化过程。从 $t^n$ 到 $t^{n+1}$ 的单个后向（隐式）欧拉时间步内的能量平衡基于能量守恒：\n- 总焓变等于净能量输入减去与环境的对流热损失。其数学形式为：\n$$\nH\\!\\left(T^{n+1}\\right) - H\\!\\left(T^{n}\\right) = \\Delta t \\left(P - h_c A \\left(T^{n+1} - T_{\\text{amb}}\\right)\\right),\n$$\n其中 $\\Delta t$ 是时间步长（单位：秒），$P$ 是恒定的体积功率输入（单位：瓦特），$h_c A$ 是集总传热系数乘以表面积（单位：瓦特每开尔文），$T_{\\text{amb}}$ 是环境温度（单位：开尔文）。\n\n给定一个形式如下的平滑焓温关系：\n$$\nh(T) = c \\left(T - T_{\\text{ref}}\\right) + L \\, f(T),\n$$\n其中 $c$ 是有效比热容（单位：焦耳每千克每开尔文），$T_{\\text{ref}}$ 是参考温度（单位：开尔文），$L$ 是潜热（单位：焦耳每千克），$f(T)$ 是平滑熔化分数：\n$$\nf(T) = \\tfrac{1}{2}\\left(1 + \\tanh\\!\\left(\\frac{T - T_m}{w}\\right)\\right),\n$$\n其中熔化温度为 $T_m$（单位：开尔文），平滑半宽为 $w$（单位：开尔文）。其导数满足：\n$$\n\\frac{dh}{dT}(T) = c + L \\, f'(T), \\quad f'(T) = \\tfrac{1}{2}\\,\\frac{1}{w}\\,\\operatorname{sech}^2\\!\\left(\\frac{T - T_m}{w}\\right),\n$$\n其中 $\\operatorname{sech}(x) = 1/\\cosh(x)$。\n\n任务：\n- 实现一个 Newton 迭代法，从以下非线性隐式方程中求解 $T^{n+1}$（单位：开尔文）：\n$$\nF(T) \\equiv H(T) + \\Delta t \\, h_c A \\, T - \\left(H\\!\\left(T^n\\right) + \\Delta t \\, P + \\Delta t \\, h_c A \\, T_{\\text{amb}}\\right) = 0,\n$$\n其中 $H(T) = m \\, h(T)$。\n- 您的求解器必须包含收敛准则和保障措施，以在 $\\frac{dH}{dT} = m \\, \\frac{dh}{dT}$ 非常大时（相变点附近）保持鲁棒性，至少包括：基于残差的停止条件、步长控制、带二分法回退的区间限定以及线搜索阻尼。\n- 您可以选择自己的容差，但在解题叙述中需用具有物理意义的理由来证明其合理性。在程序中，报告计算出的 $T^{n+1}$（单位：开尔文），并四舍五入到六位小数。\n\n定义以下参数集作为测试套件。对每种情况，计算 $T^{n+1}$（单位：开尔文）。\n\n- 情况 1（理想路径，中等平滑度）：\n  - $m = 0.5$ $\\mathrm{kg}$，$c = 2000$ $\\mathrm{J/(kg\\cdot K)}$，$L = 200000$ $\\mathrm{J/kg}$，$T_{\\text{ref}} = 300$ $\\mathrm{K}$，$T_m = 330$ $\\mathrm{K}$，$w = 2$ $\\mathrm{K}$，$h_c A = 5$ $\\mathrm{W/K}$，$P = 50$ $\\mathrm{W}$，$\\Delta t = 10$ $\\mathrm{s}$，$T_{\\text{amb}} = 300$ $\\mathrm{K}$，$T^n = 320$ $\\mathrm{K}$。\n\n- 情况 2（非常急剧的相变，具有挑战性的导数）：\n  - $m = 0.5$ $\\mathrm{kg}$，$c = 2000$ $\\mathrm{J/(kg\\cdot K)}$，$L = 200000$ $\\mathrm{J/kg}$，$T_{\\text{ref}} = 300$ $\\mathrm{K}$，$T_m = 330$ $\\mathrm{K}$，$w = 0.2$ $\\mathrm{K}$，$h_c A = 5$ $\\mathrm{W/K}$，$P = 50$ $\\mathrm{W}$，$\\Delta t = 10$ $\\mathrm{s}$，$T_{\\text{amb}} = 300$ $\\mathrm{K}$，$T^n = 320$ $\\mathrm{K}$。\n\n- 情况 3（无潜热，线性检验）：\n  - $m = 1.0$ $\\mathrm{kg}$，$c = 1000$ $\\mathrm{J/(kg\\cdot K)}$，$L = 0$ $\\mathrm{J/kg}$，$T_{\\text{ref}} = 300$ $\\mathrm{K}$，$T_m = 330$ $\\mathrm{K}$，$w = 1.0$ $\\mathrm{K}$，$h_c A = 2$ $\\mathrm{W/K}$，$P = 100$ $\\mathrm{W}$，$\\Delta t = 5$ $\\mathrm{s}$，$T_{\\text{amb}} = 300$ $\\mathrm{K}$，$T^n = 305$ $\\mathrm{K}$。\n\n- 情况 4（跨越 $T_m$ 的冷却与凝固）：\n  - $m = 0.3$ $\\mathrm{kg}$，$c = 1800$ $\\mathrm{J/(kg\\cdot K)}$，$L = 150000$ $\\mathrm{J/kg}$，$T_{\\text{ref}} = 300$ $\\mathrm{K}$，$T_m = 330$ $\\mathrm{K}$，$w = 1$ $\\mathrm{K}$，$h_c A = 10$ $\\mathrm{W/K}$，$P = -20$ $\\mathrm{W}$，$\\Delta t = 30$ $\\mathrm{s}$，$T_{\\text{amb}} = 300$ $\\mathrm{K}$，$T^n = 335$ $\\mathrm{K}$。\n\n- 情况 5（靠近相变点的大 $\\Delta t$ 和 $h_c A$ 带来的刚性步长）：\n  - $m = 0.8$ $\\mathrm{kg}$，$c = 2200$ $\\mathrm{J/(kg\\cdot K)}$，$L = 250000$ $\\mathrm{J/kg}$，$T_{\\text{ref}} = 298$ $\\mathrm{K}$，$T_m = 335$ $\\mathrm{K}$，$w = 0.5$ $\\mathrm{K}$，$h_c A = 50$ $\\mathrm{W/K}$，$P = 200$ $\\mathrm{W}$，$\\Delta t = 120$ $\\mathrm{s}$，$T_{\\text{amb}} = 300$ $\\mathrm{K}$，$T^n = 334$ $\\mathrm{K}$。\n\n最终输出规范：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，结果顺序与上述案例的顺序一致，每个 $T^{n+1}$ 值（单位：开尔文）都四舍五入到六位小数。例如，格式应如 [$r_1$,$r_2$,$r_3$,$r_4$,$r_5$]，其中每个 $r_i$ 是一个以开尔文为单位的浮点数。",
            "solution": "我们从一个集总节点在一个后向（隐式）欧拉时间步内的能量守恒出发，该节点与环境进行热交换并接收恒定的功率输入。设 $T^n$ 是已知的先前温度（单位：开尔文），$T^{n+1}$ 是未知的下一时刻温度（单位：开尔文）。能量平衡方程为：\n$$\nH\\!\\left(T^{n+1}\\right) - H\\!\\left(T^n\\right) = \\Delta t \\left(P - h_c A \\left(T^{n+1} - T_{\\text{amb}}\\right)\\right),\n$$\n其中 $H(T) = m \\, h(T)$ 且 $h(T)$ 是比焓。这是焓法的一种经过充分检验的公式，源于将热力学第一定律（能量守恒）应用于一个集总控制体。\n\n比焓的本构关系为：\n$$\nh(T) = c \\left(T - T_{\\text{ref}}\\right) + L \\, f(T), \\quad f(T) = \\tfrac{1}{2}\\left(1 + \\tanh\\!\\left(\\frac{T - T_m}{w}\\right)\\right),\n$$\n该关系将显热与通过半宽为 $w$ 的双曲正切过渡实现的平滑潜热贡献相融合。其导数为：\n$$\n\\frac{dh}{dT}(T) = c + L \\, f'(T), \\quad f'(T) = \\tfrac{1}{2}\\,\\frac{1}{w}\\,\\operatorname{sech}^2\\!\\left(\\frac{T - T_m}{w}\\right),\n$$\n其中 $\\operatorname{sech}(x) = 1/\\cosh(x)$。当 $w$ 很小且 $T$ 接近 $T_m$ 时，函数 $f'(T)$ 的值会变得非常大，这反映了与相变相关的急剧焓变。这是刚性和病态问题的物理现实来源。\n\n将能量平衡方程重排为关于 $T^{n+1}$ 的求根形式，定义：\n$$\nF(T) \\equiv H(T) + \\Delta t \\, h_c A \\, T - \\left(H\\!\\left(T^n\\right) + \\Delta t \\, P + \\Delta t \\, h_c A \\, T_{\\text{amb}}\\right) = 0.\n$$\n因为 $H(T) = m \\, h(T)$，所以 Newton 法所需的导数为：\n$$\nF'(T) = \\frac{dH}{dT}(T) + \\Delta t \\, h_c A = m \\left(c + L \\, f'(T)\\right) + \\Delta t \\, h_c A.\n$$\n根据构造，$c \\ge 0$，$L \\ge 0$，$f'(T) \\ge 0$，$m > 0$ 且 $\\Delta t \\, h_c A \\ge 0$。因此，\n$$\nF'(T)  0 \\quad \\text{对所有 } T,\n$$\n所以 $F(T)$ 是严格单调递增的。因此，该非线性方程存在唯一的 $T^{n+1}$ 解，并且总能通过取足够宽的界限来限定区间。\n\nNewton 迭代法：\n- 从一个初始猜测值 $T^{(0)}$（一个有物理动机的选择是 $T^{(0)} = T^n$）开始，迭代：\n$$\nT^{(k+1)} = T^{(k)} - \\frac{F\\!\\left(T^{(k)}\\right)}{F'\\!\\left(T^{(k)}\\right)}.\n$$\n- 收敛准则：\n  - 一个残差准则 $|F(T^{(k)})| \\le \\varepsilon_F$，其中 $\\varepsilon_F$ 是一个小的能量容差（单位：焦耳，例如 $\\varepsilon_F = 10^{-6}$ $\\mathrm{J}$），确保能量平衡得到满足。\n  - 一个步长准则 $|T^{(k+1)} - T^{(k)}| \\le \\varepsilon_T$（例如 $\\varepsilon_T = 10^{-8}$ $\\mathrm{K}$），确保迭代值没有明显变化。\n\n当 $\\frac{dH}{dT}$ 很大时的鲁棒性保障措施：\n- 区间限定与二分法回退：\n  - 因为 $F'(T)  0$，找到 $[T_{\\ell}, T_u]$ 使得 $F(T_{\\ell}) \\le 0 \\le F(T_u)$ 或反之。如果初始区间没有发生符号变化，则按几何级数扩大它，直到找到符号变化（或达到预定义的界限）。\n  - 在一个区间内，尝试一个 Newton 步。如果提议的 $T^{(k+1)}$ 超出区间或未能充分减小 $|F|$（例如，不满足一个简单的充分下降检验），则用一个二分步 $T^{(k+1)} = \\tfrac{1}{2}(T_{\\ell} + T_u)$ 替代它。根据新点的 $F$ 值的符号更新区间。\n- 线搜索阻尼：\n  - 在没有进行区间限定或当 $F'(T)$ 极大时（靠近 $T_m$ 且 $w$ 很小），对 Newton 步使用回溯线搜索以强制 $|F|$ 减小，即用 $\\alpha \\left(-F/F'\\right)$ 替换完整步长，其中 $\\alpha \\in (0,1]$ 会不断减小，直到 $|F|$ 相对于前一个迭代值减小为止。\n- 步长控制：\n  - 限制步长以避免非物理的跳跃（例如，信赖域式控制），并防止在计算 $\\tanh$ 和 $\\cosh$ 时出现数值溢出；注意，当 $|T - T_m|/w$ 很大时，$\\operatorname{sech}^2$ 会饱和到 $0$，这是良性的。\n- 导数正则性：\n  - 即使当 $\\frac{dH}{dT}$ 非常大时，$F'(T) = \\frac{dH}{dT} + \\Delta t \\, h_c A$ 仍然严格为正，这缓解了在 Newton 更新中除以接近零的数的问题。\n\n各案例的算法总结：\n- 计算恒定的右侧项 $C \\equiv H\\!\\left(T^n\\right) + \\Delta t \\, P + \\Delta t \\, h_c A \\, T_{\\text{amb}}$。\n- 定义 $F(T) = H(T) + \\Delta t \\, h_c A \\, T - C$ 和 $F'(T) = m \\left(c + L \\, f'(T)\\right) + \\Delta t \\, h_c A$。\n- 初始化 $T^{(0)} = T^n$。\n- 在 $\\min(T^n, T_{\\text{amb}}) - \\Delta$ 和 $\\max(T^n, T_{\\text{amb}}) + \\Delta$ 周围构造一个初始区间 $[T_{\\ell}, T_u]$，其中 $\\Delta$ 是某个温度值（单位：开尔文，例如 $\\Delta = 100$），然后扩大该区间直到 $F(T_{\\ell})$ 和 $F(T_u)$ 的符号相反。\n- 使用带有二分法和线搜索保障措施的 Newton 迭代法进行迭代，直到 $|F| \\le \\varepsilon_F$ 且 $| \\Delta T | \\le \\varepsilon_T$，或达到最大迭代次数（例如 $50$ 次）。\n- 报告 $T^{n+1}$（单位：开尔文），并四舍五入到六位小数。\n\n容差的理由：\n- 选择 $\\varepsilon_F = 10^{-6}$ $\\mathrm{J}$ 远低于由 $m c$ 乘以开尔文级别的温度变化所设定的典型能量尺度（量级约为 $10^{3}$ 到 $10^{5}$ $\\mathrm{J}$），这确保了能量平衡在实践中以远小于 $10^{-6}$ 的相对容差得到满足。\n- 选择 $\\varepsilon_T = 10^{-8}$ $\\mathrm{K}$ 保证了 Newton 迭代值稳定在一个远低于任何传感器分辨率或模型不确定性的温度上，因此主要作为数学上的终止准则，而不会影响物理真实性。\n- 最大迭代次数限制为 $50$ 次，对于带有二分法保障的光滑单调函数 $F(T)$，这个次数足以让 safeguarded Newton 方法收敛。\n\n测试套件涵盖：\n- 具有中等平滑度（$w = 2$ $\\mathrm{K}$）的标称 PCM 相变。\n- 急剧的相变（$w = 0.2$ $\\mathrm{K}$），在 $T_m$ 附近具有非常大的 $\\frac{dH}{dT}$，用于测试步长阻尼和二分法回退。\n- 线性情况（$L = 0$），此时该方法简化为求解一个严格的线性方程，在没有保障措施的情况下，一次 Newton 步即可收敛。\n- 负功率下跨越 $T_m$ 的冷却过程，确保在凝固期间的鲁棒性。\n- 具有大 $\\Delta t$ 和 $h_c A$ 的刚性步长，测试由线性汇项引起的条件数问题。\n\n最终程序实现了上述算法，评估了所有五个案例，并按要求打印单行输出，其中包含五个温度值（单位：开尔文），四舍五入到六位小数，用方括号括起来并用逗号分隔。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef melt_fraction(T, Tm, w):\n    \"\"\"Smooth melt fraction f(T) = 0.5 * (1 + tanh((T-Tm)/w)).\"\"\"\n    z = (T - Tm) / w\n    return 0.5 * (1.0 + np.tanh(z))\n\ndef dmelt_dT(T, Tm, w):\n    \"\"\"Derivative f'(T) = 0.5 * (1/w) * sech^2((T-Tm)/w).\"\"\"\n    z = (T - Tm) / w\n    # sech^2(z) = 1 / cosh^2(z). Use stable computation; large cosh - inf, 1/inf - 0.\n    cosh_z = np.cosh(z)\n    sech2 = 1.0 / (cosh_z * cosh_z)\n    return 0.5 * (1.0 / w) * sech2\n\ndef specific_enthalpy(T, c, L, Tref, Tm, w):\n    \"\"\"Specific enthalpy h(T) = c*(T - Tref) + L*f(T).\"\"\"\n    return c * (T - Tref) + L * melt_fraction(T, Tm, w)\n\ndef dhdT(T, c, L, Tm, w):\n    \"\"\"Derivative dh/dT = c + L*f'(T).\"\"\"\n    return c + L * dmelt_dT(T, Tm, w)\n\ndef newton_solve_temperature(m, c, L, Tref, Tm, w, hA, P, dt, Tamb, Tn):\n    \"\"\"\n    Solve F(T) = m*h(T) + dt*hA*T - (m*h(Tn) + dt*P + dt*hA*Tamb) = 0 for T.\n    Safeguarded Newton with bracketing, bisection fallback, and line-search damping.\n    \"\"\"\n    # Define H(T), F(T), and derivatives\n    def h(T):\n        return specific_enthalpy(T, c, L, Tref, Tm, w)\n\n    def dh(T):\n        return dhdT(T, c, L, Tm, w)\n\n    C = m * h(Tn) + dt * P + dt * hA * Tamb\n\n    def F(T):\n        return m * h(T) + dt * hA * T - C\n\n    def J(T):\n        return m * dh(T) + dt * hA\n\n    # Initial guess\n    T_curr = Tn\n\n    # Bracketing\n    # Start with a plausible bracket around known states and expand geometrically until sign change.\n    bracket_delta = 100.0  # Kelvin\n    T_low = min(Tn, Tamb) - bracket_delta\n    T_high = max(Tn, Tamb) + bracket_delta\n\n    F_low = F(T_low)\n    F_high = F(T_high)\n\n    # Expand bracket if no sign change\n    max_expand = 20\n    expand_count = 0\n    while F_low * F_high  0.0 and expand_count  max_expand:\n        width = T_high - T_low\n        T_low -= width\n        T_high += width\n        F_low = F(T_low)\n        F_high = F(T_high)\n        expand_count += 1\n\n    bracketed = (F_low * F_high) = 0.0\n\n    # Newton iteration with safeguards\n    tol_F = 1e-6      # Joule tolerance\n    tol_T = 1e-8      # Kelvin tolerance\n    max_iter = 50\n\n    for it in range(max_iter):\n        Fc = F(T_curr)\n        Jc = J(T_curr)\n\n        # Check residual convergence first\n        if abs(Fc) = tol_F:\n            break\n\n        # Avoid division by very small Jacobian (should not occur here since Jc  0 by construction)\n        if Jc == 0.0 or not np.isfinite(Jc):\n            # Fall back to bisection if bracketed, otherwise nudge temperature slightly\n            if bracketed:\n                T_next = 0.5 * (T_low + T_high)\n            else:\n                T_next = T_curr + 1e-6  # minimal perturbation\n        else:\n            # Proposed Newton step\n            newton_step = -Fc / Jc\n            T_proposed = T_curr + newton_step\n\n            if bracketed:\n                # Check if proposed step stays within bracket and reduces residual sufficiently\n                accepted = True\n                if not (T_low = T_proposed = T_high):\n                    accepted = False\n                else:\n                    F_prop = F(T_proposed)\n                    # Sufficient decrease check\n                    if abs(F_prop)  0.5 * abs(Fc):\n                        accepted = False\n                if accepted:\n                    T_next = T_proposed\n                else:\n                    # Bisection fallback\n                    T_next = 0.5 * (T_low + T_high)\n            else:\n                # No bracket: perform backtracking line search on Newton step\n                alpha = 1.0\n                T_next = T_proposed\n                F_next = F(T_next)\n                # Armijo-like decrease condition with small slope parameter\n                while abs(F_next)  (1.0 - 1e-4 * alpha) * abs(Fc) and alpha  (1.0 / 128.0):\n                    alpha *= 0.5\n                    T_next = T_curr + alpha * newton_step\n                    F_next = F(T_next)\n\n        # Update bracket if available\n        if bracketed:\n            F_next = F(T_next)\n            # Maintain bracket with sign test\n            if F_low * F_next = 0.0:\n                T_high = T_next\n                F_high = F_next\n            else:\n                T_low = T_next\n                F_low = F_next\n\n        # Step update\n        step = T_next - T_curr\n        T_curr = T_next\n\n        # Check both residual and step size convergence\n        if abs(F(T_curr)) = tol_F and abs(step) = tol_T:\n            break\n\n    return T_curr\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each test case is a tuple:\n    # (m, c, L, Tref, Tm, w, hA, P, dt, Tamb, Tn)\n    test_cases = [\n        (0.5, 2000.0, 200000.0, 300.0, 330.0, 2.0, 5.0, 50.0, 10.0, 300.0, 320.0),\n        (0.5, 2000.0, 200000.0, 300.0, 330.0, 0.2, 5.0, 50.0, 10.0, 300.0, 320.0),\n        (1.0, 1000.0, 0.0,     300.0, 330.0, 1.0, 2.0, 100.0, 5.0,  300.0, 305.0),\n        (0.3, 1800.0, 150000.0,300.0, 330.0, 1.0, 10.0,-20.0, 30.0, 300.0, 335.0),\n        (0.8, 2200.0, 250000.0,298.0, 335.0, 0.5, 50.0,200.0, 120.0,300.0, 334.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        m, c, L, Tref, Tm, w, hA, P, dt, Tamb, Tn = case\n        T_np1 = newton_solve_temperature(m, c, L, Tref, Tm, w, hA, P, dt, Tamb, Tn)\n        results.append(T_np1)\n\n    # Final print statement in the exact required format.\n    # Round to six decimal places, Kelvin.\n    formatted = \"[\" + \",\".join(f\"{val:.6f}\" for val in results) + \"]\"\n    print(formatted)\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}