{
    "hands_on_practices": [
        {
            "introduction": "Before we can optimize a battery's interaction with the grid, we must first build a reliable model of its physical behavior. This practice guides you in exploring the battery's fundamental electrical dynamics using a standard Thevenin equivalent circuit model. By deriving the voltage transient and heat generation from first principles, you will gain a crucial understanding of the physical constraints, such as voltage limits and thermal effects, that any advanced V2G optimization strategy must respect .",
            "id": "3959487",
            "problem": "An aggregator designs a fast-timescale control for Vehicle-to-Grid (V2G) power exchanges using an automated battery design and simulation environment. To ensure that a scheduling optimizer respects electrical and thermal limits, the aggregator models each electric vehicle battery pack with a one-branch Thevenin equivalent circuit model comprising an open-circuit source, a series ohmic resistance, and a single parallel resistor-capacitor polarization branch. The Thevenin model parameters are given as follows: the series ohmic resistance is $R_{0}=50\\ \\text{m}\\Omega$, the polarization capacitance is $C_{1}=2000\\ \\text{F}$, the polarization time constant is $\\tau_{1}=200\\ \\text{s}$, and the open-circuit voltage is $E(\\text{SoC})=400\\ \\text{V}$ and may be treated as constant over the short transient because the state of charge does not change appreciably. At time $t=0$, the grid operator issues a discharge current step command of magnitude $i=15\\ \\text{A}$ (positive for discharge) that is held constant for $t \\ge 0$. Before $t=0$, the cell rests at open circuit for a long time, so the polarization branch is fully relaxed with the initial polarization voltage equal to zero.\n\nUsing only Kirchhoff’s laws, the capacitor constitutive relation $i_{C}=C\\,dv/dt$, and Ohm’s law $v=Ri$, and neglecting reversible (entropic) heat due to the assumption that $E(\\text{SoC})$ is constant and independent of temperature over this timescale, derive from first principles the closed-form expressions for:\n- the terminal voltage transient $V(t)$ for $t \\ge 0$, and\n- the instantaneous heat generation rate $\\dot{Q}(t)$ due to Joule heating in both the series ohmic resistance and the polarization resistance.\n\nAssume the standard Thevenin one-resistor–one-capacitor structure in which the terminal voltage is given by the open-circuit source minus the series ohmic drop and minus the polarization voltage across the resistor-capacitor branch. The resistor in the polarization branch is denoted $R_{1}$ and satisfies $R_{1}C_{1}=\\tau_{1}$.\n\nProvide your final expressions as a single row matrix with the first entry equal to $V(t)$ and the second entry equal to $\\dot{Q}(t)$, both valid for all $t \\ge 0$. Express $V(t)$ in volts and $\\dot{Q}(t)$ in watts. No numerical rounding is required; provide exact closed-form expressions in terms of $t$ using the given parameter values.",
            "solution": "The problem is valid as it is scientifically grounded in standard electrical circuit theory, well-posed with sufficient data and clear objectives, and free of contradictions or ambiguities. We proceed with the derivation.\n\nThe battery is modeled by a one-branch Thevenin equivalent circuit. It consists of a constant open-circuit voltage source $E$, a series ohmic resistance $R_0$, and a parallel branch containing a polarization resistance $R_1$ and a polarization capacitance $C_1$. For time $t \\ge 0$, a constant discharge current $i$ is drawn from the terminals.\n\nThe terminal voltage $V(t)$ is given by the open-circuit voltage minus the voltage drops across the series resistance and the polarization branch:\n$$V(t) = E - V_0(t) - V_1(t)$$\nwhere $V_0(t)$ is the voltage drop across $R_0$ and $V_1(t)$ is the voltage across the parallel $R_1C_1$ branch.\n\nThe voltage drop across the series ohmic resistor $R_0$ is given by Ohm's law:\n$$V_0(t) = i R_0$$\nSince the current $i$ is a constant step of $15 \\text{ A}$ for $t \\ge 0$, $V_0(t)$ is also constant for $t \\ge 0$.\n\nThe total current $i$ flows into the polarization branch and splits into a current through the resistor, $i_{R1}(t)$, and a current through the capacitor, $i_{C1}(t)$. By Kirchhoff's Current Law (KCL):\n$$i = i_{R1}(t) + i_{C1}(t)$$\nThe current through the resistor $R_1$ is $i_{R1}(t) = V_1(t) / R_1$, and the current through the capacitor $C_1$ is $i_{C1}(t) = C_1 \\frac{dV_1(t)}{dt}$. Substituting these into the KCL equation yields a first-order linear ordinary differential equation for the polarization voltage $V_1(t)$:\n$$i = \\frac{V_1(t)}{R_1} + C_1 \\frac{dV_1(t)}{dt}$$\nRearranging this into standard form gives:\n$$\\frac{dV_1(t)}{dt} + \\frac{1}{R_1 C_1} V_1(t) = \\frac{i}{C_1}$$\nThe term $R_1 C_1$ is the polarization time constant, $\\tau_1$. The equation becomes:\n$$\\frac{dV_1(t)}{dt} + \\frac{1}{\\tau_1} V_1(t) = \\frac{i}{C_1}$$\nThe general solution to this differential equation is the sum of the homogeneous solution $V_{1,h}(t)$ and a particular solution $V_{1,p}(t)$. The homogeneous equation is $\\frac{dV_{1,h}}{dt} + \\frac{1}{\\tau_1} V_{1,h} = 0$, which has the solution $V_{1,h}(t) = A \\exp(-t/\\tau_1)$ for some constant $A$. For the constant forcing term $i/C_1$, we assume a constant particular solution $V_{1,p}(t) = K$. Substituting this into the ODE gives $0 + K/\\tau_1 = i/C_1$, so $K = i \\tau_1 / C_1 = i (R_1 C_1) / C_1 = i R_1$.\nThe general solution for the polarization voltage is:\n$$V_1(t) = A \\exp\\left(-\\frac{t}{\\tau_1}\\right) + i R_1$$\nWe use the initial condition that the polarization branch is fully relaxed at $t=0$, meaning $V_1(0) = 0$.\n$$V_1(0) = A \\exp(0) + i R_1 = A + i R_1 = 0 \\implies A = -i R_1$$\nThus, the specific solution for the polarization voltage for $t \\ge 0$ is:\n$$V_1(t) = i R_1 \\left(1 - \\exp\\left(-\\frac{t}{\\tau_1}\\right)\\right)$$\nNow, we can write the final expression for the terminal voltage $V(t)$:\n$$V(t) = E - i R_0 - i R_1 \\left(1 - \\exp\\left(-\\frac{t}{\\tau_1}\\right)\\right)$$\nLet's substitute the given numerical values: $E = 400 \\text{ V}$, $i = 15 \\text{ A}$, $R_0 = 50 \\text{ m}\\Omega = 0.05 \\ \\Omega$, $C_1 = 2000 \\text{ F}$, and $\\tau_1 = 200 \\text{ s}$. First, we calculate the polarization resistance $R_1$:\n$$R_1 = \\frac{\\tau_1}{C_1} = \\frac{200 \\text{ s}}{2000 \\text{ F}} = 0.1 \\ \\Omega$$\nNow, substitute the values into the expression for $V(t)$:\n$$V(t) = 400 - (15)(0.05) - (15)(0.1) \\left(1 - \\exp\\left(-\\frac{t}{200}\\right)\\right)$$\n$$V(t) = 400 - 0.75 - 1.5 \\left(1 - \\exp\\left(-\\frac{t}{200}\\right)\\right)$$\n$$V(t) = 399.25 - 1.5 + 1.5 \\exp\\left(-\\frac{t}{200}\\right)$$\n$$V(t) = 397.75 + 1.5 \\exp\\left(-\\frac{t}{200}\\right)$$\nThis is the closed-form expression for the terminal voltage in volts for $t \\ge 0$.\n\nNext, we derive the expression for the instantaneous heat generation rate $\\dot{Q}(t)$ due to Joule heating in both resistors $R_0$ and $R_1$. The total heat rate is the sum of the power dissipated in each resistor:\n$$\\dot{Q}(t) = P_{R0}(t) + P_{R1}(t)$$\nThe power dissipated in the series resistor $R_0$ is constant for $t \\ge 0$ since the current $i$ is constant:\n$$P_{R0}(t) = i^2 R_0$$\nThe power dissipated in the polarization resistor $R_1$ depends on the current flowing through it, $i_{R1}(t)$:\n$$P_{R1}(t) = (i_{R1}(t))^2 R_1$$\nThe current $i_{R1}(t)$ is given by Ohm's law applied to the polarization branch:\n$$i_{R1}(t) = \\frac{V_1(t)}{R_1} = \\frac{i R_1}{R_1} \\left(1 - \\exp\\left(-\\frac{t}{\\tau_1}\\right)\\right) = i \\left(1 - \\exp\\left(-\\frac{t}{\\tau_1}\\right)\\right)$$\nTherefore, the power dissipated in $R_1$ is:\n$$P_{R1}(t) = \\left[i \\left(1 - \\exp\\left(-\\frac{t}{\\tau_1}\\right)\\right)\\right]^2 R_1 = i^2 R_1 \\left(1 - \\exp\\left(-\\frac{t}{\\tau_1}\\right)\\right)^2$$\nThe total instantaneous heat generation rate is the sum of the two power terms:\n$$\\dot{Q}(t) = i^2 R_0 + i^2 R_1 \\left(1 - \\exp\\left(-\\frac{t}{\\tau_1}\\right)\\right)^2$$\n$$\\dot{Q}(t) = i^2 \\left[ R_0 + R_1 \\left(1 - \\exp\\left(-\\frac{t}{\\tau_1}\\right)\\right)^2 \\right]$$\nNow, we substitute the numerical values: $i=15 \\text{ A}$, $R_0=0.05 \\ \\Omega$, $R_1=0.1 \\ \\Omega$, and $\\tau_1=200 \\text{ s}$.\n$$i^2 = (15)^2 = 225 \\text{ A}^2$$\n$$P_{R0} = (225)(0.05) = 11.25 \\text{ W}$$\n$$P_{R1}(t) = (225)(0.1) \\left(1 - \\exp\\left(-\\frac{t}{200}\\right)\\right)^2 = 22.5 \\left(1 - \\exp\\left(-\\frac{t}{200}\\right)\\right)^2$$\nSo, the total heat generation rate in watts is:\n$$\\dot{Q}(t) = 11.25 + 22.5 \\left(1 - \\exp\\left(-\\frac{t}{200}\\right)\\right)^2$$\nThis is the closed-form expression for the total instantaneous heat generation rate for $t \\ge 0$.\nThe two required expressions are $V(t) = 397.75 + 1.5 \\exp\\left(-\\frac{t}{200}\\right)$ and $\\dot{Q}(t) = 11.25 + 22.5 \\left(1 - \\exp\\left(-\\frac{t}{200}\\right)\\right)^2$.",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n397.75 + 1.5 \\exp\\left(-\\frac{t}{200}\\right) & 11.25 + 22.5 \\left(1 - \\exp\\left(-\\frac{t}{200}\\right)\\right)^2\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "Having modeled the battery's physical constraints, we can now tackle the central economic challenge of Vehicle-to-Grid operation: optimal scheduling. This exercise challenges you to formulate this complex decision-making process as a Mixed-Integer Linear Program (MILP), a powerful tool for resource allocation. You will learn to translate real-world objectives—minimizing costs from energy arbitrage, battery degradation, and grid connection—into a structured mathematical framework, laying the groundwork for developing intelligent V2G strategies .",
            "id": "3959482",
            "problem": "You are asked to derive, implement, and solve a mixed-integer linear optimization for a Vehicle-to-Grid (V2G) scheduling problem grounded in first principles of energy conservation and linear device constraints. Consider a fleet of electric vehicles indexed by $v \\in \\mathcal{V}$ and discrete time steps indexed by $t \\in \\mathcal{T}$. The fundamental base is the State of Charge (SoC) dynamics from energy balance and linear power constraints with binary connectivity decisions. You must derive a Mixed-Integer Linear Program (MILP) whose decision variables are the binary connection state $x_{v,t} \\in \\{0,1\\}$ and the continuous power variables $P_{v,t}$ per vehicle per time step, enforce availability constraints, and integrate the SoC dynamics. Your final program must enumerate the binary decisions over availability windows and solve the resulting continuous subproblems as linear programs to optimality.\n\nUse the following fundamental bases:\n- Energy conservation for State of Charge (SoC): State of Charge (SoC) $s_{v,t}$ is the fraction of stored energy in the battery of vehicle $v$ at time $t$, defined on the interval $[0,1]$.\n- Discrete-time energy balance over time step $\\Delta t$: Charging and discharging affect $s_{v,t}$ proportionally to power and inversely to usable energy.\n- Linear device constraints: Power limits scale with connectivity, and SoC is bounded.\n\nDefine the model as follows.\n- Variables:\n  - Binary connectivity $x_{v,t} \\in \\{0,1\\}$ indicating whether vehicle $v$ is physically connected and can exchange power at time $t$.\n  - Nonnegative charging power $P^{+}_{v,t} \\ge 0$ and nonnegative discharging power $P^{-}_{v,t} \\ge 0$, with net power $P_{v,t} = P^{+}_{v,t} - P^{-}_{v,t}$.\n  - State of Charge (SoC) $s_{v,t} \\in [0,1]$.\n- Parameters (given):\n  - Availability window $a_{v,t} \\in \\{0,1\\}$.\n  - Usable energy capacity $E_{v}$ in $\\mathrm{kWh}$.\n  - Maximum charging power $\\bar{P}^{+}_{v}$ in $\\mathrm{kW}$.\n  - Maximum discharging power $\\bar{P}^{-}_{v}$ in $\\mathrm{kW}$.\n  - Charging efficiency $\\eta^{+}_{v} \\in (0,1]$ and discharging efficiency $\\eta^{-}_{v} \\in (0,1]$.\n  - Electricity price $c_{t}$ in dollars per $\\mathrm{kWh}$.\n  - Degradation penalty coefficient $\\alpha_{v}$ in dollars per $\\mathrm{kWh}$ of throughput.\n  - Connection overhead per time step $\\gamma_{v}$ in dollars.\n  - Initial SoC $s_{v,0} \\in [0,1]$; SoC bounds $s^{\\min}_{v}, s^{\\max}_{v} \\in [0,1]$; terminal SoC requirement $s^{\\mathrm{req}}_{v} \\in [0,1]$.\n  - Time step $\\Delta t$ in hours.\n- Constraints to derive using first principles:\n  - Availability: $x_{v,t} \\le a_{v,t}$ for all $v,t$.\n  - Power gating: $0 \\le P^{+}_{v,t} \\le \\bar{P}^{+}_{v} x_{v,t}$ and $0 \\le P^{-}_{v,t} \\le \\bar{P}^{-}_{v} x_{v,t}$ for all $v,t$.\n  - SoC dynamics: $s_{v,t+1} = s_{v,t} + \\dfrac{\\eta^{+}_{v} \\Delta t}{E_{v}} P^{+}_{v,t} - \\dfrac{\\Delta t}{\\eta^{-}_{v} E_{v}} P^{-}_{v,t}$ for all $v$ and all $t$ in $\\{0,\\dots,|\\mathcal{T}|-1\\}$.\n  - SoC bounds: $s^{\\min}_{v} \\le s_{v,t} \\le s^{\\max}_{v}$ for all $v,t$, and $s_{v,0} = \\text{given}$.\n  - Terminal requirement: $s_{v,|\\mathcal{T}|} \\ge s^{\\mathrm{req}}_{v}$ for all $v$.\n- Objective to derive and implement: minimize the total monetary cost over the horizon, defined as the sum of energy purchase cost minus energy sale revenue, plus linear degradation and connection overhead penalties. Formally, minimize\n  $$\\sum_{t \\in \\mathcal{T}} \\sum_{v \\in \\mathcal{V}} \\left[ c_{t} \\Delta t \\left(P^{+}_{v,t} - P^{-}_{v,t}\\right) + \\alpha_{v} \\Delta t \\left(P^{+}_{v,t} + P^{-}_{v,t}\\right) + \\gamma_{v} x_{v,t} \\right].$$\nGiven the binary nature of $x_{v,t}$ and the linear continuous constraints, this is a mixed-integer linear program. Your program must exhaustively enumerate $x_{v,t}$ patterns consistent with $a_{v,t}$ and, for each pattern, solve the continuous subproblem (the linear program with fixed $x_{v,t}$) to global optimality. Select the pattern with minimal total cost. Because the test instances are small, exhaustive enumeration is tractable.\n\nPhysical units and output specification:\n- Power $P^{+}_{v,t}, P^{-}_{v,t}$ must be handled in $\\mathrm{kW}$.\n- Energy capacity $E_{v}$ must be handled in $\\mathrm{kWh}$.\n- Price $c_{t}$ is in dollars per $\\mathrm{kWh}$.\n- Time step $\\Delta t$ is in hours.\n- State of Charge $s_{v,t}$ is dimensionless in $[0,1]$.\n- Express each optimal total cost in dollars, rounded to $3$ decimal places.\n\nTest suite. Implement your program to compute and output the optimal total cost for each of the following parameter sets:\n\n- Test case $1$ (general case):\n  - $|\\mathcal{V}| = 2$, $|\\mathcal{T}| = 3$, $\\Delta t = 1$.\n  - Prices $c_{t} = [0.15, 0.25, 0.20]$ in dollars per $\\mathrm{kWh}$.\n  - Vehicle $1$: $E_{1} = 60$, $\\bar{P}^{+}_{1} = 7.2$, $\\bar{P}^{-}_{1} = 5.0$, $\\eta^{+}_{1} = 0.95$, $\\eta^{-}_{1} = 0.95$, $s_{1,0} = 0.50$, $s^{\\min}_{1} = 0.20$, $s^{\\max}_{1} = 0.90$, $s^{\\mathrm{req}}_{1} = 0.60$, $\\alpha_{1} = 0.01$, $\\gamma_{1} = 0.02$.\n  - Vehicle $2$: $E_{2} = 75$, $\\bar{P}^{+}_{2} = 11.0$, $\\bar{P}^{-}_{2} = 8.0$, $\\eta^{+}_{2} = 0.90$, $\\eta^{-}_{2} = 0.90$, $s_{2,0} = 0.60$, $s^{\\min}_{2} = 0.30$, $s^{\\max}_{2} = 0.90$, $s^{\\mathrm{req}}_{2} = 0.65$, $\\alpha_{2} = 0.015$, $\\gamma_{2} = 0.02$.\n  - Availability $a_{v,t}$: vehicle $1$ is available at $t = 0,1$ and unavailable at $t = 2$; vehicle $2$ is available at $t = 1,2$ and unavailable at $t = 0$.\n- Test case $2$ (boundary with negative price):\n  - $|\\mathcal{V}| = 1$, $|\\mathcal{T}| = 4$, $\\Delta t = 1$.\n  - Prices $c_{t} = [-0.05, 0.10, 0.18, 0.12]$ in dollars per $\\mathrm{kWh}$.\n  - Vehicle $1$: $E_{1} = 75$, $\\bar{P}^{+}_{1} = 7.0$, $\\bar{P}^{-}_{1} = 7.0$, $\\eta^{+}_{1} = 0.92$, $\\eta^{-}_{1} = 0.92$, $s_{1,0} = 0.40$, $s^{\\min}_{1} = 0.30$, $s^{\\max}_{1} = 0.95$, $s^{\\mathrm{req}}_{1} = 0.50$, $\\alpha_{1} = 0.01$, $\\gamma_{1} = 0.01$.\n  - Availability $a_{1,t} = 1$ for all $t$ in $\\{0,1,2,3\\}$.\n- Test case $3$ (edge with high degradation cost):\n  - $|\\mathcal{V}| = 2$, $|\\mathcal{T}| = 2$, $\\Delta t = 1$.\n  - Prices $c_{t} = [0.20, 0.22]$ in dollars per $\\mathrm{kWh}$.\n  - Vehicle $1$: $E_{1} = 60$, $\\bar{P}^{+}_{1} = 7.2$, $\\bar{P}^{-}_{1} = 5.0$, $\\eta^{+}_{1} = 0.95$, $\\eta^{-}_{1} = 0.95$, $s_{1,0} = 0.79$, $s^{\\min}_{1} = 0.20$, $s^{\\max}_{1} = 0.95$, $s^{\\mathrm{req}}_{1} = 0.80$, $\\alpha_{1} = 1.0$, $\\gamma_{1} = 0.00$.\n  - Vehicle $2$: $E_{2} = 60$, $\\bar{P}^{+}_{2} = 7.2$, $\\bar{P}^{-}_{2} = 5.0$, $\\eta^{+}_{2} = 0.95$, $\\eta^{-}_{2} = 0.95$, $s_{2,0} = 0.85$, $s^{\\min}_{2} = 0.20$, $s^{\\max}_{2} = 0.95$, $s^{\\mathrm{req}}_{2} = 0.85$, $\\alpha_{2} = 1.0$, $\\gamma_{2} = 0.00$.\n  - Availability $a_{1,t} = 1$ for $t \\in \\{0,1\\}$; availability $a_{2,t} = 0$ for $t \\in \\{0,1\\}$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example, $\"[r_{1},r_{2},r_{3}]\"$, where each $r_{i}$ is the optimal total cost in dollars for test case $i$, rounded to $3$ decimal places.",
            "solution": "The user has provided a well-defined Vehicle-to-Grid (V2G) optimization problem. The first step is to validate the problem statement.\n\n### Step 1: Extract Givens\n\n**Sets and Indices:**\n-   Vehicles: $v \\in \\mathcal{V}$.\n-   Discrete time steps: $t \\in \\mathcal{T} = \\{0, 1, \\dots, |\\mathcal{T}|-1\\}$.\n\n**Decision Variables:**\n-   Binary connectivity: $x_{v,t} \\in \\{0,1\\}$.\n-   Nonnegative charging power: $P^{+}_{v,t} \\ge 0$ in $\\mathrm{kW}$.\n-   Nonnegative discharging power: $P^{-}_{v,t} \\ge 0$ in $\\mathrm{kW}$.\n-   State of Charge (SoC): $s_{v,t} \\in [0,1]$.\n\n**Parameters:**\n-   Availability window: $a_{v,t} \\in \\{0,1\\}$.\n-   Usable energy capacity: $E_{v}$ in $\\mathrm{kWh}$.\n-   Maximum charging power: $\\bar{P}^{+}_{v}$ in $\\mathrm{kW}$.\n-   Maximum discharging power: $\\bar{P}^{-}_{v}$ in $\\mathrm{kW}$.\n-   Charging efficiency: $\\eta^{+}_{v} \\in (0,1]$.\n-   Discharging efficiency: $\\eta^{-}_{v} \\in (0,1]$.\n-   Electricity price: $c_{t}$ in dollars per $\\mathrm{kWh}$.\n-   Degradation penalty coefficient: $\\alpha_{v}$ in dollars per $\\mathrm{kWh}$.\n-   Connection overhead: $\\gamma_{v}$ in dollars per time step.\n-   Initial SoC: $s_{v,0} \\in [0,1]$.\n-   SoC bounds: $s^{\\min}_{v}, s^{\\max}_{v} \\in [0,1]$.\n-   Terminal SoC requirement: $s^{\\mathrm{req}}_{v} \\in [0,1]$.\n-   Time step duration: $\\Delta t$ in hours.\n\n**Constraints (to be formally derived):**\n1.  Availability: $x_{v,t} \\le a_{v,t}$.\n2.  Power gating: $0 \\le P^{+}_{v,t} \\le \\bar{P}^{+}_{v} x_{v,t}$ and $0 \\le P^{-}_{v,t} \\le \\bar{P}^{-}_{v} x_{v,t}$.\n3.  SoC dynamics: $s_{v,t+1} = s_{v,t} + \\dfrac{\\eta^{+}_{v} \\Delta t}{E_{v}} P^{+}_{v,t} - \\dfrac{\\Delta t}{\\eta^{-}_{v} E_{v}} P^{-}_{v,t}$.\n4.  SoC bounds: $s^{\\min}_{v} \\le s_{v,t} \\le s^{\\max}_{v}$ for all $t > 0$, and $s_{v,0}$ is fixed.\n5.  Terminal requirement: $s_{v,|\\mathcal{T}|} \\ge s^{\\mathrm{req}}_{v}$.\n\n**Objective Function (to be formally derived):**\n-   Minimize total cost: $\\sum_{t \\in \\mathcal{T}} \\sum_{v \\in \\mathcal{V}} \\left[ c_{t} \\Delta t \\left(P^{+}_{v,t} - P^{-}_{v,t}\\right) + \\alpha_{v} \\Delta t \\left(P^{+}_{v,t} + P^{-}_{v,t}\\right) + \\gamma_{v} x_{v,t} \\right]$.\n\n**Solution Method:**\n-   Exhaustively enumerate all binary patterns for $x_{v,t}$ consistent with $a_{v,t}$.\n-   For each pattern, solve the resulting continuous subproblem (a Linear Program) to optimality.\n-   Select the pattern yielding the minimum total cost.\n\n**Test Cases:**\n-   Three specific test cases with all parameters provided.\n\n**Output Format:**\n-   A single line with a comma-separated list of optimal costs for each test case, rounded to $3$ decimal places, enclosed in square brackets. Example: `[r1,r2,r3]`.\n\n### Step 2: Validate Using Extracted Givens\n\n-   **Scientifically Grounded (Critical):** The problem is based on the fundamental principle of energy conservation, represented by the State of Charge (SoC) balance equation. The constraints for power limits and SoC bounds are standard in battery and power systems modeling. The economic objective function is a conventional representation of costs in energy markets. The model is scientifically sound and realistic.\n-   **Well-Posed:** The problem is a Mixed-Integer Linear Program (MILP). The specified solution method, exhaustive enumeration of binary variables for small instances, is a valid (though not generally scalable) method to find the global optimum. Each resulting continuous subproblem is a Linear Program (LP), which is convex and for which standard solvers can find a unique optimal solution if one exists. The problem structure is well-posed.\n-   **Objective (Critical):** The problem is stated using precise mathematical language and unambiguous definitions for all variables, parameters, and constraints. It is free of subjective or opinion-based claims.\n-   **Completeness and Consistency:** All necessary parameters are provided for each test case. The units ($\\mathrm{kW}$, $\\mathrm{kWh}$, $\\mathrm{h}$, `\\$`) are consistent with the physical and economic relationships defined in the model. For instance, the product $c_t \\Delta t P_{v,t}$ has units $(\\$/\\mathrm{kWh}) \\cdot \\mathrm{h} \\cdot \\mathrm{kW} = \\$`, which is correct for a cost term. There are no contradictions in the problem statement.\n\n### Step 3: Verdict and Action\nThe problem statement is valid. It is scientifically grounded, well-posed, objective, and complete. I will proceed with the solution.\n\n### Derivation and Formulation\n\nThe problem is a Mixed-Integer Linear Program (MILP) aimed at minimizing the total operational cost of a fleet of electric vehicles participating in Vehicle-to-Grid services. We will first formalize the derivation of the model components and then detail the solution algorithm.\n\n**1. Model Derivation**\n\nThe model is built upon three pillars: energy balance, linear device constraints, and economic costs.\n\n-   **State of Charge (SoC) Dynamics:** The SoC, $s_{v,t}$, represents the ratio of stored energy to the total usable capacity $E_v$. The change in stored energy over a time step $\\Delta t$ is the net energy flow into the battery. When charging with power $P^{+}_{v,t}$, the energy added to the battery is $\\eta^{+}_{v} P^{+}_{v,t} \\Delta t$, where $\\eta^{+}_{v}$ is the charging efficiency. When discharging with power $P^{-}_{v,t}$, the energy removed from the battery is $(1/\\eta^{-}_{v}) P^{-}_{v,t} \\Delta t$, where the energy delivered to the grid is $P^{-}_{v,t} \\Delta t$ and $\\eta^{-}_{v}$ is the discharging efficiency.\n    The change in SoC is the change in stored energy divided by the capacity $E_v$:\n    $$s_{v,t+1} - s_{v,t} = \\frac{\\eta^{+}_{v} P^{+}_{v,t} \\Delta t - (1/\\eta^{-}_{v}) P^{-}_{v,t} \\Delta t}{E_v}$$\n    Rearranging gives the provided state transition equation:\n    $$s_{v,t+1} = s_{v,t} + \\frac{\\eta^{+}_{v} \\Delta t}{E_v} P^{+}_{v,t} - \\frac{\\Delta t}{\\eta^{-}_{v} E_v} P^{-}_{v,t}$$\n\n-   **Power Constraints:** The binary variable $x_{v,t}$ acts as a switch. If a vehicle is not connected ($x_{v,t}=0$), no power can be exchanged, so $P^{+}_{v,t}=0$ and $P^{-}_{v,t}=0$. If it is connected ($x_{v,t}=1$), the power is limited by the vehicle's hardware, $\\bar{P}^{+}_{v}$ and $\\bar{P}^{-}_{v}$. This is captured by the \"power gating\" constraints:\n    $$0 \\le P^{+}_{v,t} \\le \\bar{P}^{+}_{v} x_{v,t}$$\n    $$0 \\le P^{-}_{v,t} \\le \\bar{P}^{-}_{v} x_{v,t}$$\n    Additionally, a vehicle can only be connected if it is physically available, requiring $x_{v,t} \\le a_{v,t}$. Since $x_{v,t}$ is binary, this enforces that $x_{v,t}$ can only be $1$ if $a_{v,t}$ is $1$.\n\n-   **Objective Function:** The total cost is the sum of three components, aggregated over all vehicles and time steps.\n    1.  **Energy Cost:** The net cost of electricity is the price $c_t$ multiplied by the net energy drawn from the grid, which is $(P^{+}_{v,t} - P^{-}_{v,t}) \\Delta t$.\n    2.  **Degradation Cost:** Battery degradation is often modeled as proportional to the total energy throughput. The power throughput is $P^{+}_{v,t} + P^{-}_{v,t}$, so the energy throughput is $(P^{+}_{v,t} + P^{-}_{v,t}) \\Delta t$. The associated cost is $\\alpha_v$ times this value.\n    3.  **Connection Cost:** A fixed cost $\\gamma_v$ is incurred for each time step the vehicle is connected, modeled as $\\gamma_v x_{v,t}$.\n\n    Summing these terms yields the objective function. We can group terms by the decision variables $P^{+}$ and $P^{-}$:\n    $$\\min \\sum_{v,t} \\left[ \\Delta t (c_t + \\alpha_v) P^{+}_{v,t} + \\Delta t (\\alpha_v - c_t) P^{-}_{v,t} + \\gamma_v x_{v,t} \\right]$$\n\n**2. Solution Strategy: Enumeration and Linear Programming**\n\nAs stipulated, we solve the MILP by enumerating all valid combinations of the binary variables $x_{v,t}$ and solving the resulting LP for the continuous variables for each combination.\n\nFor a fixed binary pattern $\\mathbf{x} = \\{x_{v,t}\\}$, the problem becomes a Linear Program (LP). The variables of this LP are the continuous variables $\\{P^{+}_{v,t}, P^{-}_{v,t}, s_{v,t}\\}$ for all $v \\in \\mathcal{V}$ and $t \\in \\mathcal{T}$.\n\nThe LP subproblem for a given $\\mathbf{x}$ is:\n$$\\text{Minimize} \\quad \\sum_{v,t} \\left[ \\Delta t (c_t + \\alpha_v) P^{+}_{v,t} + \\Delta t (\\alpha_v - c_t) P^{-}_{v,t} \\right] + \\underbrace{\\sum_{v,t} \\gamma_v x_{v,t}}_{\\text{constant}}$$\nSubject to:\n1.  $0 \\le P^{+}_{v,t} \\le \\bar{P}^{+}_{v} x_{v,t}$ (where $x_{v,t}$ is a fixed $0$ or $1$)\n2.  $0 \\le P^{-}_{v,t} \\le \\bar{P}^{-}_{v} x_{v,t}$ (where $x_{v,t}$ is a fixed $0$ or $1$)\n3.  $s_{v,t+1} - s_{v,t} - \\frac{\\eta^{+}_{v} \\Delta t}{E_v} P^{+}_{v,t} + \\frac{\\Delta t}{\\eta^{-}_{v} E_v} P^{-}_{v,t} = 0 \\quad (\\text{for } t=0, \\dots, |\\mathcal{T}|-1)$\n4.  $s^{\\min}_{v} \\le s_{v,t} \\le s^{\\max}_{v} \\quad (\\text{for } t=1, \\dots, |\\mathcal{T}|)$\n5.  $s_{v,|\\mathcal{T}|} \\ge s^{\\mathrm{req}}_{v}$\n\nThis LP can be solved using a standard solver like `scipy.optimize.linprog`.\n\n**3. Implementation using `scipy.optimize.linprog`**\n\nTo use `scipy.optimize.linprog`, we must formulate the LP in the standard form: $\\min \\mathbf{c}^T \\mathbf{z}$ subject to $\\mathbf{A}_{\\text{ub}} \\mathbf{z} \\le \\mathbf{b}_{\\text{ub}}$, $\\mathbf{A}_{\\text{eq}} \\mathbf{z} = \\mathbf{b}_{\\text{eq}}$, and $\\mathbf{lb} \\le \\mathbf{z} \\le \\mathbf{ub}$.\n\n-   **Decision Vector $\\mathbf{z}$:** We flatten the continuous variables into a single vector $\\mathbf{z}$. For $V=|\\mathcal{V}|$ vehicles and $T=|\\mathcal{T}|$ time horizons, the vector can be structured as:\n    $$\\mathbf{z} = [P^{+}_{0,0}, \\dots, P^{+}_{V-1,T-1}, \\quad P^{-}_{0,0}, \\dots, P^{-}_{V-1,T-1}, \\quad s_{0,1}, \\dots, s_{V-1,T}]$$\n    The total number of variables is $3VT$.\n\n-   **Objective Vector $\\mathbf{c}$:** The coefficients in $\\mathbf{c}$ correspond to the objective function. For a variable $P^{+}_{v,t}$, the coefficient is $\\Delta t (c_t + \\alpha_v)$. For $P^{-}_{v,t}$, it is $\\Delta t (\\alpha_v - c_t)$. For all $s_{v,t}$ variables, the coefficients are $0$. The fixed-cost part $\\sum \\gamma_v x_{v,t}$ is added to the LP optimal value `result.fun` after solving.\n\n-   **Bounds ($\\mathbf{lb}, \\mathbf{ub}$):**\n    -   For $P^{+}_{v,t}$: $[0, \\bar{P}^{+}_{v} x_{v,t}]$\n    -   For $P^{-}_{v,t}$: $[0, \\bar{P}^{-}_{v} x_{v,t}]$\n    -   For $s_{v,t}$: $[s^{\\min}_{v}, s^{\\max}_{v}]$\n\n-   **Equality Constraints ($\\mathbf{A}_{\\text{eq}}, \\mathbf{b}_{\\text{eq}}$):** These represent the SoC dynamics. For each vehicle $v$ and time step $t \\in \\{0, \\dots, T-1\\}$, we have one equation:\n    -   For $t=0$: $s_{v,1} - (\\frac{\\eta^{+}_{v}\\Delta t}{E_v})P^{+}_{v,0} + (\\frac{\\Delta t}{\\eta^{-}_{v}E_v})P^{-}_{v,0} = s_{v,0}$\n    -   For $t>0$: $s_{v,t+1} - s_{v,t} - (\\frac{\\eta^{+}_{v}\\Delta t}{E_v})P^{+}_{v,t} + (\\frac{\\Delta t}{\\eta^{-}_{v}E_v})P^{-}_{v,t} = 0$\n    These equations define the rows of $\\mathbf{A}_{\\text{eq}}$ and elements of $\\mathbf{b}_{\\text{eq}}$.\n\n-   **Inequality Constraints ($\\mathbf{A}_{\\text{ub}}, \\mathbf{b}_{\\text{ub}}$):** These capture the terminal SoC requirement $s_{v,T} \\ge s^{\\mathrm{req}}_{v}$, which is rewritten as $-s_{v,T} \\le -s^{\\mathrm{req}}_{v}$. For each vehicle $v$, we add a row to $\\mathbf{A}_{\\text{ub}}$ with a $-1$ at the position corresponding to $s_{v,T}$ and a corresponding entry $-s^{\\mathrm{req}}_{v}$ in $\\mathbf{b}_{\\text{ub}}$.\n\nThe overall algorithm consists of an outer loop that generates each valid binary pattern $\\mathbf{x}$, and an inner part that constructs and solves the above LP. The minimum cost found across all patterns is the solution.",
            "answer": "```python\nimport numpy as np\nfrom scipy.optimize import linprog\nimport itertools\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        {\n            # Test case 1 (general case)\n            \"V\": 2, \"T\": 3, \"dt\": 1.0,\n            \"c\": np.array([0.15, 0.25, 0.20]),\n            \"vehicles\": [\n                {\n                    \"E\": 60.0, \"P_plus_max\": 7.2, \"P_minus_max\": 5.0,\n                    \"eta_plus\": 0.95, \"eta_minus\": 0.95,\n                    \"s_initial\": 0.50, \"s_min\": 0.20, \"s_max\": 0.90, \"s_req\": 0.60,\n                    \"alpha\": 0.01, \"gamma\": 0.02,\n                    \"a\": np.array([1, 1, 0])\n                },\n                {\n                    \"E\": 75.0, \"P_plus_max\": 11.0, \"P_minus_max\": 8.0,\n                    \"eta_plus\": 0.90, \"eta_minus\": 0.90,\n                    \"s_initial\": 0.60, \"s_min\": 0.30, \"s_max\": 0.90, \"s_req\": 0.65,\n                    \"alpha\": 0.015, \"gamma\": 0.02,\n                    \"a\": np.array([0, 1, 1])\n                }\n            ]\n        },\n        {\n            # Test case 2 (boundary with negative price)\n            \"V\": 1, \"T\": 4, \"dt\": 1.0,\n            \"c\": np.array([-0.05, 0.10, 0.18, 0.12]),\n            \"vehicles\": [\n                {\n                    \"E\": 75.0, \"P_plus_max\": 7.0, \"P_minus_max\": 7.0,\n                    \"eta_plus\": 0.92, \"eta_minus\": 0.92,\n                    \"s_initial\": 0.40, \"s_min\": 0.30, \"s_max\": 0.95, \"s_req\": 0.50,\n                    \"alpha\": 0.01, \"gamma\": 0.01,\n                    \"a\": np.array([1, 1, 1, 1])\n                }\n            ]\n        },\n        {\n            # Test case 3 (edge with high degradation cost)\n            \"V\": 2, \"T\": 2, \"dt\": 1.0,\n            \"c\": np.array([0.20, 0.22]),\n            \"vehicles\": [\n                {\n                    \"E\": 60.0, \"P_plus_max\": 7.2, \"P_minus_max\": 5.0,\n                    \"eta_plus\": 0.95, \"eta_minus\": 0.95,\n                    \"s_initial\": 0.79, \"s_min\": 0.20, \"s_max\": 0.95, \"s_req\": 0.80,\n                    \"alpha\": 1.0, \"gamma\": 0.00,\n                    \"a\": np.array([1, 1])\n                },\n                {\n                    \"E\": 60.0, \"P_plus_max\": 7.2, \"P_minus_max\": 5.0,\n                    \"eta_plus\": 0.95, \"eta_minus\": 0.95,\n                    \"s_initial\": 0.85, \"s_min\": 0.20, \"s_max\": 0.95, \"s_req\": 0.85,\n                    \"alpha\": 1.0, \"gamma\": 0.00,\n                    \"a\": np.array([0, 0])\n                }\n            ]\n        }\n    ]\n\n    results = []\n    for case_data in test_cases:\n        cost = solve_v2g_scheduling(case_data)\n        results.append(f\"{cost:.3f}\")\n\n    print(f\"[{','.join(results)}]\")\n\ndef solve_v2g_scheduling(params):\n    \"\"\"\n    Solves the V2G scheduling MILP for a given test case by enumerating\n    binary connection patterns and solving the resulting LPs.\n    \"\"\"\n    V = params[\"V\"]\n    T = params[\"T\"]\n    dt = params[\"dt\"]\n    prices = params[\"c\"]\n    vehicles = params[\"vehicles\"]\n\n    # Generate all valid combinations of binary x_vt variables\n    vehicle_x_patterns = []\n    for v_idx in range(V):\n        availability = vehicles[v_idx][\"a\"]\n        available_slots = np.where(availability == 1)[0]\n        num_available = len(available_slots)\n        \n        patterns_for_v = []\n        for combo in itertools.product([0, 1], repeat=num_available):\n            x_v = np.zeros(T, dtype=int)\n            x_v[available_slots] = combo\n            patterns_for_v.append(x_v)\n        vehicle_x_patterns.append(patterns_for_v)\n\n    all_x_combinations = itertools.product(*vehicle_x_patterns)\n    \n    min_total_cost = float('inf')\n\n    # Variable indexing helpers\n    num_p_plus = V * T\n    num_p_minus = V * T\n    num_s = V * T\n    num_vars = num_p_plus + num_p_minus + num_s\n\n    def p_plus_idx(v, t): return v * T + t\n    def p_minus_idx(v, t): return num_p_plus + v * T + t\n    def s_idx(v, t): return num_p_plus + num_p_minus + v * T + (t - 1)\n\n    for x_combo in all_x_combinations:\n        x_matrix = np.array(x_combo)\n        \n        # --- Formulate and solve the LP subproblem ---\n        \n        # 1. Objective function vector c\n        c = np.zeros(num_vars)\n        fixed_connection_cost = 0.0\n        for v in range(V):\n            alpha_v = vehicles[v][\"alpha\"]\n            gamma_v = vehicles[v][\"gamma\"]\n            for t in range(T):\n                c[p_plus_idx(v, t)] = dt * (prices[t] + alpha_v)\n                c[p_minus_idx(v, t)] = dt * (alpha_v - prices[t])\n                fixed_connection_cost += gamma_v * x_matrix[v, t]\n\n        # 2. Bounds (lb, ub)\n        bounds = np.zeros((num_vars, 2))\n        for v in range(V):\n            for t in range(T):\n                bounds[p_plus_idx(v, t), 1] = vehicles[v][\"P_plus_max\"] * x_matrix[v, t]\n                bounds[p_minus_idx(v, t), 1] = vehicles[v][\"P_minus_max\"] * x_matrix[v, t]\n            for t in range(1, T + 1):\n                bounds[s_idx(v, t), 0] = vehicles[v][\"s_min\"]\n                bounds[s_idx(v, t), 1] = vehicles[v][\"s_max\"]\n\n        # 3. Equality constraints A_eq, b_eq (SoC dynamics)\n        A_eq = np.zeros((V * T, num_vars))\n        b_eq = np.zeros(V * T)\n        for v in range(V):\n            E_v = vehicles[v][\"E\"]\n            eta_plus_v = vehicles[v][\"eta_plus\"]\n            eta_minus_v = vehicles[v][\"eta_minus\"]\n            k_plus = (eta_plus_v * dt) / E_v\n            k_minus = dt / (eta_minus_v * E_v)\n            \n            for t in range(T):\n                row_idx = v * T + t\n                A_eq[row_idx, p_plus_idx(v, t)] = -k_plus\n                A_eq[row_idx, p_minus_idx(v, t)] = k_minus\n                if t == 0:\n                    A_eq[row_idx, s_idx(v, 1)] = 1\n                    b_eq[row_idx] = vehicles[v][\"s_initial\"]\n                else:\n                    A_eq[row_idx, s_idx(v, t)] = -1\n                    A_eq[row_idx, s_idx(v, t+1)] = 1\n\n        # 4. Inequality constraints A_ub, b_ub (Terminal SoC)\n        A_ub = np.zeros((V, num_vars))\n        b_ub = np.zeros(V)\n        for v in range(V):\n            A_ub[v, s_idx(v, T)] = -1\n            b_ub[v] = -vehicles[v][\"s_req\"]\n\n        # 5. Solve the LP\n        res = linprog(c, A_ub=A_ub, b_ub=b_ub, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')\n        \n        if res.success:\n            current_total_cost = res.fun + fixed_connection_cost\n            if current_total_cost < min_total_cost:\n                min_total_cost = current_total_cost\n\n    return min_total_cost\n    \nsolve()\n```"
        },
        {
            "introduction": "Static optimization provides a powerful plan, but real-world V2G systems must adapt to ever-changing conditions and forecast uncertainties. This final practice advances our approach by implementing a Model Predictive Control (MPC) strategy, which continuously re-optimizes over a rolling horizon to manage uncertainty. By developing a robust MPC controller and comparing its performance against a simple myopic baseline, you will directly quantify the significant economic value of foresight in dynamic energy arbitrage .",
            "id": "3959510",
            "problem": "Consider a grid-interactive electric vehicle battery performing Vehicle-to-Grid (V2G) energy arbitrage under Model Predictive Control (MPC) with updated electricity price forecasts and symmetric error bounds. The battery is modeled over a discrete time horizon with a fixed prediction horizon of $H=12$ steps and a step duration of $\\Delta t = 1$ hour. The objective is to compute the MPC dispatch sequence and compare its total day cost to a myopic control baseline that optimizes over only a single-step horizon.\n\nAssume the following physically grounded battery and market model.\n\n- Battery state of charge (SoC) $s_t$ evolves under charging power $c_t \\ge 0$ and discharging power $d_t \\ge 0$ according to\n$$\ns_{t+1} = s_t + \\eta_c \\, c_t \\, \\Delta t - \\frac{1}{\\eta_d} \\, d_t \\, \\Delta t\n$$\nwhere $\\eta_c \\in (0,1]$ and $\\eta_d \\in (0,1]$ are the charge and discharge efficiencies, respectively.\n\n- The SoC is bounded by\n$$\ns_{\\min} \\le s_t \\le s_{\\max} \\quad \\text{for all } t.\n$$\n\n- The battery can only exchange power with the grid when connected, modeled by a connectivity indicator $a_t \\in \\{0,1\\}$. Power limits are\n$$\n0 \\le c_t \\le a_t \\, P^{\\max}_{\\mathrm{ch}}, \\qquad 0 \\le d_t \\le a_t \\, P^{\\max}_{\\mathrm{dis}}.\n$$\n\n- The market price forecast at time $t$ is $p_t$ in dollars per kilowatt-hour ($$/\\mathrm{kWh}$), with a symmetric error bound $e_t \\ge 0$ such that the realized price $\\tilde{p}_t$ lies within $[p_t - e_t, \\, p_t + e_t]$. For robust planning, adopt a worst-case objective over this interval.\n\n- The degradation cost is modeled as a linear cost per energy throughput, with unit cost $c_{\\mathrm{deg}}$ in dollars per kilowatt-hour ($$/\\mathrm{kWh}$). The instantaneous cost at time $t$ is defined for realized price $\\tilde{p}_t$ as\n$$\nJ_t(\\tilde{p}_t, c_t, d_t) = \\tilde{p}_t \\, c_t \\, \\Delta t - \\tilde{p}_t \\, d_t \\, \\Delta t + c_{\\mathrm{deg}} \\, (c_t + d_t) \\, \\Delta t\n$$\nwhere charging incurs energy purchase and discharging yields revenue that reduces cost.\n\n- For robust MPC planning under price uncertainty, replace $\\tilde{p}_t$ by its worst-case value with respect to decision direction: use $p_t + e_t$ for charging cost and $p_t - e_t$ for discharging revenue. The resulting worst-case stage cost is\n$$\n\\hat{J}_t(c_t, d_t) = (p_t + e_t) \\, c_t \\, \\Delta t - (p_t - e_t) \\, d_t \\, \\Delta t + c_{\\mathrm{deg}} \\, (c_t + d_t) \\, \\Delta t.\n$$\n\n- At the final time $T$, impose a terminal SoC requirement $s_T \\ge s_{\\mathrm{terminal}}$ only when the MPC horizon reaches the end of the day.\n\nDefine two controllers:\n1. Model Predictive Control (MPC): At each time $t$, solve a robust linear program over the horizon $t, t+1, \\dots, t+N-1$ with $N = \\min(H, T-t)$ to minimize $\\sum_{k=0}^{N-1} \\hat{J}_{t+k}$ subject to the linear dynamics, SoC bounds, power bounds, and terminal SoC constraint applied when $t+N = T$. Implement receding horizon by applying only the first-step decision $(c_t, d_t)$ and then updating $s_{t+1}$.\n\n2. Myopic baseline: At each time $t$, solve the same robust linear program but only over a single-step horizon ($N = 1$) to minimize the current worst-case stage cost $\\hat{J}_t$ subject to the same constraints, apply $(c_t, d_t)$, and update $s_{t+1}$.\n\nFor both controllers, evaluate the realized total day cost using the central forecast prices (i.e., set $\\tilde{p}_t = p_t$) as\n$$\nJ_{\\mathrm{day}} = \\sum_{t=0}^{T-1} \\left( p_t \\, c_t \\, \\Delta t - p_t \\, d_t \\, \\Delta t + c_{\\mathrm{deg}} (c_t + d_t) \\Delta t \\right).\n$$\n\nCompute the difference between the myopic baseline total day cost and the MPC total day cost, for each test case:\n$$\n\\Delta J = J_{\\mathrm{day}}^{\\mathrm{myopic}} - J_{\\mathrm{day}}^{\\mathrm{MPC}}.\n$$\nExpress each $\\Delta J$ in dollars, rounded to two decimal places.\n\nYou must implement the above controllers and calculations as a complete, runnable program. The program must produce the final output exactly as a single line containing a comma-separated list enclosed in square brackets, where the $i$-th element corresponds to the value of $\\Delta J$ in dollars for the $i$-th test case.\n\nUse the following test suite. Each test case specifies the number of steps $T$, price sequence $p_t$ in dollars per kilowatt-hour ($$/\\mathrm{kWh}$), error bounds $e_t$ in dollars per kilowatt-hour ($$/\\mathrm{kWh}$), connectivity $a_t \\in \\{0,1\\}$, initial SoC $s_0$ in kilowatt-hours ($\\mathrm{kWh}$), SoC bounds $s_{\\min}$ and $s_{\\max}$ in kilowatt-hours ($\\mathrm{kWh}$), power limits $P^{\\max}_{\\mathrm{ch}}$ and $P^{\\max}_{\\mathrm{dis}}$ in kilowatts ($\\mathrm{kW}$), efficiencies $\\eta_c$ and $\\eta_d$, degradation cost $c_{\\mathrm{deg}}$ in dollars per kilowatt-hour ($$/\\mathrm{kWh}$), and terminal SoC $s_{\\mathrm{terminal}}$ in kilowatt-hours ($\\mathrm{kWh}$). The step duration is $\\Delta t = 1$ hour and the prediction horizon is $H=12$:\n\n- Test case $1$ (standard arbitrage potential):\n    - $T = 24$\n    - $p_t$: $[0.12 \\text{ for } t \\in [0,5]], [0.18 \\text{ for } t \\in [6,10]], [0.32 \\text{ for } t \\in [11,14]], [0.18 \\text{ for } t \\in [15,19]], [0.10 \\text{ for } t \\in [20,23]]$\n    - $e_t$: constant $0.03$\n    - $a_t$: $1$ for $t \\in [0,7] \\cup [18,23]$, else $0$\n    - $s_0 = 10$, $s_{\\min} = 5$, $s_{\\max} = 50$\n    - $P^{\\max}_{\\mathrm{ch}} = 7.2$, $P^{\\max}_{\\mathrm{dis}} = 7.2$\n    - $\\eta_c = 0.95$, $\\eta_d = 0.95$\n    - $c_{\\mathrm{deg}} = 0.005$\n    - $s_{\\mathrm{terminal}} = 8$\n\n- Test case $2$ (zero-price boundary):\n    - $T = 24$\n    - $p_t$: all zeros\n    - $e_t$: all zeros\n    - $a_t$: all ones\n    - $s_0 = 20$, $s_{\\min} = 5$, $s_{\\max} = 50$\n    - $P^{\\max}_{\\mathrm{ch}} = 7.2$, $P^{\\max}_{\\mathrm{dis}} = 7.2$\n    - $\\eta_c = 0.95$, $\\eta_d = 0.95$\n    - $c_{\\mathrm{deg}} = 0.005$\n    - $s_{\\mathrm{terminal}} = 5$\n\n- Test case $3$ (high uncertainty suppresses discharge):\n    - $T = 24$\n    - $p_t$: $0.20$ for all $t$\n    - $e_t$: $0.10$ for all $t$\n    - $a_t$: all ones\n    - $s_0 = 20$, $s_{\\min} = 5$, $s_{\\max} = 50$\n    - $P^{\\max}_{\\mathrm{ch}} = 7.2$, $P^{\\max}_{\\mathrm{dis}} = 7.2$\n    - $\\eta_c = 0.95$, $\\eta_d = 0.95$\n    - $c_{\\mathrm{deg}} = 0.005$\n    - $s_{\\mathrm{terminal}} = 5$\n\n- Test case $4$ (limited early connectivity with midday price spike):\n    - $T = 24$\n    - $p_t$: $[0.08 \\text{ for } t \\in [0,5]], [0.18 \\text{ for } t \\in [6,11]], [0.30 \\text{ for } t \\in [12,15]], [0.18 \\text{ for } t \\in [16,19]], [0.12 \\text{ for } t \\in [20,23]]$\n    - $e_t$: constant $0.02$\n    - $a_t$: $1$ for $t \\in [0,3] \\cup [12,15] \\cup [20,23]$, else $0$\n    - $s_0 = 9$, $s_{\\min} = 5$, $s_{\\max} = 50$\n    - $P^{\\max}_{\\mathrm{ch}} = 7.2$, $P^{\\max}_{\\mathrm{dis}} = 7.2$\n    - $\\eta_c = 0.95$, $\\eta_d = 0.95$\n    - $c_{\\mathrm{deg}} = 0.005$\n    - $s_{\\mathrm{terminal}} = 7$\n\nAlgorithmic requirements:\n- Formulate the MPC subproblem as a linear program with decision variables $\\{c_{t+k}, d_{t+k}, s_{t+k+1}\\}_{k=0}^{N-1}$, linear dynamics constraints, box constraints, and the robust objective $\\sum_{k=0}^{N-1} \\hat{J}_{t+k}$, applying the terminal SoC constraint when $t+N=T$.\n- Implement the myopic baseline as the same linear program with $N=1$.\n- Use the central forecast $p_t$ for realized cost evaluation.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element is the value of $\\Delta J$ for the corresponding test case, in dollars rounded to two decimal places (e.g., \"[1.23,0.00,0.45,-0.12]\").",
            "solution": "The user problem has been subjected to a rigorous validation process and is determined to be valid. The problem is scientifically grounded, well-posed, internally consistent, and contains all necessary information to derive a unique, verifiable solution.\n\nThe problem requires a comparison of two control strategies for electric vehicle battery dispatch in a vehicle-to-grid (V2G) context: a Model Predictive Control (MPC) strategy with a lookahead horizon and a myopic (single-step) baseline. The performance metric is the total daily cost, accounting for energy purchase, energy sales revenue, and battery degradation. Both controllers operate under electricity price uncertainty, using a robust, worst-case formulation for planning.\n\n### 1. Mathematical Model\nThe core of the problem is a discrete-time linear model of a battery system.\n\n**State Dynamics:** The battery state of charge (SoC), denoted by $s_t$ in units of kilowatt-hours (kWh) at time step $t$, evolves according to the linear equation:\n$$\ns_{t+1} = s_t + \\eta_c \\, c_t \\, \\Delta t - \\frac{1}{\\eta_d} \\, d_t \\, \\Delta t\n$$\nwhere $c_t$ and $d_t$ are the charging and discharging power in kilowatts (kW), respectively. The parameters $\\eta_c \\in (0,1]$ and $\\eta_d \\in (0,1]$ represent the charging and discharging efficiencies. The time step duration is $\\Delta t = 1$ hour.\n\n**Constraints:** The system is subject to several linear constraints:\n- **SoC Limits:** $s_{\\min} \\le s_t \\le s_{\\max}$ for all $t$.\n- **Power Limits:**\n  - $0 \\le c_t \\le a_t \\, P^{\\max}_{\\mathrm{ch}}$\n  - $0 \\le d_t \\le a_t \\, P^{\\max}_{\\mathrm{dis}}$\n  where $a_t \\in \\{0,1\\}$ is a binary indicator of grid connectivity.\n- **Terminal Constraint:** $s_T \\ge s_{\\mathrm{terminal}}$, applied at the final time $T$ of the daily operational window.\n\n**Objective Function for Planning:** The controllers must plan actions by minimizing a robust, worst-case cost function over a given prediction horizon. The worst-case stage cost $\\hat{J}_t$ at time $t$ is formulated to account for price uncertainty represented by a forecast $p_t$ and an error bound $e_t$:\n$$\n\\hat{J}_t(c_t, d_t) = (p_t + e_t + c_{\\mathrm{deg}}) \\, c_t \\, \\Delta t + (c_{\\mathrm{deg}} - (p_t - e_t)) \\, d_t \\, \\Delta t\n$$\nThis formulation ensures that when making a decision to charge, the controller assumes the highest possible price ($p_t + e_t$), and when deciding to discharge, it assumes the lowest possible price ($p_t - e_t$) to guarantee robustness. $c_{\\mathrm{deg}}$ is the linear degradation cost per kWh of throughput.\n\n### 2. Control Strategies and Optimization\nAt each time step $t$, an optimization problem is solved to determine the optimal actions $c_t$ and $d_t$.\n\n**Linear Program (LP) Formulation:** For a planning horizon of length $N$ starting at time $t$, the problem is a linear program. The decision variables are the sequences of charge powers, discharge powers, and resulting SoC values:\n$$\n\\mathbf{x} = [c_t, \\dots, c_{t+N-1}, d_t, \\dots, d_{t+N-1}, s_{t+1}, \\dots, s_{t+N}]^T\n$$\nThis is a vector in $\\mathbb{R}^{3N}$.\n\nThe LP is formulated as follows:\n$$\n\\min_{\\mathbf{x}} \\sum_{k=0}^{N-1} \\left[ (p_{t+k} + e_{t+k} + c_{\\mathrm{deg}}) c_{t+k} \\Delta t + (c_{\\mathrm{deg}} - (p_{t+k} - e_{t+k})) d_{t+k} \\Delta t \\right]\n$$\nsubject to:\n1.  **Dynamics Constraints (Equality):** For $k=0, \\dots, N-1$:\n    $$\n    s_{t+k+1} - s_{t+k} - \\eta_c c_{t+k} \\Delta t + \\frac{1}{\\eta_d} d_{t+k} \\Delta t = 0\n    $$\n    where $s_t$ is the known initial state at the beginning of the horizon. These $N$ equations form the equality constraints $A_{eq}\\mathbf{x} = b_{eq}$.\n\n2.  **State and Control Bounds (Box Constraints):** For $k=0, \\dots, N-1$:\n    - $0 \\le c_{t+k} \\le a_{t+k} P^{\\max}_{\\mathrm{ch}}$\n    - $0 \\le d_{t+k} \\le a_{t+k} P^{\\max}_{\\mathrm{dis}}$\n    - $s_{\\min} \\le s_{t+k+1} \\le s_{\\max}$\n\n3.  **Terminal Constraint (Bound Adjustment):** If the horizon extends to the end of the day, i.e., $t+N = T$, the lower bound on the final state is adjusted: $s_{t+N} \\ge s_{\\mathrm{terminal}}$.\n\nThis structure is a standard LP that can be solved efficiently using numerical solvers.\n\n**Controller Implementation:**\n1.  **MPC Controller:** At each time step $t \\in [0, T-1]$, the MPC controller solves the LP with a horizon of length $N = \\min(H, T-t)$, where $H=12$ is the maximum prediction horizon. After solving, only the first actions $(c_t^*, d_t^*)$ of the optimal sequence are applied to the system. The state is updated to $s_{t+1}$, and the process is repeated at the next time step (receding horizon control).\n\n2.  **Myopic Controller:** This controller is a special case of the MPC where the horizon is always $N=1$. At each time step $t$, it solves the LP for a single step, optimizing only the immediate cost $\\hat{J}_t$ without any foresight.\n\n### 3. Simulation and Evaluation\nThe primary task is to simulate the battery's operation over a $T=24$ hour period under both control strategies and compare their economic performance.\n\n**Simulation Loop:**\nFor each controller (MPC and Myopic):\n1.  Initialize SoC to $s_0$.\n2.  Iterate $t$ from $0$ to $T-1$:\n    a.  Set up and solve the corresponding LP (with horizon $N$ for MPC, $N=1$ for Myopic) using the current state $s_t$.\n    b.  Apply the first-step optimal actions $(c_t, d_t)$.\n    c.  Update the state to $s_{t+1}$ using the dynamics equation.\n    d.  Store the actions $(c_t, d_t)$.\n\n**Performance Evaluation:** After the simulation for each controller is complete, the total realized daily cost, $J_{\\mathrm{day}}$, is calculated using the central price forecast ($\\tilde{p}_t = p_t$) as specified:\n$$\nJ_{\\mathrm{day}} = \\sum_{t=0}^{T-1} \\left( p_t c_t \\Delta t - p_t d_t \\Delta t + c_{\\mathrm{deg}} (c_t + d_t) \\Delta t \\right)\n$$\nThe final metric is the difference in cost between the two strategies, $\\Delta J = J_{\\mathrm{day}}^{\\mathrm{myopic}} - J_{\\mathrm{day}}^{\\mathrm{MPC}}$. A positive value indicates that MPC is economically superior to the myopic baseline.\n\nThe implementation will utilize the `scipy.optimize.linprog` function to solve the LP at each step. The test cases provided will be systematically processed to compute the required $\\Delta J$ for each.",
            "answer": "```python\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef solve():\n    \"\"\"\n    Main function to run the V2G optimization simulation for all test cases.\n    \"\"\"\n\n    # Global parameters as defined in the problem statement\n    H = 12  # Prediction horizon\n    DELTA_T = 1.0  # Time step duration in hours\n\n    # Test cases definition\n    test_cases = [\n        {\n            \"T\": 24,\n            \"p_t\": np.concatenate([\n                np.full(6, 0.12), np.full(5, 0.18), np.full(4, 0.32),\n                np.full(5, 0.18), np.full(4, 0.10)\n            ]),\n            \"e_t\": np.full(24, 0.03),\n            \"a_t\": np.array([1]*8 + [0]*10 + [1]*6),\n            \"s_0\": 10.0, \"s_min\": 5.0, \"s_max\": 50.0,\n            \"P_ch_max\": 7.2, \"P_dis_max\": 7.2,\n            \"eta_c\": 0.95, \"eta_d\": 0.95,\n            \"c_deg\": 0.005, \"s_terminal\": 8.0\n        },\n        {\n            \"T\": 24,\n            \"p_t\": np.zeros(24),\n            \"e_t\": np.zeros(24),\n            \"a_t\": np.ones(24),\n            \"s_0\": 20.0, \"s_min\": 5.0, \"s_max\": 50.0,\n            \"P_ch_max\": 7.2, \"P_dis_max\": 7.2,\n            \"eta_c\": 0.95, \"eta_d\": 0.95,\n            \"c_deg\": 0.005, \"s_terminal\": 5.0\n        },\n        {\n            \"T\": 24,\n            \"p_t\": np.full(24, 0.20),\n            \"e_t\": np.full(24, 0.10),\n            \"a_t\": np.ones(24),\n            \"s_0\": 20.0, \"s_min\": 5.0, \"s_max\": 50.0,\n            \"P_ch_max\": 7.2, \"P_dis_max\": 7.2,\n            \"eta_c\": 0.95, \"eta_d\": 0.95,\n            \"c_deg\": 0.005, \"s_terminal\": 5.0\n        },\n        {\n            \"T\": 24,\n            \"p_t\": np.concatenate([\n                np.full(6, 0.08), np.full(6, 0.18), np.full(4, 0.30),\n                np.full(4, 0.18), np.full(4, 0.12)\n            ]),\n            \"e_t\": np.full(24, 0.02),\n            \"a_t\": np.array([1]*4 + [0]*8 + [1]*4 + [0]*4 + [1]*4),\n            \"s_0\": 9.0, \"s_min\": 5.0, \"s_max\": 50.0,\n            \"P_ch_max\": 7.2, \"P_dis_max\": 7.2,\n            \"eta_c\": 0.95, \"eta_d\": 0.95,\n            \"c_deg\": 0.005, \"s_terminal\": 7.0\n        }\n    ]\n\n    results = []\n    for params in test_cases:\n        cost_mpc = run_simulation(params, H, DELTA_T, 'MPC')\n        cost_myopic = run_simulation(params, H, DELTA_T, 'Myopic')\n        delta_j = cost_myopic - cost_mpc\n        results.append(round(delta_j, 2))\n\n    # Format and print the final output as specified\n    print(f\"[{','.join(f'{r:.2f}' for r in results)}]\")\n\n\ndef run_simulation(params, H, dt, controller_type):\n    \"\"\"\n    Runs a T-step simulation for a given controller type ('MPC' or 'Myopic').\n    \"\"\"\n    T = params[\"T\"]\n    s_t = params[\"s_0\"]\n    \n    charge_actions = np.zeros(T)\n    discharge_actions = np.zeros(T)\n\n    for t in range(T):\n        if controller_type == 'MPC':\n            N = min(H, T - t)\n        else:  # Myopic\n            N = 1\n        \n        c_t_opt, d_t_opt = solve_dispatch_lp(params, s_t, t, N, dt)\n\n        charge_actions[t] = c_t_opt\n        discharge_actions[t] = d_t_opt\n        \n        # Update SoC based on the applied actions\n        s_t += params[\"eta_c\"] * c_t_opt * dt - (1 / params[\"eta_d\"]) * d_t_opt * dt\n\n    # Calculate total day cost using central price forecast\n    total_cost = np.sum(\n        params[\"p_t\"] * charge_actions * dt\n        - params[\"p_t\"] * discharge_actions * dt\n        + params[\"c_deg\"] * (charge_actions + discharge_actions) * dt\n    )\n    \n    return total_cost\n\n\ndef solve_dispatch_lp(params, s_current, t, N, dt):\n    \"\"\"\n    Sets up and solves the linear program for a single dispatch decision.\n    Decision variables are [c_0..c_{N-1}, d_0..d_{N-1}, s_1..s_N]\n    \"\"\"\n    p_forecast = params[\"p_t\"][t : t + N]\n    e_forecast = params[\"e_t\"][t : t + N]\n    a_forecast = params[\"a_t\"][t : t + N]\n    \n    # 1. Objective function coefficients (cost vector c)\n    cost_c = (p_forecast + e_forecast + params[\"c_deg\"]) * dt\n    cost_d = (params[\"c_deg\"] - (p_forecast - e_forecast)) * dt\n    cost_s = np.zeros(N)\n    c_vec = np.concatenate([cost_c, cost_d, cost_s])\n    \n    # 2. Equality constraints for dynamics (A_eq x = b_eq)\n    A_eq = np.zeros((N, 3 * N))\n    b_eq = np.zeros(N)\n\n    # First row connects to s_current\n    A_eq[0, 0] = -params[\"eta_c\"] * dt      # c_t\n    A_eq[0, N] = (1 / params[\"eta_d\"]) * dt # d_t\n    A_eq[0, 2 * N] = 1.0                      # s_{t+1}\n    b_eq[0] = s_current\n\n    # Subsequent rows for internal dynamics\n    for k in range(1, N):\n        A_eq[k, k] = -params[\"eta_c\"] * dt           # c_{t+k}\n        A_eq[k, N + k] = (1 / params[\"eta_d\"]) * dt    # d_{t+k}\n        A_eq[k, 2 * N + k - 1] = -1.0                 # s_{t+k}\n        A_eq[k, 2 * N + k] = 1.0                      # s_{t+k+1}\n    \n    # 3. Bounds for decision variables\n    bounds_c = [(0, a_forecast[k] * params[\"P_ch_max\"]) for k in range(N)]\n    bounds_d = [(0, a_forecast[k] * params[\"P_dis_max\"]) for k in range(N)]\n    \n    s_min_val = params[\"s_min\"]\n    s_max_val = params[\"s_max\"]\n    bounds_s = [(s_min_val, s_max_val) for _ in range(N)]\n    \n    # Apply terminal SoC constraint if horizon reaches the end of the day\n    if t + N == params[\"T\"]:\n        # The last state variable s_{t+N} must be >= s_terminal\n        s_terminal = params[\"s_terminal\"]\n        bounds_s[-1] = (max(s_min_val, s_terminal), s_max_val)\n        \n    all_bounds = bounds_c + bounds_d + bounds_s\n\n    # Solve the linear program\n    res = linprog(c=c_vec, A_eq=A_eq, b_eq=b_eq, bounds=all_bounds, method='highs')\n    \n    if res.success:\n        # Extract the first step actions\n        c_t_opt = res.x[0] if N > 0 else 0.0\n        d_t_opt = res.x[N] if N > 0 else 0.0\n        # Clamp small values to zero to handle numerical noise\n        c_t_opt = 0.0 if c_t_opt<1e-6 else c_t_opt\n        d_t_opt = 0.0 if d_t_opt<1e-6 else d_t_opt\n\n        return c_t_opt, d_t_opt\n    else:\n        # If solver fails, take no action\n        return 0.0, 0.0\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}