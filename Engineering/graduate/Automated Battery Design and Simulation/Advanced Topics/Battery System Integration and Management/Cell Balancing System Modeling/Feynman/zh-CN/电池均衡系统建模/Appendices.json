{
    "hands_on_practices": [
        {
            "introduction": "在设计任何电池均衡系统之前，首要任务是确定其核心性能规格。本练习将引导你完成一个基础但至关重要的计算，即根据电池组的容量、预期的最大电荷状态（SOC）不平衡度以及要求的均衡时间，来估算所需的最小均衡电流。通过这个实践，你将掌握将系统级需求转化为具体硬件参数的第一步。",
            "id": "3898804",
            "problem": "一个电池管理系统 (BMS) 监控着串联锂离子电池组中的无源分流电池均衡。假设单个电池的额定容量为 $Q$（以安培-小时为单位），在均衡期间处于静止状态，没有施加外部充电或放电。荷电状态 (SOC) $z$ 定义为 $z = q/Q$，其中 $q$ 是电池内的可用电荷量。在恒定分流电流均衡期间，电池的可用电荷量减少，其减少量与均衡电流和时间成正比。对于单个电池，相对于电池组平均值需要纠正的最坏情况下的SOC不均衡是一个正分数 $\\Delta z_{\\max}$，并且均衡必须在要求的时间窗口 $t_{\\text{req}}$ 内将此SOC超出量基本上减少到零。忽略自放电、漏电以及分流电流的任何电压依赖性；将分流器在 $[0, t_{\\text{req}}]$ 区间内视作一个等于其额定值 $I_{\\text{bal}}$ 的恒流吸收器，并假设容量 $Q$ 在此区间内不发生变化。\n\n已知 $Q = 8.0\\,\\mathrm{Ah}$，$\\Delta z_{\\max} = 0.10$，以及 $t_{\\text{req}} = 1.5\\,\\mathrm{h}$，确定为保证在指定时间内纠正最坏情况下的SOC不均衡所需的最小均衡电流额定值 $I_{\\text{bal}}$。以安培 ($\\mathrm{A}$) 为单位表示最终答案，并将答案四舍五入到四位有效数字。",
            "solution": "首先对问题陈述进行严格的验证过程。\n\n给定的条件明确说明如下：\n- 额定电池容量：$Q = 8.0\\,\\mathrm{Ah}$\n- 最坏情况下的初始SOC超出量：$\\Delta z_{\\max} = 0.10$\n- 要求的均衡时间窗口：$t_{\\text{req}} = 1.5\\,\\mathrm{h}$\n- 荷电状态 $z$ 定义为可用电荷量 $q$ 与额定容量 $Q$ 的比值：$z = q/Q$。\n- 均衡通过恒定的分流电流 $I_{\\text{bal}}$ 执行。\n- 所有其他效应，如自放电、漏电和电压依赖效应，均被忽略。\n\n该问题被认为是有效的。它在科学上基于电化学和电路理论的基本原理，特别是电荷、电流和时间之间的关系 ($I = dq/dt$)。该问题提法得当，提供了确定所需最小均衡电流 $I_{\\text{bal}}$ 的唯一值所需的所有必要信息 ($Q$, $\\Delta z_{\\max}$, $t_{\\text{req}}$)。问题是客观的，并使用了电池工程领域中标准的清晰、无歧义的术语。所提供的数值对于锂离子电池是物理上现实的。简化假设被明确陈述，并且是一阶工程模型的标准做法。\n\n目标是确定在给定的时间范围内移除指定量的多余电荷所需的最小恒定均衡电流 $I_{\\text{bal}}$。\n\n荷电状态 $z$、可用电荷量 $q$ 和额定容量 $Q$ 之间的关系由下式给出：\n$$z = \\frac{q}{Q}$$\n荷电状态的变化 $\\Delta z$ 对应于存储电荷量的变化 $\\Delta q$，根据：\n$$\\Delta z = \\frac{\\Delta q}{Q}$$\n问题陈述均衡过程必须纠正一个最坏情况下的SOC不均衡 $\\Delta z_{\\max}$。这意味着必须从电池中移除与此SOC超出量相对应的电荷量 $\\Delta q_{\\text{excess}}$。重新整理前面的方程，这个多余的电荷量是：\n$$\\Delta q_{\\text{excess}} = Q \\cdot \\Delta z_{\\max}$$\n均衡是通过从电池中抽取恒定电流 $I_{\\text{bal}}$ 来实现的。在某个时间间隔内，由恒定电流移除的总电荷量是电流与时间长度的乘积。在要求的时间窗口 $t_{\\text{req}}$ 内移除的电荷量 $\\Delta q_{\\text{removed}}$ 是：\n$$\\Delta q_{\\text{removed}} = I_{\\text{bal}} \\cdot t_{\\text{req}}$$\n为保证均衡在指定时间内完成，移除的电荷量必须至少等于需要耗散的多余电荷量：\n$$\\Delta q_{\\text{removed}} \\geq \\Delta q_{\\text{excess}}$$\n代入 $\\Delta q_{\\text{removed}}$ 和 $\\Delta q_{\\text{excess}}$ 的表达式：\n$$I_{\\text{bal}} \\cdot t_{\\text{req}} \\geq Q \\cdot \\Delta z_{\\max}$$\n问题要求的是所需的最小均衡电流。这个最小值对应于等式条件：\n$$I_{\\text{bal, min}} \\cdot t_{\\text{req}} = Q \\cdot \\Delta z_{\\max}$$\n解出 $I_{\\text{bal, min}}$：\n$$I_{\\text{bal, min}} = \\frac{Q \\cdot \\Delta z_{\\max}}{t_{\\text{req}}}$$\n现在，我们将提供的数值代入这个表达式中。额定容量为 $Q = 8.0\\,\\mathrm{Ah}$，SOC不均衡为 $\\Delta z_{\\max} = 0.10$（一个无量纲量），要求的时间为 $t_{\\text{req}} = 1.5\\,\\mathrm{h}$。\n$$I_{\\text{bal, min}} = \\frac{(8.0\\,\\mathrm{Ah}) \\cdot (0.10)}{1.5\\,\\mathrm{h}}$$\n分子中的乘积是：\n$$(8.0\\,\\mathrm{Ah}) \\cdot (0.10) = 0.80\\,\\mathrm{Ah}$$\n所以电流的表达式变为：\n$$I_{\\text{bal, min}} = \\frac{0.80\\,\\mathrm{Ah}}{1.5\\,\\mathrm{h}}$$\n安培-小时 ($\\mathrm{Ah}$) 的单位除以小时 ($\\mathrm{h}$) 的单位，正确地得到了电流单位安培 ($\\mathrm{A}$)。\n$$I_{\\text{bal, min}} = \\frac{0.80}{1.5}\\,\\mathrm{A} = \\frac{8}{15}\\,\\mathrm{A}$$\n进行除法运算得到：\n$$I_{\\text{bal, min}} \\approx 0.533333...\\,\\mathrm{A}$$\n问题要求最终答案四舍五入到四位有效数字。\n$$I_{\\text{bal, min}} \\approx 0.5333\\,\\mathrm{A}$$\n这就是满足指定性能标准所需的最小均衡电流额定值。",
            "answer": "$$\\boxed{0.5333}$$"
        },
        {
            "introduction": "电池的端电压是其内部状态的重要窗口，但它并非电荷状态（SOC）的完美镜像。本练习要求你通过编程来模拟一个包含两个电芯的电池组，并探索当电芯内阻存在差异时，即使它们的SOC完全相同，端电压也会在充放电过程中出现显著差异。这项实践旨在揭示仅依赖电压阈值来判断不平衡的潜在缺陷，并加深你对电池等效电路模型在动态诊断中应用的理解。",
            "id": "3898809",
            "problem": "考虑一个由两节锂离子电池组成的电池包，该电池包采用一阶戴维南等效电路进行建模，两节电池接收相同的电池包电流。采用的符号约定是，正电流 $I$ 对应于充电过程。每节电池 $i \\in \\{1,2\\}$ 被建模为一个开路电压源，其开路电压 $U(z_{i})$ 取决于荷电状态 $z_{i}$，一个串联电阻 $R_{s,i}$，以及一个产生瞬态极化电压 $v_{p,i}$ 的单极化支路。电池 $i$ 的测量端电压为\n$$\nV_{i}(t) = U(z_{i}(t)) + I\\,R_{s,i} + v_{p,i}(t).\n$$\n该模型易于处理且在科学上具有现实意义，适用于研究瞬态电压发散现象。即使 $z_{1}(t) \\approx z_{2}(t)$，当 $R_{s,1} \\neq R_{s,2}$ 时，这种发散也可能错误地指示不平衡。\n\n使用以下基本依据：\n1. 对于容量为 $Q$（单位：库仑）的电池，在充电电流 $I$ 下，荷电状态的定义为\n$$\n\\frac{dz_{i}}{dt} = \\frac{I}{Q},\n$$\n其中 $z_{i}\\in[0,1]$ 且 $Q$ 为常数。\n2. 对于极化支路，应用源自基尔霍夫电流定律（KCL）的戴维南阻容动态特性。对于由电阻 $R_{t}$ 和电容 $C_{t}$ 组成的支路，极化电压 $v_{p,i}$ 遵循\n$$\n\\frac{dv_{p,i}}{dt} = -\\frac{1}{R_{t}C_{t}}\\,v_{p,i} + \\frac{I}{C_{t}}.\n$$\n3. 对于锂离子电池，一个平滑且物理上合理的开路电压函数 $U(z)$ 可以通过以下公式近似：\n$$\nU(z) = 3.0 + 1.2\\,z + 0.1\\,\\tanh\\!\\left(\\frac{z - 0.5}{0.1}\\right),\n$$\n当 $z \\in [0,1]$ 时，该函数产生的电压范围接近典型值。\n\n从这些基本依据出发，推导使用均匀时间步长 $\\Delta t$ 和显式时间步进法，在有限时间范围内模拟该两节电池电池包所需的离散时间更新方程。您必须实现一个程序，该程序：\n- 使用给定的 $z_{i}(0)$ 和 $v_{p,i}(0)$ 初始化两节电池。\n- 使用上述关系式演化 $z_{i}(t)$、$v_{p,i}(t)$ 并计算 $V_{i}(t)$。\n- 对每个指定的参数集，计算以下三个量：\n  1. 模拟窗口内的最大绝对端电压发散值，\n     $$\n     \\max_{t\\in[0,T]} \\left| V_{1}(t) - V_{2}(t) \\right| \\quad \\text{单位：伏特}。\n     $$\n  2. 最终的有符号端电压差，\n     $$\n     V_{1}(T) - V_{2}(T) \\quad \\text{单位：伏特}。\n     $$\n  3. 一个以整数（$0$ 或 $1$）表示的假阳性标志：如果在 $[0,T]$ 内存在任何时间，同时满足 $\\left|V_{1}(t)-V_{2}(t)\\right| \\geq V_{\\text{th}}$ 和 $\\left|z_{1}(t)-z_{2}(t)\\right| \\leq \\varepsilon_{z}$，则输出 $1$，否则输出 $0$。这代表了一个基于电压阈值的朴素不平衡检测器，在荷电状态差异很小的情况下错误地标记了不平衡。\n\n使用以下明确的单位和约定：\n- 电流 $I$ 单位为安培 ($\\mathrm{A}$)。\n- 电阻 $R_{s,i}$ 和 $R_{t}$ 单位为欧姆 ($\\Omega$)。\n- 电容 $C_{t}$ 单位为法拉 ($\\mathrm{F}$)。\n- 容量 $Q$ 单位为库仑 ($\\mathrm{C}$)。\n- 时间 $T$ 和时间步长 $\\Delta t$ 单位为秒 ($\\mathrm{s}$)。\n- 电压单位为伏特 ($\\mathrm{V}$)。\n- 荷电状态 $z$ 是无量纲的。\n\n使用对给定参数稳定的显式方法，以均匀时间步长 $\\Delta t$ 对连续时间动态进行离散化，并在仿真过程中将 $z_{i}(t)$ 限制在区间 $[0,1]$ 内以保持物理合理性。\n\n测试套件：\n实现您的程序以运行以下四个参数集。对于每种情况，按指定的单位和格式生成上述三个输出。\n\n情况 1（正常路径：中等串联电阻失配）：\n- $I = 5\\ \\mathrm{A}$，$R_{s,1} = 0.010\\ \\Omega$，$R_{s,2} = 0.020\\ \\Omega$，\n- $R_{t} = 0.015\\ \\Omega$，$C_{t} = 2000\\ \\mathrm{F}$，\n- $Q = 7200\\ \\mathrm{C}$，$T = 100\\ \\mathrm{s}$，$\\Delta t = 0.1\\ \\mathrm{s}$，\n- $z_{1}(0) = 0.5$，$z_{2}(0) = 0.5$，$v_{p,1}(0) = 0.0\\ \\mathrm{V}$，$v_{p,2}(0) = 0.0\\ \\mathrm{V}$，\n- 电压阈值 $V_{\\text{th}} = 0.05\\ \\mathrm{V}$，荷电状态容差 $\\varepsilon_{z} = 0.001$。\n\n情况 2（边界情况：串联电阻相同）：\n- $I = 5\\ \\mathrm{A}$，$R_{s,1} = 0.015\\ \\Omega$，$R_{s,2} = 0.015\\ \\Omega$，\n- $R_{t} = 0.015\\ \\Omega$，$C_{t} = 2000\\ \\mathrm{F}$，\n- $Q = 7200\\ \\mathrm{C}$，$T = 100\\ \\mathrm{s}$，$\\Delta t = 0.1\\ \\mathrm{s}$，\n- $z_{1}(0) = 0.5$，$z_{2}(0) = 0.5$，$v_{p,1}(0) = 0.0\\ \\mathrm{V}$，$v_{p,2}(0) = 0.0\\ \\mathrm{V}$，\n- $V_{\\text{th}} = 0.05\\ \\mathrm{V}$，$\\varepsilon_{z} = 0.001$。\n\n情况 3（边缘情况：较大失配、较高电流且时间常数不同）：\n- $I = 10\\ \\mathrm{A}$，$R_{s,1} = 0.005\\ \\Omega$，$R_{s,2} = 0.030\\ \\Omega$，\n- $R_{t} = 0.020\\ \\Omega$，$C_{t} = 1200\\ \\mathrm{F}$，\n- $Q = 7200\\ \\mathrm{C}$，$T = 60\\ \\mathrm{s}$，$\\Delta t = 0.05\\ \\mathrm{s}$，\n- $z_{1}(0) = 0.6$，$z_{2}(0) = 0.6$，$v_{p,1}(0) = 0.0\\ \\mathrm{V}$，$v_{p,2}(0) = 0.0\\ \\mathrm{V}$，\n- $V_{\\text{th}} = 0.05\\ \\mathrm{V}$，$\\varepsilon_{z} = 0.001$。\n\n情况 4（边缘情况：零电流基线）：\n- $I = 0\\ \\mathrm{A}$，$R_{s,1} = 0.020\\ \\Omega$，$R_{s,2} = 0.040\\ \\Omega$，\n- $R_{t} = 0.015\\ \\Omega$，$C_{t} = 2000\\ \\mathrm{F}$，\n- $Q = 7200\\ \\mathrm{C}$，$T = 50\\ \\mathrm{s}$，$\\Delta t = 0.1\\ \\mathrm{s}$，\n- $z_{1}(0) = 0.5$，$z_{2}(0) = 0.5$，$v_{p,1}(0) = 0.0\\ \\mathrm{V}$，$v_{p,2}(0) = 0.0\\ \\mathrm{V}$，\n- $V_{\\text{th}} = 0.05\\ \\mathrm{V}$，$\\varepsilon_{z} = 0.001$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含四个测试用例的结果，形式为方括号内由逗号分隔的列表。每个测试用例的结果本身必须是以下形式的列表：\n$$\n\\left[\\max_{t} \\left| V_{1}(t) - V_{2}(t) \\right|,\\; V_{1}(T) - V_{2}(T),\\; \\text{flag}\\right],\n$$\n其中前两项是单位为伏特的浮点数，第三项是整数（$0$ 或 $1$）。例如，您的输出应如下所示：\n$$\n[\\,[x_{1},y_{1},b_{1}],\\,[x_{2},y_{2},b_{2}],\\,[x_{3},y_{3},b_{3}],\\,[x_{4},y_{4},b_{4}]\\,],\n$$\n所有数值均由您的仿真程序按指定单位计算得出。",
            "solution": "用户提供的问题是有效的。它在科学上基于成熟的电池建模技术（一阶戴维南等效电路模型），问题设定良好，包含获得唯一解所需的所有参数和初始条件，并且其表述和要求都是客观的。该问题要求开发并实现一个两节电池电池包的离散时间仿真，以分析特定条件下的电压发散情况。\n\n解决方案首先从提供的连续时间模型推导出离散时间更新方程，然后概述用于计算所需指标的仿真算法。\n\n### 1. 连续时间模型构建\n\n该系统由两节电池组成，每节电池由一个状态向量描述，该向量包含其荷电状态（SoC）$z_i(t)$ 和极化电压 $v_{p,i}(t)$。系统的动态特性由一组常微分方程（ODE）控制。\n\n电池 $i$ 的荷电状态 $z_i(t)$ 根据库仑计数原理演化：\n$$\n\\frac{dz_{i}}{dt} = \\frac{I}{Q}\n$$\n其中 $I$ 是电池包电流（充电为正），$Q$ 是电池的总容量，单位为库仑。\n\n极化电压 $v_{p,i}(t)$ 捕捉了电池的瞬态响应，并由并联电阻-电容（RC）电路的动态特性建模：\n$$\n\\frac{dv_{p,i}}{dt} = -\\frac{1}{R_{t}C_{t}}\\,v_{p,i}(t) + \\frac{I}{C_{t}}\n$$\n其中 $R_t$ 和 $C_t$ 分别是极化支路的电阻和电容。需要注意的是，这两个参数对于两节电池是相同的。\n\n每节电池的端电压 $V_i(t)$ 是开路电压（OCV）、串联电阻上的压降以及极化电压的代数和：\n$$\nV_{i}(t) = U(z_{i}(t)) + I\\,R_{s,i} + v_{p,i}(t)\n$$\n开路电压 $U(z)$ 是荷电状态的非线性函数，由下式给出：\n$$\nU(z) = 3.0 + 1.2\\,z + 0.1\\,\\tanh\\!\\left(\\frac{z - 0.5}{0.1}\\right)\n$$\n\n### 2. 模型离散化\n\n为了对系统进行数值模拟，我们使用具有均匀时间步长 $\\Delta t$ 的显式（前向）欧拉方法对连续时间常微分方程进行离散化。令下标 $k$ 表示变量在时间 $t_k = k \\Delta t$ 的取值。\n\n荷电状态 $z_{i,k}$ 的更新方程从其定义推导而来：\n$$\nz_{i,k+1} = z_{i,k} + \\frac{I \\Delta t}{Q}\n$$\n为了保持物理现实性，每次更新后将荷电状态限制在区间 $[0, 1]$ 内：\n$$\nz_{i,k+1} = \\max(0, \\min(1, z_{i,k+1}))\n$$\n\n极化电压 $v_{p,i,k}$ 的更新方程也以类似方式推导：\n$$\nv_{p,i,k+1} = v_{p,i,k} + \\Delta t \\left( -\\frac{1}{R_{t}C_{t}} v_{p,i,k} + \\frac{I}{C_t} \\right)\n$$\n整理各项可得最终的更新规则：\n$$\nv_{p,i,k+1} = \\left( 1 - \\frac{\\Delta t}{R_{t}C_{t}} \\right) v_{p,i,k} + \\frac{I \\Delta t}{C_{t}}\n$$\n\n在确定了步骤 $k+1$ 的状态后，可以使用同一步骤的状态值计算端电压 $V_{i,k+1}$：\n$$\nV_{i,k+1} = U(z_{i,k+1}) + I R_{s,i} + v_{p,i,k+1}\n$$\n\n### 3. 仿真算法与输出指标\n\n仿真在时间区间 $[0, T]$ 上执行。算法流程如下：\n\n1.  **初始化**：\n    -   为特定测试用例设置参数：$I, R_{s,1}, R_{s,2}, R_t, C_t, Q, T, \\Delta t, V_{\\text{th}}, \\varepsilon_z$。\n    -   将两节电池的状态变量初始化为 $t=0$ 时的给定初始条件：$z_{1,0}, z_{2,0}, v_{p,1,0}, v_{p,2,0}$。\n    -   初始化输出指标：`max_voltage_divergence = 0.0` 和 `false_positive_flag = 0`。\n    -   确定总仿真步数，$N = \\text{round}(T / \\Delta t)$。\n\n2.  **时间步进循环**：\n    -   对 $k$ 从 $0$ 到 $N$（含）执行一个循环，以覆盖从 $t=0$ 到 $t=T$ 的所有时间点。\n    -   在对应于时间 $t_k = k \\Delta t$ 的每一步 $k$：\n        a.  **计算输出**：使用当前状态值（$z_{i,k}, v_{p,i,k}$）计算端电压 $V_{1,k}$ 和 $V_{2,k}$。\n        b.  **更新指标**：\n            i.  计算绝对电压发散值 $|V_{1,k} - V_{2,k}|$，如果该值大于当前最大值，则更新 `max_voltage_divergence`。\n            ii. 计算绝对荷电状态差异 $|z_{1,k} - z_{2,k}|$。\n            iii. 检查假阳性条件：如果 `false_positive_flag` 尚未设置，则评估是否 $|V_{1,k} - V_{2,k}| \\ge V_{\\text{th}}$ 且 $|z_{1,k} - z_{2,k}| \\le \\varepsilon_z$。如果两者都为真，则设置 `false_positive_flag = 1`。\n        c.  **存储最终差异**：如果 $k=N$（最后一步），则将有符号差异 $V_{1,N} - V_{2,N}$ 存储为 `final_voltage_difference`。\n        d.  **更新状态**：如果 $k  N$，则使用上面推导的离散时间更新方程计算下一个状态 $z_{i,k+1}$ 和 $v_{p,i,k+1}$。\n\n3.  **结果聚合**：\n    -   循环完成后，收集计算出的三个指标：`max_voltage_divergence`、`final_voltage_difference` 和 `false_positive_flag`。这个三元组构成一个测试用例的结果。\n\n对四个指定的参数集中的每一个都实施此算法，以生成最终输出。对于给定的测试用例，一个关键的观察是，由于两节电池以相同的状态（$z_1(0)=z_2(0)$，$v_{p1}(0)=v_{p2}(0)$）开始，并受到相同的动态影响（相同的 $I, Q, R_t, C_t$），它们的状态在整个仿真过程中将保持相同，即 $z_1(t) \\equiv z_2(t)$ 和 $v_{p1}(t) \\equiv v_{p2}(t)$。因此，电压差 $V_1(t) - V_2(t)$ 简化为 $I(R_{s,1} - R_{s,2})$，它随时间保持恒定。尽管如此，实现时仍将按指示执行完整的仿真。",
            "answer": "```python\nimport numpy as np\nimport math\n\n# Adherence to specified library versions (numpy==1.23.5) is assumed.\n# The `math.tanh` function is part of the standard library.\n\ndef solve():\n    \"\"\"\n    Main function to run the simulations for all test cases and print the results.\n    \"\"\"\n\n    test_cases = [\n        # Case 1 (happy path: moderate series resistance mismatch)\n        {\n            \"I\": 5.0, \"Rs1\": 0.010, \"Rs2\": 0.020,\n            \"Rt\": 0.015, \"Ct\": 2000.0,\n            \"Q\": 7200.0, \"T\": 100.0, \"dt\": 0.1,\n            \"z1_0\": 0.5, \"z2_0\": 0.5, \"vp1_0\": 0.0, \"vp2_0\": 0.0,\n            \"V_th\": 0.05, \"epsilon_z\": 0.001,\n        },\n        # Case 2 (boundary: identical series resistances)\n        {\n            \"I\": 5.0, \"Rs1\": 0.015, \"Rs2\": 0.015,\n            \"Rt\": 0.015, \"Ct\": 2000.0,\n            \"Q\": 7200.0, \"T\": 100.0, \"dt\": 0.1,\n            \"z1_0\": 0.5, \"z2_0\": 0.5, \"vp1_0\": 0.0, \"vp2_0\": 0.0,\n            \"V_th\": 0.05, \"epsilon_z\": 0.001,\n        },\n        # Case 3 (edge: larger mismatch and higher current)\n        {\n            \"I\": 10.0, \"Rs1\": 0.005, \"Rs2\": 0.030,\n            \"Rt\": 0.020, \"Ct\": 1200.0,\n            \"Q\": 7200.0, \"T\": 60.0, \"dt\": 0.05,\n            \"z1_0\": 0.6, \"z2_0\": 0.6, \"vp1_0\": 0.0, \"vp2_0\": 0.0,\n            \"V_th\": 0.05, \"epsilon_z\": 0.001,\n        },\n        # Case 4 (edge: zero current baseline)\n        {\n            \"I\": 0.0, \"Rs1\": 0.020, \"Rs2\": 0.040,\n            \"Rt\": 0.015, \"Ct\": 2000.0,\n            \"Q\": 7200.0, \"T\": 50.0, \"dt\": 0.1,\n            \"z1_0\": 0.5, \"z2_0\": 0.5, \"vp1_0\": 0.0, \"vp2_0\": 0.0,\n            \"V_th\": 0.05, \"epsilon_z\": 0.001,\n        },\n    ]\n\n    all_results = []\n    for params in test_cases:\n        result = run_simulation(params)\n        all_results.append(result)\n\n    # Format the final output as a string representing a list of lists.\n    # e.g., [[x1,y1,b1],[x2,y2,b2],...]\n    result_str = \"[\" + \",\".join([f\"[{r[0]},{r[1]},{r[2]}]\" for r in all_results]) + \"]\"\n    print(result_str)\n\ndef U_func(z):\n    \"\"\"\n    Computes the Open-Circuit Voltage (OCV) as a function of State of Charge (SoC).\n    U(z) = 3.0 + 1.2*z + 0.1*tanh((z - 0.5)/0.1)\n    \"\"\"\n    return 3.0 + 1.2 * z + 0.1 * math.tanh((z - 0.5) / 0.1)\n\ndef run_simulation(params):\n    \"\"\"\n    Performs a single simulation run for a given set of parameters.\n    \"\"\"\n    # Unpack parameters\n    I, Rs1, Rs2 = params[\"I\"], params[\"Rs1\"], params[\"Rs2\"]\n    Rt, Ct = params[\"Rt\"], params[\"Ct\"]\n    Q, T, dt = params[\"Q\"], params[\"T\"], params[\"dt\"]\n    V_th, epsilon_z = params[\"V_th\"], params[\"epsilon_z\"]\n\n    # Initialize state variables\n    z1, z2 = params[\"z1_0\"], params[\"z2_0\"]\n    vp1, vp2 = params[\"vp1_0\"], params[\"vp2_0\"]\n\n    # Initialize metrics\n    max_voltage_divergence = 0.0\n    final_voltage_difference = 0.0\n    false_positive_flag = 0\n\n    # Simulation setup\n    num_steps = int(round(T / dt))\n    \n    # Pre-calculate constants for the update equations\n    # v_p,k+1 = vp_alpha * v_p,k + vp_beta\n    vp_alpha = 1.0 - dt / (Rt * Ct)\n    vp_beta = (I * dt) / Ct\n    # z_k+1 = z_k + dz\n    dz = (I * dt) / Q\n\n    for k in range(num_steps + 1):\n        # 1. Calculate outputs at the current time step k\n        U1 = U_func(z1)\n        U2 = U_func(z2)\n        \n        V1 = U1 + I * Rs1 + vp1\n        V2 = U2 + I * Rs2 + vp2\n\n        # 2. Update metrics\n        current_voltage_divergence = abs(V1 - V2)\n        if current_voltage_divergence > max_voltage_divergence:\n            max_voltage_divergence = current_voltage_divergence\n\n        current_soc_difference = abs(z1 - z2)\n        if false_positive_flag == 0:\n            if current_voltage_divergence >= V_th and current_soc_difference = epsilon_z:\n                false_positive_flag = 1\n        \n        # 3. Store final difference at the end of the simulation\n        if k == num_steps:\n            final_voltage_difference = V1 - V2\n            break \n            \n        # 4. Update states for the next time step (k+1)\n        # Polarization voltage update\n        vp1 = vp_alpha * vp1 + vp_beta\n        vp2 = vp_alpha * vp2 + vp_beta\n\n        # State of charge update and clamping\n        z1 = z1 + dz\n        z2 = z2 + dz\n        z1 = max(0.0, min(1.0, z1))\n        z2 = max(0.0, min(1.0, z2))\n\n    return [max_voltage_divergence, final_voltage_difference, false_positive_flag]\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "当均衡系统不仅仅是简单地开关，而是需要智能地分配电流时，我们就进入了优化控制的领域。本练习将挑战你将电芯均衡问题构建为一个线性规划（LP）问题，目标是在给定的时间和执行器限制下，计算出最优的电流分配方案，以最大程度地减小最终的SOC不一致性。通过解决这个优化问题，你将学会如何从被动分析转向主动设计，为复杂的电池管理任务制定出具有可证明性能的控制策略。",
            "id": "3898781",
            "problem": "考虑一个由多个电化学电池组成的串联电池包，其中仅施加包内均衡电流，没有净外部电荷注入。设电池 $i$ 的荷电状态 (SoC) 用 $z_{i}(t)$ 表示，其电荷容量用 $Q_{i}$ 表示（单位为库仑）。在仅均衡驱动下，电池中存储的电荷满足电荷守恒和库仑计数的基本关系：对于每个电池 $i$，存储的电荷 $q_{i}(t)$ 随时间的变化为 $\\mathrm{d} q_{i}/\\mathrm{d} t = i_{i}(t)$，且SoC为 $z_{i}(t) = q_{i}(t)/Q_{i}$。因此，SoC动态方程为 $Q_{i}\\,\\mathrm{d} z_{i}/\\mathrm{d} t = i_{i}(t)$，或等效地为 $\\mathrm{d} z_{i}/\\mathrm{d} t = i_{i}(t)/Q_{i}$，其中 $i_{i}(t)$ 是施加到电池 $i$ 的均衡电流（电荷流入电池时为正）。串联电池包中的电荷守恒要求在所有时间 $t$ 满足约束 $\\sum_{i=1}^{N} i_{i}(t) = 0$ （均衡期间无净外部电荷流动）。每个执行器都遵循饱和限制 $\\lvert i_{i}(t) \\rvert \\le I_{\\max}$。\n\n性能指标是在截止时间 $t_{f}$ 时，减小最终SoC值围绕电荷加权平均SoC $\\bar{z}$ 的离散程度，$\\bar{z}$ 由总电荷守恒定义为 $\\bar{z} = \\left(\\sum_{i=1}^{N} Q_{i} z_{i}(0)\\right)\\big/\\left(\\sum_{i=1}^{N} Q_{i}\\right)$。控制目标是计算一个可行的均衡电流方案 $\\{ i_{i}(t) \\}_{i=1}^{N}$，以满足 $\\max_{i} \\lvert z_{i}(t_{f}) - \\bar{z} \\rvert \\le \\epsilon$，同时在所有 $t \\in [0, t_{f}]$ 时间内满足 $\\lvert i_{i}(t) \\rvert \\le I_{\\max}$ 和 $\\sum_{i=1}^{N} i_{i}(t) = 0$。\n\n您的任务是在离散时间内求解该问题，该离散时间包含 $M$ 个大小为 $\\Delta t = t_{f}/M$ 的相等时间步。使用分段常数控制参数化 $i_{i}(t) = i_{i}[k]$，其中 $t \\in [k \\Delta t, (k+1) \\Delta t)$ 且 $k \\in \\{0, 1, \\dots, M-1\\}$。给定 $N$、容量 $\\{Q_{i}\\}_{i=1}^{N}$（单位为库仑）、初始SoC $\\{ z_{i}(0) \\}_{i=1}^{N}$（无量纲）、电流上限 $I_{\\max}$（单位为安培）、截止时间 $t_{f}$（单位为秒）和 $M$，您必须计算出方案 $\\{ i_{i}[k] \\}$，以最小化最坏情况下的最终偏差\n$$\n\\delta = \\max_{i \\in \\{1,\\dots,N\\}} \\left\\lvert z_{i}(t_{f}) - \\bar{z} \\right\\rvert,\n$$\n同时受以下约束：\n离散化动态方程\n$$\nz_{i}(t_{f}) = z_{i}(0) + \\frac{\\Delta t}{Q_{i}} \\sum_{k=0}^{M-1} i_{i}[k],\n$$\n每一步的执行器饱和约束\n$$\n\\lvert i_{i}[k] \\rvert \\le I_{\\max} \\quad \\text{对所有 } i, k,\n$$\n以及每一步的电池包中性约束\n$$\n\\sum_{i=1}^{N} i_{i}[k] = 0 \\quad \\text{对所有 } k.\n$$\n\n您必须构建并求解一个有限维优化问题，其决策变量为 $\\{ i_{i}[k] \\}$ 和标量 $\\delta \\ge 0$，使得最小化的最优值 $\\delta^{\\star}$ 是在给定约束下可实现的最小最终SoC最大偏差。然后，对于每个测试用例，报告优化后的 $\\delta^{\\star}$，它是一个实数（无量纲SoC），四舍五入到六位小数。您无需输出方案 $\\{ i_{i}[k] \\}$；只需输出 $\\delta^{\\star}$。\n\n使用以下参数值测试套件，每个套件由一个元组 $\\left(N, \\{Q_{i}\\}_{i=1}^{N}, \\{ z_{i}(0) \\}_{i=1}^{N}, I_{\\max}, t_{f}, M\\right)$ 指定：\n\n- 测试用例1（一般情况）：\n  - $N = 4$，\n  - $\\{Q_{i}\\} = [10800, 10800, 10800, 10800]$，\n  - $\\{ z_{i}(0) \\} = [0.6, 0.5, 0.7, 0.4]$，\n  - $I_{\\max} = 2.0$，\n  - $t_{f} = 1800$，\n  - $M = 12$。\n\n- 测试用例2（时间和执行器受限）：\n  - $N = 3$，\n  - $\\{Q_{i}\\} = [9000, 9000, 9000]$，\n  - $\\{ z_{i}(0) \\} = [0.9, 0.6, 0.3]$，\n  - $I_{\\max} = 0.5$，\n  - $t_{f} = 1800$，\n  - $M = 9$。\n\n- 测试用例3（异构容量）：\n  - $N = 3$，\n  - $\\{Q_{i}\\} = [10800, 7200, 14400]$，\n  - $\\{ z_{i}(0) \\} = [0.8, 0.5, 0.6]$，\n  - $I_{\\max} = 1.0$，\n  - $t_{f} = 1200$，\n  - $M = 8$。\n\n- 测试用例4（短截止时间，近乎静态）：\n  - $N = 5$，\n  - $\\{Q_{i}\\} = [10000, 10000, 10000, 10000, 10000]$，\n  - $\\{ z_{i}(0) \\} = [0.52, 0.58, 0.54, 0.60, 0.51]$，\n  - $I_{\\max} = 0.1$，\n  - $t_{f} = 60$，\n  - $M = 6$。\n\n不涉及角度单位。物理单位已在上面指定。以无量纲SoC的形式输出最终的最大偏差值。\n\n最终输出格式要求：您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，“[result1,result2,result3,result4]”）。每个结果必须是相应测试用例的优化后的 $\\delta^{\\star}$，并四舍五入到六位小数。",
            "solution": "所呈现的问题是一个针对电池均衡系统的离散时间最优控制问题。其目标是确定一个控制序列——均衡电流 $\\{i_{i}[k]\\}$——以最小化在最终时间 $t_{f}$ 的最大状态偏差。系统的状态是电池荷电状态 (SoC) 的向量 $\\{z_i\\}$。该问题可以严格地表述并作为线性规划 (LP) 问题求解。\n\n首先，我们定义系统参数和变量。该系统由 $N$ 个串联电池组成。对于每个电池 $i \\in \\{1, \\dots, N\\}$，我们给定其电荷容量 $Q_{i}$ 和初始SoC $z_{i}(0)$。控制输入是均衡电流 $i_i(t)$，其受到最大幅值 $I_{\\max}$ 的约束。系统运行持续时间为 $t_f$。控制策略在 $M$ 个持续时间为 $\\Delta t = t_f/M$ 的区间上是分段常数。在时间区间 $[k\\Delta t, (k+1)\\Delta t)$ 内，电池 $i$ 的电流用 $i_i[k]$ 表示。\n\n当使用前向欧拉法进行离散化时，电池 $i$ 的SoC动态方程由下式给出：\n$$\nz_{i}[k+1] = z_{i}[k] + \\frac{\\Delta t}{Q_i} i_i[k]\n$$\n将此递推关系从 $k=0$ 展开到 $k=M-1$，在时间 $t_f = M \\Delta t$ 的最终SoC为：\n$$\nz_{i}(t_{f}) = z_{i}(0) + \\sum_{k=0}^{M-1} \\frac{\\Delta t}{Q_{i}} i_{i}[k] = z_{i}(0) + \\frac{\\Delta t}{Q_{i}} \\sum_{k=0}^{M-1} i_{i}[k]\n$$\n这个方程将最终状态与初始状态和控制动作联系起来。\n\n控制目标是最小化最终SoC与其电荷加权平均值 $\\bar{z}$ 之间的最坏情况偏差。平均SoC $\\bar{z}$ 是一个由初始条件和容量决定的常数，确保了电池包中总电荷的守恒：\n$$\n\\bar{z} = \\frac{\\sum_{i=1}^{N} Q_{i} z_{i}(0)}{\\sum_{i=1}^{N} Q_{i}}\n$$\n要最小化的量是标量 $\\delta$，定义为：\n$$\n\\delta = \\max_{i \\in \\{1, \\dots, N\\}} | z_i(t_f) - \\bar{z} |\n$$\n这是一个极小化极大优化问题。通过引入 $\\delta$ 作为决策变量并添加约束，可以将其转换为标准最小化问题。在 $\\delta$ 的定义下最小化它等价于：\n$$\n\\text{minimize} \\quad \\delta\n$$\n约束条件为：\n$$\n|z_i(t_f) - \\bar{z}| \\le \\delta \\quad \\text{对所有 } i \\in \\{1, \\dots, N\\}\n$$\n这 $N$ 个不等式约束可以展开为 $2N$ 个线性不等式：\n$$\nz_i(t_f) - \\bar{z} \\le \\delta \\quad \\text{和} \\quad -(z_i(t_f) - \\bar{z}) \\le \\delta\n$$\n代入 $z_i(t_f)$ 的表达式，我们得到：\n$$\n\\left( z_{i}(0) + \\frac{\\Delta t}{Q_{i}} \\sum_{k=0}^{M-1} i_{i}[k] \\right) - \\bar{z} \\le \\delta \\quad \\implies \\quad \\frac{\\Delta t}{Q_{i}} \\sum_{k=0}^{M-1} i_{i}[k] - \\delta \\le \\bar{z} - z_i(0)\n$$\n$$\n-\\left( z_{i}(0) + \\frac{\\Delta t}{Q_{i}} \\sum_{k=0}^{M-1} i_{i}[k] \\right) + \\bar{z} \\le \\delta \\quad \\implies \\quad -\\frac{\\Delta t}{Q_{i}} \\sum_{k=0}^{M-1} i_{i}[k] - \\delta \\le z_i(0) - \\bar{z}\n$$\n\n该问题还受到对控制输入 $i_i[k]$ 的物理和操作约束：\n1.  执行器饱和：每个电流的幅值是有限的。\n    $$\n    |i_i[k]| \\le I_{\\max} \\quad \\text{对所有 } i \\in \\{1, \\dots, N\\}, k \\in \\{0, \\dots, M-1\\}\n    $$\n    这等价于线性边界 $-I_{\\max} \\le i_i[k] \\le I_{\\max}$。\n\n2.  电池包中性：每个时间步的电流总和必须为零，反映了没有外部连接。\n    $$\n    \\sum_{i=1}^{N} i_i[k] = 0 \\quad \\text{对所有 } k \\in \\{0, \\dots, M-1\\}\n    $$\n\n这个完整的问题是一个线性规划 (LP) 问题。决策变量是 $N \\times M$ 个电流 $\\{i_i[k]\\}$ 和标量变量 $\\delta$。所有约束都是线性不等式或等式，目标函数是线性的。\n\n为了通过计算求解此问题，我们将其表述为标准LP形式：\n$$\n\\begin{aligned}\n\\text{minimize} \\quad  \\mathbf{c}^T \\mathbf{x} \\\\\n\\text{subject to} \\quad  \\mathbf{A}_{\\text{ub}} \\mathbf{x} \\le \\mathbf{b}_{\\text{ub}} \\\\\n \\mathbf{A}_{\\text{eq}} \\mathbf{x} = \\mathbf{b}_{\\text{eq}} \\\\\n \\mathbf{l} \\le \\mathbf{x} \\le \\mathbf{u}\n\\end{aligned}\n$$\n决策向量 $\\mathbf{x}$ 是通过堆叠所有 $N \\times M$ 个电流和变量 $\\delta$ 构建的。为了便于实现，使用基于0的索引 ($i \\in \\{0,\\dots,N-1\\}, k \\in \\{0,\\dots,M-1\\}$)，一个方便的排序是：\n$$\n\\mathbf{x} = [i_0[0], \\dots, i_{N-1}[0], i_0[1], \\dots, i_{N-1}[1], \\dots, i_0[M-1], \\dots, i_{N-1}[M-1], \\delta]^T\n$$\n决策变量的总数是 $NM+1$。$i_i[k]$ 的索引是 $k \\cdot N + i$，$\\delta$ 的索引是 $NM$。\n\nLP的组成部分如下：\n- **成本向量 $\\mathbf{c}$**：我们最小化 $\\delta$，所以 $\\mathbf{c}$ 是一个在对应于 $\\delta$ 的最后一个位置为1，其余位置为0的向量。\n$$\n\\mathbf{c} = [0, \\dots, 0, 1]^T\n$$\n- **边界**：电流的边界为 $[-I_{\\max}, I_{\\max}]$，且 $\\delta \\ge 0$。这些被指定为对 $\\mathbf{x}$ 的框约束。\n\n- **等式约束 $\\mathbf{A}_{\\text{eq}}, \\mathbf{b}_{\\text{eq}}$**：这些代表 $M$ 个电池包中性约束。对于每个时间步 $k \\in \\{0, \\dots, M-1\\}$，$\\sum_{i=0}^{N-1} i_i[k] = 0$。\n矩阵 $\\mathbf{A}_{\\text{eq}}$ 的维度是 $M \\times (NM+1)$。每一行 $k$ 对应于时间步 $k$ 的约束。它在变量 $i_0[k], \\dots, i_{N-1}[k]$ 的位置有值为1的条目，其他位置为0。向量 $\\mathbf{b}_{\\text{eq}}$ 是一个长度为 $M$ 的零向量。\n\n- **不等式约束 $\\mathbf{A}_{\\text{ub}}, \\mathbf{b}_{\\text{ub}}$**：这些代表来自极小化极大公式的 $2N$ 个约束。\n矩阵 $\\mathbf{A}_{\\text{ub}}$ 的维度是 $2N \\times (NM+1)$。对于每个电池 $i$，有两行。\n第 $2i$ 行对应于 $\\frac{\\Delta t}{Q_{i}} \\sum_{k=0}^{M-1} i_{i}[k] - \\delta \\le \\bar{z} - z_i(0)$。其条目对于变量 $i_i[k]$（对所有 $k$）为 $\\frac{\\Delta t}{Q_i}$，对于 $\\delta$ 为 $-1$，其余为 $0$。在 $\\mathbf{b}_{\\text{ub}}$ 中对应的值是 $\\bar{z} - z_i(0)$。\n第 $2i+1$ 行对应于 $-\\frac{\\Delta t}{Q_{i}} \\sum_{k=0}^{M-1} i_{i}[k] - \\delta \\le z_i(0) - \\bar{z}$。其条目对于变量 $i_i[k]$（对所有 $k$）为 $-\\frac{\\Delta t}{Q_i}$，对于 $\\delta$ 为 $-1$，其余为 $0$。在 $\\mathbf{b}_{\\text{ub}}$ 中对应的值是 $z_i(0) - \\bar{z}$。\n\n通过这种表述，可以使用一个标准的LP求解器，例如 `scipy.optimize.linprog`，来为每个测试用例找到最优值 $\\delta^\\star$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef solve():\n    \"\"\"\n    Solves a series of battery cell balancing optimization problems.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (N, Q_i, z_i(0), I_max, t_f, M)\n    test_cases = [\n        (4, np.array([10800, 10800, 10800, 10800]), np.array([0.6, 0.5, 0.7, 0.4]), 2.0, 1800, 12),\n        (3, np.array([9000, 9000, 9000]), np.array([0.9, 0.6, 0.3]), 0.5, 1800, 9),\n        (3, np.array([10800, 7200, 14400]), np.array([0.8, 0.5, 0.6]), 1.0, 1200, 8),\n        (5, np.array([10000, 10000, 10000, 10000, 10000]), np.array([0.52, 0.58, 0.54, 0.60, 0.51]), 0.1, 60, 6),\n    ]\n\n    results = []\n    for case in test_cases:\n        delta_star = solve_balancing_lp(case)\n        results.append(f\"{delta_star:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\ndef solve_balancing_lp(case):\n    \"\"\"\n    Formulates and solves the cell balancing problem as a Linear Program (LP).\n\n    Args:\n        case (tuple): A tuple containing the problem parameters\n                      (N, Q, z0, I_max, tf, M).\n\n    Returns:\n        float: The optimized minimum worst-case final deviation delta_star.\n    \"\"\"\n    N, Q, z0, I_max, tf, M = case\n\n    # -- 1. Calculate problem constants --\n    dt = tf / M\n    z_bar = np.sum(Q * z0) / np.sum(Q)\n\n    # -- 2. Define the LP structure --\n    # Decision variables x = [i_0[0], ..., i_{N-1}[0], ..., i_{N-1}[M-1], delta]^T\n    # Total number of variables is N*M currents + 1 delta\n    num_vars = N * M + 1\n    num_currents = N * M\n\n    # -- 3. Objective function: minimize delta --\n    # c vector is [0, 0, ..., 0, 1]\n    c = np.zeros(num_vars)\n    c[-1] = 1.0\n\n    # -- 4. Equality constraints: sum(i_i[k]) = 0 for each k --\n    # A_eq has M rows (one for each time step) and num_vars columns.\n    A_eq = np.zeros((M, num_vars))\n    for k in range(M):\n        start_col = k * N\n        end_col = start_col + N\n        A_eq[k, start_col:end_col] = 1.0\n    b_eq = np.zeros(M)\n    \n    # -- 5. Inequality constraints: |z_i(tf) - z_bar| = delta for each i --\n    # This gives 2*N constraints.\n    # A_ub has 2*N rows and num_vars columns.\n    A_ub = np.zeros((2 * N, num_vars))\n    b_ub = np.zeros(2 * N)\n    \n    for i in range(N):\n        # Constraint 1: (dt/Q_i) * sum(i_i[k]) - delta = z_bar - z0_i\n        # Constraint 2: -(dt/Q_i) * sum(i_i[k]) - delta = z0_i - z_bar\n\n        # Coefficients for sum(i_i[k])\n        current_coeffs = np.zeros(num_currents)\n        for k in range(M):\n            # Index of i_i[k] in the decision vector\n            current_idx = k * N + i\n            current_coeffs[current_idx] = dt / Q[i]\n            \n        # Row for constraint 1\n        A_ub[2 * i, :num_currents] = current_coeffs\n        A_ub[2 * i, -1] = -1.0  # Coefficient for delta\n        b_ub[2 * i] = z_bar - z0[i]\n        \n        # Row for constraint 2\n        A_ub[2 * i + 1, :num_currents] = -current_coeffs\n        A_ub[2 * i + 1, -1] = -1.0  # Coefficient for delta\n        b_ub[2 * i + 1] = z0[i] - z_bar\n\n    # -- 6. Bounds on decision variables --\n    # -I_max = i_i[k] = I_max\n    # delta >= 0\n    current_bounds = (-I_max, I_max)\n    delta_bounds = (0, None)\n    bounds = [current_bounds] * num_currents + [delta_bounds]\n\n    # -- 7. Solve the LP --\n    # The 'highs' method is generally robust and efficient for this type of problem.\n    result = linprog(c, A_ub=A_ub, b_ub=b_ub, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')\n\n    if result.success:\n        # The optimal value of the objective function is delta_star\n        return result.fun\n    else:\n        # This should not happen for a well-posed problem.\n        raise RuntimeError(f\"LP solver failed: {result.message}\")\n\nsolve()\n```"
        }
    ]
}