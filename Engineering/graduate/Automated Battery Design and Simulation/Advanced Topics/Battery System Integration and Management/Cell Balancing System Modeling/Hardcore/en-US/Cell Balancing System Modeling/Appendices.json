{
    "hands_on_practices": [
        {
            "introduction": "This problem explores a common diagnostic challenge in battery management: distinguishing true state-of-charge ($z$) imbalance from apparent voltage differences caused by cell-to-cell variations in parameters like series resistance. By simulating a two-cell pack with mismatched resistances, you will observe how transient voltage divergence during charging or discharging can create a \"false positive\" signal for imbalance, underscoring the need for more sophisticated state estimation beyond simple voltage comparison.",
            "id": "3898809",
            "problem": "Consider a two-cell lithium-ion pack modeled by a first-order Thevenin equivalent circuit, where both cells receive the same pack current. Adopt the sign convention that a positive current $I$ corresponds to charging. Each cell $i \\in \\{1,2\\}$ is modeled as an open-circuit voltage source with open-circuit voltage $U(z_{i})$ that depends on the state of charge $z_{i}$, a series resistance $R_{s,i}$, and a single polarization branch that produces a transient polarization voltage $v_{p,i}$. The measured terminal voltage of cell $i$ is\n$$\nV_{i}(t) = U(z_{i}(t)) + I\\,R_{s,i} + v_{p,i}(t).\n$$\nThis model is tractable yet scientifically realistic for inspecting transient voltage divergence that can falsely indicate imbalance when $R_{s,1} \\neq R_{s,2}$ even if $z_{1}(t) \\approx z_{2}(t)$.\n\nUse the following fundamental bases:\n1. The definition of state of charge for a cell of capacity $Q$ (in coulombs) under charging current $I$ is \n$$\n\\frac{dz_{i}}{dt} = \\frac{I}{Q},\n$$\nwith $z_{i}\\in[0,1]$ and $Q$ constant.\n2. For the polarization branch, apply the Thevenin resistor-capacitor dynamics derived from Kirchhoff’s Current Law (KCL). For a branch composed of resistor $R_{t}$ and capacitor $C_{t}$, the polarization voltage $v_{p,i}$ obeys\n$$\n\\frac{dv_{p,i}}{dt} = -\\frac{1}{R_{t}C_{t}}\\,v_{p,i} + \\frac{I}{C_{t}}.\n$$\n3. A smooth and physically plausible open-circuit voltage function $U(z)$ for a lithium-ion cell can be approximated by\n$$\nU(z) = 3.0 + 1.2\\,z + 0.1\\,\\tanh\\!\\left(\\frac{z - 0.5}{0.1}\\right),\n$$\nwhich produces a voltage range near typical values for $z \\in [0,1]$.\n\nStarting from these bases, derive the discrete-time update equations necessary to simulate the two-cell pack over a finite horizon using a uniform time step $\\Delta t$ and explicit time-stepping. You must implement a program that:\n- Initializes both cells with given $z_{i}(0)$ and $v_{p,i}(0)$.\n- Evolves $z_{i}(t)$, $v_{p,i}(t)$, and computes $V_{i}(t)$ using the above relationships.\n- Computes, for each specified parameter set, the following three quantities:\n  1. The maximum absolute terminal voltage divergence over the simulation window,\n     $$\n     \\max_{t\\in[0,T]} \\left| V_{1}(t) - V_{2}(t) \\right| \\quad \\text{in volts}.\n     $$\n  2. The final signed terminal voltage difference,\n     $$\n     V_{1}(T) - V_{2}(T) \\quad \\text{in volts}.\n     $$\n  3. A false-positive flag expressed as an integer ($0$ or $1$): output $1$ if there exists any time within $[0,T]$ at which $\\left|V_{1}(t)-V_{2}(t)\\right| \\geq V_{\\text{th}}$ while simultaneously $\\left|z_{1}(t)-z_{2}(t)\\right| \\leq \\varepsilon_{z}$, and output $0$ otherwise. This represents a naive voltage-threshold-based imbalance detector falsely flagging imbalance when the state of charge difference is small.\n\nUse the following explicit units and conventions:\n- Current $I$ in amperes ($\\mathrm{A}$).\n- Resistances $R_{s,i}$ and $R_{t}$ in ohms ($\\Omega$).\n- Capacitance $C_{t}$ in farads ($\\mathrm{F}$).\n- Capacity $Q$ in coulombs ($\\mathrm{C}$).\n- Time $T$ and time step $\\Delta t$ in seconds ($\\mathrm{s}$).\n- Voltages in volts ($\\mathrm{V}$).\n- State of charge $z$ is dimensionless.\n\nDiscretize the continuous-time dynamics with a uniform time step $\\Delta t$ using an explicit method that is stable for the given parameters, and clamp $z_{i}(t)$ to the interval $[0,1]$ during simulation to maintain physical plausibility.\n\nTest Suite:\nImplement your program to run the following four parameter sets. For each case, produce the three outputs described above, in the specified units and format.\n\nCase $1$ (happy path: moderate series resistance mismatch):\n- $I = 5\\ \\mathrm{A}$, $R_{s,1} = 0.010\\ \\Omega$, $R_{s,2} = 0.020\\ \\Omega$,\n- $R_{t} = 0.015\\ \\Omega$, $C_{t} = 2000\\ \\mathrm{F}$,\n- $Q = 7200\\ \\mathrm{C}$, $T = 100\\ \\mathrm{s}$, $\\Delta t = 0.1\\ \\mathrm{s}$,\n- $z_{1}(0) = 0.5$, $z_{2}(0) = 0.5$, $v_{p,1}(0) = 0.0\\ \\mathrm{V}$, $v_{p,2}(0) = 0.0\\ \\mathrm{V}$,\n- Voltage threshold $V_{\\text{th}} = 0.05\\ \\mathrm{V}$, state of charge tolerance $\\varepsilon_{z} = 0.001$.\n\nCase $2$ (boundary: identical series resistances):\n- $I = 5\\ \\mathrm{A}$, $R_{s,1} = 0.015\\ \\Omega$, $R_{s,2} = 0.015\\ \\Omega$,\n- $R_{t} = 0.015\\ \\Omega$, $C_{t} = 2000\\ \\mathrm{F}$,\n- $Q = 7200\\ \\mathrm{C}$, $T = 100\\ \\mathrm{s}$, $\\Delta t = 0.1\\ \\mathrm{s}$,\n- $z_{1}(0) = 0.5$, $z_{2}(0) = 0.5$, $v_{p,1}(0) = 0.0\\ \\mathrm{V}$, $v_{p,2}(0) = 0.0\\ \\mathrm{V}$,\n- $V_{\\text{th}} = 0.05\\ \\mathrm{V}$, $\\varepsilon_{z} = 0.001$.\n\nCase $3$ (edge: larger mismatch and higher current with different time constants):\n- $I = 10\\ \\mathrm{A}$, $R_{s,1} = 0.005\\ \\Omega$, $R_{s,2} = 0.030\\ \\Omega$,\n- $R_{t} = 0.020\\ \\Omega$, $C_{t} = 1200\\ \\mathrm{F}$,\n- $Q = 7200\\ \\mathrm{C}$, $T = 60\\ \\mathrm{s}$, $\\Delta t = 0.05\\ \\mathrm{s}$,\n- $z_{1}(0) = 0.6$, $z_{2}(0) = 0.6$, $v_{p,1}(0) = 0.0\\ \\mathrm{V}$, $v_{p,2}(0) = 0.0\\ \\mathrm{V}$,\n- $V_{\\text{th}} = 0.05\\ \\mathrm{V}$, $\\varepsilon_{z} = 0.001$.\n\nCase $4$ (edge: zero current baseline):\n- $I = 0\\ \\mathrm{A}$, $R_{s,1} = 0.020\\ \\Omega$, $R_{s,2} = 0.040\\ \\Omega$,\n- $R_{t} = 0.015\\ \\Omega$, $C_{t} = 2000\\ \\mathrm{F}$,\n- $Q = 7200\\ \\mathrm{C}$, $T = 50\\ \\mathrm{s}$, $\\Delta t = 0.1\\ \\mathrm{s}$,\n- $z_{1}(0) = 0.5$, $z_{2}(0) = 0.5$, $v_{p,1}(0) = 0.0\\ \\mathrm{V}$, $v_{p,2}(0) = 0.0\\ \\mathrm{V}$,\n- $V_{\\text{th}} = 0.05\\ \\mathrm{V}$, $\\varepsilon_{z} = 0.001$.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results for the four test cases as a comma-separated list enclosed in square brackets. Each test case’s result must itself be a list of the form\n$$\n\\left[\\max_{t} \\left| V_{1}(t) - V_{2}(t) \\right|,\\; V_{1}(T) - V_{2}(T),\\; \\text{flag}\\right],\n$$\nwhere the first two entries are floats in volts, and the third entry is an integer ($0$ or $1$). For example, your output should look like\n$$\n[\\,[x_{1},y_{1},b_{1}],\\,[x_{2},y_{2},b_{2}],\\,[x_{3},y_{3},b_{3}],\\,[x_{4},y_{4},b_{4}]\\,],\n$$\nwith all numerical values computed by your simulation in the specified units.",
            "solution": "The user-provided problem is valid. It is scientifically grounded in established battery modeling techniques (first-order Thevenin equivalent circuit model), well-posed with all necessary parameters and initial conditions for a unique solution, and objective in its formulation and requirements. The problem asks for the development and implementation of a discrete-time simulation for a two-cell battery pack to analyze voltage divergence under specific conditions.\n\nThe solution proceeds by first deriving the discrete-time update equations from the provided continuous-time model and then outlining the simulation algorithm designed to compute the required metrics.\n\n### 1. Continuous-Time Model Formulation\n\nThe system consists of two cells, each described by a state vector comprising its state of charge (SoC), $z_i(t)$, and its polarization voltage, $v_{p,i}(t)$. The dynamics of the system are governed by a set of ordinary differential equations (ODEs).\n\nThe state of charge $z_i(t)$ for cell $i$ evolves according to the principle of Coulomb counting:\n$$\n\\frac{dz_{i}}{dt} = \\frac{I}{Q}\n$$\nwhere $I$ is the pack current (positive for charging) and $Q$ is the total capacity of the cell in Coulombs.\n\nThe polarization voltage $v_{p,i}(t)$ captures the transient response of the cell and is modeled by the dynamics of a parallel resistor-capacitor (RC) circuit:\n$$\n\\frac{dv_{p,i}}{dt} = -\\frac{1}{R_{t}C_{t}}\\,v_{p,i}(t) + \\frac{I}{C_{t}}\n$$\nwhere $R_t$ and $C_t$ are the resistance and capacitance of the polarization branch, respectively. It is noted that these parameters are identical for both cells.\n\nThe terminal voltage of each cell, $V_i(t)$, is the algebraic sum of the open-circuit voltage (OCV), the voltage drop across the series resistance, and the polarization voltage:\n$$\nV_{i}(t) = U(z_{i}(t)) + I\\,R_{s,i} + v_{p,i}(t)\n$$\nThe OCV, $U(z)$, is a nonlinear function of the state of charge, given by:\n$$\nU(z) = 3.0 + 1.2\\,z + 0.1\\,\\tanh\\!\\left(\\frac{z - 0.5}{0.1}\\right)\n$$\n\n### 2. Discretization of the Model\n\nTo simulate the system numerically, we discretize the continuous-time ODEs using the explicit (forward) Euler method with a uniform time step $\\Delta t$. Let the subscript $k$ denote the evaluation of a variable at time $t_k = k \\Delta t$.\n\nThe update equation for the state of charge $z_{i,k}$ is derived from its definition:\n$$\nz_{i,k+1} = z_{i,k} + \\frac{I \\Delta t}{Q}\n$$\nTo maintain physical realism, the state of charge is clamped to the interval $[0, 1]$ after each update:\n$$\nz_{i,k+1} = \\max(0, \\min(1, z_{i,k+1}))\n$$\n\nThe update equation for the polarization voltage $v_{p,i,k}$ is similarly derived:\n$$\nv_{p,i,k+1} = v_{p,i,k} + \\Delta t \\left( -\\frac{1}{R_{t}C_{t}} v_{p,i,k} + \\frac{I}{C_t} \\right)\n$$\nRearranging the terms yields the final update rule:\n$$\nv_{p,i,k+1} = \\left( 1 - \\frac{\\Delta t}{R_{t}C_{t}} \\right) v_{p,i,k} + \\frac{I \\Delta t}{C_{t}}\n$$\n\nWith the states at step $k+1$ determined, the terminal voltage $V_{i,k+1}$ can be calculated using the values of the states at that same step:\n$$\nV_{i,k+1} = U(z_{i,k+1}) + I R_{s,i} + v_{p,i,k+1}\n$$\n\n### 3. Simulation Algorithm and Output Metrics\n\nThe simulation is performed over the time interval $[0, T]$. The algorithm proceeds as follows:\n\n1.  **Initialization**:\n    -   Set the parameters for the specific test case: $I, R_{s,1}, R_{s,2}, R_t, C_t, Q, T, \\Delta t, V_{\\text{th}}, \\varepsilon_z$.\n    -   Initialize the state variables for both cells to their given initial conditions at $t=0$: $z_{1,0}, z_{2,0}, v_{p,1,0}, v_{p,2,0}$.\n    -   Initialize the output metrics: `max_voltage_divergence = 0.0` and `false_positive_flag = 0`.\n    -   Determine the total number of simulation steps, $N = \\text{round}(T / \\Delta t)$.\n\n2.  **Time-Stepping Loop**:\n    -   Execute a loop for $k$ from $0$ to $N$ (inclusive) to cover all time points from $t=0$ to $t=T$.\n    -   At each step $k$, corresponding to time $t_k = k \\Delta t$:\n        a.  **Calculate Outputs**: Compute the terminal voltages $V_{1,k}$ and $V_{2,k}$ using the current state values ($z_{i,k}, v_{p,i,k}$).\n        b.  **Update Metrics**:\n            i.  Calculate the absolute voltage divergence $|V_{1,k} - V_{2,k}|$ and update `max_voltage_divergence` if this value is greater than the current maximum.\n            ii. Calculate the absolute SoC difference $|z_{1,k} - z_{2,k}|$.\n            iii. Check for the false-positive condition: if `false_positive_flag` is not yet set, evaluate if $|V_{1,k} - V_{2,k}| \\ge V_{\\text{th}}$ and $|z_{1,k} - z_{2,k}| \\le \\varepsilon_z$. If both are true, set `false_positive_flag = 1`.\n        c.  **Store Final Difference**: If $k=N$ (the final step), store the signed difference $V_{1,N} - V_{2,N}$ as `final_voltage_difference`.\n        d.  **Update States**: If $k  N$, compute the next states $z_{i,k+1}$ and $v_{p,i,k+1}$ using the discrete-time update equations derived above.\n\n3.  **Result Aggregation**:\n    -   After the loop completes, collect the three computed metrics: `max_voltage_divergence`, `final_voltage_difference`, and `false_positive_flag`. This triplet constitutes the result for one test case.\n\nThis algorithm is implemented for each of the four specified parameter sets to generate the final output. A crucial observation for the given test cases is that since both cells start with identical states ($z_1(0)=z_2(0)$, $v_{p1}(0)=v_{p2}(0)$) and are subjected to identical dynamics (same $I, Q, R_t, C_t$), their states will remain identical throughout the simulation, i.e., $z_1(t) \\equiv z_2(t)$ and $v_{p1}(t) \\equiv v_{p2}(t)$. Consequently, the voltage difference $V_1(t) - V_2(t)$ simplifies to $I(R_{s,1} - R_{s,2})$, which is constant over time. The implementation will nevertheless perform the full simulation as instructed.",
            "answer": "```python\nimport numpy as np\nimport math\n\n# Adherence to specified library versions (numpy==1.23.5) is assumed.\n# The `math.tanh` function is part of the standard library.\n\ndef solve():\n    \"\"\"\n    Main function to run the simulations for all test cases and print the results.\n    \"\"\"\n\n    test_cases = [\n        # Case 1 (happy path: moderate series resistance mismatch)\n        {\n            \"I\": 5.0, \"Rs1\": 0.010, \"Rs2\": 0.020,\n            \"Rt\": 0.015, \"Ct\": 2000.0,\n            \"Q\": 7200.0, \"T\": 100.0, \"dt\": 0.1,\n            \"z1_0\": 0.5, \"z2_0\": 0.5, \"vp1_0\": 0.0, \"vp2_0\": 0.0,\n            \"V_th\": 0.05, \"epsilon_z\": 0.001,\n        },\n        # Case 2 (boundary: identical series resistances)\n        {\n            \"I\": 5.0, \"Rs1\": 0.015, \"Rs2\": 0.015,\n            \"Rt\": 0.015, \"Ct\": 2000.0,\n            \"Q\": 7200.0, \"T\": 100.0, \"dt\": 0.1,\n            \"z1_0\": 0.5, \"z2_0\": 0.5, \"vp1_0\": 0.0, \"vp2_0\": 0.0,\n            \"V_th\": 0.05, \"epsilon_z\": 0.001,\n        },\n        # Case 3 (edge: larger mismatch and higher current)\n        {\n            \"I\": 10.0, \"Rs1\": 0.005, \"Rs2\": 0.030,\n            \"Rt\": 0.020, \"Ct\": 1200.0,\n            \"Q\": 7200.0, \"T\": 60.0, \"dt\": 0.05,\n            \"z1_0\": 0.6, \"z2_0\": 0.6, \"vp1_0\": 0.0, \"vp2_0\": 0.0,\n            \"V_th\": 0.05, \"epsilon_z\": 0.001,\n        },\n        # Case 4 (edge: zero current baseline)\n        {\n            \"I\": 0.0, \"Rs1\": 0.020, \"Rs2\": 0.040,\n            \"Rt\": 0.015, \"Ct\": 2000.0,\n            \"Q\": 7200.0, \"T\": 50.0, \"dt\": 0.1,\n            \"z1_0\": 0.5, \"z2_0\": 0.5, \"vp1_0\": 0.0, \"vp2_0\": 0.0,\n            \"V_th\": 0.05, \"epsilon_z\": 0.001,\n        },\n    ]\n\n    all_results = []\n    for params in test_cases:\n        result = run_simulation(params)\n        all_results.append(result)\n\n    # Format the final output as a string representing a list of lists.\n    # e.g., [[x1,y1,b1],[x2,y2,b2],...]\n    result_str = \"[\" + \",\".join([f\"[{r[0]},{r[1]},{r[2]}]\" for r in all_results]) + \"]\"\n    print(result_str)\n\ndef U_func(z):\n    \"\"\"\n    Computes the Open-Circuit Voltage (OCV) as a function of State of Charge (SoC).\n    U(z) = 3.0 + 1.2*z + 0.1*tanh((z - 0.5)/0.1)\n    \"\"\"\n    return 3.0 + 1.2 * z + 0.1 * math.tanh((z - 0.5) / 0.1)\n\ndef run_simulation(params):\n    \"\"\"\n    Performs a single simulation run for a given set of parameters.\n    \"\"\"\n    # Unpack parameters\n    I, Rs1, Rs2 = params[\"I\"], params[\"Rs1\"], params[\"Rs2\"]\n    Rt, Ct = params[\"Rt\"], params[\"Ct\"]\n    Q, T, dt = params[\"Q\"], params[\"T\"], params[\"dt\"]\n    V_th, epsilon_z = params[\"V_th\"], params[\"epsilon_z\"]\n\n    # Initialize state variables\n    z1, z2 = params[\"z1_0\"], params[\"z2_0\"]\n    vp1, vp2 = params[\"vp1_0\"], params[\"vp2_0\"]\n\n    # Initialize metrics\n    max_voltage_divergence = 0.0\n    final_voltage_difference = 0.0\n    false_positive_flag = 0\n\n    # Simulation setup\n    num_steps = int(round(T / dt))\n    \n    # Pre-calculate constants for the update equations\n    # v_p,k+1 = vp_alpha * v_p,k + vp_beta\n    vp_alpha = 1.0 - dt / (Rt * Ct)\n    vp_beta = (I * dt) / Ct\n    # z_k+1 = z_k + dz\n    dz = (I * dt) / Q\n\n    for k in range(num_steps + 1):\n        # 1. Calculate outputs at the current time step k\n        U1 = U_func(z1)\n        U2 = U_func(z2)\n        \n        V1 = U1 + I * Rs1 + vp1\n        V2 = U2 + I * Rs2 + vp2\n\n        # 2. Update metrics\n        current_voltage_divergence = abs(V1 - V2)\n        if current_voltage_divergence  max_voltage_divergence:\n            max_voltage_divergence = current_voltage_divergence\n\n        current_soc_difference = abs(z1 - z2)\n        if false_positive_flag == 0:\n            if current_voltage_divergence = V_th and current_soc_difference = epsilon_z:\n                false_positive_flag = 1\n        \n        # 3. Store final difference at the end of the simulation\n        if k == num_steps:\n            final_voltage_difference = V1 - V2\n            break \n            \n        # 4. Update states for the next time step (k+1)\n        # Polarization voltage update\n        vp1 = vp_alpha * vp1 + vp_beta\n        vp2 = vp_alpha * vp2 + vp_beta\n\n        # State of charge update and clamping\n        z1 = z1 + dz\n        z2 = z2 + dz\n        z1 = max(0.0, min(1.0, z1))\n        z2 = max(0.0, min(1.0, z2))\n\n    return [max_voltage_divergence, final_voltage_difference, false_positive_flag]\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "Since direct voltage comparison is unreliable, this exercise delves into robust state estimation using the Kalman Filter. The goal of a Kalman Filter is to produce an optimal estimate of a system's internal states—like state-of-charge $z_k$ and polarization voltage $v_{p,k}$—by fusing a predictive model with noisy measurements. This hands-on practice focuses on the core of the filter's design: computing the filter's covariance and gain matrices to understand how estimation uncertainty evolves and how the filter balances its trust between the model and incoming data.",
            "id": "3898745",
            "problem": "You are tasked with modeling a single lithium-ion cell under a balancing system and deriving the linearized measurement model needed to compute the Kalman Filter (KF) gains and the estimation error covariance evolution. The modeling context is the cell balancing system, where the bypass current is used to regulate the charge state across cells. The goal is to derive, implement, and analyze the Riccati recursion for the estimation error covariance and compute the KF gains for a noisy voltage measurement linearized around a chosen operating point.\n\nBegin from the following fundamental base:\n\n- Conservation of electric charge: the State of Charge (SoC) is defined as $z \\in [0,1]$ and evolves according to $$\\frac{dq}{dt} = -I + b,$$ where $q$ is the stored charge in Coulombs, $I$ is cell current in Amperes, and $b$ is bypass balancing current in Amperes. The nominal capacity $C_{\\mathrm{nom}}$ converts between stored charge and SoC via $q = C_{\\mathrm{nom}} z$, so that $$\\frac{dz}{dt} = \\frac{-I + b}{C_{\\mathrm{nom}}}.$$\n- First-order Resistor-Capacitor (RC) polarization voltage dynamics: the polarization voltage $v_p$ satisfies $$\\frac{dv_p}{dt} = -\\frac{1}{\\tau_p} v_p + \\frac{R_p}{\\tau_p} I,$$ where $\\tau_p$ is the polarization time constant in seconds and $R_p$ is the polarization resistance in Ohms.\n- The open-circuit voltage $U(z)$ is modeled by a monotone function of the SoC. For this problem, use $$U(z) = U_{\\mathrm{ref}} + \\alpha_U \\ln(z) - \\beta_U \\ln(1-z),$$ where $U_{\\mathrm{ref}}$ is in Volts and $\\alpha_U,\\beta_U$ are in Volts. This is a well-tested empirical form for open-circuit voltage as a function of SoC in a range away from the endpoints $z=0$ and $z=1$.\n\nThe measured terminal voltage $V_k$ at discrete time step $k$ is $$V_k = U(z_k) + v_{p,k} + I_k R_s + w_k,$$ where $R_s$ is the series resistance in Ohms, and $w_k$ is zero-mean measurement noise with variance $R$ in $\\mathrm{V}^2$.\n\nDiscretize the dynamics with sampling period $\\Delta t$ seconds using a standard forward-Euler discrete-time approximation for the SoC and an exact discretization of the linear $v_p$ dynamics:\n- $$z_{k+1} = z_k + \\frac{-I_k + b_k}{C_{\\mathrm{nom}}} \\Delta t + \\eta_{z,k},$$\n- $$v_{p,k+1} = \\mathrm{e}^{-\\Delta t/\\tau_p} v_{p,k} + R_p \\left(1-\\mathrm{e}^{-\\Delta t/\\tau_p}\\right) I_k + \\eta_{p,k},$$\nwhere $\\eta_{z,k}$ and $\\eta_{p,k}$ are zero-mean process noises with variances $Q_z$ (dimensionless squared for SoC) and $Q_{vp}$ (in $\\mathrm{V}^2$), respectively. Let the state be $x_k = [z_k,\\ v_{p,k}]^\\top$.\n\nLinearize the measurement $V_k$ with respect to the state $x_k$ around an operating point $x^\\star = [z^\\star,\\ v_p^\\star]^\\top$. The linearized measurement is $$V_k \\approx h(x^\\star) + H (x_k - x^\\star) + w_k,$$ with Jacobian\n$$H = \\begin{bmatrix} \\frac{dU}{dz}(z^\\star)  1 \\end{bmatrix}, \\quad \\frac{dU}{dz}(z) = \\frac{\\alpha_U}{z} + \\frac{\\beta_U}{1-z}.$$\nThe linearized state transition Jacobian is\n$$F = \\begin{bmatrix} 1  0 \\\\ 0  \\mathrm{e}^{-\\Delta t/\\tau_p} \\end{bmatrix}.$$\nAssume the process noise covariance is $$Q = \\mathrm{diag}\\left(Q_z,\\ Q_{vp}\\right),$$ and measurement noise variance is $$R.$$\n\nYour tasks:\n\n1. Derive from first principles the discrete-time covariance Riccati recursion for the linearized system. Explain clearly how the KF gain depends on the prior covariance and the measurement Jacobian. Specifically, from the linearized model and the Gaussian noise assumptions, derive the prediction covariance $$P_k^- = F P_{k-1} F^\\top + Q,$$ the innovation variance $$S_k = H P_k^- H^\\top + R,$$ the KF gain $$K_k = P_k^- H^\\top S_k^{-1},$$ and the posterior covariance $$P_k = (I - K_k H) P_k^-,$$ where $P_k$ is the estimation error covariance at time $k$, $I$ is the identity matrix of appropriate dimension, and $P_0$ is a given initial covariance.\n2. Implement a program that computes the KF gains $K_k$ and the posterior covariance $P_k$ over a fixed horizon of $N$ steps for the given test cases, using the linearized model computed at the specified operating point $z^\\star$ and parameters. The program should not use any external measurements; it should focus solely on the covariance recursion and KF gain computation.\n3. Analyze how the estimation error covariance evolves under different noise and dynamics conditions, especially the roles of $R$ (measurement noise variance), $Q$ (process noise covariance), $\\tau_p$ (polarization time constant), and $\\Delta t$ (sampling period), in the provided test suite.\n\nUnits and data:\n\n- Express all voltages in $\\mathrm{V}$, currents in $\\mathrm{A}$, resistances in $\\Omega$, time in $\\mathrm{s}$, capacity in $\\mathrm{A\\cdot h}$ for tabulation but convert to Coulombs in the code via $C_{\\mathrm{nom}}[\\mathrm{C}] = C_{\\mathrm{nom}}[\\mathrm{A\\cdot h}] \\times 3600$. SoC $z$ is dimensionless and must be treated as a decimal (e.g., $0.6$).\n- The program must compute and report results strictly in floating-point numbers.\n\nTest suite:\n\nCompute the KF gain sequence and covariance evolution for $N$ steps, returning the final ($k=N$) KF gain vector entries and the final posterior covariance diagonal entries for each case. Use the following three test cases:\n\n- Case A (nominal): \n  - $C_{\\mathrm{nom}} = 2.5\\ \\mathrm{A\\cdot h}$, $\\Delta t = 1.0\\ \\mathrm{s}$, $\\tau_p = 20.0\\ \\mathrm{s}$, $R_p = 0.015\\ \\Omega$, $R_s = 0.010\\ \\Omega$,\n  - $U_{\\mathrm{ref}} = 3.6\\ \\mathrm{V}$, $\\alpha_U = 0.12\\ \\mathrm{V}$, $\\beta_U = 0.12\\ \\mathrm{V}$,\n  - $z^\\star = 0.6$, $I_k = 2.0\\ \\mathrm{A}$ (constant), $b_k = 0.0\\ \\mathrm{A}$ (constant),\n  - $Q_z = 1.0\\times 10^{-9}$, $Q_{vp} = 1.0\\times 10^{-6}\\ \\mathrm{V}^2$, $R = 1.0\\times 10^{-4}\\ \\mathrm{V}^2$,\n  - $P_0 = \\mathrm{diag}(1.0\\times 10^{-4},\\ 1.0\\times 10^{-3})$, $N = 30$.\n- Case B (high measurement noise with balancing): \n  - $C_{\\mathrm{nom}} = 2.5\\ \\mathrm{A\\cdot h}$, $\\Delta t = 1.0\\ \\mathrm{s}$, $\\tau_p = 10.0\\ \\mathrm{s}$, $R_p = 0.020\\ \\Omega$, $R_s = 0.020\\ \\Omega$,\n  - $U_{\\mathrm{ref}} = 3.6\\ \\mathrm{V}$, $\\alpha_U = 0.12\\ \\mathrm{V}$, $\\beta_U = 0.12\\ \\mathrm{V}$,\n  - $z^\\star = 0.5$, $I_k = 5.0\\ \\mathrm{A}$ (constant), $b_k = 0.5\\ \\mathrm{A}$ (constant),\n  - $Q_z = 5.0\\times 10^{-9}$, $Q_{vp} = 5.0\\times 10^{-6}\\ \\mathrm{V}^2$, $R = 4.0\\times 10^{-2}\\ \\mathrm{V}^2$,\n  - $P_0 = \\mathrm{diag}(5.0\\times 10^{-4},\\ 5.0\\times 10^{-3})$, $N = 30$.\n- Case C (low measurement noise, fast polarization, higher current and series resistance): \n  - $C_{\\mathrm{nom}} = 2.5\\ \\mathrm{A\\cdot h}$, $\\Delta t = 0.5\\ \\mathrm{s}$, $\\tau_p = 2.0\\ \\mathrm{s}$, $R_p = 0.025\\ \\Omega$, $R_s = 0.050\\ \\Omega$,\n  - $U_{\\mathrm{ref}} = 3.6\\ \\mathrm{V}$, $\\alpha_U = 0.12\\ \\mathrm{V}$, $\\beta_U = 0.12\\ \\mathrm{V}$,\n  - $z^\\star = 0.9$, $I_k = 10.0\\ \\mathrm{A}$ (constant), $b_k = 1.0\\ \\mathrm{A}$ (constant),\n  - $Q_z = 1.0\\times 10^{-8}$, $Q_{vp} = 1.0\\times 10^{-5}\\ \\mathrm{V}^2$, $R = 1.0\\times 10^{-6}\\ \\mathrm{V}^2$,\n  - $P_0 = \\mathrm{diag}(1.0\\times 10^{-3},\\ 1.0\\times 10^{-3})$, $N = 30$.\n\nNote that $I_k R_s$ does not affect the Jacobian $H$ with respect to the state $x_k$, so it is treated as a known offset in the measurement model after linearization. The KF gain and covariance evolution can be computed solely from $F$, $Q$, $H$, $R$, and $P_0$.\n\nFinal output format:\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each test case result must be a list of four floating-point numbers in the order $[K_{z,N}, K_{vp,N}, P_{zz,N}, P_{vp\\,vp,N}]$, where $K_{z,N}$ and $K_{vp,N}$ are the components of the final KF gain vector $K_N$, and $P_{zz,N}$ and $P_{vp\\,vp,N}$ are the diagonal entries of the final posterior covariance $P_N$. The overall output must be a single list of these per-case lists, for example, $[[\\dots],[\\dots],[\\dots]]$.",
            "solution": "The problem statement is evaluated for validity before proceeding to a solution.\n\n### Step 1: Extract Givens\n\nThe provided information is as follows:\n\n**State and Dynamics Equations:**\n- State of Charge (SoC) definition: $z \\in [0,1]$.\n- Continuous-time charge dynamics: $\\frac{dq}{dt} = -I + b$, with $q = C_{\\mathrm{nom}} z$.\n- Continuous-time SoC dynamics: $\\frac{dz}{dt} = \\frac{-I + b}{C_{\\mathrm{nom}}}$.\n- Continuous-time polarization voltage dynamics: $\\frac{dv_p}{dt} = -\\frac{1}{\\tau_p} v_p + \\frac{R_p}{\\tau_p} I$.\n- Open-circuit voltage (OCV) model: $U(z) = U_{\\mathrm{ref}} + \\alpha_U \\ln(z) - \\beta_U \\ln(1-z)$.\n\n**Discrete-Time Model (Sampling Period $\\Delta t$):**\n- State vector: $x_k = [z_k, v_{p,k}]^\\top$.\n- Discrete SoC dynamics: $z_{k+1} = z_k + \\frac{-I_k + b_k}{C_{\\mathrm{nom}}} \\Delta t + \\eta_{z,k}$.\n- Discrete polarization voltage dynamics: $v_{p,k+1} = \\mathrm{e}^{-\\Delta t/\\tau_p} v_{p,k} + R_p \\left(1-\\mathrm{e}^{-\\Delta t/\\tau_p}\\right) I_k + \\eta_{p,k}$.\n- Measurement model: $V_k = U(z_k) + v_{p,k} + I_k R_s + w_k$.\n\n**Linearized Model and Noise Statistics:**\n- Process noise sources $\\eta_{z,k}$ and $\\eta_{p,k}$ are zero-mean with variances $Q_z$ and $Q_{vp}$, respectively.\n- Measurement noise $w_k$ is zero-mean with variance $R$.\n- Process noise covariance matrix: $Q = \\mathrm{diag}(Q_z, Q_{vp})$.\n- State transition Jacobian: $F = \\begin{bmatrix} 1  0 \\\\ 0  \\mathrm{e}^{-\\Delta t/\\tau_p} \\end{bmatrix}$.\n- Measurement Jacobian (linearized around $x^\\star = [z^\\star, v_p^\\star]^\\top$): $H = \\begin{bmatrix} \\frac{dU}{dz}(z^\\star)  1 \\end{bmatrix}$, where $\\frac{dU}{dz}(z) = \\frac{\\alpha_U}{z} + \\frac{\\beta_U}{1-z}$.\n\n**Kalman Filter Equations (to be derived and used):**\n- Initial error covariance: $P_0$.\n- Prediction covariance: $P_k^- = F P_{k-1} F^\\top + Q$.\n- Innovation variance: $S_k = H P_k^- H^\\top + R$.\n- Kalman Filter gain: $K_k = P_k^- H^\\top S_k^{-1}$.\n- Posterior covariance: $P_k = (I - K_k H) P_k^-$.\n\n**Unit Conversions and Data:**\n- Capacity is given in $\\mathrm{A \\cdot h}$ and must be converted to Coulombs using $C_{\\mathrm{nom}}[\\mathrm{C}] = C_{\\mathrm{nom}}[\\mathrm{A\\cdot h}] \\times 3600$.\n- The number of steps for the recursion is $N=30$.\n- Three test cases (A, B, C) are provided with specific parameter values for all constants and initial conditions.\n\n### Step 2: Validate Using Extracted Givens\n\n- **Scientifically Grounded:** The problem is based on established principles of electrical engineering (RC circuits), electrochemistry (battery modeling), and control theory (Kalman filtering). The battery model is a standard first-order equivalent circuit model (ECM), and the application of a Kalman filter for state estimation is a canonical problem in this field. The model for OCV is empirically validated.\n- **Well-Posed:** The problem is well-posed. It asks for the computation of Kalman filter gains and covariance evolution, which are uniquely determined by the provided Riccati recursion equations and a complete set of parameters for each test case.\n- **Objective:** The problem is stated in precise, objective, and mathematical language. There are no subjective or opinion-based elements.\n- **Completeness and Consistency:** The problem is self-contained. All necessary equations, parameters, initial conditions, and constants are provided for each of the three test cases. There are no contradictions in the provided data.\n- **Realism and Feasibility:** The parameter values are realistic for lithium-ion cells. The task of computing the covariance evolution is a standard and feasible computational task.\n\n### Step 3: Verdict and Action\n\nThe problem is **valid**. It is a well-defined and standard problem in engineering state estimation. A solution will be provided.\n\n### Solution\n\nThe task is to derive the Kalman Filter (KF) covariance update equations (the discrete-time Riccati recursion) and then implement a simulation to compute the KF gain and error covariance evolution for a linearized battery model.\n\n**1. Derivation of the Covariance Riccati Recursion**\n\nThe Kalman Filter is an optimal estimator for linear systems with Gaussian noise. It operates in a two-step cycle: prediction and update. We are concerned here with the propagation of the estimation error covariance, which describes the uncertainty of our state estimate. Let the true state be $x_k$ and its estimate be $\\hat{x}_k$. The estimation error is $e_k = x_k - \\hat{x}_k$. The error covariance is $P_k = E[e_k e_k^\\top]$, where $E[\\cdot]$ is the expectation operator.\n\nThe filter uses two estimates: the a priori estimate $\\hat{x}_k^-$, calculated before the measurement at time $k$ is incorporated, and the a posteriori estimate $\\hat{x}_k$, calculated after. The corresponding error covariances are $P_k^- = E[e_k^- (e_k^-)^\\top]$ and $P_k = E[e_k e_k^\\top]$.\n\n**Prediction Step:**\nThe state evolves according to the linearized model $x_k = F x_{k-1} + \\text{terms} + v_{k-1}$, where $v_{k-1}$ is the process noise with covariance $Q$. The a priori state estimate at time $k$ is predicted from the a posteriori estimate at time $k-1$:\n$\\hat{x}_k^- = F \\hat{x}_{k-1} + \\text{known terms}$.\nThe a priori error $e_k^- = x_k - \\hat{x}_k^-$ is then:\n$$e_k^- = (F x_{k-1} + v_{k-1}) - F \\hat{x}_{k-1} = F (x_{k-1} - \\hat{x}_{k-1}) + v_{k-1} = F e_{k-1} + v_{k-1}$$\nThe covariance of this a priori error is $P_k^- = E[e_k^- (e_k^-)^\\top]$:\n$$P_k^- = E[(F e_{k-1} + v_{k-1})(F e_{k-1} + v_{k-1})^\\top] = E[F e_{k-1} e_{k-1}^\\top F^\\top + F e_{k-1} v_{k-1}^\\top + v_{k-1} e_{k-1}^\\top F^\\top + v_{k-1} v_{k-1}^\\top]$$\nAssuming the estimation error at time $k-1$ is uncorrelated with the process noise at time $k-1$ (i.e., $E[e_{k-1} v_{k-1}^\\top] = 0$), this simplifies to:\n$$P_k^- = F E[e_{k-1} e_{k-1}^\\top] F^\\top + E[v_{k-1} v_{k-1}^\\top]$$\nThis yields the first Riccati equation, the **prediction covariance update**:\n$$P_k^- = F P_{k-1} F^\\top + Q$$\n\n**Update Step:**\nThe measurement at time $k$ is given by the linearized model $V_k \\approx h(x^\\star) + H (x_k - x^\\star) + w_k$. Let's define the measurement residual, or **innovation**, $\\tilde{y}_k$, as the difference between the actual measurement and the predicted measurement:\n$$\\tilde{y}_k = V_k - (h(x^\\star) + H(\\hat{x}_k^- - x^\\star))$$\nSubstituting the expression for $V_k$ and using $x_k = \\hat{x}_k^- + e_k^-$:\n$$\\tilde{y}_k = (h(x^\\star) + H(x_k - x^\\star) + w_k) - (h(x^\\star) + H(\\hat{x}_k^- - x^\\star)) = H(x_k - \\hat{x}_k^-) + w_k = H e_k^- + w_k$$\nThe variance of the innovation, $S_k$, is:\n$$S_k = E[\\tilde{y}_k \\tilde{y}_k^\\top] = E[(H e_k^- + w_k)(H e_k^- + w_k)^\\top]$$\nAssuming the a priori error $e_k^-$ and measurement noise $w_k$ are uncorrelated, this becomes:\n$$S_k = H E[e_k^- (e_k^-)^\\top] H^\\top + E[w_k w_k^\\top]$$\nThis is the **innovation variance** equation:\n$$S_k = H P_k^- H^\\top + R$$\nThe a posteriori state estimate is a linear combination of the a priori estimate and the innovation, weighted by the **Kalman gain** $K_k$:\n$$\\hat{x}_k = \\hat{x}_k^- + K_k \\tilde{y}_k$$\nThe gain $K_k$ is chosen to minimize the trace of the a posteriori error covariance $P_k$. The optimal gain is given by:\n$$K_k = E[e_k^- \\tilde{y}_k^\\top] S_k^{-1} = E[e_k^- (H e_k^- + w_k)^\\top] S_k^{-1} = E[e_k^- (e_k^-)^\\top] H^\\top S_k^{-1} = P_k^- H^\\top S_k^{-1}$$\nThis is the **Kalman gain** equation:\n$$K_k = P_k^- H^\\top S_k^{-1}$$\nThe gain $K_k$ optimally balances trust between the model prediction (embedded in $P_k^-$) and the new measurement (with uncertainty $R$). If the prior uncertainty $P_k^-$ is high, the gain will be large, putting more weight on the measurement. Conversely, if measurement noise $R$ is high, the gain will be small, and the filter will trust its own prediction more. The Jacobian $H$ maps state uncertainty into measurement uncertainty; if a state has a large effect on the measurement (large $H$ component), the filter can correct that state more effectively.\n\nFinally, we derive the a posteriori error covariance $P_k$. The posterior error is:\n$$e_k = x_k - \\hat{x}_k = x_k - (\\hat{x}_k^- + K_k \\tilde{y}_k) = (x_k - \\hat{x}_k^-) - K_k (H e_k^- + w_k) = e_k^- - K_k H e_k^- - K_k w_k = (I - K_k H) e_k^- - K_k w_k$$\nThe covariance $P_k = E[e_k e_k^\\top]$ is:\n$$P_k = E[((I - K_k H) e_k^- - K_k w_k)((I - K_k H) e_k^- - K_k w_k)^\\top]$$\nExpanding and using the uncorrelation between $e_k^-$ and $w_k$:\n$$P_k = (I - K_k H) E[e_k^- (e_k^-)^\\top] (I - K_k H)^\\top + K_k E[w_k w_k^\\top] K_k^\\top = (I - K_k H) P_k^- (I - K_k H)^\\top + K_k R K_k^\\top$$\nThis is the Joseph form of the covariance update, which is known for its numerical stability. The form given in the problem statement, $P_k = (I - K_k H) P_k^-$, is a valid simplification assuming $K_k$ was computed optimally as above. This simplification makes the update computationally cheaper and is sufficient for this problem.\n\n**2. Implementation and Analysis**\n\nThe derived Riccati recursion allows us to compute the evolution of the estimation error covariance $P_k$ and the corresponding Kalman gain $K_k$ without needing actual measurement data. The logic iterates the four derived equations for $N$ steps, starting from an initial covariance $P_0$.\n\n**Analysis of Parameter Effects on Covariance Evolution:**\n- **Measurement Noise ($R$):** Case B features a very large $R=4.0\\times 10^{-2}\\ \\mathrm{V}^2$. A high $R$ signifies an unreliable measurement. Consequently, the Kalman gain $K_k$ will be small, as the filter correctly discounts the noisy measurement. This leads to a higher steady-state error covariance $P_k$, as less information is extracted to correct the state estimates.\n- **Process Noise ($Q$):** This represents the uncertainty in the model dynamics. Higher $Q$ (as in Cases B and C compared to A) implies the state is expected to deviate more from the model's prediction. This increases the a priori covariance $P_k^-$ in each step, causing the filter to rely more on measurements (larger gain) and resulting in a higher steady-state posterior covariance $P$.\n- **Measurement Sensitivity ($H$):** The Jacobian $H$ depends on $z^\\star$ via $\\frac{dU}{dz}(z^\\star)$. In Case C, $z^\\star = 0.9$, which is near the end of the SoC range where the OCV curve is steepest. This yields a large $\\frac{dU}{dz}(z^\\star) \\approx 1.33\\ \\mathrm{V}$. A large value makes the measurement very sensitive to changes in SoC ($z_k$). This high sensitivity allows the filter to estimate $z_k$ with high precision, leading to a much smaller $P_{zz,N}$ component in the covariance matrix, provided the measurement is accurate (low $R$, as is the case in C).\n- **System Dynamics ($F$):** The matrix $F$ is influenced by the ratio $\\Delta t / \\tau_p$.\n  - In Case A, $\\Delta t / \\tau_p = 1/20 = 0.05$, so $F_{22} = e^{-0.05} \\approx 0.951$. The polarization voltage is highly persistent.\n  - In Case C, $\\tau_p$ is very small ($\\tau_p=2.0\\ \\mathrm{s}$) and $\\Delta t=0.5\\ \\mathrm{s}$. $\\Delta t / \\tau_p = 0.25$, so $F_{22} = e^{-0.25} \\approx 0.779$. This means the polarization voltage \"forgets\" its previous state more quickly. The model prediction for $v_{p,k}$ is less certain, which, all else being equal, would tend to increase the error variance $P_{vp,vp}$.\n\nThe provided code will numerically demonstrate these effects by propagating the covariance matrix and gain for each test case over $N=30$ steps. The final values will reflect the steady-state or near-steady-state behavior of the filter's uncertainty under the specified conditions.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the Kalman Filter covariance analysis for all test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A (nominal)\n        {\n            \"C_nom_Ah\": 2.5, \"delta_t\": 1.0, \"tau_p\": 20.0,\n            \"alpha_U\": 0.12, \"beta_U\": 0.12, \"z_star\": 0.6,\n            \"Q_z\": 1.0e-9, \"Q_vp\": 1.0e-6, \"R\": 1.0e-4,\n            \"P0_diag\": [1.0e-4, 1.0e-3], \"N\": 30\n        },\n        # Case B (high measurement noise with balancing)\n        {\n            \"C_nom_Ah\": 2.5, \"delta_t\": 1.0, \"tau_p\": 10.0,\n            \"alpha_U\": 0.12, \"beta_U\": 0.12, \"z_star\": 0.5,\n            \"Q_z\": 5.0e-9, \"Q_vp\": 5.0e-6, \"R\": 4.0e-2,\n            \"P0_diag\": [5.0e-4, 5.0e-3], \"N\": 30\n        },\n        # Case C (low measurement noise, fast polarization, higher current and series resistance)\n        {\n            \"C_nom_Ah\": 2.5, \"delta_t\": 0.5, \"tau_p\": 2.0,\n            \"alpha_U\": 0.12, \"beta_U\": 0.12, \"z_star\": 0.9,\n            \"Q_z\": 1.0e-8, \"Q_vp\": 1.0e-5, \"R\": 1.0e-6,\n            \"P0_diag\": [1.0e-3, 1.0e-3], \"N\": 30\n        }\n    ]\n\n    results = []\n    for params in test_cases:\n        result = run_covariance_recursion(params)\n        results.append(result)\n\n    # Format the results into the exact string representation required.\n    # The format is a list of lists, e.g., [[val1, val2], [val3, val4]]\n    # str(list) in Python produces the correct string for each inner list.\n    output_str = f\"[{','.join([str(res) for res in results])}]\"\n    print(output_str)\n\ndef run_covariance_recursion(params):\n    \"\"\"\n    Computes the KF gain and covariance evolution for a single test case.\n\n    Args:\n        params (dict): A dictionary containing all parameters for the test case.\n\n    Returns:\n        list: A list of four floats [K_z_N, K_vp_N, P_zz_N, P_vp_vp_N].\n    \"\"\"\n    # Extract parameters\n    delta_t = params[\"delta_t\"]\n    tau_p = params[\"tau_p\"]\n    alpha_U = params[\"alpha_U\"]\n    beta_U = params[\"beta_U\"]\n    z_star = params[\"z_star\"]\n    Q_z = params[\"Q_z\"]\n    Q_vp = params[\"Q_vp\"]\n    R = params[\"R\"]\n    P0_diag = params[\"P0_diag\"]\n    N = params[\"N\"]\n\n    # Problem statement mentions C_nom, I_k, b_k but they are not needed for the\n    # covariance recursion itself, only for the state update, which is not part of this task.\n    # R_p, R_s, U_ref are also not needed for the gain/covariance calculation.\n\n    # Construct the constant matrices for the Kalman Filter\n    # State transition Jacobian F\n    F = np.array([\n        [1.0, 0.0],\n        [0.0, np.exp(-delta_t / tau_p)]\n    ])\n\n    # Measurement Jacobian H\n    dU_dz_star = alpha_U / z_star + beta_U / (1.0 - z_star)\n    H = np.array([[dU_dz_star, 1.0]])  # H is a 1x2 row vector\n\n    # Process noise covariance Q\n    Q = np.diag([Q_z, Q_vp])\n\n    # Initialize the posterior covariance matrix P\n    P = np.diag(P0_diag)\n    \n    K = np.zeros((2, 1)) # Initialize K for the case N=0\n\n    # Riccati recursion a fixed number of times\n    for _ in range(N):\n        # 1. Prediction step for covariance\n        P_minus = F @ P @ F.T + Q\n\n        # 2. Innovation variance (S is a 1x1 matrix, effectively a scalar)\n        S = H @ P_minus @ H.T + R\n        \n        # 3. Kalman gain K\n        # S is 1x1, so its inverse is just 1/S. H.T is 2x1. P_minus is 2x2.\n        K = (P_minus @ H.T) / S\n\n        # 4. Update step for covariance\n        # Using the simplified form P = (I - K H) P^-\n        P = (np.eye(2) - K @ H) @ P_minus\n    \n    # Extract final values at step N\n    K_z_N = K[0, 0]\n    K_vp_N = K[1, 0]\n    P_zz_N = P[0, 0]\n    P_vp_vp_N = P[1, 1]\n\n    return [K_z_N, K_vp_N, P_zz_N, P_vp_vp_N]\n\nsolve()\n```"
        },
        {
            "introduction": "With a reliable way to estimate cell states, the final step is to design an effective balancing strategy. This problem introduces an optimal control approach to cell balancing, where the objective is to find the best possible current schedule to equalize the cells within a given timeframe and under actuator limitations, such as $|i_i(t)| \\le I_{\\max}$. You will formulate this challenge as a linear programming (LP) problem, a powerful and widely-used technique for finding the optimal solution to constrained, multi-variable problems.",
            "id": "3898781",
            "problem": "Consider a series-connected battery pack composed of multiple electrochemical cells where only intra-pack balancing currents are applied, with no net external charge injection. Let the state of charge (SoC) of cell $i$ be denoted by $z_{i}(t)$, and its charge capacity by $Q_{i}$ (in Coulombs). Under balancing-only actuation, the charge stored in a cell satisfies the fundamental relation of electric charge conservation and Coulomb counting: for each cell $i$, the stored charge $q_{i}(t)$ evolves as $\\mathrm{d} q_{i}/\\mathrm{d} t = i_{i}(t)$, and the SoC is $z_{i}(t) = q_{i}(t)/Q_{i}$. Therefore, the SoC dynamics are $Q_{i}\\,\\mathrm{d} z_{i}/\\mathrm{d} t = i_{i}(t)$, or equivalently $\\mathrm{d} z_{i}/\\mathrm{d} t = i_{i}(t)/Q_{i}$, where $i_{i}(t)$ is the balancing current applied to cell $i$ (positive when charge flows into the cell). Charge conservation in the series pack imposes the constraint $\\sum_{i=1}^{N} i_{i}(t) = 0$ for all times $t$ (no net external charge flow during balancing). Each actuator obeys the saturation limit $\\lvert i_{i}(t) \\rvert \\le I_{\\max}$.\n\nThe performance criterion is to reduce the dispersion of final SoC values at deadline $t_{f}$ around the charge-weighted mean SoC $\\bar{z}$, defined by conservation of total charge as $\\bar{z} = \\left(\\sum_{i=1}^{N} Q_{i} z_{i}(0)\\right)\\big/\\left(\\sum_{i=1}^{N} Q_{i}\\right)$. The control goal is to compute a feasible balancing current schedule $\\{ i_{i}(t) \\}_{i=1}^{N}$ to satisfy $\\max_{i} \\lvert z_{i}(t_{f}) - \\bar{z} \\rvert \\le \\epsilon$ with $\\lvert i_{i}(t) \\rvert \\le I_{\\max}$ and $\\sum_{i=1}^{N} i_{i}(t) = 0$ for all $t \\in [0, t_{f}]$.\n\nYour task is to solve the problem in discrete time over $M$ equal time steps of size $\\Delta t = t_{f}/M$ using a piecewise-constant control parameterization $i_{i}(t) = i_{i}[k]$ for $t \\in [k \\Delta t, (k+1) \\Delta t)$, where $k \\in \\{0, 1, \\dots, M-1\\}$. Given $N$, capacities $\\{Q_{i}\\}_{i=1}^{N}$ (in Coulombs), initial SoCs $\\{ z_{i}(0) \\}_{i=1}^{N}$ (dimensionless), current bound $I_{\\max}$ (in Amperes), deadline $t_{f}$ (in seconds), and $M$, you must compute the schedule $\\{ i_{i}[k] \\}$ that minimizes the worst-case final deviation\n$$\n\\delta = \\max_{i \\in \\{1,\\dots,N\\}} \\left\\lvert z_{i}(t_{f}) - \\bar{z} \\right\\rvert,\n$$\nsubject to the discretized dynamics\n$$\nz_{i}(t_{f}) = z_{i}(0) + \\frac{\\Delta t}{Q_{i}} \\sum_{k=0}^{M-1} i_{i}[k],\n$$\nthe per-step actuator saturation constraints\n$$\n\\lvert i_{i}[k] \\rvert \\le I_{\\max} \\quad \\text{for all } i, k,\n$$\nand the per-step pack neutrality constraints\n$$\n\\sum_{i=1}^{N} i_{i}[k] = 0 \\quad \\text{for all } k.\n$$\n\nYou must construct and solve a finite-dimensional optimization problem whose decision variables are $\\{ i_{i}[k] \\}$ and the scalar $\\delta \\ge 0$, such that the minimized optimal value $\\delta^{\\star}$ is the smallest achievable maximum final SoC deviation under the given constraints. Then, for each test case, report the optimized $\\delta^{\\star}$ as a real number (dimensionless SoC), rounded to six decimal places. You do not need to output the schedule $\\{ i_{i}[k] \\}$; only output $\\delta^{\\star}$.\n\nUse the following test suite of parameter values, each specified by a tuple $\\left(N, \\{Q_{i}\\}_{i=1}^{N}, \\{ z_{i}(0) \\}_{i=1}^{N}, I_{\\max}, t_{f}, M\\right)$:\n\n- Test case $1$ (general case):\n  - $N = 4$,\n  - $\\{Q_{i}\\} = [10800, 10800, 10800, 10800]$,\n  - $\\{ z_{i}(0) \\} = [0.6, 0.5, 0.7, 0.4]$,\n  - $I_{\\max} = 2.0$,\n  - $t_{f} = 1800$,\n  - $M = 12$.\n\n- Test case $2$ (time and actuator limited):\n  - $N = 3$,\n  - $\\{Q_{i}\\} = [9000, 9000, 9000]$,\n  - $\\{ z_{i}(0) \\} = [0.9, 0.6, 0.3]$,\n  - $I_{\\max} = 0.5$,\n  - $t_{f} = 1800$,\n  - $M = 9$.\n\n- Test case $3$ (heterogeneous capacities):\n  - $N = 3$,\n  - $\\{Q_{i}\\} = [10800, 7200, 14400]$,\n  - $\\{ z_{i}(0) \\} = [0.8, 0.5, 0.6]$,\n  - $I_{\\max} = 1.0$,\n  - $t_{f} = 1200$,\n  - $M = 8$.\n\n- Test case $4$ (short deadline, nearly static):\n  - $N = 5$,\n  - $\\{Q_{i}\\} = [10000, 10000, 10000, 10000, 10000]$,\n  - $\\{ z_{i}(0) \\} = [0.52, 0.58, 0.54, 0.60, 0.51]$,\n  - $I_{\\max} = 0.1$,\n  - $t_{f} = 60$,\n  - $M = 6$.\n\nAngle units are not involved. Physical units are specified above. Output the final maximum deviation values as dimensionless SoC.\n\nFinal output format requirement: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, \"[result1,result2,result3,result4]\"). Each result must be the optimized $\\delta^{\\star}$ for the corresponding test case, rounded to six decimal places.",
            "solution": "The problem presented is a discrete-time optimal control problem for a battery cell balancing system. The objective is to determine a control sequence—the balancing currents $\\{i_{i}[k]\\}$—that minimizes the maximum state deviation at a final time $t_{f}$. The state of the system is the vector of cell States of Charge (SoCs), $\\{z_i\\}$. This problem can be rigorously formulated and solved as a Linear Program (LP).\n\nFirst, we define the system parameters and variables. The system consists of $N$ series-connected cells. For each cell $i \\in \\{1, \\dots, N\\}$, we are given its charge capacity $Q_{i}$ and initial SoC $z_{i}(0)$. The control inputs are the balancing currents $i_i(t)$, which are constrained by a maximum magnitude $I_{\\max}$. The system operates for a duration $t_f$. The control policy is piecewise-constant over $M$ intervals of duration $\\Delta t = t_f/M$. The currents for cell $i$ during the time interval $[k\\Delta t, (k+1)\\Delta t)$ is denoted by $i_i[k]$.\n\nThe dynamics of the SoC for cell $i$, when discretized using the forward Euler method, is given by:\n$$\nz_{i}[k+1] = z_{i}[k] + \\frac{\\Delta t}{Q_i} i_i[k]\n$$\nUnrolling this recurrence from $k=0$ to $k=M-1$, the final SoC at time $t_f = M \\Delta t$ is:\n$$\nz_{i}(t_{f}) = z_{i}(0) + \\sum_{k=0}^{M-1} \\frac{\\Delta t}{Q_{i}} i_{i}[k] = z_{i}(0) + \\frac{\\Delta t}{Q_{i}} \\sum_{k=0}^{M-1} i_{i}[k]\n$$\nThis equation links the final states to the initial states and the control actions.\n\nThe control objective is to minimize the worst-case deviation of the final SoCs from their charge-weighted average, $\\bar{z}$. The average SoC $\\bar{z}$ is a constant determined by the initial conditions and capacities, ensuring conservation of total charge in the pack:\n$$\n\\bar{z} = \\frac{\\sum_{i=1}^{N} Q_{i} z_{i}(0)}{\\sum_{i=1}^{N} Q_{i}}\n$$\nThe quantity to be minimized is the scalar $\\delta$, defined as:\n$$\n\\delta = \\max_{i \\in \\{1, \\dots, N\\}} | z_i(t_f) - \\bar{z} |\n$$\nThis is a minimax optimization problem. It can be transformed into a standard minimization problem by introducing $\\delta$ as a decision variable and adding constraints. Minimizing $\\delta$ subject to its definition is equivalent to:\n$$\n\\text{minimize} \\quad \\delta\n$$\nsubject to:\n$$\n|z_i(t_f) - \\bar{z}| \\le \\delta \\quad \\text{for all } i \\in \\{1, \\dots, N\\}\n$$\nThese $N$ inequality constraints can be expanded into $2N$ linear inequalities:\n$$\nz_i(t_f) - \\bar{z} \\le \\delta \\quad \\text{and} \\quad -(z_i(t_f) - \\bar{z}) \\le \\delta\n$$\nSubstituting the expression for $z_i(t_f)$, we obtain:\n$$\n\\left( z_{i}(0) + \\frac{\\Delta t}{Q_{i}} \\sum_{k=0}^{M-1} i_{i}[k] \\right) - \\bar{z} \\le \\delta \\quad \\implies \\quad \\frac{\\Delta t}{Q_{i}} \\sum_{k=0}^{M-1} i_{i}[k] - \\delta \\le \\bar{z} - z_i(0)\n$$\n$$\n-\\left( z_{i}(0) + \\frac{\\Delta t}{Q_{i}} \\sum_{k=0}^{M-1} i_{i}[k] \\right) + \\bar{z} \\le \\delta \\quad \\implies \\quad -\\frac{\\Delta t}{Q_{i}} \\sum_{k=0}^{M-1} i_{i}[k] - \\delta \\le z_i(0) - \\bar{z}\n$$\n\nThe problem is further subject to physical and operational constraints on the control inputs $i_i[k]$:\n1.  Actuator Saturation: The magnitude of each current is limited.\n    $$\n    |i_i[k]| \\le I_{\\max} \\quad \\text{for all } i \\in \\{1, \\dots, N\\}, k \\in \\{0, \\dots, M-1\\}\n    $$\n    This is equivalent to the linear bounds $-I_{\\max} \\le i_i[k] \\le I_{\\max}$.\n\n2.  Pack Neutrality: The sum of currents at each time step must be zero, reflecting the absence of an external connection.\n    $$\n    \\sum_{i=1}^{N} i_i[k] = 0 \\quad \\text{for all } k \\in \\{0, \\dots, M-1\\}\n    $$\n\nThis full problem is a Linear Program (LP). The decision variables are the $N \\times M$ currents $\\{i_i[k]\\}$ and the scalar variable $\\delta$. All constraints are linear inequalities or equalities, and the objective function is linear.\n\nTo solve this computationally, we formulate it in the standard LP form:\n$$\n\\begin{aligned}\n\\text{minimize} \\quad  \\mathbf{c}^T \\mathbf{x} \\\\\n\\text{subject to} \\quad  \\mathbf{A}_{\\text{ub}} \\mathbf{x} \\le \\mathbf{b}_{\\text{ub}} \\\\\n \\mathbf{A}_{\\text{eq}} \\mathbf{x} = \\mathbf{b}_{\\text{eq}} \\\\\n \\mathbf{l} \\le \\mathbf{x} \\le \\mathbf{u}\n\\end{aligned}\n$$\nThe decision vector $\\mathbf{x}$ is constructed by stacking all $N \\times M$ currents and the variable $\\delta$. Using $0$-based indexing for implementation ($i \\in \\{0,\\dots,N-1\\}, k \\in \\{0,\\dots,M-1\\}$), a convenient ordering is:\n$$\n\\mathbf{x} = [i_0[0], \\dots, i_{N-1}[0], i_0[1], \\dots, i_{N-1}[1], \\dots, i_0[M-1], \\dots, i_{N-1}[M-1], \\delta]^T\n$$\nThe total number of decision variables is $NM+1$. The index of $i_i[k]$ is $k \\cdot N + i$, and the index of $\\delta$ is $NM$.\n\nThe components of the LP are as follows:\n- **Cost Vector $\\mathbf{c}$**: We minimize $\\delta$, so $\\mathbf{c}$ is a vector of zeros with a $1$ at the last position corresponding to $\\delta$.\n$$\n\\mathbf{c} = [0, \\dots, 0, 1]^T\n$$\n- **Bounds**: The currents are bounded by $[-I_{\\max}, I_{\\max}]$, and $\\delta$ is non-negative ($\\delta \\ge 0$). These are specified as box constraints on $\\mathbf{x}$.\n\n- **Equality Constraints $\\mathbf{A}_{\\text{eq}}, \\mathbf{b}_{\\text{eq}}$**: These represent the $M$ pack neutrality constraints. For each step $k \\in \\{0, \\dots, M-1\\}$, $\\sum_{i=0}^{N-1} i_i[k] = 0$.\nThe matrix $\\mathbf{A}_{\\text{eq}}$ has dimensions $M \\times (NM+1)$. Each row $k$ corresponds to the constraint at time step $k$. It has entries of $1$ for the variables $i_0[k], \\dots, i_{N-1}[k]$ and $0$ otherwise. The vector $\\mathbf{b}_{\\text{eq}}$ is a zero vector of length $M$.\n\n- **Inequality Constraints $\\mathbf{A}_{\\text{ub}}, \\mathbf{b}_{\\text{ub}}$**: These represent the $2N$ constraints from the minimax formulation.\nThe matrix $\\mathbf{A}_{\\text{ub}}$ has dimensions $2N \\times (NM+1)$. For each cell $i$, there are two rows.\nRow $2i$ corresponds to $\\frac{\\Delta t}{Q_{i}} \\sum_{k=0}^{M-1} i_{i}[k] - \\delta \\le \\bar{z} - z_i(0)$. Its entries are $\\frac{\\Delta t}{Q_i}$ for variables $i_i[k]$ (for all $k$), $-1$ for $\\delta$, and $0$ otherwise. The corresponding value in $\\mathbf{b}_{\\text{ub}}$ is $\\bar{z} - z_i(0)$.\nRow $2i+1$ corresponds to $-\\frac{\\Delta t}{Q_{i}} \\sum_{k=0}^{M-1} i_{i}[k] - \\delta \\le z_i(0) - \\bar{z}$. Its entries are $-\\frac{\\Delta t}{Q_i}$ for variables $i_i[k]$ (for all $k$), $-1$ for $\\delta$, and $0$ otherwise. The corresponding value in $\\mathbf{b}_{\\text{ub}}$ is $z_i(0) - \\bar{z}$.\n\nWith this formulation, a standard LP solver, such as `scipy.optimize.linprog`, can be employed to find the optimal value $\\delta^\\star$ for each test case.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef solve():\n    \"\"\"\n    Solves a series of battery cell balancing optimization problems.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (N, Q_i, z_i(0), I_max, t_f, M)\n    test_cases = [\n        (4, np.array([10800, 10800, 10800, 10800]), np.array([0.6, 0.5, 0.7, 0.4]), 2.0, 1800, 12),\n        (3, np.array([9000, 9000, 9000]), np.array([0.9, 0.6, 0.3]), 0.5, 1800, 9),\n        (3, np.array([10800, 7200, 14400]), np.array([0.8, 0.5, 0.6]), 1.0, 1200, 8),\n        (5, np.array([10000, 10000, 10000, 10000, 10000]), np.array([0.52, 0.58, 0.54, 0.60, 0.51]), 0.1, 60, 6),\n    ]\n\n    results = []\n    for case in test_cases:\n        delta_star = solve_balancing_lp(case)\n        results.append(f\"{delta_star:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\ndef solve_balancing_lp(case):\n    \"\"\"\n    Formulates and solves the cell balancing problem as a Linear Program (LP).\n\n    Args:\n        case (tuple): A tuple containing the problem parameters\n                      (N, Q, z0, I_max, tf, M).\n\n    Returns:\n        float: The optimized minimum worst-case final deviation delta_star.\n    \"\"\"\n    N, Q, z0, I_max, tf, M = case\n\n    # -- 1. Calculate problem constants --\n    dt = tf / M\n    z_bar = np.sum(Q * z0) / np.sum(Q)\n\n    # -- 2. Define the LP structure --\n    # Decision variables x = [i_0[0], ..., i_{N-1}[0], ..., i_{N-1}[M-1], delta]^T\n    # Total number of variables is N*M currents + 1 delta\n    num_vars = N * M + 1\n    num_currents = N * M\n\n    # -- 3. Objective function: minimize delta --\n    # c vector is [0, 0, ..., 0, 1]\n    c = np.zeros(num_vars)\n    c[-1] = 1.0\n\n    # -- 4. Equality constraints: sum(i_i[k]) = 0 for each k --\n    # A_eq has M rows (one for each time step) and num_vars columns.\n    A_eq = np.zeros((M, num_vars))\n    for k in range(M):\n        start_col = k * N\n        end_col = start_col + N\n        A_eq[k, start_col:end_col] = 1.0\n    b_eq = np.zeros(M)\n    \n    # -- 5. Inequality constraints: |z_i(tf) - z_bar| = delta for each i --\n    # This gives 2*N constraints.\n    # A_ub has 2*N rows and num_vars columns.\n    A_ub = np.zeros((2 * N, num_vars))\n    b_ub = np.zeros(2 * N)\n    \n    for i in range(N):\n        # Constraint 1: (dt/Q_i) * sum(i_i[k]) - delta = z_bar - z0_i\n        # Constraint 2: -(dt/Q_i) * sum(i_i[k]) - delta = z0_i - z_bar\n\n        # Coefficients for sum(i_i[k])\n        current_coeffs = np.zeros(num_currents)\n        for k in range(M):\n            # Index of i_i[k] in the decision vector\n            current_idx = k * N + i\n            current_coeffs[current_idx] = dt / Q[i]\n            \n        # Row for constraint 1\n        A_ub[2 * i, :num_currents] = current_coeffs\n        A_ub[2 * i, -1] = -1.0  # Coefficient for delta\n        b_ub[2 * i] = z_bar - z0[i]\n        \n        # Row for constraint 2\n        A_ub[2 * i + 1, :num_currents] = -current_coeffs\n        A_ub[2 * i + 1, -1] = -1.0  # Coefficient for delta\n        b_ub[2 * i + 1] = z0[i] - z_bar\n\n    # -- 6. Bounds on decision variables --\n    # -I_max = i_i[k] = I_max\n    # delta = 0\n    current_bounds = (-I_max, I_max)\n    delta_bounds = (0, None)\n    bounds = [current_bounds] * num_currents + [delta_bounds]\n\n    # -- 7. Solve the LP --\n    # The 'highs' method is generally robust and efficient for this type of problem.\n    result = linprog(c, A_ub=A_ub, b_ub=b_ub, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')\n\n    if result.success:\n        # The optimal value of the objective function is delta_star\n        return result.fun\n    else:\n        # This should not happen for a well-posed problem.\n        raise RuntimeError(f\"LP solver failed: {result.message}\")\n\nsolve()\n```"
        }
    ]
}