{
    "hands_on_practices": [
        {
            "introduction": "模型预测控制（MPC）的计算效率很大程度上依赖于线性系统模型。然而，电池的行为，尤其是其开路电压（OCV），具有显著的非线性特征。本练习将引导您实践泰勒级数线性化这一基础技术，从一个非线性的物理关系中构建一个适用于MPC的仿射模型。通过量化真实非线性模型与其线性近似之间的误差，您将深入理解模型精度与计算易行性之间的权衡，这是MPC设计中的一个核心挑战。",
            "id": "3928848",
            "problem": "您需要构建并评估一个适用于模型预测控制 (MPC) 的仿射终端电压模型，该模型从一个基于物理的电池模型出发，并根据电流量化线性化误差。请仅使用本说明中的信息和要求来推导、实现和测试您的解决方案。\n\n物理基础和定义如下。令 $x \\in [0,1]$ 表示荷电状态 (SOC)，定义为可用容量的剩余分数。在恒定施加电流下的SOC动态由电荷守恒给出，其中 $u$ 是施加的电流（放电为正，充电为负），$\\eta$ 是电荷转移效率，$Q_{\\mathrm{nom}}$ 是以安秒为单位的标称容量，$\\Delta t$ 是以秒为单位的采样时间。恒流段的离散时间SOC更新为\n$$\nx_{k+1} \\,=\\, x_k \\,-\\, \\frac{\\eta\\,\\Delta t}{Q_{\\mathrm{nom}}}\\,u_k,\n$$\n每次更新后进行饱和处理以将 $x_k$ 保持在 $[0,1]$ 范围内。终端电压 $V$ 定义为开路电位减去瞬时欧姆压降，即\n$$\nV \\,=\\, E(x) \\,-\\, R\\,u,\n$$\n其中 $R$ 是以欧姆为单位的内部欧姆电阻，$E(x)$ 是作为SOC函数的开路电位。\n\n为了仿真和测试，请使用一个广为接受的S型开路电位函数，该函数能够捕捉典型锂离子电池的单调和饱和行为：\n$$\nE(x) \\,=\\, E_{\\min} \\,+\\, \\frac{\\Delta E}{1 + \\exp\\!\\big(-k\\,(x - x_{\\mathrm{mid}})\\big)},\n$$\n其中 $E_{\\min}$ 是以伏特为单位的下渐近线，$E_{\\max}$ 是以伏特为单位的上渐近线，$\\Delta E \\,=\\, E_{\\max} - E_{\\min}$，$k$ 是一个无量纲的斜率参数，$x_{\\mathrm{mid}}$ 是曲线变化最快的中点SOC。\n\n任务要求：\n- 推导 $E(x)$ 在标称SOC $x^\\star$ 附近的一阶泰勒线性化，并用它构建一个适用于MPC设计的仿射近似 $V_{\\mathrm{lin}}$。请不要在问题陈述中写下最终的线性化表达式；您必须在您的解决方案中从第一性原理出发进行推导。\n- 实现一个程序，对于每个测试用例，在 $N$ 步的固定时域内以恒定电流 $u$ 进行前向仿真，计算每一步的精确非线性终端电压 $V_k$ 和仿射线性化电压 $V_{\\mathrm{lin},k}$，并返回以伏特为单位的均方根误差 (RMSE)，定义为\n$$\n\\mathrm{RMSE} \\,=\\, \\sqrt{\\frac{1}{N}\\sum_{k=1}^{N}\\left(V_k \\,-\\, V_{\\mathrm{lin},k}\\right)^2}.\n$$\n- 使用一个饱和SOC积分器，在每一步强制 $x_k \\in [0,1]$。\n- 以伏特为单位表示每个RMSE，并报告至六位小数。\n\n在此背景下，模型预测控制 (MPC) 的准确性通过在不同电流量级下预测时域内的线性化误差大小来评估。较大的电流会更快地改变SOC，并可能由于 $E(x)$ 的非线性而增加线性化误差。\n\n参数值和单位：\n- 使用安秒为单位的 $Q_{\\mathrm{nom}}$，其中 $Q_{\\mathrm{nom}}$ 通过将安时乘以 $3600$ 得出。\n- 使用安培为单位的 $u$，欧姆为单位的 $R$，伏特为单位的 $E$ 和 $V$，秒为单位的 $\\Delta t$。\n- S型OCV参数为：$E_{\\min}$ 以伏特为单位，$E_{\\max}$ 以伏特为单位，$k$ 无量纲，$x_{\\mathrm{mid}}$ 无量纲。\n\n您的程序必须评估以下参数集测试套件。每个测试用例以元组形式给出，包含 $(Q_{\\mathrm{Ah}}, \\Delta t, N, u, R, x^\\star, x_0, E_{\\min}, E_{\\max}, k, x_{\\mathrm{mid}}, \\eta)$，其中 $Q_{\\mathrm{Ah}}$ 是以安时为单位的标称容量，而 $Q_{\\mathrm{nom}} = 3600 \\cdot Q_{\\mathrm{Ah}}$ 在内部计算：\n- 测试用例 1：$(5, 1, 600, 0, 0.05, 0.5, 0.5, 3.0, 4.2, 0.8, 0.5, 1.0)$。\n- 测试用例 2：$(5, 1, 600, 2, 0.05, 0.5, 0.5, 3.0, 4.2, 0.8, 0.5, 1.0)$。\n- 测试用例 3：$(5, 1, 600, -4, 0.05, 0.9, 0.9, 3.0, 4.2, 0.8, 0.5, 1.0)$。\n- 测试用例 4：$(5, 1, 600, 20, 0.05, 0.2, 0.2, 3.0, 4.2, 0.8, 0.5, 1.0)$。\n\n要求的最终输出格式为单行，包含一个用方括号括起来的逗号分隔列表，其中每个条目是相应测试用例的RMSE，以伏特为单位并格式化为六位小数，例如，$[0.000123,0.001234,0.012345,0.123456]$。您的程序必须精确地生成这一行，不含任何额外文本。",
            "solution": "我们从控制可充电电池在模型预测控制 (MPC) 相关领域行为的基本原理出发。终端电压 $V$ 被建模为开路电位与瞬时欧姆效应之和，其基于物理的关系为 $V \\,=\\, E(x) \\,-\\, R\\,u$。荷电状态 (SOC) $x$ 根据电荷守恒演变：当电流 $u$ 定义为放电为正时，变化率为 $\\dot{x} \\,=\\, -\\frac{\\eta}{Q_{\\mathrm{nom}}}u$，其中 $\\eta$ 是电荷转移效率，$Q_{\\mathrm{nom}}$ 是以安秒为单位的标称容量。在具有均匀采样间隔 $\\Delta t$ 的离散时间内，SOC 更新为 $x_{k+1} \\,=\\, x_k \\,-\\, \\frac{\\eta \\Delta t}{Q_{\\mathrm{nom}}}u_k$，并通过饱和处理强制执行物理状态约束 $x_k \\in [0,1]$。这与将 $x \\in [0,1]$ 定义为可用电荷的分数是一致的，并且是电化学建模中用于控制的一个经过充分检验的近似方法。\n\n对于先进的控制设计和预测，MPC 通常需要一个关于目标变量的仿射模型，这里指的是作为状态和输入函数的终端电压。非线性部分是开路电位函数 $E(x)$。我们给定一个S型形式，它捕捉了锂离子开路电压的定性行为：\n$$\nE(x) \\,=\\, E_{\\min} \\,+\\, \\frac{\\Delta E}{1 + \\exp\\!\\big(-k\\,(x - x_{\\mathrm{mid}})\\big)}, \\quad \\Delta E \\,=\\, E_{\\max} - E_{\\min}.\n$$\n该函数在 $x$ 上单调递增，当 $x \\to 0$ 时在 $E_{\\min}$ 附近饱和，当 $x \\to 1$ 时在 $E_{\\max}$ 附近饱和。线性化需要其导数。定义逻辑斯蒂分数 $s(x) \\,=\\, \\frac{1}{1 + \\exp\\!\\big(-k\\,(x - x_{\\mathrm{mid}})\\big)}$。那么 $E(x) \\,=\\, E_{\\min} + \\Delta E \\, s(x)$，根据链式法则可得 $E'(x) \\,=\\, \\Delta E \\, s'(x)$，其中\n$$\ns'(x) \\,=\\, \\frac{\\mathrm{d}}{\\mathrm{d}x}\\left(\\frac{1}{1 + e^{-k(x - x_{\\mathrm{mid}})}}\\right) \\,=\\, \\frac{k\\,e^{-k(x - x_{\\mathrm{mid}})}}{\\left(1 + e^{-k(x - x_{\\mathrm{mid}})}\\right)^2} \\,=\\, k\\,s(x)\\,\\big(1 - s(x)\\big).\n$$\n因此，\n$$\nE'(x) \\,=\\, \\Delta E \\, k \\, s(x)\\,\\big(1 - s(x)\\big).\n$$\n\n为了构建 MPC 所需的仿射近似，我们在选定的标称 SOC $x^\\star$ 周围对 $E(x)$ 进行一阶泰勒线性化。可微函数 $E(x)$ 在 $x^\\star$ 处的泰勒展开给出 $E(x) \\approx E(x^\\star) + E'(x^\\star)\\,(x - x^\\star)$，对于接近 $x^\\star$ 的 $x$ 成立。将此代入电压表达式 $V \\,=\\, E(x) \\,-\\, R\\,u$，我们得到一个关于 $(x,u)$ 的仿射函数，该函数包含一个常数项和一个在状态偏差 $(x - x^\\star)$ 和输入 $u$ 上线性的项。这个仿射模型是 MPC 用来预测在偏离标称点的小范围内电压变化的模型，同时考虑了通过电阻的输入项 $-R\\,u$。\n\n为了量化相对于电流量值的线性化误差，我们在一个 $N$ 步的时域内以恒定电流 $u$ 传播SOC，并在每一步计算精确的非线性电压 $V_k$ 和在 $x^\\star$ 处线性化构建的仿射线性化电压 $V_{\\mathrm{lin},k}$。第 $k$ 步的误差是 $\\delta V_k \\,=\\, V_k - V_{\\mathrm{lin},k}$。因为欧姆项 $-R\\,u$ 同时出现在 $V_k$ 和 $V_{\\mathrm{lin},k}$ 中，所以误差完全由 $E(x)$ 中的非线性决定，\n$$\n\\delta V_k \\,=\\, E(x_k) \\,-\\, \\big(E(x^\\star) + E'(x^\\star)\\,(x_k - x^\\star)\\big).\n$$\n时域内的均方根误差 (RMSE) 是\n$$\n\\mathrm{RMSE} \\,=\\, \\sqrt{\\frac{1}{N}\\sum_{k=1}^{N}\\left(\\delta V_k\\right)^2}.\n$$\n该指标随着电流量值的增加而增加，因为更大的 $|u|$ 会更快地改变 $x_k$，使状态离 $x^\\star$ 更远，并增加一阶近似所忽略的高阶项的贡献。\n\n程序的算法设计：\n- 通过 $Q_{\\mathrm{nom}} \\,=\\, 3600 \\cdot Q_{\\mathrm{Ah}}$ 将 $Q_{\\mathrm{Ah}}$ 转换为安秒单位的 $Q_{\\mathrm{nom}}$。\n- 初始化 $x_0$ 并为线性化点设置 $x^\\star$。使用 $E'(x^\\star) \\,=\\, \\Delta E \\, k \\, s(x^\\star)\\,\\big(1 - s(x^\\star)\\big)$ 和 $s(x^\\star) \\,=\\, \\frac{1}{1 + \\exp\\!\\big(-k\\,(x^\\star - x_{\\mathrm{mid}})\\big)}$ 从S型 $E(x)$ 表达式计算导数 $E'(x^\\star)$。\n- 对于从 $1$ 到 $N$ 的 $k$，使用 $x_{k} \\,=\\, \\operatorname{clip}\\!\\left(x_{k-1} - \\frac{\\eta\\,\\Delta t}{Q_{\\mathrm{nom}}}\\,u,\\;0,\\;1\\right)$ 传播SOC，其中 $\\operatorname{clip}$ 强制饱和到区间 $[0,1]$。\n- 在每一步，计算 $V_k \\,=\\, E(x_k) \\,-\\, R\\,u$ 和 $V_{\\mathrm{lin},k} \\,=\\, \\big(E(x^\\star) + E'(x^\\star)\\,(x_k - x^\\star)\\big) \\,-\\, R\\,u$，累加 $\\left(V_k - V_{\\mathrm{lin},k}\\right)^2$，最后计算 RMSE。\n- 对每个测试用例重复此过程，并按指定格式将 RMSE 值列表（以伏特为单位，每个保留六位小数）报告为单行。\n\n对 MPC 准确性的解释：当 $u \\,=\\, 0$ 时，SOC 保持恒定，在 $x^\\star$ 处的线性化在局部是精确的，因此 RMSE 为零。随着 $|u|$ 的增加，SOC 偏离 $x^\\star$， $E(x)$ 的S型曲率贡献了高阶项，从而增加了 RMSE。在 SOC 边界附近，饱和和S型曲线的低曲率区域可能会改变误差的增长；然而，只要预测时域内的 RMSE 相对于控制和测量容差保持较小，一阶仿射近似仍然是 MPC 的一个有用的局部模型。该程序在科学上合理的参数和单位下对这种行为进行了数值量化。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef ocv_sigmoid(x, Emin, Emax, k, xmid):\n    \"\"\"\n    Open-circuit voltage E(x) using a logistic sigmoid between Emin and Emax.\n\n    E(x) = Emin + (Emax - Emin) / (1 + exp(-k*(x - xmid)))\n\n    Parameters:\n        x: SOC in [0,1]\n        Emin: lower asymptote (V)\n        Emax: upper asymptote (V)\n        k: slope parameter (dimensionless)\n        xmid: mid-SOC (dimensionless)\n    Returns:\n        E: voltage (V)\n    \"\"\"\n    dE = Emax - Emin\n    return Emin + dE / (1.0 + np.exp(-k * (x - xmid)))\n\ndef docv_dx_sigmoid(x, Emin, Emax, k, xmid):\n    \"\"\"\n    Derivative dE/dx for the OCV sigmoid model.\n\n    Using s(x) = 1 / (1 + exp(-k*(x - xmid))), then\n    dE/dx = (Emax - Emin) * k * s * (1 - s)\n    \"\"\"\n    dE = Emax - Emin\n    s = 1.0 / (1.0 + np.exp(-k * (x - xmid)))\n    return dE * k * s * (1.0 - s)\n\ndef rmse_linearization_error(params):\n    \"\"\"\n    Compute RMSE between nonlinear V(x) and affine-linearized V around x_star.\n\n    params: tuple (Q_Ah, dt, N, u, R, x_star, x0, Emin, Emax, k, xmid, eta)\n    Returns:\n        rmse (float, volts)\n    \"\"\"\n    Q_Ah, dt, N, u, R, x_star, x0, Emin, Emax, k, xmid, eta = params\n    Q_nom = Q_Ah * 3600.0  # Ampere-second\n    # Precompute linearization constants at x_star\n    E_star = ocv_sigmoid(x_star, Emin, Emax, k, xmid)\n    dE_dx_star = docv_dx_sigmoid(x_star, Emin, Emax, k, xmid)\n\n    # Initialize SOC\n    x = float(x0)\n\n    # Accumulate squared error\n    se = 0.0\n\n    # Small epsilon to avoid numerical issues at exact boundaries\n    eps = 0.0  # boundaries are acceptable for sigmoid as defined\n\n    for _ in range(int(N)):\n        # SOC update with saturation to [0,1]\n        x = x - (eta * dt / Q_nom) * u\n        if x  0.0:\n            x = 0.0\n        elif x > 1.0:\n            x = 1.0\n\n        # Nonlinear terminal voltage\n        V_true = ocv_sigmoid(x, Emin, Emax, k, xmid) - R * u\n\n        # Affine-linearized terminal voltage around x_star\n        E_lin = E_star + dE_dx_star * (x - x_star)\n        V_lin = E_lin - R * u\n\n        err = V_true - V_lin\n        se += err * err\n\n    rmse = np.sqrt(se / float(N))\n    return float(rmse)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each tuple: (Q_Ah, dt, N, u, R, x_star, x0, Emin, Emax, k, xmid, eta)\n    test_cases = [\n        (5.0, 1.0, 600, 0.0, 0.05, 0.5, 0.5, 3.0, 4.2, 0.8, 0.5, 1.0),\n        (5.0, 1.0, 600, 2.0, 0.05, 0.5, 0.5, 3.0, 4.2, 0.8, 0.5, 1.0),\n        (5.0, 1.0, 600, -4.0, 0.05, 0.9, 0.9, 3.0, 4.2, 0.8, 0.5, 1.0),\n        (5.0, 1.0, 600, 20.0, 0.05, 0.2, 0.2, 3.0, 4.2, 0.8, 0.5, 1.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = rmse_linearization_error(case)\n        # Format to six decimal places as required\n        results.append(f\"{result:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在电池管理中，MPC的一个关键应用是热控制，即在最大化性能的同时防止电池过热。本练习将演示如何构建一个能够平衡相互竞争目标的MPC目标函数：一方面是跟踪期望的电流指令，另一方面是强制执行温度安全限制。通过调整目标函数中各项的权重，您将学会如何在性能与安全之间进行关键的权衡，这是电池系统控制工程师的核心任务。",
            "id": "3928791",
            "problem": "给定一个物理上真实的、双节点的集总电-热电池模型，您必须实现一个模型预测控制（MPC）策略，以在阶跃电流输入下减轻温度超调，同时保持性能。该任务要求从第一性原理推导离散时间热力学动态，并构建一个能够在电流跟踪和温度调节之间取得平衡的有限时域MPC。您必须计算开环阶跃电流下最坏情况的温度超调，然后设计MPC权重以在满足性能约束的条件下减小该超调。所有答案都必须以数值形式表示，并通过一个完整的、可运行的程序生成。\n\n其基本原理包括以下经过充分检验的物理定律和定义：\n- 焦耳热：由电阻损耗在内部产生的功率为 $P = I^2 R$，其中 $I$ 是电流，$R$ 是内阻。\n- 集总热能平衡：对于一个热容为 $C$ 的节点，其温度动态遵循 $C \\, \\frac{dT}{dt} = \\text{净热流入}$。\n- 具有核心和表面的双节点热网络：\n  - 核心节点温度 $T_c$，热容为 $C_c$，与表面之间的热导为 $h_{cs}$。\n  - 表面节点温度 $T_s$，热容为 $C_s$，从核心传导来的热导为 $h_{cs}$，与环境温度 $T_{\\text{amb}}$ 之间的对流热导为 $h_{sa}$。\n- 连续时间模型为\n  $$C_c \\frac{dT_c}{dt} = - h_{cs} (T_c - T_s) + \\eta I^2,$$\n  $$C_s \\frac{dT_s}{dt} = h_{cs} (T_c - T_s) - h_{sa} (T_s - T_{\\text{amb}}),$$\n  其中 $\\eta$ 是施加到核心的电阻热部分（对于简单的焦耳模型，$\\eta = R$）。\n\n使用前向欧拉法，以采样时间 $\\Delta t$ 将上述动态离散化，得到仿射离散时间动态\n$$\n\\begin{bmatrix}\nT_{c,k+1} \\\\\nT_{s,k+1}\n\\end{bmatrix}\n=\n\\left(I_2 + \\Delta t \\, A\\right)\n\\begin{bmatrix}\nT_{c,k} \\\\\nT_{s,k}\n\\end{bmatrix}\n+ \\Delta t \\, B \\, w_k + \\Delta t \\, g,\n$$\n其中 $w_k = I_k^2$，$A = \\begin{bmatrix} -\\frac{h_{cs}}{C_c}  \\frac{h_{cs}}{C_c} \\\\ \\frac{h_{cs}}{C_s}  -\\frac{h_{cs} + h_{sa}}{C_s} \\end{bmatrix}$，$B = \\begin{bmatrix} \\frac{\\eta}{C_c} \\\\ 0 \\end{bmatrix}$，以及 $g = \\begin{bmatrix} 0 \\\\ \\frac{h_{sa}}{C_s} T_{\\text{amb}} \\end{bmatrix}$。\n\n将阶跃电流指令定义为 $I_d$（假设 $I_d \\ge 0$），电流平方输入边界定义为 $w_{\\max} = I_d^2$。开环阶跃输入在 $N$ 步的有限时域内对所有 $k$ 应用 $w_k = w_{\\max}$。\n\n将相对于温度限制 $T_{\\max}$ 的最坏情况温度超调定义为\n$$\n\\Delta T_{\\text{overshoot}} = \\max\\left(0, \\max_{0 \\le k \\le N} \\left( T_{s,k} - T_{\\max} \\right) \\right),\n$$\n以摄氏度（°C）表示。\n\n构建一个有限时域MPC，其决策变量为 $w_0, w_1, \\dots, w_{N-1}$，受边界条件 $0 \\le w_k \\le w_{\\max}$ 约束，以最小化目标函数\n$$\nJ = \\sum_{k=0}^{N-1} \\left[ Q \\left(w_k - w_d\\right)^2 + R \\left(w_k - w_{k-1}\\right)^2 + S \\left( \\max\\left(0, T_{s,k} - T_{\\max}\\right) \\right)^2 \\right],\n$$\n其中 $w_d = I_d^2$，$Q \\ge 0$ 是跟踪权重，$R \\ge 0$ 是平滑权重，$S \\ge 0$ 是温度惩罚权重，并且对于第一步，$w_{-1}$ 定义为 $w_{-1} = w_d$。MPC使用给定的离散时间热模型，以开环预测方式进行评估。\n\n性能通过电流跟踪的均方根误差（RMSE）来衡量：\n$$\n\\text{RMSE}_I = \\sqrt{ \\frac{1}{N} \\sum_{k=0}^{N-1} \\left( \\sqrt{w_k} - I_d \\right)^2 },\n$$\n以安培（A）表示。设计要求是从一个具有固定 $R$ 值的候选网格中选择权重 $(Q, S)$，使得在满足 $\\text{RMSE}_I \\le \\varepsilon$ 的条件下最小化 $\\Delta T_{\\text{overshoot}}$，其中 $\\varepsilon$ 是一个性能阈值。\n\n为每个测试用例实现以下算法：\n- 步骤 $1$：在阶跃输入 $w_k = w_{\\max}$ 下，计算开环最坏情况温度超调。\n- 步骤 $2$：对于候选网格中的每一对 $(Q, S)$，使用离散时间模型和目标函数 $J$ 求解关于 $w_{0:N-1}$ 的有界优化问题，然后计算产生的超调和 $\\text{RMSE}_I$。\n- 步骤 $3$：在满足 $\\text{RMSE}_I \\le \\varepsilon$ 的候选者中，选择超调最小的一个；如果出现平局，则选择 $S$ 最小的一个；如果没有候选者满足约束，则选择超调最小的候选者并报告其 $\\text{RMSE}_I$。\n- 步骤 $4$：报告开环超调、选定权重下的MPC超调、$\\text{RMSE}_I$ 以及选定的 $(Q, S)$。\n\n单位和数值要求：\n- 温度必须以摄氏度处理；报告的超调以摄氏度为单位，四舍五入到三位小数。\n- 电流必须以安培为单位；报告的 $\\text{RMSE}_I$ 以安培为单位，四舍五入到三位小数。\n- 角度不适用于此问题。\n- 所有时间单位均为秒。\n\n测试套件：\n- 用例A（正常路径）：$C_c = 4000$, $C_s = 2000$, $h_{cs} = 10$, $h_{sa} = 5$, $\\eta = 0.02$, $\\Delta t = 1$, $N = 120$, $T_{\\text{amb}} = 25$, $T_{c,0} = 25$, $T_{s,0} = 25$, $I_d = 100$, $T_{\\max} = 35$, $\\varepsilon = 10$, $R = 0.01$, 候选 $Q \\in \\{0.1, 1.0, 10.0\\}$, 候选 $S \\in \\{0.1, 1.0, 10.0, 100.0\\}$。\n- 用例B（边界接近极限）：$C_c = 4000$, $C_s = 2000$, $h_{cs} = 10$, $h_{sa} = 5$, $\\eta = 0.02$, $\\Delta t = 1$, $N = 120$, $T_{\\text{amb}} = 25$, $T_{c,0} = 34$, $T_{s,0} = 34$, $I_d = 100$, $T_{\\max} = 35$, $\\varepsilon = 10$, $R = 0.01$, 候选 $Q \\in \\{0.1, 1.0, 10.0\\}$, 候选 $S \\in \\{0.1, 1.0, 10.0, 100.0\\}$。\n- 用例C（高环境温度，较低电流）：$C_c = 4000$, $C_s = 2000$, $h_{cs} = 10$, $h_{sa} = 5$, $\\eta = 0.02$, $\\Delta t = 1$, $N = 120$, $T_{\\text{amb}} = 35$, $T_{c,0} = 35$, $T_{s,0} = 35$, $I_d = 80$, $T_{\\max} = 40$, $\\varepsilon = 8$, $R = 0.01$, 候选 $Q \\in \\{0.1, 1.0, 10.0\\}$, 候选 $S \\in \\{0.1, 1.0, 10.0, 100.0\\}$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表，列表中的每个元素对应一个测试用例，并且本身是一个包含五个浮点数的方括号逗号分隔列表，顺序为：$[\\Delta T_{\\text{overshoot,open}}, \\Delta T_{\\text{overshoot,MPC}}, \\text{RMSE}_I, Q, S]$。例如：$[[1.234,0.987,2.345,1.0,10.0],[...],[...]]$。",
            "solution": "用户提供了一个需要为电池热管理设计和评估模型预测控制（MPC）策略的问题。该问题需要针对一组测试用例进行求解。\n\n### 步骤 1：提取已知条件\n\n此问题的已知条件如下：\n- **系统模型**：一个双节点的集总电-热电池模型。\n  - 核心温度：$T_c$，表面温度：$T_s$。\n  - 热容：$C_c$, $C_s$。\n  - 热导：$h_{cs}$（核心-表面），$h_{sa}$（表面-环境）。\n  - 环境温度：$T_{\\text{amb}}$。\n  - 电阻热分数：$\\eta$。问题文本指出“对于简单的焦耳模型，$\\eta = R$”，其中 $R$ 将是内阻。在这里，$\\eta$ 以数值形式给出，代表了电阻和在核心中产生的热量比例的集总效应。\n  - 电流：$I$。\n- **连续时间动态**：\n  $$C_c \\frac{dT_c}{dt} = - h_{cs} (T_c - T_s) + \\eta I^2$$\n  $$C_s \\frac{dT_s}{dt} = h_{cs} (T_c - T_s) - h_{sa} (T_s - T_{\\text{amb}})$$\n- **离散时间动态**：采用采样时间为 $\\Delta t$ 的前向欧拉离散化。\n  $$\n  \\begin{bmatrix}\n  T_{c,k+1} \\\\\n  T_{s,k+1}\n  \\end{bmatrix}\n  =\n  \\mathbf{A_d}\n  \\begin{bmatrix}\n  T_{c,k} \\\\\n  T_{s,k}\n  \\end{bmatrix}\n  + \\mathbf{B_d} \\, w_k + \\mathbf{g_d}\n  $$\n  其中 $w_k = I_k^2$，矩阵定义如下：\n  $$ \\mathbf{A_d} = I_2 + \\Delta t \\, A, \\quad \\mathbf{B_d} = \\Delta t \\, B, \\quad \\mathbf{g_d} = \\Delta t \\, g $$\n  $$ A = \\begin{bmatrix} -\\frac{h_{cs}}{C_c}  \\frac{h_{cs}}{C_c} \\\\ \\frac{h_{cs}}{C_s}  -\\frac{h_{cs} + h_{sa}}{C_s} \\end{bmatrix}, \\quad B = \\begin{bmatrix} \\frac{\\eta}{C_c} \\\\ 0 \\end{bmatrix}, \\quad g = \\begin{bmatrix} 0 \\\\ \\frac{h_{sa}}{C_s} T_{\\text{amb}} \\end{bmatrix} $$\n- **控制问题**：\n  - 期望电流：$I_d \\ge 0$。期望电流平方：$w_d = I_d^2$。\n  - 控制输入边界：$0 \\le w_k \\le w_{\\max}$，其中 $w_{\\max} = I_d^2$。\n  - 预测时域：$N$ 步。\n- **性能指标**：\n  - 最坏情况温度超调：$\\Delta T_{\\text{overshoot}} = \\max\\left(0, \\max_{0 \\le k \\le N} \\left( T_{s,k} - T_{\\max} \\right) \\right)$，其中 $T_{\\max}$ 是温度限制。\n  - 电流跟踪均方根误差：$\\text{RMSE}_I = \\sqrt{ \\frac{1}{N} \\sum_{k=0}^{N-1} \\left( \\sqrt{w_k} - I_d \\right)^2 }$。\n- **MPC 目标函数**：\n  $$ J = \\sum_{k=0}^{N-1} \\left[ Q \\left(w_k - w_d\\right)^2 + R \\left(w_k - w_{k-1}\\right)^2 + S \\left( \\max\\left(0, T_{s,k} - T_{\\max}\\right) \\right)^2 \\right] $$\n  - 权重：$Q$（跟踪），$R$（平滑性），$S$（温度惩罚）。\n  - 平滑项的初始条件：$w_{-1} = w_d$。\n- **设计任务**：从给定的网格中找到权重 $(Q, S)$，以在满足性能约束 $\\text{RMSE}_I \\le \\varepsilon$ 的前提下，最小化 $\\Delta T_{\\text{overshoot}}$。\n- **选择逻辑**：\n  1.  筛选满足 $\\text{RMSE}_I \\le \\varepsilon$ 的候选者。\n  2.  从筛选后的集合中，选择 $\\Delta T_{\\text{overshoot}}$ 最小的一个。\n  3.  使用最小的 $S$ 来打破平局。\n  4.  如果没有候选者满足约束，则选择总体上 $\\Delta T_{\\text{overshoot}}$ 最小的一个。\n- **测试用例**：提供了三个不同的测试用例（A, B, C），包含了所有必要的数值参数。\n\n### 步骤 2：使用提取的已知条件进行验证\n1.  **科学依据**：该问题基于热力学和控制理论的基本原理。双节点热模型是电池分析中标准且物理上现实的简化。MPC 公式化是约束最优控制的典型方法。\n2.  **良态性**：问题是良态的。系统动态是线性和时不变的（仿射），目标函数是凸的（因为它是平方项和平方hinge损失项的和），并且约束是简单的边界。这种结构保证了MPC优化子问题存在唯一的 dla解。整个任务是在一个离散的参数网格上进行搜索，这也是明确定义的。\n3.  **目标**：问题以精确的数学和算法术语陈述，没有主观性或模糊性。\n4.  **完整性**：为每个测试用例提供了所有需要的数据、常数、初始条件和参数网格，使问题自成体系。\n5.  **一致性**：问题陈述中没有矛盾之处。定义、方程和算法步骤在逻辑上是一致的。\n\n### 步骤 3：结论与行动\n问题陈述是有效的。这是一个在应用于电池系统的控制工程领域中定义明确且科学合理的问题。我将继续进行完整求解。\n\n### 基于原理的求解推导\n\n将为每个测试用例遵循问题描述中指定的四步算法来实施解决方案。\n\n**1. 系统离散化**：\n首先，对于每个测试用例，使用给定的物理参数（$C_c, C_s, h_{cs}, h_{sa}, \\eta, T_{\\text{amb}}$）构建连续时间系统矩阵 $A$ 和向量 $B, g$。然后使用指定的采样时间 $\\Delta t$，通过前向欧拉方法计算离散时间系统矩阵 $\\mathbf{A_d}$、$\\mathbf{B_d}$ 和向量 $\\mathbf{g_d}$。\n\n**2. 开环分析（步骤 1）**：\n通过在整个时域 $k=0, \\dots, N-1$ 上应用恒定的电流平方阶跃输入 $w_k = w_{\\max} = I_d^2$ 来模拟开环响应。从初始状态 $(T_{c,0}, T_{s,0})$ 开始，使用离散时间方程传播状态轨迹 $N$ 步：\n$$ \\begin{bmatrix} T_{c,k+1} \\\\ T_{s,k+1} \\end{bmatrix} = \\mathbf{A_d} \\begin{bmatrix} T_{c,k} \\\\ T_{s,k} \\end{bmatrix} + \\mathbf{B_d} w_{\\max} + \\mathbf{g_d} $$\n仿真产生一系列表面温度 $T_{s,0}, T_{s,1}, \\dots, T_{s,N}$。然后，将开环超调 $\\Delta T_{\\text{overshoot,open}}$ 计算为该轨迹上超过极限 $T_{\\max}$ 的最大温度。\n\n**3. MPC 公式化与优化（步骤 2）**：\n此步骤涉及求解一系列优化问题，每个问题对应于所提供候选网格中的一对权重 $(Q, S)$。对于每一对，目标是找到最优的控制输入序列 $w_0, \\dots, w_{N-1}$，以最小化目标函数 $J$。\n\n目标函数 $J$ 是一个加权和，代表三个相互竞争的目标：\n- **跟踪**：项 $Q(w_k - w_d)^2$ 惩罚施加的（平方）电流 $w_k$ 与期望的（平方）电流 $w_d = I_d^2$ 之间的偏差。较高的 $Q$ 优先考虑性能。\n- **平滑性**：项 $R(w_k - w_{k-1})^2$ 惩罚连续时间步之间控制输入的巨大变化，防止剧烈的控制动作。\n- **热安全**：项 $S(\\max(0, T_{s,k} - T_{\\max}))^2$ 在预测的表面温度 $T_{s,k}$ 超过安全极限 $T_{\\max}$ 时施加重罚。较高的 $S$ 优先考虑温度调节。\n\n这是一个有约束的非线性优化问题，可以表述为：\n$$ \\underset{w_0, \\dots, w_{N-1}}{\\text{minimize}} \\quad J(w_0, \\dots, w_{N-1}) $$\n$$ \\text{subject to} \\quad 0 \\le w_k \\le w_{\\max} \\quad \\text{for } k=0, \\dots, N-1 $$\n\n为了解决这个问题，需要一个数值优化器。`scipy.optimize.minimize` 函数及其顺序最小二乘规划（`SLSQP`）方法非常适合此任务，因为它可以处理带有边界的非线性目标。传递给优化器的目标函数必须能够针对给定的试验输入序列 `w`，在内部模拟系统动态以计算惩罚项所需的状态轨迹 $T_{s,k}$。\n\n**4. 性能评估与候选选择（步骤 3）**：\n在为给定的 $(Q, S)$ 对获得最优输入序列 $w_{\\text{opt}}$ 后，使用此输入再次模拟系统，以找到最终的温度轨迹。根据此轨迹，计算受控超调 $\\Delta T_{\\text{overshoot,MPC}}$ 和电流跟踪误差 $\\text{RMSE}_I$。对所有的 $(Q, S)$ 对重复此过程。\n\n最后，根据指定的逻辑选择最佳配对：\n- 首先，我们识别出满足性能标准 $\\text{RMSE}_I \\le \\varepsilon$ 的解决方案子集。\n- 如果该子集非空，我们首先按升序排列 $\\Delta T_{\\text{overshoot}}$，然后按升序排列 $S$ 以打破平局。顶部的条目即为所选解决方案。\n- 如果没有解决方案满足性能标准，我们将所有解决方案按升序排列 $\\Delta T_{\\text{overshoot}}$ 并选择顶部的一个，无论其 $\\text{RMSE}_I$ 如何。\n\n**5. 报告（步骤 4）**：\n对于每个测试用例，最终结果是一个列表，包含开环超调、找到的最佳MPC超调、相应的 $\\text{RMSE}_I$ 以及实现此结果的 $Q$ 和 $S$ 的值。然后按规定格式化这些结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef solve():\n    \"\"\"\n    Solves the battery MPC problem for a suite of test cases.\n    \"\"\"\n    test_cases = [\n        # Case A: Happy path\n        {\n            'params': {'Cc': 4000, 'Cs': 2000, 'hcs': 10, 'hsa': 5, 'eta': 0.02, 'dt': 1, 'N': 120, 'Tamb': 25, 'Tc0': 25, 'Ts0': 25},\n            'spec': {'Id': 100, 'Tmax': 35, 'epsilon': 10, 'R': 0.01},\n            'grid': {'Q': [0.1, 1.0, 10.0], 'S': [0.1, 1.0, 10.0, 100.0]}\n        },\n        # Case B: Boundary near limit\n        {\n            'params': {'Cc': 4000, 'Cs': 2000, 'hcs': 10, 'hsa': 5, 'eta': 0.02, 'dt': 1, 'N': 120, 'Tamb': 25, 'Tc0': 34, 'Ts0': 34},\n            'spec': {'Id': 100, 'Tmax': 35, 'epsilon': 10, 'R': 0.01},\n            'grid': {'Q': [0.1, 1.0, 10.0], 'S': [0.1, 1.0, 10.0, 100.0]}\n        },\n        # Case C: High ambient, lower current\n        {\n            'params': {'Cc': 4000, 'Cs': 2000, 'hcs': 10, 'hsa': 5, 'eta': 0.02, 'dt': 1, 'N': 120, 'Tamb': 35, 'Tc0': 35, 'Ts0': 35},\n            'spec': {'Id': 80, 'Tmax': 40, 'epsilon': 8, 'R': 0.01},\n            'grid': {'Q': [0.1, 1.0, 10.0], 'S': [0.1, 1.0, 10.0, 100.0]}\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        p = case['params']\n        s = case['spec']\n        g = case['grid']\n\n        # Unpack parameters\n        Cc, Cs, hcs, hsa, eta, dt, N, Tamb, Tc0, Ts0 = p.values()\n        Id, Tmax, epsilon, R = s.values()\n        Q_grid, S_grid = g.values()\n\n        # Define system matrices\n        A_cont = np.array([\n            [-hcs / Cc, hcs / Cc],\n            [hcs / Cs, -(hcs + hsa) / Cs]\n        ])\n        B_cont = np.array([[eta / Cc], [0]])\n        g_cont = np.array([[0], [hsa * Tamb / Cs]])\n\n        # Discretize using Forward Euler\n        I_2 = np.identity(2)\n        Ad = I_2 + dt * A_cont\n        Bd_vec = dt * B_cont\n        gd_vec = dt * g_cont\n\n        w_d = Id**2\n        w_max = Id**2\n\n        # --- Step 1: Open-loop overshoot ---\n        T_ol = np.zeros((N + 1, 2))\n        T_ol[0] = [Tc0, Ts0]\n        for k in range(N):\n            T_ol[k+1] = Ad @ T_ol[k] + (Bd_vec * w_max + gd_vec).flatten()\n        Ts_ol = T_ol[:, 1]\n        overshoot_ol = max(0, np.max(Ts_ol) - Tmax)\n\n        # --- Steps 2  3: MPC Optimization and Selection ---\n        w_initial = np.full(N, w_d)\n        bounds = [(0, w_max) for _ in range(N)]\n        w_minus_1 = w_d\n\n        mpc_results = []\n        for Q in Q_grid:\n            for S in S_grid:\n                \n                def objective_func(w):\n                    T_pred = np.zeros((N + 1, 2))\n                    T_pred[0] = [Tc0, Ts0]\n                    for k in range(N):\n                        T_pred[k+1] = Ad @ T_pred[k] + (Bd_vec * w[k] + gd_vec).flatten()\n\n                    J_tracking = Q * np.sum((w - w_d)**2)\n                    \n                    w_lagged = np.insert(w[:-1], 0, w_minus_1)\n                    J_smoothness = R * np.sum((w - w_lagged)**2)\n\n                    Ts_for_J = T_pred[:N, 1]\n                    overshoot_terms = np.maximum(0, Ts_for_J - Tmax)\n                    J_temp_penalty = S * np.sum(overshoot_terms**2)\n                    \n                    return J_tracking + J_smoothness + J_temp_penalty\n\n                opt_res = minimize(\n                    objective_func,\n                    w_initial,\n                    method='SLSQP',\n                    bounds=bounds,\n                    options={'maxiter': 200, 'ftol': 1e-6}\n                )\n                w_opt = opt_res.x\n\n                # Evaluate performance with optimal control sequence\n                T_mpc = np.zeros((N + 1, 2))\n                T_mpc[0] = [Tc0, Ts0]\n                for k in range(N):\n                    T_mpc[k+1] = Ad @ T_mpc[k] + (Bd_vec * w_opt[k] + gd_vec).flatten()\n                \n                Ts_mpc = T_mpc[:, 1]\n                overshoot_mpc = max(0, np.max(Ts_mpc) - Tmax)\n                \n                w_opt_safe = np.maximum(0, w_opt)\n                rmse_I = np.sqrt(np.mean((np.sqrt(w_opt_safe) - Id)**2))\n                \n                mpc_results.append({\n                    'overshoot': overshoot_mpc,\n                    'rmse': rmse_I,\n                    'Q': Q,\n                    'S': S\n                })\n\n        # Select best candidate\n        valid_candidates = [r for r in mpc_results if r['rmse'] = epsilon]\n\n        if valid_candidates:\n            # Sort by overshoot, then by S\n            best_candidate = sorted(valid_candidates, key=lambda x: (x['overshoot'], x['S']))[0]\n        else:\n            # If no candidate is valid, sort all by overshoot\n            best_candidate = sorted(mpc_results, key=lambda x: x['overshoot'])[0]\n\n        # --- Step 4: Report ---\n        final_result = [\n            round(overshoot_ol, 3),\n            round(best_candidate['overshoot'], 3),\n            round(best_candidate['rmse'], 3),\n            float(best_candidate['Q']),\n            float(best_candidate['S'])\n        ]\n        all_results.append(final_result)\n    \n    # Format the final output string\n    output_str = \"[\" + \",\".join([f\"[{','.join(map(str, res))}]\" for res in all_results]) + \"]\"\n    print(output_str)\n\nsolve()\n```"
        }
    ]
}