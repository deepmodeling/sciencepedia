{
    "hands_on_practices": [
        {
            "introduction": "模型预测控制（MPC）的许多实际应用都始于为系统建立一个足够精确但计算上易于处理的预测模型。本练习将指导您完成这一基本步骤，即为一个典型的锂离子电池构建一个线性（仿射）电压模型。通过围绕一个标称工作点对非线性的开路电压（OCV）曲线进行线性化，我们将创建一个适用于线性MPC框架的模型，并定量评估该简化在不同电流下的精度，这对于理解模型失配对控制器性能的影响至关重要 。",
            "id": "3928848",
            "problem": "要求您从一个基于物理的电池模型出发，构建并评估一个适用于模型预测控制 (MPC) 的仿射端电压模型，并量化相对于电流大小的线性化误差。请仅使用本说明中的信息和要求来推导、实现和测试您的解决方案。\n\n物理基础和定义如下。令 $x \\in [0,1]$ 表示荷电状态 (SOC)，定义为剩余可用容量的分数。在恒定施加电流下的 SOC 动态由电荷守恒给出，其中 $u$ 是施加的电流（放电为正，充电为负），$\\eta$ 是电荷转移效率，$Q_{\\mathrm{nom}}$ 是以安秒为单位的标称容量，$\\Delta t$ 是以秒为单位的采样时间。对于恒流段的离散时间 SOC 更新为\n$$\nx_{k+1} \\,=\\, x_k \\,-\\, \\frac{\\eta\\,\\Delta t}{Q_{\\mathrm{nom}}}\\,u_k,\n$$\n每次更新后进行饱和处理，以保持 $x_k$ 在 $[0,1]$ 范围内。端电压 $V$ 定义为开路电位减去瞬时欧姆压降，即\n$$\nV \\,=\\, E(x) \\,-\\, R\\,u,\n$$\n其中 $R$ 是以欧姆为单位的内部欧姆电阻，$E(x)$ 是作为 SOC 函数的开路电位。\n\n对于仿真和测试，请使用一个广泛接受的 S 型开路电位函数，该函数能捕捉典型锂离子电池的单调和饱和行为：\n$$\nE(x) \\,=\\, E_{\\min} \\,+\\, \\frac{\\Delta E}{1 + \\exp\\!\\big(-k\\,(x - x_{\\mathrm{mid}})\\big)},\n$$\n其中 $E_{\\min}$ 是以伏特为单位的下渐近线，$E_{\\max}$ 是以伏特为单位的上渐近线，$\\Delta E \\,=\\, E_{\\max} - E_{\\min}$，$k$ 是一个无量纲的斜率参数，$x_{\\mathrm{mid}}$ 是曲线变化最快的中点 SOC。\n\n任务要求：\n- 推导 $E(x)$ 在标称 SOC $x^\\star$ 附近的一阶泰勒线性化，并用它构建一个适用于 MPC 设计的仿射近似 $V_{\\mathrm{lin}}$。不要在问题陈述中写下最终的线性化表达式；您必须在解决方案中从第一性原理推导它。\n- 实现一个程序，对于每个测试用例，在恒定电流 $u$ 下执行一个固定时域 $N$ 步的前向仿真，在每一步计算精确的非线性端电压 $V_k$ 和仿射线性化电压 $V_{\\mathrm{lin},k}$，并返回以伏特为单位的均方根误差 (RMSE)，定义为\n$$\n\\mathrm{RMSE} \\,=\\, \\sqrt{\\frac{1}{N}\\sum_{k=1}^{N}\\left(V_k \\,-\\, V_{\\mathrm{lin},k}\\right)^2}.\n$$\n- 使用一个饱和 SOC 积分器，在每一步强制 $x_k \\in [0,1]$。\n- 以伏特为单位表示每个 RMSE，并报告到小数点后六位。\n\n在此背景下，模型预测控制 (MPC) 的精度通过在不同电流大小下，预测时域内的线性化误差大小来评估。较大的电流会更快地改变 SOC，并可能由于 $E(x)$ 的非线性而增加线性化误差。\n\n参数值和单位：\n- 使用以安秒为单位的 $Q_{\\mathrm{nom}}$，其中 $Q_{\\mathrm{nom}}$ 通过将安时乘以 $3600$ 得出。\n- 使用以安培为单位的 $u$，以欧姆为单位的 $R$，以伏特为单位的 $E$ 和 $V$，以秒为单位的 $\\Delta t$。\n- S 型 OCV 参数 $E_{\\min}$ 以伏特为单位，$E_{\\max}$ 以伏特为单位，$k$ 无量纲，$x_{\\mathrm{mid}}$ 无量纲。\n\n您的程序必须评估以下参数集测试套件。每个测试用例以元组形式给出，包含 $(Q_{\\mathrm{Ah}}, \\Delta t, N, u, R, x^\\star, x_0, E_{\\min}, E_{\\max}, k, x_{\\mathrm{mid}}, \\eta)$，其中 $Q_{\\mathrm{Ah}}$ 是以安时为单位的标称容量，而 $Q_{\\mathrm{nom}} = 3600 \\cdot Q_{\\mathrm{Ah}}$ 在内部计算：\n- 测试用例 1：$(5, 1, 600, 0, 0.05, 0.5, 0.5, 3.0, 4.2, 0.8, 0.5, 1.0)$。\n- 测试用例 2：$(5, 1, 600, 2, 0.05, 0.5, 0.5, 3.0, 4.2, 0.8, 0.5, 1.0)$。\n- 测试用例 3：$(5, 1, 600, -4, 0.05, 0.9, 0.9, 3.0, 4.2, 0.8, 0.5, 1.0)$。\n- 测试用例 4：$(5, 1, 600, 20, 0.05, 0.2, 0.2, 3.0, 4.2, 0.8, 0.5, 1.0)$。\n\n要求的最终输出格式是单行，包含一个用方括号括起来的逗号分隔列表，其中每个条目是相应测试用例的 RMSE，以伏特表示并格式化为六位小数，例如 $[0.000123,0.001234,0.012345,0.123456]$。您的程序必须精确地生成这一行，不含任何附加文本。",
            "solution": "我们从支配可充电电池在与模型预测控制 (MPC) 相关领域中行为的基本原理开始。端电压 $V$ 被建模为开路电位和瞬时欧姆效应之和，其基于物理的关系为 $V \\,=\\, E(x) \\,-\\, R\\,u$。荷电状态 (SOC) $x$ 根据电荷守恒演化：电流 $u$ 定义为放电时为正，其变化率为 $\\dot{x} \\,=\\, -\\frac{\\eta}{Q_{\\mathrm{nom}}}u$，其中 $\\eta$ 是电荷转移效率，$Q_{\\mathrm{nom}}$ 是以安秒为单位的标称容量。在具有均匀采样间隔 $\\Delta t$ 的离散时间中，SOC 更新为 $x_{k+1} \\,=\\, x_k \\,-\\, \\frac{\\eta \\Delta t}{Q_{\\mathrm{nom}}}u_k$，并通过饱和处理强制执行物理状态约束 $x_k \\in [0,1]$。这与将 $x \\in [0,1]$ 定义为可用电荷分数是一致的，并且是用于控制的电化学建模中一个经过充分检验的近似方法。\n\n对于高级控制设计和预测，MPC 通常需要在目标变量中建立仿射模型，此处为作为状态和输入函数的端电压。非线性分量是开路电位函数 $E(x)$。我们给定一个 S 型形式，它能捕捉锂离子开路电压的定性行为：\n$$\nE(x) \\,=\\, E_{\\min} \\,+\\, \\frac{\\Delta E}{1 + \\exp\\!\\big(-k\\,(x - x_{\\mathrm{mid}})\\big)}, \\quad \\Delta E \\,=\\, E_{\\max} - E_{\\min}.\n$$\n该函数在 $x$ 上是单调递增的，当 $x \\to 0$ 时在 $E_{\\min}$ 附近饱和，当 $x \\to 1$ 时在 $E_{\\max}$ 附近饱和。线性化需要其导数。定义逻辑斯蒂分数 $s(x) \\,=\\, \\frac{1}{1 + \\exp\\!\\big(-k\\,(x - x_{\\mathrm{mid}})\\big)}$。则 $E(x) \\,=\\, E_{\\min} + \\Delta E \\, s(x)$，根据链式法则可得 $E'(x) \\,=\\, \\Delta E \\, s'(x)$，其中\n$$\ns'(x) \\,=\\, \\frac{\\mathrm{d}}{\\mathrm{d}x}\\left(\\frac{1}{1 + e^{-k(x - x_{\\mathrm{mid}})}}\\right) \\,=\\, \\frac{k\\,e^{-k(x - x_{\\mathrm{mid}})}}{\\left(1 + e^{-k(x - x_{\\mathrm{mid}})}\\right)^2} \\,=\\, k\\,s(x)\\,\\big(1 - s(x)\\big).\n$$\n因此，\n$$\nE'(x) \\,=\\, \\Delta E \\, k \\, s(x)\\,\\big(1 - s(x)\\big).\n$$\n\n为了构建 MPC 所需的仿射近似，我们在一个选定的标称 SOC $x^\\star$ 周围对 $E(x)$ 进行一阶泰勒线性化。可微函数 $E(x)$ 在 $x^\\star$ 的泰勒展开对于接近 $x^\\star$ 的 $x$ 给出 $E(x) \\approx E(x^\\star) + E'(x^\\star)\\,(x - x^\\star)$。将此代入电压表达式 $V \\,=\\, E(x) \\,-\\, R\\,u$，我们得到一个关于 $(x,u)$ 的仿射函数，它包含一个常数项和一个在状态偏差 $(x - x^\\star)$ 及输入 $u$ 上线性的项。这个仿射模型就是 MPC 用来预测在标称点附近小偏差下的电压，同时考虑了通过电阻的输入项 $-R\\,u$。\n\n为了量化相对于电流大小的线性化误差，我们在一个 $N$ 步的时域内用恒定电流 $u$ 传播 SOC，并在每一步计算精确的非线性电压 $V_k$ 和从 $x^\\star$ 处的线性化构建的仿射线性化电压 $V_{\\mathrm{lin},k}$。第 $k$ 步的误差是 $\\delta V_k \\,=\\, V_k - V_{\\mathrm{lin},k}$。因为欧姆项 $-R\\,u$ 同时出现在 $V_k$ 和 $V_{\\mathrm{lin},k}$ 中，所以误差完全由 $E(x)$ 的非线性决定，\n$$\n\\delta V_k \\,=\\, E(x_k) \\,-\\, \\big(E(x^\\star) + E'(x^\\star)\\,(x_k - x^\\star)\\big).\n$$\n在时域内的均方根误差 (RMSE) 是\n$$\n\\mathrm{RMSE} \\,=\\, \\sqrt{\\frac{1}{N}\\sum_{k=1}^{N}\\left(\\delta V_k\\right)^2}.\n$$\n该指标随电流大小的增加而增加，因为更大的 $|u|$ 会更快地改变 $x_k$，使状态离 $x^\\star$ 更远，从而增加了一阶近似所忽略的高阶项的贡献。\n\n程序的算法设计：\n- 通过 $Q_{\\mathrm{nom}} \\,=\\, 3600 \\cdot Q_{\\mathrm{Ah}}$ 将 $Q_{\\mathrm{Ah}}$ 转换为以安秒为单位的 $Q_{\\mathrm{nom}}$。\n- 初始化 $x_0$ 并为线性化点设置 $x^\\star$。使用 $E'(x^\\star) \\,=\\, \\Delta E \\, k \\, s(x^\\star)\\,\\big(1 - s(x^\\star)\\big)$ 和 $s(x^\\star) \\,=\\, \\frac{1}{1 + \\exp\\!\\big(-k\\,(x^\\star - x_{\\mathrm{mid}})\\big)}$ 从 S 型 $E(x)$ 表达式计算导数 $E'(x^\\star)$。\n- 对于从 $1$ 到 $N$ 的 $k$，使用 $x_{k} \\,=\\, \\operatorname{clip}\\!\\left(x_{k-1} - \\frac{\\eta\\,\\Delta t}{Q_{\\mathrm{nom}}}\\,u,\\;0,\\;1\\right)$ 传播 SOC，其中 $\\operatorname{clip}$ 函数强制饱和到区间 $[0,1]$。\n- 在每一步，计算 $V_k \\,=\\, E(x_k) \\,-\\, R\\,u$ 和 $V_{\\mathrm{lin},k} \\,=\\, \\big(E(x^\\star) + E'(x^\\star)\\,(x_k - x^\\star)\\big) \\,-\\, R\\,u$，累加 $\\left(V_k - V_{\\mathrm{lin},k}\\right)^2$，最后计算 RMSE。\n- 对每个测试用例重复此过程，并按指定格式以单行报告以伏特为单位的 RMSE 值列表，每个值保留六位小数。\n\n对 MPC 精度的解释：当 $u \\,=\\, 0$ 时，SOC 恒定，在 $x^\\star$ 处的线性化是局部精确的，因此 RMSE 为零。随着 $|u|$ 的增加，SOC 偏离 $x^\\star$，$E(x)$ 的 S 型曲率贡献了高阶项，从而增加了 RMSE。在 SOC 边界附近，饱和以及 S 型曲线的低曲率区域可能会改变误差的增长；然而，只要 RMSE 在预测时域内相对于控制和测量容差保持较小，一阶仿射近似仍然是 MPC 的一个有用的局部模型。该程序在科学上合理的参数和单位下，数值化地量化了这种行为。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef ocv_sigmoid(x, Emin, Emax, k, xmid):\n    \"\"\"\n    Open-circuit voltage E(x) using a logistic sigmoid between Emin and Emax.\n\n    E(x) = Emin + (Emax - Emin) / (1 + exp(-k*(x - xmid)))\n\n    Parameters:\n        x: SOC in [0,1]\n        Emin: lower asymptote (V)\n        Emax: upper asymptote (V)\n        k: slope parameter (dimensionless)\n        xmid: mid-SOC (dimensionless)\n    Returns:\n        E: voltage (V)\n    \"\"\"\n    dE = Emax - Emin\n    return Emin + dE / (1.0 + np.exp(-k * (x - xmid)))\n\ndef docv_dx_sigmoid(x, Emin, Emax, k, xmid):\n    \"\"\"\n    Derivative dE/dx for the OCV sigmoid model.\n\n    Using s(x) = 1 / (1 + exp(-k*(x - xmid))), then\n    dE/dx = (Emax - Emin) * k * s * (1 - s)\n    \"\"\"\n    dE = Emax - Emin\n    s = 1.0 / (1.0 + np.exp(-k * (x - xmid)))\n    return dE * k * s * (1.0 - s)\n\ndef rmse_linearization_error(params):\n    \"\"\"\n    Compute RMSE between nonlinear V(x) and affine-linearized V around x_star.\n\n    params: tuple (Q_Ah, dt, N, u, R, x_star, x0, Emin, Emax, k, xmid, eta)\n    Returns:\n        rmse (float, volts)\n    \"\"\"\n    Q_Ah, dt, N, u, R, x_star, x0, Emin, Emax, k, xmid, eta = params\n    Q_nom = Q_Ah * 3600.0  # Ampere-second\n    # Precompute linearization constants at x_star\n    E_star = ocv_sigmoid(x_star, Emin, Emax, k, xmid)\n    dE_dx_star = docv_dx_sigmoid(x_star, Emin, Emax, k, xmid)\n\n    # Initialize SOC\n    x = float(x0)\n\n    # Accumulate squared error\n    se = 0.0\n\n    for _ in range(int(N)):\n        # SOC update with saturation to [0,1]\n        x = x - (eta * dt / Q_nom) * u\n        if x  0.0:\n            x = 0.0\n        elif x > 1.0:\n            x = 1.0\n\n        # Nonlinear terminal voltage\n        V_true = ocv_sigmoid(x, Emin, Emax, k, xmid) - R * u\n\n        # Affine-linearized terminal voltage around x_star\n        E_lin = E_star + dE_dx_star * (x - x_star)\n        V_lin = E_lin - R * u\n\n        err = V_true - V_lin\n        se += err * err\n\n    rmse = np.sqrt(se / float(N))\n    return float(rmse)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each tuple: (Q_Ah, dt, N, u, R, x_star, x0, Emin, Emax, k, xmid, eta)\n    test_cases = [\n        (5.0, 1.0, 600, 0.0, 0.05, 0.5, 0.5, 3.0, 4.2, 0.8, 0.5, 1.0),\n        (5.0, 1.0, 600, 2.0, 0.05, 0.5, 0.5, 3.0, 4.2, 0.8, 0.5, 1.0),\n        (5.0, 1.0, 600, -4.0, 0.05, 0.9, 0.9, 3.0, 4.2, 0.8, 0.5, 1.0),\n        (5.0, 1.0, 600, 20.0, 0.05, 0.2, 0.2, 3.0, 4.2, 0.8, 0.5, 1.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = rmse_linearization_error(case)\n        # Format to six decimal places as required\n        results.append(f\"{result:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "虽然线性模型在许多情况下都很有用，但为了获得更高的保真度，控制器必须能够处理电池固有的非线性行为，例如电阻与温度的相关性。本练习将介绍一种处理非线性的常用技术——连续线性化MPC，该技术依赖于对系统动态进行精确的实时线性化。您将为一个非线性电热模型推导其雅可比矩阵，并通过数值方法进行验证，这是确保非线性MPC控制器稳定性和性能的关键实现技能 。",
            "id": "3928856",
            "problem": "给定一个适用于模型预测控制（MPC）中逐次线性化的轻度非线性连续时间电池热电模型。考虑一个等效电路模型（ECM），其包含一个电阻-电容（RC）支路，欧姆电阻依赖于温度，以及集总热力学动态。状态向量为 $\\mathbf{x} = [s, v, T]^\\top$，其中 $s$ 是荷电状态（无量纲），$v$ 是RC支路电容器电压（单位：$\\mathrm{V}$），$T$ 是电芯温度（单位：$\\mathrm{K}$）。控制输入为 $\\mathbf{u} = I$（单位：$\\mathrm{A}$），其中正值 $I$ 表示放电。欧姆电阻随温度的变化关系为 $R(T) = R_0 \\exp(\\gamma (T - T_{\\mathrm{ref}}))$，其中 $R_0$ 的单位为 $\\Omega$，$\\gamma$ 的单位为 $\\mathrm{K}^{-1}$，$T_{\\mathrm{ref}}$ 的单位为 $\\mathrm{K}$。RC支路的参数为 $R_1$（单位：$\\Omega$）和 $C_1$（单位：$\\mathrm{F}$），时间常数为 $\\tau_1 = R_1 C_1$。标称容量为 $Q$（单位：$\\mathrm{C}$），热容为 $C_{\\mathrm{th}}$（单位：$\\mathrm{J/K}$），对流系数与面积的乘积为 $hA$（单位：$\\mathrm{W/K}$）。环境温度为 $T_{\\mathrm{amb}}$（单位：$\\mathrm{K}$）。根据基本定律和广泛接受的建模近似，连续时间动态定义如下：\n- 电极-电解质系统中的电荷守恒得出 $ds/dt = -I/Q$。\n- RC支路遵循 $dv/dt = -(1/(R_1 C_1)) v + (1/C_1) I$。\n- 集总热能平衡得出 $dT/dt = (1/C_{\\mathrm{th}})\\left(R(T) I^2 - hA (T - T_{\\mathrm{amb}})\\right)$。\n\n使用采样周期为 $\\Delta t$ 秒的前向欧拉积分，将离散时间映射定义为 $\\mathbf{g}(\\mathbf{x}, \\mathbf{u}) = \\mathbf{x} + \\Delta t\\, \\mathbf{f}(\\mathbf{x}, \\mathbf{u})$，其中 $\\mathbf{f}$ 集合了连续时间动态的右侧项。\n\n任务：\n1. 从上述定义出发，根据第一性原理推导逐次线性化MPC所需的解析雅可比矩阵：在任意工作点 $(\\mathbf{x}_0, \\mathbf{u}_0)$ 的离散时间状态雅可比矩阵 $\\mathbf{A}_d = \\partial \\mathbf{g}/\\partial \\mathbf{x}$ 和离散时间输入雅可比矩阵 $\\mathbf{B}_d = \\partial \\mathbf{g}/\\partial \\mathbf{u}$。\n2. 实现一个完整、可运行的程序，该程序：\n   - 根据所述参数和变量，对模型 $\\mathbf{f}$ 和映射 $\\mathbf{g}$ 进行编码。\n   - 在给定的工作点计算第1部分中推导出的解析雅可比矩阵 $\\mathbf{A}_d$ 和 $\\mathbf{B}_d$。\n   - 使用中心有限差分法，通过对 $\\mathbf{g}$ 直接施加微小的、维度一致的扰动，来数值验证这些雅可比矩阵，并检查解析雅可比矩阵与数值雅可比矩阵之间逐项绝对差异的最大值是否在指定公差范围内。\n   - 对每个测试用例，返回一个布尔值，指示 $\\mathbf{A}_d$ 和 $\\mathbf{B}_d$ 是否都通过了验证。\n\n单位：\n- 电流 $I$ 使用 $\\mathrm{A}$，电压 $v$ 使用 $\\mathrm{V}$，温度 $T$ 使用 $\\mathrm{K}$。\n- 采样周期 $\\Delta t$ 的单位为 $\\mathrm{s}$。\n- 最终程序输出由布尔值组成，无单位。\n\n数值验证细节：\n- 对 $\\partial \\mathbf{g}/\\partial \\mathbf{x}$ 使用中心差分法，通过将每个状态分量 $x_j$ 扰动 $\\pm h_{x_j}$ 并计算 $(\\mathbf{g}(\\mathbf{x} + h_{x_j}\\mathbf{e}_j, \\mathbf{u}) - \\mathbf{g}(\\mathbf{x} - h_{x_j}\\mathbf{e}_j, \\mathbf{u}))/(2 h_{x_j})$。\n- 对 $\\partial \\mathbf{g}/\\partial \\mathbf{u}$ 使用中心差分法，通过将 $I$ 扰动 $\\pm h_u$ 并计算 $(\\mathbf{g}(\\mathbf{x}, \\mathbf{u} + h_u) - \\mathbf{g}(\\mathbf{x}, \\mathbf{u} - h_u))/(2 h_u)$。\n- 使用物理上微小且维度正确的扰动量 $h_s$、$h_v$、$h_T$、$h_u$。\n- 分别使用绝对公差 $\\tau_A$ 和 $\\tau_B$ 来验证 $\\mathbf{A}_d$ 和 $\\mathbf{B}_d$。\n\n参数值：\n- $Q = 10800\\,\\mathrm{C}$，$R_1 = 0.015\\,\\Omega$，$C_1 = 2000\\,\\mathrm{F}$，$R_0 = 0.02\\,\\Omega$，$\\gamma = 0.01\\,\\mathrm{K}^{-1}$，$T_{\\mathrm{ref}} = 298.15\\,\\mathrm{K}$，$C_{\\mathrm{th}} = 500\\,\\mathrm{J/K}$，$hA = 5\\,\\mathrm{W/K}$，$T_{\\mathrm{amb}} = 298.15\\,\\mathrm{K}$，$\\Delta t = 0.1\\,\\mathrm{s}$。\n- 扰动：$h_s = 10^{-6}$，$h_v = 10^{-6}\\,\\mathrm{V}$，$h_T = 10^{-6}\\,\\mathrm{K}$，$h_u = 10^{-6}\\,\\mathrm{A}$。\n- 公差：$\\tau_A = 10^{-8}$，$\\tau_B = 10^{-8}$。\n\n测试套件工作点 $(\\mathbf{x}_0, \\mathbf{u}_0)$:\n- 用例1（典型中程范围）：$\\mathbf{x}_0 = [0.5, 0.0, 298.15]$, $\\mathbf{u}_0 = 10.0$。\n- 用例2（低温边界）：$\\mathbf{x}_0 = [0.8, 0.1, 263.15]$, $\\mathbf{u}_0 = 5.0$。\n- 用例3（高温充电）：$\\mathbf{x}_0 = [0.2, -0.05, 308.15]$, $\\mathbf{u}_0 = -8.0$。\n- 用例4（无电流边缘情况）：$\\mathbf{x}_0 = [0.9, 0.0, 298.15]$, $\\mathbf{u}_0 = 0.0$。\n- 用例5（高温高倍率放电）：$\\mathbf{x}_0 = [0.1, 0.2, 318.15]$, $\\mathbf{u}_0 = 20.0$。\n\n要求的最终输出格式：\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，例如 $[\\text{result1},\\text{result2},\\text{result3},\\text{result4},\\text{result5}]$，其中每个结果是对应测试用例的布尔值。",
            "solution": "该问题已经过验证，被认为是有效的。它在科学上基于标准的电池建模原理，问题设定良好，目标明确，并为唯一解提供了所有必要的数据和约束。模型方程和单位在内部是一致的。\n\n任务是推导离散时间电池模型的解析雅可比矩阵，并实现一个程序对其进行数值验证。该模型基于连续时间系统的前向欧拉离散化。\n\n设状态向量为 $\\mathbf{x} = [s, v, T]^\\top$，其中 $s$ 是荷电状态，$v$ 是RC支路电容器电压，$T$ 是电芯温度。输入是电流 $\\mathbf{u} = I$。连续时间动态由 $\\dot{\\mathbf{x}} = \\mathbf{f}(\\mathbf{x}, \\mathbf{u})$ 给出，其中：\n$$\n\\mathbf{f}(\\mathbf{x}, \\mathbf{u}) =\n\\begin{bmatrix}\nf_1(s, v, T, I) \\\\\nf_2(s, v, T, I) \\\\\nf_3(s, v, T, I)\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n-I/Q \\\\\n-\\frac{1}{R_1 C_1} v + \\frac{1}{C_1} I \\\\\n\\frac{1}{C_{\\mathrm{th}}}\\left(R(T) I^2 - hA (T - T_{\\mathrm{amb}})\\right)\n\\end{bmatrix}\n$$\n随温度变化的电阻定义为 $R(T) = R_0 \\exp(\\gamma (T - T_{\\mathrm{ref}}))$。\n\n使用采样周期为 $\\Delta t$ 的前向欧拉法获得离散时间动态：\n$$\n\\mathbf{x}_{k+1} = \\mathbf{g}(\\mathbf{x}_k, \\mathbf{u}_k) = \\mathbf{x}_k + \\Delta t \\, \\mathbf{f}(\\mathbf{x}_k, \\mathbf{u}_k)\n$$\n具体来说，$\\mathbf{g}$ 的分量是：\n$$\n\\mathbf{g}(\\mathbf{x}, \\mathbf{u}) =\n\\begin{bmatrix}\ng_1 \\\\ g_2 \\\\ g_3\n\\end{bmatrix}\n=\n\\begin{bmatrix}\ns - \\frac{\\Delta t}{Q} I \\\\\nv - \\frac{\\Delta t}{R_1 C_1} v + \\frac{\\Delta t}{C_1} I \\\\\nT + \\frac{\\Delta t}{C_{\\mathrm{th}}}\\left(R(T) I^2 - hA (T - T_{\\mathrm{amb}})\\right)\n\\end{bmatrix}\n$$\n\n目标是求出此离散时间映射的雅可比矩阵 $\\mathbf{A}_d = \\partial \\mathbf{g} / \\partial \\mathbf{x}$ 和 $\\mathbf{B}_d = \\partial \\mathbf{g} / \\partial \\mathbf{u}$，并在工作点 $(\\mathbf{x}_0, \\mathbf{u}_0)$ 进行评估。\n\n状态雅可比矩阵 $\\mathbf{A}_d$ 的推导：\n状态雅可比矩阵是一个 $3 \\times 3$ 的矩阵，定义为 $\\mathbf{A}_d = \\partial \\mathbf{g} / \\partial \\mathbf{x}$。使用 $\\mathbf{g}$ 的定义，我们可以写出：\n$$\n\\mathbf{A}_d = \\frac{\\partial}{\\partial \\mathbf{x}} \\left( \\mathbf{x} + \\Delta t \\, \\mathbf{f}(\\mathbf{x}, \\mathbf{u}) \\right) = \\mathbf{I} + \\Delta t \\frac{\\partial \\mathbf{f}(\\mathbf{x}, \\mathbf{u})}{\\partial \\mathbf{x}}\n$$\n其中 $\\mathbf{I}$ 是 $3 \\times 3$ 的单位矩阵。我们必须计算连续时间动态的雅可比矩阵 $\\mathbf{A}_c = \\partial \\mathbf{f} / \\partial \\mathbf{x}$。其元素为 $(\\mathbf{A}_c)_{ij} = \\partial f_i / \\partial x_j$，其中 $\\mathbf{x} = [x_1, x_2, x_3]^\\top = [s, v, T]^\\top$。\n\n偏导数如下：\n$\\frac{\\partial f_1}{\\partial s} = 0$, $\\frac{\\partial f_1}{\\partial v} = 0$, $\\frac{\\partial f_1}{\\partial T} = 0$.\n$\\frac{\\partial f_2}{\\partial s} = 0$, $\\frac{\\partial f_2}{\\partial v} = -\\frac{1}{R_1 C_1}$, $\\frac{\\partial f_2}{\\partial T} = 0$.\n$\\frac{\\partial f_3}{\\partial s} = 0$, $\\frac{\\partial f_3}{\\partial v} = 0$.\n对于关于 $T$ 的导数：\n$$\n\\frac{\\partial f_3}{\\partial T} = \\frac{\\partial}{\\partial T} \\left[ \\frac{1}{C_{\\mathrm{th}}}\\left(R_0 \\exp(\\gamma (T - T_{\\mathrm{ref}})) I^2 - hA (T - T_{\\mathrm{amb}})\\right) \\right]\n$$\n$$\n\\frac{\\partial f_3}{\\partial T} = \\frac{1}{C_{\\mathrm{th}}} \\left( R_0 \\exp(\\gamma (T - T_{\\mathrm{ref}})) \\cdot \\gamma \\cdot I^2 - hA \\right) = \\frac{1}{C_{\\mathrm{th}}} \\left( \\gamma R(T) I^2 - hA \\right)\n$$\n结合这些结果，我们得到连续时间状态雅可比矩阵：\n$$\n\\mathbf{A}_c = \\frac{\\partial \\mathbf{f}}{\\partial \\mathbf{x}} =\n\\begin{bmatrix}\n0   0  0 \\\\\n0   -\\frac{1}{R_1 C_1}   0 \\\\\n0   0  \\frac{1}{C_{\\mathrm{th}}} \\left( \\gamma R(T) I^2 - hA \\right)\n\\end{bmatrix}\n$$\n因此，离散时间状态雅可比矩阵为：\n$$\n\\mathbf{A}_d = \\mathbf{I} + \\Delta t \\mathbf{A}_c =\n\\begin{bmatrix}\n1   0  0 \\\\\n0   1 - \\frac{\\Delta t}{R_1 C_1}   0 \\\\\n0   0  1 + \\frac{\\Delta t}{C_{\\mathrm{th}}} \\left( \\gamma R(T) I^2 - hA \\right)\n\\end{bmatrix}\n$$\n\n输入雅可比矩阵 $\\mathbf{B}_d$ 的推导：\n输入雅可比矩阵是一个 $3 \\times 1$ 的矩阵（向量），定义为 $\\mathbf{B}_d = \\partial \\mathbf{g} / \\partial \\mathbf{u} = \\partial \\mathbf{g} / \\partial I$。\n$$\n\\mathbf{B}_d = \\frac{\\partial}{\\partial I} \\left( \\mathbf{x} + \\Delta t \\, \\mathbf{f}(\\mathbf{x}, \\mathbf{u}) \\right) = \\Delta t \\frac{\\partial \\mathbf{f}(\\mathbf{x}, \\mathbf{u})}{\\partial I}\n$$\n我们计算 $\\mathbf{f}$ 的每个分量相对于 $I$ 的导数：\n$\\frac{\\partial f_1}{\\partial I} = -\\frac{1}{Q}$.\n$\\frac{\\partial f_2}{\\partial I} = \\frac{1}{C_1}$.\n$\\frac{\\partial f_3}{\\partial I} = \\frac{\\partial}{\\partial I} \\left[ \\frac{1}{C_{\\mathrm{th}}}\\left(R(T) I^2 - hA (T - T_{\\mathrm{amb}})\\right) \\right] = \\frac{1}{C_{\\mathrm{th}}} \\left( R(T) \\cdot 2I \\right) = \\frac{2 R(T) I}{C_{\\mathrm{th}}}$.\n\n连续时间输入雅可比矩阵为：\n$$\n\\mathbf{B}_c = \\frac{\\partial \\mathbf{f}}{\\partial I} =\n\\begin{bmatrix}\n-1/Q \\\\\n1/C_1 \\\\\n\\frac{2 R(T) I}{C_{\\mathrm{th}}}\n\\end{bmatrix}\n$$\n离散时间输入雅可比矩阵为：\n$$\n\\mathbf{B}_d = \\Delta t \\mathbf{B}_c =\n\\begin{bmatrix}\n-\\Delta t / Q \\\\\n\\Delta t / C_1 \\\\\n\\frac{2 \\Delta t R(T) I}{C_{\\mathrm{th}}}\n\\end{bmatrix}\n$$\n雅可比矩阵 $\\mathbf{A}_d$ 和 $\\mathbf{B}_d$ 都必须在特定的工作点 $(\\mathbf{x}_0, \\mathbf{u}_0)$ 进行评估，这意味着在表达式中使用 $T=T_0$ 和 $I=I_0$。\n\n实现将对这些推导出的解析公式进行编码，并将其与应用于函数 $\\mathbf{g}(\\mathbf{x}, \\mathbf{u})$ 的中心有限差分近似结果进行比较，从而确认推导的正确性。解析雅可比矩阵与数值雅可比矩阵之间的逐项绝对误差最大值将与给定的公差进行核对。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the battery model Jacobian validation problem.\n    This function defines the model, computes analytic and numerical Jacobians,\n    compares them, and outputs the validation results for a suite of test cases.\n    \"\"\"\n\n    # Define model parameters\n    params = {\n        'Q': 10800.0,      # Nominal capacity (C)\n        'R1': 0.015,       # RC branch resistance (Ohm)\n        'C1': 2000.0,      # RC branch capacitance (F)\n        'R0': 0.02,        # Ohmic resistance base (Ohm)\n        'gamma': 0.01,     # Temperature coefficient for R0 (1/K)\n        'T_ref': 298.15,   # Reference temperature for R0 (K)\n        'C_th': 500.0,     # Thermal capacity (J/K)\n        'hA': 5.0,         # Convective coefficient-area product (W/K)\n        'T_amb': 298.15,   # Ambient temperature (K)\n        'dt': 0.1,         # Sampling period (s)\n    }\n\n    # Define validation parameters\n    validation_params = {\n        'h_x': np.array([1e-6, 1e-6, 1e-6]),  # Perturbations for s, v, T\n        'h_u': 1e-6,                         # Perturbation for I (A)\n        'tol_A': 1e-8,                       # Tolerance for A_d\n        'tol_B': 1e-8,                       # Tolerance for B_d\n    }\n\n    # Define test suite operating points (x0, u0)\n    # x0 = [s, v, T], u0 = I\n    test_cases = [\n        # Case 1 (typical mid-range)\n        (np.array([0.5, 0.0, 298.15]), 10.0),\n        # Case 2 (low temperature boundary)\n        (np.array([0.8, 0.1, 263.15]), 5.0),\n        # Case 3 (charging at elevated temperature)\n        (np.array([0.2, -0.05, 308.15]), -8.0),\n        # Case 4 (no current edge)\n        (np.array([0.9, 0.0, 298.15]), 0.0),\n        # Case 5 (high discharge at high temperature)\n        (np.array([0.1, 0.2, 318.15]), 20.0),\n    ]\n\n    # --- Model Functions ---\n\n    def R_func(T, p):\n        \"\"\"Computes ohmic resistance R(T).\"\"\"\n        return p['R0'] * np.exp(p['gamma'] * (T - p['T_ref']))\n\n    def f_func(x, u, p):\n        \"\"\"Computes continuous-time dynamics dx/dt = f(x, u).\"\"\"\n        s, v, T = x\n        I = u\n        \n        ds_dt = -I / p['Q']\n        dv_dt = -v / (p['R1'] * p['C1']) + I / p['C1']\n        \n        joule_heat = R_func(T, p) * I**2\n        convective_heat = p['hA'] * (T - p['T_amb'])\n        dT_dt = (joule_heat - convective_heat) / p['C_th']\n        \n        return np.array([ds_dt, dv_dt, dT_dt])\n\n    def g_func(x, u, p):\n        \"\"\"Computes discrete-time mapping x_k+1 = g(x_k, u_k) via Forward Euler.\"\"\"\n        return x + p['dt'] * f_func(x, u, p)\n\n    # --- Analytic Jacobian Functions ---\n\n    def compute_Ad_analytic(x, u, p):\n        \"\"\"Computes the analytic discrete-time state Jacobian A_d.\"\"\"\n        _, _, T = x\n        I = u\n        \n        A_d = np.identity(3)\n        A_d[1, 1] = 1.0 - p['dt'] / (p['R1'] * p['C1'])\n        \n        R_T = R_func(T, p)\n        df3_dT = (p['gamma'] * R_T * I**2 - p['hA']) / p['C_th']\n        A_d[2, 2] = 1.0 + p['dt'] * df3_dT\n        \n        return A_d\n\n    def compute_Bd_analytic(x, u, p):\n        \"\"\"Computes the analytic discrete-time input Jacobian B_d.\"\"\"\n        _, _, T = x\n        I = u\n        \n        B_d = np.zeros((3, 1))\n        B_d[0, 0] = -p['dt'] / p['Q']\n        B_d[1, 0] = p['dt'] / p['C1']\n        \n        R_T = R_func(T, p)\n        df3_dI = (2.0 * R_T * I) / p['C_th']\n        B_d[2, 0] = p['dt'] * df3_dI\n        \n        return B_d\n\n    # --- Numerical Jacobian Functions (Central Differences) ---\n\n    def compute_Ad_numeric(x, u, p, vp):\n        \"\"\"Computes the numerical discrete-time state Jacobian A_d.\"\"\"\n        A_d_num = np.zeros((3, 3))\n        h_vec = vp['h_x']\n        for j in range(3):\n            h_j = h_vec[j]\n            e_j = np.zeros(3)\n            e_j[j] = 1.0\n            \n            g_plus = g_func(x + h_j * e_j, u, p)\n            g_minus = g_func(x - h_j * e_j, u, p)\n            \n            A_d_num[:, j] = (g_plus - g_minus) / (2.0 * h_j)\n        return A_d_num\n\n    def compute_Bd_numeric(x, u, p, vp):\n        \"\"\"Computes the numerical discrete-time input Jacobian B_d.\"\"\"\n        h = vp['h_u']\n        \n        g_plus = g_func(x, u + h, p)\n        g_minus = g_func(x, u - h, p)\n        \n        B_d_num = (g_plus - g_minus) / (2.0 * h)\n        return B_d_num.reshape((3, 1))\n\n\n    # --- Main Loop for Validation ---\n    \n    results = []\n    for x0, u0 in test_cases:\n        # Compute analytic Jacobians\n        Ad_analytic = compute_Ad_analytic(x0, u0, params)\n        Bd_analytic = compute_Bd_analytic(x0, u0, params)\n\n        # Compute numerical Jacobians\n        Ad_numeric = compute_Ad_numeric(x0, u0, params, validation_params)\n        Bd_numeric = compute_Bd_numeric(x0, u0, params, validation_params)\n\n        # Validate A_d\n        diff_A = np.max(np.abs(Ad_analytic - Ad_numeric))\n        is_A_valid = diff_A = validation_params['tol_A']\n\n        # Validate B_d\n        diff_B = np.max(np.abs(Bd_analytic - Bd_numeric))\n        is_B_valid = diff_B = validation_params['tol_B']\n\n        # Append result if both validations pass\n        results.append(is_A_valid and is_B_valid)\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "模型预测控制真正的威力体现在其处理多变量、多约束的复杂系统的能力上。本练习将把我们之前学到的建模和控制技能应用于一个高级的、现实世界中的挑战：管理一个多电芯串联的电池包。您将设计一个MPC，它不仅能控制总电流，还能协调各个电芯的均衡电流，以在满足所有电芯电压安全约束的同时，最大限度地提高性能。这个练习将清晰地展示MPC如何在多个执行器和相互冲突的目标之间做出智能权衡，以确保整个电池包的安全和高效运行 。",
            "id": "3928844",
            "problem": "考虑一个串联的三电芯锂离子电池组，其在离散时间预测时域内的动态特性由以下基于电荷守恒、Ohm定律和线性化开路电压图的物理关系建模。每个电芯索引表示为 $i \\in \\{1,2,3\\}$，时间索引表示为 $k \\in \\{0,1,\\dots,N-1\\}$。每个时间步的决策变量是电池组电流 $I_k$ 和每个电芯的均衡（泄放）电流 $b_{i,k}$。净电芯电流为 $I_{i,k} = I_k - b_{i,k}$，其中均衡电流代表在串联电芯串中重新分配电流的旁路驱动。荷电状态 $s_{i,k}$ 根据电荷守恒演变\n$$ s_{i,k+1} = s_{i,k} - \\frac{\\Delta t}{Q_i} I_{i,k} , $$\n其中 $Q_i$ 是电芯容量，$\\Delta t$ 是采样间隔。电芯电压由线性等效电路关系给出\n$$ V_{i,k} = V_{\\mathrm{oc},i}(s_{i,k}) - R_i I_{i,k} , \\quad V_{\\mathrm{oc},i}(s) = \\alpha_i + \\beta_i s, $$\n其中 $R_i$ 是内阻，$\\alpha_i$ 是开路电压关于荷电状态的截距，$\\beta_i$ 是斜率。\n\n模型预测控制（MPC）寻求一个序列 $\\{I_k, b_{1,k}, b_{2,k}, b_{3,k}\\}_{k=0}^{N-1}$，以在电压安全约束和执行器边界的条件下最小化一个凸目标函数。约束强制要求\n$$ V_{\\min} \\le V_{i,k} \\le V_{\\max}, \\quad 0 \\le b_{i,k} \\le b_{\\max}, \\quad 0 \\le I_k \\le I_{\\max} , $$\n对所有的 $i,k$ 均成立。要最小化的目标函数是\n$$ J = \\sum_{k=0}^{N-1} \\left( w_{\\mathrm{track}} (I_k - I^{\\mathrm{ref}}_k)^2 + w_{\\mathrm{bleed}} \\sum_{i=1}^{3} b_{i,k}^2 + w_{\\mathrm{slew}} (I_k - I_{k-1})^2 \\right), $$\n约定 $I_{-1} = I_0$。此处 $I^{\\mathrm{ref}}_k$ 是一个给定的负载电流参考序列。均衡电流在目标函数中受到惩罚，以体现可行性恢复和损耗增加之间的权衡。\n\n你的任务是实现一个MPC，对每个提供的测试用例，计算一个最优序列 $\\{I_k, b_{1,k}, b_{2,k}, b_{3,k}\\}$，在所述约束和动态特性条件下最小化 $J$。从最优解中计算：\n- 一个可行性布尔值，指示是否所有电压约束 $V_{\\min} \\le V_{i,k} \\le V_{\\max}$ 都在 $10^{-6}$ 的数值容差内对所有 $i,k$ 满足。\n- 以安培为单位的均方根跟踪误差，定义为\n$$ \\mathrm{RMS} = \\sqrt{\\frac{1}{N} \\sum_{k=0}^{N-1} (I_k - I^{\\mathrm{ref}}_k)^2} \\quad \\text{(express in $\\mathrm{A}$)}. $$\n- 在整个时域内以焦耳为单位的总泄放能量，\n$$ E_{\\mathrm{bleed}} = \\sum_{k=0}^{N-1} \\sum_{i=1}^{3} V_{i,k} \\, b_{i,k} \\, \\Delta t \\quad \\text{(express in $\\mathrm{J}$)}. $$\n\n设计你的程序来处理以下参数值的测试套件，其中包括一个通用案例和针对边界行为的边缘案例：\n\n测试用例 1（均衡，理想路径）：\n- $N = 8$, $\\Delta t = 1.0 \\, \\mathrm{s}$, $I_{\\max} = 6.0 \\, \\mathrm{A}$, $b_{\\max} = 0.5 \\, \\mathrm{A}$.\n- $Q_1 = Q_2 = Q_3 = 3600.0 \\, \\mathrm{A}\\cdot\\mathrm{s}$, $R_1 = R_2 = R_3 = 0.01 \\, \\Omega$.\n- $\\alpha_1 = \\alpha_2 = \\alpha_3 = 3.0 \\, \\mathrm{V}$, $\\beta_1 = \\beta_2 = \\beta_3 = 1.2 \\, \\mathrm{V}$.\n- $V_{\\min} = 3.0 \\, \\mathrm{V}$, $V_{\\max} = 4.2 \\, \\mathrm{V}$.\n- 初始状态 $s_{1,0} = s_{2,0} = s_{3,0} = 0.6$.\n- 参考值 $I^{\\mathrm{ref}}_k = 3.0 \\, \\mathrm{A}$ 对所有 $k$.\n- 权重 $w_{\\mathrm{track}} = 10.0$, $w_{\\mathrm{bleed}} = 0.1$, $w_{\\mathrm{slew}} = 0.01$.\n\n测试用例 2（一个电芯在无均衡时达到电压下限；通过均衡恢复可行性）：\n- $N = 8$, $\\Delta t = 1.0 \\, \\mathrm{s}$, $I_{\\max} = 6.0 \\, \\mathrm{A}$, $b_{\\max} = 2.0 \\, \\mathrm{A}$.\n- $Q_1 = Q_2 = Q_3 = 3600.0 \\, \\mathrm{A}\\cdot\\mathrm{s}$, $R_1 = 0.05 \\, \\Omega$, $R_2 = R_3 = 0.01 \\, \\Omega$.\n- $\\alpha_1 = \\alpha_2 = \\alpha_3 = 3.0 \\, \\mathrm{V}$, $\\beta_1 = \\beta_2 = \\beta_3 = 1.2 \\, \\mathrm{V}$.\n- $V_{\\min} = 3.0 \\, \\mathrm{V}$, $V_{\\max} = 4.2 \\, \\mathrm{V}$.\n- 初始状态 $s_{1,0} = 0.2$, $s_{2,0} = 0.5$, $s_{3,0} = 0.5$.\n- 参考值 $I^{\\mathrm{ref}}_k = 6.0 \\, \\mathrm{A}$ 对所有 $k$.\n- 权重 $w_{\\mathrm{track}} = 10.0$, $w_{\\mathrm{bleed}} = 0.1$, $w_{\\mathrm{slew}} = 0.01$.\n\n测试用例 3（均衡不足；通过降低电池组电流恢复可行性）：\n- $N = 8$, $\\Delta t = 1.0 \\, \\mathrm{s}$, $I_{\\max} = 6.0 \\, \\mathrm{A}$, $b_{\\max} = 0.2 \\, \\mathrm{A}$.\n- $Q_1 = Q_2 = Q_3 = 3600.0 \\, \\mathrm{A}\\cdot\\mathrm{s}$, $R_1 = 0.05 \\, \\Omega$, $R_2 = R_3 = 0.01 \\, \\Omega$.\n- $\\alpha_1 = \\alpha_2 = \\alpha_3 = 3.0 \\, \\mathrm{V}$, $\\beta_1 = \\beta_2 = \\beta_3 = 1.2 \\, \\mathrm{V}$.\n- $V_{\\min} = 3.0 \\, \\mathrm{V}$, $V_{\\max} = 4.2 \\, \\mathrm{V}$.\n- 初始状态 $s_{1,0} = 0.2$, $s_{2,0} = 0.5$, $s_{3,0} = 0.5$.\n- 参考值 $I^{\\mathrm{ref}}_k = 6.0 \\, \\mathrm{A}$ 对所有 $k$.\n- 权重 $w_{\\mathrm{track}} = 1.0$, $w_{\\mathrm{bleed}} = 0.1$, $w_{\\mathrm{slew}} = 0.01$.\n\n对于每个测试用例，实现一个MPC求解器，使用数值优化来计算最优控制序列。然后计算可行性布尔值、以 $\\mathrm{A}$ 为单位的均方根跟踪误差和以 $\\mathrm{J}$ 为单位的总泄放能量。\n\n最终输出格式：你的程序应生成单行输出，包含用方括号括起来的逗号分隔列表形式的结果。每个测试用例的结果本身必须是 $[ \\text{可行性布尔值}, \\text{以A为单位的RMS跟踪误差}, \\text{以J为单位的泄放能量} ]$ 的列表形式。例如，输出必须是 $[[\\text{布尔值},\\text{浮点数},\\text{浮点数}],[\\text{布尔值},\\text{浮点数},\\text{浮点数}],[\\text{布尔值},\\text{浮点数},\\text{浮点数}]]$ 的形式，不得有任何附加文本。",
            "solution": "用户提供了一个在电池管理系统最优控制领域中定义明确的问题。该问题在科学上基于成熟的电池建模原理，并被表述为一个凸优化问题，具体来说是一个二次规划（QP）问题，这保证了其有唯一解。所有参数和条件都已明确指定，测试用例旨在探究控制器的不同工作状态。该问题是有效的。\n\n任务是为串联的三电芯电池组实现一个模型预测控制器（MPC）。MPC必须在长度为N的预测时域内找到电池组电流 $\\{I_k\\}_{k=0}^{N-1}$ 和各电芯均衡电流 $\\{b_{i,k}\\}_{k=0}^{N-1}$ 的最优序列。最优性通过最小化二次成本函数 $J$ 来定义，并受限于一组代表电池动态特性、电压安全限制和执行器能力的线性约束。\n\n该问题被构造为一个标准的凸QP，可表示为以下形式：\n$$ \\min_{x} \\frac{1}{2} x^T H x + f^T x \\quad \\text{subject to} \\quad A x \\le b $$\n此处，决策向量 $x$ 是一个扁平化向量，包含整个时域内的所有决策变量：\n$$ x = [I_0, \\dots, I_{N-1}, b_{1,0}, \\dots, b_{1,N-1}, b_{2,0}, \\dots, b_{2,N-1}, b_{3,0}, \\dots, b_{3,N-1}]^T $$\n决策变量总数为 $4N$。\n\n要最小化的目标函数是：\n$$ J = \\sum_{k=0}^{N-1} \\left( w_{\\mathrm{track}} (I_k - I^{\\mathrm{ref}}_k)^2 + w_{\\mathrm{bleed}} \\sum_{i=1}^{3} b_{i,k}^2 + w_{\\mathrm{slew}} (I_k - I_{k-1})^2 \\right) $$\n约定 $I_{-1} = I_0$。这个约定意味着第一步的转换速率惩罚项 $(I_0 - I_{-1})^2$ 为零，因此有效的转换速率项是 $\\sum_{k=1}^{N-1} w_{\\mathrm{slew}} (I_k - I_{k-1})^2$。由于所有权重（$w_{\\mathrm{track}}, w_{\\mathrm{bleed}}, w_{\\mathrm{slew}}$）均为正，成本函数 $J$ 是关于决策向量 $x$ 的一个严格凸二次函数。\n\n所有约束相对于决策变量都是线性的。荷电状态（SOC）动态特性由下式给出：\n$$ s_{i,k+1} = s_{i,k} - \\frac{\\Delta t}{Q_i} (I_k - b_{i,k}) $$\n通过展开这个递推关系，任何时间步 $k$ 的状态 $s_{i,k}$ 都可以表示为初始状态 $s_{i,0}$ 和决策变量 $\\{I_j, b_{i,j}\\}_{j=0}^{k-1}$ 的线性函数：\n$$ s_{i,k} = s_{i,0} - \\frac{\\Delta t}{Q_i} \\sum_{j=0}^{k-1} (I_j - b_{i,j}) $$\n电芯电压 $V_{i,k}$ 也是决策变量的线性函数，通过将 $s_{i,k}$ 的表达式代入电压方程得到：\n$$ V_{i,k} = \\alpha_i + \\beta_i s_{i,k} - R_i (I_k - b_{i,k}) $$\n$$ V_{i,k} = \\alpha_i + \\beta_i \\left( s_{i,0} - \\frac{\\Delta t}{Q_i} \\sum_{j=0}^{k-1} (I_j - b_{i,j}) \\right) - R_i (I_k - b_{i,k}) $$\n因此，电压约束 $V_{\\min} \\le V_{i,k} \\le V_{\\max}$ 和执行器边界 $0 \\le I_k \\le I_{\\max}$，$0 \\le b_{i,k} \\le b_{\\max}$ 都是关于 $x$ 的线性不等式约束。\n\nQP问题使用带有‘SLSQP’（序列最小二乘规划）方法的 `scipy.optimize.minimize` 函数求解，该方法非常适合约束非线性优化，并且对QP问题效率很高。实现过程包括：\n1.  为给定的决策向量 $x$ 定义一个计算 $J$ 的目标函数。\n2.  定义一组形式为 $g(x) \\ge 0$ 的不等式约束函数。这些函数从电压限制导出：$V_{i,k} - V_{\\min} \\ge 0$ 和 $V_{\\max} - V_{i,k} \\ge 0$。\n3.  根据 $I_k$ 和 $b_{i,k}$ 的限制为 $x$ 的每个元素定义盒式约束（边界）。\n4.  为优化器提供一个初始猜测值。一个合理的选择是将电池组电流设置为参考电流，并将所有均衡电流设置为零。\n\n优化得到最优决策向量 $x^*$ 后，计算电流（$I_k^*, b_{i,k}^*$）、状态（$s_{i,k}^*$）和电压（$V_{i,k}^*$）的最优轨迹。从这些轨迹中，为每个测试用例计算以下三个输出指标：\n1.  **可行性**：执行一次布尔检查，以确认是否所有电压约束 $V_{\\min} \\le V_{i,k}^* \\le V_{\\max}$ 都在 $10^{-6}$ 的数值容差内对所有电芯 $i$ 和时间步 $k$ 满足。\n2.  **RMS跟踪误差**：计算最优电池组电流 $I_k^*$ 与参考电流 $I_k^{\\mathrm{ref}}$ 之间的均方根误差。\n3.  **总泄放能量**：通过在所有电芯和整个时域内对电芯电压、均衡电流和时间步长的乘积求和来计算均衡电路消耗的总能量：$E_{\\mathrm{bleed}} = \\sum_{k,i} V_{i,k}^* b_{i,k}^* \\Delta t$。\n\n对提供的三个测试用例中的每一个重复整个过程，并将结果汇总成指定的输出格式。",
            "answer": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef run_mpc_for_case(params):\n    \"\"\"\n    Solves the MPC optimization problem for a single test case.\n    \"\"\"\n    # Unpack parameters\n    N = params['N']\n    dt = params['dt']\n    I_max = params['I_max']\n    b_max = params['b_max']\n    Q = params['Q']\n    R = params['R']\n    alpha = params['alpha']\n    beta = params['beta']\n    Vmin = params['Vmin']\n    Vmax = params['Vmax']\n    s0 = params['s0']\n    I_ref = params['I_ref']\n    w_track = params['w_track']\n    w_bleed = params['w_bleed']\n    w_slew = params['w_slew']\n    \n    num_vars = 4 * N\n\n    # Objective function J(x)\n    def objective(x):\n        I = x[0:N]\n        b = np.reshape(x[N:], (3, N))\n        \n        tracking_cost = w_track * np.sum((I - I_ref)**2)\n        bleed_cost = w_bleed * np.sum(b**2)\n        slew_cost = w_slew * np.sum((I[1:] - I[:-1])**2)\n        \n        return tracking_cost + bleed_cost + slew_cost\n\n    # Inequality constraints: V_min = V_ik = V_max\n    def constraints(x):\n        I = x[0:N]\n        b = np.reshape(x[N:], (3, N))\n        I_cell = I[np.newaxis, :] - b # Broadcasting to (3, N)\n\n        # Calculate SOC trajectory s_i,k for k=0..N\n        # We need s up to k=N for V up to N-1\n        s = np.zeros((3, N + 1))\n        s[:, 0] = s0\n        for k in range(N):\n            s[:, k + 1] = s[:, k] - (dt / Q) * I_cell[:, k]\n\n        # Calculate voltage trajectory V_i,k for k=0..N-1\n        # V_i,k depends on s_i,k\n        Voc = alpha[:, np.newaxis] + beta[:, np.newaxis] * s[:, :-1]\n        V = Voc - R[:, np.newaxis] * I_cell\n    \n        # Constraints are g(x) >= 0\n        # V_ik - Vmin >= 0  and  Vmax - V_ik >= 0\n        c1 = V - Vmin\n        c2 = Vmax - V\n        \n        return np.concatenate([c1.flatten(), c2.flatten()])\n\n    # Bounds for decision variables\n    bounds = []\n    bounds.extend([(0, I_max)] * N)       # I_k bounds\n    bounds.extend([(0, b_max)] * (3 * N))  # b_ik bounds\n\n    # Initial guess for x\n    x0 = np.zeros(num_vars)\n    x0[0:N] = np.clip(I_ref, 0, I_max)\n\n    # Solve the QP\n    res = minimize(\n        objective,\n        x0,\n        method='SLSQP',\n        bounds=bounds,\n        constraints={'type': 'ineq', 'fun': constraints},\n        options={'disp': False, 'ftol': 1e-9, 'maxiter': 200}\n    )\n    \n    x_opt = res.x\n    I_opt = x_opt[0:N]\n    b_opt = np.reshape(x_opt[N:], (3, N))\n\n    # Re-compute optimal trajectories to calculate final metrics\n    I_cell_opt = I_opt[np.newaxis, :] - b_opt\n    \n    s_opt = np.zeros((3, N + 1))\n    s_opt[:, 0] = s0\n    for k in range(N):\n        s_opt[:, k + 1] = s_opt[:, k] - (dt / Q) * I_cell_opt[:, k]\n        \n    Voc_opt = alpha[:, np.newaxis] + beta[:, np.newaxis] * s_opt[:, :-1]\n    V_opt = Voc_opt - R[:, np.newaxis] * I_cell_opt\n\n    # 1. Feasibility check\n    tol = 1e-6\n    feasible = np.all(V_opt >= Vmin - tol) and np.all(V_opt = Vmax + tol)\n    \n    # 2. RMS tracking error\n    rms_error = np.sqrt(np.mean((I_opt - I_ref)**2))\n    \n    # 3. Total bleed energy\n    bleed_energy = np.sum(V_opt * b_opt * dt)\n    \n    return [feasible, rms_error, bleed_energy]\n\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        {\n            \"N\": 8, \"dt\": 1.0, \"I_max\": 6.0, \"b_max\": 0.5,\n            \"Q\": np.array([3600.0, 3600.0, 3600.0]),\n            \"R\": np.array([0.01, 0.01, 0.01]),\n            \"alpha\": np.array([3.0, 3.0, 3.0]),\n            \"beta\": np.array([1.2, 1.2, 1.2]),\n            \"Vmin\": 3.0, \"Vmax\": 4.2,\n            \"s0\": np.array([0.6, 0.6, 0.6]),\n            \"I_ref\": np.full(8, 3.0),\n            \"w_track\": 10.0, \"w_bleed\": 0.1, \"w_slew\": 0.01,\n        },\n        {\n            \"N\": 8, \"dt\": 1.0, \"I_max\": 6.0, \"b_max\": 2.0,\n            \"Q\": np.array([3600.0, 3600.0, 3600.0]),\n            \"R\": np.array([0.05, 0.01, 0.01]),\n            \"alpha\": np.array([3.0, 3.0, 3.0]),\n            \"beta\": np.array([1.2, 1.2, 1.2]),\n            \"Vmin\": 3.0, \"Vmax\": 4.2,\n            \"s0\": np.array([0.2, 0.5, 0.5]),\n            \"I_ref\": np.full(8, 6.0),\n            \"w_track\": 10.0, \"w_bleed\": 0.1, \"w_slew\": 0.01,\n        },\n        {\n            \"N\": 8, \"dt\": 1.0, \"I_max\": 6.0, \"b_max\": 0.2,\n            \"Q\": np.array([3600.0, 3600.0, 3600.0]),\n            \"R\": np.array([0.05, 0.01, 0.01]),\n            \"alpha\": np.array([3.0, 3.0, 3.0]),\n            \"beta\": np.array([1.2, 1.2, 1.2]),\n            \"Vmin\": 3.0, \"Vmax\": 4.2,\n            \"s0\": np.array([0.2, 0.5, 0.5]),\n            \"I_ref\": np.full(8, 6.0),\n            \"w_track\": 1.0, \"w_bleed\": 0.1, \"w_slew\": 0.01,\n        },\n    ]\n\n    all_results = []\n    for case_params in test_cases:\n        # Correct the size of s0 if it's a single value\n        if isinstance(case_params['s0'], (int, float)):\n            case_params['s0'] = np.full(3, case_params['s0'])\n        result = run_mpc_for_case(case_params)\n        all_results.append(result)\n\n    formatted_results = []\n    for res in all_results:\n        # Convert boolean to string 'True'/'False'\n        bool_val_str = str(res[0])\n        # Format the result list as a string\n        formatted_results.append(f\"[{bool_val_str},{res[1]},{res[2]}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}