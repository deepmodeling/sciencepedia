{
    "hands_on_practices": [
        {
            "introduction": "在深入研究涂布和干燥的复杂动力学之前，我们必须首先表征电池浆料的基本性质。本练习侧重于根据浆料的组成成分计算其密度，这是一个决定流动行为并对精确过程控制至关重要的参数。通过运用理想体积可加性原则，您将推导并应用混合物定则，这是材料工程中的一个基础工具 。",
            "id": "3927885",
            "problem": "在用于锂离子（Li-ion）正极制造的连续狭缝式涂布线上，一种由活性材料颗粒、聚合物粘合剂和有机溶剂组成的浆料被计量输送，以达到目标湿膜厚度。精确的浆料密度是必需的，以便将体积流量转换为质量流量，并预测模头内的流体动压。考虑一个分散良好的三元浆料，其质量分数 $w_{\\text{active}}$、$w_{\\text{binder}}$ 和 $w_{\\text{solvent}}$ 之和为 $1$，各组分密度分别为 $\\rho_{\\text{active}}$、$\\rho_{\\text{binder}}$ 和 $\\rho_{\\text{solvent}}$。假设为等温条件、夹带空气可忽略不计以及理想体积可加性（无混合超额体积），这与初级颗粒孔隙度尺度上的不可压缩悬浮液的假设一致。从密度和比容的基本定义以及质量守恒定律出发。在这些基础上，推导在所述假设下浆料密度 $\\rho_{\\text{slurry}}$ 的表达式。然后，对于一种由氧化物活性材料、聚偏氟乙烯 (polyvinylidene fluoride, PVDF) 粘合剂和一种有机溶剂组成的浆料，当\n$w_{\\text{active}}=0.6$，$w_{\\text{binder}}=0.05$，$w_{\\text{solvent}}=0.35$ 且 $\\rho_{\\text{active}}=4.9\\,\\text{g/cm}^3$，$\\rho_{\\text{binder}}=1.2\\,\\text{g/cm}^3$，$\\rho_{\\text{solvent}}=0.9\\,\\text{g/cm}^3$ 时，计算该表达式的值。将最终答案四舍五入至四位有效数字，并以 $\\text{g/cm}^3$ 为单位表示。",
            "solution": "问题陈述已经过验证，被认为是有效的。它具有科学依据，提法明确，并包含推导唯一解所需的所有必要信息。\n\n任务是推导三元浆料密度 $\\rho_{\\text{slurry}}$ 的表达式，然后计算其在特定组分下的值。推导将基于质量守恒的基本原理和理想体积可加性的假设。\n\n设 $M_{\\text{slurry}}$ 和 $V_{\\text{slurry}}$ 分别为浆料样品的总质量和总体积。浆料的密度定义为其质量与体积之比：\n$$\n\\rho_{\\text{slurry}} = \\frac{M_{\\text{slurry}}}{V_{\\text{slurry}}}\n$$\n比容 $v_{\\text{slurry}}$ 是密度的倒数：\n$$\nv_{\\text{slurry}} = \\frac{1}{\\rho_{\\text{slurry}}} = \\frac{V_{\\text{slurry}}}{M_{\\text{slurry}}}\n$$\n浆料是三种组分的混合物：活性材料、粘合剂和溶剂。设下标 'active'、'binder' 和 'solvent' 分别表示相应的组分。\n\n根据质量守恒原理，浆料的总质量是其各组分质量之和：\n$$\nM_{\\text{slurry}} = M_{\\text{active}} + M_{\\text{binder}} + M_{\\text{solvent}}\n$$\n组分 $i$ 的质量分数 $w_i$ 定义为该组分的质量 $M_i$ 与混合物总质量 $M_{\\text{slurry}}$ 之比：\n$$\nw_i = \\frac{M_i}{M_{\\text{slurry}}}\n$$\n因此，各组分的质量可以表示为 $M_i = w_i M_{\\text{slurry}}$。\n\n问题陈述要求假设理想体积可加性。这意味着混合物的总体积是其各组分体积之和。这是假设无混合超额体积（$V^{\\text{E}} = 0$）和无夹带气体的直接结果。\n$$\nV_{\\text{slurry}} = V_{\\text{active}} + V_{\\text{binder}} + V_{\\text{solvent}}\n$$\n每个组分的体积 $V_i$ 可以用其质量 $M_i$ 和密度 $\\rho_i$ 表示为 $V_i = M_i / \\rho_i$。将此代入体积可加性方程，得到：\n$$\nV_{\\text{slurry}} = \\frac{M_{\\text{active}}}{\\rho_{\\text{active}}} + \\frac{M_{\\text{binder}}}{\\rho_{\\text{binder}}} + \\frac{M_{\\text{solvent}}}{\\rho_{\\text{solvent}}}\n$$\n现在，我们可以将各组分质量的表达式（$M_i = w_i M_{\\text{slurry}}$）代入 $V_{\\text{slurry}}$ 的方程中：\n$$\nV_{\\text{slurry}} = \\frac{w_{\\text{active}} M_{\\text{slurry}}}{\\rho_{\\text{active}}} + \\frac{w_{\\text{binder}} M_{\\text{slurry}}}{\\rho_{\\text{binder}}} + \\frac{w_{\\text{solvent}} M_{\\text{slurry}}}{\\rho_{\\text{solvent}}}\n$$\n为了求得浆料密度的表达式，我们可以将 $V_{\\text{slurry}}$ 的这个表达式代入比容的定义 $v_{\\text{slurry}} = V_{\\text{slurry}}/M_{\\text{slurry}}$ 中：\n$$\n\\frac{1}{\\rho_{\\text{slurry}}} = \\frac{1}{M_{\\text{slurry}}} \\left( \\frac{w_{\\text{active}} M_{\\text{slurry}}}{\\rho_{\\text{active}}} + \\frac{w_{\\text{binder}} M_{\\text{slurry}}}{\\rho_{\\text{binder}}} + \\frac{w_{\\text{solvent}} M_{\\text{slurry}}}{\\rho_{\\text{solvent}}} \\right)\n$$\n$M_{\\text{slurry}}$ 项被消掉，得到浆料比容与各组分比容的质量分数加权和的关系：\n$$\n\\frac{1}{\\rho_{\\text{slurry}}} = \\frac{w_{\\text{active}}}{\\rho_{\\text{active}}} + \\frac{w_{\\text{binder}}}{\\rho_{\\text{binder}}} + \\frac{w_{\\text{solvent}}}{\\rho_{\\text{solvent}}}\n$$\n这是理想混合物密度混合法则的一般形式。为了得到 $\\rho_{\\text{slurry}}$ 的表达式，我们对等式两边取倒数：\n$$\n\\rho_{\\text{slurry}} = \\left( \\frac{w_{\\text{active}}}{\\rho_{\\text{active}}} + \\frac{w_{\\text{binder}}}{\\rho_{\\text{binder}}} + \\frac{w_{\\text{solvent}}}{\\rho_{\\text{solvent}}} \\right)^{-1}\n$$\n这就是推导出的浆料密度表达式。\n\n接下来，我们使用给定的数值来计算这个表达式：\n- 质量分数：$w_{\\text{active}} = 0.6$，$w_{\\text{binder}} = 0.05$，$w_{\\text{solvent}} = 0.35$。\n- 组分密度：$\\rho_{\\text{active}} = 4.9\\,\\text{g/cm}^3$，$\\rho_{\\text{binder}} = 1.2\\,\\text{g/cm}^3$，$\\rho_{\\text{solvent}} = 0.9\\,\\text{g/cm}^3$。\n\n我们首先计算分母中的各项：\n$$\n\\frac{w_{\\text{active}}}{\\rho_{\\text{active}}} = \\frac{0.6}{4.9}\\,\\text{cm}^3/\\text{g}\n$$\n$$\n\\frac{w_{\\text{binder}}}{\\rho_{\\text{binder}}} = \\frac{0.05}{1.2}\\,\\text{cm}^3/\\text{g}\n$$\n$$\n\\frac{w_{\\text{solvent}}}{\\rho_{\\text{solvent}}} = \\frac{0.35}{0.9}\\,\\text{cm}^3/\\text{g}\n$$\n现在，我们计算这些项的和：\n$$\n\\frac{1}{\\rho_{\\text{slurry}}} = \\left( \\frac{0.6}{4.9} + \\frac{0.05}{1.2} + \\frac{0.35}{0.9} \\right)\\,\\text{cm}^3/\\text{g}\n$$\n$$\n\\frac{1}{\\rho_{\\text{slurry}}} \\approx (0.122448979... + 0.041666666... + 0.388888888...)\\,\\text{cm}^3/\\text{g}\n$$\n$$\n\\frac{1}{\\rho_{\\text{slurry}}} \\approx 0.553004534... \\,\\text{cm}^3/\\text{g}\n$$\n最后，我们通过取倒数来计算 $\\rho_{\\text{slurry}}$：\n$$\n\\rho_{\\text{slurry}} = \\frac{1}{0.553004534...} \\,\\text{g/cm}^3\n$$\n$$\n\\rho_{\\text{slurry}} \\approx 1.80830405... \\,\\text{g/cm}^3\n$$\n问题要求答案四舍五入到四位有效数字。\n$$\n\\rho_{\\text{slurry}} \\approx 1.808 \\,\\text{g/cm}^3\n$$",
            "answer": "$$\\boxed{1.808}$$"
        },
        {
            "introduction": "在确定了浆料的性质之后，我们现在转向涂布过程，在此过程中，工艺参数直接决定了初始涂层的结构。本练习将演示如何从设备的体积流量和基材的线速度出发，预测最终的干电极厚度——一个关键的质量指标。此实践练习阐明了应用守恒定律的威力：首先是对总流体体积应用守恒以确定湿膜厚度，然后是对固相体积应用守恒以计算干燥过程中的收缩 。",
            "id": "3927879",
            "problem": "一台缝模涂布机将锂离子电池正极浆料涂覆在移动的铝箔基底上。体积流量在整个模唇上是均匀的，等于 $Q = 20\\,\\text{mL/min}$。涂层宽度为 $b = 100\\,\\text{mm}$，基底以恒定的线速度 $U = 0.5\\,\\text{m/s}$ 移动。浆料在涂覆点的固相体积分数为 $\\phi_{s} = 0.45$。在干燥过程中，溶剂被完全去除，最终的电极呈现出均匀的孔隙率 $\\varepsilon_{f} = 0.35$。假设如下：\n- 基底是不可渗透的，浆料不会渗入基底。\n- 涂层在宽度 $b$ 上和沿机器方向上是横向均匀的，没有边缘效应。\n- 在干燥过程中，固体是不可压缩的，并且没有横向收缩；任何厚度变化都仅由溶剂的去除和孔隙的出现引起。\n- 固相体积守恒适用于湿法沉积和干燥电极之间。\n\n从适用于连续涂布的守恒和运动学原理出发，确定湿膜厚度，然后预测干燥至孔隙率 $\\varepsilon_{f}$ 后的最终干膜厚度。仅报告预测的最终干膜厚度。以微米为单位表示您的答案，并四舍五入到四位有效数字。",
            "solution": "合适的出发点是体积流量守恒和移动基底的运动学。模头提供一个体积流量 $Q$，该流量均匀地分布在涂层宽度 $b$ 上。这定义了一个面体积通量\n$$\nq'' \\equiv \\frac{\\text{体积}}{\\text{面积}\\cdot \\text{时间}} = \\frac{Q}{b}.\n$$\n基底以速度 $U$ 平移，因此单位时间内通过模头下方的面积为 $bU$。沉积的湿膜厚度 $h_{w}$ 可通过将体积沉积速率与面积速率和厚度的乘积相等来得出，这是移动基底上均匀薄膜的连续性运动学表述：\n$$\nQ = (bU) h_{w} \\quad \\Rightarrow \\quad h_{w} = \\frac{Q}{bU}.\n$$\n\n接下来，在整个干燥过程中应用固相守恒。沉积时的浆料具有固相体积分数 $\\phi_{s}$，因此湿膜中单位基底面積的固相体积为\n$$\nV_{s,\\text{per area}} = \\phi_{s} h_{w}.\n$$\n干燥后，最终电极的孔隙率为 $\\varepsilon_{f}$，这意味着固相占据最终薄膜体积的 $(1 - \\varepsilon_{f})$ 部分。如果 $h_{d}$ 是最终干膜厚度，则干膜中单位面积的固相体积为\n$$\n(1 - \\varepsilon_{f}) h_{d}.\n$$\n湿态和干态之间的固相体积守恒得出\n$$\n\\phi_{s} h_{w} = (1 - \\varepsilon_{f}) h_{d} \\quad \\Rightarrow \\quad h_{d} = \\frac{\\phi_{s}}{1 - \\varepsilon_{f}} \\, h_{w}.\n$$\n\n现在代入给定的数值，并将单位统一转换为国际单位制（SI）。首先，将 $Q$ 从毫升/分钟转换为立方米/秒。使用 $1\\,\\text{mL} = 1 \\times 10^{-6}\\,\\text{m}^{3}$ 和 $1\\,\\text{min} = 60\\,\\text{s}$，\n$$\nQ = 20\\,\\text{mL/min} = 20 \\times 10^{-6}\\,\\text{m}^{3}\\!/\\text{min} = \\frac{20 \\times 10^{-6}}{60}\\,\\text{m}^{3}\\!/\\text{s} = \\frac{1}{3} \\times 10^{-6}\\,\\text{m}^{3}\\!/\\text{s}.\n$$\n将 $b$ 从毫米转换为米：\n$$\nb = 100\\,\\text{mm} = 0.1\\,\\text{m}.\n$$\n线速度已经是国际单位制：\n$$\nU = 0.5\\,\\text{m/s}.\n$$\n计算湿膜厚度：\n$$\nh_{w} = \\frac{Q}{bU} = \\frac{\\frac{1}{3} \\times 10^{-6}}{0.1 \\times 0.5}\\,\\text{m} = \\frac{\\frac{1}{3} \\times 10^{-6}}{0.05}\\,\\text{m} = \\left(\\frac{1}{3} \\times 10^{-6}\\right) \\times 20\\,\\text{m} = \\frac{20}{3} \\times 10^{-6}\\,\\text{m} \\approx 6.666\\overline{6} \\times 10^{-6}\\,\\text{m}.\n$$\n应用固相体积守恒来获得干膜厚度：\n$$\nh_{d} = \\frac{\\phi_{s}}{1 - \\varepsilon_{f}} \\, h_{w} = \\frac{0.45}{1 - 0.35} \\, h_{w} = \\frac{0.45}{0.65} \\, h_{w} = \\left(\\frac{9}{13}\\right) h_{w} \\approx 0.6923077\\, h_{w}.\n$$\n因此，\n$$\nh_{d} \\approx 0.6923077 \\times 6.666\\overline{6} \\times 10^{-6}\\,\\text{m} = 4.6153846 \\times 10^{-6}\\,\\text{m}.\n$$\n使用 $1\\,\\mu\\text{m} = 10^{-6}\\,\\text{m}$ 转换为微米：\n$$\nh_{d} \\approx 4.6153846\\,\\mu\\text{m}.\n$$\n四舍五入到四位有效数字，得出\n$$\nh_{d} \\approx 4.615\\,\\mu\\text{m}.\n$$\n根据题目要求，仅报告预测的最终干膜厚度，单位为微米，并保留四位有效数字。",
            "answer": "$$\\boxed{4.615}$$"
        },
        {
            "introduction": "电极的最终性能关键取决于干燥阶段，在这一阶段，复杂的传输现象可能导致不均匀性。这项高级实践旨在解决优化干燥过程以确保粘结剂均匀分布的挑战，这是影响电池性能和寿命的关键因素。您将实施伴随法 (adjoint method)，这是一种在偏微分方程约束优化中功能强大的技术，用以计算最终粘结剂分布对干燥温度曲线的灵敏度，从而为自动化过程控制开辟一条直接路径 。",
            "id": "3927880",
            "problem": "您的任务是设计并实现一个算法，用于在一个电池电极浆料涂层的一维干燥模型中，计算粘结剂均匀性目标函数相对于空气温度轨迹的梯度。该干燥模型由一个基于质量守恒原理和菲克扩散的平流-扩散偏微分方程 (PDE) 描述，其中空气温度同时控制溶剂流的平流速度和粘结剂的扩散系数。您的程序必须对空间域和时间进行离散化，正向求解状态动力学，反向求解伴随动力学，并为每个测试用例生成目标函数相对于空气温度轨迹的梯度，形式为一个时间离散向量。\n\n基本原理和控制物理：\n- 粘结剂在一维空间中的质量守恒导致了粘结剂浓度 $c(x,t)$ 的守恒定律，\n  $$\\frac{\\partial c}{\\partial t} + \\frac{\\partial J}{\\partial x} = 0,$$\n  其中 $J(x,t)$ 是总的粘结剂通量。\n- 总粘结剂通量 $J$ 是平流和扩散的叠加，\n  $$J(x,t) = u(t)\\,c(x,t) - D(T_a(t))\\,\\frac{\\partial c}{\\partial x}(x,t),$$\n  其中 $u(t)$ 是一个由空气温度轨迹 $T_a(t)$ 控制的有效贯穿厚度的溶剂平流速度，而 $D(T)$ 是通过阿伦尼乌斯(Arrhenius)定律依赖于温度的粘结剂扩散系数。\n- 将两者结合得到平流-扩散偏微分方程，\n  $$\\frac{\\partial c}{\\partial t} + u(t)\\,\\frac{\\partial c}{\\partial x} = \\frac{\\partial}{\\partial x}\\left(D(T_a(t))\\,\\frac{\\partial c}{\\partial x}\\right)。$$\n- 边界条件强制在两个膜表面没有净粘结剂损失，模型化为在 $x=0$ 和 $x=L$ 处的总通量为零，\n  $$J(0,t) = 0, \\quad J(L,t) = 0,$$\n  以及一个空间上均匀的初始条件 $c(x,0)=c_0$。\n\n物理参数化和单位如下：\n- 空间域长度 $L=100\\times 10^{-6}$ 米，一维坐标 $x\\in[0,L]$。\n- 最终时间 $t_f=600$ 秒。\n- 初始粘结剂浓度 $c_0=0.06$ (无量纲质量分数)。\n- 扩散的 Arrhenius 温度依赖性，\n  $$D(T) = D_{\\text{pre}}\\,\\exp\\!\\left(-\\frac{E_a}{R\\,T}\\right),$$\n  其中 $D_{\\text{pre}}=1.0\\times 10^{-7}\\ \\text{m}^2/\\text{s}$，活化能 $E_a=1.5\\times 10^4\\ \\text{J}/\\text{mol}$，通用气体常数 $R=8.314\\ \\text{J}/(\\text{mol}\\cdot\\text{K})$。温度 $T$ 以开尔文为单位。\n- 由高于参考温度 $T_{\\text{ref}}=298\\ \\text{K}$ 的空气温度驱动的平流速度，\n  $$u(t) = k_u\\,\\max\\!\\big(0,\\,T_a(t)-T_{\\text{ref}}\\big),$$\n  其中 $k_u=3.0\\times 10^{-9}\\ \\text{m}/(\\text{s}\\cdot\\text{K})$。\n- 粘结剂均匀性目标函数惩罚最终时刻偏离均匀目标 $c_{\\text{ref}}=0.06$ 的情况，\n  $$J = \\frac{1}{2}\\int_0^L \\big(c(x,t_f)-c_{\\text{ref}}\\big)^2\\,dx.$$\n  $J$ 的单位是浓度的平方（无量纲）乘以米。\n\n您的任务：\n1. 从上述质量守恒定律和通量定义出发，使用变分法对由目标函数和 PDE 约束构成的拉格朗日量进行计算，推导 $J$ 对轨迹 $T_a(t)$ 敏感性的伴随公式。推导时间上反向的伴随 PDE、适当的边界条件和终端条件，以及用状态变量和伴随变量表示的梯度 $\\frac{\\delta J}{\\delta T_a(t)}$ 的表达式。推导过程必须有理有据，从所述的基本原理和参数化出发，不得在未推导的情况下假设或引用目标公式。\n2. 为正向状态设计一个尊重无损失边界条件的数值稳定的时间推进算法。使用有限体积法或有限差分法。对扩散项使用隐式时间步进，对平流项使用显式迎风格式通量。清晰地说明您的离散化选择以及如何在不违反守恒性的情况下处理边界条件。将空间域离散化为 $N_x=101$ 个节点，将时间区间 $[0,t_f]$ 离散化为 $N_t=60$ 个均匀时间步。所有量均以国际单位制（SI）基本单位表示。\n3. 通过转置每个时间步的线性化正向更新来构建离散伴随系统，以将伴随变量在时间上反向传播。使用一致的离散算子以确保梯度与离散目标函数相对应。\n4. 在 Python 中实现该算法，为以下三个测试空气温度轨迹中的每一个计算梯度向量 $\\left[\\frac{\\partial J}{\\partial T_a(t_k)}\\right]_{k=0}^{N_t-1}$，每个轨迹都在均匀时间网格 $t_k=k\\,\\Delta t$ 上离散化，其中 $\\Delta t=t_f/N_t$：\n   - 情况 A (基准常数)：对于所有 $t$，$T_a(t) = 298\\ \\text{K}$。\n   - 情况 B (线性斜坡)：$T_a(t) = 298 + 30\\,\\frac{t}{t_f}\\ \\text{K}$。\n   - 情况 C (正弦调制)：$T_a(t) = 308 + 10\\,\\sin\\left(\\frac{2\\pi t}{t_f}\\right)\\ \\text{K}$。\n5. 最终输出格式：您的程序应生成单行输出，其中包含三个测试用例的结果，格式为方括号括起来的逗号分隔列表，其中每个元素本身是一个包含每个时间步梯度的 $N_t$ 个浮点值的列表。例如，一个包含三个用例且每个用例有 $N_t$ 个条目的输出应如下所示\n   $$\\texttt{[[g\\_A(t\\_0),...,g\\_A(t\\_{N_t-1})],[g\\_B(t\\_0),...,g\\_B(t\\_{N_t-1})],[g\\_C(t\\_0),...,g\\_C(t\\_{N_t-1})]]}.$$\n所有浮点值都应以 SI 基本单位表示（温度用开尔文，空间/时间输入用米/秒）。梯度值的单位是目标函数单位每开尔文，应报告为原始浮点数。不需要用户输入。\n\n测试套件覆盖和边缘条件：\n- 情况 A 测试了在参考温度下平流不活跃的边界条件，因此敏感性仅通过扩散的温度依赖性产生。\n- 情况 B 测试了单调温度升高产生递增的平流和扩散的情况。\n- 情况 C 测试了振荡行为，包括温度变化率符号的改变，而由于最大值算子的存在，平流速度保持非负。\n\n您的实现必须是自包含的，遵守指定的离散化方法，并按指定格式在单行中计算并报告三个情况的梯度。",
            "solution": "用户提供了一个来自自动化电池设计与仿真领域的适定问题陈述，特别关注制造过程建模。任务是在浆料干燥过程中，计算粘结剂均匀性目标函数相对于时变空气温度剖面的梯度。该过程由一个一维平流-扩散偏微分方程 (PDE) 建模。\n\n### 第 1 步：问题验证\n\n根据指定标准对问题进行验证。\n\n-   **提取的已知条件**：\n    -   **PDE**：$\\frac{\\partial c}{\\partial t} + u(t)\\,\\frac{\\partial c}{\\partial x} = \\frac{\\partial}{\\partial x}\\left(D(T_a(t))\\,\\frac{\\partial c}{\\partial x}\\right)$ 对于粘结剂浓度 $c(x,t)$。\n    -   **空间/时间域**：$x \\in [0, L]$，其中 $L=100\\times 10^{-6}$ 米；$t \\in [0, t_f]$，其中 $t_f=600$ 秒。\n    -   **初始条件**：$c(x,0) = c_0 = 0.06$ (均匀)。\n    -   **边界条件**：零通量，$J(x,t) = u(t)c(x,t) - D(T_a(t))\\frac{\\partial c}{\\partial x} = 0$，在 $x=0$ 和 $x=L$ 处。\n    -   **扩散系数**：$D(T) = D_{\\text{pre}}\\,\\exp(-E_a/(RT))$，其中 $D_{\\text{pre}}=1.0\\times 10^{-7}\\ \\text{m}^2/\\text{s}$，$E_a=1.5\\times 10^4\\ \\text{J}/\\text{mol}$，$R=8.314\\ \\text{J}/(\\text{mol}\\cdot\\text{K})$。\n    -   **平流速度**：$u(t) = k_u\\,\\max(0,\\,T_a(t)-T_{\\text{ref}})$，其中 $k_u=3.0\\times 10^{-9}\\ \\text{m}/(\\text{s}\\cdot\\text{K})$ 且 $T_{\\text{ref}}=298\\ \\text{K}$。\n    -   **目标函数**：$J_{\\text{obj}} = \\frac{1}{2}\\int_0^L (c(x,t_f)-c_{\\text{ref}})^2\\,dx$，其中 $c_{\\text{ref}}=0.06$。\n    -   **离散化**：$N_x=101$ 个空间节点，$N_t=60$ 个均匀时间步。\n    -   **数值方法**：扩散项采用隐式时间步进，平流项采用显式迎风格式。\n    -   **测试用例**：$T_a(t)$ 的三个指定轨迹。\n\n-   **验证结论**：\n    -   **有科学依据**：该模型基于基本的平流-扩散方程，这是输运现象的基石。参数化（阿伦尼乌斯定律等）是标准的物理近似。上下文是现实的。\n    -   **适定性**：该问题是一个标准的 PDE 约束优化问题。该 PDE 是抛物线型的，具有明确的初始和边界条件，保证了唯一解的存在。目标函数定义明确。\n    -   **客观性**：问题以精确、定量和无偏见的科学语言陈述。\n    -   **完整性**：解决问题所需的所有必要参数、方程和条件都已提供。\n    -   **一致性**：给定的条件是自洽的。出现一个特定的边缘情况，即 $c(x,0)=c_{ref}$，对于恒定温度 $T_a=T_{ref}$，这会导致一个平凡的状态演化和一个值为零的目标函数。这导致梯度为零，这是一个有效且具有物理意义的结果，而非矛盾。\n\n-   **结论**：该问题被视为 **有效**。我们可以继续进行求解。\n\n### 第 2 步：伴随公式和梯度推导\n\n我们使用拉格朗日乘子法来推导伴随方程和梯度。设 $T_a(t)$ 为控制变量。拉格朗日量 $\\mathcal{L}$ 定义为目标函数加上由伴随变量 $\\lambda(x,t)$ 加权的 PDE 约束：\n$$ \\mathcal{L}[c, T_a, \\lambda] = \\frac{1}{2}\\int_0^L (c(x,t_f)-c_{\\text{ref}})^2\\,dx - \\int_0^{t_f} \\int_0^L \\lambda \\left( \\frac{\\partial c}{\\partial t} + \\frac{\\partial J}{\\partial x} \\right) dx dt $$\n其中 $J(x,t) = u(t)c(x,t) - D(T_a(t))\\frac{\\partial c}{\\partial x}$。\n\n我们要求拉格朗日量相对于状态的变分 $\\delta_c \\mathcal{L}$ 对于任何容许的变分 $\\delta c$ 都为零。这是通过分部积分将导数从 $c$ 转移到 $\\lambda$ 来实现的。边界条件 $J(0,t)=J(L,t)=0$ 导致涉及 $J$ 的空间边界项在分部积分过程中消失。此过程产生定义了 $\\lambda(x,t)$ 的伴随系统：\n\n1.  **伴随 PDE**：一个时间反向的平流-扩散方程。与正向 PDE 相比，空间算子的符号相反。\n    $$ -\\frac{\\partial \\lambda}{\\partial t} - u(t)\\frac{\\partial \\lambda}{\\partial x} = D(T_a(t))\\frac{\\partial^2 \\lambda}{\\partial x^2} $$\n2.  **终端条件**：从最终时刻 $t_f$ 的变分推导得出。\n    $$ \\lambda(x, t_f) = c(x, t_f) - c_{\\text{ref}} $$\n3.  **伴随边界条件**：从空间边界项推导得出，得到伴随变量的零-诺伊曼(zero-Neumann)条件。\n    $$ \\frac{\\partial \\lambda}{\\partial x}(0,t) = 0, \\quad \\frac{\\partial \\lambda}{\\partial x}(L,t) = 0 $$\n\n在伴随变量 $\\lambda$ 满足此系统的情况下，目标函数相对于控制轨迹 $T_a(t)$ 的梯度由拉格朗日量相对于 $T_a$ 的偏导数给出，同时保持 $c$ 和 $\\lambda$ 固定：\n$$ \\frac{\\delta J_{\\text{obj}}}{\\delta T_a(t)} = \\frac{\\partial \\mathcal{L}}{\\partial T_a(t)} $$\n该导数源于 PDE 算子通过 $u(t)$ 和 $D(T_a(t))$ 对 $T_a$ 的显式依赖。计算得出：\n$$ \\frac{\\delta J_{\\text{obj}}}{\\delta T_a(t)} = \\int_0^L \\left( c(x,t) \\frac{\\partial \\lambda}{\\partial x}(x,t) \\frac{du}{dT_a}(t) + c(x,t) \\frac{\\partial^2 \\lambda}{\\partial x^2}(x,t) \\frac{dD}{dT_a}(t) \\right) dx $$\n$u$ 和 $D$ 相对于 $T_a$ 的导数是：\n$$ \\frac{du}{dT_a}(t) = \\begin{cases} k_u  \\text{if } T_a(t)  T_{\\text{ref}} \\\\ 0  \\text{if } T_a(t)  T_{\\text{ref}} \\end{cases} $$\n在不可微点 $T_a(t) = T_{\\text{ref}}$，我们使用右导数 $k_u$，这是一个有效的次梯度。\n$$ \\frac{dD}{dT_a}(t) = D(T_a(t)) \\cdot \\frac{E_a}{R T_a(t)^2} $$\n\n### 第 3 步：数值离散化和算法设计\n\n我们在一个包含 $N_x=101$ 个节点的均匀网格上采用有限体积法，该网格跨越域 $x \\in [0, L]$，间距为 $\\Delta x = L/(N_x-1)$。时间域 $t \\in [0, t_f]$ 被离散化为 $N_t=60$ 个步长为 $\\Delta t = t_f/N_t$ 的时间步。设 $c_i^k \\approx c(x_i, t_k)$。\n\n**正向状态模拟：**\n我们使用半隐式格式：对平流项 ($u \\ge 0$) 使用显式一阶迎风格式，对扩散项使用类似 Crank-Nicolson 的隐式格式。在时间步 $k \\to k+1$ 时，对单元 $i$ 的离散化 PDE 是一个线性系统 $A_k c^{k+1} = B_k c^k$。\n\n-   **对于内部节点 ($i=1, \\dots, N_x-2$)：**\n    $$ -\\beta_k c_{i-1}^{k+1} + (1+2\\beta_k)c_i^{k+1} - \\beta_k c_{i+1}^{k+1} = (1-\\alpha_k)c_i^k + \\alpha_k c_{i-1}^k $$\n-   **对于边界节点 $i=0$ (使用 $J(0,t)=0$)：**\n    $$ (1+\\beta_k)c_0^{k+1} - \\beta_k c_1^{k+1} = (1-\\alpha_k)c_0^k $$\n-   **对于边界节点 $i=N_x-1$ (使用 $J(L,t)=0$)：**\n    $$ -\\beta_k c_{N_x-2}^{k+1} + (1+\\beta_k)c_{N_x-1}^{k+1} = c_{N_x-1}^k + \\alpha_k c_{N_x-2}^k $$\n其中 $\\alpha_k = u(T_a(t_k))\\Delta t / \\Delta x$ 是 Courant 数，$\\beta_k = D(T_a(t_k))\\Delta t / \\Delta x^2$ 是扩散数。这对 $c^{k+1}$ 构成一个三对角系统，在每个时间步求解。\n\n**伴随系统模拟：**\n离散伴随系统是通过转置线性化的正向演化算子得到的。伴随状态 $\\lambda^k$ 通过从 $k=N_t-1$ 到 $0$ 反向求解一个线性系统来找到。\n-   **终端条件**：$\\lambda^{N_t} = (c^{N_t} - c_{\\text{ref}}) \\Delta x$。\n-   **反向步骤**：在每一步，求解三对角系统 $A_k^T \\lambda^k = B_k^T \\lambda^{k+1}$ 以得到 $\\lambda^k$。\n\n**梯度计算：**\n使用存储的状态和伴随历史记录，为每个时间步 $k=0, \\dots, N_t-1$ 计算离散梯度 $\\nabla J[k] = \\partial J_{\\text{obj}} / \\partial T_a(t_k)$：\n$$ \\nabla J[k] = (\\lambda^{k+1})^T \\left( -A_k^{-1} \\frac{\\partial A_k}{\\partial T_{a,k}} c^{k+1} + A_k^{-1} \\frac{\\partial B_k}{\\partial T_{a,k}} c^k \\right) $$\n这可以通过求解一个带有 $A_k^T$ 的线性系统，然后与从矩阵 $A_k$ 和 $B_k$ 的偏导数导出的向量进行内积来高效计算。\n\n总体算法如下：\n1.  **正向传播**：从 $k=0$ 到 $N_t$ 求解 $c^k$，存储状态历史 $c^k$ 以及参数 $\\alpha_k, \\beta_k$。\n2.  **反向传播**：从 $k=N_t$ 到 $0$ 求解 $\\lambda^k$，存储伴随历史 $\\lambda^k$。\n3.  **梯度计算**：使用存储的历史记录为 $k=0$ 到 $N_t-1$ 计算每个分量 $\\nabla J[k]$。\n\n### 第 4 步：最终实现\n以下 Python 代码实现了推导出的算法。它为三个测试用例中的每一个计算梯度，并以指定格式打印结果。使用 `scipy.linalg.solve_banded` 函数高效求解三对角线性系统。所有计算均以 SI 基本单位进行。",
            "answer": "```python\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef solve():\n    \"\"\"\n    Computes the gradient of the binder uniformity objective with respect to\n    the air temperature trajectory for a 1D battery electrode drying model.\n    \"\"\"\n\n    # Physical and Model Constants (SI units)\n    L = 100e-6  # m, domain length\n    T_F = 600.0  # s, final time\n    C_0 = 0.06  # dimensionless, initial concentration\n    C_REF = 0.06  # dimensionless, reference concentration\n    D_PRE = 1.0e-7  # m^2/s, diffusion pre-factor\n    E_A = 1.5e4  # J/mol, activation energy\n    R = 8.314  # J/(mol*K), universal gas constant\n    K_U = 3.0e-9  # m/(s*K), advection coefficient\n    T_REF = 298.0  # K, reference temperature for advection\n\n    # Discretization Parameters\n    NX = 101  # Number of spatial nodes\n    NT = 60   # Number of time steps\n    DX = L / (NX - 1)  # Spatial step size\n    DT = T_F / NT      # Time step size\n\n    # Time and space grids\n    time_grid = np.linspace(0, T_F, NT + 1)\n\n    # Test cases for air temperature trajectory T_a(t)\n    test_cases = [\n        # Case A: Baseline constant temperature\n        np.full(NT, 298.0),\n        # Case B: Linear ramp\n        298.0 + 30.0 * time_grid[:-1] / T_F,\n        # Case C: Sinusoidal modulation\n        308.0 + 10.0 * np.sin(2 * np.pi * time_grid[:-1] / T_F)\n    ]\n\n    all_results = []\n\n    for T_a_traj in test_cases:\n        # --- 1. Forward Simulation ---\n        c_hist = np.zeros((NT + 1, NX))\n        alpha_hist = np.zeros(NT)\n        beta_hist = np.zeros(NT)\n        c_hist[0, :] = C_0\n\n        for k in range(NT):\n            T_a_k = T_a_traj[k]\n            \n            D_k = D_PRE * np.exp(-E_A / (R * T_a_k))\n            u_k = K_U * np.maximum(0, T_a_k - T_REF)\n            alpha_k = u_k * DT / DX\n            beta_k = D_k * DT / (DX**2)\n            alpha_hist[k], beta_hist[k] = alpha_k, beta_k\n\n            # Assemble tridiagonal matrix A_k in banded format for SciPy\n            A_k_banded = np.zeros((3, NX))\n            A_k_banded[0, 1:] = -beta_k   # Super-diagonal\n            A_k_banded[1, :] = 1 + 2 * beta_k  # Main diagonal\n            A_k_banded[1, 0] = 1 + beta_k\n            A_k_banded[1, -1] = 1 + beta_k\n            A_k_banded[2, :-1] = -beta_k # Sub-diagonal\n\n            # Assemble RHS vector b_k = B_k * c_k\n            c_k = c_hist[k]\n            b_k = np.zeros(NX)\n            b_k[0] = (1 - alpha_k) * c_k[0]\n            if NX  1:\n                b_k[1:-1] = (1 - alpha_k) * c_k[1:-1] + alpha_k * c_k[:-2]\n                b_k[-1] = c_k[-1] + alpha_k * c_k[-2]\n            \n            c_hist[k + 1] = solve_banded((1, 1), A_k_banded, b_k, check_finite=False)\n\n        # --- 2. Adjoint Simulation (Backward in Time) ---\n        lambda_hist = np.zeros((NT + 1, NX))\n        lambda_hist[-1, :] = (c_hist[-1] - C_REF) * DX\n\n        for k in range(NT - 1, -1, -1):\n            alpha_k, beta_k = alpha_hist[k], beta_hist[k]\n            lambda_kp1 = lambda_hist[k + 1]\n\n            # Assemble A_k^T in banded format\n            Ak_T_banded = np.zeros((3, NX))\n            Ak_T_banded[0, 1:] = -beta_k  # Super-diagonal of A^T is sub-diagonal of A\n            Ak_T_banded[1, :] = 1 + 2 * beta_k\n            Ak_T_banded[1, 0] = 1 + beta_k\n            Ak_T_banded[1, -1] = 1 + beta_k\n            Ak_T_banded[2, :-1] = -beta_k  # Sub-diagonal of A^T is super-diagonal of A\n            \n            # Assemble RHS vector v = B_k^T * lambda_{k+1}\n            v = np.zeros(NX)\n            if NX  1:\n                v[:-1] = (1 - alpha_k) * lambda_kp1[:-1] + alpha_k * lambda_kp1[1:]\n                v[-1] = lambda_kp1[-1]\n            else:\n                v[0] = lambda_kp1[0]\n                \n            lambda_hist[k] = solve_banded((1, 1), Ak_T_banded, v, check_finite=False)\n\n        # --- 3. Gradient Computation ---\n        grad = np.zeros(NT)\n        for k in range(NT):\n            T_a_k = T_a_traj[k]\n            alpha_k, beta_k = alpha_hist[k], beta_hist[k]\n            c_k, c_kp1, lambda_kp1 = c_hist[k], c_hist[k+1], lambda_hist[k+1]\n            \n            # Derivatives of parameters w.r.t. T_a_k\n            D_k = D_PRE * np.exp(-E_A / (R * T_a_k))\n            dD_dTa = D_k * E_A / (R * T_a_k**2)\n            # Use right-derivative for max() at T_a = T_ref, a valid subgradient\n            du_dTa = K_U if T_a_k = T_REF else 0.0\n            dalpha_dTa = du_dTa * DT / DX\n            dbeta_dTa = dD_dTa * DT / (DX**2)\n            \n            # Compute w_k = (A_k^T)^-1 * lambda_{k+1}\n            Ak_T_banded = np.zeros((3, NX))\n            Ak_T_banded[0, 1:] = -beta_k\n            Ak_T_banded[1, :] = 1 + 2 * beta_k\n            Ak_T_banded[1, 0] = 1 + beta_k\n            Ak_T_banded[1, -1] = 1 + beta_k\n            Ak_T_banded[2, :-1] = -beta_k\n            w_k = solve_banded((1, 1), Ak_T_banded, lambda_kp1, check_finite=False)\n\n            # Compute term from derivative of A_k\n            V_Ak = np.zeros(NX)\n            V_Ak[0] = -dbeta_dTa * (c_kp1[0] - c_kp1[1]) if NX  1 else 0\n            if NX  2:\n                V_Ak[1:-1] = -dbeta_dTa * (-c_kp1[:-2] + 2*c_kp1[1:-1] - c_kp1[2:])\n                V_Ak[-1] = -dbeta_dTa * (-c_kp1[-2] + c_kp1[-1])\n            \n            # Compute term from derivative of B_k\n            V_Bk = np.zeros(NX)\n            V_Bk[0] = -dalpha_dTa * c_k[0]\n            if NX  1:\n                V_Bk[1:-1] = dalpha_dTa * (c_k[:-2] - c_k[1:-1])\n                V_Bk[-1] = dalpha_dTa * c_k[-2]\n\n            grad[k] = np.dot(w_k, V_Ak + V_Bk)\n\n        all_results.append(grad.tolist())\n    \n    # Format output as a string representing a list of lists.\n    # E.g., [[gA_0, gA_1, ...], [gB_0, gB_1, ...], [gC_0, gC_1, ...]]\n    # Use repr() to get a standard string representation of a list of floats.\n    result_str = \",\".join([repr(res) for res in all_results])\n    print(f\"[{result_str}]\")\n\nsolve()\n\n```"
        }
    ]
}