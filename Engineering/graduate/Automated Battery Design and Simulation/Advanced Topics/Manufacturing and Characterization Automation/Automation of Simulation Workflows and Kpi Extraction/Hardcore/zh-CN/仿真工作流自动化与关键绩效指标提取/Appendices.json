{
    "hands_on_practices": [
        {
            "introduction": "任何稳健的仿真工作流都始于一个正确配置的模型。对于基于偏微分方程的仿真（如电池建模），空间网格分辨率是一个关键参数，它决定了计算的准确性和成本。这个练习将演示如何自动化选择网格的过程，通过从第一性原理推导出一个约束条件——将数值误差、物理参数和期望的准确性KPI联系起来——我们可以创建能够自适应调整网格以确保仿真保真度的工作流。",
            "id": "3893789",
            "problem": "一个用于锂离子电池设计的自动化仿真工作流必须在隔膜中分配合适的空间分辨率，以精确捕捉在高电流阶跃下形成的电解质浓度边界层。该工作流对厚度为 $\\delta_{s}$ 的隔膜使用均匀一维网格，并采用二阶中心有限差分 (FD) 格式来推进（求解）电解质盐浓度 $c_{e}(x,t)$ 的演化。用于判断网格充分性的设计关键性能指标 (KPI) 是梯度 $\\nabla c_{e}$ 的相对点误差，该误差受容差 $\\varepsilon$ 的约束。\n\n假设早期的边界层形成由扩散主导，并且可以在半无限域 $x \\geq 0$ 上通过菲克第二定律 $\\partial c_{e}/\\partial t = D_{e} \\, \\partial^{2} c_{e}/\\partial x^{2}$ 来近似。在 $t > 0$ 时，位于 $x=0$ 处的界面浓度发生从 $c_{0}$ 到 $c_{s}$ 的阶跃变化，初始条件为 $c_{e}(x,0)=c_{0}$，远场边界条件为 $c_{e}(\\infty,t)=c_{0}$。这个典型的扩散问题在 $x=0$ 附近产生一个边界层，其梯度决定了最严格的分辨率要求。对于包含隔膜两个边界的 $N$ 个均匀节点，网格间距为 $h = \\delta_{s}/(N-1)$。\n\n从这些原理出发，且不使用任何快捷公式，推导所需的网格间距约束，以确保当使用二阶中心有限差分梯度时，$\\nabla c_{e}$ 在其最大值位置的相对误差受 $\\varepsilon$ 的限制。然后，根据以下参数计算满足此约束条件的最小整数节点数 $N$：\n- $\\delta_{s} = 25 \\times 10^{-6} \\ \\mathrm{m}$，\n- $D_{e} = 1.2 \\times 10^{-10} \\ \\mathrm{m}^{2}\\,\\mathrm{s}^{-1}$，\n- $t = 1 \\ \\mathrm{s}$，\n- $\\varepsilon = 0.01$。\n\n明确说明您所做的任何数学假设，并在最终进行数值计算前，保持各常量为符号形式。将最终结果报告为精确的整数节点数 $N$（无单位）。除了整数要求外，无需其他取整规则。",
            "solution": "该问题要求为一个自动化的电池仿真工作流推导网格间距约束。该约束基于早期边界层形成期间电解质浓度 $c_e(x,t)$ 的数值梯度计算的相对误差。最终目标是计算在指定条件下满足此约束所需的最小网格节点数 $N$。\n\n首先对问题陈述进行验证。\n\n### 步骤1：提取已知条件\n-   控制方程：菲克第二定律，$\\frac{\\partial c_{e}}{\\partial t} = D_{e} \\frac{\\partial^{2} c_{e}}{\\partial x^{2}}$。\n-   区域：半无限， $x \\geq 0$。\n-   初始条件：$c_{e}(x,0) = c_{0}$。\n-   边界条件：$t > 0$ 时，$c_{e}(0,t) = c_{s}$，且 $c_{e}(\\infty,t) = c_{0}$。\n-   数值方法：用于梯度 $\\nabla c_{e}$ 的二阶中心有限差分 (FD)。\n-   性能约束 (KPI)：$\\nabla c_{e}$ 在其最大值处的相对点误差受 $\\varepsilon$ 的限制。\n-   网格定义：在厚度为 $\\delta_s$ 的隔膜上使用包含 $N$ 个节点的均匀网格。网格间距为 $h = \\frac{\\delta_{s}}{N-1}$。\n-   数值：\n    -   $\\delta_{s} = 25 \\times 10^{-6} \\ \\mathrm{m}$\n    -   $D_{e} = 1.2 \\times 10^{-10} \\ \\mathrm{m}^{2}\\,\\mathrm{s}^{-1}$\n    -   $t = 1 \\ \\mathrm{s}$\n    -   $\\varepsilon = 0.01$\n\n### 步骤2：使用提取的已知条件进行验证\n该问题在科学上基于扩散原理（菲克定律）和数值分析（有限差分）。该设置涉及使用半无限域解来确定有限域问题在早期时间的分辨率要求，这是一种标准的、物理上合理的工程近似方法。特征扩散长度 $\\sqrt{D_e t} = \\sqrt{1.2 \\times 10^{-10} \\times 1} \\approx 3.46 \\times 10^{-6} \\ \\mathrm{m}$ 远小于隔膜厚度 $\\delta_s = 25 \\times 10^{-6} \\ \\mathrm{m}$，这证明了在给定时间 $t=1 \\ \\mathrm{s}$ 时使用半无限域假设的合理性。该问题是适定的、客观的，并包含足够的信息以获得唯一解。\n\n### 步骤3：结论与行动\n问题被判定为 **有效**。将提供完整的推导和解答。\n\n### 网格间距约束的推导\n\n**1. 控制方程的解析解**\n\n扩散过程由以下偏微分方程 (PDE) 描述：\n$$\n\\frac{\\partial c_{e}}{\\partial t} = D_{e} \\frac{\\partial^{2} c_{e}}{\\partial x^{2}}\n$$\n初始条件和边界条件为：\n$$\nc_{e}(x,0) = c_{0} \\quad \\text{for } x \\geq 0\n$$\n$$\nc_{e}(0,t) = c_{s} \\quad \\text{for } t > 0\n$$\n$$\n\\lim_{x\\to\\infty} c_{e}(x,t) = c_{0} \\quad \\text{for } t > 0\n$$\n这是一个标准的半无限域上的一维扩散问题。我们使用相似性变换来求解。让我们定义一个无量纲的相似性变量 $\\eta$：\n$$\n\\eta = \\frac{x}{2\\sqrt{D_e t}}\n$$\n假设解的形式为 $c_e(x,t) = f(\\eta)$，该偏微分方程将转换为一个常微分方程 (ODE)。将浓度进行归一化处理，令 $u(\\eta) = \\frac{c_e - c_0}{c_s - c_0}$，则 PDE 变为：\n$$\nu''(\\eta) + 2\\eta u'(\\eta) = 0\n$$\n边界条件转换为 $u(0) = 1$ 和 $u(\\infty) = 0$。该 ODE 的解用互补误差函数 $\\mathrm{erfc}(z)$ 表示为：\n$$\nu(\\eta) = \\mathrm{erfc}(\\eta)\n$$\n转换回原始变量，浓度分布的解析解为：\n$$\nc_e(x,t) = c_0 + (c_s - c_0) \\mathrm{erfc}\\left(\\frac{x}{2\\sqrt{D_e t}}\\right)\n$$\n\n**2. 解析梯度及其最大值位置**\n\n浓度梯度 $G(x,t) = \\nabla c_e = \\frac{\\partial c_e}{\\partial x}$ 可以通过将解对 $x$ 求导得到。利用性质 $\\frac{d}{dz}\\mathrm{erfc}(z) = -\\frac{2}{\\sqrt{\\pi}}\\exp(-z^2)$ 和链式法则：\n$$\n\\frac{\\partial c_e}{\\partial x} = (c_s - c_0) \\left( -\\frac{2}{\\sqrt{\\pi}} \\exp\\left(-\\frac{x^2}{4 D_e t}\\right) \\right) \\left( \\frac{1}{2\\sqrt{D_e t}} \\right)\n$$\n$$\nG(x,t) = \\frac{\\partial c_e}{\\partial x} = -\\frac{c_s - c_0}{\\sqrt{\\pi D_e t}} \\exp\\left(-\\frac{x^2}{4 D_e t}\\right)\n$$\n问题要求在梯度最大值的位置进行分析。梯度的大小为：\n$$\n|G(x,t)| = \\frac{|c_s - c_0|}{\\sqrt{\\pi D_e t}} \\exp\\left(-\\frac{x^2}{4 D_e t}\\right)\n$$\n该函数是一个以 $x=0$ 为中心的高斯函数，因此其最大值出现在 $x=0$ 处。所以，梯度大小的最大值位置是 $x_{max} = 0$。\n\n**3. 有限差分误差分析**\n\n该工作流使用二阶中心有限差分格式来近似梯度。对于函数 $f(x)$，在点 $x_i$ 处的近似值为：\n$$\nf'_{FD}(x_i) = \\frac{f(x_i+h) - f(x_i-h)}{2h}\n$$\n根据泰勒定理，该近似的截断误差的主项为：\n$$\nE_{abs}(x) = |f'_{FD}(x) - f'(x)| \\approx \\left| \\frac{h^2}{6} f'''(x) \\right|\n$$\n问题指定使用此格式。然而，在边界点 $x=0$ 处，中心差分模板是无法良好定义的，因为它需要一个位于域外的点 $x=-h$。该格式适用于所有内部节点 $x_i$（其中 $i=2, \\dots, N-1$）。梯度最大的点是 $x=0$，并且预计误差在这一区域最大。因此，我们必须在可以应用中心差分格式的第一个内部节点，即 $x_1=h$ 处，施加误差约束。\n\n**假设：** 误差约束在第一个内部网格点 $x=h$ 处施加，因为这是距离梯度最大值位置（$x=0$）最近的可计算点。\n\n在 $x=h$ 处的相对误差定义为：\n$$\nE_{rel}(h) = \\frac{|G_{FD}(h) - G(h)|}{|G(h)|} \\approx \\frac{h^2}{6} \\frac{|c_e'''(h)|}{|c_e'(h)|}\n$$\n我们需要计算 $c_e(x,t)$ 的一阶和三阶导数。令 $C = -\\frac{c_s-c_0}{\\sqrt{\\pi D_e t}}$ 和 $a = \\frac{1}{4D_e t}$。则 $G(x,t) = c_e'(x) = C \\exp(-ax^2)$。\n$$\nc_e''(x) = C(-2ax)\\exp(-ax^2)\n$$\n$$\nc_e'''(x) = C(-2a)\\exp(-ax^2) + C(-2ax)^2\\exp(-ax^2) = -2aC(1 - 2ax^2)\\exp(-ax^2)\n$$\n在任意点 $x$ 的相对误差为：\n$$\nE_{rel}(x) \\approx \\frac{h^2}{6} \\frac{|-2aC(1 - 2ax^2)\\exp(-ax^2)|}{|C\\exp(-ax^2)|} = \\frac{ah^2}{3} |1 - 2ax^2|\n$$\n代入 $a = \\frac{1}{4D_e t}$：\n$$\nE_{rel}(x) \\approx \\frac{h^2}{12 D_e t} \\left| 1 - \\frac{x^2}{2 D_e t} \\right|\n$$\n在 $x=h$ 处计算此式，我们得到约束条件：\n$$\nE_{rel}(h) \\approx \\frac{h^2}{12 D_e t} \\left| 1 - \\frac{h^2}{2 D_e t} \\right| \\le \\varepsilon\n$$\n对于足够精细的网格，$h$ 必须很小，这意味着离散化的特征长度 $h$ 远小于特征扩散长度 $\\sqrt{D_e t}$。这意味着项 $\\frac{h^2}{2 D_e t}$ 远小于 $1$。因此，我们可以近似为 $|1 - \\frac{h^2}{2 D_e t}| \\approx 1$。约束条件简化为：\n$$\n\\frac{h^2}{12 D_e t} \\le \\varepsilon\n$$\n这就得到了网格间距的约束：\n$$\nh \\le \\sqrt{12 D_e t \\varepsilon}\n$$\n（注：在 $x=0$ 处使用二阶精度的前向差分模板进行类似分析，会得到相同的约束条件 $\\frac{h^2}{12 D_e t} \\le \\varepsilon$，这进一步证实了此结果的有效性。）\n\n**4. 节点数 N 的计算**\n\n网格间距 $h$ 通过 $h = \\frac{\\delta_s}{N-1}$ 与节点数 $N$ 和隔膜厚度 $\\delta_s$ 相关联。将此代入约束条件：\n$$\n\\frac{\\delta_s}{N-1} \\le \\sqrt{12 D_e t \\varepsilon}\n$$\n我们重新整理以求解 $N$：\n$$\nN - 1 \\ge \\frac{\\delta_s}{\\sqrt{12 D_e t \\varepsilon}}\n$$\n$$\nN \\ge 1 + \\frac{\\delta_s}{\\sqrt{12 D_e t \\varepsilon}}\n$$\n现在，我们代入给定的数值：\n-   $\\delta_{s} = 25 \\times 10^{-6} \\ \\mathrm{m}$\n-   $D_{e} = 1.2 \\times 10^{-10} \\ \\mathrm{m}^{2}\\,\\mathrm{s}^{-1}$\n-   $t = 1 \\ \\mathrm{s}$\n-   $\\varepsilon = 0.01$\n\n分母中的项为：\n$$\n\\sqrt{12 D_e t \\varepsilon} = \\sqrt{12 \\times (1.2 \\times 10^{-10}) \\times 1 \\times 0.01} = \\sqrt{14.4 \\times 10^{-12}} = \\sqrt{14.4} \\times 10^{-6} \\ \\mathrm{m}\n$$\n将此代入关于 $N$ 的不等式：\n$$\nN \\ge 1 + \\frac{25 \\times 10^{-6}}{\\sqrt{14.4} \\times 10^{-6}} = 1 + \\frac{25}{\\sqrt{14.4}}\n$$\n我们可以写成 $\\sqrt{14.4} = \\sqrt{\\frac{144}{10}} = \\frac{12}{\\sqrt{10}}$。\n$$\nN \\ge 1 + \\frac{25}{12/\\sqrt{10}} = 1 + \\frac{25\\sqrt{10}}{12}\n$$\n数值上，$\\sqrt{10} \\approx 3.16227766$。\n$$\nN \\ge 1 + \\frac{25 \\times 3.16227766}{12} \\approx 1 + \\frac{79.05694}{12} \\approx 1 + 6.588078\n$$\n$$\nN \\ge 7.588078\n$$\n由于 $N$ 必须是整数，满足此条件的最小整数值 $N$ 是 $8$。\n\n为了验证之前所做的近似，我们计算 $h=\\frac{25 \\times 10^{-6}}{8-1} \\approx 3.57 \\times 10^{-6} \\ \\mathrm{m}$。项 $\\frac{h^2}{2 D_e t} = \\frac{(3.57 \\times 10^{-6})^2}{2 \\times 1.2 \\times 10^{-10} \\times 1} \\approx \\frac{12.76 \\times 10^{-12}}{2.4 \\times 10^{-10}} \\approx 0.053$，这确实远小于 $1$，从而证实了简化约束的有效性。\n\n所需的最小整数节点数为 $8$。",
            "answer": "$$\n\\boxed{8}\n$$"
        },
        {
            "introduction": "仿真开始运行后，自动化工作流不仅要收集数据，还必须实时验证数据。这对于确保提取的KPI（关键性能指标）基于物理上有意义且安全的操作条件至关重要。本实践旨在形式化一个不变式监视器的概念——这是一个关键组件，它能检查如电压限制等安全违规行为，并确保任何下游分析（如KPI提取）仅使用仿真有效部分的数据，从而保证自动化分析的完整性和可靠性。",
            "id": "3893774",
            "problem": "您的任务是形式化并实现电池仿真工作流中的一个自动化步骤，该步骤对电化学电池电压强制执行安全不变性，并确保下游关键性能指标（KPI）的提取不包含不安全的数据。当电压偏离指定的安全边界时，该工作流步骤必须停止仿真，并且KPI提取器必须仅使用仿真数据的安全部分来计算能量吞吐量。该任务包括一个正确性的数学证明和一个使用固定测试套件的程序化演示。所有物理量必须以指定的明确单位表示，并且所有数值答案必须根据说明进行四舍五入。\n\n基本和核心定义：\n- 设瞬时电压为 $v(t)$（单位：$\\mathrm{V}$），瞬时电流为 $i(t)$（单位：$\\mathrm{A}$），其中 $t$ 是时间（单位：$\\mathrm{s}$）。\n- 瞬时电功率定义为 $p(t) = v(t) \\cdot i(t)$（单位：$\\mathrm{W}$）。\n- 在时间区间 $\\left[t_0, t_1\\right]$ 上的能量定义为 $E = \\int_{t_0}^{t_1} p(t) \\, dt$（单位：$\\mathrm{J}$）。\n- 在离散时间仿真中，该积分将进行数值近似。使用梯形法则和均匀或非均匀采样来近似 $p(t)$ 的积分。\n- 电压的安全不变性是一个谓词 $\\mathcal{S}(t)$，定义为 $\\mathcal{S}(t) :\\Leftrightarrow \\left(v(t) \\ge V_{\\min}\\right) \\land \\left(v(t) \\le V_{\\max}\\right)$，其中 $V_{\\min}$ 和 $V_{\\max}$ 是常量（单位：$\\mathrm{V}$）。\n\n工作流步骤规范：\n- 监视器在仿真序列 $\\{t_k\\}_{k=0}^{N-1}$ 中的每个采样时间 $t_k$ 处评估 $\\mathcal{S}(t)$，该序列具有相应的测量值 $\\{v_k\\}_{k=0}^{N-1}$ 和 $\\{i_k\\}_{k=0}^{N-1}$。\n- 定义停止索引 $h$ 为满足对所有 $k \\le h$ 都有 $\\mathcal{S}(t_k)$ 成立的最大索引。如果没有发生违规，则 $h = N-1$；否则，$h+1$ 是第一个出现 $\\neg \\mathcal{S}(t_{h+1})$ 的索引。\n- KPI提取器必须仅使用前缀 $\\{t_k, v_k, i_k\\}_{k=0}^{h}$ 来计算能量 $E_{\\mathrm{mon}}$。\n- 为了进行比较，定义在没有监视的情况下，对整个序列 $\\{t_k, v_k, i_k\\}_{k=0}^{N-1}$ 计算的原始能量 $E_{\\mathrm{full}}$。\n\n污染度量：\n- 定义污染比率 $r$ 为 $r = \\begin{cases}\\dfrac{E_{\\mathrm{full}} - E_{\\mathrm{mon}}}{E_{\\mathrm{full}}}  \\text{if } E_{\\mathrm{full}} > 0, \\\\ 0  \\text{if } E_{\\mathrm{full}} = 0.\\end{cases}$ 该量为无量纲量，必须表示为小数（不带百分号），并四舍五入到6位小数。\n\n单位和舍入要求：\n- 能量 $E_{\\mathrm{mon}}$ 和 $E_{\\mathrm{full}}$ 必须以 $\\mathrm{J}$ 为单位表示，并分别四舍五入到6位小数。\n- 三角函数中出现的角度必须以弧度为单位。\n- 时间单位为 $\\mathrm{s}$，电压单位为 $\\mathrm{V}$，电流单位为 $\\mathrm{A}$，功率单位为 $\\mathrm{W}$，能量单位为 $\\mathrm{J}$。\n\n测试套件（四个案例）：\n- 案例1（理想路径，始终安全的操作）：\n  - 采样时间 $t_k$ 从 $t_0 = 0 \\, \\mathrm{s}$ 到 $t_{N-1} = 100 \\, \\mathrm{s}$，步长为 $\\Delta t = 0.5 \\, \\mathrm{s}$。\n  - 电压 $v(t) = 3.7 + 0.2 \\sin\\!\\left(\\dfrac{2\\pi t}{50}\\right)$（单位：$\\mathrm{V}$）。\n  - 电流 $i(t) = 1.5 + 0.3 \\cos\\!\\left(\\dfrac{2\\pi t}{40}\\right)$（单位：$\\mathrm{A}$）。\n  - 安全边界 $V_{\\min} = 3.0 \\, \\mathrm{V}$ 和 $V_{\\max} = 4.2 \\, \\mathrm{V}$。\n- 案例2（运行中途发生过压违规，边界条件允许在 $V_{\\max}$ 处取等号）：\n  - 采样时间 $t_k$ 从 $t_0 = 0 \\, \\mathrm{s}$ 到 $t_{N-1} = 100 \\, \\mathrm{s}$，步长为 $\\Delta t = 0.5 \\, \\mathrm{s}$。\n  - 电压 $v(t) = 3.6 + 0.01 t$（单位：$\\mathrm{V}$）。\n  - 电流 $i(t) = 2.0$（单位：$\\mathrm{A}$）。\n  - 安全边界 $V_{\\min} = 3.0 \\, \\mathrm{V}$ 和 $V_{\\max} = 4.2 \\, \\mathrm{V}$。\n- 案例3（在边界徘徊噪声后发生欠压违规）：\n  - 采样时间 $t_k$ 从 $t_0 = 0 \\, \\mathrm{s}$ 到 $t_{N-1} = 50 \\, \\mathrm{s}$，步长为 $\\Delta t = 0.5 \\, \\mathrm{s}$。\n  - 电压 $v(t) = 3.0 - 0.02 t + 0.05 \\sin\\!\\left(\\dfrac{2\\pi t}{5}\\right)$（单位：$\\mathrm{V}$）。\n  - 电流 $i(t) = 1.0 + 0.5 \\sin\\!\\left(\\dfrac{2\\pi t}{10}\\right)$（单位：$\\mathrm{A}$）。\n  - 安全边界 $V_{\\min} = 2.5 \\, \\mathrm{V}$ 和 $V_{\\max} = 4.2 \\, \\mathrm{V}$。\n- 案例4（边缘案例：立即发生违规且电流为零）：\n  - 采样时间 $t_k$ 从 $t_0 = 0 \\, \\mathrm{s}$ 到 $t_{N-1} = 10 \\, \\mathrm{s}$，步长为 $\\Delta t = 0.5 \\, \\mathrm{s}$。\n  - 电压 $v(t) = 4.5 - 0.1 t$（单位：$\\mathrm{V}$）。\n  - 电流 $i(t) = 0.0$（单位：$\\mathrm{A}$）。\n  - 安全边界 $V_{\\min} = 3.0 \\, \\mathrm{V}$ 和 $V_{\\max} = 4.2 \\, \\mathrm{V}$。\n\n必需任务：\n- 实现监视器以计算 $h$。\n- 使用梯形法则对 $\\{t_k, p_k\\}_{k=0}^{h}$（其中 $p_k = v_k i_k$）计算 $E_{\\mathrm{mon}}$。\n- 使用梯形法则对 $\\{t_k, p_k\\}_{k=0}^{N-1}$ 计算 $E_{\\mathrm{full}}$。\n- 根据其定义计算 $r$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个元素本身也是一个用方括号括起来的逗号分隔列表，格式为 $\\left[E_{\\mathrm{mon}}, E_{\\mathrm{full}}, r\\right]$，对应四个测试案例，并且所有数值都按规定进行了四舍五入。例如，输出格式必须如下所示：$\\left[\\left[E_{\\mathrm{mon,1}},E_{\\mathrm{full,1}},r_1\\right],\\left[E_{\\mathrm{mon,2}},E_{\\mathrm{full,2}},r_2\\right],\\left[E_{\\mathrm{mon,3}},E_{\\mathrm{full,3}},r_3\\right],\\left[E_{\\mathrm{mon,4}},E_{\\mathrm{full,4}},r_4\\right]\\right]$。",
            "solution": "问题陈述已经过仔细验证，并被确定为具有科学依据、适定且内部一致。它在自动化电池仿真工作流领域提出了一个形式化且可解的任务。因此，我们可以着手提供一个完整的、合理的解决方案。\n\n核心任务是为仿真的电化学电池实现一个安全监控工作流。这涉及两个主要组成部分：一个在发生安全违规时停止仿真数据流的监视器，以及一个仅使用经过验证的安全数据部分来计算能量吞吐量的关键性能指标（KPI）提取器。\n\n该解决方案基于以下原则设计：\n\n1.  **连续信号的离散化**：连续时间电压 $v(t)$ 和电流 $i(t)$ 信号在离散时间点 $\\{t_k\\}_{k=0}^{N-1}$ 进行采样，以生成测量值的时间序列 $\\{v_k, i_k\\}_{k=0}^{N-1}$。对于均匀的时间步长 $\\Delta t$，时间点由 $t_k = t_0 + k \\Delta t$ 给出。那么每个点的瞬时功率为 $p_k = v_k \\cdot i_k$。\n\n2.  **安全不变性的强制执行**：在每个时间步 $t_k$ 检查安全不变性 $\\mathcal{S}(t_k) :\\Leftrightarrow (v_k \\ge V_{\\min}) \\land (v_k \\le V_{\\max})$。工作流必须只处理到首次违规发生点之前的数据。我们将停止索引 $h$ 定义为使得安全谓词 $\\mathcal{S}(t_i)$ 对所有索引 $i \\le h$ 都为真的最大索引。\n    -   如果在整个序列中没有发生违规，则所有数据点都是安全的。安全索引的集合为 $\\{0, 1, \\dots, N-1\\}$。最大索引为 $h = N-1$。\n    -   如果违规首次发生在索引 $j = \\min\\{k \\mid \\neg \\mathcal{S}(t_k)\\}$ 处，则对于所有索引 $i  j$，数据都是安全的。安全索引的集合为 $\\{0, 1, \\dots, j-1\\}$。该集合中的最大索引为 $h = j-1$。对于边缘情况 $j=0$，安全索引集合为空，我们定义 $h = -1$。\n\n3.  **通过数值积分进行KPI提取**：能量 $E$ 是功率的时间积分，即 $E = \\int p(t) \\, dt$。对于在时间点 $\\{t_k\\}_{k=0}^{M-1}$ 的离散功率序列 $\\{p_k\\}_{k=0}^{M-1}$，该积分使用梯形法则进行近似：\n    $$ E \\approx \\sum_{k=0}^{M-2} \\frac{p_k + p_{k+1}}{2} (t_{k+1} - t_k) $$\n    对于一个恒定的时间步长 $\\Delta t$，该公式简化为：\n    $$ E \\approx \\frac{\\Delta t}{2} \\left[ p_0 + 2\\sum_{k=1}^{M-2} p_k + p_{M-1} \\right] $$\n    计算两个能量KPI：\n    -   原始能量 $E_{\\mathrm{full}}$ 是在整个数据序列（从 $k=0$ 到 $k=N-1$）上计算的。\n    -   受监控的能量 $E_{\\mathrm{mon}}$ 仅在数据的安全前缀上计算，即从 $k=0$ 到 $k=h$ 的点序列。这对应于一个包含 $h+1$ 个数据点的序列。积分是在数据 $\\{ (t_k, p_k) \\}_{k=0}^{h}$ 上执行的。如果 $h  1$，点的数量不足以形成一个区间，因此能量正确地取为 $0$。\n\n4.  **污染分析**：污染比率 $r$ 量化了因在KPI计算中包含不安全数据而引入的相对误差。其定义为：\n    $$ r = \\begin{cases}\\dfrac{E_{\\mathrm{full}} - E_{\\mathrm{mon}}}{E_{\\mathrm{full}}}  \\text{if } E_{\\mathrm{full}}  0 \\\\ 0  \\text{if } E_{\\mathrm{full}} = 0\\end{cases} $$\n    $r=0$ 的值表示没有污染，原因是没有发生违规（$E_{\\mathrm{mon}} = E_{\\mathrm{full}}$）或总能量为零。非零的 $r$ 表示 $E_{\\mathrm{full}}$ 已被来自安全操作范围之外的数据所污染。\n\n**正确性证明**：\n算法实现直接遵循了这些原则。\n- 从给定的连续函数生成时间序列数据是一个标准的采样过程。\n- 停止索引 $h$ 的确定是通过找到电压违规的第一个索引 $j$ 来实现的。如果不存在这样的 $j$，则将 $h$ 设置为 $N-1$；否则，将 $h$ 设置为 $j-1$。这正确地实现了 $h$ 的定义，即“使得 $\\mathcal{S}(t_k)$ 对所有 $k \\le h$ 都成立的最大索引”。\n- $E_{\\mathrm{mon}}$ 的计算使用了从索引 $0$ 到 $h$ 的数据切片，即切片 `[0:h+1]`。这确保了只有满足安全不变性的数据点被包含在KPI中，符合要求。`numpy.trapz` 函数正确地处理了数值积分，包括安全点数少于 $2$ 的边缘情况（此时能量为 $0$）。\n- $E_{\\mathrm{full}}$ 的计算使用了完整的数据集。\n- 污染比率 $r$ 根据其定义计算，包括了 $E_{\\mathrm{full}}=0$ 的特殊情况。\n该逻辑是合理的，并涵盖了所有指定的情况，确保了解决方案的正确性和鲁棒性。最终的程序将为提供的测试套件实现此设计。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_kpis(t_data, v_data, i_data, v_min, v_max):\n    \"\"\"\n    Monitors simulation data, computes safe and full energy, and the contamination ratio.\n\n    Args:\n        t_data (np.ndarray): Array of time points in seconds.\n        v_data (np.ndarray): Array of voltage measurements in volts.\n        i_data (np.ndarray): Array of current measurements in amperes.\n        v_min (float): Minimum safe voltage.\n        v_max (float): Maximum safe voltage.\n\n    Returns:\n        tuple[float, float, float]: A tuple containing E_mon, E_full, and r, rounded.\n    \"\"\"\n    if t_data.size == 0:\n        return 0.0, 0.0, 0.0\n\n    # Calculate instantaneous power\n    p_data = v_data * i_data\n\n    # Calculate naive energy E_full over the entire dataset\n    e_full = np.trapz(p_data, t_data)\n\n    # Find the halting index h\n    # The safety invariant is S(t_k) = (v_k = v_min) and (v_k = v_max)\n    violation_mask = (v_data  v_min) | (v_data > v_max)\n    violation_indices = np.where(violation_mask)[0]\n\n    if violation_indices.size == 0:\n        # No violation occurred, the entire run is safe\n        h = t_data.size - 1\n    else:\n        # First violation occurs at the first index in violation_indices\n        first_violation_idx = violation_indices[0]\n        # h is the greatest index such that S(t_k) holds for all k = h\n        h = first_violation_idx - 1\n\n    # The monitored energy E_mon is computed over the safe prefix {t_k, ...}_k=0 to h\n    # This corresponds to a slice of length h + 1\n    cutoff_idx = h + 1\n\n    t_safe = t_data[:cutoff_idx]\n    p_safe = p_data[:cutoff_idx]\n\n    # np.trapz returns 0.0 for arrays with length  2, correctly handling edge cases\n    e_mon = np.trapz(p_safe, t_safe)\n\n    # Calculate contamination ratio r\n    if e_full != 0:\n        r = (e_full - e_mon) / e_full\n    else:\n        r = 0.0\n\n    return round(e_mon, 6), round(e_full, 6), round(r, 6)\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases_params = [\n        {\n            # Case 1 (happy path, always-safe operation)\n            \"t_range\": (0, 100), \"dt\": 0.5,\n            \"v_func\": lambda t: 3.7 + 0.2 * np.sin(2 * np.pi * t / 50),\n            \"i_func\": lambda t: 1.5 + 0.3 * np.cos(2 * np.pi * t / 40),\n            \"bounds\": (3.0, 4.2)\n        },\n        {\n            # Case 2 (overvoltage violation mid-run)\n            \"t_range\": (0, 100), \"dt\": 0.5,\n            \"v_func\": lambda t: 3.6 + 0.01 * t,\n            \"i_func\": lambda t: 2.0,\n            \"bounds\": (3.0, 4.2)\n        },\n        {\n            # Case 3 (undervoltage violation)\n            \"t_range\": (0, 50), \"dt\": 0.5,\n            \"v_func\": lambda t: 3.0 - 0.02 * t + 0.05 * np.sin(2 * np.pi * t / 5),\n            \"i_func\": lambda t: 1.0 + 0.5 * np.sin(2 * np.pi * t / 10),\n            \"bounds\": (2.5, 4.2)\n        },\n        {\n            # Case 4 (edge case: immediate violation)\n            \"t_range\": (0, 10), \"dt\": 0.5,\n            \"v_func\": lambda t: 4.5 - 0.1 * t,\n            \"i_func\": lambda t: 0.0,\n            \"bounds\": (3.0, 4.2)\n        }\n    ]\n\n    results = []\n    for params in test_cases_params:\n        # Generate data for the current test case\n        t_start, t_end = params[\"t_range\"]\n        dt = params[\"dt\"]\n        num_points = int(round((t_end - t_start) / dt)) + 1\n        t_data = np.linspace(t_start, t_end, num_points)\n        \n        v_data = params[\"v_func\"](t_data)\n        i_data = params[\"i_func\"](t_data)\n        v_min, v_max = params[\"bounds\"]\n\n        # Calculate KPIs\n        e_mon, e_full, r = calculate_kpis(t_data, v_data, i_data, v_min, v_max)\n        results.append((e_mon, e_full, r))\n\n    # Format the final output string as specified\n    formatted_results = [f\"[{e_mon:.6f},{e_full:.6f},{r:.6f}]\" for e_mon, e_full, r in results]\n    final_output = f\"[{','.join(formatted_results)}]\"\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "在能够可靠地运行和分析单个仿真后，下一个前沿领域是自动化整个实验设计过程。我们可以智能地选择信息量最大的实验来运行，而不是详尽地模拟所有可能的设计。本练习介绍了一种来自贝叶斯优化的强大技术——主动学习。您将实现一个采集函数，即预期提升（Expected Improvement），它利用代理模型的预测和不确定性来决定哪些候选设计最有潜力，从而有效地平衡利用已知优秀设计（exploitation）和探索未知设计空间（exploration）的需求。",
            "id": "3893813",
            "problem": "您正在为一个锂离子电池单元的设计实验循环（design-of-experiments loop）进行自动化，其中模拟的循环寿命是关键性能指标（KPI）。在每次迭代中，一个主动学习（Active Learning, AL）策略必须使用从“预期改进”（Expected Improvement）中导出的采集分数对候选设计进行排序，并选择一个子集进行下一步的模拟。该流程假设一个高斯过程（Gaussian Process, GP）代理模型，该模型为每个候选设计提供循环寿命的后验预测均值和方差。模拟的循环寿命是一个以“循环次数”为单位的物理量，必须被视为一个计数值。采集分数必须以“循环次数”表示。选择索引是无量纲的。\n\n从以下基本原理开始：\n- 在一个候选设计点，KPI循环寿命 $\\,Y\\,$ 的高斯过程预测分布是一个高斯分布，其预测均值为 $\\,\\mu\\,$，预测方差为 $\\,\\sigma^2\\,$。\n- 改进随机变量定义为 $\\,I = \\max(0, Y - y^\\star)\\,$，其中 $\\,y^\\star\\,$ 是当前观测到的最佳循环寿命（单位：循环次数）。\n- 标准正态概率密度函数为 $\\,\\phi(z)\\,$，标准正态累积分布函数为 $\\,\\Phi(z)\\,$。\n\n您的任务是：\n1. 从第一性原理和上述定义出发，推导循环寿命的“预期改进”采集函数，并以“循环次数”为单位表示。严格处理 $\\,\\sigma = 0\\,$ 的边界情况。\n2. 定义一个采样策略，通过“预期改进”和预测标准差的凸组合来平衡“利用”（exploitation）和“探索”（exploration）。设该策略由 $\\,\\lambda \\in [0,1]\\,$ 和一个非负尺度因子 $\\,\\kappa\\,$ 参数化，并根据得到的采集分数选择前 $\\,B\\,$ 个候选者。通过选择最小的索引来打破平局。\n3. 实现一个独立的程序，该程序：\n   - 为每个候选者计算“预期改进”和以“循环次数”为单位的平衡采集分数。\n   - 根据该策略选择前 $\\,B\\,$ 个候选者的索引。\n   - 按下文指定的精确格式生成最终输出。\n\n使用以下测试套件。对于每个测试用例，输入为：\n- 预测均值列表 $\\,\\mu\\,$，单位：循环次数。\n- 预测标准差列表 $\\,\\sigma\\,$，单位：循环次数。\n- 当前观测到的最佳循环寿命 $\\,y^\\star\\,$，单位：循环次数。\n- 探索权重 $\\,\\lambda\\,$（无量纲）。\n- 尺度因子 $\\,\\kappa\\,$（无量纲）。\n- 模拟预算 $\\,B\\,$（整数）。\n\n计算并报告采集分数，单位为循环次数，四舍五入到六位小数。角度单位不适用。不要使用百分比。\n\n测试套件：\n- 案例 $\\,1\\,$ (正常路径):\n  - $\\,\\mu = [800, 600, 900, 700]\\,$ 循环次数\n  - $\\,\\sigma = [50, 120, 30, 80]\\,$ 循环次数\n  - $\\,y^\\star = 750\\,$ 循环次数\n  - $\\,\\lambda = 0.3\\,$\n  - $\\,\\kappa = 1.0\\,$\n  - $\\,B = 2\\,$\n- 案例 $\\,2\\,$ (零方差边界情况):\n  - $\\,\\mu = [760, 740, 755]\\,$ 循环次数\n  - $\\,\\sigma = [0, 0, 0]\\,$ 循环次数\n  - $\\,y^\\star = 755\\,$ 循环次数\n  - $\\,\\lambda = 0.5\\,$\n  - $\\,\\kappa = 1.0\\,$\n  - $\\,B = 1\\,$\n- 案例 $\\,3\\,$ (探索主导的边缘情况):\n  - $\\,\\mu = [700, 730, 720]\\,$ 循环次数\n  - $\\,\\sigma = [150, 200, 10]\\,$ 循环次数\n  - $\\,y^\\star = 750\\,$ 循环次数\n  - $\\,\\lambda = 0.7\\,$\n  - $\\,\\kappa = 1.0\\,$\n  - $\\,B = 2\\,$\n- 案例 $\\,4\\,$ (利用主导的情况):\n  - $\\,\\mu = [1000, 760, 755]\\,$ 循环次数\n  - $\\,\\sigma = [5, 100, 100]\\,$ 循环次数\n  - $\\,y^\\star = 800\\,$ 循环次数\n  - $\\,\\lambda = 0.1\\,$\n  - $\\,\\kappa = 1.0\\,$\n  - $\\,B = 1\\,$\n\n输出规范：\n- 对每个测试用例，输出一个包含以下两项的对：\n  - 所有候选者的平衡采集分数列表（单位：循环次数），四舍五入到六位小数。\n  - 所选索引的列表（在按最小索引打破平局的规则下，选择前 $\\,B\\,$ 个）。\n- 将每个案例的结果聚合到一个单一的外部列表中。您的程序应生成单行输出，包含一个以方括号括起来的逗号分隔列表形式的结果，不含空格。例如，对于两个案例，格式为 $\\,[[\\text{scores}_1,\\text{indices}_1],[\\text{scores}_2,\\text{indices}_2]]\\,$。",
            "solution": "该问题是有效的，因为它在科学上基于贝叶斯优化在工程设计中的原理，数学上是适定的，并且所有必要的数据和约束都已提供。我们着手进行逐步推导和算法设计。\n\n第一个任务是从第一性原理推导出预期改进（Expected Improvement, EI）采集函数的解析表达式。相对于当前观测到的最佳循环寿命 $y^\\star$ 的改进 $I$ 是为一个候选设计定义的，该设计的循环寿命 $Y$ 是一个随机变量。改进由 $I = \\max(0, Y - y^\\star)$ 给出。循环寿命 $Y$ 由高斯过程建模，从而得到 $Y$ 的预测分布是一个正态分布，$Y \\sim \\mathcal{N}(\\mu, \\sigma^2)$，其中 $\\mu$ 是预测均值，$\\sigma^2$ 是预测方差。\n\n预期改进 $E[I]$ 是改进随机变量 $I$ 关于 $Y$ 的预测分布的期望。设 $f_Y(y)$ 是 $Y$ 的概率密度函数（PDF）。期望通过积分计算：\n$$E[I] = E[\\max(0, Y - y^\\star)] = \\int_{-\\infty}^{\\infty} \\max(0, y - y^\\star) f_Y(y) \\, dy$$\n项 $\\max(0, y - y^\\star)$ 仅在 $y  y^\\star$ 时非零。因此，该积分仅在定义域 $[y^\\star, \\infty)$ 上非零：\n$$E[I] = \\int_{y^\\star}^{\\infty} (y - y^\\star) f_Y(y) \\, dy$$\n其中 $f_Y(y) = \\frac{1}{\\sigma\\sqrt{2\\pi}} \\exp\\left(-\\frac{(y-\\mu)^2}{2\\sigma^2}\\right)$。我们可以将积分分成两部分：\n$$E[I] = \\int_{y^\\star}^{\\infty} y f_Y(y) \\, dy - y^\\star \\int_{y^\\star}^{\\infty} f_Y(y) \\, dy$$\n第二项是 $y^\\star$ 乘以 $Y$ 超过 $y^\\star$ 的概率，即 $y^\\star P(Y  y^\\star)$。为了计算这些项，我们进行变量替换，转换到标准正态分布。令 $z = \\frac{y - \\mu}{\\sigma}$，这意味着 $y = \\mu + \\sigma z$ 且 $dy = \\sigma dz$。随机变量 $Z = \\frac{Y - \\mu}{\\sigma}$ 服从标准正态分布 $Z \\sim \\mathcal{N}(0, 1)$，其PDF为 $\\phi(z) = \\frac{1}{\\sqrt{2\\pi}} e^{-z^2/2}$，CDF为 $\\Phi(z) = \\int_{-\\infty}^{z} \\phi(u) du$。\n\n积分下限 $y = y^\\star$ 变为 $z = \\frac{y^\\star - \\mu}{\\sigma}$。积分变为：\n$$E[I] = \\int_{\\frac{y^\\star - \\mu}{\\sigma}}^{\\infty} (\\mu + \\sigma z - y^\\star) \\phi(z) \\, dz$$\n$$E[I] = \\int_{\\frac{y^\\star - \\mu}{\\sigma}}^{\\infty} (\\mu - y^\\star) \\phi(z) \\, dz + \\int_{\\frac{y^\\star - \\mu}{\\sigma}}^{\\infty} \\sigma z \\phi(z) \\, dz$$\n$$E[I] = (\\mu - y^\\star) \\int_{\\frac{y^\\star - \\mu}{\\sigma}}^{\\infty} \\phi(z) \\, dz + \\sigma \\int_{\\frac{y^\\star - \\mu}{\\sigma}}^{\\infty} z \\phi(z) \\, dz$$\n第一个积分是概率 $P(Z  \\frac{y^\\star - \\mu}{\\sigma}) = 1 - \\Phi(\\frac{y^\\star - \\mu}{\\sigma}) = \\Phi(\\frac{\\mu - y^\\star}{\\sigma})$。\n第二个积分可以直接求解：$\\int_{a}^{\\infty} z \\phi(z) dz = \\int_{a}^{\\infty} z \\frac{1}{\\sqrt{2\\pi}} e^{-z^2/2} dz$。使用换元法 $u = -z^2/2$，我们发现这个积分等于 $\\phi(a)$。\n因此，当 $a = \\frac{y^\\star - \\mu}{\\sigma}$ 时，第二个积分的计算结果为 $\\sigma \\phi(\\frac{y^\\star - \\mu}{\\sigma})$。由于标准正态PDF $\\phi(z)$ 是一个偶函数，所以 $\\phi(\\frac{y^\\star - \\mu}{\\sigma}) = \\phi(\\frac{\\mu - y^\\star}{\\sigma})$。\n\n合并各项，预期改进为：\n$$E[I] = (\\mu - y^\\star) \\Phi\\left(\\frac{\\mu - y^\\star}{\\sigma}\\right) + \\sigma \\phi\\left(\\frac{\\mu - y^\\star}{\\sigma}\\right)$$\n该公式在 $\\sigma  0$ 时有效。$Y$ 和 $y^\\star$ 的单位都是循环次数，使得项 $(\\mu - y^\\star)$ 的单位也是循环次数。CDF $\\Phi(\\cdot)$ 是无量纲的。标准差 $\\sigma$ 的单位是循环次数，而PDF $\\phi(\\cdot)$ 的单位是其参数标准差的倒数，所以乘积 $\\sigma \\phi(\\cdot)$ 是无量纲的。等等，我的单位分析不正确。$\\phi$ 和 $\\Phi$ 的参数是无量纲的。$\\phi(z)$ 的量纲为1，所以 $\\sigma \\phi(z)$ 的单位与 $\\sigma$ 相同，即循环次数。这使得和式中的两项都具有循环次数的单位，从而确保 $E[I]$ 的单位是循环次数。\n\n接下来，我们必须严格处理预测方差为零的边界情况，即 $\\sigma = 0$。在这种情况下，高斯分布坍缩为以 $\\mu$ 为中心的狄拉克δ函数，意味着 $Y = \\mu$ 的概率为1。改进不再是随机变量，而是一个确定性的量：$I = \\max(0, \\mu - y^\\star)$。因此，期望就是 $E[I] = \\max(0, \\mu - y^\\star)$。这也可以通过在EI公式中取 $\\sigma \\to 0^+$ 的极限来推导。\n令 $z = \\frac{\\mu - y^\\star}{\\sigma}$。\n- 如果 $\\mu  y^\\star$，则 $z \\to \\infty$。当 $z \\to \\infty$ 时，$\\Phi(z) \\to 1$ 且 $\\phi(z) \\to 0$。$E[I] \\to (\\mu - y^\\star) \\cdot 1 + \\sigma \\cdot 0 = \\mu - y^\\star$。\n- 如果 $\\mu  y^\\star$，则 $z \\to -\\infty$。当 $z \\to -\\infty$ 时，$\\Phi(z) \\to 0$ 且 $\\phi(z) \\to 0$。$E[I] \\to (\\mu - y^\\star) \\cdot 0 + \\sigma \\cdot 0 = 0$。\n- 如果 $\\mu = y^\\star$，则对于 $\\sigma0$ 时 $z=0$，得到 $E[I] = 0 \\cdot \\Phi(0) + \\sigma \\phi(0) = \\sigma/\\sqrt{2\\pi}$，当 $\\sigma \\to 0$ 时，该值趋于 $0$。\n在所有情况下，极限都是 $\\max(0, \\mu - y^\\star)$。因此，EI的完整定义是：\n$$EI(\\mu, \\sigma, y^\\star) = \\begin{cases} (\\mu - y^\\star)\\Phi\\left(\\frac{\\mu - y^\\star}{\\sigma}\\right) + \\sigma\\phi\\left(\\frac{\\mu - y^\\star}{\\sigma}\\right)  \\text{如果 } \\sigma  0 \\\\ \\max(0, \\mu - y^\\star)  \\text{如果 } \\sigma = 0 \\end{cases}$$\n\n第二个任务是定义采样策略。该策略通过“预期改进”（利用）和预测标准差 $\\sigma$（探索）的凸组合来构建一个平衡的采集分数 $A$。该分数由权重 $\\lambda \\in [0, 1]$ 和一个非负尺度因子 $\\kappa$ 参数化。对于具有预测均值 $\\mu_i$ 和标准差 $\\sigma_i$ 的候选者 $i$，其采集分数的公式为：\n$$A_i = (1 - \\lambda) \\cdot EI(\\mu_i, \\sigma_i, y^\\star) + \\lambda \\kappa \\sigma_i$$\n该分数的单位是循环次数，因为 $EI$ 和 $\\sigma_i$ 的单位都是循环次数，而 $\\lambda$ 和 $\\kappa$ 是无量纲的。\n\n第三个任务是实现。算法首先为每个候选设计计算采集分数 $A_i$。然后，它选择得分最高的前 $B$ 个候选者。为了确保选择的唯一性，分数上的平局通过选择具有最小原始索引的候选者来打破。这可以通过基于主键采集分数（降序）和次键原始索引（升序）对候选者进行排序来实现。程序必须处理所提供的测试套件并按指定格式生成输出。实现将使用 `numpy` 进行高效的向量化计算，并使用 `scipy.stats.norm` 来获取标准正态分布的CDF ($\\Phi$) 和PDF ($\\phi$)。",
            "answer": "```python\nimport numpy as np\nfrom scipy.stats import norm\nimport json\n\ndef solve():\n    \"\"\"\n    Computes acquisition scores and selects candidate designs for a battery\n    simulation workflow based on Expected Improvement and a balanced policy.\n    \"\"\"\n\n    test_cases = [\n        # Case 1 (happy path)\n        {'mu': [800, 600, 900, 700], 'sigma': [50, 120, 30, 80], 'y_star': 750, 'lambda_': 0.3, 'kappa': 1.0, 'B': 2},\n        # Case 2 (boundary with zero variance)\n        {'mu': [760, 740, 755], 'sigma': [0, 0, 0], 'y_star': 755, 'lambda_': 0.5, 'kappa': 1.0, 'B': 1},\n        # Case 3 (exploration-dominant edge case)\n        {'mu': [700, 730, 720], 'sigma': [150, 200, 10], 'y_star': 750, 'lambda_': 0.7, 'kappa': 1.0, 'B': 2},\n        # Case 4 (exploitation-dominant case)\n        {'mu': [1000, 760, 755], 'sigma': [5, 100, 100], 'y_star': 800, 'lambda_': 0.1, 'kappa': 1.0, 'B': 1},\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        mu = np.array(case['mu'], dtype=float)\n        sigma = np.array(case['sigma'], dtype=float)\n        y_star = float(case['y_star'])\n        lambda_ = float(case['lambda_'])\n        kappa = float(case['kappa'])\n        B = int(case['B'])\n\n        # Initialize Expected Improvement array\n        ei = np.zeros_like(mu)\n\n        # Handle sigma > 0 case\n        mask_pos_sigma = sigma > 1e-9 # Use a small epsilon for floating point stability\n        if np.any(mask_pos_sigma):\n            mu_pos = mu[mask_pos_sigma]\n            sigma_pos = sigma[mask_pos_sigma]\n            \n            improvement = mu_pos - y_star\n            z = improvement / sigma_pos\n            \n            ei_pos = improvement * norm.cdf(z) + sigma_pos * norm.pdf(z)\n            ei[mask_pos_sigma] = ei_pos\n            \n        # Handle sigma = 0 case\n        mask_zero_sigma = ~mask_pos_sigma\n        if np.any(mask_zero_sigma):\n            mu_zero = mu[mask_zero_sigma]\n            \n            ei_zero = np.maximum(0.0, mu_zero - y_star)\n            ei[mask_zero_sigma] = ei_zero\n\n        # Calculate the balanced acquisition score\n        acquisition_scores = (1 - lambda_) * ei + lambda_ * kappa * sigma\n        \n        # Round scores to six decimal places for the output\n        rounded_scores = np.round(acquisition_scores, 6).tolist()\n        \n        # Select top B candidates with tie-breaking\n        # Create a list of (score, original_index) tuples\n        indexed_scores = list(enumerate(acquisition_scores))\n        \n        # Sort by score (descending) and then by index (ascending) to break ties\n        sorted_candidates = sorted(indexed_scores, key=lambda x: (-x[1], x[0]))\n        \n        # Extract the indices of the top B candidates\n        top_indices = [idx for idx, score in sorted_candidates[:B]]\n        \n        all_results.append([rounded_scores, top_indices])\n\n    # Convert the list of lists to the specified string format with no spaces\n    # json.dumps provides a compact representation.\n    output_str = json.dumps(all_results, separators=(',', ':'))\n    print(output_str)\n\nsolve()\n```"
        }
    ]
}