{
    "hands_on_practices": [
        {
            "introduction": "在任何数据驱动的建模流程中，确保物理一致性是至关重要的第一步。本练习将指导您构建一个自动化的量纲一致性检查器，它能够验证候选控制方程中的每一项是否都具有相同的物理量纲。通过实践 ，您将学会如何为模型发现算法构建一个物理上有意义的候选函数库，从而从源头上避免生成无意义的模型。",
            "id": "3904049",
            "problem": "您的任务是构建一个单位一致性检查器，用于验证在自动化电池设计和仿真中通过数据驱动方法发现的候选控制方程。目标是确保方程右侧的每个相加项都与左侧的量纲相匹配，并且满足所有特殊函数的约束。您的程序必须是一个单一、完整、可运行的脚本，并且必须按照指定格式产生单行输出。\n\n基本基础。检查器必须基于以下基础进行操作，这些基础仅限于普遍接受的定律和定义：\n- 基于国际单位制 (SI) 的七个基本量纲进行的量纲分析，在本问题中简化为实际需要的六个：质量 $M$ (千克, $kg$)、长度 $L$ (米, $m$)、时间 $T$ (秒, $s$)、电流 $I$ (安培, $A$)、热力学温度 $\\Theta$ (开尔文, $K$) 和物质的量 $N$ (摩尔, $mol$)。\n- 算子量纲：\n  - 空间梯度 $\\nabla$ 贡献一个因子 $L^{-1}$。\n  - 空间散度 $\\nabla \\cdot$ 贡献一个因子 $L^{-1}$。\n  - 空间拉普拉斯算子 $\\nabla^{2}$ 贡献一个因子 $L^{-2}$。\n  - 时间导数 $\\partial/\\partial t$ 贡献一个因子 $T^{-1}$。\n- 特殊函数约束：\n  - 指数函数 $\\exp(\\cdot)$ 和自然对数 $\\log(\\cdot)$ 要求无量纲参数。\n  - 绝对值 $|\\cdot|$ 保持量纲不变。\n  - 范数平方 $|\\cdot|^{2}$ 将量纲指数乘以 $2$。\n  - 允许将有量纲的量进行实数次幂运算；量纲指数按该幂次进行缩放。\n\n变量和参数的量纲分配。对常见的电池模型物理量，使用以下一致且有科学依据的单位：\n- 电解质浓度 $c$：$N L^{-3}$ ($mol \\, m^{-3}$)。\n- 电势 $\\phi$：$M L^{2} T^{-3} I^{-1}$ ($V$)。\n- 电流密度 $i$：$I L^{-2}$ ($A \\, m^{-2}$)。\n- 扩散系数 $D$：$L^{2} T^{-1}$ ($m^{2} \\, s^{-1}$)。\n- 反应速率 (摩尔通量) $j$：$N L^{-2} T^{-1}$ ($mol \\, m^{-2} \\, s^{-1}$)。\n- 法拉第常数 $F$：$I T N^{-1}$ ($C \\, mol^{-1}$)。\n- 比界面面积 $a$：$L^{-1}$ ($m^{2} \\, m^{-3}$)。\n- 电解质电导率 $\\kappa$：$M^{-1} L^{-3} T^{3} I^{2}$ ($S \\, m^{-1}$)。\n- 固体电导率 $\\sigma$：$M^{-1} L^{-3} T^{3} I^{2}$ ($S \\, m^{-1}$)。\n- 热导率 $k$：$M L T^{-3} \\Theta^{-1}$ ($W \\, m^{-1} \\, K^{-1}$)。\n- 质量密度 $\\rho$：$M L^{-3}$ ($kg \\, m^{-3}$)。\n- 比热容 $c_{p}$：$L^{2} T^{-2} \\Theta^{-1}$ ($J \\, kg^{-1} \\, K^{-1}$)。\n- 温度 $T$：$\\Theta$ ($K$)。\n- 普适气体常数 $R$：$M L^{2} T^{-2} N^{-1} \\Theta^{-1}$ ($J \\, mol^{-1} \\, K^{-1}$)。\n- 活化能 $E_{a}$：$M L^{2} T^{-2} N^{-1}$ ($J \\, mol^{-1}$)。\n- 无量纲孔隙率 $\\varepsilon$：无量纲 $M^{0} L^{0} T^{0} I^{0} \\Theta^{0} N^{0}$。\n- 一级表面反应速率常数 $k_{0}$：$L T^{-1}$ ($m \\, s^{-1}$)。\n\n量纲组合规则。您必须实现关于 $(M, L, T, I, \\Theta, N)$ 指数的代数运算：\n- 乘法将指数向量相加。\n- 除法将指数向量相减。\n- 加法要求所有加数具有相同的指数向量；结果也具有该指数向量。\n- 时间导数乘以 $T^{-1}$；空间梯度乘以 $L^{-1}$；空间散度乘以 $L^{-1}$；空间拉普拉斯算子乘以 $L^{-2}$。\n- 指数函数和对数函数要求无量纲输入并产生无量纲输出。\n\n程序目标。您的程序必须：\n- 编码一个小型的表达式代数，支持变量、常量和上述算子。\n- 对每个候选方程，独立计算左侧和右侧每一项的量纲。\n- 返回一个布尔值，指示所有右侧项的量纲是否与左侧匹配，以及是否满足所有特殊函数约束。\n\n物理单位和数值单位。这个问题纯粹是关于量纲的；不要求任何数值。布尔值是无单位的，应以编程语言术语中的 $true$ 或 $false$ 值的形式返回。\n\n测试套件。检查以下九个案例，每个案例都以一个包含左侧和一项或多项右侧项的方程形式给出。对于每个案例，如果方程在上述规则下量纲一致，则返回 $true$，否则返回 $false$。\n\n- 案例 $1$ (物质扩散，一致)：\n  - 左侧：$\\dfrac{\\partial c}{\\partial t}$。\n  - 右侧项：$D \\, \\nabla^{2} c$。\n\n- 案例 $2$ (物质扩散，不一致的额外项)：\n  - 左侧：$\\dfrac{\\partial c}{\\partial t}$。\n  - 右侧项：$D \\, \\nabla^{2} c$, $\\kappa \\, \\nabla^{2} \\phi$。\n\n- 案例 $3$ (电解质电荷守恒，一致)：\n  - 左侧：$\\nabla \\cdot i$。\n  - 右侧项：$a \\, F \\, j$。\n\n- 案例 $4$ (电解质电荷守恒，因缺少比面积而不一致)：\n  - 左侧：$\\nabla \\cdot i$。\n  - 右侧项：$F \\, j$。\n\n- 案例 $5$ (包含焦耳热的能量平衡，一致)：\n  - 左侧：$\\rho \\, c_{p} \\, \\dfrac{\\partial T}{\\partial t}$。\n  - 右侧项：$k \\, \\nabla^{2} T$, $\\sigma \\, \\left| \\nabla \\phi \\right|^{2}$。\n\n- 案例 $6$ (能量平衡，不一致的焦耳热项形式)：\n  - 左侧：$\\rho \\, c_{p} \\, \\dfrac{\\partial T}{\\partial t}$。\n  - 右侧项：$k \\, \\nabla^{2} T$, $\\sigma \\, \\nabla \\phi$。\n\n- 案例 $7$ (Arrhenius 型表面反应速率，一致)：\n  - 左侧：$j$。\n  - 右侧项：$k_{0} \\, \\exp\\!\\left( - \\dfrac{E_{a}}{R \\, T} \\right) \\, c$。\n\n- 案例 $8$ (Arrhenius 型表面反应速率，指数参数不一致)：\n  - 左侧：$j$。\n  - 右侧项：$k_{0} \\, \\exp\\!\\left( - \\dfrac{E_{a}}{T} \\right) \\, c$。\n\n- 案例 $9$ (无量纲乘数保持一致性)：\n  - 左侧：$\\dfrac{\\partial c}{\\partial t}$。\n  - 右侧项：$\\varepsilon \\, \\dfrac{\\partial c}{\\partial t}$。\n\n最终输出格式。您的程序应生成单行输出，其中包含一个逗号分隔的列表，用方括号括起来，表示上述九个案例的结果（例如，$[true,false,true,\\dots]$）。在 Python 中，使用内置的布尔字面量，不改变大小写，因此输出应类似于 $[True,False,True,\\dots]$。",
            "solution": "验证候选控制方程的量纲一致性是物理学和工程学中的一个基本步骤，它确保数学模型尊重量纲齐次性原则。该原则指出，一个方程只有在其所有相加项都具有相同的物理量纲时，才具有物理意义。解决方案涉及实现一个计算框架，以根据一组关于物理量和数学算子的预定义规则自动执行此验证。\n\n该方法的核心是将任何物理量的量纲表示为一个指数向量，这些指数对应于一组基本量纲。对于本问题，六个基本量纲是质量 ($M$)、长度 ($L$)、时间 ($T$)、电流 ($I$)、热力学温度 ($\\Theta$) 和物质的量 ($N$)。因此，任何量纲都可以用一个由实数组成的 $6$ 元素向量 $[d_M, d_L, d_T, d_I, d_\\Theta, d_N]$ 来表示。例如，电解质浓度 $c$ 的单位是 $mol \\, m^{-3}$，即量纲为 $N L^{-3}$，表示为向量 $[0, -3, 0, 0, 0, 1]$。无量纲量的指数向量为 $[0, 0, 0, 0, 0, 0]$。\n\n量纲分析的代数运算随后被映射为向量运算：\n1.  **乘法**：当两个量相乘 ($A \\cdot B$) 时，它们的量纲向量相加。如果 $\\dim(A) = \\vec{v}_A$ 且 $\\dim(B) = \\vec{v}_B$，则 $\\dim(A \\cdot B) = \\vec{v}_A + \\vec{v}_B$。\n2.  **除法**：当一个量被另一个量除 ($A / B$) 时，它们的量纲向量相减：$\\dim(A / B) = \\vec{v}_A - \\vec{v}_B$。\n3.  **幂**：将一个量提升到 $p$ 次幂 ($A^p$) 会将其量纲向量乘以 $p$：$\\dim(A^p) = p \\cdot \\vec{v}_A$。\n4.  **加/减法**：对于要相加或相减的项 ($A + B$)，它们必须是量纲齐次的，即 $\\dim(A) = \\dim(B)$。结果具有相同的量纲。\n5.  **算子**：微分算子也对量纲有贡献。时间导数 $\\partial/\\partial t$ 引入 $T^{-1}$ 的量纲（向量 $[0, 0, -1, 0, 0, 0]$），而空间算子如梯度 ($\\nabla$) 或散度 ($\\nabla \\cdot$) 引入 $L^{-1}$ 的量纲（向量 $[0, -1, 0, 0, 0, 0]$）。拉普拉斯算子 ($\\nabla^2$) 引入 $L^{-2}$ 的量纲（向量 $[0, -2, 0, 0, 0, 0]$）。\n6.  **特殊函数**：超越函数如 $\\exp(\\cdot)$ 和 $\\log(\\cdot)$ 仅对无量纲参数有定义。函数本身及其参数都必须是无量纲的。\n\n要验证一个形式为 $LHS = T_1 + T_2 + \\dots + T_n$ 的方程，我们执行以下步骤：\n1.  计算左侧的量纲向量 $\\vec{d}_{LHS}$。\n2.  对右侧的每一项 $T_i$，计算其量纲向量 $\\vec{d}_{T_i}$。在此计算过程中，必须验证对特殊函数参数的所有约束。如果发现任何参数（例如 $\\exp$ 函数的参数）是有量纲的，则整个方程立即被宣布为无效。\n3.  将右侧每一项的量纲向量与左侧的向量进行比较。当且仅当 $\\vec{d}_{LHS} = \\vec{d}_{T_1} = \\vec{d}_{T_2} = \\dots = \\vec{d}_{T_n}$ 且所有特殊函数约束都得到满足时，方程才有效。\n\n让我们用两个测试案例来说明：\n\n**案例 1 (一致): $\\dfrac{\\partial c}{\\partial t} = D \\, \\nabla^{2} c$**\n- 变量量纲：$\\dim(c) = N L^{-3} \\implies [0, -3, 0, 0, 0, 1]$，$\\dim(D) = L^{2} T^{-1} \\implies [0, 2, -1, 0, 0, 0]$。\n- 算子量纲：$\\dim(\\partial/\\partial t) = T^{-1} \\implies [0, 0, -1, 0, 0, 0]$，$\\dim(\\nabla^2) = L^{-2} \\implies [0, -2, 0, 0, 0, 0]$。\n- 左侧 (LHS)：$\\dim(\\frac{\\partial c}{\\partial t}) = \\dim(c) + \\dim(\\frac{\\partial}{\\partial t}) = [0, -3, 0, 0, 0, 1] + [0, 0, -1, 0, 0, 0] = [0, -3, -1, 0, 0, 1]$。\n- 右侧 (RHS)：$\\dim(D \\nabla^2 c) = \\dim(D) + \\dim(\\nabla^2) + \\dim(c) = [0, 2, -1, 0, 0, 0] + [0, -2, 0, 0, 0, 0] + [0, -3, 0, 0, 0, 1] = [0, -3, -1, 0, 0, 1]$。\n- 因为 $\\dim(LHS) = \\dim(RHS)$，所以该方程量纲一致 ($True$)。\n\n**案例 8 (不一致): $j = k_{0} \\, \\exp\\!\\left( - \\dfrac{E_{a}}{T} \\right) \\, c$**\n- 该方程涉及一个特殊函数 $\\exp(\\cdot)$，其参数必须是无量纲的。\n- 变量量纲：$\\dim(E_a) = M L^2 T^{-2} N^{-1} \\implies [1, 2, -2, 0, 0, -1]$，$\\dim(T_{temp}) = \\Theta \\implies [0, 0, 0, 0, 1, 0]$。\n- $\\exp$ 的参数：$\\dim(\\frac{E_a}{T_{temp}}) = \\dim(E_a) - \\dim(T_{temp}) = [1, 2, -2, 0, 0, -1] - [0, 0, 0, 0, 1, 0] = [1, 2, -2, 0, -1, -1]$。\n- 结果向量不是零向量 $[0, 0, 0, 0, 0, 0]$，所以参数不是无量纲的。\n- 指数函数的约束被违反。因此，该方程量纲无效 ($False$)，无需进行进一步检查。\n\n对所有九个测试案例实施这一系统性程序，以生成最终的布尔结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the dimensional analysis problem by defining a checker class,\n    running through the test cases, and printing the results.\n    \"\"\"\n\n    class DimensionalityChecker:\n        \"\"\"\n        A class to perform dimensional analysis on physical equations.\n        It represents dimensions as 6D vectors (M, L, T, I, Theta, N)\n        and checks for consistency based on predefined rules.\n        \"\"\"\n        def __init__(self):\n            # Base dimensions are represented by a 6-element numpy array corresponding\n            # to the exponents of Mass, Length, Time, Current, Temperature, and Moles.\n            # M, L, T, I, Theta, N\n            self.dims = {\n                'c':      np.array([0, -3,  0,  0,  0,  1]), # N L^-3\n                'phi':    np.array([1,  2, -3, -1,  0,  0]), # M L^2 T^-3 I^-1\n                'i':      np.array([0, -2,  0,  1,  0,  0]), # I L^-2\n                'D':      np.array([0,  2, -1,  0,  0,  0]), # L^2 T^-1\n                'j':      np.array([0, -2, -1,  0,  0,  1]), # N L^-2 T^-1\n                'F':      np.array([0,  0,  1,  1,  0, -1]), # I T N^-1\n                'a':      np.array([0, -1,  0,  0,  0,  0]), # L^-1\n                'kappa':  np.array([-1,-3,  3,  2,  0,  0]), # M^-1 L^-3 T^3 I^2\n                'sigma':  np.array([-1,-3,  3,  2,  0,  0]), # M^-1 L^-3 T^3 I^2\n                'k':      np.array([1,  1, -3,  0, -1,  0]), # M L T^-3 Theta^-1\n                'rho':    np.array([1, -3,  0,  0,  0,  0]), # M L^-3\n                'cp':     np.array([0,  2, -2,  0, -1,  0]), # L^2 T^-2 Theta^-1\n                'T_':     np.array([0,  0,  0,  0,  1,  0]), # Theta (Temp)\n                'R':      np.array([1,  2, -2,  0, -1, -1]), # M L^2 T^-2 N^-1 Theta^-1\n                'Ea':     np.array([1,  2, -2,  0,  0, -1]), # M L^2 T^-2 N^-1\n                'eps':    np.array([0,  0,  0,  0,  0,  0]), # dimensionless\n                'k0':     np.array([0,  1, -1,  0,  0,  0]), # L T^-1\n            }\n            self.op_dims = {\n                'dt':        np.array([0,  0, -1,  0,  0,  0]), # T^-1\n                'grad_div':  np.array([0, -1,  0,  0,  0,  0]), # L^-1\n                'laplacian': np.array([0, -2,  0,  0,  0,  0]), # L^-2\n            }\n            self.DIMENSIONLESS = np.array([0, 0, 0, 0, 0, 0])\n\n        def get_dim(self, key):\n            \"\"\"Returns a copy of the dimensional vector for a variable or operator.\"\"\"\n            if key in self.dims:\n                return self.dims[key].copy()\n            return self.op_dims[key].copy()\n\n        def is_dimensionless(self, dim_vector):\n            \"\"\"Checks if a dimensional vector corresponds to a dimensionless quantity.\"\"\"\n            return np.array_equal(dim_vector, self.DIMENSIONLESS)\n\n        def check_equation(self, lhs_calc, rhs_calcs):\n            \"\"\"\n            Checks a single equation for dimensional consistency.\n\n            Args:\n                lhs_calc (callable): A function that computes the LHS dimensions.\n                rhs_calcs (list[callable]): A list of functions for each RHS term.\n\n            Returns:\n                bool: True if the equation is consistent, False otherwise.\n            \"\"\"\n            try:\n                lhs_dim = lhs_calc()\n                if lhs_dim is None: return False\n\n                for calc in rhs_calcs:\n                    rhs_dim = calc()\n                    if rhs_dim is None or not np.array_equal(lhs_dim, rhs_dim):\n                        return False\n                return True\n            except Exception:\n                return False\n\n    checker = DimensionalityChecker()\n    results = []\n\n    # Case 1: ∂c/∂t = D ∇²c\n    case1_lhs = lambda: checker.get_dim('c') + checker.get_dim('dt')\n    case1_rhs1 = lambda: checker.get_dim('D') + checker.get_dim('laplacian') + checker.get_dim('c')\n    results.append(checker.check_equation(case1_lhs, [case1_rhs1]))\n\n    # Case 2: ∂c/∂t = D ∇²c + κ ∇²ϕ\n    case2_rhs2 = lambda: checker.get_dim('kappa') + checker.get_dim('laplacian') + checker.get_dim('phi')\n    results.append(checker.check_equation(case1_lhs, [case1_rhs1, case2_rhs2]))\n\n    # Case 3: ∇⋅i = a F j\n    case3_lhs = lambda: checker.get_dim('grad_div') + checker.get_dim('i')\n    case3_rhs1 = lambda: checker.get_dim('a') + checker.get_dim('F') + checker.get_dim('j')\n    results.append(checker.check_equation(case3_lhs, [case3_rhs1]))\n\n    # Case 4: ∇⋅i = F j\n    case4_rhs1 = lambda: checker.get_dim('F') + checker.get_dim('j')\n    results.append(checker.check_equation(case3_lhs, [case4_rhs1]))\n\n    # Case 5: ρ cp ∂T/∂t = k ∇²T + σ |∇ϕ|²\n    case5_lhs = lambda: checker.get_dim('rho') + checker.get_dim('cp') + checker.get_dim('dt') + checker.get_dim('T_')\n    case5_rhs1 = lambda: checker.get_dim('k') + checker.get_dim('laplacian') + checker.get_dim('T_')\n    def case5_rhs2():\n        grad_phi_dim = checker.get_dim('grad_div') + checker.get_dim('phi')\n        norm_sq_grad_phi_dim = grad_phi_dim * 2\n        return checker.get_dim('sigma') + norm_sq_grad_phi_dim\n    results.append(checker.check_equation(case5_lhs, [case5_rhs1, case5_rhs2]))\n\n    # Case 6: ρ cp ∂T/∂t = k ∇²T + σ ∇ϕ\n    case6_rhs2 = lambda: checker.get_dim('sigma') + checker.get_dim('grad_div') + checker.get_dim('phi')\n    results.append(checker.check_equation(case5_lhs, [case5_rhs1, case6_rhs2]))\n\n    # Case 7: j = k₀ exp(-Eₐ/(RT)) c\n    case7_lhs = lambda: checker.get_dim('j')\n    def case7_rhs1():\n        exp_arg_dim = checker.get_dim('Ea') - (checker.get_dim('R') + checker.get_dim('T_'))\n        if not checker.is_dimensionless(exp_arg_dim):\n            return None  # Invalid operation\n        return checker.get_dim('k0') + checker.DIMENSIONLESS + checker.get_dim('c')\n    results.append(checker.check_equation(case7_lhs, [case7_rhs1]))\n\n    # Case 8: j = k₀ exp(-Eₐ/T) c\n    def case8_rhs1():\n        exp_arg_dim = checker.get_dim('Ea') - checker.get_dim('T_')\n        if not checker.is_dimensionless(exp_arg_dim):\n            return None  # Invalid operation\n        return checker.get_dim('k0') + checker.DIMENSIONLESS + checker.get_dim('c')\n    results.append(checker.check_equation(case7_lhs, [case8_rhs1]))\n\n    # Case 9: ∂c/∂t = ε ∂c/∂t\n    case9_rhs1 = lambda: checker.get_dim('eps') + checker.get_dim('dt') + checker.get_dim('c')\n    results.append(checker.check_equation(case1_lhs, [case9_rhs1]))\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "从数据中发现控制方程是本领域的核心任务，而评估所发现模型的不确定性同样重要。本练习模拟了一个完整的发现流程：首先从一个已知的反应扩散偏微分方程（PDE）生成带噪声的合成数据，然后利用这些数据反向推断出方程的系数。更重要的是，您将通过实践  学习并实现一种强大的非参数方法——“自举法”（bootstrapping），为发现的系数计算置信区间，从而对模型的可靠性进行量化评估。",
            "id": "3904092",
            "problem": "您的任务是实现一个严谨的、数据驱动的流程，用于估计和量化多孔电极中均质化一维锂浓度场的控制偏微分方程（PDE）的系数不确定性，该流程适用于自动化电池设计和仿真。此任务的科学基础是物质质量守恒和菲克扩散。具体来说，假设长度为 $L$ 的一维周期性域上的锂浓度场 $c(x,t)$ 遵循质量守恒，其通量为 $J$，并有一个线性体积反应汇：\n$$\\frac{\\partial c}{\\partial t} + \\frac{\\partial J}{\\partial x} = R,$$\n其中菲克通量为 $J = -D \\frac{\\partial c}{\\partial x}$，线性反应为 $R = -k c$。这里，$D$ 是扩散系数，$k$ 是一级反应速率常数。在这些假设下，控制偏微分方程为\n$$\\frac{\\partial c}{\\partial t} = D \\frac{\\partial^2 c}{\\partial x^2} - k c.$$\n\n您将通过解析求解上述在周期性域上的PDE来生成合成的、物理上合理的数据，初始条件为正弦傅里叶模态的叠加。设\n$$c(x,0) = c_0 + A_1 \\sin\\left(\\frac{2\\pi x}{L}\\right) + A_2 \\sin\\left(\\frac{4\\pi x}{L}\\right),$$\n对于 $t \\ge 0$，其精确解为\n$$c(x,t) = c_0 e^{-k t} + A_1 \\exp\\left(-\\left[k + D\\left(\\frac{2\\pi}{L}\\right)^2\\right] t\\right) \\sin\\left(\\frac{2\\pi x}{L}\\right) + A_2 \\exp\\left(-\\left[k + D\\left(\\frac{4\\pi}{L}\\right)^2\\right] t\\right) \\sin\\left(\\frac{4\\pi x}{L}\\right)。$$\n\n为了模拟测量噪声，在每个时空网格点上向 $c(x,t)$ 添加标准差为 $\\sigma$ 的独立的、零均值的高斯噪声。使用具有 $N_x$ 个点和间距 $\\Delta x = L/N_x$ 的均匀空间网格，以及具有 $N_t$ 个点和时间步长 $\\Delta t$ 的均匀时间采样。在近似空间导数时，使用空间上的周期性边界条件。将时间导数和空间二阶导数的离散近似计算为\n$$c_t(x_i,t_j) \\approx \\frac{c(x_i,t_{j+1}) - c(x_i,t_j)}{\\Delta t}, \\quad c_{xx}(x_i,t_j) \\approx \\frac{c(x_{i-1},t_j) - 2 c(x_i,t_j) + c(x_{i+1},t_j)}{\\Delta x^2},$$\n由于周期性，空间索引在模 $N_x$ 的意义下解释。\n\n将发现候选库限制在两个函数 $\\{c_{xx},\\, c\\}$，并执行以下形式的线性回归\n$$c_t = \\Theta \\, \\xi,$$\n其中 $\\Theta = [\\, c_{xx},\\; c\\,]$ 且 $\\xi = [\\, D,\\; -k\\,]^\\top$。使用普通最小二乘法来估计 $\\hat{\\xi}$。\n\n为了量化不确定性，通过有放回地重采样时空斑块来进行非参数自举法（bootstrapping）。一个时空斑块是 $(x,t)$ 网格上大小为 $p_x \\times p_t$ 的轴对齐子数组，由连续的空间索引（具有周期性环绕）和连续的时间索引构成。对于每个自举复制，有放回地采样 $M$ 个斑块，连接它们的扁平化数据向量以形成回归数据，估计 $\\hat{\\xi}^{(b)}$，并对 $B$ 个复制重复此过程。使用经验百分位数法，基于相应估计的自举分布，为 $D$ 和 $k$ 构建双侧 $95\\%$ 置信区间（CI）。报告来自 $M$ 个斑块的完整（未重采样）集合的点估计。\n\n所有量必须以国际单位制（SI units）表示：$D$ 以 $\\mathrm{m^2/s}$ 报告，$k$ 以 $\\mathrm{s^{-1}}$ 报告。角度不出现，因此不需要角度单位。输出中不要使用百分比；将所有置信区间边界表示为浮点数。\n\n实现一个单一程序，该程序：\n- 生成合成数据集，\n- 构建离散导数近似，\n- 定义和采样时空斑块，\n- 对斑块进行自举重采样，\n- 估计系数和 $95\\%$ 置信区间。\n\n使用以下测试套件。对于每个测试用例，您必须使用指定的参数。在所有情况下，除非另有说明，否则使用 $c_0 = 1000$ (单位 $\\mathrm{mol/m^3}$)、$A_1 = 50$ (单位 $\\mathrm{mol/m^3}$) 和 $A_2 = 30$ (单位 $\\mathrm{mol/m^3}$)。空间域长度为 $L = 10^{-3}$ (单位 $\\mathrm{m}$)。对于周期性，在空间上对索引 $N_x$ 取模。\n\n- 测试用例 1 (一般情况):\n    - $D = 5 \\times 10^{-12}$, $k = 10^{-3}$, $L = 10^{-3}$, $N_x = 128$, $N_t = 120$, $\\Delta t = 0.5$, $\\sigma = 10^{-6}$, $p_x = 16$, $p_t = 20$, $M = 50$, $B = 200$。\n- 测试用例 2 (无噪声情况):\n    - $D = 5 \\times 10^{-12}$, $k = 10^{-3}$, $L = 10^{-3}$, $N_x = 128$, $N_t = 120$, $\\Delta t = 0.5$, $\\sigma = 0$, $p_x = 32$, $p_t = 30$, $M = 40$, $B = 150$。\n- 测试用例 3 (更高反应速率和更高噪声):\n    - $D = 5 \\times 10^{-12}$, $k = 2 \\times 10^{-3}$, $L = 10^{-3}$, $N_x = 96$, $N_t = 100$, $\\Delta t = 0.5$, $\\sigma = 5 \\times 10^{-6}$, $p_x = 12$, $p_t = 16$, $M = 60$, $B = 200$。\n- 测试用例 4 (小数据集和较弱的扩散/反应):\n    - $D = 10^{-12}$, $k = 5 \\times 10^{-4}$, $L = 10^{-3}$, $N_x = 64$, $N_t = 80$, $\\Delta t = 0.5$, $\\sigma = 10^{-6}$, $p_x = 8$, $p_t = 10$, $M = 12$, $B = 60$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。每个测试用例必须产生一个包含六个浮点数的列表，顺序为\n$$[\\, \\hat{D},\\; \\hat{k},\\; D_{\\mathrm{low}},\\; D_{\\mathrm{high}},\\; k_{\\mathrm{low}},\\; k_{\\mathrm{high}}\\,],$$\n其中 $\\hat{D}$ 和 $\\hat{k}$ 是点估计值 (单位为 $\\mathrm{m^2/s}$ 和 $\\mathrm{s^{-1}}$)，而 $(D_{\\mathrm{low}}, D_{\\mathrm{high}})$ 和 $(k_{\\mathrm{low}}, k_{\\mathrm{high}})$ 分别是双侧 $95\\%$ 置信区间的下界和上界。因此，最终输出必须是一个包含四个此类列表的列表，每个测试用例一个，例如\n$$[ [d_1,k_1,d_{1,\\ell},d_{1,u},k_{1,\\ell},k_{1,u}], [d_2,k_2,d_{2,\\ell},d_{2,u},k_{2,\\ell},k_{2,u}], [d_3,k_3,d_{3,\\ell},d_{3,u},k_{3,\\ell},k_{3,u}], [d_4,k_4,d_{4,\\ell},d_{4,u},k_{4,\\ell},k_{4,u}] ]。$$",
            "solution": "设计从物质质量守恒和菲克扩散出发，结合线性反应动力学。在一维中，守恒表述为\n$$\\frac{\\partial c}{\\partial t} + \\frac{\\partial J}{\\partial x} = R,$$\n其中 $c(x,t)$ 是嵌入锂的浓度，$J(x,t)$ 是空间通量，$R(x,t)$ 是体积反应项。在菲克扩散下，通量为 $J = -D \\frac{\\partial c}{\\partial x}$，其中 $D$ 是扩散系数。在偏离平衡较小的情况下，一级动力学将体积反应近似为 $R = -k c$，其中 $k$ 是一个速率常数。代入这些本构关系，得到控制偏微分方程 (PDE)\n$$\\frac{\\partial c}{\\partial t} = D \\frac{\\partial^2 c}{\\partial x^2} - k c.$$\n\n该PDE是线性常系数的，并且在周期性边界条件下允许傅里叶模态解。如果初始条件是正弦模态的叠加，\n$$c(x,0) = c_0 + A_1 \\sin\\left(\\frac{2\\pi x}{L}\\right) + A_2 \\sin\\left(\\frac{4\\pi x}{L}\\right),$$\n那么每个傅里叶模态都独立衰减。零模态衰减为 $c_0 e^{-k t}$，而正弦模态衰减为\n$$A_n \\exp\\left(-\\left[k + D\\left(\\frac{2\\pi n}{L}\\right)^2\\right] t\\right) \\sin\\left(\\frac{2\\pi n x}{L}\\right),$$\n对于 $n \\in \\{1,2\\}$。因此，精确解为\n$$c(x,t) = c_0 e^{-k t} + A_1 \\exp\\left(-\\left[k + D\\left(\\frac{2\\pi}{L}\\right)^2\\right] t\\right) \\sin\\left(\\frac{2\\pi x}{L}\\right) + A_2 \\exp\\left(-\\left[k + D\\left(\\frac{4\\pi}{L}\\right)^2\\right] t\\right) \\sin\\left(\\frac{4\\pi x}{L}\\right)。$$\n\n为模拟真实的数据采集，向 $c(x,t)$ 的每个时空样本添加标准差为 $\\sigma$ 的独立零均值高斯噪声。使用具有 $N_x$ 个点、间距为 $\\Delta x = L/N_x$ 和周期性索引的均匀空间网格，以及具有 $N_t$ 个点、时间步长为 $\\Delta t$ 的均匀时间网格来离散化域。使用有限差分，时间导数和空间二阶导数近似为\n$$c_t(x_i,t_j) \\approx \\frac{c(x_i,t_{j+1}) - c(x_i,t_j)}{\\Delta t},$$\n$$c_{xx}(x_i,t_j) \\approx \\frac{c(x_{i-1},t_j) - 2 c(x_i,t_j) + c(x_{i+1},t_j)}{\\Delta x^2},$$\n其中 $i \\in \\{0,1,\\dots,N_x-1\\}$ 和 $j \\in \\{0,1,\\dots,N_t-2\\}$，并且由于周期性边界，空间索引在模 $N_x$ 的意义下求值。\n\n对于数据驱动的发现，我们将候选项库限制为 $\\{c_{xx},\\, c\\}$，并假设一个线性回归关系\n$$c_t = \\Theta \\, \\xi,$$\n其中 $\\Theta = [\\, c_{xx},\\; c\\,]$，系数向量 $\\xi = [\\, \\xi_1,\\; \\xi_2\\,]^\\top$ 映射到物理量为 $\\xi_1 = D$ 和 $\\xi_2 = -k$。普通最小二乘估计量通过最小化\n$$\\min_{\\xi} \\| \\Theta \\xi - y \\|_2^2$$\n得到，其中 $y$ 表示 $c_t$ 样本的向量。解是 Moore–Penrose 最小二乘估计\n$$\\hat{\\xi} = (\\Theta^\\top \\Theta)^{-1} \\Theta^\\top y,$$\n假设 $\\Theta^\\top \\Theta$ 是非奇异的，对于足够多样化的斑块，此条件通常是满足的。\n\n为了真实地建模空间和时间相关性并获得有效的不确定性量化，我们在时空斑块的层面上应用非参数自举法。一个斑块被定义为 $(x,t)$ 网格上大小为 $p_x \\times p_t$ 的轴对齐子数组，由连续的空间索引（具有周期性环绕）和连续的时间索引构成。对于每个自举复制 $b \\in \\{1,2,\\dots,B\\}$，我们从可用的斑块集中有放回地采样 $M$ 个斑块，连接扁平化的斑块数据 $c_t$、$c_{xx}$ 和 $c$ 以构建回归矩阵 $\\Theta^{(b)}$ 和向量 $y^{(b)}$，并通过最小二乘法计算 $\\hat{\\xi}^{(b)}$。这将产生自举样本 $\\{\\hat{\\xi}^{(b)}\\}_{b=1}^B$。使用经验百分位数法，$D$ 的双侧 $95\\%$ 置信区间（CI）是 $\\{ \\hat{\\xi}_1^{(b)} \\}$ 的第 $2.5$ 和第 $97.5$ 百分位数之间的区间，而 $k$ 的置信区间则类似地从 $\\{ -\\hat{\\xi}_2^{(b)} \\}$ 导出。点估计 $(\\hat{D}, \\hat{k})$ 是从 $M$ 个斑块的完整（未重采样）集合中计算出来的。\n\n每个测试用例的算法步骤如下：\n- 根据指定，固定 $D$、$k$、$L$、$N_x$、$N_t$、$\\Delta t$、$\\sigma$、$p_x$、$p_t$、$M$ 和 $B$。\n- 构建 $x_i = i \\Delta x$ (对于 $i \\in \\{0,\\dots,N_x-1\\}$) 和 $t_j = j \\Delta t$ (对于 $j \\in \\{0,\\dots,N_t-1\\}$)。\n- 使用精确公式评估 $c(x_i,t_j)$，然后添加标准差为 $\\sigma$ 的独立高斯噪声。\n- 计算在 $j \\in \\{0,\\dots,N_t-2\\}$ 上的 $c_t(x_i,t_j)$ 和 $c_{xx}(x_i,t_j)$ 的离散数组，并收集在 $j \\in \\{0,\\dots,N_t-2\\}$ 上的 $c(x_i,t_j)$ 以与 $c_t$ 对齐。\n- 随机均匀采样 $M$ 个时空斑块：选择空间起始索引 $s_x \\in \\{0,\\dots,N_x-1\\}$（具有周期性环绕）和时间起始索引 $s_t \\in \\{0,\\dots,N_t-2-p_t+1\\}$，提取 $p_x \\times p_t$ 的块，并将其扁平化。\n- 通过求解 $y = \\Theta \\xi$ 计算全数据最小二乘估计 $(\\hat{D}, \\hat{k})$，记住 $\\xi_2 = -k$。\n- 执行 $B$ 次自举复制，方法是有放回地重采样 $M$ 个斑块，对每个复制求解最小二乘法，并为 $D$ 和 $k$ 形成经验百分位数 $95\\%$ 置信区间。\n- 以国际单位制返回 $[\\, \\hat{D},\\; \\hat{k},\\; D_{\\mathrm{low}},\\; D_{\\mathrm{high}},\\; k_{\\mathrm{low}},\\; k_{\\mathrm{high}}\\,]$。\n\n测试套件包括四个案例，它们共同探究了算法在各种条件下的行为：一个具有中等噪声的通用“理想路径”情况，一个用于测试一致性的无噪声情况，一个具有更高噪声的更高反应速率情况以测试鲁棒性，以及一个用于测试在有限数据下性能的小数据集情况。最终输出是包含四个结果列表的单行列表，按测试用例定义排序。不应打印任何附加文本。",
            "answer": "```python\nimport numpy as np\n\n# Set a global random seed for reproducibility\nnp.random.seed(123)\n\ndef generate_concentration(D, k, L, Nx, Nt, dt, c0=1000.0, A1=50.0, A2=30.0):\n    \"\"\"\n    Generate the exact solution c(x,t) for the diffusion-reaction PDE on a periodic domain,\n    using the specified initial condition composed of sine modes and a constant offset.\n    Returns an array C of shape (Nt, Nx).\n    \"\"\"\n    x = np.linspace(0.0, L, Nx, endpoint=False)  # spatial grid\n    t = dt * np.arange(Nt)                       # time grid\n\n    # Wavenumbers for the sine modes\n    k1 = 2.0 * np.pi / L\n    k2 = 4.0 * np.pi / L\n\n    # Mode decay rates\n    decay0 = np.exp(-k * t)  # zero mode\n    decay1 = np.exp(-(k + D * (k1 ** 2)) * t)\n    decay2 = np.exp(-(k + D * (k2 ** 2)) * t)\n\n    # Construct solution: broadcast over x\n    C = (\n        (c0 * decay0)[:, None]\n        + (A1 * decay1)[:, None] * np.sin(k1 * x)[None, :]\n        + (A2 * decay2)[:, None] * np.sin(k2 * x)[None, :]\n    )\n    return C\n\ndef add_noise(C, sigma):\n    \"\"\"\n    Add independent Gaussian noise with standard deviation sigma to the concentration data.\n    \"\"\"\n    if sigma == 0.0:\n        return C.copy()\n    noise = np.random.normal(loc=0.0, scale=sigma, size=C.shape)\n    return C + noise\n\ndef compute_derivatives(C, L, dt):\n    \"\"\"\n    Compute discrete time derivative c_t and second spatial derivative c_xx with periodic wrapping.\n    c_t is computed using forward differences over time.\n    c_xx is computed using central differences in space (periodic).\n    Returns (ct, cxx, c_slice) where ct and cxx have shape (Nt-1, Nx) and c_slice aligns with ct in time.\n    \"\"\"\n    Nt, Nx = C.shape\n    dx = L / Nx\n\n    # Time derivative using forward difference: shape (Nt-1, Nx)\n    ct = (C[1:, :] - C[:-1, :]) / dt\n\n    # Second spatial derivative at times 0..Nt-2 to align with ct\n    C_time = C[:-1, :]  # shape (Nt-1, Nx)\n    # Periodic roll for spatial neighbors\n    C_left = np.roll(C_time, shift=1, axis=1)\n    C_right = np.roll(C_time, shift=-1, axis=1)\n\n    cxx = (C_left - 2.0 * C_time + C_right) / (dx ** 2)\n\n    # c aligned with ct in time\n    c_slice = C_time.copy()\n\n    return ct, cxx, c_slice\n\ndef sample_patches(ct, cxx, c_slice, px, pt, M):\n    \"\"\"\n    Sample M space-time patches with replacement.\n    Spatial dimension wraps periodically; time does not wrap.\n    Returns a list of patches, each patch is a tuple (y_flat, Theta_flat)\n    where y_flat is ct flattened and Theta_flat has columns [cxx_flat, c_flat].\n    \"\"\"\n    T, Nx = ct.shape  # T = Nt-1\n    patches = []\n\n    # Valid time start indices to fit pt within T\n    max_t_start = T - pt\n    if max_t_start  0:\n        raise ValueError(\"Patch time size exceeds available time samples.\")\n\n    for _ in range(M):\n        s_t = np.random.randint(0, max_t_start + 1)\n        s_x = np.random.randint(0, Nx)  # start in space; will wrap\n\n        # Spatial indices with periodic wrapping\n        idx = (s_x + np.arange(px)) % Nx\n\n        # Extract blocks and flatten in row-major\n        ct_patch = ct[s_t:s_t + pt, :][:, idx].reshape(-1)\n        cxx_patch = cxx[s_t:s_t + pt, :][:, idx].reshape(-1)\n        c_patch = c_slice[s_t:s_t + pt, :][:, idx].reshape(-1)\n\n        # Build Theta for this patch\n        Theta_patch = np.column_stack([cxx_patch, c_patch])\n\n        patches.append((ct_patch, Theta_patch))\n\n    return patches\n\ndef aggregate_patches(patches):\n    \"\"\"\n    Concatenate all patch data into a single regression dataset.\n    Returns y (vector) and Theta (matrix).\n    \"\"\"\n    y_list = []\n    Theta_list = []\n    for y_p, Th_p in patches:\n        y_list.append(y_p)\n        Theta_list.append(Th_p)\n    y = np.concatenate(y_list, axis=0)\n    Theta = np.vstack(Theta_list)\n    return y, Theta\n\ndef estimate_coefficients(y, Theta):\n    \"\"\"\n    Ordinary least squares estimate of xi in y = Theta @ xi.\n    Returns xi_hat (length-2 vector).\n    \"\"\"\n    # Use numpy lstsq for numerical stability\n    xi_hat, _, _, _ = np.linalg.lstsq(Theta, y, rcond=None)\n    return xi_hat\n\ndef bootstrap_ci(patches, B):\n    \"\"\"\n    Perform B bootstrap replicates by resampling patches with replacement.\n    Returns arrays of bootstrap estimates for D_hat and k_hat (k_hat computed as -xi2).\n    \"\"\"\n    P = len(patches)\n    D_boot = np.zeros(B)\n    k_boot = np.zeros(B)\n    for b in range(B):\n        # Sample patch indices with replacement\n        idx = np.random.randint(0, P, size=P)\n        resampled = [patches[i] for i in idx]\n        y_b, Theta_b = aggregate_patches(resampled)\n        xi_b = estimate_coefficients(y_b, Theta_b)\n        D_boot[b] = xi_b[0]\n        k_boot[b] = -xi_b[1]\n    return D_boot, k_boot\n\ndef run_case(D_true, k_true, L, Nx, Nt, dt, sigma, px, pt, M, B):\n    \"\"\"\n    Run the full pipeline for a single test case:\n    - Generate synthetic data\n    - Compute derivatives\n    - Sample patches\n    - Estimate coefficients\n    - Bootstrap confidence intervals\n    Returns [D_hat, k_hat, D_low, D_high, k_low, k_high]\n    \"\"\"\n    # Generate concentration and add noise\n    C = generate_concentration(D_true, k_true, L, Nx, Nt, dt)\n    C_noisy = add_noise(C, sigma)\n\n    # Derivatives\n    ct, cxx, c_slice = compute_derivatives(C_noisy, L, dt)\n\n    # Sample patches\n    patches = sample_patches(ct, cxx, c_slice, px, pt, M)\n\n    # Point estimate from full (non-resampled) set of M patches\n    y_all, Theta_all = aggregate_patches(patches)\n    xi_hat = estimate_coefficients(y_all, Theta_all)\n    D_hat = float(xi_hat[0])\n    k_hat = float(-xi_hat[1])\n\n    # Bootstrap\n    D_boot, k_boot = bootstrap_ci(patches, B)\n\n    # 95% percentile CIs\n    D_low = float(np.percentile(D_boot, 2.5))\n    D_high = float(np.percentile(D_boot, 97.5))\n    k_low = float(np.percentile(k_boot, 2.5))\n    k_high = float(np.percentile(k_boot, 97.5))\n\n    return [D_hat, k_hat, D_low, D_high, k_low, k_high]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1: general case\n        {\n            \"D\": 5e-12, \"k\": 1e-3, \"L\": 1e-3,\n            \"Nx\": 128, \"Nt\": 120, \"dt\": 0.5, \"sigma\": 1e-6,\n            \"px\": 16, \"pt\": 20, \"M\": 50, \"B\": 200\n        },\n        # Test case 2: noise-free boundary\n        {\n            \"D\": 5e-12, \"k\": 1e-3, \"L\": 1e-3,\n            \"Nx\": 128, \"Nt\": 120, \"dt\": 0.5, \"sigma\": 0.0,\n            \"px\": 32, \"pt\": 30, \"M\": 40, \"B\": 150\n        },\n        # Test case 3: higher reaction rate and higher noise\n        {\n            \"D\": 5e-12, \"k\": 2e-3, \"L\": 1e-3,\n            \"Nx\": 96, \"Nt\": 100, \"dt\": 0.5, \"sigma\": 5e-6,\n            \"px\": 12, \"pt\": 16, \"M\": 60, \"B\": 200\n        },\n        # Test case 4: small dataset, weaker diffusion/reaction\n        {\n            \"D\": 1e-12, \"k\": 5e-4, \"L\": 1e-3,\n            \"Nx\": 64, \"Nt\": 80, \"dt\": 0.5, \"sigma\": 1e-6,\n            \"px\": 8, \"pt\": 10, \"M\": 12, \"B\": 60\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        res = run_case(\n            D_true=case[\"D\"], k_true=case[\"k\"], L=case[\"L\"],\n            Nx=case[\"Nx\"], Nt=case[\"Nt\"], dt=case[\"dt\"], sigma=case[\"sigma\"],\n            px=case[\"px\"], pt=case[\"pt\"], M=case[\"M\"], B=case[\"B\"]\n        )\n        results.append(res)\n\n    # Final print statement in the exact required format.\n    # Print as a a single line: list of four lists, each with six floats.\n    # Avoid additional text.\n    print(f\"[{','.join('[' + ','.join(map(str, r)) + ']' for r in results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "一个成功的物理模型不仅要能够拟合数据，还必须遵守宇宙的基本定律。本练习将探讨如何在数据驱动发现的框架中强制施加深刻的物理约束，以热力学第二定律为例。您将学习如何检验一个被发现的线性本构关系是否满足熵产非负原理，并实践如何通过将系数矩阵投影到正半定矩阵锥上，来修正模型以确保其物理上的自洽性 。",
            "id": "3904045",
            "problem": "考虑一个可充电电池内部的等温、一维、均匀电解质域，其中离子电流密度和电解质电势梯度是共线的。记 $i_e$ 为电解质离子电流密度的大小（单位为 $\\mathrm{A/m^2}$），$g$ 为电解质电势梯度 $g = \\partial_x \\phi_e$ 的大小（单位为 $\\mathrm{V/m}$），$j$ 为界面反应电流密度的大小（单位为 $\\mathrm{A/m^2}$），$\\eta$ 为过电势的大小（单位为 $\\mathrm{V}$），$T$ 为绝对温度（单位为 $\\mathrm{K}$）。在非平衡热力学中，局部体积熵产生密度定义为\n$$\n\\sigma = \\frac{i_e \\, g}{T} + \\frac{j \\, \\eta}{T},\n$$\n单位为 $\\mathrm{W/(m^3\\cdot K)}$。热力学第二定律要求对于所有物理上允许的状态，$\\sigma \\ge 0$。\n\n一个数据驱动发现的线性模型通过一个 $2 \\times 2$ 的系数矩阵 $L$ 将流和力联系起来：\n$$\n\\begin{bmatrix}\ni_e \\\\\nj\n\\end{bmatrix}\n=\n\\begin{bmatrix}\nL_{11}  L_{12} \\\\\nL_{21}  L_{22}\n\\end{bmatrix}\n\\begin{bmatrix}\ng \\\\\n\\eta\n\\end{bmatrix}.\n$$\n热力学第二定律施加了熵产生必须为非负的约束。在线性不可逆热力学中，对于任意 $T0$ 和所有 $[g,\\eta]^T$，熵产生为非负的充分必要条件是 $L$ 的对称部分 $S = (L + L^\\top)/2$ 是半正定的。如果发现的 $L$ 违反了此约束，则必须对其进行最小程度的调整，以在保持线性结构的同时强制满足热力学第二定律。\n\n您的任务是实现一个程序，对每个提供的测试用例执行以下步骤：\n1. 计算对称部分 $S = (L + L^\\top)/2$。\n2. 对于给定的采样状态集 $(g,\\eta)$ 和温度 $T$，计算每个样本索引 $k$ 的熵产生值\n$$\n\\sigma_k = \\frac{1}{T} \\begin{bmatrix} g_k  \\eta_k \\end{bmatrix} S \\begin{bmatrix} g_k \\\\ \\eta_k \\end{bmatrix}\n$$\n，并确定是否所有的 $\\sigma_k$ 都为非负。报告所有样本中 $\\sigma_k$ 的最小值。所有熵产生值必须以 $\\mathrm{W/(m^3\\cdot K)}$ 为单位表示。\n3. 通过将 $S$ 投影到对称半正定矩阵锥上来调整系数以强制满足热力学第二定律。这通过特征值分解 $S = U \\Lambda U^\\top$ 并将任何负特征值 $\\lambda_i$ 替换为 $0$ 来实现，从而得到 $\\tilde{S} = U \\tilde{\\Lambda} U^\\top$，其中 $\\tilde{\\Lambda} = \\mathrm{diag}(\\max(\\lambda_1,0),\\max(\\lambda_2,0))$。将修正后的系数矩阵 $\\tilde{L}$ 设置为 $\\tilde{S}$。\n4. 使用 $\\tilde{S}$ 为相同的样本和温度重新计算熵产生值，确定是否所有修正后的值都为非负，并报告修正后的最小值。同时，以列表形式按行主序输出 $\\tilde{L}$ 的条目。\n\n测试套件：\n- 案例 A (正常路径，对称正定): $L = \\begin{bmatrix} 5.0  0.5 \\\\ 0.5  2.0 \\end{bmatrix}$，$T = 298\\,\\mathrm{K}$，样本 $(g,\\eta)$ 为 $\\{(0.0,0.0),(10.0,0.02),(100.0,0.1),(50.0,-0.05)\\}$。\n- 案例 B (不定，非对称): $L = \\begin{bmatrix} -1.0  4.0 \\\\ 0.2  -0.5 \\end{bmatrix}$，$T = 300\\,\\mathrm{K}$，样本 $(g,\\eta)$ 为 $\\{(20.0,0.2),(50.0,-0.1),(100.0,0.0),(0.0,0.5)\\}$。\n- 案例 C (近边界，对称且有小的负特征值): $L = \\begin{bmatrix} 10^{-3}  -2\\cdot 10^{-3} \\\\ -2\\cdot 10^{-3}  10^{-3} \\end{bmatrix}$，$T = 350\\,\\mathrm{K}$，样本 $(g,\\eta)$ 为 $\\{(1000.0,0.5),(100.0,-0.5),(0.0,1.0)\\}$。\n- 案例 D (强非对角，非对称): $L = \\begin{bmatrix} 0.5  4.5 \\\\ -4.0  0.1 \\end{bmatrix}$，$T = 1000\\,\\mathrm{K}$，样本 $(g,\\eta)$ 为 $\\{(200.0,0.2),(400.0,-0.3),(1.0,10.0)\\}$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，每个测试用例的结果本身就是一个列表，格式如下：\n$$\n[\\text{初始非负性}, \\ \\min(\\sigma)\\ \\text{单位}\\ \\mathrm{W/(m^3\\cdot K)}, \\ \\text{修正后非负性}, \\ \\min(\\tilde{\\sigma})\\ \\text{单位}\\ \\mathrm{W/(m^3\\cdot K)}, \\ \\text{展平的}\\ \\tilde{L}]\n$$\n其中包含布尔值和浮点数，分别对应案例 A、B、C 和 D。例如，输出应如下所示：\n$$\n[[\\dots],[\\dots],[\\dots],[\\dots]]\n$$\n不含任何附加文本。所有浮点数中，熵产生最小值的单位必须是 $\\mathrm{W/(m^3\\cdot K)}$，$\\tilde{L}$ 的条目是与上述定义的流和力相关的量纲一致的系数。",
            "solution": "该问题要求对电池电解质中耦合的离子输运和反应动力学的数据驱动线性模型进行分析和校正，以确保其符合热力学第二定律。核心原则是，对于任何物理上允许的状态，局部体积熵产生密度 $\\sigma$ 必须为非负。\n\n起点是给定的熵产生定义：\n$$\n\\sigma = \\frac{i_e \\, g}{T} + \\frac{j \\, \\eta}{T}\n$$\n其中 $i_e$ 是离子电流密度，$g$ 是电势梯度，$j$ 是反应电流密度，$\\eta$ 是过电势，$T$ 是绝对温度。对 $(i_e, j)$ 代表热力学流，而 $(g, \\eta)$ 代表相应的力（相差一个因子 $1/T$）。\n\n所提出的线性本构关系为：\n$$\n\\begin{bmatrix}\ni_e \\\\\nj\n\\end{bmatrix}\n=\nL\n\\begin{bmatrix}\ng \\\\\n\\eta\n\\end{bmatrix}\n$$\n其中 $L$ 是一个 $2 \\times 2$ 的唯象系数矩阵。将此关系代入 $\\sigma$ 的表达式中会得到一个二次型。设状态向量为 $\\mathbf{x} = [g, \\eta]^T$。则流通量向量为 $\\mathbf{J} = [i_e, j]^T = L\\mathbf{x}$。熵产生可以用矩阵表示法写为：\n$$\n\\sigma = \\frac{1}{T} \\mathbf{J}^T \\mathbf{x} = \\frac{1}{T} (L\\mathbf{x})^T \\mathbf{x} = \\frac{1}{T} \\mathbf{x}^T L^T \\mathbf{x}\n$$\n这个表达式并不直接方便。一个等效且更标准的形式是：\n$$\n\\sigma = \\frac{1}{T} \\mathbf{x}^T \\mathbf{J} = \\frac{1}{T} \\mathbf{x}^T L \\mathbf{x}\n$$\n二次型 $\\mathbf{x}^T M \\mathbf{x}$ 的值仅取决于矩阵 $M$ 的对称部分，因为 $\\mathbf{x}^T M \\mathbf{x} = \\mathbf{x}^T \\left(\\frac{M+M^T}{2}\\right) \\mathbf{x}$。令 $S$ 为系数矩阵 $L$ 的对称部分，定义为 $S = (L + L^T)/2$。则熵产生由下式给出：\n$$\n\\sigma = \\frac{1}{T} \\mathbf{x}^T S \\mathbf{x} = \\frac{1}{T} \\begin{bmatrix} g  \\eta \\end{bmatrix} S \\begin{bmatrix} g \\\\ \\eta \\end{bmatrix}\n$$\n热力学第二定律要求对于所有可能的状态向量 $\\mathbf{x} = [g, \\eta]^T$，$\\sigma \\ge 0$。由于 $T  0$，这等价于二次型 $\\mathbf{x}^T S \\mathbf{x}$ 对所有 $\\mathbf{x}$ 都为非负的条件。这就是矩阵 $S$ 为半正定的定义。\n\n对于每个测试用例，流程如下：\n\n1.  **计算对称部分**：给定发现的矩阵 $L$，我们首先计算其对称部分 $S = (L + L^T)/2$。\n\n2.  **评估初始熵产生**：对于给定的温度 $T$ 和 $N$ 个样本状态集 $\\{\\mathbf{x}_k\\}_{k=1}^N$，其中 $\\mathbf{x}_k = [g_k, \\eta_k]^T$，我们为每个样本计算熵产生：\n    $$\n    \\sigma_k = \\frac{1}{T} \\mathbf{x}_k^T S \\mathbf{x}_k\n    $$\n    然后我们检查是否所有的 $\\sigma_k \\ge 0$。这决定了 `initial_nonnegativity` 布尔值。我们还找到所有计算出的 $\\sigma_k$ 中的最小值。需要注意的是，即使 $S$ 不是半正定的，在一个有限的样本集中，所有的 $\\sigma_k$ 也可能为非负。然而，这并不能保证对所有可能的状态都符合热力学第二定律。\n\n3.  **通过投影强制满足热力学第二定律**：为确保对所有状态 $\\sigma \\ge 0$，我们必须将 $S$ 修改为半正定矩阵。一个标准方法是将 $S$ 投影到对称半正定矩阵锥上。这通过特征值分解实现。由于 $S$ 是对称的，它可以分解为：\n    $$\n    S = U \\Lambda U^T\n    $$\n    其中 $U$ 是一个正交矩阵，其列是 $S$ 的特征向量，而 $\\Lambda = \\mathrm{diag}(\\lambda_1, \\lambda_2)$ 是相应实特征值的对角矩阵。\n    一个矩阵是半正定的，当且仅当其所有特征值都为非负。如果 $S$ 有任何负特征值，它就不是半正定的。我们通过将所有负特征值替换为零来构造与 $S$ 最接近（在弗罗贝尼乌斯范数下）的半正定矩阵。我们形成一个新的对角矩阵 $\\tilde{\\Lambda}$，其中：\n    $$\n    \\tilde{\\Lambda} = \\mathrm{diag}(\\max(\\lambda_1, 0), \\max(\\lambda_2, 0))\n    $$\n    然后重构修正后的对称矩阵 $\\tilde{S}$：\n    $$\n    \\tilde{S} = U \\tilde{\\Lambda} U^T\n    $$\n    问题指定修正后的系数矩阵 $\\tilde{L}$ 被设置为这个新的对称半正定矩阵，即 $\\tilde{L} = \\tilde{S}$。这个新的矩阵 $\\tilde{L}$ 保证了对所有状态的熵产生都为非负。\n\n4.  **评估修正后的熵产生**：使用修正后的矩阵 $\\tilde{S}$，我们为相同的样本集重新计算熵产生值：\n    $$\n    \\tilde{\\sigma}_k = \\frac{1}{T} \\mathbf{x}_k^T \\tilde{S} \\mathbf{x}_k\n    $$\n    根据构造，$\\tilde{S}$ 是半正定的，因此可以保证所有的 $\\tilde{\\sigma}_k \\ge 0$。我们报告 `corrected_nonnegativity`（这将始终为真）和 $\\tilde{\\sigma}_k$ 的最小值。最后，将得到的矩阵 $\\tilde{L} = \\tilde{S}$ 的元素展平为一个列表以供输出。此过程系统地应用于所有提供的测试用例。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Validates a data-driven battery model against the Second Law of Thermodynamics,\n    corrects the model if necessary, and reports the results.\n    \"\"\"\n\n    test_cases = [\n        # Case A (happy path, symmetric positive definite)\n        {\n            \"L\": np.array([[5.0, 0.5], [0.5, 2.0]]),\n            \"T\": 298.0,\n            \"samples\": np.array([[0.0, 0.0], [10.0, 0.02], [100.0, 0.1], [50.0, -0.05]]),\n        },\n        # Case B (indefinite, non-symmetric)\n        {\n            \"L\": np.array([[-1.0, 4.0], [0.2, -0.5]]),\n            \"T\": 300.0,\n            \"samples\": np.array([[20.0, 0.2], [50.0, -0.1], [100.0, 0.0], [0.0, 0.5]]),\n        },\n        # Case C (near-boundary, symmetric with a small negative eigenvalue)\n        {\n            \"L\": np.array([[1e-3, -2e-3], [-2e-3, 1e-3]]),\n            \"T\": 350.0,\n            \"samples\": np.array([[1000.0, 0.5], [100.0, -0.5], [0.0, 1.0]]),\n        },\n        # Case D (strong off-diagonal, non-symmetric)\n        {\n            \"L\": np.array([[0.5, 4.5], [-4.0, 0.1]]),\n            \"T\": 1000.0,\n            \"samples\": np.array([[200.0, 0.2], [400.0, -0.3], [1.0, 10.0]]),\n        },\n    ]\n\n    results = []\n\n    for case in test_cases:\n        L = case[\"L\"]\n        T = case[\"T\"]\n        samples = case[\"samples\"]\n\n        # Step 1: Compute the symmetric part S\n        S = (L + L.T) / 2.0\n\n        # Step 2: Compute initial entropy production\n        sigmas = []\n        for x in samples:\n            sigma = (x.T @ S @ x) / T\n            sigmas.append(sigma)\n        \n        min_sigma = min(sigmas) if sigmas else 0.0\n        initial_nonnegativity = all(s >= 0 for s in sigmas)\n\n        # Step 3: Adjust coefficients to enforce the Second Law\n        # Use np.linalg.eigh for symmetric matrices\n        eigenvalues, eigenvectors = np.linalg.eigh(S)\n        \n        # Clip negative eigenvalues to 0\n        corrected_eigenvalues = np.maximum(eigenvalues, 0)\n        \n        # Reconstruct the corrected symmetric positive semidefinite matrix S_tilde\n        Lambda_tilde = np.diag(corrected_eigenvalues)\n        S_tilde = eigenvectors @ Lambda_tilde @ eigenvectors.T\n        \n        # The corrected coefficient matrix L_tilde is set to S_tilde\n        L_tilde = S_tilde\n\n        # Step 4: Recompute entropy production with the corrected matrix\n        corrected_sigmas = []\n        for x in samples:\n            corrected_sigma = (x.T @ L_tilde @ x) / T\n            corrected_sigmas.append(corrected_sigma)\n\n        min_corrected_sigma = min(corrected_sigmas) if corrected_sigmas else 0.0\n        corrected_nonnegativity = all(s >= -1e-9 for s in corrected_sigmas) # Use tolerance for float precision\n        \n        flattened_L_tilde = list(L_tilde.flatten())\n\n        results.append([\n            initial_nonnegativity,\n            min_sigma,\n            corrected_nonnegativity,\n            min_corrected_sigma,\n            flattened_L_tilde,\n        ])\n\n    print(f\"{results}\")\n\nsolve()\n\n```"
        }
    ]
}