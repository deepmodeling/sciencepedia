{
    "hands_on_practices": [
        {
            "introduction": "Before constructing any physics-informed model, it is crucial to understand the relative importance of the underlying physical phenomena. This practice focuses on the foundational technique of dimensional analysis, which allows us to scale the governing equations of a system. By deriving key dimensionless numbers from the thermal-electrochemical equations of a battery, you will learn to compare competing effects, such as heat generation versus conduction, which is essential for properly weighting terms in a PINN loss function and ensuring numerical stability. ",
            "id": "3941092",
            "problem": "A physics-informed neural network (PINN) surrogate for the pseudo-two-dimensional (P2D) battery model must be trained on appropriately scaled governing equations to ensure numerically stable optimization and physically interpretable residual weighting. Consider a single electrode region of thickness $L$ represented by a one-dimensional energy balance in the through-thickness coordinate $x$ with thermal-electrochemical coupling. The energy equation is\n$$\n\\rho c_{p} \\,\\frac{\\partial T}{\\partial t} \\;=\\; k \\,\\frac{\\partial^{2} T}{\\partial x^{2}} \\;+\\; q(x,t),\n$$\nwhere $\\rho$ is the mass density, $c_{p}$ is the specific heat capacity, $k$ is the thermal conductivity, and $q(x,t)$ is the volumetric heat generation. The volumetric heat source arises from three mechanisms: irreversible reaction heat $q_{\\mathrm{irr}}$, entropic heat $q_{\\mathrm{ent}}$, and ohmic heat $q_{\\mathrm{ohm}}$, given by\n$$\nq_{\\mathrm{irr}} \\;=\\; \\eta \\, a_{s} \\, j \\, F, \n\\qquad\nq_{\\mathrm{ent}} \\;=\\; T \\,\\frac{\\partial U}{\\partial T} \\, a_{s} \\, j \\, F,\n\\qquad\nq_{\\mathrm{ohm}} \\;=\\; \\frac{i^{2}}{\\sigma_{\\mathrm{eff}}},\n$$\nwhere $\\eta$ is the reaction overpotential, $a_{s}$ is the specific surface area, $j$ is the molar interfacial flux, $F$ is the Faraday constant, $U$ is the open-circuit potential, $i$ is the through-thickness current density, and $\\sigma_{\\mathrm{eff}}$ is an effective conductivity combining electronic and ionic pathways. Assume uniform reaction across $x \\in [0,L]$ so that the volumetric reaction current density $a_{s} j F$ is uniform, and the applied areal current density $i_{\\mathrm{app}}$ satisfies\n$$\n\\int_{0}^{L} a_{s} j F \\, dx \\;=\\; i_{\\mathrm{app}} \\quad \\Rightarrow \\quad a_{s} j F \\;=\\; \\frac{i_{\\mathrm{app}}}{L}.\n$$\nChoose a temperature scale $\\Delta T$, a reference temperature $T_{\\mathrm{ref}}$, and define the thermal diffusivity $\\alpha = k/(\\rho c_{p})$. Let the thermal diffusion timescale be $\\tau_{\\mathrm{th}} = L^{2}/\\alpha$. Using conservation of energy for scaling of the heat equation, and using Faraday’s law with solid-phase lithium conservation to define a reaction timescale for an $\\mathcal{O}(1)$ change of average solid concentration, derive the following dimensionless groups:\n- A source-conduction competition number that compares heat generation to heat removal by conduction.\n- A Péclet-like number comparing the thermal diffusion timescale to the electrochemical reaction timescale.\n\nThen, using the parameter values:\n- $L = 1.0 \\times 10^{-4}\\,\\mathrm{m}$,\n- $k = 1.5\\,\\mathrm{W}\\,\\mathrm{m}^{-1}\\,\\mathrm{K}^{-1}$,\n- $\\rho = 1800\\,\\mathrm{kg}\\,\\mathrm{m}^{-3}$,\n- $c_{p} = 900\\,\\mathrm{J}\\,\\mathrm{kg}^{-1}\\,\\mathrm{K}^{-1}$,\n- $\\Delta T = 5\\,\\mathrm{K}$,\n- $i_{\\mathrm{app}} = 25\\,\\mathrm{A}\\,\\mathrm{m}^{-2}$,\n- $\\eta_{0} = 0.06\\,\\mathrm{V}$ (use this for the overpotential scale),\n- $\\left(\\frac{\\partial U}{\\partial T}\\right) = 2.0 \\times 10^{-4}\\,\\mathrm{V}\\,\\mathrm{K}^{-1}$,\n- $T_{\\mathrm{ref}} = 298\\,\\mathrm{K}$,\n- $\\sigma_{\\mathrm{eff}} = 20\\,\\mathrm{S}\\,\\mathrm{m}^{-1}$,\n- $\\epsilon_{s} = 0.5$,\n- $c_{s,\\max} = 3.1 \\times 10^{4}\\,\\mathrm{mol}\\,\\mathrm{m}^{-3}$,\n- $F = 96485\\,\\mathrm{C}\\,\\mathrm{mol}^{-1}$,\n\nassume the entropic term contributes positively at $T_{\\mathrm{ref}}$ and compute numerical values for the two dimensionless numbers. Express the final numerical results as dimensionless values rounded to four significant figures. Present both values as a two-entry row matrix.",
            "solution": "The problem statement is evaluated for validity prior to attempting a solution.\n\n### Step 1: Extract Givens\n- **Governing Equation:** The one-dimensional energy balance is\n$$\n\\rho c_{p} \\,\\frac{\\partial T}{\\partial t} \\;=\\; k \\,\\frac{\\partial^{2} T}{\\partial x^{2}} \\;+\\; q(x,t)\n$$\n- **Variables and Constants:**\n  - $T$: Temperature\n  - $t$: Time\n  - $x$: Through-thickness coordinate in $[0, L]$\n  - $\\rho$: Mass density\n  - $c_p$: Specific heat capacity\n  - $k$: Thermal conductivity\n  - $q(x,t)$: Volumetric heat generation\n  - $L$: Electrode thickness\n- **Heat Source Components:**\n  - $q = q_{\\mathrm{irr}} + q_{\\mathrm{ent}} + q_{\\mathrm{ohm}}$\n  - $q_{\\mathrm{irr}} = \\eta \\, a_{s} \\, j \\, F$ (irreversible reaction heat)\n  - $q_{\\mathrm{ent}} = T \\,\\frac{\\partial U}{\\partial T} \\, a_{s} \\, j \\, F$ (entropic heat)\n  - $q_{\\mathrm{ohm}} = \\frac{i^{2}}{\\sigma_{\\mathrm{eff}}}$ (ohmic heat)\n- **Component Definitions:**\n  - $\\eta$: Reaction overpotential\n  - $a_s$: Specific surface area\n  - $j$: Molar interfacial flux\n  - $F$: Faraday constant\n  - $U$: Open-circuit potential\n  - $i$: Through-thickness current density\n  - $\\sigma_{\\mathrm{eff}}$: Effective conductivity\n- **Assumptions and Conditions:**\n  - Uniform reaction across $x \\in [0,L]$ implies $a_{s} j F = \\frac{i_{\\mathrm{app}}}{L}$, where $i_{\\mathrm{app}}$ is the applied areal current density.\n- **Scaling Parameters:**\n  - Temperature scale: $\\Delta T$\n  - Reference temperature: $T_{\\mathrm{ref}}$\n  - Thermal diffusivity: $\\alpha = k/(\\rho c_{p})$\n  - Thermal diffusion timescale: $\\tau_{\\mathrm{th}} = L^{2}/\\alpha$\n- **Task:**\n  1. Derive a \"source-conduction competition number\".\n  2. Derive a \"Péclet-like number\" comparing $\\tau_{\\mathrm{th}}$ to an electrochemical reaction timescale.\n  3. Compute numerical values for these two numbers using the provided data.\n- **Numerical Values:**\n  - $L = 1.0 \\times 10^{-4}\\,\\mathrm{m}$\n  - $k = 1.5\\,\\mathrm{W}\\,\\mathrm{m}^{-1}\\,\\mathrm{K}^{-1}$\n  - $\\rho = 1800\\,\\mathrm{kg}\\,\\mathrm{m}^{-3}$\n  - $c_{p} = 900\\,\\mathrm{J}\\,\\mathrm{kg}^{-1}\\,\\mathrm{K}^{-1}$\n  - $\\Delta T = 5\\,\\mathrm{K}$\n  - $i_{\\mathrm{app}} = 25\\,\\mathrm{A}\\,\\mathrm{m}^{-2}$\n  - $\\eta_{0} = 0.06\\,\\mathrm{V}$ (overpotential scale)\n  - $(\\frac{\\partial U}{\\partial T}) = 2.0 \\times 10^{-4}\\,\\mathrm{V}\\,\\mathrm{K}^{-1}$\n  - $T_{\\mathrm{ref}} = 298\\,\\mathrm{K}$\n  - $\\sigma_{\\mathrm{eff}} = 20\\,\\mathrm{S}\\,\\mathrm{m}^{-1}$\n  - $\\epsilon_{s} = 0.5$ (solid-phase volume fraction)\n  - $c_{s,\\max} = 3.1 \\times 10^{4}\\,\\mathrm{mol}\\,\\mathrm{m}^{-3}$ (max solid concentration)\n  - $F = 96485\\,\\mathrm{C}\\,\\mathrm{mol}^{-1}$\n\n### Step 2: Validate Using Extracted Givens\nThe problem is scientifically grounded, drawing upon standard principles of transport phenomena (heat equation) and electrochemistry (battery modeling). The equations for heat generation are standard in the field of battery modeling. The task is well-posed, requiring the derivation of dimensionless groups through a standard scaling analysis, followed by numerical calculation. The language is objective and precise. The provided parameters are physically realistic for battery materials and operating conditions. The problem is self-contained and provides all necessary information for its solution. It does not violate any of the specified invalidity criteria.\n\n### Step 3: Verdict and Action\nThe problem is valid. A complete solution will be provided.\n\n### Solution Derivation\nThe objective is to derive two dimensionless numbers from the governing energy balance equation and then compute their values.\n\n#### Derivation of the Source-Conduction Competition Number ($\\Pi_1$)\nWe begin by non-dimensionalizing the energy equation. Let us define the dimensionless temperature $\\theta$, spatial coordinate $\\tilde{x}$, and time $\\tilde{t}$:\n$$\n\\theta = \\frac{T - T_{\\mathrm{ref}}}{\\Delta T}, \\qquad \\tilde{x} = \\frac{x}{L}, \\qquad \\tilde{t} = \\frac{t}{\\tau_{\\mathrm{th}}}\n$$\nwhere $\\tau_{\\mathrm{th}} = L^2/\\alpha = L^2 \\rho c_p / k$ is the thermal diffusion timescale. The partial derivatives transform as:\n$$\n\\frac{\\partial T}{\\partial t} = \\frac{\\partial (\\Delta T \\theta + T_{\\mathrm{ref}})}{\\partial \\tilde{t}} \\frac{\\partial \\tilde{t}}{\\partial t} = \\frac{\\Delta T}{\\tau_{\\mathrm{th}}} \\frac{\\partial \\theta}{\\partial \\tilde{t}}\n$$\n$$\n\\frac{\\partial T}{\\partial x} = \\frac{\\Delta T}{L} \\frac{\\partial \\theta}{\\partial \\tilde{x}} \\quad \\Rightarrow \\quad \\frac{\\partial^2 T}{\\partial x^2} = \\frac{\\Delta T}{L^2} \\frac{\\partial^2 \\theta}{\\partial \\tilde{x}^2}\n$$\nSubstituting these into the governing equation:\n$$\n\\rho c_{p} \\left( \\frac{\\Delta T}{\\tau_{\\mathrm{th}}} \\frac{\\partial \\theta}{\\partial \\tilde{t}} \\right) = k \\left( \\frac{\\Delta T}{L^2} \\frac{\\partial^2 \\theta}{\\partial \\tilde{x}^2} \\right) + q(x,t)\n$$\nSubstituting $\\tau_{\\mathrm{th}} = L^2 \\rho c_p / k$:\n$$\n\\rho c_{p} \\left( \\frac{k \\Delta T}{L^2 \\rho c_p} \\frac{\\partial \\theta}{\\partial \\tilde{t}} \\right) = \\frac{k \\Delta T}{L^2} \\frac{\\partial^2 \\theta}{\\partial \\tilde{x}^2} + q\n$$\n$$\n\\frac{k \\Delta T}{L^2} \\frac{\\partial \\theta}{\\partial \\tilde{t}} = \\frac{k \\Delta T}{L^2} \\frac{\\partial^2 \\theta}{\\partial \\tilde{x}^2} + q\n$$\nDividing the entire equation by the conduction term coefficient, $\\frac{k \\Delta T}{L^2}$, yields the dimensionless form:\n$$\n\\frac{\\partial \\theta}{\\partial \\tilde{t}} = \\frac{\\partial^2 \\theta}{\\partial \\tilde{x}^2} + \\frac{L^2 q}{k \\Delta T}\n$$\nThe source-conduction competition number, which we denote $\\Pi_1$, is the characteristic magnitude of the dimensionless source term $\\frac{L^2 q}{k \\Delta T}$. This number compares the rate of heat generation to the rate of heat removal by conduction.\n$$\n\\Pi_1 = \\frac{\\text{Characteristic volumetric heat generation rate}}{\\text{Characteristic volumetric heat conduction rate}} = \\frac{q_0}{k \\Delta T / L^2} = \\frac{q_0 L^2}{k \\Delta T}\n$$\nWe must determine the characteristic heat source, $q_0$. It is the sum of the characteristic values of its components: $q_0 = q_{0,\\mathrm{irr}} + q_{0,\\mathrm{ent}} + q_{0,\\mathrm{ohm}}$. Using the provided scales and assumptions:\n- $q_{0,\\mathrm{irr}} = \\eta_0 (a_s j F) = \\eta_0 \\frac{i_{\\mathrm{app}}}{L}$\n- $q_{0,\\mathrm{ent}} = T_{\\mathrm{ref}} \\frac{\\partial U}{\\partial T} (a_s j F) = T_{\\mathrm{ref}} \\frac{\\partial U}{\\partial T} \\frac{i_{\\mathrm{app}}}{L}$\n- $q_{0,\\mathrm{ohm}} = \\frac{i_{\\mathrm{app}}^2}{\\sigma_{\\mathrm{eff}}}$ (using $i_{\\mathrm{app}}$ as the characteristic current density)\n\nThus, the total characteristic heat source is:\n$$\nq_0 = \\frac{i_{\\mathrm{app}}}{L} \\left( \\eta_0 + T_{\\mathrm{ref}} \\frac{\\partial U}{\\partial T} \\right) + \\frac{i_{\\mathrm{app}}^2}{\\sigma_{\\mathrm{eff}}}\n$$\nAnd the first dimensionless number is:\n$$\n\\Pi_1 = \\frac{L^2}{k \\Delta T} \\left[ \\frac{i_{\\mathrm{app}}}{L} \\left( \\eta_0 + T_{\\mathrm{ref}} \\frac{\\partial U}{\\partial T} \\right) + \\frac{i_{\\mathrm{app}}^2}{\\sigma_{\\mathrm{eff}}} \\right] = \\frac{L i_{\\mathrm{app}}}{k \\Delta T} \\left( \\eta_0 + T_{\\mathrm{ref}} \\frac{\\partial U}{\\partial T} \\right) + \\frac{L^2 i_{\\mathrm{app}}^2}{k \\Delta T \\sigma_{\\mathrm{eff}}}\n$$\n\n#### Derivation of the Péclet-like Number ($\\Pi_2$)\nThis number compares the thermal diffusion timescale, $\\tau_{\\mathrm{th}}$, to the electrochemical reaction timescale, $\\tau_{\\mathrm{rxn}}$.\nThe thermal timescale is given as $\\tau_{\\mathrm{th}} = L^2 / \\alpha = L^2 \\rho c_p / k$.\n\nThe electrochemical reaction timescale, $\\tau_{\\mathrm{rxn}}$, is defined for an $\\mathcal{O}(1)$ change in the average solid-phase lithium concentration. The conservation of lithium in the solid phase of the electrode is given by:\n$$\n\\epsilon_s \\frac{\\partial c_s}{\\partial t} = -\\nabla \\cdot \\mathbf{J}_s\n$$\nWhen averaged over the electrode volume, the change in the total stored lithium is due to the electrochemical reaction at the particle surfaces. The rate of change of the average solid concentration, $\\bar{c}_s$, is related to the volumetric reaction rate, $a_s j$:\n$$\n\\epsilon_s \\frac{d\\bar{c}_s}{dt} = - a_s j\n$$\nUsing the given condition $a_s j = i_{\\mathrm{app}}/(LF)$:\n$$\n\\epsilon_s \\frac{d\\bar{c}_s}{dt} = - \\frac{i_{\\mathrm{app}}}{LF}\n$$\nThe timescale $\\tau_{\\mathrm{rxn}}$ for a characteristic change in concentration $\\Delta \\bar{c}_s$ is found by approximating the derivative as a finite difference:\n$$\n\\epsilon_s \\frac{\\Delta \\bar{c}_s}{\\tau_{\\mathrm{rxn}}} \\approx \\frac{i_{\\mathrm{app}}}{LF}\n$$\nFor an $\\mathcal{O}(1)$ change, the characteristic concentration change is the maximum concentration, $\\Delta \\bar{c}_s = c_{s,\\max}$. Solving for $\\tau_{\\mathrm{rxn}}$:\n$$\n\\tau_{\\mathrm{rxn}} = \\frac{\\epsilon_s c_{s,\\max} L F}{i_{\\mathrm{app}}}\n$$\nThis represents the time to fully charge or discharge the electrode.\nThe Péclet-like number, $\\Pi_2$, is the ratio of these two timescales:\n$$\n\\Pi_2 = \\frac{\\tau_{\\mathrm{th}}}{\\tau_{\\mathrm{rxn}}} = \\frac{L^2 \\rho c_p / k}{\\epsilon_s c_{s,\\max} L F / i_{\\mathrm{app}}} = \\frac{i_{\\mathrm{app}} L \\rho c_p}{k \\epsilon_s c_{s,\\max} F}\n$$\n\n### Numerical Computation\nWe now substitute the provided numerical values into the derived expressions for $\\Pi_1$ and $\\Pi_2$.\n\n**Calculation of $\\Pi_1$:**\nFirst, calculate the characteristic source term, $q_0$.\n$$\nq_{0, \\mathrm{irr}} = \\eta_0 \\frac{i_{\\mathrm{app}}}{L} = (0.06\\,\\mathrm{V}) \\frac{25\\,\\mathrm{A}\\,\\mathrm{m}^{-2}}{1.0 \\times 10^{-4}\\,\\mathrm{m}} = 1.5 \\times 10^4\\,\\mathrm{W}\\,\\mathrm{m}^{-3}\n$$\n$$\nq_{0, \\mathrm{ent}} = T_{\\mathrm{ref}} \\frac{\\partial U}{\\partial T} \\frac{i_{\\mathrm{app}}}{L} = (298\\,\\mathrm{K})(2.0 \\times 10^{-4}\\,\\mathrm{V}\\,\\mathrm{K}^{-1}) \\frac{25\\,\\mathrm{A}\\,\\mathrm{m}^{-2}}{1.0 \\times 10^{-4}\\,\\mathrm{m}} = 1.49 \\times 10^4\\,\\mathrm{W}\\,\\mathrm{m}^{-3}\n$$\n$$\nq_{0, \\mathrm{ohm}} = \\frac{i_{\\mathrm{app}}^2}{\\sigma_{\\mathrm{eff}}} = \\frac{(25\\,\\mathrm{A}\\,\\mathrm{m}^{-2})^2}{20\\,\\mathrm{S}\\,\\mathrm{m}^{-1}} = \\frac{625}{20}\\,\\mathrm{W}\\,\\mathrm{m}^{-3} = 31.25\\,\\mathrm{W}\\,\\mathrm{m}^{-3}\n$$\nTotal characteristic source:\n$$\nq_0 = (1.5 \\times 10^4) + (1.49 \\times 10^4) + 31.25 = 29931.25\\,\\mathrm{W}\\,\\mathrm{m}^{-3}\n$$\nNow compute $\\Pi_1$:\n$$\n\\Pi_1 = \\frac{q_0 L^2}{k \\Delta T} = \\frac{(29931.25\\,\\mathrm{W}\\,\\mathrm{m}^{-3})(1.0 \\times 10^{-4}\\,\\mathrm{m})^2}{(1.5\\,\\mathrm{W}\\,\\mathrm{m}^{-1}\\,\\mathrm{K}^{-1})(5\\,\\mathrm{K})} = \\frac{2.993125 \\times 10^{-4}}{7.5} \\approx 3.99083 \\times 10^{-5}\n$$\nRounding to four significant figures, $\\Pi_1 \\approx 3.991 \\times 10^{-5}$.\n\n**Calculation of $\\Pi_2$:**\nFirst, calculate the two timescales.\nThermal diffusion timescale:\n$$\n\\tau_{\\mathrm{th}} = \\frac{L^2 \\rho c_p}{k} = \\frac{(1.0 \\times 10^{-4}\\,\\mathrm{m})^2 (1800\\,\\mathrm{kg}\\,\\mathrm{m}^{-3})(900\\,\\mathrm{J}\\,\\mathrm{kg}^{-1}\\,\\mathrm{K}^{-1})}{1.5\\,\\mathrm{W}\\,\\mathrm{m}^{-1}\\,\\mathrm{K}^{-1}} = \\frac{10^{-8} \\times 1.62 \\times 10^6}{1.5}\\,\\mathrm{s} = 0.0108\\,\\mathrm{s}\n$$\nElectrochemical reaction timescale:\n$$\n\\tau_{\\mathrm{rxn}} = \\frac{\\epsilon_s c_{s,\\max} L F}{i_{\\mathrm{app}}} = \\frac{(0.5)(3.1 \\times 10^4\\,\\mathrm{mol}\\,\\mathrm{m}^{-3})(1.0 \\times 10^{-4}\\,\\mathrm{m})(96485\\,\\mathrm{C}\\,\\mathrm{mol}^{-1})}{25\\,\\mathrm{A}\\,\\mathrm{m}^{-2}} \\approx 5982.07\\,\\mathrm{s}\n$$\nNow compute the ratio $\\Pi_2$:\n$$\n\\Pi_2 = \\frac{\\tau_{\\mathrm{th}}}{\\tau_{\\mathrm{rxn}}} = \\frac{0.0108\\,\\mathrm{s}}{5982.07\\,\\mathrm{s}} \\approx 1.8054 \\times 10^{-6}\n$$\nRounding to four significant figures, $\\Pi_2 \\approx 1.805 \\times 10^{-6}$.\n\nThe two dimensionless numbers are $\\Pi_1 \\approx 3.991 \\times 10^{-5}$ and $\\Pi_2 \\approx 1.805 \\times 10^{-6}$.",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n3.991 \\times 10^{-5} & 1.805 \\times 10^{-6}\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "Moving from theory to implementation, this exercise guides you through the construction of a physics-informed surrogate model. The Deep Operator Network (DeepONet) is a powerful architecture for learning mappings between functions, such as the mapping from an input current profile to an output voltage response in a battery. This hands-on coding task will demonstrate how to embed physical principles directly into the network design, structuring the branch and trunk networks to explicitly represent known electrochemical dynamics. ",
            "id": "3941031",
            "problem": "You are tasked with designing and implementing a Physics-Informed Deep Operator Network (DeepONet) that approximates the input-to-output causal operator mapping from current $I(t)$ to terminal voltage $V(t)$ of a lithium-ion cell, conditioned on a parameter vector $\\theta$ and temperature $T$, within a simplified, scientifically consistent form derived from the Porous-Electrode Pseudo Two-Dimensional (P2D) model. The program you write must be a complete, runnable program that instantiates this DeepONet surrogate, evaluates it across a set of test cases, and reports the quantitative error of the surrogate in volts.\n\nBegin from scientifically grounded principles:\n\n- Ion transport obeys Fick's law, which in one dimension can be written as $J = -D \\nabla c$, where $J$ is flux, $D$ is the diffusion coefficient, and $c$ is concentration. In porous electrodes, reaction kinetics are captured by the Butler–Volmer relation linking interfacial current density $j$ to overpotential $\\eta$. Charge conservation in solid and electrolyte phases and Ohm's law yield coupled partial differential equations. Under small-to-moderate excitation, linearization and homogenization lead to a reduced-order operator representation for voltage response composed of an open-circuit term, an instantaneous resistive term, and a diffusive relaxation term. This motivates a causal linear time-invariant mapping from the input $I(t)$ to the output $V(t)$ written as a convolution with a physically motivated kernel.\n\nDefine the ground-truth operator for evaluation as a causal convolution of $I(t)$ with a single-exponential relaxation kernel plus an ohmic drop and an open-circuit voltage baseline:\n$$\nV(t) = U(\\theta,T) - R_0(\\theta,T)\\, I(t) - A(\\theta,T)\\, \\int_{0}^{t} \\frac{1}{\\tau(\\theta,T)} e^{-(t-\\tau')/\\tau(\\theta,T)}\\, I(\\tau')\\, d\\tau',\n$$\nwhere $U(\\theta,T)$ is the open-circuit voltage baseline, $R_0(\\theta,T)$ is the instantaneous resistance, $A(\\theta,T)$ is the amplitude of the diffusive relaxation, and $\\tau(\\theta,T)$ is the characteristic relaxation time constant. These parameter dependencies must be physically sensible functions of $\\theta$ and $T$. For numerical realizations, implement this integral as a Riemann sum with a fixed time discretization.\n\nConstruct a Deep Operator Network to approximate the mapping $I(\\cdot) \\mapsto V(\\cdot)$ conditioned on $(\\theta, T)$:\n- The DeepONet outputs are of the form\n$$\n\\widehat{V}(t) = \\sum_{j=1}^{q} c_j\\big(I(\\cdot), \\theta, T\\big)\\, \\xi_j(t),\n$$\nwhere the branch network produces the coefficients $c_j$ as functionals of the input function $I(\\cdot)$ and the parameters $(\\theta,T)$, and the trunk network produces the location-dependent basis functions $\\xi_j(t)$.\n\n- Trunk network design requirement: choose a physics-informed dictionary of basis functions that spans the relevant response space and is independent of $(\\theta,T)$. Include:\n    1. A constant basis function $\\xi_0(t) = 1$ to represent $U(\\theta,T)$.\n    2. An identity-interpolant basis to reconstruct $I(t)$ from $m$ sensor samples $\\{I(s_i)\\}_{i=1}^{m}$ at sensor times $\\{s_i\\}$ using smooth localized functions $\\{\\phi_i(t)\\}_{i=1}^{m}$, such that $I(t) \\approx \\sum_{i=1}^{m} I(s_i)\\, \\phi_i(t)$.\n    3. A set of $K$ exponential relaxation kernels that approximate the causal convolution using a parameter-independent dictionary with time constants $\\{\\tau_d^{(k)}\\}_{k=1}^{K}$. For each dictionary element and each sensor, include causal basis functions\n    $$\n    \\xi_{k,i}(t) = \\begin{cases}\n    \\frac{1}{\\tau_d^{(k)}} \\exp\\!\\big(-(t-s_i)/\\tau_d^{(k)}\\big), & t \\ge s_i,\\\\\n    0, & t < s_i.\n    \\end{cases}\n    $$\n\n- Branch network design requirement: encode parameter dependence explicitly in the coefficients $c_j$. Use the following encoding strategy:\n    1. For the constant basis, produce $c_0 = U(\\theta,T)$.\n    2. For the ohmic reconstruction, produce coefficients $c^{\\text{ohm}}_i = -R_0(\\theta,T) \\, I(s_i)$ so that $\\sum_i c^{\\text{ohm}}_i \\phi_i(t) \\approx -R_0(\\theta,T) I(t)$.\n    3. For the diffusive kernels, produce coefficients\n    $$\n    c^{\\text{diff}}_{k,i} = -A(\\theta,T)\\, w_k(\\theta,T)\\, I(s_i)\\, \\Delta s,\n    $$\n    where $\\Delta s$ is the uniform sensor spacing and $w_k(\\theta,T)$ are nonnegative gating weights that depend on $(\\theta,T)$ and satisfy $\\sum_{k=1}^{K} w_k(\\theta,T) = 1$. To implement $w_k(\\theta,T)$, use a soft assignment based on the proximity of the true $\\tau(\\theta,T)$ to dictionary $\\tau_d^{(k)}$ values; for example, define scores $r_k(\\theta,T)$ that decrease with $\\big|\\log \\tau(\\theta,T) - \\log \\tau_d^{(k)}\\big|$ and set $w_k(\\theta,T) = \\exp(r_k)/\\sum_j \\exp(r_j)$. This encodes parameter dependence entirely within the branch network while keeping the trunk dictionary fixed.\n\nImplement the above architecture numerically:\n\n- Time discretization: choose a uniform grid $t_n = n \\Delta t$ for $n=0,\\ldots,N$ over a finite horizon of $t \\in [0, t_{\\max}]$, with $t_{\\max} = $ $10$ (seconds) and $\\Delta t = $ $0.02$ (seconds).\n- Sensor placement: use $m = $ $25$ sensors uniformly over $[0,t_{\\max}]$ at positions $s_i$ with spacing $\\Delta s$; use Gaussian localized functions $\\phi_i(t) = \\exp\\!\\big(-(t-s_i)^2/(2\\sigma^2)\\big)$ with $\\sigma = \\Delta s$ and normalize $\\sum_i \\phi_i(t) = 1$ for all $t$ to form a smooth partition of unity.\n- Dictionary size: use $K = $ $2$ dictionary elements with $\\tau_d^{(1)} = $ $1.0$ (seconds) and $\\tau_d^{(2)} = $ $4.0$ (seconds).\n\nUse physically sensible parameterizations for the ground-truth operator components:\n- Let $T_0 = $ $298$ (Kelvin), $U_0 = $ $3.6$ (Volts), $R_{0,\\text{base}} = $ $0.01$ (Ohms), $\\tau_{\\text{base}} = $ $2.0$ (seconds), $A_{\\text{base}} = $ $0.02$ (Volts per Ampere), and constants $\\alpha = $ $0.10$, $\\beta = $ $0.001$, $\\delta = $ $0.20$, $\\eta = $ $0.50$, $\\zeta = $ $0.30$, and $\\gamma = $ $300.0$ such that:\n$$\nU(\\theta,T) = U_0 + \\alpha\\, \\theta + \\beta\\, (T - T_0),\n$$\n$$\nR_0(\\theta,T) = R_{0,\\text{base}}\\, \\exp\\!\\big(\\gamma / T\\big)\\, \\big(1 + \\delta\\, \\theta\\big),\n$$\n$$\n\\tau(\\theta,T) = \\tau_{\\text{base}}\\, \\big(1 + \\eta\\, \\theta\\big)\\, \\frac{T_0}{T},\n$$\n$$\nA(\\theta,T) = A_{\\text{base}}\\, \\big(1 + \\zeta\\, \\theta\\big)\\, \\sqrt{\\frac{T_0}{T}}.\n$$\n\nDefine the test suite by specifying input currents $I(t)$, parameter vectors $\\theta$, and temperatures $T$:\n\n- Case $1$ (happy path): $I(t) = 2 \\sin\\big(2\\pi \\cdot 0.5 \\cdot t\\big)$ (Amperes), $\\theta = $ $0.5$ (dimensionless), $T = $ $298$ (Kelvin).\n- Case $2$ (boundary with step): $I(t) = 5 \\cdot H(t - 2)$ (Amperes) where $H$ is the Heaviside step function, $\\theta = $ $1.5$ (dimensionless), $T = $ $318$ (Kelvin).\n- Case $3$ (zero input): $I(t) \\equiv 0$ (Amperes), $\\theta = $ $0.7$ (dimensionless), $T = $ $290$ (Kelvin).\n- Case $4$ (edge with narrow pulse at low temperature): $I(t) = 8 \\exp\\!\\big(-(t - 5)^2/(2 \\cdot 0.15^2)\\big)$ (Amperes), $\\theta = $ $0.2$ (dimensionless), $T = $ $273$ (Kelvin).\n\nProgram requirements:\n\n- Implement the ground-truth operator $V(t)$ using the parameterizations above and a causal discrete convolution with time step $\\Delta t$.\n- Implement the DeepONet surrogate $\\widehat{V}(t)$ with the trunk dictionary and branch parameter encoding as specified, including the softmax-based gating weights $w_k(\\theta,T)$ constructed from scores $r_k(\\theta,T) = -\\big|\\log \\tau(\\theta,T) - \\log \\tau_d^{(k)}\\big|$.\n- For each test case, compute the root-mean-square error\n$$\n\\mathrm{RMSE} = \\sqrt{\\frac{1}{N+1} \\sum_{n=0}^{N} \\big(\\widehat{V}(t_n) - V(t_n)\\big)^2},\n$$\nexpressed in Volts.\n\nFinal output format:\n\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in Volts, for the four test cases in the order listed above (e.g., $[\\mathrm{rmse}_1,\\mathrm{rmse}_2,\\mathrm{rmse}_3,\\mathrm{rmse}_4]$). Round each entry to $6$ decimal places.\n\nAngle units are not present in this problem. All physical units must be respected as specified above. The parameters $\\theta$ are dimensionless. Ensure scientific realism and numerical stability throughout your implementation. The program must be completely self-contained, without any external input.",
            "solution": "The user-provided problem statement is subjected to validation and is determined to be **valid**. It is scientifically grounded in established principles of electrochemical engineering, mathematically consistent, and well-posed. The problem provides a complete and unambiguous specification for constructing a physics-informed operator network surrogate and evaluating it against a simplified, but physically sensible, ground-truth model of a lithium-ion cell. The numerical parameters, functional forms, and test cases are all clearly defined, enabling a direct and verifiable implementation.\n\nThe solution proceeds by first implementing the ground-truth model and then the specified Deep Operator Network (DeepONet) surrogate. The error between the two is then quantified for a suite of test cases.\n\n### Ground-Truth Model Implementation\n\nThe ground-truth voltage response $V(t)$ is defined by the operator:\n$$\nV(t) = U(\\theta,T) - R_0(\\theta,T)\\, I(t) - A(\\theta,T)\\, \\int_{0}^{t} \\frac{1}{\\tau(\\theta,T)} e^{-(t-\\tau')/\\tau(\\theta,T)}\\, I(\\tau')\\, d\\tau'\n$$\nThis model represents the superposition of three physical effects:\n1.  A baseline open-circuit voltage, $U(\\theta,T)$.\n2.  An instantaneous ohmic voltage drop, $R_0(\\theta,T) I(t)$.\n3.  A dynamic voltage component resulting from diffusive relaxation processes, represented by the convolution integral.\n\nThe physical parameters $U$, $R_0$, $A$, and $\\tau$ are functions of a dimensionless parameter $\\theta$ and temperature $T$. Their specified dependencies are physically motivated, such as the Arrhenius-type temperature scaling for resistance, $R_0 \\propto \\exp(\\gamma/T)$, and the inverse temperature scaling for the diffusion time constant, $\\tau \\propto 1/T$. These parameters are computed for a given $(\\theta, T)$ pair using the provided formulas:\n$$\nU(\\theta,T) = U_0 + \\alpha\\, \\theta + \\beta\\, (T - T_0)\n$$\n$$\nR_0(\\theta,T) = R_{0,\\text{base}}\\, \\exp\\!\\big(\\gamma / T\\big)\\, \\big(1 + \\delta\\, \\theta\\big)\n$$\n$$\n\\tau(\\theta,T) = \\tau_{\\text{base}}\\, \\big(1 + \\eta\\, \\theta\\big)\\, \\frac{T_0}{T}\n$$\n$$\nA(\\theta,T) = A_{\\text{base}}\\, \\big(1 + \\zeta\\, \\theta\\big)\\, \\sqrt{\\frac{T_0}{T}}\n$$\nwhere all constants ($U_0, R_{0,\\text{base}}, \\dots$) are given.\n\nThe model is implemented numerically on a discrete time grid $t_n = n \\Delta t$ for $n \\in \\{0, 1, \\dots, N\\}$. The convolution integral is computed as a discrete causal convolution. If we define a kernel $K(t) = \\frac{A(\\theta,T)}{\\tau(\\theta,T)} \\exp(-t/\\tau(\\theta,T))$, the convolution term at time $t_n$ is $(K * I)(t_n) \\Delta t$. This is efficiently calculated using `numpy.convolve`. The final ground-truth voltage at each time step $t_n$ is then:\n$$\nV(t_n) = U(\\theta,T) - R_0(\\theta,T) I(t_n) - A(\\theta,T) \\left( \\left(\\frac{1}{\\tau(\\theta,T)}e^{-t/\\tau(\\theta,T)}\\right) * I(t) \\right)_n \\Delta t\n$$\n\n### Physics-Informed DeepONet Surrogate Implementation\n\nThe DeepONet is designed to approximate the operator $I(\\cdot) \\mapsto V(\\cdot)$ conditioned on $(\\theta, T)$. Its structure, $\\widehat{V}(t) = \\sum_j c_j \\xi_j(t)$, separates the model into a trunk network, which generates a parameter-independent basis $\\{\\xi_j(t)\\}$, and a branch network, which computes input- and parameter-dependent coefficients $\\{c_j\\}$.\n\n**Trunk Network:** The basis functions $\\{\\xi_j(t)\\}$ are designed to span the space of possible voltage responses. They are fixed and do not depend on $(\\theta, T)$. The chosen basis comprises three components:\n1.  **Constant Basis:** $\\xi_0(t) = 1$. This function provides a bias term, which will be modulated by the branch network to represent the open-circuit voltage $U(\\theta,T)$.\n2.  **Input Reconstruction Basis:** A set of $m=25$ localized Gaussian functions, $\\{\\phi_i(t)\\}_{i=1}^{m}$, centered at uniformly spaced sensor locations $\\{s_i\\}_{i=1}^{m}$. These functions are normalized to form a partition of unity, $\\sum_{i=1}^m \\phi_i(t) = 1$, by dividing each Gaussian by their sum. This basis allows the network to reconstruct a smooth representation of the input current $I(t) \\approx \\sum_{i=1}^m I(s_i) \\phi_i(t)$, which is essential for capturing the ohmic term.\n3.  **Diffusive Kernel Basis:** A dictionary of $K=2$ causal exponential kernels $\\{\\xi_{k,i}(t)\\}_{k,i}$ with fixed time constants $\\tau_d^{(1)}$ and $\\tau_d^{(2)}$. Each basis function $\\xi_{k,i}(t) = \\frac{1}{\\tau_d^{(k)}} \\exp(-(t-s_i)/\\tau_d^{(k)})$ for $t \\ge s_i$ (and $0$ otherwise) represents a relaxation response originating at sensor location $s_i$ with a characteristic time $\\tau_d^{(k)}$. The full set of these functions for all sensors $i$ and dictionary elements $k$ forms a basis capable of approximating the true convolutional kernel.\n\n**Branch Network:** The branch network computes the coefficients $\\{c_j\\}$ for the basis functions. In this problem, no training is performed; the coefficients are analytically defined functions of the physical parameters $(\\theta, T)$ and the input current $I(\\cdot)$, sampled at sensor locations $s_i$.\n1.  **Coefficient for Constant Basis:** $c_0 = U(\\theta,T)$, directly mapping the physics of the open-circuit voltage to the corresponding basis function.\n2.  **Coefficients for Ohmic Term:** $c^{\\text{ohm}}_i = -R_0(\\theta,T) I(s_i)$. When combined with the partition-of-unity basis $\\phi_i(t)$, the sum $\\sum_i c^{\\text{ohm}}_i \\phi_i(t) = -R_0(\\theta,T) \\sum_i I(s_i) \\phi_i(t)$ provides a smooth approximation of the true ohmic drop, $-R_0(\\theta,T) I(t)$.\n3.  **Coefficients for Diffusive Term:** $c^{\\text{diff}}_{k,i} = -A(\\theta,T) w_k(\\theta,T) I(s_i) \\Delta s$. These coefficients scale the exponential basis functions. The term $I(s_i)\\Delta s$ approximates the infinitesimal element $I(\\tau')d\\tau'$ in the convolution integral. The key innovation is the gating weight $w_k(\\theta,T)$, which is computed via a softmax function applied to scores $r_k(\\theta,T) = -|\\log \\tau(\\theta,T) - \\log \\tau_d^{(k)}|$. This mechanism selects the dictionary kernel $\\tau_d^{(k)}$ that is \"closest\" to the true physical time constant $\\tau(\\theta,T)$ in a logarithmic sense, effectively allowing the fixed trunk basis to adapt to varying physical parameters.\n\n**Surrogate Voltage Assembly:** The final surrogate voltage $\\widehat{V}(t)$ is constructed by summing the contributions of all basis functions weighted by their corresponding coefficients:\n$$\n\\widehat{V}(t_n) = c_0 \\cdot \\xi_0(t_n) + \\sum_{i=1}^{m} c^{\\text{ohm}}_i \\cdot \\phi_{i}(t_n) + \\sum_{k=1}^{K} \\sum_{i=1}^{m} c^{\\text{diff}}_{k,i} \\cdot \\xi_{k,i}(t_n)\n$$\nThis summation is performed numerically for each point $t_n$ on the time grid.\n\n### Evaluation\n\nFor each of the four specified test cases, the input current profile $I(t)$, parameter $\\theta$, and temperature $T$ are used to compute both the ground-truth voltage $V(t_n)$ and the surrogate voltage $\\widehat{V}(t_n)$ across the time domain. The accuracy of the surrogate is then quantified by the Root Mean Square Error (RMSE):\n$$\n\\text{RMSE} = \\sqrt{\\frac{1}{N+1} \\sum_{n=0}^{N} \\big(\\widehat{V}(t_n) - V(t_n)\\big)^2}\n$$\nThe program calculates and reports this RMSE value for each case.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    # --- GLOBAL PARAMETERS ---\n    # Time discretization\n    t_max = 10.0\n    dt = 0.02\n    N = int(t_max / dt)\n    t_grid = np.linspace(0, t_max, N + 1)\n\n    # Sensor placement\n    m = 25\n    s_locs = np.linspace(0, t_max, m)\n    ds = t_max / (m - 1) if m > 1 else 0\n\n    # DeepONet dictionary parameters\n    tau_d = np.array([1.0, 4.0])\n    K = len(tau_d)\n\n    # Physical constants\n    T0 = 298.0\n    U0 = 3.6\n    R0_base = 0.01\n    tau_base = 2.0\n    A_base = 0.02\n    alpha = 0.10\n    beta = 0.001\n    delta = 0.20\n    eta = 0.50\n    zeta = 0.30\n    gamma = 300.0\n\n    # --- HELPER FUNCTIONS ---\n    def get_physical_params(theta, T):\n        \"\"\"Computes the physical parameters U, R0, tau, A for given theta and T.\"\"\"\n        U = U0 + alpha * theta + beta * (T - T0)\n        R0 = R0_base * np.exp(gamma / T) * (1 + delta * theta)\n        tau = tau_base * (1 + eta * theta) * (T0 / T)\n        A = A_base * (1 + zeta * theta) * np.sqrt(T0 / T)\n        return U, R0, tau, A\n\n    # --- GROUND-TRUTH MODEL ---\n    def calculate_V_true(I_t, theta, T):\n        \"\"\"Computes the ground-truth voltage V(t).\"\"\"\n        U, R0, tau, A = get_physical_params(theta, T)\n        \n        # Convolution term: A * integral( (1/tau) * exp(-(t-t'))/tau * I(t') dt' )\n        # Implemented as a discrete convolution\n        if tau > 1e-9: # Avoid division by zero\n            kernel = (1 / tau) * np.exp(-t_grid / tau)\n            convolution_integral = np.convolve(I_t, kernel)[:N + 1] * dt\n        else:\n            convolution_integral = np.zeros_like(t_grid)\n        \n        V_true = U - R0 * I_t - A * convolution_integral\n        return V_true\n\n    # --- PHYSICS-INFORMED DEEPONET SURROGATE ---\n    def calculate_V_hat(I_t, theta, T):\n        \"\"\"Computes the DeepONet surrogate voltage V_hat(t).\"\"\"\n        # Sample input current at sensor locations\n        I_s = np.interp(s_locs, t_grid, I_t)\n        \n        # Get physical parameters for branch network\n        U, R0, tau, A = get_physical_params(theta, T)\n        \n        # --- TRUNK NETWORK: Basis Functions ---\n        # 1. Constant basis\n        xi_0 = np.ones_like(t_grid)\n        \n        # 2. Input reconstruction basis (normalized Gaussians)\n        sigma = ds\n        phi_unnormalized = np.exp(-(t_grid[:, np.newaxis] - s_locs)**2 / (2 * sigma**2))\n        phi_sum = np.sum(phi_unnormalized, axis=1, keepdims=True)\n        # Prevent division by zero if sum is numerically zero\n        phi_sum[phi_sum  1e-9] = 1.0\n        phi_normalized = phi_unnormalized / phi_sum  # Shape: (N+1, m)\n\n        # 3. Diffusive kernel basis (causal exponentials)\n        xi_ki = np.zeros((K, m, N + 1))\n        for k in range(K):\n            for i in range(m):\n                mask = t_grid >= s_locs[i]\n                time_diff = t_grid[mask] - s_locs[i]\n                xi_ki[k, i, mask] = (1 / tau_d[k]) * np.exp(-time_diff / tau_d[k])\n                \n        # --- BRANCH NETWORK: Coefficients ---\n        # 1. Coefficient for constant basis\n        c_0 = U\n        \n        # 2. Coefficients for ohmic term\n        c_ohm_i = -R0 * I_s  # Shape: (m,)\n        \n        # 3. Coefficients for diffusive term\n        # Softmax gating weights w_k\n        r_k = -np.abs(np.log(tau) - np.log(tau_d))\n        exp_r_k = np.exp(r_k)\n        w_k = exp_r_k / np.sum(exp_r_k)  # Shape: (K,)\n        # Full coefficients c_diff_k,i\n        c_diff_ki = -A * w_k[:, np.newaxis] * I_s[np.newaxis, :] * ds # Shape: (K, m)\n\n        # --- ASSEMBLE SURROGATE VOLTAGE ---\n        # Term 1: Constant term\n        V_hat = c_0 * xi_0\n        \n        # Term 2: Ohmic term\n        ohmic_term = np.sum(c_ohm_i[np.newaxis, :] * phi_normalized, axis=1)\n        V_hat += ohmic_term\n        \n        # Term 3: Diffusive term\n        # Sum over k and i.\n        diffusive_term = np.sum(c_diff_ki[:, :, np.newaxis] * xi_ki, axis=(0, 1))\n        V_hat += diffusive_term\n        \n        return V_hat\n\n    # --- TEST SUITE ---\n    test_cases = [\n        (lambda t: 2.0 * np.sin(2 * np.pi * 0.5 * t), 0.5, 298.0),\n        (lambda t: 5.0 * (t >= 2.0), 1.5, 318.0),\n        (lambda t: np.zeros_like(t), 0.7, 290.0),\n        (lambda t: 8.0 * np.exp(-(t - 5.0)**2 / (2 * 0.15**2)), 0.2, 273.0),\n    ]\n\n    results = []\n    for i, (I_func, theta, T) in enumerate(test_cases):\n        I_t = I_func(t_grid)\n        \n        # Calculate ground-truth and surrogate voltages\n        V_true = calculate_V_true(I_t, theta, T)\n        V_hat = calculate_V_hat(I_t, theta, T)\n        \n        # Calculate RMSE\n        rmse = np.sqrt(np.mean((V_hat - V_true)**2))\n        results.append(rmse)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "A robust surrogate model for engineering applications must not only provide accurate point predictions but also quantify its own confidence. This final practice delves into the critical area of uncertainty quantification by evaluating the calibration of a model's predictive intervals. You will implement a procedure to compute the empirical coverage probability, a key metric that assesses whether the surrogate's stated uncertainty is reliable and trustworthy when tested against real-world, noisy measurements. ",
            "id": "3941070",
            "problem": "A physics-informed neural surrogate of the pseudo-two-dimensional (P2D) model, specifically a Physics-Informed Neural Network (PINN), produces time-resolved predictions of the terminal voltage of a lithium-ion cell under a given current profile. For each discrete time index $t$, the surrogate returns a predictive mean voltage $\\mu(t)$ and a predictive standard deviation $\\sigma_{\\text{model}}(t)$ that quantify uncertainty due to model approximation and latent variability. You are given withheld experimental measurements $y_{\\text{obs}}(t)$ of the same cell voltage. The measurement process is instrumented with a known, stationary measurement noise standard deviation $\\sigma_{\\text{meas}}$ expressed in volts. Assume the following foundational base: the latent predictive distribution of the surrogate for the voltage is Gaussian and independent of the Gaussian measurement noise, and the observed voltage is the sum of the latent voltage and the measurement noise. The goal is to evaluate the calibration of two-sided predictive intervals by computing empirical coverage probabilities on the withheld experiments.\n\nYour task is to write a complete program that, for each specified withheld experiment and each specified nominal coverage level, constructs a two-sided predictive interval for the observable voltage and computes the empirical coverage, defined as the fraction of observed samples whose measured voltage lies within the interval (including equality at the endpoints). All voltages and standard deviations are in volts; the coverage outputs are unitless decimals. Angles do not appear. Express all final coverage values as decimal numbers.\n\nUse the following test suite. For each case $i$, you are given:\n- the predicted means $\\mu_i = [\\mu_i(1),\\dots,\\mu_i(T_i)]$ in volts,\n- the predicted model standard deviations $\\sigma_{\\text{model},i} = [\\sigma_{\\text{model},i}(1),\\dots,\\sigma_{\\text{model},i(T_i)]$ in volts,\n- the known measurement noise standard deviation $\\sigma_{\\text{meas},i}$ in volts,\n- the observed voltages $y_{\\text{obs},i} = [y_{\\text{obs},i}(1),\\dots,y_{\\text{obs},i}(T_i)]$ in volts,\n- the list of nominal coverage levels $A = [a_1,a_2,a_3]$ as unitless decimals.\n\nConstruct each two-sided interval for the observable voltage at level $a_j \\in A$ from the combined predictive distribution implied by the independence and Gaussian assumptions. Then compute the empirical coverage for that interval as the fraction of time indices $t \\in \\{1,\\dots,T_i\\}$ for which the observed value $y_{\\text{obs},i}(t)$ lies within the interval (including the endpoints). Treat zero-width intervals as closed intervals.\n\nTest suite:\n- Case $1$ (well-calibrated, mild residuals):\n  - $\\mu_1 = [$ $3.90$, $3.88$, $3.86$, $3.84$, $3.82$, $3.80$ $]$ volts\n  - $\\sigma_{\\text{model},1} = [$ $0.01$, $0.01$, $0.01$, $0.01$, $0.01$, $0.01$ $]$ volts\n  - $\\sigma_{\\text{meas},1} = $ $0.01$ volts\n  - $y_{\\text{obs},1} = [$ $3.905$, $3.870$, $3.872$, $3.836$, $3.820$, $3.820$ $]$ volts\n- Case $2$ (underdispersed predictions):\n  - $\\mu_2 = [$ $3.90$, $3.88$, $3.86$, $3.84$, $3.82$, $3.80$ $]$ volts\n  - $\\sigma_{\\text{model},2} = [$ $0.002$, $0.002$, $0.002$, $0.002$, $0.002$, $0.002$ $]$ volts\n  - $\\sigma_{\\text{meas},2} = $ $0.005$ volts\n  - $y_{\\text{obs},2} = [$ $3.905$, $3.870$, $3.872$, $3.836$, $3.820$, $3.820$ $]$ volts\n- Case $3$ (edge case with zero noise and zero dispersion at one time):\n  - $\\mu_3 = [$ $4.00$, $3.95$, $3.90$, $3.85$ $]$ volts\n  - $\\sigma_{\\text{model},3} = [$ $0.00$, $0.005$, $0.005$, $0.005$ $]$ volts\n  - $\\sigma_{\\text{meas},3} = $ $0.00$ volts\n  - $y_{\\text{obs},3} = [$ $4.00$, $3.955$, $3.890$, $3.870$ $]$ volts\n\nNominal coverage levels (applied identically to all cases):\n- $A = [$ $0.5$, $0.8$, $0.95$ $]$.\n\nYour program must compute, for each case $i \\in \\{1,2,3\\}$ and each nominal level $a_j \\in A$, the empirical coverage as a decimal in $[0,1]$. The final output must be a single line containing a comma-separated list enclosed in square brackets with the coverages in the following order:\n$[$ $\\text{cov}(1,a_1)$, $\\text{cov}(1,a_2)$, $\\text{cov}(1,a_3)$, $\\text{cov}(2,a_1)$, $\\text{cov}(2,a_2)$, $\\text{cov}(2,a_3)$, $\\text{cov}(3,a_1)$, $\\text{cov}(3,a_2)$, $\\text{cov}(3,a_3)$ $]$.\n\nAssumptions to use:\n- The surrogate’s latent predictive distribution for voltage at each time $t$ is Gaussian with mean $\\mu(t)$ and standard deviation $\\sigma_{\\text{model}}(t)$.\n- The measurement noise is Gaussian with zero mean, independent of the latent predictive distribution, with known standard deviation $\\sigma_{\\text{meas}}$.\n\nAll voltages and standard deviations must be treated as being in volts; all output coverages must be unitless decimals. The final program must produce exactly one line in the specified format containing $9$ decimal numbers.",
            "solution": "We begin from the foundational definitions of Gaussian random variables and independence. Let the latent terminal voltage for a given time index be a Gaussian random variable $X$ with mean $\\mu$ and standard deviation $\\sigma_{\\text{model}}$, which represents the physics-informed neural surrogate’s predictive distribution. Let the measurement noise be an independent Gaussian random variable $N$ with mean $0$ and standard deviation $\\sigma_{\\text{meas}}$. The observed terminal voltage is $Y = X + N$.\n\nBy the properties of Gaussian random variables, the sum of independent Gaussian random variables is Gaussian, with mean equal to the sum of means and variance equal to the sum of variances. Thus,\n$$\nY \\sim \\mathcal{N}\\left(\\mu,\\; \\sigma_{\\text{total}}^{2}\\right), \\quad \\text{where} \\quad \\sigma_{\\text{total}} = \\sqrt{\\sigma_{\\text{model}}^{2} + \\sigma_{\\text{meas}}^{2}}.\n$$\nA two-sided central interval that contains a nominal mass $a \\in (0,1)$ of a Gaussian distribution is constructed by choosing a threshold $z$ such that\n$$\n\\mathbb{P}\\left(|Z| \\le z\\right) = a, \\quad \\text{where} \\quad Z \\sim \\mathcal{N}(0,1).\n$$\nEquivalently, $z = \\Phi^{-1}\\left(\\frac{1+a}{2}\\right)$ where $\\Phi$ is the cumulative distribution function of the standard normal distribution. Therefore, a two-sided interval for $Y$ at nominal mass $a$ is\n$$\n\\left[\\mu - z \\,\\sigma_{\\text{total}},\\; \\mu + z \\,\\sigma_{\\text{total}}\\right].\n$$\nFor empirical coverage estimation, given time indices $t \\in \\{1,\\dots,T\\}$ with predicted means $\\mu(t)$, predicted model standard deviations $\\sigma_{\\text{model}}(t)$, known measurement noise standard deviation $\\sigma_{\\text{meas}}$, and observed voltages $y_{\\text{obs}}(t)$, we compute\n$$\n\\sigma_{\\text{total}}(t) = \\sqrt{\\sigma_{\\text{model}}(t)^{2} + \\sigma_{\\text{meas}}^{2}},\n$$\nand define the interval for each $t$ as\n$$\nI_a(t) = \\left[\\mu(t) - z_a\\, \\sigma_{\\text{total}}(t),\\; \\mu(t) + z_a\\, \\sigma_{\\text{total}}(t)\\right], \\quad z_a = \\Phi^{-1}\\!\\left(\\frac{1+a}{2}\\right).\n$$\nWe then compute the empirical coverage as\n$$\n\\text{cov}(a) = \\frac{1}{T}\\sum_{t=1}^{T} \\mathbf{1}\\!\\left\\{ y_{\\text{obs}}(t) \\in I_a(t) \\right\\},\n$$\nwith interval membership inclusive at the endpoints. In the edge case $\\sigma_{\\text{total}}(t) = 0$, the interval degenerates to the single point $[\\mu(t),\\mu(t)]$, and only exact equality $y_{\\text{obs}}(t) = \\mu(t)$ counts as covered.\n\nWe apply this procedure to the specified test suite with $A = [$ $0.5$, $0.8$, $0.95$ $]$.\n\nCase $1$:\n- $\\mu_1 = [$ $3.90$, $3.88$, $3.86$, $3.84$, $3.82$, $3.80$ $]$,\n- $\\sigma_{\\text{model},1}(t) = $ $0.01$ for all $t$,\n- $\\sigma_{\\text{meas},1} = $ $0.01$,\n- $y_{\\text{obs},1} = [$ $3.905$, $3.870$, $3.872$, $3.836$, $3.820$, $3.820$ $]$.\nCompute $\\sigma_{\\text{total},1}(t) = \\sqrt{(0.01)^{2} + (0.01)^{2}} = \\sqrt{0.0002} \\approx 0.0141421356$ for all $t$. For $a = 0.5$, $z_{0.5} \\approx 0.6744897502$, giving a half-width $w_{0.5} \\approx 0.009545$. Residuals $y_{\\text{obs},1} - \\mu_1$ are [$0.005$, $-0.010$, $0.012$, $-0.004$, $0.000$, $0.020$], yielding coverage count $3$ of $6$, so $\\text{cov}(1,0.5) = 0.5$. For $a = 0.8$, $z_{0.8} \\approx 1.2815515655$ gives $w_{0.8} \\approx 0.018128$, with $5$ of $6$ covered, so $\\text{cov}(1,0.8) \\approx 0.8333333333333334$. For $a = 0.95$, $z_{0.95} \\approx 1.9599639845$ gives $w_{0.95} \\approx 0.027712$, with $6$ of $6$ covered, so $\\text{cov}(1,0.95) = 1.0$.\n\nCase $2$:\n- $\\mu_2 = [$ $3.90$, $3.88$, $3.86$, $3.84$, $3.82$, $3.80$ $]$,\n- $\\sigma_{\\text{model},2}(t) = $ $0.002$,\n- $\\sigma_{\\text{meas},2} = $ $0.005$,\n- $y_{\\text{obs},2} = [$ $3.905$, $3.870$, $3.872$, $3.836$, $3.820$, $3.820$ $]$.\nCompute $\\sigma_{\\text{total},2}(t) = \\sqrt{(0.002)^{2} + (0.005)^{2}} = \\sqrt{0.000029} \\approx 0.0053851648$. For $a = 0.5$, $w_{0.5} \\approx 0.003632$, coverage $1$ of $6$, so $\\text{cov}(2,0.5) \\approx 0.16666666666666666$. For $a = 0.8$, $w_{0.8} \\approx 0.006908$, coverage $3$ of $6$, so $\\text{cov}(2,0.8) = 0.5$. For $a = 0.95$, $w_{0.95} \\approx 0.010547$, coverage $4$ of $6$, so $\\text{cov}(2,0.95) \\approx 0.6666666666666666$.\n\nCase $3$:\n- $\\mu_3 = [$ $4.00$, $3.95$, $3.90$, $3.85$ $]$,\n- $\\sigma_{\\text{model},3} = [$ $0.00$, $0.005$, $0.005$, $0.005$ $]$,\n- $\\sigma_{\\text{meas},3} = $ $0.00$,\n- $y_{\\text{obs},3} = [$ $4.00$, $3.955$, $3.890$, $3.870$ $]$.\nCompute $\\sigma_{\\text{total},3} = [$ $0.00$, $0.005$, $0.005$, $0.005$ $]$. For $a = 0.5$, widths are [$0.000$, $0.003372$, $0.003372$, $0.003372$], coverage is $1$ of $4$, so $\\text{cov}(3,0.5) = 0.25$. For $a = 0.8$, widths are [$0.000$, $0.006408$, $0.006408$, $0.006408$], coverage is $2$ of $4$, so $\\text{cov}(3,0.8) = 0.5$. For $a = 0.95$, widths are [$0.000$, $0.009800$, $0.009800$, $0.009800$], coverage is $2$ of $4$, so $\\text{cov}(3,0.95) = 0.5$.\n\nTherefore, the program should output a single line containing\n$[$ $0.5$, $0.8333333333333334$, $1.0$, $0.16666666666666666$, $0.5$, $0.6666666666666666$, $0.25$, $0.5$, $0.5$ $]$\nin that exact order. The algorithmic steps are:\n- For each case, compute $\\sigma_{\\text{total}}(t)$ from $\\sigma_{\\text{model}}(t)$ and $\\sigma_{\\text{meas}}$.\n- For each nominal $a$, compute $z_a = \\Phi^{-1}\\!\\left(\\frac{1+a}{2}\\right)$.\n- Form intervals $\\left[\\mu(t) - z_a \\sigma_{\\text{total}}(t), \\mu(t) + z_a \\sigma_{\\text{total}}(t)\\right]$.\n- Count inclusions of $y_{\\text{obs}}(t)$ and divide by $T$ for empirical coverage.\n- Aggregate results in the specified order and print as a single-line list.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import norm\n\ndef empirical_coverage(mu, sigma_model, sigma_meas, y_obs, levels):\n    mu = np.asarray(mu, dtype=float)\n    sigma_model = np.asarray(sigma_model, dtype=float)\n    y_obs = np.asarray(y_obs, dtype=float)\n    # Total predictive std for observable under Gaussian + independence\n    sigma_total = np.sqrt(sigma_model**2 + float(sigma_meas)**2)\n    results = []\n    for a in levels:\n        z = norm.ppf((1.0 + float(a)) / 2.0)\n        half_width = z * sigma_total\n        lower = mu - half_width\n        upper = mu + half_width\n        # Inclusive interval membership\n        covered = (y_obs >= lower)  (y_obs = upper)\n        cov = covered.mean() if covered.size > 0 else float('nan')\n        results.append(cov)\n    return results\n\ndef solve():\n    # Test suite as specified in the problem statement\n    levels = [0.5, 0.8, 0.95]\n\n    # Case 1\n    mu1 = [3.90, 3.88, 3.86, 3.84, 3.82, 3.80]\n    sigma_model_1 = [0.01, 0.01, 0.01, 0.01, 0.01, 0.01]\n    sigma_meas_1 = 0.01\n    y_obs_1 = [3.905, 3.870, 3.872, 3.836, 3.820, 3.820]\n\n    # Case 2\n    mu2 = [3.90, 3.88, 3.86, 3.84, 3.82, 3.80]\n    sigma_model_2 = [0.002, 0.002, 0.002, 0.002, 0.002, 0.002]\n    sigma_meas_2 = 0.005\n    y_obs_2 = [3.905, 3.870, 3.872, 3.836, 3.820, 3.820]\n\n    # Case 3\n    mu3 = [4.00, 3.95, 3.90, 3.85]\n    sigma_model_3 = [0.00, 0.005, 0.005, 0.005]\n    sigma_meas_3 = 0.00\n    y_obs_3 = [4.00, 3.955, 3.890, 3.870]\n\n    # Compute coverages\n    cov1 = empirical_coverage(mu1, sigma_model_1, sigma_meas_1, y_obs_1, levels)\n    cov2 = empirical_coverage(mu2, sigma_model_2, sigma_meas_2, y_obs_2, levels)\n    cov3 = empirical_coverage(mu3, sigma_model_3, sigma_meas_3, y_obs_3, levels)\n\n    results = cov1 + cov2 + cov3\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}