{
    "hands_on_practices": [
        {
            "introduction": "可解释人工智能（XAI）的一项核心任务是将模型的输出归因于其输入特征。本实践将通过一个简化的正极材料共掺杂模型，介绍一种强大的归因方法——沙普利值（Shapley values, SHAP）。通过这个练习，你将亲手计算单个特征的贡献以及它们之间的交互作用，这对于理解协同效应等复杂现象至关重要。",
            "id": "3913432",
            "problem": "考虑一个用于自动化电池设计和仿真的、简化的且科学上可信的预测模型，该模型用于估算层状氧化物正极因两种阳离子共掺杂而引起的比容量（单位：毫安时/克）变化。设掺杂剂的摩尔分数分别为 $x_1$ 和 $x_2$（无量纲小数），模型预测值为\n$$\nf(x_1,x_2) = w_1 x_1 + w_2 x_2 + w_{12} x_1 x_2,\n$$\n其中 $w_1$ 和 $w_2$ 的单位是 $\\mathrm{mAh/g}$ 每单位掺杂剂分数，而 $w_{12}$ 的单位是 $\\mathrm{mAh/g}$ 每掺杂剂分数的平方。该模型捕捉了单个掺杂剂的效应以及一个模拟正极化学中存在的共掺杂协同或拮抗作用的二元交互项。\n\n在可解释性人工智能 (XAI) 中，Shapley 可加性解释 (SHAP) 使用合作博弈论将预测值归因于输入特征。对于一个实例 $x=(x_1,x_2)$，定义干预价值函数\n$$\nv(S) = f(x_S, b_{-S}),\n$$\n其中基线向量 $b=(b_1,b_2)$ 代表未掺杂的参考状态，即 $b_1=0$ 和 $b_2=0$。特征 $i$ 的 Shapley 值由合作博弈论定义给出\n$$\n\\phi_i = \\sum_{S \\subseteq N \\setminus \\{i\\}} \\frac{|S|!(M-|S|-1)!}{M!}\\left[v(S \\cup \\{i\\}) - v(S)\\right],\n$$\n其中 $N=\\{1,2\\}$ 且 $M=|N|=2$。特征对 $(i,j)$ 的 Shapley 交互指数（干预形式）定义为\n$$\n\\phi_{ij} = \\sum_{S \\subseteq N \\setminus \\{i,j\\}} \\frac{|S|!(M-|S|-2)!}{(M-1)!}\\left[v(S \\cup \\{i,j\\}) - v(S \\cup \\{i\\}) - v(S \\cup \\{j\\}) + v(S)\\right].\n$$\n对于 $M=2$，该式简化为\n$$\n\\phi_{12} = v(\\{1,2\\}) - v(\\{1\\}) - v(\\{2\\}) + v(\\emptyset).\n$$\n\n您的任务是实现一个程序，为每个提供的测试用例计算：\n1. Shapley 值 $\\phi_1$ 和 $\\phi_2$，单位为 $\\mathrm{mAh/g}$。\n2. Shapley 交互指数 $\\phi_{12}$，单位为 $\\mathrm{mAh/g}$。\n3. 一个布尔类型的协同作用标志，如果 $\\phi_{12} > 0$ 则为 $\\mathrm{True}$，否则为 $\\mathrm{False}$，将正交互作用解释为协同共掺杂，非正交互作用解释为拮抗或中性。\n4. 一个布尔类型的守恒性检验，如果 $\\phi_1 + \\phi_2$ 与 $f(x_1,x_2) - f(b_1,b_2)$ 在 $10^{-12}$ 的绝对容差内相等，则为 $\\mathrm{True}$，否则为 $\\mathrm{False}$。\n\n所有浮点数输出必须四舍五入到 $6$ 位小数，并以 $\\mathrm{mAh/g}$ 表示。掺杂剂分数 $x_1$ 和 $x_2$ 必须作为小数（而非百分比）处理。\n\n使用以下测试套件（每个元组为 $(w_1,w_2,w_{12},x_1,x_2,b_1,b_2)$）：\n- 情况 A（典型的协同共掺杂）：$(50.0, 30.0, 40.0, 0.02, 0.03, 0.0, 0.0)$。\n- 情况 B（拮抗共掺杂）：$(50.0, 60.0, -80.0, 0.01, 0.02, 0.0, 0.0)$。\n- 情况 C（无交互作用，仅存在单一掺杂剂）：$(45.0, 20.0, 0.0, 0.05, 0.0, 0.0, 0.0)$。\n- 情况 D（边界情况，一种掺杂剂缺失，交互作用系数为正）：$(35.0, 25.0, 100.0, 0.0, 0.04, 0.0, 0.0)$。\n- 情况 E（有害的单一掺杂剂，但有弱协同作用）：$( -10.0, 40.0, 10.0, 0.03, 0.03, 0.0, 0.0)$。\n\n您的程序应生成单行输出，包含一个用方括号括起来的、以逗号分隔的结果列表。此列表中的每个元素对应一个测试用例，并且本身必须是 $[\\phi_1,\\phi_2,\\phi_{12},\\mathrm{synergy},\\mathrm{conservation}]$ 形式的列表，其中 $\\phi_1$、$\\phi_2$ 和 $\\phi_{12}$ 是四舍五入到 $6$ 位小数的浮点数（单位为 $\\mathrm{mAh/g}$），而 $\\mathrm{synergy}$ 和 $\\mathrm{conservation}$ 是布尔值。例如，输出应类似于 $[[\\dots],[\\dots],[\\dots],[\\dots],[\\dots]]$，不含任何额外文本。",
            "solution": "首先对问题进行验证，以确保其科学上可靠、定义明确且客观。\n\n### 第 1 步：提取已知条件\n- **预测模型**：比容量的变化由函数 $f(x_1, x_2) = w_1 x_1 + w_2 x_2 + w_{12} x_1 x_2$ 给出，其中 $x_1$ 和 $x_2$ 是掺杂剂摩尔分数。\n- **干预价值函数**：$v(S) = f(x_S, b_{-S})$。\n- **基线向量**：未掺杂的参考状态是 $b = (b_1, b_2) = (0, 0)$。\n- **特征数量**：$M = |N| = 2$，其中 $N = \\{1, 2\\}$。\n- **Shapley 值公式**：$\\phi_i = \\sum_{S \\subseteq N \\setminus \\{i\\}} \\frac{|S|!(M-|S|-1)!}{M!}\\left[v(S \\cup \\{i\\}) - v(S)\\right]$。\n- **Shapley 交互指数公式（对于 $M=2$）**：$\\phi_{12} = v(\\{1,2\\}) - v(\\{1\\}) - v(\\{2\\}) + v(\\emptyset)$。\n- **任务**：\n  1. 计算 Shapley 值 $\\phi_1$ 和 $\\phi_2$。\n  2. 计算 Shapley 交互指数 $\\phi_{12}$。\n  3. 确定协同作用标志：如果 $\\phi_{12} > 0$ 则为 $\\mathrm{True}$。\n  4. 执行守恒性检验：如果 $|\\phi_1 + \\phi_2 - (f(x_1,x_2) - f(b_1,b_2))| \\le 10^{-12}$ 则为 $\\mathrm{True}$。\n- **输出要求**：浮点数值必须四舍五入到 $6$ 位小数。\n- **测试用例**：\n  - A: $(w_1,w_2,w_{12},x_1,x_2,b_1,b_2) = (50.0, 30.0, 40.0, 0.02, 0.03, 0.0, 0.0)$。\n  - B: $(w_1,w_2,w_{12},x_1,x_2,b_1,b_2) = (50.0, 60.0, -80.0, 0.01, 0.02, 0.0, 0.0)$。\n  - C: $(w_1,w_2,w_{12},x_1,x_2,b_1,b_2) = (45.0, 20.0, 0.0, 0.05, 0.0, 0.0, 0.0)$。\n  - D: $(w_1,w_2,w_{12},x_1,x_2,b_1,b_2) = (35.0, 25.0, 100.0, 0.0, 0.04, 0.0, 0.0)$。\n  - E: $(w_1,w_2,w_{12},x_1,x_2,b_1,b_2) = ( -10.0, 40.0, 10.0, 0.03, 0.03, 0.0, 0.0)$。\n\n### 第 2 步：使用提取的已知条件进行验证\n- **科学可靠性**：该问题基于材料科学和可解释性人工智能。预测模型是一个简单的多项式，这是材料信息学中常见的起点。使用 Shapley 值进行特征归因是 XAI 中一种标准的、数学上严谨的方法。正极中共掺杂的背景是科学相关的。该问题有效。\n- **定义明确性**：该问题提供了所有必要的公式、数据和一组明确的任务。对于每个输入测试用例，可以通过直接应用所提供的定义来计算出一组唯一的输出。该问题有效。\n- **客观性**：所有术语都经过数学定义。任务是定量的，基于提供的模型和定义，没有主观解释的余地。该问题有效。\n- **结论**：该问题未违反任何无效性标准。它是完整的、一致的、科学上可信的且定义明确的。\n\n### 第 3 步：结论与行动\n该问题有效。将制定解决方案。\n\n### 基于原则的设计与求解\n\n问题的核心是为给定的预测模型 $f(x_1, x_2)$ 推导出 Shapley 值和交互指数的解析表达式。这避免了数值近似，并提供了精确解。\n\n首先，我们为所有可能的子集 $S \\subseteq N = \\{1, 2\\}$ 计算干预价值函数 $v(S)$。实例为 $x = (x_1, x_2)$，基线为 $b = (0, 0)$。\n\n1.  $S = \\emptyset$：特征子集为空。我们对所有特征使用基线值。\n    $v(\\emptyset) = f(b_1, b_2) = f(0, 0) = w_1(0) + w_2(0) + w_{12}(0)(0) = 0$。\n\n2.  $S = \\{1\\}$：我们对特征 1 使用实例值 ($x_1$)，对特征 2 使用基线值 ($b_2$)。\n    $v(\\{1\\}) = f(x_1, b_2) = f(x_1, 0) = w_1 x_1 + w_2(0) + w_{12}x_1(0) = w_1 x_1$。\n\n3.  $S = \\{2\\}$：我们对特征 1 使用基线值 ($b_1$)，对特征 2 使用实例值 ($x_2$)。\n    $v(\\{2\\}) = f(b_1, x_2) = f(0, x_2) = w_1(0) + w_2 x_2 + w_{12}(0)x_2 = w_2 x_2$。\n\n4.  $S = \\{1, 2\\}$：我们对两个特征都使用实例值。\n    $v(\\{1, 2\\}) = f(x_1, x_2) = w_1 x_1 + w_2 x_2 + w_{12} x_1 x_2$。\n\n有了这些值，我们就可以计算 Shapley 值 $\\phi_1$ 和 $\\phi_2$。对于 $M=2$ 个特征，通用的 Shapley 公式得以简化。特征 $i$ 的 Shapley 值是其在所有可能的特征排序上的边际贡献的平均值。对于两个特征，两种排序是 $(1, 2)$ 和 $(2, 1)$。\n\n特征 1 首先被添加时的边际贡献是 $v(\\{1\\}) - v(\\emptyset)$。\n特征 1 在特征 2 之后被添加时的边际贡献是 $v(\\{1, 2\\}) - v(\\{2\\})$。\nShapley 值 $\\phi_1$ 是这两个贡献的平均值：\n$$\n\\phi_1 = \\frac{1}{2} \\left[ (v(\\{1\\}) - v(\\emptyset)) + (v(\\{1, 2\\}) - v(\\{2\\})) \\right]\n$$\n代入先验计算的值：\n$$\n\\phi_1 = \\frac{1}{2} \\left[ (w_1 x_1 - 0) + ( (w_1 x_1 + w_2 x_2 + w_{12} x_1 x_2) - w_2 x_2 ) \\right]\n$$\n$$\n\\phi_1 = \\frac{1}{2} \\left[ w_1 x_1 + w_1 x_1 + w_{12} x_1 x_2 \\right] = \\frac{1}{2} \\left[ 2 w_1 x_1 + w_{12} x_1 x_2 \\right]\n$$\n$$\n\\phi_1 = w_1 x_1 + \\frac{1}{2} w_{12} x_1 x_2\n$$\n通过对称性，交换索引 $1$ 和 $2$，我们得到 $\\phi_2$：\n$$\n\\phi_2 = w_2 x_2 + \\frac{1}{2} w_{12} x_1 x_2\n$$\n接下来，我们使用 $M=2$ 的简化公式计算 Shapley 交互指数 $\\phi_{12}$：\n$$\n\\phi_{12} = v(\\{1,2\\}) - v(\\{1\\}) - v(\\{2\\}) + v(\\emptyset)\n$$\n代入我们的值：\n$$\n\\phi_{12} = (w_1 x_1 + w_2 x_2 + w_{12} x_1 x_2) - (w_1 x_1) - (w_2 x_2) + 0\n$$\n$$\n\\phi_{12} = w_{12} x_1 x_2\n$$\n这个结果很直观：交互指数分离出了模型中交互项 $w_{12} x_1 x_2$ 的贡献。Shapley 值 $\\phi_1$ 和 $\\phi_2$ 将各自的线性效应（$w_1 x_1$ 和 $w_2 x_2$）完全归因于特征 1 和 2，并将交互效应（$w_{12} x_1 x_2$）在它们之间均等分配。\n\n如果 $\\phi_{12} > 0$，协同作用标志为 $\\mathrm{True}$，这对应于一个正的（协同的）交互效应。\n\n最后，我们执行守恒性检验。这是 Shapley 值的一个基本性质，称为效率性。Shapley 值的总和必须等于从基线开始的预测总变化量。\n$$\n\\phi_1 + \\phi_2 = (w_1 x_1 + \\frac{1}{2} w_{12} x_1 x_2) + (w_2 x_2 + \\frac{1}{2} w_{12} x_1 x_2) = w_1 x_1 + w_2 x_2 + w_{12} x_1 x_2\n$$\n从基线开始的预测变化量是：\n$$\nf(x_1, x_2) - f(b_1, b_2) = f(x_1, x_2) - f(0, 0) = (w_1 x_1 + w_2 x_2 + w_{12} x_1 x_2) - 0\n$$\n因此，我们发现 $\\phi_1 + \\phi_2 = f(x_1, x_2) - f(b_1, b_2)$ 精确成立。守恒性检验在所有情况下都应为 $\\mathrm{True}$，它可以作为对实现正确性（防止浮点运算误差）的稳健验证。\n\n算法如下：\n1. 对于每个测试用例 $(w_1, w_2, w_{12}, x_1, x_2, b_1, b_2)$：\n2. 计算交互项效应：$I = w_{12} x_1 x_2$。\n3. 计算 $\\phi_{12} = I$。\n4. 计算 $\\phi_1 = w_1 x_1 + \\frac{1}{2} I$。\n5. 计算 $\\phi_2 = w_2 x_2 + \\frac{1}{2} I$。\n6. 确定协同作用：$\\phi_{12} > 0$。\n7. 执行守恒性检验：$|\\phi_1 + \\phi_2 - (w_1 x_1 + w_2 x_2 + I)| \\le 10^{-12}$。\n8. 将 $\\phi_1, \\phi_2, \\phi_{12}$ 四舍五入到 $6$ 位小数。\n9. 将结果整理成一个列表。\n10. 汇总所有测试用例的结果并格式化最终输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Calculates Shapley values and interaction indices for a battery cathode model\n    and prints the results for a suite of test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each tuple is (w1, w2, w12, x1, x2, b1, b2).\n    test_cases = [\n        # Case A (typical synergistic co-doping)\n        (50.0, 30.0, 40.0, 0.02, 0.03, 0.0, 0.0),\n        # Case B (antagonistic co-doping)\n        (50.0, 60.0, -80.0, 0.01, 0.02, 0.0, 0.0),\n        # Case C (no interaction, single-dopant present)\n        (45.0, 20.0, 0.0, 0.05, 0.0, 0.0, 0.0),\n        # Case D (boundary with one dopant absent, positive interaction coefficient)\n        (35.0, 25.0, 100.0, 0.0, 0.04, 0.0, 0.0),\n        # Case E (harmful single dopant with weak synergy)\n        (-10.0, 40.0, 10.0, 0.03, 0.03, 0.0, 0.0),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        w1, w2, w12, x1, x2, b1, b2 = case\n\n        # The predictive model is f(x1, x2) = w1*x1 + w2*x2 + w12*x1*x2.\n        # The baseline is b = (0, 0), so f(b1, b2) = 0.\n        \n        # 1. Calculate Shapley interaction index phi_12\n        # phi_12 = v({1,2}) - v({1}) - v({2}) + v(0)\n        # v({1,2}) = f(x1, x2) = w1*x1 + w2*x2 + w12*x1*x2\n        # v({1}) = f(x1, 0) = w1*x1\n        # v({2}) = f(0, x2) = w2*x2\n        # v(0) = f(0, 0) = 0\n        # phi_12 = (w1*x1 + w2*x2 + w12*x1*x2) - (w1*x1) - (w2*x2) + 0\n        # phi_12 = w12 * x1 * x2\n        phi_12 = w12 * x1 * x2\n\n        # 2. Calculate Shapley values phi_1 and phi_2\n        # phi_1 = w1*x1 + 0.5 * w12*x1*x2\n        # phi_2 = w2*x2 + 0.5 * w12*x1*x2\n        phi_1 = w1 * x1 + 0.5 * phi_12\n        phi_2 = w2 * x2 + 0.5 * phi_12\n\n        # 3. Determine synergy flag\n        # True if phi_12 > 0\n        synergy = phi_12 > 0\n\n        # 4. Perform conservation check\n        # Check if phi_1 + phi_2 = f(x1, x2) - f(b1, b2)\n        f_x = w1 * x1 + w2 * x2 + w12 * x1 * x2\n        f_b = w1 * b1 + w2 * b2 + w12 * b1 * b2 # This is always 0 for the given cases.\n        total_effect = f_x - f_b\n        shapley_sum = phi_1 + phi_2\n        \n        # Use a tolerance for floating point comparison\n        conservation = abs(shapley_sum - total_effect) = 1e-12\n        \n        # Round the float outputs to 6 decimal places.\n        phi_1_rounded = round(phi_1, 6)\n        phi_2_rounded = round(phi_2, 6)\n        phi_12_rounded = round(phi_12, 6)\n\n        results.append([\n            phi_1_rounded,\n            phi_2_rounded,\n            phi_12_rounded,\n            synergy,\n            conservation\n        ])\n\n    # Final print statement in the exact required format.\n    # The format is a list of lists, represented as a string.\n    # e.g., [[val1, val2,...], [val1, val2,...]]\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "生成解释本身并非终点，我们还必须验证其可信度或“忠实度”（faithfulness）。本练习将实施一种标准的归因方法评估技术——删除测试。通过系统性地扰动解释所识别出的最重要特征，并在一个基于物理的模型上测量其对性能的实际影响，我们可以量化评估解释在多大程度上捕捉了模型的真实行为。",
            "id": "3913442",
            "problem": "在自动化电池设计和仿真的背景下，考虑一个用于锂离子电池的可解释人工智能模型，该模型使用归因方法根据输入设计特征对性能指标的影响对其进行排序。您必须通过删除测试来评估该归因的忠实度：在物理上合理的范围内，朝着预期会降低性能的方向扰动归因值最高的特征，然后计算性能下降作为定量指标。\n\n基本原理和建模假设：\n\n- 欧姆定律指出，对于一系列串联的电阻元件，电压降为 $V = I R$，其中 $V$ 是电压（单位 $\\mathrm{V}$），$I$ 是电流（单位 $\\mathrm{A}$），$R$ 是电阻（单位 $\\Omega$）。串联电阻线性相加。\n- 多孔介质中有效电解质电导率的 Bruggeman 关系式为 $\\kappa_{\\text{eff}} = \\kappa \\varepsilon_e^b$，其中 $\\kappa$ 是体电解质电导率（单位 $\\mathrm{S/m}$），$\\varepsilon_e$ 是电解质孔隙率（无量纲），$b$ 是 Bruggeman 指数（无量纲）。\n- 球形活性材料的比表面积为 $a = 3 \\varepsilon_s / r_p$，其中 $\\varepsilon_s$ 是固体体积分数（无量纲），$r_p$ 是颗粒半径（单位 $\\mathrm{m}$）。\n- 交换电流密度遵循阿伦尼乌斯型定律 $i_0 = i_{0,\\text{ref}} \\exp\\!\\left(-\\dfrac{E_a}{R_g} \\left(\\dfrac{1}{T} - \\dfrac{1}{T_{\\text{ref}}}\\right)\\right)$，其中 $i_{0,\\text{ref}}$ 是参考交换电流密度（单位 $\\mathrm{A/m^2}$），$E_a$ 是活化能（单位 $\\mathrm{J/mol}$），$R_g$ 是普适气体常数（单位 $\\mathrm{J/(mol\\cdot K)}$），$T$ 是温度（单位 $\\mathrm{K}$），$T_{\\text{ref}}$ 是参考温度（单位 $\\mathrm{K}$）。\n- 对于小过电势，线性化的电荷转移电阻为 $R_{\\text{ct}} = \\dfrac{R_g T}{n F a i_0 A}$，其中 $n$ 是电子数（无量纲），$F$ 是法拉第常数（单位 $\\mathrm{C/mol}$），$A$ 是电极面积（单位 $\\mathrm{m^2}$）。\n- 由电解质和隔膜引起的欧姆电阻为 $R_{\\text{ohm}} = \\dfrac{L_e}{\\kappa_{\\text{eff}} A} + \\dfrac{\\delta_s}{\\kappa_{\\text{sep,eff}} A}$，其中 $L_e$ 是电极厚度（单位 $\\mathrm{m}$），$\\delta_s$ 是隔膜厚度（单位 $\\mathrm{m}$），$A$ 是电极面积（单位 $\\mathrm{m^2}$），$\\kappa_{\\text{sep,eff}} = \\kappa_{\\text{sep}} \\varepsilon_{\\text{sep}}^b$，其中隔膜孔隙率为 $\\varepsilon_{\\text{sep}}$（无量纲），隔膜电导率为 $\\kappa_{\\text{sep}}$（单位 $\\mathrm{S/m}$）。\n- 总电阻为 $R_{\\text{total}} = R_{\\text{ohm}} + R_{\\text{ct}}$，负载下的电池端电压为 $V = V_{\\text{oc}} - I R_{\\text{total}}$，其中 $V_{\\text{oc}}$ 是开路电压（单位 $\\mathrm{V}$），$I$ 是放电电流（单位 $\\mathrm{A}$）。\n- 在持续 $t$ 秒的恒流放电过程中释放的能量为 $E = \\max\\!\\left(0, V I t\\right)$，单位为 $\\mathrm{J}$。\n\n基于归因的删除测试设计：\n\n- 给定一个特征向量 $\\mathbf{x}$，定义特征及其物理单位如下：\n  - $\\varepsilon_e$（无量纲），$r_p$（单位 $\\mathrm{m}$），$L_e$（单位 $\\mathrm{m}$），$\\delta_s$（单位 $\\mathrm{m}$），$T$（单位 $\\mathrm{K}$），$\\kappa$（单位 $\\mathrm{S/m}$），$\\kappa_{\\text{sep}}$（单位 $\\mathrm{S/m}$），$A$（单位 $\\mathrm{m^2}$），$i_{0,\\text{ref}}$（单位 $\\mathrm{A/m^2}$），$V_{\\text{oc}}$（单位 $\\mathrm{V}$），$I$（单位 $\\mathrm{A}$），$t$（单位 $\\mathrm{s}$）。\n- 使用的常量为：$R_g = 8.314\\ \\mathrm{J/(mol\\cdot K)}$，$F = 96485\\ \\mathrm{C/mol}$，$b = 1.5$，$\\varepsilon_{\\text{filler}} = 0.03$，$\\varepsilon_{\\text{sep}} = 0.4$，$E_a = 34000\\ \\mathrm{J/mol}$，$T_{\\text{ref}} = 298.15\\ \\mathrm{K}$，$n = 1$。固体体积分数为 $\\varepsilon_s = 1 - \\varepsilon_e - \\varepsilon_{\\text{filler}}$，且必须为非负值；如果为负，则视为零。\n- 使用基于梯度的归因，其定义为绝对梯度 $\\left|\\dfrac{\\partial E}{\\partial x_i}\\right|$，该梯度通过在每个 $x_i$ 的可行边界内使用对称有限差分进行数值估算。\n- 设 $k$ 为要扰动的归因值最高的特征数量。按 $\\left|\\dfrac{\\partial E}{\\partial x_i}\\right|$ 的降序对特征进行排序，选择前 $k$ 个，并对于每个选定的特征 $x_i$，根据 $\\dfrac{\\partial E}{\\partial x_i}$ 的符号，将其向最能减小 $E$ 的方向移动，移动量等于预算分数 $b_{\\text{frac}}$ 乘以其可行范围长度，并裁剪到物理上合理的边界内。如果 $k = 0$，则不扰动任何特征。\n- 性能下降指标为 $M = \\dfrac{E_{\\text{base}} - E_{\\text{pert}}}{E_{\\text{base}}}$，表示为小数（不带百分号）。如果 $E_{\\text{base}} = 0$，则定义 $M = 0$。\n\n每个特征的物理上合理的边界：\n- $\\varepsilon_e \\in [0.2, 0.6]$, $r_p \\in [1\\times 10^{-6}, 1.5\\times 10^{-5}]\\ \\mathrm{m}$, $L_e \\in [5\\times 10^{-5}, 2\\times 10^{-4}]\\ \\mathrm{m}$, $\\delta_s \\in [1\\times 10^{-5}, 3\\times 10^{-5}]\\ \\mathrm{m}$, $T \\in [283.15, 323.15]\\ \\mathrm{K}$, $\\kappa \\in [0.5, 2.0]\\ \\mathrm{S/m}$, $\\kappa_{\\text{sep}} \\in [0.3, 1.5]\\ \\mathrm{S/m}$, $A \\in [0.01, 0.05]\\ \\mathrm{m^2}$, $i_{0,\\text{ref}} \\in [1\\times 10^{-6}, 1\\times 10^{-3}]\\ \\mathrm{A/m^2}$, $V_{\\text{oc}} \\in [3.0, 4.2]\\ \\mathrm{V}$, $I \\in [5, 30]\\ \\mathrm{A}$, $t \\in [600, 3600]\\ \\mathrm{s}$。\n\n您的任务：\n\n- 根据上述基本原理推导出 $E$ 的表达式。\n- 使用保持在边界内的对称有限差分，实现 $E$ 相对于每个特征的数值梯度计算。\n- 实现所描述的删除测试，并为每个指定的测试用例计算 $M$。\n\n请使用以下参数值测试套件，每个测试用例以 $(\\mathbf{x}, k, b_{\\text{frac}})$ 的形式给出：\n\n- 测试用例 1（典型条件）：\n  - $\\varepsilon_e = 0.35$, $r_p = 5\\times 10^{-6}\\ \\mathrm{m}$, $L_e = 1\\times 10^{-4}\\ \\mathrm{m}$, $\\delta_s = 2\\times 10^{-5}\\ \\mathrm{m}$, $T = 298.15\\ \\mathrm{K}$, $\\kappa = 1.2\\ \\mathrm{S/m}$, $\\kappa_{\\text{sep}} = 0.8\\ \\mathrm{S/m}$, $A = 0.02\\ \\mathrm{m^2}$, $i_{0,\\text{ref}} = 1\\times 10^{-4}\\ \\mathrm{A/m^2}$, $V_{\\text{oc}} = 3.9\\ \\mathrm{V}$, $I = 10\\ \\mathrm{A}$, $t = 1800\\ \\mathrm{s}$，其中 $k = 3$, $b_{\\text{frac}} = 0.2$。\n- 测试用例 2（接近边界，较重极化）：\n  - $\\varepsilon_e = 0.25$, $r_p = 1.2\\times 10^{-5}\\ \\mathrm{m}$, $L_e = 1.9\\times 10^{-4}\\ \\mathrm{m}$, $\\delta_s = 2.8\\times 10^{-5}\\ \\mathrm{m}$, $T = 283.15\\ \\mathrm{K}$, $\\kappa = 0.6\\ \\mathrm{S/m}$, $\\kappa_{\\text{sep}} = 0.5\\ \\mathrm{S/m}$, $A = 0.015\\ \\mathrm{m^2}$, $i_{0,\\text{ref}} = 5\\times 10^{-5}\\ \\mathrm{A/m^2}$, $V_{\\text{oc}} = 3.7\\ \\mathrm{V}$, $I = 25\\ \\mathrm{A}$, $t = 1200\\ \\mathrm{s}$，其中 $k = 4$, $b_{\\text{frac}} = 0.3$。\n- 测试用例 3（$k=0$ 的边缘情况）：\n  - $\\varepsilon_e = 0.4$, $r_p = 8\\times 10^{-6}\\ \\mathrm{m}$, $L_e = 1.2\\times 10^{-4}\\ \\mathrm{m}$, $\\delta_s = 2.2\\times 10^{-5}\\ \\mathrm{m}$, $T = 305.15\\ \\mathrm{K}$, $\\kappa = 1.5\\ \\mathrm{S/m}$, $\\kappa_{\\text{sep}} = 1.0\\ \\mathrm{S/m}$, $A = 0.025\\ \\mathrm{m^2}$, $i_{0,\\text{ref}} = 2\\times 10^{-4}\\ \\mathrm{A/m^2}$, $V_{\\text{oc}} = 4.0\\ \\mathrm{V}$, $I = 12\\ \\mathrm{A}$, $t = 2000\\ \\mathrm{s}$，其中 $k = 0$, $b_{\\text{frac}} = 0.25$。\n- 测试用例 4（高性能设计）：\n  - $\\varepsilon_e = 0.5$, $r_p = 3\\times 10^{-6}\\ \\mathrm{m}$, $L_e = 7\\times 10^{-5}\\ \\mathrm{m}$, $\\delta_s = 1.5\\times 10^{-5}\\ \\mathrm{m}$, $T = 313.15\\ \\mathrm{K}$, $\\kappa = 1.8\\ \\mathrm{S/m}$, $\\kappa_{\\text{sep}} = 1.2\\ \\mathrm{S/m}$, $A = 0.03\\ \\mathrm{m^2}$, $i_{0,\\text{ref}} = 8\\times 10^{-4}\\ \\mathrm{A/m^2}$, $V_{\\text{oc}} = 4.1\\ \\mathrm{V}$, $I = 15\\ \\mathrm{A}$, $t = 2400\\ \\mathrm{s}$，其中 $k = 5$, $b_{\\text{frac}} = 0.1$。\n\n输出规格：\n\n- 对于每个测试用例，计算 $M$ 并将其表示为四舍五入到六位小数的浮点数。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，例如 $[m_1,m_2,m_3,m_4]$，其中每个 $m_i$ 按顺序对应于测试用例 $i$。\n\n所有物理量必须使用上述单位进行处理。不使用角度。百分比必须表示为小数，而不是带百分号。",
            "solution": "此问题被评估为**有效**。它在科学上基于成熟的电池建模原理，内容自洽，且算法定义明确。所提供的数据和常量在物理上是合理的，并且内部一致。\n\n任务是实现一个基于归因的删除测试，以评估一个简化的基于物理的锂离子电池模型的梯度归因方法的忠实度。性能指标是释放的能量 $E$。忠实度指标是在扰动影响最大的特征后计算的性能下降值 $M$。\n\n解决方案分三个阶段展开：\n1.  从提供的基本方程推导出能量函数 $E(\\mathbf{x})$ 的完整表达式。\n2.  阐明用于计算基于梯度的归因 $\\left|\\dfrac{\\partial E}{\\partial x_i}\\right|$ 的数值算法。\n3.  形式化删除测试流程，包括特征排序、扰动以及性能下降指标 $M$ 的计算。\n\n**1. 释放能量 $E(\\mathbf{x})$ 的表达式**\n\n释放的能量 $E$ 是一个 12 维特征向量 $\\mathbf{x} = (\\varepsilon_e, r_p, L_e, \\delta_s, T, \\kappa, \\kappa_{\\text{sep}}, A, i_{0,\\text{ref}}, V_{\\text{oc}}, I, t)$ 的函数。能量的最终表达式为：\n$$E(\\mathbf{x}) = \\max\\!\\left(0, (V_{\\text{oc}} - I \\cdot R_{\\text{total}}) \\cdot I \\cdot t\\right)$$\n其中 $R_{\\text{total}}$ 是电池的总内阻。该电阻是欧姆电阻 $R_{\\text{ohm}}$ 和电荷转移电阻 $R_{\\text{ct}}$ 的总和。\n$$R_{\\text{total}} = R_{\\text{ohm}} + R_{\\text{ct}}$$\n每个电阻分量的推导如下：\n\n**欧姆电阻, $R_{\\text{ohm}}$**\n欧姆电阻源于离子在多孔电极和隔膜中的传输。其表达式为：\n$$R_{\\text{ohm}} = \\dfrac{L_e}{\\kappa_{\\text{eff}} A} + \\dfrac{\\delta_s}{\\kappa_{\\text{sep,eff}} A} = \\frac{1}{A} \\left( \\frac{L_e}{\\kappa_{\\text{eff}}} + \\frac{\\delta_s}{\\kappa_{\\text{sep,eff}}} \\right)$$\n此处，$L_e$ 是电极厚度，$\\delta_s$ 是隔膜厚度，$A$ 是电极面积。有效电导率 $\\kappa_{\\text{eff}}$ 和 $\\kappa_{\\text{sep,eff}}$ 使用 Bruggeman 关系式计算：\n$$ \\kappa_{\\text{eff}} = \\kappa \\varepsilon_e^b $$\n$$ \\kappa_{\\text{sep,eff}} = \\kappa_{\\text{sep}} \\varepsilon_{\\text{sep}}^b $$\n其中 $\\kappa$ 和 $\\kappa_{\\text{sep}}$ 分别是电极和隔膜中电解质的体电导率；$\\varepsilon_e$ 和 $\\varepsilon_{\\text{sep}}$ 是各自的孔隙率；$b$ 是 Bruggeman 指数。\n\n**电荷转移电阻, $R_{\\text{ct}}$**\n电荷转移电阻模拟了活性材料颗粒表面电化学反应的动力学限制。对于小过电势，它被线性化为：\n$$R_{\\text{ct}} = \\dfrac{R_g T}{n F a i_0 A}$$\n其中 $R_g$ 是普适气体常数，$T$ 是温度，$n$ 是转移的电子数，$F$ 是法拉第常数。其对特征向量 $\\mathbf{x}$ 的关键依赖关系体现在比表面积 $a$ 和交换电流密度 $i_0$ 上。\n\n球形颗粒的比表面积 $a$ 为：\n$$a = \\frac{3 \\varepsilon_s}{r_p}$$\n其中 $r_p$ 是颗粒半径，$\\varepsilon_s$ 是固体体积分数。$\\varepsilon_s$ 定义为 $\\varepsilon_s = 1 - \\varepsilon_e - \\varepsilon_{\\text{filler}}$。由于所给定的 $\\varepsilon_e$ 边界 ($[0.2, 0.6]$) 和常量 $\\varepsilon_{\\text{filler}} = 0.03$ 确保了 $1 - \\varepsilon_e - \\varepsilon_{\\text{filler}}  0$，因此将负 $\\varepsilon_s$ 视为零的条件不会被触发。\n\n交换电流密度 $i_0$ 遵循阿伦尼乌斯型温度依赖关系：\n$$i_0 = i_{0,\\text{ref}} \\exp\\!\\left(-\\dfrac{E_a}{R_g} \\left(\\dfrac{1}{T} - \\dfrac{1}{T_{\\text{ref}}}\\right)\\right)$$\n其中 $i_{0,\\text{ref}}$ 是参考交换电流密度，$E_a$ 是活化能，$T_{\\text{ref}}$ 是参考温度。\n\n代入所有中间表达式，可以得到一个单一、复杂、非线性的函数 $E(\\mathbf{x})$，它将输入特征向量映射到标量能量输出。\n\n**2. 数值梯度计算**\n\n每个特征 $x_i$ 的归因是其对能量输出的影响，通过偏导数的绝对值 $\\left|\\dfrac{\\partial E}{\\partial x_i}\\right|$ 来量化。这些梯度使用对称有限差分公式进行数值估算：\n$$\\frac{\\partial E}{\\partial x_i}(\\mathbf{x}) \\approx \\frac{E(\\mathbf{x} + h_i \\mathbf{e}_i) - E(\\mathbf{x} - h_i \\mathbf{e}_i)}{2 h_i}$$\n其中 $\\mathbf{e}_i$ 是第 $i$ 个特征的单位向量。步长 $h_i$ 必须很小以确保准确性。一个稳健的选择，也是此处使用的选择，是特征可行范围的一小部分：$h_i = \\delta_{\\text{rel}} (x_{i, \\text{max}} - x_{i, \\text{min}})$，其中 $\\delta_{\\text{rel}}$ 是一个很小的常数（例如 $10^{-7}$）。由于所有测试点都在有界域的内部，因此 $x_i \\pm h_i$ 将保持在特征的边界内。\n\n**3. 删除测试算法**\n\n对于每个测试用例 $(\\mathbf{x}_{\\text{base}}, k, b_{\\text{frac}})$，删除测试按以下步骤进行：\n\n1.  **计算基准能量**：计算未扰动特征向量的能量，$E_{\\text{base}} = E(\\mathbf{x}_{\\text{base}})$。如果 $E_{\\text{base}} = 0$，则指标 $M$ 定义为 $0$，并终止对此用例的处理。如果 $k=0$，则不发生扰动，因此 $E_{\\text{pert}} = E_{\\text{base}}$ 且 $M=0$。\n\n2.  **计算并排序归因**：如果 $k0$ 且 $E_{\\text{base}}0$，则计算在 $\\mathbf{x}_{\\text{base}}$ 处每个特征 $x_i$ 的梯度 $g_i = \\dfrac{\\partial E}{\\partial x_i}$。根据其绝对梯度值 $|g_i|$ 对特征进行降序排序。\n\n3.  **扰动顶部特征**：从排序列表中选择前 $k$ 个特征。对于每个选定的特征 $x_i$，计算一个新的扰动值 $x'_i$。扰动将沿着梯度符号所指示的、预期会减小能量 $E$ 的方向施加。\n    $$ \\Delta x_i = -\\text{sign}(g_i) \\cdot b_{\\text{frac}} \\cdot (x_{i, \\text{max}} - x_{i, \\text{min}}) $$\n    新值为 $x'_i = x_i + \\Delta x_i$。然后对此值进行裁剪，以确保其保持在物理上合理的边界 $[x_{i, \\text{min}}, x_{i, \\text{max}}]$ 内。\n    $$ x'_{i, \\text{clipped}} = \\max(x_{i, \\text{min}}, \\min(x_{i, \\text{max}}, x'_i)) $$\n    此过程会创建一个新的扰动特征向量 $\\mathbf{x}_{\\text{pert}}$，它与 $\\mathbf{x}_{\\text{base}}$ 相同，只是前 $k$ 个特征被扰动了。\n\n4.  **计算性能下降**：计算扰动向量的能量 $E_{\\text{pert}} = E(\\mathbf{x}_{\\text{pert}})$。最终的性能下降指标 $M$ 则通过归一化差异计算得出：\n    $$M = \\frac{E_{\\text{base}} - E_{\\text{pert}}}{E_{\\text{base}}}$$\n此过程的实现见最终答案。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Validates a gradient-based attribution method for a Li-ion cell model using a deletion test.\n    \"\"\"\n\n    # Constants\n    R_g = 8.314  # J/(mol.K)\n    F = 96485    # C/mol\n    b_bruggeman = 1.5\n    eps_filler = 0.03\n    eps_sep = 0.4\n    E_a = 34000.0  # J/mol\n    T_ref = 298.15 # K\n    n_electrons = 1.0\n\n    # Feature names in a fixed order for vector mapping\n    feature_names = [\n        'eps_e', 'r_p', 'L_e', 'delta_s', 'T', 'kappa', \n        'kappa_sep', 'A', 'i0_ref', 'Voc', 'I', 't'\n    ]\n    feature_map = {name: i for i, name in enumerate(feature_names)}\n\n    # Physically plausible bounds for each feature\n    feature_bounds = {\n        'eps_e': (0.2, 0.6), 'r_p': (1e-6, 1.5e-5), 'L_e': (5e-5, 2e-4),\n        'delta_s': (1e-5, 3e-5), 'T': (283.15, 323.15), 'kappa': (0.5, 2.0),\n        'kappa_sep': (0.3, 1.5), 'A': (0.01, 0.05), 'i0_ref': (1e-6, 1e-3),\n        'Voc': (3.0, 4.2), 'I': (5.0, 30.0), 't': (600.0, 3600.0)\n    }\n    bounds_list = [feature_bounds[name] for name in feature_names]\n\n    def calculate_energy(x_vec):\n        \"\"\"\n        Calculates the delivered energy E from a feature vector.\n        \"\"\"\n        (eps_e, r_p, L_e, delta_s, T, kappa, \n         kappa_sep, A, i0_ref, Voc, I, t) = x_vec\n\n        # Solid volume fraction\n        eps_s = 1.0 - eps_e - eps_filler\n        eps_s = max(0.0, eps_s)\n        \n        # Specific surface area\n        if r_p == 0: return 0.0\n        a = 3.0 * eps_s / r_p\n\n        # Exchange current density\n        i0 = i0_ref * np.exp(-E_a / R_g * (1.0 / T - 1.0 / T_ref))\n\n        # Effective conductivities\n        kappa_eff = kappa * eps_e**b_bruggeman\n        kappa_sep_eff = kappa_sep * eps_sep**b_bruggeman\n\n        # Handle potential divisions by zero, though bounds prevent this\n        if kappa_eff == 0.0 or kappa_sep_eff == 0.0 or A == 0.0:\n            return 0.0\n\n        R_ohm = (L_e / kappa_eff + delta_s / kappa_sep_eff) / A\n\n        # Charge-transfer resistance\n        denominator_R_ct = n_electrons * F * a * i0 * A\n        if denominator_R_ct == 0.0:\n            return 0.0\n        R_ct = (R_g * T) / denominator_R_ct\n\n        # Total resistance and terminal voltage\n        R_total = R_ohm + R_ct\n        V_terminal = Voc - I * R_total\n        \n        # Delivered energy\n        energy = V_terminal * I * t\n        return max(0.0, energy)\n\n    # Test cases from the problem statement\n    test_cases = [\n        ({'eps_e': 0.35, 'r_p': 5e-6, 'L_e': 1e-4, 'delta_s': 2e-5, 'T': 298.15,\n          'kappa': 1.2, 'kappa_sep': 0.8, 'A': 0.02, 'i0_ref': 1e-4, 'Voc': 3.9,\n          'I': 10, 't': 1800}, 3, 0.2),\n        ({'eps_e': 0.25, 'r_p': 1.2e-5, 'L_e': 1.9e-4, 'delta_s': 2.8e-5, 'T': 283.15,\n          'kappa': 0.6, 'kappa_sep': 0.5, 'A': 0.015, 'i0_ref': 5e-5, 'Voc': 3.7,\n          'I': 25, 't': 1200}, 4, 0.3),\n        ({'eps_e': 0.4, 'r_p': 8e-6, 'L_e': 1.2e-4, 'delta_s': 2.2e-5, 'T': 305.15,\n          'kappa': 1.5, 'kappa_sep': 1.0, 'A': 0.025, 'i0_ref': 2e-4, 'Voc': 4.0,\n          'I': 12, 't': 2000}, 0, 0.25),\n        ({'eps_e': 0.5, 'r_p': 3e-6, 'L_e': 7e-5, 'delta_s': 1.5e-5, 'T': 313.15,\n          'kappa': 1.8, 'kappa_sep': 1.2, 'A': 0.03, 'i0_ref': 8e-4, 'Voc': 4.1,\n          'I': 15, 't': 2400}, 5, 0.1),\n    ]\n\n    results = []\n    grad_step_frac = 1e-7\n\n    for x_dict, k, b_frac in test_cases:\n        x_base = np.array([x_dict[name] for name in feature_names])\n        E_base = calculate_energy(x_base)\n\n        if k == 0 or E_base == 0:\n            results.append(0.0)\n            continue\n\n        grads = []\n        for i in range(len(feature_names)):\n            x_i_min, x_i_max = bounds_list[i]\n            h = grad_step_frac * (x_i_max - x_i_min)\n\n            if h == 0:\n                grads.append(0.0)\n                continue\n            \n            x_plus = x_base.copy()\n            x_plus[i] += h\n            E_plus = calculate_energy(x_plus)\n            \n            x_minus = x_base.copy()\n            x_minus[i] -= h\n            E_minus = calculate_energy(x_minus)\n            \n            gradient = (E_plus - E_minus) / (2 * h)\n            grads.append(gradient)\n        \n        abs_grads = np.abs(np.array(grads))\n        ranked_indices = np.argsort(abs_grads)[::-1]\n        \n        x_pert = x_base.copy()\n        top_k_indices = ranked_indices[:k]\n        \n        for idx in top_k_indices:\n            grad_val = grads[idx]\n            x_min, x_max = bounds_list[idx]\n            feat_range = x_max - x_min\n            \n            perturbation = -np.sign(grad_val) * b_frac * feat_range\n            x_pert[idx] += perturbation\n            x_pert[idx] = np.clip(x_pert[idx], x_min, x_max)\n            \n        E_pert = calculate_energy(x_pert)\n        \n        M = (E_base - E_pert) / E_base\n        results.append(round(M, 6))\n\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "可解释人工智能的最终目标通常是指导决策。本实践将从被动的解释转向主动的优化，通过生成“反事实”（counterfactuals）来实现这一目标——即对输入进行最小的改动以达到期望的输出。你将通过求解一个约束优化问题，设计一种新的充电策略，以降低析锂风险同时满足各项运行约束，从而展示XAI如何为更安全、高效的电池管理提供可行的见解。",
            "id": "3913447",
            "problem": "给定一个在有限时间范围内的基准恒流充电协议，您需要构建一个反事实协议，该协议能够降低析锂风险的替代指标，同时保持充电通量并遵守电流密度和热约束。此问题背景源于电池设计中的可解释人工智能：一个从黑盒析锂风险预测器中派生的局部可解释替代模型，提供了关于电流密度的一阶和二阶灵敏度。您的任务是为每个测试案例求解一个约束二次规划问题，该问题代表了局部有效的反事实调整。\n\n推导中使用的基本和核心定义：(i) Butler–Volmer 关系意味着界面过电位随电流密度单调增加，从而增加了析锂倾向；(ii) 一个集总单电阻单电容热模型，其热输入来自焦耳热，用于捕捉电芯温度演化；(iii) 来自可解释预测器的局部替代近似，产生一个关于电流密度调整量的二次增量风险函数。具体步骤如下所述。\n\n设有 $N$ 个时间间隔，每个间隔的持续时间为 $\\Delta t$（单位：秒），基准电流密度曲线为 $\\mathbf{J}_0 \\in \\mathbb{R}^N$，其中每个分量 $J_{0,i}$ 的单位为 $\\mathrm{A}/\\mathrm{m}^2$。设决策变量为反事实电流密度曲线 $\\mathbf{J} \\in \\mathbb{R}^N$，单位相同。设电芯几何面积为 $A_{\\mathrm{cell}}$（单位：$\\mathrm{m}^2$），内阻为 $R_{\\mathrm{int}}$（单位：$\\Omega$），热阻为 $R_{\\mathrm{th}}$（单位：$\\mathrm{K}/\\mathrm{W}$），热容为 $C_{\\mathrm{th}}$（单位：$\\mathrm{J}/\\mathrm{K}$），环境温度为 $T_{\\mathrm{env}}$（单位：$\\mathrm{K}$），初始温度为 $T_{\\mathrm{init}}$（单位：$\\mathrm{K}$）。集总热动力学通过能量平衡方程的前向欧拉法进行离散化：\n$$\nC_{\\mathrm{th}} \\frac{dT}{dt} = I^2 R_{\\mathrm{int}} - \\frac{T - T_{\\mathrm{env}}}{R_{\\mathrm{th}}},\n$$\n其中 $I = A_{\\mathrm{cell}} J$，得到：\n$$\nT_{i+1} = T_i + \\frac{\\Delta t}{C_{\\mathrm{th}}} \\left( A_{\\mathrm{cell}}^2 J_i^2 R_{\\mathrm{int}} - \\frac{T_i - T_{\\mathrm{env}}}{R_{\\mathrm{th}}} \\right),\n$$\n对于 $i \\in \\{0,\\dots,N-1\\}$，$T_0 = T_{\\mathrm{init}}$。热约束为在每个时间间隔结束时，所有索引的温度 $T_i \\le T_{\\max}$（单位：$\\mathrm{K}$）。电流密度界限为 $0 \\le J_i \\le J_{\\max}$（单位：$\\mathrm{A}/\\mathrm{m}^2$）。充电通量相等性约束为：\n$$\n\\sum_{i=0}^{N-1} J_i \\, \\Delta t = \\sum_{i=0}^{N-1} J_{0,i} \\, \\Delta t,\n$$\n这强制要求基准协议和反事实协议之间总输送电荷量（单位：$\\mathrm{A}\\cdot\\mathrm{s}/\\mathrm{m}^2$）相等。\n\n从析锂风险黑盒的局部可解释替代模型（例如，局部模型无关解释或基于 Shapley 的二次拟合）中，您被给予每个间隔的一阶灵敏度 $g_i$ 和正曲率 $h_i  0$，使得总风险相对于基准的增量变化近似为：\n$$\n\\Delta \\mathcal{R}(\\mathbf{J}) \\approx \\sum_{i=0}^{N-1} \\left[ g_i \\, (J_i - J_{0,i}) + \\tfrac{1}{2} h_i \\, (J_i - J_{0,i})^2 \\right].\n$$\n提供基准的绝对风险 $\\mathcal{R}_0$（任意非负单位）。反事实风险近似为 $\\mathcal{R}_{\\star} \\approx \\mathcal{R}_0 + \\Delta \\mathcal{R}(\\mathbf{J}_{\\star})$。您的目标是在满足约束条件的前提下最小化 $\\Delta \\mathcal{R}$。\n\n为了使热约束保持易于处理的形式，使用关于基准轨迹的一阶灵敏度线性化。定义 $\\phi = 1 - \\frac{\\Delta t}{C_{\\mathrm{th}} R_{\\mathrm{th}}}$。基准温度轨迹 $(T_i^0)_{i=0}^N$ 是通过上述热递归与 $\\mathbf{J}_0$ 得到的。线性灵敏度矩阵 $\\mathbf{B} \\in \\mathbb{R}^{N \\times N}$，其元素为 $B_{i,k} = \\frac{\\partial T_{i+1}}{\\partial J_k} \\big|_{\\mathbf{J}_0}$，满足：\n$$\nB_{k,k} = \\frac{\\Delta t}{C_{\\mathrm{th}}} \\, 2 A_{\\mathrm{cell}}^2 R_{\\mathrm{int}} \\, J_{0,k}, \\quad\nB_{i,k} = \\phi \\, B_{i-1,k} \\text{ for } i  k, \\quad\nB_{i,k} = 0 \\text{ for } i  k.\n$$\n因此，在每个时间间隔结束时的线性化热约束变为：\n$$\nT_{i+1}^0 + \\sum_{k=0}^{N-1} B_{i,k} \\, (J_k - J_{0,k}) \\le T_{\\max}, \\quad i = 0,\\dots,N-1.\n$$\n您必须求解以下约束二次规划问题：\n$$\n\\min_{\\mathbf{J} \\in \\mathbb{R}^N} \\sum_{i=0}^{N-1} \\left[ g_i \\, (J_i - J_{0,i}) + \\tfrac{1}{2} h_i \\, (J_i - J_{0,i})^2 \\right]\n$$\n约束条件为：\n$$\n\\sum_{i=0}^{N-1} J_i \\, \\Delta t = \\sum_{i=0}^{N-1} J_{0,i} \\, \\Delta t, \\quad\n0 \\le J_i \\le J_{\\max} \\text{ for all } i, \\quad\nT_{i+1}^0 + \\sum_{k=0}^{N-1} B_{i,k} \\, (J_k - J_{0,k}) \\le T_{\\max} \\text{ for } i=0,\\dots,N-1.\n$$\n对于每个测试案例，计算优化后的 $\\mathbf{J}_{\\star}$，然后计算估计的反事实绝对风险 $\\mathcal{R}_{\\star} \\approx \\mathcal{R}_0 + \\Delta \\mathcal{R}(\\mathbf{J}_{\\star})$，最后报告风险降低分数，形式为小数：\n$$\n\\rho = \\frac{\\mathcal{R}_0 - \\mathcal{R}_{\\star}}{\\mathcal{R}_0},\n$$\n四舍五入到六位小数。不允许使用百分号；报告一个无单位的小数。\n\n物理单位和角度单位：电流密度必须以 $\\mathrm{A}/\\mathrm{m}^2$ 为单位，时间以 $\\mathrm{s}$ 为单位，面积以 $\\mathrm{m}^2$ 为单位，电阻以 $\\Omega$ 为单位，热阻以 $\\mathrm{K}/\\mathrm{W}$ 为单位，热容以 $\\mathrm{J}/\\mathrm{K}$ 为单位，温度以 $\\mathrm{K}$ 为单位。没有出现角度量。\n\n测试套件和参数：\n\n测试案例 1（理想情况，约束适中）：\n- $N = 4$, $\\Delta t = 60.0$, $A_{\\mathrm{cell}} = 0.01$, $R_{\\mathrm{int}} = 0.05$, $R_{\\mathrm{th}} = 5.0$, $C_{\\mathrm{th}} = 400.0$, $T_{\\mathrm{env}} = 298.15$, $T_{\\mathrm{init}} = 298.15$, $J_{\\max} = 150.0$, $T_{\\max} = 313.15$。\n- 基准 $\\mathbf{J}_0 = [120.0, 120.0, 80.0, 80.0]$。\n- 替代模型参数 $\\mathbf{g} = [0.8, 0.6, 0.2, 0.1]$, $\\mathbf{h} = [0.02, 0.02, 0.01, 0.01]$, 以及 $\\mathcal{R}_0 = 10.0$。\n\n测试案例 2（热约束更有效）：\n- $N = 4$, $\\Delta t = 60.0$, $A_{\\mathrm{cell}} = 0.01$, $R_{\\mathrm{int}} = 0.05$, $R_{\\mathrm{th}} = 5.0$, $C_{\\mathrm{th}} = 400.0$, $T_{\\mathrm{env}} = 298.15$, $T_{\\mathrm{init}} = 298.15$, $J_{\\max} = 150.0$, $T_{\\max} = 303.15$。\n- 基准 $\\mathbf{J}_0 = [100.0, 100.0, 100.0, 100.0]$。\n- 替代模型参数 $\\mathbf{g} = [1.0, 0.7, 0.2, 0.1]$, $\\mathbf{h} = [0.02, 0.02, 0.01, 0.01]$, 以及 $\\mathcal{R}_0 = 8.0$。\n\n测试案例 3（电流密度上限限制了重新分配）：\n- $N = 4$, $\\Delta t = 30.0$, $A_{\\mathrm{cell}} = 0.01$, $R_{\\mathrm{int}} = 0.05$, $R_{\\mathrm{th}} = 5.0$, $C_{\\mathrm{th}} = 400.0$, $T_{\\mathrm{env}} = 298.15$, $T_{\\mathrm{init}} = 298.15$, $J_{\\max} = 110.0$, $T_{\\max} = 330.0$。\n- 基准 $\\mathbf{J}_0 = [110.0, 110.0, 110.0, 110.0]$。\n- 替代模型参数 $\\mathbf{g} = [0.1, 0.1, 0.1, 0.1]$, $\\mathbf{h} = [0.005, 0.005, 0.005, 0.005]$, 以及 $\\mathcal{R}_0 = 12.0$。\n\n最终输出格式：您的程序应生成单行输出，包含三个风险降低分数，按测试案例 1、2、3 的顺序排列，形式为逗号分隔的列表并用方括号括起，例如 $[x_1,x_2,x_3]$，其中每个 $x_i$ 是一个四舍五入到六位小数的十进制数。不应打印任何其他文本。",
            "solution": "该问题要求解决一个约束二次优化问题，以找到一个反事实的电池充电协议，该协议在遵守总电荷量、电流密度和电芯温度约束的同时，最小化一个析锂风险的替代指标。解决过程包括将问题表述为标准的二次规划（QP），根据给定的物理参数构建必要的矩阵和向量，对 QP 进行数值求解，并计算最终的性能指标。\n\n设时间间隔数为 $N$，决策变量为对基准电流密度曲线 $\\mathbf{J}_0 \\in \\mathbb{R}^N$ 的调整量向量 $\\boldsymbol{\\delta} \\in \\mathbb{R}^N$，其中 $\\boldsymbol{\\delta} = \\mathbf{J} - \\mathbf{J}_0$。所有向量和时间相关量的索引都将是基于 0 的，即 $i \\in \\{0, 1, \\dots, N-1\\}$。\n\n优化问题是最小化增量风险，它是 $\\boldsymbol{\\delta}$ 的一个二次函数：\n$$\n\\min_{\\boldsymbol{\\delta} \\in \\mathbb{R}^N} \\quad f(\\boldsymbol{\\delta}) = \\sum_{i=0}^{N-1} \\left[ g_i \\delta_i + \\tfrac{1}{2} h_i \\delta_i^2 \\right]\n$$\n该目标函数可以写成矩阵形式：\n$$\n\\min_{\\boldsymbol{\\delta}} \\quad \\frac{1}{2} \\boldsymbol{\\delta}^T \\mathbf{H} \\boldsymbol{\\delta} + \\mathbf{g}^T \\boldsymbol{\\delta}\n$$\n其中 $\\mathbf{g} = [g_0, g_1, \\dots, g_{N-1}]^T$ 是一阶灵敏度向量，$\\mathbf{H} = \\mathrm{diag}(h_0, h_1, \\dots, h_{N-1})$ 是正曲率的对角矩阵。由于所有 $h_i  0$，Hessian 矩阵 $\\mathbf{H}$ 是正定的，这使得目标函数是严格凸的。\n\n优化受以下线性约束的限制：\n\n1.  **电荷通量守恒**：总输送电荷量必须与基准相同。\n    $$\n    \\sum_{i=0}^{N-1} J_i \\Delta t = \\sum_{i=0}^{N-1} J_{0,i} \\Delta t \\implies \\sum_{i=0}^{N-1} (J_{0,i} + \\delta_i) = \\sum_{i=0}^{N-1} J_{0,i} \\implies \\sum_{i=0}^{N-1} \\delta_i = 0\n    $$\n    用向量形式表示，即 $\\mathbf{1}^T \\boldsymbol{\\delta} = 0$，其中 $\\mathbf{1}$ 是一个全为 1 的向量。\n\n2.  **电流密度界限**：每一步的电流密度必须在指定范围内。\n    $$\n    0 \\le J_i \\le J_{\\max} \\implies 0 \\le J_{0,i} + \\delta_i \\le J_{\\max} \\implies -J_{0,i} \\le \\delta_i \\le J_{\\max} - J_{0,i}\n    $$\n    这些是对决策变量 $\\delta_i$ 的箱式约束。\n\n3.  **线性化热约束**：每个时间间隔结束时的电芯温度不得超过最大值 $T_{\\max}$。温度演化在基准轨迹 $\\mathbf{T}^0 = (T_1^0, \\dots, T_N^0)$ 周围进行线性化。\n    $$\n    T_{i+1}^0 + \\sum_{k=0}^{N-1} B_{i,k} \\delta_k \\le T_{\\max} \\quad \\text{for } i = 0, \\dots, N-1\n    $$\n    其中 $\\mathbf{B}$ 是 $N \\times N$ 的热灵敏度矩阵。这组 $N$ 个不等式可以写成 $\\mathbf{B} \\boldsymbol{\\delta} \\le \\mathbf{d}$，其中向量 $\\mathbf{d}$ 的分量为 $d_i = T_{\\max} - T_{i+1}^0$。\n\n该问题是一个凸二次规划问题，因为它涉及在一个凸可行集（由线性等式和不等式定义）上最小化一个严格凸的二次函数。这样的问题有一个唯一的全局最小值。我们可以使用数值优化求解器来解决它，例如 `scipy.optimize.minimize` 中提供的序列最小二乘规划（SLSQP）算法。\n\n对每个测试案例，求解过程按以下步骤进行：\n\n**步骤 1：计算基准温度轨迹**\n通过使用基准电流曲线 $\\mathbf{J}_0$ 迭代离散化的热模型，计算每个时间间隔结束时的基准温度 $T_{i+1}^0$。递推关系为：\n$$\nT_{i+1}^0 = T_i^0 + \\frac{\\Delta t}{C_{\\mathrm{th}}} \\left( A_{\\mathrm{cell}}^2 J_{0,i}^2 R_{\\mathrm{int}} - \\frac{T_i^0 - T_{\\mathrm{env}}}{R_{\\mathrm{th}}} \\right), \\quad T_0^0 = T_{\\mathrm{init}}\n$$\n这可以重写为 $T_{i+1}^0 = \\phi T_i^0 + \\alpha J_{0,i}^2 + \\beta T_{\\mathrm{env}}$，其中 $\\phi = 1 - \\frac{\\Delta t}{C_{\\mathrm{th}}R_{\\mathrm{th}}}$，$\\alpha = \\frac{\\Delta t A_{\\mathrm{cell}}^2 R_{\\mathrm{int}}}{C_{\\mathrm{th}}}$，以及 $\\beta = \\frac{\\Delta t}{C_{\\mathrm{th}}R_{\\mathrm{th}}}$。得到的温度 $T_1^0, \\dots, T_N^0$ 用于定义热约束的界限。\n\n**步骤 2：构建热灵敏度矩阵 B**\n矩阵 $\\mathbf{B}$ 包含在 $\\mathbf{J} = \\mathbf{J}_0$ 处计算的偏导数 $B_{i,k} = \\frac{\\partial T_{i+1}}{\\partial J_k}$。它具有下三角结构，因为时间步 $i+1$ 的温度不受未来电流（$k  i$ 时的 $J_k$）的影响。矩阵元素计算如下：\n$$\nB_{i,k} =\n\\begin{cases}\n0  \\text{if } k  i \\\\\n\\frac{2 \\Delta t A_{\\mathrm{cell}}^2 R_{\\mathrm{int}}}{C_{\\mathrm{th}}} J_{0,k}  \\text{if } k = i \\\\\n\\phi B_{i-1,k}  \\text{if } k  i\n\\end{cases}\n$$\n\n**步骤 3：求解二次规划问题**\n对 QP 问题进行公式化并进行数值求解。求解器所需的组件包括：\n- 目标函数 $f(\\boldsymbol{\\delta}) = \\frac{1}{2}\\boldsymbol{\\delta}^T \\mathbf{H} \\boldsymbol{\\delta} + \\mathbf{g}^T \\boldsymbol{\\delta}$。\n- 目标函数的梯度（雅可比矩阵）：$\\nabla f(\\boldsymbol{\\delta}) = \\mathbf{H}\\boldsymbol{\\delta} + \\mathbf{g}$。\n- 等式约束：$\\sum_{i=0}^{N-1} \\delta_i = 0$。\n- 不等式约束：$T_{\\max} - T_{i+1}^0 - (\\mathbf{B}\\boldsymbol{\\delta})_i \\ge 0$ 对于 $i=0, \\dots, N-1$。（注意 SciPy 要求的 $\\ge 0$ 形式）。\n- 变量的界限：$-J_{0,i} \\le \\delta_i \\le J_{\\max} - J_{0,i}$。\n\n向求解器提供一个初始猜测 $\\boldsymbol{\\delta} = \\mathbf{0}$。输出为最优调整向量 $\\boldsymbol{\\delta}_{\\star}$。\n\n**步骤 4：计算风险降低分数**\n最优增量风险 $\\Delta \\mathcal{R}(\\mathbf{J}_{\\star})$ 是目标函数在解 $\\boldsymbol{\\delta}_{\\star}$ 处的值。反事实绝对风险为 $\\mathcal{R}_{\\star} = \\mathcal{R}_0 + \\Delta \\mathcal{R}(\\mathbf{J}_{\\star})$。风险降低分数 $\\rho$ 则计算如下：\n$$\n\\rho = \\frac{\\mathcal{R}_0 - \\mathcal{R}_{\\star}}{\\mathcal{R}_0} = \\frac{\\mathcal{R}_0 - (\\mathcal{R}_0 + \\Delta \\mathcal{R}(\\mathbf{J}_{\\star}))}{\\mathcal{R}_0} = - \\frac{\\Delta \\mathcal{R}(\\mathbf{J}_{\\star})}{\\mathcal{R}_0}\n$$\n最终值按要求四舍五入到六位小数。对所有测试案例重复此过程。",
            "answer": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef solve():\n    \"\"\"\n    Solves the constrained quadratic program for each test case to find the\n    optimal counterfactual charging protocol and reports the fractional risk reduction.\n    \"\"\"\n\n    test_cases = [\n        # Test case 1\n        {\n            'N': 4, 'dt': 60.0, 'A_cell': 0.01, 'R_int': 0.05, 'R_th': 5.0, \n            'C_th': 400.0, 'T_env': 298.15, 'T_init': 298.15, 'J_max': 150.0, \n            'T_max': 313.15, 'J0': [120.0, 120.0, 80.0, 80.0],\n            'g': [0.8, 0.6, 0.2, 0.1], 'h': [0.02, 0.02, 0.01, 0.01], 'R0': 10.0\n        },\n        # Test case 2\n        {\n            'N': 4, 'dt': 60.0, 'A_cell': 0.01, 'R_int': 0.05, 'R_th': 5.0,\n            'C_th': 400.0, 'T_env': 298.15, 'T_init': 298.15, 'J_max': 150.0,\n            'T_max': 303.15, 'J0': [100.0, 100.0, 100.0, 100.0],\n            'g': [1.0, 0.7, 0.2, 0.1], 'h': [0.02, 0.02, 0.01, 0.01], 'R0': 8.0\n        },\n        # Test case 3\n        {\n            'N': 4, 'dt': 30.0, 'A_cell': 0.01, 'R_int': 0.05, 'R_th': 5.0, \n            'C_th': 400.0, 'T_env': 298.15, 'T_init': 298.15, 'J_max': 110.0, \n            'T_max': 330.0, 'J0': [110.0, 110.0, 110.0, 110.0],\n            'g': [0.1, 0.1, 0.1, 0.1], 'h': [0.005, 0.005, 0.005, 0.005], 'R0': 12.0\n        }\n    ]\n\n    results = []\n    for params in test_cases:\n        result = _solve_case(params)\n        results.append(f\"{result:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\n\ndef _solve_case(params):\n    \"\"\"\n    Helper function to set up and solve the QP for a single test case.\n    \"\"\"\n    # 1. Unpack parameters and convert to numpy arrays\n    N = params['N']\n    dt = params['dt']\n    A_cell = params['A_cell']\n    R_int = params['R_int']\n    R_th = params['R_th']\n    C_th = params['C_th']\n    T_env = params['T_env']\n    T_init = params['T_init']\n    J_max = params['J_max']\n    T_max = params['T_max']\n    J0 = np.array(params['J0'])\n    g = np.array(params['g'])\n    h = np.array(params['h'])\n    R0 = params['R0']\n\n    # 2. Calculate baseline temperature trajectory\n    T0_traj = np.zeros(N + 1)\n    T0_traj[0] = T_init\n    \n    phi = 1.0 - dt / (C_th * R_th)\n    alpha = dt * A_cell**2 * R_int / C_th\n    beta_T_env = (dt / (C_th * R_th)) * T_env\n\n    for i in range(N):\n        T0_traj[i+1] = phi * T0_traj[i] + alpha * J0[i]**2 + beta_T_env\n\n    # 3. Construct the thermal sensitivity matrix B\n    B = np.zeros((N, N))\n    b_diag_factor = 2.0 * dt * A_cell**2 * R_int / C_th\n    for k in range(N):\n        B[k, k] = b_diag_factor * J0[k]\n        for i in range(k + 1, N):\n            B[i, k] = phi * B[i - 1, k]\n\n    # 4. Define the QP problem for the solver\n    # Decision variable is delta, the adjustment to J0\n    def objective(delta):\n        return 0.5 * np.sum(h * delta**2) + np.sum(g * delta)\n\n    def jacobian(delta):\n        return h * delta + g\n\n    # Equality constraint: sum of adjustments is zero (charge conservation)\n    eq_constraint = {'type': 'eq', 'fun': lambda delta: np.sum(delta)}\n\n    # Inequality constraints: thermal limits\n    # SLSQP expects constraints in the form C(x) >= 0.\n    # B @ delta = T_max - T0_traj[1:] -> (T_max - T0_traj[1:]) - (B @ delta) >= 0\n    ineq_constraints = []\n    for i in range(N):\n        constraint_fun = lambda delta, i=i: (T_max - T0_traj[i + 1]) - np.dot(B[i, :], delta)\n        ineq_constraints.append({'type': 'ineq', 'fun': constraint_fun})\n\n    constraints = [eq_constraint] + ineq_constraints\n\n    # Bounds for each delta_i: -J0[i] = delta_i = J_max - J0[i]\n    bounds = [(-J0[i], J_max - J0[i]) for i in range(N)]\n    \n    # 5. Solve the QP\n    delta0 = np.zeros(N)\n    res = minimize(objective, delta0, method='SLSQP', jac=jacobian, \n                   bounds=bounds, constraints=constraints)\n\n    # 6. Calculate the final result (fractional risk reduction)\n    delta_R_star = res.fun\n    rho = -delta_R_star / R0\n    \n    return rho\n\nsolve()\n```"
        }
    ]
}