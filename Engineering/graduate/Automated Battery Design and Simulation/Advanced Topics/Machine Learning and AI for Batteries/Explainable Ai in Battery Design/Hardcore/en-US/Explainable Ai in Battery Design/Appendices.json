{
    "hands_on_practices": [
        {
            "introduction": "The foundation of many explainable AI techniques is the ability to attribute a model's prediction to its input features. This exercise provides a concrete, hands-on introduction to one of the most rigorous attribution methods, Shapley Additive Explanations (SHAP). By working with a simplified, analytically solvable model of cathode co-doping, you will directly compute Shapley values and interaction indices, building a fundamental intuition for how XAI quantifies individual and synergistic feature effects ().",
            "id": "3913432",
            "problem": "Consider a simplified, scientifically plausible predictive model used in automated battery design and simulation to estimate the change in specific capacity of a layered oxide cathode (in milliampere-hours per gram) due to co-doping with two cation species. Let the dopant mole fractions be $x_1$ and $x_2$ (dimensionless decimal fractions), and let the model prediction be\n$$\nf(x_1,x_2) = w_1 x_1 + w_2 x_2 + w_{12} x_1 x_2,\n$$\nwhere $w_1$ and $w_2$ have units of $\\mathrm{mAh/g}$ per unit dopant fraction, and $w_{12}$ has units of $\\mathrm{mAh/g}$ per square of dopant fraction. This captures both individual dopant effects and a binary interaction term that models co-doping synergy or antagonism in cathode chemistry.\n\nIn Explainable Artificial Intelligence (XAI), Shapley Additive explanation (SHAP) attributes the prediction to input features using cooperative game theory. For an instance $x=(x_1,x_2)$, define the interventional value function\n$$\nv(S) = f(x_S, b_{-S}),\n$$\nwhere the baseline vector $b=(b_1,b_2)$ represents the undoped reference, with $b_1=0$ and $b_2=0$. The Shapley value for feature $i$ is given by the cooperative game theory definition\n$$\n\\phi_i = \\sum_{S \\subseteq N \\setminus \\{i\\}} \\frac{|S|!(M-|S|-1)!}{M!}\\left[v(S \\cup \\{i\\}) - v(S)\\right],\n$$\nwhere $N=\\{1,2\\}$ and $M=|N|=2$. The Shapley interaction index for the pair $(i,j)$ is defined (interventional form) by\n$$\n\\phi_{ij} = \\sum_{S \\subseteq N \\setminus \\{i,j\\}} \\frac{|S|!(M-|S|-2)!}{(M-1)!}\\left[v(S \\cup \\{i,j\\}) - v(S \\cup \\{i\\}) - v(S \\cup \\{j\\}) + v(S)\\right].\n$$\nFor $M=2$, this reduces to\n$$\n\\phi_{12} = v(\\{1,2\\}) - v(\\{1\\}) - v(\\{2\\}) + v(\\emptyset).\n$$\n\nYour task is to implement a program that, for each provided test case, computes:\n1. The Shapley values $\\phi_1$ and $\\phi_2$ in $\\mathrm{mAh/g}$.\n2. The Shapley interaction index $\\phi_{12}$ in $\\mathrm{mAh/g}$.\n3. A boolean synergy flag that is $\\mathrm{True}$ if $\\phi_{12} > 0$ and $\\mathrm{False}$ otherwise, interpreting positive interaction as synergistic co-doping and non-positive interaction as antagonistic or neutral.\n4. A boolean conservation check that is $\\mathrm{True}$ if $\\phi_1 + \\phi_2$ equals $f(x_1,x_2) - f(b_1,b_2)$ within an absolute tolerance of $10^{-12}$, and $\\mathrm{False}$ otherwise.\n\nAll floating-point outputs must be rounded to $6$ decimal places and expressed in $\\mathrm{mAh/g}$. Dopant fractions $x_1$ and $x_2$ must be treated as decimal fractions (not percentages).\n\nUse the following test suite (each tuple is $(w_1,w_2,w_{12},x_1,x_2,b_1,b_2)$):\n- Case A (typical synergistic co-doping): $(50.0, 30.0, 40.0, 0.02, 0.03, 0.0, 0.0)$.\n- Case B (antagonistic co-doping): $(50.0, 60.0, -80.0, 0.01, 0.02, 0.0, 0.0)$.\n- Case C (no interaction, single-dopant present): $(45.0, 20.0, 0.0, 0.05, 0.0, 0.0, 0.0)$.\n- Case D (boundary with one dopant absent, positive interaction coefficient): $(35.0, 25.0, 100.0, 0.0, 0.04, 0.0, 0.0)$.\n- Case E (harmful single dopant with weak synergy): $( -10.0, 40.0, 10.0, 0.03, 0.03, 0.0, 0.0)$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each element of this list corresponds to a test case and must itself be a list in the form $[\\phi_1,\\phi_2,\\phi_{12},\\mathrm{synergy},\\mathrm{conservation}]$, where $\\phi_1$, $\\phi_2$, and $\\phi_{12}$ are floats in $\\mathrm{mAh/g}$ rounded to $6$ decimal places, and $\\mathrm{synergy}$ and $\\mathrm{conservation}$ are booleans. For example, the output should look like $[[\\dots],[\\dots],[\\dots],[\\dots],[\\dots]]$ with no additional text.",
            "solution": "The problem is first validated to ensure it is scientifically grounded, well-posed, and objective.\n\n### Step 1: Extract Givens\n- **Predictive Model**: The change in specific capacity is given by the function $f(x_1, x_2) = w_1 x_1 + w_2 x_2 + w_{12} x_1 x_2$, where $x_1$ and $x_2$ are dopant mole fractions.\n- **Interventional Value Function**: $v(S) = f(x_S, b_{-S})$.\n- **Baseline Vector**: The undoped reference state is $b = (b_1, b_2) = (0, 0)$.\n- **Number of Features**: $M = |N| = 2$, with $N = \\{1, 2\\}$.\n- **Shapley Value Formula**: $\\phi_i = \\sum_{S \\subseteq N \\setminus \\{i\\}} \\frac{|S|!(M-|S|-1)!}{M!}\\left[v(S \\cup \\{i\\}) - v(S)\\right]$.\n- **Shapley Interaction Index Formula (for $M=2$)**: $\\phi_{12} = v(\\{1,2\\}) - v(\\{1\\}) - v(\\{2\\}) + v(\\emptyset)$.\n- **Tasks**:\n  1. Compute Shapley values $\\phi_1$ and $\\phi_2$.\n  2. Compute Shapley interaction index $\\phi_{12}$.\n  3. Determine a synergy flag: $\\mathrm{True}$ if $\\phi_{12} > 0$.\n  4. Perform a conservation check: $\\mathrm{True}$ if $|\\phi_1 + \\phi_2 - (f(x_1,x_2) - f(b_1,b_2))| \\le 10^{-12}$.\n- **Output Requirements**: Floating-point values must be rounded to $6$ decimal places.\n- **Test Cases**:\n  - A: $(w_1,w_2,w_{12},x_1,x_2,b_1,b_2) = (50.0, 30.0, 40.0, 0.02, 0.03, 0.0, 0.0)$.\n  - B: $(w_1,w_2,w_{12},x_1,x_2,b_1,b_2) = (50.0, 60.0, -80.0, 0.01, 0.02, 0.0, 0.0)$.\n  - C: $(w_1,w_2,w_{12},x_1,x_2,b_1,b_2) = (45.0, 20.0, 0.0, 0.05, 0.0, 0.0, 0.0)$.\n  - D: $(w_1,w_2,w_{12},x_1,x_2,b_1,b_2) = (35.0, 25.0, 100.0, 0.0, 0.04, 0.0, 0.0)$.\n  - E: $(w_1,w_2,w_{12},x_1,x_2,b_1,b_2) = ( -10.0, 40.0, 10.0, 0.03, 0.03, 0.0, 0.0)$.\n\n### Step 2: Validate Using Extracted Givens\n- **Scientifically Grounded**: The problem is grounded in materials science and explainable AI. The predictive model is a simple polynomial, a common starting point in materials informatics. The use of Shapley values for feature attribution is a standard, mathematically rigorous method in XAI. The context of co-doping in cathodes is scientifically relevant. The problem is valid.\n- **Well-Posed**: The problem provides all necessary formulas, data, and a clear set of tasks. For each input test case, a unique set of outputs can be calculated through a direct application of the provided definitions. The problem is valid.\n- **Objective**: All terms are defined mathematically. The tasks are quantitative and based on the provided model and definitions, free of subjective interpretation. The problem is valid.\n- **Conclusion**: The problem does not violate any of the invalidity criteria. It is complete, consistent, scientifically plausible, and well-posed.\n\n### Step 3: Verdict and Action\nThe problem is valid. A solution will be developed.\n\n### Principle-Based Design and Solution\n\nThe core of the problem is to derive analytical expressions for the Shapley values and interaction index for the given predictive model $f(x_1, x_2)$. This avoids numerical approximation and provides an exact solution.\n\nFirst, we evaluate the interventional value function $v(S)$ for all possible subsets $S \\subseteq N = \\{1, 2\\}$. The instance is $x = (x_1, x_2)$ and the baseline is $b = (0, 0)$.\n\n1.  $S = \\emptyset$: The subset of features is empty. We use the baseline values for all features.\n    $v(\\emptyset) = f(b_1, b_2) = f(0, 0) = w_1(0) + w_2(0) + w_{12}(0)(0) = 0$.\n\n2.  $S = \\{1\\}$: We use the instance value for feature $1$ ($x_1$) and the baseline for feature $2$ ($b_2$).\n    $v(\\{1\\}) = f(x_1, b_2) = f(x_1, 0) = w_1 x_1 + w_2(0) + w_{12}x_1(0) = w_1 x_1$.\n\n3.  $S = \\{2\\}$: We use the baseline for feature $1$ ($b_1$) and the instance value for feature $2$ ($x_2$).\n    $v(\\{2\\}) = f(b_1, x_2) = f(0, x_2) = w_1(0) + w_2 x_2 + w_{12}(0)x_2 = w_2 x_2$.\n\n4.  $S = \\{1, 2\\}$: We use the instance values for both features.\n    $v(\\{1, 2\\}) = f(x_1, x_2) = w_1 x_1 + w_2 x_2 + w_{12} x_1 x_2$.\n\nWith these values, we can compute the Shapley values $\\phi_1$ and $\\phi_2$. For $M=2$ features, the general Shapley formula simplifies. The Shapley value for feature $i$ is the average of its marginal contributions over all possible orderings of features. For two features, the two orderings are $(1, 2)$ and $(2, 1)$.\n\nThe marginal contribution of feature $1$ when added first is $v(\\{1\\}) - v(\\emptyset)$.\nThe marginal contribution of feature $1$ when added second (after feature $2$) is $v(\\{1, 2\\}) - v(\\{2\\})$.\nThe Shapley value $\\phi_1$ is the average of these two contributions:\n$$\n\\phi_1 = \\frac{1}{2} \\left[ (v(\\{1\\}) - v(\\emptyset)) + (v(\\{1, 2\\}) - v(\\{2\\})) \\right]\n$$\nSubstituting a Priori calculated values:\n$$\n\\phi_1 = \\frac{1}{2} \\left[ (w_1 x_1 - 0) + ( (w_1 x_1 + w_2 x_2 + w_{12} x_1 x_2) - w_2 x_2 ) \\right]\n$$\n$$\n\\phi_1 = \\frac{1}{2} \\left[ w_1 x_1 + w_1 x_1 + w_{12} x_1 x_2 \\right] = \\frac{1}{2} \\left[ 2 w_1 x_1 + w_{12} x_1 x_2 \\right]\n$$\n$$\n\\phi_1 = w_1 x_1 + \\frac{1}{2} w_{12} x_1 x_2\n$$\nBy symmetry, swapping indices $1$ and $2$, we find $\\phi_2$:\n$$\n\\phi_2 = w_2 x_2 + \\frac{1}{2} w_{12} x_1 x_2\n$$\nNext, we compute the Shapley interaction index $\\phi_{12}$ using the simplified formula for $M=2$:\n$$\n\\phi_{12} = v(\\{1,2\\}) - v(\\{1\\}) - v(\\{2\\}) + v(\\emptyset)\n$$\nSubstituting our values:\n$$\n\\phi_{12} = (w_1 x_1 + w_2 x_2 + w_{12} x_1 x_2) - (w_1 x_1) - (w_2 x_2) + 0\n$$\n$$\n\\phi_{12} = w_{12} x_1 x_2\n$$\nThis result is intuitive: the interaction index isolates the contribution of the interaction term $w_{12} x_1 x_2$ in the model. The Shapley values $\\phi_1$ and $\\phi_2$ attribute the individual linear effects ($w_1 x_1$ and $w_2 x_2$) entirely to features $1$ and $2$ respectively, and distribute the interaction effect ($w_{12} x_1 x_2$) equally between them.\n\nThe synergy flag is $\\mathrm{True}$ if $\\phi_{12} > 0$, which corresponds to a positive (synergistic) interaction effect.\n\nFinally, we perform the conservation check. This is a fundamental property of Shapley values, known as efficiency. The sum of the Shapley values must equal the total change in the prediction from the baseline.\n$$\n\\phi_1 + \\phi_2 = (w_1 x_1 + \\frac{1}{2} w_{12} x_1 x_2) + (w_2 x_2 + \\frac{1}{2} w_{12} x_1 x_2) = w_1 x_1 + w_2 x_2 + w_{12} x_1 x_2\n$$\nThe change in prediction from the baseline is:\n$$\nf(x_1, x_2) - f(b_1, b_2) = f(x_1, x_2) - f(0, 0) = (w_1 x_1 + w_2 x_2 + w_{12} x_1 x_2) - 0\n$$\nThus, we find that $\\phi_1 + \\phi_2 = f(x_1, x_2) - f(b_1, b_2)$ holds exactly. The conservation check should be $\\mathrm{True}$ for all cases, and it serves as a robust verification of the implementation's correctness against floating-point arithmetic errors.\n\nThe algorithm is as follows:\n1. For each test case $(w_1, w_2, w_{12}, x_1, x_2, b_1, b_2)$:\n2. Calculate the interaction term effect: $I = w_{12} x_1 x_2$.\n3. Calculate $\\phi_{12} = I$.\n4. Calculate $\\phi_1 = w_1 x_1 + \\frac{1}{2} I$.\n5. Calculate $\\phi_2 = w_2 x_2 + \\frac{1}{2} I$.\n6. Determine synergy: $\\phi_{12} > 0$.\n7. Perform conservation check: $|\\phi_1 + \\phi_2 - (w_1 x_1 + w_2 x_2 + I)| \\le 10^{-12}$.\n8. Round $\\phi_1, \\phi_2, \\phi_{12}$ to $6$ decimal places.\n9. Collate the results into a list.\n10. Aggregate results from all test cases and format the final output.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Calculates Shapley values and interaction indices for a battery cathode model\n    and prints the results for a suite of test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each tuple is (w1, w2, w12, x1, x2, b1, b2).\n    test_cases = [\n        # Case A (typical synergistic co-doping)\n        (50.0, 30.0, 40.0, 0.02, 0.03, 0.0, 0.0),\n        # Case B (antagonistic co-doping)\n        (50.0, 60.0, -80.0, 0.01, 0.02, 0.0, 0.0),\n        # Case C (no interaction, single-dopant present)\n        (45.0, 20.0, 0.0, 0.05, 0.0, 0.0, 0.0),\n        # Case D (boundary with one dopant absent, positive interaction coefficient)\n        (35.0, 25.0, 100.0, 0.0, 0.04, 0.0, 0.0),\n        # Case E (harmful single dopant with weak synergy)\n        (-10.0, 40.0, 10.0, 0.03, 0.03, 0.0, 0.0),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        w1, w2, w12, x1, x2, b1, b2 = case\n\n        # The predictive model is f(x1, x2) = w1*x1 + w2*x2 + w12*x1*x2.\n        # The baseline is b = (0, 0), so f(b1, b2) = 0.\n        \n        # 1. Calculate Shapley interaction index phi_12\n        # phi_12 = v({1,2}) - v({1}) - v({2}) + v(0)\n        # v({1,2}) = f(x1, x2) = w1*x1 + w2*x2 + w12*x1*x2\n        # v({1}) = f(x1, 0) = w1*x1\n        # v({2}) = f(0, x2) = w2*x2\n        # v(0) = f(0, 0) = 0\n        # phi_12 = (w1*x1 + w2*x2 + w12*x1*x2) - (w1*x1) - (w2*x2) + 0\n        # phi_12 = w12 * x1 * x2\n        phi_12 = w12 * x1 * x2\n\n        # 2. Calculate Shapley values phi_1 and phi_2\n        # phi_1 = w1*x1 + 0.5 * w12*x1*x2\n        # phi_2 = w2*x2 + 0.5 * w12*x1*x2\n        phi_1 = w1 * x1 + 0.5 * phi_12\n        phi_2 = w2 * x2 + 0.5 * phi_12\n\n        # 3. Determine synergy flag\n        # True if phi_12 > 0\n        synergy = phi_12 > 0\n\n        # 4. Perform conservation check\n        # Check if phi_1 + phi_2 = f(x1, x2) - f(b1, b2)\n        f_x = w1 * x1 + w2 * x2 + w12 * x1 * x2\n        f_b = w1 * b1 + w2 * b2 + w12 * b1 * b2 # This is always 0 for the given cases.\n        total_effect = f_x - f_b\n        shapley_sum = phi_1 + phi_2\n        \n        # Use a tolerance for floating point comparison\n        conservation = abs(shapley_sum - total_effect) <= 1e-12\n        \n        # Round the float outputs to 6 decimal places.\n        phi_1_rounded = round(phi_1, 6)\n        phi_2_rounded = round(phi_2, 6)\n        phi_12_rounded = round(phi_12, 6)\n\n        results.append([\n            phi_1_rounded,\n            phi_2_rounded,\n            phi_12_rounded,\n            synergy,\n            conservation\n        ])\n\n    # Final print statement in the exact required format.\n    # The format is a list of lists, represented as a string.\n    # e.g., [[val1, val2,...], [val1, val2,...]]\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Generating an explanation is only the first step; validating its reliability is equally crucial. This practice introduces the concept of *faithfulness*, a key metric for evaluating how well an explanation reflects the true behavior of the model. You will implement a deletion test, a common method for assessing faithfulness, on a detailed physics-based model of a Li-ion cell to see if explanation-guided changes produce the predicted outcomes (). This exercise bridges the gap between theoretical attribution and practical validation.",
            "id": "3913442",
            "problem": "Given the context of automated battery design and simulation, consider an explainable artificial intelligence model for a Lithium-ion cell that uses attribution to rank input design features by their influence on a performance metric. You must evaluate the faithfulness of the attribution via a deletion test: perturb the top-attributed features within physically plausible bounds in the direction expected to reduce performance, then compute the performance drop as a quantitative metric.\n\nFundamental base and modeling assumptions:\n\n- Ohm’s law states that for a series of resistive elements, the voltage drop is $V = I R$, where $V$ is voltage in $\\mathrm{V}$, $I$ is current in $\\mathrm{A}$, and $R$ is resistance in $\\Omega$. Resistances in series add linearly.\n- The Bruggeman relation for effective electrolyte conductivity in a porous medium is $\\kappa_{\\text{eff}} = \\kappa \\varepsilon_e^b$, where $\\kappa$ is bulk electrolyte conductivity in $\\mathrm{S/m}$, $\\varepsilon_e$ is electrolyte porosity (dimensionless), and $b$ is the Bruggeman exponent (dimensionless).\n- The specific surface area of spherical active material is $a = 3 \\varepsilon_s / r_p$, where $\\varepsilon_s$ is the solid volume fraction (dimensionless) and $r_p$ is the particle radius in $\\mathrm{m}$.\n- The exchange current density follows an Arrhenius-type law $i_0 = i_{0,\\text{ref}} \\exp\\!\\left(-\\dfrac{E_a}{R_g} \\left(\\dfrac{1}{T} - \\dfrac{1}{T_{\\text{ref}}}\\right)\\right)$, where $i_{0,\\text{ref}}$ is a reference exchange current density in $\\mathrm{A/m^2}$, $E_a$ is activation energy in $\\mathrm{J/mol}$, $R_g$ is the universal gas constant in $\\mathrm{J/(mol\\cdot K)}$, $T$ is temperature in $\\mathrm{K}$, and $T_{\\text{ref}}$ is a reference temperature in $\\mathrm{K}$.\n- For small overpotentials, linearized charge-transfer resistance is $R_{\\text{ct}} = \\dfrac{R_g T}{n F a i_0 A L_e}$, where $n$ is the number of electrons (dimensionless), $F$ is Faraday’s constant in $\\mathrm{C/mol}$, $A$ is the electrode area in $\\mathrm{m^2}$, and $L_e$ is electrode thickness in $\\mathrm{m}$.\n- The ohmic resistance due to electrolyte and separator is $R_{\\text{ohm}} = \\dfrac{L_e}{\\kappa_{\\text{eff}} A} + \\dfrac{\\delta_s}{\\kappa_{\\text{sep,eff}} A}$, where $L_e$ is electrode thickness in $\\mathrm{m}$, $\\delta_s$ is separator thickness in $\\mathrm{m}$, $A$ is electrode area in $\\mathrm{m^2}$, and $\\kappa_{\\text{sep,eff}} = \\kappa_{\\text{sep}} \\varepsilon_{\\text{sep}}^b$ with separator porosity $\\varepsilon_{\\text{sep}}$ (dimensionless) and separator conductivity $\\kappa_{\\text{sep}}$ in $\\mathrm{S/m}$.\n- The total resistance is $R_{\\text{total}} = R_{\\text{ohm}} + R_{\\text{ct}}$, and the cell terminal voltage under load is $V = V_{\\text{oc}} - I R_{\\text{total}}$, where $V_{\\text{oc}}$ is open-circuit voltage in $\\mathrm{V}$ and $I$ is discharge current in $\\mathrm{A}$.\n- The delivered energy over a constant-current discharge of duration $t$ seconds is $E = \\max\\!\\left(0, V I t\\right)$, expressed in $\\mathrm{J}$.\n\nAttribution-based deletion test design:\n\n- Given a feature vector $\\mathbf{x}$, define features and their physical units as:\n  - $\\varepsilon_e$ (dimensionless), $r_p$ in $\\mathrm{m}$, $L_e$ in $\\mathrm{m}$, $\\delta_s$ in $\\mathrm{m}$, $T$ in $\\mathrm{K}$, $\\kappa$ in $\\mathrm{S/m}$, $\\kappa_{\\text{sep}}$ in $\\mathrm{S/m}$, $A$ in $\\mathrm{m^2}$, $i_{0,\\text{ref}}$ in $\\mathrm{A/m^2}$, $V_{\\text{oc}}$ in $\\mathrm{V}$, $I$ in $\\mathrm{A}$, $t$ in $\\mathrm{s}$.\n- Constants to use are: $R_g = 8.314\\ \\mathrm{J/(mol\\cdot K)}$, $F = 96485\\ \\mathrm{C/mol}$, $b = 1.5$, $\\varepsilon_{\\text{filler}} = 0.03$, $\\varepsilon_{\\text{sep}} = 0.4$, $E_a = 34000\\ \\mathrm{J/mol}$, $T_{\\text{ref}} = 298.15\\ \\mathrm{K}$, $n = 1$. The solid volume fraction is $\\varepsilon_s = 1 - \\varepsilon_e - \\varepsilon_{\\text{filler}}$ and must be nonnegative; if negative, treat it as zero.\n- Use a gradient-based attribution defined by absolute gradients $\\left|\\dfrac{\\partial E}{\\partial x_i}\\right|$ estimated numerically via symmetric finite differences within the feasible bounds of each $x_i$.\n- Let $k$ be the number of top-attributed features to perturb. Rank features by $\\left|\\dfrac{\\partial E}{\\partial x_i}\\right|$ in descending order, select the top $k$, and for each selected feature $x_i$, move it in the direction that most reduces $E$ based on the sign of $\\dfrac{\\partial E}{\\partial x_i}$, by an amount equal to a budget fraction $b_{\\text{frac}}$ times its feasible range length, clipped to the physically plausible bounds. If $k = 0$, no features are perturbed.\n- The performance drop metric is $M = \\dfrac{E_{\\text{base}} - E_{\\text{pert}}}{E_{\\text{base}}}$, expressed as a decimal (no percentage sign). If $E_{\\text{base}} = 0$, define $M = 0$.\n\nPhysically plausible bounds for each feature:\n- $\\varepsilon_e \\in [0.2, 0.6]$, $r_p \\in [1\\times 10^{-6}, 1.5\\times 10^{-5}]\\ \\mathrm{m}$, $L_e \\in [5\\times 10^{-5}, 2\\times 10^{-4}]\\ \\mathrm{m}$, $\\delta_s \\in [1\\times 10^{-5}, 3\\times 10^{-5}]\\ \\mathrm{m}$, $T \\in [283.15, 323.15]\\ \\mathrm{K}$, $\\kappa \\in [0.5, 2.0]\\ \\mathrm{S/m}$, $\\kappa_{\\text{sep}} \\in [0.3, 1.5]\\ \\mathrm{S/m}$, $A \\in [0.01, 0.05]\\ \\mathrm{m^2}$, $i_{0,\\text{ref}} \\in [1\\times 10^{-6}, 1\\times 10^{-3}]\\ \\mathrm{A/m^2}$, $V_{\\text{oc}} \\in [3.0, 4.2]\\ \\mathrm{V}$, $I \\in [5, 30]\\ \\mathrm{A}$, $t \\in [600, 3600]\\ \\mathrm{s}$.\n\nYour task:\n\n- Derive the expression for $E$ from the fundamental base above.\n- Implement a numerical gradient computation for $E$ with respect to each feature using symmetric finite differences that remain within the bounds.\n- Implement the deletion test described and compute $M$ for each specified test case.\n\nUse the following test suite of parameter values, each test case given as $(\\mathbf{x}, k, b_{\\text{frac}})$:\n\n- Test case $1$ (typical conditions):\n  - $\\varepsilon_e = 0.35$, $r_p = 5\\times 10^{-6}\\ \\mathrm{m}$, $L_e = 1\\times 10^{-4}\\ \\mathrm{m}$, $\\delta_s = 2\\times 10^{-5}\\ \\mathrm{m}$, $T = 298.15\\ \\mathrm{K}$, $\\kappa = 1.2\\ \\mathrm{S/m}$, $\\kappa_{\\text{sep}} = 0.8\\ \\mathrm{S/m}$, $A = 0.02\\ \\mathrm{m^2}$, $i_{0,\\text{ref}} = 1\\times 10^{-4}\\ \\mathrm{A/m^2}$, $V_{\\text{oc}} = 3.9\\ \\mathrm{V}$, $I = 10\\ \\mathrm{A}$, $t = 1800\\ \\mathrm{s}$, with $k = 3$, $b_{\\text{frac}} = 0.2$.\n- Test case $2$ (near boundary, heavier polarization):\n  - $\\varepsilon_e = 0.25$, $r_p = 1.2\\times 10^{-5}\\ \\mathrm{m}$, $L_e = 1.9\\times 10^{-4}\\ \\mathrm{m}$, $\\delta_s = 2.8\\times 10^{-5}\\ \\mathrm{m}$, $T = 283.15\\ \\mathrm{K}$, $\\kappa = 0.6\\ \\mathrm{S/m}$, $\\kappa_{\\text{sep}} = 0.5\\ \\mathrm{S/m}$, $A = 0.015\\ \\mathrm{m^2}$, $i_{0,\\text{ref}} = 5\\times 10^{-5}\\ \\mathrm{A/m^2}$, $V_{\\text{oc}} = 3.7\\ \\mathrm{V}$, $I = 25\\ \\mathrm{A}$, $t = 1200\\ \\mathrm{s}$, with $k = 4$, $b_{\\text{frac}} = 0.3$.\n- Test case $3$ (edge case with $k = 0$):\n  - $\\varepsilon_e = 0.4$, $r_p = 8\\times 10^{-6}\\ \\mathrm{m}$, $L_e = 1.2\\times 10^{-4}\\ \\mathrm{m}$, $\\delta_s = 2.2\\times 10^{-5}\\ \\mathrm{m}$, $T = 305.15\\ \\mathrm{K}$, $\\kappa = 1.5\\ \\mathrm{S/m}$, $\\kappa_{\\text{sep}} = 1.0\\ \\mathrm{S/m}$, $A = 0.025\\ \\mathrm{m^2}$, $i_{0,\\text{ref}} = 2\\times 10^{-4}\\ \\mathrm{A/m^2}$, $V_{\\text{oc}} = 4.0\\ \\mathrm{V}$, $I = 12\\ \\mathrm{A}$, $t = 2000\\ \\mathrm{s}$, with $k = 0$, $b_{\\text{frac}} = 0.25$.\n- Test case $4$ (high-performance design):\n  - $\\varepsilon_e = 0.5$, $r_p = 3\\times 10^{-6}\\ \\mathrm{m}$, $L_e = 7\\times 10^{-5}\\ \\mathrm{m}$, $\\delta_s = 1.5\\times 10^{-5}\\ \\mathrm{m}$, $T = 313.15\\ \\mathrm{K}$, $\\kappa = 1.8\\ \\mathrm{S/m}$, $\\kappa_{\\text{sep}} = 1.2\\ \\mathrm{S/m}$, $A = 0.03\\ \\mathrm{m^2}$, $i_{0,\\text{ref}} = 8\\times 10^{-4}\\ \\mathrm{A/m^2}$, $V_{\\text{oc}} = 4.1\\ \\mathrm{V}$, $I = 15\\ \\mathrm{A}$, $t = 2400\\ \\mathrm{s}$, with $k = 5$, $b_{\\text{frac}} = 0.1$.\n\nOutput specification:\n\n- For each test case, compute $M$ and express it as a float rounded to six decimal places.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example $[m_1,m_2,m_3,m_4]$, where each $m_i$ corresponds to test case $i$ in order.\n\nAll physical quantities must be handled in the units stated above. Angles are not used. Percentages must be expressed as decimals, not with a percentage sign.",
            "solution": "The problem is assessed to be **valid**. It is scientifically grounded in established battery modeling principles, self-contained, and algorithmically well-defined. The provided data and constants are physically plausible and internally consistent.\n\nThe task is to implement an attribution-based deletion test to evaluate the faithfulness of a gradient-based attribution method for a simplified physics-based model of a lithium-ion battery cell. The performance metric is the delivered energy, $E$. The faithfulness metric is the performance drop, $M$, after perturbing the most influential features.\n\nThe solution is developed in three stages:\n1.  Derivation of the complete expression for the energy function, $E(\\mathbf{x})$, from the provided fundamental equations.\n2.  Specification of the numerical algorithm for computing the gradient-based attributions, $\\left|\\dfrac{\\partial E}{\\partial x_i}\\right|$.\n3.  Formalization of the deletion test procedure, including feature ranking, perturbation, and calculation of the performance drop metric, $M$.\n\n**1. Expression for Delivered Energy, $E(\\mathbf{x})$**\n\nThe delivered energy, $E$, is a function of a $12$-dimensional feature vector $\\mathbf{x} = (\\varepsilon_e, r_p, L_e, \\delta_s, T, \\kappa, \\kappa_{\\text{sep}}, A, i_{0,\\text{ref}}, V_{\\text{oc}}, I, t)$. The final expression for energy is given by:\n$$E(\\mathbf{x}) = \\max\\!\\left(0, (V_{\\text{oc}} - I \\cdot R_{\\text{total}}) \\cdot I \\cdot t\\right)$$\nwhere $R_{\\text{total}}$ is the total internal resistance of the cell. This resistance is the sum of the ohmic resistance, $R_{\\text{ohm}}$, and the charge-transfer resistance, $R_{\\text{ct}}$.\n$$R_{\\text{total}} = R_{\\text{ohm}} + R_{\\text{ct}}$$\nEach component of the resistance is derived as follows:\n\n**Ohmic Resistance, $R_{\\text{ohm}}$**\nThe ohmic resistance arises from ion transport through the porous electrode and the separator. It is given by:\n$$R_{\\text{ohm}} = \\dfrac{L_e}{\\kappa_{\\text{eff}} A} + \\dfrac{\\delta_s}{\\kappa_{\\text{sep,eff}} A} = \\frac{1}{A} \\left( \\frac{L_e}{\\kappa_{\\text{eff}}} + \\frac{\\delta_s}{\\kappa_{\\text{sep,eff}}} \\right)$$\nHere, $L_e$ is the electrode thickness, $\\delta_s$ is the separator thickness, and $A$ is the electrode area. The effective conductivities, $\\kappa_{\\text{eff}}$ and $\\kappa_{\\text{sep,eff}}$, are calculated using the Bruggeman relation:\n$$ \\kappa_{\\text{eff}} = \\kappa \\varepsilon_e^b $$\n$$ \\kappa_{\\text{sep,eff}} = \\kappa_{\\text{sep}} \\varepsilon_{\\text{sep}}^b $$\nwhere $\\kappa$ and $\\kappa_{\\text{sep}}$ are the bulk conductivities of the electrolyte in the electrode and separator, respectively; $\\varepsilon_e$ and $\\varepsilon_{\\text{sep}}$ are the respective porosities; and $b$ is the Bruggeman exponent.\n\n**Charge-Transfer Resistance, $R_{\\text{ct}}$**\nThe charge-transfer resistance models the kinetic limitations of the electrochemical reaction at the surface of the active material particles. For small overpotentials, it is linearized as:\n$$R_{\\text{ct}} = \\dfrac{R_g T}{n F a i_0 A L_e}$$\nwhere $R_g$ is the universal gas constant, $T$ is the temperature, $n$ is the number of electrons transferred, and $F$ is Faraday's constant. The key dependencies on the feature vector $\\mathbf{x}$ are through the specific surface area, $a$, and the exchange current density, $i_0$.\n\nThe specific surface area, $a$, for spherical particles is:\n$$a = \\frac{3 \\varepsilon_s}{r_p}$$\nwhere $r_p$ is the particle radius and $\\varepsilon_s$ is the solid volume fraction. $\\varepsilon_s$ is defined as $\\varepsilon_s = 1 - \\varepsilon_e - \\varepsilon_{\\text{filler}}$. Since the provided bounds on $\\varepsilon_e$ ($[0.2, 0.6]$) and the constant $\\varepsilon_{\\text{filler}}\n= 0.03$ ensure $1 - \\varepsilon_e - \\varepsilon_{\\text{filler}} > 0$, the condition to treat negative $\\varepsilon_s$ as zero is not triggered.\n\nThe exchange current density, $i_0$, follows an Arrhenius-type temperature dependence:\n$$i_0 = i_{0,\\text{ref}} \\exp\\!\\left(-\\dfrac{E_a}{R_g} \\left(\\dfrac{1}{T} - \\dfrac{1}{T_{\\text{ref}}}\\right)\\right)$$\nwhere $i_{0,\\text{ref}}$ is a reference exchange current density, $E_a$ is the activation energy, and $T_{\\text{ref}}$ is the reference temperature.\n\nSubstituting all intermediate expressions yields a single, complex, non-linear function $E(\\mathbf{x})$ that maps the input feature vector to the scalar energy output.\n\n**2. Numerical Gradient Calculation**\n\nThe attribution for each feature $x_i$ is its influence on the energy output, quantified by the absolute value of the partial derivative, $\\left|\\dfrac{\\partial E}{\\partial x_i}\\right|$. These gradients are estimated numerically using the symmetric finite difference formula:\n$$\\frac{\\partial E}{\\partial x_i}(\\mathbf{x}) \\approx \\frac{E(\\mathbf{x} + h_i \\mathbf{e}_i) - E(\\mathbf{x} - h_i \\mathbf{e}_i)}{2 h_i}$$\nwhere $\\mathbf{e}_i$ is the unit vector for the $i$-th feature. The step size, $h_i$, must be small to ensure accuracy. A robust choice, and the one used here, is a small fraction of the feature's feasible range: $h_i = \\delta_{\\text{rel}} (x_{i, \\text{max}} - x_{i, \\text{min}})$, where $\\delta_{\\text{rel}}$ is a small constant (e.g., $10^{-7}$). Since all test points are in the interior of the bounded domain, $x_i \\pm h_i$ will remain within the feature's bounds.\n\n**3. Deletion Test Algorithm**\n\nThe deletion test proceeds as follows for each test case $(\\mathbf{x}_{\\text{base}}, k, b_{\\text{frac}})$:\n\n1.  **Calculate Base Energy**: Compute the energy for the unperturbed feature vector, $E_{\\text{base}} = E(\\mathbf{x}_{\\text{base}})$. If $E_{\\text{base}} = 0$, the metric $M$ is defined as $0$, and the process terminates for this case. If $k=0$, no perturbations occur, so $E_{\\text{pert}} = E_{\\text{base}}$ and $M=0$.\n\n2.  **Compute and Rank Attributions**: If $k>0$ and $E_{\\text{base}}>0$, compute the gradient $g_i = \\dfrac{\\partial E}{\\partial x_i}$ for each feature $x_i$ at $\\mathbf{x}_{\\text{base}}$. Rank the features in descending order based on their absolute gradient values, $|g_i|$.\n\n3.  **Perturb Top Features**: Select the top $k$ features from the ranked list. For each selected feature $x_i$, a new perturbed value $x'_i$ is calculated. The perturbation is applied in the direction that is expected to decrease the energy $E$, as indicated by the sign of the gradient.\n    $$ \\Delta x_i = -\\text{sign}(g_i) \\cdot b_{\\text{frac}} \\cdot (x_{i, \\text{max}} - x_{i, \\text{min}}) $$\n    The new value is $x'_i = x_i + \\Delta x_i$. This value is then clipped to ensure it remains within its physically plausible bounds $[x_{i, \\text{min}}, x_{i, \\text{max}}]$.\n    $$ x'_{i, \\text{clipped}} = \\max(x_{i, \\text{min}}, \\min(x_{i, \\text{max}}, x'_i)) $$\n    This process creates a new perturbed feature vector, $\\mathbf{x}_{\\text{pert}}$, which is identical to $\\mathbf{x}_{\\text{base}}$ except for the top $k$ perturbed features.\n\n4.  **Calculate Performance Drop**: Compute the energy for the perturbed vector, $E_{\\text{pert}} = E(\\mathbf{x}_{\\text{pert}})$. The final performance drop metric, $M$, is then calculated as the normalized difference:\n    $$M = \\frac{E_{\\text{base}} - E_{\\text{pert}}}{E_{\\text{base}}}$$\nThe implementation of this procedure is provided in the final answer.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Validates a gradient-based attribution method for a Li-ion cell model using a deletion test.\n    \"\"\"\n\n    # Constants\n    R_g = 8.314  # J/(mol.K)\n    F = 96485    # C/mol\n    b_bruggeman = 1.5\n    eps_filler = 0.03\n    eps_sep = 0.4\n    E_a = 34000.0  # J/mol\n    T_ref = 298.15 # K\n    n_electrons = 1.0\n\n    # Feature names in a fixed order for vector mapping\n    feature_names = [\n        'eps_e', 'r_p', 'L_e', 'delta_s', 'T', 'kappa', \n        'kappa_sep', 'A', 'i0_ref', 'Voc', 'I', 't'\n    ]\n    feature_map = {name: i for i, name in enumerate(feature_names)}\n\n    # Physically plausible bounds for each feature\n    feature_bounds = {\n        'eps_e': (0.2, 0.6), 'r_p': (1e-6, 1.5e-5), 'L_e': (5e-5, 2e-4),\n        'delta_s': (1e-5, 3e-5), 'T': (283.15, 323.15), 'kappa': (0.5, 2.0),\n        'kappa_sep': (0.3, 1.5), 'A': (0.01, 0.05), 'i0_ref': (1e-6, 1e-3),\n        'Voc': (3.0, 4.2), 'I': (5.0, 30.0), 't': (600.0, 3600.0)\n    }\n    bounds_list = [feature_bounds[name] for name in feature_names]\n\n    def calculate_energy(x_vec):\n        \"\"\"\n        Calculates the delivered energy E from a feature vector.\n        \"\"\"\n        (eps_e, r_p, L_e, delta_s, T, kappa, \n         kappa_sep, A, i0_ref, Voc, I, t) = x_vec\n\n        # Solid volume fraction\n        eps_s = 1.0 - eps_e - eps_filler\n        eps_s = max(0.0, eps_s)\n        \n        # Specific surface area\n        if r_p == 0: return 0.0\n        a = 3.0 * eps_s / r_p\n\n        # Exchange current density\n        i0 = i0_ref * np.exp(-E_a / R_g * (1.0 / T - 1.0 / T_ref))\n\n        # Effective conductivities\n        kappa_eff = kappa * eps_e**b_bruggeman\n        kappa_sep_eff = kappa_sep * eps_sep**b_bruggeman\n\n        # Handle potential divisions by zero, though bounds prevent this\n        if kappa_eff == 0.0 or kappa_sep_eff == 0.0 or A == 0.0:\n            return 0.0\n\n        R_ohm = (L_e / kappa_eff + delta_s / kappa_sep_eff) / A\n\n        # Charge-transfer resistance\n        denominator_R_ct = n_electrons * F * a * i0 * A * L_e\n        if denominator_R_ct == 0.0:\n            return 0.0\n        R_ct = (R_g * T) / denominator_R_ct\n\n        # Total resistance and terminal voltage\n        R_total = R_ohm + R_ct\n        V_terminal = Voc - I * R_total\n        \n        # Delivered energy\n        energy = V_terminal * I * t\n        return max(0.0, energy)\n\n    # Test cases from the problem statement\n    test_cases = [\n        ({'eps_e': 0.35, 'r_p': 5e-6, 'L_e': 1e-4, 'delta_s': 2e-5, 'T': 298.15,\n          'kappa': 1.2, 'kappa_sep': 0.8, 'A': 0.02, 'i0_ref': 1e-4, 'Voc': 3.9,\n          'I': 10, 't': 1800}, 3, 0.2),\n        ({'eps_e': 0.25, 'r_p': 1.2e-5, 'L_e': 1.9e-4, 'delta_s': 2.8e-5, 'T': 283.15,\n          'kappa': 0.6, 'kappa_sep': 0.5, 'A': 0.015, 'i0_ref': 5e-5, 'Voc': 3.7,\n          'I': 25, 't': 1200}, 4, 0.3),\n        ({'eps_e': 0.4, 'r_p': 8e-6, 'L_e': 1.2e-4, 'delta_s': 2.2e-5, 'T': 305.15,\n          'kappa': 1.5, 'kappa_sep': 1.0, 'A': 0.025, 'i0_ref': 2e-4, 'Voc': 4.0,\n          'I': 12, 't': 2000}, 0, 0.25),\n        ({'eps_e': 0.5, 'r_p': 3e-6, 'L_e': 7e-5, 'delta_s': 1.5e-5, 'T': 313.15,\n          'kappa': 1.8, 'kappa_sep': 1.2, 'A': 0.03, 'i0_ref': 8e-4, 'Voc': 4.1,\n          'I': 15, 't': 2400}, 5, 0.1),\n    ]\n\n    results = []\n    grad_step_frac = 1e-7\n\n    for x_dict, k, b_frac in test_cases:\n        x_base = np.array([x_dict[name] for name in feature_names])\n        E_base = calculate_energy(x_base)\n\n        if k == 0 or E_base == 0:\n            results.append(0.0)\n            continue\n\n        grads = []\n        for i in range(len(feature_names)):\n            x_i_min, x_i_max = bounds_list[i]\n            h = grad_step_frac * (x_i_max - x_i_min)\n\n            if h == 0:\n                grads.append(0.0)\n                continue\n            \n            x_plus = x_base.copy()\n            x_plus[i] += h\n            E_plus = calculate_energy(x_plus)\n            \n            x_minus = x_base.copy()\n            x_minus[i] -= h\n            E_minus = calculate_energy(x_minus)\n            \n            gradient = (E_plus - E_minus) / (2 * h)\n            grads.append(gradient)\n        \n        abs_grads = np.abs(np.array(grads))\n        ranked_indices = np.argsort(abs_grads)[::-1]\n        \n        x_pert = x_base.copy()\n        top_k_indices = ranked_indices[:k]\n        \n        for idx in top_k_indices:\n            grad_val = grads[idx]\n            x_min, x_max = bounds_list[idx]\n            feat_range = x_max - x_min\n            \n            perturbation = -np.sign(grad_val) * b_frac * feat_range\n            x_pert[idx] += perturbation\n            x_pert[idx] = np.clip(x_pert[idx], x_min, x_max)\n            \n        E_pert = calculate_energy(x_pert)\n        \n        M = (E_base - E_pert) / E_base\n        results.append(round(M, 6))\n\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "The ultimate promise of XAI in scientific and engineering domains is to move beyond explanation to guide discovery and design optimization. This advanced practice demonstrates how to generate *counterfactuals*—alternative designs or operating conditions that achieve a desired outcome. Using local sensitivities from a hypothetical XAI model, you will formulate and solve a constrained optimization problem to create a safer charging protocol that mitigates lithium plating risk while maintaining performance ().",
            "id": "3913447",
            "problem": "You are given a baseline constant-current charging protocol over a finite horizon and asked to construct a counterfactual protocol that reduces a plating-risk surrogate while maintaining charge throughput and respecting current density and thermal constraints. The setting is motivated by explainable artificial intelligence in battery design: a locally interpretable surrogate derived from a black-box plating-risk predictor provides first- and second-order sensitivities with respect to current density. Your task is to solve, for each test case, a constrained quadratic program representing the locally valid counterfactual adjustment.\n\nFundamental base and core definitions to use in the derivation: (i) the Butler–Volmer relationship implies that interfacial overpotential increases monotonically with current density, which increases plating propensity; (ii) a lumped one-resistor one-capacitor thermal model, with heat input from Joule heating, captures cell temperature evolution; (iii) a local surrogate approximation from an explainable predictor yields a quadratic-increment risk function in the current-density adjustments. The steps are specified below.\n\nLet there be $N$ time intervals, each of duration $\\Delta t$ (in seconds), with baseline current-density profile $\\mathbf{J}_0 \\in \\mathbb{R}^N$ where each component $J_{0,i}$ is in $\\mathrm{A}/\\mathrm{m}^2$. Let the decision variable be the counterfactual current-density profile $\\mathbf{J} \\in \\mathbb{R}^N$, with the same units. Let the cell geometric area be $A_{\\mathrm{cell}}$ (in $\\mathrm{m}^2$), internal resistance be $R_{\\mathrm{int}}$ (in $\\Omega$), thermal resistance be $R_{\\mathrm{th}}$ (in $\\mathrm{K}/\\mathrm{W}$), thermal capacitance be $C_{\\mathrm{th}}$ (in $\\mathrm{J}/\\mathrm{K}$), ambient temperature be $T_{\\mathrm{env}}$ (in $\\mathrm{K}$), and initial temperature be $T_{\\mathrm{init}}$ (in $\\mathrm{K}$). The lumped thermal dynamics are discretized by forward Euler from the energy balance\n$$\nC_{\\mathrm{th}} \\frac{dT}{dt} = I^2 R_{\\mathrm{int}} - \\frac{T - T_{\\mathrm{env}}}{R_{\\mathrm{th}}},\n$$\nwith $I = A_{\\mathrm{cell}} J$, yielding\n$$\nT_{i+1} = T_i + \\frac{\\Delta t}{C_{\\mathrm{th}}} \\left( A_{\\mathrm{cell}}^2 J_i^2 R_{\\mathrm{int}} - \\frac{T_i - T_{\\mathrm{env}}}{R_{\\mathrm{th}}} \\right),\n$$\nfor $i \\in \\{0,\\dots,N-1\\}$, $T_0 = T_{\\mathrm{init}}$. The thermal constraint is $T_i \\le T_{\\max}$ (in $\\mathrm{K}$) for all indices at the end of each interval. The current-density bound is $0 \\le J_i \\le J_{\\max}$ (in $\\mathrm{A}/\\mathrm{m}^2$). The charge-throughput equality is\n$$\n\\sum_{i=0}^{N-1} J_i \\, \\Delta t = \\sum_{i=0}^{N-1} J_{0,i} \\, \\Delta t,\n$$\nwhich enforces equal total delivered charge (in $\\mathrm{A}\\cdot\\mathrm{s}/\\mathrm{m}^2$) between baseline and counterfactual.\n\nFrom a locally interpretable surrogate of a plating-risk black box (e.g., a local model-agnostic explanation or Shapley-based quadratic fit), you are given per-interval first-order sensitivities $g_i$ and positive curvatures $h_i > 0$ such that the incremental change in aggregate risk relative to the baseline is approximated by\n$$\n\\Delta \\mathcal{R}(\\mathbf{J}) \\approx \\sum_{i=0}^{N-1} \\left[ g_i \\, (J_i - J_{0,i}) + \\tfrac{1}{2} h_i \\, (J_i - J_{0,i})^2 \\right].\n$$\nThe absolute baseline risk $\\mathcal{R}_0$ (in arbitrary nonnegative units) is provided. The counterfactual risk is approximated by $\\mathcal{R}_{\\star} \\approx \\mathcal{R}_0 + \\Delta \\mathcal{R}(\\mathbf{J}_{\\star})$. Your goal is to minimize $\\Delta \\mathcal{R}$ subject to constraints.\n\nTo retain the thermal constraint in a tractable form, use a first-order sensitivity linearization about the baseline trajectory. Define $\\phi = 1 - \\frac{\\Delta t}{C_{\\mathrm{th}} R_{\\mathrm{th}}}$. The baseline temperature trajectory $(T_i^0)_{i=0}^N$ is obtained by the above thermal recursion with $\\mathbf{J}_0$. The linear sensitivity matrix $\\mathbf{B} \\in \\mathbb{R}^{N \\times N}$, with entries $B_{i,k} = \\frac{\\partial T_{i+1}}{\\partial J_k} \\big|_{\\mathbf{J}_0}$, satisfies\n$$\nB_{k,k} = \\frac{\\Delta t}{C_{\\mathrm{th}}} \\, 2 A_{\\mathrm{cell}}^2 R_{\\mathrm{int}} \\, J_{0,k}, \\quad\nB_{i,k} = \\phi \\, B_{i-1,k} \\text{ for } i > k, \\quad\nB_{i,k} = 0 \\text{ for } i < k,\n$$\nso that the linearized thermal constraints at the end of each interval become\n$$\nT_{i+1}^0 + \\sum_{k=0}^{N-1} B_{i,k} \\, (J_k - J_{0,k}) \\le T_{\\max}, \\quad i = 0,\\dots,N-1.\n$$\nYou must solve the constrained quadratic program\n$$\n\\min_{\\mathbf{J} \\in \\mathbb{R}^N} \\sum_{i=0}^{N-1} \\left[ g_i \\, (J_i - J_{0,i}) + \\tfrac{1}{2} h_i \\, (J_i - J_{0,i})^2 \\right]\n$$\nsubject to\n$$\n\\sum_{i=0}^{N-1} J_i \\, \\Delta t = \\sum_{i=0}^{N-1} J_{0,i} \\, \\Delta t, \\quad\n0 \\le J_i \\le J_{\\max} \\text{ for all } i, \\quad\nT_{i+1}^0 + \\sum_{k=0}^{N-1} B_{i,k} \\, (J_k - J_{0,k}) \\le T_{\\max} \\text{ for } i=0,\\dots,N-1.\n$$\nFor each test case, compute the optimized $\\mathbf{J}_{\\star}$, then compute the estimated absolute counterfactual risk $\\mathcal{R}_{\\star} \\approx \\mathcal{R}_0 + \\Delta \\mathcal{R}(\\mathbf{J}_{\\star})$, and finally report the fractional risk reduction as the decimal\n$$\n\\rho = \\frac{\\mathcal{R}_0 - \\mathcal{R}_{\\star}}{\\mathcal{R}_0},\n$$\nrounded to six decimal places. No percentage sign is permitted; report a unitless decimal.\n\nPhysical units and angle units: current density must be in $\\mathrm{A}/\\mathrm{m}^2$, time in $\\mathrm{s}$, area in $\\mathrm{m}^2$, resistance in $\\Omega$, thermal resistance in $\\mathrm{K}/\\mathrm{W}$, thermal capacitance in $\\mathrm{J}/\\mathrm{K}$, and temperature in $\\mathrm{K}$. No angle quantities appear.\n\nTest suite and parameters:\n\nTest case $1$ (happy path, moderate constraints):\n- $N = 4$, $\\Delta t = 60.0$, $A_{\\mathrm{cell}} = 0.01$, $R_{\\mathrm{int}} = 0.05$, $R_{\\mathrm{th}} = 5.0$, $C_{\\mathrm{th}} = 400.0$, $T_{\\mathrm{env}} = 298.15$, $T_{\\mathrm{init}} = 298.15$, $J_{\\max} = 150.0$, $T_{\\max} = 313.15$.\n- Baseline $\\mathbf{J}_0 = [120.0, 120.0, 80.0, 80.0]$.\n- Surrogate parameters $\\mathbf{g} = [0.8, 0.6, 0.2, 0.1]$, $\\mathbf{h} = [0.02, 0.02, 0.01, 0.01]$, and $\\mathcal{R}_0 = 10.0$.\n\nTest case $2$ (thermal constraint more active):\n- $N = 4$, $\\Delta t = 60.0$, $A_{\\mathrm{cell}} = 0.01$, $R_{\\mathrm{int}} = 0.05$, $R_{\\mathrm{th}} = 5.0$, $C_{\\mathrm{th}} = 400.0$, $T_{\\mathrm{env}} = 298.15$, $T_{\\mathrm{init}} = 298.15$, $J_{\\max} = 150.0$, $T_{\\max} = 303.15$.\n- Baseline $\\mathbf{J}_0 = [100.0, 100.0, 100.0, 100.0]$.\n- Surrogate parameters $\\mathbf{g} = [1.0, 0.7, 0.2, 0.1]$, $\\mathbf{h} = [0.02, 0.02, 0.01, 0.01]$, and $\\mathcal{R}_0 = 8.0$.\n\nTest case $3$ (current-density bound limiting reallocation):\n- $N = 4$, $\\Delta t = 30.0$, $A_{\\mathrm{cell}} = 0.01$, $R_{\\mathrm{int}} = 0.05$, $R_{\\mathrm{th}} = 5.0$, $C_{\\mathrm{th}} = 400.0$, $T_{\\mathrm{env}} = 298.15$, $T_{\\mathrm{init}} = 298.15$, $J_{\\max} = 110.0$, $T_{\\max} = 330.0$.\n- Baseline $\\mathbf{J}_0 = [110.0, 110.0, 110.0, 110.0]$.\n- Surrogate parameters $\\mathbf{g} = [0.1, 0.1, 0.1, 0.1]$, $\\mathbf{h} = [0.005, 0.005, 0.005, 0.005]$, and $\\mathcal{R}_0 = 12.0$.\n\nFinal output format: Your program should produce a single line of output containing the three fractional risk reductions, in order for test cases $1$, $2$, and $3$, as a comma-separated list enclosed in square brackets, for example, $[x_1,x_2,x_3]$, where each $x_i$ is a decimal rounded to six places. No other text should be printed.",
            "solution": "The problem requires the solution of a constrained quadratic optimization problem to find a counterfactual battery charging protocol that minimizes a surrogate for plating risk while adhering to constraints on total charge, current density, and cell temperature. The solution process involves formulating the problem as a standard Quadratic Program (QP), constructing the necessary matrices and vectors from the given physical parameters, solving the QP numerically, and calculating the final performance metric.\n\nLet the number of time intervals be $N$, and let the vector of adjustments to the baseline current-density profile $\\mathbf{J}_0 \\in \\mathbb{R}^N$ be the decision variable $\\boldsymbol{\\delta} \\in \\mathbb{R}^N$, where $\\boldsymbol{\\delta} = \\mathbf{J} - \\mathbf{J}_0$. The indices for all vectors and time-dependent quantities will be $0$-based, i.e., $i \\in \\{0, 1, \\dots, N-1\\}$.\n\nThe optimization problem is to minimize the incremental risk, which is a quadratic function of $\\boldsymbol{\\delta}$:\n$$\n\\min_{\\boldsymbol{\\delta} \\in \\mathbb{R}^N} \\quad f(\\boldsymbol{\\delta}) = \\sum_{i=0}^{N-1} \\left[ g_i \\delta_i + \\tfrac{1}{2} h_i \\delta_i^2 \\right]\n$$\nThis objective function can be written in matrix form as:\n$$\n\\min_{\\boldsymbol{\\delta}} \\quad \\frac{1}{2} \\boldsymbol{\\delta}^T \\mathbf{H} \\boldsymbol{\\delta} + \\mathbf{g}^T \\boldsymbol{\\delta}\n$$\nwhere $\\mathbf{g} = [g_0, g_1, \\dots, g_{N-1}]^T$ is the vector of first-order sensitivities and $\\mathbf{H} = \\mathrm{diag}(h_0, h_1, \\dots, h_{N-1})$ is the diagonal matrix of positive curvatures. Since all $h_i > 0$, the Hessian matrix $\\mathbf{H}$ is positive definite, making the objective function strictly convex.\n\nThe optimization is subject to the following linear constraints:\n\n1.  **Charge Throughput Conservation**: The total charge delivered must be the same as the baseline.\n    $$\n    \\sum_{i=0}^{N-1} J_i \\Delta t = \\sum_{i=0}^{N-1} J_{0,i} \\Delta t \\implies \\sum_{i=0}^{N-1} (J_{0,i} + \\delta_i) = \\sum_{i=0}^{N-1} J_{0,i} \\implies \\sum_{i=0}^{N-1} \\delta_i = 0\n    $$\n    In vector form, this is $\\mathbf{1}^T \\boldsymbol{\\delta} = 0$, where $\\mathbf{1}$ is a vector of ones.\n\n2.  **Current Density Bounds**: The current density at each step must be within the specified limits.\n    $$\n    0 \\le J_i \\le J_{\\max} \\implies 0 \\le J_{0,i} + \\delta_i \\le J_{\\max} \\implies -J_{0,i} \\le \\delta_i \\le J_{\\max} - J_{0,i}\n    $$\n    These are box constraints on the decision variables $\\delta_i$.\n\n3.  **Linearized Thermal Constraints**: The cell temperature at the end of each interval must not exceed a maximum value $T_{\\max}$. The temperature evolution is linearized around the baseline trajectory $\\mathbf{T}^0 = (T_1^0, \\dots, T_N^0)$.\n    $$\n    T_{i+1}^0 + \\sum_{k=0}^{N-1} B_{i,k} \\delta_k \\le T_{\\max} \\quad \\text{for } i = 0, \\dots, N-1\n    $$\n    where $\\mathbf{B}$ is the $N \\times N$ thermal sensitivity matrix. This set of $N$ inequalities can be written as $\\mathbf{B} \\boldsymbol{\\delta} \\le \\mathbf{d}$, where the vector $\\mathbf{d}$ has components $d_i = T_{\\max} - T_{i+1}^0$.\n\nThe problem is a convex QP, as it involves minimizing a strictly convex quadratic function over a convex feasible set (defined by linear equalities and inequalities). Such a problem has a unique global minimum. We can solve it using a numerical optimization solver, such as the Sequential Least Squares Programming (SLSQP) algorithm available in `scipy.optimize.minimize`.\n\nThe solution proceeds in the following steps for each test case:\n\n**Step 1: Compute Baseline Temperature Trajectory**\nThe baseline temperature at the end of each interval, $T_{i+1}^0$, is calculated by iterating the discretized thermal model with the baseline current profile $\\mathbf{J}_0$. The recurrence relation is:\n$$\nT_{i+1}^0 = T_i^0 + \\frac{\\Delta t}{C_{\\mathrm{th}}} \\left( A_{\\mathrm{cell}}^2 J_{0,i}^2 R_{\\mathrm{int}} - \\frac{T_i^0 - T_{\\mathrm{env}}}{R_{\\mathrm{th}}} \\right), \\quad T_0^0 = T_{\\mathrm{init}}\n$$\nThis can be rewritten as $T_{i+1}^0 = \\phi T_i^0 + \\alpha J_{0,i}^2 + \\beta T_{\\mathrm{env}}$, where $\\phi = 1 - \\frac{\\Delta t}{C_{\\mathrm{th}}R_{\\mathrm{th}}}$, $\\alpha = \\frac{\\Delta t A_{\\mathrm{cell}}^2 R_{\\mathrm{int}}}{C_{\\mathrm{th}}}$, and $\\beta = \\frac{\\Delta t}{C_{\\mathrm{th}}R_{\\mathrm{th}}}$. The resulting temperatures $T_1^0, \\dots, T_N^0$ are used to define the thermal constraint bounds.\n\n**Step 2: Construct Thermal Sensitivity Matrix B**\nThe matrix $\\mathbf{B}$ contains the partial derivatives $B_{i,k} = \\frac{\\partial T_{i+1}}{\\partial J_k}$ evaluated at $\\mathbf{J} = \\mathbf{J}_0$. It has a lower triangular structure because the temperature at time step $i+1$ is not affected by future currents ($J_k$ for $k > i$). The entries are computed as:\n$$\nB_{i,k} =\n\\begin{cases}\n0 & \\text{if } k > i \\\\\n\\frac{2 \\Delta t A_{\\mathrm{cell}}^2 R_{\\mathrm{int}}}{C_{\\mathrm{th}}} J_{0,k} & \\text{if } k = i \\\\\n\\phi B_{i-1,k} & \\text{if } k < i\n\\end{cases}\n$$\n\n**Step 3: Solve the Quadratic Program**\nThe QP is formulated and solved numerically. The necessary components for the solver are:\n- The objective function $f(\\boldsymbol{\\delta}) = \\frac{1}{2}\\boldsymbol{\\delta}^T \\mathbf{H} \\boldsymbol{\\delta} + \\mathbf{g}^T \\boldsymbol{\\delta}$.\n- The gradient (Jacobian) of the objective: $\\nabla f(\\boldsymbol{\\delta}) = \\mathbf{H}\\boldsymbol{\\delta} + \\mathbf{g}$.\n- The equality constraint: $\\sum_{i=0}^{N-1} \\delta_i = 0$.\n- The inequality constraints: $T_{\\max} - T_{i+1}^0 - (\\mathbf{B}\\boldsymbol{\\delta})_i \\ge 0$ for $i=0, \\dots, N-1$. (Note the $\\ge 0$ form required by SciPy).\n- The bounds on variables: $-J_{0,i} \\le \\delta_i \\le J_{\\max} - J_{0,i}$.\n\nAn initial guess of $\\boldsymbol{\\delta} = \\mathbf{0}$ is provided to the solver. The output is the optimal adjustment vector $\\boldsymbol{\\delta}_{\\star}$.\n\n**Step 4: Compute Fractional Risk Reduction**\nThe optimal incremental risk, $\\Delta \\mathcal{R}(\\mathbf{J}_{\\star})$, is the value of the objective function at the solution $\\boldsymbol{\\delta}_{\\star}$. The counterfactual absolute risk is $\\mathcal{R}_{\\star} = \\mathcal{R}_0 + \\Delta \\mathcal{R}(\\mathbf{J}_{\\star})$. The fractional risk reduction, $\\rho$, is then calculated as:\n$$\n\\rho = \\frac{\\mathcal{R}_0 - \\mathcal{R}_{\\star}}{\\mathcal{R}_0} = \\frac{\\mathcal{R}_0 - (\\mathcal{R}_0 + \\Delta \\mathcal{R}(\\mathbf{J}_{\\star}))}{\\mathcal{R}_0} = - \\frac{\\Delta \\mathcal{R}(\\mathbf{J}_{\\star})}{\\mathcal{R}_0}\n$$\nThe final value is rounded to six decimal places as specified. This process is repeated for all test cases.",
            "answer": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef solve():\n    \"\"\"\n    Solves the constrained quadratic program for each test case to find the\n    optimal counterfactual charging protocol and reports the fractional risk reduction.\n    \"\"\"\n\n    test_cases = [\n        # Test case 1\n        {\n            'N': 4, 'dt': 60.0, 'A_cell': 0.01, 'R_int': 0.05, 'R_th': 5.0, \n            'C_th': 400.0, 'T_env': 298.15, 'T_init': 298.15, 'J_max': 150.0, \n            'T_max': 313.15, 'J0': [120.0, 120.0, 80.0, 80.0],\n            'g': [0.8, 0.6, 0.2, 0.1], 'h': [0.02, 0.02, 0.01, 0.01], 'R0': 10.0\n        },\n        # Test case 2\n        {\n            'N': 4, 'dt': 60.0, 'A_cell': 0.01, 'R_int': 0.05, 'R_th': 5.0,\n            'C_th': 400.0, 'T_env': 298.15, 'T_init': 298.15, 'J_max': 150.0,\n            'T_max': 303.15, 'J0': [100.0, 100.0, 100.0, 100.0],\n            'g': [1.0, 0.7, 0.2, 0.1], 'h': [0.02, 0.02, 0.01, 0.01], 'R0': 8.0\n        },\n        # Test case 3\n        {\n            'N': 4, 'dt': 30.0, 'A_cell': 0.01, 'R_int': 0.05, 'R_th': 5.0, \n            'C_th': 400.0, 'T_env': 298.15, 'T_init': 298.15, 'J_max': 110.0, \n            'T_max': 330.0, 'J0': [110.0, 110.0, 110.0, 110.0],\n            'g': [0.1, 0.1, 0.1, 0.1], 'h': [0.005, 0.005, 0.005, 0.005], 'R0': 12.0\n        }\n    ]\n\n    results = []\n    for params in test_cases:\n        result = _solve_case(params)\n        results.append(f\"{result:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\n\ndef _solve_case(params):\n    \"\"\"\n    Helper function to set up and solve the QP for a single test case.\n    \"\"\"\n    # 1. Unpack parameters and convert to numpy arrays\n    N = params['N']\n    dt = params['dt']\n    A_cell = params['A_cell']\n    R_int = params['R_int']\n    R_th = params['R_th']\n    C_th = params['C_th']\n    T_env = params['T_env']\n    T_init = params['T_init']\n    J_max = params['J_max']\n    T_max = params['T_max']\n    J0 = np.array(params['J0'])\n    g = np.array(params['g'])\n    h = np.array(params['h'])\n    R0 = params['R0']\n\n    # 2. Calculate baseline temperature trajectory\n    T0_traj = np.zeros(N + 1)\n    T0_traj[0] = T_init\n    \n    phi = 1.0 - dt / (C_th * R_th)\n    alpha = dt * A_cell**2 * R_int / C_th\n    beta_T_env = (dt / (C_th * R_th)) * T_env\n\n    for i in range(N):\n        T0_traj[i+1] = phi * T0_traj[i] + alpha * J0[i]**2 + beta_T_env\n\n    # 3. Construct the thermal sensitivity matrix B\n    B = np.zeros((N, N))\n    b_diag_factor = 2.0 * dt * A_cell**2 * R_int / C_th\n    for k in range(N):\n        B[k, k] = b_diag_factor * J0[k]\n        for i in range(k + 1, N):\n            B[i, k] = phi * B[i - 1, k]\n\n    # 4. Define the QP problem for the solver\n    # Decision variable is delta, the adjustment to J0\n    def objective(delta):\n        return 0.5 * np.sum(h * delta**2) + np.sum(g * delta)\n\n    def jacobian(delta):\n        return h * delta + g\n\n    # Equality constraint: sum of adjustments is zero (charge conservation)\n    eq_constraint = {'type': 'eq', 'fun': lambda delta: np.sum(delta)}\n\n    # Inequality constraints: thermal limits\n    # SLSQP expects constraints in the form C(x) >= 0.\n    # B @ delta <= T_max - T0_traj[1:] -> (T_max - T0_traj[1:]) - (B @ delta) >= 0\n    ineq_constraints = []\n    for i in range(N):\n        constraint_fun = lambda delta, i=i: (T_max - T0_traj[i + 1]) - np.dot(B[i, :], delta)\n        ineq_constraints.append({'type': 'ineq', 'fun': constraint_fun})\n\n    constraints = [eq_constraint] + ineq_constraints\n\n    # Bounds for each delta_i: -J0[i] <= delta_i <= J_max - J0[i]\n    bounds = [(-J0[i], J_max - J0[i]) for i in range(N)]\n    \n    # 5. Solve the QP\n    delta0 = np.zeros(N)\n    res = minimize(objective, delta0, method='SLSQP', jac=jacobian, \n                   bounds=bounds, constraints=constraints)\n\n    # 6. Calculate the final result (fractional risk reduction)\n    delta_R_star = res.fun\n    rho = -delta_R_star / R0\n    \n    return rho\n\nsolve()\n```"
        }
    ]
}