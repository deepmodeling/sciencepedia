{
    "hands_on_practices": [
        {
            "introduction": "This first practice guides you through building a complete Space Vector Modulation (SVM) algorithm from the ground up. By implementing the core logic for sector detection and dwell time calculation, you will solidify your understanding of how a continuous reference vector is synthesized from discrete inverter states . This exercise is fundamental to mastering the principles of modern AC drive control.",
            "id": "3882584",
            "problem": "You are given the task of designing a general algorithm for Space Vector Modulation (SVM) that maps a specified reference trajectory in the stationary two-axis frame (the $\\alpha$-$\\beta$ plane) to a discrete set of inverter switching vectors and computes the associated dwell times. The context is a three-phase, two-level Voltage Source Inverter (VSI). The objective is to derive and implement an algorithm that, from first principles, performs reference vector mapping, sector detection, and dwell time calculation without relying on pre-derived shortcut formulas.\n\nBegin from the following foundational definitions and facts:\n\n- Let the Direct Current (DC) bus voltage be denoted by $V_{\\mathrm{dc}}$ and the sampling period by $T_{\\mathrm{s}}$ (time per switching cycle).\n- For a three-phase, two-level VSI, each leg produces a phase-to-virtual-neutral voltage $v_a$, $v_b$, $v_c \\in \\{\\pm V_{\\mathrm{dc}}/2\\}$ depending on whether the upper or lower switch is on. Let the switching state of each leg be $s_a, s_b, s_c \\in \\{+1,-1\\}$, where $+1$ corresponds to $+V_{\\mathrm{dc}}/2$ and $-1$ corresponds to $-V_{\\mathrm{dc}}/2$.\n- The stationary two-axis (Clarke) transform mapping three phase voltages $(v_a,v_b,v_c)$ to the $\\alpha$-$\\beta$ components $(v_\\alpha,v_\\beta)$ is defined as\n  $$\n  v_\\alpha = \\frac{2}{3}\\left(v_a - \\frac{1}{2}v_b - \\frac{1}{2}v_c\\right),\\quad\n  v_\\beta = \\frac{2}{3}\\left(\\frac{\\sqrt{3}}{2}(v_b - v_c)\\right).\n  $$\n  Substituting $v_a = s_a\\frac{V_{\\mathrm{dc}}}{2}$, $v_b = s_b\\frac{V_{\\mathrm{dc}}}{2}$, and $v_c = s_c\\frac{V_{\\mathrm{dc}}}{2}$ yields the inverter’s space vectors in the $\\alpha$-$\\beta$ plane.\n- The six active switching vectors (non-zero) appear at angles separated by $60^\\circ$ and have identical magnitude. Their exact coordinates follow from the definitions above for the switching triplets:\n  $$\n  \\begin{aligned}\n  \\mathbf{V}_1 &: (s_a,s_b,s_c) = (+1,-1,-1), \\\\\n  \\mathbf{V}_2 &: (s_a,s_b,s_c) = (+1,+1,-1), \\\\\n  \\mathbf{V}_3 &: (s_a,s_b,s_c) = (-1,+1,-1), \\\\\n  \\mathbf{V}_4 &: (s_a,s_b,s_c) = (-1,+1,+1), \\\\\n  \\mathbf{V}_5 &: (s_a,s_b,s_c) = (-1,-1,+1), \\\\\n  \\mathbf{V}_6 &: (s_a,s_b,s_c) = (+1,-1,+1). \\\\\n  \\end{aligned}\n  $$\n  Each $\\mathbf{V}_k$ is computed by the Clarke transform above, and has magnitude $|\\mathbf{V}_k| = \\frac{2}{3}V_{\\mathrm{dc}}$.\n- The set of zero switching vectors corresponds to $(s_a,s_b,s_c)=(+1,+1,+1)$ or $(-1,-1,-1)$, which both map to the zero vector $\\mathbf{0}$.\n\nReference vector specification:\n\n- The desired reference voltage vector is given by its polar form $(V_{\\mathrm{ref}}, \\theta)$, where $V_{\\mathrm{ref}}$ is the magnitude and $\\theta$ is the angle. Use angle units in radians throughout. The reference is mapped into the $\\alpha$-$\\beta$ plane by\n  $$\n  v_\\alpha = V_{\\mathrm{ref}}\\cos(\\theta),\\quad v_\\beta = V_{\\mathrm{ref}}\\sin(\\theta).\n  $$\n\nSector detection:\n\n- Define the sector index $k\\in\\{1,2,3,4,5,6\\}$ as the region of the $\\alpha$-$\\beta$ plane bounded by two adjacent active switching vectors within which the angle $\\theta$ lies. Use the rule\n  $$\n  \\theta_{\\mathrm{mod}} = \\theta \\bmod 2\\pi,\\quad\n  k = 1 + \\left\\lfloor \\frac{\\theta_{\\mathrm{mod}}}{\\pi/3} \\right\\rfloor,\n  $$\n  with the convention that if $V_{\\mathrm{ref}}=0$ then set $k=0$ and all dwell in the zero vector.\n- For angles exactly on a sector boundary, i.e., $\\theta_{\\mathrm{mod}}$ equal to an integer multiple of $\\pi/3$, use the above formula directly (this assigns the boundary to the higher-numbered sector except $\\theta_{\\mathrm{mod}}=0$, which maps to $k=1$).\n\nDwell time computation:\n\n- Over one switching period $T_{\\mathrm{s}}$, the reference vector integration must equal the time-weighted sum of the applied inverter vectors:\n  $$\n  T_1\\,\\mathbf{V}_k + T_2\\,\\mathbf{V}_{k+1} + T_0\\,\\mathbf{0} = T_{\\mathrm{s}}\\,\\mathbf{v}_{\\mathrm{ref}},\n  $$\n  with $T_1\\ge 0$, $T_2\\ge 0$, $T_0\\ge 0$, and $T_1+T_2+T_0 = T_{\\mathrm{s}}$.\n- The pair $(T_1,T_2)$ is obtained by solving the $2\\times 2$ linear system formed by the $\\alpha$-$\\beta$ components of $\\mathbf{V}_k$ and $\\mathbf{V}_{k+1}$ against $T_{\\mathrm{s}}\\,\\mathbf{v}_{\\mathrm{ref}}$. The zero dwell time is $T_0=T_{\\mathrm{s}}-T_1-T_2$.\n- Normalize dwell times as duty ratios $d_1=T_1/T_{\\mathrm{s}}$, $d_2=T_2/T_{\\mathrm{s}}$, $d_0=T_0/T_{\\mathrm{s}}$, enforcing $d_1,d_2,d_0\\in[0,1]$ and $d_1+d_2+d_0=1$.\n\nLinear region constraint:\n\n- The linear modulation region corresponds to the interior of the hexagon spanned by the active vectors. The maximum attainable radial reference magnitude along a sector bisector equals $V_{\\mathrm{dc}}/\\sqrt{3}$. If $V_{\\mathrm{ref}} > V_{\\mathrm{dc}}/\\sqrt{3}$, then saturate by setting $V_{\\mathrm{ref}} \\leftarrow V_{\\mathrm{dc}}/\\sqrt{3}$ while keeping $\\theta$ unchanged. This ensures $d_0\\ge 0$ and avoids overmodulation in this problem.\n\nUnits:\n\n- Express $V_{\\mathrm{dc}}$ and $V_{\\mathrm{ref}}$ in volts (V), $T_{\\mathrm{s}}$ in seconds (s), and angles $\\theta$ in radians. Duty ratios $d_1$, $d_2$, $d_0$ are dimensionless.\n\nYour program must implement:\n\n1. Mapping $(V_{\\mathrm{ref}},\\theta)$ into $(v_\\alpha,v_\\beta)$ with saturation to the linear boundary $V_{\\mathrm{dc}}/\\sqrt{3}$ when necessary.\n2. Sector detection per the rule above, using modulo for negative angles and tie-breaking on sector boundaries.\n3. Construction of the two adjacent active vectors $\\mathbf{V}_k$ and $\\mathbf{V}_{k+1}$ via the Clarke transform from switching states and solution of the $2\\times 2$ system for dwell times.\n4. Normalization and clipping of duty ratios such that $d_1,d_2,d_0\\in[0,1]$ and $d_1+d_2+d_0=1$.\n\nTest suite:\n\nUse the following test cases $(V_{\\mathrm{dc}}, T_{\\mathrm{s}}, V_{\\mathrm{ref}}, \\theta)$:\n\n- Case 1 (general interior): $(600,\\ 1\\times 10^{-4},\\ 300,\\ 0.7)$.\n- Case 2 (on sector boundary): $(540,\\ 5\\times 10^{-5},\\ 200,\\ \\pi/3)$.\n- Case 3 (saturation required): $(700,\\ 2\\times 10^{-4},\\ 420,\\ 5.5)$.\n- Case 4 (null vector): $(800,\\ 1\\times 10^{-4},\\ 0,\\ 2.0)$.\n- Case 5 (negative axis): $(500,\\ 1.5\\times 10^{-4},\\ 100,\\ \\pi)$.\n- Case 6 (negative angle): $(650,\\ 7\\times 10^{-5},\\ 150,\\ -0.1)$.\n\nFinal output format:\n\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each test case’s result must be the four-element list $[k,d_1,d_2,d_0]$ with $k$ an integer and $d_1$, $d_2$, $d_0$ real numbers rounded to $10$ decimal places. There must be no spaces in the output string. For example:\n  $$\n  [[k_1,d_{1,1},d_{2,1},d_{0,1}],[k_2,d_{1,2},d_{2,2},d_{0,2}],\\dots]\n  $$",
            "solution": "We design the algorithm by combining the physics of a two-level inverter, the Clarke transform, and geometry of the space vector hexagon. The key steps are:\n\n1. Foundational mapping of inverter switching states to space vectors.\n\nA three-phase, two-level Voltage Source Inverter (VSI) has leg voltages $v_a$, $v_b$, $v_c \\in \\{\\pm V_{\\mathrm{dc}}/2\\}$ determined by switching states $s_a,s_b,s_c\\in\\{+1,-1\\}$. The stationary frame (Clarke) transform maps $(v_a,v_b,v_c)$ to $(v_\\alpha,v_\\beta)$:\n$$\nv_\\alpha = \\frac{2}{3}\\left(v_a - \\frac{1}{2}v_b - \\frac{1}{2}v_c\\right),\\quad\nv_\\beta = \\frac{2}{3}\\left(\\frac{\\sqrt{3}}{2}(v_b - v_c)\\right).\n$$\nSubstituting $v_a = s_a\\frac{V_{\\mathrm{dc}}}{2}$, $v_b = s_b\\frac{V_{\\mathrm{dc}}}{2}$, $v_c = s_c\\frac{V_{\\mathrm{dc}}}{2}$, we obtain\n$$\nv_\\alpha = \\frac{V_{\\mathrm{dc}}}{3}\\left(s_a - \\frac{1}{2}s_b - \\frac{1}{2}s_c\\right),\\quad\nv_\\beta = \\frac{V_{\\mathrm{dc}}\\sqrt{3}}{6}(s_b - s_c).\n$$\nThere are six active vectors $\\mathbf{V}_k$ corresponding to switching triplets with two legs at $+1$ and one leg at $-1$, and the complementary three with two legs at $-1$ and one at $+1$. Organizing them by angle yields:\n$$\n\\begin{aligned}\n\\mathbf{V}_1 &: (s_a,s_b,s_c)=(+1,-1,-1),\\\\\n\\mathbf{V}_2 &: (s_a,s_b,s_c)=(+1,+1,-1),\\\\\n\\mathbf{V}_3 &: (s_a,s_b,s_c)=(-1,+1,-1),\\\\\n\\mathbf{V}_4 &: (s_a,s_b,s_c)=(-1,+1,+1),\\\\\n\\mathbf{V}_5 &: (s_a,s_b,s_c)=(-1,-1,+1),\\\\\n\\mathbf{V}_6 &: (s_a,s_b,s_c)=(+1,-1,+1).\n\\end{aligned}\n$$\nEach has magnitude $|\\mathbf{V}_k| = \\frac{2}{3}V_{\\mathrm{dc}}$ and is spaced by $60^\\circ$.\n\n2. Reference trajectory mapping.\n\nThe desired reference vector is specified by polar coordinates $(V_{\\mathrm{ref}},\\theta)$, with $(v_\\alpha,v_\\beta)$ determined by\n$$\nv_\\alpha = V_{\\mathrm{ref}}\\cos(\\theta),\\quad v_\\beta = V_{\\mathrm{ref}}\\sin(\\theta).\n$$\nSVM in the linear region requires that the reference lie within the hexagon spanned by the six active vectors. The maximum radial magnitude attainable along a sector bisector in the linear region equals $V_{\\mathrm{dc}}/\\sqrt{3}$, obtained by considering that the longest combination inside a sector triangle occurs at $T_1=T_2=T_{\\mathrm{s}}/2$, yielding\n$$\n\\left|\\frac{T_{\\mathrm{s}}}{2}\\mathbf{V}_k + \\frac{T_{\\mathrm{s}}}{2}\\mathbf{V}_{k+1}\\right| = \\frac{T_{\\mathrm{s}}}{2}\\left|\\mathbf{V}_k + \\mathbf{V}_{k+1}\\right| = \\frac{T_{\\mathrm{s}}}{2}\\cdot \\frac{4}{3}V_{\\mathrm{dc}}\\cos\\left(\\frac{\\pi}{6}\\right) = T_{\\mathrm{s}}\\cdot \\frac{V_{\\mathrm{dc}}}{\\sqrt{3}},\n$$\nso the normalized maximum is $V_{\\mathrm{dc}}/\\sqrt{3}$. We therefore saturate:\n$$\nV_{\\mathrm{ref}} \\leftarrow \\min\\left(V_{\\mathrm{ref}},\\frac{V_{\\mathrm{dc}}}{\\sqrt{3}}\\right),\n$$\nwhile preserving angle $\\theta$.\n\n3. Sector detection.\n\nAligning with the hexagon geometry, we define sector index $k$ from the angle modulo $2\\pi$:\n$$\n\\theta_{\\mathrm{mod}} = \\theta \\bmod 2\\pi,\\quad\nk = 1 + \\left\\lfloor \\frac{\\theta_{\\mathrm{mod}}}{\\pi/3}\\right\\rfloor.\n$$\nWhen $V_{\\mathrm{ref}}=0$, set $k=0$ (null vector). For boundary angles at exact multiples of $\\pi/3$, the definition maps them to the higher-numbered sector except $\\theta_{\\mathrm{mod}}=0$, which maps to $k=1$.\n\n4. Dwell time derivation.\n\nOn each switching period $T_{\\mathrm{s}}$, the inverter applies at most three vectors within a sector: two adjacent active vectors $\\mathbf{V}_k,\\mathbf{V}_{k+1}$ and the zero vector $\\mathbf{0}$. The integrated voltage over $T_{\\mathrm{s}}$ must equal the reference integration:\n$$\nT_1\\,\\mathbf{V}_k + T_2\\,\\mathbf{V}_{k+1} + T_0\\,\\mathbf{0} = T_{\\mathrm{s}}\\,\\mathbf{v}_{\\mathrm{ref}},\n$$\nwith $T_1,T_2,T_0\\ge 0$ and $T_1+T_2+T_0=T_{\\mathrm{s}}$. Writing component-wise in the $\\alpha$-$\\beta$ plane yields a $2\\times 2$ linear system for $(T_1,T_2)$:\n$$\n\\begin{bmatrix}\nV_{k,\\alpha} & V_{k+1,\\alpha} \\\\\nV_{k,\\beta} & V_{k+1,\\beta}\n\\end{bmatrix}\n\\begin{bmatrix}\nT_1\\\\\nT_2\n\\end{bmatrix}\n=\n\\begin{bmatrix}\nT_{\\mathrm{s}}\\,v_\\alpha\\\\\nT_{\\mathrm{s}}\\,v_\\beta\n\\end{bmatrix}.\n$$\nSolving for $(T_1,T_2)$ gives the active dwell times, and the zero dwell time follows as $T_0=T_{\\mathrm{s}}-T_1-T_2$. Normalize to duty ratios:\n$$\nd_1 = \\frac{T_1}{T_{\\mathrm{s}}},\\quad d_2 = \\frac{T_2}{T_{\\mathrm{s}}},\\quad d_0 = \\frac{T_0}{T_{\\mathrm{s}}}.\n$$\nWe enforce $d_1,d_2,d_0\\in[0,1]$ and $d_1+d_2+d_0=1$ by clipping negative values (due to numerical rounding) to $0$ and adjusting $d_0$ accordingly. The saturation step ensures $d_1+d_2\\le 1$ in the linear region.\n\n5. Algorithm summary for each test case:\n\n- Compute $V_{\\mathrm{lim}} = V_{\\mathrm{dc}}/\\sqrt{3}$ and set $V_{\\mathrm{ref}} \\leftarrow \\min(V_{\\mathrm{ref}},V_{\\mathrm{lim}})$.\n- If $V_{\\mathrm{ref}}=0$, output $k=0$ and $(d_1,d_2,d_0)=(0,0,1)$.\n- Else compute $\\theta_{\\mathrm{mod}} = \\theta \\bmod 2\\pi$ and sector $k=1+\\left\\lfloor\\theta_{\\mathrm{mod}}/(\\pi/3)\\right\\rfloor$.\n- Compute $(v_\\alpha,v_\\beta)=(V_{\\mathrm{ref}}\\cos\\theta_{\\mathrm{mod}},\\,V_{\\mathrm{ref}}\\sin\\theta_{\\mathrm{mod}})$.\n- Construct active vectors $\\mathbf{V}_k$ and $\\mathbf{V}_{k+1}$ using the Clarke transform expressions given the switching triplets above.\n- Solve the $2\\times 2$ system for $(T_1,T_2)$, normalize $(d_1,d_2)$, set $d_0=1-d_1-d_2$, clip to $[0,1]$, and ensure $d_1+d_2+d_0=1$ (accounting for floating-point rounding).\n- Round $d_1,d_2,d_0$ to $10$ decimal places for output.\n\n6. Output specification:\n\nReturn for each test case the list $[k,d_1,d_2,d_0]$, and aggregate all into a single line formatted as a comma-separated list enclosed in square brackets, with no spaces. The duty ratios are rounded to $10$ decimal places.\n\nThis algorithm is grounded in the physical inverter model, the Clarke transform, and direct geometric decomposition of the reference vector into the adjacent basis of the hexagon, thereby avoiding reliance on shortcut trigonometric expressions and ensuring correctness through linear algebra.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef clarke_transform_vector(Vdc, s_a, s_b, s_c):\n    \"\"\"\n    Compute the alpha-beta components of the inverter space vector\n    for switching states s_a, s_b, s_c in {+1, -1} given DC bus voltage Vdc.\n    \"\"\"\n    v_a = s_a * Vdc / 2.0\n    v_b = s_b * Vdc / 2.0\n    v_c = s_c * Vdc / 2.0\n    v_alpha = (2.0/3.0) * (v_a - 0.5*v_b - 0.5*v_c)\n    v_beta  = (2.0/3.0) * ((np.sqrt(3)/2.0) * (v_b - v_c))\n    return np.array([v_alpha, v_beta], dtype=float)\n\ndef active_vectors(Vdc):\n    \"\"\"\n    Return the six active vectors (V1..V6) in alpha-beta coordinates for the given Vdc.\n    Ordered by angle: 0, 60deg, 120deg, 180deg, 240deg, 300deg.\n    Switching triplets as per problem statement.\n    \"\"\"\n    states = [\n        (+1, -1, -1),  # V1\n        (+1, +1, -1),  # V2\n        (-1, +1, -1),  # V3\n        (-1, +1, +1),  # V4\n        (-1, -1, +1),  # V5\n        (+1, -1, +1),  # V6\n    ]\n    return [clarke_transform_vector(Vdc, *st) for st in states]\n\ndef detect_sector(theta, vref_mag):\n    \"\"\"\n    Detect sector index k in {1..6} from angle theta (radians).\n    If vref_mag == 0, return k=0.\n    Boundary angles assigned to higher-numbered sector except 0->1 implicitly by floor.\n    \"\"\"\n    if vref_mag == 0.0:\n        return 0\n    two_pi = 2.0*np.pi\n    theta_mod = theta % two_pi\n    sector = int(np.floor(theta_mod / (np.pi/3.0))) + 1\n    # sector in 1..6\n    return sector\n\ndef compute_duty_ratios(Vdc, Ts, Vref, theta):\n    \"\"\"\n    Compute [sector, d1, d2, d0] for given parameters, with saturation and normalization.\n    \"\"\"\n    # Saturation to linear SVM boundary\n    Vlim = Vdc / np.sqrt(3.0)\n    Vref_sat = min(Vref, Vlim)\n\n    # Handle null vector case\n    if Vref_sat == 0.0:\n        return [0, 0.0, 0.0, 1.0]\n\n    # Angle modulo 2*pi\n    theta_mod = theta % (2.0*np.pi)\n    k = detect_sector(theta_mod, Vref_sat)\n\n    # Reference components\n    v_alpha = Vref_sat * np.cos(theta_mod)\n    v_beta = Vref_sat * np.sin(theta_mod)\n    v_ref = np.array([v_alpha, v_beta], dtype=float)\n\n    # Get adjacent active vectors for sector k\n    vecs = active_vectors(Vdc)\n    V_k = vecs[k-1]\n    V_k1 = vecs[(k % 6)]  # wrap around for k+1\n    # Construct 2x2 matrix A and RHS b = Ts*v_ref\n    A = np.column_stack((V_k, V_k1))  # shape (2,2)\n    b = Ts * v_ref\n    # Solve for T1, T2\n    try:\n        T = np.linalg.solve(A, b)\n        T1, T2 = float(T[0]), float(T[1])\n    except np.linalg.LinAlgError:\n        # Fallback in degenerate case (should not occur for valid active vectors)\n        T1, T2 = 0.0, 0.0\n\n    # Normalize to duty ratios\n    d1 = T1 / Ts\n    d2 = T2 / Ts\n    # Clip tiny negative due to numerical errors\n    eps = 1e-12\n    if d1  0.0 and d1 > -eps:\n        d1 = 0.0\n    if d2  0.0 and d2 > -eps:\n        d2 = 0.0\n    # Ensure non-negativity\n    d1 = max(0.0, d1)\n    d2 = max(0.0, d2)\n    # Compute d0 and enforce sum to 1 within numerical tolerance\n    d0 = 1.0 - d1 - d2\n    if d0  0.0 and d0 > -eps:\n        d0 = 0.0\n    # If due to numerical issues sum exceeds 1 slightly, scale d1,d2\n    sum_d = d1 + d2 + d0\n    if abs(sum_d - 1.0) > 5e-12:\n        # Normalize the trio to sum to 1 while preserving non-negativity\n        total = d1 + d2\n        if total > 1.0:\n            # Saturate zero dwell\n            d1 = d1 / total\n            d2 = d2 / total\n            d0 = 0.0\n        else:\n            d0 = 1.0 - total\n    # Round to 10 decimal places for output\n    d1 = round(d1, 10)\n    d2 = round(d2, 10)\n    d0 = round(d0, 10)\n    return [k, d1, d2, d0]\n\ndef format_result_list(results):\n    \"\"\"\n    Format the list of per-case results [[k,d1,d2,d0], ...] with no spaces\n    and floating numbers already rounded to 10 decimal places.\n    \"\"\"\n    parts = []\n    for res in results:\n        k, d1, d2, d0 = res\n        # Ensure integer for k\n        k_str = str(int(k))\n        # Floats: format with 10 decimal places\n        d1_str = f\"{d1:.10f}\"\n        d2_str = f\"{d2:.10f}\"\n        d0_str = f\"{d0:.10f}\"\n        parts.append(f\"[{k_str},{d1_str},{d2_str},{d0_str}]\")\n    return f\"[{','.join(parts)}]\"\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case is (Vdc [V], Ts [s], Vref [V], theta [rad])\n    test_cases = [\n        (600.0, 1e-4, 300.0, 0.7),               # Case 1\n        (540.0, 5e-5, 200.0, np.pi/3.0),         # Case 2\n        (700.0, 2e-4, 420.0, 5.5),               # Case 3\n        (800.0, 1e-4, 0.0, 2.0),                 # Case 4\n        (500.0, 1.5e-4, 100.0, np.pi),           # Case 5\n        (650.0, 7e-5, 150.0, -0.1),              # Case 6\n    ]\n\n    results = []\n    for Vdc, Ts, Vref, theta in test_cases:\n        res = compute_duty_ratios(Vdc, Ts, Vref, theta)\n        results.append(res)\n\n    # Final print statement in the exact required format (no spaces).\n    print(format_result_list(results))\n\nsolve()\n```"
        },
        {
            "introduction": "Moving from theory to application, this practice tackles the challenges of implementing SVM on a real-time digital platform like a DSP or FPGA. You will learn to handle practical constraints such as time quantization and minimum pulse widths, which are essential for stable and reliable hardware operation . This exercise bridges the gap between the ideal mathematical model and a robust, implementable algorithm.",
            "id": "3882579",
            "problem": "You are tasked with implementing the dwell-time computation core of Space Vector Modulation (SVM) in a digital logic context suitable for real-time on a Digital Signal Processor (DSP) or Field Programmable Gate Array (FPGA). The derivation must start from the fundamental representation of a two-level three-phase voltage source inverter and the Clarke transform, and then proceed to allocate dwell times of switching vectors within a fixed switching period under digital quantization and minimum-pulse constraints.\n\nFundamental base and setup: Consider a two-level three-phase inverter supplied by a direct current bus of voltage $V_{\\mathrm{dc}}$. Each phase pole voltage takes either $0$ or $V_{\\mathrm{dc}}$. The resultant space vectors in the $\\alpha\\beta$ plane can be constructed by the Clarke transform, defined from phase pole voltages $v_a$, $v_b$, $v_c$ as\n$$\n\\begin{bmatrix}\nv_\\alpha\\\\\nv_\\beta\n\\end{bmatrix}\n=\\frac{2}{3}\n\\begin{bmatrix}\n1  -\\frac{1}{2}  -\\frac{1}{2}\\\\\n0  \\frac{\\sqrt{3}}{2}  -\\frac{\\sqrt{3}}{2}\n\\end{bmatrix}\n\\begin{bmatrix}\nv_a\\\\\nv_b\\\\\nv_c\n\\end{bmatrix}.\n$$\nThe inverter has six nonzero active space vectors forming a regular hexagon of magnitude $\\frac{2}{3}V_{\\mathrm{dc}}$ and two zero vectors of magnitude $0$. Within each switching period $T_s$, SVM approximates a reference vector $V_{\\mathrm{ref}}$ (expressed in the $\\alpha\\beta$ plane with magnitude $|V_{\\mathrm{ref}}|$ and angle $\\theta_{\\mathrm{ref}}$) by time-averaging two adjacent active vectors and the zero vector. Sector selection divides the angle range $[0,2\\pi)$ into six sectors of width $\\frac{\\pi}{3}$ radians. In real-time implementation, when $\\theta_{\\mathrm{ref}}$ lies exactly on a sector boundary, the lower-index sector must be chosen to avoid discontinuity.\n\nTarget derivation and implementation requirements:\n- Derive, from first principles using the vector equation in the $\\alpha\\beta$ plane, the active-vector dwell times $T_1$ and $T_2$ and the zero-vector dwell time $T_0$ over a single switching period $T_s$ in terms of $V_{\\mathrm{dc}}$, $|V_{\\mathrm{ref}}|$, and $\\theta_{\\mathrm{ref}}$. The derivation must use the decomposition of $V_{\\mathrm{ref}}$ onto the two adjacent active vectors that span the sector containing $\\theta_{\\mathrm{ref}}$, with the basis defined by inverter space vectors constructed via the Clarke transform. No shortcut formulas may be assumed without derivation.\n- If the computed $T_0$ is negative (which indicates overmodulation relative to the linear hexagon), you must saturate the synthesis by proportionally scaling $T_1$ and $T_2$ so that $T_0=0$ and $T_1+T_2=T_s$, ensuring physical realizability.\n- Implement digital quantization: given a clock of frequency $f_{\\mathrm{clk}}$ in hertz, the integer dwell ticks are $N_i=\\mathrm{round}(T_i\\cdot f_{\\mathrm{clk}})$ for $i\\in\\{0,1,2\\}$, with total ticks $N_{T_s}=\\mathrm{round}(T_s\\cdot f_{\\mathrm{clk}})$. You must guarantee $N_0+N_1+N_2=N_{T_s}$ after quantization by correcting $N_0$ to be $N_{T_s}-N_1-N_2$.\n- Enforce a minimum-pulse constraint: each dwell count must satisfy $N_i\\ge N_{\\min}$, where $N_{\\min}$ is a prescribed integer minimum number of ticks. If any $N_iN_{\\min}$, redistribute ticks preferentially from the largest available dwell (favor $N_0$ if possible) to meet each $N_i\\ge N_{\\min}$ while maintaining $N_0+N_1+N_2=N_{T_s}$. Assume feasibility, i.e., $3N_{\\min}\\le N_{T_s}$.\n- Sector selection and angles must be in radians. All physical quantities must be given in specified units, and the final integer results are unitless tick counts.\n\nTest suite: Your program must hardcode and process the following four test cases, each specified as $(V_{\\mathrm{dc}},T_s,f_{\\mathrm{clk}},|V_{\\mathrm{ref}}|,\\theta_{\\mathrm{ref}},N_{\\min})$ with units and values:\n1. Case A (general): $(600\\,\\mathrm{V},\\,50\\times 10^{-6}\\,\\mathrm{s},\\,100\\times 10^{6}\\,\\mathrm{Hz},\\,200\\,\\mathrm{V},\\,0.8\\,\\mathrm{rad},\\,50)$, i.e., $V_{\\mathrm{dc}}=600$, $T_s=50\\times 10^{-6}$, $f_{\\mathrm{clk}}=100\\times 10^{6}$, $|V_{\\mathrm{ref}}|=200$, $\\theta_{\\mathrm{ref}}=0.8$, $N_{\\min}=50$.\n2. Case B (boundary angle with high amplitude near linear limit): Let $V_s=\\frac{2}{3}V_{\\mathrm{dc}}$. $(700\\,\\mathrm{V},\\,20\\times 10^{-6}\\,\\mathrm{s},\\,50\\times 10^{6}\\,\\mathrm{Hz},\\,0.99\\,V_s,\\,\\frac{\\pi}{3}\\,\\mathrm{rad},\\,10)$, i.e., $V_{\\mathrm{dc}}=700$, $T_s=20\\times 10^{-6}$, $f_{\\mathrm{clk}}=50\\times 10^{6}$, $|V_{\\mathrm{ref}}|=0.99\\cdot \\frac{2}{3}\\cdot 700$, $\\theta_{\\mathrm{ref}}=\\frac{\\pi}{3}$, $N_{\\min}=10$.\n3. Case C (very small amplitude requiring minimum-pulse enforcement): $(400\\,\\mathrm{V},\\,10\\times 10^{-6}\\,\\mathrm{s},\\,25\\times 10^{6}\\,\\mathrm{Hz},\\,1\\,\\mathrm{V},\\,0.01\\,\\mathrm{rad},\\,15)$, i.e., $V_{\\mathrm{dc}}=400$, $T_s=10\\times 10^{-6}$, $f_{\\mathrm{clk}}=25\\times 10^{6}$, $|V_{\\mathrm{ref}}|=1$, $\\theta_{\\mathrm{ref}}=0.01$, $N_{\\min}=15$.\n4. Case D (overmodulation saturating to $T_0=0$): $(800\\,\\mathrm{V},\\,40\\times 10^{-6}\\,\\mathrm{s},\\,80\\times 10^{6}\\,\\mathrm{Hz},\\,600\\,\\mathrm{V},\\,3.4\\,\\mathrm{rad},\\,100)$, i.e., $V_{\\mathrm{dc}}=800$, $T_s=40\\times 10^{-6}$, $f_{\\mathrm{clk}}=80\\times 10^{6}$, $|V_{\\mathrm{ref}}|=600$, $\\theta_{\\mathrm{ref}}=3.4$, $N_{\\min}=100$.\n\nRequired final output format: For each test case, output a list of four integers $[\\mathrm{sector},N_0,N_1,N_2]$, where $\\mathrm{sector}\\in\\{1,2,3,4,5,6\\}$ is the selected sector index, and $N_0,N_1,N_2$ are the zero-vector and two active-vector dwell ticks, respectively, satisfying the constraints above. Your program should produce a single line of output containing the results for the four cases as a comma-separated list of these lists enclosed in square brackets, with no spaces. For example: $[[s_1,N0_1,N1_1,N2_1],[s_2,N0_2,N1_2,N2_2],[s_3,N0_3,N1_3,N2_3],[s_4,N0_4,N1_4,N2_4]]$.\n\nAngles must be in radians. Physical units must be used as stated above. All numeric answers must be integers (unitless tick counts).",
            "solution": "The user has provided a valid, well-posed problem grounded in the principles of power electronics. The task is to derive and implement the core logic for Space Vector Modulation (SVM) for a two-level, three-phase inverter, including practical digital constraints. The solution proceeds by first deriving the dwell times from fundamental principles, then applying the specified saturation, quantization, and minimum-pulse-width constraints.\n\n### 1. Fundamental Principles and Space Vector Definition\n\nA two-level three-phase inverter connects each of its three output phases ($a$, $b$, $c$) to either the positive or negative rail of a DC bus of voltage $V_{\\mathrm{dc}}$. We assume the phase pole voltages ($v_a$, $v_b$, $v_c$) relative to the negative DC rail are either $0$ or $V_{\\mathrm{dc}}$. There are $2^3 = 8$ possible switching states, represented by a triplet $(S_a, S_b, S_c)$ where $S_k \\in \\{0, 1\\}$.\n\nThe stationary reference frame voltages ($v_\\alpha$, $v_\\beta$) are obtained via the Clarke transform, as provided:\n$$\n\\begin{bmatrix}\nv_\\alpha\\\\\nv_\\beta\n\\end{bmatrix}\n=\\frac{2}{3}\n\\begin{bmatrix}\n1  -\\frac{1}{2}  -\\frac{1}{2}\\\\\n0  \\frac{\\sqrt{3}}{2}  -\\frac{\\sqrt{3}}{2}\n\\end{bmatrix}\n\\begin{bmatrix}\nv_a\\\\\nv_b\\\\\nv_c\n\\end{bmatrix}\n$$\nApplying this transform to the eight switching states yields six non-zero active vectors and two zero vectors. For example, for state $(1,0,0)$, where $v_a=V_{\\mathrm{dc}}, v_b=0, v_c=0$:\n$$\nV_1 = \\begin{bmatrix}v_\\alpha\\\\v_\\beta\\end{bmatrix} = \\frac{2}{3} \\begin{bmatrix} 1  -1/2  -1/2 \\\\ 0  \\sqrt{3}/2  -\\sqrt{3}/2 \\end{bmatrix} \\begin{bmatrix}V_{\\mathrm{dc}}\\\\0\\\\0\\end{bmatrix} = \\begin{bmatrix}\\frac{2}{3}V_{\\mathrm{dc}}\\\\0\\end{bmatrix}\n$$\nIn complex representation, this is $V_1 = \\frac{2}{3}V_{\\mathrm{dc}}e^{j0}$. The other five active vectors are found similarly to be $V_k = \\frac{2}{3}V_{\\mathrm{dc}} e^{j(k-1)\\pi/3}$ for $k \\in \\{1, \\dots, 6\\}$. These vectors form a regular hexagon in the $\\alpha\\beta$ plane. The two zero vectors, $V_0$ (from state $(0,0,0)$) and $V_7$ (from state $(1,1,1)$), lie at the origin.\n\n### 2. Dwell Time Derivation\n\nThe core of SVM is to synthesize a desired reference voltage vector, $V_{\\mathrm{ref}}$, by time-averaging three stationary vectors over a switching period $T_s$. The three vectors chosen are the two adjacent active vectors that bound the sector containing $V_{\\mathrm{ref}}$ and one of the zero vectors.\n\nThe principle of volt-second balancing states that the product of the reference vector and the switching period must equal the sum of the products of the applied vectors and their respective dwell times ($T_1, T_2, T_0$):\n$$\nV_{\\mathrm{ref}} T_s = V_k T_1 + V_{k+1} T_2 + V_0 T_0\n$$\nThe sum of dwell times must equal the switching period: $T_s = T_1 + T_2 + T_0$.\nSince $V_0$ is the zero vector, the first equation simplifies to:\n$$\nV_{\\mathrm{ref}} T_s = V_k T_1 + V_{k+1} T_2\n$$\nTo solve for $T_1$ and $T_2$, we project this vector equation onto a convenient basis. A coordinate system is chosen that is rotated by an angle $\\phi = (k-1)\\pi/3$, where $k$ is the sector index ($k \\in \\{1, \\dots, 6\\}$). In this rotated frame, the first active vector $V'_k = V_k e^{-j\\phi}$ lies on the real axis. Let $\\theta'$ be the angle of $V_{\\mathrm{ref}}$ within this new frame, so $\\theta' = \\theta_{\\mathrm{ref}} - \\phi$. The vector equation becomes:\n$$\nV'_{\\mathrm{ref}} T_s = V'_k T_1 + V'_{k+1} T_2\n$$\nwhere $V'_{\\mathrm{ref}} = |V_{\\mathrm{ref}}|e^{j\\theta'}$, $V'_k = \\frac{2}{3}V_{\\mathrm{dc}}$, and $V'_{k+1} = \\frac{2}{3}V_{\\mathrm{dc}}e^{j\\pi/3}$. Substituting these complex values:\n$$\n|V_{\\mathrm{ref}}| T_s (\\cos\\theta' + j\\sin\\theta') = \\left(\\frac{2}{3}V_{\\mathrm{dc}}\\right) T_1 + \\left(\\frac{2}{3}V_{\\mathrm{dc}}\\left(\\cos\\frac{\\pi}{3} + j\\sin\\frac{\\pi}{3}\\right)\\right) T_2\n$$\n$$\n|V_{\\mathrm{ref}}| T_s (\\cos\\theta' + j\\sin\\theta') = \\left(\\frac{2}{3}V_{\\mathrm{dc}}\\right) T_1 + \\left(\\frac{2}{3}V_{\\mathrm{dc}}\\left(\\frac{1}{2} + j\\frac{\\sqrt{3}}{2}\\right)\\right) T_2\n$$\nEquating the imaginary and real parts:\n$$\n\\text{(Imaginary)}: \\quad |V_{\\mathrm{ref}}| T_s \\sin\\theta' = \\left(\\frac{2}{3}V_{\\mathrm{dc}}\\right)\\left(\\frac{\\sqrt{3}}{2}\\right)T_2 = \\frac{V_{\\mathrm{dc}}}{\\sqrt{3}}T_2 \\implies T_2 = \\frac{\\sqrt{3}|V_{\\mathrm{ref}}|T_s}{V_{\\mathrm{dc}}}\\sin\\theta'\n$$\n$$\n\\text{(Real)}: \\quad |V_{\\mathrm{ref}}| T_s \\cos\\theta' = \\frac{2}{3}V_{\\mathrm{dc}}T_1 + \\frac{1}{3}V_{\\mathrm{dc}}T_2\n$$\nSubstituting $T_2$ into the real part equation:\n$$\n\\frac{2}{3}V_{\\mathrm{dc}}T_1 = |V_{\\mathrm{ref}}| T_s \\cos\\theta' - \\frac{1}{3}V_{\\mathrm{dc}}\\left(\\frac{\\sqrt{3}|V_{\\mathrm{ref}}|T_s}{V_{\\mathrm{dc}}}\\sin\\theta'\\right) = |V_{\\mathrm{ref}}| T_s \\left(\\cos\\theta' - \\frac{\\sin\\theta'}{\\sqrt{3}}\\right)\n$$\n$$\nT_1 = \\frac{3|V_{\\mathrm{ref}}|T_s}{2V_{\\mathrm{dc}}} \\frac{2}{\\sqrt{3}}\\left(\\frac{\\sqrt{3}}{2}\\cos\\theta' - \\frac{1}{2}\\sin\\theta'\\right) = \\frac{\\sqrt{3}|V_{\\mathrm{ref}}|T_s}{V_{\\mathrm{dc}}} \\sin\\left(\\frac{\\pi}{3} - \\theta'\\right)\n$$\nThe zero-vector dwell time is then $T_0 = T_s - T_1 - T_2$.\n\n### 3. Implementation Logic\n\nThe full implementation algorithm incorporates the derived formulas and the constraints specified in the problem statement.\n\n1.  **Sector Identification**: The angle $\\theta_{\\mathrm{ref}}$ is normalized to $[0, 2\\pi)$. The sector index $k \\in \\{1, ..., 6\\}$ is determined. The sector $k$ spans the angular region $[(k-1)\\pi/3, k\\pi/3)$. The problem dictates that if $\\theta_{\\mathrm{ref}}$ falls on a boundary, the lower-index sector is chosen. This is handled by flooring the normalized angle `theta_ref/(pi/3)` and applying a correction for exact integer results.\n\n2.  **Dwell Time Calculation**: Using the sector index $k$ and the angle within the sector $\\theta' = \\theta_{\\mathrm{ref}} - (k-1)\\pi/3$, the ideal dwell times $T_1$ and $T_2$ are computed with the derived formulas.\n\n3.  **Overmodulation Handling**: If the calculated $T_0 = T_s - T_1 - T_2$ is negative, the reference vector is outside the hexagon of achievable voltages (overmodulation). The active times $T_1$ and $T_2$ are scaled down proportionally to fit within $T_s$, such that their sum is exactly $T_s$. This sets $T_0$ to zero. The new times are $T'_1 = T_1 \\frac{T_s}{T_1+T_2}$ and $T'_2 = T_2 \\frac{T_s}{T_1+T_2}$.\n\n4.  **Digital Quantization**: The continuous-time dwell durations are converted to integer clock ticks. $N_{T_s} = \\mathrm{round}(T_s \\cdot f_{\\mathrm{clk}})$. The active vector ticks are $N_1 = \\mathrm{round}(T_1 \\cdot f_{\\mathrm{clk}})$ and $N_2 = \\mathrm{round}(T_2 \\cdot f_{\\mathrm{clk}})$. To ensure the sum of ticks is conserved, the zero-vector ticks are calculated as a remainder: $N_0 = N_{T_s} - N_1 - N_2$.\n\n5.  **Minimum Pulse Constraint**: To prevent very short pulses that are problematic for hardware, each tick count $N_i$ must be at least $N_{\\min}$. If any $N_i  N_{\\min}$, a redistribution algorithm is applied:\n    a. Deficits are calculated for each pulse: $\\Delta_i = \\max(0, N_{\\min} - N_i)$.\n    b. The total deficit is summed, $\\Delta_{\\mathrm{total}} = \\sum \\Delta_i$.\n    c. Each pulse count is provisionally increased by its deficit: $N'_i = N_i + \\Delta_i$.\n    d. The total deficit $\\Delta_{\\mathrm{total}}$ must be subtracted from the \"donor\" pulses (those originally satisfying $N_i \\ge N_{\\min}$).\n    e. The donors are sorted according to the rule: \"preferentially from the largest available dwell (favor $N_0$ if possible)\". This is implemented by sorting donor indices based on their original tick count $N_i$ in descending order, with index $0$ used as a tie-breaker.\n    f. The algorithm iterates through the sorted donors, subtracting from each the required amount until the total deficit is compensated, while ensuring no donor's count falls below $N_{\\min}$. The problem guarantees this is always possible as $3N_{\\min} \\le N_{T_s}$.\n\nThis structured approach ensures that all physical and digital constraints are met, yielding a practical implementation of the SVM core.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the SVM problem for the given test cases.\n    \"\"\"\n\n    def calculate_svm_ticks(V_dc, T_s, f_clk, V_ref_mag, theta_ref, N_min):\n        \"\"\"\n        Calculates SVM dwell time ticks for a given set of parameters,\n        following the derivation and constraints.\n        \"\"\"\n        # Step 1: Normalize theta_ref to [0, 2*pi)\n        theta_ref_norm = theta_ref % (2 * np.pi)\n\n        # Step 2: Determine sector\n        # The problem states: \"when theta_ref lies exactly on a sector boundary,\n        # the lower-index sector must be chosen\".\n        angle_norm_units = theta_ref_norm / (np.pi / 3)\n        \n        sector_idx = np.floor(angle_norm_units)\n\n        # Boundary condition: if angle is an integer multiple of pi/3 (and not 0),\n        # it belongs to the boundary, so we select the lower-index sector by\n        # decrementing the calculated index. A small tolerance is used for float comparison.\n        if angle_norm_units > 1e-9 and np.isclose(angle_norm_units, np.round(angle_norm_units)):\n            sector_idx = np.round(angle_norm_units) - 1\n        \n        # Handle the edge case where angle is 2*pi, which normalizes to 0, but\n        # a calculated index could be 6. The sectors are 1-6 (indices 0-5).\n        if sector_idx >= 6:\n            sector_idx = 5\n        \n        sector = int(sector_idx) + 1\n\n        # Step 3: Calculate angle within the sector\n        theta_prime = theta_ref_norm - sector_idx * (np.pi / 3)\n\n        # Step 4: Calculate ideal dwell times based on the derived formulas\n        # T1 is the dwell time for the first active vector of the sector.\n        # T2 is the dwell time for the second active vector of the sector.\n        common_factor = (np.sqrt(3) * V_ref_mag * T_s) / V_dc\n        T1 = common_factor * np.sin(np.pi/3 - theta_prime)\n        T2 = common_factor * np.sin(theta_prime)\n\n        # Step 5: Calculate T0 and check for overmodulation\n        T0 = T_s - T1 - T2\n\n        # Step 6: Handle overmodulation by saturating the dwell times\n        if T0  0:\n            T_sum_active = T1 + T2\n            if T_sum_active > 1e-12:  # Avoid division by zero\n                scale_factor = T_s / T_sum_active\n                T1 *= scale_factor\n                T2 *= scale_factor\n            else: # Should not happen in valid cases, but for robustness\n                T1 = T_s / 2.0\n                T2 = T_s / 2.0\n            T0 = 0.0\n\n        # Step 7: Perform digital quantization\n        N_Ts = int(np.round(T_s * f_clk))\n        N1 = int(np.round(T1 * f_clk))\n        N2 = int(np.round(T2 * f_clk))\n        # N0 is calculated as the remainder to conserve the total ticks\n        N0 = N_Ts - N1 - N2\n        \n        N = [N0, N1, N2]\n\n        # Step 8: Enforce the minimum pulse constraint\n        deficits = [max(0, N_min - val) for val in N]\n        total_deficit = sum(deficits)\n        \n        if total_deficit > 0:\n            # Create adjusted counts by raising all sub-minimum pulses to N_min\n            N_adj = [val + d for val, d in zip(N, deficits)]\n            \n            amount_to_reduce = total_deficit\n            \n            # Identify donor pulses (those that were originally >= N_min)\n            donor_indices = [i for i, d in enumerate(deficits) if d == 0]\n            \n            # Sort donors: largest first, with N0 as tie-breaker for the \"favor N0\" rule.\n            # This is achieved by sorting using a tuple key (-N[i], i).\n            sorted_donors = sorted(donor_indices, key=lambda i: (-N[i], i))\n            \n            for i in sorted_donors:\n                if amount_to_reduce = 0:\n                    break\n                \n                # Max amount we can take from this pulse without violating its own N_min\n                can_reduce = N_adj[i] - N_min\n                \n                # Actual reduction is the minimum of what's needed and what's available\n                reduction = min(amount_to_reduce, can_reduce)\n                \n                N_adj[i] -= reduction\n                amount_to_reduce -= reduction\n            \n            N_final = N_adj\n        else:\n            N_final = N\n            \n        return [sector, N_final[0], N_final[1], N_final[2]]\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A: General case\n        (600, 50e-6, 100e6, 200, 0.8, 50),\n        # Case B: Boundary angle with high amplitude\n        (700, 20e-6, 50e6, 0.99 * (2/3) * 700, np.pi/3, 10),\n        # Case C: Very small amplitude requiring minimum pulse enforcement\n        (400, 10e-6, 25e6, 1, 0.01, 15),\n        # Case D: Overmodulation\n        (800, 40e-6, 80e6, 600, 3.4, 100),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = calculate_svm_ticks(*case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    formatted_results = [f\"[{s},{n0},{n1},{n2}]\" for s, n0, n1, n2 in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "This final practice focuses on optimizing the performance of your SVM implementation, a critical step in designing efficient power converters. You will develop a strategy to select a switching sequence that minimizes switching losses, a major source of inefficiency in inverters . Furthermore, you will quantify the resulting common-mode voltage, gaining insight into a key factor affecting motor bearing life and electromagnetic interference.",
            "id": "3837777",
            "problem": "You are given a two-level, three-phase Voltage Source Inverter (VSI) driving an electric machine under Space Vector Modulation (SVM). The inverter legs are modeled as ideal switches connected to a Direct Current (DC) bus of voltage $V_{\\mathrm{dc}}$. Each leg $x \\in \\{a,b,c\\}$ has a binary switching state $S_x \\in \\{0,1\\}$, where $S_x=1$ denotes the upper device on and $S_x=0$ denotes the lower device on. The leg pole voltage relative to the DC bus midpoint is $v_{xN} = (2 S_x - 1)\\, V_{\\mathrm{dc}}/2$. The phase terminal voltages $v_a$, $v_b$, and $v_c$ relative to the machine star point satisfy $v_x = v_{xN} - v_{\\mathrm{cm}}$, where the common-mode voltage $v_{\\mathrm{cm}}$ is defined as $v_{\\mathrm{cm}} = (v_{aN} + v_{bN} + v_{cN})/3$. \n\nYou are tasked to compute, for a desired reference stator voltage space-vector trajectory over one switching period, a switching sequence that minimizes the total number of switching transitions, and to quantify the resulting common-mode voltage. The trajectory is specified by the space-vector magnitude $V_{\\mathrm{ref}}$ and electrical angle $\\theta$ in radians; the DC bus voltage $V_{\\mathrm{dc}}$ and switching period $T_s$ are also given. The initial condition is the inverter’s previous end state $s_{\\mathrm{prev}}$, encoded as an integer $s \\in \\{0,1,2,\\dots,7\\}$ with the mapping $s = 4 S_a + 2 S_b + S_c$, where $S_a$, $S_b$, and $S_c$ are the leg states for phases $a$, $b$, and $c$, respectively.\n\nFundamental base and constraints to be used:\n- The Clarke transformation and space-vector representation reduce the three-phase voltages to an $\\alpha\\beta$-plane vector. The feasible inverter space vectors are the six nonzero active vectors of equal magnitude at angles separated by $ \\pi/3 $ radians, and two zero vectors at the origin. \n- Over one switching period $T_s$, the desired average reference vector is produced by dwelling on two adjacent active vectors and possibly the zero vector. Let the sector be the set of angles between two adjacent active vectors. For a desired $V_{\\mathrm{ref}}$ with angle $\\theta$ inside a sector, the two dwell times $T_1$ and $T_2$ for the adjacent active vectors and the remaining zero-vector time $T_0=T_s - T_1 - T_2$ must be derived from first principles by resolving the vector average equation in the $\\alpha\\beta$ plane. No shortcut or pre-tabulated formula may be used in the derivation; you must derive from the geometry and the leg-voltage model stated above.\n- The common-mode voltage levels during each switching state must be determined from $v_{\\mathrm{cm}} = (v_{aN} + v_{bN} + v_{cN})/3$. You must quantify the Root Mean Square (RMS) of the common-mode voltage over the switching period as $V_{\\mathrm{cm,RMS}} = \\sqrt{\\left( \\sum_i t_i\\, v_{\\mathrm{cm},i}^2\\right) / T_s }$, where $t_i$ and $v_{\\mathrm{cm},i}$ are the dwell time and common-mode voltage during the $i$-th subinterval.\n- The switching sequence over one period is restricted to four subintervals in order: start at a zero vector, then dwell on the first active vector, then the second active vector, and finally end at a zero vector. The two active vectors must be the adjacent ones in the identified sector. The zero vector can be either $s=0$ (all lower devices on) or $s=7$ (all upper devices on). The total zero-vector dwell $T_0$ must be split equally at the beginning and end, so each zero-vector subinterval has duration $T_0/2$. Among all such candidate sequences formed by choosing the zero vectors (start and end) and the order of the two active vectors, select the one that minimizes the total number of switching transitions. The total number of transitions is the sum, over all consecutive pairs of states in the period (including the transition from the previous end state $s_{\\mathrm{prev}}$ to the starting zero vector), of the Hamming distance between the three leg-state bits.\n- Angles must be in radians. All voltage answers must be expressed in volts, and time in seconds.\n\nTest suite and required output:\n- Implement a program that, for each test case $(V_{\\mathrm{dc}}, T_s, V_{\\mathrm{ref}}, \\theta, s_{\\mathrm{prev}})$, computes:\n    $1)$ the selected four-state switching sequence as a list of integers $[s_1,s_2,s_3,s_4]$ using the encoding $s = 4 S_a + 2 S_b + S_c$, and\n    $2)$ the common-mode voltage RMS $V_{\\mathrm{cm,RMS}}$ over the switching period in volts.\n- Use the following test cases, each tuple $(V_{\\mathrm{dc}}, T_s, V_{\\mathrm{ref}}, \\theta, s_{\\mathrm{prev}})$:\n    $1)$ $(600,\\; 1.0\\times 10^{-4},\\; 200,\\; 0.3,\\; 0)$,\n    $2)$ $(600,\\; 1.0\\times 10^{-4},\\; 330,\\; \\pi/3 - 10^{-6},\\; 7)$,\n    $3)$ $(600,\\; 1.0\\times 10^{-4},\\; 1,\\; 2.0,\\; 3)$,\n    $4)$ $(600,\\; 1.0\\times 10^{-4},\\; 340,\\; 4.2,\\; 2)$.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each result is a two-element list $[\\,[s_1,s_2,s_3,s_4],\\; V_{\\mathrm{cm,RMS}}\\,]$. For example: $[[[s_1,s_2,s_3,s_4],V_1],[[...],V_2],...]$. The numeric values must be floats or integers, with the RMS expressed in volts.\n\nYour implementation must be fully self-contained, must not read any input, and must not use any external files or network access. Derivations must be based on the leg-voltage model and space-vector geometry stated above and must avoid shortcut formulas in the problem statement.",
            "solution": "The provided problem is valid as it is scientifically grounded in the principles of power electronics and electric motor control, specifically Space Vector Modulation (SVM). The problem is well-posed, objective, and contains all necessary information to derive a unique solution. The numerical values are within realistic ranges for a voltage source inverter drive system. I will proceed with a full derivation and solution.\n\nThe solution process involves several steps:\n1.  Derivation of the inverter's space voltage vectors from the given leg voltage model.\n2.  Derivation of the dwell times for the SVM algorithm from first principles.\n3.  Formulation of the optimization problem to select a switching sequence that minimizes switching transitions.\n4.  Derivation of the Root Mean Square (RMS) common-mode voltage.\n5.  Application of this methodology to the provided test cases.\n\n**1. Inverter Space Vectors**\n\nA two-level three-phase inverter has $2^3 = 8$ possible switching states, defined by the triplet $(S_a, S_b, S_c)$, where $S_x \\in \\{0, 1\\}$. The state is encoded as an integer $s = 4S_a + 2S_b + S_c$. The voltage of each leg's pole with respect to the DC bus midpoint is given by $v_{xN} = (S_x - 1/2)V_{\\mathrm{dc}}$.\n\nThe three-phase voltages are transformed into a two-dimensional space vector $\\mathbf{v} = v_\\alpha + j v_\\beta$ using the amplitude-invariant Clarke transformation:\n$$ v_\\alpha = \\frac{2}{3}(v_{aN} - \\frac{1}{2}v_{bN} - \\frac{1}{2}v_{cN}) $$\n$$ v_\\beta = \\frac{2}{3}\\frac{\\sqrt{3}}{2}(v_{bN} - v_{cN}) = \\frac{1}{\\sqrt{3}}(v_{bN} - v_{cN}) $$\nSubstituting the expression for $v_{xN}$:\n$$ v_\\alpha = \\frac{2}{3} V_{\\mathrm{dc}} \\left[ (S_a - \\frac{1}{2}) - \\frac{1}{2}(S_b - \\frac{1}{2}) - \\frac{1}{2}(S_c - \\frac{1}{2}) \\right] = \\frac{V_{\\mathrm{dc}}}{3} (2S_a - S_b - S_c) $$\n$$ v_\\beta = \\frac{V_{\\mathrm{dc}}}{\\sqrt{3}} \\left[ (S_b - \\frac{1}{2}) - (S_c - \\frac{1}{2}) \\right] = \\frac{V_{\\mathrm{dc}}}{\\sqrt{3}} (S_b - S_c) $$\nUsing these formulae, the 8 states produce 8 voltage vectors. States $s=0$ $(000)$ and $s=7$ $(111)$ result in zero vectors ($\\mathbf{V}_0 = \\mathbf{V}_7 = 0$). The other 6 states produce active vectors of magnitude $\\frac{2}{3}V_{\\mathrm{dc}}$, with angles separated by $\\pi/3$ radians, forming a hexagon in the $\\alpha\\beta$ plane. The standard active vectors and their corresponding states are:\n- $\\mathbf{V}_1$ (state $s=4, 100$): angle $0$\n- $\\mathbf{V}_2$ (state $s=6, 110$): angle $\\pi/3$\n- $\\mathbf{V}_3$ (state $s=2, 010$): angle $2\\pi/3$\n- $\\mathbf{V}_4$ (state $s=3, 011$): angle $\\pi$\n- $\\mathbf{V}_5$ (state $s=1, 001$): angle $4\\pi/3$\n- $\\mathbf{V}_6$ (state $s=5, 101$): angle $5\\pi/3$\n\n**2. Dwell Time Derivation from First Principles**\n\nSVM synthesizes a reference voltage vector $\\mathbf{V}_{\\mathrm{ref}} = V_{\\mathrm{ref}} e^{j\\theta}$ by averaging two adjacent active vectors and a zero vector over a switching period $T_s$. The averaging principle is:\n$$ \\mathbf{V}_{\\mathrm{ref}} = \\frac{1}{T_s}(T_1 \\mathbf{V}_k + T_2 \\mathbf{V}_{k+1} + T_0 \\mathbf{V}_{\\mathrm{zero}}) $$\nwhere $\\mathbf{V}_k$ and $\\mathbf{V}_{k+1}$ are the two active vectors bounding the sector containing $\\mathbf{V}_{\\mathrm{ref}}$, and $T_1$, $T_2$ are their respective dwell times. $T_0$ is the total dwell time for the zero vector. Since $\\mathbf{V}_{\\mathrm{zero}}=0$, the equation simplifies to $T_s \\mathbf{V}_{\\mathrm{ref}} = T_1 \\mathbf{V}_k + T_2 \\mathbf{V}_{k+1}$. The total time is constrained by $T_s = T_1 + T_2 + T_0$.\n\nTo solve for $T_1$ and $T_2$, we project the vector equation onto an orthogonal basis. We define a coordinate system with its u-axis aligned with the first active vector, $\\mathbf{V}_k$. Let the sector index be $k_{sec} \\in \\{0, \\dots, 5\\}$, such that $\\mathbf{V}_{\\mathrm{ref}}$ lies between the vector at angle $k_{sec}\\pi/3$ and $(k_{sec}+1)\\pi/3$. The angle of $\\mathbf{V}_{\\mathrm{ref}}$ within the sector is $\\theta' = \\theta - k_{sec}\\pi/3$.\nIn this rotated frame, the vectors are:\n- $\\mathbf{V}_{\\mathrm{ref}}$: $(V_{\\mathrm{ref}} \\cos \\theta', V_{\\mathrm{ref}} \\sin \\theta')$\n- $\\mathbf{V}_k$: $(V_s, 0)$, where $V_s = \\frac{2}{3}V_{\\mathrm{dc}}$ is the magnitude of active vectors.\n- $\\mathbf{V}_{k+1}$: $(V_s \\cos(\\pi/3), V_s \\sin(\\pi/3)) = (V_s/2, V_s \\sqrt{3}/2)$\n\nThe vector equation decomposes into two scalar equations:\n$$ T_s V_{\\mathrm{ref}} \\cos \\theta' = T_1 V_s + T_2 (V_s/2) $$\n$$ T_s V_{\\mathrm{ref}} \\sin \\theta' = T_2 (V_s \\sqrt{3}/2) $$\nFrom the second equation, we solve for $T_2$:\n$$ T_2 = \\frac{2 T_s V_{\\mathrm{ref}} \\sin \\theta'}{V_s \\sqrt{3}} = \\frac{2 T_s V_{\\mathrm{ref}} \\sin \\theta'}{(\\frac{2}{3}V_{\\mathrm{dc}}) \\sqrt{3}} = \\frac{\\sqrt{3} T_s V_{\\mathrm{ref}}}{V_{\\mathrm{dc}}} \\sin(\\theta') $$\nSubstituting $T_2$ into the first equation to find $T_1$:\n$$ T_1 = \\frac{T_s V_{\\mathrm{ref}} \\cos \\theta'}{V_s} - \\frac{T_2}{2} = \\frac{T_s V_{\\mathrm{ref}}}{V_s} \\left( \\cos \\theta' - \\frac{\\sin \\theta'}{\\sqrt{3}} \\right) = \\frac{T_s V_{\\mathrm{ref}}}{V_s} \\frac{2}{\\sqrt{3}} \\sin(\\pi/3 - \\theta') $$\n$$ T_1 = \\frac{T_s V_{\\mathrm{ref}}}{(\\frac{2}{3}V_{\\mathrm{dc}})} \\frac{2}{\\sqrt{3}} \\sin(\\pi/3 - \\theta') = \\frac{\\sqrt{3} T_s V_{\\mathrm{ref}}}{V_{\\mathrm{dc}}} \\sin(\\pi/3 - \\theta') $$\nThe remaining time is the zero-vector time, $T_0 = T_s - T_1 - T_2$. If $V_{\\mathrm{ref}}$ exceeds the linear modulation range ($T_1+T_2 > T_s$), the dwell times are scaled to saturate at $T_s$, resulting in $T_0=0$.\n\n**3. Optimal Switching Sequence**\n\nThe switching sequence is structured as four segments: zero vector, first active vector, second active vector, zero vector. The total zero time $T_0$ is split evenly, so the durations are $(T_0/2, T_{act1}, T_{act2}, T_0/2)$. We must choose the start/end zero vectors ($s_{z1}, s_{z2} \\in \\{0, 7\\}$) and the order of active vectors ($s_{act1}, s_{act2}$) to minimize the total number of switching transitions. The cost is the sum of Hamming distances between consecutive states, starting from the previous state $s_{\\mathrm{prev}}$:\n$$ \\mathrm{Cost} = H(s_{\\mathrm{prev}}, s_{z1}) + H(s_{z1}, s_{act1}) + H(s_{act1}, s_{act2}) + H(s_{act2}, s_{z2}) $$\nThe Hamming distance $H(s_i, s_j)$ is the number of differing bits in the binary representations of $s_i$ and $s_j$. Since adjacent active vectors differ by only one bit, $H(s_{act1}, s_{act2})=1$. There are 8 candidate sequences for each operating point, formed by choosing $s_{z1} \\in \\{0,7\\}$, $s_{z2} \\in \\{0,7\\}$, and the order of active vectors. We evaluate the cost for all 8 candidates and select the sequence with the minimum cost.\n\n**4. RMS Common-Mode Voltage**\n\nThe common-mode voltage for a switching state $s=(S_a,S_b,S_c)$ is:\n$$ v_{\\mathrm{cm}}(s) = \\frac{v_{aN} + v_{bN} + v_{cN}}{3} = \\frac{1}{3} \\sum_{x \\in \\{a,b,c\\}} (S_x - \\frac{1}{2})V_{\\mathrm{dc}} = \\frac{V_{\\mathrm{dc}}}{6} (2(S_a+S_b+S_c) - 3) $$\nLet $p(s) = S_a+S_b+S_c$ be the population count of the state's binary representation. Then $v_{\\mathrm{cm}}(s) = \\frac{V_{\\mathrm{dc}}}{6} (2p(s) - 3)$. The possible values for $v_{\\mathrm{cm}}^2$ are:\n- Zero vectors ($s=0, p=0$ or $s=7, p=3$): $v_{\\mathrm{cm}}(0) = -V_{\\mathrm{dc}}/2$, $v_{\\mathrm{cm}}(7) = +V_{\\mathrm{dc}}/2$. So $v_{\\mathrm{cm}}^2 = V_{\\mathrm{dc}}^2/4$.\n- Active vectors (p=1 or p=2): $v_{\\mathrm{cm}}(p=1)=-V_{\\mathrm{dc}}/6$, $v_{\\mathrm{cm}}(p=2)=+V_{\\mathrm{dc}}/6$. So $v_{\\mathrm{cm}}^2 = V_{\\mathrm{dc}}^2/36$.\n\nThe RMS value over the four-segment period $[s_1, s_2, s_3, s_4]$ with durations $[T_0/2, T_{act1}, T_{act2}, T_0/2]$ is:\n$$ V_{\\mathrm{cm,RMS}}^2 = \\frac{1}{T_s} \\left[ \\frac{T_0}{2} v_{\\mathrm{cm}}(s_1)^2 + T_{act1} v_{\\mathrm{cm}}(s_2)^2 + T_{act2} v_{\\mathrm{cm}}(s_3)^2 + \\frac{T_0}{2} v_{\\mathrm{cm}}(s_4)^2 \\right] $$\nSince the squared common-mode voltage is the same for both zero vectors, and for any pair of adjacent active vectors (one has $p=1$, the other $p=2$), the expression simplifies regardless of the chosen sequence:\n$$ V_{\\mathrm{cm,RMS}}^2 = \\frac{1}{T_s} \\left[ T_0 \\left(\\frac{V_{\\mathrm{dc}}^2}{4}\\right) + (T_1+T_2)\\left(\\frac{V_{\\mathrm{dc}}^2}{36}\\right) \\right] $$\nUsing $T_1+T_2 = T_s-T_0$:\n$$ V_{\\mathrm{cm,RMS}}^2 = \\frac{V_{\\mathrm{dc}}^2}{T_s} \\left[ \\frac{T_0}{4} + \\frac{T_s-T_0}{36} \\right] = \\frac{V_{\\mathrm{dc}}^2}{36 T_s} [9T_0 + T_s - T_0] = \\frac{V_{\\mathrm{dc}}^2}{36 T_s} [8T_0 + T_s] $$\n$$ V_{\\mathrm{cm,RMS}} = \\frac{V_{\\mathrm{dc}}}{6} \\sqrt{8 \\frac{T_0}{T_s} + 1} $$\nThis shows that $V_{\\mathrm{cm,RMS}}$ depends only on the DC link voltage and the fraction of the switching period spent in a zero state.\n\n**5. Algorithm and Implementation**\n\nThe algorithm proceeds as follows for each test case:\n1.  Normalize the input angle $\\theta$ to the range $[0, 2\\pi)$.\n2.  Determine the sector index $k_{sec} = \\lfloor \\theta / (\\pi/3) \\rfloor$.\n3.  Identify the two adjacent active states, $S_u$ and $S_v$, for this sector.\n4.  Calculate the angle within the sector, $\\theta' = \\theta - k_{sec}\\pi/3$.\n5.  Compute the dwell times $T_1$ (for $S_u$) and $T_2$ (for $S_v$). Handle saturation if $T_1+T_2 > T_s$ by scaling them proportionally so their sum is $T_s$.\n6.  Calculate the total zero time $T_0 = T_s - T_1 - T_2$.\n7.  Generate all 8 candidate switching sequences. For each sequence, calculate the total switching cost (sum of Hamming distances).\n8.  Select the sequence with the minimum cost. In case of a tie, the first one found is chosen.\n9.  Calculate $V_{\\mathrm{cm,RMS}}$ using the derived formula with the final $T_0$.\n10. Store the optimal sequence and the calculated $V_{\\mathrm{cm,RMS}}$.\nThis procedure is implemented in the provided Python code.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the SVM problem for a two-level VSI for a given set of test cases.\n    It computes the optimal switching sequence and the RMS common-mode voltage.\n    \"\"\"\n\n    test_cases = [\n        (600, 1.0e-4, 200, 0.3, 0),\n        (600, 1.0e-4, 330, np.pi/3 - 1e-6, 7),\n        (600, 1.0e-4, 1, 2.0, 3),\n        (600, 1.0e-4, 340, 4.2, 2)\n    ]\n    \n    # Active voltage vectors states keyed by sector index (0-5)\n    # The states correspond to vectors at k*pi/3 and (k+1)*pi/3\n    active_states_by_sector = {\n        0: (4, 6),  # Sector 1: 0 to pi/3\n        1: (6, 2),  # Sector 2: pi/3 to 2pi/3\n        2: (2, 3),  # Sector 3: 2pi/3 to pi\n        3: (3, 1),  # Sector 4: pi to 4pi/3\n        4: (1, 5),  # Sector 5: 4pi/3 to 5pi/3\n        5: (5, 4)   # Sector 6: 5pi/3 to 2pi\n    }\n    \n    def hamming_distance(n1, n2):\n        \"\"\"Calculates the Hamming distance between two integers.\"\"\"\n        return bin(n1 ^ n2).count('1')\n\n    results = []\n    for V_dc, T_s, V_ref, theta, s_prev in test_cases:\n        # Step 1: Normalize angle and find sector\n        theta_norm = np.fmod(theta, 2 * np.pi)\n        if theta_norm  0:\n            theta_norm += 2 * np.pi\n        \n        # Handle edge case where theta is exactly 2*pi\n        if np.isclose(theta_norm, 2 * np.pi):\n            sector_idx = 0\n        else:\n            sector_idx = int(theta_norm / (np.pi / 3))\n\n        theta_prime = theta_norm - sector_idx * np.pi / 3\n\n        # Step 2: Calculate dwell times\n        # The constants are derived from the first-principles derivation\n        a = (np.sqrt(3) * T_s * V_ref) / V_dc\n        \n        # T1 is for the first vector of the sector, T2 for the second\n        T1 = a * np.sin(np.pi/3 - theta_prime)\n        T2 = a * np.sin(theta_prime)\n\n        # Step 3: Handle overmodulation (saturation)\n        if T1 + T2 > T_s:\n            T_total_active = T1 + T2\n            T1 = T1 * T_s / T_total_active\n            T2 = T2 * T_s / T_total_active\n        \n        T0 = T_s - (T1 + T2)\n        # Ensure T0 is not negative due to floating point inaccuracies\n        T0 = max(0, T0)\n\n        # Step 4: Find optimal switching sequence\n        S_u, S_v = active_states_by_sector[sector_idx]\n        zero_vectors = [0, 7]\n        best_sequence = []\n        min_cost = float('inf')\n\n        # There are 8 candidate sequences to check\n        # (start_zero, active_1, active_2, end_zero)\n        candidates = []\n        for z1 in zero_vectors:\n            for z2 in zero_vectors:\n                # Two possible orderings for active vectors\n                candidates.append((z1, S_u, S_v, z2))\n                candidates.append((z1, S_v, S_u, z2))\n\n        for seq in candidates:\n            s1, s2, s3, s4 = seq\n            cost = (hamming_distance(s_prev, s1) +\n                    hamming_distance(s1, s2) +\n                    hamming_distance(s2, s3) +\n                    hamming_distance(s3, s4))\n            \n            if cost  min_cost:\n                min_cost = cost\n                best_sequence = list(seq)\n        \n        # Step 5: Calculate RMS common-mode voltage\n        # V_cm_rms = (V_dc/6) * sqrt(8 * (T0/T_s) + 1)\n        V_cm_rms = (V_dc / 6.0) * np.sqrt(8 * (T0 / T_s) + 1)\n        \n        # Format the result for this test case\n        # Note: The problem asks for numeric values, but to avoid float precision issues in\n        # the final string and match the example format, we create a string representation.\n        # However, the output requested is a list of lists of numbers. The final output\n        # string is built from Python objects directly.\n        results.append([best_sequence, V_cm_rms])\n\n    # Print a single line of output with all results\n    # Formatting to match the specific example format string `[[[s1,s2,s3,s4],V1],[[...],V2],...]`\n    output_str = \"[\" + \",\".join([f\"[{item[0]},{item[1]}]\" for item in results]) + \"]\"\n    output_str = output_str.replace(\" \", \"\") # Remove spaces as per example\n    print(output_str)\n\nsolve()\n```"
        }
    ]
}