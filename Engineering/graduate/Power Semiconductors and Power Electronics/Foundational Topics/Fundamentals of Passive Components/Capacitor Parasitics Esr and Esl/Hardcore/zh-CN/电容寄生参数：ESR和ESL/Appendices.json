{
    "hands_on_practices": [
        {
            "introduction": "在电源设计中，理解和量化输出电压纹波的来源至关重要。这个实践练习将带你深入分析一个典型的降压变换器，让你亲手拆解总输出纹波，并将其归因于输出电容器的三个关键参数：电容量（$C$）、等效串联电阻（ESR）和等效串联电感（ESL）。通过这项练习，你将掌握为满足系统性能指标而选择和评估电容器的基本技能。",
            "id": "3826070",
            "problem": "一个同步降压转换器将 $V_{\\mathrm{in}}=48\\,\\mathrm{V}$ 的直流输入转换为 $V_{o}=12\\,\\mathrm{V}$ 的输出，其脉冲宽度调制开关频率为 $f_{s}=500\\,\\mathrm{kHz}$，在连续导通模式下使用理想开关工作。稳态电感电流具有一个峰峰值幅度为 $\\Delta I_{L}=6\\,\\mathrm{A}$ 的三角波纹波。输出网络被建模为一个总电容为 $C=1000\\,\\mu\\mathrm{F}$ 的理想电容器，串联一个待确定的等效串联电阻（ESR）和一个已知的等效串联电感（ESL）$L_{s}=0.6\\,\\mathrm{nH}$，该电感代表了电容器和布局电感的总和。负载电流为 $I_{o}=20\\,\\mathrm{A}$。\n\n从基本关系式 $v_{L}=L\\,\\mathrm{d}i_{L}/\\mathrm{d}t$、$i_{C}=C\\,\\mathrm{d}v_{C}/\\mathrm{d}t$、$v_{\\mathrm{ESR}}=\\mathrm{ESR}\\cdot i_{C}$ 和 $v_{\\mathrm{ESL}}=L_{s}\\,\\mathrm{d}i_{C}/\\mathrm{d}t$ 出发，并假设电感电流为分段线性的三角波且开关转换为瞬时过程，推导由电容器的有限电容、其ESR和其ESL引起的峰峰值输出纹波分量的表达式。使用由转换比所隐含的占空比，并将电容电流视为等于围绕负载电流的电感纹波电流的零均值三角波纹波电流。\n\n为满足最坏情况下的合规性，假设峰峰值输出电压纹波是三个峰峰值分量（电容、ESR、ESL）的算术和。规格要求在所述条件下，开关频率下的总峰峰值输出纹波满足 $V_{\\mathrm{pp,tot}}\\leq 20\\,\\mathrm{mV}$。\n\n计算满足纹波规格的输出电容网络的最大允许等效串联电阻。以毫欧为单位表示最终答案，并四舍五入到三位有效数字。",
            "solution": "该问题要求在给定的最大总峰峰值输出电压纹波规格下，计算同步降压转换器输出电容网络的最大允许等效串联电阻（ESR）。该问题被认为是有效的，因为它具有科学依据、问题设定良好，并且所有必要的参数都已提供或可以从给定信息中推导出来。解决方案将首先确定转换器的工作参数，然后推导每个寄生元件（电容、ESR、ESL）对总输出电压纹波的贡献，最后求解满足规格的最大ESR值。\n\n首先，我们确定降压转换器的基本工作参数。\n开关周期 $T_s$ 是开关频率 $f_s$ 的倒数：\n$$T_s = \\frac{1}{f_s} = \\frac{1}{500 \\times 10^3\\,\\mathrm{Hz}} = 2 \\times 10^{-6}\\,\\mathrm{s} = 2\\,\\mu\\mathrm{s}$$\n对于在连续导通模式（CCM）下工作的理想降压转换器，占空比 $D$ 是输出电压 $V_o$ 与输入电压 $V_{\\mathrm{in}}$ 的比值：\n$$D = \\frac{V_o}{V_{\\mathrm{in}}} = \\frac{12\\,\\mathrm{V}}{48\\,\\mathrm{V}} = 0.25$$\n高边开关闭合的持续时间 $T_{on}$ 和低边开关闭合的持续时间 $T_{off}$ 由下式给出：\n$$T_{on} = D \\cdot T_s = 0.25 \\cdot (2 \\times 10^{-6}\\,\\mathrm{s}) = 0.5 \\times 10^{-6}\\,\\mathrm{s} = 0.5\\,\\mu\\mathrm{s}$$\n$$T_{off} = (1-D) \\cdot T_s = (1 - 0.25) \\cdot (2 \\times 10^{-6}\\,\\mathrm{s}) = 1.5 \\times 10^{-6}\\,\\mathrm{s} = 1.5\\,\\mu\\mathrm{s}$$\n\n总输出电压纹波 $V_{\\mathrm{pp,tot}}$ 被规定为来自电容（$V_{\\mathrm{pp,C}}$）、ESR（$V_{\\mathrm{pp,ESR}}$）和ESL（$V_{\\mathrm{pp,ESL}}$）的峰峰值贡献的算术和：\n$$V_{\\mathrm{pp,tot}} = V_{\\mathrm{pp,C}} + V_{\\mathrm{pp,ESR}} + V_{\\mathrm{pp,ESL}}$$\n问题指出，电容电流 $i_C(t)$ 可以建模为电感电流的零均值交流分量。该交流分量是一个三角波形，其峰峰值幅度等于电感电流纹波 $\\Delta I_L = 6\\,\\mathrm{A}$。\n\n我们现在推导每个纹波分量的表达式。\n\n1.  **来自ESR的贡献（$V_{\\mathrm{pp,ESR}}$）：**\n    ESR两端的电压由 $v_{\\mathrm{ESR}}(t) = \\mathrm{ESR} \\cdot i_C(t)$ 给出。由于 $v_{\\mathrm{ESR}}$ 与 $i_C(t)$ 成正比，其波形也是三角波，并与电容电流同相。因此，由ESR引起的峰峰值电压纹波与峰峰值电容电流（即 $\\Delta I_L$）成正比。\n    $$V_{\\mathrm{pp,ESR}} = \\mathrm{ESR} \\cdot \\Delta I_L$$\n\n2.  **来自电容的贡献（$V_{\\mathrm{pp,C}}$）：**\n    理想电容 $C$ 两端的电压纹波是由电容电流 $i_C(t)$ 的积分引起的。峰峰值电压纹波是由电流纹波半个周期内累积的净电荷所引起的电压变化。对于一个周期为 $T_s$、峰峰值幅度为 $\\Delta I_L$ 的零均值三角电流波形，累积的电荷（半个周期内电流曲线下的面积，这是一个三角形）为：\n    $$\\Delta Q_C = \\frac{1}{2} \\cdot \\left(\\frac{T_s}{2}\\right) \\cdot \\left(\\frac{\\Delta I_L}{2}\\right) = \\frac{\\Delta I_L T_s}{8}$$\n    相应的峰峰值电压纹波是该电荷除以电容 $C$：\n    $$V_{\\mathrm{pp,C}} = \\frac{\\Delta Q_C}{C} = \\frac{\\Delta I_L T_s}{8C}$$\n    代入给定值：\n    $$V_{\\mathrm{pp,C}} = \\frac{(6\\,\\mathrm{A}) \\cdot (2 \\times 10^{-6}\\,\\mathrm{s})}{8 \\cdot (1000 \\times 10^{-6}\\,\\mathrm{F})} = \\frac{12 \\times 10^{-6}}{8000 \\times 10^{-6}}\\,\\mathrm{V} = 1.5 \\times 10^{-3}\\,\\mathrm{V} = 1.5\\,\\mathrm{mV}$$\n\n3.  **来自ESL的贡献（$V_{\\mathrm{pp,ESL}}$）：**\n    ESL两端的电压由 $v_{\\mathrm{ESL}}(t) = L_s \\cdot \\mathrm{d}i_C/\\mathrm{d}t$ 给出。由于 $i_C(t)$ 是一个分段线性的三角波，其导数 $\\mathrm{d}i_C/\\mathrm{d}t$ 是一个分段常数（方波）波形。\n    在 $T_{on}$ 期间，电流变化量为 $\\Delta I_L$，因此变化率为：\n    $$\\frac{\\mathrm{d}i_C}{\\mathrm{d}t}\\bigg|_{T_{on}} = \\frac{\\Delta I_L}{T_{on}}$$\n    在 $T_{off}$ 期间，电流变化量为 $-\\Delta I_L$，因此变化率为：\n    $$\\frac{\\mathrm{d}i_C}{\\mathrm{d}t}\\bigg|_{T_{off}} = -\\frac{\\Delta I_L}{T_{off}}$$\n    ESL上对应的电压为：\n    $$v_{\\mathrm{ESL,on}} = L_s \\frac{\\Delta I_L}{T_{on}} \\quad \\text{和} \\quad v_{\\mathrm{ESL,off}} = -L_s \\frac{\\Delta I_L}{T_{off}}$$\n    由ESL引起的峰峰值电压纹波是这两个电压水平之间的差值：\n    $$V_{\\mathrm{pp,ESL}} = v_{\\mathrm{ESL,on}} - v_{\\mathrm{ESL,off}} = L_s \\frac{\\Delta I_L}{T_{on}} - \\left(-L_s \\frac{\\Delta I_L}{T_{off}}\\right) = L_s \\Delta I_L \\left(\\frac{1}{T_{on}} + \\frac{1}{T_{off}}\\right)$$\n    代入 $T_{on}$ 和 $T_{off}$ 的表达式：\n    $$V_{\\mathrm{pp,ESL}} = L_s \\Delta I_L \\left(\\frac{1}{D T_s} + \\frac{1}{(1-D) T_s}\\right) = \\frac{L_s \\Delta I_L}{T_s} \\left(\\frac{1-D+D}{D(1-D)}\\right) = \\frac{L_s \\Delta I_L}{T_s D(1-D)}$$\n    代入给定值：\n    $$V_{\\mathrm{pp,ESL}} = \\frac{(0.6 \\times 10^{-9}\\,\\mathrm{H}) \\cdot (6\\,\\mathrm{A})}{(2 \\times 10^{-6}\\,\\mathrm{s}) \\cdot 0.25 \\cdot (1-0.25)} = \\frac{3.6 \\times 10^{-9}}{2 \\times 10^{-6} \\cdot 0.1875}\\,\\mathrm{V} = \\frac{3.6 \\times 10^{-9}}{0.375 \\times 10^{-6}}\\,\\mathrm{V} = 9.6 \\times 10^{-3}\\,\\mathrm{V} = 9.6\\,\\mathrm{mV}$$\n\n现在我们使用总纹波规格 $V_{\\mathrm{pp,tot}} \\leq 20\\,\\mathrm{mV}$ 来计算最大允许ESR。我们将总纹波设置为其最大允许值 $20\\,\\mathrm{mV}$。\n$$V_{\\mathrm{pp,tot}} = V_{\\mathrm{pp,C}} + V_{\\mathrm{pp,ESR}} + V_{\\mathrm{pp,ESL}}$$\n$$20\\,\\mathrm{mV} = 1.5\\,\\mathrm{mV} + V_{\\mathrm{pp,ESR}} + 9.6\\,\\mathrm{mV}$$\n$$20\\,\\mathrm{mV} = 11.1\\,\\mathrm{mV} + V_{\\mathrm{pp,ESR}}$$\n求解ESR的最大纹波贡献：\n$$V_{\\mathrm{pp,ESR}} = 20\\,\\mathrm{mV} - 11.1\\,\\mathrm{mV} = 8.9\\,\\mathrm{mV} = 8.9 \\times 10^{-3}\\,\\mathrm{V}$$\n最后，我们根据关系式 $V_{\\mathrm{pp,ESR}} = \\mathrm{ESR}_{\\mathrm{max}} \\cdot \\Delta I_L$ 求出最大允许ESR，记为 $\\mathrm{ESR}_{\\mathrm{max}}$：\n$$\\mathrm{ESR}_{\\mathrm{max}} = \\frac{V_{\\mathrm{pp,ESR}}}{\\Delta I_L} = \\frac{8.9 \\times 10^{-3}\\,\\mathrm{V}}{6\\,\\mathrm{A}} \\approx 1.48333... \\times 10^{-3}\\,\\Omega$$\n问题要求答案以毫欧（m$\\Omega$）为单位，即 $10^{-3}\\,\\Omega$。\n$$\\mathrm{ESR}_{\\mathrm{max}} \\approx 1.48333...\\,\\mathrm{m}\\Omega$$\n四舍五入到三位有效数字，我们得到：\n$$\\mathrm{ESR}_{\\mathrm{max}} = 1.48\\,\\mathrm{m}\\Omega$$",
            "answer": "$$\\boxed{1.48}$$"
        },
        {
            "introduction": "为了在宽频率范围内实现低阻抗，现代电力电子系统常常并联使用多种不同类型的电容器。然而，这种做法可能会导致意想不到的高阻抗峰值，即“反谐振”现象，从而危及系统稳定性。这项实践将指导你编写代码，从基本原理出发为并联电容器组建模并仿真其阻抗特性，让你直观地看到这一关键现象，并将分析从单个工作频率扩展到整个频谱。",
            "id": "3826021",
            "problem": "您的任务是推导、实现并验证一个并联电容器组的频率相关阻抗模型，该模型需包含实际的寄生参数，特别是等效串联电阻 (ESR) 和等效串联电感 (ESL)，以及一个共享的串联互连路径。您必须使用交流网络分析的基本原理来构建总阻抗，并以数值方式将反谐振识别为阻抗幅值峰。当电感和电容的相互作用导致净导纳很小时，并联网络中会出现反谐振峰，从而引起大的阻抗幅值。您的程序必须在指定的频率范围内模拟阻抗幅值，并报告这些峰值的频率。\n\n从以下基本定义和组合规则开始，除这些之外不引入任何快捷公式：\n- 对于电阻为 $R$ 的电阻器，其阻抗为 $Z_R = R$。\n- 对于电感为 $L$ 的电感器，其阻抗为 $Z_L = j \\, \\omega \\, L$，其中 $j$ 是虚数单位，$\\omega = 2 \\pi f$ 是对应于频率 $f$ 的角频率。\n- 对于电容为 $C$ 的电容器，其阻抗为 $Z_C = \\dfrac{1}{j \\, \\omega \\, C}$。\n- 在阻抗为 $Z_1$ 和 $Z_2$ 的元件串联连接中，总阻抗为 $Z_{\\text{series}} = Z_1 + Z_2$。\n- 在阻抗为 $Z_1$ 和 $Z_2$ 的元件并联连接中，总导纳为 $Y_{\\text{parallel}} = \\dfrac{1}{Z_1} + \\dfrac{1}{Z_2}$，总阻抗为 $Z_{\\text{parallel}} = \\dfrac{1}{Y_{\\text{parallel}}}$。\n\n将电容器组构建为 $N$ 个并联支路，每个支路都是一个等效串联电阻 (ESR) 和一个等效串联电感 (ESL) 与理想电容器的串联连接，即每个支路 $i$ 的阻抗为 $Z_i(f) = R_i + j \\, \\omega \\, L_i + \\dfrac{1}{j \\, \\omega \\, C_i}$，所有支路的并联组合产生的净导纳为 $Y_{\\text{bank}}(f) = \\sum_{i=1}^{N} \\dfrac{1}{Z_i(f)}$。然后，该电容器组与一个以串联电阻 $R_s$ 和串联电感 $L_s$ 为特征的共享互连路径串联，得出总阻抗 $Z_{\\text{tot}}(f) = R_s + j \\, \\omega \\, L_s + \\dfrac{1}{Y_{\\text{bank}}(f)}$。\n\n定义反谐振峰为标量函数 $|Z_{\\text{tot}}(f)|$ 相对于 $f$ 的一个局部最大值，在该点，离散数值导数从正变负，且离散二阶导数为负。为确保得到的是具有物理意义的峰值而非数值噪声，需施加一个相对突显度标准：如果一个峰值的高度为 $H$，其局部基线（两侧最近的较低最小值中较高的一个）的水平为 $B$，则相对突显度比率 $\\rho = \\dfrac{H}{B}$ 必须满足 $\\rho \\ge \\alpha$，其中 $\\alpha = 3$。\n\n频率扫描和采样：\n- 使用 $N_f = 5000$ 个在 $f \\in [f_{\\min}, f_{\\max}]$ 范围内对数间隔的点，具体范围根据每个测试用例指定。确保在每个频率点都计算 $\\omega = 2 \\pi f$。\n- 在所有 $N_f$ 个点上计算 $Z_{\\text{tot}}(f)$ 和 $|Z_{\\text{tot}}(f)|$。\n\n输出规格：\n- 对于每个测试用例，返回一个反谐振峰频率列表，频率值为整数，单位为 $\\mathrm{Hz}$，四舍五入到最近的整数。\n- 您的程序应生成单行输出，其中包含一个由逗号分隔的列表，该列表被方括号括起来，每个测试用例的列表也由方括号括起来，且无空格。例如，两个测试用例的输出可能看起来像 $[[100000,250000],[\\ ]]$，其中第二个用例没有峰值。每个频率的单位是 $\\mathrm{Hz}$。\n\n测试套件：\n实现以下四个测试用例。对于每个用例，电容器组由多个支路组成，其参数 $(C_i, R_i, L_i)$ 分别以法拉、欧姆和亨利为单位给出，共享串联路径 $(R_s, L_s)$ 以欧姆和亨利为单位。\n\n- 测试用例 $1$ (具有中等寄生参数的通用多电容器组，预期有多个反谐振):\n  - 共享串联路径: $R_s = 2 \\times 10^{-3} \\,\\mathrm{\\Omega}$, $L_s = 5 \\times 10^{-9} \\,\\mathrm{H}$。\n  - 支路 $1$: $C_1 = 47 \\times 10^{-6} \\,\\mathrm{F}$, $R_1 = 15 \\times 10^{-3} \\,\\mathrm{\\Omega}$, $L_1 = 6 \\times 10^{-9} \\,\\mathrm{H}$。\n  - 支路 $2$: $C_2 = 1 \\times 10^{-6} \\,\\mathrm{F}$, $R_2 = 10 \\times 10^{-3} \\,\\mathrm{\\Omega}$, $L_2 = 2 \\times 10^{-9} \\,\\mathrm{H}$。\n  - 支路 $3$: $C_3 = 100 \\times 10^{-9} \\,\\mathrm{F}$, $R_3 = 20 \\times 10^{-3} \\,\\mathrm{\\Omega}$, $L_3 = 1 \\times 10^{-9} \\,\\mathrm{H}$。\n  - 频率范围: $f_{\\min} = 10^{3} \\,\\mathrm{Hz}$, $f_{\\max} = 10^{8} \\,\\mathrm{Hz}$, $N_f = 5000$。\n\n- 测试用例 $2$ (高 ESR 阻尼网络，预期很少或没有反谐振):\n  - 共享串联路径: $R_s = 5 \\times 10^{-3} \\,\\mathrm{\\Omega}$, $L_s = 5 \\times 10^{-9} \\,\\mathrm{H}$。\n  - 支路 $1$: $C_1 = 22 \\times 10^{-6} \\,\\mathrm{F}$, $R_1 = 200 \\times 10^{-3} \\,\\mathrm{\\Omega}$, $L_1 = 8 \\times 10^{-9} \\,\\mathrm{H}$。\n  - 支路 $2$: $C_2 = 1 \\times 10^{-6} \\,\\mathrm{F}$, $R_2 = 150 \\times 10^{-3} \\,\\mathrm{\\Omega}$, $L_2 = 4 \\times 10^{-9} \\,\\mathrm{H}$。\n  - 支路 $3$: $C_3 = 100 \\times 10^{-9} \\,\\mathrm{F}$, $R_3 = 150 \\times 10^{-3} \\,\\mathrm{\\Omega}$, $L_3 = 2 \\times 10^{-9} \\,\\mathrm{H}$。\n  - 频率范围: $f_{\\min} = 10^{3} \\,\\mathrm{Hz}$, $f_{\\max} = 10^{8} \\,\\mathrm{Hz}$, $N_f = 5000$。\n\n- 测试用例 $3$ (低 ESR 和较大共享电感，预期有尖锐的高 Q 值反谐振):\n  - 共享串联路径: $R_s = 0.5 \\times 10^{-3} \\,\\mathrm{\\Omega}$, $L_s = 20 \\times 10^{-9} \\,\\mathrm{H}$。\n  - 支路 $1$: $C_1 = 100 \\times 10^{-6} \\,\\mathrm{F}$, $R_1 = 3 \\times 10^{-3} \\,\\mathrm{\\Omega}$, $L_1 = 10 \\times 10^{-9} \\,\\mathrm{H}$。\n  - 支路 $2$: $C_2 = 1 \\times 10^{-6} \\,\\mathrm{F}$, $R_2 = 3 \\times 10^{-3} \\,\\mathrm{\\Omega}$, $L_2 = 2 \\times 10^{-9} \\,\\mathrm{H}$。\n  - 支路 $3$: $C_3 = 10 \\times 10^{-9} \\,\\mathrm{F}$, $R_3 = 3 \\times 10^{-3} \\,\\mathrm{\\Omega}$, $L_3 = 0.5 \\times 10^{-9} \\,\\mathrm{H}$。\n  - 频率范围: $f_{\\min} = 10^{3} \\,\\mathrm{Hz}$, $f_{\\max} = 10^{8} \\,\\mathrm{Hz}$, $N_f = 5000$。\n\n- 测试用例 $4$ (具有两个电容器的最小网络，预期有单个主导反谐振):\n  - 共享串联路径: $R_s = 1 \\times 10^{-3} \\,\\mathrm{\\Omega}$, $L_s = 10 \\times 10^{-9} \\,\\mathrm{H}$。\n  - 支路 $1$: $C_1 = 10 \\times 10^{-6} \\,\\mathrm{F}$, $R_1 = 10 \\times 10^{-3} \\,\\mathrm{\\Omega}$, $L_1 = 6 \\times 10^{-9} \\,\\mathrm{H}$。\n  - 支路 $2$: $C_2 = 100 \\times 10^{-9} \\,\\mathrm{F}$, $R_2 = 30 \\times 10^{-3} \\,\\mathrm{\\Omega}$, $L_2 = 1.5 \\times 10^{-9} \\,\\mathrm{H}$。\n  - 频率范围: $f_{\\min} = 10^{3} \\,\\mathrm{Hz}$, $f_{\\max} = 10^{8} \\,\\mathrm{Hz}$, $N_f = 5000$。\n\n您的程序必须在内部实现这四个测试用例，执行所需的计算，并打印包含四个整数列表的列表的单行内容，每个内部列表是相应测试用例的四舍五入后的反谐振峰频率，单位为 $\\mathrm{Hz}$，格式如上所述，无空格。",
            "solution": "该问题要求推导并数值实现一个并联电容器组的总阻抗模型，该模型包括寄生元件，用于识别反谐振频率。该过程基于交流 (AC) 电路分析的基本原理。\n\n首先，我们建立总阻抗 $Z_{\\text{tot}}(f)$ 作为频率 $f$ 的函数的数学模型。角频率定义为 $\\omega = 2 \\pi f$。\n分析过程分四步进行：\n1.  定义单个电容器支路的阻抗。\n2.  合并所有并联支路的导纳，求出电容器组的总导纳。\n3.  根据导纳计算电容器组的阻抗。\n4.  加上共享串联路径的阻抗，求出总网络阻抗。\n\n步骤 1：单个支路的阻抗\n\n并联电容器组中的每个支路 $i$ 由一个电容器 $C_i$ 与其寄生等效串联电阻 (ESR) $R_i$ 和等效串联电感 (ESL) $L_i$ 串联组成。这些单个元件的阻抗由以下公式给出：\n-   电阻器: $Z_{R_i} = R_i$\n-   电感器: $Z_{L_i} = j \\omega L_i$\n-   电容器: $Z_{C_i} = \\dfrac{1}{j \\omega C_i} = -j \\dfrac{1}{\\omega C_i}$\n\n其中 $j$ 是虚数单位。由于这三个元件是串联的，支路 $i$ 的总阻抗，记为 $Z_i(\\omega)$，是它们各自阻抗的和：\n$$Z_i(\\omega) = R_i + j \\omega L_i + \\frac{1}{j \\omega C_i} = R_i + j\\left(\\omega L_i - \\frac{1}{\\omega C_i}\\right)$$\n\n步骤 2：电容器组的导纳\n\n电容器组由 $N$ 个这样的支路并联而成。对于并联元件，使用导纳 $Y$ (即阻抗的倒数，$Y = 1/Z$) 更为方便。并联组合的总导纳是各个导纳之和。\n支路 $i$ 的导纳是：\n$$Y_i(\\omega) = \\frac{1}{Z_i(\\omega)} = \\frac{1}{R_i + j\\left(\\omega L_i - \\frac{1}{\\omega C_i}\\right)}$$\n电容器组的总导纳 $Y_{\\text{bank}}(\\omega)$ 是所有 $N$ 个支路的导纳之和：\n$$Y_{\\text{bank}}(\\omega) = \\sum_{i=1}^{N} Y_i(\\omega) = \\sum_{i=1}^{N} \\frac{1}{R_i + j\\left(\\omega L_i - \\frac{1}{\\omega C_i}\\right)}$$\n\n步骤 3：电容器组的阻抗\n\n电容器组的总阻抗 $Z_{\\text{bank}}(\\omega)$ 是其总导纳的倒数：\n$$Z_{\\text{bank}}(\\omega) = \\frac{1}{Y_{\\text{bank}}(\\omega)} = \\left( \\sum_{i=1}^{N} \\frac{1}{R_i + j\\left(\\omega L_i - \\frac{1}{\\omega C_i}\\right)} \\right)^{-1}$$\n\n步骤 4：总网络阻抗\n\n整个电容器组与一个共享的互连路径串联，该路径有其自身的电阻 $R_s$ 和电感 $L_s$。此共享路径的阻抗 $Z_s(\\omega)$ 为：\n$$Z_s(\\omega) = R_s + j \\omega L_s$$\n网络的总阻抗 $Z_{\\text{tot}}(\\omega)$ 是共享路径和电容器组的串联组合：\n$$Z_{\\text{tot}}(\\omega) = Z_s(\\omega) + Z_{\\text{bank}}(\\omega)$$\n代入上面推导的表达式，我们得到总阻抗作为角频率函数的最终公式：\n$$Z_{\\text{tot}}(\\omega) = (R_s + j \\omega L_s) + \\left( \\sum_{i=1}^{N} \\frac{1}{R_i + j \\left( \\omega L_i - \\frac{1}{\\omega C_i} \\right)} \\right)^{-1}$$\n这个复阻抗的幅值 $|Z_{\\text{tot}}(\\omega)|$ 是一个标量，我们需要寻找它的局部最大值作为反谐振点。\n\n数值实现与峰值识别\n\n问题要求在指定的频率范围 $[f_{\\min}, f_{\\max}]$ 内对反谐振峰进行数值搜索。这通过以下算法步骤完成：\n\n1.  **频率离散化**：生成一个频率向量 $f$，包含 $N_f = 5000$ 个在 $f_{\\min}$ 和 $f_{\\max}$ 之间对数间隔的点。然后计算相应的角频率向量 $\\omega = 2 \\pi f$。对于宽频率扫描，对数尺度是合适的。\n\n2.  **阻抗计算**：使用推导出的 $Z_{\\text{tot}}(\\omega)$ 公式，为每个频率点计算复阻抗。这可以通过对复数数组进行矢量化操作来高效实现。然后计算其幅值 $|Z_{\\text{tot}}(\\omega)|$，得到一个表示阻抗幅值谱的离散信号。\n\n3.  **峰值候选点识别**：反谐振峰被定义为阻抗幅值谱中的局部最大值。在索引 $i$ 处，如果阻抗幅值严格大于其直接相邻点，即 $|Z_{\\text{tot}}(f_i)|  |Z_{\\text{tot}}(f_{i-1})|$ 且 $|Z_{\\text{tot}}(f_i)|  |Z_{\\text{tot}}(f_{i+1})|$，则该点被识别为峰值候选点。这个条件等价于离散一阶导数符号从正变负，并确保离散二阶导数为负，如题目所规定。\n\n4.  **突显度筛选**：为了区分显著的反谐振和微小的波动，应用了相对突显度标准。对于每个候选峰，其高度为 $H = |Z_{\\text{tot}}(f_{\\text{peak}})|$，必须确定一个局部基线 $B$。$B$ 被定义为峰值两侧最近的两个局部最小值中较高的那个。\n    -   首先，识别谱中的所有局部最小值。\n    -   对于一个给定的峰值，找到其左侧最近的最小值和右侧最近的最小值。如果一侧没有最小值，则使用该侧谱的边界值。\n    -   基线 $B$ 是这两个最小值处阻抗幅值的最大值。\n    -   如果一个峰值的相对突显度比率 $\\rho = H/B$ 大于或等于阈值 $\\alpha = 3$，则该峰被确认为有效的反谐振。\n\n5.  **输出生成**：收集所有确认的反谐振峰的频率。这些频率值四舍五入到最近的整数，并格式化为最终输出所指定的列表结构。对每个提供的测试用例重复此过程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final result.\n    \"\"\"\n    test_cases = [\n        # Test case 1\n        {\n            \"shared_path\": (2e-3, 5e-9),\n            \"branches\": [\n                (47e-6, 15e-3, 6e-9),\n                (1e-6, 10e-3, 2e-9),\n                (100e-9, 20e-3, 1e-9),\n            ],\n            \"freq_range\": (1e3, 1e8),\n            \"Nf\": 5000,\n            \"alpha\": 3.0,\n        },\n        # Test case 2\n        {\n            \"shared_path\": (5e-3, 5e-9),\n            \"branches\": [\n                (22e-6, 200e-3, 8e-9),\n                (1e-6, 150e-3, 4e-9),\n                (100e-9, 150e-3, 2e-9),\n            ],\n            \"freq_range\": (1e3, 1e8),\n            \"Nf\": 5000,\n            \"alpha\": 3.0,\n        },\n        # Test case 3\n        {\n            \"shared_path\": (0.5e-3, 20e-9),\n            \"branches\": [\n                (100e-6, 3e-3, 10e-9),\n                (1e-6, 3e-3, 2e-9),\n                (10e-9, 3e-3, 0.5e-9),\n            ],\n            \"freq_range\": (1e3, 1e8),\n            \"Nf\": 5000,\n            \"alpha\": 3.0,\n        },\n        # Test case 4\n        {\n            \"shared_path\": (1e-3, 10e-9),\n            \"branches\": [\n                (10e-6, 10e-3, 6e-9),\n                (100e-9, 30e-3, 1.5e-9),\n            ],\n            \"freq_range\": (1e3, 1e8),\n            \"Nf\": 5000,\n            \"alpha\": 3.0,\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        peak_freqs = find_antiresonances(\n            case[\"shared_path\"],\n            case[\"branches\"],\n            case[\"freq_range\"],\n            case[\"Nf\"],\n            case[\"alpha\"],\n        )\n        results.append(peak_freqs)\n\n    # Format the final output string exactly as specified.\n    output_str = f\"[{','.join([f'[{\",\".join(map(str, r))}]' for r in results])}]\"\n    print(output_str)\n\ndef find_antiresonances(shared_path, branches, freq_range, Nf, alpha):\n    \"\"\"\n    Calculates the impedance spectrum and finds anti-resonance peak frequencies.\n    \n    Args:\n        shared_path (tuple): (Rs, Ls) of the shared path.\n        branches (list of tuples): List of (C, R, L) for each capacitor branch.\n        freq_range (tuple): (f_min, f_max) for the frequency sweep.\n        Nf (int): Number of frequency points.\n        alpha (float): Relative prominence threshold.\n\n    Returns:\n        list: A list of integers representing the rounded anti-resonance frequencies in Hz.\n    \"\"\"\n    Rs, Ls = shared_path\n    f_min, f_max = freq_range\n\n    # 1. Frequency sweep\n    f = np.logspace(np.log10(f_min), np.log10(f_max), Nf)\n    omega = 2 * np.pi * f\n    j = 1j\n\n    # 2. Impedance calculation (vectorized)\n    Y_bank = np.zeros_like(omega, dtype=complex)\n    for C_i, R_i, L_i in branches:\n        # Avoid division by zero at omega=0 if f_min=0, though not the case here.\n        Z_branch = R_i + j * (omega * L_i - 1.0 / (omega * C_i))\n        Y_bank += 1.0 / Z_branch\n\n    Z_bank = 1.0 / Y_bank\n    Z_s = Rs + j * omega * Ls\n    Z_tot = Z_s + Z_bank\n    Z_mag = np.abs(Z_tot)\n\n    # 3. Find local maxima and minima indices\n    # Using array slicing for efficient comparison with neighbors\n    is_peak = (Z_mag[1:-1]  Z_mag[:-2])  (Z_mag[1:-1]  Z_mag[2:])\n    peak_indices = np.where(is_peak)[0] + 1\n\n    is_minima = (Z_mag[1:-1]  Z_mag[:-2])  (Z_mag[1:-1]  Z_mag[2:])\n    minima_indices = np.where(is_minima)[0] + 1\n    \n    # 4. Prominence check\n    valid_peak_freqs = []\n    for peak_idx in peak_indices:\n        H = Z_mag[peak_idx]\n\n        # Find nearest left minimum\n        left_minima_indices = minima_indices[minima_indices  peak_idx]\n        if left_minima_indices.size  0:\n            min_left_val = Z_mag[left_minima_indices[-1]]\n        else:\n            min_left_val = Z_mag[0]\n\n        # Find nearest right minimum\n        right_minima_indices = minima_indices[minima_indices  peak_idx]\n        if right_minima_indices.size  0:\n            min_right_val = Z_mag[right_minima_indices[0]]\n        else:\n            min_right_val = Z_mag[-1]\n\n        B = max(min_left_val, min_right_val)\n        \n        # Avoid division by zero and apply prominence criterion\n        if B  1e-12: # Check against a small number\n            rho = H / B\n            if rho = alpha:\n                valid_peak_freqs.append(int(round(f[peak_idx])))\n    \n    return valid_peak_freqs\n\nif __name__ == \"__main__\":\n    solve()\n\n```"
        },
        {
            "introduction": "掌握了如何分析给定电容器组的阻抗特性后，最终的设计挑战便是主动去构建一个满足要求的电容器组。这项练习模拟了一个真实的工程任务：在满足特定频率范围内的目标阻抗曲线的前提下，选择最具成本效益的电容器组合。通过解决这个优化问题，你将把分析能力转化为强大的设计工具，这是从分析到综合的关键一步。",
            "id": "3826104",
            "problem": "考虑一组可用的电容器类型，这些电容器将并联放置在功率半导体模块的输出端。每个电容器都建模为一个理想电容器与等效串联电阻（ESR）和等效串联电感（ESL）串联。对于单个电容器，其电容为 $C$，串联电阻为 $R$，串联电感为 $L$，在角频率 $\\omega$（单位为 $\\mathrm{rad}\\,\\mathrm{s}^{-1}$）下驱动时，其复阻抗为 $Z(\\omega) = R + j\\omega L - \\dfrac{j}{\\omega C}$。当 $n$ 个相同类型的单元并联放置时，它们的组合导纳为 $Y_{n}(\\omega) = \\dfrac{n}{Z(\\omega)}$。对于一组由索引 $i$ 标识的不同电容器类型，其数量为 $n_i$，总导纳为 $Y_{\\mathrm{tot}}(\\omega) = \\sum_i \\dfrac{n_i}{Z_i(\\omega)}$。在 $Y_{\\mathrm{tot}}(\\omega) \\ne 0$ 的情况下，总阻抗幅值为 $|Z_{\\mathrm{tot}}(\\omega)| = \\left|\\dfrac{1}{Y_{\\mathrm{tot}}(\\omega)}\\right|$。\n\n您必须构建一个算法，给定一个电容器类型目录和在一组指定角频率上的目标阻抗幅值曲线 $Z_{\\mathrm{target}}(\\omega)$，为每种电容器类型选择一个非负整数数量 $n_i$，使得在测试集中的所有指定角频率 $\\omega_k$ 下，都满足约束 $|Z_{\\mathrm{tot}}(\\omega_k)| \\le Z_{\\mathrm{target}}(\\omega_k)$。在所有可行选择中，选择一个使总数量 $\\sum_i n_i$ 最小化的方案。如果总数量出现平局，则选择使总成本 $\\sum_i c_i n_i$ 最小化的方案，其中 $c_i$ 是类型 $i$ 的给定单位成本。如果不存在可行选择，则返回整数 $-1$。\n\n请使用以下物理上真实的电容器模型和参数。所有阻抗必须使用上述串联模型 $Z_i(\\omega) = R_i + j\\omega L_i - \\dfrac{j}{\\omega C_i}$ 进行评估。角频率单位必须为 $\\mathrm{rad}\\,\\mathrm{s}^{-1}$，所有阻抗幅值单位为 $\\Omega$。\n\n该测试套件包括三个用例。在每个用例中，类型的列出顺序必须与输出选择向量中的顺序一致。\n\n测试用例 $1$：\n- 类型和限制：\n  - 类型 $A$：铝电解电容器，$C_A = 100\\times 10^{-6}\\,\\mathrm{F}$，$R_A = 0.06\\,\\Omega$，$L_A = 15\\times 10^{-9}\\,\\mathrm{H}$，单位成本 $c_A = 1.20$，最大数量 $n_{A,\\max} = 4$。\n  - 类型 $B$：导电聚合物电容器，$C_B = 47\\times 10^{-6}\\,\\mathrm{F}$，$R_B = 0.025\\,\\Omega$，$L_B = 5\\times 10^{-9}\\,\\mathrm{H}$，单位成本 $c_B = 1.50$，最大数量 $n_{B,\\max} = 4$。\n  - 类型 $C$：多层陶瓷电容器 (MLCC)，$C_C = 1\\times 10^{-6}\\,\\mathrm{F}$，$R_C = 0.005\\,\\Omega$，$L_C = 0.5\\times 10^{-9}\\,\\mathrm{H}$，单位成本 $c_C = 0.30$，最大数量 $n_{C,\\max} = 6$。\n- 频率集 (单位 $\\mathrm{rad}\\,\\mathrm{s}^{-1}$): $\\{\\omega_k\\} = \\{10^{5}, 3\\times 10^{5}, 10^{6}, 3\\times 10^{6}, 10^{7}, 3\\times 10^{7}, 10^{8}\\}$。\n- 目标阻抗幅值曲线 $Z_{\\mathrm{target}}(\\omega)$:\n  - 对于 $\\omega \\le 3\\times 10^{5}$，$Z_{\\mathrm{target}}(\\omega) = 0.5\\,\\Omega$。\n  - 对于 $3\\times 10^{5}  \\omega \\le 3\\times 10^{7}$，$Z_{\\mathrm{target}}(\\omega) = 0.1\\,\\Omega$。\n  - 对于 $\\omega  3\\times 10^{7}$，$Z_{\\mathrm{target}}(\\omega) = 0.03\\,\\Omega$。\n\n测试用例 $2$：\n- 类型和限制：与测试用例 $1$ 相同，顺序也为 $[A,B,C]$。\n- 频率集 (单位 $\\mathrm{rad}\\,\\mathrm{s}^{-1}$): $\\{\\omega_k\\} = \\{10^{7}, 3\\times 10^{7}, 10^{8}, 3\\times 10^{8}, 10^{9}\\}$。\n- 目标阻抗幅值曲线 $Z_{\\mathrm{target}}(\\omega)$: 对于所有列出的 $\\omega$，恒为 $Z_{\\mathrm{target}}(\\omega) = 0.02\\,\\Omega$。\n\n测试用例 $3$：\n- 类型和限制：\n  - 类型 $C$：多层陶瓷电容器 (MLCC)，$C_C = 1\\times 10^{-6}\\,\\mathrm{F}$，$R_C = 0.005\\,\\Omega$，$L_C = 0.5\\times 10^{-9}\\,\\mathrm{H}$，单位成本 $c_C = 0.30$，最大数量 $n_{C,\\max} = 3$。\n- 频率集 (单位 $\\mathrm{rad}\\,\\mathrm{s}^{-1}$): $\\{\\omega_k\\} = \\{10^{7}, 5\\times 10^{7}\\}$。\n- 目标阻抗幅值曲线 $Z_{\\mathrm{target}}(\\omega)$: 对于所有列出的 $\\omega$，恒为 $Z_{\\mathrm{target}}(\\omega) = 0.05\\,\\Omega$。\n\n要求：\n- 严格使用上述串联 ESR 和 ESL 电容器模型以及并联导纳相加的方法来实现选择算法。\n- 对于每个测试用例，如果所提供的最大数量内不存在可行选择，则返回整数 $-1$；否则，返回一个整数列表 $[n_A,n_B,n_C]$（测试用例 $3$ 为 $[n_C]$），按指定类型顺序给出所选数量，该选择满足目标阻抗约束并按规定最小化目标函数。\n- 最终程序必须生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表，且不含空格。例如，输出必须类似于 $[[-,\\ldots],[\\ldots],-1]$，其中每个条目要么是整数 $-1$，要么是带方括号的整数列表。具体到本问题，您的程序应精确生成一行格式为 $[r_1,r_2,r_3]$ 的输出，其中 $r_1$、$r_2$ 和 $r_3$ 分别对应测试用例 $1$、测试用例 $2$ 和测试用例 $3$ 的结果，每个 $r_i$ 要么是整数 $-1$，要么是按指定顺序包含所选数量的带方括号的列表。",
            "solution": "该问题要求我们解决一个约束整数优化问题。我们必须为每种可用的电容器类型选择一个非负整数数量 $n_i$，并受最大数量约束 $n_i \\le n_{i, \\max}$ 的限制。所选的电容器集合 $\\{n_i\\}$ 必须在给定的一组角频率 $\\{\\omega_k\\}$ 下满足阻抗幅值约束 $|Z_{\\mathrm{tot}}(\\omega_k)| \\le Z_{\\mathrm{target}}(\\omega_k)$。在所有可行集合中，需要找到使总元件数量 $\\sum_i n_i$ 最小的集合。如果多个集合具有相同的最小总数量，则选择总成本 $\\sum_i c_i n_i$ 最小的那个。\n\n首先，我们形式化电气模型。类型为 $i$ 的单个电容器的复阻抗由一个串联 RLC 模型给出：\n$$Z_i(\\omega) = R_i + j\\left(\\omega L_i - \\frac{1}{\\omega C_i}\\right)$$\n其中 $R_i$、$L_i$ 和 $C_i$ 分别是等效串联电阻（ESR）、等效串联电感（ESL）和电容。$j$ 是虚数单位。\n\n当 $n_i$ 个类型为 $i$ 的电容器并联时，它们的组合导纳是单个电容器导纳的 $n_i$ 倍。单个电容器的导纳是 $Y_i(\\omega) = 1/Z_i(\\omega)$。对于一个由数量为 $\\{n_1, n_2, \\ldots, n_m\\}$ 的不同电容器组成的电容组，其总导纳是各组导纳之和：\n$$Y_{\\mathrm{tot}}(\\omega) = \\sum_{i=1}^{m} n_i Y_i(\\omega) = \\sum_{i=1}^{m} \\frac{n_i}{Z_i(\\omega)}$$\n总阻抗是总导纳的倒数，$Z_{\\mathrm{tot}}(\\omega) = 1/Y_{\\mathrm{tot}}(\\omega)$。约束条件是该阻抗的幅值：\n$$|Z_{\\mathrm{tot}}(\\omega_k)| = \\frac{1}{|Y_{\\mathrm{tot}}(\\omega_k)|} \\le Z_{\\mathrm{target}}(\\omega_k)$$\n这等效于要求总导纳幅值足够大：\n$$|Y_{\\mathrm{tot}}(\\omega_k)| \\ge \\frac{1}{Z_{\\mathrm{target}}(\\omega_k)}$$\n\n问题在于找到整数向量 $\\mathbf{n} = [n_1, n_2, \\ldots, n_m]$，该向量：\n1. 最小化 $\\sum_i n_i$，并在平局时，最小化 $\\sum_i c_i n_i$。\n2. 对所有 $i$ 满足 $0 \\le n_i \\le n_{i, \\max}$。\n3. 对所有 $k$ 满足 $| \\sum_i n_i Y_i(\\omega_k) | \\ge 1/Z_{\\mathrm{target}}(\\omega_k)$。\n\n为每种电容器类型提供的最大数量很小。这使得电容器数量的所有可能组合在计算上是可控的。例如，在测试用例 1 中，组合数量为 $(4+1) \\times (4+1) \\times (6+1) = 175$。这表明对所有可能的组合进行穷举搜索（暴力搜索）是找到全局最优解的一种可行且正确的策略。\n\n算法如下：\n1.  对于每个测试用例，我们定义电容器参数（$C_i, R_i, L_i, c_i, n_{i,\\max}$）、测试频率集 $\\{\\omega_k\\}$ 以及目标阻抗函数 $Z_{\\mathrm{target}}(\\omega)$。\n2.  为优化搜索，我们预先计算每种电容器类型 $i$ 在每个频率 $\\omega_k$ 下的复导纳 $Y_i(\\omega_k)$。这些值被存储起来以便复用。\n3.  我们初始化变量来跟踪迄今为止找到的最佳解：`best_solution = None`、`min_count = infinity` 和 `min_cost = infinity`。\n4.  我们生成所有可能的数量组合 $[n_1, n_2, \\ldots, n_m]$，其中每个 $n_i$ 的范围从 $0$到 $n_{i, \\max}$。跳过 `[0, 0, ..., 0]` 这种平凡组合，因为它会导致总导纳为零，从而阻抗无穷大，无法满足任何有限的阻抗目标。\n5.  对于每一种数量组合，我们检查其可行性：\n    a. 我们遍历每个测试频率 $\\omega_k$。\n    b. 对于每个 $\\omega_k$，我们使用预先计算的值计算总导纳 $Y_{\\mathrm{tot}}(\\omega_k) = \\sum_i n_i Y_i(\\omega_k)$。\n    c. 然后我们找到总阻抗幅值 $|Z_{\\mathrm{tot}}(\\omega_k)| = 1 / |Y_{\\mathrm{tot}}(\\omega_k)|$。\n    d. 我们将其与目标进行比较：如果 $|Z_{\\mathrm{tot}}(\\omega_k)|  Z_{\\mathrm{target}}(\\omega_k)$，则该组合不可行。我们停止检查该组合的频率，并继续处理下一个数量组合。\n6.  如果一个组合被发现是可行的（即它满足所有频率的阻抗约束），我们评估其最优性：\n    a. 我们计算总数量 $\\sum_i n_i$ 和总成本 $\\sum_i c_i n_i$。\n    b. 我们将这些值与迄今为止找到的最佳值进行比较。如果当前组合的总数量更少，它就成为新的最佳解。如果总数量相同，我们检查总成本是否更低；如果是，它就成为新的最佳解。\n7.  在遍历所有可能的组合之后，如果没有找到可行的解，我们断定不存在可行解，结果为 $-1$。否则，最终的 `best_solution` 就是电容器数量的最优选择。\n\n该过程将为三个测试用例中的每一个实现，并将结果汇总并格式化为所需的输出字符串。",
            "answer": "```python\nimport numpy as np\nimport itertools\n\ndef solve():\n    \"\"\"\n    Main function to solve all test cases and print the final result.\n    \"\"\"\n    \n    def solve_case(capacitor_types, freqs, target_Z_func):\n        \"\"\"\n        Solves a single capacitor selection problem case using a brute-force search.\n\n        Args:\n            capacitor_types (list): A list of tuples, where each tuple contains\n                                    (C, R, L, cost, max_n) for a capacitor type.\n            freqs (np.ndarray): An array of angular frequencies to test against.\n            target_Z_func (function): A function that returns the target impedance\n                                      for a given frequency.\n\n        Returns:\n            list or int: A list of optimal capacitor counts, or -1 if no\n                         solution is found.\n        \"\"\"\n        num_types = len(capacitor_types)\n        costs = np.array([t[3] for t in capacitor_types])\n        max_counts = [t[4] for t in capacitor_types]\n\n        # Pre-calculate single-capacitor admittances Y_i(w_k) for all types i and frequencies k\n        # admittances is a 2D numpy array of shape (num_types, num_freqs)\n        admittances_list = []\n        for C, R, L, _, _ in capacitor_types:\n            type_admittances = []\n            for w in freqs:\n                # Z = R + j*(wL - 1/(wC))\n                Z = R + 1j * (w * L - 1.0 / (w * C))\n                # ESR (R) is always positive, so Z is never zero.\n                Y = 1.0 / Z\n                type_admittances.append(Y)\n            admittances_list.append(type_admittances)\n        admittances = np.array(admittances_list, dtype=np.complex128)\n\n        # Pre-calculate target admittance magnitudes (1/Z_target) for all frequencies.\n        target_Y_mags = 1.0 / np.array([target_Z_func(w) for w in freqs])\n\n        best_solution = None\n        min_count = float('inf')\n        min_cost = float('inf')\n\n        # Generate all possible count combinations using itertools.product\n        count_ranges = [range(n + 1) for n in max_counts]\n        for counts_tuple in itertools.product(*count_ranges):\n            counts = np.array(counts_tuple)\n            current_count = np.sum(counts)\n\n            # Skip the trivial (0, 0, ...) case\n            if current_count == 0:\n                continue\n\n            # Check if this combination is feasible\n            is_feasible = True\n            # Y_tot(w_k) = sum(n_i * Y_i(w_k))\n            total_admittances = np.dot(counts, admittances)\n            \n            # Check if |Y_tot| = 1/Z_target for all frequencies\n            if not np.all(np.abs(total_admittances) = target_Y_mags):\n                is_feasible = False\n            \n            # If feasible, check if it's a better solution\n            if is_feasible:\n                current_cost = np.dot(counts, costs)\n                \n                if current_count  min_count:\n                    min_count = current_count\n                    min_cost = current_cost\n                    best_solution = counts\n                elif current_count == min_count and current_cost  min_cost:\n                    min_cost = current_cost\n                    best_solution = counts\n        \n        if best_solution is None:\n            return -1\n        else:\n            return best_solution.tolist()\n\n    # --- Test Case 1 ---\n    types1 = [\n        (100e-6, 0.06, 15e-9, 1.20, 4),  # Type A\n        (47e-6, 0.025, 5e-9, 1.50, 4),   # Type B\n        (1e-6, 0.005, 0.5e-9, 0.30, 6)   # Type C\n    ]\n    freqs1 = np.array([1e5, 3e5, 1e6, 3e6, 1e7, 3e7, 1e8])\n    def target_Z1(w):\n        if w = 3e5: return 0.5\n        if w = 3e7: return 0.1\n        return 0.03\n    \n    result1 = solve_case(types1, freqs1, target_Z1)\n\n    # --- Test Case 2 ---\n    types2 = types1 # Same as Case 1\n    freqs2 = np.array([1e7, 3e7, 1e8, 3e8, 1e9])\n    def target_Z2(w): return 0.02\n        \n    result2 = solve_case(types2, freqs2, target_Z2)\n\n    # --- Test Case 3 ---\n    types3 = [(1e-6, 0.005, 0.5e-9, 0.30, 3)] # Type C only\n    freqs3 = np.array([1e7, 5e7])\n    def target_Z3(w): return 0.05\n    \n    result3 = solve_case(types3, freqs3, target_Z3)\n\n    # --- Format final output ---\n    results_str = []\n    for r in [result1, result2, result3]:\n        if isinstance(r, int) and r == -1:\n            results_str.append(str(r))\n        else:\n            results_str.append(f\"[{','.join(map(str, r))}]\")\n    \n    print(f\"[{','.join(results_str)}]\")\n\nsolve()\n```"
        }
    ]
}