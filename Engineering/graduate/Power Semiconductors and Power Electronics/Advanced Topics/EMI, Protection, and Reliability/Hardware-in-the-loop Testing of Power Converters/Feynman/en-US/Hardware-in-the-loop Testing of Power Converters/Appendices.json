{
    "hands_on_practices": [
        {
            "introduction": "The first step in developing a Hardware-in-the-Loop (HIL) simulation is choosing an appropriate model for the physical system. This decision creates a fundamental trade-off between computational efficiency and physical fidelity. In this exercise, you will directly compare a computationally light averaged model with a high-fidelity switching model, quantifying the differences in their ability to predict essential dynamic behaviors like switching ripple and subharmonic oscillations in current-mode control. This practice highlights how modeling choices determine the scope and validity of your HIL test results. ",
            "id": "3845398",
            "problem": "Consider a direct current-direct current step-down (buck) converter under peak current-mode control operating in continuous conduction mode. The hardware-in-the-loop (HIL) testing context is that the converter plant is emulated at runtime, and the controller interacts with either an averaged model or a switching model of the plant. You will contrast the predictions of an averaged model with those of a switching model by quantifying the error in predicting inductor current ripple and the presence of subharmonic oscillation for duty ratios greater than $0.5$ in current-mode control.\n\nUse the following fundamental base:\n- The inductor obeys $v_{L}(t) = L \\, \\frac{d i_{L}(t)}{dt}$.\n- The capacitor obeys $i_{C}(t) = C \\, \\frac{d v_{o}(t)}{dt}$.\n- Ideal pulse-width modulation (PWM) with switching period $T = \\frac{1}{f_{s}}$ and duty ratio $D \\in (0,1)$.\n- For a buck converter, ideal steady-state average output voltage is $v_{o,\\text{avg}} = D \\, v_{\\text{in}}$.\n- In peak current-mode control, during the switch on-time, the inductor current increases with slope $m_{1} = \\frac{v_{\\text{in}} - v_{o}}{L}$, and during the off-time, the inductor current decreases with slope $m_{2} = \\frac{v_{o}}{L}$. Optional slope compensation is modeled as an added ramp with slope $m_{a}$ (in amperes per second) summed with the sensed current in the turn-off comparator.\n- State-space averaged models replace switching behavior with average values over one period and do not generate switching-frequency ripple or sampled subharmonic phenomena.\n\nTasks:\n1. Implement two plant models:\n   - An averaged model that, by construction, predicts zero inductor current ripple at the switching frequency and does not predict subharmonic oscillation.\n   - A switching model that predicts the inductor current ripple amplitude at the switching frequency based on the piecewise-linear inductor current waveform over one PWM period, and determines the presence of subharmonic oscillation using cycle-by-cycle sampled dynamics of the inner current loop.\n2. For the switching model, derive and use the piecewise-linear slopes to compute the inductor current ripple amplitude as the peak-to-valley difference over one cycle. Express the ripple amplitude in amperes.\n3. For the switching model, derive and use a sampled perturbation map for the cycle-start inductor current to determine whether a small perturbation grows in magnitude from cycle to cycle. Define subharmonic oscillation as present if the perturbation growth factor magnitude is strictly greater than $1$.\n4. Quantify the prediction error between the averaged model and the switching model as follows:\n   - Ripple error: absolute difference between the averaged model prediction of the inductor current ripple amplitude and the switching model prediction, expressed in amperes, rounded to six decimal places.\n   - Subharmonic mismatch: a boolean indicating whether the averaged model’s prediction of no subharmonic oscillation disagrees with the switching model’s prediction (i.e., True if the switching model predicts subharmonic oscillation and False otherwise).\n\nUse the following test suite of parameter sets covering a general case, a boundary condition, and a compensated edge case. Assume continuous conduction and ideal components; if a parameter is unused by a model, still include it for completeness and physical realism.\n\nEach test case is a tuple $(v_{\\text{in}}, L, C, R, f_{s}, D, m_{a})$ with units:\n- $v_{\\text{in}}$: input voltage in volts.\n- $L$: inductance in henries.\n- $C$: capacitance in farads.\n- $R$: load resistance in ohms.\n- $f_{s}$: switching frequency in hertz.\n- $D$: duty ratio (unitless).\n- $m_{a}$: slope compensation in amperes per second.\n\nTest suite:\n- Case 1 (happy path, uncompensated at $D>0.5$): $(24.0, 100\\times10^{-6}, 470\\times10^{-6}, 4.0, 100\\times10^{3}, 0.6, 0.0)$.\n- Case 2 (boundary, uncompensated at $D=0.5$): $(24.0, 100\\times10^{-6}, 470\\times10^{-6}, 4.0, 100\\times10^{3}, 0.5, 0.0)$.\n- Case 3 (edge case, compensated at $D>0.5$): $(24.0, 100\\times10^{-6}, 470\\times10^{-6}, 4.0, 100\\times10^{3}, 0.7, 60\\times10^{3})$.\n\nYour program should:\n- Compute the switching-model ripple amplitude using $m_{1}$, $m_{2}$, $T$, and $D$ from first principles.\n- Determine the switching-model subharmonic presence by evaluating the sampled perturbation growth factor derived from inner-loop slopes and $m_{a}$.\n- Compare against the averaged model predictions (zero ripple and no subharmonic oscillation).\n- Produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case result is a two-element list of the form $[\\text{ripple\\_error\\_A},\\text{subharmonic\\_mismatch}]$. There must be no spaces in the output. For example: `[[0.123456,True],[0.000000,False],[0.654321,False]]`.\n\nExpress ripple errors in amperes, rounded to six decimal places. Angles are not used in this problem. Percentages are not used; represent duty ratio $D$ as a unitless decimal as given.",
            "solution": "We begin from the fundamental laws governing the buck converter and peak current-mode control.\n\nThe inductor voltage-current relation is $v_{L}(t) = L \\, \\frac{d i_{L}(t)}{dt}$. Under ideal PWM with switching period $T = \\frac{1}{f_{s}}$ and duty ratio $D$, the ideal buck converter average output voltage is $v_{o,\\text{avg}} = D \\, v_{\\text{in}}$. In continuous conduction mode, during the on-time interval of duration $D T$, the inductor sees $v_{L} = v_{\\text{in}} - v_{o}$ and its current increases with slope\n$$\nm_{1} = \\frac{v_{\\text{in}} - v_{o}}{L}.\n$$\nDuring the off-time interval of duration $(1 - D) T$, the inductor sees $v_{L} = - v_{o}$ and its current decreases with slope\n$$\nm_{2} = \\frac{v_{o}}{L}.\n$$\nFor the switching model, we compute the peak-to-valley inductor current ripple amplitude over one cycle. Starting from a valley value $i_{\\text{val}}$, the peak current at the end of the on-time is $i_{\\text{peak}} = i_{\\text{val}} + m_{1} D T$. Therefore, the ripple amplitude (peak minus valley) is\n$$\n\\Delta i_{L,\\text{switch}} = i_{\\text{peak}} - i_{\\text{val}} = m_{1} D T.\n$$\nUsing $v_{o} = D \\, v_{\\text{in}}$, we substitute $m_{1} = \\frac{v_{\\text{in}} - D v_{\\text{in}}}{L} = \\frac{v_{\\text{in}} (1 - D)}{L}$, obtaining\n$$\n\\Delta i_{L,\\text{switch}} = \\frac{v_{\\text{in}} (1 - D)}{L} \\, D \\, T = \\frac{v_{\\text{in}} (1 - D) D}{L f_{s}}.\n$$\nThis expression results directly from integrating the inductor equation over the on-time.\n\nWe next consider subharmonic oscillation under peak current-mode control. The controller turns the switch off when the sum of the sensed inductor current and an optional slope compensation ramp reaches a fixed reference. Let the slope compensation ramp be a sawtooth with slope $m_{a}$ in amperes per second that resets each cycle. Let $i_{n}$ denote the inductor current at the beginning of cycle $n$. Define the on-time each cycle by the comparator condition. If the fixed reference is chosen to enforce nominal on-time $D T$ when $i_{n}$ equals a nominal valley value $i_{0}$, then the reference satisfies\n$$\nI_{\\text{ref}} = i_{0} + (m_{1} + m_{a}) D T,\n$$\nbecause the comparator observes $i_{n} + m_{a} t$ rising at net slope $m_{1} + m_{a}$ toward $I_{\\text{ref}}$ during on-time. For a perturbed cycle start $i_{n} = i_{0} + \\delta_{n}$, the on-time is\n$$\nt_{\\text{on}}(n) = \\frac{I_{\\text{ref}} - i_{n}}{m_{1} + m_{a}} = \\frac{i_{0} + (m_{1} + m_{a}) D T - (i_{0} + \\delta_{n})}{m_{1} + m_{a}} = D T - \\frac{\\delta_{n}}{m_{1} + m_{a}}.\n$$\nThe peak current in cycle $n$ is\n$$\ni_{\\text{peak}}(n) = i_{n} + m_{1} t_{\\text{on}}(n) = i_{0} + \\delta_{n} + m_{1} \\left( D T - \\frac{\\delta_{n}}{m_{1} + m_{a}} \\right) = i_{0} + m_{1} D T + \\delta_{n} \\left( 1 - \\frac{m_{1}}{m_{1} + m_{a}} \\right).\n$$\nThe off-time is\n$$\nt_{\\text{off}}(n) = T - t_{\\text{on}}(n) = (1 - D) T + \\frac{\\delta_{n}}{m_{1} + m_{a}}.\n$$\nAt the beginning of cycle $n+1$, the inductor current is\n$$\ni_{n+1} = i_{\\text{peak}}(n) - m_{2} t_{\\text{off}}(n) = i_{0} + m_{1} D T - m_{2} (1 - D) T + \\delta_{n} \\left( 1 - \\frac{m_{1}}{m_{1} + m_{a}} - \\frac{m_{2}}{m_{1} + m_{a}} \\right).\n$$\nFor steady-state operating points of a buck converter with $v_{o} = D v_{\\text{in}}$, the identity $m_{1} D T = m_{2} (1 - D) T$ holds, so the constant terms simplify to $i_{0}$. Therefore, the perturbation evolves according to the linear sampled map\n$$\n\\delta_{n+1} = \\left[ 1 - \\frac{m_{1} + m_{2}}{m_{1} + m_{a}} \\right] \\delta_{n}.\n$$\nThe quantity\n$$\n\\lambda = 1 - \\frac{m_{1} + m_{2}}{m_{1} + m_{a}}\n$$\nis the sampled perturbation growth factor. Subharmonic oscillation is present if the magnitude of this factor exceeds unity, that is, if $|\\lambda| > 1$. For the uncompensated case $m_{a} = 0$, we have\n$$\n\\lambda = 1 - \\frac{m_{1} + m_{2}}{m_{1}} = - \\frac{m_{2}}{m_{1}} = - \\frac{D}{1 - D},\n$$\nwhich implies $|\\lambda| > 1$ if and only if $D > 0.5$, recovering the classical criterion for buck converters under peak current-mode control. With slope compensation, stability requires $|\\lambda| < 1$, which for positive slopes reduces to the inequality\n$$\n\\frac{m_{1} + m_{2}}{m_{1} + m_{a}} < 2 \\quad \\Rightarrow \\quad m_{a} > \\frac{m_{2} - m_{1}}{2}.\n$$\n\nAveraged model predictions:\n- By definition, a state-space averaged model does not generate switching-frequency ripple, so it predicts zero inductor current ripple amplitude at the switching frequency: $\\Delta i_{L,\\text{avg}} = 0$.\n- An averaged continuous-time model does not represent sampled inner-loop dynamics, so it does not predict subharmonic oscillation under current-mode control regardless of $D$; thus its prediction is “no subharmonic oscillation.”\n\nError metrics:\n- Ripple error is $|\\Delta i_{L,\\text{switch}} - \\Delta i_{L,\\text{avg}}| = \\Delta i_{L,\\text{switch}}$, expressed in amperes and rounded to six decimal places.\n- Subharmonic mismatch is a boolean equal to True if the switching model predicts subharmonic oscillation ($|\\lambda| > 1$) and False otherwise, because the averaged model always predicts False.\n\nAlgorithmic steps for each test case $(v_{\\text{in}}, L, C, R, f_{s}, D, m_{a})$:\n1. Compute $T = \\frac{1}{f_{s}}$ and $v_{o} = D \\, v_{\\text{in}}$.\n2. Compute $m_{1} = \\frac{v_{\\text{in}} - v_{o}}{L} = \\frac{v_{\\text{in}} (1 - D)}{L}$ and $m_{2} = \\frac{v_{o}}{L} = \\frac{v_{\\text{in}} D}{L}$.\n3. Compute switching-model ripple amplitude $\\Delta i_{L,\\text{switch}} = m_{1} D T$.\n4. Compute perturbation growth factor $\\lambda = 1 - \\frac{m_{1} + m_{2}}{m_{1} + m_{a}}$ and decide subharmonic presence with the condition $|\\lambda| > 1$.\n5. Set averaged-model ripple to $0$ and averaged-model subharmonic to False.\n6. Compute ripple error as $\\Delta i_{L,\\text{switch}}$ (round to six decimal places) and subharmonic mismatch as the switching-model subharmonic decision.\n\nThe program implements these steps for the provided test suite and prints a single line: a comma-separated list enclosed in square brackets, containing a two-element list per test case in the form $[\\text{ripple\\_error\\_A},\\text{subharmonic\\_mismatch}]$ without spaces.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef switching_ripple(vin, L, fs, D):\n    \"\"\"\n    Compute peak-to-valley inductor current ripple amplitude for a buck converter\n    under ideal switching using slopes and duty ratio.\n\n    Δi = m1 * D * T, with m1 = (vin - vo)/L and vo = D * vin.\n    \"\"\"\n    T = 1.0 / fs\n    vo = D * vin\n    m1 = (vin - vo) / L\n    delta_i = m1 * D * T\n    return delta_i\n\ndef perturbation_growth_factor(vin, L, D, m_a):\n    \"\"\"\n    Compute the sampled perturbation growth factor λ for peak current-mode control\n    with optional slope compensation m_a (A/s).\n\n    λ = 1 - (m1 + m2) / (m1 + m_a), with m1 = (vin - vo)/L, m2 = vo/L, vo = D*vin.\n    \"\"\"\n    vo = D * vin\n    m1 = (vin - vo) / L\n    m2 = vo / L\n    # Avoid division by zero: if m1 + m_a == 0, define λ -> +inf to indicate instability.\n    denom = m1 + m_a\n    if denom == 0:\n        return np.inf\n    lam = 1.0 - (m1 + m2) / denom\n    return lam\n\ndef analyze_case(case):\n    vin, L, C, R, fs, D, m_a = case\n    # Switching model predictions\n    ripple_switch = switching_ripple(vin, L, fs, D)\n    lam = perturbation_growth_factor(vin, L, D, m_a)\n    subharmonic_switch = abs(lam) > 1.0  # strict inequality for D>0.5 criterion\n    # Averaged model predictions\n    ripple_avg = 0.0\n    subharmonic_avg = False\n    # Errors\n    ripple_error = ripple_switch - ripple_avg\n    # Round ripple error to six decimal places\n    ripple_error = round(ripple_error, 6)\n    subharmonic_mismatch = (subharmonic_switch != subharmonic_avg)\n    return ripple_error, subharmonic_mismatch\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (vin, L, C, R, fs, D, m_a)\n        (24.0, 100e-6, 470e-6, 4.0, 100e3, 0.6, 0.0),       # Case 1: happy path, D>0.5, no compensation\n        (24.0, 100e-6, 470e-6, 4.0, 100e3, 0.5, 0.0),       # Case 2: boundary, D=0.5, no compensation\n        (24.0, 100e-6, 470e-6, 4.0, 100e3, 0.7, 60e3),      # Case 3: compensated edge case, D>0.5\n    ]\n\n    results = []\n    for case in test_cases:\n        ripple_error, mismatch = analyze_case(case)\n        # Build string for [float,bool] with no spaces\n        pair_str = f\"[{ripple_error},{str(mismatch)}]\"\n        results.append(pair_str)\n\n    # Final print statement in the exact required format (no spaces).\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "After selecting a high-fidelity model, the next challenge is to solve its governing differential equations accurately and stably in real time. Power electronic circuits are often numerically \"stiff\" due to the wide separation of time constants, which can cause explicit solvers to fail. This practice guides you through the process of selecting a suitable implicit numerical integration scheme and an appropriate time step, $T_s$, to ensure the simulation of a stiff $LC$ filter remains stable and avoids numerical blow-up. ",
            "id": "3845343",
            "problem": "You are emulating a stiff and lightly damped series $LC$ network inside a hardware-in-the-loop (HIL) test of a power converter. The $LC$ network stands in for the passive power stage filter under test and must be integrated numerically in real time without blow-up. Starting solely from circuit laws and standard numerical method definitions, your task is to construct implicit one-step integration schemes, assess their discrete-time stability and numerical conditioning, and select a scheme and sample period that prevent divergence while remaining computationally efficient.\n\nThe physical plant is a series resistor-inductor-capacitor branch with current $i(t)$ through the branch and capacitor voltage $v_C(t)$. Use Kirchhoff’s Voltage Law and the capacitor current-voltage relation as the fundamental base:\n- $L \\dfrac{di(t)}{dt} + R\\,i(t) + v_C(t) = 0$,\n- $\\dfrac{dv_C(t)}{dt} = \\dfrac{i(t)}{C}$,\nwhere $R$ is resistance in $\\Omega$, $L$ is inductance in $\\mathrm{H}$, and $C$ is capacitance in $\\mathrm{F}$. Let the state be $x(t) = \\begin{bmatrix} i(t) \\\\ v_C(t) \\end{bmatrix}$, and write the dynamics as $\\dfrac{dx(t)}{dt} = A\\,x(t)$, where $A$ is a constant matrix determined by $R$, $L$, and $C$.\n\nConstruct two implicit integration schemes over a fixed sample period $T_s$:\n- Backward Euler, defined by evaluating the time derivative at $t_{k+1}$.\n- Trapezoidal rule, defined by a trapezoidal approximation to the state integral over $[t_k, t_{k+1}]$.\n\nFor each scheme, derive the corresponding discrete-time state transition of the form $x_{k+1} = M\\,x_k$ where $M$ is a $2\\times 2$ matrix that depends on $A$ and $T_s$. Assess numerical stability via the spectral radius $\\rho(M)$ and require $\\rho(M) \\leq 1$ to declare “no blow-up.” Assess numerical solvability via the $2$-norm condition number of the linear system matrix that must be inverted inside each implicit step, and require the condition number to be less than or equal to a prescribed bound $\\kappa_{\\max}$.\n\nDesign an algorithm that, for each test case below, chooses:\n- an implicit scheme (encode as $0$ for Backward Euler and $1$ for Trapezoidal rule),\n- the largest sample period $T_s$ (in seconds) from a given candidate set that simultaneously satisfies $\\rho(M) \\leq 1$ and the condition-number bound.\n\nAdditionally, incorporate the following scheme-preference policy to reflect low-damping resonance behavior: if the system’s continuous-time eigenvalues have a small ratio of real to imaginary parts, prefer the trapezoidal rule (energy-preserving behavior) unless its condition number bound is violated, in which case fall back to Backward Euler; otherwise prefer Backward Euler (numerical damping) unless its condition bound is violated, in which case try trapezoidal.\n\nUse the following constants and candidate sample periods:\n- Condition-number bound $\\kappa_{\\max} = 10^{8}$.\n- Candidate sample periods $T_s \\in \\{ 1\\times 10^{-7}, 5\\times 10^{-7}, 1\\times 10^{-6}, 5\\times 10^{-6}, 1\\times 10^{-5}, 5\\times 10^{-5}, 1\\times 10^{-4} \\}$ seconds.\n- Define the “low-damping” preference threshold by the ratio $\\beta = \\dfrac{\\max\\limits_i |\\Re(\\lambda_i(A))|}{\\max\\limits_i |\\Im(\\lambda_i(A))|}$ with the rule “prefer trapezoidal if $\\beta \\leq 10^{-2}$.”\n\nTest suite: evaluate your algorithm on the following parameter sets, all expressed in SI units:\n- Case $1$: $L = 1\\times 10^{-6}\\,\\mathrm{H}$, $C = 1\\times 10^{-5}\\,\\mathrm{F}$, $R = 1\\times 10^{-2}\\,\\Omega$.\n- Case $2$: $L = 1\\times 10^{-3}\\,\\mathrm{H}$, $C = 1\\times 10^{-6}\\,\\mathrm{F}$, $R = 0\\,\\Omega$.\n- Case $3$: $L = 1\\times 10^{-5}\\,\\mathrm{H}$, $C = 1\\times 10^{-7}\\,\\mathrm{F}$, $R = 1\\times 10^{-1}\\,\\Omega$.\n- Case $4$: $L = 1\\times 10^{-7}\\,\\mathrm{H}$, $C = 1\\times 10^{-7}\\,\\mathrm{F}$, $R = 1\\times 10^{-4}\\,\\Omega$.\n\nAngle units are not required in this problem. All sample periods must be expressed in seconds. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each result must be a two-element list of the form $[\\text{scheme\\_id}, T_s]$ with the numerical $T_s$ value in seconds, for example, $[[0,1\\times 10^{-6}],[1,5\\times 10^{-5}],\\dots]$. The outputs for all cases must be aggregated in order of the listed cases into one such top-level list printed on a single line.",
            "solution": "The problem requires the design of an algorithm to select an optimal implicit integration scheme and sample period for the real-time simulation of a stiff, lightly-damped series RLC circuit. The selection must satisfy constraints on numerical stability and computational conditioning.\n\nFirst, we establish the continuous-time state-space model of the RLC circuit. The governing differential equations are given by Kirchhoff's Voltage Law and the capacitor's constitutive relation:\n$$\nL \\frac{di(t)}{dt} + R\\,i(t) + v_C(t) = 0\n$$\n$$\n\\frac{dv_C(t)}{dt} = \\frac{i(t)}{C}\n$$\nDefining the state vector as $x(t) = \\begin{bmatrix} i(t) \\\\ v_C(t) \\end{bmatrix}$, we can rearrange these equations into the standard state-space form $\\frac{dx(t)}{dt} = A\\,x(t)$. The first equation gives $\\frac{di}{dt} = -\\frac{R}{L}i(t) - \\frac{1}{L}v_C(t)$. The second equation is $\\frac{dv_C}{dt} = \\frac{1}{C}i(t) + 0 \\cdot v_C(t)$. Thus, the state matrix $A$ is:\n$$\nA = \\begin{bmatrix} -R/L & -1/L \\\\ 1/C & 0 \\end{bmatrix}\n$$\nNext, we derive the discrete-time state transition matrices for the two specified implicit integration schemes over a sample period $T_s$. The discrete-time system has the form $x_{k+1} = M x_k$, where $x_k = x(kT_s)$.\n\nFor the Backward Euler (BE) scheme, the derivative is approximated at the future time step $t_{k+1}$:\n$$\n\\frac{x_{k+1} - x_k}{T_s} = A x_{k+1}\n$$\nTo find the state transition matrix $M_{BE}$, we solve for $x_{k+1}$:\n$$\nx_k = x_{k+1} - T_s A x_{k+1} = (I - T_s A) x_{k+1}\n$$\n$$\nx_{k+1} = (I - T_s A)^{-1} x_k\n$$\nwhere $I$ is the $2 \\times 2$ identity matrix. The state transition matrix is $M_{BE} = (I - T_s A)^{-1}$. The implementation of this implicit step requires solving a linear system with the matrix $S_{BE} = I - T_s A$. The numerical conditioning of this matrix is a key constraint.\n\nFor the Trapezoidal Rule (TR), the state integral is approximated over the interval $[t_k, t_{k+1}]$:\n$$\nx_{k+1} - x_k = \\frac{T_s}{2} (A x_k + A x_{k+1})\n$$\nSolving for $x_{k+1}$:\n$$\nx_{k+1} - \\frac{T_s}{2} A x_{k+1} = x_k + \\frac{T_s}{2} A x_k\n$$\n$$\n\\left(I - \\frac{T_s}{2} A\\right) x_{k+1} = \\left(I + \\frac{T_s}{2} A\\right) x_k\n$$\n$$\nx_{k+1} = \\left(I - \\frac{T_s}{2} A\\right)^{-1} \\left(I + \\frac{T_s}{2} A\\right) x_k\n$$\nThe state transition matrix is $M_{TR} = (I - \\frac{T_s}{2} A)^{-1} (I + \\frac{T_s}{2} A)$. This step requires solving a linear system involving the matrix $S_{TR} = I - \\frac{T_s}{2} A$.\n\nThe stability of the discrete-time system is determined by the spectral radius, $\\rho(M)$, of the transition matrix. The condition for preventing blow-up is $\\rho(M) \\leq 1$. The eigenvalues of the continuous-time matrix $A$ are $\\lambda_i(A) = -\\frac{R}{2L} \\pm \\sqrt{(\\frac{R}{2L})^2 - \\frac{1}{LC}}$. For any physical passive RLC circuit, $R \\ge 0$, $L > 0$, and $C > 0$, which ensures that the real parts of the eigenvalues are non-positive, $\\Re(\\lambda_i(A)) \\le 0$. Both Backward Euler and Trapezoidal methods are A-stable, meaning their region of absolute stability includes the entire left half of the complex plane. Consequently, for any system with $\\Re(\\lambda_i(A)) \\le 0$, both schemes will produce a stable discrete-time system with $\\rho(M) \\leq 1$ for any choice of $T_s > 0$. Thus, the stability constraint is always satisfied.\n\nThe primary algorithmic constraint is numerical solvability, assessed by the $2$-norm condition number of the matrix inverted at each step. We require $\\kappa_2(S) \\leq \\kappa_{\\max} = 10^8$, where $S$ is either $S_{BE}$ or $S_{TR}$.\n\nThe algorithm must also implement a scheme-preference policy. For underdamped systems, where the eigenvalues of $A$ are complex, the ratio $\\beta = \\frac{\\max_i |\\Re(\\lambda_i(A))|}{\\max_i |\\Im(\\lambda_i(A))|}$ quantifies the damping relative to the oscillation frequency. If $\\beta \\leq 10^{-2}$ (low damping), the Trapezoidal rule (scheme ID $1$), which is energy-preserving for purely oscillatory systems, is preferred. Otherwise, the Backward Euler method (scheme ID $0$), which introduces numerical damping, is preferred. This preference is honored unless the preferred scheme's condition number exceeds $\\kappa_{\\max}$, in which case the algorithm falls back to the other scheme.\n\nThe final algorithm is as follows:\nFor each given set of parameters $(L, C, R)$:\n1. Construct the state matrix $A = \\begin{bmatrix} -R/L & -1/L \\\\ 1/C & 0 \\end{bmatrix}$.\n2. Compute the eigenvalues of $A$ and determine the scheme preference order (e.g., $[1, 0]$ for TR-preferred, $[0, 1]$ for BE-preferred) based on the $\\beta$ ratio. If eigenvalues are real ($\\Im(\\lambda_i) = 0$), BE is preferred.\n3. Iterate through the candidate sample periods $T_s$ in descending order, from $10^{-4}$ down to $10^{-7}$ seconds.\n4. For each $T_s$, test the schemes in their order of preference.\n5. For the current scheme, form the corresponding system matrix $S$ (either $S_{BE}$ or $S_{TR}$).\n6. Calculate the $2$-norm condition number $\\kappa_2(S)$.\n7. If $\\kappa_2(S) \\leq \\kappa_{\\max}$, this pair of (scheme, $T_s$) is the solution for the current test case. Record the result and proceed to the next case.\n8. If the preferred scheme fails the condition number test, evaluate the fallback scheme with the same $T_s$. If it passes, it becomes the solution. If both fail, move to the next smaller $T_s$.\n\nThis procedure guarantees finding the largest valid sample period and the corresponding choice of scheme according to the specified rules.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Selects an integration scheme and the largest possible sample period for\n    simulating an RLC circuit based on stability and conditioning constraints.\n    \"\"\"\n    # Define constants and problem parameters from the statement.\n    kappa_max = 1e8\n    ts_candidates = [1e-7, 5e-7, 1e-6, 5e-6, 1e-5, 5e-5, 1e-4]\n    beta_threshold = 1e-2\n\n    # Define the test cases from the problem statement.\n    # Each tuple is (L, C, R) in SI units.\n    test_cases = [\n        (1e-6, 1e-5, 1e-2),  # Case 1\n        (1e-3, 1e-6, 0.0),   # Case 2\n        (1e-5, 1e-7, 1e-1),  # Case 3\n        (1e-7, 1e-7, 1e-4),  # Case 4\n    ]\n\n    all_results = []\n    \n    # Process each test case\n    for L, C, R in test_cases:\n        # Construct the continuous-time state matrix A\n        A = np.array([[-R/L, -1/L], [1/C, 0.0]])\n        \n        # Determine the scheme preference based on system eigenvalues\n        eigvals_A = np.linalg.eigvals(A)\n        max_re = np.max(np.abs(np.real(eigvals_A)))\n        max_im = np.max(np.abs(np.imag(eigvals_A)))\n\n        # A small tolerance for floating point comparisons of max_im\n        if max_im < 1e-12:\n            # Overdamped or critically damped: prefer Backward Euler (BE)\n            pref_order = [0, 1]  # 0: BE, 1: Trapezoidal (TR)\n        else:\n            beta = max_re / max_im\n            if beta <= beta_threshold:\n                # Lightly damped: prefer Trapezoidal rule (TR)\n                pref_order = [1, 0]\n            else:\n                # Damped enough: prefer Backward Euler (BE)\n                pref_order = [0, 1]\n        \n        # Iterate through sample periods from largest to smallest to find the optimal Ts\n        found_solution = False\n        for ts in sorted(ts_candidates, reverse=True):\n            # Check schemes in order of preference\n            for scheme_id in pref_order:\n                # Form the matrix S for the linear system in the implicit step\n                if scheme_id == 0:  # Backward Euler\n                    S = np.identity(2) - ts * A\n                else:  # Trapezoidal Rule\n                    S = np.identity(2) - (ts / 2.0) * A\n                \n                # Check the condition number against the maximum allowed value\n                if np.linalg.cond(S, 2) <= kappa_max:\n                    # Stability check is theoretically guaranteed for A-stable methods\n                    # on passive systems, but it's good practice to confirm.\n                    if scheme_id == 0:\n                        M = np.linalg.inv(S)\n                    else:\n                        M = np.linalg.inv(S) @ (np.identity(2) + (ts / 2.0) * A)\n                    \n                    rho_M = np.max(np.abs(np.linalg.eigvals(M)))\n\n                    # Use a small tolerance for floating point comparison of spectral radius\n                    if rho_M <= 1.0 + 1e-9:\n                        all_results.append([scheme_id, ts])\n                        found_solution = True\n                        break  # Break from the inner loop (schemes)\n            \n            if found_solution:\n                break  # Break from the outer loop (Ts)\n\n    # Final print statement in the exact required format.\n    # Python's default str() for lists and floats is used.\n    # The required format is [[0,1e-06],[1,5e-05],...] which map(str,...) and join will not produce\n    # so we need a more specific formatter.\n    result_strings = [f\"[{res[0]},{res[1]}]\" for res in all_results]\n    print(f\"[{','.join(result_strings)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "The fidelity of an HIL simulation depends not only on the model and solver but also on the physical hardware interfaces connecting the simulator to the device under test. These interfaces have finite resolution, which can limit the accuracy of the test. This exercise focuses on a critical output interface, the Pulse Width Modulation (PWM) generator, and asks you to calculate the necessary timer resolution and clock frequency, $f_{clk}$, to achieve a specified duty cycle precision. This demonstrates how to translate a system-level fidelity requirement into a concrete hardware specification. ",
            "id": "3845360",
            "problem": "A real-time Hardware-In-the-Loop (HIL) platform is used to test the closed-loop behavior of a digitally controlled direct-current to direct-current power converter. The Pulse Width Modulation (PWM) gating signal is synthesized by a timer peripheral on the HIL target. To ensure that the controller can impose duty-cycle changes that are no larger than a specified resolution, the HIL timer must provide sufficient time quantization over one switching period. The switching frequency is fixed at $f_{sw} = 50~\\text{kHz}$. The PWM duty cycle $D$ is defined by the ratio of the on-time $t_{on}$ to the switching period $T_{sw}$, that is $D = t_{on}/T_{sw}$. The timer generates $t_{on}$ in discrete increments equal to the timer clock period, which we call the time resolution $t_{res}$. \n\nFor HIL fidelity, the required worst-case duty-cycle increment is $0.1\\%$ of full scale. Starting from the definitions of $T_{sw}$ and $D$, and the quantization relation imposed by $t_{res}$, determine the minimum time resolution $t_{res}$ that guarantees a duty-cycle increment of $0.1\\%$ at $f_{sw} = 50~\\text{kHz}$, and then compute the corresponding minimum timer clock frequency $f_{clk}$ that achieves this time resolution. \n\nExpress the time resolution in nanoseconds and the timer clock frequency in megahertz. Provide exact values; no rounding is required. Report your final answer as a row matrix where the first entry is the time resolution in nanoseconds and the second entry is the timer clock frequency in megahertz.",
            "solution": "The switching period is given by the reciprocal of the switching frequency. Using the fundamental definition,\n$$\nT_{sw} = \\frac{1}{f_{sw}}.\n$$\nThe duty cycle $D$ is defined as\n$$\nD = \\frac{t_{on}}{T_{sw}},\n$$\nwhere $t_{on}$ is the on-time of the PWM within one switching period. In a digital implementation, $t_{on}$ can change only in discrete increments set by the timer’s clock period. Let $t_{res}$ denote the timer’s time resolution (the smallest possible increment of $t_{on}$). Then the smallest achievable change in duty cycle, $\\Delta D$, is determined by the ratio of one time-resolution step to the switching period:\n$$\n\\Delta D = \\frac{t_{res}}{T_{sw}}.\n$$\nTo guarantee that the duty-cycle resolution is at most $0.1\\%$, we require\n$$\n\\Delta D \\leq 0.001,\n$$\nsince $0.1\\%$ corresponds to the decimal fraction $0.001$. Imposing equality to find the minimum required resolution,\n$$\n\\frac{t_{res}}{T_{sw}} = 0.001 \\quad \\Rightarrow \\quad t_{res} = 0.001\\, T_{sw}.\n$$\nSubstituting $T_{sw}$ from the switching frequency $f_{sw} = 50~\\text{kHz}$,\n$$\nT_{sw} = \\frac{1}{50 \\times 10^{3}}~\\text{s} = 20 \\times 10^{-6}~\\text{s}.\n$$\nTherefore,\n$$\nt_{res} = 0.001 \\times 20 \\times 10^{-6}~\\text{s} = 20 \\times 10^{-9}~\\text{s}.\n$$\nThus the required time resolution is $20~\\text{ns}$. \n\nThe timer clock frequency $f_{clk}$ is the reciprocal of the time resolution, since each clock tick corresponds to one $t_{res}$:\n$$\nf_{clk} = \\frac{1}{t_{res}} = \\frac{1}{20 \\times 10^{-9}~\\text{s}} = 50 \\times 10^{6}~\\text{Hz}.\n$$\nExpressed in megahertz, this is\n$$\nf_{clk} = 50~\\text{MHz}.\n$$\nHence, the minimum time resolution is $20~\\text{ns}$ and the corresponding minimum timer clock frequency is $50~\\text{MHz}$.",
            "answer": "$$\\boxed{\\begin{pmatrix}20 & 50\\end{pmatrix}}$$"
        }
    ]
}