{
    "hands_on_practices": [
        {
            "introduction": "本练习旨在奠定三次谐波注入技术的理论基石。通过严格的解析推导，我们将确定在给定的三次谐波注入量 $k$ 下，基波调制指数 $m$ 所能达到的最大值。这个过程不仅能揭示该技术如何在不引起过调制的条件下提高直流母线电压利用率，还能锻炼在分析高级调制策略时至关重要的微积分与三角函数分析能力。",
            "id": "3886113",
            "problem": "考虑一个三相电压源逆变器（VSI），它为a相实现了带有三次谐波注入的正弦脉冲宽度调制（SPWM）。其归一化相参考电压由下式给出\n$$\nv_a^{*}(t) = m \\sin(\\omega t) + k \\sin(3 \\omega t),\n$$\n其中 $m$ 是基波调制幅度，$k > 0$ 是固定的三次谐波注入幅度，$\\omega$ 是角频率。角度以弧度为单位。归一化直流（DC）母线电压为单位1，为避免过调制，参考电压必须满足\n$$\n|v_a^{*}(t)| \\leq 1 \\quad \\text{for all } t.\n$$\n从微积分基本原理和三角恒等式出发，推导下列表达式的闭式表达式：\n$$\n\\max_{t} v_a^{*}(t) \\quad \\text{and} \\quad \\min_{t} v_a^{*}(t),\n$$\n除了 $k > 0$ 外，不假设 $m$ 和 $k$ 之间有任何特殊关系。利用这些极值，求出使得 $|v_a^{*}(t)| \\leq 1$ 对所有 $t$ 成立的、作为 $k$ 的函数的最大允许基波调制幅度 $m$ 的闭式表达式。将你的最终界限 $m_{\\max}(k)$ 表示为单个解析表达式。不需要数值舍入，最终界限中不出现物理单位。",
            "solution": "问题是要求解在给定的三次谐波注入幅度 $k$ 下，允许的最大基波调制幅度 $m$，使得归一化相参考电压 $v_a^{*}(t)$ 不超过归一化的直流母线电压。\n\n归一化相参考电压由下式给出\n$$v_a^{*}(t) = m \\sin(\\omega t) + k \\sin(3 \\omega t)$$\n其约束条件为\n$$|v_a^{*}(t)| \\leq 1 \\quad \\text{for all } t.$$\n\n这等效于确保 $|v_a^{*}(t)|$ 的全局最大值小于或等于1。令 $V_{peak} = \\max_t |v_a^{*}(t)|$。我们必须找到 $V_{peak}$ 作为 $m$ 和 $k$ 的函数的表达式，然后求出使 $V_{peak} \\leq 1$ 成立的最大 $m$（记为 $m_{max}(k)$）。\n\n首先，我们推导 $v_a^{*}(t)$ 的最大值和最小值的表达式。令 $x = \\omega t$。由于 $t$ 遍历所有实数，$\\sin(\\omega t)$ 将遍历其完整范围 $[-1, 1]$。我们可以通过令 $s = \\sin(x) = \\sin(\\omega t)$ 来分析该函数，其中 $s \\in [-1, 1]$。使用正弦的三倍角恒等式 $\\sin(3x) = 3\\sin(x) - 4\\sin^3(x)$，我们可以将 $v_a^{*}(t)$ 重写为 $s$ 的函数：\n$$g(s) = m s + k (3s - 4s^3) = (m+3k)s - 4ks^3$$\n我们需要找到 $g(s)$ 在 $s \\in [-1, 1]$ 上的极值。极值可能出现在区间的边界（$s = \\pm 1$）或导数为零的区间内部临界点处。\n\n$g(s)$ 关于 $s$ 的导数是：\n$$g'(s) = \\frac{d}{ds} \\left( (m+3k)s - 4ks^3 \\right) = m+3k - 12ks^2$$\n令导数为零以求临界点 $s_c$：\n$$m+3k - 12ks_c^2 = 0 \\implies s_c^2 = \\frac{m+3k}{12k}$$\n为了使这些临界点是实数且位于区间 $s \\in [-1, 1]$ 内，必须有 $0 \\leq s_c^2 \\leq 1$。\n因为 $m \\geq 0$ 且 $k > 0$，所以 $m+3k > 0$，因此 $s_c^2 > 0$ 总是满足的。\n条件 $s_c^2 \\leq 1$ 意味着：\n$$\\frac{m+3k}{12k} \\leq 1 \\implies m+3k \\leq 12k \\implies m \\leq 9k$$\n\n我们必须基于此条件分析两种情况。\n\n情况1：$0 \\leq m \\leq 9k$。\n在这种情况下，临界点 $s_c = \\pm\\sqrt{\\frac{m+3k}{12k}}$ 位于区间 $[-1, 1]$ 内。可能的极值是 $g(s)$ 在这些临界点和边界点 $s = \\pm 1$ 处的值。\n在临界点处的值：\n$$g(s_c) = (m+3k)s_c - 4ks_c^3 = s_c \\left( (m+3k) - 4ks_c^2 \\right)$$\n$$g(s_c) = s_c \\left( (m+3k) - 4k \\frac{m+3k}{12k} \\right) = s_c \\left( (m+3k) - \\frac{m+3k}{3} \\right) = \\frac{2}{3}(m+3k)s_c$$\n代入 $s_c = \\pm\\sqrt{\\frac{m+3k}{12k}}$：\n$$g(s_c) = \\pm \\frac{2}{3}(m+3k) \\sqrt{\\frac{m+3k}{12k}} = \\pm \\frac{2(m+3k)^{3/2}}{3\\sqrt{12k}} = \\pm \\frac{2(m+3k)^{3/2}}{3 \\cdot 2\\sqrt{3k}} = \\pm \\frac{(m+3k)^{3/2}}{3\\sqrt{3k}}$$\n在边界处的值：\n$$g(1) = (m+3k) - 4k = m-k$$\n$$g(-1) = -(m+3k) + 4k = -m+k = -(m-k)$$\n为了确定这种情况下的全局最大值，我们比较 $|m-k|$ 与 $\\frac{(m+3k)^{3/2}}{3\\sqrt{3k}}$。让我们比较它们的平方：\n$$(m-k)^2 \\quad \\text{vs.} \\quad \\left(\\frac{(m+3k)^{3/2}}{3\\sqrt{3k}}\\right)^2 = \\frac{(m+3k)^3}{27k}$$\n考虑其差值：\n$$\\frac{(m+3k)^3}{27k} - (m-k)^2 = \\frac{1}{27k} \\left[ (m+3k)^3 - 27k(m-k)^2 \\right]$$\n方括号中的项是：\n$$(m^3 + 9km^2 + 27k^2m + 27k^3) - 27k(m^2 - 2mk + k^2) = m^3 - 18km^2 + 81k^2m = m(m^2 - 18km + 81k^2) = m(m-9k)^2$$\n由于 $m \\ge 0$ 且 $(m-9k)^2 \\ge 0$，这个差值是非负的。因此，对于 $0 \\leq m \\leq 9k$：\n$$\\frac{(m+3k)^{3/2}}{3\\sqrt{3k}} \\geq |m-k|$$\n等号在 $m=0$ 和 $m=9k$ 时成立。\n因此，对于 $0 \\leq m \\leq 9k$，极值为 $\\pm \\frac{(m+3k)^{3/2}}{3\\sqrt{3k}}$。\n\n情况2：$m > 9k$。\n在这种情况下，$s_c^2 = \\frac{m+3k}{12k} > 1$，所以临界点位于区间 $[-1, 1]$ 之外。函数 $g(s)$ 在 $[-1, 1]$ 上是单调的，因为其导数 $g'(s) = m+3k - 12ks^2$ 在 $(-1, 1)$ 上符号不变。因此，极值必定出现在边界 $s = \\pm 1$ 处。\n值为 $g(1) = m-k$ 和 $g(-1) = k-m$。\n由于 $m > 9k > k$，$m-k$ 是正数，所以最大值是 $m-k$，最小值是 $k-m$。\n\n综合两种情况，我们得到 $v_a^*(t)$ 的最大值和最小值的闭式表达式：\n$$\\max_{t} v_a^{*}(t) = \\begin{cases} \\frac{(m+3k)^{3/2}}{3\\sqrt{3k}}  \\text{if } 0 \\le m \\le 9k \\\\ m-k  \\text{if } m > 9k \\end{cases}$$\n$$\\min_{t} v_a^{*}(t) = -\\max_{t} v_a^{*}(t) = \\begin{cases} -\\frac{(m+3k)^{3/2}}{3\\sqrt{3k}}  \\text{if } 0 \\le m \\le 9k \\\\ k-m  \\text{if } m > 9k \\end{cases}$$\n\n现在，我们通过将峰值绝对值设为1来求出允许的最大幅度 $m_{max}(k)$。\n令 $V_{peak}(m, k) = \\max_{t} |v_a^*(t)| = \\max_{t} v_a^{*}(t)$。我们对 $m$ 求解方程 $V_{peak}(m, k) = 1$。\n\n我们在过渡点 $m=9k$ 处评估峰值电压：\n$V_{peak}(9k, k) = 9k-k = 8k$.\n我们可以根据此过渡值是小于1还是大于1来区分两种情形。\n\n情形 A：解 $m_{max}$ 满足 $m_{max} > 9k$。\n这种情况在 $V_{peak}(9k, k) < 1$ 时发生，即 $8k < 1$，或 $k < 1/8$。\n在此范围内，我们求解 $m_{max} - k = 1$，得到 $m_{max} = 1+k$。\n该解是一致的，因为 $m_{max} = 1+k > 9k \\iff 1 > 8k \\iff k < 1/8$。\n所以，对于 $0 < k < 1/8$，最大幅度是 $m_{max}(k) = 1+k$。\n\n情形 B：解 $m_{max}$ 满足 $0 \\le m_{max} \\le 9k$。\n这种情况在 $V_{peak}(9k, k) \\ge 1$ 时发生，即 $8k \\ge 1$，或 $k \\ge 1/8$。\n在此范围内，我们求解 $\\frac{(m_{max}+3k)^{3/2}}{3\\sqrt{3k}} = 1$。\n$$(m_{max}+3k)^{3/2} = 3\\sqrt{3k} = (27k)^{1/2}$$\n将两边都取 $2/3$ 次方：\n$$m_{max}+3k = \\left((27k)^{1/2}\\right)^{2/3} = (27k)^{1/3} = 3k^{1/3}$$\n$$m_{max} = 3k^{1/3} - 3k$$\n如果该解满足 $0 \\le m_{max} \\le 9k$，则它是一致的。\n$m_{max} \\le 9k \\implies 3k^{1/3} - 3k \\le 9k \\implies 3k^{1/3} \\le 12k \\implies k^{1/3} \\le 4k \\implies k \\le 64k^3 \\implies 1 \\le 64k^2 \\implies k^2 \\ge 1/64 \\implies k \\ge 1/8$。\n$m_{max} \\ge 0 \\implies 3k^{1/3} - 3k \\ge 0 \\implies k^{1/3} \\ge k \\implies k \\ge k^3 \\implies 1 \\ge k^2 \\implies k \\le 1$。\n所以，对于 $1/8 \\le k \\le 1$，最大幅度是 $m_{max}(k) = 3k^{1/3} - 3k$。对于 $k>1$，$m_{max}$ 将为负，意味着没有正数 $m$ 能满足该约束。\n\n结合这些结果，我们得到 $m_{max}(k)$ 的最终表达式，它是一个单一的分段解析函数：\n$$m_{max}(k) = \\begin{cases} 1+k  \\text{if } 0 < k < \\frac{1}{8} \\\\ 3k^{1/3} - 3k  \\text{if } k \\ge \\frac{1}{8} \\end{cases}$$\n问题暗示存在物理上有意义的 $m>0$ 的解，这要求 $k \\le 1$。该表达式对 $k \\ge 1/8$ 成立。",
            "answer": "$$\n\\boxed{\nm_{\\max}(k) = \\begin{cases} 1+k & \\text{if } 0 < k < \\frac{1}{8} \\\\ 3k^{1/3} - 3k & \\text{if } k \\ge \\frac{1}{8} \\end{cases}\n}\n$$"
        },
        {
            "introduction": "从连续时间理论转向数字域，本练习专注于技术的具体实现。我们将开发一个高效的算法，利用递推关系式来生成三次谐波信号，这是数字信号处理中的一种经典技巧。我们还将探究在任何基于微控制器的系统中都存在的有限精度效应，如饱和和量化，对信号质量的实际影响。",
            "id": "3886071",
            "problem": "考虑一个采用带三次谐波注入的正弦脉宽调制（SPWM）的三相电压源逆变器（VSI）。零序分量被定义为一个连续时间正弦波，其频率为电角频率的三倍，并按一个幅值比例进行缩放。离散时间任务是仅使用相位累加和三角递推来计算每个样本的零序注入，然后应用饱和和量化，最后计算性能指标。角度单位必须是弧度，电压单位必须是伏特。\n\n起点和定义：\n- 设基波电角频率为 $\\omega$（单位 $\\text{rad/s}$），采样周期为 $T_s$（单位 $\\text{s}$），采样点数为 $N$。\n- 每个样本的离散时间相位增量为 $\\theta = 3 \\omega T_s$。\n- 三次谐波注入的幅值比为 $k = 1/6$（无量纲）。\n- 理想的零序分量是一个频率为 $3\\omega$、幅值为 $k$ 的纯正弦波。\n- 每个样本的计算必须基于恒等式 $e^{j\\phi} = \\cos(\\phi) + j\\sin(\\phi)$ 以及通过乘以 $e^{j\\theta}$ 导出的递推关系，避免在 $nT_s$ 处进行任何直接的闭式求值。\n- 量化使用中踏步均匀量化器进行，其有符号整数码的范围为 $\\left[-2^{B-1}, 2^{B-1}-1\\right]$，其中 $B$ 是比特数，$V_{\\text{fs}}$ 是满量程电压（单位：伏特）。量化器将饱和电压 $v$ 映射为一个码值 $q = \\operatorname{round}\\left(v \\cdot S\\right)$（裁剪到整数范围内），以及一个反量化电压 $v_q = q/S$，其中 $S = \\left(2^{B-1}-1\\right)/V_{\\text{fs}}$。\n- 饱和通过将任意样本 $v$ 钳位到 $v_{\\text{sat}} = \\max\\left(-V_{\\text{lim}}, \\min\\left(V_{\\text{lim}}, v\\right)\\right)$ 来执行，其中 $V_{\\text{lim}}$ 是饱和限制（单位：伏特）。如果钳位操作改变了样本的值，即钳位前 $\\lvert v \\rvert > V_{\\text{lim}}$，则称该样本“达到饱和”。\n\n算法要求：\n- 推导并实现一个递推关系，从 $\\phi_0 = 0$ 开始，仅使用 $\\theta$、$\\sin(\\theta)$ 和 $\\cos(\\theta)$ 来逐样本更新 $\\sin(\\phi_n)$ 和 $\\cos(\\phi_n)$。使用该关系计算带有幅值缩放 $k$ 的未饱和零序注入样本 $v[n]$。\n- 应用饱和限制 $V_{\\text{lim}}$ 生成 $v_{\\text{sat}}[n]$。\n- 使用 $B$ 比特和满量程 $V_{\\text{fs}}$ 对 $v_{\\text{sat}}[n]$ 进行量化，生成 $v_q[n]$。\n- 为每个测试用例计算并报告以下指标：\n  1. $v_{\\text{rms}} = \\sqrt{\\frac{1}{N}\\sum_{n=0}^{N-1} v_q[n]^2}$，单位为伏特，四舍五入到六位小数。\n  2. $n_{\\text{sat}} = \\sum_{n=0}^{N-1} \\mathbf{1}\\{\\lvert v[n] \\rvert > V_{\\text{lim}}\\}$，为整数计数。\n  3. $e_{\\text{q,rms}} = \\sqrt{\\frac{1}{N}\\sum_{n=0}^{N-1} \\left(v_q[n] - v_{\\text{sat}}[n]\\right)^2}$，单位为伏特，四舍五入到六位小数。\n\n测试套件：\n为以下参数集提供结果，这些参数集探讨了典型操作和边缘条件。所有角度单位均为弧度，所有电压单位均为伏特。\n- 情况 1：$\\omega = 2\\pi \\cdot 50$，$T_s = 1/20000$，$N = 400$，$B = 12$，$V_{\\text{fs}} = 1.0$，$V_{\\text{lim}} = 0.15$。\n- 情况 2：$\\omega = 0.999 \\cdot \\dfrac{\\pi}{3 T_s}$，其中 $T_s = 1/20000$，$N = 100$，$B = 8$，$V_{\\text{fs}} = 1.0$，$V_{\\text{lim}} = 1.0$。\n- 情况 3：$\\omega = 2\\pi \\cdot 1$，$T_s = 0.001$，$N = 1000$，$B = 10$，$V_{\\text{fs}} = 1.0$，$V_{\\text{lim}} = 1.0$。\n- 情况 4：$\\omega = 2\\pi \\cdot 60$，$T_s = 0.0001$，$N = 1000$，$B = 3$，$V_{\\text{fs}} = 0.2$，$V_{\\text{lim}} = 0.18$。\n- 情况 5：$\\omega = 2\\pi \\cdot 400$，$T_s = 0.0001$，$N = 5000$，$B = 12$，$V_{\\text{fs}} = 1.0$，$V_{\\text{lim}} = 1.0$。\n\n您的程序应生成单行输出，包含一个以逗号分隔的列表的列表形式的结果，格式严格如下：\n$[\\,[v_{\\text{rms},1},n_{\\text{sat},1},e_{\\text{q,rms},1}],[v_{\\text{rms},2},n_{\\text{sat},2},e_{\\text{q,rms},2}],\\dots,[v_{\\text{rms},5},n_{\\text{sat},5},e_{\\text{q,rms},5}]\\,]$，\n其中每个 $v_{\\text{rms},i}$ 和 $e_{\\text{q,rms},i}$ 都四舍五入到六位小数。",
            "solution": "用户的问题是有效的，因为它具有科学依据、定义明确且客观。它描述了电力电子领域中一个标准的数字信号处理任务，具体是为电压源逆变器（VSI）生成并分析三次谐波注入信号。所有参数都已定义，算法步骤清晰，所需指标基于标准公式。该问题是一个定义明确且具有唯一解的计算任务。\n\n解决方案分几步进行：推导信号生成算法、实现饱和和量化，最后计算指定的性能指标。\n\n### 1. 正弦波生成的递推关系推导\n\n问题要求生成一个角频率为 $3\\omega$、幅值为 $k$ 的正弦零序分量 $v(t)$。理想的连续时间信号是 $v_{ideal}(t) = k \\sin(3\\omega t)$。以采样周期 $T_s$ 对其进行离散化，样本为 $v[n] = v_{ideal}(nT_s) = k \\sin(3\\omega nT_s)$。\n\n设离散相位增量为 $\\theta = 3\\omega T_s$。在样本 $n$ 处的相位是 $\\phi_n = n\\theta$。我们需要迭代计算 $v[n] = k \\sin(n\\theta)$。问题要求采用基于复指数递推的方法，避免在循环内直接调用三角函数。\n\n考虑复数相量 $z_n = e^{j\\phi_n} = e^{jn\\theta}$。它可以写成直角坐标形式 $z_n = \\cos(n\\theta) + j\\sin(n\\theta)$。\n通过乘以一个常数相量 $e^{j\\theta}$，状态可以从样本 $n$ 更新到 $n+1$：\n$$z_{n+1} = e^{j(n+1)\\theta} = e^{jn\\theta} \\cdot e^{j\\theta} = z_n \\cdot e^{j\\theta}$$\n\n设 $c_n = \\cos(n\\theta)$ 和 $s_n = \\sin(n\\theta)$。将直角坐标形式代入递推关系得到：\n$$c_{n+1} + j s_{n+1} = (c_n + j s_n)(\\cos\\theta + j\\sin\\theta)$$\n展开右侧可得：\n$$c_{n+1} + j s_{n+1} = (c_n \\cos\\theta - s_n \\sin\\theta) + j(s_n \\cos\\theta + c_n \\sin\\theta)$$\n\n通过令实部和虚部分别相等，我们得到一对耦合的一阶递推关系：\n$$c_{n+1} = c_n \\cos\\theta - s_n \\sin\\theta$$\n$$s_{n+1} = s_n \\cos\\theta + c_n \\sin\\theta$$\n\n初始条件对应于 $n=0$，此时相位 $\\phi_0=0$：\n$$c_0 = \\cos(0) = 1$$\n$$s_0 = \\sin(0) = 0$$\n\n这些方程允许仅使用初始状态 $(c_0, s_0)$ 和预先计算的常数 $\\cos\\theta$ 和 $\\sin\\theta$ 来迭代计算 $\\sin(n\\theta)$ 和 $\\cos(n\\theta)$。所需的未饱和零序样本即为 $v[n] = k \\cdot s_n$。\n\n### 2. 算法实现\n\n对每个测试用例，执行以下步骤：\n\n**步骤 2.1：初始化**\n- 给定参数为 $\\omega$、$T_s$、$N$、$B$、$V_{\\text{fs}}$ 和 $V_{\\text{lim}}$。\n- 计算常数：\n  - 幅值比：$k = 1/6$。\n  - 离散相位增量：$\\theta = 3\\omega T_s$。\n  - 递推系数：$\\cos\\theta$ 和 $\\sin\\theta$。\n  - 量化器参数：\n    - 最大正码值：$q_{\\text{max}} = 2^{B-1}-1$。\n    - 最小负码值：$q_{\\text{min}} = -2^{B-1}$。\n    - 量化器缩放因子：$S = q_{\\text{max}} / V_{\\text{fs}}$。\n- 递推状态变量初始化为 $c_0=1.0$ 和 $s_0=0.0$。\n- 饱和事件计数器 $n_{\\text{sat}}$ 初始化为 $0$。\n- 准备数组以存储序列 $v[n]$、$v_{\\text{sat}}[n]$ 和 $v_q[n]$，其中 $n \\in [0, N-1]$。\n\n**步骤 2.2：逐样本处理循环**\n运行一个从 $n=0$ 到 $N-1$ 的循环来生成每个样本。\n\n1.  **生成未饱和信号：** 使用正弦递推的当前状态计算理想样本：\n    $$v[n] = k \\cdot s_n$$\n\n2.  **应用饱和：** 将未饱和样本 $v[n]$ 与饱和限制 $V_{\\text{lim}}$ 进行比较。\n    - 如果满足条件 $|v[n]| > V_{\\text{lim}}$，则饱和事件计数器递增：$n_{\\text{sat}} \\leftarrow n_{\\text{sat}} + 1$。\n    - 然后将样本钳位到范围 $[-V_{\\text{lim}}, V_{\\text{lim}}]$ 内，以产生饱和样本 $v_{\\text{sat}}[n]$：\n    $$v_{\\text{sat}}[n] = \\max(-V_{\\text{lim}}, \\min(V_{\\text{lim}}, v[n]))$$\n\n3.  **应用量化：** 对饱和样本 $v_{\\text{sat}}[n]$ 进行量化。\n    - 将样本缩放并四舍五入到最近的整数以获得初步码值：$q_{\\text{prelim}} = \\operatorname{round}(v_{\\text{sat}}[n] \\cdot S)$。\n    - 然后将此码值裁剪到允许的整数范围 $[q_{\\text{min}}, q_{\\text{max}}]$ 内：$q[n] = \\max(q_{\\text{min}}, \\min(q_{\\text{max}}, q_{\\text{prelim}}))$。\n    - 通过反向缩放获得最终的反量化电压：\n    $$v_q[n] = q[n] / S$$\n\n4.  **更新递推状态：** 使用推导出的递推关系将状态变量 $(c_n, s_n)$ 更新为 $(c_{n+1}, s_{n+1})$，为下一次迭代做准备。\n\n**步骤 2.3：性能指标计算**\n循环完成后，使用收集到的序列计算所需的指标。\n\n1.  **RMS 电压 ($v_{\\text{rms}}$)：** 计算最终反量化信号 $v_q[n]$ 的均方根值：\n    $$v_{\\text{rms}} = \\sqrt{\\frac{1}{N}\\sum_{n=0}^{N-1} v_q[n]^2}$$\n\n2.  **饱和计数 ($n_{\\text{sat}}$)：** 这是在循环期间累积的总计数。\n\n3.  **RMS 量化误差 ($e_{\\text{q,rms}}$)：** 计算反量化信号 $v_q[n]$ 与量化前（饱和）信号 $v_{\\text{sat}}[n]$ 之差的均方根值。这分离出了纯粹由量化步骤引入的误差。\n    $$e_{\\text{q,rms}} = \\sqrt{\\frac{1}{N}\\sum_{n=0}^{N-1} (v_q[n] - v_{\\text{sat}}[n])^2}$$\n\n计算出的 RMS 值按要求四舍五入到六位小数。对问题陈述中提供的五个测试用例中的每一个都重复此整个过程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef process_case(omega, Ts, N, B, V_fs, V_lim):\n    \"\"\"\n    Processes a single test case for the third-harmonic injection simulation.\n    \n    Args:\n        omega (float): Fundamental electrical angular frequency in rad/s.\n        Ts (float): Sampling period in s.\n        N (int): Number of samples.\n        B (int): Number of bits for quantization.\n        V_fs (float): Full-scale voltage for quantization in volts.\n        V_lim (float): Saturation voltage limit in volts.\n\n    Returns:\n        list: A list containing [v_rms, n_sat, e_q_rms].\n    \"\"\"\n    # 1. Initialization\n    K = 1/6\n    THETA = 3 * omega * Ts\n    COS_THETA = np.cos(THETA)\n    SIN_THETA = np.sin(THETA)\n    \n    # Quantizer parameters\n    q_max = 2**(B - 1) - 1\n    q_min = -2**(B - 1)\n    # Handle V_fs = 0 case to prevent division by zero, though not in test set\n    S = q_max / V_fs if V_fs != 0 else float('inf')\n\n    # Recurrence state variables\n    c_n = 1.0\n    s_n = 0.0\n\n    # Data storage and metrics initialization\n    vsat_vals = np.zeros(N, dtype=np.float64)\n    vq_vals = np.zeros(N, dtype=np.float64)\n    n_sat = 0\n\n    # 2. Per-Sample Processing Loop\n    for n in range(N):\n        # Generate unsaturated signal\n        v_n = K * s_n\n        \n        # Check for saturation (on the unsaturated signal)\n        if abs(v_n) > V_lim:\n            n_sat += 1\n            \n        # Apply saturation\n        vsat_n = max(-V_lim, min(V_lim, v_n))\n        vsat_vals[n] = vsat_n\n        \n        # Apply quantization\n        # Note: Python's round() rounds .5 to the nearest even integer.\n        q_prelim = round(vsat_n * S)\n        q_clipped = int(max(q_min, min(q_max, q_prelim)))\n        vq_n = q_clipped / S if S != float('inf') else 0.0\n        vq_vals[n] = vq_n\n        \n        # Update recurrence state for the next iteration\n        c_next = c_n * COS_THETA - s_n * SIN_THETA\n        s_next = s_n * COS_THETA + c_n * SIN_THETA\n        c_n, s_n = c_next, s_next\n\n    # 3. Performance Metrics Calculation\n    v_rms = np.sqrt(np.mean(np.square(vq_vals)))\n    quantization_error = vq_vals - vsat_vals\n    e_q_rms = np.sqrt(np.mean(np.square(quantization_error)))\n\n    return [round(v_rms, 6), n_sat, round(e_q_rms, 6)]\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: omega, Ts, N, B, V_fs, V_lim\n        (2 * np.pi * 50, 1/20000, 400, 12, 1.0, 0.15),\n        # Case 2: Special frequency close to Nyquist for 3rd harmonic\n        (0.999 * np.pi / (3 * 1/20000), 1/20000, 100, 8, 1.0, 1.0),\n        # Case 3: Low frequency\n        (2 * np.pi * 1, 0.001, 1000, 10, 1.0, 1.0),\n        # Case 4: Coarse quantization\n        (2 * np.pi * 60, 0.0001, 1000, 3, 0.2, 0.18),\n        # Case 5: High frequency\n        (2 * np.pi * 400, 0.0001, 5000, 12, 1.0, 1.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = process_case(*case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "最后的实践练习将调制技术与闭环控制相结合。我们将为一个 PI 电流控制器设计抗饱和（anti-windup）限制，该控制器所驱动的调制器采用了三次谐波注入技术。这是鲁棒控制设计中的关键一步，旨在确保控制器的指令始终保持在逆变器的可行工作区域内，从而防止性能下降和系统失稳。",
            "id": "3886068",
            "problem": "考虑一个三相电压源逆变器，其使用的调制器接受归一化的每相参考值 $m(\\theta)$，当 $|m(\\theta)|$ 超过指定限值 $M_{\\text{lim}}$ 时会饱和。采用零序三次谐波注入策略，使得每相参考值具有如下形式\n$$\nm(\\theta) = M\\big(\\sin(\\theta) + \\beta \\sin(3\\theta)\\big),\n$$\n其中 $M \\ge 0$ 是指令基波幅值，$\\beta \\in \\mathbb{R}$ 是相对于基波的三次谐波注入比，$\\theta$ 是以弧度为单位的角度。如果对于任意 $\\theta \\in \\mathbb{R}$，有 $|m(\\theta)| > M_{\\text{lim}}$，则调制器饱和。\n\n一个比例-积分 (PI) 电流控制器在离散时间索引 $k$（采样周期 $T_s > 0$）处计算归一化的电压指令 $u_k$，其使用的比例增益 $K_p > 0$ 和积分增益 $K_i > 0$ 如下：\n$$\nu_k^{\\text{unsat}} = K_p e_k + i_k,\n$$\n其中 $e_k$ 是电流跟踪误差，$i_k$ 是时刻 $k$ 的积分器状态。通过将指令饱和到一个可行边界 $U_{\\max}$ 并使用反计算增益 $K_{\\text{aw}} \\ge 0$ 校正积分器来实现抗饱和（anti-windup）：\n$$\nu_k^{\\text{sat}} = \\operatorname{clip}\\left(u_k^{\\text{unsat}}, -U_{\\max}, U_{\\max}\\right),\n$$\n$$\ni_{k+1} = i_k + K_i T_s e_k + K_{\\text{aw}}\\left(u_k^{\\text{sat}} - u_k^{\\text{unsat}}\\right).\n$$\n可行边界 $U_{\\max}$ 必须确保对于选定的 $M$ 和 $\\beta$，调制器永不饱和，即对所有 $\\theta$ 均有 $|m(\\theta)| \\le M_{\\text{lim}}$。为了普遍地强制执行此约束，$U_{\\max}$ 用于钳位 $M$（通过 $u_k$），使得 $M \\le U_{\\max}$，其中 $U_{\\max}$ 是根据 $\\sin(\\theta) + \\beta \\sin(3\\theta)$ 的最坏情况下的幅值导出的。\n\n您的任务是为一组测试用例实现抗饱和约束的计算和 PI 更新。对于每个测试用例，给定 $(\\beta, M_{\\text{lim}}, K_p, K_i, T_s, e_k, i_k, K_{\\text{aw}})$，您必须计算：\n1. $U_{\\max} = \\dfrac{M_{\\text{lim}}}{\\sup_{\\theta \\in \\mathbb{R}} \\left|\\sin(\\theta) + \\beta \\sin(3\\theta)\\right|}$。\n2. 饱和标志 $s_k$，如果 $u_k^{\\text{unsat}} \\ne u_k^{\\text{sat}}$ 则为 $1$，否则为 $0$。\n3. 饱和后的控制量 $u_k^{\\text{sat}}$。\n4. 下一个积分器状态 $i_{k+1}$。\n\n所有角度均以弧度为单位。所有量均为无量纲的归一化值。将最终结果以浮点数和整数的数值形式表示。\n\n测试套件：\n- 情况1（一般情况，典型幅值的零序注入）：$(\\beta, M_{\\text{lim}}, K_p, K_i, T_s, e_k, i_k, K_{\\text{aw}}) = (1/6, 1.0, 0.5, 100.0, 1.0\\times 10^{-4}, 2.0\\times 10^{-2}, 0.0, 5000.0)$。\n- 情况2（接近边界并发生饱和）：$(\\beta, M_{\\text{lim}}, K_p, K_i, T_s, e_k, i_k, K_{\\text{aw}}) = (1/6, 1.0, 1.0, 50.0, 1.0\\times 10^{-4}, 1.2, 0.1, 2000.0)$。\n- 情况3（无注入的基准情况）：$(\\beta, M_{\\text{lim}}, K_p, K_i, T_s, e_k, i_k, K_{\\text{aw}}) = (0.0, 1.0, 0.2, 200.0, 5.0\\times 10^{-5}, 6.0, 0.0, 3000.0)$。\n- 情况4（负注入比）：$(\\beta, M_{\\text{lim}}, K_p, K_i, T_s, e_k, i_k, K_{\\text{aw}}) = (-0.1, 1.0, 0.4, 120.0, 2.0\\times 10^{-4}, -3.0, 0.5, 1000.0)$。\n- 情况5（更强的注入和减小的调制器限值）：$(\\beta, M_{\\text{lim}}, K_p, K_i, T_s, e_k, i_k, K_{\\text{aw}}) = (0.25, 0.9, 0.8, 80.0, 1.0\\times 10^{-4}, 1.3, -0.5, 1500.0)$。\n\n您的程序应生成单行输出，其中包含五个测试用例的结果，格式为用方括号括起来的逗号分隔列表，其中每个元素是按 $[U_{\\max}, s_k, u_k^{\\text{sat}}, i_{k+1}]$ 顺序排列的四个值的列表。例如，格式必须如下所示：\n$$\n[\\,[U_{\\max}^{(1)}, s_k^{(1)}, u_{k,\\text{sat}}^{(1)}, i_{k+1}^{(1)}],\\,\\ldots,\\,[U_{\\max}^{(5)}, s_k^{(5)}, u_{k,\\text{sat}}^{(5)}, i_{k+1}^{(5)}]\\,].\n$$",
            "solution": "通过要求每相调制器输入在所有角度下都保持在其限值内，可以得到可行的指令边界。归一化的调制器输入为 $m(\\theta) = M\\big(\\sin(\\theta) + \\beta \\sin(3\\theta)\\big)$，可行性要求对所有 $\\theta \\in \\mathbb{R}$ 都有 $|m(\\theta)| \\le M_{\\text{lim}}$。因此，允许的基波幅值必须满足\n$$\nM \\le \\frac{M_{\\text{lim}}}{\\sup_{\\theta \\in \\mathbb{R}} \\left|\\sin(\\theta) + \\beta \\sin(3\\theta)\\right|}.\n$$\n定义\n$$\nS(\\beta) \\triangleq \\sup_{\\theta \\in \\mathbb{R}} \\left|\\sin(\\theta) + \\beta \\sin(3\\theta)\\right|.\n$$\n那么通用的抗饱和边界变为\n$$\nU_{\\max} = \\frac{M_{\\text{lim}}}{S(\\beta)}.\n$$\n\n为了从第一性原理计算 $S(\\beta)$，我们利用三角函数的三倍角恒等式，这是一个经过充分检验的公式：\n$$\n\\sin(3\\theta) = 3\\sin(\\theta) - 4\\sin^3(\\theta).\n$$\n将此代入 $S(\\beta)$ 得\n$$\n\\sin(\\theta) + \\beta \\sin(3\\theta) = \\sin(\\theta)\\left(1 + 3\\beta\\right) - 4\\beta \\sin^3(\\theta).\n$$\n令 $y = \\sin(\\theta)$，则 $y \\in [-1,1]$。定义三次多项式\n$$\ng(y) = y\\left(1 + 3\\beta\\right) - 4\\beta y^3,\n$$\n并注意到\n$$\nS(\\beta) = \\sup_{y \\in [-1,1]} |g(y)|.\n$$\n$g(y)$ 在 $[-1,1]$ 上的极值出现在区间内的驻点或边界 $y = \\pm 1$ 处。其导数为\n$$\ng'(y) = \\left(1 + 3\\beta\\right) - 12\\beta y^2.\n$$\n驻点 $y^\\star$ 满足\n$$\ny^{\\star 2} = \\frac{1 + 3\\beta}{12\\beta},\n$$\n前提是 $\\beta \\ne 0$ 且右侧非负。因此，可行的驻点是\n$$\ny^\\star = \\pm \\sqrt{\\frac{1 + 3\\beta}{12\\beta}},\n$$\n当 $\\frac{1 + 3\\beta}{12\\beta} \\in [0,1]$ 时。否则，极值位于边界 $y = \\pm 1$ 处。对于 $\\beta = 0$，函数简化为 $g(y) = y$，上确界显然为 $S(0) = 1$。\n\n因此，为稳健地计算 $S(\\beta)$：\n- 如果 $\\beta = 0$，则 $S(\\beta) = 1$。\n- 否则，计算 $y^2 = \\frac{1 + 3\\beta}{12\\beta}$，如果 $y^2 \\in [0,1]$，则将 $y^\\star = \\pm \\sqrt{y^2}$ 作为候选点；否则，仅依赖边界候选点 $y = \\pm 1$。\n- 在所有候选点上计算 $|g(y)|$ 并取最大值。\n\n在确定了 $U_{\\max}$ 后，抗饱和 PI 控制器计算未饱和的控制量\n$$\nu_k^{\\text{unsat}} = K_p e_k + i_k,\n$$\n并应用饱和\n$$\nu_k^{\\text{sat}} = \\begin{cases}\n-U_{\\max},  \\text{if } u_k^{\\text{unsat}} < -U_{\\max},\\\\\nu_k^{\\text{unsat}},  \\text{if } -U_{\\max} \\le u_k^{\\text{unsat}} \\le U_{\\max},\\\\\nU_{\\max},  \\text{if } u_k^{\\text{unsat}} > U_{\\max}.\n\\end{cases}\n$$\n当 $u_k^{\\text{unsat}} \\ne u_k^{\\text{sat}}$ 时，饱和标志 $s_k = 1$；否则 $s_k = 0$。\n\n对于抗饱和，积分器使用反计算（back-calculation）进行更新。其基本原理是，当执行器饱和时，施加的有效控制是 $u_k^{\\text{sat}}$，而不是 $u_k^{\\text{unsat}}$。如果允许积分器继续累积误差，将导致积分饱和（windup）。为防止这种情况，通过反馈施加的控制与未饱和指令之间的差异来校正积分器动态。一种常见的、经过充分检验的离散时间抗饱和结构是\n$$\ni_{k+1} = i_k + K_i T_s e_k + K_{\\text{aw}}\\left(u_k^{\\text{sat}} - u_k^{\\text{unsat}}\\right),\n$$\n其中 $K_{\\text{aw}} \\ge 0$ 的选择用于设定积分器状态与饱和状态协调的速率。该表达式源于一个原则，即积分器应反映实际施加到被控对象上的控制行为；因此，当指令饱和时，校正项会抵消累积。\n\n每个测试用例的算法总结：\n1. 给定 $\\beta$ 和 $M_{\\text{lim}}$，通过上述候选点评估方法计算 $S(\\beta)$，然后计算 $U_{\\max} = M_{\\text{lim}}/S(\\beta)$。\n2. 计算 $u_k^{\\text{unsat}} = K_p e_k + i_k$。\n3. 饱和处理：$u_k^{\\text{sat}} = \\operatorname{clip}\\left(u_k^{\\text{unsat}}, -U_{\\max}, U_{\\max}\\right)$。\n4. 标志：如果 $u_k^{\\text{unsat}} \\ne u_k^{\\text{sat}}$ 则 $s_k = 1$，否则为 $0$。\n5. 更新积分器：$i_{k+1} = i_k + K_i T_s e_k + K_{\\text{aw}}\\left(u_k^{\\text{sat}} - u_k^{\\text{unsat}}\\right)$。\n\n此过程独立应用于每个测试用例。最终程序输出单行，其中包含所有测试用例的结果列表 $[U_{\\max}, s_k, u_k^{\\text{sat}}, i_{k+1}]$，格式如指定。所有角度均以弧度为单位。所有量均为无量纲的归一化值，因此输出中不需要物理单位。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_S_beta(beta: float) -> float:\n    \"\"\"\n    Compute S(beta) = sup_{theta} |sin(theta) + beta * sin(3 theta)|\n    using the triple-angle identity and analytic candidate evaluation.\n    \"\"\"\n    # Handle the special case beta == 0\n    if np.isclose(beta, 0.0):\n        return 1.0\n\n    # Define g(y) = y*(1 + 3*beta) - 4*beta*y^3, with y in [-1, 1]\n    def g(y):\n        return y * (1.0 + 3.0 * beta) - 4.0 * beta * (y ** 3)\n\n    candidates = [-1.0, 1.0]\n\n    # Compute stationary point candidates y^2 = (1+3*beta)/(12*beta)\n    denom = 12.0 * beta\n    numer = 1.0 + 3.0 * beta\n    y2 = numer / denom\n\n    # Include stationary points if valid and within [-1,1]\n    if y2 >= 0.0:\n        y_star = np.sqrt(y2)\n        if y_star = 1.0:\n            candidates.extend([y_star, -y_star])\n\n    # Evaluate absolute values of g(y) at candidates\n    values = [abs(g(y)) for y in candidates]\n    S = max(values)\n    # Numerical safety: ensure S is positive\n    if S = 0.0:\n        # Fallback to a dense sampling if something went wrong\n        thetas = np.linspace(0.0, 2.0 * np.pi, 10001)\n        vals = np.abs(np.sin(thetas) + beta * np.sin(3.0 * thetas))\n        S = float(np.max(vals))\n    return float(S)\n\ndef anti_windup_PI(beta, M_lim, Kp, Ki, Ts, e_k, i_k, K_aw):\n    \"\"\"\n    For given parameters, compute U_max, saturation flag s_k,\n    saturated control u_sat, and next integrator state i_{k+1}.\n    \"\"\"\n    # Compute S(beta) and U_max\n    S_beta = compute_S_beta(beta)\n    U_max = M_lim / S_beta\n\n    # PI unsaturated output\n    u_unsat = Kp * e_k + i_k\n\n    # Saturate to [-U_max, U_max]\n    u_sat = max(-U_max, min(U_max, u_unsat))\n\n    # Saturation flag\n    s_k = 1 if not np.isclose(u_unsat, u_sat) else 0\n\n    # Anti-windup integrator update\n    i_next = i_k + Ki * Ts * e_k + K_aw * (u_sat - u_unsat)\n\n    return [U_max, s_k, u_sat, i_next]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case: (beta, M_lim, Kp, Ki, Ts, e_k, i_k, K_aw)\n    test_cases = [\n        (1.0/6.0, 1.0, 0.5, 100.0, 1.0e-4, 2.0e-2, 0.0, 5000.0),\n        (1.0/6.0, 1.0, 1.0, 50.0, 1.0e-4, 1.2, 0.1, 2000.0),\n        (0.0, 1.0, 0.2, 200.0, 5.0e-5, 6.0, 0.0, 3000.0),\n        (-0.1, 1.0, 0.4, 120.0, 2.0e-4, -3.0, 0.5, 1000.0),\n        (0.25, 0.9, 0.8, 80.0, 1.0e-4, 1.3, -0.5, 1500.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        beta, M_lim, Kp, Ki, Ts, e_k, i_k, K_aw = case\n        result = anti_windup_PI(beta, M_lim, Kp, Ki, Ts, e_k, i_k, K_aw)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # Ensure floats are printed in a standard Python representation.\n    print(f\"[{','.join([str(r) for r in results])}]\")\n\nsolve()\n```"
        }
    ]
}