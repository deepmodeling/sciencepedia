{
    "hands_on_practices": [
        {
            "introduction": "The stator flux estimator lies at the very heart of Direct Torque Control, functioning essentially as a pure integrator of the stator voltage equation. However, this elegant simplicity comes with a significant practical challenge: sensitivity to parameter inaccuracies. This exercise guides you through a first-principles analysis to quantify how a small, constant error in the estimated stator resistance, $\\hat{R}_{s}$, creates a cumulative drift in the flux estimate, a critical issue that plagues low-speed operation .",
            "id": "3835342",
            "problem": "Consider a stationary reference frame direct torque control (DTC) flux observer for an induction machine implemented on a voltage source inverter with a fixed sampling period. The stator flux in the stationary $\\alpha\\beta$ frame, denoted by the vector $\\psi_{s}$, obeys the stator circuit equation derived from Kirchhoff’s voltage law for the stator winding,\n$$\nv_{s}(t) = R_{s}\\,i_{s}(t) + \\frac{d\\psi_{s}(t)}{dt},\n$$\nwhere $v_{s}(t)$ is the stator voltage vector, $i_{s}(t)$ is the stator current vector, and $R_{s}$ is the true stator resistance. A forward-Euler discrete-time flux observer uses the measured $v_{s}[k]$, $i_{s}[k]$, and an estimated stator resistance $\\hat{R}_{s}$ to propagate an estimate $\\hat{\\psi}_{s}[k]$ according to\n$$\n\\hat{\\psi}_{s}[k] = \\hat{\\psi}_{s}[k-1] + \\big(v_{s}[k] - \\hat{R}_{s}\\,i_{s}[k]\\big)\\,T_{s},\n$$\nwhere $T_{s}$ is the sampling period and $k$ is the discrete-time index.\n\nAssume the machine is at standstill and a constant direct-current excitation is present in the $\\alpha$-axis due to the applied converter state, yielding a constant stator current vector $i_{s}[k] = \\begin{pmatrix} i_{0} \\\\ 0 \\end{pmatrix}$ for all $k$, with $i_{0} > 0$. Under this constant condition, the stator voltage satisfies $v_{s}[k] = R_{s}\\,i_{s}[k]$. The observer is initialized with $\\hat{\\psi}_{s}[0] = \\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix}$.\n\nStarting from the continuous-time stator circuit equation and the definition of the discrete-time observer above, derive from first principles the discrete-time evolution of the flux estimation error vector $\\varepsilon_{\\psi}[k] \\triangleq \\hat{\\psi}_{s}[k] - \\psi_{s}[k]$ and obtain a closed-form expression for $|\\varepsilon_{\\psi}[N]|$ after $N$ samples in terms of $R_{s}$, $\\hat{R}_{s}$, $i_{0}$, and $T_{s}$. Use this to evaluate the numerical drift magnitude in the flux estimate after a duration $t = N\\,T_{s}$ for the following parameters:\n- $R_{s} = 0.87$ $\\Omega$,\n- $\\hat{R}_{s} = 0.75$ $\\Omega$,\n- $i_{0} = 0.15$ $\\mathrm{A}$,\n- $T_{s} = 50 \\times 10^{-6}$ $\\mathrm{s}$,\n- $t = 0.50$ $\\mathrm{s}$.\n\nExpress the final flux drift magnitude in $\\mathrm{Wb}$ and round your answer to four significant figures.",
            "solution": "The problem is validated as follows.\n\n### Step 1: Extract Givens\n- Continuous-time stator circuit equation: $v_{s}(t) = R_{s}\\,i_{s}(t) + \\frac{d\\psi_{s}(t)}{dt}$\n- Discrete-time flux observer equation: $\\hat{\\psi}_{s}[k] = \\hat{\\psi}_{s}[k-1] + \\big(v_{s}[k] - \\hat{R}_{s}\\,i_{s}[k]\\big)\\,T_{s}$\n- Variables and constants:\n    - $\\psi_{s}(t)$: True stator flux vector in the stationary $\\alpha\\beta$ frame\n    - $v_{s}(t)$: True stator voltage vector\n    - $i_{s}(t)$: True stator current vector\n    - $R_{s}$: True stator resistance\n    - $\\hat{\\psi}_{s}[k]$: Estimated stator flux vector\n    - $\\hat{R}_{s}$: Estimated stator resistance\n    - $T_{s}$: Sampling period\n    - $k$: Discrete-time index\n- Conditions:\n    - Machine at standstill.\n    - Constant DC excitation in the $\\alpha$-axis.\n    - $i_{s}[k] = \\begin{pmatrix} i_{0} \\\\ 0 \\end{pmatrix}$ for all $k$, with $i_{0} > 0$.\n    - $v_{s}[k] = R_{s}\\,i_{s}[k]$.\n- Initial condition for observer: $\\hat{\\psi}_{s}[0] = \\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix}$.\n- Definition of flux estimation error: $\\varepsilon_{\\psi}[k] \\triangleq \\hat{\\psi}_{s}[k] - \\psi_{s}[k]$.\n- Objective: Derive the discrete-time evolution of $\\varepsilon_{\\psi}[k]$, find a closed-form expression for its drift magnitude $|\\varepsilon_{\\psi}[N]|$ after $N$ samples, and evaluate this magnitude numerically.\n- Numerical parameters:\n    - $R_{s} = 0.87$ $\\Omega$\n    - $\\hat{R}_{s} = 0.75$ $\\Omega$\n    - $i_{0} = 0.15$ $\\mathrm{A}$\n    - $T_{s} = 50 \\times 10^{-6}$ $\\mathrm{s}$\n    - $t = 0.50$ $\\mathrm{s}$\n\n### Step 2: Validate Using Extracted Givens\nThe problem is scientifically grounded, based on standard models for induction machine stator circuits and discrete-time observers in direct torque control. The equations are derived from fundamental electrical principles. The problem is well-posed, providing all necessary information, definitions, and parameters, under the standard interpretation of \"drift\" as the time-accumulated error component. The scenario described (DC excitation at standstill) is a common and realistic test condition for analyzing observer performance. The language is objective and unambiguous. The parameters provided are physically realistic. The problem is self-contained and internally consistent. The crucial consistency is that the condition $v_{s}[k] = R_{s}\\,i_{s}[k]$ implies from the continuous-time equation that $\\frac{d\\psi_{s}(t)}{dt} = 0$, meaning the true flux is constant, which is consistent with a DC steady-state condition.\n\n### Step 3: Verdict and Action\nThe problem is deemed valid. A complete solution will be provided.\n\n### Derivation and Solution\n\nThe objective is to determine the magnitude of the flux estimation error that accumulates over a time period $t$. We begin by analyzing the dynamics of the true stator flux $\\psi_{s}(t)$ and the estimated stator flux $\\hat{\\psi}_{s}[k]$.\n\nThe continuous-time stator voltage equation is given as:\n$$\nv_{s}(t) = R_{s}\\,i_{s}(t) + \\frac{d\\psi_{s}(t)}{dt}\n$$\nThe problem states that for a constant stator current vector $i_{s}(t) = i_{s}$, the corresponding stator voltage is $v_{s}(t) = R_{s}\\,i_{s}$. Substituting this condition into the voltage equation yields:\n$$\nR_{s}\\,i_{s} = R_{s}\\,i_{s} + \\frac{d\\psi_{s}(t)}{dt}\n$$\nThis implies that $\\frac{d\\psi_{s}(t)}{dt} = 0$. Therefore, the true stator flux vector $\\psi_{s}(t)$ is constant for the duration of this analysis. Let $\\psi_{s}[k]$ denote the sampled true flux at time $t = k T_s$. It follows that:\n$$\n\\psi_{s}[k] = \\psi_{s}[k-1]\n$$\nfor all $k \\ge 1$.\n\nThe discrete-time flux observer is defined by the recurrence relation:\n$$\n\\hat{\\psi}_{s}[k] = \\hat{\\psi}_{s}[k-1] + \\big(v_{s}[k] - \\hat{R}_{s}\\,i_{s}[k]\\big)\\,T_{s}\n$$\nThe flux estimation error vector is defined as $\\varepsilon_{\\psi}[k] \\triangleq \\hat{\\psi}_{s}[k] - \\psi_{s}[k]$. We now derive the discrete-time evolution of this error. The change in error from one sample to the next is:\n$$\n\\varepsilon_{\\psi}[k] - \\varepsilon_{\\psi}[k-1] = (\\hat{\\psi}_{s}[k] - \\psi_{s}[k]) - (\\hat{\\psi}_{s}[k-1] - \\psi_{s}[k-1])\n$$\nRearranging terms, we get:\n$$\n\\varepsilon_{\\psi}[k] - \\varepsilon_{\\psi}[k-1] = (\\hat{\\psi}_{s}[k] - \\hat{\\psi}_{s}[k-1]) - (\\psi_{s}[k] - \\psi_{s}[k-1])\n$$\nFrom the observer equation, we substitute for the first term on the right-hand side. From our analysis of the true flux, the second term is zero.\n$$\n\\varepsilon_{\\psi}[k] - \\varepsilon_{\\psi}[k-1] = \\big(v_{s}[k] - \\hat{R}_{s}\\,i_{s}[k]\\big)\\,T_{s} - 0\n$$\nNow, we use the given condition $v_{s}[k] = R_{s}\\,i_{s}[k]$:\n$$\n\\varepsilon_{\\psi}[k] - \\varepsilon_{\\psi}[k-1] = \\big(R_{s}\\,i_{s}[k] - \\hat{R}_{s}\\,i_{s}[k]\\big)\\,T_{s}\n$$\nThis simplifies to the recurrence relation for the error evolution:\n$$\n\\varepsilon_{\\psi}[k] = \\varepsilon_{\\psi}[k-1] + (R_{s} - \\hat{R}_{s})\\,i_{s}[k]\\,T_{s}\n$$\nThis is a first-order difference equation. We can solve it by unrolling the recursion from $k=1$ to $N$:\n$$\n\\varepsilon_{\\psi}[N] = \\varepsilon_{\\psi}[0] + \\sum_{k=1}^{N} (R_{s} - \\hat{R}_{s})\\,i_{s}[k]\\,T_{s}\n$$\nThe problem states that the stator current is constant, $i_{s}[k] = i_{s} = \\begin{pmatrix} i_{0} \\\\ 0 \\end{pmatrix}$. The summation therefore simplifies to:\n$$\n\\varepsilon_{\\psi}[N] = \\varepsilon_{\\psi}[0] + N (R_{s} - \\hat{R}_{s})\\,i_{s}\\,T_{s}\n$$\nThe term $\\varepsilon_{\\psi}[0]$ represents the initial error at $k=0$, which is a constant offset. The term $N (R_{s} - \\hat{R}_{s})\\,i_{s}\\,T_{s}$ represents the error component that accumulates over $N$ samples due to the mismatch between the true resistance $R_{s}$ and the estimated resistance $\\hat{R}_{s}$. This accumulating component is the numerical drift. We define the drift vector as:\n$$\n\\varepsilon_{\\text{drift}}[N] \\triangleq \\varepsilon_{\\psi}[N] - \\varepsilon_{\\psi}[0] = N (R_{s} - \\hat{R}_{s})\\,i_{s}\\,T_{s}\n$$\nThe problem asks for the magnitude of this drift after a time $t = N T_s$. We can express $N$ as $t/T_s$. Substituting this into the drift equation:\n$$\n\\varepsilon_{\\text{drift}}(t) = \\frac{t}{T_{s}} (R_{s} - \\hat{R}_{s})\\,i_{s}\\,T_{s} = t (R_{s} - \\hat{R}_{s})\\,i_{s}\n$$\nWe are given $i_{s} = \\begin{pmatrix} i_{0} \\\\ 0 \\end{pmatrix}$. The drift vector is:\n$$\n\\varepsilon_{\\text{drift}}(t) = t (R_{s} - \\hat{R}_{s}) \\begin{pmatrix} i_{0} \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} t (R_{s} - \\hat{R}_{s}) i_{0} \\\\ 0 \\end{pmatrix}\n$$\nThe magnitude of this vector, denoted $|\\varepsilon_{\\text{drift}}(t)|$, is the Euclidean norm:\n$$\n|\\varepsilon_{\\text{drift}}(t)| = \\sqrt{\\left(t (R_{s} - \\hat{R}_{s}) i_{0}\\right)^2 + 0^2} = |t (R_{s} - \\hat{R}_{s}) i_{0}|\n$$\nSince time $t$ and current $i_{0}$ are positive, the magnitude simplifies to:\n$$\n|\\varepsilon_{\\text{drift}}(t)| = t \\, |R_{s} - \\hat{R}_{s}| \\, i_{0}\n$$\nThis is the closed-form expression for the drift magnitude. We can now substitute the given numerical values:\n- $t = 0.50$ $\\mathrm{s}$\n- $R_{s} = 0.87$ $\\Omega$\n- $\\hat{R}_{s} = 0.75$ $\\Omega$\n- $i_{0} = 0.15$ $\\mathrm{A}$\n\nThe resistance mismatch is $|R_{s} - \\hat{R}_{s}| = |0.87 - 0.75| = |0.12| = 0.12$ $\\Omega$.\n\nThe drift magnitude is:\n$$\n|\\varepsilon_{\\text{drift}}(0.50)| = (0.50 \\, \\mathrm{s}) \\times (0.12 \\, \\Omega) \\times (0.15 \\, \\mathrm{A})\n$$\n$$\n|\\varepsilon_{\\text{drift}}(0.50)| = (0.06 \\, \\mathrm{s} \\cdot \\Omega) \\times (0.15 \\, \\mathrm{A})\n$$\n$$\n|\\varepsilon_{\\text{drift}}(0.50)| = 0.009 \\, \\mathrm{s} \\cdot \\Omega \\cdot \\mathrm{A}\n$$\nThe units are $\\mathrm{s} \\cdot (\\mathrm{V/A}) \\cdot \\mathrm{A} = \\mathrm{V} \\cdot \\mathrm{s}$, which is the Weber ($\\mathrm{Wb}$), the unit of magnetic flux. Thus, the drift magnitude is $0.009$ $\\mathrm{Wb}$.\n\nThe problem requires the answer to be rounded to four significant figures.\n$$\n0.009 = 0.009000\n$$\nThe final numerical drift magnitude is $0.009000$ $\\mathrm{Wb}$.",
            "answer": "$$\\boxed{0.009000}$$"
        },
        {
            "introduction": "Beyond static parameter mismatches, the performance of a digitally implemented controller is fundamentally limited by measurement precision. This practice shifts our focus from the deterministic drift caused by resistance errors to the stochastic uncertainty introduced by Analog-to-Digital Converter (ADC) quantization . You will implement a discrete-time model to propagate the variance from quantized voltage and current measurements through the recursive flux estimator, ultimately quantifying the uncertainty in the final calculated torque, which provides invaluable insight into how hardware limitations translate into control performance degradation.",
            "id": "3835329",
            "problem": "You are asked to implement a discrete-time torque estimator for an induction machine under Direct Torque Control (DTC) and to propagate uncertainty due to quantization in the Analog-to-Digital Converter (ADC). The estimator must start from fundamental laws and core definitions. The task must be solved in a purely mathematical and logical manner and expressed in consistent physical units. The final output must be computable with a deterministic program.\n\nFundamental base:\n- The stator flux linkage vector in stationary two-axis coordinates obeys the fundamental stator circuit relation, which is a consequence of Faraday's law and Ohm's law: $$\\frac{d}{dt}\\boldsymbol{\\psi}_s(t) = \\boldsymbol{v}_s(t) - R_s \\boldsymbol{i}_s(t),$$ where $\\boldsymbol{\\psi}_s(t)$ is the stator flux linkage, $\\boldsymbol{v}_s(t)$ is the stator voltage, $\\boldsymbol{i}_s(t)$ is the stator current, and $R_s$ is the stator resistance. In discrete time with sampling period $T_s$, the forward-Euler update is $$\\boldsymbol{\\psi}_s[k] = \\boldsymbol{\\psi}_s[k-1] + T_s\\left(\\boldsymbol{v}_s[k] - R_s \\boldsymbol{i}_s[k]\\right).$$\n- The electromagnetic torque of an induction machine in stationary two-axis coordinates is defined by $$T_e[k] = \\frac{3}{2}p\\left(\\psi_{\\alpha}[k] i_{\\beta}[k] - \\psi_{\\beta}[k] i_{\\alpha}[k]\\right),$$ where $p$ is the number of pole pairs, and $(\\alpha,\\beta)$ are the components in the stationary reference frame.\n\nQuantization model:\n- The ADC quantization is modeled as independent zero-mean uniform noise on each measured channel. If the least significant bit (LSB) of the measurement is $q$, the quantization error has variance $$\\sigma_q^2 = \\frac{q^2}{12}.$$ Let $q_i$ be the current measurement LSB in amperes (A) and $q_v$ be the voltage measurement LSB in volts (V). The quantization errors on $\\alpha$ and $\\beta$ channels are independent and identically distributed with variances $\\sigma_i^2 = \\frac{q_i^2}{12}$ and $\\sigma_v^2 = \\frac{q_v^2}{12}$, respectively.\n- The discrete-time flux update uses measured signals, so the flux estimation error accumulates due to quantized voltage and current. Assuming independence across time and channels and zero initial flux estimation error, the per-axis flux variance recursion is $$\\operatorname{Var}\\left(\\psi_{\\alpha}[k]\\right) = \\operatorname{Var}\\left(\\psi_{\\alpha}[k-1]\\right) + T_s^2\\left(\\sigma_v^2 + R_s^2 \\sigma_i^2\\right),$$ $$\\operatorname{Var}\\left(\\psi_{\\beta}[k]\\right) = \\operatorname{Var}\\left(\\psi_{\\beta}[k-1]\\right) + T_s^2\\left(\\sigma_v^2 + R_s^2 \\sigma_i^2\\right),$$ with $\\operatorname{Var}\\left(\\psi_{\\alpha}[0]\\right) = 0$ and $\\operatorname{Var}\\left(\\psi_{\\beta}[0]\\right) = 0$.\n- The torque is computed from the flux and current at the final time step. Using first-order uncertainty propagation (linearization) around the nominal values, the torque variance at the final time step $k = N$ is $$\\operatorname{Var}\\left(T_e[N]\\right) \\approx \\left(\\frac{3}{2}p\\right)^2\\left( i_{\\beta}[N]^2 \\operatorname{Var}\\left(\\psi_{\\alpha}[N]\\right) + i_{\\alpha}[N]^2 \\operatorname{Var}\\left(\\psi_{\\beta}[N]\\right) + \\psi_{\\alpha}[N]^2 \\sigma_i^2 + \\psi_{\\beta}[N]^2 \\sigma_i^2 \\right),$$ assuming independence between the flux estimation errors and the instantaneous current measurement errors on both axes. The torque mean is computed using the nominal signals without quantization.\n\nImplementation requirements:\n- Implement the discrete-time flux estimator and torque computation using the provided sequences of stator voltage and current in stationary $(\\alpha,\\beta)$ coordinates. Use the above quantization model to propagate the uncertainty and compute the torque standard deviation as the square root of the torque variance.\n- Express the final torque mean and standard deviation in Newton-meter (N·m), rounded to six decimal places.\n- Angles are not used in this problem, so no angle unit is required.\n\nTest suite:\n- Use the following three test cases. For each case, $\\boldsymbol{v}_s[k] = \\left(v_{\\alpha}[k], v_{\\beta}[k]\\right)$ and $\\boldsymbol{i}_s[k] = \\left(i_{\\alpha}[k], i_{\\beta}[k]\\right)$ for $k = 1,2,3,4,5$. The initial flux is zero: $\\psi_{\\alpha}[0] = 0$ and $\\psi_{\\beta}[0] = 0$.\n\nCase $1$ (general case):\n- Sampling period: $T_s = 0.0001 \\ \\text{s}$\n- Stator resistance: $R_s = 0.5 \\ \\Omega$\n- Pole pairs: $p = 2$\n- Current LSB: $q_i = 0.001 \\ \\text{A}$\n- Voltage LSB: $q_v = 0.01 \\ \\text{V}$\n- Voltage sequences:\n$$v_{\\alpha}[k] = [ \\ 230.0,\\ 227.0,\\ 225.0,\\ 228.0,\\ 229.0 \\ ]$$\n$$v_{\\beta}[k] = [ \\ 0.0,\\ 20.0,\\ -15.0,\\ 10.0,\\ 5.0 \\ ]$$\n- Current sequences:\n$$i_{\\alpha}[k] = [ \\ 10.0,\\ 10.5,\\ 9.8,\\ 10.2,\\ 10.1 \\ ]$$\n$$i_{\\beta}[k] = [ \\ 0.0,\\ -1.0,\\ 0.5,\\ -0.2,\\ 0.3 \\ ]$$\n\nCase $2$ (boundary case: no quantization):\n- Sampling period: $T_s = 0.0001 \\ \\text{s}$\n- Stator resistance: $R_s = 0.5 \\ \\Omega$\n- Pole pairs: $p = 2$\n- Current LSB: $q_i = 0.0 \\ \\text{A}$\n- Voltage LSB: $q_v = 0.0 \\ \\text{V}$\n- Voltage sequences:\n$$v_{\\alpha}[k] = [ \\ 230.0,\\ 227.0,\\ 225.0,\\ 228.0,\\ 229.0 \\ ]$$\n$$v_{\\beta}[k] = [ \\ 0.0,\\ 20.0,\\ -15.0,\\ 10.0,\\ 5.0 \\ ]$$\n- Current sequences:\n$$i_{\\alpha}[k] = [ \\ 10.0,\\ 10.5,\\ 9.8,\\ 10.2,\\ 10.1 \\ ]$$\n$$i_{\\beta}[k] = [ \\ 0.0,\\ -1.0,\\ 0.5,\\ -0.2,\\ 0.3 \\ ]$$\n\nCase $3$ (edge case: higher quantization and longer sampling period):\n- Sampling period: $T_s = 0.0003 \\ \\text{s}$\n- Stator resistance: $R_s = 0.8 \\ \\Omega$\n- Pole pairs: $p = 3$\n- Current LSB: $q_i = 0.005 \\ \\text{A}$\n- Voltage LSB: $q_v = 0.05 \\ \\text{V}$\n- Voltage sequences:\n$$v_{\\alpha}[k] = [ \\ 240.0,\\ 238.0,\\ 235.0,\\ 239.0,\\ 241.0 \\ ]$$\n$$v_{\\beta}[k] = [ \\ 10.0,\\ -5.0,\\ 15.0,\\ -10.0,\\ 0.0 \\ ]$$\n- Current sequences:\n$$i_{\\alpha}[k] = [ \\ 15.0,\\ 14.8,\\ 15.2,\\ 14.9,\\ 15.1 \\ ]$$\n$$i_{\\beta}[k] = [ \\ -2.0,\\ -1.5,\\ -1.0,\\ -0.5,\\ 0.0 \\ ]$$\n\nProgram output specification:\n- For each test case, compute the torque mean $T_e[5]$ and the torque standard deviation $\\sqrt{\\operatorname{Var}(T_e[5])}$ at the final step $k = 5$.\n- Your program should produce a single line of output containing the results for all cases as a comma-separated list enclosed in square brackets. Each case result must be a two-element list of floats $[T_{\\text{mean}}, T_{\\text{std}}]$, both rounded to six decimal places, and expressed in $\\text{N}\\cdot\\text{m}$. For example, the final output format should be $$[ [ \\ T_{\\text{mean},1},\\ T_{\\text{std},1} \\ ],\\ [ \\ T_{\\text{mean},2},\\ T_{\\text{std},2} \\ ],\\ [ \\ T_{\\text{mean},3},\\ T_{\\text{std},3} \\ ] ].$$",
            "solution": "The user has provided a valid, well-posed problem that is scientifically grounded in the principles of electrical engineering and control theory. The problem requires the implementation of a discrete-time torque estimator for an induction machine, including the propagation of uncertainty arising from sensor quantization. The solution below follows a systematic, principle-based approach.\n\n### 1. Problem Formulation\nThe core task is to estimate the electromagnetic torque, $T_e$, and its associated uncertainty at a final discrete time step, $N$. This involves two parallel computations:\n1.  **Mean Value Estimation**: Iteratively calculating the nominal values of the stator flux vector, $\\boldsymbol{\\psi}_s$, and then computing the nominal torque, $T_e$.\n2.  **Uncertainty Propagation**: Iteratively calculating the variance of the stator flux components, and then propagating this uncertainty, along with the current measurement uncertainty, to the final torque calculation.\n\nAll calculations are performed in a stationary two-axis reference frame, denoted by $(\\alpha, \\beta)$ coordinates.\n\n### 2. Mean Value Estimation\nThe estimation of the mean torque relies on the nominal (error-free) values of the measured signals.\n\n#### 2.1. Stator Flux Estimation\nThe fundamental relationship governing the stator flux linkage, $\\boldsymbol{\\psi}_s(t)$, is derived from Faraday's law of induction and Ohm's law applied to the stator windings:\n$$ \\frac{d}{dt}\\boldsymbol{\\psi}_s(t) = \\boldsymbol{v}_s(t) - R_s \\boldsymbol{i}_s(t) $$\nwhere $\\boldsymbol{v}_s(t)$ is the stator voltage vector, $\\boldsymbol{i}_s(t)$ is the stator current vector, and $R_s$ is the stator resistance.\n\nFor a digital control system with a sampling period $T_s$, this continuous-time differential equation is discretized. The problem specifies the use of the forward-Euler method, which yields the following recursive update rule for the flux vector at time step $k$:\n$$ \\boldsymbol{\\psi}_s[k] = \\boldsymbol{\\psi}_s[k-1] + T_s \\left( \\boldsymbol{v}_s[k] - R_s \\boldsymbol{i}_s[k] \\right) $$\nThis equation is applied separately for the $\\alpha$ and $\\beta$ components:\n$$ \\psi_{\\alpha}[k] = \\psi_{\\alpha}[k-1] + T_s \\left( v_{\\alpha}[k] - R_s i_{\\alpha}[k] \\right) $$\n$$ \\psi_{\\beta}[k] = \\psi_{\\beta}[k-1] + T_s \\left( v_{\\beta}[k] - R_s i_{\\beta}[k] \\right) $$\nStarting with the initial condition $\\boldsymbol{\\psi}_s[0] = \\boldsymbol{0}$, these equations are iterated for $k=1, 2, \\dots, N$.\n\n#### 2.2. Electromagnetic Torque Calculation\nThe electromagnetic torque, $T_e$, is a function of the stator flux and stator current components. For a three-phase machine with $p$ pole pairs, the torque in the stationary reference frame is given by:\n$$ T_e[k] = \\frac{3}{2}p \\left( \\psi_{\\alpha}[k] i_{\\beta}[k] - \\psi_{\\beta}[k] i_{\\alpha}[k] \\right) $$\nThe mean torque at the final step, $T_{e, \\text{mean}}[N]$, is calculated using the final estimated flux values, $\\psi_{\\alpha}[N]$ and $\\psi_{\\beta}[N]$, and the final measured current values, $i_{\\alpha}[N]$ and $i_{\\beta}[N]$.\n\n### 3. Uncertainty Propagation\nThe uncertainty in the torque estimate originates from the quantization of the analog voltage and current signals by the Analog-to-Digital Converter (ADC).\n\n#### 3.1. Quantization Error Model\nThe quantization error for a signal is modeled as a zero-mean random variable uniformly distributed over the interval $[-q/2, q/2]$, where $q$ is the width of a quantization step, or the least significant bit (LSB). The variance of this uniform distribution is:\n$$ \\sigma_q^2 = \\frac{q^2}{12} $$\nThe problem provides LSB values for current, $q_i$, and voltage, $q_v$. Assuming the errors on the $\\alpha$ and $\\beta$ channels are independent and identically distributed, the measurement variances are:\n$$ \\sigma_i^2 = \\operatorname{Var}(i_{\\alpha}) = \\operatorname{Var}(i_{\\beta}) = \\frac{q_i^2}{12} $$\n$$ \\sigma_v^2 = \\operatorname{Var}(v_{\\alpha}) = \\operatorname{Var}(v_{\\beta}) = \\frac{q_v^2}{12} $$\n\n#### 3.2. Flux Variance Propagation\nThe uncertainty in the flux estimate accumulates over time. The variance of the flux estimate at step $k$ depends on the variance at the previous step, $k-1$, and the uncertainty introduced by the measurements at step $k$. From the flux update equation, $\\boldsymbol{\\psi}_s[k] = \\boldsymbol{\\psi}_s[k-1] + T_s(\\boldsymbol{v}_s[k] - R_s \\boldsymbol{i}_s[k])$, we can derive the variance propagation. Assuming that the estimation error in $\\boldsymbol{\\psi}_s[k-1]$ is independent of the measurement errors in $\\boldsymbol{v}_s[k]$ and $\\boldsymbol{i}_s[k]$, the variance adds up:\n$$ \\operatorname{Var}(\\boldsymbol{\\psi}_s[k]) = \\operatorname{Var}(\\boldsymbol{\\psi}_s[k-1]) + T_s^2 \\operatorname{Var}(\\boldsymbol{v}_s[k] - R_s \\boldsymbol{i}_s[k]) $$\nAssuming independence between voltage and current measurement errors, $\\operatorname{Var}(\\boldsymbol{v}_s[k] - R_s \\boldsymbol{i}_s[k]) = \\operatorname{Var}(\\boldsymbol{v}_s[k]) + R_s^2 \\operatorname{Var}(\\boldsymbol{i}_s[k])$.\nThis leads to the per-axis variance recursion provided in the problem statement:\n$$ \\operatorname{Var}(\\psi_{\\alpha}[k]) = \\operatorname{Var}(\\psi_{\\alpha}[k-1]) + T_s^2\\left(\\sigma_v^2 + R_s^2 \\sigma_i^2\\right) $$\n$$ \\operatorname{Var}(\\psi_{\\beta}[k]) = \\operatorname{Var}(\\psi_{\\beta}[k-1]) + T_s^2\\left(\\sigma_v^2 + R_s^2 \\sigma_i^2\\right) $$\nStarting with the initial condition $\\operatorname{Var}(\\boldsymbol{\\psi}_s[0]) = 0$, this iterative calculation yields the final flux variance components, $\\operatorname{Var}(\\psi_{\\alpha}[N])$ and $\\operatorname{Var}(\\psi_{\\beta}[N])$. Notice that the variance increase per step, $\\Delta\\sigma_\\psi^2 = T_s^2(\\sigma_v^2 + R_s^2 \\sigma_i^2)$, is constant. Thus, after $N$ steps, $\\operatorname{Var}(\\psi_{\\alpha}[N]) = \\operatorname{Var}(\\psi_{\\beta}[N]) = N \\cdot \\Delta\\sigma_\\psi^2$.\n\n#### 3.3. Torque Variance Calculation\nThe variance of the final torque, $\\operatorname{Var}(T_e[N])$, is estimated using the first-order Taylor series approximation (law of propagation of uncertainty). For a function $f(x_1, \\dots, x_m)$ of independent random variables, the variance is approximately:\n$$ \\operatorname{Var}(f) \\approx \\sum_{j=1}^{m} \\left( \\frac{\\partial f}{\\partial x_j} \\right)^2 \\operatorname{Var}(x_j) $$\nHere, the function is $T_e = C(\\psi_{\\alpha} i_{\\beta} - \\psi_{\\beta} i_{\\alpha})$ with $C = \\frac{3}{2}p$. The variables are $\\psi_{\\alpha}$, $\\psi_{\\beta}$, $i_{\\alpha}$, and $i_{\\beta}$. The partial derivatives evaluated at the nominal values are:\n$$ \\frac{\\partial T_e}{\\partial \\psi_{\\alpha}} = C \\cdot i_{\\beta}, \\quad \\frac{\\partial T_e}{\\partial \\psi_{\\beta}} = -C \\cdot i_{\\alpha}, \\quad \\frac{\\partial T_e}{\\partial i_{\\alpha}} = -C \\cdot \\psi_{\\beta}, \\quad \\frac{\\partial T_e}{\\partial i_{\\beta}} = C \\cdot \\psi_{\\alpha} $$\nSubstituting these into the variance formula and using the associated variances for each variable ($\\operatorname{Var}(\\psi_{\\alpha}[N])$, $\\operatorname{Var}(\\psi_{\\beta}[N])$, $\\sigma_i^2$, $\\sigma_i^2$) gives the final torque variance expression:\n$$ \\operatorname{Var}(T_e[N]) \\approx \\left(\\frac{3}{2}p\\right)^2 \\left( i_{\\beta}[N]^2 \\operatorname{Var}(\\psi_{\\alpha}[N]) + i_{\\alpha}[N]^2 \\operatorname{Var}(\\psi_{\\beta}[N]) + \\psi_{\\alpha}[N]^2 \\sigma_i^2 + \\psi_{\\beta}[N]^2 \\sigma_i^2 \\right) $$\nThe torque standard deviation is the square root of this variance: $\\sigma_{T_e}[N] = \\sqrt{\\operatorname{Var}(T_e[N])}$.\n\n### 4. Algorithmic Implementation\nFor each test case, the following steps are executed:\n\n1.  **Initialize**: Set initial flux $\\psi_{\\alpha}[0]=0$, $\\psi_{\\beta}[0]=0$. Set initial flux variances $\\operatorname{Var}(\\psi_{\\alpha}[0])=0$, $\\operatorname{Var}(\\psi_{\\beta}[0])=0$.\n2.  **Pre-calculate Constants**: Compute the measurement variances $\\sigma_i^2 = q_i^2/12$ and $\\sigma_v^2 = q_v^2/12$. Calculate the constant per-step flux variance increment $\\Delta\\sigma_\\psi^2 = T_s^2(\\sigma_v^2 + R_s^2 \\sigma_i^2)$.\n3.  **Iterate**: Loop for $k = 1, 2, \\dots, N=5$. In each iteration:\n    a. Read the voltage and current values $(v_{\\alpha}[k], v_{\\beta}[k])$ and $(i_{\\alpha}[k], i_{\\beta}[k])$ from the input sequences.\n    b. Update the mean flux components $\\psi_{\\alpha}[k]$ and $\\psi_{\\beta}[k]$ using the forward-Euler rule.\n    c. Update the flux variances $\\operatorname{Var}(\\psi_{\\alpha}[k])$ and $\\operatorname{Var}(\\psi_{\\beta}[k])$ by adding $\\Delta\\sigma_\\psi^2$.\n4.  **Final Calculation**: After the loop finishes (at $k=N=5$):\n    a. Calculate the mean torque $T_{e, \\text{mean}}[5]$ using the final flux and current values.\n    b. Calculate the torque variance $\\operatorname{Var}(T_e[5])$ using the final flux values, final current values, final flux variances, and the current measurement variance $\\sigma_i^2$.\n    c. Compute the torque standard deviation $\\sigma_{T_e}[5] = \\sqrt{\\operatorname{Var}(T_e[5])}$.\n5.  **Output**: Store the pair $[T_{e, \\text{mean}}[5], \\sigma_{T_e}[5]]$, rounded to six decimal places.\n\nThis procedure is deterministic and directly implements the physical and statistical models provided.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the induction machine torque estimation and uncertainty propagation problem.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (general case)\n        {\n            \"Ts\": 0.0001, \"Rs\": 0.5, \"p\": 2, \"qi\": 0.001, \"qv\": 0.01,\n            \"v_alpha_seq\": [230.0, 227.0, 225.0, 228.0, 229.0],\n            \"v_beta_seq\": [0.0, 20.0, -15.0, 10.0, 5.0],\n            \"i_alpha_seq\": [10.0, 10.5, 9.8, 10.2, 10.1],\n            \"i_beta_seq\": [0.0, -1.0, 0.5, -0.2, 0.3],\n        },\n        # Case 2 (boundary case: no quantization)\n        {\n            \"Ts\": 0.0001, \"Rs\": 0.5, \"p\": 2, \"qi\": 0.0, \"qv\": 0.0,\n            \"v_alpha_seq\": [230.0, 227.0, 225.0, 228.0, 229.0],\n            \"v_beta_seq\": [0.0, 20.0, -15.0, 10.0, 5.0],\n            \"i_alpha_seq\": [10.0, 10.5, 9.8, 10.2, 10.1],\n            \"i_beta_seq\": [0.0, -1.0, 0.5, -0.2, 0.3],\n        },\n        # Case 3 (edge case: higher quantization and longer sampling period)\n        {\n            \"Ts\": 0.0003, \"Rs\": 0.8, \"p\": 3, \"qi\": 0.005, \"qv\": 0.05,\n            \"v_alpha_seq\": [240.0, 238.0, 235.0, 239.0, 241.0],\n            \"v_beta_seq\": [10.0, -5.0, 15.0, -10.0, 0.0],\n            \"i_alpha_seq\": [15.0, 14.8, 15.2, 14.9, 15.1],\n            \"i_beta_seq\": [-2.0, -1.5, -1.0, -0.5, 0.0],\n        },\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        # Unpack parameters\n        Ts = case[\"Ts\"]\n        Rs = case[\"Rs\"]\n        p = case[\"p\"]\n        qi = case[\"qi\"]\n        qv = case[\"qv\"]\n        v_alpha_seq = case[\"v_alpha_seq\"]\n        v_beta_seq = case[\"v_beta_seq\"]\n        i_alpha_seq = case[\"i_alpha_seq\"]\n        i_beta_seq = case[\"i_beta_seq\"]\n\n        # --- Mean Value and Variance Propagation ---\n\n        # Initialize mean flux and its variance at k=0\n        psi_alpha_k = 0.0\n        psi_beta_k = 0.0\n        var_psi_alpha_k = 0.0\n        var_psi_beta_k = 0.0\n\n        num_steps = len(v_alpha_seq)\n\n        # Calculate constant variances from quantization\n        sigma_i_sq = qi**2 / 12.0\n        sigma_v_sq = qv**2 / 12.0\n\n        # Calculate the per-step increase in flux variance\n        delta_var_psi_sq = Ts**2 * (sigma_v_sq + Rs**2 * sigma_i_sq)\n\n        # Loop from k=1 to N (where N=5)\n        # Python index `k_idx` corresponds to `k-1`\n        for k_idx in range(num_steps):\n            v_alpha = v_alpha_seq[k_idx]\n            v_beta = v_beta_seq[k_idx]\n            i_alpha = i_alpha_seq[k_idx]\n            i_beta = i_beta_seq[k_idx]\n\n            # Update mean flux (nominal values) using forward-Euler\n            psi_alpha_k += Ts * (v_alpha - Rs * i_alpha)\n            psi_beta_k += Ts * (v_beta - Rs * i_beta)\n\n            # Update flux variance by accumulating per-step uncertainty\n            var_psi_alpha_k += delta_var_psi_sq\n            var_psi_beta_k += delta_var_psi_sq\n\n        # The loop finishes at k=N. The variables now hold the final values.\n        psi_alpha_N = psi_alpha_k\n        psi_beta_N = psi_beta_k\n        var_psi_alpha_N = var_psi_alpha_k\n        var_psi_beta_N = var_psi_beta_k\n\n        # Get final current values at k=N\n        i_alpha_N = i_alpha_seq[-1]\n        i_beta_N = i_beta_seq[-1]\n        \n        # --- Final Torque and Uncertainty Calculation ---\n        \n        # Torque constant\n        C = 1.5 * p\n\n        # Calculate mean torque at k=N\n        Te_mean_N = C * (psi_alpha_N * i_beta_N - psi_beta_N * i_alpha_N)\n\n        # Calculate torque variance at k=N using first-order propagation\n        var_term1 = i_beta_N**2 * var_psi_alpha_N\n        var_term2 = i_alpha_N**2 * var_psi_beta_N\n        var_term3 = psi_alpha_N**2 * sigma_i_sq\n        var_term4 = psi_beta_N**2 * sigma_i_sq\n        \n        var_Te_N = C**2 * (var_term1 + var_term2 + var_term3 + var_term4)\n\n        # Calculate torque standard deviation\n        Te_std_N = np.sqrt(var_Te_N)\n\n        # Round results to six decimal places\n        Te_mean_rounded = round(Te_mean_N, 6)\n        Te_std_rounded = round(Te_std_N, 6)\n        \n        results.append([Te_mean_rounded, Te_std_rounded])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Having explored the passive consequences of model and measurement imperfections, this final practice challenges you to design a more intelligent and adaptive control law. Here, we address the practical issue of a fluctuating DC-link voltage ($V_{dc}$) not as an error source, but as a dynamic variable to be estimated and compensated for in real-time . By implementing a $V_{dc}$ observer and integrating it into a predictive control framework that minimizes a weighted cost function, you will move beyond classic DTC and engage with the principles of modern model-based control.",
            "id": "3835362",
            "problem": "Consider a squirrel-cage induction machine controlled by Direct Torque Control (DTC) through a three-phase two-level Voltage Source Inverter (VSI). The inverter DC-link voltage is denoted by $V_{dc}$, and the inverter can apply six nonzero space vectors in the stationary $\\alpha\\beta$ frame, each with unit-direction vectors $u_k$ for $k \\in \\{1,2,3,4,5,6\\}$ at angles $(k-1)\\pi/3$ radians. The corresponding applied stator voltage vector is modeled as $v_{s,k} = \\frac{2}{3} V_{dc} u_k$ when switching state $k$ is selected, neglecting dead-time and device voltage drops. The stator voltage equation in the stationary frame is given by the fundamental relationship $v_s = R_s i_s + \\frac{d\\psi_s}{dt}$, where $R_s$ is the stator resistance, $i_s$ is the stator current vector, and $\\psi_s$ is the stator flux linkage vector. The electromagnetic torque used in DTC estimation is $T_e = \\frac{3}{2} p \\left(\\psi_{s\\alpha} i_{s\\beta} - \\psi_{s\\beta} i_{s\\alpha}\\right)$, where $p$ is the number of pole pairs.\n\nTask: Design a real-time observer for $V_{dc}$ and integrate it into the switching decision to maintain accurate control of stator flux magnitude and electromagnetic torque. The observer must estimate $V_{dc}$ at each sampling step by projecting the measured stator voltage vector estimate $v_s$ onto the previously applied unit vector $u_{\\text{prev}}$ and filtering the raw estimate. Specifically, use:\n- $v_s = R_s i_s + \\frac{\\psi_s[k]-\\psi_s[k-1]}{T_s}$, where $T_s$ is the sampling period, and $\\psi_s[k]$ and $\\psi_s[k-1]$ are the current and previous stator flux vectors.\n- The raw DC-link estimate $V_{dc}^{\\text{raw}} = \\frac{3}{2} \\left(v_s \\cdot u_{\\text{prev}}\\right)$.\n- A first-order filtered observer update $V_{dc}[k] = V_{dc}[k-1] + \\gamma \\left(V_{dc}^{\\text{raw}} - V_{dc}[k-1]\\right)$ with filter gain $\\gamma \\in (0,1]$.\n\nIntegrate the observer into the switching decision by predicting the next-step stator flux and torque for each candidate switching state $k \\in \\{1,\\dots,6\\}$ using the estimated $V_{dc}[k]$:\n- $v_{s,k}^{\\text{est}} = \\frac{2}{3} V_{dc}[k] u_k$,\n- $\\psi_s^{\\text{next}}(k) = \\psi_s[k] + T_s \\left(v_{s,k}^{\\text{est}} - R_s i_s[k]\\right)$,\n- $T_e^{\\text{next}}(k) = \\frac{3}{2} p \\left(\\psi_{s\\alpha}^{\\text{next}}(k) i_{s\\beta}[k] - \\psi_{s\\beta}^{\\text{next}}(k) i_{s\\alpha}[k]\\right)$.\n\nSelect the next switching state $k^\\star$ that minimizes a weighted objective combining flux magnitude tracking and torque tracking:\n- $J(k) = w_\\psi \\left|\\left\\|\\psi_s^{\\text{next}}(k)\\right\\| - \\|\\psi_s^{\\text{ref}}\\|\\right| + w_T \\left|T_e^{\\text{ref}} - T_e^{\\text{next}}(k)\\right|$,\nwhere $\\|\\psi_s^{\\text{ref}}\\|$ is the stator flux magnitude reference and $T_e^{\\text{ref}}$ is the torque reference. Use $w_\\psi$ and $w_T$ as positive weights.\n\nAngle quantities must be treated in radians. All physical units must be explicit: $V$ for voltage, $A$ for current, $\\Omega$ for resistance, $Wb$ for flux linkage, $Nm$ for torque, and $s$ for time.\n\nYour program must implement the observer and the switching decision and apply them to the following test suite of independent single-step cases. Use $R_s = 0.5\\,\\Omega$, $p = 2$ pole pairs, and the filter gain $\\gamma = 0.3$. Use weights $w_\\psi = 1.0$ and $w_T = 0.01$.\n\nTest suite (each case provides $T_s$, $i_s[k]$, $\\psi_s[k-1]$, $\\psi_s[k]$, $u_{\\text{prev}}$ index $k_{\\text{prev}}$, previous DC-link estimate $V_{dc}[k-1]$, flux magnitude reference $\\|\\psi_s^{\\text{ref}}\\|$, and torque reference $T_e^{\\text{ref}}$):\n\n- Case 1 (happy path):\n  - $T_s = 50\\times 10^{-6}\\,s$,\n  - $i_s[k] = [10.0\\,A,\\,-5.0\\,A]$,\n  - $\\psi_s[k-1] = [0.700000\\,Wb,\\;0.000000\\,Wb]$,\n  - $\\psi_s[k] = [0.717750\\,Wb,\\;0.000125\\,Wb]$,\n  - $k_{\\text{prev}} = 1$,\n  - $V_{dc}[k-1] = 520.0\\,V$,\n  - $\\|\\psi_s^{\\text{ref}}\\| = 0.800000\\,Wb$,\n  - $T_e^{\\text{ref}} = 30.000000\\,Nm$.\n\n- Case 2 (sector boundary sensitivity):\n  - $T_s = 50\\times 10^{-6}\\,s$,\n  - $i_s[k] = [8.0\\,A,\\;2.0\\,A]$,\n  - $\\psi_s[k-1] = [0.378700\\,Wb,\\;0.588700\\,Wb]$,\n  - $\\psi_s[k] = [0.387000\\,Wb,\\;0.603372\\,Wb]$,\n  - $k_{\\text{prev}} = 2$,\n  - $V_{dc}[k-1] = 480.0\\,V$,\n  - $\\|\\psi_s^{\\text{ref}}\\| = 0.800000\\,Wb$,\n  - $T_e^{\\text{ref}} = 25.000000\\,Nm$.\n\n- Case 3 (low $V_{dc}$, ripple/undervoltage):\n  - $T_s = 100\\times 10^{-6}\\,s$,\n  - $i_s[k] = [-12.0\\,A,\\;3.0\\,A]$,\n  - $\\psi_s[k-1] = [-0.600000\\,Wb,\\;0.050000\\,Wb]$,\n  - $\\psi_s[k] = [-0.619400\\,Wb,\\;0.049850\\,Wb]$,\n  - $k_{\\text{prev}} = 4$,\n  - $V_{dc}[k-1] = 320.0\\,V$,\n  - $\\|\\psi_s^{\\text{ref}}\\| = 0.700000\\,Wb$,\n  - $T_e^{\\text{ref}} = 10.000000\\,Nm$.\n\n- Case 4 (zero torque error, measurement disturbance):\n  - $T_s = 50\\times 10^{-6}\\,s$,\n  - $i_s[k] = [3.0\\,A,\\;-6.0\\,A]$,\n  - $\\psi_s[k-1] = [0.400000\\,Wb,\\;-0.300000\\,Wb]$,\n  - $\\psi_s[k] = [0.409175\\,Wb,\\;-0.315938\\,Wb]$,\n  - $k_{\\text{prev}} = 6$,\n  - $V_{dc}[k-1] = 550.0\\,V$,\n  - $\\|\\psi_s^{\\text{ref}}\\| = 0.500000\\,Wb$,\n  - $T_e^{\\text{ref}} = -4.521708\\,Nm$.\n\nYour program must:\n- Implement the observer and switching decision exactly as specified.\n- For each case, compute the filtered estimate $V_{dc}[k]$ in $V$ and the selected next switching state index $k^\\star \\in \\{1,\\dots,6\\}$.\n- Produce a single line of output containing a list of results for the cases in order, where each result is the pair $[V_{dc}[k], k^\\star]$ with $V_{dc}[k]$ rounded to six decimal places. The final output format must be a single line like $[[v_1,k_1],[v_2,k_2],[v_3,k_3],[v_4,k_4]]$ with no spaces after commas.",
            "solution": "The problem is evaluated to be valid as it is scientifically grounded in the principles of motor control, well-posed with a complete and consistent set of data and equations, and objective in its formulation. We will, therefore, proceed with a complete solution.\n\nThe task is to design and implement a single-step algorithm for a Direct Torque Control (DTC) system. This involves two main components: a real-time observer to estimate the DC-link voltage $V_{dc}$, and a predictive switching logic to select the optimal inverter voltage vector. The solution follows the sequence of calculations as specified.\n\nThe foundation of this control scheme lies in the dynamic model of the induction machine's stator in the stationary $\\alpha\\beta$ reference frame. The stator voltage equation is given by:\n$$\nv_s = R_s i_s + \\frac{d\\psi_s}{dt}\n$$\nwhere $v_s$ is the stator voltage vector, $i_s$ is the stator current vector, $\\psi_s$ is the stator flux linkage vector, and $R_s$ is the stator resistance. The electromagnetic torque, $T_e$, is calculated as a vector cross product:\n$$\nT_e = \\frac{3}{2} p \\left(\\psi_{s\\alpha} i_{s\\beta} - \\psi_{s\\beta} i_{s\\alpha}\\right)\n$$\nwhere $p$ is the number of pole pairs.\n\nThe control actions are discrete voltage vectors generated by a two-level Voltage Source Inverter (VSI). There are six non-zero voltage vectors, $v_{s,k}$, whose direction is defined by unit vectors $u_k$ at angles $(k-1)\\pi/3$ radians for $k \\in \\{1, 2, 3, 4, 5, 6\\}$, and whose magnitude is proportional to the DC-link voltage $V_{dc}$:\n$$\nv_{s,k} = \\frac{2}{3} V_{dc} u_k\n$$\n\nThe overall algorithm consists of two sequential stages executed at each sampling instant $[k]$.\n\n**1. DC-Link Voltage Observer ($V_{dc}$ Estimation)**\n\nThe first stage is to estimate the DC-link voltage $V_{dc}[k]$ based on measurements from the previous time step. This is crucial as fluctuations in $V_{dc}$ directly affect the magnitude of the applied voltage vectors, impacting control accuracy.\n\nFirst, we estimate the actual average stator voltage $v_s$ that was applied during the interval $[k-1, k]$. This is achieved by discretizing the stator voltage equation using a backward difference for the flux derivative:\n$$\nv_s[k] \\approx R_s i_s[k] + \\frac{\\psi_s[k] - \\psi_s[k-1]}{T_s}\n$$\nHere, $i_s[k]$, $\\psi_s[k]$, and $\\psi_s[k-1]$ are measured or estimated quantities at the current and previous steps, and $T_s$ is the sampling period.\n\nThe theoretical voltage applied during the previous interval was $v_{s,\\text{prev}} = \\frac{2}{3} V_{dc} u_{\\text{prev}}$, where $u_{\\text{prev}}$ is the unit vector corresponding to the switching state $k_{\\text{prev}}$ active in that interval. Assuming our calculated $v_s[k]$ is a good approximation of this applied voltage, we can estimate $V_{dc}$ by projecting $v_s[k]$ onto the known direction of $u_{\\text{prev}}$. Since $u_{\\text{prev}}$ is a unit vector, the dot product $v_s[k] \\cdot u_{\\text{prev}}$ isolates the component of $v_s[k]$ along the direction of the applied vector, which ideally equals $\\frac{2}{3} V_{dc}$. Inverting this relationship yields a raw estimate for the DC-link voltage:\n$$\nV_{dc}^{\\text{raw}} = \\frac{3}{2} (v_s[k] \\cdot u_{\\text{prev}})\n$$\nTo mitigate the effects of measurement noise and model inaccuracies, this raw estimate is passed through a first-order low-pass filter. The filtered estimate $V_{dc}[k]$ is updated based on the previous estimate $V_{dc}[k-1]$ and the error between the raw and previous estimate, governed by a filter gain $\\gamma$:\n$$\nV_{dc}[k] = V_{dc}[k-1] + \\gamma (V_{dc}^{\\text{raw}} - V_{dc}[k-1])\n$$\n\n**2. Predictive Switching Decision**\n\nThe second stage uses the newly estimated $V_{dc}[k]$ to predict the outcome of applying each of the six possible non-zero voltage vectors in the next time step, $[k, k+1]$, and selects the one that best meets the control objectives.\n\nThe control objectives are to drive the stator flux magnitude $\\|\\psi_s\\|$ to its reference value $\\|\\psi_s^{\\text{ref}}\\|$ and the electromagnetic torque $T_e$ to its reference $T_e^{\\text{ref}}$. A cost function, $J(k)$, is formulated to quantify the performance of each candidate vector $k \\in \\{1, \\dots, 6\\}$:\n$$\nJ(k) = w_\\psi \\left|\\left\\|\\psi_s^{\\text{next}}(k)\\right\\| - \\|\\psi_s^{\\text{ref}}\\|\\right| + w_T \\left|T_e^{\\text{ref}} - T_e^{\\text{next}}(k)\\right|\n$$\nwhere $w_\\psi$ and $w_T$ are weighting factors.\n\nTo evaluate $J(k)$, we must predict the next-step flux $\\psi_s^{\\text{next}}(k)$ and torque $T_e^{\\text{next}}(k)$ for each candidate vector.\n\nFor each candidate $k$:\na. The estimated voltage vector is calculated using our updated $V_{dc}[k]$:\n$$\nv_{s,k}^{\\text{est}} = \\frac{2}{3} V_{dc}[k] u_k\n$$\nb. The next stator flux vector is predicted by integrating the stator voltage equation forward in time for one sampling period $T_s$ (a forward Euler step):\n$$\n\\psi_s^{\\text{next}}(k) = \\psi_s[k] + T_s (v_{s,k}^{\\text{est}} - R_s i_s[k])\n$$\nc. The next electromagnetic torque is then predicted using the predicted flux vector $\\psi_s^{\\text{next}}(k)$ and the *current* stator current vector $i_s[k]$ (a common simplification):\n$$\nT_e^{\\text{next}}(k) = \\frac{3}{2} p (\\psi_{s\\alpha}^{\\text{next}}(k) i_{s\\beta}[k] - \\psi_{s\\beta}^{\\text{next}}(k) i_{s\\alpha}[k])\n$$\nAfter calculating the predicted flux magnitude $\\|\\psi_s^{\\text{next}}(k)\\|$ and torque $T_e^{\\text{next}}(k)$, the cost $J(k)$ is evaluated. The optimal switching state for the next interval, $k^\\star$, is the one that minimizes this cost function:\n$$\nk^\\star = \\underset{k \\in \\{1,\\dots,6\\}}{\\arg\\min} J(k)\n$$\nThis procedure is implemented for each provided test case, using the specified machine parameters ($R_s = 0.5\\,\\Omega$, $p=2$), control parameters ($\\gamma=0.3$, $w_\\psi=1.0$, $w_T=0.01$), and case-specific initial conditions and references.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a DTC observer and predictive switching logic for an induction machine.\n    \"\"\"\n\n    # --- Fixed Parameters ---\n    R_s = 0.5  # Stator resistance in Ohms\n    p = 2      # Number of pole pairs\n    gamma = 0.3  # Vdc observer filter gain\n    w_psi = 1.0  # Flux error weight\n    w_T = 0.01   # Torque error weight\n\n    # --- Define Unit Vectors for VSI states 1-6 ---\n    # Angles are (k-1)*pi/3 for k in {1,...,6}\n    u_vectors = {\n        i: np.array([np.cos((i - 1) * np.pi / 3), np.sin((i - 1) * np.pi / 3)])\n        for i in range(1, 7)\n    }\n\n    # --- Test Suite Data ---\n    test_cases = [\n        # Case 1 (happy path)\n        {\n            \"Ts\": 50e-6,\n            \"i_s_k\": np.array([10.0, -5.0]),\n            \"psi_s_km1\": np.array([0.700000, 0.000000]),\n            \"psi_s_k\": np.array([0.717750, 0.000125]),\n            \"k_prev\": 1,\n            \"V_dc_km1\": 520.0,\n            \"psi_s_ref_mag\": 0.800000,\n            \"T_e_ref\": 30.000000,\n        },\n        # Case 2 (sector boundary sensitivity)\n        {\n            \"Ts\": 50e-6,\n            \"i_s_k\": np.array([8.0, 2.0]),\n            \"psi_s_km1\": np.array([0.378700, 0.588700]),\n            \"psi_s_k\": np.array([0.387000, 0.603372]),\n            \"k_prev\": 2,\n            \"V_dc_km1\": 480.0,\n            \"psi_s_ref_mag\": 0.800000,\n            \"T_e_ref\": 25.000000,\n        },\n        # Case 3 (low Vdc, ripple/undervoltage)\n        {\n            \"Ts\": 100e-6,\n            \"i_s_k\": np.array([-12.0, 3.0]),\n            \"psi_s_km1\": np.array([-0.600000, 0.050000]),\n            \"psi_s_k\": np.array([-0.619400, 0.049850]),\n            \"k_prev\": 4,\n            \"V_dc_km1\": 320.0,\n            \"psi_s_ref_mag\": 0.700000,\n            \"T_e_ref\": 10.000000,\n        },\n        # Case 4 (zero torque error, measurement disturbance)\n        {\n            \"Ts\": 50e-6,\n            \"i_s_k\": np.array([3.0, -6.0]),\n            \"psi_s_km1\": np.array([0.400000, -0.300000]),\n            \"psi_s_k\": np.array([0.409175, -0.315938]),\n            \"k_prev\": 6,\n            \"V_dc_km1\": 550.0,\n            \"psi_s_ref_mag\": 0.500000,\n            \"T_e_ref\": -4.521708,\n        },\n    ]\n\n    results = []\n\n    for case in test_cases:\n        # --- Stage 1: Vdc Observer ---\n        \n        # Estimate stator voltage from discrete-time model\n        v_s_est = R_s * case[\"i_s_k\"] + (case[\"psi_s_k\"] - case[\"psi_s_km1\"]) / case[\"Ts\"]\n        \n        # Get previously applied unit vector\n        u_prev = u_vectors[case[\"k_prev\"]]\n        \n        # Calculate raw DC-link voltage estimate\n        V_dc_raw = (3.0 / 2.0) * np.dot(v_s_est, u_prev)\n        \n        # Apply first-order filter to get V_dc[k]\n        V_dc_k = case[\"V_dc_km1\"] + gamma * (V_dc_raw - case[\"V_dc_km1\"])\n        \n        # --- Stage 2: Predictive Switching Decision ---\n        \n        costs = []\n        # Test each of the 6 candidate switching states\n        for k_candidate in range(1, 7):\n            u_candidate = u_vectors[k_candidate]\n            \n            # Predict applied stator voltage\n            v_s_k_est = (2.0 / 3.0) * V_dc_k * u_candidate\n            \n            # Predict next stator flux vector\n            psi_s_next = case[\"psi_s_k\"] + case[\"Ts\"] * (v_s_k_est - R_s * case[\"i_s_k\"])\n\n            # Predict next electromagnetic torque\n            psi_s_alpha_next = psi_s_next[0]\n            psi_s_beta_next = psi_s_next[1]\n            i_s_alpha_k = case[\"i_s_k\"][0]\n            i_s_beta_k = case[\"i_s_k\"][1]\n            \n            T_e_next = (3.0 / 2.0) * p * (psi_s_alpha_next * i_s_beta_k - psi_s_beta_next * i_s_alpha_k)\n\n            # Calculate cost function J(k)\n            psi_s_next_mag = np.linalg.norm(psi_s_next)\n            \n            cost = (\n                w_psi * abs(psi_s_next_mag - case[\"psi_s_ref_mag\"]) +\n                w_T * abs(case[\"T_e_ref\"] - T_e_next)\n            )\n            costs.append(cost)\n\n        # Find the index of the minimum cost. Add 1 for 1-based indexing.\n        k_star = np.argmin(costs) + 1\n        \n        results.append([V_dc_k, k_star])\n\n    # --- Format output ---\n    # Example format: [[v1,k1],[v2,k2],[v3,k3],[v4,k4]] with no spaces\n    result_strings = [f\"[{v:.6f},{k}]\" for v, k in results]\n    final_output = f\"[{','.join(result_strings)}]\"\n    \n    print(final_output)\n\nsolve()\n```"
        }
    ]
}