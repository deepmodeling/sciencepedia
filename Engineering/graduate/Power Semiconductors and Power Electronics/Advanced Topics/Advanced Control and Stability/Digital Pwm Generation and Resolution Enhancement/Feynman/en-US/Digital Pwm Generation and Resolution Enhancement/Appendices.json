{
    "hands_on_practices": [
        {
            "introduction": "Understanding the performance of a digital PWM system begins with its most fundamental characteristic: resolution. This exercise guides you through a first-principles derivation of the duty cycle resolution for a classic center-aligned PWM generator . By analyzing the behavior of the underlying digital counter, you will establish the direct relationship between the counter's modulus, $M$, and the smallest achievable, symmetric change in the duty cycle, providing a baseline for evaluating more advanced techniques.",
            "id": "3833739",
            "problem": "A digital Pulse Width Modulation (PWM) generator for a power electronic converter uses a synchronous up-down counter to produce center-aligned PWM. The counter advances on a uniform sampling clock with period $T_s$ and counts the sequence $0,1,\\dots,M, M-1,\\dots,1,0$, where $M$ is a positive integer, and the endpoints are visited exactly once per half-cycle so that there are $2M$ discrete tick intervals per full PWM period. A single integer compare register $c \\in \\{0,1,\\dots,M\\}$ governs symmetric edge placement: the output toggles from low to high when the counter equals $c$ during the up-count and toggles from high to low when the counter equals $c$ during the down-count. The duty ratio $D$ is defined as the fraction of one full period during which the output is high.\n\nStarting only from the discrete-time nature of the counter, the definition of duty ratio as on-time divided by period, and the symmetry implied by the two compare events at the same $c$ on up and down counts, determine the maximum achievable duty resolution, defined as the smallest positive increment in $D$ that can be produced by changing $c$ by its minimal quantum while preserving symmetry. Express the final duty resolution as a unitless fraction in closed form as a function of $M$. No numerical approximation is required.",
            "solution": "The problem is subjected to validation against the established criteria.\n\n### Step 1: Extract Givens\n- **System**: Digital Pulse Width Modulation (PWM) generator for a power electronic converter.\n- **Counter Type**: Synchronous up-down counter generating center-aligned PWM.\n- **Clock**: Uniform sampling clock with period $T_s$.\n- **Counter Sequence**: The counter follows the sequence $0, 1, \\dots, M, M-1, \\dots, 1, 0$. $M$ is a positive integer.\n- **PWM Period**: The full PWM period consists of $2M$ discrete tick intervals.\n- **Compare Register**: A single integer compare value $c$, where $c \\in \\{0, 1, \\dots, M\\}$.\n- **PWM Logic**: The output toggles from low to high when the counter equals $c$ during the up-count. The output toggles from high to low when the counter equals $c$ during the down-count.\n- **Duty Ratio ($D$)**: The fraction of one full period during which the output is high.\n- **Objective**: Determine the maximum achievable duty resolution, defined as the smallest positive increment in $D$ that can be produced by changing $c$ by its minimal quantum while preserving symmetry.\n\n### Step 2: Validate Using Extracted Givens\nThe problem describes a standard, textbook model of a digital symmetric PWM generator used in power electronics.\n- **Scientific Groundedness**: The physical model is based on established principles of digital logic (counters, comparators) and discrete-time systems, which are fundamental to digital control. No scientific flaws are present.\n- **Well-Posedness**: The problem is well-posed. It provides a complete description of the system's operation and asks for a specific, derivable quantity (duty resolution) as a function of a given parameter ($M$). A unique solution is expected.\n- **Objectivity**: The problem is stated in precise, objective, and technical language, free from ambiguity or subjective content. All terms like \"duty ratio\" and \"duty resolution\" are explicitly defined.\n- **Consistency and Completeness**: The provided information is self-consistent. The counter sequence $0, \\dots, M, \\dots, 0$ involves $M$ steps up and $M$ steps down, totaling $2M$ steps. With each step corresponding to a clock tick of period $T_s$, the total PWM period is $2M \\cdot T_s$. This is consistent with the statement that there are $2M$ discrete tick intervals per period.\n\n### Step 3: Verdict and Action\nThe problem is deemed **valid** as it is scientifically sound, well-posed, objective, and self-consistent. The solution process may proceed.\n\n### Solution Derivation\nThe solution is derived from the fundamental principles of the discrete-time counter operation as described.\n\nFirst, we establish the total period of the PWM signal, $T_{PWM}$. The counter advances on a clock with period $T_s$. The count sequence from $0$ to $M$ constitutes the up-counting phase and takes $M$ clock ticks, for a duration of $M \\cdot T_s$. The sequence from $M$ back to $0$ constitutes the down-counting phase and also takes $M$ clock ticks, for a duration of $M \\cdot T_s$. The total period is the sum of the up-count and down-count durations.\n$$T_{PWM} = M \\cdot T_s + M \\cdot T_s = 2M \\cdot T_s$$\nThis aligns with the problem statement that there are $2M$ tick intervals per period.\n\nNext, we determine the on-time of the PWM pulse, $T_{on}$, as a function of the compare value $c$. The pulse is symmetric and center-aligned. Let time $t=0$ be the beginning of the cycle, where the counter value is $0$.\nThe rising edge of the PWM pulse occurs when the counter, during its up-count, reaches the value $c$. Since the counter increments by $1$ at each clock tick $T_s$, this event happens at time $t_{rise}$.\n$$t_{rise} = c \\cdot T_s$$\nThe falling edge of the PWM pulse occurs when the counter, during its down-count, reaches the value $c$. The up-count phase ends at the peak value $M$ at time $M \\cdot T_s$. The down-count then begins. To go from value $M$ down to value $c$, the counter must take $M-c$ steps. Each step takes $T_s$. Therefore, the time elapsed from the peak to the falling edge is $(M-c) \\cdot T_s$. The absolute time of the falling edge, $t_{fall}$, is:\n$$t_{fall} = (\\text{time to peak}) + (\\text{time from peak to } c) = M \\cdot T_s + (M-c) \\cdot T_s = (2M-c) \\cdot T_s$$\nThe on-time, $T_{on}$, is the duration between the falling and rising edges.\n$$T_{on}(c) = t_{fall} - t_{rise} = (2M-c) \\cdot T_s - c \\cdot T_s = (2M - 2c) \\cdot T_s$$\nThe duty ratio, $D$, is defined as the ratio of the on-time to the total period.\n$$D(c) = \\frac{T_{on}(c)}{T_{PWM}} = \\frac{(2M - 2c) \\cdot T_s}{2M \\cdot T_s} = \\frac{2(M - c)}{2M} = \\frac{M - c}{M}$$\n\nThe duty resolution is defined as the smallest positive increment in $D$ that can be produced by changing $c$ by its minimal quantum. The compare value $c$ is an integer, so its minimal quantum of change is $\\Delta c = \\pm 1$.\nThe relationship between $D$ and $c$ is $D(c) = 1 - c/M$. To achieve a positive increment in $D$, we must decrease $c$. The smallest change in $c$ that produces a positive change in $D$ is $\\Delta c = -1$.\nLet the new compare value be $c' = c - 1$. The new duty ratio is $D(c')$.\n$$D(c') = \\frac{M - c'}{M} = \\frac{M - (c-1)}{M} = \\frac{M-c+1}{M}$$\nThe change in duty ratio, $\\Delta D$, is the difference between the new duty ratio and the original one.\n$$\\Delta D = D(c') - D(c) = \\frac{M-c+1}{M} - \\frac{M-c}{M} = \\frac{(M-c+1) - (M-c)}{M} = \\frac{1}{M}$$\nThis increment is a constant positive value for any allowed integer change in $c$. It does not depend on the specific value of $c$. Thus, this is the smallest positive increment achievable.\nThe requirement of preserving symmetry is inherently satisfied. The center of the pulse is located at $\\frac{t_{rise} + t_{fall}}{2} = \\frac{c \\cdot T_s + (2M-c) \\cdot T_s}{2} = \\frac{2M \\cdot T_s}{2} = M \\cdot T_s$. Since this time is independent of $c$, changing $c$ modifies the pulse width symmetrically around this fixed center point.\nTherefore, the maximum achievable duty resolution is $\\frac{1}{M}$.",
            "answer": "$$ \\boxed{\\frac{1}{M}} $$"
        },
        {
            "introduction": "While the theoretical duty cycle range of a PWM generator is $[0, 1]$, practical hardware constraints often impose significant limitations. This practice  explores the impact of the minimum required pulse width, a crucial parameter for ensuring safe and reliable switching of power devices like SiC MOSFETs. You will calculate how this physical constraint translates into a restricted feasible duty cycle range and a reduced number of usable PWM steps, a critical consideration in high-frequency converter design.",
            "id": "3833803",
            "problem": "A Silicon Carbide (SiC) Metal-Oxide-Semiconductor Field-Effect Transistor (MOSFET) half-bridge in a direct current to direct current (DC-DC) converter is driven by a digital Pulse Width Modulation (PWM) signal generated from an edge-aligned timer. The timer is clocked at frequency $f_{\\text{clk}}$ and resets every switching period $T_{\\text{sw}}$, producing a single rising edge at the beginning of the period and a falling edge when the counter reaches a programmable compare value. The commanded on-time is therefore quantized to integer multiples of the time-base $\\Delta t = 1/f_{\\text{clk}}$. The gate driver and device dynamics require that any high pulse and any low interval be at least a minimum pulse width $t_{\\min}$ to guarantee proper switching and avoid shoot-through under all operating conditions.\n\nGiven $f_{\\text{clk}} = 100\\,\\text{MHz}$, $T_{\\text{sw}} = 50\\,\\mu\\text{s}$, and $t_{\\min} = 120\\,\\text{ns}$, determine from first principles:\n- the feasible duty cycle range $D$ such that both the high interval and the low interval satisfy the minimum pulse width requirement, and\n- the number of usable duty steps available to the digital PWM when the on-time must be an integer multiple of $\\Delta t$ and both the minimum high-time and minimum low-time constraints are enforced.\n\nRound each endpoint of the duty cycle range to six significant figures. The number of steps is an exact integer and should be left exact. Express the final answer as a row matrix using the order $\\left(D_{\\min}\\ D_{\\max}\\ N_{\\text{usable}}\\right)$, with duty cycle expressed as a unitless decimal.",
            "solution": "The problem is first validated for consistency and scientific soundness. The givens are: timer clock frequency $f_{\\text{clk}} = 100\\,\\text{MHz}$, switching period $T_{\\text{sw}} = 50\\,\\mu\\text{s}$, and a minimum required pulse width (both high and low) of $t_{\\min} = 120\\,\\text{ns}$. The scenario describes a standard digital Pulse Width Modulation (PWM) generation scheme, and the numerical values are physically realistic for a modern power electronic converter utilizing Silicon Carbide (SiC) devices. The problem is well-posed, unambiguous, and contains all necessary information to derive a unique solution. Therefore, the problem is deemed valid and a formal solution can be constructed.\n\nThe core of the problem lies in the quantization of the PWM on-time, $t_{\\text{on}}$, and the constraints imposed by the minimum pulse width requirement, $t_{\\min}$.\n\nFirst, we determine the fundamental time resolution, or time-base $\\Delta t$, of the digital PWM generator. This is the inverse of the timer clock frequency, $f_{\\text{clk}}$:\n$$\n\\Delta t = \\frac{1}{f_{\\text{clk}}} = \\frac{1}{100 \\times 10^6\\,\\text{Hz}} = 10 \\times 10^{-9}\\,\\text{s} = 10\\,\\text{ns}\n$$\nThe on-time $t_{\\text{on}}$ is constrained to be an integer multiple of this time step. We can express this as:\n$$\nt_{\\text{on}} = N \\cdot \\Delta t\n$$\nwhere $N$ is a non-negative integer representing the compare value in the timer.\n\nThe problem imposes two critical constraints:\n1. The high-time interval, $t_{\\text{on}}$, must be greater than or equal to $t_{\\min}$.\n2. The low-time interval, $t_{\\text{off}}$, must be greater than or equal to $t_{\\min}$.\n\nLet us analyze the first constraint for the minimum on-time:\n$$\nt_{\\text{on}} \\geq t_{\\min}\n$$\nSubstituting the quantized expression for $t_{\\text{on}}$:\n$$\nN \\cdot \\Delta t \\geq t_{\\min}\n$$\nSolving for the integer $N$ gives the minimum number of clock cycles for a valid on-time:\n$$\nN \\geq \\frac{t_{\\min}}{\\Delta t} = \\frac{120\\,\\text{ns}}{10\\,\\text{ns}} = 12\n$$\nSince $N$ must be an integer, the minimum allowable value for the compare register is $N_{\\min} = 12$.\n\nNext, we analyze the second constraint for the minimum off-time. The off-time is the remainder of the switching period:\n$$\nt_{\\text{off}} = T_{\\text{sw}} - t_{\\text{on}} = T_{\\text{sw}} - N \\cdot \\Delta t\n$$\nThe constraint on $t_{\\text{off}}$ is:\n$$\nt_{\\text{off}} \\geq t_{\\min}\n$$\nSubstituting the expression for $t_{\\text{off}}$:\n$$\nT_{\\text{sw}} - N \\cdot \\Delta t \\geq t_{\\min}\n$$\nWe rearrange this inequality to solve for the maximum allowable value of $N$:\n$$\nN \\cdot \\Delta t \\leq T_{\\text{sw}} - t_{\\min}\n$$\n$$\nN \\leq \\frac{T_{\\text{sw}} - t_{\\min}}{\\Delta t}\n$$\nTo perform this calculation, we express all time values in consistent units, for example, nanoseconds. Given $T_{\\text{sw}} = 50\\,\\mu\\text{s} = 50000\\,\\text{ns}$:\n$$\nN \\leq \\frac{50000\\,\\text{ns} - 120\\,\\text{ns}}{10\\,\\text{ns}} = \\frac{49880\\,\\text{ns}}{10\\,\\text{ns}} = 4988\n$$\nSince $N$ must be an integer, the maximum allowable value for the compare register is $N_{\\max} = 4988$.\n\nWith the valid integer range for $N$ being $[12, 4988]$, we can now determine the feasible duty cycle range. The duty cycle $D$ is defined as $D = \\frac{t_{\\text{on}}}{T_{\\text{sw}}} = \\frac{N \\cdot \\Delta t}{T_{\\text{sw}}}$.\n\nThe minimum feasible duty cycle, $D_{\\min}$, corresponds to $N_{\\min}$:\n$$\nD_{\\min} = \\frac{N_{\\min} \\cdot \\Delta t}{T_{\\text{sw}}} = \\frac{12 \\cdot 10\\,\\text{ns}}{50\\,\\mu\\text{s}} = \\frac{120 \\times 10^{-9}\\,\\text{s}}{50 \\times 10^{-6}\\,\\text{s}} = 0.0024\n$$\nThe maximum feasible duty cycle, $D_{\\max}$, corresponds to $N_{\\max}$:\n$$\nD_{\\max} = \\frac{N_{\\max} \\cdot \\Delta t}{T_{\\text{sw}}} = \\frac{4988 \\cdot 10\\,\\text{ns}}{50\\,\\mu\\text{s}} = \\frac{49880 \\times 10^{-9}\\,\\text{s}}{50 \\times 10^{-6}\\,\\text{s}} = 0.9976\n$$\nThe problem requires these values to be rounded to six significant figures:\n$$\nD_{\\min} = 0.00240000\n$$\n$$\nD_{\\max} = 0.997600\n$$\n\nFinally, we calculate the number of usable duty steps, $N_{\\text{usable}}$. This is the total number of integer values available for $N$ within the determined feasible range, from $N_{\\min} = 12$ to $N_{\\max} = 4988$, inclusive.\n$$\nN_{\\text{usable}} = N_{\\max} - N_{\\min} + 1 = 4988 - 12 + 1 = 4976 + 1 = 4977\n$$\nThis value is an exact integer.\n\nThe three requested values are $D_{\\min}$, $D_{\\max}$, and $N_{\\text{usable}}$.",
            "answer": "$$\n\\boxed{\\begin{pmatrix} 0.00240000 & 0.997600 & 4977 \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "To achieve the highest performance, modern digital controllers actively compensate for hardware non-idealities and push resolution beyond the timer's native limits. This hands-on problem  requires you to implement a complete digital compensation and enhancement algorithm. You will use an exponentially weighted moving average (EWMA) to estimate switching delays, apply a correction to equalize conduction intervals, and then employ delta-sigma dithering to achieve sub-count, time-averaged resolution, showcasing a powerful synergy of estimation, control, and modulation.",
            "id": "3833737",
            "problem": "A digital pulse-width modulation system uses complementary gate signals with inserted dead-time to drive a half-bridge. The time base is a discrete timer whose period is represented in timer counts. Let the timer period be $N$ counts, the commanded duty fraction be $d \\in [0,1]$, and the compare value $C$ (in counts) define the nominal on-time for the high-side device in an edge-aligned scheme. Due to propagation delays and dead-time, the switching-node transitions occur with delays relative to the timer edges. The rising transition delay is denoted $d_r$ (counts) and the falling transition delay is denoted $d_f$ (counts). The effective conduction interval of the high-side device is the time between the actual rising and falling switching-node transitions.\n\nFundamental base:\n- The effective conduction interval of the high-side device is by definition the difference between the times of the actual switching-node transitions. If the commanded compare produces a nominal falling edge at time $C$ (in counts) and the rising transition is nominally at time $0$, the effective conduction interval is\n$$\nT_{\\text{on}} = C + d_f - d_r.\n$$\n- The desired effective conduction interval is \n$$\nT_{\\text{on}}^\\star = d\\,N,\n$$\nwhich enforces the average behavior consistent with the commanded duty and equalizes conduction intervals of complementary devices in the presence of asymmetric delays.\n- A capture unit provides time measurements of switching-node transitions relative to the timer reference edges. Given sequences of measured delays $\\{d_r^{(i)}\\}_{i=1}^M$ and $\\{d_f^{(i)}\\}_{i=1}^M$, a causal exponentially weighted moving average estimate for the delays is defined recursively by\n$$\n\\hat d_r^{(1)} = d_r^{(1)}, \\quad \\hat d_r^{(i)} = \\alpha\\, d_r^{(i)} + (1-\\alpha)\\, \\hat d_r^{(i-1)} \\quad \\text{for } i \\in \\{2,\\dots,M\\},\n$$\nand similarly for $\\hat d_f^{(i)}$, where $\\alpha \\in (0,1]$ is the smoothing factor. The final estimates are $\\hat d_r = \\hat d_r^{(M)}$ and $\\hat d_f = \\hat d_f^{(M)}$.\n\nDesign goal:\n- Compute a corrected compare value $C^\\star$ (in counts) that enforces $T_{\\text{on}} = T_{\\text{on}}^\\star$ under the estimated delays, subject to a guard-band constraint $g$ (in counts) to avoid edge collisions, so that\n$$\nC^\\star = \\mathrm{clip}\\Big(d\\,N - (\\hat d_f - \\hat d_r),\\, g,\\, N-g\\Big),\n$$\nwhere $\\mathrm{clip}(x,a,b)$ saturates $x$ into the interval $[a,b]$.\n\nResolution enhancement:\n- The timer compare register is integer-quantized. To achieve sub-count effective resolution, implement first-order delta-sigma fractional dithering. Let the fractional part be $\\phi = C^\\star - \\lfloor C^\\star \\rfloor$. Define an accumulator $a_1 = 0$. For cycle $k \\in \\{1,\\dots,K\\}$, compute\n$$\nu_k = \\begin{cases}\n1, & a_k + \\phi \\ge 1\\\\\n0, & \\text{otherwise},\n\\end{cases}\n\\quad\nC_k = \\lfloor C^\\star \\rfloor + u_k, \n\\quad\na_{k+1} = a_k + \\phi - u_k.\n$$\nThis yields a sequence $\\{C_k\\}_{k=1}^K$ of integer compare values whose average over $K$ cycles converges to $C^\\star$ as $K$ grows, thereby enhancing effective resolution.\n\nYour task:\n- Implement a program that, for each provided test case, performs the following steps:\n    1. Use the provided $\\alpha$ and the measured sequences $\\{d_r^{(i)}\\}$ and $\\{d_f^{(i)}\\}$ to compute $\\hat d_r$ and $\\hat d_f$ via the exponential recursion above.\n    2. Compute $C^\\star$ using the conduction-interval equality $C^\\star = d\\,N - (\\hat d_f - \\hat d_r)$ and clip it to $[g, N-g]$.\n    3. Generate $K$ integer compare values $\\{C_k\\}_{k=1}^K$ using the delta-sigma dithering rule.\n- The result for each test case is the list $\\{C_k\\}_{k=1}^K$ of integers.\n- The final output must be a single line containing the results for all test cases as a comma-separated list enclosed in square brackets, where each element is itself a bracketed, comma-separated list of integers; for example, $[[1,2],[3,4]]$.\n\nTest suite:\nProvide outputs for the following seven test cases. All delay samples are in timer counts.\n\n- Case $1$: $N = 2000$, $d = 0.4$, $g = 20$, $\\alpha = 0.6$, $K = 10$,\n  $d_r$ samples $= [27.2, 28.5, 29.1, 28.9]$,\n  $d_f$ samples $= [12.4, 11.8, 12.1, 12.0]$.\n\n- Case $2$: $N = 1000$, $d = 0.5$, $g = 10$, $\\alpha = 0.5$, $K = 8$,\n  $d_r$ samples $= [60, 59, 61]$,\n  $d_f$ samples $= [20, 21, 19]$.\n\n- Case $3$: $N = 500$, $d = 0.02$, $g = 12$, $\\alpha = 0.7$, $K = 6$,\n  $d_r$ samples $= [15.5, 15.2]$,\n  $d_f$ samples $= [10.1, 9.9]$.\n\n- Case $4$: $N = 1024$, $d = 0.95$, $g = 16$, $\\alpha = 0.5$, $K = 12$,\n  $d_r$ samples $= [7.5, 8.1, 8.0, 7.9]$,\n  $d_f$ samples $= [23.5, 24.0, 24.3, 24.1]$.\n\n- Case $5$: $N = 800$, $d = 0.01$, $g = 10$, $\\alpha = 0.6$, $K = 5$,\n  $d_r$ samples $= [25.0, 25.0, 25.0]$,\n  $d_f$ samples $= [2.0, 2.0, 2.0]$.\n\n- Case $6$: $N = 1000$, $d = 0.99$, $g = 15$, $\\alpha = 0.5$, $K = 7$,\n  $d_r$ samples $= [2.0, 2.0]$,\n  $d_f$ samples $= [0.0, 0.0]$.\n\n- Case $7$: $N = 1200$, $d = 0.01$, $g = 20$, $\\alpha = 0.6$, $K = 4$,\n  $d_r$ samples $= [50.0, 50.0, 50.0]$,\n  $d_f$ samples $= [100.0, 100.0, 100.0]$.\n\nConstraints and outputs:\n- All computations must be performed in timer counts (dimensionless). No physical units are to be used.\n- For each case, output the list $\\{C_k\\}_{k=1}^K$ of integers. \n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with each inner list formatted similarly (for example, $[[c_{1,1},\\dots,c_{1,K_1}],[c_{2,1},\\dots],\\dots]$).",
            "solution": "The user has provided a well-defined problem in the domain of digital power electronics, specifically concerning the generation of high-resolution Pulse-Width Modulation (PWM) signals. The task requires a multi-step computation involving signal processing, feedback control, and digital synthesis techniques. The problem is validated as scientifically sound, well-posed, and complete.\n\nThe solution is implemented by following the sequence of operations defined in the problem statement for each test case.\n\n**1. Delay Estimation**\n\nThe first step is to estimate the effective rising-edge delay, $\\hat d_r$, and falling-edge delay, $\\hat d_f$, from the provided sequences of measurements $\\{d_r^{(i)}\\}_{i=1}^M$ and $\\{d_f^{(i)}\\}_{i=1}^M$. The specified method is a causal Exponentially Weighted Moving Average (EWMA), which is a type of infinite impulse response (IIR) low-pass filter. It computes a smoothed estimate of the delays, giving more weight to recent measurements. The recursive formulas are:\n$$\n\\hat d_r^{(1)} = d_r^{(1)}\n$$\n$$\n\\hat d_r^{(i)} = \\alpha\\, d_r^{(i)} + (1-\\alpha)\\, \\hat d_r^{(i-1)} \\quad \\text{for } i \\in \\{2,\\dots,M\\}\n$$\nand identically for $\\hat d_f$. Here, $\\alpha \\in (0,1]$ is the smoothing factor. The final estimates used for compensation, $\\hat d_r$ and $\\hat d_f$, are the final values from the recursion, i.e., $\\hat d_r = \\hat d_r^{(M)}$ and $\\hat d_f = \\hat d_f^{(M)}$.\n\n**2. Corrected Compare Value Calculation**\n\nThe core of the control strategy is to adjust the timer's compare value, $C$, to compensate for the asymmetric delays, $\\hat d_r$ and $\\hat d_f$. The goal is to make the actual, or effective, high-side conduction interval, $T_{\\text{on}}$, equal to the desired interval, $T_{\\text{on}}^\\star$.\n\nThe effective conduction interval is given by the actual time between the rising and falling transitions of the switching node:\n$$\nT_{\\text{on}} = C + d_f - d_r\n$$\nThe desired interval is determined by the commanded duty fraction, $d$, and the timer period, $N$:\n$$\nT_{\\text{on}}^\\star = d\\,N\n$$\nEquating the two, using the estimated delays $\\hat d_r$ and $\\hat d_f$, yields the ideal compare value:\n$$\nC + \\hat d_f - \\hat d_r = d\\,N\n$$\nSolving for $C$ gives the unconstrained corrected compare value:\n$$\nC = d\\,N - (\\hat d_f - \\hat d_r)\n$$\nTo prevent hardware issues such as shoot-through or violation of minimum on/off time constraints, this value must be saturated to lie within a safe operating range. A guard-band, $g$, is specified, which defines the minimum and maximum allowable compare values. The final corrected compare value, $C^\\star$, is therefore clipped to the interval $[g, N-g]$:\n$$\nC^\\star = \\mathrm{clip}\\Big(d\\,N - (\\hat d_f - \\hat d_r),\\, g,\\, N-g\\Big)\n$$\nwhere $\\mathrm{clip}(x, a, b)$ is a function that returns $a$ if $x < a$, $b$ if $x > b$, and $x$ otherwise.\n\n**3. First-Order Delta-Sigma Dithering for Resolution Enhancement**\n\nThe computed value $C^\\star$ is a floating-point number, but the timer hardware accepts only integer compare values. Simply rounding $C^\\star$ would introduce quantization error, limiting the resolution to one timer count. To achieve sub-count average resolution, first-order delta-sigma fractional dithering is employed.\n\nThis technique generates a sequence of integer compare values, $\\{C_k\\}_{k=1}^K$, that, over $K$ cycles, has an average value that approximates $C^\\star$. The algorithm operates on the fractional part of $C^\\star$, denoted $\\phi = C^\\star - \\lfloor C^\\star \\rfloor$, where $\\lfloor \\cdot \\rfloor$ is the floor function.\n\nAn accumulator, $a$, tracks the cumulative quantization error. It is initialized to $a_1 = 0$. For each PWM cycle $k$ from $1$ to $K$, the following steps are performed:\n1.  An output bit, $u_k$, is determined by comparing the sum of the current accumulator value and the fractional part to $1$:\n    $$\n    u_k = \\begin{cases}\n    1, & \\text{if } a_k + \\phi \\ge 1 \\\\\n    0, & \\text{otherwise}\n    \\end{cases}\n    $$\n2.  The integer compare value for the cycle, $C_k$, is the sum of the integer part of $C^\\star$ and the output bit $u_k$:\n    $$\n    C_k = \\lfloor C^\\star \\rfloor + u_k\n    $$\n3.  The accumulator is updated for the next cycle by adding the fractional part and subtracting the integer part that was just output ($u_k$):\n    $$\n    a_{k+1} = a_k + \\phi - u_k\n    $$\nThis process effectively \"spreads\" the fractional part $\\phi$ across multiple cycles by occasionally incrementing the integer compare value. The accumulator ensures that the long-term average of the output sequence $\\{C_k\\}$ converges to $C^\\star$. The resulting list of integers $\\{C_k\\}_{k=1}^K$ is the final output for each test case.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\n# No other libraries outside the Python standard library are permitted.\n\ndef solve():\n    \"\"\"\n    Computes corrected PWM compare values using EWMA delay estimation and \n    delta-sigma dithering for a series of test cases.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1\n        {'N': 2000, 'd': 0.4, 'g': 20, 'alpha': 0.6, 'K': 10,\n         'dr_samples': [27.2, 28.5, 29.1, 28.9],\n         'df_samples': [12.4, 11.8, 12.1, 12.0]},\n        # Case 2\n        {'N': 1000, 'd': 0.5, 'g': 10, 'alpha': 0.5, 'K': 8,\n         'dr_samples': [60, 59, 61],\n         'df_samples': [20, 21, 19]},\n        # Case 3\n        {'N': 500, 'd': 0.02, 'g': 12, 'alpha': 0.7, 'K': 6,\n         'dr_samples': [15.5, 15.2],\n         'df_samples': [10.1, 9.9]},\n        # Case 4\n        {'N': 1024, 'd': 0.95, 'g': 16, 'alpha': 0.5, 'K': 12,\n         'dr_samples': [7.5, 8.1, 8.0, 7.9],\n         'df_samples': [23.5, 24.0, 24.3, 24.1]},\n        # Case 5\n        {'N': 800, 'd': 0.01, 'g': 10, 'alpha': 0.6, 'K': 5,\n         'dr_samples': [25.0, 25.0, 25.0],\n         'df_samples': [2.0, 2.0, 2.0]},\n        # Case 6\n        {'N': 1000, 'd': 0.99, 'g': 15, 'alpha': 0.5, 'K': 7,\n         'dr_samples': [2.0, 2.0],\n         'df_samples': [0.0, 0.0]},\n        # Case 7\n        {'N': 1200, 'd': 0.01, 'g': 20, 'alpha': 0.6, 'K': 4,\n         'dr_samples': [50.0, 50.0, 50.0],\n         'df_samples': [100.0, 100.0, 100.0]},\n    ]\n    \n    results = []\n\n    def calculate_ewma(samples, alpha):\n        \"\"\"Calculates the exponentially weighted moving average for a sequence.\"\"\"\n        if not samples:\n            return 0.0\n        \n        ewma_val = float(samples[0])\n        for i in range(1, len(samples)):\n            ewma_val = alpha * float(samples[i]) + (1.0 - alpha) * ewma_val\n        return ewma_val\n\n    for case in test_cases:\n        N = case['N']\n        d = case['d']\n        g = case['g']\n        alpha = case['alpha']\n        K = case['K']\n        dr_samples = case['dr_samples']\n        df_samples = case['df_samples']\n\n        # Step 1: Compute estimated delays using EWMA\n        d_hat_r = calculate_ewma(dr_samples, alpha)\n        d_hat_f = calculate_ewma(df_samples, alpha)\n\n        # Step 2: Compute corrected compare value C_star\n        c_star_unclipped = d * N - (d_hat_f - d_hat_r)\n        c_star = np.clip(c_star_unclipped, g, N - g)\n\n        # Step 3: Generate integer compare values using delta-sigma dithering\n        c_floor = math.floor(c_star)\n        phi = c_star - c_floor\n        \n        accumulator = 0.0\n        c_k_sequence = []\n        for _ in range(K):\n            u_k = 1 if accumulator + phi >= 1.0 else 0\n            \n            c_k = int(c_floor + u_k)\n            c_k_sequence.append(c_k)\n            \n            accumulator = accumulator + phi - u_k\n\n        results.append(c_k_sequence)\n\n    # Format the final output string as specified: [[...],[...],...]\n    # without spaces within the inner lists.\n    output_str = \"[\" + \",\".join(f\"[{','.join(map(str, r))}]\" for r in results) + \"]\"\n    \n    # Final print statement in the exact required format.\n    print(output_str)\n\nsolve()\n```"
        }
    ]
}