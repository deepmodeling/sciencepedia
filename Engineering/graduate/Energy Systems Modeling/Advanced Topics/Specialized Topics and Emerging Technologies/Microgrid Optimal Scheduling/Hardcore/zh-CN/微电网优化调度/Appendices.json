{
    "hands_on_practices": [
        {
            "introduction": "所有优化调度的核心是经济调度，即如何以最低成本满足负荷需求。本实践从一个单一调度周期入手，要求我们根据不同资源的边际成本（从光伏、储能的零成本，到发电机的燃料成本，再到代表失负荷价值的高昂削负荷成本）来确定最优的发电组合。通过这个基础练习，您将掌握经济调度的核心思想，这是构建更复杂多周期和随机调度模型的基础。",
            "id": "4103643",
            "problem": "考虑一个孤岛运行的直流-交流 (DC-AC) 微电网，其单个调度区间的时长为 $\\Delta t = 1$ 小时。该微电网使用三种资源为外生负荷 $L$ 供电：一个可用有功功率为 $P^{\\text{pv}}$ 的光伏阵列，一个可调度有功功率为 $P_g$ 的柴油发电机，以及一个从其充电状态提供有功功率 $p_b$ 的电池储能系统。微电网运营商必须确保瞬时有功功率平衡，通过非自愿削减来弥补任何功率缺口，该削减由一个受上界 $s \\le L$ 约束的非负甩负荷变量 $s \\ge 0$ 建模。目标是最小化运行成本，该成本包括发电机的线性燃料成本和反映甩负荷的失负荷价值 (VOLL) 的高额惩罚，而光伏阵列没有边际成本，电池放电的边际成本可忽略不计。基本的物理约束是交流母线上的有功功率平衡。\n\n要求您从第一性原理出发，为这个单区间问题推导出一个正确的优化公式，并在以下数据和假设下，确定最优的非自愿削减量 $s^{\\star}$：\n\n- 交流母线上的瞬时有功功率平衡约束为\n$$\np_{\\text{pv}} + p_b + P_g = L - s,\n$$\n其中 $p_{\\text{pv}}$ 是利用的光伏有功功率，$p_b$ 是输送到交流母线的电池放电有功功率，$P_g$ 是发电机有功功率，$s$ 是甩负荷变量。\n\n- 光伏利用率满足\n$$\n0 \\le p_{\\text{pv}} \\le P^{\\text{pv}},\n$$\n且削减光伏功率的边际成本为零。\n\n- 输送到交流母线的电池放电功率受到逆变器功率限制和充电状态下的可用能量的共同限制，放电效率为 $\\eta_{\\text{dis}} \\in (0,1]$。在时长 $\\Delta t$ 内，输送的有功功率约束为\n$$\n0 \\le p_b \\le \\eta_{\\text{dis}} \\min\\!\\left(P^{\\max}_{\\text{dis}}, \\frac{E^{\\text{avail}}}{\\Delta t}\\right).\n$$\n\n- 柴油发电机在其额定功率范围内可调度：\n$$\n0 \\le P_g \\le P^{\\max}_g,\n$$\n并产生线性燃料成本，其边际成本为 $c_g  0$ 美元/千瓦时。\n\n- 非自愿削减会产生高额惩罚 $\\nu  0$ 美元/千瓦时，代表失负荷价值 (VOLL)。甩负荷变量服从\n$$\n0 \\le s \\le L.\n$$\n\n- 优化目标是线性燃料成本和VOLL惩罚之和：\n$$\n\\min \\; c_g P_g \\Delta t + \\nu s \\Delta t.\n$$\n假设 $\\nu \\gg c_g$，因此优化器会优先使用任何可用的零成本或低成本电源，然后再进行甩负荷。\n\n使用以下数值，所有这些数值都科学真实且自洽：\n- $L = 670$ 千瓦。\n- $P^{\\text{pv}} = 130$ 千瓦。\n- $\\eta_{\\text{dis}} = 0.92$。\n- $P^{\\max}_{\\text{dis}} = 60$ 千瓦。\n- $E^{\\text{avail}} = 42$ 千瓦时。\n- $P^{\\max}_g = 420$ 千瓦。\n- $c_g = 0.20$ 美元/千瓦时。\n- $\\nu = 12.00$ 美元/千瓦时。\n\n从上述物理有功功率平衡和资源约束出发，并利用所述的成本结构，确定最优的非自愿削减量 $s^{\\star}$。请以千瓦为单位表示您的最终答案，并将其四舍五入到四位有效数字。",
            "solution": "首先根据提供的准则评估问题的有效性。\n\n**问题验证**\n\n**步骤1：提取给定条件**\n- 目标函数：$\\min \\; c_g P_g \\Delta t + \\nu s \\Delta t$。\n- 有功功率平衡约束：$p_{\\text{pv}} + p_b + P_g = L - s$。\n- 光伏功率约束：$0 \\le p_{\\text{pv}} \\le P^{\\text{pv}}$。\n- 电池功率约束：$0 \\le p_b \\le \\eta_{\\text{dis}} \\min\\!\\left(P^{\\max}_{\\text{dis}}, \\frac{E^{\\text{avail}}}{\\Delta t}\\right)$。\n- 发电机功率约束：$0 \\le P_g \\le P^{\\max}_g$。\n- 甩负荷约束：$0 \\le s \\le L$。\n- 问题数据：\n  - 负荷：$L = 670$ 千瓦。\n  - 可用光伏功率：$P^{\\text{pv}} = 130$ 千瓦。\n  - 电池放电效率：$\\eta_{\\text{dis}} = 0.92$。\n  - 电池逆变器功率限制：$P^{\\max}_{\\text{dis}} = 60$ 千瓦。\n  - 电池可用能量：$E^{\\text{avail}} = 42$ 千瓦时。\n  - 发电机最大功率：$P^{\\max}_g = 420$ 千瓦。\n  - 发电机边际成本：$c_g = 0.20$ 美元/千瓦时。\n  - 失负荷价值 (VOLL)：$\\nu = 12.00$ 美元/千瓦时。\n  - 调度区间：$\\Delta t = 1$ 小时。\n\n**步骤2：使用提取的给定条件进行验证**\n- **科学依据**：该问题描述了微电网的单区间经济调度。这是电力系统工程中一个标准且基本的问题。其公式，包括功率平衡方程、资源约束和成本函数，都基于已建立的物理和经济原则。\n- **适定性**：该问题是一个线性规划问题，其特点是线性的目标函数和线性的约束条件。由于存在可行解（例如，将所有发电量设为零并削减全部负荷，$s=L$），且目标函数有下界零，因此保证存在唯一的最优解。\n- **客观性与一致性**：问题陈述使用了精确、无歧义的技术语言。所有数据均已提供，量纲分析证实了其一致性。例如，$\\frac{E^{\\text{avail}}}{\\Delta t}$ 的单位是功率（$\\frac{\\text{kWh}}{\\text{h}} = \\text{kW}$），与功率限制 $P^{\\max}_{\\text{dis}}$ 一致。成本函数的单位是美元。\n\n**步骤3：结论与行动**\n该问题被认为是**有效的**，因为它具有科学依据、适定、客观且自洽。可以进行求解过程。\n\n**求解推导**\n\n目标是最小化总运行成本，该成本是发电机使用和甩负荷的函数：\n$$\n\\text{Cost} = c_g P_g \\Delta t + \\nu s \\Delta t\n$$\n由于时长 $\\Delta t$ 是一个正常数（1小时），最小化此成本等价于最小化表达式 $c_g P_g + \\nu s$。这个问题可以通过应用经济调度原则来解决，即根据发电资源的边际成本从低到高进行优先调用。\n\n可用资源的边际成本如下：\n1. 光伏功率 ($p_{\\text{pv}}$)：边际成本为 $0$。\n2. 电池放电功率 ($p_b$)：边际成本可忽略不计，因此取为 $0$。\n3. 柴油发电机功率 ($P_g$)：边际成本为 $c_g = 0.20$ 美元/千瓦时。\n4. 甩负荷 ($s$)：这是最昂贵的选项，代表无法满足负荷，其惩罚成本为 $\\nu = 12.00$ 美元/千瓦时。\n\n因此，调度顺序为：（1）光伏和电池，（2）柴油发电机，（3）甩负荷。系统将在调度更昂贵的资源之前，用尽所有来自更便宜资源的可用功率。\n\n首先，我们计算每个发电机组可用的最大功率。\n最大可用光伏功率为：\n$$\nP^{\\max}_{\\text{pv}} = P^{\\text{pv}} = 130 \\, \\text{kW}\n$$\n输送到交流母线的最大电池放电功率 $P^{\\max}_b$ 由其功率额定值和能量容量的较小者决定，并根据效率进行调整：\n$$\nP^{\\max}_b = \\eta_{\\text{dis}} \\min\\!\\left(P^{\\max}_{\\text{dis}}, \\frac{E^{\\text{avail}}}{\\Delta t}\\right)\n$$\n根据给定值，能量限制功率为 $\\frac{E^{\\text{avail}}}{\\Delta t} = \\frac{42 \\, \\text{kWh}}{1 \\, \\text{h}} = 42 \\, \\text{kW}$。\n起作用的约束是逆变器限制和能量限制的最小值：$\\min(60 \\, \\text{kW}, 42 \\, \\text{kW}) = 42 \\, \\text{kW}$。\n应用放电效率后，输送到母线的最大有功功率为：\n$$\nP^{\\max}_b = 0.92 \\times 42 \\, \\text{kW} = 38.64 \\, \\text{kW}\n$$\n最大柴油发电机功率为其铭牌额定值：\n$$\nP^{\\max}_g = 420 \\, \\text{kW}\n$$\n总可用发电容量是所有电源最大功率的总和：\n$$\nP^{\\text{supply}}_{\\text{total}} = P^{\\max}_{\\text{pv}} + P^{\\max}_b + P^{\\max}_g\n$$\n$$\nP^{\\text{supply}}_{\\text{total}} = 130 \\, \\text{kW} + 38.64 \\, \\text{kW} + 420 \\, \\text{kW} = 588.64 \\, \\text{kW}\n$$\n系统负荷为 $L = 670$ kW。我们将负荷与总可用供应进行比较：\n$$\nL = 670 \\, \\text{kW} > P^{\\text{supply}}_{\\text{total}} = 588.64 \\, \\text{kW}\n$$\n由于负荷超过了总发电容量，功率缺口不可避免。为了维持功率平衡，这个缺口必须通过非自愿削减负荷（甩负荷）来满足。最优甩负荷量 $s^{\\star}$ 正是这个缺口值。\n$$\ns^{\\star} = L - P^{\\text{supply}}_{\\text{total}}\n$$\n$$\ns^{\\star} = 670 \\, \\text{kW} - 588.64 \\, \\text{kW} = 81.36 \\, \\text{kW}\n$$\n为最小化成本，所有可用的发电资源都必须以其最大容量进行调度：$p^{\\star}_{\\text{pv}} = 130$ kW，$p^{\\star}_b = 38.64$ kW，以及 $P^{\\star}_g = 420$ kW。剩余的功率不平衡通过甩负荷 $s^{\\star} = 81.36$ kW 来处理。\n\n问题要求将最优非自愿削减量 $s^{\\star}$ 四舍五入到四位有效数字。我们计算出的值为 $81.36$ kW，该值已经是用四位有效数字表示。",
            "answer": "$$\\boxed{81.36}$$"
        },
        {
            "introduction": "在掌握了静态经济调度后，我们将问题扩展到多周期动态场景，并引入微电网的关键组件——储能系统。本实践的目标是利用储能电池在不同电价时段进行充放电，以实现利润最大化的能量套利，这需要您建立一个包含储能状态转移、充放电效率和功率限制的完整线性规划（LP）模型。这个练习将训练您将动态系统的物理和经济约束转化为标准优化模型的核心能力，并要求您通过编程求解，获得宝贵的建模与实现经验。",
            "id": "4103641",
            "problem": "考虑一个微电网中单个电化学电池的三周期能源套利问题。该电池在每个周期与外部市场进行交互，充电时购买能源，放电时出售能源。假设时间是离散的，每个周期的时间步长固定为一小时，因此在一个周期内，能量和功率在数值上是相等的。使用以下物理建模原则和核心定义：\n\n- 每个周期的能量守恒，由荷电状态递推表示，该递推源于考虑了转换损耗的能量守恒。设周期 $t$ 的充电功率为 $c_t \\ge 0$，放电功率为 $d_t \\ge 0$。设周期末的荷电状态为 $E_t$。假设存在一个往返效率参数 $0  \\eta \\le 1$，该参数被分解为对称的充电效率和放电效率，即 $\\eta_c = \\sqrt{\\eta}$ 和 $\\eta_d = \\sqrt{\\eta}$，因此往返效率为 $\\eta_c \\eta_d = \\eta$。荷电状态更新遵循以下公式：\n$$\nE_t = E_{t-1} + \\eta_c \\, c_t - \\frac{1}{\\eta_d} \\, d_t,\n$$\n对于 $t \\in \\{1,2,3\\}$，其中初始荷电状态 $E_0$ 是给定的。\n- 边界约束源于物理限制：\n  - 能量边界 $E_{\\min} \\le E_t \\le E_{\\max}$，对于 $t \\in \\{1,2,3\\}$。\n  - 每个周期 $t$ 的充电功率边界 $0 \\le c_t \\le P_{\\max}^{\\mathrm{ch}}$ 和放电功率边界 $0 \\le d_t \\le P_{\\max}^{\\mathrm{dis}}$。\n- 市场交易以 $p_t$ 美元/千瓦时的价格进行，对于 $t \\in \\{1,2,3\\}$。购买 $c_t$ 会产生 $p_t c_t$ 的成本，而出售 $d_t$ 会获得 $p_t d_t$ 的收入。\n- 为防止剩余能量产生人为价值，施加一个终端约束 $E_3 = E_{\\mathrm{final}}$，其中 $E_{\\mathrm{final}}$ 是指定的。所有能量单位为千瓦时 (kWh)，所有功率单位为千瓦 (kW)，所有价格单位为美元/千瓦时 ($/kWh)。\n\n从这些原则出发，将微电网电池套利问题建模并求解为一个线性优化问题，旨在最大化三个周期内的总利润，同时满足能量守恒、边界约束和终端约束。你的程序必须为每个测试用例计算最优的充/放电量 $(c_1,c_2,c_3)$ 和 $(d_1,d_2,d_3)$ 以及由此产生的总利润。对于所有测试用例，能量平衡、边界一致性和目标函数都必须得到满足。\n\n将所有充放电值表示为千瓦时 (kWh)，总利润表示为美元，每个值都四舍五入到三位小数。最终的程序输出必须是单行，内容是一个包含在方括号中的逗号分隔列表，其中每个元素对应一个测试用例，并且本身也是一个包含七个十进制数的方括号分隔列表：\n$$\n[c_1,c_2,c_3,d_1,d_2,d_3,\\text{profit}].\n$$\n\n使用以下测试套件。对于每个测试用例，参数为 $(p_1,p_2,p_3)$、$\\eta$、$E_0$、$E_{\\mathrm{final}}$、$E_{\\min}$、$E_{\\max}$、$P_{\\max}^{\\mathrm{ch}}$、$P_{\\max}^{\\mathrm{dis}}$：\n\n- 测试用例 1（典型的先价谷后价峰的套利）：\n  - 价格：$(p_1,p_2,p_3) = (\\,\\$\\,0.03,\\,\\$\\,0.01,\\,\\$\\,0.08\\,)$ 每千瓦时。\n  - 效率：$\\eta = 0.9$。\n  - 初始状态：$E_0 = 5$ kWh。\n  - 终端状态：$E_{\\mathrm{final}} = 5$ kWh。\n  - 能量边界：$E_{\\min} = 0$ kWh, $E_{\\max} = 10$ kWh。\n  - 功率边界：$P_{\\max}^{\\mathrm{ch}} = 5$ kW, $P_{\\max}^{\\mathrm{dis}} = 5$ kW。\n- 测试用例 2（电池满电时的单调递减价格）：\n  - 价格：$(p_1,p_2,p_3) = (\\,\\$\\,0.07,\\,\\$\\,0.05,\\,\\$\\,0.04\\,)$ 每千瓦时。\n  - 效率：$\\eta = 0.88$。\n  - 初始状态：$E_0 = 8$ kWh。\n  - 终端状态：$E_{\\mathrm{final}} = 8$ kWh。\n  - 能量边界：$E_{\\min} = 0$ kWh, $E_{\\max} = 8$ kWh。\n  - 功率边界：$P_{\\max}^{\\mathrm{ch}} = 10$ kW, $P_{\\max}^{\\mathrm{dis}} = 10$ kW。\n- 测试用例 3（价格平稳，因损耗无利可图的循环）：\n  - 价格：$(p_1,p_2,p_3) = (\\,\\$\\,0.05,\\,\\$\\,0.05,\\,\\$\\,0.05\\,)$ 每千瓦时。\n  - 效率：$\\eta = 0.95$。\n  - 初始状态：$E_0 = 5$ kWh。\n  - 终端状态：$E_{\\mathrm{final}} = 5$ kWh。\n  - 能量边界：$E_{\\min} = 0$ kWh, $E_{\\max} = 10$ kWh。\n  - 功率边界：$P_{\\max}^{\\mathrm{ch}} = 5$ kW, $P_{\\max}^{\\mathrm{dis}} = 5$ kW。\n- 测试用例 4（放电功率受限且往返效率低）：\n  - 价格：$(p_1,p_2,p_3) = (\\,\\$\\,0.04,\\,\\$\\,0.10,\\,\\$\\,0.06\\,)$ 每千瓦时。\n  - 效率：$\\eta = 0.6$。\n  - 初始状态：$E_0 = 2$ kWh。\n  - 终端状态：$E_{\\mathrm{final}} = 2$ kWh。\n  - 能量边界：$E_{\\min} = 0$ kWh, $E_{\\max} = 6$ kWh。\n  - 功率边界：$P_{\\max}^{\\mathrm{ch}} = 2$ kW, $P_{\\max}^{\\mathrm{dis}} = 1.5$ kW。\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例的结果是一个包含七个十进制数的方括号列表，顺序为 $[c_1,c_2,c_3,d_1,d_2,d_3,\\text{profit}]$，四舍五入到三位小数，例如：\n$$\n[[0.000,0.000,0.000,0.000,0.000,0.000,0.000],[\\dots],\\dots].\n$$",
            "solution": "所提出的问题是确定一个微电网中的电池在三个周期时间范围内的最优能源套利策略。这需要建立并求解一个数学优化问题，以最大化利润，同时满足系统的物理和运营约束。问题陈述具有科学依据、自成体系且定义明确，适用于正式求解。\n\n解决方案的核心在于将问题表述为线性规划 (Linear Program, LP)。一个LP问题包含一个待优化的目标函数和一组约束条件，其中目标函数和约束条件都是决策变量的线性函数。\n\n首先，我们定义决策变量。在每个时间周期 $t \\in \\{1, 2, 3\\}$，电池可以充电或放电。设 $c_t$ 为周期 $t$ 内充入的能量， $d_t$ 为周期 $t$ 内放出的能量。由于时间步长为1小时，功率（单位kW）在数值上等于能量（单位kWh）。整个时间范围内的决策变量被收集到一个向量 $x$ 中：\n$$\nx = [c_1, c_2, c_3, d_1, d_2, d_3]^T\n$$\n这些变量都是非负的，即 $c_t \\ge 0$ 和 $d_t \\ge 0$。\n\n接下来，我们建立目标函数。目标是最大化总利润，即售电总收入减去购电总成本。设市场价格为 $p_t$，则利润 $\\Pi$ 为：\n$$\n\\text{maximize} \\quad \\Pi = \\sum_{t=1}^{3} (p_t d_t - p_t c_t)\n$$\n标准的LP求解器执行最小化操作。最大化 $\\Pi$ 等价于最小化 $-\\Pi$。因此，要最小化的目标函数是：\n$$\n\\text{minimize} \\quad \\sum_{t=1}^{3} (p_t c_t - p_t d_t)\n$$\n这可以写成矩阵形式 $c_{obj}^T x$，其中成本向量 $c_{obj}$ 为：\n$$\nc_{obj} = [p_1, p_2, p_3, -p_1, -p_2, -p_3]^T\n$$\n\n系统受到几个约束的制约。\n\n1.  **荷电状态 (SOC) 动态**：在周期 $t$ 结束时，电池中存储的能量 $E_t$ 根据能量守恒定律演变，并考虑了效率损失。给定的状态方程为：\n    $$\n    E_t = E_{t-1} + \\eta_c c_t - \\frac{1}{\\eta_d} d_t\n    $$\n    其中 $\\eta_c = \\sqrt{\\eta}$ 和 $\\eta_d = \\sqrt{\\eta}$ 分别是充电和放电效率。我们可以用初始状态 $E_0$ 和决策变量来表示 $t \\in \\{1, 2, 3\\}$ 时的 $E_t$：\n    $$\n    E_1 = E_0 + \\eta_c c_1 - \\frac{1}{\\eta_d} d_1\n    $$\n    $$\n    E_2 = E_1 + \\eta_c c_2 - \\frac{1}{\\eta_d} d_2 = E_0 + \\eta_c(c_1 + c_2) - \\frac{1}{\\eta_d}(d_1 + d_2)\n    $$\n    $$\n    E_3 = E_2 + \\eta_c c_3 - \\frac{1}{\\eta_d} d_3 = E_0 + \\eta_c(c_1 + c_2 + c_3) - \\frac{1}{\\eta_d}(d_1 + d_2 + d_3)\n    $$\n\n2.  **能量边界**：存储的能量必须始终保持在物理限制内：\n    $$\n    E_{\\min} \\le E_t \\le E_{\\max} \\quad \\text{for } t \\in \\{1, 2, 3\\}\n    $$\n    这些不等式应用于 $E_1$ 和 $E_2$ 的表达式。对于 $E_3$，给出了一个更具体的约束。这些约束是决策变量的线性函数。对于 $t=1$：\n    $$\n    \\eta_c c_1 - \\frac{1}{\\eta_d} d_1 \\le E_{\\max} - E_0\n    $$\n    $$\n    -\\eta_c c_1 + \\frac{1}{\\eta_d} d_1 \\le E_0 - E_{\\min}\n    $$\n    类似地，对于 $t=2$：\n    $$\n    \\eta_c(c_1 + c_2) - \\frac{1}{\\eta_d}(d_1 + d_2) \\le E_{\\max} - E_0\n    $$\n    $$\n    -\\eta_c(c_1 + c_2) + \\frac{1}{\\eta_d}(d_1 + d_2) \\le E_0 - E_{\\min}\n    $$\n\n3.  **终端状态约束**：施加一个终端约束以确保最终荷电状态为一个指定值 $E_{\\mathrm{final}}$：\n    $$\n    E_3 = E_{\\mathrm{final}}\n    $$\n    代入 $E_3$ 的表达式：\n    $$\n    E_0 + \\eta_c \\sum_{t=1}^{3} c_t - \\frac{1}{\\eta_d} \\sum_{t=1}^{3} d_t = E_{\\mathrm{final}}\n    $$\n    这可以重排为一个线性等式约束：\n    $$\n    \\eta_c \\sum_{t=1}^{3} c_t - \\frac{1}{\\eta_d} \\sum_{t=1}^{3} d_t = E_{\\mathrm{final}} - E_0\n    $$\n\n4.  **功率边界**：充放电速率受限于电池的功率容量：\n    $$\n    0 \\le c_t \\le P_{\\max}^{\\mathrm{ch}} \\quad \\text{for } t \\in \\{1, 2, 3\\}\n    $$\n    $$\n    0 \\le d_t \\le P_{\\max}^{\\mathrm{dis}} \\quad \\text{for } t \\in \\{1, 2, 3\\}\n    $$\n    这些是关于决策变量的简单箱式约束。\n\n问题建模不需要显式约束来防止同时充放电（即 $c_t d_t = 0$）。任何在某个周期 $t$ 满足 $c_t  0$ 和 $d_t  0$ 的可行解都是次优的。由于往返效率损失 $(\\eta = \\eta_c \\eta_d  1)$，可以通过以某种方式小幅减少 $c_t$ 和 $d_t$ 来保持净能量变化不变但降低成本。因此，一个LP求解器将自然地使每个周期中这两个变量之一趋于0。\n\n完整问题通过使用标准LP求解器来解决。我们构建规范LP形式的矩阵和向量：最小化 $c_{obj}^T x$，约束条件为 $A_{eq} x = b_{eq}$，$A_{ub} x \\le b_{ub}$，以及对 $x$ 的元素级边界。\n\n对于给定的参数集 $(p_1, p_2, p_3), \\eta, E_0, E_{\\mathrm{final}}, E_{\\min}, E_{\\max}, P_{\\max}^{\\mathrm{ch}}, P_{\\max}^{\\mathrm{dis}}$：\n\n- **等式约束**：$A_{eq}$ 是一个 $1 \\times 6$ 的矩阵，$b_{eq}$ 是一个标量。\n  $$\n  A_{eq} = [\\eta_c, \\eta_c, \\eta_c, -1/\\eta_d, -1/\\eta_d, -1/\\eta_d]\n  $$\n  $$\n  b_{eq} = [E_{\\mathrm{final}} - E_0]\n  $$\n\n- **不等式约束**：$A_{ub}$ 是一个 $4 \\times 6$ 的矩阵，$b_{ub}$ 是一个 $4 \\times 1$ 的向量。\n  $$\n  A_{ub} = \\begin{pmatrix}\n  \\eta_c   0  0  -1/\\eta_d  0  0 \\\\\n  -\\eta_c  0  0  1/\\eta_d  0  0 \\\\\n  \\eta_c  \\eta_c  0  -1/\\eta_d  -1/\\eta_d  0 \\\\\n  -\\eta_c  -\\eta_c  0  1/\\eta_d  1/\\eta_d  0\n  \\end{pmatrix}\n  $$\n  $$\n  b_{ub} = [E_{\\max} - E_0, E_0 - E_{\\min}, E_{\\max} - E_0, E_0 - E_{\\min}]^T\n  $$\n\n- **边界**：下界均为 $0$。上界为：\n  $$\n  [P_{\\max}^{\\mathrm{ch}}, P_{\\max}^{\\mathrm{ch}}, P_{\\max}^{\\mathrm{ch}}, P_{\\max}^{\\mathrm{dis}}, P_{\\max}^{\\mathrm{dis}}, P_{\\max}^{\\mathrm{dis}}]^T\n  $$\n\nPython实现将为每个测试用例构建这些矩阵和向量，并将它们传递给 `scipy.optimize.linprog` 函数，以找到最优的充放电计划 $x^*$ 和相应的最小成本。最大利润是最小成本的负值。最终结果按指定格式进行格式化。",
            "answer": "```python\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef solve():\n    \"\"\"\n    Solves the microgrid battery arbitrage problem for a suite of test cases.\n    \"\"\"\n    test_cases = [\n        # Test case 1: (p1,p2,p3), eta, E0, E_final, Emin, Emax, Pch_max, Pdis_max\n        ((0.03, 0.01, 0.08), 0.9, 5, 5, 0, 10, 5, 5),\n        # Test case 2\n        ((0.07, 0.05, 0.04), 0.88, 8, 8, 0, 8, 10, 10),\n        # Test case 3\n        ((0.05, 0.05, 0.05), 0.95, 5, 5, 0, 10, 5, 5),\n        # Test case 4\n        ((0.04, 0.10, 0.06), 0.6, 2, 2, 0, 6, 2, 1.5)\n    ]\n\n    results = []\n    for case in test_cases:\n        result = solve_one_case(*case)\n        results.append(result)\n\n    # Format the final output string\n    output_str = \"[\" + \",\".join(\n        \"[\" + \",\".join([f\"{val:.3f}\" for val in res]) + \"]\" for res in results\n    ) + \"]\"\n    print(output_str)\n\ndef solve_one_case(prices, eta, E0, E_final, E_min, E_max, P_max_ch, P_max_dis):\n    \"\"\"\n    Formulates and solves the linear program for a single test case.\n    \n    The decision variable vector is x = [c1, c2, c3, d1, d2, d3].\n    \"\"\"\n    p1, p2, p3 = prices\n    \n    # Efficiencies\n    eta_c = np.sqrt(eta)\n    eta_d = np.sqrt(eta)\n\n    # Objective function: minimize (p*c - p*d)\n    c_obj = np.array([p1, p2, p3, -p1, -p2, -p3])\n\n    # --- Constraints ---\n    \n    # 1. Equality constraint: E3 = E_final\n    # E0 + eta_c*(c1+c2+c3) - (1/eta_d)*(d1+d2+d3) = E_final\n    # eta_c*(c1+c2+c3) - (1/eta_d)*(d1+d2+d3) = E_final - E0\n    A_eq = np.array([[eta_c, eta_c, eta_c, -1/eta_d, -1/eta_d, -1/eta_d]])\n    b_eq = np.array([E_final - E0])\n    \n    # 2. Inequality constraints: E_min = E_t = E_max for t=1, 2\n    # E1 = E_max => E0 + eta_c*c1 - (1/eta_d)*d1 = E_max => eta_c*c1 - (1/eta_d)*d1 = E_max - E0\n    # E1 >= E_min => E0 + eta_c*c1 - (1/eta_d)*d1 >= E_min => -eta_c*c1 + (1/eta_d)*d1 = E0 - E_min\n    # E2 = E_max => E0 + eta_c*(c1+c2) - (1/eta_d)*(d1+d2) = E_max => eta_c*(c1+c2) - (1/eta_d)*(d1+d2) = E_max - E0\n    # E2 >= E_min => E0 + eta_c*(c1+c2) - (1/eta_d)*(d1+d2) >= E_min => -eta_c*(c1+c2) + (1/eta_d)*(d1+d2) = E0 - E_min\n    A_ub = np.array([\n        [eta_c, 0, 0, -1/eta_d, 0, 0],\n        [-eta_c, 0, 0, 1/eta_d, 0, 0],\n        [eta_c, eta_c, 0, -1/eta_d, -1/eta_d, 0],\n        [-eta_c, -eta_c, 0, 1/eta_d, 1/eta_d, 0]\n    ])\n    b_ub = np.array([\n        E_max - E0,\n        E0 - E_min,\n        E_max - E0,\n        E0 - E_min\n    ])\n    \n    # 3. Bounds on variables: 0 = c_t = P_max_ch, 0 = d_t = P_max_dis\n    bounds = (\n        [(0, P_max_ch), (0, P_max_ch), (0, P_max_ch)] +\n        [(0, P_max_dis), (0, P_max_dis), (0, P_max_dis)]\n    )\n\n    # Solve the Linear Program\n    res = linprog(c=c_obj, A_ub=A_ub, b_ub=b_ub, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')\n\n    if res.success:\n        # Clean up near-zero values from solver precision\n        solution = np.maximum(0, res.x)\n        c1, c2, c3 = solution[0:3]\n        d1, d2, d3 = solution[3:6]\n        # Profit is the negative of the minimized objective function value\n        profit = -res.fun\n        return [c1, c2, c3, d1, d2, d3, profit]\n    else:\n        # Should not happen for this well-posed problem, but handle defensively.\n        return [0.0] * 7\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "现实世界中的微电网调度充满了不确定性，尤其是在可再生能源发电和负荷方面，本实践将引导您应对这一挑战，进入两阶段随机规划的领域。对于这类复杂问题，直接求解往往非常困难，因此我们采用如Benders分解法这样的高级算法，该方法将问题分解为主问题（决定“此时此地”的决策）和子问题（评估未来场景下的“追索”决策），并通过迭代生成的“割平面”进行信息交换。这个高阶练习将让您亲手实现一个强大的优化算法，以解决带有不确定性的实际微电网调度问题，从而深入理解随机优化的理论框架与应用。",
            "id": "4103624",
            "problem": "考虑一个在$T$个离散时间段内，净需求存在按场景不确定性的两阶段微电网最优调度问题。该微电网有两个可调度发电机和一个具有周期性输入容量限制的外部电网连接。第一阶段决定发电机的二元启停决策，第二阶段则针对每个场景，在第一阶段启停决策的约束下，独立地进行经济调度。您的任务是通过分离第一阶段的启停决策和第二阶段的按场景调度来实现Benders分解，并推导出迭代优化主问题的最优性割和可行性割。\n\n基本原理和定义：\n- 设 $y_1 \\in \\{0,1\\}$ 和 $y_2 \\in \\{0,1\\}$ 分别为发电机1和发电机2的第一阶段启停决策。该二元值表示发电机是已启停（开）还是未启停（关）。\n- 对于每个场景 $s \\in \\mathcal{S}$ 和每个时间段 $t \\in \\{1,\\dots,T\\}$，定义净缺口 $d_{s,t} = D_{s,t} - \\text{PV}_{s,t}$，其中 $D_{s,t}$ 是需求，$\\text{PV}_{s,t}$ 是可再生光伏发电量。每个时间段的持续时间为1小时，因此功率（$\\text{kW}$）等于该时段内的能量（$\\text{kWh}$）。\n- 场景 $s$下的第二阶段决策变量为 $g_{1,t} \\ge 0$, $g_{2,t} \\ge 0$（发电机出力）和 $g^{\\text{grid}}_{t} \\ge 0$（电网购电），对于 $t=1,\\dots,T$。\n- 发电机容量分别为 $C_1$ 和 $C_2$（单位$\\text{kW}$）；每时段电网购电容量为 $G^{\\max}_t$（单位$\\text{kW}$）。可变发电成本为 $c_1$、$c_2$，电网电价为 $c_G$（单位$\\$/\\text{kWh}$）。固定启停成本为 $F_1$ 和 $F_2$（单位$\\$$）。\n- 场景 $s$ 的第二阶段调度问题是一个线性规划，旨在最小化运营成本，同时满足每时段的平衡和容量约束。\n- Benders主问题包括第一阶段成本和通过变量 $\\theta_s$ 对按场景的递归成本的近似，该近似通过从第二阶段线性规划的对偶性和可行性条件推导出的割进行迭代优化。\n\n您必须从线性规划对偶和可行性条件出发，推导出：\n- 对于每个场景 $s$，使用第二阶段线性规划的对偶乘子，推导出一个形式为 $\\theta_s \\ge \\alpha_s + \\beta_{1,s} y_1 + \\beta_{2,s} y_2$ 的最优性割。\n- 如果某个场景的第二阶段调度对于给定的 $(y_1,y_2)$ 是不可行的，推导出一个可行性割，以确保每个时间段有足够的启停容量：$C_1 y_1 + C_2 y_2 \\ge \\max\\{d_{s,t} - G^{\\max}_t, 0\\}$，对于该场景中的所有 $t$。\n\n实现一个迭代的Benders算法：\n- 初始化，不带任何最优性割和可行性割。\n- 在每次迭代中，通过枚举 $(y_1,y_2)$ 的所有二元组合来求解主问题，并选择满足累积可行性割的组合中，使当前主目标最小的那个组合。其中，$\\theta_s$ 被替换为在 $(y_1,y_2)$ 处评估的场景 $s$ 现有最优性割的最大值，如果场景 $s$ 尚无最优性割，则为 $0$。\n- 给定选定的 $(y_1,y_2)$，求解每个场景的第二阶段调度线性规划。如果可行，则添加其最优性割；如果不可行，则为所有未满足缺口的周期添加可行性割。维护并更新全局下界和上界，直到收敛或所有可行的 $(y_1,y_2)$ 组合都已处理完毕。\n\n物理和数值单位：\n- 所有功率和能量量纲必须以 $\\text{kW}$ 和 $\\text{kWh}$ 处理。所有成本必须以美元 $\\$$ 为单位。以美元表示每个测试用例的最终期望总成本，四舍五入到两位小数。\n\n角度单位不适用。不得使用百分比。\n\n测试套件和参数规范：\n为以下三个测试用例实现上述算法。每个测试用例是一个参数元组 $(T, C_1, C_2, c_1, c_2, c_G, F_1, F_2, \\{G^{\\max}_t\\}_{t=1}^T, \\mathcal{S}, \\{p_s\\}_{s \\in \\mathcal{S}})$，其中场景数据包括 $\\{D_{s,t}\\}_{t=1}^T$ 和 $\\{\\text{PV}_{s,t}\\}_{t=1}^T$。\n\n- 测试用例1（理想情况；电网和光伏无需发电机启停即可满足）：\n  - $T = 3$, $C_1 = 50$, $C_2 = 40$, $c_1 = 0.18$, $c_2 = 0.22$, $c_G = 0.25$, $F_1 = 100$, $F_2 = 80$。\n  - $G^{\\max} = [80, 80, 80]$。\n  - 场景 $\\mathcal{S} = \\{A, B\\}$，概率为 $p_A = 0.5$, $p_B = 0.5$。\n  - 场景 $A$: $D_{A} = [70, 60, 50]$, $\\text{PV}_{A} = [30, 40, 50]$。\n  - 场景 $B$: $D_{B} = [60, 55, 65]$, $\\text{PV}_{B} = [35, 25, 30]$。\n\n- 测试用例2（电网受限；至少必须启停一台发电机）：\n  - $T = 3$, $C_1 = 50$, $C_2 = 40$, $c_1 = 0.18$, $c_2 = 0.22$, $c_G = 0.25$, $F_1 = 100$, $F_2 = 80$。\n  - $G^{\\max} = [20, 20, 20]$。\n  - 场景 $\\mathcal{S} = \\{A, B\\}$，概率为 $p_A = 0.5$, $p_B = 0.5$。\n  - 场景 $A$: $D_{A} = [70, 60, 50]$, $\\text{PV}_{A} = [30, 40, 50]$。\n  - 场景 $B$: $D_{B} = [60, 55, 65]$, $\\text{PV}_{B} = [35, 25, 30]$。\n\n- 测试用例3（边界情况；需要两台发电机才能满足所有时段）：\n  - $T = 3$, $C_1 = 50$, $C_2 = 40$, $c_1 = 0.18$, $c_2 = 0.22$, $c_G = 0.25$, $F_1 = 100$, $F_2 = 80$。\n  - $G^{\\max} = [0, 0, 0]$。\n  - 场景 $\\mathcal{S} = \\{C\\}$，概率为 $p_C = 1.0$。\n  - 场景 $C$: $D_{C} = [100, 100, 100]$, $\\text{PV}_{C} = [10, 10, 10]$。\n\n最终输出格式：\n您的程序应生成一行输出，其中包含三个测试用例各自的期望最优总成本，格式为逗号分隔的列表，并用方括号括起来（例如，“[$x_1$,$x_2$,$x_3$]”），其中每个 $x_i$ 是一个四舍五入到两位小数的浮点数（单位为$）。",
            "solution": "用户指定了一个用于微电网调度的两阶段随机优化问题，该问题将使用Benders分解法求解。该问题定义明确，在电力系统工程和运筹学方面有科学依据，并且为指定的测试用例提供了所有必要的参数。因此，该问题被认定为有效。\n\n求解方法涉及将问题分解为一个用于第一阶段发电机启停决策的主问题和一组用于在每个不确定场景下进行经济调度的第二阶段子问题。主问题通过添加从子问题推导出的最优性割和可行性割进行迭代优化。\n\n### 数学公式\n\n总体目标是最小化第一阶段固定成本与第二阶段期望运营成本之和。\n\n**第一阶段（主）问题**\n主问题决定二元发电机启停变量 $y_1, y_2 \\in \\{0, 1\\}$。其目标函数包括固定启停成本和对期望第二阶段成本的近似，后者由每个场景 $s \\in \\mathcal{S}$ 的递归变量 $\\theta_s \\ge 0$ 表示。\n\n$$\n\\min_{y_1, y_2, \\theta_s} \\quad F_1 y_1 + F_2 y_2 + \\sum_{s \\in \\mathcal{S}} p_s \\theta_s\n$$\n约束条件：\n$$\ny_1, y_2 \\in \\{0, 1\\}\n$$\n$$\n\\theta_s \\ge 0 \\quad \\forall s \\in \\mathcal{S}\n$$\n以及一组迭代添加的Benders割（最优性割和可行性割）。\n\n**第二阶段（子）问题**\n对于给定的第一阶段决策 $(\\bar{y}_1, \\bar{y}_2)$ 和特定场景 $s$，第二阶段子问题是一个最小化运营成本的线性规划（LP）。完整的子问题按时间段 $t \\in \\{1, \\dots, T\\}$ 可分。对于每个时间段，我们求解：\n\n$$\nQ_{s,t}(\\bar{y}_1, \\bar{y}_2) = \\min_{g_{1,t}, g_{2,t}, g^{\\text{grid}}_{t}} \\quad c_1 g_{1,t} + c_2 g_{2,t} + c_G g^{\\text{grid}}_{t}\n$$\n约束条件：\n\\begin{align*}\n(S1_t):  \\quad g_{1,t} + g_{2,t} + g^{\\text{grid}}_{t} \\ge d_{s,t}  \\quad [\\lambda_{s,t} \\ge 0] \\\\\n(S2_{1,t}):  \\quad g_{1,t} \\le C_1 \\bar{y}_1  \\quad [\\mu_{1,s,t} \\ge 0] \\\\\n(S3_{2,t}):  \\quad g_{2,t} \\le C_2 \\bar{y}_2  \\quad [\\mu_{2,s,t} \\ge 0] \\\\\n(S4_t):  \\quad g^{\\text{grid}}_{t} \\le G^{\\max}_t  \\quad [\\nu_{s,t} \\ge 0] \\\\\n \\quad g_{1,t}, g_{2,t}, g^{\\text{grid}}_{t} \\ge 0\n\\end{align*}\n场景 $s$ 的总第二阶段成本为 $Q_s(\\bar{y}_1, \\bar{y}_2) = \\sum_{t=1}^T Q_{s,t}(\\bar{y}_1, \\bar{y}_2)$。每个约束的对偶变量在方括号中表示。\n\n### Benders割的推导\n\n**1. 可行性割**\n对于给定的时间段 $t$ 和场景 $s$，如果总可用发电容量小于净缺口 $d_{s,t} = D_{s,t} - \\text{PV}_{s,t}$，则子问题是不可行的。最大可用供应量为 $C_1 \\bar{y}_1 + C_2 \\bar{y}_2 + G^{\\max}_t$。可行性要求：\n$$\nC_1 \\bar{y}_1 + C_2 \\bar{y}_2 + G^{\\max}_t \\ge d_{s,t}\n$$\n如果对于特定的 $(\\bar{y}_1, \\bar{y}_2)$ 违反了此条件，则生成一个可行性割并添加到主问题中，以在未来的迭代中排除此类不可行的启停决策。该割是为通用的 $y_1, y_2$ 制定的：\n$$\nC_1 y_1 + C_2 y_2 \\ge d_{s,t} - G^{\\max}_t\n$$\n由于左侧是非负的，仅当右侧为正时此割才有意义。因此，对于场景 $s$ 下子问题不可行的每个周期 $t'$，我们添加以下割：\n$$\nC_1 y_1 + C_2 y_2 \\ge \\max\\{0, d_{s,t'} - G^{\\max}_{t'}\\}\n$$\n\n**2. 最优性割**\n如果对于给定的 $(\\bar{y}_1, \\bar{y}_2)$，场景 $s$ 的子问题是可行的，则从其对偶问题生成一个最优性割。每周期子问题的对偶是：\n$$\n\\max_{\\lambda, \\mu, \\nu} \\quad d_{s,t} \\lambda_{s,t} - C_1 \\bar{y}_1 \\mu_{1,s,t} - C_2 \\bar{y}_2 \\mu_{2,s,t} - G^{\\max}_t \\nu_{s,t}\n$$\n约束条件：\n\\begin{align*}\n\\lambda_{s,t} - \\mu_{1,s,t} \\le c_1 \\\\\n\\lambda_{s,t} - \\mu_{2,s,t} \\le c_2 \\\\\n\\lambda_{s,t} - \\nu_{s,t} \\le c_G \\\\\n\\lambda_{s,t}, \\mu_{1,s,t}, \\mu_{2,s,t}, \\nu_{s,t} \\ge 0\n\\end{align*}\n根据强对偶性，原子问题的最优目标值 $Q_{s,t}(\\bar{y}_1, \\bar{y}_2)$ 等于此对偶问题的最优值。设 $(\\bar{\\lambda}_{s,t}, \\bar{\\mu}_{1,s,t}, \\bar{\\mu}_{2,s,t}, \\bar{\\nu}_{s,t})$ 为最优对偶变量。值 $Q_s(\\bar{y}_1, \\bar{y}_2) = \\sum_t Q_{s,t}(\\bar{y}_1, \\bar{y}_2)$ 为 $\\theta_s$ 提供了一个值，该值作为任何可行启停的下界。最优性割是递归函数 $Q_s(y_1, y_2)$ 的一个线性下近似。其形式为：\n$$\n\\theta_s \\ge Q_s(\\bar{y}_1, \\bar{y}_2) + \\nabla Q_s(\\bar{y}_1, \\bar{y}_2)^T \\begin{pmatrix} y_1 - \\bar{y}_1 \\\\ y_2 - \\bar{y}_2 \\end{pmatrix}\n$$\n梯度分量为 $\\frac{\\partial Q_s}{\\partial y_i} = - \\sum_{t=1}^T C_i \\bar{\\mu}_{i,s,t}$。这导致割的形式为 $\\theta_s \\ge \\alpha_s + \\beta_{1,s} y_1 + \\beta_{2,s} y_2$，其中：\n$$\n\\alpha_s = \\sum_{t=1}^T (d_{s,t} \\bar{\\lambda}_{s,t} - G^{\\max}_t \\bar{\\nu}_{s,t})\n$$\n$$\n\\beta_{1,s} = - \\sum_{t=1}^T C_1 \\bar{\\mu}_{1,s,t}\n$$\n$$\n\\beta_{2,s} = - \\sum_{t=1}^T C_2 \\bar{\\mu}_{2,s,t}\n$$\n此割被添加到主问题中，以改善其对第二阶段成本函数的近似。\n\n### Benders分解算法\n\n迭代算法按以下步骤进行：\n\n1.  **初始化**: 初始化全局下界 $LB = -\\infty$ 和上界 $UB = +\\infty$。最优性割和可行性割的集合均为空。\n2.  **主问题求解**: 在每次迭代中，求解主问题。鉴于第一阶段决策的规模很小（$2^2=4$种组合），这可以通过枚举所有 $(y_1, y_2) \\in \\{(0,0), (0,1), (1,0), (1,1)\\}$ 对来完成。对于每一对：\n    *   检查它是否满足所有当前的可行性割。\n    *   如果可行，计算其主问题目标值 $F_1 y_1 + F_2 y_2 + \\sum_s p_s \\theta_s$，其中每个 $\\theta_s$ 是在该 $(y_1, y_2)$ 处评估该场景所有现有最优性割返回的最大值。\n    *   选择具有最小主目标值的对 $(y_1^{(k)}, y_2^{(k)})$。此目标值 $Z_{MP}^{(k)}$ 更新全局下界：$LB = \\max(LB, Z_{MP}^{(k)})$。\n3.  **子问题求解**: 对于所选的 $(y_1^{(k)}, y_2^{(k)})$，求解每个场景 $s \\in \\mathcal{S}$ 的第二阶段LP。\n    *   如果任何场景 $s$ 的子问题不可行（对于任何时段 $t$），则将相应的可行性割添加到主问题中。此启停决策的真实成本为无穷大。\n    *   如果所有场景的子问题都可行，则计算总真实成本：$Z^{(k)} = F_1 y_1^{(k)} + F_2 y_2^{(k)} + \\sum_s p_s Q_s(y_1^{(k)}, y_2^{(k)})$。此值更新全局上界：$UB = \\min(UB, Z^{(k)})$。对于每个场景 $s$，使用其子问题解的对偶变量生成一个最优性割，并将其添加到主问题中。\n4.  **收敛检查**: 如果上下界之间的差距小于一个很小的容差（$UB - LB \\le \\epsilon$），或者所有四种可能的启停组合都已通过子问题评估，则算法终止。最优解是产生最佳上界的启停决策，最优值为 $UB$。\n\n此过程被实现以解决三个指定的测试用例。",
            "answer": "```python\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and orchestrate the solution process.\n    \"\"\"\n    # Test Case 1: Happy path; grid and PV suffice\n    case1 = {\n        \"T\": 3, \"C1\": 50, \"C2\": 40, \"c1\": 0.18, \"c2\": 0.22, \"cG\": 0.25,\n        \"F1\": 100, \"F2\": 80, \"G_max\": np.array([80, 80, 80]),\n        \"scenarios\": [\n            {\n                \"id\": \"A\", \"prob\": 0.5,\n                \"D\": np.array([70, 60, 50]), \"PV\": np.array([30, 40, 50])\n            },\n            {\n                \"id\": \"B\", \"prob\": 0.5,\n                \"D\": np.array([60, 55, 65]), \"PV\": np.array([35, 25, 30])\n            }\n        ]\n    }\n\n    # Test Case 2: Grid-limited; at least one generator needed\n    case2 = {\n        \"T\": 3, \"C1\": 50, \"C2\": 40, \"c1\": 0.18, \"c2\": 0.22, \"cG\": 0.25,\n        \"F1\": 100, \"F2\": 80, \"G_max\": np.array([20, 20, 20]),\n        \"scenarios\": [\n            {\n                \"id\": \"A\", \"prob\": 0.5,\n                \"D\": np.array([70, 60, 50]), \"PV\": np.array([30, 40, 50])\n            },\n            {\n                \"id\": \"B\", \"prob\": 0.5,\n                \"D\": np.array([60, 55, 65]), \"PV\": np.array([35, 25, 30])\n            }\n        ]\n    }\n\n    # Test Case 3: Boundary; both generators required\n    case3 = {\n        \"T\": 3, \"C1\": 50, \"C2\": 40, \"c1\": 0.18, \"c2\": 0.22, \"cG\": 0.25,\n        \"F1\": 100, \"F2\": 80, \"G_max\": np.array([0, 0, 0]),\n        \"scenarios\": [\n            {\n                \"id\": \"C\", \"prob\": 1.0,\n                \"D\": np.array([100, 100, 100]), \"PV\": np.array([10, 10, 10])\n            }\n        ]\n    }\n\n    test_cases = [case1, case2, case3]\n    results = []\n\n    for case in test_cases:\n        cost = run_benders_for_case(case)\n        results.append(f\"{cost:.2f}\")\n\n    print(f\"[{','.join(results)}]\")\n\ndef solve_subproblem(s_data, y, params, s_idx):\n    \"\"\"\n    Solves the second-stage LP for a given scenario and commitment decision.\n    \"\"\"\n    y1, y2 = y\n    T, C1, C2, c1, c2, cG = params[\"T\"], params[\"C1\"], params[\"C2\"], params[\"c1\"], params[\"c2\"], params[\"cG\"]\n    G_max = params[\"G_max\"]\n    \n    total_cost_s = 0.0\n    alpha_s, beta1_s, beta2_s = 0.0, 0.0, 0.0\n    \n    infeasible_periods = []\n    d_s = s_data['D'] - s_data['PV']\n\n    for t in range(T):\n        net_deficit_t = max(0, d_s[t])\n\n        c = np.array([c1, c2, cG])\n        A_ub = np.array([\n            [-1, -1, -1],  # g1+g2+g_grid >= d_st\n            [1, 0, 0],     # g1 = C1*y1\n            [0, 1, 0],     # g2 = C2*y2\n            [0, 0, 1]      # g_grid = G_max_t\n        ])\n        b_ub = np.array([-net_deficit_t, C1 * y1, C2 * y2, G_max[t]])\n        \n        bounds = [(0, None), (0, None), (0, None)]\n        \n        res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n\n        if res.status == 2: # Infeasible\n            infeasible_periods.append(t)\n        elif not res.success: # other errors\n            # For this problem, non-success other than infeasibility is unexpected\n            # but treat as infeasible to be safe.\n            infeasible_periods.append(t)\n        else:\n            total_cost_s += res.fun\n            \n            duals = res.ineqlin.marginals\n            lambda_st, mu1_st, mu2_st, nu_st = duals[0], duals[1], duals[2], duals[3]\n            \n            alpha_s += lambda_st * net_deficit_t - nu_st * G_max[t]\n            beta1_s -= mu1_st * C1\n            beta2_s -= mu2_st * C2\n\n    if infeasible_periods:\n        cuts = []\n        for t_inf in infeasible_periods:\n            rhs = max(0, d_s[t_inf] - G_max[t_inf])\n            cut = {'coeffs': [C1, C2], 'rhs': rhs}\n            cuts.append(cut)\n        return {'status': 'infeasible', 'cuts': cuts}\n    \n    cut = {'type': 'optimality', 's_idx': s_idx, 'params': (alpha_s, beta1_s, beta2_s)}\n    return {'status': 'feasible', 'cost': total_cost_s, 'cut': cut}\n\ndef run_benders_for_case(params):\n    \"\"\"\n    Executes the Benders decomposition algorithm for a single test case.\n    \"\"\"\n    y_options = [(0, 0), (0, 1), (1, 0), (1, 1)]\n    optimality_cuts = {i: [] for i, _ in enumerate(params[\"scenarios\"])}\n    feasibility_cuts = []\n    \n    lower_bound = -np.inf\n    upper_bound = np.inf\n    \n    y_processed = set()\n    \n    max_iter = len(y_options) + 2  # Sufficient iterations for this small problem\n\n    for _ in range(max_iter):\n        \n        # 1. Solve Master Problem by enumeration\n        master_results = {}\n        for y_candidate in y_options:\n            y1, y2 = y_candidate\n\n            # Check feasibility cuts\n            is_feasible = all(c['coeffs'][0] * y1 + c['coeffs'][1] * y2 >= c['rhs'] for c in feasibility_cuts)\n            if not is_feasible:\n                continue\n\n            # Calculate objective for this y\n            first_stage_cost = params['F1'] * y1 + params['F2'] * y2\n            expected_recourse_cost = 0.0\n            for s_idx, s_data in enumerate(params[\"scenarios\"]):\n                theta_s = 0.0\n                for o_cut_params in optimality_cuts[s_idx]:\n                    alpha, beta1, beta2 = o_cut_params\n                    cut_val = alpha + beta1 * y1 + beta2 * y2\n                    theta_s = max(theta_s, cut_val)\n                expected_recourse_cost += s_data['prob'] * theta_s\n            \n            total_master_cost = first_stage_cost + expected_recourse_cost\n            master_results[y_candidate] = total_master_cost\n            \n        if not master_results:\n            break # All combinations are infeasible\n        \n        current_y = min(master_results, key=master_results.get)\n        current_lb = master_results[current_y]\n        lower_bound = max(lower_bound, current_lb)\n        \n        y_processed.add(current_y)\n        \n        # 2. Solve Subproblems for current_y\n        y1_k, y2_k = current_y\n        total_second_stage_real_cost = 0.0\n        all_subproblems_feasible = True\n        new_feasibility_cuts = []\n        \n        for s_idx, s_data in enumerate(params[\"scenarios\"]):\n            sub_result = solve_subproblem(s_data, current_y, params, s_idx)\n            \n            if sub_result['status'] == 'infeasible':\n                all_subproblems_feasible = False\n                new_feasibility_cuts.extend(sub_result['cuts'])\n                break\n            else:\n                total_second_stage_real_cost += s_data['prob'] * sub_result['cost']\n                optimality_cuts[s_idx].append(sub_result['cut']['params'])\n\n        if all_subproblems_feasible:\n            current_ub = (params['F1'] * y1_k + params['F2'] * y2_k) + total_second_stage_real_cost\n            upper_bound = min(upper_bound, current_ub)\n        else:\n             for f_cut in new_feasibility_cuts:\n                if not any(np.array_equal(c['coeffs'], f_cut['coeffs']) and c['rhs'] == f_cut['rhs'] for c in feasibility_cuts):\n                    feasibility_cuts.append(f_cut)\n\n        # 3. Check Convergence\n        if upper_bound - lower_bound = 1e-6:\n            break\n        if len(y_processed) == len(y_options):\n            break\n\n    return upper_bound if upper_bound != np.inf else 0.0\n\nsolve()\n```"
        }
    ]
}