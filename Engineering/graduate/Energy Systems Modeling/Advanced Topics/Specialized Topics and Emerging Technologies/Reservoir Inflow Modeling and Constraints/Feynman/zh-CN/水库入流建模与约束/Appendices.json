{
    "hands_on_practices": [
        {
            "introduction": "水库管理始于对入库水量的理解与量化。本练习将基础的水文过程（如降雨-径流）与水库的整体水量平衡直接联系起来。通过应用质量守恒定律和单位线法，你将从第一性原理出发，推导出在特定降雨事件下水库入流的解析解，并确定为满足蓄水目标所需的恒定下泄流量。这项练习旨在培养从基本原理推导解析解的能力，为后续更复杂的数值模型学习打下坚实的基础。",
            "id": "4118220",
            "problem": "一个单水库水电系统接收来自上游集水区的水文入流。该入流通过质量守恒和线性降雨-径流表示法从第一性原理建模。水库蓄水量的基本质量平衡为 $ \\frac{dS(t)}{dt} = I(t) - R(t) - E(t) $，其中 $ S(t) $ 是蓄水量，$ I(t) $ 是入流，$ R(t) $ 是下泄量，$ E(t) $ 代表蒸发损失。水文入流定义为有效降水与单位过程线（UH）卷积产生的径流响应。假设以下科学上一致的规范和常数：\n\n- 集水区面积 $ A_c = 1.2 \\times 10^{9} \\,\\text{m}^{2} $，径流系数 $ C = 0.6 $。\n- 有效降水强度 $ p(t) = r_{0} \\exp\\!\\left(-\\frac{t}{\\theta}\\right) $（对于 $ t \\ge 0 $），其中 $ r_{0} = 1.5 \\times 10^{-5} \\,\\text{m s}^{-1} $ 和 $ \\theta = 7.2 \\times 10^{3} \\,\\text{s} $。\n- 单位过程线（UH）$ u(t) = \\frac{1}{\\tau} \\exp\\!\\left(-\\frac{t}{\\tau}\\right) $（对于 $ t \\ge 0 $），其中 $ \\tau = 7.2 \\times 10^{4} \\,\\text{s} $。\n- 水库表面积在规划期内近似为常数 $ A_{r} = 3.0 \\times 10^{7} \\,\\text{m}^{2} $。蒸发率 $ e = 6.0 \\times 10^{-3} \\,\\text{m day}^{-1} $，在规划期内假设为常数。\n- 规划期为 $ T = 1.728 \\times 10^{5} \\,\\text{s} $，从 $ t = 0 $ 到 $ t = T $。\n- 下泄策略为恒定下泄量 $ R(t) = R_{0} $，受运行约束：最小生态流量 $ R_{\\min} = 10 \\,\\text{m}^{3} \\text{ s}^{-1} $ 和最大涡轮机流量 $ R_{\\max} = 500 \\,\\text{m}^{3} \\text{ s}^{-1} $。\n- 初始蓄水量 $ S(0) = 2.50 \\times 10^{8} \\,\\text{m}^{3} $ 和目标期末蓄水量 $ S(T) = 2.65 \\times 10^{8} \\,\\text{m}^{3} $。\n\n使用质量守恒和水文入流定义 $ I(t) = C A_{c} \\int_{0}^{t} p(\\xi)\\, u(t-\\xi)\\, d\\xi $，推导 $ \\int_{0}^{T} I(t)\\, dt $ 的闭式表达式，并计算恒定下泄量 $ R_{0} $，使其在指定的规划期内，考虑蒸发损失 $ E(t) = e_{s} A_{r} $（其中 $ e_{s} $ 是以 $ \\text{m s}^{-1} $ 为单位的蒸发率）的情况下，恰好达到目标期末蓄水量 $ S(T) $。验证计算出的 $ R_{0} $ 符合给定的运行约束。将您的最终数值答案四舍五入到四位有效数字。以立方米每秒（$\\text{m}^3\\,\\text{s}^{-1}$）表示最终下泄量。",
            "solution": "该问题的求解过程是在指定的规划期内对水库应用质量守恒原理。控制方程是质量平衡的积分形式。\n\n水库蓄水量$S(t)$的基本质量平衡由下式给出：\n$$\n\\frac{dS(t)}{dt} = I(t) - R(t) - E(t)\n$$\n其中 $I(t)$ 是入流，$R(t)$ 是下泄量，$E(t)$ 是蒸发损失。为了找到在从 $t=0$ 到 $t=T$ 的规划期内总水量之间的关系，我们对该方程进行时间积分：\n$$\n\\int_{0}^{T} \\frac{dS(t)}{dt} dt = \\int_{0}^{T} I(t) dt - \\int_{0}^{T} R(t) dt - \\int_{0}^{T} E(t) dt\n$$\n左侧计算结果为蓄水量的变化量，$S(T) - S(0)$。令 $V_I = \\int_{0}^{T} I(t) dt$ 为总入流水量，$V_R = \\int_{0}^{T} R(t) dt$ 为总下泄水量，$V_E = \\int_{0}^{T} E(t) dt$ 为总蒸发水量。积分后的质量平衡方程为：\n$$\nS(T) - S(0) = V_I - V_R - V_E\n$$\n我们的目标是求解恒定下泄量 $R_0$。此方程中的每一项都必须确定。\n\n总蓄水量变化由初始和期末条件给出：\n$$\nS(T) - S(0) = 2.65 \\times 10^{8} \\,\\text{m}^{3} - 2.50 \\times 10^{8} \\,\\text{m}^{3} = 1.5 \\times 10^{7} \\,\\text{m}^{3}\n$$\n下泄策略为恒定下泄量 $R(t) = R_0$。在规划期 $T$ 内的总下泄水量为：\n$$\nV_R = \\int_{0}^{T} R_0 dt = R_0 T\n$$\n蒸发损失率为 $E(t) = e_s A_r$，其中 $A_r$ 是恒定的水库表面积，$e_s$ 是以 $\\text{m s}^{-1}$ 为单位的恒定蒸发率。首先，我们将给定的蒸发率 $e = 6.0 \\times 10^{-3} \\,\\text{m day}^{-1}$ 转换为国际单位制（SI）单位。已知 $1$ 天 = $86400$ 秒：\n$$\ne_s = \\frac{6.0 \\times 10^{-3} \\,\\text{m}}{1 \\,\\text{day}} \\times \\frac{1 \\,\\text{day}}{86400 \\,\\text{s}} = \\frac{6.0 \\times 10^{-3}}{8.64 \\times 10^4} \\,\\text{m s}^{-1}\n$$\n总蒸发水量为：\n$$\nV_E = \\int_{0}^{T} e_s A_r dt = e_s A_r T = \\left(\\frac{6.0 \\times 10^{-3}}{8.64 \\times 10^4}\\right) (3.0 \\times 10^7) (1.728 \\times 10^5) \\,\\text{m}^3\n$$\n注意到 $(1.728 \\times 10^5) / (8.64 \\times 10^4) = 2$，我们可以简化为：\n$$\nV_E = (6.0 \\times 10^{-3})(3.0 \\times 10^7)(2) = 36 \\times 10^4 \\,\\text{m}^3 = 3.6 \\times 10^5 \\,\\text{m}^3\n$$\n最复杂的项是总入流水量 $V_I$。入流率 $I(t)$ 由一个卷积分定义：\n$$\nI(t) = C A_{c} \\int_{0}^{t} p(\\xi)\\, u(t-\\xi)\\, d\\xi\n$$\n代入给定的降水函数 $p(t) = r_0 \\exp(-t/\\theta)$ 和单位过程线 $u(t) = \\frac{1}{\\tau} \\exp(-t/\\tau)$：\n$$\nI(t) = C A_c \\int_{0}^{t} r_0 \\exp(-\\xi/\\theta) \\, \\frac{1}{\\tau} \\exp(-(t-\\xi)/\\tau) \\, d\\xi\n$$\n$$\nI(t) = \\frac{C A_c r_0}{\\tau} \\exp(-t/\\tau) \\int_{0}^{t} \\exp\\left(-\\frac{\\xi}{\\theta} + \\frac{\\xi}{\\tau}\\right) d\\xi = \\frac{C A_c r_0}{\\tau} \\exp(-t/\\tau) \\int_{0}^{t} \\exp\\left(\\xi \\left(\\frac{1}{\\tau} - \\frac{1}{\\theta}\\right)\\right) d\\xi\n$$\n假设 $\\tau \\neq \\theta$，积分计算结果为：\n$$\n\\int_{0}^{t} \\exp\\left(\\xi \\frac{\\theta-\\tau}{\\tau\\theta}\\right) d\\xi = \\left[ \\frac{\\tau\\theta}{\\theta-\\tau} \\exp\\left(\\xi \\frac{\\theta-\\tau}{\\tau\\theta}\\right) \\right]_0^t = \\frac{\\tau\\theta}{\\theta-\\tau} \\left( \\exp\\left(t \\left(\\frac{1}{\\tau}-\\frac{1}{\\theta}\\right)\\right) - 1 \\right)\n$$\n将此结果代回 $I(t)$ 的表达式中：\n$$\nI(t) = \\frac{C A_c r_0}{\\tau} \\exp(-t/\\tau) \\frac{\\tau\\theta}{\\theta-\\tau} \\left( \\exp(t/\\tau) \\exp(-t/\\theta) - 1 \\right)\n$$\n$$\nI(t) = \\frac{C A_c r_0 \\theta}{\\theta-\\tau} \\left( \\exp(-t/\\theta) - \\exp(-t/\\tau) \\right)\n$$\n这就是入流率 $I(t)$ 的闭式表达式。为了求得总入流水量 $V_I$，我们将 $I(t)$ 从 $0$ 到 $T$ 积分：\n$$\nV_I = \\int_{0}^{T} I(t) dt = \\frac{C A_c r_0 \\theta}{\\theta-\\tau} \\int_{0}^{T} \\left( \\exp(-t/\\theta) - \\exp(-t/\\tau) \\right) dt\n$$\n$$\nV_I = \\frac{C A_c r_0 \\theta}{\\theta-\\tau} \\left[ [-\\theta \\exp(-t/\\theta)]_{0}^{T} - [-\\tau \\exp(-t/\\tau)]_{0}^{T} \\right]\n$$\n$$\nV_I = \\frac{C A_c r_0 \\theta}{\\theta-\\tau} \\left[ (-\\theta \\exp(-T/\\theta) + \\theta) - (-\\tau \\exp(-T/\\tau) + \\tau) \\right]\n$$\n这就得到了所需的总入流水量的闭式表达式：\n$$\nV_I = \\int_{0}^{T} I(t) dt = \\frac{C A_c r_0 \\theta}{\\theta-\\tau} \\left[ \\theta(1 - \\exp(-T/\\theta)) - \\tau(1 - \\exp(-T/\\tau)) \\right]\n$$\n现在，我们代入给定的数值：\n$C = 0.6$，$A_c = 1.2 \\times 10^9 \\,\\text{m}^2$，$r_0 = 1.5 \\times 10^{-5} \\,\\text{m s}^{-1}$，$\\theta = 7.2 \\times 10^3 \\,\\text{s}$，$\\tau = 7.2 \\times 10^4 \\,\\text{s}$，以及 $T = 1.728 \\times 10^5 \\,\\text{s}$。\n时间常数比为 $T/\\theta = (1.728 \\times 10^5)/(7.2 \\times 10^3) = 24$ 和 $T/\\tau = (1.728 \\times 10^5)/(7.2 \\times 10^4) = 2.4$。\n前置因子为：\n$$\n\\frac{C A_c r_0 \\theta}{\\theta-\\tau} = \\frac{(0.6)(1.2 \\times 10^9)(1.5 \\times 10^{-5})(7.2 \\times 10^3)}{7.2 \\times 10^3 - 7.2 \\times 10^4} = \\frac{7.776 \\times 10^7}{-6.48 \\times 10^4} = -1200 \\,\\text{m}^3\\text{s}^{-1}\n$$\n方括号中的项为：\n$$\n(7.2 \\times 10^3)(1 - \\exp(-24)) - (7.2 \\times 10^4)(1 - \\exp(-2.4)) \\,\\text{s}\n$$\n$\\exp(-24)$ 的值可以忽略不计。\n$$\n\\approx (7.2 \\times 10^3) - (7.2 \\times 10^4)(1 - \\exp(-2.4)) = 7200 - 72000(1 - 0.09071795...) = 7200 - 65468.307... = -58268.307... \\,\\text{s}\n$$\n因此，总入流水量为：\n$$\nV_I \\approx (-1200) \\times (-58268.307) = 69921968.9... \\,\\text{m}^3 \\approx 6.9922 \\times 10^7 \\,\\text{m}^3\n$$\n现在我们整理质量平衡方程以求解 $R_0$：\n$$\nS(T) - S(0) = V_I - R_0 T - V_E\n$$\n$$\nR_0 T = V_I - (S(T) - S(0)) - V_E\n$$\n$$\nR_0 = \\frac{V_I - (S(T) - S(0)) - V_E}{T}\n$$\n代入计算出的水量和规划期 $T$：\n$$\nR_0 = \\frac{69921968.9 - 1.5 \\times 10^7 - 3.6 \\times 10^5}{1.728 \\times 10^5}\n$$\n$$\nR_0 = \\frac{69921968.9 - 15000000 - 360000}{172800} = \\frac{54561968.9}{172800} \\approx 315.7521 \\,\\text{m}^3\\text{s}^{-1}\n$$\n四舍五入到四位有效数字，我们得到 $R_0 = 315.8 \\,\\text{m}^3\\text{s}^{-1}$。\n\n最后，我们必须验证这个下泄率满足运行约束：$R_{\\min} = 10 \\,\\text{m}^3\\text{s}^{-1}$ 和 $R_{\\max} = 500 \\,\\text{m}^3\\text{s}^{-1}$。\n计算值 $R_0 = 315.8 \\,\\text{m}^3\\text{s}^{-1}$ 确实在允许的最小和最大下泄量之间：\n$10 \\le 315.8 \\le 500$。\n因此结果是有效的。",
            "answer": "$$\\boxed{315.8}$$"
        },
        {
            "introduction": "现实世界的水库调度远不止于计算总水量平衡，它需要在众多约束条件下动态地管理水流。本练习将带领你从连续时间的解析世界过渡到实际运行模型中使用的离散时间框架。通过从零开始构建一个模拟器，你将深入理解诸如爬坡率、蓄水限制等运行规则如何被转化为代码逻辑，这对于任何能源系统建模者来说都是一项核心技能。",
            "id": "4118229",
            "problem": "构建一个程序，该程序在一个离散时间范围内强制执行物理上一致的水库质量平衡和状态更新约束。水库被表示为一个控制体，其蓄水量 $s(t)$ 以立方米为单位，入流速率 $I(t)$ 以立方米/秒为单位，下泄速率 $R(t)$ 以立方米/秒为单位，蒸发速率 $E(t)$ 以米/秒为单位。水库表面积被建模为一个与蓄水量相关的函数 $A(s)$，单位为平方米。程序必须从质量守恒推导出离散时间的状态更新，然后在每个时间步强制执行运行约束。\n\n从控制体的质量守恒开始：蓄水量的变化率等于净入流量减去净出流量和损失量。使用一阶显式时间离散化方法，在固定时间步长 $\\Delta t$ 上，从这个基本定律推导出离散时间更新 $s_{t+1}$，假设在每个区间内入流、下泄和蒸发是分段常数。将蒸发建模为穿过瞬时表面积 $A(s_t)$（平方米）的通量 $E_t$（米/秒），这产生了一个体积损失率 $E_t A(s_t)$（立方米/秒）。\n\n强制执行以下约束，所有约束均针对每个时间步 $t$ 表示：\n- 蓄水量边界：对于所有 $t$，满足 $S_{\\min} \\le s_t \\le S_{\\max}$。如果无约束更新将产生 $s_{t+1} > S_{\\max}$，多余的水必须被弃掉，使得 $s_{t+1} = S_{\\max}$。如果无约束更新将产生 $s_{t+1}  S_{\\min}$，必须削减下泄量以精确满足 $s_{t+1} = S_{\\min}$。\n- 最小生态下泄量：$\\underline{R} \\le R_t$。\n- 水轮机容量（最大下泄量）：$R_t \\le \\overline{R}$。\n- 爬坡率约束：$\\lvert R_t - R_{t-1} \\rvert \\le \\rho$，其中 $\\rho$ 是每个时间步下泄量的最大变化量。初始的前一时刻下泄量 $R_{-1}$ 已被指定。\n\n将表面积函数定义为 $A(s) = A_0 + \\alpha s$，其中 $A_0$ 是一个单位为平方米的正常量，$\\alpha$ 是一个单位为米⁻¹的非负常量。当为满足最小蓄水量而削减 $R_t$ 时，确保所选的 $R_t$ 是在保持 $s_{t+1} \\ge S_{\\min}$ 的同时，如果物理上可能，也满足最小生态下泄量的最大值；如果无法在不违反 $S_{\\min}$ 的情况下满足最小生态下泄量，则将 $R_t$ 设置为最大可行值，并报告未满足生态流量。\n\n单位和数值要求：\n- 所有蓄水量 $s_t$ 以立方米表示，所有入流量 $I_t$ 以立方米/秒表示，所有下泄量 $R_t$ 以立方米/秒表示，蒸发速率 $E_t$ 以米/秒表示，表面积 $A(s)$ 以平方米表示，时间步长 $\\Delta t$ 以秒表示。\n- 程序必须计算蓄水量序列 $\\{s_1, s_2, \\dots, s_T\\}$，结果为浮点数，单位为立方米。\n- 程序必须为每个测试用例计算三个布尔值：是否在每个时间步都满足了最小生态下泄量，是否在任何时间步发生了弃水，以及是否由于相对于期望下泄量的 $\\lvert R_t - R_{t-1} \\rvert > \\rho$ 而发生了任何爬坡削减。\n\n测试套件：\n使用长度为 $T = 4$ 的时域，并采用以下全局共享参数：\n- $S_{\\min} = 10{,}000{,}000$ 立方米，\n- $S_{\\max} = 100{,}000{,}000$ 立方米，\n- $A_0 = 3{,}000{,}000$ 平方米，\n- $\\alpha = 0.005$ 米⁻¹，\n- $\\Delta t = 86{,}400$ 秒，\n- $\\underline{R} = 50$ 立方米/秒，\n- $\\overline{R} = 400$ 立方米/秒，\n- $\\rho = 100$ 立方米/秒，\n- $R_{-1} = 50$ 立方米/秒，适用于所有用例，\n- 在每个用例中，对于所有 $t$， $E_t = 6 \\times 10^{-8}$ 米/秒。\n\n定义四个测试用例，每个用例由初始蓄水量 $s_0$、入流向量 $\\{I_0, I_1, I_2, I_3\\}$（单位：立方米/秒）和期望下泄向量 $\\{R^{\\mathrm{des}}_0, R^{\\mathrm{des}}_1, R^{\\mathrm{des}}_2, R^{\\mathrm{des}}_3\\}$（单位：立方米/秒）指定：\n- 用例 1（典型运行工况）：$s_0 = 50{,}000{,}000$，$\\{I_t\\} = \\{180, 160, 150, 140\\}$，$\\{R^{\\mathrm{des}}_t\\} = \\{150, 200, 180, 160\\}$。\n- 用例 2（高入流接近库容导致弃水）：$s_0 = 95{,}000{,}000$，$\\{I_t\\} = \\{500, 600, 800, 900\\}$，$\\{R^{\\mathrm{des}}_t\\} = \\{200, 200, 200, 200\\}$。\n- 用例 3（低入流有触及最小蓄水量的风险，生态流量可能无法满足）：$s_0 = 12{,}000{,}000$，$\\{I_t\\} = \\{40, 30, 20, 10\\}$，$\\{R^{\\mathrm{des}}_t\\} = \\{60, 60, 60, 60\\}$。\n- 用例 4（剧烈的下泄量变化违反爬坡约束但其他方面可行）：$s_0 = 50{,}000{,}000$，$\\{I_t\\} = \\{200, 200, 200, 200\\}$，$\\{R^{\\mathrm{des}}_t\\} = \\{50, 350, 50, 350\\}$。\n\n对于每个测试用例，生成一个形式为 $[\\text{storage\\_sequence},\\ \\text{env\\_met},\\ \\text{spill\\_occurred},\\ \\text{ramp\\_clipped\\_occurred}]$ 的结果，其中 $\\text{storage\\_sequence}$ 是列表 $[s_1, s_2, s_3, s_4]$（单位：立方米），$\\text{env\\_met}$ 是一个布尔值，指示在强制执行所有约束后是否每一步都满足了 $\\underline{R}$，$\\text{spill\\_occurred}$ 是一个布尔值，指示是否发生了任何弃水，$\\text{ramp\\_clipped\\_occurred}$ 是一个布尔值，指示是否因爬坡约束而调整了任何期望下泄量。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，$[result1,result2,result3,result4]$），其中每个 $resulti$ 是为第 $i$ 个测试用例指定的上述列表。所有蓄水量值必须以立方米为单位。此问题不涉及角度。此问题不涉及百分比。",
            "solution": "用户提供的问题经评估有效。它在科学上基于质量守恒原理，在数学上是适定的，具有一套完整的参数和约束，并以客观、正式的语言表述。该问题要求开发一个水库的离散时间仿真模型，这是水资源和能源系统工程中的一项标准任务。\n\n解决方案首先推导控制离散时间方程，然后开发一个分步算法来强制执行指定的运行约束。\n\n控制水库的基本原理是质量守恒。对于一个控制体，蓄水量 $s(t)$ 的变化率等于体积入流率减去体积出流率。入流由 $I(t)$ 给出，出流包括受控下泄量 $R(t)$ 和自然蒸发。\n\n体积蒸发损失率是蒸发速率 $E(t)$（单位：长度/时间，米/秒）与水库表面积 $A(s(t))$（单位：面积，米²）的乘积。表面积被给出为蓄水量的线性函数：\n$$ A(s) = A_0 + \\alpha s $$\n其中 $A_0$ 是基础面积，$\\alpha$ 决定了面积随蓄水量的增加程度。\n\n质量平衡的连续时间微分方程是：\n$$ \\frac{ds(t)}{dt} = I(t) - R(t) - E(t) A(s(t)) $$\n\n为了数值求解此方程，我们使用一阶显式（前向欧拉）时间离散化方法，在固定时间步长 $\\Delta t$ 上进行。我们假设速率 $I_t$、$R_t$ 和 $E_t$ 在区间 $[t, t+\\Delta t]$ 上是分段常数。导数近似为：\n$$ \\frac{ds(t)}{dt} \\approx \\frac{s_{t+1} - s_t}{\\Delta t} $$\n将此代入质量平衡方程，并在时间 $t$ 处计算右侧，得到：\n$$ \\frac{s_{t+1} - s_t}{\\Delta t} = I_t - R_t - E_t A(s_t) $$\n重新整理以求解下一时间步的蓄水量 $s_{t+1}$，我们得到离散时间状态更新方程：\n$$ s_{t+1} = s_t + \\left( I_t - R_t - E_t (A_0 + \\alpha s_t) \\right) \\Delta t $$\n\n问题的核心是在每个时间步确定实际下泄量 $R_t$，同时考虑期望下泄量 $R_t^{\\mathrm{des}}$以及一系列物理和运行约束。对于从 $0$ 到 $T-1$ 的每个时间步 $t$，在给定状态 $s_t$ 和前一时刻下泄量 $R_{t-1}$ 的情况下，执行以下算法。\n\n1.  **确定候选下泄量**：下泄量的初始目标是期望下泄量 $R_t^{\\mathrm{des}}$。该目标会按顺序进行调整以满足运行约束。\n    a.  **爬坡率约束**：下泄量不能变化太快。变化量 $|R_t - R_{t-1}|$ 不能超过爬坡率限制 $\\rho$。这为 $R_t$ 定义了一个可行范围：$[R_{t-1} - \\rho, R_{t-1} + \\rho]$。期望下泄量被裁剪到此范围内。如果发生裁剪，则将 `ramp_clipped_occurred` 标志设置为 true。\n        $$ R_t' = \\max(R_{t-1} - \\rho, \\min(R_{t-1} + \\rho, R_t^{\\mathrm{des}})) $$\n    b.  **水轮机和生态约束**：下泄量必须在水轮机容量 $\\overline{R}$ 之内，并且必须满足最小生态流量 $\\underline{R}$。这定义了第二个可行范围 $[\\underline{R}, \\overline{R}]$。然后将受爬坡约束的下泄量 $R_t'$ 裁剪到此范围内，以产生最终的候选下泄量 $R_t^{\\text{cand}}$。\n        $$ R_t^{\\text{cand}} = \\max(\\underline{R}, \\min(\\overline{R}, R_t')) $$\n\n2.  **计算暂定下一蓄水量**：使用候选下泄量 $R_t^{\\text{cand}}$，我们使用状态更新方程计算下一时间步的暂定蓄水量 $s_{t+1}^{\\text{tentative}}$。\n    $$ s_{t+1}^{\\text{tentative}} = s_t + \\left( I_t - R_t^{\\text{cand}} - E_t (A_0 + \\alpha s_t) \\right) \\Delta t $$\n\n3.  **强制执行蓄水量边界**：将暂定蓄水量与绝对最小和最大蓄水量限制 $S_{\\min}$ 和 $S_{\\max}$ 进行比较。根据此检查确定 $s_{t+1}$ 和 $R_t$ 的最终值。\n\n    a.  **弃水条件**：如果 $s_{t+1}^{\\text{tentative}} > S_{\\max}$，则水库溢出。最终蓄水量被限制在最大库容，即 $s_{t+1} = S_{\\max}$。多余的水被弃掉。通过水轮机的受控下泄量保持为候选下泄量，$R_t = R_t^{\\text{cand}}$。将 `spill_occurred` 标志设置为 true。\n\n    b.  **削减条件**：如果 $s_{t+1}^{\\text{tentative}}  S_{\\min}$，则候选下泄量过高，将导致水库水位降至最低水平以下。必须削减下泄量。问题规定应调整下泄量以精确满足 $s_{t+1} = S_{\\min}$。我们通过在状态更新方程中设置 $s_{t+1} = S_{\\min}$ 并求解 $R_t$ 来找到所需的下泄量 $R_t^{\\text{req}}$：\n        $$ S_{\\min} = s_t + \\left( I_t - R_t^{\\text{req}} - E_t (A_0 + \\alpha s_t) \\right) \\Delta t $$\n        $$ R_t^{\\text{req}} = I_t - E_t (A_0 + \\alpha s_t) - \\frac{S_{\\min} - s_t}{\\Delta t} $$\n        这个值 $R_t^{\\text{req}}$ 是不违反最小蓄水量约束的最大可能下泄量。这个物理限制优先于运行目标。因此，最终下泄量设置为此值：$R_t = R_t^{\\text{req}}$。最终蓄水量为 $s_{t+1} = S_{\\min}$。在确定此必要下泄量后，我们检查它是否满足最小生态流量：如果 $R_t  \\underline{R}$，则将 `env_met` 标志设置为 false。\n\n    c.  **正常条件**：如果 $S_{\\min} \\le s_{t+1}^{\\text{tentative}} \\le S_{\\max}$，则候选下泄量是可行的。最终蓄水量为暂定蓄水量，$s_{t+1} = s_{t+1}^{\\text{tentative}}$，最终下泄量为候选下泄量，$R_t = R_t^{\\text{cand}}$。由于 $R_t^{\\text{cand}}$ 已被强制要求 $\\ge \\underline{R}$，因此在这种情况下满足了生态流量。\n\n在每个时间步之后，最终下泄量 $R_t$ 成为下一步的前一时刻下泄量，$R_t \\rightarrow R_{t-1}$，然后仿真继续进行。对每个测试用例的整个时间范围重复此过程。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the reservoir simulation problem for all specified test cases.\n    \"\"\"\n    # Globally shared parameters\n    S_min = 10_000_000.0  # m^3\n    S_max = 100_000_000.0 # m^3\n    A0 = 3_000_000.0      # m^2\n    alpha = 0.005        # m^-1\n    delta_t = 86400.0    # seconds (1 day)\n    R_env_min = 50.0     # m^3/s\n    R_turbine_max = 400.0# m^3/s\n    rho = 100.0          # m^3/s per time step\n    R_minus_1 = 50.0     # m^3/s\n    E = 6e-8             # m/s\n    T = 4                # Number of time steps\n\n    # Test cases\n    test_cases = [\n        # Case 1 (typical operating conditions)\n        {\n            \"s0\": 50_000_000.0,\n            \"I\": np.array([180.0, 160.0, 150.0, 140.0]),\n            \"R_des\": np.array([150.0, 200.0, 180.0, 160.0]),\n        },\n        # Case 2 (high inflow near capacity causing spillage)\n        {\n            \"s0\": 95_000_000.0,\n            \"I\": np.array([500.0, 600.0, 800.0, 900.0]),\n            \"R_des\": np.array([200.0, 200.0, 200.0, 200.0]),\n        },\n        # Case 3 (low inflow risking minimum storage)\n        {\n            \"s0\": 12_000_000.0,\n            \"I\": np.array([40.0, 30.0, 20.0, 10.0]),\n            \"R_des\": np.array([60.0, 60.0, 60.0, 60.0]),\n        },\n        # Case 4 (aggressive release changes violating ramp constraints)\n        {\n            \"s0\": 50_000_000.0,\n            \"I\": np.array([200.0, 200.0, 200.0, 200.0]),\n            \"R_des\": np.array([50.0, 350.0, 50.0, 350.0]),\n        },\n    ]\n\n    results = []\n\n    for case in test_cases:\n        s_current = case[\"s0\"]\n        I_t = case[\"I\"]\n        R_des_t = case[\"R_des\"]\n        \n        R_prev = R_minus_1\n        storage_sequence = []\n        \n        # Flags for the entire horizon\n        env_met_horizon = True\n        spill_occurred_horizon = False\n        ramp_clipped_occurred_horizon = False\n\n        for t in range(T):\n            # Step 1: Determine Candidate Release\n            R_target = R_des_t[t]\n\n            # a. Ramp Rate Constraint\n            R_ramped = np.clip(R_target, R_prev - rho, R_prev + rho)\n            if R_ramped != R_target:\n                ramp_clipped_occurred_horizon = True\n\n            # b. Turbine and Environmental Constraints\n            R_cand = np.clip(R_ramped, R_env_min, R_turbine_max)\n\n            # Step 2: Calculate Tentative Next Storage\n            surface_area = A0 + alpha * s_current\n            evap_rate_volumetric = E * surface_area  # m^3/s\n            \n            s_next_tentative = s_current + (I_t[t] - R_cand - evap_rate_volumetric) * delta_t\n\n            # Step 3: Enforce Storage Bounds\n            R_final = 0.0\n            s_next = 0.0\n            \n            if s_next_tentative > S_max:\n                # Spillage condition\n                s_next = S_max\n                R_final = R_cand\n                spill_occurred_horizon = True\n            elif s_next_tentative  S_min:\n                # Curtailment condition\n                s_next = S_min\n                # Recalculate release to hit S_min exactly\n                R_req = I_t[t] - evap_rate_volumetric - (S_min - s_current) / delta_t\n                R_final = R_req\n            else:\n                # Normal condition\n                s_next = s_next_tentative\n                R_final = R_cand\n\n            # Check if environmental flow was met for this step\n            if R_final  R_env_min:\n                env_met_horizon = False\n\n            # Store result and update state for next iteration\n            storage_sequence.append(s_next)\n            s_current = s_next\n            R_prev = R_final\n\n        results.append([storage_sequence, env_met_horizon, spill_occurred_horizon, ramp_clipped_occurred_horizon])\n\n    # The custom string formatting is required to match the exact output spec.\n    results_str = [f\"[{item[0]}, {str(item[1])}, {str(item[2])}, {str(item[3])}]\" for item in results]\n    print(f\"[{','.join(results_str)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "未来的入库流量永远无法被精确预测。现代水库管理依赖于概率性预报，通常以集合预报（ensemble forecasts）的形式呈现。这项练习将让你掌握评估这些预报质量并利用它们来评估运行风险的关键技能。通过计算连续分级概率评分（CRPS）等指标并进行基于集合的模拟，你将学会量化预报的不确定性，并评估发生不利情况（如水库蓄水量低于最低限制）的概率。",
            "id": "4118226",
            "problem": "考虑一个由随机入流补给的水库，该随机入流由一组轨迹集合表示。运营方在满足涡轮机容量和蓄水上限约束的条件下进行放水，并根据观测到的入流计算验证指标。从基本原理出发：水库蓄水量动态变化的质量守恒、累积分布函数的定义以及基本概率论。您需要实现对概率性入流集合和约束条件的验证，并为提供的测试套件返回定量指标。\n\n将使用的基本原理和定义：\n- 质量守恒：对于每个时间步 $t$，蓄水量更新为\n$$\nS_{t+1} \\;=\\; S_t \\;+\\; \\Delta t\\cdot I_t \\;-\\; \\Delta t\\cdot R_t \\;-\\; E_t \\;-\\; \\text{Spill}_t,\n$$\n其中 $S_t$ 是蓄水量（单位 $\\mathrm{m}^3$），$I_t$ 是入流（单位 $\\mathrm{m}^3/\\mathrm{s}$），$R_t$ 是出库流量（单位 $\\mathrm{m}^3/\\mathrm{s}$），$E_t$ 是该时间步内的蒸发损失量（单位 $\\mathrm{m}^3$），$\\text{Spill}_t \\ge 0$ 是弃水量（单位 $\\mathrm{m}^3$），$\\Delta t$ 是时间步的持续时间（单位 $\\mathrm{s}$）。涡轮机容量约束为 $R_t \\le C_t$，蓄水量边界约束为 $S_{\\min} \\le S_t \\le S_{\\max}$。\n- 累积分布函数：对于一个具有分布函数 $F_X(x) = \\mathbb{P}(X \\le x)$ 的随机变量 $X$ 和一个观测值 $y$，预报 $F_X$ 相对于 $y$ 的连续分级概率评分 (CRPS) 为\n$$\n\\text{CRPS}(F_X, y) \\;=\\; \\int_{-\\infty}^{+\\infty} \\bigl(F_X(z) - \\mathbb{1}\\{y \\le z\\}\\bigr)^2\\,\\mathrm{d}z,\n$$\n其中 $\\mathbb{1}\\{\\cdot\\}$ 是指示函数。对于离散集合，实现此定义所隐含的相应经验计算。\n- 二元事件的 Brier 评分：对于事件 $A$（例如，入流超过阈值），预报概率为 $p$，观测结果为 $o \\in \\{0,1\\}$，Brier 评分为\n$$\n\\text{BS} \\;=\\; (p - o)^2.\n$$\n\n为每个测试用例实现的任务：\n1. 使用上述积分定义所隐含的经验离散集合公式，计算在每个时间 $t$ 的入流集合与时间 $t$ 的观测入流之间的逐时间步 CRPS，然后返回每个时间步 CRPS 值的算术平均值，结果为单个浮点数。\n2. 对于二元事件“入流超过阈值”，计算逐时间步 Brier 评分。其中，预报概率取为超过阈值的集合成员所占的比例，如果观测入流超过阈值，则观测结果为 $1$，否则为 $0$。返回每个时间步 Brier 评分的算术平均值，结果为单个浮点数。\n3. 计算标称中心预测区间在水平 $p_{\\mathrm{cov}}$ 下的经验覆盖率。方法是：在每个时间 $t$，使用集合在水平 $(1-p_{\\mathrm{cov}})/2$ 和 $1-(1-p_{\\mathrm{cov}})/2$ 处的经验分位数，然后计算落入其相应区间的观测入流的比例。返回一个布尔值，指示经验覆盖率分数是否在 $p_{\\mathrm{cov}}$ 的指定容差 $tol_{\\mathrm{cov}}$ 范围内。\n4. 在策略 $R_t = \\min\\{C_t, \\text{median}(\\text{ensemble inflow at } t)\\}$ 下，模拟所有集合轨迹的水库蓄水量。时间步长 $\\Delta t = 3600\\,\\mathrm{s}$，每个时间步的蒸发量为 $E_t$（单位 $\\mathrm{m}^3$），通过设置 $S_{t+1} = \\min\\{S_{\\max}, S_t + \\Delta t\\cdot I_t - \\Delta t\\cdot R_t - E_t\\}$ 来强制执行上限约束，并在 $S_{t+1}  S_{\\min}$ 时记录一次下限违规。返回在任何时间步发生下限违规的经验概率（以小数形式表示），该概率在所有集合成员上计算。\n\n物理单位和报告：\n- 入流和出库流量单位为 $\\mathrm{m}^3/\\mathrm{s}$。\n- 蓄水量单位为 $\\mathrm{m}^3$。\n- 每个时间步的蒸发量单位为 $\\mathrm{m}^3$。\n- 所有测试用例均使用 $\\Delta t = 3600\\,\\mathrm{s}$。\n- 所有返回的数值指标均为无量纲浮点数；覆盖率以布尔值形式返回。\n- 不涉及角度单位。\n- 程序的最终输出必须是单行文本，包含一个由方括号括起来的逗号分隔列表，其中是每个测试用例的结果。每个测试用例的结果本身也是一个列表，顺序为 $[\\text{mean\\_CRPS}, \\text{mean\\_Brier}, \\text{coverage\\_ok}, \\text{lower\\_bound\\_violation\\_probability}]$。\n\n测试套件：\n- 测试用例 1（正常路径）：\n    - 集合大小 $K = 10$，时间步数 $T = 3$。\n    - 集合入流轨迹（每个列表是在时间 $t=1,2,3$ 时的入流，单位 $\\mathrm{m}^3/\\mathrm{s}$）：\n        - $[90, 100, 95]$\n        - $[92, 98, 96]$\n        - $[88, 97, 103]$\n        - $[105, 110, 102]$\n        - $[98, 101, 99]$\n        - $[93, 94, 97]$\n        - $[102, 108, 106]$\n        - $[97, 96, 100]$\n        - $[91, 99, 95]$\n        - $[100, 104, 101]$\n    - 观测入流：$[95, 102, 100]$，单位 $\\mathrm{m}^3/\\mathrm{s}$。\n    - 超出事件的阈值：$100$，单位 $\\mathrm{m}^3/\\mathrm{s}$。\n    - 标称覆盖水平：$p_{\\mathrm{cov}} = 0.9$，容差 $tol_{\\mathrm{cov}} = 0.05$。\n    - 涡轮机容量 $C_t$：$[100, 100, 100]$，单位 $\\mathrm{m}^3/\\mathrm{s}$。\n    - 每个时间步的蒸发量 $E_t$：$[5000, 5000, 5000]$，单位 $\\mathrm{m}^3$。\n    - 蓄水量边界和初始蓄水量：$S_{\\min} = 2{,}000{,}000$ $\\mathrm{m}^3$, $S_{\\max} = 5{,}000{,}000$ $\\mathrm{m}^3$, $S_0 = 3{,}000{,}000$ $\\mathrm{m}^3$。\n- 测试用例 2（高蒸发量下的下限风险）：\n    - 集合大小 $K = 8$，时间步数 $T = 4$。\n    - 集合入流轨迹：\n        - $[35, 34, 36, 33]$\n        - $[38, 39, 37, 35]$\n        - $[32, 31, 33, 30]$\n        - $[50, 45, 48, 47]$\n        - $[40, 42, 41, 43]$\n        - $[37, 36, 35, 34]$\n        - $[45, 44, 43, 42]$\n        - $[39, 38, 40, 37]$\n    - 观测入流：$[36, 38, 40, 35]$，单位 $\\mathrm{m}^3/\\mathrm{s}$。\n    - 超出事件的阈值：$42$，单位 $\\mathrm{m}^3/\\mathrm{s}$。\n    - 标称覆盖水平：$p_{\\mathrm{cov}} = 0.9$，容差 $tol_{\\mathrm{cov}} = 0.05$。\n    - 涡轮机容量 $C_t$：$[150, 150, 150, 150]$，单位 $\\mathrm{m}^3/\\mathrm{s}$。\n    - 每个时间步的蒸发量 $E_t$：$[60000, 60000, 60000, 60000]$，单位 $\\mathrm{m}^3$。\n    - 蓄水量边界和初始蓄水量：$S_{\\min} = 2{,}000{,}000$ $\\mathrm{m}^3$, $S_{\\max} = 5{,}000{,}000$ $\\mathrm{m}^3$, $S_0 = 2{,}050{,}000$ $\\mathrm{m}^3$。\n- 测试用例 3（确定性预报的边界情况）：\n    - 集合大小 $K = 1$，时间步数 $T = 2$。\n    - 集合入流轨迹：\n        - $[120, 80]$\n    - 观测入流：$[110, 90]$，单位 $\\mathrm{m}^3/\\mathrm{s}$。\n    - 超出事件的阈值：$100$，单位 $\\mathrm{m}^3/\\mathrm{s}$。\n    - 标称覆盖水平：$p_{\\mathrm{cov}} = 0.8$，容差 $tol_{\\mathrm{cov}} = 0.10$。\n    - 涡轮机容量 $C_t$：$[90, 90]$，单位 $\\mathrm{m}^3/\\mathrm{s}$。\n    - 每个时间步的蒸发量 $E_t$：$[5000, 5000]$，单位 $\\mathrm{m}^3$。\n    - 蓄水量边界和初始蓄水量：$S_{\\min} = 1{,}000{,}000$ $\\mathrm{m}^3$, $S_{\\max} = 1{,}500{,}000$ $\\mathrm{m}^3$, $S_0 = 1{,}050{,}000$ $\\mathrm{m}^3$。\n\n您的程序应生成单行输出，其中包含一个由逗号分隔并用方括号括起来的列表，其中每个元素对应一个测试用例的结果列表，顺序为 $[\\text{mean\\_CRPS}, \\text{mean\\_Brier}, \\text{coverage\\_ok}, \\text{lower\\_bound\\_violation\\_probability}]$。例如，输出格式必须完全类似于 $[[r_{1,1},r_{1,2},r_{1,3},r_{1,4}],[r_{2,1},r_{2,2},r_{2,3},r_{2,4}],[r_{3,1},r_{3,2},r_{3,3},r_{3,4}]]$。",
            "solution": "该问题要求实现四个与水库入流预报和管理相关的不同验证和模拟任务。解决方案的设计思路是，将每个任务实现为一个模块化函数，并严格遵守所提供的定义和原理。\n\n**1. 平均连续分级概率评分 (CRPS)**\n\n第一个任务是计算平均 CRPS，这是一个评估概率预报的指标。问题给出了连续预报分布 $F_X$ 和观测值 $y$ 的 CRPS 积分定义：\n$$\n\\text{CRPS}(F_X, y) \\;=\\; \\int_{-\\infty}^{+\\infty} \\bigl(F_X(z) - \\mathbb{1}\\{y \\le z\\}\\bigr)^2\\,\\mathrm{d}z\n$$\n对于一个离散集合预报 $\\{x_i\\}_{i=1}^K$，其经验累积分布函数为 $F_K(z) = \\frac{1}{K}\\sum_{i=1}^K \\mathbb{1}\\{x_i \\le z\\}$。虽然可以直接使用这个阶梯函数求解积分，但我们采用了一种计算上更方便且更广泛的公式，称为能量形式。该公式将 CRPS 表示为预报成员与观测值之间绝对误差的期望值，减去任意两个预报成员之间绝对差期望值的一半：\n$$\n\\text{CRPS}(F_K, y) = \\mathbb{E}[|X - y|] - \\frac{1}{2}\\mathbb{E}[|X - X'|]\n$$\n其中 $X$ 和 $X'$ 是从预报分布 $F_K$ 中抽取的独立随机变量。给定集合 $\\{x_i\\}_{i=1}^K$，这些期望的经验估计值为：\n$$\n\\mathbb{E}[|X - y|] \\approx \\frac{1}{K}\\sum_{i=1}^K |x_i - y|\n$$\n$$\n\\mathbb{E}[|X - X'|] \\approx \\frac{1}{K^2}\\sum_{i=1}^K \\sum_{j=1}^K |x_i - x_j|\n$$\n该算法通过遍历每个时间步 $t$（从 $0$ 到 $T-1$）来执行。在每个步骤中，使用入流集合 $\\{I_{k,t}\\}_{k=1}^K$ 和相应的观测值 $I_{\\text{obs},t}$，通过上述公式计算一个时间步的 CRPS 值。最终指标是这些逐时间步 CRPS 值的算术平均值。\n\n**2. 平均 Brier 评分**\n\n第二个任务是计算一个二元事件的平均 Brier 评分。该事件定义为入流超过给定阈值。Brier 评分由以下公式给出：\n$$\n\\text{BS} \\;=\\; (p - o)^2\n$$\n其中 $p$ 是事件的预报概率，$o \\in \\{0,1\\}$ 是观测到的二元结果。\n\n该算法同样遍历每个时间步 $t$。对于每个步骤：\n- 预报概率 $p_t$ 计算为入流 $I_{k,t}$ 严格大于指定阈值的集合成员所占的比例。\n- 如果观测入流 $I_{\\text{obs},t}$ 严格大于阈值，则观测结果 $o_t$ 设为 $1$，否则设为 $0$。\n- 计算该时间步的 Brier 评分，$\\text{BS}_t = (p_t - o_t)^2$。\n\n最终指标是所有时间步上这些评分的算术平均值。\n\n**3. 经验覆盖率验证**\n\n第三个任务是验证中心预测区间的经验覆盖率是否在其标称水平 $p_{\\mathrm{cov}}$ 的给定容差 $tol_{\\mathrm{cov}}$ 范围内。中心预测区间由入流集合在水平 $\\alpha_1 = (1 - p_{\\mathrm{cov}})/2$ 和 $\\alpha_2 = 1 - \\alpha_1 = (1 + p_{\\mathrm{cov}})/2$ 处的经验分位数定义。\n\n该算法包括以下步骤：\n- 对于每个时间步 $t$，分别计算区间下界 $q_{1,t}$ 和上界 $q_{2,t}$，它们是入流集合 $\\{I_{k,t}\\}_{k=1}^K$ 在水平 $\\alpha_1$ 和 $\\alpha_2$ 处的经验分位数。\n- 检查观测入流 $I_{\\text{obs},t}$ 是否落在此区间内，即 $q_{1,t} \\le I_{\\text{obs},t} \\le q_{2,t}$。\n- 统计观测值被覆盖的总时间步数 $T_{\\text{covered}}$。\n- 经验覆盖率分数计算为 $p_{\\text{emp}} = T_{\\text{covered}} / T$。\n- 最后，算法返回一个布尔值，指示经验覆盖率与标称覆盖率之间的绝对差是否在容差范围内：$|p_{\\text{emp}} - p_{\\mathrm{cov}}| \\le tol_{\\mathrm{cov}}$。\n\n**4. 水库下限违规概率**\n\n第四个任务是一个模拟，用于估计违反最低蓄水水平 $S_{\\min}$ 的概率。该模拟对 $K$ 个集合入流轨迹中的每一个都运行一次。水库蓄水量 $S_t$ 根据质量守恒方程演变：\n$$\nS_{t+1}^{\\text{pre-spill}} \\;=\\; S_t \\;+\\; \\Delta t\\cdot I_t \\;-\\; \\Delta t\\cdot R_t \\;-\\; E_t\n$$\n出库策略给定为 $R_t = \\min\\{C_t, \\text{median}(\\text{ensemble inflow at } t)\\}$。一个关键点是，在任何时间步 $t$，出库流量 $R_t$ 在所有模拟运行中都是恒定的，因为它取决于该时间步整个入流集合的中位数，而不是单个成员的入流。\n\n模拟算法设计如下：\n- 首先，根据给定策略预先计算所有时间步 $t=0, ..., T-1$ 的出库流量序列 $R_t$。\n- 然后，对于 $K$ 个集合成员中的每一个：\n    - 在时间范围 $T$ 内运行一次模拟。蓄水量初始化为 $S_0$。\n    - 在每个时间步 $t$，使用该特定成员的入流 $I_{k,t}$ 和预先计算的出库流量 $R_t$，计算考虑弃水前的下一蓄水状态 $S'_{k, t+1}$。\n    - 通过将该时间步的最终蓄水量设置为 $S_{k,t+1} = \\min\\{S_{\\max}, S'_{k, t+1}\\}$ 来强制执行蓄水上限。\n    - 进行检查：如果在成员 $k$ 的模拟过程中任何时刻 $S_{k,t+1}  S_{\\min}$，则为该成员记录一次违规，并可提前停止对该成员的模拟。\n- 在模拟完所有 $K$ 个成员后，统计记录了违规的成员数量 $N_{\\text{violations}}$。\n- 最终结果是违规的经验概率，计算为 $N_{\\text{violations}} / K$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and compute the required metrics.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"name\": \"Test case 1 (happy path)\",\n            \"ensemble_inflow\": np.array([\n                [90, 100, 95], [92, 98, 96], [88, 97, 103], [105, 110, 102], [98, 101, 99],\n                [93, 94, 97], [102, 108, 106], [97, 96, 100], [91, 99, 95], [100, 104, 101]\n            ]),\n            \"observed_inflow\": np.array([95, 102, 100]),\n            \"threshold\": 100.0,\n            \"p_cov\": 0.9, \"tol_cov\": 0.05,\n            \"C_t\": np.array([100, 100, 100]),\n            \"E_t\": np.array([5000, 5000, 5000]),\n            \"S_min\": 2000000.0, \"S_max\": 5000000.0, \"S_0\": 3000000.0,\n            \"delta_t\": 3600.0\n        },\n        {\n            \"name\": \"Test case 2 (lower-bound risk under high evaporation)\",\n            \"ensemble_inflow\": np.array([\n                [35, 34, 36, 33], [38, 39, 37, 35], [32, 31, 33, 30], [50, 45, 48, 47],\n                [40, 42, 41, 43], [37, 36, 35, 34], [45, 44, 43, 42], [39, 38, 40, 37]\n            ]),\n            \"observed_inflow\": np.array([36, 38, 40, 35]),\n            \"threshold\": 42.0,\n            \"p_cov\": 0.9, \"tol_cov\": 0.05,\n            \"C_t\": np.array([150, 150, 150, 150]),\n            \"E_t\": np.array([60000, 60000, 60000, 60000]),\n            \"S_min\": 2000000.0, \"S_max\": 5000000.0, \"S_0\": 2050000.0,\n            \"delta_t\": 3600.0\n        },\n        {\n            \"name\": \"Test case 3 (deterministic forecast edge case)\",\n            \"ensemble_inflow\": np.array([[120, 80]]),\n            \"observed_inflow\": np.array([110, 90]),\n            \"threshold\": 100.0,\n            \"p_cov\": 0.8, \"tol_cov\": 0.10,\n            \"C_t\": np.array([90, 90]),\n            \"E_t\": np.array([5000, 5000]),\n            \"S_min\": 1000000.0, \"S_max\": 1500000.0, \"S_0\": 1050000.0,\n            \"delta_t\": 3600.0\n        }\n    ]\n\n    def _calculate_crps(ensemble_slice, observation):\n        \"\"\"Computes empirical CRPS for a single time step.\"\"\"\n        K = len(ensemble_slice)\n        term1 = np.mean(np.abs(ensemble_slice - observation))\n        \n        # Reshape for broadcasting\n        ens_col = ensemble_slice[:, np.newaxis]\n        ens_row = ensemble_slice[np.newaxis, :]\n        \n        term2 = 0.5 * np.mean(np.abs(ens_col - ens_row))\n        return term1 - term2\n\n    def _calculate_brier(ensemble_slice, observation, threshold):\n        \"\"\"Computes Brier score for a single time step.\"\"\"\n        p_forecast = np.mean(ensemble_slice > threshold)\n        o_observed = 1 if observation > threshold else 0\n        return (p_forecast - o_observed)**2\n\n    def process_case(case):\n        \"\"\"Processes a single test case and returns the four metrics.\"\"\"\n        I_ens = case[\"ensemble_inflow\"]\n        I_obs = case[\"observed_inflow\"]\n        threshold = case[\"threshold\"]\n        p_cov, tol_cov = case[\"p_cov\"], case[\"tol_cov\"]\n        C_t, E_t = case[\"C_t\"], case[\"E_t\"]\n        S_min, S_max, S_0 = case[\"S_min\"], case[\"S_max\"], case[\"S_0\"]\n        delta_t = case[\"delta_t\"]\n\n        K, T = I_ens.shape\n\n        # Task 1: Mean CRPS\n        crps_values = [_calculate_crps(I_ens[:, t], I_obs[t]) for t in range(T)]\n        mean_crps = np.mean(crps_values)\n\n        # Task 2: Mean Brier Score\n        brier_scores = [_calculate_brier(I_ens[:, t], I_obs[t], threshold) for t in range(T)]\n        mean_brier = np.mean(brier_scores)\n        \n        # Task 3: Coverage Check\n        alpha1 = (1.0 - p_cov) / 2.0\n        alpha2 = 1.0 - alpha1\n        \n        covered_count = 0\n        for t in range(T):\n            q1 = np.quantile(I_ens[:, t], alpha1)\n            q2 = np.quantile(I_ens[:, t], alpha2)\n            if q1 = I_obs[t] = q2:\n                covered_count += 1\n        \n        p_emp = covered_count / T\n        coverage_ok = np.abs(p_emp - p_cov) = tol_cov\n\n        # Task 4: Lower-bound violation probability\n        # Pre-calculate releases, constant for all members at each time step\n        R_t = np.array([min(C_t[t], np.median(I_ens[:, t])) for t in range(T)])\n        \n        violations = 0\n        for k in range(K):\n            S_current = S_0\n            violation_found = False\n            for t in range(T):\n                inflow_vol = I_ens[k, t] * delta_t\n                release_vol = R_t[t] * delta_t\n                evap_vol = E_t[t]\n                \n                S_next_pre_spill = S_current + inflow_vol - release_vol - evap_vol\n                S_next = min(S_max, S_next_pre_spill)\n                \n                if S_next  S_min:\n                    violation_found = True\n                    break\n                S_current = S_next\n            \n            if violation_found:\n                violations += 1\n        \n        violation_prob = violations / K\n        \n        return [mean_crps, mean_brier, coverage_ok, violation_prob]\n\n    results = [process_case(case) for case in test_cases]\n    \n    # Format the final output string as specified\n    # The boolean values need to be lowercase 'true'/'false' in the final string representation\n    formatted_results = []\n    for res in results:\n        res_copy = res[:]\n        res_copy[2] = str(res_copy[2]).lower()\n        formatted_results.append(str(res_copy))\n        \n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}