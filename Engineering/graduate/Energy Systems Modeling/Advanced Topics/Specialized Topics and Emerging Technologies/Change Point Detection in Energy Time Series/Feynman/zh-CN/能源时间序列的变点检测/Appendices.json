{
    "hands_on_practices": [
        {
            "introduction": "在能源系统实时监控中，快速检测到负荷或发电量的结构性变化至关重要。序贯概率比检验 (SPRT) 为这类在线检测问题提供了强有力的理论框架，它能够在数据流式到达时，以最少的样本量做出决策 ()。本实践将通过一个电网负荷均值漂移的假设场景，引导你从第一性原理推导 SPRT 的核心组成部分，并计算其在特定错误率下的预期决策时间，从而加深对序贯分析效率和应用的理解。",
            "id": "4077365",
            "problem": "一位输电运营商监控一个大型平衡区域的分钟级总电力负荷。设实时负荷测量值为 $\\{X_t\\}_{t \\ge 1}$，以兆瓦为单位每分钟记录一次，建模为独立同分布的高斯随机变量，其方差 $\\sigma^2$ 已知，而未知均值可能因持续的需求变化而发生偏移。在标称条件下，均值为 $\\mu_0$；如果发生阶跃变化，均值将变为 $\\mu_1 > \\mu_0$ 并保持不变。为了进行在线检测，考虑简单对简单假设 $H_0: X_t \\sim \\mathcal{N}(\\mu_0,\\sigma^2)$ 对 $H_1: X_t \\sim \\mathcal{N}(\\mu_1,\\sigma^2)$，其中 $\\mu_0$、$\\mu_1$ 和 $\\sigma^2$ 已知。\n\n仅从高斯概率密度函数的定义和简单假设的似然比定义出发，推导用于检测均值向上偏移的序贯概率比检验 (SPRT)。您的推导必须从第一性原理出发，建立以下组成部分：\n- 每样本对数似然增量 $Z_t$ 和累积对数似然 $S_n = \\sum_{t=1}^{n} Z_t$。\n- 一个基于应用于 $S_n$ 的两个固定阈值 $a$ 和 $b$ 的停止规则，该规则能达到 I 型错误概率 $\\alpha$ 和 II 型错误概率 $\\beta$。\n- 在 $H_0$ 和 $H_1$ 下 $S_n$ 的每样本期望漂移。\n\n然后，使用 Wald 恒等式和在停止边界处的忽略过冲近似，推导在 $H_0$ 下（表示为 $\\mathbb{E}_0[N]$）和在 $H_1$ 下（表示为 $\\mathbb{E}_1[N]$）的期望样本量的解析表达式，用漂移和阈值 $a$、$b$ 表示。最后，对以下参数进行数值评估这些表达式：\n- $\\mu_0 = 500\\,\\text{MW}$,\n- $\\mu_1 = 520\\,\\text{MW}$,\n- $\\sigma = 20\\,\\text{MW}$,\n- $\\alpha = 0.01$,\n- $\\beta = 0.05$.\n\n将最终的期望样本量表示为期望的一分钟样本数。将您的数值结果四舍五入到四位有效数字。以行向量 $\\big[\\mathbb{E}_0[N],\\,\\mathbb{E}_1[N]\\big]$ 的形式提供最终答案，向量中不带单位。",
            "solution": "首先验证问题，以确保其科学上合理、适定且客观。\n\n### 步骤 1：提取已知条件\n- 数据为实时负荷测量值 $\\{X_t\\}_{t \\ge 1}$，每分钟记录一次。\n- 测量值被建模为独立同分布 (i.i.d.) 的高斯随机变量。\n- 方差已知，表示为 $\\sigma^2$。\n- 两个简单假设为：\n    - $H_0: X_t \\sim \\mathcal{N}(\\mu_0, \\sigma^2)$ (标称条件)。\n    - $H_1: X_t \\sim \\mathcal{N}(\\mu_1, \\sigma^2)$ (变化后条件)。\n- 均值 $\\mu_0$ 和 $\\mu_1$，以及标准差 $\\sigma$ 是已知常数。\n- 已指定 $\\mu_1 > \\mu_0$。\n- 期望的 I 型错误概率为 $\\alpha$。\n- 期望的 II 型错误概率为 $\\beta$。\n- 用于评估的数值参数：\n    - $\\mu_0 = 500\\,\\text{MW}$\n    - $\\mu_1 = 520\\,\\text{MW}$\n    - $\\sigma = 20\\,\\text{MW}$\n    - $\\alpha = 0.01$\n    - $\\beta = 0.05$\n\n### 步骤 2：使用提取的已知条件进行验证\n依据所需标准对问题进行评估。\n- **科学依据**：该问题是序贯概率比检验 (SPRT) 的一个标准应用，SPRT 是序贯分析和统计过程控制中的一个基础且成熟的方法。将总电力负荷建模为高斯过程是许多能源系统分析中常见且合理的简化。\n- **适定性**：推导和后续数值计算所需的所有必要参数（$\\mu_0, \\mu_1, \\sigma, \\alpha, \\beta$）均已提供。目标陈述清晰，从而得到唯一的解析解和数值解。\n- **客观性**：该问题以精确、形式化的数学和统计语言陈述，没有任何主观性或模糊性。\n\n该问题没有任何无效性缺陷。它是应用统计学中一个定义明确的标准问题。\n\n### 步骤 3：结论与行动\n该问题被认为是**有效**的。将提供一个附带推理过程的完整解。\n\n### 序贯概率比检验的推导\n\n#### 每样本对数似然增量\nSPRT 的基础是似然比。对于单个观测值 $X_t$，该比率比较了在假设 $H_1$ 下观测到 $X_t$ 的概率与在假设 $H_0$ 下的概率。均值为 $\\mu$、方差为 $\\sigma^2$ 的高斯随机变量 $X$ 的概率密度函数 (PDF) 为：\n$$f(x; \\mu, \\sigma^2) = \\frac{1}{\\sqrt{2\\pi\\sigma^2}} \\exp\\left(-\\frac{(x - \\mu)^2}{2\\sigma^2}\\right)$$\n观测值 $X_t$ 的似然比为：\n$$L_t = \\frac{f(X_t; \\mu_1, \\sigma^2)}{f(X_t; \\mu_0, \\sigma^2)} = \\frac{\\frac{1}{\\sqrt{2\\pi\\sigma^2}} \\exp\\left(-\\frac{(X_t - \\mu_1)^2}{2\\sigma^2}\\right)}{\\frac{1}{\\sqrt{2\\pi\\sigma^2}} \\exp\\left(-\\frac{(X_t - \\mu_0)^2}{2\\sigma^2}\\right)}$$\n指数前因子相互抵消，得到：\n$$L_t = \\exp\\left( \\frac{(X_t - \\mu_0)^2 - (X_t - \\mu_1)^2}{2\\sigma^2} \\right)$$\n为了计算上的便利和理论分析，我们使用似然比的自然对数，即所谓的对数似然增量 $Z_t$：\n$$Z_t = \\ln(L_t) = \\frac{1}{2\\sigma^2} \\left[ (X_t - \\mu_0)^2 - (X_t - \\mu_1)^2 \\right]$$\n展开平方项：\n$$Z_t = \\frac{1}{2\\sigma^2} \\left[ (X_t^2 - 2X_t\\mu_0 + \\mu_0^2) - (X_t^2 - 2X_t\\mu_1 + \\mu_1^2) \\right]$$\n通过消去 $X_t^2$ 项来简化表达式：\n$$Z_t = \\frac{1}{2\\sigma^2} \\left[ 2X_t(\\mu_1 - \\mu_0) + \\mu_0^2 - \\mu_1^2 \\right]$$\n对 $(\\mu_0^2 - \\mu_1^2) = -(\\mu_1 - \\mu_0)(\\mu_1 + \\mu_0)$ 进行因式分解：\n$$Z_t = \\frac{\\mu_1 - \\mu_0}{\\sigma^2} X_t - \\frac{(\\mu_1 - \\mu_0)(\\mu_1 + \\mu_0)}{2\\sigma^2}$$\n这可以更紧凑地写为：\n$$Z_t = \\frac{\\mu_1 - \\mu_0}{\\sigma^2} \\left( X_t - \\frac{\\mu_0 + \\mu_1}{2} \\right)$$\n检验统计量是这些对数似然增量在 $n$ 个样本上的累积和：\n$$S_n = \\sum_{t=1}^{n} Z_t$$\n\n#### 停止规则和阈值\nSPRT 的过程是每获得一个新观测值 $X_n$ 就更新 $S_n$。在每一步 $n$，$S_n$ 都与两个固定的阈值 $a$ 和 $b$进行比较。决策规则如下：\n1. 如果 $S_n \\le a$，停止抽样并接受 $H_0$。\n2. 如果 $S_n \\ge b$，停止抽样并接受 $H_1$。\n3. 如果 $a < S_n < b$，通过获取下一个观测值 $X_{n+1}$ 继续抽样。\n\n阈值 $a$ 和 $b$ 的选择是为了满足期望的错误概率，即 $\\alpha$（I 型错误，虚警）和 $\\beta$（II 型错误，漏检）。对于较小的 $\\alpha$ 和 $\\beta$ 值，Wald 近似是准确的，它将阈值与错误概率关联如下：\n$$a \\approx \\ln\\left(\\frac{\\beta}{1-\\alpha}\\right)$$\n$$b \\approx \\ln\\left(\\frac{1-\\beta}{\\alpha}\\right)$$\n鉴于对于任何有意义的检验都有 $\\alpha < 1-\\beta$ 和 $\\beta < 1-\\alpha$，我们有 $\\beta/(1-\\alpha) < 1$ 和 $(1-\\beta)/\\alpha > 1$，这确保了 $a < 0 < b$。\n\n#### 每样本期望漂移\n累积和 $S_n$ 的行为由其期望每样本增量（即漂移）来刻画。我们在两种假设下计算此漂移。\n在 $H_0$ 下，真实均值为 $\\mu_0$，因此 $\\mathbb{E}_0[X_t] = \\mu_0$。$Z_t$ 的期望值为：\n$$\\mathbb{E}_0[Z_t] = \\mathbb{E}_0\\left[ \\frac{\\mu_1 - \\mu_0}{\\sigma^2} \\left( X_t - \\frac{\\mu_0 + \\mu_1}{2} \\right) \\right]$$\n$$\\mathbb{E}_0[Z_t] = \\frac{\\mu_1 - \\mu_0}{\\sigma^2} \\left( \\mathbb{E}_0[X_t] - \\frac{\\mu_0 + \\mu_1}{2} \\right) = \\frac{\\mu_1 - \\mu_0}{\\sigma^2} \\left( \\mu_0 - \\frac{\\mu_0 + \\mu_1}{2} \\right)$$\n$$\\mathbb{E}_0[Z_t] = \\frac{\\mu_1 - \\mu_0}{\\sigma^2} \\left( \\frac{2\\mu_0 - \\mu_0 - \\mu_1}{2} \\right) = -\\frac{(\\mu_1 - \\mu_0)^2}{2\\sigma^2}$$\n在 $H_1$ 下，真实均值为 $\\mu_1$，因此 $\\mathbb{E}_1[X_t] = \\mu_1$。$Z_t$ 的期望值为：\n$$\\mathbb{E}_1[Z_t] = \\mathbb{E}_1\\left[ \\frac{\\mu_1 - \\mu_0}{\\sigma^2} \\left( X_t - \\frac{\\mu_0 + \\mu_1}{2} \\right) \\right]$$\n$$\\mathbb{E}_1[Z_t] = \\frac{\\mu_1 - \\mu_0}{\\sigma^2} \\left( \\mathbb{E}_1[X_t] - \\frac{\\mu_0 + \\mu_1}{2} \\right) = \\frac{\\mu_1 - \\mu_0}{\\sigma^2} \\left( \\mu_1 - \\frac{\\mu_0 + \\mu_1}{2} \\right)$$\n$$\\mathbb{E}_1[Z_t] = \\frac{\\mu_1 - \\mu_0}{\\sigma^2} \\left( \\frac{2\\mu_1 - \\mu_0 - \\mu_1}{2} \\right) = \\frac{(\\mu_1 - \\mu_0)^2}{2\\sigma^2}$$\n注意 $\\mathbb{E}_0[Z_t] = -\\mathbb{E}_1[Z_t]$。在 $H_0$ 下，统计量 $S_n$ 向下漂移至阈值 $a$；在 $H_1$ 下，它向上漂移至阈值 $b$。\n\n#### 期望样本量\n设 $N$ 为检验的停止时间。Wald 恒等式指出，对于 i.i.d. 随机变量的和，有 $\\mathbb{E}[S_N] = \\mathbb{E}[N] \\mathbb{E}[Z_t]$。我们可以用这个来求平均样本数 (ASN) 或期望样本量 $\\mathbb{E}[N]$。\n忽略过冲的近似假设当过程停止时，$S_N$ 近似等于它所越过的边界，即 $S_N \\approx a$ 或 $S_N \\approx b$。\n\n在 $H_0$ 下，检验以 $1-\\alpha$ 的概率在边界 $a$ 停止（正确决策），并以 $\\alpha$ 的概率在边界 $b$ 停止（I 型错误）。$S_N$ 的期望值近似为：\n$$\\mathbb{E}_0[S_N] \\approx (1-\\alpha) \\cdot a + \\alpha \\cdot b$$\n应用 Wald 恒等式：\n$$\\mathbb{E}_0[N] \\mathbb{E}_0[Z_t] \\approx (1-\\alpha)a + \\alpha b$$\n求解 $H_0$ 下的期望样本量：\n$$\\mathbb{E}_0[N] \\approx \\frac{(1-\\alpha)a + \\alpha b}{\\mathbb{E}_0[Z_t]}$$\n在 $H_1$ 下，检验以 $1-\\beta$ 的概率在边界 $b$ 停止（正确决策），并以 $\\beta$ 的概率在边界 $a$ 停止（II 型错误）。$S_N$ 的期望值近似为：\n$$\\mathbb{E}_1[S_N] \\approx \\beta \\cdot a + (1-\\beta) \\cdot b$$\n应用 Wald 恒等式：\n$$\\mathbb{E}_1[N] \\mathbb{E}_1[Z_t] \\approx \\beta a + (1-\\beta) b$$\n求解 $H_1$ 下的期望样本量：\n$$\\mathbb{E}_1[N] \\approx \\frac{\\beta a + (1-\\beta) b}{\\mathbb{E}_1[Z_t]}$$\n\n### 数值评估\n现在我们将给定的数值代入推导出的表达式中。\n- 参数： $\\mu_0 = 500$, $\\mu_1 = 520$, $\\sigma = 20$, $\\alpha = 0.01$, $\\beta = 0.05$。\n\n首先，计算阈值 $a$ 和 $b$：\n$$a = \\ln\\left(\\frac{\\beta}{1-\\alpha}\\right) = \\ln\\left(\\frac{0.05}{1-0.01}\\right) = \\ln\\left(\\frac{0.05}{0.99}\\right) \\approx -2.985676$$\n$$b = \\ln\\left(\\frac{1-\\beta}{\\alpha}\\right) = \\ln\\left(\\frac{1-0.05}{0.01}\\right) = \\ln\\left(\\frac{0.95}{0.01}\\right) = \\ln(95) \\approx 4.553877$$\n\n接着，计算期望漂移：\n$$\\mu_1 - \\mu_0 = 520 - 500 = 20$$\n$$\\sigma^2 = 20^2 = 400$$\n$$\\mathbb{E}_1[Z_t] = \\frac{(\\mu_1 - \\mu_0)^2}{2\\sigma^2} = \\frac{20^2}{2 \\cdot 400} = \\frac{400}{800} = 0.5$$\n$$\\mathbb{E}_0[Z_t] = -0.5$$\n\n最后，计算期望样本量 $\\mathbb{E}_0[N]$ 和 $\\mathbb{E}_1[N]$：\n$$\\mathbb{E}_0[N] \\approx \\frac{(1-0.01) \\cdot (-2.985676) + 0.01 \\cdot (4.553877)}{-0.5}$$\n$$\\mathbb{E}_0[N] \\approx \\frac{0.99 \\cdot (-2.985676) + 0.01 \\cdot (4.553877)}{-0.5} = \\frac{-2.955819 + 0.045539}{-0.5} = \\frac{-2.91028}{-0.5} \\approx 5.82056$$\n四舍五入到四位有效数字，$\\mathbb{E}_0[N] \\approx 5.821$。\n\n$$\\mathbb{E}_1[N] \\approx \\frac{0.05 \\cdot (-2.985676) + (1-0.05) \\cdot (4.553877)}{0.5}$$\n$$\\mathbb{E}_1[N] \\approx \\frac{0.05 \\cdot (-2.985676) + 0.95 \\cdot (4.553877)}{0.5} = \\frac{-0.149284 + 4.326183}{0.5} = \\frac{4.176899}{0.5} \\approx 8.35380$$\n四舍五入到四位有效数字，$\\mathbb{E}_1[N] \\approx 8.354$。\n\n这些值表示达到决策所需的期望一分钟样本数。",
            "answer": "$$ \\boxed{ \\begin{pmatrix} 5.821 & 8.354 \\end{pmatrix} } $$"
        },
        {
            "introduction": "与在线检测不同，离线分析允许我们对整个时间序列进行回顾性分析，以识别所有潜在的变化点。这类问题通常被构建为模型选择任务，即在拟合数据与模型复杂度之间寻求平衡。本实践将介绍动态规划方法，这是一种能够精确求解分段常数模型最优分割的强大算法 ()。通过分析一个包含间歇性云层遮挡的太阳辐照度合成数据集，你将亲手实现该算法，并探究惩罚项和最小段长等关键参数如何影响分割结果，从而在过分割与欠分割之间进行权衡。",
            "id": "4077437",
            "problem": "考虑一个以 $1$ 分钟为固定采样间隔的单变量太阳辐照度时间序列，其中包含间歇性的云层通过，辐照度以瓦特/平方米 (W/m$^2$) 为单位记录。设该时间序列表示为 $\\{x_t\\}_{t=1}^N$，其中 $x_t$ 被建模为受独立高斯噪声干扰的分段常数均值：$x_t = \\mu_{s(t)} + \\varepsilon_t$，其中 $\\varepsilon_t \\sim \\mathcal{N}(0,\\sigma^2)$，$s(t)$ 是时间 $t$ 的段索引。变化点是段均值发生变化的任何索引 $t$。在能源系统建模中，能源时间序列中的变化点检测通常被视为一个带有最小段长度约束的惩罚似然问题，以减少过分割和欠分割。\n\n从独立高斯噪声的定义以及通过最小描述长度和信息准则进行模型选择的原则出发，推导并实现一个程序。该程序在给定施加于每段的惩罚大小 $\\lambda$ 和最小段长度 $L_{\\min}$ 的情况下，对于一个具有已知真实变化点的固定的合成太阳辐照度时间序列，返回过分割与欠分割的整数分类。过分割定义为检测到的段数严格多于真实值的段数（$+1$），欠分割定义为检测到的段数严格少于真实值的段数（$-1$），匹配分割定义为检测到的段数与真实值完全相同（$0$）。\n\n使用以下科学上真实的合成场景来定义 $\\{x_t\\}_{t=1}^N$：设 $N = 480$ 分钟。真实值包含 $9$ 个恒定辐照度段，其均值（单位为 W/m$^2$）和持续时间（单位为分钟）由有序列表给出：\nmeans $= [800, 300, 820, 500, 850, 450, 830, 350, 820]$,\ndurations $= [90, 30, 80, 40, 60, 10, 70, 50, 50]$,\n因此，真实变化点出现在累积索引 $[90, 120, 200, 240, 300, 310, 380, 430]$ 处。添加标准差为 $\\sigma = 60$ W/m$^2$ 的独立高斯测量噪声。确定性地固定随机种子，以便结果可复现。程序必须解决惩罚分割问题，该问题最小化段内平方误差之和加上 $\\lambda$ 乘以段数，并受每个段的长度至少为 $L_{\\min}$ 的约束。\n\n实现一个算法，在这些约束下计算最优分割，并为下面的每个测试用例返回整数分类 $+1$、$0$ 或 $-1$。除指定的运行时环境外，不要假设任何外部库。此问题不使用角度。时间以分钟为单位，辐照度以 W/m$^2$ 为单位，但最终输出是如上定义的无单位整数。\n\n测试套件：\n- 案例 $1$：$\\lambda = 0$， $L_{\\min} = 1$。\n- 案例 $2$：$\\lambda = 10^9$， $L_{\\min} = 1$。\n- 案例 $3$：$\\lambda = 10^6$， $L_{\\min} = 1$。\n- 案例 $4$：$\\lambda = 10^3$， $L_{\\min} = 20$。\n- 案例 $5$：$\\lambda = 5 \\times 10^6$， $L_{\\min} = 50$。\n- 案例 $6$：$\\lambda = 10^6$， $L_{\\min} = 50$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个逗号分隔的列表，列表用方括号括起来（例如，“[result_1,result_2,...,result_6]”），其中每个 $result_i$ 是按上面列出的顺序对应的测试用例的整数分类。不应产生其他输出。最终输出为无单位整数。",
            "solution": "用户希望我解决一个变化点检测问题。\n\n### 步骤1：提取给定信息\n- **时间序列模型**：一个单变量时间序列 $\\{x_t\\}_{t=1}^N$ 被建模为 $x_t = \\mu_{s(t)} + \\varepsilon_t$。\n- **噪声**：噪声项 $\\varepsilon_t$ 是独立同分布的高斯分布，$\\varepsilon_t \\sim \\mathcal{N}(0, \\sigma^2)$。\n- **信号**：均值 $\\mu_{s(t)}$ 是分段常数，其中 $s(t)$ 是时间 $t$ 的段索引。\n- **目标函数**：找到一个分割，以最小化段内平方误差之和加上一个惩罚项，即 $\\lambda \\times (\\text{段数})$。\n- **约束**：每个段的长度必须至少为 $L_{\\min}$。\n- **输出分类**：\n    -   过分割（$+1$）：检测到的段数 > 真实段数。\n    -   欠分割（$-1$）：检测到的段数 < 真实段数。\n    -   匹配分割（$0$）：检测到的段数 = 真实段数。\n- **合成数据参数**：\n    -   总长度：$N = 480$ 分钟。\n    -   采样间隔：$1$ 分钟。\n    -   真实均值 (W/m$^2$)：`means` $= [800, 300, 820, 500, 850, 450, 830, 350, 820]$。\n    -   真实持续时间（分钟）：`durations` $= [90, 30, 80, 40, 60, 10, 70, 50, 50]$。\n    -   真实段数：$K_{true} = 9$。\n    -   噪声标准差：$\\sigma = 60$ W/m$^2$。\n    -   必须使用确定性的随机种子。\n- **测试套件**：\n    -   案例 1：$\\lambda = 0$， $L_{\\min} = 1$。\n    -   案例 2：$\\lambda = 10^9$， $L_{\\min} = 1$。\n    -   案例 3：$\\lambda = 10^6$， $L_{\\min} = 1$。\n    -   案例 4：$\\lambda = 10^3$， $L_{\\min} = 20$。\n    -   案例 5：$\\lambda = 5 \\times 10^6$， $L_{\\min} = 50$。\n    -   案例 6：$\\lambda = 10^6$， $L_{\\min} = 50$。\n\n### 步骤2：使用提取的给定信息进行验证\n该问题在科学和数学上是明确定义的。\n- **科学依据**：分段常数信号加高斯噪声的模型是信号处理和统计学中的典型模型。变化点检测问题是时间序列分析中的一个基本问题。使用惩罚似然是模型选择的标准技术，与 AIC 和 BIC 等信息准则直接相关。太阳辐照度的物理背景和提供的数值是现实的。问题有效。\n- **适定性**：任务是解决一个明确定义的优化问题。最优解保证存在。使用动态规划提供了一种找到这个唯一最优解的具体方法。问题有效。\n- **目标**：问题以精确的数学定义、数值数据和明确的术语进行了规定。目标函数和约束条件都清晰陈述。问题有效。\n\n### 步骤3：结论与行动\n问题有效。将提供一个完整的解决方案。\n\n### 基于原则的求解推导\n\n问题是找到时间序列 $\\{x_t\\}_{t=0}^{N-1}$ 的一个最优划分，使其分成若干段，以最小化一个惩罚成本函数。这是一个经典的变化点检测问题，可以用动态规划精确求解。\n\n**1. 数学公式**\n\n设时间序列为 $x_0, x_1, \\dots, x_{N-1}$。一个分割由一组变化点 $0 = \\tau_0 < \\tau_1 < \\dots < \\tau_K = N$ 定义，这些变化点将数据划分为 $K$ 个段。第 $k$ 个段包含数据点 $\\{x_t\\}_{t=\\tau_{k-1}}^{\\tau_k-1}$。\n\n问题是最小化总成本，该成本是两项之和：总的段内平方误差和与段数成正比的惩罚项。\n要最小化的成本函数是：\n$$ \\mathcal{J}(\\tau_1, \\dots, \\tau_K) = \\sum_{k=1}^{K} \\left( \\sum_{t=\\tau_{k-1}}^{\\tau_k-1} (x_t - \\hat{\\mu}_k)^2 \\right) + \\lambda K $$\n其中 $\\hat{\\mu}_k$ 是第 $k$ 个段的估计均值，$K$ 是总段数。\n\n这个公式源于高斯噪声模型下的最大似然估计原理，并结合了对模型复杂度的惩罚，类似于 AIC 或 BIC 等信息准则。对于一段假设来自 $\\mathcal{N}(\\mu, \\sigma^2)$ 的数据，均值 $\\mu$ 的最大似然估计是样本均值。最小化平方误差和 $\\sum(x_t - \\hat{\\mu})^2$ 等价于最大化数据的似然。项 $\\lambda K$ 是对模型复杂度的惩罚，通过惩罚每个额外的段来防止过拟合（过分割）。\n\n令 $c(i, j)$ 表示从索引 $i$到 $j-1$ 的单段数据 $\\{x_t\\}_{t=i}^{j-1}$ 的最小平方误差和。当均值为样本均值 $\\hat{\\mu}_{i..j-1} = \\frac{1}{j-i} \\sum_{t=i}^{j-1} x_t$ 时，达到此成本。成本则为：\n$$ c(i, j) = \\sum_{t=i}^{j-1} (x_t - \\hat{\\mu}_{i..j-1})^2 = \\left(\\sum_{t=i}^{j-1} x_t^2\\right) - \\frac{1}{j-i} \\left(\\sum_{t=i}^{j-1} x_t\\right)^2 $$\n总成本可以表示为：\n$$ \\mathcal{J} = \\sum_{k=1}^{K} \\left( c(\\tau_{k-1}, \\tau_k) + \\lambda \\right) $$\n\n**2. 动态规划解法**\n\n这个优化问题具有最优子结构，使其非常适合动态规划。令 $F[i]$ 为前 $i$ 个数据点 $x_0, \\dots, x_{i-1}$ 的最优分割的最小成本。我们的目标是计算 $F[N]$。\n\n基本情况是空前缀，其成本为 $0$。因此，$F[0] = 0$。\n\n对于 $i > 0$，可以通过考虑前一个段的所有可能终点来计算 $F[i]$ 的值。如果最后一个段是 $x_j, \\dots, x_{i-1}$，则总成本是分割到 $x_{j-1}$ 的最优成本（即 $F[j]$）加上这个新最后段的成本（即 $c(j, i) + \\lambda$）。我们必须在所有可能的起始点 $j$ 上最小化这个值。\n\n递推关系是：\n$$ F[i] = \\min_{0 \\le j < i} \\{ F[j] + c(j, i) + \\lambda \\} $$\n我们还被给予了每个段长度至少为 $L_{\\min}$ 的约束。从 $j$ 到 $i-1$ 的段长度为 $i-j$。因此，我们必须有 $i-j \\ge L_{\\min}$，这意味着 $j \\le i - L_{\\min}$。\n\n带约束的递推关系变为：\n$$ F[i] = \\min_{0 \\le j \\le i - L_{\\min}} \\{ F[j] + c(j, i) + \\lambda \\} $$\n对于 $i = 1, \\dots, N$。为了重构分割，我们还存储为每个 $i$ 产生最小值的最优索引 $j$。设其为 $P[i]$。\n\n**3. 高效实现**\n\n这种动态规划的朴素实现会因为 $c(j, i)$ 的重复计算而很慢。计算 $c(j,i)$ 需要 $O(i-j)$ 的时间，使得总复杂度为 $O(N^3)$。我们可以通过预计算累积和将其降低到 $O(N^2)$。\n设 $S_1[i] = \\sum_{t=0}^{i-1} x_t$ 和 $S_2[i] = \\sum_{t=0}^{i-1} x_t^2$。\n那么 $\\sum_{t=j}^{i-1} x_t = S_1[i] - S_1[j]$ 和 $\\sum_{t=j}^{i-1} x_t^2 = S_2[i] - S_2[j]$。\n现在成本 $c(j, i)$ 可以在 $O(1)$ 时间内计算：\n$$ c(j, i) = (S_2[i] - S_2[j]) - \\frac{(S_1[i] - S_1[j])^2}{i-j} $$\n通过这种优化，动态规划算法的运行时间为 $O(N^2)$，对于 $N=480$ 来说足够高效。\n\n**4. 重构解和分类**\n\n在填充了动态规划表 $F$ 和指针表 $P$ 直到 $N$ 之后，最优成本是 $F[N]$。为了找到段数，我们使用从 $P[N]$ 开始的指针进行回溯。\n设当前索引为 `idx`$=N$。\n最后一个段的起始点是 $P[N]$。\n倒数第二个段的起始点是 $P[P[N]]$，依此类推，直到我们达到 $0$。\n段数是从 $N$ 回溯到 $0$ 所需的步数。\n\n设 $K_{found}$ 是算法找到的段数。真实段数是 $K_{true} = 9$。最终分类由 $K_{found} - K_{true}$ 的符号确定：\n-   如果 $K_{found} > K_{true}$，结果是 $+1$（过分割）。\n-   如果 $K_{found} < K_{true}$，结果是 $-1$（欠分割）。\n-   如果 $K_{found} = K_{true}$，结果是 $0$（匹配分割）。\n\n此过程应用于每个测试用例，使用其特定的 $\\lambda$ 和 $L_{\\min}$ 值。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the change point detection problem for all test cases.\n    \"\"\"\n\n    # 1. Define synthetic data parameters from the problem statement\n    means = [800, 300, 820, 500, 850, 450, 830, 350, 820]\n    durations = [90, 30, 80, 40, 60, 10, 70, 50, 50]\n    N = 480\n    sigma = 60.0\n    K_true = 9\n    \n    # 2. Generate the synthetic solar irradiance time series\n    # Fix the random seed for reproducibility as required\n    np.random.seed(42)\n    \n    # Construct the piecewise constant ground-truth signal\n    x_true = np.zeros(N)\n    current_idx = 0\n    for mean_val, duration in zip(means, durations):\n        x_true[current_idx : current_idx + duration] = mean_val\n        current_idx += duration\n        \n    # Add independent Gaussian noise\n    noise = np.random.normal(loc=0.0, scale=sigma, size=N)\n    x = x_true + noise\n\n    # 3. Define test cases\n    test_cases = [\n        (0, 1),           # Case 1\n        (10**9, 1),       # Case 2\n        (10**6, 1),       # Case 3\n        (10**3, 20),      # Case 4\n        (5 * 10**6, 50),  # Case 5\n        (10**6, 50),      # Case 6\n    ]\n\n    results = []\n    \n    # 4. Process each test case\n    for lambda_val, L_min in test_cases:\n        num_segments_found = find_optimal_segments(x, lambda_val, L_min)\n        \n        # Classify the segmentation result\n        if num_segments_found > K_true:\n            classification = 1\n        elif num_segments_found < K_true:\n            classification = -1\n        else:\n            classification = 0\n        results.append(classification)\n\n    # 5. Print the final output in the required format\n    print(f\"[{','.join(map(str, results))}]\")\n\n\ndef find_optimal_segments(x, lambda_val, L_min):\n    \"\"\"\n    Finds the optimal number of segments for a given time series, penalty, and min length.\n    Uses a dynamic programming approach (Optimal Partitioning).\n    \"\"\"\n    N = len(x)\n\n    # Precompute cumulative sums for efficient cost calculation\n    # S1[i] = sum(x[0]...x[i-1]), S2[i] = sum(x[0]**2...x[i-1]**2)\n    # This allows O(1) calculation of sum of squares for any sub-segment.\n    S1 = np.zeros(N + 1)\n    S2 = np.zeros(N + 1)\n    S1[1:] = np.cumsum(x)\n    S2[1:] = np.cumsum(x**2)\n\n    def cost(j, i):\n        \"\"\"\n        Calculates the sum of squared errors for the segment x[j...i-1].\n        \"\"\"\n        if j >= i:\n            return 0\n        \n        length = float(i - j)\n        sum_x = S1[i] - S1[j]\n        sum_x2 = S2[i] - S2[j]\n        \n        # cost = sum(x^2) - (sum(x))^2 / length\n        cost_val = sum_x2 - (sum_x**2) / length\n        return cost_val\n\n    # Initialize DP arrays\n    # F[i]: minimum cost for segmenting the prefix x[0...i-1]\n    # P[i]: stores the optimal last changepoint for the prefix x[0...i-1]\n    F = np.full(N + 1, np.inf)\n    P = np.zeros(N + 1, dtype=int)\n    \n    # Base case: cost of segmenting an empty prefix is 0\n    F[0] = 0\n\n    # Fill DP table using the recurrence relation\n    for i in range(1, N + 1):\n        # The last segment x[j...i-1] must have length at least L_min.\n        # Length = i - j >= L_min  =>  j <= i - L_min\n        for j in range(i - L_min + 1):\n            \n            # This path is only possible if F[j] is not infinity\n            if F[j] != np.inf:\n                # Cost of a potential segmentation ending at i with the last segment starting at j\n                c = cost(j, i)\n                current_cost = F[j] + c + lambda_val\n                \n                if current_cost < F[i]:\n                    F[i] = current_cost\n                    P[i] = j\n    \n    # Backtrack using the P array to find the number of segments\n    count = 0\n    idx = N\n    while idx > 0:\n        idx = P[idx]\n        count += 1\n        \n    return count\n\nsolve()\n```"
        },
        {
            "introduction": "在将变化点检测应用于储能等实际能源系统时，纯粹的统计模型可能不足以描述系统的全部行为，因为物理约束（如电池容量）必须得到满足。本实践在前一个动态规划分割练习的基础上，引入了对系统状态（如此处的电池荷电状态）的物理约束。你将学习如何修改动态规划框架，将这些非统计学的约束条件整合到优化过程中，以确保最终得到的分割方案不仅在统计上是最优的，在物理上也是可行的 ()。这个练习是连接抽象统计模型与具体工程应用的重要桥梁。",
            "id": "4077358",
            "problem": "给定一个离散时间序列，表示并网电池在连续、等间隔时间步长上的净功率不平衡测量值。设测量序列表示为 $\\{y_t\\}_{t=1}^T$，其中每个 $y_t$ 的单位为千瓦 (kW)。假设样本间的间隔长度为 $1$ 小时，因此功率的累加和对应于以千瓦时 (kWh) 为单位的能量。在以下基本假设和定义下对系统进行建模。\n\n1. 统计模型与分段。该序列服从一个带有加性噪声的分段常数均值模型。存在一个索引集 $\\{1,2,\\dots,T\\}$ 的分割，将其分为 $K$ 个连续的段，各段的均值为 $\\{\\mu_k\\}_{k=1}^K$，使得\n$$\ny_t = \\mu_{\\text{seg}(t)} + \\varepsilon_t,\n$$\n其中 $\\varepsilon_t$ 是独立同分布、均值为零、方差恒定的高斯随机变量，而 $\\text{seg}(t)$ 将时间点 $t$ 映射到其所属段的索引。在此模型下，负对数似然函数在忽略一个加性常数的情况下，与误差平方和成正比\n$$\n\\sum_{t=1}^T \\left(y_t - \\mu_{\\text{seg}(t)}\\right)^2.\n$$\n对于一个固定的分段，每段均值 $\\mu_k$ 的最小二乘估计等于该段内样本的算术平均值。\n\n2. 均值中心化下的电池荷电状态动力学。定义电池荷电状态序列 $\\{s_t\\}_{t=0}^T$，其中 $s_0$ (单位为 kWh) 已知。在每段内部，定义均值中心化残差序列 $r_t = y_t - \\mu_{\\text{seg}(t)}$。状态演化如下\n$$\ns_t = s_{t-1} + r_t, \\quad t = 1,2,\\dots,T,\n$$\n因为每个 $r_t$ 是一小时内的净能量流。由于 $\\mu_{\\text{seg}(t)}$ 是其所在段的样本均值，所以在任何一个完整段内 $r_t$ 的总和等于 $0$，这意味着在该段结束时，$s_t$ 会返回到该段开始时的值。\n\n3. 物理约束。电池必须满足非负性和有限容量的约束：\n$$\n0 \\le s_t \\le C, \\quad t=0,1,\\dots,T,\n$$\n其中 $C$ 是电池容量，单位为 kWh。由于荷电状态在每段结束时都会返回到段起始值，因此一个分段相对于上述约束的可行性，简化为检查每一段内，以共同的起始水平 $s_0$ 为基础，加上均值中心化残差的部分和，在整个该段内是否保持在 $[0,C]$ 区间内。\n\n4. 模型选择准则。给定一个非负惩罚参数 $\\lambda$ (其单位与误差平方和相同)，考虑以下带惩罰的目标函数\n$$\nJ = \\sum_{t=1}^T \\left(y_t - \\mu_{\\text{seg}(t)}\\right)^2 + \\lambda\\cdot (K-1),\n$$\n该函数对变化点的数量进行惩罚 (变化点发生在任何索引 $t \\in \\{1,2,\\dots,T-1\\}$ 处，即新的一段从时间 $t+1$ 开始)。无约束最优分段是在所有可能的分段中最小化 $J$。有约束最优分段是在满足荷电状态路径相对于电池约束的逐段可行性条件下最小化 $J$。\n\n你的任务是：\n\nA. 基于高斯噪声假设和状态更新定义，推导逐段成本结构和逐段可行性条件。解释为什么对于最小二乘段均值，一段结束时的荷电状态等于该段开始时的荷电状态，并解释为什么这意味着可以使用共同的初始水平 $s_0$ 对每一段独立地检查可行性。\n\nB. 设计一个基于动态规划 (DP) 的算法来计算：\n- 最小化 $J$ 的无约束最优分段，\n- 在每段都强制执行可行性条件的情况下，最小化 $J$ 的有约束最优分段。\n\n你的 DP 必须：\n- 将总成本视为各段成本的累加和加上惩罚项，\n- 对于有约束的情况，将转移限制在那些从 $s_0$ 开始时，其均值中心化累积和能将荷电状态保持在 $[0,C]$ 区间内的段，\n- 重构变化点索引列表。时间点 $t$ 处的一个变化点意味着新的一段从 $t+1$ 开始，因此报告的索引必须位于 $\\{1,2,\\dots,T-1\\}$ 中。\n\nC. 将该算法实现为一个完整的、可运行的程序，该程序不接受用户输入，并为以下测试套件生成所需的输出。在所有情况下：\n- $y_t$ 以 kW 表示，\n- $s_0$ 和 $C$ 以 kWh 表示，\n- 采样间隔为 1 小时。\n\n测试套件：\n1. 案例 1 (均衡波动性，充足容量)：\n   - $y = [3.2, 3.3, 3.1, 3.4, 3.5, 3.4, 3.3, 3.2]$,\n   - $s_0 = 5.0$ kWh,\n   - $C = 10.0$ kWh,\n   - $\\lambda = 1.0$。\n\n2. 案例 2 (单调斜坡，容量紧张，对变化点有大的惩罚)：\n   - $y = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]$,\n   - $s_0 = 2.0$ kWh,\n   - $C = 3.0$ kWh,\n   - $\\lambda = 20.0$。\n\n3. 案例 3 (交替注入和取出，初始状态接近上限)：\n   - $y = [3, -1, 2, -2, 4, -3, 5, -4]$,\n   - $s_0 = 1.8$ kWh,\n   - $C = 2.0$ kWh,\n   - $\\lambda = 5.0$。\n\n最终输出规范：\n对于每个测试案例，你的程序必须输出一个包含四个项目的列表：\n- 无约束最优解中的段数 (一个整数)，\n- 无约束解的变化点索引列表 (一个由 $\\{1,2,\\dots,T-1\\}$ 中的整数组成的列表)，\n- 有约束最优解中的段数 (一个整数)，\n- 有约束解的变化点索引列表 (一个由 $\\{1,2,\\dots,T-1\\}$ 中的整数组成的列表)。\n\n你的程序应生成单行输出，其中包含所有案例的结果，以逗号分隔，并用方括号括起来。例如，格式必须为 $[r_1,r_2,r_3]$，其中每个 $r_i$ 是上述的四项列表。输出是无单位的索引和计数；不要在最后一行打印任何物理单位。确保程序为测试套件精确计算这些值，并只打印那一行输出。",
            "solution": "用户提供了一个科学上合理、定义明确且客观的问题陈述。它概述了在物理约束下对时间序列进行最优分段的形式化过程，这是信号处理和能源系统分析中的一个标准任务。该问题适合使用动态规划来解决。\n\n### A. 段成本结构与可行性条件\n\n问题要求通过最小化一个带惩罚的最小二乘目标函数，对时间序列 $\\{y_t\\}_{t=1}^T$ 进行最优分段，同时满足对派生出的荷电状态 (SOC) 序列 $\\{s_t\\}_{t=0}^T$ 的物理约束。\n\n**1. 逐段成本结构**\n\n需要最小化的目标函数由下式给出\n$$\nJ = \\sum_{t=1}^T \\left(y_t - \\mu_{\\text{seg}(t)}\\right)^2 + \\lambda \\cdot (K-1)\n$$\n其中 $K$ 是段数，$\\lambda$ 是一个惩罚参数。一个分段由一组变化点 $\\{\\tau_1, \\tau_2, \\dots, \\tau_{K-1}\\}$ 定义。这将时间索引 $\\{1, \\dots, T\\}$ 划分为 $K$ 个连续的段。设一个通用段的时间范围是从 $i$ 到 $j$。该段对 $J$ 的第一项的贡献是该段内的误差平方和 (SSE)。根据最小二乘准则，该段的最优均值 $\\mu_{i,j}$ 是样本均值：\n$$\n\\mu_{i,j} = \\frac{1}{j-i+1} \\sum_{t=i}^j y_t\n$$\n该段的成本，我们表示为 $C(i, j)$，即为：\n$$\nC(i, j) = \\sum_{t=i}^j (y_t - \\mu_{i,j})^2\n$$\n为了高效计算，可以展开此表达式：\n$$\nC(i, j) = \\sum_{t=i}^j y_t^2 - 2\\mu_{i,j} \\sum_{t=i}^j y_t + (j-i+1)\\mu_{i,j}^2\n$$\n代入 $\\mu_{i,j}$ 的表达式：\n$$\nC(i, j) = \\sum_{t=i}^j y_t^2 - 2 \\left(\\frac{\\sum_{t=i}^j y_t}{j-i+1}\\right) \\sum_{t=i}^j y_t + (j-i+1) \\left(\\frac{\\sum_{t=i}^j y_t}{j-i+1}\\right)^2\n$$\n$$\nC(i, j) = \\sum_{t=i}^j y_t^2 - \\frac{2(\\sum_{t=i}^j y_t)^2}{j-i+1} + \\frac{(\\sum_{t=i}^j y_t)^2}{j-i+1} = \\sum_{t=i}^j y_t^2 - \\frac{\\left(\\sum_{t=i}^j y_t\\right)^2}{j-i+1}\n$$\n这使得如果预先计算 $\\{y_t\\}$ 和 $\\{y_t^2\\}$ 的前缀和，任何段 $[i, j]$ 的成本都可以快速计算。对于一个具有变化点 $\\tau_0=0, \\tau_1, \\dots, \\tau_{K-1}, \\tau_K=T$ 的分段，总目标函数 $J$ 于是成为一个可加和：\n$$\nJ = \\left( \\sum_{k=1}^K C(\\tau_{k-1}+1, \\tau_k) \\right) + \\lambda(K-1)\n$$\n这种可加性结构是使用动态规划解决此问题的关键。\n\n**2. 荷电状态动力学与逐段可行性**\n\nSOC 按 $s_t = s_{t-1} + r_t$ 演化，其中 $r_t = y_t - \\mu_{\\text{seg}(t)}$ 是均值中心化残差。样本之间的时间间隔是 1 小时，因此功率 $y_t$ (kW) 在数值上等于该小时内的能量 (kWh)。\n\n考虑一个从时间 $i$ 到 $j$ 的段。该段结束时的 SOC $s_j$ 可以通过对更新量求和，与该段开始时的 SOC $s_{i-1}$ 关联起来：\n$$\ns_j = s_{i-1} + \\sum_{t=i}^j r_t = s_{i-1} + \\sum_{t=i}^j (y_t - \\mu_{i,j})\n$$\n根据样本均值 $\\mu_{i,j}$ 的定义，该段内的残差之和为零：\n$$\n\\sum_{t=i}^j (y_t - \\mu_{i,j}) = \\left(\\sum_{t=i}^j y_t\\right) - (j-i+1)\\mu_{i,j} = \\left(\\sum_{t=i}^j y_t\\right) - (j-i+1)\\frac{\\sum_{t=i}^j y_t}{j-i+1} = 0\n$$\n因此，$s_j = s_{i-1}$。任何完整段结束时的 SOC 都会返回到该段开始时的值。\n\n这一性质意味着任何段的起始 SOC 始终相同。如果第一段是 $[1, \\tau_1]$，其起始状态是 $s_0$。由于 $s_{\\tau_1} = s_0$，第二段 $[\\tau_1+1, \\tau_2]$ 也实际上以状态 $s_0$ 开始。通过归纳法，任何有效分段中的每一段都以等于全局初始状态 $s_0$ 的 SOC 开始。\n\n因此，整个分段的可行性可以逐段检查。一个提议的从时间 $i$到 $j$ 的段是可行的，当且仅当该段内的 SOC 路径保持在物理边界 $[0, C]$ 内。该段内任何时间 $k$ ($i \\le k \\le j$) 的 SOC 是：\n$$\ns_k = s_{i-1} + \\sum_{l=i}^k r_l = s_0 + \\sum_{l=i}^k (y_t - \\mu_{i,j})\n$$\n因此，段 $[i,j]$ 的可行性条件是：\n$$\n0 \\le s_0 + \\sum_{l=i}^k (y_t - \\mu_{i,j}) \\le C \\quad \\forall k \\in \\{i, i+1, \\dots, j\\}\n$$\n\n### B. 动态规划算法设计\n\n寻找最优分段的问题可以建模为在一个有向无环图中寻找最短路径，其中节点代表时间点，边代表段。\n\n**1. DP 公式化**\n\n令 $\\text{Opt}[t]$ 为子序列 $\\{y_1, \\dots, y_t\\}$ 的最优分段的最小惩罚成本。我们的目标是计算 $\\text{Opt}[T]$。\n基例是空序列，其成本为 $0$。为了正确计算惩罚项 $\\lambda(K-1)$（这是对*变化点*数量的惩罚），我们设置 $\\text{Opt}[0] = -\\lambda$。\n\n对于 $t > 0$，$\\text{Opt}[t]$ 的递推关系通过考虑前一段所有可能的终点来推导。如果最后一段是 $[j+1, t]$ (对于 $0 \\le j < t$)，总成本是子序列 $\\{y_1, \\dots, y_j\\}$ 的最优成本，加上新段 $C(j+1,t)$ 的成本，再加上在 $j$ 处新变化点的惩罚 $\\lambda$。\n$$\n\\text{Opt}[t] = \\min_{0 \\le j < t} \\{ \\text{Opt}[j] + C(j+1, t) + \\lambda \\}\n$$\n基例 $\\text{Opt}[0] = -\\lambda$ 确保了对于第一段 $[1,t]$ (对应于 $j=0$)，成本被正确计算为 $\\text{Opt}[0] + C(1,t) + \\lambda = -\\lambda + C(1,t) + \\lambda = C(1,t)$，这段有 $K-1=0$ 个变化点，因此没有惩罚。\n\n为了重构分段，我们维护一个指针数组 $\\text{Pointers}[t]$，它存储产生 $\\text{Opt}[t]$ 最小成本的索引 $j$。\n\n**2. 无约束与有约束算法**\n\nDP 框架优雅地处理了这两种情况。\n\n*   **无约束情况**：算法完全按照递推关系进行。在每一步 $t$，它遍历所有可能的前一个变化点 $j$，并找到使总成本最小化的那一个。\n\n*   **有约束情况**：通过一个可行性检查来修改递推关系。当考虑一个潜在的最后一段 $[j+1, t]$ 时，我们首先计算其均值 $\\mu_{j+1,t}$，然后根据 A 部分推导的条件检查该段是否可行。\n    $$\n    0 \\le s_0 + \\sum_{l=j+1}^k (y_l - \\mu_{j+1,t}) \\le C \\quad \\forall k \\in \\{j+1, \\dots, t\\}\n    $$\n    如果该段不可行，则不允许。这可以通过为从 $j$到 $t$ 的转移分配无限大的成本来实现。递推关系实际上变为：\n    $$\n    \\text{Opt}[t] = \\min_{0 \\le j < t, \\text{段 }[j+1, t]\\text{ 可行}} \\{ \\text{Opt}[j] + C(j+1, t) + \\lambda \\}\n    $$\n\n**3. 算法步骤**\n\n1.  **初始化**：给定长度为 $T$ 的时间序列 $\\{y_t\\}_{t=1}^T$。\n    *   为 $\\{y_t\\}$ 和 $\\{y_t^2\\}$ 创建前缀和数组，以便 $O(1)$ 时间内计算 $C(i, j)$。\n    *   初始化一个大小为 $T+1$ 的成本数组 `dp_costs`，所有元素设为 $\\infty$，并设置 `dp_costs[0] = -lambda`。\n    *   初始化一个大小为 $T+1$ 的指针数组 `dp_pointers`。\n\n2.  **DP 计算**：\n    *   对于 $t$ 从 $1$ 到 $T$：\n        *   对于 $j$ 从 $0$ 到 $t-1$：\n            *   计算从时间 $j+1$ 到 $t$ 的段的成本 $C(j+1, t)$。\n            *   **若为有约束情况**：检查此段的可行性。如果不可行，则继续下一个 $j$。\n            *   计算总成本： `new_cost = dp_costs[j] + C(j+1, t) + lambda`。\n            *   如果 `new_cost < dp_costs[t]`，则更新 `dp_costs[t] = new_cost` 和 `dp_pointers[t] = j`。\n\n3.  **路径重构**：\n    *   初始化一个空的变化点列表。\n    *   从 `curr = T` 开始。\n    *   当 `curr > 0` 时：\n        *   获取前一个变化点索引 `prev = dp_pointers[curr]`。\n        *   如果 `prev > 0`，将 `prev` 添加到变化点列表 (因为这对应于在时间 `prev` 处的一个变化点)。\n        *   设置 `curr = prev`。\n    *   反转变化点列表，使它们按时间顺序排列。段的数量等于 $1$ 加上变化点的数量。\n\n对无约束情况和有约束情况各执行一次此过程，以获得每个测试场景所需的四个输出。",
            "answer": "```python\nimport numpy as np\n\ndef _find_segmentation(y, s0, C, lambda_val, constrained):\n    \"\"\"\n    Finds the optimal segmentation using dynamic programming.\n    \n    Args:\n        y (np.ndarray): The time series data.\n        s0 (float): Initial state of charge.\n        C (float): Battery capacity.\n        lambda_val (float): Penalty parameter for change points.\n        constrained (bool): If True, enforce SOC constraints.\n\n    Returns:\n        tuple[int, list[int]]: Number of segments and list of change point indices.\n    \"\"\"\n    T = len(y)\n    \n    # Precompute prefix sums for y and y^2 for O(1) cost calculation.\n    # We use 1-based indexing for sums to align with math notation.\n    S1 = np.zeros(T + 1)\n    S2 = np.zeros(T + 1)\n    for i in range(T):\n        S1[i+1] = S1[i] + y[i]\n        S2[i+1] = S2[i] + y[i]**2\n        \n    def get_segment_cost(j, t):\n        \"\"\"Calculates sum of squared errors for segment y[j...t-1].\"\"\"\n        # Segment corresponds to time steps j+1 to t.\n        # Python indices are j to t-1.\n        length = t - j\n        if length == 0:\n            return 0\n        sum_y = S1[t] - S1[j]\n        sum_y_sq = S2[t] - S2[j]\n        cost = sum_y_sq - (sum_y ** 2) / length\n        return cost\n\n    # DP state: dp_costs[t] = min cost for segmenting y[0...t-1]\n    dp_costs = np.full(T + 1, np.inf)\n    dp_pointers = np.zeros(T + 1, dtype=int)\n    \n    # Base case: cost for empty sequence is 0.\n    # The -lambda term correctly handles the penalty count (K-1).\n    dp_costs[0] = -lambda_val\n    \n    for t in range(1, T + 1):\n        for j in range(t):\n            # Potential segment is y[j...t-1], corresponding to times j+1 to t\n            \n            if constrained:\n                segment_data = y[j:t]\n                length = len(segment_data)\n                \n                # If segment is empty, skip\n                if length == 0:\n                    continue\n                \n                mean = np.mean(segment_data)\n                residuals = segment_data - mean\n                cum_residuals = np.cumsum(residuals)\n                \n                # SOC path for this segment, starting from s0\n                soc_path = s0 + cum_residuals\n                \n                # Feasibility check: 0 <= s_t <= C for all t in segment\n                if np.any(soc_path < 0) or np.any(soc_path > C):\n                    continue  # This segment is infeasible, skip\n\n            cost = get_segment_cost(j, t)\n            total_cost = dp_costs[j] + cost + lambda_val\n            \n            if total_cost < dp_costs[t]:\n                dp_costs[t] = total_cost\n                dp_pointers[t] = j\n\n    # Reconstruct the path\n    changepoints = []\n    curr = T\n    while curr > 0:\n        prev = dp_pointers[curr]\n        if prev > 0:\n            # Change point at time `prev` (1-based index)\n            changepoints.append(prev)\n        curr = prev\n        \n    changepoints.sort()\n    num_segments = len(changepoints) + 1\n    \n    return num_segments, changepoints\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and format output.\n    \"\"\"\n    test_cases = [\n        {\n            \"y\": np.array([3.2, 3.3, 3.1, 3.4, 3.5, 3.4, 3.3, 3.2]),\n            \"s0\": 5.0,\n            \"C\": 10.0,\n            \"lambda\": 1.0\n        },\n        {\n            \"y\": np.array([0., 1., 2., 3., 4., 5., 6., 7., 8., 9.]),\n            \"s0\": 2.0,\n            \"C\": 3.0,\n            \"lambda\": 20.0\n        },\n        {\n            \"y\": np.array([3., -1., 2., -2., 4., -3., 5., -4.]),\n            \"s0\": 1.8,\n            \"C\": 2.0,\n            \"lambda\": 5.0\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        y, s0, C, lambda_val = case[\"y\"], case[\"s0\"], case[\"C\"], case[\"lambda\"]\n        \n        k_unc, cp_unc = _find_segmentation(y, s0, C, lambda_val, constrained=False)\n        k_con, cp_con = _find_segmentation(y, s0, C, lambda_val, constrained=True)\n        \n        all_results.append([k_unc, cp_unc, k_con, cp_con])\n\n    # Manually format the output string to be compact (no spaces)\n    result_strings = []\n    for res in all_results:\n        k_u, cp_u, k_c, cp_c = res\n        cp_u_str = '[' + ','.join(map(str, cp_u)) + ']'\n        cp_c_str = '[' + ','.join(map(str, cp_c)) + ']'\n        res_str = f\"[{k_u},{cp_u_str},{k_c},{cp_c_str}]\"\n        result_strings.append(res_str)\n    \n    final_output = '[' + ','.join(result_strings) + ']'\n    print(final_output)\n\nsolve()\n\n```"
        }
    ]
}