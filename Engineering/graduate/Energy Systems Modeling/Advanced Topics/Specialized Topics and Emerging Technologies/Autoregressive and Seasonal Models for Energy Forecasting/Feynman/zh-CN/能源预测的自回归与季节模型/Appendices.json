{
    "hands_on_practices": [
        {
            "introduction": "掌握了自回归模型的基础知识后，首要的实践任务是从第一性原理出发，计算点预测。本练习旨在通过一个简单的二阶自回归 (AR(2)) 模型，计算一步超前预测。此练习将巩固你对最小均方误差（MMSE）预测即条件期望的理解，并让你亲手实践如何利用已知信息来预测时间序列的未来值。",
            "id": "4070510",
            "problem": "一个独立系统运营商（ISO）将去季节性的小时净负荷异常建模为一个二阶自回归（AR）模型。具体来说，在移除确定性的日季节性分量和长期均值后，残差过程 $\\{y_t\\}$ 被假定满足\n$$\ny_t \\;=\\; \\phi_1 y_{t-1} \\;+\\; \\phi_2 y_{t-2} \\;+\\; \\epsilon_t,\n$$\n其中 $\\{\\epsilon_t\\}$ 是一个零均值、序列不相关的创新过程，具有恒定方差 $\\sigma_{\\epsilon}^{2}$，并且独立于由过去观测值生成的信息集。给定系数 $\\phi_1 = 0.84$，$\\phi_2 = -0.27$，最近的两个残差观测值 $y_t = 17.9$ 和 $y_{t-1} = -11.8$（单位为兆瓦），以及创新方差 $\\sigma_{\\epsilon}^{2} = 16$。\n\n仅使用自回归（AR）过程的定义和创新过程的性质，从第一性原理推导在给定截至时间 $t$ 的信息下，$y_{t+1}$ 的单步最小均方误差预测 $\\hat{y}_{t+1|t}$。用 $\\phi_1$、$\\phi_2$、$y_t$ 和 $y_{t-1}$ 明确写出预测公式，然后用所提供的值进行数值计算。\n\n将最终预测值报告为单个数字，单位为兆瓦（MW），四舍五入到四位有效数字。最终答案以兆瓦表示。",
            "solution": "首先对问题陈述进行验证过程。\n\n### 步骤 1：提取给定信息\n-   **模型类型**：二阶自回归（AR）模型。\n-   **过程方程**：$y_t = \\phi_1 y_{t-1} + \\phi_2 y_{t-2} + \\epsilon_t$。\n-   **过程 $\\{y_t\\}$**：去季节性的小时净负荷异常残差过程。\n-   **创新过程 $\\{\\epsilon_t\\}$**：零均值、序列不相关、恒定方差 $\\sigma_{\\epsilon}^{2}$，并且独立于由过去观测值生成的信息集。\n-   **系数 $\\phi_1$**：$0.84$。\n-   **系数 $\\phi_2$**：$-0.27$。\n-   **近期观测值 $y_t$**：$17.9$（单位：兆瓦）。\n-   **过去观测值 $y_{t-1}$**：$-11.8$（单位：兆瓦）。\n-   **创新方差 $\\sigma_{\\epsilon}^{2}$**：$16$。\n-   **目标**：在给定截至时间 $t$ 的信息下，推导 $y_{t+1}$ 的单步最小均方误差（MMSE）预测 $\\hat{y}_{t+1|t}$。提供明确的公式并进行数值计算，结果四舍五入到四位有效数字。\n\n### 步骤 2：使用提取的给定信息进行验证\n1.  **科学依据**：该问题基于自回归模型，这是时间序列分析中一个标准和基本概念，广泛应用于计量经济学、信号处理和能源系统建模等领域。该设定在科学上是合理的。\n2.  **适定性**：该问题是适定的。它要求计算最小均方误差预测，这唯一定义为条件期望。计算此预测所需的所有数据（$\\phi_1$、$\\phi_2$、$y_t$、$y_{t-1}$）均已提供。AR(2)过程的平稳性条件，$|\\phi_2|  1$、$\\phi_1 + \\phi_2  1$ 和 $\\phi_2 - \\phi_1  1$，均被给定系数满足（$|-0.27|  1$；$0.84 - 0.27 = 0.57  1$；$-0.27 - 0.84 = -1.11  1$），确保该模型描述了一个稳定的物理过程。\n3.  **目标**：问题以精确、定量的术语陈述，没有歧义或主观性。\n4.  **完整性和一致性**：该问题是自洽且一致的。它提供了点预测所需的所有必要参数。创新方差 $\\sigma_{\\epsilon}^{2}=16$ 的包含对于点预测本身不是必需的，但对于计算预测误差方差或置信区间至关重要，它的存在并不构成矛盾。\n5.  **现实性**：所选的系数和观测值对于建模能源系统中的异常现象具有现实的量级。\n\n### 步骤 3：结论与行动\n问题有效。我们可以继续进行求解。\n\n### 推导与求解\n目标是求出在给定截至时间 $t$ 的可用信息下，过程 $y_t$ 在时间 $t+1$ 的单步最小均方误差（MMSE）预测。设时间 $t$ 的信息集表示为 $\\mathcal{I}_t = \\{y_t, y_{t-1}, \\dots\\}$。最小均方误差预测 $\\hat{y}_{t+1|t}$ 定义为 $y_{t+1}$ 在给定 $\\mathcal{I}_t$ 下的条件期望。\n$$\n\\hat{y}_{t+1|t} = E[y_{t+1} | \\mathcal{I}_t]\n$$\n二阶自回归模型 AR(2) 由以下方程定义：\n$$\ny_t = \\phi_1 y_{t-1} + \\phi_2 y_{t-2} + \\epsilon_t\n$$\n为了找到时间 $t+1$ 的预测，我们将模型方程中的时间索引向前推进一个步长：\n$$\ny_{t+1} = \\phi_1 y_t + \\phi_2 y_{t-1} + \\epsilon_{t+1}\n$$\n现在，我们对这个表达式取关于信息集 $\\mathcal{I}_t$ 的条件期望：\n$$\nE[y_{t+1} | \\mathcal{I}_t] = E[\\phi_1 y_t + \\phi_2 y_{t-1} + \\epsilon_{t+1} | \\mathcal{I}_t]\n$$\n根据期望算子的线性性质，我们可以将右侧的各项分开：\n$$\nE[y_{t+1} | \\mathcal{I}_t] = E[\\phi_1 y_t | \\mathcal{I}_t] + E[\\phi_2 y_{t-1} | \\mathcal{I}_t] + E[\\epsilon_{t+1} | \\mathcal{I}_t]\n$$\n我们逐项评估：\n1.  系数 $\\phi_1$ 和 $\\phi_2$ 是已知常数。过程 $y_t$ 和 $y_{t-1}$ 的值在时间 $t$ 是已知的，意味着它们包含在信息集 $\\mathcal{I}_t$ 中。已知量在已知条件下的期望就是该量本身。\n    $$\n    E[\\phi_1 y_t | \\mathcal{I}_t] = \\phi_1 y_t\n    $$\n    $$\n    E[\\phi_2 y_{t-1} | \\mathcal{I}_t] = \\phi_2 y_{t-1}\n    $$\n2.  项 $\\epsilon_{t+1}$ 是时间 $t+1$ 的创新。问题陈述中说明 $\\{\\epsilon_t\\}$ 是一个独立于过去观测值所生成信息集的创新过程。这意味着截至时间 $t$ 的信息对 $\\epsilon_{t+1}$ 的实现不提供任何信息。因此，$\\epsilon_{t+1}$ 的条件期望等于其无条件期望。\n    $$\n    E[\\epsilon_{t+1} | \\mathcal{I}_t] = E[\\epsilon_{t+1}]\n    $$\n    此外，问题明确指出 $\\{\\epsilon_t\\}$ 是一个零均值过程。因此，其无条件期望为零。\n    $$\n    E[\\epsilon_{t+1}] = 0\n    $$\n将这些结果代回预测方程，我们得到单步预测的显式公式：\n$$\n\\hat{y}_{t+1|t} = \\phi_1 y_t + \\phi_2 y_{t-1} + 0\n$$\n$$\n\\hat{y}_{t+1|t} = \\phi_1 y_t + \\phi_2 y_{t-1}\n$$\n这就是所要求的一般预测公式。现在我们代入给定的数值：$\\phi_1 = 0.84$，$\\phi_2 = -0.27$，$y_t = 17.9$ 和 $y_{t-1} = -11.8$。\n$$\n\\hat{y}_{t+1|t} = (0.84)(17.9) + (-0.27)(-11.8)\n$$\n对每一项进行乘法运算：\n$$\n(0.84)(17.9) = 15.036\n$$\n$$\n(-0.27)(-11.8) = 3.186\n$$\n将这些值相加得到预测值：\n$$\n\\hat{y}_{t+1|t} = 15.036 + 3.186 = 18.222\n$$\n问题要求最终答案四舍五入到四位有效数字。计算值为 $18.222$。四位有效数字是 $1$、$8$、$2$ 和 $2$。第五位数字是 $2$，所以我们不对最后一位有效数字进行进位。\n最终预测值为 $18.22$ 兆瓦。",
            "answer": "$$\\boxed{18.22}$$"
        },
        {
            "introduction": "在能源预测的实际应用中，我们常常需要处理带有季节性成分的复杂模型，并进行多步预测。本练习将挑战升级，要求你为一个季节性自回归积分移动平均（SARIMA）模型计算两步超前预测。通过这个练习，你将学会如何展开和处理包含常规与季节性成分的滞后多项式，并推导递归关系式来生成预测，这是能源需求预测等实际任务中的核心技能。",
            "id": "4070541",
            "problem": "考虑一个小型岛屿电网的小时用电需求 $\\{y_t\\}$，其由一个具有日季节性的季节性自回归积分移动平均 (SARIMA) 过程建模。拟合的模型为 SARIMA$(1,0,1)\\times(0,1,1)_{24}$，季节周期 $s=24$，并满足滞后多项式方程\n$$(1-\\phi_1 B)\\,(1-B^{24})\\,y_t \\;=\\; (1+\\theta_1 B)\\,(1+\\Theta_1 B^{24})\\,\\epsilon_t,$$\n其中 $B$ 是滞后算子，$\\epsilon_t$ 是一个零均值、序列不相关的创新项，$\\phi_1$、$\\theta_1$、$\\Theta_1$ 是从数据中估计的固定参数。设拟合参数为 $\\phi_1=0.85$，$\\theta_1=-0.25$，$\\Theta_1=0.40$。给定以下最近的观测值和残差（单位均为兆瓦，MW）：$y_T=1520$，$y_{T-24}=1480$，$y_{T-23}=1490$，$y_{T-22}=1510$，$\\epsilon_T=-5$，$\\epsilon_{T-24}=3$，$\\epsilon_{T-23}=1$ 以及 $\\epsilon_{T-22}=-2$。假设未来的创新项对于所有 $h\\geq 1$ 均满足 $\\mathbb{E}[\\epsilon_{T+h} \\mid \\mathcal{F}_T]=0$，其中 $\\mathcal{F}_T$ 是截至时间 $T$ 的信息集。\n\n从季节性差分和线性时间序列模型的核心定义出发，使用给定的滞后多项式和过去的残差推导条件均值的递归关系，并计算两步向前预测 $\\widehat{y}_{T+2\\mid T}$。将最终答案四舍五入至四位有效数字。以兆瓦 (MW) 为单位表示预测值。",
            "solution": "该问题经核实具有科学依据，提法恰当，客观且完整。计算所需预测值的所有必要参数和数据均已提供。SARIMA 模型是时间序列分析中用于预测季节性数据的标准框架。\n\n问题陈述了小时用电需求 $\\{y_t\\}$ 由一个季节周期 $s=24$ 的 SARIMA$(1,0,1)\\times(0,1,1)_{24}$ 模型描述。其主导的滞后多项式方程为：\n$$ (1-\\phi_1 B)\\,(1-B^{24})\\,y_t \\;=\\; (1+\\theta_1 B)\\,(1+\\Theta_1 B^{24})\\,\\epsilon_t $$\n其中 $B$ 是滞后算子，使得 $B^k y_t = y_{t-k}$，而 $\\epsilon_t$ 是一个零均值、序列不相关的创新过程。\n\n我们首先展开滞后多项式，以便用其过去的值和创新项来表示 $y_t$。\n左侧 (LHS) 为：\n$$ (1-\\phi_1 B - B^{24} + \\phi_1 B^{25})y_t = y_t - \\phi_1 y_{t-1} - y_{t-24} + \\phi_1 y_{t-25} $$\n右侧 (RHS) 为：\n$$ (1+\\theta_1 B + \\Theta_1 B^{24} + \\theta_1 \\Theta_1 B^{25})\\epsilon_t = \\epsilon_t + \\theta_1 \\epsilon_{t-1} + \\Theta_1 \\epsilon_{t-24} + \\theta_1 \\Theta_1 \\epsilon_{t-25} $$\n令 LHS 和 RHS 相等，并求解 $y_t$，得到该过程的显式表达式：\n$$ y_t = \\phi_1 y_{t-1} + y_{t-24} - \\phi_1 y_{t-25} + \\epsilon_t + \\theta_1 \\epsilon_{t-1} + \\Theta_1 \\epsilon_{t-24} + \\theta_1 \\Theta_1 \\epsilon_{t-25} $$\n在时间 $T$ 的 $h$ 步向前预测，记为 $\\widehat{y}_{T+h\\mid T}$，是在截至时间 $T$ 的信息集 $\\mathcal{F}_T$ 条件下 $y_{T+h}$ 的条件期望：\n$$ \\widehat{y}_{T+h\\mid T} = \\mathbb{E}[y_{T+h} \\mid \\mathcal{F}_T] $$\n给定未来创新项的条件期望为零：对于 $k > 0$，$\\mathbb{E}[\\epsilon_{T+k} \\mid \\mathcal{F}_T] = 0$。对于 $k \\le 0$，$\\epsilon_{T+k}$ 是信息集 $\\mathcal{F}_T$ 的一部分，因此 $\\mathbb{E}[\\epsilon_{T+k} \\mid \\mathcal{F}_T] = \\epsilon_{T+k}$。类似地，对于 $k \\le 0$，$\\mathbb{E}[y_{T+k} \\mid \\mathcal{F}_T] = y_{T+k}$；对于 $k > 0$，$\\mathbb{E}[y_{T+k} \\mid \\mathcal{F}_T] = \\widehat{y}_{T+k\\mid T}$。\n\n我们的目标是计算 $\\widehat{y}_{T+2\\mid T}$。我们必须首先计算一步向前预测 $\\widehat{y}_{T+1\\mid T}$。\n当 $t=T+1$ 时，$y_{T+1}$ 的方程为：\n$$ y_{T+1} = \\phi_1 y_{T} + y_{T-23} - \\phi_1 y_{T-24} + \\epsilon_{T+1} + \\theta_1 \\epsilon_{T} + \\Theta_1 \\epsilon_{T-23} + \\theta_1 \\Theta_1 \\epsilon_{T-24} $$\n取关于 $\\mathcal{F}_T$ 的条件期望：\n$$ \\widehat{y}_{T+1\\mid T} = \\mathbb{E}[y_{T+1} \\mid \\mathcal{F}_T] = \\phi_1 y_{T} + y_{T-23} - \\phi_1 y_{T-24} + \\mathbb{E}[\\epsilon_{T+1} \\mid \\mathcal{F}_T] + \\theta_1 \\epsilon_{T} + \\Theta_1 \\epsilon_{T-23} + \\theta_1 \\Theta_1 \\epsilon_{T-24} $$\n使用 $\\mathbb{E}[\\epsilon_{T+1} \\mid \\mathcal{F}_T]=0$，我们得到：\n$$ \\widehat{y}_{T+1\\mid T} = \\phi_1 y_{T} + y_{T-23} - \\phi_1 y_{T-24} + \\theta_1 \\epsilon_{T} + \\Theta_1 \\epsilon_{T-23} + \\theta_1 \\Theta_1 \\epsilon_{T-24} $$\n给定的参数值为 $\\phi_1=0.85$，$\\theta_1=-0.25$，以及 $\\Theta_1=0.40$。MA 参数的乘积是 $\\theta_1 \\Theta_1 = (-0.25)(0.40) = -0.10$。\n给定的数据为：$y_T=1520$，$y_{T-23}=1490$，$y_{T-24}=1480$，$\\epsilon_T=-5$，$\\epsilon_{T-23}=1$ 以及 $\\epsilon_{T-24}=3$。\n代入这些值：\n$$ \\widehat{y}_{T+1\\mid T} = (0.85)(1520) + 1490 - (0.85)(1480) + (-0.25)(-5) + (0.40)(1) + (-0.10)(3) $$\n$$ \\widehat{y}_{T+1\\mid T} = 1292 + 1490 - 1258 + 1.25 + 0.40 - 0.30 $$\n$$ \\widehat{y}_{T+1\\mid T} = 1524 + 1.35 = 1525.35 $$\n现在我们继续计算两步向前预测 $\\widehat{y}_{T+2\\mid T}$。当 $t=T+2$ 时，$y_{T+2}$ 的方程为：\n$$ y_{T+2} = \\phi_1 y_{T+1} + y_{T-22} - \\phi_1 y_{T-23} + \\epsilon_{T+2} + \\theta_1 \\epsilon_{T+1} + \\Theta_1 \\epsilon_{T-22} + \\theta_1 \\Theta_1 \\epsilon_{T-23} $$\n取关于 $\\mathcal{F}_T$ 的条件期望：\n$$ \\widehat{y}_{T+2\\mid T} = \\mathbb{E}[y_{T+2} \\mid \\mathcal{F}_T] = \\phi_1 \\mathbb{E}[y_{T+1} \\mid \\mathcal{F}_T] + y_{T-22} - \\phi_1 y_{T-23} + \\mathbb{E}[\\epsilon_{T+2} \\mid \\mathcal F_T] + \\theta_1 \\mathbb{E}[\\epsilon_{T+1} \\mid \\mathcal F_T] + \\Theta_1 \\epsilon_{T-22} + \\theta_1 \\Theta_1 \\epsilon_{T-23} $$\n使用 $\\mathbb{E}[\\epsilon_{T+2} \\mid \\mathcal F_T] = 0$、$\\mathbb{E}[\\epsilon_{T+1} \\mid \\mathcal F_T] = 0$ 以及 $\\mathbb{E}[y_{T+1} \\mid \\mathcal{F}_T] = \\widehat{y}_{T+1\\mid T}$，我们得到递归预测方程：\n$$ \\widehat{y}_{T+2\\mid T} = \\phi_1 \\widehat{y}_{T+1\\mid T} + y_{T-22} - \\phi_1 y_{T-23} + \\Theta_1 \\epsilon_{T-22} + \\theta_1 \\Theta_1 \\epsilon_{T-23} $$\n我们使用先前计算出的值 $\\widehat{y}_{T+1\\mid T}=1525.35$ 以及额外给定的数据：$y_{T-22}=1510$，$y_{T-23}=1490$，$\\epsilon_{T-22}=-2$ 以及 $\\epsilon_{T-23}=1$。将这些值代入 $\\widehat{y}_{T+2\\mid T}$ 的方程中：\n$$ \\widehat{y}_{T+2\\mid T} = (0.85)(1525.35) + 1510 - (0.85)(1490) + (0.40)(-2) + (-0.10)(1) $$\n$$ \\widehat{y}_{T+2\\mid T} = 1296.5475 + 1510 - 1266.5 - 0.80 - 0.10 $$\n$$ \\widehat{y}_{T+2\\mid T} = 2806.5475 - 1266.5 - 0.90 $$\n$$ \\widehat{y}_{T+2\\mid T} = 1540.0475 - 0.90 = 1539.1475 $$\n问题要求将最终答案四舍五入至四位有效数字。值 $1539.1475$ 四舍五入至四位有效数字是 $1539$。\n在时间 $T$ 之后两小时的电力需求预测值为 $1539$ MW。",
            "answer": "$$ \\boxed{1539} $$"
        },
        {
            "introduction": "除了传统的递归预测方法，状态空间表示法为时间序列分析提供了更强大和灵活的框架。本练习将引导你将一个SARIMA模型转化为等价的线性高斯状态空间形式，并使用卡尔曼滤波器（Kalman filter）进行状态估计和似然计算。通过这个高级编程练习，你不仅能掌握一种现代的建模与估计算法，还能深入理解模型似然的构成，这对于模型选择和参数估计至关重要。",
            "id": "4070543",
            "problem": "给定一个线性高斯状态空间模型，该模型表示经过适当差分后用于能源需求预测的季节性自回归积分移动平均 (SARIMA) 过程。潜状态是差分后的负荷，季节性效应由状态转移中的滞后-$s$自回归捕获。将差分后的潜过程表示为 $w_t$。模型定义如下。状态向量 $x_t \\in \\mathbb{R}^s$ 将 $w_t$ 的近期值堆叠为\n$$\nx_t = \\begin{bmatrix} w_t \\\\ w_{t-1} \\\\ \\vdots \\\\ w_{t-s+1} \\end{bmatrix},\n$$\n其状态转移由下式给出\n$$\nx_{t+1} = F x_t + G \\xi_{t+1}, \\quad \\xi_{t+1} \\sim \\mathcal{N}(0,q),\n$$\n观测方程为\n$$\ny_t = H x_t + v_t, \\quad v_t \\sim \\mathcal{N}(0,r).\n$$\n此处，$F \\in \\mathbb{R}^{s \\times s}$ 是类伴随矩阵\n$$\nF = \\begin{bmatrix}\n\\phi   0   \\cdots   0   \\Phi \\\\\n1   0   \\cdots   0   0 \\\\\n0   1   \\ddots   0   0 \\\\\n\\vdots   \\ddots   \\ddots   \\ddots   \\vdots \\\\\n0   \\cdots   0   1   0\n\\end{bmatrix},\n$$\n$G \\in \\mathbb{R}^{s \\times 1}$ 等于 $G = [1, 0, \\ldots, 0]^\\top$，$H \\in \\mathbb{R}^{1 \\times s}$ 等于 $H = [1, 0, \\ldots, 0]$，$\\phi \\in \\mathbb{R}$ 是非季节性自回归系数，而 $\\Phi \\in \\mathbb{R}$ 是滞后 $s$ 的季节性自回归系数。过程噪声方差为 $q > 0$，观测噪声方差为 $r > 0$。该结构是用于差分负荷的季节性自回归积分移动平均 (SARIMA) 的标准状态空间嵌入，其中潜动态是季节性自回归，测量值受到高斯观测噪声的污染。\n\n使用 $a_{0|0} = \\mathbb{E}[x_0] = \\mathbf{0} \\in \\mathbb{R}^s$ 和 $P_{0|0} = \\sigma_0^2 I_s$ 初始化滤波器，其中 $I_s$ 是 $s \\times s$ 的单位矩阵，$\\sigma_0^2 > 0$ 是给定的扩散方差。对于每个时间 $t$，定义一步预测 $a_{t|t-1} = \\mathbb{E}[x_t \\mid y_{1:t-1}]$，其协方差 $P_{t|t-1} = \\operatorname{Cov}(x_t \\mid y_{1:t-1})$，观测值的一步预测 $y_{t|t-1} = H a_{t|t-1}$，一步预测误差 $e_t = y_t - y_{t|t-1}$，以及预测误差方差 $S_t = H P_{t|t-1} H^\\top + r$。使用用于线性高斯系统的最优线性滤波器计算滤波状态 $a_{t|t} = \\mathbb{E}[x_t \\mid y_{1:t}]$ 及其协方差 $P_{t|t}$，以及增量高斯对数似然\n$$\n\\ell_t = -\\frac{1}{2}\\left( \\log(2\\pi) + \\log S_t + \\frac{e_t^2}{S_t} \\right).\n$$\n\n任务：实现一个程序，对于指定的 $s$、$\\phi$、$\\Phi$、$q$、$r$、$\\sigma_0^2$ 值以及给定的观测序列 $\\{y_t\\}_{t=1}^T$，执行以下操作：\n- 计算滤波状态估计 $\\{a_{t|t}\\}_{t=1}^T$、一步预测误差 $\\{e_t\\}_{t=1}^T$ 和增量对数似然 $\\{\\ell_t\\}_{t=1}^T$。\n- 对于每个测试用例，输出总对数似然 $\\sum_{t=1}^T \\ell_t$、最后一步预测误差 $e_T$ 以及最终滤波状态估计的第一个分量 $a_{T|T}^{(1)}$。\n\n使用以下测试套件（所有序列均无量纲；不涉及物理单位）：\n- 测试用例 1（每日季节性，每小时差分序列）：\n    - $s = 24$，$\\phi = 0.5$，$\\Phi = 0.3$，$q = 0.2$，$r = 0.1$，$\\sigma_0^2 = 10$，\n    - $T = 36$，\n    - $y_{1:36} = [0.2, 0.5, 0.1, -0.1, 0.3, 0.6, 0.4, 0.9, 1.2, 0.8, 0.2, -0.2, 0.0, 0.3, 0.7, 0.6, 0.2, 0.4, 0.1, 0.0, 0.5, 0.8, 1.0, 0.9, 0.3, 0.2, 0.1, 0.0, 0.4, 0.5, 0.7, 1.1, 1.0, 0.6, 0.3, 0.2]$。\n- 测试用例 2（短季节性，接近单位根的非季节性自回归）：\n    - $s = 4$，$\\phi = 0.95$，$\\Phi = 0.0$，$q = 10^{-6}$，$r = 0.05$，$\\sigma_0^2 = 10$，\n    - $T = 12$，\n    - $y_{1:12} = [0.0, 0.1, 0.2, 0.4, 0.6, 0.9, 1.3, 1.6, 1.8, 2.0, 2.2, 2.3]$。\n- 测试用例 3（每月季节性，具有较大测量噪声的强季节性自回归）：\n    - $s = 12$，$\\phi = 0.2$，$\\Phi = 0.8$，$q = 0.01$，$r = 0.5$，$\\sigma_0^2 = 10$，\n    - $T = 24$，\n    - $y_{1:24} = [1.0, 0.8, 0.7, 0.6, 0.5, 0.6, 0.7, 0.9, 1.2, 1.5, 1.8, 2.0, 1.1, 0.9, 0.8, 0.7, 0.6, 0.7, 0.8, 1.0, 1.3, 1.6, 1.9, 2.1]$。\n\n最终输出格式：您的程序应生成一行输出，其中包含结果，形式为一个逗号分隔的列表，包含三个列表，每个列表对应一个测试用例，格式如下\n$$\n\\text{[ [$LL_1, e_T^{(1)}, a_{T|T}^{(1,1)}$], [$LL_2, e_T^{(2)}, a_{T|T}^{(2,1)}$], [$LL_3, e_T^{(3)}, a_{T|T}^{(3,1)}$] ]},\n$$\n其中 $LL_i$ 是测试用例 $i$ 的总对数似然，$e_T^{(i)}$ 是最后一步预测误差，$a_{T|T}^{(i,1)}$ 是测试用例 $i$ 的最终滤波状态向量的第一个分量。将所有值打印为单行上的十进制浮点数，小数点后保留六位数字，完全按照所示用方括号括起来，不含任何附加文本。",
            "solution": "用户提供的问题陈述已经过验证，并被认为是有效的。它具有科学依据，问题定义明确，客观且自洽，展示了卡尔曼滤波器在线性高斯状态空间模型（代表 SARIMA 过程）上的标准应用。所有必要的参数、方程和数据均已提供。\n\n任务是实现卡尔曼滤波器来估计时间序列模型的潜状态。该模型是一个线性高斯状态空间模型，卡尔曼滤波器为此提供了状态的最优（在均方误差意义上）估计。该模型由一个状态转移方程和一个观测方程定义。\n\n时间 $t$ 的状态向量是 $x_t \\in \\mathbb{R}^s$，它是由差分过程 $w_t$ 的 $s$ 个最新值堆叠而成的：\n$$\nx_t = \\begin{bmatrix} w_t  w_{t-1}  \\cdots  w_{t-s+1} \\end{bmatrix}^\\top\n$$\n\n状态转移方程描述了状态随时间的演变：\n$$\nx_{t+1} = F x_t + G \\xi_{t+1}, \\quad \\text{其中 } \\xi_{t+1} \\sim \\mathcal{N}(0, q)\n$$\n该方程意味着过程噪声协方差矩阵为 $Q = \\mathbb{E}[(G\\xi_{t+1})(G\\xi_{t+1})^\\top] = G \\mathbb{E}[\\xi_{t+1}^2] G^\\top = q G G^\\top$。由于 $G = [1, 0, \\ldots, 0]^\\top$，$Q$ 是一个 $s \\times s$ 矩阵，其左上角元素为 $q$，其余元素均为零。\n\n观测方程将潜状态与测量值 $y_t$ 联系起来：\n$$\ny_t = H x_t + v_t, \\quad \\text{其中 } v_t \\sim \\mathcal{N}(0, r)\n$$\n此处，$H = [1, 0, \\ldots, 0]$，这意味着 $y_t$ 是最新值 $w_t$ 的带噪声测量。\n\n卡尔曼滤波器通过一个两步过程（预测和更新）递归地更新状态均值 $a_{t|t} = \\mathbb{E}[x_t \\mid y_{1:t}]$ 和协方差 $P_{t|t} = \\operatorname{Cov}(x_t \\mid y_{1:t})$ 的估计。\n\n**初始化 (在 $t=0$ 时):**\n滤波器使用 $t=0$ 时状态的先验均值和协方差进行初始化：\n- 初始状态均值: $a_{0|0} = \\mathbb{E}[x_0] = \\mathbf{0} \\in \\mathbb{R}^s$\n- 初始状态协方差: $P_{0|0} = \\operatorname{Cov}(x_0) = \\sigma_0^2 I_s$，其中 $I_s$ 是 $s \\times s$ 的单位矩阵。\n\n**递归循环 (对于 $t=1, \\ldots, T$):**\n\n**1. 预测步骤 (时间更新):**\n给定上一步的滤波状态估计 $a_{t-1|t-1}$ 及其协方差 $P_{t-1|t-1}$，我们在观测 $y_t$ 之前预测当前时间 $t$ 的状态及其协方差。预测通过系统动力学传播状态。\n- 预测状态均值: $a_{t|t-1} = \\mathbb{E}[x_t \\mid y_{1:t-1}] = F a_{t-1|t-1}$\n- 预测状态协方差: $P_{t|t-1} = \\operatorname{Cov}(x_t \\mid y_{1:t-1}) = F P_{t-1|t-1} F^\\top + Q$\n\n**2. 更新步骤 (测量更新):**\n一旦测量值 $y_t$ 可用，就对预测状态进行校正。\n- 一步预测误差 (新息): $e_t = y_t - y_{t|t-1} = y_t - H a_{t|t-1}$\n- 新息协方差: $S_t = \\operatorname{Var}(e_t) = H P_{t|t-1} H^\\top + r$\n- 卡尔曼增益: $K_t = P_{t|t-1} H^\\top S_t^{-1}$。由于 $y_t$ 是标量，$S_t$ 也是标量，其逆为 $1/S_t$。\n- 更新后 (滤波) 的状态均值: $a_{t|t} = a_{t|t-1} + K_t e_t$\n- 更新后 (滤波) 的状态协方差: $P_{t|t} = (I_s - K_t H) P_{t|t-1}$\n\n**3. 对数似然计算:**\n对于高斯系统，观测值 $y_t$ 的增量对数似然由新息 $e_t$ 的高斯概率密度函数的对数给出，其均值为 $0$，方差为 $S_t$：\n$$\n\\ell_t = \\log p(y_t | y_{1:t-1}) = -\\frac{1}{2}\\left( \\log(2\\pi) + \\log S_t + \\frac{e_t^2}{S_t} \\right)\n$$\n整个序列 $y_{1:T}$ 的总对数似然是这些增量似然的总和：$\\mathcal{L} = \\sum_{t=1}^T \\ell_t$。\n\n该算法将被实现并应用于提供的三个测试用例。对于每个用例，我们将计算总对数似然 $\\mathcal{L}$、最后一步预测误差 $e_T$ 以及最终滤波状态的第一个元素 $a_{T|T}^{(1)}$。矩阵 $F$、$G$ 和 $H$ 将根据每个测试用例的参数 $s$、$\\phi$ 和 $\\Phi$ 构建。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Kalman filtering problem for the given test cases.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"s\": 24, \"phi\": 0.5, \"Phi\": 0.3, \"q\": 0.2, \"r\": 0.1, \"sigma0_sq\": 10,\n            \"T\": 36,\n            \"y\": np.array([0.2, 0.5, 0.1, -0.1, 0.3, 0.6, 0.4, 0.9, 1.2, 0.8, 0.2, -0.2, 0.0, 0.3, 0.7, 0.6, 0.2, 0.4, 0.1, 0.0, 0.5, 0.8, 1.0, 0.9, 0.3, 0.2, 0.1, 0.0, 0.4, 0.5, 0.7, 1.1, 1.0, 0.6, 0.3, 0.2])\n        },\n        {\n            \"s\": 4, \"phi\": 0.95, \"Phi\": 0.0, \"q\": 1e-6, \"r\": 0.05, \"sigma0_sq\": 10,\n            \"T\": 12,\n            \"y\": np.array([0.0, 0.1, 0.2, 0.4, 0.6, 0.9, 1.3, 1.6, 1.8, 2.0, 2.2, 2.3])\n        },\n        {\n            \"s\": 12, \"phi\": 0.2, \"Phi\": 0.8, \"q\": 0.01, \"r\": 0.5, \"sigma0_sq\": 10,\n            \"T\": 24,\n            \"y\": np.array([1.0, 0.8, 0.7, 0.6, 0.5, 0.6, 0.7, 0.9, 1.2, 1.5, 1.8, 2.0, 1.1, 0.9, 0.8, 0.7, 0.6, 0.7, 0.8, 1.0, 1.3, 1.6, 1.9, 2.1])\n        }\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        s = case[\"s\"]\n        phi = case[\"phi\"]\n        Phi = case[\"Phi\"]\n        q = case[\"q\"]\n        r = case[\"r\"]\n        sigma0_sq = case[\"sigma0_sq\"]\n        T = case[\"T\"]\n        y_obs = case[\"y\"]\n\n        # 1. Construct state-space matrices\n        F = np.zeros((s, s))\n        F[0, 0] = phi\n        if s > 1:\n            F[0, s-1] = Phi\n        for i in range(1, s):\n            F[i, i-1] = 1.0\n\n        G = np.zeros((s, 1))\n        G[0, 0] = 1.0\n\n        H = np.zeros((1, s))\n        H[0, 0] = 1.0\n\n        # Process noise covariance matrix Q\n        Q = G @ G.T * q\n        \n        # Identity matrix\n        I_s = np.eye(s)\n\n        # 2. Initialize filter\n        # a_{t|t} is stored in a_filt, initialized to a_{0|0}\n        a_filt = np.zeros((s, 1))\n        # P_{t|t} is stored in P_filt, initialized to P_{0|0}\n        P_filt = sigma0_sq * I_s\n\n        total_log_likelihood = 0.0\n        e_final = 0.0\n        \n        # 3. Kalman filter recursion\n        for t in range(T):\n            # Previous filtered state and covariance\n            a_prev_filt = a_filt\n            P_prev_filt = P_filt\n            \n            # --- Prediction Step ---\n            a_pred = F @ a_prev_filt\n            P_pred = F @ P_prev_filt @ F.T + Q\n            \n            # --- Update Step ---\n            y_t = y_obs[t]\n            \n            # Innovation (prediction error)\n            # H @ a_pred gives a 1x1 matrix\n            y_pred = (H @ a_pred)[0, 0]\n            e_t = y_t - y_pred\n            \n            # Innovation covariance\n            # H @ P_pred @ H.T gives a 1x1 matrix\n            S_t = (H @ P_pred @ H.T)[0, 0] + r\n            \n            # Kalman gain\n            # P_pred @ H.T gives an s x 1 vector\n            K_t = (P_pred @ H.T) / S_t\n\n            # Updated (filtered) state mean and covariance\n            a_filt = a_pred + K_t * e_t\n            P_filt = (I_s - K_t @ H) @ P_pred\n            \n            # Incremental log-likelihood\n            ll_t = -0.5 * (np.log(2 * np.pi) + np.log(S_t) + e_t**2 / S_t)\n            total_log_likelihood += ll_t\n            \n            if t == T - 1:\n                e_final = e_t\n\n        a_T_T_1 = a_filt[0, 0]\n        \n        all_results.append([total_log_likelihood, e_final, a_T_T_1])\n\n    # 4. Format and print the final output\n    case_results_str = []\n    for res in all_results:\n        case_str = f\"[{res[0]:.6f}, {res[1]:.6f}, {res[2]:.6f}]\"\n        case_results_str.append(case_str)\n    \n    final_output = \"[\" + \", \".join(case_results_str) + \"]\"\n    print(final_output)\n\nsolve()\n```"
        }
    ]
}