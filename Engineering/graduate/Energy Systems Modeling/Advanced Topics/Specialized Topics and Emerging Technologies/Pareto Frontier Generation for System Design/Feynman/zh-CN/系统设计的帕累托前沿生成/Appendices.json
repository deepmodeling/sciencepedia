{
    "hands_on_practices": [
        {
            "introduction": "我们从一个基础练习开始。对于一个简单的凸问题，理解如何解析地生成帕累托前沿是掌握多目标优化的第一步。该练习在一个简单的二次模型上使用加权和方法，以揭示权重参数与最终最优权衡之间的直接关系，从而让您清晰直观地掌握标量化方法的工作原理 。",
            "id": "4110755",
            "problem": "考虑一个能源系统设计练习，其中单个标量设计变量 $x \\in \\mathbb{R}$ 参数化了一种技术配置，该配置同时影响两个相互竞争的目标：成本代理 $f_{1}(x)$ 和排放代理 $f_{2}(x)$。假设这些代理被建模为严格凸函数 $f_{1}(x)=x^{2}$ 和 $f_{2}(x)=(x-2)^{2}$。在多目标优化中，生成帕累托前沿的一种标准方法是加权和标量化：对于权重 $\\lambda \\in [0,1]$，在 $x \\in \\mathbb{R}$ 上最小化标量化目标 $g_{\\lambda}(x)=\\lambda f_{1}(x)+(1-\\lambda) f_{2}(x)$。\n\n从帕累托最优性的正式定义和凸函数的性质出发，推导 $g_{\\lambda}(x)$ 的以 $\\lambda$ 为索引的最小化器 $x^{\\star}(\\lambda)$，并用它来映射当 $\\lambda$ 在 $[0,1]$ 上变化时目标空间中的相应图像 $\\big(f_{1}(x^{\\star}(\\lambda)),f_{2}(x^{\\star}(\\lambda))\\big)$。仅使用这些基本原理，将得到的点集描述为此问题的帕累托前沿，并证明为什么加权和方法在这种情况下能恢复整个前沿。\n\n您的最终交付成果必须是行向量 $\\big(x^{\\star}(\\lambda), f_{1}(x^{\\star}(\\lambda)), f_{2}(x^{\\star}(\\lambda))\\big)$ 的关于 $\\lambda$ 的紧凑解析表达式。不需要进行数值取整。将最终答案表示为单个行矩阵。",
            "solution": "对问题陈述的有效性进行审查。\n\n**步骤1：提取已知条件**\n- 设计变量：$x \\in \\mathbb{R}$\n- 第一个目标函数（成本代理）：$f_{1}(x)=x^{2}$\n- 第二个目标函数（排放代理）：$f_{2}(x)=(x-2)^{2}$\n- $f_1$ 和 $f_2$ 都被说明是严格凸函数。\n- 使用加权和标量化方法寻找帕累托前沿。\n- 标量化目标函数为 $g_{\\lambda}(x)=\\lambda f_{1}(x)+(1-\\lambda) f_{2}(x)$。\n- 权重参数为 $\\lambda \\in [0,1]$。\n- 任务是推导以 $\\lambda$ 为索引的最小化器 $x^{\\star}(\\lambda)$，对应的目标空间图像 $\\big(f_{1}(x^{\\star}(\\lambda)),f_{2}(x^{\\star}(\\lambda))\\big)$，并证明为什么此方法能恢复这个特定问题的整个帕累托前沿。\n\n**步骤2：使用提取的已知条件进行验证**\n- **科学依据：** 该问题基于多目标优化的既定数学框架。帕累托最优性、凸函数和加权和标量化方法等概念是优化理论及其应用（包括能源系统建模）中的标准和基本概念。所提供的函数是简单的、性态良好的凸多项式。该问题在科学上和数学上都是合理的。\n- **适定性：** 该问题定义清晰，包含了所有必要的组成部分。目标、决策变量域和优化方法都已明确给出。函数是解析且严格凸的，这保证了对于任何给定的 $\\lambda \\in [0,1]$，标量化目标都存在唯一的最小化器。该问题是适定的。\n- **客观性：** 该问题使用正式、精确的数学语言陈述，没有歧义或主观内容。\n\n**步骤3：结论与行动**\n该问题是有效的，因为它具有科学依据、适定且客观。它包含了一个标准多目标优化练习的完整且一致的设置。因此，我将继续进行求解。\n\n如果不存在任何其他可行解 $x$ 支配解 $x^{\\star}$，则该解 $x^{\\star}$ 被定义为帕累托最优解。也就是说，不存在这样的 $x$，使得对于所有目标 $i \\in \\{1, 2\\}$ 都有 $f_{i}(x) \\leq f_{i}(x^{\\star})$，且至少对于一个目标 $j \\in \\{1, 2\\}$ 有 $f_{j}(x)  f_{j}(x^{\\star})$。所有对应于帕累托最优解的目标向量的集合，即 $\\big(f_{1}(x^{\\star}), f_{2}(x^{\\star})\\big)$，构成了帕累托前沿。\n\n加权和方法将多个目标组合成一个单一的标量目标函数 $g_{\\lambda}(x)$，然后对其进行最小化。标量化的目标由下式给出：\n$$g_{\\lambda}(x) = \\lambda f_{1}(x) + (1-\\lambda) f_{2}(x)$$\n将给定的函数 $f_{1}(x)$ 和 $f_{2}(x)$ 代入：\n$$g_{\\lambda}(x) = \\lambda x^{2} + (1-\\lambda)(x-2)^{2}$$\n函数 $f_{1}(x)=x^{2}$ 和 $f_{2}(x)=(x-2)^{2}$ 是严格凸函数。由于 $\\lambda \\in [0,1]$，函数 $g_{\\lambda}(x)$ 是凸函数的非负线性组合，因此其本身也是一个凸函数。对于 $\\lambda \\in (0,1)$，$g_{\\lambda}(x)$ 是严格凸的。对于一个在 $\\mathbb{R}$上定义的可微凸函数，其全局最小值出现在其一阶导数为零的任意点 $x$ 处。\n\n我们计算 $g_{\\lambda}(x)$ 关于 $x$ 的导数：\n$$ \\frac{d g_{\\lambda}}{dx} = \\frac{d}{dx} \\left[ \\lambda x^{2} + (1-\\lambda)(x-2)^{2} \\right] $$\n$$ \\frac{d g_{\\lambda}}{dx} = 2\\lambda x + 2(1-\\lambda)(x-2) $$\n$$ \\frac{d g_{\\lambda}}{dx} = 2\\lambda x + 2x - 4 - 2\\lambda x + 4\\lambda $$\n$$ \\frac{d g_{\\lambda}}{dx} = 2x - 4 + 4\\lambda $$\n为了找到最小化器 $x^{\\star}(\\lambda)$，我们令导数为零：\n$$ 2x^{\\star}(\\lambda) - 4 + 4\\lambda = 0 $$\n$$ 2x^{\\star}(\\lambda) = 4 - 4\\lambda $$\n$$ x^{\\star}(\\lambda) = 2 - 2\\lambda = 2(1-\\lambda) $$\n这个最小化器的表达式对所有 $\\lambda \\in [0,1]$ 都有效。我们可以检查边界情况：\n- 对于 $\\lambda=1$，我们最小化 $g_{1}(x)=f_{1}(x)=x^{2}$，其最小值在 $x=0$ 处。我们的公式给出 $x^{\\star}(1) = 2(1-1) = 0$。\n- 对于 $\\lambda=0$，我们最小化 $g_{0}(x)=f_{2}(x)=(x-2)^{2}$，其最小值在 $x=2$ 处。我们的公式给出 $x^{\\star}(0) = 2(1-0) = 2$。\n因此，该公式对于整个区间 $\\lambda \\in [0,1]$ 都是正确的。\n\n现在，我们将 $x^{\\star}(\\lambda)$ 代回目标函数 $f_{1}(x)$ 和 $f_{2}(x)$，以找到目标空间中帕累托前沿上的相应点。\n\n对于第一个目标 $f_{1}$：\n$$ f_{1}(x^{\\star}(\\lambda)) = (x^{\\star}(\\lambda))^{2} = \\big(2(1-\\lambda)\\big)^{2} = 4(1-\\lambda)^{2} $$\n对于第二个目标 $f_{2}$：\n$$ f_{2}(x^{\\star}(\\lambda)) = (x^{\\star}(\\lambda)-2)^{2} = \\big(2(1-\\lambda) - 2\\big)^{2} = (2 - 2\\lambda - 2)^{2} = (-2\\lambda)^{2} = 4\\lambda^{2} $$\n因此，决策空间中的帕累托最优解由 $x^{\\star}(\\lambda)=2(1-\\lambda)$ 给出，而帕累托前沿上的相应点对于 $\\lambda \\in [0,1]$ 是 $\\big(4(1-\\lambda)^{2}, 4\\lambda^{2}\\big)$。\n\n问题还要求证明为什么加权和方法在这种情况下能恢复整个帕累托前沿。多目标优化的一个基本定理指出，对于一个凸优化问题，帕累托最优解的集合与通过最小化加权和标量化 $g_{\\lambda}(x)$（对于所有可能的权重组合，其中 $\\lambda_i \\ge 0$ 且 $\\sum \\lambda_i = 1$）所获得的解的集合是相同的。\n这个问题是一个凸优化问题，因为：\n1. 决策变量的域 $x \\in \\mathbb{R}$ 是一个凸集。\n2. 目标函数 $f_{1}(x)=x^{2}$ 和 $f_{2}(x)=(x-2)^{2}$ 都是凸函数（它们的二阶导数是 $f_{1}''(x)=2 > 0$ 和 $f_{2}''(x)=2 > 0$）。\n由于该问题是凸的，每个帕累托最优点都对应于某个 $\\lambda \\in [0,1]$ 的加权和问题的解。因此，通过在 $\\lambda$ 的整个范围 $[0,1]$ 内变化，我们保证能够描绘出整个帕累托前沿。该前沿本身是目标空间中的一条凸曲线，这对于凸问题是符合预期的。\n\n最终的交付成果是行向量 $\\big(x^{\\star}(\\lambda), f_{1}(x^{\\star}(\\lambda)), f_{2}(x^{\\star}(\\lambda))\\big)$ 的紧凑解析表达式。根据我们的推导：\n- $x^{\\star}(\\lambda) = 2(1-\\lambda)$\n- $f_{1}(x^{\\star}(\\lambda)) = 4(1-\\lambda)^{2}$\n- $f_{2}(x^{\\star}(\\lambda)) = 4\\lambda^{2}$\n\n得到的行向量是 $\\begin{pmatrix} 2(1-\\lambda)  4(1-\\lambda)^{2}  4\\lambda^{2} \\end{pmatrix}$。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n2(1-\\lambda)  4(1-\\lambda)^{2}  4\\lambda^{2}\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "虽然加权和方法对凸问题很有效，但现实世界的系统设计通常涉及离散选择，这会导致非凸的目标空间。这种情况会产生“非支撑”的帕累托最优点，而加权和方法无法找到它们。本练习通过一个混合整数线性规划（MILP）的例子来展示这一局限性，并引入 epsilon-约束方法作为一种更强大的技术，用以在此类非凸场景下生成完整的帕累托前沿 。",
            "id": "4110719",
            "problem": "考虑一个小型能源系统设计问题，该问题被表述为一个混合整数线性规划（MILP）模型，其中设计选择由二元决策变量表示。目标是生成两个目标函数的帕累托前沿，并说明在组合设置中非支撑帕累托点的存在，从而推动epsilon-约束方法和增广标量化的使用。本问题中的所有数学实体都经过精确定义，且该场景在能源系统建模领域具有科学真实性。\n\n定义以下多目标MILP。决策变量为 $x_i \\in \\{0,1\\}$，其中 $i \\in \\{1,2,3,4\\}$，它们代表从四个技术选项中选择一个以满足固定的单位需求。单一选择约束为\n$$\n\\sum_{i=1}^{4} x_i = 1.\n$$\n两个目标函数是总成本和温室气体总排放量：\n$$\nf_1(\\mathbf{x}) = \\sum_{i=1}^{4} c_i x_i,\\quad f_2(\\mathbf{x}) = \\sum_{i=1}^{4} e_i x_i,\n$$\n其中 $\\mathbf{x} = (x_1,x_2,x_3,x_4)$，$c_i$ 是技术 $i$ 的成本贡献，$e_i$ 是技术 $i$ 的排放贡献。\n\n四种技术具有以下参数，这些参数在科学上是合理的且自洽的：\n- 技术 1：$c_1 = 0$ 美元（USD），$e_1 = 10$ 千克二氧化碳当量（kg $\\mathrm{CO}_2$e）。\n- 技术 2：$c_2 = 5$ 美元，$e_2 = 6$ kg $\\mathrm{CO}_2$e。\n- 技术 3：$c_3 = 9$ 美元，$e_3 = 5$ kg $\\mathrm{CO}_2$e。\n- 技术 4：$c_4 = 10$ 美元，$e_4 = 0$ kg $\\mathrm{CO}_2$e。\n\n我们考虑三种标量化策略来生成帕累托最优点：\n1. 线性加权和标量化：对于给定的权重 $\\alpha \\in [0,1]$，最小化 $g_\\alpha(\\mathbf{x}) = \\alpha f_1(\\mathbf{x}) + (1-\\alpha) f_2(\\mathbf{x})$。\n2. Epsilon-约束方法：最小化 $f_1(\\mathbf{x})$，约束条件为 $f_2(\\mathbf{x}) \\le \\epsilon$，其中排放上限 $\\epsilon \\ge 0$ 以 kg $\\mathrm{CO}_2$e 为单位。\n3. 增广加权切比雪夫标量化：最小化\n$$\nh_{w,\\rho,z}(\\mathbf{x}) = \\max\\{w_1 (f_1(\\mathbf{x}) - z_1), w_2 (f_2(\\mathbf{x}) - z_2)\\} + \\rho \\left(w_1 (f_1(\\mathbf{x}) - z_1) + w_2 (f_2(\\mathbf{x}) - z_2)\\right),\n$$\n其中 $\\mathbf{w} = (w_1,w_2)$ 是非负权重且 $w_1 + w_2 = 1$，$\\rho  0$ 是一个小的增广参数，$\\mathbf{z} = (z_1,z_2)$ 是一个参考点（例如，乌托邦点或理想点估计）。为清晰起见，所有符号、变量和数字均以 LaTeX 形式给出。\n\n基本定义（无简写）：\n- 如果不存在可行解 $\\mathbf{x}$ 使得 $f_1(\\mathbf{x}) \\le f_1(\\mathbf{x}^\\star)$ 和 $f_2(\\mathbf{x}) \\le f_2(\\mathbf{x}^\\star)$ 同时成立且至少有一个不等式是严格的，则点 $\\mathbf{x}^\\star$ 是帕累托最优的。\n- 支撑帕累托点是指那些对于某个 $\\alpha \\in [0,1]$ 可以作为 $g_\\alpha(\\mathbf{x})$ 的最小化器获得的点。\n- 非支撑帕累托点是帕累托最优的，但不能通过任何线性加权和标量化获得，这在MILP中由于目标空间中的组合非凸性而经常发生。\n\n您的任务：\n- 对可行解 $\\mathbf{x}$ 进行穷举搜索，以精确计算目标值，并为指定的标量化参数选择解决方案。\n- 使用确定性决胜规则：当两个或多个解具有相同的标量化目标值时，优先选择 $f_2(\\mathbf{x})$ 较小的解；如果仍然持平，优先选择 $f_1(\\mathbf{x})$ 较小的解；如果仍然持平，优先选择技术索引 $i$ 较小的解。\n- 单位：成本必须以美元（USD）处理，排放以千克二氧化碳当量（kg $\\mathrm{CO}_2$e）处理。最终程序输出由表示每个测试案例所选技术索引的整数组成，因此输出中无需进行数值单位转换。\n\n测试套件和覆盖范围：\n为以下参数值提供解决方案，以检验正常和边界情况下的行为：\n- 加权和法，$\\alpha = 0.2$。\n- 加权和法，$\\alpha = 0.6$。\n- 加权和法，$\\alpha = 0.9$。\n- Epsilon-约束法，$\\epsilon = 6$ kg $\\mathrm{CO}_2$e。\n- Epsilon-约束法，$\\epsilon = 5$ kg $\\mathrm{CO}_2$e。\n- Epsilon-约束法，$\\epsilon = 0$ kg $\\mathrm{CO}_2$e（边界情况）。\n- 增广加权切比雪夫法，$\\mathbf{w} = (0.5, 0.5)$，$\\rho = 0.01$，参考点 $\\mathbf{z} = (0,0)$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个逗号分隔的列表，用方括号括起来，每个条目是对应测试案例所选技术的整数索引 $i \\in \\{1,2,3,4\\}$，顺序如上所列（例如，$\\left[4,1,1,2,3,4,2\\right]$）。",
            "solution": "该问题被评估为具有科学依据、良定、客观且自洽。提供了一个唯一、可验证解所需的所有数据和定义。该场景是能源系统建模中多目标优化的标准表述，并且参数是合理的。该问题有效。\n\n求解过程首先确定可行解集及其对应的目标函数值。约束条件是 $\\sum_{i=1}^{4} x_i = 1$ 且 $x_i \\in \\{0,1\\}$。这意味着只选择一种技术。四种可能的解及其对应的目标向量 $(f_1, f_2)$（分别对应成本和排放）是：\n1.  选择技术 1 ($x_1=1$): $(f_1, f_2) = (c_1, e_1) = (0, 10)$。\n2.  选择技术 2 ($x_2=1$): $(f_1, f_2) = (c_2, e_2) = (5, 6)$。\n3.  选择技术 3 ($x_3=1$): $(f_1, f_2) = (c_3, e_3) = (9, 5)$。\n4.  选择技术 4 ($x_4=1$): $(f_1, f_2) = (c_4, e_4) = (10, 0)$。\n\n所有四个解都是帕累托最优的，因为没有一个解被其他任何解所支配。然而，对应于技术 3 的点 $(9, 5)$ 是一个非支撑帕累托点。这是因为它不位于目标空间点集的下凸包上，该下凸包由连接 $(0, 10)$、$(5, 6)$ 和 $(10, 0)$ 的线段构成。线性加权和方法只能找到支撑帕累托点，即该下凸包的顶点。\n\n通过对四种可能的技术选择穷举评估给定的目标函数，并选择使目标最小化的那个，来解决以下七个测试案例。确定性决胜规则规定，在标量化目标值相同的情况下，选择 $f_2$ 值较小的解，其次是 $f_1$ 值较小的解，最后是技术索引 $i$ 较小的解。\n\n**测试案例 1：加权和法，$\\alpha = 0.2$**\n目标是最小化 $g_{0.2}(\\mathbf{x}) = 0.2 f_1(\\mathbf{x}) + (1-0.2) f_2(\\mathbf{x}) = 0.2 f_1(\\mathbf{x}) + 0.8 f_2(\\mathbf{x})$。\n-   技术 1：$g_{0.2} = 0.2(0) + 0.8(10) = 8.0$\n-   技术 2：$g_{0.2} = 0.2(5) + 0.8(6) = 1.0 + 4.8 = 5.8$\n-   技术 3：$g_{0.2} = 0.2(9) + 0.8(5) = 1.8 + 4.0 = 5.8$\n-   技术 4：$g_{0.2} = 0.2(10) + 0.8(0) = 2.0$\n最小值为 $2.0$，对应于技术 4。\n\n**测试案例 2：加权和法，$\\alpha = 0.6$**\n目标是最小化 $g_{0.6}(\\mathbf{x}) = 0.6 f_1(\\mathbf{x}) + 0.4 f_2(\\mathbf{x})$。\n-   技术 1：$g_{0.6} = 0.6(0) + 0.4(10) = 4.0$\n-   技术 2：$g_{0.6} = 0.6(5) + 0.4(6) = 3.0 + 2.4 = 5.4$\n-   技术 3：$g_{0.6} = 0.6(9) + 0.4(5) = 5.4 + 2.0 = 7.4$\n-   技术 4：$g_{0.6} = 0.6(10) + 0.4(0) = 6.0$\n最小值为 $4.0$，对应于技术 1。\n\n**测试案例 3：加权和法，$\\alpha = 0.9$**\n目标是最小化 $g_{0.9}(\\mathbf{x}) = 0.9 f_1(\\mathbf{x}) + 0.1 f_2(\\mathbf{x})$。\n-   技术 1：$g_{0.9} = 0.9(0) + 0.1(10) = 1.0$\n-   技术 2：$g_{0.9} = 0.9(5) + 0.1(6) = 4.5 + 0.6 = 5.1$\n-   技术 3：$g_{0.9} = 0.9(9) + 0.1(5) = 8.1 + 0.5 = 8.6$\n-   技术 4：$g_{0.9} = 0.9(10) + 0.1(0) = 9.0$\n最小值为 $1.0$，对应于技术 1。\n\n**测试案例 4：Epsilon-约束法，$\\epsilon = 6$ kg $\\mathrm{CO}_2$e**\n目标是最小化 $f_1(\\mathbf{x})$，约束条件为 $f_2(\\mathbf{x}) \\le 6$。\n-   技术 1：$f_2 = 10 > 6$ (不可行)。\n-   技术 2：$f_2 = 6 \\le 6$ (可行)。$f_1 = 5$。\n-   技术 3：$f_2 = 5 \\le 6$ (可行)。$f_1 = 9$。\n-   技术 4：$f_2 = 0 \\le 6$ (可行)。$f_1 = 10$。\n在可行解（技术 2、3、4）中，最小的 $f_1$ 是 $5$，对应于技术 2。\n\n**测试案例 5：Epsilon-约束法，$\\epsilon = 5$ kg $\\mathrm{CO}_2$e**\n目标是最小化 $f_1(\\mathbf{x})$，约束条件为 $f_2(\\mathbf{x}) \\le 5$。\n-   技术 1：$f_2 = 10 > 5$ (不可行)。\n-   技术 2：$f_2 = 6 > 5$ (不可行)。\n-   技术 3：$f_2 = 5 \\le 5$ (可行)。$f_1 = 9$。\n-   技术 4：$f_2 = 0 \\le 5$ (可行)。$f_1 = 10$。\n在可行解（技术 3、4）中，最小的 $f_1$ 是 $9$，对应于技术 3。这表明 epsilon-约束方法可以找到非支撑帕累托点。\n\n**测试案例 6：Epsilon-约束法，$\\epsilon = 0$ kg $\\mathrm{CO}_2$e**\n目标是最小化 $f_1(\\mathbf{x})$，约束条件为 $f_2(\\mathbf{x}) \\le 0$。\n-   技术 1：$f_2 = 10 > 0$ (不可行)。\n-   技术 2：$f_2 = 6 > 0$ (不可行)。\n-   技术 3：$f_2 = 5 > 0$ (不可行)。\n-   技术 4：$f_2 = 0 \\le 0$ (可行)。$f_1 = 10$。\n唯一的可行解是技术 4。\n\n**测试案例 7：增广加权切比雪夫法**\n目标是最小化 $h_{w,\\rho,z}(\\mathbf{x})$，其中 $\\mathbf{w} = (0.5, 0.5)$，$\\rho = 0.01$，且 $\\mathbf{z} = (0,0)$。\n$h(\\mathbf{x}) = \\max\\{0.5 f_1(\\mathbf{x}), 0.5 f_2(\\mathbf{x})\\} + 0.01 (0.5 f_1(\\mathbf{x}) + 0.5 f_2(\\mathbf{x}))$。\n这可以简化为 $h(\\mathbf{x}) = 0.5 \\max\\{f_1(\\mathbf{x}), f_2(\\mathbf{x})\\} + 0.005 (f_1(\\mathbf{x}) + f_2(\\mathbf{x}))$。\n-   技术 1：$(f_1, f_2) = (0, 10)$。$h_1 = 0.5 \\max\\{0,10\\} + 0.005(0+10) = 0.5(10) + 0.05 = 5.05$。\n-   技术 2：$(f_1, f_2) = (5, 6)$。$h_2 = 0.5 \\max\\{5,6\\} + 0.005(5+6) = 0.5(6) + 0.055 = 3.055$。\n-   技术 3：$(f_1, f_2) = (9, 5)$。$h_3 = 0.5 \\max\\{9,5\\} + 0.005(9+5) = 0.5(9) + 0.07 = 4.57$。\n-   技术 4：$(f_1, f_2) = (10, 0)$。$h_4 = 0.5 \\max\\{10,0\\} + 0.005(10+0) = 0.5(10) + 0.05 = 5.05$。\n最小值为 $3.055$，对应于技术 2。\n\n最终结果是按顺序排列的 7 个案例的技术索引：$[4, 1, 1, 2, 3, 4, 2]$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves a multi-objective optimization problem for a small energy system\n    by exhaustively searching through the solution space and applying different\n    scalarization techniques.\n    \"\"\"\n    \n    # Technology data: [id, cost (f1), emission (f2)]\n    # All mathematical entities are represented as native Python/Numpy types.\n    techs = np.array([\n        [1.0, 0.0, 10.0],  # Technology 1\n        [2.0, 5.0, 6.0],   # Technology 2\n        [3.0, 9.0, 5.0],   # Technology 3\n        [4.0, 10.0, 0.0]   # Technology 4\n    ])\n\n    test_cases = [\n        {'method': 'weighted_sum', 'alpha': 0.2},\n        {'method': 'weighted_sum', 'alpha': 0.6},\n        {'method': 'weighted_sum', 'alpha': 0.9},\n        {'method': 'epsilon_constraint', 'epsilon': 6.0},\n        {'method': 'epsilon_constraint', 'epsilon': 5.0},\n        {'method': 'epsilon_constraint', 'epsilon': 0.0},\n        {'method': 'aug_tchebycheff', 'w': np.array([0.5, 0.5]), 'rho': 0.01, 'z': np.array([0.0, 0.0])}\n    ]\n\n    results = []\n    \n    # Tie-breaking rule principle:\n    # A solution is \"better\" if its comparison tuple is lexicographically smaller.\n    # The tuple is constructed based on the method's objective and the problem's\n    # global tie-breaking rules.\n\n    for case in test_cases:\n        \n        # This list will hold tuples for comparison: (primary_obj, f2, f1, tech_id)\n        # Sorting this list will yield the best solution according to the rules.\n        candidate_solutions = []\n\n        if case['method'] == 'weighted_sum':\n            alpha = case['alpha']\n            for tech in techs:\n                tech_id, f1, f2 = tech\n                scalar_obj = alpha * f1 + (1.0 - alpha) * f2\n                candidate_solutions.append((scalar_obj, f2, f1, tech_id))\n        \n        elif case['method'] == 'epsilon_constraint':\n            epsilon = case['epsilon']\n            feasible_techs = []\n            for tech in techs:\n                tech_id, f1, f2 = tech\n                if f2 = epsilon:\n                    feasible_techs.append(tech)\n            \n            # The objective is to minimize f1.\n            # Tie-breaking is by f2, then f1 (redundant), then tech_id.\n            for tech in feasible_techs:\n                tech_id, f1, f2 = tech\n                candidate_solutions.append((f1, f2, tech_id)) # Note f1 is the primary objective here\n        \n        elif case['method'] == 'aug_tchebycheff':\n            w1, w2 = case['w']\n            rho = case['rho']\n            z1, z2 = case['z']\n            for tech in techs:\n                tech_id, f1, f2 = tech\n                term1 = max(w1 * (f1 - z1), w2 * (f2 - z2))\n                term2 = rho * (w1 * (f1 - z1) + w2 * (f2 - z2))\n                scalar_obj = term1 + term2\n                candidate_solutions.append((scalar_obj, f2, f1, tech_id))\n        \n        # Sort candidates based on the lexicographical comparison of their tuples.\n        # This elegantly handles the multi-level tie-breaking.\n        candidate_solutions.sort()\n        \n        # The best solution is the first one after sorting.\n        best_solution = candidate_solutions[0]\n        \n        # The tech_id is the last element in the tuple.\n        best_tech_id = best_solution[-1]\n        \n        results.append(int(best_tech_id))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在掌握了 epsilon-约束方法之后，我们现在将其应用于一个更复杂、更贴近现实的场景：多周期微电网的设计。这个练习弥合了理论方法与实际能源系统建模之间的差距。通过在不同的财务假设（贴现率）下优化微电网的设计，该练习展示了如何为高维问题生成并分析帕累托前沿，揭示了经济偏好如何改变成本与环境影响之间的最优权衡 。",
            "id": "4110758",
            "problem": "考虑一个能源系统建模中的多周期微电网设计问题。该微电网有三个代表装机容量的连续决策变量：光伏容量 $x_{\\mathrm{pv}}$（单位：$\\mathrm{kW}$）、电池储能容量 $x_{\\mathrm{bat}}$（单位：$\\mathrm{kWh}$）和柴油发电机容量 $x_{\\mathrm{gen}}$（单位：$\\mathrm{kW}$）。对于每个时段 $t \\in \\{1,\\dots,T\\}$（其中 $T=4$），系统有代表运行流量的决策变量：直接用于满足负荷的光伏能量 $y_t$（单位：$\\mathrm{kWh}$）、电池充电能量 $c_t$（单位：$\\mathrm{kWh}$）、电池放电能量 $d_t$（单位：$\\mathrm{kWh}$）、发电机能量 $g_t$（单位：$\\mathrm{kWh}$）以及电池荷电状态 $e_t$（单位：$\\mathrm{kWh}$）。每个时段时长为 $h=1\\,\\mathrm{h}$，所有能量单位均为每时段。\n\n基本原理是能量守恒、线性容量资源和贴现现金流估值。能量守恒意味着输送到负荷的能量等于来自光伏、电池放电和发电机的能量之和。电池的充电和放电根据一个带效率的线性荷电状态差分方程演变。成本估值使用一个恒定的每时段贴现因子来计算运营成本的现值。\n\n参数如下，每个参数在科学上都是合理的，并且在所有测试案例中都是固定的：\n- 时段需求 $L_t$（单位：$\\mathrm{kWh}$）：$L_1=60$，$L_2=50$，$L_3=55$，$L_4=45$。\n- 光伏可用率 $a_t$（无量纲）：$a_1=0.8$，$a_2=0.6$，$a_3=0.7$，$a_4=0.5$。时段 $t$ 的可用光伏能量为 $a_t \\, x_{\\mathrm{pv}} \\, h$，其中 $h=1$。\n- 电池充电效率 $\\eta_c=0.95$ 和放电效率 $\\eta_d=0.90$（无量纲）。\n- 资本成本：光伏 $c^{\\mathrm{pv}}=900$（单位：美元/$\\mathrm{kW}$），电池 $c^{\\mathrm{bat}}=200$（单位：美元/$\\mathrm{kWh}$），发电机 $c^{\\mathrm{gen}}=300$（单位：美元/$\\mathrm{kW}$）。\n- 发电机燃料成本 $c^{\\mathrm{fuel}}=0.20$（单位：美元/$\\mathrm{kWh}$）。\n- 发电机排放因子 $\\alpha=0.80$（单位：千克 $\\mathrm{CO_2}$/$\\mathrm{kWh}$）。\n- 所有变量均为非负。\n\n两个目标是双标准最小化：\n1) 净现成本 (NPC) $C(\\delta)$，单位为美元，定义为资本成本加上贴现运营成本之和，其中 $\\delta \\in (0,1)$ 是每时段的贴现因子。对于贴现因子 $\\delta$，时段 $t$ 的运营成本的现值权重为 $\\delta^{t-1}$。目标是：\n$$\nC(\\delta) \\;=\\; c^{\\mathrm{pv}} \\, x_{\\mathrm{pv}} \\;+\\; c^{\\mathrm{bat}} \\, x_{\\mathrm{bat}} \\;+\\; c^{\\mathrm{gen}} \\, x_{\\mathrm{gen}} \\;+\\; \\sum_{t=1}^{T} \\delta^{t-1} \\, c^{\\mathrm{fuel}} \\, g_t.\n$$\n2) 总排放量 $E$，单位为千克 $\\mathrm{CO_2}$：\n$$\nE \\;=\\; \\alpha \\sum_{t=1}^{T} g_t.\n$$\n\n对于每个时段 $t \\in \\{1,\\dots,T\\}$ 的物理可行性约束是：\n- 光伏可用性：$y_t + c_t \\le a_t \\, x_{\\mathrm{pv}}$。\n- 负荷平衡：$y_t + d_t + g_t \\ge L_t$。\n- 发电机容量：$g_t \\le x_{\\mathrm{gen}}$。\n- 电池容量：$e_t \\le x_{\\mathrm{bat}}$。\n- 电池动态（带效率的能量守恒）：\n对于 $t=1,2,3$：$e_{t+1} = e_t + \\eta_c \\, c_t - \\dfrac{d_t}{\\eta_d}$。\n对于 $t=4$ 的循环条件：$e_{1} = e_{4} + \\eta_c \\, c_{4} - \\dfrac{d_{4}}{\\eta_d}$。\n\n要生成帕累托前沿点，请使用ε-约束方法：对于一组排放上限 $\\bar{E}$，在满足 $E \\le \\bar{E}$ 和上述可行性约束的条件下，最小化 $C(\\delta)$。通过对递增的 $\\bar{E}$ 值求解，您可以描绘出成本-排放的帕累托前沿。对于这个线性问题，该前沿是凸的。\n\n测试套件和输出规范：\n- 待测试的贴现因子 $\\delta$：$\\delta \\in \\{0.92, 0.96, 0.99\\}$。\n- 排放上限（单位：千克 $\\mathrm{CO_2}$）：$\\bar{E} \\in \\{0, \\alpha \\cdot 60, \\alpha \\cdot 120, \\alpha \\cdot (L_1+L_2+L_3+L_4)\\}$，其中 $L_1+L_2+L_3+L_4=210$，因此上限为 $0$、$\\alpha \\cdot 60$、$\\alpha \\cdot 120$ 和 $\\alpha \\cdot 210$。\n- 对于每个 $\\delta$，计算一组帕累托点，形式为有序对 $[C(\\delta),E]$（单位分别为美元和千克），每个排放上限对应一个有序对，按 $\\bar{E}$ 的非递减顺序排列。\n- 最终输出格式：您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，该列表包含三个条目（每个 $\\delta$ 一个），每个条目是四个 $[C(\\delta),E]$ 对的列表，所有数字四舍五入到两位小数。例如，最外层结构应类似于 $[[[c_{11},e_{11}],[c_{12},e_{12}],\\dots],[\\dots],[\\dots]]$，不含任何空格。所有成本必须以美元计，所有排放量必须以千克 $\\mathrm{CO_2}$ 计。\n\n答案以美元和千克 $\\mathrm{CO_2}$ 为单位，四舍五入到两位小数，并确保打印输出中没有空格。",
            "solution": "该问题提出了一个用于设计微电网的多目标优化任务。目标是找到两个冲突目标之间的权衡，即帕累托前沿：最小化净现成本 (NPC) 和最小化总碳排放量。该问题在科学上是有效、适定的，并提供了所有必要的数据和约束。它是线性规划和多目标优化技术在能源系统工程中的标准应用。\n\n该解决方案是使用ε-约束方法得出的。此方法将双目标问题转化为一系列单目标问题。对于给定的每时段贴现因子 $\\delta$，我们在满足系统的物理和运行约束，以及一个将总排放量 $E$ 限制在指定上限 $\\bar{E}$ 以内的附加约束条件下，最小化净现成本 $C(\\delta)$。通过对一组递增的 $\\bar{E}$ 值求解此问题，我们可以描绘出帕累托最优前沿。\n\n首先，我们定义数学模型。决策变量包括三个设计变量 $(x_{\\mathrm{pv}}, x_{\\mathrm{bat}}, x_{\\mathrm{gen}})$ 和四个时间段的二十个运行变量 $(y_t, c_t, d_t, g_t, e_t)$，其中 $t \\in \\{1, 2, 3, 4\\}$。所有变量都限制为非负。\n\n对于给定的贴现因子 $\\delta$ 和排放上限 $\\bar{E}$，线性规划 (LP) 问题公式化如下：\n\n**目标函数：最小化净现成本 $C(\\delta)$**\n成本函数是设备资本成本与运营成本（发电机燃料）贴现总和的总和。\n$$ \\min \\quad C(\\delta) = c^{\\mathrm{pv}} x_{\\mathrm{pv}} + c^{\\mathrm{bat}} x_{\\mathrm{bat}} + c^{\\mathrm{gen}} x_{\\mathrm{gen}} + \\sum_{t=1}^{4} \\delta^{t-1} c^{\\mathrm{fuel}} g_t $$\n给定的成本参数为 $c^{\\mathrm{pv}}=900\\,\\$/\\mathrm{kW}$，$c^{\\mathrm{bat}}=200\\,\\$/\\mathrm{kWh}$，$c^{\\mathrm{gen}}=300\\,\\$/\\mathrm{kW}$，以及 $c^{\\mathrm{fuel}}=0.20\\,\\$/\\mathrm{kWh}$。\n\n**满足以下每个时段 $t \\in \\{1, 2, 3, 4\\}$ 的约束条件：**\n\n1.  **负荷平衡：** 供应的能量必须满足需求 $L_t$。\n    $$ y_t + d_t + g_t \\ge L_t $$\n    需求为 $L = [60, 50, 55, 45]\\,\\mathrm{kWh}$。\n\n2.  **光伏 (PV) 可用性：** 从光伏系统调度的能量受其装机容量 $x_{\\mathrm{pv}}$ 和特定时段的可用率 $a_t$ 的限制。时段时长为 $h=1\\,\\mathrm{h}$。\n    $$ y_t + c_t \\le a_t h x_{\\mathrm{pv}} $$\n    可用率为 $a = [0.8, 0.6, 0.7, 0.5]$。\n\n3.  **发电机容量：** 来自发电机的能量受其功率容量 $x_{\\mathrm{gen}}$ 的限制。\n    $$ g_t \\le h x_{\\mathrm{gen}} $$\n\n4.  **电池储能容量：** 存储的能量 $e_t$ 不能超过电池的容量 $x_{\\mathrm{bat}}$。\n    $$ e_t \\le x_{\\mathrm{bat}} $$\n\n5.  **电池动态：** 电池的荷电状态 $e_t$ 由一个能量守恒方程控制，包括充电效率 $\\eta_c=0.95$ 和放电效率 $\\eta_d=0.90$。一个循环条件确保了在四时段周期内的可持续性。\n    $$ e_{t+1} = e_t + \\eta_c c_t - \\frac{d_t}{\\eta_d} \\quad \\text{对于 } t=1, 2, 3 $$\n    $$ e_{1} = e_{4} + \\eta_c c_{4} - \\frac{d_{4}}{\\eta_d} \\quad \\text{对于 } t=4 $$\n\n6.  **排放约束：** 总排放量，根据发电机使用情况和排放因子 $\\alpha=0.80\\,\\mathrm{kg\\,CO_2/kWh}$ 计算，上限为 $\\bar{E}$。\n    $$ \\alpha \\sum_{t=1}^{4} g_t \\le \\bar{E} $$\n\n这个LP公式针对 $\\delta \\in \\{0.92, 0.96, 0.99\\}$ 和 $\\bar{E} \\in \\{0, \\alpha \\cdot 60, \\alpha \\cdot 120, \\alpha \\cdot 210\\}$（即 $\\{0, 48, 96, 168\\}\\,\\mathrm{kg\\,CO_2}$）的每种组合进行求解。每个LP问题的解产生最小成本 $C^*(\\delta, \\bar{E})$ 和相应的最优决策变量。实际排放量 $E^*$ 是根据最优发电机调度 $g_t^*$ 计算的。得到的结果对 $[C^*, E^*]$ 是帕累托前沿上的一个点。系统地对所有指定的测试案例重复此过程，以生成所需的帕累托点集。所有数值结果按要求四舍五入到两位小数。",
            "answer": "```python\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef solve():\n    \"\"\"\n    Solves the microgrid design problem for a set of discount factors and emissions caps.\n    \"\"\"\n    # Fixed parameters\n    T = 4\n    h = 1.0\n    L = np.array([60.0, 50.0, 55.0, 45.0])\n    a = np.array([0.8, 0.6, 0.7, 0.5])\n    eta_c = 0.95\n    eta_d = 0.90\n    c_pv = 900.0\n    c_bat = 200.0\n    c_gen = 300.0\n    c_fuel = 0.20\n    alpha = 0.80\n\n    # Test cases from the problem statement\n    deltas = [0.92, 0.96, 0.99]\n    total_load = np.sum(L)\n    E_bar_levels = [0.0, alpha * 60.0, alpha * 120.0, alpha * total_load]\n\n    # Variable indices mapping:\n    # [x_pv, x_bat, x_gen, y_1..4, c_1..4, d_1..4, g_1..4, e_1..4]\n    num_vars = 3 + 4 * 5  # 23 variables\n\n    all_results = []\n    for delta in deltas:\n        delta_results = []\n        for E_bar in E_bar_levels:\n            # 1. Objective function vector c\n            # c = [c_pv, c_bat, c_gen, 0*y, 0*c, 0*d, cost_g, 0*e]\n            c_vec = np.zeros(num_vars)\n            c_vec[0] = c_pv\n            c_vec[1] = c_bat\n            c_vec[2] = c_gen\n            for t in range(T):\n                c_vec[15 + t] = (delta**t) * c_fuel\n\n            # 2. Inequality constraints A_ub * x = b_ub\n            # 17 constraints: 4 PV, 4 Load, 4 Gen, 4 Bat, 1 Emission\n            A_ub = np.zeros((17, num_vars))\n            b_ub = np.zeros(17)\n\n            for t in range(T):\n                # PV availability: y_t + c_t = a_t * h * x_pv\n                A_ub[t, 0] = -a[t] * h\n                A_ub[t, 3 + t] = 1.0   # y_t\n                A_ub[t, 7 + t] = 1.0   # c_t\n\n                # Load balance: y_t + d_t + g_t >= L_t  -> -y_t - d_t - g_t = -L_t\n                A_ub[4 + t, 3 + t] = -1.0\n                A_ub[4 + t, 11 + t] = -1.0\n                A_ub[4 + t, 15 + t] = -1.0\n                b_ub[4 + t] = -L[t]\n\n                # Generator capacity: g_t = h * x_gen -> g_t - h*x_gen = 0\n                A_ub[8 + t, 2] = -h\n                A_ub[8 + t, 15 + t] = 1.0\n\n                # Battery capacity: e_t = x_bat -> e_t - x_bat = 0\n                A_ub[12 + t, 1] = -1.0\n                A_ub[12 + t, 19 + t] = 1.0\n\n            # Emissions cap: alpha * sum(g_t) = E_bar\n            A_ub[16, 15:19] = alpha\n            b_ub[16] = E_bar\n\n            # 3. Equality constraints A_eq * x == b_eq\n            # 4 battery dynamics constraints\n            A_eq = np.zeros((4, num_vars))\n            b_eq = np.zeros(4)\n            for t in range(T - 1):\n                # e_{t+1} - e_t - eta_c*c_t + (1/eta_d)*d_t = 0\n                A_eq[t, 19 + (t + 1)] = 1.0\n                A_eq[t, 19 + t] = -1.0\n                A_eq[t, 7 + t] = -eta_c\n                A_eq[t, 11 + t] = 1.0 / eta_d\n            \n            # Cyclic constraint for t=4: e_1 = e_4 + eta_c*c_4 - d_4/eta_d\n            t = T - 1\n            A_eq[t, 19] = 1.0          # e_1\n            A_eq[t, 19 + t] = -1.0     # e_4\n            A_eq[t, 7 + t] = -eta_c    # c_4\n            A_eq[t, 11 + t] = 1.0 / eta_d # d_4\n\n            # 4. Bounds (all non-negative). Default in scipy.optimize.linprog.\n            bounds = (0, None)\n\n            # 5. Solve the LP\n            res = linprog(c=c_vec, A_ub=A_ub, b_ub=b_ub, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')\n\n            if res.success:\n                cost = res.fun\n                x_sol = res.x\n                g_sol = x_sol[15:19]\n                emissions = alpha * np.sum(g_sol)\n                delta_results.append(f\"[{cost:.2f},{emissions:.2f}]\")\n            else:\n                # Fallback for solver failure, though not expected here\n                delta_results.append(\"[nan,nan]\")\n        \n        all_results.append(f\"[{','.join(delta_results)}]\")\n        \n    print(f\"[{','.join(all_results)}]\")\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}