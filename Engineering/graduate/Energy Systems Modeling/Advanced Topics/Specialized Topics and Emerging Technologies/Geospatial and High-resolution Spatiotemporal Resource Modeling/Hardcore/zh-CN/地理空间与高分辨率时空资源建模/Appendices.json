{
    "hands_on_practices": [
        {
            "introduction": "在任何能源系统分析中，最核心的一步是将原始的气象数据转化为可用的发电量。本练习将指导您从基本物理原理出发，为风力涡轮机和光伏阵列构建性能模型，将小时级的风速和辐照度时间序列数据转换为功率输出。掌握这项技能对于准确评估可再生能源的发电潜力和经济性至关重要。",
            "id": "4093383",
            "problem": "地理空间和高分辨率时空资源建模工作流通常需要将小时资源序列转换为风力涡轮机和光伏系统的容量因子场。从基本物理关系出发，推导算法方法，通过物理驱动的功率曲线将小时风速序列 $v(t)$ 映射到涡轮机功率输出，并通过温度校正性能模型将小时阵列平面辐照度序列 $POA(t)$（表示为 $G(t)$）和环境温度序列 $T_{\\mathrm{amb}}(t)$ 映射到光伏功率输出。使用这些方法计算每个站点的容量因子，即发电量与在同一时期内以额定功率产生的能量之比。容量因子是无量纲的，必须表示为小数。\n\n您的推导必须从一个有效的基础出发。对于风能，从通过一个区域的动能通量以及涡轮机功率曲线强制执行切入、额定和切出行为的概念开始。对于光伏，从通过组件在标准测试条件下的效率和线性温度系数将阵列平面辐照度转换为直流功率开始，电池温度根据额定工作电池温度估算。不应假定任何简化公式；从这些基础逻辑地推导出每个映射。确保所有算法选择都具有科学真实性。\n\n单位必须按如下方式使用：\n- 风速单位为 $\\mathrm{m/s}$。\n- 辐照度单位为 $\\mathrm{W/m^2}$。\n- 环境和电池温度单位为 $^\\circ\\mathrm{C}$。\n- 功率单位为 $\\mathrm{kW}$。\n- 容量因子为无量纲小数。\n\n将包含 $N$ 个小时样本的时间序列的容量因子定义为 $CF = \\dfrac{\\sum_{t=1}^{N} P(t)}{P_{\\mathrm{rated}} \\cdot N}$，其中 $P(t)$ 是第 $t$ 小时的功率，$P_{\\mathrm{rated}}$ 是额定功率。此定义普遍适用；当所提供的序列跨越一整年时，它得出的是年容量因子。\n\n实施推导出的方法，并为以下测试套件计算容量因子，每个案例代表一个不同的站点或网格单元：\n\n- 风能案例 A（正常路径）：\n  - 额定功率 $P_{\\mathrm{rated}} = 3000\\,\\mathrm{kW}$。\n  - 切入速度 $v_{\\mathrm{ci}} = 3\\,\\mathrm{m/s}$。\n  - 额定速度 $v_{\\mathrm{r}} = 12\\,\\mathrm{m/s}$。\n  - 切出速度 $v_{\\mathrm{co}} = 25\\,\\mathrm{m/s}$。\n  - $N=10$ 小时的小时风速 $v(t)$：$[0, 2.5, 3, 6, 10, 12, 15, 24, 26, 8]$，单位为 $\\mathrm{m/s}$。\n\n- 风能案例 B（边缘案例，始终低于切入速度）：\n  - 额定功率 $P_{\\mathrm{rated}} = 3000\\,\\mathrm{kW}$。\n  - 切入速度 $v_{\\mathrm{ci}} = 3\\,\\mathrm{m/s}$。\n  - 额定速度 $v_{\\mathrm{r}} = 12\\,\\mathrm{m/s}$。\n  - 切出速度 $v_{\\mathrm{co}} = 25\\,\\mathrm{m/s}$。\n  - $N=10$ 小时的小时风速 $v(t)$：$[0, 1, 2, 2.9, 0.5, 2.8, 2.999, 2, 1.5, 0]$，单位为 $\\mathrm{m/s}$。\n\n- 光伏案例 C（昼夜变化，无削峰）：\n  - 额定功率 $P_{\\mathrm{rated}} = 500\\,\\mathrm{kW}$。\n  - 标准测试条件下的参考组件效率 $\\eta_{\\mathrm{ref}} = 0.18$。\n  - 功率温度系数 $\\beta = -0.004\\,^\\circ\\mathrm{C}^{-1}$。\n  - 额定工作电池温度 $NOCT = 45\\,^\\circ\\mathrm{C}$。\n  - $N=10$ 小时的小时阵列平面辐照度 $G(t)$：$[0, 0, 200, 400, 600, 800, 1000, 800, 400, 0]$，单位为 $\\mathrm{W/m^2}$。\n  - $N=10$ 小时的小时环境温度 $T_{\\mathrm{amb}}(t)$：$[15, 15, 16, 17, 18, 20, 22, 24, 22, 18]$，单位为 $^\\circ\\mathrm{C}$。\n\n- 光伏案例 D（高辐照度伴有逆变器削峰）：\n  - 额定功率 $P_{\\mathrm{rated}} = 1000\\,\\mathrm{kW}$。\n  - 标准测试条件下的参考组件效率 $\\eta_{\\mathrm{ref}} = 0.18$。\n  - 功率温度系数 $\\beta = -0.004\\,^\\circ\\mathrm{C}^{-1}$。\n  - 额定工作电池温度 $NOCT = 45\\,^\\circ\\mathrm{C}$。\n  - $N=10$ 小时的小时阵列平面辐照度 $G(t)$：$[0, 300, 600, 900, 1100, 1200, 1100, 900, 600, 300]$，单位为 $\\mathrm{W/m^2}$。\n  - $N=10$ 小时的小时环境温度 $T_{\\mathrm{amb}}(t)$：$[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]$，单位为 $^\\circ\\mathrm{C}$。\n\n您的程序应生成单行输出，其中包含与上述案例相对应的四个容量因子值，四舍五入到六位小数，以逗号分隔的列表形式包含在方括号中，例如 $[x_1, x_2, x_3, x_4]$。",
            "solution": "该问题要求从小时时间序列数据中，推导并实施计算风能和光伏（PV）发电系统容量因子的算法方法。推导必须按照规定源于基本物理原理。\n\n首先，我们处理风力涡轮机模型。风能中的功率源于运动空气的动能。质量为 $m$、速度为 $v$ 的空气的动能由 $E_k = \\frac{1}{2}mv^2$ 给出。功率是能量流动的速率。考虑一股空气在时间 $\\Delta t$ 内通过涡轮机转子面积 $A$，空气的体积为 $V = A \\cdot v \\cdot \\Delta t$。设空气密度为 $\\rho$，则质量为 $m = \\rho V = \\rho A v \\Delta t$。因此，动能通量，即风中的功率，为 $P_{\\text{wind}} = \\frac{E_k}{\\Delta t} = \\frac{1}{2}\\rho A v^3$。这表明可用功率与风速的立方成正比，即 $P_{\\text{wind}} \\propto v^3$。\n\n一台真实风力涡轮机的电力输出功率 $P(t)$ 由功率曲线描述，该曲线是瞬时风速 $v(t)$ 的函数。此曲线由四个运行区域定义，基于切入速度 $v_{\\mathrm{ci}}$、额定速度 $v_{\\mathrm{r}}$ 和切出速度 $v_{\\mathrm{co}}$。\n1.  对于 $v(t) < v_{\\mathrm{ci}}$，风速不足以克服涡轮机的机械和电气损耗，因此功率输出为零：$P(t) = 0$。\n2.  对于 $v_{\\mathrm{ci}} \\le v(t) < v_{\\mathrm{r}}$，涡轮机产生功率。遵循提取的功率应与风中可用功率相关的物理动机，此区域的输出被建模为 $v(t)^3$ 的函数。一个满足边界条件 $P(v_{\\mathrm{ci}}) = 0$ 和 $P(v_{\\mathrm{r}}) = P_{\\mathrm{rated}}$ 的常见且物理上一致的模型是一个缩放的立方函数：\n    $$P(t) = P_{\\mathrm{rated}} \\cdot \\left( \\frac{v(t)^3 - v_{\\mathrm{ci}}^3}{v_{\\mathrm{r}}^3 - v_{\\mathrm{ci}}^3} \\right)$$\n    这确保了平滑且基于物理的功率爬升。\n3.  对于 $v_{\\mathrm{r}} \\le v(t) < v_{\\mathrm{co}}$，涡轮机的控制系统将其输出限制在额定功率 $P_{\\mathrm{rated}}$，以保护发电机和电力电子设备。因此，$P(t) = P_{\\mathrm{rated}}$。\n4.  对于 $v(t) \\ge v_{\\mathrm{co}}$，涡轮机关闭以防止极端风荷载造成的结构性损伤。功率输出降至零：$P(t) = 0$。\n\n综合这些区域，从 $v(t)$ 到 $P(t)$ 的完整风力涡轮机算法映射为：\n$$\nP(t) = \n\\begin{cases} \n0 & \\text{若 } v(t) < v_{\\mathrm{ci}} \\text{ 或 } v(t) \\ge v_{\\mathrm{co}} \\\\\nP_{\\mathrm{rated}} \\cdot \\left(\\frac{v(t)^3 - v_{\\mathrm{ci}}^3}{v_{\\mathrm{r}}^3 - v_{\\mathrm{ci}}^3}\\right) & \\text{若 } v_{\\mathrm{ci}} \\le v(t) < v_{\\mathrm{r}} \\\\\nP_{\\mathrm{rated}} & \\text{若 } v_{\\mathrm{r}} \\le v(t) < v_{\\mathrm{co}}\n\\end{cases}\n$$\n\n接下来，我们处理光伏（PV）系统模型。光伏系统产生的功率取决于入射的太阳辐照度、系统面积及其转换效率。额定功率 $P_{\\mathrm{rated}}$ 是在标准测试条件（STC）下指定的，即参考辐照度 $G_{\\mathrm{ref}} = 1000\\,\\mathrm{W/m^2}$ 和参考电池温度 $T_{\\mathrm{ref}} = 25\\,^\\circ\\mathrm{C}$。在这些条件下，功率为 $P_{\\mathrm{rated}} = G_{\\mathrm{ref}} \\cdot A_{\\mathrm{sys}} \\cdot \\eta_{\\mathrm{ref}}$，其中 $A_{\\mathrm{sys}}$ 是系统总面积，$\\eta_{\\mathrm{ref}}$ 是参考组件效率。我们必须小心处理单位；如果 $P_{\\mathrm{rated}}$ 的单位是 $\\mathrm{kW}$，我们通过乘以 $1000$ 将其转换为 $\\mathrm{W}$。系统的有效面积可以推导为 $A_{\\mathrm{sys}} = \\frac{1000 \\cdot P_{\\mathrm{rated}}}{G_{\\mathrm{ref}} \\cdot \\eta_{\\mathrm{ref}}}$。\n在任意阵列平面辐照度 $G(t)$ 下，不考虑温度效应，产生的潜在功率将是 $P_{\\text{potential}}(t) = G(t) \\cdot A_{\\mathrm{sys}} \\cdot \\eta_{\\mathrm{ref}}$。代入 $A_{\\mathrm{sys}}$ 的表达式并使用 $G_{\\mathrm{ref}} = 1000\\,\\mathrm{W/m^2}$：\n$$P_{\\text{potential}}(t) = G(t) \\cdot \\left(\\frac{1000 \\cdot P_{\\mathrm{rated}}}{1000 \\cdot \\eta_{\\mathrm{ref}}}\\right) \\cdot \\eta_{\\mathrm{ref}} = P_{\\mathrm{rated}} \\cdot \\frac{G(t)}{1000}$$\n这提供了额定功率按 GHI 比率的直接缩放，其中 $P(t)$ 的单位与 $P_{\\mathrm{rated}}$（kW）相同。\n\n组件的效率，从而其功率输出，对其工作温度 $T_{\\mathrm{cell}}(t)$ 很敏感。首先，我们必须估算 $T_{\\mathrm{cell}}(t)$。问题指定使用额定工作电池温度（$NOCT$）模型。$NOCT$ 是在 $G_{\\mathrm{NOCT}} = 800\\,\\mathrm{W/m^2}$ 和 $T_{\\mathrm{amb,NOCT}} = 20\\,^\\circ\\mathrm{C}$ 条件下的电池温度。电池温度高于环境温度的程度与入射辐照度成正比。该模型为：\n$$T_{\\mathrm{cell}}(t) = T_{\\mathrm{amb}}(t) + (NOCT - T_{\\mathrm{amb,NOCT}}) \\cdot \\frac{G(t)}{G_{\\mathrm{NOCT}}} = T_{\\mathrm{amb}}(t) + (NOCT - 20) \\cdot \\frac{G(t)}{800}$$\n其中所有温度单位均为 $^\\circ\\mathrm{C}$。\n\n接下来，我们使用给定的线性功率温度系数 $\\beta$ 来考虑温度对功率输出的影响。该系数相对于参考温度 $T_{\\mathrm{ref}} = 25\\,^\\circ\\mathrm{C}$ 来修正功率输出。生成的总直流功率 $P_{\\mathrm{DC}}(t)$ 为：\n$$P_{\\mathrm{DC}}(t) = P_{\\text{potential}}(t) \\cdot [1 + \\beta(T_{\\mathrm{cell}}(t) - T_{\\mathrm{ref}})] = P_{\\mathrm{rated}} \\cdot \\frac{G(t)}{1000} \\cdot [1 + \\beta(T_{\\mathrm{cell}}(t) - 25)]$$\n由于晶体硅光伏组件的 $\\beta$ 通常为负值，因此较高的电池温度会导致较低的功率输出。\n\n最后，输送到电网的交流功率 $P(t)$ 受限于逆变器的最大功率输出，该输出假定等于系统的额定功率 $P_{\\mathrm{rated}}$。这种现象被称为逆变器削峰。因此，最终的功率输出是计算出的直流功率和额定功率中的较小者。我们还确保功率为非负值。\n$$P(t) = \\max(0, \\min(P_{\\mathrm{DC}}(t), P_{\\mathrm{rated}}))$$\n\n对于风能和光伏系统，为期 $N$ 小时的容量因子（$CF$）被定义为实际总发电量与如果系统在整个期间以其额定功率 $P_{\\mathrm{rated}}$ 运行可能产生的最大能量之比。\n$$CF = \\frac{\\sum_{t=1}^{N} P(t) \\cdot (1\\,\\text{hr})}{P_{\\mathrm{rated}} \\cdot N \\cdot (1\\,\\text{hr})} = \\frac{\\sum_{t=1}^{N} P(t)}{P_{\\mathrm{rated}} \\cdot N}$$\n使用推导出的 $P(t)$ 函数，我们可以为每个提供的测试案例计算容量因子。所有计算将保持功率单位为 $\\mathrm{kW}$，如指定。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# No other libraries are needed for this problem.\n\ndef solve():\n    \"\"\"\n    Derives and implements models for wind and PV power generation to calculate\n    capacity factors for a given set of test cases.\n    \"\"\"\n\n    # --- Model Implementation ---\n\n    def calculate_wind_power_series(v_series, p_rated, v_ci, v_r, v_co):\n        \"\"\"\n        Calculates hourly power output for a wind turbine from a wind speed series.\n        \n        Args:\n            v_series (list or np.array): Hourly wind speeds in m/s.\n            p_rated (float): Rated power in kW.\n            v_ci (float): Cut-in speed in m/s.\n            v_r (float): Rated speed in m/s.\n            v_co (float): Cut-out speed in m/s.\n\n        Returns:\n            np.array: Hourly power output in kW.\n        \"\"\"\n        v = np.array(v_series, dtype=float)\n        power = np.zeros_like(v)\n\n        # Region 1: Normal operation between cut-in and rated speed\n        # P(v) = P_rated * (v^3 - v_ci^3) / (v_r^3 - v_ci^3)\n        op_mask = (v >= v_ci) & (v < v_r)\n        v_op = v[op_mask]\n        \n        # Avoid division by zero if v_r = v_ci, though not expected for valid problems\n        v_r3_minus_v_ci3 = v_r**3 - v_ci**3\n        if v_r3_minus_v_ci3 > 0:\n            power[op_mask] = p_rated * (v_op**3 - v_ci**3) / v_r3_minus_v_ci3\n\n        # Region 2: Rated power output\n        rated_mask = (v >= v_r) & (v < v_co)\n        power[rated_mask] = p_rated\n\n        # Regions 3 & 4 (below cut-in and above cut-out) are already 0.\n        \n        return power\n\n    def calculate_pv_power_series(g_series, t_amb_series, p_rated, beta, noct):\n        \"\"\"\n        Calculates hourly power output for a PV system.\n        \n        Args:\n            g_series (list or np.array): Hourly plane-of-array irradiance in W/m^2.\n            t_amb_series (list or np.array): Hourly ambient temperature in °C.\n            p_rated (float): Rated power in kW.\n            beta (float): Power temperature coefficient in 1/°C.\n            noct (float): Nominal Operating Cell Temperature in °C.\n\n        Returns:\n            np.array: Hourly power output in kW.\n        \"\"\"\n        g = np.array(g_series, dtype=float)\n        t_amb = np.array(t_amb_series, dtype=float)\n        power = np.zeros_like(g)\n\n        # Constants from PV modeling standards\n        G_REF = 1000.0  # W/m^2 (STC irradiance)\n        T_REF = 25.0    # °C (STC cell temperature)\n        G_NOCT = 800.0  # W/m^2 (NOCT irradiance)\n        T_AMB_NOCT = 20.0 # °C (NOCT ambient temperature)\n\n        # Calculate only for hours with sunlight\n        sunlight_mask = g > 0\n        g_sun = g[sunlight_mask]\n        t_amb_sun = t_amb[sunlight_mask]\n\n        # 1. Calculate cell temperature using the NOCT model\n        t_cell = t_amb_sun + (noct - T_AMB_NOCT) * g_sun / G_NOCT\n\n        # 2. Calculate DC power with temperature adjustment\n        # P_potential = P_rated * G / G_ref\n        # P_dc = P_potential * (1 + beta * (T_cell - T_ref))\n        p_dc = (p_rated * g_sun / G_REF) * (1 + beta * (t_cell - T_REF))\n        \n        # 3. Apply inverter clipping and ensure non-negative power\n        p_final = np.maximum(0, np.minimum(p_dc, p_rated))\n\n        power[sunlight_mask] = p_final\n        return power\n\n    # --- Test Case Definitions ---\n    \n    test_cases = [\n        {\n            \"type\": \"wind\",\n            \"params\": {\n                \"v_series\": [0, 2.5, 3, 6, 10, 12, 15, 24, 26, 8],\n                \"p_rated\": 3000.0, \"v_ci\": 3.0, \"v_r\": 12.0, \"v_co\": 25.0\n            }\n        },\n        {\n            \"type\": \"wind\",\n            \"params\": {\n                \"v_series\": [0, 1, 2, 2.9, 0.5, 2.8, 2.999, 2, 1.5, 0],\n                \"p_rated\": 3000.0, \"v_ci\": 3.0, \"v_r\": 12.0, \"v_co\": 25.0\n            }\n        },\n        {\n            \"type\": \"pv\",\n            \"params\": {\n                \"g_series\": [0, 0, 200, 400, 600, 800, 1000, 800, 400, 0],\n                \"t_amb_series\": [15, 15, 16, 17, 18, 20, 22, 24, 22, 18],\n                \"p_rated\": 500.0, \"beta\": -0.004, \"noct\": 45.0\n            }\n        },\n        {\n            \"type\": \"pv\",\n            \"params\": {\n                \"g_series\": [0, 300, 600, 900, 1100, 1200, 1100, 900, 600, 300],\n                \"t_amb_series\": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n                \"p_rated\": 1000.0, \"beta\": -0.004, \"noct\": 45.0\n            }\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        params = case[\"params\"]\n        p_rated = params[\"p_rated\"]\n        \n        if case[\"type\"] == \"wind\":\n            power_series = calculate_wind_power_series(**params)\n            N = len(params[\"v_series\"])\n        elif case[\"type\"] == \"pv\":\n            power_series = calculate_pv_power_series(**params)\n            N = len(params[\"g_series\"])\n        \n        # Calculate Capacity Factor\n        # CF = sum(P_t) / (P_rated * N)\n        total_energy_generated = np.sum(power_series)\n        max_possible_energy = p_rated * N\n        \n        if max_possible_energy == 0:\n            capacity_factor = 0.0\n        else:\n            capacity_factor = total_energy_generated / max_possible_energy\n            \n        results.append(capacity_factor)\n\n    # Format results to six decimal places for the final output\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "风资源评估的一个关键挑战是，气象数据通常在标准高度（如10米）测量，而现代风力涡轮机的高度则要高得多。本练习将引导您应用微气象学中的莫宁-奥布霍夫相似性理论（Monin-Obukhov Similarity Theory），根据地表粗糙度和大气稳定性，将地面风速精确地外推至轮毂高度。这个过程是确保风能发电量预测准确性的核心技术环节。",
            "id": "4093433",
            "problem": "您的任务是实现一个垂直风速外推，该外推使用Monin–Obukhov相似性理论（MOST）框架，适用于大气表面层，并适用于地理空间和高分辨率时空资源建模。从MOST梯度关系式出发，该关系式在水平均匀条件下将平均风速廓线与表面层湍流联系起来。具体来说，以平均水平风速$\\bar{v}(z)$的垂直梯度遵循以下基本定义为基础\n$$\n\\frac{d\\,\\bar{v}}{d z} = \\frac{u_*}{\\kappa\\, z}\\,\\phi_m\\!\\left(\\frac{z}{L}\\right),\n$$\n其中$u_*$是摩擦速度，$\\kappa$是von Kármán常数，$z$是地表以上的高度，$L$是Monin–Obukhov长度，$\\phi_m$是动量的无量纲稳定度函数。使用物理边界条件，即在空气动力学粗糙度长度$z_0$处的平均风速为零，即$\\bar{v}(z_0)=0$。假设条件为水平均匀和定常，表面层内通量恒定，并忽略零平面位移高度。von Kármán常数为$\\kappa = 0.4$。\n\n对于稳定度函数$\\phi_m(\\zeta)$，其中$\\zeta = z/L$，使用广为接受的Businger–Dyer形式：\n- 对于稳定层结（$\\zeta > 0$），取$\\phi_m(\\zeta) = 1 + 5 \\zeta$。\n- 对于中性层结（极限$\\zeta \\to 0$），取$\\phi_m(\\zeta) = 1$。\n- 对于不稳定层结（$\\zeta < 0$），取$\\phi_m(\\zeta) = (1 - 16 \\zeta)^{-1/4}$。\n\n您的任务是：\n1. 通过将梯度关系式从$z_0$积分到一般高度$z$，推导出$\\bar{v}(z)$的表达式。该表达式需对所有三种稳定度状况都有效，并在中性层结下简化为经典的对数风廓线。\n2. 对于给定的$z_0$和$L$，展示如何根据参考高度$z_{\\mathrm{ref}}$处的风速测量值$\\bar{v}(z_{\\mathrm{ref}})$计算$u_*$。\n3. 使用推导出的表达式，根据输入$(z_0, z_{\\mathrm{ref}}, z_h, \\bar{v}(z_{\\mathrm{ref}}), L)$计算轮毂高度风速$\\bar{v}(z_h)$，其中$\\kappa = 0.4$。\n\n实现一个程序，对以下参数集测试套件，计算以米/秒为单位的$\\bar{v}(z_h)$。通过将$L$取为一个数量级很大的数来处理中性层结情况，并一致地实现中性极限。使用以下四个测试用例：\n\n- A用例（中性，典型矮植被）：$z_0 = 0.03$米，$z_{\\mathrm{ref}} = 10$米，$z_h = 100$米，$\\bar{v}(z_{\\mathrm{ref}}) = 6.0$米/秒，$L = 1\\times 10^{9}$米。\n- B用例（不稳定，光滑水面）：$z_0 = 0.0002$米，$z_{\\mathrm{ref}} = 10$米，$z_h = 120$米，$\\bar{v}(z_{\\mathrm{ref}}) = 8.0$米/秒，$L = -50.0$米。\n- C用例（稳定，森林地形）：$z_0 = 1.0$米，$z_{\\mathrm{ref}} = 30$米，$z_h = 80$米，$\\bar{v}(z_{\\mathrm{ref}}) = 7.0$米/秒，$L = 200.0$米。\n- D用例（弱稳定，城市粗糙度）：$z_0 = 2.0$米，$z_{\\mathrm{ref}} = 20$米，$z_h = 150$米，$\\bar{v}(z_{\\mathrm{ref}}) = 5.0$米/秒，$L = 100.0$米。\n\n实现要求：\n- 使用MOST梯度关系式的积分来构建$\\bar{v}(z)$，用一个适当定义的积分稳定度修正项来表示结果。确保在$L \\to \\infty$时能恢复到中性极限。\n- 使用$z_{\\mathrm{ref}}$处的测量值计算摩擦速度$u_*$，然后为每个用例计算$\\bar{v}(z_h)$。\n- 所有最终答案以米/秒为单位表示，并四舍五入到三位小数。程序必须生成单行输出，包含一个用方括号括起来的逗号分隔列表，例如$[\\text{result}_A,\\text{result}_B,\\text{result}_C,\\text{result}_D]$，其中每个$\\text{result}_\\cdot$是四舍五入到三位小数的浮点数。不得有其他打印文本。\n\n您的程序必须是完整且可直接运行的，无需用户输入，且仅使用指定的环境。",
            "solution": "该问题要求基于Monin–Obukhov相似性理论（MOST）实现一个垂直风速外推模型。该过程始于对问题陈述的验证。\n\n### 步骤1：提取已知条件\n- **控制微分方程：** 平均水平风速$\\bar{v}(z)$的垂直梯度由$\\frac{d\\,\\bar{v}}{d z} = \\frac{u_*}{\\kappa\\, z}\\,\\phi_m\\!\\left(\\frac{z}{L}\\right)$给出。\n- **参数和变量：**\n    - $u_*$：摩擦速度。\n    - $\\kappa$：von Kármán常数，给定为$0.4$。\n    - $z$：离地高度。\n    - $L$：Monin–Obukhov长度。\n    - $\\phi_m(\\zeta)$：动量的无量纲稳定度函数，其中$\\zeta = z/L$。\n    - $z_0$：空气动力学粗糙度长度。\n- **边界条件：** $\\bar{v}(z_0) = 0$。\n- **$\\phi_m(\\zeta)$的Businger–Dyer形式：**\n    - 稳定（$\\zeta > 0$）：$\\phi_m(\\zeta) = 1 + 5 \\zeta$。\n    - 中性（$\\zeta \\to 0$）：$\\phi_m(\\zeta) = 1$。\n    - 不稳定（$\\zeta < 0$）：$\\phi_m(\\zeta) = (1 - 16 \\zeta)^{-1/4}$。\n- **输入数据集：**\n    - A用例：$(z_0, z_{\\mathrm{ref}}, z_h, \\bar{v}(z_{\\mathrm{ref}}), L) = (0.03, 10, 100, 6.0, 1\\times 10^9)$。\n    - B用例：$(z_0, z_{\\mathrm{ref}}, z_h, \\bar{v}(z_{\\mathrm{ref}}), L) = (0.0002, 10, 120, 8.0, -50.0)$。\n    - C用例：$(z_0, z_{\\mathrm{ref}}, z_h, \\bar{v}(z_{\\mathrm{ref}}), L) = (1.0, 30, 80, 7.0, 200.0)$。\n    - D用例：$(z_0, z_{\\mathrm{ref}}, z_h, \\bar{v}(z_{\\mathrm{ref}}), L) = (2.0, 20, 150, 5.0, 100.0)$。\n- **输出要求：** 一个单行列表，包含每个用例的结果，格式为`[result_A,result_B,result_C,result_D]`，每个结果四舍五入到三位小数。\n\n### 步骤2：使用提取的已知条件进行验证\n该问题在科学上基于已建立的大气边界层物理学（Monin–Obukhov相似性理论）。所提供的方程、常数（$\\kappa$）和稳定度函数（$\\phi_m$）是微气象学中的标准形式。该问题是适定的，提供了一个微分方程和边界条件，从而导出一个唯一解。所有测试用例的输入数据对于指定条件（例如，地形粗糙度、稳定度）都是物理上现实的。问题陈述客观、精确，不包含矛盾或歧义。它与风资源建模直接相关。因此，该问题被认为是**有效的**。\n\n### 步骤3：风廓线的推导\n风速$\\bar{v}(z)$通过将梯度关系式从空气动力学粗糙度长度$z_0$积分到任意高度$z$来求得：\n$$\n\\int_{\\bar{v}(z_0)}^{\\bar{v}(z)} d\\bar{v}' = \\int_{z_0}^{z} \\frac{u_*}{\\kappa\\, z'}\\,\\phi_m\\!\\left(\\frac{z'}{L}\\right) dz'\n$$\n根据边界条件$\\bar{v}(z_0)=0$，可得：\n$$\n\\bar{v}(z) = \\frac{u_*}{\\kappa} \\int_{z_0}^{z} \\frac{1}{z'}\\,\\phi_m\\!\\left(\\frac{z'}{L}\\right) dz'\n$$\n这可以用积分稳定度修正函数$\\Psi_m(\\zeta)$来表示，其定义为$\\Psi_m(\\zeta) = \\int_{0}^{\\zeta} \\frac{1-\\phi_m(\\zeta')}{\\zeta'}d\\zeta'$。风廓线方程变为：\n$$\n\\bar{v}(z) = \\frac{u_*}{\\kappa} \\left[ \\ln\\left(\\frac{z}{z_0}\\right) - \\left(\\Psi_m\\left(\\frac{z}{L}\\right) - \\Psi_m\\left(\\frac{z_0}{L}\\right)\\right) \\right]\n$$\n我们现在推导每种稳定度状况下$\\Psi_m(\\zeta)$的形式。\n\n- **中性层结（$\\zeta \\to 0$）：**\n  $\\phi_m(\\zeta) = 1$。$\\Psi_m(\\zeta)$的被积函数为零，因此$\\Psi_m(\\zeta) = 0$。廓线简化为对数风廓线：\n  $$\n  \\bar{v}(z) = \\frac{u_*}{\\kappa} \\ln\\left(\\frac{z}{z_0}\\right)\n  $$\n\n- **稳定层结（$\\zeta > 0$）：**\n  $\\phi_m(\\zeta) = 1 + 5\\zeta$。\n  $$\n  \\Psi_m(\\zeta) = \\int_{0}^{\\zeta} \\frac{1 - (1 + 5\\zeta')}{\\zeta'} d\\zeta' = \\int_{0}^{\\zeta} -5 \\, d\\zeta' = -5\\zeta\n  $$\n  廓线方程中的稳定度修正项为$-\\left(\\Psi_m(z/L) - \\Psi_m(z_0/L)\\right) = -(-5z/L - (-5z_0/L)) = 5(z-z_0)/L$。然而，为了保持一致性和便于直接积分，对完整表达式进行积分更简单：\n  $$\n  \\int_{z_0}^{z} \\frac{1+5z'/L}{z'}dz' = \\left[\\ln(z') + \\frac{5z'}{L}\\right]_{z_0}^z = \\ln\\left(\\frac{z}{z_0}\\right) + \\frac{5(z-z_0)}{L}\n  $$\n  因此，廓线方程中括号内项的更直接表达式是$\\ln(z/z_0) + 5(z-z_0)/L$。我们对$\\Psi_m$的定义导出的修正项$-(\\Psi_m(z/L) - \\Psi_m(z_0/L))$给出了相同的结果。\n\n- **不稳定层结（$\\zeta < 0$）：**\n  $\\phi_m(\\zeta)=(1-16\\zeta)^{-1/4}$。对$\\frac{1-\\phi_m(\\zeta')}{\\zeta'}$的积分会得到一个标准但复杂的形式。令$x = (1-16\\zeta)^{1/4}$。得到的积分稳定度函数是：\n  $$\n  \\Psi_m(\\zeta) = 2\\ln\\left(\\frac{1+x}{2}\\right) + \\ln\\left(\\frac{1+x^2}{2}\\right) - 2\\arctan(x) + \\frac{\\pi}{2}\n  $$\n\n### 求解的算法设计\n令$F(z, z_0, L)$为风廓线方程中经$\\kappa$缩放的积分项：\n$$\nF(z, z_0, L) = \\ln\\left(\\frac{z}{z_0}\\right) - \\left(\\Psi_m\\left(\\frac{z}{L}\\right) - \\Psi_m\\left(\\frac{z_0}{L}\\right)\\right)\n$$\n那么风廓线为$\\bar{v}(z) = \\frac{u_*}{\\kappa} F(z, z_0, L)$。\n\n为解决该问题，我们遵循一个两步过程：\n1.  **计算摩擦速度（$u_*$）：**\n    使用参考高度$z_{\\mathrm{ref}}$处的已知风速$\\bar{v}(z_{\\mathrm{ref}})$，我们可以解出$u_*$：\n    $$\n    u_* = \\frac{\\kappa \\, \\bar{v}(z_{\\mathrm{ref}})}{F(z_{\\mathrm{ref}}, z_0, L)}\n    $$\n\n2.  **计算轮毂高度风速（$\\bar{v}(z_h)$）：**\n    使用计算出的$u_*$，我们求出轮毂高度$z_h$处的风速：\n    $$\n    \\bar{v}(z_h) = \\frac{u_*}{\\kappa} F(z_h, z_0, L)\n    $$\n\n结合这两个步骤，我们可以直接从$\\bar{v}(z_{\\mathrm{ref}})$计算$\\bar{v}(z_h)$：\n$$\n\\bar{v}(z_h) = \\bar{v}(z_{\\mathrm{ref}}) \\frac{F(z_h, z_0, L)}{F(z_{\\mathrm{ref}}, z_0, L)}\n$$\n这种比率方法避免了$u_*$的中间计算，并且在数值上是稳定的。实现需要构建一个计算$F(z, z_0, L)$的函数，该函数能根据$L$的符号和大小正确选择稳定度修正。中性情况通过使用大数量级的$L$来处理，此时$\\zeta \\approx 0$，因此$\\Psi_m(\\zeta) \\approx 0$。为$|L|$设置一个阈值（例如$10^6$）来确定中性条件的实际边界。\n\n程序将通过为每个非中性状况定义一个$\\Psi_m(\\zeta)$函数以及一个计算每个测试用例最终比率的主函数来实现此逻辑。然后按要求格式化结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for hub-height wind speed using Monin-Obukhov Similarity Theory.\n    \"\"\"\n\n    def psi_m_unstable(zeta):\n        \"\"\"\n        Calculates the integrated stability correction function Psi_m for unstable conditions.\n        zeta = z/L, where zeta < 0.\n        \"\"\"\n        if zeta >= 0:\n            # This function is not defined for zeta >= 0. Return 0 as a safe fallback.\n            return 0.0\n        x = (1 - 16 * zeta)**0.25\n        term1 = 2 * np.log((1 + x) / 2)\n        term2 = np.log((1 + x**2) / 2)\n        term3 = -2 * np.arctan(x)\n        term4 = np.pi / 2\n        return term1 + term2 + term3 + term4\n\n    def psi_m_stable(zeta):\n        \"\"\"\n        Calculates the integrated stability correction function Psi_m for stable conditions.\n        zeta = z/L, where zeta > 0.\n        \"\"\"\n        if zeta <= 0:\n            # This function is not defined for zeta <= 0. Return 0 as a safe fallback.\n            return 0.0\n        return -5.0 * zeta\n\n    def get_profile_integral_term(z, z0, L):\n        \"\"\"\n        Computes the integrated wind profile term F(z, z0, L).\n        F(z, z0, L) = ln(z/z0) - (Psi_m(z/L) - Psi_m(z0/L))\n        \"\"\"\n        log_term = np.log(z / z0)\n\n        # A large L signifies neutral conditions. A threshold is used to handle this numerically.\n        if abs(L) > 1e6:  # Neutral condition threshold\n            psi_m_z = 0.0\n            psi_m_z0 = 0.0\n        elif L > 0:  # Stable conditions\n            zeta_z = z / L\n            zeta_z0 = z0 / L\n            psi_m_z = psi_m_stable(zeta_z)\n            psi_m_z0 = psi_m_stable(zeta_z0)\n        else:  # Unstable conditions (L < 0)\n            zeta_z = z / L\n            zeta_z0 = z0 / L\n            psi_m_z = psi_m_unstable(zeta_z)\n            psi_m_z0 = psi_m_unstable(zeta_z0)\n\n        stability_correction = psi_m_z - psi_m_z0\n        return log_term - stability_correction\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A (neutral, typical short vegetation)\n        {'z0': 0.03, 'z_ref': 10, 'z_h': 100, 'v_ref': 6.0, 'L': 1e9},\n        # Case B (unstable, smooth water)\n        {'z0': 0.0002, 'z_ref': 10, 'z_h': 120, 'v_ref': 8.0, 'L': -50.0},\n        # Case C (stable, forested terrain)\n        {'z0': 1.0, 'z_ref': 30, 'z_h': 80, 'v_ref': 7.0, 'L': 200.0},\n        # Case D (slightly stable, urban roughness)\n        {'z0': 2.0, 'z_ref': 20, 'z_h': 150, 'v_ref': 5.0, 'L': 100.0}\n    ]\n\n    results = []\n    for case in test_cases:\n        z0 = case['z0']\n        z_ref = case['z_ref']\n        z_h = case['z_h']\n        v_ref = case['v_ref']\n        L = case['L']\n\n        # Calculate the integrated terms for reference and hub heights\n        F_ref = get_profile_integral_term(z_ref, z0, L)\n        F_h = get_profile_integral_term(z_h, z0, L)\n\n        # Calculate hub-height wind speed using the ratio method\n        v_h = v_ref * (F_h / F_ref)\n        \n        # Round to three decimal places and store the result\n        results.append(f\"{v_h:.3f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "一旦确定了富含可再生能源的区域，接下来的挑战就是如何以最低的成本和最小的环境影响将其接入电网。本练习将指导您使用基于栅格的最小成本路径分析方法，来规划输电走廊。您将学习如何综合考虑地形坡度、保护区限制等多种地理空间数据，以解决一个实际的能源基础设施规划优化问题。",
            "id": "4093384",
            "problem": "您的任务是为离散栅格上的输电走廊设计实现一个最小成本路径（LCP）程序。目标是根据一个对坡度和保护区进行惩罚的成本表面，形式化并计算最小总路径成本及相应的路径长度。该公式必须基于具有物理意义的定义。程序必须解决所提供测试套件中指定的案例，并以要求的格式输出最终结果。\n\n定义和建模基础：\n- 走廊设计问题假设在一个具有均匀间距的常规单元格网格上进行。设单元格大小为 $c$ 米。设高程场为数字高程模型（DEM）$Z(i,j)$，单位为米。设保护区掩码为 $P(i,j)$，其中 $P(i,j)=1$ 表示受保护的单元格，否则 $P(i,j)=0$。所有移动都限制在 $8$ 连通邻域内（基本方向和对角线方向移动）。\n- 一个位置的单位长度通行成本建模为\n$$\nC(i,j) = \\gamma + \\alpha \\cdot \\theta(i,j) + \\beta \\cdot P(i,j),\n$$\n其中 $\\gamma$ 是基础成本（美元/米），$\\alpha$ 是坡度惩罚系数（美元/米/弧度），$\\beta$ 是保护区惩罚（美元/米），$\\theta(i,j)$ 是局部坡度角（弧度）。\n- 局部坡度角 $\\theta(i,j)$ 源自表面梯度的大小。通过有限差分来近似偏导数：\n$$\ng_x(i,j)=\n\\begin{cases}\n\\dfrac{Z(i+1,j)-Z(i,j)}{c} & \\text{if } i=0, \\\\\n\\dfrac{Z(i,j)-Z(i-1,j)}{c} & \\text{if } i=n_x-1, \\\\\n\\dfrac{Z(i+1,j)-Z(i-1,j)}{2c} & \\text{otherwise},\n\\end{cases}\n\\qquad\ng_y(i,j)=\n\\begin{cases}\n\\dfrac{Z(i,j+1)-Z(i,j)}{c} & \\text{if } j=0, \\\\\n\\dfrac{Z(i,j)-Z(i,j-1)}{c} & \\text{if } j=n_y-1, \\\\\n\\dfrac{Z(i,j+1)-Z(i,j-1)}{2c} & \\text{otherwise}.\n\\end{cases}\n$$\n则坡度大小为\n$$\nm(i,j)=\\sqrt{g_x(i,j)^2+g_y(i,j)^2},\n$$\n坡度角为\n$$\n\\theta(i,j)=\\arctan\\!\\big(m(i,j)\\big),\n$$\n以弧度表示。\n- 对于从单元格 $i$ 到 $8$ 连通邻域中相邻单元格 $j$ 的移动，边长 $d_{ij}$ 为\n$$\nd_{ij}=\n\\begin{cases}\nc & \\text{对于基本方向移动},\\\\\nc\\sqrt{2} & \\text{对于对角线方向移动}。\n\\end{cases}\n$$\n为将路径上的成本线积分离散化，使用梯形法则近似边通行成本，\n$$\nw_{ij}=d_{ij}\\cdot \\dfrac{C(i)+C(j)}{2}。\n$$\n总路径成本是沿所选路径的 $w_{ij}$ 之和，路径长度是沿该路径的 $d_{ij}$ 之和。\n- 在网格上计算指定起始单元格 $(s_x,s_y)$ 和目标单元格 $(t_x,t_y)$ 之间的最小成本路径，将每个单元格视为图中一个节点，其边权重如上定义的 $w_{ij}$。实现一个与非负边权重一致的路径搜索方法。\n\n角度单位要求：\n- 所有角度必须以弧度计算和使用。\n\n单位和输出要求：\n- 最终路径长度以米表示，最终路径成本以美元表示。将两个数字都四舍五入到 $3$ 位小数。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例的结果是一个双元素列表 $[ \\text{total\\_cost}, \\text{route\\_length} ]$。例如，输出应类似于 $[[x_1,y_1],[x_2,y_2],\\dots]$，不含空格。\n\n测试套件：\n为以下参数集实现算法。在每种情况下，$Z$ 的单位是米，$P$ 是无量纲的，值为 $0$ 或 $1$，$c$ 的单位是米，成本 $\\gamma$、$\\alpha$ 和 $\\beta$ 的单位是美元/米（其中 $\\alpha$ 的单位是每弧度）。\n\n案例 1（具有中央保护区的常规路径）：\n- 网格大小：$n_x=5$, $n_y=5$。\n- 单元格大小：$c=100$。\n- 高程 $Z$：\n$$\n\\begin{bmatrix}\n100 & 120 & 140 & 160 & 180 \\\\\n100 & 120 & 140 & 160 & 200 \\\\\n100 & 120 & 160 & 200 & 240 \\\\\n100 & 120 & 160 & 200 & 240 \\\\\n90 & 110 & 130 & 150 & 170\n\\end{bmatrix}\n$$\n- 保护区掩码 $P$：\n$$\n\\begin{bmatrix}\n0 & 0 & 0 & 0 & 0 \\\\\n0 & 0 & 1 & 1 & 0 \\\\\n0 & 1 & 1 & 1 & 0 \\\\\n0 & 0 & 1 & 0 & 0 \\\\\n0 & 0 & 0 & 0 & 0\n\\end{bmatrix}\n$$\n- 参数：$\\gamma=500$, $\\alpha=1000$, $\\beta=4000$。\n- 起点和终点：$(s_x,s_y)=(0,0)$, $(t_x,t_y)=(4,4)$。\n\n案例 2（起点等于终点，平坦地形）：\n- 网格大小：$n_x=3$, $n_y=3$。\n- 单元格大小：$c=50$。\n- 高程 $Z$：\n$$\n\\begin{bmatrix}\n0 & 0 & 0 \\\\\n0 & 0 & 0 \\\\\n0 & 0 & 0\n\\end{bmatrix}\n$$\n- 保护区掩码 $P$：\n$$\n\\begin{bmatrix}\n0 & 0 & 0 \\\\\n0 & 0 & 0 \\\\\n0 & 0 & 0\n\\end{bmatrix}\n$$\n- 参数：$\\gamma=400$, $\\alpha=800$, $\\beta=2000$。\n- 起点和终点：$(s_x,s_y)=(1,1)$, $(t_x,t_y)=(1,1)$。\n\n案例 3（山脊引发的坡度惩罚和一个小型受保护单元格）：\n- 网格大小：$n_x=4$, $n_y=4$。\n- 单元格大小：$c=100$。\n- 高程 $Z$：\n$$\n\\begin{bmatrix}\n0 & 0 & 0 & 0 \\\\\n0 & 50 & 200 & 250 \\\\\n0 & 50 & 200 & 250 \\\\\n0 & 0 & 0 & 0\n\\end{bmatrix}\n$$\n- 保护区掩码 $P$：\n$$\n\\begin{bmatrix}\n0 & 0 & 0 & 0 \\\\\n0 & 0 & 1 & 0 \\\\\n0 & 0 & 0 & 0 \\\\\n0 & 0 & 0 & 0\n\\end{bmatrix}\n$$\n- 参数：$\\gamma=600$, $\\alpha=1200$, $\\beta=3000$。\n- 起点和终点：$(s_x,s_y)=(0,3)$, $(t_x,t_y)=(3,0)$。\n\n案例 4（绕过受保护屏障的走廊规避）：\n- 网格大小：$n_x=6$, $n_y=6$。\n- 单元格大小：$c=200$。\n- 高程 $Z$：\n$$\n\\begin{bmatrix}\n0 & 10 & 20 & 30 & 40 & 50 \\\\\n10 & 20 & 30 & 40 & 50 & 60 \\\\\n20 & 30 & 40 & 50 & 60 & 70 \\\\\n30 & 40 & 50 & 60 & 70 & 80 \\\\\n40 & 50 & 60 & 70 & 80 & 90 \\\\\n50 & 60 & 70 & 80 & 90 & 100\n\\end{bmatrix}\n$$\n- 保护区掩码 $P$：\n$$\n\\begin{bmatrix}\n0 & 0 & 1 & 0 & 0 & 0 \\\\\n0 & 0 & 1 & 0 & 0 & 0 \\\\\n0 & 0 & 1 & 1 & 1 & 0 \\\\\n0 & 0 & 1 & 0 & 0 & 0 \\\\\n0 & 0 & 1 & 0 & 0 & 0 \\\\\n0 & 0 & 1 & 0 & 0 & 0\n\\end{bmatrix}\n$$\n- 参数：$\\gamma=700$, $\\alpha=900$, $\\beta=5000$。\n- 起点和终点：$(s_x,s_y)=(0,0)$, $(t_x,t_y)=(5,5)$。\n\n实现和输出：\n- 按规定实现坡度计算，计算 $C(i,j)$，建立具有边权重 $w_{ij}$ 的 $8$ 连通图，并找到从起点到终点的最小成本路径。计算总路径成本和总路径长度。所有角度计算均使用弧度。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例的结果格式为 $[\\text{total\\_cost},\\text{route\\_length}]$，四舍五入到 $3$ 位小数，不含空格。例如：$[[x_1,y_1],[x_2,y_2],[x_3,y_3],[x_4,y_4]]$。",
            "solution": "### 问题验证\n\n**步骤 1：提取给定信息**\n-   **网格：** 一个具有均匀间距 `$c$`（米）的常规单元格网格，一个高程场 `$Z(i,j)`（米），以及一个保护区掩码 `$P(i,j)`（1 表示受保护，0 表示其他）。网格尺寸为 `$n_x \\times n_y$`。\n-   **移动：** 限制在 `$8$` 连通邻域内（基本方向和对角线方向移动）。\n-   **单位长度通行成本：** 在每个单元格 `$(i,j)$` 定义为 `$C(i,j) = \\gamma + \\alpha \\cdot \\theta(i,j) + \\beta \\cdot P(i,j)$`，其中 `$\\gamma$` 是基础成本（$/m），`$\\alpha$` 是坡度惩罚（$/m/弧度），`$\\beta$` 是保护区惩罚（$/m）。\n-   **坡度计算：**\n    -   高程的偏导数 `$g_x(i,j)$` 和 `$g_y(i,j)$` 使用边界处的一阶前向/后向有限差分和内部的二阶中心差分进行近似。\n    -   坡度大小为 `$m(i,j) = \\sqrt{g_x(i,j)^2 + g_y(i,j)^2}$`。\n    -   坡度角为 `$\\theta(i,j) = \\arctan(m(i,j))$`，单位为弧度。\n-   **边通行成本：** 从相邻单元格 `$i$` 移动到 `$j$` 的成本为 `$w_{ij} = d_{ij} \\cdot \\frac{C(i)+C(j)}{2}$`，其中边长 `$d_{ij}$` 对于基本方向移动是 `$c$`，对于对角线方向移动是 `$c\\sqrt{2}$`。\n-   **目标：** 计算从起始单元格 `$(s_x, s_y)$` 到目标单元格 `$(t_x, t_y)$` 的最小总路径成本（`$w_{ij}$` 之和）和相应的路径长度（`$d_{ij}$` 之和）。\n-   **算法约束：** 路径搜索方法必须与非负边权重一致。\n-   **测试用例：** 提供了四个完整的参数集，指定了 `$Z, P, c, \\gamma, \\alpha, \\beta$`，以及起点和终点坐标。\n-   **输出：** 一个单行字符串 `[[cost1,length1],[cost2,length2],...]`，数值四舍五入到 $3$ 位小数。\n\n**步骤 2：使用提取的给定信息进行验证**\n根据验证标准评估此问题：\n-   **科学性（关键）：** 该问题牢固地植根于地理空间科学和运筹学等成熟领域。在栅格表面上进行最小成本路径（LCP）分析是各种领域中路线规划的标准技术，包括生态学、土木工程和城市规划。成本模型虽然是线性的简化，但基于具有物理意义的因素：内在建设成本（`$\\gamma$`）、地形难度（坡度惩罚 `$\\alpha$`）和土地使用限制（保护区惩罚 `$\\beta$`）。通过有限差分计算坡度以及通过数值积分（梯形法则）计算路径成本的数学公式都是标准且适当的数值方法。\n-   **适定性：** 问题是适定的。它要求在一个图中的离散路径集合上最小化一个成本函数。由于成本参数 `$\\gamma, \\alpha, \\beta$` 是非负的，坡度角 `$\\theta(i,j)` 也是非负的，因此单位长度成本 `$C(i,j)$` 和边权重 `$w_{ij}$` 都保证是非负的。这确保了像迪杰斯特拉（Dijkstra）这样的最短路径算法能够找到一个稳定且值唯一的最小成本。计算所需的所有数据和常数都在测试套件中提供。\n-   **客观性（关键）：** 问题是使用精确、客观的数学语言来规定的。所有术语都已定义，计算过程也被明确描述。没有主观或基于意见的元素。\n\n该问题没有表现出任何使其无效的缺陷。它在科学上是合理的，规格是完整的，是客观的，并且需要实现一个非平凡的标准算法。\n\n**步骤 3：结论与行动**\n问题是**有效的**。将开发一个解决方案。\n\n### 算法解决方案\n在栅格网格上寻找最小成本路径的问题，可以通过将网格建模为图并应用最短路径算法来解决。每个网格单元 `$(i,j)$` 是图中的一个节点，边连接每个节点到其8个邻居。该解决方案的核心包括三个阶段：计算成本表面，定义图的边权重，以及执行迪杰斯特拉算法以找到最优路径。\n\n**1. 成本表面计算**\n路径的总成本取决于每个单元格的单位长度通行成本 `$C(i,j)$`。此成本是局部坡度角 `$\\theta(i,j)$` 和保护区状态 `$P(i,j)$` 的函数。\n\n首先，我们计算整个网格的坡度。高程的偏导数 `$g_x$` 和 `$g_y$` 根据指定的有限差分公式计算。这些公式与 `numpy.gradient` 函数在提供均匀间距 `$c$` 时的行为完全对应。具体来说，对于高程网格 `$Z$`，`g_y, g_x = np.gradient(Z, c)`，其中 `g_y` 是沿第一轴（行，索引 `$i$`）的梯度，`g_x` 是沿第二轴（列，索引 `$j$`）的梯度。这种向量化方法效率很高。（注意：`np.gradient` 返回 `dy, dx`，对应于 `d/d_axis0, d/d_axis1`，在我们的 `(row, col)` 或 `(i, j)` 约定中，这对应于 `g_i, g_j`。为与问题中的 `g_x, g_y` 保持一致，需要注意轴的对应关系，这里 `i` 是行索引（`y`方向），`j`是列索引（`x`方向）。因此 `g_i, g_j = np.gradient(Z, c)`）。\n\n根据梯度，为每个单元格计算坡度大小 `$m(i,j) = \\sqrt{g_x(i,j)^2 + g_y(i,j)^2}$`。然后使用 `$\\theta(i,j) = \\arctan(m(i,j))$` 计算以弧度为单位的坡度角。\n\n有了坡度角网格 `$\\theta$` 和保护区掩码 `$P$`，使用给定的线性模型计算单位长度成本网格 `$C$`：`$C(i,j) = \\gamma + \\alpha \\cdot \\theta(i,j) + \\beta \\cdot P(i,j)$`。这就创建了一个完整的“成本表面”，其中每个单元格都有一个相关的每米行程成本。\n\n**2. 图遍历与边权重**\n网格隐含地定义了一个图。从一个单元格 `$(i,j)$` 移动到相邻单元格 `$(k,l)$` 对应于遍历一条边。这条边的权重 `$w$` 代表该移动段的总成本。它按照指定的梯形法则计算：`$w = d \\cdot \\frac{C(i,j) + C(k,l)}{2}$`。距离 `$d$` 对于基本方向移动（水平或垂直）是 `$c$`，对于对角线方向移动是 `$c\\sqrt{2}$`。\n\n**3. 迪杰斯特拉（Dijkstra）最短路径算法**\n由于所有边权重都是非负的，迪杰斯特拉算法是寻找从起始单元格 `$(s_x, s_y)$` 到目标单元格 `$(t_x, t_y)$` 的最小成本路径的合适方法。该算法使用优先队列（最小堆）来实现，以高效地选择下一个要访问的单元格。\n\n我们维护两个与输入维度相同的网格：\n-   `dist(i,j)`：存储从起始单元格到单元格 `$(i,j)$` 所找到的最小累积成本。除起始单元格 `dist(s_x, s_y) = 0` 外，所有单元格都初始化为无穷大。\n-   `length(i,j)`：存储与到 `$(i,j)` 的最小成本路径相对应的物理路径长度。它的初始化方式与 `dist` 类似，`length(s_x, s_y) = 0`。\n\n优先队列存储 `(cost, (row, col))` 元组。它以 `(0.0, (s_x, s_y))` 初始化。\n\n算法流程如下：\n1.  从优先队列中弹出成本最小的单元格。设其为单元格 `$u$`。\n2.  如果 `$u$` 之前已被访问过，则跳过。否则，将其标记为已访问。\n3.  如果 `$u$` 是目标单元格，算法终止，因为到它的最短路径已经找到。\n4.  对于 `$u$` 的 `$8$` 个邻居中的每一个 `$v$`：\n    a. 计算边长 `$d_{uv}$` 和边成本 `$w_{uv}$`。\n    b. 计算通过 `$u$` 到达 `$v$` 的新的潜在成本：`new_cost = dist(u) + w_{uv}`。\n    c. 如果 `new_cost < dist(v)`，则找到了到 `$v$` 的更短路径。更新 `dist(v) = new_cost`，更新 `length(v) = length(u) + d_{uv}`，并将 `(new_cost, v)` 推入优先队列。\n\n算法终止后，`dist(t_x, t_y)` 和 `length(t_x, t_y)` 分别保存最终的总成本和路径长度。然后将这些值按要求四舍五入到三位小数。对于起点和终点相同的平凡情况，作为特殊情况处理，返回成本和长度均为 `$0.0$`。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\nimport heapq\n\ndef _calculate_path(Z, P, c, gamma, alpha, beta, start, target):\n    \"\"\"\n    Calculates the least-cost path cost and length on a raster grid.\n    Note: The problem defines (i,j) where i is the row index (y-axis) and j is the column index (x-axis).\n    The start/target coordinates are given as (s_x, s_y), which means (col, row). We will use (row, col) internally.\n    \"\"\"\n    start_node = (start[1], start[0])\n    target_node = (target[1], target[0])\n\n    if start_node == target_node:\n        return [0.0, 0.0]\n\n    Z = np.array(Z, dtype=float)\n    P = np.array(P, dtype=float)\n    n_rows, n_cols = Z.shape\n\n    # Step 1: Compute slope and cost grids\n    # The finite difference formulas match numpy's gradient function.\n    # np.gradient returns derivatives along each axis. For a 2D array, it returns (d/d_axis0, d/d_axis1).\n    # In our (row, col) convention, this is (d/d_row, d/d_col).\n    # The problem's g_x corresponds to d/d_col and g_y to d/d_row.\n    # So, g_y, g_x = np.gradient(Z, c).\n    g_y, g_x = np.gradient(Z, c)\n    \n    m = np.sqrt(g_x**2 + g_y**2)\n    theta = np.arctan(m)\n    \n    C = gamma + alpha * theta + beta * P\n\n    # Step 2: Dijkstra's algorithm\n    dist = np.full((n_rows, n_cols), np.inf)\n    length = np.full((n_rows, n_cols), np.inf)\n    \n    dist[start_node] = 0.0\n    length[start_node] = 0.0\n    \n    # Priority queue stores (cost, (row, col))\n    pq = [(0.0, start_node)]\n    \n    sqrt2c = c * np.sqrt(2)\n\n    while pq:\n        cost, current_node = heapq.heappop(pq)\n        \n        # If we've found a shorter path already, skip.\n        if cost > dist[current_node]:\n            continue\n        \n        if current_node == target_node:\n            break\n            \n        r, c_node = current_node\n        \n        # Explore 8-connected neighbors\n        for dr in [-1, 0, 1]:\n            for dc in [-1, 0, 1]:\n                if dr == 0 and dc == 0:\n                    continue\n                \n                nr, nc = r + dr, c_node + dc\n                neighbor_node = (nr, nc)\n                \n                if not (0 <= nr < n_rows and 0 <= nc < n_cols):\n                    continue\n\n                # Calculate edge length and cost\n                is_cardinal = (dr == 0 or dc == 0)\n                d_ij = c if is_cardinal else sqrt2c\n                \n                # Trapezoidal rule for edge weight\n                avg_cost = (C[current_node] + C[neighbor_node]) / 2.0\n                w_ij = d_ij * avg_cost\n                \n                new_cost = dist[current_node] + w_ij\n                \n                if new_cost < dist[neighbor_node]:\n                    dist[neighbor_node] = new_cost\n                    length[neighbor_node] = length[current_node] + d_ij\n                    heapq.heappush(pq, (new_cost, neighbor_node))\n\n    final_cost = dist[target_node]\n    final_length = length[target_node]\n    \n    return [round(final_cost, 3), round(final_length, 3)]\n\ndef solve():\n    \"\"\"\n    Main solver function to run all test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"Z\": [[100, 120, 140, 160, 180],\n                  [100, 120, 140, 160, 200],\n                  [100, 120, 160, 200, 240],\n                  [100, 120, 160, 200, 240],\n                  [90, 110, 130, 150, 170]],\n            \"P\": [[0, 0, 0, 0, 0],\n                  [0, 0, 1, 1, 0],\n                  [0, 1, 1, 1, 0],\n                  [0, 0, 1, 0, 0],\n                  [0, 0, 0, 0, 0]],\n            \"c\": 100, \"gamma\": 500, \"alpha\": 1000, \"beta\": 4000,\n            \"start\": (0, 0), \"target\": (4, 4)\n        },\n        {\n            \"Z\": [[0, 0, 0], [0, 0, 0], [0, 0, 0]],\n            \"P\": [[0, 0, 0], [0, 0, 0], [0, 0, 0]],\n            \"c\": 50, \"gamma\": 400, \"alpha\": 800, \"beta\": 2000,\n            \"start\": (1, 1), \"target\": (1, 1)\n        },\n        {\n            \"Z\": [[0, 0, 0, 0],\n                  [0, 50, 200, 250],\n                  [0, 50, 200, 250],\n                  [0, 0, 0, 0]],\n            \"P\": [[0, 0, 0, 0],\n                  [0, 0, 1, 0],\n                  [0, 0, 0, 0],\n                  [0, 0, 0, 0]],\n            \"c\": 100, \"gamma\": 600, \"alpha\": 1200, \"beta\": 3000,\n            \"start\": (0, 3), \"target\": (3, 0) # start=(col,row), target=(col,row)\n        },\n        {\n            \"Z\": [[0, 10, 20, 30, 40, 50],\n                  [10, 20, 30, 40, 50, 60],\n                  [20, 30, 40, 50, 60, 70],\n                  [30, 40, 50, 60, 70, 80],\n                  [40, 50, 60, 70, 80, 90],\n                  [50, 60, 70, 80, 90, 100]],\n            \"P\": [[0, 0, 1, 0, 0, 0],\n                  [0, 0, 1, 0, 0, 0],\n                  [0, 0, 1, 1, 1, 0],\n                  [0, 0, 1, 0, 0, 0],\n                  [0, 0, 1, 0, 0, 0],\n                  [0, 0, 1, 0, 0, 0]],\n            \"c\": 200, \"gamma\": 700, \"alpha\": 900, \"beta\": 5000,\n            \"start\": (0, 0), \"target\": (5, 5)\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        # Note: the problem specifies start/target as (x,y) which maps to (col, row).\n        # The function expects (row, col) internally.\n        result = _calculate_path(\n            case[\"Z\"], case[\"P\"], case[\"c\"],\n            case[\"gamma\"], case[\"alpha\"], case[\"beta\"],\n            case[\"start\"], case[\"target\"]\n        )\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    result_str = \",\".join([f\"[{cost},{length}]\" for cost, length in results])\n    print(f\"[{result_str}]\")\n\nsolve()\n\n```"
        }
    ]
}