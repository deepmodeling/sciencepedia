{
    "hands_on_practices": [
        {
            "introduction": "Aggregation offers computational tractability but often at the cost of physical fidelity. This practice explores a foundational challenge in unit aggregation: the discrepancy that arises when a cluster of discrete, dispatchable units is represented by a single, continuous convex model. By working through a simplified unit commitment problem , you will uncover the \"feasibility gap\" and analyze its crucial operational implications, providing insight into why solutions from aggregated models are not always physically realizable.",
            "id": "4133909",
            "problem": "Consider a single-period Unit Commitment (UC) setting with a cluster of identical thermal generating units. There are $N$ identical units, each characterized by a binary on/off decision and a minimum stable operating level. The original disjunctive per-unit feasible set for power output $p_i$ and commitment $u_i$ is\n$$\n\\mathcal{S} \\;=\\; \\{(u_i,p_i) \\,\\mid\\, u_i \\in \\{0,1\\},\\; p_i = 0 \\text{ if } u_i=0,\\; P^{\\min} \\le p_i \\le P^{\\max} \\text{ if } u_i=1\\}.\n$$\nPower balance must hold exactly, and there is no spillage and no load curtailment.\n\nNow aggregate the $N$ identical units into a single cluster and consider the standard convex aggregation in which the integer number of committed units is relaxed to a continuous quantity $y \\in [0,N]$, and the cluster output $p$ satisfies the convex envelope implied by the convex hull of $\\mathcal{S}$:\n$$\ny \\in [0,N], \\qquad y\\,P^{\\min} \\le p \\le y\\,P^{\\max}.\n$$\n\nYou are given the following data defining a specific instance:\n- Number of units $N = 3$,\n- Minimum and maximum outputs $P^{\\min} = 50$ MW and $P^{\\max} = 100$ MW,\n- Net load to be served exactly $D = 30$ MW.\n\nTasks:\n1) Using only the model definitions above, construct a feasible point for the aggregated convex relaxation that meets the load exactly, and justify why it is feasible in the aggregated model.\n2) Prove that the original disjunctive integer UC model is infeasible for the same data.\n3) Define the feasibility gap $G$ as the minimum absolute power-balance violation (in MW) achievable by the original disjunctive model when the exact power-balance equality is replaced by an absolute-mismatch objective, that is,\n$$\nG \\;:=\\; \\min_{\\substack{u_i \\in \\{0,1\\}\\\\ p_i}} \\left| \\sum_{i=1}^{N} p_i \\;-\\; D \\right| \\quad \\text{subject to } (u_i,p_i) \\in \\mathcal{S} \\text{ for all } i \\in \\{1,\\ldots,N\\}.\n$$\nCompute $G$ for the given data. State $G$ in MW and round your answer to four significant figures.\n\nFinally, briefly explain the operational implications of the computed $G$ in terms of what physical actions (if any) would be required to realize the aggregated-relaxation dispatch with the original physical units. Your final numerical answer must be the single value of $G$ only (in MW, rounded as instructed).",
            "solution": "The problem statement has been validated and is deemed valid. It is scientifically grounded in the principles of power systems engineering and optimization, well-posed with a clear and complete setup, and objective in its formulation. We can therefore proceed with a full solution.\n\nThe problem asks for three tasks to be completed based on the provided data for a unit commitment problem: $N=3$ identical units, each with a minimum output of $P^{\\min} = 50$ MW and a maximum output of $P^{\\max} = 100$ MW. The net load to be served is $D = 30$ MW.\n\n**Task 1: Feasibility of the Aggregated Convex Relaxation**\n\nThe aggregated convex relaxation model is defined by the variables $y$, representing the continuous number of committed units, and $p$, the total power output of the cluster. The constraints are:\n$$(1) \\quad y \\in [0, N]$$\n$$(2) \\quad y P^{\\min} \\le p \\le y P^{\\max}$$\nWe are given $N=3$, $P^{\\min}=50$, and $P^{\\max}=100$. The model must also satisfy the power balance equation, which requires the total output to be equal to the load:\n$$(3) \\quad p = D$$\nGiven $D=30$, we need to find a value of $y$ that satisfies all constraints. Substituting $p=D=30$ into inequality $(2)$, we get:\n$$y \\times 50 \\le 30 \\le y \\times 100$$\nThis compound inequality can be separated into two parts:\n$$y \\times 50 \\le 30 \\implies y \\le \\frac{30}{50} \\implies y \\le 0.6$$\n$$30 \\le y \\times 100 \\implies y \\ge \\frac{30}{100} \\implies y \\ge 0.3$$\nSo, we must find a $y$ that satisfies $0.3 \\le y \\le 0.6$. We must also satisfy constraint $(1)$, which is $y \\in [0, 3]$. The interval $[0.3, 0.6]$ is a subset of $[0, 3]$, so any $y$ in $[0.3, 0.6]$ is valid.\n\nTo construct a feasible point, we can choose any value for $y$ in this range, for example, $y=0.4$. This gives the point $(y,p) = (0.4, 30)$.\nThis point is feasible in the aggregated model because:\n1.  The power output $p=30$ MW exactly meets the load $D=30$ MW.\n2.  The continuous commitment variable $y=0.4$ is within its allowed bounds, since $0 \\le 0.4 \\le 3$.\n3.  The generation inequality is satisfied: $y P^{\\min} \\le p \\le y P^{\\max}$ becomes $0.4 \\times 50 \\le 30 \\le 0.4 \\times 100$, which simplifies to $20 \\le 30 \\le 40$. This is a true statement.\nThus, a feasible point exists for the aggregated convex relaxation.\n\n**Task 2: Infeasibility of the Original Disjunctive Model**\n\nThe original disjunctive model requires the number of committed units, $n_{on} = \\sum_{i=1}^{3} u_i$, to be an integer, where $u_i \\in \\{0, 1\\}$. The total power output $P_{total} = \\sum_{i=1}^{3} p_i$ must equal the load $D=30$ MW. Each active unit $i$ (with $u_i=1$) must produce power $p_i$ in the range $[P^{\\min}, P^{\\max}]$, i.e., $[50, 100]$.\n\nLet's analyze the possible feasible total power outputs based on the integer number of committed units, $n_{on} \\in \\{0, 1, 2, 3\\}$.\n-   If $n_{on} = 0$: All units are off ($u_i=0$ for all $i$), so $p_i=0$ for all $i$. The total power output is $P_{total} = 0$ MW. This does not equal the load $D=30$ MW.\n-   If $n_{on} = 1$: One unit is on. Its power output $p_1$ must be in the range $[50, 100]$. The total power $P_{total} = p_1$ is therefore also in the range $[50, 100]$ MW. The required load $D=30$ MW is outside this range.\n-   If $n_{on} = 2$: Two units are on. The total power output $P_{total} = p_1 + p_2$ must be in the range $[2 \\times P^{\\min}, 2 \\times P^{\\max}]$, which is $[2 \\times 50, 2 \\times 100] = [100, 200]$ MW. The required load $D=30$ MW is outside this range.\n-   If $n_{on} = 3$: Three units are on. The total power output $P_{total} = p_1 + p_2 + p_3$ must be in the range $[3 \\times P^{\\min}, 3 \\times P^{\\max}]$, which is $[3 \\times 50, 3 \\times 100] = [150, 300]$ MW. The required load $D=30$ MW is outside this range.\n\nSince for every possible integer number of committed units, the range of achievable total power output does not include $D=30$ MW, it is impossible to satisfy the power balance constraint. Therefore, the original disjunctive integer UC model is infeasible for the given data.\n\n**Task 3: Computation of the Feasibility Gap $G$**\n\nThe feasibility gap $G$ is defined as the minimum possible absolute power-balance violation for the original disjunctive model:\n$$G = \\min_{\\substack{u_i \\in \\{0,1\\}\\\\ p_i}} \\left| \\sum_{i=1}^{N} p_i - D \\right| \\quad \\text{subject to } (u_i,p_i) \\in \\mathcal{S}$$\nWe need to find the feasible total power output $P_{total} = \\sum p_i$ that is closest to the load $D=30$ MW. The set of all possible values for $P_{total}$ is the union of the ranges we found in Task 2:\n$$\\text{Feasible } P_{total} \\in \\{0\\} \\cup [50, 100] \\cup [100, 200] \\cup [150, 300]$$\nThis simplifies to the set $\\{0\\} \\cup [50, 300]$. We want to find the point in this set that minimizes the distance to $30$.\n\nWe evaluate the distance for the two disjoint parts of the set:\n1.  For the point $P_{total}=0$, the mismatch is $|0 - 30| = 30$.\n2.  For the interval $P_{total} \\in [50, 300]$, the point closest to $30$ is the lower bound of the interval, which is $50$. The mismatch is $|50 - 30| = 20$.\n\nComparing the two minimum mismatches, $\\min(30, 20) = 20$.\nTherefore, the feasibility gap is $G = 20$ MW. Rounding to four significant figures gives $20.00$.\n\n**Operational Implications**\n\nThe existence of a feasible solution for the aggregated relaxation but not for the original integer model highlights the \"relaxation gap\". The aggregated model, often used for economic dispatch due to its convexity and computational tractability, produces a solution $(y,p)=(0.4, 30)$ that is economically desirable (serves the load exactly) but physically unrealizable with the given discrete units.\n\nThe feasibility gap $G=20$ MW quantifies the minimum extent to which physical reality must deviate from the relaxed model's target. The closest physically achievable dispatch to serving the $30$ MW load is to commit one unit and run it at its minimum stable level of $P^{\\min}=50$ MW. This results in a power surplus of $50 - 30 = 20$ MW, which is exactly the value of $G$.\n\nThe operational implication is that to realize the economic outcome suggested by the aggregated model (i.e., perfectly serving the $30$ MW load), the system operator would have to take additional physical actions not captured in the simple UC model. These actions must manage the $20$ MW of over-generation. This could involve:\n-   **Energy Curtailment:** Intentionally wasting or \"spilling\" the excess $20$ MW of power.\n-   **Energy Storage:** Directing the excess $20$ MW to an energy storage system, like a battery or pumped hydro.\n-   **Ancillary Services:** Using other resources on the grid, such as fast-ramping generators or demand-side response, to absorb the surplus.\n\nIn essence, the feasibility gap $G$ represents the minimum amount of corrective action (in MW) required from ancillary services or other out-of-model mechanisms to bridge the discrepancy between the continuous, economically-optimal relaxation and the discrete, physically-constrained reality.",
            "answer": "$$\\boxed{20.00}$$"
        },
        {
            "introduction": "Having understood the potential pitfalls of aggregation, we now turn to performing it correctly for physical systems. This exercise provides a hands-on walkthrough of aggregating a power transmission network, a core task in regional energy modeling . You will derive an aggregated Power Transfer Distribution Factor ($PTDF$) from first principles by enforcing the physical constraint of angle consistency, revealing how aggregated network parameters are not arbitrary but are determined by the underlying physics of the original system.",
            "id": "4133834",
            "problem": "Consider the Direct-Current (DC) power flow approximation on a $3$-bus network with buses labeled $1$, $2$, and $3$. The network has three transmission lines: $(1,2)$, $(1,3)$, and $(2,3)$. Let the series reactances be $x_{12} = 0.5$, $x_{13} = 1$, and $x_{23} = 1$. Denote the corresponding susceptances by $b_{ij} = \\frac{1}{x_{ij}}$. Take bus $1$ as the slack bus with angle $\\theta_{1} = 0$. Adopt the line orientation from lower-numbered to higher-numbered bus, i.e., $1 \\to 2$, $1 \\to 3$, and $2 \\to 3$, and define line flows $f_{ij} = b_{ij}(\\theta_{i} - \\theta_{j})$ along these orientations.\n\nYou will merge buses $2$ and $3$ into an aggregated bus $A$. Define the aggregated transfer as a unit injection at bus $1$ and a unit withdrawal at bus $A$, with the withdrawal at bus $A$ split between the original buses $2$ and $3$ as $p_{2} = -\\alpha$ and $p_{3} = -(1-\\alpha)$, where $0 \\leq \\alpha \\leq 1$. Impose the angle consistency constraint required by a physical merge, namely $\\theta_{2} = \\theta_{3}$ under the aggregated withdrawal.\n\nStarting solely from the DC power flow definitions and the network data provided, determine the unique $\\alpha$ that enforces $\\theta_{2} = \\theta_{3}$ and compute the resulting aggregated Power Transfer Distribution Factor (PTDF) for the physical line $(1,2)$ with respect to the unit transfer from bus $1$ to bus $A$. The aggregated PTDF for line $(1,2)$ is defined as the fraction of the unit transfer that flows on $(1,2)$ in the original network under the withdrawal split that enforces $\\theta_{2} = \\theta_{3}$. Verify in your derivation that:\n- The total flow on $(1,2)$ and $(1,3)$ sums to the unit transfer (power balance), and\n- The aggregated PTDF equals the weighted sum of the bus-level PTDFs for sinks at buses $2$ and $3$ when weighted by the same $\\alpha$ and $1-\\alpha$.\n\nProvide the aggregated PTDF on line $(1,2)$ as an exact fraction. No units. No rounding is required.",
            "solution": "The problem statement will first be validated against the specified criteria.\n\n### Step 1: Extract Givens\n- Network: $3$-bus network with buses labeled $1$, $2$, and $3$.\n- Transmission lines: $(1,2)$, $(1,3)$, and $(2,3)$.\n- Series reactances: $x_{12} = 0.5$, $x_{13} = 1$, $x_{23} = 1$.\n- Susceptances: $b_{ij} = \\frac{1}{x_{ij}}$.\n- Slack bus: Bus $1$ is the slack bus with phase angle $\\theta_{1} = 0$.\n- Line flow definition: $f_{ij} = b_{ij}(\\theta_{i} - \\theta_{j})$ for orientation $i \\to j$. Orientations are given as $1 \\to 2$, $1 \\to 3$, and $2 \\to 3$.\n- Aggregation: Buses $2$ and $3$ are merged into an aggregated bus $A$.\n- Aggregated transfer: A unit injection at bus $1$ ($p_1 = 1$) and a unit withdrawal at bus $A$.\n- Withdrawal split: The withdrawal at bus $A$ is distributed as $p_{2} = -\\alpha$ and $p_{3} = -(1-\\alpha)$, where $0 \\leq \\alpha \\leq 1$.\n- Angle consistency constraint: $\\theta_{2} = \\theta_{3}$ is imposed.\n- Aggregated PTDF definition: The flow on line $(1,2)$ resulting from the unit transfer from bus $1$ to bus $A$ under the withdrawal split that enforces $\\theta_{2} = \\theta_{3}$.\n- Verification requirements: (1) The sum of flows $f_{12}$ and $f_{13}$ equals the unit transfer. (2) The aggregated PTDF equals the weighted sum $\\alpha \\cdot PTDF_{12, 12} + (1-\\alpha) \\cdot PTDF_{12, 13}$.\n\n### Step 2: Validate Using Extracted Givens\n- **Scientifically Grounded (Critical)**: The problem is based on the Direct-Current (DC) power flow approximation, a standard and fundamental tool in power system analysis. The concept of network aggregation and Power Transfer Distribution Factors (PTDFs) are also well-established principles. All definitions and relationships are consistent with the accepted theory of power systems engineering.\n- **Well-Posed**: The problem provides a complete set of linear equations with a sufficient number of constraints to determine a unique solution for the unknown variables ($\\alpha$, $\\theta_2$, $\\theta_3$).\n- **Objective (Critical)**: The problem is stated using precise, standard terminology from power system engineering. The data is numerical and the objectives are quantitative. There are no subjective or opinion-based statements.\n\n### Step 3: Verdict and Action\nThe problem is valid. It is a well-defined, self-contained, and scientifically sound exercise in power system analysis. The solution process may proceed.\n\n### Solution Derivation\nThe primary objective is to find the value of $\\alpha$ that satisfies the angle consistency constraint $\\theta_{2} = \\theta_{3}$, and then to compute the resulting aggregated Power Transfer Distribution Factor (PTDF) for the line $(1,2)$.\n\nFirst, we calculate the susceptances $b_{ij}$ from the given reactances $x_{ij}$. The values are assumed to be in per-unit.\n$b_{12} = \\frac{1}{x_{12}} = \\frac{1}{0.5} = 2$\n$b_{13} = \\frac{1}{x_{13}} = \\frac{1}{1} = 1$\n$b_{23} = \\frac{1}{x_{23}} = \\frac{1}{1} = 1$\n\nThe DC power flow equations are given by the matrix relationship $P = B\\theta$, where $P$ is the vector of net power injections, $\\theta$ is the vector of bus voltage angles, and $B$ is the susceptance matrix of the network. The elements of the $B$ matrix are:\n$B_{ii} = \\sum_{j \\neq i} b_{ij}$\n$B_{ij} = -b_{ij}$ for $i \\neq j$\n\nFor the given network, the full $B$ matrix is:\n$B_{11} = b_{12} + b_{13} = 2 + 1 = 3$\n$B_{22} = b_{12} + b_{23} = 2 + 1 = 3$\n$B_{33} = b_{13} + b_{23} = 1 + 1 = 2$\n$B_{12} = B_{21} = -b_{12} = -2$\n$B_{13} = B_{31} = -b_{13} = -1$\n$B_{23} = B_{32} = -b_{23} = -1$\n\nSo, the full susceptance matrix is:\n$$ B = \\begin{pmatrix} 3 & -2 & -1 \\\\ -2 & 3 & -1 \\\\ -1 & -1 & 2 \\end{pmatrix} $$\nSince bus $1$ is the slack bus with $\\theta_1 = 0$, we can write the reduced system of equations for the non-slack buses ($2$ and $3$):\n$$ \\begin{pmatrix} p_2 \\\\ p_3 \\end{pmatrix} = \\begin{pmatrix} B_{22} & B_{23} \\\\ B_{32} & B_{33} \\end{pmatrix} \\begin{pmatrix} \\theta_2 \\\\ \\theta_3 \\end{pmatrix} $$\nThis is the system $P' = B'\\theta'$, where $P'$ is the vector of injections at non-slack buses and $B'$ is the reduced susceptance matrix.\nThe power injections are given as $p_2 = -\\alpha$ and $p_3 = -(1-\\alpha)$. The reduced system is:\n$$ \\begin{pmatrix} -\\alpha \\\\ -(1-\\alpha) \\end{pmatrix} = \\begin{pmatrix} 3 & -1 \\\\ -1 & 2 \\end{pmatrix} \\begin{pmatrix} \\theta_2 \\\\ \\theta_3 \\end{pmatrix} $$\nTo solve for the angles $\\theta_2$ and $\\theta_3$, we must find the inverse of the reduced matrix $B'$.\n$\\det(B') = (3)(2) - (-1)(-1) = 6 - 1 = 5$.\nThe inverse is $(B')^{-1} = \\frac{1}{5} \\begin{pmatrix} 2 & 1 \\\\ 1 & 3 \\end{pmatrix}$.\n\nNow we can solve for the angles in terms of $\\alpha$:\n$$ \\begin{pmatrix} \\theta_2 \\\\ \\theta_3 \\end{pmatrix} = (B')^{-1} \\begin{pmatrix} p_2 \\\\ p_3 \\end{pmatrix} = \\frac{1}{5} \\begin{pmatrix} 2 & 1 \\\\ 1 & 3 \\end{pmatrix} \\begin{pmatrix} -\\alpha \\\\ -(1-\\alpha) \\end{pmatrix} $$\n$\\theta_2 = \\frac{1}{5} (2(-\\alpha) + 1(-(1-\\alpha))) = \\frac{1}{5} (-2\\alpha - 1 + \\alpha) = \\frac{1}{5} (-\\alpha - 1)$\n$\\theta_3 = \\frac{1}{5} (1(-\\alpha) + 3(-(1-\\alpha))) = \\frac{1}{5} (-\\alpha - 3 + 3\\alpha) = \\frac{1}{5} (2\\alpha - 3)$\n\nThe aggregation requires the physical constraint $\\theta_2 = \\theta_3$. We enforce this to find the unique value of $\\alpha$:\n$\\frac{1}{5} (-\\alpha - 1) = \\frac{1}{5} (2\\alpha - 3)$\n$-\\alpha - 1 = 2\\alpha - 3$\n$2 = 3\\alpha$\n$\\alpha = \\frac{2}{3}$\n\nWith this value of $\\alpha$, we can find the numerical values of the angles:\n$\\theta_2 = \\frac{1}{5} \\left(-\\frac{2}{3} - 1\\right) = \\frac{1}{5} \\left(-\\frac{5}{3}\\right) = -\\frac{1}{3}$\n$\\theta_3 = \\frac{1}{5} \\left(2\\left(\\frac{2}{3}\\right) - 3\\right) = \\frac{1}{5} \\left(\\frac{4}{3} - \\frac{9}{3}\\right) = \\frac{1}{5} \\left(-\\frac{5}{3}\\right) = -\\frac{1}{3}$\nThe angles are indeed equal, as required.\n\nThe aggregated PTDF for line $(1,2)$ with respect to the transfer from bus $1$ to the aggregated bus $A$ is the power flow $f_{12}$ under these conditions.\n$f_{12} = b_{12}(\\theta_1 - \\theta_2) = 2\\left(0 - \\left(-\\frac{1}{3}\\right)\\right) = 2\\left(\\frac{1}{3}\\right) = \\frac{2}{3}$.\nThus, the aggregated PTDF for line $(1,2)$ is $\\frac{2}{3}$.\n\nNext, we perform the two specified verifications.\n\n**Verification 1: Power Balance**\nWe must verify that the total flow out of the source bus $1$ equals the unit injection. The total flow is $f_{12} + f_{13}$.\nWe already have $f_{12} = \\frac{2}{3}$.\nWe calculate $f_{13} = b_{13}(\\theta_1 - \\theta_3) = 1\\left(0 - \\left(-\\frac{1}{3}\\right)\\right) = \\frac{1}{3}$.\nThe total flow is $f_{12} + f_{13} = \\frac{2}{3} + \\frac{1}{3} = 1$. This matches the unit injection $p_1=1$ at bus $1$. The verification is successful.\n\n**Verification 2: Weighted Sum of Bus-level PTDFs**\nWe need to show that the aggregated PTDF equals $\\alpha \\cdot PTDF_{12, 12} + (1-\\alpha) \\cdot PTDF_{12, 13}$. First, we compute the individual bus-level PTDFs.\n\n$PTDF_{12, 12}$: This is the flow on line $(1,2)$ for a unit transfer from bus $1$ to bus $2$. The injections are $p_1=1$, $p_2=-1$, $p_3=0$.\n$\\begin{pmatrix} \\theta_2 \\\\ \\theta_3 \\end{pmatrix} = (B')^{-1} \\begin{pmatrix} -1 \\\\ 0 \\end{pmatrix} = \\frac{1}{5} \\begin{pmatrix} 2 & 1 \\\\ 1 & 3 \\end{pmatrix} \\begin{pmatrix} -1 \\\\ 0 \\end{pmatrix} = \\frac{1}{5} \\begin{pmatrix} -2 \\\\ -1 \\end{pmatrix}$.\nSo, $\\theta_2 = -\\frac{2}{5}$.\nThe flow is $f_{12} = b_{12}(\\theta_1 - \\theta_2) = 2\\left(0 - \\left(-\\frac{2}{5}\\right)\\right) = \\frac{4}{5}$.\nTherefore, $PTDF_{12, 12} = \\frac{4}{5}$.\n\n$PTDF_{12, 13}$: This is the flow on line $(1,2)$ for a unit transfer from bus $1$ to bus $3$. The injections are $p_1=1$, $p_2=0$, $p_3=-1$.\n$\\begin{pmatrix} \\theta_2 \\\\ \\theta_3 \\end{pmatrix} = (B')^{-1} \\begin{pmatrix} 0 \\\\ -1 \\end{pmatrix} = \\frac{1}{5} \\begin{pmatrix} 2 & 1 \\\\ 1 & 3 \\end{pmatrix} \\begin{pmatrix} 0 \\\\ -1 \\end{pmatrix} = \\frac{1}{5} \\begin{pmatrix} -1 \\\\ -3 \\end{pmatrix}$.\nSo, $\\theta_2 = -\\frac{1}{5}$.\nThe flow is $f_{12} = b_{12}(\\theta_1 - \\theta_2) = 2\\left(0 - \\left(-\\frac{1}{5}\\right)\\right) = \\frac{2}{5}$.\nTherefore, $PTDF_{12, 13} = \\frac{2}{5}$.\n\nNow, we compute the weighted sum using $\\alpha = \\frac{2}{3}$ and $1-\\alpha = \\frac{1}{3}$:\nWeighted Sum = $\\alpha \\cdot PTDF_{12, 12} + (1-\\alpha) \\cdot PTDF_{12, 13}$\nWeighted Sum = $\\left(\\frac{2}{3}\\right) \\left(\\frac{4}{5}\\right) + \\left(\\frac{1}{3}\\right) \\left(\\frac{2}{5}\\right) = \\frac{8}{15} + \\frac{2}{15} = \\frac{10}{15} = \\frac{2}{3}$.\nThis value, $\\frac{2}{3}$, is identical to the aggregated PTDF calculated earlier. This verification is also successful.\n\nThe final answer is the value of the aggregated PTDF for line $(1,2)$.",
            "answer": "$$\\boxed{\\frac{2}{3}}$$"
        },
        {
            "introduction": "Static, pre-defined aggregation schemes can be suboptimal; a more powerful approach is to tailor the level of detail to the problem at hand. This final practice introduces an advanced, adaptive clustering methodology for capacity expansion modeling, where the decision to refine a cluster is based on its marginal benefit to the model's objective function . By implementing this algorithm, you will learn to build more efficient and accurate models that strategically balance computational complexity with economic fidelity.",
            "id": "4133860",
            "problem": "Consider a single-period capacity expansion abstraction in energy systems modeling. Let there be a set of micro-units indexed by $i \\in \\{1,2,\\dots,N\\}$, where each micro-unit has a constant marginal cost $c_i$ in dollars per megawatt-hour ($\\$\\!/\\mathrm{MWh}$) and a maximum deliverable energy $e_i$ in megawatt-hour ($\\mathrm{MWh}$). The system must meet a fixed energy demand $E$ in megawatt-hour ($\\mathrm{MWh}$) within the period. Assume $0 \\leq E \\leq \\sum_{i=1}^N e_i$. The expansion decision chooses a procurement vector $x = (x_1,\\dots,x_N)$ with $0 \\leq x_i \\leq e_i$ for all $i$ and $\\sum_{i=1}^N x_i \\geq E$, to minimize the total cost $\\sum_{i=1}^N c_i x_i$. This micro-level model provides the baseline optimum.\n\nTo study the impact of unit aggregation, suppose micro-units are clustered into $K$ technology classes. A class $j \\in \\{1,\\dots,K\\}$ contains a subset $S_j \\subset \\{1,\\dots,N\\}$, and is represented in the aggregated model solely by its total capacity $Q_j = \\sum_{i \\in S_j} e_i$ and its energy-weighted average cost $C_j = \\left(\\sum_{i \\in S_j} c_i e_i\\right)/Q_j$. The aggregated decision chooses $y = (y_1,\\dots,y_K)$ with $0 \\leq y_j \\leq Q_j$ and $\\sum_{j=1}^K y_j \\geq E$ to minimize $\\sum_{j=1}^K C_j y_j$. Because aggregation masks intra-class cost heterogeneity, the aggregated optimum may exceed the micro-optimum. Increasing $K$ (refining clusters) tends to decrease the aggregated optimum towards the micro-optimum.\n\nYour task is to:\n- Formulate from first principles a method to adaptively refine clusters based on marginal benefit, defined as the reduction in total cost in dollars when a single class is split into two sub-classes and the aggregated optimization is re-solved.\n- Implement a program that, for each test case provided below, performs the following:\n    1. Construct initial clusters by sorting micro-units by $c_i$ and partitioning into $K_{\\mathrm{init}}$ contiguous groups in the sorted order.\n    2. Compute the baseline aggregated optimum cost (in dollars) with $K_{\\mathrm{init}}$ classes.\n    3. Iteratively apply adaptive refinement: at each iteration, among all current classes, consider all feasible binary splits along the sorted $c_i$ within that class; for each candidate split, compute the marginal benefit (in dollars). Perform the split with the highest positive marginal benefit if it exceeds a given threshold $\\varepsilon$ (in dollars) and the current number of classes is less than $K_{\\max}$. Stop otherwise.\n    4. Compute the final aggregated optimum cost (in dollars) after refinement and the final number of classes $K_{\\mathrm{final}}$.\n    5. Compute the micro-optimal cost (in dollars) by choosing micro-units in ascending order of $c_i$ until meeting $E$.\n- For each test case, output a list $[B,F,M,K]$ where $B$ is the baseline aggregated cost in dollars, $F$ is the final aggregated cost in dollars, $M$ is the micro-optimal cost in dollars, and $K$ is the final number of classes $K_{\\mathrm{final}}$ (an integer). All costs $B$, $F$, and $M$ must be rounded to two decimal places.\n\nFundamental base you must use includes:\n- The definition of cost minimization subject to resource constraints: minimize $\\sum c_i x_i$ subject to linear capacity and demand balance constraints.\n- Cost aggregation via energy-weighted averages and the logical monotonicity that finer partitioning of the same resource set cannot increase the best achievable objective when the representation is consistent.\n- Greedy selection under linear costs with separable capacity constraints: optimal procurement from micro-units in non-decreasing order of $c_i$.\n\nAngle units are not applicable. Physical units must be handled as follows: energy in megawatt-hour ($\\mathrm{MWh}$), costs in dollars ($\\$$), and costs per energy in dollars per megawatt-hour ($\\$\\!/\\mathrm{MWh}$). Express final costs in dollars ($\\$$), rounded to two decimal places. Do not include units in the printed output; units are specified here for interpretation.\n\nTest suite:\n- Case $1$ (general heterogeneity, moderate demand, moderate refinement):\n    - $N = 12$,\n    - $c = [30, 32, 35, 40, 45, 50, 55, 60, 70, 80, 90, 100]$ in $\\$\\!/\\mathrm{MWh}$,\n    - $e = [100, 90, 80, 120, 110, 100, 80, 70, 60, 50, 40, 30]$ in $\\mathrm{MWh}$,\n    - $E = 500$ in $\\mathrm{MWh}$,\n    - $K_{\\mathrm{init}} = 3$,\n    - $\\varepsilon = 10$ in $\\$$,\n    - $K_{\\max} = 6$.\n- Case $2$ (refine aggressively to the micro-level):\n    - $N = 12$,\n    - $c = [30, 32, 35, 40, 45, 50, 55, 60, 70, 80, 90, 100]$ in $\\$\\!/\\mathrm{MWh}$,\n    - $e = [100, 90, 80, 120, 110, 100, 80, 70, 60, 50, 40, 30]$ in $\\mathrm{MWh}$,\n    - $E = 500$ in $\\mathrm{MWh}$,\n    - $K_{\\mathrm{init}} = 2$,\n    - $\\varepsilon = 0$ in $\\$$,\n    - $K_{\\max} = 12$.\n- Case $3$ (identical costs, no benefit from refinement):\n    - $N = 10$,\n    - $c = [50, 50, 50, 50, 50, 50, 50, 50, 50, 50]$ in $\\$\\!/\\mathrm{MWh}$,\n    - $e = [60, 50, 40, 40, 60, 50, 30, 30, 20, 20]$ in $\\mathrm{MWh}$,\n    - $E = 300$ in $\\mathrm{MWh}$,\n    - $K_{\\mathrm{init}} = 3$,\n    - $\\varepsilon = 1$ in $\\$$,\n    - $K_{\\max} = 6$.\n- Case $4$ (low demand, little benefit from splitting expensive classes):\n    - $N = 10$,\n    - $c = [28, 30, 35, 38, 42, 47, 53, 60, 68, 75]$ in $\\$\\!/\\mathrm{MWh}$,\n    - $e = [80, 80, 80, 80, 80, 80, 80, 80, 80, 80]$ in $\\mathrm{MWh}$,\n    - $E = 120$ in $\\mathrm{MWh}$,\n    - $K_{\\mathrm{init}} = 4$,\n    - $\\varepsilon = 5$ in $\\$$,\n    - $K_{\\max} = 8$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element corresponds to one test case and is itself a list in the form $[B,F,M,K]$, for example, $[[B_1,F_1,M_1,K_1],[B_2,F_2,M_2,K_2],\\dots]$. All costs must be rounded to two decimal places and $K$ must be an integer. No additional text should be printed.",
            "solution": "The problem requires the formulation and implementation of an adaptive clustering algorithm for an energy system capacity expansion problem. The core task is to model a system of $N$ micro-generation units to meet a demand $E$, first at a fine-grained micro-level, then using a simplified aggregated model, and finally to iteratively refine the aggregated model to reduce the discrepancy between the two.\n\n**1. Micro-Optimal Solution (The Baseline)**\n\nThe micro-level problem is to determine the energy procurement $x_i$ from each micro-unit $i \\in \\{1, 2, \\dots, N\\}$ to minimize the total system cost. Each unit has a constant marginal cost $c_i$ (in $\\$\\!/\\mathrm{MWh}$) and a maximum energy capacity $e_i$ (in $\\mathrm{MWh}$). The optimization problem is formulated as follows:\n\nMinimize:\n$$\n\\text{Total Cost} = \\sum_{i=1}^{N} c_i x_i\n$$\nSubject to:\n$$\n\\sum_{i=1}^{N} x_i \\geq E \\quad (\\text{Demand Satisfaction})\n$$\n$$\n0 \\leq x_i \\leq e_i \\quad \\forall i \\in \\{1, 2, \\dots, N\\} \\quad (\\text{Capacity Constraints})\n$$\n\nThis is a linear programming problem, specifically a continuous knapsack problem. The optimal solution can be found using a greedy algorithm. The principle is to prioritize procurement from the cheapest available sources.\n\nThe algorithm is as follows:\n$1$. Sort the micro-units in non-decreasing order of their marginal cost $c_i$.\n$2$. Iterate through the sorted units, dispatching each unit at its full capacity $e_i$, until the cumulative dispatched energy meets the demand $E$.\n$3$. The last unit in this sequence may be only partially dispatched to exactly satisfy the demand.\n\nLet the sorted units be indexed by $k=1, \\dots, N$ such that $c_k \\leq c_{k+1}$. The dispatched energy $x_k$ for each unit is determined sequentially. If $E_{rem}$ is the remaining demand, we set $x_k = \\min(e_k, E_{rem})$ and update $E_{rem} \\leftarrow E_{rem} - x_k$. The total cost computed this way is the true minimum cost, which we denote as $M$.\n\n**2. Aggregated Model and Aggregation Error**\n\nIn the aggregated model, the $N$ micro-units are partitioned into $K$ disjoint classes, $S_1, S_2, \\dots, S_K$. Each class $j$ is treated as a single composite unit. Its characteristics are derived from its constituent micro-units:\n\n- **Aggregated Capacity ($Q_j$):** The total capacity of class $j$ is the sum of the capacities of its members.\n$$\nQ_j = \\sum_{i \\in S_j} e_i\n$$\n- **Aggregated Cost ($C_j$):** The cost of class $j$ is the energy-weighted average of the costs of its members. This ensures that the total cost to dispatch the entire class is preserved: $C_j Q_j = \\sum_{i \\in S_j} c_i e_i$.\n$$\nC_j = \\frac{\\sum_{i \\in S_j} c_i e_i}{\\sum_{i \\in S_j} e_i} = \\frac{\\sum_{i \\in S_j} c_i e_i}{Q_j}\n$$\n\nThe aggregated optimization problem is structurally identical to the micro-problem, but operates on the $K$ classes instead of $N$ micro-units. We seek to choose dispatch levels $y_j$ for each class $j$:\n\nMinimize:\n$$\n\\text{Aggregated Cost} = \\sum_{j=1}^{K} C_j y_j\n$$\nSubject to:\n$$\n\\sum_{j=1}^{K} y_j \\geq E\n$$\n$$\n0 \\leq y_j \\leq Q_j \\quad \\forall j \\in \\{1, 2, \\dots, K\\}\n$$\n\nThe optimal solution to this aggregated problem is also found via a greedy strategy: sort the classes by their aggregated cost $C_j$ and dispatch them in ascending order of cost until demand $E$ is met.\n\nThe optimal cost from this model, $Cost_{agg}$, will always be greater than or equal to the micro-optimal cost $M$. This \"aggregation error\" arises because the model obscures the cost variations within a class, effectively assuming all energy from a class costs $C_j \\ \\$\\!/\\mathrm{MWh}$.\n\n**3. Adaptive Refinement Algorithm**\n\nThe core of the task is to iteratively refine the clustering to reduce the aggregation error. The refinement is driven by \"marginal benefit,\" defined as the cost reduction achieved by splitting a single class into two.\n\n**Step 3.1: Initial Clustering**\nFirst, the $N$ micro-units are sorted by their marginal cost $c_i$. Then, this sorted list is partitioned into $K_{\\mathrm{init}}$ contiguous, non-overlapping groups. This forms the initial set of classes. The aggregated cost calculated with these initial classes is the baseline aggregated cost, $B$.\n\n**Step 3.2: Iterative Refinement**\nThe algorithm proceeds iteratively from this baseline:\n$1$. **Set Initial State:** The current set of clusters is the initial partition. The current aggregated cost is $B$.\n$2$. **Loop until Termination:**\n   a. **Identify Candidate Splits:** For each current class $S_j$ containing $m_j > 1$ micro-units, consider all $m_j-1$ possible binary splits. Each split divides $S_j$ into two non-empty, contiguous sub-classes, $S_{j,1}$ and $S_{j,2}$, preserving the sorted order of micro-units.\n   b. **Evaluate Marginal Benefit:** For each candidate split, construct a temporary set of clusters where $S_j$ is replaced by $S_{j,1}$ and $S_{j,2}$. Calculate the new optimal aggregated cost for this refined set of clusters. The marginal benefit of this split is:\n      $$\n      \\text{Benefit} = (\\text{Current Aggregated Cost}) - (\\text{New Aggregated Cost})\n      $$\n      A positive benefit indicates an improvement in the model's accuracy. A benefit arises primarily when a split alters the dispatch order around the margin. For example, splitting a high-cost marginal class may reveal a cheaper sub-class that can be dispatched, lowering the overall cost.\n   c. **Select Best Split:** Identify the split (across all possible splits of all current classes) that yields the maximum positive marginal benefit, let's call it $\\text{Benefit}_{\\max}$.\n   d. **Decision and Termination:**\n      - If $\\text{Benefit}_{\\max} > \\varepsilon$ and the current number of classes is less than $K_{\\max}$, the split is accepted. The cluster set is permanently updated, and the current aggregated cost is reduced by $\\text{Benefit}_{\\max}$. The process returns to step 2.a for another iteration.\n      - If $\\text{Benefit}_{\\max} \\leq \\varepsilon$ or the number of classes has reached $K_{\\max}$, the refinement process terminates.\n\n**Step 3.3: Final Outputs**\nUpon termination, we have:\n- $M$: The true micro-optimal cost.\n- $B$: The baseline aggregated cost with $K_{\\mathrm{init}}$ classes.\n- $F$: The final aggregated cost after all refinement steps.\n- $K_{\\mathrm{final}}$: The final number of classes.\n\nThis adaptive strategy provides a principled way to balance model complexity (number of classes) and accuracy (aggregation error), adding detail only where it provides a significant improvement in the cost estimate, as determined by the threshold $\\varepsilon$.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    # Test cases defined in the problem statement.\n    test_cases = [\n        {\n            \"N\": 12,\n            \"c\": [30, 32, 35, 40, 45, 50, 55, 60, 70, 80, 90, 100],\n            \"e\": [100, 90, 80, 120, 110, 100, 80, 70, 60, 50, 40, 30],\n            \"E\": 500,\n            \"K_init\": 3,\n            \"epsilon\": 10,\n            \"K_max\": 6,\n        },\n        {\n            \"N\": 12,\n            \"c\": [30, 32, 35, 40, 45, 50, 55, 60, 70, 80, 90, 100],\n            \"e\": [100, 90, 80, 120, 110, 100, 80, 70, 60, 50, 40, 30],\n            \"E\": 500,\n            \"K_init\": 2,\n            \"epsilon\": 0,\n            \"K_max\": 12,\n        },\n        {\n            \"N\": 10,\n            \"c\": [50, 50, 50, 50, 50, 50, 50, 50, 50, 50],\n            \"e\": [60, 50, 40, 40, 60, 50, 30, 30, 20, 20],\n            \"E\": 300,\n            \"K_init\": 3,\n            \"epsilon\": 1,\n            \"K_max\": 6,\n        },\n        {\n            \"N\": 10,\n            \"c\": [28, 30, 35, 38, 42, 47, 53, 60, 68, 75],\n            \"e\": [80, 80, 80, 80, 80, 80, 80, 80, 80, 80],\n            \"E\": 120,\n            \"K_init\": 4,\n            \"epsilon\": 5,\n            \"K_max\": 8,\n        },\n    ]\n\n    results = []\n    \n    # Helper function to calculate cost for a set of \"units\" (micro or aggregated)\n    def calculate_dispatch_cost(units, demand):\n        # units is a list of tuples: (cost, capacity, total_ce_product)\n        # for micro-units, total_ce_product can be cost*capacity\n        sorted_units = sorted(units, key=lambda u: u[0])\n        total_cost = 0.0\n        remaining_demand = float(demand)\n        \n        for cost, capacity, ce_product in sorted_units:\n            if remaining_demand = 0:\n                break\n            \n            dispatch_energy = min(remaining_demand, capacity)\n            \n            if capacity > 0:\n                # Use total_ce_product when dispatching the whole block\n                # This avoids precision issues from re-calculating C * Q\n                if dispatch_energy == capacity:\n                    total_cost += ce_product\n                else: \n                    # Use average cost for partial dispatch\n                    total_cost += cost * dispatch_energy\n            \n            remaining_demand -= dispatch_energy\n            \n        return total_cost\n\n    # Helper function to calculate aggregated characteristics for a list of clusters\n    def get_aggregated_units(clusters):\n        agg_units = []\n        for cluster in clusters:\n            if not cluster:\n                continue\n            total_e = sum(u[1] for u in cluster)\n            total_ce = sum(u[0] * u[1] for u in cluster)\n            \n            if total_e > 0:\n                avg_c = total_ce / total_e\n                agg_units.append((avg_c, total_e, total_ce))\n            else:\n                # Handle empty cluster or cluster with zero capacity\n                agg_units.append((0.0, 0.0, 0.0))\n        return agg_units\n\n    for case in test_cases:\n        c, e, E = case[\"c\"], case[\"e\"], case[\"E\"]\n        K_init, epsilon, K_max = case[\"K_init\"], case[\"epsilon\"], case[\"K_max\"]\n\n        # The problem states micro-units are sorted by c_i.\n        # We zip c and e to create micro-unit tuples (cost, energy).\n        # We assume the input 'c' is already sorted and 'e' corresponds to it.\n        micro_units = list(zip(c, e))\n\n        # 1. Compute Micro-Optimal Cost (M)\n        micro_as_dispatch_units = [(u[0], u[1], u[0] * u[1]) for u in micro_units]\n        M = calculate_dispatch_cost(micro_as_dispatch_units, E)\n\n        # 2. Construct initial clusters and compute Baseline Aggregated Cost (B)\n        # Use np.array_split for balanced contiguous partitioning\n        indices = np.arange(len(micro_units))\n        split_indices = np.array_split(indices, K_init)\n        initial_clusters = [[micro_units[i] for i in idx_list] for idx_list in split_indices]\n        \n        aggregated_units_B = get_aggregated_units(initial_clusters)\n        B = calculate_dispatch_cost(aggregated_units_B, E)\n\n        # 3. Iteratively apply adaptive refinement\n        current_clusters = initial_clusters\n        current_cost = B\n        \n        while True:\n            if len(current_clusters) >= K_max:\n                break\n\n            best_split_info = {\n                \"benefit\": -1.0,\n                \"cluster_idx\": -1,\n                \"split_point\": -1,\n                \"new_clusters\": None\n            }\n\n            # Find the best possible split among all clusters\n            for i, cluster in enumerate(current_clusters):\n                if len(cluster) > 1:\n                    for p in range(1, len(cluster)):\n                        # Create a candidate split\n                        temp_clusters = list(current_clusters)\n                        # Remove the original cluster and add the two new sub-clusters\n                        sub_cluster1 = cluster[:p]\n                        sub_cluster2 = cluster[p:]\n                        \n                        temp_clusters[i:i+1] = [sub_cluster1, sub_cluster2]\n\n                        # Calculate cost with this new split\n                        agg_units_temp = get_aggregated_units(temp_clusters)\n                        new_cost = calculate_dispatch_cost(agg_units_temp, E)\n                        \n                        benefit = current_cost - new_cost\n\n                        if benefit > best_split_info[\"benefit\"]:\n                            best_split_info[\"benefit\"] = benefit\n                            best_split_info[\"new_clusters\"] = temp_clusters\n\n            # Check stopping conditions\n            if best_split_info[\"benefit\"] > epsilon:\n                # Apply the best split\n                current_clusters = best_split_info[\"new_clusters\"]\n                current_cost = current_cost - best_split_info[\"benefit\"]\n            else:\n                # No split provides enough benefit, so stop\n                break\n        \n        # 4. Compute final aggregated cost (F) and final number of classes (K_final)\n        F = current_cost\n        K_final = len(current_clusters)\n\n        # 5. Store results, rounded as required\n        results.append([round(B, 2), round(F, 2), round(M, 2), K_final])\n\n    # Format the final output string\n    formatted_results = [f\"[{b},{f},{m},{k}]\" for b, f, m, k in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}