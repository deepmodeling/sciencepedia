{
    "hands_on_practices": [
        {
            "introduction": "该练习的核心是“本征正交分解”（Proper Orthogonal Decomposition, POD），这是数据驱动降阶建模的基石。通过使用奇异值分解（Singular Value Decomposition, SVD）分析来自能源系统的“快照矩阵”，您将学习如何量化系统中的主导动态模式。这项实践对于理解如何根据“能量”含量来确定降阶模型的合适尺寸至关重要，这是评估模型精度的基本技能 。",
            "id": "4127506",
            "problem": "给定一个能量系统的快照矩阵 $X \\in \\mathbb{R}^{m \\times n}$，其中行对应状态分量（例如节点电压或热状态），列对应时间或工作点样本。通过选择主要的奇异值分解模态，可以获得一个降阶（代理）表示。您的任务是量化由秩-r截断所保留的总能量的分数，该分数由弗罗贝尼乌斯范数的平方来衡量。秩 $r$ 的保留能量分数定义为前 $r$ 个奇异值所捕获的能量与 $X$ 的总能量之比。\n\n从以下基本概念开始：\n- 矩阵 $X$ 的弗罗贝尼乌斯范数的平方定义为 $\\lVert X \\rVert_F^2 = \\sum_{i=1}^m \\sum_{j=1}^n X_{ij}^2$。\n- $X$ 的奇异值分解 (SVD) 定义为 $X = U \\Sigma V^\\top$，其中 $U \\in \\mathbb{R}^{m \\times m}$ 和 $V \\in \\mathbb{R}^{n \\times n}$ 是正交矩阵（即 $U^\\top U = I_m$ 和 $V^\\top V = I_n$），$\\Sigma \\in \\mathbb{R}^{m \\times n}$ 是一个对角矩形矩阵，其对角线上包含奇异值 $\\sigma_1, \\sigma_2, \\dots, \\sigma_p$，其中 $p = \\min(m,n)$ 且 $\\sigma_1 \\ge \\sigma_2 \\ge \\dots \\ge \\sigma_p \\ge 0$。\n- 弗罗贝尼乌斯范数的正交不变性意味着 $\\lVert X \\rVert_F^2 = \\lVert \\Sigma \\rVert_F^2 = \\sum_{i=1}^p \\sigma_i^2$。\n\n将所选秩 $r$ 的保留能量分数定义为\n$$\nE_r = \\frac{\\sum_{i=1}^{r} \\sigma_i^2}{\\sum_{i=1}^{p} \\sigma_i^2},\n$$\n其中 $p = \\min(m,n)$，$r$ 是一个整数且 $0 \\le r \\le p$。如果 $r > p$，则将 $r$ 视为 $p$。如果 $\\sum_{i=1}^{p} \\sigma_i^2 = 0$（即 $X$ 是零矩阵），则对于任何 $r$，定义 $E_r = 0$。\n\n实现一个程序，对于每个指定的测试矩阵和秩 $r$，通过以下步骤计算 $E_r$：\n- 计算 $X$ 的奇异值分解。\n- 使用奇异值精确地按上述定义评估 $E_r$。\n\n将每个保留能量分数 $E_r$ 表示为四舍五入到六位小数的小数。您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，“[$0.500000,0.750000$]”），不含空格。\n\n使用以下测试套件（每个案例提供 $X$ 和 $r$）：\n- 案例 $1$：$X = \\begin{bmatrix} 5  0  0 \\\\ 0  3  0 \\\\ 0  0  1 \\end{bmatrix}$，$r = 2$。\n- 案例 $2$：$X = \\begin{bmatrix} 4  0  0 \\\\ 0  2  0 \\\\ 0  0  1 \\\\ 0  0  0 \\end{bmatrix}$，$r = 3$。\n- 案例 $3$：$X = \\begin{bmatrix} 1  2 \\\\ 2  4 \\\\ 3  6 \\end{bmatrix}$，$r = 1$。\n- 案例 $4$：$X = \\begin{bmatrix} 1  0 \\\\ 0  1 \\end{bmatrix}$，$r = 0$。\n- 案例 $5$：$X = \\begin{bmatrix} 0  0  0 \\\\ 0  0  0 \\\\ 0  0  0 \\end{bmatrix}$，$r = 2$。\n- 案例 $6$：$X = \\begin{bmatrix} 1  0 \\\\ 0  1 \\end{bmatrix}$，$r = 5$。\n\n您的程序应按指定格式“[$E_1,E_2,E_3,E_4,E_5,E_6$]”将六个案例的保留能量分数输出为单行，其中每个 $E_i$ 按要求四舍五入到六位小数。",
            "solution": "问题陈述已经过验证，被认为是可靠的。它在科学上以线性代数为基础，特别是奇异值分解（SVD）理论，并且其在模型降阶中的应用是一个标准且适定的概念。问题是自包含的，所有必要的定义、数据和边界条件都已明确指定。没有矛盾、歧义或事实错误。\n\n任务是计算给定快照矩阵 $X$ 进行秩-r截断后的保留能量分数 $E_r$。该分数用于量化由弗罗贝尼乌斯范数平方衡量的总系统“能量”中，被前 $r$ 个主导奇异模态捕获的部分。公式如下：\n$$\nE_r = \\frac{\\sum_{i=1}^{r} \\sigma_i^2}{\\sum_{i=1}^{p} \\sigma_i^2}\n$$\n其中 $\\sigma_i$ 是 $X$ 的按降序排列的奇异值，$p = \\min(m, n)$ 是一个 $m \\times n$ 矩阵的奇异值数量，$r$ 是所选的近似秩。\n\n其基本原理是弗罗贝尼乌斯范数的正交不变性，即 $\\lVert X \\rVert_F^2 = \\lVert U \\Sigma V^\\top \\rVert_F^2 = \\lVert \\Sigma \\rVert_F^2$。因为 $\\Sigma$ 是一个对角线上为奇异值 $\\sigma_i$ 的对角矩形矩阵，其弗罗贝尼乌斯范数的平方就是奇异值平方的和：\n$$\n\\lVert X \\rVert_F^2 = \\sum_{i=1}^{p} \\sigma_i^2\n$$\n这个和代表了系统快照矩阵 $X$ 中的总能量。一个 $X$ 的秩-r近似，记为 $X_r$，仅使用前 $r$ 个奇异值及其对应的奇异向量来构造。这个近似的能量是 $\\lVert X_r \\rVert_F^2 = \\sum_{i=1}^{r} \\sigma_i^2$。保留能量分数 $E_r$ 是这两个量的比值。\n\n步骤如下：\n1. 对于每个矩阵 $X$ 和秩 $r$，确定矩阵维度 $m$ 和 $n$，以及最大可能秩 $p = \\min(m, n)$。\n2. 根据指定规则调整请求的秩 $r$：如果 $r > p$，则将其视为 $r=p$。用于分子求和的有效秩是 $r_{eff} = \\min(r, p)$。\n3. 计算 $X$ 的奇异值 $\\sigma_1, \\sigma_2, \\dots, \\sigma_p$。\n4. 计算总能量（分母）：$E_{total} = \\sum_{i=1}^{p} \\sigma_i^2$。\n5. 处理 $E_{total} = 0$ 的特殊情况（即 $X$ 是零矩阵）。在这种情况下，$E_r$ 定义为 $0$。\n6. 否则，计算保留的能量（分子）：$E_{retained} = \\sum_{i=1}^{r_{eff}} \\sigma_i^2$。\n7. 计算分数 $E_r = E_{retained} / E_{total}$。\n\n我们现在将此程序应用于每个测试案例。\n\n**案例 1：**\n- 给定：$X = \\begin{bmatrix} 5  0  0 \\\\ 0  3  0 \\\\ 0  0  1 \\end{bmatrix}$，$r = 2$。\n- 维度：$m=3, n=3$，所以 $p = \\min(3, 3) = 3$。\n- $X$ 矩阵是对角矩阵，因此其奇异值是对角元素的绝对值，按降序排列：$\\sigma_1=5, \\sigma_2=3, \\sigma_3=1$。\n- 总能量：$\\sum_{i=1}^{3} \\sigma_i^2 = 5^2 + 3^2 + 1^2 = 25 + 9 + 1 = 35$。\n- $r=2$ 的保留能量：$\\sum_{i=1}^{2} \\sigma_i^2 = 5^2 + 3^2 = 25 + 9 = 34$。\n- $E_2 = \\frac{34}{35} \\approx 0.97142857$。四舍五入到六位小数为 $0.971429$。\n\n**案例 2：**\n- 给定：$X = \\begin{bmatrix} 4  0  0 \\\\ 0  2  0 \\\\ 0  0  1 \\\\ 0  0  0 \\end{bmatrix}$，$r = 3$。\n- 维度：$m=4, n=3$，所以 $p = \\min(4, 3) = 3$。\n- 奇异值是主对角线上的非零项，排序后为：$\\sigma_1=4, \\sigma_2=2, \\sigma_3=1$。\n- 总能量：$\\sum_{i=1}^{3} \\sigma_i^2 = 4^2 + 2^2 + 1^2 = 16 + 4 + 1 = 21$。\n- 秩为 $r=3$，等于 $p$。保留的能量等于总能量。\n- $E_3 = \\frac{21}{21} = 1$。其值为 $1.000000$。\n\n**案例 3：**\n- 给定：$X = \\begin{bmatrix} 1  2 \\\\ 2  4 \\\\ 3  6 \\end{bmatrix}$，$r = 1$。\n- 维度：$m=3, n=2$，所以 $p = \\min(3, 2) = 2$。\n- 第二列是第一列的倍数，因此该矩阵的秩为 1。这意味着只有一个奇异值非零。$X^\\top X = \\begin{bmatrix} 14  28 \\\\ 28  56 \\end{bmatrix}$ 的特征值为 $\\lambda_1=70, \\lambda_2=0$。\n- 奇异值为 $\\sigma_1 = \\sqrt{70}, \\sigma_2 = 0$。\n- 总能量：$\\sum_{i=1}^{2} \\sigma_i^2 = (\\sqrt{70})^2 + 0^2 = 70$。\n- $r=1$ 的保留能量：$\\sum_{i=1}^{1} \\sigma_i^2 = (\\sqrt{70})^2 = 70$。\n- $E_1 = \\frac{70}{70} = 1$。其值为 $1.000000$。\n\n**案例 4：**\n- 给定：$X = \\begin{bmatrix} 1  0 \\\\ 0  1 \\end{bmatrix}$，$r = 0$。\n- 维度：$m=2, n=2$，所以 $p = \\min(2, 2) = 2$。\n- 该矩阵是单位矩阵 $I_2$。其奇异值为 $\\sigma_1=1, \\sigma_2=1$。\n- 总能量：$\\sum_{i=1}^{2} \\sigma_i^2 = 1^2 + 1^2 = 2$。\n- 秩为 $r=0$。分子是一个空和，其值为 0。\n- $r=0$ 的保留能量：$\\sum_{i=1}^{0} \\sigma_i^2 = 0$。\n- $E_0 = \\frac{0}{2} = 0$。其值为 $0.000000$。\n\n**案例 5：**\n- 给定：$X = \\begin{bmatrix} 0  0  0 \\\\ 0  0  0 \\\\ 0  0  0 \\end{bmatrix}$，$r = 2$。\n- 维度：$m=3, n=3$，所以 $p = \\min(3, 3) = 3$。\n- 这是零矩阵。其所有奇异值均为 0。\n- 总能量：$\\sum_{i=1}^{3} \\sigma_i^2 = 0^2 + 0^2 + 0^2 = 0$。\n- 根据问题定义，如果总能量为 0，则对于任何 $r$，$E_r=0$。\n- $E_2 = 0$。其值为 $0.000000$。\n\n**案例 6：**\n- 给定：$X = \\begin{bmatrix} 1  0 \\\\ 0  1 \\end{bmatrix}$，$r = 5$。\n- 维度：$m=2, n=2$，所以 $p = \\min(2, 2) = 2$。\n- 奇异值为 $\\sigma_1=1, \\sigma_2=1$。\n- 请求的秩 $r=5$ 大于 $p=2$。问题陈述在这种情况下将 $r$ 视为 $p$。因此，有效秩为 $r_{eff}=2$。\n- 总能量：$\\sum_{i=1}^{2} \\sigma_i^2 = 1^2 + 1^2 = 2$。\n- 有效秩 $r_{eff}=2$ 的保留能量：$\\sum_{i=1}^{2} \\sigma_i^2 = 1^2 + 1^2 = 2$。\n- $E_5 = \\frac{2}{2} = 1$。其值为 $1.000000$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the retained energy fraction for a series of test cases\n    involving matrix truncation via SVD.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (np.array([[5, 0, 0], [0, 3, 0], [0, 0, 1]], dtype=float), 2),\n        (np.array([[4, 0, 0], [0, 2, 0], [0, 0, 1], [0, 0, 0]], dtype=float), 3),\n        (np.array([[1, 2], [2, 4], [3, 6]], dtype=float), 1),\n        (np.array([[1, 0], [0, 1]], dtype=float), 0),\n        (np.array([[0, 0, 0], [0, 0, 0], [0, 0, 0]], dtype=float), 2),\n        (np.array([[1, 0], [0, 1]], dtype=float), 5),\n    ]\n\n    results = []\n    for X, r in test_cases:\n        # Main logic to calculate the result for one case goes here.\n        \n        # Get matrix dimensions and maximum possible rank p\n        m, n = X.shape\n        p = min(m, n)\n\n        # Compute singular values. We only need the values, not the full SVD.\n        s = np.linalg.svd(X, compute_uv=False)\n\n        # Square the singular values to represent their energy.\n        s_sq = np.square(s)\n\n        # The total energy is the sum of all squared singular values.\n        total_energy = np.sum(s_sq)\n\n        # Per the problem: if total energy is 0, the fraction is 0.\n        if total_energy == 0:\n            e_r = 0.0\n        else:\n            # The effective rank for summation cannot exceed p.\n            # Also handles r=0 correctly with slicing.\n            # Per problem statement: if r > p, treat r as p.\n            rank_k = min(r, p)\n            \n            # The retained energy is the sum of the first rank_k squared singular values.\n            # s is already sorted in descending order by np.linalg.svd.\n            retained_energy = np.sum(s_sq[:rank_k])\n            \n            # The fraction is the ratio of retained to total energy.\n            e_r = retained_energy / total_energy\n        \n        results.append(e_r)\n\n    # Final print statement in the exact required format.\n    # Each result is formatted to six decimal places.\n    print(f\"[{','.join(f'{res:.6f}' for res in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "从数据驱动方法转向基于物理的方法，本练习将探索克朗（Kron）削减，这是一种简化电气网络的经典技术。通过对一个五母线系统应用基本的电路定律，你将消除内部节点，从而推导出描述网络边界行为的简化模型。这项动手任务展示了如何通过直接操作系统的控制方程来创建降阶模型，这是电力系统分析中的一种强大方法 。",
            "id": "4127526",
            "problem": "给定一个电阻性五节点网络，旨在模拟直流能源系统，作为交流网络小信号行为的代理模型。该网络可用一个导纳矩阵表示，该矩阵由相连节点间的线路导纳和各节点到地的并联导纳构建。设节点电压向量为 $V \\in \\mathbb{R}^{5}$（单位：伏特），节点注入电流向量为 $I \\in \\mathbb{R}^{5}$（单位：安培）。根据 Kirchhoff 电流定律 (KCL) 和 Ohm 定律，可推导出节点关系 $I = Y V$，其中 $Y \\in \\mathbb{R}^{5 \\times 5}$ 是对称导纳矩阵。将节点划分为边界节点 $\\{1,5\\}$ 和内部节点 $\\{2,3,4\\}$，并通过消除内部状态进行模型降阶，以获得边界节点所见的降阶响应。\n\n按如下方式构建 $Y$：对于每条线路导纳为 $g$（单位：西门子 S）的无向线路 $(p,q)$，将 $g$ 加到 $Y_{pp}$ 和 $Y_{qq}$ 上，并将 $-g$ 加到 $Y_{pq}$ 和 $Y_{qp}$ 上。对于每个并联导纳为 $y_k$（单位：西门子）的节点 $k$，将 $y_k$ 加到 $Y_{kk}$ 上。所有线路导纳和并联导纳均为严格非负实数，且网络是连通的。\n\n您的程序必须：\n- 根据提供的线路和并联导纳数据构建完整的导纳矩阵 $Y$。\n- 根据边界节点 $\\{1,5\\}$ 和内部节点 $\\{2,3,4\\}$ 对 $Y$ 进行划分。\n- 通过强制执行内部 KCL 方程来消除内部节点电压，从而推导出边界电流和边界电压之间的降阶关系。\n- 计算并验证每个测试用例的电压-电流关系。\n\n基本原理：使用 Ohm 定律和 Kirchhoff 电流定律、电阻网络节点导纳的定义以及标准线性代数来消除内部变量。不要依赖任何预先给定的降阶公式；应通过使用 KCL 从全网络方程中消除内部电压来推导边界响应。\n\n网络线路集（所有测试用例通用），其中每个元组为 $(p,q,g)$，节点索引为 $1,2,3,4,5$：\n- $(1,2,4.0)$\n- $(2,3,3.0)$\n- $(3,4,2.5)$\n- $(4,5,5.0)$\n- $(2,4,1.0)$\n- $(3,5,0.5)$\n\n测试套件：\n1. 理想情况，内部注入电流为零。使用并联导纳 $[y_1,y_2,y_3,y_4,y_5] = [0.5,0.4,0.3,0.2,0.5]$ 西门子，边界节点电压 $V_b = [100.0,0.0]$ 伏特，以及内部注入电流 $I_i = [0.0,0.0,0.0]$ 安培。在 $I_i = 0$ 的条件下，计算降阶模型预测的边界电流，以及通过消除内部电压从全网络计算出的边界电流。输出以安培为单位的误差绝对无穷范数，形式为浮点数。\n2. 一般情况，内部注入电流非零。使用并联导纳 $[y_1,y_2,y_3,y_4,y_5] = [0.2,0.2,0.2,0.2,0.2]$ 西门子，边界节点电压 $V_b = [230.0,115.0]$ 伏特，以及内部注入电流 $I_i = [1.0,-0.5,0.2]$ 安培。通过从全网络方程中消除内部电压，以及通过考虑了内部注入的派生降阶映射来计算边界电流。输出以安培为单位的误差绝对无穷范数，形式为浮点数。\n3. 边界情况，测试数值稳定性和互易性。使用并联导纳 $[y_1,y_2,y_3,y_4,y_5] = [0.2,10^{-6},10^{-6},0.2,0.2]$ 西门子，边界节点电压 $V_b = [10.0,-10.0]$ 伏特，以及内部注入电流 $I_i = [0.0,0.0,0.0]$ 安培。构建降阶边界导纳，并检查其是否在 $10^{-9}$ 的容差内对称，即是否满足 $\\max_{i,j} |(Y_{\\mathrm{red}})_{ij} - (Y_{\\mathrm{red}})_{ji}| \\le 10^{-9}$。输出一个布尔值，表示对称性是否成立。\n\n由于网络是电阻性的且为标量值，角度单位不适用。所有电压单位必须是伏特，所有电流单位必须是安培。\n\n最终输出格式：您的程序应生成一行输出，其中包含一个逗号分隔的列表，并用方括号括起来（例如，$[result\\_1,result\\_2,result\\_3]$）。对于测试用例 1 和 2，结果是单位为安培的浮点数；对于测试用例 3，结果是一个布尔值。",
            "solution": "我们从控制线性电阻网络的基本定律开始。Ohm 定律指出，对于连接两个节点的线性电导，电流与电导两端的电压差成正比。Kirchhoff 电流定律 (KCL) 指出，在考虑注入和流出电流时，每个节点的电流代数和为零。\n\n对于一个 $N$ 节点电阻网络，我们定义节点导纳矩阵 $Y \\in \\mathbb{R}^{N \\times N}$，使得节点注入电流向量 $I \\in \\mathbb{R}^{N}$ 和节点电压向量 $V \\in \\mathbb{R}^{N}$ 满足线性关系\n$$\nI = Y V.\n$$\n对于每条导纳为 $g \\ge 0$ 的无向线路 $(p,q)$，其对 $Y$ 的贡献为\n$$\nY_{pp} \\leftarrow Y_{pp} + g, \\quad Y_{qq} \\leftarrow Y_{qq} + g, \\quad Y_{pq} \\leftarrow Y_{pq} - g, \\quad Y_{qp} \\leftarrow Y_{qp} - g,\n$$\n这强制要求从 $p$ 流向 $q$ 的线路电流等于 $g (V_p - V_q)$，与 Ohm 定律一致。对于每个并联导纳为 $y_k \\ge 0$ 的节点 $k$，加上\n$$\nY_{kk} \\leftarrow Y_{kk} + y_k,\n$$\n代表一个从节点 $k$ 到地的电导，其电流为 $y_k V_k$。对于具有非负导纳的连通网络，得到的 $Y$ 是对称且半正定的；在有正并联导纳或足够连通性的情况下，$Y$ 通常是非奇异的。\n\n我们将节点集划分为边界节点 $b$ 和内部节点 $i$。对于五节点系统，取 $b = \\{1,5\\}$ 和 $i = \\{2,3,4\\}$。对 $V$ 和 $I$ 进行重排序，使得 $V = \\begin{bmatrix} V_b \\\\ V_i \\end{bmatrix}$ 和 $I = \\begin{bmatrix} I_b \\\\ I_i \\end{bmatrix}$，并对 $Y$ 进行相容的划分\n$$\nY = \\begin{bmatrix} Y_{bb}  Y_{bi} \\\\ Y_{ib}  Y_{ii} \\end{bmatrix}.\n$$\n节点方程可写为\n$$\n\\begin{aligned}\nI_b = Y_{bb} V_b + Y_{bi} V_i, \\\\\nI_i = Y_{ib} V_b + Y_{ii} V_i.\n\\end{aligned}\n$$\n内部节点上的 KCL 决定了第二个方程。为了消除内部电压 $V_i$，我们求解内部方程得到 $V_i$：\n$$\nV_i = Y_{ii}^{-1} (I_i - Y_{ib} V_b),\n$$\n假设 $Y_{ii}$ 是非奇异的，对于在内部节点具有足够并联或线路电导的严格无源连通网络，此假设成立。将此代入边界方程以获得降阶关系：\n$$\nI_b = \\left( Y_{bb} - Y_{bi} Y_{ii}^{-1} Y_{ib} \\right) V_b + Y_{bi} Y_{ii}^{-1} I_i.\n$$\n定义降阶边界导纳\n$$\nY_{\\mathrm{red}} := Y_{bb} - Y_{bi} Y_{ii}^{-1} Y_{ib}.\n$$\n当内部注入满足 $I_i = 0$ 时，降阶模型简化为\n$$\nI_b = Y_{\\mathrm{red}} V_b,\n$$\n这是 Kron 降阶映射。对于非零的 $I_i$，降阶映射包含附加项 $Y_{bi} Y_{ii}^{-1} I_i$，它表示在边界上看到的内部源的影响。该推导仅依赖于 KCL、Ohm 定律和通过线性代数消除内部变量。\n\n算法步骤：\n- 根据给定的线路集和并联导纳，使用导纳的加减规则构建 $Y$。\n- 根据边界和内部节点索引将 $Y$ 划分为 $Y_{bb}$、$Y_{bi}$、$Y_{ib}$、$Y_{ii}$。\n- 对于给定的 $V_b$ 和 $I_i$，通过求解 $Y_{ii} V_i = I_i - Y_{ib} V_b$ 来计算 $V_i$，为保证数值稳定性，应使用线性求解器而非显式求逆。\n- 根据全网络方程计算 $I_b$ 为 $I_b^{\\mathrm{full}} = Y_{bb} V_b + Y_{bi} V_i$。\n- 根据降阶模型计算 $I_b$ 为 $I_b^{\\mathrm{red}} = Y_{\\mathrm{red}} V_b + Y_{bi} Y_{ii}^{-1} I_i$，通过求解 $Y_{ii} X = I_i$ 得到 $X$ 并构成 $Y_{bi} X$ 来实现。\n- 对于前两个测试用例，报告绝对无穷范数误差 $\\| I_b^{\\mathrm{full}} - I_b^{\\mathrm{red}} \\|_{\\infty}$（单位：安培）。对于对称性检查，计算 $Y_{\\mathrm{red}}$ 并验证是否满足 $\\max_{i,j} |(Y_{\\mathrm{red}})_{ij} - (Y_{\\mathrm{red}})_{ji}| \\le 10^{-9}$；相应地输出一个布尔值。\n\n科学真实性与数值考量：\n- 网络是连通的，导纳是非负的，这确保了物理上的合理性。\n- 在第三种情况下，内部节点上的并联导纳值非常小，以测试数值条件，但保持为正以使 $Y_{ii}$ 可逆；使用直接求解器可以保持稳定性。\n- $Y$ 的对称性源于互易无源网络；降阶后的 $Y_{\\mathrm{red}}$ 继承了对称性，因为它是对称矩阵的 Schur 补。$10^{-9}$ 的容差考虑了有限精度算术的影响。\n\n该程序为三个指定的测试用例执行这些步骤，为前两个用例输出绝对误差值（单位：安培），为第三个用例输出一个布尔对称性检查结果，并将它们聚合为所需格式的单行输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef build_admittance_matrix(num_buses, lines, shunts):\n    \"\"\"\n    Build the nodal admittance matrix Y for a resistive network.\n    - num_buses: int, number of buses\n    - lines: list of tuples (p, q, g) with 1-based bus indices and admittance g in siemens\n    - shunts: array-like of length num_buses, shunt admittances in siemens\n    \"\"\"\n    Y = np.zeros((num_buses, num_buses), dtype=float)\n    for p, q, g in lines:\n        # Convert to 0-based indices\n        i = p - 1\n        j = q - 1\n        # Add line admittance contributions\n        Y[i, i] += g\n        Y[j, j] += g\n        Y[i, j] -= g\n        Y[j, i] -= g\n    # Add shunts\n    for k in range(num_buses):\n        Y[k, k] += shunts[k]\n    return Y\n\ndef partition_matrix(Y, b_indices, i_indices):\n    \"\"\"\n    Partition the admittance matrix Y into submatrices Y_bb, Y_bi, Y_ib, Y_ii\n    according to boundary indices b_indices and internal indices i_indices.\n    \"\"\"\n    Y_bb = Y[np.ix_(b_indices, b_indices)]\n    Y_bi = Y[np.ix_(b_indices, i_indices)]\n    Y_ib = Y[np.ix_(i_indices, b_indices)]\n    Y_ii = Y[np.ix_(i_indices, i_indices)]\n    return Y_bb, Y_bi, Y_ib, Y_ii\n\ndef kron_reduce(Y_bb, Y_bi, Y_ib, Y_ii):\n    \"\"\"\n    Compute the Kron-reduced boundary admittance matrix:\n    Y_red = Y_bb - Y_bi * inv(Y_ii) * Y_ib\n    Implemented with linear solves for numerical stability.\n    \"\"\"\n    # Solve Y_ii * X = Y_ib for X\n    X = np.linalg.solve(Y_ii, Y_ib)\n    return Y_bb - Y_bi @ X\n\ndef boundary_currents_full(Y_bb, Y_bi, Y_ib, Y_ii, V_b, I_i):\n    \"\"\"\n    Compute boundary currents using the full network by eliminating internal voltages:\n    V_i = solve(Y_ii, I_i - Y_ib * V_b)\n    I_b_full = Y_bb * V_b + Y_bi * V_i\n    \"\"\"\n    rhs = I_i - (Y_ib @ V_b)\n    V_i = np.linalg.solve(Y_ii, rhs)\n    I_b_full = Y_bb @ V_b + Y_bi @ V_i\n    return I_b_full\n\ndef boundary_currents_reduced(Y_red, Y_bi, Y_ii, V_b, I_i):\n    \"\"\"\n    Compute boundary currents using the reduced mapping with internal injections:\n    I_b_red = Y_red * V_b + Y_bi * inv(Y_ii) * I_i\n    Implemented with a linear solve.\n    \"\"\"\n    X = np.linalg.solve(Y_ii, I_i)\n    return Y_red @ V_b + Y_bi @ X\n\ndef solve():\n    # Common line set: (p, q, g) with buses indexed 1..5\n    lines = [\n        (1, 2, 4.0),\n        (2, 3, 3.0),\n        (3, 4, 2.5),\n        (4, 5, 5.0),\n        (2, 4, 1.0),\n        (3, 5, 0.5),\n    ]\n    num_buses = 5\n    # Boundary and internal indices in 0-based indexing\n    b_idx = [0, 4]       # buses {1, 5}\n    i_idx = [1, 2, 3]    # buses {2, 3, 4}\n\n    results = []\n\n    # Test case 1: Happy path, zero internal injections\n    shunts1 = np.array([0.5, 0.4, 0.3, 0.2, 0.5], dtype=float)\n    Y1 = build_admittance_matrix(num_buses, lines, shunts1)\n    Y_bb1, Y_bi1, Y_ib1, Y_ii1 = partition_matrix(Y1, b_idx, i_idx)\n    Y_red1 = kron_reduce(Y_bb1, Y_bi1, Y_ib1, Y_ii1)\n    V_b1 = np.array([100.0, 0.0], dtype=float)   # volts\n    I_i1 = np.array([0.0, 0.0, 0.0], dtype=float)  # amperes\n    I_b_full_1 = boundary_currents_full(Y_bb1, Y_bi1, Y_ib1, Y_ii1, V_b1, I_i1)\n    I_b_red_1 = Y_red1 @ V_b1  # since I_i = 0, reduced mapping simplifies\n    mismatch1 = np.linalg.norm(I_b_full_1 - I_b_red_1, ord=np.inf)\n    results.append(mismatch1)\n\n    # Test case 2: General case, nonzero internal injections\n    shunts2 = np.array([0.2, 0.2, 0.2, 0.2, 0.2], dtype=float)\n    Y2 = build_admittance_matrix(num_buses, lines, shunts2)\n    Y_bb2, Y_bi2, Y_ib2, Y_ii2 = partition_matrix(Y2, b_idx, i_idx)\n    Y_red2 = kron_reduce(Y_bb2, Y_bi2, Y_ib2, Y_ii2)\n    V_b2 = np.array([230.0, 115.0], dtype=float)  # volts\n    I_i2 = np.array([1.0, -0.5, 0.2], dtype=float)  # amperes\n    I_b_full_2 = boundary_currents_full(Y_bb2, Y_bi2, Y_ib2, Y_ii2, V_b2, I_i2)\n    I_b_red_2 = boundary_currents_reduced(Y_red2, Y_bi2, Y_ii2, V_b2, I_i2)\n    mismatch2 = np.linalg.norm(I_b_full_2 - I_b_red_2, ord=np.inf)\n    results.append(mismatch2)\n\n    # Test case 3: Edge case, near-singular internal shunts; symmetry check of Y_red\n    shunts3 = np.array([0.2, 1e-6, 1e-6, 0.2, 0.2], dtype=float)\n    Y3 = build_admittance_matrix(num_buses, lines, shunts3)\n    Y_bb3, Y_bi3, Y_ib3, Y_ii3 = partition_matrix(Y3, b_idx, i_idx)\n    Y_red3 = kron_reduce(Y_bb3, Y_bi3, Y_ib3, Y_ii3)\n    # Symmetry check within tolerance\n    tol = 1e-9\n    symmetric = np.max(np.abs(Y_red3 - Y_red3.T)) = tol\n    results.append(symmetric)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "本实践将介绍使用径向基函数（Radial Basis Functions, RBFs）进行代理建模，这是一种为复杂输入-输出关系创建快速、准确近似的强大技术。你将为一组能源系统性能数据构建一个RBF插值器，并探索关键的形状参数 $c$ 所扮演的角色。这个练习突显了在模型平滑度、局部性和数值稳定性之间的权衡，这些是构建有效代理模型的核心问题 。",
            "id": "4127524",
            "problem": "考虑一个能源系统建模中的代理建模任务，其中一个标量、无量纲的性能指标 $y$（例如，归一化的净发电成本）必须从二维 ($2$D) 运行工况 $\\mathbf{x} \\in \\mathbb{R}^2$ 推断出来，该工况代表归一化的电负荷和热负荷水平。给定4个运行点处的训练快照\n$$\\mathbf{x}_1 = (1,0),\\quad \\mathbf{x}_2 = (-1,0),\\quad \\mathbf{x}_3 = (0,1),\\quad \\mathbf{x}_4 = (0,-1),$$\n及其测得的响应值\n$$y_1 = 1,\\quad y_2 = 1,\\quad y_3 = 1,\\quad y_4 = 1.$$\n采用一个由平移径向基函数的线性组合定义的径向基代理模型，即形状参数为 $c0$ 的多二次函数，\n$$\\phi(r)=\\sqrt{r^2 + c^2},$$\n其中 $r$ 表示 $\\mathbb{R}^2$ 中的欧几里得距离。在4个训练快照上施加精确插值条件。仅使用插值定义和欧几里得范数，推导系数并计算插值函数在新运行点\n$$\\mathbf{x}^{\\ast}=(0,0),$$ \n处的值，并将最终结果解析地表示为形状参数 $c$ 的函数。此外，根据你的推导，解释 $c$ 的选择如何影响该数据集代理拟合的平滑性、局部性和条件性，并将你的讨论建立在插值系统的极限行为和结构特性之上。以 $c$ 的单个闭式解析表达式形式给出在 $\\mathbf{x}^{\\ast}$ 处的插值函数值。无需四舍五入，且由于 $y$ 是无量纲的，因此没有物理单位。",
            "solution": "本任务是使用径向基函数 (RBF) 插值函数构建一个代理模型，并在一个特定点上对其进行求值。我们还被要求分析形状参数 $c$ 的作用。\n\n对于一组 $N$ 个训练点 $\\{\\mathbf{x}_i\\}_{i=1}^N$ 及其对应的值 $\\{y_i\\}_{i=1}^N$，RBF 插值函数 $S(\\mathbf{x})$ 的一般形式由平移基函数的线性组合给出：\n$$S(\\mathbf{x}) = \\sum_{j=1}^{N} w_j \\phi(\\|\\mathbf{x} - \\mathbf{x}_j\\|)$$\n其中 $w_j$ 是待定权重，$\\phi$ 是径向基函数，$\\|\\cdot\\|$ 表示欧几里得范数。在本问题中，$N=4$ 且 RBF 是形状参数为 $c0$ 的多二次函数 $\\phi(r) = \\sqrt{r^2 + c^2}$。\n\n精确插值条件要求代理模型与训练数据完全匹配，即对每个 $i \\in \\{1, 2, 3, 4\\}$ 都有 $S(\\mathbf{x}_i) = y_i$。这为4个未知权重 $w_j$ 产生了一个包含4个线性方程的方程组：\n$$\\sum_{j=1}^{4} w_j \\phi(\\|\\mathbf{x}_i - \\mathbf{x}_j\\|) = y_i, \\quad \\text{for } i = 1, 2, 3, 4.$$\n该方程组可以写成矩阵形式 $\\mathbf{\\Phi} \\mathbf{w} = \\mathbf{y}$，其中 $\\mathbf{w} = [w_1, w_2, w_3, w_4]^T$ 是权重向量，$\\mathbf{y} = [y_1, y_2, y_3, y_4]^T$ 是观测响应向量，$\\mathbf{\\Phi}$ 是插值矩阵，其元素为 $\\Phi_{ij} = \\phi(\\|\\mathbf{x}_i - \\mathbf{x}_j\\|)$。\n\n首先，我们计算给定训练点 $\\mathbf{x}_1 = (1,0)$、$\\mathbf{x}_2 = (-1,0)$、$\\mathbf{x}_3 = (0,1)$ 和 $\\mathbf{x}_4 = (0,-1)$ 之间的欧几里得距离矩阵 $r_{ij} = \\|\\mathbf{x}_i - \\mathbf{x}_j\\|$。\n对角线元素为 $r_{ii} = 0$。\n非对角线距离为：\n$r_{12} = \\|\\mathbf{x}_1 - \\mathbf{x}_2\\| = \\|(1 - (-1), 0 - 0)\\| = \\|(2,0)\\| = 2$。\n$r_{13} = \\|\\mathbf{x}_1 - \\mathbf{x}_3\\| = \\|(1 - 0, 0 - 1)\\| = \\|(1,-1)\\| = \\sqrt{1^2 + (-1)^2} = \\sqrt{2}$。\n$r_{14} = \\|\\mathbf{x}_1 - \\mathbf{x}_4\\| = \\|(1 - 0, 0 - (-1))\\| = \\|(1,1)\\| = \\sqrt{1^2 + 1^2} = \\sqrt{2}$。\n$r_{23} = \\|\\mathbf{x}_2 - \\mathbf{x}_3\\| = \\|(-1 - 0, 0 - 1)\\| = \\|(-1,-1)\\| = \\sqrt{(-1)^2 + (-1)^2} = \\sqrt{2}$。\n$r_{24} = \\|\\mathbf{x}_2 - \\mathbf{x}_4\\| = \\|(-1 - 0, 0 - (-1))\\| = \\|(-1,1)\\| = \\sqrt{(-1)^2 + 1^2} = \\sqrt{2}$。\n$r_{34} = \\|\\mathbf{x}_3 - \\mathbf{x}_4\\| = \\|(0 - 0, 1 - (-1))\\| = \\|(0,2)\\| = 2$。\n根据对称性，$r_{ij} = r_{ji}$。\n\n接下来，我们将 RBF $\\phi(r) = \\sqrt{r^2 + c^2}$ 应用于每个距离 $r_{ij}$，以构建插值矩阵 $\\mathbf{\\Phi}$：\n$\\Phi_{ii} = \\phi(0) = \\sqrt{0^2 + c^2} = c$。\n$\\Phi_{12} = \\phi(2) = \\sqrt{2^2 + c^2} = \\sqrt{4 + c^2}$。\n$\\Phi_{13} = \\phi(\\sqrt{2}) = \\sqrt{(\\sqrt{2})^2 + c^2} = \\sqrt{2 + c^2}$。\n完整的矩阵是：\n$$\n\\mathbf{\\Phi} = \\begin{pmatrix}\nc   \\sqrt{4+c^2}   \\sqrt{2+c^2}   \\sqrt{2+c^2} \\\\\n\\sqrt{4+c^2}   c   \\sqrt{2+c^2}   \\sqrt{2+c^2} \\\\\n\\sqrt{2+c^2}   \\sqrt{2+c^2}   c   \\sqrt{4+c^2} \\\\\n\\sqrt{2+c^2}   \\sqrt{2+c^2}   \\sqrt{4+c^2}   c\n\\end{pmatrix}\n$$\n响应向量为 $\\mathbf{y} = [1, 1, 1, 1]^T$。线性方程组为 $\\mathbf{\\Phi} \\mathbf{w} = \\mathbf{y}$。\n\n由于问题设置具有高度对称性（这些点是以原点为中心的正方形的顶点，且所有响应值都相同），我们可以推断权重也必须是对称的，即 $w_1 = w_2 = w_3 = w_4 = w$。让我们来验证这一点。如果我们将所有权重都设为同一个值 $w$，方程组 $\\mathbf{\\Phi}\\mathbf{w}=\\mathbf{y}$ 的第一行变为：\n$$(c)w + (\\sqrt{4+c^2})w + (\\sqrt{2+c^2})w + (\\sqrt{2+c^2})w = 1$$\n$$w(c + \\sqrt{4+c^2} + 2\\sqrt{2+c^2}) = 1$$\n矩阵 $\\mathbf{\\Phi}$ 的每一行都是第一行元素的排列。由于 $\\mathbf{y}$ 的所有元素都为 1，因此将 $\\mathbf{\\Phi}$ 任意一行的元素相加再乘以 $w$ 必须等于 1。每一行的元素之和是相同的：$c + \\sqrt{4+c^2} + 2\\sqrt{2+c^2}$。因此，假设 $w_1 = w_2 = w_3 = w_4 = w$ 是正确的，并满足整个方程组。\n因此，统一的权重 $w$ 为：\n$$w = \\frac{1}{c + \\sqrt{4+c^2} + 2\\sqrt{2+c^2}}$$\n系数为 $w_1 = w_2 = w_3 = w_4 = w$。\n\n现在，我们在新运行点 $\\mathbf{x}^{\\ast}=(0,0)$ 处计算插值函数 $S(\\mathbf{x})$ 的值：\n$$S(\\mathbf{x}^{\\ast}) = \\sum_{j=1}^{4} w_j \\phi(\\|\\mathbf{x}^{\\ast} - \\mathbf{x}_j\\|)$$\n从 $\\mathbf{x}^{\\ast}=(0,0)$ 到训练点的距离为：\n$\\|\\mathbf{x}^{\\ast} - \\mathbf{x}_1\\| = \\|(0,0) - (1,0)\\| = 1$。\n$\\|\\mathbf{x}^{\\ast} - \\mathbf{x}_2\\| = \\|(0,0) - (-1,0)\\| = 1$。\n$\\|\\mathbf{x}^{\\ast} - \\mathbf{x}_3\\| = \\|(0,0) - (0,1)\\| = 1$。\n$\\|\\mathbf{x}^{\\ast} - \\mathbf{x}_4\\| = \\|(0,0) - (0,-1)\\| = 1$。\n所有距离都等于 1。对应的 RBF 值为 $\\phi(1) = \\sqrt{1^2 + c^2} = \\sqrt{1+c^2}$。\n将权重和 RBF 值代入 $S(\\mathbf{x}^{\\ast})$ 的表达式中：\n$$S(\\mathbf{x}^{\\ast}) = w_1\\phi(1) + w_2\\phi(1) + w_3\\phi(1) + w_4\\phi(1) = (w_1+w_2+w_3+w_4)\\phi(1) = 4w\\phi(1)$$\n$$S(\\mathbf{x}^{\\ast}) = 4 \\left( \\frac{1}{c + \\sqrt{4+c^2} + 2\\sqrt{2+c^2}} \\right) \\sqrt{1+c^2}$$\n$$S(\\mathbf{x}^{\\ast}) = \\frac{4\\sqrt{1+c^2}}{c + \\sqrt{4+c^2} + 2\\sqrt{2+c^2}}$$\n\n最后，我们讨论形状参数 $c$ 的影响。\n1.  **平滑性**：对于任何 $c0$，多二次 RBF $\\phi(r) = \\sqrt{r^2+c^2}$ 都是无限可微的 ($C^\\infty$)。插值函数 $S(\\mathbf{x})$ 作为这类函数的线性组合，也是 $C^\\infty$ 的。然而，所得曲面的有效平滑度或平坦度由 $c$ 控制。当 $c \\to \\infty$ 时，基函数 $\\phi(r) \\approx c + \\frac{r^2}{2c}$，变得非常平坦，并接近一个常数加上一个二次项。这导致了一个全局“更平滑”的插值函数，类似于一个低阶多项式。相反，当 $c \\to 0$ 时，$\\phi(r) \\to \\sqrt{r^2} = r$，这是锥形 RBF。该函数仅是连续的 ($C^0$)，在 $r=0$ 处有一个尖峰。得到的插值函数变得更“尖锐”且更不平滑。\n\n2.  **局部性**：参数 $c$ 控制基函数的“宽度”。对于小的 $c$，函数 $\\phi(r)$ 在 $r=0$ 处峰值尖锐，衰减相对较快，使其成为一个局部化的函数。这意味着插值函数在某点 $\\mathbf{x}$ 的值主要受最近的训练点的影响。对于大的 $c$，函数 $\\phi(r)$ 非常平坦和宽广，使其成为一个全局性函数。在这种情况下，每个训练点都对整个域上的插值函数值有显著影响。小的 $c$ 意味着高局部性；大的 $c$ 意味着低局部性。\n\n3.  **条件性**：线性方程组 $\\mathbf{\\Phi}\\mathbf{w} = \\mathbf{y}$ 的条件性由矩阵 $\\mathbf{\\Phi}$ 的条件数决定。当 $c \\to \\infty$ 时，非对角线元素 $\\sqrt{r^2+c^2} = c\\sqrt{1+r^2/c^2} \\approx c(1 + \\frac{r^2}{2c^2}) = c + \\frac{r^2}{2c}$ 接近对角线元素 $c$。矩阵 $\\mathbf{\\Phi}$ 的所有元素都变得非常接近。这导致 $\\mathbf{\\Phi}$ 的列（和行）变得近乎线性相关，使得矩阵几乎奇异。因此，当 $c \\to \\infty$ 时，$\\mathbf{\\Phi}$ 的条件数变得非常大，导致一个数值病态系统。对于较小的 $c$ 值，该矩阵通常是良态的。这种权衡是 RBF 插值的一个基本方面：更平坦的基函数（大的 $c$）可以产生更平滑的拟合，但代价是数值不稳定性。\n\n在这个具体问题中，当 $c \\to \\infty$ 时，由于所有数据点的 $y_i=1$，插值函数必须趋近于常数值 1。我们的结果证实了这一点：$\\lim_{c \\to \\infty} S(\\mathbf{x}^{\\ast}) = \\lim_{c \\to \\infty} \\frac{4c}{c+c+2c} = \\frac{4c}{4c} = 1$。当 $c \\to 0$ 时，我们的结果趋近于一个有限值 $S(\\mathbf{x}^{\\ast}) \\to \\frac{4}{2+2\\sqrt{2}} = 2(\\sqrt{2}-1) \\approx 0.828$，这对应于使用锥形基函数的插值。",
            "answer": "$$\\boxed{\\frac{4\\sqrt{1+c^2}}{c + \\sqrt{4+c^2} + 2\\sqrt{2+c^2}}}$$"
        }
    ]
}