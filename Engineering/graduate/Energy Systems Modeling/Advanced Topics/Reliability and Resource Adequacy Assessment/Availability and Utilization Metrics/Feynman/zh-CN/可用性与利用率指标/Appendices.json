{
    "hands_on_practices": [
        {
            "introduction": "理解可用性的基础是掌握其两种核心计算方法。本练习将引导你区分理论稳态可用性（基于更新过程参数如平均无故障时间 $MTBF$ 和平均修复时间 $MTTR$）与经验可用性（源自有限时间范围内的运行数据），这对于连接理论模型与实际观测至关重要。通过计算这两种度量之间的差异，你将体会到模型假设与现实世界数据之间的细微差别。",
            "id": "4070894",
            "problem": "一个电力系统中的单台发电机组被建模为一个在运行状态和维修状态之间交替的更新过程。在多个周期内，测得的平均无故障时间 (MTBF) 为 $2000\\,\\mathrm{h}$，平均修复时间 (MTTR) 为 $50\\,\\mathrm{h}$。另外，在一个 $20{,}000\\,\\mathrm{h}$ 的时间跨度内，聚合的时间序列记录报告总正常运行时间 $T_{\\text{up}}=18{,}900\\,\\mathrm{h}$ 和总停机时间 $T_{\\text{down}}=1{,}100\\,\\mathrm{h}$。\n\n仅使用可用性的基本定义（即系统处于运行状态的时间占总时间的长期比例）和更新过程的适当极限定理，推导由 $MTBF$ 和 $MTTR$ 隐含的稳态可用度，以及由时间序列 $\\{T_{\\text{up}},T_{\\text{down}}\\}$ 隐含的经验可用度。计算这两个可用度指标之间的绝对差值并报告该差值。\n\n将您的最终数值结果四舍五入到四位有效数字。将最终答案表示为一个无量纲的小数（不要使用百分号）。",
            "solution": "首先验证问题的科学性、自洽性和良定性。给定的参数是平均无故障时间 ($MTBF = 2000\\,\\mathrm{h}$)、平均修复时间 ($MTTR = 50\\,\\mathrm{h}$)、总正常运行时间 ($T_{\\text{up}} = 18{,}900\\,\\mathrm{h}$) 和总停机时间 ($T_{\\text{down}} = 1{,}100\\,\\mathrm{h}$)，时间跨度为 $20{,}000\\,\\mathrm{h}$。总和 $T_{\\text{up}} + T_{\\text{down}} = 18{,}900\\,\\mathrm{h} + 1{,}100\\,\\mathrm{h} = 20{,}000\\,\\mathrm{h}$ 与所述的总时间跨度一致。可用度、MTBF 和 MTTR 的概念是可靠性工程中的基础概念。因此，该问题是有效的。\n\n任务是计算两种不同可用度度量之间的绝对差值：从更新过程参数（$MTBF$ 和 $MTTR$）推导出的理论稳态可用度，以及从时间序列数据（$T_{\\text{up}}$ 和 $T_{\\text{down}}$）测量的经验可用度。\n\n首先，我们推导稳态可用度，记为 $A_{\\text{ss}}$。对于一个在运行状态和维修状态之间交替的系统，稳态可用度是系统处于运行状态的长期概率。它由运行状态的平均持续时间 ($MTBF$) 与一个完整周期（运行+维修）的平均持续时间之比给出。\n平均周期时间为 $MTBF + MTTR$。\n稳态可用度的公式为：\n$$A_{\\text{ss}} = \\frac{MTBF}{MTBF + MTTR}$$\n代入给定值：\n$$A_{\\text{ss}} = \\frac{2000}{2000 + 50} = \\frac{2000}{2050} = \\frac{40}{41}$$\n\n接下来，我们推导经验可用度，记为 $A_{\\text{emp}}$。这是根据有限观测期内的聚合时间序列数据计算得出的。它是机组运行的总时间 ($T_{\\text{up}}$) 与总观测时间 ($T_{\\text{total}}$) 之比。\n总观测时间是正常运行时间和停机时间之和：\n$$T_{\\text{total}} = T_{\\text{up}} + T_{\\text{down}} = 18{,}900\\,\\mathrm{h} + 1{,}100\\,\\mathrm{h} = 20{,}000\\,\\mathrm{h}$$\n经验可用度的公式为：\n$$A_{\\text{emp}} = \\frac{T_{\\text{up}}}{T_{\\text{total}}}$$\n代入给定值：\n$$A_{\\text{emp}} = \\frac{18{,}900}{20{,}000} = \\frac{189}{200}$$\n\n问题要求计算这两个可用度指标之间的绝对差值 $\\Delta A$。\n$$\\Delta A = |A_{\\text{ss}} - A_{\\text{emp}}|$$\n代入 $A_{\\text{ss}}$ 和 $A_{\\text{emp}}$ 的推导表达式：\n$$\\Delta A = \\left| \\frac{40}{41} - \\frac{189}{200} \\right|$$\n为了进行分数相减，我们找到一个公分母，即 $41 \\times 200 = 8200$。\n$$\\Delta A = \\left| \\frac{40 \\times 200}{41 \\times 200} - \\frac{189 \\times 41}{200 \\times 41} \\right| = \\left| \\frac{8000}{8200} - \\frac{7749}{8200} \\right|$$\n在分子上进行减法运算：\n$$\\Delta A = \\left| \\frac{8000 - 7749}{8200} \\right| = \\frac{251}{8200}$$\n\n最后，我们计算 $\\Delta A$ 的数值，并按要求将其四舍五入到四位有效数字。\n$$\\Delta A = \\frac{251}{8200} \\approx 0.030609756...$$\n为了四舍五入到四位有效数字，我们从第一个非零数字开始看。第一个有效数字是 $3$。随后的三个数字是 $0$、$6$ 和 $0$。第五个有效数字是 $9$。由于 $9 \\ge 5$，我们将第四个有效数字（$0$）向上取整为 $1$。\n因此，四舍五入后的值为 $0.03061$。",
            "answer": "$$\\boxed{0.03061}$$"
        },
        {
            "introduction": "在能源系统中，并非所有停机时间都具有相同的影响；关键在于发电机组在被需要时是否可用。本练习将带你深入探讨两种关键的可靠性指标：需求加权等效强迫停运率 ($EFORd$) 和基于时间的强迫停运率 ($FOR$)。通过在一个包含计划性维护和需求波动的现实场景中计算这两个指标，你将学习到如何根据系统需求来量化机组的可靠性，这对于准确评估发电资产的性能至关重要。",
            "id": "4070919",
            "problem": "一位电力系统运营商正在为一个净负荷较低且有计划性维护停运的平季月份，对单个火力发电机组的可靠性性能进行建模。该运营商希望使用该机组的每小时事件历史记录，从基本原理出发量化两个可靠性指标：需求加权等效强迫停运率 (EFORd) 和基于时间的强迫停运率 (FOR)。然后，该运营商将比较这些指标，以理解平季维护和低净负荷如何影响对机组可靠性的评估。\n\n使用以下基本原理和事件数据：\n\n基本原理：\n- 发电机组的可用性由一个指示函数 $A(t)$ 表示，当机组未处于计划性维护且未处于强迫停运状态时，该函数等于 $1$，否则等于 $0$。运营商通过指示函数 $M(t)$ 记录计划性维护，通过指示函数 $F(t)$ 记录强迫停运，这些状态是互斥的，因此对于任何小时 $t$，$M(t)$、$F(t)$ 或 $A(t)$ 中只有一个等于 $1$。\n- 将机组的需求（调用服务）定义为一个二元指示函数 $C(t)$，如果系统在小时 $t$ 会调度该机组（假如它可用的情况下），则该函数等于 $1$，否则等于 $0$。运营商在概念上将 EFORd 建模为被调用的机组因强迫停运而无法供电的时间比例，将 FOR 建模为在未进行计划性维护的时间段内机组处于强迫停运状态的时间比例。\n- 您将把这个月视为一个 $H$ 小时的离散时间范围，并通过汇总记录的每小时事件历史来计算这两个指标。\n\n平季月份的事件历史：\n- 总时间范围：$H = 672$ 小时。\n- 计划性维护小时数：$H_{P} = 336$ 个连续小时，从小时 $t=0$ 到小时 $t=335$，因此在这些小时内 $M(t) = 1$。\n- 非维护小时数：$H_{\\text{NM}} = 336$ 小时，从小时 $t=336$ 到小时 $t=671$。\n- 非维护期间的需求（调用）：机组将被调用 $H_{R} = 192$ 小时；不会被调用 $336 - 192 = 144$ 小时。也就是说，在非维护小时内，有 $192$ 个小时 $C(t) = 1$，有 $144$ 个小时 $C(t) = 0$。\n- 非维护期间的强迫停运事件：\n  1. 事件 $F_{1}$：从小时 $t=336$ 开始到小时 $t=349$ 结束（含）的连续 $14$ 小时强迫停运，其中有 $10$ 个小时与 $C(t) = 1$ 同时发生。\n  2. 事件 $F_{2}$：当月晚些时候发生的连续 $7$ 小时强迫停运，所有 $7$ 个小时都与 $C(t) = 1$ 同时发生。\n  3. 事件 $F_{3}$：夜间发生的连续 $5$ 小时强迫停运，所有 $5$ 个小时都与 $C(t) = 0$ 同时发生。\n- 没有其他强迫停运事件。没有部分强迫停运；每当 $F(t) = 1$ 时，机组的可用容量降至零。\n\n任务：\n1. 从上述定义出发，将需求加权等效强迫停运率 (EFORd) 表示为一个仅使用机组被调用时的强迫停运小时数的适当小时汇总形式，并根据给定的事件历史推导出其值。\n2. 将基于时间的强迫停运率 (FOR) 表示为一个使用计划性维护之外所有强迫停运小时数的适当小时汇总形式，并根据给定的事件历史推导出其值。\n3. 以无量纲小数的形式提供计算出的两个率值，并将每个值四舍五入到四位有效数字。不要使用百分号。\n\n将您的最终输出表示为有序对 $\\left(\\text{EFORd}, \\text{FOR}\\right)$。",
            "solution": "对用户提供的问题进行有效性评估。\n\n### 步骤1：提取已知条件\n- **指示函数**：$A(t)$ 表示可用，$M(t)$ 表示计划性维护，$F(t)$ 表示强迫停运。对于任何小时 $t$，其中只有一个为 $1$。\n- **需求指示函数**：如果机组被调用服务，则 $C(t)$ 为 $1$，否则为 $0$。\n- **概念定义**：\n  - EFORd：“被调用的机组因强迫停运而无法供电的时间比例”。\n  - FOR：“在未进行计划性维护的时间段内机组处于强迫停运状态的时间比例”。\n- **时间范围**：离散的，$H$ 小时。\n- **事件历史数据**：\n  - 总时间范围：$H = 672$ 小时。\n  - 计划性维护小时数：$H_{P} = 336$ 小时（从 $t=0$ 到 $t=335$，因此在此区间内 $M(t)=1$）。\n  - 非维护小时数：$H_{\\text{NM}} = 336$ 小时（从 $t=336$ 到 $t=671$）。\n  - 非维护期间的需求：机组被调用 $H_{R} = 192$ 小时（$C(t)=1$），未被调用 $144$ 小时（$C(t)=0$）。\n  - 强迫停运事件 $F_1$：总计 $14$ 小时，其中 $10$ 小时与 $C(t)=1$ 同时发生。\n  - 强迫停运事件 $F_2$：总计 $7$ 小时，所有 $7$ 小时均与 $C(t)=1$ 同时发生。\n  - 强迫停运事件 $F_3$：总计 $5$ 小时，所有 $5$ 小时均与 $C(t)=0$ 同时发生。\n  - 无其他强迫停运，无部分停运。\n\n### 步骤2：使用提取的已知条件进行验证\n该问题基于电力系统可靠性工程的标准原理，具有科学依据，并使用了如 EFORd 和 FOR 等已确立的指标。所提供的定义与行业实践（例如，NERC GADS）一致，尽管为了问题可解而进行了简化。这是一个提法明确的问题，提供了计算所需指标的所有必要数据。数据是内部一致的：$H_P + H_{\\text{NM}} = 336+336=672 = H$，并且在非维护期间，调用小时数（$192$）和未调用小时数（$144$）之和为 $192+144=336$，与 $H_{\\text{NM}}$ 相符。强迫停运小时数的分解情况也是一致的。该问题是客观、可量化的，并且不违反任何科学或逻辑原理。它是能源系统建模中一个有效且结构良好的问题。\n\n### 步骤3：结论与行动\n问题有效。将提供完整解答。\n\n### 解答推导\n\n该问题要求基于总时间范围为 $H=672$ 小时的离散时间事件历史，计算两个不同的可靠性指标：需求加权等效强迫停运率 (EFORd) 和基于时间的强迫停运率 (FOR)。\n\n首先，我们形式化定义并汇总所提供的事件数据。设离散时间索引为 $t \\in \\{0, 1, \\dots, H-1\\}$。发电机组的状态由互斥的指示函数 $A(t)$、$M(t)$ 和 $F(t)$ 描述，使得对于所有 $t$ 都有 $A(t) + M(t) + F(t) = 1$。\n\n计划性维护的总小时数给定为 $H_P = 336$。用我们的求和表示法，即 $H_P = \\sum_{t=0}^{H-1} M(t) = 336$。\n\n未处于计划性维护的时期，我们称之为服务期，包含 $H_{\\text{NM}}$ 小时：\n$$H_{\\text{NM}} = H - H_P = 672 - 336 = 336 \\text{ 小时}$$\n在此服务期间，机组要么可用（$A(t)=1$），要么处于强迫停运状态（$F(t)=1$）。因此，对于任何 $M(t)=0$ 的 $t$，我们有 $A(t) + F(t) = 1$。此期间的持续时间可以表示为 $\\sum_{t=0}^{H-1} (1-M(t))$。\n\n接下来，我们汇总强迫停运小时数。所有强迫停运都发生在非维护期间。\n- 事件 $F_1$ 的总小时数：$14$ 小时。\n- 事件 $F_2$ 的总小时数：$7$ 小时。\n- 事件 $F_3$ 的总小时数：$5$ 小时。\n\n总强迫停运小时数 $H_{FO}$ 是这些事件持续时间的总和：\n$$H_{FO} = 14 + 7 + 5 = 26 \\text{ 小时}$$\n用符号表示，$H_{FO} = \\sum_{t=0}^{H-1} F(t)$。\n\n对于 EFORd，我们需要考虑机组被调用服务的时间，由 $C(t)=1$ 表示。机组被调用的总小时数 $H_R$ 给定为 $192$：\n$$H_R = \\sum_{t=0}^{H-1} C(t) = 192 \\text{ 小时}$$\n我们还必须找出在机组被调用时发生的强迫停运小时数。设此为 $H_{FOC}$（被调用期间的强迫停运小时数）。\n- 来自事件 $F_1$：$10$ 小时与 $C(t)=1$ 同时发生。\n- 来自事件 $F_2$：$7$ 小时与 $C(t)=1$ 同时发生。\n- 来自事件 $F_3$：$0$ 小时与 $C(t)=1$ 同时发生。\n\n将这些相加得到：\n$$H_{FOC} = 10 + 7 + 0 = 17 \\text{ 小时}$$\n用符号表示，$H_{FOC} = \\sum_{t=0}^{H-1} F(t)C(t)$。\n\n**1. EFORd 的计算**\n问题将 EFORd 定义为“被调用的机组因强迫停运而无法供电的时间比例”。这是一个条件概率：在机组被调用的条件下，其处于强迫停运状态的概率。这可以转化为被调用期间的总强迫停运小时数与机组被调用的总小时数之比。\n\n$$ \\text{EFORd} = \\frac{\\text{被调用期间的强迫停运小时数}}{\\text{总调用小时数}} = \\frac{H_{FOC}}{H_R} $$\n使用汇总值：\n$$ \\text{EFORd} = \\frac{17}{192} $$\n换算成小数，即 $17 \\div 192 \\approx 0.08854166\\ldots$。四舍五入到四位有效数字，我们得到：\n$$ \\text{EFORd} \\approx 0.08854 $$\n\n**2. FOR 的计算**\n问题将 FOR 定义为“在未进行计划性维护的时间段内机组处于强迫停运状态的时间比例”。这是总强迫停运小时数与服务期总时长（即非维护小时数）之比。\n\n$$ \\text{FOR} = \\frac{\\text{总强迫停运小时数}}{\\text{非维护小时数}} = \\frac{H_{FO}}{H_{\\text{NM}}} $$\n使用汇总值：\n$$ \\text{FOR} = \\frac{26}{336} $$\n这个分数可以通过将分子和分母除以它们的最大公约数 $2$ 来简化：\n$$ \\text{FOR} = \\frac{13}{168} $$\n换算成小数，即 $13 \\div 168 \\approx 0.07738095\\ldots$。四舍五入到四位有效数字，我们得到：\n$$ \\text{FOR} \\approx 0.07738 $$\n\n计算出的两个率值为 $\\text{EFORd} \\approx 0.08854$ 和 $\\text{FOR} \\approx 0.07738$。EFORd 高于 FOR，这对于这种平季情景来说是一个预期的结果。FOR 指标计入了服务期间所有的强迫停运小时数（$26$ 小时），包括那些机组不需要运行的时间（例如，事件 $F_3$ 的 $5$ 小时）。相比之下，EFORd 只关注需求期间的故障。它的分母更小（$192$ 对 $336$），并且排除了那些没有直接系统影响的故障，这使其从满足需求的角度来看，是一个更准确的可靠性度量。很大一部分强迫停运小时数（$26$ 小时中的 $17$ 小时）发生在需求期间，而服务期的很大一部分处于非高峰时段（$144$ 小时），这一事实导致 EFORd 值大于 FOR 值。\n\n最终结果是有序对 $(\\text{EFORd}, \\text{FOR})$。",
            "answer": "$$\\boxed{(0.08854, 0.07738)}$$"
        },
        {
            "introduction": "在现代能源系统中，尤其是对于风能和太阳能等可变电源，评估可用性面临着新的挑战，因为部分停运和资源波动使得简单的状态划分变得困难。本练习模拟了一项高级工程任务：仅使用高分辨率的功率输出数据（SCADA 数据）来估算可用功率，并计算一个能纠正部分停运影响的容量加权可用性指标。通过实施一种基于滑动窗口分位数的算法，你将获得从原始运行数据中提取有价值性能指标的实践经验，这是现代能源数据分析的一项核心技能。",
            "id": "4070903",
            "problem": "一位发电厂运营商希望根据高分辨率的监控与数据采集 (SCADA) 仅功率数据，计算一个经过部分停运校正的、基于容量的可用性指标。设 $P_{\\text{meas}}(t)$ 表示作为时间 $t$ 的函数的测量交流 (AC) 功率，单位为兆瓦，以秒为单位的时间步长 $\\Delta t$ 进行均匀采样。其根本目标是估计瞬时可用功率 $P_{\\text{available}}(t)$（即在没有停运或限电等内部限制的情况下，发电厂本可以产生的功率），然后计算指定时间范围内的资源加权容量可用性 $A_{\\text{cap}}$。\n\n从以下基本依据和假设出发：\n- 能量是功率对时间的积分：对于任何区间 $[t_0,t_1]$，能量（单位为兆瓦秒）为 $E = \\int_{t_0}^{t_1} P(t)\\,\\mathrm{d}t$。\n- 容量可用性旨在反映在有资源可用的时期内，输送的能量与可输送能量的接近程度，并且它应该对没有资源的时期不敏感。\n- 只有 $P_{\\text{meas}}(t)$ 是直接观测值，并且已知铭牌容量 $P_{\\text{nom}}$（单位为兆瓦）。没有状态或风力测量数据。为了仅从 $P_{\\text{meas}}(t)$ 估计 $P_{\\text{available}}(t)$，使用一种局部上包络方法，该方法通过对称滑动窗口中测量值的高分位数来近似瞬时可输送能力，并以铭牌容量为上限。\n\n为每个测试用例精确实现以下定义和计算：\n1. 对于每个采样时间 $t_i$，定义索引集 $\\mathcal{W}_i = \\{j: |t_j - t_i| \\leq W/2\\}$，其中 $W$（单位为秒）是窗口宽度。通过以下公式估计可用功率：\n$$\n\\widehat{P}_{\\text{available}}(t_i) = \\min\\!\\left(P_{\\text{nom}},\\ \\operatorname{Quantile}_q\\!\\left(\\{P_{\\text{meas}}(t_j)\\}_{j \\in \\mathcal{W}_i}\\right)\\right),\n$$\n其中 $\\operatorname{Quantile}_q$ 表示使用标准线性插值定义（与常见数值库一致）在窗口化样本的多重集上计算的 $q$-分位数。\n2. 为强制在测量噪声和偏差下的物理一致性，将时间 $t_i$ 的输送贡献定义为 $\\min\\!\\left(P_{\\text{meas}}(t_i), \\widehat{P}_{\\text{available}}(t_i)\\right)$。\n3. 计算时间范围内的资源加权容量可用性：\n$$\nA_{\\text{cap}} = \n\\begin{cases}\n1.0,  \\text{if } \\sum_i \\widehat{P}_{\\text{available}}(t_i)\\,\\Delta t = 0, \\\\\n\\dfrac{\\sum_i \\min\\!\\left(P_{\\text{meas}}(t_i), \\widehat{P}_{\\text{available}}(t_i)\\right)\\,\\Delta t}{\\sum_i \\widehat{P}_{\\text{available}}(t_i)\\,\\Delta t},  \\text{otherwise}.\n\\end{cases}\n$$\n这将产生一个在 $[0,1]$ 范围内的无单位十进制数。\n\n您的任务是实现一个程序，针对以下测试套件，确定性地生成规定的时间序列，通过滑动窗口分位数计算 $\\widehat{P}_{\\text{available}}(t)$，并为每个用例输出 $A_{\\text{cap}}$。时间单位必须是秒，功率单位必须是兆瓦，最终答案必须表示为十进制数（无百分号），每个数值四舍五入到 $6$ 位小数。\n\n测试套件定义（所有三角函数的参数均为弧度）：\n\n- 用例 1（具有短期部分限电的一般行为）：\n  - $\\Delta t = 60$ s，总时间范围 $T = 86400$ s，$P_{\\text{nom}} = 10.0$ MW，窗口 $W = 3600$ s，分位数 $q = 0.98$。\n  - 时间网格 $t_k = k\\,\\Delta t$，对于 $k = 0,1,\\dots,N-1$，其中 $N = T/\\Delta t$。\n  - 资源分数\n    $$\n    r_1(t) = \\operatorname{clip}\\!\\left(0 \\le \\cdot \\le 1;\\ 0.6 + 0.3\\sin\\!\\left(\\frac{2\\pi t}{T}\\right) + 0.1\\sin\\!\\left(\\frac{4\\pi t}{T}\\right)\\right).\n    $$\n  - 限电因子 $c_1(t)$ 等于 $1.0$，但在 $t \\in [28800,30600)$ 时 $c_1(t)=0.6$，在 $t \\in [64800,66600)$ 时 $c_1(t)=0.7$。\n  - 确定性测量噪声 $n_1(t) = 0.05 \\sin\\!\\left(\\frac{2\\pi \\cdot 7\\, t}{T}\\right)$ MW。\n  - 测量功率\n    $$\n    P_{\\text{meas},1}(t) = \\max\\!\\left(0,\\ P_{\\text{nom}}\\, r_1(t)\\, c_1(t) + n_1(t)\\right).\n    $$\n\n- 用例 2（零资源边界情况）：\n  - $\\Delta t = 300$ s，总时间范围 $T = 7200$ s，$P_{\\text{nom}} = 5.0$ MW，窗口 $W = 900$ s，分位数 $q = 0.95$。\n  - 时间网格如上，其中 $N = T/\\Delta t$。\n  - 对于所有 $t$，$r_2(t) = 0$；对于所有 $t$，$c_2(t) = 1$；$n_2(t) = 0$ MW。\n  - 对于所有 $t$，$P_{\\text{meas},2}(t) = 0$ MW。\n\n- 用例 3（资源间歇性且伴有长期完全和部分停运）：\n  - $\\Delta t = 30$ s，总时间范围 $T = 3600$ s，$P_{\\text{nom}} = 3.0$ MW，窗口 $W = 300$ s，分位数 $q = 0.90$。\n  - 时间网格如上，其中 $N = T/\\Delta t$。\n  - 资源分数\n    $$\n    r_3(t) = \\operatorname{clip}\\!\\left(0 \\le \\cdot \\le 1;\\ 0.2 + 0.7 \\sin^2\\!\\left(\\frac{\\pi t}{900}\\right)\\right).\n    $$\n  - 限电因子 $c_3(t)$ 在 $t \\in [600,1200)$ 时等于 $0$，在 $t \\in [1800,2400)$ 时等于 $0.5$，其他情况下等于 $1$。\n  - 确定性测量噪声 $n_3(t) = 0.03 \\sin\\!\\left(\\frac{2\\pi \\cdot 13\\, t}{T}\\right)$ MW。\n  - 测量功率\n    $$\n    P_{\\text{meas},3}(t) = \\max\\!\\left(0,\\ P_{\\text{nom}}\\, r_3(t)\\, c_3(t) + n_3(t)\\right).\n    $$\n\n- 用例 4（传感器偏差和偶尔的表观过功率）：\n  - $\\Delta t = 60$ s，总时间范围 $T = 21600$ s，$P_{\\text{nom}} = 8.0$ MW，窗口 $W = 1800$ s，分位数 $q = 0.97$。\n  - 时间网格如上，其中 $N = T/\\Delta t$。\n  - 资源分数\n    $$\n    r_4(t) = \\operatorname{clip}\\!\\left(0 \\le \\cdot \\le 1;\\ 0.5 + 0.4 \\sin\\!\\left(\\frac{2\\pi t}{T}\\right) + 0.1 \\sin\\!\\left(\\frac{6\\pi t}{T}\\right)\\right).\n    $$\n  - 偏差因子 $b = 1.02$，确定性测量噪声 $n_4(t) = 0.1 \\sin\\!\\left(\\frac{2\\pi \\cdot 5\\, t}{T}\\right)$ MW。\n  - 测量功率\n    $$\n    P_{\\text{meas},4}(t) = \\max\\!\\left(0,\\ b\\, P_{\\text{nom}}\\, r_4(t) + n_4(t)\\right).\n    $$\n\n程序要求：\n- 完全按照上述规定实现 $\\widehat{P}_{\\text{available}}(t)$ 的滑动窗口分位数估计器，在连续时间上使用对称窗口，并以 $P_{\\text{nom}}$ 为上限。\n- 对于每个用例，使用明确包含 $\\Delta t$ 的离散求和来计算 $A_{\\text{cap}}$，并应用上述的零分母约定。\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表。每个条目必须四舍五入到 $6$ 位小数，表示为十进制数，无百分号，例如 $[0.983421,0.750000,1.000000,0.942100]$。",
            "solution": "该问题要求仅使用发电厂测量功率输出的时间序列 $P_{\\text{meas}}(t)$，计算资源加权容量可用性指标 $A_{\\text{cap}}$。该方法基于首先估计瞬时可用功率 $\\widehat{P}_{\\text{available}}(t)$，然后将输送的能量与估计的可用能量进行比较。整个过程是确定性的，并将应用于四个不同的测试用例。\n\n方法步骤如下：\n\n首先，我们处理问题的离散化。持续时间为 $T$ 的总时间范围被离散化为 $N$ 个大小为 $\\Delta t$ 的时间步，使得 $N = T/\\Delta t$。离散时间点为 $t_i = i \\cdot \\Delta t$，其中 $i = 0, 1, \\dots, N-1$。对于每个测试用例，通过在这些离散时间点上对给定的资源分数 $r(t)$、限电因子 $c(t)$ 和测量噪声 $n(t)$ 的确定性函数进行采样，生成测量功率的时间序列 $P_{\\text{meas}}(t_i)$。每个用例都给出了 $P_{\\text{meas}}(t)$ 的公式，我们据此构建一个长度为 $N$ 的向量 $P_{\\text{meas}}$。\n\n其次，我们估计可用功率时间序列 $\\widehat{P}_{\\text{available}}(t_i)$。这是最关键的步骤，作为发电厂在没有内部停运或外部限电指令的情况下本可以产生的功率的代理。该方法是一种使用滑动窗口分位数的上包络技术。对于每个时间点 $t_i$，我们定义一个宽度为 $W$ 的对称窗口。包含在以 $i$ 为中心的窗口中的索引集 $j$ 由条件 $|t_j - t_i| \\le W/2$ 定义。代入 $t_k = k \\Delta t$，这变为 $|j\\Delta t - i\\Delta t| \\le W/2$，可简化为 $|j-i| \\le W/(2\\Delta t)$。由于索引 $i$ 和 $j$ 必须是整数，这意味着窗口中的相对索引集 $k = j-i$ 由 $k \\in \\{-\\lfloor W/(2\\Delta t) \\rfloor, \\dots, \\lfloor W/(2\\Delta t) \\rfloor\\}$ 给出。设 $k_{max} = \\lfloor W/(2\\Delta t) \\rfloor$。因此，对于每个 $i$，索引窗口为 $j \\in [\\max(0, i-k_{max}), \\min(N-1, i+k_{max})]$。该窗口在时间序列的边界处被截断。对于每个这样的窗口，我们收集相应的 $P_{\\text{meas}}(t_j)$ 值并按规定使用线性插值方法计算第 $q$ 个分位数。此分位数作为可用功率的初始估计。为确保物理真实性，此估计以电厂的铭牌容量 $P_{\\text{nom}}$ 为上限。因此，最终估计值为：\n$$\n\\widehat{P}_{\\text{available}}(t_i) = \\min\\!\\left(P_{\\text{nom}},\\ \\operatorname{Quantile}_q\\!\\left(\\{P_{\\text{meas}}(t_j)\\}_{j \\in \\mathcal{W}_i}\\right)\\right)\n$$\n对所有 $i=0, \\dots, N-1$ 迭代此计算，以生成完整的 $\\widehat{P}_{\\text{available}}$ 时间序列。\n\n第三，我们计算最终的可用性指标 $A_{\\text{cap}}$。为确保一致性，特别是在测量噪声或偏差可能导致 $P_{\\text{meas}}(t_i)$ 暂时超过 $\\widehat{P}_{\\text{available}}(t_i)$ 的情况下，每个时间步的“输送”功率贡献定义为 $P_{\\text{deliv}}(t_i) = \\min\\!\\left(P_{\\text{meas}}(t_i), \\widehat{P}_{\\text{available}}(t_i)\\right)$。然后，我们通过对这些功率贡献求和并乘以时间步长 $\\Delta t$ 来计算时间范围内的总输送能量 $E_{\\text{deliv}}$ 和总可用能量 $E_{\\text{avail}}$，这近似于功率对时间的积分：\n$$\nE_{\\text{deliv}} = \\Delta t \\sum_{i=0}^{N-1} P_{\\text{deliv}}(t_i) = \\Delta t \\sum_{i=0}^{N-1} \\min\\!\\left(P_{\\text{meas}}(t_i), \\widehat{P}_{\\text{available}}(t_i)\\right)\n$$\n$$\nE_{\\text{avail}} = \\Delta t \\sum_{i=0}^{N-1} \\widehat{P}_{\\text{available}}(t_i)\n$$\n资源加权容量可用性 $A_{\\text{cap}}$ 是这两个能量的比值。问题为总可用能量为零的情况（如果资源在整个期间都不可用）指定了一个约定。公式为：\n$$\nA_{\\text{cap}} = \n\\begin{cases}\n1.0,  \\text{if } E_{\\text{avail}} = 0 \\\\\n\\dfrac{E_{\\text{deliv}}}{E_{\\text{avail}}},  \\text{otherwise}\n\\end{cases}\n$$\n请注意，因子 $\\Delta t$ 同时出现在分子和分母中，因此可以消去，但包含它对于维持功率样本之和与总能量之间的概念联系至关重要。将此过程应用于四个测试用例中的每一个，并将所得的 $A_{\\text{cap}}$ 值四舍五入到 $6$ 位小数。",
            "answer": "```python\nimport numpy as np\n\ndef calculate_availability(params):\n    \"\"\"\n    Calculates the resource-weighted capacity availability for a single test case.\n    \n    Args:\n        params (dict): A dictionary containing all parameters for the test case.\n\n    Returns:\n        float: The calculated availability, A_cap.\n    \"\"\"\n    # Unpack parameters\n    dt = params[\"dt\"]\n    T = params[\"T\"]\n    P_nom = params[\"P_nom\"]\n    W = params[\"W\"]\n    q = params[\"q\"]\n    \n    # Generate time grid\n    N = int(T / dt)\n    t = np.arange(N) * dt\n    \n    # Generate P_meas time series based on case-specific functions\n    if params[\"case_id\"] == 1:\n        r = 0.6 + 0.3 * np.sin(2 * np.pi * t / T) + 0.1 * np.sin(4 * np.pi * t / T)\n        r = np.clip(r, 0, 1)\n        c = np.ones(N, dtype=float)\n        c[(t >= 28800)  (t  30600)] = 0.6\n        c[(t >= 64800)  (t  66600)] = 0.7\n        n = 0.05 * np.sin(2 * np.pi * 7 * t / T)\n        P_meas = np.maximum(0, P_nom * r * c + n)\n    elif params[\"case_id\"] == 2:\n        P_meas = np.zeros(N, dtype=float)\n    elif params[\"case_id\"] == 3:\n        r = 0.2 + 0.7 * np.sin(np.pi * t / 900)**2\n        r = np.clip(r, 0, 1)\n        c = np.ones(N, dtype=float)\n        c[(t >= 600)  (t  1200)] = 0.0\n        c[(t >= 1800)  (t  2400)] = 0.5\n        n = 0.03 * np.sin(2 * np.pi * 13 * t / T)\n        P_meas = np.maximum(0, P_nom * r * c + n)\n    elif params[\"case_id\"] == 4:\n        r = 0.5 + 0.4 * np.sin(2 * np.pi * t / T) + 0.1 * np.sin(6 * np.pi * t / T)\n        r = np.clip(r, 0, 1)\n        b = 1.02\n        n = 0.1 * np.sin(2 * np.pi * 5 * t / T)\n        P_meas = np.maximum(0, b * P_nom * r + n)\n    else:\n        raise ValueError(\"Invalid case ID\")\n\n    # Estimate P_available using a sliding-window quantile\n    P_available = np.zeros(N, dtype=float)\n    half_win_indices = int(np.floor(W / (2 * dt)))\n    \n    for i in range(N):\n        start_idx = max(0, i - half_win_indices)\n        end_idx = min(N, i + half_win_indices + 1)\n        window_data = P_meas[start_idx:end_idx]\n        \n        # Use 'linear' interpolation method for quantile as specified\n        quantile_val = np.quantile(window_data, q, method='linear')\n        P_available[i] = min(P_nom, quantile_val)\n\n    # Calculate delivered contribution\n    delivered_contrib = np.minimum(P_meas, P_available)\n\n    # Calculate total available and delivered energies\n    total_available_energy = np.sum(P_available) * dt\n    total_delivered_energy = np.sum(delivered_contrib) * dt\n\n    # Compute resource-weighted capacity availability\n    if total_available_energy == 0:\n        A_cap = 1.0\n    else:\n        A_cap = total_delivered_energy / total_available_energy\n        \n    return A_cap\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        # Case 1\n        {\"case_id\": 1, \"dt\": 60, \"T\": 86400, \"P_nom\": 10.0, \"W\": 3600, \"q\": 0.98},\n        # Case 2\n        {\"case_id\": 2, \"dt\": 300, \"T\": 7200, \"P_nom\": 5.0, \"W\": 900, \"q\": 0.95},\n        # Case 3\n        {\"case_id\": 3, \"dt\": 30, \"T\": 3600, \"P_nom\": 3.0, \"W\": 300, \"q\": 0.90},\n        # Case 4\n        {\"case_id\": 4, \"dt\": 60, \"T\": 21600, \"P_nom\": 8.0, \"W\": 1800, \"q\": 0.97},\n    ]\n\n    results = []\n    for case_params in test_cases:\n        result = calculate_availability(case_params)\n        results.append(result)\n\n    # Format the output string as per requirements\n    result_str = \",\".join([f\"{r:.6f}\" for r in results])\n    print(f\"[{result_str}]\")\n\nsolve()\n```"
        }
    ]
}