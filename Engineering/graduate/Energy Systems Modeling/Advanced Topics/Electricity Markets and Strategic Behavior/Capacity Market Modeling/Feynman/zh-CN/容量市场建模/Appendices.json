{
    "hands_on_practices": [
        {
            "introduction": "容量市场的核心目标是确保电力系统的可靠性。本实践练习将带您从最基本的概率论原理出发，为一个简化但具有代表性的三发电机系统计算其可靠性。您将通过两种关键方法——精确的解析法（状态枚举法）和行业标准的数值法（蒙特卡洛模拟）——来计算“损失负荷概率”（Loss of Load Probability, LOLP），这是衡量发电充裕度的基石性指标。通过这个练习，您将深刻理解可靠性指标的数学基础，并掌握验证复杂模型结果的核心技能。",
            "id": "4074779",
            "problem": "考虑一个包含 $3$ 个发电机组的系统的容量市场可靠性评估。假设机组 $i$ 的铭牌容量为 $c_i$（单位为兆瓦，MW），在给定小时内的独立强迫停运概率为 $p_i$。定义一个伯努利随机变量 $X_i$，如果机组 $i$ 在线（可用），则其值为 $1$；如果机组 $i$ 在该小时内发生强迫停运，则其值为 $0$。假设各机组之间相互独立。该小时内的可用容量为随机总和 $S = \\sum_{i=1}^{3} c_i X_i$。对于给定的小时负荷 $L$，负荷损失概率 (LOLP) 定义为可用容量严格小于负荷的概率，即 $P(S  L)$。在容量市场建模中，小时 LOLP 是一项基础的可靠性指标，用于为规划备用容量要求提供信息。\n\n仅从独立伯努利随机变量的概率核心定义和全概率定律出发（不使用专门的简化公式），通过枚举所有可用性状态来精确计算小时 $P(S  L)$，并通过独立抽样机组停运的蒙特卡洛模拟来验证结果。将强迫停运概率 $p_i$ 视为 $X_i = 0$ 的概率，因此 $P(X_i = 1) = 1 - p_i$ 且 $P(X_i = 0) = p_i$。对于蒙特卡洛验证，每个测试用例使用至少 $200,000$ 次独立的小时实现，并使用固定的随机种子 $42$ 以确保可复现性。所有概率均以小数形式表示（不使用百分号），所有负荷和容量均以兆瓦（MW）为单位。\n\n测试套件：\n- 案例 A（一般情况）：$c = [500, 300, 200]$ MW, $p = [0.05, 0.10, 0.20]$, $L = 700$ MW。\n- 案例 B（边界低负荷）：$c = [500, 300, 200]$ MW, $p = [0.05, 0.10, 0.20]$, $L = 0$ MW。\n- 案例 C（边界负荷高于总容量）：$c = [500, 300, 200]$ MW, $p = [0.05, 0.10, 0.20]$, $L = 1100$ MW。\n- 案例 D（边缘可靠性组合）：$c = [400, 350, 250]$ MW, $p = [0.00, 0.10, 0.80]$, $L = 850$ MW。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。每个条目对应一个测试用例，其本身是一个双元素列表 $[ \\text{analytical\\_LOLP}, \\text{monte\\_carlo\\_LOLP} ]$，每个值都格式化为小数。例如，两个测试用例的输出将类似于 $[[a_1, b_1],[a_2, b_2]]$，其中 $a_k$ 是精确枚举的概率，$b_k$ 是测试用例 $k$ 的蒙特卡洛估计值。",
            "solution": "用户提供了一个具有科学依据、定义明确且客观的问题。它基于概率论的基本原理，并应用于电力系统可靠性工程中的一个经典问题，即负荷损失概率 (LOLP) 的计算。该问题提供了所有必要的数据和定义，没有矛盾之处，并要求使用两种不同的方法（解析状态枚举和数值蒙特卡洛模拟）进行标准的、可验证的计算。数据值在物理上是现实的。因此，该问题是有效的，并将提供一个解决方案。\n\n该问题要求计算一个拥有 $3$ 个独立发电机组的电力系统的负荷损失概率 (LOLP)。设机组集合由 $i \\in \\{1, 2, 3\\}$ 索引。对于每个机组 $i$，我们给定其铭牌容量 $c_i$（单位为兆瓦，MW）和强迫停运概率 $p_i$。\n\n每个机组 $i$ 的运行状态由一个伯努利随机变量 $X_i$ 建模，其中：\n-   $X_i = 1$ 表示机组可用（在线），其发生概率为 $P(X_i=1) = 1 - p_i$。\n-   $X_i = 0$ 表示机组处于强迫停运状态（离线），其发生概率为 $P(X_i=0) = p_i$。\n\n假设各机组在统计上是独立的。系统在任何给定时刻的总可用容量是随机变量 $S$，定义为可用机组的容量之和：\n$$S = \\sum_{i=1}^{3} c_i X_i$$\n\nLOLP 定义为总可用容量 $S$ 严格小于系统负荷 $L$ 的概率。\n$$LOLP = P(S  L)$$\n\n我们将使用两种方法计算这个值：通过状态枚举进行精确计算和通过蒙特卡洛模拟进行估计。\n\n### 1. 通过状态枚举进行解析计算\n\n此方法依赖于全概率定律。所有可能的机组可用性组合构成了样本空间的一个划分。由于有 $3$ 个机组，每个机组可以处于 $2$ 种状态之一（在线或离线），因此共有 $2^3 = 8$ 个互斥的系统状态。\n\n一个系统状态可以用一个二进制向量 $\\mathbf{x} = (x_1, x_2, x_3)$ 表示，其中 $x_i \\in \\{0, 1\\}$ 是随机变量 $X_i$ 的一个具体实现。由于各机组的独立性，系统处于特定状态 $\\mathbf{x}$ 的概率是各个机组状态概率的乘积：\n$$P(\\mathbf{X}=\\mathbf{x}) = P(X_1=x_1, X_2=x_2, X_3=x_3) = \\prod_{i=1}^{3} P(X_i=x_i)$$\n其中 $P(X_i=1) = 1-p_i$ 且 $P(X_i=0) = p_i$。\n\n对于每个状态 $\\mathbf{x}$，总可用容量是一个确定性值：\n$$S_{\\mathbf{x}} = \\sum_{i=1}^{3} c_i x_i$$\n\n如果在状态 $\\mathbf{x}$ 下 $S_{\\mathbf{x}}  L$，则发生负荷损失事件。总 LOLP 是所有满足此条件的状态的概率之和：\n$$LOLP = \\sum_{\\mathbf{x} \\in \\{0,1\\}^3 \\text{ s.t. } S_{\\mathbf{x}}  L} P(\\mathbf{X}=\\mathbf{x})$$\n\n算法如下：\n1.  遍历从 $(0,0,0)$ 到 $(1,1,1)$ 的所有 $8$ 种可能状态 $\\mathbf{x} = (x_1, x_2, x_3)$。\n2.  对每个状态，计算其概率 $P(\\mathbf{x}) = \\prod_{i=1}^3 (p_i)^{1-x_i} (1-p_i)^{x_i}$。\n3.  对每个状态，计算相应的可用容量 $S_{\\mathbf{x}} = c_1 x_1 + c_2 x_2 + c_3 x_3$。\n4.  如果 $S_{\\mathbf{x}}  L$，则将 $P(\\mathbf{x})$ 加到总 LOLP 的累加和中。\n5.  最终的和即为精确的解析 LOLP。\n\n### 2. 蒙特卡洛模拟\n\n此方法使用随机抽样来估计概率。根据大数定律，在大量独立试验中事件发生的频率近似于其真实概率。\n\n算法如下：\n1.  初始化负荷损失事件计数器 $N_{LOL}$ 为 $0$。\n2.  指定模拟总次数 $K$。问题要求 $K \\ge 200,000$。我们将使用 $K = 200,000$。\n3.  将随机数生成器种子设置为 $42$ 以确保可复现性。\n4.  对于 $j=1, \\dots, K$ 重复以下步骤：\n    a.  对每个机组 $i=1, 2, 3$，模拟其状态。从 $[0, 1)$ 上的均匀分布中生成一个随机数 $u_i$。如果 $u_i  p_i$，则机组停运 ($x_i^{(j)} = 0$)；否则，机组可用 ($x_i^{(j)} = 1$）。\n    b.  计算本次模拟（实现）的总可用容量：$S^{(j)} = \\sum_{i=1}^{3} c_i x_i^{(j)}$。\n    c.  如果 $S^{(j)}  L$，则计数器加一：$N_{LOL} = N_{LOL} + 1$。\n5.  估计的 LOLP 是导致负荷损失的模拟次数所占的比例：\n$$\\widehat{LOLP} = \\frac{N_{LOL}}{K}$$\n\n两种方法都将应用于问题陈述中指定的每个测试用例。解析方法提供精确的理论概率，而蒙特卡洛方法提供一个数值估计，随着 $K$ 的增加，该估计应收敛于解析结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport itertools\n\ndef solve():\n    \"\"\"\n    Solves the capacity market reliability assessment problem for all test cases.\n    \"\"\"\n    \n    # Test cases defined in the problem statement.\n    # Each case is a tuple: (capacities, outage_probabilities, load)\n    test_cases = [\n        # Case A (general case)\n        ([500, 300, 200], [0.05, 0.10, 0.20], 700),\n        # Case B (boundary low load)\n        ([500, 300, 200], [0.05, 0.10, 0.20], 0),\n        # Case C (boundary load above total capacity)\n        ([500, 300, 200], [0.05, 0.10, 0.20], 1100),\n        # Case D (edge reliability mix)\n        ([400, 350, 250], [0.00, 0.10, 0.80], 850),\n    ]\n\n    # Monte Carlo simulation parameters\n    num_simulations = 200000\n    random_seed = 42\n\n    results = []\n    for c, p, L in test_cases:\n        analytical_lolp = calculate_analytical_lolp(c, p, L)\n        mc_lolp = run_monte_carlo_simulation(c, p, L, num_simulations, random_seed)\n        results.append([analytical_lolp, mc_lolp])\n\n    # Final print statement in the exact required format.\n    # The str() of a list includes spaces, e.g., '[1.0, 2.0]', which matches the\n    # problem's example output format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef calculate_analytical_lolp(capacities, outage_probs, load):\n    \"\"\"\n    Calculates the exact LOLP by enumerating all possible availability states.\n    \n    Args:\n        capacities (list of int): List of generator capacities in MW.\n        outage_probs (list of float): List of generator forced outage probabilities.\n        load (int): System load in MW.\n    \n    Returns:\n        float: The analytically calculated LOLP.\n    \"\"\"\n    num_units = len(capacities)\n    total_lolp = 0.0\n    \n    # Iterate through all 2^n possible states using itertools.product\n    # Each state is a tuple like (1, 1, 0) where 1=online, 0=offline\n    for state_vector in itertools.product([1, 0], repeat=num_units):\n        state_prob = 1.0\n        available_capacity = 0.0\n        \n        for i in range(num_units):\n            if state_vector[i] == 1:  # Unit is online\n                state_prob *= (1 - outage_probs[i])\n                available_capacity += capacities[i]\n            else:  # Unit is offline (on outage)\n                state_prob *= outage_probs[i]\n        \n        # Check for loss of load condition\n        if available_capacity  load:\n            total_lolp += state_prob\n            \n    return total_lolp\n\ndef run_monte_carlo_simulation(capacities, outage_probs, load, num_simulations, seed):\n    \"\"\"\n    Estimates the LOLP using a Monte Carlo simulation.\n    \n    Args:\n        capacities (list of int): List of generator capacities in MW.\n        outage_probs (list of float): List of generator forced outage probabilities.\n        load (int): System load in MW.\n        num_simulations (int): The number of independent trials to run.\n        seed (int): The seed for the random number generator for reproducibility.\n    \n    Returns:\n        float: The Monte Carlo estimated LOLP.\n    \"\"\"\n    num_units = len(capacities)\n    \n    # Use NumPy's recommended random number generation interface\n    rng = np.random.default_rng(seed)\n    \n    # Convert lists to numpy arrays for vectorized operations\n    c_np = np.array(capacities)\n    p_np = np.array(outage_probs)\n\n    # Generate random numbers for all simulations and units at once\n    # Shape: (num_simulations, num_units)\n    random_samples = rng.random(size=(num_simulations, num_units))\n    \n    # Determine unit availability: 1 if online, 0 if offline\n    # A unit is online if its random sample is >= its outage probability.\n    availability_matrix = (random_samples >= p_np).astype(int)\n    \n    # Calculate available capacity for each simulation via matrix multiplication\n    # (num_simulations, num_units) @ (num_units,) -> (num_simulations,)\n    available_capacities = availability_matrix @ c_np\n    \n    # Count the number of simulations where capacity was less than load\n    loss_of_load_count = np.sum(available_capacities  load)\n    \n    # The estimated LOLP is the fraction of loss-of-load events\n    mc_lolp = loss_of_load_count / num_simulations\n    \n    return mc_lolp\n\nif __name__ == \"__main__\":\n    solve()\n\n```"
        },
        {
            "introduction": "在量化了系统的可靠性需求后，下一步是设计一个有效的市场机制来经济地满足这一需求。本实践模拟了一个中央化的容量拍卖过程，其目标是实现社会总福利的最大化。在这个练习中，您将面对真实的挑战：一个向下倾斜的需求曲线和带有最小出力约束的非凸性供应报价，这些都是现代电力市场设计的核心难题。通过解决这个问题，您将掌握如何将经济学原理（福利最大化）与优化算法相结合，以确定市场的出清数量和价格。",
            "id": "4074742",
            "problem": "考虑一个风格化的集中式容量拍卖，该拍卖通过福利最大化规则在向下倾斜的需求曲线和非凸供应报价下进行出清。独立系统运营商（ISO）旨在选择报价和中标量，以最大化净社会福利，其定义为需求曲线在出清数量以下的积分减去中标供应商成本的总和，同时受制于报价的最低接受量约束。需求曲线是线性的且向下倾斜，供应报价可能具有整块的最低接受量，从而引入混合整数决策。\n\n基本原理和定义：设需求价格函数为线性函数，由 $D(Q) = \\alpha - \\beta Q$ 给出，其中 $Q \\ge 0$，$\\alpha  0$ 且 $\\beta  0$。数量 $Q$ 的需求估值为需求曲线下的面积，即 $V(Q) = \\int_{0}^{Q} D(q) \\, dq = \\alpha Q - \\frac{1}{2} \\beta Q^2$。为确保科学真实性（非负支付意愿），出清数量受限于 $Q \\le \\alpha / \\beta$。假设有 $N$ 个报价，此处 $N = 5$。报价 $i \\in \\{1,\\dots,N\\}$ 由可变成本 $c_i$（单位：$/MW-年）、最低接受量 $m_i$（单位：MW）和最大报价量 $q_i$（单位：MW）参数化，其中 $0 \\le m_i \\le q_i$。决策变量是二元中标指示变量 $y_i \\in \\{0,1\\}$ 和中标数量 $x_i$（单位：MW），其中 $x_i \\in [y_i m_i, y_i q_i]$。总出清数量为 $Q = \\sum_{i=1}^{N} x_i$，出清价格为 $p = D(Q)$。福利最大化出清问题是选择 $(y_i, x_i)$ 以最大化 $W(Q, x) = V(Q) - \\sum_{i=1}^{N} c_i x_i$，约束条件为 $Q = \\sum_{i=1}^{N} x_i$，$x_i \\in [y_i m_i, y_i q_i]$，$y_i \\in \\{0,1\\}$，以及 $0 \\le Q \\le \\alpha / \\beta$。\n\n您的任务是：实现一个程序，对于给定的需求参数 $(\\alpha, \\beta)$ 和五个报价 $\\{(c_i, m_i, q_i)\\}_{i=1}^{5}$，计算福利最大化的出清结果。该程序必须通过评估所有报价子集来精确解决由最低接受量约束引起的混合整数非凸性问题，并且对于每个子集，计算最优出清数量 $Q^{\\star}$，该数量最大化 $V(Q) - C_{\\min}(Q)$，其中 $C_{\\min}(Q)$ 是在给定子集和数量下可达到的最低成本，通过将超出子集最低总量之和的增量数量首先分配给最便宜的报价来获得。这将得出 $Q^{\\star}$、出清价格 $p^{\\star} = D(Q^{\\star})$、净福利 $W^{\\star} = V(Q^{\\star}) - \\sum_i c_i x_i^{\\star}$ 以及所有五个报价的中标数量 $x_i^{\\star}$。\n\n单位：数量以兆瓦（MW）表示，价格以美元/兆瓦·年（$/MW-year）表示，福利以美元/年（$/year）表示。程序必须将所有报告的浮点数四舍五入到三位小数。\n\n测试套件：在以下四个参数集上运行程序，每个参数集都恰好有五个报价。\n\n- 测试用例1（正常路径，多个极小值，宽需求支撑）：\n  - 需求：$\\alpha = 300$，$\\beta = 0.8$。\n  - 报价（成本 $c_i$ 单位为 $/MW-年，最低量 $m_i$ 单位为 MW，最大量 $q_i$ 单位为 MW）：\n    - 报价 1：$(c_1, m_1, q_1) = (100, 50, 120)$。\n    - 报价 2：$(c_2, m_2, q_2) = (130, 0, 80)$。\n    - 报价 3：$(c_3, m_3, q_3) = (90, 40, 100)$。\n    - 报价 4：$(c_4, m_4, q_4) = (160, 30, 60)$。\n    - 报价 5：$(c_5, m_5, q_5) = (110, 0, 50)$。\n- 测试用例2（需求截距低于所有边际成本，因此没有中标能提高福利的边界情况）：\n  - 需求：$\\alpha = 85$，$\\beta = 0.5$。\n  - 报价与测试用例1相同。\n- 测试用例3（需求斜率陡峭，需求上限对许多子集有约束，必须检查 $Q \\le \\alpha/\\beta$ 下的可行性）：\n  - 需求：$\\alpha = 250$，$\\beta = 3.0$。\n  - 报价与测试用例1相同。\n- 测试用例4（由于一个成本相对较低的报价有较大的最低接受量而导致的非凸边界最优解）：\n  - 需求：$\\alpha = 150$，$\\beta = 1.0$。\n  - 报价：\n    - 报价 1：$(c_1, m_1, q_1) = (95, 70, 90)$。\n    - 报价 2：$(c_2, m_2, q_2) = (140, 0, 100)$。\n    - 报价 3：$(c_3, m_3, q_3) = (120, 0, 60)$。\n    - 报价 4：$(c_4, m_4, q_4) = (180, 0, 60)$。\n    - 报价 5：$(c_5, m_5, q_5) = (160, 0, 50)$。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，每个测试用例的结果本身是一个包含八个浮点数的列表，四舍五入到三位小数：$[Q^{\\star}, p^{\\star}, W^{\\star}, x_1^{\\star}, x_2^{\\star}, x_3^{\\star}, x_4^{\\star}, x_5^{\\star}]$。因此，整体输出是一个包含四个此类列表的列表，打印时不带空格，例如：[[Q1,p1,W1,x11,x12,x13,x14,x15],[Q2,p2,W2,x21,x22,x23,x24,x25],[Q3,p3,W3,x31,x32,x33,x34,x35],[Q4,p4,W4,x41,x42,x43,x44,x45]]。\n\n角度单位：不适用。\n\n百分比：不适用。\n\n您的解决方案必须是一个完整、可运行的程序。它不能要求任何用户输入。它必须计算所有四个测试用例的结果，并以指定的确切格式打印最后一行。",
            "solution": "我们根据福利最大化公式从第一性原理推导出出清算法。需求价格函数为 $D(Q) = \\alpha - \\beta Q$，其中 $\\alpha  0$ 且 $\\beta  0$。数量 $Q$ 的总估值为 $V(Q) = \\int_0^Q D(q) \\, dq = \\alpha Q - \\frac{1}{2}\\beta Q^2$。我们施加科学上真实的约束 $Q \\le \\alpha/\\beta$，以确保边际支付意愿为非负。每个报价 $i$ 都有一个可变成本 $c_i$（单位为美元/兆瓦·年），一个最低接受量 $m_i$ 和一个最大接受量 $q_i$（单位为兆瓦），其中 $0 \\le m_i \\le q_i$。二元变量 $y_i \\in \\{0,1\\}$ 表示是否中标，连续变量 $x_i$ 表示中标数量，其中 $x_i \\in [y_i m_i, y_i q_i]$。出清数量为 $Q = \\sum_i x_i$，出清价格为 $p = D(Q)$。\n\n福利最大化问题是：\n$$\n\\max_{\\{y_i\\}, \\{x_i\\}, Q} \\quad W(Q, x) = \\alpha Q - \\frac{1}{2} \\beta Q^2 - \\sum_{i=1}^N c_i x_i\n$$\n约束条件为 $Q = \\sum_{i=1}^N x_i$，$x_i \\in [y_i m_i, y_i q_i]$，$y_i \\in \\{0,1\\}$，以及 $0 \\le Q \\le \\alpha/\\beta$。非凸性源于当 $y_i = 1$ 时整块的最低接受量 $m_i$。\n\n基于原则的简化：对于任何固定的中标子集 $S \\subseteq \\{1,\\dots,N\\}$，其中如果 $i \\in S$ 则 $y_i = 1$，否则 $y_i = 0$，我们可以首先通过在中标报价中优化分配数量来计算给定总量 $Q$ 的最低可实现成本。设 $Q_{\\min}(S) = \\sum_{i \\in S} m_i$ 和 $Q_{\\max}(S) = \\sum_{i \\in S} q_i$。可行性要求 $Q_{\\min}(S) \\le Q \\le \\min\\{Q_{\\max}(S), \\alpha/\\beta\\}$。定义由最低接受量产生的基线成本为 $C_0(S) = \\sum_{i \\in S} c_i m_i$。报价 $i$ 超出最低接受量的额外可分配容量为 $\\Delta_i = q_i - m_i$。为在给定 $Q$ 的情况下最小化 $\\sum_i c_i x_i$，我们将增量数量 $y = Q - Q_{\\min}(S)$ 按 $c_i$ 的非递减顺序分配给 $S$ 中的报价，首先填满最便宜的增量容量，直至其 $\\Delta_i$。这是经典的连续背包分配问题，是优化领域中一个经过充分检验的事实：在线性成本和可分离边界下，最小成本分配将边际单位分配给最低边际成本的资源。由此产生的最低成本为\n$$\nC_{\\min}(Q; S) = C_0(S) + \\sum_{k=1}^{K(S)} c_{(k)} \\, y_k,\n$$\n其中 $(k)$ 是按 $c_i$ 递增排序的 $S$ 中报价的索引，$y_k$ 是分配给报价 $(k)$ 的 $y$ 的部分，且 $0 \\le y_k \\le \\Delta_{(k)}$，$\\sum_k y_k = y$。\n\n边际分析：在一个子集 $S$ 内增加 $Q$ 的边际成本 $\\mathrm{MC}(Q; S)$ 是分段常数：它等于 $c_{(1)}$ 直到最便宜的增量容量被耗尽，然后是 $c_{(2)}$，依此类推。边际估值为 $D(Q) = \\alpha - \\beta Q$。福利 $W(Q; S) = V(Q) - C_{\\min}(Q; S)$ 在每个增量段内是可微的，在一个边际成本为 $c_{(k)}$ 的段内，内部最优解的一阶条件是\n$$\n\\frac{dW}{dQ} = D(Q) - \\mathrm{MC}(Q; S) = \\alpha - \\beta Q - c_{(k)} = 0,\n$$\n这得出的候选解为\n$$\nQ^{\\star}_{(k)}(S) = \\frac{\\alpha - c_{(k)}}{\\beta}.\n$$\n此候选解仅当其位于 $S$ 的可行段内时才有效，即在 $Q \\in [Q_{\\min}(S) + \\sum_{jk} \\Delta_{(j)}, Q_{\\min}(S) + \\sum_{j \\le k} \\Delta_{(j)}]$ 范围内。\n\n由于福利函数是分段二次的，因此每个子集 $S$ 的最优出清数量 $Q^{\\star}(S)$ 必须出现在段的边界点上（即 $Q_{\\min}(S)$，以及所有 $Q_{\\min}(S) + \\sum_{j=1}^{k} \\Delta_{(j)}$ 的点）或在段的内部最优解处。这为每个子集 $S$ 的最优解提供了一个有限的候选点集合。\n\n算法：\n1.  对于 $2^N - 1$ 个非空子集中的每一个中标报价子集 $S$：\n    a.  计算子集的 $Q_{\\min}(S)$ 和 $Q_{\\max}(S)$。计算有效的最大数量 $Q_{\\max}^{\\text{eff}}(S) = \\min(Q_{\\max}(S), \\alpha/\\beta)$。如果 $Q_{\\min}(S)  Q_{\\max}^{\\text{eff}}(S)$，则此子集不可行，继续。\n    b.  按成本 $c_i$ 递增的顺序对 $S$ 中的报价进行排序。\n    c.  构建一个候选最优数量 $Q$ 的集合。这个集合包括：\n        i.   $Q_{\\min}(S)$\n        ii.  所有分段边界点 $Q_{\\min}(S) + \\sum_{j=1}^k (q_{(j)}-m_{(j)})$，这些点都小于或等于 $Q_{\\max}^{\\text{eff}}(S)$。\n        iii. $Q_{\\max}^{\\text{eff}}(S)$。\n        iv.  对于每个段 $k$，计算内部候选解 $Q^{\\star}_{(k)}(S) = (\\alpha - c_{(k)})/\\beta$。如果它位于该段的范围内（包括边界）且在 $[Q_{\\min}(S), Q_{\\max}^{\\text{eff}}(S)]$ 内，则将其添加到候选集合中。\n    d.  对于此子集的每个候选数量 $Q_{cand}$：\n        i.   计算 $Q_{cand}$ 的最低成本 $C_{\\min}(Q_{cand}; S)$ 和相应的分配 $\\{x_i\\}$。\n        ii.  计算福利 $W(Q_{cand}; S) = V(Q_{cand}) - C_{\\min}(Q_{cand}; S)$。\n    e.  找到此子集 $S$ 的最佳候选解 $(Q^{\\star}(S), W^{\\star}(S), \\{x_i^{\\star}(S)\\})$。\n2.  将 $Q=0, W=0$ 的空集解与所有 $2^N-1$ 个子集的最佳解进行比较。全局最优解是所有这些解中福利最高的那个。如果出现福利相等的情况，则选择 $Q$ 最大的一个。\n3.  输出全局最优的 $(Q^{\\star}, p^{\\star}, W^{\\star}, \\{x_i^{\\star}\\})$，其中 $p^{\\star} = D(Q^{\\star})$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_welfare_opt(alpha, beta, offers):\n    \"\"\"\n    Compute welfare-maximizing clearing for given alpha, beta and offers.\n    offers: list of 5 tuples (c, m, q)\n    Returns: (Q*, p*, W*, x* list length 5)\n    \"\"\"\n    n = len(offers)\n    assert n == 5, \"Exactly 5 offers required\"\n    # Demand cap to ensure non-negative marginal value\n    q_cap = alpha / beta\n\n    # Pre-extract offer arrays\n    costs = np.array([o[0] for o in offers], dtype=float)\n    mins = np.array([o[1] for o in offers], dtype=float)\n    maxs = np.array([o[2] for o in offers], dtype=float)\n\n    # Helper to compute V(Q)\n    def valuation(Q):\n        return alpha * Q - 0.5 * beta * Q * Q\n\n    # Helper to compute cost-min and allocation for a given subset and Q\n    def cost_min_and_allocation(subset_indices, Q):\n        # baseline minima\n        m = mins[subset_indices]\n        q = maxs[subset_indices]\n        c = costs[subset_indices]\n        Qmin = float(np.sum(m))\n        y = Q - Qmin\n        # If y  0, infeasible\n        if y  -1e-12:\n            return float('inf'), None  # infeasible\n        # Sort by cost ascending, stable by index\n        order = np.argsort(c, kind='stable')\n        c_sorted = c[order]\n        m_sorted = m[order]\n        q_sorted = q[order]\n        add_caps = q_sorted - m_sorted\n        # allocate incremental y greedily\n        inc = np.zeros_like(add_caps)\n        remaining = y\n        for k in range(len(add_caps)):\n            if remaining = 0:\n                break\n            take = min(remaining, add_caps[k])\n            inc[k] = take\n            remaining -= take\n        # Minimal cost: baseline + sum(c * inc)\n        baseline_cost = float(np.dot(c, m))\n        incremental_cost = float(np.dot(c_sorted, inc))\n        total_cost = baseline_cost + incremental_cost\n        # Build full x vector of length n with zero for non-accepted\n        x = np.zeros(n, dtype=float)\n        # Map back allocations to original indices\n        # Start with minima\n        x[subset_indices] = m\n        # Add increments in sorted order mapped to original indices\n        sorted_indices = subset_indices[order]\n        for k, idx in enumerate(sorted_indices):\n            x[idx] += inc[k]\n        return total_cost, x\n\n    best_W = 0.0 # Welfare for Q=0 is 0\n    best_Q = 0.0\n    best_x = np.zeros(n, dtype=float)\n\n    # Enumerate all subsets via bit masks\n    for mask in range(1, 1  n):\n        subset_indices = np.array([i for i in range(n) if (mask >> i)  1], dtype=int)\n        \n        # Compute Qmin and Qmax and effective Qmax\n        Qmin = float(np.sum(mins[subset_indices]))\n        Qmax = float(np.sum(maxs[subset_indices]))\n        Qmax_eff = min(Qmax, q_cap)\n        if Qmin > Qmax_eff + 1e-12:\n            # Infeasible subset due to demand cap\n            continue\n\n        # For building segments, sort offers in subset by cost ascending\n        c_sub = costs[subset_indices]\n        m_sub = mins[subset_indices]\n        q_sub = maxs[subset_indices]\n        order = np.argsort(c_sub, kind='stable')\n        c_sorted = c_sub[order]\n        add_caps = q_sub[order] - m_sub[order]\n        cum_add = np.cumsum(add_caps)\n        # Candidate Q values set\n        candidates = set()\n        # Boundary at Qmin\n        candidates.add(Qmin)\n        # Segment boundaries Qmin + cum_add[k]\n        for k in range(len(cum_add)):\n            q_bound = Qmin + float(cum_add[k])\n            # Clip to Qmax_eff\n            if q_bound = Qmax_eff + 1e-12:\n                candidates.add(q_bound)\n        # Upper feasible bound\n        candidates.add(Qmax_eff)\n        # Interior candidates from equating D(Q)=c_k: Q=(alpha - c_k)/beta\n        for k in range(len(c_sorted)):\n            Qk = (alpha - float(c_sorted[k])) / beta\n            # Feasible check within segment k: [Qmin + cum_add[k-1], Qmin + cum_add[k]]\n            lower = Qmin + (float(cum_add[k-1]) if k > 0 else 0.0)\n            upper = Qmin + float(cum_add[k])\n            if Qk >= lower - 1e-12 and Qk = upper + 1e-12 and Qk = Qmax_eff + 1e-12 and Qk >= Qmin - 1e-12:\n                # Clip to feasible interval to handle numerical wiggle\n                Qk_clipped = min(max(Qk, Qmin), Qmax_eff)\n                candidates.add(Qk_clipped)\n\n        # Evaluate welfare at all candidates\n        for Qcand in candidates:\n            # Compute minimal cost and allocation\n            cost_cand, xcand = cost_min_and_allocation(subset_indices, Qcand)\n            if not np.isfinite(cost_cand):\n                continue\n            Wcand = valuation(Qcand) - cost_cand\n            # Update best if better\n            if Wcand > best_W + 1e-12 or (abs(Wcand - best_W) = 1e-12 and Qcand > best_Q):\n                best_W = Wcand\n                best_Q = Qcand\n                best_x = xcand\n\n    # Compute clearing price\n    p_star = alpha - beta * best_Q\n    # Round results to three decimals\n    def r3(x):\n        return float(np.round(x + 0.0, 3))\n    Qr = r3(best_Q)\n    pr = r3(p_star)\n    Wr = r3(best_W)\n    xr = [r3(x) for x in best_x.tolist()]\n    return Qr, pr, Wr, xr\n\ndef format_no_spaces(list_obj):\n    \"\"\"\n    Recursively format a Python list into a string without any spaces.\n    \"\"\"\n    if isinstance(list_obj, list):\n        return \"[\" + \",\".join(format_no_spaces(item) for item in list_obj) + \"]\"\n    elif isinstance(list_obj, (float, int)):\n        # Format float to avoid unnecessary trailing zeros beyond what round produced\n        if isinstance(list_obj, float) and list_obj == int(list_obj):\n             return str(int(list_obj)) + \".0\"\n        return str(list_obj)\n    else:\n        # Fallback for other types\n        return str(list_obj)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each test case: (alpha, beta, offers_list_of_5 (c,m,q))\n    test_cases = [\n        # Test case 1\n        (\n            300.0, 0.8,\n            [\n                (100.0, 50.0, 120.0),\n                (130.0, 0.0, 80.0),\n                (90.0, 40.0, 100.0),\n                (160.0, 30.0, 60.0),\n                (110.0, 0.0, 50.0),\n            ]\n        ),\n        # Test case 2\n        (\n            85.0, 0.5,\n            [\n                (100.0, 50.0, 120.0),\n                (130.0, 0.0, 80.0),\n                (90.0, 40.0, 100.0),\n                (160.0, 30.0, 60.0),\n                (110.0, 0.0, 50.0),\n            ]\n        ),\n        # Test case 3\n        (\n            250.0, 3.0,\n            [\n                (100.0, 50.0, 120.0),\n                (130.0, 0.0, 80.0),\n                (90.0, 40.0, 100.0),\n                (160.0, 30.0, 60.0),\n                (110.0, 0.0, 50.0),\n            ]\n        ),\n        # Test case 4\n        (\n            150.0, 1.0,\n            [\n                (95.0, 70.0, 90.0),\n                (140.0, 0.0, 100.0),\n                (120.0, 0.0, 60.0),\n                (180.0, 0.0, 60.0),\n                (160.0, 0.0, 50.0),\n            ]\n        ),\n    ]\n\n    results = []\n    for alpha, beta, offers in test_cases:\n        Qr, pr, Wr, xr = compute_welfare_opt(alpha, beta, offers)\n        # Build result list: [Q*, p*, W*, x1*, x2*, x3*, x4*, x5*]\n        result = [Qr, pr, Wr] + xr\n        results.append(result)\n\n    # Final print statement in the exact required format: no spaces in the list.\n    print(format_no_spaces(results))\n\nsolve()\n```"
        },
        {
            "introduction": "真实的电力系统并非一个无约束的“铜板”网络，输电阻塞会严重影响发电资源对系统可靠性的实际贡献。本高级实践将模型从单区域扩展到受输电约束连接的双区域系统，旨在探讨容量资源认证（capacity accreditation）这一前沿问题。通过计算一个位于出口受限区域的新建机组的“认证系数”，您将量化其对全系统可靠性的边际贡献，并理解为何容量的“位置”与其“大小”同等重要。这一练习揭示了在设计公平且有效的容量市场时，如何科学地评估和补偿不同地点资源的可靠性价值。",
            "id": "4074729",
            "problem": "考虑一个用于容量市场建模和可靠性评估的双区域电力系统。该系统由区域 $1$ 和区域 $2$ 组成，通过一个单一的输电接口相连，该接口具有对称的双向传输限额 $L$ 兆瓦 (megawatt)。每个区域都有一组发电机组。每个发电机组 $i$ 的铭牌容量为 $P_i$ 兆瓦，并具有独立的强迫停运率 $q_i$（一个在区间 $[0,1]$ 内的小数）。一个机组要么以其全部铭牌容量可用，概率为 $(1 - q_i)$，要么不可用（容量为零），概率为 $q_i$。在小时 $h$ 内，区域 $1$ 和区域 $2$ 的负荷是确定性值 $D_1(h)$ 和 $D_2(h)$，单位为兆瓦。设小时状态 $h$ 每年发生的期望小时数为 $w_h$，单位为小时/年。负荷损失期望 (LOLE) 定义为每年系统中任何地方出现任何未满足负荷的期望小时数。\n\n从以下基本原则出发：\n- 负荷损失期望 (LOLE) 的定义是出现未满足负荷的期望小时数：对于一个小时状态 $h$，缺电概率是指不存在一个可行的功率传输 $f$ 同时满足两个区域的平衡和接口约束的概率，即 $C_1 + f \\ge D_1(h)$、$C_2 - f \\ge D_2(h)$ 和 $-L \\le f \\le L$，其中 $C_1$ 和 $C_2$ 是小时 $h$ 内区域 $1$ 和区域 $2$ 的随机可用容量。\n- 所有机组和所有小时的机组停运是相互独立的，且区域之间也是独立的。\n- 在给定的 小时状态下，满足负荷的可行性等同于在区间 $[-L, L]$ 内存在一个传输 $f$，使得两个区域都能满足其负荷约束。定义缺额 $S_1 = D_1(h) - C_1$ 和 $S_2 = D_2(h) - C_2$。当且仅当交集 $[S_1, -S_2] \\cap [-L, L]$ 非空时，存在可行的传输。\n\n使用这些原则，推导出一个算法来计算系统级的 LOLE（单位：小时/年），该算法通过精确枚举由独立停运模型所隐含的随机可用容量 $C_1$ 和 $C_2$ 的联合分布，并为每个小时状态和每个 $(C_1, C_2)$ 对检查可行性。\n\n为候选资源定义容量认证系数如下：考虑将一个铭牌容量为 $P_{\\text{add}}$、强迫停运率为 $q_{\\text{add}}$ 的资源添加到区域 $2$（一个出口受限区域），或者为了参考，添加到区域 $1$。设 $\\Delta \\text{LOLE}_2$ 是将资源添加到区域 $2$ 带来的 LOLE 减少量，$\\Delta \\text{LOLE}_1$ 是将相同资源添加到区域 $1$ 带来的 LOLE 减少量。容量认证系数 $\\alpha$ 是比值 $\\alpha = \\Delta \\text{LOLE}_2 / \\Delta \\text{LOLE}_1$，表示为小数（无单位）。该比值捕捉了资源在出口受限区域相对于其在进口关键区域的有效可靠性价值。\n\n你的任务是实现一个程序，该程序：\n- 计算基础系统的 LOLE。\n- 计算将候选资源添加到区域 $2$ 后的 LOLE。\n- 计算将相同候选资源添加到区域 $1$ 后的 LOLE。\n- 计算每个测试用例的容量认证系数 $\\alpha$。\n\n科学真实性要求：程序必须严格使用从接口约束和机组停运模型推导出的可行性条件，不得假设任何简化的或启发式的可靠性公式，并且必须执行与独立停运假设一致的容量分布的精确枚举。\n\n单位和数值规范：\n- 所有容量 $P_i$、负荷 $D_1(h)$ 和 $D_2(h)$ 以及接口限额 $L$ 必须以兆瓦为单位处理。\n- LOLE 必须以小时/年为单位进行计算和内部处理。\n- 最终的容量认证系数 $\\alpha$ 必须表示为小数。\n- 在最终输出中，将报告的容量认证系数四舍五入到三位小数。\n\n测试套件规范。对于每个测试用例，系统由以下部分定义：\n- 区域 $1$ 的机组，以 $(P_i, q_i)$ 对的形式给出。\n- 区域 $2$ 的机组，以 $(P_i, q_i)$ 对的形式给出。\n- 接口限额 $L$，单位为兆瓦。\n- 候选新增资源 $(P_{\\text{add}}, q_{\\text{add}})$。\n- 负荷小时状态 $(D_1(h), D_2(h), w_h)$。\n\n使用以下四个测试用例：\n\n测试用例 1 (中等传输，剩余出口通常可用):\n- 区域 $1$ 机组: $(200, 0.1)$, $(150, 0.1)$。\n- 区域 $2$ 机组: $(200, 0.1)$, $(100, 0.1)$。\n- 接口: $L = 150$。\n- 新增资源: $(100, 0.05)$。\n- 小时状态: $(250, 80, 7800)$, $(350, 80, 800)$, $(380, 90, 160)$。\n\n测试用例 2 (出口完全受限, $L = 0$, 在区域 $2$ 增加容量无法降低系统 LOLE):\n- 区域 $1$ 机组: $(200, 0.1)$, $(150, 0.1)$。\n- 区域 $2$ 机组: $(200, 0.1)$, $(100, 0.1)$。\n- 接口: $L = 0$。\n- 新增资源: $(100, 0.05)$。\n- 小时状态: $(250, 60, 8000)$, $(360, 60, 760)$。\n\n测试用例 3 (边界限制的接口, 若无新增容量，出口有时不足):\n- 区域 $1$ 机组: $(200, 0.1)$, $(150, 0.1)$。\n- 区域 $2$ 机组: $(200, 0.1)$, $(100, 0.1)$。\n- 接口: $L = 100$。\n- 新增资源: $(100, 0.05)$。\n- 小时状态: $(250, 120, 8300)$, $(370, 120, 460)$。\n\n测试用例 4 (出口受限区域具有高本地负荷；新增容量主要服务于本地需求):\n- 区域 $1$ 机组: $(200, 0.1)$, $(150, 0.1)$。\n- 区域 $2$ 机组: $(200, 0.1)$, $(100, 0.1)$。\n- 接口: $L = 150$。\n- 新增资源: $(100, 0.05)$。\n- 小时状态: $(270, 180, 8500)$, $(360, 210, 260)$。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含四个测试用例的容量认证系数 $\\alpha$，格式为用方括号括起来的逗号分隔列表，每个值四舍五入到三位小数（例如，$[0.000,0.532,0.217,0.845]$）。",
            "solution": "问题陈述被评估为有效。它科学地基于电力系统可靠性分析的既定原则，具有一套完整且一致的数据和定义，问题阐述良好，并以客观、正式的语言进行构架。任务是基于一个明确定义的发电不可用性和网络约束的概率模型，计算一个特定的度量，即容量认证系数。\n\n解决方案首先从提供的基本原则中推导出必要的理论部分，然后构建一个算法来计算所需的量。\n\n1.  **区域可用容量建模**\n\n系统由两个区域组成，区域 1 和区域 2。每个区域包含一组发电机组。对于任何给定的机组 $i$，它具有铭牌容量 $P_i$ 和强迫停运率 $q_i$。问题陈述表明，机组以其全部容量 $P_i$ 可用的概率为 $1-q_i$，而不可用（零容量）的概率为 $q_i$。所有机组的停运是相互独立的。\n\n为了确定一个区域（比如区域 1）的总可用容量，用随机变量 $C_1$ 表示，我们必须考虑所有可能的机组停运组合。这将产生一个 $C_1$ 的概率质量函数 (PMF)，通常称为容量停运概率表 (COPT)。设区域 1 中的机组索引从 $j=1$ 到 $N_1$。$C_1$ 的 PMF 可以递归地构建。\n\n设 $p_j(c)$ 是机组 $j$ 的 PMF，即 $p_j(P_j) = 1-q_j$ 和 $p_j(0) = q_j$。前 $k$ 个机组容量之和 $C_{1}^{(k)} = \\sum_{j=1}^{k} C_{1,j}$ 的 PMF 是通过 $C_{1}^{(k-1)}$ 的 PMF 和机组 $k$ 的 PMF 的卷积得到的。\n\n在算法上，我们可以如下构建 COPT，它是一组 $(C, \\text{Pr}(C))$ 对：\n- 从一个初始状态开始：容量为零，概率为 $1.0$：$\\{(0, 1.0)\\}$。\n- 对于区域中的每个机组 $(P_i, q_i)$：\n  - 创建一个新的、空的 COPT。\n  - 对于当前 COPT 中的每个现有容量状态 $(C_{\\text{old}}, \\text{Pr}_{\\text{old}})$：\n    - 新机组不可用（概率为 $q_i$）导致一个状态 $(C_{\\text{old}}, \\text{Pr}_{\\text{old}} \\cdot q_i)$。\n    - 新机组可用（概率为 $1-q_i$）导致一个状态 $(C_{\\text{old}} + P_i, \\text{Pr}_{\\text{old}} \\cdot (1-q_i))$。\n    - 将这些新概率加到新 COPT 中相应的容量水平上，对相同容量值的概率求和。\n- 用新的 COPT 替换旧的。\n对区域中的所有机组重复此过程。设区域 1 和区域 2 最终的 COPT 分别为 $\\text{COPT}_1 = \\{(C_{1,j}, \\text{Pr}(C_{1,j}))\\}$ 和 $\\text{COPT}_2 = \\{(C_{2,k}, \\text{Pr}(C_{2,k}))\\}$。\n\n2.  **双区域可行性与负荷损失**\n\n对于给定的 小时状态 $h$，负荷是确定性值 $D_1(h)$ 和 $D_2(h)$。可用容量 $C_1$ 和 $C_2$ 是随机变量。系统状态的一个特定实现由一对 $(C_1, C_2)$ 给出。由于两个区域的停运是独立的，此状态的联合概率为 $\\text{Pr}(C_1, C_2) = \\text{Pr}(C_1) \\cdot \\text{Pr}(C_2)$。\n\n当无法满足两个区域的需求时，就会发生负荷损失（缺电）事件。根据问题的原则，当不存在一个可行的功率传输 $f$（从区域 2 到区域 1）满足以下约束时，就会发生这种情况：\n$$C_1 + f \\ge D_1(h)$$\n$$C_2 - f \\ge D_2(h)$$\n$$-L \\le f \\le L$$\n这些不等式为所需的传输 $f$ 定义了一个区间：$f \\in [D_1(h) - C_1, C_2 - D_2(h)]$。我们将缺额定义为 $S_1 = D_1(h) - C_1$ 和 $S_2 = D_2(h) - C_2$，因此区间为 $[S_1, -S_2]$。可行的传输还必须位于由传输限额定义的区间 $[-L, L]$ 内。\n\n当且仅当这两个区间 $[S_1, -S_2] \\cap [-L, L]$ 的交集非空时，存在可行的传输。如果此交集为空，则发生缺电。两个闭区间 $[a, b]$ 和 $[c, d]$ 的交集为空的充要条件是 $b  c$ 或 $d  a$。在我们的情况下，这意味着 $-S_2  S_1$（即 $C_1+C_2  D_1(h)+D_2(h)$，全系统容量不足），或者由于其他原因区间不重叠。一个更直接的非空交集条件是 $\\max(a, c) \\le \\min(b, d)$。\n\n因此，**无缺电**的条件是：\n$$\\max(S_1, -L) \\le \\min(-S_2, L)$$\n代入 $S_1$ 和 $S_2$ 的定义：\n$$\\max(D_1(h) - C_1, -L) \\le \\min(C_2 - D_2(h), L)$$\n如果违反此条件，则发生**负荷损失事件**：\n$$\\max(D_1(h) - C_1, -L)  \\min(C_2 - D_2(h), L)$$\n\n3.  **负荷损失期望 (LOLE) 计算**\n\nLOLE 是每年发生缺电的期望小时数。对于单个小时状态 $h$，缺电概率 $\\text{LOLP}_h$ 是所有导致缺电的联合容量状态 $(C_1, C_2)$ 的概率之和：\n$$\\text{LOLP}_h = \\sum_{(C_1, C_2) \\text{ causing shortage}} \\text{Pr}(C_1) \\cdot \\text{Pr}(C_2)$$\n总的系统 LOLE 是这些概率在所有小时状态上的加权和，其中权重 $w_h$ 是每个小时状态的持续时间：\n$$\\text{LOLE} = \\sum_{h} w_h \\cdot \\text{LOLP}_h$$\n\n计算 LOLE 的总体算法如下：\n- 对于给定的系统配置（每个区域的机组，接口限额 $L$）：\n  - 计算 $\\text{COPT}_1$ 和 $\\text{COPT}_2$。\n  - 初始化总 $\\text{LOLE} = 0$。\n  - 对于每个小时状态 $(D_1(h), D_2(h), w_h)$：\n    - 初始化小时状态缺电概率 $\\text{LOLP}_h = 0$。\n    - 对于 $\\text{COPT}_1$ 中的每个容量状态 $(C_1, \\text{Pr}(C_1))$：\n      - 对于 $\\text{COPT}_2$ 中的每个容量状态 $(C_2, \\text{Pr}(C_2))$：\n        - 如果 $\\max(D_1(h) - C_1, -L)  \\min(C_2 - D_2(h), L)$：\n          - $\\text{LOLP}_h = \\text{LOLP}_h + \\text{Pr}(C_1) \\cdot \\text{Pr}(C_2)$。\n    - 将 $w_h \\cdot \\text{LOLP}_h$ 加到总 $\\text{LOLE}$ 中。\n- 返回总 $\\text{LOLE}$。\n\n4.  **容量认证系数 ($\\alpha$) 计算**\n\n容量认证系数 $\\alpha$ 量化了在出口受限的区域 2 中增加新资源相对于在进口关键的区域 1 中增加该资源的可靠性价值。对于每个测试用例，我们必须计算三个 LOLE 值：\n- $\\text{LOLE}_{\\text{base}}$：初始定义的系统的 LOLE。\n- $\\text{LOLE}_{\\text{Z1-add}}$：将候选资源 $(P_{\\text{add}}, q_{\\text{add}})$ 添加到区域 1 后的 LOLE。\n- $\\text{LOLE}_{\\text{Z2-add}}$：将候选资源 $(P_{\\text{add}}, q_{\\text{add}})$ 添加到区域 2 后的 LOLE。\n\n相应的 LOLE 减少量为：\n$$\\Delta\\text{LOLE}_1 = \\text{LOLE}_{\\text{base}} - \\text{LOLE}_{\\text{Z1-add}}$$\n$$\\Delta\\text{LOLE}_2 = \\text{LOLE}_{\\text{base}} - \\text{LOLE}_{\\text{Z2-add}}$$\n\n容量认证系数 $\\alpha$ 是这些减少量的比值：\n$$\\alpha = \\frac{\\Delta\\text{LOLE}_2}{\\Delta\\text{LOLE}_1}$$\n$\\alpha=1$ 的值意味着资源在任一区域都同样有效，就像在没有传输约束的系统中一样。$\\alpha  1$ 的值表明，将其放置在出口受限区域会削弱其有效性，因为其剩余容量可能会被“困住”而无法服务于另一个区域的负荷。如果 $\\Delta\\text{LOLE}_1 = 0$，则只有在 $\\Delta\\text{LOLE}_2 = 0$ 的情况下，该比率才有明确定义，此时 $\\alpha=0$。在问题的背景下，如果 $\\text{LOLE}_{\\text{base}}  0$，向进口关键的区域 1 增加容量预计将产生非零的 LOLE 减少量。每个测试用例的最终结果是这个值 $\\alpha$，四舍五入到三位小数。",
            "answer": "```python\nimport numpy as np\nfrom collections import defaultdict\n\ndef get_copt(units):\n    \"\"\"\n    Computes the Capacity Outage Probability Table (COPT) for a set of generating units.\n    A unit is defined by a tuple (capacity, forced_outage_rate).\n\n    Args:\n        units (list of tuples): A list of (P_i, q_i) for each unit in the zone.\n\n    Returns:\n        dict: A dictionary mapping capacity levels to their probabilities.\n    \"\"\"\n    # Initialize COPT with a single state: 0 capacity with probability 1.0\n    copt = {0.0: 1.0}\n    for p_i, q_i in units:\n        next_copt = defaultdict(float)\n        for capacity, prob in copt.items():\n            # Case 1: The current unit is unavailable (outage)\n            # Capacity remains the same, probability is prob * q_i\n            next_copt[capacity] += prob * q_i\n            \n            # Case 2: The current unit is available\n            # Capacity increases by p_i, probability is prob * (1 - q_i)\n            next_copt[capacity + p_i] += prob * (1.0 - q_i)\n        copt = dict(next_copt)\n    return copt\n\ndef calculate_lole(units1, units2, L, hour_states):\n    \"\"\"\n    Calculates the system-wide Loss of Load Expectation (LOLE) in hours/year.\n\n    Args:\n        units1 (list): Units in Zone 1.\n        units2 (list): Units in Zone 2.\n        L (float): Bidirectional transfer limit in MW.\n        hour_states (list): Hourly load states as (D1, D2, weight_h).\n\n    Returns:\n        float: The total system LOLE in hours/year.\n    \"\"\"\n    copt1 = get_copt(units1)\n    copt2 = get_copt(units2)\n    \n    total_lole = 0.0\n    \n    for d1, d2, w_h in hour_states:\n        prob_shortage_h = 0.0\n        for c1, pr1 in copt1.items():\n            for c2, pr2 in copt2.items():\n                # A shortage occurs if no feasible transfer f exists.\n                # This is true if max(D1 - C1, -L) > min(C2 - D2, L).\n                if max(d1 - c1, -L) > min(c2 - d2, L):\n                    prob_shortage_h += pr1 * pr2\n        \n        total_lole += prob_shortage_h * w_h\n        \n    return total_lole\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and compute accreditation fractions.\n    \"\"\"\n    test_cases = [\n        {\n            \"units1\": [(200, 0.1), (150, 0.1)],\n            \"units2\": [(200, 0.1), (100, 0.1)],\n            \"L\": 150,\n            \"added_resource\": (100, 0.05),\n            \"hour_states\": [(250, 80, 7800), (350, 80, 800), (380, 90, 160)],\n        },\n        {\n            \"units1\": [(200, 0.1), (150, 0.1)],\n            \"units2\": [(200, 0.1), (100, 0.1)],\n            \"L\": 0,\n            \"added_resource\": (100, 0.05),\n            \"hour_states\": [(250, 60, 8000), (360, 60, 760)],\n        },\n        {\n            \"units1\": [(200, 0.1), (150, 0.1)],\n            \"units2\": [(200, 0.1), (100, 0.1)],\n            \"L\": 100,\n            \"added_resource\": (100, 0.05),\n            \"hour_states\": [(250, 120, 8300), (370, 120, 460)],\n        },\n        {\n            \"units1\": [(200, 0.1), (150, 0.1)],\n            \"units2\": [(200, 0.1), (100, 0.1)],\n            \"L\": 150,\n            \"added_resource\": (100, 0.05),\n            \"hour_states\": [(270, 180, 8500), (360, 210, 260)],\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        base_units1 = case[\"units1\"]\n        base_units2 = case[\"units2\"]\n        added_res = case[\"added_resource\"]\n        L_val = case[\"L\"]\n        states = case[\"hour_states\"]\n\n        # 1. Calculate LOLE for the base case\n        lole_base = calculate_lole(base_units1, base_units2, L_val, states)\n\n        # 2. Calculate LOLE with resource added to Zone 1\n        units1_plus = base_units1 + [added_res]\n        lole_z1_add = calculate_lole(units1_plus, base_units2, L_val, states)\n\n        # 3. Calculate LOLE with resource added to Zone 2\n        units2_plus = base_units2 + [added_res]\n        lole_z2_add = calculate_lole(base_units1, units2_plus, L_val, states)\n\n        # 4. Calculate LOLE reductions\n        delta_lole1 = lole_base - lole_z1_add\n        delta_lole2 = lole_base - lole_z2_add\n\n        # 5. Compute accreditation fraction alpha\n        if delta_lole1 == 0:\n            # If the reference improvement is zero, the ratio is ill-defined.\n            # If the improvement in Zone 2 is also zero, alpha is 0.\n            # Otherwise, the relative value is infinite, but this case is\n            # not expected in physically meaningful scenarios with non-zero base LOLE.\n            alpha = 0.0 if delta_lole2 == 0.0 else float('inf')\n        else:\n            alpha = delta_lole2 / delta_lole1\n            \n        results.append(f\"{alpha:.3f}\")\n\n    print(f\"[{','.join(results)}]\")\n\n# Execute the solver\nsolve()\n\n```"
        }
    ]
}