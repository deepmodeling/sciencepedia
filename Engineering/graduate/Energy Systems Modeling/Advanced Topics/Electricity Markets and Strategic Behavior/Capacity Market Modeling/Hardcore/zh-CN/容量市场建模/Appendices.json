{
    "hands_on_practices": [
        {
            "introduction": "容量市场的核心是确保电力系统的可靠性，而准确量化发电侧的不确定性是第一步。容量中断概率表（Capacity Outage Probability Table, COPT）是评估系统可靠性的基石，它描述了系统因机组强制停运而导致的总容量损失的概率分布。本练习将指导您通过递归卷积算法这一标准高效的方法，从单个发电机组的故障率出发，构建整个系统的 COPT。通过这个实践，您将掌握将离散的机组状态聚合成系统级概率模型的核心技术。",
            "id": "4074800",
            "problem": "实现一个完整的、可运行的程序，该程序使用递归卷积算法为一组独立的双态发电机组构建容量停运概率表 (COPT)，并分析计算复杂度作为容量粒度的函数。COPT 是强制停运总容量的概率质量函数。假设每个发电机组 $i$ 的铭牌容量为 $C_i$（单位为兆瓦，缩写为 MW），强迫停运率 (FOR) 为 $q_i$（以小数表示）。在双态模型下，机组 $i$ 的停运容量是一个随机变量 $X_i$，它以概率 $(1 - q_i)$ 取值为 $0$，以概率 $q_i$ 取值为 $C_i$。假设不同机组的停运是相互独立的。为了构建 COPT，需要将容量离散化到一个由容量粒度 $g$（单位为 MW）定义的网格上，该网格定义了宽度为 $g$ 的区间。每个容量 $C_i$ 必须四舍五入到最近的整数个区间，即 $K_i = \\text{round}(C_i / g)$，因此机组 $i$ 的离散化停运容量变为 $0$ 或 $K_i g$。递归卷积逐个机组进行：在每一步中，给定当前停运容量区间的分布 $P$，通过添加机组 $i$ 来更新分布，使得区间索引 $j$ 处的概率质量以 $(1 - q_i)$ 的概率分裂到区间 $j$，并以 $q_i$ 的概率分裂到区间 $j + K_i$。初始分布将全部概率 $1$ 置于区间索引 $0$ 处。\n\n您的程序必须严格按照所述实现递归卷积算法，其中单个内循环遍历现有状态，并对每个状态应用两次更新。为了跟踪复杂度，需要计算卷积执行的标量浮点运算（加法和乘法）的次数：将状态 $j$ 处的每次更新视为两次乘法和两次加法，即每个机组的每个状态总共 $4$ 次运算。同时，计算相同算法的理论运算次数，其等于 $4 \\sum_{i=1}^{N} (S_{i-1} + 1)$，其中 $N$ 是机组数量，$S_{i-1} = \\sum_{m=1}^{i-1} K_m$ 是添加机组 $i$ 之前的累计区间数。此外，计算最终 COPT 的期望停运容量，定义为 $\\mathbb{E}[\\sum_i X_i]$（单位为 MW），并将其与解析期望 $\\sum_i q_i \\cdot (K_i g)$（单位为 MW）进行比较；报告绝对误差（单位为 MW）。程序还必须验证 COPT 是否正确归一化，即概率总和是否在 $10^{-12}$ 的数值容差内等于 $1$。\n\n物理单位要求：所有容量必须以兆瓦 (MW) 为单位处理和报告。期望停运容量和绝对误差以 MW 表示，均四舍五入到三位小数。不涉及角度。不允许使用百分比；$q_i$ 必须以小数形式提供和处理。\n\n实现以上要求，并将其应用于以下测试套件。对于每个测试用例，输入是容量列表（单位 MW）、FOR 列表（小数）和粒度 $g$（单位 MW）：\n\n- 测试用例 1 (正常路径)：容量 $[100, 80, 60, 50, 30]$ MW，FOR $[0.05, 0.06, 0.08, 0.10, 0.02]$，粒度 $g = 10$ MW。\n- 测试用例 2 (更细的粒度)：容量 $[100, 80, 60, 50, 30]$ MW，FOR $[0.05, 0.06, 0.08, 0.10, 0.02]$，粒度 $g = 5$ MW。\n- 测试用例 3 (更粗的粒度)：容量 $[100, 80, 60, 50, 30]$ MW，FOR $[0.05, 0.06, 0.08, 0.10, 0.02]$，粒度 $g = 20$ MW。\n- 测试用例 4 (单机组边界情况)：容量 $[75]$ MW，FOR $[0.10]$，粒度 $g = 5$ MW。\n- 测试用例 5 (零强迫停运率的边缘情况)：容量 $[40, 60]$ MW，FOR $[0.0, 0.2]$，粒度 $g = 10$ MW。\n\n对于每个测试用例，您的程序必须生成一个包含以下七个输出的列表：\n$[S, \\text{ops\\_measured}, \\text{ops\\_theory}, \\text{mean\\_copt\\_mw}, \\text{analytic\\_mean\\_mw}, \\text{error\\_mw}, \\text{normalized}]$\n其中 $S$ 是停运容量区间的数量（一个整数），$\\text{ops\\_measured}$ 是测量的运算次数（一个整数），$\\text{ops\\_theory}$ 是根据上述公式计算的理论运算次数（一个整数），$\\text{mean\\_copt\\_mw}$ 是从 COPT 计算出的期望停运容量（单位 MW，四舍五入到三位小数，一个浮点数），$\\text{analytic\\_mean\\_mw}$ 是解析期望（单位 MW，四舍五入到三位小数，一个浮点数），$\\text{error\\_mw}$ 是绝对差值（单位 MW，四舍五入到三位小数，一个浮点数），$\\text{normalized}$ 是一个布尔值，指示 COPT 的总和是否在数值容差内为 $1$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果（例如，$[result1, result2, result3]$），其中每个 $resultk$ 是针对测试用例 $k$ 的如上所述的七元素列表。",
            "solution": "该问题要求实现一个递归卷积算法，以构建容量停运概率表 (COPT) 并分析其属性。COPT 是电力系统可靠性分析中的一个基本工具，它表示因强迫停运而不可用的总发电容量的概率质量函数 (PMF)。\n\n首先，我们从数学上对问题进行形式化。给定一组 $N$ 个独立的发电机组。对于每个机组 $i \\in \\{1, \\dots, N\\}$，我们有铭牌容量 $C_i$（单位为兆瓦，MW）和强迫停运率 (FOR) $q_i$。根据双态模型，机组 $i$ 的停运容量是一个离散随机变量 $X_i$，其 PMF 如下：\n$$\nP(X_i = x) = \n\\begin{cases} \n1 - q_i  \\text{if } x = 0 \\\\\nq_i  \\text{if } x = C_i \\\\\n0  \\text{otherwise}\n\\end{cases}\n$$\n问题要求将连续的容量值离散化到由粒度 $g$（单位为 MW）定义的网格上。每个机组 $i$ 的容量 $C_i$ 被四舍五入到 $g$ 的最近整数倍。这由区间数 $K_i = \\text{round}(C_i / g)$ 表示。因此，机组 $i$ 的离散化停运容量，记为 $\\hat{X}_i$，为 $0$ 或 $K_i g$。总停运容量 $X_{\\text{total}}$ 是各个离散化停运容量的总和：$X_{\\text{total}} = \\sum_{i=1}^N \\hat{X}_i$。\n\n由于机组停运是独立的，这些随机变量之和的 PMF 是它们各自 PMF 的卷积。COPT 是离散化总停运容量 $X_{\\text{total}}/g$ 的 PMF。我们可以使用递归方法来计算它。设 $P^{(i)}$ 是考虑前 $i$ 个机组后的 COPT（一个概率向量）。$P^{(0)}$ 是没有机组的初始状态，表示确定有 $0$ MW 的停运。这对应于一个在索引 0 处为 1，其他地方为 0 的概率向量。分布 $P^{(i)}$ 是通过将 $P^{(i-1)}$ 与机组 $i$ 的分布进行卷积得到的。\n\n我们的系统状态由一个一维数组表示，称之为 $p$，其中 $p[j]$ 存储了总停运容量对应于区间索引 $j$（即停运容量为 $j \\cdot g$ MW）的概率。最初，$p[0] = 1$，所有其他元素为 $0$。\n递归算法逐个机组进行。当添加机组 $i$（离散化容量为 $K_i$，FOR 为 $q_i$）时，我们更新概率向量 $p$。对于更新前具有概率 $p[j]$ 的每个状态 $j$，该质量被分割。以概率 $1 - q_i$（机组 $i$ 可用），停运量保持为 $j \\cdot g$，因此该质量保留在区间 $j$。以概率 $q_i$（机组 $i$ 强迫停运），停运量增加 $K_i g$，因此该质量移动到区间 $j + K_i$。\n更新规则可以表示为：\n$$\np_{\\text{new}}[k] = p_{\\text{old}}[k] \\cdot (1 - q_i) + p_{\\text{old}}[k - K_i] \\cdot q_i\n$$\n其中我们定义 $p_{\\text{old}}[m] = 0$ 若 $m  0$。这种卷积可以使用一个在状态上向后迭代的单循环来高效地就地实现。设 $S_{i-1} = \\sum_{m=1}^{i-1} K_m$ 是添加机组 $i$ 之前的最大可能停运区间索引。对机组 $i$ 的更新为：\n对于 $j$ 从 $S_{i-1}$ 向下到 $0$：\n1. 将状态 $j$ 的概率贡献加到状态 $j+K_i$：$p[j + K_i] \\leftarrow p[j+K_i] + p[j] \\cdot q_i$。\n2. 更新状态 $j$ 本身的概率：$p[j] \\leftarrow p[j] \\cdot (1 - q_i)$。\n向后迭代至关重要，因为它确保了在计算新概率时，我们使用的是当前机组更新前 $p[j]$ 的值（即 $p_{\\text{old}}[j]$）。概率数组 $p$ 的大小必须足够大，以容纳可能的最大总停运，即 $1 + \\sum_{i=1}^N K_i$ 个区间。\n\n对于复杂度分析，问题为处理每个状态 $j$（在添加一个机组时）指定了 $4$ 次浮点运算（两次加法，两次乘法）的固定成本。所定义的算法遍历从 $0$ 到当前最大累积区间数 $S_{i-1}$ 的所有可能状态。因此，对于每个机组 $i$，处理的状态数为 $S_{i-1} + 1$。总的理论运算次数是所有机组的总和：\n$$\n\\text{ops}_{\\text{theory}} = 4 \\sum_{i=1}^{N} (S_{i-1} + 1)\n$$\n测量的运算次数 $\\text{ops}_{\\text{measured}}$ 是通过在内循环中为每个 $j$ 将计数器增加 $4$ 来计算的。这确保了 $\\text{ops}_{\\text{measured}} = \\text{ops}_{\\text{theory}}$。\n\n最后，我们从最终的 COPT $p_{final}$ 计算所需的输出指标。\n总区间数为 $S = 1 + \\sum_{i=1}^N K_i$。\n从 COPT 计算的期望停运容量是该分布的均值：\n$$\n\\text{mean}_{\\text{copt\\_mw}} = \\sum_{j=0}^{S-1} p_{final}[j] \\cdot (j \\cdot g)\n$$\n解析期望停运容量由期望的线性性质导出。单个离散化机组 $i$ 的期望停运为 $0 \\cdot (1-q_i) + (K_i g) \\cdot q_i = q_i K_i g$。对于所有机组，总和为：\n$$\n\\text{analytic\\_mean\\_mw} = \\sum_{i=1}^{N} q_i K_i g\n$$\n绝对误差 $\\text{error}_{\\text{mw}}$ 是这两个值之间的绝对差。归一化检查确认最终 COPT 中所有概率的总和在一个 $10^{-12}$ 的小数值容差内等于 $1$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_copt_analysis(capacities, fors, g):\n    \"\"\"\n    Constructs a Capacity Outage Probability Table (COPT) for a set of independent\n    two-state generating units and computes analysis metrics.\n\n    Args:\n        capacities (list[float]): List of nameplate capacities (MW).\n        fors (list[float]): List of Forced Outage Rates (decimals).\n        g (float): Capacity granularity (MW).\n\n    Returns:\n        list: A list containing seven analysis results:\n              [S, ops_measured, ops_theory, mean_copt_mw, analytic_mean_mw, error_mw, normalized]\n    \"\"\"\n    num_units = len(capacities)\n    if num_units == 0:\n        return [1, 0, 0, 0.0, 0.0, 0.0, True]\n\n    # Step 1: Discretize capacities into bins\n    # K_i = round(C_i / g)\n    capacities_g = np.array(capacities) / g\n    K = np.round(capacities_g).astype(int)\n\n    # Step 2: Determine total number of bins and initialize COPT array\n    total_K = np.sum(K)\n    num_bins = total_K + 1\n    p = np.zeros(num_bins, dtype=np.float64)\n    p[0] = 1.0\n\n    # Step 3: Compute theoretical operation count\n    # Sequence of cumulative K values before adding unit i: S_0, S_1, ..., S_{N-1}\n    # where S_i = sum_{m=1 to i} K_m\n    cumulative_K_sequence = np.concatenate(([0], np.cumsum(K[:-1])))\n    # Theoretical ops = 4 * sum_{i=1 to N} (S_{i-1} + 1)\n    ops_theory = 4 * np.sum(cumulative_K_sequence + 1)\n    \n    # Step 4: Perform recursive convolution\n    ops_measured = 0\n    cumulative_K_current = 0\n    for i in range(num_units):\n        k_i = K[i]\n        q_i = fors[i]\n        p_i = 1.0 - q_i # Probability unit is available\n        \n        # The inner loop iterates backwards over all existing states from 0 to the\n        # maximum possible state before adding the current unit.\n        # This implementation ensures ops_measured will equal ops_theory.\n        for j in range(cumulative_K_current, -1, -1):\n            prob_at_j = p[j]\n            \n            # Update for unit outage: mass from state j moves to j + k_i\n            p[j + k_i] += prob_at_j * q_i\n            \n            # Update for unit availability: mass at state j is scaled\n            p[j] = prob_at_j * p_i\n            \n            # As per problem, count 4 operations per state per unit\n            ops_measured += 4\n            \n        cumulative_K_current += k_i\n\n    # Step 5: Calculate final output metrics\n    # S: Total number of outage capacity bins\n    S = num_bins\n    \n    # mean_copt_mw: Expected outage from the final COPT\n    bin_indices = np.arange(S, dtype=np.float64)\n    mean_copt_mw = g * np.sum(bin_indices * p)\n    \n    # analytic_mean_mw: Analytic expected outage based on discretized capacities\n    analytic_mean_mw = g * np.sum(K * np.array(fors, dtype=np.float64))\n    \n    # error_mw: Absolute error between the two means\n    error_mw = abs(mean_copt_mw - analytic_mean_mw)\n    \n    # normalized: Check if the COPT probability distribution sums to 1\n    normalized = abs(np.sum(p) - 1.0)  1e-12\n\n    # Round floating-point results to three decimal places\n    mean_copt_mw_rounded = round(mean_copt_mw, 3)\n    analytic_mean_mw_rounded = round(analytic_mean_mw, 3)\n    error_mw_rounded = round(error_mw, 3)\n\n    return [\n        S,\n        int(ops_measured),\n        int(ops_theory),\n        mean_copt_mw_rounded,\n        analytic_mean_mw_rounded,\n        error_mw_rounded,\n        normalized\n    ]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1 (happy path)\n        ([100, 80, 60, 50, 30], [0.05, 0.06, 0.08, 0.10, 0.02], 10),\n        # Test case 2 (finer granularity)\n        ([100, 80, 60, 50, 30], [0.05, 0.06, 0.08, 0.10, 0.02], 5),\n        # Test case 3 (coarser granularity)\n        ([100, 80, 60, 50, 30], [0.05, 0.06, 0.08, 0.10, 0.02], 20),\n        # Test case 4 (single-unit boundary)\n        ([75], [0.10], 5),\n        # Test case 5 (zero-FOR edge case)\n        ([40, 60], [0.0, 0.2], 10),\n    ]\n\n    results = []\n    for case in test_cases:\n        # Main logic to calculate the result for one case goes here.\n        capacities, fors, g = case\n        result = compute_copt_analysis(capacities, fors, g)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # Produces a single-line string representation of a list of lists.\n    # e.g., [[res1_item1, res1_item2, ...], [res2_item1, res2_item2, ...]]\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在掌握了如何构建 COPT 来模拟供应侧的可靠性后，下一步是将其融入完整的市场框架中，从而连接物理系统与经济机制。这个综合性练习将引导您完成一个端到端的容量市场建模过程。您将利用之前构建的 COPT 来推导基于可靠性价值（即损失负荷价值 $V$ 与期望缺电时数 $\\text{LOLE}$ 的乘积）的需求曲线，并与基于机组报价的供应曲线进行匹配，最终结算出市场出清价格。这个练习全面展示了如何从最基本的物理原理推导出关键的经济结果。",
            "id": "4074806",
            "problem": "您需要构建并分析一个用于能源系统建模中资源充裕度的程式化容量市场，使用一个包含 $10$ 个发电机组的合成数据集。建模必须从定义非强迫容量 (UCAP)、等效需求强迫停运率 (EFORd) 和容量停运概率表 (COPT) 的第一性原理出发，并且必须将容量市场需求视为源于可靠性的经济估值。\n\n从以下基础出发：\n\n- 机组 $i$ 的等效需求强迫停运率 (EFORd) 是指当需要该机组时，其不可用（处于强迫停运状态）的概率 $p_i \\in [0,1]$。\n- 机组 $i$ 的装机容量 (ICAP) 表示为 $C_i$，单位为兆瓦 ($\\mathrm{MW}$)。非强迫容量 (UCAP) 从第一性原理定义为 $$\\text{UCAP}_i = C_i \\cdot (1 - p_i).$$\n- 容量停运概率表 (COPT) 是系统总容量停运的概率分布，假设每个机组的停运是独立的伯努利事件：每个机组 $i$ 以概率 $(1 - p_i)$ 贡献 $0$ 的停运量，或以概率 $p_i$ 贡献 $C_i$ 的停运量。设总装机容量为 $$S = \\sum_{i=1}^{10} C_i.$$ 设随机停运容量为 $$O = \\sum_{i=1}^{10} X_i,$$ 其中 $$X_i = \\begin{cases} C_i  \\text{概率为 } p_i, \\\\ 0  \\text{概率为 } 1 - p_i. \\end{cases}$$ 可用容量为 $$A = S - O.$$\n- 设峰值负荷水平为 $L$（单位为 $\\mathrm{MW}$），设 $H$（单位为小时/年）表示评估充裕度风险的年度峰值小时数。当系统中增加一个 $Q$（单位为 $\\mathrm{MW}$）的完全可靠容量增量时，缺负荷期望 (LOLE) 定义为每年出现电力缺额的期望小时数：$$\\text{LOLE}(Q) = H \\cdot \\mathbb{P}\\left(A + Q  L\\right) = H \\cdot \\mathbb{P}\\left(O > S - (L - Q)\\right).$$\n- 设缺负荷价值 (VOLL) 为 $V$（单位为 $\\mathrm{\\$ / MWh}$）。容量数量为 $Q$ 时的支付意愿通过将边际采购成本与边际避免停运成本相等来推导。在程式化的情况下，即增加 $1$ $\\mathrm{MW}$ 的完全可靠容量可在每个缺电小时内大约减少 $1$ $\\mathrm{MW}$ 的未服务电量，容量的需求价格函数为 $$P(Q) = V \\cdot \\text{LOLE}(Q),$$ 得出价格单位为 $\\mathrm{\\$ / MW\\text{-}年}$。设一个行政设定的可靠性标准为 $\\text{LOLE}^\\star$（单位为小时/年）；可靠性要求 $R$（单位为 $\\mathrm{MW}$）是求解 $$\\text{LOLE}(R) = \\text{LOLE}^\\star$$ 的数量。\n\n给定一个包含 $10$ 个机组的合成数据集：\n- 装机容量（$\\mathrm{MW}$）：$$C = [200,\\,180,\\,160,\\,140,\\,120,\\,100,\\,90,\\,80,\\,70,\\,60].$$\n- 等效需求强迫停运率：$$p = [0.04,\\,0.05,\\,0.06,\\,0.07,\\,0.08,\\,0.06,\\,0.10,\\,0.12,\\,0.08,\\,0.09].$$\n- 供应报价（投标价）（$\\mathrm{\\$ / MW\\text{-}年}$）：$$b = [10000,\\,11000,\\,12000,\\,13000,\\,14000,\\,15000,\\,16000,\\,18000,\\,20000,\\,22000].$$\n\n在您的程序中需要实现的任务：\n\n1. 使用定义 $\\text{UCAP}_i = C_i \\cdot (1 - p_i)$ 计算每个机组的非强迫容量。\n\n2. 为停运容量 $O$ 构建容量停运概率表 (COPT)，将 $10$ 个机组的停运视为具有停运量 $C_i$ 和概率 $p_i$ 的独立伯努利随机变量。使用整数兆瓦分辨率。这是一个对停运状态的离散卷积：\n   - 将停运的概率质量函数 (PMF) 初始化为 $$\\mathbb{P}(O = 0) = 1.$$\n   - 对每个机组 $i$，更新 PMF：对于每个停运水平 $o$，新的 PMF 满足\n     $$\\mathbb{P}_{\\text{new}}(O = o) = \\mathbb{P}_{\\text{old}}(O = o) \\cdot (1 - p_i) + \\mathbb{P}_{\\text{old}}(O = o - C_i) \\cdot p_i,$$\n     其中当 $o - C_i  0$ 时，$\\mathbb{P}_{\\text{old}}(O = o - C_i) = 0$。\n\n3. 将需求曲线推导为函数 $$P(Q) = V \\cdot H \\cdot \\mathbb{P}\\left(O > S - (L - Q)\\right),$$ 其中 $Q$ 是待采购的完全可靠容量的数量（单位 $\\mathrm{MW}$），$S$ 是总装机容量，$L$ 是峰值负荷，$H$ 是年度峰值小时数，$V$ 是缺负荷价值（单位 $\\mathrm{\\$ / MWh}$）。确保对于给定的系统和负荷参数，可以为任何 $Q \\ge 0$ 计算出 $P(Q)$。\n\n4. 使用由 $10$ 个报价构成的阶梯式供应曲线进行单一价格市场出清。按投标价 $b_i$ 从低到高对机组进行排序，累积 UCAP 以形成累积报价数量水平 $Q_k$，并在每个水平上将边际报价 $b_i$ 与该数量下的需求价格 $P(Q_k)$ 进行比较。出清数量 $Q^\\star$ 是使得边际投标价小于或等于该数量下的需求价格的最大累积 UCAP：\n   $$Q^\\star = \\max \\left\\{ Q_k \\,\\middle|\\, b_{\\text{marginal at }Q_k} \\le P(Q_k) \\right\\}.$$\n   最终的容量价格为 $$P^\\star = P(Q^\\star).$$\n\n5. 容量价格必须以 $\\mathrm{\\$ / MW\\text{-}年}$ 为单位，并以浮点数形式报告。\n\n测试套件和输出要求：\n\n- 实现以下四个测试用例，每个用例由元组 $(V,\\,H,\\,L,\\,\\text{LOLE}^\\star,\\,\\text{EFORd 覆盖})$ 指定，其中 EFORd 覆盖要么是空指令，要么是用于修改该测试用例中机组 $i$（使用从1开始的索引）的强迫停运率的单个配对 $(i,\\,p_i^{\\text{new}})$：\n  1. 用例 1：$(2000,\\,50,\\,1080,\\,3,\\,\\text{无覆盖})$。\n  2. 用例 2：$(5000,\\,50,\\,1080,\\,3,\\,\\text{无覆盖})$。\n  3. 用例 3：$(2000,\\,50,\\,1020,\\,3,\\,\\text{无覆盖})$。\n  4. 用例 4：$(2000,\\,50,\\,1080,\\,3,\\,\\text{覆盖 }(1,\\,0.20))$。\n\n- 对于每个测试用例，计算最终的容量价格 $P^\\star$（单位 $\\mathrm{\\$ / MW\\text{-}年}$），并四舍五入到两位小数。\n\n- 最终输出格式：您的程序应生成单行输出，包含四个结果，形式为方括号括起来的逗号分隔列表（例如，$[result_1,result_2,result_3,result_4]$），其中每个 $result_k$ 是测试用例 $k$ 的浮点数容量价格，单位为 $\\mathrm{\\$ / MW\\text{-}年}$。\n\n所有数值答案必须以指定单位表示。容量值单位为 $\\mathrm{MW}$，时间值单位为小时/年，价格单位为 $\\mathrm{\\$ / MW\\text{-}年}$。本问题不涉及角度。百分比必须始终表示为小数（例如，$0.10$ 而不是 $10\\%$）。",
            "solution": "问题 RCM#2024–8A 要求构建和分析一个程式化的电力容量市场。解决方案涉及为一组发电机组计算非强迫容量 (UCAP)，构建一个全系统的容量停运概率表 (COPT)，基于可靠性估值推导需求曲线，并通过找到 UCAP 供应曲线和推导出的需求曲线之间的平衡点来进行市场出清。\n\n问题陈述的验证已经完成。所有给定条件、定义和约束都有科学依据、经过形式化指定且内部一致。该问题是适定且可解的。我们根据问题中阐述的第一性原理，进行分步求解。\n\n首先，我们为由 $10$ 个发电机组组成的系统建立基本参数。\n装机容量 (ICAP) 以兆瓦 ($\\mathrm{MW}$) 为单位，作为向量 $C$ 给出：\n$$C = [200,\\,180,\\,160,\\,140,\\,120,\\,100,\\,90,\\,80,\\,70,\\,60]$$\n等效需求强迫停运率 (EFORd) 作为概率向量 $p$ 给出：\n$$p = [0.04,\\,0.05,\\,0.06,\\,0.07,\\,0.08,\\,0.06,\\,0.10,\\,0.12,\\,0.08,\\,0.09]$$\n供应报价（投标价）以美元/兆瓦年 ($\\mathrm{\\$ / MW\\text{-}年}$) 为单位提供：\n$$b = [10000,\\,11000,\\,12000,\\,13000,\\,14000,\\,15000,\\,16000,\\,18000,\\,20000,\\,22000]$$\n\n系统的总装机容量是各个机组容量的总和：\n$$S = \\sum_{i=1}^{10} C_i = 200+180+160+140+120+100+90+80+70+60 = 1200 \\, \\mathrm{MW}$$\n\n**步骤 1：非强迫容量 (UCAP) 计算**\n非强迫容量 $\\text{UCAP}_i$ 代表机组的期望可用容量，考虑了其处于强迫停运的概率。它由以下原理定义：一个机组对系统可靠性的贡献是其装机容量根据其不可用率降额后的值。\n公式为：\n$$\\text{UCAP}_i = C_i \\cdot (1 - p_i)$$\n将此公式应用于 $10$ 个机组中的每一个，得出它们各自的 UCAP 值：\n- $\\text{UCAP}_1 = 200 \\cdot (1 - 0.04) = 192.0 \\, \\mathrm{MW}$\n- $\\text{UCAP}_2 = 180 \\cdot (1 - 0.05) = 171.0 \\, \\mathrm{MW}$\n- $\\text{UCAP}_3 = 160 \\cdot (1 - 0.06) = 150.4 \\, \\mathrm{MW}$\n- $\\text{UCAP}_4 = 140 \\cdot (1 - 0.07) = 130.2 \\, \\mathrm{MW}$\n- $\\text{UCAP}_5 = 120 \\cdot (1 - 0.08) = 110.4 \\, \\mathrm{MW}$\n- $\\text{UCAP}_6 = 100 \\cdot (1 - 0.06) = 94.0 \\, \\mathrm{MW}$\n- $\\text{UCAP}_7 = 90 \\cdot (1 - 0.10) = 81.0 \\, \\mathrm{MW}$\n- $\\text{UCAP}_8 = 80 \\cdot (1 - 0.12) = 70.4 \\, \\mathrm{MW}$\n- $\\text{UCAP}_9 = 70 \\cdot (1 - 0.08) = 64.4 \\, \\mathrm{MW}$\n- $\\text{UCAP}_{10} = 60 \\cdot (1 - 0.09) = 54.6 \\, \\mathrm{MW}$\n\n**步骤 2：容量停运概率表 (COPT) 构建**\nCOPT 是系统总停运容量（由随机变量 $O$ 表示）的概率质量函数 (PMF)。它是通过假设 $10$ 个机组的停运是独立随机事件推导出来的。对于每个机组 $i$，发生大小为 $C_i$ 的停运的概率为 $p_i$，发生 $0 \\, \\mathrm{MW}$ 停运的概率为 $1 - p_i$。总停运量 $O$ 是这些独立的、单个随机变量的和。\n$O$ 的 PMF 是通过卷积迭代构建的。我们从一个停运量为 $0$、概率为 $1$ 的系统开始。然后，为每个机组更新 PMF。设 $\\mathbb{P}_k(O=o)$ 是考虑机组 $1$ 到 $k$ 时总停运量为 $o \\, \\mathrm{MW}$ 的概率。在加入机组 $k+1$ 时，新的 PMF 计算如下：\n$$\\mathbb{P}_{k+1}(O = o) = \\mathbb{P}_{k}(O = o) \\cdot (1 - p_{k+1}) + \\mathbb{P}_{k}(O = o - C_{k+1}) \\cdot p_{k+1}$$\n对所有 $10$ 个机组重复此过程。可能的停运状态范围从 $0$ 到 $S = 1200 \\, \\mathrm{MW}$。得到的 PMF，$\\mathbb{P}(O=o)$，是一个数组，其索引对应于以兆瓦为单位的停运量 $o$。从这个 PMF，我们可以计算出互补累积分布函数 (CCDF)，即 $\\mathbb{P}(O \\ge o)$，这对于计算可靠性指标至关重要。\n\n**步骤 3：需求曲线制定**\n容量需求不是直接给出的，而是从可靠性的经济价值中推导出来的。需求价格 $P(Q)$ 代表系统运营商为额外增量 $Q$ 的完全可靠容量的支付意愿。它被定义为缺负荷价值 ($V$)、峰值小时数 ($H$) 和缺负荷期望 ($\\text{LOLE}$) 的函数。\n对于给定水平的已采购可靠容量 $Q$，其 LOLE 为：\n$$\\text{LOLE}(Q) = H \\cdot \\mathbb{P}(\\text{可用容量} + Q  \\text{峰值负荷})$$\n$$\\text{LOLE}(Q) = H \\cdot \\mathbb{P}((S-O) + Q  L) = H \\cdot \\mathbb{P}(O > S - L + Q)$$\n需求价格函数则由下式给出：\n$$P(Q) = V \\cdot \\text{LOLE}(Q) = V \\cdot H \\cdot \\mathbb{P}(O > S - L + Q)$$\n概率项 $\\mathbb{P}(O > k)$（其中 $k = S - L + Q$）是根据 COPT 的 CCDF 计算的。由于 $O$ 取整数值，$\\mathbb{P}(O > k) = \\mathbb{P}(O \\ge \\lfloor k \\rfloor + 1)$。这个函数 $P(Q)$ 构成了需求曲线。\n\n**步骤 4：供应曲线与市场出清**\n容量的供应曲线是通过将发电机组按其投标价 $b_i$ 从低到高排序来构建的。这会创建一个阶梯式供应函数，其中每个阶梯的高度是投标价 $b_i$，宽度是该机组的 UCAP$_i$。\n市场在此供应曲线与需求曲线 $P(Q)$ 的交点处出清。出清数量 $Q^\\star$ 是边际报价小于或等于该数量下需求价格的最大累积 UCAP。形式上，如果机组按 $j_1, j_2, \\ldots, j_{10}$ 索引，使得 $b_{j_1} \\le b_{j_2} \\le \\ldots$，且累积 UCAP 为 $Q_k = \\sum_{m=1}^{k} \\text{UCAP}_{j_m}$，则：\n$$Q^\\star = \\max \\left\\{ Q_k \\,\\middle|\\, b_{j_k} \\le P(Q_k) \\right\\}$$\n如果没有机组满足此条件，则 $Q^\\star = 0$。\n支付给所有出清容量的单一市场出清价格 $P^\\star$，由总出清数量下的需求价格决定：\n$$P^\\star = P(Q^\\star)$$\n\n**步骤 5：测试用例计算**\n上述流程将应用于四个指定的测试用例中的每一个。对于每个用例，设置参数 $(V, H, L)$，如果指定了覆盖，则调整 EFORd 向量 $p$。构建 COPT，隐式定义需求曲线，进行市场出清以找到 $Q^\\star$，然后计算最终价格 $P^\\star$ 并四舍五入到两位小数。四个用例的结果将在最终输出中呈现。对于用例 4，机组 1（$C_1 = 200 \\, \\mathrm{MW}$）的 EFORd 从 $p_1 = 0.04$ 更改为 $p_1^{\\text{new}} = 0.20$。这需要在市场出清前为该特定测试用例重新计算该机组的 UCAP 并重建 COPT。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves a series of capacity market clearing problems based on a stylized reliability model.\n    \"\"\"\n\n    # Base data for the 10 generating units\n    # Installed Capacities (ICAP) in MW\n    C_base = np.array([200, 180, 160, 140, 120, 100, 90, 80, 70, 60], dtype=np.int32)\n    # Equivalent Forced Outage Rates on Demand (EFORd)\n    p_base = np.array([0.04, 0.05, 0.06, 0.07, 0.08, 0.06, 0.10, 0.12, 0.08, 0.09])\n    # Supply offers (bids) in $/MW-year\n    b_base = np.array([10000, 11000, 12000, 13000, 14000, 15000, 16000, 18000, 20000, 22000])\n\n    # Test suite: (V, H, L, LOLE_star, EFORd_override)\n    # V: Value of Lost Load ($/MWh)\n    # H: Peak hours per year\n    # L: Peak load (MW)\n    # LOLE_star: Reliability standard (h/yr) - not used in clearing, for context only\n    # EFORd_override: (unit_index_1based, new_p_value) or None\n    test_cases = [\n        (2000, 50, 1080, 3, None),\n        (5000, 50, 1080, 3, None),\n        (2000, 50, 1020, 3, None),\n        (2000, 50, 1080, 3, (1, 0.20)),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        V, H, L, _, override = case\n        \n        # Make copies of base data to allow for modification\n        C = C_base.copy()\n        p = p_base.copy()\n        b = b_base.copy()\n        \n        # Apply EFORd override if specified\n        if override:\n            unit_idx, new_p = override\n            p[unit_idx - 1] = new_p\n\n        # --- Step 1: UCAP Calculation ---\n        UCAP = C * (1 - p)\n\n        # --- Step 2: COPT Construction ---\n        S = np.sum(C) # Total installed capacity\n        \n        # Initialize PMF for outages: P(O=0) = 1\n        pmf = np.zeros(S + 1)\n        pmf[0] = 1.0\n        \n        # Iteratively convolve with each unit's outage distribution\n        for i in range(len(C)):\n            Ci = C[i]\n            pi = p[i]\n            \n            # Using a temporary array for the new PMF is conceptually clearer\n            # and safer than in-place modification.\n            prev_pmf = pmf.copy()\n            # Contribution from unit 'i' not being on outage\n            pmf = prev_pmf * (1 - pi)\n            # Contribution from unit 'i' being on outage\n            pmf[Ci:] += prev_pmf[:-Ci] * pi\n            \n        # Compute the complementary cumulative distribution function (CCDF)\n        # ccdf[k] = P(O >= k)\n        ccdf = np.cumsum(pmf[::-1])[::-1]\n\n        # --- Step 3: Demand Curve Function ---\n        def get_demand_price(Q, V_val, H_val, L_val, S_val, ccdf_val):\n            \"\"\"\n            Calculates the demand price P(Q) for a given quantity Q.\n            P(Q) = V * H * P(O > S - L + Q)\n            \"\"\"\n            outage_threshold = S_val - L_val + Q\n            \n            # P(O > k) = P(O >= floor(k) + 1)\n            # Find the index for the CCDF lookup\n            lookup_idx = int(np.floor(outage_threshold)) + 1\n            \n            prob_shortfall = 0.0\n            if lookup_idx >= len(ccdf_val):\n                prob_shortfall = 0.0\n            elif lookup_idx  0:\n                prob_shortfall = 1.0\n            else:\n                prob_shortfall = ccdf_val[lookup_idx]\n                \n            return V_val * H_val * prob_shortfall\n\n        # --- Step 4: Supply Curve and Market Clearing ---\n        # Combine unit data and sort by bid price to form the supply curve\n        # (bid, ucap, capacity)\n        supply_stack = sorted(zip(b, UCAP, C), key=lambda x: x[0])\n        \n        cleared_ucap = 0.0\n        cumulative_ucap_at_step = 0.0\n        \n        for bid_i, ucap_i, _ in supply_stack:\n            potential_cleared_ucap = cumulative_ucap_at_step + ucap_i\n            \n            # Calculate demand price at this potential cumulative quantity\n            demand_price_at_ucap = get_demand_price(\n                potential_cleared_ucap, V, H, L, S, ccdf)\n            \n            # Check clearing condition\n            if bid_i = demand_price_at_ucap:\n                # If the unit's bid is below or at the demand price, it clears\n                cleared_ucap = potential_cleared_ucap\n                cumulative_ucap_at_step = potential_cleared_ucap\n            else:\n                # This unit is the first not to clear, so we stop\n                break\n        \n        # --- Step 5: Final Price Calculation ---\n        # The clearing price is the demand price at the final cleared quantity\n        Q_star = cleared_ucap\n        P_star = get_demand_price(Q_star, V, H, L, S, ccdf)\n        \n        results.append(round(P_star, 2))\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在理想化的“铜板”模型中，容量的价值与其在系统中的位置无关。然而，真实的电力系统受到输电网络物理极限的严格约束，这使得容量的地理位置成为一个决定其可靠性贡献的关键因素。本练习将引导您探索容量的“区域价值”和“认证”这一前沿课题。通过为一个两区域系统建模，您将亲手计算并比较在不同区域增加相同容量对系统可靠性的影响，从而深刻理解输电阻塞如何影响容量的有效性，这是现代容量市场设计中的一个核心挑战。",
            "id": "4074729",
            "problem": "考虑一个用于容量市场建模和可靠性评估的两区域电力系统。该系统由区域 $1$ 和区域 $2$ 组成，通过一个单一的传输接口相连，该接口的对称双向传输极限为 $L$ 兆瓦 (megawatt)。每个区域都有一组发电机组。每个发电机组 $i$ 的铭牌容量为 $P_i$ 兆瓦，并具有一个独立的强迫停运率 $q_i$（一个在区间 $[0,1]$ 内的小数）。一个机组要么以其全部铭牌容量可用（概率为 $(1 - q_i)$），要么不可用（容量为零，概率为 $q_i$）。在小时 $h$，区域 $1$ 和区域 $2$ 的负荷是确定性数值 $D_1(h)$ 和 $D_2(h)$，单位为兆瓦。设小时状态 $h$ 每年发生的期望小时数为 $w_h$，单位为小时/年。负荷损失期望 (Loss of Load Expectation, LOLE) 定义为系统中任何地方出现任何未服务负荷的年期望小时数。\n\n从以下基本原则出发：\n- 负荷损失期望 (LOLE) 的定义是出现未服务负荷的期望小时数：对于一个小时状态 $h$，缺电概率是指不存在一个可行的功率传输 $f$ 同时满足两个区域的平衡和接口约束的概率，即 $C_1 + f \\ge D_1(h)$，$C_2 - f \\ge D_2(h)$，以及 $-L \\le f \\le L$，其中 $C_1$ 和 $C_2$ 是小时 $h$ 内区域 $1$ 和区域 $2$ 的随机可用容量。\n- 所有机组和小时的机组停运是独立的，且区域间的停运也是独立的。\n- 在给定的小时状态下，满足负荷的可行性等同于在区间 $[-L, L]$ 内存在一个传输功率 $f$，使得两个区域都能满足其负荷约束。定义缺额 $S_1 = D_1(h) - C_1$ 和 $S_2 = D_2(h) - C_2$。当且仅当交集 $[S_1, -S_2] \\cap [-L, L]$ 非空时，存在可行的传输。\n\n利用这些原则，推导一个算法，通过精确枚举独立停运模型所蕴含的随机可用容量 $C_1$ 和 $C_2$ 的联合分布，并对每个小时状态和每个 $(C_1, C_2)$ 对检查可行性，来计算系统级的LOLE（单位为小时/年）。\n\n候选资源的认证分数定义如下：考虑将一个铭牌容量为 $P_{\\text{add}}$、强迫停运率为 $q_{\\text{add}}$ 的资源添加到区域 $2$（一个出口受限区域），或者作为参考，添加到区域 $1$。设 $\\Delta \\text{LOLE}_2$ 是将资源添加到区域 $2$ 带来的LOLE降低量，$\\Delta \\text{LOLE}_1$ 是将同一资源添加到区域 $1$ 带来的LOLE降低量。认证分数 $\\alpha$ 是比率 $\\alpha = \\Delta \\text{LOLE}_2 / \\Delta \\text{LOLE}_1$，表示为一个小数（无单位）。该比率捕捉了资源在出口受限区域相对于其在输入关键区域的有效可靠性价值。\n\n你的任务是实现一个程序，该程序：\n- 计算基础系统的LOLE。\n- 计算将候选资源添加到区域 $2$ 后的LOLE。\n- 计算将同一候选资源添加到区域 $1$ 后的LOLE。\n- 计算每个测试用例的认证分数 $\\alpha$。\n\n科学真实性要求：程序必须严格使用从接口约束和机组停运模型推导出的可行性条件，不得假设任何简化的或启发式的可靠性公式，并且必须执行与独立停运假设一致的容量分布的精确枚举。\n\n单位和数值规范：\n- 所有容量 $P_i$、负荷 $D_1(h)$ 和 $D_2(h)$ 以及接口极限 $L$ 都必须以兆瓦为单位处理。\n- LOLE必须以小时/年为单位进行计算和内部处理。\n- 最终的认证分数 $\\alpha$ 必须表示为小数值。\n- 在最终输出中，将报告的认证分数四舍五入到三位小数。\n\n测试套件规范。对于每个测试用例，系统由以下部分定义：\n- 区域 $1$ 的机组，以 $(P_i, q_i)$ 对的形式给出。\n- 区域 $2$ 的机组，以 $(P_i, q_i)$ 对的形式给出。\n- 接口极限 $L$，单位为兆瓦。\n- 候选新增资源 $(P_{\\text{add}}, q_{\\text{add}})$。\n- 负荷小时状态 $(D_1(h), D_2(h), w_h)$。\n\n使用以下四个测试用例：\n\n测试用例 $1$（中等传输能力，剩余出口通常可用）：\n- 区域 $1$ 机组：$(200, 0.1)$, $(150, 0.1)$。\n- 区域 $2$ 机组：$(200, 0.1)$, $(100, 0.1)$。\n- 接口：$L = 150$。\n- 新增资源：$(100, 0.05)$。\n- 小时状态：$(250, 80, 7800)$, $(350, 80, 800)$, $(380, 90, 160)$。\n\n测试用例 $2$（出口完全受限，$L = 0$，在区域 $2$ 增加的容量无法降低系统LOLE）：\n- 区域 $1$ 机组：$(200, 0.1)$, $(150, 0.1)$。\n- 区域 $2$ 机组：$(200, 0.1)$, $(100, 0.1)$。\n- 接口：$L = 0$。\n- 新增资源：$(100, 0.05)$。\n- 小时状态：$(250, 60, 8000)$, $(360, 60, 760)$。\n\n测试用例 $3$（边界受限接口，没有新增容量时出口有时不足）：\n- 区域 $1$ 机组：$(200, 0.1)$, $(150, 0.1)$。\n- 区域 $2$ 机组：$(200, 0.1)$, $(100, 0.1)$。\n- 接口：$L = 100$。\n- 新增资源：$(100, 0.05)$。\n- 小时状态：$(250, 120, 8300)$, $(370, 120, 460)$。\n\n测试用例 $4$（出口受限区域具有高本地负荷；新增容量主要服务于本地需求）：\n- 区域 $1$ 机组：$(200, 0.1)$, $(150, 0.1)$。\n- 区域 $2$ 机组：$(200, 0.1)$, $(100, 0.1)$。\n- 接口：$L = 150$。\n- 新增资源：$(100, 0.05)$。\n- 小时状态：$(270, 180, 8500)$, $(360, 210, 260)$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含四个测试用例的认证分数 $\\alpha$，格式为方括号内的逗号分隔列表，每个值四舍五入到三位小数（例如，$[0.000,0.532,0.217,0.845]$）。",
            "solution": "问题陈述经评估有效。它在科学上基于电力系统可靠性分析的既定原则，问题设定良好，具有完整且一致的数据和定义集，并以客观、正式的语言进行表述。任务是基于一个明确定义的关于发电机不可用性和网络约束的概率模型，计算一个特定的指标，即认证分数。\n\n解决方案首先从所提供的基本原则中推导出必要的理论组成部分，然后构建一个算法来计算所需的量。\n\n1.  **区域可用容量建模**\n\n该系统由两个区域组成，区域 $1$ 和区域 $2$。每个区域包含一组发电机组。对于任何给定的机组 $i$，其铭牌容量为 $P_i$，强迫停运率为 $q_i$。问题陈述指出，机组以其全部容量 $P_i$ 可用的概率为 $1-q_i$，不可用（零容量）的概率为 $q_i$。所有机组的停运是相互独立的。\n\n要确定一个区域（例如区域 $1$）的总可用容量（由随机变量 $C_1$ 表示），我们必须考虑机组停运的所有可能组合。这会得到 $C_1$ 的一个概率质量函数 (PMF)，通常称为容量停运概率表 (COPT)。设区域 $1$ 中的机组索引为 $j=1$ 到 $N_1$。$C_1$ 的PMF可以递归地构建。\n\n设 $p_j(c)$ 是机组 $j$ 的PMF，即 $p_j(P_j) = 1-q_j$ 和 $p_j(0) = q_j$。前 $k$ 个机组容量之和 $C_{1}^{(k)} = \\sum_{j=1}^{k} C_{1,j}$ 的PMF，可以通过 $C_{1}^{(k-1)}$ 的PMF与机组 $k$ 的PMF进行卷积得到。\n\n在算法上，我们可以如下构建COPT，它是一组 $(C, \\text{Pr}(C))$ 对的集合：\n- 从一个初始状态开始：容量为零，概率为 $1$：$\\{(0, 1.0)\\}$。\n- 对于区域中的每个机组 $(P_i, q_i)$：\n  - 创建一个新的空COPT。\n  - 对于当前COPT中的每个现有容量状态 $(C_{\\text{old}}, \\text{Pr}_{\\text{old}})$：\n    - 新机组不可用（概率为 $q_i$）导致一个状态 $(C_{\\text{old}}, \\text{Pr}_{\\text{old}} \\cdot q_i)$。\n    - 新机组可用（概率为 $1-q_i$）导致一个状态 $(C_{\\text{old}} + P_i, \\text{Pr}_{\\text{old}} \\cdot (1-q_i))$。\n    - 将这些新概率加到新COPT中相应的容量水平上，对相同的容量值，其概率求和。\n- 用新的COPT替换旧的COPT。\n对区域中的所有机组重复此过程。设区域 $1$ 和区域 $2$ 的最终COPT分别为 $\\text{COPT}_1 = \\{(C_{1,j}, \\text{Pr}(C_{1,j}))\\}$ 和 $\\text{COPT}_2 = \\{(C_{2,k}, \\text{Pr}(C_{2,k}))\\}$。\n\n2.  **两区域可行性与负荷损失**\n\n对于给定的小时状态 $h$，负荷是确定性值 $D_1(h)$ 和 $D_2(h)$。可用容量 $C_1$ 和 $C_2$ 是随机变量。系统状态的一个特定实现由一对 $(C_1, C_2)$ 给出。由于两个区域的停运是独立的，该状态的联合概率为 $\\text{Pr}(C_1, C_2) = \\text{Pr}(C_1) \\cdot \\text{Pr}(C_2)$。\n\n当无法满足两个区域的需求时，发生负荷损失（缺电）事件。根据问题的原则，这种情况发生在没有可行的功率传输 $f$（从区域 $2$ 到区域 $1$）满足以下约束时：\n$$C_1 + f \\ge D_1(h)$$\n$$C_2 - f \\ge D_2(h)$$\n$$-L \\le f \\le L$$\n这些不等式为所需的传输功率 $f$ 定义了一个区间：$f \\in [D_1(h) - C_1, C_2 - D_2(h)]$。我们定义缺额为 $S_1 = D_1(h) - C_1$ 和 $S_2 = D_2(h) - C_2$，因此区间为 $[S_1, -S_2]$。可行的传输也必须位于由传输极限定义的区间 $[-L, L]$ 内。\n\n当且仅当这两个区间 $[S_1, -S_2] \\cap [-L, L]$ 的交集非空时，存在可行的传输。如果此交集为空，则发生缺电。两个闭区间 $[a, b]$ 和 $[c, d]$ 的交集为空当且仅当 $b  c$ 或 $d  a$。在我们的情况下，这意味着 $-S_2  S_1$（这意味着 $C_1+C_2  D_1(h)+D_2(h)$，即全系统容量不足）或者由于其他原因区间不重叠。一个更直接的非空交集条件是 $\\max(a, c) \\le \\min(b, d)$。\n\n因此，**无缺电**的条件是：\n$$\\max(D_1(h) - C_1, -L) \\le \\min(C_2 - D_2(h), L)$$\n如果此条件被违反，则发生**负荷损失事件**：\n$$\\max(D_1(h) - C_1, -L) > \\min(C_2 - D_2(h), L)$$\n\n3.  **负荷损失期望 (LOLE) 计算**\n\nLOLE是每年出现缺电的期望小时数。对于单个小时状态 $h$，缺电概率 $\\text{LOLP}_h$ 是导致缺电的所有联合容量状态 $(C_1, C_2)$ 的概率之和：\n$$\\text{LOLP}_h = \\sum_{(C_1, C_2) \\text{ causing shortage}} \\text{Pr}(C_1) \\cdot \\text{Pr}(C_2)$$\n总的系统LOLE是所有小时状态下这些概率的加权和，其中权重 $w_h$ 是每个小时状态的持续时间：\n$$\\text{LOLE} = \\sum_{h} w_h \\cdot \\text{LOLP}_h$$\n\n计算LOLE的总体算法如下：\n- 对于给定的系统配置（每个区域的机组，接口极限 $L$）：\n  - 计算 $\\text{COPT}_1$ 和 $\\text{COPT}_2$。\n  - 初始化总 $\\text{LOLE} = 0$。\n  - 对于每个小时状态 $(D_1(h), D_2(h), w_h)$：\n    - 初始化小时状态缺电概率 $\\text{LOLP}_h = 0$。\n    - 对于 $\\text{COPT}_1$ 中的每个容量状态 $(C_1, \\text{Pr}(C_1))$：\n      - 对于 $\\text{COPT}_2$ 中的每个容量状态 $(C_2, \\text{Pr}(C_2))$：\n        - 如果 $\\max(D_1(h) - C_1, -L) > \\min(C_2 - D_2(h), L)$：\n          - $\\text{LOLP}_h = \\text{LOLP}_h + \\text{Pr}(C_1) \\cdot \\text{Pr}(C_2)$。\n    - 将 $w_h \\cdot \\text{LOLP}_h$ 加到总 $\\text{LOLE}$ 中。\n- 返回总 $\\text{LOLE}$。\n\n4.  **认证分数 ($\\alpha$) 计算**\n\n认证分数 $\\alpha$ 量化了在出口受限的区域 $2$ 增加一个新资源相对于在输入关键的区域 $1$ 增加该资源的可靠性价值。我们必须为每个测试用例计算三个LOLE值：\n- $\\text{LOLE}_{\\text{base}}$：初始定义的系统的LOLE。\n- $\\text{LOLE}_{\\text{Z1-add}}$：将候选资源 $(P_{\\text{add}}, q_{\\text{add}})$ 添加到区域 $1$ 后的LOLE。\n- $\\text{LOLE}_{\\text{Z2-add}}$：将候选资源 $(P_{\\text{add}}, q_{\\text{add}})$ 添加到区域 $2$ 后的LOLE。\n\n相应的LOLE降低量为：\n$$\\Delta\\text{LOLE}_1 = \\text{LOLE}_{\\text{base}} - \\text{LOLE}_{\\text{Z1-add}}$$\n$$\\Delta\\text{LOLE}_2 = \\text{LOLE}_{\\text{base}} - \\text{LOLE}_{\\text{Z2-add}}$$\n\n认证分数 $\\alpha$ 是这些降低量的比率：\n$$\\alpha = \\frac{\\Delta\\text{LOLE}_2}{\\Delta\\text{LOLE}_1}$$\n$\\alpha=1$ 的值意味着资源在任一区域都同样有效，就像在没有传输约束的系统中一样。$\\alpha  1$ 的值表示，由于资源被放置在出口受限区域，其有效性降低了，因为其剩余容量可能被“困住”而无法服务于另一区域的负荷。如果 $\\Delta\\text{LOLE}_1 = 0$，则只有当 $\\Delta\\text{LOLE}_2 = 0$ 时该比率才有明确定义，此时 $\\alpha=0$。在问题背景下，如果 $\\text{LOLE}_{\\text{base}} > 0$，向输入关键的区域 $1$ 增加容量预计会产生非零的LOLE降低。每个测试用例的最终结果是这个值 $\\alpha$，四舍五入到三位小数。",
            "answer": "```python\nimport numpy as np\nfrom collections import defaultdict\n\ndef get_copt(units):\n    \"\"\"\n    Computes the Capacity Outage Probability Table (COPT) for a set of generating units.\n    A unit is defined by a tuple (capacity, forced_outage_rate). This function calculates\n    the probability distribution of available capacity, not outage capacity.\n\n    Args:\n        units (list of tuples): A list of (P_i, q_i) for each unit in the zone.\n\n    Returns:\n        dict: A dictionary mapping available capacity levels to their probabilities.\n    \"\"\"\n    # Initialize COPT with a single state: 0 available capacity with probability 1.0\n    copt = {0.0: 1.0}\n    for p_i, q_i in units:\n        next_copt = defaultdict(float)\n        for capacity, prob in copt.items():\n            # Case 1: The current unit is unavailable (outage), probability q_i\n            # Available capacity remains the same.\n            next_copt[capacity] += prob * q_i\n            \n            # Case 2: The current unit is available, probability (1 - q_i)\n            # Available capacity increases by p_i.\n            next_copt[capacity + p_i] += prob * (1.0 - q_i)\n        copt = dict(next_copt)\n    return copt\n\ndef calculate_lole(units1, units2, L, hour_states):\n    \"\"\"\n    Calculates the system-wide Loss of Load Expectation (LOLE) in hours/year.\n\n    Args:\n        units1 (list): Units in Zone 1.\n        units2 (list): Units in Zone 2.\n        L (float): Bidirectional transfer limit in MW.\n        hour_states (list): Hourly load states as (D1, D2, weight_h).\n\n    Returns:\n        float: The total system LOLE in hours/year.\n    \"\"\"\n    copt1 = get_copt(units1)\n    copt2 = get_copt(units2)\n    \n    total_lole = 0.0\n    \n    for d1, d2, w_h in hour_states:\n        prob_shortage_h = 0.0\n        for c1, pr1 in copt1.items():\n            for c2, pr2 in copt2.items():\n                # A shortage occurs if no feasible transfer f exists.\n                # Feasibility condition: max(D1 - C1, -L) = min(C2 - D2, L)\n                # Shortage condition is the negation of feasibility.\n                if max(d1 - c1, -L) > min(c2 - d2, L):\n                    prob_shortage_h += pr1 * pr2\n        \n        total_lole += prob_shortage_h * w_h\n        \n    return total_lole\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and compute accreditation fractions.\n    \"\"\"\n    test_cases = [\n        {\n            \"units1\": [(200, 0.1), (150, 0.1)],\n            \"units2\": [(200, 0.1), (100, 0.1)],\n            \"L\": 150,\n            \"added_resource\": (100, 0.05),\n            \"hour_states\": [(250, 80, 7800), (350, 80, 800), (380, 90, 160)],\n        },\n        {\n            \"units1\": [(200, 0.1), (150, 0.1)],\n            \"units2\": [(200, 0.1), (100, 0.1)],\n            \"L\": 0,\n            \"added_resource\": (100, 0.05),\n            \"hour_states\": [(250, 60, 8000), (360, 60, 760)],\n        },\n        {\n            \"units1\": [(200, 0.1), (150, 0.1)],\n            \"units2\": [(200, 0.1), (100, 0.1)],\n            \"L\": 100,\n            \"added_resource\": (100, 0.05),\n            \"hour_states\": [(250, 120, 8300), (370, 120, 460)],\n        },\n        {\n            \"units1\": [(200, 0.1), (150, 0.1)],\n            \"units2\": [(200, 0.1), (100, 0.1)],\n            \"L\": 150,\n            \"added_resource\": (100, 0.05),\n            \"hour_states\": [(270, 180, 8500), (360, 210, 260)],\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        base_units1 = case[\"units1\"]\n        base_units2 = case[\"units2\"]\n        added_res = case[\"added_resource\"]\n        L_val = case[\"L\"]\n        states = case[\"hour_states\"]\n\n        # 1. Calculate LOLE for the base case\n        lole_base = calculate_lole(base_units1, base_units2, L_val, states)\n\n        # 2. Calculate LOLE with resource added to Zone 1\n        units1_plus = base_units1 + [added_res]\n        lole_z1_add = calculate_lole(units1_plus, base_units2, L_val, states)\n\n        # 3. Calculate LOLE with resource added to Zone 2\n        units2_plus = base_units2 + [added_res]\n        lole_z2_add = calculate_lole(base_units1, units2_plus, L_val, states)\n\n        # 4. Calculate LOLE reductions\n        delta_lole1 = lole_base - lole_z1_add\n        delta_lole2 = lole_base - lole_z2_add\n\n        # 5. Compute accreditation fraction alpha\n        if delta_lole1 == 0:\n            # If the reference improvement is zero, the ratio is ill-defined.\n            # If the improvement in Zone 2 is also zero, alpha is 0.\n            # Otherwise, the relative value is infinite, but this case is\n            # not expected in physically meaningful scenarios with non-zero base LOLE.\n            alpha = 0.0 if delta_lole2 == 0.0 else float('inf')\n        else:\n            alpha = delta_lole2 / delta_lole1\n            \n        results.append(f\"{alpha:.3f}\")\n\n    print(f\"[{','.join(results)}]\")\n\n# Execute the solver\nsolve()\n\n```"
        }
    ]
}