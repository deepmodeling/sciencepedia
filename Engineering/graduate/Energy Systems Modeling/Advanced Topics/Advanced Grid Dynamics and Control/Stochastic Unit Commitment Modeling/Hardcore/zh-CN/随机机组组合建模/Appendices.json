{
    "hands_on_practices": [
        {
            "introduction": "在深入研究随机规划的复杂公式之前，理解其根本价值至关重要。本练习旨在通过计算“随机解的价值”（Value of the Stochastic Solution, VSS），量化随机机组组合（SUC）模型相对于简化确定性模型的优势。通过解决这个问题，您将亲身体会到，在不确定的需求下面对高昂的决策失误成本时，随机规划为何是不可或缺的工具。",
            "id": "4104477",
            "problem": "在不确定的净负荷实现之前，需要确定发电机组的启停状态，由此产生了“两阶段随机机组组合决策问题”。其基本原理是在不确定性下最小化期望成本和进行线性经济调度，这两者在能源系统建模中都得到了广泛认可。在第一阶段，运营商决定火电机组的启停状态；在第二阶段，当需求场景实现后，运营商调度已启机的机组以满足需求，可能会因未满足的负荷而产生惩罚。所有成本均以美元为单位。通过假设每个时段的持续时间为 $1$ 小时，功率和能量的计量单位保持一致，因此在一个时段内，兆瓦（MW）在数值上等于兆瓦时（MWh）。\n\n考虑一个包含 $2$ 台火电机组（索引为 $i \\in \\{1,2\\}$）和单个持续时间为 $1$ 小时的时间周期的简易系统。每个机组 $i$ 的特性如下：\n- 最大容量 $P^{\\max}_i$（单位：MW），\n- 线性可变生产成本 $c_i$（单位：美元/MWh），\n- 启动成本 $C^{\\mathrm{su}}_i$（单位：美元），\n- 空载成本 $C^{\\mathrm{nl}}_i$（单位：美元/时段，当机组启机时）。\n\n第一阶段决策是在不确定性实现之前做出的，即每个机组的二元启停决策 $u_i \\in \\{0,1\\}$。对于每个场景 $s$，第二阶段决策是发电水平 $g_{i,s} \\ge 0$ 和未服务能量 $l_s \\ge 0$（切负荷），其中未服务能量的惩罚为每兆瓦时 $M$ 美元。场景需求 $D_s$ 的单位是 MWh，场景概率 $p_s$ 满足 $\\sum_s p_s = 1$ 且 $p_s \\ge 0$。\n\n对于每个场景 $s$，调度必须满足：\n$$\n\\sum_{i=1}^2 g_{i,s} + l_s = D_s, \\quad 0 \\le g_{i,s} \\le P^{\\max}_i u_i,\n$$\n每个场景的第二阶段成本为：\n$$\n\\sum_{i=1}^2 c_i g_{i,s} + M l_s.\n$$\n第一阶段成本为：\n$$\n\\sum_{i=1}^2 \\left(C^{\\mathrm{su}}_i u_i + C^{\\mathrm{nl}}_i u_i\\right).\n$$\n\n随机机组组合（SUC）问题旨在在所有可行的启停组合中，最小化第一阶段成本与期望的第二阶段成本之和。确定性期望值（EV）问题用期望需求\n$$\n\\bar{D} = \\sum_s p_s D_s,\n$$\n替代随机需求，并在满足已启机组容量约束且不发生切负荷的前提下，最小化为满足需求 $\\bar{D}$ 所需的第一阶段成本与第二阶段可变成本之和。\n\n一旦找到 EV 决策的启停组合，就需要计算在随机场景下评估这个固定启停组合的期望成本（在追索阶段允许切负荷）；这被称为评估期望值（EEV）。需要计算的量是，与最优 SUC 启停组合相比，使用 EV 启停组合所导致的期望成本增加量，对每个测试用例均以美元表示。程序必须：\n- 枚举第一阶段的启停组合。\n- 对于 SUC，计算所有启停组合下的最优期望成本。\n- 对于 EV，选择能够精确满足 $\\bar{D}$ 且使确定性成本最小的启停组合，然后计算其在随机场景下的期望成本。\n- 对于每个测试用例，输出 EEV 成本与 SUC 最优期望成本之间的差额，以美元为单位。\n\n机组数据（所有测试用例通用）：\n- 机组 1：$P^{\\max}_1 = 100$ MW， $c_1 = 20$ 美元/MWh， $C^{\\mathrm{su}}_1 = 1000$ 美元， $C^{\\mathrm{nl}}_1 = 500$ 美元。\n- 机组 2：$P^{\\max}_2 = 50$ MW， $c_2 = 25$ 美元/MWh， $C^{\\mathrm{su}}_2 = 100$ 美元， $C^{\\mathrm{nl}}_2 = 0$ 美元。\n\n测试套件的场景集和惩罚值：\n- 用例 1（一般情况）：\n  - 场景：$D_1 = 40$ MWh，概率 $p_1 = 0.6$；$D_2 = 120$ MWh，概率 $p_2 = 0.4$。\n  - 惩罚：$M = 200$ 美元/MWh。\n- 用例 2（确定性期望值启停组合与随机最优解重合的边界情况）：\n  - 场景：$D_1 = 40$ MWh，概率 $p_1 = 0.95$；$D_2 = 120$ MWh，概率 $p_2 = 0.05$。\n  - 惩罚：$M = 200$ 美元/MWh。\n- 用例 3（未服务能量惩罚较低的边缘情况）：\n  - 场景：$D_1 = 40$ MWh，概率 $p_1 = 0.6$；$D_2 = 120$ MWh，概率 $p_2 = 0.4$。\n  - 惩罚：$M = 30$ 美元/MWh。\n\n假设：\n- 每个时段持续 1 小时，因此在该时段内 1 MW 等于 1 MWh。\n- 所有机组的初始启停状态均为关闭，因此当机组启机时，会产生启动成本。\n- 最小发电量为 0 MWh，且无爬坡约束。\n\n您的程序应生成单行输出，其中包含一个方括号内的逗号分隔列表，例如 $[r_1,r_2,r_3]$，其中 $r_k$ 是用例 $k$ 的评估期望值成本与最优随机机组组合成本之间的计算差额，以美元为单位的浮点数表示。",
            "solution": "### 问题验证\n\n**步骤1：提取给定信息**\n\n- **系统参数**：$2$ 台火电机组（$i \\in \\{1,2\\}$），$1$ 个持续时间为 $1$ 小时的时间周期。\n- **机组1数据**：$P^{\\max}_1 = 100$ MW， $c_1 = 20$ 美元/MWh， $C^{\\mathrm{su}}_1 = 1000$ 美元， $C^{\\mathrm{nl}}_1 = 500$ 美元。\n- **机组2数据**：$P^{\\max}_2 = 50$ MW， $c_2 = 25$ 美元/MWh， $C^{\\mathrm{su}}_2 = 100$ 美元， $C^{\\mathrm{nl}}_2 = 0$ 美元。\n- **第一阶段决策**：每个机组 $i$ 的二元启停变量 $u_i \\in \\{0,1\\}$。\n- **第二阶段决策**：每个场景 $s$ 的发电水平 $g_{i,s} \\ge 0$ 和未服务能量 $l_s \\ge 0$。\n- **惩罚成本**：未服务能量的惩罚为每兆瓦时 $M$ 美元。\n- **场景数据**：场景由需求 $D_s$ (MWh) 和概率 $p_s$ 定义。\n- **模型方程**：\n    - 第一阶段成本：$\\sum_{i=1}^2 (C^{\\mathrm{su}}_i + C^{\\mathrm{nl}}_i) u_i$。\n    - 每个场景 $s$ 的第二阶段约束：$\\sum_{i=1}^2 g_{i,s} + l_s = D_s$ 和 $0 \\le g_{i,s} \\le P^{\\max}_i u_i$。\n    - 每个场景 $s$ 的第二阶段成本：$\\sum_{i=1}^2 c_i g_{i,s} + M l_s$。\n- **问题定义**：\n    - **随机机组组合 (SUC)**：在所有可行的启停组合中，最小化第一阶段成本与期望的第二阶段成本之和。\n    - **确定性期望值 (EV)**：用期望需求 $\\bar{D} = \\sum_s p_s D_s$ 替代随机需求 $D_s$。在满足需求恰好被满足（无切负荷）的条件下，最小化总成本。\n    - **评估期望值 (EEV)**：使用通过求解EV问题得到的固定启停组合，在随机场景下产生的期望成本。\n- **目标**：计算 EEV 成本与最优 SUC 成本之间的差额（以美元为单位）。\n- **测试用例**：\n    - **用例 1**：场景：$D_1 = 40$ MWh, $p_1 = 0.6$；$D_2 = 120$ MWh, $p_2 = 0.4$。惩罚：$M = 200$ 美元/MWh。\n    - **用例 2**：场景：$D_1 = 40$ MWh, $p_1 = 0.95$；$D_2 = 120$ MWh, $p_2 = 0.05$。惩罚：$M = 200$ 美元/MWh。\n    - **用例 3**：场景：$D_1 = 40$ MWh, $p_1 = 0.6$；$D_2 = 120$ MWh, $p_2 = 0.4$。惩罚：$M = 30$ 美元/MWh。\n- **假设**：时段持续时间为 1 小时（1 MW = 1 MWh），所有机组初始状态为停机，最小发电量为 0 MWh，无爬坡约束。\n\n**步骤2：使用提取的给定信息进行验证**\n\n依据验证标准对问题进行评估：\n- **科学依据**：该问题是将两阶段随机整数规划应用于电力系统机组组合问题的经典案例，这是能源系统建模和运筹学中一个标准且完善的课题。所有概念（经济调度、随机优化、期望值解）都具有科学合理性。\n- **良态性**：问题是良态的。第一阶段启停决策的决策空间是有限的（$2^2 = 4$ 种可能性）。对于每种启停组合，第二阶段子问题（经济调度）是一个线性规划问题，有唯一且稳定的解。目标函数和约束条件定义清晰，确保了所需值有单一且有意义的解。\n- **客观性**：问题以精确、客观、形式化的数学语言陈述。所有术语都是该领域的标准术语。\n- **完整性与一致性**：为每个用例提供了机组、场景和成本的所有必要数据。假设澄清了任何潜在的歧义（例如，初始状态、最小发电量）。不存在内部矛盾。\n- **现实性**：参数描述的是一个“简易”系统，但在该背景下，它们是物理上一致且合理的。\n\n**步骤3：结论与行动**\n\n问题陈述是**有效的**。它内容完备、有科学依据、定义明确，并且其所有组成部分都定义清晰且一致。可以继续进行求解过程。\n\n### 基于原则的设计与求解\n\n核心任务是计算随机解的价值（VSS），它衡量了使用随机优化模型相对于更简单的确定性模型所带来的收益。在这里，它被定义为在随机环境中使用确定性（EV）解所带来的成本增加，即 $VSS = C_{EEV} - C_{SUC}^*$。求解过程通过枚举该双机组系统的所有可能的第一阶段决策来进行。\n\n**1. 第一阶段决策空间**\n对于两台机组，有四种可能的启停决策 $(u_1, u_2)$：$(0,0)$、$(0,1)$、$(1,0)$ 和 $(1,1)$。我们将评估与每种决策相关的成本。\n\n**2. 第二阶段经济调度**\n对于任意给定的启停组合 $(u_1, u_2)$ 和需求场景 $D_s$，第二阶段问题是一个经济调度问题。目标是以最小的可变成本满足需求。这通过“经济次序法”（merit-order loading principle）来解决：首先调度已启机组中可变成本最低的机组，然后是次便宜的机组，以此类推。如果总启机容量不足以满足需求，则通过“切负荷”（未服务能量 $l_s$）来弥补缺口，但这会产生高昂的惩罚成本 $M$。\n机组数据显示 $c_1 = 20  c_2 = 25$。因此，机组1总是在机组2之前被调度。\n\n**3. 随机机组组合 (SUC) 求解**\nSUC 问题旨在找到最小化总期望成本的启停组合 $(u_1, u_2)$。给定启停组合的总期望成本是其固定的第一阶段成本与期望的第二阶段调度成本之和。\n- 第一阶段成本：$C_1(u_1, u_2) = (C^{\\mathrm{su}}_1 + C^{\\mathrm{nl}}_1)u_1 + (C^{\\mathrm{su}}_2 + C^{\\mathrm{nl}}_2)u_2$。\n- 期望第二阶段成本：$E[C_2(u_1, u_2)] = \\sum_s p_s \\left( \\sum_{i=1}^2 c_i g_{i,s} + M l_s \\right)$，其中 $g_{i,s}$ 和 $l_s$ 是场景 $s$ 的经济调度子问题的最优解。\n- 总期望成本：$C_{total}(u_1, u_2) = C_1(u_1, u_2) + E[C_2(u_1, u_2)]$。\n\n通过为所有四个启停选项计算 $C_{total}$，我们可以找到最优 SUC 成本 $C_{SUC}^* = \\min_{(u_1, u_2)} C_{total}(u_1, u_2)$，以及相应的最优启停组合 $(u_1^*, u_2^*)_{SUC}$。\n\n**4. 期望值 (EV) 求解与评估期望值 (EEV)**\nEV 问题是一个确定性的简化问题，其中不确定的需求 $D_s$被其期望值 $\\bar{D} = \\sum_s p_s D_s$ 所取代。问题是找到最小化服务于 $\\bar{D}$ 的确定性成本的启停组合 $(u_1, u_2)$，并满足总启机容量必须充足的约束，即 $\\sum_i P_i^{\\max} u_i \\ge \\bar{D}$。\n- 确定性成本：$C_{EV}(u_1, u_2) = C_1(u_1, u_2) + (\\text{为}\\bar{D}\\text{的调度成本})$。\n最优 EV 启停组合 $(u_1, u_2)_{EV}$ 是在所有可行启停组合中使 $C_{EV}$ 最小化的那一个。\n\n评估期望值（EEV）是在原始随机环境中使用这个固定的 EV 启停组合 $(u_1, u_2)_{EV}$ 的总期望成本。其计算方式为：\n$C_{EEV} = C_{total}((u_1, u_2)_{EV})$。\n\n**5. 最终计算**\n每个用例的最终结果是差值 $C_{EEV} - C_{SUC}^*$。\n\n**用例 1 的计算 ($D_1=40, p_1=0.6; D_2=120, p_2=0.4; M=200$):**\n- **SUC:** 通过枚举四种启停组合，我们发现最小总期望成本为 $3080$ 美元，对应于启停组合 $(u_1, u_2) = (1,1)$。\n- **EV:** 期望需求 $\\bar{D} = 0.6(40) + 0.4(120) = 72$ MW。服务于 72 MW 的最优 EV 启停组合是 $(1,0)$，其确定性成本为 $2940$ 美元。\n- **EEV:** 在随机环境下，EV 启停组合 $(1,0)$ 的总期望成本为 $C_{EEV} = C_{total}(1,0) = 4380$ 美元。\n- **结果:** $C_{EEV} - C_{SUC}^* = 4380 - 3080 = 1300$ 美元。\n\n**用例 2 的计算 ($D_1=40, p_1=0.95; D_2=120, p_2=0.05; M=200$):**\n- **SUC:** 最小总期望成本为 $1812.50$ 美元，对应于启停组合 $(u_1, u_2) = (0,1)$。\n- **EV:** 期望需求 $\\bar{D} = 0.95(40) + 0.05(120) = 44$ MW。服务于 44 MW 的最优 EV 启停组合是 $(0,1)$。\n- **EEV:** 由于 EV 启停组合 $(0,1)$ 与 SUC 最优启停组合相同，所以 $C_{EEV} = C_{SUC}^* = 1812.50$ 美元。\n- **结果:** $C_{EEV} - C_{SUC}^* = 1812.50 - 1812.50 = 0$ 美元。\n\n**用例 3 的计算 ($D_1=40, p_1=0.6; D_2=120, p_2=0.4; M=30$):**\n- **SUC:** 在较低的惩罚下，最小总期望成本为 $2040$ 美元，对应于启停组合 $(u_1, u_2) = (0,1)$。\n- **EV:** 期望需求为 $\\bar{D} = 72$ MW，与用例1相同。EV 问题独立于 $M$，因此最优 EV 启停组合仍为 $(1,0)$。\n- **EEV:** 在 $M=30$ 的条件下，EV 启停组合 $(1,0)$ 的总期望成本为 $C_{EEV} = C_{total}(1,0) = 3020$ 美元。\n- **结果:** $C_{EEV} - C_{SUC}^* = 3020 - 2040 = 980$ 美元。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the two-stage stochastic unit commitment problem for three test cases.\n    \"\"\"\n\n    # Unit data (common to all test cases)\n    # Units are pre-sorted by variable cost c_i\n    units = [\n        {'id': 1, 'P_max': 100.0, 'c': 20.0, 'C_su': 1000.0, 'C_nl': 500.0},\n        {'id': 2, 'P_max': 50.0, 'c': 25.0, 'C_su': 100.0, 'C_nl': 0.0}\n    ]\n\n    # Test cases\n    test_cases = [\n        {\n            \"scenarios\": [(40.0, 0.6), (120.0, 0.4)],  # (Demand, Probability)\n            \"penalty\": 200.0\n        },\n        {\n            \"scenarios\": [(40.0, 0.95), (120.0, 0.05)],\n            \"penalty\": 200.0\n        },\n        {\n            \"scenarios\": [(40.0, 0.6), (120.0, 0.4)],\n            \"penalty\": 30.0\n        }\n    ]\n\n    # Possible first-stage commitment decisions (u1, u2)\n    commitments = [(0, 0), (0, 1), (1, 0), (1, 1)]\n\n    results = []\n\n    def economic_dispatch(demand, commitment, units_data, penalty_cost):\n        \"\"\"\n        Calculates the minimum dispatch cost for a given demand and commitment.\n        \"\"\"\n        dispatch_cost = 0.0\n        remaining_demand = float(demand)\n\n        # Dispatch units in merit order (pre-sorted by cost)\n        for i, unit_spec in enumerate(units_data):\n            if commitment[i] == 1:\n                dispatch = min(remaining_demand, unit_spec['P_max'])\n                dispatch_cost += dispatch * unit_spec['c']\n                remaining_demand -= dispatch\n\n        # Add penalty for non-served energy (load shedding)\n        if remaining_demand > 1e-6: # Use a small tolerance for float comparison\n            dispatch_cost += remaining_demand * penalty_cost\n        \n        return dispatch_cost\n\n    for case in test_cases:\n        scenarios = case[\"scenarios\"]\n        penalty = case[\"penalty\"]\n\n        # --- 1. SUC (Stochastic Unit Commitment) Solution ---\n        # Calculate the total expected cost for every possible commitment\n        stochastic_costs = {}\n        for u in commitments:\n            # First-stage cost (startup + no-load)\n            first_stage_cost = sum(\n                (unit['C_su'] + unit['C_nl']) * u[i]\n                for i, unit in enumerate(units)\n            )\n\n            # Expected second-stage cost\n            scenario_costs = np.array([\n                economic_dispatch(demand, u, units, penalty)\n                for demand, prob in scenarios\n            ])\n            probabilities = np.array([prob for demand, prob in scenarios])\n            expected_second_stage_cost = np.dot(probabilities, scenario_costs)\n            \n            total_expected_cost = first_stage_cost + expected_second_stage_cost\n            stochastic_costs[u] = total_expected_cost\n        \n        # The optimal SUC cost is the minimum over all commitments\n        suc_optimal_cost = min(stochastic_costs.values())\n        \n        # --- 2. EV (Expected Value) Solution ---\n        # Calculate expected demand\n        expected_demand = sum(prob * demand for demand, prob in scenarios)\n\n        # Find the optimal commitment for the deterministic EV problem\n        ev_candidates = []\n        for u in commitments:\n            total_capacity = sum(\n                unit['P_max'] * u[i] for i, unit in enumerate(units)\n            )\n            # Commitment must be feasible (capacity >= expected demand)\n            if total_capacity >= expected_demand:\n                first_stage_cost = sum(\n                    (unit['C_su'] + unit['C_nl']) * u[i]\n                    for i, unit in enumerate(units)\n                )\n                # Dispatch cost for expected demand (no shedding allowed, penalty is effectively infinite)\n                dispatch_cost_ev = economic_dispatch(expected_demand, u, units, float('inf'))\n                \n                deterministic_cost = first_stage_cost + dispatch_cost_ev\n                ev_candidates.append((deterministic_cost, u))\n        \n        # The EV commitment is the one with the minimum deterministic cost\n        if not ev_candidates: # Should not happen in these test cases\n             # Handle case where no commitment is feasible for expected demand\n             # This would imply a flawed problem setup, but we'll be robust.\n             # E.g., select the highest capacity commitment\n             max_cap = -1\n             u_ev = (0,0)\n             for u in commitments:\n                 cap = sum(unit['P_max'] * u[i] for i, unit in enumerate(units))\n                 if cap > max_cap:\n                     max_cap = cap\n                     u_ev = u\n        else:\n             _, u_ev = min(ev_candidates, key=lambda x: x[0])\n\n        \n        # --- 3. EEV (Evaluated Expected Value) Cost ---\n        # The EEV is the stochastic cost of the commitment chosen by the EV problem\n        eev_cost = stochastic_costs[u_ev]\n        \n        # --- 4. Final Calculation ---\n        # Value of the Stochastic Solution (VSS) / Cost difference\n        result = eev_cost - suc_optimal_cost\n        results.append(result)\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, [round(r, 4) for r in results]))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "掌握了随机规划的价值之后，下一步是亲手构建一个模型。本练习将指导您为一个简化的两阶段电力系统构建并求解一个随机机组组合（SUC）问题。您将实践如何将第一阶段“此时此地”的机组启停决策与第二阶段“观望等待”的发电调度决策相结合，从而在多个未来场景下找到期望成本最低的鲁棒决策方案。",
            "id": "4104492",
            "problem": "考虑一个两阶段随机机组组合 (SUC) 问题，包含两台火力发电机组和两个在第二阶段开始时揭晓的需求情景。随机机组组合 (SUC) 被建模为一个混合整数线性规划 (MILP) 问题，其中二元开机变量表示发电机组的启停状态，连续调度变量表示功率输出。推导的基本依据包括功率平衡定律（每个时段的总发电量等于需求量）、线性发电成本函数（燃料成本与产出能量成正比）、从关机到开机的启动成本，以及随机优化的期望值原理。所有时间间隔的长度均为 $1$ 小时，因此以兆瓦时 (MWh) 为单位的能量等于以兆瓦 (MW) 为单位的功率。\n\n集合与数据：\n- 发电机组 $\\mathcal{G}=\\{1,2\\}$。\n- 时间段 $\\mathcal{T}=\\{1,2\\}$。\n- 情景 $\\mathcal{S}=\\{A,B\\}$，其概率 $\\pi_A$ 和 $\\pi_B$ 满足 $\\pi_A+\\pi_B=1$。\n- 对于每台发电机 $g\\in\\mathcal{G}$：最小出力 $\\underline{P}_g$（单位 $\\mathrm{MW}$），最大出力 $\\overline{P}_g$（单位 $\\mathrm{MW}$），线性可变成本 $c_g$（单位 $\\$/\\mathrm{MWh}$），以及启动成本 $h_g$（单位 $\\$$）。初始状态为 $y_{g,0}=0$（关机）。\n- 时段 $1$ 的需求 $D_{1}$（单位 $\\mathrm{MW}$，所有情景通用），以及情景 $s\\in\\mathcal{S}$ 中时段 $2$ 的需求 $D_{2,s}$（单位 $\\mathrm{MW}$）。\n\n决策变量：\n- 第一阶段（情景揭晓前）：二元开机变量 $y_{g,1}\\in\\{0,1\\}$ 和连续调度变量 $p_{g,1}\\ge 0$；启动二元变量 $v_{g,1}\\in\\{0,1\\}$。\n- 第二阶段（情景揭晓后）：对于每个情景 $s\\in\\mathcal{S}$，二元开机变量 $y_{g,2,s}\\in\\{0,1\\}$ 和连续调度变量 $p_{g,2,s}\\ge 0$；启动二元变量 $v_{g,2,s}\\in\\{0,1\\}$。\n\n确定性等价MILP推导：\n期望总成本目标为\n$$\n\\min \\left\\{\\sum_{g\\in\\mathcal{G}} \\left(h_g v_{g,1} + c_g p_{g,1}\\right) + \\sum_{s\\in\\mathcal{S}} \\pi_s \\sum_{g\\in\\mathcal{G}} \\left(h_g v_{g,2,s} + c_g p_{g,2,s}\\right)\\right\\}.\n$$\n物理和逻辑约束：\n- 时段 $1$ 的功率平衡：\n$$\n\\sum_{g\\in\\mathcal{G}} p_{g,1} = D_1.\n$$\n- 时段 $2$，情景 $s$ 的功率平衡：\n$$\n\\sum_{g\\in\\mathcal{G}} p_{g,2,s} = D_{2,s},\\quad \\forall s\\in\\mathcal{S}.\n$$\n- 时段 $1$ 的容量与开机状态关联：\n$$\n\\underline{P}_g\\, y_{g,1} \\le p_{g,1} \\le \\overline{P}_g\\, y_{g,1},\\quad \\forall g\\in\\mathcal{G}.\n$$\n- 时段 $2$ 的容量与开机状态关联：\n$$\n\\underline{P}_g\\, y_{g,2,s} \\le p_{g,2,s} \\le \\overline{P}_g\\, y_{g,2,s},\\quad \\forall g\\in\\mathcal{G},\\ \\forall s\\in\\mathcal{S}.\n$$\n- 时段 $1$ 的启动逻辑：\n$$\nv_{g,1} \\ge y_{g,1} - y_{g,0},\\quad v_{g,1}\\in\\{0,1\\},\\quad y_{g,1}\\in\\{0,1\\},\\quad \\forall g\\in\\mathcal{G}.\n$$\n- 时段 $2$ 的启动逻辑：\n$$\nv_{g,2,s} \\ge y_{g,2,s} - y_{g,1},\\quad v_{g,2,s}\\in\\{0,1\\},\\quad y_{g,2,s}\\in\\{0,1\\},\\quad \\forall g\\in\\mathcal{G},\\ \\forall s\\in\\mathcal{S}.\n$$\n- 对第一阶段变量的非预期性约束：\n由于时段 $1$ 在情景揭晓之前，第一阶段的变量在所有情景中必须相同。在确定性等价形式中，这通过将 $y_{g,1}$ 和 $p_{g,1}$ 建模为不带情景索引的变量，或者在使用情景索引时通过显式等式来强制实现：\n$$\ny_{g,1,A} = y_{g,1,B},\\quad p_{g,1,A} = p_{g,1,B},\\quad \\forall g\\in\\mathcal{G},\n$$\n我们通过使用上述与情景无关的 $y_{g,1}$ 和 $p_{g,1}$ 来实现这一点。\n\n您必须为以下每个测试用例计算最优期望总成本（单位 $\\$$）和最优的第一阶段开机决策 $y_{1,1}$ 和 $y_{2,1}$。最终成本以 $\\$$ 为单位，四舍五入到两位小数。开机决策必须报告为整数 $0$ 或 $1$。使用以下发电机数据：\n- 机组 $1$：$\\underline{P}_1=10$ $\\mathrm{MW}$，$\\overline{P}_1=50$ $\\mathrm{MW}$，$c_1=20$ $\\$/\\mathrm{MWh}$，$h_1=100$ $\\$$。\n- 机组 $2$：$\\underline{P}_2=5$ $\\mathrm{MW}$，$\\overline{P}_2=30$ $\\mathrm{MW}$，$c_2=30$ $\\$/\\mathrm{MWh}$，$h_2=50$ $\\$$。\n- 初始状态：$y_{1,0}=0$，$y_{2,0}=0$。\n\n测试套件：\n- 案例 $1$（一般情况）：$D_1=40$ $\\mathrm{MW}$，$D_{2,A}=60$ $\\mathrm{MW}$，$D_{2,B}=35$ $\\mathrm{MW}$，$\\pi_A=0.4$，$\\pi_B=0.6$。\n- 案例 $2$（接近最小出力的边界可行性）：$D_1=15$ $\\mathrm{MW}$，$D_{2,A}=15$ $\\mathrm{MW}$，$D_{2,B}=15$ $\\mathrm{MW}$，$\\pi_A=0.5$，$\\pi_B=0.5$。\n- 案例 $3$（高需求后接低需求的边缘情况）：$D_1=55$ $\\mathrm{MW}$，$D_{2,A}=80$ $\\mathrm{MW}$，$D_{2,B}=10$ $\\mathrm{MW}$，$\\pi_A=0.8$，$\\pi_B=0.2$。\n\n输出规格：\n您的程序应生成单行输出，其中包含一个由方括号括起来的列表的列表，以逗号分隔。每个内部列表的形式必须是 $[E^\\star, y_{1,1}^\\star, y_{2,1}^\\star]$，其中 $E^\\star$ 是最优期望总成本（单位 $\\$$，四舍五入到两位小数），$y_{1,1}^\\star$ 和 $y_{2,1}^\\star$ 是机组 $1$ 和 $2$ 的最优第一阶段开机决策。例如，输出可能看起来像 $[[1234.56,1,0],[\\dots]]$。",
            "solution": "用户提供了一个定义明确的两阶段随机机组组合（SUC）问题，该问题被建模为混合整数线性规划（MILP）。该问题具有科学依据，内容自洽，并且提供了求解所需的所有数据。这是电力系统优化中的一个典型问题。因此，该问题被认定为有效。\n\n目标是找到最小期望总成本以及对应的最优第一阶段开机决策 $(y_{1,1}^\\star, y_{2,1}^\\star)$。总成本包括第一阶段的启动和发电成本，加上在两个情景 $A$ 和 $B$ 下的第二阶段启动和发电成本的期望值。\n\n鉴于问题的规模较小——只有两台发电机组和第一阶段的二元开机决策——最直接透明的求解方法是对所有可能的第一阶段开机策略进行结构化枚举。对于 $(y_{1,1}, y_{2,1})$，存在 $2^2=4$ 种这样的策略：$(0,0)$、$(0,1)$、$(1,0)$ 和 $(1,1)$。对于每种策略，我们可以计算其总期望成本。最优策略是产生最低总期望成本的那个。\n\n评估单个第一阶段开机策略 $(y_{1,1}, y_{2,1})$ 的过程如下：\n\n**1. 第一阶段分析**\n首先，我们评估第一个时间段 $t=1$ 的成本和可行性。\n- **可行性检查：** 所选的开机组合必须能够满足需求 $D_1$。也就是说，已开机机组的最小出力总和不得超过需求，而最大出力总和必须至少等于需求：\n$$\n\\sum_{g \\in \\mathcal{G}} \\underline{P}_g y_{g,1} \\le D_1 \\le \\sum_{g \\in \\mathcal{G}} \\overline{P}_g y_{g,1}\n$$\n如果不满足此条件，则该开机策略不可行，其成本被视为无穷大。\n- **经济调度：** 如果可行，则通过经济调度确定功率输出 $p_{g,1}$，以最低的发电成本满足 $D_1$。由于可变成本 $c_g$ 是线性的，这涉及到在遵守最小和最大出力限制 $\\underline{P}_g$ 和 $\\overline{P}_g$ 的同时，先加载成本较低的机组（机组1，成本为 $c_1=20$ $\\$/\\mathrm{MWh}$），再加载成本较高的机组（机组2，成本为 $c_2=30$ $\\$/\\mathrm{MWh}$）。\n- **第一阶段成本 ($C_1$)：** 时段 $1$ 的成本是启动成本和发电成本之和。由于两台机组都从关机状态（$y_{g,0}=0$）开始，启动变量 $v_{g,1}$ 等于 $y_{g,1}$。成本为：\n$$\nC_1(y_{1,1}, y_{2,1}) = \\sum_{g \\in \\mathcal{G}} (h_g y_{g,1} + c_g p_{g,1})\n$$\n\n**2. 第二阶段分析（追索）**\n接下来，对于给定的第一阶段开机决策 $(y_{1,1}, y_{2,1})$，我们必须为每个情景 $s \\in \\{A, B\\}$ 确定第二阶段的最优决策并计算期望成本。第二阶段的决策是在不确定性（需求 $D_{2,s}$）揭晓后采取的“追索”行动。\n\n对于每个情景 $s \\in \\{A, B\\}$：\n- **最优第二阶段开机决策：** 我们必须找到成本最低的开机决策 $(y_{1,2,s}, y_{2,2,s})$ 以满足特定情景的需求 $D_{2,s}$。这涉及到评估所有 $4$ 种可能的第二阶段开机组合。对于每种选择：\n    - 我们根据 $D_{2,s}$ 检查可行性。\n    - 如果可行，我们计算启动成本。启动变量 $v_{g,2,s}$ 由从第一阶段状态 $y_{g,1}$ 的转变决定：$v_{g,2,s} = \\max(0, y_{g,2,s} - y_{g,1})$。该情景的启动成本为 $\\sum_{g \\in \\mathcal{G}} h_g v_{g,2,s}$。\n    - 我们执行经济调度以找到发电水平 $p_{g,2,s}$ 和相关的最低发电成本 $\\sum_{g \\in \\mathcal{G}} c_g p_{g,2,s}$。\n    - 该开机选择的第二阶段总成本是其启动成本和发电成本之和。\n- **最小情景成本 ($C_{2,s}^\\star$)：** 通过比较可行的第二阶段开机选项的总成本，我们找到情景 $s$ 的最小可能成本，记为 $C^\\star_{2,s}$。\n- **期望第二阶段成本 ($E[C_2]$)：** 第二阶段的期望成本是每个情景最小成本的概率加权平均值：\n$$\nE[C_2] = \\pi_A C^\\star_{2,A} + \\pi_B C^\\star_{2,B}\n$$\n\n**3. 总期望成本与优化**\n初始第一阶段策略 $(y_{1,1}, y_{2,1})$ 的总期望成本是第一阶段成本和期望第二阶段成本之和：\n$$\nE[C_{\\text{total}}] = C_1 + E[C_2]\n$$\n对所有四种初始第一阶段开机策略重复此计算。最优策略 $(y_{1,1}^\\star, y_{2,1}^\\star)$ 是产生最小 $E[C_{\\text{total}}]$ 的策略，而这个最小值就是最优期望总成本 $E^\\star$。\n\n使用的发电机数据为：\n- 机组 1：$\\underline{P}_1=10$ $\\mathrm{MW}$，$\\overline{P}_1=50$ $\\mathrm{MW}$，$c_1=20$ $\\$/\\mathrm{MWh}$，$h_1=100$ $\\$$。\n- 机组 2：$\\underline{P}_2=5$ $\\mathrm{MW}$，$\\overline{P}_2=30$ $\\mathrm{MW}$，$c_2=30$ $\\$/\\mathrm{MWh}$，$h_2=50$ $\\$$。\n- 初始状态：$y_{1,0}=0$，$y_{2,0}=0$。\n\n通过将这种系统性枚举和成本计算方法应用于三个测试用例中的每一个，我们得出最优的第一阶段决策和相应的最小期望成本。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the two-period stochastic unit commitment problem for the given test cases.\n    \"\"\"\n    \n    # Generator data\n    generators = [\n        {'id': 1, 'P_min': 10, 'P_max': 50, 'cost': 20, 'startup': 100, 'y0': 0},\n        {'id': 2, 'P_min': 5, 'P_max': 30, 'cost': 30, 'startup': 50, 'y0': 0}\n    ]\n    # Sort generators by cost for economic dispatch, cheaper first.\n    # We create a mapping to their original indices.\n    sorted_gen_indices = sorted(range(len(generators)), key=lambda k: generators[k]['cost'])\n\n    # Test suite\n    test_cases = [\n        {'D1': 40, 'D2A': 60, 'D2B': 35, 'pi_A': 0.4, 'pi_B': 0.6},\n        {'D1': 15, 'D2A': 15, 'D2B': 15, 'pi_A': 0.5, 'pi_B': 0.5},\n        {'D1': 55, 'D2A': 80, 'D2B': 10, 'pi_A': 0.8, 'pi_B': 0.2}\n    ]\n\n    def economic_dispatch(demand, commitment_status):\n        \"\"\"\n        Calculates the minimum generation cost and dispatch levels for a given demand and set of\n        committed units.\n        \n        Args:\n            demand (float): The load to be met.\n            commitment_status (tuple): A tuple of binary values (0 or 1) indicating which\n                                       generators are committed.\n\n        Returns:\n            tuple: (generation_cost, dispatch_levels) or (inf, None) if infeasible.\n        \"\"\"\n        p_min_total = sum(gen['P_min'] for i, gen in enumerate(generators) if commitment_status[i])\n        p_max_total = sum(gen['P_max'] for i, gen in enumerate(generators) if commitment_status[i])\n\n        if not (p_min_total = demand = p_max_total):\n            return float('inf'), None\n\n        dispatch = np.zeros(len(generators))\n        gen_cost = 0.0\n        \n        # Load all committed units to their minimum output\n        for i, gen in enumerate(generators):\n            if commitment_status[i]:\n                dispatch[i] = gen['P_min']\n                gen_cost += gen['cost'] * gen['P_min']\n\n        remaining_demand = demand - p_min_total\n\n        # Load incrementally based on cost\n        for i in sorted_gen_indices:\n            if commitment_status[i]:\n                gen = generators[i]\n                capacity_above_min = gen['P_max'] - gen['P_min']\n                load_increase = min(remaining_demand, capacity_above_min)\n                \n                dispatch[i] += load_increase\n                gen_cost += gen['cost'] * load_increase\n                remaining_demand -= load_increase\n        \n        return gen_cost, dispatch\n\n    results = []\n    \n    for case in test_cases:\n        min_total_exp_cost = float('inf')\n        optimal_y1 = None\n\n        # Enumerate all 4 possible first-stage commitments (y1_1, y2_1)\n        for y11 in [0, 1]:\n            for y21 in [0, 1]:\n                y1 = (y11, y21)\n                \n                # --- STAGE 1 ANALYSIS ---\n                # Calculate first-stage cost\n                stage1_gen_cost, _ = economic_dispatch(case['D1'], y1)\n                \n                if stage1_gen_cost == float('inf'):\n                    continue\n\n                stage1_startup_cost = sum(gen['startup'] * y1[i] for i, gen in enumerate(generators))\n                total_stage1_cost = stage1_startup_cost + stage1_gen_cost\n                \n                # --- STAGE 2 ANALYSIS ---\n                # Calculate expected second-stage cost\n                exp_stage2_cost = 0.0\n                scenarios = [('A', case['D2A'], case['pi_A']), ('B', case['D2B'], case['pi_B'])]\n                \n                for _, d2_s, pi_s in scenarios:\n                    min_cost_s = float('inf')\n                    \n                    # Find optimal recourse action for scenario s by enumerating y2_s\n                    for y12s in [0, 1]:\n                        for y22s in [0, 1]:\n                            y2_s = (y12s, y22s)\n                            \n                            gen_cost_s, _ = economic_dispatch(d2_s, y2_s)\n                            if gen_cost_s == float('inf'):\n                                continue\n                                \n                            startup_cost_s = sum(gen['startup'] * max(0, y2_s[i] - y1[i]) for i, gen in enumerate(generators))\n                            total_cost_s = startup_cost_s + gen_cost_s\n                            \n                            if total_cost_s  min_cost_s:\n                                min_cost_s = total_cost_s\n                    \n                    if min_cost_s == float('inf'):\n                        # If a scenario is infeasible for a given y1, that y1 is invalid.\n                        exp_stage2_cost = float('inf')\n                        break\n                    \n                    exp_stage2_cost += pi_s * min_cost_s\n\n                if exp_stage2_cost == float('inf'):\n                    continue\n                \n                # --- TOTAL COST  OPTIMIZATION ---\n                total_exp_cost = total_stage1_cost + exp_stage2_cost\n                \n                if total_exp_cost  min_total_exp_cost:\n                    min_total_exp_cost = total_exp_cost\n                    optimal_y1 = y1\n        \n        # Format and append result\n        results.append([float(f\"{min_total_exp_cost:.2f}\"), optimal_y1[0], optimal_y1[1]])\n\n    # Print results in the specified format\n    print(f\"{results}\")\n\nsolve()\n```"
        },
        {
            "introduction": "在真实的电力系统中，决策不仅受当前状态影响，还受历史状态的约束。本练习在前一个练习的基础上，引入了发电机组的“爬坡速率”限制，这是一个关键的跨期（inter-temporal）约束。通过解决这个更复杂的算例，您将学会如何在随机机组组合模型中处理这类动态约束，并理解它们如何影响跨多个时间周期和不确定场景下的最优启停与调度策略。",
            "id": "4125912",
            "problem": "考虑一个针对火力发电组合的随机机组组合（SUC）规划与运行问题，其时间范围为离散的 $T = 3$ 个时段，包含 $G = 2$ 台发电机。存在 $S = 3$ 个需求情景，以 $s \\in \\{1,2,3\\}$ 索引，每个情景的发生概率为 $p_s$，并在每个时段 $t \\in \\{1,2,3\\}$ 具有时变的净负荷 $D_{t,s}$。决策变量包括：在所有情景中均相同的二元启停决策 $x_{g,t} \\in \\{0,1\\}$（非预期性），以及依赖于情景的调度功率 $p_{g,t,s} \\ge 0$。目标是在满足发电机容量、爬坡约束和节点平衡的条件下，最小化期望总成本。所有发电机在时段 $t=0$ 时均处于离线状态，输出为零。\n\n从以下基本原则出发：\n- 基于概率 $p_s$ 的情景期望值算子。\n- 单位能量的线性调度成本和单位启停时段的线性固定成本。\n- 每个情景时段内发电与需求之间的有功功率平衡。\n- 连续时段之间有功功率输出的物理爬坡约束。\n- 跨情景的二元决策的非预期性。\n\n令 $c_g$ 表示发电机 $g$ 的可变能量成本，单位为美元/兆瓦时（$\\$\\!/\\,\\mathrm{MWh}$）；$f_g$ 为空载成本，单位为美元/时段；$SU_g$ 为启动成本，单位为美元/次启动；$\\overline{P}_g$ 为最大功率，单位为兆瓦（$\\mathrm{MW}$）；$R^{\\uparrow}_g$ 为上爬坡率限制，单位为兆瓦/时段（$\\mathrm{MW}/\\mathrm{period}$）；$R^{\\downarrow}_g$ 为下爬坡率限制，单位为兆瓦/时段（$\\mathrm{MW}/\\mathrm{period}$）。假设最小功率为零（$P^{\\min}_g = 0$）。二元启动指示变量 $y_{g,t}$ 由 $x_{g,t}$ 隐含得出，即 $y_{g,t} = \\max\\{0, x_{g,t} - x_{g,t-1}\\}$，其中 $x_{g,0} = 0$。\n\nSUC 的数学模型如下：\n最小化\n$$\n\\sum_{g=1}^{G} \\left( SU_g \\sum_{t=1}^{T} y_{g,t} + f_g \\sum_{t=1}^{T} x_{g,t} \\right) + \\sum_{s=1}^{S} p_s \\sum_{t=1}^{T} \\sum_{g=1}^{G} c_g \\, p_{g,t,s}\n$$\n约束条件为，对于所有 $t \\in \\{1,2,3\\}$ 和 $s \\in \\{1,2,3\\}$：\n$$\n\\sum_{g=1}^{G} p_{g,t,s} = D_{t,s},\n$$\n$$\n0 \\le p_{g,t,s} \\le \\overline{P}_g \\, x_{g,t},\n$$\n$$\n- R^{\\downarrow}_g \\le p_{g,t,s} - p_{g,t-1,s} \\le R^{\\uparrow}_g, \\quad \\text{其中 } p_{g,0,s} = 0,\n$$\n并且对于所有 $t$，变量 $x_{g,t} \\in \\{0,1\\}$ 在各情景间保持一致。\n\n您必须计算出在上述模型下能够最小化期望成本的最优机组组合计划。您的算法设计应源于基本原则，并通过对可行的机组组合计划进行穷举枚举以及对每个情景-时段进行成本最小化调度，为小规模实例生成一个正确的优化计划。对于每个候选的机组组合计划，执行经济调度，以最小化每个时段的线性成本为目标，同时满足爬坡约束、容量约束以及满足总需求的等式。如果某个计划在任何一个情景-时段内不可行，则将其舍弃。\n\n使用以下包含三个实例的测试套件。所有成本必须以美元（$\\$$）计算，功率以兆瓦（$\\mathrm{MW}$）计算，能量以兆瓦时（$\\mathrm{MWh}$）计算，爬坡率以兆瓦/时段（$\\mathrm{MW}/\\mathrm{period}$）计算。最终输出为表示机组组合的无单位二元整数。这三个实例如下：\n\n- 实例 1：\n  - 发电机 1：$\\overline{P}_1 = 100\\,\\mathrm{MW}$， $R^{\\uparrow}_1 = 50\\,\\mathrm{MW}/\\mathrm{period}$， $R^{\\downarrow}_1 = 100\\,\\mathrm{MW}/\\mathrm{period}$， $c_1 = 20\\,\\$\\!/\\,\\mathrm{MWh}$， $f_1 = 500\\,\\$/\\mathrm{period}$， $SU_1 = 2000\\,\\$.$\n  - 发电机 2：$\\overline{P}_2 = 80\\,\\mathrm{MW}$， $R^{\\uparrow}_2 = 80\\,\\mathrm{MW}/\\mathrm{period}$， $R^{\\downarrow}_2 = 80\\,\\mathrm{MW}/\\mathrm{period}$， $c_2 = 30\\,\\$\\!/\\,\\mathrm{MWh}$， $f_2 = 300\\,\\$/\\mathrm{period}$， $SU_2 = 1500\\,\\$.$\n  - 情景概率：$(p_1,p_2,p_3) = (0.3, 0.4, 0.3)$。\n  - 需求：$D_{\\cdot,1} = [60, 100, 80]\\,\\mathrm{MW}$， $D_{\\cdot,2} = [50, 70, 110]\\,\\mathrm{MW}$， $D_{\\cdot,3} = [40, 90, 60]\\,\\mathrm{MW}.$\n\n- 实例 2：\n  - 发电机 1：$\\overline{P}_1 = 120\\,\\mathrm{MW}$， $R^{\\uparrow}_1 = 30\\,\\mathrm{MW}/\\mathrm{period}$， $R^{\\downarrow}_1 = 120\\,\\mathrm{MW}/\\mathrm{period}$， $c_1 = 18\\,\\$\\!/\\,\\mathrm{MWh}$， $f_1 = 700\\,\\$/\\mathrm{period}$， $SU_1 = 2500\\,\\$.$\n  - 发电机 2：$\\overline{P}_2 = 100\\,\\mathrm{MW}$， $R^{\\uparrow}_2 = 100\\,\\mathrm{MW}/\\mathrm{period}$， $R^{\\downarrow}_2 = 100\\,\\mathrm{MW}/\\mathrm{period}$， $c_2 = 26\\,\\$\\!/\\,\\mathrm{MWh}$， $f_2 = 200\\,\\$/\\mathrm{period}$， $SU_2 = 1000\\,\\$.$\n  - 情景概率：$(p_1,p_2,p_3) = (0.2, 0.5, 0.3)$。\n  - 需求：$D_{\\cdot,1} = [40, 120, 80]\\,\\mathrm{MW}$， $D_{\\cdot,2} = [60, 140, 70]\\,\\mathrm{MW}$， $D_{\\cdot,3} = [50, 100, 90]\\,\\mathrm{MW}.$\n\n- 实例 3：\n  - 发电机 1：$\\overline{P}_1 = 90\\,\\mathrm{MW}$， $R^{\\uparrow}_1 = 45\\,\\mathrm{MW}/\\mathrm{period}$， $R^{\\downarrow}_1 = 90\\,\\mathrm{MW}/\\mathrm{period}$， $c_1 = 22\\,\\$\\!/\\,\\mathrm{MWh}$， $f_1 = 400\\,\\$/\\mathrm{period}$， $SU_1 = 1000\\,\\$.$\n  - 发电机 2：$\\overline{P}_2 = 150\\,\\mathrm{MW}$， $R^{\\uparrow}_2 = 150\\,\\mathrm{MW}/\\mathrm{period}$， $R^{\\downarrow}_2 = 150\\,\\mathrm{MW}/\\mathrm{period}$， $c_2 = 24\\,\\$\\!/\\,\\mathrm{MWh}$， $f_2 = 50\\,\\$/\\mathrm{period}$， $SU_2 = 6000\\,\\$.$\n  - 情景概率：$(p_1,p_2,p_3) = (0.3, 0.4, 0.3)$。\n  - 需求：$D_{\\cdot,1} = [30, 80, 30]\\,\\mathrm{MW}$， $D_{\\cdot,2} = [20, 60, 20]\\,\\mathrm{MW}$， $D_{\\cdot,3} = [25, 75, 25]\\,\\mathrm{MW}.$\n\n您必须通过以下方式实现期望成本最小化：\n- 枚举所有可能的机组组合计划 $x_{g,t}$，其中 $g \\in \\{1,2\\}$ 且 $t \\in \\{1,2,3\\}$。\n- 对于一个固定的计划，执行每个情景的经济调度，以在每个时段 $t$ 最小化 $\\sum_{g} c_g \\, p_{g,t,s}$，约束条件为 $p_{g,t,s} \\in [L_{g,t,s}, U_{g,t,s}]$ 和 $\\sum_{g} p_{g,t,s} = D_{t,s}$，其中\n  若 $x_{g,t} = 0$，则 $L_{g,t,s} = 0$，否则 $L_{g,t,s} = \\max\\{0, p_{g,t-1,s} - R^{\\downarrow}_g\\}$，\n  并且\n  若 $x_{g,t} = 0$，则 $U_{g,t,s} = 0$，否则 $U_{g,t,s} = \\min\\{\\overline{P}_g, p_{g,t-1,s} + R^{\\uparrow}_g\\}$，\n  其中 $p_{g,0,s} = 0$。\n- 如果某个时段出现不可行，则该计划被视为不可行。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。每个测试用例的结果必须是一个包含六个二元整数的扁平化列表，按 $[x_{1,1}, x_{1,2}, x_{1,3}, x_{2,1}, x_{2,2}, x_{2,3}]$ 的顺序表示最优机组组合计划。因此，最终输出应类似于 $[[\\dots],[\\dots],[\\dots]]$，其中每个内部列表仅包含整数（$0$ 或 $1$）。",
            "solution": "所提出的问题是一个针对小型电力系统的、有效的、良态的随机机组组合（SUC）问题。该问题基于运筹学和电力系统工程的既定原则。其目标是在考虑三种不同需求情景的情况下，为一个包含两台火力发电机、时间跨度为三个时段的系统，确定最优的机组组合计划。解决方案必须最小化总期望成本，该成本包括固定的机组组合成本、启动成本和可变的调度成本。\n\n该问题可以被表述为一个混合整数线性规划（MILP）模型。决策变量包括第一阶段（非预期的）二元机组组合变量 $x_{g,t} \\in \\{0,1\\}$（针对每台发电机 $g \\in \\{1,2\\}$ 和每个时段 $t \\in \\{1,2,3\\}$），以及第二阶段（依赖于情景的）连续调度变量 $p_{g,t,s} \\ge 0$。目标是最小化确定性的机组组合和启动成本与所有情景下调度成本的期望值之和。\n\n需要最小化的目标函数是：\n$$\nC_{total} = C_{commit} + \\mathbb{E}[C_{dispatch}] = \\sum_{g=1}^{G} \\left( SU_g \\sum_{t=1}^{T} y_{g,t} + f_g \\sum_{t=1}^{T} x_{g,t} \\right) + \\sum_{s=1}^{S} \\pi_s \\left( \\sum_{t=1}^{T} \\sum_{g=1}^{G} c_g \\, p_{g,t,s} \\right)\n$$\n其中 $y_{g,t} = \\max\\{0, x_{g,t} - x_{g,t-1}\\}$ 是启动指示变量，初始状态为 $x_{g,0}=0$。约束条件为每个情景 $s$ 和时段 $t$ 强制执行功率平衡、发电机容量限制和爬坡限制：\n1.  功率平衡：$\\sum_{g=1}^{G} p_{g,t,s} = D_{t,s}$\n2.  发电容量：$0 \\le p_{g,t,s} \\le \\overline{P}_g x_{g,t}$\n3.  爬坡限制：$p_{g,t-1,s} - R^{\\downarrow}_g \\le p_{g,t,s} \\le p_{g,t-1,s} + R^{\\uparrow}_g$，初始调度功率为 $p_{g,0,s}=0$。\n\n该问题指定了采用穷举枚举法来寻找最优机组组合计划。对于 $G=2$ 台发电机和 $T=3$ 个时段，存在 $G \\times T = 6$ 个二元机组组合变量（$x_{1,1}, x_{1,2}, x_{1,3}, x_{2,1}, x_{2,2}, x_{2,3}$）。这导致整个系统共有 $2^{G \\times T} = 2^6 = 64$ 种可能的机组组合计划。算法会遍历每一种候选计划，评估其总期望成本，并找出成本最低的计划。\n\n对于每个候选的机组组合计划，会执行一个分为两部分的成本评估：\n\n首先，计算确定性的机组组合成本（$C_{commit}$）。此成本与情景无关，仅取决于机组组合计划 $x = \\{x_{g,t}\\}$。对于每台发电机 $g$，计算其启动次数和总运行时间。成本计算公式为：\n$$\nC_{commit}(x) = \\sum_{g=1}^{G} \\left( SU_g \\sum_{t=1}^{T} \\max\\{0, x_{g,t} - x_{g,t-1}\\} + f_g \\sum_{t=1}^{T} x_{g,t} \\right)\n$$\n\n其次，计算期望调度成本（$\\mathbb{E}[C_{dispatch}]$）。这需要评估每个情景的调度可行性和成本。对于一个给定的机组组合计划 $x$，我们逐个情景进行处理。对于每个情景 $s$，我们模拟时间范围 $t=1,2,3$ 内的调度：\n在每个时段 $t$，我们必须解决一个经济调度子问题，以找到满足需求 $D_{t,s}$ 且成本最低的发电机输出 $p_{g,t,s}$。每台发电机的可用调度范围受到其启停状态、最大容量 $\\overline{P}_g$ 以及相对于前一时段输出 $p_{g,t-1,s}$ 的爬坡率限制。发电机 $g$ 的有效可行调度范围 $[L_{g,t,s}, U_{g,t,s}]$ 为：\n-   若发电机 $g$ 离线（$x_{g,t}=0$）：$L_{g,t,s} = U_{g,t,s} = 0$。\n-   若发电机 $g$ 在线（$x_{g,t}=1$）：\n    $$\n    L_{g,t,s} = \\max\\{0, p_{g,t-1,s} - R^{\\downarrow}_g\\}\n    $$\n    $$\n    U_{g,t,s} = \\min\\{\\overline{P}_g, p_{g,t-1,s} + R^{\\uparrow}_g\\}\n    $$\n初始条件为对所有 $g,s$ 均有 $p_{g,0,s}=0$。\n\n仅当总需求 $D_{t,s}$ 处于系统聚合容量范围内，即 $\\sum_{g=1}^{G} L_{g,t,s} \\le D_{t,s} \\le \\sum_{g=1}^{G} U_{g,t,s}$ 时，情景 $s$ 中时段 $t$ 的可行调度才存在。如果该条件在任何情景 $s$ 的任何时段 $t$ 中被违反，则整个机组组合计划被视为不可行，并从考虑中舍弃。\n\n如果该时段是可行的，则通过按可变成本 $c_g$ 的递增顺序（优先顺序调度法）加载发电机来找到最优调度。对于一个双发电机系统，其成本为 $c_1$ 和 $c_2$，不失一般性地假设 $c_1 \\le c_2$。为最小化调度成本 $c_1 p_{1,t,s} + c_2 p_{2,t,s}$，同时满足 $p_{1,t,s} + p_{2,t,s} = D_{t,s}$ 以及边界 $[L_{g,t,s}, U_{g,t,s}]$，我们应最大化较便宜的发电机 $p_{1,t,s}$ 的输出。$p_{1,t,s}$ 的可行范围由其自身边界和 $p_{2,t,s}$ 的边界导出：\n$$\np_{1,t,s} \\in [\\max(L_{1,t,s}, D_{t,s} - U_{2,t,s}), \\min(U_{1,t,s}, D_{t,s} - L_{2,t,s})]\n$$\n为了最大化 $p_{1,t,s}$，我们将其设置为此范围的上限：\n$$\np_{1,t,s}^* = \\min(U_{1,t,s}, D_{t,s} - L_{2,t,s})\n$$\n然后，较昂贵发电机的调度功率由功率平衡方程确定：\n$$\np_{2,t,s}^* = D_{t,s} - p_{1,t,s}^*\n$$\n如果 $c_2  c_1$，我们则会最小化 $p_{1,t,s}$，将其设置为其可行范围的下限，即 $p_{1,t,s}^* = \\max(L_{1,t,s}, D_{t,s} - U_{2,t,s})$。\n\n该时段的调度成本为 $C_{t,s} = \\sum_{g} c_g p_{g,t,s}^*$。情景 $s$ 的总调度成本为 $C_{dispatch,s} = \\sum_{t=1}^{T} C_{t,s}$。然后，通过将每个情景的成本乘以其概率来计算期望调度成本：$\\mathbb{E}[C_{dispatch}] = \\sum_{s=1}^{S} \\pi_s C_{dispatch,s}$。\n\n该候选计划的总期望成本为 $C_{total}(x) = C_{commit}(x) + \\mathbb{E}[C_{dispatch}]$。对所有 64 个计划重复此过程。产生最小有限总成本的计划即为最优解。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the stochastic unit commitment problem for three given instances\n    using exhaustive enumeration of commitment schedules.\n    \"\"\"\n\n    test_cases = [\n        # Instance 1\n        {\n            \"G1\": {\"P_max\": 100, \"R_up\": 50, \"R_down\": 100, \"c\": 20, \"f\": 500, \"SU\": 2000},\n            \"G2\": {\"P_max\": 80, \"R_up\": 80, \"R_down\": 80, \"c\": 30, \"f\": 300, \"SU\": 1500},\n            \"probs\": [0.3, 0.4, 0.3],\n            \"demands\": [\n                [60, 100, 80],\n                [50, 70, 110],\n                [40, 90, 60],\n            ],\n        },\n        # Instance 2\n        {\n            \"G1\": {\"P_max\": 120, \"R_up\": 30, \"R_down\": 120, \"c\": 18, \"f\": 700, \"SU\": 2500},\n            \"G2\": {\"P_max\": 100, \"R_up\": 100, \"R_down\": 100, \"c\": 26, \"f\": 200, \"SU\": 1000},\n            \"probs\": [0.2, 0.5, 0.3],\n            \"demands\": [\n                [40, 120, 80],\n                [60, 140, 70],\n                [50, 100, 90],\n            ],\n        },\n        # Instance 3\n        {\n            \"G1\": {\"P_max\": 90, \"R_up\": 45, \"R_down\": 90, \"c\": 22, \"f\": 400, \"SU\": 1000},\n            \"G2\": {\"P_max\": 150, \"R_up\": 150, \"R_down\": 150, \"c\": 24, \"f\": 50, \"SU\": 6000},\n            \"probs\": [0.3, 0.4, 0.3],\n            \"demands\": [\n                [30, 80, 30],\n                [20, 60, 20],\n                [25, 75, 25],\n            ],\n        },\n    ]\n\n    results = []\n    T = 3\n    G = 2\n\n    for case in test_cases:\n        min_total_cost = float('inf')\n        best_schedule = None\n\n        # Enumerate all 2^(G*T) = 64 possible commitment schedules\n        for i in range(2**(G * T)):\n            # Generate the schedule from the integer i\n            # Format: [x11, x12, x13, x21, x22, x23]\n            schedule_flat = [int(bit) for bit in format(i, f'0{G*T}b')]\n            x = np.array(schedule_flat).reshape((G, T))\n            \n            # --- 1. Calculate deterministic commitment cost ---\n            commit_cost = 0.0\n            gens = [case[\"G1\"], case[\"G2\"]]\n            for g in range(G):\n                x_g_t = x[g, :]\n                x_g_t_prev = np.insert(x_g_t[:-1], 0, 0) # x_{g,t-1} with x_{g,0}=0\n                startups = np.maximum(0, x_g_t - x_g_t_prev)\n                \n                commit_cost += gens[g][\"SU\"] * np.sum(startups)\n                commit_cost += gens[g][\"f\"] * np.sum(x_g_t)\n\n            # --- 2. Calculate expected dispatch cost ---\n            expected_dispatch_cost = 0.0\n            schedule_is_feasible = True\n\n            for s, prob in enumerate(case[\"probs\"]):\n                scenario_dispatch_cost = 0.0\n                is_feasible_scenario = True\n                p_prev = np.zeros(G) # p_{g,t-1,s}, initialized for t=1\n\n                for t in range(T):\n                    demand = case[\"demands\"][s][t]\n                    \n                    # Calculate generator bounds [L_g, U_g] for this period\n                    L_g = np.zeros(G)\n                    U_g = np.zeros(G)\n                    for g in range(G):\n                        if x[g, t] == 1:\n                            L_g[g] = max(0, p_prev[g] - gens[g][\"R_down\"])\n                            U_g[g] = min(gens[g][\"P_max\"], p_prev[g] + gens[g][\"R_up\"])\n                        # If x[g,t] == 0, bounds are already 0.\n\n                    # Check feasibility for the period\n                    if not (np.sum(L_g) = demand = np.sum(U_g)):\n                        is_feasible_scenario = False\n                        break\n                    \n                    # Economic dispatch\n                    # Sort generators by cost\n                    gen_indices = sorted(range(G), key=lambda g_idx: gens[g_idx][\"c\"])\n                    g_cheap, g_exp = gen_indices[0], gen_indices[1]\n                    \n                    # Effective bounds for the cheaper generator's dispatch\n                    p_cheap_min = max(L_g[g_cheap], demand - U_g[g_exp])\n                    p_cheap_max = min(U_g[g_cheap], demand - L_g[g_exp])\n\n                    # Dispatch cheaper generator to its max feasible limit\n                    p_dispatch = np.zeros(G)\n                    p_dispatch[g_cheap] = p_cheap_max\n                    p_dispatch[g_exp] = demand - p_dispatch[g_cheap]\n                    \n                    # Calculate period dispatch cost and update for next period\n                    period_cost = p_dispatch[0] * gens[0][\"c\"] + p_dispatch[1] * gens[1][\"c\"]\n                    scenario_dispatch_cost += period_cost\n                    p_prev = p_dispatch\n                \n                if not is_feasible_scenario:\n                    schedule_is_feasible = False\n                    break\n                else:\n                    expected_dispatch_cost += prob * scenario_dispatch_cost\n            \n            if schedule_is_feasible:\n                total_cost = commit_cost + expected_dispatch_cost\n                if total_cost  min_total_cost:\n                    min_total_cost = total_cost\n                    best_schedule = schedule_flat\n\n        results.append(best_schedule)\n    \n    # Format the final output as a list of lists of integers\n    # The provided print statement template with map(str,...) needs careful handling\n    # for lists of lists. A custom formatter is safer.\n    def format_results(res):\n        return '[' + ','.join(str(r) for r in res) + ']'\n    \n    print(f\"[{','.join(format_results(res) for res in results)}]\")\n\nsolve()\n```"
        }
    ]
}