{
    "hands_on_practices": [
        {
            "introduction": "要精确地为无功功率建模，我们必须首先从交流电路的基本原理出发。这个练习将引导您从电压、电流和阻抗这些基本物理量，推导出有功功率 ($P$)、无功功率 ($Q$) 和复功率 ($S$) 的核心数学表达式。通过这个实践 ，您将深刻理解负载的电抗性 ($X$) 如何直接决定无功功率的符号和性质，从而为感性负载（吸收无功）和容性负载（提供无功）建立起坚实的理论基础。",
            "id": "4115160",
            "problem": "一个相量电压为 $V\\angle 0$ 的单相正弦电源，为一个集总线性时不变负载供电，该负载的串联阻抗为 $Z=R+jX$，其中 $R>0$ 且 $X\\in\\mathbb{R}$。假设系统处于稳态运行，且相量采用有效值约定。采用如下符号约定：从电源端看，正的有功功率 $P$ 和无功功率 $Q$ 被负载吸收，其中正的 $Q$ 对应于感性行为。\n\n请仅使用基本相量关系和复功率的定义，推导负载吸收的有功功率 $P$、无功功率 $Q$ 和复功率 $S$ 的闭式表达式，以 $V$、$R$ 和 $X$ 表示。然后，从这些表达式出发，推断 $X$ 的符号如何决定 $Q$ 的符号，并为感性（$X>0$）和容性（$X<0$）情况提供物理解释。\n\n最后，假设一个导纳为 $jB$ 的纯无功并联补偿器在负载端并联连接（因此电源看到的是负载和补偿器的并联组合）。请确定使电源看到的净无功功率为零所需的电纳 $B$，并用 $V$、$R$ 和 $X$ 表示。\n\n请将您的最终答案表示为关于 $V$、$R$ 和 $X$ 的简化解析表达式。最终表达式中不要包含单位。不需要进行数值计算或四舍五入。",
            "solution": "该问题提法明确，且基于交流电路分析和电力系统工程的基本原理。所有术语均已定义，目标清晰。因此，可以推导出解答。\n\n首先，我们推导未补偿负载的有功功率 $P$、无功功率 $Q$ 和复功率 $S$ 的表达式。电源电压给定为相量 $\\mathbf{V} = V \\angle 0^{\\circ}$，由于其为参考相量，可写作实数 $V$。负载阻抗为 $\\mathbf{Z} = R + jX$。\n\n根据相量形式的欧姆定律，流入负载的电流 $\\mathbf{I}$ 为：\n$$\n\\mathbf{I} = \\frac{\\mathbf{V}}{\\mathbf{Z}} = \\frac{V}{R+jX}\n$$\n负载吸收的复功率 $S$ 定义为 $S = \\mathbf{V} \\mathbf{I}^*$，其中 $\\mathbf{I}^*$ 是电流相量的复共轭。我们首先求 $\\mathbf{I}^*$：\n$$\n\\mathbf{I}^* = \\left( \\frac{V}{R+jX} \\right)^* = \\frac{V^*}{(R+jX)^*} = \\frac{V}{R-jX}\n$$\n此处，$V^* = V$ 因为 $V$ 是一个实数（相量 $\\mathbf{V}$ 的幅值）。现在，我们可以写出 $S$ 的表达式：\n$$\nS = \\mathbf{V} \\mathbf{I}^* = V \\left( \\frac{V}{R-jX} \\right) = \\frac{V^2}{R-jX}\n$$\n为将其分离为实部和虚部，我们对分母进行有理化：\n$$\nS = \\frac{V^2}{R-jX} \\cdot \\frac{R+jX}{R+jX} = \\frac{V^2(R+jX)}{R^2 - (jX)^2} = \\frac{V^2(R+jX)}{R^2+X^2}\n$$\n根据定义，复功率为 $S = P + jQ$。令我们推导出的 $S$ 表达式的实部和虚部分别相等：\n$$\nP = \\frac{V^2 R}{R^2+X^2}\n$$\n$$\nQ = \\frac{V^2 X}{R^2+X^2}\n$$\n这些就是负载吸收的有功功率和无功功率的表达式。因此，复功率为 $S = \\frac{V^2 R}{R^2+X^2} + j\\frac{V^2 X}{R^2+X^2}$。\n\n接下来，我们分析无功功率 $Q$ 的符号。在 $Q$ 的表达式中，项 $V$ 代表电压的有效值大小，因此 $V^2$ 是非负的。分母 $R^2+X^2 = |\\mathbf{Z}|^2$ 是阻抗幅值的平方，并且由于 $R>0$ 而是严格为正的。因此，$Q$ 的符号完全由电抗 $X$ 的符号决定：\n- 如果 $X > 0$，负载是感性的。则 $Q > 0$，意味着负载吸收正的无功功率。物理上，这对应于电感元件的磁场所储存和释放的能量。电流相量滞后于电压相量。\n- 如果 $X  0$，负载是容性的。则 $Q  0$，意味着负载吸收负的无功功率，或者等效地，向系统提供无功功率。物理上，这对应于电容元件的电场所储存和释放的能量。电流相量超前于电压相量。\n- 如果 $X = 0$，负载是纯阻性的。则 $Q = 0$，负载不吸收无功功率。电流与电压同相。\n\n最后，我们确定使净无功功率为零所需的并联补偿器的电纳 $B$。一个导纳为 $\\mathbf{Y}_{comp} = jB$ 的补偿器与负载并联。对于并联连接，使用导纳进行计算更方便。负载的导纳 $\\mathbf{Y}_{load}$ 是其阻抗的倒数：\n$$\n\\mathbf{Y}_{load} = \\frac{1}{\\mathbf{Z}} = \\frac{1}{R+jX} = \\frac{R-jX}{R^2+X^2} = \\frac{R}{R^2+X^2} - j \\frac{X}{R^2+X^2}\n$$\n电源看到的总导纳 $\\mathbf{Y}_{total}$ 是并联导纳之和：\n$$\n\\mathbf{Y}_{total} = \\mathbf{Y}_{load} + \\mathbf{Y}_{comp} = \\left(\\frac{R}{R^2+X^2} - j \\frac{X}{R^2+X^2}\\right) + jB\n$$\n合并实部和虚部，我们得到：\n$$\n\\mathbf{Y}_{total} = \\frac{R}{R^2+X^2} + j \\left(B - \\frac{X}{R^2+X^2}\\right)\n$$\n电源提供的总复功率为 $S_{total} = V^2 \\mathbf{Y}_{total}^*$：\n$$\nS_{total} = V^2 \\left( \\frac{R}{R^2+X^2} - j \\left(B - \\frac{X}{R^2+X^2}\\right) \\right)\n$$\n净无功功率 $Q_{total}$ 是 $S_{total}$ 的虚部：\n$$\nQ_{total} = \\text{Im}(S_{total}) = -V^2 \\left(B - \\frac{X}{R^2+X^2}\\right)\n$$\n要使净无功功率为零 ($Q_{total}=0$)，我们必须有：\n$$\n-V^2 \\left(B - \\frac{X}{R^2+X^2}\\right) = 0\n$$\n由于对于一个非平凡的电源，$V \\neq 0$，括号中的项必须为零：\n$$\nB - \\frac{X}{R^2+X^2} = 0\n$$\n求解所需的电纳 $B$：\n$$\nB = \\frac{X}{R^2+X^2}\n$$\n这个 $B$ 值恰好抵消了原始负载的电纳。负载的电纳是 $B_{load} = -\\frac{X}{R^2+X^2}$，而补偿器的电纳是 $B = -B_{load}$。总电纳变为零，导致总导纳为纯导性，从而实现单位功率因数。最终推导的表达式，按要求的顺序 ($P, Q, S, B$)，在最终答案中给出。请注意，$B$ 的表达式不依赖于 $V$，这在物理上是正确的，因为所需的补偿仅取决于负载的特性。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{V^2 R}{R^2+X^2}  \\frac{V^2 X}{R^2+X^2}  \\frac{V^2(R+jX)}{R^2+X^2}  \\frac{X}{R^2+X^2}\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "在掌握了无功功率的基本定义之后，下一步是将其应用于解决实际的工程问题。功率因数校正是一个典型的应用场景，在工业和电力系统中至关重要，因为它直接关系到能源效率和系统的稳定性。这个练习  模拟了一个常见的工业负载场景，要求您计算补偿负载所需的无功功率，以达到目标功率因数。通过解决这个问题，您将熟练运用功率三角形的概念，将理论知识转化为量化的补偿方案。",
            "id": "4115151",
            "problem": "一个平衡的三相工业负载连接到线电压 $V = 13.8\\,\\mathrm{kV}$ 的中压母线上，消耗有功功率 $P = 10\\,\\mathrm{MW}$，测得的滞后功率因数 $\\mathrm{pf} = 0.85$。系统在稳态正弦条件下运行，且母线电压保持稳定。假设采用常规符号约定，即感性无功功率为正，容性无功功率为负。一个作为理想无功功率源（纯无功、无损耗且谐波可忽略不计）的并联静止补偿器将安装在同一母线上，以将功率因数提高到一个新的滞后值 $\\mathrm{pf} = 0.98$，同时保持相同的有功功率传输。\n\n仅使用交流稳态下复功率的基本定义和功率因数的定义，确定初始工作点和补偿后工作点的以下三个量：负载汲取的初始无功功率 $Q$、初始视在功率大小 $\\lvert S \\rvert$，以及为达到目标功率因数所需的并联无功补偿的量值。将 $Q$ 的最终值和所需的无功补偿以兆乏 $\\left(\\mathrm{MVAr}\\right)$ 为单位表示，将 $\\lvert S \\rvert$ 以兆伏安 $\\left(\\mathrm{MVA}\\right)$ 为单位表示。将所需补偿的量值报告为一个正数，并理解该补偿是在母线上以容性方式提供的。将您的答案四舍五入至三位有效数字。",
            "solution": "在尝试任何解答之前，需对问题陈述进行验证。\n\n### 步骤1：提取已知条件\n- 母线线电压：$V = 13.8\\,\\mathrm{kV}$\n- 负载消耗的有功功率：$P = 10\\,\\mathrm{MW}$\n- 初始功率因数：$\\mathrm{pf}_1 = 0.85$ (滞后)\n- 目标功率因数：$\\mathrm{pf}_2 = 0.98$ (滞后)\n- 约束条件：有功功率传输保持不变（$P$ 为常数）。\n- 系统条件：平衡三相，稳态正弦。\n- 补偿器模型：理想无功功率源（无损，纯无功）。\n- 符号约定：感性无功功率为正（$Q  0$）；容性无功功率为负（$Q  0$）。\n- 要求输出：初始无功功率 $Q_1$、初始视在功率大小 $|\\mathbf{S}_1|$ 以及所需并联无功补偿的量值 $|Q_{\\text{comp}}|$。\n- 报告要求：将最终值四舍五入至三位有效数字。\n\n### 步骤2：使用提取的已知条件进行验证\n对问题进行有效性评估：\n- **科学依据**：该问题基于交流(AC)电力系统的基本原理，特别是关于有功功率、无功功率、视在功率和功率因数之间的关系。这些概念是电力工程的基石。使用并联补偿来提高工业负载功率因数的场景是这些原理的经典且实际的应用。\n- **适定性**：该问题提供了确定所求量所需的全部数据。给定变量与期望变量之间的关系在电工理论中有明确定义，确保存在唯一解。\n- **客观性**：该问题使用清晰、明确、标准的电气工程术语进行陈述。诸如“功率因数”、“滞后”、“有功功率”和“无功功率”等术语具有精确的数学定义。\n\n### 步骤3：结论与行动\n该问题在科学上是合理的、自洽的且适定的。它提出了一个电力系统分析中的标准练习，没有任何逻辑矛盾、物理上的不可能性或事实错误。因此，该问题被视为**有效**，并将提供解答。\n\n### 解题推导\n复功率 ($\\mathbf{S}$)、有功功率 ($P$) 和无功功率 ($Q$) 之间的关系由表达式 $\\mathbf{S} = P + jQ$ 给出，其中 $j$ 是虚数单位。复功率的大小是视在功率 $|\\mathbf{S}|$，它通过功率三角形关系与 $P$ 和 $Q$ 相关联：$|\\mathbf{S}|^2 = P^2 + Q^2$。\n\n功率因数 $\\mathrm{pf}$ 定义为功率角 $\\theta$ 的余弦，功率角是电压和电流之间的相位差，也是复功率向量 $\\mathbf{S}$ 相对于有功功率轴的角度。它由 $\\mathrm{pf} = \\cos(\\theta) = \\frac{P}{|\\mathbf{S}|}$ 给出。\n\n“滞后”功率因数表示感性负载，其中电流滞后于电压。根据指定的符号约定，这对应于正的无功功率 $Q  0$。$P$、$Q$ 和 $\\theta$ 之间的关系是 $Q = P \\tan(\\theta)$。由于 $\\theta = \\arccos(\\mathrm{pf})$，我们可以写出 $Q = P \\tan(\\arccos(\\mathrm{pf}))$。\n\n问题分为两部分：分析初始状态和确定达到最终状态所需的补偿。\n\n**1. 初始工作点**\n\n初始状态的特征是有功功率 $P_1 = 10\\,\\mathrm{MW}$ 和滞后功率因数 $\\mathrm{pf}_1 = 0.85$。\n\n首先，我们计算初始视在功率的大小 $|\\mathbf{S}_1|$：\n$$\n|\\mathbf{S}_1| = \\frac{P_1}{\\mathrm{pf}_1} = \\frac{10\\,\\mathrm{MW}}{0.85} \\approx 11.7647\\,\\mathrm{MVA}\n$$\n四舍五入到三位有效数字，我们得到 $|\\mathbf{S}_1| \\approx 11.8\\,\\mathrm{MVA}$。\n\n接下来，我们计算初始无功功率 $Q_1$。由于功率因数是滞后的，$Q_1$ 为正。\n功率角为 $\\theta_1 = \\arccos(\\mathrm{pf}_1) = \\arccos(0.85)$。\n$$\nQ_1 = P_1 \\tan(\\theta_1) = (10\\,\\mathrm{MW}) \\times \\tan(\\arccos(0.85))\n$$\n使用三角恒等式 $\\tan(\\arccos(x)) = \\frac{\\sqrt{1 - x^2}}{x}$，我们有：\n$$\nQ_1 = (10\\,\\mathrm{MW}) \\times \\frac{\\sqrt{1 - (0.85)^2}}{0.85} = (10\\,\\mathrm{MW}) \\times \\frac{\\sqrt{1 - 0.7225}}{0.85} = (10\\,\\mathrm{MW}) \\times \\frac{\\sqrt{0.2775}}{0.85} \\approx 6.1974\\,\\mathrm{MVAr}\n$$\n四舍五入到三位有效数字，初始无功功率为 $Q_1 \\approx 6.20\\,\\mathrm{MVAr}$。\n\n**2. 补偿后工作点及所需补偿**\n\n目标是达到新的滞后功率因数 $\\mathrm{pf}_2 = 0.98$，同时保持有功功率传输，因此 $P_2 = P_1 = 10\\,\\mathrm{MW}$。并联补偿器是纯无功的，不消耗也不提供有功功率。\n\n补偿后从电源汲取的新无功功率 $Q_2$ 的计算方法与初始状态类似：\n新的功率角为 $\\theta_2 = \\arccos(\\mathrm{pf}_2) = \\arccos(0.98)$。\n$$\nQ_2 = P_2 \\tan(\\theta_2) = (10\\,\\mathrm{MW}) \\times \\tan(\\arccos(0.98))\n$$\n$$\nQ_2 = (10\\,\\mathrm{MW}) \\times \\frac{\\sqrt{1 - (0.98)^2}}{0.98} = (10\\,\\mathrm{MW}) \\times \\frac{\\sqrt{1 - 0.9604}}{0.98} = (10\\,\\mathrm{MW}) \\times \\frac{\\sqrt{0.0396}}{0.98} \\approx 2.0306\\,\\mathrm{MVAr}\n$$\n补偿器提供的无功功率 $Q_{\\text{comp}}$ 是新的总无功功率 ($Q_2$) 与负载汲取的初始无功功率 ($Q_1$) 之间的差值。总无功功率是负载无功功率和补偿器无功功率的代数和：$Q_2 = Q_1 + Q_{\\text{comp}}$。\n$$\nQ_{\\text{comp}} = Q_2 - Q_1 \\approx 2.0306\\,\\mathrm{MVAr} - 6.1974\\,\\mathrm{MVAr} \\approx -4.1668\\,\\mathrm{MVAr}\n$$\n负号表示补偿器提供容性无功功率，这符合预期，因为其目的是减少系统的净感性（滞后）无功功率。\n\n问题要求所需并联无功补偿的量值。\n$$\n|Q_{\\text{comp}}| \\approx |-4.1668\\,\\mathrm{MVAr}| = 4.1668\\,\\mathrm{MVAr}\n$$\n四舍五入到三位有效数字，补偿的量值为 $|Q_{\\text{comp}}| \\approx 4.17\\,\\mathrm{MVAr}$。\n\n总结四舍五入到三位有效数字的所求量：\n- 初始无功功率：$Q_1 = 6.20\\,\\mathrm{MVAr}$\n- 初始视在功率大小：$|\\mathbf{S}_1| = 11.8\\,\\mathrm{MVA}$\n- 所需无功补偿的量值：$|Q_{\\text{comp}}| = 4.17\\,\\mathrm{MVAr}$",
            "answer": "$$\n\\boxed{\\begin{pmatrix} 6.20  11.8  4.17 \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "无功功率的管理通常不是一次性的静态调整，而是一个随负载变化的动态优化过程。这个高级练习将挑战您从一个控制和优化的视角来思考无功补偿问题。您需要首先建立一个描述电压和功率之间关系的线性化系统模型，然后运用动态规划（Dynamic Programming）算法，为电容器组制定一个最优的投切策略 。这项实践完美地融合了基于物理的电力系统建模与先进的算法设计，体现了现代能源系统建模中为了在满足运行约束的同时最小化操作成本而采用的复杂决策方法。",
            "id": "4115155",
            "problem": "考虑一个单相辐射式馈线，它从一个刚性电源向一个单一负载母线供电。电源的电压幅值为 $V_s$，通向负载的线路具有串联阻抗 $Z = R + j X$，其中 $R$ 和 $X$ 分别是代表电阻和电抗的实常数。在离散时间 $t = 0,1,\\dots,T-1$，负载消耗有功功率 $P_t$ 和无功功率 $Q_t$。位于负载母线处的并联电容器组可以按离散步长进行切换，其模型由一个非负整数状态 $s_t \\in \\{0,1,\\dots,N\\}$ 表示，注入的无功功率为 $Q_{c,t} = s_t q_{\\text{step}}$。假设遵循以下符号约定：感性负载具有 $Q_t \\ge 0$，电容器注入的 $Q_{c,t} \\ge 0$ 会减少净无功需求。为建模目的，在小电压降和小相角的假设下，使用从复功率的基本定义和基尔霍夫电路定律推导出的线性化交流(AC)馈线关系，将母线电压幅值 $V_t$ 表示为 $V_s$、$R$、$X$、$P_t$、$Q_t$ 和 $Q_{c,t}$ 的显式函数。该线性化必须与仅保留 $R$、$X$、$P_t$、$Q_t$ 和 $Q_{c,t}$ 的一阶项保持一致。\n\n您的任务是建立并求解一个优化问题，寻找一个电容器切换时间表 $\\{s_t\\}_{t=0}^{T-1}$，以最小化切换操作的次数（即 $s_t$ 在连续时间步之间变化的次数），同时满足硬约束条件，即在每个时间步 $t$，母线电压幅值 $V_t$ 保持在指定的边界 $[V_{\\min}, V_{\\max}]$ 内。如果 $s_0 \\ne s_{\\text{init}}$，则在第一个时间步的切换被计数，其中 $s_{\\text{init}}$ 是 $t=0$ 之前的给定初始电容器状态。您必须使用动态规划 (DP) 求解此问题，确保在每个时间步都强制执行可行性。如果不存在可行的时间表，则该测试用例的输出必须是一个空列表。\n\n单位和约定：\n- 电压以伏特 (V) 表示。\n- 电阻和电抗以欧姆 ($\\Omega$) 表示。\n- 有功功率以瓦特 (W) 表示。\n- 无功功率以伏安无功 (var) 表示。\n- 在此问题中，频率不显式地出现在线性化电压关系中。\n- 不使用角度；如果在推导中需要，必须在解法中明确说明小角度近似并给出理由。\n\n测试套件：\n提供一个程序，求解以下三个测试用例。每个用例指定了 $\\{P_t\\}$、$\\{Q_t\\}$、$V_s$、$R$、$X$、$q_{\\text{step}}$、$N$、$s_{\\text{init}}$、$V_{\\min}$ 和 $V_{\\max}$。\n\n- 用例 A (具有中等补偿步长的通用负载曲线):\n  - $T = 8$,\n  - $V_s = 12470 \\text{ V}$,\n  - $R = 0.5 \\ \\Omega$,\n  - $X = 1.0 \\ \\Omega$,\n  - $V_{\\min} = 12350 \\text{ V}$,\n  - $V_{\\max} = 12650 \\text{ V}$,\n  - $q_{\\text{step}} = 200000 \\text{ var}$,\n  - $N = 4$,\n  - $s_{\\text{init}} = 0$,\n  - $\\{P_t\\} = [900000, 1200000, 1600000, 1400000, 1100000, 800000, 700000, 1000000] \\text{ W}$,\n  - $\\{Q_t\\} = [700000, 900000, 1100000, 1000000, 800000, 500000, 400000, 600000] \\text{ var}$。\n\n- 用例 B (如果过度补偿，可能出现过电压的边界条件):\n  - $T = 8$,\n  - $V_s = 12000 \\text{ V}$,\n  - $R = 0.5 \\ \\Omega$,\n  - $X = 1.0 \\ \\Omega$,\n  - $V_{\\min} = 11950 \\text{ V}$,\n  - $V_{\\max} = 12050 \\text{ V}$,\n  - $q_{\\text{step}} = 300000 \\text{ var}$,\n  - $N = 5$,\n  - $s_{\\text{init}} = 0$,\n  - $\\{P_t\\} = [200000, 200000, 200000, 200000, 200000, 200000, 200000, 200000] \\text{ W}$,\n  - $\\{Q_t\\} = [100000, 100000, 100000, 100000, 100000, 100000, 100000, 100000] \\text{ var}$。\n\n- 用例 C (由于电压上限，交替的重载和轻载迫使多次切换的边缘情况):\n  - $T = 8$,\n  - $V_s = 12470 \\text{ V}$,\n  - $R = 0.5 \\ \\Omega$,\n  - $X = 1.0 \\ \\Omega$,\n  - $V_{\\min} = 12350 \\text{ V}$,\n  - $V_{\\max} = 12400 \\text{ V}$,\n  - $q_{\\text{step}} = 300000 \\text{ var}$,\n  - $N = 2$,\n  - $s_{\\text{init}} = 0$,\n  - $\\{P_t\\} = [900000, 1600000, 1600000, 900000, 1600000, 1600000, 900000, 900000] \\text{ W}$,\n  - $\\{Q_t\\} = [700000, 1100000, 1100000, 700000, 1100000, 1100000, 700000, 700000] \\text{ var}$。\n\n您的程序必须：\n- 推导并使用与所述基本依据和假设一致的适当线性化电压关系。\n- 实现一个动态规划 (DP) 求解器，该求解器返回最小化切换操作次数的时间表 $\\{s_t\\}$，同时在每个 $t$ 满足 $V_{\\min} \\le V_t \\le V_{\\max}$。\n- 如果多个时间表达到相同的最小切换次数，则通过在每个时间步选择最小的可行电容器状态 $s_t$ 来打破平局，以确保确定性。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含三个测试用例的时间表，格式为用方括号括起来的逗号分隔列表，其中每个时间表本身是一个整数列表，代表每个时间步的电容器状态，例如 $[[s_0^{(A)},\\dots,s_7^{(A)}],[s_0^{(B)},\\dots,s_7^{(B)}],[s_0^{(C)},\\dots,s_7^{(C)}]]$。",
            "solution": "我们从复功率的基本定义和 Kirchhoff 电路定律出发，构建一个适用于离散电容器状态优化的线性化电压模型。\n\n设电源电压相量为 $V_s \\angle 0$，通过串联阻抗 $Z = R + j X$ 为单个负载母线供电。在时间 $t$，负载消耗复功率 $S_t = P_t + j Q_t$，符号约定为感性需求时 $Q_t \\ge 0$。负载端的并联电容器通过选择整数步长 $s_t \\in \\{0,1,\\dots,N\\}$ 注入无功功率 $Q_{c,t} = s_t q_{\\text{step}}$，从而将净无功需求减少到 $Q_{t}^{\\text{net}} = Q_t - Q_{c,t}$。\n\n根据交流 (AC) 系统中复功率的定义，在小压降假设下，负载母线电压幅值约等于 $V_t \\approx V_s$，复电流为\n$$\nI_t = \\frac{S_t^{\\ast}}{V_t} \\approx \\frac{P_t - j Q_t}{V_s}.\n$$\n线路上的串联电压降由欧姆定律给出，\n$$\n\\Delta V_t = Z I_t = (R + j X) \\frac{P_t - j Q_{t}^{\\text{net}}}{V_s}.\n$$\n展开乘积，\n$$\n\\Delta V_t = \\frac{R P_t + X Q_{t}^{\\text{net}}}{V_s} + j \\frac{X P_t - R Q_{t}^{\\text{net}}}{V_s}.\n$$\n在小角度近似下，其中 $V_s$ 的相位是参考，且电压幅值偏差很小，幅值变化的主要分量与实轴投影对齐。因此，一阶近似下，母线电压幅值满足\n$$\nV_t \\approx V_s - \\frac{R P_t + X Q_{t}^{\\text{net}}}{V_s} = V_s - \\frac{R P_t + X \\left(Q_t - s_t q_{\\text{step}}\\right)}{V_s}.\n$$\n这种线性化是通过仅保留 $R$、$X$、$P_t$、$Q_t$ 和 $Q_{c,t}$ 的一阶项得到的，与广泛使用的线性化配电潮流模型（例如，LinDistFlow 近似）一致，并基于 Kirchhoff 定律和复功率的定义。\n\n运行约束要求对于所有时间步 $t$ 都有\n$$\nV_{\\min} \\le V_t \\le V_{\\max}\n$$\n。优化目标是最小化切换操作的次数，定义为索引 $t \\in \\{0,\\dots,T-1\\}$ 的计数，其中当 $t=0$ 时 $s_0 \\ne s_{\\text{init}}$，或当 $t \\ge 1$ 时 $s_t \\ne s_{t-1}$。\n\n我们现在描述动态规划 (DP) 的构造。令时间 $t$ 的可行状态集为\n$$\n\\mathcal{S}_t = \\left\\{ s \\in \\{0,\\dots,N\\} \\ \\bigg| \\ V_{\\min} \\le V_s - \\frac{R P_t + X \\left(Q_t - s \\, q_{\\text{step}}\\right)}{V_s} \\le V_{\\max} \\right\\}.\n$$\n定义 DP 成本表 $C[t,s]$ 为在时间 $t$ 达到状态 $s$ 所需的最小切换次数，以及一个前驱状态表 $\\text{prev}[t,s]$ 用于存储实现该最小值的先前状态。在 $t=0$ 时的初始化为\n$$\nC[0,s] = \n\\begin{cases}\n0,  \\text{若 } s = s_{\\text{init}} \\text{ 且 } s \\in \\mathcal{S}_0,\\\\\n1,  \\text{若 } s \\ne s_{\\text{init}} \\text{ 且 } s \\in \\mathcal{S}_0,\\\\\n+\\infty,  \\text{若 } s \\notin \\mathcal{S}_0.\n\\end{cases}\n$$\n对于 $t \\ge 1$，递推关系为\n$$\nC[t,s] = \n\\begin{cases}\n\\min\\limits_{s' \\in \\mathcal{S}_{t-1}} \\left( C[t-1,s'] + \\mathbf{1}_{\\{s \\ne s'\\}} \\right),  \\text{若 } s \\in \\mathcal{S}_t, \\\\\n+\\infty,  \\text{若 } s \\notin \\mathcal{S}_t,\n\\end{cases}\n$$\n其中，如果 $s \\ne s'$，则 $\\mathbf{1}_{\\{s \\ne s'\\}}$ 等于 1，否则等于 0。如果出现最小值相同的情况，我们通过在每个时间步选择最小的 $s$ 来确定性地打破平局，这在多个最优解中强制执行一个一致的时间表。\n\n在为所有 $t$ 和 $s$ 填充 $C[t,s]$ 和 $\\text{prev}[t,s]$ 后，最优终端状态 $s^\\ast$ 被选择为\n$$\ns^\\ast \\in \\arg\\min_{s \\in \\mathcal{S}_{T-1}} C[T-1,s],\n$$\n再次应用最小状态打破平局规则。最优时间表通过使用 $\\text{prev}[t,s]$ 从 $t=T-1$ 回溯到 $t=0$ 来恢复。如果不存在有限的 $C[T-1,s]$，则问题在约束条件下是不可行的，并且时间表被定义为空列表。\n\n算法设计考虑：\n- 可行性检查仅依赖于上面推导的线性化电压表达式，并在每个时间步强制执行硬性电压边界。\n- 在最坏情况下，DP 的复杂度为 $\\mathcal{O}(T \\cdot N^2)$，这对于实践中典型的小型离散电容器组来说是可以接受的。\n- 当切换成本相等时，通过最小 $s$ 打破平局会产生偏好较低电容器使用率的时间表，这在操作上可能是可取的，并能确保确定性输出。\n\n将此方法应用于提供的测试套件，可得出在满足电压边界的同时最小化切换次数的时间表。程序实现直接遵循推导过程：它通过推导出的线性模型评估可行性，构造并求解具有指定初始化和打破平局规则的 DP 递推关系，并以要求的单行列表嵌套列表格式打印所有三个用例的时间表。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_voltage(Vs, R, X, P, Q, s, q_step):\n    \"\"\"\n    Linearized voltage magnitude at the load bus:\n    V_t ≈ Vs - (R*P + X*(Q - s*q_step)) / Vs\n    \"\"\"\n    Q_net = Q - s * q_step\n    delta_V = (R * P + X * Q_net) / Vs\n    V = Vs - delta_V\n    return V\n\ndef feasible_states(Vs, R, X, P_t, Q_t, q_step, N, Vmin, Vmax):\n    \"\"\"\n    Return list of states s in {0,...,N} that keep voltage within [Vmin, Vmax] at time t.\n    \"\"\"\n    feas = []\n    for s in range(N + 1):\n        V = compute_voltage(Vs, R, X, P_t, Q_t, s, q_step)\n        if Vmin = V = Vmax:\n            feas.append(s)\n    return feas\n\ndef dp_schedule(Vs, R, X, P, Q, q_step, N, s_init, Vmin, Vmax):\n    \"\"\"\n    Dynamic Programming to minimize number of switching events while maintaining voltage bounds.\n    Returns the schedule list [s_0, ..., s_{T-1}]. Empty list if infeasible.\n    Tie-breaking: choose smallest s when multiple transitions yield equal cost.\n    \"\"\"\n    T = len(P)\n    # Precompute feasible states per time step\n    feas_per_t = [feasible_states(Vs, R, X, P[t], Q[t], q_step, N, Vmin, Vmax) for t in range(T)]\n    if any(len(fs) == 0 for fs in feas_per_t):\n        return []  # Infeasible at some time\n\n    # Initialize DP tables\n    INF = 10**9\n    cost = np.full((T, N + 1), INF, dtype=int)\n    prev = np.full((T, N + 1), -1, dtype=int)\n\n    # Initialization at t=0\n    for s in feas_per_t[0]:\n        cost[0, s] = 0 if s == s_init else 1\n        prev[0, s] = s_init  # store initial for backtracking clarity\n\n    # DP recursion\n    for t in range(1, T):\n        feas_prev = feas_per_t[t - 1]\n        feas_curr = feas_per_t[t]\n        for s in feas_curr:\n            # Find best predecessor s'\n            best_c = INF\n            best_sp = -1\n            # Iterate predecessors in ascending order to realize tie-breaking to smaller s\n            for sp in feas_prev:\n                c = cost[t - 1, sp] + (0 if s == sp else 1)\n                if c  best_c or (c == best_c and sp  best_sp):\n                    best_c = c\n                    best_sp = sp\n            cost[t, s] = best_c\n            prev[t, s] = best_sp\n\n    # Choose terminal state with minimal cost; tie-break by smallest s\n    feas_last = feas_per_t[-1]\n    best_terminal_cost = INF\n    best_terminal_state = -1\n    for s in sorted(feas_last):\n        c = cost[T - 1, s]\n        if c  best_terminal_cost or (c == best_terminal_cost and s  best_terminal_state):\n            best_terminal_cost = c\n            best_terminal_state = s\n\n    if best_terminal_state == -1 or best_terminal_cost >= INF:\n        return []  # infeasible\n\n    # Backtrack to recover schedule\n    schedule = [0] * T\n    schedule[T - 1] = best_terminal_state\n    for t in range(T - 1, 0, -1):\n        schedule[t - 1] = prev[t, schedule[t]]\n    # Ensure s_0 respects feasibility and initial tie-breaking; cost[0, s_0] already handled\n    return schedule\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A\n        {\n            \"Vs\": 12470.0,\n            \"R\": 0.5,\n            \"X\": 1.0,\n            \"Vmin\": 12350.0,\n            \"Vmax\": 12650.0,\n            \"q_step\": 200000.0,\n            \"N\": 4,\n            \"s_init\": 0,\n            \"P\": [900000.0, 1200000.0, 1600000.0, 1400000.0, 1100000.0, 800000.0, 700000.0, 1000000.0],\n            \"Q\": [700000.0, 900000.0, 1100000.0, 1000000.0, 800000.0, 500000.0, 400000.0, 600000.0],\n        },\n        # Case B\n        {\n            \"Vs\": 12000.0,\n            \"R\": 0.5,\n            \"X\": 1.0,\n            \"Vmin\": 11950.0,\n            \"Vmax\": 12050.0,\n            \"q_step\": 300000.0,\n            \"N\": 5,\n            \"s_init\": 0,\n            \"P\": [200000.0] * 8,\n            \"Q\": [100000.0] * 8,\n        },\n        # Case C\n        {\n            \"Vs\": 12470.0,\n            \"R\": 0.5,\n            \"X\": 1.0,\n            \"Vmin\": 12350.0,\n            \"Vmax\": 12400.0,\n            \"q_step\": 300000.0,\n            \"N\": 2,\n            \"s_init\": 0,\n            \"P\": [900000.0, 1600000.0, 1600000.0, 900000.0, 1600000.0, 1600000.0, 900000.0, 900000.0],\n            \"Q\": [700000.0, 1100000.0, 1100000.0, 700000.0, 1100000.0, 1100000.0, 700000.0, 700000.0],\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        Vs = case[\"Vs\"]\n        R = case[\"R\"]\n        X = case[\"X\"]\n        Vmin = case[\"Vmin\"]\n        Vmax = case[\"Vmax\"]\n        q_step = case[\"q_step\"]\n        N = int(case[\"N\"])\n        s_init = int(case[\"s_init\"])\n        P = case[\"P\"]\n        Q = case[\"Q\"]\n\n        schedule = dp_schedule(Vs, R, X, P, Q, q_step, N, s_init, Vmin, Vmax)\n        results.append(schedule)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}