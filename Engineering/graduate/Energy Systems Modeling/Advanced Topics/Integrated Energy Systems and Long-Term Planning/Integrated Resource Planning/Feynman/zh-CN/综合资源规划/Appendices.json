{
    "hands_on_practices": [
        {
            "introduction": "综合资源规划的核心是比较具有不同成本结构和生命周期的项目。本实践介绍了核心工具——净现值 ($NPV$) 法，并探讨了贴现率（一个关于货币时间价值的关键假设）如何从根本上改变资本密集型和运营成本密集型资源之间的选择。通过亲手计算和分析，你将深入理解跨期决策的经济学原理。",
            "id": "4097905",
            "problem": "您的任务是设计并实现一个关于折现率的灵敏度分析，并在能源系统建模中的综合资源规划背景下，量化其在使用净现值对长寿命与短寿命资源计划进行排序时的影响。该分析必须从跨期估值和时间偏好的第一性原理进行阐述。考虑一个中央计划者，他使用货币时间价值的原则来评估固定规划期内的资源计划：未来的现金流根据一个恒定的实际折现率被赋予比当前现金流更低的价值。一个资源计划由一系列现金流定义，其中包括投资支出、年度运营支出、年度运营收益以及规划期末的残值。规划期是固定的，对所有资源计划都通用；在此规划期内，竞争性计划必须提供相同的年度服务。当一个资源的技术寿命短于规划期时，将根据需要进行相同的替换，以提供整个规划期的服务。如果一个资源实例的使用寿命超出了规划期，其未到期寿命将在规划期末通过按比例剩余寿命估值法转换为残值。\n\n将使用的基本假设（除了可以从这些原理推导出的公式外，不要使用任何快捷公式）：\n- 货币时间价值由一个恒定的年实际折现率 $r \\in [0,1)$ 表示。在第 $t$ 年末发生的现金流的现值由折现率 $r$ 的折现原则确定。\n- 每个资源实例都有一个技术寿命，记为 $L$；一次性资本投资成本 $K$（以美元计量的正数）；恒定的年度运营和维护成本 $C$（以美元/年计量）；以及恒定的年度运营收益 $B$（以美元/年计量）。每个活跃年份的净运营现金流为 $(B - C)$。\n- 计划者使用一个固定的规划期 $H$（以年为单位）。为确保各计划提供相同的服务，短寿命资源将在第 $0, L, 2L, \\dots$ 年进行替换，直到覆盖整个 $H$。如果最后一个实例的使用寿命超出了 $H$，其剩余寿命在第 $H$ 年转换为残值，该残值等于未到期寿命分数乘以 $K$。如果最后一个实例正好在 $H$ 年结束，则残值为零。类似地，长寿命资源根据需要进行替换以覆盖 $H$；最后一个实例在 $H$ 年的任何剩余寿命都以同样的方式产生残值。\n- 所有现金流都发生在每年年末。资本成本 $K$ 在安装当年的年末产生，年度净运营现金流 $(B - C)$ 在每个活跃年份的年末产生。残值（如有）在第 $H$ 年末产生。\n- 所有数值均以美元（USD）为单位。您必须以美元报告所有最终的适用数值量，无量纲量则以纯小数报告。不涉及角度。\n\n您的任务：\n1. 对于下述每个测试用例，实现一个函数，在给定 $r$ 的情况下，使用上述原理计算每个资源计划在规划期 $H$ 内的净现值（以美元计）。然后，对于一个指定的折现率网格，确定长寿命计划的净现值严格高于短寿命计划的折现率所占的比例（表示为0到1之间的小数）。如果两者相等（在容差 $\\varepsilon = 10^{-9}$ 范围内），则该比例计为 $0.5$。\n2. 对于每个测试用例，确定盈亏平衡折现率 $r^\\star \\in [0,1)$（如果存在），在该折现率下，长寿命和短寿命计划的净现值相等。如果在 $[0,1)$ 中不存在这样的 $r^\\star$，则返回 $-1.0$。使用基于第一性原理和连续性的稳健数值方法来确定 $r^\\star$。\n3. 灵敏度分析输出：对于每个测试用例，返回一对浮点数：任务1中描述的比例和任务2中的盈亏平衡折现率。最终的程序输出必须将所有测试用例的结果汇总到一行输出中，格式为方括号内包含的逗号分隔列表。数字必须四舍五入到六位小数。\n\n测试套件：\n使用以下三个测试用例的指定参数，以及共同的折现率网格 $R = [0.0, 0.02, 0.05, 0.08, 0.12, 0.20, 0.35]$（无量纲小数）：\n\n- 测试用例1（具有不同寿命和中等现金流的理想路径）：\n    - 规划期：$H = 30$ 年。\n    - 长寿命资源：寿命 $L_{\\mathrm{long}} = 25$ 年，资本成本 $K_{\\mathrm{long}} = 1200$ 美元，年度收益 $B = 220$ 美元/年，年度运营成本 $C_{\\mathrm{long}} = 70$ 美元/年。\n    - 短寿命资源：寿命 $L_{\\mathrm{short}} = 10$ 年，资本成本 $K_{\\mathrm{short}} = 700$ 美元，年度收益 $B = 220$ 美元/年，年度运营成本 $C_{\\mathrm{short}} = 80$ 美元/年。\n\n- 测试用例2（边界主导用例，设计成一个计划可能在所有折现率下都占优）：\n    - 规划期：$H = 30$ 年。\n    - 长寿命资源：寿命 $L_{\\mathrm{long}} = 30$ 年，资本成本 $K_{\\mathrm{long}} = 800$ 美元，年度收益 $B = 230$ 美元/年，年度运营成本 $C_{\\mathrm{long}} = 60$ 美元/年。\n    - 短寿命资源：寿命 $L_{\\mathrm{short}} = 10$ 年，资本成本 $K_{\\mathrm{short}} = 850$ 美元，年度收益 $B = 230$ 美元/年，年度运营成本 $C_{\\mathrm{short}} = 80$ 美元/年。\n\n- 测试用例3（具有多次替换和显著残值的边缘用例）：\n    - 规划期：$H = 30$ 年。\n    - 长寿命资源：寿命 $L_{\\mathrm{long}} = 35$ 年，资本成本 $K_{\\mathrm{long}} = 1500$ 美元，年度收益 $B = 210$ 美元/年，年度运营成本 $C_{\\mathrm{long}} = 70$ 美元/年。\n    - 短寿命资源：寿命 $L_{\\mathrm{short}} = 7$ 年，资本成本 $K_{\\mathrm{short}} = 500$ 美元，年度收益 $B = 210$ 美元/年，年度运营成本 $C_{\\mathrm{short}} = 90$ 美元/年。\n\n科学真实性与一致性：\n- 假设为实际（经通胀调整的）美元。除了按比例残值规则外，不包括税收或折旧。假设每个资源在活跃时具有完美的可靠性和相同的年度服务。\n\n精度和格式要求：\n- 在确定排序时，使用 $\\varepsilon = 10^{-9}$ 作为相等容差。\n- 使用 $r^\\star$ 搜索区间 $[0, 0.9]$。如果在此区间内净现值差异没有观察到符号变化，则返回 $-1.0$。\n- 将所有报告的浮点数四舍五入到六位小数。\n- 您的程序应产生一行输出，其中包含一个方括号内的逗号分隔列表，顺序为：$[\\text{prop}_1, r^\\star_1, \\text{prop}_2, r^\\star_2, \\text{prop}_3, r^\\star_3]$，其中 $\\text{prop}_i$ 是测试用例 $i$ 的比例，而 $r^\\star_i$ 是测试用例 $i$ 的盈亏平衡折现率。\n\n您的实现必须是一个使用任何现代编程语言的完整、可运行的程序。在您的最终答案中，提供一个可执行的Python代码，该代码遵守指定的运行时环境，仅打印所需的单行输出，并且不需要外部输入。",
            "solution": "我们从跨期估值和净现值定义的第一性原理出发。其根本基础是货币的时间价值：由于时间偏好和机会成本，未来收到的一美元在今天的价值较低。设 $r \\in [0,1)$ 表示恒定的实际年折现率。在第 $t$ 年末发生的现金流的现值通过使用 $r$ 进行折现获得，这与现值算子在时间区间上是乘性的，在同一时间发生的现金流上是加性的原则一致。\n\n一个资源计划由参数 $(H, L, K, B, C)$ 定义。每个资源实例从安装到其技术寿命 $L$ 结束期间提供相同的年度服务，此后必须更换以维持服务。在规划期 $H$ 内，当 $y  H$ 时，在第 $y \\in \\{0, L, 2L, \\ldots\\}$ 年进行相同的替换。对于在第 $y$ 年的每次安装，在第 $y$ 年末会产生资本成本 $K$，在每个活跃年份 $t \\in \\{y+1, y+2, \\ldots, \\min(y+L, H)\\}$ 的年末会产生年度净运营现金流 $(B - C)$，并且如果该实例的使用寿命超出了规划期，在 $t = H$ 时会产生代表剩余寿命分数乘以资本成本的残值现金流。\n\n残值是根据按比例剩余寿命估值法得出的。如果在第 $y$ 年进行安装且其技术寿命超出了规划期，那么在 $H$ 年的未到期寿命为 $(y + L - H)$ 年，因此剩余寿命分数为 $\\max\\{y + L - H, 0\\}/L$。在 $t = H$ 时的残值现金流则为：\n$$\nS(y) = K \\cdot \\frac{\\max\\{y + L - H, 0\\}}{L}.\n$$\n这个 $S(y)$ 发生在第 $H$ 年末，与发生在 $t = H$ 的任何其他现金流一样进行折现。\n\n设 $CF_t$ 表示在第 $t$ 年末所有安装合并后的净现金流。根据现金流的可加性和折现下现值的线性，折现率 $r$ 的净现值为：\n$$\n\\mathrm{NPV}(r) = \\sum_{t = 0}^{H} \\frac{CF_t}{(1 + r)^t}.\n$$\n要构建 $CF_t$，对于每次在 $y$ 年的安装：\n- 在 $t = y$ 时：增加 $(-K)$。\n- 对于每个 $t \\in \\{y+1, \\ldots, \\min(y+L, H)\\}$：增加 $(B - C)$。\n- 在 $t = H$ 时：如果 $y + L > H$，增加 $S(y)$。\n\n这种表示方法通过对短寿命资源进行重复安装（以及在需要时对长寿命资源也进行安装），确保了各个计划提供相同的服务。\n\n排序和灵敏度分析定义如下。给定两个计划，长寿命和短寿命，及其各自的参数集，将其净现值定义为函数 $\\mathrm{NPV}_{\\mathrm{long}}(r)$ 和 $\\mathrm{NPV}_{\\mathrm{short}}(r)$。对于一个折现率网格 $R = \\{r_1, r_2, \\ldots, r_m\\}$，计算长寿命计划在净现值上严格占优的折现率比例。形式上，考虑到数值精度，使用相等容差 $\\varepsilon = 10^{-9}$，对每个 $r \\in R$ 定义：\n- 如果 $\\mathrm{NPV}_{\\mathrm{long}}(r) - \\mathrm{NPV}_{\\mathrm{short}}(r) > \\varepsilon$，计数为 $1$。\n- 如果 $|\\mathrm{NPV}_{\\mathrm{long}}(r) - \\mathrm{NPV}_{\\mathrm{short}}(r)| \\le \\varepsilon$，计数为 $0.5$。\n- 否则，计数为 $0$。\n比例是计数总和除以 $|R|$（一个介于0和1之间的纯小数）。\n\n为了计算盈亏平衡折现率 $r^\\star$，考虑连续函数：\n$$\nf(r) = \\mathrm{NPV}_{\\mathrm{long}}(r) - \\mathrm{NPV}_{\\mathrm{short}}(r).\n$$\n在上述假设下，每个 $\\mathrm{NPV}$ 都是形如 $a_t (1 + r)^{-t}$（其中 $a_t$ 为常数）的有限项之和。因此，当后期正现金流占主导且前期负现金流（投资）发生时， $f(r)$ 是关于 $r$ 的连续且严格递减函数，这在资源规划中很常见。一种稳健的数值方法是在观察到符号变化时，即 $f(0) \\cdot f(0.9)  0$ 时，在 $[0, 0.9]$ 上使用二分法。如果 $[0, 0.9]$ 区间内没有符号变化，则该区间内不存在根，我们报告 $-1.0$。当应用二分法时，迭代地将区间二分并在中点评估 $f$，缩小区间直到区间宽度或 $|f(r)|$ 低于一个小的容差；然后我们将中点报告为 $r^\\star$。\n\n算法设计：\n1. 实现一个函数，在给定 $(H, L, K, B, C)$ 和 $r$ 的情况下，通过迭代安装时间 $y \\in \\{0, L, 2L, \\ldots\\}$ 且 $y  H$，并根据 $S(y)$ 加上资本支出、活跃年份至 $H$ 的年度净运营现金流 $(B - C)$ 以及在 $t=H$ 时的残值，来构建序列 $\\{CF_t\\}_{t=0}^{H}$。\n2. 将 $\\mathrm{NPV}(r)$ 计算为 $\\sum_{t=0}^{H} CF_t (1 + r)^{-t}$。注意，当 $r = 0$ 时，折现因子简化为 $1$，总和即为未折现总额。\n3. 对于每个测试用例，使用其各自的参数定义 $\\mathrm{NPV}_{\\mathrm{long}}(r)$ 和 $\\mathrm{NPV}_{\\mathrm{short}}(r)$。对于利率网格 $R = [0.0, 0.02, 0.05, 0.08, 0.12, 0.20, 0.35]$，计算长寿命计划严格占优的利率比例，其中相等情况计为 $0.5$，容差为 $\\varepsilon = 10^{-9}$。\n4. 对于盈亏平衡点 $r^\\star$，评估 $f(0)$ 和 $f(0.9)$。如果存在符号变化，则执行二分法以高精度找到 $r^\\star$（例如，直到区间宽度低于 $10^{-12}$ 或 $|f(r)|$ 低于 $10^{-12}$）。如果没有符号变化，则设置 $r^\\star = -1.0$。\n5. 格式化输出：对于每个测试用例，将比例和 $r^\\star$ 四舍五入到六位小数，并汇总成指定格式的单行输出。\n\n通过一致的年度收益和成本、实际美元折现、通过重复替换来保证交付服务的均等性，以及通过按比例剩余寿命计算残值，来确保科学真实性。该数值方法依赖于现值函数在 $r$ 上的连续性，并使用稳健的区间法进行求根，避免了对无原理捷径的依赖。\n\n最终程序为每个测试用例计算有利于长寿命计划的折现率比例和盈亏平衡折现率（如果不适用则为 $-1.0$），并将它们作为单个方括号内的逗号分隔列表打印出来，四舍五入到六位小数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef build_cash_flows(H: int, L: int, K: float, B: float, C: float) - np.ndarray:\n    \"\"\"\n    Construct the annual cash flow vector CF[0..H] for a resource plan defined by:\n    - Planning horizon H (years)\n    - Lifetime L (years)\n    - Capital cost K (USD)\n    - Annual benefit B (USD/year)\n    - Annual O cost C (USD/year)\n\n    Convention:\n    - All flows occur at year-end.\n    - Installation at year y incurs -K at t=y.\n    - Net operating cash flow (B - C) occurs at end of active years t in [y+1, min(y+L, H)].\n    - Salvage occurs at t=H for installations whose lifetime extends beyond H:\n        S(y) = K * max(y + L - H, 0) / L\n    \"\"\"\n    CF = np.zeros(H + 1, dtype=float)\n    # Installation years: 0, L, 2L, ..., while y  H\n    y = 0\n    while y  H:\n        # Capital outlay at year y\n        CF[y] += -K\n        # Annual net operating cash flows for active years until horizon\n        active_end = min(y + L, H)\n        # Operating flows at end of years y+1 .. active_end\n        if active_end >= y + 1:\n            CF[y + 1:active_end + 1] += (B - C)\n        # Salvage at end of horizon if lifetime extends beyond H\n        if y + L > H:\n            remaining_life = (y + L) - H  # positive if extends beyond H\n            salvage = K * (remaining_life / L)\n            CF[H] += salvage\n        # Next installation\n        y += L\n    return CF\n\ndef npv_of_plan(CF: np.ndarray, r: float) - float:\n    \"\"\"\n    Compute NPV given cash flow vector CF[0..H] and discount rate r in [0,1).\n    All flows are at year-end, discounted by (1 + r)^t.\n    \"\"\"\n    H = len(CF) - 1\n    if r == 0.0:\n        return float(np.sum(CF))\n    # Use stable computation for discount factors\n    t = np.arange(H + 1, dtype=float)\n    discount = np.power(1.0 + r, -t)\n    return float(np.dot(CF, discount))\n\ndef proportion_long_wins(npv_long, npv_short, rates, eps=1e-9) - float:\n    \"\"\"\n    Compute the proportion of rates where long-lived plan wins:\n    - Count 1 if NPV_long - NPV_short > eps\n    - Count 0.5 if abs difference = eps\n    - Count 0 if NPV_long - NPV_short  -eps\n    Return sum(counts) / len(rates).\n    \"\"\"\n    total = 0.0\n    for r in rates:\n        dl = npv_long(r)\n        ds = npv_short(r)\n        diff = dl - ds\n        if diff > eps:\n            total += 1.0\n        elif abs(diff) = eps:\n            total += 0.5\n        else:\n            total += 0.0\n    return total / len(rates)\n\ndef break_even_rate(npv_long, npv_short, r_low=0.0, r_high=0.9, tol=1e-12, max_iter=200) - float:\n    \"\"\"\n    Find r* in [r_low, r_high] such that NPV_long(r*) == NPV_short(r*),\n    using bisection if a sign change exists. If no sign change, return -1.0.\n    \"\"\"\n    def f(r):\n        return npv_long(r) - npv_short(r)\n    f_low = f(r_low)\n    f_high = f(r_high)\n    # If no sign change, no root in [r_low, r_high]\n    if f_low == 0.0:\n        return r_low\n    if f_high == 0.0:\n        return r_high\n    if f_low * f_high > 0.0:\n        return -1.0\n    a, b = r_low, r_high\n    fa, fb = f_low, f_high\n    for _ in range(max_iter):\n        m = 0.5 * (a + b)\n        fm = f(m)\n        # Check convergence\n        if abs(fm)  tol or (b - a)  tol:\n            return m\n        # Update bracket\n        if fa * fm = 0.0:\n            b, fb = m, fm\n        else:\n            a, fa = m, fm\n    # Return midpoint after max_iter\n    return 0.5 * (a + b)\n\ndef format_float(x: float) - str:\n    return f\"{x:.6f}\"\n\ndef solve():\n    # Define discount rate grid\n    rates = [0.0, 0.02, 0.05, 0.08, 0.12, 0.20, 0.35]\n\n    # Test cases parameters\n    test_cases = [\n        # (H, (L_long, K_long, B, C_long), (L_short, K_short, B, C_short))\n        (30, (25, 1200.0, 220.0, 70.0), (10, 700.0, 220.0, 80.0)),  # Test Case 1\n        (30, (30, 800.0, 230.0, 60.0), (10, 850.0, 230.0, 80.0)),  # Test Case 2\n        (30, (35, 1500.0, 210.0, 70.0), (7, 500.0, 210.0, 90.0)),  # Test Case 3\n    ]\n\n    results = []\n    for case in test_cases:\n        H, long_params, short_params = case\n        L_long, K_long, B_long, C_long = long_params\n        L_short, K_short, B_short, C_short = short_params\n\n        # Build cash flows for both plans\n        CF_long = build_cash_flows(H, L_long, K_long, B_long, C_long)\n        CF_short = build_cash_flows(H, L_short, K_short, B_short, C_short)\n\n        # Define NPV functions as closures over r\n        npv_long = lambda r, CF=CF_long: npv_of_plan(CF, r)\n        npv_short = lambda r, CF=CF_short: npv_of_plan(CF, r)\n\n        # Proportion of rates where long-lived wins\n        prop = proportion_long_wins(npv_long, npv_short, rates, eps=1e-9)\n\n        # Break-even discount rate via bisection on [0, 0.9]\n        r_star = break_even_rate(npv_long, npv_short, r_low=0.0, r_high=0.9, tol=1e-12, max_iter=200)\n\n        results.append(format_float(prop))\n        results.append(format_float(r_star))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "现实世界的规划必须应对未来的不确定性，例如燃料价格、负荷增长和政策变化。这项高级实践介绍了两阶段随机规划，这是一个强大的框架，用于制定稳健的“当前”容量投资决策，这些决策在一系列可能的未来“届时”运营情景下进行了优化。",
            "id": "4097963",
            "problem": "考虑一个用于电力系统的两阶段随机综合资源规划模型，该系统包含三种发电技术：天然气、风能和太阳能。第一阶段选择以兆瓦 (MW) 为单位的装机容量，第二阶段在燃料价格、负荷增长和政策参数存在不确定性的情况下，运营这些容量以满足以兆瓦时 (MWh) 为单位的能源需求。所有数量和常数必须使用指定的单位进行处理，所有最终成本输出必须以美元表示。\n\n基本基准和定义：\n- 设技术集合为 $\\mathcal{T} = \\{\\text{天然气}, \\text{风能}, \\text{太阳能}\\}$。\n- 设时间块集合为 $\\mathcal{H} = \\{\\text{高峰}, \\text{非高峰}\\}$，其中小时数 $H_{\\text{高峰}} = 2000$ 且 $H_{\\text{非高峰}} = 6760$，因此 $H_{\\text{高峰}} + H_{\\text{非高峰}} = 8760$。\n- 基础平均需求为 $D_{\\text{高峰}} = 500$ 兆瓦 (MW) 和 $D_{\\text{非高峰}} = 300$ 兆瓦 (MW)，由此得出基础能源需求为 $E_{\\text{高峰}}^{\\text{基础}} = D_{\\text{高峰}} \\cdot H_{\\text{高峰}} = 1{,}000{,}000$ 兆瓦时 (MWh) 和 $E_{\\text{非高峰}}^{\\text{基础}} = D_{\\text{非高峰}} \\cdot H_{\\text{非高峰}} = 2{,}028{,}000$ 兆瓦时 (MWh)。特定情景的能源需求按负荷增长因子 $g_s$ 进行缩放，因此对于 $h \\in \\mathcal{H}$，$E_{s,h} = g_s \\cdot E_{h}^{\\text{基础}}$。\n\n技术参数：\n- 年化固定容量成本（每兆瓦年）为 $C_{\\text{天然气}}^{\\text{容量}} = 100{,}000$ 美元/兆瓦年，$C_{\\text{风能}}^{\\text{容量}} = 200{,}000$ 美元/兆瓦年，$C_{\\text{太阳能}}^{\\text{容量}} = 150{,}000$ 美元/兆瓦年。\n- 可变运行和维护 (OM) 成本（每兆瓦时，不包括情景燃料价格和政策成本）为 $c_{\\text{天然气}}^{\\text{运维}} = 5$ 美元/兆瓦时，$c_{\\text{风能}}^{\\text{运维}} = 3$ 美元/兆瓦时，$c_{\\text{太阳能}}^{\\text{运维}} = 2$ 美元/兆瓦时。\n- 天然气的二氧化碳排放率为 $e_{\\text{天然气}} = 0.4$ 吨二氧化碳/兆瓦时。风能和太阳能的排放为零。\n- 可用性（按时间块划分的容量因子）为 $a_{\\text{天然气},\\text{高峰}} = 0.9$，$a_{\\text{天然气},\\text{非高峰}} = 0.9$，$a_{\\text{风能},\\text{高峰}} = 0.35$，$a_{\\text{风能},\\text{非高峰}} = 0.45$，$a_{\\text{太阳能},\\text{高峰}} = 0.2$，$a_{\\text{太阳能},\\text{非高峰}} = 0.05$。\n\n情景构建：\n- 设情景空间为三个集合的笛卡尔积：天然气燃料的燃料价格情景 $\\mathcal{F}$（单位：美元/兆瓦时）、负荷增长因子 $\\mathcal{G}$（对基础能源的无量纲乘数）以及政策情景 $\\mathcal{P}$（由碳税 $p^{\\text{CO2}}$（单位：美元/吨）和年度排放上限 $E^{\\text{上限}}$（单位：吨）组成）。每个情景 $s$ 是一个元组 $(f_s, g_s, p_s^{\\text{CO2}}, E_s^{\\text{上限}})$，具有相关概率 $\\pi_s$。假设集合之间相互独立，因此每个情景的概率是各组成部分概率的乘积，并等于笛卡尔积上的均匀概率。\n\n两阶段随机规划：\n- 第一阶段决策变量是装机容量 $x_t \\ge 0$，单位为兆瓦 (MW)，其中 $t \\in \\mathcal{T}$。\n- 第二阶段决策变量是能源调度 $y_{t,s,h} \\ge 0$，单位为兆瓦时 (MWh)，其中 $t \\in \\mathcal{T}$，$s$ 属于情景集 $\\mathcal{S}$，$h \\in \\mathcal{H}$。\n\n目标函数（最小化预期年度总成本）：\n$$\n\\min_{x, y} \\quad \\sum_{t \\in \\mathcal{T}} C_t^{\\text{cap}} \\, x_t \\;+\\; \\sum_{s \\in \\mathcal{S}} \\pi_s \\left( \\sum_{h \\in \\mathcal{H}} \\left[ \\left(c_{\\text{gas}}^{\\text{om}} + f_s + p_s^{\\text{CO2}} \\, e_{\\text{gas}}\\right) y_{\\text{gas},s,h} + c_{\\text{wind}}^{\\text{om}} \\, y_{\\text{wind},s,h} + c_{\\text{solar}}^{\\text{om}} \\, y_{\\text{solar},s,h} \\right] \\right)\n$$\n\n每个情景 $s \\in \\mathcal{S}$ 和时间块 $h \\in \\mathcal{H}$ 的约束条件：\n1. 能量平衡：\n$$\n\\sum_{t \\in \\mathcal{T}} y_{t,s,h} = E_{s,h}.\n$$\n2. 容量到能量的可用性（按技术和时间块）：\n$$\ny_{t,s,h} \\le x_t \\cdot a_{t,h} \\cdot H_h, \\quad \\forall t \\in \\mathcal{T}.\n$$\n3. 年度排放上限：\n$$\ne_{\\text{gas}} \\sum_{h \\in \\mathcal{H}} y_{\\text{gas},s,h} \\le E_s^{\\text{cap}}.\n$$\n4. 非负性：\n$$\nx_t \\ge 0, \\quad y_{t,s,h} \\ge 0.\n$$\n\n此公式强制执行了非预期性，因为第一阶段的容量 $x_t$ 在所有情景中是共享的。该模型是线性的，可以通过将其转换为其确定性等价线性规划，并使用标准线性规划求解器进行求解。\n\n数值测试套件：\n实施该程序以计算以下三个测试案例中每个案例的最小预期年度成本（以美元计）。使用列出的确切值，并假设笛卡尔积上的概率是均匀的。\n\n- 测试案例 1（均衡不确定性）：\n  - 燃料价格情景 $\\mathcal{F} = \\{20, 40\\}$ 美元/兆瓦时（天然气）。\n  - 负荷增长因子 $\\mathcal{G} = \\{1.0, 1.1\\}$（无量纲）。\n  - 政策情景 $\\mathcal{P} = \\{(p^{\\text{CO2}} = 0, E^{\\text{cap}} = 2{,}000{,}000),\\; (p^{\\text{CO2}} = 50, E^{\\text{cap}} = 1{,}200{,}000)\\}$，其中碳税单位为美元/吨，上限单位为吨。\n  - 8个情景中每个情景的概率为 $\\pi_s = 0.125$。\n\n- 测试案例 2（严格的排放上限）：\n  - 燃料价格情景 $\\mathcal{F} = \\{25, 35\\}$ 美元/兆瓦时（天然气）。\n  - 负荷增长因子 $\\mathcal{G} = \\{1.0, 1.2\\}$（无量纲）。\n  - 政策情景 $\\mathcal{P} = \\{(p^{\\text{CO2}} = 100, E^{\\text{cap}} = 400{,}000)\\}$。\n  - 4个情景中每个情景的概率为 $\\pi_s = 0.25$。\n\n- 测试案例 3（廉价天然气，宽松政策）：\n  - 燃料价格情景 $\\mathcal{F} = \\{10\\}$ 美元/兆瓦时（天然气）。\n  - 负荷增长因子 $\\mathcal{G} = \\{0.95, 1.0\\}$（无量纲）。\n  - 政策情景 $\\mathcal{P} = \\{(p^{\\text{CO2}} = 0, E^{\\text{cap}} = 5{,}000{,}000)\\}$。\n  - 2个情景中每个情景的概率为 $\\pi_s = 0.5$。\n\n要求的最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。每个条目必须是一个浮点数，给出相应测试案例的最小预期年度成本（以美元计），按测试案例 1、测试案例 2 和测试案例 3 的顺序排列，并四舍五入到小数点后两位。例如，格式必须与 $[c_1,c_2,c_3]$ 完全一样，其中 $c_1$、$c_2$ 和 $c_3$ 是计算出的成本（以美元计）。",
            "solution": "问题陈述已经过验证，被确定为一个定义明确、有科学依据且客观的两阶段随机线性规划问题。所有必要的数据和定义都已提供，没有矛盾或含糊之处。该问题属于能源系统建模的标准框架，特别是关于不确定性下的综合资源规划。\n\n该问题旨在通过对发电容量投资（第一阶段）和随后的运营调度（第二阶段）在一系列可能的未来情景中做出最优决策，来找到电力系统的最小预期年度总成本。解决方案包括将此随机规划问题表述为一个确定性等价线性规划（LP），并使用标准 LP 求解器进行求解。\n\n**模型构建：确定性等价 LP**\n\n两阶段随机规划通过构建一个单一的大规模确定性等价 LP 来求解，该 LP 同时表示所有情景下的所有决策。非预期性约束（第一阶段决策必须在不确定性揭晓之前做出，因此对所有情景必须相同）通过只设一组第一阶段变量而得到隐式执行。\n\n**决策变量**\n\n确定性等价 LP 的决策变量被排列成一个单一向量，记为 $\\mathbf{z}$。该向量是第一阶段和第二阶段变量的串联。\n- **第一阶段变量**：每种技术 $t \\in \\mathcal{T} = \\{\\text{天然气}, \\text{风能}, \\text{太阳能}\\}$ 的装机容量 $x_t$。共有 $|\\mathcal{T}| = 3$ 个此类变量。\n- **第二阶段变量**：每种技术 $t \\in \\mathcal{T}$、每个情景 $s \\in \\mathcal{S}$ 和每个时间块 $h \\in \\mathcal{H} = \\{\\text{高峰}, \\text{非高峰}\\}$ 的能源调度 $y_{t,s,h}$。情景总数 $|\\mathcal{S}|$ 对每个测试案例都不同。第二阶段变量的数量为 $|\\mathcal{T}| \\times |\\mathcal{S}| \\times |\\mathcal{H}| = 3 \\times |\\mathcal{S}| \\times 2 = 6|\\mathcal{S}|$。\n\n完整的决策变量向量为 $\\mathbf{z} = [x_{\\text{gas}}, x_{\\text{wind}}, x_{\\text{solar}}, \\dots, y_{t,s,h}, \\dots]^T$，总共有 $3 + 6|\\mathcal{S}|$ 个变量。\n\n**目标函数**\n\n目标是最小化预期年度总成本，即第一阶段投资成本与第二阶段运营成本的概率加权平均值之和。LP 目标函数表示为 $\\min \\mathbf{c}^T \\mathbf{z}$，其中 $\\mathbf{c}$ 是成本向量。\n\n- **投资成本系数**：$\\mathbf{c}$ 中与容量变量 $x_t$ 对应的元素是年化固定容量成本 $C_{t}^{\\text{cap}}$。\n- **运营成本系数**：$\\mathbf{c}$ 中与调度变量 $y_{t,s,h}$ 对应的元素是其边际运营成本，按情景概率 $\\pi_s$ 加权。对于给定的情景 $s=(f_s, g_s, p_s^{\\text{CO2}}, E_s^{\\text{cap}})$，可变成本为：\n    -   天然气：$c_{\\text{gas},s}^{\\text{var}} = c_{\\text{gas}}^{\\text{om}} + f_s + p_s^{\\text{CO2}} e_{\\text{gas}}$\n    -   风能：$c_{\\text{wind},s}^{\\text{var}} = c_{\\text{wind}}^{\\text{om}}$\n    -   太阳能：$c_{\\text{solar},s}^{\\text{var}} = c_{\\text{solar}}^{\\text{om}}$\n在 $\\mathbf{c}$ 中，变量 $y_{t,s,h}$ 对应的系数为 $\\pi_s \\cdot c_{t,s}^{\\text{var}}$。\n\n**约束条件**\n\n问题约束被转换为 LP 求解器所需的矩阵形式。它们分为等式约束（$\\mathbf{A}_{\\text{eq}} \\mathbf{z} = \\mathbf{b}_{\\text{eq}}$）和不等式约束（$\\mathbf{A}_{\\text{ub}} \\mathbf{z} \\le \\mathbf{b}_{\\text{ub}}$）。\n\n1.  **能量平衡（等式约束）**：对于每个情景 $s$ 和时间块 $h$，总调度能量必须等于能源需求 $E_{s,h} = g_s E_{h}^{\\text{base}}$。\n    $$ \\sum_{t \\in \\mathcal{T}} y_{t,s,h} = E_{s,h} \\quad \\forall s \\in \\mathcal{S}, h \\in \\mathcal{H} $$\n    这产生 $2|\\mathcal{S}|$ 个等式约束。$\\mathbf{A}_{\\text{eq}}$ 中对应于特定 $(s,h)$ 对的每一行，其变量 $y_{t,s,h}$（对于所有 $t \\in \\mathcal{T}$）的系数为 $1$，其他地方为 $0$。$\\mathbf{b}_{\\text{eq}}$ 中的对应元素将是 $E_{s,h}$。\n\n2.  **容量到能量的可用性（不等式约束）**：在给定时间块内，一项技术的调度能量不能超过其可用能量潜力，该潜力是其装机容量 $x_t$、可用性因子 $a_{t,h}$ 和时间块持续时间 $H_h$ 的函数。\n    $$ y_{t,s,h} \\le x_t \\cdot a_{t,h} \\cdot H_h \\implies y_{t,s,h} - (a_{t,h} H_h) x_t \\le 0 \\quad \\forall t \\in \\mathcal{T}, s \\in \\mathcal{S}, h \\in \\mathcal{H} $$\n    这产生 $6|\\mathcal{S}|$ 个不等式约束。$\\mathbf{A}_{\\text{ub}}$ 中的每一行，其变量 $y_{t,s,h}$ 的系数为 $1$，变量 $x_t$ 的系数为 $-a_{t,h} H_h$，其他地方为 $0$。$\\mathbf{b}_{\\text{ub}}$ 中的对应元素将是 $0$。\n\n3.  **年度排放上限（不等式约束）**：对于每个情景 $s$，天然气发电产生的年度二氧化碳总排放量不得超过特定情景的上限 $E_s^{\\text{cap}}$。\n    $$ e_{\\text{gas}} \\sum_{h \\in \\mathcal{H}} y_{\\text{gas},s,h} \\le E_s^{\\text{cap}} \\quad \\forall s \\in \\mathcal{S} $$\n    这产生 $|\\mathcal{S}|$ 个不等式约束。对于每个情景 $s$，$\\mathbf{A}_{\\text{ub}}$ 中的对应行，其变量 $y_{\\text{gas},s,\\text{peak}}$ 和 $y_{\\text{gas},s,\\text{offpeak}}$ 的系数为 $e_{\\text{gas}}$，其他地方为 $0$。$\\mathbf{b}_{\\text{ub}}$ 中的对应元素将是 $E_s^{\\text{cap}}$。\n\n4.  **非负性**：所有容量和调度变量必须为非负。这通过在 LP 求解器中为所有变量设置一个 $0$ 的下界来处理。\n\n**实施**\n\n算法实施涉及编写一个函数，该函数针对每个测试案例执行以下操作：\n1.  从给定的不确定性集合 $\\mathcal{F}$、$\\mathcal{G}$ 和 $\\mathcal{P}$ 的笛卡尔积中，生成完整的情景集合 $\\mathcal{S}$ 及其概率 $\\pi_s$。\n2.  动态构建确定性等价 LP 的组成部分：成本向量 $\\mathbf{c}$、等式约束矩阵 $\\mathbf{A}_{\\text{eq}}$ 和向量 $\\mathbf{b}_{\\text{eq}}$，以及不等式约束矩阵 $\\mathbf{A}_{\\text{ub}}$ 和向量 $\\mathbf{b}_{\\text{ub}}$。使用 `NumPy` 进行高效的矩阵和向量运算。\n3.  将这些组件传递给 `scipy.optimize.linprog` 函数。该函数使用 'highs' 求解器来解决 LP，该求解器非常适合此类问题。\n4.  求解器返回的最优目标函数值 `result.fun` 代表最小的预期年度总成本（以美元计）。然后按要求格式化此值。\n\n对三个测试案例中的每一个重复此过程，并将最终结果收集并以指定格式打印。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import linprog\nfrom itertools import product\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and orchestrate the solution process.\n    \"\"\"\n    test_cases = [\n        # Test Case 1 (balanced uncertainties)\n        {\n            'F': [20.0, 40.0],\n            'G': [1.0, 1.1],\n            'P': [(0.0, 2_000_000.0), (50.0, 1_200_000.0)]\n        },\n        # Test Case 2 (tight emissions cap)\n        {\n            'F': [25.0, 35.0],\n            'G': [1.0, 1.2],\n            'P': [(100.0, 400_000.0)]\n        },\n        # Test Case 3 (cheap gas, lax policy)\n        {\n            'F': [10.0],\n            'G': [0.95, 1.0],\n            'P': [(0.0, 5_000_000.0)]\n        },\n    ]\n\n    results = []\n    for params in test_cases:\n        cost = solve_irp_case(params['F'], params['G'], params['P'])\n        results.append(f\"{cost:.2f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\ndef solve_irp_case(f_scenarios, g_scenarios, p_scenarios):\n    \"\"\"\n    Solves the two-stage stochastic IRP for a given set of scenario parameters.\n    \"\"\"\n    # --- Define Problem Constants ---\n    TECH_MAP = {'gas': 0, 'wind': 1, 'solar': 2}\n    NUM_TECHS = 3\n    NUM_BLOCKS = 2\n\n    H = np.array([2000.0, 6760.0])  # hours per block\n    E_base = np.array([1_000_000.0, 2_028_000.0])  # MWh per block\n    C_cap = np.array([100_000.0, 200_000.0, 150_000.0])  # $/MW-year\n    c_om = np.array([5.0, 3.0, 2.0])  # $/MWh\n    e_gas = 0.4  # tCO2/MWh\n\n    availability = np.array([\n        [0.9, 0.9],    # gas\n        [0.35, 0.45],  # wind\n        [0.2, 0.05]    # solar\n    ])\n\n    # 1. Generate scenarios from Cartesian product\n    scenarios = list(product(f_scenarios, g_scenarios, p_scenarios))\n    num_scenarios = len(scenarios)\n    pi_s = 1.0 / num_scenarios\n\n    # 2. Define LP problem dimensions\n    num_x_vars = NUM_TECHS\n    num_y_vars = num_scenarios * NUM_BLOCKS * NUM_TECHS\n    num_vars = num_x_vars + num_y_vars\n\n    def y_idx(s_idx, h_idx, t_idx):\n        # Helper to map (scenario, block, tech) to flat index for y variables\n        return num_x_vars + s_idx * (NUM_BLOCKS * NUM_TECHS) + h_idx * NUM_TECHS + t_idx\n\n    # 3. Construct objective function vector c\n    c = np.zeros(num_vars)\n    c[:num_x_vars] = C_cap  # First-stage capacity costs\n\n    for s_idx, (f_s, g_s, (p_co2_s, E_cap_s)) in enumerate(scenarios):\n        var_cost_gas = c_om[0] + f_s + p_co2_s * e_gas\n        var_costs_s = np.array([var_cost_gas, c_om[1], c_om[2]])\n        for h_idx in range(NUM_BLOCKS):\n            for t_idx in range(NUM_TECHS):\n                idx = y_idx(s_idx, h_idx, t_idx)\n                c[idx] = pi_s * var_costs_s[t_idx]\n\n    # 4. Construct equality constraints (energy balance)\n    num_eq_constraints = num_scenarios * NUM_BLOCKS\n    A_eq = np.zeros((num_eq_constraints, num_vars))\n    b_eq = np.zeros(num_eq_constraints)\n    eq_row = 0\n    for s_idx, (_, g_s, _) in enumerate(scenarios):\n        for h_idx in range(NUM_BLOCKS):\n            b_eq[eq_row] = g_s * E_base[h_idx]\n            for t_idx in range(NUM_TECHS):\n                A_eq[eq_row, y_idx(s_idx, h_idx, t_idx)] = 1.0\n            eq_row += 1\n\n    # 5. Construct inequality constraints (capacity  emissions)\n    num_ineq_cap = num_y_vars\n    num_ineq_emissions = num_scenarios\n    num_ineq_constraints = num_ineq_cap + num_ineq_emissions\n    A_ub = np.zeros((num_ineq_constraints, num_vars))\n    b_ub = np.zeros(num_ineq_constraints)\n    \n    # Capacity constraints: y_tsh - x_t * a_th * H_h = 0\n    ineq_row = 0\n    for s_idx in range(num_scenarios):\n        for h_idx in range(NUM_BLOCKS):\n            for t_idx in range(NUM_TECHS):\n                A_ub[ineq_row, y_idx(s_idx, h_idx, t_idx)] = 1.0\n                A_ub[ineq_row, t_idx] = -availability[t_idx, h_idx] * H[h_idx]\n                ineq_row += 1 # b_ub is 0 by default\n\n    # Emissions constraints: e_gas * sum(y_gas,s,h over h) = E_cap_s\n    for s_idx, (_, _, (_, E_cap_s)) in enumerate(scenarios):\n        b_ub[ineq_row] = E_cap_s\n        # y_gas,s,peak\n        A_ub[ineq_row, y_idx(s_idx, 0, TECH_MAP['gas'])] = e_gas\n        # y_gas,s,offpeak\n        A_ub[ineq_row, y_idx(s_idx, 1, TECH_MAP['gas'])] = e_gas\n        ineq_row += 1\n\n    # 6. Define bounds (all variables are non-negative)\n    bounds = (0, None)\n\n    # 7. Solve the Linear Program\n    result = linprog(c, A_ub=A_ub, b_ub=b_ub, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')\n    \n    if not result.success:\n        # It's good practice to check if the solver succeeded.\n        raise RuntimeError(f\"LP solver failed for a test case. Status: {result.message}\")\n\n    return result.fun\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}