{
    "hands_on_practices": [
        {
            "introduction": "在跨学科建模中，一个常见但至关重要的陷阱是单位处理不当。例如，能量模型和气候模型可能使用不同的单位来量化碳排放（如 $\\text{MtCO}_2$ 与 $\\text{MtC}$）。本练习将演示如何量化这种单位不匹配导致的误差，并强调建立自动化验证检查以从根本上防止此类问题的重要性。",
            "id": "4081500",
            "problem": "一个综合评估模型 (IAM) 将一个能源系统模块与一个碳循环气候模块耦合起来。气候模块期望的输入单位是百万吨碳 ($\\text{MtC}$)，而能源系统模块报告的年排放量单位是百万吨二氧化碳 ($\\text{MtCO}_2$)。从$2020$年到$2024$年，能源系统模块报告的年 $\\mathrm{CO}_2$ 排放量 $E_t$（单位：$\\text{MtCO}_2$）如下：$E_{2020} = 2750$，$E_{2021} = 2820$，$E_{2022} = 2895$，$E_{2023} = 2970$，$E_{2024} = 3050$。由于一个单位处理的错误（bug），在$2022$年和$2023$年期间，耦合器在没有进行单位转换的情况下，将这些数值直接传递给了气候模块；在其他年份，转换被正确执行。假设原子质量为 $M_{\\mathrm{C}} = 12\\,\\mathrm{g/mol}$ 和 $M_{\\mathrm{O}} = 16\\,\\mathrm{g/mol}$，并且排放物仅由二氧化碳 ($\\mathrm{CO}_2$) 组成。仅使用质量守恒和分子组成的第一性原理，计算在$2020$–$2024$年期间，气候模块实际积分的累积排放量与物理上正确的累积排放量之间的差异，并以十亿吨二氧化碳 ($\\text{GtCO}_2$) 为单位表示您的最终答案。将您的答案四舍五入到四位有效数字。\n\n另外，请提出一个基于质量守恒和单位一致性的耦合诊断的简明验证清单，该清单应能在模拟运行前捕获这种不一致性。您的清单应基于第一性原理进行论证，而非临时的启发式方法。",
            "solution": "问题陈述被评估为具有科学依据、问题明确、客观且内部一致。它描述了综合评估建模中的一个现实场景，涉及单位转换错误，并要求基于化学第一性原理进行计算，以及基于软件验证原则提出程序性建议。所有必要的数据都已提供。该问题是有效的。\n\n根据要求，解决方案分为两部分阐述。\n\n第一部分：排放差异的计算\n\n问题的核心在于二氧化碳 ($\\text{CO}_2$) 的质量与其所含碳 ($\\text{C}$) 的质量之间的转换。这种关系由它们的摩尔质量之比决定。\n\n首先，我们使用给定的原子质量 $M_{\\mathrm{C}} = 12\\,\\mathrm{g/mol}$ 和 $M_{\\mathrm{O}} = 16\\,\\mathrm{g/mol}$ 来确定摩尔质量。\n碳的摩尔质量为 $M_{\\mathrm{C}} = 12\\,\\mathrm{g/mol}$。\n二氧化碳是一个含有一个碳原子和两个氧原子的分子，其摩尔质量为：\n$$M_{\\mathrm{CO}_2} = M_{\\mathrm{C}} + 2 \\times M_{\\mathrm{O}} = 12 + 2 \\times 16 = 12 + 32 = 44\\,\\mathrm{g/mol}$$\n\n根据定比定律，在任何纯 $\\text{CO}_2$ 样品中，碳的质量与二氧化碳的质量之比是恒定的，等于它们的摩尔质量之比。设此转换因子为 $k_C$：\n$$k_C = \\frac{\\text{Mass of C}}{\\text{Mass of CO}_2} = \\frac{M_{\\mathrm{C}}}{M_{\\mathrm{CO}_2}} = \\frac{12}{44} = \\frac{3}{11}$$\n这是用于将 $\\text{CO}_2$ 的质量转换为相应 $\\text{C}$ 质量的因子。气候模块正确地期望以百万吨碳 ($\\text{MtC}$) 为单位的输入，这应通过将能源系统的输出（单位：百万吨二氧化碳, $\\text{MtCO}_2$）乘以 $k_C$ 来获得。\n\n差异仅发生在未执行单位转换的年份，即 $2022$ 年和 $2023$ 年。在这些年份，以 $\\text{MtCO}_2$ 为单位的排放数值（我们称之为 $E_t$）被气候模块错误地解释为以 $\\text{MtC}$ 为单位的质量。\n\n对于存在错误的年份 $t$，本应积分的物理上正确的碳质量为 $C_t^{\\text{correct}} = E_t \\times k_C$。\n实际被积分的碳质量为 $C_t^{\\text{actual}} = E_t$。\n\n该年积分碳的差异或误差为两者之差：\n$$\\Delta C_t = C_t^{\\text{actual}} - C_t^{\\text{correct}} = E_t - E_t \\times k_C = E_t \\left(1 - k_C\\right)$$\n$$\\Delta C_t = E_t \\left(1 - \\frac{12}{44}\\right) = E_t \\left(\\frac{32}{44}\\right) = E_t \\left(\\frac{8}{11}\\right)$$\n这表示在受错误影响的给定年份 $t$ 中，气候模型对碳质量的高估。\n\n问题指出错误发生在 $2022$ 年和 $2023$ 年。这些年份的排放数据为 $E_{2022} = 2895\\,\\text{MtCO}_2$ 和 $E_{2023} = 2970\\,\\text{MtCO}_2$。\n整个时期内积分碳的总差异 $\\Delta C_{\\text{total}}$ 是错误年份差异的总和：\n$$\\Delta C_{\\text{total}} = \\Delta C_{2022} + \\Delta C_{2023} = (E_{2022} + E_{2023}) \\left(1 - \\frac{12}{44}\\right)$$\n$$\\Delta C_{\\text{total}} = (2895 + 2970) \\left(\\frac{8}{11}\\right) = 5865 \\times \\frac{8}{11} = \\frac{46920}{11}\\,\\text{MtC}$$\n这个值，$\\Delta C_{\\text{total}} \\approx 4265.45\\,\\text{MtC}$，是由于该错误导致气候模块积分的总超额碳质量。\n\n问题要求将此差异以十亿吨二氧化碳 ($\\text{GtCO}_2$) 表示。这意味着我们必须找出含有超额碳质量 $\\Delta C_{\\text{total}}$ 的 $\\text{CO}_2$ 的质量。这需要进行逆转换，即乘以 $\\frac{M_{\\mathrm{CO}_2}}{M_C} = \\frac{44}{12}$。\n设 $\\Delta E_{\\text{equiv}}$ 是表示为等效 $\\text{CO}_2$ 质量的差异。\n$$\\Delta E_{\\text{equiv}} = \\Delta C_{\\text{total}} \\times \\frac{M_{\\mathrm{CO}_2}}{M_C} = \\left(5865 \\times \\frac{8}{11}\\right) \\times \\frac{44}{12}$$\n$$\\Delta E_{\\text{equiv}} = 5865 \\times \\frac{8}{11} \\times \\frac{11 \\times 4}{3 \\times 4} = 5865 \\times \\frac{8}{3}$$\n$$\\Delta E_{\\text{equiv}} = 1955 \\times 8 = 15640\\,\\text{MtCO}_2$$\n这是以百万吨二氧化碳为单位的差异量级。\n\n最后，我们将其转换为十亿吨 ($\\text{GtCO}_2$) 并应用要求的四舍五入。由于 $1\\,\\text{Gt} = 1000\\,\\text{Mt}$：\n$$\\Delta E_{\\text{equiv}} = \\frac{15640}{1000}\\,\\text{GtCO}_2 = 15.640\\,\\text{GtCO}_2$$\n问题要求将答案四舍五入到四位有效数字。计算出的值 $15.640$ 有五位有效数字。四舍五入到四位有效数字得到 $15.64$。\n\n第二部分：耦合诊断的验证清单\n\n一个稳健的、基于质量守恒和单位一致性第一性原理的验证清单，对于在耦合模型系统中防止此类错误至关重要。\n\n1.  接口单位断言：模块间交换的所有数据量必须以编程方式用其物理单位进行标记（例如，作为数据结构或元数据的一部分）。在进行任何处理之前，接收模块或耦合组件必须断言传入数据的单位标记与预期单位匹配。如果存在不匹配，模拟必须以描述性错误终止。\n    *   第一性原理依据：这项检查强制执行了单位一致性的基本原则。一个物理量没有其单位是无意义的。该诊断将单位视为数据的组成部分，防止将代表物理上不同量（例如 $\\text{CO}_2$ 质量与 $\\text{C}$ 质量）的数值错误地混为一谈。\n\n2.  质量守恒转换检查：任何执行涉及守恒物质（如将 $\\text{CO}_2$ 质量转换为 $\\text{C}$ 质量）的单位转换的模块或耦合器，必须立即执行“往返”验证。在将输入量 $A$ 转换为输出量 $B$ 之后，它必须对 $B$ 应用逆转换以计算 $A'$。然后它必须断言 $A$ 和 $A'$ 在一个小的数值容差内相等，即 $|A-A'|/|A|  \\epsilon$。\n    *   第一性原理依据：这项检查是质量守恒的直接实现。化合物质量与其组成元素之一的质量之间的转换是质量守恒的体现。往返计算创建了一个代数不变量 ($A = A'$)，如果转换正确地嵌入了此物理定律，则该不变量必须成立。在给定的问题中，此检查将灾难性地失败：$E' = C \\times \\frac{44}{12} = E \\times \\frac{44}{12} \\neq E$。\n\n3.  全系统质量平衡审计：在模拟的固定时间间隔或检查点，必须执行自动审计。该审计将源模块（能源系统）排放的守恒物质（碳）的总质量相加，并将其与汇模块（气候模型）接收的该物质的总质量进行比较。这两个累积量的比率必须等于 $1$。\n    *   第一性原理依据：这将检查从单个转换提升到对质量守恒的集成系统级验证。它确保在模拟过程中数据管道的任何地方都没有“创造”或“销毁”质量，从而防范更微妙的错误，如数据包丢失、浮点误差累积或仅随时间推移才显现的错误。",
            "answer": "$$\n\\boxed{15.64}\n$$"
        },
        {
            "introduction": "在将具有不同原生时间步长的模型进行“松散耦合”时，一个核心的设计决策是如何平衡通信开销（计算成本）和插值误差（准确性）。本练习提供了一种基于第一性原理的方法来优化这一权衡。你将学习如何根据气候变量的平滑度（由其二阶导数的界限来表征）和可容忍的误差范围，来确定最佳的通信频率。",
            "id": "4081556",
            "problem": "给定两个时间步进模拟器：一个原生时间步长为 $\\Delta t_{e} = 1 \\ \\text{小时}$ 的能量模型 (EM) 和一个原生时间步长为 $\\Delta t_{c} = 6 \\ \\text{小时}$ 的气候模型 (CM)。目标是为一次为期一年的运行设计一个松耦合方案 (LCS)，该方案能够最小化 EM 和 CM 之间的通信开销，同时确保 EM 使用的气候输入的插值误差保持在指定的容差范围内。这一年的时间范围为 $T = 8760 \\ \\text{小时}$。\n\n假设每个相关的气候输入都是时间 $t$ 的二阶连续可微函数 $x(t)$，其二阶导数的幅值具有已知的全局上界，即对于 $[0, T]$ 中的所有 $t$，都有 $\\lvert x''(t) \\rvert \\le M$，其中 $M$ 是给定的。EM 在通信事件之间对 CM 的值使用分段线性插值。LCS 必须由 CM 步长的整数倍的通信时间组成，即通信之间的时间间隔 $h$ 必须满足 $h = N \\, \\Delta t_{c}$，其中 $N$ 为某个整数且 $N \\ge 1$。该方案必须包括 $t=0$ 和 $t=T$。\n\n您必须根据数值近似和光滑性界限的第一性原理，确定一个 $N$，该 $N$ 能够产生最大可行通信间隔 $h$（从而最小化通信次数），使得 EM 气候输入的最大插值误差受给定容差 $\\varepsilon$ 的限制。如果在 CM 原生步长约束 $h \\ge \\Delta t_{c}$ 的条件下，不存在满足误差界限的整数 $N \\ge 1$，则该方案不可行。\n\n对于由索引 $i$ 标记的多个气候输入，其界限为 $\\lvert x_i''(t) \\rvert \\le M_i$，容差为 $\\varepsilon_i$，误差约束必须在每个区间上对所有输入同时成立；因此，所选的 $h$ 必须满足所有输入中最严格的界限。\n\n将通信开销定义为在 $[0, T]$ 上的通信事件总数，包括两个端点。对于长度为 $h$ 的时间间隔，通信事件的数量为 $\\left\\lceil \\frac{T}{h} \\right\\rceil + 1$。您的程序必须为测试套件中的每组参数计算：\n- 满足误差界限的最大可行整数 $N$（其中 $h = N \\, \\Delta t_{c}$）。\n- 在 $[0, T]$ 上对应的通信事件总数。\n如果问题不可行，则输出 $N = -1$ 和通信事件总数 $-1$。\n\n单位：时间以 $\\text{小时}$ 报告。输出为整数。不涉及角度。不涉及百分比。\n\n测试套件：\n- 案例 (i) 单一输入，典型情况：$M = 0.0004 \\ \\text{每} \\ \\text{小时}^{2}$，$\\varepsilon = 0.02$。\n- 案例 (ii) 单一输入，边界可行性：$M = 0.01 \\ \\text{每} \\ \\text{小时}^{2}$，$\\varepsilon = 0.045$。\n- 案例 (iii) 单一输入，不可行：$M = 0.01 \\ \\text{每} \\ \\text{小时}^{2}$，$\\varepsilon = 0.044$。\n- 案例 (iv) 双输入，不同光滑度和容差：$M_1 = 0.0004 \\ \\text{每} \\ \\text{小时}^{2}$，$\\varepsilon_1 = 0.02$；$M_2 = 0.002 \\ \\text{每} \\ \\text{小时}^{2}$，$\\varepsilon_2 = 0.04$。\n\n您的程序应生成单行输出，其中包含测试套件的结果，格式为用方括号括起来的逗号分隔列表：$[[N_1,C_1],[N_2,C_2],[N_3,C_3],[N_4,C_4]]$，其中 $N_k$ 是所选的整数，$C_k$ 是案例 $k$ 的通信事件总数。如果不可行，该对应的值对必须为 $[-1,-1]$。",
            "solution": "我们将能量模型 (EM) 和气候模型 (CM) 之间的耦合形式化。EM 以时间步长 $\\Delta t_{e} = 1 \\ \\text{小时}$ 向前推进，并在每个 EM 步需要气候输入。CM 在其原生时间点提供气候输出，这些时间点之间相隔 $\\Delta t_{c} = 6 \\ \\text{小时}$。在松耦合方案 (LCS) 下，我们选择相隔 $h = N \\, \\Delta t_{c}$ 的通信时间，其中 $N \\in \\mathbb{Z}$ 且 $N \\ge 1$，以便 EM 可以在通信之间对气候输入进行线性插值。这一年的时间范围为 $T = 8760 \\ \\text{小时}$，通信时间必须包括 $t=0$ 和 $t=T$。\n\n为确保科学真实性，我们将每个气候输入 $x(t)$ 建模为在 $[0, T]$ 上二阶连续可微的函数，且满足 $\\lvert x''(t) \\rvert \\le M$。EM 在通信点之间采用分段线性插值。我们使用带有拉格朗日余项的泰勒定理和线性插值的标准误差分析，推导出插值误差的上界。\n\n设 $x(t)$ 为气候输入，考虑一个长度为 $h = b-a$ 的单耦合区间 $[a,b]$。$x(t)$ 在 $a$ 和 $b$ 之间的线性插值是唯一的仿射函数 $\\ell(t)$，使得 $\\ell(a) = x(a)$ 且 $\\ell(b) = x(b)$。定义插值误差 $e(t) = x(t) - \\ell(t)$。根据经典数值分析，可以通过皮亚诺核或在任意点应用泰勒定理并减去插值多项式，将 $e(t)$ 与二阶导数联系起来。可以得到恒等式\n$$\ne(t) = \\frac{x''(\\xi_t)}{2} \\, (t-a)(t-b),\n$$\n对于某个取决于 $t$ 的 $\\xi_t \\in (a,b)$。取绝对值并使用全局界限 $\\lvert x''(t) \\rvert \\le M$ 可得\n$$\n\\lvert e(t) \\rvert \\le \\frac{M}{2} \\, \\lvert (t-a)(t-b) \\rvert.\n$$\n函数 $\\lvert (t-a)(t-b) \\rvert$ 在中点 $t = \\frac{a+b}{2}$ 处达到其最大值，值为 $\\left(\\frac{h}{2}\\right)\\left(\\frac{h}{2}\\right) = \\frac{h^2}{4}$。因此，在该区间上的最大插值误差满足\n$$\n\\max_{t \\in [a,b]} \\lvert e(t) \\rvert \\le \\frac{M h^2}{8}.\n$$\n这个不等式是数值近似理论中一个经过充分检验的结果，它根据区间长度 $h$ 和二阶导数界限 $M$ 为分段线性插值误差提供了一个保守的界限。\n\n为了对插值误差强制施加一个容差 $\\varepsilon$，我们需要\n$$\n\\frac{M h^2}{8} \\le \\varepsilon.\n$$\n解出 $h$ 可得最大允许区间长度\n$$\nh_{\\max} = \\sqrt{\\frac{8 \\varepsilon}{M}}.\n$$\n为了最小化通信开销，我们选择满足 CM 原生步长约束（即 $h$ 必须是 $\\Delta t_{c}$ 的整数倍，即 $h = N \\, \\Delta t_{c}$，其中 $N \\in \\mathbb{Z}$ 且 $N \\ge 1$）的最大可行 $h$。因此，\n$$\nN_{\\max} = \\left\\lfloor \\frac{h_{\\max}}{\\Delta t_{c}} \\right\\rfloor.\n$$\n可行性要求 $N_{\\max} \\ge 1$，这等价于 $h_{\\max} \\ge \\Delta t_{c}$。如果 $N_{\\max}  1$，则 $\\Delta t_{c}$ 的任何整数倍都不能满足误差界限，问题对于给定的 CM 步长是不可行的。\n\n对于由索引 $i$ 标记的多个气候输入，其界限为 $M_i$，容差为 $\\varepsilon_i$，误差约束必须同时成立。因此，允许的区间受最严格的输入限制：\n$$\nh_{\\max} = \\min_{i} \\sqrt{\\frac{8 \\varepsilon_i}{M_i}},\n$$\n并且适用相同的整数倍约束：\n$$\nN_{\\max} = \\left\\lfloor \\frac{h_{\\max}}{\\Delta t_{c}} \\right\\rfloor, \\quad \\text{如果 } N_{\\max} \\ge 1 \\text{ 则可行}.\n$$\n\n一旦确定了 $N_{\\max}$，通信间隔就是 $h = N_{\\max} \\, \\Delta t_{c}$。在 $[0, T]$ 上的通信事件总数（包括两个端点）是\n$$\nC = \\left\\lceil \\frac{T}{h} \\right\\rceil + 1.\n$$\n包含 $t=T$ 确保了最后的（可能更短的）区间 $[k h, T]$ 的两个端点都可供 EM 用于插值。如果 $N_{\\max}  1$，我们声明不可行，并设置 $(N, C) = (-1, -1)$。\n\n我们现在评估测试套件：\n\n- 案例 (i)：$M = 0.0004$，$\\varepsilon = 0.02$，$\\Delta t_{c} = 6$，$T = 8760$。\n  计算 $h_{\\max} = \\sqrt{\\frac{8 \\cdot 0.02}{0.0004}} = \\sqrt{400} = 20$。那么 $N_{\\max} = \\left\\lfloor \\frac{20}{6} \\right\\rfloor = 3$。因此 $h = 18$，$C = \\left\\lceil \\frac{8760}{18} \\right\\rceil + 1 = 487 + 1 = 488$。\n\n- 案例 (ii)：$M = 0.01$，$\\varepsilon = 0.045$，$\\Delta t_{c} = 6$，$T = 8760$。\n  计算 $h_{\\max} = \\sqrt{\\frac{8 \\cdot 0.045}{0.01}} = \\sqrt{36} = 6$。那么 $N_{\\max} = \\left\\lfloor \\frac{6}{6} \\right\\rfloor = 1$。因此 $h = 6$，$C = \\left\\lceil \\frac{8760}{6} \\right\\rceil + 1 = 1460 + 1 = 1461$。\n\n- 案例 (iii)：$M = 0.01$，$\\varepsilon = 0.044$，$\\Delta t_{c} = 6$，$T = 8760$。\n  计算 $h_{\\max} = \\sqrt{\\frac{8 \\cdot 0.044}{0.01}} = \\sqrt{35.2} \\approx 5.93$。那么 $N_{\\max} = \\left\\lfloor \\frac{5.93}{6} \\right\\rfloor = 0$，这是不可行的。输出 $[-1, -1]$。\n\n- 案例 (iv)：两个输入，$(M_1, \\varepsilon_1) = (0.0004, 0.02)$ 和 $(M_2, \\varepsilon_2) = (0.002, 0.04)$；$\\Delta t_{c} = 6$，$T = 8760$。\n  计算 $h_{\\max,1} = \\sqrt{\\frac{8 \\cdot 0.02}{0.0004}} = \\sqrt{400} = 20$，以及 $h_{\\max,2} = \\sqrt{\\frac{8 \\cdot 0.04}{0.002}} = \\sqrt{160} \\approx 12.649$。因此 $h_{\\max} = \\min(20, 12.649) = 12.649$，所以 $N_{\\max} = \\left\\lfloor \\frac{12.649}{6} \\right\\rfloor = 2$。因此 $h = 12$，$C = \\left\\lceil \\frac{8760}{12} \\right\\rceil + 1 = 730 + 1 = 731$。\n\n算法如下：\n1) 对每个案例，构建 $(M_i, \\varepsilon_i)$ 对的集合（对于单输入案例，集合中只有一个元素）。\n2) 计算 $h_{\\max,i} = \\sqrt{\\frac{8 \\varepsilon_i}{M_i}}$ 并取 $h_{\\max} = \\min_i h_{\\max,i}$。\n3) 计算 $N_{\\max} = \\left\\lfloor \\frac{h_{\\max}}{\\Delta t_{c}} \\right\\rfloor$。如果 $N_{\\max}  1$，返回 $[-1, -1]$。\n4) 否则，设置 $h = N_{\\max} \\, \\Delta t_{c}$ 和 $C = \\left\\lceil \\frac{T}{h} \\right\\rceil + 1$。\n5) 将所有案例的 $[N, C]$ 列表作为单个用方括号括起来的逗号分隔行输出。\n\n此过程通过选择气候步长的最大可行整数倍来最小化通信开销，同时遵循通过泰勒定理从光滑性约束导出的插值误差界限。",
            "answer": "```python\n# Python 3.12\n# Libraries: numpy 1.23.5, scipy 1.11.4 (not used)\nimport numpy as np\n\ndef largest_feasible_N_and_count(M_list, eps_list, dt_c_hours, T_hours):\n    \"\"\"\n    Compute the largest feasible integer N such that h = N * dt_c_hours\n    satisfies max interpolation error = epsilon for all inputs,\n    and the corresponding total number of communication events over [0, T].\n\n    Parameters:\n        M_list: list or scalar; bound(s) on |x''(t)| in units per hour^2\n        eps_list: list or scalar; tolerance(s) in same units as x\n        dt_c_hours: float; climate model native step in hours\n        T_hours: float; total horizon in hours (one year)\n\n    Returns:\n        (N_max, C) where:\n            N_max: int; largest feasible integer multiple\n            C: int; total communications including endpoints\n        If infeasible, returns (-1, -1).\n    \"\"\"\n    # Ensure arrays for uniform handling\n    Ms = np.atleast_1d(M_list).astype(float)\n    eps = np.atleast_1d(eps_list).astype(float)\n\n    # Validate lengths\n    if Ms.shape != eps.shape:\n        raise ValueError(\"M_list and eps_list must have the same shape\")\n\n    # Compute h_max for each input: sqrt(8 * eps_i / M_i)\n    # Guard against division by zero or negative values (not expected in test suite)\n    h_max_list = np.sqrt(8.0 * eps / Ms)\n\n    # Most restrictive bound across inputs\n    h_max = float(np.min(h_max_list))\n\n    # Integer multiple constraint\n    N_max = int(np.floor(h_max / dt_c_hours))\n\n    if N_max  1:\n        return (-1, -1)\n\n    h = N_max * dt_c_hours\n    C = int(np.ceil(T_hours / h)) + 1\n    return (N_max, C)\n\ndef format_nested_list(obj):\n    \"\"\"\n    Format a Python nested list of ints into a compact string without spaces,\n    e.g., [[3,488],[1,1461],[-1,-1],[2,731]]\n    \"\"\"\n    if isinstance(obj, list):\n        return \"[\" + \",\".join(format_nested_list(x) for x in obj) + \"]\"\n    elif isinstance(obj, (int, np.integer)):\n        return str(int(obj))\n    else:\n        # Should not occur for this problem; handle gracefully\n        return str(obj)\n\ndef solve():\n    # Constants per problem statement\n    dt_e_hours = 1.0  # energy model step; not directly used in computation\n    dt_c_hours = 6.0  # climate model step\n    T_hours = 8760.0  # one-year horizon\n\n    # Test suite: four cases\n    test_cases = [\n        # Case (i) Single-input, typical\n        {\"M\": 0.0004, \"eps\": 0.02},\n        # Case (ii) Single-input, boundary feasibility\n        {\"M\": 0.01, \"eps\": 0.045},\n        # Case (iii) Single-input, infeasible\n        {\"M\": 0.01, \"eps\": 0.044},\n        # Case (iv) Two inputs, differing smoothness and tolerances\n        {\"M\": [0.0004, 0.002], \"eps\": [0.02, 0.04]},\n    ]\n\n    results = []\n    for case in test_cases:\n        M = case[\"M\"]\n        eps = case[\"eps\"]\n        N_max, C = largest_feasible_N_and_count(M, eps, dt_c_hours, T_hours)\n        results.append([N_max, C])\n\n    print(format_nested_list(results))\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "能量模型和气候模型通常在不同的空间网格上运行，这带来了数据聚合的挑战。简单的算术平均可能无法保留气候数据中对能源系统至关重要的空间变异性。本练习将引导你设计一个更复杂的空间聚合方案，该方案不仅将精细网格数据映射到粗糙的负荷区域，还旨在保留关键的统计特性，如均值和方差。",
            "id": "4081536",
            "problem": "给定一个概念耦合任务，该任务涉及一个包含 $10$ 个负荷区的能源系统模型与一个在 $0.25^{\\circ}$ 经纬度网格上提供风速的区域气候模型。目标是设计一种空间聚合映射，为每个负荷区生成单一的聚合风速时间序列，该序列在聚合期内的时间均值和时间方差，与应用于底层网格单元的指定加权方案所隐含的均值和方差完全匹配。\n\n使用以下基本统计和物理基础：\n- 随机变量之和的时间均值等于其时间均值之和。如果 $x_g(t)$ 是时间序列，那么对于满足 $\\sum_g \\pi_g = 1$ 的权重 $\\pi_g$，聚合序列为 $y(t) = \\sum_g \\pi_g x_g(t)$，其均值为 $\\mu_y = \\sum_g \\pi_g \\mu_g$，其中 $\\mu_g$ 是 $x_g(t)$ 的时间均值。\n- 全方差定律指出，对于一个以概率 $\\pi_g$ 选择单元格 $g$ 并从该单元格的时间序列中抽样 $X$ 的混合分布，其方差为 $\\mathrm{Var}(X) = \\sum_g \\pi_g \\left( \\sigma_g^2 + (\\mu_g - \\mu)^2 \\right)$，其中 $\\sigma_g^2$ 是 $x_g(t)$ 的时间方差，$\\mu = \\sum_g \\pi_g \\mu_g$ 是混合均值。\n- 应用线性聚合和仿射变换从网格单元序列构建区域级序列。\n- 三角函数必须使用弧度作为角度单位。\n\n网格与映射：\n- 定义一个包含 $4$ 个纬度行和 $5$ 个经度列的矩形网格，其中点位于纬度值 $30.125^{\\circ}$、$30.375^{\\circ}$、$30.625^{\\circ}$、$30.875^{\\circ}$ 和经度值 $-99.875^{\\circ}$、$-99.625^{\\circ}$、$-99.375^{\\circ}$、$-99.125^{\\circ}$、$-98.875^{\\circ}$。这些中点是 $0.25^{\\circ} \\times 0.25^{\\circ}$ 网格单元的中心；其基础纬度范围为 $30.0^{\\circ}$ 到 $31.0^{\\circ}$，经度范围为 $-100.0^{\\circ}$ 到 $-98.75^{\\circ}$。\n- 纬度行由 $i \\in \\{0,1,2,3\\}$ 索引，经度列由 $j \\in \\{0,1,2,3,4\\}$ 索引。负荷区 $z \\in \\{0,1,\\dots,9\\}$ 包括以下单元格隶属关系（以 $(i,j)$ 对的形式给出）：\n  - $z=0$：$(0,0)$、$(0,1)$\n  - $z=1$：$(0,2)$、$(0,3)$\n  - $z=2$：$(0,4)$、$(1,0)$、$(1,1)$\n  - $z=3$：$(1,2)$、$(1,3)$\n  - $z=4$：$(1,4)$、$(2,0)$\n  - $z=5$：$(2,1)$、$(2,2)$\n  - $z=6$：$(2,3)$、$(2,4)$\n  - $z=7$：$(3,0)$、$(3,1)$\n  - $z=8$：$(3,2)$、$(3,3)$\n  - $z=9$：$(3,4)$\n\n风速时间序列：\n- 对于每个网格单元 $(i,j)$，根据物理上合理的组合，为离散时间索引 $t \\in \\{0,1,\\dots,199\\}$ 定义一个确定性的 $T=200$-步长的风速时间序列 $x_{i,j}(t)$，单位为米/秒（$\\mathrm{m/s}$）：\n  $$x_{i,j}(t) = 6 + a_{i,j}\\,C_1(t) + 0.2\\,C_2(t) + S_{i,j}(t) + L_{i,j},$$\n  其中\n  $$C_1(t) = 2\\sin\\!\\left(\\frac{2\\pi t}{T}\\right),\\quad C_2(t) = \\sin\\!\\left(\\frac{2\\pi t}{50}\\right),$$\n  $$a_{i,j} = 1 + 0.1\\sin(\\phi_{i,j}),\\quad \\phi_{i,j} = \\mathrm{lat}_{i}\\,\\pi/180 + \\mathrm{lon}_{j}\\,\\pi/180,$$\n  $$S_{i,j}(t) = 0.3\\sin\\!\\left(\\frac{2\\pi t}{T} + \\theta_{i,j}\\right),\\quad \\theta_{i,j} = 0.3(i - j),$$\n  $$L_{i,j} = 0.3(\\mathrm{lat}_i - 30.5) + 0.1(\\mathrm{lon}_j + 99.375) + 0.5\\sin\\!\\left(2\\pi\\frac{i + j}{5}\\right),$$\n  其中 $\\mathrm{lat}_i$ 和 $\\mathrm{lon}_j$ 分别是索引 $i$ 和 $j$ 对应的纬度和经度中点（单位为度）。所有三角函数参数均以弧度为单位。\n\n加权方案：\n- 对于每个区域 $z$，您将为三种加权方案 $k \\in \\{1,2,3\\}$ 计算聚合权重 $w_{i,j}^{(k)}$：\n  1. 基于面积的权重： $$w_{i,j}^{(1)} = \\cos\\!\\left(\\mathrm{lat}_i\\,\\frac{\\pi}{180}\\right)$$。\n  2. 均匀权重： $$w_{i,j}^{(2)} = 1$$。\n  3. 自定义强调权重： $$w_{i,j}^{(3)} = 1 + 0.2\\left(\\mathrm{lon}_j - (-99.875)\\right) + 0.1\\left(\\mathrm{lat}_i - 30.125\\right)$$。\n- 在每个区域 $z$ 内进行归一化，以获得 $\\pi_{i,j}^{(k)} = w_{i,j}^{(k)} \\Big/ \\sum_{(p,q)\\in z} w_{p,q}^{(k)}$。\n\n各区域和方案的目标统计量：\n- 对于每个区域 $z$ 和方案 $k$，令 $\\mu_{i,j}$ 为 $x_{i,j}(t)$ 的时间均值，$\\sigma^2_{i,j}$ 为 $x_{i,j}(t)$ 的时间方差，两者均在 $t=0,\\dots,199$ 上计算。\n- 定义目标混合均值\n  $$\\mu_z^{*(k)} = \\sum_{(i,j)\\in z} \\pi_{i,j}^{(k)}\\,\\mu_{i,j}$$。\n- 使用全方差定律定义目标混合方差\n  $$\\left(\\sigma_z^{2}\\right)^{*(k)} = \\sum_{(i,j)\\in z} \\pi_{i,j}^{(k)}\\left(\\sigma^2_{i,j} + \\left(\\mu_{i,j} - \\mu_z^{*(k)}\\right)^2\\right)$$。\n\n聚合映射要求：\n- 构建聚合区域序列 $y_z^{(k)}(t) = \\sum_{(i,j)\\in z} \\pi_{i,j}^{(k)} x_{i,j}(t)$。\n- 设计一个确定性的仿射变换并应用于 $y_z^{(k)}(t)$，仅使用区域局部信息，使得变换后的序列 $\\tilde{y}_z^{(k)}(t)$ 满足\n  $$\\frac{1}{T}\\sum_{t=0}^{T-1} \\tilde{y}_z^{(k)}(t) = \\mu_z^{*(k)}\\quad\\text{和}\\quad \\frac{1}{T}\\sum_{t=0}^{T-1} \\left(\\tilde{y}_z^{(k)}(t) - \\mu_z^{*(k)}\\right)^2 = \\left(\\sigma_z^{2}\\right)^{*(k)}$$。\n- 该变换必须在原始单元格序列上是空间线性的，并且除了线性聚合和区域级仿射缩放外，不得要求修改原始气候模型的输出。\n\n测试套件与输出规范：\n- 为所有 $10$ 个区域和所有 $3$ 种加权方案实现上述过程，生成 $30$ 个特定于区域的无量纲缩放系数（每个区域每个方案一个），结果为浮点数。\n- 您的程序应产生单行输出，其中包含用方括号括起来的逗号分隔的结果列表，按方案 $k=1,2,3$ 排序，在每个方案内，再按区域 $z=0,1,\\dots,9$ 排序；例如，前 $10$ 个数字对应于方案 $k=1$ 的区域 $0$ 到 $9$，接下来的 $10$ 个对应于方案 $k=2$，最后 $10$ 个对应于方案 $k=3$。\n- 缩放系数是无单位（无量纲）的数字。所有三角函数参数均使用弧度。输出中不需要其他单位。内部风速计算必须使用米/秒（$\\mathrm{m/s}$），但不得打印单位。",
            "solution": "该问题要求设计一种空间聚合映射，以将来自网格化气候模型的风速数据耦合到区域能源系统模型。核心任务是为 $10$ 个负荷区中的每一个和 $3$ 种不同的加权方案，构建一个聚合风速时间序列，其时间均值和时间方差与特定的目标值相匹配。这是通过对线性聚合的时间序列应用特定于区域的仿射变换来实现的。\n\n解决方法可分解为以下步骤：\n\n1.  **生成网格单元时间序列**：我们首先为 $4 \\times 5 = 20$ 个网格单元中的每一个合成风速时间序列。单元格 $(i,j)$ 的时间序列由以下公式给出：\n    $$x_{i,j}(t) = 6 + a_{i,j}\\,C_1(t) + 0.2\\,C_2(t) + S_{i,j}(t) + L_{i,j}$$\n    时间范围为 $T=200$ 步长。该模型将风速表示为一个恒定基值（$6$）、共模周期性波动（$C_1(t)$ 和 $C_2(t)$）、一个空间变化的周期性分量（$S_{i,j}(t)$）和一个空间变化的时间不变偏移量（$L_{i,j}$）的叠加。参数 $a_{i,j}$ 和 $L_{i,j}$ 取决于单元格的纬度（$\\mathrm{lat}_i$）和经度（$\\mathrm{lon}_j$），从而引入了空间异质性。所有三角函数均使用弧度进行计算。\n\n2.  **网格单元的统计特性描述**：对于每个网格单元 $(i,j)$，我们计算其时间序列 $x_{i,j}(t)$ 在周期 $T$ 内的时间均值 $\\mu_{i,j}$ 和时间方差 $\\sigma^2_{i,j}$：\n    $$\\mu_{i,j} = \\frac{1}{T}\\sum_{t=0}^{T-1} x_{i,j}(t)$$\n    $$\\sigma^2_{i,j} = \\frac{1}{T}\\sum_{t=0}^{T-1} (x_{i,j}(t) - \\mu_{i,j})^2$$\n    这些统计数据构成了构建聚合区域序列目标属性的基础。\n\n3.  **区域聚合与加权**：对于每个负荷区 $z$ 和加权方案 $k \\in \\{1, 2, 3\\}$，我们首先为属于该区域的所有单元格 $(i,j)$ 计算归一化权重 $\\pi_{i,j}^{(k)}$。原始权重 $w_{i,j}^{(k)}$ 由三种方案（基于面积、均匀、自定义）给出，并在区域内进行归一化：\n    $$\\pi_{i,j}^{(k)} = \\frac{w_{i,j}^{(k)}}{\\sum_{(p,q)\\in z} w_{p,q}^{(k)}}$$\n    使用这些权重，我们为该区域构建一个线性聚合的时间序列 $y_z^{(k)}(t)$：\n    $$y_z^{(k)}(t) = \\sum_{(i,j)\\in z} \\pi_{i,j}^{(k)} x_{i,j}(t)$$\n\n4.  **目标统计量的定义**：问题为最终变换后的区域时间序列 $\\tilde{y}_z^{(k)}(t)$ 指定了目标统计属性。\n    -   目标均值 $\\mu_z^{*(k)}$ 是单个单元格均值的加权平均值：\n        $$\\mu_z^{*(k)} = \\sum_{(i,j)\\in z} \\pi_{i,j}^{(k)}\\,\\mu_{i,j}$$\n        根据期望（均值）算子的线性性质，线性聚合序列的均值 $\\mathrm{Mean}(y_z^{(k)}(t))$ 天然等于此目标均值 $\\mu_z^{*(k)}$。\n    -   目标方差 $(\\sigma_z^2)^{*(k)}$ 使用全方差定律定义：\n        $$(\\sigma_z^2)^{*(k)} = \\sum_{(i,j)\\in z} \\pi_{i,j}^{(k)} \\left(\\sigma^2_{i,j} + (\\mu_{i,j} - \\mu_z^{*(k)})^2\\right)$$\n        这代表了统计混合模型的方差，其概念上不同于线性聚合和的方差 $\\sigma_{y,z,k}^2 = \\mathrm{Var}(y_z^{(k)}(t))$。后者的计算公式为 $\\frac{1}{T}\\sum_{t=0}^{T-1} (y_z^{(k)}(t) - \\mu_z^{*(k)})^2$。\n\n5.  **仿射变换的设计**：最后一步是找到一个仿射变换 $\\tilde{y}(t) = A y(t) + B$，它能修改聚合序列 $y_z^{(k)}(t)$ 以使其具有目标统计量。系数 $A$ 和 $B$ 由以下两个条件确定：\n    1.  $\\mathrm{Mean}(\\tilde{y}) = \\mathrm{Mean}(A y + B) = A \\mathrm{Mean}(y) + B = \\mu_z^{*(k)}$\n    2.  $\\mathrm{Var}(\\tilde{y}) = \\mathrm{Var}(A y + B) = A^2 \\mathrm{Var}(y) = (\\sigma_z^2)^{*(k)}$\n\n    如前所述，$\\mathrm{Mean}(y) = \\mu_z^{*(k)}$。将此代入第一个方程得到 $A \\mu_z^{*(k)} + B = \\mu_z^{*(k)}$，这意味着 $B = (1-A)\\mu_z^{*(k)}$。\n    从第二个方程中，我们可以解出缩放系数 $A$，这正是问题所要求的量。假设 $\\mathrm{Var}(y) > 0$：\n    $$A^2 = \\frac{(\\sigma_z^2)^{*(k)}}{\\mathrm{Var}(y_z^{(k)}(t))} \\implies A_z^{(k)} = \\sqrt{\\frac{(\\sigma_z^2)^{*(k)}}{\\sigma_{y,z,k}^2}}$$\n    我们取缩放系数的正根。为 $10$ 个区域中的每一个和 $3$ 种加权方案分别计算这个无量纲系数 $A_z^{(k)}$。\n\n该算法首先生成所有 $20$ 个网格单元的时间序列及其均值和方差。然后，对于 $30$ 个区域-方案组合中的每一个，它计算归一化权重、目标均值和方差、线性聚合序列的方差，并最终计算所需的缩放系数 $A_z^{(k)}$。这 $30$ 个系数构成了最终结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the spatial aggregation mapping problem by calculating dimensionless\n    scaling coefficients for 10 load zones under 3 weighting schemes.\n    \"\"\"\n\n    # --- Problem Definition ---\n\n    # Grid and time parameters\n    T = 200\n    NUM_LAT_ROWS = 4\n    NUM_LON_COLS = 5\n    NUM_ZONES = 10\n\n    # Grid midpoints\n    lats = 30.125 + 0.25 * np.arange(NUM_LAT_ROWS)\n    lons = -99.875 + 0.25 * np.arange(NUM_LON_COLS)\n    \n    # Zone memberships: list of (i, j) tuples for each zone\n    zone_memberships = [\n        [(0, 0), (0, 1)],  # z=0\n        [(0, 2), (0, 3)],  # z=1\n        [(0, 4), (1, 0), (1, 1)],  # z=2\n        [(1, 2), (1, 3)],  # z=3\n        [(1, 4), (2, 0)],  # z=4\n        [(2, 1), (2, 2)],  # z=5\n        [(2, 3), (2, 4)],  # z=6\n        [(3, 0), (3, 1)],  # z=7\n        [(3, 2), (3, 3)],  # z=8\n        [(3, 4)]           # z=9\n    ]\n\n    # Time vector\n    t = np.arange(T)\n\n    # --- Step 1: Generate Grid Cell Time Series and Statistics ---\n    \n    x_series = np.zeros((NUM_LAT_ROWS, NUM_LON_COLS, T))\n    mu_cells = np.zeros((NUM_LAT_ROWS, NUM_LON_COLS))\n    var_cells = np.zeros((NUM_LAT_ROWS, NUM_LON_COLS))\n\n    # Common time-varying components\n    C1_t = 2 * np.sin(2 * np.pi * t / T)\n    C2_t = np.sin(2 * np.pi * t / 50)\n\n    for i in range(NUM_LAT_ROWS):\n        for j in range(NUM_LON_COLS):\n            lat_deg, lon_deg = lats[i], lons[j]\n            \n            # Spatially varying parameters\n            phi_ij = np.deg2rad(lat_deg) + np.deg2rad(lon_deg)\n            a_ij = 1 + 0.1 * np.sin(phi_ij)\n            \n            theta_ij = 0.3 * (i - j)\n            S_ij_t = 0.3 * np.sin(2 * np.pi * t / T + theta_ij)\n            \n            L_ij = (0.3 * (lat_deg - 30.5) +\n                    0.1 * (lon_deg + 99.375) +\n                    0.5 * np.sin(2 * np.pi * (i + j) / 5))\n            \n            # Construct time series for cell (i, j)\n            x_series[i, j, :] = 6 + a_ij * C1_t + 0.2 * C2_t + S_ij_t + L_ij\n            \n            # Pre-compute cell mean and variance\n            mu_cells[i, j] = np.mean(x_series[i, j, :])\n            # Use population variance (ddof=0 is default)\n            var_cells[i, j] = np.var(x_series[i, j, :])\n\n    # --- Step 2  3: Iterate Schemes and Zones, Calculate Coefficients ---\n\n    results = []\n    \n    for k in range(1, 4):  # Iterate through schemes k=1, 2, 3\n        for z in range(NUM_ZONES): # Iterate through zones z=0, ..., 9\n            cell_indices = zone_memberships[z]\n            num_cells_in_zone = len(cell_indices)\n            \n            # Step 3a: Calculate weights for the current zone and scheme\n            raw_weights = np.zeros(num_cells_in_zone)\n            for idx, (i, j) in enumerate(cell_indices):\n                lat_deg, lon_deg = lats[i], lons[j]\n                if k == 1:  # Area-based weights\n                    raw_weights[idx] = np.cos(np.deg2rad(lat_deg))\n                elif k == 2:  # Uniform weights\n                    raw_weights[idx] = 1.0\n                else:  # k == 3, Custom emphasis weights\n                    raw_weights[idx] = 1 + 0.2 * (lon_deg - lons[0]) + 0.1 * (lat_deg - lats[0])\n            \n            pi_weights = raw_weights / np.sum(raw_weights)\n\n            # Step 3b: Calculate target statistics\n            zone_mu_cells = np.array([mu_cells[i, j] for i, j in cell_indices])\n            zone_var_cells = np.array([var_cells[i, j] for i, j in cell_indices])\n            \n            mu_star_target = np.sum(pi_weights * zone_mu_cells)\n            \n            var_star_target = np.sum(pi_weights * (zone_var_cells + (zone_mu_cells - mu_star_target)**2))\n\n            # Step 3c: Calculate aggregated series and its variance\n            y_series_z_k = np.zeros(T)\n            for idx, (i, j) in enumerate(cell_indices):\n                y_series_z_k += pi_weights[idx] * x_series[i, j, :]\n            \n            var_y = np.var(y_series_z_k)\n\n            # Step 3d: Compute the scaling coefficient\n            if var_y > 0:\n                A = np.sqrt(var_star_target / var_y)\n            elif var_star_target == 0: # If both are 0, variance is already matched\n                A = 1.0\n            else: # var_y is 0 but target is not, indicates an issue\n                A = np.inf # Should not happen in this problem\n                \n            results.append(A)\n\n    # --- Final Output ---\n    # Format the results as a comma-separated list in brackets\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        }
    ]
}