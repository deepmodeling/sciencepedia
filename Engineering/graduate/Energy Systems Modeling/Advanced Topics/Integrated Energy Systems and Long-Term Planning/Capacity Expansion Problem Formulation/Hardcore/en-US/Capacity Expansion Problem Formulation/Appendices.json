{
    "hands_on_practices": [
        {
            "introduction": "A fundamental aspect of any multi-period capacity expansion model is tracking the evolution of the generation fleet over time. This involves accounting for new capacity additions, which become operational after a construction lead time, and the removal of old capacity through retirements. This exercise provides practice in applying the core principle of stock-flow consistency to calculate the total installed capacity at a future date based on a series of investment and retirement decisions .",
            "id": "4074258",
            "problem": "Consider a single-technology capacity expansion model for Combined Cycle Gas Turbine (CCGT). The total installed capacity is treated as a stock that evolves through commissioning of new builds after a construction lead time and through retirements from the stock. The lead time is two years, meaning an investment decision made in year $t$ becomes operational in year $t+L$ where $L=2$. The model tracks the annual investment decision variable $I_{t}$ (measured in megawatts) and the annual retirement variable $R_{t}$ (measured in megawatts). Assume the following are given and scientifically plausible:\n\n- The initial installed capacity stock at the end of year $2019$ is $K_{2019} = 600$ megawatts.\n- The lead time is $L=2$ years, so commissioning in year $t$ equals $I_{t-L}$.\n- Investment decisions by year: $I_{2017}=40$, $I_{2018}=30$, $I_{2019}=50$, $I_{2020}=100$, $I_{2021}=0$, $I_{2022}=200$, $I_{2023}=150$, $I_{2024}=50$, $I_{2025}=0$, $I_{2026}=100$ (all in megawatts).\n- Retirement decisions by year: $R_{2020}=40$, $R_{2021}=20$, $R_{2022}=0$, $R_{2023}=0$, $R_{2024}=80$, $R_{2025}=0$, $R_{2026}=30$, $R_{2027}=0$, $R_{2028}=70$ (all in megawatts).\n\nStarting from first principles of stock-flow consistency in capacity expansion models, derive the recursive stock evolution that aggregates vintages and accounts for lead times, and use it to compute the total installed CCGT capacity $K_{2028}$. Express the final numerical answer in megawatts. No rounding is required; report the exact integer value.",
            "solution": "The problem is valid. It is a well-posed, scientifically grounded problem in energy systems modeling that is self-contained and free of contradictions.\n\nThe first principle of stock-flow consistency states that the stock of a quantity at the end of a period is equal to the stock at the beginning of the period plus all inflows minus all outflows during the period. In this context, the stock is the total installed capacity of Combined Cycle Gas Turbine (CCGT) plants, denoted by $K_t$ (in megawatts) at the end of year $t$. The inflows are the newly commissioned capacities, and the outflows are the retired capacities.\n\nThe stock evolution can be expressed as:\n$$K_t = K_{t-1} + \\text{Commissioning}_t - \\text{Retirements}_t$$\nwhere $K_{t-1}$ is the installed capacity at the end of the previous year, $\\text{Commissioning}_t$ is the capacity that becomes operational in year $t$, and $\\text{Retirements}_t$ is the capacity that is decommissioned in year $t$.\n\nThe problem states that investment decisions, denoted by $I_t$, have a construction lead time of $L=2$ years. This means an investment decision $I_{t-L}$ made in year $t-L$ results in a new capacity, or commissioning, in year $t$. Therefore, we have:\n$$\\text{Commissioning}_t = I_{t-L} = I_{t-2}$$\nThe retirements in year $t$ are given by the variable $R_t$.\n\nSubstituting these into the stock-flow equation gives the recursive formula for the capacity stock evolution:\n$$K_t = K_{t-1} + I_{t-2} - R_t$$\nThis is the recursive stock evolution equation requested.\n\nTo compute the total installed capacity at the end of year $2028$, $K_{2028}$, starting from the given initial capacity at the end of year $2019$, $K_{2019}$, we can apply this recursive formula for each year from $t=2020$ to $t=2028$. A more direct method is to recognize that the total change in capacity is the sum of all net changes over the period. By unrolling the recursion, we get:\n$$K_{2028} = K_{2019} + \\sum_{t=2020}^{2028} (K_t - K_{t-1})$$\nSubstituting the expression for the annual change, $(K_t - K_{t-1}) = I_{t-2} - R_t$, we obtain:\n$$K_{2028} = K_{2019} + \\sum_{t=2020}^{2028} (I_{t-2} - R_t)$$\nThis can be separated into the sum of all commissions and the sum of all retirements over the period:\n$$K_{2028} = K_{2019} + \\left( \\sum_{t=2020}^{2028} I_{t-2} \\right) - \\left( \\sum_{t=2020}^{2028} R_t \\right)$$\n\nWe are given the initial capacity $K_{2019} = 600$ megawatts.\nFirst, we calculate the total commissioned capacity from the beginning of $2020$ to the end of $2028$. The summation index for the investment variable $I$ runs from $(2020-2)=2018$ to $(2028-2)=2026$.\n$$ \\sum_{t=2020}^{2028} I_{t-2} = I_{2018} + I_{2019} + I_{2020} + I_{2021} + I_{2022} + I_{2023} + I_{2024} + I_{2025} + I_{2026} $$\nUsing the provided data for investment decisions (in megawatts):\n$$ \\sum_{t=2020}^{2028} I_{t-2} = 30 + 50 + 100 + 0 + 200 + 150 + 50 + 0 + 100 = 680 $$\n\nNext, we calculate the total retired capacity from the beginning of $2020$ to the end of $2028$.\n$$ \\sum_{t=2020}^{2028} R_t = R_{2020} + R_{2021} + R_{2022} + R_{2023} + R_{2024} + R_{2025} + R_{2026} + R_{2027} + R_{2028} $$\nUsing the provided data for retirement decisions (in megawatts):\n$$ \\sum_{t=2020}^{2028} R_t = 40 + 20 + 0 + 0 + 80 + 0 + 30 + 0 + 70 = 240 $$\n\nFinally, we substitute the initial capacity and the calculated total commissions and retirements into the equation for $K_{2028}$:\n$$ K_{2028} = 600 + 680 - 240 $$\n$$ K_{2028} = 1280 - 240 $$\n$$ K_{2028} = 1040 $$\nThe total installed CCGT capacity at the end of year $2028$ is $1040$ megawatts.",
            "answer": "$$\\boxed{1040}$$"
        },
        {
            "introduction": "Capacity expansion models must not only decide what to build, but also verify that the resulting system can operate reliably and economically in the short term. This requires solving a detailed \"unit commitment and economic dispatch\" problem for representative time slices within the planning horizon. This hands-on coding practice involves formulating and solving such a single-period dispatch problem as a linear program, finding the least-cost way to meet demand while respecting a suite of realistic operational constraints for thermal, renewable, and storage technologies .",
            "id": "4074220",
            "problem": "A single-period dispatch computation is a foundational subproblem in capacity expansion problem formulation in energy systems modeling. The computation must satisfy the conservation of energy and operational constraints. Consider a system with $2$ thermal technologies, one variable renewable technology with exogenous availability, and one electrochemical storage asset. The time index is a single time slice of duration $\\Delta t = 1$ hour. The decision is to compute feasible dispatch for the thermal technologies, curtailment of renewable availability, and the realized storage actions that are as close as possible to specified storage actions, while satisfying capacity limits, ramp limits, and storage energy and power limits.\n\nFundamental base:\n- Conservation of energy requires that, within a time slice, the total supply equals the total demand after accounting for curtailment, storage charge and discharge, and any unserved energy slack. Let $D$ be the demand (in MW), $\\{g_i\\}_{i=1}^2$ be thermal dispatch (in MW), $R$ be renewable availability (in MW), $c$ be renewable curtailment (in MW), $p^{\\mathrm{ch}}$ be storage charging power (in MW), $p^{\\mathrm{dis}}$ be storage discharging power (in MW), and $u$ be nonnegative unserved energy slack (in MW). The balance is:\n$$\ng_1 + g_2 + R - c + p^{\\mathrm{dis}} - p^{\\mathrm{ch}} + u = D.\n$$\n- Thermal technology capacity limits: for each thermal technology $i \\in \\{1,2\\}$, the dispatch $g_i$ must satisfy\n$$\n0 \\le g_i \\le \\overline{G}_i,\n$$\nwhere $\\overline{G}_i$ is the nameplate capacity (in MW).\n- Thermal technology ramp limits: given previous period dispatch $g_i^{\\mathrm{prev}}$ (in MW), ramp-up limit $\\overline{R}_i^{\\mathrm{up}}$ (in MW), and ramp-down limit $\\overline{R}_i^{\\mathrm{down}}$ (in MW), the current dispatch must satisfy\n$$\ng_i \\le g_i^{\\mathrm{prev}} + \\overline{R}_i^{\\mathrm{up}}, \\quad g_i \\ge g_i^{\\mathrm{prev}} - \\overline{R}_i^{\\mathrm{down}}.\n$$\n- Renewable curtailment limits: curtailment $c$ must satisfy\n$$\n0 \\le c \\le R.\n$$\n- Storage power limits: charging $p^{\\mathrm{ch}}$ and discharging $p^{\\mathrm{dis}}$ must satisfy\n$$\n0 \\le p^{\\mathrm{ch}} \\le \\overline{P}, \\quad 0 \\le p^{\\mathrm{dis}} \\le \\overline{P},\n$$\nwhere $\\overline{P}$ is the storage power capacity (in MW).\n- Storage energy limits: let the State of Charge (SoC) be $E$ (in MWh). Given $E^{\\mathrm{prev}}$ (in MWh), charging efficiency $\\eta^{\\mathrm{ch}} \\in (0,1]$, discharging efficiency $\\eta^{\\mathrm{dis}} \\in (0,1]$, and energy bounds $\\underline{E}$ and $\\overline{E}$ (in MWh), the next SoC is\n$$\nE^{\\mathrm{new}} = E^{\\mathrm{prev}} + \\eta^{\\mathrm{ch}} p^{\\mathrm{ch}} \\Delta t - \\frac{1}{\\eta^{\\mathrm{dis}}} p^{\\mathrm{dis}} \\Delta t,\n$$\nand must satisfy\n$$\n\\underline{E} \\le E^{\\mathrm{new}} \\le \\overline{E}.\n$$\n\nTo select a unique feasible dispatch when multiple exist, define a linear objective to minimize a weighted sum of thermal generation costs, renewable curtailment penalties, unserved energy penalties, and the absolute deviation between the realized storage actions and the specified storage actions. Let $\\alpha_i$ be the cost coefficient for $g_i$ (dimensionless weights, representing monetary units per MWh but used purely as numerical weights), $\\pi^{\\mathrm{curt}}$ be the curtailment penalty weight, $\\pi^{\\mathrm{unserved}}$ be the unserved energy penalty weight, and $\\lambda$ be the penalty for deviation from the specified storage actions. Let the specified storage actions be $p^{\\mathrm{ch},*}$ and $p^{\\mathrm{dis},*}$ (in MW). Introduce nonnegative deviation variables $d^{\\mathrm{ch},+}, d^{\\mathrm{ch},-}, d^{\\mathrm{dis},+}, d^{\\mathrm{dis},-}$ enforcing\n$$\np^{\\mathrm{ch}} - p^{\\mathrm{ch},*} = d^{\\mathrm{ch},+} - d^{\\mathrm{ch},-}, \\quad p^{\\mathrm{dis}} - p^{\\mathrm{dis},*} = d^{\\mathrm{dis},+} - d^{\\mathrm{dis},-}.\n$$\nThe objective is\n$$\n\\min \\;\\; \\alpha_1 g_1 + \\alpha_2 g_2 + \\pi^{\\mathrm{curt}} c + \\pi^{\\mathrm{unserved}} u + \\lambda \\left( d^{\\mathrm{ch},+} + d^{\\mathrm{ch},-} + d^{\\mathrm{dis},+} + d^{\\mathrm{dis},-} \\right).\n$$\n\nYour task is to implement a program that, for each test case below, solves the above linear optimization problem to compute one feasible dispatch solution and reports the results.\n\nUnits and output requirements:\n- All power quantities ($g_1$, $g_2$, $c$, $u$, $p^{\\mathrm{ch}}$, $p^{\\mathrm{dis}}$) must be reported in MW, rounded to three decimal places.\n- The feasibility check for the specified storage actions must be reported as a boolean indicating whether $p^{\\mathrm{ch},*}$ and $p^{\\mathrm{dis},*}$ themselves satisfy the storage power and energy limits without adjustment.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each test caseâ€™s result must be a list in the format $[g_1,g_2,c,u,p^{\\mathrm{ch}},p^{\\mathrm{dis}},\\text{feasible\\_storage}]$.\n\nTest suite and parameters (all quantities in MW or MWh as indicated; efficiencies are dimensionless decimals; use $\\Delta t = 1$ hour):\n\n- Test case $1$ (happy path, no binding constraints besides cost ordering):\n    - Demand $D = 150$ MW, renewable availability $R = 60$ MW.\n    - Thermal $1$: $\\overline{G}_1 = 100$ MW, $g_1^{\\mathrm{prev}} = 50$ MW, $\\overline{R}_1^{\\mathrm{up}} = 60$ MW, $\\overline{R}_1^{\\mathrm{down}} = 60$ MW, cost $\\alpha_1 = 30$.\n    - Thermal $2$: $\\overline{G}_2 = 80$ MW, $g_2^{\\mathrm{prev}} = 40$ MW, $\\overline{R}_2^{\\mathrm{up}} = 80$ MW, $\\overline{R}_2^{\\mathrm{down}} = 80$ MW, cost $\\alpha_2 = 60$.\n    - Storage: $\\overline{P} = 50$ MW, $\\eta^{\\mathrm{ch}} = 0.95$, $\\eta^{\\mathrm{dis}} = 0.9$, $E^{\\mathrm{prev}} = 100$ MWh, $\\underline{E} = 20$ MWh, $\\overline{E} = 180$ MWh, specified $p^{\\mathrm{ch},*} = 0$ MW, $p^{\\mathrm{dis},*} = 20$ MW.\n- Test case $2$ (ramp and capacity binding causing unserved energy):\n    - Demand $D = 200$ MW, renewable availability $R = 40$ MW.\n    - Thermal $1$: $\\overline{G}_1 = 100$ MW, $g_1^{\\mathrm{prev}} = 10$ MW, $\\overline{R}_1^{\\mathrm{up}} = 20$ MW, $\\overline{R}_1^{\\mathrm{down}} = 10$ MW, cost $\\alpha_1 = 30$.\n    - Thermal $2$: $\\overline{G}_2 = 120$ MW, $g_2^{\\mathrm{prev}} = 10$ MW, $\\overline{R}_2^{\\mathrm{up}} = 200$ MW, $\\overline{R}_2^{\\mathrm{down}} = 10$ MW, cost $\\alpha_2 = 60$.\n    - Storage: $\\overline{P} = 50$ MW, $\\eta^{\\mathrm{ch}} = 0.95$, $\\eta^{\\mathrm{dis}} = 0.9$, $E^{\\mathrm{prev}} = 100$ MWh, $\\underline{E} = 20$ MWh, $\\overline{E} = 180$ MWh, specified $p^{\\mathrm{ch},*} = 0$ MW, $p^{\\mathrm{dis},*} = 0$ MW.\n- Test case $3$ (specified storage discharge exceeding power capacity, corrected by optimization):\n    - Demand $D = 180$ MW, renewable availability $R = 20$ MW.\n    - Thermal $1$: $\\overline{G}_1 = 100$ MW, $g_1^{\\mathrm{prev}} = 60$ MW, $\\overline{R}_1^{\\mathrm{up}} = 40$ MW, $\\overline{R}_1^{\\mathrm{down}} = 80$ MW, cost $\\alpha_1 = 30$.\n    - Thermal $2$: $\\overline{G}_2 = 80$ MW, $g_2^{\\mathrm{prev}} = 50$ MW, $\\overline{R}_2^{\\mathrm{up}} = 50$ MW, $\\overline{R}_2^{\\mathrm{down}} = 50$ MW, cost $\\alpha_2 = 60$.\n    - Storage: $\\overline{P} = 50$ MW, $\\eta^{\\mathrm{ch}} = 0.95$, $\\eta^{\\mathrm{dis}} = 0.9$, $E^{\\mathrm{prev}} = 150$ MWh, $\\underline{E} = 60$ MWh, $\\overline{E} = 160$ MWh, specified $p^{\\mathrm{ch},*} = 0$ MW, $p^{\\mathrm{dis},*} = 80$ MW.\n- Test case $4$ (specified storage discharge violating energy bound, corrected by optimization):\n    - Demand $D = 100$ MW, renewable availability $R = 50$ MW.\n    - Thermal $1$: $\\overline{G}_1 = 100$ MW, $g_1^{\\mathrm{prev}} = 0$ MW, $\\overline{R}_1^{\\mathrm{up}} = 50$ MW, $\\overline{R}_1^{\\mathrm{down}} = 50$ MW, cost $\\alpha_1 = 30$.\n    - Thermal $2$: $\\overline{G}_2 = 80$ MW, $g_2^{\\mathrm{prev}} = 0$ MW, $\\overline{R}_2^{\\mathrm{up}} = 80$ MW, $\\overline{R}_2^{\\mathrm{down}} = 80$ MW, cost $\\alpha_2 = 60$.\n    - Storage: $\\overline{P} = 50$ MW, $\\eta^{\\mathrm{ch}} = 0.95$, $\\eta^{\\mathrm{dis}} = 0.9$, $E^{\\mathrm{prev}} = 65$ MWh, $\\underline{E} = 60$ MWh, $\\overline{E} = 200$ MWh, specified $p^{\\mathrm{ch},*} = 0$ MW, $p^{\\mathrm{dis},*} = 50$ MW.\n\nPenalty weights for the objective (used uniformly across all test cases):\n- Curtailment penalty $\\pi^{\\mathrm{curt}} = 100$,\n- Unserved energy penalty $\\pi^{\\mathrm{unserved}} = 10000$,\n- Storage deviation penalty $\\lambda = 1$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each result must be a list $[g_1,g_2,c,u,p^{\\mathrm{ch}},p^{\\mathrm{dis}},\\text{feasible\\_storage}]$ with all numeric entries in MW rounded to three decimals and the boolean as either True or False, for the four test cases in order.",
            "solution": "The user has provided a well-defined linear optimization problem representative of a single-period economic dispatch task in energy systems modeling. The problem is scientifically sound, mathematically consistent, and contains all necessary data for a unique solution to be found. Therefore, the problem is deemed valid.\n\nThe task is to find a feasible and economically optimal dispatch schedule for a system comprising two thermal generators, one variable renewable source, and one energy storage unit. The optimality is defined by minimizing a linear objective function representing generation costs, penalties for curtailing renewable energy, penalties for unserved energy, and penalties for deviating from a specified storage operation schedule. The solution must adhere to a set of linear constraints: energy conservation, generator capacity and ramp limits, and storage power and energy limits.\n\nThis problem can be formulated as a Linear Program (LP), which can be solved using standard optimization solvers. The LP is structured as follows:\n\nMinimize:\n$$ c^T x $$\nSubject to:\n$$ A_{eq} x = b_{eq} $$\n$$ A_{ub} x \\le b_{ub} $$\n$$ lb \\le x \\le ub $$\n\nThe components of this formulation are defined as follows:\n\n**1. Decision Variables ($x$)**\nThe vector of decision variables $x$ includes all quantities to be determined by the optimization. We define it as a 10-element vector:\n$$ x = [g_1, g_2, c, p^{\\mathrm{ch}}, p^{\\mathrm{dis}}, u, d^{\\mathrm{ch},+}, d^{\\mathrm{ch},-}, d^{\\mathrm{dis},+}, d^{\\mathrm{dis},-}]^T $$\nwhere:\n- $g_1, g_2$: Power output from thermal generators 1 and 2 (MW).\n- $c$: Curtailed renewable power (MW).\n- $p^{\\mathrm{ch}}, p^{\\mathrm{dis}}$: Storage charging and discharging power (MW).\n- $u$: Unserved energy (power deficit slack) (MW).\n- $d^{\\mathrm{ch},+}, d^{\\mathrm{ch},-}, d^{\\mathrm{dis},+}, d^{\\mathrm{dis},-}$: Non-negative deviation variables for storage actions (MW).\n\n**2. Objective Function ($c^T x$)**\nThe objective is to minimize a weighted sum of costs and penalties. The cost vector $c$ corresponds to the coefficients of the variables in the objective function:\n$$ \\min \\;\\; \\alpha_1 g_1 + \\alpha_2 g_2 + \\pi^{\\mathrm{curt}} c + \\pi^{\\mathrm{unserved}} u + \\lambda (d^{\\mathrm{ch},+} + d^{\\mathrm{ch},-} + d^{\\mathrm{dis},+} + d^{\\mathrm{dis},-}) $$\nThus, the cost vector $c$ is:\n$$ c = [\\alpha_1, \\alpha_2, \\pi^{\\mathrm{curt}}, 0, 0, \\pi^{\\mathrm{unserved}}, \\lambda, \\lambda, \\lambda, \\lambda]^T $$\n\n**3. Equality Constraints ($A_{eq} x = b_{eq}$)**\nThere are three equality constraints:\n- **Energy Balance:** Total generation must equal total consumption.\n  $$ g_1 + g_2 - c - p^{\\mathrm{ch}} + p^{\\mathrm{dis}} + u = D - R $$\n- **Storage Charge Deviation:** This defines the relationship between realized charge, target charge, and deviation variables.\n  $$ p^{\\mathrm{ch}} - d^{\\mathrm{ch},+} + d^{\\mathrm{ch},-} = p^{\\mathrm{ch},*} $$\n- **Storage Discharge Deviation:** Similarly for discharge.\n  $$ p^{\\mathrm{dis}} - d^{\\mathrm{dis},+} + d^{\\mathrm{dis},-} = p^{\\mathrm{dis},*} $$\nThese three equations form the rows of the $A_{eq}$ matrix and the elements of the $b_{eq}$ vector.\n\n**4. Inequality Constraints ($A_{ub} x \\le b_{ub}$)**\nThe storage state of charge (SoC) must remain within its energy bounds. With $\\Delta t = 1$ hour:\n$$ \\underline{E} \\le E^{\\mathrm{prev}} + \\eta^{\\mathrm{ch}} p^{\\mathrm{ch}} - \\frac{1}{\\eta^{\\mathrm{dis}}} p^{\\mathrm{dis}} \\le \\overline{E} $$\nThis yields two linear inequality constraints:\n- $\\eta^{\\mathrm{ch}} p^{\\mathrm{ch}} - \\frac{1}{\\eta^{\\mathrm{dis}}} p^{\\mathrm{dis}} \\le \\overline{E} - E^{\\mathrm{prev}}$\n- $-\\eta^{\\mathrm{ch}} p^{\\mathrm{ch}} + \\frac{1}{\\eta^{\\mathrm{dis}}} p^{\\mathrm{dis}} \\le E^{\\mathrm{prev}} - \\underline{E}$\nThese two inequalities form the rows of the $A_{ub}$ matrix and the elements of the $b_{ub}$ vector.\n\n**5. Variable Bounds ($lb \\le x \\le ub$)**\nAll other constraints are expressed as simple bounds on the decision variables:\n- **Thermal Generation:** The dispatch for each generator $i$ is limited by its minimum output (0), maximum capacity $\\overline{G}_i$, and its ramp-rate limits.\n  $$ \\max(0, g_i^{\\mathrm{prev}} - \\overline{R}_i^{\\mathrm{down}}) \\le g_i \\le \\min(\\overline{G}_i, g_i^{\\mathrm{prev}} + \\overline{R}_i^{\\mathrm{up}}) $$\n- **Renewable Curtailment:** Curtailment cannot be negative or exceed available renewable generation $R$.\n  $$ 0 \\le c \\le R $$\n- **Storage Power:** Charging and discharging are limited by the storage power capacity $\\overline{P}$.\n  $$ 0 \\le p^{\\mathrm{ch}} \\le \\overline{P} $$\n  $$ 0 \\le p^{\\mathrm{dis}} \\le \\overline{P} $$\n- **Non-negativity:** The unserved energy and all deviation variables must be non-negative.\n  $$ u, d^{\\mathrm{ch},+}, d^{\\mathrm{ch},-}, d^{\\mathrm{dis},+}, d^{\\mathrm{dis},-} \\ge 0 $$\n\nThe solution is implemented in Python using the `scipy.optimize.linprog` function, which is designed to solve such LP problems. For each test case, we first perform a preliminary check to determine if the specified storage actions ($p^{\\mathrm{ch},*}, p^{\\mathrm{dis},*}$) are feasible on their own. Then, the LP model is constructed with the specific parameters of the test case and solved to find the optimal dispatch values. The final results are rounded and formatted as required.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef solve():\n    \"\"\"\n    Solves the single-period dispatch optimization problem for a series of test cases.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1\n        {\n            \"D\": 150, \"R\": 60,\n            \"g1_params\": {\"G_bar\": 100, \"g_prev\": 50, \"R_up\": 60, \"R_down\": 60, \"alpha\": 30},\n            \"g2_params\": {\"G_bar\": 80, \"g_prev\": 40, \"R_up\": 80, \"R_down\": 80, \"alpha\": 60},\n            \"storage_params\": {\"P_bar\": 50, \"eta_ch\": 0.95, \"eta_dis\": 0.9, \"E_prev\": 100, \"E_underline\": 20, \"E_bar\": 180, \"p_ch_star\": 0, \"p_dis_star\": 20},\n        },\n        # Test case 2\n        {\n            \"D\": 200, \"R\": 40,\n            \"g1_params\": {\"G_bar\": 100, \"g_prev\": 10, \"R_up\": 20, \"R_down\": 10, \"alpha\": 30},\n            \"g2_params\": {\"G_bar\": 120, \"g_prev\": 10, \"R_up\": 200, \"R_down\": 10, \"alpha\": 60},\n            \"storage_params\": {\"P_bar\": 50, \"eta_ch\": 0.95, \"eta_dis\": 0.9, \"E_prev\": 100, \"E_underline\": 20, \"E_bar\": 180, \"p_ch_star\": 0, \"p_dis_star\": 0},\n        },\n        # Test case 3\n        {\n            \"D\": 180, \"R\": 20,\n            \"g1_params\": {\"G_bar\": 100, \"g_prev\": 60, \"R_up\": 40, \"R_down\": 80, \"alpha\": 30},\n            \"g2_params\": {\"G_bar\": 80, \"g_prev\": 50, \"R_up\": 50, \"R_down\": 50, \"alpha\": 60},\n            \"storage_params\": {\"P_bar\": 50, \"eta_ch\": 0.95, \"eta_dis\": 0.9, \"E_prev\": 150, \"E_underline\": 60, \"E_bar\": 160, \"p_ch_star\": 0, \"p_dis_star\": 80},\n        },\n        # Test case 4\n        {\n            \"D\": 100, \"R\": 50,\n            \"g1_params\": {\"G_bar\": 100, \"g_prev\": 0, \"R_up\": 50, \"R_down\": 50, \"alpha\": 30},\n            \"g2_params\": {\"G_bar\": 80, \"g_prev\": 0, \"R_up\": 80, \"R_down\": 80, \"alpha\": 60},\n            \"storage_params\": {\"P_bar\": 50, \"eta_ch\": 0.95, \"eta_dis\": 0.9, \"E_prev\": 65, \"E_underline\": 60, \"E_bar\": 200, \"p_ch_star\": 0, \"p_dis_star\": 50},\n        }\n    ]\n    \n    # Uniform penalty weights\n    pi_curt = 100\n    pi_unserved = 10000\n    L = 1 # lambda\n\n    results = []\n    \n    for case in test_cases:\n        D, R = case[\"D\"], case[\"R\"]\n        g1p, g2p, sp = case[\"g1_params\"], case[\"g2_params\"], case[\"storage_params\"]\n        \n        # 1. Feasibility check for specified storage actions\n        E_new_star = sp[\"E_prev\"] + sp[\"eta_ch\"] * sp[\"p_ch_star\"] * 1.0 - (1/sp[\"eta_dis\"]) * sp[\"p_dis_star\"] * 1.0\n        feasible_storage = (0 <= sp[\"p_ch_star\"] <= sp[\"P_bar\"] and\n                            0 <= sp[\"p_dis_star\"] <= sp[\"P_bar\"] and\n                            sp[\"E_underline\"] <= E_new_star <= sp[\"E_bar\"])\n        \n        # 2. Define LP problem\n        # Decision variables: x = [g1, g2, c, pch, pdis, u, d_ch+, d_ch-, d_dis+, d_dis-]\n        c_vec = np.array([g1p[\"alpha\"], g2p[\"alpha\"], pi_curt, 0, 0, pi_unserved, L, L, L, L])\n        \n        # Equality constraints\n        A_eq = np.array([\n            [1, 1, -1, -1, 1, 1, 0, 0, 0, 0],  # Energy balance\n            [0, 0, 0, 1, 0, 0, -1, 1, 0, 0],  # Charge deviation\n            [0, 0, 0, 0, 1, 0, 0, 0, -1, 1],  # Discharge deviation\n        ])\n        b_eq = np.array([\n            D - R,\n            sp[\"p_ch_star\"],\n            sp[\"p_dis_star\"]\n        ])\n        \n        # Inequality constraints\n        A_ub = np.array([\n            [0, 0, 0, sp[\"eta_ch\"], -1/sp[\"eta_dis\"], 0, 0, 0, 0, 0], # E_new <= E_bar\n            [0, 0, 0, -sp[\"eta_ch\"], 1/sp[\"eta_dis\"], 0, 0, 0, 0, 0], # E_new >= E_underline\n        ])\n        b_ub = np.array([\n            sp[\"E_bar\"] - sp[\"E_prev\"],\n            sp[\"E_prev\"] - sp[\"E_underline\"]\n        ])\n\n        # Variable bounds\n        g1_lb = max(0, g1p[\"g_prev\"] - g1p[\"R_down\"])\n        g1_ub = min(g1p[\"G_bar\"], g1p[\"g_prev\"] + g1p[\"R_up\"])\n        \n        g2_lb = max(0, g2p[\"g_prev\"] - g2p[\"R_down\"])\n        g2_ub = min(g2p[\"G_bar\"], g2p[\"g_prev\"] + g2p[\"R_up\"])\n        \n        bounds = [\n            (g1_lb, g1_ub), (g2_lb, g2_ub), (0, R), \n            (0, sp[\"P_bar\"]), (0, sp[\"P_bar\"]), (0, None),\n            (0, None), (0, None), (0, None), (0, None)\n        ]\n        \n        # 3. Solve the LP\n        res = linprog(c_vec, A_ub=A_ub, b_ub=b_ub, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')\n\n        # 4. Extract, round, and store results\n        if res.success:\n            g1, g2, c_val, p_ch, p_dis, u_val = res.x[:6]\n            \n            result_list = [\n                round(g1, 3), round(g2, 3), round(c_val, 3), \n                round(u_val, 3), round(p_ch, 3), round(p_dis, 3),\n                feasible_storage\n            ]\n            results.append(result_list)\n        else:\n            # Append an error marker if solver fails, though it shouldn't for these problems.\n            results.append([\"Solver failed\"] * 7)\n            \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "The ultimate purpose of capacity expansion models is often to inform policy and investment strategy by exploring trade-offs between competing objectives, such as cost and environmental impact. This exercise demonstrates how to use a simplified two-technology expansion model to generate a policy-relevant trade-off curve, also known as a Pareto frontier, between total system cost and carbon emissions. By systematically varying an emissions cap or a carbon price, you will map out the efficient set of outcomes and quantify the cost of decarbonization .",
            "id": "4074212",
            "problem": "You are to formulate and solve a capacity expansion problem for a simplified power system with two technologies. The objective is to compute a trade-off curve between total system cost and total emissions by varying either an emissions cap or a carbon price. The problem must be formulated from first principles and solved algorithmically as a linear program for each point on the curve. All physical units must be explicitly respected, and all outputs must be reported in the specified units, rounded to two decimals.\n\nFundamental base and modeling assumptions:\n- A single-region electricity system with annual energy demand of $E$ megawatt-hours per year (MWh/year).\n- Two generation technologies indexed by $i \\in \\{\\text{F}, \\text{R}\\}$ representing a fossil technology ($\\text{F}$) and a renewable technology ($\\text{R}$).\n- Decision variables: installed capacities $k_i$ in megawatts (MW) and annual generation $g_i$ in megawatt-hours (MWh).\n- Annual hours $H = 8760$ hours/year.\n- Capacity factor $0 \\leq \\text{CF}_i \\leq 1$ for each technology $i$, relating capacity to maximum annual generation via $g_i \\leq \\text{CF}_i \\cdot H \\cdot k_i$.\n- Annualized capacity cost $c_i^{\\text{cap}}$ in dollars per megawatt-year ($\\$/\\text{MW-year}$) and variable operating cost $c_i^{\\text{var}}$ in dollars per megawatt-hour ($\\$/\\text{MWh}$).\n- Emissions intensity $e_i$ in metric tonnes of carbon dioxide per megawatt-hour ($\\text{tCO}_2/\\text{MWh}$).\n- Load balance: $\\sum_i g_i = E$.\n- Non-negativity: $k_i \\geq 0$, $g_i \\geq 0$.\n\nTwo problem variants must be solved repeatedly to trace trade-off curves:\n1. Emissions cap formulation: Minimize total annual system cost subject to an upper bound on total annual emissions,\n$$\n\\min_{k_i,g_i} \\sum_i \\left( c_i^{\\text{cap}} k_i + c_i^{\\text{var}} g_i \\right) \\quad \\text{subject to} \\quad \\sum_i g_i = E, \\; g_i \\leq \\text{CF}_i H k_i, \\; \\sum_i e_i g_i \\leq \\text{Cap}, \\; k_i,g_i \\geq 0,\n$$\nwhere $\\text{Cap}$ is the emissions cap in $\\text{tCO}_2/\\text{year}$.\n2. Carbon price formulation: Minimize total annual social cost including carbon pricing,\n$$\n\\min_{k_i,g_i} \\sum_i \\left( c_i^{\\text{cap}} k_i + c_i^{\\text{var}} g_i \\right) + \\tau \\sum_i e_i g_i \\quad \\text{subject to} \\quad \\sum_i g_i = E, \\; g_i \\leq \\text{CF}_i H k_i, \\; k_i,g_i \\geq 0,\n$$\nwhere $\\tau$ is the carbon price in dollars per tonne of carbon dioxide ($\\$/\\text{tCO}_2$).\n\nFor each problem instance, the unconstrained least-cost solution (no emissions cap and zero carbon price) must be computed first to determine the corresponding unconstrained emissions level, denoted $E_{\\text{unc}}$ in $\\text{tCO}_2/\\text{year}$. Then, for the emissions cap formulation, compute optimal solutions for a sweep of caps linearly spaced between $0$ and $E_{\\text{unc}}$, inclusive. For the carbon price formulation, compute optimal solutions for a specified set of carbon prices. For each solution, record the pair consisting of total emissions and total annual system cost.\n\nUnits and output requirements:\n- Emissions must be reported in metric tonnes of carbon dioxide per year ($\\text{tCO}_2/\\text{year}$).\n- Costs must be reported in dollars per year ($\\$/\\text{year}$).\n- Carbon prices must be in dollars per tonne of carbon dioxide ($\\$/\\text{tCO}_2$).\n- All numeric outputs must be rounded to two decimals.\n\nTest suite:\nCompute trade-off curves for the following three test cases. In each case, first compute $E_{\\text{unc}}$, then:\n- Emissions cap sweep: $6$ evenly spaced caps between $0$ and $E_{\\text{unc}}$ inclusive.\n- Carbon price sweep: prices $\\tau \\in \\{0,\\;25,\\;50,\\;100,\\;200,\\;400\\}$ in $\\$/\\text{tCO}_2$.\n\nCommon constant: $H=8760$ hours/year.\n\nTest case $1$ (happy path):\n- Demand $E = 5{,}000{,}000$ MWh/year.\n- Fossil technology ($\\text{F}$): $c_{\\text{F}}^{\\text{cap}} = 100{,}000$ $\\$/\\text{MW-year}$, $c_{\\text{F}}^{\\text{var}} = 20$ $\\$/\\text{MWh}$, $\\text{CF}_{\\text{F}} = 0.9$, $e_{\\text{F}} = 0.6$ $\\text{tCO}_2/\\text{MWh}$.\n- Renewable technology ($\\text{R}$): $c_{\\text{R}}^{\\text{cap}} = 150{,}000$ $\\$/\\text{MW-year}$, $c_{\\text{R}}^{\\text{var}} = 5$ $\\$/\\text{MWh}$, $\\text{CF}_{\\text{R}} = 0.4$, $e_{\\text{R}} = 0$ $\\text{tCO}_2/\\text{MWh}$.\n\nTest case $2$ (higher renewable capital intensity via lower capacity factor):\n- Demand $E = 2{,}000{,}000$ MWh/year.\n- Fossil technology ($\\text{F}$): $c_{\\text{F}}^{\\text{cap}} = 100{,}000$ $\\$/\\text{MW-year}$, $c_{\\text{F}}^{\\text{var}} = 20$ $\\$/\\text{MWh}$, $\\text{CF}_{\\text{F}} = 0.9$, $e_{\\text{F}} = 0.6$ $\\text{tCO}_2/\\text{MWh}$.\n- Renewable technology ($\\text{R}$): $c_{\\text{R}}^{\\text{cap}} = 180{,}000$ $\\$/\\text{MW-year}$, $c_{\\text{R}}^{\\text{var}} = 5$ $\\$/\\text{MWh}$, $\\text{CF}_{\\text{R}} = 0.25$, $e_{\\text{R}} = 0$ $\\text{tCO}_2/\\text{MWh}$.\n\nTest case $3$ (boundary case: zero demand):\n- Demand $E = 0$ MWh/year.\n- Fossil technology ($\\text{F}$): $c_{\\text{F}}^{\\text{cap}} = 100{,}000$ $\\$/\\text{MW-year}$, $c_{\\text{F}}^{\\text{var}} = 20$ $\\$/\\text{MWh}$, $\\text{CF}_{\\text{F}} = 0.9$, $e_{\\text{F}} = 0.6$ $\\text{tCO}_2/\\text{MWh}$.\n- Renewable technology ($\\text{R}$): $c_{\\text{R}}^{\\text{cap}} = 150{,}000$ $\\$/\\text{MW-year}$, $c_{\\text{R}}^{\\text{var}} = 5$ $\\$/\\text{MWh}$, $\\text{CF}_{\\text{R}} = 0.4$, $e_{\\text{R}} = 0$ $\\text{tCO}_2/\\text{MWh}$.\n\nRequired final output format:\n- Your program should produce a single line of output containing, for each test case, two lists: the emissions-cap trade-off curve and the carbon-price trade-off curve. Each curve must be a list of pairs, with each pair given as $[\\text{emissions}, \\text{cost}]$ where emissions are in $\\text{tCO}_2/\\text{year}$ and cost is in $\\$/\\text{year}$, both rounded to two decimals.\n- The overall output must thus be a list with three elements (one per test case), where each element is a list of two elements: the first is the cap-sweep curve, and the second is the price-sweep curve. For example: $[[[[e_{11},c_{11}],[e_{12},c_{12}],\\dots],[[e'_{11},c'_{11}],[e'_{12},c'_{12}],\\dots]], \\dots ]$.",
            "solution": "The user problem has been validated and is determined to be a valid, well-posed scientific problem.\n\n### **1. Problem Formulation from First Principles**\n\nThe problem asks to find the minimum cost technology mix to meet an electricity demand $E$, subject to various constraints. The decision variables are the installed capacities $k_i$ [MW] and annual generation levels $g_i$ [MWh] for two technologies, fossil ($\\text{F}$) and renewable ($\\text{R}$).\n\nThe objective function to be minimized is the total annual system cost, which is the sum of annualized capital costs and variable operating costs:\n$$\n\\text{Cost} = \\sum_{i \\in \\{\\text{F,R}\\}} \\left( c_i^{\\text{cap}} k_i + c_i^{\\text{var}} g_i \\right)\n$$\nwhere $c_i^{\\text{cap}}$ is in [$\\$/\\text{MW-year}$] and $c_i^{\\text{var}}$ is in [$\\$/\\text{MWh}$].\n\nThe constraints are:\n1.  **Load Balance**: The total generation must meet the annual demand $E$.\n    $$ \\sum_i g_i = g_{\\text{F}} + g_{\\text{R}} = E $$\n2.  **Capacity Constraint**: The annual generation from a technology is limited by its installed capacity $k_i$ and its capacity factor $\\text{CF}_i$. With $H=8760$ hours in a year, this is:\n    $$ g_i \\leq \\text{CF}_i \\cdot H \\cdot k_i \\quad \\text{for } i \\in \\{\\text{F,R}\\} $$\n3.  **Non-negativity**: All capacities and generation levels must be non-negative.\n    $$ k_i \\geq 0, \\quad g_i \\geq 0 $$\n\nSince capital costs $c_i^{\\text{cap}}$ are non-negative, a cost-minimizing solution will never build more capacity than is necessary. Thus, the capacity constraint can be treated as an equality for the required capacity: $k_i = g_i / (\\text{CF}_i \\cdot H)$. We can substitute this expression for $k_i$ into the objective function to eliminate the capacity variables:\n$$\n\\text{Cost} = \\sum_i \\left( c_i^{\\text{cap}} \\frac{g_i}{\\text{CF}_i \\cdot H} + c_i^{\\text{var}} g_i \\right) = \\sum_i g_i \\left( c_i^{\\text{var}} + \\frac{c_i^{\\text{cap}}}{\\text{CF}_i \\cdot H} \\right)\n$$\nThis allows us to define an *effective levelized cost of generation* for each technology, $C_i^{\\text{eff}}$, in units of [$\\$/\\text{MWh}$]:\n$$\nC_i^{\\text{eff}} \\equiv c_i^{\\text{var}} + \\frac{c_i^{\\text{cap}}}{\\text{CF}_i \\cdot H}\n$$\nThe optimization problem is now simplified to choosing the generation levels $g_F$ and $g_R$ to minimize the total effective cost, subject to the load balance and any additional policy constraints:\n$$\n\\min_{g_F, g_R} \\left( C_{\\text{F}}^{\\text{eff}} g_{\\text{F}} + C_{\\text{R}}^{\\text{eff}} g_{\\text{R}} \\right) \\quad \\text{s.t.} \\quad g_{\\text{F}} + g_{\\text{R}} = E, \\quad g_{\\text{F}}, g_{\\text{R}} \\geq 0\n$$\n\n### **2. Solving the Optimization Variants**\n\n#### **Unconstrained Least-Cost Solution**\nIn the absence of any emissions policies, the optimal strategy is to meet the entire demand $E$ using the technology with the lower effective cost $C_i^{\\text{eff}}$.\n- If $C_{\\text{F}}^{\\text{eff}} < C_{\\text{R}}^{\\text{eff}}$, the optimal solution is $g_{\\text{F}} = E$ and $g_{\\text{R}} = 0$.\n- If $C_{\\text{R}}^{\\text{eff}} \\leq C_{\\text{F}}^{\\text{eff}}$, the optimal solution is $g_{\\text{R}} = E$ and $g_{\\text{F}} = 0$. (In case of a tie, the cleaner technology is chosen.)\n\nThe total system cost is $C_{\\text{unc}} = C_{\\text{F}}^{\\text{eff}} g_{\\text{F}} + C_{\\text{R}}^{\\text{eff}} g_{\\text{R}}$ and the total unconstrained emissions are $E_{\\text{unc}} = e_{\\text{F}} g_{\\text{F}} + e_{\\text{R}} g_{\\text{R}}$.\n\n#### **Emissions Cap Formulation**\nAn additional constraint is added:\n$$ \\sum_i e_i g_i = e_{\\text{F}} g_{\\text{F}} + e_{\\text{R}} g_{\\text{R}} \\leq \\text{Cap} $$\nGiven that $e_{\\text{R}} = 0$ in all test cases, this simplifies to $e_{\\text{F}} g_{\\text{F}} \\leq \\text{Cap}$, which implies an upper limit on fossil generation: $g_{\\text{F}} \\leq \\text{Cap}/e_{\\text{F}}$.\nThe optimization problem for $g_F$ is:\n$$\n\\min_{g_F} \\left( (C_{\\text{F}}^{\\text{eff}} - C_{\\text{R}}^{\\text{eff}}) g_{\\text{F}} + C_{\\text{R}}^{\\text{eff}}E \\right) \\quad \\text{s.t.} \\quad 0 \\leq g_{\\text{F}} \\leq E \\quad \\text{and} \\quad g_{\\text{F}} \\leq \\frac{\\text{Cap}}{e_{\\text{F}}}\n$$\nThe solution depends on the relative costs:\n- If $C_{\\text{F}}^{\\text{eff}} < C_{\\text{R}}^{\\text{eff}}$, the term $(C_{\\text{F}}^{\\text{eff}} - C_{\\text{R}}^{\\text{eff}})$ is negative. To minimize the cost, we must maximize $g_{\\text{F}}$. The optimal value is thus $g_{\\text{F}} = \\min(E, \\text{Cap}/e_{\\text{F}})$.\n- If $C_{\\text{R}}^{\\text{eff}} \\leq C_{\\text{F}}^{\\text{eff}}$, the term is non-negative. To minimize cost, we must minimize $g_{\\text{F}}$. The optimal value is $g_{\\text{F}} = 0$. This solution is always feasible for any non-negative cap, as emissions would be $0$.\n\nOnce $g_{\\text{F}}$ is determined, $g_{\\text{R}} = E - g_{\\text{F}}$. The total cost and emissions are then calculated.\n\n#### **Carbon Price Formulation**\nThe objective function is modified to include a cost for emissions, where $\\tau$ is the carbon price [$\\$/\\text{tCO}_2$]:\n$$\n\\min \\sum_i \\left( c_i^{\\text{cap}} k_i + c_i^{\\text{var}} g_i \\right) + \\tau \\sum_i e_i g_i = \\min \\sum_i g_i \\left( C_i^{\\text{eff}} + \\tau e_i \\right)\n$$\nWe define a *carbon-adjusted effective cost* $\\tilde{C}_i^{\\text{eff}}(\\tau) = C_i^{\\text{eff}} + \\tau e_i$. The problem is then equivalent to the unconstrained case, but comparing $\\tilde{C}_{\\text{F}}^{\\text{eff}}(\\tau)$ and $\\tilde{C}_{\\text{R}}^{\\text{eff}}(\\tau)$.\n$$\n\\tilde{C}_{\\text{F}}^{\\text{eff}}(\\tau) = C_{\\text{F}}^{\\text{eff}} + \\tau e_{\\text{F}} \\quad \\text{and} \\quad \\tilde{C}_{\\text{R}}^{\\text{eff}}(\\tau) = C_{\\text{R}}^{\\text{eff}} + \\tau e_{\\text{R}} = C_{\\text{R}}^{\\text{eff}} \\quad (\\text{since } e_{\\text{R}}=0)\n$$\nThe cheaper technology is fossil fuel if $\\tilde{C}_{\\text{F}}^{\\text{eff}}(\\tau) < \\tilde{C}_{\\text{R}}^{\\text{eff}}(\\tau)$, which means $C_{\\text{F}}^{\\text{eff}} + \\tau e_{\\text{F}} < C_{\\text{R}}^{\\text{eff}}$. This inequality defines a breakeven or *switch price*, $\\tau_{\\text{switch}}$:\n$$\n\\tau_{\\text{switch}} = \\frac{C_{\\text{R}}^{\\text{eff}} - C_{\\text{F}}^{\\text{eff}}}{e_{\\text{F}}}\n$$\n- If the unconstrained fossil option is cheaper ($C_{\\text{F}}^{\\text{eff}} < C_{\\text{R}}^{\\text{eff}}$), then $\\tau_{\\text{switch}} > 0$. For any given price $\\tau$:\n    - If $\\tau < \\tau_{\\text{switch}}$, fossil remains cheaper overall, so $g_{\\text{F}} = E, g_{\\text{R}} = 0$.\n    - If $\\tau \\geq \\tau_{\\text{switch}}$, renewable becomes cost-competitive or cheaper, so $g_{\\text{F}} = 0, g_{\\text{R}} = E$.\n- If the unconstrained renewable option is cheaper or equal ($C_{\\text{R}}^{\\text{eff}} \\leq C_{\\text{F}}^{\\text{eff}}$), then $\\tau_{\\text{switch}} \\leq 0$. For any non-negative price $\\tau$, renewable remains the cheaper option, so $g_{\\text{F}} = 0, g_{\\text{R}} = E$.\n\nFor each point, we report the *system cost* $\\sum_i C_i^{\\text{eff}} g_i$ and the emissions $\\sum_i e_i g_i$. The carbon tax component $\\tau \\sum_i e_i g_i$ is part of the objective function for decision-making but not part of the final reported system cost.\n\n### **3. Algorithmic Implementation**\n\nFor each test case, the algorithm proceeds as follows:\n1.  Calculate $C_{\\text{F}}^{\\text{eff}}$ and $C_{\\text{R}}^{\\text{eff}}$.\n2.  Solve the unconstrained case to find the generation mix and the unconstrained emissions level $E_{\\text{unc}}$.\n3.  **Emissions Cap Sweep**:\n    - Generate an array of $6$ emission caps from $0$ to $E_{\\text{unc}}$.\n    - For each `Cap`, calculate the optimal $g_{\\text{F}}$ and $g_{\\text{R}}$ using the derived logic.\n    - Compute and store the resulting system cost and emissions.\n4.  **Carbon Price Sweep**:\n    - Calculate $\\tau_{\\text{switch}}$.\n    - For each provided carbon price `tau`, compare it to $\\tau_{\\text{switch}}$ to determine the optimal $g_{\\text{F}}$ and $g_{\\text{R}}$.\n    - Compute and store the resulting system cost and emissions.\n5.  All numerical results for cost and emissions are rounded to two decimal places for reporting.\n6. A special formatting function is used to convert the nested list structure into the required string format without whitespace.",
            "answer": "```python\nimport numpy as np\n\ndef format_list(l):\n    \"\"\"\n    Recursively formats a nested list into a string representation\n    without spaces, with floats formatted to two decimal places.\n    \"\"\"\n    if isinstance(l, (int, float)):\n        return f\"{l:.2f}\"\n    if isinstance(l, list):\n        return f\"[{','.join(format_list(item) for item in l)}]\"\n    return str(l)\n\ndef solve_case(params):\n    \"\"\"\n    Solves a single capacity expansion problem instance for both sweeps.\n    \"\"\"\n    E, c_F_cap, c_F_var, CF_F, e_F, c_R_cap, c_R_var, CF_R, e_R, caps_n, prices = params\n    H = 8760.0\n\n    # Handle the zero-demand boundary case\n    if E == 0:\n        zero_point = [0.00, 0.00]\n        cap_curve = [zero_point] * caps_n\n        price_curve = [zero_point] * len(prices)\n        return [cap_curve, price_curve]\n\n    # Calculate effective levelized costs ($/MWh)\n    # C_eff = c_var + c_cap / (CF * H)\n    C_F_eff = c_F_var + c_F_cap / (CF_F * H) if CF_F > 0 else float('inf')\n    C_R_eff = c_R_var + c_R_cap / (CF_R * H) if CF_R > 0 else float('inf')\n\n    # Unconstrained solution to find E_unc\n    if C_F_eff < C_R_eff:\n        g_F_unc, g_R_unc = E, 0.0\n    else: # Choose cleaner tech in a tie\n        g_F_unc, g_R_unc = 0.0, E\n    \n    E_unc = e_F * g_F_unc + e_R * g_R_unc\n\n    # --- Emissions Cap Sweep ---\n    caps = np.linspace(0, E_unc, caps_n)\n    cap_curve = []\n    for cap in caps:\n        g_F, g_R = 0.0, 0.0\n        # Given e_R = 0, the constraint e_F*g_F + e_R*g_R <= cap becomes g_F <= cap / e_F\n        g_F_max_by_cap = cap / e_F if e_F > 0 else float('inf')\n\n        if C_F_eff < C_R_eff:\n            # Fossil is cheaper, use as much as cap allows\n            g_F = min(E, g_F_max_by_cap)\n            g_R = E - g_F\n        else:\n            # Renewable is cheaper, use it exclusively\n            g_F = 0.0\n            g_R = E\n\n        cost = g_F * C_F_eff + g_R * C_R_eff\n        emissions = e_F * g_F + e_R * g_R\n        cap_curve.append([emissions, cost])\n\n    # --- Carbon Price Sweep ---\n    # tau_switch is the price at which carbon-adjusted costs are equal\n    # C_F_eff + tau * e_F = C_R_eff + tau * e_R\n    # tau = (C_R_eff - C_F_eff) / (e_F - e_R)\n    if e_F > e_R:\n        tau_switch = (C_R_eff - C_F_eff) / (e_F - e_R)\n    else:\n        # If fossil is not more emitting, it's always preferred if cheaper,\n        # or never if more expensive. No switch is possible with positive tau.\n        tau_switch = float('inf') if C_F_eff < C_R_eff else -1.0\n\n    price_curve = []\n    for tau in prices:\n        g_F, g_R = 0.0, 0.0\n        # Compare carbon-adjusted effective costs\n        if C_F_eff + tau * e_F < C_R_eff + tau * e_R:\n            g_F, g_R = E, 0.0\n        else: # Choose cleaner tech in a tie\n            g_F, g_R = 0.0, E\n\n        cost = g_F * C_F_eff + g_R * C_R_eff\n        emissions = e_F * g_F + e_R * g_R\n        price_curve.append([emissions, cost])\n        \n    return [cap_curve, price_curve]\n\n\ndef solve():\n    test_cases = [\n        # Test case 1\n        (5000000.0, 100000.0, 20.0, 0.9, 0.6, 150000.0, 5.0, 0.4, 0.0, 6, [0, 25, 50, 100, 200, 400]),\n        # Test case 2\n        (2000000.0, 100000.0, 20.0, 0.9, 0.6, 180000.0, 5.0, 0.25, 0.0, 6, [0, 25, 50, 100, 200, 400]),\n        # Test case 3\n        (0.0, 100000.0, 20.0, 0.9, 0.6, 150000.0, 5.0, 0.4, 0.0, 6, [0, 25, 50, 100, 200, 400]),\n    ]\n\n    all_results = []\n    for case_params in test_cases:\n        case_result = solve_case(case_params)\n        all_results.append(case_result)\n\n    # Format the final output string as requested\n    print(format_list(all_results))\n\nsolve()\n```"
        }
    ]
}