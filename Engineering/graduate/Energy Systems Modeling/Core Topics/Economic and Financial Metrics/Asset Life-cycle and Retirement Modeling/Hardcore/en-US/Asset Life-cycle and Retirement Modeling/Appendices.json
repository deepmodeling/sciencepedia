{
    "hands_on_practices": [
        {
            "introduction": "Effective asset life-cycle modeling begins with a solid empirical foundation built from operational data. This practice guides you through the essential process of translating raw lifetime data—which is often incomplete due to scheduled inspections—into a probabilistic model of failure. By deriving and implementing the Maximum Likelihood Estimator for the Weibull distribution with right-censored data , you will develop a core competency in reliability engineering and data-driven asset management.",
            "id": "4069746",
            "problem": "An asset reliability analyst models component lifetimes in an energy system using the two-parameter Weibull distribution to capture age-dependent failure and right-censoring due to scheduled inspection intervals. Let the lifetime of each asset be modeled by a Weibull distribution with shape parameter $k$ and scale parameter $\\lambda$, with probability density function $f(t)$ and survival function $S(t)$ given by\n$$\nf(t) = \\frac{k}{\\lambda}\\left(\\frac{t}{\\lambda}\\right)^{k-1} \\exp\\left[-\\left(\\frac{t}{\\lambda}\\right)^k\\right], \\quad S(t) = \\exp\\left[-\\left(\\frac{t}{\\lambda}\\right)^k\\right], \\quad t \\ge 0.\n$$\nYou observe a sample $\\{(t_i, \\delta_i)\\}_{i=1}^n$, where $t_i$ is the observed time in years and $\\delta_i$ is an event indicator equal to $1$ if a failure is observed at $t_i$ and equal to $0$ if the observation is right-censored at $t_i$. Using the fundamental likelihood construction for independent observations under right-censoring, the likelihood is\n$$\nL(k,\\lambda) = \\prod_{i=1}^n \\left[ f(t_i) \\right]^{\\delta_i} \\left[ S(t_i) \\right]^{1-\\delta_i}.\n$$\nFrom first principles, derive the maximum likelihood estimator (MLE) for the parameters $(k,\\lambda)$ by:\n- writing the log-likelihood $\\ell(k,\\lambda) = \\log L(k,\\lambda)$ and its score equations,\n- analytically eliminating $\\lambda$ conditional on $k$ to reduce the problem to a single nonlinear equation in $k$,\n- justifying a computational procedure to obtain $(\\hat{k},\\hat{\\lambda})$.\n\nThen, implement a program that computes $(\\hat{k},\\hat{\\lambda})$ for each of the following three datasets. All times $t_i$ are in years; report $\\hat{\\lambda}$ in years. Your program must use a numerically stable method that respects the positivity constraints $k > 0$ and $\\lambda > 0$. Round each reported parameter to four decimal places.\n\nTest suite datasets:\n1. Happy path with moderate right-censoring: $t = [3.2, 4.5, 5.1, 6.8, 7.4, 9.0, 12.5, 14.2, 15.0, 16.1, 18.0, 20.0]$, $\\delta = [1,1,1,1,1,1,1,1,0,0,0,0]$.\n2. Boundary case with no censoring: $t = [2.1, 3.0, 3.5, 4.2, 4.9, 5.7, 6.3, 7.8, 8.4, 9.9]$, $\\delta = [1,1,1,1,1,1,1,1,1,1]$.\n3. Edge case with heavy right-censoring: $t = [5.0, 8.0, 10.0, 12.0, 15.0, 18.0, 20.0, 22.0, 25.0, 30.0]$, $\\delta = [0,0,1,0,0,1,0,0,1,0]$.\n\nFinal output format specification:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets in the order $[\\hat{k}_1,\\hat{\\lambda}_1,\\hat{k}_2,\\hat{\\lambda}_2,\\hat{k}_3,\\hat{\\lambda}_3]$, where $(\\hat{k}_j,\\hat{\\lambda}_j)$ are the rounded estimates for dataset $j = 1,2,3$. For example, your output must look like $[x_1,y_1,x_2,y_2,x_3,y_3]$ with no additional text.",
            "solution": "The problem requires the derivation and implementation of the maximum likelihood estimator (MLE) for the parameters $(k, \\lambda)$ of a two-parameter Weibull distribution given a set of right-censored lifetime data. The process will follow the specified steps: derivation of the score equations, reduction to a single-variable problem, and justification of a computational procedure.\n\n### Step 1: Log-Likelihood and Score Equations\n\nThe lifetime of an asset is governed by a Weibull distribution with shape parameter $k0$ and scale parameter $\\lambda0$. The probability density function (PDF) $f(t)$ and survival function $S(t)$ are given as:\n$$\nf(t; k, \\lambda) = \\frac{k}{\\lambda}\\left(\\frac{t}{\\lambda}\\right)^{k-1} \\exp\\left[-\\left(\\frac{t}{\\lambda}\\right)^k\\right], \\quad t \\ge 0\n$$\n$$\nS(t; k, \\lambda) = \\exp\\left[-\\left(\\frac{t}{\\lambda}\\right)^k\\right], \\quad t \\ge 0\n$$\nThe data consists of $n$ independent observations $\\{(t_i, \\delta_i)\\}_{i=1}^n$, where $t_i$ is the time of failure or censoring, and $\\delta_i$ is the event indicator: $\\delta_i=1$ for a failure and $\\delta_i=0$ for a right-censored observation.\n\nThe likelihood function $L(k, \\lambda)$ for this dataset is the product of the contributions from each observation:\n$$\nL(k, \\lambda) = \\prod_{i=1}^n \\left[ f(t_i; k, \\lambda) \\right]^{\\delta_i} \\left[ S(t_i; k, \\lambda) \\right]^{1-\\delta_i}\n$$\nTo facilitate maximization, we work with the log-likelihood function, $\\ell(k, \\lambda) = \\log L(k, \\lambda)$:\n$$\n\\ell(k, \\lambda) = \\sum_{i=1}^n \\left[ \\delta_i \\log f(t_i; k, \\lambda) + (1-\\delta_i) \\log S(t_i; k, \\lambda) \\right]\n$$\nLet's find the expressions for $\\log f(t)$ and $\\log S(t)$:\n$$\n\\log S(t; k, \\lambda) = -\\left(\\frac{t}{\\lambda}\\right)^k\n$$\n$$\n\\log f(t; k, \\lambda) = \\log(k) - \\log(\\lambda) + (k-1)(\\log(t) - \\log(\\lambda)) - \\left(\\frac{t}{\\lambda}\\right)^k = \\log(k) - k\\log(\\lambda) + (k-1)\\log(t) - \\left(\\frac{t}{\\lambda}\\right)^k\n$$\nSubstituting these into the log-likelihood expression:\n$$\n\\ell(k, \\lambda) = \\sum_{i=1}^n \\left( \\delta_i \\left[ \\log(k) - k\\log(\\lambda) + (k-1)\\log(t_i) - \\left(\\frac{t_i}{\\lambda}\\right)^k \\right] + (1-\\delta_i) \\left[ -\\left(\\frac{t_i}{\\lambda}\\right)^k \\right] \\right)\n$$\nWe can combine the terms involving $-(t_i/\\lambda)^k$:\n$$\n\\ell(k, \\lambda) = \\sum_{i=1}^n \\delta_i \\left[ \\log(k) - k\\log(\\lambda) + (k-1)\\log(t_i) \\right] - \\sum_{i=1}^n \\left(\\frac{t_i}{\\lambda}\\right)^k\n$$\nLet $D = \\sum_{i=1}^n \\delta_i$ be the total number of observed failures. The expression simplifies to:\n$$\n\\ell(k, \\lambda) = D \\log(k) - D k \\log(\\lambda) + (k-1) \\sum_{i=1}^n \\delta_i \\log(t_i) - \\lambda^{-k} \\sum_{i=1}^n t_i^k\n$$\nThe maximum likelihood estimates $(\\hat{k}, \\hat{\\lambda})$ are found by solving the score equations, which are obtained by setting the partial derivatives of $\\ell(k, \\lambda)$ with respect to $k$ and $\\lambda$ to zero.\n\nThe partial derivative with respect to $\\lambda$ is:\n$$\n\\frac{\\partial \\ell}{\\partial \\lambda} = -\\frac{D k}{\\lambda} - (-k \\lambda^{-k-1}) \\sum_{i=1}^n t_i^k = -\\frac{D k}{\\lambda} + \\frac{k}{\\lambda^{k+1}} \\sum_{i=1}^n t_i^k\n$$\nSetting $\\frac{\\partial \\ell}{\\partial \\lambda} = 0$ yields the first score equation:\n$$\n-\\frac{D k}{\\lambda} + \\frac{k}{\\lambda^{k+1}} \\sum_{i=1}^n t_i^k = 0 \\quad \\implies \\quad D = \\frac{1}{\\lambda^k} \\sum_{i=1}^n t_i^k\n$$\n\nThe partial derivative with respect to $k$ is:\n$$\n\\frac{\\partial \\ell}{\\partial k} = \\frac{D}{k} - D \\log(\\lambda) + \\sum_{i=1}^n \\delta_i \\log(t_i) - \\frac{\\partial}{\\partial k} \\left( \\lambda^{-k} \\sum_{i=1}^n t_i^k \\right)\n$$\nThe derivative of the last term is:\n$$\n\\frac{\\partial}{\\partial k} \\left( \\sum_{i=1}^n \\left(\\frac{t_i}{\\lambda}\\right)^k \\right) = \\sum_{i=1}^n \\left(\\frac{t_i}{\\lambda}\\right)^k \\log\\left(\\frac{t_i}{\\lambda}\\right) = \\lambda^{-k} \\sum_{i=1}^n t_i^k (\\log(t_i) - \\log(\\lambda))\n$$\nSo, the second score equation is:\n$$\n\\frac{\\partial \\ell}{\\partial k} = \\frac{D}{k} - D \\log(\\lambda) + \\sum_{i=1}^n \\delta_i \\log(t_i) - \\lambda^{-k} \\left( \\sum_{i=1}^n t_i^k \\log(t_i) - \\log(\\lambda) \\sum_{i=1}^n t_i^k \\right) = 0\n$$\n\n### Step 2: Analytical Elimination of $\\lambda$\n\nFrom the first score equation, we can express $\\lambda$ as a function of $k$ and the data. Assuming $D > 0$:\n$$\n\\lambda^k = \\frac{1}{D} \\sum_{i=1}^n t_i^k \\quad \\implies \\quad \\hat{\\lambda}(k) = \\left( \\frac{1}{D} \\sum_{i=1}^n t_i^k \\right)^{1/k}\n$$\nThis expression provides the MLE for $\\lambda$ conditional on a given $k$, denoted $\\hat{\\lambda}(k)$.\n\nNow we substitute this result into the second score equation. First, we substitute $\\sum_{i=1}^n t_i^k = D \\lambda^k$ into the equation for $\\frac{\\partial \\ell}{\\partial k}$:\n$$\n\\frac{D}{k} - D \\log(\\lambda) + \\sum_{i=1}^n \\delta_i \\log(t_i) - \\lambda^{-k} \\left( \\sum_{i=1}^n t_i^k \\log(t_i) - \\log(\\lambda) (D \\lambda^k) \\right) = 0\n$$\n$$\n\\frac{D}{k} - D \\log(\\lambda) + \\sum_{i=1}^n \\delta_i \\log(t_i) - \\lambda^{-k} \\sum_{i=1}^n t_i^k \\log(t_i) + D \\log(\\lambda) = 0\n$$\nThe terms involving $\\log(\\lambda)$ cancel, yielding a simplified equation that does not explicitly contain $\\lambda$:\n$$\n\\frac{D}{k} + \\sum_{i=1}^n \\delta_i \\log(t_i) - \\lambda^{-k} \\sum_{i=1}^n t_i^k \\log(t_i) = 0\n$$\nFinally, we substitute the expression for $\\lambda^k$:\n$$\n\\frac{D}{k} + \\sum_{i=1}^n \\delta_i \\log(t_i) - \\frac{\\sum_{i=1}^n t_i^k \\log(t_i)}{\\frac{1}{D} \\sum_{j=1}^n t_j^k} = 0\n$$\nDividing by $D$ (assuming $D0$), we obtain the final nonlinear equation for the estimate $\\hat{k}$:\n$$\n\\frac{1}{k} + \\frac{1}{D} \\sum_{i=1}^n \\delta_i \\log(t_i) - \\frac{\\sum_{i=1}^n t_i^k \\log(t_i)}{\\sum_{j=1}^n t_j^k} = 0\n$$\n\n### Step 3: Justification of a Computational Procedure\n\nThe problem of finding $(\\hat{k}, \\hat{\\lambda})$ has been reduced to finding the root $\\hat{k}$ of the single-variable function:\n$$\ng(k) = \\frac{1}{k} + C - H(k), \\quad \\text{where } C = \\frac{1}{D} \\sum_{i=1}^n \\delta_i \\log(t_i) \\text{ and } H(k) = \\frac{\\sum_{i=1}^n t_i^k \\log(t_i)}{\\sum_{j=1}^n t_j^k}\n$$\nWe need to solve $g(k)=0$ for $k0$. We analyze the behavior of $g(k)$ on its domain $(0, \\infty)$:\n1.  As $k \\to 0^+$, the term $1/k$ dominates, so $g(k) \\to +\\infty$.\n2.  As $k \\to \\infty$, let $t_{max} = \\max\\{t_1, \\dots, t_n\\}$. The terms in the sums of $H(k)$ are dominated by the term(s) corresponding to $t_{max}$. The ratio $H(k)$ converges to $\\log(t_{max})$. Thus, $g(k) \\to C - \\log(t_{max})$. The constant $C$ is the average of the log-failure times. Since all failure times $t_i$ (for $\\delta_i=1$) must be less than or equal to $t_{max}$, their log-average $C$ must be less than or equal to $\\log(t_{max})$. Therefore, $g(k \\to \\infty) \\le 0$.\n\nSince $g(k)$ is continuous for $k0$, and it transitions from positive to non-positive, the Intermediate Value Theorem guarantees the existence of at least one root $\\hat{k} \\in (0, \\infty)$. The function can be shown to be monotonic, ensuring a unique root.\n\nA robust numerical algorithm for one-dimensional root-finding is required. Brent's method, implemented in `scipy.optimize.brentq`, is an excellent choice as it combines the speed of interpolation-based methods with the reliability of the bisection method. It requires a search interval $[a, b]$ where $g(a)$ and $g(b)$ have opposite signs. Our analysis confirms that such an interval always exists (e.g., for a small $\\epsilon  0$ and a sufficiently large $M$, we have $g(\\epsilon)0$ and $g(M)0$).\n\nFor numerical stability, especially for large values of $k$, the terms $t_i^k$ can cause overflow. We can reformulate $H(k)$ and the calculation of $\\hat{\\lambda}$ by scaling with $t_{max}$:\n$$\nH(k) = \\frac{\\sum_{i=1}^n (t_i/t_{max})^k \\log(t_i)}{\\sum_{j=1}^n (t_j/t_{max})^k}\n$$\nThis prevents overflow as $t_i/t_{max} \\le 1$. Similarly, $\\hat{\\lambda}$ is computed as:\n$$\n\\hat{\\lambda} = \\left( \\frac{1}{D} \\sum_{i=1}^n t_i^{\\hat{k}} \\right)^{1/\\hat{k}} = t_{max} \\left( \\frac{1}{D} \\sum_{i=1}^n \\left(\\frac{t_i}{t_{max}}\\right)^{\\hat{k}} \\right)^{1/\\hat{k}}\n$$\nThe power can be computed stably using logarithms: $\\hat{\\lambda} = t_{max} \\exp\\left(\\frac{1}{\\hat{k}} \\log\\left(\\frac{1}{D} \\sum \\left(\\frac{t_i}{t_{max}}\\right)^{\\hat{k}}\\right)\\right)$.\n\nThe computational procedure is:\n1.  Given data $(t_i, \\delta_i)$, compute $D = \\sum \\delta_i$. If $D=0$, the MLE is not well-defined.\n2.  Define the function $g(k)$ using the numerically stable formulation.\n3.  Use `scipy.optimize.brentq` to find the root $\\hat{k}$ of $g(k)=0$ over a suitable interval (e.g., $[10^{-6}, 100]$).\n4.  Substitute $\\hat{k}$ into the stabilized formula to calculate $\\hat{\\lambda}$.\n\nThis procedure is well-defined, respects the positivity constraints on the parameters, and is numerically robust.",
            "answer": "```python\nimport numpy as np\nfrom scipy.optimize import brentq\n\ndef mle_weibull(times, deltas):\n    \"\"\"\n    Computes the Maximum Likelihood Estimates (MLE) for the 2-parameter Weibull\n    distribution with right-censored data.\n\n    Args:\n        times (list or np.ndarray): Observed times (failure or censoring).\n        deltas (list or np.ndarray): Event indicators (1=failure, 0=censored).\n\n    Returns:\n        tuple: A tuple (k_hat, lambda_hat) containing the estimated shape\n               and scale parameters. Returns (nan, nan) if estimation fails.\n    \"\"\"\n    t = np.asanyarray(times, dtype=np.float64)\n    delta = np.asanyarray(deltas, dtype=np.float64)\n\n    D = np.sum(delta) # Total number of failures\n\n    if D == 0:\n        # MLE is not well-defined if there are no failure events.\n        # This case is not present in the problem's test suite.\n        return (np.nan, np.nan)\n\n    # Pre-calculate the constant C from the derived equation g(k) = 0\n    # C = (1/D) * sum(delta_i * log(t_i))\n    log_t_failures = np.log(t[delta == 1])\n    C = np.sum(log_t_failures) / D\n    \n    # Pre-calculate log(t) for all observations for use in H(k)\n    log_t = np.log(t)\n    \n    # Scale times by t_max for numerical stability\n    t_max = np.max(t)\n    t_norm = t / t_max\n\n    def g(k):\n        \"\"\"\n        The function g(k) for which we need to find the root.\n        g(k) = 1/k + C - H(k) = 0\n        H(k) is the ratio sum(t_i^k * log(t_i)) / sum(t_j^k)\n        \"\"\"\n        if k = 0:\n            return np.inf\n\n        # Numerically stable calculation of H(k)\n        tk_norm = t_norm ** k\n        \n        numerator = np.sum(tk_norm * log_t)\n        denominator = np.sum(tk_norm)\n\n        # Handle potential division by zero, though unlikely with t_max scaling\n        if denominator == 0:\n            return np.nan\n        \n        H_k = numerator / denominator\n        \n        return 1.0 / k + C - H_k\n\n    try:\n        # Use Brent's method to find the root k_hat. The interval [1e-6, 100]\n        # is sufficiently large for most practical reliability problems.\n        k_hat = brentq(g, a=1e-6, b=100.0)\n    except ValueError:\n        # This can happen if g(a) and g(b) have the same sign, indicating\n        # the root is outside the bracket or does not exist.\n        return (np.nan, np.nan)\n\n    # Once k_hat is found, calculate lambda_hat using the stable derived formula:\n    # lambda = t_max * ( (1/D) * sum( (t_i/t_max)^k ) )^(1/k)\n    \n    # Calculate the sum term\n    sum_term = np.sum((t_norm) ** k_hat) / D\n\n    # Use exp-log trick for stable power calculation\n    lambda_hat = t_max * np.exp(np.log(sum_term) / k_hat)\n        \n    return (k_hat, lambda_hat)\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test suite.\n    \"\"\"\n    test_cases = [\n        {\n            \"t\": [3.2, 4.5, 5.1, 6.8, 7.4, 9.0, 12.5, 14.2, 15.0, 16.1, 18.0, 20.0],\n            \"delta\": [1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0]\n        },\n        {\n            \"t\": [2.1, 3.0, 3.5, 4.2, 4.9, 5.7, 6.3, 7.8, 8.4, 9.9],\n            \"delta\": [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\n        },\n        {\n            \"t\": [5.0, 8.0, 10.0, 12.0, 15.0, 18.0, 20.0, 22.0, 25.0, 30.0],\n            \"delta\": [0, 0, 1, 0, 0, 1, 0, 0, 1, 0]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        k_hat, lambda_hat = mle_weibull(case[\"t\"], case[\"delta\"])\n        \n        # Round to four decimal places as required\n        k_rounded = round(k_hat, 4)\n        lambda_rounded = round(lambda_hat, 4)\n        \n        results.extend([k_rounded, lambda_rounded])\n\n    # Format the final output string exactly as specified\n    formatted_results = \",\".join(map(str, results))\n    print(f\"[{formatted_results}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "Once an asset's physical and economic characteristics are understood, the focus shifts to making optimal strategic decisions over its lifetime, especially under uncertainty. This exercise introduces the powerful concept of real options analysis, quantifying the value of managerial flexibility when faced with irreversible choices like plant retirement. By calculating the 'value of waiting' to learn about a potential carbon tax , you will learn to evaluate decisions not just on expected cash flows, but on their ability to preserve options in an unpredictable future.",
            "id": "4069732",
            "problem": "An electric utility owns a coal-fired power plant with remaining technical lifetime of $T = 20$ years. If operated without any carbon pricing, the plant yields a constant end-of-year net operating cash flow of $C = 120$ million United States Dollars (USD) per year. The plant emits $e = 5$ million metric tonnes of carbon dioxide (tCO$_2$) per year. There is a policy risk: at the end of the current year ($t=0$), regulators will announce whether a carbon tax at a rate of $\\tau = 30$ USD per tCO$_2$ will be implemented starting in year $t=2$ and thereafter. The probability that the announcement introduces the carbon tax is $p = 0.4$, and if the tax is not introduced at that announcement, it will not be introduced at any later date. The plant can be retired immediately at the end of this year ($t=0$) to receive a salvage value of $S_0 = 400$ million USD. If the plant is not retired now, it can be retired at the end of next year ($t=1$), after the announcement, to receive a salvage value of $S_1 = 380$ million USD. All salvage values and cash flows are end-of-year amounts. The risk-adjusted discount rate applicable to this project is $r = 0.08$ per year, constant.\n\nAssume the firm is risk-neutral and maximizes expected net present value (NPV). If the carbon tax is introduced, the net operating cash flow under the tax is $C_{\\text{tax}} = C - e \\tau$, and the firm will retire the plant immediately at $t=1$ if continued operation from $t=2$ onward would yield negative expected NPV. If the tax is not introduced, the plant will continue operating until the end of its technical life (i.e., through year $t=T$).\n\nUsing only the foundational definitions of discounted cash flow, conditional expectation, and optimal stopping under irreversible retirement, derive and compute the value of waiting to retire (the option value), defined as the difference between the expected NPV of the optimally timed retirement decision when waiting one year to learn the tax outcome versus retiring immediately at $t=0$. Round your final answer to four significant figures and express it in million United States Dollars (USD million).",
            "solution": "The problem asks for the value of the option to wait one year before making an irreversible retirement decision. This value is the difference between the expected Net Present Value (NPV) of the \"wait\" strategy and the NPV of the \"retire now\" strategy. The analysis assumes the policy announcement occurs at $t=1$, resolving the uncertainty before the second decision point.\n\n**1. NPV of Retiring Immediately (at $t=0$)**\nIf the firm retires the plant at $t=0$, it receives the salvage value $S_0$. The NPV is its value today.\n$$ \\text{NPV}(\\text{retire now}) = S_0 = 400 \\text{ million USD} $$\n\n**2. Expected NPV of Waiting**\nIf the firm waits, it operates for one year, receiving the cash flow $C$ at $t=1$. At $t=1$, the uncertainty about the carbon tax is resolved, and an optimal decision is made. The expected NPV at $t=0$ is the discounted value of all expected cash flows from $t=1$ onwards.\n$$ E[\\text{NPV}(\\text{wait})] = \\frac{C + E[V_1]}{1+r} $$\nwhere $E[V_1]$ is the expected value of the plant at $t=1$, just after the announcement.\n$$ E[V_1] = p \\cdot V_{1, \\text{tax}} + (1-p) \\cdot V_{1, \\text{no tax}} $$\n\n*   **State 1: Tax is introduced (Probability $p = 0.4$)**\n    The annual cash flow from $t=2$ onwards becomes $C_{\\text{tax}} = C - e \\tau = 120 - 5 \\times 30 = -30$ million USD. Since the future operating cash flows are negative, the rational decision at $t=1$ is to retire the plant and receive the salvage value $S_1$.\n    $$ V_{1, \\text{tax}} = \\max(\\text{NPV}_{\\text{operate}}, S_1) = \\max(\\text{negative value}, 380) = 380 \\text{ million USD} $$\n\n*   **State 2: No tax is introduced (Probability $1-p = 0.6$)**\n    The plant continues to generate a cash flow of $C = 120$ million USD from $t=2$ to $t=20$. The value of this at $t=1$ is the present value of an annuity of $C$ for $T-1=19$ years.\n    $$ \\text{NPV}_{\\text{operate}} = \\sum_{k=2}^{20} \\frac{C}{(1+r)^{k-1}} = \\frac{C}{r} \\left(1 - \\frac{1}{(1+r)^{19}}\\right) $$\n    $$ \\text{NPV}_{\\text{operate}} = \\frac{120}{0.08} \\left(1 - \\frac{1}{(1.08)^{19}}\\right) \\approx 1500 \\times (1 - 0.2317104) \\approx 1152.43 \\text{ million USD} $$\n    Since this value is greater than the salvage value $S_1 = 380$, the firm continues to operate.\n    $$ V_{1, \\text{no tax}} = \\max(\\text{NPV}_{\\text{operate}}, S_1) = 1152.43 \\text{ million USD} $$\n\n*   **Expected Value at $t=1$**\n    $$ E[V_1] = (0.4 \\times 380) + (0.6 \\times 1152.4344) = 152 + 691.4606 = 843.4606 \\text{ million USD} $$\n\n*   **Expected NPV of Waiting (at $t=0$)**\n    $$ E[\\text{NPV}(\\text{wait})] = \\frac{120 + 843.4606}{1.08} = \\frac{963.4606}{1.08} \\approx 892.0932 \\text{ million USD} $$\n\n**3. Value of Waiting (Option Value)**\nThis is the premium for retaining managerial flexibility.\n$$ \\text{Value of Waiting} = E[\\text{NPV}(\\text{wait})] - \\text{NPV}(\\text{retire now}) $$\n$$ \\text{Value of Waiting} = 892.0932 - 400 = 492.0932 \\text{ million USD} $$\n\nRounding to four significant figures, the value is **492.1 million USD**.",
            "answer": "$$\\boxed{492.1}$$"
        },
        {
            "introduction": "Asset retirement and investment decisions are rarely made in isolation; they are part of a broader, system-wide strategy to ensure a reliable and cost-effective energy supply. This final practice scales up the analysis from a single asset to an entire electricity system, challenging you to build and solve a multi-period capacity expansion model. By formulating this linear program to co-optimize investment, retirement, and generation dispatch , you will gain hands-on experience with the large-scale optimization tools that underpin modern energy system planning.",
            "id": "4069793",
            "problem": "Consider a multi-period capacity expansion and retirement planning problem for an electricity system with multiple generation technologies, where the planner must decide investment and retirement schedules to meet exogenously specified demand while minimizing total discounted system cost. The system planning horizon has $T$ discrete periods, indexed by $t \\in \\{1,2,\\dots,T\\}$, and technologies are indexed by $k \\in \\{1,2,\\dots,K\\}$. The following fundamental modeling bases must be used:\n\n- Energy balance: for each period $t$, total generation must equal demand, that is, $\\sum_{k} G_{t,k} = D_t$, where $G_{t,k}$ is the generation from technology $k$ in period $t$, and $D_t$ is the demand in period $t$.\n- Physical capacity limit: generation is bounded by available capacity and capacity factor, namely $G_{t,k} \\leq H \\cdot \\text{CF}_k \\cdot \\left(R_{t,k}^{\\text{old}} + N_{t,k}^{\\text{new}}\\right)$, where $H$ is hours per period, $\\text{CF}_k$ is the capacity factor of technology $k$, $R_{t,k}^{\\text{old}}$ is remaining in-service old capacity of technology $k$ in period $t$, and $N_{t,k}^{\\text{new}}$ is in-service new capacity of technology $k$ in period $t$.\n- Capital stock evolution and retirement: old capacity evolves as $R_{t,k}^{\\text{old}} + V_{t,k}^{\\text{ret}} = R_{t-1,k}^{\\text{old}} - M_{t,k}$ for $t \\geq 2$ and $R_{1,k}^{\\text{old}} + V_{1,k}^{\\text{ret}} = R_{0,k}^{\\text{old}} - M_{1,k}$ for $t=1$, where $V_{t,k}^{\\text{ret}} \\geq 0$ is voluntary retirement of old capacity in period $t$ and $M_{t,k} \\geq 0$ is exogenous mandatory retirement of old capacity in period $t$. The initial old capacity $R_{0,k}^{\\text{old}}$ is given. New capacity in service is the cumulative sum of prior investments with one-period construction lag, $N_{t,k}^{\\text{new}} = \\sum_{s=1}^{t-1} I_{s,k}$ for $t \\geq 2$ and $N_{1,k}^{\\text{new}} = 0$, where $I_{t,k} \\geq 0$ is investment in new capacity of technology $k$ in period $t$.\n- Cost accounting and discounting: the objective is to minimize total Net Present Value (NPV), defined as the present value of all costs across periods. Per-period costs include fuel, variable Operations and Maintenance (OM) per megawatt-hour, carbon dioxide (CO$_2$) costs per megawatt-hour (via emissions intensity and carbon price), fixed Operations and Maintenance (OM) per megawatt of capacity in service, and capital expenditure per megawatt of new capacity invested. A standard discount factor $d_t = \\frac{1}{(1+r)^t}$ with discount rate $r$ applies to period $t$ expenditures.\n\nThe decision variables are $G_{t,k} \\geq 0$, $I_{t,k} \\geq 0$, $V_{t,k}^{\\text{ret}} \\geq 0$, $R_{t,k}^{\\text{old}} \\geq 0$, and $N_{t,k}^{\\text{new}} \\geq 0$. Parameters include $D_t$ (in megawatt-hours), $H$ (in hours), $\\text{CF}_k$, fuel cost $c_k^{\\text{fuel}}$ (in dollars per megawatt-hour), variable OM cost $c_k^{\\text{vom}}$ (in dollars per megawatt-hour), emissions intensity $e_k$ (in metric tons of carbon dioxide per megawatt-hour), carbon price $p_t^{\\text{CO2}}$ (in dollars per metric ton of carbon dioxide), fixed OM cost $c_k^{\\text{fom}}$ (in dollars per megawatt per period), capital cost $C_k^{\\text{capex}}$ (in dollars per megawatt), mandatory retirement $M_{t,k}$ (in megawatts), initial old capacity $R_{0,k}^{\\text{old}}$ (in megawatts), and discount rate $r$ (decimal). All physical variables must be expressed in their specified units. The objective function is:\n$$\n\\min \\sum_{t=1}^{T} d_t \\left[ \\sum_{k=1}^{K} \\left( \\left(c_k^{\\text{fuel}} + c_k^{\\text{vom}} + p_t^{\\text{CO2}} \\cdot e_k \\right) G_{t,k} + c_k^{\\text{fom}} \\left(R_{t,k}^{\\text{old}} + N_{t,k}^{\\text{new}}\\right) \\right) \\right] + \\sum_{t=1}^{T} d_t \\sum_{k=1}^{K} C_k^{\\text{capex}} I_{t,k}.\n$$\n\nYour task is to implement a program that constructs and solves this linear optimization model using any modern programming language, subject to the constraints and parameters provided below. The program must compute the optimal total discounted cost in United States dollars (USD) and output the result in millions of USD for each test case, rounded to two decimal places.\n\nTest suite:\n- Test Case $1$ (balanced growth, moderate carbon price):\n    - $T = 4$, $K = 2$, technologies: coal ($k=1$), wind ($k=2$).\n    - $H = 8760$ hours.\n    - Demand $D_t$ in megawatt-hours: $[6{,}000{,}000, 6{,}400{,}000, 6{,}800{,}000, 7{,}200{,}000]$.\n    - Capacity factors $\\text{CF}_k$: coal $0.85$, wind $0.35$.\n    - Initial old capacities $R_{0,k}^{\\text{old}}$ in megawatts: coal $1000$, wind $200$.\n    - Mandatory retirements $M_{t,k}$ in megawatts: coal $[0, 100, 200, 0]$, wind $[0, 0, 0, 0]$.\n    - Fuel costs $c_k^{\\text{fuel}}$ in dollars per megawatt-hour: coal $20$, wind $0$.\n    - Variable OM $c_k^{\\text{vom}}$ in dollars per megawatt-hour: coal $3$, wind $8$.\n    - Emissions intensities $e_k$ in metric tons of carbon dioxide per megawatt-hour: coal $0.9$, wind $0.0$.\n    - Carbon prices $p_t^{\\text{CO2}}$ in dollars per metric ton of carbon dioxide: $[30, 40, 50, 60]$.\n    - Fixed OM $c_k^{\\text{fom}}$ in dollars per megawatt per period: coal $40{,}000$, wind $30{,}000$.\n    - Capital costs $C_k^{\\text{capex}}$ in dollars per megawatt: coal $1{,}300{,}000$, wind $1{,}600{,}000$.\n    - Discount rate $r = 0.07$.\n- Test Case $2$ (high carbon price, steep retirements):\n    - $T = 4$, $K = 2$, technologies: coal ($k=1$), wind ($k=2$).\n    - $H = 8760$ hours.\n    - Demand $D_t$ in megawatt-hours: $[5{,}000{,}000, 5{,}200{,}000, 5{,}400{,}000, 5{,}600{,}000]$.\n    - Capacity factors $\\text{CF}_k$: coal $0.85$, wind $0.35$.\n    - Initial old capacities $R_{0,k}^{\\text{old}}$ in megawatts: coal $800$, wind $0$.\n    - Mandatory retirements $M_{t,k}$ in megawatts: coal $[0, 400, 400, 0]$, wind $[0, 0, 0, 0]$.\n    - Fuel costs $c_k^{\\text{fuel}}$ in dollars per megawatt-hour: coal $20$, wind $0$.\n    - Variable OM $c_k^{\\text{vom}}$ in dollars per megawatt-hour: coal $3$, wind $8$.\n    - Emissions intensities $e_k$ in metric tons of carbon dioxide per megawatt-hour: coal $0.9$, wind $0.0$.\n    - Carbon prices $p_t^{\\text{CO2}}$ in dollars per metric ton of carbon dioxide: $[100, 120, 140, 160]$.\n    - Fixed OM $c_k^{\\text{fom}}$ in dollars per megawatt per period: coal $40{,}000$, wind $30{,}000$.\n    - Capital costs $C_k^{\\text{capex}}$ in dollars per megawatt: coal $1{,}300{,}000$, wind $1{,}600{,}000$.\n    - Discount rate $r = 0.07$.\n- Test Case $3$ (declining demand, low carbon price):\n    - $T = 4$, $K = 2$, technologies: coal ($k=1$), wind ($k=2$).\n    - $H = 8760$ hours.\n    - Demand $D_t$ in megawatt-hours: $[3{,}000{,}000, 2{,}900{,}000, 2{,}800{,}000, 2{,}700{,}000]$.\n    - Capacity factors $\\text{CF}_k$: coal $0.85$, wind $0.35$.\n    - Initial old capacities $R_{0,k}^{\\text{old}}$ in megawatts: coal $500$, wind $0$.\n    - Mandatory retirements $M_{t,k}$ in megawatts: coal $[0, 0, 0, 0]$, wind $[0, 0, 0, 0]$.\n    - Fuel costs $c_k^{\\text{fuel}}$ in dollars per megawatt-hour: coal $20$, wind $0$.\n    - Variable OM $c_k^{\\text{vom}}$ in dollars per megawatt-hour: coal $3$, wind $8$.\n    - Emissions intensities $e_k$ in metric tons of carbon dioxide per megawatt-hour: coal $0.9$, wind $0.0$.\n    - Carbon prices $p_t^{\\text{CO2}}$ in dollars per metric ton of carbon dioxide: $[10, 10, 10, 10]$.\n    - Fixed OM $c_k^{\\text{fom}}$ in dollars per megawatt per period: coal $40{,}000$, wind $30{,}000$.\n    - Capital costs $C_k^{\\text{capex}}$ in dollars per megawatt: coal $1{,}300{,}000$, wind $1{,}600{,}000$.\n    - Discount rate $r = 0.07$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., `[result1,result2,result3]`). Each result must be the optimal total discounted cost in millions of United States dollars (USD), rounded to two decimal places, for the corresponding test case listed above in order.",
            "solution": "The problem describes a well-defined linear programming (LP) model for energy system capacity expansion and retirement planning. The goal is to construct and solve this LP for three distinct test cases.\n\nThe solution approach involves mapping the problem's mathematical formulation onto the standard format required by a linear programming solver, such as SciPy's `linprog` function, which minimizes a cost function $c^T x$ subject to equality constraints $A_{eq} x = b_{eq}$, inequality constraints $A_{ub} x \\leq b_{ub}$, and variable bounds.\n\n**1. Decision Variable Vector ($x$)**\nThe decision variables for all technologies $k \\in \\{1, \\dots, K\\}$ and time periods $t \\in \\{1, \\dots, T\\}$ are:\n- $G_{t,k}$: Generation\n- $I_{t,k}$: Investment in new capacity\n- $V_{t,k}^{\\text{ret}}$: Voluntary retirement of old capacity\n- $R_{t,k}^{\\text{old}}$: Remaining old capacity in service\n- $N_{t,k}^{\\text{new}}$: New capacity in service\n\nThese are flattened into a single, one-dimensional vector $x$ for the solver. A consistent indexing scheme is used to map each variable $(type, t, k)$ to a unique position in $x$.\n\n**2. Objective Function (Cost Vector $c$)**\nThe objective is to minimize the total discounted cost. The cost vector $c$ contains the coefficients for each variable in $x$ from the objective function.\n- For each generation variable $G_{t,k}$, the coefficient is the discounted per-MWh variable cost: $d_t (c_k^{\\text{fuel}} + c_k^{\\text{vom}} + p_t^{\\text{CO2}} e_k)$.\n- For each new investment variable $I_{t,k}$, the coefficient is the discounted capital cost: $d_t C_k^{\\text{capex}}$.\n- For each in-service capacity variable $R_{t,k}^{\\text{old}}$ and $N_{t,k}^{\\text{new}}$, the coefficient is the discounted fixed OM cost: $d_t c_k^{\\text{fom}}$.\n- Voluntary retirement variables $V_{t,k}^{\\text{ret}}$ have no cost, so their coefficient is 0.\n\n**3. Constraint Matrices ($A_{eq}, b_{eq}, A_{ub}, b_{ub}$)**\nThe model's constraints are encoded into matrices.\n\n*   **Equality Constraints ($A_{eq}, b_{eq}$):**\n    1.  **Energy Balance:** For each period $t$, $\\sum_{k} G_{t,k} = D_t$. This forms $T$ constraint equations.\n    2.  **Old Capacity Evolution:** For each $(t, k)$, $R_{t,k}^{\\text{old}} + V_{t,k}^{\\text{ret}} - R_{t-1,k}^{\\text{old}} = -M_{t,k}$ (with $R_{0,k}^{\\text{old}}$ used for $t=1$). This forms $T \\times K$ equations.\n    3.  **New Capacity Evolution:** For each $(t, k)$, $N_{t,k}^{\\text{new}} - N_{t-1,k}^{\\text{new}} - I_{t-1,k} = 0$ (with $N_{1,k}^{\\text{new}}=0$ for $t=1$). This forms $T \\times K$ equations.\n\n*   **Inequality Constraints ($A_{ub}, b_{ub}$):**\n    1.  **Physical Capacity Limit:** For each $(t, k)$, $G_{t,k} \\leq H \\cdot \\text{CF}_k \\cdot (R_{t,k}^{\\text{old}} + N_{t,k}^{\\text{new}})$. This is rewritten in standard form as $G_{t,k} - (H \\cdot \\text{CF}_k) R_{t,k}^{\\text{old}} - (H \\cdot \\text{CF}_k) N_{t,k}^{\\text{new}} \\leq 0$. This forms $T \\times K$ inequalities.\n\n**4. Variable Bounds**\nAll decision variables are non-negative, so their lower bound is 0 and their upper bound is `None` (infinity).\n\nThe provided Python script implements this logic. It systematically constructs the cost vector `c` and the constraint matrices `A_eq`, `b_eq`, `A_ub`, and `b_ub` based on the input parameters for each test case. It then calls `scipy.optimize.linprog` to find the optimal cost, which is scaled to millions of USD and rounded as required.",
            "answer": "```python\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef solve_model(params):\n    \"\"\"\n    Constructs and solves the linear programming model for capacity expansion.\n    \"\"\"\n    T = params['T']\n    K = params['K']\n    H = params['H']\n    D = params['D']\n    CF = params['CF']\n    R0_old = params['R0_old']\n    M = params['M']\n    c_fuel = params['c_fuel']\n    c_vom = params['c_vom']\n    e = params['e']\n    p_co2 = params['p_co2']\n    c_fom = params['c_fom']\n    C_capex = params['C_capex']\n    r = params['r']\n\n    # --- Variable Indexing ---\n    # Variables are ordered as [G, I, V, R, N]\n    # Within each block, variables are ordered by t, then k.\n    num_vars = 5 * T * K\n    \n    _T_K = T * K\n    offsets = {\n        'G': 0 * _T_K,\n        'I': 1 * _T_K,\n        'V': 2 * _T_K,\n        'R': 3 * _T_K,\n        'N': 4 * _T_K,\n    }\n\n    def get_var_idx(var_type, t_idx, k_idx):\n        return offsets[var_type] + t_idx * K + k_idx\n\n    # --- Objective Function (Cost Vector c) ---\n    c = np.zeros(num_vars)\n    for t_idx in range(T):\n        t = t_idx + 1\n        d_t = 1 / ((1 + r) ** t)\n        for k_idx in range(K):\n            # Variable cost component\n            var_cost_per_mwh = c_fuel[k_idx] + c_vom[k_idx] + p_co2[t_idx] * e[k_idx]\n            c[get_var_idx('G', t_idx, k_idx)] = d_t * var_cost_per_mwh\n            # Fixed O cost component\n            c[get_var_idx('R', t_idx, k_idx)] = d_t * c_fom[k_idx]\n            c[get_var_idx('N', t_idx, k_idx)] = d_t * c_fom[k_idx]\n            # Capital expenditure component\n            c[get_var_idx('I', t_idx, k_idx)] = d_t * C_capex[k_idx]\n\n    # --- Constraints ---\n    num_eq_constraints = T + T * K + T * K\n    num_ub_constraints = T * K\n    A_eq = np.zeros((num_eq_constraints, num_vars))\n    b_eq = np.zeros(num_eq_constraints)\n    A_ub = np.zeros((num_ub_constraints, num_vars))\n    b_ub = np.zeros(num_ub_constraints)\n    \n    eq_row_idx = 0\n    ub_row_idx = 0\n\n    for t_idx in range(T):\n        # 1. Energy Balance: sum(k, G_tk) = D_t\n        for k_idx in range(K):\n            A_eq[eq_row_idx, get_var_idx('G', t_idx, k_idx)] = 1\n        b_eq[eq_row_idx] = D[t_idx]\n        eq_row_idx += 1\n\n        for k_idx in range(K):\n            # 2. Capacity Limit: G_tk = H * CF_k * (R_tk + N_tk)\n            # G_tk - (H*CF_k)*R_tk - (H*CF_k)*N_tk = 0\n            A_ub[ub_row_idx, get_var_idx('G', t_idx, k_idx)] = 1\n            A_ub[ub_row_idx, get_var_idx('R', t_idx, k_idx)] = -H * CF[k_idx]\n            A_ub[ub_row_idx, get_var_idx('N', t_idx, k_idx)] = -H * CF[k_idx]\n            b_ub[ub_row_idx] = 0\n            ub_row_idx += 1\n\n            # 3. Old Capacity Evolution: R_tk + V_tk = R_{t-1,k} - M_tk\n            # R_tk + V_tk - R_{t-1,k} = -M_tk\n            A_eq[eq_row_idx, get_var_idx('R', t_idx, k_idx)] = 1\n            A_eq[eq_row_idx, get_var_idx('V', t_idx, k_idx)] = 1\n            if t_idx == 0:\n                b_eq[eq_row_idx] = R0_old[k_idx] - M[k_idx, t_idx]\n            else:\n                A_eq[eq_row_idx, get_var_idx('R', t_idx - 1, k_idx)] = -1\n                b_eq[eq_row_idx] = -M[k_idx, t_idx]\n            eq_row_idx += 1\n            \n            # 4. New Capacity Evolution: N_tk = N_{t-1,k} + I_{t-1,k}\n            # N_tk - N_{t-1,k} - I_{t-1,k} = 0\n            A_eq[eq_row_idx, get_var_idx('N', t_idx, k_idx)] = 1\n            if t_idx == 0:\n                # N_1k = 0\n                b_eq[eq_row_idx] = 0\n            else:\n                A_eq[eq_row_idx, get_var_idx('N', t_idx - 1, k_idx)] = -1\n                A_eq[eq_row_idx, get_var_idx('I', t_idx - 1, k_idx)] = -1\n                b_eq[eq_row_idx] = 0\n            eq_row_idx += 1\n\n    # --- Solve ---\n    bounds = (0, None)  # All variables are non-negative\n    res = linprog(c=c, A_ub=A_ub, b_ub=b_ub, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')\n\n    if not res.success:\n        raise RuntimeError(f\"Optimization failed: {res.message}\")\n\n    total_cost_millions = res.fun / 1_000_000\n    return round(total_cost_millions, 2)\n\n\ndef solve():\n    test_cases = [\n        # Test Case 1\n        {\n            \"T\": 4, \"K\": 2, \"H\": 8760,\n            \"D\": np.array([6_000_000, 6_400_000, 6_800_000, 7_200_000]),\n            \"CF\": np.array([0.85, 0.35]),\n            \"R0_old\": np.array([1000, 200]),\n            \"M\": np.array([[0, 100, 200, 0], [0, 0, 0, 0]]), # M[k_idx, t_idx]\n            \"c_fuel\": np.array([20, 0]),\n            \"c_vom\": np.array([3, 8]),\n            \"e\": np.array([0.9, 0.0]),\n            \"p_co2\": np.array([30, 40, 50, 60]),\n            \"c_fom\": np.array([40_000, 30_000]),\n            \"C_capex\": np.array([1_300_000, 1_600_000]),\n            \"r\": 0.07,\n        },\n        # Test Case 2\n        {\n            \"T\": 4, \"K\": 2, \"H\": 8760,\n            \"D\": np.array([5_000_000, 5_200_000, 5_400_000, 5_600_000]),\n            \"CF\": np.array([0.85, 0.35]),\n            \"R0_old\": np.array([800, 0]),\n            \"M\": np.array([[0, 400, 400, 0], [0, 0, 0, 0]]),\n            \"c_fuel\": np.array([20, 0]),\n            \"c_vom\": np.array([3, 8]),\n            \"e\": np.array([0.9, 0.0]),\n            \"p_co2\": np.array([100, 120, 140, 160]),\n            \"c_fom\": np.array([40_000, 30_000]),\n            \"C_capex\": np.array([1_300_000, 1_600_000]),\n            \"r\": 0.07,\n        },\n        # Test Case 3\n        {\n            \"T\": 4, \"K\": 2, \"H\": 8760,\n            \"D\": np.array([3_000_000, 2_900_000, 2_800_000, 2_700_000]),\n            \"CF\": np.array([0.85, 0.35]),\n            \"R0_old\": np.array([500, 0]),\n            \"M\": np.array([[0, 0, 0, 0], [0, 0, 0, 0]]),\n            \"c_fuel\": np.array([20, 0]),\n            \"c_vom\": np.array([3, 8]),\n            \"e\": np.array([0.9, 0.0]),\n            \"p_co2\": np.array([10, 10, 10, 10]),\n            \"c_fom\": np.array([40_000, 30_000]),\n            \"C_capex\": np.array([1_300_000, 1_600_000]),\n            \"r\": 0.07,\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = solve_model(case)\n        results.append(result)\n\n    print(f\"[{','.join(f'{r:.2f}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}