{
    "hands_on_practices": [
        {
            "introduction": "在机组组合等大规模电网调度模型中，我们通常将时间离散化为一系列固定的时间步。这就要求我们将发电机连续的物理特性，如爬坡率，转化为离散的代数约束。本练习将指导您从基本原理出发，推导出发电机在启动事件中的精确爬坡约束，这对于构建准确的机组组合模型至关重要。",
            "id": "4093090",
            "problem": "考虑在机组组合（UC）的离散时间调度模型中的单个火电机组。设时间步长为 $\\Delta t$ 小时，并令 $P_t$ 表示时间步 $t$ 的输出电功率，$u_t \\in \\{0,1\\}$ 为时间步 $t$ 的启停状态，$y_t \\in \\{0,1\\}$ 为时间 $t$ 的启动指示变量（当且仅当机组在 $t-1$ 时刻处于停机状态而在 $t$ 时刻转为开机状态时取值为1），$w_t \\in \\{0,1\\}$ 为时间 $t$ 的停机指示变量（当且仅当机组在 $t-1$ 时刻处于开机状态而在 $t$ 时刻转为停机状态时取值为1）。当机组运行时，其具有最小和最大功率输出限制，分别记为 $P^{\\min}$ 和 $P^{\\max}$。当机组开启时，其输出必须满足约束 $P^{\\min} u_t \\le P_t \\le P^{\\max} u_t$。该机组在稳定运行时具有以 $\\mathrm{MW}/\\mathrm{h}$ 为单位的持续爬坡能力 $R^{\\uparrow}$，并在启动时具有以 $\\mathrm{MW}$ 为单位的额外启动爬坡裕量 $S^{\\uparrow}$。类似地，它具有持续滑坡能力 $R^{\\downarrow}$ 和停机滑坡裕量 $S^{\\downarrow}$，但本问题不需要这些参数。\n\n根据爬坡率作为功率输出时间导数上限的基本定义，结合该上限在时间间隔 $\\Delta t$ 上的离散时间近似，以及将启动裕量解释为仅在 $y_t=1$ 时输出的额外允许增量，通过将输出限制约束 $P_t \\le P^{\\max} u_t$ 与启动事件下连接 $P_t$ 和 $P_{t-1}$ 的爬坡不等式相结合，构建 $P_t$ 的最紧可能上界。您的推导必须从上述基本定义（变化率在 $\\Delta t$ 内受 $R^{\\uparrow}$ 限制，加上仅在 $y_t=1$ 时的启动裕量）开始，并逻辑地得出一个关于 $P_t$ 上界的单一闭式表达式，该表达式用 $P_{t-1}$、$u_{t-1}$、$u_t$、$y_t$、$P^{\\min}$、$P^{\\max}$、$R^{\\uparrow}$、$S^{\\uparrow}$ 和 $\\Delta t$ 表示。\n\n然后，根据以下数据和状态转换，对您得出的上界进行数值评估：\n- $\\Delta t = 0.25$ $\\mathrm{h}$，\n- $P^{\\min} = 60$ $\\mathrm{MW}$，\n- $P^{\\max} = 220$ $\\mathrm{MW}$，\n- $R^{\\uparrow} = 180$ $\\mathrm{MW}/\\mathrm{h}$，\n- $S^{\\uparrow} = 100$ $\\mathrm{MW}$，\n- $u_{t-1} = 0$, $u_t = 1$（一次启动，因此 $y_t = 1$），以及 $P_{t-1} = 0$ $\\mathrm{MW}$。\n\n将最终的数值上界表示为以 $\\mathrm{MW}$ 为单位的单个数字。除精确计算外，无需进行四舍五入。您的最终答案必须是一个实数值。",
            "solution": "该问题要求推导火电机组在启动事件期间功率输出 $P_t$ 的最紧可能上界。随后，需要对一组特定参数进行数值评估。推导过程必须逻辑地结合机组的最大功率限制及其爬坡特性，包括针对启动的特殊裕量。\n\n首先，我们确定所有对时间步 $t$ 的功率输出 $P_t$ 施加上限的约束。\n\n1.  **最大功率限制**：当机组运行时（即在线，$u_t = 1$），其输出 $P_t$ 不能超过其最大额定容量 $P^{\\max}$。当机组离线时（$u_t=0$），其输出必须为零。这两种情况都可以由以下不等式表示：\n    $$P_t \\le P^{\\max} u_t$$\n\n2.  **爬坡限制**：机组增加其功率输出的速率受到物理限制。这些限制对于持续运行与从离线状态启动通常是不同的。\n\n    a.  **持续爬坡**：对于“稳定运行”，即机组在时间 $t-1$ 和时间 $t$ 均在线（即 $u_{t-1}=1$ 且 $u_t=1$），功率输出的变化受持续爬坡能力 $R^{\\uparrow}$（单位为 $\\mathrm{MW}/\\mathrm{h}$）的限制。在时间步长为 $\\Delta t$ 的离散时间模型中，这可近似表示为：\n        $$P_t - P_{t-1} \\le R^{\\uparrow} \\Delta t$$\n        这提供了一个基于其先前状态的 $P_t$ 上界：$P_t \\le P_{t-1} + R^{\\uparrow} \\Delta t$。\n\n    b.  **启动爬坡裕量**：当机组在时间 $t$ 启动时，其状态从 $t-1$ 时的停机（$u_{t-1}=0$，因此 $P_{t-1}=0$）转换到 $t$ 时的开机（$u_t=1$）。问题指定了一个单位为 $\\mathrm{MW}$ 的“启动爬坡裕量” $S^{\\uparrow}$。术语“裕量”与单位 $\\mathrm{MW}$ 结合使用，表明这是对可达到的功率水平本身的限制，而不是一个速率。在电力系统建模的背景下，最严谨的解释是 $S^{\\uparrow}$ 代表机组在其运行的第一个时间间隔内可以达到的最大功率输出。“额外”这个修饰词表示这是一个在启动情况下应用的特殊约束，是对持续爬坡和最大功率限制等标准运行约束的补充。因此，对于启动事件（$y_t=1$），功率输出受以下限制：\n        $$P_t \\le S^{\\uparrow}$$\n\n为了构建一个对持续运行和启动都有效的与爬坡相关的上界单一表达式，我们可以使用二进制指示变量。一个结合了这两个互斥情况的单一不等式是：\n$$P_t \\le P_{t-1} + R^{\\uparrow} \\Delta t \\cdot u_{t-1} + S^{\\uparrow} \\cdot y_t$$\n此公式在 $P_{t-1}=0$（如果 $u_{t-1}=0$）的条件下有效，该条件由一般输出限制约束（$P^{\\min}u_{t-1} \\le P_{t-1} \\le P^{\\max}u_{t-1}$）强制执行。我们来验证这个表达式：\n-   对于持续运行（$u_{t-1}=1, u_t=1, y_t=0$）：该不等式变为 $P_t \\le P_{t-1} + R^{\\uparrow} \\Delta t$，这是正确的持续爬坡限制。\n-   对于启动（$u_{t-1}=0, u_t=1, y_t=1$）：由于 $u_{t-1}=0$，我们有 $P_{t-1}=0$。该不等式变为 $P_t \\le 0 + (R^{\\uparrow} \\Delta t)(0) + S^{\\uparrow}(1)$，简化为 $P_t \\le S^{\\uparrow}$。这是正确的启动爬坡限制。\n\n问题要求 $P_t$ 的*最紧可能*上界。这可以通过取所有有效上界约束的最小值来找到。因此，在任何时间 $t$，$P_t$ 的最全面上界是：\n$$P_t \\le \\min\\left( P^{\\max} u_t, \\quad P_{t-1} + R^{\\uparrow} \\Delta t \\cdot u_{t-1} + S^{\\uparrow} \\cdot y_t \\right)$$\n这个表达式满足了用指定变量表示单一闭式上界的要求。\n\n现在，我们为问题中给出的特定情况（即启动事件）评估此上界。条件如下：\n-   机组状态转换：从 $u_{t-1}=0$ 到 $u_t=1$。\n-   这意味着启动指示变量为 $y_t=1$。\n-   先前的功率输出为 $P_{t-1}=0 \\, \\mathrm{MW}$。\n\n我们将这些值代入通用上界表达式中。\n最小值函数的第一个参数变为：\n$$P^{\\max} u_t = P^{\\max} \\cdot 1 = P^{\\max}$$\n最小值函数的第二个参数变为：\n$$P_{t-1} + R^{\\uparrow} \\Delta t \\cdot u_{t-1} + S^{\\uparrow} \\cdot y_t = 0 + (R^{\\uparrow} \\Delta t) \\cdot 0 + S^{\\uparrow} \\cdot 1 = S^{\\uparrow}$$\n因此，对于启动这一特定情况，发电机输出的最紧可能上界为：\n$$P_t \\le \\min(P^{\\max}, S^{\\uparrow})$$\n\n最后，我们使用所提供的数据计算此上界的数值：\n-   $P^{\\max} = 220 \\, \\mathrm{MW}$\n-   $S^{\\uparrow} = 100 \\, \\mathrm{MW}$\n\n数值上界为：\n$$P_t \\le \\min(220, 100) = 100 \\, \\mathrm{MW}$$\n\n根据对启动爬坡裕量 $S^{\\uparrow}$ 的标准和最严谨的解释，在此特定启动场景中，计算上界不需要其他数据（$\\Delta t$、$P^{\\min}$、$R^{\\uparrow}$）。推导出的上界与机组的最小输出要求（$P_t \\ge P^{\\min} = 60 \\, \\mathrm{MW}$）是一致的，因为启动的可行范围是 $60 \\, \\mathrm{MW} \\le P_t \\le 100 \\, \\mathrm{MW}$。然而，问题只要求上界。",
            "answer": "$$\\boxed{100}$$"
        },
        {
            "introduction": "在掌握了单个发电机的爬坡率建模后，下一步是考虑如何在一个系统中经济地分配这些爬坡能力。爬坡备用是一种宝贵的辅助服务，必须在满足系统总体需求的同时，以最低成本在不同发电机组之间进行分配。本练习将引导您推导并实施一种基于边际成本均等原则的优化分配算法。",
            "id": "4093106",
            "problem": "考虑一个专注于发电机向上爬坡速率备用分配的能源系统建模任务。现有 $n$ 个火力发电机组，索引为 $i \\in \\{1, \\dots, n\\}$。每个机组具有向上爬坡速率能力 $RU_i$，单位为 $\\mathrm{MW/min}$。一个独立的系统运营商必须为每个机组在单个调度区间内分配向上爬坡备用 $x_i$（单位为 $\\mathrm{MW/min}$），以满足系统级的向上爬坡备用需求 $R$（单位为 $\\mathrm{MW/min}$）。该分配必须满足所有机组的 $0 \\leq x_i \\leq RU_i$ 条件以及 $\\sum_{i=1}^{n} x_i = R$。\n\n每个机组的向上爬坡备用会产生一个严格凸的成本，由 $C_i(x_i) = \\frac{1}{2} q_i x_i^2 + c_i x_i$ 给出，其中 $q_i  0$ 的单位是美元/($\\mathrm{MW/min})^2$，$c_i \\geq 0$ 的单位是美元/$\\mathrm{MW/min}$。目标是确定分配向量 $\\mathbf{x} = (x_1, \\dots, x_n)$，以在满足上述约束条件的情况下最小化总备用成本 $\\sum_{i=1}^{n} C_i(x_i)$。\n\n您必须从约束优化和微积分的基本定律和核心定义（例如，边际成本作为成本函数的导数以及线性不等式约束中的可行性概念）出发，推导出算法方法，然后实现一个完整的、可运行的程序，为每个给定的测试用例计算最优分配 $\\mathbf{x}$。您还必须在解决方案中，使用边际分析对得出的调度结果提供有原则的论证。不要使用任何未经推导的快捷公式；从第一性原理推导您的方法。\n\n假设：\n- 对所有 $i$，$q_i  0$。\n- 需求 $R$ 满足 $0 \\leq R \\leq \\sum_{i=1}^{n} RU_i$（即可行性）。\n- 所有输入都是确定性的，代表单个调度区间，并且每个 $x_i$ 在其界限内是连续的。\n\n您的程序必须实现一个稳健的数值程序来获得 $\\mathbf{x}$，使等式约束 $\\sum_{i=1}^{n} x_i = R$ 在 $10^{-9}$ 的数值公差内得以满足。\n\n物理单位：\n- 将每个分配 $x_i$ 以 $\\mathrm{MW/min}$ 表示。\n- 在最终输出中，将每个 $x_i$ 打印为小数点后恰好有 $6$ 位的小数浮点数。\n\n测试套件：\n为以下四个案例计算最优分配。每个案例由元组 $(\\{RU_i\\}_{i=1}^{n}, \\{q_i\\}_{i=1}^{n}, \\{c_i\\}_{i=1}^{n}, R)$ 指定。\n\n- 案例 $1$：$n = 3$，$RU = [\\,30,\\,20,\\,10\\,]$ $\\mathrm{MW/min}$，$q = [\\,0.8,\\,0.4,\\,1.2\\,]$ 美元/($\\mathrm{MW/min})^2$，$c = [\\,4.0,\\,3.0,\\,5.5\\,]$ 美元/$\\mathrm{MW/min}$，$R = 35$ $\\mathrm{MW/min}$。\n- 案例 $2$：$n = 2$，$RU = [\\,15,\\,15\\,]$ $\\mathrm{MW/min}$，$q = [\\,0.5,\\,0.5\\,]$ 美元/($\\mathrm{MW/min})^2$，$c = [\\,2.0,\\,2.0\\,]$ 美元/$\\mathrm{MW/min}$，$R = 0$ $\\mathrm{MW/min}$。\n- 案例 $3$：$n = 4$，$RU = [\\,5,\\,10,\\,15,\\,20\\,]$ $\\mathrm{MW/min}$，$q = [\\,1.0,\\,0.2,\\,0.6,\\,0.4\\,]$ 美元/($\\mathrm{MW/min})^2$，$c = [\\,3.5,\\,2.0,\\,2.5,\\,3.0\\,]$ 美元/$\\mathrm{MW/min}$，$R = 50$ $\\mathrm{MW/min}$。\n- 案例 $4$：$n = 4$，$RU = [\\,50,\\,5,\\,0,\\,40\\,]$ $\\mathrm{MW/min}$，$q = [\\,0.1,\\,1.5,\\,0.8,\\,0.3\\,]$ 美元/($\\mathrm{MW/min})^2$，$c = [\\,1.0,\\,10.0,\\,2.0,\\,1.5\\,]$ 美元/$\\mathrm{MW/min}$，$R = 60$ $\\mathrm{MW/min}$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个元素是一个内部列表，代表一个案例的最优分配 $\\mathbf{x}$，单位为 $\\mathrm{MW/min}$，每个值打印时小数点后恰好有 $6$ 位数字。例如，输出的形式应为 $[\\,[x_{1,1},x_{1,2},\\dots],\\,[x_{2,1},x_{2,2},\\dots],\\,\\dots\\,]$，行内任何地方都没有空格。",
            "solution": "该问题是能源系统建模领域一个定义明确、有科学依据的问题，具体涉及爬坡速率备用的经济调度。这是一个经典的凸优化问题，可以使用约束优化的原理来解决。\n\n### 求解推导\n问题是要找到分配向量 $\\mathbf{x} = (x_1, \\dots, x_n)$，以解决以下约束优化问题：\n$$\n\\begin{aligned}\n \\underset{\\mathbf{x}}{\\text{minimize}}\n  \\sum_{i=1}^{n} \\left(\\frac{1}{2} q_i x_i^2 + c_i x_i\\right) \\\\\n \\text{subject to}\n  \\sum_{i=1}^{n} x_i = R \\\\\n   0 \\leq x_i \\leq RU_i, \\quad \\forall i \\in \\{1, \\dots, n\\}\n\\end{aligned}\n$$\n\n这是一个凸优化问题。我们可以使用拉格朗日乘子法推导最优性条件，具体通过构建 Karush-Kuhn-Tucker (KKT) 条件。约束可以写成 $R - \\sum_{i=1}^{n} x_i = 0$，$-x_i \\leq 0$ 和 $x_i - RU_i \\leq 0$。\n\n该问题的拉格朗日函数 $L$ 为：\n$$\nL(\\mathbf{x}, \\lambda, \\boldsymbol{\\mu}, \\boldsymbol{\\nu}) = \\sum_{i=1}^{n} \\left(\\frac{1}{2} q_i x_i^2 + c_i x_i\\right) + \\lambda \\left(R - \\sum_{i=1}^{n} x_i\\right) + \\sum_{i=1}^{n} \\mu_i (-x_i) + \\sum_{i=1}^{n} \\nu_i (x_i - RU_i)\n$$\n其中 $\\lambda$ 是等式约束的拉格朗日乘子，$\\mu_i \\geq 0$ 和 $\\nu_i \\geq 0$ 分别是 $x_i$ 的下界和上界不等式约束的乘子。\n\n最优解 $(\\mathbf{x}^*, \\lambda^*, \\boldsymbol{\\mu}^*, \\boldsymbol{\\nu}^*)$ 的 KKT 条件是：\n\n1.  **平稳性**：拉格朗日函数相对于每个 $x_i$ 的梯度必须为零。\n    $$\n    \\frac{\\partial L}{\\partial x_i} = q_i x_i + c_i - \\lambda - \\mu_i + \\nu_i = 0 \\quad \\forall i\n    $$\n    这可以重新排列为 $q_i x_i + c_i = \\lambda + \\mu_i - \\nu_i$。项 $q_i x_i + c_i$ 是成本函数 $C'_i(x_i)$ 的导数，称为机组 $i$ 的**边际成本**。\n\n2.  **原始可行性**：必须满足原始约束条件。\n    $$\n    \\sum_{i=1}^{n} x_i = R\n    $$\n    $$\n    0 \\leq x_i \\leq RU_i \\quad \\forall i\n    $$\n\n3.  **对偶可行性**：不等式约束的拉格朗日乘子必须为非负。\n    $$\n    \\mu_i \\geq 0, \\quad \\nu_i \\geq 0 \\quad \\forall i\n    $$\n\n4.  **互补松弛性**：不等式乘子与其对应约束的乘积必须为零。\n    $$\n    \\mu_i x_i = 0 \\quad \\forall i\n    $$\n    $$\n    \\nu_i (x_i - RU_i) = 0 \\quad \\forall i\n    $$\n\n从这些条件中，我们推导出给定系统边际价格 $\\lambda$ 下的最优分配 $x_i$。我们对每个机组 $i$ 分析三种情况：\n\n-   **情况 A：机组在其限值之间调度 ($0  x_i  RU_i$)**\n    由于 $x_i > 0$ 且 $x_i  RU_i$，互补松弛性条件意味着 $\\mu_i = 0$ 和 $\\nu_i = 0$。平稳性条件于是简化为：\n    $$\n    q_i x_i + c_i = \\lambda \\quad \\implies \\quad x_i = \\frac{\\lambda - c_i}{q_i}\n    $$\n    这表明所有在其界限内运行的机组必须具有相同的边际成本，等于 $\\lambda$。\n\n-   **情况 B：机组处于其下限 ($x_i = 0$)**\n    由于 $x_i  RU_i$（假设 $RU_i > 0$），互补松弛性意味着 $\\nu_i = 0$。平稳性条件是 $c_i - \\lambda - \\mu_i = 0$。由于 $\\mu_i \\geq 0$，这意味着 $c_i - \\lambda \\geq 0$，或 $\\lambda \\leq c_i$。该机组的基础边际成本相对于系统价格 $\\lambda$ 来说太高，因此不进行调度。\n\n-   **情况 C：机组处于其上限 ($x_i = RU_i$)**\n    由于 $x_i > 0$（假设 $RU_i > 0$），互补松弛性意味着 $\\mu_i = 0$。平稳性条件是 $q_i RU_i + c_i - \\lambda + \\nu_i = 0$。由于 $\\nu_i \\geq 0$，这意味着 $q_i RU_i + c_i - \\lambda \\leq 0$，或 $\\lambda \\geq q_i RU_i + c_i$。该机组非常经济，即使在其最大出力下，其边际成本也小于或等于系统价格 $\\lambda$。\n\n结合这三种情况，我们可以将机组 $i$ 的最优分配表示为单个参数 $\\lambda$ 的函数：\n$$\nx_i(\\lambda) = \\begin{cases}\nRU_i  \\text{if } \\lambda > q_i RU_i + c_i \\\\\n\\frac{\\lambda - c_i}{q_i}  \\text{if } c_i \\leq \\lambda \\leq q_i RU_i + c_i \\\\\n0  \\text{if } \\lambda  c_i\n\\end{cases}\n$$\n这可以更紧凑地写成：\n$$\nx_i(\\lambda) = \\max\\left(0, \\min\\left(RU_i, \\frac{\\lambda - c_i}{q_i}\\right)\\right)\n$$\n这个函数 $x_i(\\lambda)$ 相对于 $\\lambda$ 是连续且单调不减的。\n\n### 算法方法\n问题的核心是找到系统边际成本的唯一值 $\\lambda^*$，使得总分配满足系统需求：\n$$\n\\sum_{i=1}^{n} x_i(\\lambda^*) = R\n$$\n让我们定义一个函数 $f(\\lambda) = \\sum_{i=1}^{n} x_i(\\lambda) - R$。我们在寻找 $f(\\lambda) = 0$ 的根。由于每个 $x_i(\\lambda)$ 都是关于 $\\lambda$ 的单调不减函数，它们的和 $\\sum_{i=1}^{n} x_i(\\lambda)$ 也是单调的。这一特性使得求根问题非常适合使用二分搜索算法。\n\n二分法算法的步骤如下：\n\n1.  **为 $\\lambda$ 建立一个搜索区间 $[\\lambda_{\\text{low}}, \\lambda_{\\text{high}}]$**：\n    -   下界可以设置为 $\\lambda_{\\text{low}} = 0$，因为 $c_i \\geq 0$。如果 $\\lambda  0$，所有的 $x_i$ 都将为 $0$。\n    -   上界 $\\lambda_{\\text{high}}$ 必须足够大，以使得 $\\sum_{i=1}^{n} x_i(\\lambda_{\\text{high}}) \\geq R$。可以选择一个安全的、足够大的值，例如，通过找到所有机组中可能的最大边际成本：$\\lambda_{\\text{high}} = \\max_i(c_i + q_i RU_i)$。\n\n2.  **迭代求根**：\n    -   重复固定次数的迭代（例如，100次）以达到高精度，或者直到搜索区间足够小。\n    -   在每次迭代中，计算中点 $\\lambda_{\\text{mid}} = (\\lambda_{\\text{low}} + \\lambda_{\\text{high}}) / 2$。\n    -   计算在此试验值下的总分配：$X_{\\text{total}} = \\sum_{i=1}^{n} \\max\\left(0, \\min\\left(RU_i, \\frac{\\lambda_{\\text{mid}} - c_i}{q_i}\\right)\\right)$。\n    -   更新区间：\n        -   如果 $X_{\\text{total}}  R$，试验值 $\\lambda_{\\text{mid}}$ 太低，无法满足需求。我们需要增加边际成本以获取更多备用。因此，我们设置 $\\lambda_{\\text{low}} = \\lambda_{\\text{mid}}$。\n        -   如果 $X_{\\text{total}} \\geq R$，试验值 $\\lambda_{\\text{mid}}$ 足够高或过高。我们可能可以用更低的成本来满足需求。因此，我们设置 $\\lambda_{\\text{high}} = \\lambda_{\\text{mid}}$。\n\n3.  **最终计算**：\n    -   迭代完成后，最优边际成本 $\\lambda^*$ 取为最终区间的中点，即 $\\lambda^* = (\\lambda_{\\text{low}} + \\lambda_{\\text{high}}) / 2$。\n    -   最终的最优分配向量 $\\mathbf{x}^* = (x_1^*, \\dots, x_n^*)$ 使用这个 $\\lambda^*$ 计算得出：\n        $$\n        x_i^* = \\max\\left(0, \\min\\left(RU_i, \\frac{\\lambda^* - c_i}{q_i}\\right)\\right) \\quad \\forall i\n        $$\n由于 $f(\\lambda)$ 的单调性，该算法是稳健、高效的，并保证收敛到唯一的最优解。在标准的双精度浮点数上进行足够次数的迭代（例如100次）将确保最终约束 $\\left| \\sum x_i - R \\right|$ 远在所需的 $10^{-9}$ 公差范围内。\n\n```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the ramp-rate reserve allocation problem for a series of test cases.\n    \"\"\"\n\n    test_cases = [\n        # Case 1: n = 3, RU = [30, 20, 10], q = [0.8, 0.4, 1.2], c = [4.0, 3.0, 5.5], R = 35\n        (np.array([30.0, 20.0, 10.0]), np.array([0.8, 0.4, 1.2]), np.array([4.0, 3.0, 5.5]), 35.0),\n        # Case 2: n = 2, RU = [15, 15], q = [0.5, 0.5], c = [2.0, 2.0], R = 0\n        (np.array([15.0, 15.0]), np.array([0.5, 0.5]), np.array([2.0, 2.0]), 0.0),\n        # Case 3: n = 4, RU = [5, 10, 15, 20], q = [1.0, 0.2, 0.6, 0.4], c = [3.5, 2.0, 2.5, 3.0], R = 50\n        (np.array([5.0, 10.0, 15.0, 20.0]), np.array([1.0, 0.2, 0.6, 0.4]), np.array([3.5, 2.0, 2.5, 3.0]), 50.0),\n        # Case 4: n = 4, RU = [50, 5, 0, 40], q = [0.1, 1.5, 0.8, 0.3], c = [1.0, 10.0, 2.0, 1.5], R = 60\n        (np.array([50.0, 5.0, 0.0, 40.0]), np.array([0.1, 1.5, 0.8, 0.3]), np.array([1.0, 10.0, 2.0, 1.5]), 60.0),\n    ]\n\n    all_results = []\n\n    for RU, q, c, R in test_cases:\n        # Handle the trivial case where R=0\n        if R == 0:\n            allocations = np.zeros_like(RU)\n            all_results.append(allocations)\n            continue\n        \n        # Handle the trivial case where R is the sum of all capacities\n        if abs(R - np.sum(RU))  1e-9:\n            allocations = RU\n            all_results.append(allocations)\n            continue\n            \n        # 1. Establish a search interval for lambda\n        lambda_low = 0.0\n        # A safe upper bound for lambda is the max possible marginal cost\n        # Add a small epsilon to handle cases where RU might be zero\n        lambda_high = np.max(c + q * (RU + 1e-9)) * 1.5 # Multiplied by 1.5 for an extra margin\n        \n        # For a more robust upper bound, ensure it's sufficiently large\n        lambda_high = max(lambda_high, 1000.0)\n\n        # 2. Iterate using bisection search to find the optimal lambda\n        # 100 iterations are more than sufficient for double precision convergence\n        for _ in range(100):\n            lambda_mid = (lambda_low + lambda_high) / 2.0\n            \n            # Calculate total allocation for the current lambda_mid\n            # x_i = (lambda - c_i) / q_i, clipped by [0, RU_i]\n            # np.divide is used for safe division, although q_i > 0 is assumed\n            x = (lambda_mid - c) / q\n            allocations = np.maximum(0.0, np.minimum(RU, x))\n            \n            total_allocation = np.sum(allocations)\n            \n            # Update the search interval\n            if total_allocation  R:\n                lambda_low = lambda_mid\n            else:\n                lambda_high = lambda_mid\n        \n        # 3. Final calculation using the determined optimal lambda\n        lambda_opt = (lambda_low + lambda_high) / 2.0\n        \n        final_x = (lambda_opt - c) / q\n        final_allocations = np.maximum(0.0, np.minimum(RU, final_x))\n        \n        # An optional step to correct for floating point inaccuracies to perfectly match R.\n        # However, 100 iterations of bisection typically make the error negligible (well within 1e-9).\n        residual = R - np.sum(final_allocations)\n        # Identify generators not at their bounds\n        active_mask = (final_allocations > 1e-9)  (final_allocations  RU - 1e-9)\n        \n        if np.any(active_mask):\n            # Calculate sum of 1/q_i for active generators\n            inv_q_sum_active = np.sum(1.0 / q[active_mask])\n            if inv_q_sum_active > 0:\n                # Distribute residual proportionally\n                final_allocations[active_mask] += residual * (1.0 / q[active_mask]) / inv_q_sum_active\n        \n        # Ensure positivity and bounds again after correction\n        final_allocations = np.maximum(0.0, np.minimum(RU, final_allocations))\n\n        all_results.append(final_allocations)\n\n    # Format output string\n    output_parts = []\n    for result_vector in all_results:\n        formatted_vector = ','.join([f\"{val:.6f}\" for val in result_vector])\n        output_parts.append(f\"[{formatted_vector}]\")\n    \n    final_output = f\"[{','.join(output_parts)}]\"\n    return final_output\n\n# This function would be called to generate the answer\n# print(solve())\n```",
            "answer": "[[9.750000,20.000000,5.250000],[0.000000,0.000000],[5.000000,10.000000,15.000000,20.000000],[46.250000,0.000000,0.000000,13.750000]]"
        },
        {
            "introduction": "离散时间模型是实际电网运行的有力工具，但理解其局限性也同样重要，因为发电机组的动态过程本质上是连续的。本练习探讨了一个关键问题：离散的采样和控制可能掩盖在采样点之间发生的瞬时爬坡率越限行为。通过该练习，您将学习如何从理论上量化这种由离散化引入的“隐藏”误差，从而确保模型和监控系统的鲁棒性。",
            "id": "4093140",
            "problem": "一个热力发电机按连续时间进行调度，其实际功率输出轨迹 $P(t)$ 在每个长度为 $\\Delta t = t_{k+1}-t_k$ 的调度区间 $[t_k, t_{k+1}]$ 上是二次连续可微的。该机组在所有时间 $t$ 上都受到一个连续时间爬坡率限制 $|\\dot{P}(t)| \\le r$ 的约束，其中 $r  0$ 是已知常数。为便于实际监测，系统运营商仅在采样时刻执行离散的爬坡检查：$|P(t_{k+1}) - P(t_k)| \\le r \\,\\Delta t$。由于实际轨迹在一个区间内不一定是线性的，因此区间内对 $|\\dot{P}(t)| \\le r$ 的违反可能会被这种离散检查所掩盖。\n\n假设存在以下具有物理意义的正则性：存在一个已知常数 $a  0$，使得二阶导数在所有时间 $t$ 上都满足 $|\\ddot{P}(t)| \\le a$（这反映了由执行器和惯性限制导致的爬坡率变化率的界限）。\n\n仅使用关于可微函数的基本微积分事实，构建瞬时爬坡率超出平均斜率的可能区间内超额量的最紧统一界。具体来说，令 $m_k := \\dfrac{P(t_{k+1}) - P(t_k)}{\\Delta t}$ 表示在 $[t_k, t_{k+1}]$ 上的平均斜率。推导最小的函数 $B(\\Delta t, a)$，使得对于任何在 $[t_k,t_{k+1}]$ 上满足 $|\\ddot{P}(t)| \\le a$ 的 $P(t)$，都有\n$$\n\\sup_{\\tau \\in [t_k,t_{k+1}]} \\bigl| \\dot{P}(\\tau) \\bigr| \\le |m_k| + B(\\Delta t, a).\n$$\n然后，解释这个界，以获得关于 $\\Delta t$ 的一个充分条件，该条件保证：每当离散检查 $|P(t_{k+1}) - P(t_k)| \\le r \\,\\Delta t$ 通过时，任何可能的对连续时间爬坡率限制的区间内违反，其幅度被一个至多为 $\\varepsilon  0$ 的容差所限制，即 $\\sup_{\\tau \\in [t_k,t_{k+1}]} \\max\\{0, |\\dot{P}(\\tau)| - r\\} \\le \\varepsilon$。\n\n最后，取 $r = 30$ MW/min， $a = 180$ MW/min$^2$，并选择一个等于爬坡率限制十分之一的容差，即 $\\varepsilon = 0.1\\, r$。计算满足你所给充分条件的以秒为单位的最大允许采样间隔 $\\Delta t$。将答案四舍五入到三位有效数字。用秒表示你的最终结果。",
            "solution": "我们从导数和积分平均值的定义以及中值定理出发。令 $v(t) := \\dot{P}(t)$ 在长度为 $\\Delta t$ 的区间 $[t_k, t_{k+1}]$ 上。该区间上的平均斜率是\n$$\nm_k = \\frac{P(t_{k+1}) - P(t_k)}{\\Delta t} = \\frac{1}{\\Delta t} \\int_{t_k}^{t_{k+1}} v(s)\\, ds.\n$$\n给定二阶导数的一个统一界 $|\\ddot{P}(t)| \\le a$，这等价于 $v(t)$ 的一个 Lipschitz 界：$|v'(t)| \\le a$ 对区间内所有的 $t$ 成立。我们的目标是仅用 $\\Delta t$ 和 $a$ 来统一地界定在整个区间上 $v(t)$ 与其平均值 $m_k$ 的偏差。\n\n固定任意 $\\tau \\in [t_k, t_{k+1}]$。考虑\n$$\nv(\\tau) - m_k \\;=\\; v(\\tau) - \\frac{1}{\\Delta t} \\int_{t_k}^{t_{k+1}} v(s)\\, ds \\;=\\; \\frac{1}{\\Delta t} \\int_{t_k}^{t_{k+1}} \\bigl( v(\\tau) - v(s) \\bigr)\\, ds.\n$$\n取绝对值并使用三角不等式，得到\n$$\n|v(\\tau) - m_k| \\;\\le\\; \\frac{1}{\\Delta t} \\int_{t_k}^{t_{k+1}} |v(\\tau) - v(s)|\\, ds.\n$$\n根据微积分基本定理以及 $|v'|$ 的界，对任意 $s,\\tau$，我们有\n$$\n|v(\\tau) - v(s)| \\;=\\; \\left| \\int_{s}^{\\tau} v'(u)\\, du \\right| \\;\\le\\; \\int_{s}^{\\tau} |v'(u)|\\, du \\;\\le\\; \\int_{s}^{\\tau} a\\, du \\;=\\; a\\, |\\tau - s|.\n$$\n将此代入前一个不等式，\n$$\n|v(\\tau) - m_k| \\;\\le\\; \\frac{a}{\\Delta t} \\int_{t_k}^{t_{k+1}} |\\tau - s|\\, ds.\n$$\n让我们进行变量替换，以测量相对于 $t_k$ 的时间。记 $\\tau = t_k + \\theta$ 和 $s = t_k + \\sigma$，其中 $\\theta,\\sigma \\in [0,\\Delta t]$。那么\n$$\n\\int_{t_k}^{t_{k+1}} |\\tau - s|\\, ds \\;=\\; \\int_{0}^{\\Delta t} |\\theta - \\sigma|\\, d\\sigma \\;=: I(\\theta).\n$$\n我们显式地计算 $I(\\theta)$：\n$$\nI(\\theta) \\;=\\; \\int_{0}^{\\theta} (\\theta - \\sigma)\\, d\\sigma \\;+\\; \\int_{\\theta}^{\\Delta t} (\\sigma - \\theta)\\, d\\sigma \\;=\\; \\left[\\theta \\sigma - \\frac{\\sigma^{2}}{2}\\right]_{0}^{\\theta} + \\left[\\frac{\\sigma^{2}}{2} - \\theta \\sigma\\right]_{\\theta}^{\\Delta t}.\n$$\n计算得到，\n$$\nI(\\theta) \\;=\\; \\left(\\theta^{2} - \\frac{\\theta^{2}}{2}\\right) \\;+\\; \\left(\\frac{\\Delta t^{2}}{2} - \\theta \\Delta t - \\left(\\frac{\\theta^{2}}{2} - \\theta^{2}\\right)\\right) \\;=\\; \\frac{\\Delta t^{2}}{2} - \\Delta t\\, \\theta + \\theta^{2}.\n$$\n这个关于 $\\theta$ 的二次函数是凸的，其导数为 $2\\theta - \\Delta t$，因此它在 $[0,\\Delta t]$ 上的最大值在端点 $\\theta = 0$ 或 $\\theta = \\Delta t$ 处取得，此时 $I(0) = I(\\Delta t) = \\Delta t^{2}/2$。因此，\n$$\n\\sup_{\\tau \\in [t_k,t_{k+1}]} |v(\\tau) - m_k| \\;\\le\\; \\frac{a}{\\Delta t} \\cdot \\frac{\\Delta t^{2}}{2} \\;=\\; \\frac{a\\, \\Delta t}{2}.\n$$\n这个界是紧的：例如，选择 $v(t)$ 从左端点到右端点以斜率 $a$ 线性增加，会得到端点处与平均值的偏差恰好为 $a\\, \\Delta t/2$。\n\n因此，最紧的统一加性界是\n$$\nB(\\Delta t, a) \\;=\\; \\frac{a\\, \\Delta t}{2},\n$$\n其意义是对于所有允许的 $P(t)$，\n$$\n\\sup_{\\tau \\in [t_k,t_{k+1}]} |\\dot{P}(\\tau)| \\;\\le\\; |m_k| + \\frac{a\\, \\Delta t}{2}.\n$$\n\n我们现在相对于连续时间爬坡率限制来解释这个界。如果离散检查通过，那么 $|m_k| \\le r$，因而\n$$\n\\sup_{\\tau \\in [t_k,t_{k+1}]} |\\dot{P}(\\tau)| \\;\\le\\; r + \\frac{a\\, \\Delta t}{2}.\n$$\n因此，瞬时爬坡率超出 $r$ 的最大可能区间内超额量被 $\\frac{a\\, \\Delta t}{2}$ 所界定。为确保任何隐藏的违规不超过一个预设的容差 $\\varepsilon  0$，只需选择 $\\Delta t$ 使得\n$$\n\\frac{a\\, \\Delta t}{2} \\;\\le\\; \\varepsilon,\n$$\n成立，或等价地，\n$$\n\\Delta t \\;\\le\\; \\frac{2\\, \\varepsilon}{a}.\n$$\n\n对于数值实例，给定 $r = 30$ MW/min， $a = 180$ MW/min$^{2}$，以及 $\\varepsilon = 0.1\\, r = 3$ MW/min。以分钟为单位的最大允许区间长度是\n$$\n\\Delta t_{\\max} \\;=\\; \\frac{2\\, \\varepsilon}{a} \\;=\\; \\frac{2 \\times 3}{180} \\;=\\; \\frac{6}{180} \\;=\\; \\frac{1}{30} \\;\\text{分钟}.\n$$\n转换为秒，\n$$\n\\Delta t_{\\max} \\;=\\; \\frac{1}{30} \\times 60 \\;=\\; 2 \\;\\text{秒}.\n$$\n四舍五入到三位有效数字并以秒表示，结果是 $2.00$ 秒。",
            "answer": "$$\\boxed{2.00}$$"
        }
    ]
}