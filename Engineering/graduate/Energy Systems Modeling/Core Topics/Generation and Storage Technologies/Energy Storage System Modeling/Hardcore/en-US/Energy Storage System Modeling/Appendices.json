{
    "hands_on_practices": [
        {
            "introduction": "A model is only as good as the data used to create it. This practice confronts a foundational challenge in energy storage modeling: how to design an experiment that yields the most informative data for parameterizing an Equivalent Circuit Model (ECM). You will explore how different input current profiles excite a system's dynamics differently and learn to quantify this \"informational content\" using the Fisher Information Matrix ($\\mathcal{I}$) to ensure your identified parameters are as accurate as possible. This hands-on coding exercise provides a rigorous, systematic approach to experiment design, moving beyond ad-hoc testing to a principled methodology grounded in system identification theory .",
            "id": "4090372",
            "problem": "Consider an Equivalent Circuit Model (ECM) of a rechargeable electrochemical energy storage device that consists of an ohmic resistance and two first-order resistor-capacitor polarization branches. The ohmic resistance is denoted by $R_0$ (in $\\Omega$). The two resistor-capacitor branches are parameterized by $(R_1, C_1)$ and $(R_2, C_2)$ (in $\\Omega$ and $\\mathrm{F}$ respectively). The input is the applied current $i(t)$ (in $\\mathrm{A}$), and the measured output is the terminal voltage $y(t)$ (in $\\mathrm{V}$). Assume operation around a fixed state-of-charge such that open-circuit voltage is effectively constant and can be subtracted; the observable dynamics are due to the polarization voltages and the ohmic drop.\n\nStarting from fundamental relations, namely Ohm’s law $v = R i$ and the capacitor constitutive law $i = C \\,\\frac{dv}{dt}$ applied to a parallel resistor-capacitor branch, establish a discrete-time model at a uniform sampling period $T_s$ (in $\\mathrm{s}$) for the branch voltages $v_1$ and $v_2$ and the measured output $y_k$ at discrete times $t_k = k T_s$. Assume an initial rest condition $v_1(0)=0$, $v_2(0)=0$.\n\nAssume the measurement noise is independently and identically distributed zero-mean Gaussian with variance $\\sigma^2$ (in $\\mathrm{V}^2$). Use the definition of the Fisher Information Matrix (FIM) for independent Gaussian noise to analyze parameter identifiability. Construct a sensitivity-based algorithm to compute the FIM for the parameter vector $\\theta = [R_0, R_1, C_1, R_2, C_2]^\\top$ under a given input sequence $\\{i_k\\}_{k=0}^{N-1}$, and use a log-determinant metric to select inputs that maximize parameter confidence in the sense of D-optimal design.\n\nDesign candidate input sequences $\\{i_k\\}$ constrained by a maximum current magnitude $I_{\\max}$ (in $\\mathrm{A}$), and restrict consideration to the following four families, each of length $N$ samples:\n- Index $0$: A two-level step sequence $i_k = I_{\\max}$ for $k  N/2$ and $i_k = -I_{\\max}$ for $k \\ge N/2$.\n- Index $1$: A slow square-wave sequence that toggles between $\\pm I_{\\max}$ every $L$ samples, where $L$ is a positive integer.\n- Index $2$: A fast alternating sequence that toggles between $\\pm I_{\\max}$ every sample.\n- Index $3$: A multisine sequence of the form $i_k = \\sum_{m=1}^M A_m \\sin(2\\pi f_m k T_s)$, scaled so that $\\max_k |i_k| \\le I_{\\max}$, with fixed frequencies $f_m$ (in $\\mathrm{Hz}$) and amplitudes $A_m$ selected to be nonzero.\n\nYour task is to implement a program that, for each provided test case, performs the following steps:\n1. Starting from the fundamental laws described above, construct the discrete-time model of the ECM.\n2. Derive and implement a recursion for the sensitivities of the discrete-time states with respect to the parameters in $\\theta$.\n3. Compute the Fisher Information Matrix based on the output sensitivity at each sample under the assumption of independent Gaussian measurement noise with variance $\\sigma^2$.\n4. For each of the four candidate input sequences, compute the log-determinant of the Fisher Information Matrix, interpret non-positive definiteness as non-identifiability, and select the index of the input that maximizes the log-determinant (with ties broken by selecting the smallest index).\n5. Output, for all test cases, a single line containing a comma-separated list of the selected indices enclosed in square brackets, e.g., \"[i_1,i_2,i_3,i_4]\". Indices are dimensionless integers.\n\nExpress all physical quantities in SI units: resistance in $\\Omega$, capacitance in $\\mathrm{F}$, time in $\\mathrm{s}$, current in $\\mathrm{A}$, and voltage in $\\mathrm{V}$.\n\nTest Suite:\nUse the following parameter sets and experimental conditions. In all cases, set the initial states to zero. For the slow square-wave candidate, use $L = 10$ samples. For the multisine candidate, use $M=3$ sinusoids with frequencies $f_1 = 0.01\\,\\mathrm{Hz}$, $f_2 = 0.05\\,\\mathrm{Hz}$, $f_3 = 0.2\\,\\mathrm{Hz}$, and choose equal amplitudes before scaling to respect the current bound.\n\n- Case 1 (happy path): $R_0 = 0.02\\,\\Omega$, $R_1 = 0.01\\,\\Omega$, $C_1 = 2500\\,\\mathrm{F}$, $R_2 = 0.015\\,\\Omega$, $C_2 = 4000\\,\\mathrm{F}$, $T_s = 1\\,\\mathrm{s}$, $N = 200$, $\\sigma = 10^{-3}\\,\\mathrm{V}$, $I_{\\max} = 10\\,\\mathrm{A}$.\n- Case 2 (slow dynamics): $R_0 = 0.015\\,\\Omega$, $R_1 = 0.02\\,\\Omega$, $C_1 = 10000\\,\\mathrm{F}$, $R_2 = 0.03\\,\\Omega$, $C_2 = 20000\\,\\mathrm{F}$, $T_s = 1\\,\\mathrm{s}$, $N = 200$, $\\sigma = 10^{-3}\\,\\mathrm{V}$, $I_{\\max} = 10\\,\\mathrm{A}$.\n- Case 3 (high noise): $R_0 = 0.02\\,\\Omega$, $R_1 = 0.01\\,\\Omega$, $C_1 = 2500\\,\\mathrm{F}$, $R_2 = 0.02\\,\\Omega$, $C_2 = 2500\\,\\mathrm{F}$, $T_s = 1\\,\\mathrm{s}$, $N = 200$, $\\sigma = 5\\times 10^{-2}\\,\\mathrm{V}$, $I_{\\max} = 10\\,\\mathrm{A}$.\n- Case 4 (short experiment): $R_0 = 0.025\\,\\Omega$, $R_1 = 0.015\\,\\Omega$, $C_1 = 3000\\,\\mathrm{F}$, $R_2 = 0.02\\,\\Omega$, $C_2 = 1500\\,\\mathrm{F}$, $T_s = 1\\,\\mathrm{s}$, $N = 60$, $\\sigma = 10^{-3}\\,\\mathrm{V}$, $I_{\\max} = 12\\,\\mathrm{A}$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3,result4]\"), where each entry is the selected candidate index for the corresponding test case.",
            "solution": "The user-provided problem is valid as it is scientifically grounded in established principles of electrical circuit theory and system identification, is well-posed with a clear objective and sufficient data, and is expressed in objective, formal language. We will proceed with a full solution.\n\nThe problem requires a systematic approach to optimal experiment design for parameter identification of an electrochemical energy storage device's Equivalent Circuit Model (ECM). The solution involves four primary stages: (1) derivation of a discrete-time model for the ECM, (2) derivation of the parameter sensitivity equations for the model output, (3) construction of the Fisher Information Matrix (FIM) based on these sensitivities, and (4) evaluation of candidate input signals using the D-optimality criterion, which involves maximizing the determinant of the FIM.\n\n### 1. Discrete-Time Model of the Equivalent Circuit\n\nThe ECM consists of an ohmic resistor $R_0$ in series with two parallel resistor-capacitor (RC) branches, denoted by $(R_1, C_1)$ and $(R_2, C_2)$. The total voltage across the circuit, $y(t)$, is the sum of the voltage drops across each series component when a current $i(t)$ is applied.\n$$y(t) = R_0 i(t) + v_1(t) + v_2(t)$$\nwhere $v_j(t)$ is the voltage across the $j$-th RC branch.\n\nFor each parallel RC branch $j \\in \\{1, 2\\}$, applying Kirchhoff's current law gives:\n$$i(t) = i_{R_j}(t) + i_{C_j}(t) = \\frac{v_j(t)}{R_j} + C_j \\frac{dv_j(t)}{dt}$$\nThis can be rearranged into a first-order linear ordinary differential equation (ODE) for the branch voltage $v_j(t)$:\n$$\\frac{dv_j(t)}{dt} = -\\frac{1}{R_j C_j} v_j(t) + \\frac{1}{C_j} i(t)$$\nDefining the state vector as $x(t) = [v_1(t), v_2(t)]^\\top$, we have a continuous-time state-space representation.\n\nTo create a discrete-time model with sampling period $T_s$, we assume the input current $i(t)$ is constant over each sampling interval $[k T_s, (k+1) T_s]$, with a value of $i_k$. This is a zero-order hold (ZOH) assumption. The exact solution to the ODE for state $v_j$ over one interval is:\n$$v_j((k+1)T_s) = e^{-T_s/(R_j C_j)} v_j(k T_s) + \\int_0^{T_s} e^{-(T_s - \\tau)/(R_j C_j)} \\frac{1}{C_j} i_k d\\tau$$\nEvaluating the integral yields the discrete-time update equation:\n$$v_{j, k+1} = e^{-T_s/(R_j C_j)} v_{j,k} + (1 - e^{-T_s/(R_j C_j)}) R_j i_k$$\nwhere $v_{j,k} = v_j(k T_s)$.\n\nWe can express the complete system in discrete-time state-space form:\n$$x_{k+1} = A_d x_k + B_d i_k$$\n$$y_k = C_d x_k + D_d i_k$$\nwhere the state vector is $x_k = [v_{1,k}, v_{2,k}]^\\top$, and the matrices are:\n$$\nA_d = \\begin{pmatrix} e^{-T_s/(R_1 C_1)}  0 \\\\ 0  e^{-T_s/(R_2 C_2)} \\end{pmatrix}, \\quad\nB_d = \\begin{pmatrix} (1 - e^{-T_s/(R_1 C_1)}) R_1 \\\\ (1 - e^{-T_s/(R_2 C_2)}) R_2 \\end{pmatrix}\n$$\n$$\nC_d = \\begin{pmatrix} 1  1 \\end{pmatrix}, \\quad\nD_d = R_0\n$$\nThe initial conditions are given as $v_1(0)=0$ and $v_2(0)=0$, so $x_0 = [0, 0]^\\top$.\n\n### 2. Parameter Sensitivity Analysis\n\nThe parameter vector is $\\theta = [R_0, R_1, C_1, R_2, C_2]^\\top$. We must find the sensitivity of the output, $S_{y,p,k} = \\frac{\\partial y_k}{\\partial p}$, for each parameter $p \\in \\theta$. From the output equation $y_k = R_0 i_k + v_{1,k} + v_{2,k}$:\n$$\\frac{\\partial y_k}{\\partial p} = \\frac{\\partial (R_0 i_k)}{\\partial p} + \\frac{\\partial v_{1,k}}{\\partial p} + \\frac{\\partial v_{2,k}}{\\partial p}$$\nThe state sensitivities, $S_{v_j,p,k} = \\frac{\\partial v_{j,k}}{\\partial p}$, are found by differentiating the state update equation with respect to $p$:\n$$S_{v_j,p,k+1} = \\frac{\\partial}{\\partial p} \\left( e^{-T_s/(R_j C_j)} v_{j,k} + (1 - e^{-T_s/(R_j C_j)}) R_j i_k \\right)$$\nUsing the product rule and chain rule, we obtain a recursive formula for the state sensitivities. Let $\\alpha_j = e^{-T_s/(R_j C_j)}$. The recursion is:\n$$S_{v_j,p,k+1} = \\frac{\\partial \\alpha_j}{\\partial p} v_{j,k} + \\alpha_j S_{v_j,p,k} + \\frac{\\partial((1-\\alpha_j)R_j)}{\\partial p} i_k$$\nwith initial conditions $S_{v_j,p,0} = \\frac{\\partial v_{j,0}}{\\partial p} = 0$.\n\nThe specific sensitivity derivations are as follows:\n\n1.  **Sensitivity to $R_0$**: $R_0$ only appears in the output equation. Hence, $\\frac{\\partial v_{j,k}}{\\partial R_0} = 0$ for all $j, k$.\n    $$S_{y,R_0,k} = \\frac{\\partial y_k}{\\partial R_0} = i_k$$\n2.  **Sensitivity to $R_1, C_1$**: These parameters only affect $v_1$. Thus, $\\frac{\\partial v_{2,k}}{\\partial R_1} = 0$ and $\\frac{\\partial v_{2,k}}{\\partial C_1} = 0$.\n    For $S_{v_1,R_1,k}$:\n    $$\\frac{\\partial \\alpha_1}{\\partial R_1} = \\alpha_1 \\frac{T_s}{R_1^2 C_1}$$\n    $$\\frac{\\partial((1-\\alpha_1)R_1)}{\\partial R_1} = 1 - \\alpha_1 - R_1\\frac{\\partial \\alpha_1}{\\partial R_1} = 1 - \\alpha_1 - \\alpha_1 \\frac{T_s}{R_1 C_1}$$\n    The recursion becomes:\n    $$S_{v_1,R_1,k+1} = \\alpha_1 S_{v_1,R_1,k} + \\left(\\alpha_1 \\frac{T_s}{R_1^2 C_1}\\right) v_{1,k} + \\left(1 - \\alpha_1 - \\alpha_1 \\frac{T_s}{R_1 C_1}\\right) i_k$$\n    For $S_{v_1,C_1,k}$:\n    $$\\frac{\\partial \\alpha_1}{\\partial C_1} = \\alpha_1 \\frac{T_s}{R_1 C_1^2}$$\n    $$\\frac{\\partial((1-\\alpha_1)R_1)}{\\partial C_1} = -R_1 \\frac{\\partial \\alpha_1}{\\partial C_1} = - \\alpha_1 \\frac{T_s}{C_1^2}$$\n    The recursion becomes:\n    $$S_{v_1,C_1,k+1} = \\alpha_1 S_{v_1,C_1,k} + \\left(\\alpha_1 \\frac{T_s}{R_1 C_1^2}\\right) v_{1,k} - \\left(\\alpha_1 \\frac{T_s}{C_1^2}\\right) i_k$$\n    The output sensitivities are $S_{y,R_1,k} = S_{v_1,R_1,k}$ and $S_{y,C_1,k} = S_{v_1,C_1,k}$.\n3.  **Sensitivity to $R_2, C_2$**: The derivations are analogous to those for $R_1, C_1$, with indices swapped.\n    $$S_{y,R_2,k} = S_{v_2,R_2,k}, \\quad S_{y,C_2,k} = S_{v_2,C_2,k}$$\n\nThe full output sensitivity vector at step $k$ is $S_{y,k} = [\\frac{\\partial y_k}{\\partial R_0}, \\frac{\\partial y_k}{\\partial R_1}, \\frac{\\partial y_k}{\\partial C_1}, \\frac{\\partial y_k}{\\partial R_2}, \\frac{\\partial y_k}{\\partial C_2}]^\\top$.\n\n### 3. Fisher Information Matrix (FIM)\n\nFor a model with additive, independent, and identically distributed (i.i.d.) zero-mean Gaussian noise with variance $\\sigma^2$, the Fisher Information Matrix $\\mathcal{I}$ is given by:\n$$\\mathcal{I} = \\sum_{k=0}^{N-1} \\frac{1}{\\sigma^2} \\left(\\frac{\\partial y_k}{\\partial \\theta}\\right) \\left(\\frac{\\partial y_k}{\\partial \\theta}\\right)^\\top = \\frac{1}{\\sigma^2} \\sum_{k=0}^{N-1} S_{y,k} S_{y,k}^\\top$$\nwhere $N$ is the number of samples. The matrix $\\mathcal{I}$ is a $5 \\times 5$ symmetric matrix. Its inverse, $\\mathcal{I}^{-1}$, provides the Cramér-Rao Lower Bound on the variance of any unbiased estimator of $\\theta$. A larger FIM corresponds to greater potential precision in parameter estimates.\n\nThe numerical algorithm proceeds by simulating the system and sensitivities simultaneously. At each time step $k \\in [0, N-1]$, the states $x_k$ and state sensitivities are used to form the output sensitivity vector $S_{y,k}$. The outer product $S_{y,k} S_{y,k}^\\top$ is computed and added to a running sum. Finally, this sum is divided by $\\sigma^2$.\n\n### 4. D-Optimal Experiment Design\n\nD-optimality is an experiment design criterion that aims to maximize the determinant of the Fisher Information Matrix, $\\det(\\mathcal{I})$. Maximizing $\\det(\\mathcal{I})$ is equivalent to minimizing the volume of the confidence ellipsoid for the parameter estimates. For numerical stability, we maximize its logarithm, $\\log(\\det(\\mathcal{I}))$.\n\nThe FIM is positive semi-definite by construction. If the experiment is not sufficiently exciting (i.e., the sensitivity vectors $\\{S_{y,k}\\}$ do not span the 5-dimensional parameter space), the FIM will be singular, $\\det(\\mathcal{I})=0$, and the parameters are not identifiable. In this case, $\\log(\\det(\\mathcal{I}))$ is $-\\infty$.\n\nThe overall procedure is as follows:\n1.  For each test case, define the true parameter vector $\\theta$.\n2.  For each of the four candidate input current sequences $\\{i_k\\}$:\n    a. Generate the sequence of length $N$ according to its definition and constraints ($I_{\\max}$).\n    b. Initialize states $x_0=[0,0]^\\top$, state sensitivities to zero, and the FIM sum matrix to a $5 \\times 5$ zero matrix.\n    c. Loop from $k=0$ to $N-1$:\n        i.  Compute the output sensitivity vector $S_{y,k}$ based on the current states and sensitivities.\n        ii. Update the FIM sum: $\\mathcal{I}_{\\text{sum}} \\leftarrow \\mathcal{I}_{\\text{sum}} + S_{y,k} S_{y,k}^\\top$.\n        iii. Update the states $x_{k+1}$ and all state sensitivities for the next time step.\n    d. Compute the final FIM: $\\mathcal{I} = \\mathcal{I}_{\\text{sum}} / \\sigma^2$.\n    e. Calculate $\\det(\\mathcal{I})$. If $\\det(\\mathcal{I})  0$, the score is $\\log(\\det(\\mathcal{I}))$. Otherwise, the score is considered $-\\infty$.\n3.  Compare the scores for the four inputs. The index of the input with the highest score is the chosen result. Ties are broken by choosing the smaller index.",
            "answer": "```python\nimport numpy as np\n\ndef generate_inputs(N, I_max, Ts, L, multisine_freqs):\n    \"\"\"\n    Generates the four candidate input current sequences.\n    \"\"\"\n    inputs = []\n    \n    # Index 0: Two-level step sequence\n    n_half = N // 2\n    step_seq = np.concatenate([np.full(n_half, I_max), np.full(N - n_half, -I_max)])\n    inputs.append(step_seq)\n\n    # Index 1: Slow square-wave sequence\n    k_indices = np.arange(N)\n    slow_square_seq = I_max * (-1)**(k_indices // L)\n    inputs.append(slow_square_seq)\n\n    # Index 2: Fast alternating sequence\n    fast_alt_seq = I_max * (-1)**k_indices\n    inputs.append(fast_alt_seq)\n    \n    # Index 3: Multisine sequence\n    t = k_indices * Ts\n    sines = [np.sin(2 * np.pi * f * t) for f in multisine_freqs]\n    unscaled_signal = np.sum(sines, axis=0)\n    s_max = np.max(np.abs(unscaled_signal))\n    if s_max > 1e-9:\n        multisine_seq = I_max * unscaled_signal / s_max\n    else:\n        multisine_seq = np.zeros(N)\n    inputs.append(multisine_seq)\n    \n    return inputs\n\ndef compute_fim_logdet(params, consts, current_seq):\n    \"\"\"\n    Computes the log-determinant of the Fisher Information Matrix for a given input.\n    \"\"\"\n    R0, R1, C1, R2, C2 = params\n    Ts, N, sigma, I_max = consts\n\n    # Pre-compute constants for the simulation loop\n    tau1 = R1 * C1\n    tau2 = R2 * C2\n    \n    if tau1 = 0 or tau2 = 0:\n        return -np.inf\n\n    alpha1 = np.exp(-Ts / tau1)\n    alpha2 = np.exp(-Ts / tau2)\n\n    # Sensitivity-related constants\n    d_alpha1_dR1 = alpha1 * Ts / (R1**2 * C1)\n    d_alpha1_dC1 = alpha1 * Ts / (R1 * C1**2)\n    d_alpha2_dR2 = alpha2 * Ts / (R2**2 * C2)\n    d_alpha2_dC2 = alpha2 * Ts / (R2 * C2**2)\n    \n    B1_term_R1 = 1 - alpha1 - alpha1 * Ts / tau1\n    B1_term_C1 = -R1 * d_alpha1_dC1\n    B2_term_R2 = 1 - alpha2 - alpha2 * Ts / tau2\n    B2_term_C2 = -R2 * d_alpha2_dC2\n\n    # Initialize states and sensitivities\n    v1, v2 = 0.0, 0.0\n    sv1_r1, sv1_c1, sv2_r2, sv2_c2 = 0.0, 0.0, 0.0, 0.0\n\n    fim_sum = np.zeros((5, 5), dtype=np.float64)\n    S_yk = np.zeros(5, dtype=np.float64)\n\n    for k in range(N):\n        ik = current_seq[k]\n\n        # 1. Construct output sensitivity vector for current step k\n        S_yk[0] = ik       # d(y_k)/d(R0)\n        S_yk[1] = sv1_r1   # d(y_k)/d(R1) = d(v1_k)/d(R1)\n        S_yk[2] = sv1_c1   # d(y_k)/d(C1) = d(v1_k)/d(C1)\n        S_yk[3] = sv2_r2   # d(y_k)/d(R2) = d(v2_k)/d(R2)\n        S_yk[4] = sv2_c2   # d(y_k)/d(C2) = d(v2_k)/d(C2)\n\n        # 2. Update FIM sum\n        fim_sum += np.outer(S_yk, S_yk)\n\n        # 3. Update states for next step k+1\n        v1_next = alpha1 * v1 + (1 - alpha1) * R1 * ik\n        v2_next = alpha2 * v2 + (1 - alpha2) * R2 * ik\n        \n        # 4. Update sensitivities for next step k+1\n        sv1_r1_next = alpha1 * sv1_r1 + d_alpha1_dR1 * v1 + B1_term_R1 * ik\n        sv1_c1_next = alpha1 * sv1_c1 + d_alpha1_dC1 * v1 + B1_term_C1 * ik\n        sv2_r2_next = alpha2 * sv2_r2 + d_alpha2_dR2 * v2 + B2_term_R2 * ik\n        sv2_c2_next = alpha2 * sv2_c2 + d_alpha2_dC2 * v2 + B2_term_C2 * ik\n\n        # Assign for next iteration\n        v1, v2 = v1_next, v2_next\n        sv1_r1, sv1_c1 = sv1_r1_next, sv1_c1_next\n        sv2_r2, sv2_c2 = sv2_r2_next, sv2_c2_next\n\n    # Final FIM calculation\n    FIM = fim_sum / (sigma**2)\n\n    # Use slogdet for numerical stability\n    sign, logdet = np.linalg.slogdet(FIM)\n    \n    if sign > 0:\n        return logdet\n    else:\n        return -np.inf\n\ndef solve():\n    test_cases = [\n        # Case 1\n        {'params': (0.02, 0.01, 2500, 0.015, 4000), 'consts': (1.0, 200, 1e-3, 10.0)},\n        # Case 2\n        {'params': (0.015, 0.02, 10000, 0.03, 20000), 'consts': (1.0, 200, 1e-3, 10.0)},\n        # Case 3\n        {'params': (0.02, 0.01, 2500, 0.02, 2500), 'consts': (1.0, 200, 5e-2, 10.0)},\n        # Case 4\n        {'params': (0.025, 0.015, 3000, 0.02, 1500), 'consts': (1.0, 60, 1e-3, 12.0)},\n    ]\n    \n    L = 10\n    multisine_freqs = [0.01, 0.05, 0.2]\n    \n    results = []\n\n    for case in test_cases:\n        params = case['params']\n        consts = case['consts']\n        Ts, N, sigma, I_max = consts\n        \n        inputs = generate_inputs(N, I_max, Ts, L, multisine_freqs)\n        \n        scores = []\n        for i in range(len(inputs)):\n            score = compute_fim_logdet(params, consts, inputs[i])\n            scores.append(score)\n            \n        best_index = np.argmax(scores)\n        results.append(best_index)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "Once a model is parameterized, its primary use is often to estimate internal states that cannot be measured directly, such as a battery's State of Charge (SOC). However, is it always possible to deduce the SOC from voltage and current measurements? This exercise delves into the theoretical underpinnings of state estimation by exploring the concept of *observability*. You will derive the mathematical conditions under which the SOC of a nonlinear battery model can be locally determined, linking the physical properties of the cell, such as the slope of its Open-Circuit Voltage (OCV) curve, to the fundamental possibility of accurate state tracking .",
            "id": "4090378",
            "problem": "A lithium-ion battery pack is modeled by a single-state Equivalent Circuit Model (ECM). The state of charge (SOC) at discrete time index $k$ is denoted by $x_k \\in [0,1]$ and evolves according to\n$$\nx_{k+1} = x_k - \\frac{\\eta I_k \\Delta t}{C},\n$$\nwhere $I_k$ is the measured applied current (positive for discharge), $\\eta \\in (0,1]$ is the coulombic efficiency, $\\Delta t0$ is the sampling period, and $C0$ is the cell capacity. The terminal voltage measurement is\n$$\nV_k = h(x_k) - R I_k,\n$$\nwhere $R \\ge 0$ is a known ohmic resistance and $h(\\cdot)$ is the open-circuit voltage (OCV) map, assumed to be continuously differentiable and strictly real-valued on $[0,1]$. All parameters and the current sequence $\\{I_k\\}$ are known, and there is no process or measurement noise. Define the adjusted output $z_k \\triangleq V_k + R I_k = h(x_k)$.\n\nLet $x^\\star \\in (0,1)$ be a nominal SOC around which local observability is to be assessed. Consider a finite observation horizon of length $N \\in \\mathbb{N}\\cup\\{0\\}$ and define the forward input-induced SOC increments $S_0 \\triangleq 0$ and\n$$\nS_k \\triangleq -\\sum_{i=0}^{k-1} \\frac{\\eta I_i \\Delta t}{C} \\quad \\text{for} \\quad k \\ge 1,\n$$\nso that $x_k = x^\\star + S_k$ under the known input sequence when initialized at $x_0 = x^\\star$.\n\nStarting from first principles of local weak observability for discrete-time nonlinear systems and the inverse function theorem, derive the Jacobian of the observation map that takes the initial SOC $x_0$ to the stacked outputs $\\{z_k\\}_{k=0}^N$. Then construct a scalar nonnegative quantity that is zero if and only if the Jacobian is the zero vector, and is strictly positive otherwise, thereby certifying local observability at $x^\\star$ over the horizon $N$.\n\nExpress your final result as a closed-form analytic expression in terms of $h'(\\cdot)$, $\\eta$, $\\Delta t$, $C$, and the current sequence $\\{I_k\\}_{k=0}^{N-1}$. Your answer must be the single scalar expression that serves as this local observability certificate. No numerical evaluation is required. Do not include any inequalities or verbal conditions in your final answer. If your expression includes sums, write them explicitly using summation notation. No units are required in the final answer.",
            "solution": "The user wants to derive a local observability certificate for a discrete-time nonlinear battery model.\n\n### Step 1: Extract Givens\n- State evolution equation: $x_{k+1} = x_k - \\frac{\\eta I_k \\Delta t}{C}$\n- State of charge: $x_k \\in [0,1]$\n- Time index: $k$\n- Applied current: $I_k$ (positive for discharge)\n- Coulombic efficiency: $\\eta \\in (0,1]$\n- Sampling period: $\\Delta t  0$\n- Cell capacity: $C  0$\n- Terminal voltage measurement: $V_k = h(x_k) - R I_k$\n- Ohmic resistance: $R \\ge 0$\n- Open-circuit voltage (OCV) map: $h(\\cdot)$, continuously differentiable and strictly real-valued on $[0,1]$\n- Adjusted output: $z_k \\triangleq V_k + R I_k = h(x_k)$\n- Nominal SOC: $x^\\star \\in (0,1)$\n- Observation horizon length: $N \\in \\mathbb{N}\\cup\\{0\\}$\n- Forward input-induced SOC increments: $S_0 \\triangleq 0$ and $S_k \\triangleq -\\sum_{i=0}^{k-1} \\frac{\\eta I_i \\Delta t}{C}$ for $k \\ge 1$.\n- System state under initial condition $x_0 = x^\\star$ is $x_k = x^\\star + S_k$.\n- All parameters ($\\eta, \\Delta t, C, R$) and the input sequence $\\{I_k\\}$ are known.\n- The system is deterministic (no process or measurement noise).\n\n### Step 2: Validate Using Extracted Givens\nThe problem is scientifically and mathematically sound.\n- **Scientifically Grounded**: The model is a standard first-order Equivalent Circuit Model (ECM) for a lithium-ion battery, a widely used and validated approach in energy systems and control engineering. The concepts of state of charge (SOC), open-circuit voltage (OCV), and coulombic efficiency are fundamental to battery modeling.\n- **Well-Posed**: The problem asks for the derivation of an observability certificate, which is a standard task in nonlinear systems theory. The definitions are precise, and all necessary information is provided. The task is to derive a specific analytical expression, which has a unique solution based on the principles of control theory.\n- **Objective**: The problem is stated in precise mathematical language, free from any subjective or ambiguous terminology.\n- **Completeness**: The model and all its parameters are fully specified. The task is clearly articulated.\n\nThe problem does not violate any of the invalidity criteria. It is a formal, self-contained, and solvable problem in the field of system identification and control theory applied to energy storage systems. All terms are well-defined within the context of the discipline.\n\n### Step 3: Verdict and Action\nThe problem is valid. A complete, reasoned solution will be provided.\n\n### Derivation of the Observability Certificate\n\nThe problem requires assessing the local weak observability of the system at a nominal state of charge $x^\\star$. Observability concerns the ability to determine the initial state of a system, here $x_0$, from a sequence of output measurements. In this case, the output measurements are the adjusted voltages $\\{z_k\\}_{k=0}^N$.\n\nFirst, we define the observation map, $\\mathcal{H}$, which maps an initial state $x_0$ to the vector of outputs over the horizon $N$. The state at any time step $k$ can be expressed as a function of the initial state $x_0$ and the known input sequence $\\{I_i\\}$.\nFrom the state evolution equation, a recursive substitution gives:\n$x_1 = x_0 - \\frac{\\eta I_0 \\Delta t}{C}$\n$x_2 = x_1 - \\frac{\\eta I_1 \\Delta t}{C} = x_0 - \\frac{\\eta I_0 \\Delta t}{C} - \\frac{\\eta I_1 \\Delta t}{C} = x_0 - \\sum_{i=0}^{1} \\frac{\\eta I_i \\Delta t}{C}$\nIn general, for any $k \\ge 1$:\n$$\nx_k = x_0 - \\sum_{i=0}^{k-1} \\frac{\\eta I_i \\Delta t}{C}\n$$\nUsing the given definition $S_k \\triangleq -\\sum_{i=0}^{k-1} \\frac{\\eta I_i \\Delta t}{C}$ for $k \\ge 1$ and $S_0 \\triangleq 0$, we can write the state at any time $k$ as:\n$$\nx_k = x_0 + S_k\n$$\nThe adjusted output at time $k$ is $z_k = h(x_k)$. Therefore, we can write $z_k$ as a function of the initial state $x_0$:\n$$\nz_k = h(x_0 + S_k)\n$$\nThe observation map $\\mathcal{H}$ takes the scalar initial state $x_0$ and produces the $(N+1)$-dimensional output vector $\\mathbf{z} = [z_0, z_1, \\dots, z_N]^T$.\n$$\n\\mathbf{z} = \\mathcal{H}(x_0) = \\begin{pmatrix} z_0 \\\\ z_1 \\\\ \\vdots \\\\ z_N \\end{pmatrix} = \\begin{pmatrix} h(x_0 + S_0) \\\\ h(x_0 + S_1) \\\\ \\vdots \\\\ h(x_0 + S_N) \\end{pmatrix}\n$$\nAccording to the principles of nonlinear observability and the inverse function theorem, the system is locally weakly observable at a nominal state $x^\\star$ if the observation map $\\mathcal{H}$ is locally injective at $x_0 = x^\\star$. A sufficient condition for this is that the Jacobian of the map, evaluated at $x_0=x^\\star$, has full column rank.\n\nThe Jacobian of $\\mathcal{H}$ with respect to the initial state $x_0$ is an $(N+1) \\times 1$ matrix (a column vector):\n$$\nJ_{\\mathcal{H}}(x_0) = \\frac{\\partial \\mathcal{H}}{\\partial x_0} = \\begin{pmatrix} \\frac{\\partial z_0}{\\partial x_0} \\\\ \\frac{\\partial z_1}{\\partial x_0} \\\\ \\vdots \\\\ \\frac{\\partial z_N}{\\partial x_0} \\end{pmatrix}\n$$\nWe compute each entry using the chain rule. Since $h(\\cdot)$ is continuously differentiable, its derivative $h'(\\cdot)$ exists.\n$$\n\\frac{\\partial z_k}{\\partial x_0} = \\frac{\\partial}{\\partial x_0} h(x_0 + S_k) = h'(x_0 + S_k) \\cdot \\frac{\\partial}{\\partial x_0}(x_0 + S_k) = h'(x_0 + S_k) \\cdot 1 = h'(x_0 + S_k)\n$$\nThus, the Jacobian is:\n$$\nJ_{\\mathcal{H}}(x_0) = \\begin{pmatrix} h'(x_0 + S_0) \\\\ h'(x_0 + S_1) \\\\ \\vdots \\\\ h'(x_0 + S_N) \\end{pmatrix}\n$$\nWe evaluate this Jacobian at the nominal initial state $x_0 = x^\\star$:\n$$\nJ_{\\mathcal{H}}(x^\\star) = \\begin{pmatrix} h'(x^\\star + S_0) \\\\ h'(x^\\star + S_1) \\\\ \\vdots \\\\ h'(x^\\star + S_N) \\end{pmatrix}\n$$\nFor a column vector, having full column rank is equivalent to being a non-zero vector. Therefore, the system is locally observable at $x^\\star$ if and only if $J_{\\mathcal{H}}(x^\\star) \\neq \\mathbf{0}$. This means at least one of its components must be non-zero.\n\nThe problem asks for a scalar non-negative quantity that is zero if and only if this Jacobian is the zero vector. The squared Euclidean norm of the Jacobian vector, $\\|J_{\\mathcal{H}}(x^\\star)\\|_2^2$, satisfies this requirement. Let this scalar certificate be $\\mathcal{O}$.\n$$\n\\mathcal{O} = \\|J_{\\mathcal{H}}(x^\\star)\\|_2^2 = \\sum_{k=0}^{N} \\left( [J_{\\mathcal{H}}(x^\\star)]_k \\right)^2 = \\sum_{k=0}^{N} (h'(x^\\star + S_k))^2\n$$\nThe system is locally observable if and only if $\\mathcal{O}  0$.\n\nFinally, we express this certificate in terms of the given parameters $h'(\\cdot)$, $\\eta$, $\\Delta t$, $C$, and the current sequence $\\{I_k\\}$. We substitute the definition of $S_k$:\n$$\n\\mathcal{O} = \\sum_{k=0}^{N} \\left( h'\\left(x^\\star + S_k\\right) \\right)^2\n$$\nFor $k=0$, $S_0=0$, and the term is $(h'(x^\\star))^2$.\nFor $k \\ge 1$, $S_k = -\\sum_{i=0}^{k-1} \\frac{\\eta I_i \\Delta t}{C}$.\nWe can write the entire sum compactly by defining the empty sum $\\sum_{i=0}^{-1}$ to be $0$. This allows us to use a single summation expression starting from $k=0$:\n$$\n\\mathcal{O} = \\sum_{k=0}^{N} \\left( h'\\left(x^\\star - \\frac{\\eta \\Delta t}{C} \\sum_{i=0}^{k-1} I_i \\right) \\right)^2\n$$\nThis expression is the required scalar non-negative quantity. It is zero if and only if $h'\\left(x^\\star - \\frac{\\eta \\Delta t}{C} \\sum_{i=0}^{k-1} I_i \\right) = 0$ for all $k \\in \\{0, 1, \\dots, N\\}$, which corresponds to the case where the Jacobian is the zero vector and the system is not locally observable.\nThis is the final analytical expression for the local observability certificate.",
            "answer": "$$\n\\boxed{\\sum_{k=0}^{N} \\left( h'\\left(x^\\star - \\frac{\\eta \\Delta t}{C} \\sum_{i=0}^{k-1} I_i \\right) \\right)^2}\n$$"
        },
        {
            "introduction": "Understanding the long-term performance and eventual failure of an energy storage system is critical for its economic viability and operational reliability. This practice bridges the gap between electrical cycling data and mechanical degradation theory to estimate battery lifetime. By implementing the industry-standard *rainflow counting* algorithm and applying a classic fatigue model, you will learn to translate a complex State of Charge (SoC) profile into a quantifiable measure of cumulative damage. This computational problem demonstrates how to forecast a battery's energy throughput to failure, a crucial metric for designing durable and cost-effective energy storage solutions .",
            "id": "4090343",
            "problem": "You are given discrete time series representing battery State of Charge (SoC) cycling profiles, along with physically meaningful parameters that allow mapping SoC variations to electrode stress. Your task is to compute the cumulative external energy throughput for each profile and estimate the cycle life by applying rainflow counting on the induced stress signal and a Wöhler-type fatigue model. The solution must be implemented as a complete, runnable program.\n\nAssume the following physically grounded base definitions and laws:\n\n- Energy conservation: Stored energy change in a battery over a time step is proportional to the change in State of Charge. If the nominal energy capacity is $C_{\\mathrm{Wh}}$ in watt-hours (Wh), and the SoC changes by $\\Delta s$, then the internal energy change is $C_{\\mathrm{Wh}} \\,\\Delta s$ in $\\mathrm{Wh}$.\n\n- External energy throughput accounts for charge and discharge conversion efficiencies. For a time step $k$ with SoC change $\\Delta s_k$, charging ($\\Delta s_k \\gt 0$) requires external energy $C_{\\mathrm{Wh}} \\,\\Delta s_k / \\eta_c$, while discharging ($\\Delta s_k \\lt 0$) yields external energy $C_{\\mathrm{Wh}} \\,|\\Delta s_k| \\,\\eta_d$. Here $\\eta_c$ and $\\eta_d$ are the charge and discharge efficiencies, respectively, each a dimensionless number in $(0,1]$.\n\n- Stress-number of cycles (S–N) Wöhler-type fatigue model: If the stress amplitude for cycle $i$ is $\\Delta \\sigma_i$, the cycles to failure at that amplitude are $N_i = N_{\\mathrm{ref}}\\left(\\dfrac{\\Delta \\sigma_{\\mathrm{ref}}}{\\Delta \\sigma_i}\\right)^m$, where $N_{\\mathrm{ref}}$ is the cycles to failure at reference stress amplitude $\\Delta \\sigma_{\\mathrm{ref}}$, and $m$ is the Basquin exponent. The per-cycle damage is $d_i = \\dfrac{1}{N_i} = \\dfrac{1}{N_{\\mathrm{ref}}}\\left(\\dfrac{\\Delta \\sigma_i}{\\Delta \\sigma_{\\mathrm{ref}}}\\right)^m$.\n\n- Miner's linear damage accumulation rule: The total damage over a profile is $D_{\\mathrm{profile}} = \\sum_i \\alpha_i \\, d_i$, where $\\alpha_i$ is the cycle count weight ($\\alpha_i = 1$ for a full cycle and $\\alpha_i = \\tfrac{1}{2}$ for a half cycle). The predicted number of repeats of the given profile to failure (cycle life for this repeated use) is $R^\\star = \\dfrac{1}{D_{\\mathrm{profile}}}$.\n\n- Mapping SoC to stress: Use a linear mapping for the electrode stress signal $\\sigma(t)$ from SoC, $\\sigma(t) = k_\\sigma \\, s(t)$, where $k_\\sigma$ has units $\\mathrm{MPa}$ per unit SoC and $s(t)$ is dimensionless. This ensures the stress amplitude for a counted cycle is $\\Delta \\sigma = k_\\sigma \\, \\Delta s$.\n\nThe rainflow counting must be performed on the discrete stress signal $\\{\\sigma_k\\}$ obtained from the SoC samples $\\{s_k\\}$. Use an algorithm that:\n- Extracts turning points (local extrema) from $\\{\\sigma_k\\}$ to form a sequence of reversals.\n- Iteratively applies the rainflow counting rules to identify full and half cycles and their amplitudes $\\Delta \\sigma_i$.\n- Produces a set of cycles with amplitudes and weights $\\alpha_i \\in \\{1,\\tfrac{1}{2}\\}$.\n\nFor each test case, compute:\n- The cumulative external energy throughput in $\\mathrm{Wh}$ over the provided profile (sum of external charge and discharge energy magnitudes).\n- The total damage $D_{\\mathrm{profile}}$ over the profile.\n- The predicted repeats to failure $R^\\star = \\dfrac{1}{D_{\\mathrm{profile}}}$, dimensionless. If $D_{\\mathrm{profile}} = 0$, define $R^\\star = +\\infty$.\n- The energy throughput to failure $E_{\\mathrm{TTF}} = R^\\star \\times E_{\\mathrm{throughput}}$, expressed in $\\mathrm{Wh}$. If $R^\\star = +\\infty$, define $E_{\\mathrm{TTF}} = +\\infty$.\n\nExpress all energy values in $\\mathrm{Wh}$, and produce dimensionless quantities without units. Angles are not involved, and no angle unit is required.\n\nUse the following Test Suite of parameter sets. Each test case is defined by a tuple $(\\{s_k\\}, \\Delta t, C_{\\mathrm{Wh}}, \\eta_c, \\eta_d, k_\\sigma, \\Delta \\sigma_{\\mathrm{ref}}, N_{\\mathrm{ref}}, m)$:\n- Test Case $1$ (happy path, mixed amplitudes):\n  - $\\{s_k\\} = [\\,0.50,\\,0.65,\\,0.40,\\,0.75,\\,0.35,\\,0.80,\\,0.45,\\,0.60\\,]$\n  - $\\Delta t = 600\\,\\mathrm{s}$\n  - $C_{\\mathrm{Wh}} = 10000$\n  - $\\eta_c = 0.96$\n  - $\\eta_d = 0.96$\n  - $k_\\sigma = 80\\,\\mathrm{MPa}$\n  - $\\Delta \\sigma_{\\mathrm{ref}} = 32\\,\\mathrm{MPa}$\n  - $N_{\\mathrm{ref}} = 12000$\n  - $m = 3.2$\n- Test Case $2$ (boundary, monotonic increase causing only half cycles):\n  - $\\{s_k\\} = [\\,0.50,\\,0.55,\\,0.60,\\,0.65,\\,0.70\\,]$\n  - $\\Delta t = 900\\,\\mathrm{s}$\n  - $C_{\\mathrm{Wh}} = 10000$\n  - $\\eta_c = 0.96$\n  - $\\eta_d = 0.96$\n  - $k_\\sigma = 80\\,\\mathrm{MPa}$\n  - $\\Delta \\sigma_{\\mathrm{ref}} = 32\\,\\mathrm{MPa}$\n  - $N_{\\mathrm{ref}} = 12000$\n  - $m = 3.2$\n- Test Case $3$ (edge case with mixed half and full cycles):\n  - $\\{s_k\\} = [\\,0.20,\\,0.60,\\,0.30,\\,0.55,\\,0.25\\,]$\n  - $\\Delta t = 300\\,\\mathrm{s}$\n  - $C_{\\mathrm{Wh}} = 10000$\n  - $\\eta_c = 0.96$\n  - $\\eta_d = 0.96$\n  - $k_\\sigma = 80\\,\\mathrm{MPa}$\n  - $\\Delta \\sigma_{\\mathrm{ref}} = 32\\,\\mathrm{MPa}$\n  - $N_{\\mathrm{ref}} = 12000$\n  - $m = 3.2$\n- Test Case $4$ (high-stress swings):\n  - $\\{s_k\\} = [\\,0.10,\\,0.90,\\,0.20,\\,0.85,\\,0.30,\\,0.80\\,]$\n  - $\\Delta t = 1200\\,\\mathrm{s}$\n  - $C_{\\mathrm{Wh}} = 10000$\n  - $\\eta_c = 0.96$\n  - $\\eta_d = 0.96$\n  - $k_\\sigma = 80\\,\\mathrm{MPa}$\n  - $\\Delta \\sigma_{\\mathrm{ref}} = 32\\,\\mathrm{MPa}$\n  - $N_{\\mathrm{ref}} = 12000$\n  - $m = 3.2$\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case result is itself a list in the form $[E_{\\mathrm{throughput}}, D_{\\mathrm{profile}}, R^\\star, E_{\\mathrm{TTF}}]$. For example, the final output should look like $[[x_1,y_1,z_1,w_1],[x_2,y_2,z_2,w_2],[x_3,y_3,z_3,w_3],[x_4,y_4,z_4,w_4]]$ with numeric values replacing the placeholders.",
            "solution": "The task requires integrating foundational electrochemical energy accounting with mechanical fatigue analysis. The derivation proceeds from first principles.\n\nStart with the energy conservation principle for a battery. Let the nominal energy capacity be $C_{\\mathrm{Wh}}$ in watt-hours. The State of Charge sequence is $\\{s_k\\}$, dimensionless and bounded in $[0,1]$. The internal energy change over a discrete step $k$ is $\\Delta E_{\\mathrm{int},k} = C_{\\mathrm{Wh}} \\,\\Delta s_k$, with $\\Delta s_k = s_{k+1} - s_k$. External energy accounting incorporates efficiency. For charging steps ($\\Delta s_k > 0$), the required external energy input is $E_{\\mathrm{ext},k}^{\\mathrm{in}} = \\dfrac{C_{\\mathrm{Wh}} \\,\\Delta s_k}{\\eta_c}$. For discharging steps ($\\Delta s_k  0$), the external energy output is $E_{\\mathrm{ext},k}^{\\mathrm{out}} = C_{\\mathrm{Wh}} \\,|\\Delta s_k| \\,\\eta_d$. The cumulative external energy throughput, defined as the sum of magnitudes of external energy flows, is\n$$\nE_{\\mathrm{throughput}} = \\sum_{k=0}^{K-2}\n\\begin{cases}\n\\dfrac{C_{\\mathrm{Wh}} \\,\\Delta s_k}{\\eta_c},  \\Delta s_k > 0 \\\\[6pt]\nC_{\\mathrm{Wh}} \\,(-\\Delta s_k)\\,\\eta_d,  \\Delta s_k  0 \\\\[6pt]\n0,  \\Delta s_k = 0\n\\end{cases}\n$$\nThis quantity is expressed in $\\mathrm{Wh}$.\n\nNext, map the SoC signal to electrode stress using the linear model $\\sigma_k = k_\\sigma \\, s_k$, where $k_\\sigma$ has units $\\mathrm{MPa}$ per unit SoC. This mapping reflects a proportional relationship between lithiation state and mechanical stress, which is consistent with small-strain approximations in active materials. The stress sequence $\\{\\sigma_k\\}$ is then analyzed using rainflow counting to extract cycle amplitudes. The rainflow algorithm operates on the sequence of turning points (reversals) and applies a stack-based comparison of adjacent ranges to identify closed cycles. For three consecutive reversals $\\sigma_{a}, \\sigma_{b}, \\sigma_{c}$, define ranges $R_1 = |\\sigma_b - \\sigma_a|$ and $R_2 = |\\sigma_c - \\sigma_b|$. If $R_1 \\le R_2$, a cycle with amplitude $\\Delta \\sigma = R_1$ is counted; the algorithm then removes the middle points and continues. At the end of the traversal, residual adjacent pairs on the stack represent half cycles. Each counted element is associated with a weight $\\alpha_i = 1$ for full cycles and $\\alpha_i = \\tfrac{1}{2}$ for half cycles.\n\nWith the set of cycle amplitudes $\\{\\Delta \\sigma_i\\}$ and weights $\\{\\alpha_i\\}$, apply the Wöhler-type fatigue model. The cycles to failure at amplitude $\\Delta \\sigma_i$ is\n$$\nN_i = N_{\\mathrm{ref}}\\left(\\dfrac{\\Delta \\sigma_{\\mathrm{ref}}}{\\Delta \\sigma_i}\\right)^m,\n$$\nwith $N_{\\mathrm{ref}}$ the cycles to failure at the reference stress amplitude $\\Delta \\sigma_{\\mathrm{ref}}$, and $m$ the Basquin exponent. The damage for cycle $i$ is\n$$\nd_i = \\dfrac{1}{N_i} = \\dfrac{1}{N_{\\mathrm{ref}}}\\left(\\dfrac{\\Delta \\sigma_i}{\\Delta \\sigma_{\\mathrm{ref}}}\\right)^m.\n$$\nBy Miner's rule, the total damage over the profile is\n$$\nD_{\\mathrm{profile}} = \\sum_i \\alpha_i \\, d_i = \\sum_i \\alpha_i \\, \\dfrac{1}{N_{\\mathrm{ref}}}\\left(\\dfrac{\\Delta \\sigma_i}{\\Delta \\sigma_{\\mathrm{ref}}}\\right)^m.\n$$\nIf no cycles are detected or all amplitudes are zero, then $D_{\\mathrm{profile}} = 0$. The predicted number of repeats to failure is\n$$\nR^\\star = \\begin{cases}\n\\dfrac{1}{D_{\\mathrm{profile}}},  D_{\\mathrm{profile}} > 0 \\\\[6pt]\n+\\infty,  D_{\\mathrm{profile}} = 0\n\\end{cases}\n$$\nThe energy throughput to failure is the cumulative throughput of the profile scaled by the number of repeats:\n$$\nE_{\\mathrm{TTF}} = R^\\star \\times E_{\\mathrm{throughput}}.\n$$\nIf $R^\\star = +\\infty$, then $E_{\\mathrm{TTF}} = +\\infty$.\n\nAlgorithmic design:\n\n- Compute $E_{\\mathrm{throughput}}$ directly from $\\{s_k\\}$, $C_{\\mathrm{Wh}}$, $\\eta_c$, and $\\eta_d$ using the piecewise sum above.\n\n- Generate the stress sequence $\\sigma_k = k_\\sigma \\, s_k$.\n\n- Extract reversals: include the first and last points, and any intermediate point $\\sigma_i$ that satisfies $(\\sigma_i - \\sigma_{i-1})(\\sigma_{i+1} - \\sigma_i) \\le 0$ with inequality strict when adjacent values differ. Remove consecutive duplicates to avoid zero-length ranges.\n\n- Apply the stack-based rainflow algorithm:\n  - Initialize an empty stack.\n  - For each reversal value, push onto the stack and, while there are at least three points, compare the last two ranges. If the earlier range is less than or equal to the later, count a full cycle of amplitude equal to the earlier range and remove the two earlier points from the stack; otherwise stop the inner loop.\n  - After processing all reversals, count half cycles for each remaining adjacent pair on the stack with amplitude equal to the pair’s range.\n\n- Compute $D_{\\mathrm{profile}}$ via the Wöhler model for each cycle amplitude, applying $\\alpha_i$ weights.\n\n- Compute $R^\\star$ and $E_{\\mathrm{TTF}}$.\n\nThis approach respects conservation of energy in throughput computation and uses a well-tested fatigue model (the stress-number of cycles Wöhler relation) combined with rainflow counting, a standard method for transforming variable-amplitude load histories into a set of damaging cycles. The program applies this procedure to the four test cases and outputs the requested list-of-lists, with energy values in $\\mathrm{Wh}$ and dimensionless damage and repeats.",
            "answer": "```python\nimport numpy as np\n\ndef extract_reversals(series: np.ndarray) - np.ndarray:\n    \"\"\"\n    Extract turning points (reversals) from a numeric sequence.\n    Includes first and last points. Removes consecutive duplicates.\n    \"\"\"\n    if len(series) == 0:\n        return np.array([])\n    # Remove consecutive duplicates\n    s = [series[0]]\n    for x in series[1:]:\n        if x != s[-1]:\n            s.append(x)\n    s = np.array(s, dtype=float)\n    if len(s) == 1:\n        return s.copy()\n\n    rev = [s[0]]\n    for i in range(1, len(s) - 1):\n        prev = s[i - 1]\n        curr = s[i]\n        nxt = s[i + 1]\n        # reversal if direction changes or plateau transitions\n        if (curr - prev) * (nxt - curr) = 0:\n            if not (curr == prev and curr == nxt):\n                rev.append(curr)\n    rev.append(s[-1])\n    # Remove consecutive duplicates in reversals\n    clean = [rev[0]]\n    for x in rev[1:]:\n        if x != clean[-1]:\n            clean.append(x)\n    return np.array(clean, dtype=float)\n\ndef rainflow_ranges(series: np.ndarray):\n    \"\"\"\n    Perform rainflow counting on a sequence of stress values.\n    Returns a list of tuples (amplitude, weight) where weight is 1.0 for full cycle\n    and 0.5 for half cycle.\n    \"\"\"\n    rev = extract_reversals(series)\n    cycles = []\n    stack = []\n    for x in rev:\n        stack.append(x)\n        # While at least 3 reversals, compare ranges\n        while len(stack) = 3:\n            s0 = stack[-3]\n            s1 = stack[-2]\n            s2 = stack[-1]\n            r1 = abs(s1 - s0)\n            r2 = abs(s2 - s1)\n            if r1 = r2:\n                # Count a full cycle of amplitude r1\n                if r1 > 0.0:\n                    cycles.append((r1, 1.0))\n                # Remove middle two: first remove s1 (index -2), then s0 (now at index -2)\n                stack.pop(-2)\n                stack.pop(-2)\n            else:\n                break\n    # Remaining adjacent pairs are half cycles\n    for i in range(len(stack) - 1):\n        r = abs(stack[i + 1] - stack[i])\n        if r > 0.0:\n            cycles.append((r, 0.5))\n    return cycles\n\ndef compute_throughput_wh(soc: np.ndarray, C_wh: float, eta_c: float, eta_d: float) - float:\n    \"\"\"\n    Compute cumulative external energy throughput in Wh from an SoC sequence.\n    Charging steps: external energy in = C_wh * delta_soc / eta_c\n    Discharging steps: external energy out = C_wh * (-delta_soc) * eta_d\n    \"\"\"\n    throughput = 0.0\n    for i in range(len(soc) - 1):\n        ds = soc[i + 1] - soc[i]\n        if ds > 0:\n            throughput += C_wh * ds / eta_c\n        elif ds  0:\n            throughput += C_wh * (-ds) * eta_d\n        # ds == 0 contributes nothing\n    return throughput\n\ndef fatigue_damage_profile(soc: np.ndarray, k_sigma: float, sigma_ref: float,\n                           N_ref: float, m: float) - float:\n    \"\"\"\n    Map SoC to stress, apply rainflow counting, and compute total damage per profile.\n    Damage per cycle: d_i = (1/N_ref) * (Delta_sigma_i / sigma_ref)^m\n    \"\"\"\n    sigma = k_sigma * soc\n    cycles = rainflow_ranges(sigma)\n    D = 0.0\n    for amp, weight in cycles:\n        if amp = 0.0:\n            continue\n        # Damage contribution\n        D += weight * (amp / sigma_ref) ** m / N_ref\n    return D\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case: (soc_list, dt_seconds, C_wh, eta_c, eta_d, k_sigma, sigma_ref, N_ref, m)\n    test_cases = [\n        ([0.50, 0.65, 0.40, 0.75, 0.35, 0.80, 0.45, 0.60], 600, 10000.0, 0.96, 0.96, 80.0, 32.0, 12000.0, 3.2),\n        ([0.50, 0.55, 0.60, 0.65, 0.70], 900, 10000.0, 0.96, 0.96, 80.0, 32.0, 12000.0, 3.2),\n        ([0.20, 0.60, 0.30, 0.55, 0.25], 300, 10000.0, 0.96, 0.96, 80.0, 32.0, 12000.0, 3.2),\n        ([0.10, 0.90, 0.20, 0.85, 0.30, 0.80], 1200, 10000.0, 0.96, 0.96, 80.0, 32.0, 12000.0, 3.2),\n    ]\n\n    results = []\n    for case in test_cases:\n        soc_list, dt, C_wh, eta_c, eta_d, k_sigma, sigma_ref, N_ref, m = case\n        soc = np.array(soc_list, dtype=float)\n\n        # Energy throughput in Wh\n        E_throughput = compute_throughput_wh(soc, C_wh, eta_c, eta_d)\n\n        # Damage per profile\n        D_profile = fatigue_damage_profile(soc, k_sigma, sigma_ref, N_ref, m)\n\n        # Repeats to failure\n        if D_profile > 0.0:\n            R_star = 1.0 / D_profile\n            E_ttf = R_star * E_throughput\n        else:\n            R_star = float('inf')\n            E_ttf = float('inf')\n\n        results.append([E_throughput, D_profile, R_star, E_ttf])\n\n    # Final print statement in the exact required format.\n    # Produce a single line with the list-of-lists.\n    print(f\"[{','.join([str(r) for r in results])}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}