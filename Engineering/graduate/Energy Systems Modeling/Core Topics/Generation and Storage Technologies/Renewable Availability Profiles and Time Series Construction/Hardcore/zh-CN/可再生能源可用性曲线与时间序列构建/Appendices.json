{
    "hands_on_practices": [
        {
            "introduction": "在能源系统建模中，时间序列数据是基础。然而，时间戳这个看似简单的细节，可能隐藏着关于数据生成方式的关键信息。本练习探讨了区间平均值数据与瞬时时间点样本之间的差异，并强调了如果误解这种区别，在计算总能量或容量因子等聚合量时，会如何导致显著的偏差。通过分析不同的时间戳约定，你将培养对确保数据完整性和构建精确可靠的能源模型至关重要的批判性思维能力。",
            "id": "4115881",
            "problem": "一位能源系统建模者需要根据长度为 $T$ 的时间范围内、每小时可用率的时间序列，计算风力或光伏（PV）发电厂的年度容量因子。该时间范围被划分为 $N$ 个等宽的区间，宽度为 $\\Delta t = T/N$。令 $a(t) \\in [0,1]$ 表示底层的连续可用率分数，$P_{\\mathrm{rated}}$ 表示额定功率，因此物理功率为 $P(t) = P_{\\mathrm{rated}} a(t)$。三家数据提供商为相同的底层过程和完全覆盖该时间范围的同一组不相交、连续的区间，提供了具有不同时间戳约定的时间序列：\n- 提供商 $A$：值以区间结束时间 $t_k$ 标记；每个报告值等于区间 $(t_{k-1}, t_k]$ 上的区间平均可用率。\n- 提供商 $B$：值以区间起始时间 $t_{k-1}$ 标记；每个报告值等于区间 $[t_{k-1}, t_k)$ 上的区间平均可用率。\n- 提供商 $C$：值以中心时间 $(t_{k-1} + t_k)/2$ 标记；每个报告值等于区间 $[t_{k-1}, t_k)$ 中心的瞬时可用率。\n\n该建模者通过对报告的序列进行离散求和，并用 $P_{\\mathrm{rated}}$ 和 $T$ 进行归一化，来估算容量因子。假设 $a(t)$ 在 $[0,T]$ 上是连续的，且具有有界导数。\n\n哪种说法最能描述时间戳约定对计算出的容量因子的影响，并规定了一种能避免偏差的一致性约定？\n\nA. 如果报告值是区间平均值，以半开区间形式平铺 $[0,T]$，并且没有边界区间被丢弃或重复，那么容量因子估计值对于时间戳表示的是起始、结束还是中心是不变的。偏差主要产生于将区间平均值误解为点样本或对时间范围边界处理不当时。一个一致、无偏的约定是，存储半开区间 $[t_k, t_{k+1})$ 的区间平均可用率，用明确的区间语义在 $t_k$ 或 $t_{k+1}$ 标记时间戳，并通过区间能量总和除以 $P_{\\mathrm{rated}} T$ 来计算容量因子。如果只有点样本可用，则在 $[0,T]$ 上使用边界对齐的中点或梯形求积法。\n\nB. 区间起始时间戳会系统性地夸大风能和光伏的容量因子，因为可用率通常在每小时内增加；区间结束时间戳则消除了这种效应。因此，一个一致、无偏的约定是使用区间结束时间戳，并将值解释为瞬时值。\n\nC. 当容量因子通过对点样本使用矩形法则计算时，中心时间戳能保证对任何平滑的可用率曲线都实现零偏差；而起始和结束时间戳会产生大小相等、符号相反的一阶偏差，该偏差与局部时间导数成正比。因此，应始终在区间中心标记时间戳以消除偏差。\n\nD. 为避免重复计算，对于区间结束时间戳，应丢弃第一个报告值，并对其余 $N-1$ 个值求和；这能消除边界效应并确保容量因子无偏。\n\nE. 在任何解释下，时间戳的选择都无关紧要，因为对固定的 $N$ 个值的集合求和，其结果与重新标记无关；因此，容量因子不能依赖于起始、结束还是中心的约定，也不需要对边界进行特殊处理。",
            "solution": "该问题要求分析不同的时间序列时间戳和数据表示约定如何影响年度容量因子的计算。\n\n真实容量因子 $CF$ 定义为在周期 $T$ 内产生的总实际能量除以该周期内可能产生的最大能量。在数学上，它是可用率分数 $a(t)$ 的时间平均值：\n$$CF = \\frac{\\int_0^T P(t) \\, dt}{P_{\\mathrm{rated}} T} = \\frac{\\int_0^T P_{\\mathrm{rated}} a(t) \\, dt}{P_{\\mathrm{rated}} T} = \\frac{1}{T} \\int_0^T a(t) \\, dt$$\n\n时间范围 $[0, T]$ 被划分为 $N$ 个相等的区间，每个区间的宽度为 $\\Delta t = T/N$。第 $k$ 个区间可以表示为 $[t_{k-1}, t_k)$ 或 $(t_{k-1}, t_k]$，其中 $t_k = k \\Delta t$，对于 $k=0, 1, \\dots, N$。该积分可以表示为这些区间上的和：\n$$CF = \\frac{1}{T} \\sum_{k=1}^N \\int_{t_{k-1}}^{t_k} a(t) \\, dt$$\n\n建模者对容量因子的估计值 $\\widehat{CF}$ 是通过对所提供的时间序列值（我们称之为 $\\{v_k\\}_{k=1}^N$）进行离散求和得到的：\n$$\\widehat{CF} = \\frac{\\sum_{k=1}^N (v_k P_{\\mathrm{rated}}) \\Delta t}{P_{\\mathrm{rated}} T} = \\frac{\\Delta t}{T} \\sum_{k=1}^N v_k = \\frac{1}{N} \\sum_{k=1}^N v_k$$\n\n我们现在将为每个数据提供商分析估计值 $\\widehat{CF}$。\n\n**对提供商 A（区间末端平均值）和提供商 B（区间起始平均值）的分析：**\n\n两个提供商都提供作为区间平均值的值。\n对于提供商 A，值 $A_k$ 的时间戳在 $t_k$，代表在 $(t_{k-1}, t_k]$ 上的平均值。\n对于提供商 B，值 $B_k$ 的时间戳在 $t_{k-1}$，代表在 $[t_{k-1}, t_k)$ 上的平均值。\n\n在这两种情况下，第 $k$ 个区间的报告值是该区间上真实的平均可用率：\n$$v_k = \\frac{1}{\\Delta t} \\int_{t_{k-1}}^{t_k} a(\\tau) \\, d\\tau$$\n对于提供商 A 和提供商 B，报告值的集合 $\\{v_k\\}_{k=1}^N$ 是相同的；只是附加到这些值上的时间标签不同。\n\n估计的容量因子计算如下：\n$$\\widehat{CF} = \\frac{1}{N} \\sum_{k=1}^N v_k = \\frac{1}{N} \\sum_{k=1}^N \\left( \\frac{1}{\\Delta t} \\int_{t_{k-1}}^{t_k} a(\\tau) \\, d\\tau \\right)$$\n代入 $N = T / \\Delta t$：\n$$\\widehat{CF} = \\frac{\\Delta t}{T} \\frac{1}{\\Delta t} \\sum_{k=1}^N \\int_{t_{k-1}}^{t_k} a(\\tau) \\, d\\tau = \\frac{1}{T} \\sum_{k=1}^N \\int_{t_{k-1}}^{t_k} a(\\tau) \\, d\\tau$$\n根据积分的可加性，对平铺 $[0, T]$ 的不相交区间 $[t_{k-1}, t_k]$ 上的积分求和，等于在整个时间范围上的积分：\n$$\\widehat{CF} = \\frac{1}{T} \\int_0^T a(\\tau) \\, d\\tau = CF$$\n\n结论：如果数据由一套完整的、不重叠的、完美平铺时间范围的区间平均值组成，那么离散求和可以正确且精确地重建真实的容量因子。时间戳的选择（区间起始 vs. 区间末端）仅仅是一个标记约定，对计算值没有影响。偏差为零。\n\n**对提供商 C（中心瞬时值）的分析：**\n\n提供商 C 提供的值 $C_k$ 是每个区间中点 $t_{k,cen} = (t_{k-1} + t_k) / 2$ 的瞬时样本。\n$$C_k = a(t_{k,cen})$$\n估计的容量因子是：\n$$\\widehat{CF}_C = \\frac{1}{N} \\sum_{k=1}^N C_k = \\frac{1}{N} \\sum_{k=1}^N a(t_{k,cen})$$\n为了将其与真实的 $CF$ 进行比较，我们重写该表达式：\n$$\\widehat{CF}_C = \\frac{\\Delta t}{T} \\sum_{k=1}^N a(t_{k,cen})$$\n这个计算等同于使用数值积分的中点法则来近似真实积分 $\\int_0^T a(t) \\, dt$：\n$$\\int_0^T a(t) \\, dt \\approx \\sum_{k=1}^N a(t_{k,cen}) \\Delta t$$\n复合中点法则的误差在数值分析中是已知的。对于一个具有连续二阶导数的函数 $a(t)$，其误差为：\n$$\\int_0^T a(t) \\, dt - \\sum_{k=1}^N a(t_{k,cen}) \\Delta t = \\frac{T (\\Delta t)^2}{24} a''(\\xi)$$\n对于某个 $\\xi \\in (0, T)$。\n\n结论：来自提供商 C 数据的估计是一个近似值，而不是一个精确的计算。它是有偏差的，并且除非对所有 $t$ 都有 $a''(t) = 0$（即 $a(t)$ 是一个线性函数），否则偏差（误差）非零。\n\n**选项评估：**\n\n**A. 如果报告值是区间平均值，以半开区间形式平铺 $[0,T]$，并且没有边界区间被丢弃或重复，那么容量因子估计值对于时间戳表示的是起始、结束还是中心是不变的。偏差主要产生于将区间平均值误解为点样本或对时间范围边界处理不当时。一个一致、无偏的约定是，存储半开区间 $[t_k, t_{k+1})$ 的区间平均可用率，用明确的区间语义在 $t_k$ 或 $t_{k+1}$ 标记时间戳，并通过区间能量总和除以 $P_{\\mathrm{rated}} T$ 来计算容量因子。如果只有点样本可用，则在 $[0,T]$ 上使用边界对齐的中点或梯形求积法。**\n- 这个陈述与我们的分析完全一致。它正确地指出，对于区间平均数据（提供商 A 和 B），时间戳是一个标记问题，如果执行正确，计算是精确的（无偏的）。它指出了误差的真正来源：误解数据类型（例如，将平均值视为点样本）或不当处理求和域（边界效应）。为区间平均值规定的约定是数学上精确的方法。它还正确地建议对点样本使用数值积分。\n- **结论：正确。**\n\n**B. 区间起始时间戳会系统性地夸大风能和光伏的容量因子，因为可用率通常在每小时内增加；区间结束时间戳则消除了这种效应。因此，一个一致、无偏的约定是使用区间结束时间戳，并将值解释为瞬时值。**\n- 这个选项在多个方面存在缺陷。首先，可用率“通常在每小时内增加”的前提是一个薄弱且未经证实的概括。其次，它错误地分析了偏差。如果我们对一个递增函数使用区间起始的点样本，左黎曼和会*低估*（而不是夸大）积分。第三，它将区间平均数据（来自提供商 B）与点样本数据混为一谈。如上所示，对于区间平均值，没有偏差。最后，它建议误解数据（“将值解释为瞬时值”），这是误差的直接原因。\n- **结论：不正确。**\n\n**C. 当容量因子通过对点样本使用矩形法则计算时，中心时间戳能保证对任何平滑的可用率曲线都实现零偏差；而起始和结束时间戳会产生大小相等、符号相反的一阶偏差，该偏差与局部时间导数成正比。因此，应始终在区间中心标记时间戳以消除偏差。**\n- 中心时间戳（中点法则）“保证对任何平滑”曲线都实现零偏差的核心主张是错误的。如分析所示，误差与二阶导数 $a''(t)$ 成正比，并且对于任何非线性函数都是非零的。虽然中点法则通常比左手或右手法则更准确，但它通常不是精确的。\n- **结论：不正确。**\n\n**D. 为避免重复计算，对于区间结束时间戳，应丢弃第一个报告值，并对其余 $N-1$ 个值求和；这能消除边界效应并确保容量因子无偏。**\n- “重复计算”的前提是错误的。提供商 A 的区间数据 $(t_0, t_1], (t_1, t_2], \\dots, (t_{N-1}, t_N]$ 是完全不相交的，并且覆盖了整个时间范围。丢弃第一个值意味着忽略了在第一个区间 $(0, t_1]$ 内产生的能量，这会引入显著的偏差。这个建议是明显错误的。\n- **结论：不正确。**\n\n**E. 在任何解释下，时间戳的选择都无关紧要，因为对固定的 $N$ 个值的集合求和，其结果与重新标记无关；因此，容量因子不能依赖于起始、结束还是中心的约定，也不需要对边界进行特殊处理。**\n- “在任何解释下”这个短语是一个致命缺陷。对一个值的解释——是区间平均值还是点样本——是至关重要的。来自提供商 C 的值集（点样本）与来自 A 和 B 的值集（区间平均值）在根本上是不同的。“不需要对边界进行特殊处理”的说法也是错误且危险的，因为差一错误是常见且重要的偏差来源。这个陈述宣扬了一种危险的简单化观点。\n- **结论：不正确。**\n\n基于严谨的分析，只有选项 A 提供了对该问题的科学上合理且完整的描述。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "能源模型常常在不同的时间分辨率下运行，这要求对数据进行上采样或下采样。这个过程必须谨慎执行，以保持数据的物理完整性。本实践聚焦于重采样过程中的能量守恒原则。你将实现一种方法，其中通过平均实现从高分辨率到低分辨率（例如15分钟到小时）的降采样，而通过重复（零阶保持）实现升采样，从而确保总能量保持不变。这个动手编码练习为你提供了处理时间序列的核心技能，这对于任何处理多尺度数据的能源建模者来说都至关重要。",
            "id": "4115891",
            "problem": "您的任务是在能源系统建模的背景下，设计并实现一种用于15分钟可用性曲线和小时可用性曲线之间的能量守恒重采样和插值方案。考虑一个以千瓦 (kW) 为单位的功率时间序列，表示为函数 $P(t)$，其中 $t$ 是以小时为单位的时间。区间 $[a,b]$ 上的能量定义为 $E_{[a,b]} = \\int_a^b P(t)\\, dt$，单位为千瓦时 (kWh)。在离散时间下，对于均匀的采样间隔 $\\Delta t$，一个常见的建模假设是 $P(t)$ 在每个采样间隔上是分段常数。在此假设下，一系列区间上的能量由黎曼和给出：$E = \\sum_i P_i \\Delta t$，其中 $P_i$ 是区间 $i$ 上的恒定功率。\n\n您的程序必须构建一个方案，在以下转换中保持能量守恒（即功率对时间的积分）：\n- 从15分钟（$\\Delta t = 0.25$ 小时）到小时（$\\Delta t = 1$ 小时），以及\n- 从小时到15分钟。\n\n您必须遵守以下科学约束：\n- 从15分钟降采样到小时必须产生一个小时时间序列 $\\{\\hat{P}_h\\}$，其中每个 $\\hat{P}_h$ 是小时平均功率，使得小时能量等于该小时内各15分钟能量之和。\n- 从小时升采样到15分钟必须产生一个15分钟时间序列 $\\{p_{h,j}\\}$（每小时 $j=1,\\dots,4$），使得每小时的能量得以保持。\n\n定义和要求：\n- 令 $P_k$ 表示15分钟功率样本（单位：kW），其中 $k$ 索引一天中的各个15分钟（共 $96$ 个样本）。\n- 令 $\\hat{P}_h$ 表示小时功率样本（单位：kW），其中 $h$ 索引一天中的各个小时（共 $24$ 个样本）。\n- 15分钟能量为 $E_{\\text{15min}} = \\sum_{k=0}^{95} P_k \\cdot 0.25$（单位：kWh）。\n- 小时能量为 $E_{\\text{hour}} = \\sum_{h=0}^{23} \\hat{P}_h \\cdot 1$（单位：kWh）。\n- 任何三角函数中使用的角度必须以弧度为单位。\n\n您的程序必须实现：\n1. 一个函数，输入一个15分钟序列 $\\{P_k\\}$，返回小时序列 $\\{\\hat{P}_h\\}$，使得从 $15$ 分钟聚合到 $1$ 小时时能量守恒。\n2. 一个函数，输入一个小时序列 $\\{\\hat{P}_h\\}$，返回一个15分钟序列 $\\{p_{h,j}\\}$，使得从 $1$ 小时分解到 $15$ 分钟时能量守恒。\n\n测试套件：\n实现以下测试用例以验证能量守恒。对于每个用例，计算原始序列与经过一次应保持能量守恒的往返转换后得到的序列之间的总能量绝对差（单位：kWh）。每个测试用例应产生一个浮点数（单位：kWh）。您的最终输出必须是单行文本，其中包含所有结果，格式为逗号分隔的列表并用方括号括起。\n\n15分钟到小时再到15分钟（15→60→15）：\n- 测试 $1$（类太阳能15分钟曲线）：令 $P_{\\max} = 100$ (kW)。对于 $t_k = k \\cdot 0.25$，其中 $k \\in \\{0,1,\\dots,95\\}$，定义 $P_k = \\max\\{0, P_{\\max} \\cdot \\sin\\left(\\pi \\cdot \\frac{t_k - 6}{12}\\right)\\}$，适用于 $t_k \\in [0,24)$，角度以弧度为单位。\n- 测试 $2$（单小时线性斜坡15分钟曲线）：在第 $8$ 小时到第 $9$ 小时之间定义一个从 $0$ (kW) 到 $80$ (kW) 的线性斜坡。使用 $[8,9)$ 小时内每个15分钟子区间的中点来表示每个子区间的平均功率 $P_k$，从而在 $[8,9)$ 内得到 $10, 30, 50, 70$ (kW) 的15分钟值；其他地方 $P_k = 0$ (kW)。\n- 测试 $3$（恒定15分钟曲线）：对于所有 $k$，$P_k = 50$ (kW)。\n- 测试 $4$（确定性伪随机15分钟曲线）：使用固定的种子生成 $96$ 个在 $[0,100]$ (kW) 区间内均匀分布的确定性样本。\n\n小时到15分钟再到小时（60→15→60）：\n- 测试 $5$（三角形小时曲线）：对于 $h \\in \\{0,1,\\dots,23\\}$，定义 $\\hat{P}_h = \\max\\{0, 100 \\cdot (1 - |h - 12|/6)\\}$ (kW)。\n- 测试 $6$（尖峰小时曲线）：对于 $h \\in \\{0,1,\\dots,23\\}$，如果 $h$ 是偶数，则定义 $\\hat{P}_h = 100$ (kW)；如果 $h$ 是奇数，则 $\\hat{P}_h = 0$ (kW)。\n\n单位要求：\n- 所有功率值必须解释为千瓦 (kW)。\n- 所有能量值必须以千瓦时 (kWh) 计算和报告。\n- 所有用于三角函数的角度必须以弧度为单位。\n- 程序必须计算往返转换的总能量绝对差，并以 kWh 为单位报告。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个由逗号分隔并用方括号括起来的结果列表，按顺序包含 $6$ 个测试的结果。例如，格式必须是 $[r_1,r_2,r_3,r_4,r_5,r_6]$，其中每个 $r_i$ 是一个浮点数（单位：kWh）。",
            "solution": "该问题要求为15分钟和小时分辨率之间的功率时间序列设计并实现一种能量守恒的重采样方案。核心原则是能量守恒，其定义为功率对时间的积分 $E = \\int P(t) dt$。对于在时长为 $\\Delta t$ 的采样间隔上功率被假定为分段常数的离散时间序列，该积分变为一个和式：$E = \\sum_i P_i \\Delta t$。\n\n首先，我们为所需的两个转换函数建立数学形式。\n\n**1. 降采样：15分钟到小时（15-min → 60-min）**\n\n令 $\\{P_k\\}_{k=0}^{95}$ 为时间步长 $\\Delta t_{15} = 0.25$ 小时的15分钟功率序列。令 $\\{\\hat{P}_h\\}_{h=0}^{23}$ 为相应的时间步长 $\\Delta t_{60} = 1.0$ 小时的小时功率序列。\n\n能量守恒约束要求在任何给定小时内计算的能量是相同的，无论使用何种分辨率。对于任意小时 $h$（其中 $h \\in \\{0, 1, \\dots, 23\\}$），根据小时序列计算的能量为：\n$$E_{h, \\text{hourly}} = \\hat{P}_h \\cdot \\Delta t_{60} = \\hat{P}_h \\cdot 1$$\n\n同一个小时 $h$ 对应四个15分钟间隔，其索引为 $k = 4h, 4h+1, 4h+2$ 和 $4h+3$。根据15分钟序列计算的该小时内的总能量是这四个间隔能量的总和：\n$$E_{h, \\text{15min}} = \\sum_{j=0}^{3} P_{4h+j} \\cdot \\Delta t_{15} = \\left( P_{4h} + P_{4h+1} + P_{4h+2} + P_{4h+3} \\right) \\cdot 0.25$$\n\n令两个能量表达式相等（$E_{h, \\text{hourly}} = E_{h, \\text{15min}}$），可得出确定小时功率值 $\\hat{P}_h$ 的规则：\n$$\\hat{P}_h \\cdot 1 = \\left( P_{4h} + P_{4h+1} + P_{4h+2} + P_{4h+3} \\right) \\cdot 0.25$$\n$$\\hat{P}_h = \\frac{P_{4h} + P_{4h+1} + P_{4h+2} + P_{4h+3}}{4}$$\n\n这表明，能量守恒的降采样操作等同于取每小时内四个15分钟功率值的算术平均值。\n\n**2. 升采样：小时到15分钟（60-min → 15-min）**\n\n令 $\\{\\hat{P}_h\\}_{h=0}^{23}$ 为小时功率序列。我们需要确定一个15分钟序列 $\\{P_k\\}_{k=0}^{95}$，该序列在每小时都保持能量守恒。小时 $h$ 的能量守恒方程与之前相同：\n$$\\hat{P}_h = \\frac{1}{4} \\sum_{j=0}^{3} P_{4h+j}$$\n\n对于每个小时 $h$，这是一个包含四个未知数 $\\{P_{4h}, P_{4h+1}, P_{4h+2}, P_{4h+3}\\}$ 的单线性方程。这是一个欠定系统，存在无限多解。为了选择一个唯一解，需要一个额外的假设。问题从一开始就指出，功率 $P(t)$ 在每个采样间隔上被建模为分段常数。对于升采样，最简单且最一致的选择是扩展此假设，假定小时功率值 $\\hat{P}_h$ 代表整个小时内的恒定功率水平。这引出以下规则：\n$$P_k = \\hat{P}_{\\lfloor k/4 \\rfloor}$$\n换句话说，给定小时内的所有四个15分钟功率值都设置为该小时的功率值：\n$$P_{4h} = P_{4h+1} = P_{4h+2} = P_{4h+3} = \\hat{P}_h$$\n这种选择满足能量守恒约束，因为 $\\frac{1}{4}(\\hat{P}_h + \\hat{P}_h + \\hat{P}_h + \\hat{P}_h) = \\hat{P}_h$。此方法，也称为零阶保持或最近邻插值，是选定的升采样方案。\n\n**3. 往返能量守恒分析**\n\n问题要求计算往返转换后的总能量绝对差。\n\n**情况 A：15-min → 60-min → 15-min**\n- 初始15分钟序列 $\\{P_k\\}$ 被降采样为小时序列 $\\{\\hat{P}_h\\}$，其中 $\\hat{P}_h = \\frac{1}{4}\\sum_{j=0}^{3} P_{4h+j}$。\n- 然后该小时序列被升采样为一个新的15分钟序列 $\\{P'_k\\}$，其中 $P'_k = \\hat{P}_{\\lfloor k/4 \\rfloor}$。\n- 原始序列的总能量为 $E_{\\text{orig}} = \\Delta t_{15} \\sum_{k=0}^{95} P_k = 0.25 \\sum_{k=0}^{95} P_k$。\n- 重建序列的总能量为 $E_{\\text{recon}} = \\Delta t_{15} \\sum_{k=0}^{95} P'_k$。\n代入定义：\n$$E_{\\text{recon}} = 0.25 \\sum_{h=0}^{23} \\sum_{j=0}^{3} P'_{4h+j} = 0.25 \\sum_{h=0}^{23} \\sum_{j=0}^{3} \\hat{P}_h = 0.25 \\sum_{h=0}^{23} 4\\hat{P}_h = \\sum_{h=0}^{23} \\hat{P}_h$$\n现在，代入 $\\hat{P}_h$ 的公式：\n$$E_{\\text{recon}} = \\sum_{h=0}^{23} \\left( \\frac{1}{4}\\sum_{j=0}^{3} P_{4h+j} \\right) = 0.25 \\sum_{h=0}^{23} \\sum_{j=0}^{3} P_{4h+j} = 0.25 \\sum_{k=0}^{95} P_k = E_{\\text{orig}}$$\n因此，对于此往返过程，总能量在分析上是守恒的，绝对差 $|E_{\\text{orig}} - E_{\\text{recon}}|$ 为 $0$。\n\n**情况 B：60-min → 15-min → 60-min**\n- 初始小时序列 $\\{\\hat{P}_h\\}$ 被升采样为15分钟序列 $\\{P_k\\}$，其中 $P_k = \\hat{P}_{\\lfloor k/4 \\rfloor}$。\n- 然后该15分钟序列被降采样为一个新的小时序列 $\\{\\hat{P}'_h\\}$。\n$$\\hat{P}'_h = \\frac{1}{4}\\sum_{j=0}^{3} P_{4h+j} = \\frac{1}{4}\\left(\\hat{P}_h + \\hat{P}_h + \\hat{P}_h + \\hat{P}_h\\right) = \\hat{P}_h$$\n重建的小时序列 $\\{\\hat{P}'_h\\}$ 与原始序列 $\\{\\hat{P}_h\\}$ 完全相同。因此，它们的总能量 $E_{\\text{recon}} = \\sum \\hat{P}'_h \\cdot 1$ 和 $E_{\\text{orig}} = \\sum \\hat{P}_h \\cdot 1$ 是相同的。绝对差 $|E_{\\text{orig}} - E_{\\text{recon}}|$ 也为 $0$。\n\n实现将针对各种测试曲线计算这些差异。任何非零结果都将归因于浮点运算误差。",
            "answer": "```python\nimport numpy as np\n\ndef downsample_15_to_60(p_15min: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Downsamples a quarter-hour power series to an hourly series by averaging.\n    This preserves energy as per the derivation.\n    \"\"\"\n    if p_15min.shape != (96,):\n        raise ValueError(\"Input must be a numpy array of shape (96,).\")\n    # Reshape the 96-sample series into 24 hours of 4 quarter-hour samples\n    # and compute the mean for each hour.\n    return p_15min.reshape(24, 4).mean(axis=1)\n\ndef upsample_60_to_15(p_60min: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Upsamples an hourly power series to a quarter-hour series by repetition.\n    This preserves energy under the piecewise-constant power assumption.\n    \"\"\"\n    if p_60min.shape != (24,):\n        raise ValueError(\"Input must be a numpy array of shape (24,).\")\n    # Repeat each hourly value 4 times to create the quarter-hour series.\n    return p_60min.repeat(4)\n\ndef calculate_energy(power_series: np.ndarray, dt: float) -> float:\n    \"\"\"\n    Calculates the total energy for a time series with a given time step.\n    \"\"\"\n    return np.sum(power_series) * dt\n\ndef solve():\n    \"\"\"\n    Runs the test suite and computes the energy differences for round-trip conversions.\n    \"\"\"\n    results = []\n    \n    # --- Test Cases 1-4: 15-min -> 60-min -> 15-min ---\n\n    # Test 1: Solar-like quarter-hour profile\n    k = np.arange(96)\n    t_k = k * 0.25\n    p15_orig_1 = np.maximum(0, 100.0 * np.sin(np.pi * (t_k - 6.0) / 12.0))\n    \n    # Test 2: Single-hour linear ramp quarter-hour profile\n    p15_orig_2 = np.zeros(96)\n    p15_orig_2[32:36] = [10.0, 30.0, 50.0, 70.0]\n\n    # Test 3: Constant quarter-hour profile\n    p15_orig_3 = np.full(96, 50.0)\n\n    # Test 4: Deterministic pseudo-random quarter-hour profile\n    np.random.seed(42)\n    p15_orig_4 = np.random.uniform(0.0, 100.0, 96)\n\n    test_cases_15min = [p15_orig_1, p15_orig_2, p15_orig_3, p15_orig_4]\n\n    for p15_orig in test_cases_15min:\n        E_orig = calculate_energy(p15_orig, 0.25)\n        p60_resampled = downsample_15_to_60(p15_orig)\n        p15_recon = upsample_60_to_15(p60_resampled)\n        E_recon = calculate_energy(p15_recon, 0.25)\n        diff = np.abs(E_orig - E_recon)\n        results.append(diff)\n        \n    # --- Test Cases 5-6: 60-min -> 15-min -> 60-min ---\n\n    # Test 5: Triangular hourly profile\n    h = np.arange(24)\n    p60_orig_5 = np.maximum(0, 100.0 * (1.0 - np.abs(h - 12.0) / 6.0))\n\n    # Test 6: Spiky hourly profile\n    p60_orig_6 = 100.0 * (h % 2 == 0)\n\n    test_cases_60min = [p60_orig_5, p60_orig_6]\n\n    for p60_orig in test_cases_60min:\n        E_orig = calculate_energy(p60_orig, 1.0)\n        p15_resampled = upsample_60_to_15(p60_orig)\n        p60_recon = downsample_15_to_60(p15_resampled)\n        E_recon = calculate_energy(p60_recon, 1.0)\n        diff = np.abs(E_orig - E_recon)\n        results.append(diff)\n        \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "与风能和太阳能等间歇性可再生能源不同，潮汐能由于其引力起源而具有高度的可预测性。构建其可用性曲线需要一种基于谐波分析的不同方法。本练习将指导你通过叠加主要谐波分量来建立潮流速度时间序列。然后，你将应用流体速度与动能功率之间的物理关系，即功率与速度的立方成正比（$P \\propto |v|^3$），来生成功率可用性曲线。这项高级实践提供了一个从第一性原理生成可再生能源可用性曲线的完整工作流程，融合了物理学、海洋学和数值方法的概念，以创建一个可用于模型的时序数据。",
            "id": "4115872",
            "problem": "您的任务是利用谐波分析构建一个潮流可用性时间序列，并计算相应的动能通量时间序列。构建过程必须依据潮汐分量的标准表示方法以及移动流体的动能通量计算方法。从基本原理出发，使用以下科学上已确立的出发点：\n- 任何平稳的潮流信号都可以近似为一组有限谐波的总和。对于由 $j$ 索引的分量，每个谐波分量都由振幅 $A_j$（单位：$\\mathrm{m/s}$）、相位 $\\phi_j$（单位：弧度）和角频率 $\\omega_j$（单位：弧度/小时）来表征。沿固定轴向的速度建模为\n$$\nv(t) \\;=\\; \\sum_{j} A_j \\cos\\!\\big(\\omega_j t + \\phi_j\\big),\n$$\n其中 $t$ 是以小时为单位的时间。\n- 密度为 $\\rho$、速度为 $|v|$ 的流体流的单位面积动能通量为\n$$\nP(t) \\;=\\; \\tfrac{1}{2}\\,\\rho\\,|v(t)|^3,\n$$\n其中 $\\rho$ 的单位是 $\\mathrm{kg/m^3}$，$P(t)$ 的单位是 $\\mathrm{W/m^2}$。使用 $\\rho = 1025$ $\\mathrm{kg/m^3}$（海水，国际单位制 (SI)）。\n\n需要使用的谐波分量是主要太阴半日分潮（$\\mathrm{M2}$）、主要太阳半日分潮（$\\mathrm{S2}$）、太阴太阳日分潮（$\\mathrm{K1}$）和主要太阴日分潮（$\\mathrm{O1}$）。它们的以小时为单位的天文周期如下：\n- $\\mathrm{M2}$: $T_{\\mathrm{M2}} = 12.4206012$,\n- $\\mathrm{S2}$: $T_{\\mathrm{S2}} = 12.0$,\n- $\\mathrm{K1}$: $T_{\\mathrm{K1}} = 23.93447213$,\n- $\\mathrm{O1}$: $T_{\\mathrm{O1}} = 25.81934166$.\n\n对于每个分量，角频率计算如下：\n$$\n\\omega_j \\;=\\; \\frac{2\\pi}{T_j}\n\\quad\\text{(弧度/小时)}.\n$$\n\n将时间均匀离散化为：\n$$\nt_k \\;=\\; k\\,\\Delta t,\\quad k \\in \\{0,1,2,\\dots,N-1\\},\n$$\n其中 $\\Delta t$ 是以小时为单位的时间步长，$N \\;=\\; \\left\\lfloor \\dfrac{T}{\\Delta t} \\right\\rfloor$ 是在时间范围 $T$（小时）内的样本总数。使用离散时间算术平均值作为时间平均功率通量的估计量：\n$$\n\\overline{P} \\;=\\; \\frac{1}{N} \\sum_{k=0}^{N-1} P(t_k).\n$$\n\n角度单位：所有相位和角频率均以弧度为单位，$t$ 以小时为单位。速度单位必须是 $\\mathrm{m/s}$，功率通量必须以 $\\mathrm{W/m^2}$ 表示。您的程序必须为以下每个测试用例计算 $\\overline{P}$，并将每个结果以 $\\mathrm{W/m^2}$ 为单位表示，精确到小数点后 $6$ 位。\n\n使用以下包含四个案例的测试套件实现上述计算，每个案例由时间范围 $T$、时间步长 $\\Delta t$、振幅向量 $[A_{\\mathrm{M2}}, A_{\\mathrm{S2}}, A_{\\mathrm{K1}}, A_{\\mathrm{O1}}]$（单位：$\\mathrm{m/s}$）和相位向量 $[\\phi_{\\mathrm{M2}}, \\phi_{\\mathrm{S2}}, \\phi_{\\mathrm{K1}}, \\phi_{\\mathrm{O1}}]$（单位：弧度）指定：\n- 案例 A（两个大小潮周期内的一般多谐波情况）：\n  - $T = 336.0$, $\\Delta t = 0.25$,\n  - $[A_{\\mathrm{M2}}, A_{\\mathrm{S2}}, A_{\\mathrm{K1}}, A_{\\mathrm{O1}}] = [1.0, 0.35, 0.25, 0.15]$,\n  - $[\\phi_{\\mathrm{M2}}, \\phi_{\\mathrm{S2}}, \\phi_{\\mathrm{K1}}, \\phi_{\\mathrm{O1}}] = [0.4, -1.1, 1.6, -0.3]$.\n- 案例 B（周期为整数倍的单分量边界情况）：\n  - $T = 10 \\times 12.4206012$, $\\Delta t = 0.05$,\n  - $[A_{\\mathrm{M2}}, A_{\\mathrm{S2}}, A_{\\mathrm{K1}}, A_{\\mathrm{O1}}] = [1.5, 0.0, 0.0, 0.0]$,\n  - $[\\phi_{\\mathrm{M2}}, \\phi_{\\mathrm{S2}}, \\phi_{\\mathrm{K1}}, \\phi_{\\mathrm{O1}}] = [0.0, 0.0, 0.0, 0.0]$.\n- 案例 C（以全日潮为主且带相位偏移的情况）：\n  - $T = 168.0$, $\\Delta t = 0.2$,\n  - $[A_{\\mathrm{M2}}, A_{\\mathrm{S2}}, A_{\\mathrm{K1}}, A_{\\mathrm{O1}}] = [0.6, 0.3, 1.2, 0.8]$,\n  - $[\\phi_{\\mathrm{M2}}, \\phi_{\\mathrm{S2}}, \\phi_{\\mathrm{K1}}, \\phi_{\\mathrm{O1}}] = [\\pi/3, -\\pi/4, \\pi/2, -\\pi/6]$.\n- 案例 D（近零振幅以探测数值稳定性）：\n  - $T = 48.0$, $\\Delta t = 0.5$,\n  - $[A_{\\mathrm{M2}}, A_{\\mathrm{S2}}, A_{\\mathrm{K1}}, A_{\\mathrm{O1}}] = [0.01, 0.01, 0.01, 0.01]$,\n  - $[\\phi_{\\mathrm{M2}}, \\phi_{\\mathrm{S2}}, \\phi_{\\mathrm{K1}}, \\phi_{\\mathrm{O1}}] = [0.0, 0.0, 0.0, 0.0]$.\n\n您的程序应：\n- 使用指定的 $\\mathrm{M2}$、$\\mathrm{S2}$、$\\mathrm{K1}$、$\\mathrm{O1}$ 周期来构建 $\\omega_j$，\n- 为每个案例在均匀网格上构建 $v(t_k)$，\n- 使用 $\\rho = 1025$ $\\mathrm{kg/m^3}$ 计算 $P(t_k) = \\tfrac{1}{2}\\rho |v(t_k)|^3$，\n- 为每个案例计算 $\\overline{P}$ 并精确到小数点后 $6$ 位。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序为 $\\big[\\overline{P}_{\\mathrm{A}}, \\overline{P}_{\\mathrm{B}}, \\overline{P}_{\\mathrm{C}}, \\overline{P}_{\\mathrm{D}}\\big]$。例如，格式必须与 $\\big[1.234000,5.678900,2.500000,0.000001\\big]$ 完全一致，每个条目的单位为 $\\mathrm{W/m^2}$。",
            "solution": "该问题是有效的，因为它具有科学依据、提法得当、客观，并为一项直接的计算任务提供了一套完整、一致的规范。解决方案要求构建一个潮流速度时间序列，并随后计算平均动能通量。该过程遵循谐波分析和流体动力学的既定原理。\n\n基本原理是，一个平稳的潮流信号可以表示为有限数量谐波分量的叠加。在时间 $t$（小时），沿固定轴的速度 $v(t)$ 由以下总和给出：\n$$\nv(t) = \\sum_{j} A_j \\cos(\\omega_j t + \\phi_j)\n$$\n在此，j 索引潮汐分量（$\\mathrm{M2}$、$\\mathrm{S2}$、$\\mathrm{K1}$、$\\mathrm{O1}$）。对于每个分量 $j$，$A_j$ 是速度振幅（单位：$\\mathrm{m/s}$），$\\phi_j$ 是相位偏移（单位：弧度），$\\omega_j$ 是角频率（单位：弧度/小时）。\n\n角频率 $\\omega_j$ 从每个分量的天文周期 $T_j$ 导出，使用关系式：\n$$\n\\omega_j = \\frac{2\\pi}{T_j}\n$$\n四个指定分量的周期作为常量给出：\n- $T_{\\mathrm{M2}} = 12.4206012$ 小时\n- $T_{\\mathrm{S2}} = 12.0$ 小时\n- $T_{\\mathrm{K1}} = 23.93447213$ 小时\n- $T_{\\mathrm{O1}} = 25.81934166$ 小时\n\n动能通量 $P(t)$ 代表垂直于流向的单位面积上单位时间内流过的动能，对于密度为 $\\rho$、速度为 $|v(t)|$ 的流体，其公式为：\n$$\nP(t) = \\tfrac{1}{2}\\,\\rho\\,|v(t)|^3\n$$\n问题指定海水密度为 $\\rho = 1025$ $\\mathrm{kg/m^3}$。当速度单位为 $\\mathrm{m/s}$ 时，得到的功率通量 $P(t)$ 的单位为瓦特/平方米（$\\mathrm{W/m^2}$）。\n\n目标是计算在给定时间范围 $T$ 内的时间平均功率通量 $\\overline{P}$。由于对 $|\\sum_j \\dots|^3$ 的平均值求解析解是不可行的，因此采用基于离散时间平均的数值方法。时间被离散化为一个均匀网格：\n$$\nt_k = k\\,\\Delta t, \\quad \\text{for } k \\in \\{0, 1, 2, \\dots, N-1\\}\n$$\n其中 $\\Delta t$ 是以小时为单位的时间步长，$N$ 是样本总数，定义为：\n$$\nN = \\left\\lfloor \\frac{T}{\\Delta t} \\right\\rfloor\n$$\n然后，使用 $N$ 个样本的离散时间算术平均值来估计平均功率通量 $\\overline{P}$：\n$$\n\\overline{P} = \\frac{1}{N} \\sum_{k=0}^{N-1} P(t_k) = \\frac{1}{N} \\sum_{k=0}^{N-1} \\left( \\tfrac{1}{2}\\,\\rho\\,|v(t_k)|^3 \\right)\n$$\n\n每个测试用例的计算算法如下：\n1.  **初始化**：根据 $\\mathrm{M2}$、$\\mathrm{S2}$、$\\mathrm{K1}$ 和 $\\mathrm{O1}$ 各分量的周期 $T_j$ 预先计算出角频率 $\\omega_j$。\n2.  **时间离散化**：对于给定的时间范围 $T$ 和时间步长 $\\Delta t$ 的测试用例，计算样本数 $N$。生成一个长度为 $N$ 的时间向量 $t$，代表离散的时间点 $t_k$。\n3.  **速度时间序列构建**：初始化一个长度为 $N$ 的空速度向量 $v$。对于四个分量中的每一个，计算其在所有时间步 $t_k$ 对速度的贡献 $A_j \\cos(\\omega_j t_k + \\phi_j)$，并将其加到总速度向量 $v$ 中。\n4.  **功率通量计算**：通过取速度向量的绝对值 $|v(t_k)|$ 来得到瞬时速率。然后使用功率通量公式 $P(t_k) = \\frac{1}{2} \\rho |v(t_k)|^3$ 按元素计算功率通量时间序列 $P(t_k)$。\n5.  **求平均值**：通过计算功率通量时间序列向量 $P(t_k)$ 的算术平均值来计算平均功率通量 $\\overline{P}$。\n6.  **输出格式化**：对所有四个测试用例重复此过程。最终结果四舍五入到小数点后 $6$ 位，并格式化为指定的输出字符串。\n\n此过程通过高精度浮点运算实现，为每组输入参数产生确定性且可验证的结果。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the average tidal current power flux for specified harmonic constituents.\n    \"\"\"\n    # Define physical and numerical constants\n    RHO = 1025.0  # Density of seawater in kg/m^3\n\n    # Astronomical periods of the four principal tidal constituents in hours\n    # Order: M2, S2, K1, O1\n    PERIODS = np.array([\n        12.4206012,      # M2: Principal lunar semidiurnal\n        12.0,            # S2: Principal solar semidiurnal\n        23.93447213,     # K1: Luni-solar diurnal\n        25.81934166      # O1: Principal lunar diurnal\n    ], dtype=np.float64)\n    \n    # Calculate angular frequencies in radians per hour\n    OMEGAS = 2 * np.pi / PERIODS\n    \n    # Define the test suite as a list of tuples.\n    # Each tuple contains: (T, dt, Amplitudes, Phases)\n    test_cases = [\n        # Case A: General multiharmonic over two spring-neap cycles\n        (336.0, 0.25, [1.0, 0.35, 0.25, 0.15], [0.4, -1.1, 1.6, -0.3]),\n        \n        # Case B: Single-constituent boundary with integer multiples of the period\n        (10 * 12.4206012, 0.05, [1.5, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0]),\n        \n        # Case C: Diurnal-dominated with phase offsets\n        (168.0, 0.2, [0.6, 0.3, 1.2, 0.8], [np.pi/3, -np.pi/4, np.pi/2, -np.pi/6]),\n        \n        # Case D: Near-zero amplitudes to probe numerical stability\n        (48.0, 0.5, [0.01, 0.01, 0.01, 0.01], [0.0, 0.0, 0.0, 0.0])\n    ]\n\n    results = []\n    \n    for T_horizon, dt, amps_list, phases_list in test_cases:\n        amps = np.array(amps_list, dtype=np.float64)\n        phases = np.array(phases_list, dtype=np.float64)\n        \n        # 1. Discretize time\n        # N is the number of samples for the given horizon T and time step dt.\n        N = int(np.floor(T_horizon / dt))\n        # t is the time vector from t=0 to t=(N-1)*dt.\n        t = np.arange(N, dtype=np.float64) * dt\n        \n        # 2. Calculate velocity time series v(t)\n        # Initialize velocity vector with zeros. Use float64 for precision.\n        v = np.zeros(N, dtype=np.float64)\n        \n        # Sum the contributions of each harmonic constituent\n        for j in range(len(OMEGAS)):\n            # Add component v_j(t) = A_j * cos(omega_j * t + phi_j)\n            v += amps[j] * np.cos(OMEGAS[j] * t + phases[j])\n            \n        # 3. Calculate power flux time series P(t)\n        # P(t) = 1/2 * rho * |v(t)|^3\n        # np.abs() calculates the speed |v(t)| from the 1D velocity v(t).\n        P = 0.5 * RHO * np.power(np.abs(v), 3)\n        \n        # 4. Compute average power flux\n        # Use the discrete arithmetic mean as the estimator for the time-average.\n        P_avg = np.mean(P)\n        results.append(P_avg)\n\n    # Format the final results to exactly 6 decimal places and print\n    # in the required format: [result_A,result_B,result_C,result_D]\n    print(f\"[{','.join([f'{r:.6f}' for r in results])}]\")\n\nsolve()\n```"
        }
    ]
}