{
    "hands_on_practices": [
        {
            "introduction": "火力发电机组在进入稳定运行状态之前，必须先成功启动。本练习旨在探讨启动过程中的基本动态特性，其中机组的爬坡能力（$RU$）与其最低稳定发电水平（$P^{\\min}$）之间存在直接的制约关系。通过解决这个问题，您将计算出机组从冷启动到达到可运行状态所需的最短时间，从而揭示电力系统调度中的一个关键约束。",
            "id": "4130416",
            "problem": "单个火力发电机组在离散时间内进行建模，周期长度为 $\\Delta t = 1$ 小时。设 $t \\in \\{1,2,\\dots\\}$ 为周期索引，$p_t$ 表示机组的电输出功率（单位：兆瓦），$u_t \\in \\{0,1\\}$ 表示其开/关机状态。该机组遵循能源系统建模中的三个标准约束：最小稳定出力约束、最大出力约束，以及一个因热惯性导致的发电机有限变动速率能力所引起的跨时间周期爬坡速率限制。具体来说，对于每个周期 $t$，\n- 最小出力约束为 $p_t \\ge P^{\\min} u_t$，\n- 最大出力约束为 $p_t \\le P^{\\max} u_t$，\n- 爬坡速率限制（定义为每个周期的最大出力增量）为 $p_t - p_{t-1} \\le RU$。\n\n假设发电机初始状态为关机，即 $u_0 = 0$ 且 $p_0 = 0$。该机组从周期 $t=1$ 开始投入运行，因此对于所有 $t \\ge 1$，$u_t = 1$。参数为 $P^{\\min} = 300$ 兆瓦，$P^{\\max} = 500$ 兆瓦，爬坡速率限制 $RU = 80$ 兆瓦/小时。没有单独的启动爬坡参数；启动时适用相同的爬坡速率限制。在这些条件下，如果爬坡速率限制较低，那么在第一个运行周期内将 $p_t$ 调度到 $P^{\\min}$ 或更高可能是不可能的，因为跨时间周期的变动速率约束可能会阻止机组在单个周期内从零出力达到最小稳定出力。\n\n在给定上述约束和初始条件下，确定最早的周期索引 $t^{\\star} \\ge 1$，在该周期存在一个可行的 $p_{t^{\\star}}$ 满足 $p_{t^{\\star}} \\ge P^{\\min}$。以整数形式提供 $t^{\\star}$。无需进行舍入，最终答案中也不需要单位，因为 $t^{\\star}$ 是一个周期索引。",
            "solution": "该问题要求确定机组从零出力开始，达到其最小稳定出力 $P^{\\min}$ 所需的最短时间。这取决于机组的爬坡速率限制。\n\n**步骤1：明确参数和约束**\n- 初始状态 (t=0)：$p_0 = 0$ MW。\n- 最小稳定出力：$P^{\\min} = 300$ MW。\n- 爬坡速率限制：$RU = 80$ MW/小时。这意味着在一个小时（一个周期）内，机组的出力最多能增加80 MW。\n- 约束：$p_t - p_{t-1} \\le RU$。\n\n**步骤2：逐周期计算最大可达出力**\n我们可以通过迭代计算每个周期结束时机组能达到的最大出力，来确定何时能超过 $P^{\\min}$。\n- **周期 1 (t=1):** 机组从 $p_0=0$ 开始。在第一个小时内，其最大出力为 $p_1^{\\max} = p_0 + RU = 0 + 80 = 80$ MW。\n  - 由于 $80  300$，机组在周期1无法达到最小稳定出力。\n\n- **周期 2 (t=2):** 假设机组在周期1结束时达到了最大出力 $p_1=80$ MW。在第二个小时内，其最大出力为 $p_2^{\\max} = p_1 + RU = 80 + 80 = 160$ MW。\n  - 由于 $160  300$，机组在周期2仍无法达到最小稳定出力。\n\n- **周期 3 (t=3):** 假设机组在周期2结束时达到了最大出力 $p_2=160$ MW。在第三个小时内，其最大出力为 $p_3^{\\max} = p_2 + RU = 160 + 80 = 240$ MW。\n  - 由于 $240  300$，机组在周期3仍无法达到最小稳定出力。\n\n- **周期 4 (t=4):** 假设机组在周期3结束时达到了最大出力 $p_3=240$ MW。在第四个小时内，其最大出力为 $p_4^{\\max} = p_3 + RU = 240 + 80 = 320$ MW。\n  - 由于 $320 \\ge 300$，机组在周期4可以达到并超过其最小稳定出力。\n\n**步骤3：结论**\n因此，最早可以调度机组出力大于或等于 $P^{\\min}$ 的周期是 $t^{\\star} = 4$。\n更形式化地，我们需要找到最小的整数 $t^{\\star}$ 使得 $t^{\\star} \\times RU \\ge P^{\\min}$。\n$t^{\\star} \\ge \\frac{P^{\\min}}{RU} = \\frac{300}{80} = 3.75$。\n由于 $t^{\\star}$ 必须是整数，所以最小的 $t^{\\star}$ 是 $\\lceil 3.75 \\rceil = 4$。",
            "answer": "$$\n\\boxed{4}\n$$"
        },
        {
            "introduction": "一旦机组并网运行，其主要目标便是实现经济运行。本练习聚焦于经典的经济调度问题，即机组如何在运行限制内决定其最优出力水平以实现利润最大化。您将应用边际成本与市场价格进行比较的原则来寻找最优调度点，从而理解最低（$P^{\\min}$）和最高（$P^{\\max}$）出力限制如何为这一经济优化问题界定可行的决策空间。",
            "id": "4130468",
            "problem": "一个火力发电机组在集中式调度环境中作为价格接受者资源运行。该机组已启机，且必须遵守其最小和最大稳定出力限制。设调度决策为 $q$（单位：兆瓦），其箱式约束为 $q \\in [q_{\\min}, q_{\\max}]$。系统运营商按节点边际电价（LMP）$\\lambda$（单位：美元/兆瓦时）对电量进行补偿，该机组的可变生产成本是覆盖三个连续分段的凸分段线性函数。具体而言，设分段点为 $q_{1}$ 和 $q_{2}$，非递减的分段斜率为 $c_{1}$、$c_{2}$、$c_{3}$，则成本函数 $C(q)$ 为\n$$\nC(q) =\n\\begin{cases}\nc_{1}(q - q_{\\min}),   q \\in [q_{\\min}, q_{1}], \\\\\nc_{1}(q_{1} - q_{\\min}) + c_{2}(q - q_{1}),   q \\in [q_{1}, q_{2}], \\\\\nc_{1}(q_{1} - q_{\\min}) + c_{2}(q_{2} - q_{1}) + c_{3}(q - q_{2}),   q \\in [q_{2}, q_{\\max}].\n\\end{cases}\n$$\n该机组参与运行的参数如下：\n- 最小和最大出力为 $q_{\\min} = 70$ 和 $q_{\\max} = 310$ 兆瓦。\n- 分段点为 $q_{1} = 160$ 和 $q_{2} = 240$ 兆瓦。\n- 分段斜率为 $c_{1} = 23$、$c_{2} = 31$ 和 $c_{3} = 43$ 美元/兆瓦时。\n- 节点边际电价（LMP）为 $\\lambda = 45$ 美元/兆瓦时。\n\n假设该机组选择 $q$ 以最大化净收益（收益减去成本），即求解\n$$\n\\max_{q \\in [q_{\\min}, q_{\\max}]} \\ \\lambda q - C(q),\n$$\n计算最优调度量 $q^{\\star}$，并确定解在哪个成本分段上处于活动状态。最终调度量以兆瓦（MW）表示。无需四舍五入。",
            "solution": "首先验证该问题，以确保其具有科学依据、良构且客观。\n\n**步骤1：提取已知条件**\n- 决策变量：$q$（单位：兆瓦，MW）。\n- 调度可行集：$q \\in [q_{\\min}, q_{\\max}]$。\n- 节点边际电价（LMP）：$\\lambda$（单位：美元/兆瓦时，USD/MWh）。\n- 可变生产成本函数 $C(q)$ 是分段线性的：\n$$\nC(q) =\n\\begin{cases}\nc_{1}(q - q_{\\min}),  q \\in [q_{\\min}, q_{1}], \\\\\nc_{1}(q_{1} - q_{\\min}) + c_{2}(q - q_{1}),  q \\in [q_{1}, q_{2}], \\\\\nc_{1}(q_{1} - q_{\\min}) + c_{2}(q_{2} - q_{1}) + c_{3}(q - q_{2}),  q \\in [q_{2}, q_{\\max}].\n\\end{cases}\n$$\n- 分段斜率是非递减的：$c_{1} \\le c_{2} \\le c_{3}$。\n- 参数：\n  - $q_{\\min} = 70$ MW\n  - $q_{\\max} = 310$ MW\n  - $q_{1} = 160$ MW\n  - $q_{2} = 240$ MW\n  - $c_{1} = 23$ USD/MWh\n  - $c_{2} = 31$ USD/MWh\n  - $c_{3} = 43$ USD/MWh\n  - $\\lambda = 45$ USD/MWh\n- 目标：在 $q \\in [q_{\\min}, q_{\\max}]$ 的约束下，最大化净收益 $\\Pi(q) = \\lambda q - C(q)$。\n\n**步骤2：使用提取的已知条件进行验证**\n该问题是针对单个价格接受者发电机组的标准经济调度模型，是电力系统工程和电力市场分析中的一个基本概念。\n- **科学依据充分**：该模型基于既定的微观经济学利润最大化原理以及火力发电机组成本函数的工程表示。使用凸分段线性成本函数是现实的，而节点边际电价（LMP）的概念是该领域的标准做法。\n- **良构性**：目标函数 $\\Pi(q) = \\lambda q - C(q)$ 需要在一个紧凸集 $[q_{\\min}, q_{\\max}]$ 上最大化。成本函数 $C(q)$ 是凸函数，因为其斜率是非递减的（$23 \\le 31 \\le 43$）。收益函数 $\\lambda q$ 是线性的。凸函数的负数 $-C(q)$ 是凹函数。一个线性函数（因此也是凹函数）与一个凹函数的和是凹函数。因此，$\\Pi(q)$ 是一个凹函数。在一个紧凸集上最大化一个凹函数是一个保证有解的良构问题。\n- **客观性和完整性**：该问题通过精确的数学公式和明确的数值进行定义。所有必要的数据都已提供，且不存在矛盾。分段点的顺序是正确的：$q_{\\min}  q_{1}  q_{2}  q_{\\max}$。\n\n**步骤3：结论与行动**\n该问题是有效的。下面将给出严谨的求解过程。\n\n目标是找到能解决以下优化问题的调度水平 $q^{\\star}$：\n$$ \\max_{q \\in [q_{\\min}, q_{\\max}]} \\Pi(q) = \\lambda q - C(q) $$\n对于一个价格接受者企业，边际收益就是市场价格 $\\lambda$。一个理性的、追求利润最大化的企业，只要边际收益大于边际生产成本，就会增加其产量。边际成本 $C'(q)$ 是成本函数 $C(q)$ 关于 $q$ 的导数。由于 $C(q)$ 是分段线性的，其导数是一个分段常数（或阶梯）函数：\n$$\nC'(q) = \\frac{dC}{dq} =\n\\begin{cases}\nc_{1},  \\text{for } q \\in (q_{\\min}, q_{1}) \\\\\nc_{2},  \\text{for } q \\in (q_{1}, q_{2}) \\\\\nc_{3},  \\text{for } q \\in (q_{2}, q_{\\max})\n\\end{cases}\n$$\n在分段点 $q_1$ 和 $q_2$ 处，导数未定义，但这不影响优化逻辑。最优性条件通过比较每个分段的边际收益 $\\lambda$ 和边际成本来找到。利润函数的导数是 $\\Pi'(q) = \\lambda - C'(q)$。如果 $\\Pi'(q) > 0$，利润随 $q$ 的增加而增加，应增加产量。如果 $\\Pi'(q)  0$，利润随 $q$ 的增加而减少，应减少产量。\n\n让我们代入给定的数值：\n- LMP（边际收益）：$\\lambda = 45$ USD/MWh。\n- 边际成本：$c_{1} = 23$ USD/MWh，$c_{2} = 31$ USD/MWh，$c_{3} = 43$ USD/MWh。\n- 分段：\n  - 分段 1：$q \\in [70, 160]$\n  - 分段 2：$q \\in [160, 240]$\n  - 分段 3：$q \\in [240, 310]$\n\n我们现在分析每个分段的边际利润 $\\lambda - C'(q)$：\n1.  对于分段1，$q \\in (70, 160)$，边际成本为 $c_{1} = 23$。边际利润为 $\\lambda - c_{1} = 45 - 23 = 22$。由于这个值是正的，机组应至少生产到该分段的末端，即 $q_{1} = 160$ MW，以获取这部分利润。\n\n2.  对于分段2，$q \\in (160, 240)$，边际成本为 $c_{2} = 31$。边际利润为 $\\lambda - c_{2} = 45 - 31 = 14$。由于这个值也是正的，机组应继续增加其产量，贯穿整个分段，至少达到 $q_{2} = 240$ MW。\n\n3.  对于分段3，$q \\in (240, 310]$，边际成本为 $c_{3} = 43$。边际利润为 $\\lambda - c_{3} = 45 - 43 = 2$。由于边际利润仍然为正，机组应继续在该分段内增加其产量。\n\n由于从 $q_{\\min}$ 到 $q_{\\max}$ 的所有可能出力水平的边际利润都为正，总利润函数 $\\Pi(q)$ 在其整个定义域 $[70, 310]$ 上是严格递增的。一个严格递增函数在闭区间上的最大值在区间的右端点处取得。\n\n因此，最优调度量 $q^{\\star}$ 是该机组可能的最大出力。\n$$ q^{\\star} = q_{\\max} $$\n代入给定值，我们得到：\n$$ q^{\\star} = 310 \\text{ MW} $$\n处于活动状态的成本分段是包含最优调度水平 $q^{\\star}$ 的那一段。由于 $q^{\\star} = 310$ MW，且第三分段的定义域为 $q \\in [q_{2}, q_{\\max}]$，即 $[240, 310]$，所以最优调度量位于第三成本分段内。具体来说，它位于该分段的上边界。因此，在解中，第三成本分段处于活动状态。",
            "answer": "$$\n\\boxed{310}\n$$"
        },
        {
            "introduction": "诸如最低出力水平之类的运行约束不仅是物理限制，它们还会给电力系统带来切实的经济影响。这个编程实践练习将让您通过求解一个小型机组组合问题来量化这种影响。通过比较真实情景（$P^{\\min}  0$）与理想化情景（$P^{\\min} = 0$）下的总系统成本，您将能直接衡量由运行不灵活性（尤其是在低需求时期）所带来的经济代价。",
            "id": "4130421",
            "problem": "构建并求解一个针对火力发电机组的小型、科学上现实的机组组合问题，以量化在低需求时段非零最小出力对成本的影响，并将其与所有最小出力均为零的假设情况进行比较。仅依赖基本原则：功率平衡、机组能力约束和线性生产成本。该问题纯粹是数学问题，并将通过算法实现。\n\n考虑一组以 $i \\in \\{1,2,3\\}$ 为索引的火力发电机组和一个单一时间段 $t$（一小时）。对每个机组，定义一个二进制启停状态 $u_i \\in \\{0,1\\}$ 和一个连续功率输出 $p_i \\ge 0$（单位为兆瓦）。设系统需求为 $D$（单位为兆瓦）。为确保在总最小出力超过需求时的可行性，引入一个非负的弃能变量 $s \\ge 0$（单位为兆瓦），代表生产出但立即被削减且无价值的能量。采用以下在能源系统建模中标准的核心约束和成本模型：\n\n- 功率平衡：\n$$\\sum_{i=1}^{3} p_i \\;=\\; D + s.$$\n- 带最小和最大出力的机组能力：\n$$u_i \\, P_i^{\\min} \\;\\le\\; p_i \\;\\le\\; u_i \\, P_i^{\\max}, \\quad \\text{for } i \\in \\{1,2,3\\}.$$\n- 无跨时段耦合：无爬坡、无最小开关机时间、无启停成本。\n- 线性生产成本：\n$$\\text{Cost} \\;=\\; \\sum_{i=1}^{3} c_i \\, p_i.$$\n\n定义两种情况：\n- Case A（实际情况）：给定非零的最小出力 $P_i^{\\min}$。\n- Case B（假设情况）：将所有最小出力设为零，即对所有 $i$ 都有 $P_i^{\\min}=0$。\n\n对于这两种情况，决策变量为 $u_i$ 和 $p_i$，以及 $s \\ge 0$。目标是在满足约束条件的前提下，最小化总生产成本。参数如下：\n\n- 机组 1：$P_1^{\\min} = 50$ MW, $P_1^{\\max} = 200$ MW, $c_1 = 20$ 美元/兆瓦时。\n- 机组 2：$P_2^{\\min} = 30$ MW, $P_2^{\\max} = 100$ MW, $c_2 = 25$ 美元/兆瓦时。\n- 机组 3：$P_3^{\\min} = 10$ MW, $P_3^{\\max} = 50$ MW, $c_3 = 40$ 美元/兆瓦时。\n\n假设时间段为一小时，因此兆瓦和兆瓦时的数值在这一小时内是相同的。所有成本以美元表示，四舍五入到两位小数。\n\n编写一个完整且可运行的程序，针对下方的每个测试用例，计算 Case A 和 Case B 中的最低总生产成本，并返回成本差 $\\Delta = \\text{Cost}_{A} - \\text{Cost}_{B}$（以美元为单位）：\n\n- 测试用例 1：$D = 5$ MW。\n- 测试用例 2：$D = 10$ MW。\n- 测试用例 3：$D = 20$ MW。\n- 测试用例 4：$D = 130$ MW。\n- 测试用例 5：$D = 250$ MW。\n\n您的程序必须为每个测试用例以及 Case A 和 Case B 精确求解混合整数线性规划问题。您可以利用问题中不存在跨时段耦合以及线性成本的结构。弃能 $s$ 没有直接成本，但受 $s \\ge 0$ 的约束。如果 $D = 0$，则零启停、零输出的解是可行的，成本为零。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，例如 `[x_1,x_2,x_3,x_4,x_5]`，其中每个 $x_k$ 是测试用例 $k$ 的 $\\Delta$ 值，以美元为单位，四舍五入到两位小数，不打印任何单位或额外文本。答案值必须是浮点数。\n\n测试套件涵盖：\n- 极低的需求，此时最小出力可能导致弃能（测试 1 和 2）。\n- 一个低但为正的需求，高于最小的机组最小出力（测试 3）。\n- 一个正常的需求，此时最小出力约束不起作用（测试 4）。\n- 一个高的需求，需要多个机组运行（测试 5）。",
            "solution": "该问题是一个混合整数线性规划（MILP）问题，可通过枚举所有8种机组启停组合来精确求解，因为机组数量很少。对于每种组合，我们计算满足需求和运行约束的最低成本，然后选择所有组合中的全局最低成本。\n\n**算法**\n\n对于每种情况（Case A 和 Case B）和每个需求水平 $D$：\n1.  **Case A (实际 $P_i^{\\min}$ > 0):**\n    a. 遍历所有 $2^3=8$ 种机组启停组合。\n    b. 对于每种组合，确定已开启机组的总最小出力 ($P_{\\min}^{\\text{total}}$) 和总最大出力 ($P_{\\max}^{\\text{total}}$)。\n    c. 所需总产量为 $P_{\\text{req}} = \\max(D, P_{\\min}^{\\text{total}})$。如果 $P_{\\text{req}} > P_{\\max}^{\\text{total}}$，则该组合不可行。\n    d. 对于可行的组合，按成本的优先顺序（merit order）调度机组以满足 $P_{\\text{req}}$，首先将所有开启的机组调度至其 $P_i^{\\min}$，然后将剩余需求经济地分配给成本最低的机组，直至其 $P_i^{\\max}$。\n    e. 计算该组合的总成本。\n    f. 追踪并保留所有可行组合中的最低总成本作为 $\\text{Cost}_A$。\n\n2.  **Case B (假设 $P_i^{\\min} = 0$):**\n    a. 这个问题简化为标准的经济调度问题。所需总产量始终为 $D$。\n    b. 按成本的优先顺序开启并调度机组，直到满足需求 $D$。\n    c. 计算总成本作为 $\\text{Cost}_B$。\n\n3.  **计算差值**: $\\Delta = \\text{Cost}_A - \\text{Cost}_B$。\n\n以下 Python 代码实现了此逻辑，以计算所有测试用例的成本差。\n\n```python\nimport numpy as np\nimport itertools\n\ndef solve():\n    \"\"\"\n    Solves the unit commitment problem for the given test cases and prints the results.\n    \"\"\"\n\n    # Define unit parameters for Case A\n    units_case_a = [\n        {'id': 1, 'p_min': 50.0, 'p_max': 200.0, 'cost': 20.0},\n        {'id': 2, 'p_min': 30.0, 'p_max': 100.0, 'cost': 25.0},\n        {'id': 3, 'p_min': 10.0, 'p_max': 50.0, 'cost': 40.0},\n    ]\n\n    # Define unit parameters for Case B (hypothetical, p_min = 0)\n    units_case_b = [\n        {'id': 1, 'p_min': 0.0, 'p_max': 200.0, 'cost': 20.0},\n        {'id': 2, 'p_min': 0.0, 'p_max': 100.0, 'cost': 25.0},\n        {'id': 3, 'p_min': 0.0, 'p_max': 50.0, 'cost': 40.0},\n    ]\n\n    test_demands = [5.0, 10.0, 20.0, 130.0, 250.0]\n\n    results = []\n    \n    for demand in test_demands:\n        cost_a = compute_milp_cost(demand, units_case_a)\n        cost_b = compute_economic_dispatch_cost(demand, units_case_b)\n        \n        delta = cost_a - cost_b\n        results.append(f\"{delta:.2f}\")\n\n    # The problem statement asks for a specific output format, which is a list of strings.\n    # For the answer tag, we just provide the final list as a string.\n    # The print statement is for execution but the function's conceptual return is the list.\n    # print(f\"[{','.join(results)}]\")\n    return f\"[{','.join(results)}]\"\n\n\ndef compute_milp_cost(demand, units):\n    \"\"\"\n    Solves the mixed-integer linear problem by enumerating all commitment states.\n    This is exact for a small number of units.\n    \"\"\"\n    if demand == 0.0:\n        return 0.0\n\n    num_units = len(units)\n    min_total_cost = np.inf\n\n    # Iterate through all 2^N commitment combinations\n    for commitment in itertools.product([0, 1], repeat=num_units):\n        \n        committed_units_indices = [i for i, u in enumerate(commitment) if u == 1]\n        if not committed_units_indices:\n            if demand > 0: # If demand > 0 and no units are on, this state is infeasible.\n                continue\n            else: # demand is 0, cost is 0\n                min_total_cost = min(min_total_cost, 0.0)\n                continue\n            \n        p_min_total = sum(units[i]['p_min'] for i in committed_units_indices)\n        p_max_total = sum(units[i]['p_max'] for i in committed_units_indices)\n\n        # Determine required production and check feasibility\n        p_required = max(demand, p_min_total)\n        \n        if p_required > p_max_total:\n            # This commitment state cannot meet the required production.\n            continue\n\n        # Feasible state, now calculate the minimum cost for this dispatch.\n        # Start with minimum generation.\n        current_cost = 0.0\n        power_dispatch = {i: 0.0 for i in range(num_units)}\n        \n        for i in committed_units_indices:\n            power_dispatch[i] = units[i]['p_min']\n            \n        current_production = sum(power_dispatch.values())\n        \n        # Dispatch remaining power economically (merit order)\n        power_to_add = p_required - current_production\n        \n        # Sort committed units by cost to dispatch economically\n        sorted_committed_units = sorted([units[i] for i in committed_units_indices], key=lambda x: x['cost'])\n        \n        for unit in sorted_committed_units:\n            if power_to_add = 0:\n                break\n                \n            unit_idx = unit['id'] - 1\n            available_capacity = unit['p_max'] - power_dispatch[unit_idx]\n            dispatch_amount = min(power_to_add, available_capacity)\n            \n            power_dispatch[unit_idx] += dispatch_amount\n            power_to_add -= dispatch_amount\n        \n        # Calculate final cost for this dispatch\n        final_cost = sum(power_dispatch[i] * units[i]['cost'] for i in range(num_units))\n        min_total_cost = min(min_total_cost, final_cost)\n\n    return min_total_cost\n\ndef compute_economic_dispatch_cost(demand, units):\n    \"\"\"\n    Solves a simple economic dispatch problem where P_min = 0 for all units.\n    This uses a greedy merit-order dispatch.\n    \"\"\"\n    if demand == 0.0:\n        return 0.0\n\n    # Sort units by cost (merit order)\n    sorted_units = sorted(units, key=lambda x: x['cost'])\n    \n    total_cost = 0.0\n    remaining_demand = demand\n    \n    total_max_cap = sum(u['p_max'] for u in units)\n    if demand > total_max_cap:\n        return np.inf\n\n    for unit in sorted_units:\n        if remaining_demand = 0:\n            break\n            \n        # Dispatch amount is the minimum of what's needed and what the unit can provide\n        dispatch_amount = min(remaining_demand, unit['p_max'])\n        \n        total_cost += dispatch_amount * unit['cost']\n        remaining_demand -= dispatch_amount\n        \n    return total_cost\n\n# To generate the answer, one would run:\n# solve()\n```",
            "answer": "[300.00,200.00,350.00,0.00,0.00]"
        }
    ]
}