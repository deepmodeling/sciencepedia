{
    "hands_on_practices": [
        {
            "introduction": "To effectively incorporate battery degradation into planning models, we must begin by quantifying the physical loss of capacity. This first practice introduces a foundational reduced-form model that separates degradation into its two primary components: calendar aging, which occurs over time regardless of use, and cycle aging, which results from charging and discharging. By applying distinct mathematical forms to each mechanism—a square-root-of-time dependency for calendar fade and a linear dependency for cycle fade—you will calculate the remaining capacity of a battery, gaining a fundamental understanding of how these distinct aging pathways are modeled and combined. ",
            "id": "4071265",
            "problem": "A utility-scale lithium-ion battery energy storage system of nominal capacity $Q_{0}$ (in $\\mathrm{kWh}$) is represented in a long-run planning model using reduced-form degradation components calibrated from electrochemical and empirical evidence. Two well-tested facts underpin the representation:\n- For diffusion-limited growth of the Solid Electrolyte Interphase (SEI), the loss of cyclable lithium, and hence capacity fade, scales as the square root of calendar time $t$; this is a consequence of Fickian transport controlling the rate of SEI growth, yielding a thickness $\\delta(t) \\propto \\sqrt{t}$ and capacity loss $\\Delta Q_{\\mathrm{cal}}(t) \\propto \\delta(t)$.\n- For cycling at moderate depth-of-discharge and fixed operating conditions, the incremental loss of cyclable lithium per Equivalent Full Cycle (EFC) is approximately constant, producing an accumulated capacity loss that is linear in the number of EFCs, $N$, i.e., $\\Delta Q_{\\mathrm{cyc}}(N) \\propto N$, where an EFC aggregates partial cycles such that the total energy throughput equals one nominal full charge/discharge.\n\nAssume that, over the time horizon of interest, the calendar and cycling mechanisms are independent and their losses add linearly, with proportionality constants $\\alpha$ (for calendar time) and $\\beta$ (for cycling), both calibrated at the pack level. Starting from these base facts, derive an analytic expression for the residual capacity $Q(t,N)$ in terms of $Q_{0}$, $\\alpha$, $\\beta$, $t$, and $N$.\n\nThen, using $Q_{0}=100\\ \\mathrm{kWh}$, $\\alpha=0.2\\ \\mathrm{kWh}/\\sqrt{\\mathrm{day}}$, $\\beta=0.05\\ \\mathrm{kWh}$ per EFC, $t=90\\ \\mathrm{day}$, and $N=300$ EFC, compute the numerical value of $Q(t,N)$. Express the final capacity in $\\mathrm{kWh}$ and round your answer to four significant figures.",
            "solution": "The problem statement is first subjected to a rigorous validation process.\n\n### Step 1: Extract Givens\n-   Nominal capacity: $Q_{0}$ (in $\\mathrm{kWh}$)\n-   Calendar time: $t$\n-   Number of Equivalent Full Cycles (EFCs): $N$\n-   Calendar capacity loss model: $\\Delta Q_{\\mathrm{cal}}(t) \\propto \\sqrt{t}$\n-   Cycling capacity loss model: $\\Delta Q_{\\mathrm{cyc}}(N) \\propto N$\n-   Assumption: Calendar and cycling degradation mechanisms are independent and their losses add linearly.\n-   Proportionality constant for calendar loss: $\\alpha$\n-   Proportionality constant for cycling loss: $\\beta$\n-   Required derivation: An analytic expression for the residual capacity $Q(t,N)$ in terms of $Q_{0}$, $\\alpha$, $\\beta$, $t$, and $N$.\n-   Numerical values for calculation:\n    -   $Q_{0} = 100\\ \\mathrm{kWh}$\n    -   $\\alpha = 0.2\\ \\mathrm{kWh}/\\sqrt{\\mathrm{day}}$\n    -   $\\beta = 0.05\\ \\mathrm{kWh}$ per EFC\n    -   $t = 90\\ \\mathrm{day}$\n    -   $N = 300$ EFC\n-   Final instruction: Compute the numerical value of $Q(t,N)$ and round to four significant figures.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is assessed for validity.\n-   **Scientifically Grounded**: The problem is grounded in established, albeit simplified, models of battery degradation. The square-root-of-time dependence for calendar aging (linked to diffusion-limited SEI layer growth) and the linear dependence on the number of equivalent full cycles are standard and widely used approximations in the field of battery modeling and energy systems analysis. The premises are scientifically sound for a reduced-form model.\n-   **Well-Posed**: The problem is well-posed. It provides all necessary information, including initial conditions ($Q_0$), model forms ($\\propto \\sqrt{t}$, $\\propto N$), constants ($\\alpha, \\beta$), and a clear set of assumptions (independence and linear additivity of loss mechanisms), to derive a unique analytical expression and compute a corresponding numerical result.\n-   **Objective**: The problem is stated in objective, technical language, free from ambiguity or subjective claims.\n\nThe problem does not exhibit any flaws such as scientific unsoundness, incompleteness, contradiction, or ill-posed structure.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. A solution will be derived.\n\nThe residual capacity of the battery, $Q(t,N)$, is defined as the initial nominal capacity, $Q_{0}$, minus the total capacity loss, $\\Delta Q_{\\mathrm{total}}(t,N)$.\n$$\nQ(t,N) = Q_{0} - \\Delta Q_{\\mathrm{total}}(t,N)\n$$\nThe problem states that the total loss is the linear sum of the independent calendar and cycling loss components.\n$$\n\\Delta Q_{\\mathrm{total}}(t,N) = \\Delta Q_{\\mathrm{cal}}(t) + \\Delta Q_{\\mathrm{cyc}}(N)\n$$\nThe calendar-induced capacity loss, $\\Delta Q_{\\mathrm{cal}}(t)$, is given as proportional to the square root of time, with a proportionality constant $\\alpha$.\n$$\n\\Delta Q_{\\mathrm{cal}}(t) = \\alpha \\sqrt{t}\n$$\nThe cycling-induced capacity loss, $\\Delta Q_{\\mathrm{cyc}}(N)$, is given as proportional to the number of equivalent full cycles, with a proportionality constant $\\beta$.\n$$\n\\Delta Q_{\\mathrm{cyc}}(N) = \\beta N\n$$\nSubstituting these expressions into the equation for total loss gives:\n$$\n\\Delta Q_{\\mathrm{total}}(t,N) = \\alpha \\sqrt{t} + \\beta N\n$$\nTherefore, the analytic expression for the residual capacity $Q(t,N)$ is:\n$$\nQ(t,N) = Q_{0} - (\\alpha \\sqrt{t} + \\beta N)\n$$\nThis is the first part of the required solution.\n\nFor the second part, we substitute the provided numerical values into this expression. The given values are:\n$Q_{0} = 100\\ \\mathrm{kWh}$\n$\\alpha = 0.2\\ \\mathrm{kWh}/\\sqrt{\\mathrm{day}}$\n$\\beta = 0.05\\ \\mathrm{kWh}$ per EFC\n$t = 90\\ \\mathrm{day}$\n$N = 300$ EFC\n\nFirst, we calculate the calendar loss component:\n$$\n\\Delta Q_{\\mathrm{cal}}(90) = \\alpha \\sqrt{t} = 0.2 \\cdot \\sqrt{90}\n$$\nSince $\\sqrt{90} = \\sqrt{9 \\cdot 10} = 3\\sqrt{10}$, this becomes:\n$$\n\\Delta Q_{\\mathrm{cal}}(90) = 0.2 \\cdot 3\\sqrt{10} = 0.6\\sqrt{10}\\ \\mathrm{kWh}\n$$\nNext, we calculate the cycling loss component:\n$$\n\\Delta Q_{\\mathrm{cyc}}(300) = \\beta N = 0.05 \\cdot 300 = 15\\ \\mathrm{kWh}\n$$\nThe total capacity loss is the sum of these two components:\n$$\n\\Delta Q_{\\mathrm{total}}(90, 300) = (0.6\\sqrt{10} + 15)\\ \\mathrm{kWh}\n$$\nThe residual capacity is then:\n$$\nQ(90, 300) = Q_{0} - \\Delta Q_{\\mathrm{total}}(90, 300) = 100 - (0.6\\sqrt{10} + 15)\n$$\n$$\nQ(90, 300) = 85 - 0.6\\sqrt{10}\\ \\mathrm{kWh}\n$$\nTo find the numerical value, we approximate $\\sqrt{10} \\approx 3.16227766$:\n$$\nQ(90, 300) \\approx 85 - 0.6 \\cdot 3.16227766\n$$\n$$\nQ(90, 300) \\approx 85 - 1.897366596\n$$\n$$\nQ(90, 300) \\approx 83.102633404\\ \\mathrm{kWh}\n$$\nThe problem requires the answer to be rounded to four significant figures. The first four significant figures are $8$, $3$, $1$, and $0$. The fifth figure is $2$, so we round down.\n$$\nQ(90, 300) \\approx 83.10\\ \\mathrm{kWh}\n$$",
            "answer": "$$\\boxed{83.10}$$"
        },
        {
            "introduction": "While physical capacity loss is the root cause of degradation, planning models operate in the domain of economics to make optimal decisions. This exercise demonstrates how to translate the physical wear of a battery into a tangible economic cost. You will derive a marginal degradation cost by amortizing the battery's replacement cost over its total lifetime service, quantified in equivalent full cycles. This practice is essential for understanding how complex aging processes are simplified into linear cost parameters, enabling optimizers to balance the revenue from energy arbitrage against the long-term cost of asset wear. ",
            "id": "4071287",
            "problem": "A capacity expansion planning model seeks to internalize battery wear by assigning a linear marginal degradation cost per unit of discharged energy. Assume a lithium-ion battery technology whose life is governed by linear cumulative damage consistent with Palmgren–Miner’s rule (often called Miner's rule): cumulative damage $D$ accumulates additively with each stress event and the asset reaches end-of-life when $D=1$. In a cycle-life based representation, define an Equivalent Full Cycle (EFC) as the passage of discharged energy equal to the nameplate energy capacity $E_{\\mathrm{nom}}$; under linear damage, one EFC contributes damage $1/N_{\\mathrm{EFC}}$, where $N_{\\mathrm{EFC}}$ is the number of EFCs to end-of-life. Let replacement at end-of-life cost $C_{\\mathrm{rep}}$ be the present-value cost used in long-run planning. Assume calendar aging is negligible, round-trip efficiency effects are neglected for damage accounting (that is, damage scales with discharged energy measured at the battery output), and partial cycles are linearly additive in discharged energy toward EFCs.\n\nStarting from these definitions and assumptions only, derive the marginal degradation cost per unit discharged energy $\\lambda_{\\mathrm{MWh}}$ as a function of $C_{\\mathrm{rep}}$, $E_{\\mathrm{nom}}$, and $N_{\\mathrm{EFC}}$. Then compute $\\lambda_{\\mathrm{MWh}}$ for a battery with $E_{\\mathrm{nom}}=100\\ \\mathrm{kWh}$, $N_{\\mathrm{EFC}}=4{,}000$, and $C_{\\mathrm{rep}}=\\$100{,}000$. Express your final answer in dollars per megawatt-hour. If the result is not an integer, round your answer to four significant figures.",
            "solution": "The problem requires the derivation of the marginal degradation cost per unit of discharged energy for a battery, based on a linear cumulative damage model. The derivation must be followed by a numerical calculation for a specific set of parameters.\n\nFirst, we validate the problem statement.\n**Step 1: Extract Givens**\n-   Damage accumulation model: Palmgren–Miner’s rule (linear cumulative damage).\n-   Damage variable: $D$.\n-   End-of-life condition: $D=1$.\n-   Cycle definition: An Equivalent Full Cycle (EFC) is the discharge of energy equal to the nameplate energy capacity, $E_{\\mathrm{nom}}$.\n-   Damage per EFC: The damage incurred from one EFC is $1/N_{\\mathrm{EFC}}$.\n-   Total cycles to end-of-life: $N_{\\mathrm{EFC}}$.\n-   Replacement Cost: $C_{\\mathrm{rep}}$ is the present-value cost of replacement at end-of-life.\n-   Assumptions: Calendar aging is negligible; round-trip efficiency effects are neglected for damage accounting; partial cycles are linearly additive.\n-   Variables for derivation: $C_{\\mathrm{rep}}$, $E_{\\mathrm{nom}}$, $N_{\\mathrm{EFC}}$.\n-   Numerical values for calculation: $E_{\\mathrm{nom}}=100\\ \\mathrm{kWh}$, $N_{\\mathrm{EFC}}=4,000$, $C_{\\mathrm{rep}}=\\$100,000$.\n-   Target variable: $\\lambda_{\\mathrm{MWh}}$, the marginal degradation cost in dollars per megawatt-hour.\n-   Rounding: Round to four significant figures if the result is not an integer.\n\n**Step 2: Validate Using Extracted Givens**\nThe problem is scientifically grounded, employing a standard engineering model (linear damage accumulation) for life assessment, which is common in energy systems modeling for its simplicity and tractability. It is well-posed, providing all necessary information to derive a unique solution. The terminology is objective and precise within the field. The assumptions are explicitly stated and consistent. The numerical values are physically plausible for a battery energy storage system. Therefore, the problem is valid.\n\n**Step 3: Derivation and Solution**\nThe core principle is to amortize the total replacement cost, $C_{\\mathrm{rep}}$, over the total service the battery provides during its lifetime. The service is measured in terms of the total energy discharged.\n\nThe total number of Equivalent Full Cycles (EFCs) the battery can deliver before reaching its end-of-life is $N_{\\mathrm{EFC}}$. By definition, one EFC corresponds to a total discharged energy equal to the battery's nameplate energy capacity, $E_{\\mathrm{nom}}$.\n\nTherefore, the total energy, $E_{\\mathrm{total}}$, that the battery can discharge over its entire operational life is the product of the number of EFCs and the energy discharged per EFC:\n$$\nE_{\\mathrm{total}} = N_{\\mathrm{EFC}} \\times E_{\\mathrm{nom}}\n$$\nThe problem states that the model uses a linear marginal degradation cost. This implies that each unit of discharged energy contributes an equal amount to the total cost of wear. The total cost to be amortized is the replacement cost, $C_{\\mathrm{rep}}$. The marginal degradation cost, which we denote as $\\lambda$, is this total cost distributed linearly over the total energy discharged.\n\nThus, the marginal cost per unit of energy is:\n$$\n\\lambda = \\frac{\\text{Total Cost}}{\\text{Total Energy Discharged}} = \\frac{C_{\\mathrm{rep}}}{E_{\\mathrm{total}}}\n$$\nSubstituting the expression for $E_{\\mathrm{total}}$, we obtain the marginal cost as a function of the given parameters:\n$$\n\\lambda = \\frac{C_{\\mathrm{rep}}}{N_{\\mathrm{EFC}} E_{\\mathrm{nom}}}\n$$\nThe units of the parameters are $C_{\\mathrm{rep}}$ in dollars ($\\$$), $N_{\\mathrm{EFC}}$ is a dimensionless quantity (number of cycles), and $E_{\\mathrm{nom}}$ is in kilowatt-hours ($\\mathrm{kWh}$). Consequently, the derived marginal cost $\\lambda$ has units of dollars per kilowatt-hour ($\\$/\\mathrm{kWh}$).\n\nThe problem requires the final answer, $\\lambda_{\\mathrm{MWh}}$, to be in units of dollars per megawatt-hour ($\\$/\\mathrm{MWh}$). We use the conversion factor $1 \\ \\mathrm{MWh} = 1000 \\ \\mathrm{kWh}$. To convert from $\\$/\\mathrm{kWh}$ to $\\$/\\mathrm{MWh}$, we multiply by $1000$:\n$$\n\\lambda_{\\mathrm{MWh}} \\left[\\frac{\\$}{\\mathrm{MWh}}\\right] = \\lambda \\left[\\frac{\\$}{\\mathrm{kWh}}\\right] \\times \\frac{1000 \\ \\mathrm{kWh}}{1 \\ \\mathrm{MWh}}\n$$\nSo, the symbolic expression for the marginal degradation cost in the required units is:\n$$\n\\lambda_{\\mathrm{MWh}} = 1000 \\times \\frac{C_{\\mathrm{rep}}}{N_{\\mathrm{EFC}} E_{\\mathrm{nom}}}\n$$\nThis is the first part of the required answer.\n\nNext, we compute the numerical value of $\\lambda_{\\mathrm{MWh}}$ using the provided data:\n-   $C_{\\mathrm{rep}} = \\$100,000$\n-   $N_{\\mathrm{EFC}} = 4,000$\n-   $E_{\\mathrm{nom}} = 100 \\ \\mathrm{kWh}$\n\nFirst, we calculate the total lifetime energy throughput, $E_{\\mathrm{total}}$:\n$$\nE_{\\mathrm{total}} = N_{\\mathrm{EFC}} \\times E_{\\mathrm{nom}} = 4,000 \\times 100 \\ \\mathrm{kWh} = 400,000 \\ \\mathrm{kWh}\n$$\nNow, we calculate the marginal cost in $\\$/\\mathrm{kWh}$:\n$$\n\\lambda = \\frac{C_{\\mathrm{rep}}}{E_{\\mathrm{total}}} = \\frac{\\$100,000}{400,000 \\ \\mathrm{kWh}} = \\$0.25 \\ \\text{per kWh}\n$$\nFinally, we convert this value to $\\$/\\mathrm{MWh}$:\n$$\n\\lambda_{\\mathrm{MWh}} = \\$0.25 \\ \\frac{1}{\\mathrm{kWh}} \\times \\frac{1000 \\ \\mathrm{kWh}}{1 \\ \\mathrm{MWh}} = \\$250 \\ \\text{per MWh}\n$$\nAlternatively, using the combined formula:\n$$\n\\lambda_{\\mathrm{MWh}} = 1000 \\times \\frac{100,000}{4,000 \\times 100} = 1000 \\times \\frac{100,000}{400,000} = 1000 \\times 0.25 = 250\n$$\nThe result, $250$, is an integer. Therefore, the rounding rule does not apply. The marginal degradation cost is $\\$250$ per MWh.",
            "answer": "$$\\boxed{250}$$"
        },
        {
            "introduction": "Simple linear cost models, while useful, fail to capture the nuances of battery wear, where cycle depth and operational patterns have highly non-linear effects. This advanced, implementation-focused practice tackles this challenge by building a sophisticated surrogate model for a high-fidelity degradation assessment based on the rainflow counting algorithm. You will develop a cutting-plane algorithm to construct a piecewise-linear, convex underestimator of the true degradation cost, creating a representation that is both accurate and compatible with convex optimization frameworks. This capstone exercise bridges the gap between complex fatigue analysis and tractable planning models, a key skill in state-of-the-art energy system modeling. ",
            "id": "4071249",
            "problem": "You are asked to design and implement a cutting-plane algorithm that constructs a piecewise-linear convex surrogate for rainflow-based battery degradation cost over a discrete State of Charge (SoC) trajectory domain. The surrogate must be iteratively refined using offline rainflow evaluations to reduce approximation gaps on a finite sample pool, thereby emulating planning-model compatible representations of battery degradation.\n\nStart from the following context-appropriate fundamental base:\n\n- A battery State of Charge trajectory over a discretized horizon is a vector $s \\in \\mathcal{S} = [0,1]^T$, where $T$ is the number of time steps and each component $s_t \\in [0,1]$ denotes SoC at time step $t$.\n- The classical rainflow counting algorithm maps any sequence $s \\in \\mathcal{S}$ to a multiset of cycles $\\{(d_i, w_i)\\}_i$, where each $d_i \\in [0,1]$ is a cycle depth (amplitude between adjacent extrema) and $w_i \\in \\{1, \\tfrac{1}{2}\\}$ is the cycle weight (full or half cycle). The algorithm is memoryless with respect to cycle concatenation and is widely used for cycle extraction.\n- The total degradation cost under a cycle-depth penalty is\n$$\nf(s) \\;=\\; \\sum_{i} \\kappa\\, \\phi(d_i)\\, w_i,\n$$\nwhere $\\kappa > 0$ is a scaling constant and $\\phi(d)$ is convex and non-decreasing in $d$. For this problem, take $\\phi(d) = d^\\alpha$ with $\\alpha \\ge 2$, which is convex on $[0,1]$.\n- A well-tested observation from the literature is that if $\\phi(d)$ is convex and non-decreasing, then the rainflow-aggregated degradation $f(s)$ is a convex functional of the SoC trajectory $s$.\n\nYour tasks:\n\n1. Implement a function that computes $f(s)$ using the classical rainflow counting method on $s \\in [0,1]^T$ with the penalty $\\phi(d) = d^\\alpha$. The cycle extraction must be scientifically sound: identify reversals (local extrema), apply the rainflow criteria to count closed cycles with weight $1$ and residual half cycles with weight $\\tfrac{1}{2}$, and compute the sum of $\\kappa d^\\alpha$ times weights.\n2. Implement an iterative cutting-plane algorithm that builds a piecewise-linear convex surrogate\n$$\ng(s) \\;=\\; \\max_{k=1,\\dots,K} \\left\\{ a_k + b_k^\\top s \\right\\}\n$$\nas an underestimator of $f(s)$ over a finite sample pool $\\mathcal{X} \\subset \\mathcal{S}$. Each cut is constructed at an anchor $x_k \\in \\mathcal{X}$ using an approximate subgradient $b_k$ obtained via finite differences:\n   - For each coordinate $j \\in \\{1,\\dots,T\\}$, approximate $\\frac{\\partial f}{\\partial s_j}(x_k)$ by forward or central differences with a small perturbation $\\varepsilon > 0$, respecting the bounds $[0,1]$ by clipping. Use central differences $\\frac{f(x_k + \\varepsilon e_j) - f(x_k - \\varepsilon e_j)}{2\\varepsilon}$ when both perturbed points lie in $[0,1]^T$, and one-sided differences otherwise.\n   - To ensure the cut underestimates on $\\mathcal{X}$, introduce a scalar $\\gamma_k \\in (0,1]$ that scales the approximate subgradient based on offline evaluations of $f$ at all $s \\in \\mathcal{X}$. Define the cut as\n     $$\n     h_k(s) \\;=\\; f(x_k) + \\gamma_k\\, b_k^\\top (s - x_k),\n     $$\n     and choose $\\gamma_k$ to satisfy $h_k(s) \\le f(s)$ for all $s \\in \\mathcal{X}$ whenever possible. One way to achieve this is\n     $$\n     \\gamma_k \\;=\\; \\min\\left\\{\\, 1, \\; \\min_{s \\in \\mathcal{X}:\\; b_k^\\top(s-x_k) > 0} \\frac{f(s)-f(x_k)}{b_k^\\top(s-x_k)} \\,\\right\\},\n     $$\n     with the convention that the inner minimum over an empty set equals $1$. If the outer minimum is negative due to numerical artifacts, replace it by $0$, which yields the constant cut $h_k(s) = f(x_k)$.\n   - Set $a_k = f(x_k) - (\\gamma_k b_k)^\\top x_k$ and $b_k \\leftarrow \\gamma_k b_k$, so the surrogate is $g(s) = \\max_k \\{a_k + b_k^\\top s\\}$.\n3. Construct an initial set of anchors (for example, constant and structured trajectories) and iteratively refine:\n   - Evaluate $f(s)$ for all $s \\in \\mathcal{X}$.\n   - Build initial cuts at chosen anchors.\n   - At each iteration, compute the approximation gaps $\\Delta(s) = f(s) - g(s)$ for all $s \\in \\mathcal{X}$, select the $s^\\star$ that maximizes $\\Delta(s)$, add a cut at $x = s^\\star$ using the procedure above, and repeat until either $\\max_{s \\in \\mathcal{X}} \\Delta(s) \\le \\tau$ or a maximum number $K_{\\max}$ of cuts is reached. Here $\\tau > 0$ is a tolerance.\n4. Return the final maximum approximation gap $\\max_{s \\in \\mathcal{X}} \\Delta(s)$ for each test case as a float without units. All outputs are dimensionless because the objective uses $\\kappa$ and exponents on normalized depths; do not include any unit labels.\n\nTest suite and required program output:\n\nImplement the above for the following parameter sets, using a fixed random seed for reproducibility in generating $\\mathcal{X}$ whenever randomness is used. For each case, construct $\\mathcal{X}$ by including some fixed structured trajectories (for example, the zero sequence, a ramp, a triangular wave, and a constant sequence) and then adding random trajectories normalized to $[0,1]^T$.\n\n- Case A (happy path):\n  - $T = 24$, $N = 30$, $\\kappa = 1.0$, $\\alpha = 2.5$, $\\varepsilon = 10^{-3}$, $\\tau = 10^{-4}$, $K_{\\max} = 30$, random seed fixed.\n- Case B (boundary emphasis with many nearly constant segments):\n  - $T = 12$, $N = 12$, $\\kappa = 1.0$, $\\alpha = 3.0$, $\\varepsilon = 10^{-3}$, $\\tau = 10^{-3}$, $K_{\\max} = 20$, random seed fixed.\n- Case C (strong convexity of cycle penalty):\n  - $T = 16$, $N = 25$, $\\kappa = 1.0$, $\\alpha = 4.0$, $\\varepsilon = 10^{-3}$, $\\tau = 10^{-4}$, $K_{\\max} = 30$, random seed fixed.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with the entries ordered as $[\\text{gap}_A,\\text{gap}_B,\\text{gap}_C]$, where each $\\text{gap}$ is the final maximum approximation gap for the corresponding case expressed as a float (dimensionless). No other text should be printed.",
            "solution": "The objective is to design and implement a cutting-plane algorithm to construct a piecewise-linear, convex surrogate function $g(s)$ that approximates a complex, non-linear battery degradation cost function, $f(s)$. The cost function $f(s)$ is based on the rainflow-counting analysis of a battery's State of Charge (SoC) trajectory, $s \\in [0,1]^T$. The surrogate $g(s)$ must be an underestimator of $f(s)$ and is intended for use within computationally tractable planning and optimization models. The algorithm iteratively refines the surrogate by adding cutting planes at points of maximum approximation error, evaluated over a finite pool of sample trajectories $\\mathcal{X}$.\n\nThe methodological approach is structured into three main components: the definition and computation of the degradation cost function $f(s)$; the formulation of the cutting-plane algorithm; and the specific procedure for generating each cut.\n\n### 1. The Degradation Cost Functional $f(s)$\n\nThe degradation cost $f(s)$ for an SoC trajectory $s = (s_1, \\dots, s_T)$ is defined as the aggregated cost over all stress cycles identified by the rainflow-counting algorithm. The formula is given by:\n$$\nf(s) = \\sum_{i} \\kappa\\, \\phi(d_i)\\, w_i\n$$\nwhere $\\kappa > 0$ is a scaling constant, and the summation is over all cycles identified in the trajectory $s$. Each cycle $i$ is characterized by a depth (amplitude) $d_i \\in [0,1]$ and a weight $w_i \\in \\{1, \\frac{1}{2}\\}$, corresponding to a full or half cycle, respectively. The function $\\phi(d)$ quantifies the stress induced by a cycle of depth $d$. For this problem, we use the convex, non-decreasing function $\\phi(d) = d^{\\alpha}$ with $\\alpha \\ge 2$.\n\nThe computation of $f(s)$ is performed via the following steps:\n1.  **Reversal Identification**: The input trajectory $s$ is first processed to identify its sequence of local extrema, known as reversals. This involves filtering out consecutive identical values to form a compact sequence, and then extracting all points that are local maxima or minima, including the start and end points of the trajectory.\n2.  **Rainflow Cycle Counting**: A stack-based algorithm, compliant with standards such as ASTM E1049, is applied to the sequence of reversals. The algorithm processes reversals one by one. For a trio of consecutive reversals $(Y, X, P)$, if the range of the current segment $|P-X|$ is greater than or equal to the range of the previous segment $|X-Y|$, a full cycle of depth $|X-Y|$ is counted, and both $X$ and $Y$ are removed from consideration. This process is repeated until no more full cycles can be closed.\n3.  **Residual Half-Cycles**: Any reversals remaining on the stack after processing the entire trajectory form residual half-cycles. For each adjacent pair of remaining reversals $(Y, X)$, a half-cycle of depth $|X-Y|$ is counted.\n4.  **Cost Aggregation**: The total degradation cost $f(s)$ is computed by summing the penalty $\\kappa d_i^\\alpha$ for each counted cycle $i$, weighted by its corresponding weight $w_i$.\n\n### 2. The Cutting-Plane Algorithm\n\nThe algorithm constructs the surrogate $g(s)$ as the pointwise maximum of a set of affine functions (cuts):\n$$\ng(s) = \\max_{k=1,\\dots,K} \\{ a_k + b_k^\\top s \\}\n$$\nThis form ensures that $g(s)$ is a convex and piecewise-linear function. The algorithm iteratively adds cuts to improve the approximation quality over the sample pool $\\mathcal{X}$.\n\nThe procedure is as follows:\n1.  **Initialization**:\n    - A sample pool $\\mathcal{X}$ of $N$ SoC trajectories is generated. This pool includes a set of deterministic, structured trajectories (e.g., constant, ramp, triangular wave) to cover fundamental behaviors, and a set of random trajectories to ensure diverse coverage of the space $\\mathcal{S}=[0,1]^T$.\n    - The exact degradation cost $f(s)$ is pre-computed and cached for every sample $s \\in \\mathcal{X}$.\n    - An initial set of cuts is generated using the structured trajectories as anchor points $x_k$. This provides a foundational approximation.\n2.  **Iterative Refinement**: The algorithm enters a loop that continues until either the maximum number of cuts $K_{\\max}$ is reached or the approximation error is acceptably small.\n    - In each iteration, the current surrogate $g(s)$ is evaluated for all $s \\in \\mathcal{X}$.\n    - The approximation gap is calculated for each sample: $\\Delta(s) = f(s) - g(s)$.\n    - The sample $s^\\star$ that exhibits the maximum gap is identified: $s^\\star = \\arg\\max_{s \\in \\mathcal{X}} \\Delta(s)$.\n    - If $\\Delta(s^\\star)$ is below a specified tolerance $\\tau$, the algorithm terminates.\n    - Otherwise, a new cut is generated using $s^\\star$ as the anchor point $x_k$, and this cut is added to the set defining $g(s)$.\n\n### 3. Cut Generation\n\nA new cut at an anchor point $x_k \\in \\mathcal{X}$ is an affine function $h_k(s) = a_k + b_k^\\top s$ designed to be a valid underestimator of $f(s)$. Its construction involves two main steps:\n\n1.  **Subgradient Approximation**: Since $f(s)$ is complex and may not be continuously differentiable, we use an approximate subgradient, which provides the linear term $b_k$. This vector is computed using a finite difference scheme. For each component $j \\in \\{1, \\dots, T\\}$, the partial derivative $\\frac{\\partial f}{\\partial s_j}(x_k)$ is approximated. To handle the domain boundaries at $s_j=0$ and $s_j=1$, a generalized central difference formula is used:\n    $$\n    b_{k,j} = \\frac{f(\\text{clip}(x_k + \\varepsilon e_j)) - f(\\text{clip}(x_k - \\varepsilon e_j))}{\\text{clip}(x_{k,j} + \\varepsilon) - \\text{clip}(x_{k,j} - \\varepsilon)}\n    $$\n    where $e_j$ is the $j$-th standard basis vector, $\\varepsilon$ is a small perturbation, and $\\text{clip}(\\cdot)$ ensures the argument remains in $[0,1]$. This formulation gracefully transitions from a central difference in the interior of the domain to a one-sided (forward or backward) difference at the boundaries.\n\n2.  **Underestimation Guarantee**: The approximate subgradient does not guarantee that the resulting tangent plane $f(x_k) + b_k^\\top (s - x_k)$ is a global underestimator. To enforce this property over the known sample pool $\\mathcal{X}$, the gradient $b_k$ is scaled by a factor $\\gamma_k \\in [0,1]$. This factor is chosen to be the largest value that prevents the cut from \"overshooting\" $f(s)$ for any sample in $\\mathcal{X}$. It is defined as:\n    $$\n    \\gamma_k = \\min\\left\\{ 1, \\min_{s \\in \\mathcal{X} : b_k^\\top(s-x_k) > 0} \\frac{f(s)-f(x_k)}{b_k^\\top(s-x_k)} \\right\\}\n    $$\n    The inner minimum is taken over all samples where the cut lies above the anchor value. If this set is empty, $\\gamma_k=1$. If numerical artifacts lead to a negative minimum, $\\gamma_k$ is set to $0$. The final cut is defined by the scaled gradient $b_k' = \\gamma_k b_k$ and the intercept $a_k = f(x_k) - (b_k')^\\top x_k$.\n\nThis iterative process constructs a high-quality, convex, piecewise-linear underestimator $g(s)$ for the complex degradation function $f(s)$, making it suitable for integration into large-scale energy system optimization problems. The final output is the maximum approximation gap over the sample pool upon termination.",
            "answer": "```python\nimport numpy as np\n\ndef _get_reversals(series):\n    \"\"\"Extracts the reversal points from a time series.\"\"\"\n    if not isinstance(series, np.ndarray):\n        series = np.array(series)\n    \n    # Filter out consecutive duplicates\n    if series.size == 0:\n        return []\n    \n    unique_series = [series[0]]\n    for i in range(1, len(series)):\n        if series[i] != series[i-1]:\n            unique_series.append(series[i])\n    \n    if len(unique_series)  3:\n        return unique_series\n\n    # Identify extrema\n    reversals = [unique_series[0]]\n    for i in range(1, len(unique_series) - 1):\n        p_prev, p_curr, p_next = unique_series[i-1], unique_series[i], unique_series[i+1]\n        is_peak = p_curr > p_prev and p_curr > p_next\n        is_valley = p_curr  p_prev and p_curr  p_next\n        if is_peak or is_valley:\n            reversals.append(p_curr)\n    reversals.append(unique_series[-1])\n    \n    return reversals\n\ndef rainflow_cost(s, kappa, alpha):\n    \"\"\"Computes the rainflow-based degradation cost for an SoC trajectory.\"\"\"\n    reversals = _get_reversals(s)\n    if len(reversals)  2:\n        return 0.0\n\n    cycles = []\n    stack = []\n\n    for p in reversals:\n        while len(stack) >= 2:\n            x = stack[-1]\n            y = stack[-2]\n            range_xy = abs(x - y)\n            range_px = abs(p - x)\n            if range_px >= range_xy:\n                cycles.append({'depth': range_xy, 'weight': 1.0})\n                stack.pop()\n                stack.pop()\n            else:\n                break\n        stack.append(p)\n\n    while len(stack) >= 2:\n        x = stack.pop()\n        y = stack[-1]\n        range_yx = abs(y - x)\n        cycles.append({'depth': range_yx, 'weight': 0.5})\n    \n    total_cost = sum(kappa * (c['depth']**alpha) * c['weight'] for c in cycles)\n    return total_cost\n\ndef calculate_subgradient(s_anchor_tuple, f_eval_func, T, epsilon):\n    \"\"\"Calculates the approximate subgradient using a generalized finite difference.\"\"\"\n    s_anchor = np.array(s_anchor_tuple)\n    b = np.zeros(T)\n    \n    for j in range(T):\n        s_plus_val = min(s_anchor[j] + epsilon, 1.0)\n        s_minus_val = max(s_anchor[j] - epsilon, 0.0)\n\n        s_plus = s_anchor.copy()\n        s_plus[j] = s_plus_val\n        f_plus = f_eval_func(tuple(s_plus))\n\n        s_minus = s_anchor.copy()\n        s_minus[j] = s_minus_val\n        f_minus = f_eval_func(tuple(s_minus))\n\n        delta_s_j = s_plus_val - s_minus_val\n        if delta_s_j > 1e-12:\n            b[j] = (f_plus - f_minus) / delta_s_j\n        else:\n            b[j] = 0.0\n    return b\n\ndef solve():\n    \"\"\"Main solver function to run the cutting-plane algorithm for all test cases.\"\"\"\n    test_cases = [\n        # Case A: T, N, kappa, alpha, epsilon, tau, K_max, seed\n        (24, 30, 1.0, 2.5, 1e-3, 1e-4, 30, 42),\n        # Case B: T, N, kappa, alpha, epsilon, tau, K_max, seed\n        (12, 12, 1.0, 3.0, 1e-3, 1e-3, 20, 42),\n        # Case C: T, N, kappa, alpha, epsilon, tau, K_max, seed\n        (16, 25, 1.0, 4.0, 1e-3, 1e-4, 30, 42),\n    ]\n\n    results = []\n\n    for case in test_cases:\n        T, N, kappa, alpha, epsilon, tau, K_max, seed = case\n        \n        rng = np.random.default_rng(seed)\n\n        # 1. Generate sample pool X\n        structured_trajs = []\n        structured_trajs.append(np.zeros(T))\n        structured_trajs.append(np.full(T, 0.5))\n        structured_trajs.append(np.linspace(0, 1, T))\n        \n        half = T // 2\n        s_tri = np.zeros(T)\n        if half > 0:\n            s_tri[:half] = np.linspace(0, 1, half, endpoint=False)\n        if T - half > 0:\n            s_tri[half:] = np.linspace(1, 0, T - half)\n        structured_trajs.append(s_tri)\n\n        num_random = N - len(structured_trajs)\n        random_trajs = [rng.random(T) for _ in range(num_random)]\n        \n        X_list = structured_trajs + random_trajs\n        X_tuples = [tuple(s) for s in X_list]\n\n        # 2. Pre-compute f(s) for all s in X using a cache\n        f_cache = {}\n        def f(s_tuple):\n            if s_tuple in f_cache:\n                return f_cache[s_tuple]\n            cost = rainflow_cost(s_tuple, kappa, alpha)\n            f_cache[s_tuple] = cost\n            return cost\n\n        f_X = {s_tuple: f(s_tuple) for s_tuple in X_tuples}\n\n        # 3. Initialize cuts from structured trajectories\n        cuts = []\n        initial_anchors = [tuple(s) for s in structured_trajs]\n\n        for xk_tuple in initial_anchors:\n            b_k = calculate_subgradient(xk_tuple, f, T, epsilon)\n            f_xk = f_X[xk_tuple]\n            \n            ratios = []\n            xk_arr = np.array(xk_tuple)\n            for s_tuple in X_tuples:\n                s_arr = np.array(s_tuple)\n                dot_product = b_k.dot(s_arr - xk_arr)\n                if dot_product > 1e-9:\n                    ratio = (f_X[s_tuple] - f_xk) / dot_product\n                    ratios.append(ratio)\n            \n            gamma_k = min(1.0, min(ratios)) if ratios else 1.0\n            gamma_k = max(0.0, gamma_k)\n\n            b_k_final = gamma_k * b_k\n            a_k = f_xk - b_k_final.dot(xk_arr)\n            cuts.append((a_k, b_k_final))\n\n        # 4. Iterative refinement loop\n        max_gap = float('inf')\n        num_cuts = len(cuts)\n        while num_cuts  K_max:\n            # Find current max gap and corresponding point s_star\n            current_max_gap = -1.0\n            s_star_tuple = None\n\n            for s_tuple in X_tuples:\n                s_arr = np.array(s_tuple)\n                g_s = max(a + b.dot(s_arr) for a, b in cuts) if cuts else 0.0\n                gap = f_X[s_tuple] - g_s\n                if gap > current_max_gap:\n                    current_max_gap = gap\n                    s_star_tuple = s_tuple\n            \n            max_gap = current_max_gap\n            \n            if max_gap = tau:\n                break\n            \n            # Add new cut at s_star\n            x_new_tuple = s_star_tuple\n            b_new = calculate_subgradient(x_new_tuple, f, T, epsilon)\n            f_xnew = f_X[x_new_tuple]\n\n            ratios = []\n            x_new_arr = np.array(x_new_tuple)\n            for s_tuple in X_tuples:\n                s_arr = np.array(s_tuple)\n                dot_product = b_new.dot(s_arr - x_new_arr)\n                if dot_product > 1e-9:\n                    ratio = (f_X[s_tuple] - f_xnew) / dot_product\n                    ratios.append(ratio)\n            \n            gamma_new = min(1.0, min(ratios)) if ratios else 1.0\n            gamma_new = max(0.0, gamma_new)\n            \n            b_new_final = gamma_new * b_new\n            a_new = f_xnew - b_new_final.dot(x_new_arr)\n            cuts.append((a_new, b_new_final))\n            num_cuts += 1\n        \n        # 5. Calculate final max gap after loop terminates\n        final_max_gap = -1.0\n        if not X_tuples:\n             final_max_gap = 0.0\n        else:\n            for s_tuple in X_tuples:\n                s_arr = np.array(s_tuple)\n                g_s = max(a + b.dot(s_arr) for a, b in cuts) if cuts else 0.0\n                gap = f_X[s_tuple] - g_s\n                if gap > final_max_gap:\n                    final_max_gap = gap\n        \n        results.append(final_max_gap)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.8f}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}