{
    "hands_on_practices": [
        {
            "introduction": "准确预测风力涡轮机轮毂高度处的风速，是风能发电建模的基石。本练习将引导你从大气边界层物理学的基本原理出发，推导出对数风廓线，并将其应用于根据参考高度的测量值来计算轮毂高度风速的实际任务中。通过进一步考虑地形引起的风速加速效应，本练习旨在强化你将物理模型应用于实际风资源评估问题的能力。",
            "id": "4134886",
            "problem": "一个风力涡轮机场址的特征是其上游具有水平均质的表面，粗糙度长度为 $z_{0}$，且大气稳定性为中性。气象塔上一个经过校准的风杯式风速计报告了在离地参考高度 $z_{\\mathrm{ref}}$ 处的 $10$ 分钟平均水平风速 $U_{\\mathrm{ref}}$。涡轮机轮毂高度为 $z_{h}$。在场址附近，气流遇到一个平缓的二维山脊，其山脊线与涡轮机排平行，因此平均气流垂直于山脊。该山脊相对于周围平原的几何高度为 $H$，逆风坡长度尺度为 $L$（定义为从平原到山脊线的水平距离），且 $H/L \\ll 1$。假设平原和山脊上的粗糙度长度相同，且位移高度可以忽略不计。\n\n从以下关于粗糙表面上中性层结、定常、水平均质的湍流边界层流动的基本原理出发：\n- 垂直湍流动量通量（切应力）不随高度变化，可以表示为 $\\tau = \\rho\\,u_{*}^{2}$，其中 $\\rho$ 是空气密度，$u_{*}$ 是摩擦速度，\n- 使用涡黏性（动量扩散系数）$K_{m}$ 和通量-梯度关系 $\\tau = \\rho\\,K_{m}\\,\\frac{\\mathrm{d}U}{\\mathrm{d}z}$ 的一阶闭合，\n- 在中性稳定条件下，由混合长度理论得出 $K_{m} = \\kappa\\,u_{*}\\,z$，\n\n推导出平坦地形上的平均风速廓线 $U(z)$，并利用测量的 $z_{\\mathrm{ref}}$ 处的 $U_{\\mathrm{ref}}$ 和给定的 $z_{0}$，计算平坦地形上的轮毂高度风速 $U_{\\mathrm{flat}}(z_{h})$。然后，为了考虑山脊顶部的地形引起的加速效应，采用一个适用于中性条件下平缓二维山脊的简单线性地形加速模型，其中山脊顶部的分数加速率与逆风坡度成正比，\n$$S = c\\,\\frac{H}{L},$$\n比例常数 $c = 2.0$。将山脊顶部的轮毂高度风速估算为 $U_{\\mathrm{crest}}(z_{h}) = U_{\\mathrm{flat}}(z_{h})\\,(1+S)$。\n\n使用以下数值：\n- $\\kappa = 0.40$，\n- $U_{\\mathrm{ref}} = 7.50~\\mathrm{m}\\,\\mathrm{s}^{-1}$ 在 $z_{\\mathrm{ref}} = 10~\\mathrm{m}$，\n- $z_{0} = 0.050~\\mathrm{m}$，\n- $z_{h} = 120~\\mathrm{m}$，\n- $H = 40.0~\\mathrm{m}$，\n- $L = 400.0~\\mathrm{m}$。\n\n计算 $U_{\\mathrm{crest}}(z_{h})$ 并以 $\\mathrm{m}\\,\\mathrm{s}^{-1}$ 为单位表示您的最终答案。将您的答案四舍五入到四位有效数字。",
            "solution": "问题陈述已解析和验证。\n\n### 步骤1：提取已知条件\n- 上游表面粗糙度长度：$z_{0}$\n- 大气稳定性：中性\n- 参考平均水平风速：在参考高度 $z_{\\mathrm{ref}}$ 处为 $U_{\\mathrm{ref}}$\n- 涡轮机轮毂高度：$z_{h}$\n- 山脊几何高度：$H$\n- 山脊逆风坡长度尺度：$L$\n- 条件：$H/L \\ll 1$\n- 假设：粗糙度长度是均匀的。\n- 假设：位移高度可以忽略不计。\n- 基本原理1：垂直湍流动量通量（切应力）为 $\\tau = \\rho\\,u_{*}^{2}$，其中 $\\rho$ 是空气密度，$u_{*}$ 是摩擦速度。$\\tau$ 不随高度变化。\n- 基本原理2：通量-梯度关系为 $\\tau = \\rho\\,K_{m}\\,\\frac{\\mathrm{d}U}{\\mathrm{d}z}$，其中 $K_{m}$ 为涡黏性。\n- 基本原理3：涡黏性的混合长度模型为 $K_{m} = \\kappa\\,u_{*}\\,z$。\n- 地形加速模型：山脊顶部的分数加速率为 $S = c\\,\\frac{H}{L}$。\n- 山脊顶部轮毂高度风速：$U_{\\mathrm{crest}}(z_{h}) = U_{\\mathrm{flat}}(z_{h})\\,(1+S)$。\n- 数值：\n    - von Kármán 常数，$\\kappa = 0.40$\n    - $U_{\\mathrm{ref}} = 7.50~\\mathrm{m}\\,\\mathrm{s}^{-1}$\n    - $z_{\\mathrm{ref}} = 10~\\mathrm{m}$\n    - $z_{0} = 0.050~\\mathrm{m}$\n    - $z_{h} = 120~\\mathrm{m}$\n    - $H = 40.0~\\mathrm{m}$\n    - $L = 400.0~\\mathrm{m}$\n    - 比例常数，$c = 2.0$\n\n### 步骤2：使用提取的已知条件进行验证\n该问题具有科学依据，提法得当且客观。它基于大气边界层物理学的标准、成熟原理（对数风廓线）和一个用于描述平缓地形上流动的常用简化模型（线性理论）。该问题是自洽的，提供了所有必要的物理假设和数值数据。条件 $H/L = 40.0/400.0 = 0.1 \\ll 1$ 得到满足，这为使用线性加速模型提供了依据。所提供的值在风资源评估的背景下是物理上现实的。该问题不是不适定的、矛盾的或琐碎的。\n\n### 步骤3：结论和行动\n该问题有效。将提供完整解答。\n\n### 解题推导\n首要任务是根据所提供的关于中性层结、定常、水平均质湍流边界层的基本原理，推导出平坦地形上的平均风速廓线 $U(z)$。\n\n我们有两个关于切应力 $\\tau$ 的表达式：\n$$\n\\tau = \\rho\\,u_{*}^{2}\n$$\n和\n$$\n\\tau = \\rho\\,K_{m}\\,\\frac{\\mathrm{d}U}{\\mathrm{d}z}\n$$\n将这两个表达式相等，并除以空气密度 $\\rho$，得到：\n$$\nu_{*}^{2} = K_{m}\\,\\frac{\\mathrm{d}U}{\\mathrm{d}z}\n$$\n接下来，我们代入给定的涡黏性混合长度模型，$K_{m} = \\kappa\\,u_{*}\\,z$：\n$$\nu_{*}^{2} = (\\kappa\\,u_{*}\\,z)\\,\\frac{\\mathrm{d}U}{\\mathrm{d}z}\n$$\n假设摩擦速度不为零 ($u_{*} > 0$)，我们可以除以 $u_{*}$：\n$$\nu_{*} = \\kappa\\,z\\,\\frac{\\mathrm{d}U}{\\mathrm{d}z}\n$$\n这是一个关于风速 $U$ 作为高度 $z$ 函数的可分离一阶常微分方程。我们重新整理它以便积分：\n$$\n\\mathrm{d}U = \\frac{u_{*}}{\\kappa}\\,\\frac{\\mathrm{d}z}{z}\n$$\n为了求得廓线 $U(z)$，我们对这个方程进行积分。粗糙表面上流动的边界条件是风速在粗糙度长度处外推为零，即 $U(z_{0}) = 0$。我们从粗糙度高度 $z_{0}$ 积分到任意高度 $z$：\n$$\n\\int_{0}^{U(z)} \\mathrm{d}U' = \\int_{z_{0}}^{z} \\frac{u_{*}}{\\kappa}\\,\\frac{\\mathrm{d}z'}{z'}\n$$\n由于在此模型中 $u_{*}$ 和 $\\kappa$ 不随高度变化，我们有：\n$$\nU(z) = \\frac{u_{*}}{\\kappa} \\int_{z_{0}}^{z} \\frac{1}{z'}\\,\\mathrm{d}z' = \\frac{u_{*}}{\\kappa} [\\ln(z')]_{z_0}^{z}\n$$\n$$\nU(z) = \\frac{u_{*}}{\\kappa} (\\ln(z) - \\ln(z_{0}))\n$$\n使用对数的性质，我们得到对数风廓线：\n$$\nU(z) = \\frac{u_{*}}{\\kappa} \\ln\\left(\\frac{z}{z_{0}}\\right)\n$$\n该廓线描述了平坦地形上的风速，我们将其表示为 $U_{\\mathrm{flat}}(z)$。\n\n下一步是利用在高度 $z_{\\mathrm{ref}}$ 处测得的风速 $U_{\\mathrm{ref}}$ 来确定此平坦地形上轮毂高度 $z_{h}$ 处的风速 $U_{\\mathrm{flat}}(z_h)$。我们有两个对数廓线的实例：\n在参考高度：$U_{\\mathrm{ref}} = U_{\\mathrm{flat}}(z_{\\mathrm{ref}}) = \\frac{u_{*}}{\\kappa} \\ln\\left(\\frac{z_{\\mathrm{ref}}}{z_{0}}\\right)$\n在轮毂高度：$U_{\\mathrm{flat}}(z_{h}) = \\frac{u_{*}}{\\kappa} \\ln\\left(\\frac{z_{h}}{z_{0}}\\right)$\n\n为了在不显式计算中间参数 $u_{*}$ 的情况下求得 $U_{\\mathrm{flat}}(z_{h})$，我们可以取这两个方程的比值：\n$$\n\\frac{U_{\\mathrm{flat}}(z_{h})}{U_{\\mathrm{ref}}} = \\frac{\\frac{u_{*}}{\\kappa} \\ln\\left(\\frac{z_h}{z_0}\\right)}{\\frac{u_{*}}{\\kappa} \\ln\\left(\\frac{z_{\\mathrm{ref}}}{z_0}\\right)} = \\frac{\\ln\\left(z_h / z_0\\right)}{\\ln\\left(z_{\\mathrm{ref}} / z_0\\right)}\n$$\n由此，我们可以解出 $U_{\\mathrm{flat}}(z_{h})$：\n$$\nU_{\\mathrm{flat}}(z_{h}) = U_{\\mathrm{ref}} \\frac{\\ln\\left(z_{h} / z_0\\right)}{\\ln\\left(z_{\\mathrm{ref}} / z_0\\right)}\n$$\n现在我们代入给定的数值：$U_{\\mathrm{ref}} = 7.50~\\mathrm{m}\\,\\mathrm{s}^{-1}$，$z_{\\mathrm{ref}} = 10~\\mathrm{m}$，$z_{h} = 120~\\mathrm{m}$，以及 $z_{0} = 0.050~\\mathrm{m}$。\n$$\n\\frac{z_{h}}{z_{0}} = \\frac{120}{0.050} = 2400\n$$\n$$\n\\frac{z_{\\mathrm{ref}}}{z_{0}} = \\frac{10}{0.050} = 200\n$$\n将这些值代入 $U_{\\mathrm{flat}}(z_h)$ 的方程中：\n$$\nU_{\\mathrm{flat}}(z_{h}) = 7.50 \\times \\frac{\\ln(2400)}{\\ln(200)} \\approx 7.50 \\times \\frac{7.78322}{5.29832} \\approx 7.50 \\times 1.46898 \\approx 11.01735~\\mathrm{m}\\,\\mathrm{s}^{-1}\n$$\n接下来，我们计算由山脊引起的分数加速率 $S$。给定的模型是 $S = c\\,\\frac{H}{L}$。我们代入数值 $c = 2.0$，$H = 40.0~\\mathrm{m}$ 和 $L = 400.0~\\mathrm{m}$：\n$$\nS = 2.0 \\times \\frac{40.0}{400.0} = 2.0 \\times 0.1 = 0.2\n$$\n问题陈述指出，山脊顶部的轮毂高度风速 $U_{\\mathrm{crest}}(z_{h})$ 由公式 $U_{\\mathrm{crest}}(z_{h}) = U_{\\mathrm{flat}}(z_{h})\\,(1+S)$ 给出。\n我们使用刚刚计算出的 $U_{\\mathrm{flat}}(z_{h})$ 和 $S$ 的值：\n$$\nU_{\\mathrm{crest}}(z_{h}) = 11.01735 \\times (1 + 0.2) = 11.01735 \\times 1.2\n$$\n$$\nU_{\\mathrm{crest}}(z_{h}) \\approx 13.22082~\\mathrm{m}\\,\\mathrm{s}^{-1}\n$$\n问题要求将最终答案四舍五入到四位有效数字。\n$$\nU_{\\mathrm{crest}}(z_{h}) \\approx 13.22~\\mathrm{m}\\,\\mathrm{s}^{-1}\n$$",
            "answer": "$$\n\\boxed{13.22}\n$$"
        },
        {
            "introduction": "在对可变可再生能源（VRE）的发电量进行建模后，下一步是理解其对电力系统的影响。本练习的核心是“净负荷”——即总负荷减去VRE发电量——以及其统计特性（如爬坡率）如何随着VRE渗透率的增加而变化。这是一个至关重要的练习，可以帮助你深入理解VRE给电网稳定性带来的挑战，并掌握量化这些挑战所需的数据分析技能。",
            "id": "4134860",
            "problem": "考虑一个单区域电力系统，其小时时间索引为 $t \\in \\{0,1,\\dots,T-1\\}$，其中 $T = 168$ 小时（一周）。定义净负荷为 $L_{\\text{net}}(t) = L(t) - G_{\\text{VRE}}(t)$，其中 $L(t)$ 是总负荷，$G_{\\text{VRE}}(t)$ 是可变可再生能源（VRE）的发电量。假设采用以下建模框架，该框架必须严格按照规定实现。\n\n基本依据和定义：\n- 能量平衡定义：对于每个小时 $t$，净负荷 $L_{\\text{net}}(t)$ 等于总负荷 $L(t)$ 减去 VRE 发电量 $G_{\\text{VRE}}(t)$。\n- VRE 发电模型：$G_{\\text{VRE}}(t) = C \\cdot \\text{CF}(t)$，其中 $C$ 是 VRE 的装机容量（单位：兆瓦），$\\text{CF}(t)$ 是 VRE 的容量因子（无量纲），满足 $0 \\le \\text{CF}(t) \\le 1$。\n- 渗透率定义：能量渗透率水平 $p$ 定义为在整个时间范围内平均 VRE 发电量与平均负荷的比值，即 $p = \\dfrac{\\frac{1}{T}\\sum_{t=0}^{T-1} G_{\\text{VRE}}(t)}{\\frac{1}{T}\\sum_{t=0}^{T-1} L(t)}$。在 $G_{\\text{VRE}}(t) = C \\cdot \\text{CF}(t)$ 模型下，这意味着 $C = p \\cdot \\dfrac{\\frac{1}{T}\\sum_{t=0}^{T-1} L(t)}{\\frac{1}{T}\\sum_{t=0}^{T-1} \\text{CF}(t)}$。\n- 爬坡定义：对于小时时间步长 $\\Delta t = 1$ 小时，净负荷爬坡为 $R(t) = L_{\\text{net}}(t) - L_{\\text{net}}(t-1)$，其中 $t \\in \\{1,2,\\dots,T-1\\}$。\n\n三角函数约定：所有三角函数参数均以弧度为单位。\n\n合成负荷与容量因子：\n- 假设以兆瓦为单位的负荷 $L(t)$ 由下式给出\n$$\nL(t) = L_0 + A_d \\sin\\!\\left(2\\pi \\frac{t}{24} - \\phi_d\\right) + A_w \\sin\\!\\left(2\\pi \\frac{t}{168} - \\phi_w\\right) + A_f \\sin\\!\\left(2\\pi \\frac{t}{8}\\right),\n$$\n其中 $L_0 = 1000$，$A_d = 150$，$A_w = 100$，$\\phi_d = \\frac{\\pi}{3}$，$\\phi_w = \\frac{\\pi}{4}$，以及 $A_f = 50$。\n- 假设容量因子 $\\text{CF}(t)$ 是类太阳能和类风能分量的凸组合：\n    - 定义日内小时 $h(t) = t \\bmod 24$。太阳能分量为\n    $$\n    \\text{CF}_{\\text{solar}}(t) = \\left[\\max\\!\\left(0, \\sin\\!\\left(\\pi \\frac{h(t)}{24}\\right)\\right)\\right]^{\\alpha},\n    $$\n    其中 $\\alpha = 1.5$。\n    - 风能分量为\n    $$\n    \\text{CF}_{\\text{wind}}(t) = \\operatorname{clip}\\!\\left(0.4 + 0.2 \\sin\\!\\left(2\\pi \\cdot 0.7 \\cdot \\frac{t}{24} + \\frac{\\pi}{6}\\right) + 0.1 \\sin\\!\\left(2\\pi \\frac{t}{168} + \\frac{\\pi}{5}\\right),\\, 0,\\, 1\\right),\n    $$\n    其中 $\\operatorname{clip}(x,a,b)$ 在 $x < a$ 时取值为 $a$，在 $x > b$ 时取值为 $b$，否则取值为 $x$。\n    - 最终容量因子为 $\\text{CF}(t) = \\operatorname{clip}\\!\\left(0.6 \\cdot \\text{CF}_{\\text{solar}}(t) + 0.4 \\cdot \\text{CF}_{\\text{wind}}(t),\\, 0,\\, 1\\right)$。\n\n要评估的统计特性：\n- 必须计算以下八个统计特性：$1.$ 最大净负荷 ($\\mathrm{MW}$), $2.$ 最小净负荷 ($\\mathrm{MW}$), $3.$ 最大净负荷时间（小时索引 $t$）, $4.$ 最小净负荷时间（小时索引 $t$）, $5.$ 最大净负荷上爬坡率 ($\\mathrm{MW/h}$), $6.$ 最大净负荷下爬坡率 ($\\mathrm{MW/h}$), $7.$ 净负荷爬坡率的标准差 ($\\mathrm{MW/h}$)，以及 $8.$ 绝对净负荷爬坡率的第 $99$ 百分位数 ($\\mathrm{MW/h}$)。\n- 在出现相同值的情况下，最大值和最小值的时间应返回第一个时间索引。\n- 净负荷爬坡率的标准差应作为 $\\{R(t)\\}_{t=1}^{T-1}$ 的总体标准差计算，$\\sigma_R = \\sqrt{\\frac{1}{T-1} \\sum_{t=1}^{T-1} (R(t) - \\bar{R})^2}$。\n- 第 $99$ 百分位数必须使用线性插值法计算，该方法对应于 NumPy 库中的 `linear` 方法。\n\n测试套件和输出格式：\n- 您必须为以下渗透率水平 $p \\in \\{0.0, 0.2, 0.9, 1.2\\}$ 分别计算这八个统计特性。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的列表，该列表包含四个列表，每个列表对应一个渗透率水平。每个内部列表应包含按上述顺序排列的八个统计特性的值。\n- 在每个内部列表中，浮点数结果必须四舍五入到小数点后三位，整数结果必须保持为整数。\n- 示例输出：`[[1.111,2.222,3,4,5.555,6.666,7.777,8.888],[...],[...],[...]]`",
            "solution": "所提出的问题是能源系统建模中的一个有效的计算练习。它具有科学依据，问题适定，并且所有定义和参数都已提供，以确保唯一且可验证的解。\n\n任务是分析在可变可再生能源（VRE）不同渗透率水平下，电力系统净负荷的统计特性。\n\n求解过程首先为电力负荷和 VRE 容量因子构建合成时间序列，然后计算满足指定能量渗透率水平所需的 VRE 容量，最后计算一套用于表征所得净负荷曲线的指标。\n\n基本量定义在 $T=168$ 小时（一周）的离散时间范围内，时间索引为 $t \\in \\{0, 1, \\dots, T-1\\}$。\n\n**步骤 1：生成负荷和 VRE 容量因子曲线**\n\n首先，我们生成系统负荷 $L(t)$ 和 VRE 容量因子 $\\text{CF}(t)$ 的时间序列。这些是旨在捕捉真实世界数据基本特征的合成曲线。\n\n负荷 $L(t)$ 被建模为正弦函数的叠加：\n$$\nL(t) = L_0 + A_d \\sin\\!\\left(2\\pi \\frac{t}{24} - \\phi_d\\right) + A_w \\sin\\!\\left(2\\pi \\frac{t}{168} - \\phi_w\\right) + A_f \\sin\\!\\left(2\\pi \\frac{t}{8}\\right)\n$$\n其中 $L_0 = 1000$ MW 是基本负荷。正弦项代表：\n- 周期为 $24$ 小时、振幅为 $A_d = 150$ MW 的日循环。相位移为 $\\phi_d = \\pi/3$。\n- 周期为 $168$ 小时、振幅为 $A_w = 100$ MW 的周循环。相位移为 $\\phi_w = \\pi/4$。\n- 周期为 $8$ 小时、振幅为 $A_f = 50$ MW 的高频波动，代表更快的负荷变化。\n\nVRE 容量因子 $\\text{CF}(t)$ 是太阳能和风能分量的加权平均，反映了一个混合的可再生能源组合。日内小时为 $h(t) = t \\bmod 24$。\n\n太阳能分量 $\\text{CF}_{\\text{solar}}(t)$ 被建模为在白天的时段内有效，并在正午达到峰值：\n$$\n\\text{CF}_{\\text{solar}}(t) = \\left[\\max\\!\\left(0, \\sin\\!\\left(\\pi \\frac{h(t)}{24}\\right)\\right)\\right]^{\\alpha}\n$$\n其中指数 $\\alpha = 1.5$。参数为 $\\pi h(t)/24$ 的正弦函数在一个 $24$ 小时周期内产生一个半波，模仿每日太阳辐照度模式。$\\max(0, \\dots)$ 确保了非负性，尽管对于 $h(t) \\in [0, 23]$ 来说这是多余的。\n\n风能分量 $\\text{CF}_{\\text{wind}}(t)$ 是不同频率正弦波的和，捕捉了风能资源的多尺度时间变异性：\n$$\n\\text{CF}_{\\text{wind}}(t) = \\operatorname{clip}\\!\\left(0.4 + 0.2 \\sin\\!\\left(2\\pi \\cdot 0.7 \\cdot \\frac{t}{24} + \\frac{\\pi}{6}\\right) + 0.1 \\sin\\!\\left(2\\pi \\frac{t}{168} + \\frac{\\pi}{5}\\right),\\, 0,\\, 1\\right)\n$$\n$\\operatorname{clip}(x, a, b)$ 函数确保容量因子保持在其 $[0, 1]$ 的物理边界内。\n\n最终的容量因子是一个凸组合，并被裁剪到 $[0, 1]$ 范围内：\n$$\n\\text{CF}(t) = \\operatorname{clip}\\!\\left(0.6 \\cdot \\text{CF}_{\\text{solar}}(t) + 0.4 \\cdot \\text{CF}_{\\text{wind}}(t),\\, 0,\\, 1\\right)\n$$\n\n**步骤 2：计算 VRE 容量和净负荷**\n\n对于给定的能量渗透率水平 $p$，我们确定必要的 VRE 装机容量 $C$。渗透率 $p$ 是平均 VRE 发电量与平均负荷的比值：\n$$\np = \\frac{\\bar{G}_{\\text{VRE}}}{\\bar{L}} = \\frac{\\frac{1}{T}\\sum_{t=0}^{T-1} C \\cdot \\text{CF}(t)}{\\frac{1}{T}\\sum_{t=0}^{T-1} L(t)} = C \\frac{\\overline{\\text{CF}}}{\\bar{L}}\n$$\n求解 $C$ 可得：\n$$\nC = p \\cdot \\frac{\\bar{L}}{\\overline{\\text{CF}}} = p \\cdot \\frac{\\sum_{t=0}^{T-1} L(t)}{\\sum_{t=0}^{T-1} \\text{CF}(t)}\n$$\n这在 VRE 的期望能量贡献与所需装机容量之间建立了一个直接关系，该关系由资源的平均生产率（$\\overline{\\text{CF}}$）相对于平均需求（$\\bar{L}$）来调节。\n\n一旦对于给定的 $p$ 知道了 $C$，VRE 发电时间序列就是 $G_{\\text{VRE}}(t) = C \\cdot \\text{CF}(t)$。净负荷，即必须由可调度发电厂满足的负荷，则为：\n$$\nL_{\\text{net}}(t) = L(t) - G_{\\text{VRE}}(t)\n$$\n\n**步骤 3：计算爬坡和统计指标**\n\n净负荷的变动性是电力系统运营商的一个关键问题。我们使用几个指标来量化这一点。首先，我们计算净负荷爬坡序列，它表示净负荷从一小时到下一小时的变化：\n$$\nR(t) = L_{\\text{net}}(t) - L_{\\text{net}}(t-1) \\quad \\text{for } t \\in \\{1, 2, \\dots, T-1\\}\n$$\n该爬坡序列有 $T-1 = 167$ 个数据点。\n\n使用 $L_{\\text{net}}(t)$ 和 $R(t)$ 时间序列，我们为每个测试案例的 $p$ 值计算八个指定的统计特性：\n1.  **最大净负荷**：$\\max_t L_{\\text{net}}(t)$。这决定了可调度发电机所需的峰值容量。\n2.  **最小净负荷**：$\\min_t L_{\\text{net}}(t)$。非常低或负的最小净负荷表示 VRE 过度发电的时段。\n3.  **最大净负荷时间**：$t_{\\max} = \\arg\\max_t L_{\\text{net}}(t)$，在出现相同值的情况下取第一个索引。\n4.  **最小净负荷时间**：$t_{\\min} = \\arg\\min_t L_{\\text{net}}(t)$，在出现相同值的情况下取第一个索引。\n5.  **最大上爬坡率**：$\\max_t R(t)$。这是可调度发电量所需的最快增长，是衡量系统灵活性需求的关键指标。\n6.  **最大下爬坡率**：$\\min_t R(t)$。这是可调度发电量所需的最快下降。\n7.  **爬坡标准差**：$\\sigma_R$。这被计算为爬坡序列 $\\{R(t)\\}_{t=1}^{T-1}$ 的总体标准差。提供的公式是 $\\sigma_R = \\sqrt{\\frac{1}{T-1} \\sum_{t=1}^{T-1} (R(t) - \\bar{R})^2}$，这对应于 $T-1$ 个爬坡值总体的标准差。\n8.  **绝对爬坡值的第 99 百分位数**：$\\{|R(t)|\\}$ 的 $Q_{0.99}$。极端爬坡通常比平均变动性更重要。该分位数使用指定的线性插值方法计算，该方法对应于 NumPy 库中的 `linear` 方法。\n\n对每个指定的渗透率水平 $p \\in \\{0.0, 0.2, 0.9, 1.2\\}$ 重复这些计算，并按要求聚合和格式化结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the energy systems modeling problem by calculating net load statistics\n    for different VRE penetration levels.\n    \"\"\"\n    \n    # Define constants and parameters from the problem statement\n    T = 168\n    L0 = 1000.0\n    Ad = 150.0\n    Aw = 100.0\n    Af = 50.0\n    phi_d = np.pi / 3.0\n    phi_w = np.pi / 4.0\n    alpha = 1.5\n    \n    # Time vector\n    t = np.arange(T, dtype=float)\n    \n    # --- Step 1: Generate Load and VRE Capacity Factor Profiles ---\n    \n    # Load profile L(t)\n    L_t = (L0 +\n           Ad * np.sin(2 * np.pi * t / 24.0 - phi_d) +\n           Aw * np.sin(2 * np.pi * t / 168.0 - phi_w) +\n           Af * np.sin(2 * np.pi * t / 8.0))\n    \n    # Hour of day h(t)\n    h_t = t % 24\n    \n    # Solar capacity factor CF_solar(t)\n    # The max(0, sin) is redundant as sin(pi*h/24) is non-negative for h in [0, 23]\n    CF_solar_t = np.sin(np.pi * h_t / 24.0)**alpha\n    \n    # Wind capacity factor CF_wind(t)\n    CF_wind_t = np.clip(\n        0.4 + 0.2 * np.sin(2 * np.pi * 0.7 * t / 24.0 + np.pi / 6.0) +\n        0.1 * np.sin(2 * np.pi * t / 168.0 + np.pi / 5.0),\n        0.0, 1.0\n    )\n    \n    # Combined capacity factor CF(t)\n    CF_t = np.clip(0.6 * CF_solar_t + 0.4 * CF_wind_t, 0.0, 1.0)\n    \n    # Pre-calculate averages needed for C\n    avg_L = np.mean(L_t)\n    avg_CF = np.mean(CF_t)\n\n    def calculate_metrics(p):\n        \"\"\"\n        Calculates the 8 specified metrics for a given penetration level p.\n        \"\"\"\n        # --- Step 2: Calculate VRE Capacity and Net Load ---\n        \n        # Calculate installed VRE capacity C\n        if avg_CF == 0:\n            C = 0.0\n        else:\n            C = p * avg_L / avg_CF\n            \n        # VRE generation G_VRE(t)\n        G_vre_t = C * CF_t\n        \n        # Net load L_net(t)\n        L_net_t = L_t - G_vre_t\n        \n        # --- Step 3: Calculation of Ramps and Statistical Metrics ---\n\n        # Ramp series R(t)\n        R_t = L_net_t[1:] - L_net_t[:-1]\n        \n        # 1. Max net load\n        max_L_net = np.max(L_net_t)\n        \n        # 2. Min net load\n        min_L_net = np.min(L_net_t)\n        \n        # 3. Time of max net load (first occurrence)\n        t_max = np.argmax(L_net_t)\n        \n        # 4. Time of min net load (first occurrence)\n        t_min = np.argmin(L_net_t)\n\n        # 5. Max up-ramp\n        max_R = np.max(R_t)\n        \n        # 6. Max down-ramp\n        min_R = np.min(R_t)\n        \n        # 7. Standard deviation of the ramp series\n        # The formula given is the population std dev of the ramp series,\n        # which has T-1 elements. numpy.std(ddof=0) divides by N, correct.\n        sigma_R = np.std(R_t, ddof=0)\n        \n        # 8. 99% quantile of absolute ramp\n        abs_R_t = np.abs(R_t)\n        # The specified interpolation rule matches numpy's 'linear' method.\n        Q_0_99 = np.quantile(abs_R_t, 0.99, method='linear')\n        \n        return [max_L_net, min_L_net, t_max, t_min, max_R, min_R, sigma_R, Q_0_99]\n\n    # Test suite of penetration levels\n    test_cases = [0.0, 0.2, 0.9, 1.2]\n    \n    all_results = []\n    for p_val in test_cases:\n        results = calculate_metrics(p_val)\n        all_results.append(results)\n\n    # Format the output string as specified\n    formatted_results = []\n    for case_result in all_results:\n        # Round floats to 3 decimal places, keep integers as is\n        formatted_list = [\n            f\"{val:.3f}\" if isinstance(val, (float, np.floating)) else str(val)\n            for val in case_result\n        ]\n        formatted_results.append(f\"[{','.join(formatted_list)}]\")\n    \n    # Final print statement\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "为了应对可再生能源的波动性挑战，配备储能的混合能源系统是一种关键解决方案。本练习将指导你构建并求解一个混合整数线性规划问题，为一个包含光伏、风能和储能的混合电站制定最优调度策略，以满足其确定的出力目标。通过本练习，你将学习如何运用数学规划方法制定运行决策，从而弥合资源建模与实际电网运行之间的鸿沟，确保供电的可靠性。",
            "id": "4134839",
            "problem": "考虑一个由光伏发电、风力发电和电化学储能系统组成的混合电站。设时间范围被离散为 $T$ 个小时间隔，其中 $\\Delta t = 1$ 小时。光伏可用功率曲线由一个长度为 $T$ 的数组给出，每个元素以 $\\mathrm{MW}$ 为单位。风力可用功率曲线由一个长度为 $T$ 的数组给出，每个元素以 $\\mathrm{MW}$ 为单位。固定电力供应义务是一个长度为 $T$ 的数组，每个元素以 $\\mathrm{MW}$ 为单位。储能系统具有以 $\\mathrm{MWh}$ 为单位的最大储能容量、以 $\\mathrm{MW}$ 为单位的最大充电功率、以 $\\mathrm{MW}$ 为单位的最大放电功率、充电效率（无量纲）和放电效率（无量纲）。初始荷电状态以 $\\mathrm{MWh}$ 为单位，并要求在时间范围结束时荷电状态返回到相同的值。\n\n仅从适用于能源系统建模的基本守恒原理和核心运行定义出发，推导一个混合整数线性优化模型，用于调度光伏发电、风力发电以及储能的充放电，以便在给定可变性下，在物理上可行时满足固定电力供应义务。推导必须从以下几点开始：\n\n- 储能系统在离散时间步长上的能量守恒。\n- 每个时间步长的功率平衡，将净功率与电网和固定电力供应义务联系起来。\n- 所有组件的功率和能量容量的物理限制。\n- 强制储能系统非同时充放电的二进制决策。\n\n您的推导必须产生一个适用于混合整数线性规划的公式，其中充放电决策是二进制的，所有其他决策变量是连续的。目标应是在遵守所有物理约束的同时，最小化整个时间范围内的总未满足固定电力。每个时间步长的未满足固定电力必须是一个非负松弛变量（以 $\\mathrm{MW}$ 为单位的无量纲数），其总和将被最小化。为保证数值鲁棒性，可行性评估应接受总未满足固定电力可忽略不计的解，该可忽略量由一个远小于典型 $\\mathrm{MW}$ 值的容差阈值定义。\n\n您必须实现一个程序，使用通用求解器为下面的一组测试案例求解所推导的混合整数线性优化问题，并返回每个案例的可行性。一个案例当且仅当最优总未满足固定电力在小的数值容差内等于 $0$ 时，才被视为可行。\n\n所需物理单位：\n- 所有功率量，包括光伏可用功率、风力可用功率、充电功率、放电功率、固定供应义务和未满足固定电力，必须以 $\\mathrm{MW}$ 为单位。\n- 所有能量量，包括储能容量和荷电状态，必须以 $\\mathrm{MWh}$ 为单位。\n- 此问题中不出现任何角度量。\n- 任何比率必须以小数形式报告。\n\n要实现的测试套件：\n- 案例 $1$（常规理想路径）：$T = 6$。光伏可用功率 $[3.0, 2.0, 1.0, 0.5, 1.5, 2.0]$ $\\mathrm{MW}$。风力可用功率 $[1.0, 1.5, 2.0, 1.2, 0.8, 1.5]$ $\\mathrm{MW}$。固定供应义务 $[2.0, 2.0, 2.0, 2.0, 2.0, 2.0]$ $\\mathrm{MW}$。储能参数：最大能量 $1.0 \\mathrm{MWh}$，初始荷电状态 $0.5 \\mathrm{MWh}$，最大充电功率 $1.5 \\mathrm{MW}$，最大放电功率 $1.5 \\mathrm{MW}$，充电效率 $0.95$，放电效率 $0.95$。\n- 案例 $2$（全局能量赤字）：$T = 4$。光伏可用功率 $[0.2, 0.2, 0.2, 0.2]$ $\\mathrm{MW}$。风力可用功率 $[0.1, 0.1, 0.1, 0.1]$ $\\mathrm{MW}$。固定供应义务 $[0.5, 0.5, 0.5, 0.5]$ $\\mathrm{MW}$。储能参数：最大能量 $10.0 \\mathrm{MWh}$，初始荷电状态 $0.0 \\mathrm{MWh}$，最大充电功率 $5.0 \\mathrm{MW}$，最大放电功率 $5.0 \\mathrm{MW}$，充电效率 $0.95$，放电效率 $0.95$。\n- 案例 $3$（具有可变性和精确能量规模的单谷时段）：$T = 5$。光伏可用功率 $[2.5, 2.2, 0.2, 2.1, 2.3]$ $\\mathrm{MW}$。风力可用功率 $[0.3, 0.5, 0.3, 0.2, 0.3]$ $\\mathrm{MW}$。固定供应义务 $[2.0, 2.0, 1.4, 2.0, 2.0]$ $\\mathrm{MW}$。储能参数：最大能量 $1.6 \\mathrm{MWh}$，初始荷电状态 $0.0 \\mathrm{MWh}$，最大充电功率 $1.5 \\mathrm{MW}$，最大放电功率 $1.5 \\mathrm{MW}$，充电效率 $0.95$，放电效率 $0.95$。\n- 案例 $4$（谷时段功率受限导致不可行）：$T = 3$。光伏可用功率 $[3.0, 1.0, 3.0]$ $\\mathrm{MW}$。风力可用功率 $[0.0, 0.0, 0.0]$ $\\mathrm{MW}$。固定供应义务 $[2.5, 2.5, 2.5]$ $\\mathrm{MW}$。储能参数：最大能量 $10.0 \\mathrm{MWh}$，初始荷电状态 $0.0 \\mathrm{MWh}$，最大充电功率 $3.0 \\mathrm{MW}$，最大放电功率 $1.0 \\mathrm{MW}$，充电效率 $0.95$，放电效率 $0.95$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[\\mathrm{True},\\mathrm{False},\\mathrm{True},\\mathrm{False}]$）的结果，其中每个条目是一个布尔值，如果该案例在上述定义下是可行的，则为 $\\mathrm{True}$，否则为 $\\mathrm{False}$。布尔值必须完全按照 Python 布尔字面量打印，不带任何附加文本。",
            "solution": "我们从能源系统建模所依据的核心定义和基本定律开始。在离散的小时间隔上，我们利用能量守恒和运行边界来推导一个混合整数线性规划问题，该问题决定了如何调度光伏发电、风力发电和储能以满足固定电力供应义务。\n\n为每个时间 $t \\in \\{0,1,\\dots,T-1\\}$ 定义以下决策变量：\n- $p^{\\mathrm{pv}}_t \\ge 0$ 是调度到电网的光伏功率，单位为 $\\mathrm{MW}$。\n- $p^{\\mathrm{w}}_t \\ge 0$ 是调度到电网的风力功率，单位为 $\\mathrm{MW}$。\n- $p^{\\mathrm{ch}}_t \\ge 0$ 是储能充电功率，单位为 $\\mathrm{MW}$。\n- $p^{\\mathrm{dis}}_t \\ge 0$ 是储能放电功率，单位为 $\\mathrm{MW}$。\n- $u^{\\mathrm{ch}}_t \\in \\{0,1\\}$ 是二进制充电决策，指示充电是否激活。\n- $u^{\\mathrm{dis}}_t \\in \\{0,1\\}$ 是二进制放电决策，指示放电是否激活。\n- $r_t \\ge 0$ 是未满足的固定电力（松弛变量），单位为 $\\mathrm{MW}$。\n定义储能的荷电状态 $s_t$，单位为 $\\mathrm{MWh}$，其中 $t \\in \\{0,1,\\dots,T\\}$，初始条件 $s_0$ 给定，终端条件为 $s_T = s_0$。\n\n物理和运行参数如下：\n- 光伏可用功率曲线 $a^{\\mathrm{pv}}_t$，单位为 $\\mathrm{MW}$。\n- 风力可用功率曲线 $a^{\\mathrm{w}}_t$，单位为 $\\mathrm{MW}$。\n- 固定供应义务 $P^{\\mathrm{firm}}_t$，单位为 $\\mathrm{MW}$。\n- 最大储能能量 $E^{\\mathrm{max}}$，单位为 $\\mathrm{MWh}$。\n- 最大充电功率 $P^{\\mathrm{ch,max}}$，单位为 $\\mathrm{MW}$。\n- 最大放电功率 $P^{\\mathrm{dis,max}}$，单位为 $\\mathrm{MW}$。\n- 充电效率 $\\eta^{\\mathrm{ch}} \\in (0,1]$（无量纲）。\n- 放电效率 $\\eta^{\\mathrm{dis}} \\in (0,1]$（无量纲）。\n我们取 $\\Delta t = 1$ 小时，因此在每个时间步长上能量和功率可以直接比较。\n\n根据储能在一个步长内的能量守恒，储存能量的变化等于储能的净输入减去损耗。以功率 $p^{\\mathrm{ch}}_t$ 充电 $\\Delta t = 1$ 小时，储存的能量增加 $\\eta^{\\mathrm{ch}} p^{\\mathrm{ch}}_t$，而以功率 $p^{\\mathrm{dis}}_t$ 放电，储存的能量减少 $\\frac{1}{\\eta^{\\mathrm{dis}}} p^{\\mathrm{dis}}_t$。因此，对于每个 $t \\in \\{0,\\dots,T-1\\}$，\n$$\ns_{t+1} = s_t + \\eta^{\\mathrm{ch}} p^{\\mathrm{ch}}_t - \\frac{1}{\\eta^{\\mathrm{dis}}} p^{\\mathrm{dis}}_t.\n$$\n运行边界强制要求对所有 $t$ 都有 $0 \\le s_t \\le E^{\\mathrm{max}}$。\n\n对于到电网的净功率平衡，在每个时间 $t$，电网接收的功率是调度发电量与储能放电量之和，减去任何用于给储能充电的功率。为确保在可能的情况下满足固定供应义务，我们引入一个非负松弛变量 $r_t$ 表示未满足的固定电力。因此净功率平衡必须满足\n$$\np^{\\mathrm{pv}}_t + p^{\\mathrm{w}}_t + p^{\\mathrm{dis}}_t - p^{\\mathrm{ch}}_t + r_t \\ge P^{\\mathrm{firm}}_t.\n$$\n发电的物理限制意味着\n$$\n0 \\le p^{\\mathrm{pv}}_t \\le a^{\\mathrm{pv}}_t, \\quad 0 \\le p^{\\mathrm{w}}_t \\le a^{\\mathrm{w}}_t.\n$$\n储能的功率限制为\n$$\n0 \\le p^{\\mathrm{ch}}_t \\le P^{\\mathrm{ch,max}}, \\quad 0 \\le p^{\\mathrm{dis}}_t \\le P^{\\mathrm{dis,max}}.\n$$\n为了以线性方式强制非同时充放电，我们使用二进制决策和 Big-$M$ 型连接约束：\n$$\np^{\\mathrm{ch}}_t \\le P^{\\mathrm{ch,max}} u^{\\mathrm{ch}}_t, \\quad p^{\\mathrm{dis}}_t \\le P^{\\mathrm{dis,max}} u^{\\mathrm{dis}}_t, \\quad u^{\\mathrm{ch}}_t + u^{\\mathrm{dis}}_t \\le 1.\n$$\n终端条件 $s_T = s_0$ 强制了在整个时间范围内的循环操作。\n\n目标是最小化总未满足固定电力：\n$$\n\\min \\sum_{t=0}^{T-1} r_t.\n$$\n所有约束都是线性的，只有 $u^{\\mathrm{ch}}_t$ 和 $u^{\\mathrm{dis}}_t$ 是二进制的，因此该问题是一个混合整数线性规划问题。\n\n算法设计：\n- 构建一个决策向量，堆叠了 $p^{\\mathrm{pv}}_t$、 $p^{\\mathrm{w}}_t$、 $p^{\\mathrm{ch}}_t$、 $p^{\\mathrm{dis}}_t$、 $s_t$ （其中 $t=0,\\dots,T$）、 $u^{\\mathrm{ch}}_t$、 $u^{\\mathrm{dis}}_t$ 和 $r_t$。\n- 使用可用发电限制、储能容量和储能功率限制来设置变量边界。设置二进制边界 $0 \\le u^{\\mathrm{ch}}_t \\le 1$ 和 $0 \\le u^{\\mathrm{dis}}_t \\le 1$，以及非负边界 $r_t \\ge 0$ 并为数值稳定性设置一个合理的上界。\n- 构建线性约束：\n  - 对所有 $t$，储能动态等式 $s_{t+1} - s_t - \\eta^{\\mathrm{ch}} p^{\\mathrm{ch}}_t + \\frac{1}{\\eta^{\\mathrm{dis}}} p^{\\mathrm{dis}}_t = 0$。\n  - 初始和终端荷电状态等式 $s_0 = \\text{given}$ 和 $s_T = s_0$。\n  - Big-$M$ 连接约束 $p^{\\mathrm{ch}}_t - P^{\\mathrm{ch,max}} u^{\\mathrm{ch}}_t \\le 0$ 和 $p^{\\mathrm{dis}}_t - P^{\\mathrm{dis,max}} u^{\\mathrm{dis}}_t \\le 0$，以及 $u^{\\mathrm{ch}}_t + u^{\\mathrm{dis}}_t \\le 1$。\n  - 功率平衡不等式 $p^{\\mathrm{pv}}_t + p^{\\mathrm{w}}_t + p^{\\mathrm{dis}}_t - p^{\\mathrm{ch}}_t + r_t \\ge P^{\\mathrm{firm}}_t$。\n- 使用一个混合整数线性规划求解器来最小化 $\\sum_t r_t$。如果最优的 $\\sum_t r_t$ 在一个小的容差范围内为零（例如，小于 $10^{-6}$ $\\mathrm{MW}$-小时，与 $\\Delta t = 1$ 小时下的单位相匹配），则认为解对于固定供应义务是可行的。\n\n可变性下的可行性评估：\n- 案例 $1$ 有足够的发电和储能来弥补一个短时的低谷；模型应能找到满足固定供应义务的调度方案，使得 $\\sum_t r_t$ 接近 $0$。\n- 案例 $2$ 存在全局能量赤字；储能不能创造能量，因此 $\\sum_t r_t$ 必须严格为正。\n- 案例 $3$ 需要在早期时段充电以覆盖一个具有实际效率的单谷时段；参数被选择为使得充电足够，且 $\\sum_t r_t \\approx 0$。\n- 案例 $4$ 有足够的能量，但在深度低谷期间放电功率不足，因此由于放电速率约束，$\\sum_t r_t$ 仍为正。\n\n程序输出一行，包含一个布尔值列表，每个布尔值指示相应的测试案例在基于第一性原理推导出的最优混合整数线性规划调度下是否可行。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import milp, LinearConstraint, Bounds\n\ndef solve_case(pv_avail, wind_avail, firm, E_max, s_init, P_ch_max, P_dis_max, eta_ch, eta_dis, tol=1e-6):\n    \"\"\"\n    Solve the MILP scheduling problem for a single case and return True if feasible (sum of slack ~ 0).\n    Parameters are arrays/lists for pv_avail, wind_avail, firm of length T.\n    \"\"\"\n    pv_avail = np.array(pv_avail, dtype=float)\n    wind_avail = np.array(wind_avail, dtype=float)\n    firm = np.array(firm, dtype=float)\n    T = len(pv_avail)\n\n    # Variable indexing\n    # Order: p_pv[0..T-1], p_w[0..T-1], p_ch[0..T-1], p_dis[0..T-1], s[0..T], u_ch[0..T-1], u_dis[0..T-1], r[0..T-1]\n    idx_pv_start = 0\n    idx_pv_end = idx_pv_start + T\n\n    idx_w_start = idx_pv_end\n    idx_w_end = idx_w_start + T\n\n    idx_ch_start = idx_w_end\n    idx_ch_end = idx_ch_start + T\n\n    idx_dis_start = idx_ch_end\n    idx_dis_end = idx_dis_start + T\n\n    idx_s_start = idx_dis_end\n    idx_s_end = idx_s_start + (T + 1)  # s_0 ... s_T\n\n    idx_uch_start = idx_s_end\n    idx_uch_end = idx_uch_start + T\n\n    idx_udis_start = idx_uch_end\n    idx_udis_end = idx_udis_start + T\n\n    idx_r_start = idx_udis_end\n    idx_r_end = idx_r_start + T\n\n    n_vars = idx_r_end\n\n    # Integrality: 0 for continuous, 1 for integer (binary handled via bounds [0,1])\n    integrality = np.zeros(n_vars, dtype=int)\n    integrality[idx_uch_start:idx_uch_end] = 1\n    integrality[idx_udis_start:idx_udis_end] = 1\n\n    # Variable bounds\n    lb = np.zeros(n_vars, dtype=float)\n    ub = np.full(n_vars, np.inf, dtype=float)\n\n    # p_pv bounds [0, pv_avail[t]]\n    lb[idx_pv_start:idx_pv_end] = 0.0\n    ub[idx_pv_start:idx_pv_end] = pv_avail\n\n    # p_w bounds [0, wind_avail[t]]\n    lb[idx_w_start:idx_w_end] = 0.0\n    ub[idx_w_start:idx_w_end] = wind_avail\n\n    # p_ch bounds [0, P_ch_max]\n    lb[idx_ch_start:idx_ch_end] = 0.0\n    ub[idx_ch_start:idx_ch_end] = P_ch_max\n\n    # p_dis bounds [0, P_dis_max]\n    lb[idx_dis_start:idx_dis_end] = 0.0\n    ub[idx_dis_start:idx_dis_end] = P_dis_max\n\n    # s bounds [0, E_max]\n    lb[idx_s_start:idx_s_end] = 0.0\n    ub[idx_s_start:idx_s_end] = E_max\n\n    # u_ch bounds [0,1]\n    lb[idx_uch_start:idx_uch_end] = 0.0\n    ub[idx_uch_start:idx_uch_end] = 1.0\n\n    # u_dis bounds [0,1]\n    lb[idx_udis_start:idx_udis_end] = 0.0\n    ub[idx_udis_start:idx_udis_end] = 1.0\n\n    # r bounds [0, R_max]; choose a reasonable big-M upper bound\n    R_max = max(1.0, float(np.max(firm)) * 2.0)\n    lb[idx_r_start:idx_r_end] = 0.0\n    ub[idx_r_start:idx_r_end] = R_max\n\n    bounds = Bounds(lb, ub)\n\n    constraints = []\n\n    # Storage dynamics: s[t+1] - s[t] - eta_ch * p_ch[t] + (1/eta_dis) * p_dis[t] = 0\n    for t in range(T):\n        row = np.zeros(n_vars, dtype=float)\n        row[idx_s_start + (t + 1)] = 1.0\n        row[idx_s_start + t] = -1.0\n        row[idx_ch_start + t] = -eta_ch\n        row[idx_dis_start + t] = 1.0 / eta_dis\n        constraints.append(LinearConstraint(row, 0.0, 0.0))\n\n    # Initial state of charge: s[0] = s_init\n    row = np.zeros(n_vars, dtype=float)\n    row[idx_s_start + 0] = 1.0\n    constraints.append(LinearConstraint(row, s_init, s_init))\n\n    # Terminal state of charge: s[T] = s_init\n    row = np.zeros(n_vars, dtype=float)\n    row[idx_s_start + T] = 1.0\n    constraints.append(LinearConstraint(row, s_init, s_init))\n\n    # Linking constraints: p_ch[t] - P_ch_max * u_ch[t] = 0, p_dis[t] - P_dis_max * u_dis[t] = 0\n    for t in range(T):\n        # Charge linking\n        row = np.zeros(n_vars, dtype=float)\n        row[idx_ch_start + t] = 1.0\n        row[idx_uch_start + t] = -P_ch_max\n        constraints.append(LinearConstraint(row, -np.inf, 0.0))\n\n        # Discharge linking\n        row = np.zeros(n_vars, dtype=float)\n        row[idx_dis_start + t] = 1.0\n        row[idx_udis_start + t] = -P_dis_max\n        constraints.append(LinearConstraint(row, -np.inf, 0.0))\n\n    # Non-simultaneity: u_ch[t] + u_dis[t] = 1\n    for t in range(T):\n        row = np.zeros(n_vars, dtype=float)\n        row[idx_uch_start + t] = 1.0\n        row[idx_udis_start + t] = 1.0\n        constraints.append(LinearConstraint(row, -np.inf, 1.0))\n\n    # Firm obligation: p_pv + p_w + p_dis - p_ch + r >= firm\n    for t in range(T):\n        row = np.zeros(n_vars, dtype=float)\n        row[idx_pv_start + t] = 1.0\n        row[idx_w_start + t] = 1.0\n        row[idx_dis_start + t] = 1.0\n        row[idx_ch_start + t] = -1.0\n        row[idx_r_start + t] = 1.0\n        constraints.append(LinearConstraint(row, firm[t], np.inf))\n\n    # Objective: minimize sum of r_t\n    c = np.zeros(n_vars, dtype=float)\n    c[idx_r_start:idx_r_end] = 1.0\n\n    # Solve MILP\n    res = milp(c=c, constraints=constraints, integrality=integrality, bounds=bounds)\n\n    # Check feasibility: success and total unmet firm power ~ 0\n    feasible = bool(res.success)\n    if feasible:\n        total_unmet = res.fun\n        feasible = total_unmet = tol\n    return feasible\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: happy path\n        {\n            \"pv\": [3.0, 2.0, 1.0, 0.5, 1.5, 2.0],\n            \"wind\": [1.0, 1.5, 2.0, 1.2, 0.8, 1.5],\n            \"firm\": [2.0, 2.0, 2.0, 2.0, 2.0, 2.0],\n            \"E_max\": 1.0,\n            \"s_init\": 0.5,\n            \"P_ch_max\": 1.5,\n            \"P_dis_max\": 1.5,\n            \"eta_ch\": 0.95,\n            \"eta_dis\": 0.95,\n        },\n        # Case 2: global energy deficit\n        {\n            \"pv\": [0.2, 0.2, 0.2, 0.2],\n            \"wind\": [0.1, 0.1, 0.1, 0.1],\n            \"firm\": [0.5, 0.5, 0.5, 0.5],\n            \"E_max\": 10.0,\n            \"s_init\": 0.0,\n            \"P_ch_max\": 5.0,\n            \"P_dis_max\": 5.0,\n            \"eta_ch\": 0.95,\n            \"eta_dis\": 0.95,\n        },\n        # Case 3: single trough with variability and exact energy sizing\n        {\n            \"pv\": [2.5, 2.2, 0.2, 2.1, 2.3],\n            \"wind\": [0.3, 0.5, 0.3, 0.2, 0.3],\n            \"firm\": [2.0, 2.0, 1.4, 2.0, 2.0],\n            \"E_max\": 1.6,\n            \"s_init\": 0.0,\n            \"P_ch_max\": 1.5,\n            \"P_dis_max\": 1.5,\n            \"eta_ch\": 0.95,\n            \"eta_dis\": 0.95,\n        },\n        # Case 4: power-limited infeasibility at trough\n        {\n            \"pv\": [3.0, 1.0, 3.0],\n            \"wind\": [0.0, 0.0, 0.0],\n            \"firm\": [2.5, 2.5, 2.5],\n            \"E_max\": 10.0,\n            \"s_init\": 0.0,\n            \"P_ch_max\": 3.0,\n            \"P_dis_max\": 1.0,\n            \"eta_ch\": 0.95,\n            \"eta_dis\": 0.95,\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        feasible = solve_case(\n            pv_avail=case[\"pv\"],\n            wind_avail=case[\"wind\"],\n            firm=case[\"firm\"],\n            E_max=case[\"E_max\"],\n            s_init=case[\"s_init\"],\n            P_ch_max=case[\"P_ch_max\"],\n            P_dis_max=case[\"P_dis_max\"],\n            eta_ch=case[\"eta_ch\"],\n            eta_dis=case[\"eta_dis\"],\n        )\n        results.append(feasible)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}