{
    "hands_on_practices": [
        {
            "introduction": "The first step in modeling electric vehicle charging demand is to understand the energy consumption of a single vehicle during a trip. This practice grounds your understanding in the first principles of physics, requiring you to build a dynamic model that calculates the tractive force needed to overcome inertia, rolling resistance, and aerodynamic drag. By integrating the required mechanical power over a specified driving cycle and accounting for drivetrain and regenerative braking efficiencies, you will compute the net energy consumed from the battery, providing a foundational tool for any charging analysis .",
            "id": "4087464",
            "problem": "An electric vehicle operates over a specified driving cycle characterized by a speed profile as a function of time. The objective is to compute the electric vehicle charging demand required to restore the battery to its initial state-of-charge after completing the cycle. The computation must be grounded in fundamentals of mechanics and established vehicle modeling practice.\n\nStarting from first principles, use the following modeling bases:\n- Newton’s second law: the net longitudinal force equals mass times longitudinal acceleration. Denote mass by $m$ in $\\mathrm{kg}$, speed by $v(t)$ in $\\mathrm{m/s}$, and acceleration by $a(t)$ in $\\mathrm{m/s^2}$.\n- Rolling resistance model: the rolling resistance force is proportional to the normal force with coefficient $c_r$ (dimensionless), such that the rolling resistance force magnitude is $c_r \\, m \\, g$, where $g$ is the gravitational acceleration in $\\mathrm{m/s^2}$.\n- Aerodynamic drag model: the aerodynamic drag force magnitude is proportional to the squared speed and the dynamic pressure. Using air density $\\rho$ in $\\mathrm{kg/m^3}$, frontal area $A$ in $\\mathrm{m^2}$, and drag coefficient $C_d$ (dimensionless), the drag force magnitude depends on $\\tfrac{1}{2}\\,\\rho\\,A\\,C_d\\,v(t)^2$.\n- Mechanical power at the wheels equals the longitudinal tractive force times speed. Adopt the sign convention that positive mechanical power represents energy drawn from the battery to the wheels, while negative mechanical power represents energy returned from the wheels to the battery through regenerative braking if present.\n\nElectrical energy conversion assumptions:\n- Drivetrain efficiency $\\eta_d$ (dimensionless) maps mechanical power at the wheels to electrical power drawn from the battery when mechanical power is positive.\n- Regenerative braking efficiency $\\eta_{\\text{reg}}$ (dimensionless) maps negative mechanical power at the wheels to electrical power recovered into the battery when mechanical power is negative. Assume full regenerative capture of negative mechanical power limited only by the efficiency $\\eta_{\\text{reg}}$.\n- Charging efficiency $\\eta_{\\text{ch}}$ (dimensionless) maps grid energy to battery energy during charging.\n\nCompute the net battery energy change over the cycle by integrating mechanical power over time and converting to electrical energy using the efficiencies above. If the net battery energy change is negative (i.e., net energy gain due to regeneration), set the required grid energy to recharge to the initial state-of-charge to zero. Otherwise, compute the grid energy as the battery energy change divided by the charging efficiency. Express all energy results in kilowatt-hour ($\\mathrm{kWh}$), rounded to six decimal places.\n\nTime discretization requirements:\n- For each test case, construct $v(t)$ on a uniform grid with time step $\\Delta t = 1 \\mathrm{s}$ across the specified horizon $[0, T]$.\n- Compute $a(t)$ via finite differences consistent with the uniform grid.\n- Integrate over time using a numerically consistent method (for example, the trapezoidal rule or a Riemann sum).\n\nProvide a program that, for the following test suite, computes the required grid energy to recharge the battery to its initial state-of-charge after the cycle. Use the specified physical parameters for each test case. All speeds are in $\\mathrm{m/s}$, times in $\\mathrm{s}$, and energies in $\\mathrm{kWh}$. The gravitational acceleration is $g=9.81 \\mathrm{m/s^2}$ in all cases.\n\nTest Suite:\n- Case 1 (baseline urban profile):\n  - Parameters: $m=1600$ kg, $c_r=0.012$, $\\rho=1.225$ kg/m^3, $A=2.2$ m^2, $C_d=0.29$, $\\eta_d=0.92$, $\\eta_{\\text{reg}}=0.65$, $\\eta_{\\text{ch}}=0.90$.\n  - Horizon: $T=600$ s, $\\Delta t=1$ s.\n  - Speed profile $v(t)$:\n    - For $t \\in [0, 30]$: linearly accelerate from $0$ to $15$ m/s.\n    - For $t \\in [30, 150]$: cruise at $15$ m/s.\n    - For $t \\in [150, 170]$: linearly decelerate from $15$ to $0$ m/s.\n    - For $t \\in [170, 230]$: dwell at $0$ m/s.\n    - For $t \\in [230, 260]$: linearly accelerate from $0$ to $12$ m/s.\n    - For $t \\in [260, 380]$: cruise at $12$ m/s.\n    - For $t \\in [380, 420]$: linearly decelerate from $12$ to $0$ m/s.\n    - For $t \\in [420, 600]$: dwell at $0$ m/s.\n- Case 2 (stationary edge case):\n  - Parameters: same as Case 1.\n  - Horizon: $T=300$ s, $\\Delta t=1$ s.\n  - Speed profile $v(t)$: identically $0$ for all $t \\in [0, 300]$.\n- Case 3 (high-speed acceleration and regenerative braking):\n  - Parameters: $m=1600$ kg, $c_r=0.012$, $\\rho=1.225$ kg/m^3, $A=2.2$ m^2, $C_d=0.29$, $\\eta_d=0.92$, $\\eta_{\\text{reg}}=0.75$, $\\eta_{\\text{ch}}=0.90$.\n  - Horizon: $T=120$ s, $\\Delta t=1$ s.\n  - Speed profile $v(t)$:\n    - For $t \\in [0, 30]$: linearly accelerate from $0$ to $30$ m/s.\n    - For $t \\in [30, 60]$: cruise at $30$ m/s.\n    - For $t \\in [60, 80]$: linearly decelerate from $30$ to $0$ m/s.\n    - For $t \\in [80, 120]$: dwell at $0$ m/s.\n- Case 4 (aerodynamic regime, sustained cruising):\n  - Parameters: $m=1600$ kg, $c_r=0.012$, $\\rho=1.225$ kg/m^3, $A=2.6$ m^2, $C_d=0.32$, $\\eta_d=0.92$, $\\eta_{\\text{reg}}=0.65$, $\\eta_{\\text{ch}}=0.90$.\n  - Horizon: $T=600$ s, $\\Delta t=1$ s.\n  - Speed profile $v(t)$: constant cruising at $33.33$ m/s for all $t \\in [0, 600]$.\n\nRequired output:\n- For each case, compute the grid energy required to recharge the battery to its initial state-of-charge after the cycle, in $\\mathrm{kWh}$, rounded to six decimal places.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $\\left[\\text{result1},\\text{result2},\\text{result3},\\text{result4}\\right]$), with each result rounded to six decimal places and expressed in $\\mathrm{kWh}$.",
            "solution": "The problem is well-posed, scientifically grounded, and contains all necessary information to proceed with a solution.\n\n### 1. Governing Principles and Force-Power Formulation\n\nThe analysis begins from first principles of classical mechanics. The motion of the electric vehicle is governed by Newton's second law applied in the longitudinal direction. The net force on the vehicle is the sum of the tractive force from the powertrain and various resistive forces. For a vehicle of mass $m$ moving on a level surface with longitudinal acceleration $a(t)$, the required tractive force at the wheels, $F_{\\text{tractive}}(t)$, is given by:\n\n$$\nF_{\\text{tractive}}(t) = m \\, a(t) + F_{\\text{res}}(t)\n$$\n\nwhere $F_{\\text{res}}(t)$ is the total resistive force. The problem specifies two primary sources of resistance: rolling resistance and aerodynamic drag.\n\nThe rolling resistance force, $F_{rr}$, is modeled as proportional to the normal force on the vehicle. For a level surface, this is:\n$$\nF_{rr} = c_r \\, m \\, g\n$$\nwhere $c_r$ is the dimensionless coefficient of rolling resistance and $g$ is the acceleration due to gravity. This force is assumed to be constant whenever the vehicle is in motion and acts to oppose the direction of velocity.\n\nThe aerodynamic drag force, $F_{ad}(t)$, is proportional to the dynamic pressure of the air and the vehicle's frontal area. Its magnitude is given by:\n$$\nF_{ad}(t) = \\frac{1}{2} \\, \\rho \\, A \\, C_d \\, v(t)^2\n$$\nwhere $\\rho$ is the air density, $A$ is the frontal area, $C_d$ is the dimensionless drag coefficient, and $v(t)$ is the vehicle's speed. This force also opposes the direction of velocity.\n\nCombining these components, the total tractive force required to follow the specified speed profile is:\n$$\nF_{\\text{tractive}}(t) = m \\, a(t) + c_r \\, m \\, g + \\frac{1}{2} \\, \\rho \\, A \\, C_d \\, v(t)^2\n$$\nThe sign convention is such that $F_{\\text{tractive}}(t)$ is positive for motoring and negative for braking.\n\nThe mechanical power at the wheels, $P_{\\text{mech}}(t)$, is the product of the tractive force and the vehicle's speed:\n$$\nP_{\\text{mech}}(t) = F_{\\text{tractive}}(t) \\cdot v(t)\n$$\nA positive $P_{\\text{mech}}(t)$ indicates power is expended to propel the vehicle (motoring), while a negative $P_{\\text{mech}}(t)$ signifies that power is being delivered to the wheels from the vehicle's kinetic energy (braking), which can be partially recovered.\n\n### 2. Electrical Power and Energy Consumption\n\nThe mechanical power at the wheels is supplied by or delivered to the vehicle's battery through the electric drivetrain. The conversion between mechanical and electrical power is subject to efficiencies.\n\nThe electrical power drawn from or supplied to the battery, $P_{\\text{elec}}(t)$, is determined as follows:\n- When motoring ($P_{\\text{mech}}(t) > 0$), power is drawn from the battery, and the conversion is governed by the drivetrain efficiency $\\eta_d$:\n  $$\n  P_{\\text{elec}}(t) = \\frac{P_{\\text{mech}}(t)}{\\eta_d}\n  $$\n- When braking ($P_{\\text{mech}}(t)  0$), power is returned to the battery via regenerative braking, governed by the regenerative efficiency $\\eta_{\\text{reg}}$:\n  $$\n  P_{\\text{elec}}(t) = P_{\\text{mech}}(t) \\cdot \\eta_{\\text{reg}}\n  $$\n- When $P_{\\text{mech}}(t) = 0$, no power is exchanged, so $P_{\\text{elec}}(t) = 0$.\n\nThe net change in the battery's stored energy over the driving cycle of duration $T$ is the time integral of the electrical power:\n$$\n\\Delta E_{\\text{batt}} = \\int_{0}^{T} P_{\\text{elec}}(t) \\, dt\n$$\nA positive $\\Delta E_{\\text{batt}}$ represents a net discharge of the battery.\n\n### 3. Numerical Discretization and Algorithm\n\nTo compute the solution, we discretize the problem over a uniform time grid. The time horizon $[0, T]$ is divided into $N$ intervals of duration $\\Delta t = 1 \\, \\mathrm{s}$, yielding time points $t_i = i \\cdot \\Delta t$ for $i = 0, 1, \\dots, N$.\n\nThe algorithm proceeds as follows:\n1.  **Construct Time and Velocity Vectors**: A time vector $\\mathbf{t} = [t_0, t_1, \\dots, t_N]$ is created. The corresponding velocity vector $\\mathbf{v} = [v_0, v_1, \\dots, v_N]$ is constructed by sampling the given piecewise speed profile at each time point $t_i$.\n2.  **Compute Acceleration Vector**: The acceleration vector $\\mathbf{a} = [a_0, a_1, \\dots, a_N]$ is computed using a finite difference approximation on the velocity vector $\\mathbf{v}$. A standard approach, such as `numpy.gradient`, which uses central differences for interior points and second-order accurate one-sided differences at the boundaries, is suitable and consistent. Given $\\Delta t=1 \\, \\mathrm{s}$, this is applied directly to the velocity vector.\n3.  **Calculate Instantaneous Forces and Powers**: For each time index $i$:\n    a. Tractive Force: $F_{\\text{tractive}, i} = m \\, a_i + c_r \\, m \\, g + \\frac{1}{2} \\, \\rho \\, A \\, C_d \\, v_i^2$.\n    b. Mechanical Power: $P_{\\text{mech}, i} = F_{\\text{tractive}, i} \\cdot v_i$.\n    c. Electrical Power: $P_{\\text{elec}, i}$ is calculated based on the sign of $P_{\\text{mech}, i}$ and the corresponding efficiencies $\\eta_d$ or $\\eta_{\\text{reg}}$.\n4.  **Integrate Electrical Power**: The net battery energy change, $\\Delta E_{\\text{batt}}$, is calculated by numerically integrating the electrical power vector $\\mathbf{P}_{\\text{elec}}$ with respect to time. The trapezoidal rule is a suitable and numerically consistent method:\n    $$\n    \\Delta E_{\\text{batt}} \\approx \\sum_{i=1}^{N} \\frac{P_{\\text{elec}, i} + P_{\\text{elec}, i-1}}{2} \\Delta t\n    $$\n    This is performed on the computed power values, yielding a result in Joules.\n\n### 4. Grid Energy Calculation\n\nThe final objective is to find the energy required from the grid, $E_{\\text{grid}}$, to restore the battery to its initial state.\n1.  **Unit Conversion**: The calculated $\\Delta E_{\\text{batt}}$ in Joules is converted to kilowatt-hours (kWh) using the conversion factor $1 \\, \\mathrm{kWh} = 3.6 \\times 10^6 \\, \\mathrm{J}$.\n    $$\n    \\Delta E_{\\text{batt}} [\\mathrm{kWh}] = \\frac{\\Delta E_{\\text{batt}} [\\mathrm{J}]}{3.6 \\times 10^6}\n    $$\n2.  **Charging Logic**:\n    - If $\\Delta E_{\\text{batt}} \\le 0$, the vehicle has experienced a net energy gain over the cycle (due to significant regenerative braking). No charging is required. Thus, $E_{\\text{grid}} = 0$.\n    - If $\\Delta E_{\\text{batt}} > 0$, the battery has been discharged. The energy required from the grid must account for the charging efficiency $\\eta_{\\text{ch}}$.\n      $$\n      E_{\\text{grid}} = \\frac{\\Delta E_{\\text{batt}} [\\mathrm{kWh}]}{\\eta_{\\text{ch}}}\n      $$\n3.  **Final Result**: The computed value of $E_{\\text{grid}}$ is rounded to six decimal places as required. This process is repeated for each test case provided.",
            "answer": "```python\nimport numpy as np\n\ndef calculate_grid_energy(params, cycle_def):\n    \"\"\"\n    Computes the grid energy required to recharge an EV battery after a driving cycle.\n    \n    Args:\n        params (dict): Dictionary of vehicle and efficiency parameters.\n        cycle_def (dict): Dictionary defining the driving cycle horizon and speed profile.\n\n    Returns:\n        float: Grid energy in kWh, rounded to 6 decimal places.\n    \"\"\"\n    # Unpack parameters\n    m = params['m']\n    c_r = params['c_r']\n    rho = params['rho']\n    A = params['A']\n    C_d = params['C_d']\n    eta_d = params['eta_d']\n    eta_reg = params['eta_reg']\n    eta_ch = params['eta_ch']\n    g = 9.81\n\n    # Unpack cycle definition\n    T = cycle_def['T']\n    dt = cycle_def['dt']\n    speed_profile = cycle_def['speed_profile']\n\n    # 1. Construct Time and Velocity Vectors\n    time = np.arange(0, T + dt, dt)\n    v = np.zeros_like(time, dtype=float)\n\n    for segment in speed_profile:\n        t_start, t_end = segment[0], segment[1]\n        v_start, v_end = segment[2], segment[3]\n        \n        # Find indices corresponding to the time segment\n        start_idx = int(t_start / dt)\n        end_idx = int(t_end / dt)\n        num_points = end_idx - start_idx + 1\n\n        if v_start == v_end: # Constant speed (cruise or dwell)\n            v[start_idx : end_idx + 1] = v_start\n        else: # Linear acceleration/deceleration\n            v[start_idx : end_idx + 1] = np.linspace(v_start, v_end, num_points)\n\n    # 2. Compute Acceleration Vector\n    a = np.gradient(v, dt)\n\n    # 3. Calculate Instantaneous Forces and Powers\n    F_rr = c_r * m * g\n    F_ad = 0.5 * rho * A * C_d * v**2\n    F_tractive = m * a + F_rr + F_ad\n\n    P_mech = F_tractive * v\n    \n    # Use np.where for conditional power calculation\n    P_elec = np.where(P_mech  0, P_mech / eta_d, P_mech * eta_reg)\n\n    # 4. Integrate Electrical Power (Trapezoidal Rule)\n    delta_E_batt_J = np.trapz(P_elec, time)\n\n    # 5. Grid Energy Calculation\n    # Convert Joules to kWh\n    delta_E_batt_kWh = delta_E_batt_J / 3.6e6\n\n    if delta_E_batt_kWh = 0:\n        E_grid = 0.0\n    else:\n        E_grid = delta_E_batt_kWh / eta_ch\n\n    return round(E_grid, 6)\n\ndef solve():\n    \"\"\"\n    Defines test cases and computes the results for the problem.\n    \"\"\"\n    g = 9.81  # m/s^2\n\n    test_cases = [\n        {\n            \"params\": {\n                'm': 1600, 'c_r': 0.012, 'rho': 1.225, 'A': 2.2, 'C_d': 0.29,\n                'eta_d': 0.92, 'eta_reg': 0.65, 'eta_ch': 0.90\n            },\n            \"cycle_def\": {\n                'T': 600, 'dt': 1,\n                'speed_profile': [\n                    (0, 30, 0, 15), (30, 150, 15, 15), (150, 170, 15, 0),\n                    (170, 230, 0, 0), (230, 260, 0, 12), (260, 380, 12, 12),\n                    (380, 420, 12, 0), (420, 600, 0, 0)\n                ]\n            }\n        },\n        {\n            \"params\": {\n                'm': 1600, 'c_r': 0.012, 'rho': 1.225, 'A': 2.2, 'C_d': 0.29,\n                'eta_d': 0.92, 'eta_reg': 0.65, 'eta_ch': 0.90\n            },\n            \"cycle_def\": {\n                'T': 300, 'dt': 1,\n                'speed_profile': [(0, 300, 0, 0)]\n            }\n        },\n        {\n            \"params\": {\n                'm': 1600, 'c_r': 0.012, 'rho': 1.225, 'A': 2.2, 'C_d': 0.29,\n                'eta_d': 0.92, 'eta_reg': 0.75, 'eta_ch': 0.90\n            },\n            \"cycle_def\": {\n                'T': 120, 'dt': 1,\n                'speed_profile': [\n                    (0, 30, 0, 30), (30, 60, 30, 30), (60, 80, 30, 0),\n                    (80, 120, 0, 0)\n                ]\n            }\n        },\n        {\n            \"params\": {\n                'm': 1600, 'c_r': 0.012, 'rho': 1.225, 'A': 2.6, 'C_d': 0.32,\n                'eta_d': 0.92, 'eta_reg': 0.65, 'eta_ch': 0.90\n            },\n            \"cycle_def\": {\n                'T': 600, 'dt': 1,\n                'speed_profile': [(0, 600, 33.33, 33.33)]\n            }\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = calculate_grid_energy(case[\"params\"], case[\"cycle_def\"])\n        results.append(f\"{result:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Knowing how much energy an EV consumes is only half the story; we must also model the process of replenishing that energy under real-world constraints. This exercise moves from vehicle physics to charging logistics by framing the problem as a feasibility question solved with linear programming. You will determine whether a vehicle can meet a target State of Charge ($SOC$) by a deadline, subject to constraints like charger power limits, grid capacity, and vehicle availability, giving you hands-on experience with optimization techniques that are central to smart charging and grid integration strategies .",
            "id": "4087499",
            "problem": "Consider a single electric vehicle charging problem over a discretized time horizon. Let the time horizon be partitioned into $D$ slots indexed by $t \\in \\{0,1,\\dots,D-1\\}$, each of duration $\\Delta t$ in hours. Let the electric vehicle battery have energy capacity $E_{\\mathrm{cap}}$ in kilowatt-hours (kWh), initial state of charge $\\mathrm{SOC}_0 \\in [0,1]$, and a charging efficiency $\\eta \\in (0,1]$ that linearly maps electrical energy delivered at the plug to energy stored in the battery. The decision variables are the charging powers $\\{p_t\\}_{t=0}^{D-1}$ in kilowatts (kW), subject to linear constraints capturing physical and operational limits.\n\nFundamental base and model:\n- By conservation of energy, the energy stored in the battery increases with delivered power according to $\\Delta E_t = \\eta\\, p_t\\, \\Delta t$, where $\\Delta E_t$ is the battery energy increment during slot $t$ and $p_t$ is the plug power during slot $t$.\n- The state of charge evolves as $\\mathrm{SOC}_{t+1} = \\mathrm{SOC}_t + \\dfrac{\\Delta E_t}{E_{\\mathrm{cap}}} = \\mathrm{SOC}_t + \\dfrac{\\eta\\, p_t\\, \\Delta t}{E_{\\mathrm{cap}}}$.\n- Define $\\alpha = \\dfrac{\\eta\\, \\Delta t}{E_{\\mathrm{cap}}}$. Then $\\mathrm{SOC}_D = \\mathrm{SOC}_0 + \\alpha \\sum_{t=0}^{D-1} p_t$.\n\nConstraints:\n- Power nonnegativity: $p_t \\ge 0$ for all $t$.\n- Availability window and power limits: let $a_t \\in \\{0,1\\}$ denote availability (vehicle is connected during slot $t$ if $a_t=1$, otherwise $a_t=0$), let $P^{\\max}_t$ be the charger maximum in kilowatts during slot $t$, and let $P^{\\mathrm{grid}}_t$ be an exogenous grid or feeder upper bound during slot $t$. Then $p_t \\le a_t \\cdot \\min\\{P^{\\max}_t, P^{\\mathrm{grid}}_t\\}$ for all $t$.\n- Minimum mobility state of charge: at any slot boundary $t$, impose $\\mathrm{SOC}_t \\ge \\mathrm{SOC}_{\\min}$, where $\\mathrm{SOC}_{\\min} \\in [0,1]$ is a mobility requirement.\n- Target by deadline: impose $\\mathrm{SOC}_D \\ge \\mathrm{SOC}_{\\mathrm{target}}$, where $\\mathrm{SOC}_{\\mathrm{target}} \\in [0,1]$ is the required state of charge by slot $D$.\n\nFormulation:\n- The feasibility problem is a linear program with decision variables $p_t$ and linear inequality constraints. With the definition of $\\alpha$, the target-by-deadline constraint can be written as $\\alpha \\sum_{t=0}^{D-1} p_t \\ge \\mathrm{SOC}_{\\mathrm{target}} - \\mathrm{SOC}_0$, which is linear. Minimum mobility constraints for intermediate times can be written as $\\alpha \\sum_{k=0}^{t-1} p_k \\ge \\mathrm{SOC}_{\\min} - \\mathrm{SOC}_0$ for $t=1,\\dots,D$, which are also linear. The objective may be the zero function, as only feasibility is required.\n\nYour task:\n- Write a program that, for each test case, constructs the described linear program, solves it, and returns a boolean indicating whether the constraints are feasible (i.e., whether some charging schedule $\\{p_t\\}$ exists that satisfies all constraints). If $D=0$, interpret the constraints as requiring $\\mathrm{SOC}_0 \\ge \\mathrm{SOC}_{\\mathrm{target}}$ and $\\mathrm{SOC}_0 \\ge \\mathrm{SOC}_{\\min}$.\n- Units: power must be handled in kilowatts (kW), energy in kilowatt-hours (kWh), time in hours, and state of charge as a decimal fraction in $[0,1]$ (e.g., $0.8$). The final boolean result for each test case should be computed without rounding or truncation and printed as either $True$ or $False$.\n\nTest suite:\nProvide results for the following four test cases, each specified as $(E_{\\mathrm{cap}}, \\Delta t, D, \\eta, \\mathrm{SOC}_0, \\mathrm{SOC}_{\\min}, \\mathrm{SOC}_{\\mathrm{target}}, \\{P^{\\max}_t\\}_{t=0}^{D-1}, \\{P^{\\mathrm{grid}}_t\\}_{t=0}^{D-1}, \\{a_t\\}_{t=0}^{D-1})$:\n1. Happy path feasibility with continuous availability and typical alternating current Level $2$ charging:\n   - $E_{\\mathrm{cap}} = 60$ kWh, $\\Delta t = 0.25$ h, $D = 16$, $\\eta = 0.92$, $\\mathrm{SOC}_0 = 0.5$, $\\mathrm{SOC}_{\\min} = 0.2$, $\\mathrm{SOC}_{\\mathrm{target}} = 0.8$, $P^{\\max}_t = 7$ kW for all $t$, $P^{\\mathrm{grid}}_t = 10$ kW for all $t$, $a_t = 1$ for all $t$.\n2. Infeasible due to insufficient availability and low power:\n   - $E_{\\mathrm{cap}} = 60$ kWh, $\\Delta t = 1.0$ h, $D = 1$, $\\eta = 0.92$, $\\mathrm{SOC}_0 = 0.7$, $\\mathrm{SOC}_{\\min} = 0.2$, $\\mathrm{SOC}_{\\mathrm{target}} = 0.9$, $P^{\\max}_0 = 3.6$ kW, $P^{\\mathrm{grid}}_0 = 3.6$ kW, $a_0 = 1$.\n3. Boundary case with immediate deadline:\n   - $E_{\\mathrm{cap}} = 50$ kWh, $\\Delta t = 0.25$ h, $D = 0$, $\\eta = 0.90$, $\\mathrm{SOC}_0 = 0.7$, $\\mathrm{SOC}_{\\min} = 0.6$, $\\mathrm{SOC}_{\\mathrm{target}} = 0.7$. Empty sequences for $P^{\\max}_t$, $P^{\\mathrm{grid}}_t$, and $a_t$ because there are no slots.\n4. Exact-feasibility boundary with intermittent availability and varying power limits:\n   - $E_{\\mathrm{cap}} = 50$ kWh, $\\Delta t = 0.25$ h, $D = 5$, $\\eta = 0.80$, $\\mathrm{SOC}_0 = 0.6$, $\\mathrm{SOC}_{\\min} = 0.2$, $\\mathrm{SOC}_{\\mathrm{target}} = 0.8$, $P^{\\max}_t = [20, 20, 15, 20, 15]$ kW, $P^{\\mathrm{grid}}_t = [25, 25, 25, 25, 25]$ kW, $a_t = [1, 0, 1, 0, 1]$.\n\nFinal output format:\n- Your program should produce a single line of output containing the boolean results for the test suite as a comma-separated list enclosed in square brackets, for example, $[True,False,True,True]$.",
            "solution": "We begin from conservation of energy, which states that the rate of change of energy stored in a system is equal to the net power input. For an electric vehicle battery with charging efficiency $\\eta \\in (0,1]$, when a charger delivers electrical power $p_t$ in kilowatts over a slot of duration $\\Delta t$ hours, the energy stored in the battery increases by $\\Delta E_t = \\eta\\, p_t\\, \\Delta t$ kilowatt-hours. The state of charge, denoted by $\\mathrm{SOC}_t \\in [0,1]$, is the fraction of the battery's energy capacity $E_{\\mathrm{cap}}$ that is filled, so the incremental change in state of charge in slot $t$ is\n$$\n\\Delta \\mathrm{SOC}_t = \\frac{\\Delta E_t}{E_{\\mathrm{cap}}} = \\frac{\\eta\\, p_t\\, \\Delta t}{E_{\\mathrm{cap}}}.\n$$\nTherefore, the discrete-time state of charge dynamics are\n$$\n\\mathrm{SOC}_{t+1} = \\mathrm{SOC}_t + \\frac{\\eta\\, p_t\\, \\Delta t}{E_{\\mathrm{cap}}}.\n$$\nDefine the constant\n$$\n\\alpha = \\frac{\\eta\\, \\Delta t}{E_{\\mathrm{cap}}}.\n$$\nBy repeated substitution, the state of charge at the deadline slot $D$ is\n$$\n\\mathrm{SOC}_D = \\mathrm{SOC}_0 + \\alpha \\sum_{t=0}^{D-1} p_t.\n$$\n\nWe now collect the constraints required by physical and operational limits and express them in linear form:\n- Nonnegativity of power: $p_t \\ge 0$ for all $t$.\n- Availability and power limits: let $a_t \\in \\{0,1\\}$ indicate whether the vehicle is connected during slot $t$, let $P^{\\max}_t$ be the charger rating in kilowatts, and let $P^{\\mathrm{grid}}_t$ be a grid upper bound in kilowatts. The feasible upper bound for slot $t$ is\n$$\n\\overline{P}_t = a_t \\cdot \\min\\{P^{\\max}_t, P^{\\mathrm{grid}}_t\\},\n$$\nso we have $p_t \\le \\overline{P}_t$ for all $t$.\n- Minimum mobility state of charge: impose that for each intermediate slot boundary,\n$$\n\\mathrm{SOC}_t \\ge \\mathrm{SOC}_{\\min} \\quad \\text{for all } t \\in \\{0,1,\\dots,D\\}.\n$$\nSince there is no discharge modeled, these constraints are nonbinding whenever $\\mathrm{SOC}_0 \\ge \\mathrm{SOC}_{\\min}$, but they can be included in the linear program for completeness.\n- Target-by-deadline requirement:\n$$\n\\mathrm{SOC}_D \\ge \\mathrm{SOC}_{\\mathrm{target}}.\n$$\n\nAll constraints are linear in the decision variables $\\{p_t\\}$. In particular, the target constraint can be written as\n$$\n\\alpha \\sum_{t=0}^{D-1} p_t \\ge \\mathrm{SOC}_{\\mathrm{target}} - \\mathrm{SOC}_0,\n$$\nand each minimum mobility constraint can be written as\n$$\n\\alpha \\sum_{k=0}^{t-1} p_k \\ge \\mathrm{SOC}_{\\min} - \\mathrm{SOC}_0 \\quad \\text{for } t=1,\\dots,D.\n$$\nTo use a standard linear programming solver in inequality form with upper bounds, we express these as\n$$\n-\\alpha \\sum_{t=0}^{D-1} p_t \\le -(\\mathrm{SOC}_{\\mathrm{target}} - \\mathrm{SOC}_0),\n$$\nand\n$$\n-\\alpha \\sum_{k=0}^{t-1} p_k \\le -(\\mathrm{SOC}_{\\min} - \\mathrm{SOC}_0), \\quad t=1,\\dots,D.\n$$\n\nWe formulate the feasibility linear program as:\n- Decision variables: $p_t$, $t=0,\\dots,D-1$.\n- Objective: minimize $0$ (the zero function), i.e., any feasible point is acceptable.\n- Inequality constraints: the transformed target and minimum mobility constraints as above.\n- Bounds: $0 \\le p_t \\le \\overline{P}_t$ for each $t$.\n\nAlgorithmic design:\n1. For each test case, compute $\\alpha = \\dfrac{\\eta\\, \\Delta t}{E_{\\mathrm{cap}}}$.\n2. If $D=0$, there are no decision variables. Feasibility reduces to checking $\\mathrm{SOC}_0 \\ge \\mathrm{SOC}_{\\mathrm{target}}$ and $\\mathrm{SOC}_0 \\ge \\mathrm{SOC}_{\\min}$. Return $True$ if both hold, otherwise $False$.\n3. Otherwise, construct the upper bounds $\\overline{P}_t = a_t \\cdot \\min\\{P^{\\max}_t, P^{\\mathrm{grid}}_t\\}$ for $t=0,\\dots,D-1$, and set variable bounds as $0 \\le p_t \\le \\overline{P}_t$.\n4. Build the inequality matrix-vector pair $(A_{\\mathrm{ub}}, b_{\\mathrm{ub}})$:\n   - The target constraint row has entries $A_{\\mathrm{ub}}^{(0,t)} = -\\alpha$ for $t=0,\\dots,D-1$ and $b_{\\mathrm{ub}}^{(0)} = -(\\mathrm{SOC}_{\\mathrm{target}} - \\mathrm{SOC}_0)$.\n   - For each $t=1,\\dots,D$, a minimum mobility row has entries $A_{\\mathrm{ub}}^{(t,u)} = -\\alpha$ for $u=0,\\dots,t-1$ and $A_{\\mathrm{ub}}^{(t,u)} = 0$ for $u=t,\\dots,D-1$, with $b_{\\mathrm{ub}}^{(t)} = -(\\mathrm{SOC}_{\\min} - \\mathrm{SOC}_0)$.\n5. Set the objective vector $c$ to the zero vector of length $D$ and solve the linear program. If the solver reports a feasible solution, return $True$; otherwise, return $False$.\n\nInterpretation for the test suite:\n- In the first case, the cumulative available energy and efficiency suffice to reach the target, so feasibility is expected.\n- In the second case, the single slot with low power is inadequate to produce the required state of charge increase, so infeasibility is expected.\n- In the third case, with immediate deadline and no charging opportunity, feasibility depends solely on the initial state of charge meeting both the target and minimum requirements.\n- In the fourth case, the upper bounds and availability are constructed so that the cumulative possible charging exactly meets the required state of charge increase at the efficiency given, resulting in exact-feasibility at the boundary.\n\nThe program implements this formulation and prints the boolean results for the four test cases in the specified single-line format.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef check_feasibility(E_cap, dt, D, eta, soc0, soc_min, soc_target,\n                      pmax, pgrid, availability):\n    \"\"\"\n    Check feasibility of reaching soc_target by deadline with linear constraints.\n    Parameters:\n        E_cap (float): Battery capacity in kWh.\n        dt (float): Slot duration in hours.\n        D (int): Number of slots to the deadline.\n        eta (float): Charging efficiency (0..1].\n        soc0 (float): Initial state of charge (0..1).\n        soc_min (float): Minimum mobility SOC (0..1).\n        soc_target (float): Target SOC by deadline (0..1).\n        pmax (array-like of length D): Per-slot charger maximum power in kW.\n        pgrid (array-like of length D): Per-slot grid upper bound in kW.\n        availability (array-like of length D): Per-slot availability (0 or 1).\n    Returns:\n        bool: True if feasible, False otherwise.\n    \"\"\"\n    # Handle the zero-slot boundary case directly.\n    if D == 0:\n        return (soc0 = soc_target) and (soc0 = soc_min)\n\n    alpha = eta * dt / E_cap\n\n    # Compute per-slot upper bounds considering availability and both limits.\n    pmax = np.array(pmax, dtype=float)\n    pgrid = np.array(pgrid, dtype=float)\n    availability = np.array(availability, dtype=float)\n\n    if pmax.shape[0] != D or pgrid.shape[0] != D or availability.shape[0] != D:\n        # Dimension mismatch: treat as infeasible for safety.\n        return False\n\n    ub = availability * np.minimum(pmax, pgrid)\n    bounds = [(0.0, float(ub_t)) for ub_t in ub]\n\n    # Build A_ub and b_ub for target and minimum SOC constraints.\n    # Target constraint: -alpha * sum(p_t) = -(soc_target - soc0)\n    A_rows = []\n    b_vals = []\n\n    A_target = -alpha * np.ones(D)\n    b_target = -(soc_target - soc0)\n    A_rows.append(A_target)\n    b_vals.append(b_target)\n\n    # Minimum SOC constraints for each intermediate time t = 1..D:\n    # -alpha * sum_{k=0..t-1}(p_k) = -(soc_min - soc0)\n    for t in range(1, D + 1):\n        row = np.zeros(D)\n        row[:t] = -alpha\n        A_rows.append(row)\n        b_vals.append(-(soc_min - soc0))\n\n    A_ub = np.vstack(A_rows)\n    b_ub = np.array(b_vals)\n\n    # Objective is zero vector (feasibility problem).\n    c = np.zeros(D)\n\n    # Solve the LP using HiGHS.\n    res = linprog(c=c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n\n    # Feasible if solver succeeded.\n    return bool(res.success)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # 1. Happy path feasibility with continuous availability.\n        {\n            \"E_cap\": 60.0, \"dt\": 0.25, \"D\": 16, \"eta\": 0.92,\n            \"soc0\": 0.5, \"soc_min\": 0.2, \"soc_target\": 0.8,\n            \"pmax\": [7.0]*16, \"pgrid\": [10.0]*16, \"availability\": [1]*16\n        },\n        # 2. Infeasible due to insufficient availability and low power.\n        {\n            \"E_cap\": 60.0, \"dt\": 1.0, \"D\": 1, \"eta\": 0.92,\n            \"soc0\": 0.7, \"soc_min\": 0.2, \"soc_target\": 0.9,\n            \"pmax\": [3.6], \"pgrid\": [3.6], \"availability\": [1]\n        },\n        # 3. Boundary case with immediate deadline (D=0).\n        {\n            \"E_cap\": 50.0, \"dt\": 0.25, \"D\": 0, \"eta\": 0.90,\n            \"soc0\": 0.7, \"soc_min\": 0.6, \"soc_target\": 0.7,\n            \"pmax\": [], \"pgrid\": [], \"availability\": []\n        },\n        # 4. Exact-feasibility boundary with intermittent availability and varying power limits.\n        {\n            \"E_cap\": 50.0, \"dt\": 0.25, \"D\": 5, \"eta\": 0.80,\n            \"soc0\": 0.6, \"soc_min\": 0.2, \"soc_target\": 0.8,\n            \"pmax\": [20.0, 20.0, 15.0, 20.0, 15.0],\n            \"pgrid\": [25.0, 25.0, 25.0, 25.0, 25.0],\n            \"availability\": [1, 0, 1, 0, 1]\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        result = check_feasibility(\n            case[\"E_cap\"], case[\"dt\"], case[\"D\"], case[\"eta\"],\n            case[\"soc0\"], case[\"soc_min\"], case[\"soc_target\"],\n            case[\"pmax\"], case[\"pgrid\"], case[\"availability\"]\n        )\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "To effectively serve a fleet of EVs, we must scale our analysis from a single vehicle to the system level of charging infrastructure. This practice challenges you to design an optimal charging station by balancing the number of Level 2 and DC Fast Chargers to minimize the total social cost—a combination of user waiting times and amortized capital investment. By applying M/M/c queuing theory within a mixed-integer optimization framework, you will tackle a core infrastructure planning problem, learning how to make data-driven decisions that weigh service quality against economic and physical constraints .",
            "id": "4087440",
            "problem": "Consider a single charging station that can be equipped with two types of electric vehicle charging plugs: Level 2 (L2) and Direct Current Fast Charging (DCFC). Assume two independent arrival streams of electric vehicles, one that uses L2 and one that uses DCFC. Each stream is modeled as a Poisson process with arrival rate $\\lambda$ (vehicles per hour), and each charging service time is exponentially distributed with service rate $\\mu$ (vehicles per hour per plug). The station has $n_L$ L2 plugs and $n_F$ DCFC plugs; both $n_L$ and $n_F$ are decision variables constrained to be nonnegative integers. Each plug type occupies physical area and costs money to procure. Let the generalized social cost be the sum of user waiting costs and amortized capital costs per hour. The Value Of Time (VOT) is $v$ dollars per hour. Each L2 plug has capital cost $\\text{Cap}_L$ dollars and footprint $\\text{Area}_L$ square meters, and each DCFC plug has capital cost $\\text{Cap}_F$ dollars and footprint $\\text{Area}_F$ square meters. The amortization factor $a$ converts capital cost to dollars per hour for social accounting. The station must satisfy a budget constraint and a footprint constraint.\n\nYour task is to formulate and solve the mixed-integer optimization problem that minimizes the generalized social cost:\n- Decision variables: $n_L \\in \\mathbb{Z}_{\\ge 0}$ and $n_F \\in \\mathbb{Z}_{\\ge 0}$.\n- Objective: Minimize $C = v \\cdot \\left( \\lambda_L \\cdot W_{q,L}(n_L) + \\lambda_F \\cdot W_{q,F}(n_F) \\right) + a \\cdot \\left( \\text{Cap}_L \\cdot n_L + \\text{Cap}_F \\cdot n_F \\right)$, where $W_{q,i}(n_i)$ is the expected waiting time in queue (in hours) in an $M/M/c$ system for class $i \\in \\{L, F\\}$ with $c = n_i$, arrival rate $\\lambda_i$, and service rate $\\mu_i$. Use the exact expected waiting time in queue for $M/M/c$ queues under the standard stability condition, and treat any configuration with $\\lambda_i \\ge \\mu_i \\cdot n_i$ as infeasible (infinite waiting time).\n- Constraints:\n  - Budget: $\\text{Cap}_L \\cdot n_L + \\text{Cap}_F \\cdot n_F \\le B$ (dollars).\n  - Footprint: $\\text{Area}_L \\cdot n_L + \\text{Area}_F \\cdot n_F \\le A$ (square meters).\n  - Stability for each stream $i \\in \\{L, F\\}$ with $\\lambda_i  0$: $\\lambda_i  \\mu_i \\cdot n_i$.\n- Units: Express the total generalized social cost in dollars per hour, rounded to three decimals. Vehicle arrivals and service rates are per hour, waiting times in hours, costs in dollars, and areas in square meters.\n\nIf multiple $(n_L, n_F)$ pairs attain the same minimal objective within numerical precision, break ties by choosing the configuration with the smallest total number of plugs $n_L + n_F$, and if still tied, choose the lexicographically smaller pair $(n_L, n_F)$.\n\nFor infeasible parameter sets in which no $(n_L, n_F)$ satisfies the constraints and stability, return the triple $[-1,-1,\\infty]$, where the counts are $-1$ and the cost is $+\\infty$.\n\nImplement a program that evaluates the following test suite of parameter sets and outputs the optimal $(n_L, n_F)$ and the corresponding minimized generalized social cost for each case. All numbers in this suite are scientifically plausible and self-consistent.\n\nTest Suite:\n- Case $1$ (balanced demand, ample resources):\n  - $\\lambda_L = 3.0$, $\\mu_L = 0.5$, $\\lambda_F = 5.0$, $\\mu_F = 3.0$, $v = 20.0$, $\\text{Cap}_L = 5000.0$, $\\text{Cap}_F = 40000.0$, $a = 0.001$, $B = 200000.0$, $A = 200.0$, $\\text{Area}_L = 10.0$, $\\text{Area}_F = 20.0$.\n- Case $2$ (tight resources near capacity):\n  - $\\lambda_L = 2.5$, $\\mu_L = 0.5$, $\\lambda_F = 8.0$, $\\mu_F = 3.0$, $v = 25.0$, $\\text{Cap}_L = 5000.0$, $\\text{Cap}_F = 40000.0$, $a = 0.001$, $B = 160000.0$, $A = 180.0$, $\\text{Area}_L = 12.0$, $\\text{Area}_F = 30.0$.\n- Case $3$ (one stream has no demand):\n  - $\\lambda_L = 1.0$, $\\mu_L = 0.5$, $\\lambda_F = 0.0$, $\\mu_F = 3.0$, $v = 15.0$, $\\text{Cap}_L = 5000.0$, $\\text{Cap}_F = 40000.0$, $a = 0.002$, $B = 20000.0$, $A = 80.0$, $\\text{Area}_L = 20.0$, $\\text{Area}_F = 25.0$.\n- Case $4$ (infeasible due to budget):\n  - $\\lambda_L = 4.0$, $\\mu_L = 0.5$, $\\lambda_F = 9.0$, $\\mu_F = 3.0$, $v = 25.0$, $\\text{Cap}_L = 5000.0$, $\\text{Cap}_F = 40000.0$, $a = 0.001$, $B = 25000.0$, $A = 200.0$, $\\text{Area}_L = 10.0$, $\\text{Area}_F = 20.0$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element is the list $[n_L,n_F,\\text{cost}]$ for one case in the order given above. For example, the output format is $[[n_{L,1},n_{F,1},\\text{cost}_1],[n_{L,2},n_{F,2},\\text{cost}_2],[n_{L,3},n_{F,3},\\text{cost}_3],[n_{L,4},n_{F,4},\\text{cost}_4]]$. The cost must be rounded to three decimals and expressed in dollars per hour.",
            "solution": "The user has provided a well-defined mixed-integer nonlinear programming problem concerning the optimal design of an electric vehicle charging station. The problem is scientifically grounded in queueing theory and economic principles, and all parameters and constraints are clearly specified. It is thus deemed a valid problem.\n\n### 1. Problem Formulation\n\nThe objective is to determine the optimal number of Level 2 (L2) chargers, $n_L$, and Direct Current Fast Charging (DCFC) chargers, $n_F$, to install at a station. The decision variables are $n_L \\in \\mathbb{Z}_{\\ge 0}$ and $n_F \\in \\mathbb{Z}_{\\ge 0}$.\n\nThe goal is to minimize the generalized social cost per hour, $C$, which is the sum of user waiting time costs and amortized capital investment costs. The objective function is:\n$$\n\\min_{n_L, n_F} C(n_L, n_F) = v \\cdot \\left( \\lambda_L \\cdot W_{q,L}(n_L) + \\lambda_F \\cdot W_{q,F}(n_F) \\right) + a \\cdot \\left( \\text{Cap}_L \\cdot n_L + \\text{Cap}_F \\cdot n_F \\right)\n$$\nThis minimization is subject to several constraints:\n1.  **Budget Constraint**: The total capital cost cannot exceed the budget $B$.\n    $$ \\text{Cap}_L \\cdot n_L + \\text{Cap}_F \\cdot n_F \\le B $$\n2.  **Footprint Constraint**: The total area occupied by the chargers cannot exceed the available station area $A$.\n    $$ \\text{Area}_L \\cdot n_L + \\text{Area}_F \\cdot n_F \\le A $$\n3.  **Stability Constraints**: For each charger type $i \\in \\{L, F\\}$ with a non-zero arrival rate $\\lambda_i  0$, the total service rate must exceed the arrival rate to ensure the queue is stable (i.e., does not grow infinitely).\n    $$ \\lambda_i  \\mu_i \\cdot n_i \\quad \\text{for } i \\in \\{L, F\\} \\text{ if } \\lambda_i  0 $$\n\n### 2. Modeling Queueing and Costs\n\nThe problem models the two types of charging services as independent M/M/c queueing systems. An M/M/c queue is characterized by Poisson arrivals (M), exponential service times (M), and $c$ parallel identical servers.\n\n-   For L2 chargers, we have an M/M/$n_L$ system with arrival rate $\\lambda_L$ and per-plug service rate $\\mu_L$.\n-   For DCFC chargers, we have an M/M/$n_F$ system with arrival rate $\\lambda_F$ and per-plug service rate $\\mu_F$.\n\nThe term $W_{q,i}(n_i)$ in the objective function represents the expected waiting time in the queue (not including service time) for a vehicle of type $i$. For an M/M/c system with $c$ servers, arrival rate $\\lambda$, and service rate $\\mu$, the expected waiting time in queue, $W_q$, is given by:\n$$\nW_q(c, \\lambda, \\mu) = \\frac{L_q}{\\lambda}\n$$\nwhere $L_q$ is the expected number of customers in the queue. This can be calculated using the Erlang C formula, which gives the probability $P_q$ that an arriving customer must wait in queue. The formula for $W_q$ is:\n$$\nW_q(c, \\lambda, \\mu) = \\frac{P_q}{c\\mu - \\lambda}\n$$\nwhere the probability of queueing, $P_q$, is:\n$$\nP_q = \\frac{\\frac{(\\lambda/\\mu)^c}{c!(1 - \\rho)}}{\\sum_{k=0}^{c-1} \\frac{(\\lambda/\\mu)^k}{k!} + \\frac{(\\lambda/\\mu)^c}{c!(1 - \\rho)}}\n$$\nand $\\rho = \\frac{\\lambda}{c\\mu}$ is the system utilization. This formula is valid only under the stability condition $\\rho  1$, which is equivalent to $\\lambda  c\\mu$. If this condition is not met, the queue length and waiting time are considered infinite. If $\\lambda = 0$, the waiting time is $0$.\n\nThe total cost function combines the user-side cost (value of time spent waiting) and the operator-side cost (amortized capital investment) into a single metric for optimization.\n\n### 3. Solution Algorithm\n\nSince the decision variables $n_L$ and $n_F$ are non-negative integers and their feasible range is bounded by the budget and area constraints, we can solve this optimization problem by performing an exhaustive search over all valid pairs $(n_L, n_F)$.\n\nThe algorithm proceeds as follows for each test case:\n1.  **Define Search Space**: The maximum possible values for $n_L$ and $n_F$ are limited by the constraints. For a given $n_L$, the maximum possible $n_F$ is constrained by $n_F \\le \\lfloor \\min((B - \\text{Cap}_L n_L)/\\text{Cap}_F, (A - \\text{Area}_L n_L)/\\text{Area}_F) \\rfloor$. This suggests a nested loop structure.\n\n2.  **Iterate and Evaluate**: We iterate through all non-negative integer values of $n_L$ starting from $0$. For each $n_L$, we iterate through all non-negative integer values of $n_F$ starting from $0$.\n    -   For each pair $(n_L, n_F)$, we first check if it satisfies the budget and area constraints. If not, we can break the inner loop (for $n_F$) and continue to the next $n_L$, as any larger $n_F$ will also violate the constraint. Similarly, the outer loop for $n_L$ can be terminated once $n_L$ alone violates the constraints.\n\n3.  **Calculate Cost**: For a pair $(n_L, n_F)$ that is feasible with respect to budget and area:\n    -   We check the stability condition for both the L2 and DCFC queues. If either queue is unstable (i.e., $\\lambda_i \\ge \\mu_i n_i$ for $\\lambda_i  0$), the waiting time is infinite, and thus the total cost for this configuration is infinite.\n    -   If both queues are stable, we calculate $W_{q,L}(n_L)$ and $W_{q,F}(n_F)$ using the M/M/c formula.\n    -   The total social cost $C(n_L, n_F)$ is then computed.\n\n4.  **Find Minimum and Handle Ties**:\n    -   We maintain a variable `min_cost`, initialized to infinity, and a list `solutions` to store the best configuration(s) found.\n    -   If the `current_cost` for $(n_L, n_F)$ is less than `min_cost`, we update `min_cost` and replace `solutions` with the new best pair, i.e., `solutions = [(n_L, n_F)]`.\n    -   If `current_cost` is equal to `min_cost` (within a small tolerance for floating-point comparison), we append the current pair to the `solutions` list to handle ties.\n\n5.  **Apply Tie-Breaking Rules**: After checking all feasible pairs, if the `solutions` list is not empty, we sort it to find the unique best solution according to the specified rules:\n    1.  Smallest total number of plugs ($n_L + n_F$).\n    2.  Lexicographically smaller pair $(n_L, n_F)$.\n    This is achieved by sorting the `solutions` list using a key `(n_L + n_F, n_L)`. The first element of the sorted list is the optimal configuration.\n\n6.  **Handle Infeasibility**: If, after checking all pairs within the budget and area limits, the `solutions` list remains empty, it means no configuration is both physically/economically feasible and stable. In this case, the problem is infeasible, and the output is $[-1, -1, \\infty]$.\n\nThe accompanying Python code implements this complete algorithm. A helper function `calculate_wq` is used to compute the M/M/c waiting time, handling stability checks and the case of zero arrivals. The main `solve` function iterates through the test cases, applies the search algorithm for each, formats the results, and prints the final output.",
            "answer": "```python\nimport math\nimport numpy as np\n\ndef calculate_wq(c, lam, mu):\n    \"\"\"\n    Calculates the expected waiting time in queue for an M/M/c system.\n    \n    Args:\n        c (int): Number of servers.\n        lam (float): Arrival rate.\n        mu (float): Service rate per server.\n        \n    Returns:\n        float: Expected waiting time in queue (Wq). Returns infinity if unstable.\n    \"\"\"\n    if lam == 0:\n        return 0.0\n    \n    if c == 0:\n        return np.inf\n\n    # Stability condition: lambda  c * mu\n    if lam = c * mu:\n        return np.inf\n\n    rho = lam / (c * mu)\n    u = lam / mu\n\n    # Calculate P0, the probability of an empty system\n    sum_term = 0.0\n    # Use log scale for numerical stability, though direct is fine for these parameters\n    current_term_log = 0.0  # for (u^0 / 0!)\n    sum_term_log = [current_term_log]\n    for k in range(1, c):\n        current_term_log += math.log(u) - math.log(k)\n        sum_term_log.append(current_term_log)\n    \n    # Log-sum-exp trick to sum terms\n    max_log = max(sum_term_log)\n    sum_of_exps = sum(math.exp(log_val - max_log) for log_val in sum_term_log)\n    sum_term = math.exp(max_log) * sum_of_exps\n\n    # Final term in the P0 denominator\n    last_term_log = 0.0\n    if u  0: # Avoid log(0)\n        try:\n            last_term_log = c * math.log(u) - math.lgamma(c + 1)\n        except ValueError: # math domain error if u is negative, shouldn't happen\n            return np.inf\n            \n    last_term = math.exp(last_term_log) / (1 - rho)\n\n    p0 = 1.0 / (sum_term + last_term)\n    \n    # Calculate Pq, the probability of queueing (Erlang C formula)\n    pq = p0 * last_term\n\n    # Calculate Wq\n    wq = pq / (c * mu - lam)\n    \n    return wq\n\ndef solve_case(params):\n    \"\"\"\n    Solves the optimization problem for a single parameter set.\n    \"\"\"\n    lambda_L, mu_L, lambda_F, mu_F, v, cap_L, cap_F, a, B, A, area_L, area_F = params\n\n    min_cost = np.inf\n    solutions = []\n\n    # Determine a reasonable upper bound for n_L to make the search finite\n    nL_max_budget = B / cap_L if cap_L  0 else np.inf\n    nL_max_area = A / area_L if area_L  0 else np.inf\n    nL_max = int(min(nL_max_budget, nL_max_area)) + 2\n\n    nL = 0\n    while True:\n        cost_L_cap = cap_L * nL\n        area_L_used = area_L * nL\n\n        if cost_L_cap  B or area_L_used  A:\n            break\n\n        # Determine a reasonable upper bound for n_F\n        nF_max_budget = (B - cost_L_cap) / cap_F if cap_F  0 else np.inf\n        nF_max_area = (A - area_L_used) / area_F if area_F  0 else np.inf\n        nF_max = int(min(nF_max_budget, nF_max_area)) + 2\n        \n        nF = 0\n        while True:\n            cost_F_cap = cap_F * nF\n            area_F_used = area_F * nF\n            \n            total_cap = cost_L_cap + cost_F_cap\n            total_area = area_L_used + area_F_used\n\n            if total_cap  B or total_area  A:\n                break\n\n            #\n            # This pair (nL, nF) is feasible in terms of budget and area.\n            # Now check stability and calculate cost.\n            #\n            wq_L = calculate_wq(nL, lambda_L, mu_L)\n            wq_F = calculate_wq(nF, lambda_F, mu_F)\n            \n            if np.isinf(wq_L) or np.isinf(wq_F):\n                current_cost = np.inf\n            else:\n                waiting_cost = v * (lambda_L * wq_L + lambda_F * wq_F)\n                capital_cost = a * (cap_L * nL + cap_F * nF)\n                current_cost = waiting_cost + capital_cost\n            \n            if current_cost  min_cost:\n                min_cost = current_cost\n                solutions = [(nL, nF)]\n            elif not np.isinf(current_cost) and abs(current_cost - min_cost)  1e-9:\n                solutions.append((nL, nF))\n\n            if nF = nF_max:\n                break\n            nF += 1\n        \n        if nL = nL_max:\n            break\n        nL += 1\n\n    if not solutions:\n        return [-1, -1, np.inf]\n    else:\n        # Apply tie-breaking rules\n        # 1. smallest total number of plugs nL + nF\n        # 2. lexicographically smaller pair (nL, nF)\n        solutions.sort(key=lambda x: (x[0] + x[1], x[0]))\n        best_nL, best_nF = solutions[0]\n        return [best_nL, best_nF, min_cost]\n\ndef solve():\n    test_cases = [\n        # Case 1\n        (3.0, 0.5, 5.0, 3.0, 20.0, 5000.0, 40000.0, 0.001, 200000.0, 200.0, 10.0, 20.0),\n        # Case 2\n        (2.5, 0.5, 8.0, 3.0, 25.0, 5000.0, 40000.0, 0.001, 160000.0, 180.0, 12.0, 30.0),\n        # Case 3\n        (1.0, 0.5, 0.0, 3.0, 15.0, 5000.0, 40000.0, 0.002, 20000.0, 80.0, 20.0, 25.0),\n        # Case 4\n        (4.0, 0.5, 9.0, 3.0, 25.0, 5000.0, 40000.0, 0.001, 25000.0, 200.0, 10.0, 20.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = solve_case(case)\n        if np.isinf(result[2]):\n            results.append(\"[-1,-1,inf]\")\n        else:\n            results.append(f\"[{result[0]},{result[1]},{result[2]:.3f}]\")\n    \n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}