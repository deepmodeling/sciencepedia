{
    "hands_on_practices": [
        {
            "introduction": "掌握理论的最好方法是将其付诸实践。本节的第一个练习将引导您分析解决一个经典的经济调度问题，该问题是能源系统建模的核心。通过为这个凸二次规划（Quadratic Program, QP）问题构建并求解卡罗需-库恩-塔克（Karush-Kuhn-Tucker, KKT）条件，您将深入理解约束优化中的一阶最优性条件，并体会到凸性如何保证我们找到全局最优解。",
            "id": "4110217",
            "problem": "一个电力系统运营商必须调度两台火电机组，以经济有效的方式满足固定的负荷需求。每台机组 $i \\in \\{1,2\\}$ 都有一个凸二次燃料成本函数，这与能源系统中标准的热耗率建模一致。考虑以下以标准二次规划 (QP) 形式写出的经济调度问题：\n$$\\min_{\\mathbf{p} \\in \\mathbb{R}^{2}} \\;\\; \\frac{1}{2}\\,\\mathbf{p}^{\\top}\\mathbf{H}\\,\\mathbf{p} + \\mathbf{f}^{\\top}\\mathbf{p} + c_{0} \\quad \\text{subject to} \\quad \\mathbf{A}\\,\\mathbf{p} = d, \\quad \\mathbf{0} \\le \\mathbf{p} \\le \\mathbf{p}^{\\max},$$\n其中 $\\mathbf{p} = \\begin{pmatrix} p_{1} \\\\ p_{2} \\end{pmatrix}$ 是以兆瓦 (MW) 为单位的机组出力向量，$\\mathbf{H} = \\begin{pmatrix} 2  0 \\\\ 0  4 \\end{pmatrix}$ 是一个对称正定矩阵，代表二次边际成本，$\\mathbf{f} = \\begin{pmatrix} 10 \\\\ 6 \\end{pmatrix}$ 代表线性成本项，$c_{0} \\in \\mathbb{R}$ 是一个常数项，$\\mathbf{A} = \\begin{pmatrix} 1  1 \\end{pmatrix}$ 强制功率平衡，$d = 50$ 是以兆瓦 (MW) 为单位的总需求，以及 $\\mathbf{p}^{\\max} = \\begin{pmatrix} 100 \\\\ 100 \\end{pmatrix}$ 是铭牌容量上限。下限为零反映了发电量的非负性。所有量都是确定性的，并且反映了一个没有损耗或爬坡约束的单周期静态调度。\n\n从二次型的凸性和约束优化中的最优性条件的核心定义出发，通过构建并利用线性代数求解 Karush-Kuhn-Tucker (KKT) 系统的一阶最优性条件，来解析地推导出最优调度方案 $\\mathbf{p}^{\\star}$。您的推导必须明确论证此问题类别中凸性的存在以及 KKT 条件对于最优性的充分性。验证在解处是否有任何边界约束是有效的。\n\n用兆瓦 (MW) 表示最终的最优机组出力 $p_{1}^{\\star}$ 和 $p_{2}^{\\star}$。提供精确值，不要四舍五入。最终答案必须是仅包含 $(p_{1}^{\\star}, p_{2}^{\\star})$ 的单个行向量。",
            "solution": "所提供的问题是一个双机组系统的经济调度问题，被表述为一个二次规划 (QP) 问题。在进行求解之前，需要对问题陈述进行验证。\n\n### 步骤 1：提取已知条件\n- 优化变量：$\\mathbf{p} = \\begin{pmatrix} p_{1} \\\\ p_{2} \\end{pmatrix} \\in \\mathbb{R}^{2}$\n- 目标函数：$\\min_{\\mathbf{p}} \\;\\; \\frac{1}{2}\\,\\mathbf{p}^{\\top}\\mathbf{H}\\,\\mathbf{p} + \\mathbf{f}^{\\top}\\mathbf{p} + c_{0}$\n- 二次成本矩阵：$\\mathbf{H} = \\begin{pmatrix} 2  0 \\\\ 0  4 \\end{pmatrix}$\n- 线性成本向量：$\\mathbf{f} = \\begin{pmatrix} 10 \\\\ 6 \\end{pmatrix}$\n- 成本常数项：$c_{0} \\in \\mathbb{R}$\n- 等式约束矩阵：$\\mathbf{A} = \\begin{pmatrix} 1  1 \\end{pmatrix}$\n- 等式约束右侧（需求）：$d = 50$\n- 下限约束：$\\mathbf{p} \\ge \\mathbf{0}$，其中 $\\mathbf{0} = \\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix}$\n- 上限约束：$\\mathbf{p} \\le \\mathbf{p}^{\\max}$，其中 $\\mathbf{p}^{\\max} = \\begin{pmatrix} 100 \\\\ 100 \\end{pmatrix}$\n\n### 步骤 2：使用提取的已知条件进行验证\n- **科学依据**：该问题对火电机组使用了标准的凸二次成本函数模型，并强制执行了功率平衡方程和容量限制。这是电力系统经济学中一个基本且成熟的公式。该设置在科学上是合理的。\n- **适定性**：该问题是一个 QP 问题。目标函数的海森矩阵是给定的矩阵 $\\mathbf{H}$。对角矩阵 $\\mathbf{H}$ 的特征值是其对角线元素，即 $\\lambda_1 = 2$ 和 $\\lambda_2 = 4$。由于两个特征值都是严格正的，因此 $\\mathbf{H}$ 是正定的，目标函数是严格凸的。所有约束都是线性的，定义了一个凸且紧的可行集（一个线段）。在一个非空、闭合、凸集上对一个严格凸函数进行最小化，会得到一个唯一的解。因此，该问题是适定的。\n- **客观性**：该问题使用精确的数学符号和无歧义的语言进行陈述。它是客观的。\n\n### 步骤 3：结论与行动\n问题是有效的。将通过构建和求解 Karush-Kuhn-Tucker (KKT) 条件来推导解答。\n\n### 最优调度的推导\n\n该优化问题是：\n$$ \\min_{p_1, p_2} \\;\\; f(\\mathbf{p}) = \\frac{1}{2}\\begin{pmatrix} p_1  p_2 \\end{pmatrix} \\begin{pmatrix} 2  0 \\\\ 0  4 \\end{pmatrix} \\begin{pmatrix} p_1 \\\\ p_2 \\end{pmatrix} + \\begin{pmatrix} 10  6 \\end{pmatrix} \\begin{pmatrix} p_1 \\\\ p_2 \\end{pmatrix} + c_0 $$\n$$ \\text{subject to:} $$\n$$ p_1 + p_2 = 50 $$\n$$ 0 \\le p_1 \\le 100 $$\n$$ 0 \\le p_2 \\le 100 $$\n\n展开后即最小化 $f(p_1, p_2) = p_1^2 + 2p_2^2 + 10p_1 + 6p_2 + c_0$。如前所述，目标函数是严格凸的，可行域是凸的。因此，KKT 条件是全局最优的充分必要条件。\n\n该问题的拉格朗日函数 $\\mathcal{L}$ 是通过将拉格朗日乘子与每个约束关联来构建的。设 $\\lambda$ 为等式约束的乘子，$\\mu_{1,L}$ 和 $\\mu_{2,L}$ 为下限约束（$p_1 \\ge 0, p_2 \\ge 0$）的乘子，$\\mu_{1,U}$ 和 $\\mu_{2,U}$ 为上限约束（$p_1 \\le 100, p_2 \\le 100$）的乘子。约束以 $g(\\mathbf{p}) \\le 0$ 的形式写出。\n\n$\\mathcal{L}(p_1, p_2, \\lambda, \\boldsymbol{\\mu}) = p_1^2 + 2p_2^2 + 10p_1 + 6p_2 + c_0 + \\lambda(p_1+p_2-50) - \\mu_{1,L}p_1 - \\mu_{2,L}p_2 + \\mu_{1,U}(p_1-100) + \\mu_{2,U}(p_2-100)$\n\nKKT 条件如下：\n1.  **平稳性**：拉格朗日函数相对于原始变量 $(p_1, p_2)$ 的梯度必须为零。\n    $$ \\frac{\\partial \\mathcal{L}}{\\partial p_1} = 2p_1 + 10 + \\lambda - \\mu_{1,L} + \\mu_{1,U} = 0 $$\n    $$ \\frac{\\partial \\mathcal{L}}{\\partial p_2} = 4p_2 + 6 + \\lambda - \\mu_{2,L} + \\mu_{2,U} = 0 $$\n2.  **原始可行性**：解必须满足所有约束。\n    $$ p_1 + p_2 = 50 $$\n    $$ 0 \\le p_1 \\le 100 $$\n    $$ 0 \\le p_2 \\le 100 $$\n3.  **对偶可行性**：不等式约束的拉格朗日乘子必须为非负。\n    $$ \\mu_{1,L}, \\mu_{2,L}, \\mu_{1,U}, \\mu_{2,U} \\ge 0 $$\n4.  **互补松弛性**：不等式乘子与其对应松弛量的乘积必须为零。\n    $$ \\mu_{1,L} p_1 = 0, \\quad \\mu_{2,L} p_2 = 0 $$\n    $$ \\mu_{1,U} (p_1 - 100) = 0, \\quad \\mu_{2,U} (p_2 - 100) = 0 $$\n\n为了求解这个系统，我们首先做一个简化假设，即没有边界约束是有效的，这意味着 $0  p_1  100$ 且 $0  p_2  100$。对于相对于机组容量而言适中的需求水平，这是一个合理的初始假设。\n\n如果没有边界约束有效，互补松弛性意味着它们对应的乘子为零：$\\mu_{1,L}=\\mu_{1,U}=0$ 且 $\\mu_{2,L}=\\mu_{2,U}=0$。平稳性条件简化为：\n$$ 2p_1 + 10 + \\lambda = 0 \\quad \\implies \\quad 2p_1 + 10 = -\\lambda $$\n$$ 4p_2 + 6 + \\lambda = 0 \\quad \\implies \\quad 4p_2 + 6 = -\\lambda $$\n项 $-\\lambda$ 是系统的边际电价。对于最优调度，两台机组的增量成本必须等于这个价格。令这两个表达式相等，得到：\n$$ 2p_1 + 10 = 4p_2 + 6 $$\n$$ 2p_1 - 4p_2 = -4 $$\n$$ p_1 - 2p_2 = -2 $$\n我们现在得到了一个包含两个变量的两个线性方程组，即这个方程和功率平衡方程：\n1. $p_1 - 2p_2 = -2$\n2. $p_1 + p_2 = 50$\n\n用方程 (2) 减去方程 (1) 得到：\n$$ (p_1 + p_2) - (p_1 - 2p_2) = 50 - (-2) $$\n$$ 3p_2 = 52 $$\n$$ p_2^{\\star} = \\frac{52}{3} $$\n将此值代回功率平衡方程以求得 $p_1$：\n$$ p_1^{\\star} = 50 - p_2^{\\star} = 50 - \\frac{52}{3} = \\frac{150 - 52}{3} = \\frac{98}{3} $$\n所提出的最优调度方案为 $\\mathbf{p}^{\\star} = \\begin{pmatrix} 98/3 \\\\ 52/3 \\end{pmatrix}$。\n\n最后，我们必须验证该解是否与我们最初的假设（即没有边界约束是有效的）一致。\n对于机组 1：$p_1^{\\star} = \\frac{98}{3} \\approx 32.67$。该值满足 $0  32.67  100$。\n对于机组 2：$p_2^{\\star} = \\frac{52}{3} \\approx 17.33$。该值满足 $0  17.33  100$。\n\n边界的两个原始可行性条件都得到严格满足。这证实了我们最初的假设是正确的，并且乘子 $\\mu_{1,L}, \\mu_{1,U}, \\mu_{2,L}, \\mu_{2,U}$ 确实都为零。所有 KKT 条件均已满足。由于 KKT 条件对于这个严格凸问题是充分的，因此唯一的全局最小值是 $\\mathbf{p}^{\\star} = \\begin{pmatrix} 98/3 \\\\ 52/3 \\end{pmatrix}$。在解处没有边界约束是有效的。",
            "answer": "$$\\boxed{\\begin{pmatrix} \\frac{98}{3}  \\frac{52}{3} \\end{pmatrix}}$$"
        },
        {
            "introduction": "现实世界中的能源系统模型常常包含由开关决策（例如发电机启停）引入的非凸性。这个练习将挑战您处理一个典型的非凸成本函数，并使用一种名为“透视变换”（perspective transformation）的先进技术来推导其最紧的凸包络。掌握这项技能对于构建可在混合整数二阶锥规划（Mixed-Integer Second-Order Cone Programming, MISOCP）求解器中高效求解的高质量松弛至关重要。",
            "id": "4110222",
            "problem": "考虑能源系统模型中的单个发电机，其具有一个二进制开/关状态变量 $u \\in \\{0,1\\}$ 和一个非负功率输出 $p \\geq 0$。当发电机开启时（即 $u=1$），其瞬时损耗成本被建模为凸二次函数 $f(p) = p^{2}$。当发电机关闭时（即 $u=0$），它必须不产生功率，因此 $p=0$，损耗成本为 $f(0)=0$。运行范围施加了标准的耦合约束 $0 \\leq p \\leq \\overline{P}\\,u$，其中 $\\overline{P}  0$ 是发电机开启时的已知最大输出功率。为了构建一个适用于混合整数二阶锥规划（MISOCP）的易于处理的凸松弛，为损耗成本引入一个辅助的上境图变量 $t$，并将二进制变量松弛为 $u \\in [0,1]$。\n\n从凸性、上境图和凸函数的透视变换的定义出发，推导在松弛域上带有耦合约束的损耗成本的最紧凸下包络。具体来说，刻画出最小的凸函数 $t(p,u)$，它在 $u \\in \\{0,1\\}$ 且 $p$ 满足 $0 \\leq p \\leq \\overline{P}\\,u$ 时，为原始的开/关损耗 $p^{2}$ 提供下界，并且该函数可以扩展为在 $u \\in [0,1]$ 上的凸函数。\n\n请以单一闭式解析表达式的形式给出 $t(p,u)$ 的最终答案，该表达式在 $u \\in (0,1]$ 上有效，仅用 $p$ 和 $u$ 表示，不含任何分段情况，且表达式中不包含物理单位。您可以假设在 $(p,u)=(0,0)$ 处的闭包由连续性良定义。不需要进行数值舍入。",
            "solution": "该问题要求推导具有二进制启停状态的发电机损耗成本的最紧凸下包络。我们首先正式陈述问题，然后利用凸分析的原理进行推导。\n\n首先，我们验证问题陈述。\n\n### 第1步：提取已知条件\n- 一个二进制启停变量 $u \\in \\{0,1\\}$。\n- 一个非负功率输出 $p \\geq 0$。\n- 当发电机开启时（$u=1$），损耗成本函数为 $f(p) = p^{2}$。该函数是凸函数。\n- 当发电机关闭时（$u=0$），功率输出必须为零（$p=0$），损耗成本为 $f(0)=0$。\n- 一个耦合约束将功率输出与启停状态联系起来：$0 \\leq p \\leq \\overline{P}\\,u$，其中 $\\overline{P}  0$ 是一个代表最大功率输出的给定常数。\n- 为用于混合整数二阶锥规划（MISOCP），通过将二进制变量松弛为 $u \\in [0,1]$ 并为损耗成本引入一个辅助的上境图变量 $t$ 来对优化问题进行松弛。\n- 目标是推导在松弛域上损耗成本的最紧凸下包络，记为 $t(p,u)$。该包络必须是一个凸函数，为 $u \\in \\{0,1\\}$ 时的原始成本提供下界，并在连续域 $\\{(p,u) \\mid u \\in [0,1], 0 \\leq p \\leq \\overline{P}\\,u\\}$ 上有定义。\n- 最终答案應为 $t(p,u)$ 在 $u \\in (0,1]$ 上的单一闭式表达式。\n\n### 第2步：使用提取的已知条件进行验证\n- **科学依据**：该问题在能源系统建模和优化领域有坚实的理论基础。使用二次函数建模发电机成本和使用二进制变量表示开/关状态是标准做法。使用凸松弛、上境图和MISOCP是解决此类混合整数非线性问题的先进技术。\n- **良态性**：该问题是良态的。在一个指定域上寻找一个函数的凸包络在数学上是一个具有唯一解的明确定义问题。\n- **客观性**：问题使用精确、客观的数学语言陈述。\n- 该问题没有任何科学或事实上的不健全之处，是可形式化的、完整的、可行的和结构良好的。它代表了凸分析的一个非平凡应用。\n\n### 第3步：结论与行动\n问题有效。我们继续进行求解。\n\n由于二进制变量 $u$ 的存在，原始成本结构本质上是非凸的。让我们在由 $u \\in \\{0,1\\}$ 和 $0 \\leq p \\leq \\overline{P}\\,u$ 指定的非凸域上定义有效成本函数 $C(p,u)$。\n这给出：\n$C(p,u) = \\begin{cases} p^2  \\text{若 } u=1, 0 \\leq p \\leq \\overline{P} \\\\ 0  \\text{若 } u=0, p=0 \\end{cases}$\n我们引入一个上境图变量 $t$ 来表示成本，使得 $t \\geq C(p,u)$。与原始问题成本函数图像对应的点集 $(p,u,t)$ 是一个点和一段抛物线段的并集：\n$S_{graph} = \\{(0,0,0)\\} \\cup \\{ (p, 1, p^2) \\mid p \\in [0, \\overline{P}] \\}$\n任务是在松弛域 $D_{rel} = \\{(p,u) \\mid u \\in [0,1], 0 \\leq p \\leq \\overline{P}\\,u\\}$ 上找到该函数的凸包络。凸包络的上境图是原始函数上境图的凸包。凸包络本身是其图像为该凸包下边界的函数。\n\n构建涉及像 $u$ 这样的缩放变量的函数的凸包络的一个强大工具是透視变换。给定一个凸函数 $g(x)$，其透视函数定义为 $h(x,\\lambda) = \\lambda \\, g(x/\\lambda)$，其中缩放变量 $\\lambda  0$。函数 $h(x,\\lambda)$ 在 $(x,\\lambda)$ 上是联合凸的。\n\n在我们的问题中，“开启”状态（$u=1$）的基础成本函数是 $f(p)=p^2$。这是关于 $p$ 的凸函数。我们可以将功率输出 $p$ 对应于一般变量 $x$，将启停变量 $u$ 对应于缩放变量 $\\lambda$。\n\n我们将透视变换应用于 $f(p)=p^2$，使用缩放变量 $u$。这就得到了下包络的函数，我们将其记为 $t(p,u)$：\n$$t(p,u) = u \\cdot f(p/u) = u \\left( \\frac{p}{u} \\right)^2 = \\frac{p^2}{u}$$\n该表达式在 $u0$ 时有定义。让我们分析它的性质。\n\n1. **凸性**：由于 $f(p)=p^2$ 是一个凸函数，其透视函数 $t(p,u)=p^2/u$ 在其定义域（即 $u0$）上是关于 $(p,u)$ 的联合凸函数。\n\n2. **与整数点的一致性**：我们必须检查该函数是否在 $u$ 的整数值处正确表示成本。\n- 对于 $u=1$：该公式给出 $t(p,1) = p^2/1 = p^2$。这与“开启”状态的原始成本函数 $f(p)=p^2$ 完全匹配。\n- 对于 $u=0$：表达式 $p^2/u$ 未定义。然而，问题陈述允许我们考虑函数在 $(p,u)=(0,0)$ 处的闭包，该闭包由连续性良定义。松弛域要求 $0 \\leq p \\leq \\overline{P}\\,u$。当 $u \\to 0^+$ 时，这迫使 $p \\to 0$。我们计算当 $(p,u)$ 在此域内趋近于 $(0,0)$ 时 $t(p,u)$ 的极限：\n$$ \\lim_{(p,u) \\to (0,0), u0, 0 \\leq p \\leq \\overline{P}u} \\frac{p^2}{u} $$\n根据约束 $p \\leq \\overline{P}u$，我们有 $p^2 \\leq \\overline{P}^2 u^2$。两边同除以 $u$（因为 $u0$），我们得到：\n$$ 0 \\leq \\frac{p^2}{u} \\leq \\overline{P}^2 u $$\n当 $u \\to 0^+$ 时，项 $\\overline{P}^2 u$ 趋近于 $0$。根据夹逼定理，我们有：\n$$ \\lim_{(p,u) \\to (0,0), (p,u) \\in D_{rel}} t(p,u) = 0 $$\n该极限与“关闭”状态的成本 $C(0,0)=0$ 相匹配。因此，定义为当 $u0$ 时为 $p^2/u$ 且在 $(p,u)=(0,0)$ 时为 $0$ 的函数 $t(p,u)$ 在整个松弛域 $D_{rel}$ 上是连续的。由此闭包形成的函数在凸集 $D_{rel}$ 上是凸的。\n\n3. **最紧下界**：为了确认 $t(p,u) = p^2/u$ 是凸包络（即，最紧的可能凸下界），我们考虑松弛域 $D_{rel}$ 中 $u \\in (0,1)$ 的任意点 $(p,u)$。该点可以表示为来自原始整数域的两个点的凸组合：\n$$ (p,u) = (1-u)(0,0) + u\\left(\\frac{p}{u}, 1\\right) $$\n注意点 $(p/u, 1)$ 位于“开启”域中，因为当 $u0$ 时，$0 \\leq p \\leq \\overline{P}u$ 意味着 $0 \\leq p/u \\leq \\overline{P}$。\n令 $\\phi(p,u)$ 是原始成本函数 $C(p,u)$ 的任意凸下界函数。根据凸函数的琴生不等式（Jensen's inequality），我们必然有：\n$$ \\phi(p,u) = \\phi\\left((1-u)(0,0) + u\\left(\\frac{p}{u}, 1\\right)\\right) \\leq (1-u)\\phi(0,0) + u\\,\\phi\\left(\\frac{p}{u}, 1\\right) $$\n由于 $\\phi$ 是一个下界，$\\phi(0,0) \\leq C(0,0) = 0$ 且 $\\phi(p/u, 1) \\leq C(p/u, 1) = (p/u)^2$。为了获得最紧的界，我们必须在函数有定义的整数点上取等号，因此我们考虑 $\\phi(0,0)=0$ 和 $\\phi(p/u, 1) = (p/u)^2$。\n將這些代入不等式得到：\n$$ \\phi(p,u) \\leq (1-u)(0) + u\\left(\\frac{p}{u}\\right)^2 = u \\frac{p^2}{u^2} = \\frac{p^2}{u} $$\n这表明任何凸下估计函数 $\\phi(p,u)$ 都必须小于或等于 $p^2/u$。由于我们的候选函数 $t(p,u)=p^2/u$ 本身是凸的，并且以等号满足此上界，因此它必须是最大的凸下界，这正是凸包络的定义。\n\n得到的约束是 $t \\geq p^2/u$，它在 $u0$ 时有效。在MISOCP的背景下，这通常被重写为二阶锥约束 $p^2 \\leq tu$（对于 $t \\geq 0, u \\geq 0$），这等价于 $\\|(2p, t-u)\\|_2 \\leq t+u$。这证明了所推导形式的实用性。\n\n要求的最终答案是 $t(p,u)$ 在 $u \\in (0,1]$ 上有效的单一闭式表达式。这就是从透视函数推导出的表达式。",
            "answer": "$$\\boxed{\\frac{p^2}{u}}$$"
        },
        {
            "introduction": "理论的价值最终体现在实践中。在最后的这个动手练习中，您将通过编程来解决一个简化的机组组合（Unit Commitment）问题，这是一个经典的混合整数线性规划（Mixed-Integer Linear Program, MILP）问题。您的任务是计算并比较两种不同凸松弛策略下的“整数规划间隙”（integrality gap），从而亲身体验更强的（“更紧的”）公式如何能够更精确地逼近真实的最优解，并理解其在求解大型复杂问题中的重要性。",
            "id": "4110228",
            "problem": "考虑一个能源系统建模中科学上一致的小规模机組組合问题。有 $I=2$ 个火力发电机组，索引为 $i \\in \\{1,2\\}$，以及 $T=3$ 个时间段，索引为 $t \\in \\{1,2,3\\}$。令 $p_{i,t}$ 表示机组 $i$ 在时间 $t$ 的功率输出（单位为 $\\mathrm{MW}$），$u_{i,t} \\in \\{0,1\\}$ 表示机组 $i$ 在时间 $t$ 的启停状态（$1$ 表示开启），$v_{i,t} \\in \\{0,1\\}$ 表示机组 $i$ 在时间 $t$ 的启动指示变量。假设初始状态为关闭，即对所有 $i$ 都有 $u_{i,0}=0$。每个机组 $i$ 都有最小输出功率 $P^{\\min}_i$（单位为 $\\mathrm{MW}$）、最大输出功率 $P^{\\max}_i$（单位为 $\\mathrm{MW}$）、边际成本 $c_i$（单位为 $\\$ / \\mathrm{MWh}$）和启动成本 $S_i$（单位为 $\\$$）。时间 $t$ 的需求为 $D_t$（单位为 $\\mathrm{MW}$）。物理功率平衡要求 $$\\sum_{i=1}^{I} p_{i,t} = D_t \\quad \\text{for all } t.$$ 运行约束要求 $$P^{\\min}_i u_{i,t} \\le p_{i,t} \\le P^{\\max}_i u_{i,t} \\quad \\text{for all } i,t,$$ 以及启动逻辑要求 $$v_{i,t} \\ge u_{i,t} - u_{i,t-1}, \\quad v_{i,t} \\in \\{0,1\\}, \\quad u_{i,t} \\in \\{0,1\\} \\quad \\text{for all } i,t.$$ 整个时间范围内的总成本为 $$Z = \\sum_{t=1}^{T} \\sum_{i=1}^{I} \\left( c_i \\, p_{i,t} + S_i \\, v_{i,t} \\right),$$ 必须在满足上述约束的条件下将其最小化。\n\n从基本原理上讲，机组組合问题是线性经济调度与二元启停决策的结合，使其成为一个混合整数线性规划（MILP）问题。凸化方法将二元变量松弛为 $[0,1]$ 区间内的连续变量，并添加代表原始逻辑的凸包或有效包络的线性不等式，从而得到线性规划（LP）。\n\n对于给定的松弛 $r$，定义其整数规划间隙为 $$g_r = \\frac{Z^{\\mathrm{MILP}} - Z^{\\mathrm{LP},r}}{Z^{\\mathrm{MILP}}},$$ 其中 $Z^{\\mathrm{MILP}}$ 是 MILP 的最优目标值，$Z^{\\mathrm{LP},r}$ 是松弛 $r$ 下 LP 的最优目标值。整数规划间隙 $g_r$ 是无量纲的，并且必须以小数（而非百分比）形式报告。\n\n您将为两种凸化方法计算 $g_r$：\n- 松弛 $\\mathrm{R0}$（基本松弛）：变量满足 $0 \\le u_{i,t} \\le 1$、$v_{i,t} \\ge 0$、$p_{i,t} \\ge 0$、功率平衡、上界耦合约束 $p_{i,t} \\le P^{\\max}_i u_{i,t}$ 以及启动不等式 $v_{i,t} \\ge u_{i,t} - u_{i,t-1}$；没有下界耦合约束 $p_{i,t} \\ge P^{\\min}_i u_{i,t}$，也没有额外的启动凸包不等式。\n- 松弛 $\\mathrm{R1}$（加强凸化）：变量满足 $0 \\le u_{i,t} \\le 1$、$0 \\le v_{i,t} \\le 1$、$p_{i,t} \\ge 0$、功率平衡、两个耦合约束 $P^{\\min}_i u_{i,t} \\le p_{i,t} \\le P^{\\max}_i u_{i,t}$ 以及启动逻辑的完整线性凸包：$v_{i,t} \\ge u_{i,t} - u_{i,t-1}$、$v_{i,t} \\le u_{i,t}$ 和 $v_{i,t} \\le 1 - u_{i,t-1}$。\n\n对于 MILP 基准（整数问题），您必须强制执行 $u_{i,t} \\in \\{0,1\\}$、$v_{i,t} \\in \\{0,1\\}$ 且 $v_{i,t} = \\max\\{0, u_{i,t} - u_{i,t-1}\\}$，以及调度约束 $P^{\\min}_i u_{i,t} \\le p_{i,t} \\le P^{\\max}_i u_{i,t}$、$\\sum_i p_{i,t} = D_t$。对于任何候选的二元调度方案 $\\{u_{i,t}\\}$，最优调度 $\\{p_{i,t}\\}$ 是线性经济调度的解，该调度在满足边界和功率平衡约束的条件下最小化 $\\sum_i c_i p_{i,t}$；当 $c_i$ 为常数时，这可以通过将所有在线机组的功率设置为 $p_{i,t} = P^{\\min}_i$ 并将剩余需求按 $c_i$ 从小到大的顺序分配给各机组直至其 $P^{\\max}_i$ 来实现。\n\n使用以下科学上合理的参数（所有功率单位为 $\\mathrm{MW}$，成本单位为 $\\$$）：\n- 机组 $1$：$P^{\\min}_1 = 50$，$P^{\\max}_1 = 150$，$c_1 = 10$，$S_1 = 200$。\n- 机组 $2$：$P^{\\min}_2 = 30$，$P^{\\max}_2 = 100$，$c_2 = 12$，$S_2 = 180$。\n- 初始状态：$u_{1,0} = 0$，$u_{2,0} = 0$。\n\n包含三种需求情景的测试套件以确保覆盖范围：\n1. “理想路径”需求曲线：$D = [80,160,110]$。\n2. 接近最小输出的低需求曲线：$D = [40,45,35]$。\n3. 接近容量的高需求曲线：$D = [150,180,220]$。\n\n您的程序必须：\n- 通过枚举所有满足各时段可行性的二元调度方案 $\\{u_{i,t}\\}$ 来计算 $Z^{\\mathrm{MILP}}$，使用经济调度计算 $p_{i,t}$ 和诱导的启动来计算 $v_{i,t}$ 及总成本 $Z$。\n- 通过求解上述相应的线性规划问题来计算 $Z^{\\mathrm{LP},\\mathrm{R0}}$ 和 $Z^{\\mathrm{LP},\\mathrm{R1}}$。\n- 为三种需求情景中的每一种计算整数规划间隙 $g_{\\mathrm{R0}}$ 和 $g_{\\mathrm{R1}}$。\n\n输出格式要求：\n- 您的程序应生成单行输出，其中包含一个逗号分隔的列表的列表形式的结果，不含空格。每个内部列表对应一个需求情景，并按顺序包含两个浮点数 $[g_{\\mathrm{R0}}, g_{\\mathrm{R1}}]$。例如：“[[gR0_case1,gR1_case1],[gR0_case2,gR1_case2],[gR0_case3,gR1_case3]]”。\n- 以小数形式（无单位）报告整数规划间隙。不允许使用百分号。\n\n此问题不涉及角度。物理单位仅适用于输入；输出是按规定格式的無單位小数。",
            "solution": "该问题是有效的。这是一个来自能源系统工程和运筹学领域、具有科学依据、提法得当且客观的问题。它提供了一套完整且一致的数据和定义，用于求解指定的量。该问题要求在两种不同的线性规划（LP）松弛下，计算一个小规模机组组合（UC）问题的整数规划间隙。这是理解混合整数优化问题凸松弛质量的标准且有意义的练习。所有提供的参数都是科学上合理的，并且指定的需求情景在给定的发电约束下是可行的。\n\n对于每个需求情景，求解方法分为三个主要部分。首先，通过枚举所有可能的二元启停调度方案，确定混合整数线性规划（MILP）的精确最优成本 $Z^{\\mathrm{MILP}}$。其次，通过构建和求解相应的LP问题，找到两种不同LP松弛的最优成本 $Z^{\\mathrm{LP,R0}}$ 和 $Z^{\\mathrm{LP,R1}}$。第三，使用提供的公式计算整数规划间隙 $g_{\\mathrm{R0}}$ 和 $g_{\\mathrm{R1}}$。\n\n**第一部分：通过完全枚举求解 MILP**\n\n该问题涉及 $I=2$ 个发电机组，时间范围为 $T=3$ 个时段。每个机组 $i$ 在时间 $t$ 的启停状态由二元变量 $u_{i,t} \\in \\{0,1\\}$ 给出。这导致了 $I \\times T = 2 \\times 3 = 6$ 个二元变量，从而产生 $2^6 = 64$ 种可能的启停调度方案 $\\{ u_{i,t} \\}_{i \\in \\{1,2\\}, t \\in \\{1,2,3\\}}$。鉴于这个小的状态空间，可以通过评估每个调度方案的成本并找出最小值来找到精确的 MILP 解。\n\n对于 64 个候选调度方案中的每一个，我们执行两项检查：可行性检查和成本计算。\n\n1.  **可行性检查**：如果已启停的发电机能够在每个时间段 $t$ 满足需求 $D_t$，则该调度方案是可行的。令 $U_t = \\{ i \\mid u_{i,t} = 1 \\}$ 为在时间 $t$ 处于在线状态的发电机组集合。一个调度方案在时间 $t$ 是可行的，当且仅当在线机组的总最小功率输出不超过需求，且它们的总最大功率输出不小于需求。\n    $$ \\sum_{i \\in U_t} P^{\\min}_i \\le D_t \\le \\sum_{i \\in U_t} P^{\\max}_i $$\n    只有当此条件对所有 $t \\in \\{1, 2, 3\\}$ 都成立时，调度方案才是可行的。在任何时间段内不可行的调度方案都将被舍弃。\n\n2.  **成本计算**：对于每个可行的调度方案，总成本 $Z$ 是启动成本和生产（燃料）成本之和。\n    - **启动成本**：如果机组 $i$ 从关闭 ($u_{i,t-1}=0$) 转换到开启 ($u_{i,t}=1$) 状态，启动变量 $v_{i,t}$ 为 $1$，否则为 $0$。给定两个机组的初始状态均为 $u_{i,0}=0$，启动事件由 $v_{i,t} = \\max\\{0, u_{i,t} - u_{i,t-1}\\}$ 确定。总启动成本为 $\\sum_{t=1}^{T} \\sum_{i=1}^{I} S_i v_{i,t}$。\n    - **生产成本**：在每个时间段 $t$，通过对在线机组 $U_t$ 进行经济调度来最小化生产成本。问题是找到功率输出 $p_{i,t}$，使得在满足 $\\sum_{i \\in U_t} p_{i,t} = D_t$ 和 $P^{\\min}_i \\le p_{i,t} \\le P^{\\max}_i$ 的条件下，最小化 $\\sum_{i \\in U_t} c_i p_{i,t}$。在边际成本 $c_i$ 为常数的情况下，最优调度按 $c_i$ 的递增顺序加载机组。给定 $c_1=10$ 和 $c_2=12$，机组 1 总是在机组 2 之前被调度。步骤如下：\n        a. 将所有在线机组设置为其最小输出：$p_{i,t} = P^{\\min}_i$ for all $i \\in U_t$。\n        b. 剩余需求 $D'_t = D_t - \\sum_{i \\in U_t} P^{\\min}_i$ 则通过将最便宜的机组（机组 1）的输出增加到其最大值，然后是次便宜的机组（机组 2）来满足。\n    总生产成本为 $\\sum_{t=1}^{T} \\sum_{i \\in U_t} c_i p_{i,t}$。\n\n最优 MILP 目标值 $Z^{\\mathrm{MILP}}$ 是在所有可行调度方案中找到的最小总成本。\n\n**第二部分：求解 LP 松弛**\n\n通过允许二元变量 $u_{i,t}$ 和 $v_{i,t}$ 在区间 $[0,1]$ 内取任意实数值，MILP被松弛为一个 LP。这创建了一个可以被高效求解的凸可行域。我们构建并求解对应于松弛 $\\mathrm{R0}$ 和 $\\mathrm{R1}$ 的两个LP。LP的决策变量向量是 $x = [p_{1,1}, \\dots, p_{2,3}, u_{1,1}, \\dots, u_{2,3}, v_{1,1}, \\dots, v_{2,3}]^T$。目标函数是最小化 $Z = \\sum_{t=1}^{T} \\sum_{i=1}^{I} (c_i p_{i,t} + S_i v_{i,t})$。\n\n**松弛 R0（基本松弛）**：\n此 LP 的约束条件为：\n- 功率平衡：$\\sum_{i=1}^{I} p_{i,t} = D_t$ for $t \\in \\{1,2,3\\}$。\n- 上界耦合：$p_{i,t} - P^{\\max}_i u_{i,t} \\le 0$ for $i \\in \\{1,2\\}, t \\in \\{1,2,3\\}$。\n- 启动逻辑：$u_{i,t} - u_{i,t-1} - v_{i,t} \\le 0$ for $i \\in \\{1,2\\}, t \\in \\{1,2,3\\}$。注意 $u_{i,0}=0$。\n- 变量边界：$p_{i,t} \\ge 0$, $0 \\le u_{i,t} \\le 1$, $v_{i,t} \\ge 0$。\n这是一个弱松弛，因为它省略了最小功率输出约束 $p_{i,t} \\ge P^{\\min}_i u_{i,t}$，这可能导致解中机组部分“开启”($u_{i,t}  0$)但仅产生任意小的功率($p_{i,t} \\approx 0$)，从而规避了最小发电量的要求。\n\n**松弛 R1（加强凸化）**：\n此松弛通过增加更多约束，提供了对 MILP 可行集更紧的近似。\n- 包括 $\\mathrm{R0}$ 的所有约束。\n- 下界耦合：$P^{\\min}_i u_{i,t} - p_{i,t} \\le 0$ for $i \\in \\{1,2\\}, t \\in \\{1,2,3\\}$。这 enforces that if a unit is fractionally on, it must produce at least a proportional amount of its minimum power.\n- 启动凸包：通过附加的有效不等式来加强启动逻辑。\n    - $v_{i,t} - u_{i,t} \\le 0$\n    - $v_{i,t} + u_{i,t-1} \\le 1$\n- 更紧的变量边界：$p_{i,t} \\ge 0$, $0 \\le u_{i,t} \\le 1$, $0 \\le v_{i,t} \\le 1$。\n\nR1 的可行域是 R0 可行域的子集。因此，我们预期最优目标值满足关系 $Z^{\\mathrm{LP,R0}} \\le Z^{\\mathrm{LP,R1}} \\le Z^{\\mathrm{MILP}}$。LP和MILP目标值之间的差异越小，表示松弛越紧。\n\n**第三部分：计算整数规划间隙**\n\n整数规划间隙 $g_r$ 用于衡量松弛 $r$ 的质量。它被定义为最优 MILP 成本与最优 LP 成本之间的相对差异：\n$$ g_r = \\frac{Z^{\\mathrm{MILP}} - Z^{\\mathrm{LP},r}}{Z^{\\mathrm{MILP}}} $$\n间隙越小，表示松弛质量越高（越紧）。我们将为三种需求情景中的每一种计算 $g_{\\mathrm{R0}}$ 和 $g_{\\mathrm{R1}}$。我们预计 $g_{\\mathrm{R1}} \\le g_{\\mathrm{R0}}$，因为 $\\mathrm{R1}$ 是一个更强的模型表述。\n\n提供的数值参数如下：\n- 机组 $1$：$P^{\\min}_1 = 50$, $P^{\\max}_1 = 150$, $c_1 = 10$, $S_1 = 200$。\n- 机组 $2$：$P^{\\min}_2 = 30$, $P^{\\max}_2 = 100$, $c_2 = 12$, $S_2 = 180$。\n- 初始状态：$u_{1,0} = 0$, $u_{2,0} = 0$。\n\n每个需求情景的具体计算由最终答案中的程序执行。",
            "answer": "```python\nimport numpy as np\nfrom scipy.optimize import linprog\nfrom itertools import product\n\ndef solve():\n    \"\"\"\n    Solves the Unit Commitment problem for three demand scenarios.\n    For each scenario, it computes the exact MILP solution, two LP relaxations (R0, R1),\n    and the corresponding integrality gaps.\n    \"\"\"\n    # Problem Parameters\n    I, T = 2, 3\n    UNITS = [1, 2]\n    P_MIN = {1: 50, 2: 30}\n    P_MAX = {1: 150, 2: 100}\n    C_COST = {1: 10, 2: 12}\n    S_COST = {1: 200, 2: 180}\n    U_INIT = {1: 0, 2: 0}\n\n    test_cases = [\n        [80, 160, 110],  # Case 1\n        [40, 45, 35],    # Case 2\n        [150, 180, 220]  # Case 3\n    ]\n\n    def solve_milp(demand):\n        \"\"\"Solves the MILP by enumerating all 2^(I*T) commitment schedules.\"\"\"\n        min_total_cost = float('inf')\n        \n        # Generate all 2^(I*T) = 64 schedules\n        for schedule_flat in product([0, 1], repeat=I * T):\n            u = {\n                1: {t+1: schedule_flat[t] for t in range(T)},\n                2: {t+1: schedule_flat[T + t] for t in range(T)}\n            }\n            \n            is_feasible = True\n            total_prod_cost = 0.0\n\n            # 1. Feasibility Check and Economic Dispatch\n            for t in range(1, T + 1):\n                online_units = [i for i in UNITS if u[i][t] == 1]\n                p_min_sum = sum(P_MIN[i] for i in online_units)\n                p_max_sum = sum(P_MAX[i] for i in online_units)\n\n                if not (p_min_sum = demand[t-1] = p_max_sum):\n                    is_feasible = False\n                    break\n                \n                # Economic Dispatch\n                p = {i: 0.0 for i in UNITS}\n                if online_units:\n                    # Set to min power\n                    residual_demand = demand[t-1]\n                    for i in online_units:\n                        p[i] = P_MIN[i]\n                        residual_demand -= P_MIN[i]\n                    \n                    # Dispatch cheaper unit 1 first\n                    if 1 in online_units:\n                        load1 = min(residual_demand, P_MAX[1] - P_MIN[1])\n                        p[1] += load1\n                        residual_demand -= load1\n                    # Dispatch unit 2\n                    if 2 in online_units:\n                        load2 = min(residual_demand, P_MAX[2] - P_MIN[2])\n                        p[2] += load2\n                        residual_demand -= load2\n\n                total_prod_cost += sum(C_COST[i] * p[i] for i in UNITS)\n            \n            if not is_feasible:\n                continue\n\n            # 2. Startup Cost Calculation\n            total_startup_cost = 0.0\n            for i in UNITS:\n                u_prev = U_INIT[i]\n                for t in range(1, T + 1):\n                    if u[i][t] == 1 and u_prev == 0:\n                        total_startup_cost += S_COST[i]\n                    u_prev = u[i][t]\n            \n            current_total_cost = total_prod_cost + total_startup_cost\n            if current_total_cost  min_total_cost:\n                min_total_cost = current_total_cost\n                \n        return min_total_cost\n\n    def solve_lp(demand, relaxation_type):\n        \"\"\"Builds and solves the LP for a given relaxation type ('R0' or 'R1').\"\"\"\n        num_p, num_u, num_v = I * T, I * T, I * T\n        num_vars = num_p + num_u + num_v\n\n        # Variable indexing helpers\n        p_idx = lambda i, t: (i - 1) * T + (t - 1)\n        u_idx = lambda i, t: num_p + (i - 1) * T + (t - 1)\n        v_idx = lambda i, t: num_p + num_u + (i - 1) * T + (t - 1)\n\n        # Objective function\n        c = np.zeros(num_vars)\n        for i in UNITS:\n            for t in range(1, T + 1):\n                c[p_idx(i, t)] = C_COST[i]\n                c[v_idx(i, t)] = S_COST[i]\n        \n        # Equality constraints: Power balance\n        A_eq = np.zeros((T, num_vars))\n        b_eq = np.array(demand, dtype=float)\n        for t in range(1, T + 1):\n            for i in UNITS:\n                A_eq[t-1, p_idx(i, t)] = 1.0\n\n        # Inequality constraints\n        A_ub_list, b_ub_list = [], []\n\n        for i in UNITS:\n            for t in range(1, T + 1):\n                # Upper linking: p_it = P_max_i * u_it\n                row = np.zeros(num_vars)\n                row[p_idx(i, t)] = 1.0\n                row[u_idx(i, t)] = -P_MAX[i]\n                A_ub_list.append(row)\n                b_ub_list.append(0.0)\n\n                # Startup logic: v_it >= u_it - u_it-1\n                u_prev_val = U_INIT[i] if t == 1 else 0\n                row = np.zeros(num_vars)\n                row[u_idx(i, t)] = 1.0\n                row[v_idx(i, t)] = -1.0\n                if t > 1:\n                    row[u_idx(i, t-1)] = -1.0\n                A_ub_list.append(row)\n                b_ub_list.append(u_prev_val if t==1 else 0)\n\n                if relaxation_type == 'R1':\n                    # Lower linking: p_it >= P_min_i * u_it\n                    row = np.zeros(num_vars)\n                    row[u_idx(i, t)] = P_MIN[i]\n                    row[p_idx(i, t)] = -1.0\n                    A_ub_list.append(row)\n                    b_ub_list.append(0.0)\n\n                    # Startup convex hull: v_it = u_it\n                    row = np.zeros(num_vars)\n                    row[v_idx(i, t)] = 1.0\n                    row[u_idx(i, t)] = -1.0\n                    A_ub_list.append(row)\n                    b_ub_list.append(0.0)\n\n                    # Startup convex hull: v_it = 1 - u_it-1\n                    u_prev_val = U_INIT[i] if t == 1 else 0\n                    row = np.zeros(num_vars)\n                    row[v_idx(i, t)] = 1.0\n                    if t > 1:\n                        row[u_idx(i, t - 1)] = 1.0\n                    A_ub_list.append(row)\n                    b_ub_list.append(1.0 - u_prev_val if t==1 else 1.0)\n\n        A_ub = np.array(A_ub_list)\n        b_ub = np.array(b_ub_list)\n        \n        # Bounds\n        bounds = [(0, None)] * num_p + [(0, 1)] * num_u\n        if relaxation_type == 'R0':\n            bounds += [(0, None)] * num_v\n        else: # R1\n            bounds += [(0, 1)] * num_v\n            \n        res = linprog(c, A_ub=A_ub, b_ub=b_ub, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')\n        \n        return res.fun if res.success else float('inf')\n\n    all_gaps = []\n    for demand_scenario in test_cases:\n        z_milp = solve_milp(demand_scenario)\n        \n        if z_milp == float('inf'):\n            # This case shouldn't happen with the given problems\n            all_gaps.append([float('nan'), float('nan')])\n            continue\n            \n        z_lp_r0 = solve_lp(demand_scenario, 'R0')\n        z_lp_r1 = solve_lp(demand_scenario, 'R1')\n        \n        g_r0 = (z_milp - z_lp_r0) / z_milp if z_milp != 0 else 0\n        g_r1 = (z_milp - z_lp_r1) / z_milp if z_milp != 0 else 0\n        \n        all_gaps.append([g_r0, g_r1])\n\n    # Format the final output string exactly as required\n    print(f\"[[{','.join(f'[{g[0]},{g[1]}]' for g in all_gaps)}]\")\n\nsolve()\n```"
        }
    ]
}