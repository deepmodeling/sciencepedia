{
    "hands_on_practices": [
        {
            "introduction": "直流潮流（DC power flow）是快速线性估算电网中功率分布的基础工具。本练习旨在将物理模型转化为图论框架，通过构建关联矩阵和加权拉普拉斯矩阵来解决一个核心问题，这是实现电网分析自动化的关键技能。通过这个实践，你将亲手实现一个基于图的直流潮流求解器，从而加深对电网线性化模型及其矩阵表示的理解。",
            "id": "4094429",
            "problem": "考虑一个能量传输网络，表示为一个连通的有向图 $G = (\\mathcal{V}, \\mathcal{E})$，其中 $\\mathcal{V}$ 是母线（节点）的集合，$\\mathcal{E}$ 是输电线路（边）的集合。每条边 $(i,j) \\in \\mathcal{E}$ 从母线 $i$ 指向母线 $j$，具有已知的串联电抗 $x_{ij} > 0$（以公共基准值的标幺值表示），并被建模为无损电感元件。该网络在正弦稳态下运行，并遵循交流（AC）潮流的直流（DC）近似法的以下假设：\n- 所有母线 $i \\in \\mathcal{V}$ 的电压幅值近似均匀且固定为 $|V_i| \\approx 1$ 标幺值。\n- 母线之间的相角差满足 $|\\theta_i - \\theta_j| \\ll 1$ 弧度，因此 $\\sin(\\theta_i - \\theta_j) \\approx \\theta_i - \\theta_j$。\n- 与电抗相比，线路电阻和并联元件可忽略不计。\n- 母线上的有功功率注入等于其所连接线路上有向有功潮流的代数和，这与基尔霍夫电流定律（KCL）和基尔霍夫电压定律（KVL）一致。\n\n在这些假设下，使用基于图的公式化方法，其中关联矩阵编码边的方向，加权拉普拉斯矩阵编码线路电抗，来推导和实现线性直流潮流。设置一个指定索引的平衡母线，其相角固定为 $0$ 弧度。所有母线相角以弧度表示。所有线路潮流以兆瓦（MW）表示。使用一个以兆瓦（MW）为单位的公共基准功率 $S_{\\text{base}}$ 在标幺值和物理单位之间进行转换，即 $P_{\\text{MW}} = P_{\\text{p.u.}} \\cdot S_{\\text{base}}$ 和 $F_{\\text{MW}} = F_{\\text{p.u.}} \\cdot S_{\\text{base}}$。\n\n编写一个完整、可运行的程序，该程序：\n- 根据有向边构建关联矩阵，并使用线路电抗形成相应的加权拉普拉斯矩阵。\n- 在平衡母线相角固定为 $0$ 弧度的条件下，求解线性系统以获得母线相角 $\\theta_i$。\n- 使用直流近似法计算每条边 $(i,j) \\in \\mathcal{E}$ 的有向线路潮流 $F_{ij}$（单位：MW），其中正向潮流定义为与边的方向一致。\n- 检查每条边的热极限符合性：如果 $|F_{ij}|$ 严格大于指定的极限 $L_{ij}$（单位：MW），则认为违反了极限。等于 $|F_{ij}| = L_{ij}$ 不算作违反。\n- 生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。每个测试用例的结果必须是一个包含三个元素的列表：按母线索引升序排列的母线相角列表（单位：弧度），按给定边列表顺序排列的线路潮流列表（单位：MW），以及一个布尔标志，指示是否有任何线路极限被违反。\n\n角度单位：弧度。功率单位：MW。程序必须以这些单位生成输出。\n\n使用以下测试套件，它涵盖了一个通用情况、一个边界条件和一个边缘情况：\n\n- 测试用例 1（三母线链式网络，正常路径）：\n  - 母线：$\\{1,2,3\\}$。\n  - 边和电抗（标幺值）：$(1,2)$，电抗 $x_{12} = 0.2$；$(2,3)$，电抗 $x_{23} = 0.25$。\n  - 按顺序排列的有向边：$(1,2)$, $(2,3)$。\n  - 净注入功率（MW）：$[50, -30, -20]$。\n  - 平衡母线索引：$1$。\n  - 基准功率：$S_{\\text{base}} = 100$ MW。\n  - 线路极限（MW）：$[100, 100]$。\n\n- 测试用例 2（四母线环形网络，包括极限上的边界相等情况和一次违规）：\n  - 母线：$\\{1,2,3,4\\}$。\n  - 边和电抗（标幺值）：$(1,2)$，电抗 $x_{12} = 0.1$；$(2,3)$，电抗 $x_{23} = 0.2$；$(3,4)$，电抗 $x_{34} = 0.3$；$(4,1)$，电抗 $x_{41} = 0.4$。\n  - 按顺序排列的有向边：$(1,2)$, $(2,3)$, $(3,4)$, $(4,1)$。\n  - 净注入功率（MW）：$[0, 60, -30, -30]$。\n  - 平衡母线索引：$1$。\n  - 基准功率：$S_{\\text{base}} = 100$ MW。\n  - 线路极限（MW）：$[21, 30, 9, 21]$。\n\n- 测试用例 3（双母线单线路，零注入功率的边缘情况）：\n  - 母线：$\\{1,2\\}$。\n  - 边和电抗（标幺值）：$(1,2)$，电抗 $x_{12} = 0.5$。\n  - 按顺序排列的有向边：$(1,2)$。\n  - 净注入功率（MW）：$[0, 0]$。\n  - 平衡母线索引：$1$。\n  - 基准功率：$S_{\\text{base}} = 100$ MW。\n  - 线路极限（MW）：$[10]$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[result1,result2,result3]$），其中每个 $resultk$ 的形式为指定的 $[\\text{角度}, \\text{潮流}, \\text{违规情况}]$。",
            "solution": "在尝试求解之前，对问题陈述的有效性进行评估。\n\n### 步骤 1：提取已知条件\n- **网络模型**：一个表示能量传输网络的连通有向图 $G = (\\mathcal{V}, \\mathcal{E})$。\n- **节点**：$\\mathcal{V}$ 是母线的集合。\n- **边**：$\\mathcal{E}$ 是从母线 $i$ 到母线 $j$ 的有向输电线路的集合。\n- **边属性**：每条边 $(i,j)$ 具有串联电抗 $x_{ij} > 0$（标幺值），并被建模为无损电感器。\n- **运行假设（直流潮流）**：\n    - 所有母线 $i \\in \\mathcal{V}$ 的电压幅值 $|V_i| \\approx 1$ 标幺值。\n    - 母线之间的相角差很小，即 $|\\theta_i - \\theta_j| \\ll 1$ 弧度，允许近似为 $\\sin(\\theta_i - \\theta_j) \\approx \\theta_i - \\theta_j$。\n    - 线路电阻和并联元件可忽略不计。\n- **守恒定律**：母线上的有功功率注入等于其所连接线路上有向有功潮流的代数和。\n- **要求的公式化方法**：使用关联矩阵和加权拉普拉斯矩阵的基于图的公式化方法。\n- **边界条件**：一个指定索引的平衡母线，其相角固定为 $\\theta_{\\text{slack}} = 0$ 弧度。\n- **单位转换**：使用以兆瓦（MW）为单位的基准功率 $S_{\\text{base}}$ 在标幺值（p.u.）和物理单位之间转换：$P_{\\text{MW}} = P_{\\text{p.u.}} \\cdot S_{\\text{base}}$ 和 $F_{\\text{MW}} = F_{\\text{p.u.}} \\cdot S_{\\text{base}}$。\n- **输出要求**：\n    1.  按母线索引排序的母线相角 $\\theta_i$ 列表（单位：弧度）。\n    2.  按输入边列表顺序排列的有向线路潮流 $F_{ij}$ 列表（单位：MW）。\n    3.  一个布尔标志，指示是否有任何线路极限被违反，其中违反定义为 $|F_{ij}| > L_{ij}$。\n- **测试用例**：提供了三个具体的测试用例，包含所有必要的参数（网络拓扑、电抗、功率注入、平衡母线、基准功率、线路极限）。\n\n### 步骤 2：使用提取的已知条件进行验证\n- **科学依据**：该问题基于直流（DC）潮流近似法，这是电力系统工程中一个标准且基础的分析工具。其假设和基于图的公式化方法是教科书级别的内容。这在科学上是合理的。\n- **适定性**：该问题是适定的。对于一个连通网络，指定一个平衡母线（一个参考角度）会使求解其余母线角度的线性方程组非奇异，从而保证唯一解。每个测试用例都提供了所有必要的数据。\n- **目标**：问题陈述使用了精确、客观和定量的语言。目标清晰明确，没有歧义。\n- **完整性和一致性**：设置是完整的。对于每个测试用例，都指定了母线数量、有向边、它们的电抗、所有母线的净功率注入、平衡母线、基准功率和线路热极限。不存在矛盾之处。\n- **可行性**：给出的电抗、功率注入和极限的数值在电力系统研究的实际范围内。\n\n### 步骤 3：结论与行动\n问题是**有效的**，因为它在科学上是合理的、适定的和完整的。将根据指定的图论原理来开发解决方案。\n\n### 解题推导\n直流潮流模型提供了有功功率注入、母线相角和线路潮流之间的线性化关系。推导过程如下：\n\n1.  **线路潮流**：在直流近似假设下，从母线 $i$ 到母线 $j$、沿电抗为 $x_{ij}$ 的线路的有功潮流 $F_{ij}$ 由下式给出：\n    $$F_{ij}^{\\text{p.u.}} = \\frac{|V_i||V_j|}{x_{ij}}\\sin(\\theta_i - \\theta_j) \\approx \\frac{1 \\cdot 1}{x_{ij}}(\\theta_i - \\theta_j) = b_{ij}(\\theta_i - \\theta_j)$$\n    其中 $b_{ij} = 1/x_{ij}$ 是线路的电纳（以标幺值 p.u. 表示）。\n\n2.  **母线功率平衡**：任意母线 $i$ 的净有功功率注入 $P_i$ 是从该母线流向所有相连线路的有功潮流之和。\n    $$P_i^{\\text{p.u.}} = \\sum_{j \\text{ adjacent to } i} F_{ij}^{\\text{p.u.}} = \\sum_{j \\text{ adjacent to } i} b_{ij}(\\theta_i - \\theta_j)$$\n    这可以重写为一组线性方程，每个母线对应一个方程。\n\n3.  **图论矩阵公式**：这个方程组可以用图论优雅地表示。设图有 $N_b = |\\mathcal{V}|$ 个母线和 $N_e = |\\mathcal{E}|$ 条边。\n    - **关联矩阵 ($\\mathbf{A}$)**：一个 $N_b \\times N_e$ 的矩阵，用于捕捉图的拓扑结构和边的方向。对于第 $k$ 条从母线 $i$ 指向母线 $j$ 的边：\n      $$A_{mk} = \\begin{cases} +1  \\text{如果 } m=i \\text{ （源母线）} \\\\ -1  \\text{如果 } m=j \\text{ （目标母线）} \\\\ 0  \\text{其他情况} \\end{cases}$$\n    - **边电纳矩阵 ($\\mathbf{W}$)**：一个 $N_e \\times N_e$ 的对角矩阵，其对角线元素是线路电纳，$W_{kk} = b_k = 1/x_k$。\n    - **母线导纳矩阵 ($\\mathbf{B}$)**：母线功率注入向量 $\\mathbf{P}^{\\text{p.u.}}$ 和母线相角向量 $\\boldsymbol{\\theta}$ 之间的关系由 $\\mathbf{P}^{\\text{p.u.}} = \\mathbf{B}\\boldsymbol{\\theta}$ 给出。直流模型的母线导纳矩阵 $\\mathbf{B}$ 等价于加权图拉普拉斯矩阵 $\\mathbf{L}_w$：\n      $$\\mathbf{B} = \\mathbf{A} \\mathbf{W} \\mathbf{A}^T$$\n      $\\mathbf{B}$ 的元素是：\n      - $B_{ii} = \\sum_{k \\text{ incident to } i} b_k$ （连接到母线 $i$ 的所有线路的电纳之和）\n      - 如果母线 $i$ 和 $j$ 之间存在线路，则对于 $i \\neq j$ 有 $B_{ij} = -b_{ij}$。\n\n4.  **求解系统**：矩阵 $\\mathbf{B}$ 是奇异的，这反映了物理上只有相角差是确定的。通过将一个母线（例如母线 $s$）设为平衡母线并将其相角固定为 $\\theta_s = 0$，我们提供了一个参考。这移除了一个未知数（$\\theta_s$）和一个方程（平衡母线 $s$ 处的功率平衡方程，它成为一个相关方程）。通过从 $\\mathbf{B}$ 中移除对应于平衡母线的行和列，并从 $\\mathbf{P}^{\\text{p.u.}}$ 中移除相应的条目，来简化系统。令简化后的量用下标 'red' 表示。\n    $$\\mathbf{P}_{\\text{red}}^{\\text{p.u.}} = \\mathbf{B}_{\\text{red}} \\boldsymbol{\\theta}_{\\text{red}}$$\n    由于对于连通图，$\\mathbf{B}_{\\text{red}}$ 是可逆的，可以通过求解这个线性系统来找到未知的非平衡母线相角 $\\boldsymbol{\\theta}_{\\text{red}}$：\n    $$\\boldsymbol{\\theta}_{\\text{red}} = \\mathbf{B}_{\\text{red}}^{-1} \\mathbf{P}_{\\text{red}}^{\\text{p.u.}}$$\n    然后由 $\\boldsymbol{\\theta}_{\\text{red}}$ 和 $\\theta_s=0$ 组装成完整的相角向量 $\\boldsymbol{\\theta}$。所有角度均以弧度为单位。\n\n5.  **计算线路潮流**：一旦所有母线相角已知，就可以计算每条线路上的有向潮流。考虑方向后，所有边上的相角差向量为 $\\Delta\\boldsymbol{\\theta} = \\mathbf{A}^T \\boldsymbol{\\theta}$。那么，线路潮流的标幺值向量为：\n    $$\\mathbf{F}^{\\text{p.u.}} = \\mathbf{W} (\\mathbf{A}^T \\boldsymbol{\\theta})$$\n    为了以兆瓦（MW）为单位获得潮流，每个元素都乘以基准功率 $S_{\\text{base}}$：\n    $$\\mathbf{F}^{\\text{MW}} = S_{\\text{base}} \\cdot \\mathbf{F}^{\\text{p.u.}}$$\n\n6.  **热极限检查**：对于每条线路 $k$，将其潮流的绝对值 $|F_k^{\\text{MW}}|$ 与其热极限 $L_k^{\\text{MW}}$ 进行比较。如果任何线路的 $|F_k^{\\text{MW}}| > L_k^{\\text{MW}}$，则发生了违规。\n\n将实施这种结构化的、基于原理的方法来解决给定的测试用例。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves a series of DC power flow problems using a graph-based formulation.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"buses\": [1, 2, 3],\n            \"edges\": [(1, 2), (2, 3)],\n            \"reactances\": [0.2, 0.25],\n            \"injections_mw\": [50, -30, -20],\n            \"slack_bus_index\": 1,\n            \"base_power\": 100.0,\n            \"line_limits_mw\": [100, 100],\n        },\n        {\n            \"buses\": [1, 2, 3, 4],\n            \"edges\": [(1, 2), (2, 3), (3, 4), (4, 1)],\n            \"reactances\": [0.1, 0.2, 0.3, 0.4],\n            \"injections_mw\": [0, 60, -30, -30],\n            \"slack_bus_index\": 1,\n            \"base_power\": 100.0,\n            \"line_limits_mw\": [21, 30, 9, 21],\n        },\n        {\n            \"buses\": [1, 2],\n            \"edges\": [(1, 2)],\n            \"reactances\": [0.5],\n            \"injections_mw\": [0, 0],\n            \"slack_bus_index\": 1,\n            \"base_power\": 100.0,\n            \"line_limits_mw\": [10],\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        # Main logic to calculate the result for one case goes here.\n        num_buses = len(case[\"buses\"])\n        edges = case.get(\"edges\")\n        num_edges = len(edges)\n        reactances = np.array(case[\"reactances\"], dtype=float)\n        injections_mw = np.array(case[\"injections_mw\"], dtype=float)\n        slack_bus_id = case[\"slack_bus_index\"]\n        s_base = case[\"base_power\"]\n        limits_mw = np.array(case[\"line_limits_mw\"], dtype=float)\n        \n        # 1. Convert to 0-based index for arrays\n        slack_idx_0based = slack_bus_id - 1\n\n        # 2. Build Incidence Matrix A (num_buses x num_edges)\n        A = np.zeros((num_buses, num_edges), dtype=float)\n        for k, (i, j) in enumerate(edges):\n            A[i - 1, k] = 1.0\n            A[j - 1, k] = -1.0\n        \n        # 3. Build Susceptance Diagonal Matrix W (num_edges x num_edges)\n        susceptances = 1.0 / reactances\n        W = np.diag(susceptances)\n        \n        # 4. Build Bus Admittance Matrix B (num_buses x num_buses)\n        # B is the weighted graph Laplacian: B = A * W * A^T\n        B = A @ W @ A.T\n\n        # 5. Convert power injections to per unit\n        P_pu = injections_mw / s_base\n        \n        # 6. Create the reduced system for non-slack buses\n        all_indices = np.arange(num_buses)\n        non_slack_indices = np.delete(all_indices, slack_idx_0based)\n        \n        B_red = B[np.ix_(non_slack_indices, non_slack_indices)]\n        P_pu_red = P_pu[non_slack_indices]\n        \n        # 7. Solve for non-slack bus angles\n        # B_red * theta_red = P_pu_red\n        theta_red = np.linalg.solve(B_red, P_pu_red)\n        \n        # 8. Reconstruct the full vector of bus angles (in radians)\n        theta = np.zeros(num_buses, dtype=float)\n        theta[non_slack_indices] = theta_red\n        # The slack bus angle theta[slack_idx_0based] is already 0.0\n\n        # 9. Calculate oriented line flows in MW\n        # Angle differences: delta_theta = A^T * theta\n        # Flows (p.u.): F_pu = W * delta_theta\n        # Flows (MW): F_mw = F_pu * S_base\n        flows_pu = W @ A.T @ theta\n        flows_mw = flows_pu * s_base\n\n        # 10. Check for thermal limit violations\n        # Violation if |flow| > limit. Equality is not a violation.\n        is_violated = bool(np.any(np.abs(flows_mw) > limits_mw))\n\n        # 11. Store results in the specified format\n        result = [\n            np.round(theta, 12).tolist(), \n            np.round(flows_mw, 12).tolist(), \n            is_violated\n        ]\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # The default str() representation of a list is \"[item1, item2, ...]\",\n    # which matches the required nested list format for each result.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "虽然直流模型很有用，但精确的系统分析通常需要更完整的交流（AC）模型。本练习将挑战你超越现成公式，从第一性原理（基尔霍夫电流定律和欧姆定律）出发，推导出一个复杂元件——带分接头的变压器——对节点导纳矩阵的贡献。这个过程不仅能加深你对网络建模复杂性的理解，还能锻炼你处理非对称网络元件的建模能力。",
            "id": "4094408",
            "problem": "考虑一个连通的交流 (AC) 能源网络，该网络表示为一个有向图，其中母线为节点，元件（线路和变压器）为边。该网络以标幺值 (p.u.) 建模，并遵循基尔霍夫电流定律 (KCL) 和欧姆定律。每条支路由一个串联阻抗表示，并在适用情况下由一个并联导纳表示。一个有载调压理想变压器由一个复数非额定变比表示，该变比修改了母线电压和支路电流之间的关系。节点导纳矩阵是根据这些支路模型构建的。节点方程在注入电流变量上是线性的。\n\n从基尔霍夫电流定律 (KCL)、欧姆定律和网络元件的标幺值表示法这些基本原理出发，您必须推导出以下两种情况的节点导纳矩阵贡献：\n- 标准输电线路，采用对称 $\\pi$ 型模型，包含串联阻抗，以及\n- 理想变压器，其复数非额定分接头位于支路的“首”端，包括分接头对母线侧所见导纳的影响。\n\n然后，实现推导出的表达式来构建节点导纳矩阵，并在给定指定注入电流和已知平衡母线电压的情况下，严格依据 KCL 和欧姆定律，求解未知的母线电压。您的程序必须是完整且可运行的，所有计算均以标幺值（无量纲）进行，并使用弧度作为角度单位。\n\n网络规格：\n- 母线：$\\{1,2,3\\}$。\n- 平衡母线电压：$V_1 = 1 \\angle 0$ p.u.\n- 注入电流：$I_2 = -0.50 - j\\,0.20$ p.u.，$I_3 = -0.30 - j\\,0.10$ p.u.。这些是标幺值定义的独立电流源/汇，不依赖于母线电压幅值。\n- 支路 $1 \\leftrightarrow 2$ 是一台理想变压器，串联阻抗为 $z_{12} = 0.01 + j\\,0.05$ p.u.，复数非额定变比 $t = a\\,e^{j\\theta}$ 位于母线 1 侧。除串联支路建模产生的导纳外，该支路上没有其他并联导纳；励磁导纳被忽略。\n- 支路 $2 \\leftrightarrow 3$ 是一条输电线路，模型为对称 $\\pi$ 型，串联阻抗为 $z_{23} = 0.015 + j\\,0.06$ p.u.，总并联导纳为 $y_{sh,23} = j\\,0.002$ p.u.，在两端平均分配为 $y_{sh,23}/2$。\n\n任务：\n1. 使用基尔霍夫电流定律 (KCL) 和欧姆定律，推导母线 $k$ 和 $m$ 之间的一般支路的节点导纳矩阵贡献：\n   - 具有串联阻抗和对称并联导纳的线路（无分接头），以及\n   - 在母线 $k$ 侧具有非额定复数分接头 $t = a\\,e^{j\\theta}$ 的理想变压器，包括分接头对母线所见导纳的影响。您不得假设或使用任何现成的变压器公式；必须从理想变压器的电压-电流关系和串联导纳推导出变压器的效应，然后将这些关系转化为与 KCL 一致的节点导纳贡献。\n2. 使用您推导的表达式，构建网络的完整节点导纳矩阵 $Y$。一致地使用复数和标幺值。\n3. 通过使用已知的平衡母线电压 $V_1$ 对系统进行分块，从线性节点方程 $I = YV$ 中求解未知母线电压 $V_2$ 和 $V_3$。清晰地表述求解过程并在代码中实现。\n4. 对于每个测试用例，计算 $|V_3|$ 的标幺值幅值。\n\n测试套件（角度以弧度为单位）：\n- 用例 A：$a = 1.00$，$\\theta = 0$。\n- 用例 B：$a = 0.95$，$\\theta = 0$。\n- 用例 C：$a = 1.00$，$\\theta = \\pi/12$。\n- 用例 D：$a = 1.10$，$\\theta = -\\pi/6$。\n\n答案规格：\n- 角度使用弧度。\n- 所有输出均以标幺值（无量纲）表示。\n- 对于每个测试用例，返回 $|V_3|$ 的浮点数值，四舍五入到六位小数。\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，`[result1,result2,result3,result4]`），顺序为用例 A、B、C、D。",
            "solution": "该问题要求推导两种交流网络元件的节点导纳矩阵元素、构建网络的节点导纳矩阵 $Y$，并求解由此产生的线性方程组 $I = YV$ 以获得未知母线电压。整个过程必须基于基尔霍夫电流定律 (KCL) 和欧姆定律。\n\n首先，确立问题的有效性。\n-   **提取的已知条件**：\n    -   网络：3 个母线，连通，交流。\n    -   平衡母线：母线 1，电压 $V_1 = 1 \\angle 0$ p.u. ($1+j0$)。\n    -   注入电流：$I_2 = -0.50 - j\\,0.20$ p.u.，$I_3 = -0.30 - j\\,0.10$ p.u.。\n    -   支路 $1 \\leftrightarrow 2$：理想变压器，串联阻抗为 $z_{12} = 0.01 + j\\,0.05$ p.u.，复数非额定变比 $t = a\\,e^{j\\theta}$ 位于母线 1 侧。无励磁导纳。\n    -   支路 $2 \\leftrightarrow 3$：对称 $\\pi$ 模型输电线路，串联阻抗为 $z_{23} = 0.015 + j\\,0.06$ p.u.，总并联导纳为 $y_{sh,23} = j\\,0.002$ p.u.。\n-   **有效性结论**：问题是有效的。它在科学上基于基本电路理论和标准的电力系统建模技术。问题提法恰当，提供了一套完整且一致的数据和约束，可以得到唯一解。语言客观且无歧义。\n\n求解过程分三个阶段：元件模型的推导、系统矩阵的构建和线性方程组的求解。\n\n**1. 从第一性原理推导节点导纳矩阵贡献**\n\n节点导纳公式由 KCL 推导而来，KCL 指出，从外部源流入任何节点（母线）的电流总和必须等于离开该节点并流入网络支路的电流总和。对于任意母线 $k$，这表示为：\n$$I_k = \\sum_{m \\in N_k} I_{k \\to m}$$\n其中 $I_k$ 是注入母线 $k$ 的电流，$N_k$ 是连接到母线 $k$ 的母线集合，$I_{k \\to m}$ 是通过连接它们的支路从母线 $k$ 流向母线 $m$ 的电流。目标是将每个支路电流 $I_{k \\to m}$ 表示为母线电压的线性函数，从而得到矩阵方程 $I = YV$。\n\n**1.1. 对称 $\\pi$ 模型输电线路**\n\n考虑母线 $k$ 和母线 $m$ 之间的一条由对称 $\\pi$ 模型表示的支路。该模型包括母线之间的一个串联导纳 $y_{km} = 1/z_{km}$ 和从每个母线连接到参考地的并联导纳 $y_{sh,km}/2$。设 $V_k$ 和 $V_m$ 分别是母线 $k$ 和母线 $m$ 的复数电压。\n\n离开母线 $k$ 并流入该支路的电流 $I_{k \\to m}$ 有两个分量：\n1.  通过串联元件的电流，由欧姆定律给出：$(V_k - V_m)y_{km}$。\n2.  通过母线 $k$ 处并联元件的电流：$V_k (y_{sh,km}/2)$。\n\n将这些分量相加，得到离开母线 $k$ 的该支路总电流：\n$$I_{k \\to m} = (V_k - V_m)y_{km} + V_k \\frac{y_{sh,km}}{2} = \\left(y_{km} + \\frac{y_{sh,km}}{2}\\right)V_k - y_{km}V_m$$\n根据对称性，离开母线 $m$ 的该支路电流为：\n$$I_{m \\to k} = (V_m - V_k)y_{km} + V_m \\frac{y_{sh,km}}{2} = \\left(y_{km} + \\frac{y_{sh,km}}{2}\\right)V_m - y_{km}V_k$$\n\n这些表达式将母线 $k$ 和 $m$ 处的注入电流（这里，假设这是唯一的支路，则 $I_k = I_{k \\to m}$ 和 $I_m = I_{m \\to k}$）与母线电压联系起来。它们为节点导纳矩阵 $Y$ 提供以下贡献：\n-   对角线（自导纳）项：$Y_{kk}$ 和 $Y_{mm}$ 增加 $(y_{km} + y_{sh,km}/2)$。\n-   非对角线（互导纳）项：$Y_{km}$ 和 $Y_{mk}$ 减少 $y_{km}$。\n$$ \\Delta Y = \\begin{pmatrix} y_{km} + y_{sh,km}/2  & -y_{km} \\\\ -y_{km}  & y_{km} + y_{sh,km}/2 \\end{pmatrix} $$\n\n**1.2. 带非额定分接头的理想变压器**\n\n考虑母线 $k$（“首”端）和母线 $m$（“末”端）之间的一条支路，包含串联阻抗 $z_{km}$（导纳 $y_{km} = 1/z_{km}$）和一个理想变压器。变压器具有复数非额定变比 $t = a e^{j\\theta}$，位于母线 $k$ 侧。励磁导纳被忽略。\n\n理想变压器会改变电压和电流。设母线 $k$ 的电压为 $V_k$。分接头在变压器的另一侧产生一个中间电压 $V_k'$，使得 $V_k' = V_k / t$。串联阻抗 $z_{km}$ 位于此中间点 $k'$ 和母线 $m$ 之间。\n\n从 $k'$ 流向 $m$ 穿过串联阻抗的电流 $I'_{k \\to m}$ 由欧姆定律给出：\n$$I'_{k \\to m} = (V_k' - V_m) y_{km} = \\left(\\frac{V_k}{t} - V_m\\right) y_{km}$$\n对于一个理想的功率不变变压器，进入一次侧的电流 $I_{k \\to m}$ 和离开二次侧的电流 $I'_{k \\to m}$ 之间的关系是 $I_{k \\to m} = I'_{k \\to m} / t^*$，其中 $t^*$ 是 $t$ 的复共轭。这种关系确保了复功率守恒（$S = V_k I_{k \\to m}^* = V_k' (I'_{k \\to m})^*$）。\n\n代入 $I'_{k \\to m}$ 的表达式，得到离开母线 $k$ 的电流：\n$$I_{k \\to m} = \\frac{1}{t^*} \\left(\\frac{V_k}{t} - V_m\\right) y_{km} = \\frac{y_{km}}{t t^*} V_k - \\frac{y_{km}}{t^*} V_m = \\frac{y_{km}}{|t|^2} V_k - \\frac{y_{km}}{t^*} V_m$$\n离开母线 $m$ 的电流 $I_{m \\to k}$ 直接从母线 $m$ 流向中间点 $k'$：\n$$I_{m \\to k} = (V_m - V_k') y_{km} = \\left(V_m - \\frac{V_k}{t}\\right) y_{km} = - \\frac{y_{km}}{t} V_k + y_{km} V_m$$\n\n这些关系为节点导纳矩阵 $Y$ 提供了以下非对称贡献：\n-   $Y_{kk}$ 增加 $y_{km}/|t|^2$。\n-   $Y_{mm}$ 增加 $y_{km}$。\n-   $Y_{km}$ 减少 $y_{km}/t^*$。\n-   $Y_{mk}$ 减少 $y_{km}/t$。\n$$ \\Delta Y = \\begin{pmatrix} y_{km}/|t|^2  & -y_{km}/t^* \\\\ -y_{km}/t  & y_{km} \\end{pmatrix} $$\n\n**2. 网络导纳矩阵的构建**\n\n完整的 $3 \\times 3$ 节点导纳矩阵 $Y$ 是通过初始化一个零矩阵并累加每个支路的贡献来构建的。\n\n-   **支路 $1 \\leftrightarrow 2$ (变压器)：** $k=1$, $m=2$, $z_{12} = 0.01 + j\\,0.05$, $y_{12} = 1/z_{12}$, 分接头 $t$ 在母线 1 侧。\n    -   $Y_{11} \\leftarrow Y_{11} + y_{12}/|t|^2$\n    -   $Y_{22} \\leftarrow Y_{22} + y_{12}$\n    -   $Y_{12} \\leftarrow Y_{12} - y_{12}/t^*$\n    -   $Y_{21} \\leftarrow Y_{21} - y_{12}/t$\n\n-   **支路 $2 \\leftrightarrow 3$ ($\\pi$ 模型线路)：** $k=2$, $m=3$, $z_{23} = 0.015 + j\\,0.06$, $y_{23} = 1/z_{23}$, $y_{sh,23} = j\\,0.002$。\n    -   $Y_{22} \\leftarrow Y_{22} + y_{23} + y_{sh,23}/2$\n    -   $Y_{33} \\leftarrow Y_{33} + y_{23} + y_{sh,23}/2$\n    -   $Y_{23} \\leftarrow Y_{23} - y_{23}$\n    -   $Y_{32} \\leftarrow Y_{32} - y_{23}$\n\n综合这些，$Y$ 矩阵的最终元素是：\n$Y_{11} = y_{12}/|t|^2$\n$Y_{12} = -y_{12}/t^*$\n$Y_{13} = 0$\n$Y_{21} = -y_{12}/t$\n$Y_{22} = y_{12} + y_{23} + y_{sh,23}/2$\n$Y_{23} = -y_{23}$\n$Y_{31} = 0$\n$Y_{32} = -y_{23}$\n$Y_{33} = y_{23} + y_{sh,23}/2$\n\n**3. 求解节点方程**\n\n节点方程为 $I = YV$。我们根据已知和未知电压对该系统进行分块。母线 1 是具有已知电压 $V_1$ 的平衡母线。母线 2 和 3 是负荷母线，其注入电流已知但电压 $V_2$ 和 $V_3$ 未知。设 $U = \\{2, 3\\}$ 为未知电压母线集合，$S = \\{1\\}$ 为已知电压母线集合。\n\n分块后的系统是：\n$$ \\begin{pmatrix} I_U \\\\ I_S \\end{pmatrix} = \\begin{pmatrix} Y_{UU}  & Y_{US} \\\\ Y_{SU}  & Y_{SS} \\end{pmatrix} \\begin{pmatrix} V_U \\\\ V_S \\end{pmatrix} $$\n其中 $V_U = \\begin{pmatrix} V_2 \\\\ V_3 \\end{pmatrix}$ 且 $V_S = \\begin{pmatrix} V_1 \\end{pmatrix}$。矩阵方程的上半部分与未知电压有关：\n$$ I_U = Y_{UU} V_U + Y_{US} V_S $$\n我们重新整理这个方程以求解 $V_U$：\n$$ Y_{UU} V_U = I_U - Y_{US} V_S $$\n这是一个 $2 \\times 2$ 的复数线性方程组。其组成部分为：\n-   $I_U = \\begin{pmatrix} I_2 \\\\ I_3 \\end{pmatrix} = \\begin{pmatrix} -0.50 - j\\,0.20 \\\\ -0.30 - j\\,0.10 \\end{pmatrix}$\n-   $V_S = \\begin{pmatrix} V_1 \\end{pmatrix} = \\begin{pmatrix} 1.0 + j\\,0.0 \\end{pmatrix}$\n-   $Y_{UU} = \\begin{pmatrix} Y_{22}  & Y_{23} \\\\ Y_{32}  & Y_{33} \\end{pmatrix}$\n-   $Y_{US} = \\begin{pmatrix} Y_{21} \\\\ Y_{31} \\end{pmatrix}$\n\n对于每个测试用例，计算 $t = a\\,e^{j\\theta}$ 的值，构建矩阵 $Y$，求解系统 $Y_{UU} V_U = I_U - Y_{US} V_S$ 得到 $V_U$，并计算所得电压 $V_3$ 的幅值。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the unknown bus voltages in a 3-bus power system\n    for different transformer tap settings.\n    \"\"\"\n\n    # Define the problem parameters as complex numbers\n    V1 = 1.0 + 0.0j\n    I2 = -0.50 - 0.20j\n    I3 = -0.30 - 0.10j\n    \n    z12 = 0.01 + 0.05j\n    z23 = 0.015 + 0.06j\n    ysh23 = 0.002j\n\n    # Pre-calculate branch admittances\n    y12 = 1.0 / z12\n    y23 = 1.0 / z23\n\n    # Define the test cases from the problem statement\n    # Each case is a tuple (a, theta) for the tap ratio t = a * exp(j*theta)\n    test_cases = [\n        (1.00, 0.0),                  # Case A\n        (0.95, 0.0),                  # Case B\n        (1.00, np.pi / 12),           # Case C\n        (1.10, -np.pi / 6),           # Case D\n    ]\n\n    results = []\n    for a, theta in test_cases:\n        # 1. Calculate the complex tap ratio for the current case\n        t = a * np.exp(1j * theta)\n        \n        # 2. Assemble the 3x3 nodal admittance matrix Y\n        Y = np.zeros((3, 3), dtype=np.complex128)\n\n        # Add contributions from Branch 1-2 (Transformer)\n        # k=1 (tap side), m=2\n        Y[0, 0] += y12 / (np.abs(t)**2)\n        Y[1, 1] += y12\n        Y[0, 1] += -y12 / np.conjugate(t)\n        Y[1, 0] += -y12 / t\n\n        # Add contributions from Branch 2-3 (pi-model line)\n        # k=2, m=3\n        Y[1, 1] += y23 + ysh23 / 2.0\n        Y[2, 2] += y23 + ysh23 / 2.0\n        Y[1, 2] += -y23\n        Y[2, 1] += -y23 # same as Y[1,2] since it's a symmetric line\n\n        # 3. Partition the system to solve for unknown voltages V2 and V3\n        # The system is Y_UU * V_U = I_U - Y_US * V_S\n        # Bus 1 is the slack bus (S), buses 2 and 3 have unknown voltages (U)\n        \n        # Y_UU is the submatrix for unknown voltage buses (2, 3)\n        Y_UU = Y[1:3, 1:3]\n        \n        # Y_US is the submatrix coupling unknown and slack buses\n        Y_US = Y[1:3, 0].reshape(2, 1)\n\n        # I_U is the vector of known current injections at buses 2 and 3\n        I_U = np.array([I2, I3])\n        \n        # V_S is the known slack bus voltage V1\n        V_S = np.array([V1]) # As a 1x1 vector\n\n        # Calculate the right-hand side of the linear equation\n        RHS = I_U - (Y_US @ V_S).flatten()\n        \n        # 4. Solve the linear system for the unknown voltages V_U = [V2, V3]\n        V_U = np.linalg.solve(Y_UU, RHS)\n        \n        # Extract V3 from the solution vector\n        V3 = V_U[1]\n        \n        # 5. Compute the magnitude of V3 and round to six decimal places\n        magnitude_V3 = np.abs(V3)\n        results.append(round(magnitude_V3, 6))\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "本练习将重心从网络分析转向网络监控，这是现代智能电网的核心议题。它介绍了网络可观性（observability）和相量测量单元（PMU）的概念，这些是实现广域监控的关键。通过这个练习，你将体验如何将物理定律（如基尔霍夫电流定律）抽象为图论规则，并利用这些规则解决一个关键的组合优化问题：如何以最小的投资实现全网状态的完整监测。",
            "id": "4094414",
            "problem": "考虑一个无向简单图 $G = (V,E)$，它代表一个输电级电力网络，其中 $V$ 是一个有限的母线集合，$E$ 是一个有限的无向支路集合。相量测量单元 (PMU) 是一种设备，当安装在母线 $v \\in V$ 上时，它会测量该母线 $v$ 处的复电压相量 $V_v$ 以及所有邻接支路 $(v,u) \\in E$ 上的复电流相量 $I_{v,u}$。目标是确定一个最小基数的 PMU 布局，以保证网络完全可观测，即可观测性意味着对于每个 $v \\in V$，其复电压相量 $V_v$ 都是可确定的。这是在线性化网络方程和已知线路导纳的标准假设下进行的。\n\n其基本依据是 Kirchhoff 电流定律 (KCL)，该定律指出，对于任何母线 $v \\in V$，流入该母线的电流代数和等于净注入。特别地，在零注入母线 $z \\in Z \\subseteq V$ 处，电流之和为零：\n$$\n\\sum_{u \\in N(z)} I_{z,u} = 0,\n$$\n其中 $N(z)$ 表示 $z$ 的邻居集合。如果一个零注入母线上除了一个邻接支路外，所有支路上的复电流相量都已知，那么剩余支路的电流可以通过 KCL 推断出来。如果一条支路的复电流及其一个端点的复电压已知，则可以使用支路导纳关系推断出另一个端点的复电压。这就引出了可从物理原理推导出的基于图的可观测性规则。\n\n定义以下用于可观测性闭包的基于图的规则，这些是你的程序唯一需要使用的规则：\n- 直接测量规则：如果在 $v \\in V$ 处放置一个 PMU，则 $v$ 及其所有邻居 $u \\in N(v)$ 都是可观测的。\n- 零注入推断规则：如果一个零注入母线 $z \\in Z$ 是可观测的，并且其邻居 $u \\in N(z)$ 中恰好有一个尚未被观测，则 $u$ 通过基于 KCL 的推断变为可观测的。\n\n如果一个母线的复电压相量 $V_v$ 可以通过上述规则确定，则该母线是可观测的。完全可观测性意味着 $V$ 中的所有母线都是可观测的。\n\n给定多个测试用例。对于每个测试用例，你必须计算额外 PMU 布局的字典序最小的最小基数集合 $P_{\\mathrm{add}} \\subseteq V \\setminus P_0$。该集合与任何预装 PMU $P_0 \\subseteq V$ 结合后，在所述规则下能实现完全可观测性。字典序是根据母线索引的升序列表来确定的。如果 $P_0 = \\varnothing$，则 $P_{\\mathrm{add}}$ 就是最小基数 PMU 布局集合。\n\n所有母线均由非负整数索引，所有集合必须表示为这些整数的升序列表。答案中无需报告任何物理单位。\n\n测试套件：\n- 案例 A (无零注入推断的路径图)：\n  $V = \\{0,1,2,3,4,5\\}$, \n  $E = \\{(0,1),(1,2),(2,3),(3,4),(4,5)\\}$, \n  $Z = \\varnothing$, \n  $P_0 = \\varnothing$。\n  计算 $P_{\\mathrm{add}}$。\n- 案例 B (在内部母线上有零注入推断的路径图)：\n  $V = \\{0,1,2,3,4,5\\}$, \n  $E = \\{(0,1),(1,2),(2,3),(3,4),(4,5)\\}$, \n  $Z = \\{1,2,3,4\\}$, \n  $P_0 = \\varnothing$。\n  计算 $P_{\\mathrm{add}}$。\n- 案例 C (在叶节点上预装了 PMU 的星形图)：\n  $V = \\{0,1,2,3,4\\}$, \n  $E = \\{(0,1),(0,2),(0,3),(0,4)\\}$, \n  $Z = \\varnothing$, \n  $P_0 = \\{1\\}$。\n  计算 $P_{\\mathrm{add}}$。\n- 案例 D (带孤立母线的图)：\n  $V = \\{0,1,2\\}$, \n  $E = \\{(0,1)\\}$, \n  $Z = \\varnothing$, \n  $P_0 = \\varnothing$。\n  计算 $P_{\\mathrm{add}}$。\n\n算法约束：\n- 你的程序必须搜索候选的额外 PMU 布局，并选择一个能实现完全可观测性的最小基数集合，当基数相同时，按索引升序列表的字典序选择。\n- 可观测性闭包必须严格通过迭代上述两个规则直到达到不动点来计算，然后检查是否所有母线都已可观测。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表。列表中的每个元素是对应测试用例的 $P_{\\mathrm{add}}$ 的母线索引升序列表。输出不得包含任何空格。例如，对于三个结果 $R_1$、$R_2$ 和 $R_3$，该行应为 $[R_1,R_2,R_3]$ 的形式，其中 $R_i$ 表示为像 $[0,2,5]$ 这样的列表。",
            "solution": "所提出的问题是确定为实现网络完全可观测性所需的、字典序最小的最小基数额外相量测量单元 (PMU) 布局集合，记为 $P_{\\mathrm{add}}$。该网络表示为一个无向图 $G = (V,E)$，其中 $V$ 是母线集合，$E$ 是支路集合。这个问题定义明确，在电力系统工程中有科学依据，并且在给定约束下有唯一解。它是集合覆盖问题或支配集问题的变种，并增加了特定的推断规则。\n\n解决策略涉及对所有可能的额外 PMU 布局空间进行系统性搜索。由于目标是首先最小化 $P_{\\mathrm{add}}$ 的基数，然后选择字典序最小的集合，因此搜索是相应地结构化的。我们从 $k=0$ 开始，对额外布局集合的大小 $k = |P_{\\mathrm{add}}|$ 进行迭代，并递增 $k$ 直到找到解决方案。对于每个 $k$ 值，我们从可用母线集合 $V \\setminus P_0$ 中生成所有可能的 $k$ 个母线的组合。通过按字典序生成这些组合，第一个能实现网络完全可观测性的组合，保证是最小可能基数下的字典序最小解。\n\n对于每个候选的 PMU 总布局集合 $P = P_0 \\cup P_{\\mathrm{add\\_candidate}}$，我们必须验证它是否能实现完全可观测性。这是通过计算可观测性闭包来完成的，即可观测性闭包是其电压相量可以被确定的所有母线的完整集合。该闭包是通过迭代应用给定的两个规则直到达到不动点（即没有新的母线可以被观测到）来计算的。\n\n可观测性闭包算法的步骤如下：\n1.  **初始化 (直接测量规则)**：形成一个初始的可观测母线集合 $O$。对于每个放置了 PMU 的母线 $v$ ($v \\in P$)，母线 $v$ 本身及其邻域中的所有母线 $N(v)$ 都被添加到集合 $O$ 中。这由规则表达为：如果 $v \\in P$，则 $\\{v\\} \\cup N(v) \\subseteq O$。\n\n2.  **迭代推断 (零注入推断规则)**：算法进入一个迭代循环。在每次迭代中，它会检查每个零注入母线 $z \\in Z$。如果 $z$ 在当前的可观测母线集合 $O$ 中，算法会检查其邻居。如果恰好有一个邻居，比如 $u \\in N(z)$，尚未在 $O$ 中，那么 $u$ 就变为可观测的，并被添加到一个用于当前迭代的临时新增可观测母线集合中。在检查完所有零注入母线后，这个临时集合会被添加到 $O$ 中。循环继续，直到对所有 $z \\in Z$ 的完整遍历不再产生新的可观测母线为止。此时，已达到不动点，集合 $O$ 是完整的。\n\n3.  **验证**：在不动点迭代终止后，将最终可观测母线集合的基数 $|O|$ 与网络中母线的总数 $|V|$ 进行比较。如果 $|O| = |V|$，则对于给定的 PMU 布局 $P$，网络是完全可观测的。\n\n因此，每个测试用例的总体算法是一个嵌套过程：外层循环按大小和字典序搜索最优的 $P_{\\mathrm{add}}$，而内层循环（可观测性闭包算法）则验证每个候选布局。图使用邻接表来表示，以便于高效地查找邻居，这对于应用两种可观测性规则至关重要。",
            "answer": "```python\nimport numpy as np\nimport itertools\n\ndef solve():\n    \"\"\"\n    Solves the PMU placement problem for a suite of test cases.\n    \"\"\"\n\n    def check_observability(num_buses, adj, z_buses, pmu_set):\n        \"\"\"\n        Computes the observability closure for a given PMU placement.\n\n        Args:\n            num_buses (int): The total number of buses in the network.\n            adj (dict): An adjacency list representation of the graph.\n            z_buses (set): A set of indices of zero injection buses.\n            pmu_set (set): A set of indices of buses with PMUs.\n\n        Returns:\n            bool: True if the network is fully observable, False otherwise.\n        \"\"\"\n        observed = set()\n\n        # Rule 1: Direct measurement\n        for pmu_bus in pmu_set:\n            observed.add(pmu_bus)\n            if pmu_bus in adj:\n                for neighbor in adj[pmu_bus]:\n                    observed.add(neighbor)\n\n        # Early exit if all buses are already observed by direct measurement\n        if len(observed) == num_buses:\n            return True\n\n        # Rule 2: Zero injection inference (iterative fixed-point)\n        while True:\n            newly_observed_this_pass = set()\n            for z in z_buses:\n                if z in observed:\n                    unobserved_neighbors = []\n                    if z in adj:\n                        for neighbor in adj[z]:\n                            if neighbor not in observed:\n                                unobserved_neighbors.append(neighbor)\n                    \n                    if len(unobserved_neighbors) == 1:\n                        new_bus = unobserved_neighbors[0]\n                        # Check if it's truly new to avoid redundant adds\n                        if new_bus not in observed:\n                           newly_observed_this_pass.add(new_bus)\n\n            if not newly_observed_this_pass:\n                break  # Fixed point reached\n            \n            observed.update(newly_observed_this_pass)\n\n        return len(observed) == num_buses\n\n    def find_min_placement(num_buses, edges, z_buses, p0_buses):\n        \"\"\"\n        Finds the lexicographically smallest, minimum-cardinality additional\n        PMU placement for full observability.\n\n        Args:\n            num_buses (int): The total number of buses.\n            edges (list of tuples): The list of branches in the graph.\n            z_buses (list): A list of indices of zero injection buses.\n            p0_buses (list): A list of indices of pre-installed PMUs.\n\n        Returns:\n            list: The lexicographically smallest, minimum-cardinality P_add.\n        \"\"\"\n        V = np.arange(num_buses)\n        P0 = set(p0_buses)\n        Z = set(z_buses)\n        \n        # Using numpy to find available buses for placement\n        available_buses = np.setdiff1d(V, list(P0)).tolist()\n\n        adj = {i: [] for i in range(num_buses)}\n        for u, v in edges:\n            adj[u].append(v)\n            adj[v].append(u)\n\n        # Iterate on the size of the additional PMU set, k\n        for k in range(len(available_buses) + 1):\n            # itertools.combinations produces tuples in lexicographical order\n            for p_add_tuple in itertools.combinations(available_buses, k):\n                p_add = set(p_add_tuple)\n                current_pmu_set = P0.union(p_add)\n                \n                if check_observability(num_buses, adj, Z, current_pmu_set):\n                    return sorted(list(p_add))\n        \n        return [] # Should not be reached for a valid problem setup\n\n    # Test Suite\n    test_cases = [\n        # Case A: path graph without zero injection inference\n        {'num_buses': 6, 'edges': [(0,1),(1,2),(2,3),(3,4),(4,5)], 'z_buses': [], 'p0_buses': []},\n        # Case B: path graph with zero injection inference at interior buses\n        {'num_buses': 6, 'edges': [(0,1),(1,2),(2,3),(3,4),(4,5)], 'z_buses': [1,2,3,4], 'p0_buses': []},\n        # Case C: star graph with a pre-installed PMU at a leaf\n        {'num_buses': 5, 'edges': [(0,1),(0,2),(0,3),(0,4)], 'z_buses': [], 'p0_buses': [1]},\n        # Case D: graph with an isolated bus\n        {'num_buses': 3, 'edges': [(0,1)], 'z_buses': [], 'p0_buses': []}\n    ]\n\n    results = []\n    for case in test_cases:\n        result = find_min_placement(\n            case['num_buses'], \n            case['edges'], \n            case['z_buses'], \n            case['p0_buses']\n        )\n        results.append(result)\n\n    # Format the final output string to be exactly as specified (no spaces).\n    results_str = [str(r).replace(\" \", \"\") for r in results]\n    print(f\"[{','.join(results_str)}]\")\n\nsolve()\n```"
        }
    ]
}