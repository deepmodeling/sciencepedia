{
    "hands_on_practices": [
        {
            "introduction": "能源模型通常采用两种基本的时间表示方法：按时间顺序排列和按负荷持续时间曲线排列。虽然负荷持续时间曲线（LDC）在长期规划中对于评估能量平衡非常有用，但它通过对负荷水平进行排序，完全忽略了时间上的连续性。本练习旨在通过一个具体的例子，量化这种简化所带来的误差，即当发电机组受到爬坡率限制时，基于LDC的调度与按时间顺序的调度在生产成本上的差异。通过这个实践，你将深刻理解为何对于运行可行性和成本精确评估而言，时间顺序是不可或缺的。",
            "id": "4129555",
            "problem": "考虑一个具有连续功率输出的独立火力发电机组，其在连续时间步长之间受到对称的爬坡率限制。系统负荷是确定性的，并在一个固定的时间范围内呈正弦曲线变化。您将比较遵循时间顺序的按时序调度与通过对负荷水平排序而忽略时间顺序的负荷持续时间曲线 (LDC) 调度，并计算用LDC调度替代按时序调度时产生的生产成本误差。\n\n基本原理和定义：\n- 设时间范围总时长为 $T$ 小时，离散为 $N$ 个相等的时间步长，每个步长为 $\\Delta t = T/N$ 小时。\n- 在离散时间索引 $t \\in \\{0,1,\\dots,N-1\\}$ 处，负荷为 $L_t$（单位：兆瓦 MW），遵循正弦曲线 $L_t = L_0 + A \\sin\\left( 2\\pi \\frac{t}{N} \\right)$，其中 $L_0$ 是平均负荷（MW），$A$ 是振幅（MW）。\n- 发电机在时间步长 $t$ 的发电量为 $p_t$（单位：兆瓦 MW），并满足爬坡率约束\n$$\n|p_t - p_{t-1}| \\le r \\quad \\text{for } t \\ge 1,\n$$\n其中 $r = R \\Delta t$ 是每个步长的爬坡限制（MW），$R$ 是连续爬坡率（MW/小时）。初始条件为 $p_0 = L_0 + A \\sin\\left( 0 \\right) = L_0$。\n- 一个步长内的能量是功率乘以时长。在时间 $t$ 产生的能量是 $p_t \\Delta t$（单位：兆瓦时 MWh）。在时间 $t$ 的未满足能量（短缺）为 $s_t = \\max(0, L_t - p_t)$（单位：MW），贡献了 $s_t \\Delta t$ 的能量短缺（MWh）。\n- 生产成本与能量成线性关系，可变成本为 $c$（单位：美元/兆瓦时 $\\$/\\text{MWh}$）。未服务的能量会产生罚款 $v$（单位：美元/兆瓦时 $\\$/\\text{MWh}$）。假设任何超额发电（即 $p_t > L_t$）都以零转售价值被削减，但仍产生生产成本 $c$。\n- 按时序调度的成本为\n$$\nC_{\\text{chron}} = c \\sum_{t=0}^{N-1} p_t \\Delta t + v \\sum_{t=0}^{N-1} s_t \\Delta t.\n$$\n- LDC调度忽略了爬坡约束，它假设发电机可以满足按大小排序后每个持续时间段的负荷。对于单个机组和线性生产成本，这会得到\n$$\nC_{\\text{LDC}} = c \\sum_{t=0}^{N-1} L_t \\Delta t,\n$$\n因为假设所有负荷都被完全满足，没有短缺，也没有时间顺序约束。\n- 将生产成本误差定义为\n$$\nE = C_{\\text{chron}} - C_{\\text{LDC}},\n$$\n单位为美元，四舍五入到两位小数。\n\n序列在爬坡可行性中的作用：\n- 爬坡率约束将相邻的时间点耦合在一起，因此可行性取决于序列 $\\{L_t\\}$ 和每步的差值 $\\Delta L_t = L_t - L_{t-1}$。像LDC那样对负荷进行排序会消除相邻关系，因此无法强制执行 $|p_t - p_{t-1}| \\le r$。对于正弦曲线 $L(t) = L_0 + A \\sin\\left( \\frac{2\\pi}{T} t \\right)$，最大连续斜率的绝对值为 $\\left| \\frac{dL}{dt} \\right|_{\\max} = \\frac{2\\pi A}{T}$（MW/小时）。在离散时间内，精确跟踪的必要条件是 $R \\ge \\max_t \\left| \\frac{L_t - L_{t-1}}{\\Delta t} \\right|$，当时间上相邻的差值超过 $R$ 时，该条件就会被违反，导致在爬坡时出现短缺，在降坡时可能出现超额发电。\n\n您的任务：\n- 实现一个程序，计算遵循爬坡率约束的按时序调度，以在线性生产成本 $c$ 和短缺惩罚 $v$ 的条件下最小化 $C_{\\text{chron}}$。\n- 为上述定义的相同负荷和发电机参数计算LDC调度成本 $C_{\\text{LDC}}$。\n- 报告每个给定测试用例的生产成本误差 $E$。\n\n数值单位和输出要求：\n- 所有给定和计算的物理量都必须使用其单位处理：功率（兆瓦 MW），时间（小时 h），能量（兆瓦时 MWh），成本（美元 $）。\n- 将每个测试用例的最终生产成本误差 $E$ 以美元表示，为浮点数，四舍五入到两位小数。\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，“[e1,e2,e3]”）。\n\n测试套件：\n使用以下四组参数集来测试解决方案的不同方面。每个测试用例都是一个元组 $(L_0, A, T, N, c, v, R)$，其单位为 $(\\text{MW}, \\text{MW}, \\text{h}, -, \\$/\\text{MWh}, \\$/\\text{MWh}, \\text{MW}/\\text{h})$。\n\n1. 一般情况（理想路径，爬坡率足够高，可以完美跟踪）：$(100, 30, 24, 96, 50, 5000, 12)$。\n2. 中度爬坡能力不足（时序导致升坡时出现短缺）：$(100, 30, 24, 96, 50, 5000, 6)$。\n3. 严重爬坡能力不足（由于升坡短缺和降坡超额发电导致较大误差）：$(100, 30, 24, 96, 50, 5000, 0.5)$。\n4. 边界条件（爬坡率等于正弦曲线的最大连续斜率）：$(100, 30, 24, 96, 50, 5000, \\frac{2\\pi A}{T})$。在实现中，将 $R$ 的数值设置为 $R = \\frac{2\\pi A}{T}$。\n\n您的程序必须实现受爬坡约束的按时序调度，计算 $C_{\\text{chron}}$ 和 $C_{\\text{LDC}}$，并将四个 $E$ 值（以美元为单位）作为单行列表输出，四舍五入到两位小数。",
            "solution": "该问题要求计算生产成本误差 $E$。该误差源于用一个简化的负荷持续时间曲线 (LDC) 调度模型替代一个更真实的、考虑了发电机爬坡率约束的按时序调度模型。误差定义为 $E = C_{\\text{chron}} - C_{\\text{LDC}}$。我们将首先形式化每个成本分量的计算，然后推导按时序调度的算法。\n\n持续时间为 $T$ 的时间范围被离散化为 $N$ 个长度为 $\\Delta t = T/N$ 的步长。在时间索引 $t \\in \\{0, 1, \\dots, N-1\\}$ 处的系统负荷由正弦函数 $L_t = L_0 + A \\sin\\left( 2\\pi \\frac{t}{N} \\right)$ 给出。\n\n首先，我们来处理 LDC 调度成本 $C_{\\text{LDC}}$。该模型假设发电机可以在任何时间满足任何负荷水平，忽略了时间序列，因此也忽略了爬坡率约束。在线性生产成本 $c$ 和所有负荷都被满足的假设下，总产量就是负荷所需的总能量。\n$$\nC_{\\text{LDC}} = c \\sum_{t=0}^{N-1} (L_t \\cdot \\Delta t) = c \\Delta t \\sum_{t=0}^{N-1} L_t\n$$\n该计算是对给定负荷曲线的直接求和，再乘以成本和时间步长。\n\n接下来，我们处理按时序调度成本 $C_{\\text{chron}}$。该成本受到爬坡率约束 $|p_t - p_{t-1}| \\le r$（对于 $t \\ge 1$）的限制，其中 $p_t$ 是在时间 $t$ 的发电功率，$r = R \\Delta t$ 是每个时间步长允许的最大产量变化。初始条件为 $p_0 = L_0$，这等于 $t=0$ 时的负荷 $L_0 = L_0 + A \\sin(0)$。\n\n按时序调度的总成本由以下公式给出：\n$$\nC_{\\text{chron}} = \\sum_{t=0}^{N-1} \\left( c \\cdot p_t \\cdot \\Delta t + v \\cdot s_t \\cdot \\Delta t \\right) = \\Delta t \\sum_{t=0}^{N-1} \\left( c \\cdot p_t + v \\cdot \\max(0, L_t - p_t) \\right)\n$$\n其中 $v$ 是对未服务能量（$s_t \\Delta t$）的高额惩罚。目标是确定能使该总成本最小化的生产序列 $\\{p_t\\}_{t=0}^{N-1}$。\n\n该问题具有顺序结构。对 $p_t$ 的最优决策仅取决于前一步的状态 $p_{t-1}$。这使我们能够通过在从 $t=1$ 到 $t=N-1$ 的每个时间步长做出局部最优决策来解决问题。对于每个步长 $t$，我们必须找到能最小化单步成本 $\\text{cost}_t(p_t) = c \\cdot p_t + v \\cdot \\max(0, L_t - p_t)$ 的 $p_t$ 值，同时满足约束 $p_{t-1} - r \\le p_t \\le p_{t-1} + r$。\n\n让我们分析单步成本函数。它是关于 $p_t$ 的一个分段线性凸函数。\n- 当 $p_t \\ge L_t$ 时，成本为 $c \\cdot p_t$。斜率为 $c > 0$。\n- 当 $p_t  L_t$ 时，成本为 $c \\cdot p_t + v(L_t - p_t) = (c-v)p_t + v L_t$。由于短缺惩罚 $v$ 远大于生产成本 $c$（例如，$v=5000, c=50$），斜率 $c-v$ 为负。\n\n$\\text{cost}_t(p_t)$ 的无约束最小值出现在 $p_t = L_t$ 处，此时函数呈“V”形。为了最小化受约束的成本，我们必须在可行区间 $[p_{t-1}-r, p_{t-1}+r]$ 中选择离无约束最小值 $L_t$ 最近的点。这是 $L_t$ 在可行区间上的投影。因此，最优生产水平 $p_t^*$ 由以下方式给出：\n- 如果 $L_t$ 在区间内，即 $p_{t-1}-r \\le L_t \\le p_{t-1}+r$，则 $p_t^* = L_t$。\n- 如果 $L_t  p_{t-1}+r$，发电机无法足够快地升坡以满足负荷。最近的可行点是上界，所以 $p_t^* = p_{t-1}+r$。这会导致短缺 $s_t = L_t - p_t^*  0$。\n- 如果 $L_t  p_{t-1}-r$，发电机无法足够快地降坡。最近的可行点是下界，所以 $p_t^* = p_{t-1}-r$。这会导致相对于负荷的超额发电（$p_t^*  L_t$），但没有短缺（$s_t = 0$）。\n\n这个逻辑可以紧凑地表示为：\n$$\np_t^* = \\max(p_{t-1} - r, \\min(L_t, p_{t-1} + r))\n$$\n这等效于将目标值 $L_t$ 钳位或裁剪到由爬坡率限制定义的可行范围内。\n\n计算 $C_{\\text{chron}}$ 的算法如下：\n1.  初始化参数 $L_0, A, T, N, c, v, R$ 并计算派生常数 $\\Delta t = T/N$ 和 $r = R \\Delta t$。\n2.  生成负荷向量 $\\{L_t\\}_{t=0}^{N-1}$。\n3.  通过设置初始条件 $p_0 = L_0$ 来初始化生产向量 $\\{p_t\\}_{t=0}^{N-1}$。\n4.  初始化 $C_{\\text{chron}} = (c \\cdot p_0) \\cdot \\Delta t$，因为 $s_0 = \\max(0, L_0 - p_0) = 0$。\n5.  从 $t=1$ 迭代到 $N-1$：\n    a. 使用规则 $p_t = \\max(p_{t-1} - r, \\min(L_t, p_{t-1} + r))$ 确定最优产量 $p_t$。\n    b. 计算短缺 $s_t = \\max(0, L_t - p_t)$。\n    c. 将当前步长的成本 $(c \\cdot p_t + v \\cdot s_t) \\cdot \\Delta t$ 加到 $C_{\\text{chron}}$。\n\n最后，计算生产成本误差 $E = C_{\\text{chron}} - C_{\\text{LDC}}$ 并四舍五入到两位小数。\n\n对于爬坡率 $R$ 足够高的测试用例，每步爬坡限制 $r$ 可能会超过任何两个连续步骤之间负荷的最大变化量，即 $r \\ge \\max_t |L_t - L_{t-1}|$。在这种情况下，如果 $p_{t-1}=L_{t-1}$，则 $|L_t - p_{t-1}| = |L_t-L_{t-1}| \\le r$，这意味着目标负荷 $L_t$ 始终在可行的生产区间 $[p_{t-1}-r, p_{t-1}+r]$ 内。从初始状态 $p_0=L_0$ 通过归纳法可知，最优调度始终是 $p_t = L_t$。因此，$C_{\\text{chron}} = \\sum c \\cdot L_t \\Delta t = C_{\\text{LDC}}$，从而产生生产成本误差 $E=0$。这适用于测试用例1和4，其中提供的爬坡率 $R$ 大于离散负荷信号的最大变化率。对于情况2和3，$R$ 不足，导致 $p_t$ 和 $L_t$ 之间出现偏差，从而产生正误差 $E$。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the production cost error problem for a set of test cases.\n    \"\"\"\n\n    def compute_production_cost_error(L0, A, T, N, c, v, R):\n        \"\"\"\n        Computes the production cost error between chronological and LDC dispatch.\n\n        Args:\n            L0 (float): Mean load in MW.\n            A (float): Amplitude of sinusoidal load in MW.\n            T (float): Time horizon in hours.\n            N (int): Number of time steps.\n            c (float): Variable production cost in $/MWh.\n            v (float): Unserved energy penalty in $/MWh.\n            R (float): Continuous ramp rate in MW/hour.\n\n        Returns:\n            float: The production cost error E, rounded to two decimal places.\n        \"\"\"\n        \n        # 1. Parameter and Load Profile Setup\n        delta_t = T / N\n        r = R * delta_t  # Per-step ramp limit in MW\n        \n        t_steps = np.arange(N)\n        load = L0 + A * np.sin(2 * np.pi * t_steps / N)\n        \n        # 2. LDC Dispatch Cost Calculation\n        # Assumes all load is met, no constraints.\n        c_ldc = c * np.sum(load) * delta_t\n        \n        # 3. Chronological Dispatch and Cost Calculation\n        p = np.zeros(N)  # Production schedule in MW\n        \n        # Initial condition at t=0\n        # Problem statement: p_0 = L_0. Load at t=0 is L0 + A*sin(0) = L0.\n        p[0] = L0\n        \n        # Shortage at t=0 is max(0, load[0] - p[0]), which is 0.\n        c_chron = c * p[0] * delta_t\n        \n        # Iterate through the time horizon to determine the optimal dispatch\n        for t in range(1, N):\n            p_prev = p[t-1]\n            \n            # The optimal dispatch p[t] is the projection of the load[t] onto\n            # the feasible interval [p_prev - r, p_prev + r].\n            p[t] = np.clip(load[t], p_prev - r, p_prev + r)\n            \n            # Calculate shortage (unmet load) at the current step\n            s_t = max(0, load[t] - p[t])\n            \n            # Accumulate cost for the current step\n            cost_t = (c * p[t] + v * s_t) * delta_t\n            c_chron += cost_t\n            \n        # 4. Compute the final error\n        error = c_chron - c_ldc\n        \n        return round(error, 2)\n\n    # Test suite from the problem statement\n    # Each case is a tuple (L0, A, T, N, c, v, R)\n    test_cases = [\n        (100, 30, 24, 96, 50, 5000, 12),\n        (100, 30, 24, 96, 50, 5000, 6),\n        (100, 30, 24, 96, 50, 5000, 0.5),\n        # For the 4th case, R is defined by a formula\n        (100, 30, 24, 96, 50, 5000, (2 * np.pi * 30) / 24),\n    ]\n\n    results = []\n    for params in test_cases:\n        result = compute_production_cost_error(*params)\n        results.append(result)\n\n    # Print the final results in the specified format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在确立了时间顺序的重要性之后，我们将这一原则应用于能量存储系统——一项其价值与时间紧密相关的关键技术。储能系统的充放电决策完全依赖于电价或负荷的逐时变化。本练习要求你为一个给定的时序净负荷曲线计算所需的最小储能容量，以实现“削峰填谷”的目标。要解决这个问题，你必须精确地模拟储能状态（SOC）在整个周期内的动态演变，并考虑充放电效率带来的能量损失，这是一个基于时序动态进行系统设计的典型实践。",
            "id": "4129549",
            "problem": "给定一个24小时时间范围内的离散时间顺序净负荷序列、一个目标峰值上限以及储能的充放电效率。目标是计算一个理想化储能系统的最小能量容量（以兆瓦时 MWh 表示），该系统能够在满足以下符合物理现实的约束条件下，将全天的净负荷限制在指定目标或以下。\n\n基本和核心定义：考虑一个离散时间表示，小时索引为 $t \\in \\{0,1,\\dots,T-1\\}$，其中 $T=24$，时间步长 $\\Delta t = 1$ 小时。令 $L_t$ 表示时间顺序的净负荷（兆瓦），即扣除非调度性供应后的剩余需求。令 $P^{\\mathrm{cap}}$ 表示目标上限（兆瓦），因此要求是确保任何小时的净负荷都不超过 $P^{\\mathrm{cap}}$。储能系统在小时 $t$ 开始时的荷电状态（SoC）表示为 $s_t$（兆瓦时），充电效率为 $\\eta_c \\in (0,1]$，放电效率为 $\\eta_d \\in (0,1]$。令 $u_t^{c}$ 表示在小时 $t$ 期间的充电功率（兆瓦），并令所需的放电功率 $u_t^{d}$ 为将净负荷降低至上限所必需的非负功率，其值由时间顺序和上限决定：$$u_t^{d} = \\max\\{0, L_t - P^{\\mathrm{cap}}\\}.$$ 类似地，为避免在充电时超过上限的最大可行充电功率为 $$U_t^{c} = \\max\\{0, P^{\\mathrm{cap}} - L_t\\}.$$ 根据能量守恒和效率定义推导出的每小时SoC动态为 $$s_{t+1} = s_t + \\eta_c \\, u_t^c \\, \\Delta t - \\frac{u_t^{d}}{\\eta_d} \\, \\Delta t,$$ 其中 $\\Delta t = 1$ 小时。储能能量容量 $E$（兆瓦时）必须满足边界约束 $$0 \\le s_t \\le E \\quad \\text{对所有 } t,$$ 且每日循环运行要求 $$s_T = s_0.$$\n\n最小可行容量问题是：找到最小的 $E$，使得存在一个充电计划 $\\{u_t^c\\}_{t=0}^{T-1}$，满足对所有 $t$ 都有 $0 \\le u_t^c \\le U_t^c$，同时满足SoC动态、循环边界条件和SoC边界，给定强制执行上限的强制放电 $\\{u_t^d\\}$。如果不存在这样的计划（即时间顺序和效率意味着存在一个无法通过可行充电来恢复的能量不平衡），则报告不可行。\n\n任务：\n1.  实现一个程序，对每个给定的测试用例，用纯数学术语，根据上述离散动态，建立并求解最小容量问题，并返回最小的 $E$（单位为兆瓦时 MWh），四舍五入到三位小数。如果某个测试用例的问题不可行，则返回哨兵值 $-1.000$。\n2.  您必须明确强制执行循环边界条件 $s_T = s_0$、SoC边界 $0 \\le s_t \\le E$ 和充电边界 $0 \\le u_t^c \\le U_t^c$，并且必须将放电 $u_t^d$ 视为由时间顺序固定的。使用 $\\Delta t = 1$ 小时，因此以兆瓦时为单位的能量等于以兆瓦为单位的功率乘以1。\n3.  您必须以兆瓦时（MWh）为单位表示最终容量答案，四舍五入到三位小数。\n\n测试套件：\n为以下四个测试用例提供结果，每个用例由 $(\\{L_t\\}_{t=0}^{23}, P^{\\mathrm{cap}}, \\eta_c, \\eta_d)$ 指定。\n\n- 用例 $1$ (一般的理想情况):\n  - $P^{\\mathrm{cap}} = 50$,\n  - $\\eta_c = 0.92$, $\\eta_d = 0.90$,\n  - $\\{L_t\\}_{t=0}^{23} = [48, 52, 55, 60, 62, 58, 54, 49, 45, 43, 46, 50, 53, 57, 65, 63, 59, 56, 52, 48, 44, 42, 47, 51]$.\n\n- 用例 $2$ (具有对称性的边界能量平衡可行性):\n  - $P^{\\mathrm{cap}} = 50$,\n  - $\\eta_c = 0.90$, $\\eta_d = 0.90$,\n  - 构建波谷和波峰，使得 $\\sum_t \\eta_c U_t^c = \\sum_t \\frac{u_t^d}{\\eta_d}$：设 $b = 9$ 且 $a = \\frac{b}{\\eta_c \\eta_d} = \\frac{9}{0.9 \\cdot 0.9} = 11.111\\ldots$，所以\n  - $\\{L_t\\}_{t=0}^{23} = [38.8888888889 \\text{ (重复 } 12 \\text{ 次)}, 59 \\text{ (重复 } 12 \\text{ 次)}]$.\n\n- 用例 $3$ (重要的边缘案例：由于效率下波谷能量不足而不可行):\n  - $P^{\\mathrm{cap}} = 50$,\n  - $\\eta_c = 0.90$, $\\eta_d = 0.90$,\n  - $\\{L_t\\}_{t=0}^{23} = [42 \\text{ (重复 } 12 \\text{ 次)}, 60 \\text{ (重复 } 12 \\text{ 次)}]$.\n\n- 用例 $4$ (边缘案例：没有超过上限的峰值，容量为零):\n  - $P^{\\mathrm{cap}} = 50$,\n  - $\\eta_c = 0.95$, $\\eta_d = 0.95$,\n  - $\\{L_t\\}_{t=0}^{23} = [45, 46, 47, 48, 49, 50, 49, 48, 47, 46, 45, 44, 45, 46, 47, 48, 49, 50, 49, 48, 47, 46, 45, 44]$.\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，每个条目是对应测试用例计算出的最小容量（单位为兆瓦时 MWh），四舍五入到三位小数，如果不可行则为 $-1.000$。例如，输出必须具有以下形式 $$[x_1,x_2,x_3,x_4],$$ 其中每个 $x_i$ 是一个如上指定的浮点数。",
            "solution": "该问题要求计算一个储能系统的最小能量容量 $E$，该储能系统需要将一个时间顺序的净负荷曲线 $L_t$ 限制在给定的峰值水平 $P^{\\mathrm{cap}}$。解决方案必须遵循系统的动态特性、物理约束和循环运行要求。\n\n### 步骤 1：问题验证\n\n**1.1. 提取给定条件**\n\n-   **时间范围**：$t \\in \\{0, 1, \\dots, T-1\\}$，其中 $T=24$。\n-   **时间步长**：$\\Delta t = 1$ 小时。\n-   **时间顺序净负荷**：$L_t$ (MW)。\n-   **目标峰值上限**：$P^{\\mathrm{cap}}$ (MW)。\n-   **储能荷电状态 (SoC)**：$s_t$ (MWh)，在小时 $t$ 开始时。\n-   **效率**：充电效率 $\\eta_c \\in (0, 1]$，放电效率 $\\eta_d \\in (0, 1]$。\n-   **充电功率**：$u_t^c$ (MW)。\n-   **放电功率**：$u_t^{d} = \\max\\{0, L_t - P^{\\mathrm{cap}}\\}$ (MW)。这是为满足上限要求而必须进行的、非负的功率注入。\n-   **最大可行充电功率**：$U_t^{c} = \\max\\{0, P^{\\mathrm{cap}} - L_t\\}$ (MW)。\n-   **SoC动态**：$s_{t+1} = s_t + \\eta_c \\, u_t^c \\, \\Delta t - \\frac{u_t^{d}}{\\eta_d} \\, \\Delta t$。\n-   **储能约束**：\n    -   SoC边界：对所有 $t$，$0 \\le s_t \\le E$。\n    -   充电边界：对所有 $t$，$0 \\le u_t^c \\le U_t^c$。\n    -   循环条件：$s_T = s_0$。\n-   **目标**：找到最小可行能量容量 $E$ (MWh)。\n-   **不可行性**：如果不存在解，报告不可行。\n\n**1.2. 使用提取的给定条件进行验证**\n\n-   **科学依据**：该问题基于应用于储能系统的公认能量守恒原理。该模型使用了效率、荷电状态和潮流的标准定义。这是能源系统建模中使用的一种简化但物理上真实的表示方法。\n-   **适定性**：该问题被构建为一个约束优化问题：在系统状态和控制变量的一组线性约束下，最小化变量 $E$。如果存在可行解，这种结构是适定的，并且 $E$ 存在唯一的最小值。\n-   **客观性**：问题陈述使用了精确的数学定义和客观语言。没有主观或模糊的术语。\n-   **完整性**：所有必要的数据和方程（$L_t$、$P^{\\mathrm{cap}}$、效率、动态、约束）都已提供，以构建一个可解的模型。\n-   **一致性**：给定条件内部一致。充放电的物理原理在SoC动态方程中得到了正确表示。例如，要向电网放电 $u_t^d$，必须从储能中提取能量 $u_t^d / \\eta_d$，这正确地计及了损耗。\n\n**1.3. 结论与行动**\n\n该问题是**有效的**。它是能源系统工程领域一个科学合理、适定且客观的问题。我将继续进行建模和求解。\n\n### 步骤 2：数学建模与求解\n\n核心任务是找到允许可行运行计划的最小能量容量 $E$。这可以被构建为一个约束优化问题。\n\n**A. 可行性条件**\n\n首先，我们为任何可行解的存在建立一个必要条件。SoC动态由下式给出（其中 $\\Delta t=1$）：\n$$s_{t+1} = s_t + \\eta_c u_t^c - \\frac{u_t^{d}}{\\eta_d}$$\n将此方程从 $t=0$ 到 $t=T-1$ 求和：\n$$\\sum_{t=0}^{T-1} (s_{t+1} - s_t) = \\sum_{t=0}^{T-1} \\left( \\eta_c u_t^c - \\frac{u_t^{d}}{\\eta_d} \\right)$$\n左侧是一个等于 $s_T - s_0$ 的伸缩求和。循环边界条件 $s_T = s_0$ 意味着这个和为零。因此，整个周期的总能量平衡为：\n$$\\sum_{t=0}^{T-1} \\eta_c u_t^c = \\sum_{t=0}^{T-1} \\frac{u_t^{d}}{\\eta_d}$$\n该方程表示，充入储能的总能量（计及充电效率）必须等于为满足放电需求而从储能中提取的总能量（计及放电效率）。\n\n充电功率受限于 $0 \\le u_t^c \\le U_t^c$。在整个周期内求和，可以得到可充电总能量的上限：\n$$\\sum_{t=0}^{T-1} \\eta_c u_t^c \\le \\sum_{t=0}^{T-1} \\eta_c U_t^c$$\n结合这两个结果，得到一个基本可行性条件：\n$$\\sum_{t=0}^{T-1} \\frac{u_t^{d}}{\\eta_d} \\le \\sum_{t=0}^{T-1} \\eta_c U_t^c$$\n放电所需的总能量（从储能的角度看）必须小于或等于可用于充电的总最大能量（计入储能）。如果违反此条件，储能系统在周期内将出现不可恢复的能量赤字，不存在可行的充电计划。此时问题是不可行的。\n\n**B. 线性规划模型**\n\n如果可行性条件成立，我们可以通过求解一个线性规划（LP）来找到最小容量 $E$。问题是在一组线性约束下最小化 $E$。\n\n优化变量是：\n-   能量容量 $E$。\n-   每个小时开始时的荷电状态：$\\{s_0, s_1, \\dots, s_{T-1}\\}$。\n-   每个小时的充电功率：$\\{u_0^c, u_1^c, \\dots, u_{T-1}^c\\}$。\n\nLP模型构建如下：\n\n**最小化：**\n$$E$$\n**约束条件：**\n\n1.  **SoC动态（等式约束）：** 这 $T$ 个约束将跨时间步的状态变量联系起来。对于 $t \\in \\{0, \\dots, T-2\\}$：\n    $$s_{t+1} - s_t - \\eta_c u_t^c = -\\frac{u_t^d}{\\eta_d}$$\n    对于最后一步，并入循环条件 $s_T=s_0$：\n    $$s_0 - s_{T-1} - \\eta_c u_{T-1}^c = -\\frac{u_{T-1}^d}{\\eta_d}$$\n\n2.  **SoC容量限制（不等式约束）：** SoC不得超过容量 $E$。对于 $t \\in \\{0, \\dots, T-1\\}$：\n    $$s_t - E \\le 0$$\n\n3.  **变量边界：**\n    -   非负容量：$E \\ge 0$。\n    -   非负SoC：对所有 $t \\in \\{0, \\dots, T-1\\}$，$s_t \\ge 0$。\n    -   充电功率限制：对所有 $t \\in \\{0, \\dots, T-1\\}$，$0 \\le u_t^c \\le U_t^c$。\n\n这个模型构成了一个标准的LP问题，可以使用数值算法（如单纯形法或内点法）求解，这些算法已在 `scipy.optimize` 等库中实现。\n\n**C. 算法大纲**\n\n对于每个测试用例：\n1.  根据输入的负荷曲线 $\\{L_t\\}$ 和峰值上限 $P^{\\mathrm{cap}}$，预计算固定的每小时参数：\n    -   强制放电功率：$u_t^d = \\max(0, L_t - P^{\\mathrm{cap}})$。\n    -   最大充电功率：$U_t^c = \\max(0, P^{\\mathrm{cap}} - L_t)$。\n2.  验证能量平衡可行性条件：如果 $\\sum_{t=0}^{T-1} \\frac{u_t^d}{\\eta_d}  \\sum_{t=0}^{T-1} \\eta_c U_t^c$，则问题不可行。报告 $-1.000$。\n3.  如果可行，构建LP的各组成部分：目标函数向量、等式和不等式约束的矩阵，以及每个变量的边界。\n4.  使用标准求解器求解LP。解将提供所有变量的最优值，包括最小容量 $E$。\n5.  返回获得的最小容量 $E$，四舍五入到三位小数。\n\n此过程正确地对物理系统进行建模，并保证在给定约束下找到最小可能的储能容量。",
            "answer": "```python\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: General happy path\n        {\n            \"L_t\": np.array([48, 52, 55, 60, 62, 58, 54, 49, 45, 43, 46, 50, 53, 57, 65, 63, 59, 56, 52, 48, 44, 42, 47, 51]),\n            \"P_cap\": 50.0,\n            \"eta_c\": 0.92,\n            \"eta_d\": 0.90,\n        },\n        # Case 2: Boundary energy-balance feasibility\n        {\n            \"L_t\": np.concatenate([np.full(12, 38.8888888889), np.full(12, 59.0)]),\n            \"P_cap\": 50.0,\n            \"eta_c\": 0.90,\n            \"eta_d\": 0.90,\n        },\n        # Case 3: Infeasible due to insufficient valley energy\n        {\n            \"L_t\": np.concatenate([np.full(12, 42.0), np.full(12, 60.0)]),\n            \"P_cap\": 50.0,\n            \"eta_c\": 0.90,\n            \"eta_d\": 0.90,\n        },\n        # Case 4: No peaks above the cap, zero capacity\n        {\n            \"L_t\": np.array([45, 46, 47, 48, 49, 50, 49, 48, 47, 46, 45, 44, 45, 46, 47, 48, 49, 50, 49, 48, 47, 46, 45, 44]),\n            \"P_cap\": 50.0,\n            \"eta_c\": 0.95,\n            \"eta_d\": 0.95,\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        result = calculate_min_capacity(case[\"L_t\"], case[\"P_cap\"], case[\"eta_c\"], case[\"eta_d\"])\n        results.append(f\"{result:.3f}\")\n\n    print(f\"[{','.join(results)}]\")\n\ndef calculate_min_capacity(L_t, P_cap, eta_c, eta_d):\n    \"\"\"\n    Calculates the minimum storage capacity for a given load profile and parameters.\n\n    Args:\n        L_t (np.array): Chronological net load series (MW).\n        P_cap (float): Target peak cap (MW).\n        eta_c (float): Storage charge efficiency.\n        eta_d (float): Storage discharge efficiency.\n\n    Returns:\n        float: The minimum required storage capacity (MWh), or -1.0 if infeasible.\n    \"\"\"\n    T = 24\n    \n    # Calculate hourly required discharge and max possible charge power\n    u_d = np.maximum(0, L_t - P_cap)\n    U_c = np.maximum(0, P_cap - L_t)\n    \n    # Calculate energy drawn from storage for discharge\n    d_t = u_d / eta_d\n    \n    # Check overall energy balance feasibility\n    total_discharge_needed = np.sum(d_t)\n    total_charge_available = np.sum(eta_c * U_c)\n    \n    # Use a small tolerance for floating point comparison, though not strictly needed for given cases\n    if total_discharge_needed > total_charge_available + 1e-9:\n        return -1.0\n\n    # If no discharge is ever needed, capacity is zero\n    if total_discharge_needed  1e-9:\n        return 0.0\n\n    # Formulate and solve the Linear Program\n    # Variable vector x: [E, s_0, ..., s_23, u_c_0, ..., u_c_23]\n    # Total variables: 1 (E) + T (s_t) + T (u_c_t) = 1 + 24 + 24 = 49\n    num_vars = 1 + 2 * T\n\n    # Objective function: minimize E\n    c = np.zeros(num_vars)\n    c[0] = 1.0\n\n    # Equality constraints (A_eq * x = b_eq): SoC dynamics\n    A_eq = np.zeros((T, num_vars))\n    b_eq = -d_t\n    \n    for t in range(T - 1):\n        # s_{t+1} - s_t - eta_c * u_c_t = -d_t\n        A_eq[t, 1 + (t + 1)] = 1.0  # s_{t+1}\n        A_eq[t, 1 + t] = -1.0       # -s_t\n        A_eq[t, 1 + T + t] = -eta_c # -eta_c * u_c_t\n    \n    # Cyclic constraint: s_0 - s_{T-1} - eta_c * u_c_{T-1} = -d_{T-1}\n    A_eq[T - 1, 1] = 1.0            # s_0\n    A_eq[T - 1, 1 + (T - 1)] = -1.0 # -s_{T-1}\n    A_eq[T - 1, 1 + T + (T-1)] = -eta_c # -eta_c * u_c_{T-1}\n\n    # Inequality constraints (A_ub * x = b_ub): SoC = E\n    # s_t - E = 0\n    A_ub = np.zeros((T, num_vars))\n    b_ub = np.zeros(T)\n    \n    for t in range(T):\n        A_ub[t, 1 + t] = 1.0 # s_t\n        A_ub[t, 0] = -1.0    # -E\n\n    # Bounds for variables\n    bounds = []\n    # E >= 0\n    bounds.append((0, None))\n    # s_t >= 0\n    for _ in range(T):\n        bounds.append((0, None))\n    # 0 = u_c_t = U_c_t\n    for t in range(T):\n        bounds.append((0, U_c[t]))\n\n    # Solve the LP\n    res = linprog(c, A_eq=A_eq, b_eq=b_eq, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n\n    if res.success:\n        min_E = res.x[0]\n        return min_E\n    else:\n        # Should not be reached if initial feasibility check is correct, but as a fallback\n        return -1.0\n\nif __name__ == '__main__':\n    solve()\n```"
        },
        {
            "introduction": "最后一个实践将视角从应用时序模型转向审视模型本身的数据基础。即使我们采用了时序模型，时间分辨率的选择——作为时间表示的一个基本方面——也可能极大地影响模型的结论。本练习通过比较高分辨率数据与降采样（时间聚合）后的数据在关键斜坡指标上的差异，来探讨这个问题。你将看到时间聚合如何像一个滤镜，平滑掉可再生能源的真实波动性，从而可能导致对系统灵活性（如备用容量）需求的严重低估。",
            "id": "4129582",
            "problem": "将风力发电输出的离散时间表示看作一个按时间顺序排列的序列 $\\{w_t\\}_{t=0}^{T-1}$，该序列以均匀的小时间隔测量，每个样本 $w_t$ 以兆瓦（MW）为单位。定义小时斜坡序列为 $r^{(1)}_t = w_t - w_{t-1}$，其中 $t \\in \\{1,2,\\dots,T-1\\}$。在该小时序列上定义三个斜坡指标：\n- 平均绝对斜坡 $\\mathrm{MAR}^{(1)} = \\frac{1}{T-1} \\sum_{t=1}^{T-1} \\left|r^{(1)}_t\\right|$，单位为 $\\text{MW}$，\n- 斜坡方差 $\\mathrm{VAR}^{(1)} = \\frac{1}{T-1} \\sum_{t=1}^{T-1} \\left(r^{(1)}_t - \\overline{r}^{(1)}\\right)^2$，单位为 $\\text{MW}^2$，其中 $\\overline{r}^{(1)} = \\frac{1}{T-1} \\sum_{t=1}^{T-1} r^{(1)}_t$，\n- 最大绝对斜坡 $\\mathrm{MAX}^{(1)} = \\max_{t \\in \\{1,\\dots,T-1\\}} \\left|r^{(1)}_t\\right|$，单位为 $\\text{MW}$。\n\n现在，通过对3小时块进行非重叠算术平均，以更粗的时间分辨率构建一个重采样序列，从而得到 $\\{W_k\\}_{k=0}^{K-1}$，其中 $K = \\left\\lfloor \\frac{T}{3} \\right\\rfloor$ 且\n$$\nW_k = \\frac{1}{3} \\sum_{j=0}^{2} w_{3k+j}, \\quad k \\in \\{0,1,\\dots,K-1\\}.\n$$\n为保持对齐和时序，舍弃任何不能填满一个完整3小时块的尾随小时。定义3小时斜坡序列为 $r^{(3)}_k = W_k - W_{k-1}$，其中 $k \\in \\{1,2,\\dots,K-1\\}$，并定义相应的斜坡指标：\n- 平均绝对斜坡 $\\mathrm{MAR}^{(3)} = \\frac{1}{K-1} \\sum_{k=1}^{K-1} \\left|r^{(3)}_k\\right|$，单位为 $\\text{MW}$，\n- 斜坡方差 $\\mathrm{VAR}^{(3)} = \\frac{1}{K-1} \\sum_{k=1}^{K-1} \\left(r^{(3)}_k - \\overline{r}^{(3)}\\right)^2$，单位为 $\\text{MW}^2$，其中 $\\overline{r}^{(3)} = \\frac{1}{K-1} \\sum_{k=1}^{K-1} r^{(3)}_k$，\n- 最大绝对斜坡 $\\mathrm{MAX}^{(3)} = \\max_{k \\in \\{1,\\dots,K-1\\}} \\left|r^{(3)}_k\\right|$，单位为 $\\text{MW}$。\n\n对于每个数据集，计算由重采样引起的每个指标的相对误差：\n$$\n\\epsilon_{\\mathrm{MAR}} = \\frac{\\mathrm{MAR}^{(3)} - \\mathrm{MAR}^{(1)}}{\\mathrm{MAR}^{(1)}}, \\quad\n\\epsilon_{\\mathrm{VAR}} = \\frac{\\mathrm{VAR}^{(3)} - \\mathrm{VAR}^{(1)}}{\\mathrm{VAR}^{(1)}}, \\quad\n\\epsilon_{\\mathrm{MAX}} = \\frac{\\mathrm{MAX}^{(3)} - \\mathrm{MAX}^{(1)}}{\\mathrm{MAX}^{(1)}}.\n$$\n如果上述任何分数中的分母为 $0$，则将相应的相对误差定义为 $0$。此外，计算一个备用容量缩放因子\n$$\ns = \n\\begin{cases}\n\\frac{\\mathrm{MAX}^{(1)}}{\\mathrm{MAX}^{(3)}},  \\text{如果 } \\mathrm{MAX}^{(3)}  0, \\\\\n+\\infty,  \\text{如果 } \\mathrm{MAX}^{(3)} = 0 \\text{ 且 } \\mathrm{MAX}^{(1)}  0, \\\\\n1,  \\text{如果 } \\mathrm{MAX}^{(3)} = 0 \\text{ 且 } \\mathrm{MAX}^{(1)} = 0,\n\\end{cases}\n$$\n该因子被解释为将基于3小时的最大斜坡要求进行缩放以满足小时级别极端值所需的乘法因子，$s$ 是无单位的。\n\n使用以下三个测试数据集，以涵盖典型情况、边界情况和边缘情况。在所有情况下，通过将 $w_t$ 限定为至少 $0$ $\\text{MW}$ 来强制其非负性。\n\n- 测试用例 #1 (典型日变化)：$T = 24$，对于 $t \\in \\{0,1,\\dots,23\\}$，\n$$\nw_t = 600 + 150 \\sin\\left(\\frac{2\\pi t}{24}\\right) + 40 \\sin\\left(\\frac{2\\pi t}{3}\\right) + 20 \\cos\\left(\\frac{2\\pi t}{5}\\right) - 200 \\cdot \\mathbf{1}_{\\{12 \\le t \\le 13\\}},\n$$\n其中 $\\mathbf{1}$ 是指示函数。单位为 $\\text{MW}$。\n\n- 测试用例 #2 (带有尖峰的边界长度)：$T = 25$，对于 $t \\in \\{0,1,\\dots,24\\}$，\n$$\nw_t = 350 + 120 \\sin\\left(\\frac{2\\pi t}{12}\\right) + 80 \\sin\\left(\\frac{2\\pi t}{4}\\right) + 250 \\cdot \\mathbf{1}_{\\{t = 7\\}} - 300 \\cdot \\mathbf{1}_{\\{t = 18\\}}.\n$$\n\n- 测试用例 #3 (边缘情况常数序列)：$T = 27$，对于 $t \\in \\{0,1,\\dots,26\\}$，\n$$\nw_t = 300.\n$$\n\n所有三角函数均使用弧度作为角度单位。$w_t$、$r^{(1)}_t$、$r^{(3)}_k$、$\\mathrm{MAR}^{(1)}$、$\\mathrm{MAR}^{(3)}$ 以及 $\\mathrm{MAX}^{(1)}$、$\\mathrm{MAX}^{(3)}$ 的单位是 $\\text{MW}$。$\\mathrm{VAR}^{(1)}$ 和 $\\mathrm{VAR}^{(3)}$ 的单位是 $\\text{MW}^2$。相对误差 $\\epsilon_{\\mathrm{MAR}}$、$\\epsilon_{\\mathrm{VAR}}$、$\\epsilon_{\\mathrm{MAX}}$ 和缩放因子 $s$ 是无单位的小数值。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个元素对应一个测试用例，并且本身是按 $[\\epsilon_{\\mathrm{MAR}}, \\epsilon_{\\mathrm{VAR}}, \\epsilon_{\\mathrm{MAX}}, s]$ 顺序排列的包含四个浮点数的列表。例如，输出格式为 $[[a_1,b_1,c_1,d_1],[a_2,b_2,c_2,d_2],[a_3,b_3,c_3,d_3]]$，不含空格。",
            "solution": "问题陈述已根据指定标准进行了分析和验证。\n\n### 问题验证\n\n**步骤 1：提取已知条件**\n- **时间序列：** $\\{w_t\\}_{t=0}^{T-1}$，以 $\\text{MW}$ 为单位的小时功率。\n- **小时斜坡：** $r^{(1)}_t = w_t - w_{t-1}$，其中 $t \\in \\{1,\\dots,T-1\\}$。\n- **小时指标：**\n    - $\\mathrm{MAR}^{(1)} = \\frac{1}{T-1} \\sum_{t=1}^{T-1} |r^{(1)}_t|$。\n    - $\\mathrm{VAR}^{(1)} = \\frac{1}{T-1} \\sum_{t=1}^{T-1} (r^{(1)}_t - \\overline{r}^{(1)})^2$，其中 $\\overline{r}^{(1)}$ 是 $r^{(1)}_t$ 的平均值。\n    - $\\mathrm{MAX}^{(1)} = \\max_{t} |r^{(1)}_t|$。\n- **重采样序列：** $\\{W_k\\}_{k=0}^{K-1}$，通过3小时非重叠平均得到，其中 $K = \\lfloor T/3 \\rfloor$ 且 $W_k = \\frac{1}{3} \\sum_{j=0}^{2} w_{3k+j}$。尾随数据被丢弃。\n- **3小时斜坡：** $r^{(3)}_k = W_k - W_{k-1}$，其中 $k \\in \\{1,\\dots,K-1\\}$。\n- **3小时指标：**\n    - $\\mathrm{MAR}^{(3)} = \\frac{1}{K-1} \\sum_{k=1}^{K-1} |r^{(3)}_k|$。\n    - $\\mathrm{VAR}^{(3)} = \\frac{1}{K-1} \\sum_{k=1}^{K-1} (r^{(3)}_k - \\overline{r}^{(3)})^2$，其中 $\\overline{r}^{(3)}$ 是 $r^{(3)}_k$ 的平均值。\n    - $\\mathrm{MAX}^{(3)} = \\max_{k} |r^{(3)}_k|$。\n- **相对误差：** $\\epsilon_{\\mathrm{MAR}} = (\\mathrm{MAR}^{(3)} - \\mathrm{MAR}^{(1)})/\\mathrm{MAR}^{(1)}$，$\\epsilon_{\\mathrm{VAR}} = (\\mathrm{VAR}^{(3)} - \\mathrm{VAR}^{(1)})/\\mathrm{VAR}^{(1)}$，$\\epsilon_{\\mathrm{MAX}} = (\\mathrm{MAX}^{(3)} - \\mathrm{MAX}^{(1)})/\\mathrm{MAX}^{(1)}$。如果分母为 $0$，则误差定义为 $0$。\n- **备用容量缩放因子：** $s$ 被分段定义：如果 $\\mathrm{MAX}^{(3)}  0$，则 $s = \\mathrm{MAX}^{(1)} / \\mathrm{MAX}^{(3)}$；如果 $\\mathrm{MAX}^{(3)} = 0$ 且 $\\mathrm{MAX}^{(1)}  0$，则 $s = +\\infty$；如果两者都为 $0$，则 $s = 1$。\n- **约束条件：** 对所有 $t$，$w_t \\ge 0$。\n- **测试用例：** 提供了三个关于 $w_t$ 的特定函数，分别对应 $T=24$、$T=25$ 和 $T=27$。\n\n**步骤 2：使用提取的已知条件进行验证**\n问题被评估为有效。\n- **有科学依据：** 该问题将标准的时间序列分析技术（降采样、差分算子、统计矩）应用于一个合成的发电信号。这是能源系统建模中研究数据分辨率对变异性评估影响的一种常用且有效的方法。\n- **定义明确：** 所有术语、变量和公式都有明确无误的定义。测试用例是完整的。对特殊情况（例如，除以零）的处理有精确规定，确保了每种情况都能确定唯一的解。问题是自洽的。\n- **客观性：** 问题陈述纯粹是数学和程序性的，没有主观或模棱两可的语言。\n\n**步骤 3：结论与行动**\n问题是有效的。将提供一个完整的解决方案。\n\n### 基于原则的设计与解决方案\n这个问题研究了时间聚合对时间序列统计特性的影响，这是能源系统建模中的一个关键课题。高分辨率数据（例如，小时级）能捕捉到像风能这样的可变可再生能源的快速波动，即“斜坡”。系统运营商必须持有充足的备用容量来管理这些斜坡。为了计算上的易行性，能源模型常使用较粗糙的数据（例如，3小时、6小时）。本问题将与此类降采样相关的信息损失的量化过程形式化。\n\n其核心原理是算术平均起到低通滤波器的作用。通过对3小时块内的每小时功率输出 $w_t$ 进行平均以创建 $W_k$，我们平滑了时间序列。这个滤波过程会衰减高频分量，直接表现为大斜坡的幅度和频率的减小。因此，我们预期在较粗糙序列上计算的斜坡指标（$\\mathrm{MAR}^{(3)}$、$\\mathrm{VAR}^{(3)}$、$\\mathrm{MAX}^{(3)}$）会小于它们在高分辨率下的对应项（$\\mathrm{MAR}^{(1)}$、$\\mathrm{VAR}^{(1)}$、$\\mathrm{MAX}^{(1)}$）。相对误差 $\\epsilon$ 量化了这种减小，因此预计为负值。备用容量缩放因子 $s$ 提供了一个直接的乘数，表明根据低分辨率数据计算的备用容量需求需要放大多少才能覆盖高分辨率数据中观察到的真实极端情况。$s  1$ 表示低分辨率数据低估了最大斜坡。\n\n该解决方案通过一个针对每个测试用例的系统性算法来实现。\n\n**步骤 A：时间序列生成**\n对于每个测试用例，根据其指定函数生成小时风电序列 $\\{w_t\\}_{t=0}^{T-1}$。通过将任何负值限定为 $0$ 来强制执行非负约束 $w_t \\ge 0$。\n\n**步骤 B：小时斜坡指标计算**\n1.  使用一阶差分计算小时斜坡序列 $\\{r^{(1)}_t\\}_{t=1}^{T-1}$：$r^{(1)}_t = w_t - w_{t-1}$。\n2.  平均绝对斜坡 $\\mathrm{MAR}^{(1)}$ 是序列 $\\{r^{(1)}_t\\}$ 中元素绝对值的平均值。\n3.  斜坡方差 $\\mathrm{VAR}^{(1)}$ 使用提供的公式计算，该公式对应于序列 $\\{r^{(1)}_t\\}$ 的总体方差。注意，求和项数为 $T-1$，除数也为 $T-1$。\n4.  最大绝对斜坡 $\\mathrm{MAX}^{(1)}$ 是序列 $\\{r^{(1)}_t\\}$ 中元素绝对值的最大值。\n\n**步骤 C：时间序列重采样**\n1.  粗糙序列的块数为 $K = \\lfloor T/3 \\rfloor$。\n2.  原始序列 $\\{w_t\\}$ 被截断为其前 $3K$ 个元素，以确保它可以被均匀地分成大小为3的块。\n3.  截断后的序列被分割成 $K$ 个不重叠的、由3个连续小时组成的块。计算每个块的算术平均值以形成重采样序列 $\\{W_k\\}_{k=0}^{K-1}$。\n\n**步骤 D：3小时斜坡指标计算**\n1.  3小时斜坡序列 $\\{r^{(3)}_k\\}_{k=1}^{K-1}$ 计算为 $r^{(3)}_k = W_k - W_{k-1}$。\n2.  指标 $\\mathrm{MAR}^{(3)}$、$\\mathrm{VAR}^{(3)}$ 和 $\\mathrm{MAX}^{(3)}$ 是根据序列 $\\{r^{(3)}_k\\}$ 计算的，使用的定义与其小时对应项相同，但样本大小为 $K-1$。\n\n**步骤 E：最终指标计算**\n1.  使用各自的公式计算相对误差 $\\epsilon_{\\mathrm{MAR}}$、$\\epsilon_{\\mathrm{VAR}}$ 和 $\\epsilon_{\\mathrm{MAX}}$。应用了当分母为 $0$ 时误差为 $0$ 的指定条件。这对于测试用例 #3 尤其重要，因为其初始序列是恒定的，导致所有斜坡指标都为零。\n2.  根据其分段定义计算备用容量缩放因子 $s$，该定义正确处理了 $\\mathrm{MAX}^{(1)}$ 和 $\\mathrm{MAX}^{(3)}$ 为零或正的所有组合。$\\mathrm{MAX}^{(3)}=0$ 但 $\\mathrm{MAX}^{(1)}0$ 的情况正确地得出 $s=+\\infty$，表示对备用需求的无界低估。两者均为 $0$ 的情况正确地得出 $s=1$，表示不需要缩放，因为没有斜坡需要覆盖。\n\n这个全面的程序确保了问题陈述的各个方面都得到了严谨的遵循，为每个测试用例得出了正确且可验证的结果。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem for all test cases and prints the final result.\n    \"\"\"\n\n    def get_w_case1(t_vector):\n        \"\"\"Generates the time series for test case #1.\"\"\"\n        term1 = 150 * np.sin(2 * np.pi * t_vector / 24)\n        term2 = 40 * np.sin(2 * np.pi * t_vector / 3)\n        term3 = 20 * np.cos(2 * np.pi * t_vector / 5)\n        w = 600 + term1 + term2 + term3\n        # Indicator function for 12 = t = 13\n        w[12:14] -= 200\n        return w\n\n    def get_w_case2(t_vector):\n        \"\"\"Generates the time series for test case #2.\"\"\"\n        term1 = 120 * np.sin(2 * np.pi * t_vector / 12)\n        term2 = 80 * np.sin(2 * np.pi * t_vector / 4)\n        w = 350 + term1 + term2\n        # Indicator functions for t=7 and t=18\n        w[7] += 250\n        w[18] -= 300\n        return w\n\n    def get_w_case3(t_vector):\n        \"\"\"Generates the time series for test case #3.\"\"\"\n        return np.full_like(t_vector, 300.0, dtype=float)\n\n    test_cases = [\n        {'T': 24, 'func': get_w_case1},\n        {'T': 25, 'func': get_w_case2},\n        {'T': 27, 'func': get_w_case3},\n    ]\n\n    results = []\n    for case in test_cases:\n        T = case['T']\n        w_func = case['func']\n\n        # Step A: Generate original series {w_t}\n        t = np.arange(T)\n        w = w_func(t)\n        w = np.maximum(0, w)  # Enforce non-negativity\n\n        # Step B: Compute hourly ramp metrics\n        if T > 1:\n            r1 = np.diff(w)\n            mar1 = np.mean(np.abs(r1))\n            # The problem defines variance with N in the denominator, which is np.var's default (ddof=0)\n            var1 = np.var(r1, ddof=0)\n            max1 = np.max(np.abs(r1))\n        else:\n            mar1, var1, max1 = 0.0, 0.0, 0.0\n\n        # Step C  D: Resample and compute 3-hour ramp metrics\n        K = T // 3\n        if K > 1:\n            w_trunc = w[:3 * K]\n            W = np.mean(w_trunc.reshape(-1, 3), axis=1)\n            r3 = np.diff(W)\n            mar3 = np.mean(np.abs(r3))\n            var3 = np.var(r3, ddof=0)\n            max3 = np.max(np.abs(r3))\n        else:\n            mar3, var3, max3 = 0.0, 0.0, 0.0\n\n        # Step E: Calculate errors and scaling factor\n        \n        # Relative errors\n        eps_mar = (mar3 - mar1) / mar1 if mar1 != 0 else 0.0\n        eps_var = (var3 - var1) / var1 if var1 != 0 else 0.0\n        eps_max = (max3 - max1) / max1 if max1 != 0 else 0.0\n\n        # Reserve scaling factor\n        if max3 > 0:\n            s = max1 / max3\n        elif max3 == 0 and max1 > 0:\n            s = float('inf')\n        else:  # max3 == 0 and max1 == 0\n            s = 1.0\n\n        results.append([eps_mar, eps_var, eps_max, s])\n\n    # Final print statement in the exact required format.\n    inner_parts = []\n    for res_list in results:\n        formatted_list = f\"[{','.join(map(str, res_list))}]\"\n        inner_parts.append(formatted_list)\n    final_string = f\"[{','.join(inner_parts)}]\"\n    \n    print(final_string)\n\nsolve()\n```"
        }
    ]
}