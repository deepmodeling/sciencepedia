{
    "hands_on_practices": [
        {
            "introduction": "在处理任何数据之前，第一步总是验证其有效性。此练习旨在将简单无向图的邻接矩阵的基本完整性检查——即对称性和对角线元素为零——实现为代码。通过这项实践，你将在一个具体的计算情境中，加深对邻接矩阵这一定义性属性的理解。",
            "id": "4291927",
            "problem": "考虑一个顶点集为 $V$（大小为 $n$）的有限图，并设 $A \\in \\mathbb{R}^{n \\times n}$ 是一个建议的邻接矩阵表示。根据定义，对于无向图，顶点之间的成对关系是对称的，并且不存在自环要求没有顶点与其自身相邻。根据这些核心定义，一个无向无环图的有效邻接矩阵必须是方的、对称的，并且对角线元素为零。在具有实值条目的计算环境中，由于浮点表示，通常需要近似相等；因此可以使用一个容差参数 $\\varepsilon > 0$ 来操作化相等性检查。\n\n你的任务是实现一个程序，对每个提供的矩阵执行以下源于基本定义的一致性检查：\n- 验证 $A$ 是方阵，即对于某个整数 $n \\geq 1$，$A \\in \\mathbb{R}^{n \\times n}$。\n- 通过计数满足 $|a_{ij} - a_{ji}| > \\varepsilon$ 的无序顶点对 $\\{i,j\\}$（其中 $1 \\leq i < j \\leq n$）的数量来量化对称性违规。\n- 通过计数满足 $|a_{ii}| > \\varepsilon$ 的索引 $i \\in \\{1,\\dots,n\\}$ 的数量来量化对角线性违规。\n\n如果一个矩阵不是方阵，则对称性和对角线违规计数是未定义的。在这种情况下，将方阵检查报告为假，并对两个违规计数使用整数 $-1$ 来表示未定义的值。\n\n对所有绝对值比较使用容差 $\\varepsilon = 10^{-9}$。\n\n实现上述逻辑并将其应用于以下矩阵测试套件。每个矩阵被指定为实值数组；行以方括号列表的形式列出：\n- 测试用例 $1$：\n  [\n    [$0$, $1$, $0$],\n    [$1$, $0$, $1$],\n    [$0$, $1$, $0$]\n  ]\n- 测试用例 $2$：\n  [\n    [$0$, $2$, $0$],\n    [$2$, $1$, $3$],\n    [$0$, $3$, $0$]\n  ]\n- 测试用例 $3$：\n  [\n    [$0$, $1$, $0$],\n    [$0$, $0$, $1$],\n    [$0$, $1$, $0$]\n  ]\n- 测试用例 $4$：\n  [\n    [$1$, $1$, $0$],\n    [$0$, $0$, $0$],\n    [$0$, $0$, $0$]\n  ]\n- 测试用例 $5$：\n  [\n    [$0.0$]\n  ]\n- 测试用例 $6$：\n  [\n    [$1 \\times 10^{-12}$]\n  ]\n- 测试用例 $7$ (非方阵)：\n  [\n    [$0$, $1$, $0$],\n    [$1$, $0$, $1$]\n  ]\n- 测试用例 $8$：\n  [\n    [$0.0$, $1.0000000005$],\n    [$1.0$, $0.0$]\n  ]\n- 测试用例 $9$：\n  [\n    [$0.0$, $1.000000002$],\n    [$1.0$, $0.0$]\n  ]\n- 测试用例 $10$：\n  [\n    [$0$, $2.5$, $0$],\n    [$2.5$, $0$, $4.1$],\n    [$0$, $4.1$, $0$]\n  ]\n\n输出规范：\n- 对于每个测试用例，生成一个形式为 $[s, c_{\\text{sym}}, c_{\\text{diag}}]$ 的列表，其中 $s$ 是一个布尔值，表示矩阵是否为方阵，$c_{\\text{sym}}$ 是对称性违规的整数计数，$c_{\\text{diag}}$ 是对角线性违规的整数计数（当 $s$ 为假时，两个计数均为 $-1$）。\n- 你的程序应生成单行输出，其中包含所有测试用例的结果，形式为用方括号括起来的逗号分隔列表。具体来说，输出必须是结果列表的单行字符串表示，例如 $[r_1, r_2, \\dots, r_{10}]$，其中每个 $r_k$ 是上述的单个测试用例列表。",
            "solution": "目标是根据一个有限、无向、无环图的邻接矩阵所需的基本属性，验证给定的矩阵 $A$。这些属性是：矩阵必须是方的、对称的，并且对角线元素为零。验证将以计算方式执行，使用数值容差 $\\varepsilon = 10^{-9}$ 来考虑浮点数的不精确性。对于每个提供的矩阵，我们必须执行三个检查：方阵性、对称性违规和对角线性违规。\n\n假设一个候选矩阵以二维实数数组的形式提供。我们用 $a_{ij}$ 表示其元素，其中 $i$ 是行索引，$j$ 是列索引。步骤如下：\n\n1.  **方阵验证**：邻接矩阵表示大小为 $n$ 的集合 $V$ 中顶点之间的关系。这要求矩阵的行（或列）与图的顶点之间存在一一对应关系。因此，矩阵必须是方阵，即具有相同的行数和列数。设矩阵 $A$ 有 $m$ 行和 $p$ 列。对于一个非空图，要使 $A$ 成为一个有效的邻接矩阵，它必须满足 $m=p$ 且 $n=m=p \\geq 1$。如果给定矩阵未通过此测试，它就不能是邻接矩阵。题目规定，在这种情况下，对称性和对角线违规计数是未定义的，应报告为整数 $-1$。因此，非方阵的结果是 $[\\text{False}, -1, -1]$。\n\n2.  **对称性违规量化**：对于无向图，任意两个顶点 $i$ 和 $j$ 之间的关系是对称的。如果顶点 $i$ 与顶点 $j$ 相邻，那么顶点 $j$ 也必须与顶点 $i$ 相邻。就邻接矩阵 $A$ 而言，这转化为对称性属性：$A = A^T$，或对于所有索引对 $(i, j)$，$a_{ij} = a_{ji}$。为了在数值上下文中量化与此属性的偏差，我们计算其相应矩阵条目在给定容差 $\\varepsilon$ 内不相等的无序不同顶点对 $\\{i,j\\}$ 的数量。如果 $|a_{ij} - a_{ji}| > \\varepsilon$，则顶点对 $\\{i,j\\}$ 发生对称性违规。我们遍历所有唯一的索引对 $(i, j)$（其中 $1 \\leq i < j \\leq n$），并对每个违反此条件的对递增一个计数器 $c_{\\text{sym}}$。索引集 $1 \\leq i < j \\leq n$ 对应于矩阵严格上三角中的条目。\n\n3.  **对角线性违规量化**：根据定义，无环图没有连接顶点到自身的边。这意味着对于任何顶点 $i$，邻接矩阵中的条目 $a_{ii}$ 必须为零。与对称性检查类似，我们使用容差 $\\varepsilon$ 来测试此属性。如果顶点 $i$ 对应的对角线条目 $a_{ii}$ 的绝对值大于容差，即 $|a_{ii}| > \\varepsilon$，则发生对角线性违规。我们遍历从 $i=1$ 到 $n$ 的所有对角线条目，并为每个违反该条件的条目递增一个计数器 $c_{\\text{diag}}$。\n\n整个过程是首先检查方阵性。如果矩阵是方阵，我们继续计算 $c_{\\text{sym}}$ 和 $c_{\\text{diag}}$。单个矩阵的最终输出是一个列表 $[s, c_{\\text{sym}}, c_{\\text{diag}}]$，其中 $s$ 是方阵性测试的布尔结果。此过程系统地应用于提供的每个测试用例。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Validates a set of matrices against the properties of an adjacency matrix\n    for an undirected, loopless graph and reports consistency check results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1\n        [\n            [0, 1, 0],\n            [1, 0, 1],\n            [0, 1, 0]\n        ],\n        # Test case 2\n        [\n            [0, 2, 0],\n            [2, 1, 3],\n            [0, 3, 0]\n        ],\n        # Test case 3\n        [\n            [0, 1, 0],\n            [0, 0, 1],\n            [0, 1, 0]\n        ],\n        # Test case 4\n        [\n            [1, 1, 0],\n            [0, 0, 0],\n            [0, 0, 0]\n        ],\n        # Test case 5\n        [\n            [0.0]\n        ],\n        # Test case 6\n        [\n            [1e-12]\n        ],\n        # Test case 7 (non-square)\n        [\n            [0, 1, 0],\n            [1, 0, 1]\n        ],\n        # Test case 8\n        [\n            [0.0, 1.0000000005],\n            [1.0, 0.0]\n        ],\n        # Test case 9\n        [\n            [0.0, 1.000000002],\n            [1.0, 0.0]\n        ],\n        # Test case 10\n        [\n            [0, 2.5, 0],\n            [2.5, 0, 4.1],\n            [0, 4.1, 0]\n        ]\n    ]\n\n    epsilon = 1e-9\n    results = []\n\n    for case_data in test_cases:\n        # Convert list of lists to a NumPy array for efficient computation.\n        # Use dtype=float to handle all specified numeric types.\n        matrix = np.array(case_data, dtype=float)\n\n        # Step 1: Verify that the matrix is square (n x n with n >= 1).\n        if matrix.ndim == 2 and matrix.shape[0] == matrix.shape[1] and matrix.shape[0] >= 1:\n            is_square = True\n        else:\n            is_square = False\n\n        if not is_square:\n            # For non-square matrices, symmetry and diagonal counts are undefined.\n            results.append([False, -1, -1])\n            continue\n\n        n = matrix.shape[0]\n\n        # Step 2: Quantify diagonal violations.\n        # Count where the absolute value of a diagonal element exceeds epsilon.\n        diag_violations = np.sum(np.abs(np.diag(matrix)) > epsilon)\n\n        # Step 3: Quantify symmetry violations.\n        # For a 1x1 matrix, there are no off-diagonal elements to check.\n        if n == 1:\n            sym_violations = 0\n        else:\n            # Vectorized approach: compare upper triangle with transposed lower triangle.\n            # np.triu(matrix, k=1) gets elements above the main diagonal.\n            upper_triangle = np.triu(matrix, k=1)\n            # np.tril(matrix, k=-1).T gets elements below the main diagonal and transposes them\n            # into the upper triangle for element-wise comparison.\n            lower_triangle_transposed = np.tril(matrix, k=-1).T\n            \n            # Calculate the absolute difference and count violations.\n            diff_matrix = np.abs(upper_triangle - lower_triangle_transposed)\n            sym_violations = np.sum(diff_matrix > epsilon)\n\n        # Append the result for the current case. Cast numpy integers to standard python ints.\n        results.append([True, int(sym_violations), int(diag_violations)])\n\n    # The final print statement must match the specified single-line format.\n    # The `str` of a list adds spaces, e.g., `[True, 0, 0]`.\n    # The code `','.join(map(str, results))` joins these string representations\n    # with a comma, and the f-string wraps the whole thing in brackets.\n    # This results in a string like '[[True, 0, 0],[True, 0, 1],...]'\n    final_output_string = f\"[{','.join(map(str, results))}]\"\n    print(final_output_string)\n\nsolve()\n```"
        },
        {
            "introduction": "在网络科学中，表示方法之间的转换是一项核心技能。本练习将指导你实现一个高效的算法，将邻接矩阵转换为边列表。更重要的是，它引入了一个使用关联矩阵进行验证的步骤，从而在三种基本的网络表示方法之间建立起一个实际的联系。",
            "id": "4291946",
            "problem": "考虑一个定义在大小为 $n \\in \\mathbb{N}$ 的顶点集上的有限、简单、无向图。邻接矩阵是一个方形二元矩阵 $\\mathbf{A} \\in \\{0,1\\}^{n \\times n}$，其元素 $A_{ij} = 1$ 当且仅当顶点 $i$ 和顶点 $j$ 之间存在一条无向边，并且对于所有 $i$ 都有 $A_{ii} = 0$。对于无向图，$\\mathbf{A}$ 是对称的，即对于所有 $i,j$ 都有 $A_{ij} = A_{ji}$。边列表是表示边的无序对 $\\{i,j\\}$ 的集合；为避免重复，边可以用 $i < j$ 的形式进行规范表示。关联矩阵 $\\mathbf{B} \\in \\{0,1\\}^{n \\times m}$（其中 $m$ 是边的数量）每列对应一条边，每行对应一个顶点，其中如果顶点 $i$ 是边 $k$ 的一个端点，则 $B_{ik} = 1$，否则 $B_{ik} = 0$。\n\n从这些基础定义出发，推导出一个正确的算法，该算法通过仅扫描邻接矩阵的严格上三角部分来生成一个简单无向图的边列表。证明为什么这个过程对每条无向边恰好枚举一次，以及为什么其关于 $n$ 的时间复杂度为 $O(n^2)$。作为一项独立的正确性检验，从推导出的边列表构建关联矩阵，并用它来验证乘积 $\\mathbf{B}\\mathbf{B}^\\top$ 的非对角线元素与原始邻接矩阵 $\\mathbf{A}$ 的非对角线元素相匹配。\n\n你的程序必须为以下邻接矩阵测试套件实现此算法和验证过程，并为每个测试用例返回：\n- 布尔值，指示 $\\mathbf{A}$ 是否表示一个有效的简单无向图（即 $\\mathbf{A}$ 是对称的、对角线为零且元素在 $\\{0,1\\}$ 内），\n- 整数，找到的边的数量 $m$，\n- 整数，在严格上三角部分检查的位置数量，即 $n(n-1)/2$，\n- 布尔值，指示 $\\mathbf{B}\\mathbf{B}^\\top$ 的非对角线元素是否与 $\\mathbf{A}$ 的非对角线元素一致，\n- 以及一个以 $i < j$ 对表示的边列表。",
            "solution": "问题陈述定义明确，其科学基础根植于图论的基本原理，并为一个具体的计算任务提供了一套完整的规范。简单无向图、邻接矩阵 $\\mathbf{A}$、边列表和关联矩阵 $\\mathbf{B}$ 的定义都是标准的。所提出的 $\\mathbf{B}\\mathbf{B}^\\top$ 的非对角线元素与 $\\mathbf{A}$ 之间的关系是代数图论中的一个已知结果。因此，该问题是有效的，并且可以推导出解决方案。\n\n任务是设计并证明一个算法，用于将简单无向图的邻接矩阵表示转换为边列表，分析其计算复杂度，并通过从中间的关联矩阵表示重构邻接矩阵来执行验证步骤。\n\n**1. 边列表生成算法**\n\n一个包含 $n$ 个顶点的简单无向图由其顶点集 $V = \\{0, 1, \\dots, n-1\\}$ 和边集 $E$ 定义。邻接矩阵 $\\mathbf{A} \\in \\{0,1\\}^{n \\times n}$ 编码了连通性，其中如果顶点 $i$ 和顶点 $j$ 之间存在边，则 $A_{ij} = 1$，否则 $A_{ij} = 0$。\n\n对于无向图，$i$ 和 $j$ 之间存在边意味着双向邻接，因此 $\\mathbf{A}$ 是对称的，即 $A_{ij} = A_{ji}$。对于简单图，不存在自环，这意味着对于所有 $i \\in V$，都有 $A_{ii} = 0$。\n\n边是不同顶点的无序对 $\\{i,j\\}$。$\\mathbf{A}$ 的对称性意味着每条边 $\\{i,j\\}$ 对应于矩阵中的两个非零元素：$A_{ij}=1$ 和 $A_{ji}=1$。为了对每条边只枚举一次，我们必须采用一种约定来避免这种重复。边 $\\{i,j\\}$ 的一个规范表示是满足 $i < j$ 的有序对 $(i,j)$。这个约定将每条边唯一地映射到邻接矩阵的严格上三角部分的一个元素，即元素集合 $\\{A_{ij} \\mid 0 \\le i < j < n\\}$。\n\n这导出了以下生成边列表的算法：\n1. 初始化一个空列表 `edge_list`。\n2. 遍历所有满足 $0 \\le i < n$ 和 $i < j < n$ 的顶点索引对 $(i,j)$。\n3. 对于每对 $(i,j)$，检查矩阵元素 $A_{ij}$ 的值。\n4. 如果 $A_{ij} = 1$，则将对 $(i,j)$ 添加到 `edge_list` 中。\n\n这个过程保证了每条边都被找到并只记录一次。图中的任何边 $\\{u,v\\}$ 都对应于 $A_{uv}=1$ 和 $A_{vu}=1$。按照约定，我们可以假设 $u < v$。算法在扫描严格上三角部分时会检查元素 $A_{uv}$ 并将 $(u,v)$ 添加到列表中。对应的元素 $A_{vu}$ 位于严格下三角部分，永远不会被检查，从而防止了这条边被第二次添加。\n\n**2. 时间复杂度分析**\n\n该算法的计算成本主要取决于其在邻接矩阵中必须检查的元素数量。该过程遍历 $n \\times n$ 矩阵的严格上三角部分。此类元素的数量由以下总和给出：\n$$ \\sum_{i=0}^{n-2} (n-1-i) = (n-1) + (n-2) + \\dots + 1 = \\frac{(n-1)n}{2} $$\n这个总和的计算结果为 $\\frac{1}{2}n^2 - \\frac{1}{2}n$。由于操作次数与此数量成正比，时间复杂度由 $n$ 的最高次幂决定。因此，从邻接矩阵生成边列表的时间复杂度为 $O(n^2)$。\n\n**3. 通过关联矩阵进行验证**\n\n问题要求通过从生成的边列表构造关联矩阵 $\\mathbf{B}$ 并验证矩阵乘积 $\\mathbf{B}\\mathbf{B}^\\top$ 的一个性质来进行正确性检查。\n\n设生成的边列表为 $E = \\{e_1, e_2, \\dots, e_m\\}$，其中 $m$ 是边的总数。关联矩阵 $\\mathbf{B}$ 是一个 $n \\times m$ 的矩阵，其中如果顶点 $i$ 是边 $e_k$ 的一个端点，则元素 $B_{ik}$ 为 $1$，否则为 $0$。$\\mathbf{B}$ 的每一列对应一条边，并恰好包含两个非零元素。\n\n我们要分析乘积 $\\mathbf{C} = \\mathbf{B}\\mathbf{B}^\\top$，它是一个 $n \\times n$ 的矩阵。元素 $C_{ij}$ 是 $\\mathbf{B}$ 的第 $i$ 行和第 $j$ 行的点积：\n$$ C_{ij} = (\\mathbf{B}\\mathbf{B}^\\top)_{ij} = \\sum_{k=1}^{m} B_{ik} B_{jk} $$\n让我们分析 $\\mathbf{C}$ 的元素：\n\n*   **对角线元素 ($i=j$)**:\n    $$ C_{ii} = \\sum_{k=1}^{m} B_{ik} B_{ik} = \\sum_{k=1}^{m} B_{ik}^2 $$\n    由于 $B_{ik} \\in \\{0,1\\}$，我们有 $B_{ik}^2 = B_{ik}$。因此，\n    $$ C_{ii} = \\sum_{k=1}^{m} B_{ik} $$\n    这个和计算了与顶点 $i$ 相关联的边的数量，根据定义，这就是顶点 $i$ 的度，记作 $\\deg(i)$。\n\n*   **非对角线元素 ($i \\neq j$)**:\n    $$ C_{ij} = \\sum_{k=1}^{m} B_{ik} B_{jk} $$\n    项 $B_{ik}B_{jk}$ 非零（等于 $1$）当且仅当 $B_{ik}=1$ 和 $B_{jk}=1$ 同时成立。这个条件意味着顶点 $i$ 和顶点 $j$ 都是同一条边 $e_k$ 的端点。在一个简单图中，任意两个不同的顶点 $i$ 和 $j$ 之间最多只能有一条边连接。\n    - 如果在 $i$ 和 $j$ 之间存在一条边，设这条边为 $e_p$。那么当 $k=p$ 时，$B_{ip}B_{jp} = 1 \\times 1 = 1$。对于任何其他 $k \\neq p$ 的边 $e_k$，它不可能同时连接 $i$ 和 $j$，所以 $B_{ik}$ 或 $B_{jk}$ 中至少有一个必须为零，使得乘积 $B_{ik}B_{jk}=0$。因此 $C_{ij}$ 的总和计算结果为 $1$。\n    - 如果在 $i$ 和 $j$ 之间没有边，那么对于所有边 $e_k$，$i$ 和 $j$ 不可能同时是其端点。因此，对于所有 $k \\in \\{1, \\dots, m\\}$，乘积 $B_{ik}B_{jk}$ 都为 $0$，总和 $C_{ij}$ 的计算结果为 $0$。\n\n这表明，对于 $i \\neq j$，$C_{ij}=1$ 如果 $i$ 和 $j$ 之间有边，否则 $C_{ij}=0$。这正是邻接矩阵元素 $A_{ij}$ 的定义。因此，我们已经证实 $\\mathbf{B}\\mathbf{B}^\\top$ 的非对角线元素与原始邻接矩阵 $\\mathbf{A}$ 的相应元素相同。这为验证生成的边列表的正确性提供了一种稳健的方法。完整的关系可以简洁地表示为 $\\mathbf{B}\\mathbf{B}^\\top = \\mathbf{A} + \\mathbf{D}$，其中 $\\mathbf{D}$ 是顶点度的对角矩阵。\n\n实现将执行以下步骤：验证输入矩阵，通过扫描上三角部分生成边列表，构建关联矩阵，计算 $\\mathbf{B}\\mathbf{B}^\\top$，并将其非对角线部分与原始矩阵 $\\mathbf{A}$进行比较。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the graph representation problem for a suite of test cases.\n    \"\"\"\n\n    def process_matrix(A):\n        \"\"\"\n        Processes a single adjacency matrix according to the problem statement.\n\n        Args:\n            A (np.ndarray): The adjacency matrix.\n\n        Returns:\n            list: A list containing the results for this test case in the specified format.\n                  [is_valid, num_edges, num_inspected, recon_ok, edge_list]\n        \"\"\"\n        A = np.array(A, dtype=int)\n        \n        # Determine matrix properties\n        n = A.shape[0]\n\n        # 1. Validate the adjacency matrix\n        is_square = (A.ndim == 2 and A.shape[0] == A.shape[1])\n        is_symmetric = is_square and np.array_equal(A, A.T)\n        has_zero_diagonal = is_square and np.all(np.diag(A) == 0)\n        has_binary_entries = np.all((A == 0) | (A == 1))\n        \n        is_valid = is_symmetric and has_zero_diagonal and has_binary_entries\n\n        # 2. Generate edge list by scanning the strictly upper triangular part\n        edge_list = []\n        if n > 0:\n            for i in range(n):\n                for j in range(i + 1, n):\n                    if A[i, j] == 1:\n                        edge_list.append([i, j])\n        \n        num_edges = len(edge_list)\n        \n        # 3. Calculate the number of inspected positions\n        num_inspected = n * (n - 1) // 2 if n > 0 else 0\n\n        # 4. Verification using incidence matrix\n        recon_ok = False\n        if is_square: # Proceed with verification only if matrix is square\n            if num_edges == 0:\n                # If no edges, B is n x 0, and BB^T is the n x n zero matrix.\n                # This must match A for the reconstruction to be ok.\n                B_BT = np.zeros((n, n), dtype=int)\n            else:\n                # Construct incidence matrix B\n                B = np.zeros((n, num_edges), dtype=int)\n                for k, edge in enumerate(edge_list):\n                    i, j = edge\n                    B[i, k] = 1\n                    B[j, k] = 1\n                \n                # Calculate B * B^T\n                B_BT = B @ B.T\n            \n            # The off-diagonal entries of B * B^T should match A.\n            # We can check this by creating a copy of B*B^T, setting its\n            # diagonal to 0, and comparing with A.\n            # This works because A is required to have a zero diagonal.\n            recon_A = B_BT.copy()\n            np.fill_diagonal(recon_A, 0)\n            \n            recon_ok = np.array_equal(A, recon_A)\n\n        # Format the output for this specific case\n        # Note: edge_list must be a standard python list for correct string representation\n        return [is_valid, num_edges, num_inspected, recon_ok, edge_list]\n\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1 (n=5), sparse graph\n        [[0, 1, 0, 1, 0],\n         [1, 0, 0, 0, 1],\n         [0, 0, 0, 1, 0],\n         [1, 0, 1, 0, 0],\n         [0, 1, 0, 0, 0]],\n        \n        # Test case 2 (n=4), empty graph\n        [[0, 0, 0, 0],\n         [0, 0, 0, 0],\n         [0, 0, 0, 0],\n         [0, 0, 0, 0]],\n        \n        # Test case 3 (n=4), complete graph\n        [[0, 1, 1, 1],\n         [1, 0, 1, 1],\n         [1, 1, 0, 1],\n         [1, 1, 1, 0]],\n        \n        # Test case 4 (n=1), trivial graph\n        [[0]]\n    ]\n\n    results = [process_matrix(A) for A in test_cases]\n\n    # Format the final output string as specified\n    case_strings = []\n    for res in results:\n        # res[4] is the edge_list, which needs special formatting to remove spaces\n        edge_list_str = str(res[4]).replace(' ', '')\n        case_str = f\"[{res[0]},{res[1]},{res[2]},{res[3]},{edge_list_str}]\"\n        case_strings.append(case_str)\n\n    # Final print statement in the exact required format.\n    final_output = f\"[{','.join(case_strings)}]\"\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "真实世界的网络往往包含简单图无法捕捉的复杂性，例如自环和平行边。本练习将我们的理解扩展到多重图，要求我们构建一个精确定义的关联矩阵，以便正确地处理这些特征。这项任务突显了如何调整表示方法的定义，以保留如图顶点度这样的关键图属性。",
            "id": "4291936",
            "problem": "给定一个有限无向多重图，以边列表的形式表示，可能包含自环和平行边。设图为 $G = (V, E)$，其中 $V = \\{0,1,\\ldots,n-1\\}$ 是大小为 $n$ 的顶点集，而 $E = \\{e_0, e_1, \\ldots, e_{m-1}\\}$ 是按给定顺序排列的大小为 $m$ 的边的多重集。每条边 $e_j$ 是一个无序对 $(u_j, v_j)$，其中 $u_j, v_j \\in V$。自环是指 $u_j = v_j$ 的情况。平行边是指在 $E$ 中重复出现的无序对。\n\n基本定义：\n- 在无向多重图中，顶点 $v \\in V$ 的度定义为与 $v$ 相关联的边的端点数，其中 $v$ 上的一个自环贡献为 $2$。\n- 无向关联矩阵（Incidence Matrix, IM）$B \\in \\mathbb{Z}^{n \\times m}$ 编码了顶点和边之间的关联关系，其设计使得对每个顶点的关联求和可以恢复其度。度必须与上述基本定义一致，包括自环和平行边的每个副本的乘法贡献。\n\n任务：\n- 构建一个算法，在给定 $n$ 和边列表 $E$（允许自环和平行边）的情况下，建立关联矩阵 $B$，使得通过 $\\mathbf{d} = B \\mathbf{1}_m$ 恢复的度向量 $\\mathbf{d} \\in \\mathbb{Z}^n$ 与基本定义中陈述的度计数规则相匹配，其中 $\\mathbf{1}_m$ 表示 $m$ 维全1向量。\n- 您的算法必须指定并实现如何处理自环和平行边，以确保每个顶点的度正确性得以保持。处理方式必须与无向、非定向的关联约定一致，即每条非自环边为其两个端点各贡献一个单位的关联，而每个自环为其唯一端点贡献两个单位的关联。\n- 此外，验证 $B$ 的一个结构性质，该性质编码了平行边的重数：对于 $u \\neq v$，非对角线元素 $(B B^\\top)_{uv}$ 等于 $u$ 和 $v$ 之间的边数（即无序对 $\\{u,v\\}$ 在 $E$ 中的重数）。自环不贡献于非对角线元素。\n\n程序的输入规范：\n- 没有外部输入。请使用程序中嵌入的以下测试套件。\n\n测试套件：\n- 测试用例 1：$n = 6$，$E = [(0,1),(1,2),(2,2),(3,4),(3,4),(4,4)]$。期望度：$[1,2,3,2,4,0]$。需在 $B B^\\top$ 中检查的边对：$(3,4) \\mapsto 2$，$(0,1) \\mapsto 1$，$(1,2) \\mapsto 1$。\n- 测试用例 2：$n = 3$，$E = [(0,0),(0,0),(2,2)]$。期望度：$[4,0,2]$。需检查的边对：$(0,1) \\mapsto 0$。\n- 测试用例 3：$n = 4$，$E = []$。期望度：$[0,0,0,0]$。需检查的边对：$(0,1) \\mapsto 0$。\n- 测试用例 4：$n = 5$，$E = [(0,3),(0,3),(0,3),(1,1),(2,4)]$。期望度：$[3,2,1,3,1]$。需检查的边对：$(0,3) \\mapsto 3$，$(2,4) \\mapsto 1$，$(0,2) \\mapsto 0$。\n- 测试用例 5：$n = 2$，$E = [(0,1),(1,1)]$。期望度：$[1,3]$。需检查的边对：$(0,1) \\mapsto 1$。\n\n每个测试用例的验证标准：\n- 标准 1 (形状)：$B$ 的形状必须是 $n \\times m$。\n- 标准 2 (度正确性)：$B \\mathbf{1}_m$ 必须等于期望的度向量。\n- 标准 3 (边对重数正确性)：对于为测试用例列出的每个边对 $(u,v)$，非对角线元素 $(B B^\\top)_{uv}$ 必须等于指定的重数。\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含五个测试用例的结果，格式为方括号括起来的逗号分隔列表（例如，$[result_1,result_2,result_3,result_4,result_5]$），其中每个 $result_i$ 是一个布尔值，表示测试用例 $i$ 是否通过了所有三个验证标准。",
            "solution": "该问题要求为给定的具有 $n$ 个顶点和 $m$ 条边的多重图 $G=(V,E)$ 构建并验证其无向关联矩阵 $B$，该图可能包含自环和平行边。构建过程必须满足两个关键性质：一个度恢复性质和一个边对重数性质。\n\n设顶点集为 $V = \\{0, 1, \\ldots, n-1\\}$，边多重集为 $E = \\{e_0, e_1, \\ldots, e_{m-1}\\}$。关联矩阵 $B$ 将是一个 $n \\times m$ 的整数矩阵。元素 $B_{ij}$ 表示顶点 $i$ 与边 $j$ 的关联关系。\n\n**1. 构建关联矩阵 $B$ 的算法**\n\n$B$ 的构建由度恢复性质决定，该性质规定度向量 $\\mathbf{d}$ 必须可以通过乘积 $\\mathbf{d} = B \\mathbf{1}_m$ 恢复，其中 $\\mathbf{1}_m$ 是 $m$ 维全1列向量。顶点 $v$ 的度定义为与其相关联的边的端点数，自环为其所在顶点的度贡献 $2$。\n\n为满足此要求，我们必须定义 $B$ 中对应于每条边的列，使得 $B$ 的每一行之和等于相应顶点的度。\n\n让我们考虑一条任意边 $e_j = (u_k, v_l) \\in E$。\n\n- **情况 1：非自环边** ($u_k \\neq v_l$)。这条边有两个不同的端点，$u_k$ 和 $v_l$。它必须为 $u_k$ 的度贡献 $1$，为 $v_l$ 的度贡献 $1$。为通过乘积 $B \\mathbf{1}_m$ 实现这一点，$B$ 的第 $j$ 列之和必须为 $2$，并以每个顶点一个 $1$ 的方式分布。因此，对于 $B$ 的第 $j$ 列，我们设置 $B_{u_k, j} = 1$ 和 $B_{v_l, j} = 1$。此列中的所有其他元素，$B_{i,j}$ 对于 $i \\notin \\{u_k, v_l\\}$，均为 $0$。\n\n- **情况 2：自环边** ($u_k = v_l$)。顶点 $u_k$ 上的一个自环为其度贡献 $2$。为确保这一点，来自边 $e_j$ 的贡献必须完全集中在顶点 $u_k$ 上。因此，对于 $B$ 的第 $j$ 列，我们设置 $B_{u_k, j} = 2$。此列中的所有其他元素，$B_{i,j}$ 对于 $i \\neq u_k$，均为 $0$。\n\n这种构建方法唯一地定义了任何给定图 $G=(V, E)$ 的矩阵 $B$。算法如下：\n1. 初始化一个 $n \\times m$ 的矩阵 $B$，所有元素均设为 $0$。设 $m$ 是输入列表 $E$ 中的边数。\n2. 以索引 $j = 0, \\ldots, m-1$ 遍历边列表 $E$。对于每条边 $e_j = (u,v)$：\n   a. 如果 $u \\neq v$，则设置 $B_{u,j} = 1$ 和 $B_{v,j} = 1$。\n   b. 如果 $u = v$，则设置 $B_{u,j} = 2$。\n3. 得到的矩阵 $B$ 即为所求的关联矩阵。\n\n**2. 验证标准**\n\n**标准 1：形状正确性**\n该构建方法直接产生一个具有 $n$ 行（对应 $n$ 个顶点）和 $m$ 列（对应 $m$ 条边）的矩阵。因此形状为 $n \\times m$，满足第一个标准。一个特殊情况是当 $E$ 为空时，即 $m=0$。在这种情况下，$B$ 是一个 $n \\times 0$ 的矩阵。\n\n**标准 2：度正确性**\n顶点 $i$ 的度 $d_i$ 是向量 $\\mathbf{d} = B \\mathbf{1}_m$ 的第 $i$ 个元素。其计算方式为 $d_i = \\sum_{j=0}^{m-1} B_{i,j} \\cdot 1 = \\sum_{j=0}^{m-1} B_{i,j}$。这个和累加了每条边的贡献。根据我们的构建方法：\n- 一条与顶点 $i$ 关联的非自环边对总和贡献 $1$（因为 $B_{i,j} = 1$）。\n- 一个在顶点 $i$ 上的自环对总和贡献 $2$（因为 $B_{i,j} = 2$）。\n- 不与顶点 $i$ 关联的边贡献 $0$。\n因此，这个和是 (与 $i$ 关联的非自环边数) + $2 \\times$ (在 $i$ 上的自环数)，这正是所给定的度的定义。这证实了我们构建方法的度恢复性质的有效性。当 $m=0$ 时，度向量正确地为零向量。\n\n**标准 3：边对重数正确性**\n我们需要验证对于 $u \\neq v$，非对角线元素 $(B B^\\top)_{uv}$ 等于顶点 $u$ 和 $v$ 之间的边数。矩阵乘积 $B B^\\top$ 是一个 $n \\times n$ 的矩阵。其 $(u,v)$ 项由 $B$ 的第 $u$ 行和第 $v$ 行的点积给出：\n$$ (B B^\\top)_{uv} = \\sum_{j=0}^{m-1} B_{uj} B_{vj} $$\n让我们分析每一条边 $e_j$ 的项 $B_{uj} B_{vj}$：\n- 如果 $e_j=(p,q)$ 是一条非自环边，其在 $B$ 中对应的第 $j$ 列有两个非零项：$B_{pj}=1$ 和 $B_{qj}=1$。只有当 $\\{u, v\\} = \\{p, q\\}$ 时，乘积 $B_{uj} B_{vj}$ 才非零。在这种情况下，$B_{uj} B_{vj} = 1 \\cdot 1 = 1$。对于所有其他行对 $(u', v')$，乘积为 $0$。\n- 如果 $e_j=(p,p)$ 是一个自环，其第 $j$ 列有一个非零项：$B_{pj}=2$。由于我们考虑的是 $u \\neq v$ 的非对角线元素，所以 $B_{uj}$ 和 $B_{vj}$ 不可能同时非零。因此，$B_{uj} B_{vj} = 0$。\n\n因此，总和 $\\sum_{j=0}^{m-1} B_{uj} B_{vj}$ 对顶点 $u$ 和 $v$ 之间存在的每一条边计数为 $1$。这个总和恰好是边 $\\{u,v\\}$ 的重数。自环正确地不贡献于非对角线元素。这证实了该结构性质。当 $m=0$ 时，$B B^\\top$ 是 $n \\times n$ 的零矩阵，所有重数都正确地为 $0$。\n\n实现的算法将遵循这些原则，构建矩阵 $B$ 并为每个测试用例执行指定的数值检查。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Constructs and validates the incidence matrix for multigraphs according to the problem specification.\n    \"\"\"\n    # Test suite as defined in the problem statement.\n    # Each tuple contains:\n    # 1. n (number of vertices)\n    # 2. E (edge list)\n    # 3. expected_degrees (the ground truth degree vector)\n    # 4. pairs_to_check (a list of ((u, v), expected_multiplicity) tuples)\n    test_suite = [\n        (6, [(0, 1), (1, 2), (2, 2), (3, 4), (3, 4), (4, 4)], [1, 2, 3, 2, 4, 0], [((3, 4), 2), ((0, 1), 1), ((1, 2), 1)]),\n        (3, [(0, 0), (0, 0), (2, 2)], [4, 0, 2], [((0, 1), 0)]),\n        (4, [], [0, 0, 0, 0], [((0, 1), 0)]),\n        (5, [(0, 3), (0, 3), (0, 3), (1, 1), (2, 4)], [3, 2, 1, 3, 1], [((0, 3), 3), ((2, 4), 1), ((0, 2), 0)]),\n        (2, [(0, 1), (1, 1)], [1, 3], [((0, 1), 1)]),\n    ]\n\n    results = []\n\n    for n, E, expected_degrees, pairs_to_check in test_suite:\n        m = len(E)\n\n        # Initialize the n x m incidence matrix B with zeros.\n        # Ensure it has the correct integer type.\n        B = np.zeros((n, m), dtype=int)\n\n        # Populate the incidence matrix B based on the edge list.\n        for j, edge in enumerate(E):\n            u, v = edge\n            if u == v:  # Loop edge\n                B[u, j] = 2\n            else:  # Non-loop edge\n                B[u, j] = 1\n                B[v, j] = 1\n\n        # --- Validation ---\n        all_criteria_passed = True\n\n        # Criterion 1: Shape correctness\n        # The shape of B must be n x m.\n        if B.shape != (n, m):\n            all_criteria_passed = False\n\n        # Criterion 2: Degree correctness\n        # The calculated degree vector d = B * 1_m must match the expected degrees.\n        # numpy handles the m=0 case correctly, producing a zero vector.\n        if m > 0:\n            ones_m = np.ones(m, dtype=int)\n            calculated_degrees = B @ ones_m\n        else:\n            calculated_degrees = np.zeros(n, dtype=int)\n\n        if not np.array_equal(calculated_degrees, np.array(expected_degrees)):\n            all_criteria_passed = False\n        \n        # Criterion 3: Pair multiplicity correctness\n        # The off-diagonal entries of B * B^T must match pair multiplicities.\n        # numpy handles the m=0 case correctly, producing a zero matrix.\n        if m > 0:\n            BB_T = B @ B.T\n        else:\n            BB_T = np.zeros((n, n), dtype=int)\n\n        for (u, v), expected_multiplicity in pairs_to_check:\n            # Check (u, v) entry. Since BB_T is symmetric, (v, u) is identical.\n            if BB_T[u, v] != expected_multiplicity:\n                all_criteria_passed = False\n                break # A single failure is enough for this criterion\n        \n        results.append(all_criteria_passed)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\".replace(\"True\", \"true\").replace(\"False\", \"false\"))\n\nsolve()\n\n```"
        }
    ]
}