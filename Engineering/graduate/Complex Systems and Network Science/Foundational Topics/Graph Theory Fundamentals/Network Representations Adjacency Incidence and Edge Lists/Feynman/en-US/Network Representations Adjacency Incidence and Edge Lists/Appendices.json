{
    "hands_on_practices": [
        {
            "introduction": "The adjacency matrix is a foundational tool in network science, but its validity hinges on specific structural properties. This first practice focuses on the crucial task of data validation, translating the theoretical definitions of an undirected, loopless graph into concrete computational checks . By implementing these checks for symmetry and a zero diagonal, you will build a robust function to ensure that a given matrix is a faithful representation before using it in further analysis.",
            "id": "4291927",
            "problem": "Consider a finite graph with vertex set $V$ of size $n$, and let $A \\in \\mathbb{R}^{n \\times n}$ be a proposed adjacency matrix representation. By definition, for an undirected graph, the pairwise relationship between vertices is symmetric, and the absence of self-loops requires that no vertex is adjacent to itself. From these core definitions, it follows that a valid adjacency matrix for an undirected loopless graph must be square, symmetric, and have a zero diagonal. In computational settings with real-valued entries, approximate equality is often required due to floating-point representation; therefore a tolerance parameter $\\varepsilon > 0$ can be used to operationalize equality checks.\n\nYour task is to implement a program that, for each provided matrix, performs the following consistency checks derived from the fundamental definitions:\n- Verify that $A$ is square, that is $A \\in \\mathbb{R}^{n \\times n}$ for some integer $n \\geq 1$.\n- Quantify symmetry violations by counting the number of unordered vertex pairs $\\{i,j\\}$ with $1 \\leq i < j \\leq n$ such that $|a_{ij} - a_{ji}| > \\varepsilon$.\n- Quantify diagonal violations by counting the number of indices $i \\in \\{1,\\dots,n\\}$ such that $|a_{ii}| > \\varepsilon$.\n\nIf a matrix is not square, the symmetry and diagonal violation counts are undefined. In that case, report the squareness check as false and use the integer $-1$ for both violation counts to denote undefined values.\n\nUse the tolerance $\\varepsilon = 10^{-9}$ for all absolute-value comparisons.\n\nImplement the above logic and apply it to the following test suite of matrices. Each matrix is specified as a real-valued array; rows are listed as bracketed lists:\n- Test case $1$:\n  [\n    [0, 1, 0],\n    [1, 0, 1],\n    [0, 1, 0]\n  ]\n- Test case $2$:\n  [\n    [0, 2, 0],\n    [2, 1, 3],\n    [0, 3, 0]\n  ]\n- Test case $3$:\n  [\n    [0, 1, 0],\n    [0, 0, 1],\n    [0, 1, 0]\n  ]\n- Test case $4$:\n  [\n    [1, 1, 0],\n    [0, 0, 0],\n    [0, 0, 0]\n  ]\n- Test case $5$:\n  [\n    [0.0]\n  ]\n- Test case $6$:\n  [\n    [1e-12]\n  ]\n- Test case $7$ (non-square):\n  [\n    [0, 1, 0],\n    [1, 0, 1]\n  ]\n- Test case $8$:\n  [\n    [0.0, 1.0000000005],\n    [1.0, 0.0]\n  ]\n- Test case $9$:\n  [\n    [0.0, 1.000000002],\n    [1.0, 0.0]\n  ]\n- Test case $10$:\n  [\n    [0, 2.5, 0],\n    [2.5, 0, 4.1],\n    [0, 4.1, 0]\n  ]\n\nOutput specification:\n- For each test case, produce a list of the form $[s, c_{\\text{sym}}, c_{\\text{diag}}]$, where $s$ is a boolean indicating whether the matrix is square, $c_{\\text{sym}}$ is the integer count of symmetry violations, and $c_{\\text{diag}}$ is the integer count of diagonal violations (or $-1$ for both counts when $s$ is false).\n- Your program should produce a single line of output containing the results for all test cases as a comma-separated list enclosed in square brackets. Concretely, the output must be a single line string representation of the list of results, such as $[r_1, r_2, \\dots, r_{10}]$, where each $r_k$ is the per-test-case list described above.",
            "solution": "The objective is to validate a given matrix $A$ against the fundamental properties required for it to be an adjacency matrix of a finite, undirected, loopless graph. These properties are that the matrix must be square, symmetric, and have a zero diagonal. The validation will be performed computationally, employing a numerical tolerance $\\varepsilon = 10^{-9}$ to account for floating-point inaccuracies. For each supplied matrix, we must perform three checks: squareness, symmetry violations, and diagonal violations.\n\nLet a candidate matrix be provided as a two-dimensional array of real numbers. We denote its elements by $a_{ij}$, where $i$ is the row index and $j$ is the column index. The procedure is as follows:\n\n1.  **Squareness Verification**: An adjacency matrix represents relationships between vertices in a set $V$ of size $n$. This requires a one-to-one correspondence between the rows (or columns) of the matrix and the vertices of the graph. Consequently, the matrix must be square, i.e., have the same number of rows and columns. Let the matrix $A$ have $m$ rows and $p$ columns. For $A$ to be a valid adjacency matrix for a non-empty graph, it must satisfy $m=p$ and $n=m=p \\geq 1$. If a given matrix fails this test, it cannot be an adjacency matrix. The problem specifies that in this case, the symmetry and diagonal violation counts are undefined and should be reported as the integer $-1$. The result for a non-square matrix is thus $[\\text{False}, -1, -1]$.\n\n2.  **Symmetry Violation Quantification**: For an undirected graph, the relationship between any two vertices $i$ and $j$ is symmetric. If vertex $i$ is adjacent to vertex $j$, then vertex $j$ must be adjacent to vertex $i$. In terms of the adjacency matrix $A$, this translates to the property of symmetry: $A = A^T$, or $a_{ij} = a_{ji}$ for all pairs of indices $(i, j)$. To quantify deviations from this property in a numerical context, we count the number of unordered pairs of distinct vertices $\\{i,j\\}$ for which the corresponding matrix entries are not equal, within the given tolerance $\\varepsilon$. A symmetry violation for the pair $\\{i,j\\}$ occurs if $|a_{ij} - a_{ji}| > \\varepsilon$. We iterate over all unique pairs of indices $(i, j)$ such that $1 \\leq i < j \\leq n$ and increment a counter, $c_{\\text{sym}}$, for each pair that violates this condition. The set of indices $1 \\leq i < j \\leq n$ corresponds to the entries in the strict upper triangle of the matrix.\n\n3.  **Diagonal Violation Quantification**: A loopless graph, by definition, has no edges connecting a vertex to itself. This means that for any vertex $i$, the entry $a_{ii}$ in the adjacency matrix must be zero. Similar to the symmetry check, we use the tolerance $\\varepsilon$ to test this property. A diagonal violation for vertex $i$ occurs if its corresponding diagonal entry $a_{ii}$ has a magnitude greater than the tolerance, i.e., $|a_{ii}| > \\varepsilon$. We iterate through all diagonal entries from $i=1$ to $n$ and increment a counter, $c_{\\text{diag}}$, for each entry that violates the condition.\n\nThe overall process is to first check for squareness. If the matrix is square, we proceed to compute $c_{\\text{sym}}$ and $c_{\\text{diag}}$. The final output for a single matrix is a list $[s, c_{\\text{sym}}, c_{\\text{diag}}]$, where $s$ is the boolean result of the squareness test. This procedure is applied systematically to every test case provided.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Validates a set of matrices against the properties of an adjacency matrix\n    for an undirected, loopless graph and reports consistency check results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1\n        [\n            [0, 1, 0],\n            [1, 0, 1],\n            [0, 1, 0]\n        ],\n        # Test case 2\n        [\n            [0, 2, 0],\n            [2, 1, 3],\n            [0, 3, 0]\n        ],\n        # Test case 3\n        [\n            [0, 1, 0],\n            [0, 0, 1],\n            [0, 1, 0]\n        ],\n        # Test case 4\n        [\n            [1, 1, 0],\n            [0, 0, 0],\n            [0, 0, 0]\n        ],\n        # Test case 5\n        [\n            [0.0]\n        ],\n        # Test case 6\n        [\n            [1e-12]\n        ],\n        # Test case 7 (non-square)\n        [\n            [0, 1, 0],\n            [1, 0, 1]\n        ],\n        # Test case 8\n        [\n            [0.0, 1.0000000005],\n            [1.0, 0.0]\n        ],\n        # Test case 9\n        [\n            [0.0, 1.000000002],\n            [1.0, 0.0]\n        ],\n        # Test case 10\n        [\n            [0, 2.5, 0],\n            [2.5, 0, 4.1],\n            [0, 4.1, 0]\n        ]\n    ]\n\n    epsilon = 1e-9\n    results = []\n\n    for case_data in test_cases:\n        # Convert list of lists to a NumPy array for efficient computation.\n        # Use dtype=float to handle all specified numeric types.\n        matrix = np.array(case_data, dtype=float)\n\n        # Step 1: Verify that the matrix is square (n x n with n >= 1).\n        if matrix.ndim == 2 and matrix.shape[0] == matrix.shape[1] and matrix.shape[0] >= 1:\n            is_square = True\n        else:\n            is_square = False\n\n        if not is_square:\n            # For non-square matrices, symmetry and diagonal counts are undefined.\n            results.append([False, -1, -1])\n            continue\n\n        n = matrix.shape[0]\n\n        # Step 2: Quantify diagonal violations.\n        # Count where the absolute value of a diagonal element exceeds epsilon.\n        diag_violations = np.sum(np.abs(np.diag(matrix)) > epsilon)\n\n        # Step 3: Quantify symmetry violations.\n        # For a 1x1 matrix, there are no off-diagonal elements to check.\n        if n = 1:\n            sym_violations = 0\n        else:\n            # Vectorized approach: compare upper triangle with transposed lower triangle.\n            # np.triu(matrix, k=1) gets elements above the main diagonal.\n            upper_triangle = np.triu(matrix, k=1)\n            # np.tril(matrix, k=-1).T gets elements below the main diagonal and transposes them\n            # into the upper triangle for element-wise comparison.\n            lower_triangle_transposed = np.tril(matrix, k=-1).T\n            \n            # Calculate the absolute difference and count violations.\n            diff_matrix = np.abs(upper_triangle - lower_triangle_transposed)\n            sym_violations = np.sum(diff_matrix > epsilon)\n\n        # Append the result for the current case. Cast numpy integers to standard python ints.\n        results.append([True, int(sym_violations), int(diag_violations)])\n\n    # The final print statement must match the specified single-line format.\n    # The `str` of a list adds spaces, e.g., `[True, 0, 0]`.\n    # The code `','.join(map(str, results))` joins these string representations\n    # with a comma, and the f-string wraps the whole thing in brackets.\n    # This results in a string like '[[True, 0, 0],[True, 0, 1],...]'\n    final_output_string = f\"[{','.join(map(str, results))}]\"\n    print(final_output_string)\n\nsolve()\n```"
        },
        {
            "introduction": "Different analytical tasks are best suited to different network representations, making the ability to convert between them an essential skill. This exercise guides you through an efficient algorithm to convert an adjacency matrix $A$ into an edge list, a format often preferred for its sparse storage . As a powerful verification step, you will also explore the connection between these formats and the incidence matrix $B$ by confirming the algebraic graph theory result that links the off-diagonal entries of $B B^T$ back to $A$.",
            "id": "4291946",
            "problem": "Consider a finite, simple, undirected graph defined on a vertex set of size $n \\in \\mathbb{N}$. The adjacency matrix is a square binary matrix $\\mathbf{A} \\in \\{0,1\\}^{n \\times n}$ with entries $A_{ij} = 1$ if and only if there is an undirected edge between vertex $i$ and vertex $j$, and $A_{ii} = 0$ for all $i$. For an undirected graph, $\\mathbf{A}$ is symmetric, that is, $A_{ij} = A_{ji}$ for all $i,j$. The edge list is a collection of unordered pairs $\\{i,j\\}$ representing the edges; to avoid duplication, edges can be represented canonically with $i  j$. The incidence matrix $\\mathbf{B} \\in \\{0,1\\}^{n \\times m}$, where $m$ is the number of edges, has one column per edge and one row per vertex, with $B_{ik} = 1$ if vertex $i$ is an endpoint of edge $k$ and $B_{ik} = 0$ otherwise.\n\nStarting from these foundational definitions, derive a correct algorithm that produces the edge list of a simple, undirected graph by scanning only the strictly upper triangular part of the adjacency matrix. Justify why this procedure enumerates each undirected edge exactly once and why its time complexity in terms of $n$ is $O(n^2)$. As an independent correctness check, construct the incidence matrix from the derived edge list and use it to verify that the off-diagonal entries of the product $\\mathbf{B}\\mathbf{B}^\\top$ match those of the original adjacency matrix $\\mathbf{A}$.\n\nYour program must implement this algorithm and verification for the following test suite of adjacency matrices, and for each test case return:\n- the boolean indicating whether $\\mathbf{A}$ represents a valid simple undirected graph (that is, $\\mathbf{A}$ is symmetric, has a zero diagonal, and has entries in $\\{0,1\\}$),\n- the integer number of edges $m$ found,\n- the integer number of inspected positions in the strictly upper triangular part, which is $n(n-1)/2$,\n- the boolean indicating whether the off-diagonal entries of $\\mathbf{B}\\mathbf{B}^\\top$ coincide with those of $\\mathbf{A}$,\n- the edge list represented as a list of pairs $[i,j]$ with $ij$.\n\nUse the test suite below:\n- Test case $1$ ($n=5$), sparse graph:\n$$\n\\mathbf{A}^{(1)}=\n\\begin{bmatrix}\n0  1  0  1  0 \\\\\n1  0  0  0  1 \\\\\n0  0  0  1  0 \\\\\n1  0  1  0  0 \\\\\n0  1  0  0  0\n\\end{bmatrix}.\n$$\n- Test case $2$ ($n=4$), empty graph:\n$$\n\\mathbf{A}^{(2)}=\n\\begin{bmatrix}\n0  0  0  0 \\\\\n0  0  0  0 \\\\\n0  0  0  0 \\\\\n0  0  0  0\n\\end{bmatrix}.\n$$\n- Test case $3$ ($n=4$), complete graph:\n$$\n\\mathbf{A}^{(3)}=\n\\begin{bmatrix}\n0  1  1  1 \\\\\n1  0  1  1 \\\\\n1  1  0  1 \\\\\n1  1  1  0\n\\end{bmatrix}.\n$$\n- Test case $4$ ($n=1$), trivial graph:\n$$\n\\mathbf{A}^{(4)}=\n\\begin{bmatrix}\n0\n\\end{bmatrix}.\n$$\n\nFinal output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets with no spaces, where each element corresponds to one test case and is itself a list in the order specified above. For example, the output must have the form\n$[\\text{case}_1,\\text{case}_2,\\text{case}_3,\\text{case}_4]$\nwith each $\\text{case}_k$ rendered as $[\\text{valid},m,\\text{inspected},\\text{recon\\_ok},\\text{edge\\_list}]$ (booleans as $True$ or $False$, integers in base-$10$, and lists using square brackets).",
            "solution": "The problem statement is well-defined, scientifically grounded in the elementary principles of graph theory, and provides a complete set of specifications for a concrete computational task. The definitions of a simple undirected graph, adjacency matrix $\\mathbf{A}$, edge list, and incidence matrix $\\mathbf{B}$ are standard. The proposed relationship between the off-diagonal entries of $\\mathbf{B}\\mathbf{B}^\\top$ and $\\mathbf{A}$ is a known result in algebraic graph theory. The problem is therefore valid and a solution can be derived.\n\nThe task is to devise and justify an algorithm for converting an adjacency matrix representation of a simple, undirected graph into an edge list, analyze its computational complexity, and perform a verification step by reconstructing the adjacency matrix from an intermediate incidence matrix representation.\n\n**1. Algorithm for Edge List Generation**\n\nA simple, undirected graph on $n$ vertices is defined by its vertex set $V = \\{0, 1, \\dots, n-1\\}$ and its edge set $E$. The adjacency matrix $\\mathbf{A} \\in \\{0,1\\}^{n \\times n}$ encodes the connectivity, where $A_{ij} = 1$ if an edge exists between vertex $i$ and vertex $j$, and $A_{ij} = 0$ otherwise.\n\nFor an undirected graph, the presence of an edge between $i$ and $j$ implies adjacency in both directions, so $\\mathbf{A}$ is symmetric, i.e., $A_{ij} = A_{ji}$. For a simple graph, there are no self-loops, meaning $A_{ii} = 0$ for all $i \\in V$.\n\nAn edge is an unordered pair of distinct vertices $\\{i,j\\}$. The symmetry of $\\mathbf{A}$ means that each edge $\\{i,j\\}$ corresponds to two non-zero entries in the matrix: $A_{ij}=1$ and $A_{ji}=1$. To enumerate each edge exactly once, we must adopt a convention that avoids this duplication. A canonical representation for an edge $\\{i,j\\}$ is an ordered pair $(i,j)$ where $i  j$. This convention maps each edge to a unique entry in the strictly upper triangular part of the adjacency matrix, i.e., the set of entries $\\{A_{ij} \\mid 0 \\le i  j  n\\}$.\n\nThis leads to the following algorithm for generating the edge list:\n1. Initialize an empty list, `edge_list`.\n2. Iterate through all pairs of vertex indices $(i,j)$ such that $0 \\le i  n$ and $i  j  n$.\n3. For each pair $(i,j)$, inspect the value of the matrix entry $A_{ij}$.\n4. If $A_{ij} = 1$, add the pair $(i,j)$ to `edge_list`.\n\nThis procedure guarantees that every edge is found and recorded exactly once. Any edge $\\{u,v\\}$ in the graph corresponds to $A_{uv}=1$ and $A_{vu}=1$. By convention, we can assume $u  v$. The algorithm will inspect the entry $A_{uv}$ during its scan of the strictly upper triangular part and add $(u,v)$ to the list. The corresponding entry $A_{vu}$ is in the strictly lower triangular part and is never inspected, thus preventing the edge from being added a second time.\n\n**2. Time Complexity Analysis**\n\nThe algorithm's computational cost is dominated by the number of entries it must inspect in the adjacency matrix. The procedure iterates through the strictly upper triangular part of the $n \\times n$ matrix. The number of such entries is given by the sum:\n$$ \\sum_{i=0}^{n-2} (n-1-i) = (n-1) + (n-2) + \\dots + 1 = \\frac{(n-1)n}{2} $$\nThis sum evaluates to $\\frac{1}{2}n^2 - \\frac{1}{2}n$. Since the number of operations is proportional to this quantity, the time complexity is determined by the highest power of $n$. Therefore, the time complexity of generating the edge list from the adjacency matrix is $O(n^2)$.\n\n**3. Verification via Incidence Matrix**\n\nThe problem requires a correctness check by constructing the incidence matrix $\\mathbf{B}$ from the generated edge list and verifying a property of the matrix product $\\mathbf{B}\\mathbf{B}^\\top$.\n\nLet the generated edge list be $E = \\{e_1, e_2, \\dots, e_m\\}$, where $m$ is the total number of edges. The incidence matrix $\\mathbf{B}$ is an $n \\times m$ matrix where the entry $B_{ik}$ is $1$ if vertex $i$ is an endpoint of edge $e_k$, and $0$ otherwise. Each column of $\\mathbf{B}$ corresponds to an edge and contains exactly two non-zero entries.\n\nWe are to analyze the product $\\mathbf{C} = \\mathbf{B}\\mathbf{B}^\\top$, which is an $n \\times n$ matrix. An entry $C_{ij}$ is the dot product of the $i$-th row and the $j$-th row of $\\mathbf{B}$:\n$$ C_{ij} = (\\mathbf{B}\\mathbf{B}^\\top)_{ij} = \\sum_{k=1}^{m} B_{ik} B_{jk} $$\nLet us analyze the entries of $\\mathbf{C}$:\n\n*   **Diagonal entries ($i=j$)**:\n    $$ C_{ii} = \\sum_{k=1}^{m} B_{ik} B_{ik} = \\sum_{k=1}^{m} B_{ik}^2 $$\n    Since $B_{ik} \\in \\{0,1\\}$, we have $B_{ik}^2 = B_{ik}$. Thus,\n    $$ C_{ii} = \\sum_{k=1}^{m} B_{ik} $$\n    This sum counts the number of edges incident to vertex $i$, which is by definition the degree of vertex $i$, denoted $\\deg(i)$.\n\n*   **Off-diagonal entries ($i \\neq j$)**:\n    $$ C_{ij} = \\sum_{k=1}^{m} B_{ik} B_{jk} $$\n    The term $B_{ik}B_{jk}$ is non-zero (equal to $1$) if and only if both $B_{ik}=1$ and $B_{jk}=1$. This condition means that vertex $i$ and vertex $j$ are both endpoints of the same edge $e_k$. In a simple graph, there can be at most one edge connecting any two distinct vertices $i$ and $j$.\n    - If there is an edge between $i$ and $j$, let this edge be $e_p$. Then for $k=p$, $B_{ip}B_{jp} = 1 \\times 1 = 1$. For any other edge $e_k$ with $k \\neq p$, it cannot connect both $i$ and $j$, so at least one of $B_{ik}$ or $B_{jk}$ must be zero, making the product $B_{ik}B_{jk}=0$. The sum for $C_{ij}$ thus evaluates to $1$.\n    - If there is no edge between $i$ and $j$, then for all edges $e_k$, it is not possible for both $i$ and $j$ to be its endpoints. Thus, for all $k \\in \\{1, \\dots, m\\}$, the product $B_{ik}B_{jk}$ is $0$, and the sum $C_{ij}$ evaluates to $0$.\n\nThis shows that for $i \\neq j$, $C_{ij}=1$ if there is an edge between $i$ and $j$, and $C_{ij}=0$ otherwise. This is precisely the definition of the adjacency matrix entries $A_{ij}$. Therefore, we have confirmed that the off-diagonal entries of $\\mathbf{B}\\mathbf{B}^\\top$ are identical to the corresponding entries of the original adjacency matrix $\\mathbf{A}$. This provides a robust method for verifying the correctness of the generated edge list. The full relationship is succinctly expressed as $\\mathbf{B}\\mathbf{B}^\\top = \\mathbf{A} + \\mathbf{D}$, where $\\mathbf{D}$ is the diagonal matrix of vertex degrees.\n\nThe implementation will perform these steps: validate the input matrix, generate the edge list by scanning the upper triangle, construct the incidence matrix, compute $\\mathbf{B}\\mathbf{B}^\\top$, and compare its off-diagonal part with the original matrix $\\mathbf{A}$.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the graph representation problem for a suite of test cases.\n    \"\"\"\n\n    def process_matrix(A):\n        \"\"\"\n        Processes a single adjacency matrix according to the problem statement.\n\n        Args:\n            A (np.ndarray): The adjacency matrix.\n\n        Returns:\n            list: A list containing the results for this test case in the specified format.\n                  [is_valid, num_edges, num_inspected, recon_ok, edge_list]\n        \"\"\"\n        A = np.array(A, dtype=int)\n        \n        # Determine matrix properties\n        n = A.shape[0]\n\n        # 1. Validate the adjacency matrix\n        is_square = (A.ndim == 2 and A.shape[0] == A.shape[1])\n        is_symmetric = is_square and np.array_equal(A, A.T)\n        has_zero_diagonal = is_square and np.all(np.diag(A) == 0)\n        has_binary_entries = np.all((A == 0) | (A == 1))\n        \n        is_valid = is_symmetric and has_zero_diagonal and has_binary_entries\n\n        # 2. Generate edge list by scanning the strictly upper triangular part\n        edge_list = []\n        if n > 0:\n            for i in range(n):\n                for j in range(i + 1, n):\n                    if A[i, j] == 1:\n                        edge_list.append([i, j])\n        \n        num_edges = len(edge_list)\n        \n        # 3. Calculate the number of inspected positions\n        num_inspected = n * (n - 1) // 2 if n > 0 else 0\n\n        # 4. Verification using incidence matrix\n        recon_ok = False\n        if is_square: # Proceed with verification only if matrix is square\n            if num_edges == 0:\n                # If no edges, B is n x 0, and BB^T is the n x n zero matrix.\n                # This must match A for the reconstruction to be ok.\n                B_BT = np.zeros((n, n), dtype=int)\n            else:\n                # Construct incidence matrix B\n                B = np.zeros((n, num_edges), dtype=int)\n                for k, edge in enumerate(edge_list):\n                    i, j = edge\n                    B[i, k] = 1\n                    B[j, k] = 1\n                \n                # Calculate B * B^T\n                B_BT = B @ B.T\n            \n            # The off-diagonal entries of B * B^T should match A.\n            # We can check this by creating a copy of B*B^T, setting its\n            # diagonal to 0, and comparing with A.\n            # This works because A is required to have a zero diagonal.\n            recon_A = B_BT.copy()\n            np.fill_diagonal(recon_A, 0)\n            \n            recon_ok = np.array_equal(A, recon_A)\n\n        # Format the output for this specific case\n        # Note: edge_list must be a standard python list for correct string representation\n        return [is_valid, num_edges, num_inspected, recon_ok, edge_list]\n\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1 (n=5), sparse graph\n        [[0, 1, 0, 1, 0],\n         [1, 0, 0, 0, 1],\n         [0, 0, 0, 1, 0],\n         [1, 0, 1, 0, 0],\n         [0, 1, 0, 0, 0]],\n        \n        # Test case 2 (n=4), empty graph\n        [[0, 0, 0, 0],\n         [0, 0, 0, 0],\n         [0, 0, 0, 0],\n         [0, 0, 0, 0]],\n        \n        # Test case 3 (n=4), complete graph\n        [[0, 1, 1, 1],\n         [1, 0, 1, 1],\n         [1, 1, 0, 1],\n         [1, 1, 1, 0]],\n        \n        # Test case 4 (n=1), trivial graph\n        [[0]]\n    ]\n\n    results = [process_matrix(A) for A in test_cases]\n\n    # Format the final output string as specified\n    case_strings = []\n    for res in results:\n        # res[4] is the edge_list, which needs special formatting to remove spaces\n        edge_list_str = str(res[4]).replace(' ', '')\n        case_str = f\"[{res[0]},{res[1]},{res[2]},{res[3]},{edge_list_str}]\"\n        case_strings.append(case_str)\n\n    # Final print statement in the exact required format.\n    final_output = f\"[{','.join(case_strings)}]\"\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "Real-world networks are dynamic systems that evolve over time, and our analytical tools must be able to adapt. This final practice moves from static representations to dynamic graph maintenance, challenging you to design an incremental algorithm that keeps an adjacency matrix and an edge list synchronized during a series of edge additions and removals . The exercise emphasizes the importance of efficiency by requiring an analysis of the amortized time and space costs, a key concept in designing scalable algorithms for large, evolving networks.",
            "id": "4291956",
            "problem": "You are given a directed simple graph with vertices labeled by integers $0,1,\\dots,n-1$. The adjacency matrix $A \\in \\{0,1\\}^{n \\times n}$ encodes edges such that $A_{uv} = 1$ if and only if there is a directed edge from vertex $u$ to vertex $v$, and $A_{uv} = 0$ otherwise. An edge list $E$ is the set of ordered pairs $(u,v)$ corresponding to present edges. You must design an incremental algorithm that updates $A$ when edges are added to or removed from the edge list, and analyze amortized time and space costs under a specified cost model. The algorithm should be logically derived from the fundamental definitions of adjacency matrices and edge lists, and must operate using a unit-cost model for primitive operations as follows.\n\nAssume a Random Access Machine (RAM) model in which each of the following primitive operations has unit cost:\n- A membership query for an ordered pair $(u,v)$ in the set $E$ has cost $1$.\n- Insertion of $(u,v)$ into $E$ or deletion of $(u,v)$ from $E$ has cost $1$.\n- Writing a single cell $A_{uv} \\leftarrow b$ for $b \\in \\{0,1\\}$ has cost $1$.\n\nYour algorithm must process a sequence of $U$ update operations, each of the form \"add $(u,v)$\" or \"remove $(u,v)$\". For each update, perform exactly one membership query. If the query indicates the operation changes the edge set (i.e., adding a currently absent edge or removing a currently present edge), perform one set update (insertion or deletion) and one adjacency matrix write to keep $A$ and $E$ consistent. If the operation does not change the set (e.g., trying to add an already-present edge or remove a non-existent edge), perform no additional work beyond the membership query. Assume self-loops $(u,u)$ are permitted and treated as ordinary edges under this model.\n\nFor each test case, compute and return the following quantities:\n1. The final number of edges $|E|$ (integer).\n2. The sum of all entries of $A$, i.e., $\\sum_{u=0}^{n-1}\\sum_{v=0}^{n-1} A_{uv}$ (integer).\n3. The maximum out-degree $\\max_{u \\in \\{0,\\dots,n-1\\}} \\sum_{v=0}^{n-1} A_{uv}$ (integer).\n4. The total number of primitive time steps executed, defined as the total count of unit-cost membership queries, set updates, and adjacency writes across all updates (integer).\n5. The amortized time per update, defined as the total number of primitive time steps divided by the number of updates $U$ (float).\n6. The peak dynamic space usage above the adjacency matrix baseline, defined as the maximum cardinality of $E$ observed at any point during processing (integer).\n7. The average dynamic space usage above the adjacency matrix baseline, defined as the average cardinality of $E$ taken over the $U$ post-update states (float).\n8. A boolean indicating whether $A$ is consistent with $E$ at the end, meaning that the set of positions where $A_{uv} = 1$ is exactly equal to $E$.\n\nUse the following test suite. Vertices are labeled $0,1,\\dots,n-1$, and each operation is specified as either \"add $(u,v)$\" or \"remove $(u,v)$\".\n- Test case $1$: $n=5$ with updates\n  - add $(0,1)$, add $(1,2)$, add $(2,3)$, add $(3,4)$, add $(4,0)$, remove $(2,3)$, add $(2,3)$, add $(2,3)$, remove $(0,2)$.\n- Test case $2$: $n=4$ with updates\n  - remove $(0,0)$, remove $(1,2)$, remove $(3,1)$, remove $(2,2)$.\n- Test case $3$: $n=100$ with updates\n  - add $(0,99)$, add $(25,25)$, add $(50,51)$, add $(51,50)$, remove $(25,25)$, add $(99,0)$, remove $(52,52)$.\n- Test case $4$: $n=10$ with updates\n  - add $(0,0)$, add $(0,1)$, add $(0,2)$, add $(0,3)$, add $(0,4)$, add $(0,5)$, add $(0,6)$, add $(0,7)$, add $(0,8)$, add $(0,9)$,\n  - add $(1,0)$, add $(2,0)$, add $(3,0)$, add $(4,0)$, add $(5,0)$, add $(6,0)$, add $(7,0)$, add $(8,0)$, add $(9,0)$,\n  - remove $(0,0)$, remove $(0,1)$, remove $(5,0)$, remove $(7,0)$, remove $(0,9)$, remove $(9,0)$.\n- Test case $5$: $n=3$ with updates\n  - add $(0,0)$, add $(0,0)$, remove $(0,0)$, remove $(0,0)$, add $(1,2)$, add $(1,2)$, add $(2,1)$, remove $(1,2)$.\n\nYour program should produce a single line of output containing the results for all test cases as a comma-separated list of lists enclosed in square brackets, with each inner list containing the eight quantities in the order specified above. For example, the output format must look like $[[r^{(1)}_1,r^{(1)}_2,\\dots,r^{(1)}_8],[r^{(2)}_1,\\dots,r^{(2)}_8],\\dots]$ where $r^{(i)}_j$ denotes the $j$-th result for test case $i$. No physical units or angles are involved; all numeric responses must be given as integers, floats, or booleans, exactly as computed by the algorithm.",
            "solution": "The problem requires the design and analysis of an incremental algorithm for maintaining the consistency of an adjacency matrix $A$ and an edge list $E$ for a directed graph under a sequence of edge addition and removal operations. The analysis is performed under a specified unit-cost Random Access Machine (RAM) model.\n\nFirst, we formalize the problem's components. A directed graph is a pair $G=(V, E)$, where $V=\\{0, 1, \\dots, n-1\\}$ is a set of $n$ vertices and $E \\subseteq V \\times V$ is a set of ordered pairs representing directed edges. The problem involves two distinct representations of this graph:\n1.  The adjacency matrix, $A$, an $n \\times n$ matrix where entries are defined as:\n    $$A_{uv} = \\begin{cases} 1  \\text{if } (u,v) \\in E \\\\ 0  \\text{if } (u,v) \\notin E \\end{cases}$$\n2.  The edge list, $E$, which is explicitly maintained as a set of pairs $(u,v)$.\n\nThe algorithm starts with an empty graph, where $E$ is the empty set, $E = \\emptyset$, and $A$ is the $n \\times n$ zero matrix. It then processes a sequence of $U$ update operations. The core of the algorithm is to ensure that after each update, the property $A_{uv}=1 \\iff (u,v) \\in E$ remains true for all pairs $(u,v) \\in V \\times V$.\n\nThe algorithm for a single update operation is explicitly defined in the problem statement. Let's analyze the logic for each type of operation. Let the state before an operation be $(A, E)$ and the state after be $(A', E')$.\n\nFor an \"add $(u,v)$\" operation:\n1.  A membership query is performed to check if $(u,v) \\in E$. This has a cost of $1$ time unit.\n2.  If the query returns false (i.e., $(u,v) \\notin E$), the edge must be added. This triggers two further primitive operations:\n    a. Insertion into the edge set: $E' = E \\cup \\{(u,v)\\}$. This has a cost of $1$.\n    b. Writing to the adjacency matrix: $A'_{uv} = 1$. This has a cost of $1$.\n    The total cost for adding a new edge is $1+1+1=3$. The resulting state is $(A', E')$, where $A'$ is identical to $A$ except for $A'_{uv}=1$.\n3.  If the query returns true (i.e., $(u,v) \\in E$), the edge already exists. No change is made to the graph representations, so $E' = E$ and $A' = A$. The total cost for this redundant operation is just the cost of the initial query, which is $1$.\n\nFor a \"remove $(u,v)$\" operation:\n1.  A membership query is performed to check if $(u,v) \\in E$. This has a cost of $1$ time unit.\n2.  If the query returns true (i.e., $(u,v) \\in E$), the edge must be removed. This triggers two further primitive operations:\n    a. Deletion from the edge set: $E' = E \\setminus \\{(u,v)\\}$. This has a cost of $1$.\n    b. Writing to the adjacency matrix: $A'_{uv} = 0$. This has a cost of $1$.\n    The total cost for removing an existing edge is $1+1+1=3$. The resulting state is $(A', E')$, where $A'$ is identical to $A$ except for $A'_{uv}=0$.\n3.  If the query returns false (i.e., $(u,v) \\notin E$), the edge does not exist to be removed. No change is made, so $E' = E$ and $A' = A$. The total cost for this redundant operation is $1$.\n\nTo provide the required output quantities, we must simulate this process for each test case, tracking several metrics. Let $U$ be the total number of updates. Let $E_k$ be the edge set after the $k$-th update, for $k=1, \\dots, U$.\n\nThe eight required quantities are calculated as follows:\n1.  Final number of edges, $|E|$: This is the cardinality of the edge set $E_U$ after all $U$ updates have been processed. $|E_U|$.\n2.  Sum of all entries of $A$: Since the algorithm maintains consistency, this sum is equal to the number of edges. $\\sum_{u=0}^{n-1}\\sum_{v=0}^{n-1} A_{uv} = |E_U|$.\n3.  Maximum out-degree: The out-degree of a vertex $u$ is the number of edges originating from it, which is given by the sum of the $u$-th row of $A$: $\\text{deg}^+(u) = \\sum_{v=0}^{n-1} A_{uv}$. The maximum out-degree is $\\max_{u \\in V} \\text{deg}^+(u)$. This is calculated from the final adjacency matrix $A_U$.\n4.  Total number of primitive time steps: This is the cumulative sum of the costs of all operations performed. We maintain a running total, incrementing it by $1$ or $3$ for each of the $U$ updates, according to the logic described above. Let $T$ be this total.\n5.  Amortized time per update: This is the total time cost divided by the number of updates, $T/U$. This represents the average cost per operation over the entire sequence.\n6.  Peak dynamic space usage: The dynamic space is the size of the edge list, $|E_k|$. We track this value after each update and find the maximum observed value over the sequence: $\\max_{k=1,\\dots,U} |E_k|$.\n7.  Average dynamic space usage: This is the arithmetic mean of the edge set cardinalities over the sequence of updates: $\\frac{1}{U} \\sum_{k=1}^{U} |E_k|$.\n8.  Consistency boolean: A final check is performed to verify that the final matrix $A_U$ and edge set $E_U$ are consistent. This is true if and only if for every vertex pair $(u,v) \\in V \\times V$, the condition $(A_U)_{uv} = 1$ is equivalent to $(u,v) \\in E_U$. By construction, our algorithm ensures this, so the result should always be true.\n\nThe implementation will involve initializing an $n \\times n$ zero matrix for $A$ (using `numpy` for efficiency in matrix operations) and an empty `set` for $E$. The simulation proceeds by iterating through the list of updates for each test case, applying the specified logic, and accumulating the necessary statistics to compute the final eight--element result vector.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to process all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        # Test case 1\n        {\n            \"n\": 5,\n            \"updates\": [\n                (\"add\", (0, 1)), (\"add\", (1, 2)), (\"add\", (2, 3)),\n                (\"add\", (3, 4)), (\"add\", (4, 0)), (\"remove\", (2, 3)),\n                (\"add\", (2, 3)), (\"add\", (2, 3)), (\"remove\", (0, 2))\n            ]\n        },\n        # Test case 2\n        {\n            \"n\": 4,\n            \"updates\": [\n                (\"remove\", (0, 0)), (\"remove\", (1, 2)), \n                (\"remove\", (3, 1)), (\"remove\", (2, 2))\n            ]\n        },\n        # Test case 3\n        {\n            \"n\": 100,\n            \"updates\": [\n                (\"add\", (0, 99)), (\"add\", (25, 25)), (\"add\", (50, 51)),\n                (\"add\", (51, 50)), (\"remove\", (25, 25)), (\"add\", (99, 0)),\n                (\"remove\", (52, 52))\n            ]\n        },\n        # Test case 4\n        {\n            \"n\": 10,\n            \"updates\": [\n                (\"add\", (0, 0)), (\"add\", (0, 1)), (\"add\", (0, 2)),\n                (\"add\", (0, 3)), (\"add\", (0, 4)), (\"add\", (0, 5)),\n                (\"add\", (0, 6)), (\"add\", (0, 7)), (\"add\", (0, 8)),\n                (\"add\", (0, 9)), (\"add\", (1, 0)), (\"add\", (2, 0)),\n                (\"add\", (3, 0)), (\"add\", (4, 0)), (\"add\", (5, 0)),\n                (\"add\", (6, 0)), (\"add\", (7, 0)), (\"add\", (8, 0)),\n                (\"add\", (9, 0)), (\"remove\", (0, 0)), (\"remove\", (0, 1)),\n                (\"remove\", (5, 0)), (\"remove\", (7, 0)), (\"remove\", (0, 9)),\n                (\"remove\", (9, 0))\n            ]\n        },\n        # Test case 5\n        {\n            \"n\": 3,\n            \"updates\": [\n                (\"add\", (0, 0)), (\"add\", (0, 0)), (\"remove\", (0, 0)),\n                (\"remove\", (0, 0)), (\"add\", (1, 2)), (\"add\", (1, 2)),\n                (\"add\", (2, 1)), (\"remove\", (1, 2))\n            ]\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        n = case[\"n\"]\n        updates = case[\"updates\"]\n        U = len(updates)\n\n        # Initialize data structures and tracking variables\n        A = np.zeros((n, n), dtype=int)\n        E = set()\n        \n        total_time_steps = 0\n        cardinality_history = []\n        peak_space = 0\n\n        for op, edge in updates:\n            u, v = edge\n            \n            # 1. Membership query (cost = 1)\n            total_time_steps += 1\n            is_present = edge in E\n\n            if op == \"add\":\n                if not is_present:\n                    # 2. Set insertion (cost = 1)\n                    total_time_steps += 1\n                    E.add(edge)\n                    \n                    # 3. Adjacency matrix write (cost = 1)\n                    total_time_steps += 1\n                    A[u, v] = 1\n            elif op == \"remove\":\n                if is_present:\n                    # 2. Set deletion (cost = 1)\n                    total_time_steps += 1\n                    E.remove(edge)\n\n                    # 3. Adjacency matrix write (cost = 1)\n                    total_time_steps += 1\n                    A[u, v] = 0\n\n            # Track space usage after each update\n            current_cardinality = len(E)\n            cardinality_history.append(current_cardinality)\n            if current_cardinality > peak_space:\n                peak_space = current_cardinality\n\n        # Calculate final quantities\n        # 1. Final number of edges\n        final_num_edges = len(E)\n\n        # 2. Sum of all entries of A\n        sum_A = np.sum(A)\n\n        # 3. Maximum out-degree\n        if n > 0:\n            max_out_degree = np.max(np.sum(A, axis=1))\n        else:\n            max_out_degree = 0\n\n        # 4. Total number of primitive time steps (already calculated)\n\n        # 5. Amortized time per update\n        if U > 0:\n            amortized_time = total_time_steps / U\n        else:\n            amortized_time = 0.0\n\n        # 6. Peak dynamic space usage (already calculated)\n\n        # 7. Average dynamic space usage\n        if U > 0:\n            avg_space = sum(cardinality_history) / U\n        else:\n            avg_space = 0.0\n            \n        # 8. Consistency boolean\n        is_consistent = True\n        for r in range(n):\n            for c in range(n):\n                if (A[r, c] == 1) != ((r, c) in E):\n                    is_consistent = False\n                    break\n            if not is_consistent:\n                break\n        \n        case_results = [\n            int(final_num_edges),\n            int(sum_A),\n            int(max_out_degree),\n            int(total_time_steps),\n            float(amortized_time),\n            int(peak_space),\n            float(avg_space),\n            is_consistent\n        ]\n        all_results.append(case_results)\n\n    # Format the final output string\n    result_str = \"[\" + \",\".join([str(res) for res in all_results]) + \"]\"\n    print(result_str.replace(\" \", \"\"))\n\nsolve()\n```"
        }
    ]
}