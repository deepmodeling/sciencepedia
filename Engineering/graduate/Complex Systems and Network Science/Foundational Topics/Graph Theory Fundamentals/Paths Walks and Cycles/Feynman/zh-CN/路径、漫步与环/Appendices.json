{
    "hands_on_practices": [
        {
            "introduction": "一个网络最基本的循环属性是其长度。最短循环的长度，即“围长”（girth），是衡量网络结构的一个关键指标，例如它关系到网络中的局部聚类程度。这项练习将指导你使用广度优先搜索（BFS）来动手计算一个图的围长，从而将循环的抽象定义与一个高效的实用算法联系起来 。",
            "id": "4296170",
            "problem": "设 $G=(V,E)$ 是一个有限、简单、无向图。途径（walk）是一个顶点的有限序列，其中相邻顶点是邻接的；路径（path）是所有顶点都不同的途径；环（cycle）是除首尾顶点外所有顶点都不同的闭合途径。$G$ 的围长（girth），记作 $g(G)$，定义为 $G$ 中最短环的长度。如果 $G$ 没有环，其围长通常取为 $+\\infty$，但在本问题中，此种情况必须报告值 $0$。\n\n您的任务是实现一个完整的程序，使用一种基于广度优先搜索（BFS; Breadth-First Search）分层和弦检测的方法，为提供的测试套件中的每个图计算 $g(G)$。该方法必须遵循以下纲要：\n\n- 对于每条无向边 $e=\\{u,v\\}\\in E$，将 $e$ 视为一个预期的弦（chord），它与连接 $u$ 和 $v$ 的一条路径结合以闭合一个环。从一个端点使用 BFS 分层，检测连接两个端点的最短路径，同时刻意忽略对 $e$ 本身的遍历以避免平凡路径。将这样一条路径的存在解释为证明了由该路径与 $e$ 共同构成的一个环，并记录其长度。在所有边中，返回该环长的最小值为围长。\n- 如果对于任何边都没有检测到环，则报告围长为 $0$。\n\n您必须实现这种 BFS 与弦检测相结合的方法，不得借助任何快捷公式；程序必须仅依赖于途径、路径、环的核心定义，以及 BFS 在无权图中发现最短路径的性质。\n\n测试套件规范。对于每个测试用例，图由其顶点集和无向边集给出。所有图都是有限且简单的。\n\n- 测试用例 1：$V=\\{\\,0,1,2\\,\\}$，$E=\\{\\,\\{0,1\\},\\{1,2\\},\\{2,0\\}\\,\\}$。\n- 测试用例 2：$V=\\{\\,0,1,2,3\\,\\}$，$E=\\{\\,\\{0,1\\},\\{1,2\\},\\{2,3\\},\\{3,0\\}\\,\\}$。\n- 测试用例 3：$V=\\{\\,0,1,2,3\\,\\}$，$E=\\{\\,\\{0,1\\},\\{1,2\\},\\{2,3\\}\\,\\}$。\n- 测试用例 4：$V=\\{\\,0,1,2,3,4,5\\,\\}$，$E=\\{\\,\\{0,1\\},\\{1,2\\},\\{2,0\\},\\{2,3\\},\\{3,4\\},\\{4,5\\}\\,\\}$。该图不连通；一个连通分量包含一个三角形。\n- 测试用例 5：$V=\\{\\,0,1,2,3,4,5\\,\\}$，$E=\\{\\,\\{0,1\\},\\{1,2\\},\\{3,4\\},\\{4,5\\},\\{0,3\\},\\{1,4\\},\\{2,5\\}\\,\\}$。\n\n必需的输出。您的程序应生成单行输出，其中包含五个测试用例的结果，格式为方括号括起来的逗号分隔列表。每个条目必须是一个整数：边的数量表示的围长，无环图报告为 $0$，按上述测试用例的顺序汇总。例如，输出格式必须是形如“[x1,x2,x3,x4,x5]”的单行，其中每个 $x_i$ 是为测试用例 $i$ 计算出的围长。",
            "solution": "问题要求计算给定有限、简单、无向图 $G=(V,E)$ 的围长 $g(G)$。围长定义为 $G$ 中最短环的长度。按照惯例，如果 $G$ 是无环的（不包含任何环），其围长为 $+\\infty$；然而，问题规定在这种情况下必须报告值 $0$。解决方案必须遵循一种基于广度优先搜索（BFS）和弦检测的指定算法。\n\n该算法的基本原理如下：图 $G$ 中的任何环都可以看作是一条边 $\\{u,v\\} \\in E$ 作为“弦”，闭合了其端点 $u$ 和 $v$ 之间的一条路径。这样一个环的长度是路径长度加上闭合边的长度，即 $1$。为了找到可能的最短环，我们必须找到某条边的两个端点之间的最短路径。设此路径长度为 $d$。相应的环长度将为 $d+1$。图的围长 $g(G)$ 将是通过将 $E$ 中的每条边都视为潜在的弦而找到的此类环长度的最小值。\n\n更正式地，对于任何边 $e=\\{u,v\\} \\in E$，包含 $e$ 的最短环由 $e$ 本身以及在子图 $G' = (V, E \\setminus \\{e\\})$ 中 $u$ 和 $v$ 之间的最短路径构成。设此最短路径的长度表示为 $d_{G'}(u,v)$。这个环的长度则为 $d_{G'}(u,v) + 1$。整个图 $G$ 的围长是所有边对应值的最小值：\n$$ g(G) = \\min_{\\{u,v\\} \\in E} \\left( d_{G'}(u,v) + 1 \\right) $$\n如果对于某条边 $\\{u,v\\}$，在 $G'$ 中 $u$ 和 $v$ 之间不存在路径，则 $d_{G'}(u,v) = +\\infty$。如果所有边都如此，则该图是无环的。\n\n算法流程如下：\n1. 初始化一个变量 $g_{\\min}$ 用于记录找到的最小环长度，其初始值为代表无穷大的值，例如 $g_{\\min} \\leftarrow +\\infty$。\n2. 根据给定的顶点集 $V$ 和边集 $E$ 构建图 $G$ 的邻接表表示。\n3. 遍历 $E$ 中的每条边 $\\{u,v\\}$。对于每条边，执行以下步骤计算包含该边的最短环的长度：\n    a. 我们需要在图 $G' = (V, E \\setminus \\{\\{u,v\\}\\})$ 中找到最短路径距离 $d_{G'}(u,v)$。这可以通过运行广度优先搜索（BFS）来完成，该算法保证能在无权图中找到最短路径。\n    b. 在图 $G$ 中从 $u$ 开始的标准 BFS 会立即找到 $v$ 作为一个距离为 1 的邻居，这对应于遍历边 $\\{u,v\\}$ 本身。为了强制在 $G'$ 内搜索，我们必须“刻意忽略”这次遍历。这通过修改 BFS 的初始化来实现。\n    c. 我们不只将源顶点 $u$ 放入队列，而是从 $u$ 的所有邻居（除了 $v$）开始搜索。设 $N(u)$ 为 $u$ 的邻居集合。BFS 队列用所有顶点 $w \\in N(u) \\setminus \\{v\\}$ 进行初始化。每个这样的顶点 $w$ 都以初始路径长度 1 被添加到队列中。我们还将 $u$ 和所有这些初始邻居标记为已访问，以防止 BFS 树中出现环。\n    d. 随后 BFS 以其标准方式进行，逐层探索图。当到达目标顶点 $v$ 时终止。记录的 $v$ 的距离，我们称之为 $d_{\\text{path}}$，即为 $G'$ 中从 $u$ 到 $v$ 的最短路径长度。\n    e. 如果 BFS 完成时未到达 $v$，则不存在其他路径，我们继续处理下一条边。\n    f. 如果找到了长度为 $d_{\\text{path}}$ 的路径，这对应一个长度为 $d_{\\text{path}} + 1$ 的环。我们更新找到的最小长度：$g_{\\min} \\leftarrow \\min(g_{\\min}, d_{\\text{path}} + 1)$。\n4. 遍历完 $E$ 中的所有边后，如果 $g_{\\min}$ 仍为其初始值 $+\\infty$，则表示没有找到环。在这种情况下，函数返回 $0$。否则，它返回计算出的 $g_{\\min}$ 值作为图的围长。\n\n该方法系统地检查与每条边相关的所有最小环，并利用 BFS 在无权图中寻找最短路径的特性，正确地确定全局最小值，即围长。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport collections\n\ndef solve():\n    \"\"\"\n    Main solver function to compute the girth for all test cases.\n    \"\"\"\n    # Test suite specification.\n    test_cases = [\n        # Test case 1: A triangle graph\n        {\"V\": {0, 1, 2}, \"E\": [{0, 1}, {1, 2}, {2, 0}]},\n        # Test case 2: A square graph (4-cycle)\n        {\"V\": {0, 1, 2, 3}, \"E\": [{0, 1}, {1, 2}, {2, 3}, {3, 0}]},\n        # Test case 3: A path graph (acyclic)\n        {\"V\": {0, 1, 2, 3}, \"E\": [{0, 1}, {1, 2}, {2, 3}]},\n        # Test case 4: A disconnected graph with a triangle component\n        {\"V\": {0, 1, 2, 3, 4, 5}, \"E\": [{0, 1}, {1, 2}, {2, 0}, {2, 3}, {3, 4}, {4, 5}]},\n        # Test case 5: A prism graph (girth is 4)\n        {\"V\": {0, 1, 2, 3, 4, 5}, \"E\": [{0, 1}, {1, 2}, {3, 4}, {4, 5}, {0, 3}, {1, 4}, {2, 5}]}\n    ]\n\n    results = []\n    for case in test_cases:\n        vertices = case[\"V\"]\n        # Convert set of sets to a list of tuples for easier iteration\n        edges = [tuple(e) for e in case[\"E\"]]\n        girth = _calculate_girth(vertices, edges)\n        results.append(girth)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef _calculate_girth(vertices, edges):\n    \"\"\"\n    Calculates the girth of a graph using a BFS-based approach for each edge.\n    \n    Args:\n        vertices (set): The set of vertices in the graph.\n        edges (list of tuples): The list of edges in the graph.\n        \n    Returns:\n        int: The girth of the graph, or 0 if the graph is acyclic.\n    \"\"\"\n    if not edges:\n        return 0\n\n    adj = {v: [] for v in vertices}\n    for u, v_node in edges:\n        adj[u].append(v_node)\n        adj[v_node].append(u)\n\n    min_cycle_len = float('inf')\n\n    for u, v in edges:\n        # We perform a BFS to find the shortest path from u to v\n        # in the graph G' = G - {u, v}.\n        \n        distances = {node: -1 for node in vertices}\n        q = collections.deque()\n\n        # Initialize BFS from u, but do not traverse the edge {u, v}.\n        # This is done by adding all neighbors of u, except for v,\n        # to the queue as the starting points of the search.\n        distances[u] = 0\n        for neighbor in adj[u]:\n            if neighbor != v:\n                distances[neighbor] = 1\n                q.append((neighbor, 1))\n\n        path_found = False\n        path_len = -1\n        \n        while q:\n            current_node, dist = q.popleft()\n\n            if current_node == v:\n                path_len = dist\n                path_found = True\n                break # Found the shortest path, no need to search further for this edge\n\n            for neighbor in adj[current_node]:\n                if distances[neighbor] == -1:\n                    distances[neighbor] = dist + 1\n                    q.append((neighbor, dist + 1))\n        \n        if path_found:\n            cycle_len = path_len + 1\n            min_cycle_len = min(min_cycle_len, cycle_len)\n    \n    if min_cycle_len == float('inf'):\n        return 0\n    else:\n        return int(min_cycle_len)\n\nsolve()\n```"
        },
        {
            "introduction": "在识别最短循环之后，一个更普遍的问题是检测和计数网络中所有的简单循环。这项练习将对比两种强大的方法：一种是通过深度优先搜索（DFS）进行精确枚举，另一种是利用邻接矩阵的幂进行代数估算。通过实现这两种方法，你将更深刻地理解简单循环与更一般的闭路（closed walk）之间的关键区别 。",
            "id": "4296197",
            "problem": "考虑一个包含 $n$ 个标记顶点 $\\{0,1,\\dots,n-1\\}$ 的有限有向图，其二元邻接矩阵为 $A \\in \\{0,1\\}^{n \\times n}$，其中当且仅当存在一条从顶点 $i$ 到顶点 $j$ 的有向边时，$A_{ij} = 1$，否则 $A_{ij} = 0$。请使用以下基本依据：\n\n- 有向漫步的定义：一个顶点序列 $(v_0, v_1, \\dots, v_k)$，满足对于所有 $t \\in \\{0,1,\\dots,k-1\\}$ 都有 $A_{v_{t} v_{t+1}} = 1$。\n- 代数图论中一个经过充分检验的事实：对于任意整数 $k \\ge 1$，$A^k$ 的 $(i,j)$ 元等于从 $i$ 到 $j$ 的长度为 $k$ 的有向漫步的数量。特别地，$\\operatorname{tr}(A^k) = \\sum_{i=0}^{n-1} (A^k)_{ii}$ 等于从同一顶点出发并返回的长度为 $k$ 的闭合漫步的数量。\n\n长度为 $k$ 的简单有向环是一个长度为 $k$ 的闭合有向漫步，它恰好访问 $k$ 个不同的顶点一次，除了起点/终点的重复。您的任务是设计一个算法，通过计算 $A$ 的幂的迹来检测是否存在至少一个长度有界的简单有向环（长度不大于 $k$），并对使用迹进行计数时可能出现的假阳性（由闭合漫步中的回溯和重复顶点引起）进行推理和实证说明。\n\n您的任务包括：\n\n- 基于上述第一性原理，推导出一个检测规则，用于判断是否存在长度至多为 $k$ 的简单有向环，该规则使用 $\\operatorname{tr}(A^\\ell)$，其中 $\\ell \\in \\{1,2,\\dots,k\\}$。\n- 基于 $A$ 的幂的迹，定义一个关于长度至多为 $k$ 的简单有向环数量的整数值上界。\n- 通过深度优先搜索（DFS）实现一个精确的枚举程序，该程序通过直接强制执行顶点不重复和使用规范化规则来避免旋转重复，从而计算长度至多为 $k$ 的简单有向环的数量，并将其与您基于迹的上界进行比较，以通过实证揭示由回溯和重复顶点引起的假阳性的大小。\n\n您必须实现一个单一程序，对于每个测试用例，返回两个整数：基于迹的上界（使用向上取整函数取整以确保其为上界）和长度至多为 $k$ 的简单有向环的精确枚举计数。最终输出必须将所有测试用例的结果聚合为一行，格式为方括号内以逗号分隔的列表。\n\n测试套件（每个测试用例提供一个邻接矩阵 $A$ 和一个界限 $k$）：\n\n- 测试用例 1：$A$ 是顶点 $\\{0,1,2\\}$ 上的有向 $3$-环，边为 $(0 \\to 1)$、$(1 \\to 2)$、$(2 \\to 0)$，即\n  $$\n  A = \\begin{pmatrix}\n  0  1  0 \\\\\n  0  0  1 \\\\\n  1  0  0\n  \\end{pmatrix},\n  $$\n  且 $k = 3$。\n- 测试用例 2：$A$ 是顶点 $\\{0,1\\}$ 上的有向 $2$-环，边为 $(0 \\to 1)$、$(1 \\to 0)$，即\n  $$\n  A = \\begin{pmatrix}\n  0  1 \\\\\n  1  0\n  \\end{pmatrix},\n  $$\n  且 $k = 4$。\n- 测试用例 3：$A$ 是一个 $3$-顶点图，在顶点 $0$ 处有一个自环，并含有一个有向 $3$-环 $(0 \\to 1 \\to 2 \\to 0)$，即\n  $$\n  A = \\begin{pmatrix}\n  1  1  0 \\\\\n  0  0  1 \\\\\n  1  0  0\n  \\end{pmatrix},\n  $$\n  且 $k = 3$。\n- 测试用例 4：$A$ 是一个有向无环图（DAG），为 $\\{0,1,2,3\\}$ 上的链，边为 $(0 \\to 1)$、$(1 \\to 2)$、$(2 \\to 3)$，即\n  $$\n  A = \\begin{pmatrix}\n  0  1  0  0 \\\\\n  0  0  1  0 \\\\\n  0  0  0  1 \\\\\n  0  0  0  0\n  \\end{pmatrix},\n  $$\n  且 $k = 4$。\n- 测试用例 5：$A$ 是一个 $5$-顶点图，由一个有向 $3$-环 $(0 \\to 1 \\to 2 \\to 0)$ 和一个不相交的有向 $2$-环 $(3 \\to 4 \\to 3)$ 组成，即\n  $$\n  A = \\begin{pmatrix}\n  0  1  0  0  0 \\\\\n  0  0  1  0  0 \\\\\n  1  0  0  0  0 \\\\\n  0  0  0  0  1 \\\\\n  0  0  0  1  0\n  \\end{pmatrix},\n  $$\n  且 $k = 3$。\n\n答案规范：\n\n- 对于每个测试用例，计算基于迹的上界\n  $$\n  U_k \\equiv \\left\\lceil \\sum_{\\ell=1}^{k} \\frac{\\operatorname{tr}(A^\\ell)}{\\ell} \\right\\rceil,\n  $$\n  并使用带有顶点不重复和规范化规则（确保每个环只计数一次）的 DFS 计算长度至多为 $k$ 的简单有向环的精确数量 $E_k$。\n- 您的程序应生成单行输出，其中包含一个方括号内的逗号分隔列表，按测试用例排序，每个测试用例先包含 $U_k$ 再包含 $E_k$。例如，输出格式必须为\n  $$\n  [U_1,E_1,U_2,E_2,U_3,E_3,U_4,E_4,U_5,E_5].\n  $$\n- 所有输出均为无单位的整数。\n\n该问题纯粹是数学和算法问题，需要基于所提供的基本定义和事实进行严谨的推理。不涉及物理单位、角度单位或百分比单位。所选的测试用例旨在覆盖：包含单个简单环的一般情况、多次遍历导致迹计数膨胀的情况、包含自环和环的情况、无环图的边界情况以及包含多个环的情况。",
            "solution": "该问题要求推导一种基于迹的方法来检测和限定简单有向环的数量，并实现一个精确的枚举算法进行比较。解决方案分为两部分：基于迹的方法的理论推导和精确计数方法的算法设计。\n\n### 第 1 部分：基于迹的环检测和上界\n\n该方法的基础是代数图论中的一个事实：矩阵幂 $A^k$ 的 $(i,j)$ 元给出了从顶点 $i$ 到顶点 $j$ 的长度为 $k$ 的不同有向漫步的数量。因此，$A^k$ 的迹，记为 $\\operatorname{tr}(A^k) = \\sum_{i=0}^{n-1} (A^k)_{ii}$，给出了图中长度为 $k$ 的闭合有向漫步的总数。\n\n长度为 $\\ell$ 的简单有向环是一种特殊的长度为 $\\ell$ 的闭合漫步，其中除起点和终点重合外，所有顶点都是不同的。一个关键的观察是，任何闭合漫步都必须至少包含一个简单环。要理解这一点，考虑一个闭合漫步 $W=(v_0, v_1, \\dots, v_\\ell=v_0)$。如果 $W$ 不是简单的，则序列 $v_0, \\dots, v_{\\ell-1}$ 中至少有一个顶点是重复的。设对于某个 $0 \\le i  j  \\ell$ 有 $v_i = v_j$。那么，子漫步 $(v_i, v_{i+1}, \\dots, v_j)$ 是一个更短的闭合漫步。这个简化过程可以重复应用，直到找到一个没有重复中间顶点的闭合漫步，根据定义，这就是一个简单环。由此产生的简单环的长度最多为原始漫步的长度。\n\n**检测规则：**\n基于上述推理，存在长度为 $\\ell \\in \\{1, 2, \\dots, k\\}$ 的闭合漫步意味着存在一个长度至多为 $\\ell$ 的简单有向环。长度至多为 $k$ 的闭合漫步总数由 $\\sum_{\\ell=1}^k \\operatorname{tr}(A^\\ell)$ 给出。因此，一个稳健的检测规则如下：当且仅当 $\\sum_{\\ell=1}^k \\operatorname{tr}(A^\\ell) > 0$ 时，存在长度至多为 $k$ 的简单有向环。任何幂次 $\\ell \\ge 1$ 的非零迹都表示存在闭合漫步，从而保证了简单环的存在。\n\n**上界推导：**\n问题提供了公式 $U_k \\equiv \\left\\lceil \\sum_{\\ell=1}^{k} \\frac{\\operatorname{tr}(A^\\ell)}{\\ell} \\right\\rceil$ 作为长度至多为 $k$ 的简单有向环数量的上界。我们来分析其组成部分。\n一个长度为 $\\ell$ 的简单环可以表示为 $\\ell$ 个不同的闭合漫步，每个漫步从其 $\\ell$ 个顶点之一开始。例如，环 $(v_0 \\to v_1 \\to \\dots \\to v_{\\ell-1} \\to v_0)$ 产生了闭合漫步 $(v_0, \\dots, v_0)$，$(v_1, \\dots, v_1)$ 等等。所有这 $\\ell$ 个漫步都计入 $\\operatorname{tr}(A^\\ell)$ 中。将 $\\operatorname{tr}(A^\\ell)$ 除以 $\\ell$ 是为了尝试将这个环本身只计数一次。\n\n然而，$\\operatorname{tr}(A^\\ell)$ 也包括了来自非简单闭合漫步的贡献，这些贡献是“假阳性”的来源，并导致该方法成为一个上界而非精确计数。这些非简单漫步包括：\n1.  **复合漫步：** 将一个长度为 $d$（其中 $d$ 整除 $\\ell$）的简单环遍历总共 $\\ell/d$ 次。例如，一个 $2$-环遍历两次是一个长度为 $4$ 的闭合漫步。\n2.  **带有偏移或回溯的漫步：** 一种离开一个顶点，沿着一条路径行进，然后返回的漫步。例如，$i \\to j \\to i$ 是一个长度为 $2$ 的闭合漫步，但仅当 $i \\ne j$ 时才构成一个简单的 $2$-环。\n\n因此，公式 $\\sum_{\\ell=1}^{k} \\frac{\\operatorname{tr}(A^\\ell)}{\\ell}$ 对所有长度至多为 $k$ 的环的估计值进行了求和。由于每一项 $\\frac{\\operatorname{tr}(A^\\ell)}{\\ell}$ 都多算了或正确计算了长度为 $\\ell$ 的简单环，总和是对长度至多为 $k$ 的简单环真实数量的高估。应用向上取整函数 $\\lceil \\cdot \\rceil$ 是为了确保最终的上界是一个整数。\n\n为了计算给定邻接矩阵 $A$ 和界限 $k$ 的 $U_k$，我们从 $1$ 到 $k$ 遍历 $\\ell$。在每次迭代中，我们使用矩阵幂运算计算 $A^\\ell$，求其迹 $\\operatorname{tr}(A^\\ell)$，除以 $\\ell$，并累加结果。最终的总和向上取整到最近的整数。\n\n### 第 2 部分：使用深度优先搜索（DFS）进行精确枚举\n\n为了获得简单有向环的精确计数 $E_k$，我们必须显式地枚举它们。深度优先搜索（DFS）是在图中探索路径的一种自然算法选择。其核心思想是，从每个顶点出发，找到所有能返回该顶点的简单路径，从而形成一个环。\n\n该算法的结构如下：\n1.  **图表示：** 将邻接矩阵 $A$ 转换为邻接表，以便在遍历过程中高效地查找邻居。\n2.  **遍历起始顶点：** 从图中的每个顶点 $s \\in \\{0, 1, \\dots, n-1\\}$ 开始搜索。这确保能发现所有可能的环。\n3.  **DFS 遍历：** 对每个 `start_node` $s$ 执行一次递归 DFS。DFS 函数维护当前 `path`（一个顶点列表）和一个 `visited` 集合，用于 O(1) 复杂度的检查，以强制执行“简单”约束（无重复顶点）。\n    - 递归从当前顶点 $u$ 进行到其邻居 $v$。\n    - 如果邻居 $v$ 与 `start_node` 相同，则找到了一个环。该环的长度是当前 `path` 中的顶点数。\n    - 如果邻居 $v$ 在当前 `path` 中未被访问过，则从 $v$ 继续递归进行 DFS，将 $v$ 添加到 `path` 和 `visited` 集合中。递归调用返回后，移除 $v$（回溯）以允许探索其他路径。\n4.  **长度约束：** 对搜索进行剪枝。如果扩展路径会使其长度超过允许的最大环长度 $k$，则停止递归。\n5.  **规范化和计数：** 一个长度为 $\\ell$ 的简单环将被发现 $\\ell$ 次，每次以其一个顶点作为 `start_node`。为了对每个唯一的环只计数一次，我们使用一种规范表示。一个方便的选择是环中顶点的排序元组。例如，路径 `[0, 1, 2]`、`[1, 2, 0]` 和 `[2, 0, 1]` 都对应于同一个 $3$-环。它们的规范表示将是 `(0, 1, 2)`。这些规范形式存储在一个 `set` 中以自动丢弃重复项。\n6.  **最终计数：** 长度至多为 $k$ 的简单环的精确数量，记为 $E_k$，是这个规范表示集合的最终大小。\n\n这种基于 DFS 的方法通过直接强制执行简单环的定义并采用规范化规则来防止因旋转对称性而导致的重复计数，从而保证了精确的计数。$U_k$ 和 $E_k$ 的比较将通过实证展示基于迹的方法固有的高估问题。",
            "answer": "```python\nimport numpy as np\nimport math\n\ndef calculate_trace_bound(A, k):\n    \"\"\"\n    Calculates the trace-based upper bound Uk for simple cycles of length up to k.\n    Uk = ceil(sum_l=1^k (tr(A^l) / l))\n    \"\"\"\n    total_trace_term = 0.0\n    for l in range(1, k + 1):\n        # Use numpy's verified matrix power function for robustness\n        A_power = np.linalg.matrix_power(A.astype(np.float64), l)\n        trace_val = np.trace(A_power)\n        total_trace_term += trace_val / l\n    return math.ceil(total_trace_term)\n\ndef find_exact_cycles(A, k):\n    \"\"\"\n    Finds the exact number of simple directed cycles of length up to k using DFS.\n    \"\"\"\n    n = A.shape[0]\n    adj = {i: [j for j, connected in enumerate(row) if connected] for i, row in enumerate(A)}\n    found_cycles = set()\n\n    for start_node in range(n):\n        # The path starts with the start_node\n        path = [start_node]\n        # Visited set for O(1) lookups\n        visited = {start_node}\n        dfs_recursive(start_node, start_node, path, visited, k, adj, found_cycles)\n        \n    return len(found_cycles)\n\ndef dfs_recursive(start_node, u, path, visited, max_len, adj, found_cycles):\n    \"\"\"\n    Recursive DFS helper function to find simple cycles.\n    \"\"\"\n    path_len = len(path)\n\n    # Explore neighbors of the current node u\n    for v in adj.get(u, []):\n        # A cycle is found if the neighbor is the start_node.\n        # The cycle length is path_len.\n        if v == start_node:\n            if path_len = max_len:\n                # Canonical form is the sorted tuple of vertices to count each cycle once\n                canonical_form = tuple(sorted(path))\n                found_cycles.add(canonical_form)\n        \n        # If neighbor is not visited and path is not too long, continue the path\n        elif v not in visited:\n            if path_len  max_len:\n                visited.add(v)\n                path.append(v)\n                dfs_recursive(start_node, v, path, visited, max_len, adj, found_cycles)\n                path.pop()\n                visited.remove(v)\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        # Test case 1\n        (np.array([[0, 1, 0], [0, 0, 1], [1, 0, 0]]), 3),\n        # Test case 2\n        (np.array([[0, 1], [1, 0]]), 4),\n        # Test case 3\n        (np.array([[1, 1, 0], [0, 0, 1], [1, 0, 0]]), 3),\n        # Test case 4\n        (np.array([[0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1], [0, 0, 0, 0]]), 4),\n        # Test case 5\n        (np.array([\n            [0, 1, 0, 0, 0],\n            [0, 0, 1, 0, 0],\n            [1, 0, 0, 0, 0],\n            [0, 0, 0, 0, 1],\n            [0, 0, 0, 1, 0]\n        ]), 3),\n    ]\n\n    results = []\n    for A, k in test_cases:\n        U_k = calculate_trace_bound(A, k)\n        E_k = find_exact_cycles(A, k)\n        results.extend([U_k, E_k])\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "最后，我们将从静态的网络结构分析过渡到在其上展开的动态过程。本练习探讨随机游走中的“首达时间”（hitting time），这是理解网络中导航、扩散和搜索过程的关键指标。你将从第一步分析法（first-step analysis）出发，推导其控制线性方程组，并为一个具体例子求解，从而揭示路径概率如何塑造遍历过程的动态特性 。",
            "id": "4296165",
            "problem": "考虑一个有限、连通的带权无向图 $G=(V,E)$，其顶点集为 $V=\\{1,2,\\dots,n\\}$，对称权重矩阵为 $W=(w_{ij})$，其中对所有 $i$，有 $w_{ij}=w_{ji}\\geq 0$ 且 $w_{ii}=0$。对于每个顶点 $i\\in V$，定义加权度 $d_i=\\sum_{k=1}^{n} w_{ik}$ 和标准随机游走的转移概率矩阵 $P=(p_{ij})$，该随机游走从顶点 $i$ 移动到邻居顶点 $j$ 的概率为 $p_{ij}=w_{ij}/d_i$。此过程是一个时齐、离散时间、有限状态的马尔可夫链 (MC)。对于一个固定的目标顶点 $j\\in V$，定义平均首达时间 $H_{ij}$ 为从 $i$ 开始的马尔可夫链首次访问 $j$ 所需步数的期望值，其边界条件为 $H_{jj}=0$。\n\n仅使用上述核心定义和第一步分析法，推导对于一个固定目标 $j$，由首达时间向量 $\\{H_{ij} : i\\in V\\}$ 所满足的线性方程组。您的推导必须清楚地说明在吸收目标 $j$ 处的边界条件的作用，并且必须为未知数 $\\{H_{ij} : i\\neq j\\}$ 构建一个适定的线性系统。\n\n然后，将您推导出的系统应用于以下具有 4 个节点和相应权重的特定带权无向图：\n- $w_{12}=2$, $w_{13}=1$, $w_{23}=1$, $w_{24}=1$, $w_{34}=2$,\n- 所有其他 $w_{ij}=0$ (当 $i\\neq j$ 时)。\n\n计算从节点 1 到目标节点 4 的平均首达时间，即 $H_{14}$，结果要求为精确值。不需要四舍五入。最终答案必须是一个没有单位的实数。",
            "solution": "问题要求做两件事：首先，推导带权无向图上平均首达时间的一般线性系统；其次，将此系统应用于一个特定图来计算一个特定的首达时间。\n\n首先，我们来推导这个线性系统。\n设 $G=(V,E)$ 是一个有限、连通、带权的无向图，其顶点集为 $V=\\{1,2,\\dots,n\\}$，权重矩阵为 $W=(w_{ij})$。从顶点 $i$ 到顶点 $j$ 的随机游走转移概率由 $p_{ij} = w_{ij}/d_i$ 给出，其中 $d_i = \\sum_{k=1}^{n} w_{ik}$ 是顶点 $i$ 的加权度。设 $H_{ij}$ 为从顶点 $i$ 开始的随机游走首次到达固定目标顶点 $j$ 的期望步数。问题陈述了边界条件 $H_{jj} = 0$，这表示如果游走从目标开始，到达目标的时间为 0。\n\n对于任意起始顶点 $i \\neq j$，我们可以使用第一步分析法来确定 $H_{ij}$。从顶点 $i$ 以概率 $p_{ik}$ 走一步到邻居顶点 $k$。此步之后，游走位于顶点 $k$，根据定义，到达目标 $j$ 所需的期望额外步数为 $H_{kj}$。总期望时间 $H_{ij}$ 是这一步（计为 1 步）与从后续顶点出发的期望时间之和，并对所有可能的下一个顶点 $k$ 取平均。\n\n数学上，这表示为：\n$$ H_{ij} = 1 + \\sum_{k \\in V} p_{ik} H_{kj} $$\n这个方程对所有 $i \\in V$ 且 $i \\neq j$ 成立。\n\n项 $\\sum_{k \\in V} p_{ik} H_{kj}$ 是从下一状态出发的首达时间的期望值。我们可以通过代入 $p_{ik}$ 的定义来重写该方程：\n$$ H_{ij} = 1 + \\sum_{k=1}^{n} \\frac{w_{ik}}{d_i} H_{kj} $$\n由于我们有 $n-1$ 个未知值 $\\{H_{ij} : i \\in V, i \\neq j\\}$，我们可以为每个 $i \\neq j$ 写出一个这样的方程。这就构成了一个包含 $n-1$ 个变量的 $n-1$ 个线性方程组。\n\n边界条件 $H_{jj}=0$ 的作用至关重要。对于任意 $i \\neq j$，求和可以分解为：\n$$ H_{ij} = 1 + \\left( \\sum_{k \\neq j} p_{ik} H_{kj} \\right) + p_{ij} H_{jj} $$\n代入 $H_{jj}=0$，最后一项消失：\n$$ H_{ij} = 1 + \\sum_{k \\neq j} p_{ik} H_{kj} $$\n整理后得到未知数 $\\{H_{ij} : i \\neq j\\}$ 的适定线性系统的结构：\n$$ H_{ij} - \\sum_{k \\neq j} p_{ik} H_{kj} = 1 \\quad \\text{for each } i \\in V \\setminus \\{j\\} $$\n以矩阵形式表示，如果 $\\mathbf{H}$ 是未知数 $H_{ij}$（其中 $i \\neq j$）的列向量，$\\mathbf{P}'$ 是 $\\mathbf{P}$ 中对应于非目标状态的子矩阵，则该系统为 $(\\mathbf{I} - \\mathbf{P}')\\mathbf{H} = \\mathbf{1}$，其中 $\\mathbf{I}$ 是单位矩阵，$\\mathbf{1}$ 是全为1的列向量。图是连通的这一事实保证了该系统有唯一解。\n\n接下来，我们将此框架应用于具体图。\n该图有 $n=4$ 个顶点, $V=\\{1, 2, 3, 4\\}$。目标是顶点 $j=4$。我们需要计算 $H_{14}$。未知数是 $H_{14}$、$H_{24}$ 和 $H_{34}$。边界条件是 $H_{44}=0$。\n\n给出的非零权重为 $w_{12}=2$, $w_{13}=1$, $w_{23}=1$, $w_{24}=1$, $w_{34}=2$。由于图是无向的，所以 $w_{ji}=w_{ij}$。\n加权度 $d_i = \\sum_{k} w_{ik}$ 分别为：\n$d_1 = w_{12} + w_{13} = 2 + 1 = 3$\n$d_2 = w_{21} + w_{23} + w_{24} = 2 + 1 + 1 = 4$\n$d_3 = w_{31} + w_{32} + w_{34} = 1 + 1 + 2 = 4$\n$d_4 = w_{42} + w_{43} = 1 + 2 = 3$\n\n对于起始顶点 $i \\in \\{1, 2, 3\\}$，所需的转移概率 $p_{ik} = w_{ik}/d_i$ 为：\n对于 $i=1$: $p_{12} = \\frac{2}{3}$, $p_{13} = \\frac{1}{3}$. ($p_{11}=p_{14}=0$)\n对于 $i=2$: $p_{21} = \\frac{2}{4} = \\frac{1}{2}$, $p_{23} = \\frac{1}{4}$, $p_{24} = \\frac{1}{4}$. ($p_{22}=0$)\n对于 $i=3$: $p_{31} = \\frac{1}{4}$, $p_{32} = \\frac{1}{4}$, $p_{34} = \\frac{2}{4} = \\frac{1}{2}$. ($p_{33}=0$)\n\n现在，我们使用一般方程 $H_{i4} = 1 + \\sum_{k=1}^4 p_{ik} H_{k4}$ 和条件 $H_{44}=0$ 来建立关于 $H_{14}$、$H_{24}$ 和 $H_{34}$ 的线性系统。\n\n对于 $i=1$:\n$H_{14} = 1 + p_{12}H_{24} + p_{13}H_{34} = 1 + \\frac{2}{3}H_{24} + \\frac{1}{3}H_{34}$\n两边乘以 $3$ 得: $3H_{14} = 3 + 2H_{24} + H_{34} \\implies 3H_{14} - 2H_{24} - H_{34} = 3$ (方程 1)\n\n对于 $i=2$:\n$H_{24} = 1 + p_{21}H_{14} + p_{23}H_{34} + p_{24}H_{44} = 1 + \\frac{1}{2}H_{14} + \\frac{1}{4}H_{34} + \\frac{1}{4}(0)$\n两边乘以 $4$ 得: $4H_{24} = 4 + 2H_{14} + H_{34} \\implies -2H_{14} + 4H_{24} - H_{34} = 4$ (方程 2)\n\n对于 $i=3$:\n$H_{34} = 1 + p_{31}H_{14} + p_{32}H_{24} + p_{34}H_{44} = 1 + \\frac{1}{4}H_{14} + \\frac{1}{4}H_{24} + \\frac{1}{2}(0)$\n两边乘以 $4$ 得: $4H_{34} = 4 + H_{14} + H_{24} \\implies -H_{14} - H_{24} + 4H_{34} = 4$ (方程 3)\n\n我们得到了一个包含三个线性方程的方程组：\n1) $3H_{14} - 2H_{24} - H_{34} = 3$\n2) $-2H_{14} + 4H_{24} - H_{34} = 4$\n3) $-H_{14} - H_{24} + 4H_{34} = 4$\n\n我们可以解这个方程组。从方程 1，我们将 $H_{34}$ 用其他变量表示：\n$H_{34} = 3H_{14} - 2H_{24} - 3$\n\n将 $H_{34}$ 的表达式代入方程 2：\n$-2H_{14} + 4H_{24} - (3H_{14} - 2H_{24} - 3) = 4$\n$-2H_{14} + 4H_{24} - 3H_{14} + 2H_{24} + 3 = 4$\n$-5H_{14} + 6H_{24} = 1$ (方程 2')\n\n将 $H_{34}$ 的表达式代入方程 3：\n$-H_{14} - H_{24} + 4(3H_{14} - 2H_{24} - 3) = 4$\n$-H_{14} - H_{24} + 12H_{14} - 8H_{24} - 12 = 4$\n$11H_{14} - 9H_{24} = 16$ (方程 3')\n\n现在我们得到了一个关于变量 $H_{14}$ 和 $H_{24}$ 的 $2 \\times 2$ 方程组：\n2') $-5H_{14} + 6H_{24} = 1$\n3') $11H_{14} - 9H_{24} = 16$\n\n从方程 2'，我们解出 $H_{24}$: $6H_{24} = 1 + 5H_{14} \\implies H_{24} = \\frac{1 + 5H_{14}}{6}$。\n\n将此代入方程 3'：\n$11H_{14} - 9\\left(\\frac{1 + 5H_{14}}{6}\\right) = 16$\n$11H_{14} - \\frac{3}{2}(1 + 5H_{14}) = 16$\n整个方程两边乘以 $2$ 以消去分数：\n$22H_{14} - 3(1 + 5H_{14}) = 32$\n$22H_{14} - 3 - 15H_{14} = 32$\n$7H_{14} = 35$\n$H_{14} = \\frac{35}{7} = 5$\n\n从节点 1 到目标节点 4 的平均首達时间是 5。",
            "answer": "$$\\boxed{5}$$"
        }
    ]
}