{
    "hands_on_practices": [
        {
            "introduction": "Understanding the structure of paths is fundamental, but its true power in network science is revealed when used to quantify the roles of individual nodes. This exercise focuses on betweenness centrality, a key metric that measures a node's influence over the flow of information by counting how often it lies on the shortest paths between other nodes. You will apply the core definition to a graph specifically designed to have multiple shortest paths, providing hands-on practice in calculating this crucial centrality measure from first principles .",
            "id": "4296207",
            "problem": "Consider an undirected weighted graph $G$ with node set $V=\\{s,a,b,r,v,t\\}$ and positive edge weights specified as follows: $w(s,a)=1$, $w(s,b)=1$, $w(a,v)=1$, $w(b,v)=1$, $w(a,r)=1$, $w(b,r)=1$, $w(v,t)=1$, and $w(r,t)=1$. There are no other edges in $G$. In this graph, multiple distinct shortest paths (geodesics) exist between certain node pairs; for example, between $s$ and $t$.\n\nStarting from the core definitions of weighted path length (sum of edge weights along a path), geodesic distance (minimum weighted path length between two nodes), and node betweenness centrality in undirected weighted graphs (where the contribution from a source-target pair $\\{s,t\\}$ is the fraction of geodesics that traverse the node), derive and compute the normalized betweenness centrality of node $v$.\n\nUse the standard normalization for undirected graphs that divides the raw sum of pairwise contributions by the number of unordered source-target pairs that exclude $v$, so that the maximum possible normalized value is $1$. Provide an exact value. Express your final answer as an exact rational number without rounding and without units.",
            "solution": "We begin from the foundational definitions relevant to undirected weighted graphs:\n- The length of a path is the sum of the edge weights along that path.\n- The geodesic distance between two nodes $x$ and $y$ is the minimum path length over all paths joining $x$ and $y$.\n- Let $\\sigma_{xy}$ denote the number of distinct geodesics (shortest paths) between $x$ and $y$, and let $\\sigma_{xy}(v)$ denote the number of those geodesics that pass through node $v$ (with $v\\notin\\{x,y\\}$).\n- The raw node betweenness centrality of $v$ is defined by\n$$\ng(v)=\\sum_{\\substack{s,t\\in V\\\\ s\\neq v\\neq t\\\\ s\\neq t}}\\frac{\\sigma_{st}(v)}{\\sigma_{st}}\\,,\n$$\nwhere the sum is over unordered pairs $\\{s,t\\}$ in the undirected case.\n- The normalized betweenness centrality divides $g(v)$ by the total number of unordered source-target pairs that exclude $v$, which is $\\frac{(n-1)(n-2)}{2}$ for a graph with $n$ nodes. Here $n=|V|=6$, so the normalization factor is $\\frac{(6-1)(6-2)}{2}=\\frac{5\\cdot 4}{2}=10$.\n\nWe will compute $g(v)$ by enumerating all unordered pairs in $V\\setminus\\{v\\}=\\{s,a,b,r,t\\}$, which yields $\\binom{5}{2}=10$ pairs. For each pair, we identify all geodesics, count $\\sigma_{st}$ and $\\sigma_{st}(v)$, and add $\\frac{\\sigma_{st}(v)}{\\sigma_{st}}$ to $g(v)$.\n\nBecause all given edges have weight $1$, path lengths are simply the number of edges traversed.\n\nList the pairs and analyze:\n\n$1.$ Pair $\\{s,a\\}$: The edge $(s,a)$ of weight $1$ is a geodesic. Any path through $v$ would have length at least $2$, so it is not a geodesic. Hence $\\sigma_{sa}=1$ and $\\sigma_{sa}(v)=0$, contributing $0$.\n\n$2.$ Pair $\\{s,b\\}$: By symmetry with $\\{s,a\\}$, the direct edge $(s,b)$ of weight $1$ is the unique geodesic. Thus $\\sigma_{sb}=1$, $\\sigma_{sb}(v)=0$, contributing $0$.\n\n$3.$ Pair $\\{s,r\\}$: Paths $s\\to a\\to r$ and $s\\to b\\to r$ both have length $2$ and are geodesics. Any route that detours through $v$ is longer. Thus $\\sigma_{sr}=2$ and $\\sigma_{sr}(v)=0$, contributing $0$.\n\n$4.$ Pair $\\{s,t\\}$: The following four length-$3$ paths are geodesics:\n- $s\\to a\\to v\\to t$,\n- $s\\to b\\to v\\to t$,\n- $s\\to a\\to r\\to t$,\n- $s\\to b\\to r\\to t$.\nAmong these, exactly two pass through $v$. Thus $\\sigma_{st}=4$ and $\\sigma_{st}(v)=2$, contributing $\\frac{2}{4}=\\frac{1}{2}$.\n\n$5.$ Pair $\\{a,b\\}$: All length-$2$ paths between $a$ and $b$ are geodesics. There are three such paths:\n- $a\\to s\\to b$,\n- $a\\to v\\to b$,\n- $a\\to r\\to b$.\nExactly one of these passes through $v$. Thus $\\sigma_{ab}=3$ and $\\sigma_{ab}(v)=1$, contributing $\\frac{1}{3}$.\n\n$6.$ Pair $\\{a,r\\}$: The direct edge $(a,r)$ of weight $1$ is the unique geodesic. Hence $\\sigma_{ar}=1$ and $\\sigma_{ar}(v)=0$, contributing $0$.\n\n$7.$ Pair $\\{a,t\\}$: There are two length-$2$ geodesics:\n- $a\\to v\\to t$,\n- $a\\to r\\to t$.\nExactly one passes through $v$. Thus $\\sigma_{at}=2$ and $\\sigma_{at}(v)=1$, contributing $\\frac{1}{2}$.\n\n$8.$ Pair $\\{b,r\\}$: The direct edge $(b,r)$ of weight $1$ is the unique geodesic. Hence $\\sigma_{br}=1$ and $\\sigma_{br}(v)=0$, contributing $0$.\n\n$9.$ Pair $\\{b,t\\}$: By symmetry with $\\{a,t\\}$, there are two length-$2$ geodesics:\n- $b\\to v\\to t$,\n- $b\\to r\\to t$.\nExactly one passes through $v$. Thus $\\sigma_{bt}=2$ and $\\sigma_{bt}(v)=1$, contributing $\\frac{1}{2}$.\n\n$10.$ Pair $\\{r,t\\}$: The direct edge $(r,t)$ of weight $1$ is the unique geodesic. Hence $\\sigma_{rt}=1$ and $\\sigma_{rt}(v)=0$, contributing $0$.\n\nSumming the contributions, we obtain\n$$\ng(v)=0+0+0+\\frac{1}{2}+\\frac{1}{3}+0+\\frac{1}{2}+0+\\frac{1}{2}+0=\\frac{3}{2}+\\frac{1}{3}=\\frac{9}{6}+\\frac{2}{6}=\\frac{11}{6}.\n$$\n\nWith $n=6$, the number of unordered source-target pairs that exclude $v$ is\n$$\n\\frac{(n-1)(n-2)}{2}=\\frac{(6-1)(6-2)}{2}=\\frac{5\\cdot 4}{2}=10.\n$$\nTherefore, the normalized betweenness centrality of $v$ is\n$$\ng'(v)=\\frac{g(v)}{10}=\\frac{\\frac{11}{6}}{10}=\\frac{11}{60}.\n$$\n\nThis is the exact normalized value, as required.",
            "answer": "$$\\boxed{\\frac{11}{60}}$$"
        },
        {
            "introduction": "Paths and walks are not merely static structures; they form the scaffold for dynamic processes on networks. This practice explores the concept of a random walk, a foundational model for everything from information diffusion to animal foraging. By applying first-step analysis, a powerful technique for studying stochastic processes, you will derive and solve the system of equations that governs the expected hitting timeâ€”the average number of steps required to reach a target node from any starting point .",
            "id": "4296165",
            "problem": "Consider a finite, connected, weighted undirected graph $G=(V,E)$ with vertex set $V=\\{1,2,\\dots,n\\}$ and symmetric weight matrix $W=(w_{ij})$ where $w_{ij}=w_{ji}\\geq 0$ and $w_{ii}=0$ for all $i$. For each vertex $i\\in V$, define the weighted degree $d_i=\\sum_{k=1}^{n} w_{ik}$ and the transition probability matrix $P=(p_{ij})$ of the standard random walk that moves from $i$ to a neighbor $j$ with probability $p_{ij}=w_{ij}/d_i$. This process is a time-homogeneous, discrete-time, finite-state Markov chain (MC). For a fixed target vertex $j\\in V$, define the expected hitting time $H_{ij}$ as the expectation of the number of steps required for the MC starting at $i$ to visit $j$ for the first time, with the boundary condition $H_{jj}=0$.\n\nUsing only the core definitions above and first-step analysis, derive the linear system satisfied by the vector of hitting times $\\{H_{ij} : i\\in V\\}$ for a fixed target $j$. Your derivation must clearly indicate the role of the boundary condition at the absorbing target $j$ and must construct a well-posed linear system for the unknowns $\\{H_{ij} : i\\neq j\\}$.\n\nThen, apply your derived system to the following specific weighted undirected graph on $4$ nodes with weights:\n- $w_{12}=2$, $w_{13}=1$, $w_{23}=1$, $w_{24}=1$, $w_{34}=2$,\n- all other $w_{ij}=0$ for $i\\neq j$.\n\nCompute the expected hitting time from node $1$ to the target node $4$, that is, $H_{14}$, as an exact value. No rounding is required. The final answer must be a single real number with no units.",
            "solution": "The problem asks for two things: first, to derive the general linear system for expected hitting times on a weighted undirected graph, and second, to apply this system to a specific graph to compute a particular hitting time.\n\nFirst, we address the derivation of the linear system.\nLet $G=(V,E)$ be a finite, connected, weighted, undirected graph with vertex set $V=\\{1,2,\\dots,n\\}$ and weight matrix $W=(w_{ij})$. The transition probability for a random walk from vertex $i$ to vertex $j$ is given by $p_{ij} = w_{ij}/d_i$, where $d_i = \\sum_{k=1}^{n} w_{ik}$ is the weighted degree of vertex $i$. Let $H_{ij}$ be the expected number of steps for a random walk starting at vertex $i$ to first reach a fixed target vertex $j$. The problem states the boundary condition $H_{jj} = 0$, which signifies that if the walk starts at the target, the time to reach it is $0$.\n\nFor any starting vertex $i \\neq j$, we can use first-step analysis to determine $H_{ij}$. A single step is taken from vertex $i$ to a neighboring vertex $k$ with probability $p_{ik}$. After this step, the walk is at vertex $k$, and the expected number of additional steps to reach the target $j$ is, by definition, $H_{kj}$. The total expected time $H_{ij}$ is the sum of this first step (which counts as $1$ step) and the expected time from the subsequent vertex, averaged over all possible next vertices $k$.\n\nMathematically, this is expressed as:\n$$ H_{ij} = 1 + \\sum_{k \\in V} p_{ik} H_{kj} $$\nThis equation holds for all $i \\in V$ such that $i \\neq j$.\n\nThe term $\\sum_{k \\in V} p_{ik} H_{kj}$ is the expected value of the hitting time from the next state. We can rewrite the equation by substituting the definition of $p_{ik}$:\n$$ H_{ij} = 1 + \\sum_{k=1}^{n} \\frac{w_{ik}}{d_i} H_{kj} $$\nSince we have $n-1$ unknown values $\\{H_{ij} : i \\in V, i \\neq j\\}$, we can write one such equation for each $i \\neq j$. This gives a system of $n-1$ linear equations in $n-1$ variables.\n\nThe role of the boundary condition $H_{jj}=0$ is crucial. For any $i \\neq j$, the sum can be split:\n$$ H_{ij} = 1 + \\left( \\sum_{k \\neq j} p_{ik} H_{kj} \\right) + p_{ij} H_{jj} $$\nSubstituting $H_{jj}=0$, the last term vanishes:\n$$ H_{ij} = 1 + \\sum_{k \\neq j} p_{ik} H_{kj} $$\nRearranging this gives the structure of a well-posed linear system for the unknowns $\\{H_{ij} : i \\neq j\\}$:\n$$ H_{ij} - \\sum_{k \\neq j} p_{ik} H_{kj} = 1 \\quad \\text{for each } i \\in V \\setminus \\{j\\} $$\nIn matrix form, if $\\mathbf{H}$ is the column vector of unknowns $H_{ij}$ (for $i \\neq j$) and $\\mathbf{P}'$ is the submatrix of $\\mathbf{P}$ corresponding to non-target states, the system is $(\\mathbf{I} - \\mathbf{P}')\\mathbf{H} = \\mathbf{1}$, where $\\mathbf{I}$ is the identity matrix and $\\mathbf{1}$ is a column vector of ones. The fact that the graph is connected ensures that this system has a unique solution.\n\nNext, we apply this framework to the specific graph.\nThe graph has $n=4$ vertices, $V=\\{1, 2, 3, 4\\}$. The target is vertex $j=4$. We need to compute $H_{14}$. The unknowns are $H_{14}$, $H_{24}$, and $H_{34}$. The boundary condition is $H_{44}=0$.\n\nThe non-zero weights are given as $w_{12}=2$, $w_{13}=1$, $w_{23}=1$, $w_{24}=1$, $w_{34}=2$. Since the graph is undirected, $w_{ji}=w_{ij}$.\nThe weighted degrees $d_i = \\sum_{k} w_{ik}$ are:\n$d_1 = w_{12} + w_{13} = 2 + 1 = 3$\n$d_2 = w_{21} + w_{23} + w_{24} = 2 + 1 + 1 = 4$\n$d_3 = w_{31} + w_{32} + w_{34} = 1 + 1 + 2 = 4$\n$d_4 = w_{42} + w_{43} = 1 + 2 = 3$\n\nThe required transition probabilities $p_{ik} = w_{ik}/d_i$ for starting vertices $i \\in \\{1, 2, 3\\}$ are:\nFor $i=1$: $p_{12} = \\frac{2}{3}$, $p_{13} = \\frac{1}{3}$. ($p_{11}=p_{14}=0$)\nFor $i=2$: $p_{21} = \\frac{2}{4} = \\frac{1}{2}$, $p_{23} = \\frac{1}{4}$, $p_{24} = \\frac{1}{4}$. ($p_{22}=0$)\nFor $i=3$: $p_{31} = \\frac{1}{4}$, $p_{32} = \\frac{1}{4}$, $p_{34} = \\frac{2}{4} = \\frac{1}{2}$. ($p_{33}=0$)\n\nNow, we set up the linear system for $H_{14}$, $H_{24}$, and $H_{34}$ using the general equation $H_{i4} = 1 + \\sum_{k=1}^4 p_{ik} H_{k4}$ and the condition $H_{44}=0$.\n\nFor $i=1$:\n$H_{14} = 1 + p_{12}H_{24} + p_{13}H_{34} = 1 + \\frac{2}{3}H_{24} + \\frac{1}{3}H_{34}$\nMultiplying by $3$ gives: $3H_{14} = 3 + 2H_{24} + H_{34} \\implies 3H_{14} - 2H_{24} - H_{34} = 3$ (Eq. 1)\n\nFor $i=2$:\n$H_{24} = 1 + p_{21}H_{14} + p_{23}H_{34} + p_{24}H_{44} = 1 + \\frac{1}{2}H_{14} + \\frac{1}{4}H_{34} + \\frac{1}{4}(0)$\nMultiplying by $4$ gives: $4H_{24} = 4 + 2H_{14} + H_{34} \\implies -2H_{14} + 4H_{24} - H_{34} = 4$ (Eq. 2)\n\nFor $i=3$:\n$H_{34} = 1 + p_{31}H_{14} + p_{32}H_{24} + p_{34}H_{44} = 1 + \\frac{1}{4}H_{14} + \\frac{1}{4}H_{24} + \\frac{1}{2}(0)$\nMultiplying by $4$ gives: $4H_{34} = 4 + H_{14} + H_{24} \\implies -H_{14} - H_{24} + 4H_{34} = 4$ (Eq. 3)\n\nWe have a system of three linear equations:\n1) $3H_{14} - 2H_{24} - H_{34} = 3$\n2) $-2H_{14} + 4H_{24} - H_{34} = 4$\n3) $-H_{14} - H_{24} + 4H_{34} = 4$\n\nWe can solve this system. From Eq. 1, we express $H_{34}$ in terms of the other variables:\n$H_{34} = 3H_{14} - 2H_{24} - 3$\n\nSubstitute this expression for $H_{34}$ into Eq. 2:\n$-2H_{14} + 4H_{24} - (3H_{14} - 2H_{24} - 3) = 4$\n$-2H_{14} + 4H_{24} - 3H_{14} + 2H_{24} + 3 = 4$\n$-5H_{14} + 6H_{24} = 1$ (Eq. 2')\n\nSubstitute the expression for $H_{34}$ into Eq. 3:\n$-H_{14} - H_{24} + 4(3H_{14} - 2H_{24} - 3) = 4$\n$-H_{14} - H_{24} + 12H_{14} - 8H_{24} - 12 = 4$\n$11H_{14} - 9H_{24} = 16$ (Eq. 3')\n\nNow we have a $2 \\times 2$ system with variables $H_{14}$ and $H_{24}$:\n2') $-5H_{14} + 6H_{24} = 1$\n3') $11H_{14} - 9H_{24} = 16$\n\nFrom Eq. 2', we solve for $H_{24}$: $6H_{24} = 1 + 5H_{14} \\implies H_{24} = \\frac{1 + 5H_{14}}{6}$.\n\nSubstitute this into Eq. 3':\n$11H_{14} - 9\\left(\\frac{1 + 5H_{14}}{6}\\right) = 16$\n$11H_{14} - \\frac{3}{2}(1 + 5H_{14}) = 16$\nMultiply the entire equation by $2$ to clear the fraction:\n$22H_{14} - 3(1 + 5H_{14}) = 32$\n$22H_{14} - 3 - 15H_{14} = 32$\n$7H_{14} = 35$\n$H_{14} = \\frac{35}{7} = 5$\n\nThe expected hitting time from node $1$ to the target node $4$ is $5$.",
            "answer": "$$\\boxed{5}$$"
        },
        {
            "introduction": "Detecting cyclic structures is a critical task in network analysis, as cycles often represent feedback loops, recurrent states, or vulnerabilities. This advanced exercise delves into the algorithmic challenge of cycle detection, contrasting an elegant algebraic method based on matrix traces with an exact enumeration via Depth-First Search (DFS). Through this comparison, you will gain a deeper appreciation for algorithmic trade-offs and the subtle but crucial distinction between counting all closed walks and counting only *simple* cycles .",
            "id": "4296197",
            "problem": "Consider a finite directed graph with $n$ labeled vertices $\\{0,1,\\dots,n-1\\}$ and a binary adjacency matrix $A \\in \\{0,1\\}^{n \\times n}$, where $A_{ij} = 1$ if and only if there is a directed edge from vertex $i$ to vertex $j$, and $A_{ij} = 0$ otherwise. Use the following fundamental bases:\n\n- The definition of a directed walk: A sequence of vertices $(v_0, v_1, \\dots, v_k)$ such that $A_{v_{t} v_{t+1}} = 1$ for all $t \\in \\{0,1,\\dots,k-1\\}$.\n- The well-tested fact in algebraic graph theory: For any integer $k \\ge 1$, the $(i,j)$-entry of $A^k$ equals the number of directed walks of length $k$ from $i$ to $j$. In particular, $\\operatorname{tr}(A^k) = \\sum_{i=0}^{n-1} (A^k)_{ii}$ equals the number of closed walks of length $k$ that start and end at the same vertex.\n\nA simple directed cycle of length $k$ is a closed directed walk of length $k$ that visits $k$ distinct vertices exactly once, except for the start/end vertex repetition. You are asked to design an algorithm that detects the existence of at least one simple directed cycle of bounded length $k$ by computing traces of powers of $A$ and to reason about, and empirically illustrate, the possibility of false positives when using traces for counting, which arise from backtracking and repeated vertices in closed walks.\n\nYour tasks:\n\n- Derive, from first principles above, a detection rule for the existence of at least one simple directed cycle of length at most $k$ using $\\operatorname{tr}(A^\\ell)$ for $\\ell \\in \\{1,2,\\dots,k\\}$.\n- Define an integer-valued upper bound on the number of simple directed cycles of length at most $k$ based on traces of powers of $A$.\n- Implement an exact enumeration procedure by Depth-First Search (DFS) that counts the number of simple directed cycles of length at most $k$ by directly enforcing vertex non-repetition and a canonicalization rule to avoid rotational duplicates, and compare it to your trace-based upper bound to empirically expose the magnitude of false positives caused by backtracking and repeated vertices.\n\nYou must implement a single program that, for each test case, returns two integers: the trace-based upper bound (rounded up to the nearest integer using the ceiling function to ensure it is an upper bound) and the exact enumeration count of simple directed cycles of length at most $k$. The final output must aggregate the results of all test cases into a single line formatted as a comma-separated list enclosed in square brackets.\n\nTest suite (each test case provides an adjacency matrix $A$ and a bound $k$):\n\n- Test case $1$: $A$ is the directed $3$-cycle on vertices $\\{0,1,2\\}$ with edges $(0 \\to 1)$, $(1 \\to 2)$, $(2 \\to 0)$, that is,\n  $$\n  A = \\begin{pmatrix}\n  0 & 1 & 0 \\\\\n  0 & 0 & 1 \\\\\n  1 & 0 & 0\n  \\end{pmatrix},\n  $$\n  and $k = 3$.\n- Test case $2$: $A$ is a directed $2$-cycle on vertices $\\{0,1\\}$ with edges $(0 \\to 1)$, $(1 \\to 0)$, that is,\n  $$\n  A = \\begin{pmatrix}\n  0 & 1 \\\\\n  1 & 0\n  \\end{pmatrix},\n  $$\n  and $k = 4$.\n- Test case $3$: $A$ is a $3$-vertex graph with a self-loop at vertex $0$ and a directed $3$-cycle $(0 \\to 1 \\to 2 \\to 0)$, that is,\n  $$\n  A = \\begin{pmatrix}\n  1 & 1 & 0 \\\\\n  0 & 0 & 1 \\\\\n  1 & 0 & 0\n  \\end{pmatrix},\n  $$\n  and $k = 3$.\n- Test case $4$: $A$ is a directed acyclic graph (DAG) that is a chain on $\\{0,1,2,3\\}$ with edges $(0 \\to 1)$, $(1 \\to 2)$, $(2 \\to 3)$, that is,\n  $$\n  A = \\begin{pmatrix}\n  0 & 1 & 0 & 0 \\\\\n  0 & 0 & 1 & 0 \\\\\n  0 & 0 & 0 & 1 \\\\\n  0 & 0 & 0 & 0\n  \\end{pmatrix},\n  $$\n  and $k = 4$.\n- Test case $5$: $A$ is a $5$-vertex graph consisting of a directed $3$-cycle $(0 \\to 1 \\to 2 \\to 0)$ disjoint from a directed $2$-cycle $(3 \\to 4 \\to 3)$, that is,\n  $$\n  A = \\begin{pmatrix}\n  0 & 1 & 0 & 0 & 0 \\\\\n  0 & 0 & 1 & 0 & 0 \\\\\n  1 & 0 & 0 & 0 & 0 \\\\\n  0 & 0 & 0 & 0 & 1 \\\\\n  0 & 0 & 0 & 1 & 0\n  \\end{pmatrix},\n  $$\n  and $k = 3$.\n\nAnswer specification:\n\n- For each test case, compute the trace-based upper bound\n  $$\n  U_k \\equiv \\left\\lceil \\sum_{\\ell=1}^{k} \\frac{\\operatorname{tr}(A^\\ell)}{\\ell} \\right\\rceil,\n  $$\n  and compute the exact count $E_k$ of simple directed cycles of length at most $k$ using DFS with vertex non-repetition and a canonicalization rule that counts each cycle once.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, ordered by test case, and for each test case include first $U_k$ then $E_k$. For example, the output format must be\n  $$\n  [U_1,E_1,U_2,E_2,U_3,E_3,U_4,E_4,U_5,E_5].\n  $$\n- All outputs are unitless integers.\n\nThe problem is purely mathematical and algorithmic and requires rigorous reasoning grounded in the provided fundamental definitions and facts. No physical units, angle units, or percentage units are involved. The test cases have been chosen to cover: a general case with a single simple cycle, a case where multiple traversals inflate trace counts, a case with a self-loop plus a cycle, an acyclic boundary case, and a multi-cycle case.",
            "solution": "The problem requires the derivation of a trace-based method for detecting and bounding the number of simple directed cycles, and the implementation of an exact enumeration algorithm for comparison. The solution is presented in two parts: the theoretical derivation for the trace-based approach and the algorithmic design for the exact counting method.\n\n### Part 1: Trace-Based Cycle Detection and Upper Bound\n\nThe foundation of this method is the algebraic graph theory fact that the $(i,j)$-entry of the matrix power $A^k$ gives the number of distinct directed walks of length $k$ from vertex $i$ to vertex $j$. Consequently, the trace of $A^k$, written as $\\operatorname{tr}(A^k) = \\sum_{i=0}^{n-1} (A^k)_{ii}$, gives the total number of closed directed walks of length $k$ in the graph.\n\nA simple directed cycle of length $\\ell$ is a specific kind of closed walk of length $\\ell$ where all vertices are distinct, except for the coincidence of the start and end vertex. A crucial observation is that any closed walk must contain at least one simple cycle. To see this, consider a closed walk $W=(v_0, v_1, \\dots, v_\\ell=v_0)$. If $W$ is not simple, at least one vertex is repeated in the sequence $v_0, \\dots, v_{\\ell-1}$. Let $v_i = v_j$ for some $0 \\le i < j < \\ell$. Then the sub-walk $(v_i, v_{i+1}, \\dots, v_j)$ is a shorter closed walk. This reduction process can be applied repeatedly until a closed walk with no repeated intermediate vertices is found, which is by definition a simple cycle. The length of this resulting simple cycle is at most the length of the original walk.\n\n**Detection Rule:**\nBased on the above reasoning, the existence of a closed walk of length $\\ell \\in \\{1, 2, \\dots, k\\}$ implies the existence of a simple directed cycle of length at most $\\ell$. The total number of closed walks of length up to $k$ is given by $\\sum_{\\ell=1}^k \\operatorname{tr}(A^\\ell)$. Therefore, a robust detection rule is as follows: a simple directed cycle of length at most $k$ exists if and only if $\\sum_{\\ell=1}^k \\operatorname{tr}(A^\\ell) > 0$. Any non-zero trace for a power $\\ell \\ge 1$ signals a closed walk, which guarantees a simple cycle.\n\n**Upper Bound Derivation:**\nThe problem provides the formula $U_k \\equiv \\left\\lceil \\sum_{\\ell=1}^{k} \\frac{\\operatorname{tr}(A^\\ell)}{\\ell} \\right\\rceil$ as an upper bound for the number of simple directed cycles of length at most $k$. Let's analyze its components.\nA single simple cycle of length $\\ell$ can be represented as $\\ell$ distinct closed walks, one starting from each of its $\\ell$ vertices. For example, the cycle $(v_0 \\to v_1 \\to \\dots \\to v_{\\ell-1} \\to v_0)$ gives rise to the closed walks $(v_0, \\dots, v_0)$, $(v_1, \\dots, v_1)$, and so on. All these $\\ell$ walks are counted in $\\operatorname{tr}(A^\\ell)$. Dividing $\\operatorname{tr}(A^\\ell)$ by $\\ell$ is an attempt to count the cycle itself just once.\n\nHowever, $\\operatorname{tr}(A^\\ell)$ also includes contributions from non-simple closed walks, which are the source of \"false positives\" and cause this method to be an upper bound rather than an exact count. These non-simple walks include:\n1.  **Composite walks:** Traversing a simple cycle of length $d$ (where $d$ divides $\\ell$) a total of $\\ell/d$ times. For example, a $2$-cycle traversed twice is a closed walk of length $4$.\n2.  **Walks with excursions or backtracking:** A walk that leaves a vertex, follows a path, and then returns. For instance, $i \\to j \\to i$ is a closed walk of length $2$ but forms a simple $2$-cycle only if $i \\ne j$.\n\nThe formula $\\sum_{\\ell=1}^{k} \\frac{\\operatorname{tr}(A^\\ell)}{\\ell}$ thus sums up these estimates for all lengths up to $k$. Since each term $\\frac{\\operatorname{tr}(A^\\ell)}{\\ell}$ overcounts or correctly counts the simple cycles of length $\\ell$, the total sum is an over-approximation of the true number of simple cycles of length at most $k$. The ceiling function, $\\lceil \\cdot \\rceil$, is applied to ensure the final bound is an integer.\n\nTo compute $U_k$ for a given adjacency matrix $A$ and bound $k$, we iterate $\\ell$ from $1$ to $k$. In each iteration, we calculate $A^\\ell$ using matrix exponentiation, find its trace $\\operatorname{tr}(A^\\ell)$, divide by $\\ell$, and accumulate the result. The final sum is rounded up to the nearest integer.\n\n### Part 2: Exact Enumeration using Depth-First Search (DFS)\n\nTo obtain the exact count of simple directed cycles, $E_k$, we must explicitly enumerate them. A Depth-First Search (DFS) is a natural algorithmic choice for exploring paths in a graph. The core idea is to find all simple paths starting from each vertex that lead back to the same vertex, forming a cycle.\n\nThe algorithm is structured as follows:\n1.  **Graph Representation:** The adjacency matrix $A$ is converted to an adjacency list for efficient neighbor lookup during traversal.\n2.  **Iteration over Starting Vertices:** The search is initiated from every vertex $s \\in \\{0, 1, \\dots, n-1\\}$ in the graph. This ensures that all possible cycles are discovered.\n3.  **DFS Traversal:** For each `start_node` $s$, a recursive DFS is performed. The DFS function maintains the current `path` (a list of vertices) and a `visited` set for O(1) checking to enforce the \"simple\" constraint (no repeated vertices).\n    - The recursion proceeds from a current vertex $u$ to its neighbors $v$.\n    - If a neighbor $v$ is the same as the `start_node`, a cycle has been found. The length of this cycle is the number of vertices in the current `path`.\n    - If a neighbor $v$ has not been visited in the current `path`, the DFS continues recursively from $v$, with $v$ added to the `path` and `visited` set. After the recursive call returns, $v$ is removed (backtracking) to allow exploration of other paths.\n4.  **Length Constraint:** The search is pruned. The recursion is stopped if extending the path would make its length exceed the maximum allowed cycle length $k$.\n5.  **Canonicalization and Counting:** A simple cycle of length $\\ell$ will be found $\\ell$ times, once for each of its vertices serving as the `start_node`. To count each unique cycle only once, we use a canonical representation. A convenient choice is the sorted tuple of the vertices in the cycle. For example, the paths `[0, 1, 2]`, `[1, 2, 0]`, and `[2, 0, 1]` all correspond to the same $3$-cycle. Their canonical representation would be `(0, 1, 2)`. These canonical forms are stored in a `set` to automatically discard duplicates.\n6.  **Final Count:** The exact number of simple cycles of length at most $k$, denoted $E_k$, is the final size of this set of canonical representations.\n\nThis DFS-based approach guarantees an exact count by directly enforcing the definition of a simple cycle and employing a canonicalization rule to prevent overcounting due to rotational symmetries. The comparison of $U_k$ and $E_k$ will empirically demonstrate the overestimation inherent in the trace-based method.",
            "answer": "```python\nimport numpy as np\nimport math\n\ndef calculate_trace_bound(A, k):\n    \"\"\"\n    Calculates the trace-based upper bound Uk for simple cycles of length up to k.\n    Uk = ceil(sum_l=1^k (tr(A^l) / l))\n    \"\"\"\n    total_trace_term = 0.0\n    n = A.shape[0]\n\n    # A_power will store A^l\n    A_power = np.copy(A).astype(np.float64) # Use float for potentially large numbers\n    \n    for l in range(1, k + 1):\n        if l > 1:\n            # More efficient than calling matrix_power in a loop\n            A_power = A_power @ A\n        \n        # Ensure A_power is what we expect for l=1\n        if l == 1 and not np.array_equal(A_power, A):\n             A_power = np.copy(A).astype(np.float64)\n\n        # Check if A_power grew too large before taking trace\n        if n > 0:\n            trace_val = np.trace(A_power)\n            total_trace_term += trace_val / l\n\n    return math.ceil(total_trace_term)\n\ndef find_exact_cycles(A, k):\n    \"\"\"\n    Finds the exact number of simple directed cycles of length up to k using DFS.\n    \"\"\"\n    n = A.shape[0]\n    adj = {i: [j for j, connected in enumerate(row) if connected] for i, row in enumerate(A)}\n    found_cycles = set()\n\n    for start_node in range(n):\n        # The path starts with the start_node\n        path = [start_node]\n        # Visited set for O(1) lookups\n        visited = {start_node}\n        dfs_recursive(start_node, start_node, path, visited, k, adj, found_cycles)\n        \n    return len(found_cycles)\n\ndef dfs_recursive(start_node, u, path, visited, max_len, adj, found_cycles):\n    \"\"\"\n    Recursive DFS helper function to find simple cycles.\n    \"\"\"\n    path_len = len(path)\n\n    # Explore neighbors of the current node u\n    for v in adj.get(u, []):\n        # A cycle is found if the neighbor is the start_node.\n        # cycle length is path_len.\n        if v == start_node:\n            if path_len <= max_len:\n                # Canonical form is the sorted tuple of vertices\n                canonical_form = tuple(sorted(path))\n                found_cycles.add(canonical_form)\n        \n        # If neighbor is not visited and path is not too long, continue the path\n        elif v not in visited:\n            if path_len < max_len:\n                visited.add(v)\n                path.append(v)\n                dfs_recursive(start_node, v, path, visited, max_len, adj, found_cycles)\n                path.pop()\n                visited.remove(v)\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        # Test case 1\n        (np.array([[0, 1, 0], [0, 0, 1], [1, 0, 0]]), 3),\n        # Test case 2\n        (np.array([[0, 1], [1, 0]]), 4),\n        # Test case 3\n        (np.array([[1, 1, 0], [0, 0, 1], [1, 0, 0]]), 3),\n        # Test case 4\n        (np.array([[0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1], [0, 0, 0, 0]]), 4),\n        # Test case 5\n        (np.array([\n            [0, 1, 0, 0, 0],\n            [0, 0, 1, 0, 0],\n            [1, 0, 0, 0, 0],\n            [0, 0, 0, 0, 1],\n            [0, 0, 0, 1, 0]\n        ]), 3),\n    ]\n\n    results = []\n    for A, k in test_cases:\n        # Using numpy.linalg.matrix_power for verified power calculation\n        def calculate_trace_bound_alt(A,k):\n            total_trace_term = 0.0\n            for l in range(1, k + 1):\n                A_power = np.linalg.matrix_power(A, l)\n                trace_val = np.trace(A_power)\n                total_trace_term += trace_val / l\n            return math.ceil(total_trace_term)\n        \n        U_k = calculate_trace_bound_alt(A.astype(np.float64), k)\n        E_k = find_exact_cycles(A, k)\n        results.extend([U_k, E_k])\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}