{
    "hands_on_practices": [
        {
            "introduction": "图的围长（girth），即其最短环路的长度，是刻画网络局部结构的一个基本属性。本练习将指导你运用广度优先搜索（BFS）实现计算围长的经典算法 。通过将每条边视为闭合环路的一条潜在“弦”，你将巩固对 BFS 如何寻找最短路径的理解，并将其应用于解决这个基础的图论问题。",
            "id": "4296170",
            "problem": "设 $G=(V,E)$ 是一个有限、简单、无向图。游走是一个顶点的有限序列，其中连续的顶点是相邻的；路径是所有顶点都互不相同的游走；圈是除了首尾顶点外所有顶点都互不相同的闭合游走。$G$ 的围长，记为 $g(G)$，定义为 $G$ 中最短圈的长度。如果 $G$ 没有圈，则其围长通常取为 $+\\infty$，但在本问题中，此种情况必须报告值 $0$。\n\n你的任务是实现一个完整的程序，该程序使用一种基于广度优先搜索（BFS; Breadth-First Search）层和弦检测的方法，为提供的测试套件中的每个图计算 $g(G)$。该方法必须遵循以下纲要：\n\n- 对于每条无向边 $e=\\{u,v\\}\\in E$，将 $e$ 视为一个潜在的弦，当它与连接 $u$ 和 $v$ 的路径结合时会闭合一个圈。从一个端点使用 BFS 层，检测连接这两个端点的最短路径，同时刻意忽略对 $e$ 本身的遍历，以避免平凡路径。将这样一条路径的存在解释为证明了由该路径与 $e$ 共同构成一个圈，并记录其长度。在所有边上，返回此类圈的最小长度作为围长。\n- 如果对任何边都没有检测到圈，则报告围长为 $0$。\n\n你必须实现这种 BFS 与弦检测相结合的方法，不得借助任何快捷公式；程序必须仅依赖于游走、路径、圈的核心定义以及 BFS 在无权图中发现最短路径的特性。\n\n测试套件规范。对于每个测试用例，图由其顶点集和无向边集给出。所有图都是有限且简单的。\n\n- 测试用例 1：$V=\\{\\,0,1,2\\,\\}$，$E=\\{\\,\\{0,1\\},\\{1,2\\},\\{2,0\\}\\,\\}$。\n- 测试用例 2：$V=\\{\\,0,1,2,3\\,\\}$，$E=\\{\\,\\{0,1\\},\\{1,2\\},\\{2,3\\},\\{3,0\\}\\,\\}$。\n- 测试用例 3：$V=\\{\\,0,1,2,3\\,\\}$，$E=\\{\\,\\{0,1\\},\\{1,2\\},\\{2,3\\}\\,\\}$。\n- 测试用例 4：$V=\\{\\,0,1,2,3,4,5\\,\\}$，$E=\\{\\,\\{0,1\\},\\{1,2\\},\\{2,0\\},\\{2,3\\},\\{3,4\\},\\{4,5\\}\\,\\}$。该图是非连通的；其中一个连通分量包含一个三角形。\n- 测试用例 5：$V=\\{\\,0,1,2,3,4,5\\,\\}$，$E=\\{\\,\\{0,1\\},\\{1,2\\},\\{3,4\\},\\{4,5\\},\\{0,3\\},\\{1,4\\},\\{2,5\\}\\,\\}$。\n\n所需输出。你的程序应生成单行输出，其中包含五个测试用例的结果，格式为用方括号括起来的逗号分隔列表。每个条目必须是一个整数：以边的数量表示的围长，无圈图报告为 $0$，并按上述测试用例的顺序汇总。例如，输出格式必须是形如“[x1,x2,x3,x4,x5]”的单行，其中每个 $x_i$ 是为测试用例 $i$ 计算出的围长。",
            "solution": "问题要求计算给定有限、简单、无向图 $G=(V,E)$ 的围长 $g(G)$。围长定义为 $G$ 中最短圈的长度。按照惯例，如果 $G$ 是无圈的（不包含任何圈），其围长为 $+\\infty$；然而，问题指定在这种情况下必须报告值 $0$。解决方案必须遵循一种基于广度优先搜索（BFS）和弦检测的指定算法。\n\n该算法的基本原理如下：图 $G$ 中的任何圈都可以看作是一条边 $\\{u,v\\} \\in E$，它作为一条“弦”，闭合了其端点 $u$ 和 $v$ 之间的一条路径。这样一个圈的长度是路径的长度加上闭合边的长度，即 $1$。为了找到可能的最短圈，我们必须找到某条边的两个端点之间的最短路径。设该路径长度为 $d$。相应的圈长度将为 $d+1$。图的围长 $g(G)$ 将是通过将 $E$ 中的每条边都视作潜在的弦而找到的此类圈的最小长度。\n\n更正式地，对于任何边 $e=\\{u,v\\} \\in E$，包含 $e$ 的最短圈由 $e$ 本身和在子图 $G' = (V, E \\setminus \\{e\\})$ 中 $u$ 和 $v$ 之间的最短路径构成。设这条最短路径的长度记为 $d_{G'}(u,v)$。那么这个圈的长度就是 $d_{G'}(u,v) + 1$。整个图 $G$ 的围长是遍历所有边得到的这些值的最小值：\n$$ g(G) = \\min_{\\{u,v\\} \\in E} \\left( d_{G'}(u,v) + 1 \\right) $$\n如果对于某条边 $\\{u,v\\}$，在 $G'$ 中 $u$ 和 $v$ 之间不存在路径，则 $d_{G'}(u,v) = +\\infty$。如果所有边都是这种情况，则该图是无圈的。\n\n算法流程如下：\n1.  初始化一个变量 $g_{\\min}$ 用于记录已找到的最小圈长度，将其值设为表示无穷大的数，例如 $g_{\\min} \\leftarrow +\\infty$。\n2.  根据给定的顶点集 $V$ 和边集 $E$ 构建图 $G$ 的邻接表表示。\n3.  遍历 $E$ 中的每条边 $\\{u,v\\}$。对每条边，执行以下步骤来计算包含它的最短圈的长度：\n    a. 我们需要在图 $G' = (V, E \\setminus \\{\\{u,v\\}\\})$ 中找到最短路径距离 $d_{G'}(u,v)$。这可以通过运行广度优先搜索（BFS）来完成，该算法保证能在无权图中找到最短路径。\n    b. 在图 $G$ 中从 $u$ 开始的标准 BFS 会立即找到距离为 1 的邻居 $v$，这对应于遍历边 $\\{u,v\\}$ 本身。为了强制在 $G'$ 中进行搜索，我们必须“刻意忽略”这次遍历。这通过修改 BFS 的初始化来实现。\n    c. 我们不只将源顶点 $u$ 放入队列，而是从 $u$ 的所有邻居（除了 $v$）开始搜索。设 $N(u)$ 是 $u$ 的邻居集合。BFS 队列用所有顶点 $w \\in N(u) \\setminus \\{v\\}$ 进行初始化。每个这样的顶点 $w$ 以初始路径长度 1 被添加到队列中。我们还将 $u$ 和所有这些初始邻居标记为已访问，以防止在 BFS 树中产生圈。\n    d. 然后 BFS 以其标准方式继续进行，逐层探索图。当到达目标顶点 $v$ 时，搜索终止。为 $v$ 记录的距离，我们称之为 $d_{\\text{path}}$，就是 $G'$ 中从 $u$ 到 $v$ 的最短路径的长度。\n    e. 如果 BFS 完成时没有到达 $v$，则不存在替代路径，我们继续处理下一条边。\n    f. 如果找到了长度为 $d_{\\text{path}}$ 的路径，这对应一个长度为 $d_{\\text{path}} + 1$ 的圈。我们更新已找到的最小长度：$g_{\\min} \\leftarrow \\min(g_{\\min}, d_{\\text{path}} + 1)$。\n4.  在遍历完 $E$ 中的所有边后，如果 $g_{\\min}$ 仍为其初始值 $+\\infty$，则表示没有找到任何圈。在这种情况下，函数返回 $0$。否则，它返回计算出的 $g_{\\min}$ 值作为图的围长。\n\n该方法系统地检查与每条边关联的所有最小圈，并利用 BFS 在无权图中能找到最短路径的特性，正确地识别出全局最小值，即围长。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport collections\n\ndef solve():\n    \"\"\"\n    Main solver function to compute the girth for all test cases.\n    \"\"\"\n    # Test suite specification.\n    test_cases = [\n        # Test case 1: A triangle graph\n        {\"V\": {0, 1, 2}, \"E\": [{0, 1}, {1, 2}, {2, 0}]},\n        # Test case 2: A square graph (4-cycle)\n        {\"V\": {0, 1, 2, 3}, \"E\": [{0, 1}, {1, 2}, {2, 3}, {3, 0}]},\n        # Test case 3: A path graph (acyclic)\n        {\"V\": {0, 1, 2, 3}, \"E\": [{0, 1}, {1, 2}, {2, 3}]},\n        # Test case 4: A disconnected graph with a triangle component\n        {\"V\": {0, 1, 2, 3, 4, 5}, \"E\": [{0, 1}, {1, 2}, {2, 0}, {2, 3}, {3, 4}, {4, 5}]},\n        # Test case 5: A prism graph (girth is 4)\n        {\"V\": {0, 1, 2, 3, 4, 5}, \"E\": [{0, 1}, {1, 2}, {3, 4}, {4, 5}, {0, 3}, {1, 4}, {2, 5}]}\n    ]\n\n    results = []\n    for case in test_cases:\n        vertices = case[\"V\"]\n        # Convert set of sets to a list of tuples for easier iteration\n        edges = [tuple(e) for e in case[\"E\"]]\n        girth = _calculate_girth(vertices, edges)\n        results.append(girth)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef _calculate_girth(vertices, edges):\n    \"\"\"\n    Calculates the girth of a graph using a BFS-based approach for each edge.\n    \n    Args:\n        vertices (set): The set of vertices in the graph.\n        edges (list of tuples): The list of edges in the graph.\n        \n    Returns:\n        int: The girth of the graph, or 0 if the graph is acyclic.\n    \"\"\"\n    if not edges:\n        return 0\n\n    adj = {v: [] for v in vertices}\n    for u, v_node in edges:\n        adj[u].append(v_node)\n        adj[v_node].append(u)\n\n    min_cycle_len = float('inf')\n\n    for u, v in edges:\n        # We perform a BFS to find the shortest path from u to v\n        # in the graph G' = G - {u, v}.\n        \n        distances = {node: -1 for node in vertices}\n        q = collections.deque()\n\n        # Initialize BFS from u, but do not traverse the edge {u, v}.\n        # This is done by adding all neighbors of u, except for v,\n        # to the queue as the starting points of the search.\n        distances[u] = 0\n        for neighbor in adj[u]:\n            if neighbor != v:\n                distances[neighbor] = 1\n                q.append((neighbor, 1))\n\n        path_found = False\n        path_len = -1\n        \n        while q:\n            current_node, dist = q.popleft()\n\n            if current_node == v:\n                path_len = dist\n                path_found = True\n                break # Found the shortest path, no need to search further for this edge\n\n            for neighbor in adj[current_node]:\n                if distances[neighbor] == -1:\n                    distances[neighbor] = dist + 1\n                    q.append((neighbor, dist + 1))\n        \n        if path_found:\n            cycle_len = path_len + 1\n            min_cycle_len = min(min_cycle_len, cycle_len)\n    \n    if min_cycle_len == float('inf'):\n        return 0\n    else:\n        return int(min_cycle_len)\n\nsolve()\n```"
        },
        {
            "introduction": "除了寻找最短环路，一个更普遍的任务是检测并计数一个图中的所有简单环路。本练习要求你对比两种截然不同的方法：一种是利用矩阵幂的迹（trace）的优雅代数方法，另一种是运用深度优先搜索（DFS）的直接算法枚举 。完成此练习将有助于你厘清“闭合游走”与严格定义的“简单环路”之间的关键区别，这是网络分析中一个常见的混淆点。",
            "id": "4296197",
            "problem": "考虑一个有限有向图，其包含 $n$ 个标记为 $\\{0,1,\\dots,n-1\\}$ 的顶点和一个二元邻接矩阵 $A \\in \\{0,1\\}^{n \\times n}$，其中当且仅当存在一条从顶点 $i$ 到顶点 $j$ 的有向边时，$A_{ij} = 1$，否则 $A_{ij} = 0$。请使用以下基本依据：\n\n- 有向游走的定义：一个顶点序列 $(v_0, v_1, \\dots, v_k)$，满足对于所有 $t \\in \\{0,1,\\dots,k-1\\}$ 都有 $A_{v_{t} v_{t+1}} = 1$。\n- 代数图论中一个经过充分验证的事实：对于任意整数 $k \\ge 1$，$A^k$ 的 $(i,j)$ 项等于从 $i$到 $j$ 的长度为 $k$ 的有向游走数量。特别地，$\\operatorname{tr}(A^k) = \\sum_{i=0}^{n-1} (A^k)_{ii}$ 等于所有起点和终点相同的长度为 $k$ 的闭合游走数量。\n\n一个长度为 $k$ 的简单有向环是一个长度为 $k$ 的闭合有向游走，除了起点/终点的重复外，它恰好访问 $k$ 个不同顶点一次。您的任务是设计一种算法，通过计算 $A$ 的幂的迹来检测是否存在至少一个长度有界（长度为 $k$ 或更小）的简单有向环，并对使用迹进行计数时可能出现的假阳性进行论证和实证说明。这种假阳性源于闭合游走中的回溯和重复顶点。\n\n您的任务：\n\n- 根据上述第一性原理，推导出一个检测规则，用于判断是否存在至少一个长度不超过 $k$ 的简单有向环，该规则使用 $\\operatorname{tr}(A^\\ell)$（其中 $\\ell \\in \\{1,2,\\dots,k\\}$）。\n- 基于 $A$ 的幂的迹，定义一个关于长度不超过 $k$ 的简单有向环数量的整数值上界。\n- 通过深度优先搜索 (Depth-First Search, DFS) 实现一个精确的枚举程序，该程序通过直接强制顶点不重复和使用规范化规则来避免旋转重复，从而计算长度不超过 $k$ 的简单有向环的数量，并将其与您基于迹的上界进行比较，以实证地揭示由回溯和重复顶点引起的假阳性的大小。\n\n您必须实现一个单一程序，对于每个测试用例，返回两个整数：基于迹的上界（使用向上取整函数（ceiling function）四舍五入到最近的整数以确保它是一个上界）和长度不超过 $k$ 的简单有向环的精确枚举计数。最终输出必须将所有测试用例的结果聚合为单行，格式为方括号内以逗号分隔的列表。\n\n测试套件（每个测试用例提供一个邻接矩阵 $A$ 和一个界限 $k$）：\n\n- 测试用例 1：$A$ 是顶点集 $\\{0,1,2\\}$ 上的有向 3-环，其边为 $(0 \\to 1)$、$(1 \\to 2)$、$(2 \\to 0)$，即：\n  $$\n  A = \\begin{pmatrix}\n  0  1  0 \\\\\n  0  0  1 \\\\\n  1  0  0\n  \\end{pmatrix},\n  $$\n  且 $k = 3$。\n- 测试用例 2：$A$ 是顶点集 $\\{0,1\\}$ 上的有向 2-环，其边为 $(0 \\to 1)$、$(1 \\to 0)$，即：\n  $$\n  A = \\begin{pmatrix}\n  0  1 \\\\\n  1  0\n  \\end{pmatrix},\n  $$\n  且 $k = 4$。\n- 测试用例 3：$A$ 是一个 3-顶点图，在顶点 0 处有一个自环，并有一个有向 3-环 $(0 \\to 1 \\to 2 \\to 0)$，即：\n  $$\n  A = \\begin{pmatrix}\n  1  1  0 \\\\\n  0  0  1 \\\\\n  1  0  0\n  \\end{pmatrix},\n  $$\n  且 $k = 3$。\n- 测试用例 4：$A$ 是一个有向无环图 (DAG)，是 $\\{0,1,2,3\\}$ 上的链，其边为 $(0 \\to 1)$、$(1 \\to 2)$、$(2 \\to 3)$，即：\n  $$\n  A = \\begin{pmatrix}\n  0  1  0  0 \\\\\n  0  0  1  0 \\\\\n  0  0  0  1 \\\\\n  0  0  0  0\n  \\end{pmatrix},\n  $$\n  且 $k = 4$。\n- 测试用例 5：$A$ 是一个 5-顶点图，由一个有向 3-环 $(0 \\to 1 \\to 2 \\to 0)$ 和一个不相交的有向 2-环 $(3 \\to 4 \\to 3)$ 组成，即：\n  $$\n  A = \\begin{pmatrix}\n  0  1  0  0  0 \\\\\n  0  0  1  0  0 \\\\\n  1  0  0  0  0 \\\\\n  0  0  0  0  1 \\\\\n  0  0  0  1  0\n  \\end{pmatrix},\n  $$\n  且 $k = 3$。\n\n答案规格：\n\n- 对于每个测试用例，计算基于迹的上界\n  $$\n  U_k \\equiv \\left\\lceil \\sum_{\\ell=1}^{k} \\frac{\\operatorname{tr}(A^\\ell)}{\\ell} \\right\\rceil,\n  $$\n  并使用带有顶点不重复和用于避免旋转重复的规范化规则的 DFS 计算长度不超过 $k$ 的简单有向环的精确计数 $E_k$。\n- 您的程序应生成单行输出，其中包含一个方括号内的逗号分隔列表，按测试用例排序，且每个测试用例的结果首先包含 $U_k$ 然后是 $E_k$。例如，输出格式必须为\n  $$\n  [U_1,E_1,U_2,E_2,U_3,E_3,U_4,E_4,U_5,E_5].\n  $$\n- 所有输出均为无单位整数。\n\n该问题纯粹是数学和算法问题，要求基于所提供的基本定义和事实进行严谨的推理。不涉及物理单位、角度单位或百分比单位。选择的测试用例旨在涵盖：包含单个简单环的一般情况、多次遍历导致迹计数膨胀的情况、包含自环和环的情况、无环图的边界情况以及多环情况。",
            "solution": "该问题要求推导一种基于迹的方法来检测和限定简单有向环的数量，并实现一个精确的枚举算法进行比较。解决方案分为两部分：基于迹方法的理论推导和精确计数方法的算法设计。\n\n### 第 1 部分：基于迹的环检测和上界\n\n此方法的基础是代数图论中的一个事实，即矩阵幂 $A^k$ 的 $(i,j)$ 项给出了从顶点 $i$ 到顶点 $j$ 的长度为 $k$ 的不同有向游走数量。因此，$A^k$ 的迹，记为 $\\operatorname{tr}(A^k) = \\sum_{i=0}^{n-1} (A^k)_{ii}$，给出了图中长度为 $k$ 的闭合有向游走的总数。\n\n长度为 $\\ell$ 的简单有向环是一种特殊的长度为 $\\ell$ 的闭合游走，其中除了起点和终点重合外，所有顶点都是不同的。一个关键的观察是，任何闭合游走必定包含至少一个简单环。要理解这一点，考虑一个闭合游走 $W=(v_0, v_1, \\dots, v_\\ell=v_0)$。如果 $W$ 不是简单的，那么在序列 $v_0, \\dots, v_{\\ell-1}$ 中至少有一个顶点被重复。设对于某个 $0 \\le i  j  \\ell$ 有 $v_i = v_j$。那么子游走 $(v_i, v_{i+1}, \\dots, v_j)$ 就是一个更短的闭合游走。这个简化过程可以反复应用，直到找到一个没有重复中间顶点的闭合游走，根据定义，这就是一个简单环。所得简单环的长度最多为原始游走的长度。\n\n**检测规则：**\n基于以上推理，存在长度为 $\\ell \\in \\{1, 2, \\dots, k\\}$ 的闭合游走意味着存在长度不超过 $\\ell$ 的简单有向环。长度不超过 $k$ 的闭合游走总数由 $\\sum_{\\ell=1}^k \\operatorname{tr}(A^\\ell)$ 给出。因此，一个稳健的检测规则如下：当且仅当 $\\sum_{\\ell=1}^k \\operatornametr(A^\\ell) > 0$ 时，存在长度不超过 $k$ 的简单有向环。任何幂次 $\\ell \\ge 1$ 的非零迹都表示存在闭合游走，从而保证了简单环的存在。\n\n**上界推导：**\n问题提供了公式 $U_k \\equiv \\left\\lceil \\sum_{\\ell=1}^{k} \\frac{\\operatorname{tr}(A^\\ell)}{\\ell} \\right\\rceil$ 作为长度不超过 $k$ 的简单有向环数量的上界。我们来分析其组成部分。\n一个长度为 $\\ell$ 的简单环可以表示为 $\\ell$ 个不同的闭合游走，每个游走从其 $\\ell$ 个顶点中的一个开始。例如，环 $(v_0 \\to v_1 \\to \\dots \\to v_{\\ell-1} \\to v_0)$ 会产生闭合游走 $(v_0, \\dots, v_0)$、$(v_1, \\dots, v_1)$ 等等。所有这 $\\ell$ 个游走都被计入 $\\operatorname{tr}(A^\\ell)$ 中。将 $\\operatorname{tr}(A^\\ell)$ 除以 $\\ell$ 是为了尝试将该环本身只计数一次。\n\n然而，$\\operatorname{tr}(A^\\ell)$ 也包含来自非简单闭合游走的贡献，这些非简单闭合游走是“假阳性”的来源，并导致该方法成为一个上界而不是精确计数。这些非简单的游走包括：\n1.  **复合游走**：遍历一个长度为 $d$（其中 $d$ 是 $\\ell$ 的因子）的简单环共 $\\ell/d$ 次。例如，一个 2-环遍历两次是一个长度为 4 的闭合游走。\n2.  **带有偏移或回溯的游走**：指离开一个顶点，沿一条路径行进，然后返回的游走。例如，$i \\to j \\to i$ 是一个长度为 2 的闭合游走，但只有当 $i \\ne j$ 时才构成一个简单的 2-环。\n\n因此，公式 $\\sum_{\\ell=1}^{k} \\frac{\\operatorname{tr}(A^\\ell)}{\\ell}$ 汇总了所有长度不超过 $k$ 的这些估计值。由于每一项 $\\frac{\\operatorname{tr}(A^\\ell)}{\\ell}$ 都过多地或正确地计算了长度为 $\\ell$ 的简单环，总和是对长度不超过 $k$ 的简单环真实数量的过高估计。应用向上取整函数 $\\lceil \\cdot \\rceil$ 是为了确保最终的界限是一个整数。\n\n为了计算给定邻接矩阵 $A$ 和界限 $k$ 的 $U_k$，我们从 1 到 $k$ 遍历 $\\ell$。在每次迭代中，我们使用矩阵求幂计算 $A^\\ell$，找到其迹 $\\operatorname{tr}(A^\\ell)$，除以 $\\ell$，并累加结果。最终的总和向上取整到最近的整数。\n\n### 第 2 部分：使用深度优先搜索 (DFS) 进行精确枚举\n\n为了获得简单有向环的精确计数 $E_k$，我们必须显式地枚举它们。深度优先搜索 (DFS) 是探索图中路径的一种自然的算法选择。其核心思想是，从每个顶点出发，找到所有能回到该顶点自身的简单路径，从而形成环。\n\n该算法的结构如下：\n1.  **图表示**：将邻接矩阵 $A$ 转换为邻接表，以便在遍历过程中高效查找邻居。\n2.  **遍历起始顶点**：从图中的每个顶点 $s \\in \\{0, 1, \\dots, n-1\\}$ 开始搜索。这确保了所有可能的环都能被发现。\n3.  **DFS 遍历**：对每个 `start_node` $s$ 执行递归 DFS。DFS 函数维护当前 `path`（一个顶点列表）和一个 `visited` 集合，用于 O(1) 时间复杂度的检查，以强制执行“简单”约束（无重复顶点）。\n    - 递归从当前顶点 $u$ 进行到其邻居 $v$。\n    - 如果邻居 $v$ 与 `start_node` 相同，则找到了一个环。该环的长度是当前 `path` 中的顶点数。\n    - 如果邻居 $v$ 在当前 `path` 中未被访问过，则从 $v$ 继续递归进行 DFS，将 $v$ 添加到 `path` 和 `visited` 集合中。递归调用返回后，将 $v$ 移除（回溯），以便探索其他路径。\n4.  **长度约束**：进行搜索剪枝。如果扩展路径会使其长度超过允许的最大环长度 $k$，则停止递归。\n5.  **规范化与计数**：一个长度为 $\\ell$ 的简单环将被发现 $\\ell$ 次，即其每个顶点作为 `start_node` 时都会被发现一次。为确保每个唯一的环只被计数一次，我们使用一种规范表示。一个方便的选择是环中顶点的排序元组。例如，路径 `[0, 1, 2]`、`[1, 2, 0]` 和 `[2, 0, 1]` 都对应同一个 3-环。它们的规范表示将是 `(0, 1, 2)`。这些规范形式存储在一个 `set` 中以自动丢弃重复项。\n6.  **最终计数**：长度不超过 $k$ 的简单环的精确数量，记为 $E_k$，是这个规范表示集合的最终大小。\n\n这种基于 DFS 的方法通过直接强制执行简单环的定义并采用规范化规则来防止因旋转对称性而导致的重复计数，从而保证了计数的精确性。$U_k$ 和 $E_k$ 的比较将实证地展示基于迹的方法固有的高估问题。",
            "answer": "```python\nimport numpy as np\nimport math\n\ndef calculate_trace_bound(A, k):\n    \"\"\"\n    Calculates the trace-based upper bound Uk for simple cycles of length up to k.\n    Uk = ceil(sum_l=1^k (tr(A^l) / l))\n    \"\"\"\n    total_trace_term = 0.0\n    n = A.shape[0]\n\n    # Use numpy's matrix_power for robust and efficient power calculation\n    for l in range(1, k + 1):\n        if n > 0:\n            A_power = np.linalg.matrix_power(A.astype(np.float64), l)\n            trace_val = np.trace(A_power)\n            total_trace_term += trace_val / l\n\n    return math.ceil(total_trace_term)\n\ndef find_exact_cycles(A, k):\n    \"\"\"\n    Finds the exact number of simple directed cycles of length up to k using DFS.\n    \"\"\"\n    n = A.shape[0]\n    adj = {i: [j for j, connected in enumerate(row) if connected] for i, row in enumerate(A)}\n    found_cycles = set()\n\n    for start_node in range(n):\n        # The path starts with the start_node\n        path = [start_node]\n        # Visited set for O(1) lookups\n        visited = {start_node}\n        dfs_recursive(start_node, start_node, path, visited, k, adj, found_cycles)\n        \n    return len(found_cycles)\n\ndef dfs_recursive(start_node, u, path, visited, max_len, adj, found_cycles):\n    \"\"\"\n    Recursive DFS helper function to find simple cycles.\n    \"\"\"\n    path_len = len(path)\n\n    # Explore neighbors of the current node u\n    for v in adj.get(u, []):\n        # A cycle is found if the neighbor is the start_node.\n        # The cycle length is path_len (number of vertices/edges in the cycle).\n        if v == start_node:\n            if path_len = max_len:\n                # Canonical form is the sorted tuple of vertices to handle rotations\n                canonical_form = tuple(sorted(path))\n                found_cycles.add(canonical_form)\n        \n        # If neighbor is not visited and path is not too long, continue the path\n        elif v not in visited:\n            if path_len  max_len:\n                visited.add(v)\n                path.append(v)\n                dfs_recursive(start_node, v, path, visited, max_len, adj, found_cycles)\n                path.pop()\n                visited.remove(v)\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        # Test case 1\n        (np.array([[0, 1, 0], [0, 0, 1], [1, 0, 0]]), 3),\n        # Test case 2\n        (np.array([[0, 1], [1, 0]]), 4),\n        # Test case 3\n        (np.array([[1, 1, 0], [0, 0, 1], [1, 0, 0]]), 3),\n        # Test case 4\n        (np.array([[0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1], [0, 0, 0, 0]]), 4),\n        # Test case 5\n        (np.array([\n            [0, 1, 0, 0, 0],\n            [0, 0, 1, 0, 0],\n            [1, 0, 0, 0, 0],\n            [0, 0, 0, 0, 1],\n            [0, 0, 0, 1, 0]\n        ]), 3),\n    ]\n\n    results = []\n    for A, k in test_cases:\n        U_k = calculate_trace_bound(A, k)\n        E_k = find_exact_cycles(A, k)\n        results.extend([U_k, E_k])\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "路径，特别是被称为测地线（geodesics）的最短路径，不仅仅是结构特征，它们还是网络中信息流与影响力的通道。本练习将指导你计算介数中心性（betweenness centrality），以此展示最短路径的实际重要性 。这个度量基于通过一个节点的最短路径的比例来衡量其影响力，从而将抽象的路径枚举与识别复杂系统中关键节点的具体应用联系起来。",
            "id": "4296207",
            "problem": "考虑一个无向加权图 $G$，其节点集为 $V=\\{s,a,b,r,v,t\\}$，正边权具体如下：$w(s,a)=1$，$w(s,b)=1$，$w(a,v)=1$，$w(b,v)=1$，$w(a,r)=1$，$w(b,r)=1$，$w(v,t)=1$ 以及 $w(r,t)=1$。$G$ 中没有其他边。在这个图中，某些节点对之间存在多条不同的最短路径（测地线）；例如，节点 $s$ 和 $t$ 之间。\n\n从加权路径长度（路径上边权之和）、测地距离（两节点间的最小加权路径长度）以及无向加权图中节点介数中心性（其中，来自源-目标对 $\\{s,t\\}$ 的贡献是经过该节点的最短路径所占的比例）的核心定义出发，推导并计算节点 $v$ 的归一化介数中心性。\n\n使用无向图的标准归一化方法，该方法将成对贡献的原始总和除以不包含 $v$ 的无序源-目标对的数量，使得可能的最大归一化值为 $1$。请提供一个精确值。将最终答案表示为一个精确的有理数，不进行四舍五入且不带单位。",
            "solution": "我们从与无向加权图相关的基本定义开始：\n- 路径的长度是该路径上边权的总和。\n- 两个节点 $x$ 和 $y$ 之间的测地距离是连接 $x$ 和 $y$ 的所有路径中的最小路径长度。\n- 令 $\\sigma_{xy}$ 表示 $x$ 和 $y$ 之间不同最短路径（测地线）的数量，令 $\\sigma_{xy}(v)$ 表示其中经过节点 $v$（$v\\notin\\{x,y\\}$）的最短路径数量。\n- 节点 $v$ 的原始节点介数中心性定义为\n$$\ng(v)=\\sum_{\\substack{s,t\\in V\\\\ s\\neq v\\neq t\\\\ s\\neq t}}\\frac{\\sigma_{st}(v)}{\\sigma_{st}}\\,,\n$$\n其中，在无向图的情况下，求和是针对所有无序对 $\\{s,t\\}$。\n- 归一化介数中心性是将 $g(v)$ 除以不包含 $v$ 的无序源-目标对的总数，对于一个有 $n$ 个节点的图，这个总数是 $\\frac{(n-1)(n-2)}{2}$。这里 $n=|V|=6$，所以归一化因子是 $\\frac{(6-1)(6-2)}{2}=\\frac{5\\cdot 4}{2}=10$。\n\n我们将通过枚举 $V\\setminus\\{v\\}=\\{s,a,b,r,t\\}$ 中所有的无序对来计算 $g(v)$，这会得到 $\\binom{5}{2}=10$ 对。对于每一对，我们识别出所有的最短路径，计算 $\\sigma_{st}$ 和 $\\sigma_{st}(v)$，并将 $\\frac{\\sigma_{st}(v)}{\\sigma_{st}}$ 加到 $g(v)$ 上。\n\n因为所有给定边的权重都为 $1$，所以路径长度就是经过的边的数量。\n\n列出节点对并进行分析：\n\n1. 节点对 $\\{s,a\\}$：权重为 $1$ 的边 $(s,a)$ 是一条最短路径。任何经过 $v$ 的路径长度至少为 $2$，因此不是最短路径。所以 $\\sigma_{sa}=1$ 且 $\\sigma_{sa}(v)=0$，贡献为 $0$。\n\n2. 节点对 $\\{s,b\\}$：根据与 $\\{s,a\\}$ 的对称性，权重为 $1$ 的直连边 $(s,b)$ 是唯一的最短路径。因此 $\\sigma_{sb}=1$，$\\sigma_{sb}(v)=0$，贡献为 $0$。\n\n3. 节点对 $\\{s,r\\}$：路径 $s\\to a\\to r$ 和 $s\\to b\\to r$ 的长度都为 $2$，都是最短路径。任何绕道经过 $v$ 的路径都更长。因此 $\\sigma_{sr}=2$ 且 $\\sigma_{sr}(v)=0$，贡献为 $0$。\n\n4. 节点对 $\\{s,t\\}$：以下四条长度为 $3$ 的路径是最短路径：\n- $s\\to a\\to v\\to t$，\n- $s\\to b\\to v\\to t$，\n- $s\\to a\\to r\\to t$，\n- $s\\to b\\to r\\to t$。\n在这些路径中，恰好有两条经过 $v$。因此 $\\sigma_{st}=4$ 且 $\\sigma_{st}(v)=2$，贡献为 $\\frac{2}{4}=\\frac{1}{2}$。\n\n5. 节点对 $\\{a,b\\}$：所有 $a$ 和 $b$ 之间长度为 $2$ 的路径都是最短路径。共有三条这样的路径：\n- $a\\to s\\to b$，\n- $a\\to v\\to b$，\n- $a\\to r\\to b$。\n其中恰好有一条经过 $v$。因此 $\\sigma_{ab}=3$ 且 $\\sigma_{ab}(v)=1$，贡献为 $\\frac{1}{3}$。\n\n6. 节点对 $\\{a,r\\}$：权重为 $1$ 的直连边 $(a,r)$ 是唯一的最短路径。因此 $\\sigma_{ar}=1$ 且 $\\sigma_{ar}(v)=0$，贡献为 $0$。\n\n7. 节点对 $\\{a,t\\}$：有两条长度为 $2$ 的最短路径：\n- $a\\to v\\to t$，\n- $a\\to r\\to t$。\n恰好有一条经过 $v$。因此 $\\sigma_{at}=2$ 且 $\\sigma_{at}(v)=1$，贡献为 $\\frac{1}{2}$。\n\n8. 节点对 $\\{b,r\\}$：权重为 $1$ 的直连边 $(b,r)$ 是唯一的最短路径。因此 $\\sigma_{br}=1$ 且 $\\sigma_{br}(v)=0$，贡献为 $0$。\n\n9. 节点对 $\\{b,t\\}$：根据与 $\\{a,t\\}$ 的对称性，有两条长度为 $2$ 的最短路径：\n- $b\\to v\\to t$，\n- $b\\to r\\to t$。\n恰好有一条经过 $v$。因此 $\\sigma_{bt}=2$ 且 $\\sigma_{bt}(v)=1$，贡献为 $\\frac{1}{2}$。\n\n10. 节点对 $\\{r,t\\}$：权重为 $1$ 的直连边 $(r,t)$ 是唯一的最短路径。因此 $\\sigma_{rt}=1$ 且 $\\sigma_{rt}(v)=0$，贡献为 $0$。\n\n将所有贡献相加，我们得到\n$$\ng(v)=0+0+0+\\frac{1}{2}+\\frac{1}{3}+0+\\frac{1}{2}+0+\\frac{1}{2}+0=\\frac{3}{2}+\\frac{1}{3}=\\frac{9}{6}+\\frac{2}{6}=\\frac{11}{6}.\n$$\n\n当 $n=6$ 时，不包含 $v$ 的无序源-目标对的数量是\n$$\n\\frac{(n-1)(n-2)}{2}=\\frac{(6-1)(6-2)}{2}=\\frac{5\\cdot 4}{2}=10.\n$$\n因此，节点 $v$ 的归一化介数中心性是\n$$\ng'(v)=\\frac{g(v)}{10}=\\frac{\\frac{11}{6}}{10}=\\frac{11}{60}.\n$$\n\n这就是所要求的精确归一化值。",
            "answer": "$$\\boxed{\\frac{11}{60}}$$"
        }
    ]
}