{
    "hands_on_practices": [
        {
            "introduction": "The girth, defined as the length of the shortest cycle in a graph, is a fundamental property that characterizes the local topology of a network. This exercise provides a hands-on opportunity to compute this important metric by systematically exploring the graph's structure. You will implement an algorithm based on Breadth-First Search (BFS), reinforcing your understanding of how this traversal method can be adapted to find shortest paths and detect cycles .",
            "id": "4296170",
            "problem": "Let $G=(V,E)$ be a finite, simple, undirected graph. A walk is a finite sequence of vertices in which consecutive vertices are adjacent, a path is a walk with all vertices distinct, and a cycle is a closed walk with all vertices distinct except for the first and last. The girth of $G$, denoted $g(G)$, is defined as the length of the shortest cycle in $G$. If $G$ has no cycle, then its girth is conventionally taken to be $+\\infty$, and in this problem you must report the value $0$ in that case.\n\nYour task is to implement a complete program that computes $g(G)$ for each graph in the provided test suite using a method based on Breadth-First Search (BFS) layers and chord detection. The method must adhere to the following outline:\n\n- For each undirected edge $e=\\{u,v\\}\\in E$ treat $e$ as a prospective chord that would close a cycle when combined with a path connecting $u$ and $v$. Using BFS layers from one endpoint, detect the shortest path connecting the endpoints while deliberately ignoring traversal of $e$ itself to avoid a trivial path. Interpret the presence of such a path as certifying a cycle formed by that path together with $e$ and record its length. Over all edges, return the minimum such cycle length as the girth.\n- If no cycle is detected for any edge, then report the girth as $0$.\n\nYou must implement this BFS-and-chord-detection approach without resorting to any shortcut formulas; the program must rely only on the core definitions of walks, paths, cycles, and the BFS property that it discovers shortest paths in unweighted graphs.\n\nTest suite specification. For each test case, the graph is given by its vertex set and undirected edge set. All graphs are finite and simple.\n\n- Test case $1$: $V=\\{\\,0,1,2\\,\\}$, $E=\\{\\,\\{0,1\\},\\{1,2\\},\\{2,0\\}\\,\\}$.\n- Test case $2$: $V=\\{\\,0,1,2,3\\,\\}$, $E=\\{\\,\\{0,1\\},\\{1,2\\},\\{2,3\\},\\{3,0\\}\\,\\}$.\n- Test case $3$: $V=\\{\\,0,1,2,3\\,\\}$, $E=\\{\\,\\{0,1\\},\\{1,2\\},\\{2,3\\}\\,\\}$.\n- Test case $4$: $V=\\{\\,0,1,2,3,4,5\\,\\}$, $E=\\{\\,\\{0,1\\},\\{1,2\\},\\{2,0\\},\\{2,3\\},\\{3,4\\},\\{4,5\\}\\,\\}$. This graph is disconnected; one component contains a triangle.\n- Test case $5$: $V=\\{\\,0,1,2,3,4,5\\,\\}$, $E=\\{\\,\\{0,1\\},\\{1,2\\},\\{3,4\\},\\{4,5\\},\\{0,3\\},\\{1,4\\},\\{2,5\\}\\,\\}$.\n\nRequired output. Your program should produce a single line of output containing the results for the five test cases as a comma-separated list enclosed in square brackets. Each entry must be an integer: the girth in number of edges, with acyclic graphs reported as $0$, aggregated in the order of the test cases above. For example, the output format must look like a single line of the form \"[x1,x2,x3,x4,x5]\" where each $x_i$ is the computed girth for test case $i$.",
            "solution": "The problem requires the computation of the girth $g(G)$ of a given finite, simple, undirected graph $G=(V,E)$. The girth is defined as the length of the shortest cycle in $G$. By convention, if $G$ is acyclic (contains no cycles), its girth is $+\\infty$; however, the problem specifies that a value of $0$ must be reported in this case. The solution must adhere to a specified algorithm based on Breadth-First Search (BFS) and chord detection.\n\nThe fundamental principle of the algorithm is as follows: any cycle in the graph $G$ can be viewed as an edge $\\{u,v\\} \\in E$, which acts as a \"chord,\" closing a path between its endpoints $u$ and $v$. The length of such a cycle is the length of the path plus the length of the closing edge, which is $1$. To find the shortest possible cycle, we must find the shortest path between the endpoints of some edge. Let this path length be $d$. The corresponding cycle length will be $d+1$. The girth of the graph, $g(G)$, will be the minimum such cycle length found by considering every edge in $E$ as a potential chord.\n\nMore formally, for any edge $e=\\{u,v\\} \\in E$, the shortest cycle containing $e$ is formed by $e$ itself and the shortest path between $u$ and $v$ in the subgraph $G' = (V, E \\setminus \\{e\\})$. Let the length of this shortest path be denoted $d_{G'}(u,v)$. The length of this cycle is then $d_{G'}(u,v) + 1$. The girth of the entire graph $G$ is the minimum of these values over all edges:\n$$ g(G) = \\min_{\\{u,v\\} \\in E} \\left( d_{G'}(u,v) + 1 \\right) $$\nIf for some edge $\\{u,v\\}$, no path exists between $u$ and $v$ in $G'$, then $d_{G'}(u,v) = +\\infty$. If this is the case for all edges, the graph is acyclic.\n\nThe algorithm proceeds as follows:\n1.  Initialize a variable for the minimum cycle length found, $g_{\\min}$, to a value representing infinity, e.g., $g_{\\min} \\leftarrow +\\infty$.\n2.  Construct an adjacency list representation of the graph $G$ from the given vertex set $V$ and edge set $E$.\n3.  Iterate through each edge $\\{u,v\\} \\in E$. For each edge, perform the following steps to calculate the length of the shortest cycle that includes it:\n    a. We need to find the shortest path distance $d_{G'}(u,v)$ in the graph $G' = (V, E \\setminus \\{\\{u,v\\}\\})$. This is accomplished by running a Breadth-First Search (BFS), which is guaranteed to find shortest paths in an unweighted graph.\n    b. A standard BFS from $u$ in graph $G$ would immediately find $v$ as a neighbor at distance $1$, corresponding to traversing the edge $\\{u,v\\}$ itself. To enforce the search within $G'$, we must \"deliberately ignore\" this traversal. This is achieved by modifying the BFS initialization.\n    c. Instead of placing only the source vertex $u$ into the queue, we begin the search from all neighbors of $u$ *except* for $v$. Let $N(u)$ be the set of neighbors of $u$. The BFS queue is initialized with all vertices $w \\in N(u) \\setminus \\{v\\}$. Each such vertex $w$ is added to the queue with an initial path length of $1$. We also mark $u$ and all these initial neighbors as visited to prevent cycles in the BFS tree.\n    d. The BFS then proceeds in its standard manner, exploring the graph layer by layer. It terminates when the target vertex $v$ is reached. The distance recorded for $v$, let's call it $d_{\\text{path}}$, is the length of the shortest path from $u$ to $v$ in $G'$.\n    e. If the BFS completes without reaching $v$, no alternative path exists, and we proceed to the next edge.\n    f. If a path of length $d_{\\text{path}}$ is found, this corresponds to a cycle of length $d_{\\text{path}} + 1$. We update our minimum found length: $g_{\\min} \\leftarrow \\min(g_{\\min}, d_{\\text{path}} + 1)$.\n4.  After iterating through all edges in $E$, if $g_{\\min}$ remains at its initial value of $+\\infty$, it signifies that no cycles were found. In this scenario, the function returns $0$. Otherwise, it returns the computed value of $g_{\\min}$ as the girth of the graph.\n\nThis method systematically checks all minimal cycles associated with each edge and correctly identifies the global minimum, the girth, by leveraging the property that BFS finds shortest paths in unweighted graphs.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport collections\n\ndef solve():\n    \"\"\"\n    Main solver function to compute the girth for all test cases.\n    \"\"\"\n    # Test suite specification.\n    test_cases = [\n        # Test case 1: A triangle graph\n        {\"V\": {0, 1, 2}, \"E\": [{0, 1}, {1, 2}, {2, 0}]},\n        # Test case 2: A square graph (4-cycle)\n        {\"V\": {0, 1, 2, 3}, \"E\": [{0, 1}, {1, 2}, {2, 3}, {3, 0}]},\n        # Test case 3: A path graph (acyclic)\n        {\"V\": {0, 1, 2, 3}, \"E\": [{0, 1}, {1, 2}, {2, 3}]},\n        # Test case 4: A disconnected graph with a triangle component\n        {\"V\": {0, 1, 2, 3, 4, 5}, \"E\": [{0, 1}, {1, 2}, {2, 0}, {2, 3}, {3, 4}, {4, 5}]},\n        # Test case 5: A prism graph (girth is 4)\n        {\"V\": {0, 1, 2, 3, 4, 5}, \"E\": [{0, 1}, {1, 2}, {3, 4}, {4, 5}, {0, 3}, {1, 4}, {2, 5}]}\n    ]\n\n    results = []\n    for case in test_cases:\n        vertices = case[\"V\"]\n        # Convert set of sets to a list of tuples for easier iteration\n        edges = [tuple(e) for e in case[\"E\"]]\n        girth = _calculate_girth(vertices, edges)\n        results.append(girth)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef _calculate_girth(vertices, edges):\n    \"\"\"\n    Calculates the girth of a graph using a BFS-based approach for each edge.\n    \n    Args:\n        vertices (set): The set of vertices in the graph.\n        edges (list of tuples): The list of edges in the graph.\n        \n    Returns:\n        int: The girth of the graph, or 0 if the graph is acyclic.\n    \"\"\"\n    if not edges:\n        return 0\n\n    adj = {v: [] for v in vertices}\n    for u, v_node in edges:\n        adj[u].append(v_node)\n        adj[v_node].append(u)\n\n    min_cycle_len = float('inf')\n\n    for u, v in edges:\n        # We perform a BFS to find the shortest path from u to v\n        # in the graph G' = G - {u, v}.\n        \n        distances = {node: -1 for node in vertices}\n        q = collections.deque()\n\n        # Initialize BFS from u, but do not traverse the edge {u, v}.\n        # This is done by adding all neighbors of u, except for v,\n        # to the queue as the starting points of the search.\n        distances[u] = 0\n        for neighbor in adj[u]:\n            if neighbor != v:\n                distances[neighbor] = 1\n                q.append((neighbor, 1))\n\n        path_found = False\n        path_len = -1\n        \n        while q:\n            current_node, dist = q.popleft()\n\n            if current_node == v:\n                path_len = dist\n                path_found = True\n                break # Found the shortest path, no need to search further for this edge\n\n            for neighbor in adj[current_node]:\n                if distances[neighbor] == -1:\n                    distances[neighbor] = dist + 1\n                    q.append((neighbor, dist + 1))\n        \n        if path_found:\n            cycle_len = path_len + 1\n            min_cycle_len = min(min_cycle_len, cycle_len)\n    \n    if min_cycle_len == float('inf'):\n        return 0\n    else:\n        return int(min_cycle_len)\n\nsolve()\n```"
        },
        {
            "introduction": "Betweenness centrality quantifies a node's importance by measuring how often it lies on the shortest paths connecting other nodes. This hands-on calculation challenges you to compute this metric in a graph specifically designed to have multiple shortest paths, or geodesics, between certain node pairs. By carefully enumerating these paths and applying the formal definition, you will develop a deep and precise understanding of how this crucial centrality measure is derived and normalized .",
            "id": "4296207",
            "problem": "Consider an undirected weighted graph $G$ with node set $V=\\{s,a,b,r,v,t\\}$ and positive edge weights specified as follows: $w(s,a)=1$, $w(s,b)=1$, $w(a,v)=1$, $w(b,v)=1$, $w(a,r)=1$, $w(b,r)=1$, $w(v,t)=1$, and $w(r,t)=1$. There are no other edges in $G$. In this graph, multiple distinct shortest paths (geodesics) exist between certain node pairs; for example, between $s$ and $t$.\n\nStarting from the core definitions of weighted path length (sum of edge weights along a path), geodesic distance (minimum weighted path length between two nodes), and node betweenness centrality in undirected weighted graphs (where the contribution from a source-target pair $\\{s,t\\}$ is the fraction of geodesics that traverse the node), derive and compute the normalized betweenness centrality of node $v$.\n\nUse the standard normalization for undirected graphs that divides the raw sum of pairwise contributions by the number of unordered source-target pairs that exclude $v$, so that the maximum possible normalized value is $1$. Provide an exact value. Express your final answer as an exact rational number without rounding and without units.",
            "solution": "We begin from the foundational definitions relevant to undirected weighted graphs:\n- The length of a path is the sum of the edge weights along that path.\n- The geodesic distance between two nodes $x$ and $y$ is the minimum path length over all paths joining $x$ and $y$.\n- Let $\\sigma_{xy}$ denote the number of distinct geodesics (shortest paths) between $x$ and $y$, and let $\\sigma_{xy}(v)$ denote the number of those geodesics that pass through node $v$ (with $v\\notin\\{x,y\\}$).\n- The raw node betweenness centrality of $v$ is defined by\n$$\ng(v)=\\sum_{\\substack{s,t\\in V\\\\ s\\neq v\\neq t\\\\ s\\neq t}}\\frac{\\sigma_{st}(v)}{\\sigma_{st}}\\,,\n$$\nwhere the sum is over unordered pairs $\\{s,t\\}$ in the undirected case.\n- The normalized betweenness centrality divides $g(v)$ by the total number of unordered source-target pairs that exclude $v$, which is $\\frac{(n-1)(n-2)}{2}$ for a graph with $n$ nodes. Here $n=|V|=6$, so the normalization factor is $\\frac{(6-1)(6-2)}{2}=\\frac{5\\cdot 4}{2}=10$.\n\nWe will compute $g(v)$ by enumerating all unordered pairs in $V\\setminus\\{v\\}=\\{s,a,b,r,t\\}$, which yields $\\binom{5}{2}=10$ pairs. For each pair, we identify all geodesics, count $\\sigma_{st}$ and $\\sigma_{st}(v)$, and add $\\frac{\\sigma_{st}(v)}{\\sigma_{st}}$ to $g(v)$.\n\nBecause all given edges have weight $1$, path lengths are simply the number of edges traversed.\n\nList the pairs and analyze:\n\n$1.$ Pair $\\{s,a\\}$: The edge $(s,a)$ of weight $1$ is a geodesic. Any path through $v$ would have length at least $2$, so it is not a geodesic. Hence $\\sigma_{sa}=1$ and $\\sigma_{sa}(v)=0$, contributing $0$.\n\n$2.$ Pair $\\{s,b\\}$: By symmetry with $\\{s,a\\}$, the direct edge $(s,b)$ of weight $1$ is the unique geodesic. Thus $\\sigma_{sb}=1$, $\\sigma_{sb}(v)=0$, contributing $0$.\n\n$3.$ Pair $\\{s,r\\}$: Paths $s\\to a\\to r$ and $s\\to b\\to r$ both have length $2$ and are geodesics. Any route that detours through $v$ is longer. Thus $\\sigma_{sr}=2$ and $\\sigma_{sr}(v)=0$, contributing $0$.\n\n$4.$ Pair $\\{s,t\\}$: The following four length-$3$ paths are geodesics:\n- $s\\to a\\to v\\to t$,\n- $s\\to b\\to v\\to t$,\n- $s\\to a\\to r\\to t$,\n- $s\\to b\\to r\\to t$.\nAmong these, exactly two pass through $v$. Thus $\\sigma_{st}=4$ and $\\sigma_{st}(v)=2$, contributing $\\frac{2}{4}=\\frac{1}{2}$.\n\n$5.$ Pair $\\{a,b\\}$: All length-$2$ paths between $a$ and $b$ are geodesics. There are three such paths:\n- $a\\to s\\to b$,\n- $a\\to v\\to b$,\n- $a\\to r\\to b$.\nExactly one of these passes through $v$. Thus $\\sigma_{ab}=3$ and $\\sigma_{ab}(v)=1$, contributing $\\frac{1}{3}$.\n\n$6.$ Pair $\\{a,r\\}$: The direct edge $(a,r)$ of weight $1$ is the unique geodesic. Hence $\\sigma_{ar}=1$ and $\\sigma_{ar}(v)=0$, contributing $0$.\n\n$7.$ Pair $\\{a,t\\}$: There are two length-$2$ geodesics:\n- $a\\to v\\to t$,\n- $a\\to r\\to t$.\nExactly one passes through $v$. Thus $\\sigma_{at}=2$ and $\\sigma_{at}(v)=1$, contributing $\\frac{1}{2}$.\n\n$8.$ Pair $\\{b,r\\}$: The direct edge $(b,r)$ of weight $1$ is the unique geodesic. Hence $\\sigma_{br}=1$ and $\\sigma_{br}(v)=0$, contributing $0$.\n\n$9.$ Pair $\\{b,t\\}$: By symmetry with $\\{a,t\\}$, there are two length-$2$ geodesics:\n- $b\\to v\\to t$,\n- $b\\to r\\to t$.\nExactly one passes through $v$. Thus $\\sigma_{bt}=2$ and $\\sigma_{bt}(v)=1$, contributing $\\frac{1}{2}$.\n\n$10.$ Pair $\\{r,t\\}$: The direct edge $(r,t)$ of weight $1$ is the unique geodesic. Hence $\\sigma_{rt}=1$ and $\\sigma_{rt}(v)=0$, contributing $0$.\n\nSumming the contributions, we obtain\n$$\ng(v)=0+0+0+\\frac{1}{2}+\\frac{1}{3}+0+\\frac{1}{2}+0+\\frac{1}{2}+0=\\frac{3}{2}+\\frac{1}{3}=\\frac{9}{6}+\\frac{2}{6}=\\frac{11}{6}.\n$$\n\nWith $n=6$, the number of unordered source-target pairs that exclude $v$ is\n$$\n\\frac{(n-1)(n-2)}{2}=\\frac{(6-1)(6-2)}{2}=\\frac{5\\cdot 4}{2}=10.\n$$\nTherefore, the normalized betweenness centrality of $v$ is\n$$\ng'(v)=\\frac{g(v)}{10}=\\frac{\\frac{11}{6}}{10}=\\frac{11}{60}.\n$$\n\nThis is the exact normalized value, as required.",
            "answer": "$$\\boxed{\\frac{11}{60}}$$"
        },
        {
            "introduction": "Algebraic graph theory provides elegant tools for analyzing network structure, such as using the trace of the adjacency matrix power, $\\operatorname{tr}(A^k)$, to count closed walks. This practice challenges you to explore the strengths and limitations of this technique for detecting simple cycles. You will implement both the trace-based estimation and an exact cycle enumeration via Depth-First Search (DFS), allowing you to empirically investigate why $\\operatorname{tr}(A^k)$ counts all closed walks, not just simple cycles, and thus serves as an upper bound .",
            "id": "4296197",
            "problem": "Consider a finite directed graph with $n$ labeled vertices $\\{0,1,\\dots,n-1\\}$ and a binary adjacency matrix $A \\in \\{0,1\\}^{n \\times n}$, where $A_{ij} = 1$ if and only if there is a directed edge from vertex $i$ to vertex $j$, and $A_{ij} = 0$ otherwise. Use the following fundamental bases:\n\n- The definition of a directed walk: A sequence of vertices $(v_0, v_1, \\dots, v_k)$ such that $A_{v_{t} v_{t+1}} = 1$ for all $t \\in \\{0,1,\\dots,k-1\\}$.\n- The well-tested fact in algebraic graph theory: For any integer $k \\ge 1$, the $(i,j)$-entry of $A^k$ equals the number of directed walks of length $k$ from $i$ to $j$. In particular, $\\operatorname{tr}(A^k) = \\sum_{i=0}^{n-1} (A^k)_{ii}$ equals the number of closed walks of length $k$ that start and end at the same vertex.\n\nA simple directed cycle of length $k$ is a closed directed walk of length $k$ that visits $k$ distinct vertices exactly once, except for the start/end vertex repetition. You are asked to design an algorithm that detects the existence of at least one simple directed cycle of bounded length $k$ by computing traces of powers of $A$ and to reason about, and empirically illustrate, the possibility of false positives when using traces for counting, which arise from backtracking and repeated vertices in closed walks.\n\nYour tasks:\n\n- Derive, from first principles above, a detection rule for the existence of at least one simple directed cycle of length at most $k$ using $\\operatorname{tr}(A^\\ell)$ for $\\ell \\in \\{1,2,\\dots,k\\}$.\n- Define an integer-valued upper bound on the number of simple directed cycles of length at most $k$ based on traces of powers of $A$.\n- Implement an exact enumeration procedure by Depth-First Search (DFS) that counts the number of simple directed cycles of length at most $k$ by directly enforcing vertex non-repetition and a canonicalization rule to avoid rotational duplicates, and compare it to your trace-based upper bound to empirically expose the magnitude of false positives caused by backtracking and repeated vertices.\n\nYou must implement a single program that, for each test case, returns two integers: the trace-based upper bound (rounded up to the nearest integer using the ceiling function to ensure it is an upper bound) and the exact enumeration count of simple directed cycles of length at most $k$. The final output must aggregate the results of all test cases into a single line formatted as a comma-separated list enclosed in square brackets.\n\nTest suite (each test case provides an adjacency matrix $A$ and a bound $k$):\n\n- Test case $1$: $A$ is the directed $3$-cycle on vertices $\\{0,1,2\\}$ with edges $(0 \\to 1)$, $(1 \\to 2)$, $(2 \\to 0)$, that is,\n  $$\n  A = \\begin{pmatrix}\n  0  1  0 \\\\\n  0  0  1 \\\\\n  1  0  0\n  \\end{pmatrix},\n  $$\n  and $k = 3$.\n- Test case $2$: $A$ is a directed $2$-cycle on vertices $\\{0,1\\}$ with edges $(0 \\to 1)$, $(1 \\to 0)$, that is,\n  $$\n  A = \\begin{pmatrix}\n  0  1 \\\\\n  1  0\n  \\end{pmatrix},\n  $$\n  and $k = 4$.\n- Test case $3$: $A$ is a $3$-vertex graph with a self-loop at vertex $0$ and a directed $3$-cycle $(0 \\to 1 \\to 2 \\to 0)$, that is,\n  $$\n  A = \\begin{pmatrix}\n  1  1  0 \\\\\n  0  0  1 \\\\\n  1  0  0\n  \\end{pmatrix},\n  $$\n  and $k = 3$.\n- Test case $4$: $A$ is a directed acyclic graph (DAG) that is a chain on $\\{0,1,2,3\\}$ with edges $(0 \\to 1)$, $(1 \\to 2)$, $(2 \\to 3)$, that is,\n  $$\n  A = \\begin{pmatrix}\n  0  1  0  0 \\\\\n  0  0  1  0 \\\\\n  0  0  0  1 \\\\\n  0  0  0  0\n  \\end{pmatrix},\n  $$\n  and $k = 4$.\n- Test case $5$: $A$ is a $5$-vertex graph consisting of a directed $3$-cycle $(0 \\to 1 \\to 2 \\to 0)$ disjoint from a directed $2$-cycle $(3 \\to 4 \\to 3)$, that is,\n  $$\n  A = \\begin{pmatrix}\n  0  1  0  0  0 \\\\\n  0  0  1  0  0 \\\\\n  1  0  0  0  0 \\\\\n  0  0  0  0  1 \\\\\n  0  0  0  1  0\n  \\end{pmatrix},\n  $$\n  and $k = 3$.\n\nAnswer specification:\n\n- For each test case, compute the trace-based upper bound\n  $$\n  U_k \\equiv \\left\\lceil \\sum_{\\ell=1}^{k} \\frac{\\operatorname{tr}(A^\\ell)}{\\ell} \\right\\rceil,\n  $$\n  and compute the exact count $E_k$ of simple directed cycles of length at most $k$ using DFS with vertex non-repetition and a canonicalization rule that counts each cycle once.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, ordered by test case, and for each test case include first $U_k$ then $E_k$. For example, the output format must be\n  $$\n  [U_1,E_1,U_2,E_2,U_3,E_3,U_4,E_4,U_5,E_5].\n  $$\n- All outputs are unitless integers.\n\nThe problem is purely mathematical and algorithmic and requires rigorous reasoning grounded in the provided fundamental definitions and facts. No physical units, angle units, or percentage units are involved. The test cases have been chosen to cover: a general case with a single simple cycle, a case where multiple traversals inflate trace counts, a case with a self-loop plus a cycle, an acyclic boundary case, and a multi-cycle case.",
            "solution": "The problem requires the derivation of a trace-based method for detecting and bounding the number of simple directed cycles, and the implementation of an exact enumeration algorithm for comparison. The solution is presented in two parts: the theoretical derivation for the trace-based approach and the algorithmic design for the exact counting method.\n\n### Part 1: Trace-Based Cycle Detection and Upper Bound\n\nThe foundation of this method is the algebraic graph theory fact that the $(i,j)$-entry of the matrix power $A^k$ gives the number of distinct directed walks of length $k$ from vertex $i$ to vertex $j$. Consequently, the trace of $A^k$, written as $\\operatorname{tr}(A^k) = \\sum_{i=0}^{n-1} (A^k)_{ii}$, gives the total number of closed directed walks of length $k$ in the graph.\n\nA simple directed cycle of length $\\ell$ is a specific kind of closed walk of length $\\ell$ where all vertices are distinct, except for the coincidence of the start and end vertex. A crucial observation is that any closed walk must contain at least one simple cycle. To see this, consider a closed walk $W=(v_0, v_1, \\dots, v_\\ell=v_0)$. If $W$ is not simple, at least one vertex is repeated in the sequence $v_0, \\dots, v_{\\ell-1}$. Let $v_i = v_j$ for some $0 \\le i  j  \\ell$. Then the sub-walk $(v_i, v_{i+1}, \\dots, v_j)$ is a shorter closed walk. This reduction process can be applied repeatedly until a closed walk with no repeated intermediate vertices is found, which is by definition a simple cycle. The length of this resulting simple cycle is at most the length of the original walk.\n\n**Detection Rule:**\nBased on the above reasoning, the existence of a closed walk of length $\\ell \\in \\{1, 2, \\dots, k\\}$ implies the existence of a simple directed cycle of length at most $\\ell$. The total number of closed walks of length up to $k$ is given by $\\sum_{\\ell=1}^k \\operatorname{tr}(A^\\ell)$. Therefore, a robust detection rule is as follows: a simple directed cycle of length at most $k$ exists if and only if $\\sum_{\\ell=1}^k \\operatorname{tr}(A^\\ell)  0$. Any non-zero trace for a power $\\ell \\ge 1$ signals a closed walk, which guarantees a simple cycle.\n\n**Upper Bound Derivation:**\nThe problem provides the formula $U_k \\equiv \\left\\lceil \\sum_{\\ell=1}^{k} \\frac{\\operatorname{tr}(A^\\ell)}{\\ell} \\right\\rceil$ as an upper bound for the number of simple directed cycles of length at most $k$. Let's analyze its components.\nA single simple cycle of length $\\ell$ can be represented as $\\ell$ distinct closed walks, one starting from each of its $\\ell$ vertices. For example, the cycle $(v_0 \\to v_1 \\to \\dots \\to v_{\\ell-1} \\to v_0)$ gives rise to the closed walks $(v_0, \\dots, v_0)$, $(v_1, \\dots, v_1)$, and so on. All these $\\ell$ walks are counted in $\\operatorname{tr}(A^\\ell)$. Dividing $\\operatorname{tr}(A^\\ell)$ by $\\ell$ is an attempt to count the cycle itself just once.\n\nHowever, $\\operatorname{tr}(A^\\ell)$ also includes contributions from non-simple closed walks, which are the source of \"false positives\" and cause this method to be an upper bound rather than an exact count. These non-simple walks include:\n1.  **Composite walks:** Traversing a simple cycle of length $d$ (where $d$ divides $\\ell$) a total of $\\ell/d$ times. For example, a $2$-cycle traversed twice is a closed walk of length $4$.\n2.  **Walks with excursions or backtracking:** A walk that leaves a vertex, follows a path, and then returns. For instance, $i \\to j \\to i$ is a closed walk of length $2$ but forms a simple $2$-cycle only if $i \\ne j$.\n\nThe formula $\\sum_{\\ell=1}^{k} \\frac{\\operatorname{tr}(A^\\ell)}{\\ell}$ thus sums up these estimates for all lengths up to $k$. Since each term $\\frac{\\operatorname{tr}(A^\\ell)}{\\ell}$ overcounts or correctly counts the simple cycles of length $\\ell$, the total sum is an over-approximation of the true number of simple cycles of length at most $k$. The ceiling function, $\\lceil \\cdot \\rceil$, is applied to ensure the final bound is an integer.\n\nTo compute $U_k$ for a given adjacency matrix $A$ and bound $k$, we iterate $\\ell$ from $1$ to $k$. In each iteration, we calculate $A^\\ell$ using matrix exponentiation, find its trace $\\operatorname{tr}(A^\\ell)$, divide by $\\ell$, and accumulate the result. The final sum is rounded up to the nearest integer.\n\n### Part 2: Exact Enumeration using Depth-First Search (DFS)\n\nTo obtain the exact count of simple directed cycles, $E_k$, we must explicitly enumerate them. A Depth-First Search (DFS) is a natural algorithmic choice for exploring paths in a graph. The core idea is to find all simple paths starting from each vertex that lead back to the same vertex, forming a cycle.\n\nThe algorithm is structured as follows:\n1.  **Graph Representation:** The adjacency matrix $A$ is converted to an adjacency list for efficient neighbor lookup during traversal.\n2.  **Iteration over Starting Vertices:** The search is initiated from every vertex $s \\in \\{0, 1, \\dots, n-1\\}$ in the graph. This ensures that all possible cycles are discovered.\n3.  **DFS Traversal:** For each `start_node` $s$, a recursive DFS is performed. The DFS function maintains the current `path` (a list of vertices) and a `visited` set for O(1) checking to enforce the \"simple\" constraint (no repeated vertices).\n    - The recursion proceeds from a current vertex $u$ to its neighbors $v$.\n    - If a neighbor $v$ is the same as the `start_node`, a cycle has been found. The length of this cycle is the number of vertices in the current `path`.\n    - If a neighbor $v$ has not been visited in the current `path`, the DFS continues recursively from $v$, with $v$ added to the `path` and `visited` set. After the recursive call returns, $v$ is removed (backtracking) to allow exploration of other paths.\n4.  **Length Constraint:** The search is pruned. The recursion is stopped if extending the path would make its length exceed the maximum allowed cycle length $k$.\n5.  **Canonicalization and Counting:** A simple cycle of length $\\ell$ will be found $\\ell$ times, once for each of its vertices serving as the `start_node`. To count each unique cycle only once, we use a canonical representation. A convenient choice is the sorted tuple of the vertices in the cycle. For example, the paths `[0, 1, 2]`, `[1, 2, 0]`, and `[2, 0, 1]` all correspond to the same $3$-cycle. Their canonical representation would be `(0, 1, 2)`. These canonical forms are stored in a `set` to automatically discard duplicates.\n6.  **Final Count:** The exact number of simple cycles of length at most $k$, denoted $E_k$, is the final size of this set of canonical representations.\n\nThis DFS-based approach guarantees an exact count by directly enforcing the definition of a simple cycle and employing a canonicalization rule to prevent overcounting due to rotational symmetries. The comparison of $U_k$ and $E_k$ will empirically demonstrate the overestimation inherent in the trace-based method.",
            "answer": "```python\nimport numpy as np\nimport math\n\ndef calculate_trace_bound(A, k):\n    \"\"\"\n    Calculates the trace-based upper bound Uk for simple cycles of length up to k.\n    Uk = ceil(sum_l=1^k (tr(A^l) / l))\n    \"\"\"\n    total_trace_term = 0.0\n    n = A.shape[0]\n\n    # A_power will store A^l\n    A_power = np.copy(A).astype(np.float64) # Use float for potentially large numbers\n    \n    for l in range(1, k + 1):\n        if l  1:\n            # More efficient than calling matrix_power in a loop\n            A_power = A_power @ A\n        \n        # Ensure A_power is what we expect for l=1\n        if l == 1 and not np.array_equal(A_power, A):\n             A_power = np.copy(A).astype(np.float64)\n\n        # Check if A_power grew too large before taking trace\n        if n  0:\n            trace_val = np.trace(A_power)\n            total_trace_term += trace_val / l\n\n    return math.ceil(total_trace_term)\n\ndef find_exact_cycles(A, k):\n    \"\"\"\n    Finds the exact number of simple directed cycles of length up to k using DFS.\n    \"\"\"\n    n = A.shape[0]\n    adj = {i: [j for j, connected in enumerate(row) if connected] for i, row in enumerate(A)}\n    found_cycles = set()\n\n    for start_node in range(n):\n        # The path starts with the start_node\n        path = [start_node]\n        # Visited set for O(1) lookups\n        visited = {start_node}\n        dfs_recursive(start_node, start_node, path, visited, k, adj, found_cycles)\n        \n    return len(found_cycles)\n\ndef dfs_recursive(start_node, u, path, visited, max_len, adj, found_cycles):\n    \"\"\"\n    Recursive DFS helper function to find simple cycles.\n    \"\"\"\n    path_len = len(path)\n\n    # Explore neighbors of the current node u\n    for v in adj.get(u, []):\n        # A cycle is found if the neighbor is the start_node.\n        # cycle length is path_len.\n        if v == start_node:\n            if path_len = max_len:\n                # Canonical form is the sorted tuple of vertices\n                canonical_form = tuple(sorted(path))\n                found_cycles.add(canonical_form)\n        \n        # If neighbor is not visited and path is not too long, continue the path\n        elif v not in visited:\n            if path_len  max_len:\n                visited.add(v)\n                path.append(v)\n                dfs_recursive(start_node, v, path, visited, max_len, adj, found_cycles)\n                path.pop()\n                visited.remove(v)\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        # Test case 1\n        (np.array([[0, 1, 0], [0, 0, 1], [1, 0, 0]]), 3),\n        # Test case 2\n        (np.array([[0, 1], [1, 0]]), 4),\n        # Test case 3\n        (np.array([[1, 1, 0], [0, 0, 1], [1, 0, 0]]), 3),\n        # Test case 4\n        (np.array([[0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1], [0, 0, 0, 0]]), 4),\n        # Test case 5\n        (np.array([\n            [0, 1, 0, 0, 0],\n            [0, 0, 1, 0, 0],\n            [1, 0, 0, 0, 0],\n            [0, 0, 0, 0, 1],\n            [0, 0, 0, 1, 0]\n        ]), 3),\n    ]\n\n    results = []\n    for A, k in test_cases:\n        # Using numpy.linalg.matrix_power for verified power calculation\n        def calculate_trace_bound_alt(A,k):\n            total_trace_term = 0.0\n            for l in range(1, k + 1):\n                A_power = np.linalg.matrix_power(A, l)\n                trace_val = np.trace(A_power)\n                total_trace_term += trace_val / l\n            return math.ceil(total_trace_term)\n        \n        U_k = calculate_trace_bound_alt(A.astype(np.float64), k)\n        E_k = find_exact_cycles(A, k)\n        results.extend([U_k, E_k])\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}