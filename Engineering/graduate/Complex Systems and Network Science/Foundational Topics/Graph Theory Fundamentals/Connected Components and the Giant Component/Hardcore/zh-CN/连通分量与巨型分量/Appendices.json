{
    "hands_on_practices": [
        {
            "introduction": "巨连通片的出现是一个急剧的相变过程。为了理解为何会发生这种相变，首先分析网络在临界阈值以下的结构至关重要。 这个练习将引导你使用一个强大的分支过程近似方法，推导出在亚临界状态下（subcritical regime）连通组件的期望大小。这为在巨连通片出现之前、组件规模保持有限且微小的观点提供了定量的理论基础。",
            "id": "4270116",
            "problem": "考虑一个建模为 Erdős–Rényi (ER) 随机图 $G(n,p)$ 的无向简单网络，其中 $p = c/n$，固定 $0 < c < 1$ 且 $n$ 很大。从图中均匀随机地选择一个节点。请仅使用 ER 模型的基本定义、从种子节点开始的连通分量探索过程，以及一个通过 $G(n,p)$ 在亚临界状态 ($c < 1$) 下的局部树状结构证明其合理性的 Galton–Watson (GW) 分支过程近似，推导在 $n \\to \\infty$ 极限下，包含所选节点的连通分量的期望大小的闭式解析表达式。\n\n你的推导必须从第一性原理出发：定义探索过程（例如，广度优先搜索 (BFS)），阐述后代分布如何从 $G(n,p)$ 中产生，并证明为什么在有限的探索深度下，对于 $c < 1$ 的情况，环路是可忽略的。然后，通过对各代期望数量求和，计算发现的节点总数的期望值。将你的最终答案表示为 $c$ 的函数。无需四舍五入，不涉及单位。",
            "solution": "我们的任务是推导在一个 Erdős–Rényi (ER) 随机图 $G(n,p)$ 中，当 $n \\to \\infty$ 时，包含一个随机选择的节点的连通分量的期望大小。其中，边的概率为 $p = c/n$，并且 $c$ 是一个满足 $0 < c < 1$ 的固定常数。这种状态被称为亚临界状态。推导将使用一个建模为 Galton-Watson (GW) 分支过程的探索过程。\n\n首先，我们定义一个探索过程来寻找包含一个随机选择的种子节点（我们称之为 $v_0$）的连通分量。广度优先搜索 (BFS) 是概念化此探索过程的一种自然方式。令 $S_k$ 为在过程的第 $k$ 步之前发现的节点集合，令 $Q_k$ 为第 $k$ 步时其邻居尚未被探索的“活跃”节点集合。\n\n该过程从第 $k=0$ 代开始：\n- 初始已发现节点集合为 $S_0 = \\{v_0\\}$。\n- 初始活跃节点集合为 $Q_0 = \\{v_0\\}$。\n- 第 0 代的大小为 $|Q_0| = 1$。\n\n在随后的每一步 $k \\ge 1$：\n- 我们通过识别 $Q_{k-1}$ 中所有尚未被发现的邻居节点来形成活跃节点集 $Q_k$。也就是说，对于每个节点 $u \\in Q_{k-1}$，我们检查所有其他节点 $w \\in V \\setminus S_{k-1}$（其中 $V$ 是所有 $n$ 个节点的集合），如果存在一条边 $(u,w)$，则将 $w$ 添加到 $Q_k$ 中。\n- 已发现的节点集合更新为：$S_k = S_{k-1} \\cup Q_k$。\n- 当 $Q_k$ 为空时，过程终止，此时 $S_{k-1}$ 就是完整的连通分量。\n\n连通分量的总大小为 $\\sum_{k=0}^{\\infty} |Q_k|$。我们想要找到这个和的期望值。\n\n现在，我们将此探索过程与 Galton-Watson 分支过程联系起来。GW 过程模拟了种群增长，其中第 $k$ 代的每个个体独立地为第 $k+1$ 代产生随机数量的后代，这些后代的数量从一个共同的后代分布中抽取。\n\n让我们确定我们探索过程的后代分布。考虑第 $k-1$ 代中的一个节点 $u$（即 $u \\in Q_{k-1}$）。它的“后代”是其不在 $S_{k-1}$ 中的邻居。$S_{k-1}$ 中的节点数是到目前为止发现的连通分量的大小。在亚临界状态 ($c < 1$) 下，连通分量很小，其大小不随 $n$ 扩展。正如我们将要展示的，其期望大小是有限的。因此，对于任何有限的探索步数 $k$，$S_{k-1}$ 的大小是 $O(1)$ 阶。这意味着当 $n \\to \\infty$ 时，有 $|S_{k-1}| \\ll n$。\n\n节点 $u$ 的潜在后代数量是尚未发现的节点数，即 $n - |S_{k-1}|$。由于 $|S_{k-1}|$ 与 $n$ 相比可以忽略不计，我们可以将其近似为 $n-1$ 甚至 $n$。对于这 $n-|S_{k-1}|$ 个节点中的每一个，比如说 $w$，存在一条边 $(u,w)$ 的概率是 $p$。因此，从节点 $u$ 发现的新邻居的数量遵循二项分布 $B(n-|S_{k-1}|, p)$。\n\n给定 $p = c/n$ 和大的 $n$，我们可以用均值为 $\\lambda = mp$ 的泊松分布来近似二项分布 $B(m,p)$。这里，$m = n - |S_{k-1}| \\approx n$。因此，均值为 $\\lambda \\approx np = n(c/n) = c$。所以，任何给定节点的后代数量可以很好地由均值为 $c$ 的泊松分布来近似，记为 $\\text{Poisson}(c)$。\n\n使用 GW 过程的关键理由是 ER 图在稀疏状态（$p=c/n$）下的局部树状结构。GW 模型假设不同个体的后代数量是独立的。在我们的图探索中，这转化为一个假设，即两个不同的已发现节点 $u_1, u_2 \\in S_k$ 的邻域彼此不相交，也与先前发现的节点（除了它们的“父节点”）不相交。如果图中存在短环，这个假设就会被违反。例如，如果两个节点 $u_1, u_2 \\in Q_{k-1}$ 有一个共同的邻居 $w \\notin S_{k-1}$，这是允许的。但是如果 $u_1$ 的一个邻居已经在 $S_{k-1}$ 中（并且不是 $u_1$ 的父节点），这就形成了一个环。对于任何固定的 $c$，当 $n \\to \\infty$ 时，这种短环的概率是极小的。一个长度为 $k$ 的环需要 $k$ 条特定的边存在于一个有 $\\binom{n}{k}$ 个可能位置形成这样一个环的图中。长度为 $k$ 的环的期望数量大约为 $\\frac{(n-1)!}{(n-k)! \\cdot 2k} p^k \\approx \\frac{n^k}{2k} (c/n)^k = \\frac{c^k}{2k}$，这是一个与 $n$ 无关的常数。一个随机选择的节点属于这样一个环的概率与 $1/n$ 成正比。因此，对于一个有限大小的连通分量的探索，在 $n \\to \\infty$ 的极限下，遇到环的概率是可以忽略的。\n\n这就证明了将连通分量探索建模为一个 GW 分支过程是合理的，其中每个个体的后代数量独立地从 $\\text{Poisson}(c)$ 分布中抽取。\n\n令 $Z_k$ 为第 $k$ 代中节点数量的随机变量（即 $Z_k = |Q_k|$）。我们从一个节点开始，所以 $Z_0=1$。\n单个个体的期望后代数是后代分布的均值，即 $\\mu = E[\\text{Poisson}(c)] = c$。\n第 $k$ 代的期望大小 $E[Z_k]$ 可以递归计算。\n$E[Z_1] = E[\\text{初始节点的后代数量}] = c$。\n$E[Z_2] = E[E[Z_2 | Z_1]]$。给定第 1 代中有 $Z_1$ 个个体，每个个体期望产生 $c$ 个后代，所以 $E[Z_2 | Z_1] = c Z_1$。\n因此，$E[Z_2] = E[c Z_1] = c E[Z_1] = c \\cdot c = c^2$。\n通过归纳法，第 $k$ 代的期望大小为 $E[Z_k] = c^k E[Z_0] = c^k$。\n\n连通分量的总大小 $S$ 是从开始到过程消亡的所有代的规模之和：\n$$ S = \\sum_{k=0}^{\\infty} Z_k $$\n我们要求的是这个连通分量的期望大小 $E[S]$。根据期望的线性性质，我们可以写出：\n$$ E[S] = E\\left[\\sum_{k=0}^{\\infty} Z_k\\right] = \\sum_{k=0}^{\\infty} E[Z_k] $$\n代入 $E[Z_k]$ 的表达式：\n$$ E[S] = \\sum_{k=0}^{\\infty} c^k $$\n这是一个几何级数。题目说明 $0 < c < 1$。对于 $c$ 的这个范围，级数收敛。几何级数的和由公式 $\\frac{a}{1-r}$ 给出，其中 $a$ 是首项，$r$ 是公比。\n在我们的例子中，首项（$k=0$）是 $c^0 = 1$，公比是 $c$。\n因此，连通分量的期望大小是：\n$$ E[S] = \\frac{1}{1-c} $$\n这个结果在亚临界状态（$c < 1$）下成立。当 $c>1$ 时，GW 过程有非零的概率永远存活，这对应于一个大小与 $n$ 成正比的“巨型连通分量”的出现。在这种情况下，和 $\\sum c^k$ 会发散，反映了分支过程的无限期望大小（尽管图中连通分量的大小仍然是有限的，与 $n$ 成比例）。这里的分析严格限于连通分量很小的亚临界情况。",
            "answer": "$$\\boxed{\\frac{1}{1-c}}$$"
        },
        {
            "introduction": "除了图的概率模型，我们经常需要分析一个给定的具体网络的结构。 这个实践引入了图拉普拉斯算子（graph Laplacian），这是一个能够巧妙编码图连通性的矩阵。你将首先证明谱图论中的一个基本定理，该定理将拉普拉斯算子的特征值与连通组件的数量联系起来，然后通过实现一个数值算法将这个强大的理论付诸实践。",
            "id": "4270126",
            "problem": "考虑一个具有 $n$ 个标记为 $0,1,\\dots,n-1$ 的顶点的有限、无向、加权图，以及一个对称权重矩阵 $W \\in \\mathbb{R}^{n \\times n}$，其元素 $W_{ij} \\ge 0$ 代表边权重。图中没有自环，因此对所有 $i$ 都有 $W_{ii} = 0$。定义顶点 $i$ 的度为 $d_i = \\sum_{j=0}^{n-1} W_{ij}$，组合图拉普拉斯矩阵 $L \\in \\mathbb{R}^{n \\times n}$ 为 $L = D - W$，其中 $D$ 是对角线元素为 $d_0,\\dots,d_{n-1}$ 的对角矩阵。一个连通分量是顶点的最大子集，使得对于子集中的任意两个顶点 $u$ 和 $v$，都存在一条由严格正权重边构成的路径连接 $u$ 和 $v$。$L$ 的零特征值的重数定义为 $L$ 的零空间的维度，即与特征值 $0$ 相关联的线性无关特征向量的数量。\n\n第 $1$ 部分：仅从上述定义和实对称矩阵的基本性质出发，推导图的连通分量数为何等于拉普拉斯矩阵 $L$ 的零特征值的重数。您的推导必须从基本原理出发，除了已说明的内容外，不得使用任何快捷公式，并且必须解释该性质是什么，为什么它为真，以及它如何从定义中得出。\n\n第 $2$ 部分：设计一个算法，在给定一个具有非负项和零对角线的对称稀疏权重矩阵 $W$ 的情况下，构建 $L$ 并使用稀疏特征求解器通过估计零特征值的重数来计算连通分量的数量。该算法必须：\n- 使用一个特征求解器，该求解器针对 $L$ 的代数最小特征值，并计算在按 $L$ 的量级缩放的容差范围内有多少个特征值在数值上等于零。\n- 调整所请求的特征值数量 $k$，以便当数值上为零的特征值数量等于 $k$ 且 $k \\le n-1$ 时，算法增加 $k$ 直到 $k = n-1$ 或零特征值的计数严格小于 $k$ 为止，从而确保捕获所有零特征值。\n- 正确处理空图的边缘情况，其中 $W$ 没有非零项，此时拉普拉斯矩阵是零矩阵，连通分量的数量为 $n$。\n\n将此算法实现为一个完整的、可运行的程序，该程序不接受任何输入，并使用固定的内部测试套件。使用以下五个测试用例，每个用例由顶点数 $n$ 和一个无向边列表 $(i,j,w)$ 指定，其中 $i \\neq j$，$w > 0$，并具有隐式对称性 $(j,i,w)$：\n\n测试用例 $1$（单条路径，连通）：$n=5$；边 $\\{(0,1,1),(1,2,1),(2,3,1),(3,4,1)\\}$。\n\n测试用例 $2$（两个分量：一条长度为 $2$ 的路径和一条长度为 $1$ 的路径）：$n=5$；边 $\\{(0,1,1),(1,2,1),(3,4,1)\\}$。\n\n测试用例 $3$（所有顶点都是孤立的）：$n=4$；边 $\\{\\}$。\n\n测试用例 $4$（三个分量：一个三角形、一条边和一个孤立顶点）：$n=6$；边 $\\{(0,1,1),(1,2,1),(2,0,1),(3,4,1)\\}$。\n\n测试用例 $5$（加权：一个带正权重的 4-环外加一个孤立顶点）：$n=5$；边 $\\{(0,1,0.5),(1,2,2.0),(2,3,1.5),(3,0,1.0)\\}$。\n\n您的程序必须：\n- 根据每个测试用例构建 $W$ 并形成 $L = D - W$。\n- 使用稀疏特征求解器计算 $L$ 的代数最小特征值，并根据一个按 $L$ 的最大对角线项缩放的容差，计算有多少个特征值在数值上为零。\n- 将五个测试用例的整数结果汇总到单行输出中，格式完全如下：一个用方括号括起来的逗号分隔列表。例如，如果结果是 $a_1,a_2,a_3,a_4,a_5$，则打印单行 $[a_1,a_2,a_3,a_4,a_5]$。",
            "solution": "该问题是有效的，因为它在科学上植根于谱图理论，问题提出得很好，并且表述客观。它包含一个理论推导和一个算法实现，这两者都是网络科学和计算数学中的标准主题。\n\n### 第 1 部分：推导\n\n目标是证明对于一个加权无向图，其连通分量的数量（用 $c$ 表示）等于其组合拉普拉斯矩阵 $L$ 的特征值 $0$ 的重数。重数是 $L$ 的零空间的维度，记为 $\\text{dim}(\\text{null}(L))$。给定 $L = D - W$，其中 $W$ 是对称权重矩阵，满足 $W_{ij} \\ge 0$ 和 $W_{ii} = 0$，$D$ 是对角度矩阵，其对角线元素为 $d_i = \\sum_{j} W_{ij}$。$L$ 的零空间是满足 $L\\mathbf{v} = \\mathbf{0}$ 的向量 $\\mathbf{v} \\in \\mathbb{R}^n$ 的集合。我们必须证明 $\\text{dim}(\\text{null}(L)) = c$。\n\n证明过程分为两个主要步骤：首先，我们通过拉普拉斯矩阵的二次型建立其一个基本性质；其次，我们利用这个性质将其零空间中向量的结构与图的连通分量联系起来。\n\n**第 1 步：拉普拉斯二次型**\n\n设 $\\mathbf{v} \\in \\mathbb{R}^n$ 为任意向量，其分量为 $v_0, v_1, \\dots, v_{n-1}$。考虑二次型 $\\mathbf{v}^T L \\mathbf{v}$。\n$$ \\mathbf{v}^T L \\mathbf{v} = \\mathbf{v}^T (D-W) \\mathbf{v} = \\mathbf{v}^T D \\mathbf{v} - \\mathbf{v}^T W \\mathbf{v} $$\n第一项是 $\\mathbf{v}^T D \\mathbf{v} = \\sum_{i=0}^{n-1} d_i v_i^2$。根据度 $d_i$ 的定义，我们可以将其写为：\n$$ \\sum_{i=0}^{n-1} d_i v_i^2 = \\sum_{i=0}^{n-1} \\left( \\sum_{j=0}^{n-1} W_{ij} \\right) v_i^2 = \\sum_{i,j} W_{ij} v_i^2 $$\n第二项是 $\\mathbf{v}^T W \\mathbf{v} = \\sum_{i,j} W_{ij} v_i v_j$。\n将这些代入 $\\mathbf{v}^T L \\mathbf{v}$ 的表达式中：\n$$ \\mathbf{v}^T L \\mathbf{v} = \\sum_{i,j} W_{ij} v_i^2 - \\sum_{i,j} W_{ij} v_i v_j $$\n由于权重矩阵 $W$ 是对称的（$W_{ij} = W_{ji}$），我们可以处理第一个和式：\n$$ \\sum_{i,j} W_{ij} v_i^2 = \\frac{1}{2} \\sum_{i,j} W_{ij} v_i^2 + \\frac{1}{2} \\sum_{i,j} W_{ij} v_i^2 $$\n通过在第二部分交换求和索引 $i$ 和 $j$ 并利用 $W$ 的对称性：\n$$ \\frac{1}{2} \\sum_{j,i} W_{ji} v_j^2 = \\frac{1}{2} \\sum_{i,j} W_{ij} v_j^2 $$\n所以，我们可以写成：\n$$ \\mathbf{v}^T L \\mathbf{v} = \\frac{1}{2} \\sum_{i,j} W_{ij} (v_i^2 + v_j^2) - \\sum_{i,j} W_{ij} v_i v_j $$\n将各项合并到一个求和式中：\n$$ \\mathbf{v}^T L \\mathbf{v} = \\frac{1}{2} \\sum_{i,j} W_{ij} (v_i^2 - 2v_i v_j + v_j^2) = \\frac{1}{2} \\sum_{i,j} W_{ij} (v_i - v_j)^2 $$\n这个恒等式是基础。由于边权重是非负的（$W_{ij} \\ge 0$）并且 $(v_i - v_j)^2 \\ge 0$，因此对于任何向量 $\\mathbf{v}$，都有 $\\mathbf{v}^T L \\mathbf{v} \\ge 0$。这表明拉普拉斯矩阵 $L$ 是半正定的，意味着其所有特征值 $\\lambda$ 都是非负的（$\\lambda \\ge 0$）。\n\n**第 2 步：将零空间与连通分量关联**\n\n对应于特征值 $\\lambda = 0$ 的特征向量 $\\mathbf{v}$ 必须满足 $L\\mathbf{v} = \\mathbf{0}$。对于这样的向量，其二次型必须为零：$\\mathbf{v}^T L \\mathbf{v} = 0$。\n使用第 1 步中的恒等式：\n$$ \\frac{1}{2} \\sum_{i,j} W_{ij} (v_i - v_j)^2 = 0 $$\n由于这是一个非负项的和，要使和为零，每个单独的项都必须为零。也就是说，对于每一对索引 $(i, j)$：\n$$ W_{ij} (v_i - v_j)^2 = 0 $$\n这个条件有一个至关重要的推论：如果顶点 $i$ 和顶点 $j$ 之间存在一条权重严格为正的边（即 $W_{ij} > 0$），那么必须有 $(v_i - v_j)^2 = 0$，这意味着 $v_i = v_j$。\n\n根据定义，一个连通分量是一个最大的顶点集合，其中任意两个顶点都通过一条由正权重边构成的路径相连。让我们考虑单个连通分量。如果顶点 $u$ 和 $v$ 在同一个分量中，则存在一条路径 $p_0, p_1, \\dots, p_k$，其中 $u=p_0$，$v=p_k$，并且对于所有 $m \\in \\{0, \\dots, k-1\\}$ 都有 $W_{p_{m}p_{m+1}} > 0$。将条件 $v_i = v_j$ 应用于此路径上的每条边，我们得到 $v_{p_0} = v_{p_1} = \\dots = v_{p_k}$。因此，对于与特征值 $0$ 相关联的任何特征向量 $\\mathbf{v}$，其分量在单个连通分量内的所有顶点上必须是恒定的。\n\n设图有 $c$ 个连通分量，$C_1, C_2, \\dots, C_c$。基于以上推理，任何向量 $\\mathbf{v} \\in \\text{null}(L)$ 在每个分量的顶点上必须取一个恒定值。设分量 $C_k$ 的这个恒定值为 $\\alpha_k$。因此，对于任何 $i \\in C_k$，有 $v_i = \\alpha_k$。\n\n这意味着零空间中的任何向量 $\\mathbf{v}$ 都可以表示为一组特定向量的线性组合。让我们定义一组 $c$ 个指示向量 $\\{\\mathbf{u}_1, \\mathbf{u}_2, \\dots, \\mathbf{u}_c\\}$，其中对于每个 $k \\in \\{1, \\dots, c\\}$，$\\mathbf{u}_k$ 的第 $i$ 个分量是：\n$$ (\\mathbf{u}_k)_i = \\begin{cases} 1  &\\text{如果顶点 } i \\in C_k \\\\ 0  &\\text{如果顶点 } i \\notin C_k \\end{cases} $$\n那么，任何向量 $\\mathbf{v} \\in \\text{null}(L)$ 都可以写成：\n$$ \\mathbf{v} = \\sum_{k=1}^c \\alpha_k \\mathbf{u}_k $$\n这表明向量 $\\{\\mathbf{u}_1, \\dots, \\mathbf{u}_c\\}$ 张成了 $L$ 的零空间。\n\n为了完成证明，我们必须证明这些向量是线性无关的。考虑这些向量的一个等于零向量的线性组合：\n$$ \\sum_{k=1}^c \\beta_k \\mathbf{u}_k = \\mathbf{0} $$\n向量 $\\mathbf{u}_k$ 具有不相交的支撑集；也就是说，对于任何顶点 $i$，$(\\mathbf{u}_k)_i$ 仅对于一个 $k$ 值非零。如果我们考虑方程的第 $i$ 个分量，其中 $i \\in C_j$，则和式简化为 $\\beta_j (\\mathbf{u}_j)_i = 0$。由于 $(\\mathbf{u}_j)_i=1$，所以必须有 $\\beta_j=0$。因为这对任何分量 $j$ 都成立，所以所有系数 $\\beta_k$ 都必须为零。因此，集合 $\\{\\mathbf{u}_1, \\dots, \\mathbf{u}_c\\}$ 是线性无关的。\n\n由于集合 $\\{\\mathbf{u}_1, \\dots, \\mathbf{u}_c\\}$ 是一个张成 $L$ 零空间的线性无关集，它构成了 $\\text{null}(L)$ 的一个基。零空间的维度是其基中向量的数量，即 $c$。\n因此，我们证明了图拉普拉斯矩阵 $L$ 的零特征值的重数等于图的连通分量数 $c$。\n\n### 第 2 部分：算法设计\n\n该算法通过计算图拉普拉斯矩阵 $L$ 的零特征值的重数来计算连通分量的数量。它利用矩阵的稀疏表示来高效处理潜在的大型图，并使用迭代特征求解器来找到最小的特征值。\n\n1.  **矩阵构建**：给定顶点数 $n$ 和加权边列表，使用坐标格式构建一个稀疏权重矩阵 $W$，然后将其转换为压缩稀疏行（CSR）矩阵以进行高效的算术运算。由于图是无向的，对于每条边 $(i, j, w)$，$W_{ij}$ 和 $W_{ji}$ 的项都设置为 $w$。通过对 $W$ 的行求和并将得到的度放在一个稀疏矩阵的对角线上，形成对角度矩阵 $D$。然后拉普拉斯矩阵为 $L = D - W$。\n\n2.  **特征求解器策略**：算法的核心是找出 $L$ 的数值上为零的特征值的数量。由于 $L$ 是对称且半正定的，其特征值是实数且非负的。我们使用 `scipy.sparse.linalg.eigsh`，这是一个用于实对称矩阵的特征求解器，配置为寻找具有最小代数值（'SA'）的特征值。\n\n3.  **数值容差**：对于浮点数，直接与零进行比较是不鲁棒的。建立一个容差 $\\tau$，按 $L$ 的量级进行缩放。一个合适的缩放因子是 $L$ 的最大对角线元素，即最大顶点度 $\\max(d_i)$。容差为 $\\tau = \\max(d_i) \\cdot \\epsilon$，其中 $\\epsilon$ 是一个与机器精度相关的小常数（例如 $10^{-9}$）。如果所有度都为零（空图），则使用一个小的绝对容差。如果 $|\\lambda| < \\tau$，则认为特征值 $\\lambda$ 在数值上为零。\n\n4.  **自适应特征值搜索**：先验地不知道存在多少个零特征值。算法必须自适应地确定这一点。它开始时请求少量的特征值，$k=1$。\n    -   它计算 $k$ 个最小的特征值。设其中数值上为零的数量为 $c_0$。\n    -   如果 $c_0 < k$，这意味着至少找到了一个非零特征值。由于特征值是排序的，所有比这个小的特征值都必须是零。因此，$c_0$ 是零特征值的总数，搜索终止。\n    -   如果 $c_0 = k$，所有找到的特征值都是零。可能存在更多的零特征值。算法增加 $k$（例如，加倍，$k \\to 2k$）并重复该过程。这将持续到满足条件 $c_0 < k$ 或 $k$ 达到其最大可能值为止。\n\n5.  **边缘情况**：\n    -   `eigsh` 求解器要求请求的特征值数量 $k$ 小于 $n$。因此，对 $k$ 的自适应搜索上限为 $n-1$。\n    -   如果算法请求 $k=n-1$ 个特征值并发现它们全部为零，则出现一种特殊情况。对于非空图，$L$ 的迹 $\\text{Tr}(L) = \\sum d_i$ 是正的，并且等于所有特征值的和。如果 $n-1$ 个特征值为零，则最后一个特征值必须是 $\\lambda_n = \\text{Tr}(L) > 0$。所以重数是 $n-1$。但是，如果图是空的（$W=0$），则 $L=0$，$\\text{Tr}(L)=0$，并且所有 $n$ 个特征值都为零。自适应逻辑处理了这种情况：如果它找到 $n-1$ 个零特征值，它会检查迹。如果迹在数值上为零，则结论是有 $n$ 个分量（孤立顶点）；否则，有 $n-1$ 个分量。这正确地实现了问题描述中处理空图情况的逻辑。\n\n这种自适应稀疏特征求解器方法对于大型稀疏网络而言既是计算高效的，也是数值鲁棒的。",
            "answer": "```python\nimport numpy as np\nfrom scipy.sparse import csr_matrix, diags\nfrom scipy.sparse.linalg import eigsh, ArpackError\n\ndef count_connected_components(n, edges):\n    \"\"\"\n    Counts the number of connected components of a graph using its Laplacian matrix.\n\n    This function constructs the graph Laplacian L=D-W and finds the multiplicity\n    of its zero eigenvalue, which equals the number of connected components. It\n    uses an adaptive sparse eigensolver to find all numerically zero eigenvalues.\n\n    Args:\n        n (int): The number of vertices in the graph.\n        edges (list of tuples): A list of (u, v, w) tuples representing edges.\n\n    Returns:\n        int: The number of connected components.\n    \"\"\"\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n\n    # If there are no edges, every vertex is a component.\n    if not edges:\n        return n\n\n    # Construct the sparse weight matrix W\n    row, col, data = [], [], []\n    for u, v, w in edges:\n        row.extend([u, v])\n        col.extend([v, u])\n        data.extend([w, w])\n    \n    W = csr_matrix((data, (row, col)), shape=(n, n))\n\n    # Construct the sparse degree matrix D and Laplacian L\n    degrees = np.array(W.sum(axis=1)).flatten()\n    D = diags(degrees, 0)\n    L = D - W\n    \n    # Tolerance for a value to be considered zero.\n    # The problem suggests scaling by the largest diagonal entry of L, which is max(degrees).\n    max_degree = degrees.max()\n    # Use a small absolute tolerance if graph is empty (max_degree=0),\n    # although the initial check for empty edge list handles this.\n    tol = max_degree * 1e-9 if max_degree > 0 else 1e-9\n\n    # Adaptive algorithm to find the number of zero eigenvalues.\n    k = 1 # Start by searching for 1 eigenvalue.\n    while True:\n        # eigsh requires k to be less than the matrix dimension n.\n        k_to_ask = min(k, n - 1)\n        \n        try:\n            eigenvalues = eigsh(L, k=k_to_ask, which='SA', return_eigenvectors=False)\n        except ArpackError:\n            # This can happen if k is too large for the problem size or other issues.\n            # For this problem's scope, we assume it implies we need all eigenvalues.\n            # A full calculation would be more robust.\n            k_to_ask = n - 1\n            if k_to_ask == 0: # Graph of size 1\n                 return 1\n            eigenvalues = eigsh(L, k=k_to_ask, which='SA', return_eigenvectors=False)\n        \n        num_zero = np.sum(np.abs(eigenvalues)  tol)\n\n        if num_zero  k_to_ask:\n            # We found a non-zero eigenvalue, so all smaller ones (which we also\n            # have) constitute the full set of zero eigenvalues.\n            return int(num_zero)\n        \n        # If we asked for k_to_ask eigenvalues and all were zero:\n        if k_to_ask == n - 1:\n            # We found n-1 zero eigenvalues. The nth eigenvalue is Tr(L) - sum(n-1 zeros).\n            # Tr(L) = sum(degrees). This is zero only for an empty graph.\n            # If trace is zero, all n eigenvalues are zero -> n components.\n            # Otherwise, the nth eigenvalue is > 0 -> n-1 components.\n            if np.isclose(degrees.sum(), 0.0, atol=tol):\n                return n\n            else:\n                return n - 1\n        \n        # All k_to_ask eigenvalues were zero, and we haven't checked up to n-1 yet.\n        # Increase k to search for more. Double it for efficiency.\n        k *= 2\n\n\ndef solve():\n    \"\"\"\n    Main function to run the algorithm on the specified test cases.\n    \"\"\"\n    test_cases = [\n        (5, [(0, 1, 1), (1, 2, 1), (2, 3, 1), (3, 4, 1)]),\n        (5, [(0, 1, 1), (1, 2, 1), (3, 4, 1)]),\n        (4, []),\n        (6, [(0, 1, 1), (1, 2, 1), (2, 0, 1), (3, 4, 1)]),\n        (5, [(0, 1, 0.5), (1, 2, 2.0), (2, 3, 1.5), (3, 0, 1.0)]),\n    ]\n\n    results = []\n    for n, edges in test_cases:\n        num_components = count_connected_components(n, edges)\n        results.append(num_components)\n\n    # Print the final result in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "网络的连通性并非均匀分布；某些节点对于维持网络整体的连接比其他节点更为关键。 这个练习专注于识别这些被称为“关节点”（articulation points）或“割点”（cut vertices）的节点。通过实现一个基于深度优先搜索（DFS）的经典算法，你将获得分析网络结构脆弱性、理解不同节点在维持网络连通性中所扮演角色的实践经验。",
            "id": "4270105",
            "problem": "考虑一个有限、简单、无向图 $G = (V, E)$，其中 $|V| = n$ 且 $|E| = m$，$V = \\{0,1,\\dots,n-1\\}$，$E \\subseteq \\{\\{u,v\\} \\mid u,v \\in V, u \\neq v\\}$。一个连通分量是一个极大子集 $C \\subseteq V$，使得 $C$ 中的任意一对顶点在图 $G$ 中都由一条路径相连。关节点（也称为割点）是一个顶点 $a \\in V$，移除该顶点（及其所有关联边）将严格增加连通分量的数量。巨型连通分量是移除关节点后剩余图中基数最大的连通分量。设计一个基于深度优先搜索（DFS）low-link 值的算法，以识别图 $G$ 中的所有关节点，并从第一性原理出发分析其复杂度，仅从连通分量、DFS 树结构以及回边和树边的概念等核心定义开始。您的算法必须能够处理非连通图，即从每个未访问过的顶点开始启动深度优先搜索（DFS），并且必须根据 low-link 计算和发现时间戳来证明关节点判据的正确性，而不是依赖于任何现成的快捷公式。\n\n您的程序必须实现所设计的算法，并为下面提供的每个测试图输出两个量：\n- 所有关节点（以顶点索引表示）的排序列表。\n- 移除所有关节点后巨型连通分量的大小（一个整数）（如果所有顶点都被移除，则大小为 $0$）。\n\n使用以下测试套件。对于每个测试用例，图由 $n$ 和一个无向边列表（以无序对的形式给出）指定：\n- 测试用例 1 (一般多块情况): $n = 8$，边 $E = \\{(0,1),(1,2),(2,0),(2,3),(3,4),(4,5),(5,3),(5,6),(6,7)\\}$。\n- 测试用例 2 (星形树): $n = 5$，边 $E = \\{(0,1),(0,2),(0,3),(0,4)\\}$。\n- 测试用例 3 (完全图): $n = 5$，边 $E = \\{(u,v) \\mid 0 \\le u  v \\le 4\\}$，即在 $\\{0,1,2,3,4\\}$ 上的所有顶点对。\n- 测试用例 4 (非连通混合结构): $n = 6$，边 $E = \\{(0,1),(1,2),(2,0),(3,4),(4,5)\\}$。\n- 测试用例 5 (单个顶点): $n = 1$，边 $E = \\emptyset$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的、以逗号分隔的结果列表。此列表中的每个元素对应一个测试用例，并且其本身也必须是一个包含两个元素的列表：第一个元素是关节点的排序列表（整数列表），第二个元素是移除这些关节点后巨型连通分量的大小（一个整数）。例如，输出格式必须为\n$[r_1,r_2,\\dots,r_5]$\n其中每个 $r_i$ 的形式为 $[\\text{整数列表}, \\text{整数}]$。\n\n不涉及物理单位。不涉及角度。不涉及百分比。答案必须仅使用上述指定的基本类型（布尔值、整数、浮点数或这些类型的列表）表示。\n\n该问题要求：\n- 从连通分量和深度优先搜索（DFS）的核心定义出发，推导出一个基于 low-link 的、能正确识别关节点的判据，并解释其正确性。\n- 描述并证明在无向图上计算发现时间戳和 low-link 值所需的算法步骤，包括处理回边和树边，以及 DFS 根节点与非根节点的特殊作用。\n- 在不使用快捷公式的情况下，根据 $n$ 和 $m$ 分析时间和空间复杂度，并将复杂度与底层的每个顶点和每条边的操作联系起来。\n- 您的实现必须将该算法应用于测试套件，并以指定的单行格式打印结果。",
            "solution": "该问题要求设计、分析并实现一个算法，用于识别一个有限、简单、无向图 $G = (V, E)$ 中的所有关节点（或割点），并随后确定移除这些关节点后巨型连通分量的大小。该算法必须从第一性原理出发，使用深度优先搜索（DFS）和 low-link 值的概念进行推导。\n\n### 1. 基本概念：DFS 树与边的分类\n\n对图 $G$ 进行深度优先搜索遍历会系统地探索图的顶点和边。遍历从任意一个起始顶点开始，并沿着每个分支尽可能深地探索，然后回溯。这个过程自然地定义了图的一个生成森林，称为 DFS 森林（如果图是连通的，则为单个 DFS 树）。图的边 $E$ 可以根据此 DFS 森林进行分类：\n\n- **树边（Tree Edge）：** 如果顶点 $v$ 是在探索顶点 $u$ 的过程中首次被发现的，则边 $(u, v)$ 是一条树边。所有树边的集合构成了 DFS 生成森林。\n- **回边（Back Edge）：** 如果顶点 $v$ 是顶点 $u$ 在 DFS 树中的一个祖先，则边 $(u, v)$ 是一条回边。在无向图中，一个关键的特例是，根据此定义，从顶点 $u$ 指向其 DFS 树中父节点的边在技术上是一条回边，但我们必须在分析中将其排除在回边的考虑之外，以避免平凡的环。\n\n关节点是移除后会增加连通分量数量的顶点。我们可以通过分析一个顶点在 DFS 树结构中的作用来推导其成为关节点的条件。\n\n### 2. 关节点条件的推导\n\n让我们考虑一个任意顶点 $u \\in V$。我们根据它在 DFS 树中的位置来分析移除 $u$ 的影响。\n\n**情况 1：顶点 $u$ 是 DFS 树的根节点。**\nDFS 树的根是一个连通分量遍历的起点。当我们从 $u$ 开始进行 DFS 时，会生成一组以其子节点为根的子树。这些不同子树之间的任何路径都必须经过 $u$。如果我们移除 $u$，这些子树将彼此断开连接。如果根节点 $u$ 在 DFS 树中有两个或更多子节点，移除它将把单个连通分量分裂成至少两个分量（每个子节点的子树各成一个）。如果 $u$ 有零个或一个子节点，移除它不会使其后代彼此断开连接（因为最多只有一组后代）。因此，一个根节点 $u$ 是关节点的充要条件是它在 DFS 树中有超过一个子节点。\n\n**情况 2：顶点 $u$ 不是 DFS 树的根节点。**\n一个非根顶点 $u$ 在 DFS 树中有一个唯一的父节点，我们称之为 $p$。移除 $u$ 会将其父节点 $p$ 与其在 DFS 树中的任何一个子节点（例如 $v$）断开。包含 $p$ 的连通分量和包含以 $v$ 为根的子树的连通分量将会被分离，除非存在一条不经过 $u$ 的备用路径，连接以 $v$ 为根的子树和包含 $p$（以及 $u$ 的其他祖先）的图部分。这样一条备用路径必须由从 $v$ 的子树中某个顶点 $w$（$w$ 可以是 $v$ 本身）到 $u$ 的一个真祖先（即 $p$ 或 $p$ 的祖先）的一条回边形成。如果对于 $u$ 的某个子节点 $v$，以 $v$ 为根的子树中没有任何顶点有一条回边能连接到 $u$ 的真祖先，那么从该子树到图其余部分的所有路径都必须经过 $u$。在这种情况下，移除 $u$ 将切断这种连接，从而增加连通分量的数量。\n因此，一个非根顶点 $u$ 是关节点的充要条件是它在 DFS 树中至少有一个子节点 $v$，使得从以 $v$ 为根的子树出发，不存在任何一条回到 $u$ 的真祖先的回边。\n\n### 3. 使用发现时间和 Low-Link 值进行形式化\n\n为了在算法上形式化这个条件，我们引入两个在 DFS 遍历期间计算的度量：\n- **发现时间 `discovery[u]`**：在顶点 $u$ 首次被访问时分配给它的一个时间戳。我们可以使用一个简单的计数器，每发现一个新顶点就递增。根据定义，如果 $u$ 是 $v$ 在 DFS 树中的祖先，那么 `discovery[u]`  `discovery[v]`。\n- **Low-Link 值 `lowlink[u]`**：从 $u$ 出发，通过遍历零条或多条树边，然后至多一条回边所能到达的顶点的最小发现时间。\n\n`lowlink[u]` 值可以递归计算。在从顶点 $u$ 进行 DFS 的过程中：\n1.  初始化 `lowlink[u]` 为 `discovery[u]`。这代表了不使用任何回边的情况。\n2.  对于 $u$ 的每个邻居 $v$：\n    a. 如果 $(u,v)$ 是一条树边（即 $v$ 是 $u$ 的一个未访问过的子节点）：我们递归计算 `lowlink[v]`。递归调用返回后，我们更新 `lowlink[u] = min(lowlink[u], lowlink[v])`。这是因为如果 $v$ 的子树可以到达一个具有较小发现时间的祖先，那么 $u$ 也可以通过 $v$ 到达。\n    b. 如果 $(u,v)$ 是一条回边（且 $v$ 不是 $u$ 的父节点）：我们更新 `lowlink[u] = min(lowlink[u], discovery[v])`。我们使用 `discovery[v]` 是因为 $v$ 是一个祖先，这条回边提供了到达它的捷径。\n\n现在，我们可以重新表述非根顶点 $u$ 及其子节点 $v$ 的关节点条件：\n“以 $v$ 为根的子树没有到 $u$ 的*真祖先*的回边”这一条件，等价于“从 $v$ 的子树能到达的最小发现时间至少是 `discovery[u]`”。用我们的术语来说，这正是条件 `lowlink[v] = discovery[u]`。如果这个不等式成立，意味着以 $v$ 为根的子树最多只能回溯到 $u$ 本身，而无法到达 DFS 树中更高的位置。因此，$u$ 是该子树与图其余部分连接的唯一节点。\n\n### 4. 算法\n\n**第一部分：寻找关节点**\n完整的算法结合了这些思想：\n1.  初始化数据结构：图的邻接表、大小为 $n$ 的 `discovery` 和 `lowlink` 数组（初始化为哨兵值，如 -1）、一个 `parent` 数组、一个集合 `articulation_points` 以及一个时间计数器 `time = 0`。\n2.  遍历每个顶点 $i \\in \\{0, 1, \\dots, n-1\\}$。如果顶点 $i$ 未被访问，则从 $i$ 开始进行 DFS。这确保了所有连通分量（以及森林中的所有 DFS 树）都被访问到。\n3.  递归的 DFS 函数 `DFS(u, p)` 执行以下操作：\n    a. 标记 $u$ 为已访问。设置 `discovery[u] = lowlink[u] = time`，并增加 `time`。设置 `parent[u] = p`。\n    b. 初始化 DFS 树中的子节点计数器 `children_count = 0`。\n    c. 对于 $u$ 的每个邻居 $v$：\n        i. 如果 $v$ 是父节点 $p$，忽略这条边。\n        ii. 如果 $v$ 已被访问，意味着 $(u, v)$ 是一条回边。更新 `lowlink[u] = min(lowlink[u], discovery[v])`。\n        iii. 如果 $v$ 未被访问：\n            - 增加 `children_count`。\n            - 递归调用 `DFS(v, u)`。\n            - 调用返回后，更新 `lowlink[u] = min(lowlink[u], lowlink[v])`。\n            - **关节点检查**：\n                - 如果 $p$ 为空（即 $u$ 是根节点）且 `children_count  1`，将 $u$ 添加到 `articulation_points`。\n                - 如果 $p$ 不为空（即 $u$ 不是根节点）且 `lowlink[v] = discovery[u]`，将 $u$ 添加到 `articulation_points`。\n4.  初始循环完成后，`articulation_points` 包含所有割点的完整集合。\n\n**第二部分：计算巨型连通分量的大小**\n1.  令 $A$ 为已识别出的关节点集合。\n2.  构建剩余图 $G'$，它由顶点 $V' = V \\setminus A$ 和 $E$ 中连接 $V'$ 内两个顶点的所有边组成。\n3.  寻找 $G'$ 中所有连通分量的大小。这可以通过对 $V'$ 中的顶点进行另一系列遍历（DFS 或 BFS）来完成。\n4.  维护一个 `max_size` 变量。对于找到的每个分量，将 `max_size` 更新为其当前值与新找到的分量大小的最大值。\n5.  如果 $V'$ 为空（即所有顶点都是关节点），则大小为 $0$。否则，最终的 `max_size` 就是答案。\n\n### 5. 复杂度分析\n\n- **时间复杂度：** 算法的核心是一次完整的图的 DFS 遍历。主循环确保每个顶点都只被访问一次。DFS 函数对于每个顶点 `u`，会遍历其邻接表。在整个执行过程中，每条边 $(u, v)$ 被考虑两次：一次从 $u$ 的邻接表，一次从 $v$ 的。因此，DFS 部分的总工作量与所有顶点的度数之和成正比，即 $2m$。数组的初始化需要 $O(n)$ 时间。因此，寻找所有关节点需要 $O(n+m)$ 时间。后续寻找巨型连通分量的步骤涉及在子图上进行另一次图遍历，其时间上限也是 $O(n+m)$。因此，总时间复杂度为 $O(n+m)$。\n\n- **空间复杂度：** 该算法需要存储空间用于：\n    - 图的邻接表表示法：$O(n+m)$。\n    - `discovery`、`lowlink`、`parent` 和 `visited` 数组：每个需要 $O(n)$ 空间。\n    - DFS 的递归栈：在最坏情况下（一个路径图），递归深度可能为 $n$，需要 $O(n)$ 空间。\n    - 关节点集合：最多需要 $O(n)$ 空间。\n主要项是邻接表，因此总空间复杂度为 $O(n+m)$。",
            "answer": "```python\nimport sys\nimport numpy as np\n\n# It is a good practice to increase recursion limit for deep graphs in DFS.\nsys.setrecursionlimit(2000)\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test suite.\n    \"\"\"\n    test_cases = [\n        # Test case 1 (general multi-block case)\n        (8, [(0, 1), (1, 2), (2, 0), (2, 3), (3, 4), (4, 5), (5, 3), (5, 6), (6, 7)]),\n        # Test case 2 (tree star)\n        (5, [(0, 1), (0, 2), (0, 3), (0, 4)]),\n        # Test case 3 (complete graph)\n        (5, [(u, v) for u in range(5) for v in range(u + 1, 5)]),\n        # Test case 4 (disconnected mixed structure)\n        (6, [(0, 1), (1, 2), (2, 0), (3, 4), (4, 5)]),\n        # Test case 5 (single vertex)\n        (1, []),\n    ]\n\n    results = []\n    for n, edges in test_cases:\n        result = find_aps_and_giant_component(n, edges)\n        results.append(result)\n\n    # Convert results to the required string format\n    # The string representation of a list in Python matches the required format '[item1, item2]'.\n    output_str = f\"[{','.join(map(str, results))}]\"\n    print(output_str)\n\ndef find_aps_and_giant_component(n, edges):\n    \"\"\"\n    Finds articulation points and the size of the giant component after their removal.\n\n    Args:\n        n (int): The number of vertices.\n        edges (list of tuples): The list of edges in the graph.\n\n    Returns:\n        list: A list containing two elements:\n              - A sorted list of articulation points.\n              - An integer representing the size of the giant component.\n    \"\"\"\n    if n == 0:\n        return [[], 0]\n    \n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    # --- Part 1: Find Articulation Points using Tarjan's low-link algorithm ---\n    discovery = np.full(n, -1, dtype=int)\n    lowlink = np.full(n, -1, dtype=int)\n    parent = np.full(n, -1, dtype=int)\n    articulation_points = set()\n    time = 0\n\n    def find_aps_dfs(u):\n        nonlocal time\n        discovery[u] = lowlink[u] = time\n        time += 1\n        children_count = 0\n\n        for v in adj[u]:\n            if v == parent[u]:\n                continue\n            \n            if discovery[v] != -1:  # Back edge\n                lowlink[u] = min(lowlink[u], discovery[v])\n            else:  # Tree edge\n                children_count += 1\n                parent[v] = u\n                find_aps_dfs(v)\n                lowlink[u] = min(lowlink[u], lowlink[v])\n\n                # Articulation point conditions\n                # 1. u is the root of DFS tree and has more than one child.\n                if parent[u] == -1 and children_count > 1:\n                    articulation_points.add(u)\n                # 2. u is not root and low value of one of its children is more\n                #    than or equal to discovery time of u.\n                if parent[u] != -1 and lowlink[v] >= discovery[u]:\n                    articulation_points.add(u)\n\n    for i in range(n):\n        if discovery[i] == -1:\n            find_aps_dfs(i)\n    \n    sorted_aps = sorted(list(articulation_points))\n\n    # --- Part 2: Calculate size of giant component after removing APs ---\n    if len(sorted_aps) == n:\n        # If all vertices are articulation points, the remaining graph is empty.\n        giant_component_size = 0\n    else:\n        ap_set = set(sorted_aps)\n        visited_cc = set()\n        giant_component_size = 0\n\n        for i in range(n):\n            if i not in ap_set and i not in visited_cc:\n                current_component_size = 0\n                q = [i]\n                visited_cc.add(i)\n                head = 0\n                while head  len(q):\n                    u = q[head]\n                    head += 1\n                    current_component_size += 1\n                    for v in adj[u]:\n                        if v not in ap_set and v not in visited_cc:\n                            visited_cc.add(v)\n                            q.append(v)\n                giant_component_size = max(giant_component_size, current_component_size)\n\n    return [sorted_aps, giant_component_size]\n\nsolve()\n```"
        }
    ]
}