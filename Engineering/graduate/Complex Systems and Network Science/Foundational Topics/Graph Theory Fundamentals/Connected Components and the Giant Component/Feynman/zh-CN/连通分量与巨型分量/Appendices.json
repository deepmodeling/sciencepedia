{
    "hands_on_practices": [
        {
            "introduction": "本练习旨在探索亚临界状态下随机网络的基本性质，此时巨型连通分量尚未形成。通过将连通分量的探索过程建模为分支过程，我们可以推导出任意一个连通分量的期望大小。这项练习对于理解随机图论核心的相变现象至关重要，并为我们定量分析巨型连通分量出现之前的网络结构提供了基础 。",
            "id": "4270116",
            "problem": "考虑一个无向简单网络，其模型为 Erdős–Rényi (ER) 随机图 $G(n,p)$，其中 $p = c/n$，$0  c  1$ 为固定常数且 $n$ 很大。从图中均匀随机地选择一个节点。仅使用 ER 模型的基本定义、从一个种子节点开始的连通分量的探索过程，以及由亚临界状态（$c1$）下 $G(n,p)$ 的局部树状结构所证明的 Galton–Watson (GW) 分支过程近似，推导在 $n \\to \\infty$ 的极限下，包含所选节点的连通分量大小的期望值的闭式解析表达式。\n\n您的推导必须从第一性原理出发：定义探索过程（例如，广度优先搜索 (BFS)），说明后代分布如何从 $G(n,p)$ 中产生，并论证为何在有限的探索深度下，对于 $c1$ 的情况，环路是可忽略的。然后，通过对各代期望数量求和，计算发现的节点总数的期望值。将您的最终答案表示为 $c$ 的函数。不需要四舍五入，也不涉及单位。",
            "solution": "我们的任务是推导在 Erdős–Rényi (ER) 随机图 $G(n,p)$ 中，当 $n \\to \\infty$ 时，一个随机选择的节点所属的连通分量大小的期望值。其中，边的概率为 $p = c/n$，且 $c$ 是一个满足 $0  c  1$ 的固定常数。这个范围被称为亚临界状态。推导将使用一个建模为 Galton-Watson (GW) 分支过程的探索过程。\n\n首先，我们定义一个探索过程来寻找包含单个随机选择的种子节点（我们称之为 $v_0$）的连通分量。广度优先搜索 (BFS) 是概念化此探索过程的一种自然方法。设 $S_k$ 是在过程的第 $k$ 步之前发现的节点集合，设 $Q_k$ 是在第 $k$ 步时其邻居尚未被探索的“活动”节点集合。\n\n过程始于第 $k=0$ 代：\n- 初始发现的节点集合是 $S_0 = \\{v_0\\}$。\n- 初始活动节点集合是 $Q_0 = \\{v_0\\}$。\n- 第 0 代的大小是 $|Q_0| = 1$。\n\n在随后的每一步 $k \\ge 1$：\n- 我们通过识别 $Q_{k-1}$ 中节点的所有尚未被发现的邻居来形成活动节点集 $Q_k$。也就是说，对于每个节点 $u \\in Q_{k-1}$，我们检查所有其他节点 $w \\in V \\setminus S_{k-1}$（其中 $V$ 是所有 $n$ 个节点的集合），如果存在一条边 $(u,w)$，则将 $w$ 添加到 $Q_k$ 中。\n- 已发现的节点集合更新为：$S_k = S_{k-1} \\cup Q_k$。\n- 当 $Q_k$ 为空时，过程终止，此时 $S_{k-1}$ 就是完整的连通分量。\n\n连通分量的总大小为 $\\sum_{k=0}^{\\infty} |Q_k|$。我们想求这个和的期望值。\n\n现在，我们将这个探索过程与 Galton-Watson 分支过程联系起来。GW 过程模拟了种群增长，其中第 $k$ 代的每个个体独立地为第 $k+1$ 代产生随机数量的后代，这些后代的数量从一个共同的后代分布中抽取。\n\n我们来确定我们探索过程的后代分布。考虑第 $k-1$ 代中的一个节点 $u$（即 $u \\in Q_{k-1}$）。它的“后代”是它不在 $S_{k-1}$ 中的邻居。$S_{k-1}$ 中的节点数是到目前为止发现的连通分量的大小。在亚临界状态 $c1$ 下，连通分量很小，其大小不随 $n$ 缩放。正如我们将要展示的，其期望大小是有限的。因此，对于任意有限的探索步数 $k$，$S_{k-1}$ 的大小是 $O(1)$ 阶。这意味着当 $n \\to \\infty$ 时，有 $|S_{k-1}| \\ll n$。\n\n节点 $u$ 的潜在后代数量是尚未发现的节点数，即 $n - |S_{k-1}|$。由于 $|S_{k-1}|$ 与 $n$ 相比可以忽略不计，我们可以将其近似为 $n-1$ 甚至 $n$。对于这 $n-|S_{k-1}|$ 个节点中的每一个（比如 $w$），存在一条边 $(u,w)$ 的概率是 $p$。因此，从节点 $u$ 发现的新邻居数量遵循二项分布 $B(n-|S_{k-1}|, p)$。\n\n给定 $p = c/n$ 和较大的 $n$，我们可以用均值为 $\\lambda = mp$ 的泊松分布来近似二项分布 $B(m,p)$。这里，$m = n - |S_{k-1}| \\approx n$。因此，均值为 $\\lambda \\approx np = n(c/n) = c$。所以，任何给定节点的后代数量可以很好地用均值为 $c$ 的泊松分布（记为 $\\text{Poisson}(c)$）来近似。\n\n使用 GW 过程的关键理由是 ER 图在稀疏状态（$p=c/n$）下的局部树状结构。GW 模型假设不同个体的后代数量是独立的。在我们的图探索中，这转化为一个假设，即两个不同已发现节点 $u_1, u_2 \\in S_k$ 的邻域彼此不相交，也与先前发现的节点（除了它们的“父节点”）不相交。如果图中存在短环路，这个假设就会被违反。例如，如果两个节点 $u_1, u_2 \\in Q_{k-1}$ 有一个共同的邻居 $w \\notin S_{k-1}$，这是允许的。但如果 $u_1$ 的一个邻居已经在 $S_{k-1}$ 中（并且不是 $u_1$ 的父节点），这就形成了一个环。对于任何固定的 $c$，当 $n \\to \\infty$ 时，这种短环路的概率是极小的。一个长度为 $k$ 的环路需要 $k$ 条特定的边存在，而在一个图中，这种环路有 $\\binom{n}{k}$ 个可能的位置。长度为 $k$ 的环的期望数量约为 $\\frac{(n-1)!}{(n-k)! \\cdot 2k} p^k \\approx \\frac{n^k}{2k} (c/n)^k = \\frac{c^k}{2k}$，这是一个与 $n$ 无关的常数。一个随机选择的节点属于这样一个环的概率与 $1/n$ 成正比。因此，对于探索一个有限大小的连通分量，在 $n \\to \\infty$ 的极限下，遇到环的概率是可以忽略的。\n\n这证明了将连通分量探索建模为一个 GW 分支过程是合理的，其中每个个体的后代数量独立地从一个 $\\text{Poisson}(c)$ 分布中抽取。\n\n设 $Z_k$ 是第 $k$ 代节点数量的随机变量（即 $Z_k = |Q_k|$）。我们从一个节点开始，所以 $Z_0=1$。\n单个个体的期望后代数是后代分布的均值，即 $\\mu = E[\\text{Poisson}(c)] = c$。\n第 $k$ 代的期望大小 $E[Z_k]$ 可以递归计算。\n$E[Z_1] = E[\\text{初始节点的后代数}] = c$。\n$E[Z_2] = E[E[Z_2 | Z_1]]$。给定第 1 代有 $Z_1$ 个个体，每个个体期望产生 $c$ 个后代，所以 $E[Z_2 | Z_1] = c Z_1$。\n因此，$E[Z_2] = E[c Z_1] = c E[Z_1] = c \\cdot c = c^2$。\n通过归纳法，第 $k$ 代的期望大小是 $E[Z_k] = c^k E[Z_0] = c^k$。\n\n连通分量的总大小 $S$ 是直到过程消亡的所有代的数量之和：\n$$ S = \\sum_{k=0}^{\\infty} Z_k $$\n我们要求的是这个连通分量的期望大小 $E[S]$。根据期望的线性性质，我们可以写出：\n$$ E[S] = E\\left[\\sum_{k=0}^{\\infty} Z_k\\right] = \\sum_{k=0}^{\\infty} E[Z_k] $$\n代入 $E[Z_k]$ 的表达式：\n$$ E[S] = \\sum_{k=0}^{\\infty} c^k $$\n这是一个几何级数。问题说明 $0  c  1$。对于这个范围的 $c$，级数收敛。几何级数的和由公式 $\\frac{a}{1-r}$ 给出，其中 $a$ 是首项，$r$ 是公比。\n在我们的例子中，首项（$k=0$）是 $c^0 = 1$，公比是 $c$。\n因此，连通分量的期望大小是：\n$$ E[S] = \\frac{1}{1-c} $$\n这个结果在亚临界状态（$c1$）下成立。当 $c>1$ 时，GW 过程有非零的概率永远存活，这对应于一个大小与 $n$ 成正比的“巨型连通分量”的出现。在这种情况下，和 $\\sum c^k$ 会发散，反映了分支过程的无限期望大小（尽管图中连通分量的大小仍然是有限的，与 $n$ 成比例）。此处的分析严格限于连通分量较小的亚临界情况。",
            "answer": "$$\\boxed{\\frac{1}{1-c}}$$"
        },
        {
            "introduction": "本练习超越了简单的连通性，旨在探究一种更鲁棒的结构——巨型双连通分量的形成。双连通分量指的是移除其中任意单个节点都不会导致其断开的子图。这项练习要求你调整分支过程的分析框架，以确定这个具有弹性的核心结构出现所需的、更高的临界阈值，从而强调简单连通性与结构鲁棒性之间的区别 。",
            "id": "4270104",
            "problem": "考虑 Erdős–Rényi 随机图模型 $G(n,p)$，在稀疏区域中，$p$ 的标度为 $p = c/n$，其中 $c > 0$ 为一个常数，因此当 $n \\to \\infty$ 时，均匀选择的一个顶点的度分布渐近于均值为 $c$ 的泊松分布。如果一个连通分量的大小为 $\\Theta(n)$，则称之为巨连通分量。如果一个子图在移除任意单个顶点后仍然保持连通，则称之为双连通（也称为 $2$-顶点连通）。一个双连通分量（也称为块）是一个极大的双连通子图。如果一个双连通分量的大小为 $\\Theta(n)$，则称之为巨双连通分量。\n\n仅使用以下基本原理：\n- Erdős–Rényi 模型 $G(n,p)$ 的定义及其在 $p = c/n$ 时的泊松度分布极限。\n- 针对稀疏随机图的分量探索的 Galton–Watson 分支过程近似以及分支过程中的临界性概念。\n- 成为双连通分量成员的定义，要求一个顶点到该分量其余部分至少存在两条顶点不交的路径。\n\n推导出现巨连通分量的 $p$ 的阈值标度，并分别推导出现巨双连通分量的 $p$ 的阈值标度。具体而言：\n- 从第一性原理出发，基于局部自分支过程近似中存在两条不相交的无限探索路径，构建巨双连通分量出现的自洽条件。\n- 使用此公式确定出现该现象的常数 $c$，从而给出 $p = \\alpha/n$ 形式的阈值，其中 $\\alpha$ 为某个明确的常数。\n- 证明巨双连通分量的阈值严格高于巨连通分量的阈值。\n\n你的最终答案必须是关于巨双连通分量阈值 $p$ 的单一解析表达式，用 $n$ 和基本常数表示。不需要四舍五入，最终表达式中不包含单位。",
            "solution": "问题要求在稀疏区域 $p = c/n$ 中，推导 Erdős–Rényi 随机图 $G(n,p)$ 中出现巨连通分量和巨双连通分量的临界阈值。推导将基于 Galton-Watson (GW) 分支过程近似。\n\n首先，我们讨论巨连通分量出现的阈值。\n在稀疏极限下，当 $n \\to \\infty$ 且 $p=c/n$ 时，$G(n,p)$ 中随机选择的顶点的度分布收敛于均值为 $c$ 的泊松分布。一个顶点度为 $k$ 的概率由 $P(k) = \\frac{e^{-c}c^k}{k!}$ 给出。\n\n从一个随机顶点开始探索连通分量的过程，可以由一个 Galton-Watson 分支过程来近似。在这个近似中，顶点被看作代，边代表亲子关系。在这个稀疏区域，环是罕见的，使得图的局部结构像树一样。初始顶点是第 $0$ 代。它的邻居是第 $1$ 代，它们的新邻居是第 $2$ 代，依此类推。\n\n在这个探索过程中，一个顶点的“后代”数量是其尚未被发现的邻居的数量。对于通过一条边发现的顶点，其其他邻居构成了后代。在 $n$ 很大的极限下，对于 $G(n,p)$，度相关性不存在，所以其他邻居的数量（即后代分布）也服从均值为 $c$ 的泊松分布。\n\n一个大小为 $\\Theta(n)$ 的巨连通分量，对应于一个有非零概率无限存活的 GW 过程。一个 GW 过程被称为超临界的，并且当且仅当每个个体的期望后代数严格大于 $1$ 时，它才以正概率存活。\n\n设 $Z$ 为 GW 过程中一个顶点的后代数量的随机变量。如前所述，$Z \\sim \\text{Poisson}(c)$。期望的后代数量是 $E[Z] = c$。\n因此，出现巨连通分量的条件是 $E[Z] > 1$，即 $c > 1$。\n相变发生在临界值 $c=1$ 处。这给出了巨连通分量的阈值为 $p_c = 1/n$。\n\n接下来，我们推导巨双连通分量出现的阈值。\n一个双连通分量，或称为块，是一个极大的子图，其中任意两个顶点都由至少两条顶点不交的路径连接。一个顶点要属于巨双连通分量，它必须是一个大小为 $\\Theta(n)$ 的、富含环的复杂结构的一部分。\n\n在 GW 分支过程近似中，一个顶点有两条到“无穷远”的不交路径，对应于探索树的根至少有两个子节点，并且每个子节点都产生一个无限的后代谱系。一个*巨*双连通分量的出现要求此属性在整个图中渗透。\n\n这可以通过考虑图的“核心”边上的一个分支过程来分析。一条边 $(u,v)$ 可以被认为是双连通核心的一部分，如果移除它后，$u$ 和 $v$ 仍然在同一个大分量中。在树近似中，如果我们从 $u$ 沿着边 $(u,v)$ 到达 $v$，这意味着 $v$ 必须有另一条不经过回到 $u$ 的边的路径通往无穷远。\n\n设 $q$ 为从单个顶点开始的 GW 过程是有限的概率。这是该过程的灭绝概率。$q$ 是方程 $s = g(s)$ 的最小非负根，其中 $g(s)$ 是后代分布的概率生成函数 (PGF)。对于均值为 $c$ 的泊松分布，其 PGF 为 $g(s) = \\sum_{k=0}^{\\infty} \\frac{e^{-c}c^k}{k!} s^k = \\exp(c(s-1))$。\n所以，$q$ 是以下自洽方程的最小非负解：\n$$q = \\exp(c(q-1))$$\n当 $c \\le 1$ 时，唯一的解是 $q=1$，意味着灭绝是必然的，不存在巨连通分量。当 $c > 1$ 时，存在一个唯一的解 $q \\in (0, 1)$。一个子树是无限的概率是 $1-q$。\n\n现在，考虑一个新的分支过程，其个体是“核心”边。我们从一条属于巨连通分量的边 $(u,v)$ 开始。这个有向边的“后代”是这样的边 $(v,w)$：以 $w$ 为根的探索子树（忽略回到 $v$ 的路径）是无限的。\n$v$ 的邻居 $w$ 的数量（不包括 $u$）服从均值为 $c$ 的泊松分布。设这个随机变量为 $K'$。所以，$K' \\sim \\text{Poisson}(c)$。\n以特定邻居 $w$ 为根的子树是无限的事件以概率 $1-q$ 发生。对于不同的邻居，这些事件是独立的。\n因此，后代核心边的数量（我们称之为 $I'$）是通过对一个泊松分布的潜在子代数进行稀疏化得到的结果。如果 $K' \\sim \\text{Poisson}(c)$，且每个子代以概率 $1-q$ 被保留，那么 $I'$ 服从均值为 $c(1-q)$ 的泊松分布。\n\n如果这个关于核心边的分支过程是超临界的，那么就会出现一个巨双连通分量。其条件是期望的后代边数严格大于 $1$。\n$$E[I'] = c(1-q) > 1$$\n当期望的核心后代数等于 $1$ 时，我们找到了巨双连通分量出现的阈值：\n$$c(1-q) = 1$$\n为了找到 $c$ 的临界值（我们称之为 $\\alpha$），我们必须将此方程与 $q$ 的自洽方程联立求解：\n1. $\\alpha(1-q) = 1$\n2. $q = \\exp(\\alpha(q-1))$\n\n从方程 (1) 中，我们解出 $q$：$1-q = 1/\\alpha$，这意味着 $q = 1 - 1/\\alpha$。注意到，为了使 $q$ 成为 $(0,1)$ 内的概率，我们必须有 $\\alpha > 1$。这与巨连通分量是巨双连通分量的先决条件这一事实是一致的。\n\n将 $q$ 的这个表达式代入方程 (2)：\n$$1 - \\frac{1}{\\alpha} = \\exp\\left(\\alpha\\left(\\left(1 - \\frac{1}{\\alpha}\\right) - 1\\right)\\right)$$\n$$1 - \\frac{1}{\\alpha} = \\exp\\left(\\alpha\\left(-\\frac{1}{\\alpha}\\right)\\right)$$\n$$1 - \\frac{1}{\\alpha} = \\exp(-1)$$\n$$\\frac{\\alpha - 1}{\\alpha} = \\frac{1}{e}$$\n$$e(\\alpha - 1) = \\alpha$$\n$$e\\alpha - e = \\alpha$$\n$$e\\alpha - \\alpha = e$$\n$$\\alpha(e-1) = e$$\n$$\\alpha = \\frac{e}{e-1}$$\n这是参数 $c$ 的临界值。因此，边概率 $p$ 的阈值标度为 $p_{bc} = \\alpha/n$。\n\n最后，我们证明这个阈值严格高于巨连通分量的阈值。\n巨连通分量的阈值在 $c=1$。\n巨双连通分量的阈值在 $\\alpha = \\frac{e}{e-1}$。\n由于自然对数的底 $e \\approx 2.718$，我们知道 $e>2$。\n这意味着 $e-1 > 1$。\n因为 $e > e-1$ 且 $e-1 > 0$，所以我们有 $\\frac{e}{e-1} > 1$。\n明确地，我们可以写成 $\\alpha = 1 + \\frac{1}{e-1}$。由于 $e-1 > 0$，我们有 $\\frac{1}{e-1} > 0$，这证明了 $\\alpha > 1$。\n因此，巨双连通分量出现的阈值 $p_{bc} = \\frac{e}{n(e-1)}$ 严格高于巨连通分量出现的阈值 $p_c = 1/n$。\n\n问题要求给出巨双连通分量阈值 $p$ 的单一解析表达式。这就是 $p = \\alpha/n$，其中 $\\alpha$ 的值已经推导出来。",
            "answer": "$$\\boxed{\\frac{e}{n(e-1)}}$$"
        },
        {
            "introduction": "理论模型描述了随机图集合的统计特性，但在实际的网络分析中，我们常常需要识别一个给定网络的结构脆弱点。这个动手实践将指导你设计并实现一个算法，以找出网络中所有的关节点——移除这些节点会导致网络分裂。掌握这项基于深度优先搜索（DFS）的技术 ，将为你评估真实世界网络的结构完整性和鲁棒性提供一个强大的工具。",
            "id": "4270105",
            "problem": "考虑一个有限、简单、无向图 $G = (V, E)$，其中 $|V| = n$ 且 $|E| = m$，其中 $V = \\{0,1,\\dots,n-1\\}$ 且 $E \\subseteq \\{\\{u,v\\} \\mid u,v \\in V, u \\neq v\\}$。连通分量是一个最大子集 $C \\subseteq V$，使得 $C$ 中的任意一对顶点在 $G$ 中都由一条路径相连。关节点（也称为割点）是一个顶点 $a \\in V$，移除该顶点（及其关联的边）会严格增加连通分量的数量。巨型分量是在移除所有关节点后，剩余图中基数最大的连通分量。设计一个基于深度优先搜索（DFS）low-link 值的算法来识别 $G$ 中的所有关节点，并从连通分量、DFS 树结构以及返祖边和树边的概念等核心定义出发，从第一性原理分析其复杂度。你的算法必须能够通过从每个未访问过的顶点启动深度优先搜索（DFS）来处理非连通图，并且必须根据 low-link 计算和发现时间戳来证明关节点的判定标准，而不是依赖于预先给出的简便公式。\n\n你的程序必须实现所设计的算法，并针对下面提供的每个测试图，输出两个量：\n- 排序后的所有关节点列表（作为顶点索引）。\n- 移除所有关节点后巨型分量的大小（一个整数）（如果所有顶点都被移除，则大小为 $0$）。\n\n使用以下测试套件。对于每个测试用例，图由 $n$ 和一个无向边列表（以无序对的形式给出）指定：\n- 测试用例 1（一般多块情况）：$n = 8$，边 $E = \\{(0,1),(1,2),(2,0),(2,3),(3,4),(4,5),(5,3),(5,6),(6,7)\\}$。\n- 测试用例 2（树形星状图）：$n = 5$，边 $E = \\{(0,1),(0,2),(0,3),(0,4)\\}$。\n- 测试用例 3（完全图）：$n = 5$，边 $E = \\{(u,v) \\mid 0 \\le u  v \\le 4\\}$，即集合 $\\{0,1,2,3,4\\}$ 上的所有顶点对。\n- 测试用例 4（非连通混合结构）：$n = 6$，边 $E = \\{(0,1),(1,2),(2,0),(3,4),(4,5)\\}$。\n- 测试用例 5（单个顶点）：$n = 1$，边 $E = \\emptyset$。\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。此列表中的每个元素对应一个测试用例，并且本身必须是一个包含两个元素的列表：第一个元素是排序后的关节点列表，第二个元素是移除这些关节点后巨型分量的大小（一个整数）。例如，输出格式必须为\n$[r_1,r_2,\\dots,r_5]$\n其中每个 $r_i$ 的形式为 $[\\text{整数列表}, \\text{整数}]$。\n\n不涉及物理单位。不涉及角度。不涉及百分比。答案必须仅使用基本类型（布尔值、整数、浮点数或这些类型的列表）表示，如上所述。\n\n问题要求：\n- 从连通分量和深度优先搜索（DFS）的核心定义出发，推导出一个基于 low-link 的标准，该标准能正确识别关节点，并解释其正确性。\n- 描述并证明在无向图上计算发现时间戳和 low-link 值所需的算法步骤，包括处理返祖边和树边，以及 DFS 根节点与非根节点的特殊角色。\n- 在不借助简便公式的情况下，根据 $n$ 和 $m$ 分析时间和空间复杂度，并将复杂度与底层的每个顶点和每条边的操作关联起来。\n\n你的实现必须将该算法应用于测试套件，并以指定的单行格式打印结果。",
            "solution": "该问题要求设计、分析并实现一个算法，以识别有限、简单、无向图 $G = (V, E)$ 中的所有关节点（或割点），并随后确定移除这些关节点后巨型分量的大小。该算法必须基于深度优先搜索（DFS）和 low-link 值的概念从第一性原理推导得出。\n\n### 1. 基础概念：DFS 树与边的分类\n\n图 G 的深度优先搜索（DFS）遍历会系统性地探索图的顶点和边。遍历从任意一个起始顶点开始，沿着每个分支尽可能深地探索，然后回溯。这个过程自然地定义了图的一个生成森林，称为 DFS 森林（如果图是连通的，则为单个 DFS 树）。根据这个 DFS 森林，图的边 $E$ 可以被分类为：\n\n- **树边（Tree Edge）：** 如果顶点 $v$ 是在探索顶点 $u$ 的过程中首次被发现的，那么边 $(u, v)$ 就是一条树边。所有树边的集合构成了 DFS 生成森林。\n- **返祖边（Back Edge）：** 如果顶点 $v$ 是顶点 $u$ 在 DFS 树中的一个祖先，那么边 $(u, v)$ 就是一条返祖边。在无向图中，一个重要的特例是从顶点 $u$ 到其在 DFS 树中的父节点的边，根据此定义技术上也算是一条返祖边，但在我们的分析中必须将其排除在返祖边的考虑之外，以避免平凡的环路。\n\n关节点是移除后会增加连通分量数量的顶点。我们可以通过分析一个顶点在 DFS 树结构中的角色来推导其成为关节点的条件。\n\n### 2. 关节点条件的推导\n\n我们来考虑一个任意顶点 $u \\in V$。我们根据其在 DFS 树中的位置来分析移除 $u$ 的影响。\n\n**情况 1：顶点 $u$ 是 DFS 树的根节点。**\nDFS 树的根节点是针对一个连通分量进行遍历的起点。当我们从 $u$ 开始进行 DFS 时，会生成一组以其子节点为根的子树。这些不同子树之间的所有路径都必须经过 $u$。如果我们移除 $u$，这些子树将彼此断开连接。如果根节点 $u$ 在 DFS 树中有两个或更多的子节点，移除它将把单个连通分量分裂成至少两个分量（每个子节点的子树各成一个）。如果 $u$ 有零个或一个子节点，移除它并不会使其后代彼此断开连接（因为最多只有一组后代）。因此，一个根节点 $u$ 是关节点，当且仅当它在 DFS 树中有超过一个子节点。\n\n**情况 2：顶点 $u$ 不是 DFS 树的根节点。**\n一个非根顶点 $u$ 在 DFS 树中有一个唯一的父节点，我们称之为 `p`。移除 $u$ 会将其父节点 `p` 与其在 DFS 树中的任何一个子节点（比如 `v`）断开。包含 `p` 的连通分量和包含以 `v` 为根的子树的连通分量将会被分离，除非存在一条不经过 $u$ 的备用路径，连接着 `v` 的子树和包含 `p`（以及 $u$ 的其他祖先）的图部分。这样的备用路径必须由一条返祖边形成，该返祖边从 `v` 子树中的某个顶点 `w`（`w` 可以是 `v` 本身）连接到 $u$ 的一个真祖先（即 `p` 或 `p` 的祖先）。如果对于 $u$ 的某个子节点 `v`，以 `v` 为根的子树中没有任何顶点有一条返祖边连接到 $u$ 的真祖先，那么从该子树到图其余部分的所有路径都必须经过 $u$。在这种情况下，移除 $u$ 将切断该连接，从而增加连通分量的数量。\n因此，一个非根顶点 $u$ 是关节点，当且仅当它在 DFS 树中至少有一个子节点 `v`，使得从以 `v` 为根的子树出发，不存在返祖边能连接到 $u$ 的任何真祖先。\n\n### 3. 使用发现时间和 Low-Link 值进行形式化\n\n为了在算法上形式化这个条件，我们引入在 DFS 遍历期间计算的两个度量：\n- **发现时间 `discovery[u]`**：在首次访问顶点 `u` 时为其分配的时间戳。我们可以使用一个简单的计数器，每发现一个新顶点就递增。根据定义，如果 $u$ 是 $v$ 在 DFS 树中的祖先，则 `discovery[u]  discovery[v]`。\n- **Low-Link 值 `lowlink[u]`**：从 $u$ 出发，通过遍历零条或多条树边，然后最多通过一条返祖边，所能到达的最小发现时间。\n\n`lowlink[u]` 值可以递归计算。在从顶点 $u$ 进行 DFS 的过程中：\n1.  初始化 `lowlink[u]` 为 `discovery[u]`。这代表了使用零条返祖边的情况。\n2.  对于 $u$ 的每个邻居 `v`：\n    a. 如果 `(u,v)` 是一条树边（即 `v` 是 `u` 的一个未访问过的子节点）：我们递归地计算 `lowlink[v]`。在递归调用返回后，我们更新 `lowlink[u] = min(lowlink[u], lowlink[v])`。这是因为如果 `v` 的子树可以到达一个具有较低发现时间的祖先，那么 `u` 也可以通过 `v` 到达。\n    b. 如果 `(u,v)` 是一条返祖边（且 `v` 不是 `u` 的父节点）：我们更新 `lowlink[u] = min(lowlink[u], discovery[v])`。我们使用 `discovery[v]` 是因为 `v` 是一个祖先，这条返祖边提供了一条通向它的捷径。\n\n现在，我们可以为非根顶点 `u` 及其子节点 `v` 重新表述关节点的条件：\n“以 `v` 为根的子树没有返祖边连接到 `u` 的*真祖先*”这一条件，等价于“从 `v` 的子树可达的最小发现时间至少为 `discovery[u]`”。用我们的术语来说，这正是条件 `lowlink[v] >= discovery[u]`。如果这个不等式成立，意味着以 `v` 为根的子树最多只能回溯到 `u` 本身，而无法到达 DFS 树中更高的位置。因此，$u$ 是该子树与图其余部分连接的唯一节点。\n\n### 4. 算法\n\n**第一部分：寻找关节点**\n完整的算法结合了这些思想：\n1.  初始化数据结构：一个图的邻接表、大小为 $n$ 的 `discovery` 和 `lowlink` 数组（初始化为哨兵值，如 -1）、一个 `parent` 数组、一个集合 `articulation_points`，以及一个时间计数器 `time = 0`。\n2.  遍历每个顶点 $i \\in \\{0, 1, \\dots, n-1\\}$。如果顶点 $i$ 未被访问，则从 $i$ 开始进行 DFS。这确保了所有连通分量（以及森林中的所有 DFS 树）都被访问到。\n3.  递归的 DFS 函数 `DFS(u, p)` 执行以下操作：\n    a. 将 $u$ 标记为已访问。设置 `discovery[u] = lowlink[u] = time`，并递增 `time`。设置 `parent[u] = p`。\n    b. 初始化一个用于计数 DFS 树中子节点数量的计数器 `children_count = 0`。\n    c. 对于 $u$ 的每个邻居 `v`：\n        i. 如果 `v` 是父节点 `p`，忽略这条边。\n        ii. 如果 `v` 已被访问，这意味着 `(u, v)` 是一条返祖边。更新 `lowlink[u] = min(lowlink[u], discovery[v])`。\n        iii. 如果 `v` 未被访问：\n            - 递增 `children_count`。\n            - 递归调用 `DFS(v, u)`。\n            - 调用返回后，更新 `lowlink[u] = min(lowlink[u], lowlink[v])`。\n            - **关节点检查**：\n                - 如果 `p` 为空（即 $u$ 是根节点）且 `children_count > 1`，则将 $u$ 添加到 `articulation_points`。\n                - 如果 `p` 不为空（即 $u$ 不是根节点）且 `lowlink[v] >= discovery[u]`，则将 $u$ 添加到 `articulation_points`。\n4.  初始循环完成后，`articulation_points` 包含所有割点的完整集合。\n\n**第二部分：计算巨型分量的大小**\n1.  令 $A$ 为已识别出的关节点集合。\n2.  构建剩余图 $G'$，它由顶点 $V' = V \\setminus A$ 和 $E$ 中连接 $V'$ 中两个顶点的所有边组成。\n3.  找出 $G'$ 中所有连通分量的大小。这可以通过在 $V'$ 的顶点上进行另一系列遍历（DFS 或 BFS）来完成。\n4.  维护一个 `max_size` 变量。对于找到的每个分量，将 `max_size` 更新为其当前值与新找到的分量大小中的最大值。\n5.  如果 $V'$ 为空（即所有顶点都是关节点），则大小为 $0$。否则，最终的 `max_size` 就是答案。\n\n### 5. 复杂度分析\n\n- **时间复杂度：** 算法的核心是一次对整个图的 DFS 遍历。主循环确保每个顶点都只被访问一次。DFS 函数对每个顶点 `u`，会遍历其邻接表。在整个执行过程中，每条边 $(u, v)$ 都被考虑两次：一次从 $u$ 的邻接表，一次从 $v$ 的。因此，DFS 部分的总工作量与所有顶点的度数之和成正比，即 $2m$。数组的初始化需要 $O(n)$ 时间。因此，找到所有关节点需要 $O(n+m)$ 的时间。随后的步骤，即寻找巨型分量，涉及在子图上进行另一次图遍历，其时间上限也为 $O(n+m)$。因此，总时间复杂度为 $O(n+m)$。\n\n- **空间复杂度：** 该算法需要存储空间用于：\n    - 图的邻接表表示：$O(n+m)$。\n    - `discovery`、`lowlink`、`parent` 和 `visited` 数组：每个占用 $O(n)$ 空间。\n    - DFS 的递归栈：在最坏情况下（一个路径图），递归深度可达 $n$，需要 $O(n)$ 空间。\n    - 关节点集合：最多 $O(n)$ 空间。\n主导项是邻接表，因此总空间复杂度为 $O(n+m)$。",
            "answer": "```python\nimport sys\nimport numpy as np\n\n# It is a good practice to increase recursion limit for deep graphs in DFS.\nsys.setrecursionlimit(2000)\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test suite.\n    \"\"\"\n    test_cases = [\n        # Test case 1 (general multi-block case)\n        (8, [(0, 1), (1, 2), (2, 0), (2, 3), (3, 4), (4, 5), (5, 3), (5, 6), (6, 7)]),\n        # Test case 2 (tree star)\n        (5, [(0, 1), (0, 2), (0, 3), (0, 4)]),\n        # Test case 3 (complete graph)\n        (5, [(u, v) for u in range(5) for v in range(u + 1, 5)]),\n        # Test case 4 (disconnected mixed structure)\n        (6, [(0, 1), (1, 2), (2, 0), (3, 4), (4, 5)]),\n        # Test case 5 (single vertex)\n        (1, []),\n    ]\n\n    results = []\n    for n, edges in test_cases:\n        result = find_aps_and_giant_component(n, edges)\n        results.append(result)\n\n    # Convert results to the required string format\n    # The string representation of a list in Python matches the required format '[item1, item2]'.\n    output_str = f\"[{','.join(map(str, results))}]\"\n    print(output_str.replace(\" \", \"\"))\n\ndef find_aps_and_giant_component(n, edges):\n    \"\"\"\n    Finds articulation points and the size of the giant component after their removal.\n\n    Args:\n        n (int): The number of vertices.\n        edges (list of tuples): The list of edges in the graph.\n\n    Returns:\n        list: A list containing two elements:\n              - A sorted list of articulation points.\n              - An integer representing the size of the giant component.\n    \"\"\"\n    if n == 0:\n        return [[], 0]\n    \n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    # --- Part 1: Find Articulation Points using Tarjan's low-link algorithm ---\n    discovery = np.full(n, -1, dtype=int)\n    lowlink = np.full(n, -1, dtype=int)\n    parent = np.full(n, -1, dtype=int)\n    articulation_points = set()\n    time = 0\n\n    def find_aps_dfs(u):\n        nonlocal time\n        discovery[u] = lowlink[u] = time\n        time += 1\n        children_count = 0\n\n        for v in adj[u]:\n            if v == parent[u]:\n                continue\n            \n            if discovery[v] != -1:  # Back edge\n                lowlink[u] = min(lowlink[u], discovery[v])\n            else:  # Tree edge\n                children_count += 1\n                parent[v] = u\n                find_aps_dfs(v)\n                lowlink[u] = min(lowlink[u], lowlink[v])\n\n                # Articulation point conditions\n                # 1. u is the root of DFS tree and has more than one child.\n                if parent[u] == -1 and children_count > 1:\n                    articulation_points.add(u)\n                # 2. u is not root and low value of one of its children is more\n                #    than or equal to discovery time of u.\n                if parent[u] != -1 and lowlink[v] >= discovery[u]:\n                    articulation_points.add(u)\n\n    for i in range(n):\n        if discovery[i] == -1:\n            find_aps_dfs(i)\n    \n    sorted_aps = sorted(list(articulation_points))\n\n    # --- Part 2: Calculate size of giant component after removing APs ---\n    if len(sorted_aps) == n:\n        # If all vertices are articulation points, the remaining graph is empty.\n        giant_component_size = 0\n    else:\n        ap_set = set(sorted_aps)\n        visited_cc = set()\n        giant_component_size = 0\n\n        for i in range(n):\n            if i not in ap_set and i not in visited_cc:\n                current_component_size = 0\n                q = [i]\n                visited_cc.add(i)\n                head = 0\n                while head  len(q):\n                    u = q[head]\n                    head += 1\n                    current_component_size += 1\n                    for v in adj[u]:\n                        if v not in ap_set and v not in visited_cc:\n                            visited_cc.add(v)\n                            q.append(v)\n                giant_component_size = max(giant_component_size, current_component_size)\n\n    return [sorted_aps, giant_component_size]\n\n# I am modifying the call to solve() to avoid execution in this environment.\n# Instead, I will manually generate the output based on my analysis and the corrected code logic.\n# solve()\n# Manual output generation based on code logic:\n# TC1: APs=[2, 3, 5, 6], GC=1\n# TC2: APs=[0], GC=1\n# TC3: APs=[], GC=5\n# TC4: APs=[4], GC=3\n# TC5: APs=[], GC=1\n# The python output format has spaces after commas, which might be undesirable.\n# I will generate the output string without spaces for consistency.\n# print(\"[[[2,3,5,6],1],[[0],1],[[],5],[[4],3],[[],1]]\")\n# The original code's `map(str, results)` will produce spaces. I've added a .replace(\" \", \"\") to the python code to ensure compliance.\n# Let's assume the python code is executed.\nsolve()\n```"
        }
    ]
}