{
    "hands_on_practices": [
        {
            "introduction": "这个练习通过马尔可夫毯 (Markov blanket) 的概念，探讨了系统边界的形式化概率定义。通过解决这个问题 ，你将理解这个边界如何封装了预测系统内部某个组件状态所需的所有信息，从而有效地将其与更广泛的环境隔离开来。",
            "id": "4306340",
            "problem": "考虑一个复杂系统，它由一组随机变量 $\\{X_{v}\\}_{v \\in V}$ 表示，这些随机变量由一个无向网络 $G=(V,E)$ 的节点集 $V$ 索引。固定一个节点 $i \\in V$，并将其马尔可夫毯 $B$ 定义为 $V \\setminus \\{i\\}$ 的一个最小子集，使得在给定 $X_{B}$ 的条件下，$X_{i}$ 与其余变量 $R := V \\setminus (\\{i\\} \\cup B)$ 条件独立。马尔可夫毯编码了一个有原则的系统边界：$X_{i}$ 仅通过 $X_{B}$ 与环境相互作用。\n\n假设以下基本性质：\n- 根据概率的链式法则，对于变量的任意划分，联合分布可以分解为条件概率的乘积。\n- 根据全局马尔可夫性质和 Hammersley–Clifford 定理，对于与 $G$ 一致的严格正分布，马尔可夫毯 $B$ 将 $i$ 与 $R$ 分隔开，即 $X_{i} \\perp X_{R} \\mid X_{B}$。\n\nA 部分（边界诱导的因子分解）。仅使用这些基本性质和马尔可夫毯的定义，推导出一个形式如下的联合分布的边界因子分解：\n$$\nP(x) = P(x_{B}) \\, P(x_{i} \\mid x_{B}) \\, P(x_{R} \\mid x_{B}),\n$$\n其中 $x$ 表示 $X_{V}$ 的一个实现，$x_{S}$ 表示其在索引集 $S \\subseteq V$ 上的限制。\n\nB 部分（仅基于马尔可夫毯的估计器）。现在假设 $X := (X_{v})_{v \\in V}$ 服从一个与 $G$ 一致的零均值高斯马尔可夫随机场，其密度为\n$$\nP(x) \\propto \\exp\\!\\left( -\\tfrac{1}{2} \\, x^{\\top} \\Lambda \\, x \\right),\n$$\n其中 $\\Lambda \\in \\mathbb{R}^{|V| \\times |V|}$ 是一个对称正定精度矩阵，其稀疏模式与 $G$ 匹配，即只要 $(i,j) \\notin E$ 且 $i \\neq j$，就有 $\\Lambda_{ij} = 0$。将变量划分为 $x = (x_{i}, x_{B}, x_{R})$，并相应地将 $\\Lambda$ 划分为块 $(\\Lambda_{ii}, \\Lambda_{iB}, \\Lambda_{iR}, \\Lambda_{BB}, \\Lambda_{BR}, \\Lambda_{RR})$。\n\n推导在给定马尔可夫毯变量的条件下 $X_i$ 的最小均方误差 (MMSE) 估计器 $\\widehat{x}_{i}(x_{B}) := \\mathbb{E}[X_{i} \\mid X_{B} = x_{B}]$，并将其表示为一个仅依赖于 $\\Lambda_{ii}$、$\\Lambda_{iB}$ 和 $x_{B}$ 的闭式解析表达式。\n\n您的最终答案必须是 $\\widehat{x}_{i}(x_{B})$ 的单个闭式表达式，不带单位。不需要进行数值舍入。",
            "solution": "该问题关注无向网络系统中的系统边界和环境。马尔可夫毯构成了将节点 $i$ 与环境的其余部分 $R$ 隔离开的边界，它通过在给定边界变量 $X_{B}$ 的条件下使 $X_{i}$ 与 $X_{R}$ 独立来实现这一点。我们分两部分进行。\n\nA 部分。边界诱导的因子分解源于基本规则。根据概率的链式法则，对于将 $V$ 划分为三个不相交子集 $\\{i\\}$、$B$ 和 $R$ 的任意划分，我们有\n$$\nP(x) = P(x_{B}) \\, P(x_{i}, x_{R} \\mid x_{B}) = P(x_{B}) \\, P(x_{i} \\mid x_{B}, x_{R}) \\, P(x_{R} \\mid x_{B}).\n$$\n根据马尔可夫毯的定义性质 $X_{i} \\perp X_{R} \\mid X_{B}$，这意味着\n$$\nP(x_{i} \\mid x_{B}, x_{R}) = P(x_{i} \\mid x_{B}).\n$$\n将此等式代入链式法则的因子分解中，得到\n$$\nP(x) = P(x_{B}) \\, P(x_{i} \\mid x_{B}) \\, P(x_{R} \\mid x_{B}),\n$$\n这就是所求的边界因子分解。这表明马尔可夫毯是一个系统边界：内部变量 $X_{i}$ 仅通过边界 $X_{B}$ 与环境 $X_{R}$ 进行概率性相互作用。\n\nB 部分。我们现在在高斯马尔可夫随机场设定下推导一个仅基于马尔可夫毯的估计器。随机向量 $X$ 是零均值高斯分布，其密度为\n$$\nP(x) \\propto \\exp\\!\\left( -\\tfrac{1}{2} \\, x^{\\top} \\Lambda \\, x \\right),\n$$\n其中 $\\Lambda$ 是一个对称正定精度矩阵，其稀疏性与无向图 $G$ 匹配。将 $x$ 划分为 $x = (x_{i}, x_{B}, x_{R})$，并用块坐标写出二次型：\n$$\nx^{\\top} \\Lambda x\n= \n\\begin{pmatrix}\nx_{i} & x_{B}^{\\top} & x_{R}^{\\top}\n\\end{pmatrix}\n\\begin{pmatrix}\n\\Lambda_{ii} & \\Lambda_{iB} & \\Lambda_{iR} \\\\\n\\Lambda_{Bi} & \\Lambda_{BB} & \\Lambda_{BR} \\\\\n\\Lambda_{Ri} & \\Lambda_{RB} & \\Lambda_{RR} \n\\end{pmatrix}\n\\begin{pmatrix}\nx_{i} \\\\ x_{B} \\\\ x_{R}\n\\end{pmatrix}.\n$$\n展开包含 $x_{i}$ 的项，\n$$\nx^{\\top} \\Lambda x\n=\n\\Lambda_{ii} x_{i}^{2} + 2 x_{i} \\left( \\Lambda_{iB} x_{B} + \\Lambda_{iR} x_{R} \\right) + \\text{与 } x_{i} \\text{ 无关的项}.\n$$\n条件密度 $P(x_{i} \\mid x_{B}, x_{R})$ 与这个关于 $x_i$ 的二次型的负二分之一的指数成正比，这是一个单变量高斯分布，其精度（方差的倒数）为 $\\Lambda_{ii}$，线性系数为 $\\Lambda_{iB} x_{B} + \\Lambda_{iR} x_{R}$。通过配方法，条件均值为\n$$\n\\mathbb{E}[X_{i} \\mid X_{B} = x_{B}, X_{R} = x_{R}]\n= - \\Lambda_{ii}^{-1} \\left( \\Lambda_{iB} x_{B} + \\Lambda_{iR} x_{R} \\right).\n$$\n根据 $\\Lambda$ 与 $G$ 一致的稀疏性质，对于 $r \\in R$，只要 $(i,r) \\notin E$，我们就有 $\\Lambda_{ir} = 0$。由于根据 $B$ 作为无向图中邻居集（马尔可夫毯）的构造，$R$ 只包含 $i$ 的非邻居节点，因此 $\\Lambda_{iR}$ 矩阵块为零。因此，\n$$\n\\mathbb{E}[X_{i} \\mid X_{B} = x_{B}, X_{R} = x_{R}]\n= - \\Lambda_{ii}^{-1} \\Lambda_{iB} x_{B}.\n$$\n此外，边界诱导的条件独立性 $X_{i} \\perp X_{R} \\mid X_{B}$ 意味着对于任意 $x_R$ 都有\n$$\n\\mathbb{E}[X_{i} \\mid X_{B} = x_{B}] = \\mathbb{E}[X_{i} \\mid X_{B} = x_{B}, X_{R} = x_{R}]\n$$\n，因此仅使用马尔可夫毯变量的最小均方误差 (MMSE) 估计器是相同的表达式：\n$$\n\\widehat{x}_{i}(x_{B}) := \\mathbb{E}[X_{i} \\mid X_{B} = x_{B}]\n= - \\Lambda_{ii}^{-1} \\Lambda_{iB} x_{B}.\n$$\n该估计器仅依赖于精度子块 $\\Lambda_{ii}$ 和 $\\Lambda_{iB}$ 以及观测到的马尔可夫毯值 $x_{B}$，从而使马尔可夫毯成为系统变量 $X_i$ 与其环境之间的预测边界。",
            "answer": "$$\\boxed{-\\Lambda_{ii}^{-1}\\,\\Lambda_{iB}\\,x_{B}}$$"
        },
        {
            "introduction": "系统边界的选择会极大地影响分析结论。这个练习  展示了一个经典的辛普森悖论 (Simpson's paradox) 案例，在忽略一个隐藏的环境因素时，观察到的关联性发生了反转。你将通过形式化地扩展系统边界以包含这个混淆变量，来解决这个悖论，并揭示真实的潜在因果效应。",
            "id": "4306410",
            "problem": "一名研究人员在一个由两个环境分层 $S \\in \\{A,B\\}$ 组成的总体中，研究一个二元处理 $T \\in \\{0,1\\}$ 和一个二元结果 $Y \\in \\{0,1\\}$。最初，系统边界排除了 $S$，只考虑了 $T$ 和 $Y$ 之间的聚合关联。随后，边界被扩展以明确包含 $S$ 及其因果关系。相关的结构关系由一个有向无环图 (DAG) 表示，其中包含箭头 $S \\rightarrow T$、$S \\rightarrow Y$ 和 $T \\rightarrow Y$，这与存在由 $S$ 引起的混淆相一致。\n\n以下观测数量通过经验得到了良好估计：\n- 层内条件结果率：\n  - $P(Y=1 \\mid T=1,S=A) = 0.95$, $P(Y=1 \\mid T=0,S=A) = 0.90$。\n  - $P(Y=1 \\mid T=1,S=B) = 0.35$, $P(Y=1 \\mid T=0,S=B) = 0.30$。\n- 目标总体中的分层分布：\n  - $P(S=A) = 0.5$, $P(S=B) = 0.5$。\n- 按分层观测到的处理选择：\n  - $P(S=A \\mid T=1) = 0.1$, $P(S=B \\mid T=1) = 0.9$。\n  - $P(S=A \\mid T=0) = 0.9$, $P(S=B \\mid T=0) = 0.1$。\n\n您可以假设存在一个结构因果模型 (SCM)，其中干预 $\\mathrm{do}(T=t)$ 将 $T$ 设定为 $t$ 并切断所有指向 $T$ 的因果箭头，同时保持 $S$ 的分布不变。反事实结果用 $Y_t$ 表示，因果效应根据干预分布 $P(Y \\mid \\mathrm{do}(T=t))$ 定义。全概率法则和DAG的图示含义适用。\n\n鉴于以上信息，聚合关联 $P(Y=1 \\mid T=1)$ 与 $P(Y=1 \\mid T=0)$ 相比表现出辛普森悖论，与层内比较相比出现了逆转。在包含 $S$ 的扩展系统边界下，请选择正确构建了反事实的选项，该选项展示了悖论是如何被解决的，并提供了从所提供数量计算得出的因果风险差 $P(Y=1 \\mid \\mathrm{do}(T=1)) - P(Y=1 \\mid \\mathrm{do}(T=0))$ 的正确形式化表达式和正确数值。\n\n选项：\n\n- A. $P(Y=1 \\mid T=1) - P(Y=1 \\mid T=0) = \\left(0.1 \\cdot 0.95 + 0.9 \\cdot 0.35\\right) - \\left(0.9 \\cdot 0.90 + 0.1 \\cdot 0.30\\right) = 0.41 - 0.84 = -0.43$。\n\n- B. $P(Y=1 \\mid \\mathrm{do}(T=1)) = \\sum_{s \\in \\{A,B\\}} P(Y=1 \\mid T=1,S=s)\\,P(S=s \\mid T=1)$ 和 $P(Y=1 \\mid \\mathrm{do}(T=0)) = \\sum_{s \\in \\{A,B\\}} P(Y=1 \\mid T=0,S=s)\\,P(S=s \\mid T=0)$，得出 $0.41 - 0.84 = -0.43$。\n\n- C. $P(Y=1 \\mid \\mathrm{do}(T=1)) = \\sum_{s \\in \\{A,B\\}} P(Y=1 \\mid T=1,S=s)\\,P(S=s) = 0.5 \\cdot 0.95 + 0.5 \\cdot 0.35 = 0.65$，且 $P(Y=1 \\mid \\mathrm{do}(T=0)) = \\sum_{s \\in \\{A,B\\}} P(Y=1 \\mid T=0,S=s)\\,P(S=s) = 0.5 \\cdot 0.90 + 0.5 \\cdot 0.30 = 0.60$，因此风险差为 $0.65 - 0.60 = 0.05$。\n\n- D. $P(Y=1 \\mid \\mathrm{do}(T=1)) - P(Y=1 \\mid \\mathrm{do}(T=0)) = \\left(0.95 - 0.90\\right) + \\left(0.35 - 0.30\\right) = 0.10$。",
            "solution": "这个问题的核心是区分关联与因果，并通过扩展系统边界来包含混淆变量，从而解决辛普森悖论。\n\n**1. 识别辛普森悖论**\n\n首先，我们检查数据是否确实表现出辛普森悖论。\n- **层内关联**：\n  - 在分层A中，处理的效应是 $P(Y=1|T=1,S=A) - P(Y=1|T=0,S=A) = 0.95 - 0.90 = +0.05$。\n  - 在分层B中，处理的效应是 $P(Y=1|T=1,S=B) - P(Y=1|T=0,S=B) = 0.35 - 0.30 = +0.05$。\n在两个分层中，处理都表现出轻微的正向关联。\n\n- **聚合关联**：\n现在，我们计算忽略分层$S$时的总体（聚合）关联。这需要使用全概率法则计算 $P(Y=1|T=1)$ 和 $P(Y=1|T=0)$：\n$P(Y=1|T=1) = \\sum_s P(Y=1|T=1,S=s)P(S=s|T=1) = (0.95)(0.1) + (0.35)(0.9) = 0.095 + 0.315 = 0.41$。\n$P(Y=1|T=0) = \\sum_s P(Y=1|T=0,S=s)P(S=s|T=0) = (0.90)(0.9) + (0.30)(0.1) = 0.81 + 0.03 = 0.84$。\n聚合风险差是 $0.41 - 0.84 = -0.43$。\n\n聚合结果显示处理有强烈的负向关联，而层内结果显示有正向关联。这就是辛普森悖论。\n\n**2. 解决悖论：计算因果效应**\n\n悖论的产生是因为变量$S$是一个**混淆因子**。从给定的因果图 $S \\to T$ 和 $S \\to Y$ 可以看出，$S$ 同时影响处理的选择和结果。具体来说，结果率较高的分层A中的个体倾向于不接受处理（$P(S=A|T=0)=0.9$），而结果率较低的分层B中的个体倾向于接受处理（$P(S=B|T=1)=0.9$）。因此，简单的关联比较是不公平的。\n\n为了得到处理$T$对结果$Y$的真实**因果效应**，我们必须消除混淆因子$S$的影响。这通过计算干预分布 $P(Y|\\mathrm{do}(T=t))$ 来实现。根据因果图，$S$满足后门准则，因此我们可以使用**后门调整公式**：\n$$ P(Y=1 \\mid \\mathrm{do}(T=t)) = \\sum_{s} P(Y=1 \\mid T=t, S=s)P(S=s) $$\n这个公式模拟了一个理想实验：如果我们对整个总体（其分层分布为$P(S=s)$）强制施加处理$T=t$，结果会如何。\n\n- **计算 $P(Y=1 \\mid \\mathrm{do}(T=1))$**:\n  $P(Y=1 \\mid \\mathrm{do}(T=1)) = P(Y=1|T=1,S=A)P(S=A) + P(Y=1|T=1,S=B)P(S=B)$\n  $= (0.95)(0.5) + (0.35)(0.5) = 0.475 + 0.175 = 0.65$。\n\n- **计算 $P(Y=1 \\mid \\mathrm{do}(T=0))$**:\n  $P(Y=1 \\mid \\mathrm{do}(T=0)) = P(Y=1|T=0,S=A)P(S=A) + P(Y=1|T=0,S=B)P(S=B)$\n  $= (0.90)(0.5) + (0.30)(0.5) = 0.45 + 0.15 = 0.60$。\n\n- **计算因果风险差**:\n  $P(Y=1 \\mid \\mathrm{do}(T=1)) - P(Y=1 \\mid \\mathrm{do}(T=0)) = 0.65 - 0.60 = 0.05$。\n\n真实的因果效应是$+0.05$，与层内关联的方向一致。悖论得到解决。\n\n**3. 评估选项**\n\n- **A** 错误地计算了观测关联，而非因果效应。\n- **B** 错误地将因果量 $P(Y|\\mathrm{do}(T=t))$ 等同于观测量 $P(Y|T=t)$，使用了错误的加权项 $P(S=s|T=t)$。\n- **C** 正确地使用了后门调整公式，以 $P(S=s)$ 进行加权，计算出了正确的因果效应和风险差。\n- **D** 使用了一个没有理论依据的错误公式，将风险差直接相加。\n\n因此，选项C是唯一正确的答案。",
            "answer": "$$\\boxed{C}$$"
        },
        {
            "introduction": "在许多实际场景中，我们需要为复杂系统建立既准确又计算上易于处理的简化模型。这项动手编程练习  要求你实现一个算法，寻找能够满足给定误差容限 $\\epsilon$ 下，保持关键系统可观测量不变的最小系统边界。这个过程演示了一种原则性的模型降维方法。",
            "id": "4306421",
            "problem": "给定一个有限、加权、无向图，其节点集为 $\\{1,2,\\dots,n\\}$，非负对称权重为 $W_{ij}=W_{ji}\\ge 0$。考虑在 $\\mathbb{R}^n$ 上的线性时不变动力学，其由常微分方程 (ODE) $d\\mathbf{x}/dt = A \\mathbf{x}$ 定义，其中 $A = W - D$，$D$ 是一个对角矩阵，其元素为 $D_{ii} = \\sum_{j=1}^n W_{ij} + \\delta_i$。量 $\\delta_i>0$ 是每个节点的衰减率。设初始条件为 $\\mathbf{x}(0) = \\mathbf{e}_{i^\\star}$，这是以选定的目标节点 $i^\\star \\in \\{1,\\dots,n\\}$ 为中心的标准基向量。定义在时间 $T>0$ 时的目标可观测量为 $Y(T) = \\mathbf{e}_{i^\\star}^\\top e^{A T} \\mathbf{e}_{i^\\star}$，其中 $e^{A T}$ 表示矩阵指数。\n\n对于一个非负整数半径 $r$，定义边界集 $B(r)$ 为与 $i^\\star$ 的无权最短路径距离至多为 $r$ 的节点集合。令 $E(r)$ 表示环境，即 $B(r)$ 在 $\\{1,\\dots,n\\}$ 中的补集。将 $A$ 相应地分块为\n$$\nA = \\begin{pmatrix}\nA_{BB} & A_{BE} \\\\\nA_{EB} & A_{EE}\n\\end{pmatrix}\n$$\n其中这些块对应于边界 $B(r)$ 和环境 $E(r)$。在标准的绝热消除（快环境）近似下，环境根据 $\\mathbf{x}_E \\approx -A_{EE}^{-1} A_{EB} \\mathbf{x}_B$ 受控于边界，这在边界上导出有效生成元\n$$\nA_{\\text{eff}}(r) = A_{BB} - A_{BE} A_{EE}^{-1} A_{EB}.\n$$\n将可观测量的近似定义为\n$$\n\\widehat{Y}(T;r) = \\mathbf{e}_{i^\\star,B}^\\top e^{A_{\\text{eff}}(r) T} \\mathbf{e}_{i^\\star,B},\n$$\n其中 $\\mathbf{e}_{i^\\star,B}$ 表示标准基向量在由 $B(r)$ 索引的坐标上的限制。对于给定的误差容限 $\\epsilon>0$，如果 $|Y(T) - \\widehat{Y}(T;r)| \\le \\epsilon$，则边界 $B(r)$ 是充分的；如果在所有充分边界中其基数 $|B(r)|$ 最小，则它是最小的。\n\n您的任务是编写一个完整的程序，对下面的每个测试用例，计算最小充分边界基数 $|B(r^\\star)|$，其中\n$$\nr^\\star = \\min\\{r \\in \\{0,1,2,\\dots\\}: |Y(T) - \\widehat{Y}(T;r)| \\le \\epsilon\\}.\n$$\n如果在 $\\{0,1,2,\\dots,n-1\\}$ 中没有半径 $r$ 满足该不等式，则定义 $r^\\star = n-1$。\n\n下面所有图在计算最短路径时均视为无权图（无论 $W$ 如何），并对节点标签使用基于1的索引。在所有情况下，用于分配衰减率和定义边界层的距离都是通过从 $i^\\star$ 开始的无权最短路径计算的。程序应实现以下测试套件：\n\n- 测试用例1（单链，三尺度衰减）：\n    - 图：长度为 $n=12$ 的链，连续节点之间有边，对称权重为 $W_{i,i+1} = W_{i+1,i} = g$（$i=1,\\dots,11$），其他 $W_{ij}=0$。\n    - 参数：$g=0.25$，目标节点 $i^\\star=6$，最终时间 $T=1.0$，容限 $\\epsilon=10^{-4}$。\n    - 衰减率：令 $d(i)$ 为从 $i^\\star$ 到 $i$ 的无权最短路径距离。设置\n      $\\delta_i = \\delta_{\\text{slow}}$ 如果 $d(i) \\le 1$，\n      $\\delta_i = \\delta_{\\text{medium}}$ 如果 $2 \\le d(i) \\le 3$，\n      以及 $\\delta_i = \\delta_{\\text{fast}}$ 如果 $d(i) \\ge 4$，\n      其中 $\\delta_{\\text{slow}}=0.05$，$\\delta_{\\text{medium}}=0.20$，$\\delta_{\\text{fast}}=1.50$。\n\n- 测试用例2（更长的链，更严格的容限）：\n    - 图：长度为 $n=20$ 的链，连续节点之间有边，对称权重为 $W_{i,i+1} = W_{i+1,i} = g$（$i=1,\\dots,19$），其他 $W_{ij}=0$。\n    - 参数：$g=0.40$，目标节点 $i^\\star=10$，最终时间 $T=3.0$，容限 $\\epsilon=10^{-8}$。\n    - 衰减率：令 $d(i)$ 为从 $i^\\star$ 到 $i$ 的无权最短路径距离。设置\n      $\\delta_i = \\delta_{\\text{slow}}$ 如果 $d(i) \\le 1$，\n      $\\delta_i = \\delta_{\\text{medium}}$ 如果 $2 \\le d(i) \\le 4$，\n      以及 $\\delta_i = \\delta_{\\text{fast}}$ 如果 $d(i) \\ge 5$，\n      其中 $\\delta_{\\text{slow}}=0.02$，$\\delta_{\\text{medium}}=0.10$，$\\delta_{\\text{fast}}=2.00$。\n\n- 测试用例3（两个弱连接的链）：\n    - 图：两个由单个弱连接相连的不相交链。链A长度为8，位于节点 $1,\\dots,8$ 上，其中 $W_{i,i+1} = W_{i+1,i} = g_A$（$i=1,\\dots,7$）。链B长度为5，位于节点 $9,\\dots,13$ 上，其中 $W_{j,j+1} = W_{j+1,j} = g_B$（$j=9,\\dots,12$）。一条权重为 $\\gamma$ 的跨边连接节点8和节点9。所有其他 $W_{ij}=0$。\n    - 参数：$g_A=0.30$，$g_B=0.30$，$\\gamma=0.001$，目标节点 $i^\\star=4$，最终时间 $T=1.0$，容限 $\\epsilon=10^{-3}$。\n    - 衰减率：令 $d(i)$ 为在全图（包括弱连接）中从 $i^\\star$ 到 $i$ 的无权最短路径距离。设置\n      $\\delta_i = \\delta_{\\text{slow}}$ 如果 $d(i) \\le 1$，\n      $\\delta_i = \\delta_{\\text{medium}}$ 如果 $2 \\le d(i) \\le 4$，\n      以及 $\\delta_i = \\delta_{\\text{fast}}$ 如果 $d(i) \\ge 5$，\n      其中 $\\delta_{\\text{slow}}=0.05$，$\\delta_{\\text{medium}}=0.20$，$\\delta_{\\text{fast}}=1.20$。\n\n实现要求：\n- 通过矩阵指数 $e^{A T}$ 精确计算 $Y(T)$。\n- 对每个半径 $r=0,1,\\dots,n-1$，通过 $A_{\\text{eff}}(r) = A_{BB} - A_{BE} A_{EE}^{-1} A_{EB}$ 计算 $A_{\\text{eff}}(r)$。如果 $A_{EE}$ 是奇异的或病态的，使用 Moore–Penrose 伪逆代替 $A_{EE}^{-1}$。\n- 计算 $\\widehat{Y}(T;r)$ 和误差 $|Y(T) - \\widehat{Y}(T;r)|$；选择使误差至多为 $\\epsilon$ 的最小 $r$。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如 $[r_1,r_2,r_3]$），列表中的每个条目是相应测试用例的最小充分边界基数 $|B(r^\\star)|$。\n\n所有量都是无量纲的；不出现角度；没有百分比。最终输出应为一个整数列表。",
            "solution": "该问题要求我们确定图上线性动力学系统的最小充分边界大小。这是一个模型降阶问题，我们用一个定义在子区域（“边界”）上的更小的有效模型来近似一个大系统。该近似的充分性通过特定可观测量的误差来衡量，我们寻求满足给定误差容限的最小边界。\n\n对于每个测试用例，总体方法包括以下步骤：\n1.  **系统定义**：构建代表系统的数学对象：权重矩阵 $W$，每个节点的衰减率 $\\delta_i$，以及完整的系统动力学矩阵 $A = W - D$，其中 $D_{ii} = (\\sum_j W_{ij}) + \\delta_i$。\n2.  **最短路径计算**：确定从目标节点 $i^\\star$ 到图中每个其他节点 $i$ 的无权最短路径距离 $d(i)$。这通过使用广度优先搜索（BFS）算法来完成，该算法对于无权图是最优的。这些距离用于定义衰减率 $\\delta_i$ 和同心边界集 $B(r)$。\n3.  **精确可观测量计算**：计算目标可观测量 $Y(T) = \\mathbf{e}_{i^\\star}^\\top e^{A T} \\mathbf{e}_{i^\\star}$ 的“精确”值。这需要计算完整系统矩阵 $A$ 乘以时间 $T$ 后的矩阵指数 $e^{A T}$。结果 $Y(T)$ 是该矩阵指数中对应于目标节点 $i^\\star$ 的对角元素。\n4.  **迭代搜索最小半径**：遍历可能的边界半径 $r = 0, 1, 2, \\dots, n-1$。对于每个半径 $r$：\n    a.  **系统划分**：将所有节点的集合 $\\{1, \\dots, n\\}$ 划分为边界集 $B(r) = \\{i \\mid d(i) \\le r\\}$ 和环境集 $E(r) = \\{i \\mid d(i) > r\\}$。系统矩阵 $A$ 相应地被划分为块 $A_{BB}$、$A_{BE}$、$A_{EB}$ 和 $A_{EE}$。\n    b.  **有效模型构建**：使用绝热消除公式计算边界动力学的有效生成元 $A_{\\text{eff}}(r)$：$A_{\\text{eff}}(r) = A_{BB} - A_{BE} A_{EE}^{-1} A_{EB}$。为确保数值稳定性并处理环境块 $A_{EE}$ 可能奇异的情况，使用其 Moore-Penrose 伪逆代替标准逆 $A_{EE}^{-1}$。如果环境集 $E(r)$ 为空，则有效模型就是限制在边界上的完整系统，即 $A_{\\text{eff}}(r) = A_{BB} = A$，且近似变得精确。\n    c.  **近似可观测量计算**：计算近似可观测量 $\\widehat{Y}(T;r) = \\mathbf{e}_{i^\\star,B}^\\top e^{A_{\\text{eff}}(r) T} \\mathbf{e}_{i^\\star,B}$。这涉及对较小的有效矩阵 $A_{\\text{eff}}(r)$ 进行矩阵求幂，并提取边界局部索引中对应于目标节点 $i^\\star$ 的对角元素。\n    d.  **误差评估**：计算绝对误差 $|Y(T) - \\widehat{Y}(T;r)|$ 并与指定的容限 $\\epsilon$ 进行比较。\n5.  **结果确定**：第一个使误差小于或等于 $\\epsilon$ 的半径 $r^\\star$ 是最小充分半径。因为边界集大小 $|B(r)|$ 是半径 $r$ 的单调非减函数，所以最小化 $r$ 等价于最小化边界基数。该测试用例的最终结果是这个最小充分边界的基数 $|B(r^\\star)|$。\n\n该过程被系统地应用于指定的三个测试用例中的每一个。所有涉及矩阵和向量的计算都使用 `numpy` 库执行。矩阵指数通过 `scipy.linalg.expm` 计算，伪逆通过 `numpy.linalg.pinv` 计算。问题中给出的基于1的节点索引，在内部计算中被转换为基于0的索引。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import expm\nfrom collections import deque\n\ndef _get_shortest_paths_bfs(n, adj_list, start_node_0):\n    \"\"\"Computes unweighted shortest-path distances from a start node using BFS.\"\"\"\n    distances = np.full(n, -1, dtype=int)\n    queue = deque([(start_node_0, 0)])\n    distances[start_node_0] = 0\n\n    while queue:\n        u, d = queue.popleft()\n        for v in adj_list[u]:\n            if distances[v] == -1:\n                distances[v] = d + 1\n                queue.append((v, d + 1))\n    \n    return distances\n\ndef _process_case(n, i_star, T, epsilon, adj_list, W, delta_rules):\n    \"\"\"\n    Solves for the minimal sufficient boundary cardinality for a single test case.\n    \"\"\"\n    # 1. Use 0-based indexing for all internal calculations\n    i_star_0 = i_star - 1\n\n    # 2. Get shortest path distances from the target node\n    distances = _get_shortest_paths_bfs(n, adj_list, i_star_0)\n\n    # 3. Construct the delta vector based on distance rules\n    deltas = np.zeros(n)\n    max_dist = np.max(distances)\n    for min_d, max_d, val in delta_rules:\n        effective_max_d = max_dist if max_d >= n else max_d\n        indices = np.where((distances >= min_d)  (distances = effective_max_d))[0]\n        deltas[indices] = val\n\n    # 4. Construct the full system matrix A\n    D = np.diag(np.sum(W, axis=1) + deltas)\n    A = W - D\n\n    # 5. Compute the exact observable Y(T)\n    expm_AT = expm(A * T)\n    Y_T = expm_AT[i_star_0, i_star_0]\n\n    # 6. Iterate through radii r = 0, 1, ..., n-1 to find the minimal sufficient radius\n    for r in range(n):\n        # 7. Define boundary B(r) and environment E(r) index sets\n        B_indices = np.where(distances = r)[0]\n        E_indices = np.where(distances > r)[0]\n        \n        # Sort for consistent matrix slicing\n        B_indices.sort()\n        E_indices.sort()\n\n        Y_hat_T_r = 0.0 # Initialize approximated observable\n        \n        if E_indices.size == 0:\n            # If the environment is empty, the approximation is exact.\n            Y_hat_T_r = Y_T\n        else:\n            # 8. Partition matrix A and compute the effective generator A_eff\n            A_BB = A[np.ix_(B_indices, B_indices)]\n            A_BE = A[np.ix_(B_indices, E_indices)]\n            A_EB = A[np.ix_(E_indices, B_indices)]\n            A_EE = A[np.ix_(E_indices, E_indices)]\n\n            A_eff = A_BB - A_BE @ np.linalg.pinv(A_EE) @ A_EB\n            \n            # Find the index of the target node within the boundary set\n            i_star_B_idx = np.where(B_indices == i_star_0)[0][0]\n            \n            # 9. Compute the approximate observable Y_hat(T;r)\n            expm_A_eff_T = expm(A_eff * T)\n            Y_hat_T_r = expm_A_eff_T[i_star_B_idx, i_star_B_idx]\n\n        # 10. Check the error condition\n        error = abs(Y_T - Y_hat_T_r)\n        if error = epsilon:\n            # Found the minimal sufficient radius r*; return its cardinality\n            return len(B_indices)\n\n    # This part should not be reached because for r large enough, E is empty,\n    # error is 0, and the condition is met.\n    return n\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = []\n\n    # Test Case 1\n    n1 = 12\n    W1 = np.zeros((n1, n1))\n    adj1 = [[] for _ in range(n1)]\n    for i in range(n1 - 1):\n        W1[i, i + 1] = W1[i + 1, i] = 0.25\n        adj1[i].append(i + 1)\n        adj1[i+1].append(i)\n    case1_params = {\n        \"n\": n1, \"i_star\": 6, \"T\": 1.0, \"epsilon\": 1e-4,\n        \"adj_list\": adj1, \"W\": W1,\n        \"delta_rules\": [(0, 1, 0.05), (2, 3, 0.20), (4, n1, 1.50)]\n    }\n    test_cases.append(case1_params)\n\n    # Test Case 2\n    n2 = 20\n    W2 = np.zeros((n2, n2))\n    adj2 = [[] for _ in range(n2)]\n    for i in range(n2 - 1):\n        W2[i, i + 1] = W2[i + 1, i] = 0.40\n        adj2[i].append(i + 1)\n        adj2[i+1].append(i)\n    case2_params = {\n        \"n\": n2, \"i_star\": 10, \"T\": 3.0, \"epsilon\": 1e-8,\n        \"adj_list\": adj2, \"W\": W2,\n        \"delta_rules\": [(0, 1, 0.02), (2, 4, 0.10), (5, n2, 2.00)]\n    }\n    test_cases.append(case2_params)\n\n    # Test Case 3\n    n3 = 13\n    gA, gB, gamma = 0.30, 0.30, 0.001\n    W3 = np.zeros((n3, n3))\n    adj3 = [[] for _ in range(n3)]\n    # Chain A: nodes 1..8 (indices 0..7)\n    for i in range(7):\n        W3[i, i + 1] = W3[i + 1, i] = gA\n        adj3[i].append(i + 1)\n        adj3[i+1].append(i)\n    # Chain B: nodes 9..13 (indices 8..12)\n    for i in range(8, 12):\n        W3[i, i + 1] = W3[i + 1, i] = gB\n        adj3[i].append(i + 1)\n        adj3[i+1].append(i)\n    # Link: node 8 to 9 (indices 7 to 8)\n    W3[7, 8] = W3[8, 7] = gamma\n    adj3[7].append(8)\n    adj3[8].append(7)\n    case3_params = {\n        \"n\": n3, \"i_star\": 4, \"T\": 1.0, \"epsilon\": 1e-3,\n        \"adj_list\": adj3, \"W\": W3,\n        \"delta_rules\": [(0, 1, 0.05), (2, 4, 0.20), (5, n3, 1.20)]\n    }\n    test_cases.append(case3_params)\n\n    results = []\n    for case_params in test_cases:\n        result = _process_case(**case_params)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}