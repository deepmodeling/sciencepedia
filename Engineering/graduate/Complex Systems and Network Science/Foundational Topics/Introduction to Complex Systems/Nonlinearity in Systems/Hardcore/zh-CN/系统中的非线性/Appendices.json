{
    "hands_on_practices": [
        {
            "introduction": "许多复杂系统，从气候模型到神经网络，都表现出多重稳定状态。本练习  将通过一个简单的双稳态势能函数来探索这一现象。通过分析系统平衡点及其稳定性如何随外部作用力而变化，你将推导出系统发生“灾变式”突跳的条件，并揭示迟滞现象背后的机制——一个系统状态依赖于其历史路径的关键概念。",
            "id": "4293615",
            "problem": "考虑一个单自由度的过阻尼梯度系统，其状态变量为 $x \\in \\mathbb{R}$，演化足够缓慢，以至于系统保持在有效势的局部极小值点上（或绝热地跟踪这些极小值点）。其固有势为 $V(x)=\\frac{1}{4}x^{4}-\\frac{1}{2}a x^{2}$，其中 $a>0$。一个准静态的外部广义力 $F \\in \\mathbb{R}$ 与 $x$ 线性耦合，因此有效势为 $U(x;F)=V(x)-F x$。在准静态极限下，平衡点被定义为 $U$ 的驻点，局部稳定性则由 $U$ 的正曲率定义。\n\n仅使用这些原理，完成以下任务：\n\n(a) 通过对 $U(x;F)$ 关于 $x$ 取驻点，推导 $x$ 作为 $F$ 的函数的平衡条件。不要显式求解所得的多项式；而是表达出 $x$ 必须满足的隐式关系。\n\n(b) 通过考察 $U(x;F)$ 的曲率，确定平衡点关于 $x$ 和 $a$ 的局部稳定性判据。\n\n(c) 确定在 $F$ 变化时，一个稳定平衡点和一个不稳定平衡点合并并相互湮灭的条件（鞍结事件）。利用此条件，解析地推导出发生这种消失现象的临界力 $F_{c}$ 的大小，以 $a$ 的封闭形式表示。\n\n(d) 结合上述推导，用文字解释当 $F$ 从一个大的负值缓慢循环扫描到一个大的正值再返回时，追踪 $x$ 与 $F$ 的关系如何产生一个磁滞回线。你的解释应将多重平衡点的存在、它们的稳定性以及鞍结事件联系起来。\n\n作为最终答案，提供你得到的临界力大小 $F_{c}$ 的精确解析表达式。不需要数值近似，也不需要单位。",
            "solution": "系统的有效势由 $U(x;F) = V(x) - Fx$ 给出，其中固有势为 $V(x) = \\frac{1}{4}x^{4} - \\frac{1}{2}ax^{2}$，参数 $a > 0$。因此，有效势为：\n$$\nU(x;F) = \\frac{1}{4}x^{4} - \\frac{1}{2}ax^{2} - Fx\n$$\n\n(a) 平衡条件是通过找出有效势 $U(x;F)$ 相对于状态变量 $x$ 的驻点来确定的。这通过将 $U$ 对 $x$ 的一阶导数设为零来实现。\n$$\n\\frac{\\partial U}{\\partial x} = \\frac{\\partial}{\\partial x} \\left( \\frac{1}{4}x^{4} - \\frac{1}{2}ax^{2} - Fx \\right) = x^{3} - ax - F\n$$\n将此导数设为零，$\\frac{\\partial U}{\\partial x} = 0$，得到定义给定力 $F$ 下 $x$ 的平衡值的隐式关系：\n$$\nx^{3} - ax - F = 0\n$$\n这个方程可以表示为 $F = x^{3} - ax$，它定义了 $(x, F)$ 平面中的平衡流形。\n\n(b) 平衡点的局部稳定性由该点势的曲率决定。稳定的平衡点对应于势的局部极小值，这要求 $U(x;F)$ 对 $x$ 的二阶导数为正。我们计算这个二阶导数：\n$$\n\\frac{\\partial^{2} U}{\\partial x^{2}} = \\frac{\\partial}{\\partial x} (x^{3} - ax - F) = 3x^{2} - a\n$$\n为使平衡点局部稳定，必须有 $\\frac{\\partial^{2} U}{\\partial x^{2}} > 0$。这给出了稳定性判据：\n$$\n3x^{2} - a > 0\n$$\n这个不等式可以对 $x$ 求解以确定稳定区域：\n$$\nx^{2} > \\frac{a}{3} \\quad \\text{或等价地} \\quad |x| > \\sqrt{\\frac{a}{3}}\n$$\n如果平衡点位于满足 $|x| > \\sqrt{a/3}$ 的位置，则它们是稳定的。相反，如果 $|x|  \\sqrt{a/3}$，曲率为负，则平衡点是不稳定的。\n\n(c) 当一个稳定平衡点和一个不稳定平衡点合并并相互湮灭时，发生鞍结事件。这发生在稳定性的边缘，恰好是势的曲率为零的地方。这对应于条件：\n$$\n\\frac{\\partial^{2} U}{\\partial x^{2}} = 3x^{2} - a = 0\n$$\n求解发生此情况的临界位置 $x_{c}$，我们发现：\n$$\nx_{c}^{2} = \\frac{a}{3} \\implies x_{c} = \\pm \\sqrt{\\frac{a}{3}}\n$$\n这些临界位置是鞍结分岔的位置。为了找到相应的临界力值，我们将这些 $x_{c}$ 值代回到(a)部分的平衡条件 $F = x^{3} - ax$ 中。\n对于临界点 $x_{c} = -\\sqrt{\\frac{a}{3}}$：\n$$\nF = \\left(-\\sqrt{\\frac{a}{3}}\\right)^{3} - a\\left(-\\sqrt{\\frac{a}{3}}\\right) = -\\left(\\frac{a}{3}\\right)\\sqrt{\\frac{a}{3}} + a\\sqrt{\\frac{a}{3}} = \\sqrt{\\frac{a}{3}}\\left(a - \\frac{a}{3}\\right) = \\sqrt{\\frac{a}{3}}\\left(\\frac{2a}{3}\\right) = \\frac{2a\\sqrt{a}}{3\\sqrt{3}}\n$$\n对于临界点 $x_{c} = +\\sqrt{\\frac{a}{3}}$：\n$$\nF = \\left(\\sqrt{\\frac{a}{3}}\\right)^{3} - a\\left(\\sqrt{\\frac{a}{3}}\\right) = \\left(\\frac{a}{3}\\right)\\sqrt{\\frac{a}{3}} - a\\sqrt{\\frac{a}{3}} = \\sqrt{\\frac{a}{3}}\\left(\\frac{a}{3} - a\\right) = \\sqrt{\\frac{a}{3}}\\left(-\\frac{2a}{3}\\right) = -\\frac{2a\\sqrt{a}}{3\\sqrt{3}}\n$$\n问题要求临界力的大小，记为 $F_{c}$。这是上面计算出的力的绝对值：\n$$\nF_{c} = \\left|\\pm\\frac{2a\\sqrt{a}}{3\\sqrt{3}}\\right| = \\frac{2a\\sqrt{a}}{3\\sqrt{3}}\n$$\n\n(d) 在特定 $F$ 范围内存在多重平衡点以及它们在临界点处的湮灭导致了磁滞现象。在力 $|F|  F_{c}$ 的范围内，对于 $x$ 有三个平衡解：两个是稳定的（外部分支，其中 $|x| > \\sqrt{a/3}$），一个是不稳定的（中间分支，其中 $|x|  \\sqrt{a/3}$）。根据假设，系统会跟踪一个稳定的平衡点（$U$ 的一个局部极小值）。\n\n让我们追踪 $F$ 的缓慢循环扫描过程：\n1.  从一个大的负力开始，$F \\ll -F_{c}$。此时 $U(x;F)$ 只有一个极小值，位于一个大的负 $x$ 处。系统状态处于这个下方的稳定分支上。\n2.  缓慢增加 $F$。系统状态 $x$ 随之增加，沿着这个下方的稳定分支。即使当 $F$ 进入双稳区 $(-F_{c}, F_{c})$，系统仍然停留在这个分支上。\n3.  当 $F$ 达到临界值 $+F_{c}$ 时，下方的稳定平衡点（在 $x_{c} = -\\sqrt{a/3}$ 处）与中间的不稳定平衡点合并，两者都消失了。\n4.  由于其局部极小值消失，系统必须经历一次灾难性的跳跃，到达唯一剩下的稳定平衡点，该平衡点位于上方分支，对应一个正的 $x$ 值。\n5.  现在，将 $F$ 从一个大的正值扫回。系统从上方的稳定分支（大的正 $x$）开始。\n6.  当 $F$ 减小时，系统跟踪这个上方的分支， $x$ 随之减小。\n7.  当 $F$ 下降到另一个临界值 $-F_{c}$ 时，上方的稳定平衡点（在 $x_{c} = +\\sqrt{a/3}$ 处）与不稳定平衡点合并并消失。\n8.  然后系统必须跳跃到唯一可用的稳定状态，即下方分支上一个负的 $x$ 值处。\n\n当 $F$ 增加时 $x$ 的路径与 $F$ 减小时的路径不同。这种状态对控制参数 $F$ 历史的依赖性就是磁滞。$x$ 对 $F$ 的图像形成一个回线，向上和向下的跳跃发生在两个不同的力值，$+F_{c}$ 和 $-F_{c}$，它们是鞍结分岔点。",
            "answer": "$$\\boxed{\\frac{2a\\sqrt{a}}{3\\sqrt{3}}}$$"
        },
        {
            "introduction": "虽然一些非线性系统会稳定在特定状态，但另一些则表现出混沌动态，其特征是对初始条件的极端敏感性。本练习  将介绍逻辑斯谛映射，这是一个经典的、能够展示从周期性到混沌等丰富行为的模型系统。你将首先推导最大李雅普诺夫指数的表达式——这是量化混沌的“金标准”，然后通过编程实现其数值估算，从而掌握一种区分可预测行为与混沌行为的直接实践方法。",
            "id": "4293679",
            "problem": "考虑在区间 $[0,1]$ 上由 $x_{n+1} = T(x_n)$ 定义的一维迭代映射，其中 $T$ 是连续可微的。最大李雅普诺夫指数 (LLE) 量化了邻近轨道分离的平均指数率，其基本定义为长时间极限\n$$\\lambda = \\lim_{n \\to \\infty} \\frac{1}{n} \\ln \\frac{|\\delta x_n|}{|\\delta x_0|},$$\n其中 $\\delta x_n$ 是两条轨道在 $n$ 次迭代后的无穷小分离，该分离在由 $T$ 诱导的线性化下演化。\n\n您的任务是：\n\n1) 从上述基本定义和可微函数复合的链式法则出发，推导出一维可微映射的最大李雅普诺夫指数的表达式，该表达式应为沿典型轨道对 $T$ 的导数绝对值的对数进行的长时间平均。清晰地陈述您为证明该推导而使用的所有假设。\n\n2) 将您的结果具体应用于参数为 $r \\in (0,4]$ 的逻辑斯蒂映射 $T(x) = r x (1 - x)$。提供该映射的最大李雅普诺夫指数的有限时间估计量中每次迭代贡献的显式表达式，该表达式应为 $r$ 和当前状态 $x_n$ 的函数。\n\n3) 实现一个程序，使用有限时间估计量\n$$\\hat{\\lambda}_{N,M}(x_0) = \\frac{1}{N} \\sum_{n=1}^{N} \\log \\left| T'(x_{M+n-1}) \\right|,$$\n来数值估算最大李雅普诺夫指数，其中 $M$ 是预烧（暂态）长度，$N$ 是用于平均的迭代次数，$x_0$ 是初始条件，$\\log$ 表示自然对数。您的实现必须对逻辑斯蒂映射中可能发生的非线性诱导的奇异事件具有鲁棒性，例如遇到 $|T'(x)| = 0$ 的点或舍入到区间端点的情况：\n- 在迭代索引为 $n$ 时计算任何对数之前，如果 $|1 - 2 x_{M+n-1}|  \\varepsilon_{\\text{crit}}$ 或 $x_{M+n-1} \\notin [0,1]$ 或 $x_{M+n-1}$ 距离任一端点的距离在 $\\varepsilon_{\\text{end}}$ 之内，则将 $x_{M+n-1}$ 替换为 $x_{M+n-1} + \\operatorname{sign}(0.5 - x_{M+n-1}) \\, \\varepsilon_{\\text{jit}}$，然后将其限制在闭区间 $[\\varepsilon_{\\text{end}}, 1 - \\varepsilon_{\\text{end}}]$ 内。\n- 使用 $\\varepsilon_{\\text{crit}} = 10^{-14}$，$\\varepsilon_{\\text{jit}} = 10^{-12}$，以及 $\\varepsilon_{\\text{end}} = 10^{-15}$。\n- 在每次映射迭代 $x \\mapsto T(x)$ 后，将结果限制在 $[\\varepsilon_{\\text{end}}, 1 - \\varepsilon_{\\text{end}}]$ 内，以避免伪舍入到端点。\n\n4) 使用您的程序为以下测试套件评估估计量。对于每种情况，报告一个浮点数值，该值等于四舍五入到 $6$ 位小数的 $\\hat{\\lambda}_{N,M}(x_0)$：\n- 情况 A（完全发展的混沌，典型初始条件）：$r = 4.0$, $x_0 = 0.123456789$, $M = 1000$, $N = 200000$。\n- 情况 B（需要正则化的临界点初始条件）：$r = 4.0$, $x_0 = 0.5$, $M = 1000$, $N = 200000$。\n- 情况 C（周期窗口）：$r = 3.2$, $x_0 = 0.1$, $M = 1000$, $N = 200000$。\n- 情况 D（接近费根鲍姆点的混沌初现）：$r = 3.569945672$, $x_0 = 0.1$, $M = 2000$, $N = 200000$。\n- 情况 E（混沌带状吸引子）：$r = 3.75$, $x_0 = 0.1$, $M = 1000$, $N = 200000$。\n\n将估算出的最大李雅普诺夫指数的正值解释为对初始条件敏感依赖性（混沌）的指标，负值解释为渐近周期性的指标。您无需输出此解释；它用于指导您的理解。\n\n最终输出格式要求：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，每个值四舍五入到 $6$ 位小数，顺序为 [情况 A, 情况 B, 情况 C, 情况 D, 情况 E]。例如，一个有效的输出行格式为“[0.693147,0.693147,-0.000001,0.000000,0.500000]”。不要打印任何其他文本。",
            "solution": "用户的要求是推导一维映射的最大李雅普诺夫指数 (LLE) 的表达式，将其具体化到逻辑斯蒂映射，并实现一个数值估计器来计算几个测试案例的 LLE。\n\n### 任务 1：李雅普诺夫指数表达式的推导\n\n最大李雅普诺夫指数 $\\lambda$ 量化了无穷小邻近轨道分离的平均指数率。对于一维映射 $x_{n+1} = T(x_n)$，其基本定义为：\n$$\n\\lambda = \\lim_{n \\to \\infty} \\frac{1}{n} \\ln \\frac{|\\delta x_n|}{|\\delta x_0|}\n$$\n这里，$\\delta x_0$ 是两个起始点 $x_0$ 和 $x_0' = x_0 + \\delta x_0$ 之间的初始无穷小分离。经过 $n$ 次迭代后的分离是 $\\delta x_n = x_n' - x_n$，其中 $x_n = T^n(x_0)$ 且 $x_n' = T^n(x_0')$。\n\n我们逐步进行推导。\n设两条轨道在 $x_0$ 和 $x_0' = x_0 + \\delta x_0$ 处初始化。\n一次迭代后，它们的状态为 $x_1 = T(x_0)$ 和 $x_1' = T(x_0 + \\delta x_0)$。\n分离变为 $\\delta x_1 = x_1' - x_1 = T(x_0 + \\delta x_0) - T(x_0)$。\n由于初始分离 $\\delta x_0$ 是无穷小的，且假设映射 $T$ 是连续可微的，我们可以使用 $T(x_0 + \\delta x_0)$ 在 $x_0$ 附近的一阶泰勒级数展开：\n$$\nT(x_0 + \\delta x_0) \\approx T(x_0) + T'(x_0) \\delta x_0\n$$\n其中 $T'(x_0)$ 是 $T$ 在 $x_0$ 处的导数。\n将此代入 $\\delta x_1$ 的表达式中得到：\n$$\n\\delta x_1 \\approx (T(x_0) + T'(x_0) \\delta x_0) - T(x_0) = T'(x_0) \\delta x_0\n$$\n这表明初始分离 $\\delta x_0$ 在一次迭代后被拉伸或压缩了 $|T'(x_0)|$ 倍。\n\n现在，我们考虑分离在 $n$ 次迭代中的演化。第二次迭代后，分离为 $\\delta x_2 \\approx T'(x_1) \\delta x_1$。代入 $\\delta x_1$ 的表达式，我们得到：\n$$\n\\delta x_2 \\approx T'(x_1) \\left( T'(x_0) \\delta x_0 \\right) = T'(x_1) T'(x_0) \\delta x_0\n$$\n通过归纳法，经过 $n$ 次迭代后，分离 $\\delta x_n$ 与初始分离 $\\delta x_0$ 的关系为：\n$$\n\\delta x_n \\approx \\left( \\prod_{k=0}^{n-1} T'(x_k) \\right) \\delta x_0\n$$\n其中 $x_k = T^k(x_0)$ 是主轨道在第 $k$ 次迭代时的状态。根据链式法则，这个乘积项正是映射的第 $n$ 次迭代 $T^n(x_0)$ 的导数：$(T^n)'(x_0) = T'(x_{n-1}) \\cdots T'(x_1) T'(x_0)$。\n\n我们将此结果代入 $\\lambda$ 的定义中：\n$$\n\\lambda = \\lim_{n \\to \\infty} \\frac{1}{n} \\ln \\frac{|\\left( \\prod_{k=0}^{n-1} T'(x_k) \\right) \\delta x_0|}{|\\delta x_0|}\n$$\n$|\\delta x_0|$ 项被消掉：\n$$\n\\lambda = \\lim_{n \\to \\infty} \\frac{1}{n} \\ln \\left| \\prod_{k=0}^{n-1} T'(x_k) \\right|\n$$\n利用对数的性质 $\\ln(\\prod a_i) = \\sum \\ln(a_i)$，我们得到最终表达式：\n$$\n\\lambda = \\lim_{n \\to \\infty} \\frac{1}{n} \\sum_{k=0}^{n-1} \\ln |T'(x_k)|\n$$\n该表达式将最大李雅普诺夫指数表示为沿轨道对映射导数的绝对值的对数进行的长时间平均。\n\n此推导依赖于以下关键假设：\n1.  **可微性**：映射 $T(x)$ 必须在其定义域上至少是连续可微的 ($C^1$)，这样才能使用泰勒级数展开和链式法则。\n2.  **无穷小分离**：整个推导基于映射动力学的线性化，这仅对无穷小分离有效。李雅普诺夫指数描述了这种无穷小扰动的增长率。\n3.  **遍历性**：这是所推导公式具有实用性的一个关键假设。我们假设系统在其吸引子上是遍历的。这意味着对于吸引盆内几乎所有的初始条件 $x_0$，沿其产生轨道的时间平均等于在该吸引子的自然不变测度上的空间平均。因此，该极限存在且独立于典型初始条件 $x_0$ 的具体选择。\n\n### 任务 2：具体化到逻辑斯蒂映射\n\n逻辑斯蒂映射定义为 $T(x) = r x (1 - x)$。\n为了应用推导出的公式，我们首先需要计算它的导数 $T'(x)$：\n$$\nT'(x) = \\frac{d}{dx} \\left( rx - rx^2 \\right) = r - 2rx = r(1-2x)\n$$\n在第 $n$ 步，对 LLE 有限时间估计量的单次迭代贡献是求和内的项，即 $\\ln|T'(x_n)|$。对于逻辑斯蒂映射，该项的显式表达式为：\n$$\n\\ln|T'(x_n)| = \\ln|r(1-2x_n)|\n$$\n\n### 任务 3  4：数值估计与实现\n\n问题提供了一个 LLE 的有限时间估计量：\n$$\n\\hat{\\lambda}_{N,M}(x_0) = \\frac{1}{N} \\sum_{n=1}^{N} \\log \\left| T'(x_{M+n-1}) \\right|\n$$\n这里，$M$ 是“预烧”迭代次数，以使轨道稳定在吸引子上，$N$ 是随后用于计算平均值的迭代次数。\n\n数值实现遵循一个精确的算法以确保鲁棒性，特别是针对奇异点。逻辑斯蒂映射的导数 $T'(x) = r(1-2x)$ 在临界点 $x=0.5$ 处为零，这将导致对数发散到 $-\\infty$。端点 $x=0$ 和 $x=1$ 也可能带来问题。\n\n实现的算法流程如下：\n1.  用初始条件 $x_0$ 初始化状态 $x$。\n2.  执行预烧阶段：迭代映射 $M$ 次。在每次迭代中，更新状态 $x \\leftarrow r x (1 - x)$，然后将结果限制在区间 $[\\varepsilon_{\\text{end}}, 1 - \\varepsilon_{\\text{end}}]$ 内，以防止状态因浮点舍入而精确落在端点上。\n3.  初始化一个累加器 `lyapunov_sum` 为 $0.0$。\n4.  执行 $N$ 次迭代的平均阶段：\n    a. 设当前状态为 $x_{current}$。在使用它之前，检查是否存在数值不稳定的情况。如果一个状态离临界点 $0.5$ 太近（即 $|1 - 2x_{current}|  \\varepsilon_{\\text{crit}}$）或者它位于或太靠近区间端点，则认为该状态不稳定。\n    b. 如果状态不稳定，通过添加一个小的抖动 $\\pm\\varepsilon_{\\text{jit}}$ 来扰动（替换）它。抖动的符号选择为将状态推离区间中心。然后将扰动后的状态限制在 $[\\varepsilon_{\\text{end}}, 1 - \\varepsilon_{\\text{end}}]$ 内。这个新的安全状态将替换旧状态用于当前步骤中的所有后续计算。\n    c. 使用（可能被扰动过的）状态计算导数项 $\\ln|r(1-2x)|$，并将其加到 `lyapunov_sum` 中。\n    d. 使用（可能被扰动过的）状态作为输入，迭代映射以进行下一步计算，$x \\leftarrow r x (1 - x)$。\n    e. 将映射迭代的结果限制在 $[\\varepsilon_{\\text{end}}, 1 - \\varepsilon_{\\text{end}}]$ 内。\n5. 循环结束后，LLE 的估计值计算为 $\\hat{\\lambda} = \\text{lyapunov\\_sum} / N$。\n6. 对指定的五个测试案例应用此过程，并将结果四舍五入到 $6$ 位小数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates the largest Lyapunov exponent for the logistic map\n    for a suite of test cases and prints the results in the specified format.\n    \"\"\"\n    # Define constants for numerical stability from the problem statement.\n    EPS_CRIT = 1.0e-14\n    EPS_JIT = 1.0e-12\n    EPS_END = 1.0e-15\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A (fully developed chaos)\n        {'r': 4.0, 'x0': 0.123456789, 'M': 1000, 'N': 200000},\n        # Case B (critical point initial condition)\n        {'r': 4.0, 'x0': 0.5, 'M': 1000, 'N': 200000},\n        # Case C (periodic window)\n        {'r': 3.2, 'x0': 0.1, 'M': 1000, 'N': 200000},\n        # Case D (onset of chaos)\n        {'r': 3.569945672, 'x0': 0.1, 'M': 2000, 'N': 200000},\n        # Case E (chaotic banded attractor)\n        {'r': 3.75, 'x0': 0.1, 'M': 1000, 'N': 200000},\n    ]\n\n    def calculate_lle(r, x0, M, N):\n        \"\"\"\n        Estimates the Largest Lyapunov Exponent (LLE) for the logistic map.\n\n        Args:\n            r (float): The parameter of the logistic map.\n            x0 (float): The initial condition.\n            M (int): The number of burn-in (transient) iterations.\n            N (int): The number of iterations for averaging.\n\n        Returns:\n            float: The estimated LLE.\n        \"\"\"\n        x = float(x0)\n\n        # Burn-in phase to allow the trajectory to settle on the attractor.\n        # After each map iteration, the state is clamped to avoid rounding\n        # into exact endpoints.\n        for _ in range(M):\n            x = r * x * (1.0 - x)\n            x = max(EPS_END, min(1.0 - EPS_END, x))\n\n        lyapunov_sum = 0.0\n\n        # Averaging phase to compute the LLE.\n        for _ in range(N):\n            # Check for singular or near-singular conditions before evaluation.\n            # This includes being too close to the critical point (x=0.5)\n            # or the interval endpoints.\n            if (abs(1.0 - 2.0 * x)  EPS_CRIT) or \\\n               (x = EPS_END) or (x >= 1.0 - EPS_END):\n                \n                # Perturb the state to avoid singularity.\n                # The sign of the jitter is chosen to push the state away\n                # from the center (0.5).\n                sign_val = np.sign(0.5 - x)\n                if sign_val == 0.0:\n                    sign_val = 1.0  # Handle exact x=0.5 case by picking a direction.\n                \n                x += sign_val * EPS_JIT\n                \n                # Clamp the perturbed state back into the safe interval.\n                x = max(EPS_END, min(1.0 - EPS_END, x))\n\n            # Add the log of the absolute value of the derivative to the sum.\n            # This uses the (potentially perturbed) state x.\n            lyapunov_sum += np.log(abs(r * (1.0 - 2.0 * x)))\n\n            # Iterate the map for the next step using the (potentially perturbed) state.\n            x = r * x * (1.0 - x)\n            \n            # Clamp the result of the map iteration to stay within the safe interval.\n            x = max(EPS_END, min(1.0 - EPS_END, x))\n\n        # The LLE is the average of the logged values.\n        return lyapunov_sum / N\n\n    results = []\n    for case in test_cases:\n        lle = calculate_lle(case['r'], case['x0'], case['M'], case['N'])\n        # Format the result to 6 decimal places as a string.\n        results.append(f\"{lle:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "我们如何分析连续时间混沌系统（如天气模型或湍流）中复杂的、盘绕的轨迹？本练习  将演示一种强大的降维技术：庞加莱截面。通过系统地记录轨迹穿过特定平面的位置，我们可以将一个三维流动（例如罗斯勒系统）简化为一个一维的“首次返回映射”。这项实践将指导你通过数值方法构建此映射，并分析其结构，以识别隐藏在连续流动中混沌动力学的标志性特征——拉伸与折叠。",
            "id": "4293629",
            "problem": "给定一个三维 Rössler 动力系统，由以下常微分方程（ODE）组定义\n$$\n\\dot{x} = -y - z,\\quad \\dot{y} = x + a y,\\quad \\dot{z} = b + z(x - c),\n$$\n其中 $x$、$y$ 和 $z$ 是状态变量，$a$、$b$ 和 $c$ 是参数。通过考虑流在平面 $\\Sigma: x=0$ 上以 $\\dot{x} > 0$ 方向穿越的点集，可以构建一个 Poincaré 截面。与该截面相关的首次返回映射 $f$ 将每个交点值 $z_n$ 映射到下一个交点值 $z_{n+1}$。\n\n从确定性连续时间动力系统和 Poincaré 截面的基本定义出发，设计一个程序，对于给定的参数三元组 $(a,b,c)$，执行以下操作：\n- 使用步长为 $\\Delta t$ 的定步长四阶 Runge–Kutta 方法对 Rössler 系统进行数值积分，以近似流 $\\phi_t$。\n- 通过识别 $x$ 从负值变为非负值且方向条件 $\\dot{x}>0$ 成立的转换，来检测对 Poincaré 截面 $\\Sigma$ 的穿越，并记录穿越时线性插值得到的交点值 $z$。\n- 在丢弃最初的 $N_{\\mathrm{discard}}$ 个交点的暂态后，利用接下来的 $N_{\\mathrm{map}}$ 个交点构建有序对 $(z_n,z_{n+1})$，从而构造首次返回映射。\n- 使用以下方法量化首次返回映射中的拉伸和折叠结构指标：\n    1. 动态范围 $R = \\max(z_n) - \\min(z_n)$。\n    2. 通过有限差分从排序后的映射中计算出的最大绝对斜率 $S_{\\max}$，即\n       $$S_i = \\frac{z_{n+1}^{(i+1)} - z_{n+1}^{(i)}}{z_n^{(i+1)} - z_n^{(i)}},\\quad S_{\\max} = \\max_i |S_i|,$$\n       其中上标表示按 $z_n$ 排序。\n    3. 斜率符号变化次数 $\\sigma$，定义为相邻 $S_i$ 符号不同的次数。\n    4. 对角线穿越次数 $\\kappa$，定义为 $\\operatorname{sign}(z_{n+1}^{(i)} - z_n^{(i)})$ 符号发生变化的相邻索引的次数。\n- 当且仅当以下决策规则成立时，宣布首次返回映射揭示了混沌动力学：\n    $$\\text{chaotic} \\iff \\left(R > 10^{-3}\\right)\\ \\land\\ \\left(S_{\\max} > 1.1\\right)\\ \\land\\ \\left(\\sigma \\ge 1\\right)\\ \\land\\ \\left(\\kappa \\ge 2\\right),$$\n  否则宣布为非混沌。\n\n数值积分细节和单位：\n- 使用 $\\Delta t = 0.01$ 和定步长四阶 Runge–Kutta 方法进行足够长时间的积分以收集交点。在此数学模型中，时间是无量纲的。\n- 使用连续数值状态之间的线性插值来估计在 $\\Sigma$ 上的交点。\n- 初始条件必须为 $(x_0,y_0,z_0)=(1,1,1)$。\n- 使用 $N_{\\mathrm{discard}}=100$ 和 $N_{\\mathrm{map}}=300$。\n\n测试套件：\n- 情况 1：$a=0.2$, $b=0.2$, $c=5.7$（典型混沌区）。\n- 情况 2：$a=0.2$, $b=0.2$, $c=4.0$（周期区）。\n- 情况 3：$a=0.2$, $b=0.2$, $c=4.5$（临近转变区）。\n\n边界条件和覆盖率要求：\n- 通过要求至少 50 个首次返回对来确保鲁棒性；如果获得的对数少于此值，则对该情况返回非混沌的决策。\n- 通过在 $|x_{n+1} - x_n|  10^{-12}$ 时拒绝穿越，来处理 $x$ 以极小增量改变符号的近切向穿越情况。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含三个测试用例的布尔结果，格式为用方括号括起来的逗号分隔列表（例如，“[True,False,True]”）。",
            "solution": "Rössler 系统是一个连续时间确定性动力系统，由常微分方程（ODE）流控制\n$$\n\\dot{\\mathbf{x}} = \\mathbf{F}(\\mathbf{x}),\\quad \\mathbf{x} = (x,y,z),\\quad \\mathbf{F}(x,y,z) = \\left(-y-z,\\ x+a y,\\ b+z(x-c)\\right).\n$$\nPoincaré 截面通过在方向约束（此处为 $\\dot{x} > 0$）下考虑轨迹与一个余维为一的流形（此处为平面 $\\Sigma: x=0$）的交点来降低维度。首次返回映射 $f$ 将一个交点坐标 $z_n$ 映射到下一个交点 $z_{n+1}$，从而产生一个限制在截面上的连续流的一维离散时间表示。在此类系统中，混沌动力学通过首次返回映射中的拉伸和折叠现象得以揭示，这可以通过斜率超过一和非单调性来检测。\n\n基于原理的构造与算法：\n1. 基本定义：\n   - 一个确定性 ODE 定义了一个流 $\\phi_t$，它满足 $\\frac{d}{dt}\\phi_t(\\mathbf{x}_0) = \\mathbf{F}(\\phi_t(\\mathbf{x}_0))$，初始条件为 $\\phi_0(\\mathbf{x}_0) = \\mathbf{x}_0$。\n   - 一个具有平面 $\\Sigma: x=0$ 的 Poincaré 截面记录了状态序列 $\\{\\mathbf{x}(t_n)\\}$，使得 $x(t_n) = 0$ 且 $\\dot{x}(t_n) > 0$，从而生成交点坐标 $\\{z_n\\}$。\n   - 首次返回映射 $f$ 由连续的交点构建：$f(z_n) = z_{n+1}$，其合理性在于连续流和截面引起的回归。\n\n2. 数值积分：\n   - 使用定步长四阶 Runge–Kutta (RK4) 方法，这是一种经过充分检验的方法，通过以下公式近似流：\n     $$\n     \\begin{aligned}\n     \\mathbf{k}_1 = \\mathbf{F}(\\mathbf{x}_n),\\\\\n     \\mathbf{k}_2 = \\mathbf{F}(\\mathbf{x}_n + \\tfrac{\\Delta t}{2}\\mathbf{k}_1),\\\\\n     \\mathbf{k}_3 = \\mathbf{F}(\\mathbf{x}_n + \\tfrac{\\Delta t}{2}\\mathbf{k}_2),\\\\\n     \\mathbf{k}_4 = \\mathbf{F}(\\mathbf{x}_n + \\Delta t\\,\\mathbf{k}_3),\\\\\n     \\mathbf{x}_{n+1} = \\mathbf{x}_n + \\tfrac{\\Delta t}{6}\\left(\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4\\right).\n     \\end{aligned}\n     $$\n   - 步长 $\\Delta t$ 设置为 $\\Delta t = 0.01$，积分持续进行，直到收集到足够数量的截面穿越点。\n\n3. Poincaré 截面检测：\n   - 当 $x_n  0$，$x_{n+1} \\ge 0$，且方向约束 $\\dot{x} = -y - z > 0$ 满足时（为简化起见，在步进后的状态下进行评估），即检测到一次正确方向的穿越。\n   - $\\Sigma$ 上的交点通过连续状态之间的线性插值来近似：\n     $$\n     \\alpha = \\frac{-x_n}{x_{n+1} - x_n},\\quad z_\\text{cross} = z_n + \\alpha (z_{n+1} - z_n),\n     $$\n     如果需要，$y$ 也有类似的表达式。拒绝 $|x_{n+1} - x_n|  10^{-12}$ 的穿越以避免数值伪影。\n\n4. 首次返回映射构造：\n   - 丢弃前 $N_{\\mathrm{discard}} = 100$ 个交点以消除暂态效应。\n   - 使用接下来的 $N_{\\mathrm{map}} = 300$ 个交点形成有序对 $(z_n, z_{n+1})$。\n\n5. 拉伸和折叠的指标：\n   - 按 $z_n$ 对这些点对进行排序，以沿其定义域参数化映射。设 $\\{(z_n^{(i)}, z_{n+1}^{(i)})\\}_{i=1}^M$ 表示排序后的序列，其中 $M = N_{\\mathrm{map}} - 1$。\n   - 计算有限差分斜率\n     $$\n     S_i = \\frac{z_{n+1}^{(i+1)} - z_{n+1}^{(i)}}{z_n^{(i+1)} - z_n^{(i)}},\n     $$\n     跳过 $|z_n^{(i+1)} - z_n^{(i)}|$ 小于一个很小容差的索引，以避免除以零。\n   - 最大绝对斜率 $S_{\\max} = \\max_i |S_i|$ 表示局部拉伸；$S_{\\max} > 1$ 是一个经典指标，表明映射会放大邻近点之间的距离。\n   - 斜率符号变化次数\n     $$\n     \\sigma = \\#\\left\\{i : \\operatorname{sign}(S_i) \\ne \\operatorname{sign}(S_{i+1})\\right\\}\n     $$\n     表示折叠（非单调性）。\n   - 对角线穿越次数\n     $$\n     \\kappa = \\#\\left\\{i : \\operatorname{sign}(z_{n+1}^{(i)} - z_n^{(i)}) \\ne \\operatorname{sign}(z_{n+1}^{(i+1)} - z_n^{(i+1)})\\right\\}\n     $$\n     捕捉了映射穿越恒等线 $z_{n+1} = z_n$ 的频率，这是多不动点和复杂返回动力学的代表指标。\n   - 动态范围 $R = \\max(z_n) - \\min(z_n)$ 确保了平凡的近常数映射（简单极限环的典型特征）不会因数值噪声而被错误分类。\n\n6. 决策规则与理由：\n   - 当 $R > 10^{-3}$、$S_{\\max} > 1.1$、$\\sigma \\ge 1$ 且 $\\kappa \\ge 2$ 时，宣布为混沌。此规则体现了从 Poincaré 截面导出的一维混沌映射的核心定性特征：足够的延展（非平凡动力学）、超过单位一的拉伸（敏感依赖性），以及伴随重复恒等线穿越的折叠（复杂回归）。\n   - 对于典型参数 $a=0.2$、$b=0.2$、$c=5.7$，根据经验，Rössler 系统表现出混沌；其首次返回映射通常是单峰的，具有超过一的陡峭斜率和清晰的折叠，满足决策规则。\n   - 对于 $a=0.2$、$b=0.2$、$c=4.0$，系统会稳定到一个周期轨道；截面交点会收缩到单个值附近，导致 $R$ 值很小，斜率接近零或未定义但被过滤，因此不满足决策规则。\n   - 对于 $a=0.2$、$b=0.2$、$c=4.5$，系统行为接近一个转变点；这些指标可以量化拉伸和折叠是否已经足够强。\n\n7. 输出：\n   - 程序将上述过程应用于三个指定的参数集，并以“[True,False,True]”的格式打印包含布尔决策的单行输出。底层的计算遵循基于原理的检测方法，该方法根植于 Poincaré 首次返回映射的结构，不依赖于快捷公式。\n\n该方法将动力系统理论的机理定义与数值稳定的算法和可量化的标准相结合，从而能够使用 Poincaré 截面的首次返回映射对混沌动力学进行可复现的检测。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef rossler_deriv(state, a, b, c):\n    \"\"\"Compute the Rössler derivatives at a given state.\"\"\"\n    x, y, z = state\n    dx = -y - z\n    dy = x + a * y\n    dz = b + z * (x - c)\n    return np.array([dx, dy, dz], dtype=float)\n\ndef rk4_step(state, dt, a, b, c):\n    \"\"\"Perform one fixed-step RK4 update for the Rössler system.\"\"\"\n    k1 = rossler_deriv(state, a, b, c)\n    k2 = rossler_deriv(state + 0.5 * dt * k1, a, b, c)\n    k3 = rossler_deriv(state + 0.5 * dt * k2, a, b, c)\n    k4 = rossler_deriv(state + dt * k3, a, b, c)\n    return state + (dt / 6.0) * (k1 + 2*k2 + 2*k3 + k4)\n\ndef simulate_intersections(a, b, c, dt=0.01, max_steps=250000, discard=100, need_after_discard=300):\n    \"\"\"\n    Simulate the Rössler system and collect z-values at intersections\n    with the Poincaré section x=0, crossing with increasing x (dx/dt  0).\n    Uses linear interpolation between successive RK4 states.\n    \"\"\"\n    state = np.array([1.0, 1.0, 1.0], dtype=float)  # initial condition\n    x_prev, y_prev, z_prev = state\n    intersections = []\n\n    # Warm-up few steps to move away from initial condition if needed\n    for _ in range(100):\n        state = rk4_step(state, dt, a, b, c)\n    x_prev, y_prev, z_prev = state\n\n    for _ in range(max_steps):\n        state_next = rk4_step(state, dt, a, b, c)\n        x_next, y_next, z_next = state_next\n\n        # Directional condition: crossing from x0 to x>=0 and dx/dt > 0\n        # Reject extremely small denominators to avoid numerical artifacts.\n        denom = x_next - x_prev\n        if x_prev  0.0 and x_next >= 0.0 and abs(denom) > 1e-12:\n            dx_next = -y_next - z_next\n            if dx_next > 0.0:\n                # Linear interpolation to find intersection on x=0\n                alpha = -x_prev / denom\n                # Interpolate z at crossing\n                z_cross = z_prev + alpha * (z_next - z_prev)\n                intersections.append(z_cross)\n\n        # Advance\n        state = state_next\n        x_prev, y_prev, z_prev = state\n\n        # Early exit if enough intersections collected\n        if len(intersections) >= discard + need_after_discard + 5:\n            # Collect a few extra beyond need_after_discard for robust pairing\n            break\n\n    # If not enough intersections collected, return empty list\n    if len(intersections)  discard + need_after_discard:\n        return []\n\n    # Discard transients and keep needed intersections\n    return intersections[discard:discard + need_after_discard]\n\ndef analyze_first_return(z_list):\n    \"\"\"\n    Analyze first-return map pairs (z_n, z_{n+1}) and compute chaos indicators:\n    dynamic range R, maximum absolute slope S_max, slope sign changes sigma,\n    diagonal crossings kappa. Apply decision rule to return boolean.\n    \"\"\"\n    if len(z_list)  2:\n        return False\n\n    z = np.array(z_list, dtype=float)\n    R = float(np.max(z) - np.min(z))\n\n    # Form pairs (z_n, z_{n+1})\n    z_n = z[:-1]\n    z_np1 = z[1:]\n    M = len(z_n)\n    if M  50:\n        return False  # Not enough data for robust analysis\n\n    # Sort by z_n to parameterize the map\n    order = np.argsort(z_n)\n    z_sorted = z_n[order]\n    znext_sorted = z_np1[order]\n\n    # Compute finite-difference slopes, skipping near-zero delta z\n    slopes = []\n    for i in range(M - 1):\n        dz = z_sorted[i + 1] - z_sorted[i]\n        if abs(dz)  1e-10:\n            continue\n        s = (znext_sorted[i + 1] - znext_sorted[i]) / dz\n        slopes.append(s)\n    if len(slopes) == 0:\n        S_max = 0.0\n        slope_sign_changes = 0\n    else:\n        slopes = np.array(slopes, dtype=float)\n        S_max = float(np.max(np.abs(slopes)))\n        # Compute slope sign changes (ignore zeros by using sign of nonzero values)\n        signs = np.sign(slopes)\n        # Filter out zeros by keeping nonzero signs\n        nz = signs[signs != 0.0]\n        if len(nz)  2:\n            slope_sign_changes = 0\n        else:\n            slope_sign_changes = int(np.sum(nz[1:] * nz[:-1]  0.0))\n\n    # Compute diagonal crossings: sign changes of (z_next - z) along sorted map\n    d = znext_sorted - z_sorted\n    d_sign = np.sign(d)\n    # Remove zeros for robust count\n    d_nz = d_sign[d_sign != 0.0]\n    if len(d_nz)  2:\n        kappa = 0\n    else:\n        kappa = int(np.sum(d_nz[1:] * d_nz[:-1]  0.0))\n\n    # Decision rule\n    chaotic = (R > 1e-3) and (S_max > 1.1) and (slope_sign_changes >= 1) and (kappa >= 2)\n    return chaotic\n\ndef solve():\n    # Define the test cases from the problem statement: (a, b, c)\n    test_cases = [\n        (0.2, 0.2, 5.7),  # canonical chaotic\n        (0.2, 0.2, 4.0),  # periodic regime\n        (0.2, 0.2, 4.5),  # near transition\n    ]\n\n    dt = 0.01\n    max_steps = 250000\n    discard = 100\n    need_after_discard = 300\n\n    results = []\n    for a, b, c in test_cases:\n        z_intersections = simulate_intersections(\n            a=a, b=b, c=c,\n            dt=dt, max_steps=max_steps,\n            discard=discard, need_after_discard=need_after_discard\n        )\n        result = analyze_first_return(z_intersections)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}