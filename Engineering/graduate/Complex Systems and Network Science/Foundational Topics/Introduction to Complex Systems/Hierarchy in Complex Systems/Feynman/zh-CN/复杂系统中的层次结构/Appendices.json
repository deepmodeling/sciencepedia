{
    "hands_on_practices": [
        {
            "introduction": "在许多层级系统中，节点具有明确定义的层级。一个关键问题是，连接是倾向于在相似层级的节点之间形成，还是在不同层级的节点之间形成？基于皮尔逊相关系数的层级同配性（Level Assortativity）为回答这个问题提供了一个精确的工具。本练习将指导你推导该公式并将其应用于一个具体示例，从而加深你对网络度量如何量化结构模式的理解 ()。",
            "id": "4281144",
            "problem": "考虑一个表示层级系统的无向网络，其节点标记为 $1$ 到 $8$，并具有属性 $\\ell_i \\in \\mathbb{N}$ 表示节点 $i$ 的层级。各层级定义如下：$\\ell_1 = 0$，$\\ell_2 = 1$，$\\ell_3 = 1$，$\\ell_4 = 2$，$\\ell_5 = 2$，$\\ell_6 = 2$，$\\ell_7 = 2$ 和 $\\ell_8 = 3$。该网络具有以下无向边：\n$$(1,2),\\ (1,3),\\ (2,4),\\ (2,5),\\ (3,6),\\ (3,7),\\ (4,5),\\ (6,7),\\ (5,8),\\ (7,8),\\ (2,3)$$\n使用皮尔逊相关系数（PCC）的定义，将无向网络的层级同配系数 $r_{\\mathrm{level}}$ 定义为当边被无方向地均匀随机抽样时，边两端节点的层级之间的相关性。从两个实值随机变量之间相关性的基本定义出发，推导一个适用于节点上带有标量属性的无向网络的 $r_{\\mathrm{level}}$ 公式。然后，为上述网络精确计算 $r_{\\mathrm{level}}$。将最终答案表示为单个最简有理数。无需四舍五入。",
            "solution": "该问题经评估有效，因为它在网络科学中有科学依据，提法得当，客观，并包含得出唯一解所需的所有信息。\n\n该问题要求推导层级同配系数 $r_{\\mathrm{level}}$ 的通用公式，并对一个特定网络进行计算。层级同配系数定义为边两端节点层级的皮尔逊相关系数（PCC）。\n\n首先，我们推导通用公式。设网络由一个节点集合 $V$ 和一个无向边集合 $E$ 描述。节点数为 $N = |V|$，边数为 $M = |E|$。每个节点 $i \\in V$ 都有一个标量属性，即其层级，记为 $\\ell_i$。\n\n两个随机变量 $X$ 和 $Y$ 的皮尔逊相关系数 $\\rho_{X,Y}$ 定义为：\n$$\n\\rho_{X,Y} = \\frac{\\mathrm{Cov}(X,Y)}{\\sigma_X \\sigma_Y} = \\frac{E[XY] - E[X]E[Y]}{\\sqrt{E[X^2] - (E[X])^2} \\sqrt{E[Y^2] - (E[Y])^2}}\n$$\n为了将其应用于我们的网络，我们必须定义样本空间和随机变量。问题陈述我们“无方向地均匀随机”抽样边。对于无向网络，一种标准而严谨的形式化方法是考虑一个包含 $2M$ 条有向边的样本空间，其中每条无向边 $(i,j) \\in E$ 对应于两条有向边 $i \\to j$ 和 $j \\to i$。这 $2M$ 条有向边中的每一条都以等概率 $\\frac{1}{2M}$ 被选择。\n\n设 $X$ 和 $Y$ 分别是随机选择的有向边的源节点和目标节点层级的随机变量。对于一条有向边 $i \\to j$，观测值为 $(\\ell_i, \\ell_j)$。\n\n$X$ 的取值集合是 $\\{\\ell_i | \\text{对于每条有向边 } i \\to j\\}$，$Y$ 的取值集合是 $\\{\\ell_j | \\text{对于每条有向边 } i \\to j\\}$。由于网络是无向的，所有源节点的集合与所有目标节点的集合相同，$X$ 和 $Y$ 的分布是相同的。因此，$E[X] = E[Y]$ 且 $\\sigma_X = \\sigma_Y$。$r_{\\mathrm{level}}$ 的公式简化为：\n$$\nr_{\\mathrm{level}} = \\frac{E[XY] - (E[X])^2}{E[X^2] - (E[X])^2}\n$$\n我们现在用网络属性来表示期望值。设 $d_i$ 为节点 $i$ 的度。在 $2M$ 条有向边的集合中，一个节点 $i$ 作为源节点出现 $d_i$ 次。\n$X$ 的期望值为：\n$$\nE[X] = \\sum_{i \\to j} \\frac{1}{2M} \\ell_i = \\frac{1}{2M} \\sum_{i \\in V} d_i \\ell_i\n$$\n$X^2$ 的期望值为：\n$$\nE[X^2] = \\sum_{i \\to j} \\frac{1}{2M} \\ell_i^2 = \\frac{1}{2M} \\sum_{i \\in V} d_i \\ell_i^2\n$$\n联合期望 $E[XY]$ 是对所有 $2M$ 条有向边计算的：\n$$\nE[XY] = \\sum_{i \\to j} \\frac{1}{2M} \\ell_i \\ell_j = \\frac{1}{2M} \\sum_{(i,j) \\in E} (\\ell_i \\ell_j + \\ell_j \\ell_i) = \\frac{2}{2M} \\sum_{(i,j) \\in E} \\ell_i \\ell_j = \\frac{1}{M} \\sum_{(i,j) \\in E} \\ell_i \\ell_j\n$$\n将这些表达式代入 $r_{\\mathrm{level}}$ 的公式：\n$$\nr_{\\mathrm{level}} = \\frac{\\frac{1}{M} \\sum_{(i,j) \\in E} \\ell_i \\ell_j - \\left(\\frac{1}{2M} \\sum_{k \\in V} d_k \\ell_k\\right)^2}{\\frac{1}{2M} \\sum_{k \\in V} d_k \\ell_k^2 - \\left(\\frac{1}{2M} \\sum_{k \\in V} d_k \\ell_k\\right)^2}\n$$\n为简化表达式，分子和分母同乘以 $4M^2$：\n$$\nr_{\\mathrm{level}} = \\frac{4M \\sum_{(i,j) \\in E} \\ell_i \\ell_j - \\left(\\sum_{k \\in V} d_k \\ell_k\\right)^2}{2M \\sum_{k \\in V} d_k \\ell_k^2 - \\left(\\sum_{k \\in V} d_k \\ell_k\\right)^2}\n$$\n这是无向网络节点上标量属性的同配系数的通用公式。\n\n现在，我们计算给定网络的 $r_{\\mathrm{level}}$。\n该网络有 $N=8$ 个节点和 $M=11$ 条边。\n层级为：$\\ell_1=0$, $\\ell_2=1$, $\\ell_3=1$, $\\ell_4=2$, $\\ell_5=2$, $\\ell_6=2$, $\\ell_7=2$, $\\ell_8=3$。\n边为：$(1,2), (1,3), (2,4), (2,5), (3,6), (3,7), (4,5), (6,7), (5,8), (7,8), (2,3)$。\n\n首先，我们计算每个节点 $i$ 的度 $d_i$：\n$d_1 = 2$（到 $2, 3$ 的边）\n$d_2 = 4$（到 $1, 4, 5, 3$ 的边）\n$d_3 = 4$（到 $1, 6, 7, 2$ 的边）\n$d_4 = 2$（到 $2, 5$ 的边）\n$d_5 = 3$（到 $2, 4, 8$ 的边）\n$d_6 = 2$（到 $3, 7$ 的边）\n$d_7 = 3$（到 $3, 6, 8$ 的边）\n$d_8 = 2$（到 $5, 7$ 的边）\n度之和为 $\\sum_{i=1}^8 d_i = 2+4+4+2+3+2+3+2=22$，这正好等于 $2M = 2 \\times 11$。\n\n接下来，我们计算公式所需的三个和：\n1. $S_1 = \\sum_{k \\in V} d_k \\ell_k$：\n$S_1 = d_1\\ell_1 + d_2\\ell_2 + d_3\\ell_3 + d_4\\ell_4 + d_5\\ell_5 + d_6\\ell_6 + d_7\\ell_7 + d_8\\ell_8$\n$S_1 = (2)(0) + (4)(1) + (4)(1) + (2)(2) + (3)(2) + (2)(2) + (3)(2) + (2)(3)$\n$S_1 = 0 + 4 + 4 + 4 + 6 + 4 + 6 + 6 = 34$\n\n2. $S_2 = \\sum_{k \\in V} d_k \\ell_k^2$：\n$S_2 = d_1\\ell_1^2 + d_2\\ell_2^2 + d_3\\ell_3^2 + d_4\\ell_4^2 + d_5\\ell_5^2 + d_6\\ell_6^2 + d_7\\ell_7^2 + d_8\\ell_8^2$\n$S_2 = (2)(0^2) + (4)(1^2) + (4)(1^2) + (2)(2^2) + (3)(2^2) + (2)(2^2) + (3)(2^2) + (2)(3^2)$\n$S_2 = 0 + 4 + 4 + 8 + 12 + 8 + 12 + 18 = 66$\n\n3. $S_3 = \\sum_{(i,j) \\in E} \\ell_i \\ell_j$：\n$S_3 = \\ell_1\\ell_2 + \\ell_1\\ell_3 + \\ell_2\\ell_4 + \\ell_2\\ell_5 + \\ell_3\\ell_6 + \\ell_3\\ell_7 + \\ell_4\\ell_5 + \\ell_6\\ell_7 + \\ell_5\\ell_8 + \\ell_7\\ell_8 + \\ell_2\\ell_3$\n$S_3 = (0)(1) + (0)(1) + (1)(2) + (1)(2) + (1)(2) + (1)(2) + (2)(2) + (2)(2) + (2)(3) + (2)(3) + (1)(1)$\n$S_3 = 0 + 0 + 2 + 2 + 2 + 2 + 4 + 4 + 6 + 6 + 1 = 29$\n\n现在我们将这些值代入 $r_{\\mathrm{level}}$ 的公式，其中 $M=11$：\n$$\nr_{\\mathrm{level}} = \\frac{4M S_3 - S_1^2}{2M S_2 - S_1^2} = \\frac{4(11)(29) - (34)^2}{2(11)(66) - (34)^2}\n$$\n计算分子：\n$4(11)(29) = 44 \\times 29 = 1276$\n$34^2 = 1156$\n分子 = $1276 - 1156 = 120$\n\n计算分母：\n$2(11)(66) = 22 \\times 66 = 1452$\n$34^2 = 1156$\n分母 = $1452 - 1156 = 296$\n\n所以，层级同配系数为：\n$$\nr_{\\mathrm{level}} = \\frac{120}{296}\n$$\n最后，我们将分数化为最简形式。我们求 $120$ 和 $296$ 的最大公约数：\n$120 = 12 \\times 10 = (2^2 \\times 3) \\times (2 \\times 5) = 2^3 \\times 3 \\times 5$\n$296 = 4 \\times 74 = 2^2 \\times (2 \\times 37) = 2^3 \\times 37$\n最大公约数是 $2^3 = 8$。\n$$\nr_{\\mathrm{level}} = \\frac{120 \\div 8}{296 \\div 8} = \\frac{15}{37}\n$$\n给定网络的层级同配系数的精确值为 $\\frac{15}{37}$。",
            "answer": "$$\\boxed{\\frac{15}{37}}$$"
        },
        {
            "introduction": "层级结构不仅关乎静态的节点划分，它还深刻地影响着信息或影响如何在系统中流动。全局可达性中心性（Global Reaching Centrality, GRC）通过衡量节点可达范围的异质性来捕捉这一功能性特征。本实践更进一步，引入了度保持重连这一关键的零模型技术，旨在证明网络的层级结构是一种高阶特性，而不仅仅是其度分布的副产品 ()。",
            "id": "4281098",
            "problem": "您的任务是形式化并计算有向网络中的度保持重连如何影响一种称为全局可达中心性的层次性度量。您的程序必须从复杂系统和网络科学的核心定义出发，不依赖任何假设答案的捷径或启发式方法。一个有向图由一个大小为 $N$ 的节点集和一组有向边定义。有向图的入度序列和出度序列分别是每个节点的入边和出边计数。度保持重连是指任何一种能使每个节点的入度和出度序列都保持不变的边集变换。一种保持度序列不变的标准微观移动是双边交换：选取两条不同的边 $(u \\to v)$ 和 $(x \\to y)$，如果有效，则将其替换为 $(u \\to y)$ 和 $(x \\to v)$；有效性要求不产生自环，不引入平行边（即图仍为简单有向图），并且两条替换边不与原始边完全相同。\n\n节点 $i$ 的局部可达中心性定义为其通过有向路径可以到达的其他节点的比例。对于一个有 $N$ 个节点的有向图，设可达性计数 $R_i$ 是从节点 $i$ 出发沿有向路径可达的不同节点的数量，不包括 $i$ 本身。那么局部可达中心性为 $c(i) = R_i / (N-1)$。全局可达中心性（GRC）通过聚合所有节点与最大局部可达中心性 $c_{\\max} = \\max_j c(j)$ 的距离，来表征局部可达中心性的异质性。您必须基于这些定义推导并实现这个网络级度量的计算。\n\n您的程序必须：\n- 为每个节点 $i$ 实现有向可达性的计算以统计 $R_i$，并由此计算每个节点 $i$ 的 $c(i)$，然后根据 $c_{\\max}$ 和集合 $\\{c(i)\\}$ 的聚合计算全局可达中心性。\n- 基于上述指定的重复有效双边交换，实现度保持重连。设 $E$ 为有向边的数量。对于给定的重连强度参数 $f \\in [0,1]$，执行恰好 $S = \\lfloor f \\cdot E \\rfloor$ 次成功的交换。为保证可复现性，随机性必须由给定的整数种子 $s$ 控制。\n- 对于下面提供的每个测试用例，计算原始图的全局可达中心性，使用指定的 $(f,s)$ 对图进行重连，然后再次计算全局可达中心性。返回由初始值、重连后值及其差值（重连后减去重连前）组成的三元组。\n\n使用以下测试套件，其中节点标记为 $0,1,\\dots,N-1$，每条边是一个有序对 $(u,v)$，表示一条有向边 $u \\to v$。这里提供的所有数字（包括 $N$、$E$、$f$ 和 $s$ 的值）都必须按字面值处理。\n\n- 测试用例 1 (层次化树状结构):\n  - $N = 9$\n  - 边集: $(0,1)$, $(0,2)$, $(0,3)$, $(1,4)$, $(1,5)$, $(2,6), (3,7), (3,8)$\n  - $f = 1.0$\n  - 种子 $s = 42$\n\n- 测试用例 2 (有向环):\n  - $N = 8$\n  - 边集: $(0,1)$, $(1,2)$, $(2,3), (3,4), (4,5), (5,6), (6,7), (7,0)$\n  - $f = 1.0$\n  - 种子 $s = 7$\n\n- 测试用例 3 (前馈有向无环图):\n  - $N = 10$\n  - 边集: $(0,2), (0,3), (1,3), (1,4), (2,5), (2,6), (3,6), (4,7), (5,8), (6,8), (7,9), (8,9)\n  - $f = 0.5$\n  - 种子 $s = 123$\n\n- 测试用例 4 (边界无重连情况):\n  - $N = 7$\n  - 边集: $(0,1), (0,2), (1,3), (2,3), (3,4), (4,5), (5,6)$\n  - $f = 0.0$\n  - 种子 $s = 99$\n\n最终输出格式：\n- 您的程序必须生成单行文本，其中包含一个扁平列表，按顺序包含每个测试用例的 3 个浮点数，并连接成一个列表。对于每个测试用例，输出初始全局可达中心性、重连后全局可达中心性以及它们的差值（重连后减去重连前）。将所有测试用例的这些三元组连接成一个列表。每个浮点数必须四舍五入到恰好 $6$ 位小数。最后一行必须看起来像\n  - $[\\text{r}_{1,1},\\text{r}_{1,2},\\text{r}_{1,3},\\text{r}_{2,1},\\dots,\\text{r}_{4,3}]$\n  其中 $\\text{r}_{k,j}$ 是测试用例 $k$ 的第 $j$ 个结果。",
            "solution": "经过严格审查，该问题被认定为有效。它在网络科学方面有科学依据，提法明确且客观。全局可达中心性（GRC）的定义被表述为与最大局部中心性的距离聚合。虽然未指定确切的聚合函数，但科学文献中存在一个标准定义，我将采用该定义。该问题可通过标准图算法的组合来解决。\n\n解决方案分为三个主要阶段：首先，形式化并计算全局可达中心性（GRC）；其次，实现度保持重连过程；第三，将这些应用于每个测试用例。\n\n### 1. 全局可达中心性（GRC）\n\n问题将有向图中节点 $i$ 的局部可达中心性 $c(i)$ 定义为它能到达的其他节点的比例。设 $R_i$ 为从节点 $i$ 出发沿有向路径可达的不同节点的数量（不包括节点 $i$ 本身）。那么，局部可达中心性为：\n$$c(i) = \\frac{R_i}{N-1}$$\n对于 $N  1$，此值是良定义的。\n\n全局可达中心性（GRC）被描述为衡量这些局部中心性异质性的指标，基于与观察到的最大中心性 $c_{\\max} = \\max_j c(j)$ 的偏差。根据复杂系统文献中的标准定义，我们将 GRC 形式化为网络中所有节点与最大值的偏差的归一化总和：\n$$GRC = \\frac{\\sum_{i=0}^{N-1} (c_{\\max} - c(i))}{N-1}$$\n对于 $N1$，此公式也是良定义的。GRC 为 $0$ 表示所有节点具有相同的局部可达中心性（一种“平等主义”结构），而较高的 GRC 表示更大的异质性，这是层次化结构的特征，即少数节点可以到达许多其他节点，而大多数节点的覆盖范围非常有限。\n\n为了计算 GRC，我们必须首先计算每个节点 $i \\in \\{0, 1, \\dots, N-1\\}$ 的 $R_i$。这是一个有向图上的标准可达性问题。对于每个节点 $i$，我们可以从 $i$ 开始执行图遍历，例如广度优先搜索（BFS）或深度优先搜索（DFS）。除起始节点 $i$ 外的所有被访问节点的集合构成了可达节点的集合。该集合的大小即为 $R_i$。计算 GRC 的整体算法如下：\n1. 对于每个节点 $i=0, \\dots, N-1$：\n   a. 从 $i$ 开始执行图遍历（例如 BFS）以找到所有可达节点。\n   b. 统计可达节点的数量以得到 $R_i$。\n   c. 计算 $c(i) = R_i / (N-1)$。\n2. 找到最大局部中心性 $c_{\\max} = \\max_i c(i)$。\n3. 使用公式 $GRC = (\\sum_i (c_{\\max} - c(i))) / (N-1)$ 计算 GRC。\n\n### 2. 度保持重连\n\n问题指定了一种度保持重连机制：双边交换。此过程修改网络拓扑，同时确保每个节点的入度和出度保持不变。过程如下：\n1. 从图的边集中随机选择两条不同的有向边 $(u \\to v)$ 和 $(x \\to y)$。\n2. 尝试用一对新边 $(u \\to y)$ 和 $(x \\to v)$ 替换它们。\n3. 仅当交换遵循简单有向图的以下有效性条件时，才被视为“成功”：\n   a. **无自环**：新边不能是自环，即 $u \\neq y$ 且 $x \\neq v$。\n   b. **无平行边**：新边 $(u \\to y)$ 和 $(x \\to v)$ 不能已存在于图中。\n   c. **非平凡性**：新边集合必须与原始边集合不同。这当且仅当 $u \\neq x$ 且 $v \\neq y$ 时成立。此条件确保交换确实修改了图结构。\n\n对于一个具有 $E$ 条边的给定图和重连强度参数 $f \\in [0,1]$，算法必须执行恰好 $S = \\lfloor f \\cdot E \\rfloor$ 次成功的交换。为实现这一点，我们重复选择边对并根据有效性条件进行测试，直到累积了 $S$ 次成功的交换。随机性由种子 $s$ 管理以保证可复现性。\n\n因此，重连算法如下：\n1. 使用给定的种子 $s$ 初始化一个伪随机数生成器。\n2. 设当前边集为 $\\mathcal{E}$。设 $E = |\\mathcal{E}|$。\n3. 计算目标交换次数 $S = \\lfloor f \\cdot E \\rfloor$。\n4. 如果 $S  0$，进入一个循环以执行 $S$ 次成功的交换：\n   a. 从当前边列表中重复选择两条不同的边 $(u, v)$ 和 $(x, y)$。\n   b. 检查交换为 $(u, y)$ 和 $(x, v)$ 是否有效（无自环、无平行边、非平凡）。\n   c. 如果有效，更新边集：$\\mathcal{E} \\leftarrow (\\mathcal{E} \\setminus \\{(u,v), (x,y)\\}) \\cup \\{(u,y), (x,v)\\}$。这构成一次成功的交换。增加成功计数器并进行下一次交换。\n   d. 如果无效，则放弃选择并用新的一对随机边重试。\n\n### 3. 每个测试用例的总体流程\n\n对于由节点数 $N$、初始边集、重连强度 $f$ 和种子 $s$ 定义的每个测试用例，执行以下步骤：\n1. 根据给定的 $N$ 和边集构建初始图。\n2. 使用第 1 节中描述的方法计算初始全局可达中心性 $GRC_{initial}$。\n3. 使用参数 $f$ 和 $s$，按照第 2 节中描述的度保持重连算法执行，以获得一个新的、重连后的图。如果 $f=0$，则不发生重连，图保持不变。\n4. 计算重连后图的全局可达中心性 $GRC_{post}$。\n5. 计算差值 $\\Delta_{GRC} = GRC_{post} - GRC_{initial}$。\n6. 测试用例的最终结果是三元组 $(GRC_{initial}, GRC_{post}, \\Delta_{GRC})$。将所有测试用例的这些三元组连接起来，以产生最终输出。",
            "answer": "```python\nimport numpy as np\nfrom collections import deque\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases.\n    \"\"\"\n    test_cases = [\n        {\n            \"N\": 9,\n            \"edges\": [(0, 1), (0, 2), (0, 3), (1, 4), (1, 5), (2, 6), (3, 7), (3, 8)],\n            \"f\": 1.0,\n            \"s\": 42\n        },\n        {\n            \"N\": 8,\n            \"edges\": [(0, 1), (1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 7), (7, 0)],\n            \"f\": 1.0,\n            \"s\": 7\n        },\n        {\n            \"N\": 10,\n            \"edges\": [\n                (0, 2), (0, 3), (1, 3), (1, 4), (2, 5), (2, 6), \n                (3, 6), (4, 7), (5, 8), (6, 8), (7, 9), (8, 9)\n            ],\n            \"f\": 0.5,\n            \"s\": 123\n        },\n        {\n            \"N\": 7,\n            \"edges\": [(0, 1), (0, 2), (1, 3), (2, 3), (3, 4), (4, 5), (5, 6)],\n            \"f\": 0.0,\n            \"s\": 99\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        N, edges, f, s = case[\"N\"], case[\"edges\"], case[\"f\"], case[\"s\"]\n        initial_grc, post_grc, diff_grc = process_case(N, edges, f, s)\n        results.extend([initial_grc, post_grc, diff_grc])\n\n    # Format output to exactly 6 decimal places.\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\ndef _get_reachable_set(start_node, N, adj):\n    \"\"\"\n    Computes the set of reachable nodes from a given start_node using BFS.\n    \"\"\"\n    if start_node not in adj:\n        return set()\n    \n    q = deque([start_node])\n    visited = {start_node}\n    \n    while q:\n        u = q.popleft()\n        if u in adj:\n            for v in adj[u]:\n                if v not in visited:\n                    visited.add(v)\n                    q.append(v)\n                    \n    return visited - {start_node}\n\ndef calculate_grc(N, edges):\n    \"\"\"\n    Calculates the Global Reaching Centrality for a given graph.\n    \"\"\"\n    if N = 1:\n        return 0.0\n\n    adj = {i: [] for i in range(N)}\n    for u, v in edges:\n        adj[u].append(v)\n\n    local_centralities = np.zeros(N)\n    for i in range(N):\n        reachable_nodes = _get_reachable_set(i, N, adj)\n        R_i = len(reachable_nodes)\n        local_centralities[i] = R_i / (N - 1)\n\n    if len(local_centralities) == 0:\n        return 0.0\n        \n    c_max = np.max(local_centralities)\n    \n    grc_numerator = np.sum(c_max - local_centralities)\n    grc = grc_numerator / (N - 1)\n    \n    return grc\n\ndef process_case(N, edges, f, s):\n    \"\"\"\n    Processes a single test case: calculates initial GRC, performs rewiring,\n    and calculates post-rewiring GRC.\n    \"\"\"\n    # Calculate initial GRC\n    initial_grc = calculate_grc(N, edges)\n\n    # Perform rewiring\n    E = len(edges)\n    num_swaps = int(f * E)\n    \n    if num_swaps == 0:\n        post_grc = initial_grc\n    else:\n        rng = np.random.default_rng(seed=s)\n        edge_set = set(edges)\n        edge_list = list(edges)\n\n        successful_swaps = 0\n        # Add a failsafe for potentially difficult-to-rewire topologies\n        max_attempts = 100 * E * num_swaps if num_swaps  0 else 1\n        attempts = 0\n\n        while successful_swaps  num_swaps and attempts  max_attempts:\n            attempts += 1\n            if len(edge_list)  2:\n                break # Not enough edges to perform a swap\n            \n            # 1. Pick two distinct edges\n            idx1, idx2 = rng.choice(len(edge_list), size=2, replace=False)\n            u, v = edge_list[idx1]\n            x, y = edge_list[idx2]\n\n            # 2. Check for non-triviality\n            if u == x or v == y:\n                continue\n\n            # Proposed new edges\n            new_edge1 = (u, y)\n            new_edge2 = (x, v)\n\n            # 3. Validity checks\n            # a. No self-loops\n            if u == y or x == v:\n                continue\n            # b. No parallel edges\n            if new_edge1 in edge_set or new_edge2 in edge_set:\n                continue\n            \n            # The swap is valid and successful\n            # Update edge_set\n            edge_set.remove((u, v))\n            edge_set.remove((x, y))\n            edge_set.add(new_edge1)\n            edge_set.add(new_edge2)\n            \n            # Update edge_list for next random sampling\n            edge_list[idx1] = new_edge1\n            edge_list[idx2] = new_edge2\n\n            successful_swaps += 1\n\n        # Calculate post-rewiring GRC\n        post_grc = calculate_grc(N, list(edge_set))\n\n    # Calculate difference\n    diff_grc = post_grc - initial_grc\n\n    return initial_grc, post_grc, diff_grc\n\nsolve()\n```"
        },
        {
            "introduction": "一些最引人入胜的复杂系统表现出一种自相似或分形的层级结构，其模式在不同尺度上重复出现。本练习介绍了一种强大的计算方法——盒子覆盖法（Box-Covering），用于在没有先验层级知识的情况下检测这类涌现结构。通过计算网络的分形维数并评估其在不同尺度下的稳定性，我们可以识别自相似组织的特征，这是许多自然和技术层级系统的一个标志 ()。",
            "id": "4281053",
            "problem": "您的任务是，在无向、无权图上实现一个广义的箱覆盖程序，以通过分形（箱）维度的稳定性来研究层次自相似性。从以下基础出发：图的定义、最短路径距离的定义，以及分形网络的经验标度关系。目标是，对于多个箱半径，计算覆盖图所需的最小箱数，拟合箱标度指数，并判断该指数在不同尺度上是否稳定。\n\n定义和要求：\n- 设图表示为 $G = (V, E)$，其中 $V$ 是一个包含 $n$ 个节点的有限集合，$\\lvert V \\rvert = n$，$E \\subseteq \\{ \\{u,v\\} \\mid u,v \\in V, u \\neq v \\}$ 是一个无自环或多重边的无向边集。\n- 设 $d(u,v)$ 为节点 $u$ 和 $v$ 之间的最短路径距离，定义为在图 $G$ 中从 $u$ 到 $v$ 的任意简单路径上的最小边数。如果不存在路径，则距离定义为无穷大；然而，本文考虑的所有图都是连通的，因此所有成对距离都是有限的。\n- 对于整数半径 $r \\geq 1$，定义以节点 $c \\in V$ 为中心的半径为 $r$ 的箱为集合 $B_r(c) = \\{ v \\in V \\mid d(c,v) \\leq r \\}$。图的半径为 $r$ 的箱覆盖是任意一个箱族 $\\{ B_r(c_i) \\}_{i=1}^{N}$，使得 $\\bigcup_{i=1}^{N} B_r(c_i) = V$。半径为 $r$ 所需的最小箱数表示为 $N_B(r)$。\n- 当标度关系 $N_B(r) \\propto r^{-d_B}$ 在多个 $r$ 的尺度上近似有效时，箱（分形）维度 $d_B$ 在操作上由此定义。在实践中，指数 $d_B$ 通过对 $\\log N_B(r)$ 与 $\\log r$ 进行线性回归来估计，其中 $d_B$ 由斜率的负值给出。\n\n算法约束：\n- 对于一般图，计算精确的最小 $N_B(r)$ 在组合上是困难的。您必须实现一个基于“最大排除质量燃烧”逻辑的有原则的贪婪近似算法：迭代地选择能够在其半径 $r$ 内覆盖最多当前未覆盖节点的节点作为箱中心，将这些节点标记为已覆盖，并继续此过程直到所有节点都被覆盖。这个贪婪过程为每个 $r$ 定义了一个近似的 $N_B(r)$。\n- 使用从每个节点开始的广度优先搜索来计算所有节点对之间的最短路径距离 $d(u,v)$，以确保在无权图中的正确性。\n\n稳定性评估：\n- 对于给定的半径集合 $\\{ r_1, r_2, \\dots, r_m \\}$，其中 $r_i \\in \\mathbb{N}$ 且 $r_i \\geq 1$，计算所有 $i$ 的 $N_B(r_i)$。\n- 使用最小二乘法将直线 $y = a + b x$ 拟合到点 $(x_i, y_i)$，其中 $x_i = \\log r_i$，$y_i = \\log N_B(r_i)$。估计的箱维度为 $d_B = -b$。\n- 计算拟合的决定系数 $R^2$，其定义为 $R^2 = 1 - \\frac{\\sum_{i=1}^{m} (y_i - \\hat{y}_i)^2}{\\sum_{i=1}^{m} (y_i - \\bar{y})^2}$，其中 $\\hat{y}_i = a + b x_i$，$\\bar{y}$ 是 $y_i$ 值的平均值。\n- 定义连续尺度之间的局部斜率 $s_i = - \\frac{y_{i+1} - y_i}{x_{i+1} - x_i}$，其中 $i = 1, \\dots, m-1$。设 $\\mu_s$ 为 $\\{ s_i \\}$ 的平均值，$\\sigma_s$ 为其标准差。当 $\\mu_s  0$ 时，定义变异系数 $\\mathrm{CV} = \\sigma_s / \\mu_s$。\n- 当且仅当以下条件同时成立时，声明该估计是稳定分形的（解释为层次自相似性的证据）：(i) $m \\geq 3$，(ii) $\\mu_s  0$，(iii) $\\mathrm{CV} \\leq \\tau$，以及 (iv) $R^2 \\geq \\rho$。使用 $\\tau = 0.15$ 和 $\\rho = 0.90$。\n- 如果 $m  3$，您必须将稳定性判定设为假，因为无法在少于三个尺度上评估稳定性。\n\n您的程序必须实现以上内容，并为以下测试套件生成结果：\n\n测试套件：\n1. 方形晶格图：设 $G$ 是边长为 $s=6$ 的二维网格，有 $n=36$ 个节点，其中节点与其四个存在的曼哈顿邻居相连。使用半径 $\\{ r \\in \\mathbb{N} \\mid r \\in \\{ 1, 2, 3 \\} \\}$。\n2. 星形图：设 $G$ 是一个星形图，有一个中心节点和 $L=20$ 个叶节点，因此有 $n=21$ 个节点，其边为 $\\{ \\{0,i\\} \\mid i \\in \\{1, \\dots, 20\\} \\}$。使用半径 $\\{ r \\in \\mathbb{N} \\mid r \\in \\{ 1, 2 \\} \\}$。\n3. 平衡有根树：设 $G$ 是一棵有根树，分支因子为 $b=3$，高度为 $h=3$，共有 $n = 1 + 3 + 9 + 27 = 40$ 个节点，通过确定性地将 $\\ell$ 层的每个节点连接到 $\\ell+1$ 层的 $b$ 个子节点来构建，其中 $\\ell \\in \\{ 0,1,2 \\}$。使用半径 $\\{ r \\in \\mathbb{N} \\mid r \\in \\{ 1, 2, 3, 4 \\} \\}$。\n\n最终输出规范：\n- 对于每个测试用例，输出一个包含两个元素的列表 $[d_B, \\text{stable}]$，其中 $d_B$ 是一个四舍五入到四位小数的浮点数，$\\text{stable}$ 是一个布尔值，其文本形式为 $\\mathrm{True}$ 或 $\\mathrm{False}$。\n- 将三个用例的输出聚合到一个列表中，并以一行无空格的形式打印，格式必须为 $[[d_{B,1},\\mathrm{stable}_1],[d_{B,2},\\mathrm{stable}_2],[d_{B,3},\\mathrm{stable}_3]]$。\n- 不涉及物理单位。不使用角度。所有答案均为纯数值或布尔值。\n\n您的实现必须是一个完整、可运行的程序，该程序能够构建图、使用指定的贪婪算法计算 $N_B(r)$、通过对 $\\log$-$\\log$ 数据进行最小二乘法估计 $d_B$ 和 $R^2$、使用指定的阈值评估稳定性，并以所需的确切格式打印最终结果。",
            "solution": "任务是在图上实现一个广义的箱覆盖程序，通过分析分形维度的稳定性来评估层次自相似性。这涉及几个步骤：构建指定的图，计算所有节点对之间的最短路径，应用贪婪算法来近似计算不同半径 $r$ 下的最小箱数 $N_B(r)$，最后，对 $(r, N_B(r))$ 数据进行标度分析，以确定箱维度 $d_B$ 及其在不同尺度上的稳定性。\n\n首先，我们使用邻接表来表示图 $G=(V, E)$，这是一种用于稀疏图的标准且高效的数据结构。节点数表示为 $n = |V|$。我们需要函数来构建三种指定的图拓扑：\n1. 边长为 $s$ 的二维方形晶格，产生 $n = s^2$ 个节点。每个节点 $(i, j)$ 与其曼哈顿邻居 $(i \\pm 1, j)$ 和 $(i, j \\pm 1)$ 相连，前提是这些邻居在网格边界内。\n2. 一个星形图，有一个中心节点和 $L$ 个叶节点，总共有 $n = L+1$ 个节点。中心节点与所有叶节点相连，叶节点之间没有连接。\n3. 一个分支因子为 $b$、高度为 $h$ 的平衡有根树。节点总数为 $n = \\sum_{i=0}^{h} b^i = \\frac{b^{h+1}-1}{b-1}$。该图从第 $0$ 层的根节点开始，逐层构建。\n\n箱覆盖方法的基础是任意两个节点 $u, v \\in V$ 之间的最短路径距离 $d(u,v)$。由于图是无权的，最短路径距离就是连接节点的路径中的最小边数。在无权图中计算所有节点对之间的最短路径（APSP）最直接的方法是从图中的每个节点开始执行广度优先搜索（BFS）。对于每个源节点 $s$，BFS 逐层探索图，确保通过最短路径到达任何节点 $v$。从 $s$ 到所有其他节点的距离被存储起来。通过对所有 $n$ 个节点重复此操作作为源节点，我们填充一个 $n \\times n$ 的距离矩阵，其中存储了所有 $d(u,v)$ 的值。\n\n问题的核心是确定 $N_B(r)$，即覆盖图所需的半径为 $r$ 的箱的最小数量。箱 $B_r(c)$ 是距离中心节点 $c$ 不超过 $r$ 的所有节点的集合。找到精确的最小值等同于集合覆盖问题，这是一个 NP-hard 问题。因此，我们使用指定的贪婪近似算法：\n1. 将未覆盖节点集 $U$ 初始化为整个节点集 $V$。将箱数初始化为 $0$。\n2. 当 $U$ 不为空时：a. 增加箱数。b. 识别最优的箱中心 $c^* \\in V$，使其能覆盖的当前未覆盖节点数最大化，即 $c^* = \\arg\\max_{c \\in V} |B_r(c) \\cap U|$。c. 通过移除所选箱中包含的所有节点来更新未覆盖节点集：$U \\leftarrow U \\setminus B_r(c^*)$。\n3. 最终的箱数是该算法对 $N_B(r)$ 的估计。对指定集合 $\\{r_1, r_2, \\dots, r_m\\}$ 中的每个半径 $r$ 重复此过程。\n\n最后一步是标度分析。如果一个图在一系列尺度 $r$ 上表现出幂律标度关系 $N_B(r) \\propto r^{-d_B}$，则该图被认为是类分形的。对该关系取对数可得到一个线性方程：$\\log N_B(r) = C - d_B \\log r$，其中 C 是一个常数。我们可以通过对数据点 $(x_i, y_i) = (\\log r_i, \\log N_B(r_i))$ 进行线性最小二乘回归来估计箱维度 $d_B$。估计的维度 $d_B$ 是计算出的斜率的负值。\n\n使用两个指标来评估这种标度关系的稳定性。首先，决定系数 $R^2 = 1 - \\frac{\\sum (y_i - \\hat{y}_i)^2}{\\sum (y_i - \\bar{y})^2}$ 量化了线性拟合的优度。接近 $1$ 的 $R^2$ 值表明幂律模型能很好地描述数据。其次，我们通过计算局部斜率 $s_i = - \\frac{\\log N_B(r_{i+1}) - \\log N_B(r_i)}{\\log r_{i+1} - \\log r_i}$ 来分析标度指数在不同尺度上的一致性。如果标度关系是稳定的，这些局部斜率应该几乎是恒定的。我们使用变异系数 $\\mathrm{CV} = \\sigma_s / \\mu_s$ 来量化它们的变化，其中 $\\mu_s$ 和 $\\sigma_s$ 分别是局部斜率 $\\{s_i\\}$ 的平均值和标准差。低的 CV 值表示标度关系稳定。\n\n如果一个图在至少 $m \\geq 3$ 个尺度上进行测量，平均局部斜率 $\\mu_s$ 为正，拟合质量高（$R^2 \\geq \\rho=0.90$），且局部斜率变化低（$\\mathrm{CV} \\leq \\tau=0.15$），则声明该图具有稳定的分形维度。如果 $m  3$，稳定性评估没有意义，结果被定义为不稳定。\n实现将遵循这些原则，使用 `numpy` 进行高效的数值计算，如线性回归、均值和标准差。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom collections import deque\n\ndef create_square_lattice(s):\n    \"\"\"Creates an adjacency list for an s x s square lattice graph.\"\"\"\n    n = s * s\n    adj_list = [[] for _ in range(n)]\n    for i in range(s):\n        for j in range(s):\n            node_idx = i * s + j\n            if i  0:\n                adj_list[node_idx].append((i - 1) * s + j)\n            if i  s - 1:\n                adj_list[node_idx].append((i + 1) * s + j)\n            if j  0:\n                adj_list[node_idx].append(i * s + (j - 1))\n            if j  s - 1:\n                adj_list[node_idx].append(i * s + (j + 1))\n    return adj_list\n\ndef create_star_graph(L):\n    \"\"\"Creates an adjacency list for a star graph with L leaves.\"\"\"\n    n = L + 1\n    adj_list = [[] for _ in range(n)]\n    hub = 0\n    for leaf in range(1, n):\n        adj_list[hub].append(leaf)\n        adj_list[leaf].append(hub)\n    return adj_list\n\ndef create_balanced_tree(b, h):\n    \"\"\"Creates an adjacency list for a balanced rooted tree.\"\"\"\n    if b == 1:\n        n = h + 1\n    else:\n        n = (b**(h + 1) - 1) // (b - 1)\n\n    adj_list = [[] for _ in range(n)]\n    if n == 1:\n        return adj_list\n    \n    current_node = 1\n    parents = [0]\n    for _ in range(h):\n        next_parents = []\n        for p in parents:\n            for _ in range(b):\n                if current_node  n:\n                    adj_list[p].append(current_node)\n                    adj_list[current_node].append(p)\n                    next_parents.append(current_node)\n                    current_node += 1\n        parents = next_parents\n    return adj_list\n\ndef calculate_apsp(adj_list):\n    \"\"\"Calculates all-pairs shortest paths using BFS from each node.\"\"\"\n    n = len(adj_list)\n    dist_matrix = np.full((n, n), -1, dtype=int)\n    for i in range(n):\n        dist_matrix[i, i] = 0\n        q = deque([(i, 0)])\n        visited = {i}\n        while q:\n            u, d = q.popleft()\n            for v in adj_list[u]:\n                if v not in visited:\n                    visited.add(v)\n                    dist_matrix[i, v] = d + 1\n                    q.append((v, d + 1))\n    return dist_matrix\n\ndef compute_nb_greedy(dist_matrix, r):\n    \"\"\"Computes N_B(r) using the specified greedy algorithm.\"\"\"\n    n = dist_matrix.shape[0]\n    uncovered_nodes = set(range(n))\n    num_boxes = 0\n    \n    potential_covers = [\n        {v for v in range(n) if dist_matrix[c, v] = r} for c in range(n)\n    ]\n\n    while uncovered_nodes:\n        num_boxes += 1\n        best_center = -1\n        max_newly_covered_count = -1\n        \n        for c in range(n):\n            newly_covered_count = len(potential_covers[c].intersection(uncovered_nodes))\n            if newly_covered_count  max_newly_covered_count:\n                max_newly_covered_count = newly_covered_count\n                best_center = c\n        \n        if max_newly_covered_count == 0:\n            break\n            \n        nodes_in_chosen_box = potential_covers[best_center]\n        uncovered_nodes.difference_update(nodes_in_chosen_box)\n        \n    return num_boxes\n\ndef analyze_scaling(radii, nb_values):\n    \"\"\"Analyzes scaling to find d_B and stability.\"\"\"\n    m = len(radii)\n    tau = 0.15\n    rho = 0.90\n    \n    if m  3:\n        stable = False\n        if m  2:\n            db = 0.0\n        else: # m == 2\n            x = np.log(radii)\n            # This check is for safety, problem constraints should prevent it.\n            if np.isclose(x[1], x[0]): \n                db = 0.0\n                return db, stable\n            y = np.log(nb_values)\n            if np.isclose(y[1], y[0]):\n                db = 0.0\n            else:\n                b = (y[1] - y[0]) / (x[1] - x[0])\n                db = -b\n        return db, stable\n\n    x = np.log(radii)\n    y = np.log(nb_values)\n    \n    # Handle cases with no variation in N_B(r)\n    if np.allclose(y, y[0]):\n        return 0.0, False\n\n    b, a = np.polyfit(x, y, 1)\n    db = -b\n    \n    y_pred = b * x + a\n    ss_res = np.sum((y - y_pred)**2)\n    ss_tot = np.sum((y - np.mean(y))**2)\n    r_squared = 1 - (ss_res / ss_tot)\n        \n    local_slopes = -np.diff(y) / np.diff(x)\n    \n    mu_s = np.mean(local_slopes)\n    \n    if mu_s = 0 or len(local_slopes)  2:\n        return db, False\n        \n    # Use ddof=1 for sample standard deviation\n    sigma_s = np.std(local_slopes, ddof=1)\n    cv = sigma_s / mu_s\n    \n    stable = (mu_s  0) and (cv = tau) and (r_squared = rho)\n    \n    return db, stable\n\ndef solve():\n    test_suite = [\n        {'type': 'lattice', 'params': {'s': 6}, 'radii': [1, 2, 3]},\n        {'type': 'star', 'params': {'L': 20}, 'radii': [1, 2]},\n        {'type': 'tree', 'params': {'b': 3, 'h': 3}, 'radii': [1, 2, 3, 4]} \n    ]\n    \n    final_results = []\n    \n    for test in test_suite:\n        if test['type'] == 'lattice':\n            adj = create_square_lattice(**test['params'])\n        elif test['type'] == 'star':\n            adj = create_star_graph(**test['params'])\n        elif test['type'] == 'tree':\n            adj = create_balanced_tree(**test['params'])\n            \n        dist_matrix = calculate_apsp(adj)\n        \n        radii = test['radii']\n        nb_values = [compute_nb_greedy(dist_matrix, r) for r in radii]\n            \n        db, stable = analyze_scaling(radii, nb_values)\n        \n        final_results.append(f\"[{db:.4f},{str(stable)}]\")\n        \n    print(f\"[{','.join(final_results)}]\")\n\nsolve()\n```"
        }
    ]
}