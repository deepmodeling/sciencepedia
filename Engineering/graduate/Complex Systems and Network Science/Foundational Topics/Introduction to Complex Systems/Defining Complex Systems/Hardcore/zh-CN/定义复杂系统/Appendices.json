{
    "hands_on_practices": [
        {
            "introduction": "复杂系统通常具有多个稳定状态，这一特性被称为多稳态。即使是简单的一维非线性微分方程也能捕捉到这种现象，它揭示了非线性如何催生出质变性的新行为。本练习将通过分析一个典范系统的固定点及其稳定性，来理解系统如何在不同的长期结果之间做出“选择”，并引入势能景观的概念，这是理解更复杂系统中状态转换的有力工具。",
            "id": "4271109",
            "problem": "考虑一维常微分方程 (ODE) $\\frac{dx}{dt} = a x - b x^{3}$，其中 $a0$ 且 $b0$。使用动力学系统的基本定义，通过条件 $f(x^{\\ast})=0$（其中 $f(x)=a x - b x^{3}$）来定义不动点 $x^{\\ast}$，并通过一维情况下导数 $f'(x^{\\ast})$ 的符号来定义不动点的线性稳定性。在复杂系统中，双稳态指的是两个具有不同吸引盆的渐近稳定不动点共存，并由一个不稳定不动点分隔。从这些定义出发，并且不使用任何预先推导的快捷公式，请执行以下操作：\n- 确定系统的所有不动点，用 $a$ 和 $b$ 表示。\n- 对每个不动点附近的系统进行线性化，以确定其稳定性，从而在合适的正参数 $a$ 和 $b$ 条件下，证明双稳态的存在。\n- 通过识别一个标量势 $U(x)$ 使得 $\\frac{dx}{dt} = -\\frac{dU}{dx}$，将该系统解释为梯度流，并通过要求 $U(0)=0$ 来固定 $U(x)$ 的加法常数。\n- 将双稳态势垒高度定义为分隔吸引盆的不稳定不动点与任一稳定不动点之间的势能差。精确计算此势垒高度，用 $a$ 和 $b$ 表示。\n\n请以单个封闭形式的解析表达式提供最终答案。无需四舍五入。最终表达式中不包含任何单位。",
            "solution": "经评估，该问题陈述具有科学依据、问题设定良好、客观且内容自洽。它提出了一个动力学系统理论中的标准问题，没有任何明显的缺陷、矛盾或含糊之处。因此，我们可以着手求解。\n\n给定的一维常微分方程 (ODE) 为 $\\frac{dx}{dt} = f(x)$，其中 $f(x) = a x - b x^{3}$，参数 $a$ 和 $b$ 为正实数，即 $a0$ 且 $b0$。\n\n首先，我们通过求解方程 $f(x^{\\ast})=0$ 来确定不动点，记为 $x^{\\ast}$。\n$$a x^{\\ast} - b (x^{\\ast})^{3} = 0$$\n将 $x^{\\ast}$ 因子提出，我们得到：\n$$x^{\\ast} (a - b (x^{\\ast})^{2}) = 0$$\n由于 $a0$ 且 $b0$，该方程产生三个不同的实数解：\n1. $x^{\\ast}_{1} = 0$\n2. $a - b (x^{\\ast})^{2} = 0 \\implies (x^{\\ast})^{2} = \\frac{a}{b} \\implies x^{\\ast} = \\pm\\sqrt{\\frac{a}{b}}$\n\n因此，系统的三个不动点是 $x^{\\ast}_{1} = 0$、$x^{\\ast}_{2} = \\sqrt{\\frac{a}{b}}$ 和 $x^{\\ast}_{3} = -\\sqrt{\\frac{a}{b}}$。\n\n接下来，我们分析每个不动点的线性稳定性。稳定性由导数 $f'(x) = \\frac{df}{dx}$ 在不动点 $x^{\\ast}$ 处的值的符号决定。\n首先，我们计算 $f(x)$ 的导数：\n$$f'(x) = \\frac{d}{dx}(a x - b x^{3}) = a - 3 b x^{2}$$\n现在，我们在三个不动点处分别计算该导数的值：\n- 对于 $x^{\\ast}_{1} = 0$：\n  $$f'(0) = a - 3 b (0)^{2} = a$$\n  因为给定 $a0$，所以 $f'(0)0$。正导数表明该不动点是不稳定的。\n- 对于 $x^{\\ast}_{2} = \\sqrt{\\frac{a}{b}}$：\n  $$f'\\left(\\sqrt{\\frac{a}{b}}\\right) = a - 3 b \\left(\\sqrt{\\frac{a}{b}}\\right)^{2} = a - 3 b \\left(\\frac{a}{b}\\right) = a - 3a = -2a$$\n  因为给定 $a0$，所以 $f'(\\sqrt{\\frac{a}{b}}) = -2a  0$。负导数表明该不动点是渐近稳定的。\n- 对于 $x^{\\ast}_{3} = -\\sqrt{\\frac{a}{b}}$：\n  $$f'\\left(-\\sqrt{\\frac{a}{b}}\\right) = a - 3 b \\left(-\\sqrt{\\frac{a}{b}}\\right)^{2} = a - 3 b \\left(\\frac{a}{b}\\right) = a - 3a = -2a$$\n  同样，因为 $a0$，所以 $f'(-\\sqrt{\\frac{a}{b}}) = -2a  0$。该不动点也是渐近稳定的。\n\n该系统拥有两个稳定不动点 $x^{\\ast}_{2} = \\sqrt{\\frac{a}{b}}$ 和 $x^{\\ast}_{3} = -\\sqrt{\\frac{a}{b}}$，它们被一个不稳定不动点 $x^{\\ast}_{1} = 0$ 分隔。这证实了问题陈述中所定义的双稳态的存在。\n\n现在，我们通过找到一个势函数 $U(x)$ 使得 $\\frac{dx}{dt} = -\\frac{dU}{dx}$，将该系统解释为梯度流。\n我们将给定的动力学方程与此条件等同起来：\n$$a x - b x^{3} = -\\frac{dU}{dx}$$\n这意味着：\n$$\\frac{dU}{dx} = -a x + b x^{3}$$\n为了求出 $U(x)$，我们将 $\\frac{dU}{dx}$ 的表达式对 $x$ 进行积分：\n$$U(x) = \\int (-a x + b x^{3}) \\, dx = -a \\frac{x^{2}}{2} + b \\frac{x^{4}}{4} + C$$\n其中 $C$ 是积分常数。我们利用给定条件 $U(0)=0$ 来确定这个常数。\n$$U(0) = -a \\frac{0^{2}}{2} + b \\frac{0^{4}}{4} + C = 0 \\implies C = 0$$\n因此，势函数为：\n$$U(x) = -\\frac{a x^{2}}{2} + \\frac{b x^{4}}{4}$$\n稳定不动点对应于势函数 $U(x)$ 的局部极小值，而不稳定不动点对应于局部极大值。\n\n最后，我们计算双稳态势垒高度，它被定义为不稳定不动点与任一稳定不动点之间的势能差。令 $\\Delta U$ 表示此势垒高度。\n不稳定不动点是 $x^{\\ast}_{\\text{unstable}} = 0$。该点处的势为：\n$$U(x^{\\ast}_{\\text{unstable}}) = U(0) = 0$$\n稳定不动点是 $x^{\\ast}_{\\text{stable}} = \\pm\\sqrt{\\frac{a}{b}}$。由于势函数具有偶对称性 ($U(x) = U(-x)$)，在两个稳定点处的势值相同。我们以 $x = \\sqrt{\\frac{a}{b}}$ 为例进行计算：\n$$U\\left(\\sqrt{\\frac{a}{b}}\\right) = -\\frac{a}{2}\\left(\\sqrt{\\frac{a}{b}}\\right)^{2} + \\frac{b}{4}\\left(\\sqrt{\\frac{a}{b}}\\right)^{4}$$\n$$U\\left(\\sqrt{\\frac{a}{b}}\\right) = -\\frac{a}{2}\\left(\\frac{a}{b}\\right) + \\frac{b}{4}\\left(\\frac{a^{2}}{b^{2}}\\right)$$\n$$U\\left(\\sqrt{\\frac{a}{b}}\\right) = -\\frac{a^{2}}{2b} + \\frac{a^{2}}{4b} = -\\frac{2a^{2}}{4b} + \\frac{a^{2}}{4b} = -\\frac{a^{2}}{4b}$$\n势垒高度 $\\Delta U$ 是不稳定鞍点处的势与稳定极小值处的势之差：\n$$\\Delta U = U(x^{\\ast}_{\\text{unstable}}) - U(x^{\\ast}_{\\text{stable}})$$\n$$\\Delta U = U(0) - U\\left(\\sqrt{\\frac{a}{b}}\\right) = 0 - \\left(-\\frac{a^{2}}{4b}\\right) = \\frac{a^{2}}{4b}$$\n这就是所求的双稳态势垒高度。",
            "answer": "$$\n\\boxed{\\frac{a^{2}}{4b}}\n$$"
        },
        {
            "introduction": "复杂系统最著名的特征之一是混沌，即确定性规则可能导致看似随机和不可预测的行为。混沌的关键标志是对初始条件的敏感依赖性，这意味着微小的初始差异会随时间呈指数级增长，而这个发散率由李雅普诺夫指数 $\\lambda$ 来量化。本计算练习将让您通过实现逻辑斯蒂映射并计算其李雅普诺夫指数，亲手衡量混沌，从而具体理解如何从数值上识别和表征复杂性的一个决定性特征。",
            "id": "4271118",
            "problem": "你需要编写一个完整的程序，该程序估计一维逻辑斯谛映射的最大李雅普诺夫指数，并用它来解释作为复杂系统一个定义性特征的混沌的存在。逻辑斯谛映射是一个离散时间动力系统，由递推关系 $x_{t+1} = f_r(x_t)$ 给出，其中 $f_r(x) = r x (1 - x)$，$r \\in [0,4]$ 是一个实参数，$x_t \\in [0,1]$ 是在离散时间 $t \\in \\{0,1,2,\\dots\\}$ 的状态。对于一维映射，最大李雅普诺夫指数 $\\lambda$ 的基本定义是，在沿一条典型轨道的映射线性化作用下，一个无穷小扰动的长期增长率，即：\n$$\n\\lambda = \\lim_{n \\to \\infty} \\frac{1}{n} \\sum_{t=0}^{n-1} \\ln \\left| f_r'(x_t) \\right|,\n$$\n其中 $f_r'(x) = \\frac{d}{dx} f_r(x)$ 是导数。对于逻辑斯谛映射，$f_r'(x) = r(1-2x)$。$\\lambda$ 的符号决定了相邻轨道的指数发散或收敛：如果 $\\lambda  0$，则典型的相邻轨道会以指数级速度发散，表明对初始条件的敏感依赖性（混沌）；如果 $\\lambda  0$，轨道会收敛到一个稳定的周期轨道或不动点；如果 $\\lambda = 0$，系统处于分岔阈值。\n\n你的程序必须严格根据上述基本定义和逻辑斯谛映射的导数来实现以下任务：\n- 对于给定的参数 $r$、初始条件 $x_0 \\in (0,1)$、用于舍弃初始步骤的暂态长度 $n_{\\mathrm{trans}} \\in \\mathbb{N}$ 和测量长度 $n \\in \\mathbb{N}$，计算一个估计量\n$$\n\\hat{\\lambda}(r; x_0, n_{\\mathrm{trans}}, n) = \\frac{1}{n} \\sum_{t=n_{\\mathrm{trans}}}^{n_{\\mathrm{trans}} + n - 1} \\ln \\left( \\left| r \\left( 1 - 2 x_t \\right) \\right| + \\varepsilon \\right),\n$$\n其中 $\\varepsilon = 10^{-12}$ 是一个固定的数值保护措施，以避免对零取对数。状态序列 $\\{x_t\\}$ 是从 $x_0$ 开始通过迭代 $x_{t+1} = r x_t (1 - x_t)$ 生成的。\n- 通过返回一个由容差为 $\\tau = 10^{-4}$ 的决策规则定义的布尔值 $c$ 来解释混沌的存在：如果 $\\hat{\\lambda}  \\tau$，则设置 $c = \\mathrm{True}$，否则设置 $c = \\mathrm{False}$。该规则体现了这样一种解释，即严格为正的李雅普诺夫指数表示持续的敏感依赖性，并为有限时间估计误差设置了一个小的容差。\n\n使用以下参数值 $(r, x_0, n_{\\mathrm{trans}}, n)$ 的测试套件：\n- 情况 1：$r = 0.5$, $x_0 = 0.123456789$, $n_{\\mathrm{trans}} = 10000$, $n = 200000$。\n- 情况 2：$r = 2.5$, $x_0 = 0.123456789$, $n_{\\mathrm{trans}} = 10000$, $n = 200000$。\n- 情况 3：$r = 3.2$, $x_0 = 0.123456789$, $n_{\\mathrm{trans}} = 10000$, $n = 200000$。\n- 情况 4：$r = 3.5$, $x_0 = 0.123456789$, $n_{\\mathrm{trans}} = 10000$, $n = 200000$。\n- 情况 5：$r = 3.56995$, $x_0 = 0.123456789$, $n_{\\mathrm{trans}} = 10000$, $n = 200000$。\n- 情况 6：$r = 3.7$, $x_0 = 0.123456789$, $n_{\\mathrm{trans}} = 10000$, $n = 200000$。\n- 情况 7：$r = 3.83$, $x_0 = 0.123456789$, $n_{\\mathrm{trans}} = 10000$, $n = 200000$。\n- 情况 8：$r = 4.0$, $x_0 = 0.123456789$, $n_{\\mathrm{trans}} = 10000$, $n = 200000$。\n\n对于每种情况，计算由四舍五入后的李雅普诺夫估计值和混沌标志组成的数对。使用标准四舍五入规则将每个 $\\hat{\\lambda}$ 四舍五入到 $6$ 位小数。\n\n最终输出格式要求：\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，其中每个元素本身是一个 $[\\hat{\\lambda}, c]$ 形式的双元素列表。例如，三个案例的输出可能看起来像 $[[0.123456,\\mathrm{True}],[-0.000789,\\mathrm{False}],[0.693147,\\mathrm{True}]]$。\n- 除了所要求的单行之外，不允许有任何额外的文本或空白。\n- 此问题不涉及任何物理单位。",
            "solution": "问题陈述经评估有效。它在科学上基于动力系统和混沌的成熟理论，特别是关于逻辑斯谛映射，这是该领域的一个典型模型。该问题是适定的，为获得唯一的数值解提供了所需的一套完整且明确的定义、方程和参数。其语言是客观且数学上精确的。所提供的估计李雅普诺夫指数的方法是一种标准的数值技术。\n\n解决方案将首先通过实现一个函数来模拟逻辑斯谛映射并计算定义的最大李雅普诺夫指数估计量 $\\hat{\\lambda}$ 来开发。随后将应用指定的决策规则将动力学行为分类为混沌或非混沌。\n\n逻辑斯谛映射是一个离散时间动力系统，由以下递推关系描述：\n$$\nx_{t+1} = f_r(x_t) = r x_t (1 - x_t)\n$$\n其中 $x_t \\in [0,1]$ 是系统在时间步 $t$ 的状态，$r \\in [0,4]$ 是一个控制参数。\n\n最大李雅普诺夫指数 $\\lambda$ 量化了相邻轨道发散或收敛的平均指数率。正指数 $\\lambda  0$ 是混沌的一个定义性特征，表明对初始条件的敏感依赖性。其形式化定义如下：\n$$\n\\lambda = \\lim_{n \\to \\infty} \\frac{1}{n} \\sum_{t=0}^{n-1} \\ln \\left| f_r'(x_t) \\right|\n$$\n其中 $f_r'(x)$ 是映射函数的导数。对于逻辑斯谛映射，该导数为 $f_r'(x) = r(1-2x)$。项 $\\ln |f_r'(x_t)|$ 表示在状态 $x_t$ 处无穷小扰动的局部（或瞬时）对数扩张或收缩率。李雅普诺夫指数是这些局部速率在一条典型轨道上的长期平均值。\n\n对于给定的参数集 $(r, x_0, n_{\\mathrm{trans}}, n)$，估计 $\\lambda$ 的算法步骤如下：\n\n1.  **初始化**：从初始条件 $x_0$ 开始。\n\n2.  **暂态舍弃**：将映射迭代 $n_{\\mathrm{trans}}$ 步。状态 $x_t$ 根据 $x_{t+1} = r x_t (1 - x_t)$ 进行更新，其中 $t = 0, 1, \\dots, n_{\\mathrm{trans}}-1$。这个初始阶段让系统的轨道稳定到其吸引子上（例如，不动点、周期轨道或奇异吸引子）。通过舍弃这些暂态，后续对 $\\lambda$ 的计算反映了吸引子的内禀动力学，且与 $x_0$ 的具体选择无关（不包括测度为零的初始条件集合）。\n\n3.  **李雅普诺夫求和**：在暂态阶段之后，再执行 $n$ 次迭代。在此测量阶段，对于从 $n_{\\mathrm{trans}}$ 到 $n_{\\mathrm{trans}} + n - 1$ 的每一步 $t$，计算导数项 $f_r'(x_t) = r(1-2x_t)$ 并累加其对数量值的和。问题指定使用求和来计算估计量 $\\hat{\\lambda}$：\n    $$\n    S = \\sum_{t=n_{\\mathrm{trans}}}^{n_{\\mathrm{trans}} + n - 1} \\ln \\left( \\left| r \\left( 1 - 2 x_t \\right) \\right| + \\varepsilon \\right)\n    $$\n    小常数 $\\varepsilon = 10^{-12}$ 是一个数值保护措施，用于防止因 `log(0)` 而产生的错误，这种情况会在轨道点 $x_t$ 恰好等于临界点 $x_c = 0.5$（此时 $f_r'(0.5) = 0$）时发生。计算完局部项后，将状态更新为 $x_{t+1}$ 以进行下一次迭代。\n\n4.  **求平均**：估计量 $\\hat{\\lambda}$ 是在 $n$ 个测量步骤中累加总和的平均值：\n    $$\n    \\hat{\\lambda} = \\frac{S}{n}\n    $$\n    这个值是真实李雅普诺夫指数 $\\lambda$ 的一个近似。随着 $n \\to \\infty$，近似的质量会提高。\n\n5.  **混沌分类**：李雅普诺夫指数的符号决定了系统的稳定性。问题定义了一个决策规则来对动力学行为进行分类，使用容差 $\\tau = 10^{-4}$ 来考虑有限时间数值估计误差，尤其是在 $\\lambda$ 可能接近于零的分岔点附近。用于表示混沌的布尔标志 $c$ 按如下方式确定：\n    $$\n    c = \\begin{cases} \\mathrm{True}  \\text{if } \\hat{\\lambda}  \\tau \\\\ \\mathrm{False}  \\text{if } \\hat{\\lambda} \\le \\tau \\end{cases}\n    $$\n    $c = \\mathrm{True}$ 的值表示系统表现出对初始条件的敏感依赖性（混沌），而 $c = \\mathrm{False}$ 表示非混沌行为（收敛到稳定的不动点或周期轨道）。\n\n最后，为了报告目的，计算出的估计量 $\\hat{\\lambda}$ 将四舍五入到 $6$ 位小数。程序将对每个指定的测试案例执行此过程，并将结果格式化为 $[\\hat{\\lambda}_{\\text{rounded}}, c]$ 形式的数对列表。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the largest Lyapunov exponent for the logistic map for a suite of\n    test cases and classifies the dynamics as chaotic or not.\n    \"\"\"\n\n    test_cases = [\n        # (r, x0, n_trans, n)\n        (0.5, 0.123456789, 10000, 200000),\n        (2.5, 0.123456789, 10000, 200000),\n        (3.2, 0.123456789, 10000, 200000),\n        (3.5, 0.123456789, 10000, 200000),\n        (3.56995, 0.123456789, 10000, 200000),\n        (3.7, 0.123456789, 10000, 200000),\n        (3.83, 0.123456789, 10000, 200000),\n        (4.0, 0.123456789, 10000, 200000),\n    ]\n\n    # Constants defined in the problem\n    epsilon = 1e-12\n    tau = 1e-4\n\n    results = []\n    \n    for r, x0, n_trans, n in test_cases:\n        # Initial state\n        x = x0\n\n        # Discard transient iterations to let the trajectory settle on the attractor\n        for _ in range(n_trans):\n            x = r * x * (1.0 - x)\n\n        # Measurement phase: compute the sum for the Lyapunov exponent\n        lyapunov_sum = 0.0\n        for _ in range(n):\n            # The derivative of the logistic map is f'(x) = r*(1-2x)\n            derivative = r * (1.0 - 2.0 * x)\n            # Add the local contribution to the sum, with a numerical safeguard\n            lyapunov_sum += np.log(np.abs(derivative) + epsilon)\n            # Iterate the map to the next state\n            x = r * x * (1.0 - x)\n\n        # Compute the estimator for the Lyapunov exponent\n        lambda_hat = lyapunov_sum / n\n\n        # Round the result to 6 decimal places for output\n        rounded_lambda = round(lambda_hat, 6)\n\n        # Apply the decision rule to classify chaos\n        is_chaotic = lambda_hat  tau\n        \n        results.append([rounded_lambda, is_chaotic])\n\n    # Format the final output according to the specified format\n    # The str() representation of a Python list and boolean matches the required format.\n    output_string = f\"[{','.join(map(str, results))}]\"\n    \n    print(output_string)\n\nsolve()\n```"
        },
        {
            "introduction": "许多复杂系统，从社会系统到生物通路，都可以被最恰当地描述为由相互作用的组件构成的网络。这些网络很少是随机的，而是具有涌现的结构模式，其中最重要的一种是社群结构。本练习将挑战您探索这种层级结构，通过构建一个合成网络并应用分辨率参数模块度 $Q_{\\gamma}$，您将学习社群发现算法如何揭示复杂网络中存在的不同组织尺度，这是网络科学中的一项关键技能。",
            "id": "4271079",
            "problem": "您的任务是构建一个具有嵌套模块和超模块的层次化加权网络，然后评估分辨率参数模块度以识别稳定的社群尺度。该网络应以确定性的方式构建，以确保结果是可复现且无歧义的。\n\n定义与约束：\n- 设网络有 $n$ 个节点，排列成 $S$ 个超模块。每个超模块包含 $M$ 个模块，每个模块包含 $N$ 个节点，因此 $n = S \\times M \\times N$。\n- 定义一个无向无自环网络的加权邻接矩阵 $A \\in \\mathbb{R}^{n \\times n}$。对于两个不同的节点 $i \\neq j$：\n  - 如果节点 $i$ 和 $j$ 位于同一模块中，则设置 $A_{ij} = p_{\\mathrm{in}}$。\n  - 如果节点 $i$ 和 $j$ 位于不同模块但属于同一超模块，则设置 $A_{ij} = p_{\\mathrm{mid}}$。\n  - 否则（如果节点 $i$ 和 $j$ 位于不同的超模块中），则设置 $A_{ij} = p_{\\mathrm{out}}$。\n  - 对所有 $i$ 设置 $A_{ii} = 0$。\n- 节点 $i$ 的度（强度）为 $k_i = \\sum_{j=1}^n A_{ij}$。总边权为 $2m = \\sum_{i=1}^n \\sum_{j=1}^n A_{ij}$，因此 $m = \\frac{1}{2}\\sum_{i=1}^n \\sum_{j=1}^n A_{ij}$。\n- 使用配置模型零期望 $P_{ij} = \\frac{k_i k_j}{2m}$。\n- 对于给定的划分 $\\mathcal{P}$ 和分辨率参数 $\\gamma  0$，定义分辨率模块度\n  $$Q_{\\gamma}(\\mathcal{P}) = \\frac{1}{2m} \\sum_{i=1}^n \\sum_{j=1}^n \\left( A_{ij} - \\gamma \\frac{k_i k_j}{2m} \\right) \\delta\\big( c_i, c_j \\big),$$\n  其中 $c_i$ 是节点 $i$ 在划分 $\\mathcal{P}$ 中的社群标签，$\\delta(\\cdot,\\cdot)$ 是克罗内克δ函数。\n- 仅考虑以下四个候选划分：\n  - $\\mathcal{P}_0$：所有节点位于单个社群中（编码为标签 $0$）。\n  - $\\mathcal{P}_1$：社群是 $S$ 个超模块（编码为标签 $1$）。\n  - $\\mathcal{P}_2$：社群是所有 $S \\times M$ 个模块（编码为标签 $2$）。\n  - $\\mathcal{P}_3$：每个节点自成一个社群（编码为标签 $3$）。\n- 对于每个分辨率参数值 $\\gamma$，从 $\\{\\mathcal{P}_0,\\mathcal{P}_1,\\mathcal{P}_2,\\mathcal{P}_3\\}$ 中选择使 $Q_{\\gamma}$ 最大化的划分。如果出现平局，选择标签索引最小的划分以确保确定性行为。\n\n任务要求：\n- 实现一个程序，对于下方的每个测试用例，按规定构建 $A$，计算每个 $\\gamma$ 和每个 $\\ell \\in \\{0,1,2,3\\}$ 的 $Q_{\\gamma}(\\mathcal{P}_\\ell)$，并记录在平局决胜规则下实现最大模块度的划分索引 $\\ell$。\n- 通过将不同 $\\gamma$ 值下的获胜划分标签序列压缩为连续的相同标签段，来识别稳定的社群尺度，并报告每个连续段的运行长度（即网格点的计数）。\n\n测试套件：\n为了覆盖典型、近简并和边界场景，请使用以下测试用例。下方所有数字必须精确使用。\n1. 具有清晰分离的理想层次结构：\n   - $S = 3$, $M = 2$, $N = 8$,\n   - $p_{\\mathrm{in}} = 0.9$, $p_{\\mathrm{mid}} = 0.3$, $p_{\\mathrm{out}} = 0.05$,\n   - $\\gamma$ 网格: $\\{0.5, 1.0, 1.5, 2.0, 3.0\\}$。\n2. 弱分离层次结构（近简并）：\n   - $S = 2$, $M = 3$, $N = 6$,\n   - $p_{\\mathrm{in}} = 0.4$, $p_{\\mathrm{mid}} = 0.35$, $p_{\\mathrm{out}} = 0.3$,\n   - $\\gamma$ 网格: $\\{0.5, 1.0, 1.2, 1.5\\}$。\n3. 单个超模块的边界情况：\n   - $S = 1$, $M = 4$, $N = 5$,\n   - $p_{\\mathrm{in}} = 0.6$, $p_{\\mathrm{mid}} = 0.2$, $p_{\\mathrm{out}} = 0.0$,\n   - $\\gamma$ 网格: $\\{0.3, 0.8, 1.4, 2.2, 3.5\\}$。\n\n最终输出格式：\n- 对于每个测试用例，生成一个包含两个列表的列表：\n  - 第一个列表是按顺序排列的、在给定 $\\gamma$ 网格上的获胜划分标签。\n  - 第二个列表包含连续的相同获胜标签段的长度（为正整数）。\n- 您的程序应生成单行输出，其中包含三个测试用例的结果，格式为用方括号括起来的逗号分隔列表，不含空格。例如：\n  $$[\\,[\\,[\\ell_{1,1},\\ldots,\\ell_{1,k_1}],\\,[r_{1,1},\\ldots,r_{1,s_1}]\\,],\\,[\\,[\\ell_{2,1},\\ldots,\\ell_{2,k_2}],\\,[r_{2,1},\\ldots,r_{2,s_2}]\\,],\\,[\\,[\\ell_{3,1},\\ldots,\\ell_{3,k_3}],\\,[r_{3,1},\\ldots,r_{3,s_3}]\\,]\\,]$$\n  其中 $\\ell_{t,\\cdot}$ 是 $\\{0,1,2,3\\}$ 中的整数，而 $r_{t,\\cdot}$ 是正整数，$t \\in \\{1,2,3\\}$。",
            "solution": "该问题要求在一个确定性构建的层次化加权网络中分析其社群结构。分析将通过为一组固定的四个候选划分计算分辨率参数模块度 $Q_{\\gamma}$，并确定在不同分辨率参数 $\\gamma$ 值下哪个划分是最优的来执行。\n\n该问题在科学上是适定的，提供了所有必要的定义和参数。该网络是一个层次化随机分块模型，块内权重统一，是网络科学中的一个标准基准。模块度函数 $Q_{\\gamma}$ 是社群检测的传统工具。该任务是这些概念的直接应用。\n\n首先，我们确定网络的关键属性。网络有 $n = S \\times M \\times N$ 个节点，其中 $S$ 是超模块的数量，$M$ 是每个超模块中模块的数量，$N$ 是每个模块中节点的数量。加权邻接矩阵 $A$ 由三个参数定义：$p_{\\mathrm{in}}$、$p_{\\mathrm{mid}}$ 和 $p_{\\mathrm{out}}$。\n\n网络构建的高度对称性带来了一个关键的简化。每个节点在结构上都与其他任何节点等效。所有节点具有相同的度（强度），我们记为 $k$。我们可以通过对任意节点的连接权重求和来计算 $k$：\n- 与同一模块中其他 $(N-1)$ 个节点的连接：$(N-1) p_{\\mathrm{in}}$。\n- 与同一超模块内其他模块中 $N(M-1)$ 个节点的连接：$N(M-1) p_{\\mathrm{mid}}$。\n- 与其他超模块中 $NM(S-1)$ 个节点的连接：$NM(S-1) p_{\\mathrm{out}}$。\n\n将这些贡献相加，得到每个节点的度 $k$：\n$$k = (N-1) p_{\\mathrm{in}} + N(M-1) p_{\\mathrm{mid}} + N M (S-1) p_{\\mathrm{out}}$$\n网络中的总边权 $2m$ 是所有节点度的总和，因此 $2m = \\sum_{i=1}^n k_i = n k$。\n由于所有节点的度都相等 ($k_i = k$)，零模型项 $\\frac{k_i k_j}{2m}$ 简化为 $\\frac{k^2}{nk} = \\frac{k}{n}$。\n\n对于一个划分 $\\mathcal{P}$，其分辨率模块度由下式给出：\n$$Q_{\\gamma}(\\mathcal{P}) = \\frac{1}{2m} \\sum_{i,j} \\left( A_{ij} - \\gamma \\frac{k_i k_j}{2m} \\right) \\delta(c_i, c_j)$$\n其中 $c_i$ 是节点 $i$ 的社群。这可以重写为对划分 $\\mathcal{P}$ 中所有社群 $c$ 的求和：\n$$Q_{\\gamma}(\\mathcal{P}) = \\sum_{c \\in \\mathcal{P}} \\left( \\frac{L_c}{m} - \\gamma \\left( \\frac{K_c}{2m} \\right)^2 \\right)$$\n其中 $L_c = \\frac{1}{2} \\sum_{i,j \\in c} A_{ij}$ 是社群 $c$ 内部边的总权重，而 $K_c = \\sum_{i \\in c} k_i$ 是社群 $c$ 中节点度的总和。\n\n我们现在可以推导出四个候选划分的模块度的闭式表达式，而无需显式构建矩阵 $A$。\n\n**1. 划分 $\\mathcal{P}_0$：所有节点在一个社群中。**\n只有一个社群，包含所有 $n$ 个节点。\n$K_0 = \\sum_{i=1}^n k = nk = 2m$。\n$L_0$ 是所有边权总和的一半，即 $m$。\n$$Q_{\\gamma}(\\mathcal{P}_0) = \\frac{m}{m} - \\gamma \\left( \\frac{2m}{2m} \\right)^2 = 1 - \\gamma$$\n\n**2. 划分 $\\mathcal{P}_1$：社群是 $S$ 个超模块。**\n有 $S$ 个相同的社群，每个大小为 $MN$。对于其中一个社群 $c$：\n$K_c = (MN)k$。\n$L_c$ 是一个超模块内部的权重总和。它包括其 $M$ 个模块内部的权重以及这些模块之间的权重。\n$L_c = M \\left( \\binom{N}{2} p_{\\mathrm{in}} \\right) + \\binom{M}{2} N^2 p_{\\mathrm{mid}} = \\frac{M N(N-1)}{2} p_{\\mathrm{in}} + \\frac{M(M-1)N^2}{2} p_{\\mathrm{mid}}$。\n总模块度是一个超模块模块度的 $S$ 倍：\n$$Q_{\\gamma}(\\mathcal{P}_1) = S \\left( \\frac{L_c}{m} - \\gamma \\left( \\frac{K_c}{2m} \\right)^2 \\right) = S \\left( \\frac{L_c}{nk/2} - \\gamma \\left( \\frac{MNk}{nk} \\right)^2 \\right)$$\n$$Q_{\\gamma}(\\mathcal{P}_1) = \\frac{2S L_c}{SMNk} - S \\gamma \\left( \\frac{1}{S} \\right)^2 = \\frac{2 L_c}{MNk} - \\frac{\\gamma}{S}$$\n代入 $L_c$ 并化简得：\n$$Q_{\\gamma}(\\mathcal{P}_1) = \\frac{(N-1) p_{\\mathrm{in}} + N(M-1) p_{\\mathrm{mid}}}{k} - \\frac{\\gamma}{S}$$\n在 $S=1$ 的情况下，此式正确地简化为 $1-\\gamma$，与 $Q_{\\gamma}(\\mathcal{P}_0)$ 相匹配。\n\n**3. 划分 $\\mathcal{P}_2$：社群是 $S \\times M$ 个模块。**\n有 $SM$ 个相同的社群，每个大小为 $N$。对于其中一个社群 $c$：\n$K_c = Nk$。\n$L_c$ 是一个模块内部的权重总和：$L_c = \\binom{N}{2} p_{\\mathrm{in}} = \\frac{N(N-1)}{2} p_{\\mathrm{in}}$。\n总模块度是一个模块模块度的 $SM$ 倍：\n$$Q_{\\gamma}(\\mathcal{P}_2) = SM \\left( \\frac{L_c}{m} - \\gamma \\left( \\frac{K_c}{2m} \\right)^2 \\right) = SM \\left( \\frac{N(N-1)p_{\\mathrm{in}}/2}{nk/2} - \\gamma \\left( \\frac{Nk}{nk} \\right)^2 \\right)$$\n$$Q_{\\gamma}(\\mathcal{P}_2) = \\frac{SM N(N-1)p_{\\mathrm{in}}}{SMNk} - SM \\gamma \\left( \\frac{1}{SM} \\right)^2 = \\frac{(N-1)p_{\\mathrm{in}}}{k} - \\frac{\\gamma}{SM}$$\n\n**4. 划分 $\\mathcal{P}_3$：每个节点自成一个社群。**\n有 $n$ 个社群，每个大小为 $1$。对于任何一个这样的社群 $c$：\n$K_c = k$。\n$L_c = 0$，因为没有自环 ($A_{ii}=0$)。\n总模块度是所有 $n$ 个社群的总和：\n$$Q_{\\gamma}(\\mathcal{P}_3) = n \\left( \\frac{0}{m} - \\gamma \\left( \\frac{k}{2m} \\right)^2 \\right) = -n \\gamma \\left( \\frac{k}{nk} \\right)^2 = -n \\gamma \\frac{1}{n^2} = -\\frac{\\gamma}{n}$$\n\n算法流程如下：对于每个测试用例，我们首先计算常数 $k$。然后，对于每个指定的 $\\gamma$ 值，我们使用推导出的公式计算四个模块度值。获胜的划分是具有最大 $Q_{\\gamma}$ 值的那个，平局则通过选择索引最小的划分（$\\ell=0,1,2,3$）来解决。此过程产生一个获胜划分标签的序列。最后，该序列被压缩成一个连续相同标签的运行长度列表。\n示例：对于 $S=1$（测试用例3），$\\mathcal{P}_0$ 和 $\\mathcal{P}_1$ 是相同的划分。我们的公式得出 $Q_{\\gamma}(\\mathcal{P}_0) = Q_{\\gamma}(\\mathcal{P}_1) = 1-\\gamma$。指定的平局决胜规则（选择最小的标签索引）确保了选择 $\\mathcal{P}_0$（标签0）而不是 $\\mathcal{P}_1$（标签1），从而提供了一个确定性的结果。\n这种解析方法计算效率高，并避免了大型矩阵求和可能带来的浮点不精确性。",
            "answer": "```python\nimport numpy as np\nfrom itertools import groupby\n\ndef solve():\n    \"\"\"\n    Solves the hierarchical network modularity problem for the given test cases.\n    \"\"\"\n    test_cases = [\n        {'S': 3, 'M': 2, 'N': 8, 'p_in': 0.9, 'p_mid': 0.3, 'p_out': 0.05,\n         'gamma_grid': [0.5, 1.0, 1.5, 2.0, 3.0]},\n        {'S': 2, 'M': 3, 'N': 6, 'p_in': 0.4, 'p_mid': 0.35, 'p_out': 0.3,\n         'gamma_grid': [0.5, 1.0, 1.2, 1.5]},\n        {'S': 1, 'M': 4, 'N': 5, 'p_in': 0.6, 'p_mid': 0.2, 'p_out': 0.0,\n         'gamma_grid': [0.3, 0.8, 1.4, 2.2, 3.5]},\n    ]\n    \n    all_results = []\n\n    for case in test_cases:\n        S, M, N = case['S'], case['M'], case['N']\n        p_in, p_mid, p_out = case['p_in'], case['p_mid'], case['p_out']\n        gamma_grid = case['gamma_grid']\n        \n        n = S * M * N\n\n        # Calculate the degree k for any node. Due to symmetry, all nodes have the same degree.\n        # This avoids building the full adjacency matrix.\n        k = (N - 1) * p_in + N * (M - 1) * p_mid + N * M * (S - 1) * p_out\n\n        if k == 0:\n            # Handle the trivial case of a network with no edges to avoid division by zero.\n            # For the given test cases, k will always be positive.\n            # The modularities would all be 0 in this case. The winner would be partition 0.\n            winning_labels = [0] * len(gamma_grid)\n        else:\n            winning_labels = []\n            for gamma in gamma_grid:\n                # Calculate modularity Q for each of the four partitions\n                # using the derived analytical formulas.\n                \n                # Q_gamma(P_0): All nodes in one community\n                q0 = 1.0 - gamma\n                \n                # Q_gamma(P_1): Communities are super-modules\n                # If S=1, P_1 is identical to P_0. \n                # The formula automatically handles this.\n                q1_num = (N - 1) * p_in + N * (M - 1) * p_mid\n                q1 = q1_num / k - gamma / S\n                \n                # Q_gamma(P_2): Communities are modules\n                q2_num = (N - 1) * p_in\n                q2 = q2_num / k - gamma / (S * M)\n                \n                # Q_gamma(P_3): Each node is its own community\n                q3 = -gamma / n\n                \n                modularity_values = [q0, q1, q2, q3]\n                \n                # Find the maximum modularity and the winning partition index.\n                # The tie-breaking rule (choose smallest index) is handled by np.argmax.\n                max_q = np.max(modularity_values)\n                # Use a small tolerance for floating point comparisons to find all maxima\n                winner = np.where(np.isclose(modularity_values, max_q))[0][0]\n                winning_labels.append(winner)\n\n        # Calculate the lengths of contiguous runs of identical winning labels\n        if not winning_labels:\n            run_lengths = []\n        else:\n            run_lengths = [len(list(g)) for k, g in groupby(winning_labels)]\n        \n        all_results.append([winning_labels, run_lengths])\n\n    # Format the final output string as per the problem specification.\n    # We manually construct the string to avoid spaces introduced by standard list-to-string conversions.\n    result_strings = []\n    for labels, runs in all_results:\n        labels_str = f\"[{','.join(map(str, labels))}]\"\n        runs_str = f\"[{','.join(map(str, runs))}]\"\n        result_strings.append(f\"[{labels_str},{runs_str}]\")\n        \n    final_output = f\"[{','.join(result_strings)}]\"\n    print(final_output)\n\nsolve()\n\n```"
        }
    ]
}