{
    "hands_on_practices": [
        {
            "introduction": "This exercise grounds our study in the most fundamental property of any undirected graph: the handshaking lemma. By deriving the relationship between the sum of degrees, the number of nodes $n$, and the number of edges $m$, you will solidify your understanding of how local properties (node degrees) constrain a global property (the total number of connections). Applying this principle to calculate the number of edges from a given degree sequence  is a foundational skill for any network scientist.",
            "id": "4293371",
            "problem": "Consider an undirected simple graph with $n$ nodes and $m$ edges. Let $A$ denote its adjacency matrix, which by definition is an $n \\times n$ symmetric matrix with entries $a_{ij} \\in \\{0,1\\}$ and $a_{ii} = 0$, where $a_{ij} = 1$ if and only if there is an edge between node $i$ and node $j$. The degree of node $i$, denoted $d_i$, is defined as the total number of neighbors of node $i$, equivalently $d_i = \\sum_{j=1}^{n} a_{ij}$. The degree sequence is the list $(d_1, d_2, \\ldots, d_n)$, and the average degree is $\\langle k \\rangle = \\frac{1}{n} \\sum_{i=1}^{n} d_i$.\n\nStarting from these core definitions, derive a closed-form expression that relates the average degree $\\langle k \\rangle$ to the number of edges $m$ and the number of nodes $n$ in any undirected simple graph. Then, use this relationship to compute the number of edges $m$ for a graph on $n = 10$ nodes whose degree sequence is $(5, 5, 4, 4, 3, 3, 2, 2, 2, 2)$. If needed, you may assume this degree sequence is realizable by an undirected simple graph.\n\nYour final answer must be the single integer value of $m$. No rounding is required, and no units are involved.",
            "solution": "The problem asks for two things: first, to derive a relationship between the average degree $\\langle k \\rangle$, the number of edges $m$, and the number of nodes $n$ in an undirected simple graph; second, to use this relationship to find the number of edges for a graph with a given number of nodes and a specific degree sequence.\n\nLet us begin with the first part. We are given an undirected simple graph with $n$ nodes and $m$ edges. The degree of a node $i$, denoted $d_i$, is the number of edges connected to it. The sum of the degrees of all nodes in the graph is given by the expression $\\sum_{i=1}^{n} d_i$.\n\nBy definition, each edge connects exactly two nodes. Therefore, when we sum the degrees of all nodes, each edge is counted exactly twice: once for each of the two nodes it is incident upon. This fundamental principle of graph theory is known as the handshaking lemma. It establishes a direct relationship between the sum of degrees and the number of edges. Mathematically, this is expressed as:\n$$ \\sum_{i=1}^{n} d_i = 2m $$\n\nAlternatively, we can derive this from the given definition of the adjacency matrix $A$. The degree of node $i$ is defined as $d_i = \\sum_{j=1}^{n} a_{ij}$. The sum of all degrees is then:\n$$ \\sum_{i=1}^{n} d_i = \\sum_{i=1}^{n} \\left( \\sum_{j=1}^{n} a_{ij} \\right) $$\nThis double summation represents the sum of all elements in the $n \\times n$ adjacency matrix $A$. For an undirected graph, the adjacency matrix is symmetric, meaning $a_{ij} = a_{ji}$. An edge between node $i$ and node $j$ corresponds to two non-zero entries in the matrix, $a_{ij} = 1$ and $a_{ji} = 1$. Since the graph is simple, there are no self-loops, so all diagonal elements $a_{ii}$ are $0$. Consequently, the total sum of the entries in the adjacency matrix is equal to twice the number of edges, as each edge is represented by two '1's. Thus, we have:\n$$ \\sum_{i=1}^{n} \\sum_{j=1}^{n} a_{ij} = 2m $$\nThis confirms the handshaking lemma: $\\sum_{i=1}^{n} d_i = 2m$.\n\nNext, we use the definition of the average degree, $\\langle k \\rangle$, which is given as the mean of the degrees of all nodes:\n$$ \\langle k \\rangle = \\frac{1}{n} \\sum_{i=1}^{n} d_i $$\nSubstituting the result from the handshaking lemma into this definition, we obtain the required closed-form expression:\n$$ \\langle k \\rangle = \\frac{2m}{n} $$\nThis expression relates the average degree $\\langle k \\rangle$ to the number of edges $m$ and the number of nodes $n$.\n\nFor the second part of the problem, we are given a graph with $n = 10$ nodes and the degree sequence $(5, 5, 4, 4, 3, 3, 2, 2, 2, 2)$. We are asked to compute the number of edges $m$. The problem states that we may assume this degree sequence is realizable by an undirected simple graph.\n\nTo find $m$, we can rearrange the handshaking lemma:\n$$ m = \\frac{1}{2} \\sum_{i=1}^{n} d_i $$\nFirst, we must calculate the sum of the degrees from the given sequence:\n$$ \\sum_{i=1}^{10} d_i = 5 + 5 + 4 + 4 + 3 + 3 + 2 + 2 + 2 + 2 $$\n$$ \\sum_{i=1}^{10} d_i = (2 \\times 5) + (2 \\times 4) + (2 \\times 3) + (4 \\times 2) $$\n$$ \\sum_{i=1}^{10} d_i = 10 + 8 + 6 + 8 $$\n$$ \\sum_{i=1}^{10} d_i = 32 $$\nThe sum of the degrees is $32$. Note that this sum is an even number, which is a necessary condition for any degree sequence of an undirected graph.\n\nNow, we can substitute this sum into the formula for $m$:\n$$ m = \\frac{1}{2} \\times 32 $$\n$$ m = 16 $$\nTherefore, the number of edges in the graph is $16$.",
            "answer": "$$\n\\boxed{16}\n$$"
        },
        {
            "introduction": "While the degree sequence provides a valuable first-order description of a network, does it tell the whole story? This practice explores that critical question by challenging you to compare two graphs that share an identical degree sequence . By analyzing higher-order structures like triangles, you will demonstrate that these graphs are fundamentally different (non-isomorphic), highlighting that the degree sequence is not a complete graph invariant.",
            "id": "4293430",
            "problem": "Consider two labeled simple graphs $G_1$ and $G_2$ on the common vertex set $V=\\{1,2,3,4,5,6\\}$. Their edge sets are specified as follows:\n$$\nE(G_1)=\\{\\{1,2\\},\\{2,3\\},\\{3,1\\},\\{4,5\\},\\{5,6\\},\\{6,4\\},\\{1,4\\},\\{2,5\\},\\{3,6\\}\\},\n$$\nand\n$$\nE(G_2)=\\bigl\\{\\{i,j\\}: i\\in\\{1,2,3\\},\\ j\\in\\{4,5,6\\}\\bigr\\}.\n$$\nBegin from the fundamental definitions of degree, degree sequence, simple triangle (a $3$-cycle), bipartite graph, and graph isomorphism in the context of simple graphs. Using only these definitions and standard facts derivable from them, do the following:\n- Verify that $G_1$ and $G_2$ have identical degree sequences (state the sequence explicitly in nonincreasing order).\n- Establish that $G_1$ and $G_2$ are not isomorphic by demonstrating that their triangle counts differ.\n- Compute the triangle counts $T(G_1)$ and $T(G_2)$ exactly and then report the value of $T(G_1)-T(G_2)$.\n\nExplain your reasoning. Express your final answer as a single integer. No rounding is needed.",
            "solution": "This problem requires the analysis and comparison of two simple graphs, $G_1$ and $G_2$, defined on the same set of vertices $V=\\{1,2,3,4,5,6\\}$. The core of the problem involves verifying that they share a graph invariant (the degree sequence) but differ in another (the triangle count), thus proving they are non-isomorphic. We begin by stating the fundamental definitions as required.\n\nA **simple graph** $G$ is an ordered pair $(V, E)$, where $V$ is a set of vertices and $E$ is a set of $2$-element subsets of $V$, called edges.\n\nThe **degree** of a vertex $v$ in a graph $G$, denoted $\\deg_G(v)$, is the number of edges incident to $v$.\n\nThe **degree sequence** of a graph is the sequence of the degrees of its vertices, typically listed in nonincreasing order.\n\nA **simple triangle**, or a $3$-cycle, is a set of three distinct vertices $\\{u, v, w\\}$ such that the edges $\\{u,v\\}$, $\\{v,w\\}$, and $\\{w,u\\}$ all belong to the edge set of the graph. The triangle count, $T(G)$, is the number of such subgraphs in $G$.\n\nA graph is **bipartite** if its vertex set can be partitioned into two disjoint and non-empty sets, $U$ and $W$, such that every edge connects a vertex in $U$ to one in $W$.\n\nTwo graphs $G_1 = (V_1, E_1)$ and $G_2 = (V_2, E_2)$ are **isomorphic**, denoted $G_1 \\cong G_2$, if there exists a bijection $f: V_1 \\rightarrow V_2$ such that $\\{u,v\\} \\in E_1$ if and only if $\\{f(u),f(v)\\} \\in E_2$. Isomorphic graphs are structurally identical, and thus share all graph-theoretic properties, such as their degree sequences and triangle counts. These properties are called graph invariants.\n\nFirst, we determine the degree sequence for each graph.\n\nFor graph $G_1$, the edge set is $E(G_1)=\\{\\{1,2\\},\\{2,3\\},\\{3,1\\},\\{4,5\\},\\{5,6\\},\\{6,4\\},\\{1,4\\},\\{2,5\\},\\{3,6\\}\\}$. We find the degree of each vertex by counting its incident edges:\n- $\\deg_{G_1}(1)$: neighbors are $2, 3, 4$. Degree is $3$.\n- $\\deg_{G_1}(2)$: neighbors are $1, 3, 5$. Degree is $3$.\n- $\\deg_{G_1}(3)$: neighbors are $1, 2, 6$. Degree is $3$.\n- $\\deg_{G_1}(4)$: neighbors are $5, 6, 1$. Degree is $3$.\n- $\\deg_{G_1}(5)$: neighbors are $4, 6, 2$. Degree is $3$.\n- $\\deg_{G_1}(6)$: neighbors are $4, 5, 3$. Degree is $3$.\nAll vertices in $G_1$ have a degree of $3$. The degree sequence of $G_1$ in nonincreasing order is $(3, 3, 3, 3, 3, 3)$.\n\nNext, we analyze graph $G_2$. Its edge set is defined as $E(G_2)=\\bigl\\{\\{i,j\\}: i\\in\\{1,2,3\\},\\ j\\in\\{4,5,6\\}\\bigr\\}$. This means that every vertex in the set $U=\\{1,2,3\\}$ is connected to every vertex in the set $W=\\{4,5,6\\}$, and there are no edges within $U$ or within $W$. This is the definition of the complete bipartite graph $K_{3,3}$.\n- For any vertex $v \\in U=\\{1,2,3\\}$, it is connected to all $3$ vertices in $W$. Thus, $\\deg_{G_2}(v) = 3$.\n- For any vertex $v \\in W=\\{4,5,6\\}$, it is connected to all $3$ vertices in $U$. Thus, $\\deg_{G_2}(v) = 3$.\nAll vertices in $G_2$ also have a degree of $3$. The degree sequence of $G_2$ in nonincreasing order is also $(3, 3, 3, 3, 3, 3)$.\nThis verifies that $G_1$ and $G_2$ have identical degree sequences.\n\nNow, we establish that the graphs are not isomorphic by comparing their triangle counts.\n\nLet's compute the triangle count for $G_2$, denoted $T(G_2)$. As established, $G_2$ is a bipartite graph with partitions $U=\\{1,2,3\\}$ and $W=\\{4,5,6\\}$. A fundamental property of bipartite graphs is that they contain no odd-length cycles. A triangle is a cycle of length $3$, which is an odd number. To see why this is true, consider any walk in a bipartite graph starting from a vertex in one partition, say $U$. Each step in the walk moves to the other partition. So, a walk of length $k$ starting in $U$ ends in $W$ if $k$ is odd, and in $U$ if $k$ is even. A cycle of length $3$ is a walk of length $3$ that starts and ends at the same vertex. If it starts in $U$, it must end in $W$ after $3$ steps, so it cannot return to the starting vertex. Therefore, no cycle of length $3$ can exist in $G_2$. The triangle count is $T(G_2)=0$.\n\nNext, we compute the triangle count for $G_1$, denoted $T(G_1)$. We must search for sets of three vertices that are all mutually connected. Let's inspect the edge set $E(G_1)$:\n- Consider the vertex set $\\{1,2,3\\}$. The edges connecting these vertices are $\\{1,2\\}$, $\\{2,3\\}$, and $\\{3,1\\}$, which are all present in $E(G_1)$. Thus, $\\{1,2,3\\}$ forms a triangle.\n- Consider the vertex set $\\{4,5,6\\}$. The edges connecting these vertices are $\\{4,5\\}$, $\\{5,6\\}$, and $\\{6,4\\}$, which are all present in $E(G_1)$. Thus, $\\{4,5,6\\}$ forms a second triangle.\n- Are there any other triangles? Another triangle would have to involve vertices from both $\\{1,2,3\\}$ and $\\{4,5,6\\}$. Let's check a potential case. Consider the edge $\\{1,4\\}$. A triangle involving this edge would require a third vertex $v$ such that $\\{1,v\\}$ and $\\{4,v\\}$ are both edges. The neighbors of vertex $1$ are $\\{2,3,4\\}$, and the neighbors of vertex $4$ are $\\{5,6,1\\}$. The only common neighbor is the vertex itself (which is not allowed in a simple triangle), so no triangle is formed with the edge $\\{1,4\\}$. A systematic check reveals no other triangles. For instance, for a triangle of the form $\\{i, j, k\\}$ with $i,j \\in \\{1,2,3\\}$ and $k \\in \\{4,5,6\\}$, we would need $\\{i,j\\}$, $\\{i,k\\}$, and $\\{j,k\\}$ to be edges. The only edge within $\\{1,2,3\\}$ pairs is $\\{1,2\\}$, $\\{2,3\\}$, $\\{3,1\\}$. Let's check $\\{1,2,k\\}$ for $k \\in \\{4,5,6\\}$. The cross-edges are $\\{1,4\\}$ and $\\{2,5\\}$. So if we check $\\{1,2,4\\}$, we need $\\{1,2\\}$, $\\{1,4\\}$, and $\\{2,4\\}$. The edge $\\{2,4\\}$ is not in $E(G_1)$. Similar checks for all other combinations confirm that no other triangles exist.\nThus, the triangle count for $G_1$ is $T(G_1)=2$.\n\nSince the number of triangles is a graph invariant, and $T(G_1)=2 \\neq T(G_2)=0$, we have rigorously demonstrated that the graphs $G_1$ and $G_2$ are not isomorphic, despite having the same degree sequence.\n\nFinally, we compute the required difference:\n$$\nT(G_1) - T(G_2) = 2 - 0 = 2.\n$$",
            "answer": "$$\n\\boxed{2}\n$$"
        },
        {
            "introduction": "Having seen that not all sequences can form a graph and that some sequences correspond to multiple different graphs, we turn to a crucial algorithmic question: how can we efficiently determine if a given degree sequence is \"graphical\" at all? This problem introduces the constructive Havel-Hakimi algorithm and pushes you to think about its computational performance . By analyzing and implementing both a straightforward sorting-based approach and a more optimized counting-based method, you will gain hands-on experience in algorithmic design and complexity analysis, core skills for working with large-scale networks.",
            "id": "4293434",
            "problem": "Consider a finite simple graph, defined as a graph with no self-loops and no multiple edges. A degree sequence is a finite list of nonnegative integers $d_1, d_2, \\dots, d_n$ where $d_i$ denotes the degree of node $i$. A degree sequence is called graphical if there exists a finite simple graph whose node degrees are exactly $d_1, d_2, \\dots, d_n$. The Havel–Hakimi (HH) construction is a constructive procedure to test whether a nonincreasing finite sequence of nonnegative integers is graphical: at each iteration, it removes the largest degree $d$ and subtracts $1$ from the next $d$ largest remaining degrees, rejecting the sequence if any degree becomes negative or if $d$ exceeds the number of remaining elements.\n\nStarting from the following fundamental base:\n- The handshake lemma: for any finite simple graph with $n$ nodes and $m$ edges, $\\sum_{i=1}^{n} d_i = 2m$, which implies that any graphical degree sequence must have an even sum.\n- The definition of graphicality: a sequence $d_1, \\dots, d_n$ is graphical if and only if it can be reduced to the all-zero sequence by a sequence of Havel–Hakimi reductions applied to its nonincreasing reordering, without producing negative values or violating the finite simple graph constraints $0 \\le d_i \\le n-1$.\n\nTask:\n1. Analyze, from first principles of algorithmic operations applied to sequences, the computational complexity of implementing the Havel–Hakimi decision procedure by sorting the sequence at every iteration. Use the above base facts and the general comparison-based sorting lower bound to reason about the total cost as a function of $n$.\n2. Design and justify an algorithm that avoids $O(n \\log n)$ sorting at each iteration by maintaining a bounded integer count structure over degrees $0, 1, \\dots, n-1$, thus achieving an $O(n^2)$ worst-case time bound while preserving the correctness of Havel–Hakimi decisions.\n3. Implement both algorithms described in Items $1$ and $2$ to decide graphicality for a given degree sequence, including appropriate validation steps derived from the base facts, namely: checking integrality of degrees, nonnegativity, upper bound $d_i \\le n-1$, and evenness of $\\sum_i d_i$.\n4. Apply your implementations to the provided test suite. For each test case, produce two boolean outputs: first, the result from the sorting-based Havel–Hakimi implementation; second, the result from your $O(n^2)$ bounded-count implementation. Aggregate the outputs for all test cases into a single line in the final format described below.\n\nTest suite (each as a list in the specified order):\n- Test $1$: $[3,3,2,2,2,1,1,1]$\n- Test $2$: $[0,0,0,0]$\n- Test $3$: $[3,3,3,1]$\n- Test $4$: $[4,2,2,2]$\n- Test $5$: $[4,0,0,0,0]$\n- Test $6$: $[5,5,5,5,5,5]$\n- Test $7$: $[1,1,1]$\n- Test $8$: $[-1,2,2]$\n- Test $9$: $[6,4,4,3,3,3,2,2,2,1]$\n- Test $10$: $[7,7,7,7,3,3,3,3]$\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. For each test case in the order $1$ through $10$, first output the boolean result (either True or False) from the sorting-based Havel–Hakimi implementation, followed immediately by the boolean result from the $O(n^2)$ bounded-count implementation. For example, the output should be of the form $[\\text{sort}_1,\\text{bucket}_1,\\text{sort}_2,\\text{bucket}_2,\\dots,\\text{sort}_{10},\\text{bucket}_{10}]$ where each entry is a boolean.",
            "solution": "The user-provided problem is a valid, well-posed task in algorithmic graph theory. It requires the analysis, design, and implementation of algorithms to test if a degree sequence is graphical, based on the Havel-Hakimi theorem. All provided information is scientifically sound and internally consistent.\n\nA degree sequence is a list of non-negative integers $S = (d_1, d_2, \\dots, d_n)$. It is called graphical if there exists a simple graph with $n$ nodes whose degrees are given by the elements of $S$. The solution proceeds by first discussing necessary conditions for a sequence to be graphical, then analyzing two algorithmic implementations of the Havel-Hakimi procedure.\n\n### Preliminary Validation\nBefore applying the iterative Havel-Hakimi procedure, we can falsify many non-graphical sequences using two fundamental properties of simple graphs:\n1.  **Handshake Lemma**: The sum of the degrees in any graph is equal to twice the number of edges, $\\sum_{i=1}^{n} d_i = 2m$. Consequently, the sum of any graphical degree sequence must be an even number. A sequence with an odd sum is immediately non-graphical.\n2.  **Simple Graph Constraint**: In a simple graph with $n$ nodes, the maximum degree any single node can have is $n-1$ (by connecting to every other node). Therefore, for a sequence to be graphical, every degree $d_i$ must satisfy the inequality $0 \\le d_i \\le n-1$. Any sequence containing a negative degree or a degree greater than or equal to $n$ is non-graphical.\n\nThese checks provide a fast initial screening. If a sequence passes these checks, a more sophisticated algorithm like the Havel-Hakimi procedure is required.\n\n### 1. Analysis of the Sorting-Based Havel-Hakimi Algorithm\n\nThe Havel-Hakimi procedure is a recursive algorithm that determines if a sequence is graphical. As described, one implementation strategy involves sorting the sequence at each step. The algorithm is as follows:\n1.  Start with the degree sequence $S$.\n2.  If the sequence is empty or contains only zeros, it is graphical.\n3.  Sort the sequence in non-increasing order.\n4.  Remove the largest degree, $d_1$, from the sequence. Let the new sequence length be $n' = n-1$.\n5.  If $d_1 > n'$, the sequence is not graphical.\n6.  Subtract $1$ from each of the next $d_1$ largest degrees in the remaining sequence.\n7.  If any degree becomes negative during this process, the sequence is not graphical.\n8.  Repeat the process with the new sequence.\n\nTo analyze the computational complexity, let $n$ be the initial number of elements in the sequence. The main loop of the procedure executes at most $n$ times, as in each valid step, either the number of non-zero elements decreases or the sum of degrees decreases, leading to the all-zero sequence, or the list size decreases by one.\n\nThe most computationally expensive operation inside the loop is sorting. Using a comparison-based sorting algorithm (e.g., Mergesort, Heapsort), sorting a sequence of length $k$ has a time complexity of $O(k \\log k)$. In the first iteration, we sort $n$ elements, costing $O(n \\log n)$. In the second, we sort $n-1$ elements, costing $O((n-1) \\log(n-1))$, and so on.\n\nThe total time complexity, $T(n)$, is the sum of costs over all iterations. In the worst case, the loop runs approximately $n$ times.\n$$T(n) = \\sum_{k=0}^{n-1} O((n-k) \\log(n-k))$$\nLet $j = n-k$. As $k$ goes from $0$ to $n-1$, $j$ goes from $n$ to $1$.\n$$T(n) = \\sum_{j=1}^{n} O(j \\log j)$$\nA simple upper bound for this sum is $n \\times O(n \\log n)$, which gives $O(n^2 \\log n)$. A more formal analysis using integral bounds confirms that $\\sum_{j=1}^{n} j \\log j$ is indeed $\\Theta(n^2 \\log n)$. Therefore, the worst-case time complexity of the Havel-Hakimi implementation that relies on re-sorting at each iteration is $O(n^2 \\log n)$.\n\n### 2. Design of an $O(n^2)$ Bounded-Count Algorithm\n\nThe bottleneck in the sorting-based approach is the repeated $O(k \\log k)$ sorting step. We can achieve better performance by recognizing that the degrees are integers within a known, bounded range, specifically $[0, n-1]$ for a valid sequence of length $n$. This structure allows for a counting-based approach, avoiding comparison sorting.\n\n**Data Structure:**\nWe use an array, let's call it `counts`, of size $n$, to store the frequency of each degree. `counts[k]` will hold the number of nodes that have degree $k$. This structure can be built from the initial degree sequence in $O(n)$ time.\n\n**Algorithm:**\nThe algorithm proceeds iteratively, simulating the removal of one node at each step. Let `num_nodes` be the number of nodes currently under consideration, initialized to $n$.\n\nFor each step (up to $n-1$ times):\n1.  **Find Maximum Degree**: Find the largest degree $d_{max}$ present in the current graph representation by scanning the `counts` array from index `num_nodes - 1` down to $0$. The first index $d$ with `counts[d] > 0` is our $d_{max}$. This takes $O(n)$ time. If no non-zero degree is found, the sequence is graphical.\n2.  **Remove Node**: Decrement the count of this maximum degree: `counts[d_max]--`. We also conceptually reduce the number of nodes: `num_nodes--`.\n3.  **Check Validity**: We must ensure that $d_{max}$ is not greater than the number of remaining nodes, which is now `num_nodes`. If $d_{max} > \\text{num\\_nodes}$, the sequence is non-graphical.\n4.  **Decrement Neighbor Degrees**: We need to subtract $1$ from `d_max` other degrees. Since the Havel-Hakimi theorem requires reducing the largest available degrees, we again scan the `counts` array from the highest possible degree (now `num_nodes`) downwards. For each degree level $k$ we encounter, we 'move' nodes from `counts[k]` to `counts[k-1]` until we have accounted for `d_max` decrements. This process also takes $O(n)$ time. If at any point we need to decrement a degree of $0$ (i.e., move a count from `counts[0]`), the sequence is non-graphical.\n\n**Complexity Analysis:**\nThe main loop runs at most $n$ times. Inside the loop, each step (finding the max degree, updating counts) involves scanning the `counts` array of size $n$. Thus, each iteration takes $O(n)$ time. The total worst-case time complexity is $n \\times O(n) = O(n^2)$. This is a significant improvement over the $O(n^2 \\log n)$ complexity of the sorting-based method. This algorithm is correct because by always selecting nodes to decrement from the highest-degree buckets first, it perfectly simulates the logic of the sorted-list approach.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef _common_pre_checks(degrees):\n    \"\"\"\n    Performs initial validation on the degree sequence.\n    - Sum of degrees must be even.\n    - All degrees d must satisfy 0 <= d < n.\n    \n    Returns a tuple (is_valid, message).\n    \"\"\"\n    if not isinstance(degrees, list):\n        return False, \"Input must be a list.\"\n\n    if not degrees:\n        return True, \"\" # Empty graph is graphical\n\n    n = len(degrees)\n    s = 0\n    for d in degrees:\n        if not isinstance(d, int):\n            return False, \"Degrees must be integers.\"\n        if d < 0:\n            return False, f\"Negative degree found: {d}.\"\n        if d >= n:\n            return False, f\"Degree {d} is invalid for a graph with {n} nodes.\"\n        s += d\n\n    if s % 2 != 0:\n        return False, \"Sum of degrees must be even.\"\n\n    return True, \"\"\n\ndef havel_hakimi_sorting(degrees):\n    \"\"\"\n    Checks if a degree sequence is graphical using the Havel-Hakimi algorithm\n    with sorting at each step. Complexity: O(n^2 log n).\n    \"\"\"\n    is_valid, msg = _common_pre_checks(degrees)\n    if not is_valid:\n        return False\n\n    # Make a mutable copy\n    degs = list(degrees)\n\n    while True:\n        # Optimization: remove trailing zeros\n        degs = [d for d in degs if d > 0]\n        if not degs:\n            return True\n\n        degs.sort(reverse=True)\n\n        d1 = degs.pop(0)\n        \n        if d1 > len(degs):\n            return False\n        \n        for i in range(d1):\n            degs[i] -= 1\n            if degs[i] < 0:\n                return False\n    \n    return True # Should be unreachable if logic is correct\n\ndef havel_hakimi_counting(degrees):\n    \"\"\"\n    Checks if a degree sequence is graphical using the Havel-Hakimi algorithm\n    with a counting-based approach. Complexity: O(n^2).\n    \"\"\"\n    is_valid, msg = _common_pre_checks(degrees)\n    if not is_valid:\n        return False\n        \n    n = len(degrees)\n    if n == 0:\n        return True\n\n    # counts[k] stores the number of nodes with degree k\n    counts = np.zeros(n, dtype=int)\n    for d in degrees:\n        counts[d] += 1\n        \n    num_nodes = n\n    \n    # Iterate n-1 times, conceptually removing one node each time\n    for _ in range(n):\n        # Find the max degree by scanning from the top\n        max_deg = -1\n        # Highest possible degree is num_nodes - 1\n        for d in range(num_nodes - 1, -1, -1):\n            if counts[d] > 0:\n                max_deg = d\n                break\n        \n        # If all remaining degrees are 0, sequence is graphical\n        if max_deg <= 0:\n            return True\n            \n        # \"Remove\" the node with max_deg\n        counts[max_deg] -= 1\n        num_nodes -= 1\n        \n        # If d > number of remaining nodes, it's impossible\n        if max_deg > num_nodes:\n            return False\n            \n        # \"Connect\" the removed node by decrementing d largest degrees\n        to_reduce = max_deg\n        # Iterate from the highest possible degree downwards\n        for d in range(num_nodes, -1, -1):\n            num_in_bucket = counts[d]\n            take = min(to_reduce, num_in_bucket)\n            \n            if take > 0:\n                # We cannot decrement a node of degree 0\n                if d == 0:\n                    return False\n                \n                counts[d] -= take\n                counts[d-1] += take\n                to_reduce -= take\n                \n            if to_reduce == 0:\n                break\n        \n        # If we couldn't find enough nodes to connect to\n        if to_reduce > 0:\n            return False\n            \n    return True\n\n\ndef solve():\n    \"\"\"\n    Runs the Havel-Hakimi algorithms on the provided test suite.\n    \"\"\"\n    test_cases = [\n        [3, 3, 2, 2, 2, 1, 1, 1],\n        [0, 0, 0, 0],\n        [3, 3, 3, 1],\n        [4, 2, 2, 2],\n        [4, 0, 0, 0, 0],\n        [5, 5, 5, 5, 5, 5],\n        [1, 1, 1],\n        [-1, 2, 2],\n        [6, 4, 4, 3, 3, 3, 2, 2, 2, 1],\n        [7, 7, 7, 7, 3, 3, 3, 3],\n    ]\n\n    results = []\n    for case in test_cases:\n        res_sort = havel_hakimi_sorting(case)\n        res_count = havel_hakimi_counting(case)\n        results.append(str(res_sort))\n        results.append(str(res_count))\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}