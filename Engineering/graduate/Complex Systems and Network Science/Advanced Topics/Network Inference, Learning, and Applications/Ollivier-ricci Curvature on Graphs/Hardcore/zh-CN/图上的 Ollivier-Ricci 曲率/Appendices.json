{
    "hands_on_practices": [
        {
            "introduction": "我们从一个基本结构——路径图——开始我们的实践之旅。路径图作为最简单的图之一，是测试和理解复杂网络度量理想的起点。通过这个练习，你将亲手计算一条边上的Ollivier-Ricci曲率，这不仅能帮助你熟悉Wasserstein距离的计算，还能揭示一个关于“平坦”离散空间的基本结论。",
            "id": "4294224",
            "problem": "令 $P_{n}$ 为一个在 $n \\geq 2$ 个顶点上的无权无向路径图，顶点依次标记为 $v_{1}, v_{2}, \\dots, v_{n}$，并令 $d$ 为 $P_{n}$ 上的标准图距离。考虑沿一条边 $\\{x,y\\}$ 的Ollivier-Ricci曲率，其空闲参数 $\\alpha=0$，该曲率使用每个顶点邻域上的均匀概率测度以及关于 $d$ 的1-Wasserstein距离来定义。对于 $P_{n}$ 中的一个相邻对 $(x,y)$，计算 $\\kappa_{0}(x,y)$ 的精确值，并解释作为端点边（与叶节点相连）与作为内部边（两个端点的度均为2）是否以及如何影响该值。你的最终答案必须是一个精确的数字，无需四舍五入。",
            "solution": "该问题被认为是有效的，因为它具有科学依据、提法明确且客观。它在图上离散Ricci曲率的既定数学框架内提出了一个正式问题。我们着手进行解答。\n\n图中一条边 $\\{x,y\\}$ 的Ollivier-Ricci曲率，在空闲参数为 $\\alpha$ 时，定义为：\n$$\n\\kappa_{\\alpha}(x,y) = 1 - \\frac{W_1(\\mu_x^\\alpha, \\mu_y^\\alpha)}{d(x,y)}\n$$\n其中 $d(x,y)$ 是顶点 $x$ 和 $y$ 之间的距离，$W_1$ 是两个概率测度之间的1-Wasserstein距离，而 $\\mu_v^\\alpha$ 是顶点 $v$ 上的概率测度。\n问题指定了空闲参数 $\\alpha=0$。对于相邻顶点 $x$ 和 $y$，我们有 $d(x,y)=1$。曲率公式简化为：\n$$\n\\kappa_{0}(x,y) = 1 - W_1(\\mu_x, \\mu_y)\n$$\n在度为 $\\deg(v)$ 的顶点 $v$ 上的概率测度 $\\mu_v$ 被指定为其邻居 $N(v)$ 上的均匀测度。这可以写成：\n$$\n\\mu_v = \\frac{1}{\\deg(v)} \\sum_{z \\in N(v)} \\delta_z\n$$\n其中 $\\delta_z$ 是集中在顶点 $z$ 上的狄拉克测度。两个测度 $\\mu_x$ 和 $\\mu_y$ 之间的1-Wasserstein距离是一个最优运输问题的解：\n$$\nW_1(\\mu_x, \\mu_y) = \\inf_{\\pi \\in \\Pi(\\mu_x, \\mu_y)} \\sum_{z_1, z_2} d(z_1, z_2) \\pi(z_1, z_2)\n$$\n这里，$\\Pi(\\mu_x, \\mu_y)$ 是从分布 $\\mu_x$ 到 $\\mu_y$ 的所有运输方案（耦合）的集合。一个方案 $\\pi(z_1, z_2)$ 表示从 $z_1$（$x$ 的一个邻居）运输到 $z_2$（$y$ 的一个邻居）的质量，受限于 $\\pi$ 的边际分布为 $\\mu_x$ 和 $\\mu_y$ 的约束。\n\n我们分析在顶点为 $\\{v_1, v_2, \\dots, v_n\\}$ 的路径图 $P_n$ 中两种不同类型边的曲率。\n\n情况1：内部边\n设边为 $\\{x,y\\} = \\{v_i, v_{i+1}\\}$，其中 $1  i  n-1$。这要求 $n \\geq 4$。对于这样一条边，两个顶点的度都为2。\n邻居是 $N(x) = N(v_i) = \\{v_{i-1}, v_{i+1}\\}$ 和 $N(y) = N(v_{i+1}) = \\{v_i, v_{i+2}\\}$。\n度数为 $\\deg(x)=2$ 和 $\\deg(y)=2$。\n概率测度是：\n$$\n\\mu_x = \\frac{1}{2}\\delta_{v_{i-1}} + \\frac{1}{2}\\delta_{v_{i+1}}\n$$\n$$\n\\mu_y = \\frac{1}{2}\\delta_{v_{i}} + \\frac{1}{2}\\delta_{v_{i+2}}\n$$\n我们需要找到将质量 $\\frac{1}{2}$ 从 $x$ 的每个邻居运输到 $y$ 的邻居的最小成本，每个 $y$ 的邻居需要质量 $\\frac{1}{2}$。质量的源点是 $\\{v_{i-1}, v_{i+1}\\}$，汇点是 $\\{v_i, v_{i+2}\\}$。成本是图距离 $d(u, w) = |j-k|$，对于顶点 $v_j, v_k$。\n我们来计算成对距离：\n$d(v_{i-1}, v_i) = 1$\n$d(v_{i-1}, v_{i+2}) = |(i+2)-(i-1)| = 3$\n$d(v_{i+1}, v_i) = 1$\n$d(v_{i+1}, v_{i+2}) = 1$\n\n一个运输方案 $\\pi$ 必须满足边际条件。设 $\\pi(v_{i-1}, v_i) = a$。因为从 $v_{i-1}$ 出发的总质量为 $\\frac{1}{2}$，我们有 $\\pi(v_{i-1}, v_{i+2}) = \\frac{1}{2} - a$。因为到达 $v_i$ 的总质量为 $\\frac{1}{2}$，我们必须有 $\\pi(v_{i+1}, v_i) = \\frac{1}{2} - a$。最后，为了使从 $v_{i+1}$ 出发的质量加起来为 $\\frac{1}{2}$，有 $\\pi(v_{i+1}, v_{i+2}) = \\frac{1}{2} - (\\frac{1}{2} - a) = a$。约束条件 $a \\geq 0$ 和 $\\frac{1}{2}-a \\geq 0$ 意味着 $0 \\leq a \\leq \\frac{1}{2}$。\n\n总运输成本 $C(a)$ 为：\n$$\nC(a) = a \\cdot d(v_{i-1}, v_i) + (\\frac{1}{2}-a) \\cdot d(v_{i-1}, v_{i+2}) + (\\frac{1}{2}-a) \\cdot d(v_{i+1}, v_i) + a \\cdot d(v_{i+1}, v_{i+2})\n$$\n$$\nC(a) = a \\cdot 1 + (\\frac{1}{2}-a) \\cdot 3 + (\\frac{1}{2}-a) \\cdot 1 + a \\cdot 1\n$$\n$$\nC(a) = a + \\frac{3}{2} - 3a + \\frac{1}{2} - a + a = 2 - 2a\n$$\n为了找到Wasserstein距离 $W_1(\\mu_x, \\mu_y)$，我们必须最小化 $C(a)$。成本 $C(a)=2-2a$ 在 $a$ 最大化时最小化。最大值为 $a=\\frac{1}{2}$。\n最优成本为 $W_1(\\mu_x, \\mu_y) = C(\\frac{1}{2}) = 2 - 2(\\frac{1}{2}) = 1$。\n因此，曲率为：\n$$\n\\kappa_0(v_i, v_{i+1}) = 1 - W_1(\\mu_x, \\mu_y) = 1 - 1 = 0\n$$\n\n情况2：端点边\n设边为 $\\{x,y\\} = \\{v_1, v_2\\}$。分析取决于图的大小 $n$。\n\n子情况2a：$n \\geq 3$。\n这里，$x=v_1$ 是一个叶节点，而 $y=v_2$ 是由 $\\{v_1, v_2, v_3\\}$ 构成的路径中的一个内部顶点。\n邻居是 $N(x)=N(v_1) = \\{v_2\\}$ 和 $N(y)=N(v_2) = \\{v_1, v_3\\}$。\n度数为 $\\deg(x)=1$ 和 $\\deg(y)=2$。\n概率测度是：\n$$\n\\mu_x = \\frac{1}{1}\\delta_{v_2} = \\delta_{v_2}\n$$\n$$\n\\mu_y = \\frac{1}{2}\\delta_{v_1} + \\frac{1}{2}\\delta_{v_3}\n$$\n运输问题是将质量1从单一源点 $v_2$ 移动到两个汇点 $v_1$ 和 $v_3$，每个汇点需要质量 $\\frac{1}{2}$。运输方案是唯一确定的：我们必须将质量 $\\frac{1}{2}$ 从 $v_2$ 发送到 $v_1$，并将质量 $\\frac{1}{2}$ 从 $v_2$ 发送到 $v_3$。\n成本是：\n$$\nW_1(\\mu_x, \\mu_y) = \\frac{1}{2} d(v_2, v_1) + \\frac{1}{2} d(v_2, v_3)\n$$\n距离为 $d(v_2, v_1)=1$ 和 $d(v_2, v_3)=1$。\n$$\nW_1(\\mu_x, \\mu_y) = \\frac{1}{2}(1) + \\frac{1}{2}(1) = 1\n$$\n曲率是：\n$$\n\\kappa_0(v_1, v_2) = 1 - W_1(\\mu_x, \\mu_y) = 1 - 1 = 0\n$$\n根据对称性，同样的结果也适用于另一个端点边 $\\{v_{n-1}, v_n\\}$。\n\n子情况2b：$n = 2$。\n图是 $P_2$，由一条边 $\\{v_1, v_2\\}$ 组成。两个顶点都是叶节点。\n这里，$x=v_1$ 且 $y=v_2$。\n邻居是 $N(x)=N(v_1)=\\{v_2\\}$ 和 $N(y)=N(v_2)=\\{v_1\\}$。\n度数为 $\\deg(x)=1$ 和 $\\deg(y)=1$。\n概率测度是：\n$$\n\\mu_x = \\delta_{v_2}\n$$\n$$\n\\mu_y = \\delta_{v_1}\n$$\n运输问题是将质量1从源点 $v_2$ 移动到汇点 $v_1$。该方案是平凡的。\n成本为 $W_1(\\mu_x, \\mu_y) = 1 \\cdot d(v_2, v_1) = 1 \\cdot 1 = 1$。\n曲率是：\n$$\n\\kappa_0(v_1, v_2) = 1 - W_1(\\mu_x, \\mu_y) = 1 - 1 = 0\n$$\n\n在所有情况下——内部边、对于 $n \\geq 3$ 的端点边以及 $P_2$ 中的边——计算出的Wasserstein距离都是 $W_1=1$。因此，Ollivier-Ricci曲率始终为 $0$。边的位置（端点边与内部边）不影响其曲率值。对于此曲率定义，路径图 $P_n$ 处处是离散“平坦”的。\n$P_n$ 中任意边的曲率的唯一精确值为 $0$。",
            "answer": "$$\\boxed{0}$$"
        },
        {
            "introduction": "在理解了路径图的‘平坦’特性后，我们转向一个具有更多连接性的结构：环形图。与计算相邻节点间的曲率不同，这个练习将引导你探索图中两个相对顶点之间的曲率。这个过程将揭示正曲率是如何从邻域的高度重叠中产生的，并让你通过构建并求解一个简单的线性规划问题来实践最优传输的核心思想。",
            "id": "4294251",
            "problem": "考虑圈图 $C_4$，其顶点集为 $V=\\{v_0,v_1,v_2,v_3\\}$，边集为 $E=\\{(v_0,v_1),(v_1,v_2),(v_2,v_3),(v_3,v_0)\\}$。令 $d(\\cdot,\\cdot)$ 表示 $C_4$ 上的最短路径度量。对于每个顶点 $x\\in V$，定义均匀邻域测度 $\\mu_x$ 为一个在其邻居集合 $N(x)$ 上支撑的概率测度，该测度为每个 $z\\in N(x)$ 赋予概率 $1/\\deg(x)$，其中 $\\deg(x)$ 是 $x$ 的度。在 $C_4$ 中，每个顶点的度都为 $2$。\n\n令 $x=v_0$ 和 $y=v_2$ 为相对顶点。使用 1-Wasserstein 距离（也称为推土机距离）的最优传输公式，通过一个在 $\\mu_x$ 和 $\\mu_y$ 之间，以 $d(\\cdot,\\cdot)$ 为传输成本的线性规划（LP）公式，计算 $W_1(\\mu_x,\\mu_y)$。然后，使用 Ollivier-Ricci 曲率 $k(x,y)$ 关于 1-Wasserstein 距离和图度量的定义，计算曲率 $k(x,y)$。\n\n在您的推导中：\n- 从图上最短路径度量、均匀邻域测度以及有限度量空间上离散概率测度之间 1-Wasserstein 距离的原始线性规划（LP）的标准定义开始。\n- 明确指出 $\\mu_x$ 和 $\\mu_y$ 及相关的支撑集。\n- 用传输变量和约束来构建线性规划，并精确求解。\n\n将最终的曲率值 $k(x,y)$ 表示为一个精确的实数。无需四舍五入，也没有物理单位。",
            "solution": "该问题要求计算圈图 $C_4$ 上两个相对顶点 $x=v_0$ 和 $y=v_2$ 的 Ollivier-Ricci 曲率 $k(x,y)$。计算过程首先涉及确定均匀邻域测度 $\\mu_x$ 和 $\\mu_y$ 之间的 1-Wasserstein 距离 $W_1(\\mu_x, \\mu_y)$。\n\n步骤 1：定义图、度量和相关顶点。\n圈图 $C_4$ 的顶点集为 $V=\\{v_0, v_1, v_2, v_3\\}$，边集为 $E=\\{(v_0,v_1), (v_1,v_2), (v_2,v_3), (v_3,v_0)\\}$。度量 $d(\\cdot, \\cdot)$ 是图上的最短路径距离。相关顶点为 $x=v_0$ 和 $y=v_2$。它们之间的最短路径距离 $d(x,y) = d(v_0,v_2)$ 可以通过遍历路径 $(v_0, v_1, v_2)$ 或 $(v_0, v_3, v_2)$ 来找到。两条路径的长度都为 $2$。因此，\n$$d(v_0, v_2) = 2$$\n\n步骤 2：定义均匀邻域测度 $\\mu_x$ 和 $\\mu_y$。\n顶点 $u$ 的均匀邻域测度 $\\mu_u$ 是一个在其邻居集合 $N(u)$ 上支撑的概率测度，为每个邻居分配概率 $1/\\deg(u)$。在 $C_4$ 中，每个顶点的度都为 $2$。\n\n对于顶点 $x=v_0$，其邻居为 $N(v_0) = \\{v_1, v_3\\}$。度为 $\\deg(v_0)=2$。因此，测度 $\\mu_{v_0}$ 为：\n$$ \\mu_{v_0}(v_1) = \\frac{1}{\\deg(v_0)} = \\frac{1}{2} $$\n$$ \\mu_{v_0}(v_3) = \\frac{1}{\\deg(v_0)} = \\frac{1}{2} $$\n我们可以将这个测度写为 $\\mu_{v_0} = \\frac{1}{2}\\delta_{v_1} + \\frac{1}{2}\\delta_{v_3}$，其中 $\\delta_v$ 是集中在顶点 $v$ 上的狄拉克测度。\n\n对于顶点 $y=v_2$，其邻居为 $N(v_2) = \\{v_1, v_3\\}$。度为 $\\deg(v_2)=2$。测度 $\\mu_{v_2}$ 为：\n$$ \\mu_{v_2}(v_1) = \\frac{1}{\\deg(v_2)} = \\frac{1}{2} $$\n$$ \\mu_{v_2}(v_3) = \\frac{1}{\\deg(v_2)} = \\frac{1}{2} $$\n这个测度是 $\\mu_{v_2} = \\frac{1}{2}\\delta_{v_1} + \\frac{1}{2}\\delta_{v_3}$。\n\n我们观察到这两个测度是相同的：$\\mu_{v_0} = \\mu_{v_2}$。\n\n步骤 3：将 1-Wasserstein 距离表述为线性规划 (LP)。\n两个离散概率测度 $\\mu_a = \\sum_{i} p_i \\delta_{u_i}$ 和 $\\mu_b = \\sum_{j} q_j \\delta_{w_j}$ 之间的 1-Wasserstein 距离 $W_1(\\mu_a, \\mu_b)$ 是以下原始线性规划（也称为 Kantorovich 问题）的解：\n$$ W_1(\\mu_a, \\mu_b) = \\min_{\\pi} \\sum_{i,j} \\pi_{ij} d(u_i, w_j) $$\n受以下约束：\n1. 对所有 $i,j$，$\\pi_{ij} \\ge 0$。\n2. 对所有 $i$，$\\sum_j \\pi_{ij} = p_i$。（从 $u_i$ 传输的总质量等于 $u_i$ 处的质量）。\n3. 对所有 $j$，$\\sum_i \\pi_{ij} = q_j$。（传输到 $w_j$ 的总质量等于 $w_j$ 处的质量）。\n\n在我们的例子中，$\\mu_a = \\mu_{v_0}$ 和 $\\mu_b = \\mu_{v_2}$。两个测度的支撑集都是同一个顶点集 $\\{v_1, v_3\\}$。我们记源顶点（来自 $\\mu_{v_0}$）为 $u_1=v_1, u_2=v_3$，目标顶点（对于 $\\mu_{v_2}$）为 $w_1=v_1, w_2=v_3$。概率为 $p_1 = p_2 = 1/2$ 和 $q_1 = q_2 = 1/2$。传输方案是一个变量矩阵 $\\pi_{ij}$（其中 $i, j \\in \\{1, 2\\}$），表示从 $u_i$ 移动到 $w_j$ 的质量量。\n\n成本矩阵 $C$ 包含原始图 $C_4$ 上的最短路径距离 $d(u_i, w_j)$：\n- $d(u_1, w_1) = d(v_1, v_1) = 0$\n- $d(u_1, w_2) = d(v_1, v_3) = 2$ (通过路径 $v_1-v_0-v_3$ 或 $v_1-v_2-v_3$)\n- $d(u_2, w_1) = d(v_3, v_1) = 2$\n- $d(u_2, w_2) = d(v_3, v_3) = 0$\n所以，成本矩阵是 $C = \\begin{pmatrix} 0  2 \\\\ 2  0 \\end{pmatrix}$。\n\n该线性规划旨在最小化目标函数：\n$$ \\text{成本} = \\pi_{11}d(v_1, v_1) + \\pi_{12}d(v_1, v_3) + \\pi_{21}d(v_3, v_1) + \\pi_{22}d(v_3, v_3) $$\n$$ \\text{成本} = 0 \\cdot \\pi_{11} + 2 \\cdot \\pi_{12} + 2 \\cdot \\pi_{21} + 0 \\cdot \\pi_{22} = 2(\\pi_{12} + \\pi_{21}) $$\n受以下约束：\n- 离开 $v_1$ 的质量：$\\pi_{11} + \\pi_{12} = \\mu_{v_0}(v_1) = 1/2$\n- 离开 $v_3$ 的质量：$\\pi_{21} + \\pi_{22} = \\mu_{v_0}(v_3) = 1/2$\n- 到达 $v_1$ 的质量：$\\pi_{11} + \\pi_{21} = \\mu_{v_2}(v_1) = 1/2$\n- 到达 $v_3$ 的质量：$\\pi_{12} + \\pi_{22} = \\mu_{v_2}(v_3) = 1/2$\n- 非负性：$\\pi_{ij} \\ge 0$。\n\n步骤 4：求解线性规划。\n为了最小化成本 $2(\\pi_{12} + \\pi_{21})$，我们必须为 $\\pi_{12}$ 和 $\\pi_{21}$ 选择可能的最小非负值。让我们测试将交叉传输项设为零的解：\n$$ \\pi_{12} = 0 $$\n$$ \\pi_{21} = 0 $$\n将这些代入约束条件中：\n- 从 $\\pi_{11} + \\pi_{12} = 1/2$ 中，我们得到 $\\pi_{11} + 0 = 1/2 \\implies \\pi_{11} = 1/2$。\n- 从 $\\pi_{21} + \\pi_{22} = 1/2$ 中，我们得到 $0 + \\pi_{22} = 1/2 \\implies \\pi_{22} = 1/2$。\n\n这个提议的解是一个传输方案 $\\Pi = \\begin{pmatrix} 1/2  0 \\\\ 0  1/2 \\end{pmatrix}$。我们必须验证它满足所有约束。\n- 行约束由构造满足。\n- 列约束检查：\n  - $\\pi_{11} + \\pi_{21} = 1/2 + 0 = 1/2$。这是正确的。\n  - $\\pi_{12} + \\pi_{22} = 0 + 1/2 = 1/2$。这是正确的。\n- 所有的 $\\pi_{ij}$ 都是非负的。\n该解是可行的。由于我们已将目标函数的非负分量最小化到其可能的最小值（$0$），因此该解是最优的。这对应于将 $v_1$ 处的质量传输到 $v_1$，并将 $v_3$ 处的质量传输到 $v_3$，这是最高效的方案，因为源测度和目标测度是相同的。\n\n最小成本，即 Wasserstein 距离，为：\n$$ W_1(\\mu_{v_0}, \\mu_{v_2}) = 2(\\pi_{12} + \\pi_{21}) = 2(0 + 0) = 0 $$\n\n步骤 5：计算 Ollivier-Ricci 曲率。\nOllivier-Ricci 曲率 $k(x,y)$ 定义为：\n$$ k(x,y) = 1 - \\frac{W_1(\\mu_x, \\mu_y)}{d(x,y)} $$\n对于 $x=v_0$ 和 $y=v_2$，我们有 $d(v_0,v_2)=2$，并且我们刚刚计算出 $W_1(\\mu_{v_0}, \\mu_{v_2})=0$。\n代入这些值：\n$$ k(v_0, v_2) = 1 - \\frac{0}{2} = 1 - 0 = 1 $$\n相对顶点对 $(v_0, v_2)$ 的曲率为 $1$。这个大的正曲率反映了 $v_0$ 和 $v_2$ 周围的局部邻域分布是相同的，这表明这两点之间有很强的局部“内聚力”或缺乏“扩散”。",
            "answer": "$$ \\boxed{1} $$"
        },
        {
            "introduction": "手动计算对于建立直觉至关重要，但要分析真实世界的复杂网络，我们必须借助计算工具。最后一个练习将引导你完成从理论到实践的飞跃：设计一个算法，将曲率的计算过程自动化。这个练习不仅要求你将最优传输问题形式化为计算机可以求解的线性规划，还将促使你思考算法效率和稀疏数据结构在网络分析中的重要性。",
            "id": "4294133",
            "problem": "一个连通、简单、无向图 $G = (V,E)$ 及其最短路径度量 $d_G$ 定义了一个度量测度空间，其中每个顶点 $x \\in V$ 都带有一个由懒惰参数 $\\alpha \\in [0,1]$ 参数化的概率测度 $m_x^\\alpha$。懒惰随机游走测度的定义为：对于每个邻居 $u \\in N(x)$，$m_x^\\alpha(x) = \\alpha$，$m_x^\\alpha(u) = \\frac{1-\\alpha}{\\deg(x)}$，对于所有其他顶点，$m_x^\\alpha(u) = 0$。对于一条边 $(x,y) \\in E$，Ollivier–Ricci 曲率 $\\kappa_\\alpha(x,y)$ 通过度量 $d_G$ 下的 Wasserstein 1-距离 $W_1$ 定义为 $\\kappa_\\alpha(x,y) = 1 - \\frac{W_1(m_x^\\alpha,m_y^\\alpha)}{d_G(x,y)}$。由于对于边而言 $d_G(x,y) = 1$，该式可简化为 $\\kappa_\\alpha(x,y) = 1 - W_1(m_x^\\alpha,m_y^\\alpha)$。Wasserstein 1-距离 $W_1(m_x^\\alpha,m_y^\\alpha)$ 是将分布 $m_x^\\alpha$ 移动到 $m_y^\\alpha$ 所需的最小总运输成本（成本函数为 $d_G(u,v)$），并且可以使用测度支撑集之间的最优耦合 $\\pi$ 将其构建为一个线性规划（LP）问题。\n\n从图上的最短路径度量、顶点上的懒惰随机游走测度以及最优运输的 Kantorovich 公式的基本定义出发，设计一个算法，通过求解一个限制在 $m_x^\\alpha$ 和 $m_y^\\alpha$ 的稀疏支撑集上的线性规划问题来计算所有边 $(x,y) \\in E$ 的 $\\kappa_\\alpha(x,y)$。该算法必须：\n- 构建一个线性规划，其变量仅表示 $m_x^\\alpha$ 和 $m_y^\\alpha$ 的非零支撑集（即 $S_x = \\{x\\} \\cup N(x)$ 和 $S_y = \\{y\\} \\cup N(y)$）之间的运输流。\n- 使用图的最短路径距离 $d_G(u,v)$ 作为 $u \\in S_x$ 和 $v \\in S_y$ 之间的运输成本。\n- 强制施加等式约束，使得从每个 $u \\in S_x$ 出发的流之和等于 $m_x^\\alpha(u)$，而进入每个 $v \\in S_y$ 的流之和等于 $m_y^\\alpha(v)$。\n- 将线性规划的最优解作为 $W_1(m_x^\\alpha,m_y^\\alpha)$ 进行计算，并返回 $\\kappa_\\alpha(x,y) = 1 - W_1(m_x^\\alpha,m_y^\\alpha)$。\n\n根据 $|V|$、 $|E|$ 以及局部度 $\\deg(x)$ 和 $\\deg(y)$ 分析算法的计算复杂度，并清楚解释稀疏支撑集和最短路径计算的作用。你的分析应考虑：\n- 由 $S_x$ 和 $S_y$ 产生的线性规划变量和约束的数量。\n- 使用广度优先搜索（BFS）计算仅限于点对 $u \\in S_x, v \\in S_y$ 的 $d_G(u,v)$ 的成本。\n- 计算所有边的 $\\kappa_\\alpha(x,y)$ 的每边成本和总成本。\n\n实现要求：\n- 使用允许的库实现上述基于线性规划的算法，并生成数值结果。\n- 程序不得接受任何输入，必须是自包含的，并且必须在内部构建测试套件。\n\n测试套件：\n1. 图 $G_1$：四个顶点的路径图，其中 $V = \\{0,1,2,3\\}$，$E = \\{(0,1),(1,2),(2,3)\\}$，$\\alpha = 0.5$。\n2. 图 $G_2$：三角形图，其中 $V = \\{0,1,2\\}$，$E = \\{(0,1),(1,2),(2,0)\\}$，$\\alpha = 0$。\n3. 图 $G_3$：由一座桥连接的两个三角形组成的杠铃图，左侧三角形顶点为 $\\{0,1,2\\}$，右侧三角形顶点为 $\\{3,4,5\\}$，边为 $(0,1),(1,2),(2,0)$ 和 $(3,4),(4,5),(5,3)$，桥边为 $(0,3)$，$\\alpha = 0.5$。\n4. 图 $G_4$：四个顶点的环图，其中 $V = \\{0,1,2,3\\}$，$E = \\{(0,1),(1,2),(2,3),(3,0)\\}$，$\\alpha = 1$。\n\n对于测试套件中的每个图 $G_i$，计算每条无向边 $(x,y) \\in E$ 的 $\\kappa_\\alpha(x,y)$，并按点对 $(\\min\\{x,y\\},\\max\\{x,y\\})$ 的字典序排序。将四个测试用例的所有结果聚合到一个列表中，该列表按 $G_1$、$G_2$、$G_3$、$G_4$ 的顺序连接每个图的结果序列。你的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如 $[r_1,r_2,\\dots,r_n]$）。将所有数值结果表示为保留六位小数的浮点数。不涉及物理单位或角度单位，也不需要百分比。",
            "solution": "该问题陈述被评估为有效，因为它在离散 Ricci 曲率的既定理论中具有科学依据，问题良定且目标明确，并为获得唯一解提供了所有必要信息。懒惰随机游走测度、Wasserstein 距离和 Ollivier-Ricci 曲率的定义在网络科学和离散微分几何领域是标准的。任务是设计并实现一个计算这些曲率的算法，并分析其复杂度。\n\n问题的核心是计算图 $G=(V,E)$ 中所有边 $(x,y)$ 的 Ollivier-Ricci 曲率 $\\kappa_\\alpha(x,y)$。提供的定义是：\n$$ \\kappa_\\alpha(x,y) = 1 - \\frac{W_1(m_x^\\alpha, m_y^\\alpha)}{d_G(x,y)} $$\n对于一条边 $(x,y) \\in E$，最短路径距离 $d_G(x,y)=1$，这使得表达式简化为 $\\kappa_\\alpha(x,y) = 1 - W_1(m_x^\\alpha, m_y^\\alpha)$。主要的计算任务是确定分别以顶点 $x$ 和 $y$ 为中心的概率测度 $m_x^\\alpha$ 和 $m_y^\\alpha$ 之间的 Wasserstein 1-距离 $W_1(m_x^\\alpha, m_y^\\alpha)$。\n\n对于每条边 $(x,y) \\in E$，算法按以下步骤进行：\n\n**步骤 1：图预处理与最短路径度量**\n首先，处理图 $G=(V,E)$ 以计算所有可能参与运输成本计算的顶点对 $(u,v)$ 的最短路径距离 $d_G(u,v)$。对于给定的边 $(x,y)$，运输发生在支撑集 $S_x = \\{x\\} \\cup N(x)$ 和 $S_y = \\{y\\} \\cup N(y)$ 之间。为了处理所有边，最有效的方法是预先计算图 $G$ 的所有顶点对最短路径（APSP）矩阵。由于该图是简单无权图，这可以通过从每个顶点 $v \\in V$ 开始运行广度优先搜索（BFS）来完成。单次 BFS 的复杂度是 $O(|V|+|E|)$。对所有 $|V|$ 个顶点执行此操作，构建完整距离矩阵 $d_G$ 的总复杂度为 $O(|V|(|V|+|E|))$。\n\n**步骤 2：定义概率测度**\n对于度为 $\\deg(z)$ 的给定顶点 $z \\in V$，懒惰随机游走测度 $m_z^\\alpha$ 由懒惰参数 $\\alpha \\in [0,1]$ 定义如下：\n- $m_z^\\alpha(z) = \\alpha$（中心顶点上的质量）\n- 对于每个邻居 $u \\in N(z)$，$m_z^\\alpha(u) = \\frac{1-\\alpha}{\\deg(z)}$\n- 对于所有其他顶点 $v \\notin \\{z\\} \\cup N(z)$，$m_z^\\alpha(v) = 0$\n\n该测度的支撑集 $S_z = \\{u \\in V \\mid m_z^\\alpha(u)  0\\}$ 是 $z$ 的闭邻域，即 $S_z = \\{z\\} \\cup N(z)$。该集合的大小为 $|S_z| = 1 + \\deg(z)$。总质量为 $\\sum_{u \\in S_z} m_z^\\alpha(u) = \\alpha + \\deg(z) \\left(\\frac{1-\\alpha}{\\deg(z)}\\right) = \\alpha + (1-\\alpha) = 1$，这证实了它是一个有效的概率测度。\n\n**步骤 3：将 Wasserstein 距离构建为线性规划**\nWasserstein 1-距离 $W_1(m_x^\\alpha, m_y^\\alpha)$ 是一个最优运输问题的解。它可以通过求解基于 Kantorovich 公式的线性规划（LP）问题来找到。目标是找到一个最优耦合（运输方案）$\\pi(u,v)$，该方案指定了从每个顶点 $u \\in S_x$ 移动到每个顶点 $v \\in S_y$ 的质量数量，以最小化总运输成本。\n\n该线性规划构建如下：\n- **变量**：变量是运输方案的元素 $\\pi(u,v)$，其中 $u \\in S_x$ 且 $v \\in S_y$。变量的数量为 $|S_x| \\times |S_y| = (1+\\deg(x))(1+\\deg(y))$。\n- **目标函数**：最小化总成本，即所有运输质量乘以其各自的行进距离的总和：\n$$ \\text{Minimize} \\quad \\sum_{u \\in S_x} \\sum_{v \\in S_y} \\pi(u,v) d_G(u,v) $$\n- **约束条件**：\n    1. **非负性**：对于所有 $u \\in S_x, v \\in S_y$，$\\pi(u,v) \\ge 0$。\n    2. **源边际约束**：从任一顶点 $u \\in S_x$ 运出的总质量必须等于最初在 $u$ 处的质量：\n    $$ \\sum_{v \\in S_y} \\pi(u,v) = m_x^\\alpha(u) \\quad \\forall u \\in S_x $$\n    共有 $|S_x| = 1+\\deg(x)$ 个此类约束。\n    3. **目标边际约束**：运入任一顶点 $v \\in S_y$ 的总质量必须等于 $v$ 处所需的质量：\n    $$ \\sum_{u \\in S_x} \\pi(u,v) = m_y^\\alpha(v) \\quad \\forall v \\in S_y $$\n    共有 $|S_y| = 1+\\deg(y)$ 个此类约束。\n\n该线性规划的解在 `scipy` 中用 `res.fun` 表示，它给出了 $W_1(m_x^\\alpha, m_y^\\alpha)$ 的值。然后曲率计算为 $\\kappa_\\alpha(x,y) = 1 - W_1(m_x^\\alpha,m_y^\\alpha)$。\n\n**步骤 4：计算复杂度分析**\n总体复杂度取决于图的结构。\n\n- **APSP 预计算**：如前所述，计算距离矩阵 $d_G$ 的成本为 $O(|V|(|V|+|E|))$。这是一次性成本。对于 $|E| \\approx O(|V|)$ 的稀疏图，这简化为 $O(|V|^2)$。\n\n- **每条边 $(x,y) \\in E$ 的曲率计算**：\n    - **LP 规模**：变量数量为 $N_{var} = (1+\\deg(x))(1+\\deg(y))$，等式约束数量为 $N_{con} = (1+\\deg(x)) + (1+\\deg(y))$。\n    - **LP 构建**：构建成本向量需要在预计算的距离矩阵中进行 $N_{var}$ 次查找。构建约束矩阵 `A_eq` 涉及将 $2 \\cdot N_{var}$ 个非零条目（每个变量 $\\pi(u,v)$ 出现在一个源约束和一个目标约束中）放入一个大小为 $N_{con} \\times N_{var}$ 的矩阵中。此构建过程耗时 $O(N_{var} \\cdot N_{con})$。\n    - **LP 求解**：求解线性规划的复杂度（例如，使用内点法）是 $N_{var}$ 和 $N_{con}$ 的多项式。一个保守的估计是 $O(N_{var}^3)$。对于边 $(x,y)$ 的支撑集，这变为 $O(( (1+\\deg(x))(1+\\deg(y)) )^3)$。使用稀疏支撑集（$S_x, S_y$）至关重要，因为在整个顶点集 $V$ 上的线性规划将涉及 $O(|V|^2)$ 个变量，这对于大图来说是难以处理的。\n\n- **总复杂度**：计算所有 $|E|$ 条边的曲率的总时间是预处理成本和每条边计算成本的总和：\n$$ T_{total} = O(|V|(|V|+|E|)) + \\sum_{(x,y) \\in E} T_{LP}(1+\\deg(x), 1+\\deg(y)) $$\n其中 $T_{LP}$ 是为一条边建立和求解线性规划的时间。在最大度为 $\\Delta_{max}$ 的图中，每条边的成本是有界的，求和项变为 $O(|E| \\cdot T_{LP}(\\Delta_{max}, \\Delta_{max}))$。算法的效率在很大程度上取决于图的局部度数性质。\n\n所提供的 Python 实现遵循此逻辑。它使用 `numpy` 进行高效的数组操作，并使用 `scipy.optimize.linprog` 来求解每条边的最优运输问题。",
            "answer": "```python\nimport numpy as np\nfrom scipy.optimize import linprog\nfrom collections import deque\n\ndef compute_ollivier_ricci(adj, alpha):\n    \"\"\"\n    Computes the Ollivier-Ricci curvature for all edges in a graph.\n\n    Args:\n        adj (dict): An adjacency list representation of the graph.\n        alpha (float): The laziness parameter, in [0, 1].\n\n    Returns:\n        list: A list of curvature values for each edge, ordered lexicographically.\n    \"\"\"\n    num_vertices = len(adj)\n    \n    # Step 1: Compute All-Pairs Shortest Paths (APSP) using BFS from each node\n    dist_matrix = np.full((num_vertices, num_vertices), np.inf)\n    for i in range(num_vertices):\n        dist_matrix[i, i] = 0\n        q = deque([(i, 0)])\n        visited = {i}\n        while q:\n            u, d = q.popleft()\n            for v in adj[u]:\n                if v not in visited:\n                    visited.add(v)\n                    dist_matrix[i, v] = d + 1\n                    dist_matrix[v, i] = d + 1\n                    q.append((v, d + 1))\n\n    # Get a sorted list of unique edges\n    edges = set()\n    for u, neighbors in adj.items():\n        for v in neighbors:\n            if u  v:\n                edges.add((u, v))\n    sorted_edges = sorted(list(edges))\n\n    curvatures = []\n\n    for x, y in sorted_edges:\n        # Step 2: Define probability measures and their supports\n        deg_x = len(adj[x])\n        deg_y = len(adj[y])\n        \n        # Supports are the closed neighborhoods\n        S_x = sorted([x] + adj[x])\n        S_y = sorted([y] + adj[y])\n        \n        p = len(S_x)\n        q = len(S_y)\n        \n        # Measures m_x and m_y\n        m_x = np.zeros(p)\n        for i, u in enumerate(S_x):\n            if u == x:\n                m_x[i] = alpha\n            else:\n                m_x[i] = (1 - alpha) / deg_x if deg_x > 0 else 0\n\n        m_y = np.zeros(q)\n        for j, v in enumerate(S_y):\n            if v == y:\n                m_y[j] = alpha\n            else:\n                m_y[j] = (1 - alpha) / deg_y if deg_y > 0 else 0\n\n        # Step 3: Formulate and solve the LP for Wasserstein distance\n        \n        # Cost vector c\n        cost_vector = np.zeros(p * q)\n        for i in range(p):\n            for j in range(q):\n                cost_vector[i * q + j] = dist_matrix[S_x[i], S_y[j]]\n\n        # Equality constraints A_eq * pi = b_eq\n        A_eq = np.zeros((p + q, p * q))\n        for i in range(p):\n            A_eq[i, i * q : (i + 1) * q] = 1  # Source marginals\n        for j in range(q):\n            A_eq[p + j, j::q] = 1           # Target marginals\n\n        b_eq = np.concatenate([m_x, m_y])\n\n        # Bounds for variables (pi_ij >= 0)\n        bounds = (0, None)\n        \n        # Solve the LP\n        # Use 'highs' method for robustness and performance\n        res = linprog(c=cost_vector, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')\n        \n        w1_distance = res.fun\n        \n        # Curvature is 1 - W_1 / d(x,y). Since d(x,y)=1 for an edge, it's 1 - W_1.\n        kappa = 1 - w1_distance\n        curvatures.append(kappa)\n\n    return curvatures\n    \ndef solve():\n    \"\"\"\n    Defines test cases, computes curvatures, and prints the final result.\n    \"\"\"\n    # Test suite definition\n    # G1: Path on 4 vertices\n    g1_adj = {0: [1], 1: [0, 2], 2: [1, 3], 3: [2]}\n    alpha1 = 0.5\n\n    # G2: Triangle on 3 vertices\n    g2_adj = {0: [1, 2], 1: [0, 2], 2: [0, 1]}\n    alpha2 = 0.0\n\n    # G3: Barbell graph\n    g3_adj = {\n        0: [1, 2, 3], 1: [0, 2], 2: [0, 1],\n        3: [0, 4, 5], 4: [3, 5], 5: [3, 4]\n    }\n    alpha3 = 0.5\n    \n    # G4: Cycle on 4 vertices\n    g4_adj = {0: [1, 3], 1: [0, 2], 2: [1, 3], 3: [0, 2]}\n    alpha4 = 1.0\n\n    test_cases = [\n        (g1_adj, alpha1),\n        (g2_adj, alpha2),\n        (g3_adj, alpha3),\n        (g4_adj, alpha4)\n    ]\n\n    all_results = []\n    for adj, alpha in test_cases:\n        results_for_case = compute_ollivier_ricci(adj, alpha)\n        all_results.extend(results_for_case)\n\n    # Format output as a comma-separated list of floats rounded to 6 decimal places\n    output_str = f\"[{','.join(f'{r:.6f}' for r in all_results)}]\"\n    print(output_str)\n\nsolve()\n```"
        }
    ]
}