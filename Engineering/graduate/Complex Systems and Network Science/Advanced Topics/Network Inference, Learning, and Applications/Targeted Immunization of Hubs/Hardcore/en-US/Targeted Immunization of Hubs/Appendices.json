{
    "hands_on_practices": [
        {
            "introduction": "Targeted immunization strategies begin with a fundamental task: identifying the most connected nodes, or hubs, in a network. This exercise moves beyond theoretical discussion to address the practical, computational challenge of performing this task efficiently on large-scale networks, where an algorithm's scalability is paramount. You will implement a linear-time sorting method to find top-degree hubs, a core skill for any network scientist analyzing real-world data .",
            "id": "4306971",
            "problem": "You are given an undirected simple graph defined over a set of nodes labeled from $0$ to $n-1$, and an edge list as pairs of node identifiers. The concept of targeted immunization of hubs is modeled by selecting the nodes with largest degree (number of incident edges) and immunizing those nodes first. The objective is to design an algorithm that identifies the top-degree hubs efficiently on sparse graphs and to analyze the algorithm’s memory complexity in terms of the number of scalar slots it allocates in arrays and lists, excluding the memory of the input itself. The algorithm should adhere to the following constraints and goals:\n\n- Fundamental base definitions: A graph is specified by $n$ nodes and $m$ edges. The degree of a node is the number of edges that connect to it. Hubs are nodes with high degree. Sparse graphs satisfy $m = \\Theta(n)$.\n- Time complexity target: For sparse graphs, the algorithm must run in $O(m)$ time in the asymptotic sense, where $m$ is the number of edges.\n- Memory complexity target: Analyze the auxiliary memory used by the algorithm (excluding the memory of the given input). Report this analysis for each test case as a count of scalar slots (for example, array entries and list elements) allocated and used by the algorithm, which is a unitless integer.\n\nThe algorithm must:\n- Compute node degrees from the edge list.\n- Identify the top $k$ nodes with the highest degree for immunization.\n- Break ties by selecting lower node identifiers first when degrees are equal.\n- Return the list of selected node identifiers in nonincreasing order of degree (with ascending identifiers within equal-degree groups), truncated to the requested $k$.\n\nThe output for each test case must be a pair consisting of:\n- A list of node identifiers representing the top hubs to immunize.\n- A single integer representing the total auxiliary memory scalar slot count used by the algorithm.\n\nYour program should produce a single line of output containing the results for all test cases as a comma-separated list enclosed in square brackets. Each test case result must be represented as a two-element list of the form $[\\text{hub\\_list}, \\text{memory\\_count}]$, and your final output should be formatted as, for example, $[[\\dots, \\dots],[\\dots, \\dots],\\dots]$ on a single line with no additional text.\n\nUse the following test suite of parameter values:\n- Test case $1$ (general case with heterogeneous degrees):\n  - $n = 12$\n  - $k = 3$\n  - Edge list: $[(0,1),(0,2),(0,3),(0,4),(0,5),(0,6),(3,7),(3,8),(3,9),(7,10),(1,2),(4,5),(8,9),(10,11)]$\n- Test case $2$ (star graph with a single dominant hub):\n  - $n = 10$\n  - $k = 2$\n  - Edge list: $[(0,1),(0,2),(0,3),(0,4),(0,5),(0,6),(0,7),(0,8),(0,9)]$\n- Test case $3$ (multiple hubs with equal degree and explicit ties):\n  - $n = 8$\n  - $k = 4$\n  - Edge list: $[(0,1),(0,2),(0,3),(4,5),(4,6),(4,7),(1,2),(5,6)]$\n- Test case $4$ (boundary condition with zero hubs requested):\n  - $n = 5$\n  - $k = 0$\n  - Edge list: $[(0,1),(2,3)]$\n\nAlgorithmic and analysis requirements:\n- Treat the graph as undirected and simple, with no self-loops. If an edge $u,v$ appears, both $u$ and $v$ have their degree incremented by $1$.\n- Correctness criteria: The list of selected hubs must be in nonincreasing order of degree, with ties broken by ascending node identifier due to a deterministic insertion order.\n- Time complexity analysis: Provide a principled derivation showing why the algorithm runs in $O(m)$ time for sparse graphs, starting from fundamental definitions and well-tested facts, without using shortcut formulas.\n- Memory complexity analysis: Report the auxiliary memory scalar slot count per test case. For concreteness, count the degrees array of length $n$, the bucket array of length $D+1$ (where $D$ is the maximum degree encountered), and the total number of node entries stored across all buckets (which sums to $n$), yielding a total count of $2n + (D+1)$. Report this integer for each test case.\n\nFinal output format:\n- Your program should produce a single line containing the results for the four test cases as a single list in the format $[[\\text{list\\_for\\_case1}, \\text{mem1}],[\\text{list\\_for\\_case2}, \\text{mem2}],[\\text{list\\_for\\_case3}, \\text{mem3}],[\\text{list\\_for\\_case4}, \\text{mem4}]]$.",
            "solution": "An algorithm is designed to identify high-degree hub nodes in a sparse network for targeted immunization, adhering to specified complexity constraints. The solution is presented in three parts: a conceptual outline of the algorithm, a detailed analysis of its time and memory complexity, and the step-by-step derivation of results for the provided test cases.\n\n### Algorithmic Design and Principles\n\nThe problem requires an algorithm to find the top $k$ nodes with the highest degree in a graph specified by $n$ nodes and $m$ edges, with a time complexity of $O(m)$ for sparse graphs where $m = \\Theta(n)$.\n\nA naive approach would involve computing the degree of all $n$ nodes and then sorting them, which would take at least $O(n \\log n)$ time. For sparse graphs, where $n$ is proportional to $m$, an $O(n \\log n)$ complexity is not compliant with the required $O(m)$ target. Therefore, a more efficient, linear-time sorting method is necessary.\n\nSince the values we are sorting by (the node degrees) are integers within a constrained range (from $0$ to a maximum degree $D  n$), a **bucket sort** (a form of counting sort) is the most appropriate and efficient strategy. The algorithm proceeds in three main steps:\n\n1.  **Degree Computation**: An array, `degrees`, of size $n$ is initialized to zeros. We iterate through the $m$ edges in the input list. For each edge $(u, v)$, we increment the degree counters for nodes $u$ and $v$. This step correctly computes the degree of every node in the graph.\n\n2.  **Bucket-based Sorting**: Instead of a comparison-based sort, we group nodes by their computed degree. We create an auxiliary data structure, `buckets`, which is an array of lists. The size of this array is $D+1$, where $D$ is the maximum degree observed in the graph. We then iterate through each node $i$ from $0$ to $n-1$ and place its identifier into the list at `buckets[degrees[i]]`. This operation populates the buckets, with `buckets[d]` containing a list of all nodes of degree $d$. Crucially, by iterating through nodes in ascending order of their identifiers ($i=0, 1, \\dots, n-1$), we ensure that the list within each bucket is inherently sorted by node identifier. This elegantly handles the specified tie-breaking rule (lower node identifiers are chosen first for the same degree) without any extra sorting or processing.\n\n3.  **Extraction of Top-k Hubs**: To find the top $k$ hubs, we iterate through the `buckets` array in reverse order of degree, from $D$ down to $0$. We collect the node identifiers from each bucket and add them to our result list until we have gathered $k$ nodes. Since the nodes within each bucket are already sorted by identifier, the overall resulting list will be correctly ordered according to both criteria: nonincreasing degree, with ties broken by ascending node identifier.\n\n### Complexity Analysis\n\n**Time Complexity**:\n-   **Step 1 (Degree Computation)**: Initializing the `degrees` array of size $n$ takes $O(n)$ time. Iterating through $m$ edges to update degrees takes $O(m)$ time. The total time for this step is $O(n+m)$.\n-   **Step 2 (Bucket Sorting)**: Finding the maximum degree $D$ requires one pass over the `degrees` array, taking $O(n)$ time. Initializing the `buckets` array of size $D+1$ takes $O(D)$ time. Populating the buckets requires iterating through all $n$ nodes, taking $O(n)$ time. The total time for this step is $O(n+D)$.\n-   **Step 3 (Extraction)**: Iterating through the buckets from $D$ down to $0$ and collecting up to $k$ nodes takes at most $O(D+n)$ time, as in the worst case we might scan all buckets and their contents.\n\nThe total time complexity is the sum of these steps: $T(n, m) = O(n+m) + O(n+D) + O(D+n) = O(n+m+D)$. In a simple graph with $n$ nodes, the maximum possible degree is $D \\le n-1$. Therefore, the complexity simplifies to $O(n+m)$. For the specified case of sparse graphs where $m=\\Theta(n)$, we have $m \\ge c \\cdot n$ for some constant $c0$, which implies that $O(n+m) = O(m)$. Thus, the algorithm meets the required $O(m)$ time complexity.\n\n**Memory Complexity**:\nThe problem asks for an analysis of the auxiliary memory, defined as the total count of scalar slots used, excluding the storage for the input edge list. Following the specified counting rule, the memory usage is broken down as follows:\n-   A `degrees` array of length $n$ is allocated to store the degree of each node. This uses $n$ scalar slots.\n-   A `buckets` data structure is used for sorting. This is an array of lists.\n    -   The primary array, which holds references to the lists for each degree, has a size of $D+1$, where $D$ is the maximum degree. This accounts for $D+1$ scalar slots.\n    -   The total number of elements stored across all the lists within the buckets is exactly $n$, as each of the $n$ nodes is placed into exactly one bucket. This accounts for an additional $n$ scalar slots.\n-   The total auxiliary memory scalar slot count is the sum of these components: $n + (D+1) + n = 2n + D + 1$. This integer value is calculated for each test case.\n\n### Test Case Execution\n\n**Test Case 1**: $n = 12$, $k = 3$\n-   Degrees: $\\text{deg}(0)=6, \\text{deg}(1)=2, \\text{deg}(2)=2, \\text{deg}(3)=4, \\text{deg}(4)=2, \\text{deg}(5)=2, \\text{deg}(6)=1, \\text{deg}(7)=2, \\text{deg}(8)=2, \\text{deg}(9)=2, \\text{deg}(10)=2, \\text{deg}(11)=1$.\n-   Maximum degree $D=6$.\n-   Buckets: $\\text{buckets}[6] = [0]$, $\\text{buckets}[4] = [3]$, $\\text{buckets}[2] = [1, 2, 4, 5, 7, 8, 9, 10]$, $\\text{buckets}[1] = [6, 11]$.\n-   Top $k=3$ hubs: From degree $6$, we get node $0$. From degree $4$, we get node $3$. From degree $2$, we get node $1$.\n-   Hub list: $[0, 3, 1]$.\n-   Memory count: $2n + D + 1 = 2(12) + 6 + 1 = 24 + 7 = 31$.\n-   Result: $[[0, 3, 1], 31]$.\n\n**Test Case 2**: $n = 10$, $k = 2$\n-   Degrees: $\\text{deg}(0)=9$, $\\text{deg}(i)=1$ for $i \\in \\{1, \\dots, 9\\}$.\n-   Maximum degree $D=9$.\n-   Buckets: $\\text{buckets}[9] = [0]$, $\\text{buckets}[1] = [1, 2, 3, 4, 5, 6, 7, 8, 9]$.\n-   Top $k=2$ hubs: From degree $9$, we get node $0$. From degree $1$, we get node $1$ (the first in the sorted list).\n-   Hub list: $[0, 1]$.\n-   Memory count: $2n + D + 1 = 2(10) + 9 + 1 = 20 + 10 = 30$.\n-   Result: $[[0, 1], 30]$.\n\n**Test Case 3**: $n = 8$, $k = 4$\n-   Degrees: $\\text{deg}(0)=3, \\text{deg}(1)=2, \\text{deg}(2)=2, \\text{deg}(3)=1, \\text{deg}(4)=3, \\text{deg}(5)=2, \\text{deg}(6)=2, \\text{deg}(7)=1$.\n-   Maximum degree $D=3$.\n-   Buckets: $\\text{buckets}[3] = [0, 4]$, $\\text{buckets}[2] = [1, 2, 5, 6]$, $\\text{buckets}[1] = [3, 7]$.\n-   Top $k=4$ hubs: From degree $3$, we get nodes $0, 4$. From degree $2$, we get nodes $1, 2$.\n-   Hub list: $[0, 4, 1, 2]$.\n-   Memory count: $2n + D + 1 = 2(8) + 3 + 1 = 16 + 4 = 20$.\n-   Result: $[[0, 4, 1, 2], 20]$.\n\n**Test Case 4**: $n = 5$, $k = 0$\n-   Degrees: $\\text{deg}(0)=1, \\text{deg}(1)=1, \\text{deg}(2)=1, \\text{deg}(3)=1, \\text{deg}(4)=0$.\n-   Maximum degree $D=1$.\n-   Since $k=0$, the list of hubs is empty.\n-   Hub list: $[]$.\n-   Memory count: $2n + D + 1 = 2(5) + 1 + 1 = 10 + 2 = 12$.\n-   Result: $[[], 12]$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the hub identification problem for all test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"n\": 12, \"k\": 3,\n            \"edges\": [(0,1),(0,2),(0,3),(0,4),(0,5),(0,6),(3,7),(3,8),(3,9),(7,10),(1,2),(4,5),(8,9),(10,11)]\n        },\n        {\n            \"n\": 10, \"k\": 2,\n            \"edges\": [(0,1),(0,2),(0,3),(0,4),(0,5),(0,6),(0,7),(0,8),(0,9)]\n        },\n        {\n            \"n\": 8, \"k\": 4,\n            \"edges\": [(0,1),(0,2),(0,3),(4,5),(4,6),(4,7),(1,2),(5,6)]\n        },\n        {\n            \"n\": 5, \"k\": 0,\n            \"edges\": [(0,1),(2,3)]\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        n = case[\"n\"]\n        k = case[\"k\"]\n        edges = case[\"edges\"]\n\n        # If n=0, the graph is empty. However, all test cases have n  0.\n        # This implementation assumes n  0 as per the test suite.\n\n        # Step 1: Compute node degrees.\n        # Initialize a degrees array of size n with zeros.\n        degrees = np.zeros(n, dtype=int)\n        for u, v in edges:\n            degrees[u] += 1\n            degrees[v] += 1\n        \n        # Determine the maximum degree D. If there are no edges, max_degree is 0.\n        if degrees.size  0:\n            max_degree = int(np.max(degrees))\n        else: # This case is not hit by the provided tests, but for completeness.\n            max_degree = 0\n\n        # Calculate memory complexity as per the problem's formula.\n        # Total auxiliary memory scalar slot count = 2n + (D+1).\n        memory_count = 2 * n + (max_degree + 1)\n\n        # Handle the k=0 boundary case early.\n        if k == 0:\n            all_results.append([[], memory_count])\n            continue\n        \n        # Step 2: Bucket-based sorting.\n        # Create an array of lists (buckets), indexed by degree.\n        buckets = [[] for _ in range(max_degree + 1)]\n        # Populate buckets. Nodes are added in ascending order of their identifiers\n        # automatically satisfying the tie-breaking rule within each bucket.\n        for i in range(n):\n            node_degree = degrees[i]\n            buckets[node_degree].append(i)\n\n        # Step 3: Extract top-k hubs.\n        hubs = []\n        count = 0\n        # Iterate from the highest degree bucket down to the lowest.\n        for d in range(max_degree, -1, -1):\n            nodes_at_this_degree = buckets[d]\n            # The nodes in this list are already sorted by identifier.\n            for node in nodes_at_this_degree:\n                if count  k:\n                    hubs.append(node)\n                    count += 1\n                else:\n                    # Found k hubs, no need to check further.\n                    break\n            if count = k:\n                # Found k hubs, no need to check lower-degree buckets.\n                break\n        \n        all_results.append([hubs, memory_count])\n\n    # Final print statement must produce the exact required format.\n    # The repr() function gives a string representation like '[[...], ...]'\n    # which has spaces. The required format has no spaces.\n    # We construct the string manually to ensure no spaces.\n    final_output_str = repr(all_results).replace(\" \",\"\")\n    print(final_output_str)\n\nsolve()\n\n```"
        },
        {
            "introduction": "After identifying the hubs, a public health planner must answer a critical question: how many nodes must be immunized to effectively suppress an epidemic? This practice exercise provides a direct way to answer this by connecting a specific intervention—removing top-degree nodes—to its impact on the network's epidemic threshold. By calculating the change in the network's spectral radius, you will determine the minimal immunization effort required to halt disease spread, translating network theory into a quantitative public health strategy .",
            "id": "4306970",
            "problem": "You are given an undirected, simple network represented by an adjacency matrix $A \\in \\{0,1\\}^{n \\times n}$ with $A$ symmetric and $A_{ii} = 0$ for all $i$. Consider the Susceptible-Infected-Susceptible (SIS) epidemic process with infection rate $\\beta$ and recovery rate $\\mu$. A well-tested and widely used mean-field threshold condition relates the spectral radius (largest eigenvalue) $\\lambda_1(A_{\\text{res}})$ of the residual adjacency matrix $A_{\\text{res}}$ (obtained after immunization) to the dimensionless ratio $\\beta/\\mu$, stating that the epidemic dies out when the condition $(\\beta/\\mu)  1/\\lambda_1(A_{\\text{res}})$ holds.\n\nTargeted immunization of hubs is implemented as follows. Define the degree of node $i$ as $k_i = \\sum_{j=1}^{n} A_{ij}$. Order the nodes in nonincreasing degree: nodes with larger $k_i$ precede nodes with smaller $k_i$, and ties are broken deterministically by ascending node index (that is, if $k_p = k_q$ and $p  q$, then node $p$ precedes node $q$). For an integer $m$ with $0 \\le m \\le n$, immunize the first $m$ nodes in this ordering, which is defined to delete the corresponding $m$ rows and $m$ columns from $A$. The residual adjacency matrix $A_{\\text{res}}$ is the principal submatrix of $A$ indexed by the remaining, non-immunized nodes. If $m = n$, the residual adjacency matrix $A_{\\text{res}}$ is the empty matrix, and by convention its largest eigenvalue is taken to be $\\lambda_1(A_{\\text{res}}) = 0$.\n\nYour task is to write a program that, for each provided test case, determines the minimal integer $m$ such that the strict inequality $1/\\lambda_1(A_{\\text{res}})  \\beta/\\mu$ is satisfied when immunizing the first $m$ nodes in the degree-based ordering described above. If $m = 0$ already satisfies the inequality, then the minimal $m$ is $0$. If immunizing all $n$ nodes is required, then the minimal $m$ is $n$, and the inequality holds because $1/\\lambda_1(A_{\\text{res}})$ is interpreted as $+\\infty$ when $\\lambda_1(A_{\\text{res}}) = 0$ and $\\beta/\\mu$ is finite and positive.\n\nInput is implicit: your program must use the following test suite of adjacency matrices $A$ (with nodes indexed from $0$ to $n-1$) and ratios $\\beta/\\mu$. Each adjacency matrix is given as a list of lists with entries in $\\{0,1\\}$, and each ratio is a positive real number.\n\n- Test case $1$ (a path on $5$ nodes with edges $(0,1)$, $(1,2)$, $(2,3)$, $(3,4)$), with $\\beta/\\mu = 0.5$:\n  $$\n  A = \\begin{bmatrix}\n  0  1  0  0  0 \\\\\n  1  0  1  0  0 \\\\\n  0  1  0  1  0 \\\\\n  0  0  1  0  1 \\\\\n  0  0  0  1  0\n  \\end{bmatrix}\n  $$\n- Test case $2$ (a star on $6$ nodes with center node $0$ connected to nodes $1,2,3,4,5$), with $\\beta/\\mu = 0.6$:\n  $$\n  A = \\begin{bmatrix}\n  0  1  1  1  1  1 \\\\\n  1  0  0  0  0  0 \\\\\n  1  0  0  0  0  0 \\\\\n  1  0  0  0  0  0 \\\\\n  1  0  0  0  0  0 \\\\\n  1  0  0  0  0  0\n  \\end{bmatrix}\n  $$\n- Test case $3$ (a complete graph on $4$ nodes), with $\\beta/\\mu = 0.8$:\n  $$\n  A = \\begin{bmatrix}\n  0  1  1  1 \\\\\n  1  0  1  1 \\\\\n  1  1  0  1 \\\\\n  1  1  1  0\n  \\end{bmatrix}\n  $$\n- Test case $4$ (a cycle on $6$ nodes with edges $(i,(i+1)\\bmod 6)$ for $i \\in \\{0,1,2,3,4,5\\}$), with $\\beta/\\mu = 0.9$:\n  $$\n  A = \\begin{bmatrix}\n  0  1  0  0  0  1 \\\\\n  1  0  1  0  0  0 \\\\\n  0  1  0  1  0  0 \\\\\n  0  0  1  0  1  0 \\\\\n  0  0  0  1  0  1 \\\\\n  1  0  0  0  1  0\n  \\end{bmatrix}\n  $$\n- Test case $5$ (a complete graph on $3$ nodes), with $\\beta/\\mu = 0.5$:\n  $$\n  A = \\begin{bmatrix}\n  0  1  1 \\\\\n  1  0  1 \\\\\n  1  1  0\n  \\end{bmatrix}\n  $$\n\nYour program must compute, for each test case, the minimal integer $m$ satisfying $1/\\lambda_1(A_{\\text{res}})  \\beta/\\mu$ under the targeted immunization rule defined above. For numerical computation of $\\lambda_1(A_{\\text{res}})$, the adjacency matrices are symmetric and real; use a method appropriate for symmetric matrices. If $A_{\\text{res}}$ is empty (that is, all nodes are immunized), define $\\lambda_1(A_{\\text{res}}) = 0$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, ordered in the same sequence as the test cases, for example $[m_1,m_2,m_3,m_4,m_5]$. The outputs are integers and no physical units are involved.",
            "solution": "The problem asks for the minimum number of nodes, $m$, to immunize in a network to suppress an epidemic, based on a given threshold condition. The immunization strategy is targeted, prioritizing nodes with the highest degree.\n\nThe core of the problem lies in the condition for epidemic eradication, given by the mean-field theory for a Susceptible-Infected-Susceptible (SIS) process on a network. The condition states that the epidemic will die out if the effective spreading rate is less than one. This translates to the inequality:\n$$\n\\frac{\\beta}{\\mu} \\lambda_1(A_{\\text{res}})  1\n$$\nwhere $\\beta$ is the infection rate, $\\mu$ is the recovery rate, and $\\lambda_1(A_{\\text{res}})$ is the spectral radius (the largest eigenvalue) of the adjacency matrix $A_{\\text{res}}$ of the residual network after immunization. The problem statement presents this strict inequality in the equivalent form:\n$$\n\\frac{1}{\\lambda_1(A_{\\text{res}})}  \\frac{\\beta}{\\mu}\n$$\nThis can be rearranged into a more computationally convenient form. Let $\\tau = \\beta/\\mu$ be the given ratio. We are looking for the smallest $m$ such that:\n$$\n\\lambda_1(A_{\\text{res}})  \\frac{1}{\\tau} \\quad \\text{or} \\quad \\lambda_1(A_{\\text{res}})  \\frac{\\mu}{\\beta}\n$$\nLet's define the threshold for the spectral radius as $\\lambda_{\\text{th}} = \\mu / \\beta$. Our goal is to find the minimum integer $m \\in \\{0, 1, \\dots, n\\}$ such that $\\lambda_1(A_{\\text{res}})  \\lambda_{\\text{th}}$.\n\nThe process to determine the minimal $m$ for a given network $A$ and ratio $\\tau = \\beta/\\mu$ follows a clear algorithmic procedure. We must iterate through possible values of $m$, starting from $m=0$, and for each $m$, check if the condition is satisfied. The first value of $m$ for which the condition holds is the minimal value.\n\nThe steps for each test case are as follows:\n1.  **Node Ordering for Immunization**: First, we must establish the priority order for immunization. This order is based on node degree, a measure of a node's connectivity.\n    a.  For each node $i$ in the network (indexed from $0$ to $n-1$), calculate its degree $k_i$, which is the sum of entries in the $i$-th row (or column) of the adjacency matrix $A$: $k_i = \\sum_{j=0}^{n-1} A_{ij}$.\n    b.  Create a list of all nodes, represented by their indices $\\{0, 1, \\dots, n-1\\}$.\n    c.  Sort this list of nodes in non-increasing order of their degrees.\n    d.  According to the problem's rule, any ties in degree are resolved by sorting the tied nodes by their original index in ascending order. This creates a unique, deterministic ordering of nodes for immunization.\n\n2.  **Iterative Search for Minimal $m$**: We search for the minimal number of immunized nodes $m$ by checking values sequentially, from $m=0$ to $m=n$.\n    a.  The loop begins with $m=0$, representing the case of no immunization.\n    b.  For a given $m$, we identify the set of nodes to be immunized. This set consists of the first $m$ nodes from the sorted list determined in Step 1. The remaining $n-m$ nodes form the residual network.\n    c.  Construct the residual adjacency matrix, $A_{\\text{res}}$. This is the principal submatrix of the original matrix $A$ formed by selecting only the rows and columns corresponding to the non-immunized (residual) nodes.\n    d.  Compute the spectral radius $\\lambda_1(A_{\\text{res}})$ of this residual matrix.\n        i.  If $m=n$, all nodes are immunized. The residual network is empty. By the problem's convention, the spectral radius of the empty matrix is $\\lambda_1(A_{\\text{res}}) = 0$.\n        ii. If $0 \\le m  n$, the residual network is non-empty. Since the original adjacency matrix $A$ is real and symmetric, any principal submatrix $A_{\\text{res}}$ is also real and symmetric. Therefore, all its eigenvalues are real. Furthermore, because the entries of $A_{\\text{res}}$ are non-negative, the Perron-Frobenius theorem guarantees that its spectral radius (largest eigenvalue) is real, non-negative, and is equal to its largest eigenvalue. We can compute all eigenvalues and find the maximum.\n    e.  Compare the computed spectral radius $\\lambda_1(A_{\\text{res}})$ with the threshold $\\lambda_{\\text{th}} = \\mu/\\beta$.\n    f.  If the condition $\\lambda_1(A_{\\text{res}})  \\lambda_{\\text{th}}$ is satisfied, the current value of $m$ is the minimal number of immunizations required. We record this value as the solution for the current test case and stop the search for this case.\n    g.  If the condition is not met, we increment $m$ by $1$ and repeat from step 2b. The process is guaranteed to terminate, as for $m=n$, $\\lambda_1(A_{\\text{res}}) = 0$, and the condition $0  \\lambda_{\\text{th}}$ will always be true since $\\beta$ and $\\mu$ are positive rates.\n\nFor implementation, we use numerical libraries to perform matrix operations. Specifically, for a given $A_{\\text{res}}$, we can use an eigenvalue solver optimized for real symmetric matrices to find its eigenvalues. The largest of these real values is the spectral radius $\\lambda_1(A_{\\text{res}})$. This systematic process is applied to each of the provided test cases to find the corresponding minimal $m$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the targeted immunization problem for a given suite of test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1\n        (\n            np.array([\n                [0, 1, 0, 0, 0],\n                [1, 0, 1, 0, 0],\n                [0, 1, 0, 1, 0],\n                [0, 0, 1, 0, 1],\n                [0, 0, 0, 1, 0]\n            ]), \n            0.5\n        ),\n        # Test case 2\n        (\n            np.array([\n                [0, 1, 1, 1, 1, 1],\n                [1, 0, 0, 0, 0, 0],\n                [1, 0, 0, 0, 0, 0],\n                [1, 0, 0, 0, 0, 0],\n                [1, 0, 0, 0, 0, 0],\n                [1, 0, 0, 0, 0, 0]\n            ]), \n            0.6\n        ),\n        # Test case 3\n        (\n            np.array([\n                [0, 1, 1, 1],\n                [1, 0, 1, 1],\n                [1, 1, 0, 1],\n                [1, 1, 1, 0]\n            ]), \n            0.8\n        ),\n        # Test case 4\n        (\n            np.array([\n                [0, 1, 0, 0, 0, 1],\n                [1, 0, 1, 0, 0, 0],\n                [0, 1, 0, 1, 0, 0],\n                [0, 0, 1, 0, 1, 0],\n                [0, 0, 0, 1, 0, 1],\n                [1, 0, 0, 0, 1, 0]\n            ]), \n            0.9\n        ),\n        # Test case 5\n        (\n            np.array([\n                [0, 1, 1],\n                [1, 0, 1],\n                [1, 1, 0]\n            ]), \n            0.5\n        )\n    ]\n\n    results = []\n    \n    for A, beta_mu_ratio in test_cases:\n        # Number of nodes\n        n = A.shape[0]\n        \n        # Calculate the threshold for the spectral radius\n        lambda_threshold = 1.0 / beta_mu_ratio\n        \n        # Step 1: Determine the node ordering for immunization\n        # Calculate degrees\n        degrees = A.sum(axis=1)\n        \n        # Create a list of (degree, index) tuples for sorting\n        nodes_with_degrees = [(degrees[i], i) for i in range(n)]\n        \n        # Sort nodes: primary key is degree (descending), secondary key is index (ascending)\n        nodes_with_degrees.sort(key=lambda x: (-x[0], x[1]))\n        \n        # Get the sorted list of node indices for immunization\n        immunization_order = [node[1] for node in nodes_with_degrees]\n        \n        # Step 2: Iteratively find the minimal m\n        for m in range(n + 1):\n            # Determine the set of residual nodes\n            if m == 0:\n                residual_nodes_indices = list(range(n))\n            else:\n                nodes_to_immunize = set(immunization_order[:m])\n                all_nodes = set(range(n))\n                residual_nodes_indices = sorted(list(all_nodes - nodes_to_immunize))\n\n            # Calculate the spectral radius of the residual matrix\n            num_residual_nodes = len(residual_nodes_indices)\n            \n            if num_residual_nodes == 0:\n                # By convention, if the residual matrix is empty, lambda_1 = 0\n                lambda_1_res = 0.0\n            else:\n                # Construct the residual adjacency matrix A_res\n                A_res = A[np.ix_(residual_nodes_indices, residual_nodes_indices)]\n                \n                # Check for an empty matrix which can occur if num_residual_nodes is 0\n                if A_res.size == 0:\n                    lambda_1_res = 0.0\n                else:\n                    # For a real symmetric matrix, spectral radius is the max eigenvalue\n                    # eigvalsh is optimized for Hermitian (includes real symmetric) matrices\n                    eigenvalues = np.linalg.eigvalsh(A_res)\n                    lambda_1_res = np.max(eigenvalues) if eigenvalues.size  0 else 0.0\n\n            # Check if the condition is met\n            if lambda_1_res  lambda_threshold:\n                results.append(m)\n                break\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "While targeting hubs is a powerful heuristic, it may not always be the most efficient strategy, and different theoretical models can offer conflicting recommendations. This exercise delves into the strategic complexities of immunization by asking you to evaluate a trade-off between two different targeting schemes. By analyzing a composite risk metric that bridges two major theoretical frameworks, you will determine the conditions under which one strategy is superior to another, highlighting the importance of understanding model assumptions in making real-world decisions .",
            "id": "4306983",
            "problem": "Consider a Susceptible-Infected-Susceptible (SIS) spreading process on a large, static, undirected network with heavy-tailed degree heterogeneity. Let the disease transmission and recovery rates be fixed and uniform over nodes. Two established risk surrogates for sustained prevalence are: (i) in the quenched mean-field approximation, monotone dependence on the largest eigenvalue of the adjacency matrix, denoted by $\\,\\lambda_{1}\\,$, and (ii) in the heterogeneous mean-field approximation, monotone dependence on the ratio $\\,\\langle k^{2}\\rangle/\\langle k\\rangle\\,$, where $\\,\\langle k\\rangle\\,$ and $\\,\\langle k^{2}\\rangle\\,$ are the first and second moments of the degree distribution, respectively. Assume that steady-state prevalence is modeled by a convex combination of these surrogates after intervention, so that the composite risk metric\n$$\n\\Phi(\\alpha)\\;=\\;\\alpha\\,R_{\\mathrm{spec}}\\;+\\;(1-\\alpha)\\,R_{\\mathrm{mf}},\\quad \\alpha\\in[0,1],\n$$\nwith $\\,R_{\\mathrm{spec}}\\,$ proportional to $\\,\\lambda_{1}\\,$ and $\\,R_{\\mathrm{mf}}\\,$ proportional to $\\,\\langle k^{2}\\rangle/\\langle k\\rangle\\,$, provides a normalized prediction of prevalence relative to the pre-intervention baseline. Suppose a fixed budget allows one of two immunization strategies:\n\n- Strategy $\\,\\mathrm{H}\\,$: immunize the $\\,10\\,$ highest-degree hubs.\n- Strategy $\\,\\mathrm{M}\\,$: immunize $\\,40\\,$ moderate-degree nodes whose degrees are close to $\\,2\\langle k\\rangle\\,$.\n\nEmpirical measurement after intervention reports the following normalized post-intervention risk components (each reported as a fraction of its pre-intervention value):\n\n- For strategy $\\,\\mathrm{H}\\,$: $\\,R_{\\mathrm{spec}}^{(\\mathrm{H})}=0.55\\,$ and $\\,R_{\\mathrm{mf}}^{(\\mathrm{H})}=0.70\\,$.\n- For strategy $\\,\\mathrm{M}\\,$: $\\,R_{\\mathrm{spec}}^{(\\mathrm{M})}=0.80\\,$ and $\\,R_{\\mathrm{mf}}^{(\\mathrm{M})}=0.50\\,$.\n\nAssume the composite risk $\\,\\Phi(\\alpha)\\,$ is minimized by the strategy that yields the smaller value of $\\,\\Phi(\\alpha)\\,$. Under these conditions, which of the following statements is correct?\n\nA. There exists a unique $\\,\\alpha^{\\star}\\approx 0.44\\,$ such that for $\\,\\alpha\\alpha^{\\star}\\,$ strategy $\\,\\mathrm{H}\\,$ minimizes $\\,\\Phi(\\alpha)\\,$ and for $\\,\\alpha\\alpha^{\\star}\\,$ strategy $\\,\\mathrm{M}\\,$ minimizes $\\,\\Phi(\\alpha)\\,$.\n\nB. There exists a unique $\\,\\alpha^{\\star}\\approx 0.56\\,$ such that for $\\,\\alpha\\alpha^{\\star}\\,$ strategy $\\,\\mathrm{H}\\,$ minimizes $\\,\\Phi(\\alpha)\\,$ and for $\\,\\alpha\\alpha^{\\star}\\,$ strategy $\\,\\mathrm{M}\\,$ minimizes $\\,\\Phi(\\alpha)\\,$.\n\nC. There exists a unique $\\,\\alpha^{\\star}\\approx 0.44\\,$ such that for $\\,\\alpha\\alpha^{\\star}\\,$ strategy $\\,\\mathrm{H}\\,$ minimizes $\\,\\Phi(\\alpha)\\,$ and for $\\,\\alpha\\alpha^{\\star}\\,$ strategy $\\,\\mathrm{M}\\,$ minimizes $\\,\\Phi(\\alpha)\\,$.\n\nD. No crossover exists: strategy $\\,\\mathrm{H}\\,$ minimizes $\\,\\Phi(\\alpha)\\,$ for all $\\,\\alpha\\in[0,1]\\,$.",
            "solution": "The user has requested a meticulous validation and solution of the provided problem.\n\n**Problem Validation**\n\n**Step 1: Extract Givens**\n\n*   **Process**: Susceptible-Infected-Susceptible (SIS) spreading process.\n*   **Network**: Large, static, undirected, with heavy-tailed degree heterogeneity.\n*   **Parameters**: Disease transmission and recovery rates are fixed and uniform.\n*   **Risk Surrogates**:\n    *   Quenched mean-field (QMF) risk depends monotonically on the largest eigenvalue of the adjacency matrix, $\\lambda_{1}$.\n    *   Heterogeneous mean-field (HMF) risk depends monotonically on the ratio $\\langle k^{2}\\rangle/\\langle k\\rangle$.\n*   **Composite Risk Metric**: The post-intervention prevalence is predicted by a normalized composite risk metric $\\Phi(\\alpha) = \\alpha\\,R_{\\mathrm{spec}} + (1-\\alpha)\\,R_{\\mathrm{mf}}$, for $\\alpha \\in [0,1]$.\n*   **Metric Components**: $R_{\\mathrm{spec}}$ is proportional to $\\lambda_{1}$ and $R_{\\mathrm{mf}}$ is proportional to $\\langle k^{2}\\rangle/\\langle k\\rangle$.\n*   **Immunization Strategies**:\n    *   Strategy $\\mathrm{H}$: immunize the $10$ highest-degree hubs.\n    *   Strategy $\\mathrm{M}$: immunize $40$ moderate-degree nodes with degrees close to $2\\langle k\\rangle$.\n*   **Empirical Data (Post-Intervention, Normalized)**:\n    *   For strategy $\\mathrm{H}$: $R_{\\mathrm{spec}}^{(\\mathrm{H})}=0.55$, $R_{\\mathrm{mf}}^{(\\mathrm{H})}=0.70$.\n    *   For strategy $\\mathrm{M}$: $R_{\\mathrm{spec}}^{(\\mathrm{M})}=0.80$, $R_{\\mathrm{mf}}^{(\\mathrm{M})}=0.50$.\n*   **Objective**: Minimize the composite risk $\\Phi(\\alpha)$.\n\n**Step 2: Validate Using Extracted Givens**\n\n1.  **Scientifically Grounded**: The problem is well-founded in network epidemiology. The SIS model, heterogeneous networks, and the two mean-field approximations (QMF and HMF) are standard frameworks. The epidemic threshold in the QMF model is inversely proportional to $\\lambda_{1}$, and in the HMF model, it is proportional to $\\langle k\\rangle / \\langle k^{2}\\rangle$. Using quantities proportional to $\\lambda_{1}$ and $\\langle k^{2}\\rangle/\\langle k\\rangle$ as risk surrogates ($R_{\\mathrm{spec}}$ and $R_{\\mathrm{mf}}$ respectively) is therefore theoretically sound.\n2.  **Well-Posed**: The problem is mathematically well-defined. It provides explicit functional forms for the risk metrics for two distinct strategies and asks to determine the condition under which one is superior to the other. All necessary data are provided, leading to a unique solution.\n3.  **Objective**: The problem is stated using precise, quantitative, and objective language, with no subjective or ambiguous terms.\n4.  **Consistency and Realism**: The provided data are consistent with established knowledge of targeted immunization. Immunizing the top hubs (Strategy $\\mathrm{H}$) is known to be highly effective at reducing $\\lambda_{1}$, as hubs dominate the principal eigenvector. The reported reduction to $R_{\\mathrm{spec}}^{(\\mathrm{H})}=0.55$ is substantial and plausible. The effect on $\\langle k^{2}\\rangle/\\langle k\\rangle$ can be less pronounced, so $R_{\\mathrm{mf}}^{(\\mathrm{H})}=0.70$ is also reasonable. Strategy $\\mathrm{M}$ targets more nodes of moderate degree. This can be more effective at reducing the overall second moment of the degree distribution, explaining the strong reduction to $R_{\\mathrm{mf}}^{(\\mathrm{M})}=0.50$. Its impact on $\\lambda_{1}$ is expected to be less than that of hub removal, consistent with the higher value $R_{\\mathrm{spec}}^{(\\mathrm{M})}=0.80$. The setup is internally consistent and scientifically plausible.\n5.  **No Other Flaws**: The problem is not trivial, circular, or ill-posed. The use of a composite metric $\\Phi(\\alpha)$ is a reasonable way to model uncertainty between different theoretical approximations.\n\n**Step 3: Verdict and Action**\n\nThe problem statement is **valid**. The solution process will now proceed.\n\n**Solution Derivation**\n\nThe problem requires us to compare two immunization strategies, $\\mathrm{H}$ and $\\mathrm{M}$, based on the minimization of the composite risk metric $\\Phi(\\alpha)$. The metric is defined as:\n$$\n\\Phi(\\alpha) = \\alpha\\,R_{\\mathrm{spec}} + (1-\\alpha)\\,R_{\\mathrm{mf}}\n$$\nLet's write the specific risk functions for each strategy using the provided post-intervention data.\n\nFor Strategy $\\mathrm{H}$:\n$$\n\\Phi^{(\\mathrm{H})}(\\alpha) = \\alpha\\,R_{\\mathrm{spec}}^{(\\mathrm{H})} + (1-\\alpha)\\,R_{\\mathrm{mf}}^{(\\mathrm{H})}\n$$\nSubstituting the given values, $R_{\\mathrm{spec}}^{(\\mathrm{H})}=0.55$ and $R_{\\mathrm{mf}}^{(\\mathrm{H})}=0.70$:\n$$\n\\Phi^{(\\mathrm{H})}(\\alpha) = 0.55\\alpha + 0.70(1-\\alpha) = 0.55\\alpha + 0.70 - 0.70\\alpha = 0.70 - 0.15\\alpha\n$$\n\nFor Strategy $\\mathrm{M}$:\n$$\n\\Phi^{(\\mathrm{M})}(\\alpha) = \\alpha\\,R_{\\mathrm{spec}}^{(\\mathrm{M})} + (1-\\alpha)\\,R_{\\mathrm{mf}}^{(\\mathrm{M})}\n$$\nSubstituting the given values, $R_{\\mathrm{spec}}^{(\\mathrm{M})}=0.80$ and $R_{\\mathrm{mf}}^{(\\mathrm{M})}=0.50$:\n$$\n\\Phi^{(\\mathrm{M})}(\\alpha) = 0.80\\alpha + 0.50(1-\\alpha) = 0.80\\alpha + 0.50 - 0.50\\alpha = 0.50 + 0.30\\alpha\n$$\n\nThe optimal strategy is the one that results in a lower value of $\\Phi(\\alpha)$. A crossover in preference between the two strategies occurs at a value of $\\alpha$, denoted $\\alpha^{\\star}$, where their performance is equal:\n$$\n\\Phi^{(\\mathrm{H})}(\\alpha^{\\star}) = \\Phi^{(\\mathrm{M})}(\\alpha^{\\star})\n$$\nWe solve for $\\alpha^{\\star}$:\n$$\n0.70 - 0.15\\alpha^{\\star} = 0.50 + 0.30\\alpha^{\\star}\n$$\nRearranging the terms to solve for $\\alpha^{\\star}$:\n$$\n0.70 - 0.50 = 0.30\\alpha^{\\star} + 0.15\\alpha^{\\star}\n$$\n$$\n0.20 = 0.45\\alpha^{\\star}\n$$\n$$\n\\alpha^{\\star} = \\frac{0.20}{0.45} = \\frac{20}{45} = \\frac{4}{9}\n$$\nThe decimal representation of $\\alpha^{\\star}$ is $4/9 \\approx 0.4444...$. Since $\\alpha^{\\star} \\in [0,1]$, a unique crossover point exists.\n\nNow we must determine which strategy is superior for $\\alpha  \\alpha^{\\star}$ and $\\alpha  \\alpha^{\\star}$.\n\nStrategy $\\mathrm{H}$ is preferred when $\\Phi^{(\\mathrm{H})}(\\alpha)  \\Phi^{(\\mathrm{M})}(\\alpha)$:\n$$\n0.70 - 0.15\\alpha  0.50 + 0.30\\alpha\n$$\n$$\n0.20  0.45\\alpha\n$$\n$$\n\\alpha  \\frac{0.20}{0.45} = \\frac{4}{9}\n$$\nSo, for $\\alpha  \\alpha^{\\star}$, strategy $\\mathrm{H}$ minimizes the risk.\n\nStrategy $\\mathrm{M}$ is preferred when $\\Phi^{(\\mathrm{M})}(\\alpha)  \\Phi^{(\\mathrm{H})}(\\alpha)$:\n$$\n0.50 + 0.30\\alpha  0.70 - 0.15\\alpha\n$$\n$$\n0.45\\alpha  0.20\n$$\n$$\n\\alpha  \\frac{0.20}{0.45} = \\frac{4}{9}\n$$\nSo, for $\\alpha  \\alpha^{\\star}$, strategy $\\mathrm{M}$ minimizes the risk.\n\nIn summary, there is a unique crossover point at $\\alpha^{\\star} = 4/9 \\approx 0.44$. For values of the weighting parameter $\\alpha$ greater than $\\alpha^{\\star}$, strategy $\\mathrm{H}$ is optimal. For values of $\\alpha$ less than $\\alpha^{\\star}$, strategy $\\mathrm{M}$ is optimal.\n\n**Option-by-Option Analysis**\n\n*   **A. There exists a unique $\\,\\alpha^{\\star}\\approx 0.44\\,$ such that for $\\,\\alpha\\alpha^{\\star}\\,$ strategy $\\,\\mathrm{H}\\,$ minimizes $\\,\\Phi(\\alpha)\\,$ and for $\\,\\alpha\\alpha^{\\star}\\,$ strategy $\\,\\mathrm{M}\\,$ minimizes $\\,\\Phi(\\alpha)\\,$.**\n    *   Our calculation yields a unique crossover point $\\alpha^{\\star} = 4/9 \\approx 0.44$.\n    *   Our analysis shows that strategy $\\mathrm{H}$ is preferred ($\\Phi^{(\\mathrm{H})}(\\alpha)  \\Phi^{(\\mathrm{M})}(\\alpha)$) when $\\alpha  \\alpha^{\\star}$.\n    *   Our analysis shows that strategy $\\mathrm{M}$ is preferred ($\\Phi^{(\\mathrm{M})}(\\alpha)  \\Phi^{(\\mathrm{H})}(\\alpha)$) when $\\alpha  \\alpha^{\\star}$.\n    *   This statement is fully consistent with our derived results.\n    *   Verdict: **Correct**.\n\n*   **B. There exists a unique $\\,\\alpha^{\\star}\\approx 0.56\\,$ such that for $\\,\\alpha\\alpha^{\\star}\\,$ strategy $\\,\\mathrm{H}\\,$ minimizes $\\,\\Phi(\\alpha)\\,$ and for $\\,\\alpha\\alpha^{\\star}\\,$ strategy $\\,\\mathrm{M}\\,$ minimizes $\\,\\Phi(\\alpha)\\,$.**\n    *   The value of the crossover point is incorrect. We calculated $\\alpha^{\\star} \\approx 0.44$, not $0.56$. The value $0.56 \\approx 5/9$ is incorrect.\n    *   Verdict: **Incorrect**.\n\n*   **C. There exists a unique $\\,\\alpha^{\\star}\\approx 0.44\\,$ such that for $\\,\\alpha\\alpha^{\\star}\\,$ strategy $\\,\\mathrm{H}\\,$ minimizes $\\,\\Phi(\\alpha)\\,$ and for $\\,\\alpha\\alpha^{\\star}\\,$ strategy $\\,\\mathrm{M}\\,$ minimizes $\\,\\Phi(\\alpha)\\,$.**\n    *   The value of the crossover point $\\alpha^{\\star} \\approx 0.44$ is correct.\n    *   However, the conditions are reversed. This option claims strategy $\\mathrm{H}$ is better for $\\alpha  \\alpha^{\\star}$ and strategy $\\mathrm{M}$ is better for $\\alpha  \\alpha^{\\star}$. Our analysis proved the opposite.\n    *   Verdict: **Incorrect**.\n\n*   **D. No crossover exists: strategy $\\,\\mathrm{H}\\,$ minimizes $\\,\\Phi(\\alpha)\\,$ for all $\\,\\alpha\\in[0,1]\\,$.**\n    *   Our calculation demonstrated the existence of a unique crossover point $\\alpha^{\\star} = 4/9$, which lies in the interval $[0, 1]$. Therefore, a crossover does exist.\n    *   Furthermore, at $\\alpha=0$, $\\Phi^{(\\mathrm{H})}(0) = 0.70$ and $\\Phi^{(\\mathrm{M})}(0) = 0.50$, so strategy $\\mathrm{M}$ is superior. Strategy $\\mathrm{H}$ does not minimize $\\Phi(\\alpha)$ for all $\\alpha \\in [0,1]$.\n    *   Verdict: **Incorrect**.",
            "answer": "$$\\boxed{A}$$"
        }
    ]
}