{
    "hands_on_practices": [
        {
            "introduction": "A fundamental question in cellular automata is whether a given configuration can appear as a result of evolution, or if it is a \"Garden of Eden\" with no predecessor. Answering this probes the surjectivity of the global evolution map. This exercise introduces the powerful transfer matrix method, a cornerstone technique for systematically counting the number of predecessors for any configuration in a one-dimensional CA, thereby providing a concrete tool to analyze the automaton's reachability and generative capabilities .",
            "id": "4266043",
            "problem": "Consider a binary, one-dimensional Elementary Cellular Automaton (ECA) on a periodic lattice (ring) of length $L$, with radius $r=1$ and the update rule given by Wolfram’s Rule $184$. The ECA state at time $t$ is denoted by a sequence $\\{s_i(t)\\}_{i=0}^{L-1}$ with $s_i(t) \\in \\{0,1\\}$, and periodic boundary conditions $s_{i+L}(t) = s_i(t)$. The local update rule produces the next state $s_i(t+1) = f(s_{i-1}(t), s_i(t), s_{i+1}(t))$ according to the truth table for Rule $184$:\n$$\nf(1,1,1)=1,\\quad f(1,1,0)=0,\\quad f(1,0,1)=1,\\quad f(1,0,0)=1,\\quad f(0,1,1)=1,\\quad f(0,1,0)=0,\\quad f(0,0,1)=0,\\quad f(0,0,0)=0.\n$$\nThis automaton is known to model conservative transport (traffic flow), where a $1$ represents a particle and a $0$ a vacancy.\n\nLet $L=20$ and define the target configuration $\\{t_i\\}_{i=0}^{19}$ by $t_i = i \\bmod 2$, i.e., the strictly alternating pattern $t = 0101\\cdots 01$ of length $20$ with $t_0=0$. A predecessor of $t$ is any configuration $\\{s_i\\}_{i=0}^{19} \\in \\{0,1\\}^{20}$ such that applying Rule $184$ once (with the ring topology) yields $t$.\n\nStarting from the fundamental definitions of cellular automata and their local map composition on a ring, derive a principled method to count the number $N$ of distinct predecessors of $t$ under Rule $184$. Based on your derivation, determine whether $t$ is a Garden of Eden (a configuration with zero predecessors).\n\nReport your final answer as the ordered pair $(N,g)$, where $N$ is the total number of predecessors of $t$, and $g$ equals $1$ if $t$ is a Garden of Eden and $0$ otherwise. No rounding is required, and no units are involved. Express the pair $(N,g)$ as instructed in the final answer format.",
            "solution": "The user wants to find the number of predecessors for a specific configuration in an elementary cellular automaton.\n\n### Step 1: Extract Givens\n- **System**: Binary, one-dimensional Elementary Cellular Automaton (ECA).\n- **Lattice**: Periodic ring of length $L=20$.\n- **Radius**: $r=1$.\n- **Update Rule**: Wolfram's Rule 184.\n- **Truth Table**:\n  - $f(1,1,1)=1$\n  - $f(1,1,0)=0$\n  - $f(1,0,1)=1$\n  - $f(1,0,0)=1$\n  - $f(0,1,1)=1$\n  - $f(0,1,0)=0$\n  - $f(0,0,1)=0$\n  - $f(0,0,0)=0$\n- **State notation**: $\\{s_i(t)\\}_{i=0}^{L-1}$, $s_i(t) \\in \\{0,1\\}$.\n- **Boundary conditions**: Periodic, $s_{i+L}(t) = s_i(t)$.\n- **Local update rule**: $s_i(t+1) = f(s_{i-1}(t), s_i(t), s_{i+1}(t))$.\n- **Target configuration**: $\\{t_i\\}_{i=0}^{19}$ with $t_i = i \\bmod 2$.\n- **Definition**: A predecessor of $t$ is a configuration $\\{s_i\\}$ such that applying Rule 184 once yields $t$.\n- **Definition**: A Garden of Eden is a configuration with zero predecessors.\n- **Objective**: Find the number of predecessors $N$ and a flag $g$ where $g=1$ if the configuration is a Garden of Eden and $g=0$ otherwise.\n- **Final Answer Format**: An ordered pair $(N, g)$.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is scientifically grounded, being a standard problem in the theory of cellular automata. It is well-posed, with all necessary parameters ($L$, rule, target configuration) explicitly defined. The language is objective and formal. The problem is self-contained, consistent, and requires a rigorous, non-trivial mathematical derivation. The concepts of predecessors and Garden of Eden are fundamental to the study of cellular automata dynamics.\n\n### Step 3: Verdict and Action\nThe problem is valid. A full solution will be derived.\n\n### Derivation\nA configuration $s = \\{s_i\\}_{i=0}^{L-1}$ is a predecessor of the target configuration $t = \\{t_i\\}_{i=0}^{L-1}$ if for every site $i \\in \\{0, 1, \\dots, L-1\\}$, the following equation holds:\n$$t_i = f(s_{i-1}, s_i, s_{i+1})$$\nwhere indices are taken modulo $L=20$. This constitutes a system of $20$ coupled non-linear equations for the variables $\\{s_i\\}$.\n\nThis system can be solved using the transfer matrix method. We define the \"state\" at each position $i$ by the pair of cell values $(s_{i-1}, s_i)$. There are $2^2=4$ possible states: $(0,0)$, $(0,1)$, $(1,0)$, and $(1,1)$. The local rule $t_i = f(s_{i-1}, s_i, s_{i+1})$ acts as a constraint on the transition from state $(s_{i-1}, s_i)$ at position $i$ to state $(s_i, s_{i+1})$ at position $i+1$.\n\nThe target configuration is given by $t_i = i \\bmod 2$, which results in the pattern $t = 010101\\dots01$. Since the value of $t_i$ depends on whether $i$ is even or odd, we must define two separate transfer matrices:\n1.  $M_0$ for even $i$, where $t_i=0$.\n2.  $M_1$ for odd $i$, where $t_i=1$.\n\nThe entry $(M_k)_{uv}$ of a transfer matrix is $1$ if a transition from state $u=(s_{i-1}, s_i)$ to state $v=(s_i, s_{i+1})$ is allowed under the constraint $t_i=k$, and $0$ otherwise. We map the states to indices as follows: $0 \\leftrightarrow (0,0)$, $1 \\leftrightarrow (0,1)$, $2 \\leftrightarrow (1,0)$, $3 \\leftrightarrow (1,1)$.\n\n**Constructing $M_0$ (for $t_i=0$):**\nThe set of input neighborhoods $(s_{i-1}, s_i, s_{i+1})$ that map to $0$ under Rule $184$ is:\n$\\{(1,1,0), (0,1,0), (0,0,1), (0,0,0)\\}$.\n- From state $(0,0)$: Neighborhoods are $(0,0,0)$ and $(0,0,1)$. These lead to next states $(0,0)$ and $(0,1)$.\n- From state $(0,1)$: Neighborhood is $(0,1,0)$, leading to next state $(1,0)$.\n- From state $(1,0)$: No neighborhood starts with $(1,0)$ and maps to $0$.\n- From state $(1,1)$: Neighborhood is $(1,1,0)$, leading to next state $(1,0)$.\nThis gives the matrix:\n$$M_0 = \\begin{pmatrix} 1  1  0  0 \\\\ 0  0  1  0 \\\\ 0  0  0  0 \\\\ 0  0  1  0 \\end{pmatrix}$$\n\n**Constructing $M_1$ (for $t_i=1$):**\nThe set of input neighborhoods that map to $1$ is:\n$\\{(1,1,1), (1,0,1), (1,0,0), (0,1,1)\\}$.\n- From state $(0,0)$: No neighborhood starts with $(0,0)$ and maps to $1$.\n- From state $(0,1)$: Neighborhood is $(0,1,1)$, leading to next state $(1,1)$.\n- From state $(1,0)$: Neighborhoods are $(1,0,0)$ and $(1,0,1)$. These lead to next states $(0,0)$ and $(0,1)$.\n- From state $(1,1)$: Neighborhood is $(1,1,1)$, leading to next state $(1,1)$.\nThis gives the matrix:\n$$M_1 = \\begin{pmatrix} 0  0  0  0 \\\\ 0  0  0  1 \\\\ 1  1  0  0 \\\\ 0  0  0  1 \\end{pmatrix}$$\n\nThe total number of predecessor configurations $N$ is the number of valid closed paths of length $L=20$ around the ring. This is given by the trace of the total transfer matrix $M_{total}$. The total matrix is the product of the individual matrices for each site, in reverse order of their indices.\n$$M_{total} = M_{t_{19}} M_{t_{18}} \\cdots M_{t_1} M_{t_0}$$\nGiven $t=0101\\dots01$, we have $t_0=0, t_1=1, t_2=0, \\dots, t_{18}=0, t_{19}=1$.\n$$M_{total} = M_1 M_0 M_1 M_0 \\cdots M_1 M_0 = (M_1 M_0)^{10}$$\n\nLet's compute the product $A = M_1 M_0$:\n$$A = M_1 M_0 = \\begin{pmatrix} 0  0  0  0 \\\\ 0  0  0  1 \\\\ 1  1  0  0 \\\\ 0  0  0  1 \\end{pmatrix} \\begin{pmatrix} 1  1  0  0 \\\\ 0  0  1  0 \\\\ 0  0  0  0 \\\\ 0  0  1  0 \\end{pmatrix} = \\begin{pmatrix} 0  0  0  0 \\\\ 0  0  1  0 \\\\ 1  1  1  0 \\\\ 0  0  1  0 \\end{pmatrix}$$\nWe need to compute $N = \\text{Tr}(A^{10})$. We can do this by finding a general form for $A^n$. Let $F_n$ be the $n$-th Fibonacci number, with $F_0=0, F_1=1, F_2=1, \\dots$.\nLet's hypothesize a form for $A^n$ for $n \\ge 1$:\n$$A^n = \\begin{pmatrix} 0  0  0  0 \\\\ F_{n-1}  F_{n-1}  F_{n}  0 \\\\ F_{n}  F_{n}  F_{n+1}  0 \\\\ F_{n-1}  F_{n-1}  F_{n}  0 \\end{pmatrix}$$\n(with the convention $F_{-1}=1$).\nLet's check for $n=1$: $A^1 = \\begin{pmatrix} 0  0  0  0 \\\\ F_0  F_0  F_1  0 \\\\ F_1  F_1  F_2  0 \\\\ F_0  F_0  F_1  0 \\end{pmatrix} = \\begin{pmatrix} 0  0  0  0 \\\\ 0  0  1  0 \\\\ 1  1  1  0 \\\\ 0  0  1  0 \\end{pmatrix}$. This matches our matrix $A$.\n\nWe prove the form by induction. Assume it holds for $n$. Then for $n+1$:\n$$A^{n+1} = A^n A = \\begin{pmatrix} 0  0  0  0 \\\\ F_{n-1}  F_{n-1}  F_{n}  0 \\\\ F_{n}  F_{n}  F_{n+1}  0 \\\\ F_{n-1}  F_{n-1}  F_{n}  0 \\end{pmatrix} \\begin{pmatrix} 0  0  0  0 \\\\ 0  0  1  0 \\\\ 1  1  1  0 \\\\ 0  0  1  0 \\end{pmatrix}$$\nMultiplying the third row of $A^n$ by $A$:\n$$(F_n, F_n, F_{n+1}, 0) \\cdot A = (F_{n+1}, F_{n+1}, F_n+F_{n+1}, 0) = (F_{n+1}, F_{n+1}, F_{n+2}, 0)$$\nThis is consistent with the hypothesized form for row 3 of $A^{n+1}$.\nMultiplying the second row of $A^n$ by $A$:\n$$(F_{n-1}, F_{n-1}, F_{n}, 0) \\cdot A = (F_n, F_n, F_{n-1}+F_n, 0) = (F_n, F_n, F_{n+1}, 0)$$\nThis is consistent with the form for row 2 of $A^{n+1}$. The fourth row is identical to the second. The first row remains zero. The induction holds.\n\nNow we can compute $N = \\text{Tr}(A^{10})$:\n$$A^{10} = \\begin{pmatrix} 0  0  0  0 \\\\ F_{9}  F_{9}  F_{10}  0 \\\\ F_{10}  F_{10}  F_{11}  0 \\\\ F_9  F_9  F_{10}  0 \\end{pmatrix}$$\n$$N = \\text{Tr}(A^{10}) = 0 + F_9 + F_{11} + 0 = F_9 + F_{11}$$\nWe compute the required Fibonacci numbers:\n$F_0=0, F_1=1, F_2=1, F_3=2, F_4=3, F_5=5, F_6=8, F_7=13, F_8=21, F_9=34, F_{10}=55, F_{11}=89$.\n$$N = 34 + 89 = 123$$\nThe number of distinct predecessors is $N=123$.\n\nA configuration is a Garden of Eden if it has zero predecessors, i.e., $N=0$. Since $N=123 \\ne 0$, the target configuration $t$ is not a Garden of Eden. The indicator variable $g$ is therefore $0$.\n\nThe final answer is the ordered pair $(N,g) = (123,0)$.\nThis result can be cross-checked using the eigenvalues of $A$. The characteristic polynomial is $\\det(A-\\lambda I) = \\lambda^2(\\lambda^2-\\lambda-1)$. The eigenvalues are $\\lambda=0$ (multiplicity 2), $\\lambda=\\phi = \\frac{1+\\sqrt{5}}{2}$, and $\\lambda=1-\\phi = \\frac{1-\\sqrt{5}}{2}$. The matrix is diagonalizable, so $\\text{Tr}(A^{10}) = \\sum \\lambda_i^{10} = 0^{10} + 0^{10} + \\phi^{10} + (1-\\phi)^{10}$. This sum is the definition of the $10$-th Lucas number, $L_{10}$. The sequence of Lucas numbers begins $L_0=2, L_1=1, L_2=3, \\dots$ with the recurrence $L_n=L_{n-1}+L_{n-2}$. We find $L_{10}=123$. The identity $L_n=F_{n-1}+F_{n+1}$ further confirms that $L_{10} = F_9+F_{11}$, validating our matrix exponentiation result.",
            "answer": "$$ \\boxed{\\begin{pmatrix} 123  0 \\end{pmatrix}} $$"
        },
        {
            "introduction": "While many cellular automata exhibit complex, unpredictable dynamics, a special class of \"additive\" or linear rules are amenable to deep mathematical analysis. This practice delves into the temporal periodicity of Rule 90, a canonical linear automaton, demonstrating how its dynamics can be precisely characterized using the algebra of polynomial rings over the finite field $\\mathbb{F}_2$. By solving this problem, you will learn to translate a temporal condition into a spatial recurrence relation and use algebraic tools to count the exact number of periodic configurations, a feat rarely possible for non-linear systems .",
            "id": "4266012",
            "problem": "Consider the one-dimensional binary Cellular Automaton (CA) known as Wolfram’s Rule $90$ on a ring of length $n$ with periodic boundary conditions. Let the state at discrete time $t$ be $x_t \\in \\mathbb{F}_2^n$, where $\\mathbb{F}_2$ denotes the Finite Field of two elements ($\\mathbb{F}_2$). Let $S:\\mathbb{F}_2^n \\to \\mathbb{F}_2^n$ be the cyclic left-shift operator defined by $(S x)_i = x_{i-1}$ with indices interpreted modulo $n$. The global linear update for Rule $90$ can be written as $x_{t+1} = A x_t$ where $A = S + S^{-1}$ over $\\mathbb{F}_2$.\n\nWe say a configuration $x \\in \\mathbb{F}_2^n$ is temporally periodic of period $p$ if it satisfies $A^p x = x$. Work in the algebraic module $\\mathbb{F}_2[T,T^{-1}]/(T^n - 1)$ via the standard identification of configurations $x \\in \\mathbb{F}_2^n$ with polynomials $X(T) \\in \\mathbb{F}_2[T]/(T^n - 1)$, where the action of $S$ corresponds to multiplication by $T$. Assume $n$ is odd and $p$ is a power of two (i.e., $p = 2^k$ for some integer $k \\ge 0$).\n\nStarting from the core definitions of Rule $90$, derive a method to characterize all $x \\in \\mathbb{F}_2^n$ such that $A^p x = x$ using linear recurrences over $\\mathbb{F}_2$ in the spatial index. Then, using properties of roots of unity in the algebraic closure of $\\mathbb{F}_2$, determine the total number of distinct configurations $x \\in \\mathbb{F}_2^n$ satisfying $A^p x = x$ as a closed-form analytical expression in terms of $n$ and $p$. Your final answer must be a single closed-form expression. No rounding is required.",
            "solution": "The user wants to solve a problem about Wolfram's Rule 90 cellular automaton.\n\n### Step 1: Extract Givens\n-   **System**: One-dimensional binary Cellular Automaton (CA), Wolfram's Rule $90$.\n-   **Lattice**: A ring of length $n$ with periodic boundary conditions.\n-   **State**: At discrete time $t$, the state is $x_t \\in \\mathbb{F}_2^n$, where $\\mathbb{F}_2$ is the finite field of two elements.\n-   **Operator $S$**: Cyclic left-shift operator, $(S x)_i = x_{i-1}$ with indices modulo $n$.\n-   **Update Rule**: The global linear update is $x_{t+1} = A x_t$, where the matrix $A = S + S^{-1}$ over $\\mathbb{F}_2$.\n-   **Temporal Periodicity**: A configuration $x \\in \\mathbb{F}_2^n$ is temporally periodic of period $p$ if it satisfies $A^p x = x$.\n-   **Algebraic Framework**: The problem is set in the module $\\mathbb{F}_2[T,T^{-1}]/(T^n - 1)$. Configurations $x \\in \\mathbb{F}_2^n$ correspond to polynomials $X(T) \\in \\mathbb{F}_2[T]/(T^n - 1)$, and the action of $S$ corresponds to multiplication by $T$.\n-   **Constraints**:\n    1.  The length of the ring, $n$, is an odd integer.\n    2.  The period, $p$, is a power of two, i.e., $p = 2^k$ for some integer $k \\ge 0$.\n-   **Goals**:\n    1.  Derive a method to characterize all configurations $x$ satisfying $A^p x = x$ using linear recurrences over $\\mathbb{F}_2$ in the spatial index.\n    2.  Determine the total number of such distinct configurations as a closed-form analytical expression in terms of $n$ and $p$.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is scientifically and mathematically sound. It is a well-defined question within the fields of cellular automata theory and abstract algebra.\n\n-   **Scientific Grounding**: The representation of Rule $90$ as a linear operator $A = S + S^{-1}$ over $\\mathbb{F}_2$ is standard. The use of polynomial rings to analyze cyclic systems is a powerful and common technique in algebraic coding theory and the study of linear cellular automata.\n-   **Well-Posedness**: The question asks for the number of solutions to a linear equation $(A^p - I)x = 0$, which is equivalent to finding the size of the null space of the linear operator $A^p-I$. This is a well-posed problem in linear algebra.\n-   **Objectivity  Completeness**: The problem is stated using precise mathematical language. All necessary information and constraints ($n$ is odd, $p=2^k$) are provided and are crucial for the solution. There are no contradictions.\n\nThe problem does not violate any of the invalidity criteria. It is a valid, non-trivial mathematical problem.\n\n### Step 3: Verdict and Action\nThe problem is valid. We proceed with the solution.\n\n### Solution Derivation\n\nThe local update rule for Rule $90$ states that the state of a cell at the next time step is the sum (modulo $2$) of the states of its left and right neighbors. For a cell at position $i$, its state at time $t+1$, $x_{t+1, i}$, is given by:\n$$x_{t+1, i} = x_{t, i-1} + x_{t, i+1} \\pmod{2}$$\nThe indices are taken modulo $n$ due to the periodic boundary conditions.\nIn vector form, using the shift operator $S$, this is $x_{t+1} = S^{-1} x_t + S x_t = (S + S^{-1})x_t$. The problem defines $A = S + S^{-1}$, so $x_{t+1} = Ax_t$.\n\nWe are looking for configurations $x$ that are temporally periodic with period $p$, which means they satisfy the equation $A^p x = x$. Since we are working over $\\mathbb{F}_2$, this is equivalent to $(A^p + I)x = 0$, where $I$ is the identity operator.\n\nThe problem states that $p$ is a power of two, $p = 2^k$ for some integer $k \\ge 0$. The arithmetic is in characteristic $2$, which has the property $(a+b)^2 = a^2 + b^2$. By induction, this generalizes to $(a+b)^{2^k} = a^{2^k} + b^{2^k}$.\nApplying this to the operator $A$:\n$$A^p = A^{2^k} = (S + S^{-1})^{2^k} = S^{2^k} + (S^{-1})^{2^k} = S^p + S^{-p}$$\nThe condition $A^p x = x$ thus becomes:\n$$(S^p + S^{-p})x = x$$\n$$(S^p + S^{-p} + I)x = 0$$\n\nThis operator equation provides the characterization of the configurations using a linear recurrence, as requested by the first part of the problem. Applying the operator to a generic configuration $x$, we obtain the recurrence relation for its components $x_i$:\n$$(S^p x)_i + (S^{-p} x)_i + (I x)_i = 0$$\n$$x_{i-p} + x_{i+p} + x_i = 0 \\pmod{2}$$\nThis recurrence must hold for all $i \\in \\{0, 1, \\dots, n-1\\}$, with indices interpreted modulo $n$. Any configuration $x \\in \\mathbb{F}_2^n$ satisfying this spatial recurrence relation is a periodic point of period $p$ for Rule $90$.\n\nTo find the total number of such configurations, we need to find the dimension of the null space of the operator $M = S^p + S^{-p} + I$. We use the provided algebraic framework.\nIn the ring $\\mathbb{F}_2[T]/(T^n-1)$, the shift operator $S$ corresponds to multiplication by the indeterminate $T$. The operator $M$ then corresponds to multiplication by the polynomial $m(T) = T^p + T^{-p} + 1$. To clear the negative exponent, we can multiply by $T^p$, which is an invertible element in this ring, yielding the polynomial $P(T) = T^p m(T) = T^{2p} + 1 + T^p$.\nThe number of solutions to $m(T)X(T) \\equiv 0 \\pmod{T^n-1}$ is given by $2^d$, where $d$ is the dimension of the null space. This dimension is equal to the degree of the greatest common divisor of the corresponding polynomial and the ring modulus:\n$$d = \\deg(\\gcd(T^{2p} + T^p + 1, T^n - 1))$$\nTo find this GCD, we analyze the roots of the polynomials in the algebraic closure of $\\mathbb{F}_2$, denoted $\\overline{\\mathbb{F}}_2$. A common root $\\alpha$ must satisfy both $\\alpha^{2p} + \\alpha^p + 1 = 0$ and $\\alpha^n = 1$.\n\nThe equation $\\alpha^{2p} + \\alpha^p + 1 = 0$ is a quadratic in $\\alpha^p$. The polynomial $y^2+y+1$ is irreducible over $\\mathbb{F}_2$, and its roots are the primitive $3$-rd roots of unity in $\\overline{\\mathbb{F}}_2$. Thus, $\\alpha^p$ must be a primitive $3$-rd root of unity. This implies that the multiplicative order of $\\alpha^p$ is $3$.\n\nLet $d_{root} = \\operatorname{ord}(\\alpha)$ be the order of the root $\\alpha$.\nFrom $\\alpha^n=1$, we know that $d_{root}$ must be a divisor of $n$.\nThe order of $\\alpha^p$ is given by $\\operatorname{ord}(\\alpha^p) = \\frac{d_{root}}{\\gcd(d_{root}, p)}$.\nSo, we must have $\\frac{d_{root}}{\\gcd(d_{root}, p)} = 3$, which implies $d_{root} = 3 \\cdot \\gcd(d_{root}, p)$.\n\nThis equation tells us that $d_{root}$ must be a multiple of $3$. It also implies that $\\frac{d_{root}}{3}$ must be a divisor of $p$.\nWe are given that $p=2^k$ for some $k \\ge 0$. So, $\\frac{d_{root}}{3}$ must be a power of $2$, say $2^j$ for some $j \\ge 0$.\nThus, the order of any common root must be of the form $d_{root} = 3 \\cdot 2^j$.\n\nHowever, we also know that $d_{root}$ must divide $n$. The problem states that $n$ is an odd number.\nFor $d_{root} = 3 \\cdot 2^j$ to be a divisor of an odd number $n$, the power of $2$ must be $2^0=1$. This forces $j=0$.\nTherefore, the only possible order for a common root $\\alpha$ is $d_{root}=3$.\n\nThe roots of order $3$ are precisely the roots of the 3rd cyclotomic polynomial, $\\Phi_3(T) = T^2+T+1$.\nThis means that the $\\gcd(T^{2p} + T^p + 1, T^n - 1)$ must be a divisor of $\\Phi_3(T)$. Since $\\Phi_3(T)$ is irreducible over $\\mathbb{F}_2$, the gcd can only be $1$ or $\\Phi_3(T)$ itself.\n\nThe gcd will be $\\Phi_3(T)$ if and only if $\\Phi_3(T)$ is a factor of both $T^n - 1$ and $T^{2p} + T^p + 1$.\n\n1.  When does $\\Phi_3(T)$ divide $T^n - 1$?\n    $\\Phi_3(T)$ divides $T^n-1$ if and only if its roots, which are the primitive $3$-rd roots of unity, are also $n$-th roots of unity. This occurs if and only if the order of the roots, which is $3$, divides $n$. So, $\\Phi_3(T) | (T^n-1)$ if and only if $3 | n$.\n\n2.  When does $\\Phi_3(T)$ divide $T^{2p} + T^p + 1$?\n    Let $\\alpha$ be a root of $\\Phi_3(T)$, so $\\alpha^2+\\alpha+1=0$ and $\\alpha^3=1$. We must check if $\\alpha^{2p}+\\alpha^p+1=0$. Since $p=2^k$, we consider $p \\pmod 3$.\n    $2 \\equiv -1 \\pmod 3$, so $p = 2^k \\equiv (-1)^k \\pmod 3$.\n    - If $k$ is even, $p \\equiv 1 \\pmod 3$. Then $\\alpha^p = \\alpha$. The expression becomes $\\alpha^2 + \\alpha + 1$, which is $0$.\n    - If $k$ is odd, $p \\equiv -1 \\equiv 2 \\pmod 3$. Then $\\alpha^p = \\alpha^2$. The expression becomes $(\\alpha^2)^2 + \\alpha^2 + 1 = \\alpha^4 + \\alpha^2 + 1 = \\alpha + \\alpha^2 + 1$, which is $0$.\n    In both cases, the condition holds. Thus, for any $p=2^k$ with $k \\ge 0$, $\\Phi_3(T)$ is a factor of $T^{2p} + T^p + 1$.\n\nCombining these findings:\n-   If $3$ does not divide $n$ (i.e., $3 \\nmid n$), then $\\Phi_3(T)$ is not a factor of $T^n-1$. The gcd must be $1$. The degree $d=0$, and the number of solutions is $2^0=1$. The only solution is the trivial all-zero configuration.\n-   If $3$ divides $n$ (i.e., $3 | n$), then $\\Phi_3(T)$ is a factor of both polynomials. The gcd is $\\Phi_3(T)=T^2+T+1$. The degree $d=\\deg(\\Phi_3(T))=2$. The number of solutions is $2^2=4$.\n\nWe need to express this result as a single closed-form expression in terms of $n$ (and possibly $p$, although the result is independent of $p$). We can use the greatest common divisor function, $\\gcd(a,b)$. Since $n$ is an integer, $\\gcd(n,3)$ can be either $1$ (if $3 \\nmid n$) or $3$ (if $3 | n$).\n-   If $\\gcd(n,3)=1$, the number of solutions is $1$.\n-   If $\\gcd(n,3)=3$, the number of solutions is $4$.\n\nThis can be compactly written as $2^{\\gcd(n,3)-1}$.\n-   If $\\gcd(n,3)=1$, we have $2^{1-1} = 2^0 = 1$.\n-   If $\\gcd(n,3)=3$, we have $2^{3-1} = 2^2 = 4$.\nThis formula correctly captures the number of solutions for all odd $n$.",
            "answer": "$$\n\\boxed{2^{\\gcd(n,3)-1}}\n$$"
        },
        {
            "introduction": "For many of the most fascinating cellular automata, including Conway's Game of Life and Wolfram's Class IV rules, exact analytical solutions for their long-term behavior are often out of reach. In these cases, we turn to computational experiments to uncover statistical patterns and emergent phenomena like phase transitions. This hands-on simulation asks you to act as a computational scientist, using Monte Carlo methods to estimate the critical initial density at which stable structures emerge, providing insight into the statistical mechanics of these complex systems .",
            "id": "4266022",
            "problem": "Consider binary-state Cellular Automata (CA) under the canonical update rules of Wolfram's elementary CA and Conway's Game of Life (GoL). Let the state space be discrete and finite, and let time advance in discrete steps. The fundamental base of this problem is the definition of deterministic local update rules applied synchronously to all sites, and the probabilistic initialization of configurations by independent and identically distributed Bernoulli trials.\n\nDefinitions and setup:\n- A one-dimensional elementary CA consists of a ring of $M$ cells with binary states $\\{0,1\\}$, updated synchronously at time $t \\mapsto t+1$ according to a mapping determined by a Wolfram rule number $R \\in \\{0,1,\\dots,255\\}$. Each site update depends on its radius-$1$ neighborhood $\\{x_{i-1}(t), x_{i}(t), x_{i+1}(t)\\}$.\n- Conway's Game of Life (GoL) consists of a two-dimensional toroidal lattice of size $N \\times N$ with binary states $\\{0,1\\}$. The update rule at time $t \\mapsto t+1$ is: a live cell remains live if it has exactly $2$ or $3$ live neighbors; a dead cell becomes live if it has exactly $3$ live neighbors; otherwise the cell becomes or remains dead. Neighbor counts are computed from the $8$ nearest neighbors on the torus.\n- A random initial configuration with density $p \\in [0,1]$ is generated by independent Bernoulli trials where each site is live (state $1$) with probability $p$ and dead (state $0$) with probability $1-p$.\n- A configuration is called eventually periodic with period less than or equal to $2$ if there exists a finite transient time after which the global configuration satisfies $X_{t} = X_{t-1}$ (period $1$) or $X_{t} = X_{t-2}$ (period $2$). We call the emergence of such eventual periodicity the emergence of stable structures.\n\nObjective:\nFor random initial configurations with density $p$, estimate the critical $p$ at which stable structures emerge, defined as the smallest $p$ in a given discrete set of densities for which the empirical probability of stabilization (eventual period less than or equal to $2$ within a fixed time horizon) is at least $0.5$. Then compare the estimates to qualitative empirical findings reported for canonical rules.\n\nEstimation protocol:\n- For each selected $p$, run $S$ independent trials (each trial uses an independent random seed), evolve the CA for $T$ steps from the random initial configuration, and test whether the final configuration $X_{T}$ satisfies $X_{T}=X_{T-1}$ or $X_{T}=X_{T-2}$. Let $\\hat{q}(p)$ denote the fraction of trials that satisfy this stability criterion.\n- Define the estimated critical density $p^{\\star}$ as the smallest tested density $p$ such that $\\hat{q}(p) \\ge 0.5$. If no tested $p$ achieves $\\hat{q}(p) \\ge 0.5$, then output $-1.0$ for the estimate to indicate \"not found within grid.\"\n\nScientific realism and constraints:\n- All simulations use toroidal boundary conditions to avoid boundary artifacts and to ensure spatial homogeneity.\n- The test horizon $T$ and the number of trials $S$ are finite, acknowledging that an eventual period might occur after time $T$, but the estimation criterion uses the observed horizon.\n\nTest suite:\nEvaluate three cases to exercise different facets of the dynamics:\n1. GoL on an $N \\times N$ torus with $N=64$, $T=256$, $S=16$, and tested densities $p \\in \\{0.05, 0.10, 0.20, 0.30, 0.40\\}$.\n2. Elementary CA rule $R=110$ on a one-dimensional ring of size $M=256$, $T=256$, $S=16$, and tested densities $p \\in \\{0.05, 0.10, 0.20, 0.30, 0.40\\}$.\n3. Elementary CA rule $R=30$ on a one-dimensional ring of size $M=256$, $T=256$, $S=16$, and tested densities $p \\in \\{0.05, 0.10, 0.20, 0.30, 0.40\\}$.\n\nAnswer specification:\n- For each of the above three cases, compute the estimated $p^{\\star}$ using the definition above, and round each result to two decimal places.\n- If no critical density is found within the tested grid (i.e., the stabilization fraction never reaches $0.5$), output $-1.00$ for that case.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of cases $1$ to $3$, for example: \"[$p^{\\star}_{\\mathrm{GoL}},$ $p^{\\star}_{110},$ $p^{\\star}_{30}$]\". The values must be printed as floats rounded to two decimal places.\n\nNo angles or physical units are involved in this problem, so no unit specification is required.",
            "solution": "The user has provided a valid, well-posed, and scientifically grounded computational problem. The task is to estimate a critical parameter, the initial density $p^{\\star}$, for the emergence of simple periodic behavior in three distinct cellular automata systems. The problem is rooted in the canonical field of complex systems, specifically concerning the dynamics of Wolfram's elementary Cellular Automata (CA) and Conway's Game of Life (GoL). All parameters, definitions, and procedures are specified with sufficient rigor to permit a unique and verifiable solution.\n\nThe problem will be solved by implementing a Monte Carlo simulation protocol as specified. For each system and for each candidate density $p$ from a given discrete set, we will simulate the automaton's evolution for a specified number of trials and timesteps. We will then determine the critical density $p^{\\star}$ based on the empirical probability of the system reaching a stable state.\n\nThe overall methodology is composed of several key stages for each test case:\n$1$. **System Initialization**: For each of the $S$ independent trials, an initial configuration is generated. This is a grid of cells (a $1$D ring of size $M$ for elementary CA, or a $2$D torus of size $N \\times N$ for GoL) where each cell is set to state $1$ (live) with probability $p$ and state $0$ (dead) with probability $1-p$. This is achieved by sampling from a Bernoulli distribution for each site.\n\n$2$. **Temporal Evolution**: The automaton is evolved synchronously for $T$ discrete time steps. At each step $t$, the state of every cell at time $t+1$ is calculated based on the states of its local neighborhood at time $t$. The update rules are deterministic and are applied to all cells simultaneously. To manage boundary effects and maintain spatial homogeneity, all simulations employ periodic (toroidal) boundary conditions.\n\n$3$. **Stability Assessment**: The protocol defines stability as the emergence of a configuration that is periodic with a period of $1$ or $2$. This is tested at the end of the simulation horizon, at time $T$. A trial is deemed stable if the global state of the automaton at time $T$, denoted $X_{T}$, is identical to the state at the previous step, $X_{T-1}$, or the step before that, $X_{T-2}$. That is, the condition is $X_{T} = X_{T-1} \\lor X_{T} = X_{T-2}$. To perform this check, the configurations from the last three time steps ($T-2$, $T-1$, and $T$) must be stored.\n\n$4$. **Statistical Estimation of $p^{\\star}$**: For a given density $p$, the empirical probability of stabilization, $\\hat{q}(p)$, is calculated as the fraction of the $S$ trials that meet the stability criterion. The critical density, $p^{\\star}$, is then defined as the smallest density $p$ in the tested set $\\{0.05, 0.10, 0.20, 0.30, 0.40\\}$ for which $\\hat{q}(p) \\ge 0.5$. If no tested density satisfies this condition, $p^{\\star}$ is designated as $-1.0$.\n\nThe specific update rules for the three test cases are implemented as follows:\n\n**Case 1: Conway's Game of Life (GoL)**\nGoL evolves on a $2$D grid. The neighborhood of a cell consists of its $8$ adjacent cells (the Moore neighborhood). The update rule, known as B3/S23, is:\n- A dead cell with exactly $3$ live neighbors becomes live (Birth).\n- A live cell with $2$ or $3$ live neighbors remains live (Survival).\n- In all other cases, a cell becomes or remains dead (due to Overpopulation or Loneliness).\nThe number of live neighbors for every cell in the grid can be computed efficiently using a $2$D convolution. A kernel matrix, $K = \\begin{pmatrix} 1  1  1 \\\\ 1  0  1 \\\\ 1  1  1 \\end{pmatrix}$, is convolved with the binary state grid. The periodic boundary condition is handled by the 'wrap' mode of the convolution function.\n\n**Cases 2  3: Elementary Cellular Automata (Rules $110$ and $30$)**\nElementary CAs evolve on a $1$D ring. The state of a cell $x_i$ at time $t+1$ is determined by the states of its radius-$1$ neighborhood $\\{x_{i-1}(t), x_i(t), x_{i+1}(t)\\}$ at time $t$. There are $2^3 = 8$ possible neighborhood configurations, which can be interpreted as $3$-bit binary numbers from $(0,0,0)$ to $(1,1,1)$, corresponding to integer values $0$ to $7$. A Wolfram rule number $R \\in \\{0, \\dots, 255\\}$ is an $8$-bit integer. The $k$-th bit of $R$ (from right to left, $0$-indexed) specifies the output state for the neighborhood configuration with integer value $k$.\nFor example, for rule $R=30$, its binary representation is $00011110_2$. The rule's lookup table is $[0, 1, 1, 1, 1, 0, 0, 0]$ for neighborhoods $(0,0,0)$ through $(1,1,1)$ respectively. The update for the entire grid can be vectorized efficiently. For a grid `c`, the neighborhood indices for all cells are calculated as $4 \\times \\text{roll}(c, 1) + 2 \\times c + 1 \\times \\text{roll}(c, -1)$, where `roll` performs a circular shift. The new grid is then generated by indexing the rule's lookup table with this array of indices. This same procedure is applied for both Rule $R=110$ and Rule $R=30$.\n\nRule $30$ is known for its chaotic behavior (Wolfram Class III), making it a candidate for a pseudo-random number generator. Its dynamics are highly unpredictable and unlikely to settle into simple periodic orbits. Rule $110$ is a Class IV automaton, known for its ability to support complex, persistent structures (gliders) and is computationally universal. This complexity also suggests it may not readily stabilize. GoL is famed for its rich zoo of patterns, from simple static or oscillating forms to complex \"gliders\" and \"spaceships,\" and its fate is highly sensitive to initial density. The specified protocol will be executed to quantify the propensity of these three distinct systems to stabilize under random initial conditions.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.signal import convolve2d\n\ndef solve():\n    \"\"\"\n    Main function to run the cellular automata simulations and find the critical densities.\n    \"\"\"\n\n    # For reproducibility of the entire set of results.\n    np.random.seed(42)\n\n    # --- Helper functions for simulations ---\n\n    def _get_eca_lookup_table(rule_number):\n        \"\"\"Generates the lookup table for a Wolfram elementary CA rule.\"\"\"\n        if not (0 = rule_number = 255):\n            raise ValueError(\"Rule number must be between 0 and 255.\")\n        # The binary string corresponds to neighborhoods 7 down to 0.\n        # We reverse it to map index k to neighborhood k.\n        binary_string = f'{rule_number:08b}'\n        return np.array([int(bit) for bit in binary_string], dtype=np.int8)[::-1]\n\n    ECA_LOOKUP_TABLES = {\n        30: _get_eca_lookup_table(30),\n        110: _get_eca_lookup_table(110)\n    }\n\n    def _estimate_p_star_eca(M, R, T, S, p_grid):\n        \"\"\"\n        Estimates the critical density p* for an elementary cellular automaton.\n        \"\"\"\n        lookup_table = ECA_LOOKUP_TABLES[R]\n        for p in p_grid:\n            stable_count = 0\n            for _ in range(S):\n                # 1. Initialization\n                grid = (np.random.rand(M)  p).astype(np.int8)\n                \n                # History stores [t-2, t-1, t]\n                history = [None, None, grid.copy()]\n\n                # 2. Temporal Evolution\n                for _ in range(T):\n                    # Efficiently calculate neighborhood indices for all cells\n                    left_shifted = np.roll(grid, 1)\n                    right_shifted = np.roll(grid, -1)\n                    indices = 4 * left_shifted + 2 * grid + 1 * right_shifted\n                    \n                    grid = lookup_table[indices]\n\n                    # Update history\n                    history[0] = history[1]\n                    history[1] = history[2]\n                    history[2] = grid.copy()\n\n                # 3. Stability Assessment\n                is_period_1 = np.array_equal(history[2], history[1])\n                is_period_2 = (history[0] is not None) and np.array_equal(history[2], history[0])\n                \n                if is_period_1 or is_period_2:\n                    stable_count += 1\n            \n            # 4. Statistical Estimation\n            q_hat = stable_count / S\n            if q_hat = 0.5:\n                return p\n        \n        return -1.0\n    \n    def _estimate_p_star_gol(N, T, S, p_grid):\n        \"\"\"\n        Estimates the critical density p* for Conway's Game of Life.\n        \"\"\"\n        # Kernel for counting neighbors using convolution\n        kernel = np.array([[1, 1, 1], \n                           [1, 0, 1], \n                           [1, 1, 1]], dtype=np.int8)\n        \n        for p in p_grid:\n            stable_count = 0\n            for _ in range(S):\n                # 1. Initialization\n                grid = (np.random.rand(N, N)  p).astype(np.int8)\n                history = [None, None, grid.copy()]\n\n                # 2. Temporal Evolution\n                for _ in range(T):\n                    # Count neighbors using convolution with 'wrap' for toroidal boundaries\n                    neighbor_counts = convolve2d(grid, kernel, mode='same', boundary='wrap')\n                    \n                    # Apply GoL rules (B3/S23)\n                    # Birth: dead cell (grid==0) with 3 neighbors becomes live\n                    births = (grid == 0)  (neighbor_counts == 3)\n                    # Survival: live cell (grid==1) with 2 or 3 neighbors stays live\n                    survivals = (grid == 1)  ((neighbor_counts == 2) | (neighbor_counts == 3))\n                    \n                    grid = (births | survivals).astype(np.int8)\n                    \n                    # Update history\n                    history[0] = history[1]\n                    history[1] = history[2]\n                    history[2] = grid.copy()\n\n                # 3. Stability Assessment\n                is_period_1 = np.array_equal(history[2], history[1])\n                is_period_2 = (history[0] is not None) and np.array_equal(history[2], history[0])\n\n                if is_period_1 or is_period_2:\n                    stable_count += 1\n            \n            # 4. Statistical Estimation\n            q_hat = stable_count / S\n            if q_hat = 0.5:\n                return p\n\n        return -1.0\n\n    # --- Define and run test cases ---\n\n    test_cases = [\n        {\n            \"id\": \"GoL\", \"func\": _estimate_p_star_gol,\n            \"params\": {\"N\": 64, \"T\": 256, \"S\": 16, \"p_grid\": [0.05, 0.10, 0.20, 0.30, 0.40]}\n        },\n        {\n            \"id\": \"Rule 110\", \"func\": _estimate_p_star_eca,\n            \"params\": {\"M\": 256, \"R\": 110, \"T\": 256, \"S\": 16, \"p_grid\": [0.05, 0.10, 0.20, 0.30, 0.40]}\n        },\n        {\n            \"id\": \"Rule 30\", \"func\": _estimate_p_star_eca,\n            \"params\": {\"M\": 256, \"R\": 30, \"T\": 256, \"S\": 16, \"p_grid\": [0.05, 0.10, 0.20, 0.30, 0.40]}\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = case[\"func\"](**case[\"params\"])\n        results.append(result)\n\n    # --- Format and print the final output ---\n    \n    # The format string ensures two decimal places, e.g., 0.1 - \"0.10\", -1.0 - \"-1.00\"\n    formatted_results = [f\"{r:.2f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}