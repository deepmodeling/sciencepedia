{
    "hands_on_practices": [
        {
            "introduction": "为了系统地描述所有256种基本元胞自动机，我们需要一种简洁的表示法。沃尔夫勒姆编码（Wolfram code）通过一个整数来代表规则的真值表，提供了一种标准化的方法。本练习将指导你逆向执行此过程，将规则编码转换回其完整的真值表，这是理解规则空间并实现任何元胞自动机模拟器的基础步骤。",
            "id": "4266078",
            "problem": "考虑一个基本细胞自动机 (Elementary Cellular Automaton, ECA)，它被定义为一种具有二进制状态和最近邻相互作用的一维细胞自动机 (Cellular Automaton, CA)。形式上，设局部更新规则为一个布尔函数 $f:\\{0,1\\}^3 \\to \\{0,1\\}$，它将一个邻域三元组 $(x_{i-1}(t), x_i(t), x_{i+1}(t)) \\in \\{0,1\\}^3$ 映射到一个更新后的状态 $x_i(t+1) \\in \\{0,1\\}$。全局动力学将 $f$ 同步地应用于一个构型的每个位置，以生成下一个构型。\n\n所有可能邻域的一种规范枚举按降序字典序列出八个二进制三元组：\n$$\n(1,1,1),\\ (1,1,0),\\ (1,0,1),\\ (1,0,0),\\ (0,1,1),\\ (0,1,0),\\ (0,0,1),\\ (0,0,0).\n$$\n对于任何布尔函数 $f:\\{0,1\\}^3 \\to \\{0,1\\}$，其在此排序下的真值表 $v \\in \\{0,1\\}^8$ 定义为\n$$\nv = \\big(f(1,1,1),\\ f(1,1,0),\\ f(1,0,1),\\ f(1,0,0),\\ f(0,1,1),\\ f(0,1,0),\\ f(0,0,1),\\ f(0,0,0)\\big).\n$$\nECA 规则的 Wolfram 代码是通过在 ECA 文献中使用的标准约定下，将真值表以 2 为基数进行编码得到的整数 $R \\in \\{0,\\dots,255\\}$。这在 $\\{0,\\dots,255\\}$ 中的整数与 $\\{0,1\\}^3$ 上的所有布尔函数之间建立了一个双射。\n\n任务：根据二进制位置表示法的第一性原理和上述规范邻域排序，推导出一个算法。给定 $R \\in \\{0,\\dots,255\\}$，该算法输出相应的布尔函数 $f$，其形式为真值表向量 $v \\in \\{0,1\\}^8$，并与上面指定的邻域顺序对齐。你的推导必须仅依赖于二进制表示和布尔函数的基本定义和属性。\n\n你的程序必须实现此算法，并在以下 Wolfram 代码整数测试集上进行评估：\n- $R=0$ (边界情况：所有输出为 $0$)，\n- $R=1$ (边界情况：最低有效位被设置)，\n- $R=30$ (经典复杂规则)，\n- $R=90$ (经典加法规则)，\n- $R=110$ (经典复杂规则)，\n- $R=128$ (边界情况：最高有效位被设置)，\n- $R=255$ (边界情况：所有输出为 $1$)。\n\n对于每个测试用例，返回真值表向量 $v$，作为一个包含八个整数的列表，其固定顺序对应于邻域 $(1,1,1)$, $(1,1,0)$, $(1,0,1)$, $(1,0,0)$, $(0,1,1)$, $(0,1,0)$, $(0,0,1)$, $(0,0,0)$。\n\n你的程序应生成单行输出，其中包含结果，形式为一个逗号分隔的八项列表的列表，并用方括号括起来。例如，预期的格式是\n$$\n\\big[\\,[v_{R_1}],\\,[v_{R_2}],\\,\\dots\\,\\big]\n$$\n其中每个 $[v_{R_k}]$ 本身就是一个包含八个整数的列表。本问题不涉及任何物理单位或角度单位，所有输出均为 $\\{0,1\\}$ 中的整数。",
            "solution": "该问题已经过验证，并被确定为计算科学和复杂系统领域内一个提法恰当且有科学依据的问题。任务是推导并实现一个算法，该算法将 Wolfram 代码（一个整数 $R \\in \\{0, \\dots, 255\\}$）转换为其对应的基本细胞自动机（ECA）的 $8$ 位真值表向量 $v$。\n\n### 从第一性原理推导\n\n问题的核心在于理解整数 $R$ 和真值表向量 $v$ 之间的关系。我们将根据所提供的定义和二进制表示法的基本原理来推导这种关系。\n\n**1. Wolfram 代码的形式化定义**\n\nECA 的局部更新规则是一个布尔函数 $f:\\{0,1\\}^3 \\to \\{0,1\\}$。该函数有 $2^3 = 8$ 种可能的输入（邻域）。问题为这些邻域指定了一种按降序字典序排列的规范顺序：\n$$\n(1,1,1), (1,1,0), (1,0,1), (1,0,0), (0,1,1), (0,1,0), (0,0,1), (0,0,0)\n$$\n函数 $f$ 的真值表是一个 $8$ 位向量 $v$，其中每一位是 $f$ 对于指定顺序中相应邻域的输出：\n$$\nv = (v_1, v_2, v_3, v_4, v_5, v_6, v_7, v_8)\n$$\n其中 $v_1 = f(1,1,1)$，$v_2 = f(1,1,0)$，以此类推，直到 $v_8 = f(0,0,0)$。\n\nWolfram 代码 $R$ 被定义为其二进制表示为向量 $v$ 的整数。与指定的降序邻域顺序一致的标准约定将 $v_1$ 视为最高有效位（MSB），将 $v_8$ 视为最低有效位（LSB）。\n\n根据位置数字系统的原理，一个 $8$ 位二进制数 $(b_7 b_6 b_5 b_4 b_3 b_2 b_1 b_0)_2$ 对应于由以 2 为基数的多项式给出的整数 $N$：\n$$\nN = \\sum_{i=0}^{7} b_i \\cdot 2^i = b_7 \\cdot 2^7 + b_6 \\cdot 2^6 + \\dots + b_0 \\cdot 2^0\n$$\n在我们的例子中，二进制表示由 $v$ 的元素给出，其中 $v_1$ 对应最高次幂位（$b_7$），$v_2$ 对应下一位（$b_6$），以此类推，直到 $v_8$ 对应最低次幂位（$b_0$）。映射索引后，位 $v_k$（对于 $k \\in \\{1, \\dots, 8\\}$）对应于位置系数 $b_{8-k}$。因此，整数 $R$ 定义为：\n$$\nR = v_1 \\cdot 2^7 + v_2 \\cdot 2^6 + v_3 \\cdot 2^5 + v_4 \\cdot 2^4 + v_5 \\cdot 2^3 + v_6 \\cdot 2^2 + v_7 \\cdot 2^1 + v_8 \\cdot 2^0 = \\sum_{k=1}^{8} v_k \\cdot 2^{8-k}\n$$\n\n**2. 逆映射（R 到 v）的推导**\n\n任务是执行逆运算：给定一个整数 $R$，我们必须找到其二进制展开的系数 $v_k \\in \\{0,1\\}$。这是一个标准的基数转换过程，可以进行形式化推导。\n\n让我们从 $R$ 中找到一个通用位 $v_k$，对于 $k \\in \\{1, \\dots, 8\\}$。位 $v_k$ 是项 $2^{8-k}$ 的系数。设 $p_k = 8-k$ 是对应于 $v_k$ 的 $2$ 的幂。幂 $p_k$ 的范围从 $p_1=7$（对于 MSB $v_1$）到 $p_8=0$（对于 LSB $v_8$）。\n\n为了分离出 $v_k$，我们可以操纵 $R$ 的表达式。让我们将 $R$ 除以 $2^{p_k}$：\n$$\n\\frac{R}{2^{p_k}} = \\frac{1}{2^{p_k}} \\sum_{j=1}^{8} v_j \\cdot 2^{8-j} = \\sum_{j=1}^{8} v_j \\cdot 2^{(8-j)-p_k}\n$$\n我们可以在索引 $k$ 处拆分这个和：\n$$\n\\frac{R}{2^{p_k}} = \\sum_{j=1}^{k} v_j \\cdot 2^{(p_j - p_k)} + \\sum_{j=k+1}^{8} v_j \\cdot 2^{(p_j - p_k)}\n$$\n第一个求和包含具有非负次幂的 $2$ 的项，而第二个求和包含具有负次幂的项。\n$$\n\\frac{R}{2^{p_k}} = \\underbrace{(v_1 \\cdot 2^{p_1-p_k} + \\dots + v_{k-1} \\cdot 2^{p_{k-1}-p_k} + v_k \\cdot 2^0)}_{\\text{整数部分}} + \\underbrace{(v_{k+1} \\cdot 2^{-1} + \\dots + v_8 \\cdot 2^{-(8-k)})}_{\\text{小数部分}}\n$$\n通过对此表达式取底，我们消除了小数部分：\n$$\n\\left\\lfloor \\frac{R}{2^{p_k}} \\right\\rfloor = v_1 \\cdot 2^{p_1-p_k} + \\dots + v_{k-1} \\cdot 2^{1} + v_k\n$$\n和中的每一项，除了最后一项 ($v_k$)，都是 $2$ 的倍数。因此，如果我们对整个表达式取模 $2$，我们就能分离出 $v_k$：\n$$\n\\left\\lfloor \\frac{R}{2^{p_k}} \\right\\rfloor \\pmod 2 = (v_1 \\cdot 2^{p_1-p_k} + \\dots + v_{k-1} \\cdot 2^{1} + v_k) \\pmod 2 = v_k\n$$\n这为我们提供了每个位 $v_k$ 的直接公式：\n$$\nv_k = \\left\\lfloor \\frac{R}{2^{8-k}} \\right\\rfloor \\pmod 2, \\quad \\text{for } k=1, 2, \\dots, 8.\n$$\n\n**3. 算法过程**\n\n推导出的公式直接转化为一个算法。为了构造向量 $v = (v_1, \\dots, v_8)$，我们可以从 $k=1$ 迭代到 $k=8$。在编程中，整数除法 `R // (2**p)` 对应于 $\\lfloor R / 2^p \\rfloor$，而取模运算符 `... % 2` 对应于 $\\pmod 2$。\n\n更高效地，这些操作可以使用位运算符实现。操作 $\\lfloor R / 2^p \\rfloor$ 等效于将 $R$ 按位右移 $p$ 位（表示为 $R \\gg p$）。操作 $\\pmod 2$ 等效于与 $1$ 进行按位与（表示为 $\\land 1$）。\n\n因此，算法如下：\n1. 为真值表向量 $v$ 初始化一个空列表。\n2. 用索引 $k$ 从 $1$ 迭代到 $8$。这对应于 $v$ 的分量。\n3. 对于每个 $k$，计算相应的位位置（$2$ 的幂）为 $p = 8 - k$。这将使 $p$ 从 $7$ 遞減到 $0$。\n4. 计算位值为 $v_k = (R \\gg p) \\land 1$。\n5. 将此位值附加到列表 $v$ 中。\n6. 循环完成后，列表 $v$ 将按正确顺序包含真值表的 $8$ 位。\n\n该算法是推导出的数学过程的直接实现，并且仅依赖于二进制表示法的基本属性。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# No external libraries are needed for this solution.\n\ndef solve():\n    \"\"\"\n    Solves the problem of converting Wolfram codes for Elementary Cellular Automata\n    into their corresponding truth table vectors.\n    \"\"\"\n\n    def get_truth_table_vector(wolfram_code: int) -> list[int]:\n        \"\"\"\n        Derives the 8-bit truth table vector from an ECA Wolfram code.\n\n        The Wolfram code R is the integer representation of the 8-bit truth table\n        v = (v1, v2, ..., v8), where v1 is the most significant bit.\n        The truth table bits correspond to the neighborhood outputs in the order:\n        (1,1,1), (1,1,0), (1,0,1), (1,0,0), (0,1,1), (0,1,0), (0,0,1), (0,0,0).\n\n        The bit v_k corresponds to the coefficient of 2^(8-k). It can be extracted\n        using bitwise operations. The bit at position p (from the right, 0-indexed)\n        is found by (R >> p)  1.\n        For v1, p=7. For v2, p=6, ..., for v8, p=0.\n\n        Args:\n            wolfram_code: An integer between 0 and 255.\n\n        Returns:\n            A list of 8 integers (0 or 1) representing the truth table.\n        \"\"\"\n        if not 0 = wolfram_code = 255:\n            raise ValueError(\"Wolfram code must be between 0 and 255.\")\n\n        vector = []\n        # The powers of 2 for the bits range from 7 (MSB) down to 0 (LSB).\n        for power in range(7, -1, -1):\n            # Isolate the bit at the current power's position.\n            # (wolfram_code >> power) shifts the bit to the LSB position.\n            #  1 extracts this bit's value.\n            bit = (wolfram_code >> power)  1\n            vector.append(bit)\n        \n        return vector\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        0,   # Boundary case: all outputs 0\n        1,   # Boundary case: least significant bit set\n        30,  # Canonical complex rule\n        90,  # Canonical additive rule\n        110, # Canonical complex rule\n        128, # Boundary case: most significant bit set\n        255  # Boundary case: all outputs 1\n    ]\n\n    results = []\n    for R in test_cases:\n        truth_table = get_truth_table_vector(R)\n        results.append(truth_table)\n\n    # Final print statement in the exact required format.\n    # The default string representation of a list in Python includes spaces,\n    # which is consistent with the problem's LaTeX example format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在理解了规则的定义方式之后，下一步是分析它们的动力学行为。本练习将介绍“前驱”（predecessor）和“伊甸园”（Garden of Eden）构型的概念，这些概念与元胞自动机全局更新函数的满射性（surjectivity）有关。通过一个具体的例子，你将学习并应用强大的传输矩阵法（transfer matrix method），来计算在规则184（一个著名的交通流模型）下一个特定构型的前驱数量。",
            "id": "4266043",
            "problem": "考虑一个在长度为 $L$ 的周期性晶格（环）上的二元一维初等元胞自动机 (ECA)，其作用半径 $r=1$，更新规则由 Wolfram 的 184 号规则给出。ECA 在时刻 $t$ 的状态由序列 $\\{s_i(t)\\}_{i=0}^{L-1}$ 表示，其中 $s_i(t) \\in \\{0,1\\}$，且具有周期性边界条件 $s_{i+L}(t) = s_i(t)$。局部更新规则根据 184 号规则的真值表产生下一个状态 $s_i(t+1) = f(s_{i-1}(t), s_i(t), s_{i+1}(t))$：\n$$\nf(1,1,1)=1,\\quad f(1,1,0)=0,\\quad f(1,0,1)=1,\\quad f(1,0,0)=1,\\quad f(0,1,1)=1,\\quad f(0,1,0)=0,\\quad f(0,0,1)=0,\\quad f(0,0,0)=0.\n$$\n已知该自动机可用于模拟保守输运（交通流），其中 1 代表一个粒子，0 代表一个空位。\n\n设 $L=20$，目标构型 $\\{t_i\\}_{i=0}^{19}$ 定义为 $t_i = i \\bmod 2$，即长度为 20、严格交替的模式 $t = 0101\\cdots 01$，且 $t_0=0$。$t$ 的一个前驱是任何构型 $\\{s_i\\}_{i=0}^{19} \\in \\{0,1\\}^{20}$，该构型在应用一次 184 号规则（在环形拓扑上）后能够产生 $t$。\n\n从元胞自动机的基本定义及其在环上的局部映射组合出发，推导出一个有原理的方法来计算在 184 号规则下 $t$ 的不同前驱的数量 $N$。根据你的推导，判断 $t$ 是否为伊甸园（一个没有前驱的构型）。\n\n将你的最终答案表示为有序对 $(N,g)$，其中 $N$ 是 $t$ 的前驱总数，如果 $t$ 是伊甸园，则 $g$ 等于 1，否则等于 0。无需四舍五入，不涉及单位。按照最终答案格式的要求表示该有序对 $(N,g)$。",
            "solution": "用户希望找到一个初等元胞自动机中特定构型的前驱数量。\n\n### 步骤 1：提取已知条件\n- **系统**：二元一维初等元胞自动机 (ECA)。\n- **晶格**：长度为 $L=20$ 的周期性环。\n- **半径**：$r=1$。\n- **更新规则**：Wolfram 的 184 号规则。\n- **真值表**：\n  - $f(1,1,1)=1$\n  - $f(1,1,0)=0$\n  - $f(1,0,1)=1$\n  - $f(1,0,0)=1$\n  - $f(0,1,1)=1$\n  - $f(0,1,0)=0$\n  - $f(0,0,1)=0$\n  - $f(0,0,0)=0$\n- **状态表示**：$\\{s_i(t)\\}_{i=0}^{L-1}$，$s_i(t) \\in \\{0,1\\}$。\n- **边界条件**：周期性，$s_{i+L}(t) = s_i(t)$。\n- **局部更新规则**：$s_i(t+1) = f(s_{i-1}(t), s_i(t), s_{i+1}(t))$。\n- **目标构型**：$\\{t_i\\}_{i=0}^{19}$，其中 $t_i = i \\bmod 2$。\n- **定义**：$t$ 的一个前驱是任何构型 $\\{s_i\\}$，该构型在应用一次 184 号规则后能够产生 $t$。\n- **定义**：伊甸园是一个没有前驱的构型。\n- **目标**：找到前驱的数量 $N$ 和一个标志 $g$，如果该构型是伊甸园，则 $g=1$，否则 $g=0$。\n- **最终答案格式**：一个有序对 $(N, g)$。\n\n### 步骤 2：使用提取的已知条件进行验证\n该问题具有科学依据，是元胞自动机理论中的一个标准问题。它定义良好（well-posed），所有必要的参数（$L$、规则、目标构型）都已明确定义。语言客观且正式。该问题是自洽、一致的，并且需要严谨且不平凡的数学推导。前驱和伊甸园的概念是研究元胞自动机动力学的基础。\n\n### 步骤 3：结论与行动\n问题有效。将推导完整解法。\n\n### 推导\n一个构型 $s = \\{s_i\\}_{i=0}^{L-1}$ 是目标构型 $t = \\{t_i\\}_{i=0}^{L-1}$ 的前驱，如果对于每个位点 $i \\in \\{0, 1, \\dots, L-1\\}$，以下方程都成立：\n$$t_i = f(s_{i-1}, s_i, s_{i+1})$$\n其中索引在模 $L=20$ 的意义下取值。这构成了一个关于变量 $\\{s_i\\}$ 的 20 个耦合非线性方程组。\n\n该方程组可以使用转移矩阵法求解。我们将每个位置 $i$ 的“状态”定义为元胞值的对 $(s_{i-1}, s_i)$。共有 $2^2=4$ 种可能的状态：$(0,0)$、$(0,1)$、$(1,0)$ 和 $(1,1)$。局部规则 $t_i = f(s_{i-1}, s_i, s_{i+1})$ 作为从位置 $i$ 的状态 $(s_{i-1}, s_i)$ 到位置 $i+1$ 的状态 $(s_i, s_{i+1})$ 的转移约束。\n\n目标构型由 $t_i = i \\bmod 2$ 给出，产生模式 $t = 010101\\dots01$。由于 $t_i$ 的值取决于 $i$ 是偶数还是奇数，我们必须定义两个独立的转移矩阵：\n1.  $M_0$ 对应于偶数 $i$，此时 $t_i=0$。\n2.  $M_1$ 对应于奇数 $i$，此时 $t_i=1$。\n\n如果在约束 $t_i=k$ 下，从状态 $u=(s_{i-1}, s_i)$ 到状态 $v=(s_i, s_{i+1})$ 的转移是允许的，则转移矩阵的元素 $(M_k)_{uv}$ 为 1，否则为 0。我们将状态映射到索引如下：$0 \\leftrightarrow (0,0)$，$1 \\leftrightarrow (0,1)$，$2 \\leftrightarrow (1,0)$，$3 \\leftrightarrow (1,1)$。\n\n**构建 $M_0$ (针对 $t_i=0$)：**\n在 184 号规则下映射到 $0$ 的输入邻域 $(s_{i-1}, s_i, s_{i+1})$ 集合为：\n$\\{(1,1,0), (0,1,0), (0,0,1), (0,0,0)\\}$。\n- 从状态 $(0,0)$：邻域为 $(0,0,0)$ 和 $(0,0,1)$。这些导致下一个状态为 $(0,0)$ 和 $(0,1)$。\n- 从状态 $(0,1)$：邻域为 $(0,1,0)$，导致下一个状态为 $(1,0)$。\n- 从状态 $(1,0)$：没有以 $(1,0)$ 开始并映射到 0 的邻域。\n- 从状态 $(1,1)$：邻域为 $(1,1,0)$，导致下一个状态为 $(1,0)$。\n这给出矩阵：\n$$M_0 = \\begin{pmatrix} 1  1  0  0 \\\\ 0  0  1  0 \\\\ 0  0  0  0 \\\\ 0  0  1  0 \\end{pmatrix}$$\n\n**构建 $M_1$ (针对 $t_i=1$)：**\n映射到 1 的输入邻域集合为：\n$\\{(1,1,1), (1,0,1), (1,0,0), (0,1,1)\\}$。\n- 从状态 $(0,0)$：没有以 $(0,0)$ 开始并映射到 1 的邻域。\n- 从状态 $(0,1)$：邻域为 $(0,1,1)$，导致下一个状态为 $(1,1)$。\n- 从状态 $(1,0)$：邻域为 $(1,0,0)$ 和 $(1,0,1)$。这些导致下一个状态为 $(0,0)$ 和 $(0,1)$。\n- 从状态 $(1,1)$：邻域为 $(1,1,1)$，导致下一个状态为 $(1,1)$。\n这给出矩阵：\n$$M_1 = \\begin{pmatrix} 0  0  0  0 \\\\ 0  0  0  1 \\\\ 1  1  0  0 \\\\ 0  0  0  1 \\end{pmatrix}$$\n\n前驱构型的总数 $N$ 是环上长度为 $L=20$ 的有效闭合路径的数量。这由总转移矩阵 $M_{total}$ 的迹给出。总矩阵是每个位点的单个矩阵按其索引逆序的乘积。\n$$M_{total} = M_{t_{19}} M_{t_{18}} \\cdots M_{t_1} M_{t_0}$$\n给定 $t=0101\\dots01$，我们有 $t_0=0, t_1=1, t_2=0, \\dots, t_{18}=0, t_{19}=1$。\n$$M_{total} = M_1 M_0 M_1 M_0 \\cdots M_1 M_0 = (M_1 M_0)^{10}$$\n\n让我们计算乘积 $A = M_1 M_0$：\n$$A = M_1 M_0 = \\begin{pmatrix} 0  0  0  0 \\\\ 0  0  0  1 \\\\ 1  1  0  0 \\\\ 0  0  0  1 \\end{pmatrix} \\begin{pmatrix} 1  1  0  0 \\\\ 0  0  1  0 \\\\ 0  0  0  0 \\\\ 0  0  1  0 \\end{pmatrix} = \\begin{pmatrix} 0  0  0  0 \\\\ 0  0  1  0 \\\\ 1  1  1  0 \\\\ 0  0  1  0 \\end{pmatrix}$$\n我们需要计算 $N = \\text{Tr}(A^{10})$。我们可以通过找到 $A^n$ 的通项形式来做到这一点。设 $F_n$ 为第 $n$ 个斐波那契数，其中 $F_0=0, F_1=1, F_2=1, \\dots$。\n让我们假设 $A^n$ 对于 $n \\ge 1$ 的一个形式：\n$$A^n = \\begin{pmatrix} 0  0  0  0 \\\\ F_{n-1}  F_{n-1}  F_{n}  0 \\\\ F_{n}  F_{n}  F_{n+1}  0 \\\\ F_{n-1}  F_{n-1}  F_{n}  0 \\end{pmatrix}$$\n(按照惯例 $F_{-1}=1$）。\n让我们检查 $n=1$ 的情况：$A^1 = \\begin{pmatrix} 0  0  0  0 \\\\ F_0  F_0  F_1  0 \\\\ F_1  F_1  F_2  0 \\\\ F_0  F_0  F_1  0 \\end{pmatrix} = \\begin{pmatrix} 0  0  0  0 \\\\ 0  0  1  0 \\\\ 1  1  1  0 \\\\ 0  0  1  0 \\end{pmatrix}$。这与我们的矩阵 $A$ 相符。\n\n我们用数学归纳法证明这个形式。假设它对 $n$ 成立。那么对于 $n+1$：\n$$A^{n+1} = A^n A = \\begin{pmatrix} 0  0  0  0 \\\\ F_{n-1}  F_{n-1}  F_{n}  0 \\\\ F_{n}  F_{n}  F_{n+1}  0 \\\\ F_{n-1}  F_{n-1}  F_{n}  0 \\end{pmatrix} \\begin{pmatrix} 0  0  0  0 \\\\ 0  0  1  0 \\\\ 1  1  1  0 \\\\ 0  0  1  0 \\end{pmatrix}$$\n将 $A^n$ 的第三行乘以 $A$：\n$$(F_n, F_n, F_{n+1}, 0) \\cdot A = (F_{n+1}, F_{n+1}, F_n+F_{n+1}, 0) = (F_{n+1}, F_{n+1}, F_{n+2}, 0)$$\n这与假设的 $A^{n+1}$ 第三行的形式一致。\n将 $A^n$ 的第二行乘以 $A$：\n$$(F_{n-1}, F_{n-1}, F_{n}, 0) \\cdot A = (F_n, F_n, F_{n-1}+F_n, 0) = (F_n, F_n, F_{n+1}, 0)$$\n这与 $A^{n+1}$ 第二行的形式一致。第四行与第二行相同。第一行保持为零。归纳成立。\n\n现在我们可以计算 $N = \\text{Tr}(A^{10})$：\n$$A^{10} = \\begin{pmatrix} 0  0  0  0 \\\\ F_{9}  F_{9}  F_{10}  0 \\\\ F_{10}  F_{10}  F_{11}  0 \\\\ F_9  F_9  F_{10}  0 \\end{pmatrix}$$\n$$N = \\text{Tr}(A^{10}) = 0 + F_9 + F_{11} + 0 = F_9 + F_{11}$$\n我们计算所需的斐波那契数：\n$F_0=0, F_1=1, F_2=1, F_3=2, F_4=3, F_5=5, F_6=8, F_7=13, F_8=21, F_9=34, F_{10}=55, F_{11}=89$。\n$$N = 34 + 89 = 123$$\n不同前驱的数量为 $N=123$。\n\n如果一个构型没有前驱，即 $N=0$，那么它就是伊甸园。因为 $N=123 \\ne 0$，所以目标构型 $t$ 不是伊甸园。因此，指示变量 $g$ 为 0。\n\n最终答案是有序对 $(N,g) = (123,0)$。\n这个结果可以用 $A$ 的特征值进行交叉检验。特征多项式是 $\\det(A-\\lambda I) = \\lambda^2(\\lambda^2-\\lambda-1)$。特征值为 $\\lambda=0$（重数为 2）、$\\lambda=\\phi = \\frac{1+\\sqrt{5}}{2}$ 和 $\\lambda=1-\\phi = \\frac{1-\\sqrt{5}}{2}$。该矩阵是可对角化的，所以 $\\text{Tr}(A^{10}) = \\sum \\lambda_i^{10} = 0^{10} + 0^{10} + \\phi^{10} + (1-\\phi)^{10}$。这个和是第 10 个卢卡斯数 $L_{10}$ 的定义。卢卡斯数序列以 $L_0=2, L_1=1, L_2=3, \\dots$ 开始，递推关系为 $L_n=L_{n-1}+L_{n-2}$。我们求得 $L_{10}=123$。恒等式 $L_n=F_{n-1}+F_{n+1}$ 进一步证实了 $L_{10} = F_9+F_{11}$，从而验证了我们的矩阵幂运算结果。",
            "answer": "$$ \\boxed{\\begin{pmatrix} 123  0 \\end{pmatrix}} $$"
        },
        {
            "introduction": "除了从单个状态出发的确定性演化，我们通常也对元胞自动机从随机初始条件开始的统计行为感兴趣。本练习将焦点转移到一个计算实验上，你将探索在康威生命游戏（Conway's Game of Life）、混沌的规则30（Rule 30）以及复杂的规则110（Rule 110）等标志性模型中，初始“存活”细胞的密度如何影响系统的最终命运。这个模拟练习让学生能够通过经验性研究，探索相变和从随机性中涌现秩序等复杂系统研究的核心概念。",
            "id": "4266022",
            "problem": "考虑在 Wolfram 的初级细胞自动机和 Conway 的生命游戏 (GoL) 的经典更新规则下的二元状态细胞自动机 (CA)。设状态空间是离散且有限的，时间以离散步长推进。本问题的基本基础是对所有位点同步应用的确定性局部更新规则的定义，以及通过独立同分布的伯努利试验对构型进行的概率性初始化。\n\n定义与设置：\n- 一个一维初级细胞自动机由一个包含 $M$ 个细胞的环组成，细胞具有二元状态 $\\{0,1\\}$，在时间 $t \\mapsto t+1$ 时根据一个由 Wolfram 规则编号 $R \\in \\{0,1,\\dots,255\\}$ 决定的映射进行同步更新。每个位点的更新取决于其半径为 1 的邻域 $\\{x_{i-1}(t), x_{i}(t), x_{i+1}(t)\\}$。\n- Conway 的生命游戏 (GoL) 由一个大小为 $N \\times N$、具有二元状态 $\\{0,1\\}$ 的二维环形网格组成。在时间 $t \\mapsto t+1$ 时的更新规则是：如果一个活细胞恰好有 $2$ 或 $3$ 个活邻居，则它保持存活；如果一个死细胞恰好有 $3$ 个活邻居，则它变为活细胞；否则，该细胞变为或保持死亡状态。邻居计数是根据环面上的 $8$ 个最近邻居计算的。\n- 密度为 $p \\in [0,1]$ 的随机初始构型通过独立的伯努利试验生成，其中每个位点有概率 $p$ 为活（状态 $1$），有概率 $1-p$ 为死（状态 $0$）。\n- 如果存在一个有限的瞬态时间，在此之后全局构型满足 $X_{t} = X_{t-1}$（周期为 $1$）或 $X_{t} = X_{t-2}$（周期为 $2$），则称该构型为最终周期性，且周期小于或等于 $2$。我们将这种最终周期性的出现称为稳定结构的出现。\n\n目标：\n对于密度为 $p$ 的随机初始构型，估计稳定结构出现的临界 $p$。该临界 $p$ 定义为：在一个给定的离散密度集合中，使得稳定化（在固定时间范围内最终周期小于或等于 $2$）的经验概率至少为 $0.5$ 的最小 $p$ 值。然后将此估计值与已报道的关于经典规则的定性经验发现进行比较。\n\n估计协议：\n- 对于每个选定的 $p$，运行 $S$ 次独立试验（每次试验使用一个独立的随机种子），将细胞自动机从随机初始构型演化 $T$ 步，并测试最终构型 $X_{T}$ 是否满足 $X_{T}=X_{T-1}$ 或 $X_{T}=X_{T-2}$。令 $\\hat{q}(p)$ 表示满足此稳定性标准的试验所占的比例。\n- 将估计的临界密度 $p^{\\star}$ 定义为使得 $\\hat{q}(p) \\ge 0.5$ 的最小测试密度 $p$。如果在测试的 $p$ 中没有一个能达到 $\\hat{q}(p) \\ge 0.5$，则输出 $-1.0$ 作为估计值，以表示“在网格内未找到”。\n\n科学真实性与约束：\n- 所有模拟均使用环形边界条件，以避免边界效应并确保空间同质性。\n- 测试范围 $T$ 和试验次数 $S$ 是有限的，我们承认最终周期可能在时间 $T$ 之后出现，但估计标准使用观测到的时间范围。\n\n测试套件：\n评估以下三个案例，以检验动力学的不同方面：\n1. 在 $N \\times N$ 环面上运行 GoL，其中 $N=64$，$T=256$，$S=16$，测试密度 $p \\in \\{0.05, 0.10, 0.20, 0.30, 0.40\\}$。\n2. 在大小为 $M=256$ 的一维环上运行初级细胞自动机规则 $R=110$，其中 $T=256$，$S=16$，测试密度 $p \\in \\{0.05, 0.10, 0.20, 0.30, 0.40\\}$。\n3. 在大小为 $M=256$ 的一维环上运行初级细胞自动机规则 $R=30$，其中 $T=256$，$S=16$，测试密度 $p \\in \\{0.05, 0.10, 0.20, 0.30, 0.40\\}$。\n\n答案规格：\n- 对于上述三个案例中的每一个，使用以上定义计算估计的 $p^{\\star}$，并将每个结果四舍五入到小数点后两位。\n- 如果在测试的网格内未找到临界密度（即稳定化比例从未达到 $0.5$），则该案例输出 $-1.00$。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按案例 $1$ 到 $3$ 的顺序列出结果，例如：“[$p^{\\star}_{\\mathrm{GoL}},$ $p^{\\star}_{110},$ $p^{\\star}_{30}$]”。这些值必须打印为四舍五入到小数点后两位的浮点数。\n\n本问题不涉及角度或物理单位，因此无需单位说明。",
            "solution": "用户提供了一个有效、良构且有科学依据的计算问题。任务是为三种不同的细胞自动机系统中简单周期行为的出现，估计一个关键参数，即初始密度 $p^{\\star}$。该问题植根于复杂系统领域的经典范畴，特别是关于 Wolfram 的初级细胞自动机 (CA) 和 Conway 的生命游戏 (GoL) 的动力学。所有参数、定义和程序都以足够的严谨性进行了规定，从而能够得到唯一且可验证的解。\n\n该问题将通过实施指定的蒙特卡洛模拟协议来解决。对于每个系统和给定离散集合中的每个候选密度 $p$，我们将模拟自动机在指定试验次数和时间步长下的演化。然后，我们将根据系统达到稳定状态的经验概率来确定临界密度 $p^{\\star}$。\n\n针对每个测试案例，整体方法由几个关键阶段组成：\n$1$. **系统初始化**：对于 $S$ 次独立试验中的每一次，都会生成一个初始构型。这是一个细胞网格（对于初级 CA 是大小为 $M$ 的一维环，对于 GoL 是大小为 $N \\times N$ 的二维环面），其中每个细胞以概率 $p$ 设置为状态 $1$（活），以概率 $1-p$ 设置为状态 $0$（死）。这是通过对每个位点从伯努利分布中抽样来实现的。\n\n$2$. **时间演化**：自动机同步演化 $T$ 个离散时间步。在每一步 $t$，时间 $t+1$ 时每个细胞的状态是根据其局部邻域在时间 $t$ 的状态计算的。更新规则是确定性的，并同时应用于所有细胞。为了管理边界效应并保持空间同质性，所有模拟都采用周期性（环形）边界条件。\n\n$3$. **稳定性评估**：该协议将稳定性定义为出现周期为 $1$ 或 $2$ 的周期性构型。这在模拟范围的末尾，即时间 $T$ 进行测试。如果自动机在时间 $T$ 的全局状态 $X_{T}$ 与前一步的状态 $X_{T-1}$ 或再前一步的状态 $X_{T-2}$ 相同，则该次试验被认为是稳定的。也就是说，条件是 $X_{T} = X_{T-1} \\lor X_{T} = X_{T-2}$。要执行此检查，必须存储最后三个时间步（$T-2$、$T-1$ 和 $T$）的构型。\n\n$4$. **$p^{\\star}$ 的统计估计**：对于给定的密度 $p$，稳定化的经验概率 $\\hat{q}(p)$ 计算为满足稳定性标准的 $S$ 次试验所占的比例。然后，临界密度 $p^{\\star}$ 定义为测试集 $\\{0.05, 0.10, 0.20, 0.30, 0.40\\}$ 中使得 $\\hat{q}(p) \\ge 0.5$ 的最小密度 $p$。如果没有测试密度满足此条件，则将 $p^{\\star}$ 指定为 $-1.0$。\n\n三个测试案例的具体更新规则实现如下：\n\n**案例 1：Conway 的生命游戏 (GoL)**\nGoL 在二维网格上演化。一个细胞的邻域由其 $8$ 个相邻细胞（Moore 邻域）组成。更新规则，称为 B3/S23，是：\n- 一个有恰好 $3$ 个活邻居的死细胞变为活细胞（诞生）。\n- 一个有 $2$ 或 $3$ 个活邻居的活细胞保持存活（生存）。\n- 在所有其他情况下，细胞变为或保持死亡状态（由于拥挤或孤单）。\n网格中每个细胞的活邻居数量可以通过二维卷积来高效计算。一个核矩阵 $K = \\begin{pmatrix} 1  1  1 \\\\ 1  0  1 \\\\ 1  1  1 \\end{pmatrix}$ 与二元状态网格进行卷积。周期性边界条件通过卷积函数的 'wrap' 模式处理。\n\n**案例 2 与 3：初级细胞自动机（规则 $110$ 和 $30$）**\n初级细胞自动机在一维环上演化。细胞 $x_i$ 在时间 $t+1$ 的状态由其在时间 $t$ 的半径为 1 的邻域 $\\{x_{i-1}(t), x_i(t), x_{i+1}(t)\\}$ 的状态决定。共有 $2^3 = 8$ 种可能的邻域构型，可以解释为从 $(0,0,0)$ 到 $(1,1,1)$ 的 3 位二进制数，对应整数值 $0$ 到 $7$。一个 Wolfram 规则编号 $R \\in \\{0, \\dots, 255\\}$ 是一个 8 位整数。$R$ 的第 $k$ 位（从右到左，0-索引）指定了整数值为 $k$ 的邻域构型的输出状态。\n例如，对于规则 $R=30$，其二进制表示为 $00011110_2$。对于从 $(0,0,0)$ 到 $(1,1,1)$ 的邻域，规则的查找表分别为 $[0, 1, 1, 1, 1, 0, 0, 0]$。整个网格的更新可以被高效地向量化。对于一个网格 `c`，所有细胞的邻域索引计算为 $4 \\times \\text{roll}(c, 1) + 2 \\times c + 1 \\times \\text{roll}(c, -1)$，其中 `roll` 执行循环移位。然后通过使用这个索引数组对规则的查找表进行索引来生成新的网格。同样的过程也适用于规则 $R=110$ 和规则 $R=30$。\n\n规则 $30$ 以其混沌行为（Wolfram III 类）而闻名，使其成为伪随机数生成器的候选者。其动力学高度不可预测，不太可能稳定到简单的周期轨道上。规则 $110$ 是一个 IV 类自动机，以其支持复杂、持久结构（滑翔机）的能力和计算普适性而闻名。这种复杂性也表明它可能不容易稳定。GoL 因其丰富的模式库而著名，从简单的静态或振荡形式到复杂的“滑翔机”和“宇宙飞船”，其最终状态对初始密度高度敏感。指定的协议将被执行，以量化这三个不同系统在随机初始条件下稳定的倾向。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.signal import convolve2d\n\ndef solve():\n    \"\"\"\n    Main function to run the cellular automata simulations and find the critical densities.\n    \"\"\"\n\n    # For reproducibility of the entire set of results.\n    np.random.seed(42)\n\n    # --- Helper functions for simulations ---\n\n    def _get_eca_lookup_table(rule_number):\n        \"\"\"Generates the lookup table for a Wolfram elementary CA rule.\"\"\"\n        if not (0 = rule_number = 255):\n            raise ValueError(\"Rule number must be between 0 and 255.\")\n        # The binary string corresponds to neighborhoods 7 down to 0.\n        # We reverse it to map index k to neighborhood k.\n        binary_string = f'{rule_number:08b}'\n        return np.array([int(bit) for bit in binary_string], dtype=np.int8)[::-1]\n\n    ECA_LOOKUP_TABLES = {\n        30: _get_eca_lookup_table(30),\n        110: _get_eca_lookup_table(110)\n    }\n\n    def _estimate_p_star_eca(M, R, T, S, p_grid):\n        \"\"\"\n        Estimates the critical density p* for an elementary cellular automaton.\n        \"\"\"\n        lookup_table = ECA_LOOKUP_TABLES[R]\n        for p in p_grid:\n            stable_count = 0\n            for _ in range(S):\n                # 1. Initialization\n                grid = (np.random.rand(M)  p).astype(np.int8)\n                \n                # History stores [t-2, t-1, t]\n                history = [None, None, grid.copy()]\n\n                # 2. Temporal Evolution\n                for _ in range(T):\n                    # Efficiently calculate neighborhood indices for all cells\n                    left_shifted = np.roll(grid, 1)\n                    right_shifted = np.roll(grid, -1)\n                    indices = 4 * left_shifted + 2 * grid + 1 * right_shifted\n                    \n                    grid = lookup_table[indices]\n\n                    # Update history\n                    history[0] = history[1]\n                    history[1] = history[2]\n                    history[2] = grid.copy()\n\n                # 3. Stability Assessment\n                is_period_1 = np.array_equal(history[2], history[1])\n                is_period_2 = (history[0] is not None) and np.array_equal(history[2], history[0])\n                \n                if is_period_1 or is_period_2:\n                    stable_count += 1\n            \n            # 4. Statistical Estimation\n            q_hat = stable_count / S\n            if q_hat >= 0.5:\n                return p\n        \n        return -1.0\n    \n    def _estimate_p_star_gol(N, T, S, p_grid):\n        \"\"\"\n        Estimates the critical density p* for Conway's Game of Life.\n        \"\"\"\n        # Kernel for counting neighbors using convolution\n        kernel = np.array([[1, 1, 1], \n                           [1, 0, 1], \n                           [1, 1, 1]], dtype=np.int8)\n        \n        for p in p_grid:\n            stable_count = 0\n            for _ in range(S):\n                # 1. Initialization\n                grid = (np.random.rand(N, N)  p).astype(np.int8)\n                history = [None, None, grid.copy()]\n\n                # 2. Temporal Evolution\n                for _ in range(T):\n                    # Count neighbors using convolution with 'wrap' for toroidal boundaries\n                    neighbor_counts = convolve2d(grid, kernel, mode='same', boundary='wrap')\n                    \n                    # Apply GoL rules (B3/S23)\n                    # Birth: dead cell (grid==0) with 3 neighbors becomes live\n                    births = (grid == 0)  (neighbor_counts == 3)\n                    # Survival: live cell (grid==1) with 2 or 3 neighbors stays live\n                    survivals = (grid == 1)  ((neighbor_counts == 2) | (neighbor_counts == 3))\n                    \n                    grid = (births | survivals).astype(np.int8)\n                    \n                    # Update history\n                    history[0] = history[1]\n                    history[1] = history[2]\n                    history[2] = grid.copy()\n\n                # 3. Stability Assessment\n                is_period_1 = np.array_equal(history[2], history[1])\n                is_period_2 = (history[0] is not None) and np.array_equal(history[2], history[0])\n\n                if is_period_1 or is_period_2:\n                    stable_count += 1\n            \n            # 4. Statistical Estimation\n            q_hat = stable_count / S\n            if q_hat >= 0.5:\n                return p\n\n        return -1.0\n\n    # --- Define and run test cases ---\n\n    test_cases = [\n        {\n            \"id\": \"GoL\", \"func\": _estimate_p_star_gol,\n            \"params\": {\"N\": 64, \"T\": 256, \"S\": 16, \"p_grid\": [0.05, 0.10, 0.20, 0.30, 0.40]}\n        },\n        {\n            \"id\": \"Rule 110\", \"func\": _estimate_p_star_eca,\n            \"params\": {\"M\": 256, \"R\": 110, \"T\": 256, \"S\": 16, \"p_grid\": [0.05, 0.10, 0.20, 0.30, 0.40]}\n        },\n        {\n            \"id\": \"Rule 30\", \"func\": _estimate_p_star_eca,\n            \"params\": {\"M\": 256, \"R\": 30, \"T\": 256, \"S\": 16, \"p_grid\": [0.05, 0.10, 0.20, 0.30, 0.40]}\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = case[\"func\"](**case[\"params\"])\n        results.append(result)\n\n    # --- Format and print the final output ---\n    \n    # The format string ensures two decimal places, e.g., 0.1 -> \"0.10\", -1.0 -> \"-1.00\"\n    formatted_results = [f\"{r:.2f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}