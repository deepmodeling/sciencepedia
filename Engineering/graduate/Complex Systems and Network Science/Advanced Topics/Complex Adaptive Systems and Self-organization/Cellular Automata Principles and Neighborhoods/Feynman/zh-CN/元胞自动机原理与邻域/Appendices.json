{
    "hands_on_practices": [
        {
            "introduction": "元胞自动机的核心在于其局域规则，它决定了整个系统的演化。本练习将引导你“解码”一个著名的规则——规则110——从它的沃尔夫勒姆数（Wolfram number）开始，这是使用元胞自动机的一项基本技能。然后，你将利用这个解码后的规则来预测自动机在随机初始状态下的行为，从而将微观规则与宏观性质联系起来。",
            "id": "4267330",
            "problem": "考虑一个初等元胞自动机（ECA），其定义为一个邻域半径为 $1$ 的一维二元状态元胞自动机，因此在时间 $t$ 的每个位点 $i$ 都有一个由三个位点组成的邻域 $(s_{i-1}(t), s_{i}(t), s_{i+1}(t)) \\in \\{0,1\\}^{3}$，并且下一状态由局部更新函数 $f: \\{0,1\\}^{3} \\to \\{0,1\\}$ 确定。Wolfram 编码约定为每个规则编号 $R \\in \\{0,1,\\dots,255\\}$ 分配一个 $8$ 位二进制字符串，其中从最高有效位到最低有效位的比特按顺序对应于输出 $f(1,1,1)$, $f(1,1,0)$, $f(1,0,1)$, $f(1,0,0)$, $f(0,1,1)$, $f(0,1,0)$, $f(0,0,1)$, $f(0,0,0)$。\n\n仅使用上述定义和独立伯努利随机变量的标准性质，对特定规则编号 $R=110$ 执行以下操作：\n\n1. 推导 $R$ 的 $8$ 位二进制表示，并按指定顺序写出所有八个邻域模式 $(a,b,c) \\in \\{0,1\\}^{3}$ 的显式局部规则映射 $f(a,b,c)$。验证每个映射都对应于 Wolfram 编码约定下 $R$ 的正确比特位。\n\n2. 假设在时间 $t$ 的当前构型是一个参数为 $p$ 的独立同分布（i.i.d.）伯努利场，即 $P(s_{j}(t)=1)=p$ 且 $\\{s_{j}(t)\\}$ 在所有 $j$ 上相互独立。仅使用独立性和局部规则 $f$，推导概率 $P(s_{i}(t+1)=1)$ 作为 $p$ 的函数。\n\n将您的最终答案报告为关于 $p$ 的单个简化解析表达式。无需四舍五入，也不应包含单位。",
            "solution": "出发点是初等元胞自动机（ECA）的定义，它带有一个局部更新函数 $f: \\{0,1\\}^{3} \\to \\{0,1\\}$，该函数根据三位点邻域 $(s_{i-1}(t), s_{i}(t), s_{i+1}(t))$ 指定下一状态 $s_{i}(t+1)$。Wolfram 编码约定提供了一个从规则编号 $R \\in \\{0,1,\\dots,255\\}$ 到 $f$ 在八种可能的邻域构型上的输出的映射，这些构型按照 $R$ 的 $8$ 位二进制表示中从最高有效位到最低有效位的顺序排列为 $111, 110, 101, 100, 011, 010, 001, 000$。\n\n步骤 $1$：解码规则编号 $R=110$ 并显式写出 $f$。\n\n我们首先将 $R=110$ 转换为其 $8$ 位二进制表示。值 $110$ 可分解为\n$$\n110 = 64 + 32 + 8 + 4 + 2 = 2^{6} + 2^{5} + 2^{3} + 2^{2} + 2^{1}.\n$$\n因此，从最高有效位到最低有效位的 $8$ 位二进制展开式为\n$$\n01101110,\n$$\n这对应于比特向量\n$$\nb_{7}\\ b_{6}\\ b_{5}\\ b_{4}\\ b_{3}\\ b_{2}\\ b_{1}\\ b_{0} = 0\\ 1\\ 1\\ 0\\ 1\\ 1\\ 1\\ 0,\n$$\n其中 $b_{k} \\in \\{0,1\\}$ 且 $b_{7}$ 是最高有效位。根据 Wolfram 约定，这些比特按以下顺序映射到邻域构型：\n$$\n111 \\mapsto b_{7},\\quad 110 \\mapsto b_{6},\\quad 101 \\mapsto b_{5},\\quad 100 \\mapsto b_{4},\\quad 011 \\mapsto b_{3},\\quad 010 \\mapsto b_{2},\\quad 001 \\mapsto b_{1},\\quad 000 \\mapsto b_{0}.\n$$\n因此，显式的局部规则值为\n- $f(1,1,1) = 0$,\n- $f(1,1,0) = 1$,\n- $f(1,0,1) = 1$,\n- $f(1,0,0) = 0$,\n- $f(0,1,1) = 1$,\n- $f(0,1,0) = 1$,\n- $f(0,0,1) = 1$,\n- $f(0,0,0) = 0$.\n\n这个映射是对 $R=110$ 的二进制表示 $01101110$ 的直接验证，与 Wolfram 编码顺序一致。\n\n步骤 $2$：在时间 $t$ 处为独立同分布伯努利$(p)$场的条件下，计算 $P(s_{i}(t+1)=1)$。\n\n在独立同分布伯努利$(p)$的假设下，在时间 $t$ 观察到特定邻域 $(a,b,c) \\in \\{0,1\\}^{3}$ 的概率仅由该模式中 $1$ 的数量决定。令 $k(a,b,c) = a + b + c$ 为 $1$ 的数量。则\n$$\nP\\big((s_{i-1}(t), s_{i}(t), s_{i+1}(t)) = (a,b,c)\\big) = p^{k(a,b,c)} (1-p)^{3 - k(a,b,c)}.\n$$\n下一状态 $s_{i}(t+1)$ 等于 $1$ 的情况，恰好对应于那些 $f(a,b,c)=1$ 的邻域。从步骤 $1$ 可知，产生 $1$ 的邻域是\n$$\n(1,1,0),\\ (1,0,1),\\ (0,1,1),\\ (0,1,0),\\ (0,0,1).\n$$\n按 $1$ 的数量分组：\n- 构型 $(1,1,0)$, $(1,0,1)$, $(0,1,1)$ 各有 $k=2$ 个 $1$，总共贡献的概率为 $3\\, p^{2}(1-p)$。\n- 构型 $(0,1,0)$ 和 $(0,0,1)$ 各有 $k=1$ 个 $1$，总共贡献的概率为 $2\\, p(1-p)^{2}$。\n\n因此，\n$$\nP\\big(s_{i}(t+1)=1\\big) = 3\\, p^{2}(1-p) + 2\\, p(1-p)^{2}.\n$$\n我们简化这个表达式：\n$$\n3\\, p^{2}(1-p) + 2\\, p(1-p)^{2} = 3p^{2} - 3p^{3} + 2p - 4p^{2} + 2p^{3} = 2p - p^{2} - p^{3}.\n$$\n因此，所求的概率作为 $p$ 的函数是\n$$\n2p - p^{2} - p^{3}.\n$$\n\n此结果直接源于 ECA 规则的 Wolfram 编码的基本定义以及各位点上伯努利随机变量的独立性。",
            "answer": "$$\\boxed{2 p - p^{2} - p^{3}}$$"
        },
        {
            "introduction": "理解了局域规则如何工作后，下一步是观察它的实际运行。本练习探讨了元胞自动机在有限网格上的行为，其中边界条件的选择——即如何处理边缘——会深刻影响系统的长期演化。你将通过编程实现并比较不同的边界类型，以揭示它们对动力学的影响。",
            "id": "4267346",
            "problem": "考虑一个一维、二元状态的初等元胞自动机 (Elementary Cellular Automaton, ECA)，它定义在一个长度为 $n$ 的有限数组上，邻域半径为 $r=1$，并有一个确定性的局部更新函数 $f:\\{0,1\\}^3\\to\\{0,1\\}$。在离散时间 $t$ 的全局构型表示为 $x(t)\\in\\{0,1\\}^n$。ECA 规则 54 由从三元组 $(a,b,c)\\in\\{0,1\\}^3$ 到新状态 $f(a,b,c)$ 的映射指定，具体如下：\n$$\nf(1,1,1)=0,\\quad f(1,1,0)=0,\\quad f(1,0,1)=1,\\quad f(1,0,0)=1,\\quad f(0,1,1)=0,\\quad f(0,1,0)=1,\\quad f(0,0,1)=1,\\quad f(0,0,0)=0.\n$$\n需要通过比较应用于相同局部规则的三种边界模型来分析 ECA 动力学对边界条件的依赖性：\n- 周期性边界：对于所有索引 $i\\in\\{0,1,\\dots,n-1\\}$，元胞 $i$ 的左邻居是 $x_{(i-1)\\bmod n}$，右邻居是 $x_{(i+1)\\bmod n}$。\n- 固定边界：定义虚拟元胞 $x_{-1}=0$ 和 $x_{n}=0$；对于 $i=0$，左邻居是 $x_{-1}=0$，右邻居是 $x_{1}$；对于 $i=n-1$，左邻居是 $x_{n-2}$，右邻居是 $x_{n}=0$；对于内部索引 $1\\le i\\le n-2$，应用标准邻居。\n- 反射边界：定义虚拟元胞 $x_{-1}=x_{0}$ 和 $x_{n}=x_{n-1}$；对于 $i=0$，左邻居是 $x_{-1}=x_{0}$，右邻居是 $x_{1}$；对于 $i=n-1$，左邻居是 $x_{n-2}$，右邻居是 $x_{n}=x_{n-1}$；对于内部索引 $1\\le i\\le n-2$，应用标准邻居。\n\n从一个初始构型 $x(0)$ 开始，在任何固定的边界条件下，动力学是有限状态空间 $\\{0,1\\}^n$ 上的一个确定性映射，因此最终必然进入一个周期性轨道。定义瞬态长度 $\\tau$ 和周期长度 $p$ 如下。设 $t$ 是第一个满足存在 $t_0  t$ 使得 $x(t) = x(t_0)$ 的时间步。瞬态长度定义为 $\\tau = t_0$，周期长度定义为 $p = t - t_0$。",
            "solution": "用户希望在大小为 $n$ 的有限一维格子上，分析初等元胞自动机 (ECA) 规则 54 在三种不同边界条件（固定、反射和周期性）下的动力学。对于给定的初始构型，任务是计算每种边界条件下轨迹的瞬态长度 $\\tau$ 和周期长度 $p$。\n\n该问题在计算上是明确定义的，并基于元胞自动机的标准理论。系统的状态空间是有限的，有 $2^n$ 种可能的构型。由于更新规则是确定性的，从任何初始构型 $x(0)$ 开始，系统会生成一个构型序列 $x(0), x(1), x(2), \\ldots$。由于状态空间的有限性，某个构型最终必然会重复出现。设 $t$ 是重复构型首次出现的时间步，即 $x(t) = x(t_0)$ 对于某个 $t_0  t$ 成立，且 $t$ 是最小的。问题将瞬态长度定义为 $\\tau = t_0$，周期长度定义为 $p = t - t_0$。\n\n我们的方法是逐步模拟自动机的演化，并检测重复状态的首次出现。这是一个有限状态机中的经典循环检测问题。对于给定的 $n$（最大为 16）的约束，一个直接且高效的方法是存储每个生成的构型及其出现的时间步。\n\n算法流程如下：\n1.  **规则表示**：局部更新规则，即规则 54，由问题为所有 $2^3 = 8$ 种可能的邻域状态 $(x_{i-1}, x_i, x_{i+1})$ 定义。我们可以将此映射存储在字典或哈希图中，以实现高效查找。键将是表示邻域三元组的元组，例如 $(1, 0, 1)$，值将是中心元胞的结果状态，例如 $1$。\n\n2.  **状态演化**：我们将实现一个函数，根据时间 $t$ 的构型计算时间 $t+1$ 的构型。该函数接受当前状态数组、其长度 $n$ 以及边界条件类型作为输入。\n    - 在此函数内部，初始化一个用于时间 $t+1$ 的新状态数组。\n    - 它遍历从 $0$ 到 $n-1$ 的每个元胞 $i$。\n    - 对于每个元胞 $i$，它确定其左邻居、自身（中心）和右邻居的状态。邻居的状态根据指定的边界条件确定：\n        - **周期性**：格子被视为一个环。元胞 $0$ 的左邻居是元胞 $n-1$，元胞 $n-1$ 的右邻居是元胞 $0$。对任何元胞 $i$，其左邻居位于索引 $(i-1) \\pmod n$ 处，右邻居位于索引 $(i+1) \\pmod n$ 处。\n        - **固定**：格子被扩展了两个“虚拟”元胞 $x_{-1}$ 和 $x_{n}$，它们永久固定为状态 $0$。因此，对于元胞 $0$，左邻居是 $0$；对于元胞 $n-1$，右邻居是 $0$。\n        - **反射**：虚拟元胞镜像其在格子上的相邻元胞的状态。也就是说，$x_{-1} = x_0$ 且 $x_n = x_{n-1}$。因此，对于元胞 $0$，其左邻居与元胞 $0$ 状态相同；对于元胞 $n-1$，其右邻居与元胞 $n-1$ 状态相同。\n    - 邻域三元组用作键，在规则 54 映射中查找元胞 $i$ 的新状态。\n    - 新状态被赋给新状态数组中相应的元胞。\n    - 该函数返回完成的新状态数组。\n\n3.  **循环检测**：我们实现一个函数来寻找 $(\\tau, p)$。\n    - 该函数初始化一个字典 `history` 来存储遇到的每个唯一构型及其首次出现的时间步。初始构型 $x(0)$ 以时间步 $t=0$ 存储。\n    - 然后它进入一个从 $t=1$ 开始的循环。在每次迭代中，它使用上述状态演化函数计算下一个构型 $x(t)$。\n    - 在进入下一步之前，它检查新构型 $x(t)$ 是否已存在于 `history` 字典中。由于 NumPy 数组是不可哈希的，我们将其转换为元组以便用作字典的键。\n    - 如果在 `history` 中找到了 $x(t)$，则检测到了一个循环。从字典中检索其首次出现的时间 $t_0$。瞬态长度为 $\\tau = t_0$，周期长度为 $p = t - t_0$。函数返回这对值 $(\\tau, p)$。\n    - 如果 $x(t)$ 不在 `history` 中，则将其与当前时间步 $t$ 一起添加到字典中，并使用这个新状态继续模拟。\n\n4.  **主程序**：程序的主体部分遍历所提供的测试用例。对于每个由初始构型字符串及其长度 $n$ 指定的测试用例，它调用循环检测函数三次，每种边界条件（‘fixed’、‘reflective’、‘periodic’）一次。对三种条件中的每一种得到的六个整数值——$(\\tau, p)$——被收集并格式化为所需的输出字符串。最终输出是一个列表的列表，其中每个内部列表对应一个测试用例。\n\n这个完整、确定性的过程保证了能为问题陈述中定义的每种情景找到正确的瞬态和周期长度。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Solves the ECA Rule 54 dynamics problem for a suite of test cases.\n    \"\"\"\n\n    # Rule 54 is defined by the mapping from a neighborhood (left, center, right)\n    # to the new state of the center cell.\n    # The rule number 54 comes from the binary string 00110110, which corresponds\n    # to the outputs for neighborhoods (1,1,1) through (0,0,0) in that order.\n    RULE_54_MAP = {\n        (1, 1, 1): 0, (1, 1, 0): 0, (1, 0, 1): 1, (1, 0, 0): 1,\n        (0, 1, 1): 0, (0, 1, 0): 1, (0, 0, 1): 1, (0, 0, 0): 0\n    }\n\n    def get_next_state(state: np.ndarray, boundary: str) - np.ndarray:\n        \"\"\"\n        Computes the next state of the cellular automaton for a given configuration\n        and boundary condition.\n\n        Args:\n            state: A 1D numpy array representing the current configuration.\n            boundary: A string specifying the boundary condition ('fixed', 'reflective', 'periodic').\n\n        Returns:\n            A 1D numpy array for the next configuration.\n        \"\"\"\n        n = len(state)\n        new_state = np.empty(n, dtype=int)\n\n        for i in range(n):\n            center = state[i]\n            \n            if boundary == 'periodic':\n                left = state[(i - 1 + n) % n]\n                right = state[(i + 1) % n]\n            elif boundary == 'fixed':\n                left = state[i - 1] if i  0 else 0\n                right = state[i + 1] if i  n - 1 else 0\n            elif boundary == 'reflective':\n                left = state[i - 1] if i  0 else state[0]\n                right = state[i + 1] if i  n - 1 else state[n - 1]\n            else:\n                raise ValueError(\"Invalid boundary condition specified.\")\n\n            triplet = (left, center, right)\n            new_state[i] = RULE_54_MAP[triplet]\n\n        return new_state\n\n    def find_cycle(initial_state_str: str, boundary: str) - tuple[int, int]:\n        \"\"\"\n        Simulates the ECA and finds the transient length (tau) and cycle length (p).\n\n        Args:\n            initial_state_str: The initial configuration as a binary string.\n            boundary: The boundary condition to apply.\n\n        Returns:\n            A tuple (tau, p).\n        \"\"\"\n        initial_state = np.array([int(c) for c in initial_state_str], dtype=int)\n        \n        # history stores {config_tuple: time_step}\n        history = {tuple(initial_state): 0}\n        current_state = initial_state\n        time = 0\n\n        while True:\n            time += 1\n            next_state = get_next_state(current_state, boundary)\n            next_state_tuple = tuple(next_state)\n\n            if next_state_tuple in history:\n                t0 = history[next_state_tuple]\n                tau = t0\n                p = time - t0\n                return tau, p\n            \n            history[next_state_tuple] = time\n            current_state = next_state\n\n    test_cases = [\n        (12, \"000001111100\"),\n        (12, \"100000000001\"),\n        (1, \"1\"),\n        (2, \"10\"),\n        (16, \"0011011000110110\"),\n    ]\n\n    all_results = []\n    for n, initial_config in test_cases:\n        case_results = []\n        \n        # Fixed boundary\n        tau_f, p_f = find_cycle(initial_config, 'fixed')\n        case_results.extend([tau_f, p_f])\n\n        # Reflective boundary\n        tau_r, p_r = find_cycle(initial_config, 'reflective')\n        case_results.extend([tau_r, p_r])\n\n        # Periodic boundary\n        tau_p, p_p = find_cycle(initial_config, 'periodic')\n        case_results.extend([tau_p, p_p])\n        \n        all_results.append(case_results)\n\n    # Format the final output string as specified\n    case_strings = [f\"[{','.join(map(str, res))}]\" for res in all_results]\n    final_output = f\"[{','.join(case_strings)}]\"\n    \n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "为了分析元胞自动机更深层次的性质，我们可以从模拟转向更强大的数学形式化方法。本练习介绍了德布鲁因图（de Bruijn graph），这是一个将元胞自动机动力学转化为图论问题的工具。通过研究这个图，你将能够精确地计算任何给定状态的前驱状态（preimages）的数量，并判断一个规则是否可逆，这是许多物理和计算模型中的一个关键属性。",
            "id": "3104885",
            "problem": "给定一个定义在长度为$L$的周期性环（循环边界）上的一维、二元、半径为$1$的细胞自动机，它由一个作用于邻域 $(a,b,c)$ 的局部规则 $f:\\{0,1\\}^3 \\to \\{0,1\\}$ 指定，形式为 $y_i = f(x_{i-1}, x_i, x_{i+1})$，其中索引对$L$取模。该局部规则由其 Wolfram 规则数 $R \\in \\{0,1,\\dots,255\\}$ 编码，其中邻域 $(a,b,c)$ 的输出由 $R$ 在位置 $p = 4a + 2b + c$ 上的比特位给出，即 $f(a,b,c) = \\left\\lfloor \\frac{R}{2^p} \\right\\rfloor \\bmod 2$。\n\n你的任务是，从第一性原理出发，推导给定局部规则的 de Bruijn 图，并用它来计算目标构型的单步原像计数，以及检测在给定长度的有限环上的可逆性。对于半径为$1$的二元细胞自动机，其 de Bruijn 图的节点集对应所有长度为$2$的二进制词，即 $V = \\{00,01,10,11\\}$，有向边对应所有长度为$3$的二进制词，即对于每个三元组 $(a,b,c) \\in \\{0,1\\}^3$，都有一条从节点 $ab$ 到节点 $bc$ 的边。每条边由局部规则的输出 $f(a,b,c) \\in \\{0,1\\}$ 标记。定义大小为 $4 \\times 4$ 的整数邻接矩阵 $A_0$ 和 $A_1$，其中当且仅当存在一条从 $u$ 到 $v$ 且标记为 $\\ell \\in \\{0,1\\}$ 的边时，$(A_\\ell)_{u,v} = 1$，否则 $(A_\\ell)_{u,v} = 0$。\n\n使用的基本原理：\n- 细胞自动机定义：$y_i = f(x_{i-1}, x_i, x_{i+1})$，其中 $f$ 是局部规则，索引对$L$取模。\n- 半径为$1$的 de Bruijn 图构造：节点是长度为$2$的词，边是长度为$3$的词，具有重叠部分，边标签由 $f$ 决定。\n- 通过邻接矩阵进行游走计数：具有固定标签序列的长度为$L$的闭合游走数量等于邻接矩阵乘积的迹。\n\n目标推导与算法：\n- 通过枚举所有 $(a,b,c) \\in \\{0,1\\}^3$ 从给定的 $R$ 构建 $A_0$ 和 $A_1$。\n- 对于给定的目标词 $y \\in \\{0,1\\}^L$，计算在周期性边界下全局规则一步演化的原像计数为\n$$\\text{preimages}(y) = \\operatorname{trace}\\!\\left(A_{y_0} A_{y_1} \\cdots A_{y_{L-1}}\\right),$$\n其中 $y_i$ 是 $y$ 的第 $i$ 个比特位，$A_{y_i}$ 在 $y_i=0$ 时为 $A_0$，在 $y_i=1$ 时为 $A_1$。\n- 对于在长度为$L$的有限环上的可逆性，全局映射是双射当且仅当对于每个目标 $y \\in \\{0,1\\}^L$，其原像计数恰好为 $1$。使用上述公式测试所有 $2^L$ 个目标词。\n\n单位与格式：\n- 没有物理量；所有输出均为纯数学和逻辑值。所有数值量化的输出必须是整数或布尔值。\n- 不使用角度。\n- 不使用百分比。\n\n测试套件及所需输出：\n实现一个程序，为给定的规则构建 $A_0$ 和 $A_1$，并按顺序产生以下结果。对于每个原像计数案例，输出整数计数值。对于每个可逆性案例，输出一个布尔值，指示在指定长度的环上的全局映射是否为双射（True 表示可逆，False 表示不可逆）。\n\n测试用例：\n1. 对于 $R=240$ 和长度为 $L = 5$ 的 $y = \\text{\"10101\"}$ 的原像计数。\n2. 对于 $R=204$ 和长度为 $L = 4$ 的 $y = \\text{\"0110\"}$ 的原像计数。\n3. 对于 $R=90$ 和长度为 $L = 2$ 的 $y = \\text{\"00\"}$ 的原像计数。\n4. 对于 $R=30$ 和长度为 $L = 4$ 的 $y = \\text{\"0000\"}$ 的原像计数。\n5. 对于 $R=240$ 在环长度 $L = 6$ 上的可逆性。\n6. 对于 $R=170$ 在环长度 $L = 5$ 上的可逆性。\n7. 对于 $R=90$ 在环长度 $L = 5$ 上的可逆性。\n8. 对于 $R=150$ 在环长度 $L = 5$ 上的可逆性。\n9. 对于 $R=204$ 在环长度 $L = 1$ 上的可逆性。\n10. 对于 $R=90$ 在环长度 $L = 1$ 上的可逆性。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含一个逗号分隔的结果列表，并用方括号括起来（例如，\"[result1,result2,...,result10]\"），结果顺序与上述测试用例完全一致。",
            "solution": "所提出的问题是有效的。它在细胞自动机和符号动力学的既定理论中有科学依据，定义明确，包含所有必要的定义和约束，并以客观、正式的语言表述。它提出了一个可以使用所提供原理通过算法解决的标准、非平凡问题。\n\n一维细胞自动机 (CA) 根据局部邻域中的状态更新格点上每个细胞的状态。对于长度为$L$的周期性环上的半径为$1$的 CA，下一时间步细胞 $i$ 的状态 $y_i$ 是当前时间步细胞 $i-1$、$i$ 和 $i+1$ 状态的函数 $f$，当前构型表示为 $x = (x_0, x_1, \\dots, x_{L-1})$。整个构型从 $x$ 到 $y$ 的全局演化是通过在所有位置同时应用局部规则 $f$ 来确定的：$y_i = f(x_{i-1}, x_i, x_{i+1})$，其中索引对$L$取模。\n\n此类系统的动力学可以使用 de Bruijn 图进行分析。对于半径为$1$的二元 CA，de Bruijn 图的构造如下。图的节点 $V$ 代表所有可能的状态块，其长度为 $2r=2$，其中 $r=1$ 是半径。因此，节点集为 $V = \\{00, 01, 10, 11\\}$。对于每个可能的状态三元组 $(a,b,c) \\in \\{0,1\\}^3$，都存在一条从节点 $u=ab$ 到节点 $v=bc$ 的有向边。该边对应于长度为 $2r+1=3$ 的状态块 $abc$。每条边都由其对应块的局部规则输出 $\\ell = f(a,b,c)$ 进行标记。\n\n长度为$L$的环上的一个构型 $x = (x_0, x_1, \\dots, x_{L-1})$ 可以表示为一系列长度为$2$的重叠块：$(x_0x_1), (x_1x_2), \\dots, (x_{L-2}x_{L-1}), (x_{L-1}x_0)$。这对应于 de Bruijn 图中一条长度为$L$的闭合游走：$x_0x_1 \\to x_1x_2 \\to \\dots \\to x_{L-1}x_0$。如果局部规则输出的序列与目标构型 $y = (y_0, y_1, \\dots, y_{L-1})$ 匹配，则构型 $x$ 是 $y$ 的一个原像。在图表示中，这意味着对应于 $x$ 的闭合游走上的边标签序列必须恰好是 $(y_0, y_1, \\dots, y_{L-1})$。\n\n为了计算此类游走的数量，我们引入带标签的邻接矩阵。设节点 $\\{00, 01, 10, 11\\}$ 由 $u, v \\in \\{0, 1, 2, 3\\}$ 索引。我们定义两个 $4 \\times 4$ 的矩阵 $A_0$ 和 $A_1$。如果存在一条从节点 $u$ 到节点 $v$ 且标签为 $\\ell \\in \\{0,1\\}$ 的边，则条目 $(A_\\ell)_{u,v}$ 为 $1$，否则为 $0$。Wolfram 规则数 $R$ 编码了函数 $f$。对于 $2^3=8$ 个可能的邻域 $(a,b,c)$ 中的每一个，我们可以确定其整数表示 $p=4a+2b+c$。规则输出由 $R$ 的第 $p$ 位给出，$f(a,b,c) = (R \\gg p) \\ 1$。此输出 $\\ell$ 决定了哪个矩阵 $A_0$ 或 $A_1$ 会获得一个条目。源节点是 $u=2a+b$，目标节点是 $v=2b+c$。因此，我们设置 $(A_\\ell)_{2a+b, 2b+c} = 1$。\n\n具有特定标签序列 $y=(y_0, \\dots, y_{L-1})$ 的长度为$L$的路径数量可以通过乘以相应的邻接矩阵来找到。矩阵乘积 $M_y = A_{y_0} A_{y_1} \\cdots A_{y_{L-1}}$ 包含的条目 $(M_y)_{u,v}$ 计录了从节点 $u$ 开始、在节点 $v$ 结束且具有标签序列 $y$ 的长度为$L$的游走数量。为了找到 $y$ 的原像数量，我们需要计算具有此标签序列的*闭合*游走的总数。这是 $M_y$ 的对角元素之和，即其迹：\n$$ \\text{preimages}(y) = \\sum_{u=0}^{3} (M_y)_{u,u} = \\operatorname{trace}(M_y) $$\n\n一个 CA 的全局映射在长度为$L$的环上被认为是可逆的，如果它在所有 $2^L$ 个构型的集合上是一个双射。对于有限集上的函数，双射等价于单射和满射。这意味着对于每个目标构型 $y$，必须存在且仅存在一个原像构型 $x$。因此，一个规则在长度为$L$的环上是可逆的，当且仅当对于所有 $2^L$ 个可能的目标构型 $y$，$\\text{preimages}(y) = 1$。检查可逆性的算法包括遍历每个可能的目标字符串 $y \\in \\{0,1\\}^L$，使用迹公式计算其原像计数，并验证在每种情况下计数都恰好为 $1$。如果任何计数不为 $1$，则该规则是不可逆的。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the cellular automata problem by constructing de Bruijn graph\n    adjacency matrices and using them to count preimages and check reversibility.\n    \"\"\"\n\n    # --- Helper Functions ---\n\n    memoized_matrices = {}\n\n    def get_adjacency_matrices(R):\n        \"\"\"\n        Constructs the labeled adjacency matrices A0 and A1 for a given\n        Wolfram rule number R.\n        \"\"\"\n        if R in memoized_matrices:\n            return memoized_matrices[R]\n\n        # Nodes are '00', '01', '10', '11'. We map them to indices 0, 1, 2, 3.\n        # node_map = {'00': 0, '01': 1, '10': 2, '11': 3}\n        # which corresponds to int(s, 2)\n        A0 = np.zeros((4, 4), dtype=np.int64)\n        A1 = np.zeros((4, 4), dtype=np.int64)\n\n        # Iterate through all 8 possible neighborhoods (a, b, c)\n        for p in range(8):\n            # Decode neighborhood from p\n            a = (p  2)  1\n            b = (p  1)  1\n            c = p  1\n\n            # Determine source and destination nodes from the neighborhood\n            # u = 'ab', v = 'bc'\n            u_idx = 2 * a + b\n            v_idx = 2 * b + c\n\n            # Determine the rule output (the edge label)\n            label = (R  p)  1\n\n            if label == 0:\n                A0[u_idx, v_idx] = 1\n            else:\n                A1[u_idx, v_idx] = 1\n        \n        memoized_matrices[R] = (A0, A1)\n        return A0, A1\n\n    def count_preimages(y_str, A0, A1):\n        \"\"\"\n        Computes the preimage count for a target string y.\n        \"\"\"\n        y = [int(bit) for bit in y_str]\n        L = len(y)\n\n        if L == 0:\n            return 0\n        \n        # Start with the matrix for the first bit of y\n        if y[0] == 0:\n            M = A0.copy()\n        else:\n            M = A1.copy()\n\n        # Multiply by subsequent matrices\n        for i in range(1, L):\n            if y[i] == 0:\n                M = M @ A0\n            else:\n                M = M @ A1\n        \n        return int(np.trace(M))\n\n    def check_reversibility(R, L, A0, A1):\n        \"\"\"\n        Checks if the rule R is reversible on a ring of length L.\n        \"\"\"\n        num_configs = 1  L\n        for i in range(num_configs):\n            # Generate the binary string for the target configuration y\n            y_str = format(i, f'0{L}b')\n            \n            # Calculate preimage count for this y\n            preimage_count = count_preimages(y_str, A0, A1)\n            \n            # If the count is not 1, the map is not a bijection\n            if preimage_count != 1:\n                return False\n        \n        # If all 2^L configurations have exactly one preimage, it's reversible\n        return True\n\n    # --- Test Case Execution ---\n\n    test_cases = [\n        ('preimage', {'R': 240, 'y': \"10101\"}),\n        ('preimage', {'R': 204, 'y': \"0110\"}),\n        ('preimage', {'R': 90, 'y': \"00\"}),\n        ('preimage', {'R': 30, 'y': \"0000\"}),\n        ('reversibility', {'R': 240, 'L': 6}),\n        ('reversibility', {'R': 170, 'L': 5}),\n        ('reversibility', {'R': 90, 'L': 5}),\n        ('reversibility', {'R': 150, 'L': 5}),\n        ('reversibility', {'R': 204, 'L': 1}),\n        ('reversibility', {'R': 90, 'L': 1}),\n    ]\n\n    results = []\n    for test_type, params in test_cases:\n        R = params['R']\n        A0, A1 = get_adjacency_matrices(R)\n        \n        if test_type == 'preimage':\n            y = params['y']\n            result = count_preimages(y, A0, A1)\n        elif test_type == 'reversibility':\n            L = params['L']\n            result = check_reversibility(R, L, A0, A1)\n        \n        results.append(result)\n\n    # --- Final Output ---\n    # Convert booleans to \"True\" or \"False\" strings as per standard conversion\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}