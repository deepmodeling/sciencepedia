{
    "hands_on_practices": [
        {
            "introduction": "时间聚合最直接的误导方式就是改变我们对网络局部结构的认知。本练习将聚焦于三角形，这是许多现实世界网络中的一个基本结构基元。通过计算和比较聚合图中的静态三角形数量与原始时序数据中的“时序尊重”三角形数量，你将亲身体会到聚合如何扭曲了局部信息交换的真实潜力。",
            "id": "4312058",
            "problem": "考虑一个在节点集 $V=\\{1,2,3,4\\}$ 上，于时间区间 $[0,10]$ 内观测到的瞬时无向接触的时间网络。一个接触表示为三元组 $(i,j,t)$，表示节点 $i$ 和 $j$ 在时间 $t$ 发生了接触。给定的接触序列为\n$(1,2,1)$、$(2,3,2)$、$(1,3,3)$、$(1,4,4)$、$(2,3,5)$、$(1,2,6)$、$(1,3,7)$、$(2,4,8)$。\n将时间聚合图定义为在 $V$ 上的简单无向图，如果在观测窗口内至少发生过一次接触 $(i,j,t)$，则在节点 $i$ 和 $j$ 之间放置一条边。将尊重时间的序列定义为一个有序的接触列表 $(i_{1},j_{1},t_{1}),\\dots,(i_{m},j_{m},t_{m})$，其时间严格递增 $t_1  t_2  \\dots  t_m$。",
            "solution": "该问题要求计算与时间网络中三角形结构相关的两个不同量，然后计算它们的比率。第一个量是时间聚合图中的静态三角形数量，第二个量是在特定持续时间约束下的尊重时间的三角形模体数量。\n\n节点集为 $V = \\{1,2,3,4\\}$。时间网络由在时间区间 $[0,10]$ 内的一系列瞬时接触定义：\n$$C = \\{(1,2,1), (2,3,2), (1,3,3), (1,4,4), (2,3,5), (1,2,6), (1,3,7), (2,4,8)\\}$$\n其中一个接触是一个元组 $(i,j,t)$。为清晰起见，我们可以按时间顺序列出这些接触：\n$c_1 = (1,2,1)$\n$c_2 = (2,3,2)$\n$c_3 = (1,3,3)$\n$c_4 = (1,4,4)$\n$c_5 = (2,3,5)$\n$c_6 = (1,2,6)$\n$c_7 = (1,3,7)$\n$c_8 = (2,4,8)$\n\n**第一部分：静态三角形计数**\n\n首先，我们构建时间聚合图 $G_{\\text{agg}} = (V, E_{\\text{agg}})$。如果在给定的序列中存在至少一个接触 $(i,j,t)$，则边 $(i,j)$ 存在于 $E_{\\text{agg}}$ 中。通过检查接触列表，我们识别出唯一的交互对：\n\\begin{itemize}\n    \\item 对 $\\{1,2\\}$：在 $t=1$ 和 $t=6$ 有接触。边 $(1,2) \\in E_{\\text{agg}}$。\n    \\item 对 $\\{2,3\\}$：在 $t=2$ 和 $t=5$ 有接触。边 $(2,3) \\in E_{\\text{agg}}$。\n    \\item 对 $\\{1,3\\}$：在 $t=3$ 和 $t=7$ 有接触。边 $(1,3) \\in E_{\\text{agg}}$。\n    \\item 对 $\\{1,4\\}$：在 $t=4$ 有接触。边 $(1,4) \\in E_{\\text{agg}}$。\n    \\item 对 $\\{2,4\\}$：在 $t=8$ 有接触。边 $(2,4) \\in E_{\\text{agg}}$。\n    \\item 对 $\\{3,4\\}$：无接触。边 $(3,4) \\notin E_{\\text{agg}}$。\n\\end{itemize}\n因此，聚合图的边集为 $E_{\\text{agg}} = \\{(1,2), (2,3), (1,3), (1,4), (2,4)\\}$。\n\n一个静态三角形是三个节点 $\\{a,b,c\\} \\subseteq V$ 的集合，其中所有三条边 $(a,b)$、$(b,c)$ 和 $(c,a)$ 都存在于 $E_{\\text{agg}}$ 中。我们检查 $V$ 中所有可能的3节点子集：\n\\begin{enumerate}\n    \\item 三元组 $\\{1,2,3\\}$：所需的边是 $(1,2)$、$(2,3)$ 和 $(1,3)$。这三条边都在 $E_{\\text{agg}}$ 中。因此，$\\{1,2,3\\}$ 形成一个静态三角形。\n    \\item 三元组 $\\{1,2,4\\}$：所需的边是 $(1,2)$、$(2,4)$ 和 $(1,4)$。这三条边都在 $E_{\\text{agg}}$ 中。因此，$\\{1,2,4\\}$ 形成一个静态三角形。\n    \\item 三元组 $\\{1,3,4\\}$：所需的边是 $(1,3)$、$(3,4)$ 和 $(1,4)$。边 $(3,4)$ 不在 $E_{\\text{agg}}$ 中。这不是一个三角形。\n    \\item 三元组 $\\{2,3,4\\}$：所需的边是 $(2,3)$、$(3,4)$ 和 $(2,4)$。边 $(3,4)$ 不在 $E_{\\text{agg}}$ 中。这不是一个三角形。\n\\end{enumerate}\n静态三角形的总数为 $2$。\n\n**第二部分：时间三角形模体计数**\n\n一个尊重时间的三角形模体被定义为一个由三次接触组成的尊重时间的序列 $(i_1,j_1,t_1), (i_2,j_2,t_2), (i_3,j_3,t_3)$，满足以下条件：\n\\begin{enumerate}\n    \\item 时间严格递增：$t_1  t_2  t_3$。\n    \\item 接触涉及单个3节点集 $\\{a,b,c\\}$ 的三个不同节点对。也就是说，边集 $\\{\\{i_1,j_1\\}, \\{i_2,j_2\\}, \\{i_3,j_3\\}\\}$ 恰好是 $\\{\\{a,b\\}, \\{b,c\\}, \\{c,a\\}\\}$。\n    \\item 持续时间有界：$t_3 - t_1 \\leq \\tau$，其中 $\\tau=3$。\n\\end{enumerate}\n时间三角形只能存在于形成静态三角形的节点集上。因此，我们只需要研究节点三元组 $\\{1,2,3\\}$ 和 $\\{1,2,4\\}$。\n\n**情况A：三元组 $\\{1,2,4\\}$**\n涉及这些节点的接触是 $c_1=(1,2,1)$、 $c_4=(1,4,4)$、 $c_6=(1,2,6)$ 和 $c_8=(2,4,8)$。要在 $\\{1,2,4\\}$ 上形成一个三角形，一个序列必须包含在 $\\{1,2\\}$、$\\{1,4\\}$ 和 $\\{2,4\\}$ 这三个节点对上的各一次接触。\n对于边 $(2,4)$，唯一的接触是 $t=8$ 时的 $c_8$。因此，对于任何这样的模体，$t_3$ 必须是 $8$。约束条件 $t_3 - t_1 \\leq 3$ 意味着 $8 - t_1 \\leq 3$，这要求 $t_1 \\geq 5$。\n然而，另外两条边 $(1,2)$ 和 $(1,4)$ 的可用接触都发生在 $t=5$ 之前。具体来说，我们有 $(1,2,1)$ 和 $(1,4,4)$。因此，不可能形成一个尊重时间的序列 $(c_a, c_b, c_c)$，其中 $c_c = c_8=(2,4,8)$ 且 $t(c_a) \\geq 5$。\n或者，考虑可能的序列：\n- 使用 $(1,2,1)$、$(1,4,4)$、$(2,4,8)$ 的序列：按时间排序的序列是 $((1,2,1), (1,4,4), (2,4,8))$。这里，$t_1=1, t_2=4, t_3=8$。持续时间为 $t_3-t_1=7$，大于 $\\tau=3$。\n- 使用 $(1,2,6)$、$(1,4,4)$、$(2,4,8)$ 的序列：按时间排序的序列是 $((1,4,4), (1,2,6), (2,4,8))$。这里，$t_1=4, t_2=6, t_3=8$。持续时间为 $t_3-t_1=4$，大于 $\\tau=3$。\n因此，在节点集 $\\{1,2,4\\}$ 上没有尊重时间的三角形模体。\n\n**情况B：三元组 $\\{1,2,3\\}$**\n涉及这些节点的接触是 $c_1=(1,2,1)$、 $c_2=(2,3,2)$、 $c_3=(1,3,3)$、 $c_5=(2,3,5)$、 $c_6=(1,2,6)$ 和 $c_7=(1,3,7)$。\n我们系统地从此子集中搜索满足条件的有序接触三元组。\n\\begin{enumerate}\n    \\item 序列 $((1,2,1), (2,3,2), (1,3,3))$:\n    \\begin{itemize}\n        \\item 时间：$t_1=1, t_2=2, t_3=3$。这些是严格递增的。\n        \\item 边：接触对应于对 $\\{1,2\\}$、$\\{2,3\\}$ 和 $\\{1,3\\}$，在 $\\{1,2,3\\}$ 上形成一个三角形。\n        \\item 持续时间：$t_3-t_1 = 3-1=2$。由于 $2 \\leq \\tau=3$，这是一个有效的时间模体。\n    \\end{itemize}\n    \\item 序列 $((1,3,3), (2,3,5), (1,2,6))$:\n    \\begin{itemize}\n        \\item 时间：$t_1=3, t_2=5, t_3=6$。这些是严格递增的。\n        \\item 边：接触对应于对 $\\{1,3\\}$、$\\{2,3\\}$ 和 $\\{1,2\\}$，在 $\\{1,2,3\\}$ 上形成一个三角形。\n        \\item 持续时间：$t_3-t_1 = 6-3=3$。由于 $3 \\leq \\tau=3$，这是一个有效的时间模体。\n    \\end{itemize}\n    \\item 序列 $((2,3,5), (1,2,6), (1,3,7))$:\n    \\begin{itemize}\n        \\item 时间：$t_1=5, t_2=6, t_3=7$。这些是严格递增的。\n        \\item 边：接触对应于对 $\\{2,3\\}$、$\\{1,2\\}$ 和 $\\{1,3\\}$，在 $\\{1,2,3\\}$ 上形成一个三角形。\n        \\item 持续时间：$t_3-t_1 = 7-5=2$。由于 $2 \\leq \\tau=3$，这是一个有效的时间模体。\n    \\end{itemize}\n\\end{enumerate}\n对 $\\{1,2,3\\}$ 上所有其他可能的三接触组合进行彻底检查，没有发现其他满足所有标准的序列。例如，序列 $((1,2,1), (1,3,3), (2,3,5))$ 的持续时间为 $5-1=4  3$。序列 $((2,3,2), (1,2,6), (1,3,7))$ 的持续时间为 $7-2=5  3$。\n尊重时间的三角形模体的总数为 $3$。\n\n**第三部分：比率 $R$**\n\n比率 $R$ 定义为时间三角形模体计数除以静态三角形计数。\n$$R = \\frac{\\text{时间三角形模体计数}}{\\text{静态三角形计数}}$$\n代入计算出的值：\n$$R = \\frac{3}{2}$$\n该比率是一个精确分数，并且已经是最简形式。",
            "answer": "$$\\boxed{\\frac{3}{2}}$$"
        },
        {
            "introduction": "除了局部结构，时间聚合同样会严重扭曲我们对单个节点重要性的判断。本练习对比了静态度（一个衡量节点连接性的简单指标）与时间介数（一个捕捉节点对动态路径控制能力的指标）。这个思想实验将挑战你发现一种“时间门控”机制，即一个静态连接很少的节点，因其独特的时序位置而变得至关重要，这有力地证明了在时序网络中，节点*何时*活跃可能比它拥有*多少*连接更为关键。",
            "id": "4311999",
            "problem": "考虑一个时序网络，它表示为节点之间一系列带时间戳的无向接触，其中每个接触是一个元组 $(u,v,t)$，表示节点 $u$ 和 $v$ 在时间 $t$ 发生了一次交互。时间聚合网络是一个静态图，其邻接矩阵为 $\\bar A$，其中当且仅当在任意时间存在至少一个接触 $(u,v,t)$ 时，图中才包含一条无向边 $(u,v)$。节点 $i$ 的聚合度 $\\deg_{\\bar A}(i)$ 是它在这个时间聚合图中的度。一条时序路径（time-respecting path）是一个接触序列 $(u_0,u_1,t_1),(u_1,u_2,t_2),\\dots,(u_{k-1},u_k,t_k)$，其时间戳严格递增 $t_1  t_2  \\dots  t_k$。",
            "solution": "我们从基本原理出发，系统地分析选项 A。\n\n**1. 聚合度分析：**\n首先，我们构建时间聚合网络。聚合边包括在任何时间点发生过的所有接触，即 $(a,b), (b,c), (a,c), (b,v), (v,d), (d,e), (c,d)$。\n然后计算每个节点的聚合度：\n- $\\deg_{\\bar A}(v)=2$（邻居为 $b$ 和 $d$）\n- $\\deg_{\\bar A}(b)=3$（邻居为 $a, c, v$）\n- $\\deg_{\\bar A}(c)=3$（邻居为 $a, b, d$）\n- $\\deg_{\\bar A}(d)=3$（邻居为 $v, e, c$）\n- $\\deg_{\\bar A}(a)=2$（邻居为 $b, c$）\n- $\\deg_{\\bar A}(e)=1$（邻居为 $d$）\n节点 $v$ 的聚合度（2）确实低于节点 $b, c, d$ 的聚合度（均为3）。第一个条件满足。\n\n**2. 时序介数分析：**\n接下来，我们评估节点 $v$ 在最早到达时序路径中的作用，特别是连接两个社团（$S_1=\\{a,b,c\\}$ 和 $S_2=\\{d,e\\}$）的路径。\n- **从 $c$ 到 $d$ 的路径：**\n    - 路径1（通过 $v$）：$c \\to b$ (在 $t=2$ 发生) $\\to v$ (在 $t=3$ 发生) $\\to d$ (在 $t=4$ 发生)。这是一个有效的时序路径，总到达时间为 $4$。\n    - 路径2（直接连接）：$c \\to d$ (在 $t=11$ 发生)。这是一个有效的时序路径，总到达时间为 $11$。\n    比较两条路径，通过节点 $v$ 的路径（到达时间4）远快于直接路径（到达时间11）。因此，节点 $v$ 位于从 $c$ 到 $d$ 的最早到达路径上。\n- **从 $a$ 到 $d$ 的路径：**\n    - 路径1（通过 $v$）：$a \\to b$ (在 $t=1$) $\\to v$ (在 $t=3$) $\\to d$ (在 $t=4$)。这是一个有效的时序路径，总到达时间为 $4$。\n    - 路径2（通过 $c$）：$a \\to c$ 的接触在 $t=15$，$c \\to d$ 的接触在 $t=11$。这无法形成一条时间严格递增的路径 ($15 \\not 11$)。\n    因此，唯一快速的时序路径是通过 $v$ 的路径。节点 $v$ 位于从 $a$ 到 $d$ 的最早到达路径上。\n- **从 $b$ 到 $d$ 的路径：**\n    - 路径1（通过 $v$）：$b \\to v$ (在 $t=3$) $\\to d$ (在 $t=4$)。到达时间为 $4$。\n    - 路径2（通过 $c$）：$b \\to c$ (在 $t=2$) $\\to d$ (在 $t=11$)。到达时间为 $11$。\n    同样，通过 $v$ 的路径是最快的。\n\n**结论：**\n节点 $v$ 是连接两个社团的关键“时间门控”（temporal gatekeeper）。尽管其静态连接数不多，但其连接的时机（$t=3$ 和 $t=4$）恰好承接了社团 $S_1$ 的早期活动，并将其传递给 $S_2$。其他跨社团的连接（如 $c \\to d$ 在 $t=11$）发生得太晚，无法形成最快路径。因此，节点 $v$ 的时序介数很高。\n选项 A 成功构建了一个节点聚合度低但时序介数高的场景。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "最后的这项实践综合了我们之前的发现，旨在探究其最终影响：这些结构和中心性的差异如何影响在网络上传播的动态过程？你将使用经典的易感-感染-恢复 (SIR) 流行病模型，在静态聚合图和真实的时序网络上分别模拟同一场疫情的爆发。这个编程练习让你能够直接、定量地比较最终感染规模和感染峰值时间等结果，为“为何时间分辨分析对于理解和预测现实世界动态现象至关重要”这一观点提供了令人信服的证据。",
            "id": "4312020",
            "problem": "考虑一个基数为 $|V|=5$ 的有限节点集 $V$，标记为 $0$、$1$、$2$、$3$、$4$。一个时间接触网络由一组无向接触事件指定，表示为有序三元组 $(i,j,t)$，其中 $i,j \\in V$，离散时间 $t \\in \\{0,1,2,3,4,5,6,7,8,9\\}$。事件列表为\n$$\nE=\\{(0,1,0),(1,2,1),(2,3,2),(3,4,3),(0,2,4),(1,3,5),(2,4,6),(0,3,7),(1,4,8),(0,4,9)\\}.\n$$\n这些事件定义了一个高阶时间分辨表示，其中感染只能在精确的时间点沿遵循时间顺序的接触传播。静态时间聚合网络定义为：当且仅当对于某个时间 $t$ 在 $E$ 中存在至少一个接触事件 $(i,j,t)$ 时，节点 $i$ 和 $j$ 之间存在一条无向边，并且这个静态网络忽略时间顺序。\n\n在两种表示上，从单个种子节点开始，模拟一个离散时间的易感-感染-恢复 (SIR) 过程。在离散时间 $t$，每个节点 $x \\in V$ 的状态是 $S$ (易感)、$I$ (感染) 或 $R$ (恢复)之一。基本基础是以下定义和规则集：\n- 在时间 $t=0$ 开始时，恰好有一个种子节点是感染状态，所有其他节点都是易感状态。\n- 传播规则：在时间 $t$ 与感染节点接触的易感节点以独立概率 $\\beta \\in [0,1]$ 变为新感染状态。在静态聚合网络中，时间 $t$ 的接触集由所有静态边定义，视为在每个离散时间步都可用。在时间分辨网络中，只有根据 $E$ 在时间 $t$ 实际发生的接触是可用的。\n- 恢复规则：每个感染节点在时间 $t$ 结束时以独立概率 $\\mu \\in [0,1]$ 恢复，并在此后保持恢复状态。\n- 更新约定：在时间 $t$ 首先评估传播，新感染的节点在时间 $t+1$ 变为感染状态。在时间 $t$ 是感染状态的节点的恢复在传播之后评估，并在时间 $t+1$ 生效。设 $I_t$ 表示在应用第 $t$ 步的任何传播和恢复之前，第 $t$ 步开始时的感染节点数。\n\n在 $T$ 个离散时间步的模拟时域内定义以下指标：\n- 最终爆发规模 $F$，等于到时间 $T$ 为止曾被感染的节点总数，即模拟结束时非易感状态的节点数 ($I_T + R_T$)。\n- 感染峰值时间 $t^{\\star}$，等于使 $I_t$ 最大化的最小离散时间索引 $t \\in \\{0,1,\\dots,T-1\\}$。\n\n您的任务是编写一个完整的程序，使用固定的种子进行独立伪随机抽样以保证可复现性，在上述定义的静态聚合网络和时间分辨高阶表示上模拟 SIR 过程。对所有测试用例，使用伪随机数生成器 (PRNG) 种子 $42$。对于种子节点，使用节点 $0$。\n\n程序必须处理以下参数值测试套件，表示为元组 $(\\beta,\\mu,T)$：\n- 测试用例 1：$(0.3,0.1,10)$，一个通用的“顺利路径”用例。\n- 测试用例 2：$(0.5,0.9,10)$，一个快速恢复的边界条件。\n- 测试用例 3：$(0.0,1.0,10)$，一个无传播且立即恢复的边缘用例。\n- 测试用例 4：$(0.8,0.2,10)$，一个侵略性传播和中等恢复的用例。\n\n对于每个测试用例，计算并返回一个包含四个整数的列表 $[F_{\\mathrm{static}}, t^{\\star}_{\\mathrm{static}}, F_{\\mathrm{temporal}}, t^{\\star}_{\\mathrm{temporal}}]$，其中 $F_{\\mathrm{static}}$ 和 $t^{\\star}_{\\mathrm{static}}$ 是在静态聚合网络上计算的，而 $F_{\\mathrm{temporal}}$ 和 $t^{\\star}_{\\mathrm{temporal}}$ 是在时间分辨高阶表示上计算的。\n\n最终输出格式要求：您的程序应生成单行输出，其中包含结果，格式为用方括号括起来的逗号分隔列表，每个测试用例一个方括号列表，按所列顺序排列。例如，输出必须采用以下形式\n$$\n[[F_{\\mathrm{static}}^{(1)}, t^{\\star}_{\\mathrm{static}}^{(1)}, F_{\\mathrm{temporal}}^{(1)}, t^{\\star}_{\\mathrm{temporal}}^{(1)}],\\dots,[F_{\\mathrm{static}}^{(4)}, t^{\\star}_{\\mathrm{static}}^{(4)}, F_{\\mathrm{temporal}}^{(4)}, t^{\\star}_{\\mathrm{temporal}}^{(4)}]].\n$$\n不涉及物理单位；所有时间都是离散索引，所有概率必须作为 $[0,1]$ 中的小数处理。",
            "solution": "用户提供的问题陈述已经过分析和验证。该问题被认为具有科学依据、适定且完整。该问题要求在两种不同的网络表示上模拟易感-感染-恢复 (SIR) 流行病过程，这两种表示派生自一组给定的带时间戳的接触事件：一个静态、时间聚合的网络和一个时间分辨的时序网络。目标是针对一系列测试用例，为这两种表示计算最终爆发规模 ($F$) 和感染峰值时间 ($t^{\\star}$)。\n\n解决方案将通过创建一个能够处理两种网络类型的鲁棒模拟函数来实现。此函数的核心将遍历离散的时间步，按规定应用传播和恢复的随机规则。为保证可复现性，将为每个独立的模拟运行使用固定的种子初始化一个伪随机数生成器 (PRNG)。\n\n### **1. 网络表示**\n\n首先，我们必须根据提供的事件列表 $E$ 来形式化两种网络结构：\n$E=\\{(0,1,0),(1,2,1),(2,3,2),(3,4,3),(0,2,4),(1,3,5),(2,4,6),(0,3,7),(1,4,8),(0,4,9)\\}$.\n节点集为 $V = \\{0, 1, 2, 3, 4\\}$。\n\n- **时间聚合静态网络 ($G_{\\mathrm{static}}$):** 如果对于任何时间 $t$，至少存在一个三元组 $(i, j, t) \\in E$，则在 $G_{\\mathrm{static}}$ 中存在一条无向边 $(i, j)$。快速检查 $E$ 表明，每对不同的节点都至少通过一个事件连接。例如，$(0,1) \\in E$、$(0,2) \\in E$、$(0,3) \\in E$、$(0,4) \\in E$、$(1,2) \\in E$ 等。因此，$G_{\\mathrm{static}}$ 是一个完全图 $K_5$。在这种表示中，每个节点在所有时间 $t$ 都是其他所有节点的邻居。\n\n- **时间分辨时序网络 ($G_{\\mathrm{temporal}}$):** 这个网络是动态的。在特定时间 $t$ 的活动接触集仅包含满足 $(i, j, t) \\in E$ 的点对 $(i, j)$。我们可以将其表示为一系列图，每个时间步一个。在实现上，这可以通过一个字典来处理，该字典将每个时间 $t$ 映射到在该时间活动的边集。\n  - $t=0: \\{(0,1)\\}$\n  - $t=1: \\{(1,2)\\}$\n  - $t=2: \\{(2,3)\\}$\n  ... 对于所有 $t \\in \\{0, \\dots, 9\\}$ 依此类推。\n\n### **2. SIR 模拟算法**\n\n将设计一个单一函数来为给定的参数集 $(\\beta, \\mu, T)$ 和指定的网络类型执行 SIR 模拟。节点的状态将用数字表示，例如 $S \\equiv 0$，$I \\equiv 1$，$R \\equiv 2$。\n\n模拟过程如下：\n\n1.  **初始化：**\n    - 使用指定的种子 ($42$) 初始化一个伪随机数生成器 (PRNG)，以确保每次模拟结果的可复现性。\n    - 设置大小为 $|V|=5$ 的节点状态数组。在 $t=0$ 时，种子节点 ($0$) 被设置为状态 $I$，所有其他节点被设置为状态 $S$。\n    - 初始化一个空列表 `infectious_counts`，用于存储每个时间步 $t$ 开始时的感染个体数 $I_t$。\n\n2.  **时间演化循环：** 模拟从 $t = 0$ 迭代到 $T-1$。在每个步骤 $t$ 中：\n    - **a. 记录现存感染：** 统计当前感染节点数并附加到 `infectious_counts`。该值代表 $I_t$。\n    - **b. 传播阶段：**\n        - 识别易感节点集和感染节点集。\n        - 对于每个易感节点 $s$，识别其在时间 $t$ 连接的感染邻居数 $k$。“邻居”的定义取决于网络类型。\n            - 在 $G_{\\mathrm{static}}$ 中，任何感染节点都是邻居。\n            - 在 $G_{\\mathrm{temporal}}$ 中，只有在时间 $t$ 精确存在的边连接的节点才是邻居。\n        - 如果 $k  0$，节点 $s$ 被感染的概率是 $p_{\\mathrm{infect}} = 1 - (1-\\beta)^k$。这考虑了来自其 $k$ 个感染邻居的独立传播机会。\n        - 从 PRNG 中抽取一个随机数 $r \\in [0,1)$。如果 $r  p_{\\mathrm{infect}}$，节点 $s$ 被标记为新感染。\n    - **c. 恢复阶段：**\n        - 对于在步骤 $t$ 开始时是感染状态的每个节点 $i$，抽取一个随机数 $r \\in [0,1)$。如果 $r  \\mu$，节点 $i$ 被标记为新恢复。\n    - **d. 状态更新：** 根据问题的更新约定，所有节点的状态在时间步 $t+1$ 开始时同时更新。标记为新感染的节点从 $S$ 转换到 $I$。标记为新恢复的节点从 $I$ 转换到 $R$。\n\n3.  **指标计算：** 循环在时间 $T$ 完成后：\n    - **最终爆发规模 ($F$)：** 模拟结束时非易感状态 ($S$) 的节点总数。这是处于状态 $I$ 和 $R$ 的节点之和。\n    - **感染峰值时间 ($t^{\\star}$):** `infectious_counts` 列表中的最大值的索引。问题规定，如果最大值在多个时间点出现，则使用最小的那个索引；`numpy.argmax` 自然地提供了这个功能。\n\n### **3. 程序结构**\n\n主程序将定义测试用例和事件列表。然后它将遍历每个测试用例 $(\\beta, \\mu, T)$，对静态网络和时序网络各执行一次上述模拟算法。每个测试用例的四个结果指标 ($F_{\\mathrm{static}}, t^{\\star}_{\\mathrm{static}}, F_{\\mathrm{temporal}}, t^{\\star}_{\\mathrm{temporal}}$) 将被收集起来。最后，收集到的结果将按照问题规范的要求，格式化为一个表示列表的列表的单个字符串。\n\n对于特殊情况 $(\\beta=0.0, \\mu=1.0)$，我们预计没有传播 ($p_{\\mathrm{infect}}=0$)。初始种子节点在 $t=0$ 时是感染状态，然后立即恢复 (因为 $\\mu=1.0$)，疫情将停止。因此，对于这种情况，我们预期 $I_0=1$ 且对于 $t>0$ 有 $I_t=0$。这将导致两种网络类型的 $F=1$ 和 $t^{\\star}=0$，这可作为对实现的关键验证。",
            "answer": "```python\nimport numpy as np\n\ndef run_simulation(beta, mu, T, network_type, events, num_nodes, seed_node, prng_seed):\n    \"\"\"\n    Runs a single SIR simulation on a given network representation.\n\n    Args:\n        beta (float): Transmission probability.\n        mu (float): Recovery probability.\n        T (int): Simulation horizon (number of time steps).\n        network_type (str): 'static' or 'temporal'.\n        events (list): List of contact events (i, j, t).\n        num_nodes (int): Total number of nodes.\n        seed_node (int): The initial infectious node.\n        prng_seed (int): Seed for the pseudo-random number generator.\n\n    Returns:\n        tuple: A tuple containing the final outbreak size (F) and peak infectious time (t_star).\n    \"\"\"\n    # State representation: 0=S, 1=I, 2=R\n    S, I, R = 0, 1, 2\n    \n    # Initialize PRNG for reproducibility of this specific run\n    rng = np.random.default_rng(prng_seed)\n    \n    # Initialize states: one seed node is infectious, others are susceptible\n    states = np.full(num_nodes, S, dtype=int)\n    states[seed_node] = I\n    \n    # Prepare network structure\n    temporal_adj = {}\n    if network_type == 'temporal':\n        temporal_adj = {t: [] for t in range(T)}\n        for i, j, t in events:\n            if t  T:\n                temporal_adj[t].append(tuple(sorted((i, j))))\n\n    infectious_counts = []\n\n    for t in range(T):\n        # 1. Record number of infectious nodes at the start of step t\n        current_infected_count = np.sum(states == I)\n        infectious_counts.append(current_infected_count)\n\n        if current_infected_count == 0:\n            # Optimization: if no one is infectious, epidemic cannot spread further\n            # Fill remaining time steps with 0\n            infectious_counts.extend([0] * (T - t - 1))\n            break\n\n        # 2. Transmission phase\n        infectious_nodes = np.where(states == I)[0]\n        susceptible_nodes = np.where(states == S)[0]\n        newly_infected = set()\n\n        if beta > 0 and len(susceptible_nodes) > 0:\n            if network_type == 'static':\n                # The static graph is a complete graph K_5.\n                # All susceptible nodes are exposed to all infectious nodes.\n                num_infectious_neighbors = len(infectious_nodes)\n                if num_infectious_neighbors > 0:\n                    p_infect = 1.0 - (1.0 - beta)**num_infectious_neighbors\n                    for s_node in susceptible_nodes:\n                        if rng.random()  p_infect:\n                            newly_infected.add(s_node)\n            else: # temporal\n                active_contacts = temporal_adj.get(t, [])\n                if active_contacts:\n                    for s_node in susceptible_nodes:\n                        k = 0 # Number of infectious neighbors for this susceptible node at time t\n                        for i_node in infectious_nodes:\n                            if tuple(sorted((s_node, i_node))) in active_contacts:\n                                k += 1\n                        if k > 0:\n                            p_infect = 1.0 - (1.0 - beta)**k\n                            if rng.random()  p_infect:\n                                newly_infected.add(s_node)\n\n        # 3. Recovery phase\n        newly_recovered = set()\n        if mu > 0:\n            for i_node in infectious_nodes:\n                if rng.random()  mu:\n                    newly_recovered.add(i_node)\n\n        # 4. Update states for time t+1\n        # It's important to update based on the sets, as a node cannot be both newly infected and recovered\n        # The logic is sound as newly_infected comes from S, and newly_recovered from I.\n        if newly_infected:\n            states[list(newly_infected)] = I\n        if newly_recovered:\n            states[list(newly_recovered)] = R\n            \n    # Calculate metrics after simulation horizon T\n    # F: Final outbreak size (nodes that are not S)\n    final_outbreak_size = np.sum(states != S)\n    \n    # t_star: Smallest time of peak infection\n    # np.argmax returns the first occurrence of the maximum value.\n    if not infectious_counts or max(infectious_counts) == 0:\n      peak_time = 0\n    else:\n      peak_time = np.argmax(infectious_counts)\n\n    return final_outbreak_size, peak_time\n\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final results.\n    \"\"\"\n    # Problem givens\n    num_nodes = 5\n    seed_node = 0\n    prng_seed = 42\n    events = [\n        (0, 1, 0), (1, 2, 1), (2, 3, 2), (3, 4, 3), (0, 2, 4),\n        (1, 3, 5), (2, 4, 6), (0, 3, 7), (1, 4, 8), (0, 4, 9)\n    ]\n\n    # Test suite: (beta, mu, T)\n    test_cases = [\n        (0.3, 0.1, 10),\n        (0.5, 0.9, 10),\n        (0.0, 1.0, 10),\n        (0.8, 0.2, 10),\n    ]\n\n    all_results = []\n    for beta, mu, T in test_cases:\n        # Run for static network\n        F_static, t_star_static = run_simulation(beta, mu, T, 'static', events, num_nodes, seed_node, prng_seed)\n        \n        # Run for temporal network\n        F_temporal, t_star_temporal = run_simulation(beta, mu, T, 'temporal', events, num_nodes, seed_node, prng_seed)\n        \n        all_results.append([F_static, t_star_static, F_temporal, t_star_temporal])\n\n    # Format the output as a string representation of a list of lists.\n    # str(list) creates the correct format e.g., '[1, 0, 1, 0]'\n    # ','.join(...) creates the comma separation between these lists.\n    # The outer '[]' complete the list of lists format.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```"
        }
    ]
}