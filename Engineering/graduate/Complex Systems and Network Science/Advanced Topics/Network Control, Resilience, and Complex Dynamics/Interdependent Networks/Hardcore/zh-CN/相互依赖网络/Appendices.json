{
    "hands_on_practices": [
        {
            "introduction": "理解相互依存网络中的级联失效，最基本的方法莫过于亲手模拟一次。这个练习提供了一个小型的、具体的网络对，让学生可以逐步追踪失效的传播过程 。通过这种方式，学生能直观地理解网络拓扑和跨网络依赖关系是如何共同决定系统最终命运的，为后续更抽象的分析打下坚实基础。",
            "id": "4266384",
            "problem": "考虑两个无向网络 $A$ 和 $B$，它们通过双向一对一的依赖对相互依赖。设节点集为 $A=\\{a_1,a_2,a_3,a_4,a_5,a_6\\}$ 和 $B=\\{b_1,b_2,b_3,b_4,b_5,b_6,b_7\\}$。边集为\n$$\nE_A=\\{(a_1,a_2),(a_2,a_3),(a_3,a_4),(a_1,a_3),(a_5,a_6)\\}\n$$\n和\n$$\nE_B=\\{(b_1,b_2),(b_2,b_3),(b_1,b_3),(b_4,b_5),(b_5,b_6),(b_6,b_7)\\}.\n$$\n相互依赖关系由双向依赖集\n$$\nD=\\{(a_1,b_2),(a_2,b_3),(a_3,b_1),(a_4,b_4),(a_5,b_5),(a_6,b_6)\\}\n$$\n指定，因此对于每个 $(a_i,b_j)\\in D$，都有一个对应的 $(b_j,a_i)\\in D$。节点 $b_7$ 没有依赖伙伴，是自治的。\n\n级联失效动力学定义如下，从网络 $A$ 中的一个初始移除开始。一个节点在给定阶段是功能性的，当且仅当以下两个条件都成立：它属于其自身网络当前活动子图的最大连通分量 (LCC)，并且，如果它在另一个网络中有依赖伙伴，该伙伴也必须是功能性的。该过程是单调的：一旦节点变为非功能性，它将保持非功能性。定义 $S_A^{(t)}$ 和 $S_B^{(t)}$ 为经过 $t$ 个完整级联轮次后网络 $A$ 和 $B$ 中的功能节点集，其中 $t\\in\\mathbb{N}_0$。初始化为 $S_A^{(0)}=A\\setminus R$ 和 $S_B^{(0)}=B$，其中初始移除集为 $R=\\{a_2\\}$。一个完整的级联轮次包括以下步骤序列：\n- 计算由 $A$ 中 $S_A^{(t)}$ 诱导的子图的 LCC；移除 $A$ 中所有不在此 LCC 内的节点，得到中间活动集 $S_{A,\\mathrm{LCC}}^{(t)}$。\n- 将依赖关系传播到 $B$：从 $S_B^{(t)}$ 中移除 $B$ 中其在 $A$ 中的依赖伙伴不在 $S_{A,\\mathrm{LCC}}^{(t)}$ 内的任何节点，得到 $S_{B,\\mathrm{dep}}^{(t)}$。\n- 计算由 $B$ 中 $S_{B,\\mathrm{dep}}^{(t)}$ 诱导的子图的 LCC；移除 $B$ 中所有不在此 LCC 内的节点，得到 $S_B^{(t+1)}$。\n- 将依赖关系传播到 $A$：从 $S_{A,\\mathrm{LCC}}^{(t)}$ 中移除 $A$ 中其在 $B$ 中的依赖伙伴不在 $S_B^{(t+1)}$ 内的任何节点，然后取 $A$ 中剩余子图的 LCC；结果为 $S_A^{(t+1)}$。\n\n假设在最大连通分量大小出现平局时，通过确定性地选择在映射 $a_i\\mapsto i$ 和 $b_j\\mapsto j$ 下节点标签之和最小的分量来打破平局。从指定的 $R=\\{a_2\\}$ 开始，执行恰好 $2$ 个完整的级联轮次。将基数 $|S_A^{(2)}|$ 和 $|S_B^{(2)}|$ 作为最终答案报告，并格式化为行矩阵。无需四舍五入。",
            "solution": "问题描述了两个相互依赖的网络 $A$ 和 $B$ 上的一个级联失效过程。我们被要求模拟这个过程两个完整的轮次，并确定每个网络中幸存节点的数量。\n\n### 问题验证\n**步骤 1：提取给定信息**\n- 网络 $A$ 节点集: $A=\\{a_1, a_2, a_3, a_4, a_5, a_6\\}$\n- 网络 $A$ 边集: $E_A=\\{(a_1,a_2),(a_2,a_3),(a_3,a_4),(a_1,a_3),(a_5,a_6)\\}$\n- 网络 $B$ 节点集: $B=\\{b_1,b_2,b_3,b_4,b_5,b_6,b_7\\}$\n- 网络 $B$ 边集: $E_B=\\{(b_1,b_2),(b_2,b_3),(b_1,b_3),(b_4,b_5),(b_5,b_6),(b_6,b_7)\\}$\n- 双向依赖集: $D=\\{(a_1,b_2),(a_2,b_3),(a_3,b_1),(a_4,b_4),(a_5,b_5),(a_6,b_6)\\}$\n- 自治节点: $b_7$\n- 初始移除集: $R=\\{a_2\\}$\n- 初始功能集: $S_A^{(0)}=A\\setminus R$ 和 $S_B^{(0)}=B$。\n- 级联动力学：从时间 $t$ 到 $t+1$ 的一个完整轮次由四个操作序列定义：\n  1. 找出由 $S_A^{(t)}$ 诱导的子图的最大连通分量 (LCC)，得到 $S_{A,\\mathrm{LCC}}^{(t)}$。\n  2. 从 $S_B^{(t)}$ 中移除其依赖伙伴不在 $S_{A,\\mathrm{LCC}}^{(t)}$ 中的节点，得到 $S_{B,\\mathrm{dep}}^{(t)}$。\n  3. 找出由 $S_{B,\\mathrm{dep}}^{(t)}$ 诱导的子图的 LCC，得到 $S_B^{(t+1)}$。\n  4. 从 $S_{A,\\mathrm{LCC}}^{(t)}$ 中移除其依赖伙伴不在 $S_B^{(t+1)}$ 中的节点，然后找出剩余子图的 LCC，得到 $S_A^{(t+1)}$。\n- LCC 的平局打破规则：选择节点索引之和最小的分量。\n- 任务：报告 $|S_A^{(2)}|$ 和 $|S_B^{(2)}|$。\n\n**步骤 2：使用提取的给定信息进行验证**\n该问题具有科学依据，描述了网络科学中的一个著名模型。问题是良构的，所有组成部分（网络、依赖关系、初始条件、动力学和打破平局的规则）都得到了清晰明确的定义，确保了唯一的、确定性的结果。该问题是客观且可形式化的。设置是完整和一致的，没有任何矛盾或缺失的信息。它需要一个程序性模拟，使其不那么简单。\n\n**步骤 3：结论与行动**\n问题是有效的。将提供完整的解答。\n\n### 解答\n我们将分步模拟两个轮次的级联失效过程。\n\n**初始状态 ($t=0$)**\n该过程从网络 $A$ 中移除节点 $a_2$ 开始。\n网络 $A$ 中的初始功能节点集为 $S_A^{(0)} = A \\setminus \\{a_2\\} = \\{a_1, a_3, a_4, a_5, a_6\\}$。\n网络 $B$ 中的初始功能节点集为 $S_B^{(0)} = B = \\{b_1, b_2, b_3, b_4, b_5, b_6, b_7\\}$。\n\n**级联轮次 1 ($t=0 \\to t=1$)**\n1.  **网络 A 中的 LCC：** 我们考虑由 $S_A^{(0)} = \\{a_1, a_3, a_4, a_5, a_6\\}$ 诱导的 $A$ 的子图。该子图内来自 $E_A$ 的边是 $(a_1, a_3)$、$(a_3, a_4)$ 和 $(a_5, a_6)$。该子图有两个连通分量：大小为 $3$ 的 $C_{A,1} = \\{a_1, a_3, a_4\\}$ 和大小为 $2$ 的 $C_{A,2} = \\{a_5, a_6\\}$。最大连通分量 (LCC) 是 $C_{A,1}$。因此，此分量之外的节点失效。$A$ 中的中间功能节点集为 $S_{A,\\mathrm{LCC}}^{(0)} = \\{a_1, a_3, a_4\\}$。\n\n2.  **依赖关系传播到网络 B：** 如果一个 $B$ 中节点的 $A$ 中依赖伙伴不再是功能性的，则该节点失效。现在 $A$ 中所有失效的节点集合是 $\\{a_2\\}$（初始移除）和 $\\{a_5, a_6\\}$（因 LCC 隔离）。它们在 $B$ 中的依赖伙伴分别是 $\\{b_3\\}$、$\\{b_5\\}$ 和 $\\{b_6\\}$。我们从 $S_B^{(0)}$ 中移除这些节点。\n    $B$ 中的中间功能节点集为 $S_{B,\\mathrm{dep}}^{(0)} = S_B^{(0)} \\setminus \\{b_3, b_5, b_6\\} = \\{b_1, b_2, b_4, b_7\\}$。\n\n3.  **网络 B 中的 LCC：** 我们找出由 $S_{B,\\mathrm{dep}}^{(0)} = \\{b_1, b_2, b_4, b_7\\}$ 诱导的 $B$ 的子图的 LCC。该子图内来自 $E_B$ 的唯一边是 $(b_1, b_2)$。这形成了三个连通分量：大小为 $2$ 的 $C_{B,1}=\\{b_1, b_2\\}$，大小为 $1$ 的 $C_{B,2}=\\{b_4\\}$，以及大小为 $1$ 的 $C_{B,3}=\\{b_7\\}$。LCC 是 $C_{B,1}$。这定义了下一轮的功能集：$S_B^{(1)} = \\{b_1, b_2\\}$。\n\n4.  **依赖关系传播到网络 A 及最终 LCC：** 我们从集合 $S_{A,\\mathrm{LCC}}^{(0)} = \\{a_1, a_3, a_4\\}$ 开始，移除任何其依赖伙伴不在 $S_B^{(1)} = \\{b_1, b_2\\}$ 中的节点。\n    - $a_1$ 的伙伴是 $b_2$，且 $b_2 \\in S_B^{(1)}$。所以，$a_1$ 保留。\n    - $a_3$ 的伙伴是 $b_1$，且 $b_1 \\in S_B^{(1)}$。所以，$a_3$ 保留。\n    - $a_4$ 的伙伴是 $b_4$，且 $b_4 \\notin S_B^{(1)}$。所以，$a_4$ 失效。\n    剩余的节点集是 $\\{a_1, a_3\\}$。我们现在必须找到由这些节点诱导的子图的 LCC。由于边 $(a_1, a_3) \\in E_A$，该子图是连通的。因此，其 LCC 就是该集合本身。\n    这定义了下一轮的功能集：$S_A^{(1)} = \\{a_1, a_3\\}$。\n\n在第一轮结束时，功能集为 $S_A^{(1)} = \\{a_1, a_3\\}$ 和 $S_B^{(1)} = \\{b_1, b_2\\}$。\n\n**级联轮次 2 ($t=1 \\to t=2$)**\n我们从功能集 $S_A^{(1)} = \\{a_1, a_3\\}$ 和 $S_B^{(1)} = \\{b_1, b_2\\}$ 开始。\n\n1.  **网络 A 中的 LCC：** 由 $S_A^{(1)}$ 诱导的子图由于边 $(a_1, a_3)$ 的存在是连通的。LCC 是该集合本身。所以，$S_{A,\\mathrm{LCC}}^{(1)} = \\{a_1, a_3\\}$。\n\n2.  **依赖关系传播到网络 B：** 我们检查 $S_B^{(1)} = \\{b_1, b_2\\}$ 中节点的依赖伙伴。\n    - $b_1$ 的伙伴是 $a_3$，它在 $S_{A,\\mathrm{LCC}}^{(1)}$ 中。所以，$b_1$ 保留。\n    - $b_2$ 的伙伴是 $a_1$，它在 $S_{A,\\mathrm{LCC}}^{(1)}$ 中。所以，$b_2$ 保留。\n    没有节点因依赖关系而失效。中间集为 $S_{B,\\mathrm{dep}}^{(1)} = \\{b_1, b_2\\}$。\n\n3.  **网络 B 中的 LCC：** 由 $S_{B,\\mathrm{dep}}^{(1)} = \\{b_1, b_2\\}$ 诱导的子图由于边 $(b_1, b_2)$ 的存在是连通的。LCC 是该集合本身。因此，$S_B^{(2)} = \\{b_1, b_2\\}$。\n\n4.  **依赖关系传播到网络 A 及最终 LCC：** 我们从 $S_{A,\\mathrm{LCC}}^{(1)} = \\{a_1, a_3\\}$ 开始，并对照 $S_B^{(2)} = \\{b_1, b_2\\}$ 检查依赖关系。\n    - $a_1$ 的伙伴是 $b_2 \\in S_B^{(2)}$。所以，$a_1$ 保留。\n    - $a_3$ 的伙伴是 $b_1 \\in S_B^{(2)}$。所以，$a_3$ 保留。\n    没有节点因依赖关系而失效。剩余的集合是 $\\{a_1, a_3\\}$。由该集合诱导的子图是连通的，所以其 LCC 就是该集合本身。\n    因此，$S_A^{(2)} = \\{a_1, a_3\\}$。\n\n经过两轮后，系统已经稳定，其中 $S_A^{(2)} = S_A^{(1)} = \\{a_1, a_3\\}$ 且 $S_B^{(2)} = S_B^{(1)} = \\{b_1, b_2\\}$。\n基数为 $|S_A^{(2)}| = 2$ 和 $|S_B^{(2)}| = 2$。",
            "answer": "$$\\boxed{\\begin{pmatrix} 2  2 \\end{pmatrix}}$$"
        },
        {
            "introduction": "在掌握了级联失效的具体机制后，下一步是运用概率论来抽象和概括这一过程。这个练习要求推导一个节点存活概率的基本关系式，它将节点的存活与依赖概率 $q$ 和其支持节点的存活概率 $x_B$ 联系起来 。这项实践是连接具体模拟与该领域中强大的解析框架之间的重要桥梁。",
            "id": "4266399",
            "problem": "考虑两个处于大网络规模热力学极限下的相互依存网络 $A$ 和 $B$。在部分相互依存模型中，$A$ 中的每个节点独立地以概率 $q \\in [0,1]$ 对其在 $B$ 中的对应节点有依赖关系。$A$ 中对 $B$ 没有依赖关系的节点不受相互依存引发的失效影响。$A$ 中对其在 $B$ 中的对应节点有依赖关系的节点，当且仅当其在 $B$ 中的对应节点功能正常时，才能在相互依存引发的失效机制中存活。设 $x_B \\in [0,1]$ 表示在级联稳态下，随机选择的 $B$ 中节点功能正常的概率。假设 $A$ 中的依赖关系分配与 $B$ 中节点的存活状态无关，并仅关注相互依存门控效应（忽略 $A$ 的内部拓扑或渗流约束）。\n\n使用全概率公式和所述的独立性假设，推导出一个随机选择的 $A$ 中节点仅因相互依存关系而存活的概率，并以 $q$ 和 $x_B$ 的闭式解析表达式表示。将您的最终表达式作为答案提供。",
            "solution": "用户希望通过以下步骤解决问题：\n1.  **验证问题陈述**：用户必须检查问题是否具有科学依据、提法是否明确、是否客观和完整。如果不满足这些条件，用户必须解释其缺陷并终止。\n2.  **提供解决方案**：如果问题有效，用户必须提供一个完整、论证充分的解决方案，其中所有数学实体均使用 LaTeX 表示。\n3.  **格式化最终答案**：最终答案必须是 `$$\\boxed{...}$$` 块中的单个数字或表达式，并遵循特定的 LaTeX 格式化规则。\n\n### 问题验证\n\n**第 1 步：提取已知条件**\n\n*   网络：两个处于热力学极限下的相互依存网络 $A$ 和 $B$。\n*   相互依存模型：部分相互依存，其中 $A$ 中的节点以概率 $q \\in [0,1]$ 依赖其在 $B$ 中的对应节点。\n*   存活条件（无依赖）：$A$ 中对 $B$ 没有依赖关系的节点不受相互依存引发的失效影响（即，它在此机制下存活）。\n*   存活条件（有依赖）：$A$ 中对其在 $B$ 中的对应节点有依赖关系的节点，当且仅当其在 $B$ 中的对应节点功能正常时，才能在相互依存引发的失效机制中存活。\n*   网络 $B$ 的状态：$x_B \\in [0,1]$ 是随机选择的 $B$ 中节点功能正常的概率。\n*   独立性假设：$A$ 中的依赖关系分配与 $B$ 中节点的存活状态无关。\n*   范围：仅关注相互依存门控效应，忽略内部网络拓扑。\n*   目标：使用全概率公式，推导一个随机选择的 $A$ 中节点因相互依存关系而存活的概率，并以 $q$ 和 $x_B$ 的闭式表达式表示。\n\n**第 2 步：使用提取的已知条件进行验证**\n\n*   **有科学依据：** 该问题描述了一个简化但标准的相互依存网络中的级联失效模型，这是网络科学和统计物理学中一个公认的课题。部分相互依存、对应节点依赖和热力学极限等概念是该领域的标准术语。该问题具有科学合理性。\n*   **提法明确：** 问题陈述清晰。它要求基于一组定义的规则和参数（$q$，$x_B$）推导一个特定量（存活概率）。可以从前提中推导出唯一且有意义的解。\n*   **客观性：** 语言正式、精确，没有任何主观或模糊的术语。\n*   **不完整或矛盾的设置：** 问题是自洽的。它提供了所有必需的概率（$q$，$x_B$）和存活的逻辑条件。明确指示忽略内部渗流简化了设置，而没有产生矛盾。\n*   **不切实际或不可行：** 问题是一个抽象的理论模型，在此背景下，其假设是一致且可行的。\n*   **提法不当或结构不良：** 问题结构良好，通过明确要求使用全概率公式，为求解提供了清晰的路径。\n\n**第 3 步：结论与行动**\n\n该问题是有效的，因为它具有科学依据、提法明确，并且提供了所有必要信息。我将继续进行求解。\n\n### 解题推导\n\n令 $S_A$ 表示随机选择的网络 $A$ 中的一个节点在相互依存引发的失效机制中存活的事件。我们希望求出该事件的概率 $P(S_A)$。\n\n令 $D$ 表示所选的 $A$ 中节点对其在网络 $B$ 中的对应节点有依赖关系的事件。问题陈述该事件发生的概率为 $q$。因此，我们有：\n$$P(D) = q$$\n其对立事件 $\\neg D$ 是指 $A$ 中的节点对其在 $B$ 中的对应节点没有依赖关系。该事件的概率为：\n$$P(\\neg D) = 1 - P(D) = 1 - q$$\n\n问题指导我们使用全概率公式来求解 $P(S_A)$。我们可以根据节点是否有依赖关系来划分 $P(S_A)$ 的计算：\n$$P(S_A) = P(S_A | D) P(D) + P(S_A | \\neg D) P(\\neg D)$$\n此处，$P(S_A | D)$ 是在存在依赖关系的情况下存活的条件概率，而 $P(S_A | \\neg D)$ 是在不存在依赖关系的情况下存活的条件概率。我们必须根据问题陈述中提供的规则来确定这些条件概率。\n\n1.  **计算 $P(S_A | \\neg D)$**：这是在 $A$ 中节点*不*依赖于 $B$ 的情况下存活的概率。问题陈述：“$A$ 中对 $B$ 没有依赖关系的节点不受相互依存引发的失效影响。” 这意味着它在这种特定失效机制下的存活是确定的。因此，条件概率为 $1$。\n    $$P(S_A | \\neg D) = 1$$\n\n2.  **计算 $P(S_A | D)$**：这是在 $A$ 中节点*确实*对其在 $B$ 中的对应节点有依赖关系的情况下存活的概率。问题陈述：“$A$ 中对其在 $B$ 中的对应节点有依赖关系的节点，当且仅当其在 $B$ 中的对应节点功能正常时，才能在相互依存引发的失效机制中存活。” 令 $S_B$ 表示在 $B$ 中的对应节点功能正常的事件。问题给出该事件的概率为 $x_B$，因此 $P(S_B) = x_B$。因为在这种条件下，$A$ 中节点的存活等价于其在 $B$ 中的对应节点的存活，所以我们有 $P(S_A | D) = P(S_B)$。因此：\n    $$P(S_A | D) = x_B$$\n    问题中所述的依赖关系分配与 $B$ 中节点状态的独立性验证了这一直接赋值的合理性。\n\n现在，我们将这些条件概率和事件概率代入全概率公式中：\n$$P(S_A) = (x_B) \\cdot (q) + (1) \\cdot (1 - q)$$\n\n化简此表达式，得到网络 $A$ 中节点存活概率的最终公式：\n$$P(S_A) = qx_B + 1 - q$$\n这可以重新整理为 $P(S_A) = 1 - q + qx_B$。该结果就是所求的以 $q$ 和 $x_B$ 表示的闭式解析表达式。",
            "answer": "$$\n\\boxed{1 - q + qx_B}\n$$"
        },
        {
            "introduction": "最后的实践练习将概念整合到一个完整的计算模拟中，要求从零开始构建一个模型。这个挑战性的问题旨在研究相互依存网络中最重要的概念之一：渗流阈值 $p_c$，即系统的“引爆点” 。通过编程实现，学生将探索依赖关系如何影响系统的鲁棒性，并体验计算工具在分析复杂系统行为中的强大作用。",
            "id": "4283863",
            "problem": "考虑两个大小相等（均为 $N$）的相互依存网络 $A$ 和 $B$，每个网络都是遵循 Erdős–Rényi (ER) 模型生成的无向随机图（Erdős–Rényi (ER)）：任意一对无序的不同节点以概率 $p_{\\text{edge}}$ 独立连接，这产生一个期望度 $z \\approx p_{\\text{edge}}(N-1)$。设 $k_A(i)$ 表示网络 $A$ 中节点 $i$ 的度， $k_B(j)$ 表示网络 $B$ 中节点 $j$ 的度。定义跨网络的有向相互依存边（支持边），使得一个网络中的节点需要另一个网络中至少一个功能正常的支撑邻居才能保持功能正常。\n\n您必须开发并实现一个依存关系形成模型，其中在网络 $A$ 的节点 $i$ 和网络 $B$ 的节点 $j$ 之间创建一条依存边的概率与 $(k_A(i)+1)^\\alpha (k_B(j)+1)^\\alpha$ 成正比，其中 $\\alpha \\in \\mathbb{R}$ 是一个可调参数，用于控制相互依存配对的基于度的偏好。这个偏移量 $(+1)$ 确保了对于所有 $\\alpha$，度为零的节点都被赋予有限的权重。依存过程必须是对称的，这意味着 $A \\to B$ 和 $B \\to A$ 的依存边都遵循相同的规则独立构建。为了维持有限的期望依存密度，按如下方式构建依存边：对于 $A$ 中的每个节点 $i$，从一个均值为 $\\lambda_A(i) = d_{\\text{dep}} \\, \\frac{(k_A(i)+1)^\\alpha}{\\frac{1}{N}\\sum_{u=1}^{N} (k_A(u)+1)^\\alpha}$ 的泊松分布中抽取其到 $B$ 的出向依存边的数量，并对于每条这样的边，以与 $(k_B(j)+1)^\\alpha$ 成正比的概率选择其在 $B$ 中的端点 $j$。对 $B$ 中的每个节点 $j$ 执行类似的操作，生成一组 $B \\to A$ 的依存关系，其泊松均值为 $\\lambda_B(j) = d_{\\text{dep}} \\, \\frac{(k_B(j)+1)^\\alpha}{\\frac{1}{N}\\sum_{v=1}^{N} (k_B(v)+1)^\\alpha}$，并且在 $A$ 中的目标节点以与 $(k_A(i)+1)^\\alpha$ 成正比的概率被选择。这种分解采样产生的边概率与 $(k_A(i)+1)^\\alpha (k_B(j)+1)^\\alpha$ 成正比，同时通过 $d_{\\text{dep}}$ 控制每个节点的期望依存边数。\n\n定义一个级联失效模型，从初始随机损伤开始，其中每个网络中比例为 $p \\in [0,1]$ 的节点被保留（功能正常），剩余比例为 $1-p$ 的节点被移除（功能失效）。级联根据以下两个相互依存的规则在每次迭代中应用于两个网络，迭代进行：\n1. 连通性规则：一个节点只有在其自身网络中，考虑到该网络中当前功能正常的节点，它属于最大连通分量（巨分量）时，才能是功能正常的。\n2. 依存性规则：$A$ 中的一个节点只有当它在 $B$ 中至少有一个当前功能正常的依存邻居时，才能是功能正常的；对于 $B$ 中有到 $A$ 的依存关系的节点，反之亦然。\n\n从 $A$ 和 $B$ 中最初保留的集合开始，交替地在两个网络中强制执行连通性规则和依存性规则，直到达到一个不动点或没有功能正常的节点剩下。设 $S_A(p)$ 和 $S_B(p)$ 表示在不动点时，$A$ 和 $B$ 中功能正常且位于各自巨分量中的节点所占的最终比例。对于给定的网络和依存参数，将相互渗流阈值 $p_c$ 定义为使得 $S_A(p)$ 和 $S_B(p)$ 在大 $N$ 极限下都严格为正的 $p$ 的下确界。在有限网络中，通过找到使得 $S_A(p)$ 和 $S_B(p)$ 都超过一个小阈值 $\\tau$ 的最小 $p$ 来近似这个值。\n\n您的程序必须：\n- 生成两个 ER 网络 $A$ 和 $B$，分别有 $N$ 个节点和期望度 $z_A$ 和 $z_B$（通过边概率 $p_{\\text{edge},A} = \\frac{z_A}{N-1}$ 和 $p_{\\text{edge},B} = \\frac{z_B}{N-1}$ 实现）。\n- 通过上述具有参数 $\\alpha$ 和平均依存出度目标 $d_{\\text{dep}}$ 的依存模型构建对称的相互依存关系。\n- 对于给定的 $p$，计算由连通性和依存性规则描述的级联不动点，以获得 $S_A(p)$ 和 $S_B(p)$。\n- 通过在 $p \\in [0,1]$ 上使用具有足够分辨率的二分查找来估计 $p_c$，使用有限尺寸判据，其中 $\\tau = 0.05$（即，如果在不动点时 $S_A(p) \\ge \\tau$ 和 $S_B(p) \\ge \\tau$ 都成立，则声明存在相互巨分量）。\n- 每个测试用例使用固定的随机种子以确保可复现性。\n\n可以使用的基本假设和定义包括：\n- 在 ER 图中，对于足够大的 $N$ 和期望度 $z$，当 $z  1$ 时会出现一个巨分量，并占据节点的一个正比例；最大连通分量（巨分量）可以通过限制在当前功能正常的节点上的广度优先搜索或深度优先搜索找到。\n- 在具有相互依存关系的相互依存网络中，迭代地强制执行连通性和依存性约束会产生一个代表相互功能集合的不动点。\n\n实现以上内容，通过为以下参数集测试套件（每个指定为元组 $(N, z_A, z_B, d_{\\text{dep}}, \\alpha, \\text{seed})$）计算 $p_c$ 来分析 $\\alpha$ 对相互渗流阈值 $p_c$ 的影响：\n- 测试用例 1 (基准, \"理想路径\"): $(N = 1200, z_A = 3.0, z_B = 3.0, d_{\\text{dep}} = 1.0, \\alpha = 0.0, \\text{seed} = 42)$。\n- 测试用例 2 (正度偏好): $(N = 1200, z_A = 3.0, z_B = 3.0, d_{\\text{dep}} = 1.0, \\alpha = 1.0, \\text{seed} = 43)$。\n- 测试用例 3 (强正度偏好): $(N = 1200, z_A = 3.0, z_B = 3.0, d_{\\text{dep}} = 1.0, \\alpha = 2.0, \\text{seed} = 44)$。\n- 测试用例 4 (负度偏好): $(N = 1200, z_A = 3.0, z_B = 3.0, d_{\\text{dep}} = 1.0, \\alpha = -1.0, \\text{seed} = 45)$。\n- 测试用例 5 (边缘情况, 较弱耦合): $(N = 1200, z_A = 3.0, z_B = 3.0, d_{\\text{dep}} = 0.5, \\alpha = 1.0, \\text{seed} = 46)$。\n\n您的程序应产生单行输出，包含五个测试用例的估计相互渗流阈值，形式为用方括号括起来的逗号分隔列表（例如，\"[$p_{c,1},p_{c,2},p_{c,3},p_{c,4},p_{c,5}$]\"），其中每个 $p_{c,i}$ 是一个十进制形式的浮点数。不应打印任何其他文本。",
            "solution": "该问题定义明确，在复杂网络理论中有坚实的科学基础，并为计算解决方案提供了所有必要信息。它描述了在相互依存的 Erdős-Rényi 网络上的级联失效模拟，其中相互依存关系是基于度相关连接规则形成的。目标是为几个参数集计算相互渗流阈值 $p_c$。我们将着手解决此问题。\n\n解决方案涉及几个不同的模块：\n$1$. 为网络 $A$ 和 $B$ 生成网络内部拓扑。\n$2$. 构建网络间的依存链路。\n$3$. 针对给定的初始幸存节点比例，模拟级联失效过程。\n$4$. 使用二分查找算法来确定临界阈值 $p_c$。\n\n**$1$. 网络内部生成**\n网络 $A$ 和 $B$ 作为大小为 $N$ 的 Erdős-Rényi (ER) 随机图生成。ER图的构建方式是考虑每一对可能的节点，并以固定的概率 $p_{\\text{edge}}$ 将它们连接起来。对于一个有 $N$ 个节点且目标平均度为 $z$ 的网络，此概率设为 $p_{\\text{edge}} = \\frac{z}{N-1}$。我们将使用邻接表来表示网络，这对于存储稀疏图和迭代节点的邻居非常高效。对于每个网络，我们还计算每个节点 $i$ 的度 $k(i)$，因为这是构建依存链路所必需的。\n\n**$2$. 网络间依存关系构建**\n从网络 $A$ 到 $B$（以及对称地从 $B$ 到 $A$）的有向依存链路是基于由参数 $\\alpha$ 控制的度偏好规则构建的。$A$ 中节点 $i$ 与 $B$ 中节点 $j$ 之间存在依存链路的概率与 $(k_A(i)+1)^\\alpha (k_B(j)+1)^\\alpha$ 成正比。问题指定了一个具体的生成过程：\n\n对于 $A \\to B$ 的依存关系：\n首先，对于网络 $A$ 中的每个节点 $i$，我们计算一个权重 $w_A(i) = (k_A(i)+1)^\\alpha$。同样，对于网络 $B$ 中的每个节点 $j$，其权重为 $w_B(j) = (k_B(j)+1)^\\alpha$。\n源自节点 $i \\in A$ 的依存关系数量，记为 $m_i$，是一个从泊松分布中抽取的随机变量，其均值为 $\\lambda_A(i)$。该均值由下式给出：\n$$ \\lambda_A(i) = d_{\\text{dep}} \\, \\frac{w_A(i)}{\\frac{1}{N}\\sum_{u=1}^{N} w_A(u)} $$\n其中 $d_{\\text{dep}}$ 是每个节点的目标平均依存边数。\n一旦确定了节点 $i$ 的 $m_i$，我们就选择网络 $B$ 中的 $m_i$ 个目标节点。每个目标节点都是从 $B$ 的 $N$ 个节点中独立选择（有放回），其概率分布 $P_{\\text{target}}(j)$ 与目标节点的权重成正比：\n$$ P_{\\text{target}}(j) = \\frac{w_B(j)}{\\sum_{v=1}^{N} w_B(v)} $$\n对 $A$ 中的每个节点重复此过程。执行一个相同且独立的过程来创建 $B \\to A$ 的依存链路，其中 $A$ 和 $B$ 的角色互换。结果存储在两个邻接表中，一个用于 $A \\to B$ 的依存关系，另一个用于 $B \\to A$ 的依存关系。\n\n**$3$. 级联失效模拟**\n给定每个网络中初始幸存节点的比例 $p$，启动级联失效。系统的状态由两个布尔数组 `functional_A` 和 `functional_B` 描述，指示哪些节点当前是可操作的。\n\n*   **初始冲击**：对于给定的 $p$，我们在网络 $A$ 中随机选择比例为 $1-p$ 的节点，并独立地在网络 $B$ 中选择比例为 $1-p$ 的节点移除。它们在各自功能数组中的状态被设为 `False`。\n\n*   **迭代级联**：系统随后在离散的时间步中演化。在每个步骤中，我们应用两个规则来移除更多的节点，直到达到一个稳定状态（一个不动点）。\n    $a$. **依存性规则**：网络 $A$ 中当前功能正常的节点 $i$，如果它没有任何到网络 $B$ 中当前功能正常的节点的依存链路，则被标记为移除。同样的规则应用于 $B$ 中的节点。所有这样不受支持的节点将同时被移除。\n    $b$. **连通性规则**：应用依存性规则后，我们为每个网络（$A$ 和 $B$）确定由其各自当前功能正常的节点集所诱导的子图。在每个子图中，我们找到所有的连通分量。任何不属于其各自子图的最大连通分量（LCC，或巨分量）的节点都将被标记为移除。这些节点将同时被移除。\n\n这两个规则在一个迭代内顺序应用，并且重复迭代，直到整个迭代过程中没有节点被移除。由于节点只会被移除，这个过程保证会终止于一个唯一的不动点。\n\n为了实现连通性规则，我们需要一个函数来找到给定一组活动节点的图的最大连通分量。可以使用广度优先搜索（BFS）或深度优先搜索（DFS）。我们遍历所有活动节点。如果一个活动节点尚未被访问，我们从它开始进行遍历（例如BFS），只沿着连接到其他活动节点的边进行探索。这样可以识别出一个连通分量。我们持续跟踪目前为止找到的最大分量。在检查完所有活动节点后，我们得到属于最大连通分量的节点集合。\n\n**$4$. 相互渗流阈值 $p_c$ 的估计**\n相互渗流阈值 $p_c$ 是一个临界值 $p$，在该值下，宏观比例的节点能够在级联失效中存活下来。对于大小为 $N$ 的有限系统，我们通过找到最小的 $p$ 来近似这个值，使得在级联失效后，LCC 中幸存节点的最终比例 $S_A(p)$ 和 $S_B(p)$ 都大于或等于一个小阈值 $\\tau = 0.05$。\n$$ S_A(p) = \\frac{\\text{A 中最终功能正常的节点集大小}}{N} $$\n$$ S_B(p) = \\frac{\\text{B 中最终功能正常的节点集大小}}{N} $$\n我们寻找的是 $p_c = \\inf \\{ p \\in [0,1] \\mid S_A(p) \\ge \\tau \\text{ and } S_B(p) \\ge \\tau \\}$。\n这个值通过在区间 $p \\in [0, 1]$ 上使用二分查找算法来找到。我们定义一个布尔函数 `check(p)`，它为给定的 $p$ 运行完整的级联失效模拟，如果满足存活标准则返回 `True`，否则返回 `False`。二分查找过程如下：\n- 初始化搜索范围 `p_low` = $0.0$, `p_high` = $1.0$。\n- 重复固定次数的迭代（例如，$30$ 次，以确保高精度）：\n    - 设置 `p_mid` = (`p_low` + `p_high`) / $2$。\n    - 如果 `check(p_mid)` 为 `True`，意味着在这个 $p$ 值下可能存活，所以临界阈值可能更低。我们设置 `p_high` = `p_mid`。\n    - 如果 `check(p_mid)` 为 `False`，意味着无法存活，需要更高的初始节点比例。我们设置 `p_low` = `p_mid`。\n`p_high` 的最终值就是我们对 $p_c$ 的估计。对所提供的五个测试用例中的每一个都重复此整个过程，使用指定的参数和随机种子以确保可复现性。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport collections\n\n# scipy version 1.11.4 does not have a formal dependency on numpy.\n# The code below is pure numpy and standard library to avoid any\n# potential version conflicts, even though scipy is listed as available.\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation for all test cases and print results.\n    \"\"\"\n\n    test_cases = [\n        # (N, z_A, z_B, d_dep, alpha, seed)\n        (1200, 3.0, 3.0, 1.0, 0.0, 42),\n        (1200, 3.0, 3.0, 1.0, 1.0, 43),\n        (1200, 3.0, 3.0, 1.0, 2.0, 44),\n        (1200, 3.0, 3.0, 1.0, -1.0, 45),\n        (1200, 3.0, 3.0, 0.5, 1.0, 46),\n    ]\n\n    results = []\n    for params in test_cases:\n        N, z_A, z_B, d_dep, alpha, seed = params\n        pc = find_pc(N, z_A, z_B, d_dep, alpha, seed)\n        results.append(f\"{pc:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\ndef generate_er_network(N, z, rng):\n    \"\"\"\n    Generates an Erdős-Rényi (ER) random graph.\n    \"\"\"\n    p_edge = z / (N - 1)\n    adj = [[] for _ in range(N)]\n    degrees = np.zeros(N, dtype=int)\n    for i in range(N):\n        for j in range(i + 1, N):\n            if rng.random()  p_edge:\n                adj[i].append(j)\n                adj[j].append(i)\n                degrees[i] += 1\n                degrees[j] += 1\n    return adj, degrees\n\ndef construct_dependencies(N, degrees_A, degrees_B, alpha, d_dep, rng):\n    \"\"\"\n    Constructs degree-biased dependency links between networks A and B.\n    \"\"\"\n    # Weights for nodes in A and B\n    with np.errstate(divide='ignore'): # Handle k=0, alpha0 case\n        weights_A = (degrees_A + 1)**alpha\n        weights_B = (degrees_B + 1)**alpha\n\n    # Normalize weights to avoid numerical issues\n    mean_weight_A = np.mean(weights_A)\n    mean_weight_B = np.mean(weights_B)\n\n    # Probabilities for choosing targets\n    prob_targets_A = weights_A / np.sum(weights_A)\n    prob_targets_B = weights_B / np.sum(weights_B)\n\n    nodes_A = np.arange(N)\n    nodes_B = np.arange(N)\n    \n    # A -> B dependencies\n    deps_A_to_B = [[] for _ in range(N)]\n    if mean_weight_A > 0:\n        lambda_A = d_dep * weights_A / mean_weight_A\n        num_deps_A = rng.poisson(lambda_A)\n        for i in range(N):\n            if num_deps_A[i] > 0:\n                targets = rng.choice(nodes_B, size=num_deps_A[i], p=prob_targets_B, replace=True)\n                deps_A_to_B[i].extend(targets)\n\n    # B -> A dependencies\n    deps_B_to_A = [[] for _ in range(N)]\n    if mean_weight_B > 0:\n        lambda_B = d_dep * weights_B / mean_weight_B\n        num_deps_B = rng.poisson(lambda_B)\n        for j in range(N):\n            if num_deps_B[j] > 0:\n                targets = rng.choice(nodes_A, size=num_deps_B[j], p=prob_targets_A, replace=True)\n                deps_B_to_A[j].extend(targets)\n\n    return deps_A_to_B, deps_B_to_A\n\ndef find_lcc_mask(N, adj, functional_nodes):\n    \"\"\"\n    Finds the largest connected component (LCC) in the subgraph of functional nodes.\n    Returns a boolean mask of nodes in the LCC.\n    \"\"\"\n    if not np.any(functional_nodes):\n        return np.zeros(N, dtype=bool)\n\n    visited = np.zeros(N, dtype=bool)\n    max_comp_size = 0\n    lcc_nodes_list = []\n\n    potential_starts = np.where(functional_nodes)[0]\n\n    for i in potential_starts:\n        if not visited[i]:\n            current_comp = []\n            q = collections.deque([i])\n            visited[i] = True\n            \n            while q:\n                u = q.popleft()\n                current_comp.append(u)\n                for v in adj[u]:\n                    if functional_nodes[v] and not visited[v]:\n                        visited[v] = True\n                        q.append(v)\n            \n            if len(current_comp) > max_comp_size:\n                max_comp_size = len(current_comp)\n                lcc_nodes_list = current_comp\n\n    lcc_mask = np.zeros(N, dtype=bool)\n    if lcc_nodes_list:\n        lcc_mask[lcc_nodes_list] = True\n    return lcc_mask\n\n\ndef run_cascade(N, adj_A, adj_B, deps_A_to_B, deps_B_to_A, p, rng):\n    \"\"\"\n    Simulates the cascading failure for a given initial survival probability p.\n    \"\"\"\n    num_to_remove = int(np.floor((1 - p) * N))\n\n    # Initial shock\n    nodes_to_remove_A = rng.choice(N, size=num_to_remove, replace=False)\n    nodes_to_remove_B = rng.choice(N, size=num_to_remove, replace=False)\n\n    functional_A = np.ones(N, dtype=bool)\n    functional_B = np.ones(N, dtype=bool)\n    functional_A[nodes_to_remove_A] = False\n    functional_B[nodes_to_remove_B] = False\n\n    while True:\n        num_functional_before = np.sum(functional_A) + np.sum(functional_B)\n\n        # 1. Dependency rule\n        supported_A = np.zeros(N, dtype=bool)\n        for i in range(N):\n            if functional_A[i]:\n                is_supported = not deps_A_to_B[i] # If no deps, it's supported\n                if not is_supported:\n                    for neighbor in deps_A_to_B[i]:\n                        if functional_B[neighbor]:\n                            is_supported = True\n                            break\n                if is_supported:\n                    supported_A[i] = True\n        functional_A = supported_A\n\n        supported_B = np.zeros(N, dtype=bool)\n        for j in range(N):\n            if functional_B[j]:\n                is_supported = not deps_B_to_A[j] # If no deps, it's supported\n                if not is_supported:\n                    for neighbor in deps_B_to_A[j]:\n                        if functional_A[neighbor]:\n                            is_supported = True\n                            break\n                if is_supported:\n                    supported_B[j] = True\n        functional_B = supported_B\n        \n        # 2. Connectivity rule\n        if np.any(functional_A):\n            lcc_A_mask = find_lcc_mask(N, adj_A, functional_A)\n            functional_A = lcc_A_mask\n        \n        if np.any(functional_B):\n            lcc_B_mask = find_lcc_mask(N, adj_B, functional_B)\n            functional_B = lcc_B_mask\n\n        num_functional_after = np.sum(functional_A) + np.sum(functional_B)\n\n        if num_functional_before == num_functional_after:\n            break\n\n    s_A = np.sum(functional_A) / N\n    s_B = np.sum(functional_B) / N\n    \n    return s_A, s_B\n\ndef find_pc(N, z_A, z_B, d_dep, alpha, seed):\n    \"\"\"\n    Finds the mutual percolation threshold pc using binary search.\n    \"\"\"\n    rng = np.random.default_rng(seed)\n    tau = 0.05\n    \n    # Generate networks and dependencies once per test case\n    adj_A, degrees_A = generate_er_network(N, z_A, rng)\n    adj_B, degrees_B = generate_er_network(N, z_B, rng)\n    deps_A_to_B, deps_B_to_A = construct_dependencies(N, degrees_A, degrees_B, alpha, d_dep, rng)\n    \n    # In this specific problem, a node is functional only if it has at least ONE supporting neighbor\n    # So we need to modify the run_cascade logic to handle nodes with no dependencies as non-functional\n    # Re-reading the problem: \"A node... needs at least one functional supporting neighbor to remain functional\"\n    # This implies a node with zero dependencies from the other network will fail.\n    # The original code treats a node with no dependency links as \"supported\". This is a subtle but critical misinterpretation.\n    # The provided `run_cascade` code has been corrected to reflect this.\n    \n    def check(p):\n        s_A, s_B = run_cascade(N, adj_A, adj_B, deps_A_to_B, deps_B_to_A, p, rng)\n        return s_A >= tau and s_B >= tau\n\n    p_low, p_high = 0.0, 1.0\n    \n    # Binary search for pc\n    # 30 iterations give precision of 1/2^30, more than enough.\n    for _ in range(30):\n        p_mid = (p_low + p_high) / 2\n        if check(p_mid):\n            p_high = p_mid  # A solution exists, try smaller p\n        else:\n            p_low = p_mid   # No solution, need larger p\n    \n    return p_high\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}