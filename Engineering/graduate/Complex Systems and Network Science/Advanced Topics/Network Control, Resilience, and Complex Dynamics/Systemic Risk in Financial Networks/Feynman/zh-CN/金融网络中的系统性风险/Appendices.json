{
    "hands_on_practices": [
        {
            "introduction": "系统性风险建模的核心在于确定在相互连接的债务网络中，每个金融机构最终能够偿还的支付向量 $p$。本练习将引导您在一个小型三银行系统中，通过手工计算来实践经典的 Eisenberg-Noe 清算模型 。通过推演和验证哪些银行违约（即 $p_i  \\bar{p}_i$），哪些银行保持偿付能力，您将掌握金融传染机制的基础逻辑。",
            "id": "4306720",
            "problem": "考虑一个由三家银行组成的金融系统，银行索引为 $i \\in \\{1,2,3\\}$，该系统通过 Eisenberg–Noe (EN) 框架进行建模。每家银行 $i$ 对系统有总名义负债 $\\bar{p}_{i} \\ge 0$，并拥有外部资产 $a_{i} \\ge 0$。相对负债矩阵 $\\Pi$ 的元素为 $\\Pi_{ij} \\in [0,1]$，代表银行 $i$ 的总名义负债中欠债权人 $j$ 的部分，当 $\\bar{p}_{i} > 0$ 时，满足 $\\sum_{j=1}^{3} \\Pi_{ij} = 1$。令 $p \\in \\mathbb{R}_{+}^{3}$ 表示清算时的已实现支付向量。\n\n假设有限责任和按比例偿付，因此每家银行的已实现支付等于其总名义负债和其可用资源（外部资产加上已实现的银行间流入资金）中的较小者。形式上，对于每个 $i$，清算支付必须满足，\n$$\n0 \\le p_{i} \\le \\bar{p}_{i}, \\quad p_{i} = \\min\\!\\left\\{ \\bar{p}_{i},\\ a_{i} + \\sum_{j=1}^{3} \\Pi_{j i}\\, p_{j} \\right\\}.\n$$\n\n给定以下实例（所有数量均以同一货币单位计算）：\n- 总名义负债向量 $\\bar{p} = (\\bar{p}_{1}, \\bar{p}_{2}, \\bar{p}_{3}) = (100, 90, 80)$。\n- 相对负债矩阵\n$$\n\\Pi \\;=\\;\n\\begin{pmatrix}\n0  0.5  0.5 \\\\\n0.4  0  0.6 \\\\\n0.5  0.5  0\n\\end{pmatrix}.\n$$\n- 外部资产向量 $a = (a_{1}, a_{2}, a_{3}) = (20, 30, 35)$。\n\n从 Eisenberg–Noe 框架中内含的有限责任和按比例偿付的定义出发，推导清算问题的不动点方程，并显式求解清算向量 $p$。在不动点处，确定违约集合 $D = \\{\\, i \\in \\{1,2,3\\} : p_{i}  \\bar{p}_{i} \\,\\}$。\n\n答案格式要求：将您的最终答案以单行矩阵的形式报告，包含六个条目，顺序为 $(p_{1}, p_{2}, p_{3}, d_{1}, d_{2}, d_{3})$，其中如果银行 $i$ 违约，则 $d_{i} = 1$，否则 $d_{i} = 0$。无需四舍五入。在最终的方框答案中不要包含单位。",
            "solution": "该问题被验证为具有科学依据、提法恰当且客观。这是 Eisenberg–Noe 金融清算模型的一个标准应用，所有必要数据均已提供。\n\n清算向量 $p=(p_1, p_2, p_3)$ 由每家银行 $i \\in \\{1,2,3\\}$ 的不动点条件确定：\n$$\np_{i} = \\min\\!\\left\\{ \\bar{p}_{i},\\ a_{i} + \\sum_{j=1}^{3} \\Pi_{j i}\\, p_{j} \\right\\}\n$$\n其中 $\\bar{p} = (100, 90, 80)$ 是总名义负债向量，$a = (20, 30, 35)$ 是外部资产向量，$\\Pi$ 是相对负债矩阵。项 $\\sum_{j=1}^{3} \\Pi_{j i}\\, p_{j}$ 代表银行 $i$ 收到的总银行间资产。这个和可以用 $\\Pi$ 的转置（记为 $\\Pi^T$）来表示，其中 $(\\Pi^T)_{ij} = \\Pi_{ji}$。方程组为：\n$$\n\\begin{pmatrix} p_1 \\\\ p_2 \\\\ p_3 \\end{pmatrix} = \\min\\!\\left\\{ \\begin{pmatrix} \\bar{p}_1 \\\\ \\bar{p}_2 \\\\ \\bar{p}_3 \\end{pmatrix}, \\begin{pmatrix} a_1 \\\\ a_2 \\\\ a_3 \\end{pmatrix} + \\Pi^T \\begin{pmatrix} p_1 \\\\ p_2 \\\\ p_3 \\end{pmatrix} \\right\\}\n$$\n给定矩阵 $\\Pi$，其转置为：\n$$\n\\Pi^T =\n\\begin{pmatrix}\n0  0.4  0.5 \\\\\n0.5  0  0.5 \\\\\n0.5  0.6  0\n\\end{pmatrix}\n$$\n清算支付的方程组变为：\n$$\np_1 = \\min\\{100,\\, 20 + 0.4 p_2 + 0.5 p_3\\} \\\\\np_2 = \\min\\{90,\\, 30 + 0.5 p_1 + 0.5 p_3\\} \\\\\np_3 = \\min\\{80,\\, 35 + 0.5 p_1 + 0.6 p_2\\}\n$$\n为了求解这个系统，我们可以将银行集合划分为两个不相交的集合：违约银行集合，$D = \\{i : p_i  \\bar{p}_i\\}$，和偿付能力充足的银行集合，$S = \\{i : p_i = \\bar{p}_i\\}$。对于银行 $i \\in D$，其已实现支付等于其可用资源。对于银行 $i \\in S$，其已实现支付等于其名义负债，并且其可用资源必须足以覆盖这些负债。\n这导出了基于一个假设划分 $(D, S)$ 的以下方程组和不等式组：\n对于 $i \\in D$：$p_i = a_i + \\sum_{j=1}^{3} \\Pi_{ji} p_j$\n对于 $i \\in S$：$p_i = \\bar{p}_i$ 且 $a_i + \\sum_{j=1}^{3} \\Pi_{ji} p_j \\ge \\bar{p}_i$\n\n让我们首先检验没有银行违约的假设，即 $D = \\emptyset$ 且 $S = \\{1, 2, 3\\}$。这将意味着 $p = \\bar{p} = (100, 90, 80)$。我们必须检查所有银行的资源约束是否满足。\n对于银行1：$a_1 + \\sum_{j=1}^{3} \\Pi_{j1} p_j = 20 + 0.4(90) + 0.5(80) = 20 + 36 + 40 = 96$。\n偿付能力充足的条件是 $96 \\ge \\bar{p}_1 = 100$，这是不成立的。因此，假设 $D = \\emptyset$ 是不正确的。至少银行1必须违约。\n\n让我们检验假设 $D = \\{1\\}$ 且 $S = \\{2, 3\\}$。这意味着：\n1. 银行1违约：$p_1  100$，所以 $p_1 = 20 + 0.4 p_2 + 0.5 p_3$。\n2. 银行2偿付能力充足：$p_2 = \\bar{p}_2 = 90$。\n3. 银行3偿付能力充足：$p_3 = \\bar{p}_3 = 80$。\n\n我们将 $p_2$ 和 $p_3$ 的值代入 $p_1$ 的方程中：\n$$\np_1 = 20 + 0.4(90) + 0.5(80) = 20 + 36 + 40 = 96\n$$\n这给出了一个候选解向量 $p = (96, 90, 80)$。现在，我们必须验证这个解与我们关于划分 $(D,S)$ 的初始假设的一致性。\n- 对于银行 $1 \\in D$：$p_1  \\bar{p}_1$ 是否成立？我们有 $96  100$。这符合假设。\n- 对于银行 $2 \\in S$：$p_2 = \\bar{p}_2$ 是否成立，且其资源是否充足？我们设定 $p_2=90$。我们必须检查 $a_2 + \\sum_{j=1}^{3} \\Pi_{j2} p_j \\ge \\bar{p}_2$ 是否成立。\n$$\n30 + 0.5 p_1 + 0.5 p_3 = 30 + 0.5(96) + 0.5(80) = 30 + 48 + 40 = 118\n$$\n条件是 $118 \\ge 90$，成立。这符合假设。\n- 对于银行 $3 \\in S$：$p_3 = \\bar{p}_3$ 是否成立，且其资源是否充足？我们设定 $p_3=80$。我们必须检查 $a_3 + \\sum_{j=1}^{3} \\Pi_{j3} p_j \\ge \\bar{p}_3$ 是否成立。\n$$\n35 + 0.5 p_1 + 0.6 p_2 = 35 + 0.5(96) + 0.6(90) = 35 + 48 + 54 = 137\n$$\n条件是 $137 \\ge 80$，成立。这也符合假设。\n\n由于划分 $D=\\{1\\}, S=\\{2,3\\}$ 的所有条件都得到满足，这个划分是正确的，并且唯一的清算向量是 $p = (96, 90, 80)$。\n\n违约集合是 $D = \\{i : p_i  \\bar{p}_i\\}$。\n- 银行1：$p_1 = 96  \\bar{p}_1 = 100$，所以银行1违约。违约指示符为 $d_1 = 1$。\n- 银行2：$p_2 = 90 = \\bar{p}_2 = 90$，所以银行2不违约。违约指示符为 $d_2 = 0$。\n- 银行3：$p_3 = 80 = \\bar{p}_3 = 80$，所以银行3不违约。违约指示符为 $d_3 = 0$。\n\n最终的清算向量是 $p=(p_1, p_2, p_3) = (96, 90, 80)$，违约指示符向量是 $d=(d_1, d_2, d_3) = (1, 0, 0)$。最终答案必须以单行矩阵 $(p_1, p_2, p_3, d_1, d_2, d_3)$ 的形式报告。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n96  90  80  1  0  0\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "除了清算机制本身，网络的拓扑结构在决定冲击如何传播方面起着至关重要的作用。本练习探讨了一种常见的核心-边缘（core-periphery）网络结构，并揭示了节点的系统重要性并不仅仅取决于其“核心”或“边缘”的标签，而是其具体的连接模式 。通过手动追踪违约的连锁反应，您将建立起关于网络拓扑如何塑造系统脆弱性的直观理解。",
            "id": "2435839",
            "problem": "考虑一个静态的银行间网络，该网络具有核心-外围架构，包含六家银行：核心银行 $C_{1}, C_{2}, C_{3}$ 和外围银行 $P_{1}, P_{2}, P_{3}$。令 $L_{ij}$ 表示银行 $i$ 对银行 $j$ 的名义银行间负债（因此 $j$ 是 $i$ 的债权人）。仅有的非零银行间负债如下：\n- $L_{P_{1},C_{1}} = 4$, $L_{P_{1},C_{2}} = 4$, $L_{P_{1},C_{3}} = 4$,\n- $L_{P_{2},C_{1}} = 4$,\n- $L_{P_{3},C_{2}} = 4$,\n- $L_{C_{1},C_{2}} = 4$, $L_{C_{2},C_{3}} = 4$, $L_{C_{3},C_{1}} = 4$。\n\n所有银行初始时均为有偿付能力，且每家银行 $i$ 都拥有相同的股权（资本）缓冲 $E_{i} = 3$ 货币单位。银行间资产的回收率为 $0$（等价于违约损失率 (LGD) 等于 $1$）：如果借款人 $i$ 违约，每个债权人 $j$ 会立即将其银行间资产减记 $L_{ij}$。一家银行 $k$ 违约当且仅当其股权变为严格为负。传染以离散的轮次展开：在每一轮中，任何新违约借款人造成的损失都会传递给其债权人；当没有新的违约发生时，此过程停止。超过零的股权不计入（有限责任）。\n\n考虑两个实验，每个实验都由一个发生在时间 $0$ 的特殊外部资产冲击引发，该冲击足够大，足以迫使目标银行立即违约：\n- 情景 S1（高连接度外围冲击）：冲击 $P_{1}$，使 $P_{1}$ 在时间 $0$ 违约。\n- 情景 S2（低连接度核心冲击）：冲击 $C_{3}$，使 $C_{3}$ 在时间 $0$ 违约。\n\n将破坏性定义为级联效应不动点处的银行违约总数（包括最初受冲击的银行）。根据所述规则，对于该网络，以下哪个陈述是正确的？\n\nA. 冲击高连接度的外围银行 $P_{1}$（情景 S1）比冲击低连接度的核心银行 $C_{3}$（情景 S2）更具破坏性。\n\nB. 冲击低连接度的核心银行 $C_{3}$（情景 S2）比冲击高连接度的外围银行 $P_{1}$（情景 S1）更具破坏性。\n\nC. 两种情景的破坏性相同。\n\nD. 两种情景都不会产生超出最初受冲击银行范围的传染。",
            "solution": "首先应验证问题陈述的科学性和逻辑完整性。\n\n### 步骤 1：提取已知信息\n问题陈述中提供的必要信息如下：\n- **网络结构**：六家银行，分为核心银行（$C_{1}, C_{2}, C_{3}$）和外围银行（$P_{1}, P_{2}, P_{3}$）。\n- **银行间负债 ($L_{ij}$)**：非零负债为：\n  - $L_{P_{1},C_{1}} = 4$\n  - $L_{P_{1},C_{2}} = 4$\n  - $L_{P_{1},C_{3}} = 4$\n  - $L_{P_{2},C_{1}} = 4$\n  - $L_{P_{3},C_{2}} = 4$\n  - $L_{C_{1},C_{2}} = 4$\n  - $L_{C_{2},C_{3}} = 4$\n  - $L_{C_{3},C_{1}} = 4$\n- **初始条件**：每家银行 $i$ 的初始股权为 $E_{i} = 3$ 货币单位。\n- **违约机制**：\n  - 银行间资产的回收率为 $0$。这意味着违约损失率（LGD）为 $1$。\n  - 一家银行 $k$ 在其股权变为严格为负时（即 $E_{k}  0$）违约。\n  - 传染以离散的轮次传播。\n- **情景**：\n  - **情景 S1**：银行 $P_{1}$ 受到冲击并在时间 $t=0$ 违约。\n  - **情景 S2**：银行 $C_{3}$ 受到冲击并在时间 $t=0$ 违约。\n- **度量标准**：破坏性被定义为最终状态下银行违约的总数。\n\n### 步骤 2：使用提取的已知信息进行验证\n该问题描述了一个金融网络上的传染过程，这是计算经济学和金融学中的一个标准课题。\n- **科学依据**：该模型是已建立的传染模型（如那些由 Furfine 或 Eisenberg-Noe 提出的模型）的简化形式。它基于公认的资产负债表机制和违约传播原理。\n- **适定性**：网络结构、初始条件和传染的动态规则都得到了明确无误的定义。这使得每个情景都能产生唯一的、确定性的结果。\n- **客观性**：问题以精确、量化的术语陈述。违约和破坏性的定义清晰且客观。\n- **缺陷检查**：该问题不违反任何无效性标准。它是自洽的、逻辑一致的且计算上可行的。描述“高连接度”和“低连接度”可以基于节点的出度来解释，这与传染传播相关。$P_1$ 的出度是 $3$，而 $C_3$ 的出度是 $1$，这使得该术语在此背景下是合理的。\n\n### 步骤 3：结论与行动\n问题陈述是**有效的**。现在将推导求解过程。\n\n### 求解过程推导\n对每个情景的传染过程进行逐轮模拟。每家银行的初始股权为 $E_i = 3$。如果银行 $k$ 的股权 $E_k$ 降至 $0$ 以下，则该银行违约。\n\n**情景 S1：冲击外围银行 $P_{1}$**\n\n- **时间 $t=0$**：银行 $P_{1}$ 受到冲击并违约。\n  - 违约银行集合，$D = \\{P_{1}\\}$。\n  - $P_{1}$ 的债权人是满足 $L_{P_{1},j} > 0$ 的银行 $j$。根据已知信息，这些银行是 $C_{1}$、$C_{2}$ 和 $C_{3}$。\n\n- **时间 $t=1$**：$P_{1}$ 违约造成的损失传播给其债权人。由于回收率为 $0$，每个债权人的损失等于负债的全部价值。\n  - $C_{1}$ 的股权变为：$E_{C_{1}}' = E_{C_{1}} - L_{P_{1},C_{1}} = 3 - 4 = -1$。\n  - $C_{2}$ 的股权变为：$E_{C_{2}}' = E_{C_{2}} - L_{P_{1},C_{2}} = 3 - 4 = -1$。\n  - $C_{3}$ 的股权变为：$E_{C_{3}}' = E_{C_{3}} - L_{P_{1},C_{3}} = 3 - 4 = -1$。\n  - 我们检查新的违约情况：\n    - $E_{C_{1}}'  0 \\implies C_{1}$ 违约。\n    - $E_{C_{2}}'  0 \\implies C_{2}$ 违约。\n    - $E_{C_{3}}'  0 \\implies C_{3}$ 违约。\n  - 本轮新增的违约银行是 $\\{C_{1}, C_{2}, C_{3}\\}$。\n  - 现在的违约银行集合是 $D = \\{P_{1}, C_{1}, C_{2}, C_{3}\\}$。\n\n- **时间 $t=2$**：来自第 $t=1$ 轮 $C_{1}$、$C_{2}$ 和 $C_{3}$ 违约的损失被传播。我们必须检查当前有偿付能力的银行中有哪些是这些新违约银行的债权人。\n  - 仅有的有偿付能力的银行是 $P_{2}$ 和 $P_{3}$。\n  - 我们检查 $P_2$ 或 $P_3$ 是否是 $C_1, C_2, C_3$ 的债权人。没有形如 $L_{C_{k}, P_{j}}$ 的负债，所以它们不是。它们的股权保持在 $3$。\n  - $C_{1}$ 的债权人是 $C_{2}$ ($L_{C_{1},C_{2}}=4$)，$C_{2}$ 的债权人是 $C_{3}$ ($L_{C_{2},C_{3}}=4$)，$C_{3}$ 的债权人是 $C_{1}$ ($L_{C_{3},C_{1}}=4$)。然而，所有这些债权人 ($C_1, C_2, C_3$) 都已经违约。因此，它们的违约不会在有偿付能力的银行中引发任何*新的*违约。\n  - 本轮没有新的银行违约。\n\n- **不动点**：由于在第 $t=2$ 轮没有新的违约发生，级联效应已经停止。\n  - 情景 S1 的最终违约银行集合是 $\\{P_{1}, C_{1}, C_{2}, C_{3}\\}$。\n  - 总破坏性为 $4$ 次违约。\n\n**情景 S2：冲击核心银行 $C_{3}$**\n\n- **时间 $t=0$**：银行 $C_{3}$ 受到冲击并违约。\n  - 违约银行集合，$D = \\{C_{3}\\}$。\n  - $C_{3}$ 的债权人是满足 $L_{C_{3},j} > 0$ 的银行 $j$。根据已知信息，唯一的债权人是 $C_{1}$ ($L_{C_{3},C_{1}} = 4$)。\n\n- **时间 $t=1$**：$C_{3}$ 违约造成的损失传播给其债权人 $C_{1}$。\n  - $C_{1}$ 的股权变为：$E_{C_{1}}' = E_{C_{1}} - L_{C_{3},C_{1}} = 3 - 4 = -1$。\n  - 我们检查新的违约情况：$E_{C_{1}}'  0 \\implies C_{1}$ 违约。\n  - 本轮新增违约：$\\{C_{1}\\}$。\n  - 现在的违约银行集合是 $D = \\{C_{3}, C_{1}\\}$。\n\n- **时间 $t=2$**：来自第 $t=1$ 轮 $C_{1}$ 违约的损失被传播。\n  - $C_{1}$ 的债权人是 $C_{2}$ ($L_{C_{1},C_{2}} = 4$)。银行 $C_2$ 当前有偿付能力（$E_{C_{2}} = 3$）。\n  - $C_{2}$ 的股权变为：$E_{C_{2}}' = E_{C_{2}} - L_{C_{1},C_{2}} = 3 - 4 = -1$。\n  - 我们检查新的违约情况：$E_{C_{2}}'  0 \\implies C_{2}$ 违约。\n  - 本轮新增违约：$\\{C_{2}\\}$。\n  - 现在的违约银行集合是 $D = \\{C_{3}, C_{1}, C_{2}\\}$。\n\n- **时间 $t=3$**：来自第 $t=2$ 轮 $C_{2}$ 违约的损失被传播。\n  - $C_{2}$ 的债权人是 $C_{3}$ ($L_{C_{2},C_{3}} = 4$)。\n  - 银行 $C_{3}$ 已经在违约银行集合中。没有触发新的违约。\n  - 没有有偿付能力的银行是 $C_2$ 的债权人。\n  - 本轮没有新的银行违约。\n\n- **不动点**：由于在第 $t=3$ 轮没有新的违约发生，级联效应已经停止。\n  - 情景 S2 的最终违约银行集合是 $\\{C_{3}, C_{1}, C_{2}\\}$。\n  - 总破坏性为 $3$ 次违约。\n\n**情景比较**\n- 情景 S1 的破坏性：$4$ 次违约。\n- 情景 S2 的破坏性：$3$ 次违约。\n由于 $4 > 3$，情景 S1 比情景 S2 更具破坏性。\n\n### 逐项分析\n\n**A. 冲击高连接度的外围银行 $P_{1}$（情景 S1）比冲击低连接度的核心银行 $C_{3}$（情景 S2）更具破坏性。**\n根据计算，S1 导致 4 家银行违约，S2 导致 3 家银行违约。$4 > 3$。因此，S1 更具破坏性。如果“连接度”指的是出度（银行对其负有债务的债权人数量），即引发传染的渠道，那么“高连接度”和“低连接度”的标签是一致的。$P_1$ 的出度为 3，而 $C_3$ 的出度为 1。该陈述与推导结果一致。\n**结论：正确。**\n\n**B. 冲击低连接度的核心银行 $C_{3}$（情景 S2）比冲击高连接度的外围银行 $P_{1}$（情景 S1）更具破坏性。**\n该陈述声称 $3 > 4$，这在数学上是错误的。\n**结论：错误。**\n\n**C. 两种情景的破坏性相同。**\n该陈述声称 $4 = 3$，这在数学上是错误的。\n**结论：错误。**\n\n**D. 两种情景都不会产生超出最初受冲击银行范围的传染。**\n在 S1 中，银行 $C_{1}, C_{2}, C_{3}$ 因传染而违约。在 S2 中，银行 $C_{1}, C_{2}$ 因传染而违约。两种情况下，传染都明显发生。\n**结论：错误。**",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "手动求解清算系统对于理解模型很有启发，但对于真实规模的网络来说并不可行。本练习要求您动手实现用于求解 Eisenberg-Noe 清算向量 $p$ 的标准计算方法——虚拟违约算法（Fictitious Default Algorithm, FDA）。这项实践将帮助您搭建从理论模型到大规模系统性风险实用分析之间的桥梁。",
            "id": "4306697",
            "problem": "考虑一个包含 $n$ 家银行的金融网络中的 Eisenberg–Noe (EN) 银行间清算支付模型。令 $L \\in \\mathbb{R}_{+}^{n \\times n}$ 为名义银行间负债矩阵，其中 $L_{i j}$ 表示银行 $i$ 对银行 $j$ 的债务。令 $\\bar{p} \\in \\mathbb{R}_{+}^{n}$ 为每家银行对所有债权人（包括非银行债权人，如储户）的总名义负债向量，令 $x \\in \\mathbb{R}_{+}^{n}$ 为每家银行可用于偿还负债的外源性资产向量。定义相对负债矩阵 $\\Pi \\in [0,1]^{n \\times n}$ 为，当 $\\bar{p}_{i} > 0$ 时 $\\pi_{i j} = \\frac{L_{i j}}{\\bar{p}_{i}}$，当 $\\bar{p}_{i} = 0$ 时 $\\pi_{i j} = 0$。EN 清算机制旨在寻求一个支付向量 $p \\in \\mathbb{R}_{+}^{n}$，该向量遵循有限责任和绝对优先原则：每家银行 $i$ 支付 $p_{i} = \\min\\{\\bar{p}_{i}, x_{i} + \\sum_{j=1}^{n} \\pi_{j i} p_{j}\\}$。\n\n任务 A (实现)：实现虚拟违约算法 (FDA)，用于计算上文定义的清算支付向量 $p$。您的实现必须对任意 $n$ 通用，并且仅依赖于所提供的基本定义。不应引入超出本问题陈述范围的任何额外假设。\n\n任务 B (终止性证明)：提供一个清晰的证明，证明对于一个有 $n$ 家银行的系统，在所述的 EN 模型假设下，FDA 在最多 $n$ 次迭代内终止，并解释为什么每次迭代要么严格增加违约银行的集合，要么终止。\n\n任务 C (应用于测试套件)：将您的实现应用于以下参数集 $(L, \\bar{p}, x)$ 的测试套件，并为每种情况计算相应的清算支付向量 $p$。\n\n- 测试用例 $1$ (正常路径，预计无违约)：$n = 3$, \n  $$L = \\begin{pmatrix}\n  0  1  0.5 \\\\\n  0.5  0  0.5 \\\\\n  0.2  0.3  0\n  \\end{pmatrix}, \\quad \\bar{p} = \\begin{pmatrix} 1.5 \\\\ 1.0 \\\\ 0.5 \\end{pmatrix}, \\quad x = \\begin{pmatrix} 2.0 \\\\ 0.7 \\\\ 0.6 \\end{pmatrix}.$$\n- 测试用例 $2$ (因外部债务引发的级联)：$n = 3$, \n  $$L = \\begin{pmatrix}\n  0  0.9  0 \\\\\n  0  0  0.9 \\\\\n  0.9  0  0\n  \\end{pmatrix}, \\quad \\bar{p} = \\begin{pmatrix} 1.5 \\\\ 1.5 \\\\ 1.5 \\end{pmatrix}, \\quad x = \\begin{pmatrix} 0.1 \\\\ 0.1 \\\\ 0.1 \\end{pmatrix}.$$\n- 测试用例 $3$ (边界情况：一家总债务为零的银行)：$n = 2$,\n  $$L = \\begin{pmatrix}\n  0  0 \\\\\n  0.4  0\n  \\end{pmatrix}, \\quad \\bar{p} = \\begin{pmatrix} 0.0 \\\\ 0.4 \\end{pmatrix}, \\quad x = \\begin{pmatrix} 0.0 \\\\ 0.0 \\end{pmatrix}.$$\n- 测试用例 $4$ (边缘案例：单一银行，仅对社会有债务)：$n = 1$,\n  $$L = \\begin{pmatrix} 0 \\end{pmatrix}, \\quad \\bar{p} = \\begin{pmatrix} 1.0 \\end{pmatrix}, \\quad x = \\begin{pmatrix} 0.3 \\end{pmatrix}.$$\n\n输出规范：您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表（例如 $[result1,result2,result3]$）。对于每个测试用例，将计算出的支付向量 $p$ 作为浮点数的嵌套列表输出，并按银行索引的顺序（从 $1$ 到 $n$）。因此，最终输出必须是 $[[p^{(1)}_1,\\ldots,p^{(1)}_{n_1}],[p^{(2)}_1,\\ldots,p^{(2)}_{n_2}],\\ldots]$ 的形式，不含任何额外文本。\n\n所有量均为无量纲，且必须作为实数处理。角度和物理单位不适用。每个测试用例的答案是代表该情况清算支付的浮点数列表。",
            "solution": "### 任务 A 和 B：虚拟违约算法 (FDA) 及其终止性\n\n虚拟违约算法 (FDA) 是一个用于寻找 Eisenberg-Noe (EN) 清算向量 $p$ 的迭代过程。\n\n**算法描述**\n\n该算法迭代地构建一个违约银行集合。令 $V = \\{1, \\dots, n\\}$ 为所有银行的集合。\n\n1.  **初始化**：从一个候选的违约银行集合 $D_0 = \\emptyset$ 开始。假设 $A_0 = V \\setminus D_0$ 中的银行具有清偿能力。\n2.  **迭代 $k$（对于 $k \\ge 1$）**：\n    a. 给定前一次迭代的违约银行集合 $D_{k-1}$，我们定义一个假设的支付向量 $p^{(k-1)}$。假设 $A_{k-1} = V \\setminus D_{k-1}$ 中的银行 $j$ 具有清偿能力并全额支付其债务，即 $p_j^{(k-1)} = \\bar{p}_j$。\n    b. 对于 $D_{k-1}$ 中的银行 $i$（虚拟违约者），其支付由其可用现金决定。这导致了一个关于支付 $(p_i)_{i \\in D_{k-1}}$ 的线性方程组，并求解该方程组。\n    c. 我们现在有了完整的假设支付向量 $p^{(k-1)}$。\n    d. 使用这个向量 $p^{(k-1)}$，我们识别出“真正”的违约者。如果一家银行 $i$ 的总可用资产少于其总负债，则该银行违约。令所有这类银行的集合为 $D_k$。\n    e. **终止检查**：如果 $D_k = D_{k-1}$，则违约银行集合已稳定。算法终止，最终的清算向量为 $p = p^{(k-1)}$。否则，我们设置 $k \\to k+1$ 并重复该过程。\n\n**终止性证明**\n\n1.  **违约集合的单调性**：可以证明，违约集合序列是非递减的，即对于所有 $k \\ge 1$，有 $D_{k-1} \\subseteq D_k$。这是因为在每次迭代中，我们对有偿付能力银行的支付假设（$p_j = \\bar{p}_j$）是最乐观的。如果一个银行在这种乐观情况下都违约了，那么在任何更现实（即支付更少）的情况下它也必然会违约。\n2.  **严格增加或终止**：如果 $D_k \\neq D_{k-1}$，则结合 $D_{k-1} \\subseteq D_k$，意味着 $D_{k-1}$ 是 $D_k$ 的一个真子集。因此，违约集合的基数必须严格增加：$|D_k| > |D_{k-1}|$。\n3.  **有界增长**：基数序列 $|D_0|, |D_1|, |D_2|, \\ldots$ 是一个从 $0$ 开始、严格递增的整数序列，且其上限为银行总数 $n$。一个有上界的严格递增整数序列必须是有限的。因此，算法最多在 $n$ 次迭代后，违约集合的大小就不再增加，从而保证终止。\n\n### 任务 A 和 C：Python 实现及应用\n\n以下 Python 代码实现了 FDA，并将其应用于给定的四个测试用例。\n\n```python\nimport numpy as np\n\ndef compute_clearing_vector(L, p_bar, x):\n    \"\"\"\n    Computes the Eisenberg-Noe clearing payment vector using the Fictitious Default Algorithm.\n\n    Args:\n        L (np.ndarray): The n x n matrix of nominal interbank liabilities.\n        p_bar (np.ndarray): The n-element vector of total nominal liabilities.\n        x (np.ndarray): The n-element vector of exogenous assets.\n\n    Returns:\n        np.ndarray: The n-element clearing payment vector p.\n    \"\"\"\n    n = L.shape[0]\n    if n == 0:\n        return np.array([])\n        \n    # Step 1: Compute the relative liability matrix Pi\n    pi = np.zeros_like(L, dtype=float)\n    for i in range(n):\n        if p_bar[i] > 0:\n            pi[i, :] = L[i, :] / p_bar[i]\n\n    pi_T = pi.T  # Transpose for easier income calculation: income_i = (pi_T @ p)_i\n\n    # Step 2: Fictitious Default Algorithm\n    D_indices = set()\n    all_indices = set(range(n))\n\n    for _ in range(n + 1):\n        D_old_size = len(D_indices)\n        A_indices = all_indices - D_indices\n\n        D_list = sorted(list(D_indices))\n        A_list = sorted(list(A_indices))\n        \n        # Step 2a: Solve for payments of defaulting banks\n        p_iter = np.zeros(n, dtype=float)\n        \n        if D_list:\n            # System for defaulting banks: (I - Pi_T_DD) * p_D = x_D + Pi_T_DA * p_bar_A\n            pi_T_DD = pi_T[np.ix_(D_list, D_list)]\n            matrix = np.identity(len(D_list)) - pi_T_DD\n            \n            rhs = x[D_list]\n            if A_list:\n                pi_T_DA = pi_T[np.ix_(D_list, A_list)]\n                rhs += pi_T_DA @ p_bar[A_list]\n            \n            try:\n                p_D = np.linalg.solve(matrix, rhs)\n                p_D[p_D  0] = 0\n                p_iter[D_list] = p_D\n            except np.linalg.LinAlgError:\n                p_iter[D_list] = x[D_list]\n\n        # Step 2b: Assume solvent banks pay in full\n        p_iter[A_list] = p_bar[A_list]\n\n        # Step 2c: Check for new defaults among currently solvent banks\n        newly_defaulting_indices = set()\n        for i in A_list:\n            if p_bar[i] > 0:\n                assets = x[i] + pi_T[i, :] @ p_iter\n                if assets  p_bar[i]:\n                    newly_defaulting_indices.add(i)\n        \n        D_indices.update(newly_defaulting_indices)\n\n        # Step 2d: Check for termination\n        if len(D_indices) == D_old_size:\n            return p_iter\n\n    raise RuntimeError(\"Algorithm failed to converge within n iterations.\")\n\ndef solve_and_format_output():\n    \"\"\"\n    Defines test cases, runs the solver, and formats the output.\n    \"\"\"\n    test_cases = [\n        {\n            \"L\": np.array([[0, 1, 0.5], [0.5, 0, 0.5], [0.2, 0.3, 0]]),\n            \"p_bar\": np.array([1.5, 1.0, 0.5]),\n            \"x\": np.array([2.0, 0.7, 0.6])\n        },\n        {\n            \"L\": np.array([[0, 0.9, 0], [0, 0, 0.9], [0.9, 0, 0]]),\n            \"p_bar\": np.array([1.5, 1.5, 1.5]),\n            \"x\": np.array([0.1, 0.1, 0.1])\n        },\n        {\n            \"L\": np.array([[0, 0], [0.4, 0]]),\n            \"p_bar\": np.array([0.0, 0.4]),\n            \"x\": np.array([0.0, 0.0])\n        },\n        {\n            \"L\": np.array([[0]]),\n            \"p_bar\": np.array([1.0]),\n            \"x\": np.array([0.3])\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        p = compute_clearing_vector(case['L'], case['p_bar'], case['x'])\n        # Round to avoid floating point representation issues, e.g., 0.25000000000000006\n        results.append(np.round(p, 8).tolist())\n\n    return \"[\" + \",\".join([str(res) for res in results]) + \"]\"\n\n# The answer is the output of this function call.\n# print(solve_and_format_output())\n\n```",
            "answer": "[[1.5, 1.0, 0.5],[0.25, 0.25, 0.25],[0.0, 0.0],[0.3]]"
        }
    ]
}