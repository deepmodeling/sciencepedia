{
    "hands_on_practices": [
        {
            "introduction": "我们从最简单但非平凡的例子开始：Erdős-Rényi (ER) 图上的 2-核。这个练习是掌握 k-核渗流理论的基石，它将引导你从第一性原理出发，推导出描述渗流过程的自洽方程。通过分析 2-核在临界点附近的连续相变行为，你将掌握平均场理论的核心数学技巧，并深入理解网络鲁棒性如何从微观规则中涌现。",
            "id": "4284889",
            "problem": "考虑 Erdős-Rényi 随机图 $G(n,p)$，其中 $p=c/n$，平均度 $c>0$。一个图的 $2$-核 (2-core) 是指一个最大的子图，其中每个顶点的度至少为 $2$。在 $n \\to \\infty$ 且 $c$ 固定的稀疏情况下，度分布渐近于均值为 $c$ 的泊松分布，并且图是局部树状的。\n\n定义 $S(c)$ 为 $2$-核中顶点的极限比例。仅使用以下基本要素：\n- 通过迭代移除叶节点来定义 $2$-核（重复删除度为 $1$ 的顶点及其关联的边，直到不存在此类顶点为止），\n- $G(n,c/n)$ 的局部树状性质，\n- 泊松度分布及其概率生成函数 $G_{0}(x)=\\exp(c(x-1))$，\n从第一性原理出发，推导出一个自洽描述，该描述是关于通过一条均匀随机选择的边到达的邻居在移除叶节点后仍保留在 $2$-核中的概率，并由此推导出 $S(c)$ 的表达式。\n\n然后，通过设置 $c=1+\\epsilon$（其中 $\\epsilon>0$ 为小量），并对您推导出的 $S(c)$ 表达式进行系统性的小 $\\epsilon$ 展开，分析在临界点 $c=1$ 附近 $2$-核的出现过程。证明该相变是连续的，并且\n$$\nS(c)\\sim B\\,(c-1)^{2}\n$$\n当 $\\epsilon=c-1\\downarrow 0^{+}$ 时成立，并从您推导的基于泊松分布的方程中确定系数 $B$ 的精确值。\n\n您的最终答案必须是 $B$ 的精确值。不需要四舍五入。",
            "solution": "我们从通过迭代移除叶节点来定义 $2$-核出发，并利用 $G(n,c/n)$ 的局部树状性质来建立一个自洽框架。令 $p_{d}$ 表示一个顶点度为 $d$ 的概率；在稀疏极限下的 Erdős-Rényi 模型 $G(n,c/n)$ 中，我们有泊松分布 $p_{d}=\\exp(-c)\\,c^{d}/d!$。概率生成函数为 $G_{0}(x)=\\sum_{d\\ge 0}p_{d}x^{d}=\\exp(c(x-1))$。\n\n引入量 $y(c)$，表示沿着一条均匀随机选择的边到达的顶点在移除叶节点后仍保留在 $2$-核中的概率。因为我们是沿着一条边走的，所以到达的顶点的度遵循大小偏倚分布 $\\frac{d\\,p_{d}}{c}$，并且在度为 $d$ 的条件下，其其他邻居的数量为 $d-1$。在 $2$-核中，一个顶点必须至少有两个幸存的邻居。当我们以沿着一条边到达一个邻居为条件时，该邻居可以将这条进入的边计入其幸存的邻居中，因此它需要其另外 $d-1$ 个邻居中至少有一个额外的幸存邻居才能保留在 $2$-核中。在局部树状的独立性假设下，这 $d-1$ 个邻居中的每一个都以概率 $y(c)$ 独立地保留下来。\n\n因此，在度为 $d$ 的条件下，到达的邻居保留在 $2$-核中的概率是 $1-(1-y)^{d-1}$，因为 $(1-y)^{d-1}$ 是其他 $d-1$ 个邻居均不保留的概率。对大小偏倚度分布进行平均，得到自洽方程\n$$\ny = \\sum_{d\\ge 1}\\frac{d\\,p_{d}}{c}\\,[1-(1-y)^{d-1}] = 1-\\sum_{d\\ge 1}\\frac{d\\,p_{d}}{c}\\,(1-y)^{d-1}.\n$$\n对于泊松分布，$\\frac{d\\,p_{d}}{c}=p_{d-1}$，因此求和可以简化为：\n$$\ny = 1 - \\sum_{m\\ge 0}p_{m}(1-y)^{m} = 1 - G_{0}(1-y).\n$$\n使用 $G_{0}(x)=\\exp(c(x-1))$，我们得到显式的定点方程\n$$\ny = 1 - \\exp(-c\\,y).\n$$\n\n接下来，我们表示 $2$-核中顶点的比例 $S(c)$。一个度为 $d$ 的顶点，如果其 $d$ 个邻居中至少有两个保留下来，那么它就保留在 $2$-核中。在独立性近似下，幸存邻居的数量服从二项分布 $\\text{Binomial}(d,y)$，因此存活概率为 $1-[(1-y)^{d}+d\\,y\\,(1-y)^{d-1}]$，其中减去的项是幸存邻居为 $0$ 或 $1$ 的情况。对 $p_{d}$ 进行平均得到\n$$\nS(c) = \\sum_{d\\ge 0}p_{d}\\Bigl[1-(1-y)^{d}-d\\,y\\,(1-y)^{d-1}\\Bigr] = 1 - \\sum_{d\\ge 0}p_{d}(1-y)^{d} - y\\sum_{d\\ge 0}d\\,p_{d}(1-y)^{d-1}.\n$$\n识别出生成函数求和的形式，\n$$\n\\sum_{d\\ge 0}p_{d}(1-y)^{d} = G_{0}(1-y) = \\exp(-c\\,y),\n$$\n以及\n$$\n\\sum_{d\\ge 0}d\\,p_{d}(1-y)^{d-1} = G_{0}'(1-y) = c\\,\\exp(c((1-y)-1)) = c\\,\\exp(-c\\,y),\n$$\n我们得到\n$$\nS(c) = 1 - \\exp(-c\\,y) - y\\,c\\,\\exp(-c\\,y).\n$$\n使用定点关系 $y=1-\\exp(-c\\,y)$，我们简化 $\\exp(-c\\,y)=1-y$，因此\n$$\nS(c) = 1 - (1-y) - y\\,c\\,(1-y) = y[1 - c + c\\,y] = y[c\\,y - (c-1)].\n$$\n\n为了分析临界点 $c=1$ 附近的行为，设 $c=1+\\epsilon$，其中 $\\epsilon>0$ 为小量。$y$ 的定点方程变为\n$$\ny = 1 - \\exp(-(1+\\epsilon)\\,y).\n$$\n对小量 $y$ 和 $\\epsilon$ 展开指数函数，\n$$\n\\exp(-(1+\\epsilon)\\,y) = 1 - (1+\\epsilon)\\,y + \\tfrac{1}{2}(1+\\epsilon)^{2}y^{2} - \\tfrac{1}{6}(1+\\epsilon)^{3}y^{3} + \\cdots,\n$$\n所以\n$$\ny = (1+\\epsilon)\\,y - \\tfrac{1}{2}(1+\\epsilon)^{2}y^{2} + \\tfrac{1}{6}(1+\\epsilon)^{3}y^{3} - \\cdots.\n$$\n整理得，\n$$\n-\\epsilon\\,y + \\tfrac{1}{2}(1+\\epsilon)^{2}y^{2} - \\tfrac{1}{6}(1+\\epsilon)^{3}y^{3} + \\cdots = 0.\n$$\n对于小的 $\\epsilon$，非平凡解具有 $y=O(\\epsilon)$ 的形式。保持线性和二次项之间的主导平衡，得到\n$$\n\\epsilon\\,y \\approx \\tfrac{1}{2}(1+\\epsilon)^{2}y^{2},\n$$\n因此\n$$\ny \\approx \\frac{2\\,\\epsilon}{(1+\\epsilon)^{2}} = 2\\,\\epsilon - 4\\,\\epsilon^{2} + O(\\epsilon^{3}).\n$$\n将 $c=1+\\epsilon$ 和这个展开式代入 $S(c)=y[c\\,y-(c-1)]$，\n$$\nS(c) = y((1+\\epsilon)\\,y - \\epsilon) = y(y + \\epsilon\\,y - \\epsilon).\n$$\n使用 $y \\approx 2\\epsilon$ 的一阶近似，我们得到\n$$\nS(c) \\approx (2\\epsilon)((2\\epsilon) + \\epsilon(2\\epsilon) - \\epsilon) = (2\\epsilon)(\\epsilon + 2\\epsilon^2) \\approx 2\\epsilon^2.\n$$\n因此，当 $\\epsilon=c-1\\downarrow 0^{+}$ 时，\n$$\nS(c) \\sim B\\,(c-1)^{2}\n$$\n其中\n$$\nB = 2.\n$$\n这证实了 $2$-核在 $c=1$ 处连续出现，具有二次标度行为，并从基于泊松分布的自洽方程中确定了系数。",
            "answer": "$$\\boxed{2}$$"
        },
        {
            "introduction": "在掌握了 2-核的连续相变之后，我们将探索 k-核渗流更令人惊讶的特性。当 $k \\ge 3$ 时，相变的性质会发生根本性的改变，从连续转变为一种兼具连续和不连续特征的“混合”相变。这个练习将引导你分析 $k=3$ 的情况，你不仅需要推导出描述这种不连续跃迁的临界条件，还需要结合数值方法来精确定位临界点和核尺寸的突变大小。",
            "id": "4284918",
            "problem": "考虑一个 Erdős-Rényi (ER) 随机图，该图定义在 $n$ 个已标记的顶点上，其中每对顶点之间独立地以概率 $p$ 连接一条边，使得在稀疏极限下，平均度 $c$ 等于 $c = p(n-1)$。一个图的 $k$-核（$k$-core）是指一个最大子图，其中每个顶点的度都至少为 $k$。对于大尺寸极限下的ER随机图，已知当 $k \\geq 3$ 时，巨型 $k$-核的出现是一个混合（不连续且具有临界奇异性）相变，发生在某个阈值平均度 $c^\\star$ 处。\n\n仅从ER图的基本事实（稀疏极限下平均度为 $c$ 的泊松度分布和边的独立性）以及 $k$-核作为迭代修剪（不断移除度小于 $k$ 的顶点，直到所有剩余顶点的度都至少为 $k$）过程的不动点的定义出发，推导随机跟随一条半边所到达的顶点在修剪后的图中仍然存在的存活概率 $x$ 所满足的自洽条件，并推导出非零不动点 $x^\\star$ 通过不动点方程的二重根形式出现的涌现阈值所对应的条件。\n\n对于 $k = 3$ 的具体情况，您必须：\n- 使用ER图的假设和迭代修剪方法，得到不动点函数 $f(x; c)$，使得 $k$-核对应于 $f(x; c) = 0$ 的解。\n- 通过在非零 $x^\\star$ 处的二重根（相切）条件 $f(x; c) = 0$ 和 $\\frac{\\partial}{\\partial x} f(x; c) = 0$ 来刻画该阈值，并将这些条件简化为一个可以用数值方法求解的、关于某个辅助变量的单一标量方程。\n- 数值计算：\n  1. $k=3$ 时，阈值处的非零解 $x^\\star$。\n  2. 阈值平均度 $c^\\star$。\n  3. 阈值处 $3$-核中顶点的相应比例 $S^\\star$，以小数（而非百分比）表示。使用标准的计数论证，即修剪后图中剩余度小于 $k$ 的顶点比例是均值为 $cx$ 的泊松随机变量直至 $k-1$ 的累积概率。\n\n您的程序必须从第一性原理出发，实现一个稳健的数值求解器，并产生以下测试套件输出：\n- 测试用例1（正常路径）：使用括号区间 $[1.0, 3.0]$ 计算求解由二重根条件导出的简化标量方程的辅助变量。\n- 测试用例2：根据测试用例1中获得的辅助变量计算 $x^\\star$。\n- 测试用例3：根据辅助变量和 $x^\\star$ 计算 $c^\\star$。\n- 测试用例4：使用 $x^\\star$ 和 $c^\\star$，通过适用于 $k=3$ 的泊松累积表达式计算 $S^\\star$。\n- 测试用例5（边界条件验证）：通过在 $10^{-12}$ 的容差范围内检查 $f(x^\\star; c^\\star) = 0$ 和 $\\frac{\\partial}{\\partial x} f(x^\\star; c^\\star) = 0$ 是否成立，并验证二阶导数 $\\frac{\\partial^2}{\\partial x^2} f(x^\\star; c^\\star)$ 是否为严格正数，来验证解处的二重根条件。输出一个布尔值，指示是否所有检查都通过。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序完全如下：$[y^\\star, x^\\star, c^\\star, S^\\star, \\text{boolean}]$，其中 $y^\\star$ 是您在推导中引入的辅助变量。不涉及单位；$S^\\star$ 以小数表示。",
            "solution": "确定埃尔德什-雷尼（ER）随机图中巨型 $k$-核的出现是一个网络科学中的经典问题。我们的任务是针对 $3$-核（$k=3$）的特定情况推导这一相变的条件，并计算临界参数。推导将从第一性原理出发，即ER图在大尺寸、稀疏极限下的性质。\n\n在此极限下，一个具有 $n$ 个顶点和平均度 $c$ 的ER图表现出两个关键特性：\n$1$。顶点的度分布遵循平均值为 $c$ 的泊松分布：$P(d) = e^{-c} \\frac{c^d}{d!}$。\n$2$。不同顶点的度是不相关的，且图的结构是局部树状的。\n\n$k$-核是通过迭代修剪所有度小于 $k$ 的顶点来找到的。一个顶点的存活取决于其邻居的存活。这表明可以采用自洽或平均场方法。设 $x$ 为跟随一条随机边到达的顶点属于 $k$-核的概率。这是*邻居*顶点的存活概率。$x$ 的非零值表示存在一个宏观（巨型）的 $k$-核。\n\n考虑一个通过跟随随机边到达的顶点 $v$。由于是随机选择边，顶点 $v$ 的度分布不同于随机顶点的标准泊松分布。通过跟随随机边选择一个度为 $d$ 的顶点的概率与 $d P(d)$ 成正比。其*剩余度* $d-1$（即顶点 $v$ 的其他边的数量）的分布则由 $\\frac{d P(d)}{\\langle d \\rangle} = \\frac{d e^{-c} c^d/d!}{c} = e^{-c} \\frac{c^{d-1}}{(d-1)!}$ 给出。这是一个平均值为 $c$ 的泊松分布。\n\n我们来为修剪过程建模。顶点 $v$ 的 $d-1$ 个“其他”邻居中的每一个都以概率 $x$ 独立地在修剪过程中存活下来。因为这些邻居数量的初始分布是平均值为 $c$ 的泊松分布，所以*存活*邻居的数量遵循一个“稀疏化”的泊松分布，其平均值为 $c x$。\n为了让顶点 $v$ 自身存活并成为 $k$-核的一部分，它在最终修剪后的图中的度必须至少为 $k$。我们是通过一条边（我们假设这条边连接到图的存活部分）到达 $v$ 的，因此 $v$ 必须有至少 $k-1$ 个其他也存活下来的邻居。\n\n这导出了关于 $x$ 的自洽方程。顶点 $v$ 存活的概率 $x$ 是一个平均值为 $c x$ 的泊松随机变量 $Z$ 取值至少为 $k-1$ 的概率：\n$$x = P(Z \\ge k-1) = \\sum_{j=k-1}^{\\infty} e^{-cx} \\frac{(cx)^j}{j!} = 1 - \\sum_{j=0}^{k-2} e^{-cx} \\frac{(cx)^j}{j!}$$\n这个方程总有一个平凡解 $x=0$，对应于不存在巨型 $k$-核的情况。一个非平凡解 $x > 0$ 在一个临界阈值 $c^\\star$ 处出现。\n\n对于 $k=3$ 的特定情况，自洽方程为：\n$$x = 1 - \\sum_{j=0}^{1} e^{-cx} \\frac{(cx)^j}{j!} = 1 - \\left( e^{-cx} \\frac{(cx)^0}{0!} + e^{-cx} \\frac{(cx)^1}{1!} \\right)$$\n$$x = 1 - e^{-cx}(1+cx)$$\n我们定义一个不动点函数 $f(x; c)$，它的根即为 $x$ 的解：\n$$f(x; c) = x - 1 + e^{-cx}(1+cx) = 0$$\n对于 $k \\ge 3$，非平凡解的出现是一个不连续相变，其特征是鞍-节分岔。这发生在直线 $y=x$ 与曲线 $g(x) = 1 - e^{-cx}(1+cx)$ 相切时。这个相切点 $(x^\\star, c^\\star)$ 是方程 $f(x;c)=0$ 的一个二重根，并且对于 $x^\\star > 0$ 必须同时满足两个条件：\n$1$. $f(x^\\star; c^\\star) = 0$\n$2$. $\\frac{\\partial f}{\\partial x}(x^\\star; c^\\star) = 0$\n\n我们来计算关于 $x$ 的偏导数：\n$$\\frac{\\partial f}{\\partial x} = \\frac{\\partial}{\\partial x} \\left( x - 1 + e^{-cx}(1+cx) \\right) = 1 + [(-c)e^{-cx}(1+cx) + e^{-cx}(c)]$$\n$$\\frac{\\partial f}{\\partial x} = 1 -ce^{-cx} - c^2x e^{-cx} + ce^{-cx} = 1 - c^2x e^{-cx}$$\n在临界点 $(x^\\star, c^\\star)$ 处的两个条件是：\n$1$. $x^\\star - 1 + e^{-c^\\star x^\\star}(1+c^\\star x^\\star) = 0$\n$2$. $1 - (c^\\star)^2 x^\\star e^{-c^\\star x^\\star} = 0$\n\n为了求解这个方程组，我们引入一个辅助变量 $y = cx$。在阈值处，令 $y^\\star = c^\\star x^\\star$。\n根据条件（2）：\n$$1 = (c^\\star)^2 x^\\star e^{-c^\\star x^\\star} = c^\\star (c^\\star x^\\star) e^{-c^\\star x^\\star} = c^\\star y^\\star e^{-y^\\star}$$\n这给出了 $c^\\star$ 的表达式：\n$$c^\\star = \\frac{e^{y^\\star}}{y^\\star}$$\n根据条件（1）：\n$$1 - x^\\star = e^{-c^\\star x^\\star}(1+c^\\star x^\\star) = e^{-y^\\star}(1+y^\\star)$$\n我们需要一个用 $y^\\star$ 表示 $x^\\star$ 的表达式。使用 $x^\\star = y^\\star/c^\\star$ 和 $c^\\star$ 的表达式：\n$$x^\\star = \\frac{y^\\star}{e^{y^\\star}/y^\\star} = (y^\\star)^2 e^{-y^\\star}$$\n将此代入重新整理的条件（1）中：\n$$1 - (y^\\star)^2 e^{-y^\\star} = e^{-y^\\star}(1+y^\\star)$$\n乘以 $e^{y^\\star}$ (因为 $y^\\star > 0$, $e^{y^\\star} \\neq 0$)：\n$$e^{y^\\star} - (y^\\star)^2 = 1+y^\\star$$\n整理后得到一个关于 $y^\\star$ 的单一标量方程：\n$$e^{y^\\star} - (y^\\star)^2 - y^\\star - 1 = 0$$\n这个方程可以通过数值方法求解 $y^\\star > 0$。问题指定了一个括号区间 $[1.0, 3.0]$。\n\n一旦找到 $y^\\star$，我们就可以计算其他的临界量：\n-   $x^\\star = (y^\\star)^2 e^{-y^\\star}$\n-   $c^\\star = e^{y^\\star} / y^\\star$\n\n最后，我们计算 $S^\\star$，即阈值处 $3$-核中的顶点比例。一个随机选择的顶点能够存活，条件是它在修剪后的图中的度至少为 $k=3$。在一个随机顶点的每个邻居都以概率 $x^\\star$ 独立存活后，该顶点的度遵循一个平均值为 $c^\\star x^\\star = y^\\star$ 的泊松分布。因此，$S^\\star$ 是一个泊松变量 $Z \\sim \\text{Poisson}(y^\\star)$ 至少为 $3$ 的概率：\n$$S^\\star = P(Z \\ge 3) = 1 - P(Z \\le 2) = 1 - \\sum_{j=0}^{2} e^{-y^\\star} \\frac{(y^\\star)^j}{j!}$$\n$$S^\\star = 1 - e^{-y^\\star} \\left( 1 + y^\\star + \\frac{(y^\\star)^2}{2} \\right)$$\n为了使相变成为一个对应于不连续跳跃的真正的鞍-节分岔，函数 $f(x;c)$ 在临界点的二阶导数必须非零。\n$$\\frac{\\partial^2 f}{\\partial x^2} = \\frac{\\partial}{\\partial x} (1 - c^2x e^{-cx}) = -c^2 [e^{-cx} + x(-c)e^{-cx}] = -c^2 e^{-cx}(1-cx)$$\n在阈值处，这变为：\n$$\\frac{\\partial^2 f}{\\partial x^2}(x^\\star, c^\\star) = -(c^\\star)^2 e^{-y^\\star}(1-y^\\star)$$\n对于一个从 $x=0$ 开始的、有物理意义的不连续相变，我们要求这个二阶导数为正，这意味着 $1-y^\\star  0$，即 $y^\\star  1$。数值解必须满足这一点。\n\n数值实现将求解 $y^\\star$，然后使用这些推导出的公式计算 $x^\\star$、$c^\\star$ 和 $S^\\star$，最后验证二重根条件和二阶导数的符号。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import brentq\n\ndef solve():\n    \"\"\"\n    Derives and computes the critical parameters for 3-core percolation on an ER graph.\n\n    The problem is solved by first deriving the self-consistency equations for the\n    survival probability of a node in the k-core. For k=3, this leads to a system\n    of two equations for the critical threshold (x*, c*), based on the double-root\n    condition for the emergence of a non-trivial solution.\n\n    f(x; c) = x - 1 + exp(-c*x)*(1 + c*x) = 0\n    df/dx(x; c) = 1 - c**2 * x * exp(-c*x) = 0\n\n    By introducing an auxiliary variable y = c*x, this system is reduced to a\n    single scalar equation for y:\n    g(y) = exp(y) - y**2 - y - 1 = 0\n\n    This script solves for y*, then computes x*, c*, and the 3-core size S* at the\n    threshold. Finally, it verifies that the computed values satisfy the original\n    double-root conditions.\n    \"\"\"\n\n    # --- Test Case 1: Compute the auxiliary variable y* ---\n    # Define the scalar function g(y) = 0 to be solved.\n    def g(y):\n        return np.exp(y) - y**2 - y - 1\n\n    # Solve for y* in the given interval [1.0, 3.0].\n    # There is also a root at y=0 which we are not interested in.\n    try:\n        y_star = brentq(g, 1.0, 3.0, xtol=1e-15, rtol=1e-15)\n    except ValueError:\n        # Handle cases where brentq might fail, although it shouldn't for this function and interval.\n        y_star = None\n    \n    if y_star is None:\n        raise RuntimeError(\"Failed to find root for the auxiliary variable y.\")\n\n    # --- Test Case 2: Compute x* ---\n    # The survival probability x* is given by x* = (y*)**2 * exp(-y*).\n    x_star = y_star**2 * np.exp(-y_star)\n\n    # --- Test Case 3: Compute c* ---\n    # The critical mean degree c* is given by c* = exp(y*) / y*.\n    c_star = np.exp(y_star) / y_star\n\n    # --- Test Case 4: Compute S* ---\n    # The fraction of vertices in the 3-core S* is P(Z = 3) where Z ~ Poisson(y*).\n    # S* = 1 - exp(-y*) * (1 + y* + (y*)**2 / 2).\n    s_star = 1.0 - np.exp(-y_star) * (1.0 + y_star + y_star**2 / 2.0)\n    \n    # --- Test Case 5: Verify double-root conditions ---\n    tolerance = 1e-12\n    all_checks_passed = False\n\n    # Check 1: f(x*, c*) = 0\n    # f_val = x* - 1 + exp(-c*x)*(1 + c*x) = x* - 1 + exp(-y*)*(1 + y*)\n    f_val = x_star - 1.0 + np.exp(-y_star) * (1.0 + y_star)\n    check1 = abs(f_val)  tolerance\n\n    # Check 2: df/dx(x*, c*) = 0\n    # dfdx_val = 1 - c*^2 * x* * exp(-c*x) = 1 - c* * y* * exp(-y*)\n    # Since c* = exp(y*)/y*, this simplifies to 1 - (exp(y*)/y*) * y* * exp(-y*) = 1 - 1 = 0\n    # We use a numerical check to account for floating point inaccuracies.\n    dfdx_val = 1.0 - c_star**2 * x_star * np.exp(-y_star)\n    check2 = abs(dfdx_val)  tolerance\n\n    # Check 3: d^2f/dx^2(x*,c*) > 0\n    # d2fdx2 = -c*^2 * exp(-y*) * (1-y*)\n    d2fdx2_val = -(c_star**2) * np.exp(-y_star) * (1.0 - y_star)\n    check3 = d2fdx2_val > 0\n\n    all_checks_passed = bool(check1 and check2 and check3)\n    \n    # Assemble the final results\n    results = [y_star, x_star, c_star, s_star, all_checks_passed]\n    \n    # Final print statement in the exact required format.\n    # The format specifier ensures high precision to match the calculations.\n    # Note: A simple `str()` conversion might not provide enough precision.\n    print(f\"[{results[0]:.15f},{results[1]:.15f},{results[2]:.15f},{results[3]:.15f},{str(results[4]).lower()}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "理论模型为我们理解网络结构提供了强大的框架，但如何将其应用于真实数据呢？这个练习旨在搭建从理论到实践的桥梁。你将学习一项网络科学中的基本任务：检验一个观测到的网络属性（此处为 k-核大小）是否具有统计显著性，或者它仅仅是节点度分布的简单产物。通过实现一个保留度序列的零模型并进行统计检验，你将掌握评估真实网络中结构冗余性的重要实证方法。",
            "id": "4284882",
            "problem": "考虑一个由图 $G = (V, E)$ 表示的简单无向网络，其包含 $|V| = n$ 个节点和 $|E| = m$ 条边。度序列是度列表 $\\{d_1, d_2, \\dots, d_n\\}$，其中 $d_i$ 是节点 $i$ 的度。图的 $k$-核是一个最大诱导子图，其中每个节点的度至少为 $k$。它是通过递归地修剪度严格小于 $k$ 的节点，直到无法再进行修剪为止而得到的。$k$-核的大小，记为 $|V_k(G)|$，是此修剪过程后剩余的节点数。\n\n您的任务是设计一个程序，该程序在一个度保持的零模型下执行经验推断，以检验 $k$-核的结构增强性。零模型必须精确地保持经验度序列，并通过在简单图（无自环和无多重边）上重复应用度保持的双边交换来随机化网络。一次双边交换选择两条不同的边 $(a,b)$ 和 $(c,d)$，其四个端点 $\\{a,b,c,d\\}$ 互不相同，并将它们替换为 $(a,c)$ 和 $(b,d)$ 或 $(a,d)$ 和 $(b,c)$，前提是生成的图仍然是简单的。双边交换必须成功重复固定的次数，以引发充分的随机化。对于每个随机化样本，计算其 $k$-核大小 $|V_k(\\cdot)|$。\n\n结构增强的统计检验应按以下步骤进行。设 $X_{\\text{obs}}$ 表示经验图 $G$ 的观测 $k$-核大小。通过执行 $R$ 次独立的随机化生成一个零模型系综，每次随机化都从 $G$ 开始并应用 $S$ 次成功的双边交换。设 $\\{X_1, X_2, \\dots, X_R\\}$ 是从随机化系综中得到的 $k$-核大小。使用这些样本计算一个标准化检验统计量，以比较 $X_{\\text{obs}}$ 与零期望。使用固定的阈值 $z^{\\ast} = 2$ 进行决策。如果标准化检验统计量表明观测到的 $k$-核大小显著大于零期望（超过阈值），则将该情况分类为结构增强；否则，不将其分类为增强。在零模型系综的经验方差为零的情况下，将标准化检验统计量定义为 $0$，并且不分类为增强。\n\n您的程序必须实现：\n- 一个使用递归修剪定义计算 $k$-核大小 $|V_k(G)|$ 的过程。\n- 一个通过双边交换生成 $G$ 的度保持随机化样本的过程，确保图始终保持简单。\n- 一个计算零期望和标准化检验统计量，并使用阈值 $z^{\\ast} = 2$ 做出增强决策的过程。\n\n使用以下测试套件。每个测试用例通过节点数 $n$、边集 $E$、核参数 $k$、随机化次数 $R$、每次随机化成功的交换次数 $S$ 以及用于可复现性的随机种子 $s$ 来指定图。节点由从 $0$ 到 $n-1$ 的整数标记。所有数字必须作为整数处理。\n\n测试用例 1（带外围的密集核心）：\n- $n = 12$\n- $E$ 由节点 $\\{0,1,2,3,4,5\\}$ 之间形成一个团的所有对，加上每个外围节点 $\\{6,7,8,9,10,11\\}$ 到该团的两条边组成：\n  - 团的边：$\\{(0,1),(0,2),(0,3),(0,4),(0,5),(1,2),(1,3),(1,4),(1,5),(2,3),(2,4),(2,5),(3,4),(3,5),(4,5)\\}$\n  - 外围连接：$(6,0),(6,1),(7,2),(7,3),(8,4),(8,5),(9,0),(9,2),(10,1),(10,4),(11,3),(11,5)$\n- $k = 5$\n- $R = 200$\n- $S = 270$\n- $s = 12345$\n\n测试用例 2（近正则的类随机图）：\n- $n = 12$\n- $E = \\{(0,1),(0,2),(0,3),(0,4),(1,2),(1,5),(1,6),(2,3),(2,7),(3,4),(3,8),(4,5),(4,9),(5,6),(5,10),(6,7),(6,11),(7,8),(7,9),(8,9),(8,10),(9,10),(10,11),(11,0),(11,3)\\}$\n- $k = 4$\n- $R = 200$\n- $S = 250$\n- $s = 2021$\n\n测试用例 3（星形图边界情况）：\n- $n = 12$\n- $E = \\{(0,1),(0,2),(0,3),(0,4),(0,5),(0,6),(0,7),(0,8),(0,9),(0,10),(0,11)\\}$\n- $k = 5$\n- $R = 100$\n- $S = 100$\n- $s = 7$\n\n对于每个测试用例，您的程序必须生成一个形式为 $[\\mu, X_{\\text{obs}}, Z, \\text{reinforced}]$ 的列表，其中：\n- $\\mu$ 是 $\\{X_1,\\dots,X_R\\}$ 的样本均值，表示为浮点数，\n- $X_{\\text{obs}}$ 是经验 $k$-核大小，表示为整数，\n- $Z$ 是标准化检验统计量，表示为浮点数，\n- $\\text{reinforced}$ 是一个布尔值，指示标准化检验统计量是否超过阈值 $z^{\\ast} = 2$。\n\n最终输出格式：您的程序应生成一行输出，其中包含所有测试用例的结果，形式为一个逗号分隔的列表，并用方括号括起来。列表中的每个项目本身也是按上述顺序排列的列表。例如，输出应类似于 $[[\\mu_1,X_{\\text{obs},1},Z_1,\\text{reinforced}_1],[\\mu_2,X_{\\text{obs},2},Z_2,\\text{reinforced}_2],[\\mu_3,X_{\\text{obs},3},Z_3,\\text{reinforced}_3]]$。此问题不涉及任何物理单位、角度单位或百分比，因此不应提供这些内容。",
            "solution": "该问题是有效的。它提出了网络科学领域中一个定义明确的任务，该任务具有科学依据、客观且内部一致。\n\n### 步骤 1：提取给定信息\n\n- **图表示**：一个简单无向图 $G = (V, E)$，有 $n = |V|$ 个节点和 $m = |E|$ 条边。\n- **节点标签**：从 $0$ 到 $n-1$ 的整数。\n- **$k$-核定义**：每个节点的度至少为 $k$ 的最大诱导子图。它是通过递归地修剪度严格小于 $k$ 的节点得到的。\n- **$k$-核大小**：$|V_k(G)|$，即 $k$-核中的节点数。\n- **任务**：使用一个度保持的零模型，对 $k$-核的结构增强性进行经验推断。\n- **零模型**：通过使用固定数量的成功的度保持双边交换来随机化经验图 $G$ 而生成。图必须保持简单（无自环、无多重边）。\n- **双边交换**：选择两条不同的边 $(a,b)$ 和 $(c,d)$，其四个端点 $\\{a,b,c,d\\}$ 互不相同。将它们替换为 $(a,c)$ 和 $(b,d)$ 或 $(a,d)$ 和 $(b,c)$，前提是生成的图仍然是简单的。\n- **随机化过程**：对于 $R$ 次独立随机化中的每一次，都从经验图 $G$ 开始，并应用 $S$ 次成功的双边交换。\n- **统计检验**：\n    - $X_{\\text{obs}}$：经验图 $G$ 的观测 $k$-核大小。\n    - $\\{X_1, X_2, \\dots, X_R\\}$：来自 $R$ 个随机化图的一组 $k$-核大小。\n    - 零模型系综的样本均值：$\\mu = \\frac{1}{R} \\sum_{i=1}^{R} X_i$。\n    - 零模型系综的样本标准差：$\\sigma = \\sqrt{\\frac{1}{R} \\sum_{i=1}^{R} (X_i - \\mu)^2}$。\n    - 标准化检验统计量：$Z = \\frac{X_{\\text{obs}} - \\mu}{\\sigma}$。\n    - 特殊条件：如果 $\\sigma = 0$，则 $Z = 0$。\n- **决策规则**：\n    - 阈值：$z^{\\ast} = 2$。\n    - 分类：如果 $Z  z^{\\ast}$，则图是“结构增强的”。否则，不是。\n- **测试用例**：提供了三个测试用例，每个都带有图结构 ($n, E$)、核分析 ($k$)、随机化 ($R, S$) 和可复现性 ($s$) 的参数。\n- **输出格式**：对于每个测试用例，输出一个列表 $[\\mu, X_{\\text{obs}}, Z, \\text{reinforced}]$。最终程序输出是这些列表的列表。\n\n### 步骤 2：使用提取的给定信息进行验证\n\n- **科学依据**：$k$-核、通过双边交换（也称为配置模型切换算法）进行的度保持随机化以及零模型假设检验等概念，是网络科学和复杂系统理论中的基本和标准方法论。整个过程在科学上是有效的。\n- **适定性**：问题被精确地规定。所有必要的输入 ($n, E, k, R, S, s$)、算法（用于$k$-核的修剪，双边交换）和统计过程（$Z$的计算，对$\\sigma=0$的处理，决策阈值）都已明确定义。这确保了对于给定的随机种子，每个测试用例都存在一个唯一的、稳定的、有意义的计算结果。\n- **客观性**：问题以正式、无偏见的语言陈述。所有分析和决策的标准都是定量的和明确的（例如，$Z  2$）。\n\n该问题没有以下任何无效性缺陷：\n1.  **科学/事实不健全**：没有违反科学或数学原理。\n2.  **不可形式化/不相关**：该问题是一个可形式化的算法任务，与 $k$-核渗流的主题直接相关。\n3.  **不完整/矛盾的设置**：提供了所有必需的数据和条件，并且它们是一致的。\n4.  **不切实际/不可行**：测试用例的参数（$n=12$，中等的 $R, S$）在计算上是可行的。图结构是有效的。\n5.  **不适定/结构不良**：问题结构良好，对于给定的种子会产生确定性的结果。\n6.  **伪深刻/琐碎**：该任务需要实现和集成几个非琐碎的算法，使其成为一个实质性的问题。测试用例经过精心选择，以探究实现的不同方面，包括边界条件（星形图）。\n7.  **超出科学可验证性**：给定指定的随机种子，结果是可计算复现和验证的。\n\n### 步骤 3：结论与行动\n\n问题陈述是**有效的**。将根据要求开发和实现一个解决方案。\n\n### 算法设计与原则\n\n解决方案被构造成一系列过程，这些过程对应于问题陈述的主要组成部分。\n\n1.  **`k_core_size(adj, k)`**：此函数计算给定图（由邻接表 `adj` 表示）和整数 $k$ 的 $k$-核大小。它实现了指定的递归修剪算法。\n    - **原则**：$k$-核是通过迭代移除度小于 $k$ 的节点来找到的。这个过程必须持续到没有这样的节点存在为止，因为移除一个节点会减少其邻居的度，可能导致它们在后续步骤中被修剪。\n    - **实现**：我们首先计算所有节点的初始度。用所有度小于 $k$ 的节点初始化一个队列。然后我们处理这个队列，一次移除一个节点。对于每个被移除的节点，我们遍历其邻居，将它们的度减一。如果一个邻居的度降到 $k$ 以下，就将其添加到队列中以便稍后修剪。我们跟踪被移除的节点以避免重复处理，并计算最终的核大小，即 $n$ 减去被移除的唯一节点总数。\n\n2.  **`perform_randomization(adj, num_swaps, rng)`**：此函数接受一个图、一个目标成功交换次数 $S$ 和一个随机数生成器。它返回一个具有相同度序列的新图。\n    - **原则**：双边交换是生成具有固定度序列的随机图的基本操作。它在局部重新布线网络，同时保持每个相关节点的度。重复应用可以充分随机化网络结构，打破那些并非由度序列本身引起的关联。\n    - **实现**：制作输入图邻接表的副本。创建一个包含所有唯一边的列表。主循环一直运行，直到执行了 $S$ 次成功的交换。在每次尝试中，随机选择两条不同的边 $(a,b)$ 和 $(c,d)$。我们验证四个端点是否不同。然后我们检查两个可能的新边对 $(a,c)$ 和 $(b,d)$ 或 $(a,d)$ 和 $(b,c)$ 的有效性。如果新边对不会引入多重边（即新边尚不存在），则该新边对是有效的。如果至少存在一种有效的重新布线方式，就选择一种，更新邻接表和边列表，并增加成功交换计数器。为了防止在无法进行交换的图（例如星形图）中出现无限循环，我们加入了对总尝试次数的限制。\n\n3.  **`solve()`**：这是主驱动函数，为所有测试用例协调整个分析过程。\n    - **原则**：任务的核心是将一个观测度量（$X_{\\text{obs}}$）与从一个随机图系综生成的该度量的零分布进行统计比较。Z-分数量化了观测值与零模型均值相差多少个标准差，提供了一个标准化的结构意外性度量。\n    - **实现**：该函数遍历每个测试用例。对于每个用例，它使用给定的种子初始化一个随机数生成器以保证可复现性。它构建图并计算观测的 $k$-核大小 $X_{\\text{obs}}$。然后，它进入一个循环以生成 $R$ 个随机化图。在每次迭代中，它对原始图的一个新副本调用 `perform_randomization`，并计算结果随机图的 $k$-核大小，将其添加到一个零值列表中。生成零模型系综后，它计算均值 $\\mu$ 和标准差 $\\sigma$。Z-分数计算为 $(X_{\\text{obs}} - \\mu) / \\sigma$，并有特定检查，如果 $\\sigma=0$ 则设置 $Z=0$。最后，根据 $Z  2$ 做出增强决策。将结果 $[\\mu, X_{\\text{obs}}, Z, \\text{reinforced}]$ 收集并格式化为所需的最终输出字符串。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef k_core_size(adj, k):\n    \"\"\"\n    Computes the size of the k-core of a graph using recursive pruning.\n    \n    Args:\n        adj (list of set): The adjacency list of the graph.\n        k (int): The core parameter.\n        \n    Returns:\n        int: The number of nodes in the k-core.\n    \"\"\"\n    n = len(adj)\n    degrees = np.array([len(neighbors) for neighbors in adj])\n    \n    # Queue for nodes to be pruned\n    prune_queue = [i for i, d in enumerate(degrees) if d  k]\n    head = 0\n    \n    is_pruned = np.zeros(n, dtype=bool)\n    num_pruned = 0\n    \n    while head  len(prune_queue):\n        u = prune_queue[head]\n        head += 1\n        \n        if is_pruned[u]:\n            continue\n            \n        is_pruned[u] = True\n        num_pruned += 1\n        \n        for v in adj[u]:\n            if not is_pruned[v]:\n                degrees[v] -= 1\n                if degrees[v]  k:\n                    prune_queue.append(v)\n                    \n    return n - num_pruned\n\ndef perform_randomization(adj, num_swaps, rng):\n    \"\"\"\n    Generates a degree-preserving randomized graph via double-edge swaps.\n    \n    Args:\n        adj (list of set): The adjacency list of the original graph.\n        num_swaps (int): The number of successful swaps to perform.\n        rng (np.random.Generator): The random number generator.\n        \n    Returns:\n        list of set: The adjacency list of the randomized graph.\n    \"\"\"\n    n = len(adj)\n    rand_adj = [s.copy() for s in adj]\n    \n    edges = []\n    for u in range(n):\n        for v in rand_adj[u]:\n            if u  v:\n                edges.append((u, v))\n                \n    num_edges = len(edges)\n    if num_edges  2:\n        return rand_adj\n\n    successful_swaps = 0\n    # Add a safety break for non-randomizable graphs\n    max_attempts = 100 * num_swaps if num_swaps > 0 else 1\n    attempts = 0\n\n    while successful_swaps  num_swaps and attempts  max_attempts:\n        attempts += 1\n        \n        if num_edges  2:\n            break\n\n        idx1, idx2 = rng.choice(num_edges, 2, replace=False)\n        e1, e2 = edges[idx1], edges[idx2]\n        a, b = e1\n        c, d = e2\n        \n        if len({a, b, c, d}) != 4:\n            continue\n            \n        # Rewiring option 1: (a,d) and (b,c)\n        valid1 = (d not in rand_adj[a]) and (c not in rand_adj[b])\n        # Rewiring option 2: (a,c) and (b,d)\n        valid2 = (c not in rand_adj[a]) and (d not in rand_adj[b])\n        \n        chosen_rewiring = None\n        if valid1 and valid2:\n            chosen_rewiring = 1 if rng.random()  0.5 else 2\n        elif valid1:\n            chosen_rewiring = 1\n        elif valid2:\n            chosen_rewiring = 2\n        \n        if chosen_rewiring:\n            # Remove old edges\n            rand_adj[a].remove(b); rand_adj[b].remove(a)\n            rand_adj[c].remove(d); rand_adj[d].remove(c)\n            \n            if chosen_rewiring == 1: # (a,d) and (b,c)\n                rand_adj[a].add(d); rand_adj[d].add(a)\n                rand_adj[b].add(c); rand_adj[c].add(b)\n                edges[idx1] = tuple(sorted((a,d)))\n                edges[idx2] = tuple(sorted((b,c)))\n            else: # chosen_rewiring == 2, (a,c) and (b,d)\n                rand_adj[a].add(c); rand_adj[c].add(a)\n                rand_adj[b].add(d); rand_adj[d].add(b)\n                edges[idx1] = tuple(sorted((a,c)))\n                edges[idx2] = tuple(sorted((b,d)))\n\n            successful_swaps += 1\n            \n    return rand_adj\n\ndef solve():\n    test_cases = [\n        {\n            \"n\": 12,\n            \"E\": [\n                (0,1),(0,2),(0,3),(0,4),(0,5),(1,2),(1,3),(1,4),(1,5),\n                (2,3),(2,4),(2,5),(3,4),(3,5),(4,5),\n                (6,0),(6,1),(7,2),(7,3),(8,4),(8,5),(9,0),(9,2),\n                (10,1),(10,4),(11,3),(11,5)\n            ],\n            \"k\": 5, \"R\": 200, \"S\": 270, \"s\": 12345\n        },\n        {\n            \"n\": 12,\n            \"E\": [\n                (0,1),(0,2),(0,3),(0,4),(1,2),(1,5),(1,6),(2,3),(2,7),\n                (3,4),(3,8),(4,5),(4,9),(5,6),(5,10),(6,7),(6,11),\n                (7,8),(7,9),(8,9),(8,10),(9,10),(10,11),(11,0),(11,3)\n            ],\n            \"k\": 4, \"R\": 200, \"S\": 250, \"s\": 2021\n        },\n        {\n            \"n\": 12,\n            \"E\": [(0,i) for i in range(1, 12)],\n            \"k\": 5, \"R\": 100, \"S\": 100, \"s\": 7\n        }\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        n, E, k, R, S, s = case[\"n\"], case[\"E\"], case[\"k\"], case[\"R\"], case[\"S\"], case[\"s\"]\n        \n        rng = np.random.default_rng(s)\n        \n        adj_obs = [set() for _ in range(n)]\n        for u, v in E:\n            adj_obs[u].add(v)\n            adj_obs[v].add(u)\n            \n        X_obs = k_core_size(adj_obs, k)\n        \n        null_core_sizes = []\n        for _ in range(R):\n            adj_random = perform_randomization(adj_obs, S, rng)\n            X_rand = k_core_size(adj_random, k)\n            null_core_sizes.append(X_rand)\n\n        null_dist = np.array(null_core_sizes, dtype=float)\n        mu = np.mean(null_dist)\n        sigma = np.std(null_dist)\n        \n        if sigma == 0.0:\n            Z = 0.0\n        else:\n            Z = (X_obs - mu) / sigma\n            \n        z_star = 2.0\n        reinforced = Z > z_star\n        \n        all_results.append([float(mu), int(X_obs), float(Z), bool(reinforced)])\n\n    # Format the final output string precisely\n    result_strings = []\n    for res in all_results:\n        # Convert boolean to lowercase as per common data exchange formats\n        bool_str = str(res[3]).lower()\n        res_str = f\"[{res[0]},{res[1]},{res[2]},{bool_str}]\"\n        result_strings.append(res_str)\n        \n    print(f\"[{','.join(result_strings)}]\")\n\nsolve()\n```"
        }
    ]
}