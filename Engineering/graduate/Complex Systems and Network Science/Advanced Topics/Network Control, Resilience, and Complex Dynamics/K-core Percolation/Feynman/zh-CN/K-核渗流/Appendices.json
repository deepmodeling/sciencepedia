{
    "hands_on_practices": [
        {
            "introduction": "我们将从基础的 Erdős–Rényi (ER) 随机图模型开始。理解 ER 图上的 k-核渗流是掌握该领域的基石。与 $2$-核的连续相变不同，当 $k \\ge 3$ 时，$k$-核的出现是一种“混合”相变——其规模会发生不连续的跳跃，但临界点附近仍伴随着奇异性。这个练习  将引导你推导这种混合相变的临界条件，并用数值方法计算出 $3$-核的临界点，从而将解析理论与计算实践联系起来。",
            "id": "4284918",
            "problem": "考虑一个 Erdős–Rényi (ER) 随机图，该图定义在 $n$ 个标记顶点上，其中每对顶点以概率 $p$ 独立连接，使得在稀疏极限下，平均度 $c$ 等于 $c = p(n-1)$。图的 $k$-核是指每个顶点的度至少为 $k$ 的最大子图。对于大尺寸极限下的 ER 随机图，已知当 $k \\ge 3$ 时，巨型 $k$-核的出现是在一个阈值平均度 $c^\\star$ 处的混合（具有临界奇异性的不连续）相变。\n\n仅从 ER 图的基本事实（稀疏极限下平均度为 $c$ 的泊松度分布以及边的独立性）和 $k$-核的定义（通过迭代剪枝——移除度小于 $k$ 的顶点，直到所有剩余顶点的度至少为 $k$——得到的不动点）出发，推导出一个随机跟随的半边所指向的、且在剪枝后的图中仍然存在的顶点的存活概率 $x$ 的相应自洽条件，以及非零不动点 $x^\\star$ 通过不动点方程的二重根出现的涌现阈值的相应条件。\n\n对于 $k = 3$ 的特定情况，您必须：\n- 使用 ER 图的假设和迭代剪枝方法，得到不动点函数 $f(x; c)$，使得 $k$-核对应于 $f(x; c) = 0$ 的解。\n- 通过在非零 $x^\\star$ 处的二重根（相切）条件 $f(x^\\star; c^\\star) = 0$ 和 $\\frac{\\partial}{\\partial x} f(x^\\star; c^\\star) = 0$ 来刻画该阈值，并将这些条件简化为可以进行数值求解的、关于一个辅助变量的单个标量方程。\n- 数值计算：\n  1. 对于 $k = 3$，在阈值处的非零解 $x^\\star$。\n  2. 阈值平均度 $c^\\star$。\n  3. 在阈值处 $3$-核中的相应顶点分数 $S^\\star$，以小数（而非百分比）表示。使用标准的计数论证，即在剪枝后的图中，剩余度小于 $k$ 的顶点分数是均值为 $cx$ 的泊松随机变量在 $k-1$ 之前的累积概率。\n\n您的程序必须从第一性原理出发实现一个鲁棒的数值求解器，并产生以下测试套件输出：\n- 测试用例 1（正常路径）：使用包围区间 $[1.0, 3.0]$ 计算求解从二重根条件导出的简化标量方程的辅助变量。\n- 测试用例 2：根据测试用例 1 中获得的辅助变量计算 $x^\\star$。\n- 测试用例 3：根据辅助变量和 $x^\\star$ 计算 $c^\\star$。\n- 测试用例 4：使用 $x^\\star$ 和 $c^\\star$，通过 $k=3$ 的适当泊松累积表达式计算 $S^\\star$。\n- 测试用例 5（边界条件验证）：通过检查 $f(x^\\star; c^\\star) = 0$ 和 $\\frac{\\partial}{\\partial x} f(x^\\star; c^\\star) = 0$ 在 $10^{-12}$ 的容差范围内是否成立，以及二阶导数 $\\frac{\\partial^2}{\\partial x^2} f(x^\\star; c^\\star)$ 是否严格为正，来验证解处的二重根条件。输出一个布尔值，指示所有检查是否通过。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个逗号分隔的列表，用方括号括起来，并严格按以下顺序排列：[$y^\\star, x^\\star, c^\\star, S^\\star$, boolean]，其中 $y^\\star$ 是您在推导中引入的辅助变量。不涉及单位；请将 $S^\\star$ 表示为小数。",
            "solution": "在 Erdős–Rényi (ER) 随机图中确定巨型 $k$-核的出现是网络科学中的一个经典问题。我们的任务是推导 $3$-核（$k=3$）这一特定情况下的相变条件，并计算临界参数。推导将从第一性原理开始，即 ER 图在大尺寸、稀疏极限下的性质。\n\n在此极限下，具有 $n$ 个顶点和平均度 $c$ 的 ER 图表现出两个关键性质：\n$1$. 顶点的度分布遵循均值为 $c$ 的泊松分布：$P(d) = e^{-c} \\frac{c^d}{d!}$。\n$2$. 不同顶点的度是不相关的，并且图的结构是局部树状的。\n\n$k$-核是通过迭代剪枝所有度小于 $k$ 的顶点来找到的。一个顶点的存活取决于其邻居的存活。这表明可以采用一种自洽或平均场方法。设 $x$ 是通过跟随一条随机边到达的顶点属于 $k$-核的概率。这是*相邻*顶点的存活概率。$x$ 的非零值表示存在宏观（巨型）$k$-核。\n\n考虑通过跟随一条随机边到达的顶点 $v$。由于是随机选择边，顶点 $v$ 的度分布不是随机顶点的标准泊松分布。通过跟随一条随机边选择一个度为 $d$ 的顶点的概率与 $d P(d)$ 成正比。因此，$v$ 的*剩余度* $d-1$（$v$ 的其他边的数量）的分布由 $\\frac{d P(d)}{\\langle d \\rangle} = \\frac{d e^{-c} c^d/d!}{c} = e^{-c} \\frac{c^{d-1}}{(d-1)!}$ 给出。这是一个均值为 $c$ 的泊松分布。\n\n我们来为剪枝过程建模。顶点 $v$ 的 $d-1$ 个“其他”邻居中的每一个都以概率 $x$ 独立地在剪枝过程中存活下来。因为这些邻居数量的初始分布是均值为 $c$ 的泊松分布，所以*存活*邻居的数量遵循一个均值为 $c x$ 的“稀疏化”泊松分布。\n为了使顶点 $v$ 本身存活并成为 $k$-核的一部分，它在最终剪枝图中的度必须至少为 $k$。我们通过一条边到达 $v$（我们假设这条边连接到图的存活部分），所以 $v$ 必须至少有 $k-1$ 个其他邻居也存活下来。\n\n这导出了 $x$ 的自洽方程。顶点 $v$ 存活的概率 $x$ 是一个均值为 $c x$ 的泊松随机变量 $Z$ 取值至少为 $k-1$ 的概率：\n$$x = P(Z \\ge k-1) = \\sum_{j=k-1}^{\\infty} e^{-cx} \\frac{(cx)^j}{j!} = 1 - \\sum_{j=0}^{k-2} e^{-cx} \\frac{(cx)^j}{j!}$$\n该方程总有一个平凡解 $x=0$，对应于不存在巨型 $k$-核的情况。一个非平凡解 $x > 0$ 在临界阈值 $c^\\star$ 处出现。\n\n对于 $k=3$ 的特定情况，自洽方程为：\n$$x = 1 - \\sum_{j=0}^{1} e^{-cx} \\frac{(cx)^j}{j!} = 1 - \\left( e^{-cx} \\frac{(cx)^0}{0!} + e^{-cx} \\frac{(cx)^1}{1!} \\right)$$\n$$x = 1 - e^{-cx}(1+cx)$$\n我们定义一个不动点函数 $f(x; c)$，其根给出了 $x$ 的解：\n$$f(x; c) = x - 1 + e^{-cx}(1+cx) = 0$$\n对于 $k \\ge 3$，非平凡解的出现是一种不连续相变，其特征是鞍结分岔。这发生在直线 $y=x$ 与曲线 $g(x) = 1 - e^{-cx}(1+cx)$ 相切时。这个相切点 $(x^\\star, c^\\star)$ 是方程 $f(x;c)=0$ 的一个二重根，并且对于 $x^\\star > 0$ 必须同时满足两个条件：\n$1$. $f(x^\\star; c^\\star) = 0$\n$2$. $\\frac{\\partial f}{\\partial x}(x^\\star; c^\\star) = 0$\n\n让我们计算关于 $x$ 的偏导数：\n$$\\frac{\\partial f}{\\partial x} = \\frac{\\partial}{\\partial x} \\left( x - 1 + e^{-cx}(1+cx) \\right) = 1 + [(-c)e^{-cx}(1+cx) + e^{-cx}(c)]$$\n$$\\frac{\\partial f}{\\partial x} = 1 -ce^{-cx} - c^2x e^{-cx} + ce^{-cx} = 1 - c^2x e^{-cx}$$\n在临界点 $(x^\\star, c^\\star)$ 的两个条件是：\n$1$. $x^\\star - 1 + e^{-c^\\star x^\\star}(1+c^\\star x^\\star) = 0$\n$2$. $1 - (c^\\star)^2 x^\\star e^{-c^\\star x^\\star} = 0$\n\n为了解这个方程组，我们引入一个辅助变量 $y = cx$。在阈值处，令 $y^\\star = c^\\star x^\\star$。\n从条件（2）可得：\n$$1 = (c^\\star)^2 x^\\star e^{-c^\\star x^\\star} = c^\\star (c^\\star x^\\star) e^{-c^\\star x^\\star} = c^\\star y^\\star e^{-y^\\star}$$\n这给出了 $c^\\star$ 的表达式：\n$$c^\\star = \\frac{e^{y^\\star}}{y^\\star}$$\n从条件（1）可得：\n$$1 - x^\\star = e^{-c^\\star x^\\star}(1+c^\\star x^\\star) = e^{-y^\\star}(1+y^\\star)$$\n我们需要一个用 $y^\\star$ 表示 $x^\\star$ 的表达式。使用 $x^\\star = y^\\star/c^\\star$ 和 $c^\\star$ 的表达式：\n$$x^\\star = \\frac{y^\\star}{e^{y^\\star}/y^\\star} = (y^\\star)^2 e^{-y^\\star}$$\n将此代入重新整理后的条件（1）：\n$$1 - (y^\\star)^2 e^{-y^\\star} = e^{-y^\\star}(1+y^\\star)$$\n两边乘以 $e^{y^\\star}$（因为 $y^\\star > 0$，所以 $e^{y^\\star} \\neq 0$）：\n$$e^{y^\\star} - (y^\\star)^2 = 1+y^\\star$$\n重新整理得到一个关于 $y^\\star$ 的单个标量方程：\n$$e^{y^\\star} - (y^\\star)^2 - y^\\star - 1 = 0$$\n这个方程可以对 $y^\\star > 0$ 进行数值求解。问题指定了一个包围区间 $[1.0, 3.0]$。\n\n一旦找到 $y^\\star$，我们就可以计算其他临界量：\n-   $x^\\star = (y^\\star)^2 e^{-y^\\star}$\n-   $c^\\star = e^{y^\\star} / y^\\star$\n\n最后，我们计算 $S^\\star$，即在阈值处 $3$-核中的顶点分数。一个随机选择的顶点如果在剪枝后的图中度至少为 $k=3$ 则存活。每个邻居以概率 $x^\\star$ 独立存活后，一个随机顶点的度遵循均值为 $c^\\star x^\\star = y^\\star$ 的泊松分布。因此，$S^\\star$ 是一个泊松变量 $Z \\sim \\text{Poisson}(y^\\star)$ 至少为 $3$ 的概率：\n$$S^\\star = P(Z \\ge 3) = 1 - P(Z \\le 2) = 1 - \\sum_{j=0}^{2} e^{-y^\\star} \\frac{(y^\\star)^j}{j!}$$\n$$S^\\star = 1 - e^{-y^\\star} \\left( 1 + y^\\star + \\frac{(y^\\star)^2}{2} \\right)$$\n为了使相变成为一个对应于不连续跳跃的真正的鞍结分岔，在临界点处 $f(x;c)$ 的二阶导数必须非零。\n$$\\frac{\\partial^2 f}{\\partial x^2} = \\frac{\\partial}{\\partial x} (1 - c^2x e^{-cx}) = -c^2 [e^{-cx} + x(-c)e^{-cx}] = -c^2 e^{-cx}(1-cx)$$\n在阈值处，这变为：\n$$\\frac{\\partial^2 f}{\\partial x^2}(x^\\star, c^\\star) = -(c^\\star)^2 e^{-y^\\star}(1-y^\\star)$$\n对于一个从 $x=0$ 开始的物理上有意义的不连续相变，我们要求这个二阶导数为正，这意味着 $1-y^\\star  0$，即 $y^\\star > 1$。数值解必须满足这一点。\n\n数值实现将求解 $y^\\star$，然后使用这些推导出的公式计算 $x^\\star$、$c^\\star$ 和 $S^\\star$，最后验证二重根条件和二阶导数的符号。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import brentq\n\ndef solve():\n    \"\"\"\n    Derives and computes the critical parameters for 3-core percolation on an ER graph.\n\n    The problem is solved by first deriving the self-consistency equations for the\n    survival probability of a node in the k-core. For k=3, this leads to a system\n    of two equations for the critical threshold (x*, c*), based on the double-root\n    condition for the emergence of a non-trivial solution.\n\n    f(x; c) = x - 1 + exp(-c*x)*(1 + c*x) = 0\n    df/dx(x; c) = 1 - c**2 * x * exp(-c*x) = 0\n\n    By introducing an auxiliary variable y = c*x, this system is reduced to a\n    single scalar equation for y:\n    g(y) = exp(y) - y**2 - y - 1 = 0\n\n    This script solves for y*, then computes x*, c*, and the 3-core size S* at the\n    threshold. Finally, it verifies that the computed values satisfy the original\n    double-root conditions.\n    \"\"\"\n\n    # --- Test Case 1: Compute the auxiliary variable y* ---\n    # Define the scalar function g(y) = 0 to be solved.\n    def g(y):\n        return np.exp(y) - y**2 - y - 1\n\n    # Solve for y* in the given interval [1.0, 3.0].\n    # There is also a root at y=0 which we are not interested in.\n    try:\n        y_star = brentq(g, 1.0, 3.0, xtol=1e-15, rtol=1e-15)\n    except ValueError:\n        # Handle cases where brentq might fail, although it shouldn't for this function and interval.\n        y_star = None\n    \n    if y_star is None:\n        raise RuntimeError(\"Failed to find root for the auxiliary variable y.\")\n\n    # --- Test Case 2: Compute x* ---\n    # The survival probability x* is given by x* = (y*)**2 * exp(-y*).\n    x_star = y_star**2 * np.exp(-y_star)\n\n    # --- Test Case 3: Compute c* ---\n    # The critical mean degree c* is given by c* = exp(y*) / y*.\n    c_star = np.exp(y_star) / y_star\n\n    # --- Test Case 4: Compute S* ---\n    # The fraction of vertices in the 3-core S* is P(Z = 3) where Z ~ Poisson(y*).\n    # S* = 1 - exp(-y*) * (1 + y* + (y*)**2 / 2).\n    s_star = 1.0 - np.exp(-y_star) * (1.0 + y_star + y_star**2 / 2.0)\n    \n    # --- Test Case 5: Verify double-root conditions ---\n    tolerance = 1e-12\n    all_checks_passed = False\n\n    # Check 1: f(x*, c*) = 0\n    # f_val = x* - 1 + exp(-c*x)*(1 + c*x) = x* - 1 + exp(-y*)*(1 + y*)\n    f_val = x_star - 1.0 + np.exp(-y_star) * (1.0 + y_star)\n    check1 = abs(f_val)  tolerance\n\n    # Check 2: df/dx(x*, c*) = 0\n    # dfdx_val = 1 - c*^2 * x* * exp(-c*x) = 1 - c* * y* * exp(-y*)\n    # Since c* = exp(y*)/y*, this simplifies to 1 - (exp(y*)/y*) * y* * exp(-y*) = 1 - 1 = 0\n    # We use a numerical check to account for floating point inaccuracies.\n    dfdx_val = 1.0 - c_star**2 * x_star * np.exp(-y_star)\n    check2 = abs(dfdx_val)  tolerance\n\n    # Check 3: d^2f/dx^2(x*,c*)  0\n    # d2fdx2 = -c*^2 * exp(-y*) * (1-y*)\n    d2fdx2_val = -(c_star**2) * np.exp(-y_star) * (1.0 - y_star)\n    check3 = d2fdx2_val  0\n\n    all_checks_passed = bool(check1 and check2 and check3)\n    \n    # Assemble the final results\n    results = [y_star, x_star, c_star, s_star, all_checks_passed]\n    \n    # Final print statement in the exact required format.\n    # The format specifier ensures high precision to match the calculations.\n    # Note: A simple `str()` conversion might not provide enough precision.\n    print(f\"[{results[0]:.15f},{results[1]:.15f},{results[2]:.15f},{results[3]:.15f},{str(results[4]).lower()}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "真实世界的网络结构远比简单的随机图复杂，一个关键的复杂性来源是度相关性，即度大（或小）的节点倾向于相互连接。如果两个网络具有完全相同的度分布，它们的 $k$-核大小会相同吗？这个练习  通过一个巧妙构建的玩具模型给出了一个惊人的答案，它清晰地展示了同配混合（assortative mixing）如何能显著增强网络的鲁棒性。通过这个练习，你将接触到分析有相关性网络的强大工具——腔方法（cavity method）。",
            "id": "4284879",
            "problem": "考虑一个通过配置模型生成的无向随机网络，其度分布为 $P(q)=\\frac{1}{2}\\delta_{q,2}+\\frac{1}{2}\\delta_{q,4}$，使得一半节点的度为 $2$，另一半节点的度为 $4$。定义了两个系综，它们共享此度分布，但通过条件邻居度分布 $P(q' \\mid q)$ 而在度-度相关性上有所不同：\n- 同配系综 $\\mathrm{A}$：$P(2 \\mid 2)=1$, $P(4 \\mid 4)=1$，以及 $P(2 \\mid 4)=P(4 \\mid 2)=0$。\n- 异配系综 $\\mathrm{D}$：$P(4 \\mid 2)=1$, $P(2 \\mid 2)=0$, $P(2 \\mid 4)=\\frac{1}{2}$，以及 $P(4 \\mid 4)=\\frac{1}{2}$。\n\n这些条件概率满足无向一致性约束 $q P(q) P(q' \\mid q)=q' P(q') P(q \\mid q')$（对于所有 $q,q' \\in \\{2,4\\}$）。\n\n仅从 $k$-核的定义（即每个节点的度至少为 $k$ 的最大诱导子图）以及配置模型的局部树状性质（因此沿着不同边到达的消息在给定节点度的条件下可以被视为独立事件）出发，分析每个系综中的 $3$-核（$k=3$）。定义沿一条边的空腔消息为正，如果当该边被移除时，接收端的节点仍将保留在 $3$-核中；令 $y_q$ 表示在无限大尺寸极限下，从一个度为 $q$ 的节点发出的此类消息为正的概率，并令 $t_q$ 表示一个度为 $q$ 的节点属于 $3$-核的概率。\n\n推导 $y_q$ 的相应自洽关系，并用它们计算每个系综中的 $t_q$。然后，分别计算系综 A 和 D 中 $3$-核内节点的总比例 $S_{\\mathrm{A}}$ 和 $S_{\\mathrm{D}}$。最后，报告减少量\n$$\\Delta S \\equiv S_{\\mathrm{A}}-S_{\\mathrm{D}}.$$\n将最终答案表示为一个精确数。无需四舍五入。",
            "solution": "该问题要求分析两个随机网络系综 A 和 D 中的 $3$-核，这两个系综共享相同的度分布 $P(q)=\\frac{1}{2}\\delta_{q,2}+\\frac{1}{2}\\delta_{q,4}$，但在度-度相关性上有所不同。将按照指定，使用空腔方法进行分析。\n\n问题陈述已经过验证，被认为是有效的。它在科学上植根于复杂网络理论，特别是 $k$-核渗流。问题提法良好，提供了所有必要信息，没有矛盾之处。定义和目标都客观明确地陈述了。\n\n$k$-核是其中每个节点的度都至少为 $k$ 的最大诱导子图。对于本问题，$k=3$。分析依赖于一种适用于局部树状网络的消息传递（空腔）方法，例如在无限大尺寸极限下由配置模型生成的网络。\n\n令 $y_q$ 为从一个度为 $q$ 的节点发出的消息为“正”的概率。一个正消息表示，在移除了消息所沿边线的网络的“空腔”版本中，发送节点将仍保留在 $3$-核内。一个原始度为 $q$ 的节点在空腔图中的度为 $q-1$。为了使该节点保留在 $3$-核中，它必须连接到至少 $k=3$ 个同样保留在核中的邻居。在消息传递框架中，这转化为该节点从其在空腔图中的 $q-1$ 个邻居处接收到至少 $3$ 个正消息。\n\n令 $Y_q$ 为我们度为 $q$ 的节点接收到的消息为正的概率。这个概率取决于其邻居的度分布 $P(q'|q)$，以及一个度为 $q'$ 的邻居发送正消息的概率 $y_{q'}$。所以，$Y_q = \\sum_{q'} P(q'|q) y_{q'}$。\n\n度为 $q$ 的节点接收到的正消息数量（来自其 $q-1$ 个邻居）遵循二项分布，因为在树状结构上，传入的消息是独立的。因此，$y_q$ 的自洽方程为：\n$$y_q = \\sum_{m=k}^{q-1} \\binom{q-1}{m} (Y_q)^m (1-Y_q)^{q-1-m}$$\n对于我们的问题，$k=3$，可能的度为 $q \\in \\{2, 4\\}$。\n\n对于一个度为 $q=2$ 的节点，它在空腔图中有 $q-1=1$ 个邻居。它不可能接收到至少 $k=3$ 个正消息。因此，求和为空，且\n$$y_2 = 0$$\n这对两个系综都成立。\n\n对于一个度为 $q=4$ 的节点，它在空腔图中有 $q-1=3$ 个邻居。它必须从这 $3$ 个邻居处接收到至少 $3$ 个正消息。这只有在所有 $3$ 个邻居都发送正消息时才可能。\n$$y_4 = \\binom{3}{3} (Y_4)^3 (1-Y_4)^{3-3} = (Y_4)^3$$\n其中 $Y_4 = P(2|4)y_2 + P(4|4)y_4$。\n\n一旦确定了 $y_q$ 的值，我们就可以计算 $t_q$，即一个随机选择的度为 $q$ 的节点在 $3$-核中的概率。这个节点位于完整的图中，有 $q$ 个邻居。如果它从其 $q$ 个邻居处接收到至少 $3$ 个正消息，它就属于 $3$-核。一个邻居发送正消息的概率仍然是 $Y_q$。\n$$t_q = \\sum_{m=k}^{q} \\binom{q}{m} (Y_q)^m (1-Y_q)^{q-m}$$\n对于 $q=2$，求和为空，所以 $t_2=0$。\n对于 $q=4$，$t_4 = \\sum_{m=3}^{4} \\binom{4}{m} (Y_4)^m (1-Y_4)^{4-m} = \\binom{4}{3} (Y_4)^3 (1-Y_4) + \\binom{4}{4} (Y_4)^4$。\n\n$3$-核中节点的总比例 $S$ 由 $S = \\sum_q P(q)t_q$ 给出。\n\n**系综 A（同配）的分析**\n条件概率为 $P(2|2)=1$, $P(4|4)=1$，以及 $P(2|4)=P(4|2)=0$。\n如前所述，$y_2=0$。\n对于 $y_4$，我们首先计算 $Y_4$：\n$Y_4 = P(2|4)y_2 + P(4|4)y_4 = (0)(0) + (1)y_4 = y_4$。\n$y_4$ 的自洽方程变为：\n$$y_4 = (y_4)^3 \\implies y_4(y_4^2 - 1) = 0$$\n$y_4$ 在区间 $[0,1]$ 内的解是 $y_4=0$（平凡核）和 $y_4=1$（非平凡核）。对于一个可以支持 $k$-核的网络，我们取非平凡解 $y_4=1$。一个纯粹的 4-正则图会形成一个 3-核，因此这个选择在物理上是合理的。\n\n所以，对于系综 A，我们有 $y_2=0$ 和 $y_4=1$。\n现在我们计算概率 $t_q$。\n度为 $2$ 的节点永远不可能在 $3$-核中，因此 $t_2=0$。\n对于 $t_4$，我们有 $Y_4 = y_4=1$。\n$$t_4 = \\sum_{m=3}^{4} \\binom{4}{m} (1)^m (1-1)^{4-m} = \\binom{4}{3}(1)^3(0)^1 + \\binom{4}{4}(1)^4(0)^0 = 0 + 1 = 1$$\n所以，$t_2=0$ 且 $t_4=1$。所有度为 $4$ 的节点都在 $3$-核中，而度为 $2$ 的节点则没有。\n系综 A 中 $3$-核内节点的总比例为：\n$$S_{\\mathrm{A}} = P(2)t_2 + P(4)t_4 = \\frac{1}{2}(0) + \\frac{1}{2}(1) = \\frac{1}{2}$$\n\n**系综 D（异配）的分析**\n条件概率为 $P(4|2)=1$, $P(2|2)=0$, $P(2|4)=\\frac{1}{2}$，以及 $P(4|4)=\\frac{1}{2}$。\n同样，$y_2=0$。\n对于 $y_4$，我们计算 $Y_4$：\n$Y_4 = P(2|4)y_2 + P(4|4)y_4 = \\left(\\frac{1}{2}\\right)(0) + \\left(\\frac{1}{2}\\right)y_4 = \\frac{1}{2}y_4$。\n$y_4$ 的自洽方程是：\n$$y_4 = \\left(\\frac{1}{2}y_4\\right)^3 = \\frac{1}{8}y_4^3 \\implies y_4\\left(1 - \\frac{y_4^2}{8}\\right) = 0$$\n解为 $y_4=0$ 和 $y_4^2=8$，即 $y_4 = \\sqrt{8} = 2\\sqrt{2}$。由于 $y_4$ 是一个概率，它必须在 $[0,1]$ 区间内。$2\\sqrt{2} \\approx 2.828 > 1$，所以这个解是不符合物理实际的。唯一有效的解是 $y_4=0$。\n\n对于系综 D，我们有 $y_2=0$ 和 $y_4=0$。这意味着不存在非平凡的 $3$-核。\n我们计算概率 $t_q$。\n$t_2=0$。\n对于 $t_4$，我们有 $Y_4 = \\frac{1}{2}y_4 = 0$。\n$$t_4 = \\sum_{m=3}^{4} \\binom{4}{m} (0)^m (1-0)^{4-m} = 0$$\n所以，$t_2=0$ 且 $t_4=0$。没有任何节点在 $3$-核中。\n系综 D 中 $3$-核内节点的总比例为：\n$$S_{\\mathrm{D}} = P(2)t_2 + P(4)t_4 = \\frac{1}{2}(0) + \\frac{1}{2}(0) = 0$$\n\n**最终计算**\n问题要求计算减少量 $\\Delta S = S_{\\mathrm{A}} - S_{\\mathrm{D}}$。\n$$\\Delta S = \\frac{1}{2} - 0 = \\frac{1}{2}$$\n这个结果突显了度相关性对网络鲁棒性的强烈影响。同配网络维持了一个由其所有度为 $4$ 的节点构成的大 $3$-核，而异配网络的 $3$-核则完全崩溃了。",
            "answer": "$$\\boxed{\\frac{1}{2}}$$"
        },
        {
            "introduction": "作为一名网络科学家，一个核心任务是判断在真实网络中观察到的结构特征（例如一个巨大的 $k$-核）是否具有统计显著性。这个特征是网络非平凡组织的结果，还是仅仅是其度序列的随机产物？这个练习  将指导你完成一个标准的研究流程：将经验网络的 $k$-核大小与一个保留了相同度序列的“零模型”系综进行比较。通过这种方式，你将掌握使用假设检验来识别网络中非平凡结构特性的关键技能。",
            "id": "4284882",
            "problem": "考虑一个由图 $G = (V, E)$ 表示的简单无向网络，其包含 $|V| = n$ 个节点和 $|E| = m$ 条边。度序列是度数的列表 $\\{d_1, d_2, \\dots, d_n\\}$，其中 $d_i$ 是节点 $i$ 的度。图的 $k$-核 (k-core) 是一个最大诱导子图，其中每个节点的度至少为 $k$。它是通过递归地修剪度严格小于 $k$ 的节点，直到无法再进行修剪为止而获得的。$k$-核的大小，记为 $|V_k(G)|$，是此修剪过程后剩余的节点数。\n\n您的任务是设计一个程序，在一个度保持的零模型下执行经验推断，以检验 $k$-核的结构增强性。该零模型必须精确地保持经验度序列，并通过在简单图（无自环和无重边）上重复应用度保持的双边交换来随机化网络。一次双边交换选择两条具有四个不同端点 $\\{a,b,c,d\\}$ 的不同边 $(a,b)$ 和 $(c,d)$，并将它们替换为 $(a,c)$ 和 $(b,d)$ 或 $(a,d)$ 和 $(b,c)$，前提是生成的图保持为简单图。双边交换必须成功重复固定的次数，以引发充分的随机化。对于每个随机化样本，计算其 $k$-核大小 $|V_k(\\cdot)|$。\n\n结构增强的统计检验应按以下方式进行。设 $X_{\\text{obs}}$ 表示经验图 $G$ 的观测 $k$-核大小。通过执行 $R$ 次独立的随机化来生成一个零系综，每次随机化都从 $G$ 开始，并应用 $S$ 次成功的双边交换。设 $\\{X_1, X_2, \\dots, X_R\\}$ 是从随机化系综中得到的 $k$-核大小。使用这些样本计算一个标准化的检验统计量，以比较 $X_{\\text{obs}}$ 与零期望。使用一个固定的阈值 $z^{\\ast} = 2$ 来进行决策。如果标准化检验统计量表明观测的 $k$-核大小显著大于零期望（超过阈值），则将该情况分类为结构增强；否则，不将其分类为增强。在零系综的经验方差为零的情况下，将标准化检验统计量定义为 $0$，并且不分类为增强。\n\n您的程序必须实现：\n- 一个使用递归修剪定义计算 $k$-核大小 $|V_k(G)|$ 的过程。\n- 一个通过双边交换生成 $G$ 的度保持随机样本的过程，并确保图始终保持简单。\n- 一个计算零期望和标准化检验统计量，并使用阈值 $z^{\\ast} = 2$ 做出增强决策的过程。\n\n请使用以下测试套件。每个测试用例通过节点数 $n$、边集 $E$、核参数 $k$、随机化次数 $R$、每次随机化的成功交换次数 $S$ 以及用于可复现性的随机种子 $s$ 来指定图。节点由从 $0$ 到 $n-1$ 的整数标记。所有数字必须作为整数处理。\n\n测试用例 1 (带外围的稠密核心):\n- $n = 12$\n- $E$ 包含节点 $\\{0,1,2,3,4,5\\}$ 之间形成一个团的所有对，以及从每个外围节点 $\\{6,7,8,9,10,11\\}$ 到该团的两条边：\n  - 团的边: $\\{(0,1),(0,2),(0,3),(0,4),(0,5),(1,2),(1,3),(1,4),(1,5),(2,3),(2,4),(2,5),(3,4),(3,5),(4,5)\\}$\n  - 外围连接: $(6,0),(6,1),(7,2),(7,3),(8,4),(8,5),(9,0),(9,2),(10,1),(10,4),(11,3),(11,5)$\n- $k = 5$\n- $R = 200$\n- $S = 270$\n- $s = 12345$\n\n测试用例 2 (近正则的类随机图):\n- $n = 12$\n- $E = \\{(0,1),(0,2),(0,3),(0,4),(1,2),(1,5),(1,6),(2,3),(2,7),(3,4),(3,8),(4,5),(4,9),(5,6),(5,10),(6,7),(6,11),(7,8),(7,9),(8,9),(8,10),(9,10),(10,11),(11,0),(11,3)\\}$\n- $k = 4$\n- $R = 200$\n- $S = 250$\n- $s = 2021$\n\n测试用例 3 (星形图边界情况):\n- $n = 12$\n- $E = \\{(0,1),(0,2),(0,3),(0,4),(0,5),(0,6),(0,7),(0,8),(0,9),(0,10),(0,11)\\}$\n- $k = 5$\n- $R = 100$\n- $S = 100$\n- $s = 7$\n\n您的程序必须为每个测试用例生成一个形式为 [$\\mu, X_{\\text{obs}}, Z$, reinforced] 的列表，其中：\n- $\\mu$ 是 $\\{X_1,\\dots,X_R\\}$ 的样本均值，表示为浮点数，\n- $X_{\\text{obs}}$ 是经验 $k$-核大小，表示为整数，\n- $Z$ 是标准化检验统计量，表示为浮点数，\n- $\\text{reinforced}$ 是一个布尔值，指示标准化检验统计量是否超过阈值 $z^{\\ast} = 2$。\n\n最终输出格式：您的程序应生成单行输出，其中包含所有测试用例的结果，形式为一个用方括号括起来的逗号分隔列表，其中每个项目本身都是按上述顺序排列的列表。例如，输出应类似于 [$[\\mu_1, X_{\\text{obs},1}, Z_1, \\text{reinforced}_1], [\\mu_2, X_{\\text{obs},2}, Z_2, \\text{reinforced}_2], [\\mu_3, X_{\\text{obs},3}, Z_3, \\text{reinforced}_3]]$。此问题不涉及物理单位、角度单位或百分比，因此不应提供任何此类单位。",
            "solution": "该问题是有效的。它在网络科学领域提出了一个定义明确的任务，该任务具有科学依据、客观且内部一致。\n\n### 步骤1：提取给定信息\n\n- **图表示法**：一个简单无向图 $G = (V, E)$，有 $n = |V|$ 个节点和 $m = |E|$ 条边。\n- **节点标签**：从 $0$ 到 $n-1$ 的整数。\n- **$k$-核定义**：每个节点的度至少为 $k$ 的最大诱导子图。它是通过递归地修剪度严格小于 $k$ 的节点获得的。\n- **$k$-核大小**：$|V_k(G)|$，$k$-核中的节点数。\n- **任务**：使用一个度保持的零模型对 $k$-核的结构增强性进行经验推断。\n- **零模型**：通过使用固定次数的成功度保持双边交换来随机化经验图 $G$ 生成。图必须保持简单（无自环，无重边）。\n- **双边交换**：选择两条不同的边 $(a,b)$ 和 $(c,d)$，其四个端点 $\\{a,b,c,d\\}$ 均不相同。用 $(a,c)$ 和 $(b,d)$ 或 $(a,d)$ 和 $(b,c)$ 替换它们，前提是生成的图保持简单。\n- **随机化过程**：对于 $R$ 次独立的随机化中的每一次，都从经验图 $G$ 开始，并应用 $S$ 次成功的双边交换。\n- **统计检验**：\n    - $X_{\\text{obs}}$：经验图 $G$ 的观测 $k$-核大小。\n    - $\\{X_1, X_2, \\dots, X_R\\}$：来自 $R$ 个随机化图的一组 $k$-核大小。\n    - 零系综的样本均值：$\\mu = \\frac{1}{R} \\sum_{i=1}^{R} X_i$。\n    - 零系综的样本标准差：$\\sigma = \\sqrt{\\frac{1}{R} \\sum_{i=1}^{R} (X_i - \\mu)^2}$。\n    - 标准化检验统计量：$Z = \\frac{X_{\\text{obs}} - \\mu}{\\sigma}$。\n    - 特殊条件：如果 $\\sigma = 0$，则 $Z = 0$。\n- **决策规则**：\n    - 阈值：$z^{\\ast} = 2$。\n    - 分类：如果 $Z > z^{\\ast}$，图被分类为“结构增强”。否则，不被分类为增强。\n- **测试用例**：提供了三个测试用例，每个用例都有图结构（$n, E$）、核分析（$k$）、随机化（$R, S$）和可复现性（$s$）的参数。\n- **输出格式**：对于每个测试用例，输出一个列表 $[\\mu, X_{\\text{obs}}, Z, \\text{reinforced}]$。最终程序输出是这些列表的列表。\n\n### 步骤2：使用提取的信息进行验证\n\n- **科学上合理**：$k$-核、通过双边交换进行的度保持随机化（也称为配置模型切换算法）以及零模型假设检验等概念是网络科学和复杂系统理论中的基本和标准方法。整个过程在科学上是有效的。\n- **定义明确**：问题被高度精确地规定。所有必要的输入（$n, E, k, R, S, s$）、算法（用于 $k$-核的修剪算法、双边交换）和统计程序（$Z$ 的计算、$\\sigma=0$ 的处理、决策阈值）都被明确定义。这确保了对于给定的随机种子，每个测试用例都有一个唯一的、稳定的和有意义的计算结果。\n- **客观**：问题以正式、无偏见的语言陈述。所有分析和决策的标准都是定量的和明确的（例如，$Z > 2$）。\n\n该问题没有以下任何无效性缺陷：\n1.  **科学/事实不健全**：没有违反科学或数学原理。\n2.  **不可形式化/不相关**：该问题是一个可形式化的算法任务，与 $k$-核渗流的主题直接相关。\n3.  **不完整/矛盾的设置**：所有需要的数据和条件都已提供，并且它们是一致的。\n4.  **不现实/不可行**：测试用例的参数（$n=12$，中等大小的 $R, S$）在计算上是可行的。图结构是有效的。\n5.  **不适定/结构不良**：问题结构良好，对于给定的种子会产生一个确定的结果。\n6.  **伪深刻/琐碎**：该任务需要实现和集成几个非琐碎的算法，使其成为一个实质性的问题。测试用例经过精心选择，以探究实现的不同方面，包括边界条件（星形图）。\n7.  **超出科学可验证性**：在给定指定随机种子的情况下，结果是可计算复现和验证的。\n\n### 步骤3：结论与行动\n\n问题陈述是**有效的**。将根据要求开发并实现一个解决方案。\n\n### 算法设计与原理\n\n解决方案被构造为一系列过程，对应于问题陈述的主要组成部分。\n\n1.  **`k_core_size(adj, k)`**：该函数计算由邻接表 `adj` 表示的图对于给定整数 `k` 的 $k$-核大小。它实现了指定的递归修剪算法。\n    - **原理**：通过迭代移除度小于 $k$ 的节点来找到 $k$-核。这个过程必须持续到没有这样的节点存在为止，因为移除一个节点会减少其邻居的度，可能导致它们在后续步骤中被修剪。\n    - **实现**：我们首先计算所有节点的初始度。初始化一个队列，包含所有度小于 `k` 的节点。然后我们处理这个队列，一次移除一个节点。对于每个被移除的节点，我们遍历其邻居，将它们的度减一。如果一个邻居的度降到 `k` 以下，它就被添加到队列中以便稍后修剪。我们跟踪被移除的节点，以避免重复处理，并计算最终的核大小，即 $n$ 减去被移除的唯一节点总数。\n\n2.  **`perform_randomization(adj, num_swaps, rng)`**：该函数接受一个图、一个成功交换的目标次数 `S` 和一个随机数生成器。它返回一个具有相同度序列的新图。\n    - **原理**：双边交换是生成具有固定度序列的随机图的基本操作。它在局部重新布线网络，同时保持每个相关节点的度不变。重复应用可以充分随机化网络结构，打破非因度序列本身造成的关联。\n    - **实现**：创建输入图邻接表的副本。创建一个包含所有唯一边的列表。主循环运行直到执行了 `S` 次成功的交换。在每次尝试中，随机选择两条不同的边 $(a,b)$ 和 $(c,d)$。我们验证这四个端点是不同的。然后我们检查两种可能的新边对 $(a,c)$ 和 $(b,d)$ 或 $(a,d)$ 和 $(b,c)$ 的有效性。如果新边对不会引入重边（即新边尚不存在），则该新边对是有效的。如果至少存在一个有效的重连方式，则选择其中一种，更新邻接表和边列表，并增加成功交换计数器。为防止在没有可交换的图（如星形图）上出现无限循环，我们加入了总尝试次数的限制。\n\n3.  **`solve()`**：这是为所有测试用例编排整个分析过程的主驱动函数。\n    - **原理**：任务的核心是在观测指标 ($X_{\\text{obs}}$) 与从随机图系综生成的该指标的零分布之间进行统计比较。Z-score量化了观测值与零模型均值相差多少个标准差，从而提供了一个标准化的结构意外性度量。\n    - **实现**：该函数遍历每个测试用例。对于每个用例，它使用给定的种子初始化一个随机数生成器以确保可复现性。它构建图并计算观测的 $k$-核大小 $X_{\\text{obs}}$。然后，它进入一个循环以生成 $R$ 个随机化图。对于每次迭代，它在一个原始图的新副本上调用 `perform_randomization`，并计算生成的随机图的 $k$-核大小，将其添加到一个零值列表中。生成零系综后，它计算均值 $\\mu$ 和标准差 $\\sigma$。Z-score计算为 $(X_{\\text{obs}} - \\mu) / \\sigma$，并特别检查在 $\\sigma=0$ 时将 $Z$ 设为0。最后，根据 $Z > 2$ 做出增强决策。结果 $[\\mu, X_{\\text{obs}}, Z, \\text{reinforced}]$ 被收集并格式化为所需的最终输出字符串。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef k_core_size(adj, k):\n    \"\"\"\n    Computes the size of the k-core of a graph using recursive pruning.\n    \n    Args:\n        adj (list of set): The adjacency list of the graph.\n        k (int): The core parameter.\n        \n    Returns:\n        int: The number of nodes in the k-core.\n    \"\"\"\n    n = len(adj)\n    degrees = np.array([len(neighbors) for neighbors in adj])\n    \n    # Queue for nodes to be pruned\n    prune_queue = [i for i, d in enumerate(degrees) if d  k]\n    head = 0\n    \n    is_pruned = np.zeros(n, dtype=bool)\n    num_pruned = 0\n    \n    while head  len(prune_queue):\n        u = prune_queue[head]\n        head += 1\n        \n        if is_pruned[u]:\n            continue\n            \n        is_pruned[u] = True\n        num_pruned += 1\n        \n        for v in adj[u]:\n            if not is_pruned[v]:\n                degrees[v] -= 1\n                if degrees[v]  k:\n                    prune_queue.append(v)\n                    \n    return n - num_pruned\n\ndef perform_randomization(adj, num_swaps, rng):\n    \"\"\"\n    Generates a degree-preserving randomized graph via double-edge swaps.\n    \n    Args:\n        adj (list of set): The adjacency list of the original graph.\n        num_swaps (int): The number of successful swaps to perform.\n        rng (np.random.Generator): The random number generator.\n        \n    Returns:\n        list of set: The adjacency list of the randomized graph.\n    \"\"\"\n    n = len(adj)\n    rand_adj = [s.copy() for s in adj]\n    \n    edges = []\n    for u in range(n):\n        for v in rand_adj[u]:\n            if u  v:\n                edges.append((u, v))\n                \n    num_edges = len(edges)\n    if num_edges  2:\n        return rand_adj\n\n    successful_swaps = 0\n    # Add a safety break for non-randomizable graphs\n    max_attempts = 100 * num_swaps if num_swaps  0 else 1\n    attempts = 0\n\n    while successful_swaps  num_swaps and attempts  max_attempts:\n        attempts += 1\n        \n        if num_edges  2:\n            break\n\n        idx1, idx2 = rng.choice(num_edges, 2, replace=False)\n        e1, e2 = edges[idx1], edges[idx2]\n        a, b = e1\n        c, d = e2\n        \n        if len({a, b, c, d}) != 4:\n            continue\n            \n        # Rewiring option 1: (a,d) and (b,c)\n        valid1 = (d not in rand_adj[a]) and (c not in rand_adj[b])\n        # Rewiring option 2: (a,c) and (b,d)\n        valid2 = (c not in rand_adj[a]) and (d not in rand_adj[b])\n        \n        chosen_rewiring = None\n        if valid1 and valid2:\n            chosen_rewiring = 1 if rng.random()  0.5 else 2\n        elif valid1:\n            chosen_rewiring = 1\n        elif valid2:\n            chosen_rewiring = 2\n        \n        if chosen_rewiring:\n            # Remove old edges\n            rand_adj[a].remove(b); rand_adj[b].remove(a)\n            rand_adj[c].remove(d); rand_adj[d].remove(c)\n            \n            if chosen_rewiring == 1: # (a,d) and (b,c)\n                rand_adj[a].add(d); rand_adj[d].add(a)\n                rand_adj[b].add(c); rand_adj[c].add(b)\n                edges[idx1] = tuple(sorted((a,d)))\n                edges[idx2] = tuple(sorted((b,c)))\n            else: # chosen_rewiring == 2, (a,c) and (b,d)\n                rand_adj[a].add(c); rand_adj[c].add(a)\n                rand_adj[b].add(d); rand_adj[d].add(b)\n                edges[idx1] = tuple(sorted((a,c)))\n                edges[idx2] = tuple(sorted((b,d)))\n\n            successful_swaps += 1\n            \n    return rand_adj\n\ndef solve():\n    test_cases = [\n        {\n            \"n\": 12,\n            \"E\": [\n                (0,1),(0,2),(0,3),(0,4),(0,5),(1,2),(1,3),(1,4),(1,5),\n                (2,3),(2,4),(2,5),(3,4),(3,5),(4,5),\n                (6,0),(6,1),(7,2),(7,3),(8,4),(8,5),(9,0),(9,2),\n                (10,1),(10,4),(11,3),(11,5)\n            ],\n            \"k\": 5, \"R\": 200, \"S\": 270, \"s\": 12345\n        },\n        {\n            \"n\": 12,\n            \"E\": [\n                (0,1),(0,2),(0,3),(0,4),(1,2),(1,5),(1,6),(2,3),(2,7),\n                (3,4),(3,8),(4,5),(4,9),(5,6),(5,10),(6,7),(6,11),\n                (7,8),(7,9),(8,9),(8,10),(9,10),(10,11),(11,0),(11,3)\n            ],\n            \"k\": 4, \"R\": 200, \"S\": 250, \"s\": 2021\n        },\n        {\n            \"n\": 12,\n            \"E\": [(0,i) for i in range(1, 12)],\n            \"k\": 5, \"R\": 100, \"S\": 100, \"s\": 7\n        }\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        n, E, k, R, S, s = case[\"n\"], case[\"E\"], case[\"k\"], case[\"R\"], case[\"S\"], case[\"s\"]\n        \n        rng = np.random.default_rng(s)\n        \n        adj_obs = [set() for _ in range(n)]\n        for u, v in E:\n            adj_obs[u].add(v)\n            adj_obs[v].add(u)\n            \n        X_obs = k_core_size(adj_obs, k)\n        \n        null_core_sizes = []\n        for _ in range(R):\n            adj_random = perform_randomization(adj_obs, S, rng)\n            X_rand = k_core_size(adj_random, k)\n            null_core_sizes.append(X_rand)\n\n        null_dist = np.array(null_core_sizes, dtype=float)\n        mu = np.mean(null_dist)\n        sigma = np.std(null_dist)\n        \n        if sigma == 0.0:\n            Z = 0.0\n        else:\n            Z = (X_obs - mu) / sigma\n            \n        z_star = 2.0\n        reinforced = Z  z_star\n        \n        all_results.append([float(mu), int(X_obs), float(Z), bool(reinforced)])\n\n    # Format the final output string precisely\n    result_strings = []\n    for res in all_results:\n        # Convert boolean to lowercase as per common data exchange formats\n        bool_str = str(res[3]).lower()\n        res_str = f\"[{res[0]},{res[1]},{res[2]},{bool_str}]\"\n        result_strings.append(res_str)\n        \n    print(f\"[{','.join(result_strings)}]\")\n\nsolve()\n```"
        }
    ]
}