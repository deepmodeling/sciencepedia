{
    "hands_on_practices": [
        {
            "introduction": "The behavior of bootstrap percolation on regular lattices is a cornerstone of the field. This exercise guides you through the classic analysis of how a large system makes the transition to full activation. You will explore the concept of nucleation, where the global outcome hinges on the formation of rare, local 'critical droplets', and use the Poisson approximation to connect the microscopic seed probability $p$ to the macroscopic probability of spanning the entire grid .",
            "id": "4265156",
            "problem": "Consider two-neighbor bootstrap percolation on the two-dimensional integer lattice restricted to an $a \\times b$ rectangular region, with open boundary conditions. Each site is initially infected (a seed) independently with probability $p \\in (0,1)$, and the dynamics proceed in discrete time by infecting any healthy site that has at least $r=2$ infected nearest neighbors (in the sense of the von Neumann neighborhood), with infected sites remaining infected forever. A set is said to be internally spanned if, starting from the seeds contained within it and assuming all sites outside are healthy, the dynamics eventually infect every site in the set.\n\nUsing only fundamental definitions of two-neighbor bootstrap percolation and well-tested facts about the existence of a sharp critical length scale for $r=2$ in two dimensions, derive the leading-order asymptotics of the probability that the fixed $a \\times b$ rectangle is internally spanned as a function of $a$, $b$, and $p$ in the sparse-seed regime. In particular, assume the following scaling regime:\n- $p \\to 0$,\n- $a \\to \\infty$ and $b \\to \\infty$,\n- the product $a b$ grows with $p$ in such a way that\n$$\na b \\,\\exp\\!\\Big(-\\frac{\\pi^{2}}{18\\,p}\\Big) \\;\\longrightarrow\\; \\lambda \\in (0,\\infty) \\quad \\text{as } p \\to 0.\n$$\n\nUnder these assumptions, compute the limiting value of the internal spanning probability as an explicit closed-form function of the limit parameter $\\lambda$. Your final answer must be a single closed-form analytic expression in $\\lambda$ with no units. No rounding is required.\n\nAdditionally, in your derivation, analyze how the result encodes the scaling with $a$, $b$, and $p$, starting from the core definitions of bootstrap percolation and standard nucleation-droplet heuristics validated by rigorous results for the two-neighbor model in two dimensions. Do not invoke any shortcut formulas without justification from these bases.",
            "solution": "The problem asks for the asymptotic probability that an $a \\times b$ rectangle is internally spanned under two-neighbor bootstrap percolation, in a specific limiting regime where the initial seed probability $p$ tends to $0$.\n\nThe model is two-neighbor ($r=2$) bootstrap percolation on a rectangular subset of the two-dimensional integer lattice $\\mathbb{Z}^2$ of size $a \\times b$. Each site is initially designated as infected with an independent probability $p$. The process evolves in discrete time steps: any healthy site with at least $r=2$ infected nearest neighbors (in the von Neumann sense) becomes infected. Infected sites remain infected permanently. The rectangle is subject to open boundary conditions, meaning sites outside the rectangle are considered permanently healthy. An $a \\times b$ rectangle is said to be \"internally spanned\" if an initial configuration of seeds within the rectangle leads to the eventual infection of all $ab$ sites.\n\nWe are interested in the sparse-seed regime, where $p \\to 0$. In this regime, the global event of spanning a large region is an extremely rare occurrence. The dynamics are governed by a principle of nucleation and growth. For the entire rectangle to become infected, the initial random configuration of seeds must contain at least one \"critical nucleus\" or \"droplet\"—a local configuration of infected sites that is stable and can grow to infect its surroundings. If no such nucleus is formed, disconnected small clusters of infected sites will typically remain small and fail to propagate across the entire system.\n\nThe core of the problem relies on a well-established result for two-neighbor bootstrap percolation concerning the probability of forming a critical nucleus. The formation of a nucleus at any particular location is a specific local event, and its probability, which we can interpret as the density of nucleation centers $\\rho(p)$, is known to have a very strong dependence on $p$. For the $r=2$ model on $\\mathbb{Z}^2$, rigorous analysis has shown that the leading-order asymptotic behavior of this density is given by:\n$$\n\\rho(p) \\sim \\exp\\Big(-\\frac{\\pi^{2}}{18p}\\Big) \\quad \\text{as } p \\to 0\n$$\nThe constant $\\frac{\\pi^2}{18}$ is a non-trivial feature of this specific model. The problem statement gives a scaling relation that is explicitly built upon this fundamental result, guiding us to use it as a \"well-tested fact\".\n\nLet $N$ be the random variable representing the number of critical nuclei within the $a \\times b$ rectangle. The total number of sites in the rectangle is $ab$. Since $p \\to 0$, the formation of a nucleus is a very rare event. The events of nucleation at different sites, especially those far from each other, are approximately independent. In a large domain, the total count of occurrences of a rare, local, and nearly independent event is well-approximated by a Poisson distribution. We can therefore model $N$ as a Poisson random variable, $N \\sim \\text{Poisson}(\\mu)$.\n\nThe mean (or parameter) $\\mu$ of this Poisson distribution is the expected number of nuclei in the rectangle. This is given by the product of the number of potential locations for a nucleus (which is the area, $ab$) and the probability per site of forming a nucleus (the density $\\rho(p)$). Thus,\n$$\n\\mu = \\mathbb{E}[N] \\approx ab \\cdot \\rho(p)\n$$\nSubstituting the known asymptotic form of $\\rho(p)$, we have\n$$\n\\mu \\approx ab \\cdot \\exp\\Big(-\\frac{\\pi^{2}}{18p}\\Big)\n$$\nThe problem specifies a joint asymptotic limit where $p \\to 0$, $a \\to \\infty$, $b \\to \\infty$ in such a way that this very quantity converges to a finite, positive constant $\\lambda$:\n$$\nab \\exp\\Big(-\\frac{\\pi^{2}}{18p}\\Big) \\longrightarrow \\lambda\n$$\nThis precisely means that the expected number of critical nuclei in the rectangle converges to $\\lambda$. The scaling law is designed to ensure that in the limit, we are in a critical window where the number of nuclei is of order one.\n\nThe event that the $a \\times b$ rectangle is internally spanned is, in this limit, equivalent to the event that there is at least one critical nucleus within its boundaries, i.e., $N \\ge 1$. This is because any such nucleus, being \"critical,\" is by definition capable of self-sustained growth. Given the open boundary conditions and the diverging size of the rectangle ($a, b \\to \\infty$), a nucleus formed sufficiently far from the boundaries will grow to fill the entire domain. The probability of spanning the large rectangle without a proper nucleus, from sub-critical configurations, becomes negligible as $p \\to 0$.\n\nTherefore, the probability of the rectangle being internally spanned, $P_{\\text{span}}$, converges to the probability $P(N \\ge 1)$. For a Poisson random variable $N$ with mean $\\mu \\to \\lambda$, this probability is calculated as:\n$$\nP(N \\ge 1) = 1 - P(N=0)\n$$\nThe probability mass function of the Poisson distribution is $P(N=k) = \\frac{\\mu^k e^{-\\mu}}{k!}$. For $k=0$, we have:\n$$\nP(N=0) = \\frac{\\mu^0 e^{-\\mu}}{0!} = e^{-\\mu}\n$$\nAs we are in the limit where $\\mu \\to \\lambda$, the limiting probability of finding no nuclei is $e^{-\\lambda}$.\n\nConsequently, the limiting probability that the rectangle is spanned is:\n$$\n\\lim_{p \\to 0} P_{\\text{span}} = 1 - \\lim_{\\mu \\to \\lambda} e^{-\\mu} = 1 - e^{-\\lambda}\n$$\nThis result demonstrates how the scaling of the system's dimensions ($a$, $b$) and the seed probability ($p$) are coupled. The product $ab$ represents the volume of opportunities for nucleation, while the term $\\exp(-\\frac{\\pi^2}{18p})$ represents the extreme rarity of this event at any given location. Their product, $\\lambda$, is the expected number of \"successful\" nucleation events, which directly governs the probability of the macroscopic phase transition (spanning the system).",
            "answer": "$$\\boxed{1 - \\exp(-\\lambda)}$$"
        },
        {
            "introduction": "To fully appreciate the unique character of bootstrap percolation, it is instructive to compare it with other contagion models. This problem presents a specially designed graph to starkly contrast the outcomes of bootstrap dynamics and standard site percolation . By working through this example, you will analytically quantify how the cooperative threshold rule of bootstrap percolation can trigger a much more extensive cascade than simple node connectivity alone would permit.",
            "id": "4265164",
            "problem": "Consider the following family of graphs that highlight a contrast between standard site percolation and $r$-bootstrap percolation. Let $G_{m,d}$ consist of a fully connected core of $m$ nodes (a clique), where each core node has exactly $d$ distinct pendant neighbors (degree-one leaves) attached to it. The total number of nodes is $n = m(1+d)$. Perform standard site percolation by independently occupying each node with probability $\\phi \\in (0,1)$ and consider the largest connected component among the occupied nodes. Independently, initialize $r$-bootstrap percolation with threshold $r=2$ by declaring as initially active exactly those nodes that are occupied in the site percolation step, and then iteratively activate any node that has at least $r$ active neighbors, repeating until no further activations are possible. \n\nStarting from the core definitions that site percolation is an independent node-occupation process and that $r$-bootstrap percolation is an iterative threshold activation dynamics on a graph, analyze $G_{m,d}$ in the limit $m \\to \\infty$ at fixed $d$. \n\nYour tasks are:\n- Deduce, from first principles, whether the standard site percolation process yields a giant component for any fixed $\\phi \\in (0,1)$, and whether the $r$-bootstrap percolation process with $r=2$ fully activates the graph for the same $\\phi$.\n- Define the discrepancy $\\Delta(\\phi,d)$ as the limiting expected fraction of nodes that are active at the end of the $r$-bootstrap process minus the limiting expected fraction of nodes that belong to the largest connected component under standard site percolation, and derive a closed-form analytic expression for $\\Delta(\\phi,d)$.\n\nExpress the final answer as a single closed-form expression in terms of $\\phi$ and $d$. No numerical approximation is required; do not round. No physical units are involved in this problem.",
            "solution": "The problem requires an analysis of two processes, standard site percolation and $r$-bootstrap percolation, on a specific graph family $G_{m,d}$ in the limit where the core size $m \\to \\infty$ while the number of pendants per core node, $d$, remains fixed. The graph $G_{m,d}$ consists of a clique of $m$ core nodes, with each core node having $d$ distinct pendant neighbors (leaves). The total number of nodes in the graph is $n = m + md = m(1+d)$.\n\nLet's analyze each process separately to determine the expected fraction of nodes in the largest component or final active set.\n\n**1. Standard Site Percolation**\n\nIn standard site percolation, each node in $G_{m,d}$ is independently occupied with probability $\\phi \\in (0,1)$. We are interested in the size of the largest connected component (LCC) of occupied nodes.\n\nThe core of the graph is a clique of $m$ nodes. Any two occupied core nodes are, by definition, connected. Let $N_{core}^{occ}$ be the number of occupied core nodes. $N_{core}^{occ}$ follows a binomial distribution, $N_{core}^{occ} \\sim \\text{Bin}(m, \\phi)$. As $m \\to \\infty$, the probability of having $N_{core}^{occ} < 2$ tends to zero. Specifically, $P(N_{core}^{occ}=0)=(1-\\phi)^m \\to 0$ and $P(N_{core}^{occ}=1)=m\\phi(1-\\phi)^{m-1} \\to 0$. Therefore, with probability approaching $1$, we have at least two occupied core nodes, which form a single connected component among themselves. This component forms the nucleus of the LCC.\n\nFor an occupied pendant node to be part of a connected component of size greater than $1$, its unique core neighbor must also be part of that component. The LCC will thus consist of all occupied core nodes plus any occupied pendant nodes that are attached to an occupied core node.\n\nLet's calculate the expected size of the LCC, denoted by $\\langle S_{LCC} \\rangle$. By linearity of expectation, this is the sum of probabilities of each node being in the LCC.\nA core node is in the LCC if it is occupied. The expected number of occupied core nodes is $m\\phi$.\nA pendant node is in the LCC if it is occupied AND its core neighbor is occupied. Since these are independent events, the probability of a specific pendant node being in the LCC is $\\phi \\times \\phi = \\phi^2$. There are $md$ pendant nodes. So, the expected number of pendant nodes in the LCC is $md\\phi^2$.\n\nThe total expected size of the LCC is the sum of these two quantities:\n$$ \\langle S_{LCC} \\rangle = m\\phi + md\\phi^2 = m\\phi(1+d\\phi) $$\nThe expected fraction of nodes in the LCC is $\\langle S_{LCC} \\rangle/n$. In the limit $m \\to \\infty$:\n$$ \\lim_{m\\to\\infty} \\frac{\\langle S_{LCC} \\rangle}{n} = \\lim_{m\\to\\infty} \\frac{m\\phi(1+d\\phi)}{m(1+d)} = \\frac{\\phi(1+d\\phi)}{1+d} $$\nFor any fixed $\\phi \\in (0,1)$ and integer $d \\ge 1$, this fraction is strictly greater than $0$. A component containing a non-zero fraction of the total nodes in the infinite-system limit is a giant component. Thus, the standard site percolation process yields a giant component for any fixed $\\phi \\in (0,1)$.\n\n**2. $r$-Bootstrap Percolation with $r=2$**\n\nIn this process, the set of initially active nodes is the set of occupied nodes from the site percolation step. Subsequently, an inactive node becomes active if it has at least $r=2$ active neighbors. This rule is applied iteratively until no more nodes can be activated.\n\nLet's analyze the activation of different node types:\n-   **Pendant nodes**: A pendant node has degree $1$. It can never have $2$ or more active neighbors. Therefore, a pendant node can only be part of the final active set if it was initially active (i.e., occupied). It cannot be activated by the bootstrap dynamics.\n-   **Core nodes**: A core node is connected to all other $m-1$ core nodes. If at least two core nodes are initially active, say $C_i$ and $C_j$, then any other inactive core node $C_k$ has at least two active neighbors ($C_i$ and $C_j$). Consequently, $C_k$ will become active in the first step of the bootstrap process. This implies that if at least two core nodes are initially active, all $m$ core nodes will become active.\n\nThe number of initially active core nodes follows a binomial distribution $\\text{Bin}(m, \\phi)$. The probability of having fewer than two initially active core nodes is $P(\\text{fewer than 2}) = P(0) + P(1) = (1-\\phi)^m + m\\phi(1-\\phi)^{m-1}$. For any fixed $\\phi \\in (0,1)$, this probability tends to $0$ as $m \\to \\infty$. Thus, with probability approaching $1$, the entire core of $m$ nodes becomes active.\n\nLet's calculate the expected size of the final active set, $\\langle S_{BP} \\rangle$, in the limit $m \\to \\infty$.\nThe final active set consists of all core nodes (with probability approaching $1$) and all initially active pendant nodes.\nThe expected number of active core nodes, in the limit $m \\to \\infty$, is $m$.\nThe expected number of active pendant nodes is the expected number of initially occupied pendant nodes, which is $md\\phi$.\nThe total expected size of the final active set is:\n$$ \\langle S_{BP} \\rangle = m + md\\phi = m(1+d\\phi) $$\nThe limiting expected fraction of active nodes is then:\n$$ \\lim_{m\\to\\infty} \\frac{\\langle S_{BP} \\rangle}{n} = \\lim_{m\\to\\infty} \\frac{m(1+d\\phi)}{m(1+d)} = \\frac{1+d\\phi}{1+d} $$\nThe problem asks whether the process fully activates the graph. Full activation means the fraction of active nodes is $1$. The derived fraction is $1$ only if $1+d\\phi = 1+d$, which would require $\\phi=1$. Since the problem specifies $\\phi \\in (0,1)$, the fraction is always less than $1$. Therefore, the $r$-bootstrap percolation process does not fully activate the graph.\n\n**3. Discrepancy $\\Delta(\\phi, d)$**\n\nThe discrepancy $\\Delta(\\phi,d)$ is defined as the limiting expected fraction of active nodes in the bootstrap process minus the limiting expected fraction of nodes in the LCC under site percolation. Using the results derived above:\n$$ \\Delta(\\phi, d) = \\left( \\lim_{m\\to\\infty} \\frac{\\langle S_{BP} \\rangle}{n} \\right) - \\left( \\lim_{m\\to\\infty} \\frac{\\langle S_{LCC} \\rangle}{n} \\right) $$\n$$ \\Delta(\\phi, d) = \\frac{1+d\\phi}{1+d} - \\frac{\\phi(1+d\\phi)}{1+d} $$\nWe can simplify this expression by factoring out the common term $(1+d\\phi)$:\n$$ \\Delta(\\phi, d) = \\frac{(1+d\\phi) - \\phi(1+d\\phi)}{1+d} $$\n$$ \\Delta(\\phi, d) = \\frac{(1+d\\phi)(1-\\phi)}{1+d} $$\nThis can be expanded for an alternative form:\n$$ \\Delta(\\phi, d) = \\frac{1 - \\phi + d\\phi - d\\phi^2}{1+d} $$\nThis expression represents the limiting expected fraction of nodes that were initially unoccupied but became active during the bootstrap process. This occurs only for core nodes, which are recruited into the active set, and allows their respective occupied pendant neighbors (which would be isolated in site percolation) to be counted in the final active set.",
            "answer": "$$\\boxed{\\frac{(1-\\phi)(1+d\\phi)}{1+d}}$$"
        },
        {
            "introduction": "The definition of a dynamical process on a network often involves choices, such as whether updates occur simultaneously or one at a time. This exercise tackles the fundamental question of whether the final state of bootstrap percolation depends on this choice . You will first derive the theoretical result, which hinges on the crucial property of monotonicity, and then implement a simulation to empirically verify that synchronous and asynchronous updates indeed lead to the same outcome.",
            "id": "4265169",
            "problem": "Let a finite tree graph be denoted by $G = (V,E)$ with $|V| = n$ and undirected edges. Consider $r$-bootstrap percolation defined as follows: an initial active set $A_0 \\subseteq V$ is given. The dynamics are progressive, meaning once a vertex becomes active it remains active. The update rule is: an inactive vertex $v$ becomes active if and only if it has at least $r$ active neighbors. Two update schemes are considered: synchronous and asynchronous. In synchronous updates, all vertices that satisfy the activation rule at a given round are activated simultaneously. In asynchronous updates, vertices are updated one at a time in a random sequential order, repeatedly selecting a single vertex according to a random schedule and applying the same rule, until no further activation is possible. An absorbing set is any $A \\subseteq V$ such that further updates under the rule leave $A$ unchanged.\n\nFundamental base and definitions: A progressive dynamics is one in which state transitions are monotone with respect to set inclusion and do not deactivate vertices. The update operator $F$ for synchronous $r$-bootstrap percolation is defined by $F(A) = A \\cup \\{ v \\in V : |\\{u \\in N(v) : u \\in A\\}| \\ge r \\}$, where $N(v)$ is the neighbor set of $v$. The operator $F$ is monotone with respect to the partial order on subsets of $V$ induced by inclusion and is inflationary, meaning $A \\subseteq F(A)$. On a finite set $V$, repeated application of $F$ must stabilize at a fixed point that is the absorbing set reached from $A_0$. Asynchronous updates apply the same rule to single vertices and thus implement single-site monotone, inflationary operators whose compositions are also monotone and inflationary.\n\nTask: Derive, from the above base, whether the final absorbing set reached by asynchronous random sequential updates is the same as that reached by synchronous updates for $r$-bootstrap percolation on finite trees. Then implement a program to empirically verify the equality of the distribution of final absorbing set sizes between synchronous updates and asynchronous random sequential updates when the initial active set $A_0$ is generated by independent Bernoulli trials with activation probability $p$ at each vertex. For each test case $i$ in the suite below, the program must:\n- Construct the specified tree $G_i$.\n- For $T$ independent trials, sample $A_0$ by including each vertex independently with probability $p$ (expressed as a decimal in $[0,1]$).\n- Compute the final absorbing set size under synchronous updates and under asynchronous random sequential updates starting from the same $A_0$ for each trial.\n- Aggregate the empirical distributions of final sizes for both schemes and compute the total variation distance between them, defined as $\\frac{1}{2} \\sum_{k=0}^{n} |P(k) - Q(k)|$, where $P(k)$ and $Q(k)$ are the empirical probabilities of final size $k$ under synchronous and asynchronous updates, respectively.\n\nYour program must output a single line containing a comma-separated list enclosed in square brackets of the total variation distances (each a float) for the following test suite, in the specified order:\n- Case $1$: Path tree with $n = 20$, threshold $r = 1$, initial activation probability $p = 0.1$, trials $T = 500$.\n- Case $2$: Star tree with $n = 21$ (one center, $20$ leaves), threshold $r = 2$, initial activation probability $p = 0.2$, trials $T = 500$.\n- Case $3$: Complete binary tree of height $h = 5$ (thus $n = 2^{h+1} - 1 = 63$), threshold $r = 2$, initial activation probability $p = 0.05$, trials $T = 500$.\n- Case $4$: Path tree with $n = 50$, threshold $r = 10$, initial activation probability $p = 0.3$, trials $T = 500$.\n- Case $5$: Complete binary tree of height $h = 4$ (thus $n = 2^{h+1} - 1 = 31$), threshold $r = 1$, initial activation probability $p = 0.0$, trials $T = 500$.\n\nFinal output format requirement: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[x_1,x_2,x_3,x_4,x_5]$), where each $x_i$ is the computed total variation distance (a float) for case $i$.",
            "solution": "The problem asks for two tasks: first, a theoretical derivation concerning the final state of synchronous versus asynchronous bootstrap percolation on finite trees; and second, an empirical verification of the result via a computational experiment.\n\n### Theoretical Derivation\n\nThe core of the question is whether the choice of update scheme—synchronous versus asynchronous random sequential—affects the final absorbing set for $r$-bootstrap percolation. The process is defined on a finite graph $G = (V,E)$. The dynamics are progressive, meaning the set of active vertices, denoted by $A$, can only grow.\n\nLet's formalize the update operators. The initial set of active vertices is $A_0$.\n\nThe **synchronous update** operator, $F$, is defined as:\n$$F(A) = A \\cup \\{ v \\in V \\setminus A : |N(v) \\cap A| \\ge r \\}$$\nwhere $N(v)$ is the set of neighbors of vertex $v$. The final absorbing set under synchronous updates, $A_{sync}^*$, is the fixed point obtained by iterating $F$ starting from $A_0$, i.e., $A_{sync}^* = \\lim_{k \\to \\infty} F^k(A_0)$. This limit is guaranteed to exist because $V$ is finite and $F$ is inflationary ($A \\subseteq F(A)$).\n\nThe **asynchronous update** scheme involves applying single-site operators. For each vertex $i \\in V$, let $F_i$ be the operator that updates only vertex $i$:\n$$F_i(A) = \\begin{cases} A \\cup \\{i\\} & \\text{if } i \\notin A \\text{ and } |N(i) \\cap A| \\ge r \\\\ A & \\text{otherwise} \\end{cases}$$\nAn asynchronous process is a sequence of applications of these single-site operators, $A_{k+1} = F_{i_k}(A_k)$, for some schedule of vertices $\\{i_k\\}$. The final absorbing set, $A_{async}^*$, is the fixed point reached when no more single-vertex activations are possible.\n\nThe problem states, and it is a key property, that these operators are **monotone**. For any operator $\\mathcal{F}$ in our system (be it $F$ or any $F_i$), monotonicity means that if $A \\subseteq B \\subseteq V$, then $\\mathcal{F}(A) \\subseteq \\mathcal{F}(B)$. This property is crucial for proving the equivalence of the final states.\n\nWe will now prove that $A_{sync}^* = A_{async}^*$ for any finite graph (the result is not limited to trees). We do so by showing mutual set inclusion.\n\n**1. Proof of $A_{async}^* \\subseteq A_{sync}^*$**\n\nLet the sequence of active sets in an asynchronous update process be $A_0, A_1, A_2, \\ldots, A_{async}^*$, where $A_{k+1} = F_{v_k}(A_k)$ for some chosen vertex $v_k$. We prove by induction that $A_k \\subseteq A_{sync}^*$ for all $k \\ge 0$.\n\n*   **Base Case ($k=0$):** $A_0 \\subseteq A_{sync}^*$ by the definition of $A_{sync}^*$ as the closure of $A_0$ under the inflationary operator $F$.\n\n*   **Inductive Step:** Assume $A_k \\subseteq A_{sync}^*$ for some $k \\ge 0$. We need to show $A_{k+1} \\subseteq A_{sync}^*$.\n    The set $A_{k+1}$ is either $A_k$ or $A_k \\cup \\{v_k\\}$. If $A_{k+1} = A_k$, the claim holds trivially.\n    If $A_{k+1} = A_k \\cup \\{v_k\\}$, this means vertex $v_k$ was activated. By the rule, $v_k \\notin A_k$ and $|N(v_k) \\cap A_k| \\ge r$.\n    From the inductive hypothesis, $A_k \\subseteq A_{sync}^*$. By monotonicity of set intersection, $N(v_k) \\cap A_k \\subseteq N(v_k) \\cap A_{sync}^*$.\n    This implies $|N(v_k) \\cap A_{sync}^*| \\ge |N(v_k) \\cap A_k| \\ge r$.\n    So, vertex $v_k$ satisfies the activation condition with respect to the set $A_{sync}^*$.\n    Since $A_{sync}^*$ is a fixed point of the synchronous operator $F$, we have $F(A_{sync}^*) = A_{sync}^*$. This means there are no vertices outside $A_{sync}^*$ that can be activated from it. As $v_k$ can be activated from $A_{sync}^*$, it must be that $v_k \\in A_{sync}^*$.\n    Therefore, $A_{k+1} = A_k \\cup \\{v_k\\} \\subseteq A_{sync}^* \\cup \\{v_k\\} = A_{sync}^*$.\n\nBy induction, every set in the asynchronous sequence is a subset of $A_{sync}^*$. This includes the final absorbing set, so $A_{async}^* \\subseteq A_{sync}^*$.\n\n**2. Proof of $A_{sync}^* \\subseteq A_{async}^*$**\n\nLet the sequence of active sets in the synchronous update process be $A^{(0)}, A^{(1)}, A^{(2)}, \\ldots$, where $A^{(0)}=A_0$ and $A^{(k+1)} = F(A^{(k)})$. The union of these sets is $A_{sync}^*$. We prove by induction that $A^{(k)} \\subseteq A_{async}^*$ for all $k \\ge 0$.\n\n*   **Base Case ($k=0$):** $A^{(0)} = A_0$. Since the asynchronous process is progressive and starts from $A_0$, we have $A_0 \\subseteq A_{async}^*$.\n\n*   **Inductive Step:** Assume $A^{(k)} \\subseteq A_{async}^*$ for some $k \\ge 0$. We need to show $A^{(k+1)} \\subseteq A_{async}^*$.\n    By definition, $A^{(k+1)} = F(A^{(k)}) = A^{(k)} \\cup \\{v \\in V \\setminus A^{(k)} : |N(v) \\cap A^{(k)}| \\ge r\\}$.\n    Let $v$ be any vertex in $A^{(k+1)}$.\n    If $v \\in A^{(k)}$, then by the inductive hypothesis, $v \\in A_{async}^*$.\n    If $v \\notin A^{(k)}$, then its activation implies $|N(v) \\cap A^{(k)}| \\ge r$.\n    From the inductive hypothesis, $A^{(k)} \\subseteq A_{async}^*$. Thus, $|N(v) \\cap A_{async}^*| \\ge |N(v) \\cap A^{(k)}| \\ge r$.\n    This means vertex $v$ satisfies the activation condition with respect to the set $A_{async}^*$.\n    Since $A_{async}^*$ is an absorbing set for the asynchronous process, no vertex outside of it can be activated. Formally, for any $u \\notin A_{async}^*$, $|N(u) \\cap A_{async}^*| < r$.\n    As $v$ satisfies the condition $|N(v) \\cap A_{async}^*| \\ge r$, it must be that $v \\in A_{async}^*$.\n    Thus, any vertex $v \\in A^{(k+1)}$ is also in $A_{async}^*$, which means $A^{(k+1)} \\subseteq A_{async}^*$.\n\nBy induction, $A^{(k)} \\subseteq A_{async}^*$ for all $k$. Therefore, their union, $A_{sync}^* = \\bigcup_{k \\ge 0} A^{(k)}$, must also be a subset of $A_{async}^*$.\n\n**Conclusion**\n\nHaving shown both $A_{async}^* \\subseteq A_{sync}^*$ and $A_{sync}^* \\subseteq A_{async}^*$, we conclude that $A_{sync}^* = A_{async}^*$. The final absorbing set is independent of the update scheme (synchronous or asynchronous) for any $r$-bootstrap percolation process on any finite graph.\n\nThis theoretical result implies that for any given initial active set $A_0$, the final size of the absorbing set will be identical for both schemes. Consequently, when $A_0$ is sampled randomly, the resulting probability distributions of final sizes for the two schemes must be identical. The total variation distance between these two empirical distributions should therefore be $0.0$. Any non-zero result from the simulation would be attributable to subtle implementation differences rather than the underlying theory.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef create_path_graph(n):\n    \"\"\"Creates an adjacency list for a path graph of n vertices.\"\"\"\n    if n <= 0:\n        return {}\n    adj = {i: [] for i in range(n)}\n    for i in range(n - 1):\n        adj[i].append(i + 1)\n        adj[i + 1].append(i)\n    return adj\n\ndef create_star_graph(n):\n    \"\"\"Creates an adjacency list for a star graph of n vertices.\"\"\"\n    if n <= 0:\n        return {}\n    adj = {i: [] for i in range(n)}\n    center = 0\n    for i in range(1, n):\n        adj[center].append(i)\n        adj[i].append(center)\n    return adj\n\ndef create_binary_tree(h):\n    \"\"\"Creates an adjacency list for a complete binary tree of height h.\"\"\"\n    n = 2**(h + 1) - 1\n    if n <= 0:\n        return {}\n    adj = {i: [] for i in range(n)}\n    # Iterate through all possible parent nodes\n    for i in range((n - 1) // 2 + 1):\n        left_child = 2 * i + 1\n        right_child = 2 * i + 2\n        if left_child < n:\n            adj[i].append(left_child)\n            adj[left_child].append(i)\n        if right_child < n:\n            adj[i].append(right_child)\n            adj[right_child].append(i)\n    return adj\n\ndef simulate_sync(adj, r, initial_active):\n    \"\"\"Simulates r-bootstrap percolation with synchronous updates.\"\"\"\n    n = len(adj)\n    active = initial_active.copy()\n    \n    while True:\n        to_activate = []\n        for i in range(n):\n            if not active[i]:\n                active_neighbors = 0\n                for neighbor in adj[i]:\n                    if active[neighbor]:\n                        active_neighbors += 1\n                if active_neighbors >= r:\n                    to_activate.append(i)\n        \n        if not to_activate:\n            break\n        \n        for i in to_activate:\n            active[i] = True\n            \n    return np.sum(active)\n\ndef simulate_async(adj, r, initial_active):\n    \"\"\"Simulates r-bootstrap percolation with asynchronous random sequential updates.\"\"\"\n    n = len(adj)\n    active = initial_active.copy()\n    \n    while True:\n        changed_in_pass = False\n        update_order = np.random.permutation(n)\n        for i in update_order:\n            if not active[i]:\n                active_neighbors = 0\n                for neighbor in adj[i]:\n                    if active[neighbor]:\n                        active_neighbors += 1\n                if active_neighbors >= r:\n                    active[i] = True\n                    changed_in_pass = True\n        \n        if not changed_in_pass:\n            break\n            \n    return np.sum(active)\n\ndef solve():\n    \"\"\"\n    Runs the empirical verification for the test suite and prints the results.\n    \"\"\"\n    test_cases = [\n        {'type': 'path', 'params': {'n': 20}, 'r': 1, 'p': 0.1, 'T': 500},\n        {'type': 'star', 'params': {'n': 21}, 'r': 2, 'p': 0.2, 'T': 500},\n        {'type': 'binary_tree', 'params': {'h': 5}, 'r': 2, 'p': 0.05, 'T': 500},\n        {'type': 'path', 'params': {'n': 50}, 'r': 10, 'p': 0.3, 'T': 500},\n        {'type': 'binary_tree', 'params': {'h': 4}, 'r': 1, 'p': 0.0, 'T': 500},\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        T = case['T']\n        p = case['p']\n        r = case['r']\n        \n        if case['type'] == 'path':\n            n = case['params']['n']\n            adj = create_path_graph(n)\n        elif case['type'] == 'star':\n            n = case['params']['n']\n            adj = create_star_graph(n)\n        elif case['type'] == 'binary_tree':\n            h = case['params']['h']\n            n = 2**(h + 1) - 1\n            adj = create_binary_tree(h)\n\n        sync_hist = np.zeros(n + 1, dtype=np.int32)\n        async_hist = np.zeros(n + 1, dtype=np.int32)\n        \n        for _ in range(T):\n            # Generate the same initial active set for both schemes in each trial\n            initial_active = np.random.rand(n) < p\n            \n            # Run synchronous simulation\n            sync_size = simulate_sync(adj, r, initial_active)\n            sync_hist[sync_size] += 1\n            \n            # Run asynchronous simulation\n            async_size = simulate_async(adj, r, initial_active)\n            async_hist[async_size] += 1\n\n        # Calculate empirical probability distributions\n        P_sync = sync_hist / T\n        P_async = async_hist / T\n        \n        # Calculate Total Variation Distance\n        tv_distance = 0.5 * np.sum(np.abs(P_sync - P_async))\n        results.append(tv_distance)\n\n    # Print the final result in the specified format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}