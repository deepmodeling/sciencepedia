{
    "hands_on_practices": [
        {
            "introduction": "要真正理解一个新模型，关键一步是将其与已有的模型进行对比。本练习旨在揭示自举渗流（bootstrap percolation）与标准位点渗流（standard site percolation）在根本机制上的差异。通过在一个精心设计的图结构上进行分析，你将亲身体会到，简单的连通性规则与基于局部阈值的“协作”激活规则会如何导致截然不同的宏观结果 。",
            "id": "4265164",
            "problem": "考虑以下图族，它突出了标准位点渗流和 $r$-自举渗流之间的差异。设 $G_{m,d}$ 由一个包含 $m$ 个节点的全连接核心（一个团）组成，其中每个核心节点都连接着 $d$ 个不同的悬垂邻居（度为1的叶节点）。节点总数为 $n = m(1+d)$。通过以概率 $\\phi \\in (0,1)$ 独立占据每个节点来进行标准位点渗流，并考虑被占据节点中的最大连通分量。独立地，以阈值 $r=2$ 初始化 $r$-自举渗流，将位点渗流步骤中被占据的节点声明为初始激活节点，然后迭代地激活任何至少有 $r$ 个激活邻居的节点，重复此过程直到没有更多节点可以被激活。\n\n从位点渗流是独立的节点占据过程以及 $r$-自举渗流是图上的迭代阈值激活动力学这两个核心定义出发，在固定 $d$ 的条件下，分析 $m \\to \\infty$ 极限下的 $G_{m,d}$。\n\n您的任务是：\n- 从第一性原理出发，推断对于任何固定的 $\\phi \\in (0,1)$，标准位点渗流过程是否会产生巨分量，以及对于相同的 $\\phi$，阈值为 $r=2$ 的 $r$-自举渗流过程是否会完全激活整个图。\n- 将差异 $\\Delta(\\phi,d)$ 定义为 $r$-自举渗流过程结束时激活节点的极限期望分数与标准位点渗流下属于最大连通分量的节点的极限期望分数之差，并推导 $\\Delta(\\phi,d)$ 的闭式解析表达式。\n\n将最终答案表示为关于 $\\phi$ 和 $d$ 的单个闭式表达式。不需要数值近似；不要四舍五入。本问题不涉及物理单位。",
            "solution": "该问题被评估为有效，因为它在网络科学中有科学依据，问题设定良好，客观且内部一致。它提出了一个可解的理论问题，没有任何事实或逻辑缺陷。\n\n该问题要求在一个特定的图族 $G_{m,d}$ 上，在核心大小 $m \\to \\infty$ 而每个核心节点的悬垂节点数 $d$ 保持固定的极限下，分析两个过程：标准位点渗流和 $r$-自举渗流。图 $G_{m,d}$ 由一个包含 $m$ 个核心节点的团组成，每个核心节点有 $d$ 个不同的悬垂邻居（叶节点）。图中节点的总数为 $n = m + md = m(1+d)$。\n\n让我们分别分析每个过程，以确定最大分量或最终激活集中的节点期望分数。\n\n**1. 标准位点渗流**\n\n在标准位点渗流中，$G_{m,d}$ 中的每个节点都以概率 $\\phi \\in (0,1)$ 被独立占据。我们关心的是被占据节点的最大连通分量（LCC）的大小。\n\n图的核心是一个包含 $m$ 个节点的团。根据定义，任何两个被占据的核心节点都是相连的。设 $N_{core}^{occ}$ 为被占据的核心节点数。$N_{core}^{occ}$ 服从二项分布，$N_{core}^{occ} \\sim \\text{Bin}(m, \\phi)$。当 $m \\to \\infty$ 时，被占据的核心节点数小于2（即 $N_{core}^{occ}  2$）的概率趋于零。具体来说，$P(N_{core}^{occ}=0)=(1-\\phi)^m \\to 0$ 且 $P(N_{core}^{occ}=1)=m\\phi(1-\\phi)^{m-1} \\to 0$。因此，以趋近于 $1$ 的概率，我们至少有两个被占据的核心节点，它们自身形成一个单一的连通分量。这个分量构成了 LCC 的核。\n\n悬垂节点是度为 $1$ 的叶节点。它唯一的邻居是一个核心节点。对于一个被占据的悬垂节点，要成为大于 $1$ 的连通分量的一部分，其唯一的邻居核心节点也必须是该分量的一部分。因此，LCC 将由所有被占据的核心节点，加上任何连接到被占据核心节点的被占据的悬垂节点组成。\n\n我们来计算 LCC 的期望大小，记为 $\\langle S_{LCC} \\rangle$。根据期望的线性性质，这是每个节点属于 LCC 的概率之和。\n如果一个核心节点被占据，它就在 LCC 中。被占据的核心节点的期望数量是 $m\\phi$。\n如果一个悬垂节点被占据且其核心邻居也被占据，它就在 LCC 中。由于这些是独立事件，一个特定的悬垂节点属于 LCC 的概率是 $\\phi \\times \\phi = \\phi^2$。共有 $md$ 个悬垂节点。所以，LCC 中悬垂节点的期望数量是 $md\\phi^2$。\n\nLCC 的总期望大小是这两项之和：\n$$ \\langle S_{LCC} \\rangle = m\\phi + md\\phi^2 = m\\phi(1+d\\phi) $$\nLCC 中节点的期望分数是 $\\langle S_{LCC} \\rangle/n$。在 $m \\to \\infty$ 的极限下：\n$$ \\lim_{m\\to\\infty} \\frac{\\langle S_{LCC} \\rangle}{n} = \\lim_{m\\to\\infty} \\frac{m\\phi(1+d\\phi)}{m(1+d)} = \\frac{\\phi(1+d\\phi)}{1+d} $$\n对于任何固定的 $\\phi \\in (0,1)$ 和整数 $d \\ge 1$，这个分数严格大于 $0$。在无限系统极限下，包含总节点数非零分数的连通分量就是巨分量。因此，标准位点渗流过程对于任何固定的 $\\phi \\in (0,1)$ 都会产生一个巨分量。\n\n**2. $r=2$ 的 $r$-自举渗流**\n\n在此过程中，初始激活节点的集合是位点渗流步骤中被占据的节点集合。随后，一个非激活节点如果至少有 $r=2$ 个激活邻居，就会变为激活状态。此规则被迭代应用，直到没有更多节点可以被激活。\n\n我们来分析不同类型节点的激活情况：\n- **悬垂节点**：悬垂节点的度为 $1$。它永远不可能有 $2$ 个或更多的激活邻居。因此，一个悬垂节点只有在初始时是激活的（即被占据的），才能成为最终激活集的一部分。它不能被自举动力学激活。\n- **核心节点**：一个核心节点连接到所有其他 $m-1$ 个核心节点。如果至少有两个核心节点初始激活，比如 $C_i$ 和 $C_j$，那么任何其他非激活的核心节点 $C_k$ 都至少有两个激活邻居（$C_i$ 和 $C_j$）。因此，$C_k$ 将在自举过程的第一步被激活。这意味着如果至少有两个核心节点初始激活，所有 $m$ 个核心节点都将变为激活状态。\n\n初始激活的核心节点数服从二项分布 $\\text{Bin}(m, \\phi)$。初始激活的核心节点少于两个的概率是 $P(\\text{fewer than 2}) = P(0) + P(1) = (1-\\phi)^m + m\\phi(1-\\phi)^{m-1}$。对于任何固定的 $\\phi \\in (0,1)$，当 $m \\to \\infty$ 时，这个概率趋于 $0$。因此，以趋近于 $1$ 的概率，整个包含 $m$ 个节点的核心都会被激活。\n\n我们来计算在 $m \\to \\infty$ 极限下，最终激活集 $\\langle S_{BP} \\rangle$ 的期望大小。\n最终激活集由所有核心节点（以趋近于 $1$ 的概率）和所有初始激活的悬垂节点组成。\n在 $m \\to \\infty$ 极限下，激活核心节点的期望数量是 $m$。\n激活悬垂节点的期望数量等于初始被占据的悬垂节点的期望数量，即 $md\\phi$。\n最终激活集的总期望大小是：\n$$ \\langle S_{BP} \\rangle = m + md\\phi = m(1+d\\phi) $$\n那么，激活节点的极限期望分数是：\n$$ \\lim_{m\\to\\infty} \\frac{\\langle S_{BP} \\rangle}{n} = \\lim_{m\\to\\infty} \\frac{m(1+d\\phi)}{m(1+d)} = \\frac{1+d\\phi}{1+d} $$\n问题询问该过程是否完全激活了图。完全激活意味着激活节点的比例为 $1$。推导出的比例仅在 $1+d\\phi = 1+d$ 时才为 $1$，这要求 $\\phi=1$。由于问题指定 $\\phi \\in (0,1)$，该比例总是小于 $1$。因此，$r$-自举渗流过程不会完全激活整个图。\n\n**3. 差异 $\\Delta(\\phi, d)$**\n\n差异 $\\Delta(\\phi,d)$ 定义为自举过程中激活节点的极限期望分数减去位点渗流下 LCC 中节点的极限期望分数。使用上面推导的结果：\n$$ \\Delta(\\phi, d) = \\left( \\lim_{m\\to\\infty} \\frac{\\langle S_{BP} \\rangle}{n} \\right) - \\left( \\lim_{m\\to\\infty} \\frac{\\langle S_{LCC} \\rangle}{n} \\right) $$\n$$ \\Delta(\\phi, d) = \\frac{1+d\\phi}{1+d} - \\frac{\\phi(1+d\\phi)}{1+d} $$\n我们可以通过提取公因式 $(1+d\\phi)$ 来简化这个表达式：\n$$ \\Delta(\\phi, d) = \\frac{(1+d\\phi) - \\phi(1+d\\phi)}{1+d} $$\n$$ \\Delta(\\phi, d) = \\frac{(1+d\\phi)(1-\\phi)}{1+d} $$\n这可以展开得到另一种形式：\n$$ \\Delta(\\phi, d) = \\frac{1 - \\phi + d\\phi - d\\phi^2}{1+d} $$\n这个表达式代表了在自举过程中，初始未被占据但后来被激活的节点的极限期望分数。这种情况只发生在核心节点上，它们被招募进激活集，并使得它们各自被占据的悬垂邻居（在位点渗流中会被孤立）能够被计入最终的激活集中。",
            "answer": "$$\\boxed{\\frac{(1-\\phi)(1+d\\phi)}{1+d}}$$"
        },
        {
            "introduction": "在理解了自举渗流的独特性质后，我们将从定性比较转向对其相变的定量分析。在初始种子稀疏的情况下，系统的全局激活通常依赖于“成核”（nucleation）这一罕见事件的发生。本练习将引导你运用泊松统计（Poisson statistics）这一统计物理中的强大工具，推导系统被完全激活的概率，从而深刻理解系统尺寸（$a$, $b$）与种子密度（$p$）之间是如何通过成核物理联系起来的 。",
            "id": "4265156",
            "problem": "考虑在二维整数晶格上限制于一个 $a \\times b$ 矩形区域内的二邻居自举渗流，边界条件为开放边界。每个位点最初以独立的概率 $p \\in (0,1)$ 被感染（成为一个种子），动力学过程以离散时间步进，任何拥有至少 $r=2$ 个已感染最近邻（冯·诺依曼邻域意义上）的健康位点都会被感染，而已感染的位点将永远保持感染状态。如果从一个集合内部包含的种子开始，并假设集合外的所有位点都为健康，动力学过程最终感染了该集合中的每一个位点，则称该集合是内部张成的。\n\n仅使用二邻居自举渗流的基本定义以及关于二维中 $r=2$ 时存在一个尖锐临界长度标尺的已验证事实，推导在稀疏种子情境下，固定的 $a \\times b$ 矩形被内部张成的概率作为 $a$、$b$ 和 $p$ 的函数的主阶渐近行为。特别地，假设以下标度情境：\n- $p \\to 0$，\n- $a \\to \\infty$ 且 $b \\to \\infty$，\n- 乘积 $a b$ 随 $p$ 增长的方式使得\n$$\na b \\,\\exp\\!\\Big(-\\frac{\\pi^{2}}{18\\,p}\\Big) \\;\\longrightarrow\\; \\lambda \\in (0,\\infty) \\quad \\text{当 } p \\to 0 \\text{ 时}.\n$$\n\n在这些假设下，计算内部张成概率的极限值，其形式为极限参数 $\\lambda$ 的一个显式闭式函数。您的最终答案必须是关于 $\\lambda$ 的单一闭式解析表达式，无单位。无需四舍五入。\n\n此外，在您的推导中，请从自举渗流的核心定义以及经二维二邻居模型严格结果验证的标准成核-液滴启发式方法出发，分析该结果如何编码了与 $a$、$b$ 和 $p$ 的标度关系。未经这些基础的证明，请勿援引任何快捷公式。",
            "solution": "问题要求在初始种子概率 $p$ 趋于 $0$ 的特定极限情境下，一个 $a \\times b$ 矩形在二邻居自举渗流下被内部张成的渐近概率。\n\n该模型是二维整数晶格 $\\mathbb{Z}^2$ 上一个尺寸为 $a \\times b$ 的矩形子集上的二邻居（$r=2$）自举渗流。每个位点最初以独立的概率 $p$ 被指定为已感染。该过程以离散时间步演化：任何拥有至少 $r=2$ 个已感染最近邻（冯·诺依曼意义上）的健康位点都会被感染。已感染的位点将永久保持感染状态。矩形受开放边界条件限制，意味着矩形外的位点被视为永久健康。如果矩形内的一个初始种子构型最终导致所有 $ab$ 个位点被感染，则称该 $a \\times b$ 矩形是“内部张成的”。\n\n我们关心的是稀疏种子情境，其中 $p \\to 0$。在这种情境下，张成一个大区域的全局事件是极其罕见的。动力学由成核和生长原理支配。为使整个矩形被感染，初始的随机种子构型必须包含至少一个“临界核”或“液滴”——一个稳定的、能够生长以感染其周围环境的局部已感染位点构型。如果没有形成这样的核，不连通的小感染簇通常会保持很小，无法在整个系统中传播。\n\n问题的核心依赖于一个关于二邻居自举渗流形成临界核概率的公认结果。在任何特定位置形成一个核是一个特定的局部事件，其概率，我们可以解释为成核中心密度 $\\rho(p)$，已知对 $p$ 有非常强的依赖性。对于 $\\mathbb{Z}^2$ 上的 $r=2$ 模型，严格的分析表明，该密度的主要渐近行为由下式给出：\n$$\n\\rho(p) \\sim \\exp\\Big(-\\frac{\\pi^{2}}{18p}\\Big) \\quad \\text{当 } p \\to 0 \\text{ 时}\n$$\n常数 $\\frac{\\pi^2}{18}$ 是这个特定模型的一个非平凡特征。问题陈述给出的标度关系明确地建立在这个基本结果之上，引导我们将其作为一个“已验证事实”来使用。\n\n令 $N$ 为表示 $a \\times b$ 矩形内临界核数量的随机变量。矩形中的总位点数为 $ab$。由于 $p \\to 0$，形成一个核是一个非常罕见的事件。在不同位点（尤其是相距很远的位点）的成核事件近似独立。在一个大区域中，一个罕见的、局部的、近似独立的事件发生总次数可以很好地用泊松分布来近似。因此，我们可以将 $N$ 建模为一个泊松随机变量，即 $N \\sim \\text{Poisson}(\\mu)$。\n\n这个泊松分布的均值（或参数）$\\mu$ 是矩形中核的期望数量。它由核的潜在位置数（即面积 $ab$）与每个位点形成核的概率（密度 $\\rho(p)$）的乘积给出。因此，\n$$\n\\mu = \\mathbb{E}[N] \\approx ab \\cdot \\rho(p)\n$$\n代入已知的 $\\rho(p)$ 的渐近形式，我们有\n$$\n\\mu \\approx ab \\cdot \\exp\\Big(-\\frac{\\pi^{2}}{18p}\\Big)\n$$\n问题指定了一个联合渐近极限，其中 $p \\to 0$，$a \\to \\infty$，$b \\to \\infty$，且其方式使得这个量收敛到一个有限的正数常量 $\\lambda$：\n$$\nab \\exp\\Big(-\\frac{\\pi^{2}}{18p}\\Big) \\longrightarrow \\lambda\n$$\n这恰好意味着矩形中临界核的期望数量收敛于 $\\lambda$。该标度定律旨在确保在极限情况下，我们处于一个临界窗口，其中核的数量为一阶。\n\n在这个极限下，$a \\times b$ 矩形被内部张成的事件等价于其边界内至少存在一个临界核的事件，即 $N \\ge 1$。这是因为任何这样的核，由于是“临界的”，根据定义能够自我维持生长。考虑到开放边界条件和矩形尺寸的发散性（$a, b \\to \\infty$），一个在离边界足够远的地方形成的核将会生长并填满整个区域。当 $p \\to 0$ 时，从亚临界构型出发张成大矩形的概率变得可以忽略不计。\n\n因此，矩形被内部张成的概率 $P_{\\text{span}}$ 收敛于概率 $P(N \\ge 1)$。对于一个均值 $\\mu \\to \\lambda$ 的泊松随机变量 $N$，这个概率计算如下：\n$$\nP(N \\ge 1) = 1 - P(N=0)\n$$\n泊松分布的概率质量函数为 $P(N=k) = \\frac{\\mu^k e^{-\\mu}}{k!}$。对于 $k=0$，我们有：\n$$\nP(N=0) = \\frac{\\mu^0 e^{-\\mu}}{0!} = e^{-\\mu}\n$$\n由于我们处于 $\\mu \\to \\lambda$ 的极限下，没有找到核的极限概率是 $e^{-\\lambda}$。\n\n因此，矩形被张成的极限概率是：\n$$\n\\lim_{p \\to 0} P_{\\text{span}} = 1 - \\lim_{\\mu \\to \\lambda} e^{-\\mu} = 1 - e^{-\\lambda}\n$$\n这个结果展示了系统维度（$a$、$b$）的标度与种子概率（$p$）是如何耦合的。乘积 $ab$ 代表了成核机会的体积，而项 $\\exp(-\\frac{\\pi^2}{18p})$ 代表了在任何给定位置该事件的极端稀有性。它们的乘积 $\\lambda$ 是“成功”成核事件的期望数量，它直接决定了宏观相变（张成系统）的概率。",
            "answer": "$$\\boxed{1 - \\exp(-\\lambda)}$$"
        },
        {
            "introduction": "最后，我们将注意力转向动力学过程本身。在许多复杂系统中，事件发生的顺序至关重要，可能导致不同的最终结局。本练习结合了理论证明与计算实验，旨在揭示自举渗流的一个核心特性：其动力学的单调性（monotonicity）保证了无论节点是同时更新（同步）还是一次一个地更新（异步），最终的激活状态都是唯一的 。这一性质极大地简化了对此类系统的分析，是一个具有普遍意义的基础性结论。",
            "id": "4265169",
            "problem": "设一个有限树图表示为 $G = (V,E)$，其中 $|V| = n$ 且边是无向的。考虑如下定义的 $r$-自举渗流：给定一个初始激活集 $A_0 \\subseteq V$。该动力学过程是递进的，意味着一个顶点一旦被激活，它将保持激活状态。更新规则是：一个未激活的顶点 $v$ 变为激活状态，当且仅当它至少有 $r$ 个激活的邻居。考虑两种更新方案：同步更新和异步更新。在同步更新中，给定一轮中所有满足激活规则的顶点会同时被激活。在异步更新中，顶点以随机序列的方式逐个更新，根据一个随机序列重复地选择单个顶点并应用相同的规则，直到没有进一步的激活可能发生。吸收集是任意满足在该规则下进一步更新后保持不变的集合 $A \\subseteq V$。\n\n基本依据与定义：递进动力学是一种状态转换关于集合包含关系是单调的，且不会使顶点失活的动力学过程。同步 $r$-自举渗流的更新算子 $F$ 定义为 $F(A) = A \\cup \\{ v \\in V : |\\{u \\in N(v) : u \\in A\\}| \\ge r \\}$，其中 $N(v)$ 是 $v$ 的邻居集。算子 $F$ 关于由包含关系导出的 $V$ 的子集上的偏序是单调的，并且是膨胀的，即 $A \\subseteq F(A)$。在有限集 $V$ 上，重复应用 $F$ 必然会稳定在一个不动点，这个不动点就是从 $A_0$ 到达的吸收集。异步更新将相同的规则应用于单个顶点，因此实现了单点单调、膨胀的算子，这些算子的复合也同样是单调和膨胀的。\n\n任务：基于以上基础，推导在有限树上的 $r$-自举渗流中，通过异步随机序列更新达到的最终吸收集是否与通过同步更新达到的相同。然后，实现一个程序，当初始激活集 $A_0$ 是通过在每个顶点上以激活概率 $p$ 进行独立的伯努利试验生成时，经验性地验证同步更新和异步随机序列更新下最终吸收集大小的分布是否相等。对于下面套件中的每个测试用例 $i$，程序必须：\n- 构建指定的树 $G_i$。\n- 进行 $T$ 次独立试验，通过以概率 $p$（表示为 $[0,1]$ 范围的小数）独立地包含每个顶点来抽样 $A_0$。\n- 对于每次试验，从相同的 $A_0$ 开始，计算同步更新和异步随机序列更新下的最终吸收集大小。\n- 汇总两种方案的最终大小的经验分布，并计算它们之间的总变差距离，定义为 $\\frac{1}{2} \\sum_{k=0}^{n} |P(k) - Q(k)|$，其中 $P(k)$ 和 $Q(k)$ 分别是同步和异步更新下最终大小为 $k$ 的经验概率。\n\n您的程序必须输出单行，其中包含一个由方括号括起来的逗号分隔列表，该列表包含以下测试套件的总变差距离（每个都是浮点数），并按指定顺序排列：\n- 用例 1：路径树， $n = 20$，阈值 $r = 1$，初始激活概率 $p = 0.1$，试验次数 $T = 500$。\n- 用例 2：星形树， $n = 21$ （一个中心，20个叶节点），阈值 $r = 2$，初始激活概率 $p = 0.2$，试验次数 $T = 500$。\n- 用例 3：高度为 $h = 5$ 的完全二叉树（因此 $n = 2^{h+1} - 1 = 63$），阈值 $r = 2$，初始激活概率 $p = 0.05$，试验次数 $T = 500$。\n- 用例 4：路径树， $n = 50$，阈值 $r = 10$，初始激活概率 $p = 0.3$，试验次数 $T = 500$。\n- 用例 5：高度为 $h = 4$ 的完全二叉树（因此 $n = 2^{h+1} - 1 = 31$），阈值 $r = 1$，初始激活概率 $p = 0.0$，试验次数 $T = 500$。\n\n最终输出格式要求：您的程序应生成单行输出，包含一个由方括号括起来的逗号分隔列表（例如，$[x_1,x_2,x_3,x_4,x_5]$），其中每个 $x_i$ 是为用例 $i$ 计算出的总变差距离（一个浮点数）。",
            "solution": "该问题要求完成两项任务：首先，是对有限树上同步与异步自举渗流最终状态的理论推导；其次，是通过计算实验对结果进行经验性验证。\n\n### 理论推导\n\n问题的核心是，更新方案的选择——同步与异步随机序列——是否会影响 $r$-自举渗流的最终吸收集。这个过程定义在有限图 $G = (V,E)$ 上。该动力学是递进的，意味着表示为 $A$ 的激活顶点集只能增长。\n\n让我们来形式化更新算子。初始激活顶点集为 $A_0$。\n\n**同步更新**算子 $F$ 定义为：\n$$F(A) = A \\cup \\{ v \\in V \\setminus A : |N(v) \\cap A| \\ge r \\}$$\n其中 $N(v)$ 是顶点 $v$ 的邻居集。同步更新下的最终吸收集 $A_{sync}^*$ 是从 $A_0$ 开始迭代 $F$ 得到的不动点，即 $A_{sync}^* = \\lim_{k \\to \\infty} F^k(A_0)$。这个极限保证存在，因为 $V$ 是有限的，且 $F$ 是膨胀的（$A \\subseteq F(A)$）。\n\n**异步更新**方案涉及应用单点算子。对于每个顶点 $i \\in V$，令 $F_i$ 为只更新顶点 $i$ 的算子：\n$$F_i(A) = \\begin{cases} A \\cup \\{i\\}  \\text{if } i \\notin A \\text{ and } |N(i) \\cap A| \\ge r \\\\ A  \\text{otherwise} \\end{cases}$$\n一个异步过程是这些单点算子的一系列应用， $A_{k+1} = F_{i_k}(A_k)$，其中 $\\{i_k\\}$ 是某个顶点序列。最终吸收集 $A_{async}^*$ 是当不再有任何单顶点激活可能时达到的不动点。\n\n问题陈述，这也是一个关键性质，即这些算子是**单调的**。对于我们系统中的任何算子 $\\mathcal{F}$（无论是 $F$ 还是任何 $F_i$），单调性意味着如果 $A \\subseteq B \\subseteq V$，那么 $\\mathcal{F}(A) \\subseteq \\mathcal{F}(B)$。这个性质对于证明最终状态的等价性至关重要。\n\n我们现在将证明对于任何有限图（该结果不限于树），$A_{sync}^* = A_{async}^*$。我们通过证明集合的相互包含来做到这一点。\n\n**1. 证明 $A_{async}^* \\subseteq A_{sync}^*$**\n\n设异步更新过程中的激活集序列为 $A_0, A_1, A_2, \\ldots, A_{async}^*$，其中 $A_{k+1} = F_{v_k}(A_k)$，对应某个选定的顶点 $v_k$。我们用数学归纳法证明对于所有 $k \\ge 0$，都有 $A_k \\subseteq A_{sync}^*$。\n\n*   **基础情形 ($k=0$)：** 根据 $A_{sync}^*$ 的定义，它是 $A_0$ 在膨胀算子 $F$ 下的闭包，因此 $A_0 \\subseteq A_{sync}^*$。\n\n*   **归纳步骤：** 假设对于某个 $k \\ge 0$，$A_k \\subseteq A_{sync}^*$ 成立。我们需要证明 $A_{k+1} \\subseteq A_{sync}^*$。\n    集合 $A_{k+1}$ 要么是 $A_k$，要么是 $A_k \\cup \\{v_k\\}$。如果 $A_{k+1} = A_k$，则该论断不证自明。\n    如果 $A_{k+1} = A_k \\cup \\{v_k\\}$，这意味着顶点 $v_k$ 被激活了。根据规则，$v_k \\notin A_k$ 且 $|N(v_k) \\cap A_k| \\ge r$。\n    根据归纳假设，$A_k \\subseteq A_{sync}^*$。由集合交集的单调性，$N(v_k) \\cap A_k \\subseteq N(v_k) \\cap A_{sync}^*$。\n    这意味着 $|N(v_k) \\cap A_{sync}^*| \\ge |N(v_k) \\cap A_k| \\ge r$。\n    所以，顶点 $v_k$ 相对于集合 $A_{sync}^*$ 满足激活条件。\n    由于 $A_{sync}^*$ 是同步算子 $F$ 的一个不动点，我们有 $F(A_{sync}^*) = A_{sync}^*$。这意味着在 $A_{sync}^*$ 之外没有可以被其激活的顶点。因为 $v_k$ 可以从 $A_{sync}^*$ 激活，那么必然有 $v_k \\in A_{sync}^*$。\n    因此，$A_{k+1} = A_k \\cup \\{v_k\\} \\subseteq A_{sync}^* \\cup \\{v_k\\} = A_{sync}^*$。\n\n根据数学归纳法，异步序列中的每个集合都是 $A_{sync}^*$ 的子集。这包括最终的吸收集，所以 $A_{async}^* \\subseteq A_{sync}^*$。\n\n**2. 证明 $A_{sync}^* \\subseteq A_{async}^*$**\n\n设同步更新过程中的激活集序列为 $A^{(0)}, A^{(1)}, A^{(2)}, \\ldots$，其中 $A^{(0)}=A_0$ 且 $A^{(k+1)} = F(A^{(k)})$。这些集合的并集是 $A_{sync}^*$。我们用数学归纳法证明对于所有 $k \\ge 0$，都有 $A^{(k)} \\subseteq A_{async}^*$。\n\n*   **基础情形 ($k=0$)：** $A^{(0)} = A_0$。因为异步过程是递进的并且从 $A_0$ 开始，所以我们有 $A_0 \\subseteq A_{async}^*$。\n\n*   **归纳步骤：** 假设对于某个 $k \\ge 0$，$A^{(k)} \\subseteq A_{async}^*$ 成立。我们需要证明 $A^{(k+1)} \\subseteq A_{async}^*$。\n    根据定义，$A^{(k+1)} = F(A^{(k)}) = A^{(k)} \\cup \\{v \\in V \\setminus A^{(k)} : |N(v) \\cap A^{(k)}| \\ge r\\}$。\n    设 $v$ 是 $A^{(k+1)}$ 中的任意顶点。\n    如果 $v \\in A^{(k)}$，那么根据归纳假设，$v \\in A_{async}^*$。\n    如果 $v \\notin A^{(k)}$，那么它的激活意味着 $|N(v) \\cap A^{(k)}| \\ge r$。\n    根据归纳假设，$A^{(k)} \\subseteq A_{async}^*$。因此，$|N(v) \\cap A_{async}^*| \\ge |N(v) \\cap A^{(k)}| \\ge r$。\n    这意味着顶点 $v$ 相对于集合 $A_{async}^*$ 满足激活条件。\n    由于 $A_{async}^*$ 是异步过程的一个吸收集，它之外的任何顶点都不能被激活。形式上，对于任何 $u \\notin A_{async}^*$，都有 $|N(u) \\cap A_{async}^*|  r$。\n    由于 $v$ 满足条件 $|N(v) \\cap A_{async}^*| \\ge r$，那么必然有 $v \\in A_{async}^*$。\n    因此，$A^{(k+1)}$ 中的任何顶点 $v$ 也都在 $A_{async}^*$ 中，这意味着 $A^{(k+1)} \\subseteq A_{async}^*$。\n\n根据数学归纳法，对所有 $k$ 都有 $A^{(k)} \\subseteq A_{async}^*$。因此，它们的并集 $A_{sync}^* = \\bigcup_{k \\ge 0} A^{(k)}$ 也必然是 $A_{async}^*$ 的一个子集。\n\n**结论**\n\n通过证明 $A_{async}^* \\subseteq A_{sync}^*$ 和 $A_{sync}^* \\subseteq A_{async}^*$，我们得出结论 $A_{sync}^* = A_{async}^*$。对于任何有限图上的任何 $r$-自举渗流过程，其最终吸收集都与更新方案（同步或异步）无关。\n\n这个理论结果意味着，对于任何给定的初始激活集 $A_0$，两种方案的最终吸收集大小将是相同的。因此，当 $A_0$ 是随机抽样时，两种方案得到的最终大小的概率分布必须完全相同。因此，这两种经验分布之间的总变差距离应为 $0.0$。模拟中得到的任何非零结果都应归因于微小的实现差异，而非基础理论本身。\n\n所提供的实现将为几个测试用例计算此距离。基于此推导，预期的输出是一个所有总变差距离均为 $0.0$ 的列表。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef create_path_graph(n):\n    \"\"\"Creates an adjacency list for a path graph of n vertices.\"\"\"\n    if n == 0:\n        return {}\n    adj = {i: [] for i in range(n)}\n    for i in range(n - 1):\n        adj[i].append(i + 1)\n        adj[i + 1].append(i)\n    return adj\n\ndef create_star_graph(n):\n    \"\"\"Creates an adjacency list for a star graph of n vertices.\"\"\"\n    if n == 0:\n        return {}\n    adj = {i: [] for i in range(n)}\n    center = 0\n    for i in range(1, n):\n        adj[center].append(i)\n        adj[i].append(center)\n    return adj\n\ndef create_binary_tree(h):\n    \"\"\"Creates an adjacency list for a complete binary tree of height h.\"\"\"\n    n = 2**(h + 1) - 1\n    if n == 0:\n        return {}\n    adj = {i: [] for i in range(n)}\n    # Iterate through all possible parent nodes\n    for i in range((n - 1) // 2 + 1):\n        left_child = 2 * i + 1\n        right_child = 2 * i + 2\n        if left_child  n:\n            adj[i].append(left_child)\n            adj[left_child].append(i)\n        if right_child  n:\n            adj[i].append(right_child)\n            adj[right_child].append(i)\n    return adj\n\ndef simulate_sync(adj, r, initial_active):\n    \"\"\"Simulates r-bootstrap percolation with synchronous updates.\"\"\"\n    n = len(adj)\n    active = initial_active.copy()\n    \n    while True:\n        to_activate = []\n        for i in range(n):\n            if not active[i]:\n                active_neighbors = 0\n                for neighbor in adj.get(i, []):\n                    if active[neighbor]:\n                        active_neighbors += 1\n                if active_neighbors >= r:\n                    to_activate.append(i)\n        \n        if not to_activate:\n            break\n        \n        for i in to_activate:\n            active[i] = True\n            \n    return np.sum(active)\n\ndef simulate_async(adj, r, initial_active):\n    \"\"\"Simulates r-bootstrap percolation with asynchronous random sequential updates.\"\"\"\n    n = len(adj)\n    active = initial_active.copy()\n    \n    while True:\n        changed_in_pass = False\n        update_order = np.random.permutation(n)\n        for i in update_order:\n            if not active[i]:\n                active_neighbors = 0\n                for neighbor in adj.get(i, []):\n                    if active[neighbor]:\n                        active_neighbors += 1\n                if active_neighbors >= r:\n                    active[i] = True\n                    changed_in_pass = True\n        \n        if not changed_in_pass:\n            break\n            \n    return np.sum(active)\n\ndef solve():\n    \"\"\"\n    Runs the empirical verification for the test suite and prints the results.\n    \"\"\"\n    test_cases = [\n        {'type': 'path', 'params': {'n': 20}, 'r': 1, 'p': 0.1, 'T': 500},\n        {'type': 'star', 'params': {'n': 21}, 'r': 2, 'p': 0.2, 'T': 500},\n        {'type': 'binary_tree', 'params': {'h': 5}, 'r': 2, 'p': 0.05, 'T': 500},\n        {'type': 'path', 'params': {'n': 50}, 'r': 10, 'p': 0.3, 'T': 500},\n        {'type': 'binary_tree', 'params': {'h': 4}, 'r': 1, 'p': 0.0, 'T': 500},\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        T = case['T']\n        p = case['p']\n        r = case['r']\n        \n        if case['type'] == 'path':\n            n = case['params']['n']\n            adj = create_path_graph(n)\n        elif case['type'] == 'star':\n            n = case['params']['n']\n            adj = create_star_graph(n)\n        elif case['type'] == 'binary_tree':\n            h = case['params']['h']\n            n = 2**(h + 1) - 1\n            adj = create_binary_tree(h)\n\n        if n == 0:\n            results.append(0.0)\n            continue\n            \n        sync_hist = np.zeros(n + 1, dtype=np.int32)\n        async_hist = np.zeros(n + 1, dtype=np.int32)\n        \n        for _ in range(T):\n            # Generate the same initial active set for both schemes in each trial\n            initial_active = np.random.rand(n)  p\n            \n            # Run synchronous simulation\n            sync_size = simulate_sync(adj, r, initial_active)\n            sync_hist[sync_size] += 1\n            \n            # Run asynchronous simulation\n            async_size = simulate_async(adj, r, initial_active)\n            async_hist[async_size] += 1\n\n        # Calculate empirical probability distributions\n        P_sync = sync_hist / T\n        P_async = async_hist / T\n        \n        # Calculate Total Variation Distance\n        tv_distance = 0.5 * np.sum(np.abs(P_sync - P_async))\n        results.append(tv_distance)\n\n    # Print the final result in the specified format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}