{
    "hands_on_practices": [
        {
            "introduction": "神经连接体并非随机的网络；它们是由反复出现的基本回路模式（称为网络基序）构成的。这项练习提供了一项基础技能：学习如何系统地识别和计数这些基序。掌握这一技能使我们能够剖析连接体的基本计算构件，并将其结构与零模型进行比较 。",
            "id": "4293135",
            "problem": "一个有向突触图将一个局部神经微回路建模为一个没有自环的简单有向图，其中从神经元 $i$ 到神经元 $j$ 的一条有向边代表一个突触 $i \\to j$。在复杂系统和网络科学中的神经连接组学背景下，网络基序是在固定数量节点上指定的诱导子图模式，在图同构（标签置换）的意义下被考虑，并且通常相对于一个适当的零模型（例如度保持配置模型）来评估其统计上的过表达。关注于3节点尺度的基序。\n\n从有向图、邻接矩阵、诱导子图和图同构的基本定义出发，定义有向图中3节点基序的含义，并推导出一个通用的、精确的计数方法，用于计数所有3节点基序。该方法需使用邻接矩阵运算、针对一个三元组中需要和禁止的边的指示函数，以及考虑每个基序同构类的自同构群的组合校正。你的方法必须用对不同节点三元组的求和以及邻接矩阵元素及其补的乘积来表示，并且必须包括将有序节点三元组的计数转换为无标签诱导基序计数所需的对称性校正。\n\n然后，将你的方法应用于以下由 $n=6$ 个神经元组成的有向突触网络，其邻接矩阵为 $\\mathbf{A} \\in \\{0,1\\}^{6 \\times 6}$，其中如果存在突触 $i \\to j$，则 $\\mathbf{A}_{ij}=1$，否则 $\\mathbf{A}_{ij}=0$：\n$$\n\\mathbf{A}=\n\\begin{pmatrix}\n0  1  1  0  0  0 \\\\\n0  0  1  0  0  0 \\\\\n0  0  0  0  0  0 \\\\\n0  0  0  0  1  1 \\\\\n0  0  0  0  0  1 \\\\\n0  0  0  0  0  0 \\\\\n\\end{pmatrix}.\n$$\n假设没有自环，并且每个有序神经元对之间最多只有一条有向边。\n\n对于称为前馈环（定义为一个诱导的3节点有向无环三元组，恰好有三条边 $i \\to j$、$j \\to k$ 和 $i \\to k$，并且三元组中所有反向边都不存在）的特定基序类型，计算该网络中存在的诱导前馈环基序的精确数量。将你的最终答案表示为一个整数。无需四舍五入。",
            "solution": "该问题要求两个主要部分：首先，推导出一个通用的、精确的方法，使用邻接矩阵运算和组合校正来计数有向图中的3节点基序；其次，应用此方法在给定的特定网络中找出诱导前馈环基序的数量。\n\n首先，我们建立必要的定义。有向图是一个对 $G=(V, E)$，其中 $V=\\{1, 2, \\dots, n\\}$ 是一个包含 $n$ 个节点（神经元）的集合，而 $E \\subseteq V \\times V$ 是一个有向边（突触）的集合。该图由其邻接矩阵 $\\mathbf{A}$ 表示，这是一个 $n \\times n$ 矩阵，其中如果存在从节点 $i$到节点 $j$ 的边（即 $(i,j) \\in E$），则 $\\mathbf{A}_{ij}=1$，否则 $\\mathbf{A}_{ij}=0$。问题陈述没有自环，这意味着对于所有 $i \\in V$，$\\mathbf{A}_{ii}=0$。在节点集 $S \\subseteq V$ 上的诱导子图是图 $G[S]$，它由节点 $S$ 以及 $E$ 中连接 $S$ 内节点的所有边组成。一个3节点基序是三个节点上诱导子图的一个同构类。我们旨在计算不同的三节点集合 $S=\\{i,j,k\\}$ 的数量，其诱导子图 $G[S]$ 与特定的基序模式同构。\n\n为了推导一个通用的计数方法，我们遍历所有有序且不同的节点三元组 $(i, j, k)$，其总数为 $n(n-1)(n-2)$。对于每个有序三元组，我们可以确定它们之间六条可能边的具体标记模式：$i \\leftrightarrow j$、$i \\leftrightarrow k$ 和 $j \\leftrightarrow k$。设 $M$ 为一个目标基序同构类，由顶点为 $\\{v_1, v_2, v_3\\}$ 的图 $G_M$ 表示。我们可以通过将 $G_M$ 的角色映射到有序三元组 $(i,j,k)$ 中的位置来定义一个规范标记模式。例如，我们可以指定 $i$ 扮演 $v_1$ 的角色，$j$ 扮演 $v_2$ 的角色，$k$ 扮演 $v_3$ 的角色。\n\n可以为这个规范标记模式构建一个指示函数 $I_M(i,j,k)$。如果 $(i,j,k)$ 上的子图匹配该模式，则此函数等于 $1$，否则为 $0$。它被表示为对应于三个节点之间六条可能有向边的六个项的乘积。对于模式中要求存在的每条边，例如 $u \\to v$，我们包含一个因子 $\\mathbf{A}_{uv}$。对于要求不存在的每条边，我们包含一个因子 $(1-\\mathbf{A}_{uv})$。\n\n在整个图中，这个特定规范标记模式的总出现次数可以通过对所有不同的有序三元组求和指示函数来找到：\n$$N_{raw} = \\sum_{i,j,k \\text{ distinct}} I_M(i,j,k)$$\n这个和 $N_{raw}$ 并不直接给出无标签诱导基序的数量 $N_M$。由于对称性导致的重复计数需要进行校正。如果一个节点集 $\\{u,v,w\\}$ 上的单个诱导基序的不同置换与规范标记模式匹配，则它可能在 $N_{raw}$ 中被多次计数。对于基序的单个实例，这种匹配置换的数量是组合对称因子 $S_M$。该因子等于基序图的自同构群的大小 $|\\text{Aut}(G_M)|$，即保持其边结构的基序节点置换的数量。\n\n$M$ 类诱导基序数量的最终通用公式为：\n$$N_M = \\frac{N_{raw}}{S_M} = \\frac{1}{|\\text{Aut}(G_M)|} \\sum_{i,j,k \\text{ distinct}} I_M(i,j,k)$$\n\n接下来，我们应用此方法来计数称为前馈环 (FFL) 的特定基序。FFL 被定义为一个诱导的3节点三元组，恰好有三条边形成一个带捷径的有向无环路径：$i \\to j$、$j \\to k$ 和 $i \\to k$。我们将其定义为有序三元组 $(i,j,k)$ 的规范标记模式，其中 $i$ 是源节点，$j$ 是中间节点，$k$ 是汇节点。\n\n用于此模式的指示函数 $I_{FFL}(i,j,k)$ 要求存在边 $i \\to j$、$j \\to k$ 和 $i \\to k$，并且不存在反向边 $j \\to i$、$k \\to j$ 和 $k \\to i$。该函数是：\n$$I_{FFL}(i,j,k) = \\mathbf{A}_{ij}\\mathbf{A}_{jk}\\mathbf{A}_{ik}(1-\\mathbf{A}_{ji})(1-\\mathbf{A}_{kj})(1-\\mathbf{A}_{ki})$$\n为了找到对称因子 $S_{FFL}$，我们确定 FFL 图的自同构群的大小。FFL 中的节点具有由其在基序内的入度和出度区分的独特角色：\n- 源节点 ($i$)：入度 $0$，出度 $2$。\n- 中间节点 ($j$)：入度 $1$，出度 $1$。\n- 汇节点 ($k$)：入度 $2$，出度 $0$。\n由于所有三个节点都具有不同的度特征，任何自同构都必须将每个节点映射到其自身。因此，自同构群是平凡的，只包含单位置换。因此，$|\\text{Aut}(FFL)| = 1$，对称因子 $S_{FFL}=1$。\n这意味着对于网络中每个诱导 FFL 子图的实例，其节点中恰好只有一个有序三元组会匹配规范模式。因此，总计数就是原始和：\n$$N_{FFL} = \\sum_{i,j,k \\text{ distinct}} I_{FFL}(i,j,k)$$\n我们现在为给定的邻接矩阵计算这个和：\n$$\n\\mathbf{A}=\n\\begin{pmatrix}\n0  1  1  0  0  0 \\\\\n0  0  1  0  0  0 \\\\\n0  0  0  0  0  0 \\\\\n0  0  0  0  1  1 \\\\\n0  0  0  0  0  1 \\\\\n0  0  0  0  0  0 \\\\\n\\end{pmatrix}\n$$\n只有当 $\\mathbf{A}_{ij}=1$，$\\mathbf{A}_{jk}=1$ 和 $\\mathbf{A}_{ik}=1$ 时，$I_{FFL}$ 中的乘积才非零。条件 $\\mathbf{A}_{ij}\\mathbf{A}_{jk}=1$ 意味着存在一条从 $i$ 经过 $j$ 到 $k$ 的长度为2的路径。我们可以系统地寻找这样的路径。\n\n让我们搜索满足 $\\mathbf{A}_{ij}=1$ 和 $\\mathbf{A}_{jk}=1$ 的三元组 $(i,j,k)$：\n1.  路径 $1 \\to 2 \\to 3$：我们有 $\\mathbf{A}_{12}=1$ 和 $\\mathbf{A}_{23}=1$。这给出了候选三元组 $(i,j,k) = (1,2,3)$。\n    - 我们检查捷径边：$\\mathbf{A}_{ik} = \\mathbf{A}_{13}=1$。此条件满足。\n    - 我们检查不存在的边：\n        - $\\mathbf{A}_{ji} = \\mathbf{A}_{21}=0$。满足。\n        - $\\mathbf{A}_{kj} = \\mathbf{A}_{32}=0$。满足。\n        - $\\mathbf{A}_{ki} = \\mathbf{A}_{31}=0$。满足。\n    所有条件都满足。三元组 $(1,2,3)$ 对总和贡献 $1$。\n\n2.  路径 $4 \\to 5 \\to 6$：我们有 $\\mathbf{A}_{45}=1$ 和 $\\mathbf{A}_{56}=1$。这给出了候选三元组 $(i,j,k) = (4,5,6)$。\n    - 我们检查捷径边：$\\mathbf{A}_{ik} = \\mathbf{A}_{46}=1$。此条件满足。\n    - 我们检查不存在的边：\n        - $\\mathbf{A}_{ji} = \\mathbf{A}_{54}=0$。满足。\n        - $\\mathbf{A}_{kj} = \\mathbf{A}_{65}=0$。满足。\n        - $\\mathbf{A}_{ki} = \\mathbf{A}_{64}=0$。满足。\n    所有条件都满足。三元组 $(4,5,6)$ 对总和贡献 $1$。\n\n是否还有其他长度为2的路径？我们可以检查图的结构。\n- 节点 $1$ 有到 $2$ 和 $3$ 的出边。节点 $2$ 有到 $3$ 的出边。节点 $3$ 没有出边。这只产生了路径 $1 \\to 2 \\to 3$。\n- 节点 $4$ 有到 $5$ 和 $6$ 的出边。节点 $5$ 有到 $6$ 的出边。节点 $6$ 没有出边。这只产生了路径 $4 \\to 5 \\to 6$。\n图中没有其他 $i \\to j \\to k$ 的序列。该图由两个不连通的分量 $\\{1,2,3\\}$ 和 $\\{4,5,6\\}$ 组成，并且在每个分量内的搜索都已完成。\n\n该和仅对两个有序三元组 $(1,2,3)$ 和 $(4,5,6)$ 非零。\n因此，前馈环基序的总数为：\n$$N_{FFL} = 1 + 1 = 2$$\n这两个诱导的 FFL 基序位于节点集 $\\{1,2,3\\}$ 和 $\\{4,5,6\\}$ 上。",
            "answer": "$$\\boxed{2}$$"
        },
        {
            "introduction": "在识别了局部回路之后，下一步是理解神经元如何组织成更大、功能上更连贯的群体或模块。这项练习介绍了模块度，这是量化社区结构的一个关键概念，并要求你推导和应用其公式。通过理解如何测量模块度，你可以将大脑划分为不同的子系统，并探索连接体的组织原则 。",
            "id": "4293166",
            "problem": "考虑一个从神经连接组中提取的小型加权有向微电路，其节点集为 $\\{1,2,3,4\\}$，加权邻接项 $w_{ij}$ 由以下非零值给出：$w_{12}=3$、$w_{13}=1$、$w_{21}=2$、$w_{23}=2$、$w_{24}=1$、$w_{32}=1$、$w_{34}=2$、$w_{41}=1$、$w_{43}=2$，而对于所有其他有序对 $(i,j)$（包括所有 $i$ 的 $w_{ii}=0$），$w_{ij}=0$。令 $m=\\sum_{i,j} w_{ij}$ 表示总权重。假设社群分配为 $c_{1}=c_{2}$ 和 $c_{3}=c_{4}$（两个模块），并且模块度是通过将观测到的社群内部权重与在加权有向网络的度保持（强度保持）零模型下的期望值进行比较来定义的，其中带有一个可调分辨率参数 $\\gamma0$，该参数用于重新缩放期望权重的基线。\n\n任务：\n仅从以下原则出发：\n(1) 一个划分的模块度衡量的是社群内部权重与其在零模型下期望值的归一化偏差。\n(2) 加权有向网络的度保持零模型是固定每个节点的出强度 $s_{i}^{\\mathrm{out}}=\\sum_{j} w_{ij}$ 和入强度 $s_{j}^{\\mathrm{in}}=\\sum_{i} w_{ij}$ 以及总权重 $m$ 的最大熵系综，\n推导模块度 $Q(\\gamma)$ 关于 $w_{ij}$、$s_{i}^{\\mathrm{out}}$、$s_{j}^{\\mathrm{in}}$、$m$、$\\gamma$ 和社群标签 $c_{i}$ 的显式解析表达式，并在此框架内解释 $\\gamma$ 对所检测社群尺度的作用和影响。\n\n然后，对于给定的网络和指定的划分，在 $\\gamma=\\frac{6}{5}$ 时计算 $Q(\\gamma)$ 的值，使用的约定是 $Q(\\gamma)$ 中的求和遍历所有有序对 $(i,j)$（包括 $i=j$），并且 $w_{ii}=0$。将你的最终答案表示为一个精确分数。模块度值是无量纲的。不要提供中间过程的数值舍入；最终答案必须是精确的。",
            "solution": "问题要求推导带有分辨率参数的加权有向网络的模块度表达式，解释该参数的作用，并对一个特定的微电路进行计算。该过程首先验证问题陈述，我们发现其科学上合理、问题明确且客观。因此，我们可以着手求解。\n\n首先，我们根据所提供的原则推导模块度 $Q(\\gamma)$ 的解析表达式。\n\n原则（1）指出，模块度衡量的是社群内部权重与其在零模型下期望值的归一化偏差。设节点集为 $V$，节点 $i$ 的社群分配为 $c_i$，加权邻接矩阵为 $W = (w_{ij})$。网络中的总权重为 $m = \\sum_{i,j \\in V} w_{ij}$。模块度 $Q$ 通常表示为对所有节点对 $(i,j)$ 的求和，求和项是观测权重 $w_{ij}$ 与零模型下的期望权重 $P_{ij}$ 之差，但仅当节点 $i$ 和 $j$ 属于同一社群时才计入。这种选择是通过使用克罗内克δ函数 $\\delta(c_i, c_j)$ 来实现的，当 $c_i = c_j$ 时，该函数等于1，否则等于0。该和通过总权重 $m$ 进行归一化。问题还引入了一个分辨率参数 $\\gamma  0$，用于重新缩放期望权重的基线。综合这些，模块度的表达式为：\n$$\nQ(\\gamma) = \\frac{1}{m} \\sum_{i,j} \\left[ w_{ij} - \\gamma P_{ij} \\right] \\delta(c_i, c_j)\n$$\n\n原则（2）指定了零模型。它是保持每个节点的出强度 $s_i^{\\mathrm{out}} = \\sum_j w_{ij}$ 和入强度 $s_j^{\\mathrm{in}} = \\sum_i w_{ij}$ 的最大熵系综。这是加权有向网络的标准配置模型。在此模型中，从节点 $i$ 到节点 $j$ 的有向边的期望权重 $P_{ij}$ 与 $i$ 的出强度和 $j$ 的入强度成正比。一个单位权重源于节点 $i$ 的概率是 $\\frac{s_i^{\\mathrm{out}}}{m}$，终于节点 $j$ 的概率是 $\\frac{s_j^{\\mathrm{in}}}{m}$。假设这些是独立事件，一个单位权重从 $i$ 流向 $j$ 的概率是 $\\frac{s_i^{\\mathrm{out}}s_j^{\\mathrm{in}}}{m^2}$。由于系统中有 $m$ 个总权重单位，从 $i$ 到 $j$ 的期望总权重是：\n$$\nP_{ij} = m \\times \\left( \\frac{s_i^{\\mathrm{out}}}{m} \\frac{s_j^{\\mathrm{in}}}{m} \\right) = \\frac{s_i^{\\mathrm{out}} s_j^{\\mathrm{in}}}{m}\n$$\n将这个 $P_{ij}$ 的表达式代入模块度方程，得到所需的显式解析表达式：\n$$\nQ(\\gamma) = \\frac{1}{m} \\sum_{i,j} \\left( w_{ij} - \\gamma \\frac{s_i^{\\mathrm{out}} s_j^{\\mathrm{in}}}{m} \\right) \\delta(c_i, c_j)\n$$\n\n接下来，我们解释分辨率参数 $\\gamma$ 的作用。项 $\\gamma \\frac{s_i^{\\mathrm{out}} s_j^{\\mathrm{in}}}{m}$ 作为对社群内部连接的惩罚项，这些连接在具有相同强度序列的网络中被认为是随机存在的。\n- 如果 $\\gamma  1$，惩罚项被放大。这使得一组节点更难被识别为一个社群；只有那些内部连接性显著高于期望的节点群才会产生正的模块度贡献。这种设置有利于检测更小、更密集的社群，从而提供高分辨率的社群结构。\n- 如果 $0  \\gamma  1$，惩罚项被减小。这使得节点群更容易被识别为社群，即使它们的内部连接性不是特别强。这种设置有利于检测更大、密度较低的社群，提供了网络组织的低分辨率视图。\n- 如果 $\\gamma = 1$，该表达式简化为加权有向图模块度的标准形式。因此，$\\gamma$ 是一个可调参数，允许探索不同尺度下的社群结构。\n\n最后，我们针对给定的网络、划分以及 $\\gamma = \\frac{6}{5}$ 来计算 $Q(\\gamma)$。该网络有一个节点集 $\\{1, 2, 3, 4\\}$ 和以下非零权重：$w_{12}=3$、$w_{13}=1$、$w_{21}=2$、$w_{23}=2$、$w_{24}=1$、$w_{32}=1$、$w_{34}=2$、$w_{41}=1$、$w_{43}=2$。\n\n首先，我们计算强度序列和总权重 $m$。\n出强度为：\n$s_1^{\\mathrm{out}} = w_{12} + w_{13} = 3 + 1 = 4$\n$s_2^{\\mathrm{out}} = w_{21} + w_{23} + w_{24} = 2 + 2 + 1 = 5$\n$s_3^{\\mathrm{out}} = w_{32} + w_{34} = 1 + 2 = 3$\n$s_4^{\\mathrm{out}} = w_{41} + w_{43} = 1 + 2 = 3$\n\n入强度为：\n$s_1^{\\mathrm{in}} = w_{21} + w_{41} = 2 + 1 = 3$\n$s_2^{\\mathrm{in}} = w_{12} + w_{32} = 3 + 1 = 4$\n$s_3^{\\mathrm{in}} = w_{13} + w_{23} + w_{43} = 1 + 2 + 2 = 5$\n$s_4^{\\mathrm{in}} = w_{24} + w_{34} = 1 + 2 = 3$\n\n总权重为 $m = \\sum_i s_i^{\\mathrm{out}} = 4 + 5 + 3 + 3 = 15$。（检验：$\\sum_j s_j^{\\mathrm{in}} = 3 + 4 + 5 + 3 = 15$）。\n\n给定的划分为两个模块：$C_1 = \\{1, 2\\}$ 和 $C_2 = \\{3, 4\\}$。\n我们可以通过按社群对各项进行分组来重写模块度求和：\n$$\nQ(\\gamma) = \\frac{1}{m} \\left[ \\sum_{i,j \\in C_1} \\left( w_{ij} - \\gamma \\frac{s_i^{\\mathrm{out}} s_j^{\\mathrm{in}}}{m} \\right) + \\sum_{i,j \\in C_2} \\left( w_{ij} - \\gamma \\frac{s_i^{\\mathrm{out}} s_j^{\\mathrm{in}}}{m} \\right) \\right]\n$$\n让我们分析每个社群的贡献。\n\n对于社群 $C_1 = \\{1, 2\\}$：\n内部总权重为 $W_1 = \\sum_{i,j \\in C_1} w_{ij} = w_{11} + w_{12} + w_{21} + w_{22} = 0 + 3 + 2 + 0 = 5$。\n出强度之和为 $S_1^{\\mathrm{out}} = s_1^{\\mathrm{out}} + s_2^{\\mathrm{out}} = 4 + 5 = 9$。\n入强度之和为 $S_1^{\\mathrm{in}} = s_1^{\\mathrm{in}} + s_2^{\\mathrm{in}} = 3 + 4 = 7$。\n期望内部权重项为 $\\sum_{i,j \\in C_1} \\frac{s_i^{\\mathrm{out}} s_j^{\\mathrm{in}}}{m} = \\frac{1}{m} (\\sum_{i \\in C_1} s_i^{\\mathrm{out}})(\\sum_{j \\in C_1} s_j^{\\mathrm{in}}) = \\frac{S_1^{\\mathrm{out}} S_1^{\\mathrm{in}}}{m} = \\frac{9 \\times 7}{15} = \\frac{63}{15} = \\frac{21}{5}$。\n\n对于社群 $C_2 = \\{3, 4\\}$：\n内部总权重为 $W_2 = \\sum_{i,j \\in C_2} w_{ij} = w_{33} + w_{34} + w_{43} + w_{44} = 0 + 2 + 2 + 0 = 4$。\n出强度之和为 $S_2^{\\mathrm{out}} = s_3^{\\mathrm{out}} + s_4^{\\mathrm{out}} = 3 + 3 = 6$。\n入强度之和为 $S_2^{\\mathrm{in}} = s_3^{\\mathrm{in}} + s_4^{\\mathrm{in}} = 5 + 3 = 8$。\n期望内部权重项为 $\\sum_{i,j \\in C_2} \\frac{s_i^{\\mathrm{out}} s_j^{\\mathrm{in}}}{m} = \\frac{S_2^{\\mathrm{out}} S_2^{\\mathrm{in}}}{m} = \\frac{6 \\times 8}{15} = \\frac{48}{15} = \\frac{16}{5}$。\n\n现在我们将这些结果结合起来得到 $Q(\\gamma)$：\n$$\nQ(\\gamma) = \\frac{1}{m} \\left[ \\left(W_1 - \\gamma \\frac{S_1^{\\mathrm{out}} S_1^{\\mathrm{in}}}{m}\\right) + \\left(W_2 - \\gamma \\frac{S_2^{\\mathrm{out}} S_2^{\\mathrm{in}}}{m}\\right) \\right]\n$$\n$$\nQ(\\gamma) = \\frac{1}{15} \\left[ \\left(5 - \\gamma \\frac{21}{5}\\right) + \\left(4 - \\gamma \\frac{16}{5}\\right) \\right] = \\frac{1}{15} \\left[ 9 - \\gamma \\left(\\frac{21}{5} + \\frac{16}{5}\\right) \\right] = \\frac{1}{15} \\left( 9 - \\gamma \\frac{37}{5} \\right)\n$$\n最后，我们代入 $\\gamma = \\frac{6}{5}$：\n$$\nQ\\left(\\frac{6}{5}\\right) = \\frac{1}{15} \\left( 9 - \\frac{6}{5} \\cdot \\frac{37}{5} \\right) = \\frac{1}{15} \\left( 9 - \\frac{222}{25} \\right)\n$$\n为了减去分数，我们找到一个公分母：\n$$\nQ\\left(\\frac{6}{5}\\right) = \\frac{1}{15} \\left( \\frac{9 \\times 25}{25} - \\frac{222}{25} \\right) = \\frac{1}{15} \\left( \\frac{225 - 222}{25} \\right) = \\frac{1}{15} \\left( \\frac{3}{25} \\right)\n$$\n$$\nQ\\left(\\frac{6}{5}\\right) = \\frac{3}{15 \\times 25} = \\frac{1}{5 \\times 25} = \\frac{1}{125}\n$$\n模块度值是按要求给出的精确分数。",
            "answer": "$$\\boxed{\\frac{1}{125}}$$"
        },
        {
            "introduction": "神经网络不仅仅是抽象的图；它们是嵌入在三维空间中的物理系统，其中布线成本高昂。这项练习探讨了布线经济性这一关键的生物学原理，挑战你优化网络拓扑以减少其总布线长度，同时保留其核心计算架构。这项实践弥合了抽象网络分析与塑造大脑进化和发育的真实物理和代谢约束之间的鸿沟 。",
            "id": "4293136",
            "problem": "考虑一个表示神经连接体的空间嵌入无向简单图，其中节点为神经元，边为轴突或树突连接。每个节点 $i$ 都有一个固定的位置 $\\mathbf{x}_i \\in \\mathbb{R}^2$，一条无向边 $\\{u,v\\}$ 产生等于其欧几里得距离 $\\|\\mathbf{x}_u - \\mathbf{x}_v\\|_2$ 的布线成本。图 $G=(V,E)$ 的总布线长度为 $$L(G) = \\sum_{\\{u,v\\}\\in E} \\|\\mathbf{x}_u - \\mathbf{x}_v\\|_2.$$ 神经连接体学中的布线经济性原则假设，对于给定的功能架构，生物神经网络通常在满足架构约束的条件下最小化总布线长度。在本问题中，这些约束是固定的度序列和保持全局连通性。\n\n请构建一个约束优化问题，通过保持节点度和全局连通性的重连（rewiring）操作，将总布线长度减少一个固定的比例 $r \\in (0,1)$。允许的重连操作是双边交换（double-edge swap）：用 $\\{a,c\\}$ 和 $\\{b,d\\}$ 或 $\\{a,d\\}$ 和 $\\{b,c\\}$ 替换两条不相交的边 $\\{a,b\\}$ 和 $\\{c,d\\}$（其中 $a,b,c,d$ 均不相同），前提是生成的图保持简单（无自环或平行边）且连通。目标是找到一个此类交换的序列，从而得到一个图 $G'$，其满足 $L(G') \\leq (1-r)\\,L(G)$，同时保持每个节点的度和图的连通性。如果不存在这样的图，则过程应在这些操作下终止于一个局部最优解。\n\n从以下三个测试用例开始，实现一个确定性算法，该算法迭代地应用最佳可用双边交换（即最大程度减少总布线长度的交换），同时保持图的简单性和连通性，直到达到目标缩减量或不存在任何可改进的交换为止。对于每个测试用例，计算比率 $L(G_{\\text{final}})/L(G_{\\text{initial}})$，四舍五入到六位小数，其中 $G_{\\text{final}}$ 是终止时的图。当使用角度时，单位必须是弧度。\n\n测试套件：\n- 测试用例 A (理想路径，中等规模，异构几何)：\n  - 节点 $V = \\{0,1,2,3,4,5,6,7,8,9\\}$ 及其位置\n    - $\\mathbf{x}_0 = (0.05, 0.10)$，\n    - $\\mathbf{x}_1 = (0.15, 0.92)$，\n    - $\\mathbf{x}_2 = (0.90, 0.80)$，\n    - $\\mathbf{x}_3 = (0.85, 0.15)$，\n    - $\\mathbf{x}_4 = (0.40, 0.50)$，\n    - $\\mathbf{x}_5 = (0.60, 0.55)$，\n    - $\\mathbf{x}_6 = (0.20, 0.20)$，\n    - $\\mathbf{x}_7 = (0.30, 0.85)$，\n    - $\\mathbf{x}_8 = (0.70, 0.25)$，\n    - $\\mathbf{x}_9 = (0.10, 0.60)$。\n  - 初始无向边集 $E$：\n    - $\\{0,2\\}$, $\\{0,7\\}$, $\\{0,6\\}$, $\\{1,3\\}$, $\\{1,9\\}$, $\\{1,5\\}$, $\\{2,8\\}$, $\\{2,5\\}$, $\\{3,4\\}$, $\\{3,6\\}$, $\\{4,5\\}$, $\\{4,9\\}$, $\\{7,9\\}$, $\\{6,8\\}$, $\\{7,8\\}$。\n  - 目标缩减比例 $r = 0.07$。\n- 测试用例 B (趋向局部最优的边界情况，几何环格)：\n  - 节点 $V = \\{0,1,2,3,4,5,6,7,8,9,10,11\\}$ 排列在一个以 $(0.5, 0.5)$ 为中心、半径为 $0.45$ 的圆上：\n    - $\\mathbf{x}_i = \\big(0.5 + 0.45 \\cos(2\\pi i / 12),\\; 0.5 + 0.45 \\sin(2\\pi i / 12)\\big)$ 对于 $i \\in \\{0,1,\\dots,11\\}$，角度单位为弧度。\n  - 初始无向边集 $E$ 通过将每个节点连接到其两个最近的环上邻居和一个较长的弦来形成：\n    - 对于每个 $i$，包含 $\\{i, (i+1)\\bmod 12\\}$、$\\{i, (i-1)\\bmod 12\\}$ 和 $\\{i, (i+3)\\bmod 12\\}$，将图视为无向简单图（即，每个无序对只包含一次）。\n  - 目标缩减比例 $r = 0.02$。\n- 测试用例 C (边缘情况，完全图；无法进行重连更改)：\n  - 节点 $V = \\{0,1,2,3,4,5,6,7\\}$ 及其位置\n    - $\\mathbf{x}_0 = (0.10, 0.10)$，\n    - $\\mathbf{x}_1 = (0.20, 0.80)$，\n    - $\\mathbf{x}_2 = (0.80, 0.20)$，\n    - $\\mathbf{x}_3 = (0.90, 0.90)$，\n    - $\\mathbf{x}_4 = (0.50, 0.50)$，\n    - $\\mathbf{x}_5 = (0.30, 0.70)$，\n    - $\\mathbf{x}_6 = (0.70, 0.30)$，\n    - $\\mathbf{x}_7 = (0.40, 0.60)$。\n  - 初始无向边集 $E$ 是 8 个节点上的完全图：包含所有满足 $0 \\le i  j \\le 7$ 的节点对 $\\{i,j\\}$。\n  - 目标缩减比例 $r = 0.10$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[\\text{result}_A,\\text{result}_B,\\text{result}_C]$）。每个结果必须是相应测试用例的最终总布线长度除以初始总布线长度，作为浮点数，四舍五入到六位小数，不带单位。",
            "solution": "该问题提出了一个基于神经连接体学中布线经济性原则的约束优化任务。我们得到一个空间嵌入的无向简单图 $G=(V, E)$，其中节点 $V$ 代表具有固定位置 $\\mathbf{x}_i \\in \\mathbb{R}^2$ 的神经元，边 $E$ 代表连接。一条边 $\\{u,v\\}$ 的成本是其欧几里得长度 $\\|\\mathbf{x}_u - \\mathbf{x}_v\\|_2$，图的总布线长度为 $L(G) = \\sum_{\\{u,v\\}\\in E} \\|\\mathbf{x}_u - \\mathbf{x}_v\\|_2$。\n\n目标是将总布线长度 $L(G)$ 减少一个目标比例 $r \\in (0,1)$，达到新值 $L(G') \\leq (1-r)L(G)$。此优化受两个关键要求约束：必须保持每个节点的度，且图必须保持连通。唯一允许的操作是双边交换（double-edge swap），这是一种标准的保持度的重连操作。此操作选择两条不相交的边 $\\{a,b\\}$ 和 $\\{c,d\\}$，并用两种可能的新边对之一替换它们：$\\{a,c\\}$ 和 $\\{b,d\\}$，或 $\\{a,d\\}$ 和 $\\{b,c\\}$。一个交换仅当结果图保持简单（无平行边）和连通时才有效。\n\n该问题要求实现一个确定性贪心算法。在每一步中，算法必须识别所有可能的有效双边交换，并执行那个能带来最大总布线长度减少的交换。这个迭代过程持续进行，直到达到目标布线长度，或者直到没有更多可以减少长度的交换为止，此时图相对于交换操作处于局部最小值。每个测试用例的最终输出是最终布线长度与初始布线长度的比率，$L(G_{\\text{final}})/L(G_{\\text{initial}})$。\n\n方法论步骤如下：\n\n1.  **初始化**：对于每个测试用例，使用节点位置 $\\mathbf{x}_i$ 和初始边集 $E$ 来构建图的表示。计算初始总布线长度 $L_{\\text{initial}}$。由此确定目标长度 $L_{\\text{target}} = (1-r)L_{\\text{initial}}$。我们使用一个排序元组的集合来表示无向简单图，其中每个元组 `(u, v)` 且 $u  v$ 对应一条边 $\\{u,v\\}$。\n\n2.  **贪心迭代优化**：算法的核心是一个循环，只要当前布线长度 $L_{\\text{current}}$ 大于 $L_{\\text{target}}$，该循环就继续。\n   a. **候选搜索**：在每次迭代中，我们搜索最优的有效交换。这涉及遍历当前图中所有不同的边对 $\\{a,b\\}$ 和 $\\{c,d\\}$。对于每个这样的对，我们确保四个节点 $a, b, c, d$ 是不同的。\n   b. **交换评估**：我们评估两种可能的交换：\n      i. 交换 1：用新边 $\\{a,c\\}, \\{b,d\\}$ 替换 $\\{a,b\\}, \\{c,d\\}$。\n      ii. 交换 2：用新边 $\\{a,d\\}, \\{b,c\\}$ 替换 $\\{a,b\\}, \\{c,d\\}$。\n   c. **约束验证**：对于每个潜在的交换，我们验证两个约束：\n      i. **简单性**：提议的新边不能已存在于图中。使用基于集合的图表示，此检查非常高效。\n      ii. **连通性**：交换后图必须保持连通。我们通过创建一个带有交换后边的临时图状态，并从任意节点开始执行图遍历（如广度优先搜索 (BFS) 或深度优先搜索 (DFS)）来验证这一点。当且仅当遍历访问了所有 $|V|$ 个节点时，图是连通的。\n   d. **成本效益分析**：如果一个交换是有效的，我们计算布线长度的变化量 $\\Delta L = L_{\\text{new}} - L_{\\text{old}}$。如果 $\\Delta L  0$，则该交换是改进的。我们跟踪提供最大长度减少（即最负的 $\\Delta L$）的有效交换。\n   e. **状态更新**：在评估了所有可能的交换后，如果找到了一个改进的交换，我们将其中的最佳交换应用到图的边集，并更新当前总长度 $L_{\\text{current}}$。如果没有改进的交换存在，则图处于局部最优状态，该测试用例的优化过程终止。\n\n3.  **终止与输出**：循环在达到目标长度 $L_{\\text{target}}$ 或收敛到局部最小值时终止。最终布线长度 $L_{\\text{final}}$ 是终止时图的长度。然后计算所需的比率 $L_{\\text{final}}/L_{\\text{initial}}$。\n\n对于涉及完全图 $K_8$ 的测试用例 C，不可能进行任何双边交换。对于任意一对不相交的边 $\\{a,b\\}$ 和 $\\{c,d\\}$，潜在的新边 $\\{a,c\\}, \\{b,d\\}, \\{a,d\\}, \\{b,c\\}$ 在完全图中必然已经存在。因此，简单性约束永远无法满足，不会执行任何交换，算法预计会立即终止，从而得出 1.0 的长度比率。这展示了算法对约束检查的正确处理。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom collections import deque\n\ndef solve():\n    \"\"\"\n    Solves the neural connectome wiring economy problem for three test cases.\n    \"\"\"\n\n    def run_single_case(params):\n        \"\"\"\n        Executes the greedy optimization for a single test case.\n        \"\"\"\n        node_positions, initial_edges, r = params\n        \n        positions = np.array(node_positions)\n        edge_set = {tuple(sorted(e)) for e in initial_edges}\n        num_nodes = len(positions)\n\n        def get_dist(n1, n2):\n            return np.linalg.norm(positions[n1] - positions[n2])\n\n        def get_total_length(current_edges):\n            if not current_edges:\n                return 0.0\n            return sum(get_dist(u, v) for u, v in current_edges)\n\n        def is_connected(current_edges):\n            if num_nodes = 1:\n                return True\n            if not current_edges:\n                return False\n            \n            adj = {i: [] for i in range(num_nodes)}\n            nodes_with_edges = set()\n            for u, v in current_edges:\n                adj[u].append(v)\n                adj[v].append(u)\n                nodes_with_edges.add(u)\n                nodes_with_edges.add(v)\n            \n            if len(nodes_with_edges) != num_nodes: # If some nodes are isolated\n                return False\n\n            start_node = next(iter(nodes_with_edges))\n            q = deque([start_node])\n            visited = {start_node}\n            count = 1\n            while q:\n                u = q.popleft()\n                for v_neighbor in adj[u]:\n                    if v_neighbor not in visited:\n                        visited.add(v_neighbor)\n                        q.append(v_neighbor)\n                        count += 1\n            return count == num_nodes\n\n        initial_length = get_total_length(edge_set)\n        if initial_length == 0.0:\n            return 1.0\n\n        target_length = (1.0 - r) * initial_length\n        current_length = initial_length\n\n        while current_length > target_length:\n            best_swap_info = None\n            max_reduction = 0.0\n            \n            edge_list = list(edge_set)\n            \n            for i in range(len(edge_list)):\n                for j in range(i + 1, len(edge_list)):\n                    u1, v1 = edge_list[i]\n                    u2, v2 = edge_list[j]\n\n                    if len({u1, v1, u2, v2}) != 4:\n                        continue\n\n                    original_pair_length = get_dist(u1, v1) + get_dist(u2, v2)\n\n                    # Swap 1: {u1,v1}, {u2,v2} -> {u1,u2}, {v1,v2}\n                    new_e1 = tuple(sorted((u1, u2)))\n                    new_e2 = tuple(sorted((v1, v2)))\n                    \n                    if new_e1 not in edge_set and new_e2 not in edge_set:\n                        new_pair_length = get_dist(u1, u2) + get_dist(v1, v2)\n                        reduction = original_pair_length - new_pair_length\n                        \n                        if reduction > max_reduction:\n                            temp_edges = edge_set.copy()\n                            temp_edges.remove(tuple(sorted((u1, v1))))\n                            temp_edges.remove(tuple(sorted((u2, v2))))\n                            temp_edges.add(new_e1)\n                            temp_edges.add(new_e2)\n                            if is_connected(temp_edges):\n                                max_reduction = reduction\n                                best_swap_info = ((u1, v1), (u2, v2), new_e1, new_e2)\n                    \n                    # Swap 2: {u1,v1}, {u2,v2} -> {u1,v2}, {v1,u2}\n                    new_e1_alt = tuple(sorted((u1, v2)))\n                    new_e2_alt = tuple(sorted((v1, u2)))\n\n                    if new_e1_alt not in edge_set and new_e2_alt not in edge_set:\n                        new_pair_length_alt = get_dist(u1, v2) + get_dist(v1, u2)\n                        reduction_alt = original_pair_length - new_pair_length_alt\n                        \n                        if reduction_alt > max_reduction:\n                            temp_edges = edge_set.copy()\n                            temp_edges.remove(tuple(sorted((u1, v1))))\n                            temp_edges.remove(tuple(sorted((u2, v2))))\n                            temp_edges.add(new_e1_alt)\n                            temp_edges.add(new_e2_alt)\n                            if is_connected(temp_edges):\n                                max_reduction = reduction_alt\n                                best_swap_info = ((u1, v1), (u2, v2), new_e1_alt, new_e2_alt)\n\n            if best_swap_info:\n                old1, old2, new1, new2 = best_swap_info\n                edge_set.remove(tuple(sorted(old1)))\n                edge_set.remove(tuple(sorted(old2)))\n                edge_set.add(new1)\n                edge_set.add(new2)\n                current_length -= max_reduction\n            else:\n                break\n        \n        final_length = get_total_length(edge_set)\n        ratio = final_length / initial_length\n        return round(ratio, 6)\n\n    # Test Case A\n    nodes_A = [\n        (0.05, 0.10), (0.15, 0.92), (0.90, 0.80), (0.85, 0.15), (0.40, 0.50),\n        (0.60, 0.55), (0.20, 0.20), (0.30, 0.85), (0.70, 0.25), (0.10, 0.60)\n    ]\n    edges_A = [\n        {0,2}, {0,7}, {0,6}, {1,3}, {1,9}, {1,5}, {2,8}, {2,5}, {3,4},\n        {3,6}, {4,5}, {4,9}, {7,9}, {6,8}, {7,8}\n    ]\n    r_A = 0.07\n    case_A = (nodes_A, edges_A, r_A)\n\n    # Test Case B\n    num_nodes_B = 12\n    nodes_B = [(0.5 + 0.45 * np.cos(2 * np.pi * i / num_nodes_B),\n                0.5 + 0.45 * np.sin(2 * np.pi * i / num_nodes_B)) for i in range(num_nodes_B)]\n    edges_B = set()\n    for i in range(num_nodes_B):\n        edges_B.add(tuple(sorted((i, (i + 1) % num_nodes_B))))\n        # The problem says {i, (i-1) mod 12}, which is the same as {(i-1) mod 12, i}.\n        # So we only add one direction of neighbor connection\n        edges_B.add(tuple(sorted((i, (i + 3) % num_nodes_B))))\n    # Correcting the setup for case B: each node connects to its two nearest neighbors.\n    # The initial set comprehension might miss one side.\n    edges_B_corrected = set()\n    for i in range(num_nodes_B):\n        edges_B_corrected.add(tuple(sorted((i, (i + 1) % num_nodes_B))))\n        edges_B_corrected.add(tuple(sorted((i, (i + 3) % num_nodes_B))))\n    r_B = 0.02\n    case_B = (nodes_B, list(edges_B_corrected), r_B)\n\n\n    # Test Case C\n    num_nodes_C = 8\n    nodes_C = [\n        (0.10, 0.10), (0.20, 0.80), (0.80, 0.20), (0.90, 0.90),\n        (0.50, 0.50), (0.30, 0.70), (0.70, 0.30), (0.40, 0.60)\n    ]\n    edges_C = []\n    for i in range(num_nodes_C):\n        for j in range(i + 1, num_nodes_C):\n            edges_C.append((i, j))\n    r_C = 0.10\n    case_C = (nodes_C, edges_C, r_C)\n    \n    test_cases = [case_A, case_B, case_C]\n    \n    results = []\n    for case in test_cases:\n        result = run_single_case(case)\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}