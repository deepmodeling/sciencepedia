{
    "hands_on_practices": [
        {
            "introduction": "在工作量证明（Proof-of-Work）区块链中，交易的最终性不是绝对的，而是概率性的。这项实践深入探讨了中本聪共识的基础安全模型，您将在此量化交易在双花攻击中被逆转的风险。通过对诚实矿工和恶意矿工之间的竞争进行建模，这个练习  让您能够精确推导出攻击成功的概率，从而深刻理解“六个区块确认”这一经验法则以及PoW系统的核心安全原理。",
            "id": "4264554",
            "problem": "考虑一个工作量证明（PoW）区块链，其中区块的发现被建模为一系列独立试验，每次试验的结果要么是一个诚实区块，要么是一个攻击者区块。设攻击者控制总算力的比例为 $\\alpha \\in (0, \\tfrac{1}{2})$，诚实网络控制的比例为 $1-\\alpha$。一笔交易在收到 $z \\in \\mathbb{N}$ 个确认后被视为已接受，这意味着在包含该交易的区块之后已经附加了 $z$ 个诚实区块。商家在诚实链在该交易之后前进了 $z$ 个区块的停止时刻接受该交易。攻击者从交易被广播的那一刻起就进行私下挖矿，目的是在之后替换掉包含该交易的诚实链段。\n\n将区块发现序列建模为独立的伯努利试验，产生一个诚实区块的概率为 $p = 1-\\alpha$，产生一个攻击者区块的概率为 $q = \\alpha$。设 $K$ 为在第 $z$ 个诚实区块被发现之前，所发现的攻击者区块的数量。随机变量 $K$ 服从参数为 $(z, q)$ 的负二项分布，即\n$$\n\\mathbb{P}[K = k] = \\binom{z+k-1}{k} p^{z} q^{k}, \\quad k \\in \\mathbb{Z}_{\\ge 0}.\n$$\n在第 $z$ 个诚实区块之后，如果攻击者落后了 $d = z - k > 0$ 个区块，那么在一个偏向于诚实网络的有偏随机游走中，攻击者最终追上（并超过）的概率由经典的赌徒破产命中概率给出\n$$\n\\left(\\frac{q}{p}\\right)^{d}.\n$$\n如果 $d \\le 0$，攻击者已经追上或领先，最终逆转以概率 $1$ 发生。\n\n从这些基本建模假设和定义出发，推导出一笔被 $z$ 个确认所接受的交易最终被攻击者逆转的精确概率 $P(z,\\alpha)$。使用负二项分布的尾部和正则化不完全贝塔函数 $I_{x}(a,b) = \\dfrac{B_{x}(a,b)}{B(a,b)}$（其中 $B_{x}(a,b) = \\int_{0}^{x} t^{a-1}(1-t)^{b-1}\\,dt$ 且 $B(a,b) = \\int_{0}^{1} t^{a-1}(1-t)^{b-1}\\,dt$），以闭合形式表示你的最终结果。你的最终答案必须是关于 $z$ 和 $\\alpha$ 的单个解析表达式。不需要进行数值计算或四舍五入。",
            "solution": "用户要求我找出交易最终被逆转的概率。\n\n### 第 1 步：提取已知条件\n-   攻击者算力比例：$\\alpha \\in (0, \\frac{1}{2})$。\n-   诚实网络算力比例：$1-\\alpha$。\n-   所需确认数：$z \\in \\mathbb{N}$。\n-   诚实区块的概率（成功）：$p = 1-\\alpha$。\n-   攻击者区块的概率（失败）：$q = \\alpha$。\n-   $K$ 是在找到第 $z$ 个诚实区块之前发现的攻击者区块的数量。\n-   $K$ 的概率质量函数为 $\\mathbb{P}[K=k] = \\binom{z+k-1}{k} p^z q^k$，对于 $k \\in \\mathbb{Z}_{\\ge 0}$。\n-   攻击者的链落后量为 $d = z-k$。\n-   给定 $K=k$ 时，逆转的概率是：\n    -   如果 $z-k > 0$（即 $k  z$），则为 $\\left(\\frac{q}{p}\\right)^{z-k}$。\n    -   如果 $z-k \\le 0$（即 $k \\ge z$），则为 $1$。\n-   目标是求出总的逆转概率 $P(z, \\alpha)$。\n-   最终答案必须用 $z$、$\\alpha$ 和正则化不完全贝塔函数 $I_x(a,b)$ 来表示。\n\n### 第 2 步：使用提取的已知条件进行验证\n问题陈述提供了一个定义明确的概率模型，用于分析区块链安全性，特别是双花攻击场景。该模型是加密货币学术文献中的一个标准且受尊重的研究方法，源于 Satoshi Nakamoto 的白皮书，后来由像 Meni Rosenfeld 这样的研究人员形式化。\n\n-   **科学依据：** 该模型基于概率论的基本原理（伯努利试验、负二项分布、赌徒破产问题）。$\\alpha  1/2$ 的假设是工作量证明区块链的标准安全假设，确保诚实链的预期增长速度快于任何攻击者链。该问题在科学上是合理的。\n-   **适定性：** 该问题提供了计算所需总概率的所有必要定义、变量和条件概率。目标明确，结构设置确保了唯一解的存在。\n-   **客观性：** 该问题使用精确的数学语言陈述，没有任何主观或模棱两可的术语。\n\n所有有效性标准均已满足。该问题是有效的。\n\n### 第 3 步：结论与行动\n该问题是有效的。我将继续进行求解。\n\n### 逆转概率的推导\n\n设 $E$ 为交易最终被逆转的事件。我们寻求计算 $P(z, \\alpha) = \\mathbb{P}[E]$。我们可以通过应用全概率定律，以在 $z$ 个确认时点前发现的攻击者区块数量 $K$ 为条件来计算此概率。\n\n$$\nP(z, \\alpha) = \\sum_{k=0}^{\\infty} \\mathbb{P}[E | K=k] \\mathbb{P}[K=k]\n$$\n\n问题根据攻击者是落后 ($k  z$) 还是不落后 ($k \\ge z$) 提供了条件概率 $\\mathbb{P}[E | K=k]$。我们可以相应地将求和分为两部分：\n$$\nP(z, \\alpha) = \\sum_{k=0}^{z-1} \\mathbb{P}[E | K=k] \\mathbb{P}[K=k] + \\sum_{k=z}^{\\infty} \\mathbb{P}[E | K=k] \\mathbb{P}[K=k]\n$$\n代入给定的条件概率：\n$$\nP(z, \\alpha) = \\sum_{k=0}^{z-1} \\left(\\frac{q}{p}\\right)^{z-k} \\mathbb{P}[K=k] + \\sum_{k=z}^{\\infty} (1) \\cdot \\mathbb{P}[K=k]\n$$\n我们分别分析每个求和。\n\n第二个和就是 $K$ 的负二项分布的尾部概率：\n$$\n\\text{Sum 2} = \\sum_{k=z}^{\\infty} \\mathbb{P}[K=k] = \\mathbb{P}[K \\ge z]\n$$\n对于在 $z$ 次成功（成功概率为 $p$）之前出现 $K$ 次失败的负二项随机变量，其累积分布函数（CDF）通过 $\\mathbb{P}[K \\le k] = I_p(z, k+1)$ 与正则化不完全贝塔函数相关。因此，尾部概率为：\n$$\n\\mathbb{P}[K \\ge z] = 1 - \\mathbb{P}[K \\le z-1] = 1 - I_p(z, (z-1)+1) = 1 - I_p(z, z)\n$$\n\n现在，我们来分析第一个和。我们代入 $K$ 的概率质量函数（PMF），$\\mathbb{P}[K=k] = \\binom{z+k-1}{k} p^z q^k$：\n$$\n\\text{Sum 1} = \\sum_{k=0}^{z-1} \\left(\\frac{q}{p}\\right)^{z-k} \\binom{z+k-1}{k} p^z q^k\n$$\n我们来简化求和内的项：\n$$\n\\left(\\frac{q}{p}\\right)^{z-k} p^z q^k = \\frac{q^{z-k}}{p^{z-k}} p^z q^k = p^{z - (z-k)} q^{k + (z-k)} = p^k q^z\n$$\n所以第一个和变为：\n$$\n\\text{Sum 1} = \\sum_{k=0}^{z-1} \\binom{z+k-1}{k} p^k q^z = q^z \\sum_{k=0}^{z-1} \\binom{z+k-1}{k} p^k\n$$\n为了计算这个有限和，我们使用负二项级数的恒等式：$\\sum_{k=0}^{\\infty} \\binom{n+k-1}{k} x^k = (1-x)^{-n}$。对于我们的和，当 $n=z$ 且 $x=p$ 时，完整的无穷级数将是 $\\sum_{k=0}^{\\infty} \\binom{z+k-1}{k} p^k = (1-p)^{-z} = q^{-z}$。\n\n我们可以将这个有限和表示为无穷级数减去其尾部：\n$$\n\\sum_{k=0}^{z-1} \\binom{z+k-1}{k} p^k = \\left(\\sum_{k=0}^{\\infty} \\binom{z+k-1}{k} p^k\\right) - \\left(\\sum_{k=z}^{\\infty} \\binom{z+k-1}{k} p^k\\right) = q^{-z} - \\sum_{k=z}^{\\infty} \\binom{z+k-1}{k} p^k\n$$\n将此代回第一个和的表达式中：\n$$\n\\text{Sum 1} = q^z \\left(q^{-z} - \\sum_{k=z}^{\\infty} \\binom{z+k-1}{k} p^k\\right) = 1 - q^z \\sum_{k=z}^{\\infty} \\binom{z+k-1}{k} p^k\n$$\n项 $q^z \\sum_{k=z}^{\\infty} \\binom{z+k-1}{k} p^k$ 可以解释为另一个负二项分布的尾部概率。设 $K'$ 是一个随机变量，表示在 $z$ 次成功之前发生失败的次数，其中成功概率为 $q$，失败概率为 $p=1-q$。$K'$ 的概率质量函数为 $\\mathbb{P}[K'=k] = \\binom{z+k-1}{k} q^z p^k$。\n因此，该项为 $\\sum_{k=z}^{\\infty} \\mathbb{P}[K'=k] = \\mathbb{P}[K' \\ge z]$。使用相同的 CDF 与贝塔函数恒等式，我们得到：\n$$\n\\mathbb{P}[K' \\ge z] = 1 - \\mathbb{P}[K' \\le z-1] = 1 - I_q(z, z)\n$$\n因此，第一个和的计算结果为：\n$$\n\\text{Sum 1} = 1 - \\mathbb{P}[K' \\ge z] = 1 - (1 - I_q(z,z)) = I_q(z,z)\n$$\n\n最后，我们将两个和相加，得到总概率 $P(z, \\alpha)$：\n$$\nP(z, \\alpha) = \\text{Sum 1} + \\text{Sum 2} = I_q(z,z) + (1 - I_p(z,z))\n$$\n我们现在使用正则化不完全贝塔函数的基本恒等式：$I_x(a,b) + I_{1-x}(b,a) = 1$。\n在我们的情况下，当 $x=q$, $1-x=p$ 且 $a=b=z$ 时，该恒等式变为 $I_q(z,z) + I_p(z,z) = 1$。\n这意味着 $1 - I_p(z,z) = I_q(z,z)$。\n将此代入我们关于 $P(z, \\alpha)$ 的表达式中：\n$$\nP(z, \\alpha) = I_q(z,z) + I_q(z,z) = 2 I_q(z,z)\n$$\n因为 $q = \\alpha$，所以最终逆转概率的最终表达式为：\n$$\nP(z, \\alpha) = 2 I_{\\alpha}(z,z)\n$$",
            "answer": "$$\n\\boxed{2 I_{\\alpha}(z,z)}\n$$"
        },
        {
            "introduction": "除了共识算法本身，区块链的韧性还取决于其底层点对点（P2P）通信网络的结构。这项实践  将焦点从抽象的协议转移到具体的网络拓扑结构，要求您分析P2P图的连接模式。您将实现关键的网络科学指标并模拟针对性的攻击，以理解网络结构如何影响系统的去中心化程度和稳健性。",
            "id": "4264612",
            "problem": "您将获得区块链和加密货币网络中对等（P2P）连接的无向样本。将每个样本建模为一个具有固定数量节点和无序对边列表的简单无向图。您必须使用复杂网络的基本原理，为每个样本计算三个量：所有节点的经验度分布、度相关性系数以及在目标性节点移除下的弹性剖面。请纯粹以数学术语进行分析，并实现一个单一程序，为提供的测试套件生成指定的输出。\n\n需要使用并从中推导的基本原理和定义：\n- 一个简单无向图由一个大小为 $N$ 的节点集和边集 $E \\subset \\{\\{u,v\\} \\mid u,v \\in \\{0,1,\\dots,N-1\\}, u \\neq v\\}$ 定义，图中没有平行边和自环。\n- 节点 $i$ 的度，记为 $k_i$，是图上节点 $i$ 的邻居数量，由 $E$ 定义的邻接关系导出。\n- 经验度分布是在 $\\{0,1,\\dots,k_{\\max}\\}$ 上的概率质量函数，其中 $k_{\\max} = \\max_{i} k_i$，概率 $p_k$ 等于度恰好为 $k$ 的节点所占的比例；即，$p_k = \\frac{1}{N} |\\{i \\mid k_i = k\\}|$。\n- 度相关性（Degree assortativity）定义为所有边两端节点度的皮尔逊相关系数。设 $m = |E|$ 为边的数量。设边两端度的均值为 $\\mu = \\frac{1}{2m} \\sum_{\\{u,v\\}\\in E} (k_u + k_v)$。设配对的边两端度的协方差为 $\\mathrm{cov} = \\frac{1}{m} \\sum_{\\{u,v\\}\\in E} (k_u - \\mu)(k_v - \\mu)$，边两端度的方差为 $\\sigma^2 = \\frac{1}{2m} \\sum_{\\{u,v\\}\\in E} [(k_u - \\mu)^2 + (k_v - \\mu)^2]$。相关性系数为 $r = \\frac{\\mathrm{cov}}{\\sigma^2}$，并约定如果 $m=0$ 或 $\\sigma^2=0$，则 $r=0$。\n- 目标性攻击下的弹性通过依次移除高度节点并量化剩余节点中最大连通分量的大小来衡量。移除策略是自适应的：在每一步移除时，选择当前度最高的节点；如果存在平局，则选择索引最小的节点。移除 $K$ 个节点后，计算最大连通分量中剩余节点的数量 $S_{\\max}$，并报告弹性比率 $R = \\frac{S_{\\max}}{N}$。\n\n为每个测试用例实现的任务:\n1. 计算所有 $N$ 个节点（包括度为 $0$ 的节点）的经验度分布 $[p_0, p_1, \\dots, p_{k_{\\max}}]$。\n2. 使用上面定义的皮尔逊相关性计算度相关性系数 $r$。\n3. 计算移除比例列表 $P = [p^{(1)}, p^{(2)}, \\dots, p^{(L)}]$ 对应的弹性比率 $R$，其中每个 $p^{(l)}$ 是要移除的节点占总数的十进制比例。对于每个比例 $p^{(l)}$，从原始图开始独立地、自适应地移除 $K^{(l)} = \\left\\lfloor p^{(l)} N \\right\\rfloor$ 个节点，并报告相应的 $R^{(l)}$。\n\n所有量都是无单位的概率或比率。所有分数都表示为小数。不使用角度。\n\n测试套件：\n- 案例 $1$ (标准情况，集群化的P2P结构):\n    - $N = 10$\n    - $E = \\{(0,1),(1,2),(2,0),(2,3),(3,4),(4,5),(5,3),(6,7),(7,8),(8,6),(8,9),(0,9)\\}$\n    - $P = [0.0, 0.1, 0.25, 0.5]$\n- 案例 $2$ (边界条件，星形拓扑):\n    - $N = 8$\n    - $E = \\{(0,1),(0,2),(0,3),(0,4),(0,5),(0,6),(0,7)\\}$\n    - $P = [0.0, 0.1, 0.25, 0.5]$\n- 案例 $3$ (边缘情况，不相交的连通分量和孤立节点):\n    - $N = 9$\n    - $E = \\{(0,1),(1,2),(3,4),(4,5),(5,3)\\}$\n    - $P = [0.0, 0.1, 0.25, 0.5]$\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。对于每个案例，输出一个形式为 $[\\text{degree\\_distribution}, r, \\text{resilience\\_vector}]$ 的列表，其中 $\\text{degree\\_distribution}$ 是一个小数列表 $[p_0,\\dots,p_{k_{\\max}}]$，$r$ 是一个小数，而 $\\text{resilience\\_vector}$ 是一个与 $P$ 对应的小数列表。因此，总输出在一行内，格式为 $[\\text{case}_1,\\text{case}_2,\\text{case}_3]$，例如 $[[[p_0,\\dots],r,[R^{(1)},\\dots]],[\\dots],[\\dots]]$。",
            "solution": "该问题要求为给定的图样本计算三个网络理论量：经验度分布、度相关性系数以及在目标性节点移除策略下的弹性剖面。解决方案的结构是直接根据提供的数学定义实现算法。\n\n一个无向图使用邻接表来表示，这是一个从每个节点索引 $i \\in \\{0, 1, \\dots, N-1\\}$ 到其邻居集合的映射。这种结构对于计算节点度和图遍历算法非常高效。\n\n**1. 经验度分布**\n\n首先，计算每个节点 $i$ 的度 $k_i$。节点的度是其在邻接表中邻居集合的大小。\n设所有 $N$ 个节点的度列表为 $[k_0, k_1, \\dots, k_{N-1}]$。图中最大度为 $k_{\\max} = \\max_{i} k_i$。\n经验度分布是概率质量函数 $\\{p_k\\}$，其中 $p_k$ 是度为 $k$ 的节点所占的比例。这通过首先为从 $0$ 到 $k_{\\max}$ 的每个度值创建频率计数来计算。对于每个 $k \\in \\{0, 1, \\dots, k_{\\max}\\}$，我们计算度为 $k$ 的节点数 $N_k = |\\{i \\mid k_i = k\\}|$。然后，概率 $p_k$ 由以下公式给出：\n$$p_k = \\frac{N_k}{N}$$\n此部分的最终输出是一个列表 $[p_0, p_1, \\dots, p_{k_{\\max}}]$。\n\n**2. 度相关性系数**\n\n度相关性系数 $r$ 是根据提供的类皮尔逊相关性公式计算的。设边集为 $E$，其大小为 $m = |E|$。如果 $m=0$，则 $r$ 定义为 $0$。否则，我们按以下步骤进行：\n首先，我们使用先前计算的节点度 $k_i$。\n计算所有边两端度的均值 $\\mu$。共有 $2m$ 个这样的边端。\n$$\\mu = \\frac{1}{2m} \\sum_{\\{u,v\\}\\in E} (k_u + k_v)$$\n接下来，边两端度的方差 $\\sigma^2$ 是所有边两端度的方差。\n$$\\sigma^2 = \\frac{1}{2m} \\sum_{\\{u,v\\}\\in E} \\left[ (k_u - \\mu)^2 + (k_v - \\mu)^2 \\right]$$\n如果 $\\sigma^2=0$，则 $r$ 定义为 $0$。例如，在所有节点度都相同的正则图中，会发生这种情况。\n然后，计算跨边度的协方差 $\\mathrm{cov}$：\n$$\\mathrm{cov} = \\frac{1}{m} \\sum_{\\{u,v\\}\\in E} (k_u - \\mu)(k_v - \\mu)$$\n最后，相关性系数 $r$ 是协方差与方差的比值：\n$$r = \\frac{\\mathrm{cov}}{\\sigma^2}$$\n\n**3. 弹性剖面**\n\n网络弹性通过模拟目标性攻击来评估。对于列表 $P$ 中每个指定的移除比例 $p^{(l)}$，独立执行以下过程，每次都从原始图开始。\n\n首先，计算要移除的节点数 $K^{(l)} = \\lfloor p^{(l)} N \\rfloor$。\n移除过程是自适应的，迭代 $K^{(l)}$ 步。在每一步中：\n1. 计算图中所有剩余节点的当前度。节点的度是其邻居中也仍在图中的节点数量。\n2. 识别当前度最高的节点。如果多个节点共享相同的最高度，则选择节点索引最小的那个进行移除。此平局打破规则确保了过程的确定性。\n3. 将选定的节点从图中移除。\n\n在移除 $K^{(l)}$ 个节点后，分析剩余图的结构。我们必须找到最大连通分量的大小 $S_{\\max}$。这可以通过图遍历算法（如广度优先搜索 (BFS) 或深度优先搜索 (DFS)）来实现。对剩余图中每个未访问过的节点启动该算法，计算其所在分量的节点数。在所有分量中找到的最大大小即为 $S_{\\max}$。如果没有剩余节点，则 $S_{\\max} = 0$。\n\n然后，弹性比率 $R^{(l)}$ 计算为原始节点中位于最大连通分量内的节点比例：\n$$R^{(l)} = \\frac{S_{\\max}}{N}$$\n对 $P$ 中的所有比例重复此过程，得到一个弹性比率列表 $[R^{(1)}, R^{(2)}, \\dots, R^{(L)}]$。\n\n这三个计算量——$[p_0, \\dots, p_{k_{\\max}}]$、$r$ 和 $[R^{(1)}, \\dots, R^{(L)}]$——的组合构成单个测试用例的完整结果。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    test_cases = [\n        {\n            \"N\": 10,\n            \"E\": [(0,1),(1,2),(2,0),(2,3),(3,4),(4,5),(5,3),(6,7),(7,8),(8,6),(8,9),(0,9)],\n            \"P\": [0.0, 0.1, 0.25, 0.5]\n        },\n        {\n            \"N\": 8,\n            \"E\": [(0,1),(0,2),(0,3),(0,4),(0,5),(0,6),(0,7)],\n            \"P\": [0.0, 0.1, 0.25, 0.5]\n        },\n        {\n            \"N\": 9,\n            \"E\": [(0,1),(1,2),(3,4),(4,5),(5,3)],\n            \"P\": [0.0, 0.1, 0.25, 0.5]\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        result = process_case(case[\"N\"], case[\"E\"], case[\"P\"])\n        all_results.append(result)\n\n    # Format the final output string as per specifications.\n    results_str = []\n    for res_case in all_results:\n        dist_str = f\"[{','.join(map(str, res_case[0]))}]\"\n        r_str = str(res_case[1])\n        resil_str = f\"[{','.join(map(str, res_case[2]))}]\"\n        results_str.append(f\"[{dist_str},{r_str},{resil_str}]\")\n    \n    final_output = f\"[{','.join(results_str)}]\"\n    print(final_output)\n\ndef process_case(N, E, P):\n    \"\"\"\n    Processes a single test case to compute degree distribution, assortativity, and resilience.\n    \"\"\"\n    if N == 0:\n        dist = [1.0] if N == 0 else [] # Special case for N=0\n        r = 0.0\n        resilience = [0.0] * len(P)\n        return [dist, r, resilience]\n\n    # Build adjacency list\n    adj = {i: set() for i in range(N)}\n    for u, v in E:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    # 1. Degree Distribution\n    degrees = np.array([len(adj[i]) for i in range(N)])\n    if len(degrees) == 0:\n        k_max = -1\n    else:\n        k_max = np.max(degrees) if N > 0 else -1\n        \n    counts = np.bincount(degrees, minlength=k_max + 1 if k_max >= 0 else 0)\n    p_k = (counts / N).tolist() if N > 0 else []\n\n    # 2. Degree Assortativity\n    m = len(E)\n    if m == 0:\n        r = 0.0\n    else:\n        mu_numerator = sum(degrees[u] + degrees[v] for u, v in E)\n        mu = mu_numerator / (2 * m)\n\n        sigma_sq_numerator = sum((degrees[u] - mu)**2 + (degrees[v] - mu)**2 for u, v in E)\n        sigma_sq = sigma_sq_numerator / (2 * m)\n\n        if sigma_sq == 0:\n            r = 0.0\n        else:\n            cov_numerator = sum((degrees[u] - mu) * (degrees[v] - mu) for u, v in E)\n            cov = cov_numerator / m\n            r = cov / sigma_sq\n    \n    # 3. Resilience Profile\n    resilience_ratios = []\n    for p_frac in P:\n        K = int(p_frac * N)\n        \n        active_nodes = set(range(N))\n        \n        # Adaptive node removal\n        for _ in range(K):\n            if not active_nodes:\n                break\n                \n            max_deg = -1\n            nodes_to_remove_candidates = []\n            \n            # Calculate current degrees of active nodes\n            current_degrees = {}\n            for node in active_nodes:\n                current_deg = sum(1 for neighbor in adj[node] if neighbor in active_nodes)\n                current_degrees[node] = current_deg\n                if current_deg > max_deg:\n                    max_deg = current_deg\n            \n            # Find all nodes with max degree\n            for node in active_nodes:\n                if current_degrees[node] == max_deg:\n                    nodes_to_remove_candidates.append(node)\n            \n            # Tie-break with smallest index\n            node_to_remove = min(nodes_to_remove_candidates)\n            active_nodes.remove(node_to_remove)\n\n        # Find largest connected component size (S_max)\n        s_max = 0\n        visited = set()\n        for i in active_nodes:\n            if i not in visited:\n                component_size = 0\n                q = [i]\n                visited.add(i)\n                \n                head = 0\n                while head  len(q):\n                    u = q[head]\n                    head += 1\n                    component_size += 1\n                    for v in adj[u]:\n                        if v in active_nodes and v not in visited:\n                            visited.add(v)\n                            q.append(v)\n                \n                if component_size > s_max:\n                    s_max = component_size\n        \n        resilience_ratio = s_max / N if N > 0 else 0\n        resilience_ratios.append(resilience_ratio)\n\n    return [p_k, r, resilience_ratios]\n\nif __name__ == '__main__':\n    solve()\n```"
        },
        {
            "introduction": "权益证明（Proof-of-Stake）为高能耗的工作量证明提供了一种替代方案，它通过经济激励而非原始算力来保障网络安全。PoS系统的安全性关键在于使恶意行为在经济上变得不理性。这项实践  让您扮演机制设计者的角色，挑战您运用博弈论和期望效用原理，来确定为阻止验证者试图欺骗系统所需的最低“罚没”（slashing）惩罚。",
            "id": "4264538",
            "problem": "一个权益证明 (PoS) 区块链通过罚没 (slashing) 来惩罚双重签名 (double-signing)。考虑一个具有代表性的验证者，其质押了 $S$ 个代币。当被选为区块提议者时，他面临一个一次性的机会来进行模棱两可的行为（双重签名）。该验证者是风险中性的，其目标是最大化预期折扣效用，每个时期的折扣因子为 $\\delta \\in (0,1)$。只要验证者保持活跃且未被罚没，基准协议会为每个质押的代币带来每个时期 $y$ 个代币的预期奖励率。\n\n假设以下基本要素是给定的并且具有科学依据：\n1. 诚实行事的基准奖励流的现值为 $C = \\frac{\\delta y S}{1 - \\delta}$。\n2. 如果验证者进行模棱两可的行为，一个对手方会提供一笔贿赂，在创造可证明的模棱两可行为后，立即产生 $b$ 个代币的预期收益。\n3. 双重签名的证据通过一个八卦网络（gossip network）传播，该网络被建模为速率为 $\\lambda  0$ 的泊松过程。在一个长度为 $T  0$ 个时期的检测窗口内，至少有一个证据到达链上的概率是 $p_{d} = 1 - \\exp(-\\lambda T)$。\n4. 如果在窗口期内被检测到，验证者将被罚没其质押金的一部分，比例为 $s \\in [0,1]$（损失 $s S$ 个代币），并被监禁或驱逐，这将摧毁其未来基准奖励现值的一部分，比例为 $\\gamma \\in [0,1]$，因此检测后的持续价值变为 $(1 - \\gamma) C$。如果在窗口期内未被检测到，则不进行罚没，持续价值保持为 $C$。\n5. 当前时期与双重签名选择无关的即时基准收益在比较中会相互抵消，因此可以忽略。\n\n仅使用预期效用最大化的第一性原理和上述基本要素，推导出一个严格的激励相容约束，使得在决策点上，诚实行为弱优于模棱两可的行为，并求解强制执行此约束的最小罚没比例 $s_{\\min}$。将 $s_{\\min}$ 明确表示为参数 $\\{b, S, \\gamma, \\delta, y, \\lambda, T\\}$ 的一个闭式函数。假设参数满足 $0  s_{\\min}  1$，因此边界截断不生效。您的最终答案必须是单一的闭式表达式。无需四舍五入。",
            "solution": "该问题是有效的。它提出了一个定义明确的权益证明区块链中验证者行为的经济模型，使用了预期效用理论和网络建模的标准原理。所有参数都得到了明确定义，并且前提在经济建模和计算机科学的背景下具有科学依据。任务是推导一个激励相容约束并求解一个最小参数值，这是机制设计中的一个标准流程。\n\n目标是找到最小的罚没比例，记为 $s_{\\min}$，以确保对于一个风险中性的验证者来说，诚实行为是一个弱占优策略。这通过建立一个激励相容 (IC) 约束来实现，其中诚实行为的预期效用大于或等于模棱两可行为（双重签名）的预期效用。\n\n设 $U_{\\text{honest}}$ 为选择诚实行事所带来的预期效用，设 $U_{\\text{equivocate}}$ 为选择模棱两可行为所带来的预期效用。验证者是风险中性的，因此效用等同于以代币计价的收益的期望值。\n\n首先，我们确定诚实行事的预期效用。如果验证者诚实行事，他们不会收到贿赂，也不会被罚没。他们的收益由未来基准奖励的持续价值构成。根据问题陈述，两种选择共有的即时收益可以被忽略。诚实行为的持续流现值被给定为 $C$。\n$$\nU_{\\text{honest}} = C\n$$\n\n接下来，我们确定模棱两可行为的预期效用。如果验证者采取模棱两可的行为，他们会立即收到一笔 $b$ 个代币的贿赂。他们随后的效用取决于模棱两可行为的证据是否在时间窗口 $T$ 内被检测到并被包含在链上。\n检测到的概率给定为 $p_d = 1 - \\exp(-\\lambda T)$。\n因此，未被检测到的概率是 $1 - p_d = \\exp(-\\lambda T)$。\n\n如果发生检测（概率为 $p_d$）：\n- 验证者被罚没，招致 $sS$ 个代币的损失。\n- 他们未来奖励的现值减少了 $\\gamma$ 的比例，因此持续价值变为 $(1 - \\gamma)C$。\n在这种结果下的总价值是 $-sS + (1 - \\gamma)C$。\n\n如果未发生检测（概率为 $1 - p_d$）：\n- 验证者不会被罚没。\n- 未来奖励的持续价值保持为 $C$。\n在这种结果下的总价值是 $C$。\n\n模棱两可行为的预期效用是即时贿赂与各种结果的加权平均值之和：\n$$\nU_{\\text{equivocate}} = b + p_d \\left( -sS + (1 - \\gamma)C \\right) + (1 - p_d)C\n$$\n我们可以简化这个表达式：\n$$\nU_{\\text{equivocate}} = b - p_d sS + p_d (1 - \\gamma)C + C - p_d C\n$$\n$$\nU_{\\text{equivocate}} = b - p_d sS + p_d C - p_d \\gamma C + C - p_d C\n$$\n$$\nU_{\\text{equivocate}} = b - p_d sS - p_d \\gamma C + C\n$$\n这可以重写为：\n$$\nU_{\\text{equivocate}} = b + C - p_d(sS + \\gamma C)\n$$\n\n诚实行事成为弱占优策略的激励相容约束是 $U_{\\text{honest}} \\ge U_{\\text{equivocate}}$。代入效用的表达式：\n$$\nC \\ge b + C - p_d(sS + \\gamma C)\n$$\n从两边减去 $C$ 得到：\n$$\n0 \\ge b - p_d(sS + \\gamma C)\n$$\n重新排列各项，我们得到了安全条件的优雅形式：\n$$\np_d(sS + \\gamma C) \\ge b\n$$\n这个约束表明，来自模棱两可行为的预期惩罚（即检测概率乘以直接罚没和未来奖励损失的货币化价值之和）必须至少与贿赂一样大。\n\n为了找到强制执行此约束的最小罚没比例 $s_{\\min}$，我们将不等式设为等式，使用 $s = s_{\\min}$：\n$$\np_d(s_{\\min}S + \\gamma C) = b\n$$\n现在，我们求解 $s_{\\min}$：\n$$\ns_{\\min}S + \\gamma C = \\frac{b}{p_d}\n$$\n$$\ns_{\\min}S = \\frac{b}{p_d} - \\gamma C\n$$\n$$\ns_{\\min} = \\frac{1}{S} \\left( \\frac{b}{p_d} - \\gamma C \\right)\n$$\n问题提供了 $p_d$ 和 $C$ 的显式形式：\n$$\np_d = 1 - \\exp(-\\lambda T)\n$$\n$$\nC = \\frac{\\delta y S}{1 - \\delta}\n$$\n将这些代入 $s_{\\min}$ 的表达式中：\n$$\ns_{\\min} = \\frac{1}{S} \\left( \\frac{b}{1 - \\exp(-\\lambda T)} - \\gamma \\left( \\frac{\\delta y S}{1 - \\delta} \\right) \\right)\n$$\n最后，我们分配 $\\frac{1}{S}$ 项以获得闭式解：\n$$\ns_{\\min} = \\frac{b}{S(1 - \\exp(-\\lambda T))} - \\frac{\\gamma \\delta y}{1 - \\delta}\n$$\n这就是使诚实行事成为弱占优策略所需的最小罚没比例，表示为给定参数的函数。假设 $0  s_{\\min}  1$ 确保了这个内部解是有效的，无需考虑边界条件。",
            "answer": "$$\\boxed{\\frac{b}{S(1 - \\exp(-\\lambda T))} - \\frac{\\gamma \\delta y}{1 - \\delta}}$$"
        }
    ]
}