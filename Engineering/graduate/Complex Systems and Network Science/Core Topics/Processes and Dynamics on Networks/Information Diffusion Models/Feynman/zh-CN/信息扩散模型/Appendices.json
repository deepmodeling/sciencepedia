{
    "hands_on_practices": [
        {
            "introduction": "理论是基础，但真正的理解始于实践。本练习将引导您深入独立级联（IC）模型的内部机制，通过编写一个程序来精确计算一个小型网络中所有可能的级联结果及其概率。这个过程将帮助您巩固对IC模型等价的“活边”图视角的理解，这是分析更复杂网络扩散现象的基石。",
            "id": "4283251",
            "problem": "考虑一个由图 $G=(V,E)$ 表示的有向网络，其中 $V$ 是节点的有限集合，$E$ 是有向边的有限集合。每条有向边 $(i,j)\\in E$ 都有一个相关的激活概率 $p_{ij}\\in[0,1]$。我们研究独立级联（IC）模型下的信息传播，其定义如下：在时间 $t=0$ 时，从一个初始的激活节点集合 $S\\subseteq V$ 开始。在随后的每个离散时间步，任何在时间 $t$ 激活的节点 $i$ 都有一次机会，通过边 $(i,j)$ 尝试激活其每个当前未激活的出邻居 $j$。对于不同的边，这些尝试是独立的，并以概率 $p_{ij}$ 成功。所有的激活尝试每条边只发生一次，且节点一旦被激活，将永远保持激活状态。当没有新的激活发生时，该过程终止，最终得到一个最终激活集合 $A_\\infty\\subseteq V$。最终级联规模为 $|A_\\infty|$。\n\n从上述概率和独立级联模型的基本定义出发，推导一个有原则的算法，通过“活边”视角枚举激活路径，来计算最终级联规模的精确分布。然后，为指定的小型网络和参数集实现该算法。你的程序必须为下面的每个测试用例计算概率列表 $\\left[\\Pr\\left(|A_\\infty|=s_{\\min}\\right),\\Pr\\left(|A_\\infty|=s_{\\min}+1\\right),\\ldots,\\Pr\\left(|A_\\infty|=|V|\\right)\\right]$，其中 $s_{\\min}=|S|$ 是可能的最小级联规模。所有概率必须表示为小数（即浮点数），并四舍五入到10位小数。你的程序应生成单行输出，包含一个由方括号括起来的逗号分隔列表（例如，$[result1,result2,result3]$），其中每个 $resultk$ 是测试用例 $k$ 的列表。\n\n网络规格：\n- 节点：$V=\\{0,1,2,3,4\\}$，因此 $|V|=5$。\n- 有向边 $E$（按固定顺序用于枚举）：$(0,1)$, $(0,2)$, $(1,2)$, $(1,3)$, $(2,3)$, $(2,4)$, $(3,4)$, $(4,1)$。共有 $|E|=8$ 条边。\n\n测试套件：\n- 测试用例 1（一般重叠路径，单一种子节点）：\n  - 种子集合：$S=\\{0\\}$，因此 $s_{\\min}=1$。\n  - 边激活概率：$p_{0,1}=0.3$, $p_{0,2}=0.6$, $p_{1,2}=0.5$, $p_{1,3}=0.4$, $p_{2,3}=0.7$, $p_{2,4}=0.2$, $p_{3,4}=0.9$, $p_{4,1}=0.1$。\n- 测试用例 2（边界情况，所有边几乎必然不激活）：\n  - 种子集合：$S=\\{0\\}$，因此 $s_{\\min}=1$。\n  - 边激活概率：对于所有 $(i,j)\\in E$，$p_{i,j}=0$。\n- 测试用例 3（边界情况，所有边几乎必然激活）：\n  - 种子集合：$S=\\{0\\}$，因此 $s_{\\min}=1$。\n  - 边激活概率：对于所有 $(i,j)\\in E$，$p_{i,j}=1$。\n- 测试用例 4（多种子节点，一般概率）：\n  - 种子集合：$S=\\{0,2\\}$，因此 $s_{\\min}=2$。\n  - 边激活概率：与测试用例 1 相同。\n\n算法要求：\n- 你的算法必须通过“活边”视角使用路径枚举来计算精确分布：将每条边 $(i,j)$ 视为以概率 $p_{ij}$ 独立地成为活边，以概率 $1-p_{ij}$ 成为死边；枚举所有子集 $F\\subseteq E$ 作为可能的活边实现；计算在 $(V,F)$ 中从 $S$ 出发的可达性；并根据边概率的乘积来聚合每个实现 $F$ 的概率质量。\n- 最终输出必须是单行，包含一个由四个列表组成的列表，每个测试用例一个，其中每个内部列表按升序给出级联规模为 $s_{\\min},s_{\\min}+1,\\ldots,|V|$ 的概率，并四舍五入到10位小数。\n\n你的程序必须是完整的、可运行的，并且不得要求任何用户输入。每个用例的输出类型是浮点数列表。程序必须通过确保每个测试用例的概率总和在很小的数值公差内为1，来进行内部归一化验证。最终的打印输出必须严格按照指定格式生成一行。",
            "solution": "用户希望在一个小型网络中，根据独立级联（IC）模型计算最终级联规模的精确概率分布。这需要严格应用概率论和图论。\n\n### 步骤1：提取给定信息\n- **模型**：有向图 $G=(V, E)$ 上的独立级联（IC）模型。\n- **网络结构**：\n    - 节点：$V=\\{0,1,2,3,4\\}$，因此 $|V|=5$。\n    - 有向边：$E = \\{(0,1), (0,2), (1,2), (1,3), (2,3), (2,4), (3,4), (4,1)\\}$，因此 $|E|=8$。\n- **传播过程**：一个初始种子集合 $S$ 在 $t=0$ 时被激活。在每个步骤中，新激活的节点以给定的概率 $p_{ij}$ 尝试激活其未激活的邻居。一条边 $(i,j)$ 只能用于一次激活尝试。\n- **算法要求**：通过枚举所有可能的活边子图来计算最终级联规模 $|A_\\infty|$ 的精确分布。最小级联规模是 $s_{\\min}=|S|$。\n- **测试用例**：\n    1.  **种子集合**：$S=\\{0\\}$。**概率**：$p_{0,1}=0.3$, $p_{0,2}=0.6$, $p_{1,2}=0.5$, $p_{1,3}=0.4$, $p_{2,3}=0.7$, $p_{2,4}=0.2$, $p_{3,4}=0.9$, $p_{4,1}=0.1$。\n    2.  **种子集合**：$S=\\{0\\}$。**概率**：对于所有 $(i,j)\\in E$，$p_{ij}=0$。\n    3.  **种子集合**：$S=\\{0\\}$。**概率**：对于所有 $(i,j)\\in E$，$p_{ij}=1$。\n    4.  **种子集合**：$S=\\{0,2\\}$。**概率**：与测试用例1相同。\n- **输出格式**：一个包含概率列表的列表的单行，例如 `[[dist1], [dist2], [dist3], [dist4]]`。每个内部列表 `[dist_k]` 包含从 $s=s_{\\min}, s_{\\min}+1, \\ldots, |V|$ 的概率 $\\Pr(|A_\\infty|=s)$，四舍五入到10位小数。\n\n### 步骤2：使用提取的给定信息进行验证\n根据指定标准对问题进行验证。\n- **科学基础**：独立级联模型是网络科学和复杂系统研究中的一个基础且被广泛研究的模型。“活边模型”视角是一种标准的、数学上等价的表述，它有助于进行精确分析。该问题牢固地植根于已建立的科学原理。\n- **适定性**：网络是有限的（$|V|=5, |E|=8$），并且为每个测试用例完全指定了边激活概率集。目标是计算有限结果集（级联规模从 $s_{\\min}$ 到 $|V|$）上的离散概率分布。由于活边配置的数量是有限的（$2^{|E|}$），并且对于每种配置，级联规模都是唯一确定的，因此存在唯一的概率分布。该问题是适定的。\n- **客观性**：问题使用精确的数学定义和客观的数值数据进行陈述。没有歧义、主观性或基于意见的语言。\n\n该问题没有表现出任何已识别的缺陷（例如，科学上不健全、不完整、不现实等）。对于给定的网络规模（$2^8 = 256$ 个实现），枚举方法在计算上是可行的。\n\n### 步骤3：结论与行动\n问题陈述是**有效的**。将开发并实现一个完整的解决方案。\n\n### 基于原理的算法设计\n\n解决此问题的核心原理是动态、时间展开的独立级联（IC）过程与“活边”图上的静态可达性问题之间的等价性。\n\n1.  **活边模型**：IC模型的随机过程可以被重新概念化如下：在扩散开始之前，自然为每条边 $(i, j) \\in E$ “抛硬币”。边以其给定的概率 $p_{ij}$ 被宣告为**活边**，以概率 $1 - p_{ij}$ 被宣告为**死边**。所有边的这些结果都是独立的。这个单一的随机实验生成了子图 $G_F = (V, F)$ 的一个特定实现，其中 $F \\subseteq E$ 是所有活边的集合。一旦这个子图被确定，信息就从种子集合 $S$ 确定性地传播到所有可以从 $S$ 中任何节点通过完全由活边组成的路径到达的节点。最终的激活集合 $A_\\infty$ 正是这个可达节点的集合。\n\n2.  **枚举所有可能性**：因为边成为活边的事件是独立的，所以任何特定活边子图 $G_F = (V, F)$ 的概率是单个边结果概率的乘积：\n    $$ \\Pr(F) = \\left( \\prod_{(i,j) \\in F} p_{ij} \\right) \\left( \\prod_{(i,j) \\in E \\setminus F} (1 - p_{ij}) \\right) $$\n    可能的活边子图总数为 $2^{|E|}$。对于给定的网络， $|E|=8$，所以有 $2^8 = 256$ 种可能的结果（实现）。这个数字足够小，可以进行完全枚举。\n\n3.  **算法**：基于上述原理，计算精确级联规模分布的算法如下：\n    a. 初始化一个大小为 $|V| - s_{\\min} + 1$ 的数组 `size_distribution`，所有元素为零。该数组将存储从 $s_{\\min}$ 到 $|V|$ 的每个可能级联规模的聚合概率。此数组的索引 $k$ 对应于 $s_{\\min} + k$ 的级联规模。\n    b. 遍历边的每个可能子集 $F \\subseteq E$。这可以通过循环一个从 $0$ 到 $2^{|E|}-1$ 的整数计数器，并使用其二进制表示来选择活边来高效实现。\n    c. 对于每个实现 $F$：\n        i.  使用上述公式计算此特定实现 $\\Pr(F)$ 的概率。\n        ii. 构建相应的活边图 $G_F = (V, F)$。\n        iii. 在 $G_F$ 中确定从种子集合 $S$ 可达的节点集。这是一个标准的图可达性问题，可以通过从所有种子节点同时开始的广度优先搜索（BFS）或深度优先搜索（DFS）来有效解决。\n        iv. 设可达集合的大小为 $k = |A_\\infty|$。\n        v. 将概率 $\\Pr(F)$ 加到 `size_distribution` 数组中的相应条目。具体来说，如果大小为 $k$，我们更新索引为 $k - s_{\\min}$ 的条目：`size_distribution[k - s_min] += Pr(F)`。\n    d. 在遍历所有 $2^{|E|}$ 个实现后，`size_distribution` 数组将包含最终级联规模的完整概率分布。\n\n4.  **最终确定**：将所得概率四舍五入到指定的精度（10位小数），以生成每个测试用例的最终输出。内部检查概率总和是否为1.0（在浮点运算的小容差范围内）可作为算法正确性的验证。",
            "answer": "```python\nimport numpy as np\nfrom collections import deque\n\ndef solve():\n    \"\"\"\n    Main function to define the network, test cases, and compute the exact \n    cascade size distributions for the Independent Cascade model via live-edge enumeration.\n    \"\"\"\n\n    # 1. Define the network structure.\n    # Nodes are represented by integers from 0 to 4.\n    nodes = [0, 1, 2, 3, 4]\n    # Edges are given in a fixed order for deterministic enumeration.\n    edges = [(0, 1), (0, 2), (1, 2), (1, 3), (2, 3), (2, 4), (3, 4), (4, 1)]\n    num_nodes = len(nodes)\n    num_edges = len(edges)\n\n    # 2. Define the test cases as specified in the problem statement.\n    # Probabilities for Test Case 1 and 4.\n    p_case1 = {\n        (0, 1): 0.3, (0, 2): 0.6, (1, 2): 0.5, (1, 3): 0.4,\n        (2, 3): 0.7, (2, 4): 0.2, (3, 4): 0.9, (4, 1): 0.1\n    }\n    # Probabilities for Test Case 2 (all edges inactive).\n    p_case2 = {edge: 0.0 for edge in edges}\n    # Probabilities for Test Case 3 (all edges active).\n    p_case3 = {edge: 1.0 for edge in edges}\n\n    test_cases = [\n        {'S': {0}, 'p': p_case1},    # Test Case 1\n        {'S': {0}, 'p': p_case2},    # Test Case 2\n        {'S': {0}, 'p': p_case3},    # Test Case 3\n        {'S': {0, 2}, 'p': p_case1} # Test Case 4\n    ]\n\n    def compute_distribution(seed_set, prob_map):\n        \"\"\"\n        Computes the cascade size distribution for a single test case.\n        \"\"\"\n        s_min = len(seed_set)\n        # Initialize an array to store the probability mass for each cascade size.\n        # Index k corresponds to size s_min + k.\n        size_distribution = np.zeros(num_nodes - s_min + 1)\n\n        # Enumerate all 2^|E| live-edge graph realizations.\n        for i in range(1 << num_edges):\n            live_adj = {node: [] for node in nodes}\n            realization_prob = 1.0\n\n            # For each realization, determine the live-edge graph and its probability.\n            for j in range(num_edges):\n                edge = edges[j]\n                edge_prob = prob_map[edge]\n\n                # The j-th bit of i determines if the j-th edge is live.\n                if (i >> j) & 1:  # Edge is live.\n                    u, v = edge\n                    live_adj[u].append(v)\n                    realization_prob *= edge_prob\n                else:  # Edge is dead.\n                    realization_prob *= (1.0 - edge_prob)\n            \n            # If a realization has zero probability, it can be skipped.\n            if realization_prob == 0.0:\n                continue\n            \n            # Compute the cascade size for this live-edge graph using BFS.\n            queue = deque(seed_set)\n            reachable_nodes = set(seed_set)\n            \n            while queue:\n                u = queue.popleft()\n                for v in live_adj.get(u, []):\n                    if v not in reachable_nodes:\n                        reachable_nodes.add(v)\n                        queue.append(v)\n            \n            cascade_size = len(reachable_nodes)\n            \n            # Add the probability of this realization to the corresponding size bin.\n            if cascade_size >= s_min:\n                size_distribution[cascade_size - s_min] += realization_prob\n        \n        # Internal verification that probabilities sum to 1.\n        if not np.isclose(np.sum(size_distribution), 1.0):\n             # This assert will fail if there is a logical error or significant floating-point drift.\n             # For this problem's scale, drift should be negligible.\n             raise AssertionError(f\"Probabilities do not sum to 1. Sum is {np.sum(size_distribution)}\")\n        \n        return size_distribution\n\n    # 3. Process each test case and collect the results.\n    all_results = []\n    for case in test_cases:\n        seed_set = case['S']\n        prob_map = case['p']\n        \n        dist = compute_distribution(seed_set, prob_map)\n        \n        # Round probabilities to 10 decimal places and convert to a standard Python list.\n        rounded_dist = np.round(dist, 10).tolist()\n        all_results.append(rounded_dist)\n\n    # 4. Print the final output in the exact specified format.\n    # The str() representation of a Python list is '[elem1, elem2, ...]', which\n    # naturally creates the desired format when joining a list of lists.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "影响力是一个依赖于模型的概念，而非节点固有的属性。本练习通过一个精心设计的思想实验，鲜明地对比了线性阈值（LT）模型和独立级联（IC）模型。通过分析在两种不同动态规则下哪个节点能产生最大的影响，您将深刻体会到模型假设对预测结果的决定性作用。",
            "id": "4283370",
            "problem": "考虑一个有向图 $G=(V,E)$，该图旨在对比线性阈值（LT）模型和独立级联（IC）模型下的影响区域。LT模型（Linear Threshold, LT）由节点特定的阈值和加权的入边定义：当来自其已激活入邻居的权重总和达到或超过其阈值时，一个节点变为激活状态。IC模型（Independent Cascade, IC）由边特定的激活概率定义：每个新激活的节点都有一次机会，以给定的边概率独立地激活其每个未激活的出邻居。在两种模型中，选定的种子集在时间步 $t=0$ 时被激活，并在此后保持激活状态。种子集的影响区域是最终变为激活状态的节点集合；在IC模型中，这个区域是随机的，所以我们考虑其期望大小。\n\n按如下方式构建 $G$。令 $V=\\{c,h,t_1,\\dots,t_{10},l_1,\\dots,l_8\\}$，并令 $E$ 由对每个 $i\\in\\{1,\\dots,10\\}$ 的边 $c\\to t_i$ 和对每个 $j\\in\\{1,\\dots,8\\}$ 的边 $h\\to l_j$ 组成。不存在其他边。在LT模型下，设置阈值 $\\theta_{t_i}=0.4$ 和 $\\theta_{l_j}=0.4$，并设置边权重 $w_{c\\to t_i}=1$ 和 $w_{h\\to l_j}=1$；$c$ 和 $h$ 的阈值是无关紧要的，因为种子节点在初始时就被激活了。在IC模型下，对所有相关边设置激活概率 $p_{c\\to t_i}=0.3$ 和 $p_{h\\to l_j}=0.8$。\n\n假设有 $k=1$ 个种子的预算。你的任务是比较影响区域，确定在每个模型下哪个单节点种子能最大化影响力，并解释（如果存在差异的话）最有影响力的种子在不同模型间存在差异的结构性原因。\n\n对于图 $G$，哪个选项正确地指出了在LT和IC模型下最有影响力的单节点种子，并给出了正确的结构性原因？\n\nA. 在LT模型下，选择 $c$ 作为种子可以最大化影响区域；在IC模型下，选择 $h$ 作为种子可以最大化期望影响。结构性原因是，当边权重足以超过阈值时（这里是 $1\\ge 0.4$），LT模型会确定性地激活邻居，因此更多的出邻居确定性地意味着更多的激活；而IC模型依赖于独立的单次尝试，因此较少的邻居但具有较高的单位边概率（这里是 $0.8$）可能比拥有较多邻居但单位边概率较低（这里是 $0.3$）产生更高的期望传播范围。\n\nB. 在LT和IC模型下，选择 $h$ 作为种子都是最优的，因为高的出度总是主导边权重和概率，所以仅凭度中心性就能决定最有影响力的种子，而与模型特定的动态无关。\n\nC. 在LT模型下，选择 $h$ 作为种子是最优的；在IC模型下，选择 $c$ 作为种子是最优的，因为IC模型会为同一条边在多个时间步上累积激活概率，而LT模型则不会，所以IC模型偏爱许多弱边，而LT模型偏爱少数强边。\n\nD. 在LT和IC模型下，任何单节点种子都具有相同的影响力，这是由于传播函数的子模性和单调性，这意味着对于任何具有相同节点集和预算 $k=1$ 的图，不同模型下的最优种子是相同的。",
            "solution": "用户希望我解决一个关于特定图上信息传播模型（LT 和 IC）的问题。\n\n这是我的计划：\n1.  **验证问题陈述**：\n    *   **步骤 1：提取已知条件**：我将列出所有的定义、图结构、模型参数和任务。\n        *   图 $G=(V, E)$。\n        *   节点 $V = \\{c, h, t_1, \\dots, t_{10}, l_1, \\dots, l_8\\}$。总节点数：$1+1+10+8 = 20$。\n        *   边 $E$：$c \\to t_i$ (其中 $i=1, \\dots, 10$) 和 $h \\to l_j$ (其中 $j=1, \\dots, 8$) 。\n        *   **LT模型参数**：\n            *   阈值：对所有 $i$，$\\theta_{t_i} = 0.4$。\n            *   阈值：对所有 $j$，$\\theta_{l_j} = 0.4$。\n            *   $c, h$ 的阈值无关紧要。\n            *   边权重：对所有 $i$， $w_{c \\to t_i} = 1$。\n            *   边权重：对所有 $j$， $w_{h \\to l_j} = 1$。\n        *   **IC模型参数**：\n            *   概率：对所有 $i$， $p_{c \\to t_i} = 0.3$。\n            *   概率：对所有 $j$， $p_{h \\to l_j} = 0.8$。\n        *   **任务**：\n            *   预算 $k=1$ 个种子。\n            *   比较影响区域。\n            *   确定在每个模型下最大化影响力的单节点种子。\n            *   解释任何差异的结构性原因。\n            *   评估给出的选项。\n\n    *   **步骤 2：使用提取的已知条件进行验证**：\n        *   **有科学依据吗？**：是的，LT和IC是网络科学和社交网络分析中的标准模型。该问题是这些模型的教科书式应用。\n        *   **问题定义良好吗？**：是的，图结构和模型参数都已完全指定。任务是找到最优的单节点种子集，这对于两个模型来说都是一个定义明确的问题。每个模型都应该有一个唯一的解。\n        *   **客观吗？**：是的，语言精确且定量。没有主观性陈述。\n        *   **缺陷检查**：\n            1.  **科学/事实不健全**：否。模型定义正确。参数选择有效。\n            2.  **无法形式化/不相关**：否。这是信息传播模型中的一个标准问题。\n            3.  **不完整/矛盾**：否。所有必要信息都已提供。图结构简单明确。\n            4.  **不现实/不可行**：否。这是一个理论构造，但参数在数学和物理上是一致的。\n            5.  **问题设置不当/结构不良**：否。解是唯一且有意义的。问题清晰。\n            6.  **伪深刻/琐碎**：否。它需要理解LT和IC模型之间的根本区别，这是该领域的关键概念。该结构是专门为突出这种差异而设计的。\n            7.  **超出科学可验证范围**：否。结果可以直接计算。\n\n    *   **步骤 3：结论与行动**：该问题是**有效的**。我将继续进行解答。\n\n2.  **解决问题**：\n    *   目标是找到 $k=1$ 时的最优种子。可能的种子是 $V$ 中的任何节点。然而，只有节点 $c$ 和 $h$ 有出边。选择任何 $t_i$ 或 $l_j$ 节点作为种子，其影响传播将只有1（节点自身），因为它们没有出邻居。因此，唯一有意义的种子选择是 $c$ 和 $h$。我需要比较在两种模型下，选择 $c$ 作为种子与选择 $h$ 作为种子的影响力。\n    *   令 $\\sigma_{LT}(S)$ 为LT模型中种子集 $S$ 的影响区域大小。\n    *   令 $\\mathbb{E}[\\sigma_{IC}(S)]$ 为IC模型中种子集 $S$ 的影响区域的期望大小。\n\n    *   **LT模型下的分析**：\n        *   **种子集 $S = \\{c\\}$**：\n            *   在 $t=0$ 时，$c$ 被激活。\n            *   在 $t=1$ 时，我们检查它的邻居，即节点 $t_i$（$i=1, \\dots, 10$）。\n            *   对于每个节点 $t_i$，其唯一的激活入邻居是 $c$。边 $c \\to t_i$ 的权重是 $w_{c \\to t_i} = 1$。\n            *   $t_i$ 的阈值是 $\\theta_{t_i} = 0.4$。\n            *   由于 $w_{c \\to t_i} = 1 \\ge \\theta_{t_i} = 0.4$，节点 $t_i$ 将被激活。\n            *   这对所有 $i=1, \\dots, 10$ 都成立。因此，$c$ 的所有10个邻居都被激活。\n            *   节点 $t_i$ 没有出邻居，所以级联停止。\n            *   最终激活的节点集是 $\\{c, t_1, \\dots, t_{10}\\}$。\n            *   总影响力为 $\\sigma_{LT}(\\{c\\}) = 1 (\\text{种子}) + 10 (\\text{邻居}) = 11$。\n        *   **种子集 $S = \\{h\\}$**：\n            *   在 $t=0$ 时，$h$ 被激活。\n            *   在 $t=1$ 时，我们检查它的邻居，即节点 $l_j$（$j=1, \\dots, 8$）。\n            *   对于每个节点 $l_j$，其唯一的激活入邻居是 $h$。边 $h \\to l_j$ 的权重是 $w_{h \\to l_j} = 1$。\n            *   $l_j$ 的阈值是 $\\theta_{l_j} = 0.4$。\n            *   由于 $w_{h \\to l_j} = 1 \\ge \\theta_{l_j} = 0.4$，节点 $l_j$ 将被激活。\n            *   这对所有 $j=1, \\dots, 8$ 都成立。因此，$h$ 的所有8个邻居都被激活。\n            *   节点 $l_j$ 没有出邻居，所以级联停止。\n            *   最终激活的节点集是 $\\{h, l_1, \\dots, l_8\\}$。\n            *   总影响力为 $\\sigma_{LT}(\\{h\\}) = 1 (\\text{种子}) + 8 (\\text{邻居}) = 9$。\n        *   **LT模型比较**：\n            *   $\\sigma_{LT}(\\{c\\}) = 11$。\n            *   $\\sigma_{LT}(\\{h\\}) = 9$。\n            *   由于 $11 > 9$，LT模型的最优种子是 $c$。\n\n    *   **IC模型下的分析**：\n        *   这个过程是概率性的。我们需要计算期望影响力大小。\n        *   在IC模型中，给定种子集 $S$，激活节点的期望数量是 $|S| + \\sum_{v \\in V \\setminus S} P(\\text{v is activated}|S)$。\n        *   在这种简单的图结构中，一个节点只能被其唯一的入邻居激活。\n        *   **种子集 $S = \\{c\\}$**：\n            *   $c$ 被激活。\n            *   对于每个邻居 $t_i$，它有一次被 $c$ 激活的机会。这以概率 $p_{c \\to t_i} = 0.3$ 发生。\n            *   每个 $t_i$ 的激活是一个成功概率为 $0.3$ 的独立伯努利试验。\n            *   激活的邻居的期望数量是 $\\sum_{i=1}^{10} p_{c \\to t_i} = 10 \\times 0.3 = 3$。\n            *   影响区域的期望大小 $\\mathbb{E}[\\sigma_{IC}(\\{c\\})]$ 是种子集的大小加上新激活节点的期望数量。\n            *   $\\mathbb{E}[\\sigma_{IC}(\\{c\\})] = 1 (\\text{种子}) + \\text{激活邻居的期望数量} = 1 + 10 \\times 0.3 = 1 + 3 = 4$。\n        *   **种子集 $S = \\{h\\}$**：\n            *   $h$ 被激活。\n            *   对于每个邻居 $l_j$，它有一次被 $h$ 激活的机会。这以概率 $p_{h \\to l_j} = 0.8$ 发生。\n            *   每个 $l_j$ 的激活是一个成功概率为 $0.8$ 的独立伯努利试验。\n            *   激活的邻居的期望数量是 $\\sum_{j=1}^{8} p_{h \\to l_j} = 8 \\times 0.8 = 6.4$。\n            *   影响区域的期望大小 $\\mathbb{E}[\\sigma_{IC}(\\{h\\})]$ 是种子集的大小加上新激活节点的期望数量。\n            *   $\\mathbb{E}[\\sigma_{IC}(\\{h\\})] = 1 (\\text{种子}) + \\text{激活邻居的期望数量} = 1 + 8 \\times 0.8 = 1 + 6.4 = 7.4$。\n        *   **IC模型比较**：\n            *   $\\mathbb{E}[\\sigma_{IC}(\\{c\\})] = 4$。\n            *   $\\mathbb{E}[\\sigma_{IC}(\\{h\\})] = 7.4$。\n            *   由于 $7.4 > 4$，IC模型的最优种子是 $h$。\n\n    *   **结果总结**：\n        *   LT模型：最优种子是 $c$。\n        *   IC模型：最优种子是 $h$。\n        *   最优种子在不同模型之间是不同的。\n\n    *   **结构性原因**：\n        *   在LT模型中，一旦满足阈值，激活就是确定性的。由于权重 $w=1$ 远大于阈值 $\\theta=0.4$，对于任何激活节点的邻居，激活都是保证的。因此，影响力与出邻居的数量（出度）成正比。节点 $c$ 的出度是 $10$，而节点 $h$ 的出度是 $8$。因此，$c$ 更好。\n        *   在IC模型中，激活是概率性的。期望激活数量是概率之和，即（出度）$\\times$（每条边的概率）。对于节点 $c$，期望的二次激活数量是 $10 \\times 0.3 = 3$。对于节点 $h$，它是 $8 \\times 0.8 = 6.4$。在这里，$h$ 的更高单位边概率超过了 $c$ 的更多邻居数量。重点是度数和概率的乘积，而不仅仅是度数。因此，$h$ 更好。\n        *   该问题旨在说明，当权重足够高时，LT对连接数量（度数）敏感，而IC对度数和概率的乘积敏感，这使得一个度数较小但边概率高的节点可能更具影响力。\n\n3.  **评估选项**：\n    *   **A. 在LT模型下，选择 $c$ 作为种子可以最大化影响区域；在IC模型下，选择 $h$ 作为种子可以最大化期望影响。结构性原因是，当边权重足以超过阈值时（这里是 $1\\ge 0.4$），LT模型会确定性地激活邻居，因此更多的出邻居确定性地意味着更多的激活；而IC模型依赖于独立的单次尝试，因此较少的邻居但具有较高的单位边概率（这里是 $0.8$）可能比拥有较多邻居但单位边概率较低（这里是 $0.3$）产生更高的期望传播范围。**\n        *   我的分析证实：LT最优是 $c$，IC最优是 $h$。\n        *   给出的LT原因正确。由于 $w > \\theta$，每个邻居都被确定性激活。因此，拥有更多邻居的节点（$c$）获胜。\n        *   给出的IC原因正确。它关系到期望激活数，这取决于度数和概率的乘积。$8 \\times 0.8 > 10 \\times 0.3$，所以 $h$ 获胜。\n        *   此选项似乎完全正确。\n\n    *   **B. 在LT和IC模型下，选择 $h$ 作为种子都是最优的，因为高的出度总是主导边权重和概率，所以仅凭度中心性就能决定最有影响力的种子，而与模型特定的动态无关。**\n        *   这是不正确的。我的分析显示LT最优是 $c$ 而IC最优是 $h$。它们不相同。\n        *   其推理也是有缺陷的。它声称选择 $h$ 是最优的，但是 $c$ 有更高的出度（$10$ 对 $8$）。所以“高的出度总是主导”这个推理将意味着 $c$ 更好，这与该陈述的第一部分相矛盾。仅凭度中心性就能决定影响力的说法正是这个问题旨在反驳的。\n\n    *   **C. 在LT模型下，选择 $h$ 作为种子是最优的；在IC模型下，选择 $c$ 作为种子是最优的，因为IC模型会为同一条边在多个时间步上累积激活概率，而LT模型则不会，所以IC模型偏爱许多弱边，而LT模型偏爱少数强边。**\n        *   预测与我的计算结果完全相反。我发现LT最优是 $c$，IC最优是 $h$。\n        *   关于IC的推理在事实上是不正确的。在标准的IC模型中，一个激活的节点只有**一次机会**来激活其未激活的邻居。对于来自同一父节点的同一条边，不存在跨多个时间步累积概率的情况。（如果一个节点有多个激活的父节点，那么它可以得到多次激活尝试，但这不是所描述的情况）。关于LT的推理也过于简单化和误导性（“LT偏爱少数强边”）。在这种情况下，LT偏爱多条边，因为所有边都足够“强”。\n\n    *   **D. 在LT和IC模型下，任何单节点种子都具有相同的影响力，这是由于传播函数的子模性和单调性，这意味着对于任何具有相同节点集和预算 $k=1$ 的图，不同模型下的最优种子是相同的。**\n        *   这是不正确的。我的计算显示了两种模型下不同的影响值和不同的最优种子。\n        *   其推理是有缺陷的。虽然LT和IC的影响函数确实是单调和子模的，但这并不意味着不同模型的最优种子是相同的。子模性是单个影响函数 $\\sigma(\\cdot)$ 的一个属性，它没有说明两个不同函数 $\\sigma_{LT}(\\cdot)$ 和 $\\sigma_{IC}(\\cdot)$ 之间的关系。LT和IC的最优种子可能不同是一个众所周知的结果，而这个问题就是说明这一点的标准例子。\n\n4.  **最终结论**：\n    *   我的分析表明，在LT模型下，选择 $c$ 作为种子是最优的（$\\sigma_{LT}(\\{c\\})=11$ 对比 $\\sigma_{LT}(\\{h\\})=9$），而在IC模型下，选择 $h$ 作为种子是最优的（$\\mathbb{E}[\\sigma_{IC}(\\{h\\})]=7.4$ 对比 $\\mathbb{E}[\\sigma_{IC}(\\{c\\})]=4$）。\n    *   原因在于，在这种设置下，LT模型归结为出度的比较，而IC模型归结为期望二次激活的比较，即（出度）$\\times$（概率）。\n    *   选项A正确地指出了两种模型的最优种子，并提供了正确的根本原因。\n    *   所有其他选项在预测或推理上，或两者都存在错误。\n\n5.  **最后润色**：\n    *   我将清晰地写出解决方案，用LaTeX定义所有符号。\n    *   我将按要求从验证部分开始。\n    *   然后，我将为LT和IC模型提供详细的推导过程。\n    *   最后，我将分析每个选项（A, B, C, D）并说明其正确或错误的原因。\n    *   最终答案将包含在 `$$\\boxed{A}$$` 中。\n\n再次检查数学计算。\nLT: 种子c: 1(c) + 10(t_i) = 11。因为对每个t_i，来自激活邻居的权重总和是 w_{c->t_i} = 1，阈值是 theta_{t_i} = 0.4。由于 1 >= 0.4，t_i激活。种子h: 1(h) + 8(l_j) = 9。因为对每个l_j，权重总和是 w_{h->l_j} = 1，阈值是 theta_{l_j} = 0.4。由于 1 >= 0.4，l_j激活。所以对于LT, c更好。\nIC: 种子c: 期望影响 = 1(c) + sum_{i=1 to 10} P(t_i 激活)。P(t_i 激活) = p_{c->t_i} = 0.3。所以期望影响 = 1 + 10 * 0.3 = 1 + 3 = 4。种子h: 期望影响 = 1(h) + sum_{j=1 to 8} P(l_j 激活)。P(l_j 激活) = p_{h->l_j} = 0.8。所以期望影响 = 1 + 8 * 0.8 = 1 + 6.4 = 7.4。所以对于IC, h更好。\n结果是一致的。选项A中的推理也是正确的。LT：当权重超过阈值时，激活是确定性的。问题设置使得所有相关边的 $w > \\theta$。所以影响传播就变成了出邻居数量的计数。节点 $c$ 的出邻居（$10$）比 $h$（$8$）多。IC：激活是概率性的。期望传播取决于出边的激活概率之和。对于 $c$，这个和是 $10 \\times 0.3 = 3$。对于 $h$，这个和是 $8 \\times 0.8 = 6.4$。所以 $h$ 有更大的期望传播。\n逻辑是合理的。我将继续撰写解决方案。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "在掌握了扩散模型的基础后，我们转向一个核心应用：影响力最大化。本练习将通过一个具体的计算案例，揭示为何简单的“高出度”节点选择策略往往并非最优。您将亲手计算并比较朴素启发式方法与基于子模性的贪心算法所产生的预期影响，从而直观地理解“边际收益递减”这一关键概念在选择种子节点时的重要性。",
            "id": "4283432",
            "problem": "考虑以下有向图，该图旨在比较在独立级联（IC）模型下，用于影响力最大化的朴素高出度种子选择策略与标准贪心算法。节点集为 $V=\\{a,b,h,o,t_{1},t_{2},t_{3},t_{4},t_{5},t_{6}\\}$。只有节点 $\\{a,b,h,o\\}$ 具有出边（它们是候选种子集），且所有边都指向目标节点 $\\{t_{1},\\dots,t_{6}\\}$。目标节点之间没有边，也没有任何边指向 $\\{a,b,h,o\\}$ 中的任何节点。有向边及其 IC 激活概率如下：\n- 从 $a$ 到 $t_{1},t_{2},t_{3}$ 的边，每条边的激活概率为 $0.9$。\n- 从 $b$ 到 $t_{4},t_{5},t_{6}$ 的边，每条边的激活概率为 $0.9$。\n- 从 $o$ 到 $t_{1},t_{2},t_{3},t_{4}$ 的边，每条边的激活概率为 $0.2$。\n- 从 $h$ 到 $t_{1},t_{2},t_{3},t_{4},t_{5},t_{6}$ 的边，每条边的激活概率为 $0.1$。\n\n我们采用独立级联（IC）模型：初始种子节点在时间 $t=0$ 时是激活的；每个激活节点在下一时间步有一次机会独立地激活其每个当前未激活的出邻居，激活成功与否取决于对应边的激活概率；在此图中，由于第一步之后没有更多的边，因此过程随后终止。总影响力（传播范围）定义为传播过程终止时激活节点的期望数量，并将种子节点计为激活。\n\n设种子预算为 $k=2$。定义两种种子选择策略：\n- 朴素高出度种子选择：从 $\\{a,b,h,o\\}$ 中选择 $k$ 个出度最大的节点，忽略边的概率。\n- 贪心子模种子选择：一次迭代地添加一个种子，每次都从 $\\{a,b,h,o\\}$ 中选择在 IC 模型下能够最大化期望传播范围边际增益的节点。\n\n仅使用 IC 模型的定义和规则以及标准概率定律，计算此图上贪心子模种子选择策略与朴素高出度策略的总期望影响力之差。请将最终答案表示为一个精确的、未经四舍五入的小数。",
            "solution": "问题验证如下：\n### 步骤1：提取给定信息\n- 节点集：$V=\\{a,b,h,o,t_{1},t_{2},t_{3},t_{4},t_{5},t_{6}\\}$\n- 候选种子集：$S_{cand}=\\{a,b,h,o\\}$\n- 目标节点集：$T=\\{t_{1},t_{2},t_{3},t_{4},t_{5},t_{6}\\}$\n- 边结构和概率：\n  - 从 $a$ 到 $t_{1},t_{2},t_{3}$ 的边，每条边的概率为 $p=0.9$。\n  - 从 $b$ 到 $t_{4},t_{5},t_{6}$ 的边，每条边的概率为 $p=0.9$。\n  - 从 $o$ 到 $t_{1},t_{2},t_{3},t_{4}$ 的边，每条边的概率为 $p=0.2$。\n  - 从 $h$ 到 $t_{1},t_{2},t_{3},t_{4},t_{5},t_{6}$ 的边，每条边的概率为 $p=0.1$。\n- 模型：独立级联（IC）模型，单步激活。\n- 影响力（传播范围）：总激活节点（种子+新激活）的期望数量。\n- 种子预算：$k=2$。\n- 策略1（朴素）：从 $\\{a,b,h,o\\}$ 中选择出度最大的 $k=2$ 个节点。\n- 策略2（贪心）：迭代选择 $k=2$ 个种子，每次选择都使期望传播范围的边际增益最大化。\n\n### 步骤2：使用提取的给定信息进行验证\n根据验证标准对问题进行评估：\n- **科学依据：** 问题基于网络科学和信息传播领域中成熟的独立级联（IC）模型和标准算法（用于子模最大化的贪心算法）。概念是合理的。\n- **良构性：** 提供了所有必要信息（图结构、概率、预算、算法定义）。目标——计算一个特定的数值差异——是清晰明确的。存在唯一解。\n- **客观性：** 问题以精确、正式的语言陈述，不含主观或基于意见的内容。\n- **完整性与一致性：** 问题是自洽的，没有矛盾。图结构简单且被完全描述。\n- **现实性：** 这是一个为说明概念而构造的例子，这是标准的学术实践。概率和图结构在物理上并非不可能。\n\n### 步骤3：结论与行动\n问题有效。将提供完整解答。\n\n对于给定的种子集 $S$，总期望影响力（传播范围），记为 $\\sigma(S)$，是种子数量与新激活节点的期望数量之和。\n$$ \\sigma(S) = |S| + \\sum_{v \\in V \\setminus S} P(v \\text{ 被激活} | S) $$\n在这个特定的图结构中，只有 $T = \\{t_1, \\dots, t_6\\}$ 中的节点可以被新激活。目标节点 $t_i$ 被种子集 $S$ 激活的概率等于 $1$ 减去它不被 $S$ 中任何种子激活的概率。设 $N_{in}(t_i)$ 为 $t_i$ 的入邻居集合。\n$$ P(t_i \\text{ 被激活} | S) = 1 - \\prod_{s \\in S \\cap N_{in}(t_i)} (1 - p_{s,t_i}) $$\n其中 $p_{s,t_i}$ 是从 $s$ 到 $t_i$ 的边上的激活概率。总期望影响力为：\n$$ \\sigma(S) = |S| + \\sum_{i=1}^{6} \\left( 1 - \\prod_{s \\in S \\cap N_{in}(t_i)} (1 - p_{s,t_i}) \\right) $$\n\n**1. 朴素高出度种子选择策略**\n首先，我们确定候选种子节点 $\\{a,b,h,o\\}$ 的出度：\n- $a$ 的出度：$\\text{deg}^+(a) = 3$（到 $t_1, t_2, t_3$）。\n- $b$ 的出度：$\\text{deg}^+(b) = 3$（到 $t_4, t_5, t_6$）。\n- $h$ 的出度：$\\text{deg}^+(h) = 6$（到 $t_1, \\dots, t_6$）。\n- $o$ 的出度：$\\text{deg}^+(o) = 4$（到 $t_1, \\dots, t_4$）。\n\n出度最高的两个节点是 $h$（出度为 $6$）和 $o$（出度为 $4$）。因此，朴素种子集是 $S_{naive} = \\{h, o\\}$。预算为 $k=2$。\n期望影响力 $\\sigma(S_{naive})$ 的计算如下：\n$$ \\sigma(S_{naive}) = |S_{naive}| + \\sum_{i=1}^{6} P(t_i \\text{ 被激活} | \\{h,o\\}) $$\n$|S_{naive}|=2$。我们来计算每个目标节点的激活概率：\n- 对于 $t_1, t_2, t_3$：它们是 $h$（概率 $p=0.1$）和 $o$（概率 $p=0.2$）的邻居。\n  $P(\\text{被激活}) = 1 - (1 - p_{h,t_i})(1 - p_{o,t_i}) = 1 - (1 - 0.1)(1 - 0.2) = 1 - (0.9)(0.8) = 1 - 0.72 = 0.28$。\n- 对于 $t_4$：这个节点也是 $h$（$p=0.1$）和 $o$（$p=0.2$）的邻居。\n  $P(\\text{被激活}) = 1 - (0.9)(0.8) = 0.28$。\n- 对于 $t_5, t_6$：它们只是 $h$ 的邻居（概率 $p=0.1$）。\n  $P(\\text{被激活}) = p_{h,t_i} = 0.1$。\n\n将期望的新激活数相加：\n$$ \\sum_{i=1}^{6} P(t_i \\text{ 被激活}) = 3 \\times (0.28) + 1 \\times (0.28) + 2 \\times (0.1) = 4 \\times 0.28 + 0.2 = 1.12 + 0.2 = 1.32 $$\n朴素策略的总期望影响力是：\n$$ \\sigma(S_{naive}) = 2 + 1.32 = 3.32 $$\n\n**2. 贪心子模种子选择策略**\n贪心算法逐个选择种子。预算为 $k=2$，我们进行两次选择。\n\n**选择 1：** 找出具有最高期望影响力的单个种子。\n$\\sigma(\\{s\\}) = 1 + \\sum_{t_i \\in T} p_{s,t_i}$。\n- $\\sigma(\\{a\\}) = 1 + 3 \\times 0.9 = 1 + 2.7 = 3.7$。\n- $\\sigma(\\{b\\}) = 1 + 3 \\times 0.9 = 1 + 2.7 = 3.7$。\n- $\\sigma(\\{h\\}) = 1 + 6 \\times 0.1 = 1 + 0.6 = 1.6$。\n- $\\sigma(\\{o\\}) = 1 + 4 \\times 0.2 = 1 + 0.8 = 1.8$。\n最大影响力为 $3.7$，由 $a$ 和 $b$ 共同达到。我们通过选择 $a$ 来打破平局。第一个种子是 $s_1 = a$。设当前种子集为 $S_1 = \\{a\\}$。\n\n**选择 2：** 找出添加到 $S_1$ 中时提供最大边际影响力增益的节点。\n将节点 $s$ 添加到 $S_1$ 的边际增益是 $\\sigma(S_1 \\cup \\{s\\}) - \\sigma(S_1)$。我们对 $s \\in \\{b,h,o\\}$ 计算这个值。\n- **将 $b$ 添加到 $\\{a\\}$**：$S=\\{a,b\\}$。$a$ 和 $b$ 的邻居是不相交的。\n  $\\sigma(\\{a,b\\}) = 2 + \\sum P(t_i \\text{ 激活} | \\{a,b\\})$。\n  对于 $t_1,t_2,t_3$：$P(\\text{激活}) = p_{a,t_i} = 0.9$。\n  对于 $t_4,t_5,t_6$：$P(\\text{激活}) = p_{b,t_i} = 0.9$。\n  $\\sum P = 3 \\times 0.9 + 3 \\times 0.9 = 5.4$。\n  $\\sigma(\\{a,b\\}) = 2 + 5.4 = 7.4$。\n  来自 $b$ 的边际增益：$\\sigma(\\{a,b\\}) - \\sigma(\\{a\\}) = 7.4 - 3.7 = 3.7$。\n\n- **将 $h$ 添加到 $\\{a\\}$**：$S=\\{a,h\\}$。\n  $\\sigma(\\{a,h\\}) = 2 + \\sum P(t_i \\text{ 激活} | \\{a,h\\})$。\n  对于 $t_1,t_2,t_3$：是 $a$（$p=0.9$）和 $h$（$p=0.1$）的邻居。\n  $P(\\text{激活}) = 1 - (1-0.9)(1-0.1) = 1 - (0.1)(0.9) = 1 - 0.09 = 0.91$。\n  对于 $t_4,t_5,t_6$：仅是 $h$ 的邻居（$p=0.1$）。$P(\\text{激活}) = 0.1$。\n  $\\sum P = 3 \\times 0.91 + 3 \\times 0.1 = 2.73 + 0.3 = 3.03$。\n  $\\sigma(\\{a,h\\}) = 2 + 3.03 = 5.03$。\n  来自 $h$ 的边际增益：$\\sigma(\\{a,h\\}) - \\sigma(\\{a\\}) = 5.03 - 3.7 = 1.33$。\n\n- **将 $o$ 添加到 $\\{a\\}$**：$S=\\{a,o\\}$。\n  $\\sigma(\\{a,o\\}) = 2 + \\sum P(t_i \\text{ 激活} | \\{a,o\\})$。\n  对于 $t_1,t_2,t_3$：是 $a$（$p=0.9$）和 $o$（$p=0.2$）的邻居。\n  $P(\\text{激活}) = 1 - (1-0.9)(1-0.2) = 1 - (0.1)(0.8) = 1 - 0.08 = 0.92$。\n  对于 $t_4$：仅是 $o$ 的邻居（$p=0.2$）。$P(\\text{激活}) = 0.2$。\n  对于 $t_5,t_6$：没有来自 $\\{a,o\\}$ 的入边。$P(\\text{激活}) = 0$。\n  $\\sum P = 3 \\times 0.92 + 1 \\times 0.2 = 2.76 + 0.2 = 2.96$。\n  $\\sigma(\\{a,o\\}) = 2 + 2.96 = 4.96$。\n  来自 $o$ 的边际增益：$\\sigma(\\{a,o\\}) - \\sigma(\\{a\\}) = 4.96 - 3.7 = 1.26$。\n\n比较边际增益：$3.7$（来自 $b$）$> 1.33$（来自 $h$）$> 1.26$（来自 $o$）。\n贪心算法选择 $b$ 作为第二个种子。贪心种子集是 $S_{greedy} = \\{a, b\\}$。\n贪心策略的总期望影响力是 $\\sigma(S_{greedy}) = \\sigma(\\{a,b\\}) = 7.4$。\n\n**3. 期望影响力的差异**\n差异是贪心策略的期望影响力减去朴素策略的期望影响力。\n$$ \\text{差异} = \\sigma(S_{greedy}) - \\sigma(S_{naive}) = 7.4 - 3.32 = 4.08 $$\n最终答案是一个精确的小数。",
            "answer": "$$ \\boxed{4.08} $$"
        }
    ]
}