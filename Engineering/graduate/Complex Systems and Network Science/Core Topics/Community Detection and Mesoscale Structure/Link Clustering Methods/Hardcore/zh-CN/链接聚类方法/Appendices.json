{
    "hands_on_practices": [
        {
            "introduction": "掌握任何算法的第一步都是要理解其核心机制。本练习旨在将链接相似度的数学定义转化为一个高效的计算过程。通过实现一个程序，您将专注于一个关键的优化：仅为共享节点的相邻边对计算相似度，并证明这种简化为何是有效且安全的。",
            "id": "4285836",
            "problem": "给定一个简单、无向、无权图 $G = (V, E)$，图中没有自环和多重边。链接社区是一个边的子集，它在由邻接边上的相似度阈值导出的边相似度图中形成一个连通分量。任务是形式化、实现并测试以下流程和属性。\n\n本问题的基本定义：\n- 对于节点 $x \\in V$，令 $N(x)$ 表示 $x$ 在图 $G$ 中的开邻域，即与 $x$ 相邻的节点集合。定义包含性邻域 $I(x) \\equiv N(x) \\cup \\{x\\}$。\n- 对于恰好共享一个节点 $k \\in V$ 的两条边 $e = \\{u, k\\}$ 和 $f = \\{v, k\\}$，定义其非共享端点的包含性邻域的 Jaccard 相似度为\n$$\ns_J(e, f) \\equiv \\frac{|I(u) \\cap I(v)|}{|I(u) \\cup I(v)|}.\n$$\n- 对于不共享节点（即在 $G$ 中不邻接）的两条边，按照惯例定义 $s_J(e, f) \\equiv 0$。\n\n连通性和聚类构造：\n- 令 $\\theta > 0$ 为一个相似度阈值。构造边相似度图 $H_\\theta$，其节点集为 $E$，并且当且仅当 $e, f \\in E$ 在图 $G$ 中恰好共享一个节点且 $s_J(e, f) > \\theta$ 时，它们之间存在一条无向边。定义链接社区为 $H_\\theta$ 的连通分量。\n- 链接社区的连通性约束是，每个社区必须是线图意义上的连通子图（即，在共享 $G$ 中节点的邻接关系下是连通的）。\n\n你的任务：\n- 实现一个程序，该程序：\n  1. 仅对共享一个节点的边对 $\\{e, f\\}$ 计算 $s_J(e, f)$，将不邻接的边对视为相似度为 $0$，而不显式计算它们的集合重叠。\n  2. 使用严格阈值规则 $s_J(e, f) > \\theta$ 构建 $H_\\theta$。\n  3. 使用广度优先搜索（BFS）将链接社区提取为 $H_\\theta$ 的连通分量。\n  4. 为了验证，还通过为所有无序边对计算 $s_J(e, f)$ 来构建一个辅助图 $\\widehat{H}_\\theta$，并遵循与上述相同的惯例（不邻接的边对相似度为 $0$），然后在 $s_J(e, f) > \\theta$ 时连接 $e, f$（此辅助构造可以包含所有边对，但根据惯例，不邻接的边对相似度为 $0$，因此不会通过正阈值）。\n  5. 对于下面的每个测试用例，验证从 $H_\\theta$ 和 $\\widehat{H}_\\theta$ 获得的连通分量作为边的集合是相同的，从而证明对于给定的 $s_J$ 和正 $\\theta$，忽略不邻接的边对保留了链接社区的连通性约束。\n\n设计要求：\n- 在您的程序注释中提供清晰的伪代码，概述如何仅为共享节点的边对计算邻接边相似度，以及如何安全地忽略不邻接的边对。伪代码必须明确使用包含性邻域 $I(\\cdot)$ 和与 $\\theta$ 的严格阈值比较 $>$。\n- 使用从上述定义派生的集合论操作；不要假设或引用超出集合并集、交集和基数范围的专门公式。\n- 社区必须表示为边的集合并进行比较；为了规范化，一条边可以表示为有序对 $(a, b)$，其中 $a  b$。\n\n测试套件：\n对于每种情况，使用指定的图和阈值，并输出一个布尔值，指示来自 $H_\\theta$ 和 $\\widehat{H}_\\theta$ 的社区是否相同。使用以下测试用例：\n\n- 情况 1 (三角形): $V = \\{\\,1,2,3\\,\\}$, $E = \\{\\,\\{1,2\\}, \\{2,3\\}, \\{1,3\\}\\,\\}$, $\\theta = 0.5$。\n- 情况 2 (路径): $V = \\{\\,1,2,3,4\\,\\}$, $E = \\{\\,\\{1,2\\}, \\{2,3\\}, \\{3,4\\}\\,\\}$, $\\theta = 0.2$。\n- 情况 3 (相同路径): $V = \\{\\,1,2,3,4\\,\\}$, $E = \\{\\,\\{1,2\\}, \\{2,3\\}, \\{3,4\\}\\,\\}$, $\\theta = 0.3$。\n- 情况 4 (三角形加孤立边): $V = \\{\\,1,2,3,4,5\\,\\}$, $E = \\{\\,\\{1,2\\}, \\{2,3\\}, \\{1,3\\}, \\{4,5\\}\\,\\}$, $\\theta = 0.5$。\n- 情况 5 (带对角线的正方形): $V = \\{\\,1,2,3,4\\,\\}$, $E = \\{\\,\\{1,2\\}, \\{2,3\\}, \\{3,4\\}, \\{4,1\\}, \\{1,3\\}\\,\\}$, $\\theta = 0.4$。\n- 情况 6 (使用严格不等式的零阈值边界路径): $V = \\{\\,1,2,3,4\\,\\}$, $E = \\{\\,\\{1,2\\}, \\{2,3\\}, \\{3,4\\}\\,\\}$, $\\theta = 0$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序与上述测试用例相同；例如，$[r_1,r_2,\\dots,r_6]$，其中每个 $r_i$ 是一个布尔值。\n- 不应打印任何其他文本。",
            "solution": "该问题要求在一个简单、无向、无权图 $G = (V, E)$ 中，实现并验证一个与链接社区检测相关的属性。问题的核心是验证对于给定的相似度度量和一个非负阈值 $\\theta$，无论底层的边相似度图是通过仅考虑邻接边对还是所有边对来构建的，所产生的链接社区都是相同的。\n\n首先，我们必须验证问题陈述。\n\n### 第 1 步：提取已知条件\n- **图**：一个简单、无向、无权图 $G = (V, E)$，没有自环或多重边。\n- **邻域**：开邻域 $N(x) = \\{v \\in V \\mid \\{x,v\\} \\in E\\}$；包含性邻域 $I(x) = N(x) \\cup \\{x\\}$。\n- **边相似度**：对于恰好共享一个节点 $k \\in V$ 的两条边 $e = \\{u, k\\}$ 和 $f = \\{v, k\\}$，Jaccard 相似度为 $s_J(e, f) \\equiv \\frac{|I(u) \\cap I(v)|}{|I(u) \\cup I(v)|}$。\n- **不邻接边的惯例**：如果两条边不共享节点，则 $s_J(e, f) \\equiv 0$。\n- **边相似度图 $H_\\theta$**：顶点集为 $E$。当且仅当 $e, f \\in E$ 在 $G$ 中恰好共享一个节点且 $s_J(e, f) > \\theta$ 时，它们之间存在一条边。\n- **链接社区**：定义为 $H_\\theta$ 的连通分量。\n- **辅助图 $\\widehat{H}_\\theta$**：顶点集为 $E$。当且仅当 $s_J(e, f) > \\theta$ 时，任意两条不同的边 $e, f \\in E$ 之间存在一条边。对所有边对计算 $s_J$ 使用相同的定义，包括对不邻接边的惯例。\n- **验证任务**：对于每个给定的测试用例（一个图 $G$ 和一个阈值 $\\theta$），验证 $H_\\theta$ 和 $\\widehat{H}_\\theta$ 的连通分量作为边的集合是相同的。\n- **阈值条件**：使用严格不等式 $s_J > \\theta$。测试用例包括 $\\theta > 0$ 和 $\\theta=0$。\n- **测试套件**：\n    - 用例 1：$V = \\{1,2,3\\}$, $E = \\{\\{1,2\\}, \\{2,3\\}, \\{1,3\\}\\}$, $\\theta = 0.5$。\n    - 用例 2：$V = \\{1,2,3,4\\}$, $E = \\{\\{1,2\\}, \\{2,3\\}, \\{3,4\\}\\}$, $\\theta = 0.2$。\n    - 用例 3：$V = \\{1,2,3,4\\}$, $E = \\{\\{1,2\\}, \\{2,3\\}, \\{3,4\\}\\}$, $\\theta = 0.3$。\n    - 用例 4：$V = \\{1,2,3,4,5\\}$, $E = \\{\\{1,2\\}, \\{2,3\\}, \\{1,3\\}, \\{4,5\\}\\}$, $\\theta = 0.5$。\n    - 用例 5：$V = \\{1,2,3,4\\}$, $E = \\{\\{1,2\\}, \\{2,3\\}, \\{3,4\\}, \\{4,1\\}, \\{1,3\\}\\}$, $\\theta = 0.4$。\n    - 用例 6：$V = \\{1,2,3,4\\}$, $E = \\{\\{1,2\\}, \\{2,3\\}, \\{3,4\\}\\}$, $\\theta = 0$。\n\n### 第 2 步：使用提取的已知条件进行验证\n该问题具有科学依据，提法恰当且客观。链接聚类、Jaccard 相似度和连通分量的概念是网络科学中的标准概念。问题提供了所有必要的定义、数据和约束。\n\n问题的核心是验证两种不同的边相似度图构造过程是否会产生相同的连通分量。让我们分析一下构造规则：\n1.  图 $H_\\theta$ 在两条链接 $e,f$ 之间有边，当且仅当它们在 $G$ 中邻接（共享一个节点）并且 $s_J(e,f) > \\theta$。\n2.  图 $\\widehat{H}_\\theta$ 在两条链接 $e,f$ 之间有边，当且仅当 $s_J(e,f) > \\theta$。\n\n相似性度量 $s_J$ 的定义是关键：对于不邻接的边，$s_J(e, f) \\equiv 0$。问题的测试用例使用非负阈值 ($\\theta \\ge 0$)。添加边的条件是严格不等式 $s_J(e,f) > \\theta$。如果 $e$ 和 $f$ 不邻接，那么 $s_J(e,f) = 0$。该条件变为 $0 > \\theta$。由于 $\\theta \\ge 0$，这个不等式永远不成立。\n因此，在不邻接的链接对之间永远不能向 $\\widehat{H}_\\theta$ 添加边。只有当对应的链接 $e,f$ 在 $G$ 中邻接时，才能向 $\\widehat{H}_\\theta$ 添加边。这使得向 $\\widehat{H}_\\theta$ 添加边的条件与向 $H_\\theta$ 添加边的条件实际上是相同的。\n因此，对于任何 $\\theta \\ge 0$，$H_\\theta$ 和 $\\widehat{H}_\\theta$ 的边集必须相同。具有相同顶点集和相同边集的两个图也必须具有相同的连通分量。\n\n该问题要求对此逻辑推论进行计算验证，这是计算科学中一个有效且标准的练习，以确保理论定义被正确地翻译成代码。从实现的角度来看，这个问题并非微不足道，因为它需要将集合论的定义仔细地翻译成算法。\n\n### 第 3 步：结论和行动\n该问题是**有效的**。将提供完整的解决方案。\n\n### 解决方案\n解决方案涉及实现构造边相似度图 $H_\\theta$ 和 $\\widehat{H}_\\theta$ 的算法，找到它们的连通分量，并为每个测试用例比较所得的划分。\n\n**算法步骤**\n\n1.  **图表示**：对于给定的图 $G=(V, E)$，我们首先构建一个邻接表表示，它是一个将每个节点映射到其邻居集合的字典。这允许高效地查找邻域。$E$ 中的边被规范化，例如，通过将每条边 $\\{u, v\\}$ 表示为 $u  v$ 的有序元组 $(u, v)$。这些规范化的边元组将作为 $H_\\theta$ 和 $\\widehat{H}_\\theta$ 的顶点。我们创建一个从每个边元组到从 $0$ 到 $|E|-1$ 的唯一整数索引的映射，以便在数据结构中方便使用。\n\n2.  **包含性邻域的预计算**：对每个节点 $x \\in V$，计算并存储其包含性邻域 $I(x)$。这是通过取节点的开邻域 $N(x)$（来自邻接表）与包含节点本身的集合 $\\{x\\}$ 的并集来完成的。这种预计算可以防止在计算多个相似度时进行冗余计算。\n\n3.  **$H_\\theta$ 的构建**：初始化一个 $H_\\theta$ 的邻接表。我们遍历规范化边列表中的所有唯一边对 $(e_i, e_j)$。对于每一对，我们检查它们是否恰好共享一个节点。这可以通过找到构成每条边的节点集的交集来高效地完成。\n    - 如果它们共享一个节点，比如 $k$，其中 $e_i=\\{u,k\\}$ 和 $e_j=\\{v,k\\}$，我们检索预先计算好的包含性邻域 $I(u)$ 和 $I(v)$。\n    - Jaccard 相似度计算为 $s_J(e_i, e_j) = \\frac{|I(u) \\cap I(v)|}{|I(u) \\cup I(v)|}$。\n    - 如果 $s_J(e_i, e_j) > \\theta$，我们在 $H_\\theta$ 的邻接表中对应于 $e_i$ 和 $e_j$ 的整数索引之间添加一条边。\n\n4.  **$\\widehat{H}_\\theta$ 的构建**：对 $\\widehat{H}_\\theta$ 遵循类似的过程。我们再次遍历所有唯一的边对 $(e_i, e_j)$。\n    - 如果边是邻接的（共享一个节点），则按上述方法计算相似度。\n    - 如果边是不邻接的（共享零个节点），根据定义，相似度为 $s_J(e_i, e_j) = 0$。\n    - 如果 $s_J(e_i, e_j) > \\theta$，则在 $\\widehat{H}_\\theta$ 的邻接表中它们的索引之间添加一条边。如前所述，对于 $\\theta \\ge 0$，不邻接边的情况永远不会满足此条件。\n\n5.  **寻找连通分量**：使用标准的广度优先搜索（BFS）算法，根据其邻接表来寻找图的连通分量。我们为顶点（即 $G$ 的边）维护一个 `visited` 数组。我们遍历从 $0$ 到 $|E|-1$ 的每个顶点。如果一个顶点尚未被访问，我们从它开始进行 BFS，以找到其分量中的所有顶点，并将它们标记为已访问。重复此过程，直到所有顶点都被访问。结果是一个集合列表，其中每个集合包含属于一个社区的边的整数索引。\n\n6.  **比较社区划分**：为了验证这两个划分（一个来自 $H_\\theta$，一个来自 $\\widehat{H}_\\theta$）是相同的，我们必须以一种规范的方式对它们进行比较。\n    - 首先，将作为整数索引集的连通分量转换回规范化的边元组集。\n    - 对于每个划分，我们创建一个规范表示。每个分量（一个边元组的集合）被转换为一个排序后的边元组的元组。然后对这些分量元组的列表进行排序。\n    - 当且仅当它们的排序后规范表示相等时，这两个划分是相同的。这个结果（一个布尔值）被记录用于该测试用例。\n\n对问题陈述中提供的所有测试用例重复此过程。最终输出是一个布尔值列表。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and verifies the link clustering procedure as specified.\n    \"\"\"\n    \n    # Test cases as defined in the problem statement.\n    # Each case is a tuple: (set of vertices, set of edges, threshold theta)\n    test_cases = [\n        # Case 1: triangle\n        ({1, 2, 3}, {frozenset({1, 2}), frozenset({2, 3}), frozenset({1, 3})}, 0.5),\n        # Case 2: path\n        ({1, 2, 3, 4}, {frozenset({1, 2}), frozenset({2, 3}), frozenset({3, 4})}, 0.2),\n        # Case 3: same path\n        ({1, 2, 3, 4}, {frozenset({1, 2}), frozenset({2, 3}), frozenset({3, 4})}, 0.3),\n        # Case 4: triangle plus isolated edge\n        ({1, 2, 3, 4, 5}, {frozenset({1, 2}), frozenset({2, 3}), frozenset({1, 3}), frozenset({4, 5})}, 0.5),\n        # Case 5: square with a diagonal\n        ({1, 2, 3, 4}, {frozenset({1, 2}), frozenset({2, 3}), frozenset({3, 4}), frozenset({4, 1}), frozenset({1, 3})}, 0.4),\n        # Case 6: path with zero threshold\n        ({1, 2, 3, 4}, {frozenset({1, 2}), frozenset({2, 3}), frozenset({3, 4})}, 0.0),\n    ]\n\n    results = []\n\n    for V, E, theta in test_cases:\n        # Canonicalize edges to sorted tuples for consistent ordering\n        edges = sorted([tuple(sorted(list(e))) for e in E])\n        edge_to_idx = {edge: i for i, edge in enumerate(edges)}\n        num_edges = len(edges)\n\n        # Build adjacency list for the original graph G\n        adj_G = {node: set() for node in V}\n        for u, v in edges:\n            adj_G[u].add(v)\n            adj_G[v].add(u)\n\n        # Pre-compute inclusive neighborhoods I(x) for all x in V\n        I_neighborhoods = {node: adj_G[node] | {node} for node in V}\n\n        # --- Build H_theta (considering only adjacent edges) ---\n        # Pseudocode for building H_theta:\n        # 1. Initialize an adjacency list H_theta_adj for all edges in E.\n        # 2. For each distinct pair of edges (e1, e2) from E:\n        # 3.   Check if e1 and e2 share exactly one node, k.\n        # 4.   If they do, let u and v be the non-shared nodes.\n        # 5.   Compute similarity s_J = |I(u) intersect I(v)| / |I(u) union I(v)|.\n        # 6.   If s_J > theta, add an edge between e1 and e2 in H_theta_adj.\n        H_theta_adj = {i: [] for i in range(num_edges)}\n        for i in range(num_edges):\n            for j in range(i + 1, num_edges):\n                e1 = edges[i]\n                e2 = edges[j]\n                \n                shared_nodes = set(e1)  set(e2)\n                if len(shared_nodes) == 1:\n                    k = shared_nodes.pop()\n                    u = (set(e1) - {k}).pop()\n                    v = (set(e2) - {k}).pop()\n\n                    Iu = I_neighborhoods[u]\n                    Iv = I_neighborhoods[v]\n                    \n                    intersection_size = len(Iu  Iv)\n                    union_size = len(Iu | Iv)\n\n                    similarity = intersection_size / union_size if union_size > 0 else 0\n                    \n                    if similarity > theta:\n                        H_theta_adj[i].append(j)\n                        H_theta_adj[j].append(i)\n\n        # --- Build H_hat_theta (considering all pairs of edges) ---\n        # Pseudocode for building H_hat_theta:\n        # 1. Initialize an adjacency list H_hat_theta_adj for all edges in E.\n        # 2. For each distinct pair of edges (e1, e2) from E:\n        # 3.   If e1 and e2 are adjacent (share one node k):\n        # 4.     Compute s_J as |I(u) intersect I(v)| / |I(u) union I(v)|.\n        # 5.   Else (non-adjacent edges):\n        # 6.     Set s_J = 0.\n        # 7.   If s_J > theta, add an edge between e1 and e2 in H_hat_theta_adj.\n        H_hat_theta_adj = {i: [] for i in range(num_edges)}\n        for i in range(num_edges):\n            for j in range(i + 1, num_edges):\n                e1 = edges[i]\n                e2 = edges[j]\n                \n                shared_nodes = set(e1)  set(e2)\n                similarity = 0.0\n                if len(shared_nodes) == 1:\n                    k = shared_nodes.pop()\n                    u = (set(e1) - {k}).pop()\n                    v = (set(e2) - {k}).pop()\n\n                    Iu = I_neighborhoods[u]\n                    Iv = I_neighborhoods[v]\n                    \n                    intersection_size = len(Iu  Iv)\n                    union_size = len(Iu | Iv)\n\n                    similarity = intersection_size / union_size if union_size > 0 else 0\n                \n                # For non-adjacent edges, similarity remains 0\n                \n                if similarity > theta:\n                    H_hat_theta_adj[i].append(j)\n                    H_hat_theta_adj[j].append(i)\n\n        # --- Find and compare communities ---\n        def find_components(adj, n_nodes):\n            visited = [False] * n_nodes\n            components = []\n            for i in range(n_nodes):\n                if not visited[i]:\n                    component = set()\n                    queue = [i]\n                    visited[i] = True\n                    head = 0\n                    while head  len(queue):\n                        u = queue[head]\n                        head += 1\n                        component.add(u)\n                        for v in adj[u]:\n                            if not visited[v]:\n                                visited[v] = True\n                                queue.append(v)\n                    components.append(component)\n            return components\n\n        components_H = find_components(H_theta_adj, num_edges)\n        components_H_hat = find_components(H_hat_theta_adj, num_edges)\n\n        def get_canonical_communities(components_indices, edge_list):\n            # Convert indices to edge tuples\n            communities_edges = [\n                frozenset(edge_list[i] for i in component) for component in components_indices\n            ]\n            # Sort individual communities and then the list of communities for a canonical form\n            return sorted(list(c) for c in communities_edges)\n        \n        canonical_H = get_canonical_communities(components_H, edges)\n        canonical_H_hat = get_canonical_communities(components_H_hat, edges)\n        \n        results.append(canonical_H == canonical_H_hat)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, [r.lower() for r in results]))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在掌握了基本算法逻辑之后，通过一个完整的实例来观察其运作至关重要。本练习提供了一个在小型网络上手动应用链接聚类的完整演练。您将亲手计算相似度，执行层次聚类，并使用划分密度指标 $D$ 来寻找最优的社区结构，从而将该方法的所有关键概念联系起来。",
            "id": "4285854",
            "problem": "考虑一个无向简单图，其节点集为 $\\{1,2,3,4,5,6\\}$，边集标记如下：$e_{1}=(1,2)$、$e_{2}=(2,3)$、$e_{3}=(1,3)$、$e_{4}=(3,4)$、$e_{5}=(4,5)$、$e_{6}=(5,6)$、$e_{7}=(4,6)$。您将使用单链接方法对边（链接聚类）执行层次凝聚聚类（Hierarchical Agglomerative Clustering, HAC），其中边与边之间的相似度仅对共享一个节点的边对定义，具体如下。对于共享节点 $v$ 的两条边，例如 $e_{i}=(x,v)$ 和 $e_{j}=(y,v)$，将节点 $u$ 的包含性邻域定义为 $n_{\\mathrm{incl}}(u) = \\{u\\} \\cup \\{w \\mid (u,w) \\text{ is an edge}\\}$，Jaccard 相似度定义为 $s(e_{i},e_{j}) = \\frac{|n_{\\mathrm{incl}}(x) \\cap n_{\\mathrm{incl}}(y)|}{|n_{\\mathrm{incl}}(x) \\cup n_{\\mathrm{incl}}(y)|}$。使用不相似度 $d(e_{i},e_{j}) = 1 - s(e_{i},e_{j})$ 和单链接方法构建树状图，其中在阈值 $t$ 处的切割将产生社群，这些社群是“边的图”中的连通分量，在该图中，成对不相似度至多为 $t$。\n\n对于由切割产生的任何边社群 $c$，用 $m_{c}$ 表示 $c$ 中的边数，用 $n_{c}$ 表示与这些边关联的不同节点数。一个社群的划分密度为 $D_{c} = \\frac{2\\left(m_{c} - (n_{c}-1)\\right)}{(n_{c}-1)(n_{c}-2)}$（当 $n_{c} \\geq 3$ 时），而按照惯例，当 $n_{c} \\leq 2$ 时 $D_{c}=0$。在某次切割处的全局划分密度为 $D = \\sum_{c} \\frac{m_{c}}{M} D_{c}$，其中 $M$ 是图中的总边数。\n\n任务：\n- 计算所有共享一个节点的边对的 $s(e_{i},e_{j})$，并列出出现的所有不同不相似度 $d$。\n- 确定在与不同 $d$ 值对应的每个可能的树状图切割处获得的社群。\n- 使用上述定义和完整的算术计算，计算每个可能切割处的 $D$。\n- 选择使 $D$ 最大化的切割。如果有多个切割达到相同的最大 $D$ 值，则在这些切割中选择最小的不相似度阈值 $t$。将此最优阈值 $t^{\\ast}$ 作为您的最终答案报告。无需四舍五入；请提供精确值。",
            "solution": "为了解决这个问题，我们系统地遵循所概述的步骤。\n\n**第 1 步：计算邻域和不相似度**\n\n首先，我们确定图中每个节点的包含性邻域 $n_{\\mathrm{incl}}(u)$：\n- $n_{\\mathrm{incl}}(1) = \\{1, 2, 3\\}$\n- $n_{\\mathrm{incl}}(2) = \\{1, 2, 3\\}$\n- $n_{\\mathrm{incl}}(3) = \\{1, 2, 3, 4\\}$\n- $n_{\\mathrm{incl}}(4) = \\{3, 4, 5, 6\\}$\n- $n_{\\mathrm{incl}}(5) = \\{4, 5, 6\\}$\n- $n_{\\mathrm{incl}}(6) = \\{4, 5, 6\\}$\n\n接下来，我们计算所有共享一个节点的边对的 Jaccard 相似度 $s(e_i, e_j)$，然后计算不相似度 $d = 1-s$。\n\n- **共享节点 1**: $e_1=(1,2), e_3=(1,3)$。$s(e_1, e_3) = \\frac{|n_{\\mathrm{incl}}(2) \\cap n_{\\mathrm{incl}}(3)|}{|n_{\\mathrm{incl}}(2) \\cup n_{\\mathrm{incl}}(3)|} = \\frac{|\\{1,2,3\\} \\cap \\{1,2,3,4\\}|}{|\\{1,2,3\\} \\cup \\{1,2,3,4\\}|} = \\frac{3}{4}$。$d=1/4$。\n- **共享节点 2**: $e_1=(1,2), e_2=(2,3)$。$s(e_1, e_2) = \\frac{|n_{\\mathrm{incl}}(1) \\cap n_{\\mathrm{incl}}(3)|}{|n_{\\mathrm{incl}}(1) \\cup n_{\\mathrm{incl}}(3)|} = \\frac{3}{4}$。$d=1/4$。\n- **共享节点 3**:\n  - $e_2=(2,3), e_3=(1,3)$。$s(e_2, e_3) = \\frac{|n_{\\mathrm{incl}}(1) \\cap n_{\\mathrm{incl}}(2)|}{|n_{\\mathrm{incl}}(1) \\cup n_{\\mathrm{incl}}(2)|} = \\frac{3}{3} = 1$。$d=0$。\n  - $e_2=(2,3), e_4=(3,4)$。$s(e_2, e_4) = \\frac{|n_{\\mathrm{incl}}(2) \\cap n_{\\mathrm{incl}}(4)|}{|n_{\\mathrm{incl}}(2) \\cup n_{\\mathrm{incl}}(4)|} = \\frac{|\\{1,2,3\\} \\cap \\{3,4,5,6\\}|}{|\\{1,2,3\\} \\cup \\{3,4,5,6\\}|} = \\frac{1}{6}$。$d=5/6$。\n  - $e_3=(1,3), e_4=(3,4)$。$s(e_3, e_4) = \\frac{|n_{\\mathrm{incl}}(1) \\cap n_{\\mathrm{incl}}(4)|}{|n_{\\mathrm{incl}}(1) \\cup n_{\\mathrm{incl}}(4)|} = \\frac{1}{6}$。$d=5/6$。\n- **共享节点 4**:\n  - $e_4=(3,4), e_5=(4,5)$。$s(e_4, e_5) = \\frac{|n_{\\mathrm{incl}}(3) \\cap n_{\\mathrm{incl}}(5)|}{|n_{\\mathrm{incl}}(3) \\cup n_{\\mathrm{incl}}(5)|} = \\frac{1}{6}$。$d=5/6$。\n  - $e_4=(3,4), e_7=(4,6)$。$s(e_4, e_7) = \\frac{|n_{\\mathrm{incl}}(3) \\cap n_{\\mathrm{incl}}(6)|}{|n_{\\mathrm{incl}}(3) \\cup n_{\\mathrm{incl}}(6)|} = \\frac{1}{6}$。$d=5/6$。\n  - $e_5=(4,5), e_7=(4,6)$。$s(e_5, e_7) = \\frac{|n_{\\mathrm{incl}}(5) \\cap n_{\\mathrm{incl}}(6)|}{|n_{\\mathrm{incl}}(5) \\cup n_{\\mathrm{incl}}(6)|} = \\frac{3}{3} = 1$。$d=0$。\n- **共享节点 5**: $e_5=(4,5), e_6=(5,6)$。$s(e_5, e_6) = \\frac{|n_{\\mathrm{incl}}(4) \\cap n_{\\mathrm{incl}}(6)|}{|n_{\\mathrm{incl}}(4) \\cup n_{\\mathrm{incl}}(6)|} = \\frac{3}{4}$。$d=1/4$。\n- **共享节点 6**: $e_6=(5,6), e_7=(4,6)$。$s(e_6, e_7) = \\frac{|n_{\\mathrm{incl}}(4) \\cap n_{\\mathrm{incl}}(5)|}{|n_{\\mathrm{incl}}(4) \\cup n_{\\mathrm{incl}}(5)|} = \\frac{3}{4}$。$d=1/4$。\n\n出现的所有不同不相似度值为 $d \\in \\{0, 1/4, 5/6\\}$。\n\n**第 2 步：确定切割和社群**\n\n我们将根据不相似度阈值 $t$ 确定划分。\n- **切割在 $t=0$**: 我们连接所有不相似度为 $0$ 的边对。即 $(e_2, e_3)$ 和 $(e_5, e_7)$。\n  - 社群: $\\{e_2, e_3\\}, \\{e_5, e_7\\}, \\{e_1\\}, \\{e_4\\}, \\{e_6\\}$。这是一个包含 5 个社群的划分。\n- **切割在 $t=1/4$**: 我们还包括不相似度为 $1/4$ 的连接。这些是 $(e_1, e_2), (e_1, e_3), (e_5, e_6), (e_6, e_7)$。\n  - $\\{e_1, e_2, e_3\\}$ 现在成为一个连通分量。\n  - $\\{e_5, e_6, e_7\\}$ 现在成为一个连通分量。\n  - $e_4$ 仍然孤立。\n  - 社群: $\\{e_1, e_2, e_3\\}, \\{e_5, e_6, e_7\\}, \\{e_4\\}$。这是一个包含 3 个社群的划分。\n- **切割在 $t=5/6$**: 我们包括所有不相似度 $\\le 5/6$ 的连接。$e_4$ 现在通过 $e_2, e_3, e_5, e_7$ 连接到其他两个簇。\n  - 社群: $\\{e_1, e_2, e_3, e_4, e_5, e_6, e_7\\}$。所有边合并成一个单一的社群。\n\n**第 3 步：计算每个切割的划分密度 $D$**\n\n总边数 $M=7$。\n\n- **对于切割在 $t=0$**:\n  - 社群 $c_1=\\{e_2, e_3\\}$: $m_{c_1}=2$, 节点为 $\\{1,2,3\\}$, 所以 $n_{c_1}=3$。$D_{c_1} = \\frac{2(2-(3-1))}{(3-1)(3-2)} = 0$。\n  - 社群 $c_2=\\{e_5, e_7\\}$: $m_{c_2}=2$, 节点为 $\\{4,5,6\\}$, 所以 $n_{c_2}=3$。$D_{c_2} = \\frac{2(2-(3-1))}{(3-1)(3-2)} = 0$。\n  - 其他社群有 $m_c=1, n_c=2$，所以它们的 $D_c=0$。\n  - 全局 $D = \\sum \\frac{m_c}{M} D_c = 0$。\n\n- **对于切割在 $t=1/4$**:\n  - 社群 $c_1'=\\{e_1, e_2, e_3\\}$ (一个三角形): $m_{c_1'}=3$, 节点为 $\\{1,2,3\\}$, $n_{c_1'}=3$。$D_{c_1'} = \\frac{2(3-(3-1))}{(3-1)(3-2)} = \\frac{2(1)}{2} = 1$。\n  - 社群 $c_2'=\\{e_5, e_6, e_7\\}$ (另一个三角形): $m_{c_2'}=3$, 节点为 $\\{4,5,6\\}$, $n_{c_2'}=3$。$D_{c_2'} = 1$。\n  - 社群 $c_3'=\\{e_4\\}$: $m_{c_3'}=1$, 节点为 $\\{3,4\\}$, $n_{c_3'}=2$。$D_{c_3'}=0$。\n  - 全局 $D = \\frac{3}{7}(1) + \\frac{3}{7}(1) + \\frac{1}{7}(0) = \\frac{6}{7}$。\n\n- **对于切割在 $t=5/6$**:\n  - 社群 $c_1''=\\{\\text{all 7 edges}\\}$: $m_{c_1''}=7$, 节点为 $\\{1,2,3,4,5,6\\}$, $n_{c_1''}=6$。\n  - $D_{c_1''} = \\frac{2(7-(6-1))}{(6-1)(6-2)} = \\frac{2(2)}{5 \\cdot 4} = \\frac{4}{20} = \\frac{1}{5}$。\n  - 全局 $D = \\frac{7}{7} \\cdot D_{c_1''} = \\frac{1}{5}$。\n\n**第 4 步：选择最优切割**\n\n比较全局划分密度值:\n- $D(t=0) = 0$\n- $D(t=1/4) = 6/7 \\approx 0.857$\n- $D(t=5/6) = 1/5 = 0.2$\n\n最大值 $D = 6/7$ 是在 $t=1/4$ 的切割处获得的。根据问题，我们选择产生这个最大值的最小阈值。在这种情况下，最大值是唯一的，对应的阈值是 $t^* = 1/4$。",
            "answer": "$$\n\\boxed{\\frac{1}{4}}\n$$"
        },
        {
            "introduction": "本练习将引导您从具体案例走向一般性原理，这是一项更高级的实践。通过分析一个理想化的“团环”网络模型，您将推导出该方法区分社群的能力如何关键地取决于网络结构和相似度阈值 $\\tau$。这项练习旨在培养您预测聚类结果的分析能力。",
            "id": "4285820",
            "problem": "考虑一个如下构建的环状团网络。设有 $M$ 个团循环排列，其中每个团 $C_{i}$ 有 $n$ 个节点，且 $n \\geq 3$。对于每对相邻的团 $(C_{i}, C_{i+1})$，选择 $s$ 个边界节点 $S_{A} \\subset C_{i}$ 和 $s$ 个边界节点 $S_{B} \\subset C_{i+1}$，其中 $2 \\leq s \\leq n$。通过一个完全二分字图 $K_{s,s}$ 连接 $S_{A}$ 和 $S_{B}$，从而连接这两个团，使得每对相邻团之间的团间边数为 $r = s^{2}$。所有图都是无向简单图。\n\n我们应用 Ahn、Bagrow 和 Lehmann 的链接聚类方法，该方法对边而非节点进行聚类。对于共享端点 $u$ 的两条相邻边 $e_{1} = (u,v)$ 和 $e_{2} = (u,w)$，定义节点 $x$ 的包含性邻居集合为 $\\mathrm{IN}(x) = \\{x\\} \\cup N(x)$，其中 $N(x)$ 是 $x$ 的邻居集合。定义局部链接-链接相似度 $S(e_{1}, e_{2})$ 为非共享端点的包含性邻居集合的杰卡德相似度：\n$$\nS(e_{1}, e_{2}) = \\frac{|\\mathrm{IN}(v) \\cap \\mathrm{IN}(w)|}{|\\mathrm{IN}(v) \\cup \\mathrm{IN}(w)|}.\n$$\n在边集合上进行单链接层次聚类时，一个阈值 $\\tau \\in [0,1]$ 会产生链接社区。这些社区是一个图的连通分量，该图中的顶点是原始网络的边，如果两条边共享一个节点且它们的相似度 $S \\geq \\tau$，则它们之间存在无向邻接关系。\n\n关注任意一对相邻的团 $(C_{i}, C_{i+1})$，解析地确定临界阈值 $\\tau_{c}(n,r)$。当阈值高于此值时，边社区将不会跨越 $C_{i}$ 和 $C_{i+1}$ 之间的团间桥梁传播，也就是说，在链接相似度图中，与 $C_{i}$ 中边界节点关联的团内边将与连接到 $C_{i+1}$ 的团间边在该边界处断开连接。请用 $n$ 和 $r$ 表示您的最终答案，形式为一个单一的闭式表达式。无需四舍五入，也无需报告单位。",
            "solution": "用户希望找到在环状团网络中链接社区分离的临界阈值 $\\tau_{c}(n,r)$。首先对问题进行验证，以确保其具有科学依据、问题设定良好且客观。\n\n### 步骤1：问题验证\n\n已知条件逐字从问题陈述中提取：\n- 一个由 $M$ 个团 $C_i$ 循环排列构成的网络。\n- 每个团 $C_i$ 有 $n$ 个节点，且 $n \\geq 3$。\n- 对于一对相邻的团 $(C_i, C_{i+1})$，存在边界节点集 $S_A \\subset C_i$ 和 $S_B \\subset C_{i+1}$，每个集合的大小为 $s$，其中 $2 \\leq s \\leq n$。\n- $S_A$ 和 $S_B$ 通过一个完全二分字图 $K_{s,s}$ 连接。\n- 团间边的数量为 $r = s^2$。\n- 图是无向简单图。\n- 对于两条相邻边 $e_1 = (u,v)$ 和 $e_2 = (u,w)$，链接相似度定义为 $S(e_{1}, e_{2}) = \\frac{|\\mathrm{IN}(v) \\cap \\mathrm{IN}(w)|}{|\\mathrm{IN}(v) \\cup \\mathrm{IN}(w)|}$。\n- 包含性邻居集合为 $\\mathrm{IN}(x) = \\{x\\} \\cup N(x)$，其中 $N(x)$ 是 $x$ 的邻居集合。\n- 链接社区是通过在边上进行单链接层次聚类形成的，基于相似度 $S$ 和一个阈值 $\\tau$。\n- 目标是找到临界阈值 $\\tau_c(n,r)$，在该阈值下，与 $C_i$ 中一个边界节点关联的团内边与关联到同一节点的团间边断开连接。\n\n该问题在网络科学领域，特别是在链接聚类方面，具有科学依据。定义是标准的或已明确给出。其结构是一个关于图模型的数学问题，问题设定良好。语言客观而精确。推导阈值所需的所有信息均已提供。不存在妨碍形式化解的矛盾或模糊之处。约束条件 $r=s^2$ 且 $s$ 为整数，意味着 $r$ 必须是一个完全平方数，这是对参数的有效约束。该问题被认定为有效。\n\n### 步骤2：临界阈值的推导\n\n临界阈值 $\\tau_c$ 是这样一个值：当阈值达到该值时，由边界节点上的团内边和团间边形成的链接社区不再连接。我们使用单链接聚类，其中组件根据其任意元素对之间的最高相似度进行合并。因此，当阈值 $\\tau$ 刚刚超过一个共享公共节点的团内边集中的边和一个团间边集中的边之间的最大可能相似度时，这两个社区将分离。临界阈值 $\\tau_c$ 就是这个最大相似度值。\n\n为简化符号，我们关注一对任意相邻的团，标记为 $C_1$ 和 $C_2$。设 $S_A \\subset C_1$ 为 $C_1$ 中 $s$ 个边界节点的集合，设 $S_B \\subset C_2$ 为 $C_2$ 中 $s$ 个边界节点的集合。\n\n考虑一个边界节点 $u \\in S_A$。我们关心与 $u$ 关联的两类边之间的相似度：\n1.  一条团内边 $e_{intra} = (u,v)$，其中 $v \\in C_1$ 且 $v \\neq u$。\n2.  一条团间边 $e_{inter} = (u,w)$，其中 $w \\in S_B$。\n\n相似度为 $S(e_{intra}, e_{inter}) = \\frac{|\\mathrm{IN}(v) \\cap \\mathrm{IN}(w)|}{|\\mathrm{IN}(v) \\cup \\mathrm{IN}(w)|}$。为了找到最大相似度，我们必须分析包含性邻居集合 $\\mathrm{IN}(v)$ 和 $\\mathrm{IN}(w)$ 的结构。$\\mathrm{IN}(v)$ 的结构取决于 $v$ 本身是边界节点还是 $C_1$ 的内部节点。\n\n首先，我们来刻画节点 $w \\in S_B$ 的包含性邻居集合。一个节点 $w \\in S_B \\subset C_2$ 与其所在团 $C_2$ 中的所有其他 $n-1$ 个节点相连，并与另一个团的边界集 $S_A$ 中的所有 $s$ 个节点相连。\n$N(w) = (C_2 \\setminus \\{w\\}) \\cup S_A$。因此，其包含性邻居集合为 $\\mathrm{IN}(w) = \\{w\\} \\cup N(w) = C_2 \\cup S_A$。其大小为 $|\\mathrm{IN}(w)| = |C_2|+|S_A| = n+s$，因为 $C_2$ 和 $S_A$ 是不相交的节点集合。\n\n现在，我们考虑节点 $v \\in C_1 \\setminus \\{u\\}$ 的两种情况。\n\n**情况1：$v$ 是 $C_1$ 的一个内部节点 ($v \\in C_1 \\setminus S_A$)。**\n一个内部节点 $v$ 仅与其所在团 $C_1$ 内的其他 $n-1$ 个节点相连。\n$N(v) = C_1 \\setminus \\{v\\}$。其包含性邻居集合为 $\\mathrm{IN}(v) = \\{v\\} \\cup N(v) = C_1$。其大小为 $|\\mathrm{IN}(v)| = n$。\n包含性邻居集合的交集为：\n$$ |\\mathrm{IN}(v) \\cap \\mathrm{IN}(w)| = |C_1 \\cap (C_2 \\cup S_A)| = |(C_1 \\cap C_2) \\cup (C_1 \\cap S_A)| $$\n由于 $C_1$ 和 $C_2$ 不相交，$C_1 \\cap C_2 = \\emptyset$。由于 $S_A \\subset C_1$，$C_1 \\cap S_A = S_A$。\n因此，$|\\mathrm{IN}(v) \\cap \\mathrm{IN}(w)| = |S_A| = s$。\n包含性邻居集合的并集为：\n$$ |\\mathrm{IN}(v) \\cup \\mathrm{IN}(w)| = |\\mathrm{IN}(v)| + |\\mathrm{IN}(w)| - |\\mathrm{IN}(v) \\cap \\mathrm{IN}(w)| = n + (n+s) - s = 2n $$\n在这种情况下，我们记为 $S_1$ 的相似度是：\n$$ S_1 = \\frac{s}{2n} $$\n\n**情况2：$v$ 是 $C_1$ 的一个边界节点 ($v \\in S_A \\setminus \\{u\\}$)。**\n一个边界节点 $v$ 与 $C_1$ 中的所有其他 $n-1$ 个节点以及 $S_B$ 中的所有 $s$ 个节点相连。\n$N(v) = (C_1 \\setminus \\{v\\}) \\cup S_B$。其包含性邻居集合为 $\\mathrm{IN}(v) = \\{v\\} \\cup N(v) = C_1 \\cup S_B$。其大小为 $|\\mathrm{IN}(v)|=|C_1|+|S_B| = n+s$。\n包含性邻居集合的交集为：\n$$ |\\mathrm{IN}(v) \\cap \\mathrm{IN}(w)| = |(C_1 \\cup S_B) \\cap (C_2 \\cup S_A)| = |(C_1 \\cap C_2) \\cup (C_1 \\cap S_A) \\cup (S_B \\cap C_2) \\cup (S_B \\cap S_A)| $$\n使用 $S_A \\subset C_1$，$S_B \\subset C_2$，以及 $C_1 \\cap C_2 = \\emptyset$，上式简化为：\n$$ |\\emptyset \\cup S_A \\cup S_B \\cup \\emptyset| = |S_A \\cup S_B| = |S_A| + |S_B| = s + s = 2s $$\n包含性邻居集合的并集为：\n$$ |\\mathrm{IN}(v) \\cup \\mathrm{IN}(w)| = |\\mathrm{IN}(v)| + |\\mathrm{IN}(w)| - |\\mathrm{IN}(v) \\cap \\mathrm{IN}(w)| = (n+s) + (n+s) - 2s = 2n $$\n在这种情况下，我们记为 $S_2$ 的相似度是：\n$$ S_2 = \\frac{2s}{2n} = \\frac{s}{n} $$\n\n临界阈值 $\\tau_c$ 是在边界节点 $u$ 处连接团内和团间边社区的最大相似度。\n$$ \\tau_c = \\max(S_1, S_2) = \\max\\left(\\frac{s}{2n}, \\frac{s}{n}\\right) $$\n由于 $n > 0$，我们有 $\\frac{s}{n} > \\frac{s}{2n}$。因此，最大相似度是 $S_2$。\n$$ \\tau_c = \\frac{s}{n} $$\n\n最后，我们用 $n$ 和 $r$ 来表示结果。问题陈述中指出 $r = s^2$。由于 $s$ 是节点计数，它是非负的，所以我们可以写成 $s = \\sqrt{r}$。\n将此代入 $\\tau_c$ 的表达式中：\n$$ \\tau_c(n,r) = \\frac{\\sqrt{r}}{n} $$\n此表达式代表临界阈值。对于任何大于 $\\tau_c(n,r)$ 的聚类阈值 $\\tau$，与一个边界节点关联的团内边和团间边将属于不同的链接社区。",
            "answer": "$$\\boxed{\\frac{\\sqrt{r}}{n}}$$"
        }
    ]
}