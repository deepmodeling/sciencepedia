{
    "hands_on_practices": [
        {
            "introduction": "This first practice provides a foundational, analytical exploration of the resolution limit. We will use the canonical \"ring of cliques\" network model, a structure that possesses an unambiguous ground-truth community structure. By calculating the modularity for both the ground-truth partition and a coarser partition where adjacent cliques are merged, you will derive the precise mathematical condition under which modularity optimization favors the incorrect, merged structure . This exercise reveals how the global nature of the modularity null model can cause it to fail in resolving small, dense communities within a large network.",
            "id": "4311135",
            "problem": "Consider an undirected, unweighted ring network constructed as follows: take $r$ cliques, each of size $s$, and connect consecutive cliques by a single edge to form a cycle. Assume $r \\geq 4$ is even and $s \\geq 3$. Let $m$ denote the total number of edges in the network. Using the standard definition of modularity for undirected, unweighted networks,\n$$\nQ \\;=\\; \\sum_{C} \\left( e_{C} \\;-\\; a_{C}^{2} \\right),\n$$\nwhere $e_{C}$ is the fraction of edges with both ends inside community $C$ and $a_{C}$ is the fraction of edge ends attached to nodes in community $C$, perform the following:\n\n1. Compute $m$.\n2. Compute the modularity $Q_{r}$ for the partition into $r$ communities, where each clique forms its own community.\n3. Compute the modularity $Q_{r/2}$ for the partition into $r/2$ communities obtained by merging adjacent cliques pairwise (so each community consists of two adjacent cliques and the edge between them).\n4. Report the closed-form analytic expression for\n$$\n\\Delta Q(r,s) \\;=\\; Q_{r/2} \\;-\\; Q_{r}.\n$$\n\nNo numerical approximation or rounding is required. Your final answer must be a single closed-form expression in terms of $r$ and $s$.",
            "solution": "The user wants me to analyze the modularity of a specific network structure under two different community partitions.\n\n### Step 1: Extract Givens\n- **Network Structure**: An undirected, unweighted ring network formed by $r$ cliques.\n- **Clique Size**: Each clique has size $s$.\n- **Connections**: Consecutive cliques are connected by a single edge to form a cycle.\n- **Parameters**:\n    - $r$: Number of cliques, $r \\geq 4$ and is even.\n    - $s$: Size of each clique, $s \\geq 3$.\n- **Modularity Definition**: $Q = \\sum_{C} ( e_{C} - a_{C}^{2} )$, where $e_{C}$ is the fraction of edges with both ends in community $C$, and $a_{C}$ is the fraction of edge ends attached to nodes in community $C$.\n- **Tasks**:\n    1. Compute $m$, the total number of edges.\n    2. Compute $Q_{r}$, the modularity for the partition into $r$ communities (each clique is a community).\n    3. Compute $Q_{r/2}$, the modularity for the partition into $r/2$ communities (adjacent cliques are merged pairwise).\n    4. Compute $\\Delta Q(r,s) = Q_{r/2} - Q_{r}$.\n\n### Step 2: Validate Using Extracted Givens\n- **Scientifically Grounded**: The problem is based on the standard definition of modularity and a well-defined network topology (ring of cliques), which are fundamental concepts in network science. The problem context, the resolution limit of modularity, is a well-established topic. The problem is scientifically sound.\n- **Well-Posed**: The network structure and the community partitions are described precisely. The quantities to be computed are clearly defined. The constraints on $r$ and $s$ ensure the structure is non-trivial. A unique and meaningful solution exists.\n- **Objective**: The problem is stated using precise mathematical and network science terminology, free from any subjective or biased language.\n\n### Step 3: Verdict and Action\nThe problem is valid. It is a standard exercise in network modularity calculation. I will proceed with the solution.\n\n### Part 1: Compute the total number of edges, $m$\nThe network consists of two types of edges: edges within cliques and edges connecting cliques.\nThe number of edges in a single complete graph (clique) of size $s$ is given by $\\binom{s}{2} = \\frac{s(s-1)}{2}$.\nSince there are $r$ such cliques, the total number of edges within all cliques is $r \\times \\frac{s(s-1)}{2}$.\nThe $r$ cliques are arranged in a ring, with each clique connected to its two neighbors by a single edge. This forms a cycle of cliques, resulting in $r$ connecting edges.\nThe total number of edges, $m$, is the sum of these two quantities:\n$$\nm = r \\frac{s(s-1)}{2} + r = r \\left( \\frac{s^2-s}{2} + 1 \\right) = \\frac{r}{2}(s^2 - s + 2)\n$$\n\n### Part 2: Compute the modularity $Q_r$\nIn this partition, there are $r$ communities, with each community $C_i$ (for $i=1, \\dots, r$) being one of the cliques of size $s$. Due to the symmetry of the network, the values of $e_{C_i}$ and $a_{C_i}$ will be the same for all communities. We can compute them for an arbitrary community $C$ and then sum up.\nThe modularity is $Q_r = \\sum_{i=1}^{r} (e_{C_i} - a_{C_i}^2) = r(e_C - a_C^2)$.\n\n$e_C$ is the fraction of edges that are internal to community $C$. The number of internal edges is the number of edges in a clique of size $s$, which is $\\frac{s(s-1)}{2}$.\n$$\ne_C = \\frac{\\text{edges within } C}{m} = \\frac{\\frac{s(s-1)}{2}}{\\frac{r}{2}(s^2-s+2)} = \\frac{s^2-s}{r(s^2-s+2)}\n$$\n\n$a_C$ is the fraction of edge ends (or half-links) attached to nodes in community $C$. The total number of edge ends in the network is $2m$. The number of edge ends attached to nodes in $C$ is the sum of the degrees of all nodes in $C$, denoted $k_C$.\nThe sum of degrees $k_C$ can be calculated as twice the number of internal edges plus the number of external edges. Community $C$ is connected to two other cliques, so it has $2$ external edges.\n$$\nk_C = 2 \\times (\\text{internal edges}) + (\\text{external edges}) = 2 \\times \\frac{s(s-1)}{2} + 2 = s^2 - s + 2\n$$\nSo, $a_C$ is:\n$$\na_C = \\frac{k_C}{2m} = \\frac{s^2-s+2}{2 \\times \\frac{r}{2}(s^2-s+2)} = \\frac{s^2-s+2}{r(s^2-s+2)} = \\frac{1}{r}\n$$\nNow we can compute $Q_r$:\n$$\nQ_r = r(e_C - a_C^2) = r \\left( \\frac{s^2-s}{r(s^2-s+2)} - \\left(\\frac{1}{r}\\right)^2 \\right) = \\frac{s^2-s}{s^2-s+2} - \\frac{r}{r^2} = \\frac{s^2-s}{s^2-s+2} - \\frac{1}{r}\n$$\n\n### Part 3: Compute the modularity $Q_{r/2}$\nIn this partition, we have $r/2$ communities. Each new community, let's call it $C'$, is formed by merging a pair of adjacent cliques (e.g., $C_1$ and $C_2$) and the single edge connecting them.\nAgain, by symmetry, we can calculate the contribution from one such community $C'$ and multiply by the number of communities, $r/2$.\nThe modularity is $Q_{r/2} = \\frac{r}{2}(e_{C'} - a_{C'}^2)$.\n\n$e_{C'}$ is the fraction of edges internal to community $C'$. The internal edges are the edges within the first clique, the edges within the second clique, and the one edge that connected them.\nNumber of internal edges in $C'$ = $\\frac{s(s-1)}{2} + \\frac{s(s-1)}{2} + 1 = s(s-1)+1 = s^2-s+1$.\n$$\ne_{C'} = \\frac{s^2-s+1}{m} = \\frac{s^2-s+1}{\\frac{r}{2}(s^2-s+2)} = \\frac{2(s^2-s+1)}{r(s^2-s+2)}\n$$\n\n$a_{C'}$ is the fraction of edge ends in $C'$. A merged community $C'$ consists of two original cliques, say $C_1$ and $C_2$. The set of nodes in $C'$ is the disjoint union of nodes in $C_1$ and $C_2$. The degrees of the nodes are properties of the graph, not the partition. Thus, the sum of degrees of nodes in $C'$ is the sum of degrees of nodes in $C_1$ plus the sum of degrees of nodes in $C_2$.\n$$\nk_{C'} = k_{C_1} + k_{C_2} = (s^2-s+2) + (s^2-s+2) = 2(s^2-s+2)\n$$\nAlternatively, the sum of ends is $2 \\times (\\text{internal edges}) + (\\text{external edges})$. For $C'$, there are two external edges (one from the former $C_1$ to its other neighbor, and one from the former $C_2$ to its other neighbor).\n$k_{C'} = 2(s^2-s+1) + 2 = 2s^2-2s+4 = 2(s^2-s+2)$. Both methods agree.\nSo, $a_{C'}$ is:\n$$\na_{C'} = \\frac{k_{C'}}{2m} = \\frac{2(s^2-s+2)}{2 \\times \\frac{r}{2}(s^2-s+2)} = \\frac{2(s^2-s+2)}{r(s^2-s+2)} = \\frac{2}{r}\n$$\nNow we can compute $Q_{r/2}$:\n$$\nQ_{r/2} = \\frac{r}{2}(e_{C'} - a_{C'}^2) = \\frac{r}{2} \\left( \\frac{2(s^2-s+1)}{r(s^2-s+2)} - \\left(\\frac{2}{r}\\right)^2 \\right)\n$$\n$$\nQ_{r/2} = \\frac{r}{2} \\frac{2(s^2-s+1)}{r(s^2-s+2)} - \\frac{r}{2} \\frac{4}{r^2} = \\frac{s^2-s+1}{s^2-s+2} - \\frac{2}{r}\n$$\n\n### Part 4: Compute the difference $\\Delta Q(r,s)$\nFinally, we compute the difference $\\Delta Q(r,s) = Q_{r/2} - Q_{r}$.\n$$\n\\Delta Q(r,s) = \\left( \\frac{s^2-s+1}{s^2-s+2} - \\frac{2}{r} \\right) - \\left( \\frac{s^2-s}{s^2-s+2} - \\frac{1}{r} \\right)\n$$\n$$\n\\Delta Q(r,s) = \\left( \\frac{s^2-s+1}{s^2-s+2} - \\frac{s^2-s}{s^2-s+2} \\right) + \\left( -\\frac{2}{r} + \\frac{1}{r} \\right)\n$$\n$$\n\\Delta Q(r,s) = \\frac{(s^2-s+1) - (s^2-s)}{s^2-s+2} - \\frac{1}{r}\n$$\n$$\n\\Delta Q(r,s) = \\frac{1}{s^2-s+2} - \\frac{1}{r}\n$$\n\nThis expression represents the change in modularity when pairs of adjacent cliques are merged. A positive value of $\\Delta Q$ indicates that the coarser partition (with $r/2$ communities) is preferred by the modularity metric, which is the heart of the resolution limit problem. This occurs when $\\frac{1}{s^2-s+2}  \\frac{1}{r}$, or $r  s^2-s+2$.",
            "answer": "$$\n\\boxed{\\frac{1}{s^2 - s + 2} - \\frac{1}{r}}\n$$"
        },
        {
            "introduction": "Building on the previous exercise, this problem explores the resolution limit in a different but equally illustrative scenario involving weighted networks. Here, we consider two well-defined communities and tune the \"coupling strength\" of the inter-community edges. Your task is to derive the critical coupling weight at which modularity maximization transitions from correctly identifying the two communities to merging them into one . This analysis leads to a starkly clear result that deepens the intuition for why the resolution limit occurs, even when inter-community connections are demonstrably weaker than intra-community ones.",
            "id": "4311076",
            "problem": "Consider an undirected, weighted network composed of two identical modules, each being a fully connected clique with $n$ nodes. Every intra-module edge has weight $1$. Between modules, every pair of nodes across the modules is connected (i.e., the inter-module topology is complete bipartite), and every inter-module edge has tunable weight $w \\geq 0$. The total weight in the network is the sum of all edge weights. Assume that community detection is performed by maximizing the standard weighted Newman–Girvan Modularity (NGM).\n\nStarting from first principles and the weighted definition of Newman–Girvan Modularity, analyze how the optimal community structure changes as the inter-module coupling $w$ increases continuously from $0$, and determine the exact critical value of $w$ at which the optimal modularity-maximizing partition transitions from two communities (each clique as its own community) to a single merged community containing all $2n$ nodes.\n\nYour derivation must:\n- Begin from the modularity definition for weighted graphs and the stated network structure, computing the modularity for the two-community partition and for the single-community partition.\n- Use only the stated properties of the graph and quantities derivable from them (total edge weight, node strengths, and community-level aggregates).\n- Produce as the final result a closed-form analytic expression for the critical coupling $w_c$ as a function of $n$.\n\nExpress your final answer as a single analytic expression. No numerical approximation is required.",
            "solution": "The problem statement is scientifically grounded, well-posed, objective, and contains all necessary information for a unique solution. It is a valid problem in network science, specifically addressing the resolution limit of modularity maximization. We may proceed with the solution.\n\nThe Newman–Girvan Modularity (NGM) for a weighted, undirected network is given by the expression:\n$$\nQ = \\frac{1}{2m} \\sum_{i,j} \\left[ A_{ij} - \\frac{k_i k_j}{2m} \\right] \\delta(c_i, c_j)\n$$\nwhere $A_{ij}$ is the weight of the edge between nodes $i$ and $j$, $k_i = \\sum_j A_{ij}$ is the strength (weighted degree) of node $i$, $m = \\frac{1}{2} \\sum_i k_i$ is the total weight of all edges in the network, $c_i$ is the community assignment of node $i$, and $\\delta(c_i, c_j) = 1$ if $c_i = c_j$ and $0$ otherwise.\n\nFirst, we characterize the given network structure.\nThe network consists of $2n$ nodes, divided into two cliques of $n$ nodes each.\nLet's calculate the total weight of edges, $m$.\nWithin each clique, there are $\\binom{n}{2} = \\frac{n(n-1)}{2}$ edges, each with weight $1$. The total weight from these intra-module edges is $2 \\times \\frac{n(n-1)}{2} = n(n-1)$.\nBetween the two cliques, there are $n \\times n = n^2$ edges, each with weight $w$. The total weight from these inter-module edges is $n^2 w$.\nThe total weight of all edges in the network is therefore:\n$$\nm = n(n-1) + n^2 w\n$$\nNext, we determine the strength $k_i$ for an arbitrary node $i$. Due to the symmetry of the network, all nodes have the same strength. Consider a node $i$ in one of the cliques. It is connected to $n-1$ other nodes within its own clique (each connection has weight $1$) and to $n$ nodes in the other clique (each connection has weight $w$).\nThe strength of any node $i$ is:\n$$\nk_i = k = (n-1) \\times 1 + n \\times w = n-1 + nw\n$$\nWe can verify our expression for $m$ using the strengths: $2m = \\sum_i k_i = (2n)k = 2n(n-1+nw)$, which gives $m = n(n-1+nw) = n(n-1) + n^2w$, matching our previous calculation.\n\nNow, we evaluate the modularity for the two specified partitions.\n\n**Partition 1: Two Communities ($P_2$)**\nIn this partition, each clique forms a separate community. Let's call them $C_1$ and $C_2$. The modularity formula can be expressed as a sum over communities:\n$$\nQ = \\sum_{c} \\left( \\frac{L_c}{m} - \\left(\\frac{K_c}{2m}\\right)^2 \\right)\n$$\nwhere $L_c$ is the sum of weights of edges entirely within community $c$, and $K_c$ is the sum of the strengths of all nodes in community $c$.\n\nFor community $C_1$ (and identically for $C_2$):\nThe sum of internal edge weights, $L_1$, is the total weight of the clique, which is $L_1 = \\binom{n}{2} \\times 1 = \\frac{n(n-1)}{2}$.\nThe sum of node strengths, $K_1$, is the number of nodes in the community multiplied by the strength of each node: $K_1 = n \\times k = n(n-1+nw)$.\n\nThe total modularity for this two-community partition, $Q_2$, is:\n$$\nQ_2 = \\left( \\frac{L_1}{m} - \\left(\\frac{K_1}{2m}\\right)^2 \\right) + \\left( \\frac{L_2}{m} - \\left(\\frac{K_2}{2m}\\right)^2 \\right)\n$$\nSince $L_1 = L_2$ and $K_1 = K_2$, this simplifies to:\n$$\nQ_2 = 2 \\left( \\frac{L_1}{m} - \\left(\\frac{K_1}{2m}\\right)^2 \\right)\n$$\nLet's compute the term $\\frac{K_1}{2m}$:\n$$\n\\frac{K_1}{2m} = \\frac{n k}{2nk} = \\frac{1}{2}\n$$\nThis remarkably simple result holds for any bisection of a network into two parts with equal summed degrees.\nSubstituting this into the expression for $Q_2$:\n$$\nQ_2 = 2 \\left( \\frac{n(n-1)/2}{m} - \\left(\\frac{1}{2}\\right)^2 \\right) = \\frac{n(n-1)}{m} - 2 \\left(\\frac{1}{4}\\right) = \\frac{n(n-1)}{m} - \\frac{1}{2}\n$$\nFinally, substituting the expression for $m$:\n$$\nQ_2(w) = \\frac{n(n-1)}{n(n-1) + n^2 w} - \\frac{1}{2}\n$$\n\n**Partition 2: Single Community ($P_1$)**\nIn this partition, all $2n$ nodes belong to a single community. We use the same formula as above, but with only one term in the summation.\nThe single community encompasses the entire network.\nThe sum of internal edge weights, $L_{total}$, is the sum of all edge weights in the network, which is $m$.\nThe sum of node strengths, $K_{total}$, is the sum of all node strengths in the network, which is $2m$.\nThe modularity for this single-community partition, $Q_1$, is:\n$$\nQ_1 = \\frac{L_{total}}{m} - \\left(\\frac{K_{total}}{2m}\\right)^2 = \\frac{m}{m} - \\left(\\frac{2m}{2m}\\right)^2 = 1 - 1^2 = 0\n$$\nThe modularity of a partition into a single community is always zero.\n\n**Determining the Critical Coupling $w_c$**\nThe optimal partition is the one with the highest modularity. The two-community structure ($P_2$) is preferred when $Q_2(w)  Q_1$. The single-community structure ($P_1$) is preferred when $Q_1  Q_2(w)$. The transition occurs at the critical value of the coupling, $w_c$, where the modularity values are equal.\n$$\nQ_2(w_c) = Q_1\n$$\n$$\n\\frac{n(n-1)}{n(n-1) + n^2 w_c} - \\frac{1}{2} = 0\n$$\nSolving for $w_c$:\n$$\n\\frac{n(n-1)}{n(n-1) + n^2 w_c} = \\frac{1}{2}\n$$\n$$\n2n(n-1) = n(n-1) + n^2 w_c\n$$\nAssuming $n  1$ (for a non-trivial clique), we can simplify.\n$$\nn(n-1) = n^2 w_c\n$$\nDividing both sides by $n^2$ (assuming $n \\neq 0$):\n$$\nw_c = \\frac{n(n-1)}{n^2} = \\frac{n-1}{n}\n$$\nThis expression gives the critical inter-module edge weight $w_c$. For $w  w_c$, $Q_2(w)  0$, making the two-community partition optimal. For $w  w_c$, $Q_2(w)  0$, making the single-community partition (with $Q_1 = 0$) optimal. At $w=w_c$, both partitions have a modularity of $0$.",
            "answer": "$$\\boxed{\\frac{n-1}{n}}$$"
        },
        {
            "introduction": "This final practice moves from analytical derivation to computational experiment, grounding the theoretical concept of the resolution limit in a practical application. You will implement a simulation using the Stochastic Block Model (SBM) to generate networks with a known ground-truth community structure. By applying a greedy modularity optimization algorithm, you will observe firsthand how the algorithm's ability to recover the true communities degrades as the overall network size increases, even when the communities themselves remain well-defined . This exercise demonstrates the tangible consequences of the resolution limit and introduces the use of metrics like Normalized Mutual Information (NMI) to quantify performance.",
            "id": "4311141",
            "problem": "Consider undirected, unweighted graphs generated by the equal-size Stochastic Block Model (SBM) with $B$ blocks of size $s$ each, so that $N = B s$. Let the average degree be $k$, and let the mixing parameter $\\mu \\in [0,1]$ denote the fraction of a node's expected edges that go outside its own block. For equal-sized blocks, setting the within-block connection probability $p_{\\mathrm{in}}$ and the cross-block probability $p_{\\mathrm{out}}$ to satisfy the expected degree constraint leads to\n$$\np_{\\mathrm{in}} = \\frac{(1 - \\mu) k}{s - 1}, \\quad p_{\\mathrm{out}} = \\frac{\\mu k}{N - s}.\n$$\nThe ground-truth partition assigns each node to its block. The modularity $Q$ of a partition $\\{c_i\\}$ of the node set is\n$$\nQ = \\frac{1}{2m} \\sum_{i,j} \\left(A_{ij} - \\frac{k_i k_j}{2m}\\right) \\delta(c_i, c_j),\n$$\nwhere $A_{ij}$ is the adjacency matrix, $k_i$ is the degree of node $i$, and $m$ is the total number of edges. The resolution limit of modularity describes the tendency for modularity optimization to merge small communities when the total system size increases, even if the small communities are well-defined.\n\nTask: Implement a complete program that, for each test case below, performs the following steps:\n- Generate one SBM realization with parameters $(N, s, k, \\mu)$ as specified, using the probabilities $p_{\\mathrm{in}}$ and $p_{\\mathrm{out}}$ above.\n- Initialize the partition to the ground-truth block assignment.\n- Iteratively and greedily merge the pair of communities that yields the largest strictly positive increase in modularity $Q$, stopping when no merge produces a positive $Q$ increase. Only pairwise merges are permitted.\n- Compute the Normalized Mutual Information (NMI) between the final detected partition and the ground-truth partition, defined as\n$$\n\\mathrm{NMI}(X,Y) = \\frac{2 I(X;Y)}{H(X) + H(Y)},\n$$\nwith mutual information\n$$\nI(X;Y) = \\sum_{x \\in X} \\sum_{y \\in Y} \\frac{n_{xy}}{N} \\log \\left(\\frac{n_{xy} N}{n_x n_y}\\right),\n$$\nand entropies\n$$\nH(X) = - \\sum_{x \\in X} \\frac{n_x}{N} \\log \\left(\\frac{n_x}{N}\\right), \\quad H(Y) = - \\sum_{y \\in Y} \\frac{n_y}{N} \\log \\left(\\frac{n_y}{N}\\right),\n$$\nwhere $n_{xy}$ is the number of nodes assigned to community $x$ in partition $X$ and community $y$ in partition $Y$, and $n_x$ and $n_y$ are marginal counts. Use the natural logarithm.\n\nParameters:\n- Block size $s = 16$ (fixed across tests).\n- Average degree $k = 12$ (fixed across tests).\n- Mixing parameter $\\mu$ varies per test.\n- Total system size $N$ varies per test.\n\nTest suite:\n1. $(N = 64, \\mu = 0.10)$\n2. $(N = 64, \\mu = 0.40)$\n3. $(N = 160, \\mu = 0.10)$\n4. $(N = 160, \\mu = 0.30)$\n5. $(N = 320, \\mu = 0.10)$\n6. $(N = 320, \\mu = 0.35)$\n\nFinal output format:\n- Your program should produce a single line of output containing the six NMI values, one per test case in the order above, rounded to four decimal places, as a comma-separated list enclosed in square brackets (e.g., “[0.9321,0.4810,0.9023,0.7123,0.8532,0.6011]”).\n\nNo physical units or angle units apply. All random number generation must be deterministic per test case to ensure reproducibility. The program must be fully self-contained and require no user input.",
            "solution": "The problem is valid. It is a well-defined computational task based on established principles in network science, specifically the study of community detection and the resolution limit of modularity. All parameters, formulas, and procedures are clearly specified, and the test cases are computationally feasible.\n\nThe solution proceeds by implementing the specified algorithm for each test case. The core steps are: (1) generation of a graph from the Stochastic Block Model (SBM), (2) application of a greedy agglomerative algorithm to optimize modularity, and (3) evaluation of the resulting partition against the ground truth using Normalized Mutual Information (NMI).\n\n### 1. Stochastic Block Model (SBM) Graph Generation\nFor each test case with parameters for total nodes $N$, block size $s$, average degree $k$, and mixing parameter $\\mu$, we first derive the necessary model parameters. The number of blocks is $B = N/s$. The probabilities for creating an edge between two nodes are:\n- $p_{\\mathrm{in}} = \\frac{(1 - \\mu) k}{s - 1}$ for two nodes within the same block.\n- $p_{\\mathrm{out}} = \\frac{\\mu k}{N - s}$ for two nodes in different blocks.\n\nA graph instance is generated as an undirected, unweighted graph with $N$ nodes. The ground-truth partition is defined by assigning nodes $0, \\dots, s-1$ to block $0$, nodes $s, \\dots, 2s-1$ to block $1$, and so on. An $N \\times N$ adjacency matrix $A$ is constructed by considering every pair of nodes $(i, j)$ with $i  j$. An edge $(i, j)$ is created with probability $p_{\\mathrm{in}}$ if nodes $i$ and $j$ belong to the same block, and with probability $p_{\\mathrm{out}}$ if they belong to different blocks. To ensure reproducibility as required, the pseudo-random number generator is seeded with a unique integer for each test case.\n\n### 2. Greedy Modularity Optimization\nThe algorithm for community detection starts with the ground-truth partition, where each of the $B$ blocks constitutes a community. The process iteratively merges pairs of communities to maximize the increase in modularity, $Q$.\n\nThe modularity of a partition is given by:\n$$\nQ = \\frac{1}{2m} \\sum_{i,j} \\left(A_{ij} - \\frac{k_i k_j}{2m}\\right) \\delta(c_i, c_j)\n$$\nwhere $m$ is the total number of edges, $A$ is the adjacency matrix, $k_i$ is the degree of node $i$, and $c_i$ is the community of node $i$. An equivalent formulation, more useful for tracking changes, is:\n$$\nQ = \\sum_{c \\in C} \\left( \\frac{L_{c}}{m} - \\left(\\frac{k_C}{2m}\\right)^2 \\right)\n$$\nwhere the sum is over the set of communities $C$, $L_c$ is the number of internal edges within community $c$, and $k_C$ is the sum of degrees of all nodes in community $c$.\n\nWhen two distinct communities, $c_i$ and $c_j$, are merged, the change in modularity, $\\Delta Q_{ij}$, can be calculated efficiently:\n$$\n\\Delta Q_{ij} = Q_{\\text{merged}} - Q_{\\text{original}} = 2 \\left( \\frac{L_{ij}}{2m} - \\frac{k_{C_i} k_{C_j}}{(2m)^2} \\right)\n$$\nwhere $L_{ij}$ is the number of edges between communities $c_i$ and $c_j$, $k_{C_i}$ is the total degree of community $c_i$, and $k_{C_j}$ is the total degree of community $c_j$.\n\nThe greedy algorithm is as follows:\n1. Initialize the partition to the ground-truth blocks.\n2. In each step, calculate $\\Delta Q_{ij}$ for every possible pair of distinct communities $(c_i, c_j)$.\n3. Find the pair $(c_i^*, c_j^*)$ that yields the maximum positive increase in modularity, $\\max(\\Delta Q_{ij})$.\n4. If $\\max(\\Delta Q_{ij})  0$, merge communities $c_i^*$ and $c_j^*$. Update the partition and the community-level properties (total degrees and inter-community edges).\n5. Repeat from step 2 until no merge results in a strictly positive increase in $Q$.\n\nThis process yields a final partition, which may have fewer communities than the initial $B$ blocks, demonstrating the resolution limit.\n\n### 3. Normalized Mutual Information (NMI)\nTo quantify how well the final detected partition $X$ matches the ground-truth partition $Y$, we compute the Normalized Mutual Information (NMI). First, a contingency table (or confusion matrix) with entries $n_{xy}$ is constructed, where $n_{xy}$ is the number of nodes belonging to community $x$ in partition $X$ and community $y$ in partition $Y$.\n\nThe mutual information $I(X;Y)$ is calculated as:\n$$\nI(X;Y) = \\sum_{x \\in X} \\sum_{y \\in Y} \\frac{n_{xy}}{N} \\log \\left(\\frac{n_{xy} N}{n_x n_y}\\right)\n$$\nwhere $n_x = \\sum_y n_{xy}$ and $n_y = \\sum_x n_{xy}$ are the marginal counts (community sizes), and the natural logarithm is used. Terms where $n_{xy}=0$ are treated as zero.\n\nThe entropies of the partitions are:\n$$\nH(X) = - \\sum_{x \\in X} \\frac{n_x}{N} \\log \\left(\\frac{n_x}{N}\\right)\n$$\n$$\nH(Y) = - \\sum_{y \\in Y} \\frac{n_y}{N} \\log \\left(\\frac{n_y}{N}\\right)\n$$\n\nFinally, the NMI is given by:\n$$\n\\mathrm{NMI}(X,Y) = \\frac{2 I(X;Y)}{H(X) + H(Y)}\n$$\nAn NMI of $1$ indicates perfect agreement between the partitions, while an NMI of $0$ indicates no more agreement than expected by chance. Lower NMI values for larger N, even with low $\\mu$, will illustrate the resolution limit.\n\n### 4. Implementation Details\nThe overall process is encapsulated in a program that iterates through the six provided test cases. For each case, it deterministically generates the graph, runs the greedy merging algorithm, computes the NMI of the resulting partition, and stores the value. The final output is a list of these NMI values, rounded to four decimal places.",
            "answer": "```python\nimport numpy as np\n\ndef generate_sbm(N, s, k, mu, seed):\n    \"\"\"\n    Generates an undirected, unweighted SBM graph.\n\n    Args:\n        N (int): Total number of nodes.\n        s (int): Size of each block.\n        k (float): Average degree.\n        mu (float): Mixing parameter.\n        seed (int): Seed for the random number generator.\n\n    Returns:\n        tuple: A tuple containing:\n            - np.ndarray: Adjacency matrix of the graph.\n            - np.ndarray: Ground truth partition array.\n    \"\"\"\n    if N % s != 0:\n        raise ValueError(\"N must be a multiple of s.\")\n    B = N // s\n    \n    if s == 1:\n        p_in = 0  # No self-loops, so probability of in-block edge is 0\n    else:\n        p_in = (1 - mu) * k / (s - 1)\n    \n    if N == s:\n        p_out = 0 # No other blocks to connect to\n    else:\n        p_out = mu * k / (N - s)\n\n    if p_in > 1 or p_out > 1:\n        # This check is for robustness, though problem parameters are safe.\n        raise ValueError(f\"Probabilities must be = 1. Got p_in={p_in}, p_out={p_out}\")\n\n    adj = np.zeros((N, N), dtype=np.int8)\n    ground_truth = np.repeat(np.arange(B), s)\n    rng = np.random.default_rng(seed)\n\n    for i in range(N):\n        for j in range(i + 1, N):\n            prob = p_in if ground_truth[i] == ground_truth[j] else p_out\n            if rng.random()  prob:\n                adj[i, j] = 1\n                adj[j, i] = 1\n                \n    return adj, ground_truth\n\ndef calculate_nmi(p_true, p_pred, N):\n    \"\"\"\n    Calculates the Normalized Mutual Information (NMI) between two partitions.\n    \n    Args:\n        p_true (np.ndarray): The ground truth partition labels.\n        p_pred (np.ndarray): The predicted partition labels.\n        N (int): Total number of nodes.\n\n    Returns:\n        float: The NMI value.\n    \"\"\"\n    # Create unique labels for communities\n    true_labels = np.unique(p_true)\n    pred_labels = np.unique(p_pred)\n    \n    true_map = {label: i for i, label in enumerate(true_labels)}\n    pred_map = {label: i for i, label in enumerate(pred_labels)}\n\n    # Contingency table\n    contingency = np.zeros((len(true_labels), len(pred_labels)))\n    for i in range(N):\n        contingency[true_map[p_true[i]], pred_map[p_pred[i]]] += 1\n\n    # Marginals\n    n_x = np.sum(contingency, axis=0) # Sum over rows for pred communities\n    n_y = np.sum(contingency, axis=1) # Sum over columns for true communities\n    \n    # Mutual Information I(X; Y)\n    I_xy = 0\n    for i in range(len(true_labels)):\n        for j in range(len(pred_labels)):\n            if contingency[i, j] > 0:\n                n_ij = contingency[i,j]\n                I_xy += (n_ij / N) * np.log((n_ij * N) / (n_y[i] * n_x[j]))\n    \n    # Entropy H(X) and H(Y)\n    H_x = 0\n    for val in n_x:\n        if val > 0:\n            H_x -= (val / N) * np.log(val / N)\n            \n    H_y = 0\n    for val in n_y:\n        if val > 0:\n            H_y -= (val / N) * np.log(val / N)\n            \n    # NMI\n    if (H_x + H_y) == 0:\n        return 1.0 if np.array_equal(p_true, p_pred) else 0.0\n    \n    return 2 * I_xy / (H_x + H_y)\n\ndef run_single_case(N, s, k, mu, seed):\n    \"\"\"\n    Runs the full simulation for a single test case.\n    \"\"\"\n    adj, ground_truth = generate_sbm(N, s, k, mu, seed)\n    \n    num_edges = np.sum(adj) / 2\n    if num_edges == 0: # Handle disconnected graph case\n        return calculate_nmi(ground_truth, np.arange(N), N)\n\n    total_degree_2m = 2 * num_edges\n    \n    node_degrees = np.sum(adj, axis=1)\n    \n    # --- Greedy merging algorithm ---\n    \n    # Initial partition is the ground truth\n    current_partition = ground_truth.copy()\n    comm_ids = list(np.unique(current_partition))\n    num_comms = len(comm_ids)\n\n    # Use dictionaries for flexible community management\n    id_map = {cid: i for i, cid in enumerate(comm_ids)}\n    \n    while True:\n        # Re-evaluate community properties at each step for simplicity\n        # For larger problems, an update mechanism would be more efficient\n        \n        # Calculate community degrees and inter-community edges\n        k_comm = {cid: 0 for cid in comm_ids}\n        for i in range(N):\n            k_comm[current_partition[i]] += node_degrees[i]\n            \n        L_inter = np.zeros((num_comms, num_comms))\n        comm_nodes = {cid: np.where(current_partition == cid)[0] for cid in comm_ids}\n\n        for i in range(num_comms):\n            for j in range(i + 1, num_comms):\n                cid1 = comm_ids[i]\n                cid2 = comm_ids[j]\n                nodes1 = comm_nodes[cid1]\n                nodes2 = comm_nodes[cid2]\n                \n                # Number of edges between the two communities\n                edges_between = np.sum(adj[np.ix_(nodes1, nodes2)])\n                L_inter[i, j] = edges_between\n\n        # Find best merge\n        max_delta_q = -1.0\n        best_pair = None\n        \n        for i in range(num_comms):\n            for j in range(i + 1, num_comms):\n                cid1, cid2 = comm_ids[i], comm_ids[j]\n                \n                L_ij = L_inter[i, j]\n                k_C_i = k_comm[cid1]\n                k_C_j = k_comm[cid2]\n                \n                delta_q = 2 * ( (L_ij / total_degree_2m) - (k_C_i * k_C_j) / (total_degree_2m**2) )\n\n                if delta_q > max_delta_q:\n                    max_delta_q = delta_q\n                    best_pair = (cid1, cid2)\n\n        if max_delta_q > 0:\n            # Perform merge\n            c_absorb, c_merge_into = min(best_pair), max(best_pair)\n            \n            # Update partition array\n            current_partition[current_partition == c_merge_into] = c_absorb\n            \n            # Update community list\n            comm_ids.remove(c_merge_into)\n            num_comms = len(comm_ids)\n        else:\n            # No positive Q increase, stop\n            break\n\n    # Calculate NMI of final partition\n    nmi_result = calculate_nmi(ground_truth, current_partition, N)\n    return nmi_result\n    \ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    # Fixed parameters\n    s_fixed = 16\n    k_fixed = 12\n\n    # Test suite: (N, mu)\n    test_cases = [\n        (64, 0.10),\n        (64, 0.40),\n        (160, 0.10),\n        (160, 0.30),\n        (320, 0.10),\n        (320, 0.35),\n    ]\n\n    results = []\n    for i, (N_val, mu_val) in enumerate(test_cases):\n        # Use test case index as seed for reproducibility\n        seed = i\n        nmi = run_single_case(N_val, s_fixed, k_fixed, mu_val, seed)\n        results.append(f\"{nmi:.4f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}