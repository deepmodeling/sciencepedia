{
    "hands_on_practices": [
        {
            "introduction": "The Label Propagation Algorithm operates on a simple, powerful principle of local consensus. To truly grasp its mechanics, there is no substitute for performing the calculations by hand. This first exercise  provides a foundational drill, guiding you through a single synchronous update on a small, weighted network. By meticulously tracking how each node aggregates influence from its neighbors and resolves ties, you will build a concrete understanding of the core update rule that drives the entire algorithm.",
            "id": "4285516",
            "problem": "Consider an undirected, weighted network with node set $\\{1,2,3,4,5,6\\}$ and weighted adjacency matrix $W \\in \\mathbb{R}^{6 \\times 6}$ given by\n$$\nW \\;=\\;\n\\begin{pmatrix}\n0 & 1 & 1 & 0 & 0 & 0 \\\\\n1 & 0 & 1 & 0 & 2 & 0 \\\\\n1 & 1 & 0 & 1 & 0 & 0 \\\\\n0 & 0 & 1 & 0 & 1 & 1 \\\\\n0 & 2 & 0 & 1 & 0 & 1 \\\\\n0 & 0 & 0 & 1 & 1 & 0\n\\end{pmatrix}.\n$$\nWe will apply one synchronous iteration of the Label Propagation Algorithm (LPA), defined as follows: at iteration $t$, each node $i$ updates its label to the label that maximizes the sum of the weights $W_{ij}$ of edges from $i$ to its neighbors $j$ currently carrying that label. If there is a tie among two or more labels (equal maximizing sums), break the tie by choosing the label with the smallest index. Let the label set be $\\mathcal{L} = \\{\\ell_1, \\ell_2\\}$, with the index order $\\ell_1 \\prec \\ell_2$. The initial labeling is\n$$\nL^{(0)} \\;=\\; (\\ell_1,\\; \\ell_2,\\; \\ell_2,\\; \\ell_1,\\; \\ell_2,\\; \\ell_1),\n$$\nassigned to nodes $(1,2,3,4,5,6)$ respectively.\n\nPerform exactly one synchronous iteration of LPA to obtain $L^{(1)}$. Then, treating $L^{(1)}$ as a partition of the nodes, compute the modularity $Q$ of this partition under the standard weighted, undirected configuration-model null baseline. Express the final modularity as an exact rational number. No rounding is required. The final answer must be a single real-valued number.",
            "solution": "We begin from the definition of the Label Propagation Algorithm (LPA): each node selects the label maximizing the sum of incident edge weights to neighbors carrying that label. The update is synchronous, so all nodes compute their new labels from $L^{(0)}$ and update simultaneously to form $L^{(1)}$. The tie-breaking rule selects the smallest index label when maxima are equal, here $\\ell_1 \\prec \\ell_2$.\n\nStep $1$: compute $L^{(1)}$ by aggregating neighbor weights by label for each node under $L^{(0)}$.\n\n- Node $1$ has neighbors $\\{2,3\\}$ with weights $W_{12} = 1$ and $W_{13} = 1$. Under $L^{(0)}$, node $2$ carries $\\ell_2$ and node $3$ carries $\\ell_2$. Aggregated weights: $\\ell_1$: $0$, $\\ell_2$: $1+1 = 2$. Node $1$ updates to $\\ell_2$.\n\n- Node $2$ has neighbors $\\{1,3,5\\}$ with weights $W_{21} = 1$, $W_{23} = 1$, $W_{25} = 2$. Under $L^{(0)}$, labels are $L^{(0)}(1) = \\ell_1$, $L^{(0)}(3) = \\ell_2$, $L^{(0)}(5) = \\ell_2$. Aggregated weights: $\\ell_1$: $1$, $\\ell_2$: $1+2 = 3$. Node $2$ updates to $\\ell_2$ (unchanged).\n\n- Node $3$ has neighbors $\\{1,2,4\\}$ with weights $W_{31} = 1$, $W_{32} = 1$, $W_{34} = 1$. Under $L^{(0)}$, labels are $L^{(0)}(1) = \\ell_1$, $L^{(0)}(2) = \\ell_2$, $L^{(0)}(4) = \\ell_1$. Aggregated weights: $\\ell_1$: $1+1 = 2$, $\\ell_2$: $1$. Node $3$ updates to $\\ell_1$.\n\n- Node $4$ has neighbors $\\{3,5,6\\}$ with weights $W_{43} = 1$, $W_{45} = 1$, $W_{46} = 1$. Under $L^{(0)}$, labels are $L^{(0)}(3) = \\ell_2$, $L^{(0)}(5) = \\ell_2$, $L^{(0)}(6) = \\ell_1$. Aggregated weights: $\\ell_1$: $1$, $\\ell_2$: $1+1 = 2$. Node $4$ updates to $\\ell_2$.\n\n- Node $5$ has neighbors $\\{2,4,6\\}$ with weights $W_{52} = 2$, $W_{54} = 1$, $W_{56} = 1$. Under $L^{(0)}$, labels are $L^{(0)}(2) = \\ell_2$, $L^{(0)}(4) = \\ell_1$, $L^{(0)}(6) = \\ell_1$. Aggregated weights: $\\ell_1$: $1+1 = 2$, $\\ell_2$: $2$. This is a tie between $\\ell_1$ and $\\ell_2$ at total weight $2$. By the tie-breaking rule, node $5$ updates to $\\ell_1$ (the smallest index).\n\n- Node $6$ has neighbors $\\{4,5\\}$ with weights $W_{64} = 1$, $W_{65} = 1$. Under $L^{(0)}$, labels are $L^{(0)}(4) = \\ell_1$, $L^{(0)}(5) = \\ell_2$. Aggregated weights: $\\ell_1$: $1$, $\\ell_2$: $1$. This is a tie; by tie-breaking, node $6$ updates to $\\ell_1$ (unchanged).\n\nCollecting the updates, the synchronous iteration yields\n$$\nL^{(1)} \\;=\\; (\\ell_2,\\; \\ell_2,\\; \\ell_1,\\; \\ell_2,\\; \\ell_1,\\; \\ell_1).\n$$\n\nStep $2$: compute the modularity $Q$ of the partition induced by $L^{(1)}$ under the standard weighted, undirected configuration-model baseline. The modularity is defined by comparing the observed intra-community edge weight to the expected weight under the null model. For an undirected weighted graph, let $m$ be the sum of all edge weights, and let $k_i = \\sum_{j} W_{ij}$ be the strength (weighted degree) of node $i$. An equivalent and standard expression for modularity is\n$$\nQ \\;=\\; \\sum_{s} \\left( \\frac{l_s}{m} \\;-\\; \\left( \\frac{d_s}{2m} \\right)^{2} \\right),\n$$\nwhere the sum is over communities $s$, $l_s$ is the total weight of edges with both endpoints in community $s$, and $d_s$ is the sum of strengths $k_i$ over nodes in community $s$. We derive this identity from the baseline $\\left(W_{ij} - \\frac{k_i k_j}{2m}\\right)$ formulation by summing over node pairs within each community and recognizing that $\\sum_{i,j \\in s} W_{ij} = 2 l_s$ and $\\sum_{i \\in s} k_i = d_s$.\n\nCompute $m$, the total edge weight:\n$$\nm \\;=\\; W_{12} + W_{13} + W_{23} + W_{45} + W_{56} + W_{46} + W_{34} + W_{25}\n\\;=\\; 1+1+1+1+1+1+1+2 \\;=\\; 9.\n$$\nThus $2m = 18$.\n\nCompute strengths $k_i$ for $i \\in \\{1,\\dots,6\\}$:\n\\begin{align*}\nk_1 &= W_{12} + W_{13} \\;=\\; 1 + 1 \\;=\\; 2, \\\\\nk_2 &= W_{21} + W_{23} + W_{25} \\;=\\; 1 + 1 + 2 \\;=\\; 4, \\\\\nk_3 &= W_{31} + W_{32} + W_{34} \\;=\\; 1 + 1 + 1 \\;=\\; 3, \\\\\nk_4 &= W_{43} + W_{45} + W_{46} \\;=\\; 1 + 1 + 1 \\;=\\; 3, \\\\\nk_5 &= W_{52} + W_{54} + W_{56} \\;=\\; 2 + 1 + 1 \\;=\\; 4, \\\\\nk_6 &= W_{64} + W_{65} \\;=\\; 1 + 1 \\;=\\; 2.\n\\end{align*}\nCheck consistency: $\\sum_{i=1}^{6} k_i = 2+4+3+3+4+2 = 18 = 2m$.\n\nUnder $L^{(1)}$, community $\\ell_1$ contains nodes $\\{3,5,6\\}$ and community $\\ell_2$ contains nodes $\\{1,2,4\\}$.\n\nCompute intra-community weights:\n- For community $\\ell_1$ (nodes $\\{3,5,6\\}$), the edges with both endpoints inside are $(5,6)$ with weight $W_{56} = 1$. There are no edges $(3,5)$ or $(3,6)$ in $W$. Hence $l_{\\ell_1} = 1$.\n\n- For community $\\ell_2$ (nodes $\\{1,2,4\\}$), the edges with both endpoints inside are $(1,2)$ with weight $W_{12} = 1$. There are no edges $(1,4)$ or $(2,4)$. Hence $l_{\\ell_2} = 1$.\n\nCompute community strengths:\n\\begin{align*}\nd_{\\ell_1} &= k_3 + k_5 + k_6 \\;=\\; 3 + 4 + 2 \\;=\\; 9, \\\\\nd_{\\ell_2} &= k_1 + k_2 + k_4 \\;=\\; 2 + 4 + 3 \\;=\\; 9.\n\\end{align*}\n\nNow evaluate $Q$:\n\\begin{align*}\nQ &= \\left( \\frac{l_{\\ell_1}}{m} - \\left( \\frac{d_{\\ell_1}}{2m} \\right)^{2} \\right)\n   + \\left( \\frac{l_{\\ell_2}}{m} - \\left( \\frac{d_{\\ell_2}}{2m} \\right)^{2} \\right) \\\\\n  &= \\left( \\frac{1}{9} - \\left( \\frac{9}{18} \\right)^{2} \\right)\n   + \\left( \\frac{1}{9} - \\left( \\frac{9}{18} \\right)^{2} \\right) \\\\\n  &= 2 \\left( \\frac{1}{9} - \\frac{1}{4} \\right)\n   \\;=\\; 2 \\left( \\frac{4 - 9}{36} \\right)\n   \\;=\\; 2 \\left( -\\frac{5}{36} \\right)\n   \\;=\\; -\\frac{10}{36}\n   \\;=\\; -\\frac{5}{18}.\n\\end{align*}\n\nTherefore, the modularity of the partition produced by one synchronous LPA iteration with the specified tie-breaking is $-\\frac{5}{18}$.",
            "answer": "$$\\boxed{-\\frac{5}{18}}$$"
        },
        {
            "introduction": "An algorithm's behavior is defined not just by a single step, but by its evolution over time. This practice  explores the dynamic properties of synchronous LPA, revealing a classic failure mode. Using a complete bipartite graph, you will demonstrate how the simultaneous-update rule can lead to perpetual oscillations, where labels flip back and forth indefinitely without reaching a stable community structure. This insight is crucial for understanding why asynchronous update schemes are often preferred in practice and highlights the importance of network topology in shaping algorithmic outcomes.",
            "id": "4285556",
            "problem": "Consider the Label Propagation Algorithm (LPA), where each vertex in a network carries a label in the set $\\{+1,-1\\}$ and, under synchronous updates, each vertex simultaneously adopts the label that is the strict majority among its neighbors’ labels. In the case of an exact tie, the vertex retains its current label. Let $G$ be the complete bipartite graph $K_{m,n}$ with bipartition $(U,V)$, where $|U|=m$ and $|V|=n$, and every vertex in $U$ is connected to every vertex in $V$ with no edges inside $U$ or $V$. Initialize labels so that all vertices in $U$ have label $+1$ and all vertices in $V$ have label $-1$.\n\nUsing only core definitions of synchronous label updates and the structure of a bipartite graph, derive the resulting synchronous label dynamics starting from this initial condition. Then, determine the minimal period of the orbit generated by these dynamics (i.e., the smallest positive integer $p$ such that the system returns to its initial labeling after exactly $p$ synchronous updates). Your final answer must be a single real number. No rounding is required.",
            "solution": "The problem is well-posed, scientifically grounded, and self-contained. It describes a deterministic process on a well-defined mathematical object. We may therefore proceed with the solution.\n\nLet the state of the network at a discrete time step $t$ be denoted by the collection of all vertex labels. Let $L_t(x)$ be the label of vertex $x$ at time $t$. The set of labels is $\\{+1, -1\\}$. The network is a complete bipartite graph $G = K_{m,n}$ with bipartition $(U, V)$, where $|U|=m$ and $|V|=n$.\n\nThe initial condition at $t=0$ is given as:\nFor any vertex $u \\in U$, $L_0(u) = +1$.\nFor any vertex $v \\in V$, $L_0(v) = -1$.\n\nThe update rule is synchronous. At each time step $t+1$, every vertex $x$ simultaneously updates its label, $L_{t+1}(x)$, to be the label held by the strict majority of its neighbors at time $t$. If there is an exact tie among neighbor labels, the vertex retains its current label, i.e., $L_{t+1}(x) = L_t(x)$.\n\nLet us analyze the evolution of the system from $t=0$ to $t=1$.\n\nFirst, consider an arbitrary vertex $u \\in U$. By the definition of a complete bipartite graph, the set of neighbors of $u$, denoted $N(u)$, is the entire set $V$. The size of the neighborhood is $|N(u)| = |V| = n$. At time $t=0$, all vertices in $V$ have the label $-1$. Therefore, for any vertex $u \\in U$, all of its $n$ neighbors have the label $-1$. The collection of neighbor labels for $u$ is $\\{L_0(y) \\text{ for } y \\in N(u)\\} = \\{-1, -1, \\dots, -1\\}$. Provided $n > 0$, the strict majority label is unambiguously $-1$. The tie-breaking condition is not met. Thus, at time $t=1$, every vertex in $U$ adopts the label $-1$.\n$$ \\forall u \\in U, \\quad L_1(u) = -1 $$\n\nNext, consider an arbitrary vertex $v \\in V$. The set of its neighbors, $N(v)$, is the entire set $U$. The size of the neighborhood is $|N(v)| = |U| = m$. At time $t=0$, all vertices in $U$ have the label $+1$. Therefore, for any vertex $v \\in V$, all of its $m$ neighbors have the label $+1$. The collection of neighbor labels for $v$ is $\\{L_0(y) \\text{ for } y \\in N(v)\\} = \\{+1, +1, \\dots, +1\\}$. Provided $m > 0$, the strict majority label is unambiguously $+1$. Again, the tie-breaking condition is irrelevant. Thus, at time $t=1$, every vertex in $V$ adopts the label $+1$.\n$$ \\forall v \\in V, \\quad L_1(v) = +1 $$\n\nSo, at time $t=1$, the state of the system is the complete opposite of the initial state: all vertices in $U$ have label $-1$ and all vertices in $V$ have label $+1$.\n\nNow, let us analyze the evolution of the system from $t=1$ to $t=2$, using the state at $t=1$ as the new initial condition.\n\nConsider an arbitrary vertex $u \\in U$. Its neighbors are the $n$ vertices in $V$. At time $t=1$, all these neighbors have the label $+1$. The strict majority label among the neighbors of $u$ is therefore $+1$. So, at time $t=2$, every vertex in $U$ adopts the label $+1$.\n$$ \\forall u \\in U, \\quad L_2(u) = +1 $$\n\nConsider an arbitrary vertex $v \\in V$. Its neighbors are the $m$ vertices in $U$. At time $t=1$, all these neighbors have the label $-1$. The strict majority label among the neighbors of $v$ is therefore $-1$. So, at time $t=2$, every vertex in $V$ adopts the label $-1$.\n$$ \\forall v \\in V, \\quad L_2(v) = -1 $$\n\nThe state of the system at $t=2$ is: $L_2(u)=+1$ for all $u \\in U$ and $L_2(v)=-1$ for all $v \\in V$. This is identical to the initial state at $t=0$.\n\nLet $S_t$ be the state of the system (the full configuration of labels) at time $t$. We have shown that $S_2 = S_0$. Since the update rule is deterministic, the system's evolution is periodic. The sequence of states is $S_0, S_1, S_2, S_3, \\dots$, which is equivalent to $S_0, S_1, S_0, S_1, \\dots$.\n\nThe problem asks for the minimal period of the orbit, which is the smallest positive integer $p$ such that $S_p = S_0$.\nWe have found that for $p=2$, $S_2 = S_0$. We must check if a smaller positive integer satisfies this condition. The only smaller positive integer is $p=1$.\n\nLet's compare the state at $t=1$ with the state at $t=0$.\nState $S_0$: $L_0(u)=+1$ for $u \\in U$ and $L_0(v)=-1$ for $v \\in V$.\nState $S_1$: $L_1(u)=-1$ for $u \\in U$ and $L_1(v)=+1$ for $v \\in V$.\n\nAssuming the graph is non-trivial (i.e., $m \\ge 1$ and $n \\ge 1$), the sets $U$ and $V$ are non-empty, and the labels are different. Therefore, $S_1 \\neq S_0$.\n\nThe smallest positive integer $p$ for which $S_p = S_0$ is $p=2$. This result holds for any $m, n \\ge 1$. The system enters a limit cycle of length $2$ immediately. The minimal period of the orbit generated by the dynamics is therefore $2$.",
            "answer": "$$\\boxed{2}$$"
        },
        {
            "introduction": "Beyond simple dynamics, LPA exhibits emergent behaviors that determine its effectiveness on complex networks. This final exercise  shifts from direct simulation to a mean-field analysis, a powerful technique for understanding system-level properties. You will model the interaction between a small, dense community and a large one to determine the critical tipping point at which the smaller group is absorbed. This practice provides a clear, quantitative illustration of LPA's inherent resolution limit, helping to explain why the algorithm sometimes struggles to identify small communities embedded within larger ones.",
            "id": "4285519",
            "problem": "Consider a simple two-community network model designed to study the dynamics of the Label Propagation Algorithm (LPA). Let $C_A$ be a large community and $C_B$ be a small dense subgraph. Community $C_A$ is modeled as an Erdős–Rényi (ER) random graph $G(n_A, q_A)$ with $n_A$ nodes and intra-community edge probability $q_A$. Community $C_B$ is modeled as a complete graph (clique) $K_{n_B}$ with $n_B$ nodes. Between any pair of nodes $(i, j)$ with $i \\in C_A$ and $j \\in C_B$, an inter-community edge is present independently with probability $r$.\n\nAll edges are undirected and unweighted. At time $t=0$, each node in $C_A$ carries label $a$, and each node in $C_B$ carries label $b$. The network then undergoes one synchronous update under the Label Propagation Algorithm: each node adopts the label that maximizes the number of its neighbors currently carrying that label; in the event of a tie, the node preserves its current label.\n\nWe define the phenomenon of absorption of the small dense subgraph $C_B$ into the larger community $C_A$ to occur when, after the first synchronous update, a typical node in $C_B$ will adopt label $a$ rather than retain label $b$, under a mean-field assumption where neighbor counts are replaced by their expectations. The critical inter-community edge density $r_c$ is defined as the value of $r$ at which the expected number of neighbors with label $a$ seen by a node in $C_B$ equals the expected number of neighbors with label $b$ seen by the same node, so that for $r > r_c$ the small dense subgraph is absorbed, and for $r < r_c$ it resists absorption.\n\nAssume parameter values $n_A = 1200$, $q_A = 0.15$, and $n_B = 25$. The ER connectivity of $C_A$ is sufficiently strong that for all relevant $r$ it is internally self-stabilizing against label changes, in the sense that a node in $C_A$ has, in expectation, strictly more neighbors with label $a$ within $C_A$ than neighbors with label $b$ in $C_B$.\n\nCompute the critical inter-community edge density $r_c$ under the mean-field assumption described above. Express your final answer as a decimal and round your answer to four significant figures.",
            "solution": "The problem statement is deemed valid as it is scientifically grounded in network science, well-posed with all necessary information, and free of contradictions or ambiguities.\n\nThe objective is to compute the critical inter-community edge density, denoted as $r_c$. This critical value is defined by the condition where a typical node in the small community $C_B$ has an equal expected number of neighbors with label $a$ and label $b$ at the initial time $t=0$. This is the tipping point for the synchronous update of the Label Propagation Algorithm, according to the mean-field assumption specified.\n\nLet us consider a generic node $j$ belonging to the community $C_B$. We need to calculate the expected number of its neighbors with label $a$ and with label $b$.\n\nFirst, we determine the expected number of neighbors with label $b$. At time $t=0$, all nodes in $C_B$ carry label $b$. The community $C_B$ is modeled as a complete graph (clique) $K_{n_B}$. In a clique of size $n_B$, every node is connected to every other node. Therefore, any node $j \\in C_B$ is connected to all of the other $n_B - 1$ nodes within $C_B$. Since all these nodes have label $b$, the number of neighbors of node $j$ with label $b$ is deterministically $n_B - 1$. The expectation of a constant is the constant itself. Let $E[N_b(j)]$ be the expected number of neighbors of node $j$ with label $b$.\n$$E[N_b(j)] = n_B - 1$$\n\nNext, we determine the expected number of neighbors with label $a$. At time $t=0$, all nodes in the community $C_A$ carry label $a$. The number of nodes in $C_A$ is $n_A$. According to the problem statement, an edge between any node $j \\in C_B$ and any node $i \\in C_A$ exists independently with probability $r$. For node $j$, there are $n_A$ potential neighbors in $C_A$. The formation of each of these $n_A$ edges can be viewed as an independent Bernoulli trial with a success probability of $r$. The total number of neighbors of $j$ in $C_A$ is therefore a random variable following a binomial distribution $B(n_A, r)$. The expected value of this distribution is the product of the number of trials and the probability of success. Let $E[N_a(j)]$ be the expected number of neighbors of node $j$ with label $a$.\n$$E[N_a(j)] = n_A r$$\nThe parameter $q_A$, which is the intra-community edge probability for $C_A$, is not relevant for calculating the expected number of neighbors for a node in $C_B$.\n\nThe critical inter-community edge density $r_c$ is defined as the value of $r$ where these two expected values are equal.\n$$E[N_a(j)] = E[N_b(j)]$$\nSubstituting the expressions derived above, we set the condition for $r=r_c$:\n$$n_A r_c = n_B - 1$$\n\nWe can now solve for $r_c$:\n$$r_c = \\frac{n_B - 1}{n_A}$$\n\nThe problem provides the following parameter values: $n_A = 1200$ and $n_B = 25$. Substituting these values into the expression for $r_c$:\n$$r_c = \\frac{25 - 1}{1200} = \\frac{24}{1200}$$\n\nPerforming the division:\n$$r_c = \\frac{24}{1200} = \\frac{1}{50} = 0.02$$\n\nThe problem requires the answer to be expressed as a decimal rounded to four significant figures. To express $0.02$ with four significant figures, we write it as $0.02000$.",
            "answer": "$$\\boxed{0.02000}$$"
        }
    ]
}