{
    "hands_on_practices": [
        {
            "introduction": "路径图是一种基础的图结构，其中任意两点之间的最短路径是唯一的。这种简单性使其成为一个理想的起点，可以帮助我们从第一性原理出发，掌握介数中心性的核心概念。将指导您推导路径图上一个节点的捷径介数和流介数，并揭示为何这两种度量在树形结构上是等价的。",
            "id": "4263552",
            "problem": "考虑路径图 $P_n$，其包含 $n$ 个标记节点 $\\{1,2,\\dots,n\\}$，边集为 $\\{(i,i+1) : i=1,2,\\dots,n-1\\}$。固定一个内部节点 $k$，$1  k  n$。求节点 $k$ 的最短路径介数中心性。",
            "solution": "该问题陈述经评估为有效，因为它在网络科学中有科学依据，是良构的、客观的且自洽的。所提供的最短路径和电流介数中心性的定义是标准的，路径图 $P_n$ 也是图论中的一个基本结构。该问题要求从第一性原理出发进行推导，这是理解这些概念的一个有意义的练习。未检测到问题验证清单中定义的任何缺陷。\n\n我们将按以下步骤进行：首先推导最短路径介数中心性 $B(k)$，然后证明其在树上与电流介数中心性 $C(k)$ 等价，最后给出 $C(k)$ 的结果并提供组合解释。\n\n所讨论的图是具有 $n$ 个节点的路径图 $P_n$，这些节点按顺序标记为 $1, 2, \\dots, n$。边连接相邻节点，即 $\\{(i, i+1) : i=1, \\dots, n-1\\}$。路径图是树的一种。任何树的一个基本性质是，对于任意两个不同的节点 $s$ 和 $t$，都存在一条连接它们的唯一简单路径。这条路径必然是最短路径。因此，对于 $P_n$ 中的任意一对节点 $(s, t)$，最短路径的数量为 $\\sigma_{st} = 1$。\n\n首先，我们推导内部节点 $k$（$1  k  n$）的最短路径介数中心性 $B(k)$。其定义为：\n$$\nB(k) = \\sum_{s \\neq k \\neq t} \\frac{\\sigma_{st}(k)}{\\sigma_{st}}\n$$\n在路径图中，$\\sigma_{st} = 1$。只有当节点 $k$ 位于从 $s$ 到 $t$ 的唯一路径上时，$\\sigma_{st}(k)$ 才为 1，否则为 0。这发生在 $s$ 和 $t$ 位于 $k$ 的“两侧”时，即 $s  k  t$ 或 $t  k  s$。\n\n为了计算总和，我们对所有对 $(s,t)$ 进行计数，其中 $k$ 位于它们之间。为避免重复计数，我们只考虑 $s  t$ 的情况，这要求 $s  k  t$。\n- 源节点 $s$ 可以是集合 $\\{1, 2, \\dots, k-1\\}$ 中的任意一个。有 $k-1$ 种选择。\n- 目标节点 $t$ 可以是集合 $\\{k+1, k+2, \\dots, n\\}$ 中的任意一个。有 $n-k$ 种选择。\n\n因此，总共有 $(k-1)(n-k)$ 对节点 $(s,t)$ 的最短路径经过 $k$。对于每一对，贡献为 $\\frac{1}{1} = 1$。\n所以，最短路径介数中心性为：\n$$\nB(k) = \\sum_{s=1}^{k-1} \\sum_{t=k+1}^{n} \\frac{1}{1} = (k-1)(n-k)\n$$\n对于任何树状图（包括路径图），最短路径介数中心性与流介数中心性是等价的，因为任意两点之间只有一条路径。因此，节点 $k$ 的流介数中心性也是 $(k-1)(n-k)$。",
            "answer": "$$\\boxed{(k-1)(n-k)}$$"
        },
        {
            "introduction": "捷径介数和流介数之间的一个关键区别在于它们如何处理备选路径。捷径介数是一种“全有或全无”的度量，它只考虑绝对最短路径上的节点。将探讨一个精心构造的图，其中一条最短路径与多条稍长的备选路径并存，这种情况在现实网络中很常见。通过计算这两种中心性，本练习生动地展示了流介数如何将重要性分配到所有可用路径上，从而更细致地反映了节点在网络流量中的作用。",
            "id": "4263558",
            "problem": "考虑如下构建的无向、无权简单图。固定一个整数参数 $m \\ge 0$。顶点集为 $\\{s,t,v\\} \\cup \\{a_i,b_i\\}_{i=1}^{m}$。边集为 $\\{\\{s,v\\},\\{v,t\\}\\} \\cup \\bigcup_{i=1}^{m} \\{\\{s,a_i\\},\\{a_i,b_i\\},\\{b_i,t\\}\\}$。在电流介数中心性的电网络模型中，将每条边解释为电阻为 $1$ 的单位电阻器。设 $s$ 为源点，$t$ 为汇点，注入单位电流。\n\n仅使用基本定义和定律来回答以下问题。\n\n- 对于测地线介数中心性，使用成对贡献定义：对于顶点 $x,y$ 且 $x \\neq y$，点对 $(x,y)$ 对顶点 $w \\notin \\{x,y\\}$ 的依赖度为 $\\delta_{xy}(w) = \\sigma_{xy}(w)/\\sigma_{xy}$，其中 $\\sigma_{xy}$ 是 $x$–$y$ 之间最短路径的数量，$\\sigma_{xy}(w)$ 是这些路径中经过 $w$ 的数量。\n\n- 对于电流介数中心性，在单位电阻器网络上使用 Kirchhoff 电路定律：在 $s$ 处注入电流 $I=1$ 并在 $t$ 处取出，令 $\\iota_{st}(w)$ 表示在所得线性系统的唯一解下，流过顶点 $w$ 的电流量。\n\n在此图中，唯一的 $s$–$t$ 最短路径经过 $v$，但还存在 $m$ 条内部不相交的替代 $s$–$t$ 路径，它们不经过 $v$ 且长度多一条边。\n\n以 $m$ 的闭式函数形式计算比率\n$$\nR(m) \\equiv \\frac{\\delta_{st}(v)}{\\iota_{st}(v)}.\n$$\n请以关于 $m$ 的单一简化解析表达式给出最终答案。无需进行数值四舍五入，最终表达式中不应包含单位。",
            "solution": "该问题已经过分析，被认为是科学上成立、定义明确且客观的有效问题。这是网络科学中的一个标准问题，旨在比较两种不同的顶点中心性度量。\n\n解答过程分为三部分：首先，计算测地线介数中心性贡献 $\\delta_{st}(v)$；其次，计算电流介数中心性 $\\iota_{st}(v)$；最后，计算它们的比率 $R(m)$。\n\n**第一部分：测地线介数中心性贡献 $\\delta_{st}(v)$**\n\n测地线介数中心性基于一对顶点之间的最短路径中经过第三个顶点的路径所占的比例。点对 $(s,t)$ 对顶点 $v$ 的依赖度由 $\\delta_{st}(v) = \\frac{\\sigma_{st}(v)}{\\sigma_{st}}$ 给出，其中 $\\sigma_{st}$ 是从 $s$ 到 $t$ 的最短路径（测地线）的总数，而 $\\sigma_{st}(v)$ 是这些路径中经过 $v$ 的数量。\n\n该图是无权的，因此路径长度即为边的数量。我们找出所有从 $s$ 到 $t$ 的路径：\n1.  路径 $s \\to v \\to t$。此路径的长度为 $1+1=2$。\n2.  对于从 $1$ 到 $m$ 的每个整数 $i$，都有一条路径 $s \\to a_i \\to b_i \\to t$。这 $m$ 条路径中每条的长度都为 $1+1+1=3$。\n\n最短路径长度为 $2$。只有一条路径的长度为此值，即 $s \\to v \\to t$。因此，最短路径的总数为 $\\sigma_{st} = 1$。\n\n接下来，我们计算这些最短路径中经过顶点 $v$ 的数量。唯一的最短路径 $s \\to v \\to t$ 根据其构造，经过 $v$。因此，从 $s$ 到 $t$ 经过 $v$ 的最短路径数量为 $\\sigma_{st}(v) = 1$。\n\n使用所提供的定义， $v$ 对点对 $(s,t)$ 的测地线介数中心性贡献为：\n$$\n\\delta_{st}(v) = \\frac{\\sigma_{st}(v)}{\\sigma_{st}} = \\frac{1}{1} = 1\n$$\n\n**第二部分：电流介数中心性 $\\iota_{st}(v)$**\n\n电流介数中心性通过一个电路类比来分析，其中图的每条边都是一个电阻为 $R=1$ 的电阻器。在源顶点 $s$ 注入单位电流 $I_{\\text{total}} = 1$，并在汇顶点 $t$ 将其取出。量 $\\iota_{st}(v)$ 表示流经顶点 $v$ 的电流量。\n\n该电路可以看作是一组连接 $s$ 和 $t$ 的并联支路。\n1.  一条支路对应路径 $s \\to v \\to t$。它由两个串联的电阻器 $R_{sv}$ 和 $R_{vt}$ 组成。该支路的总电阻为 $R_{\\text{path},v} = R_{sv} + R_{vt} = 1+1=2$。\n2.  对于每个 $i \\in \\{1, 2, \\dots, m\\}$，都有一条支路对应路径 $s \\to a_i \\to b_i \\to t$。每条这样的支路由三个串联的电阻器 $R_{sa_i}$、$R_{a_ib_i}$ 和 $R_{b_it}$ 组成。这 $m$ 条支路中每条的总电阻为 $R_{\\text{path},i} = R_{sa_i} + R_{a_ib_i} + R_{b_it} = 1+1+1=3$。\n\n有 $m$ 条阻值为 $3$ 的相同路径并联。它们的组合等效电阻 $R_m$ 由以下公式给出：\n$$\n\\frac{1}{R_m} = \\sum_{i=1}^{m} \\frac{1}{R_{\\text{path},i}} = \\sum_{i=1}^{m} \\frac{1}{3} = \\frac{m}{3}\n$$\n因此，$R_m = \\frac{3}{m}$。这个等效电阻是涉及 $\\{a_i, b_i\\}$ 顶点的 $m$ 条并联路径块的电阻。整个块与经过 $v$ 的路径并联。\n\n$s$ 和 $t$ 之间电路的总有效电阻，记作 $R_{\\text{eff}}$，是 $R_{\\text{path},v}$ 和 $R_m$ 并联的等效电阻：\n$$\n\\frac{1}{R_{\\text{eff}}} = \\frac{1}{R_{\\text{path},v}} + \\frac{1}{R_m} = \\frac{1}{2} + \\frac{1}{3/m} = \\frac{1}{2} + \\frac{m}{3}\n$$\n合并各项可得：\n$$\n\\frac{1}{R_{\\text{eff}}} = \\frac{3 + 2m}{6} \\implies R_{\\text{eff}} = \\frac{6}{3 + 2m}\n$$\n根据欧姆定律，源点 $s$ 和汇点 $t$ 之间的电势差（电压）为 $\\Delta\\phi = \\phi_s - \\phi_t = I_{\\text{total}} \\times R_{\\text{eff}}$。由于 $I_{\\text{total}} = 1$，电势差就等于有效电阻：\n$$\n\\Delta\\phi = R_{\\text{eff}} = \\frac{6}{3 + 2m}\n$$\n这个电势差施加在所有并联支路上。流经包含顶点 $v$ 的支路的电流，我们称之为 $I_v$，可以用该支路的欧姆定律计算：\n$$\nI_v = \\frac{\\Delta\\phi}{R_{\\text{path},v}} = \\frac{6 / (3 + 2m)}{2} = \\frac{3}{3 + 2m}\n$$\n这个电流 $I_v$ 从 $s$ 流向 $v$，然后从 $v$ 流向 $t$。从 $s$ 进入顶点 $v$ 的电流等于从顶点 $v$ 流向 $t$ 的电流。这个吞吐量的大小被定义为顶点的电流介数中心性，$\\iota_{st}(v)$。\n因此：\n$$\n\\iota_{st}(v) = I_v = \\frac{3}{3 + 2m}\n$$\n\n**第三部分：比率 $R(m)$**\n\n最后一步是计算比率 $R(m) = \\frac{\\delta_{st}(v)}{\\iota_{st}(v)}$。\n代入前面部分计算出的值：\n$$\nR(m) = \\frac{1}{\\frac{3}{3 + 2m}}\n$$\n简化此表达式可得：\n$$\nR(m) = \\frac{3 + 2m}{3}\n$$\n这个表达式也可以写成 $1 + \\frac{2}{3}m$。$\\frac{3+2m}{3}$ 的形式是一个单一的简化有理表达式。",
            "answer": "$$\n\\boxed{\\frac{3+2m}{3}}\n$$"
        },
        {
            "introduction": "虽然解析推导对于简单图具有启发性，但对于更大、更复杂的网络，这种方法很快就变得不切实际。为了分析真实世界的系统，我们必须依赖计算方法。将引导您从理论走向应用，在二维网格图（一种常见的空间网络模型）上计算流边介数。通过这个练习，您将使用图拉普拉斯算子及其伪逆来实现标准的计算方法，这是一种植根于谱图理论的强大技术，对于实际的网络分析至关重要。",
            "id": "4263564",
            "problem": "考虑一个由 $m \\times n$ 矩形二维网格构成的有限、连通、无向、加权图 $G = (V,E)$。每个顶点 $v \\in V$ 对应一个整数坐标 $(r,c)$，其中 $0 \\leq r \\leq m-1$ 且 $0 \\leq c \\leq n-1$。每对曼哈顿距离为单位1的顶点（四邻域连通）由一条边 $(i,j) \\in E$ 连接，其单位电导为 $c_{ij} = 1$。令 $N = |V| = m \\cdot n$。固定网格内的一条边 $e = (u,v)$，其中 $u \\neq v$。\n\n使用图的电网络类比，定义两个不同顶点 $s,t \\in V$ 之间的电流如下：在 $s$ 处注入一个单位电流源，在 $t$ 处注入一个单位电流汇。由此产生的顶点电势函数 $\\phi : V \\to \\mathbb{R}$ 必须在每条边上满足基尔霍夫电流定律（KCL）和欧姆定律，所有存在的边的电导均为单位1。设图拉普拉斯算子 $L \\in \\mathbb{R}^{N \\times N}$ 定义为：若 $i \\neq j$ 且 $(i,j) \\in E$，则 $L_{ii} = \\sum_{j \\in \\mathcal{N}(i)} c_{ij}$ 且 $L_{ij} = -c_{ij}$；否则 $L_{ij} = 0$，其中 $\\mathcal{N}(i)$ 表示顶点 $i$ 的邻居。在 $(s,t)$ 注入下，流经固定边 $e=(u,v)$ 的电流是边流的绝对值，等于 $|c_{uv} \\cdot (\\phi_u - \\phi_v)|$。\n\n边 $e$ 的电流边介数 $C_e$ 定义为，当在 $s$ 处注入一单位电流并在 $t$ 处提取时，流经 $e$ 的绝对电流在所有 $s \\neq t$ 的无序对 $(s,t)$ 上的平均值。形式上，令 $\\mathcal{P} = \\{(s,t) \\in V \\times V : s  t\\}$ 表示所有无序的源-汇对。则\n$$\nC_e = \\frac{1}{|\\mathcal{P}|} \\sum_{(s,t) \\in \\mathcal{P}} \\left| c_{uv} \\cdot (\\phi_u^{(s,t)} - \\phi_v^{(s,t)}) \\right|,\n$$\n其中 $\\phi^{(s,t)}$ 是满足KCL和欧姆定律的电势向量，对应的注入向量 $b \\in \\mathbb{R}^N$ 定义为 $b_s = +1$，$b_t = -1$，对所有其他 $i \\in V$，$b_i = 0$。因为所有边的电导都是单位1，即 $c_{uv} = 1$，所以边电流简化为 $|\\phi_u^{(s,t)} - \\phi_v^{(s,t)}|$。\n\n您的任务是为指定的网格尺寸和指定的边计算 $C_e$，并报告其数值。除了计算 $C_e$ 之外，您应确保计算方法与上述物理定律一致，并在逻辑上基于图拉普拉斯算子的性质。在您的推理中，您也应准备好对边与网格边界的邻近程度如何影响 $C_e$ 提出定性解释，尽管程序将只输出数值。\n\n不需要物理单位，因为所有电导都是无量纲的，所有电流和电势都通过单位注入进行了一致的归一化定义。不涉及角度，也不需要百分比。\n\n测试套件（每个测试用例以 $(m,n,(r_u,c_u),(r_v,c_v))$ 的形式给出，边的端点以顶点坐标列出）：\n- 测试 1：$(3,3,(1,1),(1,2))$\n- 测试 2：$(5,5,(2,2),(2,3))$\n- 测试 3：$(5,5,(0,2),(0,3))$\n- 测试 4：$(7,7,(3,3),(4,3))$\n- 测试 5：$(2,2,(0,0),(0,1))$\n- 测试 6：$(4,6,(2,3),(2,4))$\n\n对于每个测试用例，您的程序必须计算电流边介数 $C_e$（一个实数 $C_e \\in \\mathbb{R}$），并生成一行输出，其中包含用方括号括起来的逗号分隔的浮点数列表。每个浮点数应四舍五入到八位小数。例如，输出格式应为 $[\\text{result}_1,\\text{result}_2,\\dots,\\text{result}_6]$，其中每个 $\\text{result}_k$ 是测试用例 $k$ 的 $C_e$ 值，四舍五入到八位小数。",
            "solution": "问题陈述经评估有效。它在科学上基于网络科学和电路理论的原理，在数学上是适定的，并且定义客观精确。唯一解所需的所有数据和定义都已提供。因此，我们可以着手提供完整解答。\n\n核心任务是为一个矩形网格图中指定的边 $e=(u,v)$ 计算电流边介数 $C_e$。该方法依赖于图的电学类比，其中顶点是节点，边是导体。\n\n首先，我们建立一个清晰的数学框架。该图是一个 $m \\times n$ 的网格。我们可以将每个由坐标 $(r,c)$（其中 $0 \\leq r  m$ 且 $0 \\leq c  n$）标识的顶点映射到一个唯一的整数索引 $i \\in \\{0, 1, \\dots, N-1\\}$，其中 $N=mn$。一个标准的行主序映射是 $i = r \\cdot n + c$。\n\n网络的电学行为由图拉普拉斯算子 $L \\in \\mathbb{R}^{N \\times N}$ 控制。对于边 $(i,j)$ 上电导为 $c_{ij}$ 的图，拉普拉斯算子定义为：\n$$\nL_{ij} = \\begin{cases}\n    \\sum_{k \\in \\mathcal{N}(i)} c_{ik}  \\text{若 } i = j \\\\\n    -c_{ij}  \\text{若 } i \\neq j \\text{ 且 } (i,j) \\in E \\\\\n    0  \\text{其他情况}\n\\end{cases}\n$$\n在这个问题中，所有边的电导都为单位1，即 $c_{ij}=1$。因此，对角线元素 $L_{ii}$ 等于顶点 $i$ 的度，而非对角线元素 $L_{ij}$ 在顶点 $i$ 和 $j$ 相邻时为 $-1$，否则为 $0$。\n\n当一个单位电流在源顶点 $s$ 注入并在汇顶点 $t$ 撤出时，顶点电势向量 $\\phi^{(s,t)} \\in \\mathbb{R}^N$ 是基尔霍夫电流定律的解，其矩阵形式为：\n$$ L\\phi^{(s,t)} = b^{(s,t)} $$\n这里，$b^{(s,t)}$ 是电流注入向量，定义为 $b_s = +1$，$b_t = -1$，对所有其他顶点 $k$，$b_k = 0$。\n\n对于连通图，拉普拉斯矩阵 $L$ 是奇异的，其一维零空间由全1向量 $\\mathbf{1}$ 张成。$L\\phi = b$ 有解当且仅当 $b$ 与零空间正交，即 $\\mathbf{1}^T b = \\sum b_i = 0$。我们的注入向量 $b^{(s,t)}$ 满足此条件，因为 $\\sum_k b_k = 1 - 1 = 0$。解 $\\phi^{(s,t)}$ 在一个加法常数（接地电势的选择）内是唯一的。然而，电势差，如 $\\phi_i - \\phi_j$，是唯一的且具有物理意义。\n\n为了求解电势，我们使用拉普拉斯算子的摩尔-彭若斯伪逆 $L^+$。该系统的唯一最小范数解由 $\\phi^{(s,t)} = L^+ b^{(s,t)}$ 给出。流经目标边 $e=(u,v)$ 的电流与其两端的电势差成正比。由于 $c_{uv}=1$，电流就是 $|\\phi_u^{(s,t)} - \\phi_v^{(s,t)}|$。\n\n边 $e=(u,v)$ 两端的电势差可以表示为：\n$$ \\phi_u^{(s,t)} - \\phi_v^{(s,t)} = (\\delta_u - \\delta_v)^T \\phi^{(s,t)} $$\n其中 $\\delta_k$ 是在索引 $k$ 处为1，其他位置为0的标准基向量。代入 $\\phi^{(s,t)}$ 和 $b^{(s,t)}$ 的表达式：\n$$ \\phi_u^{(s,t)} - \\phi_v^{(s,t)} = (\\delta_u - \\delta_v)^T L^+ (\\delta_s - \\delta_t) $$\n这个表达式揭示了一种强大的计算简化方法。我们不必为 $\\frac{N(N-1)}{2}$ 个源-汇对中的每一个求解一个线性系统，而是可以只计算一次 $L^+$。让我们定义一个与边 $e=(u,v)$ 相关联的向量 $y_e \\in \\mathbb{R}^N$：\n$$ y_e = L^+ (\\delta_u - \\delta_v) $$\n因为 $L$ 是实对称矩阵，所以它的伪逆 $L^+$ 也是实对称的。因此，我们可以将电势差写为：\n$$ \\phi_u^{(s,t)} - \\phi_v^{(s,t)} = (L^+(\\delta_u - \\delta_v))^T (\\delta_s - \\delta_t) = y_e^T (\\delta_s - \\delta_t) = y_{es} - y_{et} $$\n其中 $y_{ek}$ 表示向量 $y_e$ 的第 $k$ 个分量。\n\n电流边介数 $C_e$ 是在所有不同顶点的无序对 $(s,t)$ 上绝对电流的平均值。对于 $N(N-1)/2$ 个这样的对，公式为：\n$$ C_e = \\frac{1}{N(N-1)/2} \\sum_{0 \\le s  t  N} |\\phi_u^{(s,t)} - \\phi_v^{(s,t)}| = \\frac{2}{N(N-1)} \\sum_{0 \\le s  t  N} |y_{es} - y_{et}| $$\n\n这导出了针对每个测试用例的以下算法：\n1. 给定网格维度 $m$ 和 $n$，设置 $N=mn$。构建对应于具有单位电导的网格图的 $N \\times N$ 拉普拉斯矩阵 $L$。将使用映射 $i = r \\cdot n + c$ 把网格坐标与矩阵索引关联起来。\n2. 计算拉普拉斯矩阵的摩尔-彭若斯伪逆 $L^+$。\n3. 对于给定的边 $e=(u,v)$，由坐标 $(r_u,c_u)$ 和 $(r_v,c_v)$ 指定，确定它们的索引 $u_{idx}$ 和 $v_{idx}$。\n4. 构建向量 $x_e = \\delta_{u_{idx}} - \\delta_{v_{idx}}$。\n5. 计算向量 $y_e = L^+ x_e$。\n6. 初始化一个总和变量为零。遍历所有索引对 $(s, t)$，其中 $0 \\le s  t  N$，并累加绝对差之和 $\\sum |y_{es} - y_{et}|$。\n7. 将最终总和除以总对数 $N(N-1)/2$，得到 $C_e$。\n\n定性地看，电流边介数 $C_e$ 衡量了一条边对于网络中全局传输的重要性。位于网格中心的边必须为许多从网格一侧跨越到另一侧的节点对承载电流。相比之下，靠近边界或角落的边参与的长程路径较少，主要服务于局部电流。因此，可以预期中心位置的边的 $C_e$ 会显著高于边缘位置的边。这可以通过测试用例2（中心边）与测试用例3（边界边）在同一个 $5 \\times 5$ 网格上的对比得到例证，我们预计前者的 $C_e$ 将会大得多。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the current-flow edge betweenness for specified edges in grid graphs.\n\n    The solution proceeds as follows:\n    1. For each test case (m, n, u_coords, v_coords), the total number of vertices\n       N = m * n is determined.\n    2. A mapping from 2D grid coordinates (r, c) to a 1D vertex index is\n       defined as idx = r * n + c.\n    3. The graph Laplacian L is constructed for the m x n grid. For each vertex i,\n       we find its neighbors j (up, down, left, right). L[i, j] is set to -1,\n       and the diagonal L[i, i] is the degree of vertex i. All conductances are 1.\n    4. The Moore-Penrose pseudoinverse of the Laplacian, L+, is computed using\n       np.linalg.pinv(L).\n    5. An edge vector x_e is created for the target edge e = (u, v). This vector has\n       a +1 at index u and a -1 at index v.\n    6. A vector y_e = L+ @ x_e is computed. The current through edge e for a source-sink\n       pair (s, t) is given by |y_e[s] - y_e[t]|.\n    7. The current-flow edge betweenness C_e is calculated by summing these absolute\n       differences over all unique pairs of vertices (s, t) and dividing by the\n       total number of pairs, N * (N - 1) / 2.\n    8. The results for all test cases are collected and printed in the specified format.\n    \"\"\"\n    test_cases = [\n        (3, 3, (1, 1), (1, 2)),\n        (5, 5, (2, 2), (2, 3)),\n        (5, 5, (0, 2), (0, 3)),\n        (7, 7, (3, 3), (4, 3)),\n        (2, 2, (0, 0), (0, 1)),\n        (4, 6, (2, 3), (2, 4)),\n    ]\n\n    results = []\n    \n    for m, n, u_coords, v_coords in test_cases:\n        N = m * n\n\n        def coord_to_idx(r, c):\n            return r * n + c\n\n        laplacian = np.zeros((N, N), dtype=np.float64)\n\n        for r in range(m):\n            for c in range(n):\n                i = coord_to_idx(r, c)\n                degree = 0\n                # Neighbors\n                # Up\n                if r > 0:\n                    j = coord_to_idx(r - 1, c)\n                    laplacian[i, j] = -1.0\n                    degree += 1\n                # Down\n                if r  m - 1:\n                    j = coord_to_idx(r + 1, c)\n                    laplacian[i, j] = -1.0\n                    degree += 1\n                # Left\n                if c > 0:\n                    j = coord_to_idx(r, c - 1)\n                    laplacian[i, j] = -1.0\n                    degree += 1\n                # Right\n                if c  n - 1:\n                    j = coord_to_idx(r, c + 1)\n                    laplacian[i, j] = -1.0\n                    degree += 1\n                \n                laplacian[i, i] = float(degree)\n\n        laplacian_pinv = np.linalg.pinv(laplacian)\n\n        u_idx = coord_to_idx(u_coords[0], u_coords[1])\n        v_idx = coord_to_idx(v_coords[0], v_coords[1])\n\n        x_e = np.zeros(N, dtype=np.float64)\n        x_e[u_idx] = 1.0\n        x_e[v_idx] = -1.0\n\n        y_e = laplacian_pinv @ x_e\n\n        total_current_sum = 0.0\n        for s in range(N):\n            for t in range(s + 1, N):\n                total_current_sum += np.abs(y_e[s] - y_e[t])\n\n        num_pairs = N * (N - 1) / 2.0\n        c_e = total_current_sum / num_pairs\n        results.append(c_e)\n        \n    print(f\"[{','.join(f'{r:.8f}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}