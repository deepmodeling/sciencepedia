{
    "hands_on_practices": [
        {
            "introduction": "理论学习之后，我们通过一系列动手实践来巩固和深化理解。第一个练习将带领我们回到非线性动力学的基础，通过解析方法来研究逻辑斯谛映射 (logistic map) 的稳定性。我们将从最简单的吸引子——不动点——入手，推导其存在的条件，并通过线性稳定性分析来确定其稳定区间。这个练习的关键在于将不动点的线性稳定性（由导数 $|f'(x^*)|$ 决定）与李雅普诺夫指数 ($\\lambda = \\ln|f'(x^*)|$) 直接联系起来，从而为我们理解更复杂轨道上的指数发散奠定坚实的分析基础。",
            "id": "4263918",
            "problem": "考虑单位区间上的一维离散时间逻辑斯蒂映射 $x_{n+1} = a x_n (1 - x_n)$，其参数 $a \\in [0,4]$。从离散映射的不动点和线性稳定性的基本定义出发：不动点 $x^{\\ast}$ 满足 $f(x^{\\ast}) = x^{\\ast}$，其局部线性稳定性由导数的绝对值 $|f'(x^{\\ast})|$ 通过映射在 $x^{\\ast}$ 周围的线性化来确定。此外，使用离散时间映射的最大李雅普诺夫指数（MLE）的定义，记为 $\\lambda$，它通过相邻轨道的渐近指数分离率来量化对初始条件的敏感性。\n\n任务：\n1. 推导逻辑斯蒂映射的所有不动点 $x^{\\ast}$ 作为 $a$ 的函数，并说明每个不动点存在的参数条件。\n2. 使用线性化方法，确定使每个不动点线性稳定的参数集（$[0,4]$ 的子集）。\n3. 对于每个存在至少一个稳定不动点的参数值 $a$，使用标准的离散时间定义 $\\lambda = \\lim_{n \\to \\infty} \\frac{1}{n} \\sum_{k=0}^{n-1} \\ln |f'(x_k)|$，将 $\\lambda(a)$ 定义为在该 $a$ 值下所选的稳定不动点轨道的 MLE。\n4. 令 $S = \\{ a \\in [0,4] \\mid f \\text{ 存在一个线性稳定的不动点} \\}$。精确计算积分\n$$\nI = \\int_{a \\in S} \\lambda(a) \\, da\n$$\n。将您的答案表示为单个实数。无需四舍五入。",
            "solution": "给定逻辑斯蒂映射 $f(x) = a x (1 - x)$，参数 $a \\in [0,4]$。\n\n步骤1：不动点。不动点 $x^{\\ast}$ 满足 $f(x^{\\ast}) = x^{\\ast}$，即\n$$\na x^{\\ast} (1 - x^{\\ast}) = x^{\\ast}.\n$$\n整理得，\n$$\nx^{\\ast} \\left( a(1 - x^{\\ast}) - 1 \\right) = 0.\n$$\n因此，或者 $x^{\\ast} = 0$，或者 $a(1 - x^{\\ast}) - 1 = 0$。解后者可得\n$$\na(1 - x^{\\ast}) = 1 \\quad \\Rightarrow \\quad 1 - x^{\\ast} = \\frac{1}{a} \\quad \\Rightarrow \\quad x^{\\ast} = 1 - \\frac{1}{a}.\n$$\n因此，不动点为对所有 $a$ 都成立的 $x^{\\ast}_0 = 0$，以及在 $a \\neq 0$ 的条件下成立的 $x^{\\ast}_1 = 1 - \\frac{1}{a}$。在规范定义域 $a \\in [0,4]$ 上，两者都存在，但 $x^{\\ast}_1$ 要求 $a > 0$，并且当 $a \\geq 1$ 时它位于单位区间内，因为当 $a \\in [1,\\infty)$ 时 $x^{\\ast}_1 \\in [0,1]$。\n\n步骤2：通过导数判断线性稳定性。对于离散时间映射 $x_{n+1} = f(x_n)$，在不动点 $x^{\\ast}$ 附近的线性化动力学为 $\\delta_{n+1} \\approx f'(x^{\\ast}) \\delta_{n}$，其中 $\\delta_n$ 是一个小的微扰。如果不动点满足 $|f'(x^{\\ast})|  1$，则它是线性稳定的。\n\n首先计算 $f'(x) = a(1 - 2x)$。\n\n- 在 $x^{\\ast}_0 = 0$ 处：$f'(0) = a$。稳定性条件为 $|a|  1$。限制在 $a \\in [0,4]$ 内，得到稳定区间为 $a \\in [0,1)$。\n\n- 在 $x^{\\ast}_1 = 1 - \\frac{1}{a}$ 处：计算 $f'(x^{\\ast}_1)$，\n$$\nf'\\!\\left(1 - \\frac{1}{a}\\right) = a\\!\\left(1 - 2\\!\\left(1 - \\frac{1}{a}\\right)\\right) = a\\!\\left(1 - 2 + \\frac{2}{a}\\right) = a(-1) + 2 = 2 - a.\n$$\n稳定性条件 $|2 - a|  1$ 得到 $1  a  3$。这与存在条件 $a \\geq 1$ 一致，因此非平凡不动点 $x^{\\ast}_1$ 在 $a \\in (1,3)$ 上是稳定的。\n\n总结在 $[0,4]$ 内的稳定区间：\n- $x^{\\ast}_0$ 在 $a \\in [0,1)$ 上稳定。\n- $x^{\\ast}_1$ 在 $a \\in (1,3)$ 上稳定。\n在 $a = 1$ 和 $a = 3$ 时，不动点是临界的，在线性意义上不是严格稳定的。对于 $a \\in (3,4]$，两个不动点都不稳定，这与在分岔图中观察到的周期倍增级联和混沌动力学的出现相一致。\n\n定义具有稳定不动点的参数值集合：\n$$\nS = (0,1) \\cup (1,3).\n$$\n端点贡献的测度为零，不影响积分。\n\n步骤3：最大李雅普诺夫指数（MLE）。对于一维离散映射，沿轨道 $\\{x_n\\}$ 的最大李雅普诺夫指数（MLE）定义为\n$$\n\\lambda = \\lim_{n \\to \\infty} \\frac{1}{n} \\sum_{k=0}^{n-1} \\ln |f'(x_k)|.\n$$\n对于一个不动点轨道，即对所有 $n$ 都有 $x_n = x^{\\ast}$，导数因子是常数，MLE简化为\n$$\n\\lambda = \\ln |f'(x^{\\ast})|.\n$$\n因此，在每个稳定区间上，我们有：\n- 对于 $a \\in (0,1)$ (稳定的 $x^{\\ast}_0$)：$\\lambda(a) = \\ln |f'(0)| = \\ln a$，因为 $a > 0$。\n- 对于 $a \\in (1,3)$ (稳定的 $x^{\\ast}_1$)：$\\lambda(a) = \\ln |f'(x^{\\ast}_1)| = \\ln |2 - a|$。\n\n我们需要计算\n$$\nI = \\int_{a \\in S} \\lambda(a) \\, da = \\int_{0}^{1} \\ln a \\, da + \\int_{1}^{3} \\ln |2 - a| \\, da.\n$$\n\n步骤4：计算积分。\n\n第一个积分：\n$$\n\\int_{0}^{1} \\ln a \\, da = \\left[ a \\ln a - a \\right]_{0}^{1} = \\left( 1 \\cdot \\ln 1 - 1 \\right) - \\lim_{a \\to 0^{+}} \\left( a \\ln a - a \\right) = (0 - 1) - (0 - 0) = -1.\n$$\n\n第二个积分，在 $a = 2$ 处拆分以处理绝对值：\n$$\n\\int_{1}^{3} \\ln |2 - a| \\, da = \\int_{1}^{2} \\ln(2 - a) \\, da + \\int_{2}^{3} \\ln(a - 2) \\, da.\n$$\n对于第一部分，令 $u = 2 - a$，则 $du = -da$。当 $a$ 从 $1$ 变到 $2$ 时，$u$ 从 $1$ 变到 $0$：\n$$\n\\int_{1}^{2} \\ln(2 - a) \\, da = \\int_{1}^{0} \\ln u \\, (-du) = \\int_{0}^{1} \\ln u \\, du = \\left[ u \\ln u - u \\right]_{0}^{1} = -1.\n$$\n对于第二部分，令 $v = a - 2$，则 $dv = da$。当 $a$ 从 $2$ 变到 $3$ 时，$v$ 从 $0$ 变到 $1$：\n$$\n\\int_{2}^{3} \\ln(a - 2) \\, da = \\int_{0}^{1} \\ln v \\, dv = \\left[ v \\ln v - v \\right]_{0}^{1} = -1.\n$$\n因此，\n$$\n\\int_{1}^{3} \\ln |2 - a| \\, da = -1 + (-1) = -2.\n$$\n\n合并结果，\n$$\nI = \\int_{0}^{1} \\ln a \\, da + \\int_{1}^{3} \\ln |2 - a| \\, da = -1 + (-2) = -3.\n$$\n\n解释：积分 $I$ 汇集了在集合 $S$ 中所有参数值下稳定不动点的最大李雅普诺夫指数。其负值反映了在这些参数区域内的平均收缩（对初始条件不敏感），而边界 $a = 1$ 和 $a = 3$ 标志着局部分岔阈值，在这些阈值处，稳定性分别通过 $a=1$ 处的类跨临界交换和 $a=3$ 处的翻转（周期倍增）分岔而丧失。",
            "answer": "$$\\boxed{-3}$$"
        },
        {
            "introduction": "掌握了不动点的解析分析后，我们转向更普遍的情况，特别是当系统进入混沌状态时，解析方法往往难以奏效。本练习旨在通过编写程序，从第一性原理出发，数值化地估算逻辑斯谛映射的最大李雅普诺夫指数。我们将实现一个数值稳定的算法，它通过对轨道上局部拉伸率的对数进行平均来计算李雅普诺夫指数，这个方法巧妙地避免了直接计算连乘积所导致的浮点数溢出问题。通过这个实践，你不仅能掌握一个研究任何一维映射的核心计算工具，还能学会如何评估数值结果的收敛性和对初始参数的敏感性。",
            "id": "4263792",
            "problem": "实现一个程序，纯粹基于对初始条件敏感性的第一性原理，估算一维逻辑斯谛映射的最大李雅普诺夫指数。逻辑斯谛映射由递推关系 $x_{n+1} = a\\,x_n\\,(1 - x_n)$ 定义，其定义域为区间 $[0,1]$，控制参数 $a \\in [0,4]$。从对初始条件的敏感性定义和映射的可微性出发：如果一个可微映射 $f$ 控制着演化过程 $x_{n+1} = f(x_n)$，那么两个相邻轨道间的微小扰动 $\\delta_n$ 将根据局域线性化进行演化。以此为基本依据，推导出一个算法来估算逻辑斯谛映射轨道上的指数分离率，从而得到最大李雅普诺夫指数。\n\n您的实现要求如下。\n\n- 您必须设计一个数值稳定的算法来估算最大李雅普诺夫指数，该算法需要：\n  - 对给定的参数 $a$、初始条件 $x_0 \\in (0,1)$、总迭代长度 $N$ 和暂态截断长度 $T$（其中 $0 \\leq T  N$），迭代逻辑斯谛映射 $x_{n+1} = a\\,x_n\\,(1 - x_n)$。\n  - 在累积任何与局域扩张率相关的量相关的量之前，丢弃前 $T$ 次迭代的结果。\n  - 以避免数值上溢、下溢和未定义操作的方式累积局域扩张率。必须通过适当的数值保护措施来避免任何不可避免的奇点（例如，计算零的对数），这些措施不应使渐近估计产生偏差（例如，通过使用一个非常小的正阈值 $\\varepsilon$ 来限制任何因子的大小使其远离零，并在需要时使用一个微小的 $\\varepsilon_x$ 将 $x_n$ 保持在 $(0,1)$ 内）。\n  - 对于给定的 $(a,x_0,N,T)$，返回最大李雅普诺夫指数的单个浮点估计值。\n\n- 收敛性与敏感性分析：\n  - 对于下方的每个测试用例，计算四个量：\n    1. 使用给定 $(a,x_0,N,T)$ 的基准估计值。\n    2. 基准估计值与使用相同 $(a,N,T)$ 但初始条件有轻微扰动 $x_0'$ 所得估计值之间的绝对差，用以量化指数估计值本身对初始条件的不敏感性。\n    3. 基准估计值与使用 $(a,x_0,2N,T)$ 所得估计值之间的绝对差，用以量化随平均长度增加的收敛性。\n    4. 基准估计值与使用 $(a,x_0,N,2T)$ 所得估计值之间的绝对差，用以量化对暂态截断长度的敏感性。\n  - 这四个量中的每一个都必须报告为四舍五入到 $6$ 位小数的浮点数。\n\n- 测试套件：\n  - 使用以下五个参数集，每个参数集指定为 $(a, x_0, x_0', N, T)$：\n    - 用例 1：$(a = 2.5,\\; x_0 = 0.123456789,\\; x_0' = 0.123456788,\\; N = 20000,\\; T = 1000)$。\n    - 用例 2：$(a = 3.2,\\; x_0 = 0.123456789,\\; x_0' = 0.223456789,\\; N = 40000,\\; T = 2000)$。\n    - 用例 3：$(a = 3.569945672,\\; x_0 = 0.101010101,\\; x_0' = 0.101010100,\\; N = 120000,\\; T = 10000)$。\n    - 用例 4：$(a = 3.8,\\; x_0 = 0.314159265,\\; x_0' = 0.314159260,\\; N = 60000,\\; T = 5000)$。\n    - 用例 5：$(a = 4.0,\\; x_0 = 0.271828182,\\; x_0' = 0.271828180,\\; N = 60000,\\; T = 5000)$。\n\n- 最终输出规格：\n  - 对于每个用例，输出一个包含四个浮点数的列表 $[b, d_0, d_N, d_T]$，四舍五入到 $6$ 位小数，其中：\n    - $b$ 是针对 $(a,x_0,N,T)$ 的基准最大李雅普诺夫指数估计值。\n    - $d_0$ 是基准估计值与针对 $(a,x_0',N,T)$ 的估计值之间的绝对差。\n    - $d_N$ 是基准估计值与针对 $(a,x_0,2N,T)$ 的估计值之间的绝对差。\n    - $d_T$ 是基准估计值与针对 $(a,x_0,N,2T)$ 的估计值之间的绝对差。\n  - 您的程序应生成单行输出，其中包含所有五个用例的结果，形式为一个用方括号括起来的逗号分隔列表，其中每个元素本身就是该用例的四元数列表。数值条目必须四舍五入到 $6$ 位小数。例如，整体格式应为\n    $$[[b_1,d_{0,1},d_{N,1},d_{T,1}],[b_2,d_{0,2},d_{N,2},d_{T,2}],[b_3,d_{0,3},d_{N,3},d_{T,3}],[b_4,d_{0,4},d_{N,4},d_{T,4}],[b_5,d_{0,5},d_{N,5},d_{T,5}]].$$",
            "solution": "本问题要求实现一个从第一性原理推导出的算法，用于估算一维逻辑斯谛映射的最大李雅普诺夫指数。\n\n**1. 从第一性原理推导**\n\n逻辑斯谛映射由以下迭代方程定义：\n$$x_{n+1} = f(x_n) = a x_n (1 - x_n)$$\n其中 $x_n$ 是系统在区间 $[0, 1]$ 上第 $n$ 步的状态，$a$ 是范围在 $[0, 4]$ 内的控制参数。\n\n最大李雅普诺夫指数 $\\lambda$ 量化了相邻轨道发散或收敛的平均指数率。为推导其公式，考虑从无限接近的初始条件 $x_0$ 和 $x_0' = x_0 + \\delta_0$（其中 $|\\delta_0|$ 非常小）开始的两条轨道。\n\n经过一次迭代，两条轨道之间的分离变为：\n$$\\delta_1 = x_1' - x_1 = f(x_0 + \\delta_0) - f(x_0)$$\n对于无限小的 $\\delta_0$，我们可以使用 $f(x)$ 在 $x_0$ 附近的一阶泰勒级数展开：\n$$f(x_0 + \\delta_0) \\approx f(x_0) + f'(x_0)\\delta_0$$\n其中 $f'(x)$ 是 $f(x)$ 对 $x$ 的导数。将此代入 $\\delta_1$ 的表达式中，得到：\n$$\\delta_1 \\approx (f(x_0) + f'(x_0)\\delta_0) - f(x_0) = f'(x_0)\\delta_0$$\n这表明初始分离 $\\delta_0$ 在一次迭代后被拉伸或压缩了因子 $f'(x_0)$。\n\n经过 $n$ 次迭代后，状态由映射的第 $n$ 次复合给出，$x_n = f^n(x_0)$。轨道之间的分离 $\\delta_n = f^n(x_0+\\delta_0) - f^n(x_0)$ 可以通过重复应用局域线性化与初始分离 $\\delta_0$ 关联起来。第 $n$ 次迭代映射的导数 $(f^n)'(x_0)$ 使用链式法则求得：\n$$(f^n)'(x_0) = \\frac{d}{dx}f(f(...f(x)...))|_{x=x_0} = f'(x_{n-1}) f'(x_{n-2}) \\cdots f'(x_0) = \\prod_{i=0}^{n-1} f'(x_i)$$\n其中 $x_i = f^i(x_0)$。因此，经过 $n$ 步后的分离为：\n$$\\delta_n \\approx (f^n)'(x_0) \\delta_0 = \\left(\\prod_{i=0}^{n-1} f'(x_i)\\right) \\delta_0$$\n分离的大小演化为 $|\\delta_n| \\approx |\\delta_0| \\prod_{i=0}^{n-1} |f'(x_i)|$。\n\n李雅普诺夫指数 $\\lambda$ 定义为指数分离率的长期平均值：\n$$\\lambda = \\lim_{n \\to \\infty} \\frac{1}{n} \\ln\\left|\\frac{\\delta_n}{\\delta_0}\\right|$$\n代入分离比的表达式，得到：\n$$\\lambda = \\lim_{n \\to \\infty} \\frac{1}{n} \\ln\\left|\\prod_{i=0}^{n-1} f'(x_i)\\right|$$\n利用对数性质 $\\ln(\\prod_i A_i) = \\sum_i \\ln(A_i)$，我们得到李雅普诺夫指数的基本公式：\n$$\\lambda = \\lim_{n \\to \\infty} \\frac{1}{n} \\sum_{i=0}^{n-1} \\ln|f'(x_i)|$$\n这表明 $\\lambda$ 是映射导数绝对值的对数沿轨道的时间平均值。\n\n**2. 算法构建与数值稳定性**\n\n对于逻辑斯谛映射 $f(x) = a x (1 - x)$，其导数为：\n$$f'(x) = a - 2ax = a(1 - 2x)$$\n$\\lambda$ 的数值估计可以通过对有限次迭代 $N$ 进行平均来计算。为确保估计值反映的是吸引子上的行为而非初始暂态动力学，前 $T$ 次迭代被丢弃。然后，数值估计值 $\\hat{\\lambda}$ 在随后的 $N-T$ 次迭代上计算：\n$$\\hat{\\lambda} = \\frac{1}{N-T} \\sum_{i=T}^{N-1} \\ln|a(1-2x_i)|$$\n这种形式是数值稳定的。直接计算乘积 $\\prod |f'(x_i)|$ 会在 $N$ 很大时导致浮点数上溢或下溢。对对数求和可以避免这个问题。\n\n如果某个迭代值 $x_i$ 恰好等于 $0.5$，就会出现一个潜在的数值问题。在这种情况下，$f'(x_i) = a(1-2 \\cdot 0.5) = 0$，而 $\\ln(0)$ 是未定义的。虽然在连续动力学中精确达到这一点的概率可以忽略不计，但在有限精度运算中它可能发生，或者值可能非常接近于零。为防止这种情况，正如问题所建议的，我们实现一个数值保护措施，即在对数的参数上加上一个非常小的正常数 $\\varepsilon$。我们选择 $\\varepsilon = 10^{-12}$。求和项变为 $\\ln(|a(1-2x_i)| + \\varepsilon)$。这可以防止计算失败，并且如果此类事件很少发生，引入的偏差也可以忽略不计。\n\n算法如下：\n1.  用初始条件 $x_0$ 初始化状态 $x$。\n2.  迭代映射 $T$ 次，每一步更新 $x \\leftarrow a x (1 - x)$，以丢弃暂态行为。\n3.  初始化一个求和变量 `log_sum` 为 $0$。\n4.  再迭代 $N-T$ 步（从 $i=T$到$N-1$）：\n    a. 计算导数：$d = a(1 - 2x)$。\n    b. 将其绝对值的受保护对数加到总和中：`log_sum += np.log(np.abs(d) + epsilon)`。\n    c. 为下一次迭代更新状态：$x \\leftarrow a x (1 - x)$。\n5.  李雅普诺夫指数的估计值为 `log_sum / (N - T)`。\n\n这个过程被封装在一个以 $(a, x_0, N, T)$ 为输入的函数中。对于每个测试用例，这个函数会用不同的参数调用四次，以计算基准估计值并执行所需的敏感性分析。然后计算绝对差，并将所有结果四舍五入到 $6$ 位小数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef estimate_lyapunov(a: float, x0: float, N: int, T: int) -> float:\n    \"\"\"\n    Estimates the largest Lyapunov exponent for the logistic map.\n\n    Args:\n        a (float): The control parameter of the logistic map.\n        x0 (float): The initial condition.\n        N (int): The total number of iterations.\n        T (int): The number of transient iterations to discard.\n\n    Returns:\n        float: The estimated largest Lyapunov exponent.\n    \"\"\"\n    # A small positive constant to avoid log(0)\n    epsilon = 1e-12\n    \n    x = x0\n    \n    # Discard the first T transient iterations\n    for _ in range(T):\n        x = a * x * (1.0 - x)\n        \n    log_sum = 0.0\n    \n    # Iterate for N-T steps to accumulate the sum of logarithms of derivatives\n    num_sum_terms = N - T\n    for _ in range(num_sum_terms):\n        # The derivative of the logistic map f(x) = ax(1-x) is f'(x) = a(1-2x)\n        derivative = a * (1.0 - 2.0 * x)\n        \n        # Add the safeguarded logarithm of the absolute value of the derivative\n        log_sum += np.log(np.abs(derivative) + epsilon)\n        \n        # Update the state to the next iteration\n        x = a * x * (1.0 - x)\n        \n    # The Lyapunov exponent is the average of the log-derivatives\n    return log_sum / num_sum_terms\n\ndef solve():\n    \"\"\"\n    Main function to run the analysis for all test cases and print the results.\n    \"\"\"\n    \n    # Test cases defined as (a, x0, x0', N, T)\n    test_cases = [\n        (2.5, 0.123456789, 0.123456788, 20000, 1000),\n        (3.2, 0.123456789, 0.223456789, 40000, 2000),\n        (3.569945672, 0.101010101, 0.101010100, 120000, 10000),\n        (3.8, 0.314159265, 0.314159260, 60000, 5000),\n        (4.0, 0.271828182, 0.271828180, 60000, 5000)\n    ]\n\n    all_results = []\n\n    for a, x0, x0_prime, N, T in test_cases:\n        # 1. Baseline estimate\n        b = estimate_lyapunov(a, x0, N, T)\n\n        # 2. Sensitivity to initial condition\n        b_prime = estimate_lyapunov(a, x0_prime, N, T)\n        d0 = abs(b - b_prime)\n\n        # 3. Convergence with iteration length\n        b_2N = estimate_lyapunov(a, x0, 2 * N, T)\n        dN = abs(b - b_2N)\n\n        # 4. Sensitivity to transient cut length\n        # Ensure 2*T is less than N\n        if 2 * T >= N:\n            # This case should not occur with the given test suite, but is a safeguard.\n            dT = np.nan\n        else:\n            b_2T = estimate_lyapunov(a, x0, N, 2 * T)\n            dT = abs(b - b_2T)\n        \n        # Collect results for this case\n        case_results = [\n            round(b, 6),\n            round(d0, 6),\n            round(dN, 6),\n            round(dT, 6)\n        ]\n        all_results.append(case_results)\n\n    # Format the final output string as specified\n    final_output_string = str(all_results).replace(\" \", \"\")\n    print(final_output_string)\n\n# Execute the main function\nsolve()\n```"
        },
        {
            "introduction": "在掌握了单个动力系统的分析方法后，我们将挑战一个更复杂且与本领域核心主题紧密相关的场景：耦合动力系统网络。本练习将引导你分析网络上同步现象的稳定性，这是一个典型的复杂系统涌现行为。你将学习到，同步的稳定性并非由单个节点的混沌行为（由其自身的李雅普诺夫指数决定）直接决定，而是由所谓的“横向李雅普诺夫指数”控制，它耦合了局域动力学、耦合强度以及网络拓扑结构（通过拉普拉斯算子的特征值）三者的影响。通过完成这个练习，你将能够把对单个系统动力学的理解扩展到对复杂网络集体行为的分析中，并掌握一种识别网络中关键节点（如“起搏器”或“去同步器”）的实用方法。",
            "id": "4263814",
            "problem": "考虑一个由 $N$ 个相同的离散时间动力学单元组成的网络，每个单元都由 logistic 映射 $f(x) = r x (1 - x)$ 控制，并通过一个无向图进行扩散耦合。设 $A \\in \\mathbb{R}^{N \\times N}$ 为对称邻接矩阵（如果节点 $i$ 和 $j$ 连接，则 $A_{ij} = 1$，否则 $A_{ij} = 0$），并设 $D$ 为对角度矩阵，其中 $D_{ii} = \\sum_{j} A_{ij}$。组合拉普拉斯算子为 $L = D - A$。网络动力学定义为\n$$\nx_i(t+1) = f\\big(x_i(t)\\big) + \\varepsilon \\sum_{j=1}^N A_{ij}\\left(f\\big(x_j(t)\\big) - f\\big(x_i(t)\\big)\\right),\n$$\n其中 $x_i(t) \\in (0,1)$ 是节点 $i$ 在整数时间 $t \\ge 0$ 时的状态，$r \\in (0,4]$ 是 logistic 参数，$\\varepsilon \\ge 0$ 是扩散耦合强度。\n\n同步轨道是由 $x_1(t) = x_2(t) = \\cdots = x_N(t) = s_t$ 对所有 $t$ 定义的不变流形，其中 $s_{t+1} = f(s_t)$。同步的稳定性由与 $L$ 的非零特征值相关的横向模式控制。对于每个非零的拉普拉斯特征值，相应的横向模式有一个时变线性乘子，该乘子由沿同步轨道计算的耦合映射的雅可比矩阵确定。最大横向李雅普诺夫指数表征了垂直于同步流形的无穷小扰动的平均指数增长率。当 $r$ 处于混沌区域时，同步轨道 $s_t$ 会出现对初始条件的敏感性，这通过时变乘子影响横向李雅普诺夫指数。\n\n您的任务是针对每个提供的测试用例，以编程方式估算：\n1. 同步状态的最大横向李雅普诺夫指数（基于对角化 $L$ 并沿 $s_t$ 对线性化横向乘子大小的对数进行数值时间平均）。\n2. 在以下操作性定义下，充当起搏器的节点索引集和充当去同步器的节点索引集：\n   - 对于每个节点 $k$，移除节点 $k$ 及其所有入射边，形成一个维度为 $(N-1) \\times (N-1)$ 的简化网络，其邻接矩阵为 $A^{(-k)}$，拉普拉斯算子为 $L^{(-k)}$。使用相同的 $r$ 和 $\\varepsilon$ 以及限制在简化网络上的同步轨道 $s_t$，重新计算简化网络的最大横向李雅普诺夫指数。令 $\\Delta_k$ 表示简化网络的最大横向李雅普诺夫指数与原始网络的最大横向李雅普诺夫指数之差。\n   - 如果 $\\Delta_k$ 严格大于一个数值容差，则节点 $k$ 被分类为起搏器，这表明移除 $k$ 会增加不稳定性（即 $k$ 的原始存在有助于稳定同步）。\n   - 如果 $\\Delta_k$ 严格小于一个数值容差，则节点 $k$ 被分类为去同步器，这表明移除 $k$ 会降低不稳定性（即 $k$ 的原始存在有助于破坏同步的稳定性）。\n   - 如果 $|\\Delta_k|$ 在数值容差范围内，则不将 $k$ 分类为起搏器或去同步器。\n\n使用同步轨道的初始条件 $s_0 = 0.5$。同步轨道总共使用 $T = 5000$ 次迭代，并丢弃前 $T_{\\mathrm{trans}} = 1000$ 次迭代作为暂态。在对乘子取对数时，通过在取对数前将任何乘子的绝对值下限设为 $10^{-12}$ 来稳健地处理数值下溢。\n\n所有数值均为无量纲。不涉及角度。所有输出必须是数值浮点数或整数。\n\n测试套件：\n- 案例1：\n  - 网络：$N=5$，循环图 $C_5$，其邻接矩阵为\n    $$\n    A = \\begin{bmatrix}\n    0  1  0  0  1 \\\\\n    1  0  1  0  0 \\\\\n    0  1  0  1  0 \\\\\n    0  0  1  0  1 \\\\\n    1  0  0  1  0 \\\\\n    \\end{bmatrix}\n    $$\n  - Logistic 参数：$r = 3.8$\n  - 耦合强度：$\\varepsilon = 0.1$\n- 案例2：\n  - 网络：$N=6$，循环图 $C_6$，其邻接矩阵为\n    $$\n    A = \\begin{bmatrix}\n    0  1  0  0  0  1 \\\\\n    1  0  1  0  0  0 \\\\\n    0  1  0  1  0  0 \\\\\n    0  0  1  0  1  0 \\\\\n    0  0  0  1  0  1 \\\\\n    1  0  0  0  1  0 \\\\\n    \\end{bmatrix}\n    $$\n  - Logistic 参数：$r = 3.9$\n  - 耦合强度：$\\varepsilon = 0.2$\n- 案例3：\n  - 网络：$N=8$，完全图 $K_8$，其邻接矩阵为 $A_{ij} = 1$ 对 $i \\ne j$ 且 $A_{ii} = 0$ 对所有 $i$。\n  - Logistic 参数：$r = 3.6$\n  - 耦合强度：$\\varepsilon = 0.05$\n\n答案规格：\n- 对每个案例，估算最大横向李雅普诺夫指数，作为浮点数并四舍五入到六位小数。\n- 对每个案例，返回两个整数列表：起搏器节点索引和去同步器节点索引。索引必须按升序排列并使用从零开始的索引。\n- 您的程序应生成单行输出，其中包含所有案例的结果，形式为一个用方括号括起来的逗号分隔列表，每个案例的结果是列表\n  $[ \\text{max\\_exponent}, [\\text{pacemakers}], [\\text{desynchronizers}] ]$。\n- 例如，最终输出格式应为\n  $[[x_1,[p_1],[d_1]],[x_2,[p_2],[d_2]],[x_3,[p_3],[d_3]]]$，不含空格。",
            "solution": "用户提供的问题已经过分析和验证。\n\n### 步骤1：提取给定信息\n- **动力系统**：一个由 $N$ 个相同的离散时间单元组成的网络。\n- **单元动力学**：Logistic 映射，$f(x) = r x (1 - x)$，状态为 $x_i(t) \\in (0,1)$，参数为 $r \\in (0,4]$。\n- **网络耦合**：在具有对称邻接矩阵 $A$ 的无向图上进行扩散耦合。\n- **耦合映射方程**：\n$$x_i(t+1) = f\\big(x_i(t)\\big) + \\varepsilon \\sum_{j=1}^N A_{ij}\\left(f\\big(x_j(t)\\big) - f\\big(x_i(t)\\big)\\right)$$\n- **参数**：耦合强度 $\\varepsilon \\ge 0$。\n- **矩阵**：邻接矩阵 $A$，度矩阵 $D$ 其中 $D_{ii} = \\sum_j A_{ij}$，以及组合拉普拉斯算子 $L = D - A$。\n- **同步状态**：一个不变流形，其中 $x_1(t) = x_2(t) = \\cdots = x_N(t) = s_t$，其轨迹由 $s_{t+1} = f(s_t)$ 控制。\n- **初始条件**：同步轨道从 $s_0 = 0.5$ 开始。\n- **数值积分**：总迭代次数 $T = 5000$，丢弃的暂态迭代次数 $T_{\\mathrm{trans}} = 1000$。\n- **数值稳定性**：对于任何值 $v$，对数计算为 $\\ln(\\max(|v|, 10^{-12}))$。\n- **节点分类任务**：\n  - 对每个节点 $k$，通过移除节点 $k$ 及其边来形成一个简化网络。\n  - 计算原始网络的最大横向李雅普诺夫指数（$\\Lambda_{\\text{max}}^{\\text{orig}}$）和每个简化网络的最大横向李雅普诺夫指数（$\\Lambda_{\\text{max}}^{(-k)}$）。\n  - 计算差值 $\\Delta_k = \\Lambda_{\\text{max}}^{(-k)} - \\Lambda_{\\text{max}}^{\\text{orig}}$。\n  - 如果 $\\Delta_k > \\tau$（$\\tau$ 是一个数值容差），则节点 $k$ 是一个**起搏器**。\n  - 如果 $\\Delta_k  -\\tau$，则节点 $k$ 是一个**去同步器**。\n- **测试用例**：\n  1. $N=5$ 循环图 ($C_5$)，$r=3.8$，$\\varepsilon=0.1$。\n  2. $N=6$ 循环图 ($C_6$)，$r=3.9$，$\\varepsilon=0.2$。\n  3. $N=8$ 完全图 ($K_8$)，$r=3.6$，$\\varepsilon=0.05$。\n\n### 步骤2：使用提取的给定信息进行验证\n根据验证标准对问题进行评估：\n- **科学依据**：网络上的耦合 logistic 映射模型是复杂系统、非线性动力学和网络科学研究中的一个典型例子。同步稳定性、横向李雅普诺夫指数以及网络结构的作用等概念是公认的科学原理。该问题在科学上是合理的。\n- **适定性**：问题为计算所有必需量提供了清晰、确定性的程序。输入数据（$A$, $r$, $\\varepsilon$）是充分的，起搏器/去同步器的定义明确，可以得出唯一解。\n- **客观性**：问题以精确的数学和算法术语陈述，没有任何主观或基于意见的语言。\n- **其他标准**：问题可形式化，与指定主题相关，设置完整且一致，使用现实的参数值，结构良好，并且并非微不足道。\n\n### 步骤3：结论与行动\n该问题是**有效的**。将提供一个合理的解决方案。\n\n### 基于原理的解决方案\n\n该解决方案涉及分析耦合映射网络中同步状态的稳定性。这是通过计算最大横向李雅普诺夫指数来实现的。\n\n**1. 系统动力学与同步**\n\n网络在离散时间 $t$ 的状态由向量 $\\vec{x}(t) = [x_1(t), \\dots, x_N(t)]^T$ 给出。控制方程可以写成紧凑的向量形式。项 $\\sum_{j=1}^N A_{ij}(f(x_j(t)) - f(x_i(t)))$ 是 $(A-D)F(\\vec{x}(t)) = -LF(\\vec{x}(t))$ 的第 $i$ 个分量，其中 $F(\\vec{x}(t))$ 是将 $f(x)$ 逐元素应用于向量 $\\vec{x}(t)$。因此，系统动力学为：\n$$\n\\vec{x}(t+1) = F(\\vec{x}(t)) - \\varepsilon L F(\\vec{x}(t)) = (I - \\varepsilon L) F(\\vec{x}(t))\n$$\n其中 $I$ 是 $N \\times N$ 的单位矩阵。\n\n同步流形是所有节点状态都相同的子空间，即对所有 $i \\in \\{1, \\dots, N\\}$ 都有 $x_i(t) = s_t$。在此流形上，$F(\\vec{s}_t) = f(s_t) \\vec{1}$，其中 $\\vec{1}$ 是全一向量。由于 $L\\vec{1} = \\vec{0}$，动力学简化为 $\\vec{x}(t+1) = f(s_t)\\vec{1} - \\varepsilon L (f(s_t)\\vec{1}) = f(s_t)\\vec{1}$。这证实了如果系统从同步流形开始，它将一直停留在那里，状态根据单个 logistic 映射 $s_{t+1} = f(s_t)$ 演化。\n\n**2. 横向稳定性与李雅普诺夫指数**\n\n为评估此同步状态的稳定性，我们考虑一个偏离同步轨道的小扰动 $\\vec{\\delta}(t)$：$\\vec{x}(t) = \\vec{s}_t + \\vec{\\delta}(t)$。扰动的演化由围绕 $\\vec{s}_t$ 的映射的线性化控制：\n$$\n\\vec{\\delta}(t+1) \\approx J_t \\vec{\\delta}(t)\n$$\n映射 $\\vec{G}(\\vec{x}) = (I - \\varepsilon L)F(\\vec{x})$ 在 $\\vec{s}_t$ 处的雅可比矩阵 $J_t$ 是：\n$$\nJ_t = (I - \\varepsilon L) F'(\\vec{s}_t) = (I - \\varepsilon L) \\cdot \\text{diag}(f'(s_t), \\dots, f'(s_t)) = f'(s_t)(I - \\varepsilon L)\n$$\n其中 $f'(s_t) = r(1 - 2s_t)$。\n\n通过使用拉普拉斯矩阵 $L$ 的特征基，可以简化稳定性分析。由于 $L$ 是实对称矩阵，它有 $N$ 个实特征值 $\\lambda_1, \\dots, \\lambda_N$ 和一组对应的标准正交特征向量 $\\vec{v}_1, \\dots, \\vec{v}_N$。这些特征向量也是雅可比矩阵 $J_t$ 的特征向量：\n$$\nJ_t \\vec{v}_i = f'(s_t)(I - \\varepsilon L)\\vec{v}_i = f'(s_t)(1 - \\varepsilon \\lambda_i)\\vec{v}_i\n$$\n与模式 $\\vec{v}_i$ 对应的 $J_t$ 的特征值是时变乘子 $\\mu_i(t) = f'(s_t)(1 - \\varepsilon \\lambda_i)$。\n\n任何图的拉普拉斯算子都至少有一个特征值 $\\lambda_1 = 0$，其特征向量 $\\vec{v}_1 \\propto \\vec{1}$ 张成了同步流形。沿此方向的扰动不影响同步。稳定性由*横向*模式决定，这些模式对应于所有非零特征值 $\\lambda_i \\neq 0$。\n\n每个模式 $\\vec{v}_i$ 的李雅普诺夫指数衡量了沿该方向扰动的平均指数增长率：\n$$\n\\Lambda_i = \\lim_{M \\to \\infty} \\frac{1}{M} \\sum_{t=0}^{M-1} \\ln |\\mu_i(t)| = \\lim_{M \\to \\infty} \\frac{1}{M} \\sum_{t=0}^{M-1} \\ln |f'(s_t)(1 - \\varepsilon \\lambda_i)|\n$$\n利用对数的性质，这可以分为两部分：\n$$\n\\Lambda_i = \\ln|1 - \\varepsilon \\lambda_i| + \\left\\langle \\ln|f'(s_t)| \\right\\rangle_t\n$$\n其中 $\\left\\langle \\cdot \\right\\rangle_t$ 表示时间平均。第二项是孤立 logistic 映射的李雅普诺夫指数，$\\Lambda_0$。\n\n同步状态的整体稳定性由最不稳定的横向模式决定。因此，最大横向李雅普诺夫指数为：\n$$\n\\Lambda_{\\text{max}} = \\max_{i : \\lambda_i \\neq 0} \\Lambda_i\n$$\n如果 $\\Lambda_{\\text{max}}  0$，则同步状态是稳定的。\n\n**3. 计算算法**\n\n对于每个测试用例 $(A, r, \\varepsilon)$，算法如下：\n\n1.  **生成同步轨道**：从 $s_0=0.5$ 开始，使用 $s_{t+1} = r s_t(1-s_t)$ 生成长度为 $T=5000$ 的时间序列 $s_t$。同时计算导数序列 $f'(s_t) = r(1-2s_t)$。\n\n2.  **计算平均对数导数**：在轨道的后半部分（$t \\in [1000, 4999]$）计算导数对数幅度的平均值 $\\Lambda_0 = \\langle \\ln|f'(s_t)| \\rangle_t$。在取对数前应用规定的 $10^{-12}$ 下限，以防止数值错误。对于给定的测试用例，此项是常数。\n\n3.  **定义计算函数**：定义一个函数 `get_max_transverse_lyapunov(A, eps, lambda_0)`。它接受一个邻接矩阵 $A$、耦合强度 $\\varepsilon$ 和预先计算的 $\\Lambda_0$。在函数内部：\n    a. 构造拉普拉斯算子 $L=D-A$。\n    b. 数值计算 $L$ 的特征值 $\\lambda_i$。\n    c. 筛选出非零特征值（使用一个小的数值容差）。\n    d. 对于每个非零 $\\lambda_i$，计算相应的李雅普诺夫指数 $\\Lambda_i = \\ln|1 - \\varepsilon \\lambda_i| + \\Lambda_0$。\n    e. 函数返回所有计算出的 $\\Lambda_i$ 中的最大值。如果不存在横向模式（例如，对于单节点图），则返回 $-\\infty$。\n\n4.  **计算基线指数**：使用原始网络的邻接矩阵 $A$ 调用步骤3中的函数，以获得基线最大横向李雅普诺夫指数 $\\Lambda_{\\text{max}}^{\\text{orig}}$。\n\n5.  **分类节点**：通过一个循环遍历从 $0$ 到 $N-1$ 的每个节点索引 $k$：\n    a. 通过从 $A$ 中删除第 $k$ 行和第 $k$ 列来创建简化网络的邻接矩阵 $A^{(-k)}$。\n    b. 使用 $A^{(-k)}$ 调用步骤3中的函数，计算简化网络的指数 $\\Lambda_{\\text{max}}^{(-k)}$。\n    c. 计算差值 $\\Delta_k = \\Lambda_{\\text{max}}^{(-k)} - \\Lambda_{\\text{max}}^{\\text{orig}}$。\n    d. 根据 $\\Delta_k$ 相对于一个小的数值容差的符号，将节点 $k$ 分类为起搏器（$\\Delta_k > 0$）、去同步器（$\\Delta_k  0$）或中性。\n\n6.  **格式化输出**：将每个测试用例的结果（包括四舍五入的 $\\Lambda_{\\text{max}}^{\\text{orig}}$ 以及排序后的起搏器和去同步器索引列表）收集起来，并格式化为指定的字符串格式。对于给定的测试用例（循环图和完全图），所有节点在结构上是等价的。因此，在单个案例中，所有节点预计将属于同一类别。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef get_max_transverse_lyapunov(A, eps, s_prime_log_mean, num_tol):\n    \"\"\"\n    Calculates the maximum transverse Lyapunov exponent for a given network.\n    \n    Args:\n        A (np.ndarray): Adjacency matrix of the network.\n        eps (float): Coupling strength.\n        s_prime_log_mean (float): Pre-calculated time average of the log-derivative.\n        num_tol (float): Numerical tolerance for checking zero eigenvalues.\n\n    Returns:\n        float: The maximum transverse Lyapunov exponent.\n    \"\"\"\n    N = A.shape[0]\n    if N = 1:\n        return -np.inf\n\n    D = np.diag(A.sum(axis=1))\n    L = D - A\n    \n    # Use eigvalsh for real symmetric matrices for accuracy and performance\n    lambda_vals = np.linalg.eigvalsh(L)\n    \n    # Transverse modes correspond to non-zero eigenvalues\n    transverse_lambda_vals = lambda_vals[lambda_vals > num_tol]\n\n    if len(transverse_lambda_vals) == 0:\n        return -np.inf\n\n    # Calculate Lyapunov exponent for each transverse mode\n    lyapunov_exponents = np.log(np.abs(1 - eps * transverse_lambda_vals)) + s_prime_log_mean\n    \n    return np.max(lyapunov_exponents)\n\ndef solve():\n    \"\"\"\n    Solves the problem of calculating maximum transverse Lyapunov exponents\n    and classifying nodes in a network of coupled logistic maps.\n    \"\"\"\n    test_cases = [\n        # Case 1: C5\n        {\n            \"A\": np.array([\n                [0, 1, 0, 0, 1], [1, 0, 1, 0, 0], [0, 1, 0, 1, 0],\n                [0, 0, 1, 0, 1], [1, 0, 0, 1, 0]\n            ], dtype=np.float64),\n            \"r\": 3.8, \"eps\": 0.1\n        },\n        # Case 2: C6\n        {\n            \"A\": np.array([\n                [0, 1, 0, 0, 0, 1], [1, 0, 1, 0, 0, 0], [0, 1, 0, 1, 0, 0],\n                [0, 0, 1, 0, 1, 0], [0, 0, 0, 1, 0, 1], [1, 0, 0, 0, 1, 0]\n            ], dtype=np.float64),\n            \"r\": 3.9, \"eps\": 0.2\n        },\n        # Case 3: K8\n        {\n            \"A\": np.ones((8, 8), dtype=np.float64) - np.eye(8, dtype=np.float64),\n            \"r\": 3.6, \"eps\": 0.05\n        }\n    ]\n\n    s0 = 0.5\n    T = 5000\n    T_trans = 1000\n    min_abs_val = 1e-12\n    num_tol = 1e-9\n\n    final_results = []\n\n    for case in test_cases:\n        A, r, eps = case[\"A\"], case[\"r\"], case[\"eps\"]\n        N = A.shape[0]\n\n        # 1. Generate synchronous orbit and its derivatives\n        s = np.zeros(T)\n        s[0] = s0\n        for t in range(T - 1):\n            s[t+1] = r * s[t] * (1 - s[t])\n        \n        s_prime = r * (1 - 2 * s)\n\n        # 2. Calculate average log-derivative of the orbit\n        log_sum = np.sum(np.log(np.maximum(np.abs(s_prime[T_trans:]), min_abs_val)))\n        s_prime_log_mean = log_sum / (T - T_trans)\n\n        # 3. Calculate max transverse Lyapunov exponent for the original network\n        max_lyap_orig = get_max_transverse_lyapunov(A, eps, s_prime_log_mean, num_tol)\n        \n        pacemakers = []\n        desynchronizers = []\n\n        # 4. Classify nodes by removing them one by one\n        for k in range(N):\n            # Create the adjacency matrix for the reduced network\n            A_reduced = np.delete(np.delete(A, k, axis=0), k, axis=1)\n            max_lyap_reduced = get_max_transverse_lyapunov(A_reduced, eps, s_prime_log_mean, num_tol)\n            \n            delta_k = max_lyap_reduced - max_lyap_orig\n            \n            if delta_k > num_tol:\n                pacemakers.append(k)\n            elif delta_k  -num_tol:\n                desynchronizers.append(k)\n        \n        final_results.append([\n            round(max_lyap_orig, 6),\n            sorted(pacemakers),\n            sorted(desynchronizers)\n        ])\n    \n    # Print the final results in the specified format\n    print(str(final_results).replace(\" \", \"\"))\n\n# Execute the main function\nsolve()\n```"
        }
    ]
}