{
    "hands_on_practices": [
        {
            "introduction": "数值模拟是研究像逻辑斯蒂映射这样混沌系统的主要工具。本练习将指导你模拟该映射的行为，并研究一些实际操作中的选择——例如等待系统稳定下来的时间（暂态）以及如何对数据进行采样——是如何影响我们对吸引子及其性质（如李雅普诺夫指数）的理解的。这项实践旨在培养你在理论与计算实验之间相互作用的批判性意识 。",
            "id": "4267582",
            "problem": "您的任务是分析用于构建一维逻辑斯谛映射分岔图的有限时间数值程序如何影响其长期行为的经验表示。逻辑斯谛映射是由函数 $f_r:[0,1]\\to[0,1]$ 定义的离散时间动力系统，其更新规则为 $x_{n+1} = r\\,x_n(1-x_n)$，其中 $r \\in [0,4]$ 是一个实数参数，$x_n \\in [0,1]$ 是在离散时间 $n \\in \\mathbb{N}$ 的状态。对于每个固定的参数 $r$，轨道 $(x_n)_{n\\ge 0}$ 由一个初始条件 $x_0 \\in (0,1)$ 确定。分岔图可视化了当 $r$ 变化时轨道值的渐近集，其经验构建依赖于两个数值设计选择：舍弃一段有限的暂态过程和对轨道的有限子序列进行采样。\n\n您的推理应基于以下基本定义和经过充分检验的事实：\n- 当几乎所有轨道的长时间统计量收敛到相同分布时，映射 $f_r$ 就承认一个在 $[0,1]$ 上的不变概率测度 $\\mu_r$；对于混沌吸引子，这通常是 Sinai–Ruelle–Bowen (SRB) 测度。对于像 $f_r$ 这样的分段光滑一维映射，长轨道的经验分布通常用作 $\\mu_r$ 的近似。\n- 最大李雅普诺夫指数定义为（当极限存在时）$\\lambda(r) = \\lim_{N\\to\\infty} \\frac{1}{N} \\sum_{n=0}^{N-1} \\log |f_r'(x_n)|$，其中 $f_r'(x) = r(1-2x)$。对于遍历测度，根据伯克霍夫遍历定理，沿典型轨道的时间平均等于相对于 $\\mu_r$ 的空间平均。\n\n对于每个测试用例参数 $r$，您的程序必须执行以下操作：\n1. 从相同的固定初始条件 $x_0 = 0.123456789$ 开始，生成逻辑斯谛映射 $x_{n+1} = r\\,x_n(1-x_n)$ 的单条轨道，长度为 $N = 10^5$ 次迭代。\n2. 考虑两个暂态舍弃长度 $T_{\\text{short}}$ 和 $T_{\\text{long}}$，其中 $0  T_{\\text{short}}  T_{\\text{long}}  N$，以及两种采样方案：步长为 $s_{\\text{dense}} = 1$ 的密集采样和步长为 $s_{\\text{thin}} \\in \\mathbb{N}$ (其中 $s_{\\text{thin}} \\ge 2$) 的稀疏采样。\n3. 为确保在总迭代次数为 $N$ 的固定预算下各方案之间进行公平比较，通过以下公式定义公共样本大小 $M_0$：\n$$\nM_0 = \\min\\left\\{N - T_{\\text{short}},\\; N - T_{\\text{long}},\\; \\left\\lfloor \\frac{N - T_{\\text{long}}}{s_{\\text{thin}}} \\right\\rfloor \\right\\}。\n$$\n然后，使用以下三种配置中的每一种精确提取 $M_0$ 个样本：\n- 短暂态密集采样：舍弃 $T_{\\text{short}}$ 次迭代，然后以步长 $s_{\\text{dense}} = 1$ 取 $M_0$ 个连续点。\n- 长暂态密集采样：舍弃 $T_{\\text{long}}$ 次迭代，然后以步长 $s_{\\text{dense}} = 1$ 取 $M_0$ 个连续点。\n- 长暂态稀疏采样：舍弃 $T_{\\text{long}}$ 次迭代，然后以步长 $s_{\\text{thin}}$ 取 $M_0$ 个点。\n4. 对每个样本集，在区间 $[0,1]$ 上使用 $B = 200$ 个等宽分箱计算归一化直方图，以近似该采样方案导出的经验不变测度 $\\mu_r$。设得到的概率向量为 $p_{\\text{short,dense}}$、$p_{\\text{long,dense}}$ 和 $p_{\\text{long,thin}}$。\n5. 通过计算以下两个距离，量化吸引子的经验视觉测度受暂态舍弃和采样的影响程度：\n- 暂态敏感度，定义为短暂态和长暂態的密集采样直方图之间的全变差距离：\n$$\nD_{\\text{transient}} = \\frac{1}{2} \\sum_{i=1}^{B} \\left| \\left(p_{\\text{short,dense}}\\right)_i - \\left(p_{\\text{long,dense}}\\right)_i \\right|。\n$$\n- 采样敏感度，定义为长暂态密集采样和长暂态稀疏采样直方图之间的全变差距离：\n$$\nD_{\\text{sampling}} = \\frac{1}{2} \\sum_{i=1}^{B} \\left| \\left(p_{\\text{long,dense}}\\right)_i - \\left(p_{\\text{long,thin}}\\right)_i \\right|。\n$$\n6. 对每个样本集，通过有限时间平均估计最大李雅普诺夫指数：\n$$\n\\hat{\\lambda} = \\frac{1}{M_0} \\sum_{m=1}^{M_0} \\log \\left| r \\left( 1 - 2 x_m \\right) \\right|,\n$$\n其中 $x_m$ 遍历采样得到的子序列。利用这些估计值，计算：\n- $\\Delta_{\\text{transient}} = \\left| \\hat{\\lambda}_{\\text{short,dense}} - \\hat{\\lambda}_{\\text{long,dense}} \\right|$，\n- $\\Delta_{\\text{sampling}} = \\left| \\hat{\\lambda}_{\\text{long,dense}} - \\hat{\\lambda}_{\\text{long,thin}} \\right|$。\n\n测试套件与参数覆盖范围：\n- 用例 1（周期2区域与混叠边界情况）：$r = 3.0$, $T_{\\text{short}} = 100$, $T_{\\text{long}} = 5000$, $s_{\\text{thin}} = 2$。\n- 用例 2（倍周期之外的周期窗口）：$r = 3.5$, $T_{\\text{short}} = 100$, $T_{\\text{long}} = 5000$, $s_{\\text{thin}} = 2$。\n- 用例 3（完全混沌区域）：$r = 3.7$, $T_{\\text{short}} = 100$, $T_{\\text{long}} = 5000$, $s_{\\text{thin}} = 5$。\n- 用例 4（强混沌区域，接近上端）：$r = 3.9$, $T_{\\text{short}} = 100$, $T_{\\text{long}} = 5000$, $s_{\\text{thin}} = 7$。\n\n所需输出：\n- 对于每个用例，输出一个包含四个浮点数的列表 $[D_{\\text{transient}}, D_{\\text{sampling}}, \\Delta_{\\text{transient}}, \\Delta_{\\text{sampling}}]$，其中每个浮点数都四舍五入到恰好六位小数。\n- 您的程序应生成单行输出，其中包含这些列表组成的逗号分隔列表，并用方括号括起来。例如，一个有效的形状是 $[[a_1,a_2,a_3,a_4],[b_1,b_2,b_3,b_4],\\ldots]$，不含空格。\n\n关于科学真实性的说明：\n- 按照规定，将每个参数的迭代总步数保持在 $N = 10^5$ 以内。\n- 使用 $x_0 = 0.123456789$，并确保所有直方图分箱均匀覆盖 $[0,1]$。\n- 在计算 $\\log |f_r'(x)|$ 时，如果 $|f_r'(x)|$ 发生数值下溢，请使用一个标准的微小正数阈值以避免对零取对数，并在您的解题思路中明确说明这一选择。",
            "solution": "用户提供的问题被评估为有效。它在科学上是合理的、问题定义是明确的，并且所有变量和条件都已无歧义地指定。该问题构成了非线性动力学和混沌理论领域的一个标准数值研究，重点关注在逻辑斯谛映射分析中的计算假象。\n\n解决方案通过实施指定的数值实验来推进。对于每个参数集，分析涉及轨道生成、根据三种不同方案进行子采样，以及随后计算统计和动力学量以量化这些方案引起的差异。\n\n### 基于原理的设计\n\n本研究探讨的基本原理是动力系统的长期行为与其有限时间数值近似之间的一致性。对于遍历系统，伯克霍夫遍历定理保证，对于几乎所有初始条件，沿轨道的可观测量的时间平均值会收敛到系统自然不变测度 $\\mu_r$ 的空间平均值。数值模拟分岔图涉及两个关键近似：\n1.  **舍弃暂态过程**：轨道在初始阶段迭代一段有限时间 $T$，以便让其收敛到吸引子上，并舍弃最初的 $T$ 个点。\n2.  **对吸引子进行采样**：在随后的有限次迭代中记录系统状态，以构建吸引子几何形态及其上支撑的不变测度的图像。\n\n本问题将对这些选择如何影响动力学两种主要特征的调查形式化：其一是不变测度本身，通过直方图近似；其二是最大李雅普诺夫指数 $\\hat{\\lambda}$，它衡量系统对初始条件的敏感度。\n\n### 算法实现\n\n对于每个由参数集 $(r, T_{\\text{short}}, T_{\\text{long}}, s_{\\text{thin}})$ 定义的测试用例，执行以下步骤序列。\n\n1.  **轨道生成**：使用逻辑斯谛映射递推关系 $x_{n+1} = r\\,x_n(1-x_n)$ 生成长度为 $N = 10^5$ 的单个时间序列 $(x_n)_{n=0}^{N-1}$。初始条件固定为 $x_0 = 0.123456789$。这条长轨道是所有后续分析的基础数据。\n\n2.  **公共样本大小计算**：为确保公平比较，所有统计估计都基于相同数量的数据点 $M_0$。此大小由最严格的采样方案确定：\n    $$\n    M_0 = \\min\\left\\{N - T_{\\text{short}},\\; N - T_{\\text{long}},\\; \\left\\lfloor \\frac{N - T_{\\text{long}}}{s_{\\text{thin}}} \\right\\rfloor \\right\\}\n    $$\n    这确保了任何观察到的差异都是由采样策略本身（即选择了哪些点）引起的，而不是由于不同样本大小带来的统计不确定性。\n\n3.  **数据提取**：从主轨道中提取三个不同但大小均为 $M_0$ 的样本：\n    *   **短暂态、密集样本**：子序列在 $T_{\\text{short}}$ 次迭代后开始，由 $M_0$ 个连续点组成。这对应于 `orbit[T_short : T_short + M_0]`。\n    *   **长暂态、密集样本**：子序列在 $T_{\\text{long}}$ 次迭代后开始，由 $M_0$ 个连续点组成。这对应于 `orbit[T_long : T_long + M_0]`。\n    *   **长暂态、稀疏样本**：子序列在 $T_{\\text{long}}$ 次迭代后开始，但以 $s_{\\text{thin}}$ 的步长取点。这对应于 `orbit[T_long : T_long + M_0 * s_thin : s_thin]`。\n\n4.  **经验不变测度估计**：对于三个样本中的每一个，我们近似不变测度 $\\mu_r$。这是通过在区间 $[0,1]$ 上使用 $B = 200$ 个等宽分箱构建归一化直方图来完成的。如果 $c_i$ 是第 $i$ 个分箱中的样本点计数，则该分箱的概率为 $p_i = c_i / M_0$。此过程产生三个概率向量：$p_{\\text{short,dense}}$、$p_{\\text{long,dense}}$ 和 $p_{\\text{long,thin}}$。\n\n5.  **量化测度差异**：经验测度之间的差异使用全变差距离进行量化，这是一种衡量概率分布的标准度量。计算的两个特定量是：\n    *   暂态敏感度: $D_{\\text{transient}} = \\frac{1}{2} \\sum_{i=1}^{B} | (p_{\\text{short,dense}})_i - (p_{\\text{long,dense}})_i |$。这衡量了延长暂态舍弃周期的影响。\n    *   采样敏感度: $D_{\\text{sampling}} = \\frac{1}{2} \\sum_{i=1}^{B} | (p_{\\text{long,dense}})_i - (p_{\\text{long,thin}})_i |$。这衡量了在长暂态之后，稀疏采样与密集采样的影响。\n\n6.  **有限时间李雅普诺夫指数估计**：最大李雅普诺夫指数是混沌的关键指标。对于一维映射，它是通过对轨道上映射导数绝对值的对数进行平均来估计的。对于每个样本，估计值 $\\hat{\\lambda}$ 计算如下：\n    $$\n    \\hat{\\lambda} = \\frac{1}{M_0} \\sum_{m=1}^{M_0} \\log \\left| r \\left( 1 - 2 x_m \\right) \\right|\n    $$\n    其中 $\\{x_m\\}_{m=1}^{M_0}$ 是样本中的点。一个关键的实现细节是处理对数参数为零的情况，这种情况发生在轨道点 $x_m$ 恰好等于临界点 $x=0.5$ 时。为防止致命的数学错误（$\\log(0)$）并保持数值稳定性，在取对数之前，会向绝对值 $|f_r'(x_m)|$ 中加入一个微小的正常数 `numpy.finfo(float).tiny`。\n\n7.  **量化李雅普诺夫指数差异**：李雅普诺夫指数估计对采样方案的敏感度通过绝对差来衡量：\n    *   暂态敏感度：$\\Delta_{\\text{transient}} = | \\hat{\\lambda}_{\\text{short,dense}} - \\hat{\\lambda}_{\\text{long,dense}} |$。\n    *   采样敏感度：$\\Delta_{\\text{sampling}} = | \\hat{\\lambda}_{\\text{long,dense}} - \\hat{\\lambda}_{\\text{long,thin}} |$。\n\n对四个指定的测试用例中的每一个都执行这些计算，并将结果按要求编译和格式化。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# No other libraries outside the Python standard library are permitted.\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation for all test cases and print the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (r, T_short, T_long, s_thin)\n        (3.0, 100, 5000, 2),\n        (3.5, 100, 5000, 2),\n        (3.7, 100, 5000, 5),\n        (3.9, 100, 5000, 7),\n    ]\n\n    all_results = []\n    for params in test_cases:\n        result = analyze_logistic_map(*params)\n        all_results.append(result)\n\n    # Final print statement in the exact required format.\n    # Format: [[a,b,c,d],[e,f,g,h],...]\n    output_parts = []\n    for res_list in all_results:\n        formatted_list = ','.join([f'{x:.6f}' for x in res_list])\n        output_parts.append(f'[{formatted_list}]')\n    \n    print(f\"[{','.join(output_parts)}]\")\n\ndef analyze_logistic_map(r, T_short, T_long, s_thin):\n    \"\"\"\n    Performs the analysis for a single set of parameters for the logistic map.\n    \n    Args:\n        r (float): The parameter of the logistic map.\n        T_short (int): Short transient discard length.\n        T_long (int): Long transient discard length.\n        s_thin (int): Stride for thin sampling.\n\n    Returns:\n        list: A list containing [D_transient, D_sampling, Delta_transient, Delta_sampling].\n    \"\"\"\n    N = 100000\n    x0 = 0.123456789\n    B = 200\n\n    # 1. Generate the orbit\n    orbit = np.zeros(N)\n    orbit[0] = x0\n    for n in range(N - 1):\n        orbit[n + 1] = r * orbit[n] * (1 - orbit[n])\n        \n    # 2. Define the common sample size M0\n    M0 = min(N - T_short, N - T_long, (N - T_long) // s_thin)\n\n    # 3. Extract the three sample sets\n    sample_short_dense = orbit[T_short : T_short + M0]\n    sample_long_dense = orbit[T_long : T_long + M0]\n    # The stop index for thin sampling ensures exactly M0 points are taken\n    stop_index_thin = T_long + M0 * s_thin\n    sample_long_thin = orbit[T_long : stop_index_thin : s_thin]\n\n    # 4. Compute normalized histograms\n    hist_short_dense, _ = np.histogram(sample_short_dense, bins=B, range=(0, 1))\n    hist_long_dense, _ = np.histogram(sample_long_dense, bins=B, range=(0, 1))\n    hist_long_thin, _ = np.histogram(sample_long_thin, bins=B, range=(0, 1))\n\n    # Normalize to get probability vectors\n    p_short_dense = hist_short_dense / M0\n    p_long_dense = hist_long_dense / M0\n    p_long_thin = hist_long_thin / M0\n    \n    # 5. Compute total variation distances\n    D_transient = 0.5 * np.sum(np.abs(p_short_dense - p_long_dense))\n    D_sampling = 0.5 * np.sum(np.abs(p_long_dense - p_long_thin))\n\n    # 6. Estimate largest Lyapunov exponents\n    # Define a helper function for clarity\n    def estimate_lyapunov(sample, r_param):\n        # Add a small epsilon to avoid log(0)\n        # np.finfo(float).tiny is the smallest positive representable number.\n        log_derivs = np.log(np.abs(r_param * (1 - 2 * sample)) + np.finfo(float).tiny)\n        return np.mean(log_derivs)\n\n    lambda_short_dense = estimate_lyapunov(sample_short_dense, r)\n    lambda_long_dense = estimate_lyapunov(sample_long_dense, r)\n    lambda_long_thin = estimate_lyapunov(sample_long_thin, r)\n    \n    # Compute differences in Lyapunov estimates\n    Delta_transient = np.abs(lambda_short_dense - lambda_long_dense)\n    Delta_sampling = np.abs(lambda_long_dense - lambda_long_thin)\n    \n    return [D_transient, D_sampling, Delta_transient, Delta_sampling]\n\nsolve()\n```"
        },
        {
            "introduction": "在探索了逻辑斯蒂映射的行为之后，我们现在将注意力集中在其最显著的特征之一：通往混沌的倍周期分岔路径。这项实践要求你通过数值计算来估算费根鲍姆常数 $\\delta$，这是一个描述这些分岔缩放规律的普适常数。通过实现一个求根算法来定位超稳定轨道，你不仅能亲眼见证这种普适性，还能获得在非线性动力学研究中至关重要的稳健数值技术的实践经验 。",
            "id": "4267656",
            "problem": "考虑一个被称为逻辑斯谛映射 (logistic map) 的一维迭代动力系统，其定义为 $f_{r}(x) = r x (1 - x)$，其中参数 $r$ 为实数且 $x \\in [0,1]$。随着 $r$ 的增加，逻辑斯谛映射会展现出倍周期级联现象，并在一个有限的参数值处汇集，此时混沌出现。Feigenbaum 常数 $\\delta$ 描述了与此倍周期过程相关的连续参数区间长度的几何收敛性。常数 $\\delta$ 由连续差分的极限比率 $\\frac{r_{n} - r_{n-1}}{r_{n+1} - r_{n}}$ (当 $n \\to \\infty$ 时) 定义，其中 $r_{n}$ 表示系统从一个周期为 $2^{n-1}$ 的稳定轨道分岔到一个周期为 $2^{n}$ 的稳定轨道时的参数值。在实践中，可以通过识别超稳定参数值 $s_{n}$ 来估计这些 $r_{n}$ 值。在这些超稳定参数值下，临界点 $x_{c} = \\frac{1}{2}$ 属于周期为 $2^{n}$ 的吸引环。等价地，$s_{n}$ 是方程 $f_{s_{n}}^{(2^{n})}\\!\\left(\\frac{1}{2}\\right) - \\frac{1}{2} = 0$ 的一个根，其中 $f_{r}^{(k)}$ 表示 $k$ 次复合。\n\n从迭代映射的定义、$f_{r}(x)$ 在 $r$ 和 $x$ 上的连续性以及连续函数的介值定理这些基本原理出发，您必须：\n\n- 通过求解 $F_{n}(r) = f_{r}^{(2^{n})}\\!\\left(\\frac{1}{2}\\right) - \\frac{1}{2} = 0$（其中 $n \\in \\mathbb{N}$），推导并实现一个稳健的数值方法来定位逻辑斯谛映射的超稳定参数 $s_{n}$。从对应于不动点的 $s_{0} = 2$ 开始，对于每个后续的 $n$，搜索满足 $F_{n}(r) = 0$ 的最小的 $r > s_{n-1}$。\n- 使用区间套策略保证 $F_{n}(r)$ 的根区间的存在性，然后在该区间上应用二分法以高精度计算 $s_{n}$。您必须确保所有步骤都保持数值稳定性。\n- 对指定的 $n$ 值，计算 Feigenbaum 比率估计值序列 $\\delta_{n} = \\frac{s_{n} - s_{n-1}}{s_{n+1} - s_{n}}$ 并分析其收敛行为。\n\n您的程序必须为以下测试套件生成输出，该套件旨在评估其正确性、稳定性和收敛性：\n\n- 使用您的方法获得的超稳定序列 $\\{s_{n}\\}$，计算 $n \\in \\{1,2,3,4,5,6,7\\}$ 的 Feigenbaum 比率估计值 $\\delta_{n}$。\n- 此外，计算两个布尔诊断值：\n  1. $M_{s}$：序列 $\\{s_{n}\\}$ 在计算范围内是否严格递增，即对于所有考虑的连续对，是否有 $s_{n+1} > s_{n}$。\n  2. $D_{\\delta}$：对于您计算出的集合中最后三个可用的连续索引，绝对差值 $|\\delta_{n+1} - \\delta_{n}|$ 是否严格递减，这用于探究经验收敛行为。\n\n所有量都是纯数值且无单位。不涉及角度。最终输出必须以单行形式呈现，包含一个用方括号括起来的逗号分隔列表，结构如下：\n$[\\delta_{1},\\delta_{2},\\delta_{3},\\delta_{4},\\delta_{5},\\delta_{6},\\delta_{7},M_{s},D_{\\delta}]$,\n其中前七个条目是浮点数，后两个条目是布尔值。您的程序必须在没有任何外部输入或文件的情况下计算这些值，并且必须能在标准环境中按原样运行。\n\n您的算法必须从上述基本原理推导得出，不得使用任何快捷公式或预先制表的分岔点。它必须根据给定的定义和基本连续性属性，通过算法生成所有值。",
            "solution": "该问题要求数值计算 Feigenbaum 常数 $\\delta$，该常数表征了通往混沌的倍周期路径中的普适标度行为。我们的任务是针对一维逻辑斯谛映射这一特定情况来完成计算，其迭代函数定义为 $f_{r}(x) = r x (1 - x)$，其中状态变量 $x$ 局限于区间 $[0, 1]$ 内，而 $r$ 是一个实数参数。该解法必须从基本原理推导得出，即迭代映射的定义、其迭代函数的连续性以及介值定理。\n\n首先，我们建立理论和算法基础。映射的第 $k$ 次迭代由复合函数 $f_{r}^{(k)}(x) = f_r(f_r(\\dots f_r(x)\\dots))$ 定义，其中函数 $f_r$ 被应用 $k$ 次。对于任意固定的整数 $k$ 和初始点 $x$，函数 $g(r) = f_{r}^{(k)}(x)$ 是一个关于 $r$ 的多项式。一个直接的推论是，$g(r)$ 对于所有 $r \\in \\mathbb{R}$ 都是 $r$ 的连续函数。这种连续性是我们数值方法的核心支柱，因为它允许我们应用介值定理。\n\n问题指导我们使用超稳定环来近似倍周期分岔点。如果映射的临界点 $x_c$ 是周期环的一个元素，那么这个吸引子就是一个周期为 $p$ 的超稳定环。对于逻辑斯谛映射 $f_r(x)$，临界点可通过求解 $f_r'(x_c) = r(1-2x_c) = 0$ 找到，解得 $x_c = 1/2$。一个周期为 $2^n$ 的超稳定环是指 $x_c=1/2$ 的轨道周期为 $2^n$ 的环。产生这样一个环的参数值 $s_n$ 可通过求解方程 $f_{s_n}^{(2^n)}(1/2) = 1/2$ 找到。这引导我们定义一个函数序列 $F_n(r) = f_{r}^{(2^n)}(1/2) - 1/2$。超稳定参数 $s_n$ 是方程 $F_n(r)=0$ 的根。由于 $f_r^{(2^n)}(1/2)$ 关于 $r$ 是连续的，因此 $F_n(r)$ 也是连续的。\n\n我们的目标是找到根序列 $\\{s_n\\}$，其中 $n=0, 1, 2, \\dots$。问题规定，对于每个 $n \\geq 1$，我们必须找到严格大于 $s_{n-1}$ 且满足 $F_n(r)=0$ 的最小根。问题提供了基准情形 $s_0=2$，它对应于超稳定不动点（$n=0$，周期 $2^0=1$）。我们可以验证这一点：$F_0(r) = f_r(1/2) - 1/2 = r(1/2)(1-1/2) - 1/2 = r/4 - 1/2$。令 $F_0(r)=0$ 可得 $r/4=1/2$，因此 $s_0=2$。\n\n为了找到每个后续的根 $s_n$，我们采用一个基于 $F_n(r)$ 连续性的两阶段数值算法：\n1.  **求根区间限定 (Root Bracketing)**：介值定理指出，对于一个在区间 $[a, b]$ 上的连续函数 $F_n(r)$，如果 $F_n(a)$ 和 $F_n(b)$ 异号，则在 $(a, b)$ 内至少存在一个根。我们的算法必须首先为目标根 $s_n$ 找到这样一个区间 $[a, b]$。我们从一个略大于先前找到的根 $s_{n-1}$ 的点开始搜索，并以足够小的步长在 $r$ 上前进，在每个点上评估 $F_n(r)$ 的符号。第一个检测到符号变化的区间就成为我们的根区间。这个过程可靠地分离出“大于 $s_{n-1}$ 的最小根”。\n\n2.  **通过二分法进行根的精化 (Root Refinement via Bisection)**：一旦根被限定在区间 $[a, b]$ 内，二分法提供了一个稳健且保证收敛的算法来精化其值。该方法按以下步骤进行：\n    a. 计算中点 $c = (a+b)/2$ 并评估 $F_n(c)$。\n    b. 如果 $F_n(a)$ 和 $F_n(c)$ 异号，则根位于 $[a, c]$ 内，因此我们令 $b=c$。\n    c. 否则，根必定位于 $[c, b]$ 内，我们令 $a=c$。\n    d. 重复此过程，每一步将区间宽度减半，直到宽度 $(b-a)$ 小于预定的数值公差 $\\epsilon$。最终区间的中点被视为 $s_n$ 的高精度估计值。计算成本主要由 $F_n(r)$ 的评估决定，这需要对逻辑斯谛映射进行 $2^n$ 次迭代。\n\n此过程被顺序应用于计算序列 $s_0, s_1, s_2, \\dots, s_8$。高公差（例如 $\\epsilon=10^{-15}$）是必要的，因为后续 Feigenbaum 比率的计算对 $s_n$ 值的精度很敏感。\n\n计算出序列 $\\{s_n\\}_{n=0}^8$ 后，我们便可以求出 Feigenbaum 常数的估计值 $\\delta_n$。这些估计值由超稳定点之间连续参数区间的长度之比给出：\n$$ \\delta_n = \\frac{s_n - s_{n-1}}{s_{n+1} - s_n} $$\n我们将计算 $n \\in \\{1, 2, 3, 4, 5, 6, 7\\}$ 时这些值。\n\n最后，计算两个诊断布尔值：\n-   $M_s$：检查计算出的序列是否严格单调递增，即对所有相关 $k$ 是否有 $s_{k+1} > s_k$。这是一个预期的理论属性。\n-   $D_\\delta$：通过检查我们计算出的集合中最后三个可用连续索引的绝对差值 $|\\delta_{n+1} - \\delta_n|$ 是否严格递减，来探究 $\\delta_n$ 序列的收敛性。这对应于检验是否 $|\\delta_5 - \\delta_4| > |\\delta_6 - \\delta_5| > |\\delta_7 - \\delta_6|$。\n\n这种基于第一性原理的稳健算法，能够在不借助预制表值或高级库函数的情况下，精确确定所需的量，严格遵守了问题的约束条件。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy is available but not used to adhere to the problem's\n# requirement of deriving and implementing the numerical method.\n\ndef solve():\n    \"\"\"\n    Computes Feigenbaum constant estimates for the logistic map by finding\n    superstable parameter values using a custom bisection root-finder.\n    \"\"\"\n    # Configuration\n    N_MAX = 8  # We need s_0 through s_8 to compute delta_1 through delta_7\n    BISECTION_TOL = 1e-15\n\n    # A dictionary of search step sizes for the bracketing algorithm.\n    # The step size must decrease as n increases because the distance\n    # between successive s_n values shrinks geometrically.\n    SEARCH_STEPS = {\n        1: 1e-1, 2: 1e-2, 3: 5e-3, 4: 1e-3,\n        5: 1e-4, 6: 1e-5, 7: 1e-6, 8: 1e-7\n    }\n\n    def iterate_map(r, x0, k):\n        \"\"\"Computes the k-th iterate of the logistic map f_r(x) starting from x0.\"\"\"\n        x = x0\n        for _ in range(k):\n            # Using np.float64 for operations to maintain precision\n            x = np.float64(r) * x * (np.float64(1.0) - x)\n        return x\n\n    def F_n(r, n):\n        \"\"\"The target function whose root is the superstable parameter s_n.\n        F_n(r) = f_r^(2^n)(1/2) - 1/2\n        \"\"\"\n        k = 1  n  # 2**n using bitwise shift\n        x_final = iterate_map(r, np.float64(0.5), k)\n        return x_final - np.float64(0.5)\n\n    def bisection(func, a, b, tol):\n        \"\"\"\n        Finds a root of func in the bracket [a, b] to a given tolerance.\n        Assumes func(a) and func(b) have opposite signs.\n        \"\"\"\n        fa = func(a)\n        if fa * func(b)  0:\n            raise ValueError(f\"Root is not bracketed in [{a}, {b}].\")\n        \n        while (b - a)  tol:\n            c = a + (b - a) / 2\n            fc = func(c)\n            if fc == 0:\n                return c\n            if fa * fc  0:\n                b = c\n            else:\n                a = c\n                fa = fc\n        return a + (b - a) / 2\n\n    s = [np.float64(2.0)]  # Start with s_0 = 2\n\n    # Sequentially compute s_1, s_2, ..., s_N_MAX\n    for n in range(1, N_MAX + 1):\n        target_func = lambda r: F_n(r, n)\n        \n        # --- Root Bracketing ---\n        # Start search for s_n just after s_{n-1}\n        # Add a small epsilon to avoid starting exactly at the previous root\n        r_a = s[n-1] + 1e-9\n        \n        search_step = SEARCH_STEPS.get(n, 1e-8)\n        val_a = target_func(r_a)\n        \n        while True:\n            r_b = r_a + search_step\n            val_b = target_func(r_b)\n            if val_a * val_b  0:\n                # Bracket found\n                break\n            r_a = r_b\n            val_a = val_b\n            if r_a  4.0: # Safety break; chaos is confined to r = 4\n                raise RuntimeError(f\"Bracket search failed for s_{n}\")\n\n        # --- Root Refinement ---\n        s_n = bisection(target_func, r_a, r_b, BISECTION_TOL)\n        s.append(s_n)\n\n    # Compute Feigenbaum ratio estimates delta_n\n    deltas = []\n    for n in range(1, 8):  # n from 1 to 7\n        numerator = s[n] - s[n-1]\n        denominator = s[n+1] - s[n]\n        delta_n = numerator / denominator\n        deltas.append(delta_n)\n    \n    # Compute diagnostic booleans\n    # M_s: Check if the s_n sequence is strictly increasing\n    M_s = all(s[i]  s[i+1] for i in range(len(s) - 1))\n    \n    # D_delta: Check for convergence behavior in the delta_n sequence.\n    # We check if the absolute differences |delta_{n+1} - delta_n|\n    # are strictly decreasing for the last three available indices.\n    delta_diffs_abs = [abs(deltas[i+1] - deltas[i]) for i in range(len(deltas) - 1)]\n    # This checks |d5-d4| > |d6-d5| AND |d6-d5| > |d7-d6|\n    # Note: indices for delta_diffs_abs are shifted.\n    # delta_diffs_abs[i] = |deltas[i+1] - deltas[i]|\n    # delta_diffs_abs[3] = |deltas[4] - deltas[3]| = |d5 - d4|\n    # delta_diffs_abs[4] = |deltas[5] - deltas[4]| = |d6 - d5|\n    # delta_diffs_abs[5] = |deltas[6] - deltas[5]| = |d7 - d6|\n    D_delta = (delta_diffs_abs[3]  delta_diffs_abs[4]) and \\\n              (delta_diffs_abs[4]  delta_diffs_abs[5])\n              \n    # Format and print the final result\n    final_results = deltas + [M_s, D_delta]\n    print(f\"[{','.join(map(str, final_results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "尽管数值方法提供了宝贵的洞察力，但对混沌的更深层次理解来自于解析处理。本练习要求你精确计算逻辑斯蒂映射在参数 $r=4$（一个完全发展的混沌状态）时的最大李雅普诺夫指数。通过运用不变测度和遍历定理等概念，这项实践将混沌理论的抽象数学框架与一个具体的、可计算的结果联系起来，从而加深对混沌动力学理论基础的理解 。",
            "id": "4267640",
            "problem": "考虑单位区间 $[0,1]$ 上的一维逻辑斯谛映射 $f(x)=r\\,x(1-x)$，参数 $r=4$。该映射 $f$ 在 $[0,1]$ 上保持一个关于勒贝格测度绝对连续的不变概率测度 $\\mu$，其密度为 $\\rho(x)=\\frac{1}{\\pi\\sqrt{x(1-x)}}$。对于 $\\mu$-几乎所有的初始条件 $x_{0}\\in[0,1]$，最大李雅普诺夫指数定义为\n$$\n\\lambda(x_{0})=\\lim_{n\\to\\infty}\\frac{1}{n}\\sum_{k=0}^{n-1}\\ln\\big|f'(x_{k})\\big|\\quad\\text{其中 }x_{k}=f^{k}(x_{0})。\n$$\n从不变测度和伯克霍夫遍历定理 (Birkhoff Ergodic Theorem, BET) 的核心定义出发，并假设在 $r=4$ 时 $\\mu$ 对于 $f$ 是遍历的，推导最大李雅普诺夫指数作为关于 $\\rho$ 的积分的空间平均表示。然后，仅使用给定的不变密度和基础微积分，计算该映射在 $r=4$ 时的最大李雅普诺夫指数的精确闭式值。将你的最终答案表示为包含自然对数的单个精确表达式，不要四舍五入。最终答案不需要物理单位。",
            "solution": "该问题要求分两部分作答：首先，利用所给定义和伯克霍夫遍历定理 (Birkhoff Ergodic Theorem, BET) 推导最大李雅普诺夫指数的空间平均表示；其次，计算在指定参数值下逻辑斯谛映射的该指数的精确值。\n\n问题陈述已经过验证，被认为是有效的。它在科学上基于遍历理论和非线性动力学的既定原则，问题提法得当，且表述客观。所有必要信息均已提供。\n\n**第一部分：空间平均表示的推导**\n\n最大李雅普诺夫指数 $\\lambda(x_0)$ 是作为沿始于 $x_0$ 的轨道的时均值给出的：\n$$\n\\lambda(x_0) = \\lim_{n\\to\\infty}\\frac{1}{n}\\sum_{k=0}^{n-1}\\ln\\big|f'(x_k)\\big|\n$$\n其中 $x_k = f^k(x_0) = f(f(...f(x_0)...))$ 是映射 $f(x)$ 的第 $k$ 次迭代。\n\n该表达式具有函数 $g(x) = \\ln|f'(x)|$ 沿轨道 $\\{x_k\\}_{k=0}^\\infty$ 的时均值形式。伯克霍夫遍历定理 (Birkhoff Ergodic Theorem, BET) 建立了时均值和空间平均之间的基本联系。该定理指出，对于一个保测变换 $f$ 在一个概率空间 $(X, \\mathcal{B}, \\mu)$ 上，如果该变换相对于测度 $\\mu$ 是遍历的，并且对于任何可积函数 $g \\in L^1(\\mu)$，对于 $\\mu$-几乎所有的初始点 $x_0 \\in X$，函数 $g$ 沿轨道的时均值等于 $g$ 的空间平均。\n在数学上，对于 $\\mu$-几乎所有的 $x_0$：\n$$\n\\lim_{n\\to\\infty}\\frac{1}{n}\\sum_{k=0}^{n-1}g(f^k(x_0)) = \\int_X g(x) \\,d\\mu(x)\n$$\n在此问题的背景下：\n- 空间是单位区间, $X = [0, 1]$。\n- 变换是逻辑斯谛映射, $f(x) = 4x(1-x)$。\n- 系统被假设对于不变概率测度 $\\mu$ 是遍历的。\n- 需要求平均的函数是 $g(x) = \\ln|f'(x)|$。我们必须确保 $g(x)$ 关于 $\\mu$ 是可积的，这将在计算过程中得到证实。\n\n通过应用 BET，我们可以将李雅普诺夫指数的时均值定义与其空间平均对应物等同起来。由于该定理对 $\\mu$-几乎所有的 $x_0$ 都成立，所以李雅普诺夫指数 $\\lambda$ 对这组点来说与初始条件无关。\n$$\n\\lambda = \\int_0^1 \\ln|f'(x)| \\,d\\mu(x)\n$$\n问题陈述指出，不变测度 $\\mu$ 相对于勒贝格测度 $dx$ 是绝对连续的，并提供了其概率密度函数 $\\rho(x)$。这意味着微分测度元 $d\\mu(x)$ 可以写成 $\\rho(x)dx$。将此代入积分，得到所求的空间平均表示：\n$$\n\\lambda = \\int_0^1 \\ln|f'(x)| \\rho(x) \\,dx\n$$\n至此，推导完成。\n\n**第二部分：李雅普诺夫指数的计算**\n\n我们现在计算上面推导出的积分值。给定的组成部分是：\n- 映射: $f(x) = 4x(1-x) = 4x - 4x^2$。\n- 导数: $f'(x) = 4 - 8x = 4(1-2x)$。\n- 不变密度: $\\rho(x) = \\frac{1}{\\pi\\sqrt{x(1-x)}}$。\n\n将这些代入 $\\lambda$ 的空间平均公式：\n$$\n\\lambda = \\int_0^1 \\ln|4(1-2x)| \\frac{1}{\\pi\\sqrt{x(1-x)}} \\,dx\n$$\n我们可以将对数项 $\\ln|4(1-2x)| = \\ln(4) + \\ln|1-2x|$ 分开。积分可以因此分为两部分：\n$$\n\\lambda = \\frac{1}{\\pi}\\int_0^1 \\frac{\\ln(4)}{\\sqrt{x(1-x)}} \\,dx + \\frac{1}{\\pi}\\int_0^1 \\frac{\\ln|1-2x|}{\\sqrt{x(1-x)}} \\,dx\n$$\n我们分别计算每个积分。\n\n第一个积分, $I_1$:\n$$\nI_1 = \\frac{\\ln(4)}{\\pi} \\int_0^1 \\frac{1}{\\sqrt{x(1-x)}} \\,dx\n$$\n这个积分与概率密度函数 $\\rho(x)$ 的归一化有关。根据定义，一个概率密度函数的积分必须为 $1$：\n$$\n\\int_0^1 \\rho(x) \\,dx = \\int_0^1 \\frac{1}{\\pi\\sqrt{x(1-x)}} \\,dx = 1\n$$\n这意味着 $\\int_0^1 \\frac{1}{\\sqrt{x(1-x)}} \\,dx = \\pi$。因此，第一项是：\n$$\nI_1 = \\frac{\\ln(4)}{\\pi} \\cdot \\pi = \\ln(4)\n$$\n\n第二个积分, $I_2$:\n$$\nI_2 = \\frac{1}{\\pi}\\int_0^1 \\frac{\\ln|1-2x|}{\\sqrt{x(1-x)}} \\,dx\n$$\n为了计算这个积分，我们采用三角代换。令 $x = \\sin^2(\\theta)$。\n则 $dx = 2\\sin(\\theta)\\cos(\\theta) \\,d\\theta$。\n积分限相应改变：当 $x=0$ 时, $\\theta=0$；当 $x=1$ 时, $\\theta=\\pi/2$。\n被积函数中的项变为：\n- $\\sqrt{x(1-x)} = \\sqrt{\\sin^2(\\theta)(1-\\sin^2(\\theta))} = \\sqrt{\\sin^2(\\theta)\\cos^2(\\theta)} = \\sin(\\theta)\\cos(\\theta)$ 对于 $\\theta \\in [0, \\pi/2]$。\n- $1-2x = 1 - 2\\sin^2(\\theta) = \\cos(2\\theta)$。\n将这些直接代入 $\\lambda$ 的表达式中：\n$$\n\\lambda = \\frac{1}{\\pi} \\int_0^{\\pi/2} \\frac{\\ln|4\\cos(2\\theta)|}{\\sin(\\theta)\\cos(\\theta)} \\left(2\\sin(\\theta)\\cos(\\theta)\\right) \\,d\\theta = \\frac{2}{\\pi} \\int_0^{\\pi/2} \\ln|4\\cos(2\\theta)| \\,d\\theta\n$$\n我们可以再次拆分对数：\n$$\n\\lambda = \\frac{2}{\\pi} \\int_0^{\\pi/2} \\left(\\ln(4) + \\ln|\\cos(2\\theta)|\\right) \\,d\\theta = \\frac{2}{\\pi} \\left( \\int_0^{\\pi/2} \\ln(4) \\,d\\theta + \\int_0^{\\pi/2} \\ln|\\cos(2\\theta)| \\,d\\theta \\right)\n$$\n第一部分是 $\\frac{2}{\\pi} \\left( \\ln(4) \\cdot \\frac{\\pi}{2} \\right) = \\ln(4)$。这与 $I_1$ 相符。\n第二部分正是变量代换后的 $I_2$：\n$$\nI_2 = \\frac{2}{\\pi}\\int_0^{\\pi/2} \\ln|\\cos(2\\theta)| \\,d\\theta\n$$\n对数的参数 $\\cos(2\\theta)$ 在 $\\theta \\in [0, \\pi/4)$ 时为正，在 $\\theta \\in (\\pi/4, \\pi/2]$ 时为负。我们在 $\\theta = \\pi/4$ 处拆分积分：\n$$\nI_2 = \\frac{2}{\\pi} \\left[ \\int_0^{\\pi/4} \\ln(\\cos(2\\theta)) \\,d\\theta + \\int_{\\pi/4}^{\\pi/2} \\ln(-\\cos(2\\theta)) \\,d\\theta \\right]\n$$\n对于第一个子积分，令 $u=2\\theta$，则 $d\\theta = du/2$。积分限变为 $0$ 到 $\\pi/2$。\n$\\int_0^{\\pi/4} \\ln(\\cos(2\\theta)) \\,d\\theta = \\frac{1}{2}\\int_0^{\\pi/2} \\ln(\\cos(u)) \\,du$。\n对于第二个子积分，令 $v=\\pi - 2\\theta$，则 $d\\theta = -dv/2$。积分限变为 $\\pi/2$ 到 $0$。$-\\cos(2\\theta) = -\\cos(\\pi-v) = -(-\\cos(v)) = \\cos(v)$。\n$\\int_{\\pi/4}^{\\pi/2} \\ln(-\\cos(2\\theta)) \\,d\\theta = \\int_{\\pi/2}^0 \\ln(\\cos(v)) \\left(-\\frac{dv}{2}\\right) = \\frac{1}{2}\\int_0^{\\pi/2} \\ln(\\cos(v)) \\,dv$。\n因此，这两个子积分是相同的。\n$$\nI_2 = \\frac{2}{\\pi} \\left[ \\frac{1}{2}\\int_0^{\\pi/2} \\ln(\\cos(u)) \\,du + \\frac{1}{2}\\int_0^{\\pi/2} \\ln(\\cos(v)) \\,dv \\right] = \\frac{2}{\\pi} \\int_0^{\\pi/2} \\ln(\\cos(u)) \\,du\n$$\n这是一个标准的定积分结果。令 $J = \\int_0^{\\pi/2} \\ln(\\cos u) \\,du$。利用性质 $\\int_a^b f(x)dx = \\int_a^b f(a+b-x)dx$，我们也有 $J = \\int_0^{\\pi/2} \\ln(\\sin u) \\,du$。\n将这两种形式相加得到：\n$$\n2J = \\int_0^{\\pi/2} (\\ln(\\sin u) + \\ln(\\cos u)) \\,du = \\int_0^{\\pi/2} \\ln(\\sin u \\cos u) \\,du = \\int_0^{\\pi/2} \\ln\\left(\\frac{\\sin(2u)}{2}\\right) \\,du\n$$\n$$\n2J = \\int_0^{\\pi/2} \\ln(\\sin(2u)) \\,du - \\int_0^{\\pi/2} \\ln(2) \\,du\n$$\n第二项是 $\\frac{\\pi}{2}\\ln(2)$。对于第一项，令 $w=2u$，则 $du = dw/2$。积分限为 $0$ 到 $\\pi$。\n$\\int_0^{\\pi/2} \\ln(\\sin(2u)) \\,du = \\frac{1}{2}\\int_0^{\\pi} \\ln(\\sin w) \\,dw$。根据 $\\sin(w)$ 关于 $w=\\pi/2$ 的对称性，这等于 $\\frac{1}{2} \\left( 2 \\int_0^{\\pi/2} \\ln(\\sin w) \\,dw \\right) = \\int_0^{\\pi/2} \\ln(\\sin w) \\,dw = J$。\n代回原式：\n$$\n2J = J - \\frac{\\pi}{2}\\ln(2) \\implies J = -\\frac{\\pi}{2}\\ln(2)\n$$\n最后，我们可以计算 $I_2$：\n$$\nI_2 = \\frac{2}{\\pi} J = \\frac{2}{\\pi} \\left(-\\frac{\\pi}{2}\\ln(2)\\right) = -\\ln(2)\n$$\n结合 $I_1$ 和 $I_2$ 的结果：\n$$\n\\lambda = I_1 + I_2 = \\ln(4) - \\ln(2) = \\ln(2^2) - \\ln(2) = 2\\ln(2) - \\ln(2) = \\ln(2)\n$$\n对于 $r=4$ 的逻辑斯谛映射，其最大李雅普诺夫指数为 $\\ln(2)$。",
            "answer": "$$\\boxed{\\ln(2)}$$"
        }
    ]
}