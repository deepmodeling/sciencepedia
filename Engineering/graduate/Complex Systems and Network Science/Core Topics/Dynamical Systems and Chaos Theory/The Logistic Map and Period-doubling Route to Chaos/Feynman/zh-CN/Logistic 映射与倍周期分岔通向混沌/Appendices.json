{
    "hands_on_practices": [
        {
            "introduction": "在深入探讨混沌行为之前，分析一个逻辑斯谛映射行为可预测且能用精确公式描述的案例是很有启发性的。这个针对 $r=2$ 的练习将演示如何通过变量替换来简化一个非线性问题，从而推导出其闭合形式解，并严格证明系统会收敛到一个稳定的不动点。这个练习旨在锻炼解析技巧，并为理解不动点和稳定性建立直观感觉。",
            "id": "4310178",
            "problem": "考虑单位区间上的离散时间逻辑斯谛映射，其递推关系定义为 $x_{n+1} = r\\,x_n\\,(1 - x_n)$，其中 $n \\in \\mathbb{N}$ 且参数 $r \\in \\mathbb{R}$。重点研究 $r = 2$ 的情况。从迭代映射和不动点的核心定义出发：对于映射 $f(x) = r\\,x\\,(1 - x)$，不动点 $x^{\\ast}$ 满足 $x^{\\ast} = f(x^{\\ast})$；不动点的稳定性可以通过局域线性化来评估，其中 $|f'(x^{\\ast})|  1$ 意味着局域吸引。\n\n您的任务是：\n1. 对于递推关系 $x_{n+1} = 2\\,x_n\\,(1 - x_n)$，从第一性原理出发，且不使用预先给定的解形式，推导出一个关于 $x_0$ 和 $n$ 的 $x_n$ 的闭式解析表达式。\n2. 使用您得到的表达式来验证当 $x_0 \\in [0,1]$ 时 $x_n$ 的收敛性质，包括确定吸引不动点和任何例外的初始条件。\n\n请给出所有必要的步骤和论证，并使其根植于所述的定义和事实。您的最终答案必须是 $x_n$ 作为 $n$ 和 $x_0$ 的函数的单个闭式解析表达式。不需要数值取整，也不涉及物理单位。",
            "solution": "该问题要求推导参数 $r=2$ 的逻辑斯谛映射的闭式解，并基于该解分析其收敛性质。\n\n具体的递推关系由下式给出：\n$$x_{n+1} = 2x_n(1 - x_n)$$\n初始条件 $x_0$ 属于区间 $[0,1]$。\n\n为了找到 $x_n$ 的闭式解，我们寻求一种变换，将这个非线性递推关系简化为线性或更简单的形式。对于二次映射，一种标准技巧是平移变量，将映射的顶点置于原点。函数 $f(x) = 2x(1-x) = 2x - 2x^2$ 是一条抛物线，其顶点位于 $x = -\\frac{2}{2(-2)} = \\frac{1}{2}$。这启发我们进行如下的变量代换：\n$$x_n = \\frac{1}{2} - z_n$$\n将此代入递推关系中，得到：\n$$\\frac{1}{2} - z_{n+1} = 2\\left(\\frac{1}{2} - z_n\\right)\\left(1 - \\left(\\frac{1}{2} - z_n\\right)\\right)$$\n$$\\frac{1}{2} - z_{n+1} = 2\\left(\\frac{1}{2} - z_n\\right)\\left(\\frac{1}{2} + z_n\\right)$$\n右边是一个平方差：\n$$\\frac{1}{2} - z_{n+1} = 2\\left(\\left(\\frac{1}{2}\\right)^2 - z_n^2\\right)$$\n$$\\frac{1}{2} - z_{n+1} = 2\\left(\\frac{1}{4} - z_n^2\\right)$$\n$$\\frac{1}{2} - z_{n+1} = \\frac{1}{2} - 2z_n^2$$\n这就将关于 $z_n$ 的递推关系简化为一个更简单的形式：\n$$z_{n+1} = 2z_n^2$$\n我们可以通过迭代来解这个新的递推关系。\n对于 $n=1$：$z_1 = 2z_0^2$。\n对于 $n=2$：$z_2 = 2z_1^2 = 2(2z_0^2)^2 = 2(4z_0^4) = 8z_0^4$。\n对于 $n=3$：$z_3 = 2z_2^2 = 2(8z_0^4)^2 = 2(64z_0^8) = 128z_0^8$。\n我们观察到一个规律。让我们提出通项公式 $z_n = \\frac{1}{2}(2z_0)^{2^n}$。\n我们用数学归纳法来验证。当 $n=0$ 时，基础情形为 $z_0 = \\frac{1}{2}(2z_0)^{2^0} = \\frac{1}{2}(2z_0)^1 = z_0$，这是正确的。\n假设该公式对 $n$ 成立。那么 $z_{n+1} = 2z_n^2 = 2\\left(\\frac{1}{2}(2z_0)^{2^n}\\right)^2 = 2\\left(\\frac{1}{4}\\left((2z_0)^{2^n}\\right)^2\\right) = \\frac{1}{2}(2z_0)^{2^n \\times 2} = \\frac{1}{2}(2z_0)^{2^{n+1}}$。根据数学归纳法，该公式成立。\n\n现在，我们回代以求得 $x_n$ 的表达式。\n首先，用 $x_0$ 表示 $z_0$：$z_0 = \\frac{1}{2} - x_0$。\n然后将 $z_n$ 和 $z_0$ 回代到变换 $x_n = \\frac{1}{2} - z_n$ 中：\n$$x_n = \\frac{1}{2} - \\frac{1}{2}(2z_0)^{2^n}$$\n$$x_n = \\frac{1}{2}\\left(1 - (2z_0)^{2^n}\\right)$$\n$$x_n = \\frac{1}{2}\\left(1 - \\left(2\\left(\\frac{1}{2} - x_0\\right)\\right)^{2^n}\\right)$$\n$$x_n = \\frac{1}{2}\\left(1 - (1 - 2x_0)^{2^n}\\right)$$\n这就是 $x_n$ 关于 $x_0$ 和 $n$ 的闭式解析表达式。\n\n接下来，我们使用这个表达式来分析当 $x_0 \\in [0,1]$ 时的收敛性质。\n当 $n \\to \\infty$ 时，序列 $\\{x_n\\}$ 的长期行为取决于 $(1 - 2x_0)^{2^n}$ 这一项。令 $c = 1 - 2x_0$。\n由于 $x_0 \\in [0,1]$，我们有：\n$0 \\le x_0 \\le 1$\n$0 \\ge -2x_0 \\ge -2$\n$1 \\ge 1 - 2x_0 \\ge -1$\n所以，底数 $c$ 位于区间 $[-1, 1]$ 内。我们根据 $c$ 的值来分析极限。\n\n情况 1：$|c|  1$。\n这对应于 $-1  1 - 2x_0  1$。\n不等式 $1 - 2x_0  1$ 意味着 $-2x_0  0$，所以 $x_0  0$。\n不等式 $-1  1 - 2x_0$ 意味着 $2x_0  2$，所以 $x_0  1$。\n因此， $|c|  1$ 等价于 $x_0 \\in (0,1)$。\n对于这些初始条件，当 $n \\to \\infty$ 时，指数 $2^n \\to \\infty$。由于 $|c|  1$，我们有 $\\lim_{n\\to\\infty} c^{2^n} = 0$。\n因此，序列的极限为：\n$$\\lim_{n\\to\\infty} x_n = \\lim_{n\\to\\infty} \\frac{1}{2}(1 - (1 - 2x_0)^{2^n}) = \\frac{1}{2}(1 - 0) = \\frac{1}{2}$$\n对于开区间 $(0,1)$ 内的任何初始条件 $x_0$，序列都收敛到 $\\frac{1}{2}$。这表明 $x^{\\ast} = \\frac{1}{2}$ 是一个吸引不动点。\n这与给定的稳定性判据是一致的。函数 $f(x)=2x(1-x)$ 的不动点是方程 $x = 2x(1-x)$ 的解。这给出 $x=0$ 以及 $1 = 2(1-x)$，从中解得 $x=\\frac{1}{2}$。导数为 $f'(x) = 2 - 4x$。在不动点 $x^{\\ast}=\\frac{1}{2}$ 处，导数为 $f'(\\frac{1}{2}) = 2 - 4(\\frac{1}{2}) = 0$。由于 $|f'(\\frac{1}{2})| = 0  1$，该不动点是局域吸引的（更具体地说是超吸引的）。\n\n情况 2：$|c| = 1$。\n这对应于 $x_0$ 区间的端点。这些是例外的初始条件。\n子情况 2a：$c = 1$。\n$1 - 2x_0 = 1 \\implies -2x_0 = 0 \\implies x_0 = 0$。\n如果 $x_0 = 0$，闭式表达式给出 $x_n = \\frac{1}{2}(1 - 1^{2^n}) = \\frac{1}{2}(1 - 1) = 0$ 对所有 $n$ 成立。该序列为 $\\{0, 0, 0, \\dots\\}$。这就是不动点 $x^{\\ast}=0$。稳定性分析表明 $|f'(0)| = |2 - 4(0)| = 2  1$，所以这个不动点是排斥的。\n\n子情况 2b：$c = -1$。\n$1 - 2x_0 = -1 \\implies -2x_0 = -2 \\implies x_0 = 1$。\n如果 $x_0 = 1$，闭式表达式给出 $x_n = \\frac{1}{2}(1 - (-1)^{2^n})$。\n对于 $n \\ge 1$，指数 $2^n$ 是一个偶数。因此，对于所有 $n \\ge 1$，都有 $(-1)^{2^n} = 1$。\n这意味着对于所有 $n \\ge 1$，都有 $x_n = \\frac{1}{2}(1-1) = 0$。\n从 $x_0=1$ 开始的序列是 $\\{1, 0, 0, 0, \\dots\\}$。系统在一次迭代后演化到排斥不动点 $x^{\\ast}=0$。\n\n总而言之，推导出的闭式解证实了对于逻辑斯谛映射 $x_{n+1} = 2x_n(1-x_n)$，点 $x^{\\ast}=\\frac{1}{2}$ 是一个吸引不动点，其吸引盆是区间 $(0,1)$。点 $x_0=0$ 和 $x_0=1$ 是例外的初始条件，它们将导致系统趋向于排斥不动点 $x^{\\ast}=0$。",
            "answer": "$$\n\\boxed{\\frac{1}{2}\\left(1 - (1 - 2x_0)^{2^n}\\right)}\n$$"
        },
        {
            "introduction": "随着参数 $r$ 的增加，逻辑斯谛映射经历了一系列周期倍增分岔，这是一条通往混沌的普适路径。这项动手计算练习将指导你通过数值方法定位超稳定周期出现的参数值 $r_n^{\\mathrm{ss}}$，并利用这些值来估算费根鲍姆常数 $\\delta$。这是一个普适常数，它控制着许多不同系统中这一混沌转变过程。",
            "id": "4310123",
            "problem": "考虑一维离散时间逻辑斯谛映射，它由函数 $f_r:[0,1]\\to[0,1]$ 定义，其形式为 $f_r(x)=r\\,x\\,(1-x)$，其中参数 $r\\in[0,4]$。当 $r$ 接近混沌初发时，逻辑斯谛映射表现出吸引子环的倍周期序列和参数空间中的一个累积点，这可以通过超稳定环进行探究。一个超稳定的周期为 $2^n$ 的环的特征是该环包含临界点 $x=\\tfrac{1}{2}$。这样的参数 $r=r_n^{\\mathrm{ss}}$ 满足条件 $f_r^{2^n}\\!\\left(\\tfrac{1}{2}\\right)=\\tfrac{1}{2}$，其中 $f_r^{k}$ 表示 $f_r$ 与自身的 $k$ 次复合。\n\n仅使用映射迭代和连续性的基本定义，以及基于这些原理的数值求根方法，编写一个完整的、可运行的程序，该程序：\n\n1. 实现对任意整数 $k\\geq 1$ 和实数 $x\\in[0,1]$ 的复合函数 $f_r^{k}(x)$。\n2. 对于指定测试集中的每个整数 $n$，求解 $r_n^{\\mathrm{ss}}$，其定义为满足 $f_r^{2^n}\\!\\left(\\tfrac{1}{2}\\right)=\\tfrac{1}{2}$ 且大于 $r_{n-1}^{\\mathrm{ss}}$（其中 $r_0^{\\mathrm{ss}}$ 由方程 $f_r\\!\\left(\\tfrac{1}{2}\\right)=\\tfrac{1}{2}$ 定义）的最小参数 $r$。必须通过在一个 $g_n$ 变号的 $r$ 区间内，寻找连续函数 $g_n(r)=f_r^{2^n}\\!\\left(\\tfrac{1}{2}\\right)-\\tfrac{1}{2}$ 的根来获得解。\n3. 计算由连续区间比值定义的 Feigenbaum 标度估计值 $\\delta_n$\n$$\n\\delta_n=\\frac{r_{n-1}^{\\mathrm{ss}}-r_{n-2}^{\\mathrm{ss}}}{r_n^{\\mathrm{ss}}-r_{n-1}^{\\mathrm{ss}}}\n$$\n对于测试集中所有该表达式有定义的 $n$。已知这些比值会趋近于与倍周期通往混沌路径相关的 Feigenbaum 常数 $\\delta$。\n\n您的算法必须从核心定义和事实出发：逻辑斯谛映射 $f_r(x)=r\\,x\\,(1-x)$、复合 $f_r^{k}$、固定迭代深度下对 $r$ 的连续性，以及用于证明基于区间划定的求根过程合理性的介值定理。除了这些基础知识外，避免使用任何非推导的快捷公式。\n\n测试集：\n- 计算 $n\\in\\{0,1,2,3,4,5\\}$ 的 $r_n^{\\mathrm{ss}}$，约定 $r_0^{\\mathrm{ss}}$ 解方程 $f_r\\!\\left(\\tfrac{1}{2}\\right)=\\tfrac{1}{2}$。\n- 根据上述定义计算 $n\\in\\{2,3,4,5\\}$ 的 $\\delta_n$。\n\n输出规格：\n- 您的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表，顺序为 $[r_0^{\\mathrm{ss}},r_1^{\\mathrm{ss}},r_2^{\\mathrm{ss}},r_3^{\\mathrm{ss}},r_4^{\\mathrm{ss}},r_5^{\\mathrm{ss}},\\delta_2,\\delta_3,\\delta_4,\\delta_5]$。\n- 每个数值条目必须表示为一个（无单位的）实数，并四舍五入到 $12$ 位小数。\n- 不得打印任何其他文本或格式。\n\n科学真实性要求：\n- 使用区间划定和二分法（或等效的连续区间划定方法）来定位每个根 $r_n^{\\mathrm{ss}}$，该根是大于 $r_{n-1}^{\\mathrm{ss}}$ 并且在主倍周期级联的科学合理上限（例如 $r\\leq 3.58$）内的最小解。\n- 确保所有计算均使用基于给定定义的确定性数值程序进行。",
            "solution": "用户请求一个关于逻辑斯谛映射和 Feigenbaum 常数的计算问题的解决方案。问题陈述已经过验证，被认定为具有科学依据、问题明确且客观。它代表了计算物理和混沌系统研究中的一个标准练习。解决方案如下。\n\n### **问题验证**\n\n**第1步：提取已知条件**\n-   **逻辑斯谛映射：** $f_r:[0,1]\\to[0,1]$，由 $f_r(x)=r\\,x\\,(1-x)$ 定义，其中参数 $r\\in[0,4]$。\n-   **映射复合：** $f_r^k$ 是 $f_r$ 与自身的 $k$ 次复合。\n-   **超稳定环条件：** 当参数 $r=r_n^{\\mathrm{ss}}$ 满足条件 $f_r^{2^n}\\!\\left(\\tfrac{1}{2}\\right)=\\tfrac{1}{2}$ 时，存在一个超稳定的周期为 $2^n$ 的环，因为该环必须包含映射的临界点 $x=\\tfrac{1}{2}$。\n-   **任务1：实现：** 实现复合映射 $f_r^k(x)$。\n-   **任务2：求根：** 对于每个 $n \\in \\{0, 1, 2, 3, 4, 5\\}$，求解 $r_n^{\\mathrm{ss}}$。\n    -   $r_0^{\\mathrm{ss}}$ 由方程 $f_r(\\tfrac{1}{2})=\\tfrac{1}{2}$ 的解定义。\n    -   对于 $n  0$，$r_n^{\\mathrm{ss}}$ 是满足超稳定条件且大于 $r_{n-1}^{\\mathrm{ss}}$ 的最小参数值 $r$。\n    -   该方法必须是对函数 $g_n(r)=f_r^{2^n}\\!\\left(\\tfrac{1}{2}\\right)-\\tfrac{1}{2}$ 进行数值求根，使用区间划定法，其合理性由介值定理保证。\n-   **任务3：Feigenbaum Delta 计算：** 计算标度估计值 $\\delta_n=\\frac{r_{n-1}^{\\mathrm{ss}}-r_{n-2}^{\\mathrm{ss}}}{r_n^{\\mathrm{ss}}-r_{n-1}^{\\mathrm{ss}}}$，其中 $n \\in \\{2, 3, 4, 5\\}$。\n-   **测试集与输出：** 计算 $[r_0^{\\mathrm{ss}}, r_1^{\\mathrm{ss}}, ..., r_5^{\\mathrm{ss}}, \\delta_2, ..., \\delta_5]$，每个值四舍五入到 $12$ 位小数。\n-   **约束条件：** 仅使用基本定义。根的搜索应在合理的参数范围内进行，例如 $r \\le 3.58$。\n\n**第2步：验证结论**\n该问题有效。它是一个定义明确的数学问题，植根于已建立的动力系统和混沌理论。所有术语都有正式定义，目标清晰，所要求的方法论具体且恰当。问题是自洽的，没有矛盾或歧义。\n\n### **基于原理的解决方案设计**\n\n问题的核心是找到特定的参数值 $r_n^{\\mathrm{ss}}$，在这些值下逻辑斯谛映射表现出周期为 $2^n$ 的超稳定环。解决方案是通过将数学定义直接转化为数值算法来构建的。\n\n**1. 映射复合函数**\n首先，我们实现函数 $f_r^k(x)$，它代表逻辑斯谛映射 $f_r(x) = r\\,x\\,(1-x)$ 的第 $k$ 次迭代。这通过一个简单的循环实现，该循环从初始值 $x$ 开始，将映射公式应用 $k$ 次。这个我们称之为 `logistic_map_composed(k, r, x)` 的函数是基本构建模块。\n\n**2. 超稳定环方程**\n周期为 $2^n$ 的超稳定环的条件是 $f_r^{2^n}\\!\\left(\\tfrac{1}{2}\\right)=\\tfrac{1}{2}$。为了使用数值求根器求解 $r$，我们定义一个目标函数 $g_n(r) = f_r^{2^n}\\!\\left(\\tfrac{1}{2}\\right) - \\tfrac{1}{2}$。$g_n(r)=0$ 的根对应于所需的参数值 $r_n^{\\mathrm{ss}}$。该函数关于 $r$ 是连续的，这证明了使用如二分法或 Brent 方法等区间划定求根方法的合理性，因为如果能找到一个区间 $[a, b]$ 使得 $g_n(a)$ 和 $g_n(b)$ 异号（这是介值定理的一个推论），则这些方法保证收敛。\n\n**3. 顺序求根**\n问题要求按顺序找到 $n=0, 1, \\dots, 5$ 的参数 $r_n^{\\mathrm{ss}}$。\n\n-   **基本情况 ($n=0$):** 我们需要解 $f_r(\\tfrac{1}{2}) = \\tfrac{1}{2}$。这就是 $r(\\tfrac{1}{2})(1-\\tfrac{1}{2}) = \\tfrac{1}{2}$，化简为 $r/4 = \\tfrac{1}{2}$，得到解析解 $r_0^{\\mathrm{ss}} = 2$。为了与方法论保持一致，我们将通过找到 $g_0(r) = f_r^1(\\tfrac{1}{2}) - \\tfrac{1}{2} = 0$ 的根来数值求解。一个合适的区间是 $[1, 3]$，因为 $g_0(1) = -0.25$ 且 $g_0(3) = 0.25$。\n\n-   **迭代步骤 ($n  0$):** 对于每个 $n$，我们必须找到大于先前找到的根 $r_{n-1}^{\\mathrm{ss}}$ 的 $g_n(r) = 0$ 的最小根。一个关键的观察是，如果 $r_{n-1}^{\\mathrm{ss}}$ 产生一个周期为 $2^{n-1}$ 的超稳定环，那么 $f_{r_{n-1}^{\\mathrm{ss}}}^{2^{n-1}}(\\tfrac{1}{2}) = \\tfrac{1}{2}$。由此得出 $f_{r_{n-1}^{\\mathrm{ss}}}^{2^n}(\\tfrac{1}{2}) = f_{r_{n-1}^{\\mathrm{ss}}}^{2^{n-1}}(f_{r_{n-1}^{\\mathrm{ss}}}^{2^{n-1}}(\\tfrac{1}{2})) = f_{r_{n-1}^{\\mathrm{ss}}}^{2^{n-1}}(\\tfrac{1}{2}) = \\tfrac{1}{2}$，这意味着 $g_n(r_{n-1}^{\\mathrm{ss}}) = 0$。因此，$r_{n-1}^{\\mathrm{ss}}$ 也是 $g_n(r)=0$ 的一个根。我们的任务是找到*下一个*根。\n\n    为此，我们建立一个从恰好大于 $r_{n-1}^{\\mathrm{ss}}$ 的地方开始的搜索区间。设我们搜索的下界为 $a = r_{n-1}^{\\mathrm{ss}} + \\epsilon$，其中 $\\epsilon  0$ 是一个非常小的数。然后我们以一个小的步长递增，对 $r  a$ 进行采样，直到找到一个值 $b$ 使得 $\\mathrm{sign}(g_n(a)) \\neq \\mathrm{sign}(g_n(b))$。这个区间 $[a, b]$ 就成为根 $r_n^{\\mathrm{ss}}$ 的一个有效区间。此搜索的步长必须小于预期的距离 $r_n^{\\mathrm{ss}} - r_{n-1}^{\\mathrm{ss}}$ 以确保我们不会跳过所要找的根。由于这个距离按几何级数减小，因此选择一个足够小的步长（例如 $10^{-6}$）。一旦找到区间，就使用像 Brent 方法（`scipy.optimize.brentq`）这样的稳健算法来高精度地找到根。\n\n**4. Feigenbaum Delta 计算**\n在计算出序列 $[r_0^{\\mathrm{ss}}, \\dots, r_5^{\\mathrm{ss}}]$ 之后，对于 $n \\in \\{2, 3, 4, 5\\}$ 的 Feigenbaum 比率估计值 $\\delta_n$ 直接根据其定义计算：$\\delta_n = (r_{n-1}^{\\mathrm{ss}} - r_{n-2}^{\\mathrm{ss}}) / (r_n^{\\mathrm{ss}} - r_{n-1}^{\\mathrm{ss}})$。已知这些值收敛于普适的 Feigenbaum 常数 $\\delta \\approx 4.669201...$。\n\n**5. 实现**\n该算法使用 Python 实现，借助 `numpy` 库来保证数值稳定性，并使用 `scipy.optimize.brentq` 函数进行高效精确的求根。所有计算都使用标准的双精度浮点运算（`float64`）执行，这对于在这些迭代级别上达到所需精度是足够的。收集最终结果并按要求格式化为 $12$ 位小数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import brentq\n\ndef solve():\n    \"\"\"\n    Computes the superstable cycle parameters r_n and Feigenbaum delta estimates\n    for the logistic map, based on fundamental definitions and numerical root-finding.\n    \"\"\"\n    \n    def logistic_map_composed(k: int, r: float, x: float) - float:\n        \"\"\"\n        Computes the k-th composition of the logistic map f_r(x).\n        \n        Args:\n            k: The number of compositions (integer = 1).\n            r: The logistic map parameter.\n            x: The initial value.\n            \n        Returns:\n            The value of f_r^k(x).\n        \"\"\"\n        val = x\n        for _ in range(k):\n            val = r * val * (1.0 - val)\n        return val\n\n    def g_n_func(r: float, n: int) - float:\n        \"\"\"\n        The objective function g_n(r) = f_r^(2^n)(1/2) - 1/2.\n        The roots of this function are the superstable cycle parameters.\n        \n        Args:\n            r: The logistic map parameter.\n            n: The period-doubling level.\n            \n        Returns:\n            The value of g_n(r).\n        \"\"\"\n        k = 2**n\n        x0 = 0.5\n        return logistic_map_composed(k, r, x0) - x0\n\n    r_ss = []\n    \n    # n=0: Find r_0^ss\n    # The condition is f_r(1/2) = 1/2, which analytically gives r=2.\n    # We solve numerically using brentq for methodological consistency.\n    # A bracket is [1.0, 3.0] since g_0(1)=-0.25 and g_0(3)=0.25.\n    try:\n        r0 = brentq(g_n_func, 1.0, 3.0, args=(0,))\n        r_ss.append(r0)\n    except ValueError:\n        # This fallback should not be needed for this well-behaved case.\n        r_ss.append(2.0)\n\n    # Sequentially find r_n^ss for n = 1, 2, 3, 4, 5\n    max_r = 3.58  # Scientific realism constraint from problem statement.\n    num_n = 5\n\n    for n in range(1, num_n + 1):\n        r_prev = r_ss[n-1]\n        \n        # We search for the smallest root r  r_prev. We know that r_prev is also a\n        # root of g_n(r), so we must start our search for a bracketing interval\n        # just above r_prev.\n        \n        # Start search slightly above the previous root.\n        bracket_a = r_prev + 1e-9\n        sign_a = np.sign(g_n_func(bracket_a, n))\n\n        # Handle unlikely case where start point is a root.\n        if sign_a == 0:\n            bracket_a += 1e-9 \n            sign_a = np.sign(g_n_func(bracket_a, n))\n\n        # The search step for the bracket's other end must be small enough to\n        # not miss the first root. The distance between roots shrinks by ~4.669 each time.\n        # r_5 - r_4 is on the order of 10^-3, so 10^-6 is a safe step size.\n        search_step = 1e-6\n        bracket_b = bracket_a\n        \n        found_bracket = False\n        while bracket_b = max_r:\n            bracket_b += search_step\n            if np.sign(g_n_func(bracket_b, n)) != sign_a:\n                found_bracket = True\n                break\n        \n        if not found_bracket:\n            raise RuntimeError(f\"Could not find a root-finding bracket for n={n} within r = {max_r}\")\n\n        # Use brentq to find the precise root within the bracket [bracket_a, bracket_b].\n        r_n = brentq(g_n_func, bracket_a, bracket_b, args=(n,))\n        r_ss.append(r_n)\n\n    # Compute the Feigenbaum delta estimates\n    deltas = []\n    for n in range(2, num_n + 1):\n        delta = (r_ss[n-1] - r_ss[n-2]) / (r_ss[n] - r_ss[n-1])\n        deltas.append(delta)\n\n    # Combine results and format for output\n    final_results = r_ss + deltas\n    formatted_results = [f\"{x:.12f}\" for x in final_results]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在周期倍增级联的终点，即参数 $r = r_{\\infty}$ 处，吸引子不再是有限的点集，而是一个复杂的、自相似的分形结构。这个实践项目将通过实现“盒计数”算法，来数值估算这个“奇异吸引子”的分形维数，为其几何复杂性提供一个定量的度量。",
            "id": "4310136",
            "problem": "你将使用以下数学基础，为一个在一维逻辑斯蒂映射（logistic map）周期倍增（period-doubling）积累点上的吸引子（attractor），实现一个盒计数维度（box-counting dimension）的数值估计器：逻辑斯蒂映射的定义、吸引子的概念，以及盒计数（容量）维度的定义。逻辑斯蒂映射在区间 $[0,1]$ 上定义为 $x_{n+1} = r x_n (1 - x_n)$，其中 $r$ 是一个实数参数，$x_n$ 表示在离散时间 $n$ 的状态。周期倍增积累参数为 $r_{\\infty} \\approx 3.569945672$，它是在稳定轨道的周期加倍时，分岔（bifurcation）参数序列的极限。在 $r = r_{\\infty}$ 时，长期动力学行为被支撑在一个分形吸引子上。\n\n一个集合 $A \\subset \\mathbb{R}$ 的盒计数（容量）维度 $D_0$ 定义为\n$$\nD_0 = \\lim_{\\varepsilon \\to 0} \\frac{\\log N(\\varepsilon)}{\\log(1/\\varepsilon)},\n$$\n其中 $N(\\varepsilon)$ 是覆盖集合 $A$ 所需的长度为 $\\varepsilon$ 的最小区间（盒子）数量。在实践中，对于一个采样的有限子集 $S \\subset A$，当将 $[0,1]$ 划分为 $M$ 个宽度为 $\\varepsilon = 1/M$ 的等长单元格（bin）时，通过计算被占据的单元格数量来估计 $N(\\varepsilon)$，并且可能会通过对多个网格偏移（grid offsets）进行平均来减少对齐偏差（alignment bias）。\n\n任务要求：\n- 推导并实现一个程序，该程序：\n  1. 为逻辑斯蒂映射 $x_{n+1} = r x_n (1 - x_n)$ 生成一个数值轨道，需提供给定的初始条件 $x_0 \\in (0,1)$、一个指定的要丢弃的瞬态迭代次数，以及要保留的样本大小。允许使用一个可选的步幅（stride）来稀疏化保留的样本，以减少短期相关性。\n  2. 对一组尺度 $\\{\\varepsilon_k\\}$，使用每个尺度 $M_k = 1/\\varepsilon_k$ 个单元格，通过计算非空单元格的数量来估计 $N(\\varepsilon)$。为减少边界引起的偏差，在分箱前通过对数据进行移位并在模1下环绕（wrapping modulo 1），来对 $[0,\\varepsilon_k)$ 区间内的 $K$ 个均匀间隔的网格偏移上的盒子计数进行平均。\n  3. 对所提供尺度范围内的 $\\log N(\\varepsilon_k)$ 与 $\\log(1/\\varepsilon_k)$ 进行普通最小二乘回归（ordinary least squares regression），以估计斜率作为盒计数维度 $\\widehat{D}_0$。同时，从回归中计算斜率的标准误差（standard error）作为拟合不确定性的度量，但最终输出将只报告 $\\widehat{D}_0$。\n- 通过从上述定义中论证每一步并清晰地指定所有数值参数，来确保科学真实性。\n- 不允许使用任何维度的快捷公式；估计器必须从定义中推导出来。\n\n测试套件：\n你必须在以下三个参数集上运行你的估计器，每个参数集指定为一个元组 $(r, x_0, \\text{sample\\_size}, \\text{discard}, \\text{stride}, \\{M_k\\}, K)$，其中 $M_k$ 是每个尺度的盒子数量，$K$ 是每个尺度的偏移量数量：\n1. 情况A（理想路径，$r_{\\infty}$ 并有足够的采样）： $(r = 3.569945672, x_0 = 0.123456789, \\text{sample\\_size} = 120000, \\text{discard} = 50000, \\text{stride} = 1, \\{M_k\\} = \\{64, 128, 256, 512, 1024\\}, K = 7)$。\n2. 情况B（边缘情况，$r_{\\infty}$ 且采样较少以暴露有限样本偏差）： $(r = 3.569945672, x_0 = 0.123456789, \\text{sample\\_size} = 20000, \\text{discard} = 50000, \\text{stride} = 1, \\{M_k\\} = \\{64, 128, 256, 512, 1024\\}, K = 7)$。\n3. 情况C（边界比较，区间上的完全混沌映射）： $(r = 4.0, x_0 = 0.123456789, \\text{sample\\_size} = 120000, \\text{discard} = 1000, \\text{stride} = 1, \\{M_k\\} = \\{64, 128, 256, 512, 1024\\}, K = 7)$。\n\n最终输出格式：\n- 你的程序应产生单行输出，其中包含上述测试用例的三个盒计数维度估计值 $\\widehat{D}_0$，以逗号分隔，保留六位小数，并用方括号括起来。例如，输出应如下所示：$[0.538000,0.532100,0.999500]$。\n- 不应打印任何其他文本。\n\n注意：\n- 所有计算都是无量纲的；不涉及任何物理单位。\n- 不使用角度。\n- 不得使用百分比；报告原始十进制数值。",
            "solution": "我们从逻辑斯蒂映射和盒计数维度的定义开始。逻辑斯蒂映射定义为 $x_{n+1} = r x_n (1 - x_n)$，其中 $x_n \\in [0,1]$ 且 $r \\in [0,4]$。参数 $r_{\\infty}$ 是周期倍增分岔序列的极限，标志着通过周期倍增路径进入混沌的开始。在 $r = r_{\\infty}$ 时，支撑动力学行为的不变集是一个类康托尔（Cantor-like）分形吸引子。\n\n一个集合 $A \\subset \\mathbb{R}$ 的盒计数（容量）维度，记为 $D_0$，由\n$$\nD_0 = \\lim_{\\varepsilon \\to 0} \\frac{\\log N(\\varepsilon)}{\\log(1/\\varepsilon)},\n$$\n给出，其中 $N(\\varepsilon)$ 是覆盖 $A$ 所需的长度为 $\\varepsilon$ 的最小区间数。这是一个基本定义；我们的估计器必须使用有限数据来模拟这个极限。对于一个采样得到的子集 $S \\subset A$，我们通过将区间 $[0,1]$ 划分成 $M = 1/\\varepsilon$ 个宽度为 $\\varepsilon = 1/M$ 的等长单元格，并计算被占据的单元格数量来近似 $N(\\varepsilon)$。为减轻盒子对齐相对于集合几何形状所产生的偏差，我们对 $K$ 个偏移量上的占据数进行平均。对于每个偏移量，我们将数据移动一个量 $s \\in [0,\\varepsilon)$，并以模1进行环绕处理，这样单元格的边界就等效地平移了，同时仍然覆盖整个区间。\n\n算法推导：\n1. 轨道生成：对于给定的 $r$、初始条件 $x_0$ 以及用于瞬态丢弃和样本大小的整数，我们计算迭代 $x_{n+1} = r x_n (1 - x_n)$（对于 $n = 0,1,\\dots$），丢弃前 $\\text{discard}$ 个值以移除瞬态部分，并保留接下来的 $\\text{sample\\_size}$ 个点。一个可选的步幅 $\\text{stride}$ 可以保留每 $\\text{stride}$ 个点，以在不改变吸引子支撑集的情况下减少短期相关性。\n\n2. 在尺度 $\\varepsilon = 1/M$ 上的盒子占据情况：对于固定的 $M$，我们考虑 $K$ 个偏移量 $s_j = j \\varepsilon / K$（对于 $j=0,1,\\dots,K-1$）。对于每个偏移量 $s_j$，我们通过 $y_i = x_i - s_j$ 变换样本，然后进行环绕处理：如果 $y_i  0$，则用 $y_i + 1$ 替换 $y_i$。此操作将样本映射到 $[0,1]$ 上，同时有效地移动了单元格网格。然后我们将 $[0,1]$ 划分为 $M$ 个单元格，并计算非零占据的单元格数量。最终的盒子数 $N(\\varepsilon)$ 是 $K$ 个偏移量上计数的平均值。\n\n3. 维度估计：设尺度由 $M_k \\in \\{64, 128, 256, 512, 1024\\}$ 给出，因此 $\\varepsilon_k = 1/M_k$。计算 $x_k = \\log(1/\\varepsilon_k) = \\log(M_k)$ 和 $y_k = \\log N(\\varepsilon_k)$。使用普通最小二乘法拟合线性模型 $y_k = \\beta_0 + \\beta_1 x_k + \\varepsilon_k$，其中 $\\beta_1$ 是斜率。估计的斜率 $\\widehat{\\beta}_1$ 即为我们的估计器 $\\widehat{D}_0$。计算斜率的标准误差以评估拟合质量：如果 $\\widehat{y}_k = \\widehat{\\beta}_0 + \\widehat{\\beta}_1 x_k$，残差为 $r_k = y_k - \\widehat{y}_k$，残差方差为 $\\widehat{\\sigma}^2 = \\sum_k r_k^2 / (n - 2)$，斜率的标准误差为 $\\text{SE}(\\widehat{\\beta}_1) = \\sqrt{\\widehat{\\sigma}^2 / \\sum_k (x_k - \\bar{x})^2}$，其中 $n$ 是尺度的数量。\n\n基于第一性原理的论证：\n- 该估计器通过在对数-对数（log-log）尺度上进行线性回归，直接实现了 $D_0$ 的定义，这是检测幂律标度（power-law scaling）的标准方法。对偏移量进行平均可以减少由于单元格网格相对于吸引子空隙（lacunae）的对齐而产生的系统误差。\n- 丢弃瞬态部分是合理的，因为在一般的初始条件 $x_0$ 下，早期的迭代会向不变集收敛；包含这些瞬态部分会因过度表示吸引子之外的区域而使占据计数产生偏差。\n- 包含步幅是为了减少有限时间序列中的短期时间相关性，而不改变其几何支撑集。这一点很重要，因为连续的迭代可能会以某种方式聚集，从而在精细尺度上暂时性地使占据计数产生偏差。\n\n误差来源及缓解措施：\n- 有限样本大小：由于只有有限数量的点，当 $\\varepsilon$ 减小时，$N(\\varepsilon)$ 会达到饱和，导致 $\\log N$ 与 $\\log(1/\\varepsilon)$ 的关系图中出现曲率。增加样本大小和选择合适的 $M_k$ 范围可以缓解此问题，但会受到计算预算的限制。\n- 尺度选择：如果 $M_k$ 值太小（粗糙的单元格），几何结构将得不到充分解析；如果太大（精细的单元格），占据情况会受到有限样本和数值精度的限制。理想情况是选择一个能提供明显线性区域的中等范围的 $M_k$。\n- 网格对齐偏差：固定的网格可能会交替地高估或低估空隙集（lacunar sets）；在 $[0,\\varepsilon)$ 上对多个偏移量进行平均可以减少这种偏差。\n- 在 $r_{\\infty}$ 处的参数不确定性：使用 $r_{\\infty}$ 的有限精度近似值会引入微小偏差；这可以通过长的瞬态过程和采样来缓解，尽管这只是对严格在 $r_{\\infty}$ 处的豪斯多夫维度（Hausdorff dimension）的近似。\n- 数值精度和舍入误差：迭代 $x_{n+1} = r x_n (1 - x_n)$ 会累积浮点误差；然而，对于指定的样本大小，双精度通常是足够的。\n- 时间相关性：如果不进行稀疏化处理，邻近的迭代点可能会聚集在同一个盒子内；步幅以减少点数为代价降低了序列相关性。\n\n测试用例：\n- 情况A针对 $r = r_{\\infty}$，并有足够的采样以获得一个合理的标度窗口，旨在得到一个小于1的维度。\n- 情况B使用较少的样本以暴露有限样本偏差和较大的标准误差。\n- 情况C使用 $r = 4.0$，此时吸引子是整个区间 $[0,1]$，其维度为1；估计器应返回一个接近1的值。\n\n输出规格：\n- 程序应打印单行输出，按顺序包含情况A、B和C的三个估计值 $\\widehat{D}_0$，保留六位小数，用方括号括起，并用逗号分隔，无空格，例如 $[0.538000,0.532100,0.999500]$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef logistic_orbit(r: float, x0: float, sample_size: int, discard: int, stride: int) - np.ndarray:\n    \"\"\"\n    Generate a logistic map orbit: x_{n+1} = r x_n (1 - x_n), discarding transients and retaining samples.\n    Parameters:\n        r: logistic map parameter.\n        x0: initial condition in (0,1).\n        sample_size: number of points to retain.\n        discard: number of transient iterations to discard.\n        stride: keep every `stride`-th point after transient.\n    Returns:\n        points: numpy array of retained points of length `sample_size`.\n    \"\"\"\n    total_iters = discard + sample_size * stride\n    x = x0\n    retained = np.empty(sample_size, dtype=np.float64)\n    idx = 0\n    for n in range(total_iters):\n        x = r * x * (1.0 - x)\n        if n = discard:\n            if (n - discard) % stride == 0:\n                retained[idx] = x\n                idx += 1\n                if idx = sample_size:\n                    break\n    return retained\n\ndef average_box_count(points: np.ndarray, M: int, offsets: int) - float:\n    \"\"\"\n    Compute average number of occupied boxes over multiple offsets for given scale M (number of bins).\n    Parameters:\n        points: sample points in [0,1].\n        M: number of bins (boxes), epsilon = 1/M.\n        offsets: number of offsets to average over.\n    Returns:\n        avg_count: average occupied box count across offsets.\n    \"\"\"\n    eps = 1.0 / M\n    counts = []\n    # Evenly spaced offsets in [0, eps)\n    for j in range(offsets):\n        s = (j / offsets) * eps\n        shifted = points - s\n        # Wrap modulo 1 without using slow Python mod\n        shifted = shifted.copy()\n        mask = shifted  0.0\n        if np.any(mask):\n            shifted[mask] += 1.0\n        hist = np.histogram(shifted, bins=M, range=(0.0, 1.0))[0]\n        count = np.count_nonzero(hist)\n        counts.append(count)\n    return float(np.mean(counts))\n\ndef estimate_box_dimension(points: np.ndarray, Ms: np.ndarray, offsets: int) - float:\n    \"\"\"\n    Estimate box-counting dimension from points using scales Ms and averaging over offsets.\n    Parameters:\n        points: sample points.\n        Ms: array of numbers of bins (scales).\n        offsets: number of offsets per scale.\n    Returns:\n        dimension_estimate: slope of log N vs log M.\n    \"\"\"\n    Ms = np.asarray(Ms, dtype=np.int64)\n    log_M = np.log(Ms.astype(np.float64))\n    log_N = np.empty_like(log_M)\n    for i, M in enumerate(Ms):\n        N_avg = average_box_count(points, int(M), offsets)\n        # Prevent log(0) by ensuring at least 1 occupied bin (for degenerate cases)\n        N_eff = max(N_avg, 1.0)\n        log_N[i] = np.log(N_eff)\n    # Ordinary least squares for slope and intercept\n    x = log_M\n    y = log_N\n    X = np.vstack([x, np.ones_like(x)]).T\n    beta, _, _, _ = np.linalg.lstsq(X, y, rcond=None)\n    slope = float(beta[0])\n    return slope\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each test case: (r, x0, sample_size, discard, stride, Ms_list, offsets)\n    test_cases = [\n        (3.569945672, 0.123456789, 120000, 50000, 1, [64, 128, 256, 512, 1024], 7),   # Case A\n        (3.569945672, 0.123456789, 20000, 50000, 1, [64, 128, 256, 512, 1024], 7),    # Case B\n        (4.0,         0.123456789, 120000, 1000,  1, [64, 128, 256, 512, 1024], 7),   # Case C\n    ]\n\n    results = []\n    for r, x0, sample_size, discard, stride, Ms_list, offsets in test_cases:\n        points = logistic_orbit(r, x0, sample_size, discard, stride)\n        d_est = estimate_box_dimension(points, np.array(Ms_list, dtype=np.int64), offsets)\n        results.append(f\"{d_est:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}