{
    "hands_on_practices": [
        {
            "introduction": "The first step in any spectral analysis is decomposing a signal into its constituent frequencies. This practice provides hands-on experience using the Discrete Fourier Transform (DFT) to analyze synthetic signals, similar to those representing harmonic phenomena in Earth systems. By implementing the DFT and calculating the one-sided amplitude spectrum, you will develop the fundamental skill of identifying which frequencies are present in a a dataset and correctly quantifying their physical amplitudes .",
            "id": "3914642",
            "problem": "You are tasked with designing and implementing a program that computes the Discrete Fourier Transform (DFT) of real-valued, uniformly sampled synthetic signals that represent idealized harmonic constituents used in environmental and earth system modeling (for example, diurnal and semidiurnal tidal harmonics in ocean or atmospheric dynamics). The goal is to determine which nonnegative frequency bins correspond to nonzero sinusoidal components and to report their amplitudes using a one-sided amplitude spectrum that is physically meaningful for real signals.\n\nFundamental basis and definitions:\n- The Discrete Fourier Transform (DFT) of a length-$N$ complex sequence $\\{u_n\\}_{n=0}^{N-1}$ is defined by\n$$\nU_k = \\sum_{n=0}^{N-1} u_n \\, e^{-i \\, 2\\pi k n / N}, \\quad k=0,1,\\dots,N-1,\n$$\nwhere $i$ is the imaginary unit and $e^{(\\cdot)}$ denotes the exponential function.\n- A real sinusoidal component of the form $A \\sin\\!\\big(2\\pi m n / N + \\phi\\big)$ or $A \\cos\\!\\big(2\\pi m n / N + \\phi\\big)$, with integer $m \\in \\{0,1,\\dots,N-1\\}$, contributes energy at frequency bins $k=m$ and $k=N-m$ in the two-sided spectrum, with special cases at $k=0$ (direct current) and $k=N/2$ (Nyquist) when $N$ is even.\n\nAmplitude reporting convention:\n- You must report amplitudes using the one-sided amplitude spectrum $A_k$ for nonnegative frequency bins $k \\in \\{0,1,\\dots,\\lfloor N/2 \\rfloor\\}$, defined from $U_k$ by\n$$\nA_k =\n\\begin{cases}\n\\frac{|U_k|}{N}, & \\text{if } k=0 \\text{ or } k=\\frac{N}{2} \\text{ (when } N \\text{ is even)} \\\\\n\\frac{2|U_k|}{N}, & \\text{if } 1 \\le k \\le \\frac{N}{2}-1 \\text{ (when } N \\text{ is even)}\n\\end{cases}\n$$\nand analogously for odd $N$ where only $k=0$ uses the first case. Here $|\\cdot|$ denotes the complex modulus. This convention ensures that pure real sinusoids of amplitude $A$ at bin $k$ appear with $A_k = A$ in the one-sided spectrum, while avoiding double counting of symmetric conjugate pairs. Angles are in radians.\n\nBin identification:\n- Identify all nonnegative frequency bins $k$ whose one-sided amplitudes $A_k$ exceed a fixed absolute tolerance $\\tau = 10^{-8}$. Return the list of such $k$ sorted in strictly increasing order, along with the corresponding amplitudes $A_k$ rounded to six decimal places.\n\nNumerical and algorithmic constraints:\n- Compute the DFT exactly as defined above using standard numerical libraries. You may use a Fast Fourier Transform (FFT) implementation consistent with the DFT definition.\n- All arrays are finite and of length $N$ as specified per test case. No windowing or zero-padding is to be performed unless explicitly specified (it is not in this problem).\n\nTest suite:\nImplement your program to process the following five test cases. Each signal is real-valued and defined for $n \\in \\{0,1,\\dots,N-1\\}$:\n1. $N=32$, $u_n = \\sin\\!\\left(2\\pi \\frac{n}{8}\\right) + \\sin\\!\\left(2\\pi \\frac{n}{16}\\right)$.\n2. $N=32$, $u_n = 0.5 + \\sin\\!\\left(2\\pi \\frac{n}{8}\\right)$. The constant term is the direct current (DC) component.\n3. $N=32$, $u_n = \\cos\\!\\left(\\pi n\\right)$. This is the Nyquist component for even $N$.\n4. $N=64$, $u_n = 1.2 \\, \\sin\\!\\left(2\\pi \\frac{5 n}{64} + 0.3\\right)$.\n5. $N=64$, $u_n = 0.3 + 0.8 \\, \\cos\\!\\left(2\\pi \\frac{10 n}{64}\\right) + 0.5 \\, \\sin\\!\\left(2\\pi \\frac{12 n}{64}\\right)$.\n\nFor each test case, produce as output a pair consisting of:\n- the sorted list of detected nonnegative frequency bins $k$;\n- the list of the corresponding one-sided amplitudes $A_k$, each rounded to six decimal places.\n\nFinal output format:\n- Your program should produce a single line of output containing the results for the five test cases as a comma-separated list enclosed in square brackets, with each test case represented as a two-element list. For example:\n`[[[k_1,k_2],[A_1,A_2]],[...],[...],[...],[...]]`\n- The final output must contain no spaces.\n- All numerical values must be plain decimals. There are no physical units to report in this problem.\n- The outputs must be comprised of booleans, integers, floats, or lists of these.\n\nYour implementation should be entirely self-contained and require no user input.",
            "solution": "The problem statement is assessed to be valid. It is scientifically grounded in the principles of Fourier analysis, well-posed with a clear and complete set of definitions and constraints, and formulated using objective, formal language. There are no contradictions, ambiguities, or factual inaccuracies. The task is a standard application of the Discrete Fourier Transform (DFT) in signal processing, relevant to the specified domain of environmental and earth system modeling. We may, therefore, proceed with a solution.\n\nThe core of this problem is to compute the one-sided amplitude spectrum of several real-valued discrete signals. For a real-valued signal $\\{u_n\\}_{n=0}^{N-1}$, the DFT coefficients $\\{U_k\\}_{k=0}^{N-1}$ exhibit conjugate symmetry, i.e., $U_k = U_{N-k}^*$ for $k=1, \\dots, N-1$, where the asterisk denotes the complex conjugate. This symmetry implies that the magnitudes are symmetric, $|U_k| = |U_{N-k}|$, meaning the frequency information for $k > N/2$ is redundant. A one-sided spectrum consolidates the power from the symmetric negative-frequency-equivalent bins ($k$ and $N-k$) into the single positive frequency bin $k$, providing a more physically intuitive representation of amplitude.\n\nThe procedure to solve the problem for each test case is as follows:\n\n1.  **Signal Generation**: For a given signal definition $u_n$ and sample count $N$, generate the discrete sequence $\\{u_n\\}_{n=0}^{N-1}$. The independent variable is the discrete index $n$, which runs from $0$ to $N-1$.\n\n2.  **DFT Computation**: Compute the DFT of the sequence $\\{u_n\\}$ to obtain the complex-valued frequency-domain representation $\\{U_k\\}_{k=0}^{N-1}$ using the formula:\n    $$\n    U_k = \\sum_{n=0}^{N-1} u_n \\, e^{-i \\, 2\\pi k n / N}\n    $$\n    This is computationally implemented using a standard Fast Fourier Transform (FFT) algorithm, which is an efficient method to compute the DFT.\n\n3.  **One-Sided Amplitude Spectrum Calculation**: From the DFT coefficients $\\{U_k\\}$, we construct the one-sided amplitude spectrum $\\{A_k\\}$ for the non-negative frequency bins, which range from $k=0$ to $k=\\lfloor N/2 \\rfloor$. The problem provides the precise normalization rules, which account for the special cases of the DC component ($k=0$) and the Nyquist frequency ($k=N/2$ for even $N$).\n    -   For frequency bins $k$ from $1$ up to, but not including, the Nyquist frequency (i.e., $1 \\le k < N/2$), the amplitude is calculated by doubling the magnitude of the DFT coefficient and normalizing by $N$:\n        $$\n        A_k = \\frac{2|U_k|}{N}\n        $$\n        The factor of $2$ accounts for the energy from the corresponding symmetric bin at $N-k$.\n    -   For the DC component ($k=0$) and the Nyquist frequency ($k=N/2$, if $N$ is even), these bins do not have a distinct symmetric counterpart. Therefore, their amplitudes are calculated without the factor of $2$:\n        $$\n        A_k = \\frac{|U_k|}{N} \\quad \\text{for } k=0 \\text{ or } k=\\frac{N}{2}\n        $$\n    This normalization ensures that a pure real sinusoid of the form $A \\cos(2\\pi m n/N + \\phi)$ will correctly register an amplitude of $A$ at bin $k=m$ in the one-sided spectrum.\n\n4.  **Component Identification and Formatting**:\n    -   The calculated amplitudes $\\{A_k\\}$ are filtered to identify the significant frequency components. A component at bin $k$ is considered significant if its amplitude $A_k$ exceeds the specified tolerance $\\tau = 10^{-8}$.\n    -   The integer indices $k$ of all significant components are collected into a list, sorted in strictly increasing order.\n    -   The corresponding amplitudes $A_k$ are collected into a second list, with each value rounded to six decimal places as required.\n    -   The final result for the test case is a pair of these two lists.\n\nLet's illustrate with Test Case 1: $N=32$, $u_n = \\sin(2\\pi \\frac{n}{8}) + \\sin(2\\pi \\frac{n}{16})$.\nThis signal can be rewritten in terms of the DFT frequency index $m$ as $u_n = \\sin(2\\pi \\frac{4n}{32}) + \\sin(2\\pi \\frac{2n}{32})$. This is a superposition of two pure sinusoids with amplitudes of $1$ at frequency indices $m_1=2$ and $m_2=4$. Both frequencies fall in the range $1 \\le k < N/2$, so the $2|U_k|/N$ rule applies. According to Fourier theory, the one-sided spectrum should show an amplitude of $1.0$ at bin $k=2$ and an amplitude of $1.0$ at bin $k=4$. All other amplitudes should be zero (or within machine precision of zero). The algorithm will identify bins $k=2$ and $k=4$ as significant, as their amplitudes will be approximately $1.0$, well above $\\tau = 10^{-8}$. The expected output for this case is thus `[[2,4], [1.0, 1.0]]`.\n\nThis same procedure is applied systematically to all five test cases. For constant terms (e.g., $0.5$ in Case 2), we expect a component at $k=0$. For a term like $\\cos(\\pi n)$ with $N=32$, which is $\\cos(2\\pi \\frac{16n}{32})$, we expect a component at the Nyquist frequency $k=N/2=16$. The implementation will rigorously apply these rules to produce the final formatted output.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the one-sided amplitude spectrum for a suite of test signals\n    and identifies significant frequency components.\n    \"\"\"\n    \n    # Define the test cases as tuples of (N, signal_function)\n    # The signal function takes the array of indices n as input.\n    test_cases = [\n        (32, lambda n: np.sin(2 * np.pi * n / 8) + np.sin(2 * np.pi * n / 16)),\n        (32, lambda n: 0.5 + np.sin(2 * np.pi * n / 8)),\n        (32, lambda n: np.cos(np.pi * n)),\n        (64, lambda n: 1.2 * np.sin(2 * np.pi * 5 * n / 64 + 0.3)),\n        (64, lambda n: 0.3 + 0.8 * np.cos(2 * np.pi * 10 * n / 64) + 0.5 * np.sin(2 * np.pi * 12 * n / 64))\n    ]\n\n    results = []\n    tolerance = 1e-8\n\n    for N, signal_func in test_cases:\n        # Step 1: Signal Generation\n        n = np.arange(N)\n        u_n = signal_func(n)\n\n        # Step 2: DFT Computation using FFT\n        U_k = np.fft.fft(u_n)\n\n        # Step 3: One-Sided Amplitude Spectrum Calculation\n        num_one_sided_freqs = N // 2 + 1\n        # Extract magnitudes for non-negative frequencies\n        U_k_mag_one_sided = np.abs(U_k[:num_one_sided_freqs])\n        \n        # Calculate amplitudes with normalization factor of 2/N\n        A_k = U_k_mag_one_sided * 2 / N\n        \n        # Correct the DC (k=0) and Nyquist (k=N/2) components\n        A_k[0] = U_k_mag_one_sided[0] / N\n        if N % 2 == 0:\n            # The last element corresponds to the Nyquist frequency\n            A_k[-1] = U_k_mag_one_sided[-1] / N\n\n        # Step 4: Component Identification and Formatting\n        # Find indices where amplitude exceeds the tolerance\n        significant_bins = np.where(A_k > tolerance)[0]\n        \n        # Get the corresponding amplitudes and round them\n        significant_amplitudes = np.round(A_k[significant_bins], 6)\n        \n        # Append the result for this case\n        results.append([significant_bins.tolist(), significant_amplitudes.tolist()])\n\n    # Final print statement in the exact required format with no spaces.\n    final_output_str = str(results).replace(\" \", \"\")\n    print(final_output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "Having learned how to transform a signal into its spectrum, we now explore why this is so powerful for solving differential equations. This exercise demonstrates the core principle that makes spectral methods elegant and efficient: the transformation of calculus into algebra. You will derive from first principles how the complex operation of differentiation in physical space becomes simple multiplication by the imaginary wavenumber $ik$ in Fourier space, a property that is central to building spectral models .",
            "id": "3914646",
            "problem": "Consider a one-dimensional, zonally periodic tracer field $u(x)$ on the interval $x \\in [0,2\\pi)$ used in idealized environmental and Earth system modeling, with periodic boundary conditions and a Fourier series representation. Let the complex-exponential Fourier series be defined by\n$$\nu(x) = \\sum_{k\\in\\mathbb{Z}} \\hat{u}_k \\exp(i k x),\n$$\nwhere the Fourier coefficients $\\hat{u}_k$ are given by the definition\n$$\n\\hat{u}_k = \\frac{1}{2\\pi}\\int_{0}^{2\\pi} u(x)\\exp(-i k x)\\,\\mathrm{d}x.\n$$\nStarting from these definitions and the property that differentiation is a linear operator, derive the general relation between the Fourier coefficients of $u(x)$ and the Fourier coefficients of its first spatial derivative $u_x(x) = \\frac{\\mathrm{d}u}{\\mathrm{d}x}(x)$ on this periodic domain. Then apply your derived relation to the specific tracer field\n$$\nu(x) = \\sin(3x) + 0.5\\,\\cos(5x),\n$$\nto compute the spectral derivative and reconstruct $u_x(x)$ in physical space. In your derivation, explicitly identify the nonzero Fourier coefficients of $u(x)$ and show how they transform under differentiation, and then simplify the result to an analytic expression for $u_x(x)$ in terms of elementary trigonometric functions of $x$. Express the final answer as a single closed-form function of $x$. No rounding is required, and no units are to be reported.",
            "solution": "The problem as stated is valid. It is a well-posed, self-contained, and scientifically grounded exercise in the application of spectral methods, which are fundamental to environmental and Earth system modeling. We shall proceed with the derivation and solution.\n\nThe core of the problem lies in the property of the Fourier series that relates differentiation in physical space to a simple algebraic operation in spectral (Fourier) space. We will first derive this general property and then apply it to the specific function provided.\n\n**Part 1: General Relation for the Spectral Derivative**\n\nWe begin with the definition of a function $u(x)$ on a periodic domain $x \\in [0, 2\\pi)$ via its complex-exponential Fourier series:\n$$u(x) = \\sum_{k\\in\\mathbb{Z}} \\hat{u}_k \\exp(i k x)$$\nHere, $k$ is the integer wavenumber and $\\hat{u}_k$ are the complex Fourier coefficients. The first spatial derivative of $u(x)$ is $u_x(x) = \\frac{\\mathrm{d}u}{\\mathrm{d}x}$. Since differentiation is a linear operator, we can differentiate the series term-by-term. This operation is justified for functions that are sufficiently smooth, such as the one given in the problem.\n$$u_x(x) = \\frac{\\mathrm{d}}{\\mathrm{d}x} \\left( \\sum_{k\\in\\mathbb{Z}} \\hat{u}_k \\exp(i k x) \\right) = \\sum_{k\\in\\mathbb{Z}} \\hat{u}_k \\frac{\\mathrm{d}}{\\mathrm{d}x} (\\exp(i k x))$$\nThe derivative of the complex exponential function with respect to $x$ is:\n$$\\frac{\\mathrm{d}}{\\mathrm{d}x} (\\exp(i k x)) = i k \\exp(i k x)$$\nSubstituting this result back into the series for $u_x(x)$, we find:\n$$u_x(x) = \\sum_{k\\in\\mathbb{Z}} (i k \\hat{u}_k) \\exp(i k x)$$\nBy definition, the function $u_x(x)$ also has a Fourier series representation with coefficients denoted by $\\widehat{(u_x)}_k$:\n$$u_x(x) = \\sum_{k\\in\\mathbb{Z}} \\widehat{(u_x)}_k \\exp(i k x)$$\nBy equating the two series representations for $u_x(x)$ and comparing the terms for each wavenumber $k$, we obtain the general relation between the Fourier coefficients of a function and its derivative:\n$$\\widehat{(u_x)}_k = i k \\hat{u}_k$$\nThis fundamental result shows that differentiation in physical space is equivalent to multiplication by $i k$ in spectral space.\n\n**Part 2: Application to a Specific Tracer Field**\n\nWe are given the specific tracer field:\n$$u(x) = \\sin(3x) + 0.5\\cos(5x)$$\nTo apply the spectral differentiation rule, we must first find the non-zero Fourier coefficients, $\\hat{u}_k$, of this function. We use Euler's formulas to express $\\sin(3x)$ and $\\cos(5x)$ in terms of complex exponentials:\n$$\\sin(3x) = \\frac{\\exp(i3x) - \\exp(-i3x)}{2i}$$\n$$\\cos(5x) = \\frac{\\exp(i5x) + \\exp(-i5x)}{2}$$\nSubstituting these into the expression for $u(x)$, and noting that $0.5 = \\frac{1}{2}$:\n$$u(x) = \\frac{\\exp(i3x) - \\exp(-i3x)}{2i} + \\frac{1}{2} \\left( \\frac{\\exp(i5x) + \\exp(-i5x)}{2} \\right)$$\n$$u(x) = \\frac{1}{2i}\\exp(i3x) - \\frac{1}{2i}\\exp(-i3x) + \\frac{1}{4}\\exp(i5x) + \\frac{1}{4}\\exp(-i5x)$$\nSince $\\frac{1}{i} = -i$, we have:\n$$u(x) = \\left(-\\frac{i}{2}\\right)\\exp(i3x) + \\left(\\frac{i}{2}\\right)\\exp(-i3x) + \\frac{1}{4}\\exp(i5x) + \\frac{1}{4}\\exp(-i5x)$$\nBy comparing this directly to the general form $u(x) = \\sum_{k\\in\\mathbb{Z}} \\hat{u}_k \\exp(i k x)$, we can explicitly identify the non-zero Fourier coefficients of $u(x)$:\n- For $k=3$: $\\hat{u}_3 = -\\frac{i}{2}$\n- For $k=-3$: $\\hat{u}_{-3} = \\frac{i}{2}$\n- For $k=5$: $\\hat{u}_5 = \\frac{1}{4}$\n- For $k=-5$: $\\hat{u}_{-5} = \\frac{1}{4}$\nAll other coefficients $\\hat{u}_k$ are zero for $k \\notin \\{-5, -3, 3, 5\\}$.\n\nNext, we apply the differentiation rule $\\widehat{(u_x)}_k = i k \\hat{u}_k$ to find the Fourier coefficients of the derivative, $u_x(x)$:\n- For $k=3$: $\\widehat{(u_x)}_3 = i(3)\\hat{u}_3 = 3i\\left(-\\frac{i}{2}\\right) = -\\frac{3i^2}{2} = \\frac{3}{2}$\n- For $k=-3$: $\\widehat{(u_x)}_{-3} = i(-3)\\hat{u}_{-3} = -3i\\left(\\frac{i}{2}\\right) = -\\frac{3i^2}{2} = \\frac{3}{2}$\n- For $k=5$: $\\widehat{(u_x)}_5 = i(5)\\hat{u}_5 = 5i\\left(\\frac{1}{4}\\right) = \\frac{5i}{4}$\n- For $k=-5$: $\\widehat{(u_x)}_{-5} = i(-5)\\hat{u}_{-5} = -5i\\left(\\frac{1}{4}\\right) = -\\frac{5i}{4}$\n\n**Part 3: Reconstruction of the Derivative in Physical Space**\n\nWe now reconstruct $u_x(x)$ from its Fourier coefficients $\\widehat{(u_x)}_k$:\n$$u_x(x) = \\sum_{k \\in \\{-5,-3,3,5\\}} \\widehat{(u_x)}_k \\exp(i k x)$$\n$$u_x(x) = \\widehat{(u_x)}_{-5}\\exp(-i5x) + \\widehat{(u_x)}_{-3}\\exp(-i3x) + \\widehat{(u_x)}_{3}\\exp(i3x) + \\widehat{(u_x)}_{5}\\exp(i5x)$$\nSubstituting the coefficient values we just calculated:\n$$u_x(x) = \\left(-\\frac{5i}{4}\\right)\\exp(-i5x) + \\left(\\frac{3}{2}\\right)\\exp(-i3x) + \\left(\\frac{3}{2}\\right)\\exp(i3x) + \\left(\\frac{5i}{4}\\right)\\exp(i5x)$$\nTo simplify this expression and return to real-valued trigonometric functions, we group terms with opposite wavenumbers:\n$$u_x(x) = \\frac{3}{2}\\left(\\exp(i3x) + \\exp(-i3x)\\right) + \\frac{5i}{4}\\left(\\exp(i5x) - \\exp(-i5x)\\right)$$\nRecalling Euler's formulas for cosine and sine, $2\\cos(\\theta) = \\exp(i\\theta) + \\exp(-i\\theta)$ and $2i\\sin(\\theta) = \\exp(i\\theta) - \\exp(-i\\theta)$, we can write:\n$$u_x(x) = \\frac{3}{2}(2\\cos(3x)) + \\frac{5i}{4}(2i\\sin(5x))$$\n$$u_x(x) = 3\\cos(3x) + \\frac{10i^2}{4}\\sin(5x)$$\nUsing the identity $i^2 = -1$ and simplifying the fraction, we arrive at the final closed-form expression for the derivative:\n$$u_x(x) = 3\\cos(3x) - \\frac{5}{2}\\sin(5x)$$\nThis result is identical to that obtained by direct differentiation of the original function $u(x)$, confirming the correctness of the spectral method.",
            "answer": "$$\n\\boxed{3\\cos(3x) - \\frac{5}{2}\\sin(5x)}\n$$"
        },
        {
            "introduction": "This capstone practice integrates the preceding concepts to construct a full numerical model of a physical system. You will develop a two-dimensional pseudospectral solver for the Euler equations, which govern the motion of incompressible, inviscid fluids. This involves tackling the challenge of nonlinear advection using the pseudospectral method and controlling numerical artifacts through dealiasing, culminating in a verification of the model's physical fidelity by testing the conservation of energy and enstrophy .",
            "id": "3914652",
            "problem": "Consider the two-dimensional incompressible Euler equations on a square periodic domain for the vorticity field. Let the computational domain be $[0,2\\pi]\\times[0,2\\pi]$ with periodic boundary conditions, and angles expressed in radians. Define the vorticity $\\omega(x,y,t)$, the streamfunction $\\psi(x,y,t)$, and the velocity $\\mathbf{u}(x,y,t)=(u_x,u_y)$. The governing equations are\n$$\\frac{\\partial \\omega}{\\partial t} + J(\\psi,\\omega) = 0,$$\nwith the Jacobian $J(\\psi,\\omega) = \\frac{\\partial \\psi}{\\partial x}\\frac{\\partial \\omega}{\\partial y} - \\frac{\\partial \\psi}{\\partial y}\\frac{\\partial \\omega}{\\partial x}$ and the Poisson relation $\\nabla^2 \\psi = \\omega$. The velocity is recovered from the streamfunction by $u_x = -\\frac{\\partial \\psi}{\\partial y}$ and $u_y = \\frac{\\partial \\psi}{\\partial x}$.\n\nThe goal is to compute the time evolution of the vorticity using a pseudospectral method with Fast Fourier Transform (FFT) and two-thirds dealiasing, and then quantify the conservation properties of kinetic energy and enstrophy for the inviscid dynamics. The kinetic energy density $E$ and the enstrophy density $Z$ are defined by\n$$E(t) = \\frac{1}{2}\\langle |\\mathbf{u}(x,y,t)|^2 \\rangle, \\quad Z(t) = \\frac{1}{2}\\langle \\omega(x,y,t)^2 \\rangle,$$\nwhere $\\langle \\cdot \\rangle$ denotes the spatial average over the domain. For the inviscid two-dimensional Euler equations, both $E(t)$ and $Z(t)$ are invariants of motion in the continuous setting. In this problem, you will assess how well these invariants are preserved by a pseudospectral discretization with dealiasing and explicit time stepping.\n\nNumerical method specification:\n- Spatial discretization is Fourier pseudospectral on an $N\\times N$ grid with $N$ even, on the domain $L_x=L_y=2\\pi$.\n- Wavenumbers are defined consistently with the discrete Fourier transform; denote $k_x$ and $k_y$ as integer-valued angular wavenumbers due to $L_x=L_y=2\\pi$.\n- Spectral differentiation uses multiplication by $\\mathrm{i}k_x$ or $\\mathrm{i}k_y$ in Fourier space.\n- The nonlinear advection term $J(\\psi,\\omega)$ is computed pseudospectrally by transforming the needed fields to physical space, multiplying, and transforming back.\n- Two-thirds dealiasing is enforced by zeroing all Fourier modes with $|k_x| > K_c$ or $|k_y| > K_c$, where $K_c = \\left\\lfloor \\frac{N}{3} \\right\\rfloor$, both before forming physical-space products and after transforming the products back to spectral space. The same truncation is applied to the updated vorticity spectrum at the end of each time step.\n- Time stepping uses the classical fourth-order Rungeâ€“Kutta method for the inviscid dynamics $\\frac{\\partial \\omega}{\\partial t} = -J(\\psi,\\omega)$.\n\nEnergy and enstrophy diagnostics:\n- At the initial time $t=0$, compute $E(0)$ and $Z(0)$ from the initial vorticity using the streamfunction relation and velocity recovery defined above.\n- After integrating to the final time $t=T$, compute $E(T)$ and $Z(T)$.\n- For each test case, report two values:\n    1. If $E(0) > 0$, return the relative change $\\Delta E = \\frac{E(T)-E(0)}{E(0)}$; if $E(0)=0$, return $E(T)$ as a dimensionless scalar.\n    2. If $Z(0) > 0$, return the relative change $\\Delta Z = \\frac{Z(T)-Z(0)}{Z(0)}$; if $Z(0)=0$, return $Z(T)$ as a dimensionless scalar.\nAll reported values are dimensionless scalars.\n\nTest suite:\nFor each case, specify $N$, time step $\\Delta t$, number of time steps $n_\\text{steps}$, and the initial vorticity $\\omega(x,y,0)$ as an analytic function, with angles in radians.\n\n- Case A1 (baseline resolution, conservative time step):\n    - $N=64$, $\\Delta t = 0.0025$, $n_\\text{steps} = 400$ so $T = 1.0$.\n    - $\\omega(x,y,0) = \\sin(x)\\cos(y) + 0.5\\cos(2x)\\cos(y) - 0.25\\sin(y)$.\n- Case A2 (same initial condition, larger time step):\n    - $N=64$, $\\Delta t = 0.01$, $n_\\text{steps} = 200$ so $T = 2.0$.\n    - $\\omega(x,y,0) = \\sin(x)\\cos(y) + 0.5\\cos(2x)\\cos(y) - 0.25\\sin(y)$.\n- Case Z0 (zero vorticity edge case):\n    - $N=32$, $\\Delta t = 0.01$, $n_\\text{steps} = 100$ so $T = 1.0$.\n    - $\\omega(x,y,0) = 0$.\n- Case B (higher resolution, mixed-mode initial condition):\n    - $N=96$, $\\Delta t = 0.002$, $n_\\text{steps} = 300$ so $T = 0.6$.\n    - $\\omega(x,y,0) = \\sin(x) + \\sin(y) + 0.1\\sin(x+y) + 0.1\\sin(2x-y)$.\n\nOutput format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case contributes a two-element list `[energy_metric, enstrophy_metric]`. For example, the output must be of the form\n`[ [a_1,b_1], [a_2,b_2], [a_3,b_3], [a_4,b_4] ]`\nwith all values as decimals. The final values are dimensionless by construction; therefore, no physical unit is required in the output.\n\nYour program must be a complete, runnable program that implements the pseudospectral solver with dealiasing and produces the specified output for the four test cases.",
            "solution": "The user has provided a valid problem statement. The task is to simulate the two-dimensional incompressible Euler equations for vorticity on a doubly periodic domain using a pseudospectral method. The simulation results will be used to quantify the numerical conservation of kinetic energy and enstrophy, two invariants of the continuous system. The numerical scheme involves a fourth-order Runge-Kutta (RK4) method for time integration and a two-thirds dealiasing rule to control aliasing errors arising from the nonlinear advection term.\n\nThe solution is structured as follows:\n1.  **Governing Equations and Spectral Representation**: A review of the Euler equations in vorticity-streamfunction form and their representation in Fourier space.\n2.  **Pseudospectral Method for the Nonlinear Term**: A description of how the Jacobian term $J(\\psi, \\omega)$ is computed using a mix of spectral and physical space operations.\n3.  **Dealiasing**: An explanation of the two-thirds rule and its specific application as described in the problem statement.\n4.  **Time Integration**: The implementation of the RK4 scheme for advancing the vorticity spectrum in time.\n5.  **Diagnostic Calculations**: The formulas for computing kinetic energy and enstrophy from the vorticity spectrum using Parseval's theorem.\n6.  **Algorithm Implementation**: A summary of the computational workflow for solving each test case.\n\n**1. Governing Equations and Spectral Representation**\n\nThe governing equations are the vorticity evolution equation and the Poisson equation relating vorticity $\\omega$ to the streamfunction $\\psi$:\n$$\n\\frac{\\partial \\omega}{\\partial t} + J(\\psi,\\omega) = 0 \\quad \\text{where} \\quad J(\\psi,\\omega) = \\frac{\\partial \\psi}{\\partial x}\\frac{\\partial \\omega}{\\partial y} - \\frac{\\partial \\psi}{\\partial y}\\frac{\\partial \\omega}{\\partial x}\n$$\n$$\n\\nabla^2 \\psi = \\omega\n$$\nThe domain is a square $[0, 2\\pi] \\times [0, 2\\pi]$ with periodic boundary conditions. This periodicity makes a Fourier series representation natural. A scalar field $f(x,y,t)$ on this domain can be represented as:\n$$\nf(x,y,t) = \\sum_{k_x=-\\infty}^{\\infty} \\sum_{k_y=-\\infty}^{\\infty} \\hat{f}(k_x, k_y, t) e^{i(k_x x + k_y y)}\n$$\nwhere $k_x$ and $k_y$ are integer wavenumbers and $\\hat{f}(k_x, k_y, t)$ are the complex Fourier coefficients. In a numerical context, we use the Discrete Fourier Transform (DFT) on an $N \\times N$ grid. The wavenumbers become discrete and finite, ranging from $-N/2$ to $N/2-1$.\n\nSpatial derivatives are computed efficiently in Fourier space. The Fourier transform of a partial derivative is:\n$$\n\\mathcal{F}\\left(\\frac{\\partial f}{\\partial x}\\right) = i k_x \\hat{f}(k_x, k_y) \\quad \\text{and} \\quad \\mathcal{F}\\left(\\frac{\\partial f}{\\partial y}\\right) = i k_y \\hat{f}(k_x, k_y)\n$$\nThe Poisson equation $\\nabla^2 \\psi = \\omega$ becomes algebraic in Fourier space:\n$$\n( (ik_x)^2 + (ik_y)^2 ) \\hat{\\psi} = - (k_x^2 + k_y^2) \\hat{\\psi} = \\hat{\\omega}\n$$\nThis allows us to solve for the streamfunction spectrum $\\hat{\\psi}$ directly from the vorticity spectrum $\\hat{\\omega}$:\n$$\n\\hat{\\psi}(k_x, k_y) = -\\frac{\\hat{\\omega}(k_x, k_y)}{k_x^2 + k_y^2} \\quad \\text{for} \\quad (k_x, k_y) \\neq (0,0)\n$$\nFor the mean mode $(k_x, k_y) = (0,0)$, the denominator is zero. The average of the initial vorticity is zero for all test cases, so $\\hat{\\omega}(0,0)=0$. The average value of the streamfunction $\\hat{\\psi}(0,0)$ is physically irrelevant as it does not affect the velocity field (which depends on derivatives of $\\psi$), so we set $\\hat{\\psi}(0,0) = 0$.\n\n**2. Pseudospectral Method for the Nonlinear Term**\n\nThe nonlinear Jacobian term $J(\\psi, \\omega)$ involves products of fields, which correspond to convolutions in Fourier space. Direct evaluation of these convolutions is computationally expensive ($O(N^4)$). The pseudospectral method provides a more efficient $O(N^2 \\log N)$ approach:\n1.  Start with the spectral fields $\\hat{\\omega}$ and $\\hat{\\psi}$.\n2.  Compute the spectral representations of the required derivatives, e.g., $\\widehat{\\frac{\\partial \\psi}{\\partial x}} = i k_x \\hat{\\psi}$.\n3.  Apply the inverse Fast Fourier Transform (IFFT) to these spectral derivatives to obtain the corresponding fields in physical space, e.g., $\\frac{\\partial \\psi}{\\partial x}(x,y)$.\n4.  Perform the multiplications in physical space to compute $J(x,y) = \\frac{\\partial \\psi}{\\partial x}\\frac{\\partial \\omega}{\\partial y} - \\frac{\\partial \\psi}{\\partial y}\\frac{\\partial \\omega}{\\partial x}$.\n5.  Apply the forward Fast Fourier Transform (FFT) to $J(x,y)$ to obtain its spectrum, $\\hat{J}(k_x, k_y)$.\n\nThe time evolution of the vorticity spectrum is then given by $\\frac{\\partial \\hat{\\omega}}{\\partial t} = - \\hat{J}$.\n\n**3. Dealiasing**\n\nThe multiplication in physical space can create artificial high-frequency modes due to the periodic nature of the DFT, a phenomenon known as aliasing. The two-thirds dealiasing rule is applied to prevent this. The cutoff wavenumber is defined as $K_c = \\lfloor N/3 \\rfloor$.\nThe procedure, as specified in the problem, involves three filtering steps:\n1.  **Before Products**: Before transforming the derivatives (e.g., $\\widehat{\\frac{\\partial \\psi}{\\partial x}}$) to physical space for multiplication, all Fourier coefficients for which $|k_x| > K_c$ or $|k_y| > K_c$ are set to zero. This ensures the fields being multiplied have their spectral content limited.\n2.  **After Products**: After computing the product (the Jacobian) in physical space and transforming it back to Fourier space, the resulting spectrum $\\hat{J}$ is truncated again using the same rule. This removes the high-frequency content generated by the multiplication that could cause aliasing.\n3.  **End of Timestep**: After the full RK4 time step is completed, the updated vorticity spectrum $\\hat{\\omega}(t+\\Delta t)$ is truncated one final time.\n\nThis procedure ensures that all non-linear interactions are free of aliasing errors.\n\n**4. Time Integration**\n\nThe semi-discretized equation for the vorticity spectrum is an ordinary differential equation (ODE):\n$$\n\\frac{d\\hat{\\omega}(t)}{dt} = \\mathcal{R}(\\hat{\\omega}(t))\n$$\nwhere $\\mathcal{R}(\\hat{\\omega}(t)) = -\\hat{J}(\\psi,\\omega)$ is the right-hand side, which includes the pseudospectral calculation with dealiasing. This system of ODEs is integrated using the classical fourth-order Runge-Kutta (RK4) method. For a timestep from $t_n$ to $t_{n+1}=t_n+\\Delta t$:\n$$\n\\begin{aligned}\n    k_1 &= \\mathcal{R}(\\hat{\\omega}_n) \\\\\n    k_2 &= \\mathcal{R}(\\hat{\\omega}_n + \\frac{\\Delta t}{2} k_1) \\\\\n    k_3 &= \\mathcal{R}(\\hat{\\omega}_n + \\frac{\\Delta t}{2} k_2) \\\\\n    k_4 &= \\mathcal{R}(\\hat{\\omega}_n + \\Delta t k_3) \\\\\n    \\hat{\\omega}_{n+1} &= \\hat{\\omega}_n + \\frac{\\Delta t}{6} (k_1 + 2k_2 + 2k_3 + k_4)\n\\end{aligned}\n$$\nAfter computing $\\hat{\\omega}_{n+1}$, the end-of-step dealiasing filter is applied.\n\n**5. Diagnostic Calculations**\n\nThe kinetic energy $E$ and enstrophy $Z$ are computed from the vorticity spectrum $\\hat{\\omega}$ using Parseval's theorem. For the DFT normalization used by NumPy, the spatial average of a squared field $\\langle f^2 \\rangle$ is related to its FFT $\\hat{f}_{FFT}$ by:\n$$\n\\langle f^2 \\rangle = \\frac{1}{N^2} \\sum_{j,l=0}^{N-1} |f(x_j, y_l)|^2 = \\frac{1}{N^4} \\sum_{k_x, k_y} |\\hat{f}_{FFT}(k_x, k_y)|^2\n$$\nThe enstrophy $Z = \\frac{1}{2} \\langle \\omega^2 \\rangle$ is therefore:\n$$\nZ(t) = \\frac{1}{2N^4} \\sum_{k_x, k_y} |\\hat{\\omega}(k_x, k_y, t)|^2\n$$\nThe kinetic energy $E = \\frac{1}{2} \\langle |\\mathbf{u}|^2 \\rangle = \\frac{1}{2} \\langle u_x^2 + u_y^2 \\rangle$ can also be expressed in terms of $\\hat{\\omega}$. First, we find the velocity spectra: $\\hat{u}_x = -ik_y \\hat{\\psi}$ and $\\hat{u}_y = ik_x \\hat{\\psi}$. Substituting $\\hat{\\psi}$, we have:\n$$\nE(t) = \\frac{1}{2N^4} \\sum_{(k_x,k_y) \\neq (0,0)} (k_x^2 + k_y^2) |\\hat{\\psi}|^2 = \\frac{1}{2N^4} \\sum_{(k_x,k_y) \\neq (0,0)} \\frac{|\\hat{\\omega}(k_x, k_y, t)|^2}{k_x^2 + k_y^2}\n$$\nThe $(k_x,k_y)=(0,0)$ mode is excluded as it contains no kinetic energy.\n\n**6. Algorithm Implementation**\n\nFor each test case, the solver proceeds as follows:\n1.  Set up the computational grid ($N \\times N$) and corresponding 2D wavenumber arrays ($k_x, k_y$). Pre-compute the inverse Laplacian operator and the dealiasing mask.\n2.  Evaluate the initial vorticity $\\omega(x,y,0)$ on the grid and compute its spectrum $\\hat{\\omega}(0)$ via FFT. Apply the dealiasing filter to this initial spectrum.\n3.  Calculate the initial energy $E(0)$ and enstrophy $Z(0)$ using the spectral formulas.\n4.  Loop for the specified number of time steps ($n_\\text{steps}$), advancing $\\hat{\\omega}$ at each step using the RK4 method. The function for the RHS of the ODE encapsulates the full pseudospectral and dealiasing procedure for the Jacobian.\n5.  After the final time step, calculate the final energy $E(T)$ and enstrophy $Z(T)$.\n6.  Compute the required output metrics ($\\Delta E$ or $E(T)$, and $\\Delta Z$ or $Z(T)$) and store them.\n7.  After processing all cases, format the results into the specified string format and print to standard output.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        # Case A1: (N, dt, n_steps, omega_func)\n        (64, 0.0025, 400, lambda x, y: np.sin(x)*np.cos(y) + 0.5*np.cos(2*x)*np.cos(y) - 0.25*np.sin(y)),\n        # Case A2\n        (64, 0.01, 200, lambda x, y: np.sin(x)*np.cos(y) + 0.5*np.cos(2*x)*np.cos(y) - 0.25*np.sin(y)),\n        # Case Z0\n        (32, 0.01, 100, lambda x, y: np.zeros_like(x)),\n        # Case B\n        (96, 0.002, 300, lambda x, y: np.sin(x) + np.sin(y) + 0.1*np.sin(x+y) + 0.1*np.sin(2*x-y))\n    ]\n\n    results = []\n    for params in test_cases:\n        result = _run_solver(*params)\n        results.append(result)\n        \n    print(str(results).replace(\" \", \"\"))\n\ndef _run_solver(N, dt, n_steps, omega_func):\n    \"\"\"\n    Solves the 2D Euler equations for a single test case.\n    \"\"\"\n    # 1. Grid, Wavenumbers, and Pre-computation\n    L = 2.0 * np.pi\n    dx = L / N\n    # Physical grid\n    x = np.arange(N) * dx\n    X, Y = np.meshgrid(x, x, indexing='ij')\n\n    # Wavenumber grid (integer angular wavenumbers for domain size 2*pi)\n    k_1d = np.fft.fftfreq(N) * N\n    kx, ky = np.meshgrid(k_1d, k_1d, indexing='ij')\n    \n    # Inverse Laplacian for Poisson solve: inv_lap = -1/(k_x^2+k_y^2)\n    k_sq = kx**2 + ky**2\n    # Avoid division by zero for the k=0 mode.\n    # The w_hat[0,0] is zero, so psi_hat[0,0] will be 0.\n    inv_lap = np.divide(-1.0, k_sq, out=np.zeros_like(k_sq), where=(k_sq != 0))\n\n    # Dealiasing filter setup (2/3 rule)\n    Kc = N // 3\n    dealias_mask = (np.abs(kx) > Kc) | (np.abs(ky) > Kc)\n\n    def dealias(f_hat):\n        \"\"\"Applies the dealiasing filter to a spectral field.\"\"\"\n        f_hat[dealias_mask] = 0.0\n        return f_hat\n\n    # 2. Diagnostics: Energy and Enstrophy Calculation\n    def calculate_invariants(w_hat):\n        \"\"\"Computes kinetic energy and enstrophy from the vorticity spectrum.\"\"\"\n        # Enstrophy Z = 0.5 * <w^2>. Using Parseval's theorem for numpy's DFT.\n        enstrophy = 0.5 * np.sum(np.abs(w_hat)**2) / (N**4)\n\n        # Energy E = 0.5 * <|u|^2> = sum(|w_hat|^2 / k^2) / (2*N^4)\n        energy_spec = np.divide(np.abs(w_hat)**2, k_sq, out=np.zeros_like(k_sq), where=(k_sq != 0))\n        energy = 0.5 * np.sum(energy_spec) / (N**4)\n        \n        return energy, enstrophy\n\n    # 3. RHS of the Vorticity Equation (Pseudospectral with Dealiasing)\n    def compute_rhs(w_hat):\n        \"\"\"Computes the spectral representation of -J(psi, omega).\"\"\"\n        # Get streamfunction spectrum\n        psi_hat = w_hat * inv_lap\n\n        # Spectral derivatives of psi and omega.\n        dpsidx_hat = 1j * kx * psi_hat\n        dpsidy_hat = 1j * ky * psi_hat\n        domegadx_hat = 1j * kx * w_hat\n        domegady_hat = 1j * ky * w_hat\n\n        # Dealias before transforming to physical space (before product).\n        dpsidx_hat = dealias(dpsidx_hat)\n        dpsidy_hat = dealias(dpsidy_hat)\n        domegadx_hat = dealias(domegadx_hat)\n        domegady_hat = dealias(domegady_hat)\n        \n        # Transform to physical space via IFFT\n        dpsidx_phys = np.fft.ifft2(dpsidx_hat).real\n        dpsidy_phys = np.fft.ifft2(dpsidy_hat).real\n        domegady_phys = np.fft.ifft2(domegady_hat).real\n        \n        # Calculate Jacobian product in physical space\n        # J(psi, omega) = (dpsi/dx)*(domega/dy) - (dpsi/dy)*(domega/dx)\n        # We need d(omega)/dx, so we must also transform domegadx_hat\n        domegadx_phys = np.fft.ifft2(domegadx_hat).real\n        jacobian_phys = dpsidx_phys * domegady_phys - dpsidy_phys * domegadx_phys\n        \n        # Transform Jacobian back to spectral space\n        jacobian_hat = np.fft.fft2(jacobian_phys)\n        \n        # Dealias the product spectrum and return RHS = -J_hat\n        return -dealias(jacobian_hat)\n\n    # 4. Initial Condition and Initial Diagnostics\n    omega_phys_0 = omega_func(X, Y)\n    omega_hat = np.fft.fft2(omega_phys_0)\n    omega_hat = dealias(omega_hat) # Dealias initial state\n\n    E0, Z0 = calculate_invariants(omega_hat)\n\n    # 5. Time Integration (RK4)\n    for _ in range(n_steps):\n        k1 = compute_rhs(omega_hat)\n        k2 = compute_rhs(omega_hat + 0.5 * dt * k1)\n        k3 = compute_rhs(omega_hat + 0.5 * dt * k2)\n        k4 = compute_rhs(omega_hat + dt * k3)\n        \n        omega_hat += (dt / 6.0) * (k1 + 2.0 * k2 + 2.0 * k3 + k4)\n        \n        # Dealias at the end of the step\n        omega_hat = dealias(omega_hat)\n\n    # 6. Final Diagnostics and Metrics\n    ET, ZT = calculate_invariants(omega_hat)\n\n    # Calculate metrics as specified\n    if E0 > 1e-16: # Use a small tolerance for zero check\n        delta_E = (ET - E0) / E0\n    else:\n        delta_E = ET\n\n    if Z0 > 1e-16: # Use a small tolerance for zero check\n        delta_Z = (ZT - Z0) / Z0\n    else:\n        delta_Z = ZT\n        \n    return [delta_E, delta_Z]\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}