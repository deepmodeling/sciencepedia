{
    "hands_on_practices": [
        {
            "introduction": "半拉格朗日格式的核心在于插值过程，即在离散的网格点上估算出发点处的物理量。插值方法的选择直接决定了格式的精度和计算成本，但同样也可能引入非物理的振荡。本练习  使用一个带有尖锐梯度的“平顶帽”示踪物，旨在通过对比不同阶插值方法，直观地揭示高阶格式在提高精度的同时，可能牺牲单调性并产生伪振荡的现象。",
            "id": "3911345",
            "problem": "要求您设计并实现一个一维半拉格朗日平流测试，使用帽形示踪剂评估单调性，并量化伪下冲的振幅，将其作为 Courant–Friedrichs–Lewy (CFL) 数和插值阶数的函数。您必须使用的基本依据是一维被动示踪剂平流方程和半拉格朗日输运的定义。\n\n场景与基本原理：\n- 考虑在一个长度为 $L$ 米的周期性域上的一维被动示踪剂平流方程：\n$$\n\\frac{\\partial c}{\\partial t} + u \\frac{\\partial c}{\\partial x} = 0,\n$$\n其中 $c(x,t)$ 是示踪剂浓度（无量纲），$u$ 是以 $\\mathrm{m/s}$ 为单位的恒定速度，$x$ 是以米为单位的空间坐标，$t$ 是以秒为单位的时间。\n- 半拉格朗日方法基于沿轨迹的物质导数定义，即对于纯平流过程，示踪剂沿轨迹保持不变：\n$$\n\\frac{D c}{D t} = \\frac{\\partial c}{\\partial t} + u \\frac{\\partial c}{\\partial x} = 0.\n$$\n- 以此为基础，推导如何在网格点 $x_i$ 处将 $c$ 从时间层 $t^n$推进到时间层 $t^{n+1} = t^n + \\Delta t$，方法是在出发点处评估前一时刻的示踪剂。您的推导必须从上述方程和核心定义出发，不得使用或假设任何快捷公式。\n\n数值设置：\n- 使用一个包含 $N$ 个点的均匀周期性网格，域长 $L = 1$（米），空间步长 $\\Delta x = L/N$（米），速度 $u = 1$（米/秒），以及由 Courant–Friedrichs–Lewy 数决定的单个时间步长 $\\Delta t$（秒）：\n$$\n\\mathrm{CFL} = \\frac{u \\Delta t}{\\Delta x}.\n$$\n- 初始化一个帽形示踪剂 $c(x,0)$，其在区间 $[x_0, x_0+w)$ 上的振幅为 $1$，在其他地方为 $0$。其中 $x_0 = 0.33 L$（米），$w = 0.20 L$（米）。该示踪剂是无量纲的，并且初始值严格在 $[0,1]$ 范围内。\n\n插值与单调性评估：\n- 实现三种插值阶数，用于在出发点评估前一时刻的示踪剂：\n  1. 阶 $p=0$：最近邻插值。\n  2. 阶 $p=1$：线性插值。\n  3. 阶 $p=3$：使用最近的四个网格值进行三次拉格朗日插值。\n- 在一个半拉格朗日时间步后，计算伪下冲的振幅，定义为\n$$\nA_{\\text{under}} = \\max\\left(0, -\\min_i c^{n+1}(x_i)\\right),\n$$\n该值衡量对下界 $0$ 的违反程度。振幅是无量纲的（与 $c$ 的单位相同）。本问题不涉及角度。\n\n算法要求：\n- 从第一性原理推导并实现半拉格朗日更新：为每个网格点计算出发点，然后使用所选的插值阶数将前一时刻的示踪剂插值到该点，同时遵守周期性边界条件。\n- 确保实现是科学上真实且自洽的。使用足够大的 $N$ 来分辨帽形函数和插值效应。\n\n测试套件：\n- 使用 $N = 2048$（整数），$L = 1$（米），$u = 1$（米/秒），以及帽形函数参数 $x_0 = 0.33 L$ 和 $w = 0.20 L$。\n- 对于每个测试用例，通过 $\\Delta t = \\mathrm{CFL} \\cdot \\Delta x / u$（秒）从指定的 $\\mathrm{CFL}$ 计算 $\\Delta t$，执行恰好一个半拉格朗日步骤，并返回 $A_{\\text{under}}$。\n- 测试套件由以下 $(p, \\mathrm{CFL})$ 对组成：\n  1. $(0, 0.75)$,\n  2. $(1, 0.75)$,\n  3. $(3, 0.75)$,\n  4. $(3, 0.25)$,\n  5. $(3, 1.00)$,\n  6. $(3, 2.25)$,\n  7. $(3, 0.00)$,\n  8. $(1, 0.25)$,\n  9. $(0, 0.25)$.\n\n输出规格：\n- 您的程序应生成单行输出，其中包含上述测试用例的九个振幅 $A_{\\text{under}}$，以逗号分隔的列表形式包含在方括号中，顺序与测试套件相同，每个振幅四舍五入到六位小数。例如：\n$$\n\\text{[0.000000,0.000000,0.012345,\\dots]}\n$$\n不应打印任何额外文本。",
            "solution": "该问题被验证为具有科学依据、适定且客观。它构成了分析半拉格朗日平流方案特性的标准数值实验。我们将继续进行推导和求解。\n\n### 基于原理的半拉格朗日方法推导\n\n一维被动示踪剂平流方程如下：\n$$\n\\frac{\\partial c}{\\partial t} + u \\frac{\\partial c}{\\partial x} = 0\n$$\n其中 $c(x,t)$ 是示踪剂浓度，$u$ 是恒定速度，$x$ 是空间坐标，$t$ 是时间。左侧的表达式是浓度 $c$ 沿着随流运动的轨迹 $X(t)$ 的物质导数，定义为 $\\frac{D c}{D t} = \\frac{\\partial c}{\\partial t} + u \\frac{\\partial c}{\\partial x}$。因此，控制方程简化为：\n$$\n\\frac{D c}{D t} = 0\n$$\n该方程表明浓度 $c$ 沿着特征线是恒定的，特征线即流体质点的轨迹。特征线 $X(\\tau)$ 由以下常微分方程描述：\n$$\n\\frac{dX(\\tau)}{d\\tau} = u\n$$\n为了求出网格点 $x_i$ 和时间 $t^{n+1} = t^n + \\Delta t$ 处的浓度 $c^{n+1}(x_i)$，我们从到达点 $(x_i, t^{n+1})$ 沿特征线向后追溯时间，以找到其在前一时间层 $t^n$ 的出发点 $(x_{d,i}, t^n)$。由于 $u$ 是常数，将轨迹方程从 $t^n$ 积分到 $t^{n+1}$ 是很直接的：\n$$\n\\int_{t^n}^{t^{n+1}} \\frac{dX}{d\\tau} d\\tau = \\int_{t^n}^{t^{n+1}} u d\\tau\n$$\n$$\nX(t^{n+1}) - X(t^n) = u (t^{n+1} - t^n)\n$$\n代入 $X(t^{n+1}) = x_i$ 和出发点的定义 $x_{d,i} = X(t^n)$，我们得到：\n$$\nx_i - x_{d,i} = u \\Delta t\n$$\n这就得出了出发点的位置：\n$$\nx_{d,i} = x_i - u \\Delta t\n$$\n原理 $\\frac{Dc}{Dt}=0$ 意味着浓度沿此路径守恒：\n$$\nc(x_i, t^{n+1}) = c(x_{d,i}, t^n)\n$$\n在数值计算的背景下，$c(x, t^n)$ 仅在离散的网格点 $x_j$ 上已知。出发点 $x_{d,i}$ 通常不会与任何网格点重合。因此，为了找到 $c(x_{d,i}, t^n)$ 的值，我们必须对时间 $t^n$ 的网格数据进行插值。将插值算子记为 $\\mathcal{I}$，半拉格朗日更新法则为：\n$$\nc_i^{n+1} = \\mathcal{I}[c^n](x_{d,i}) = \\mathcal{I}[c^n](x_i - u \\Delta t)\n$$\n\n### 数值实现\n\n长度为 $L=1$ 的域被离散为 $N$ 个网格单元，网格间距为 $\\Delta x = L/N$。网格点为 $x_i = i \\Delta x$，其中 $i \\in \\{0, 1, \\dots, N-1\\}$。速度为 $u=1$。我们可以用 Courant–Friedrichs–Lewy (CFL) 数来表示时间步长：$\\Delta t = \\mathrm{CFL} \\cdot \\Delta x / u$。将这些代入出发点方程：\n$$\nx_{d,i} = x_i - u \\left(\\frac{\\mathrm{CFL} \\cdot \\Delta x}{u}\\right) = i\\Delta x - \\mathrm{CFL} \\cdot \\Delta x = (i - \\mathrm{CFL})\\Delta x\n$$\n这表明，以网格单位衡量的出发点位于无量纲坐标 $\\alpha_i = i - \\mathrm{CFL}$ 处。由于域是大小为 $N$ 个网格单元的周期性域，我们对该坐标使用模 $N$ 运算：$\\alpha_{\\text{p},i} = \\alpha_i \\pmod N$。\n\n设 $j = \\lfloor \\alpha_{\\text{p},i} \\rfloor$ 为出发点前最后一个网格点的索引，设 $s = \\alpha_{\\text{p},i} - j$ 为进入区间 $[x_j, x_{j+1})$ 的小数距离，其中 $s \\in [0, 1)$。值 $c_i^{n+1}$ 是通过使用索引 $j$ 周围的点构成的模板对值 $c_k^n$进行插值得到的。\n\n### 插值方案与单调性\n\n初始条件是一个值在 $[0, 1]$ 内的帽形函数。如果一个数值方案不引入新的极值，则它是单调的。对于本问题，单调方案将确保 $c_i^{n+1} \\in [0, 1]$，因此下冲振幅 $A_{\\text{under}} = \\max(0, -\\min_i c_i^{n+1})$ 将为零。\n\n1.  **阶 $p=0$ (最近邻)**：从最近的网格点取值。$c_i^{n+1} = c_{j+\\text{round}(s)}^n$。由于这只从初始数据中选择现有值，因此它是单调的。我们预期 $A_{\\text{under}}=0$。\n\n2.  **阶 $p=1$ (线性插值)**：该值为两个包围网格点的加权平均值。\n    $$\n    c_i^{n+1} = (1-s)c_j^n + s c_{j+1}^n\n    $$\n    作为 $[0, 1]$ 中两个值的凸组合，结果也在 $[0, 1]$ 内。此方案是单调的，我们预期 $A_{\\text{under}}=0$。\n\n3.  **阶 $p=3$ (三次拉格朗日插值)**：我们使用最近的四个网格点，形成一个模板 $\\{j-1, j, j+1, j+2\\}$ 来构造一个三次多项式。所有索引都必须周期性处理，例如，索引 $j-1$ 变为 $(j-1) \\pmod N$。插值后的值为：\n    $$\n    c_i^{n+1} = c_{j-1}^n \\mathcal{L}_{-1}(s) + c_{j}^n \\mathcal{L}_{0}(s) + c_{j+1}^n \\mathcal{L}_{1}(s) + c_{j+2}^n \\mathcal{L}_{2}(s)\n    $$\n    其中 $\\mathcal{L}_k(s)$ 是在归一化的局部坐标 $s \\in [0,1)$ 处求值的拉格朗日基多项式，对应于 $\\{-1, 0, 1, 2\\}$ 处的模板点：\n    $$\n    \\begin{align*}\n    \\mathcal{L}_{-1}(s) = -\\frac{s(s-1)(s-2)}{6} \\\\\n    \\mathcal{L}_{0}(s) = \\frac{(s+1)(s-1)(s-2)}{2} \\\\\n    \\mathcal{L}_{1}(s) = -\\frac{(s+1)s(s-2)}{2} \\\\\n    \\mathcal{L}_{2}(s) = \\frac{(s+1)s(s-1)}{6}\n    \\end{align*}\n    $$\n    该方案通常不是单调的。基多项式可以取负值，这意味着插值结果不是一个凸组合。这可能导致在陡峭梯度附近出现伪振荡（下冲和上冲），因此对于非整数的 CFL 数，我们可能预期 $A_{\\text{under}}  0$。对于整数 CFL 值，出发点与网格点对齐，$s=0$，插值变为精确选择（$c_i^{n+1} = c_{i-\\mathrm{CFL}}^n$），不会产生下冲。\n\n算法通过遍历每个测试用例 $(p, \\mathrm{CFL})$ 来进行，构建初始状态 $c^0$，使用指定的插值计算新状态 $c^1$，然后计算 $A_{\\text{under}}$。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 1D semi-Lagrangian advection test for monotonicity.\n    \"\"\"\n    \n    # ------------------\n    # Numerical Setup\n    # ------------------\n    N = 2048\n    L = 1.0\n    u = 1.0\n    x0 = 0.33 * L\n    w = 0.20 * L\n    \n    dx = L / N\n    x = np.arange(N) * dx\n    \n    # ------------------\n    # Initial Condition\n    # ------------------\n    c0 = np.zeros(N, dtype=np.float64)\n    # Define the top-hat tracer profile\n    # Use boolean indexing for clarity and efficiency\n    c0[(x = x0)  (x  (x0 + w))] = 1.0\n    \n    # ------------------\n    # Test Suite\n    # ------------------\n    test_cases = [\n        (0, 0.75),\n        (1, 0.75),\n        (3, 0.75),\n        (3, 0.25),\n        (3, 1.00),\n        (3, 2.25),\n        (3, 0.00),\n        (1, 0.25),\n        (0, 0.25),\n    ]\n    \n    results = []\n    \n    for p, cfl in test_cases:\n        # For CFL=0, there is no change, so no undershoot\n        if cfl == 0.0:\n            results.append(0.0)\n            continue\n            \n        c1 = np.zeros(N, dtype=np.float64)\n\n        for i in range(N):\n            # Calculate departure point in non-dimensional grid coordinates\n            alpha = float(i) - cfl\n            \n            # Apply periodic boundary conditions. Python's % operator handles\n            # negative numbers in a way that is suitable for this (e.g., -0.75 % N = N-0.75).\n            alpha_periodic = alpha % N\n            \n            j = int(np.floor(alpha_periodic))\n            s = alpha_periodic - j\n\n            # Perform interpolation based on order p\n            if p == 0:  # Nearest-neighbor\n                idx = (j + int(round(s))) % N\n                c1[i] = c0[idx]\n            \n            elif p == 1:  # Linear\n                j0 = j\n                j1 = (j + 1) % N\n                c1[i] = (1.0 - s) * c0[j0] + s * c0[j1]\n            \n            elif p == 3:  # Cubic Lagrange\n                # Stencil points are j-1, j, j+1, j+2\n                j_m1 = (j - 1) % N\n                j_0 = j\n                j_1 = (j + 1) % N\n                j_2 = (j + 2) % N\n                \n                # Get the concentrations at the stencil points\n                c_m1 = c0[j_m1]\n                c_0 = c0[j_0]\n                c_1 = c0[j_1]\n                c_2 = c0[j_2]\n                \n                # Evaluate the Lagrange basis polynomials at s\n                l_m1 = -s * (s - 1.0) * (s - 2.0) / 6.0\n                l_0  = (s + 1.0) * (s - 1.0) * (s - 2.0) / 2.0\n                l_1  = -(s + 1.0) * s * (s - 2.0) / 2.0\n                l_2  = (s + 1.0) * s * (s - 1.0) / 6.0\n                \n                c1[i] = l_m1 * c_m1 + l_0 * c_0 + l_1 * c_1 + l_2 * c_2\n        \n        # Calculate amplitude of spurious undershoots\n        min_c1 = np.min(c1)\n        a_under = max(0.0, -min_c1)\n        results.append(a_under)\n\n    # Format the output as specified\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "除了局部精度和形状保持，数值格式的另一个关键属性是其对守恒律的遵守能力，尤其是质量守恒。标准的逐点插值半拉格朗日方法通常不保证离散总质量的守恒，这在长期气候或环境模拟中可能导致严重偏差。本练习  对比了非守恒的逐点插值方法与一种内在守恒的几何重映方法，以量化不同方案在质量守恒方面的表现，并揭示守恒格式设计的核心思想。",
            "id": "3911296",
            "problem": "考虑一维线性平流方程，这是环境与地球系统建模中示踪剂输运的一个典型模型：$$\\frac{\\partial q}{\\partial t} + u \\frac{\\partial q}{\\partial x} = 0,$$ 该方程定义在区间 $$x \\in [0,1)$$上，具有周期性边界条件和恒定速度 $$u$$。量 $$q(x,t)$$ 是无量纲的。半拉格朗日（SL）方法通过沿时间向后追踪特征线来推进求解：在每个网格位置 $$x_i$$，确定其出发点 $$x_d = x_i - u \\Delta t$$，并计算前一时刻解在 $$x_d$$ 处的值。在离散实现中，这需要对场 $$q$$ 进行插值，并且根据表示方式的不同，还可能需要对几何平移区间上的网格单元平均值进行重映。在连续形式下，总质量 $$M(t) = \\int_0^1 q(x,t) \\, dx$$ 在平流方程下是精确守恒的。在离散 SL 实现中，插值和几何重映的选择决定了离散总质量是否守恒，以及质量误差如何随多个时间步累积。\n\n您的任务是构建一个用于诊断多个时间步后全局质量误差的定量指标，并在纯数学和计算的环境下，针对不同的插值和几何重映选择进行计算。在一个包含 $$N_x$$ 个单元、单元宽度为 $$\\Delta x = 1/N_x$$ 的均匀周期性网格上进行计算，网格上的值可以是位于单元中心 $$x_i = (i + 0.5)\\Delta x$$ 的点值，也可以是与区间 $$[i\\Delta x,(i+1)\\Delta x)$$ 关联的单元平均值。对于每种方法和初始条件，将步骤 $$n$$ 的离散总质量定义为 $$M^n = \\sum_{i=0}^{N_x-1} q_i^n \\, \\Delta x,$$ 其中 $$q_i^n$$ 根据方法的不同，表示近似局部平均值的点值或单元平均值本身。在使用恒定时间步 $$\\Delta t$$ 传播 $$N_{\\text{steps}}$$ 步后，诊断全局质量误差 $$E = M^{N_{\\text{steps}}} - M^0$$，其结果为一个实数。所有量均为无量纲；无需物理单位。假设除计算中固有的浮点舍入外，所有算术运算均在精确实数算术下执行。\n\n实现两种 SL 更新范式：\n- 带插值的点值 SL：对每个单元中心 $$x_i$$，使用线性插值或三次插值来计算出发点 $$x_d = x_i - u \\Delta t$$ 处的 $$q^n$$，从而得到下一步的结果 $$q^{n+1}$$。\n- 单元平均值的守恒几何重映：将 $$q_i^n$$ 视为单元平均值，并通过对出发区间 $$[x_i - \\Delta x/2 - u \\Delta t, x_i + \\Delta x/2 - u \\Delta t]$$ 上的前一时刻场进行平均来生成 $$q_i^{n+1}$$。由于周期性，该区间位于前一时刻的网格上。根据其构造，这种重映在离散层面上必须是质量守恒的。\n\n构建一个程序，针对以下测试套件，计算规定步数后的全局质量误差 $$E$$。最终输出必须是单行文本，其中包含一个用方括号括起来的逗号分隔列表形式的结果。\n\n测试套件：\n- 案例 1（理想情况，光滑场，小库朗数，点值线性插值）：$$N_x = 128$$，$$\\Delta t = 1\\times 10^{-2}$$，$$u = 0.1$$，$$N_{\\text{steps}} = 100$$，初始条件 $$q(x) = 1 + \\sin(2\\pi x)$$，方法：带线性插值的点值 SL。\n- 案例 2（光滑场，小库朗数，高阶插值）：与案例 1 参数相同，但使用三次插值，方法：带三次插值的点值 SL。\n- 案例 3（非光滑场，小库朗数，插值引发质量误差的压力测试）：$$N_x = 128$$，$$\\Delta t = 1\\times 10^{-2}$$，$$u = 0.1$$，$$N_{\\text{steps}} = 100$$，初始条件为当 $$x \\in [0.25,0.75]$$ 时 $$q(x) = 1$$ 否则 $$q(x) = 0$$（周期性解释），方法：带线性插值的点值 SL。\n- 案例 4（非光滑场，守恒几何重映）：与案例 3 参数相同，但方法为：单元平均值的守恒几何重映。\n- 案例 5（每步有效位移大，守恒几何重映，周期性环绕压力测试）：$$N_x = 128$$，$$\\Delta t = 0.1$$，$$u = 0.5$$，$$N_{\\text{steps}} = 25$$，初始条件 $$q(x) = \\exp\\left(-\\left(\\frac{x - 0.3}{0.05}\\right)^2\\right)$$，方法：单元平均值的守恒几何重映。\n\n您的程序必须以精确格式生成输出：一个包含列表 $$[E_1,E_2,E_3,E_4,E_5]$$ 的单行文本，其中每个 $$E_k$$ 是案例 $$k$$ 计算出的全局质量误差，以浮点数表示。",
            "solution": "该问题要求计算几种半拉格朗日（SL）平流方案应用于一维线性平流方程 $\\frac{\\partial q}{\\partial t} + u \\frac{\\partial q}{\\partial x} = 0$（在周期性域 $x \\in [0,1)$ 上）的全局质量误差。总质量 $M(t) = \\int_0^1 q(x,t) \\, dx$ 是连续方程的一个不变量。我们将研究不同的离散数值方法对该性质的保持情况。\n\n首先，我们建立离散框架。该域被离散为 $N_x$ 个均匀单元，每个单元的宽度为 $\\Delta x = 1/N_x$。量 $q(x,t)$ 在时间步 $n$ 由一个离散值向量 $q^n$ 表示。考虑两种表示方法：\n1.  **点值**：$q_i^n$ 表示场在单元中心 $x_i = (i + 0.5)\\Delta x$（其中 $i=0, \\dots, N_x-1$）的值。因此，$q_i^n \\approx q(x_i, n\\Delta t)$。\n2.  **单元平均值**：$q_i^n$ 表示在单元 $i$（即区间 $[i\\Delta x, (i+1)\\Delta x)$）上的平均值。因此，$q_i^n = \\frac{1}{\\Delta x} \\int_{i\\Delta x}^{(i+1)\\Delta x} q(x, n\\Delta t) \\, dx$。\n\n初始离散场 $q^0$ 是通过将给定的连续初始条件 $q(x,0)$ 投影到网格上获得的。\n- 对于点值表示，我们在单元中心对函数进行采样：$q_i^0 = q(x_i, 0)$。\n- 对于单元平均值表示，我们计算真实的单元平均值：$q_i^0 = \\frac{1}{\\Delta x} \\int_{i\\Delta x}^{(i+1)\\Delta x} q(x,0) \\, dx$。对于方波函数，该积分可解析计算；对于高斯分布则使用误差函数 `erf`（即高斯函数的解析积分）进行计算。\n\n时间步 $n$ 的离散总质量定义为 $M^n = \\Delta x \\sum_{i=0}^{N_x-1} q_i^n$。$N_{\\text{steps}}$ 步后的全局质量误差是最终离散质量与初始离散质量之差：$E = M^{N_{\\text{steps}}} - M^0$。\n\n现在我们详细介绍半拉格朗日时间步进算法。SL 方法的核心思想是沿时间向后追踪特征线。为了找到到达点 $x_a$ 的值 $q^{n+1}$，我们找到其出发点 $x_d = x_a - u\\Delta t$，并设 $q^{n+1}(x_a) = q^n(x_d)$。\n\n**1. 带插值的点值 SL**\n\n在此范式中，我们更新每个单元中心 $x_i$ 处的点值。新值 $q_i^{n+1}$ 通过在出发点 $x_d = x_i - u\\Delta t$ 对场 $q^n$ 进行插值来确定。\n出发点 $x_d$ 通常不会与网格点重合。其相对于网格的位置用于执行插值。我们定义一个连续的网格坐标 $p(x) = (x / \\Delta x) - 0.5$，使得网格点 $x_i$ 对应于整数坐标 $i$。$x_i$ 的出发位置是 $p_d = ((x_i - u\\Delta t) \\pmod{1}) / \\Delta x - 0.5$。设 $j = \\lfloor p_d \\rfloor$ 为整数部分，$f = p_d - j$ 为小数部分，其中 $0 \\le f  1$。\n\n-   **线性插值**：我们使用最近的两个网格点 $j$ 和 $j+1$ 来构建一个线性插值。索引按周期性处理。\n    $$q_i^{n+1} = (1-f) q_{j \\pmod{N_x}}^n + f q_{(j+1) \\pmod{N_x}}^n$$\n    此方法简单且计算效率高，但本质上不保证质量守恒。插值后值的总和不保证等于原始值的总和。\n\n-   **三次插值**：使用四个网格点可以实现更高阶、更精确的插值。我们使用拉格朗日形式，构建一个通过点 $(j-1, q_{j-1}^n)$、$(j, q_j^n)$、$(j+1, q_{j+1}^n)$ 和 $(j+2, q_{j+2}^n)$ 的多项式。在相对于网格点 $j$ 的小数位置 $f$ 处评估此多项式，得到：\n    $$q_i^{n+1} = L(f) = \\sum_{m=-1}^{2} q_{j+m}^n \\prod_{k=-1, k\\ne m}^{2} \\frac{f-k}{m-k}$$\n    显式地，这是：\n    $$q_i^{n+1} = q_{j-1}^n \\frac{f(f-1)(f-2)}{-6} + q_j^n \\frac{(f+1)(f-1)(f-2)}{2} + q_{j+1}^n \\frac{(f+1)f(f-2)}{-2} + q_{j+2}^n \\frac{(f+1)f(f-1)}{6}$$\n    所有索引都是周期性的。与线性插值一样，此方法不保证质量守恒。\n\n**2. 守恒几何重映**\n\n此方法被设计为离散质量守恒。场 $q^n$ 被解释为分段常数函数，其在区间 $[i\\Delta x, (i+1)\\Delta x)$ 上的值为 $q_i^n$。新的单元平均值 $q_i^{n+1}$ 通过计算 $q^n$ 在单元 $i$ 的出发区域上的平均值得到。该区域是向后平移的区间 $[i\\Delta x, (i+1)\\Delta x)$，即 $[i\\Delta x - u\\Delta t, (i+1)\\Delta x - u\\Delta t)$。\n新的单元平均值为：\n$$q_i^{n+1} = \\frac{1}{\\Delta x} \\int_{i\\Delta x - u\\Delta t}^{(i+1)\\Delta x - u\\Delta t} q^n(x') \\, dx'$$\n令 $\\alpha = u\\Delta t / \\Delta x$ 为以网格单元为单位的位移。令 $k = \\lfloor \\alpha \\rfloor$ 且 $\\delta = \\alpha - k$。单元 $i$ 的出发区间为 $[(i-k-\\delta)\\Delta x, (i-k-\\delta+1)\\Delta x)$。由于 $q^n$ 是分段常数，该积分是此区间与旧网格单元重叠的各段上的总和。此计算产生了一个看似简单但功能强大的更新规则：\n$$q_i^{n+1} = (1-\\delta) q_{(i-k) \\pmod{N_x}}^n + \\delta q_{(i-k-1) \\pmod{N_x}}^n$$\n该方案根据其构造是守恒的。为了验证，我们对所有单元求和：\n$$M^{n+1} = \\Delta x \\sum_{i=0}^{N_x-1} q_i^{n+1} = \\Delta x \\sum_{i=0}^{N_x-1} \\left( (1-\\delta) q_{i-k}^n + \\delta q_{i-k-1}^n \\right)$$\n通过对求和项重新索引（由于周期性，这是有效的），我们得到：\n$$M^{n+1} = \\Delta x \\left( (1-\\delta) \\sum_{j=0}^{N_x-1} q_j^n + \\delta \\sum_{j=0}^{N_x-1} q_j^n \\right) = (1-\\delta) M^n + \\delta M^n = M^n$$\n因此，离散质量在每个时间步都是精确守恒的。对于此方法，计算出的任何误差 $E$ 都应仅由浮点舍入误差引起。\n\n提供的 Python 代码实现了这些算法，用于计算每个指定测试案例的质量误差。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import erf\n\ndef initialize_q(Nx, ic_name, method):\n    \"\"\"\n    Initializes the discrete field q0 based on the initial condition function\n    and the representation (pointwise or cell-average).\n    \"\"\"\n    dx = 1.0 / Nx\n    if method.startswith('pointwise'):\n        x = (np.arange(Nx) + 0.5) * dx\n        if ic_name == 'sin':\n            return 1.0 + np.sin(2 * np.pi * x)\n        elif ic_name == 'box':\n            return np.where((x = 0.25)  (x  0.75), 1.0, 0.0)\n    elif method.startswith('conservative'):\n        q0 = np.zeros(Nx)\n        if ic_name == 'box':\n            for i in range(Nx):\n                x_left, x_right = i * dx, (i + 1) * dx\n                overlap = max(0.0, min(x_right, 0.75) - max(x_left, 0.25))\n                q0[i] = overlap / dx\n            return q0\n        elif ic_name == 'gauss':\n            mu, sigma = 0.3, 0.05\n            # Use the analytical integral of a Gaussian, which involves the error function (erf)\n            # ∫ exp(-((x-μ)/σ)²) dx = σ * sqrt(π)/2 * erf((x-μ)/σ)\n            sqrt_pi_half_sigma = sigma * np.sqrt(np.pi) / 2.0\n            for i in range(Nx):\n                x_left, x_right = i * dx, (i + 1) * dx\n                integral = sqrt_pi_half_sigma * (erf((x_right - mu) / sigma) - erf((x_left - mu) / sigma))\n                q0[i] = integral / dx\n            return q0\n    return None\n\ndef advect_step(q, Nx, dx, u, dt, method):\n    \"\"\"\n    Performs a single time step of semi-Lagrangian advection.\n    \"\"\"\n    if method == 'pointwise_linear':\n        x_centers = (np.arange(Nx) + 0.5) * dx\n        x_depart = x_centers - u * dt\n        \n        # Calculate fractional grid positions for departure points\n        p = ((x_depart % 1.0) / dx) - 0.5\n        j = np.floor(p).astype(int)\n        f = p - j\n        \n        # Use np.take for efficient periodic boundary handling\n        q_j = np.take(q, j, mode='wrap')\n        q_j1 = np.take(q, j + 1, mode='wrap')\n        \n        return (1.0 - f) * q_j + f * q_j1\n\n    elif method == 'pointwise_cubic':\n        x_centers = (np.arange(Nx) + 0.5) * dx\n        x_depart = x_centers - u * dt\n        \n        p = ((x_depart % 1.0) / dx) - 0.5\n        j = np.floor(p).astype(int)\n        s = p - j  # Fractional part for Lagrange formula\n        \n        q_jm1 = np.take(q, j - 1, mode='wrap')\n        q_j = np.take(q, j, mode='wrap')\n        q_j1 = np.take(q, j + 1, mode='wrap')\n        q_j2 = np.take(q, j + 2, mode='wrap')\n        \n        # 4-point Lagrange interpolation formula\n        term_m1 = q_jm1 * s * (s - 1.0) * (s - 2.0) / -6.0\n        term_0 = q_j * (s + 1.0) * (s - 1.0) * (s - 2.0) / 2.0\n        term_1 = q_j1 * (s + 1.0) * s * (s - 2.0) / -2.0\n        term_2 = q_j2 * (s + 1.0) * s * (s - 1.0) / 6.0\n        \n        return term_m1 + term_0 + term_1 + term_2\n\n    elif method == 'conservative_remapping':\n        alpha = u * dt / dx  # Displacement in grid cell units\n        k = np.floor(alpha).astype(int)\n        delta = alpha - k\n        \n        # Update rule derived from geometric remapping of cell averages\n        # q_new[i] = (1-delta)*q[i-k] + delta*q[i-(k+1)]\n        # This is vectorized using np.roll for periodic shifts\n        q_new = (1.0 - delta) * np.roll(q, k) + delta * np.roll(q, k + 1)\n        return q_new\n\n    else:\n        raise ValueError(f\"Unknown method: {method}\")\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and compute global mass errors.\n    \"\"\"\n    test_cases = [\n        # (Nx, dt, u, N_steps, ic_name, method)\n        (128, 1e-2, 0.1, 100, 'sin', 'pointwise_linear'),\n        (128, 1e-2, 0.1, 100, 'sin', 'pointwise_cubic'),\n        (128, 1e-2, 0.1, 100, 'box', 'pointwise_linear'),\n        (128, 1e-2, 0.1, 100, 'box', 'conservative_remapping'),\n        (128, 0.1, 0.5, 25, 'gauss', 'conservative_remapping'),\n    ]\n\n    results = []\n    for case in test_cases:\n        Nx, dt, u, N_steps, ic_name, method = case\n        \n        dx = 1.0 / Nx\n        \n        # 1. Initialize the field q\n        q0 = initialize_q(Nx, ic_name, method)\n        \n        # 2. Compute initial mass\n        M0 = np.sum(q0) * dx\n        \n        # 3. Time-step the solution\n        q = q0.copy()\n        for _ in range(N_steps):\n            q = advect_step(q, Nx, dx, u, dt, method)\n            \n        # 4. Compute final mass and error\n        M_final = np.sum(q) * dx\n        error = M_final - M0\n        results.append(error)\n        \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在地球系统模型等实际应用中，平流问题通常是多维的。为了简化计算，一种常用技术是算子分裂或维度分裂，即将多维平流分解为一系列一维平流步骤。然而，当速度场各分量相互耦合时（例如旋转流），这种分裂会引入特有的结构性误差。本练习  通过一个二维刚体旋转的经典测试案例，旨在隔离并量化这种由维度分裂引起的误差，帮助理解其对模拟结果的影响。",
            "id": "4199723",
            "problem": "考虑一个由速度场 $\\boldsymbol{u}(x,y,t)$ 控制的、坐标为 $x$ 和 $y$ 的平面上的二维被动标量平流方程，其形式为以下一阶偏微分方程 (PDE)\n$$\n\\frac{\\partial f}{\\partial t} + \\boldsymbol{u}\\cdot\\nabla f = 0,\n$$\n其中 $f(x,y,t)$ 是被平流的标量。在半拉格朗日平流格式中，位于到达点 $(x,y)$ 和时间 $t+\\Delta t$ 的标量 $f$ 的值，是通过沿着特征线回溯到时间 $t$ 的出发点 $(x_d,y_d)$，然后对 $f(x_d,y_d,t)$ 进行采样来计算的。该方法通过追踪特征线而非执行显式通量更新，从而避免了欧拉方法的 Courant–Friedrichs–Lewy 约束。\n\n本问题旨在分析维度分裂方法在旋转流中引入的误差，并量化在与聚变等离子体湍流模拟相关的刚体旋转测试中产生的虚假交叉导数效应，其中 ExB 旋转是一个常见的主题。你必须从第一性原理出发进行推导，并实现一个程序来计算分裂方法在一个光滑测试函数上产生的误差，然后量化误差中与二阶混合导数（交叉导数）结构对齐的分量。\n\n基本原理和设置：\n- 速度场是角速度为 $\\Omega$（单位：弧度/秒）的刚体旋转，由下式给出：\n$$\nu(x,y) = -\\Omega\\,y,\\qquad v(x,y) = \\Omega\\,x.\n$$\n- 对于一个时间步长 $\\Delta t$（单位：秒），将时间 $t+\\Delta t$ 的到达位置 $(x,y)$ 映射到时间 $t$ 的出发位置 $(x_d,y_d)$ 的精确特征流，是在时间上向后旋转角度 $\\theta=\\Omega\\,\\Delta t$（单位：弧度）。精确的出发点映射为：\n$$\nx_d^{\\mathrm{exact}} = x\\cos\\theta + y\\sin\\theta,\\qquad\ny_d^{\\mathrm{exact}} = -x\\sin\\theta + y\\cos\\theta.\n$$\n- 一个采用 Lie 分裂（先沿 $x$ 方向平流，再沿 $y$ 方向平流）的维度分裂半拉格朗日方法，通过序列化的一维回溯来计算出发点映射：\n$$\nx^{(1)} = x - u(x,y)\\,\\Delta t = x + \\Omega\\,y\\,\\Delta t,\\qquad y^{(1)} = y,\n$$\n$$\nx_d^{\\mathrm{split}} = x^{(1)},\\qquad y_d^{\\mathrm{split}} = y^{(1)} - v(x^{(1)},y^{(1)})\\,\\Delta t = y - \\Omega\\,x^{(1)}\\,\\Delta t.\n$$\n- 初始条件 $f_0(x,y)$ 是一个旋转的椭圆高斯函数，这是一个光滑的测试剖面，它打破了轴对称性以揭示交叉导数的耦合效应。定义主轴坐标为：\n$$\nx' = x\\cos\\alpha + y\\sin\\alpha,\\qquad y' = -x\\sin\\alpha + y\\cos\\alpha,\n$$\n并令\n$$\nf_0(x,y) = \\exp\\!\\left(-\\left[\\frac{x'^2}{\\sigma_1^2} + \\frac{y'^2}{\\sigma_2^2}\\right]\\right),\n$$\n其中 $\\alpha$ 是旋转角（单位：弧度），$\\sigma_1, \\sigma_2$ 是半轴宽度（与 $x$ 和 $y$ 的长度单位相同）。精确的半拉格朗日更新得到 $f^{\\mathrm{exact}}(x,y) = f_0\\!\\left(x_d^{\\mathrm{exact}},y_d^{\\mathrm{exact}}\\right)$，而分裂更新得到 $f^{\\mathrm{split}}(x,y) = f_0\\!\\left(x_d^{\\mathrm{split}},y_d^{\\mathrm{split}}\\right)$。\n\n误差量化：\n- 定义局部误差场\n$$\nE(x,y) = f^{\\mathrm{split}}(x,y) - f^{\\mathrm{exact}}(x,y).\n$$\n- 将初始条件 $f_0$ 在到达网格上的二阶混合导数（交叉导数）定义为\n$$\nD_{xy}(x,y) = \\frac{\\partial^2 f_0}{\\partial x\\,\\partial y}(x,y),\n$$\n该导数在网格上通过周期性中心差分进行数值计算。\n- 计算误差的 $L^2$ 范数\n$$\n\\|E\\|_{2} = \\left(\\int_{\\Omega_D} E(x,y)^2\\,\\mathrm{d}x\\,\\mathrm{d}y\\right)^{1/2},\n$$\n和 $L^\\infty$ 范数 $\\|E\\|_{\\infty} = \\max_{(x,y)\\in\\Omega_D} |E(x,y)|$，其中 $\\Omega_D$ 表示计算域。\n- 通过将 $E$ 在网格上的离散内积中正交投影到 $D_{xy}$ 上，来量化虚假的交叉导数效应：\n$$\nC_{xy} = \\frac{\\langle E, D_{xy} \\rangle}{\\langle D_{xy}, D_{xy} \\rangle},\n$$\n其中 $\\langle A,B\\rangle = \\int_{\\Omega_D} A(x,y)\\,B(x,y)\\,\\mathrm{d}x\\,\\mathrm{d}y$ 通过求和乘以单元面积来近似。与交叉导数结构对齐的误差能量所占比例为\n$$\nR = \\frac{|C_{xy}|\\,\\|D_{xy}\\|_{2}}{\\|E\\|_{2}},\n$$\n这是一个无量纲量。\n\n域、单位和数值方法：\n- 使用边长为 $L$（单位：米）的方形周期性域，即 $x,y\\in[-L/2,L/2)$，该区域被均匀离散为 $N_x\\times N_y$ 个点，间距为 $\\Delta x = L/N_x$，$\\Delta y = L/N_y$。\n- 时间单位为秒，$\\Omega$ 的单位为弧度/秒，角度（如 $\\theta$ 和 $\\alpha$）的单位为弧度。\n- 所有报告的输出均为无量纲浮点数。在此测试中，标量 $f$ 是无单位的。\n- 初始条件和所有 $f_0(x_d,y_d)$ 的求值都必须根据旋转高斯函数的定义进行解析计算，而不是通过网格插值，以将分裂误差与插值误差分离开来。\n\n程序行为要求：\n- 实现上述的映射和度量。\n- 使用周期性中心差分计算 $D_{xy}$。\n- 对每个测试用例，计算并按顺序返回四个浮点数：$\\|E\\|_2$、$\\|E\\|_\\infty$、$C_{xy}$ 和 $R$。\n\n测试套件：\n- 设 $N_x=N_y=128$，$L=1$，且 $\\Omega=2\\pi$。\n- 三个测试用例，涵盖不同方面：\n    1. 理想路径：$\\Delta t = 1/64$，$\\alpha = \\pi/6$，$\\sigma_1 = 0.15$，$\\sigma_2 = 0.25$。\n    2. 更大的时间步长：$\\Delta t = 1/8$，$\\alpha = \\pi/6$，$\\sigma_1 = 0.15$，$\\sigma_2 = 0.25$。\n    3. 对称性边缘情况（预期交叉导数投影接近于零）：$\\Delta t = 1/8$，$\\alpha = 0$，$\\sigma_1 = 0.2$，$\\sigma_2 = 0.2$。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如 $[r_1,r_2,\\dots]$），列表中的条目是测试用例1的4个浮点数，后跟测试用例2的4个浮点数，再后跟测试用例3的4个浮点数；因此，单个列表中总共有12个浮点数。",
            "solution": "我们从被动标量平流 PDE $\\partial_t f + \\boldsymbol{u}\\cdot\\nabla f = 0$ 开始，该方程意味着 $f$ 沿着特征线为常数。特征线 $(x(t),y(t))$ 满足以下常微分方程 (ODEs)：\n$$\n\\frac{dx}{dt} = u(x,y) = -\\Omega\\,y, \\qquad \\frac{dy}{dt} = v(x,y) = \\Omega\\,x,\n$$\n其中 $\\Omega$ 是旋转的角频率。这些线性常微分方程的解是一个匀速旋转。在一个时间步长 $\\Delta t$ 内，从时间 $t$ 的点 $(x_0,y_0)$ 到时间 $t+\\Delta t$ 的点 $(x_1,y_1)$ 的前向映射为：\n$$\nx_1 = x_0\\cos\\theta - y_0\\sin\\theta,\\qquad y_1 = x_0\\sin\\theta + y_0\\cos\\theta,\\qquad \\theta = \\Omega\\,\\Delta t.\n$$\n半拉格朗日更新需要进行回溯：给定时间 $t+\\Delta t$ 的点 $(x,y)$，找到时间 $t$ 的点 $(x_d^{\\mathrm{exact}},y_d^{\\mathrm{exact}})$，使得 $f(x,y,t+\\Delta t) = f(x_d^{\\mathrm{exact}},y_d^{\\mathrm{exact}},t)$。对前向旋转求逆可得到精确的出发点映射：\n$$\nx_d^{\\mathrm{exact}} = x\\cos\\theta + y\\sin\\theta,\\qquad y_d^{\\mathrm{exact}} = -x\\sin\\theta + y\\cos\\theta.\n$$\n\n维度分裂通过序列化的一维求解来近似二维平流。对于 Lie 分裂（先沿 $x$ 移动，再沿 $y$ 移动），我们定义算子 $\\mathcal{A} = u(x,y)\\,\\partial_x$ 和 $\\mathcal{B} = v(x,y)\\,\\partial_y$。一个步长内，先应用 $x$ 方向平流 $\\Delta t$，再应用 $y$ 方向平流 $\\Delta t$。相应的半拉格朗日回溯使用：\n$$\nx^{(1)} = x - u(x,y)\\,\\Delta t = x + \\Omega y\\,\\Delta t,\\qquad y^{(1)} = y,\n$$\n$$\nx_d^{\\mathrm{split}} = x^{(1)},\\qquad y_d^{\\mathrm{split}} = y^{(1)} - v\\big(x^{(1)},y^{(1)}\\big)\\,\\Delta t = y - \\Omega x^{(1)}\\,\\Delta t.\n$$\n对于具有对易算子的可分离平流，此映射是精确的，但对于旋转，算子并不能对易。Lie 分裂的局部误差可以使用 Baker-Campbell-Hausdorff (BCH) 展开进行分析：对于非对易算子 $\\mathcal{A}$ 和 $\\mathcal{B}$，一步会引入一个与对易子 $[\\mathcal{A},\\mathcal{B}]$ 成正比的 $O(\\Delta t^2)$ 误差。对于我们的旋转场，其中 $\\mathcal{A} = -\\Omega y\\,\\partial_x$ 和 $\\mathcal{B} = \\Omega x\\,\\partial_y$，将对易子作用于一个光滑函数 $f$ 得到\n$$\n[\\mathcal{A},\\mathcal{B}] f = \\mathcal{A}(\\mathcal{B}f) - \\mathcal{B}(\\mathcal{A}f) = \\Omega^2\\left(x\\,\\partial_x f - y\\,\\partial_y f\\right).\n$$\n等价地，对精确和分裂的出发点映射在小 $\\Delta t$ 情况下进行泰勒展开，可以得到：\n$$\nx_d^{\\mathrm{exact}} = x + \\Omega y\\,\\Delta t - \\tfrac{1}{2}\\Omega^2 x\\,\\Delta t^2 + O(\\Delta t^3),\\qquad\ny_d^{\\mathrm{exact}} = y - \\Omega x\\,\\Delta t - \\tfrac{1}{2}\\Omega^2 y\\,\\Delta t^2 + O(\\Delta t^3),\n$$\n而\n$$\nx_d^{\\mathrm{split}} = x + \\Omega y\\,\\Delta t,\\qquad\ny_d^{\\mathrm{split}} = y - \\Omega x\\,\\Delta t - \\Omega^2 y\\,\\Delta t^2.\n$$\n相减得到\n$$\n\\delta x_d = x_d^{\\mathrm{split}} - x_d^{\\mathrm{exact}} = \\tfrac{1}{2}\\Omega^2 x\\,\\Delta t^2 + O(\\Delta t^3), \\qquad\n\\delta y_d = y_d^{\\mathrm{split}} - y_d^{\\mathrm{exact}} = -\\tfrac{1}{2}\\Omega^2 y\\,\\Delta t^2 + O(\\Delta t^3).\n$$\n标量的主阶误差则为\n$$\nE(x,y) = f^{\\mathrm{split}}(x,y) - f^{\\mathrm{exact}}(x,y) \\approx \\partial_x f_0\\big(x_d^{\\mathrm{exact}},y_d^{\\mathrm{exact}}\\big)\\,\\delta x_d + \\partial_y f_0\\big(x_d^{\\mathrm{exact}},y_d^{\\mathrm{exact}}\\big)\\,\\delta y_d,\n$$\n该式在 $O(\\Delta t^2)$ 阶上与对易子的结果一致，\n$$\nE(x,y) \\approx \\tfrac{1}{2}\\Omega^2\\,\\Delta t^2\\left(x\\,\\partial_x f_0 - y\\,\\partial_y f_0\\right),\n$$\n其中导数在适当接近的点上求值。这表明主导误差是方向导数的不平衡，而非纯粹的混合导数。然而，对于旋转的各向异性高斯函数 $f_0$，其空间结构会将这些不平衡耦合到包含混合导数 $\\partial^2 f_0/(\\partial x\\,\\partial y)$ 的基分量中，从而产生一个可测量的到 $D_{xy}$ 上的投影。\n\n为量化这种虚假的交叉导数效应，我们计算：\n1. 误差场 $E(x,y)$，即分裂与精确半拉格朗日更新之差。更新是通过在各自的出发点解析地计算 $f_0$ 来执行的。这将分裂误差与插值误差分离开来。\n2. $E$ 的 $L^2$ 和 $L^\\infty$ 范数，即 $\\|E\\|_2$ 和 $\\|E\\|_\\infty$。\n3. 网格上对 $D_{xy}(x,y)$ 的周期性中心差分近似。\n4. 投影系数 $C_{xy} = \\langle E,D_{xy}\\rangle/\\langle D_{xy},D_{xy}\\rangle$ 和比例 $R = |C_{xy}|\\,\\|D_{xy}\\|_2/\\|E\\|_2$。\n\n算法设计：\n- 在 $x,y\\in[-L/2,L/2)$ 上构建一个 $N_x=N_y=128$ 的均匀网格，其中 $L=1$，间距为 $\\Delta x = \\Delta y = L/N_x$。\n- 定义旋转坐标 $x' = x\\cos\\alpha + y\\sin\\alpha$，$y' = -x\\sin\\alpha + y\\cos\\alpha$，以及 $f_0(x,y) = \\exp\\!\\left(-\\left[x'^2/\\sigma_1^2 + y'^2/\\sigma_2^2\\right]\\right)$。\n- 对每个角速度为 $\\Omega=2\\pi$ 和给定 $\\Delta t$ 的测试用例，计算 $\\theta=\\Omega\\Delta t$（单位：弧度）。\n- 通过上述公式计算精确和分裂的出发点映射，以获得 $(x_d^{\\mathrm{exact}},y_d^{\\mathrm{exact}})$ 和 $(x_d^{\\mathrm{split}},y_d^{\\mathrm{split}})$。\n- 在这些出发点上解析地计算 $f_0$，以在到达网格上得到 $f^{\\mathrm{exact}}$ 和 $f^{\\mathrm{split}}$；计算 $E=f^{\\mathrm{split}}-f^{\\mathrm{exact}}$。\n- 通过周期性中心差分计算 $D_{xy}$：\n$$\nD_{xy}(i,j) \\approx \\frac{f_0(i+1,j+1)-f_0(i+1,j-1)-f_0(i-1,j+1)+f_0(i-1,j-1)}{4\\,\\Delta x\\,\\Delta y}.\n$$\n- 对每个测试用例，使用单元面积 $\\Delta x\\,\\Delta y$ 计算离散内积，以获得 $\\|E\\|_2$、$\\|E\\|_\\infty$、$C_{xy}$ 和 $R$。\n\n测试套件覆盖范围：\n- 一个小 $\\Delta t$ 的情况（$\\Delta t=1/64$）展示了 $\\|E\\|_2$ 预期的 $O(\\Delta t^2)$ 标度律和通常较小的 $R$ 值。\n- 一个较大 $\\Delta t$ 的情况（$\\Delta t=1/8$）会放大分裂误差和交叉导数投影，从而增加 $\\|E\\|_\\infty$ 和 $R$。\n- 一个对称性边缘情况，其中 $\\alpha=0$ 且 $\\sigma_1=\\sigma_2$，使得初始条件具有旋转对称性；尽管 $D_{xy}$ 不恒等于零，但由于对称性，预计投影系数 $C_{xy}$ 和比例 $R$ 会相对较小。\n\n最终程序遵循这些步骤，并为每个测试用例按顺序报告四个浮点数 $\\|E\\|_2$、$\\|E\\|_\\infty$、$C_{xy}$ 和 $R$，按要求汇总成一个用方括号括起来的逗号分隔列表。所有角度均以弧度处理，$\\Omega$ 的单位是弧度/秒，$\\Delta t$ 的单位是秒，输出为无量纲浮点数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef rotated_gaussian(x, y, sigma1, sigma2, alpha):\n    # Compute rotated coordinates\n    xp = x * np.cos(alpha) + y * np.sin(alpha)\n    yp = -x * np.sin(alpha) + y * np.cos(alpha)\n    return np.exp(-((xp / sigma1) ** 2 + (yp / sigma2) ** 2))\n\ndef exact_departure(x, y, theta):\n    # Backward characteristic for solid-body rotation: inverse of forward rotation\n    xd = x * np.cos(theta) + y * np.sin(theta)\n    yd = -x * np.sin(theta) + y * np.cos(theta)\n    return xd, yd\n\ndef split_departure_lie(x, y, omega, dt):\n    # Lie splitting: first x-advection then y-advection\n    x1 = x + omega * y * dt\n    y1 = y\n    yd = y1 - omega * x1 * dt\n    xd = x1\n    return xd, yd\n\ndef mixed_derivative_periodic(f, dx, dy):\n    # Central mixed derivative with periodic boundary conditions:\n    # Dxy ≈ (f(i+1,j+1) - f(i+1,j-1) - f(i-1,j+1) + f(i-1,j-1)) / (4 dx dy)\n    f_ip_jp = np.roll(np.roll(f, -1, axis=0), -1, axis=1)\n    f_ip_jm = np.roll(np.roll(f, -1, axis=0),  1, axis=1)\n    f_im_jp = np.roll(np.roll(f,  1, axis=0), -1, axis=1)\n    f_im_jm = np.roll(np.roll(f,  1, axis=0),  1, axis=1)\n    dxy = (f_ip_jp - f_ip_jm - f_im_jp + f_im_jm) / (4.0 * dx * dy)\n    return dxy\n\ndef inner_product(a, b, cell_area):\n    return np.sum(a * b) * cell_area\n\ndef l2_norm(a, cell_area):\n    return np.sqrt(np.sum(a * a) * cell_area)\n\ndef linf_norm(a):\n    return float(np.max(np.abs(a)))\n\ndef run_case(nx, ny, L, omega, dt, alpha, sigma1, sigma2):\n    # Grid\n    x = (np.arange(nx) - nx/2) * (L / nx)\n    y = (np.arange(ny) - ny/2) * (L / ny)\n    X, Y = np.meshgrid(x, y, indexing='ij')\n    dx = L / nx\n    dy = L / ny\n    cell_area = dx * dy\n\n    # Initial condition\n    f0 = rotated_gaussian(X, Y, sigma1, sigma2, alpha)\n\n    # Exact and split departures\n    theta = omega * dt\n    xd_exact, yd_exact = exact_departure(X, Y, theta)\n    xd_split, yd_split = split_departure_lie(X, Y, omega, dt)\n\n    # Evaluate f0 analytically at departure points\n    f_exact = rotated_gaussian(xd_exact, yd_exact, sigma1, sigma2, alpha)\n    f_split = rotated_gaussian(xd_split, yd_split, sigma1, sigma2, alpha)\n\n    # Error field\n    E = f_split - f_exact\n\n    # Mixed derivative of initial field at arrival grid\n    Dxy = mixed_derivative_periodic(f0, dx, dy)\n\n    # Norms and projections\n    E_l2 = l2_norm(E, cell_area)\n    E_linf = linf_norm(E)\n\n    denom = inner_product(Dxy, Dxy, cell_area)\n    if denom > 0:\n        Cxy = inner_product(E, Dxy, cell_area) / denom\n        Dxy_l2 = l2_norm(Dxy, cell_area)\n        R = (abs(Cxy) * Dxy_l2 / E_l2) if E_l2 > 0 else 0.0\n    else:\n        Cxy = 0.0\n        R = 0.0\n\n    return float(E_l2), float(E_linf), float(Cxy), float(R)\n\ndef solve():\n    # Define constants for all test cases\n    nx = 128\n    ny = 128\n    L = 1.0\n    omega = 2.0 * np.pi  # radians per second\n\n    # Test suite: (dt, alpha, sigma1, sigma2)\n    test_cases = [\n        (1.0/64.0, np.pi/6.0, 0.15, 0.25),  # Happy path\n        (1.0/8.0,  np.pi/6.0, 0.15, 0.25),  # Larger time step\n        (1.0/8.0,  0.0,       0.20, 0.20),  # Symmetry edge case\n    ]\n\n    results = []\n    for dt, alpha, sigma1, sigma2 in test_cases:\n        E_l2, E_linf, Cxy, R = run_case(nx, ny, L, omega, dt, alpha, sigma1, sigma2)\n        results.extend([E_l2, E_linf, Cxy, R])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(lambda x: f'{x:.8e}', results))}]\")\n\nsolve()\n```"
        }
    ]
}