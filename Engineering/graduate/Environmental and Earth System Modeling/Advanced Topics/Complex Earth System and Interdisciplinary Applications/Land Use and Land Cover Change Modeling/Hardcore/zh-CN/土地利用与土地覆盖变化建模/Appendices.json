{
    "hands_on_practices": [
        {
            "introduction": "土地利用和土地覆盖变化（LULC）模型在很大程度上依赖于从卫星图像中提取的准确输入数据。植被指数，如归一化植被指数（$NDVI$）和增强型植被指数（$EVI$），是区分植被与其他地表覆盖类型以及评估植被健康状况的基础。本练习将通过一个具体案例，帮助您掌握这些关键指数的计算，并理解其背后的物理原理，特别是关于大气校正的考量，这是遥感数据预处理中的一个关键步骤。",
            "id": "3888134",
            "problem": "在一个混合农业景观上获取的一个多光谱光学遥感像元，通过三个光谱波段$\\left(B_2,B_3,B_4\\right)$进行观测，其双向地表反射率分别为$\\left(0.12,0.09,0.22\\right)$。假设$B_2$对应蓝光波段，$B_3$对应红光波段，$B_4$对应近红外波段。用于土地利用和土地覆盖变化建模的植被指数，是通过具有物理动机的光谱反射率组合构建的，这些组合利用了红光波段的色素吸收和近红外波段的强叶片散射之间的对比，并加入了气溶胶阻抗项。\n\n仅使用植被指数的核心定义和经过充分检验的公式，计算该像元的归一化植被指数（NDVI）和增强型植被指数（EVI）。在推导EVI时，使用中分辨率成像光谱仪（MODIS）文献中采用的标准系数，即$G=2.5$，$L=1$，$C_1=6$和$C_2=7.5$。然后，基于第一性原理，讨论哪个指数对残留的大气效应（例如，不完全校正后残留的加性路径辐射）更敏感，并结合蓝光波段和权重项的作用解释原因。\n\n将每个指数表示为纯数（无量纲），并将数值结果四舍五入至四位有效数字。",
            "solution": "该问题是有效的，因为它在科学上基于光学遥感的原理，问题陈述清晰，为计算提供了所有必要信息，并且用客观、精确的语言表达。它要求应用标准、公认的公式，并基于大气辐射传输的第一性原理进行讨论，这些原理是环境和地球系统建模的核心。\n\n问题提供了三个光谱波段的地表反射率：\n蓝光波段反射率，$\\rho_{\\text{blue}} = B_2 = 0.12$\n红光波段反射率，$\\rho_{\\text{red}} = B_3 = 0.09$\n近红外（NIR）波段反射率，$\\rho_{\\text{NIR}} = B_4 = 0.22$\n\n我们的任务是计算两个标准的植被指数——归一化植被指数（NDVI）和增强型植被指数（EVI），并讨论它们对大气效应的相对敏感性。\n\n首先，我们计算NDVI。NDVI的公式定义为近红外和红光反射率之间的归一化差异：\n$$\n\\text{NDVI} = \\frac{\\rho_{\\text{NIR}} - \\rho_{\\text{red}}}{\\rho_{\\text{NIR}} + \\rho_{\\text{red}}}\n$$\n代入给定的反射率值：\n$$\n\\text{NDVI} = \\frac{0.22 - 0.09}{0.22 + 0.09} = \\frac{0.13}{0.31}\n$$\n计算数值：\n$$\n\\text{NDVI} \\approx 0.4193548...\n$$\n四舍五入到四位有效数字，我们得到 $\\text{NDVI} = 0.4194$。\n\n接下来，我们计算EVI。包含标准MODIS系数的EVI公式为：\n$$\n\\text{EVI} = G \\times \\frac{\\rho_{\\text{NIR}} - \\rho_{\\text{red}}}{\\rho_{\\text{NIR}} + C_1 \\times \\rho_{\\text{red}} - C_2 \\times \\rho_{\\text{blue}} + L}\n$$\n问题提供了系数：$G = 2.5$，$L = 1$，$C_1 = 6$ 和 $C_2 = 7.5$。将这些系数和反射率值代入公式：\n$$\n\\text{EVI} = 2.5 \\times \\frac{0.22 - 0.09}{0.22 + (6 \\times 0.09) - (7.5 \\times 0.12) + 1}\n$$\n首先，我们计算分母中的各项：\n$$\n6 \\times 0.09 = 0.54\n$$\n$$\n7.5 \\times 0.12 = 0.90\n$$\n现在，将这些值代回EVI方程：\n$$\n\\text{EVI} = 2.5 \\times \\frac{0.13}{0.22 + 0.54 - 0.90 + 1}\n$$\n$$\n\\text{EVI} = 2.5 \\times \\frac{0.13}{0.86}\n$$\n计算数值：\n$$\n\\text{EVI} \\approx 2.5 \\times 0.1511627... \\approx 0.3779069...\n$$\n四舍五入到四位有效数字，我们得到 $\\text{EVI} = 0.3779$。\n\n最后，我们讨论NDVI和EVI对残留大气效应的相对敏感性。大气污染，主要来自气溶胶散射和分子（Rayleigh）散射，会引入一种称为路径辐射的加性信号。这种效应与波长有关，在较短波长（即蓝光波段）处最强，并随着波长的增加而减弱。\n\nNDVI是一个简单的比值。虽然比值形式可以减少乘性噪声（例如，光照角度的变化），但它对路径辐射等加性噪声高度敏感。如果在波段$\\lambda$中存在一个加性大气信号$\\delta_{\\lambda}$，那么传感器测得的反射率$\\rho^*_{\\lambda}$约等于$\\rho_{\\lambda} + \\delta_{\\lambda}$。从传感器反射率计算出的NDVI将是：\n$$\n\\text{NDVI}_{\\text{atm}} = \\frac{(\\rho_{\\text{NIR}} + \\delta_{\\text{NIR}}) - (\\rho_{\\text{red}} + \\delta_{\\text{red}})}{(\\rho_{\\text{NIR}} + \\delta_{\\text{NIR}}) + (\\rho_{\\text{red}} + \\delta_{\\text{red}})} = \\frac{\\rho_{\\text{NIR}} - \\rho_{\\text{red}} + \\delta_{\\text{NIR}} - \\delta_{\\text{red}}}{\\rho_{\\text{NIR}} + \\rho_{\\text{red}} + \\delta_{\\text{NIR}} + \\delta_{\\text{red}}}\n$$\n由于加性项$\\delta_{\\lambda}$不会相互抵消，NDVI对大气条件敏感，尤其是对气溶胶的变化。\n\nEVI的构建正是为了缓解这个问题。其结构相对于NDVI有两个关键改进：\n1.  分母中有一个土壤调节因子$L$，用于将植被信号与冠层背景亮度解耦。\n2.  一个大气阻抗项，使用蓝光波段和系数$C_1$和$C_2$构建。分母项$\\rho_{\\text{NIR}} + C_1 \\rho_{\\text{red}} - C_2 \\rho_{\\text{blue}} + L$使用蓝光波段来校正气溶胶的影响。气溶胶路径辐射在蓝光光谱中显著高于红光光谱。EVI公式利用了这一物理原理。项$C_1 \\rho_{\\text{red}} - C_2 \\rho_{\\text{blue}}$的设计旨在将红光波段中的气溶胶信号与蓝光波段中的气溶胶信号耦合起来。由于气溶胶散射在两个波段中都增加了反射率，但在蓝光波段中更强，因此该差异项为气溶胶效应提供了一阶校正。\n\n因此，根据其数学定义中内含的第一性原理，NDVI天生就比EVI对残留的大气效应更敏感。EVI通过引入蓝光波段和特定的权重系数$C_1$和$C_2$，能够自我校正一大部分大气气溶胶污染，这是更简单的双波段NDVI所不具备的能力。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n0.4194 & 0.3779\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "在模型生成了土地覆盖分类图之后，我们必须对其准确性进行量化评估。混淆矩阵是完成此项任务的标准工具，它详细地展示了正确分类和错误分类的情况，为我们提供了对模型性能的深入洞察。通过本练习，您将学会计算和解读总体精度、用户精度和生产者精度等核心精度指标，这对于报告模型质量以及理解模型的优缺点至关重要。",
            "id": "3888144",
            "problem": "考虑一个在土地利用和土地覆盖（LULC）变化建模工作流中使用的监督土地覆盖分类，其中一个预测类别的分类栅格图通过与使用分层随机抽样设计收集的独立参考数据进行验证。这些参考数据来源于实地调查和高分辨率航空影像。设三个主题类别为 $C_{1}$ (森林)、$C_{2}$ (农业) 和 $C_{3}$ (城市)。将混淆矩阵定义为一个 $3 \\times 3$ 的矩阵 $N$，其元素 $n_{ij}$ 是被预测为类别 $C_{i}$ 但参考数据指示为类别 $C_{j}$ 的样本数量。对于一个特定的研究区域，得到以下矩阵：\n$$\nN \\;=\\; \\begin{pmatrix}\n460 & 40 & 20 \\\\\n30 & 310 & 25 \\\\\n10 & 50 & 155\n\\end{pmatrix},\n$$\n其中行按预测类别 $(C_{1}, C_{2}, C_{3})$ 排序，列按参考类别 $(C_{1}, C_{2}, C_{3})$ 排序。使用分类精度关于事件频率及其经验概率的基本定义，计算总体精度（OA）、每个预测类别的用户精度（UA）以及每个参考类别的生产者精度（PA）。将OA、每个UA和每个PA表示为小数。将您的答案四舍五入至四位有效数字。按以下顺序报告您的最终结果：$(\\text{OA}, \\text{UA}_{C_{1}}, \\text{UA}_{C_{2}}, \\text{UA}_{C_{3}}, \\text{PA}_{C_{1}}, \\text{PA}_{C_{2}}, \\text{PA}_{C_{3}})$。无需单位。",
            "solution": "用户提供了一个具有科学依据、适定、客观且包含唯一解所需全部信息的问题。其定义和数据符合遥感与空间分析领域中土地利用和土地覆盖变化建模的标准实践。问题中没有矛盾、歧义或事实错误。因此，该问题被视为有效，并将在下面提供完整解答。\n\n该问题要求根据给定的混淆矩阵 $N$ 计算几个标准的精度评估指标。该矩阵的定义是，其元素 $n_{ij}$ 代表预测类别为 $C_i$ 而真实（参考）类别为 $C_j$ 的样本数量。给定的矩阵是：\n$$\nN \\;=\\; \\begin{pmatrix}\n460 & 40 & 20 \\\\\n30 & 310 & 25 \\\\\n10 & 50 & 155\n\\end{pmatrix}\n$$\n在此，行对应于预测类别（$C_1$=森林, $C_2$=农业, $C_3$=城市），列以相同顺序列对应于参考类别。\n\n首先，我们通过对矩阵 $N$ 的所有元素求和来计算样本总数 $S_{total}$。\n$$\nS_{total} = \\sum_{i=1}^{3} \\sum_{j=1}^{3} n_{ij} = 460 + 40 + 20 + 30 + 310 + 25 + 10 + 50 + 155 = 1100\n$$\n\n接下来，我们计算所需的精度指标。\n\n总体精度 (OA)：\n总体精度是所有被正确分类的样本所占的比例。其计算方法是用对角线元素之和（正确分类的样本数）除以样本总数。\n$$\n\\text{OA} = \\frac{\\sum_{k=1}^{3} n_{kk}}{S_{total}} = \\frac{n_{11} + n_{22} + n_{33}}{S_{total}}\n$$\n从矩阵 $N$ 中代入数值：\n$$\n\\text{OA} = \\frac{460 + 310 + 155}{1100} = \\frac{925}{1100} \\approx 0.840909...\n$$\n四舍五入到四位有效数字，我们得到 $\\text{OA} = 0.8409$。\n\n用户精度 (UA)：\n类别 $C_i$ 的用户精度是指被预测为类别 $C_i$ 的样本中，实际上也属于类别 $C_i$ 的样本所占的比例。它从用户的角度衡量地图的可靠性（即，在地图上标记为 $C_i$ 的样本中，地面上真正是 $C_i$ 的比例是多少？）。其计算方法是用类别 $C_i$ 的正确分类样本数（$n_{ii}$）除以预测为类别 $C_i$ 的总样本数（行和 $R_i = \\sum_{j=1}^{3} n_{ij}$）。\n\n对于类别 $C_1$：\n行和为 $R_1 = 460 + 40 + 20 = 520$。\n$$\n\\text{UA}_{C_{1}} = \\frac{n_{11}}{R_1} = \\frac{460}{520} \\approx 0.884615...\n$$\n四舍五入到四位有效数字，$\\text{UA}_{C_{1}} = 0.8846$。\n\n对于类别 $C_2$：\n行和为 $R_2 = 30 + 310 + 25 = 365$。\n$$\n\\text{UA}_{C_{2}} = \\frac{n_{22}}{R_2} = \\frac{310}{365} \\approx 0.849315...\n$$\n四舍五入到四位有效数字，$\\text{UA}_{C_{2}} = 0.8493$。\n\n对于类别 $C_3$：\n行和为 $R_3 = 10 + 50 + 155 = 215$。\n$$\n\\text{UA}_{C_{3}} = \\frac{n_{33}}{R_3} = \\frac{155}{215} \\approx 0.720930...\n$$\n四舍五入到四位有效数字，$\\text{UA}_{C_{3}} = 0.7209$。\n\n生产者精度 (PA)：\n类别 $C_j$ 的生产者精度是指类别 $C_j$ 的参考样本中，被正确分类为 $C_j$ 的样本所占的比例。它衡量地图制作者在多大程度上正确地表示了真实世界的地物（即，地面上所有真实的 $C_j$ 区域中，有多大比例被正确识别？）。其计算方法是用类别 $C_j$ 的正确分类样本数（$n_{jj}$）除以类别 $C_j$ 的总参考样本数（列和 $K_j = \\sum_{i=1}^{3} n_{ij}$）。\n\n对于类别 $C_1$：\n列和为 $K_1 = 460 + 30 + 10 = 500$。\n$$\n\\text{PA}_{C_{1}} = \\frac{n_{11}}{K_1} = \\frac{460}{500} = 0.92\n$$\n表示为四位有效数字，$\\text{PA}_{C_{1}} = 0.9200$。\n\n对于类别 $C_2$：\n列和为 $K_2 = 40 + 310 + 50 = 400$。\n$$\n\\text{PA}_{C_{2}} = \\frac{n_{22}}{K_2} = \\frac{310}{400} = 0.775\n$$\n表示为四位有效数字，$\\text{PA}_{C_{2}} = 0.7750$。\n\n对于类别 $C_3$：\n列和为 $K_3 = 20 + 25 + 155 = 200$。\n$$\n\\text{PA}_{C_{3}} = \\frac{n_{33}}{K_3} = \\frac{155}{200} = 0.775\n$$\n表示为四位有效数字，$\\text{PA}_{C_{3}} = 0.7750$。\n\n最终结果按要求收集和排序：$(\\text{OA}, \\text{UA}_{C_{1}}, \\text{UA}_{C_{2}}, \\text{UA}_{C_{3}}, \\text{PA}_{C_{1}}, \\text{PA}_{C_{2}}, \\text{PA}_{C_{3}})$。\n这些值为 ($0.8409, 0.8846, 0.8493, 0.7209, 0.9200, 0.7750, 0.7750$)。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n0.8409 & 0.8846 & 0.8493 & 0.7209 & 0.9200 & 0.7750 & 0.7750\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "土地利用变化建模的一个核心任务是在景观尺度上分配未来的土地利用变化。这个问题通常被构建为一个优化问题：在满足各类土地利用面积需求（配额）的同时，将土地利用类型分配给各个空间单元，以最大化总体适宜性。本练习将介绍这种用于LULC分配的优化框架，并通过比较一种快速但可能非最优的贪婪启发式算法与保证最优的整数规划解，让您深入理解在设计真实世界LULC模型时，计算效率与解质量之间的权衡。",
            "id": "3888221",
            "problem": "考虑一个离散的土地利用和土地覆盖 (LULC) 分配问题，该问题构建在一个包含 $10$ 个独立空间单元和 $3$ 个土地类别的有限集合上。每个单元 $i \\in \\{0,1,\\dots,9\\}$ 和每个类别 $c \\in \\{0,1,2\\}$ 都关联一个适宜性得分 $S_{i,c} \\in [0,1]$，当单元 $i$ 被分配给类别 $c$ 时，该得分表示对目标函数的加性贡献。给定一个各类别面积配额向量 $\\mathbf{q} \\in \\mathbb{Z}_{\\ge 0}^3$，使得 $\\sum_{c=0}^{2} q_c = 10$，其中 $q_c$ 是需要分配给类别 $c$ 的单元数量。目标是计算这 $10$ 个单元到 $3$ 个类别的两种分配方案：(a) 贪心启发式分配，以及 (b) 最优整数分配，该最优整数分配在满足配额和分配排他性约束的条件下，最大化总适宜性。\n\n基本模型和决策结构：使用决策变量 $x_{i,c} \\in \\{0,1\\}$ 对分配问题进行建模，该变量指示单元 $i$ 是否被分配给类别 $c$。目标是在满足排他性约束 $\\sum_{c=0}^{2} x_{i,c} = 1$（对于所有 $i \\in \\{0,\\dots,9\\}$）和配额约束 $\\sum_{i=0}^{9} x_{i,c} = q_c$（对于所有 $c \\in \\{0,1,2\\}$）的条件下，最大化加性总适宜性 $\\sum_{i=0}^{9} \\sum_{c=0}^{2} S_{i,c} x_{i,c}$。需要实现的贪心启发式算法是以下规则，且必须确定性地应用：\n\n- 对于每个单元 $i$，令 $c^*(i)$ 为实现最大适宜性 $\\max_{c} S_{i,c}$ 的类别索引，并令 $c^{**}(i)$ 为该单元实现次高适宜性的类别。定义边际差值 $m_i = S_{i,c^*(i)} - S_{i,c^{**}(i)}$。在确定 $c^*(i)$ 或 $c^{**}(i)$ 时若出现平局，则选择最小的类别索引 $c$ 来打破平局。\n- 按 $m_i$ 的降序对单元进行排序。若边际差值相同，则按单元索引 $i$ 的升序来打破平局。\n- 遍历排序后的单元。对于每个单元 $i$，在那些仍有剩余配额（$q_c > 0$）的类别中，将其分配给能最大化 $S_{i,c}$ 的类别 $c$。若出现平局，则选择最小的类别索引 $c$。分配后，将该类别的相应配额减 1。\n- 持续此过程，直到所有 $10$ 个单元都被分配且所有配额都得到满足。\n\n对于最优整数解，你必须精确计算出能最大化总适宜性的分配方案，且不得放宽整数性要求；对于 $10$ 个单元和固定配额，允许对特定于类别的组合进行穷举搜索。\n\n你的程序必须同时实现贪心启发式算法和最优整数分配。对于下面的每个测试用例，计算：\n- 贪心总适宜性 $G$。\n- 最优总适宜性 $O$。\n- 非负差值 $D = O - G$。\n- 布尔相等标志 $B$，指示 $G$ 是否等于 $O$。\n\n测试套件（每个用例指定了 $10 \\times 3$ 的适宜性矩阵 $\\mathbf{S}$ 和配额向量 $\\mathbf{q}$）：\n\n用例 1：\n$$\n\\mathbf{S} =\n\\begin{bmatrix}\n0.82 & 0.10 & 0.08 \\\\\n0.40 & 0.85 & 0.15 \\\\\n0.35 & 0.10 & 0.90 \\\\\n0.60 & 0.55 & 0.20 \\\\\n0.30 & 0.75 & 0.50 \\\\\n0.70 & 0.65 & 0.40 \\\\\n0.10 & 0.20 & 0.95 \\\\\n0.55 & 0.58 & 0.52 \\\\\n0.48 & 0.50 & 0.49 \\\\\n0.33 & 0.32 & 0.31\n\\end{bmatrix},\n\\quad\n\\mathbf{q} = \\begin{bmatrix} 3 \\\\ 3 \\\\ 4 \\end{bmatrix}.\n$$\n\n用例 2：\n$$\n\\mathbf{S} =\n\\begin{bmatrix}\n0.60 & 0.60 & 0.10 \\\\\n0.40 & 0.65 & 0.40 \\\\\n0.55 & 0.55 & 0.20 \\\\\n0.50 & 0.50 & 0.80 \\\\\n0.45 & 0.49 & 0.70 \\\\\n0.68 & 0.40 & 0.68 \\\\\n0.35 & 0.90 & 0.10 \\\\\n0.75 & 0.60 & 0.75 \\\\\n0.52 & 0.52 & 0.52 \\\\\n0.20 & 0.95 & 0.95\n\\end{bmatrix},\n\\quad\n\\mathbf{q} = \\begin{bmatrix} 5 \\\\ 5 \\\\ 0 \\end{bmatrix}.\n$$\n\n用例 3：\n$$\n\\mathbf{S} =\n\\begin{bmatrix}\n0.80 & 0.80 & 0.80 \\\\\n0.81 & 0.80 & 0.79 \\\\\n0.79 & 0.81 & 0.80 \\\\\n0.70 & 0.88 & 0.88 \\\\\n0.88 & 0.70 & 0.88 \\\\\n0.85 & 0.85 & 0.85 \\\\\n0.90 & 0.75 & 0.75 \\\\\n0.75 & 0.90 & 0.75 \\\\\n0.60 & 0.60 & 0.95 \\\\\n0.95 & 0.60 & 0.60\n\\end{bmatrix},\n\\quad\n\\mathbf{q} = \\begin{bmatrix} 2 \\\\ 4 \\\\ 4 \\end{bmatrix}.\n$$\n\n最终输出格式：你的程序应生成单行输出，其中包含一个用方括号括起来的、逗号分隔的结果列表，且无空格。每个测试用例必须以子列表的形式报告，格式为 $[G,O,D,B]$，其中 $G$、$O$ 和 $D$ 是普通表示法的小数，小数点后最多六位，而 $B$ 为 $True$ 或 $False$。因此，最后一行必须是 $[[G_1,O_1,D_1,B_1],[G_2,O_2,D_2,B_2],[G_3,O_3,D_3,B_3]]$ 的形式，其中索引对应于用例编号。",
            "solution": "用户提出了一个来自土地利用和土地覆盖 (LULC) 建模领域的明确定义的优化问题，该领域是环境和地球系统建模的一个子学科。问题是找到并比较空间单元到土地利用类别的两种不同分配方案：一种基于特定的贪心启发式算法，另一种代表全局最优解。\n\n### 第 1 步：提取已知信息\n- **域**：一个包含 $N=10$ 个空间单元的集合，索引为 $i \\in \\{0, 1, \\dots, 9\\}$。\n- **类别**：一个包含 $M=3$ 个土地类别的集合，索引为 $c \\in \\{0, 1, 2\\}$。\n- **适宜性得分**：一个 $10 \\times 3$ 的矩阵 $\\mathbf{S}$，其中 $S_{i,c} \\in [0,1]$ 是将单元 $i$ 分配给类别 $c$ 的适宜性。\n- **配额向量**：一个向量 $\\mathbf{q} \\in \\mathbb{Z}_{\\ge 0}^3$，指定了每个类别 $c$ 所需的单元数量 $q_c$。给定条件 $\\sum_{c=0}^{2} q_c = 10$。\n- **决策变量**：$x_{i,c} \\in \\{0,1\\}$，其中如果单元 $i$ 被分配给类别 $c$，则 $x_{i,c}=1$，否则为 $0$。\n- **目标函数**：最大化总适宜性，$Z = \\sum_{i=0}^{9} \\sum_{c=0}^{2} S_{i,c} x_{i,c}$。\n- **约束条件**：\n    1.  **排他性**：每个单元必须只分配给一个类别：对于每个单元 $i$，$\\sum_{c=0}^{2} x_{i,c} = 1$。\n    2.  **配额满足**：分配给每个类别的单元数量必须与配额匹配：对于每个类别 $c$，$\\sum_{i=0}^{9} x_{i,c} = q_c$。\n- **贪心启发式算法**：\n    1.  对于每个单元 $i$，确定具有最高适宜性的类别 $c^*(i)$ 和次高适宜性的类别 $c^{**}(i)$。平局通过选择最小的类别索引 $c$ 来打破。\n    2.  计算每个单元的边际差值：$m_i = S_{i,c^*(i)} - S_{i,c^{**}(i)}$。\n    3.  按边际差值 $m_i$ 的降序对单元进行排序。平局通过单元索引 $i$ 的升序来打破。\n    4.  遍历排序后的单元。对于每个单元 $i$，在那些仍有剩余配额（$q_c > 0$）的类别中，将其分配给能最大化 $S_{i,c}$ 的类别 $c$。$S_{i,c}$ 的平局通过选择最小的类别索引 $c$ 来打破。分配后，将所分配类别的配额减一。\n- **最优整数解**：满足所有约束并实现目标函数 $Z$ 最大可能值的分配方案 $\\{x_{i,c}\\}$。问题指出允许进行穷举搜索。\n- **每个测试用例的输出**：\n    - $G$：贪心启发式算法的总适宜性。\n    - $O$：最优总适宜性。\n    - $D$：差值 $O - G$。\n    - $B$：一个布尔值，如果 $G = O$ 则为 `True`，否则为 `False`。\n- **测试用例**：提供了适宜性矩阵 $\\mathbf{S}$ 和配额向量 $\\mathbf{q}$ 的三个具体实例。\n\n### 第 2 步：使用提取的已知信息进行验证\n该问题经过了严格的验证程序。\n\n- **科学依据**：该问题是运筹学和计算地理学中一个成熟的公式化问题，称为广义分配问题 (GAP) 或多资源/多项目分配问题。它是建模 LULC 分配的标准方法。所提出的贪心启发式算法是一种常见的“基于后悔值”的启发式算法，其中边际差值代表了不选择最佳选项的机会成本。所有内容在科学上和数学上都是合理的。\n- **适定性**：该问题是适定的。目标函数是线性的，约束定义了一个有限的、非空的、离散的可行集（一个顶点为整数解的多面体）。最大值保证存在。贪心启发式算法是完全确定性的，包括所有打破平局的规则，确保了唯一的结果。\n- **客观性**：问题以精确、形式化的数学术语陈述，没有任何主观或模糊的语言。\n- **一致性和完整性**：问题提供了所有必要的信息：单元和类别的数量、目标函数、所有约束、贪心启发式算法的完整定义（包括打破平局的规则）以及测试用例的数据。条件 $\\sum q_c = 10$ 确保了完整分配是可能的。\n\n### 第 3 步：结论与行动\n该问题是有效的。它是一个标准的、适定的优化任务，基于成熟的科学和数学原理。我现在将着手解决。\n\n### 基于原则的设计\n解决方案需要实现两种不同的算法：一种是贪心启发式算法，另一种是最优求解器。\n\n#### 贪心启发式算法\n逻辑严格遵循指定的规则。\n1.  **边际差值计算**：对于每个单元 $i$，考虑其三个适宜性得分 $S_{i,0}, S_{i,1}, S_{i,2}$。为了系统地处理打破平局的规则（最小类别索引），我们可以为每个单元创建一个元组列表 `(score, class_index)`，并首先按得分降序排序，然后按类别索引升序排序。排序后列表的第一个元素给出 $(S_{i,c^*(i)}, c^*(i))$，第二个元素给出 $(S_{i,c^{**}(i)}, c^{**}(i))$，由此计算出边际差值 $m_i$。\n2.  **单元排序**：创建一个包含所有单元的 $(m_i, i)$ 元组的列表。此列表首先按边际差值 $m_i$ 降序排序，然后按单元索引 $i$ 升序排序，以生成用于分配的确定性单元顺序。\n3.  **迭代分配**：我们按排序后的顺序遍历单元。对于每个单元，我们检查其对所有类别 $c \\in \\{0,1,2\\}$ 的适宜性得分。我们选择在配额尚未用完的类别中得分最高的类别。打破平局的规则（最小类别索引 $c$）可以通过按 $0, 1, 2$ 的顺序遍历类别，并且仅在找到严格更高的适宜性时才更新最佳类别选择来自然处理。一旦一个单元被分配，相应类别的配额就递减。\n4.  **适宜性求和**：在所有 $10$ 个单元都被分配后，通过对最终分配的 $S_{i,c}$ 值求和来计算总适宜性 $G$。\n\n#### 最优整数分配算法\n问题规模（$10$ 个单元，$3$ 个类别）足够小，可以按建议进行穷举搜索。问题在于将 $10$ 个单元的集合划分为三个大小分别为 $q_0, q_1, q_2$ 的子集。这种划分的数量由多项式系数 $\\binom{10}{q_0, q_1, q_2}$ 给出。对于给定的测试用例，这个数字很小（例如，对于 $\\mathbf{q}=[3,3,4]$，它是 $\\frac{10!}{3!3!4!} = 4200$），使得完全搜索在计算上是可行的。\n1.  **生成划分**：我们可以使用嵌套迭代器系统地生成所有有效的划分。Python 标准库中的 `itertools.combinations` 函数非常适合此任务。\n    - 首先，我们从所有单元索引 $\\{0, \\dots, 9\\}$ 的集合中，生成所有分配给类别 $0$ 的 $q_0$ 个单元的组合。\n    - 对于每个这样的选择，我们考虑剩余的单元索引集。从此集合中，我们生成所有分配给类别 $1$ 的 $q_1$ 个单元的组合。\n    - 最后剩下的 $q_2$ 个单元自动分配给类别 $2$。\n2.  **评估和最大化**：对于每个完全定义的分配（划分），我们通过对相应的 $S_{i,c}$ 值求和来计算总适宜性。我们维护一个总适宜性的运行最大值。在检查完所有可能的划分后，这个运行最大值将是最优值 $O$。\n\n#### 数值精度和最终计算\n为了避免潜在的浮点数不精确性，特别是在比较数值时，一个有效的策略是将适宜性得分乘以 $100$ 的因子（因为输入有两位小数）转换为整数。然后，所有对 $G$ 和 $O$ 的计算都可以使用整数算术执行，最终结果可以通过除以 $100$ 转换回浮点数。\n- 计算贪心适宜性 $G$ 和最优适宜性 $O$。\n- 计算差值 $D = O - G$。\n- 执行布尔相等性检查 $B$。使用 `numpy.isclose(G, O)` 对于比较浮点数是稳健的。\n- 每个测试用例的结果 $[G, O, D, B]$ 在打印前按照指定的输出规则进行格式化。",
            "answer": "```python\nimport numpy as np\nfrom itertools import combinations\n\ndef solve():\n    \"\"\"\n    Solves the LULC allocation problem for a suite of test cases.\n    For each case, it computes and compares a greedy heuristic solution\n    and the optimal integer solution.\n    \"\"\"\n    test_cases = [\n        (\n            np.array([\n                [0.82, 0.10, 0.08],\n                [0.40, 0.85, 0.15],\n                [0.35, 0.10, 0.90],\n                [0.60, 0.55, 0.20],\n                [0.30, 0.75, 0.50],\n                [0.70, 0.65, 0.40],\n                [0.10, 0.20, 0.95],\n                [0.55, 0.58, 0.52],\n                [0.48, 0.50, 0.49],\n                [0.33, 0.32, 0.31]\n            ]),\n            np.array([3, 3, 4])\n        ),\n        (\n            np.array([\n                [0.60, 0.60, 0.10],\n                [0.40, 0.65, 0.40],\n                [0.55, 0.55, 0.20],\n                [0.50, 0.50, 0.80],\n                [0.45, 0.49, 0.70],\n                [0.68, 0.40, 0.68],\n                [0.35, 0.90, 0.10],\n                [0.75, 0.60, 0.75],\n                [0.52, 0.52, 0.52],\n                [0.20, 0.95, 0.95]\n            ]),\n            np.array([5, 5, 0])\n        ),\n        (\n            np.array([\n                [0.80, 0.80, 0.80],\n                [0.81, 0.80, 0.79],\n                [0.79, 0.81, 0.80],\n                [0.70, 0.88, 0.88],\n                [0.88, 0.70, 0.88],\n                [0.85, 0.85, 0.85],\n                [0.90, 0.75, 0.75],\n                [0.75, 0.90, 0.75],\n                [0.60, 0.60, 0.95],\n                [0.95, 0.60, 0.60]\n            ]),\n            np.array([2, 4, 4])\n        )\n    ]\n\n    results_str_list = []\n    \n    for S, q in test_cases:\n        G = compute_greedy(S, q.copy())\n        O = compute_optimal(S, q)\n        \n        D = O - G\n        B = np.isclose(G, O)\n\n        # Format numbers as specified: plain decimal, up to 6 digits after decimal.\n        # str(round(val, 6)) correctly handles this formatting.\n        G_str = str(round(G, 6))\n        O_str = str(round(O, 6))\n        D_str = str(round(D, 6))\n        B_str = str(B)\n        \n        results_str_list.append(f\"[{G_str},{O_str},{D_str},{B_str}]\")\n\n    print(f\"[[{','.join(results_str_list)}]]\")\n\n\ndef compute_greedy(S, q):\n    \"\"\"\n    Computes the total suitability using the specified greedy heuristic.\n    \"\"\"\n    num_cells = S.shape[0]\n    num_classes = S.shape[1]\n    \n    # Use integer arithmetic to avoid floating point issues\n    S_int = np.round(S * 100).astype(int)\n\n    # 1.  2. Calculate margins and sort cells\n    margins = []\n    for i in range(num_cells):\n        # Sort by score (desc), then class index (asc) to handle ties for c* and c**\n        sorted_scores = sorted([(S_int[i, c], c) for c in range(num_classes)], key=lambda x: (-x[0], x[1]))\n        \n        s_star = sorted_scores[0][0]\n        s_star_star = sorted_scores[1][0]\n        margin = s_star - s_star_star\n        margins.append((margin, i))\n\n    # Sort cells by margin (desc), then cell index (asc)\n    sorted_cells = sorted(margins, key=lambda x: (-x[0], x[1]))\n\n    # 3. Iterative Allocation\n    allocation = -np.ones(num_cells, dtype=int)\n    remaining_quotas = q.copy()\n    \n    for _, i in sorted_cells:\n        best_c = -1\n        max_s = -1\n        \n        # Find best available class, breaking ties by smallest class index\n        for c in range(num_classes):\n            if remaining_quotas[c] > 0:\n                if S_int[i, c] > max_s:\n                    max_s = S_int[i, c]\n                    best_c = c\n        \n        if best_c != -1:\n            allocation[i] = best_c\n            remaining_quotas[best_c] -= 1\n\n    # 4. Calculate total suitability\n    greedy_suitability_int = 0\n    for i in range(num_cells):\n        assigned_class = allocation[i]\n        greedy_suitability_int += S_int[i, assigned_class]\n\n    return greedy_suitability_int / 100.0\n\n\ndef compute_optimal(S, q):\n    \"\"\"\n    Computes the optimal total suitability using exhaustive search over partitions.\n    \"\"\"\n    S_int = np.round(S * 100).astype(int)\n    cell_indices = list(range(S.shape[0]))\n    \n    max_suitability = -1\n\n    # Generate combinations for class 0\n    c0_indices_iter = combinations(cell_indices, q[0])\n    \n    for c0_indices in c0_indices_iter:\n        s0 = sum(S_int[i, 0] for i in c0_indices)\n        \n        rem_indices = [i for i in cell_indices if i not in c0_indices]\n        \n        # Generate combinations for class 1 from remaining cells\n        c1_indices_iter = combinations(rem_indices, q[1])\n        \n        for c1_indices in c1_indices_iter:\n            s1 = sum(S_int[i, 1] for i in c1_indices)\n            \n            # The rest are assigned to class 2\n            c2_indices = [i for i in rem_indices if i not in c1_indices]\n            s2 = sum(S_int[i, 2] for i in c2_indices)\n\n            current_suitability = s0 + s1 + s2\n            if current_suitability > max_suitability:\n                max_suitability = current_suitability\n\n    return max_suitability / 100.0\n\nsolve()\n```"
        }
    ]
}