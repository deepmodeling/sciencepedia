{
    "hands_on_practices": [
        {
            "introduction": "Many socio-ecological systems can exist in multiple stable states and exhibit 'tipping points,' where a small change in an external driver triggers an abrupt, system-wide shift. This exercise introduces the mathematical tools to analyze such critical transitions through a stylized model of pro-environmental behavior adoption . By performing a complete bifurcation analysis, you will develop the fundamental skill of identifying a system's equilibria and pinpointing the exact thresholds at which it loses resilience and tips into an alternative state.",
            "id": "3896255",
            "problem": "Consider a stylized socio-ecological tipping model for the fraction of households adopting a pro-environmental behavior, denoted by the state variable $x$. The adoption dynamics are represented by the one-dimensional ordinary differential equation (ODE):\n$$\n\\dot{x} = \\mu - x + x^{3},\n$$\nwhere $\\mu$ is a dimensionless exogenous driver representing the net socio-political pressure favoring adoption (for example, incentives minus costs). The cubic nonlinearity captures reinforcing social feedbacks (for example, imitation and norm internalization), while the linear loss term captures spontaneous abandonment or saturation effects.\n\nStarting from foundational dynamical systems concepts—equilibria are points where $\\dot{x} = 0$, local stability in one dimension is determined by the sign of the derivative of the right-hand side with respect to $x$ evaluated at an equilibrium, and a saddle-node bifurcation occurs when a pair of equilibria coalesce with zero slope—perform a bifurcation analysis of the system as $\\mu$ varies:\n\n- Identify all equilibrium points $x^{\\ast}$ as functions of $\\mu$ by solving $\\mu - x + x^{3} = 0$.\n- Determine the local stability of these equilibria using the one-dimensional linearization criterion.\n- Find the critical values of $\\mu$ at which saddle-node bifurcations occur.\n\nExpress the final critical $\\mu$ values exactly (no rounding). The final answer must be reported as the set of critical values in a single row matrix. $\\mu$ is dimensionless.",
            "solution": "The problem requires a bifurcation analysis of the one-dimensional dynamical system given by the ordinary differential equation (ODE):\n$$\n\\dot{x} = \\mu - x + x^{3}\n$$\nThe state variable is $x$ and $\\mu$ is a control parameter. The analysis involves identifying the equilibrium points, determining their stability, and finding the critical values of $\\mu$ at which saddle-node bifurcations occur.\n\nLet the right-hand side of the ODE be denoted by the function $f(x, \\mu)$, such that $\\dot{x} = f(x, \\mu) = \\mu - x + x^{3}$.\n\n**Step 1: Equilibrium Points**\n\nEquilibrium points, denoted by $x^{\\ast}$, are the values of $x$ for which the system is stationary, i.e., $\\dot{x} = 0$. We find these by solving the equation $f(x^{\\ast}, \\mu) = 0$.\n$$\n\\mu - x^{\\ast} + (x^{\\ast})^{3} = 0\n$$\nThis equation can be rearranged to express $\\mu$ as a function of the equilibrium state $x^{\\ast}$:\n$$\n\\mu = x^{\\ast} - (x^{\\ast})^{3}\n$$\nThis cubic relationship shows that for a given value of $\\mu$, there can be either one or three real equilibrium points $x^{\\ast}$.\n\n**Step 2: Stability Analysis**\n\nThe local stability of an equilibrium point $x^{\\ast}$ in a one-dimensional system is determined by the sign of the derivative of $f(x, \\mu)$ with respect to $x$, evaluated at $x^{\\ast}$. Let's compute this derivative:\n$$\nf'(x) = \\frac{d}{dx}f(x, \\mu) = \\frac{d}{dx}(\\mu - x + x^{3}) = -1 + 3x^{2}\n$$\nThe stability criteria are:\n- If $f'(x^{\\ast}) < 0$, the equilibrium is locally stable (an attractor).\n- If $f'(x^{\\ast}) > 0$, the equilibrium is locally unstable (a repellor).\n- If $f'(x^{\\ast}) = 0$, the equilibrium is marginally stable, and a bifurcation may occur.\n\nFrom the expression for $f'(x)$, we can determine the stability based on the value of $x^{\\ast}$:\n- Stability ($f'(x^{\\ast})<0$): $-1 + 3(x^{\\ast})^{2} < 0 \\implies 3(x^{\\ast})^{2} < 1 \\implies (x^{\\ast})^{2} < \\frac{1}{3}$. This corresponds to $-\\frac{1}{\\sqrt{3}} < x^{\\ast} < \\frac{1}{\\sqrt{3}}$.\n- Instability ($f'(x^{\\ast})>0$): $-1 + 3(x^{\\ast})^{2} > 0 \\implies (x^{\\ast})^{2} > \\frac{1}{3}$. This corresponds to $x^{\\ast} > \\frac{1}{\\sqrt{3}}$ or $x^{\\ast} < -\\frac{1}{\\sqrt{3}}$.\n\n**Step 3: Saddle-Node Bifurcations**\n\nA saddle-node (or fold) bifurcation occurs when a pair of equilibria—one stable and one unstable—coalesce and annihilate. This happens at points where the equilibrium is marginally stable, i.e., $f'(x^{\\ast})=0$. To find the critical values of the parameter $\\mu$ at which these bifurcations occur, we must solve the system of two equations simultaneously: the equilibrium condition and the marginal stability condition.\n\nThe system of equations for the critical points $(x_c, \\mu_c)$ is:\n$$\n\\begin{cases}\n\\mu_c - x_c + x_c^3 = 0 & \\quad (\\text{Equilibrium condition: } f(x_c, \\mu_c) = 0) \\\\\n-1 + 3x_c^2 = 0 & \\quad (\\text{Marginal stability condition: } f'(x_c) = 0)\n\\end{cases}\n$$\n\nFrom the second equation, we find the values of $x$ at which the bifurcations occur:\n$$\n3x_c^2 = 1 \\implies x_c^2 = \\frac{1}{3} \\implies x_c = \\pm\\frac{1}{\\sqrt{3}}\n$$\nThese are the two equilibrium points where the bifurcations happen. Now, we substitute these values of $x_c$ back into the first equation (or the rearranged equilibrium condition $\\mu_c = x_c - x_c^3$) to find the corresponding critical values of $\\mu$, denoted $\\mu_c$.\n\nCase 1: $x_c = +\\frac{1}{\\sqrt{3}}$\n$$\n\\mu_{c1} = x_c - x_c^3 = \\frac{1}{\\sqrt{3}} - \\left(\\frac{1}{\\sqrt{3}}\\right)^3 = \\frac{1}{\\sqrt{3}} - \\frac{1}{3\\sqrt{3}} = \\frac{3 - 1}{3\\sqrt{3}} = \\frac{2}{3\\sqrt{3}}\n$$\n\nCase 2: $x_c = -\\frac{1}{\\sqrt{3}}$\n$$\n\\mu_{c2} = x_c - x_c^3 = -\\frac{1}{\\sqrt{3}} - \\left(-\\frac{1}{\\sqrt{3}}\\right)^3 = -\\frac{1}{\\sqrt{3}} - \\left(-\\frac{1}{3\\sqrt{3}}\\right) = -\\frac{1}{\\sqrt{3}} + \\frac{1}{3\\sqrt{3}} = \\frac{-3 + 1}{3\\sqrt{3}} = -\\frac{2}{3\\sqrt{3}}\n$$\n\nThe critical values of $\\mu$ at which saddle-node bifurcations occur are $\\mu_c = \\pm\\frac{2}{3\\sqrt{3}}$. These values can be written with a rationalized denominator as $\\mu_c = \\pm\\frac{2\\sqrt{3}}{9}$. For values of $\\mu$ between $-\\frac{2\\sqrt{3}}{9}$ and $\\frac{2\\sqrt{3}}{9}$, the system has three equilibria (two stable, one unstable). For $|\\mu| > \\frac{2\\sqrt{3}}{9}$, it has only one stable equilibrium. At the critical values $\\mu_c$, two of the equilibria merge.\n\nThe two critical values of $\\mu$ are $-\\frac{2\\sqrt{3}}{9}$ and $\\frac{2\\sqrt{3}}{9}$.",
            "answer": "$$\n\\boxed{\\begin{pmatrix} -\\frac{2\\sqrt{3}}{9} & \\frac{2\\sqrt{3}}{9} \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "The management of common-pool resources is a central challenge in socio-ecological systems, often leading to a conflict between individual interests and collective well-being. This exercise  delves into this 'tragedy of the commons' by coupling a logistic growth model of a renewable resource with the economic decisions of multiple harvesting agents. You will use game theory to derive the symmetric Nash equilibrium effort and compare it to the social optimum, providing a clear, quantitative understanding of how decentralized competition can drive resource over-exploitation.",
            "id": "3896254",
            "problem": "Consider a renewable resource harvested by $N$ identical agents in a socio-ecological system, with ecological biomass state $B(t)$ evolving according to logistic growth with harvest:\n$$\n\\frac{dB}{dt} \\;=\\; r\\,B\\left(1 - \\frac{B}{K}\\right) \\;-\\; q\\,E\\,B,\n$$\nwhere $r>0$ is the intrinsic growth rate, $K>0$ is the carrying capacity, $q>0$ is the catchability coefficient, and $E \\equiv \\sum_{i=1}^{N} E_i$ is the aggregate harvest effort. Each agent $i$ chooses effort $E_i \\ge 0$ and receives instantaneous utility\n$$\nu_i(E_i, B) \\;=\\; p\\,q\\,E_i\\,B \\;-\\; c\\,E_i \\;-\\; \\phi\\,q\\,E_i\\,B,\n$$\nwhere $p>0$ is the exogenous unit price of harvest, $c>0$ is the marginal cost of effort, and $\\phi \\ge 0$ parameterizes an internalized ecological penalty per unit harvest. Assume that the system is managed in a stationary regime where agents anticipate the long-run sustainable biomass implied by the above dynamics, and that parameters satisfy $(p - \\phi)\\,q\\,K > c$ so that interior positive efforts exist.\n\nModel the interaction as a contemporaneous symmetric Nash game with $N$ identical agents choosing $\\{E_i\\}$ simultaneously, taking others’ efforts as given and recognizing that the sustainable biomass depends on the aggregate effort through the ecological dynamics. Then, derive:\n\n1. The symmetric Nash equilibrium effort $E_i^{\\ast}$ for each agent, where all agents choose the same effort.\n2. The social planner’s optimal total effort $E^{\\mathrm{SP}}$ that maximizes the aggregate instantaneous net benefit $\\sum_{i=1}^{N} u_i(E_i, B)$ subject to the same ecological dynamics at the sustainable biomass.\n\nFinally, express the comparison between decentralized and centralized outcomes as the ratio of the decentralized aggregate effort to the centralized aggregate effort at the sustainable biomass:\n$$\nR \\;\\equiv\\; \\frac{E_{\\mathrm{tot}}^{\\mathrm{Nash}}}{E_{\\mathrm{tot}}^{\\mathrm{SP}}},\n$$\nwhere $E_{\\mathrm{tot}}^{\\mathrm{Nash}} \\equiv \\sum_{i=1}^{N} E_i^{\\ast}$ and $E_{\\mathrm{tot}}^{\\mathrm{SP}} \\equiv E^{\\mathrm{SP}}$. Provide $R$ as a closed-form analytic expression in terms of $N$ only. No numerical approximation is required. The final answer should be dimensionless, and you should not include units.",
            "solution": "The problem statement is a well-defined exercise in bio-economic modeling, specifically applying game theory to a common-pool resource problem governed by logistic growth dynamics. All components are scientifically grounded, mathematically consistent, and well-posed. The problem is therefore valid.\n\nThe solution proceeds in four steps:\n1.  Determine the sustainable biomass level as a function of aggregate effort.\n2.  Derive the symmetric Nash equilibrium effort for the decentralized scenario.\n3.  Derive the optimal effort for the centralized social planner scenario.\n4.  Compute the ratio of the aggregate efforts from the two scenarios.\n\nStep 1: Sustainable Biomass\nThe ecological dynamics are given by the logistic growth model with harvesting:\n$$ \\frac{dB}{dt} = rB\\left(1 - \\frac{B}{K}\\right) - qEB $$\nwhere $E$ is the aggregate harvest effort, $E = \\sum_{i=1}^{N} E_i$. The system is assumed to be in a stationary regime, which implies that the biomass level is constant, i.e., $\\frac{dB}{dt} = 0$.\n$$ rB\\left(1 - \\frac{B}{K}\\right) - qEB = 0 $$\nThis equation has two possible steady-state solutions for $B$. One is the trivial solution $B=0$, which corresponds to the extinction of the resource. The other is the non-trivial, positive biomass level which we seek. We can find it by dividing by $B$ (assuming $B>0$):\n$$ r\\left(1 - \\frac{B}{K}\\right) - qE = 0 $$\nSolving for $B$ as a function of the aggregate effort $E$:\n$$ 1 - \\frac{B}{K} = \\frac{qE}{r} $$\n$$ \\frac{B}{K} = 1 - \\frac{qE}{r} $$\n$$ B(E) = K\\left(1 - \\frac{qE}{r}\\right) $$\nThis expression represents the sustainable biomass level for a given aggregate effort $E$. For a positive biomass, it is required that $E < \\frac{r}{q}$.\n\nStep 2: Symmetric Nash Equilibrium (Decentralized Outcome)\nIn the decentralized scenario, each of the $N$ identical agents chooses their effort $E_i$ to maximize their own individual utility, taking the efforts of the other agents, $E_{-i} = \\sum_{j \\neq i} E_j$, as given. The utility for agent $i$ is:\n$$ u_i(E_i, B) = p\\,q\\,E_i\\,B - c\\,E_i - \\phi\\,q\\,E_i\\,B = ((p - \\phi)qB - c)E_i $$\nEach agent recognizes that the sustainable biomass $B$ depends on the aggregate effort $E = E_i + E_{-i}$. Substituting the expression for $B(E)$ into the utility function, we get the utility for agent $i$ as a function of efforts only:\n$$ u_i(E_i, E_{-i}) = \\left((p - \\phi)qK\\left(1 - \\frac{q(E_i + E_{-i})}{r}\\right) - c\\right)E_i $$\nTo find the optimal effort $E_i$, we differentiate $u_i$ with respect to $E_i$ and set the derivative to zero.\n$$ \\frac{\\partial u_i}{\\partial E_i} = (p - \\phi)qK\\left(1 - \\frac{q(E_i + E_{-i})}{r}\\right) - c + E_i\\left((p - \\phi)qK\\left(-\\frac{q}{r}\\right)\\right) = 0 $$\n$$ (p - \\phi)qK\\left(1 - \\frac{q(E_i + E_{-i})}{r} - \\frac{qE_i}{r}\\right) - c = 0 $$\n$$ (p - \\phi)qK\\left(1 - \\frac{q(2E_i + E_{-i})}{r}\\right) = c $$\nThis equation gives the reaction function of agent $i$. We are looking for a symmetric Nash equilibrium where all agents choose the same effort level, $E_i = E^*$ for all $i=1, \\dots, N$. In this case, $E_{-i} = (N-1)E^*$. Substituting this into the first-order condition:\n$$ (p - \\phi)qK\\left(1 - \\frac{q(2E^* + (N-1)E^*)}{r}\\right) = c $$\n$$ (p - \\phi)qK\\left(1 - \\frac{q(N+1)E^*}{r}\\right) = c $$\nNow, we solve for the symmetric equilibrium effort $E^*$:\n$$ 1 - \\frac{q(N+1)E^*}{r} = \\frac{c}{(p - \\phi)qK} $$\n$$ \\frac{q(N+1)E^*}{r} = 1 - \\frac{c}{(p - \\phi)qK} $$\n$$ E^* = \\frac{r}{q(N+1)}\\left(1 - \\frac{c}{(p - \\phi)qK}\\right) $$\nThe total effort in the decentralized Nash equilibrium is the sum of individual efforts:\n$$ E_{\\mathrm{tot}}^{\\mathrm{Nash}} = \\sum_{i=1}^{N} E^* = N E^* = \\frac{Nr}{q(N+1)}\\left(1 - \\frac{c}{(p - \\phi)qK}\\right) $$\n\nStep 3: Social Planner's Optimum (Centralized Outcome)\nThe social planner aims to maximize the aggregate net benefit of all agents, which is the sum of their utilities. Let $U_{SP}$ be the total social welfare.\n$$ U_{SP} = \\sum_{i=1}^{N} u_i = \\sum_{i=1}^{N} \\left(((p - \\phi)qB - c)E_i\\right) = ((p - \\phi)qB - c) \\sum_{i=1}^{N} E_i $$\nLet $E^{\\mathrm{SP}}$ be the total effort chosen by the social planner. Then $U_{SP}$ becomes:\n$$ U_{SP}(E^{\\mathrm{SP}}) = ((p - \\phi)qB - c)E^{\\mathrm{SP}} $$\nThe planner is also constrained by the ecological dynamics, so we substitute $B(E^{\\mathrm{SP}}) = K\\left(1 - \\frac{qE^{\\mathrm{SP}}}{r}\\right)$:\n$$ U_{SP}(E^{\\mathrm{SP}}) = \\left((p - \\phi)qK\\left(1 - \\frac{qE^{\\mathrm{SP}}}{r}\\right) - c\\right)E^{\\mathrm{SP}} $$\nTo find the optimal total effort $E^{\\mathrm{SP}}$, we differentiate $U_{SP}$ with respect to $E^{\\mathrm{SP}}$ and set the derivative to zero.\n$$ \\frac{d U_{SP}}{d E^{\\mathrm{SP}}} = (p - \\phi)qK\\left(1 - \\frac{qE^{\\mathrm{SP}}}{r}\\right) - c + E^{\\mathrm{SP}}\\left((p - \\phi)qK\\left(-\\frac{q}{r}\\right)\\right) = 0 $$\n$$ (p - \\phi)qK\\left(1 - \\frac{2qE^{\\mathrm{SP}}}{r}\\right) - c = 0 $$\nSolving for the socially optimal total effort, which we denote $E_{\\mathrm{tot}}^{\\mathrm{SP}} = E^{\\mathrm{SP}}$:\n$$ 1 - \\frac{2qE_{\\mathrm{tot}}^{\\mathrm{SP}}}{r} = \\frac{c}{(p - \\phi)qK} $$\n$$ \\frac{2qE_{\\mathrm{tot}}^{\\mathrm{SP}}}{r} = 1 - \\frac{c}{(p - \\phi)qK} $$\n$$ E_{\\mathrm{tot}}^{\\mathrm{SP}} = \\frac{r}{2q}\\left(1 - \\frac{c}{(p - \\phi)qK}\\right) $$\n\nStep 4: Ratio of Decentralized to Centralized Effort\nFinally, we compute the ratio $R$ of the total decentralized effort to the total centralized effort.\n$$ R = \\frac{E_{\\mathrm{tot}}^{\\mathrm{Nash}}}{E_{\\mathrm{tot}}^{\\mathrm{SP}}} = \\frac{\\frac{Nr}{q(N+1)}\\left(1 - \\frac{c}{(p - \\phi)qK}\\right)}{\\frac{r}{2q}\\left(1 - \\frac{c}{(p - \\phi)qK}\\right)} $$\nThe condition $(p - \\phi)qK > c$ ensures that the term $\\left(1 - \\frac{c}{(p - \\phi)qK}\\right)$ is positive and thus non-zero, allowing it to be cancelled from the numerator and denominator.\n$$ R = \\frac{\\frac{Nr}{q(N+1)}}{\\frac{r}{2q}} = \\frac{Nr}{q(N+1)} \\cdot \\frac{2q}{r} $$\n$$ R = \\frac{2N}{N+1} $$\nThis expression gives the ratio as a function of the number of agents $N$ only, as required. This result quantifies the \"tragedy of the commons\" in this model: as $N$ increases, the ratio of decentralized to centralized effort approaches $2$, indicating significant over-exploitation of the resource.",
            "answer": "$$\\boxed{\\frac{2N}{N+1}}$$"
        },
        {
            "introduction": "The structure of social and ecological interactions profoundly shapes system-wide outcomes, a fact that aggregated models often miss. This hands-on programming practice  challenges you to simulate how a behavior spreads through a network using a threshold model of social contagion. By implementing the simulation and comparing cascades on networks with different levels of clustering, you will gain direct insight into how network topology can either facilitate or inhibit large-scale transformations.",
            "id": "3896268",
            "problem": "Consider a progressive threshold contagion on a socio-ecological interaction network represented by an undirected, simple, binary adjacency matrix $A \\in \\{0,1\\}^{N \\times N}$, where $N$ is the number of nodes. Let $S \\subset \\{0,1,\\dots,N-1\\}$ be an initial seed set of active nodes, and let the threshold vector be $\\boldsymbol{\\theta} \\in [0,1]^N$. Define the degree of node $i$ as $d_i = \\sum_{j=0}^{N-1} A_{ij}$. Let the binary state vector at discrete time $t$ be $\\mathbf{x}(t) \\in \\{0,1\\}^N$, where $x_i(t)=1$ if node $i$ is active at time $t$ and $x_i(t)=0$ otherwise. The initial condition is given by $x_i(0)=1$ for $i \\in S$ and $x_i(0)=0$ for $i \\notin S$.\n\nThe synchronous updating rule is progressive and defined as follows for all nodes $i \\in \\{0,1,\\dots,N-1\\}$:\n$$\nx_i(t+1) =\n\\begin{cases}\n1, & \\text{if } x_i(t)=1, \\\\\n1, & \\text{if } d_i>0 \\text{ and } \\dfrac{1}{d_i}\\sum_{j=0}^{N-1} A_{ij} x_j(t) \\ge \\theta_i, \\\\\n0, & \\text{otherwise.}\n\\end{cases}\n$$\nFor nodes with zero degree ($d_i=0$), adopt the convention that $\\dfrac{1}{d_i}\\sum_{j} A_{ij} x_j(t)$ is treated as $0$ in the above rule.\n\nThe cascade size $C$ is defined as the number of active nodes at convergence:\n$$\nC = \\sum_{i=0}^{N-1} x_i(\\infty),\n$$\nwhere $\\mathbf{x}(t)$ converges to a fixed point $\\mathbf{x}(\\infty)$ under the synchronous, progressive rule.\n\nYou are to compute $C$ for each test case. Additionally, clustering sensitivity should be examined by comparing cascade sizes across networks with similar degree but differing levels of clustering. Clustering is quantified via the local clustering coefficient of node $i$,\n$$\nC_i = \\frac{2 T_i}{d_i(d_i-1)},\n$$\nwhere $T_i$ is the number of triangles incident to node $i$, and $C_i=0$ when $d_i<2$. The global clustering coefficient is the average $\\bar{C} = \\dfrac{1}{N}\\sum_{i=0}^{N-1} C_i$. In the solution, discuss how variations in $\\bar{C}$ influence cascade sizes under the synchronous threshold dynamics.\n\nThe test suite comprises the following cases. For each case, the threshold vector is constant, $\\theta_i=\\theta$ for all $i$.\n\n- Case $1$: A Watts–Strogatz (WS) small-world ring lattice with $N=20$, mean degree $k=4$, rewiring probability $p=0$, threshold $\\theta=0.25$, seed set $S=\\{0\\}$. Construct the initial ring by connecting each node $i$ to its $k/2=2$ nearest neighbors on each side using modular arithmetic on node indices.\n\n- Case $2$: The same WS ring lattice parameters with $N=20$, $k=4$, $p=0$, threshold $\\theta=0.5$, seed set $S=\\{0,1\\}$.\n\n- Case $3$: A WS network with $N=20$, $k=4$, $p=0.8$, threshold $\\theta=0.5$, seed set $S=\\{0,1\\}$. Use a fixed random number generator seed of $42$ for rewiring. Rewire each directed ring edge $(i, i+r)$ for $r \\in \\{1,2\\}$ independently with probability $p$ to a new endpoint $w$ chosen uniformly at random from $\\{0,1,\\dots,N-1\\} \\setminus \\left(\\{i\\} \\cup \\mathcal{N}(i)\\right)$, where $\\mathcal{N}(i)$ is the current neighbor set of $i$, avoiding self-loops and duplicate edges.\n\n- Case $4$: A custom network with $N=5$ comprised of a path on nodes $\\{0,1,2,3\\}$ and an isolated node $\\{4\\}$. The nonzero adjacency entries are $A_{01}=A_{10}=A_{12}=A_{21}=A_{23}=A_{32}=1$, all others $0$. Threshold $\\theta=0.25$, seed set $S=\\{0\\}$.\n\n- Case $5$: The WS ring lattice with $N=20$, $k=4$, $p=0$, threshold $\\theta=1.0$, seed set $S=\\{0,1\\}$.\n\nYour task is to write a complete, runnable program that:\n- Constructs the specified adjacency matrices.\n- Simulates the synchronous threshold dynamics until convergence.\n- Computes the cascade size $C$ for each case.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3,result4,result5]\"), where each result is the integer cascade size $C$ for the corresponding case in the order listed above. No physical units are involved in this problem. Angles are not involved. Percentages should be represented as decimal fractions as already specified for $\\theta$.",
            "solution": "We begin from the representation of a socio-ecological interaction network as an undirected, simple graph encoded by the binary adjacency matrix $A \\in \\{0,1\\}^{N \\times N}$, where $A_{ij}=1$ if there is an interaction edge between nodes $i$ and $j$, and $A_{ij}=0$ otherwise. The degree of node $i$ is $d_i = \\sum_{j=0}^{N-1} A_{ij}$, which is the count of its interacting partners.\n\nThe threshold contagion rule is a well-tested model for adoption dynamics in social and socio-ecological systems. Let the threshold vector be $\\boldsymbol{\\theta} \\in [0,1]^N$ and the initial seed set be $S \\subset \\{0,1,\\dots,N-1\\}$. The synchronous, progressive update rule is:\n$$\nx_i(t+1) =\n\\begin{cases}\n1, & \\text{if } x_i(t)=1, \\\\\n1, & \\text{if } d_i>0 \\text{ and } \\dfrac{1}{d_i}\\sum_{j=0}^{N-1} A_{ij} x_j(t) \\ge \\theta_i, \\\\\n0, & \\text{otherwise,}\n\\end{cases}\n$$\nwith the convention that for nodes with zero degree ($d_i=0$), the fraction $\\dfrac{1}{d_i}\\sum_{j} A_{ij} x_j(t)$ is treated as $0$. This convention reflects that isolated nodes cannot receive social or ecological reinforcement from neighbors and thus remain inactive unless initially seeded.\n\nThis rule is progressive, meaning once a node is active ($x_i(t)=1$), it remains active at all subsequent times. From a fundamental base, the key properties are:\n- Monotonicity: Since the update only flips $x_i$ from $0$ to $1$ and never from $1$ to $0$, the sequence $\\{\\mathbf{x}(t)\\}_{t=0}^{\\infty}$ is non-decreasing in the component-wise order.\n- Finite convergence: Because the state space is finite ($\\{0,1\\}^N$), and the sequence is monotone, it must converge in at most $N$ steps to a fixed point $\\mathbf{x}(\\infty)$ where no further changes occur under the update rule.\n\nTherefore, an algorithmic design follows directly:\n- Initialize $\\mathbf{x}(0)$ with $x_i(0)=1$ if $i \\in S$ and $x_i(0)=0$ otherwise.\n- Repeat synchronously:\n  - For each node $i$ with $x_i(t)=0$, compute the fraction $f_i(t) = \\dfrac{1}{d_i}\\sum_{j=0}^{N-1} A_{ij} x_j(t)$ if $d_i>0$, and $f_i(t)=0$ otherwise.\n  - Set $x_i(t+1)=1$ if $f_i(t) \\ge \\theta_i$, else retain $x_i(t+1)=x_i(t)$.\n- Stop when $\\mathbf{x}(t+1)=\\mathbf{x}(t)$, and compute the cascade size $C = \\sum_{i=0}^{N-1} x_i(\\infty)$.\n\nFor constructing the networks, we employ the Watts–Strogatz (WS) small-world model to control clustering while holding the degree approximately constant:\n- Start from a regular ring lattice: for each node $i$, connect to its $k/2$ nearest neighbors on each side, i.e., add edges $(i, (i+r) \\bmod N)$ and $(i, (i-r) \\bmod N)$ for $r \\in \\{1,2,\\dots,k/2\\}$.\n- For each directed ring edge $(i, i+r)$ with $r \\in \\{1,2,\\dots,k/2\\}$, independently with probability $p$, rewire its endpoint $i+r$ to a uniformly random node $w \\in \\{0,1,\\dots,N-1\\} \\setminus \\left(\\{i\\} \\cup \\mathcal{N}(i)\\right)$, where $\\mathcal{N}(i)$ is the current neighbor set of $i$. This avoids self-loops and multiple edges. The resulting undirected graph has mean degree approximately $k$ and reduced clustering for larger $p$.\n\nClustering sensitivity is understood through the local clustering coefficient,\n$$\nC_i = \\frac{2 T_i}{d_i(d_i-1)},\n$$\nwhere $T_i$ counts triangles incident to $i$. The global clustering coefficient is $\\bar{C} = \\dfrac{1}{N}\\sum_{i=0}^{N-1} C_i$. In threshold contagion, higher $\\bar{C}$ increases the probability that neighbors of a seed share common contacts, thereby increasing simultaneous reinforcement. For thresholds such as $\\theta=0.5$ on degree $d_i=4$, activation requires at least $2$ active neighbors. In a lattice with many triangles, two adjacent seeds often share neighbors, enabling their neighbors to meet the $2$-neighbor requirement and propagate activation. In contrast, after rewiring with large $p$ (lower clustering), two seeds share fewer neighbors, so nodes adjacent to only one seed will not meet the threshold, stalling the cascade.\n\nWe now reason about the test cases:\n- Case $1$ with $N=20$, $k=4$, $p=0$, and $\\theta=0.25$ (one neighbor suffices for $d_i=4$) will propagate along the ring because each boundary node adjacent to an active node has at least one active neighbor, leading to full activation under synchronous progression.\n- Case $2$ with $N=20$, $k=4$, $p=0$, and $\\theta=0.5$ (two neighbors needed) starts from two adjacent seeds. In the ring lattice, many nodes are in triangles with these seeds and hence receive reinforcement from two active neighbors, allowing the activation wave to propagate and reach the entire network under progressive dynamics.\n- Case $3$ with $N=20$, $k=4$, $p=0.8$, and $\\theta=0.5$ uses the same degree but lower clustering due to rewiring (random seed fixed at $42$ for reproducibility). Here, the scarcity of triangles reduces shared neighbors of seeds, often preventing nodes from reaching the two-neighbor threshold, which limits the cascade size compared to Case $2$.\n- Case $4$ with $N=5$ and a path $\\{0,1,2,3\\}$ plus isolated node $\\{4\\}$ at $\\theta=0.25$ will activate the path progressively from the seed at node $0$ (each step requires one active neighbor), but the isolated node with $d_4=0$ remains inactive unless initially seeded, yielding a cascade that excludes node $4$.\n- Case $5$ with $N=20$, $k=4$, $p=0$, and $\\theta=1.0$ requires all neighbors to be active for adoption. Starting from $S=\\{0,1\\}$, no other node initially satisfies this requirement, and progression stalls, yielding only the seeded nodes active at convergence.\n\nAlgorithmically, the synchronous update can be implemented efficiently:\n- Compute degrees $\\mathbf{d} = A \\mathbf{1}$ once.\n- At each iteration, compute neighbor activation counts as $A \\mathbf{x}(t)$, divide element-wise by $\\mathbf{d}$ where $d_i>0$, compare with $\\boldsymbol{\\theta}$, and update inactive nodes accordingly.\n- Terminate when the active set stabilizes. The complexity per iteration is $O(|E|)$ for sparse computation or $O(N^2)$ for dense matrices; the number of iterations is at most $N$ due to monotone progression.\n\nThe program will construct the specified adjacency matrices (including WS networks with given parameters), simulate the synchronous threshold dynamics until convergence for each case, and output the cascade sizes in the required single-line format. The comparison between Case $2$ and Case $3$ illustrates sensitivity to clustering: higher $\\bar{C}$ in Case $2$ facilitates meeting thresholds via shared neighbors and triangles, yielding larger cascades, while lower $\\bar{C}$ in Case $3$ suppresses such reinforcement, reducing cascade size.",
            "answer": "```python\nimport numpy as np\n\ndef watts_strogatz_adjacency(n: int, k: int, p: float, seed: int | None = None) -> np.ndarray:\n    \"\"\"\n    Construct an undirected Watts-Strogatz small-world graph adjacency matrix.\n    - n: number of nodes (must be >= 3)\n    - k: mean degree (must be even and < n)\n    - p: rewiring probability in [0,1]\n    - seed: RNG seed for reproducibility\n    Returns adjacency matrix A (n x n) with 0/1 entries, no self-loops, no multi-edges.\n    \"\"\"\n    assert n >= 3, \"n must be at least 3\"\n    assert k % 2 == 0 and 0 < k < n, \"k must be even and 0 < k < n\"\n    rng = np.random.default_rng(seed)\n\n    # Start with ring lattice: connect i to i±r for r = 1..k/2\n    A = np.zeros((n, n), dtype=np.int64)\n    half_k = k // 2\n    # Add undirected edges (i, (i+r) % n) and (i, (i-r) % n)\n    for i in range(n):\n        for r in range(1, half_k + 1):\n            j = (i + r) % n\n            A[i, j] = 1\n            A[j, i] = 1\n\n    # Rewire each directed \"clockwise\" edge (i, i+r) for r=1..k/2 independently\n    # Process edges only in one direction to avoid double rewiring\n    for i in range(n):\n        for r in range(1, half_k + 1):\n            j = (i + r) % n\n            if rng.random() < p:\n                # Attempt to rewire (i, j) to (i, w)\n                # Remove edge (i, j)\n                A[i, j] = 0\n                A[j, i] = 0\n                # Choose new w uniformly from nodes excluding i and current neighbors of i\n                neighbors_i = set(np.where(A[i] == 1)[0])\n                forbidden = neighbors_i.union({i})\n                candidates = [w for w in range(n) if w not in forbidden]\n                if len(candidates) == 0:\n                    # No possible rewiring; restore original edge\n                    A[i, j] = 1\n                    A[j, i] = 1\n                else:\n                    w = rng.choice(candidates)\n                    A[i, w] = 1\n                    A[w, i] = 1\n    return A\n\ndef cascade_size(A: np.ndarray, theta: np.ndarray, seeds: list[int]) -> int:\n    \"\"\"\n    Compute cascade size under synchronous progressive threshold dynamics.\n    - A: adjacency matrix (n x n), assumed undirected, simple\n    - theta: threshold vector (length n)\n    - seeds: list of initially active node indices\n    Returns integer cascade size (number of active nodes at convergence).\n    \"\"\"\n    n = A.shape[0]\n    # Binary state vector\n    x = np.zeros(n, dtype=bool)\n    x[seeds] = True\n    degrees = A.sum(axis=1).astype(np.int64)\n\n    # Iteratively update until convergence\n    max_iters = n  # progressive dynamics converge in at most n steps\n    for _ in range(max_iters):\n        prev_x = x.copy()\n        # Compute fraction of active neighbors; handle degree zero separately\n        active_counts = A @ x.astype(np.int64)  # number of active neighbors\n        frac = np.zeros(n, dtype=float)\n        # For nodes with degree > 0\n        mask_deg_pos = degrees > 0\n        frac[mask_deg_pos] = active_counts[mask_deg_pos] / degrees[mask_deg_pos]\n        # Progressive: already active remain active\n        new_x = prev_x.copy()\n        # Nodes that are inactive but meet threshold become active\n        adopt_mask = (~prev_x) & (frac >= theta)\n        new_x[adopt_mask] = True\n        x = new_x\n        if np.array_equal(x, prev_x):\n            break\n    return int(x.sum())\n\ndef solve():\n    # Define test cases as tuples specifying how to build A, theta, seeds\n    # Case 1: WS ring lattice N=20, k=4, p=0.0, theta=0.25, seeds={0}\n    case1 = (\"ws\", {\"n\": 20, \"k\": 4, \"p\": 0.0, \"seed\": None}, {\"theta\": 0.25, \"seeds\": [0]})\n    # Case 2: WS ring lattice N=20, k=4, p=0.0, theta=0.5, seeds={0,1}\n    case2 = (\"ws\", {\"n\": 20, \"k\": 4, \"p\": 0.0, \"seed\": None}, {\"theta\": 0.5, \"seeds\": [0, 1]})\n    # Case 3: WS N=20, k=4, p=0.8, theta=0.5, seeds={0,1}, RNG seed=42\n    case3 = (\"ws\", {\"n\": 20, \"k\": 4, \"p\": 0.8, \"seed\": 42}, {\"theta\": 0.5, \"seeds\": [0, 1]})\n    # Case 4: Custom path on nodes {0,1,2,3} and isolated node {4}, theta=0.25, seeds={0}\n    case4 = (\"custom\", {\"n\": 5, \"edges\": [(0, 1), (1, 2), (2, 3)]}, {\"theta\": 0.25, \"seeds\": [0]})\n    # Case 5: WS ring lattice N=20, k=4, p=0.0, theta=1.0, seeds={0,1}\n    case5 = (\"ws\", {\"n\": 20, \"k\": 4, \"p\": 0.0, \"seed\": None}, {\"theta\": 1.0, \"seeds\": [0, 1]})\n\n    test_cases = [case1, case2, case3, case4, case5]\n\n    results = []\n    for kind, params, dyn in test_cases:\n        theta_val = dyn[\"theta\"]\n        seeds = dyn[\"seeds\"]\n        if kind == \"ws\":\n            A = watts_strogatz_adjacency(n=params[\"n\"], k=params[\"k\"], p=params[\"p\"], seed=params[\"seed\"])\n            theta = np.full(params[\"n\"], theta_val, dtype=float)\n        elif kind == \"custom\":\n            n = params[\"n\"]\n            A = np.zeros((n, n), dtype=np.int64)\n            for (u, v) in params[\"edges\"]:\n                A[u, v] = 1\n                A[v, u] = 1\n            theta = np.full(n, theta_val, dtype=float)\n        else:\n            raise ValueError(\"Unknown test case kind.\")\n        csize = cascade_size(A, theta, seeds)\n        results.append(csize)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}