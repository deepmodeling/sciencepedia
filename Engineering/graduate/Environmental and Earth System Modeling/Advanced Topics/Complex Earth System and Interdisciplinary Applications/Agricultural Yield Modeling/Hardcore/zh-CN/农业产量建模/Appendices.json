{
    "hands_on_practices": [
        {
            "introduction": "预测作物的生命周期时间，即物候，是任何农业模型的支柱。本练习将指导您从头开始构建一个冬小麦的物候模型，该模型综合了温度、日长和春化期等关键环境因素的影响，以确定开花时间。通过实现这些核心关系，您将对作物发育的模拟方式获得基础性的理解。",
            "id": "3860938",
            "problem": "实现一个程序，在温度、光周期和春化温度的逐日强迫下，计算一个冬小麦栽培品种从播种到开花的持续时间。该栽培品种的特性由基点温度、光周期敏感性、春化需求和一个内在发育时间尺度决定。计算必须遵循以下基于物理和生物学原理的原则和定义，并且所有输出必须以整数天数（单位：天）返回。\n\n使用以下基本依据：\n\n1. 逐日发育速率定义：向开花发展的瞬时速率与乘性环境响应标量和一个内在时间尺度成正比。设 $r(d)$ 为第 $d$ 天的速率。则\n$$\nr(d) = k \\cdot f_T(T(d)) \\cdot f_P(P(d)) \\cdot f_V(V(d)),\n$$\n其中 $k$ 是内在速率常数，单位为 $\\text{day}^{-1}$，$f_T$ 是在 $[0,1]$ 区间内的温度响应标量，$f_P$ 是在 $[0,1]$ 区间内的光周期响应标量，$f_V$ 是在 $[0,1]$ 区间内的春化完成度标量。\n\n2. 事件标准：开花发生在累积发育总和达到栽培品种特定阈值 $D_{\\text{req}}$ 的最早一天 $D$：\n$$\n\\sum_{i=1}^{D} r(i) \\ge D_{\\text{req}}.\n$$\n如果在给定的逐日序列中不存在这样的 $D$，则该情况的输出必须为 $-1$。\n\n3. 使用基点温度的温度响应：设基点温度为最低温度 $T_b$、最适温度 $T_o$ 和最高温度 $T_c$，单位为 $^{\\circ}\\mathrm{C}$。通过分段线性函数定义 $f_T(T)$：\n- 如果 $T \\le T_b$，$f_T(T) = 0$。\n- 如果 $T_b  T \\le T_o$，$f_T(T) = \\dfrac{T - T_b}{T_o - T_b}$。\n- 如果 $T_o  T  T_c$，$f_T(T) = \\dfrac{T_c - T}{T_c - T_o}$。\n- 如果 $T \\ge T_c$，$f_T(T) = 0$。\n\n4. 长日照谷物的光周期响应：设临界光周期为 $P_{\\text{crit}}$，饱和光周期为 $P_{\\text{opt}}$，单位为 $\\mathrm{hours}$。引入一个最小光周期因子 $s_{P,\\min}$，表示在极短日照下的残余发育。将 $f_P(P)$ 定义为一个有界线性标量：\n- 如果 $P \\le P_{\\text{crit}}$，$f_P(P) = s_{P,\\min}$。\n- 如果 $P_{\\text{crit}}  P  P_{\\text{opt}}$，\n$$\nf_P(P) = s_{P,\\min} + \\left( \\frac{P - P_{\\text{crit}}}{P_{\\text{opt}} - P_{\\text{crit}}} \\right) \\cdot (1 - s_{P,\\min}).\n$$\n- 如果 $P \\ge P_{\\text{opt}}$，$f_P(P) = 1$。\n\n5. 春化积累与效应：逐日春化单位累积 $a_V(T_v)$ 是春化温度 $T_v$（单位：$^{\\circ}\\mathrm{C}$）的三角函数，其参数为 $T_{v,\\min}$、$T_{v,\\text{opt}}$ 和 $T_{v,\\max}$：\n- 如果 $T_v \\le T_{v,\\min}$，$a_V(T_v) = 0$。\n- 如果 $T_{v,\\min}  T_v \\le T_{v,\\text{opt}}$，\n$$\na_V(T_v) = \\frac{T_v - T_{v,\\min}}{T_{v,\\text{opt}} - T_{v,\\min}}.\n$$\n- 如果 $T_{v,\\text{opt}}  T_v  T_{v,\\max}$，\n$$\na_V(T_v) = \\frac{T_{v,\\max} - T_v}{T_{v,\\max} - T_{v,\\text{opt}}}.\n$$\n- 如果 $T_v \\ge T_{v,\\max}$，$a_V(T_v) = 0$。\n\n累积春化量为\n$$\nV(d) = \\min\\left(V_{\\text{req}}, \\sum_{i=1}^{d} a_V(T_v(i))\\right),\n$$\n春化效应标量为\n$$\nf_V(V(d)) = \\frac{V(d)}{V_{\\text{req}}}.\n$$\n\n栽培品种参数（除非在测试用例中另有说明，否则为常数）：\n- 基点温度：$T_b = 0\\,^{\\circ}\\mathrm{C}$，$T_o = 18\\,^{\\circ}\\mathrm{C}$，$T_c = 35\\,^{\\circ}\\mathrm{C}$。\n- 光周期敏感性：$P_{\\text{crit}} = 8\\,\\mathrm{hours}$，$P_{\\text{opt}} = 16\\,\\mathrm{hours}$，$s_{P,\\min} = 0.5$。\n- 春化参数：$T_{v,\\min} = 0\\,^{\\circ}\\mathrm{C}$，$T_{v,\\text{opt}} = 6\\,^{\\circ}\\mathrm{C}$，$T_{v,\\max} = 15\\,^{\\circ}\\mathrm{C}$，$V_{\\text{req}} = 40$ (无量纲单位)。\n- 发育阈值：$D_{\\text{req}} = 1.0$ (无量纲)。\n\n内在发育速率常数 $k$（每个测试用例中指定）：见下文测试套件。$k$ 的单位是 $\\text{day}^{-1}$。\n\n逐日序列生成和单位：\n- 所有温度 $T(d)$ 和 $T_v(d)$ 的单位均为 $^{\\circ}\\mathrm{C}$。\n- 所有光周期 $P(d)$ 的单位均为 $\\mathrm{hours}$。\n- 所有天数必须以 $\\mathrm{days}$ 为单位报告为整数。\n\n测试套件（四个用例；每个用例定义了 $N$ 天和逐日序列）：\n\n- 用例 1（温带季节性演进，典型冬小麦，理想路径）：\n    - $N = 220$。\n    - $T(d) = 6 + 7 \\cdot \\sin\\left(\\dfrac{2\\pi (d - 20)}{365}\\right)$，对于 $d = 1,2,\\dots,N$。\n    - $P(d) = 12 + 4 \\cdot \\sin\\left(\\dfrac{2\\pi (d - 20)}{365}\\right)$。\n    - $T_v(d) = T(d)$。\n    - $k = 0.012$。\n\n- 用例 2（临界阈值下的边界光周期；相同的热力强迫）：\n    - $N = 220$。\n    - $T(d) = 6 + 7 \\cdot \\sin\\left(\\dfrac{2\\pi (d - 20)}{365}\\right)$。\n    - $P(d) = P_{\\text{crit}} = 8$，对于所有 $d$。\n    - $T_v(d) = T(d)$。\n    - $k = 0.012$。\n\n- 用例 3（因温度过高导致春化不足）：\n    - $N = 200$。\n    - $T(d) = 20 + 4 \\cdot \\sin\\left(\\dfrac{2\\pi d}{365}\\right)$。\n    - $P(d) = 12 + 2 \\cdot \\sin\\left(\\dfrac{2\\pi d}{365}\\right)$。\n    - $T_v(d) = T(d)$。\n    - $k = 0.012$。\n\n- 用例 4（在适宜温度下发育较慢的栽培品种）：\n    - $N = 250$。\n    - $T(d) = 14 + 6 \\cdot \\sin\\left(\\dfrac{2\\pi (d - 60)}{365}\\right)$。\n    - $P(d) = 11 + 3 \\cdot \\sin\\left(\\dfrac{2\\pi (d - 60)}{365}\\right)$。\n    - $T_v(d) = T(d)$。\n    - $k = 0.008$。\n\n算法任务：\n- 对于每个用例，计算所有 $d$ 的 $f_T(T(d))$、$f_P(P(d))$、$a_V(T_v(d))$、$V(d)$、$f_V(V(d))$ 和 $r(d)$，然后确定最小的天数 $D$，使得 $\\sum_{i=1}^{D} r(i) \\ge D_{\\text{req}}$。如果对于 $d \\in \\{1,\\dots,N\\}$ 不存在这样的 $D$，则报告 $-1$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含四个用例的结果，格式为方括号括起来的逗号分隔列表（例如，“[result1,result2,result3,result4]”），其中每个结果是从播种到开花的整数天数（单位：$\\mathrm{days}$），如果开花未在提供的 $N$ 天内发生，则为 $-1$。",
            "solution": "问题陈述已经过分析并被确定为有效。它在科学上基于环境和地球系统建模的原理，特别是作物物候学，并且在数学上是适定的、客观的和自洽的。所有必需的方程、参数和环境强迫数据均已提供，以确保得出唯一且可验证的解。\n\n通过为四个测试用例中的每一个实现一个离散时间的逐日模拟模型来找到解决方案。该模型根据每日环境输入计算冬小麦栽培品种的开花进程。模型的核心是计算每日发育速率 $r(d)$，然后随时间积分，直到达到指定的发育阈值。\n\n第 $d$ 天的每日发育速率由以下方程给出：\n$$\nr(d) = k \\cdot f_T(T(d)) \\cdot f_P(P(d)) \\cdot f_V(V(d))\n$$\n这里，$k$ 是栽培品种的内在发育速率常数，单位为 $\\text{day}^{-1}$。项 $f_T$、$f_P$ 和 $f_V$ 是介于 $0$ 和 $1$ 之间的无量纲标量，分别代表温度、光周期和春化的限制效应。\n\n对于模拟中的每一天 $d$，从 $d=1$ 到为该用例指定的最大天数 $N$，执行以下步骤：\n\n1.  **环境强迫计算**：根据为每个测试用例提供的正弦函数计算日平均温度 $T(d)$、光周期 $P(d)$ 和春化温度 $T_v(d)$。在所有用例中，都指定 $T_v(d) = T(d)$。\n\n2.  **温度响应标量, $f_T(T(d))$**：该标量是使用日温度 $T(d)$ 和栽培品种的基点温度（最低 $T_b = 0\\,^{\\circ}\\mathrm{C}$、最适 $T_o = 18\\,^{\\circ}\\mathrm{C}$ 和最高 $T_c = 35\\,^{\\circ}\\mathrm{C}$）的分段线性（三角）函数计算的。该函数定义如下：\n    -   如果 $T \\le T_b$ 或 $T \\ge T_c$，则 $f_T(T) = 0$。\n    -   如果 $T_b  T \\le T_o$，则 $f_T(T) = (T - T_b) / (T_o - T_b)$。\n    -   如果 $T_o  T  T_c$，则 $f_T(T) = (T_c - T) / (T_c - T_o)$。\n    此函数在允许生长的温度范围之外评估为 $0$，并线性缩放到在最适温度下达到最大值 $1$。\n\n3.  **光周期响应标量, $f_P(P(d))$**：该标量量化了植物对日长 $P(d)$ 的响应。对于像冬小麦这样的长日照植物，发育随日照变长而加速。该函数是一个有界线性模型，基于临界光周期 $P_{\\text{crit}} = 8\\,\\mathrm{hours}$、饱和光周期 $P_{\\text{opt}} = 16\\,\\mathrm{hours}$ 和最小响应因子 $s_{P,\\min} = 0.5$。\n    -   如果 $P \\le P_{\\text{crit}}$，发育以基线速率进行，因此 $f_P(P) = s_{P,\\min}$。\n    -   如果 $P \\ge P_{\\text{opt}}$，光周期需求完全满足，因此 $f_P(P) = 1$。\n    -   如果 $P_{\\text{crit}}  P  P_{\\text{opt}}$，响应呈线性插值：$f_P(P) = s_{P,\\min} + ( (P - P_{\\text{crit}}) / (P_{\\text{opt}} - P_{\\text{crit}}) ) \\cdot (1 - s_{P,\\min})$。\n\n4.  **春化响应标量, $f_V(V(d))$**：该分量模拟了低温需求的满足情况，这对冬小麦获得开花能力至关重要。计算是一个涉及状态积累的两步过程。\n    -   首先，根据春化温度 $T_v(d)$ 计算每日春化单位累积 $a_V(T_v(d))$。这也遵循一个三角响应函数，其春化基点温度为 $T_{v,\\min} = 0\\,^{\\circ}\\mathrm{C}$、$T_{v,\\text{opt}} = 6\\,^{\\circ}\\mathrm{C}$ 和 $T_{v,\\max} = 15\\,^{\\circ}\\mathrm{C}$。如果温度低于 $T_{v,\\min}$ 或高于 $T_{v,\\max}$，则不发生春化，最大累积速率（每天1个单位）发生在 $T_{v,\\text{opt}}$。\n    -   这些每日单位随时间累积：$V_{\\text{accum}}(d) = \\sum_{i=1}^{d} a_V(T_v(i))$。\n    -   有效累积春化量 $V(d)$ 是累积总量和总需求 $V_{\\text{req}} = 40$ 单位中的较小者：$V(d) = \\min(V_{\\text{req}}, V_{\\text{accum}}(d))$。\n    -   最后，春化标量 $f_V(V(d))$ 是已满足的春化需求的比例：$f_V(V(d)) = V(d) / V_{\\text{req}}$。该值随着低温需求的满足从 $0$ 增加到 $1$。\n\n5.  **累积发育和事件标准**：通过将内在速率 $k$ 乘以三个环境标量来计算每日速率 $r(d)$。该速率被添加到一个运行总和 `cumulative_development_sum` 中。模拟在每一天 $d$ 检查该总和是否达到或超过总发育需求 $D_{\\text{req}} = 1.0$。首次满足此条件 $\\sum_{i=1}^{D} r(i) \\ge D_{\\text{req}}$ 的那一天 $D$，即为预测的开花日。\n\n6.  **终止**：给定用例的模拟以两种方式之一终止。如果在第 $D$ 天满足开花标准，则将整数 $D$ 记录为结果。如果模拟完成所有 $N$ 天而未满足标准，则表示未发生开花，结果记录为 $-1$。\n\n这整个过程独立地应用于问题陈述中定义的四个测试用例中的每一个。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the sowing-to-flowering duration for a winter wheat cultivar\n    based on a daily-time-step phenology model.\n    \"\"\"\n\n    # Cultivar parameters (constant across all cases)\n    T_b, T_o, T_c = 0.0, 18.0, 35.0  # Cardinal temperatures for growth\n    P_crit, P_opt, s_P_min = 8.0, 16.0, 0.5  # Photoperiod parameters\n    T_v_min, T_v_opt, T_v_max = 0.0, 6.0, 15.0  # Cardinal vernalization temperatures\n    V_req = 40.0  # Vernalization requirement\n    D_req = 1.0  # Development threshold\n\n    def calculate_f_T(T):\n        \"\"\"Calculates the temperature response scalar f_T.\"\"\"\n        if T = T_b or T >= T_c:\n            return 0.0\n        elif T_b  T = T_o:\n            return (T - T_b) / (T_o - T_b)\n        else:  # T_o  T  T_c\n            return (T_c - T) / (T_c - T_o)\n\n    def calculate_f_P(P):\n        \"\"\"Calculates the photoperiod response scalar f_P.\"\"\"\n        if P = P_crit:\n            return s_P_min\n        elif P >= P_opt:\n            return 1.0\n        else:  # P_crit  P  P_opt\n            return s_P_min + ((P - P_crit) / (P_opt - P_crit)) * (1.0 - s_P_min)\n            \n    def calculate_a_V(T_v):\n        \"\"\"Calculates the daily vernalization unit accrual a_V.\"\"\"\n        if T_v = T_v_min or T_v >= T_v_max:\n            return 0.0\n        elif T_v_min  T_v = T_v_opt:\n            return (T_v - T_v_min) / (T_v_opt - T_v_min)\n        else: # T_v_opt  T_v  T_v_max\n            return (T_v_max - T_v) / (T_v_max - T_v_opt)\n\n    # Test suite definition\n    test_cases = [\n        {\n            \"N\": 220, \"k\": 0.012,\n            \"T_func\": lambda d: 6.0 + 7.0 * np.sin(2 * np.pi * (d - 20) / 365.0),\n            \"P_func\": lambda d: 12.0 + 4.0 * np.sin(2 * np.pi * (d - 20) / 365.0),\n        },\n        {\n            \"N\": 220, \"k\": 0.012,\n            \"T_func\": lambda d: 6.0 + 7.0 * np.sin(2 * np.pi * (d - 20) / 365.0),\n            \"P_func\": lambda d: P_crit,\n        },\n        {\n            \"N\": 200, \"k\": 0.012,\n            \"T_func\": lambda d: 20.0 + 4.0 * np.sin(2 * np.pi * d / 365.0),\n            \"P_func\": lambda d: 12.0 + 2.0 * np.sin(2 * np.pi * d / 365.0),\n        },\n        {\n            \"N\": 250, \"k\": 0.008,\n            \"T_func\": lambda d: 14.0 + 6.0 * np.sin(2 * np.pi * (d - 60) / 365.0),\n            \"P_func\": lambda d: 11.0 + 3.0 * np.sin(2 * np.pi * (d - 60) / 365.0),\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        N = case[\"N\"]\n        k = case[\"k\"]\n        T_func = case[\"T_func\"]\n        P_func = case[\"P_func\"]\n\n        cumulative_development_sum = 0.0\n        cumulative_vernalization_units = 0.0\n        flowering_day = -1\n\n        for d in range(1, N + 1):\n            # Calculate daily environmental drivers\n            T_d = T_func(d)\n            P_d = P_func(d)\n            T_v_d = T_d\n\n            # Calculate response scalars\n            f_T_d = calculate_f_T(T_d)\n            f_P_d = calculate_f_P(P_d)\n\n            # Update vernalization status and calculate f_V\n            a_V_d = calculate_a_V(T_v_d)\n            cumulative_vernalization_units += a_V_d\n            V_d = min(V_req, cumulative_vernalization_units)\n            f_V_d = V_d / V_req if V_req > 0 else 1.0\n\n            # Calculate daily development rate\n            r_d = k * f_T_d * f_P_d * f_V_d\n\n            # Update cumulative development sum\n            cumulative_development_sum += r_d\n\n            # Check for flowering\n            if cumulative_development_sum >= D_req:\n                flowering_day = d\n                break\n        \n        results.append(flowering_day)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "作物捕获阳光的能力是光合作用并最终决定产量的主要驱动力。本练习深入探讨了作物冠层内光截获的建模，应用比尔-朗伯定律来量化叶片吸收了多少光合有效辐射（PAR）。您将比较一种简单方法与一个更符合物理现实、考虑了太阳角度变化的模型，从而突显出生物物理模拟中细节的重要性。",
            "id": "3860944",
            "problem": "您需要开发一个完整且可运行的程序，该程序使用两种可选的短波消光系数公式（一个为恒定值，另一个依赖于太阳天顶角），计算具有已测量叶面积指数 (LAI) 的水平均质作物冠层每日截获的光合有效辐射 (PAR)。其科学背景是环境和地球系统模拟中的农业产量模拟。推导和计算必须从经过充分验证的辐射传输物理原理开始，特别是吸收介质中直射辐射的指数衰减规律。您的实现必须是通用的、纯数学的，仅依赖于指定的输入参数，无需任何外部输入。所有输入角度必须以度为单位，任何内部三角函数都应在角度转换为弧度后应用。能量必须以兆焦耳每平方米 ($MJ \\cdot m^{-2}$) 表示。每个测试用例的最终结果必须是以 $MJ \\cdot m^{-2} \\cdot day^{-1}$ 为单位的每日截获 PAR，并四舍五入到 3 位小数。\n\n科学基础和使用的假设：\n- 光合有效辐射 (PAR) 是与光合作用相关的短波辐射部分，在本任务中，为了计算目的，它被视为冠层顶部的直射辐射。\n- 均质吸收介质中的指数衰减（比尔-朗伯定律）适用于具有特定叶倾角分布特征的叶片元素的水平均质冠层。\n- 随机（球形）叶倾角分布的消光系数取决于投影函数和太阳天顶角。对于恒定系数情况，使用单一的漫射光消光值。对于依赖太阳天顶角的情况，使用球形叶片投影函数归一化。\n- 忽略 PAR 为零的夜间时段。当 PAR 为正且太阳天顶角接近地平线时，应遵守物理上一致的限制，以避免计算中出现奇点。\n\n您的程序必须：\n- 为每个提供的测试用例，使用两种模型计算每日截获的 PAR：\n  1. 一个具有指定常数 $k_c$ 的恒定消光系数模型。\n  2. 一个与球形叶倾角分布一致、依赖于太阳天顶角的消光系数模型 $k(\\theta)$。\n- 对于每个小时 $h$，给定小时 PAR $I_{h}$（单位 $MJ \\cdot m^{-2} \\cdot h^{-1}$）和太阳天顶角 $\\theta_h$（单位度），根据比尔-朗伯定律计算冠层的截获分数，累加所有白昼小时的截获小时 PAR，并返回两种模型的每日总截获 PAR（单位 $MJ \\cdot m^{-2} \\cdot day^{-1}$），结果四舍五入到 3 位小数。\n\n测试套件和参数：\n- 使用以下四个测试用例。每个用例提供一个白昼小时 PAR 值数组 $[I_{1}, I_{2}, \\dots]$（单位 $MJ \\cdot m^{-2} \\cdot h^{-1}$）和相应的太阳天顶角数组 $[\\theta_{1}, \\theta_{2}, \\dots]$（单位度），以及一个已测量的 LAI 和一个恒定消光系数 $k_c$。在所有情况下，对于依赖太阳天顶角的公式，采用球形叶倾角分布归一化 $G = 0.5$。\n\n- 测试用例 1（正常路径，类似中纬度夏季）：\n  - LAI $= 3.0$, $k_c = 0.5$。\n  - 小时 PAR ($MJ \\cdot m^{-2} \\cdot h^{-1}$): $[0.12, 0.28, 0.55, 0.82, 1.05, 1.15, 1.12, 1.00, 0.78, 0.50, 0.28, 0.12]$。\n  - 太阳天顶角 (度): $[80, 70, 60, 50, 40, 30, 25, 30, 40, 50, 60, 70]$。\n\n- 测试用例 2（边界情况，高纬度大太阳天顶角）：\n  - LAI $= 2.0$, $k_c = 0.5$。\n  - 小时 PAR ($MJ \\cdot m^{-2} \\cdot h^{-1}$): $[0.05, 0.08, 0.12, 0.18, 0.22, 0.22, 0.18, 0.12, 0.08, 0.05]$。\n  - 太阳天顶角 (度): $[85, 80, 75, 70, 65, 65, 70, 75, 80, 85]$。\n\n- 测试用例 3（边缘情况，无叶冠层）：\n  - LAI $= 0.0$, $k_c = 0.5$。\n  - 小时 PAR ($MJ \\cdot m^{-2} \\cdot h^{-1}$): $[0.12, 0.28, 0.55, 0.82, 1.05, 1.15, 1.12, 1.00, 0.78, 0.50, 0.28, 0.12]$。\n  - 太阳天顶角 (度): $[80, 70, 60, 50, 40, 30, 25, 30, 40, 50, 60, 70]$。\n\n- 测试用例 4（边缘情况，密集冠层）：\n  - LAI $= 6.0$, $k_c = 0.5$。\n  - 小时 PAR ($MJ \\cdot m^{-2} \\cdot h^{-1}$): $[0.10, 0.20, 0.40, 0.80, 1.20, 1.40, 1.30, 1.10, 0.90, 0.60, 0.30, 0.10]$。\n  - 太阳天顶角 (度): $[80, 70, 60, 50, 40, 30, 25, 30, 40, 50, 60, 70]$。\n\n输出规范：\n- 对每个测试用例，生成一个包含两个元素的列表 $[D_c, D_v]$，其中 $D_c$ 是使用恒定消光模型计算的每日截获 PAR（单位 $MJ \\cdot m^{-2} \\cdot day^{-1}$），$D_v$ 是使用依赖太阳天顶角消光模型计算的每日截获 PAR（单位 $MJ \\cdot m^{-2} \\cdot day^{-1}$）。每个值都必须四舍五入到 3 位小数。\n- 将所有测试用例的结果汇总到一行输出中，格式为方括号括起来的逗号分隔列表，其中每个测试用例由其自己的方括号对表示，例如：$[[D_{c1},D_{v1}],[D_{c2},D_{v2}],\\dots]$。\n\n您的程序必须严格按照此格式生成一行输出，且不得从用户或外部源读取任何输入。",
            "solution": "该问题是有效的，因为它具有科学依据、提法得当，并且为获得唯一解提供了所有必要的参数。解决方案源于植物冠层辐射传输的基本原理。\n\n控制作物冠层光吸收的核心原理是比尔-朗伯定律，该定律描述了辐射穿过吸收介质时的指数衰减。对于水平均质冠层，从冠层顶部算起，在累积叶面积指数为 $L$ 处的光合有效辐射 (PAR) 通量 $I$ 由下式给出：\n$$\nI(L) = I_0 \\exp(-k \\cdot L)\n$$\n其中 $I_0$ 是冠层顶部（$L=0$）的入射 PAR 通量，$k$ 是光消光系数。\n\n整个冠层（总叶面积指数为 LAI）截获的 PAR 量是入射辐射与穿透到地面（$L = \\text{LAI}$）的辐射之差。截获辐射的分数 $f_{\\text{int}}$ 为：\n$$\nf_{\\text{int}} = \\frac{I_0 - I(\\text{LAI})}{I_0} = 1 - \\exp(-k \\cdot \\text{LAI})\n$$\n该问题要求通过对所有白昼小时的每小时截获 PAR 进行求和来计算每日总截获 PAR。对于每个小时 $h$，截获的 PAR $I_{\\text{int}, h}$ 为：\n$$\nI_{\\text{int}, h} = I_h \\cdot f_{\\text{int}, h} = I_h \\cdot (1 - \\exp(-k_h \\cdot \\text{LAI}))\n$$\n其中 $I_h$ 是小时 $h$ 的入射 PAR，$k_h$ 是相应的每小时消光系数。每日总截获 PAR $D$ 是其总和：\n$$\nD = \\sum_{h=1}^{N} I_{\\text{int}, h}\n$$\n其中 $N$ 是白昼小时数。问题要求使用两种不同的消光系数 $k$ 模型来执行此计算。\n\n**模型 1：恒定消光系数**\n\n此模型假定全天使用单一、恒定的消光系数 $k_c$。这是一种常见的简化，通常代表漫射光条件或日平均值。每日截获 PAR $D_c$ 由下式给出：\n$$\nD_c = \\sum_{h=1}^{N} I_h \\cdot (1 - \\exp(-k_c \\cdot \\text{LAI}))\n$$\n由于项 $(1 - \\exp(-k_c \\cdot \\text{LAI}))$ 对所有小时都是恒定的，因此可以将其从求和中提出：\n$$\nD_c = \\left(1 - \\exp(-k_c \\cdot \\text{LAI})\\right) \\sum_{h=1}^{N} I_h\n$$\n\n**模型 2：依赖太阳天顶角的消光系数**\n\n此模型使用的消光系数随太阳天顶角 $\\theta$ 而变化。对于直射辐射，消光系数是光穿过冠层路径长度的函数，由下式给出：\n$$\nk(\\theta) = \\frac{G(\\theta)}{\\cos(\\theta)}\n$$\n此处，$G(\\theta)$ 是叶片朝向函数，表示朝向太阳投影的叶面积分数。问题指定了球形叶倾角分布，其投影函数为常数 $G(\\theta) = 0.5$。因此，对于天顶角为 $\\theta_h$ 的小时 $h$，其可变消光系数 $k_v$ 为：\n$$\nk_v(\\theta_h) = \\frac{0.5}{\\cos(\\theta_h)}\n$$\n注意，太阳天顶角 $\\theta_h$ 以度为单位提供，在使用如 $\\cos()$ 等三角函数时必须转换为弧度。此模型的每日截获 PAR $D_v$ 是通过对每小时的截获量求和计算得出的，其中消光系数每小时都在变化：\n$$\nD_v = \\sum_{h=1}^{N} \\left[ I_h \\cdot \\left(1 - \\exp\\left(-\\frac{0.5}{\\cos(\\theta_h)} \\cdot \\text{LAI}\\right)\\right) \\right]\n$$\n与恒定系数模型不同，截获分数项不能从求和中提出。\n\n**计算实现**\n\n对于每个测试用例，我们都给定了 LAI、恒定消光系数 $k_c$、一个小时 PAR 值数组 $\\{I_h\\}$ 以及一个相应的太阳天顶角数组 $\\{\\theta_h\\}$。\n\n1.  对于恒定模型，我们首先将所有小时 PAR 值相加，得到每日总入射 PAR $\\sum I_h$。然后，我们使用其简化公式计算 $D_c$。\n\n2.  对于可变模型，我们遍历每个小时。在每次迭代中，我们将天顶角 $\\theta_h$ 转换为弧度，计算 $k_v(\\theta_h)$，计算每小时截获的 PAR $I_{\\text{int}, h}$，并将其加到 $D_v$ 的运行总和中。\n\n3.  一个特殊情况是 LAI $= 0$ 时，这代表无叶冠层或裸地。在这种情况下，项 $\\exp(-k \\cdot \\text{LAI})$ 变为 $\\exp(0) = 1$，使得截获分数为 $1-1=0$。因此，对于 LAI $= 0$，$D_c$ 和 $D_v$ 都正确地计算为 $0$。\n\n根据规范，每个测试用例的最终结果 $D_c$ 和 $D_v$ 都四舍五入到 3 位小数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes daily intercepted PAR for a crop canopy using two extinction coefficient models.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test Case 1 (happy path, mid-latitude summer-like)\n        {\n            \"LAI\": 3.0, \"k_c\": 0.5,\n            \"par\": np.array([0.12, 0.28, 0.55, 0.82, 1.05, 1.15, 1.12, 1.00, 0.78, 0.50, 0.28, 0.12]),\n            \"zenith_angles\": np.array([80, 70, 60, 50, 40, 30, 25, 30, 40, 50, 60, 70])\n        },\n        # Test Case 2 (boundary high-latitude with large solar zenith)\n        {\n            \"LAI\": 2.0, \"k_c\": 0.5,\n            \"par\": np.array([0.05, 0.08, 0.12, 0.18, 0.22, 0.22, 0.18, 0.12, 0.08, 0.05]),\n            \"zenith_angles\": np.array([85, 80, 75, 70, 65, 65, 70, 75, 80, 85])\n        },\n        # Test Case 3 (edge case, leafless canopy)\n        {\n            \"LAI\": 0.0, \"k_c\": 0.5,\n            \"par\": np.array([0.12, 0.28, 0.55, 0.82, 1.05, 1.15, 1.12, 1.00, 0.78, 0.50, 0.28, 0.12]),\n            \"zenith_angles\": np.array([80, 70, 60, 50, 40, 30, 25, 30, 40, 50, 60, 70])\n        },\n        # Test Case 4 (edge case, dense canopy)\n        {\n            \"LAI\": 6.0, \"k_c\": 0.5,\n            \"par\": np.array([0.10, 0.20, 0.40, 0.80, 1.20, 1.40, 1.30, 1.10, 0.90, 0.60, 0.30, 0.10]),\n            \"zenith_angles\": np.array([80, 70, 60, 50, 40, 30, 25, 30, 40, 50, 60, 70])\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        lai = case[\"LAI\"]\n        k_c = case[\"k_c\"]\n        hourly_par = case[\"par\"]\n        zenith_deg = case[\"zenith_angles\"]\n\n        # Handle the edge case of LAI = 0 explicitly for clarity,\n        # though the formulas would yield 0 anyway.\n        if lai == 0.0:\n            d_c = 0.0\n            d_v = 0.0\n        else:\n            # Model 1: Constant extinction coefficient (k_c)\n            # D_c = (1 - exp(-k_c * LAI)) * sum(I_h)\n            total_daily_par = np.sum(hourly_par)\n            interception_fraction_c = 1.0 - np.exp(-k_c * lai)\n            d_c = interception_fraction_c * total_daily_par\n\n            # Model 2: Solar-zenith-dependent extinction coefficient k(theta)\n            # D_v = sum [ I_h * (1 - exp(-k_v(theta_h) * LAI)) ]\n            # k_v(theta) = G / cos(theta) with G = 0.5\n            zenith_rad = np.deg2rad(zenith_deg)\n            cos_zenith = np.cos(zenith_rad)\n            \n            # The problem guarantees zenith angles  90, so cos_zenith > 0.\n            # No need to check for division by zero.\n            k_v = 0.5 / cos_zenith\n            \n            interception_fraction_v = 1.0 - np.exp(-k_v * lai)\n            hourly_intercepted_par_v = hourly_par * interception_fraction_v\n            d_v = np.sum(hourly_intercepted_par_v)\n            \n        # Round results to 3 decimal places\n        d_c_rounded = round(d_c, 3)\n        d_v_rounded = round(d_v, 3)\n        \n        all_results.append(f\"[{d_c_rounded:.3f},{d_v_rounded:.3f}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "建立模型只是工作的一半；严格评估其预测能力同样至关重要。本练习介绍了k折交叉验证，这是一种评估模型泛化到新数据能力的稳健方法。您将应用此技术来评估一个简单的作物产量偏差校正模型，学习一套量化模型性能和可靠性的标准工作流程。",
            "id": "3860914",
            "problem": "您将获得两个数据集，其中包含多个年份和地点的农业产量数据。在每个数据集中，都有模拟产量和观测产量的配对观测值。设观测产量表示为 $o_i$（单位：吨/公顷，t/ha），模拟产量表示为 $s_i$（单位：吨/公顷，t/ha），其中 $i$ 为样本索引。为了评估一个简单偏差校正模型的泛化能力并评价其预测性能，您必须在每个数据集的所有样本上实现一个确定性的 $k$ 折交叉验证，并在汇总的测试集预测上计算指定的评估指标。交叉验证过程必须满足以下约束条件：\n- 样本按站点标识符（升序）排序，然后按年份（升序）排序。\n- 样本 $i$ 的折数索引为 $f_i = i \\bmod k$，其中排序后 $i$ 从 $0$ 开始，$k$ 是折数。\n- 对于每个折数 $j \\in \\{0,1,\\dots,k-1\\}$，训练集包含所有满足 $f_i \\neq j$ 的样本，测试集包含所有满足 $f_i = j$ 的样本。\n\n要在每个训练集上拟合的预测模型是一个从模拟产量到观测产量的线性偏差校正映射，\n$$\n\\hat{o}_i = a\\, s_i + b,\n$$\n其中 $a$ 和 $b$ 是标量参数。这些参数必须通过普通最小二乘法估计，该方法旨在最小化训练集上的残差平方和。拟合后，您必须在相应的测试集上生成预测值 $\\hat{o}_i$，最后汇总所有折数的测试集预测，以在汇总的测试集上计算所需的评估指标。\n\n评估指标根据误差 $e_i = \\hat{o}_i - o_i$ 从基本原理定义：\n- 均方根误差（RMSE，单位：t/ha）：$$\\mathrm{RMSE} = \\sqrt{\\frac{1}{n}\\sum_{i=1}^{n} e_i^2}.$$\n- 平均绝对误差（MAE，单位：t/ha）：$$\\mathrm{MAE} = \\frac{1}{n}\\sum_{i=1}^{n} |e_i|.$$\n- 偏差（Bias，单位：t/ha）：$$\\mathrm{Bias} = \\frac{1}{n}\\sum_{i=1}^{n} e_i.$$\n- 纳什-萨特克利夫效率（Nash–Sutcliffe efficiency，无量纲）：$$\\mathrm{NSE} = 1 - \\frac{\\sum_{i=1}^{n} e_i^2}{\\sum_{i=1}^{n} (o_i - \\bar{o})^2},$$ 其中 $\\bar{o}$ 是汇总测试集上观测产量的平均值。\n\n所有产量单位均为吨/公顷（t/ha）。任何中间或最终值都必须使用这些单位进行一致计算，任何具有物理单位的指标都必须以 t/ha 表示。纳什-萨特克利夫效率是无量纲的。\n\n您的程序必须为以下测试套件实现上述过程。每个数据集都完全指定为 $(\\text{站点}, \\text{年份}, s, o)$ 元组，其中 $s$ 和 $o$ 的单位为 t/ha：\n\n数据集 A（多站点，多年份）：\n- 站点 $0$：$2015$ 年至 $2018$ 年\n  - $(0, 2015, 4.9, 5.2)$, $(0, 2016, 5.7, 5.6)$, $(0, 2017, 6.0, 6.1)$, $(0, 2018, 5.5, 5.8)$\n- 站点 $1$：$2015$ 年至 $2018$ 年\n  - $(1, 2015, 6.5, 7.1)$, $(1, 2016, 7.0, 6.8)$, $(1, 2017, 7.3, 7.4)$, $(1, 2018, 7.2, 7.0)$\n- 站点 $2$：$2015$ 年至 $2018$ 年\n  - $(2, 2015, 3.5, 3.8)$, $(2, 2016, 4.0, 4.2)$, $(2, 2017, 4.7, 4.5)$, $(2, 2018, 3.9, 4.0)$\n\n数据集 B（单站点，多年份）：\n- 站点 $3$：$2015$ 年至 $2019$ 年\n  - $(3, 2015, 3.5, 4.0)$, $(3, 2016, 4.2, 4.0)$, $(3, 2017, 3.8, 4.0)$, $(3, 2018, 4.5, 4.0)$, $(3, 2019, 4.0, 4.0)$\n\n对于以下每个测试用例，请实现上述确定性 $k$ 折交叉验证过程，并在汇总的测试集预测上计算指标：\n- 用例 $1$：数据集 A，$k=3$，指标 $\\mathrm{NSE}$（无量纲）。将结果报告为小数，并四舍五入到小数点后六位。\n- 用例 $2$：数据集 A，$k=4$，指标 $\\mathrm{RMSE}$（单位：t/ha）。将结果报告为小数，并四舍五入到小数点后六位。\n- 用例 $3$：数据集 B，$k=5$，指标 $\\mathrm{Bias}$（单位：t/ha）。将结果报告为小数，并四舍五入到小数点后六位。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按用例 $1$、用例 $2$、用例 $3$ 的顺序排列结果，每个数字格式化为小数点后恰好六位（例如，`[0.123456,0.654321,-0.000100]`）。",
            "solution": "我们从环境与地球系统建模中用于预测模型确定性评估的基本定义开始。产量预测通过使用基于误差的指标比较模拟产量与观测产量来进行评估。设观测产量为 $o_i \\in \\mathbb{R}$，模拟产量为 $s_i \\in \\mathbb{R}$，两者均以吨/公顷（t/ha）为单位。我们将预测模型定义为一个线性偏差校正映射，\n$$\n\\hat{o}_i = a\\, s_i + b,\n$$\n其中 $a \\in \\mathbb{R}$ 和 $b \\in \\mathbb{R}$ 是待从数据中估计的参数。建模假设是模拟产量与观测产量之间的关系可以通过一个仿射变换来近似，并且随机误差由残差 $\\epsilon_i = o_i - \\hat{o}_i$ 捕获。\n\n为了从训练集中估计 $a$ 和 $b$，我们采用基于最小化残差平方和这一经过充分检验的原则的普通最小二乘法。设训练集由 $m$ 个样本组成，索引为 $i \\in \\{1,\\dots,m\\}$。定义设计矩阵\n$$\nX = \n\\begin{bmatrix}\ns_1  1 \\\\\ns_2  1 \\\\\n\\vdots  \\vdots \\\\\ns_m  1\n\\end{bmatrix},\n$$\n参数向量\n$$\n\\theta = \n\\begin{bmatrix}\na \\\\ b\n\\end{bmatrix},\n$$\n和响应向量\n$$\ny = \n\\begin{bmatrix}\no_1 \\\\ o_2 \\\\ \\vdots \\\\ o_m\n\\end{bmatrix}.\n$$\n残差向量为 $r = y - X \\theta$。普通最小二乘估计 $\\hat{\\theta}$ 最小化目标函数\n$$\nJ(\\theta) = \\| y - X \\theta \\|_2^2 = \\sum_{i=1}^{m} \\left(o_i - a s_i - b\\right)^2.\n$$\n一个经过充分检验的解由正规方程给出\n$$\nX^\\top X \\hat{\\theta} = X^\\top y,\n$$\n其解为\n$$\n\\hat{\\theta} = (X^\\top X)^{-1} X^\\top y,\n$$\n前提是 $X^\\top X$ 可逆。在数值计算上，为确保稳定性，我们使用最小二乘求解器计算 $\\hat{\\theta}$，即使 $X^\\top X$ 是病态的，该求解器也能在欧几里得范数意义下找到最小化 $J(\\theta)$ 的 $\\hat{\\theta}$。\n\n一旦获得 $\\hat{\\theta} = (\\hat{a}, \\hat{b})^\\top$，对任何具有模拟产量 $s$ 的测试样本的预测计算为 $\\hat{o} = \\hat{a} s + \\hat{b}$。测试样本的误差为\n$$\ne = \\hat{o} - o.\n$$\n为了评估一个包含 $n$ 个样本的汇总测试集的性能，我们从基本原理计算以下指标：\n- 均方根误差，\n$$\n\\mathrm{RMSE} = \\sqrt{\\frac{1}{n}\\sum_{i=1}^{n} e_i^2},\n$$\n单位为 t/ha，因为它是由单位为 t/ha 的差值的平方导出，然后取平方根。\n- 平均绝对误差，\n$$\n\\mathrm{MAE} = \\frac{1}{n}\\sum_{i=1}^{n} |e_i|,\n$$\n单位同样为 t/ha。\n- 偏差，\n$$\n\\mathrm{Bias} = \\frac{1}{n}\\sum_{i=1}^{n} e_i,\n$$\n单位为 t/ha。\n- 纳什-萨特克利夫效率，\n$$\n\\mathrm{NSE} = 1 - \\frac{\\sum_{i=1}^{n} e_i^2}{\\sum_{i=1}^{n} (o_i - \\bar{o})^2},\n$$\n其中 $\\bar{o} = \\frac{1}{n}\\sum_{i=1}^{n} o_i$。该指标是无量纲的，因为它是相同单位的平方和之比。\n\n对于交叉验证，我们使用一个确定性的划分规则来确保跨年份和站点的可复现性。让样本按站点标识符（升序）排序，然后按年份（升序）排序。为每个样本分配一个折数索引\n$$\nf_i = i \\bmod k,\n$$\n其中 $i$ 是排序后从 0 开始的索引，$k$ 是折数。对于每个折数 $j \\in \\{0,1,\\dots,k-1\\}$，定义训练集 $\\mathcal{T}_j = \\{ i \\mid f_i \\neq j \\}$ 和测试集 $\\mathcal{S}_j = \\{ i \\mid f_i = j \\}$。在 $\\mathcal{T}_j$ 上，通过普通最小二乘法拟合 $\\hat{a}_j$ 和 $\\hat{b}_j$。然后，在 $\\mathcal{S}_j$ 上生成预测 $\\hat{o}_i = \\hat{a}_j s_i + \\hat{b}_j$。将所有折数的测试预测汇总收集到一个集合 $\\{(\\hat{o}_i, o_i)\\}_{i=1}^{n}$ 中用于指标计算，其中 $n$ 是数据集中的总样本数。\n\n每个测试用例的算法设计：\n1. 加载数据集并按站点和年份对样本进行排序，以建立确定性索引 $i$。\n2. 对于指定的 $k$，计算折数索引 $f_i = i \\bmod k$。\n3. 对于每个折数 $j$，从 $\\mathcal{T}_j$ 中组建训练矩阵 $X$ 和向量 $y$，通过最小二乘法求解 $\\hat{\\theta}_j$，并在 $\\mathcal{S}_j$ 上计算测试预测。\n4. 拼接所有测试预测，以获得汇总测试集的数组 $(\\hat{o}_i)$ 和 $(o_i)$。\n5. 使用其上述基本定义计算所请求的指标。\n6. 将结果格式化为小数点后恰好六位。\n\n对于测试套件：\n- 用例 $1$ 使用数据集 A，$k=3$，和 $\\mathrm{NSE}$。纳什-萨特克利夫效率评估了偏差校正后的预测相对于观测产量平均值再现观测产量变异性的能力。\n- 用例 $2$ 使用数据集 A，$k=4$，和 $\\mathrm{RMSE}$（单位：t/ha）。这评估了偏差校正后预测误差的典型量级。\n- 用例 $3$ 使用数据集 B，$k=5$，和 $\\mathrm{Bias}$（单位：t/ha）。由于观测产量多年保持不变，偏差量化了预测值与观测值之间的平均有符号偏差（单位：t/ha），并且在 $o_i$ 的方差为零时是稳健的。\n\n最后，程序按用例 $1$、用例 $2$、用例 $3$ 的顺序，以 `[v1,v2,v3]` 的格式单行输出三个指标值，其中 $v1$、$v2$ 和 $v3$ 是四舍五入到小数点后六位的小数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef assign_folds(sorted_samples, k):\n    \"\"\"\n    Assign fold indices deterministically using i % k, where i is the index\n    after sorting by (site, year).\n    \"\"\"\n    folds = []\n    for i, _ in enumerate(sorted_samples):\n        folds.append(i % k)\n    return np.array(folds, dtype=int)\n\ndef fit_linear_least_squares(s_train, o_train):\n    \"\"\"\n    Fit a linear model o_hat = a*s + b using ordinary least squares.\n    Returns (a, b).\n    \"\"\"\n    # Design matrix with columns [s, 1]\n    X = np.column_stack([s_train, np.ones_like(s_train)])\n    # Solve least squares: minimize ||X*[a,b] - o||\n    theta, _, _, _ = np.linalg.lstsq(X, o_train, rcond=None)\n    a, b = theta[0], theta[1]\n    return a, b\n\ndef predict_linear(a, b, s):\n    \"\"\"\n    Predict observed yield from simulated yield using o_hat = a*s + b.\n    \"\"\"\n    return a * s + b\n\ndef metric_rmse(o_hat, o_true):\n    \"\"\"\n    Root Mean Squared Error (t/ha).\n    \"\"\"\n    e = o_hat - o_true\n    return float(np.sqrt(np.mean(e**2)))\n\ndef metric_bias(o_hat, o_true):\n    \"\"\"\n    Bias (t/ha).\n    \"\"\"\n    e = o_hat - o_true\n    return float(np.mean(e))\n\ndef metric_nse(o_hat, o_true):\n    \"\"\"\n    Nash–Sutcliffe efficiency (dimensionless).\n    \"\"\"\n    e = o_hat - o_true\n    denom = np.sum((o_true - np.mean(o_true))**2)\n    num = np.sum(e**2)\n    # If denom is zero (no variability), NSE is undefined; set to 1 - num/0 -> -inf.\n    # For robustness, we return -inf in that case.\n    if denom == 0.0:\n        return float(\"-inf\")\n    return float(1.0 - num / denom)\n\ndef cross_validate(samples, k, metric_name):\n    \"\"\"\n    Perform deterministic k-fold cross-validation on given samples.\n    samples: list of tuples (site, year, s, o)\n    k: number of folds\n    metric_name: one of 'NSE', 'RMSE', 'Bias'\n    Returns computed metric on pooled test predictions.\n    \"\"\"\n    # Sort samples by (site, year)\n    sorted_samples = sorted(samples, key=lambda x: (x[0], x[1]))\n    folds = assign_folds(sorted_samples, k)\n    # Collect pooled predictions and observations\n    o_hat_pooled = []\n    o_true_pooled = []\n\n    for j in range(k):\n        # Indices for training and test\n        test_idx = np.where(folds == j)[0]\n        train_idx = np.where(folds != j)[0]\n\n        # Extract training data\n        s_train = np.array([sorted_samples[idx][2] for idx in train_idx], dtype=float)\n        o_train = np.array([sorted_samples[idx][3] for idx in train_idx], dtype=float)\n\n        # Fit linear model\n        a, b = fit_linear_least_squares(s_train, o_train)\n\n        # Predict on test data\n        s_test = np.array([sorted_samples[idx][2] for idx in test_idx], dtype=float)\n        o_test = np.array([sorted_samples[idx][3] for idx in test_idx], dtype=float)\n\n        o_hat = predict_linear(a, b, s_test)\n\n        o_hat_pooled.append(o_hat)\n        o_true_pooled.append(o_test)\n\n    # Concatenate pooled arrays\n    o_hat_pooled = np.concatenate(o_hat_pooled) if len(o_hat_pooled) > 0 else np.array([], dtype=float)\n    o_true_pooled = np.concatenate(o_true_pooled) if len(o_true_pooled) > 0 else np.array([], dtype=float)\n\n    # Compute requested metric\n    if metric_name == 'NSE':\n        return metric_nse(o_hat_pooled, o_true_pooled)\n    elif metric_name == 'RMSE':\n        return metric_rmse(o_hat_pooled, o_true_pooled)\n    elif metric_name == 'Bias':\n        return metric_bias(o_hat_pooled, o_true_pooled)\n    else:\n        raise ValueError(\"Unsupported metric_name\")\n\ndef solve():\n    # Define Dataset A (multi-site, multi-year): (site, year, s, o) with yields in t/ha.\n    dataset_a = [\n        (0, 2015, 4.9, 5.2), (0, 2016, 5.7, 5.6), (0, 2017, 6.0, 6.1), (0, 2018, 5.5, 5.8),\n        (1, 2015, 6.5, 7.1), (1, 2016, 7.0, 6.8), (1, 2017, 7.3, 7.4), (1, 2018, 7.2, 7.0),\n        (2, 2015, 3.5, 3.8), (2, 2016, 4.0, 4.2), (2, 2017, 4.7, 4.5), (2, 2018, 3.9, 4.0),\n    ]\n\n    # Define Dataset B (single-site, multi-year): (site, year, s, o) with yields in t/ha.\n    dataset_b = [\n        (3, 2015, 3.5, 4.0), (3, 2016, 4.2, 4.0), (3, 2017, 3.8, 4.0), (3, 2018, 4.5, 4.0), (3, 2019, 4.0, 4.0),\n    ]\n\n    # Test cases: (dataset, k, metric_name)\n    test_cases = [\n        (dataset_a, 3, 'NSE'),   # Case 1\n        (dataset_a, 4, 'RMSE'),  # Case 2\n        (dataset_b, 5, 'Bias'),  # Case 3\n    ]\n\n    results = []\n    for dataset, k, metric_name in test_cases:\n        value = cross_validate(dataset, k, metric_name)\n        # Format to six decimal places; handle infinities explicitly\n        if np.isneginf(value):\n            formatted = \"-inf\"\n        elif np.isposinf(value):\n            formatted = \"inf\"\n        elif np.isnan(value):\n            formatted = \"nan\"\n        else:\n            formatted = f\"{value:.6f}\"\n        results.append(formatted)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}