{
    "hands_on_practices": [
        {
            "introduction": "构建基于主体的模型（ABM）的一个基本任务是形式化单个主体的决策过程。这项练习  旨在为您奠定一个关键基础，要求您模拟农民在降雨不确定的情况下选择种植何种作物。您将应用均值-方差效用理论来刻画具有不同风险厌恶程度的主体如何做出理性选择，然后汇总这些个体决策以确定整个系统的稳态行为。这项练习对于培养将微观经济学原理与宏观涌现模式联系起来的能力至关重要。",
            "id": "3860659",
            "problem": "您需要以纯数学方式构建并分析一个关于人类—环境系统中农业决策的最小化基于主体的模型（Agent-Based Model, ABM）。环境的特点是固定的随机降雨分布，每个主体（农民）在季节开始时，根据预期利润及其变异性选择两种作物中的一种。您的任务是在指定的分布、参数值和决策规则下，计算种植作物 $A$ 的农民所占的稳态比例。所有量均为无量纲。最终输出必须表示为保留六位小数的小数分数。\n\n模型设置：\n- 有 $N$ 个主体（农民），每个主体都有一个风险规避参数 $\\lambda$，该参数从有界区间上的指定分布中独立抽取。每个季节，主体选择能够使其均值—方差期望效用最大化的作物，期望效用定义为 $U_i(\\lambda) = \\mathbb{E}[\\Pi_i] - \\lambda \\operatorname{Var}(\\Pi_i)$，其中 $i \\in \\{A,B\\}$，$ \\Pi_i$ 表示利润。\n- 降雨量 $R$ 是一个随机变量，服从固定的对数正态分布，参数为 $(\\mu_R, \\sigma_R)$，因此 $\\ln R \\sim \\mathcal{N}(\\mu_R, \\sigma_R^2)$ 且所有矩 $\\mathbb{E}[R^k]$ 对于 $k \\geq 0$ 都存在。\n- 作物 $i$ 的产量函数为 $Y_i(R) = a_i R - b_i R^2$，单位产出价格为 $P_i$，固定成本为 $c_i$。利润等于 $\\Pi_i = P_i Y_i(R) - c_i$。\n- 在给定的固定降雨分布和固定作物参数下，每个主体选择使 $U_i(\\lambda)$ 最大化的作物。由于分布随时间保持不变，一旦期望反映了固定的环境，主体的选择在不同季节间便不再改变，宏观层面的状态会收敛到种植作物 $A$ 的主体的稳态比例。\n\n使用的基础理论：\n- 均值—方差决策理论：$U_i(\\lambda) = \\mathbb{E}[\\Pi_i] - \\lambda \\operatorname{Var}(\\Pi_i)$。\n- 矩和方差的定义：对于随机变量 $X$，$\\operatorname{Var}(X) = \\mathbb{E}[X^2] - (\\mathbb{E}[X])^2$，协方差 $\\operatorname{Cov}(X,Y) = \\mathbb{E}[XY] - \\mathbb{E}[X]\\mathbb{E}[Y]$。\n- 对数正态分布的矩：若 $\\ln R \\sim \\mathcal{N}(\\mu_R, \\sigma_R^2)$，则 $\\mathbb{E}[R^k] = \\exp\\!\\left(k\\mu_R + \\frac{1}{2}k^2 \\sigma_R^2\\right)$，对于 $k \\in \\{1,2,3,4\\}$。\n- 大数定律：稳态比例等于在指定的 $\\lambda$ 分布下，选择作物 $A$ 的主体集合的概率测度。\n\n您的任务：\n- 推导一个算法，在给定 $(\\mu_R, \\sigma_R)$、$(a_A, b_A, P_A, c_A)$、$(a_B, b_B, P_B, c_B)$ 以及 $\\lambda$ 的指定分布下，计算种植作物 $A$ 的农民的稳态比例 $f_A$。您应假设 $\\lambda$ 服从 $[\\lambda_{\\min}, \\lambda_{\\max}]$ 上的均匀分布或 $[0, \\lambda_{\\max}]$ 上形状参数为 $(\\alpha, \\beta)$ 的缩放贝塔分布。稳态比例必须通过使用对数正态分布的解析矩和均值—方差效用规则来计算，而非通过模拟。\n\n- 具体来说，根据 $(\\mu_R, \\sigma_R, a_i, b_i)$ 使用最高到 $k=4$ 的矩来计算 $\\mathbb{E}[Y_i]$ 和 $\\operatorname{Var}(Y_i)$，然后对于 $i\\in\\{A,B\\}$ 求得 $\\mathbb{E}[\\Pi_i]$ 和 $\\operatorname{Var}(\\Pi_i)$。定义 $\\Delta E = \\mathbb{E}[\\Pi_A] - \\mathbb{E}[\\Pi_B]$ 和 $\\Delta V = \\operatorname{Var}(\\Pi_A) - \\operatorname{Var}(\\Pi_B)$，并使用决策不等式 $U_A(\\lambda) > U_B(\\lambda)$ 来确定区分选择作物 $A$ 和作物 $B$ 的主体的 $\\lambda$ 阈值。\n\n- 严格处理边界条件：\n    - 如果 $\\Delta V > 0$，则当 $\\lambda < \\Delta E / \\Delta V$ 时，主体选择作物 $A$。\n    - 如果 $\\Delta V < 0$，则当 $\\lambda > \\Delta E / \\Delta V$ 时，主体选择作物 $A$。\n    - 如果 $\\Delta V = 0$，则选择与 $\\lambda$ 无关；如果 $\\Delta E > 0$，则 $f_A = 1$；如果 $\\Delta E < 0$，则 $f_A = 0$；如果 $\\Delta E = 0$，则 $f_A = 1/2$。\n\n- 对于均匀分布 $\\lambda \\sim \\mathcal{U}([\\lambda_{\\min}, \\lambda_{\\max}])$，通过测量相应区间的长度来评估该比例。对于在 $[0, \\lambda_{\\max}]$ 上的缩放贝塔分布，使用归一化阈值 $z = (\\Delta E / \\Delta V) / \\lambda_{\\max}$ 上的贝塔累积分布函数进行评估，不等式的方向由 $\\Delta V$ 的符号决定。\n\n测试套件：\n为以下四个参数集计算 $f_A$。每个测试用例都是独立的，应产生一个浮点数（选择作物 $A$ 的农民比例），四舍五入到六位小数，不以百分比表示。\n\n- 测试用例 1（正常路径，均匀分布）：\n    - 降雨参数：$\\mu_R = 0.5$，$\\sigma_R = 0.3$。\n    - 作物 A：$a_A = 2.0$， $b_A = 0.15$， $P_A = 1.0$， $c_A = 0.2$。\n    - 作物 B：$a_B = 1.6$， $b_B = 0.05$， $P_B = 1.1$， $c_B = 0.25$。\n    - $\\lambda$ 分布：均匀分布，$\\lambda_{\\min} = 0.0$，$\\lambda_{\\max} = 2.0$。\n\n- 测试用例 2（边界情况，方差相等，均匀分布）：\n    - 降雨参数：$\\mu_R = 0.3$，$\\sigma_R = 0.2$。\n    - 作物 A：$a_A = 1.5$， $b_A = 0.08$， $P_A = 1.0$， $c_A = 0.1$。\n    - 作物 B：$a_B = 1.5$， $b_B = 0.08$， $P_B = 1.0$， $c_B = 0.3$。\n    - $\\lambda$ 分布：均匀分布，$\\lambda_{\\min} = 0.0$，$\\lambda_{\\max} = 3.0$。\n\n- 测试用例 3（边缘情况，负阈值，均匀分布）：\n    - 降雨参数：$\\mu_R = 0.4$，$\\sigma_R = 0.6$。\n    - 作物 A：$a_A = 1.8$， $b_A = 0.1$， $P_A = 2.0$， $c_A = 5.0$。\n    - 作物 B：$a_B = 1.8$， $b_B = 0.1$， $P_B = 0.5$， $c_B = 0.0$。\n    - $\\lambda$ 分布：均匀分布，$\\lambda_{\\min} = 0.0$，$\\lambda_{\\max} = 10.0$。\n\n- 测试用例 4（不等式反转，[0,1]上的贝塔分布）：\n    - 降雨参数：$\\mu_R = 0.7$，$\\sigma_R = 0.4$。\n    - 作物 A：$a_A = 1.5$， $b_A = 0.07$， $P_A = 0.8$， $c_A = 0.05$。\n    - 作物 B：$a_B = 1.5$， $b_B = 0.07$， $P_B = 2.0$， $c_B = 0.2$。\n    - $\\lambda$ 分布：在 $[0, \\lambda_{\\max}]$ 上的缩放贝塔分布，$\\lambda_{\\max} = 1.0$，形状参数 $\\alpha = 2.0$，$\\beta = 5.0$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按测试用例1到4的顺序排列结果。每个数字必须四舍五入到六位小数。例如，$[0.742857,0.500000,0.000000,0.123456]$。",
            "solution": "已根据指定的验证协议对用户提供的问题进行了分析。\n\n### 第 1 步：提取给定信息\n- **任务**：计算选择作物 $A$ 的农民的稳态比例 ($f_A$)。\n- **主体**：$N$ 个农民，其风险规避参数为 $\\lambda$。\n- **效用函数**：$U_i(\\lambda) = \\mathbb{E}[\\Pi_i] - \\lambda \\operatorname{Var}(\\Pi_i)$，适用于作物 $i \\in \\{A, B\\}$。\n- **决策规则**：选择使 $U_i(\\lambda)$ 最大化的作物。\n- **环境**：降雨量 $R$ 是一个随机变量，服从对数正态分布，$\\ln R \\sim \\mathcal{N}(\\mu_R, \\sigma_R^2)$。\n- **对数正态分布的矩**：$\\mathbb{E}[R^k] = \\exp(k\\mu_R + \\frac{1}{2}k^2 \\sigma_R^2)$，对于 $k \\in \\{1, 2, 3, 4\\}$。\n- **产量函数**：$Y_i(R) = a_i R - b_i R^2$。\n- **利润函数**：$\\Pi_i = P_i Y_i(R) - c_i$。\n- **$\\lambda$ 分布**：\n    1. 均匀分布：$\\lambda \\sim \\mathcal{U}([\\lambda_{\\min}, \\lambda_{\\max}])$。\n    2. 缩放贝塔分布：在 $[0, \\lambda_{\\max}]$ 上，形状参数为 $(\\alpha, \\beta)$。\n- **决策逻辑**：选择取决于 $\\Delta V = \\operatorname{Var}(\\Pi_A) - \\operatorname{Var}(\\Pi_B)$ 的符号和阈值 $\\lambda_c = \\Delta E / \\Delta V$，其中 $\\Delta E = \\mathbb{E}[\\Pi_A] - \\mathbb{E}[\\Pi_B]$。\n    - 如果 $\\Delta V > 0$，当 $\\lambda < \\lambda_c$ 时选择 $A$。\n    - 如果 $\\Delta V < 0$，当 $\\lambda > \\lambda_c$ 时选择 $A$。\n    - 如果 $\\Delta V = 0$，选择仅取决于 $\\Delta E$ 的符号。\n- **测试用例**：提供了四个具体的参数集用于计算。\n\n### 第 2 步：使用提取的给定信息进行验证\n- **科学依据**：该问题基于标准的经济学理论（均值-方差分析）、统计理论（对数正态分布、均匀分布和贝塔分布的性质）以及基于主体的建模的核心概念。产量函数是一种常见的简化方法。此项有效。\n- **良态性**：问题定义明确，提供了所有必要的参数、方程和决策规则，以便为每个测试用例计算出唯一解。此项有效。\n- **客观性**：问题以精确的数学术语陈述，没有歧义或主观内容。此项有效。\n- **完整性与一致性**：问题是自包含的，其组成部分在逻辑上是一致的。所有情况（例如，$\\Delta V > 0$, $\\Delta V < 0$, $\\Delta V = 0$）的规则都已完全指定。此项有效。\n- **现实性**：虽然是一种抽象，但该模型捕捉了预期回报与风险之间的基本权衡，这是农业决策的一个现实方面。此项有效。\n\n### 第 3 步：结论与行动\n该问题是有效的。它是一项严谨且定义明确的应用数学和建模练习。我将继续提供完整的解决方案。\n\n### 解析解推导\n目标是找到选择作物 $A$ 的主体稳态比例 $f_A$。这个比例等同于一个随机选择的主体的风险规避参数 $\\lambda$ 落在偏好作物 $A$ 的范围内的概率。推导过程分四步进行。\n\n**1. 降雨量 ($R$) 的矩**\n给定降雨量 $R$ 服从对数正态分布，使得 $\\ln R \\sim \\mathcal{N}(\\mu_R, \\sigma_R^2)$，则 $R$ 的 $k$ 阶原点矩由以下公式给出：\n$$M_k = \\mathbb{E}[R^k] = \\exp\\left(k\\mu_R + \\frac{1}{2}k^2 \\sigma_R^2\\right)$$\n我们将需要前四阶矩（$M_1, M_2, M_3, M_4$）来计算二次利润函数的均值和方差。\n\n**2. 期望利润和利润方差 ($\\mathbb{E}[\\Pi_i]$ 和 $\\operatorname{Var}(\\Pi_i)$)**\n作物 $i$ 的利润是降雨量 $R$ 的函数：$\\Pi_i(R) = P_i(a_i R - b_i R^2) - c_i$。\n\n期望利润 $\\mathbb{E}[\\Pi_i]$ 通过期望的线性性质求得：\n$$ \\mathbb{E}[\\Pi_i] = \\mathbb{E}[P_i(a_i R - b_i R^2) - c_i] = P_i a_i \\mathbb{E}[R] - P_i b_i \\mathbb{E}[R^2] - c_i $$\n用 $R$ 的矩表示：\n$$ \\mathbb{E}[\\Pi_i] = P_i a_i M_1 - P_i b_i M_2 - c_i $$\n\n利润的方差 $\\operatorname{Var}(\\Pi_i)$ 计算如下：\n$$ \\operatorname{Var}(\\Pi_i) = \\operatorname{Var}(P_i(a_i R - b_i R^2) - c_i) = P_i^2 \\operatorname{Var}(a_i R - b_i R^2) = P_i^2 \\operatorname{Var}(Y_i) $$\n其中 $Y_i = a_i R - b_i R^2$ 是产量。产量的方差 $\\operatorname{Var}(Y_i)$ 由下式给出：\n$$ \\operatorname{Var}(Y_i) = \\operatorname{Var}(a_i R - b_i R^2) = a_i^2 \\operatorname{Var}(R) + b_i^2 \\operatorname{Var}(R^2) - 2 a_i b_i \\operatorname{Cov}(R, R^2) $$\n所需的方差和协方差项可以用 $R$ 的矩表示：\n- $\\operatorname{Var}(R) = \\mathbb{E}[R^2] - (\\mathbb{E}[R])^2 = M_2 - M_1^2$\n- $\\operatorname{Var}(R^2) = \\mathbb{E}[(R^2)^2] - (\\mathbb{E}[R^2])^2 = M_4 - M_2^2$\n- $\\operatorname{Cov}(R, R^2) = \\mathbb{E}[R \\cdot R^2] - \\mathbb{E}[R]\\mathbb{E}[R^2] = M_3 - M_1 M_2$\n将这些代入 $\\operatorname{Var}(Y_i)$ 的表达式中：\n$$ \\operatorname{Var}(Y_i) = a_i^2 (M_2 - M_1^2) + b_i^2 (M_4 - M_2^2) - 2 a_i b_i (M_3 - M_1 M_2) $$\n这使得可以完整计算作物 $A$ 和 $B$ 的 $\\mathbb{E}[\\Pi_i]$ 和 $\\operatorname{Var}(\\Pi_i)$。\n\n**3. 决策阈值**\n如果作物 $A$ 的效用高于作物 $B$，主体就会选择作物 $A$：$U_A(\\lambda) > U_B(\\lambda)$。\n$$ \\mathbb{E}[\\Pi_A] - \\lambda \\operatorname{Var}(\\Pi_A) > \\mathbb{E}[\\Pi_B] - \\lambda \\operatorname{Var}(\\Pi_B) $$\n整理各项得：\n$$ \\mathbb{E}[\\Pi_A] - \\mathbb{E}[\\Pi_B] > \\lambda (\\operatorname{Var}(\\Pi_A) - \\operatorname{Var}(\\Pi_B)) $$\n令 $\\Delta E = \\mathbb{E}[\\Pi_A] - \\mathbb{E}[\\Pi_B]$ 和 $\\Delta V = \\operatorname{Var}(\\Pi_A) - \\operatorname{Var}(\\Pi_B)$。不等式变为 $\\Delta E > \\lambda \\Delta V$。设临界阈值为 $\\lambda_c = \\Delta E / \\Delta V$。偏好的作物取决于主体的 $\\lambda$ 相对于 $\\lambda_c$ 的大小，不等式的方向取决于 $\\Delta V$ 的符号：\n- 情况 1：$\\Delta V > 0$。不等式为 $\\lambda < \\lambda_c$。风险规避程度较低的主体（$\\lambda$ 较小）偏好作物 A。\n- 情况 2：$\\Delta V < 0$。不等式变为 $\\lambda > \\lambda_c$。风险规避程度较高的主体（$\\lambda$ 较大）偏好作物 A。\n- 情况 3：$\\Delta V = 0$。选择与 $\\lambda$ 无关。如果 $\\Delta E > 0$，所有主体选择 $A$ ($f_A=1$)。如果 $\\Delta E < 0$，所有主体选择 $B$ ($f_A=0$)。如果 $\\Delta E = 0$，主体无差异，按惯例 $f_A = 1/2$。\n\n**4. 比例 $f_A$ 的计算**\n比例 $f_A$ 是满足偏好条件的 $\\lambda$ 值集合的测度，该测度根据为 $\\lambda$ 指定的概率分布计算。\n\n- **对于 $\\lambda \\sim \\mathcal{U}([\\lambda_{\\min}, \\lambda_{\\max}])$**：\n比例 $f_A$ 是偏好 A 的区间与 $[\\lambda_{\\min}, \\lambda_{\\max}]$ 相交部分的长度，除以总区间长度 $(\\lambda_{\\max} - \\lambda_{\\min})$。\n  - 如果 $\\Delta V > 0$：$f_A = P(\\lambda < \\lambda_c) = \\frac{\\max(0, \\min(\\lambda_c, \\lambda_{\\max}) - \\lambda_{\\min})}{\\lambda_{\\max} - \\lambda_{\\min}}$。\n  - 如果 $\\Delta V < 0$：$f_A = P(\\lambda > \\lambda_c) = \\frac{\\max(0, \\lambda_{\\max} - \\max(\\lambda_c, \\lambda_{\\min}))}{\\lambda_{\\max} - \\lambda_{\\min}}$。\n\n- **对于在 $[0, \\lambda_{\\max}]$ 上形状参数为 $(\\alpha, \\beta)$ 的缩放贝塔分布 $\\lambda$**：\n$\\lambda$ 的累积分布函数 (CDF) 为 $F_{\\lambda}(v) = I_{v/\\lambda_{\\max}}(\\alpha, \\beta)$，其中 $I_z(\\alpha, \\beta)$ 是正则化不完全贝塔函数。$\\lambda$ 的支撑集为 $[0, \\lambda_{\\max}]$。设归一化阈值为 $z_c = \\lambda_c / \\lambda_{\\max}$。\n  - 如果 $\\Delta V > 0$：$f_A = P(\\lambda < \\lambda_c) = F_{\\lambda}(\\lambda_c)$。计算为 $I_{\\text{clip}(z_c, 0, 1)}(\\alpha, \\beta)$，其中 $\\text{clip}$ 将 $z_c$ 限制在区间 $[0, 1]$ 内。\n  - 如果 $\\Delta V < 0$：$f_A = P(\\lambda > \\lambda_c) = 1 - F_{\\lambda}(\\lambda_c)$。计算为 $1 - I_{\\text{clip}(z_c, 0, 1)}(\\alpha, \\beta)$。\n\n这些推导出的公式为计算任何给定有效参数集的 $f_A$ 提供了一个完整的算法。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import betainc\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        # Test case 1 (happy path, Uniform)\n        {\n            \"rain\": (0.5, 0.3),\n            \"crop_a\": (2.0, 0.15, 1.0, 0.2),\n            \"crop_b\": (1.6, 0.05, 1.1, 0.25),\n            \"dist\": {\"type\": \"uniform\", \"params\": (0.0, 2.0)},\n        },\n        # Test case 2 (boundary, equal variance, Uniform)\n        {\n            \"rain\": (0.3, 0.2),\n            \"crop_a\": (1.5, 0.08, 1.0, 0.1),\n            \"crop_b\": (1.5, 0.08, 1.0, 0.3),\n            \"dist\": {\"type\": \"uniform\", \"params\": (0.0, 3.0)},\n        },\n        # Test case 3 (edge case, negative threshold, Uniform)\n        {\n            \"rain\": (0.4, 0.6),\n            \"crop_a\": (1.8, 0.1, 2.0, 5.0),\n            \"crop_b\": (1.8, 0.1, 0.5, 0.0),\n            \"dist\": {\"type\": \"uniform\", \"params\": (0.0, 10.0)},\n        },\n        # Test case 4 (inequality flips, Beta on [0,1])\n        {\n            \"rain\": (0.7, 0.4),\n            \"crop_a\": (1.5, 0.07, 0.8, 0.05),\n            \"crop_b\": (1.5, 0.07, 2.0, 0.2),\n            \"dist\": {\"type\": \"beta\", \"params\": (1.0, 2.0, 5.0)},\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        f_a = compute_f_a(case)\n        results.append(f\"{f_a:.6f}\")\n    \n    print(f\"[{','.join(results)}]\")\n\ndef get_profit_stats(crop_params, moments):\n    \"\"\"\n    Calculates the expected profit and variance of profit for a single crop.\n    \n    Args:\n        crop_params (tuple): (a, b, P, c) for the crop.\n        moments (tuple): First four moments of the rainfall distribution (m1, m2, m3, m4).\n        \n    Returns:\n        tuple: (E_Pi, Var_Pi), the expected profit and variance of profit.\n    \"\"\"\n    a, b, P, c = crop_params\n    m1, m2, m3, m4 = moments\n\n    # Expected yield\n    E_Y = a * m1 - b * m2\n    \n    # Expected profit\n    E_Pi = P * E_Y - c\n\n    # Variance of yield\n    var_R = m2 - m1**2\n    var_R2 = m4 - m2**2\n    cov_R_R2 = m3 - m1 * m2\n    \n    var_Y = a**2 * var_R + b**2 * var_R2 - 2 * a * b * cov_R_R2\n    \n    # Variance of profit\n    var_Pi = P**2 * var_Y\n    \n    return E_Pi, var_Pi\n\ndef compute_f_a(case_params):\n    \"\"\"\n    Computes the steady-state fraction of farmers choosing crop A.\n    \n    Args:\n        case_params (dict): A dictionary containing all parameters for a test case.\n        \n    Returns:\n        float: The fraction of farmers choosing crop A.\n    \"\"\"\n    dist_type = case_params['dist']['type']\n    dist_params = case_params['dist']['params']\n    mu_r, sigma_r = case_params['rain']\n    crop_a_params = case_params['crop_a']\n    crop_b_params = case_params['crop_b']\n\n    # 1. Calculate moments of rainfall R\n    m1 = np.exp(mu_r + 0.5 * sigma_r**2)\n    m2 = np.exp(2 * mu_r + 2 * sigma_r**2)\n    m3 = np.exp(3 * mu_r + 4.5 * sigma_r**2)\n    m4 = np.exp(4 * mu_r + 8 * sigma_r**2)\n    moments = (m1, m2, m3, m4)\n\n    # 2. Compute profit statistics for each crop\n    E_Pi_A, Var_Pi_A = get_profit_stats(crop_a_params, moments)\n    E_Pi_B, Var_Pi_B = get_profit_stats(crop_b_params, moments)\n\n    # 3. Calculate differences in expectation (delta_E) and variance (delta_V)\n    delta_E = E_Pi_A - E_Pi_B\n    delta_V = Var_Pi_A - Var_Pi_B\n\n    # 4. Handle the case of zero variance difference\n    if np.isclose(delta_V, 0):\n        if delta_E > 0:\n            return 1.0\n        elif delta_E  0:\n            return 0.0\n        else: # delta_E is also zero, agents are indifferent\n            return 0.5\n\n    # 5. Compute the critical risk aversion threshold\n    lambda_c = delta_E / delta_V\n\n    # 6. Calculate the fraction f_A based on the distribution of lambda\n    if dist_type == 'uniform':\n        lambda_min, lambda_max = dist_params\n        range_len = lambda_max - lambda_min\n        if range_len = 0: return 0.0 if delta_E  0 else 1.0\n        \n        # Clip the threshold to the support of lambda\n        lambda_c_clipped = np.clip(lambda_c, lambda_min, lambda_max)\n        \n        if delta_V > 0: # Choose A if lambda  lambda_c\n            effective_length = lambda_c_clipped - lambda_min\n            return effective_length / range_len\n        else: # delta_V  0, choose A if lambda > lambda_c\n            effective_length = lambda_max - lambda_c_clipped\n            return effective_length / range_len\n\n    elif dist_type == 'beta':\n        lambda_max, alpha, beta = dist_params\n        \n        if lambda_max = 0: return 0.0 if delta_E  0 else 1.0\n        \n        # Normalize threshold to the standard Beta domain [0, 1]\n        z_c = lambda_c / lambda_max\n        z_c_clipped = np.clip(z_c, 0, 1)\n\n        cdf_at_threshold = betainc(alpha, beta, z_c_clipped)\n\n        if delta_V > 0: # Choose A if lambda  lambda_c\n            return cdf_at_threshold\n        else: # delta_V  0, choose A if lambda > lambda_c\n            return 1.0 - cdf_at_threshold\n            \n    return 0.0 # Should not be reached\n\nif __name__ == '__main__':\n    solve()\n```"
        },
        {
            "introduction": "基于主体的模型通常用于表示由空间或网络结构介導的交互系统。这项练习  要求您构建一个灌溉网络的模拟，该网络被建模为一个有向無環图。您的任务是实现水资源守恒的物理定律以及复杂、基于规则的水量分配逻辑，这一逻辑受到主体控制的闸门和优先权的影响。这项实践为您在受约束、空间显式的环境中模拟资源流提供了必要的动手经验。",
            "id": "3860567",
            "problem": "考虑一个有向无环图，代表一个灌溉网络，其节点为 $\\mathcal{N}$，边为 $\\mathcal{E}$。每条边 $(i \\rightarrow j) \\in \\mathcal{E}$ 代表一条从上游节点 $i$ 到下游节点 $j$ 的运河。代理人控制边上的闸门开启度，从而影响有效吞吐量。您必须实现一个程序，该程序在代理人控制的闸门设置下，根据物理和社会约束条件计算水流分配，并报告指定测试用例的量化结果。\n\n基本原理和约束条件：\n- 质量守恒（连续性）：对于每个节点 $i \\in \\mathcal{N}$，设 $S_i$ 为外源入流量（源项），$I_i$ 为从上游边流入的总流量，$D_i$ 为当地环境需水量，$L_i \\in [0,1)$ 为一个无量纲的损失系数，代表因渗透和蒸发导致的流出量减少。节点 $i$ 处的可用水量为 $A_i = S_i + I_i$。节点 $i$ 处得到满足的需水量为 $E_i = \\min(D_i, A_i)$，扣除损失前剩余的可分配水量为 $R_i = A_i - E_i$。可用于下游分配的预算水量（应用损失后）为 $B_i = (1 - L_i) R_i$。\n- 容量与控制：每条边 $e \\in \\mathcal{E}$ 的额定容量为 $C_e$（单位：$m^3/s$）。一个由代理人控制的闸门开启度分数 $g_e \\in [0,1]$ 将有效容量修正为 $C^{\\text{eff}}_e = g_e C_e$。每条边 $e$ 的流量 $F_e$ 必须满足 $0 \\leq F_e \\leq C^{\\text{eff}}_e$。\n- 公平性权重：从节点 $i$ 出发的每条边 $e$ 都有一个非负的优先级权重 $w_e \\geq 0$，用于控制从节点 $i$ 出发各条出边之间的比例分配。当 $B_i$ 小于从 $i$ 出发的各条出边的有效容量之和时，从 $i$ 出发的流量应按 $\\{w_e\\}$ 成比例分配，同时遵守容量限制；当 $B_i$ 超过有效容量之和时，各条边将以其有效容量饱和，任何剩余的 $B_i$ 不会输送到下游（它在本地溢出，不用于满足下游的需水）。\n- 拓扑计算：由于该图是无环的，分配可以按拓扑顺序进行，从源头开始向下游推进，从而确保在计算 $A_i$、$E_i$、$R_i$、$B_i$ 及出边分配时，$I_i$ 是已知的。\n\n节点分配要求：\n- 对于每个节点 $i$，设 $\\mathcal{E}^+_i$ 表示出边集合，其有效容量为 $\\{C^{\\text{eff}}_e\\}$，权重为 $\\{w_e\\}$。将 $B_i$ 在 $\\mathcal{E}^+_i$ 上进行分配，使得：\n    1. $\\sum_{e \\in \\mathcal{E}^+_i} F_e = \\min\\left(B_i, \\sum_{e \\in \\mathcal{E}^+_i} C^{\\text{eff}}_e\\right)$，\n    2. 对所有 $e \\in \\mathcal{E}^+_i$ 都有 $0 \\leq F_e \\leq C^{\\text{eff}}_e$，\n    3. 如果 $\\sum_{e \\in \\mathcal{E}^+_i} C^{\\text{eff}}_e \\ge B_i$，则在未饱和的边中，$F_e$ 的比率与 $w_e$ 成正比。\n\n您的程序必须在每个节点上实现一个与上述规则一致、尊重容量的加权比例分配方案，仅使用提供的数值输入和基本原理。在计算完所有节点的流量和已满足的需水量后，输出每个测试用例的总未满足需水量，其定义为 $\\sum_{i \\in \\mathcal{N}} (D_i - E_i)$，单位为 $m^3/s$。\n\n图与参数化：\n- 节点：$\\mathcal{N} = \\{0, 1, 2, 3\\}$。\n- 边 $\\mathcal{E}$ 及其额定容量 $C_e$（单位 $m^3/s$）、代理人控制的闸门开启度 $g_e$（无量纲）和优先级权重 $w_e$（无量纲）如下：\n    - 边 $e_0$：$0 \\rightarrow 1$，$C_{e_0} = 5$，$w_{e_0} = 1.0$。\n    - 边 $e_1$：$0 \\rightarrow 2$，$C_{e_1} = 6$，$w_{e_1} = 2.0$。\n    - 边 $e_2$：$1 \\rightarrow 3$，$C_{e_2} = 4$，$w_{e_2} = 1.0$。\n    - 边 $e_3$：$2 \\rightarrow 3$，$C_{e_3} = 3$，$w_{e_3} = 1.0$。\n- 损失系数：$L_0 = 0.1$，$L_1 = 0.05$，$L_2 = 0.05$，$L_3 = 0$。\n- 该图为无环图，其拓扑顺序与从上游到下游的遍历顺序 $0 \\rightarrow \\{1,2\\} \\rightarrow 3$ 一致。\n\n测试套件：\n- 案例 1 (理想路径)：外源入流量 $S_0 = 10, S_1 = 0, S_2 = 0, S_3 = 0$；需水量 $D_0 = 2, D_1 = 3, D_2 = 1, D_3 = 4$；闸门开启度 $g_{e_0} = 0.8, g_{e_1} = 0.5, g_{e_2} = 1.0, g_{e_3} = 1.0$。\n- 案例 2 (边界情况，含关闭的闸门)：外源入流量 $S_0 = 10, S_1 = 0, S_2 = 0, S_3 = 0$；需水量 $D_0 = 2, D_1 = 3, D_2 = 1, D_3 = 4$；闸门开启度 $g_{e_0} = 0.8, g_{e_1} = 0.0, g_{e_2} = 1.0, g_{e_3} = 1.0$。\n- 案例 3 (边缘情况，供应有限)：外源入流量 $S_0 = 3, S_1 = 0, S_2 = 0, S_3 = 0$；需水量 $D_0 = 1.5, D_1 = 2, D_2 = 1, D_3 = 4$；闸门开启度 $g_{e_0} = 0.8, g_{e_1} = 0.5, g_{e_2} = 1.0, g_{e_3} = 1.0$。\n\n角度单位不适用。所有报告的量都必须以 $m^3/s$ 为单位。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[\\text{结果}_1,\\text{结果}_2,\\text{结果}_3]$），每个条目是相应案例的总未满足需水量，以 $m^3/s$ 为单位的浮点数表示。",
            "solution": "该问题要求在一个模拟的灌溉网络中计算水量分配及由此产生的未满足需水量。该网络被建模为一个有向无环图 (DAG)，这允许按照指定的拓扑顺序进行逐个节点的顺序计算。解决方案是通过在每个节点应用质量守恒原理和受容量约束的加权比例分配规则得出的。\n\n### 基本原理和算法\n\n计算过程是按指定的拓扑顺序处理每个节点：$0 \\rightarrow 1 \\rightarrow 2 \\rightarrow 3$。对于每个节点 $i$，会计算一个水量预算，然后根据物理和社会约束条件进行分配。\n\n**1. 每个节点的质量守恒：**\n对于任何给定节点 $i \\in \\mathcal{N}$，水量平衡计算如下：\n- **总入流量 ($I_i$)：** 所有入边流量的总和。对于像节点0这样的源节点，$I_0 = 0$。对于其他节点，$I_i = \\sum_{j \\to i} F_{j \\to i}$，其中 $F_{j \\to i}$ 是从节点 $j$ 到节点 $i$ 的边上的流量。\n- **可用水量 ($A_i$)：** 外源入流量 $S_i$ 和总入流量 $I_i$ 的总和：$A_i = S_i + I_i$。\n- **已满足的需水量 ($E_i$)：** 当地环境需水量 $D_i$ 被可用水量尽可能满足：$E_i = \\min(D_i, A_i)$。该节点的未满足需水量为 $D_i - E_i$。\n- **剩余可分配水量 ($R_i$)：** 满足当地需水量后剩余的水量：$R_i = A_i - E_i$。\n- **下游预算水量 ($B_i$)：** 这是在考虑本地损失（如渗透、蒸发）后可用于分配给下游节点的水量，由损失系数 $L_i$ 给出：$B_i = (1 - L_i) R_i$。\n\n**2. 下游流量分配：**\n预算水量 $B_i$ 在从节点 $i$ 出发的出边集合（表示为 $\\mathcal{E}^+_i$）中进行分配。$\\mathcal{E}^+_i$ 中的每条边 $e$ 都有一个有效容量 $C^{\\text{eff}}_e = g_e C_e$，其中 $g_e$ 是代理人控制的闸门开启度，以及一个优先级权重 $w_e$。离开节点 $i$ 的总流量受其出边总有效容量 $\\sum_{e \\in \\mathcal{E}^+_i} C^{\\text{eff}}_e$ 的约束。\n从节点 $i$ 分配的总流量为 $\\sum_{e \\in \\mathcal{E}^+_i} F_e = \\min\\left(B_i, \\sum_{e \\in \\mathcal{E}^+_i} C^{\\text{eff}}_e\\right)$。\n该总流量在各条边上的分配遵循一个尊重容量的加权比例方案：\n\n- **超额供应情况：** 如果预算水量 $B_i$ 大于或等于总出边有效容量（$\\sum C^{\\text{eff}}_e$），则每条出边 $e$ 都以其有效容量饱和：$F_e = C^{\\text{eff}}_e$。任何剩余的预算（$B_i - \\sum C^{\\text{eff}}_e$）被视为溢出，不会输送到下游。\n- **供应不足情况：** 如果预算水量 $B_i$ 小于总出边有效容量，则流量按权重 $\\{w_e\\}$ 成比例分配，同时受容量约束 $\\{C^{\\text{eff}}_e\\}$ 的限制。这通过一个迭代算法来处理：\n    1.  将活动边集合初始化为从节点 $i$ 出发的所有出边。\n    2.  在一个循环中，使用剩余的预算和活动边：\n        a. 为每个活动边计算一个与其权重成比例的临时流量。\n        b. 如果任何临时流量超过其边的有效容量，该边被视为“饱和候选边”。\n        c. 如果有饱和候选边，则将其流量固定为其有效容量，从预算中减去这些流量，将它们从活动边集合中移除，并用减少后的预算和剩余的边重复此过程。\n        d. 如果没有边的临时流量超过其容量，则将剩余预算按比例分配给剩余的活动边，该节点的处理过程完成。\n\n**3. 总未满足需水量：**\n在按拓扑顺序处理完所有节点并确定所有流量和已满足的需水量之后，主要输出是整个网络的总未满足需水量，计算公式为 $\\sum_{i \\in \\mathcal{N}} (D_i - E_i)$。\n\n### 计算示例：案例 1\n\n**参数：**\n- 外源入流量：$S = \\{10, 0, 0, 0\\}$ $m^3/s$\n- 需水量：$D = \\{2, 3, 1, 4\\}$ $m^3/s$\n- 闸门开启度：$g = \\{g_{e_0}=0.8, g_{e_1}=0.5, g_{e_2}=1.0, g_{e_3}=1.0\\}$\n- 额定容量：$C = \\{C_{e_0}=5, C_{e_1}=6, C_{e_2}=4, C_{e_3}=3\\}$ $m^3/s$\n- 权重：$w = \\{w_{e_0}=1.0, w_{e_1}=2.0, w_{e_2}=1.0, w_{e_3}=1.0\\}$\n- 损失系数：$L = \\{0.1, 0.05, 0.05, 0\\}$\n\n**步骤 0：预计算**\n- 有效容量：\n  - $C^{\\text{eff}}_{e_0} = 0.8 \\times 5 = 4.0$ $m^3/s$\n  - $C^{\\text{eff}}_{e_1} = 0.5 \\times 6 = 3.0$ $m^3/s$\n  - $C^{\\text{eff}}_{e_2} = 1.0 \\times 4 = 4.0$ $m^3/s$\n  - $C^{\\text{eff}}_{e_3} = 1.0 \\times 3 = 3.0$ $m^3/s$\n\n**步骤 1：处理节点 0**\n- $I_0 = 0$。$A_0 = S_0 + I_0 = 10 + 0 = 10$。\n- $E_0 = \\min(D_0, A_0) = \\min(2, 10) = 2$。节点 0 的未满足需水量为 0。\n- $R_0 = A_0 - E_0 = 10 - 2 = 8$。\n- $B_0 = (1 - L_0) R_0 = (1 - 0.1) \\times 8 = 7.2$。\n- 将 $B_0=7.2$ 分配给边 $e_0$ ($0 \\to 1$) 和 $e_1$ ($0 \\to 2$)。\n- 从节点 0 出发的总出边容量为 $C^{\\text{eff}}_{e_0} + C^{\\text{eff}}_{e_1} = 4.0 + 3.0 = 7.0$。\n- 由于 $B_0=7.2  7.0$ (超额供应)，边被饱和。\n- $F_{e_0} = 4.0$。$F_{e_1} = 3.0$。有 $7.2 - 7.0 = 0.2$ $m^3/s$ 的水量溢出。\n\n**步骤 2：处理节点 1**\n- $I_1 = F_{e_0} = 4.0$。$A_1 = S_1 + I_1 = 0 + 4.0 = 4.0$。\n- $E_1 = \\min(D_1, A_1) = \\min(3, 4.0) = 3$。节点 1 的未满足需水量为 0。\n- $R_1 = A_1 - E_1 = 4.0 - 3 = 1.0$。\n- $B_1 = (1 - L_1) R_1 = (1 - 0.05) \\times 1.0 = 0.95$。\n- 将 $B_1=0.95$ 分配给边 $e_2$ ($1 \\to 3$)。\n- $F_{e_2} = \\min(B_1, C^{\\text{eff}}_{e_2}) = \\min(0.95, 4.0) = 0.95$。\n\n**步骤 3：处理节点 2**\n- $I_2 = F_{e_1} = 3.0$。$A_2 = S_2 + I_2 = 0 + 3.0 = 3.0$。\n- $E_2 = \\min(D_2, A_2) = \\min(1, 3.0) = 1$。节点 2 的未满足需水量为 0。\n- $R_2 = A_2 - E_2 = 3.0 - 1 = 2.0$。\n- $B_2 = (1 - L_2) R_2 = (1 - 0.05) \\times 2.0 = 1.9$。\n- 将 $B_2=1.9$ 分配给边 $e_3$ ($2 \\to 3$)。\n- $F_{e_3} = \\min(B_2, C^{\\text{eff}}_{e_3}) = \\min(1.9, 3.0) = 1.9$。\n\n**步骤 4：处理节点 3**\n- $I_3 = F_{e_2} + F_{e_3} = 0.95 + 1.9 = 2.85$。\n- $A_3 = S_3 + I_3 = 0 + 2.85 = 2.85$。\n- $E_3 = \\min(D_3, A_3) = \\min(4, 2.85) = 2.85$。节点 3 的未满足需水量为 $4 - 2.85 = 1.15$。\n- 节点 3 是一个没有出边的汇点。\n\n**步骤 5：最终计算**\n- 总未满足需水量 = $\\sum (D_i - E_i) = 0 (\\text{节点 } 0) + 0 (\\text{节点 } 1) + 0 (\\text{节点 } 2) + 1.15 (\\text{节点 } 3) = 1.15$ $m^3/s$。\n对所有测试案例应用此相同程序以获得各自的结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef allocate_proportional_flow(budget, capacities, weights):\n    \"\"\"\n    Allocates a budget of water flow across outgoing edges based on a\n    capacity-constrained weighted proportional rule (iterative water-filling).\n\n    Args:\n        budget (float): The total available water budget to allocate.\n        capacities (dict): A dictionary mapping edge index to its effective capacity.\n        weights (dict): A dictionary mapping edge index to its priority weight.\n\n    Returns:\n        dict: A dictionary mapping edge index to its allocated flow.\n    \"\"\"\n    if not capacities:\n        return {}\n\n    total_capacity = sum(capacities.values())\n    if budget >= total_capacity:\n        return capacities.copy()\n\n    flows = {edge: 0.0 for edge in capacities}\n    \n    # Use copies for mutable operations\n    remaining_budget = budget\n    active_capacities = capacities.copy()\n    active_edges = list(capacities.keys())\n    \n    while remaining_budget > 1e-9 and active_edges:\n        current_total_weight = sum(weights[edge] for edge in active_edges)\n        \n        if current_total_weight  1e-9:\n            break\n\n        # Calculate the water level 'h' that would be achieved if resources were unlimited\n        # h = budget / total_weight. Then flow_e = h * weight_e\n        # The bottleneck is the edge with the smallest capacity-to-weight ratio\n        min_ratio = float('inf')\n        for edge in active_edges:\n            if weights[edge] > 1e-9:\n                ratio = active_capacities[edge] / weights[edge]\n                min_ratio = min(min_ratio, ratio)\n        \n        # Budget required to bring all active edges to this minimum ratio\n        budget_to_saturate_next = min_ratio * current_total_weight\n\n        if remaining_budget = budget_to_saturate_next:\n            # No edge saturates with the remaining budget. Distribute and finish.\n            for edge in active_edges:\n                flows[edge] += remaining_budget * weights[edge] / current_total_weight\n            remaining_budget = 0.0\n            break\n        else:\n            # At least one edge saturates. Allocate up to the saturation point.\n            for edge in active_edges:\n                flows[edge] += min_ratio * weights[edge]\n            \n            remaining_budget -= budget_to_saturate_next\n            \n            # Update capacities and find newly saturated edges to remove\n            edges_to_remove = []\n            for edge in active_edges:\n                active_capacities[edge] -= min_ratio * weights[edge]\n                if active_capacities[edge]  1e-9:\n                    edges_to_remove.append(edge)\n            \n            active_edges = [e for e in active_edges if e not in edges_to_remove]\n    \n    return flows\n\ndef solve():\n    # --- Static problem definition ---\n    nodes = [0, 1, 2, 3]\n    edges = [(0, 1), (0, 2), (1, 3), (2, 3)]\n    out_edges = {i: [] for i in nodes}\n    in_edges = {i: [] for i in nodes}\n    for i, (u, v) in enumerate(edges):\n        out_edges[u].append(i)\n        in_edges[v].append(i)\n    topological_order = [0, 1, 2, 3]\n    C_nominal = np.array([5.0, 6.0, 4.0, 3.0])\n    weights = np.array([1.0, 2.0, 1.0, 1.0])\n    L = np.array([0.1, 0.05, 0.05, 0.0])\n\n    # --- Test Cases ---\n    test_cases = [\n        {\"S\": np.array([10.0, 0.0, 0.0, 0.0]), \"D\": np.array([2.0, 3.0, 1.0, 4.0]), \"g\": np.array([0.8, 0.5, 1.0, 1.0])},\n        {\"S\": np.array([10.0, 0.0, 0.0, 0.0]), \"D\": np.array([2.0, 3.0, 1.0, 4.0]), \"g\": np.array([0.8, 0.0, 1.0, 1.0])},\n        {\"S\": np.array([3.0, 0.0, 0.0, 0.0]), \"D\": np.array([1.5, 2.0, 1.0, 4.0]), \"g\": np.array([0.8, 0.5, 1.0, 1.0])}\n    ]\n\n    results = []\n    for case in test_cases:\n        S, D, g = case[\"S\"], case[\"D\"], case[\"g\"]\n        C_eff = C_nominal * g\n        F = np.zeros(len(edges))\n        E = np.zeros(len(nodes))\n        \n        for i in topological_order:\n            # 1. Calculate water available at node i\n            inflow_I = sum(F[edge_idx] for edge_idx in in_edges[i])\n            available_A = S[i] + inflow_I\n            \n            # 2. Satisfy local demand\n            satisfied_E = min(D[i], available_A)\n            E[i] = satisfied_E\n            \n            # 3. Calculate remaining water and budget for downstream\n            remaining_R = available_A - satisfied_E\n            budget_B = (1 - L[i]) * remaining_R\n            \n            # 4. Allocate budget to outgoing edges\n            node_out_edges_indices = out_edges[i]\n            if node_out_edges_indices:\n                sub_capacities = {e: C_eff[e] for e in node_out_edges_indices}\n                sub_weights = {e: weights[e] for e in node_out_edges_indices}\n                \n                allocated_flows = allocate_proportional_flow(budget_B, sub_capacities, sub_weights)\n                \n                for edge_idx, flow_val in allocated_flows.items():\n                    F[edge_idx] = flow_val\n        \n        total_unmet_demand = np.sum(D - E)\n        results.append(round(total_unmet_demand, 6))\n        \n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "ABM的一个关键优势在于其能够模拟随时间学习并改变行为的适应性主体。在这项高级实践  中，您将使用强化学习框架来探究主体如何学会在资源保护与开发之间进行权衡。核心挑战在于找到一个自洽的均衡点，在该均衡点上，主体的集体学习行为与环境状态动态耦合，从而突显出作为复杂人与环境系统标志的共同演化反馈机制。",
            "id": "3860641",
            "problem": "考虑一个嵌入在单一资源环境中的相同智能体种群。在每个离散时间步，每个智能体都面临一个二元选择：保护（$C$）与开采（$E$）。环境由一个归一化的资源存量 $s_t \\in [0,1]$ 表示，该存量根据由开采引起的离散时间平均场逻辑斯蒂补充和线性耗竭进行演化：\n$$\ns_{t+1} = s_t + \\rho (1 - s_t) - \\xi \\, \\pi_E \\, s_t,\n$$\n其中 $\\rho  0$ 是内在补充率，$\\xi \\ge 0$ 是开采影响系数，$\\pi_E \\in [0,1]$ 是种群中选择开采的稳态概率（平均场近似假设每个智能体相对于种群来说都小到可以忽略不计）。\n\n每个智能体接收依赖于当前存量 $s_t$ 的即时奖励：\n$$\nr_C(s_t) = g \\, s_t, \\qquad r_E(s_t) = f \\, s_t - c,\n$$\n其中 $f  0$ 和 $g \\ge 0$ 是特定动作的收益系数，$c \\ge 0$ 是以效用单位衡量的外部化开采成本。\n\n智能体使用在策略的预期状态-动作-奖励-状态-动作（Expected-SARSA）更新和 softmax 动作选择来学习动作价值。令 $Q_C$ 和 $Q_E$ 表示动作价值的估计值。策略是温度为 $\\tau  0$ 的 softmax：\n$$\n\\pi_a = \\frac{\\exp(Q_a / \\tau)}{\\exp(Q_C / \\tau) + \\exp(Q_E / \\tau)}, \\quad a \\in \\{C,E\\},\n$$\n对于单个稳态，Expected-SARSA 的不动点一致性得出\n$$\nQ_a = r_a + \\gamma \\sum_{b \\in \\{C,E\\}} \\pi_b Q_b,\n$$\n其中 $\\gamma \\in [0,1)$ 是折扣因子。在稳态下，资源存量 $s^*$ 和开采概率 $\\pi_E$ 必须与上述定义联合自洽。\n\n仅从上述核心定义和定律出发，推导在温度为 $\\tau$ 的 softmax 策略下，稳态开采概率 $\\pi_E$ 的自洽标量不动点方程，并用参数 $(\\tau,\\rho,\\xi,f,g,c,\\gamma)$ 表示。实现一个算法，为每组参数计算唯一的稳态解 $\\pi_E \\in [0,1]$，并以浮点数形式生成最终的开采概率。在输出中无需显式计算 $Q_C$、$Q_E$ 或 $s^*$，但你的推导必须证明最终算法形式的合理性。\n\n除奖励以效用单位衡量外，所有量均为无量纲；请将最终的开采概率报告为无单位的小数。不涉及角度。\n\n你的程序必须解决以下测试套件，该套件旨在测试典型行为、低温和高温极限以及环境边缘情况。对于每种情况，计算稳态开采概率 $\\pi_E$ 并四舍五入到六位小数：\n\n- 情况 A（中等温度，基准环境）：$\\tau = 0.25$, $\\rho = 0.6$, $\\xi = 0.8$, $f = 1.0$, $g = 0.4$, $c = 0.2$, $\\gamma = 0.9$。\n- 情况 B（近确定性策略）：$\\tau = 10^{-3}$, $\\rho = 0.6$, $\\xi = 0.8$, $f = 1.0$, $g = 0.4$, $c = 0.2$, $\\gamma = 0.9$。\n- 情况 C（高温，近随机策略）：$\\tau = 100.0$, $\\rho = 0.6$, $\\xi = 0.8$, $f = 1.0$, $g = 0.4$, $c = 0.2$, $\\gamma = 0.9$。\n- 情况 D（开采对资源无影响）：$\\tau = 0.5$, $\\rho = 0.6$, $\\xi = 0.0$, $f = 1.0$, $g = 0.4$, $c = 0.2$, $\\gamma = 0.9$。\n- 情况 E（高开采成本有利于保护）：$\\tau = 0.25$, $\\rho = 0.6$, $\\xi = 0.8$, $f = 1.0$, $g = 0.4$, $c = 0.8$, $\\gamma = 0.9$。\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，[$x_1,x_2,x_3,x_4,x_5$]），每个 $x_i$ 等于相应情况下的稳态开采概率，四舍五入到六位小数。",
            "solution": "我们从基于智能体的学习和环境动力学定义开始。存在一个由资源存量 $s_t \\in [0,1]$ 表征的单一稳态环境状态，其平均场演化如下：\n$$\ns_{t+1} = s_t + \\rho (1 - s_t) - \\xi \\, \\pi_E \\, s_t,\n$$\n其中 $\\rho  0$ 是补充率，$\\xi \\ge 0$ 是开采对存量的影响，$\\pi_E$ 是稳态开采概率。在稳态下，令 $s_{t+1} = s_t = s^*$，解出 $s^*$：\n$$\n0 = \\rho (1 - s^*) - \\xi \\, \\pi_E \\, s^*, \\quad \\Rightarrow \\quad s^* = \\frac{\\rho}{\\rho + \\xi \\pi_E}.\n$$\n\n智能体接收依赖于 $s_t$ 的即时奖励：\n$$\nr_C(s) = g s, \\qquad r_E(s) = f s - c,\n$$\n其中 $f  0$ 和 $g \\ge 0$ 是特定动作的收益，$c \\ge 0$ 是以效用单位衡量的开采成本。\n\n智能体采用预期状态-动作-奖励-状态-动作（Expected-SARSA）学习，其动作价值为 $Q_C,Q_E$，策略为温度为 $\\tau$ 的 softmax：\n$$\n\\pi_a = \\frac{\\exp(Q_a/\\tau)}{\\exp(Q_C/\\tau) + \\exp(Q_E/\\tau)}, \\quad a \\in \\{C,E\\},\n$$\n对于单个稳态，Expected-SARSA 的不动点一致性得出：\n$$\nQ_a = r_a + \\gamma \\sum_{b \\in \\{C,E\\}} \\pi_b Q_b, \\quad \\gamma \\in [0,1).\n$$\n\n定义软价值\n$$\nV = \\sum_{b \\in \\{C,E\\}} \\pi_b Q_b.\n$$\n代入 Expected-SARSA 形式来表示 $V$：\n$$\nV = \\sum_b \\pi_b \\left(r_b + \\gamma V\\right) = \\sum_b \\pi_b r_b + \\gamma V.\n$$\n解出 $V$：\n$$\nV = \\frac{\\sum_b \\pi_b r_b}{1 - \\gamma}.\n$$\n那么每个动作价值是\n$$\nQ_a = r_a + \\gamma V = r_a + \\gamma \\frac{\\sum_b \\pi_b r_b}{1 - \\gamma}.\n$$\n\n考虑进入 softmax 的动作价值之差：\n$$\n\\Delta \\equiv Q_E - Q_C = \\left(r_E + \\gamma \\frac{\\sum_b \\pi_b r_b}{1 - \\gamma}\\right) - \\left(r_C + \\gamma \\frac{\\sum_b \\pi_b r_b}{1 - \\gamma}\\right) = r_E - r_C.\n$$\n因此，使用 Expected-SARSA 和 softmax 的学习动态所产生的稳态策略差异仅由即时奖励差异决定。这种抵消在单一稳态下是直观的，因为预期的未来回报通过 $\\gamma V$ 对两个动作价值的贡献是相等的。\n\n使用两个动作的 softmax 形式，开采概率是 $Q_E - Q_C$ 的逻辑斯蒂函数：\n$$\n\\pi_E = \\frac{1}{1 + \\exp\\left(-\\frac{Q_E - Q_C}{\\tau}\\right)} = \\frac{1}{1 + \\exp\\left(-\\frac{r_E - r_C}{\\tau}\\right)}.\n$$\n代入 $r_E(s^*) = f s^* - c$ 和 $r_C(s^*) = g s^*$：\n$$\nr_E - r_C = (f - g) s^* - c.\n$$\n使用稳态存量 $s^* = \\frac{\\rho}{\\rho + \\xi \\pi_E}$，我们得到关于 $\\pi_E$ 的标量不动点方程：\n$$\n\\pi_E = \\frac{1}{1 + \\exp\\left(-\\frac{(f - g)\\, \\frac{\\rho}{\\rho + \\xi \\pi_E} - c}{\\tau}\\right)}.\n$$\n\n对于 $\\rho  0$、$\\xi \\ge 0$、$f  0$、$g \\ge 0$、$c \\ge 0$ 和 $\\tau  0$，此方程在区间 $\\pi_E \\in [0,1]$ 上是良定义的。方程右侧是连续的，并且严格有界于 $(0,1)$ 内。定义函数\n$$\nh(\\pi) = \\frac{1}{1 + \\exp\\left(-\\frac{(f - g)\\, \\frac{\\rho}{\\rho + \\xi \\pi} - c}{\\tau}\\right)}.\n$$\n我们寻求 $\\pi^*$ 使得 $h(\\pi^*) = \\pi^*$。考虑 $g(\\pi) = h(\\pi) - \\pi$。那么 $g(0) = h(0) - 0  0$，因为 $h(0) \\in (0,1)$。同样，$g(1) = h(1) - 1  0$，因为 $h(1) \\in (0,1)$。根据介值定理，在 $[0,1]$ 中至少存在一个根。在所述参数范围内，$h(\\pi)$ 的单调性意味着唯一性，因为增加 $\\pi$ 会削弱存量 $s^*$，并通常减少 $(f - g) s^* - c$，使得当 $(f - g) \\rho  0$ 和 $\\xi \\ge 0$ 时，$h(\\pi)$ 是非增的。因此，存在一个唯一的不动点，并且可以通过在 $[0,1]$ 上对 $g(\\pi)$ 使用稳健的区间求根法找到。\n\n为给定参数集计算 $\\pi_E$ 的算法步骤：\n1. 定义逻辑斯蒂函数 $\\sigma(x) = \\frac{1}{1 + e^{-x}}$。\n2. 对于给定的 $(\\tau,\\rho,\\xi,f,g,c)$，定义 $h(\\pi) = \\sigma\\left(\\frac{(f - g)\\, \\frac{\\rho}{\\rho + \\xi \\pi} - c}{\\tau}\\right)$ 和 $g(\\pi) = h(\\pi) - \\pi$。\n3. 在 $[0,1]$ 上对 $g(\\pi)$ 使用区间求根法，以获得唯一的不动点 $\\pi^*$。\n4. 将 $\\pi^*$ 四舍五入到六位小数。\n5. 对每个测试用例重复此过程。\n\n请注意，由于单一稳态和 Expected-SARSA 结构，折扣因子 $\\gamma$ 从开采概率的计算中抵消了；softmax 仅依赖于 $Q_E - Q_C = r_E - r_C$。尽管如此，$\\gamma$ 仍然是基础推导的一部分。\n\n将此方法应用于问题中指定的测试套件。对于每种情况，程序通过求解不动点方程来计算稳态开采概率 $\\pi_E$，并以方括号内的单个逗号分隔列表形式返回四舍五入后的值。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import brentq\n\ndef steady_state_exploitation_probability(tau, rho, xi, f, g, c, gamma):\n    \"\"\"\n    Compute steady-state exploitation probability pi_E under a softmax policy\n    with temperature tau, in a mean-field single-state environment with\n    logistic replenishment and linear depletion from exploitation.\n\n    Although gamma is part of the RL setup, pi_E depends only on reward\n    differences in the single stationary state and thus is independent of gamma.\n    \"\"\"\n    # Logistic function\n    def logistic(x):\n        # Use stable computation\n        # For large negative x, exp(-x) may overflow; handle with np.where\n        return 1.0 / (1.0 + np.exp(-x))\n\n    # Define the fixed-point function g(pi) = h(pi) - pi\n    def g_fun(pi):\n        # Steady-state stock s* = rho / (rho + xi * pi)\n        denom = rho + xi * pi\n        # Avoid division by zero; denom >= rho > 0 under given parameters\n        s_star = rho / denom\n        # Reward difference delta = (f - g) * s* - c\n        delta = (f - g) * s_star - c\n        # Softmax exploitation probability under two actions: logistic(delta / tau)\n        h_pi = logistic(delta / tau)\n        return h_pi - pi\n\n    # Root finding on interval [0,1]; g(0) > 0 and g(1)  0 typically\n    # To ensure robustness, clip extreme tau values are still handled by brentq.\n    pi_star = brentq(g_fun, 0.0, 1.0, maxiter=1000, rtol=1e-12)\n    return pi_star\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (tau, rho, xi, f, g, c, gamma)\n    test_cases = [\n        (0.25, 0.6, 0.8, 1.0, 0.4, 0.2, 0.9),   # Case A\n        (1e-3, 0.6, 0.8, 1.0, 0.4, 0.2, 0.9),   # Case B\n        (100.0, 0.6, 0.8, 1.0, 0.4, 0.2, 0.9),  # Case C\n        (0.5, 0.6, 0.0, 1.0, 0.4, 0.2, 0.9),    # Case D\n        (0.25, 0.6, 0.8, 1.0, 0.4, 0.8, 0.9),   # Case E\n    ]\n\n    results = []\n    for case in test_cases:\n        tau, rho, xi, f, g, c, gamma = case\n        pi_e = steady_state_exploitation_probability(tau, rho, xi, f, g, c, gamma)\n        results.append(f\"{pi_e:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}