{
    "hands_on_practices": [
        {
            "introduction": "We begin with a cornerstone technique for analyzing numerical stability: the von Neumann (or Fourier) stability analysis. This method allows us to understand how a numerical scheme amplifies or damps different Fourier modes of the solution. By applying it to the linear advection equation, a fundamental model for transport phenomena in the atmosphere and oceans, we can derive the famous Courant–Friedrichs–Lewy (CFL) condition, a critical stability constraint for many explicit time-stepping schemes. ",
            "id": "3950212",
            "problem": "Consider the one-dimensional linear advection equation $u_{t} + a\\,u_{x} = 0$ with constant advection speed $a > 0$, which serves as a canonical transport model in Computational Fluid Dynamics (CFD). The domain is taken to be either periodic or infinite, and the spatial grid is uniform with nodes $x_{j} = j\\,\\Delta x$ for integer $j$ and time levels $t^{n} = n\\,\\Delta t$ for integer $n$. Define the Courant–Friedrichs–Lewy (CFL) number $\\nu = a\\,\\Delta t/\\Delta x$. Discretize the equation with a first-order upwind spatial difference (appropriate for $a>0$) and a forward-Euler time integration, forming the explicit scheme that updates $u_{j}^{n}$ to $u_{j}^{n+1}$. Starting from the linear advection model and the definitions of the forward difference in time and the upwind difference in space, perform a von Neumann (Fourier) stability analysis by substituting a single Fourier mode $u_{j}^{n} = \\hat{u}^{n}\\,\\exp(i\\,j\\,\\theta)$, where $i = \\sqrt{-1}$ and $\\theta$ is the nondimensional wavenumber. Derive the amplification factor $G(\\theta)$ defined by $\\hat{u}^{n+1} = G(\\theta)\\,\\hat{u}^{n}$, and determine the largest admissible value of the CFL number $\\nu$ such that the scheme is stable for all $\\theta$. Your final answer must consist of the closed-form expression for $G(\\theta)$ and the single number giving the largest admissible $\\nu$, in that order. No rounding is required.",
            "solution": "The problem statement is evaluated and found to be valid. It is a scientifically grounded, well-posed, and objective problem from the field of computational fluid dynamics, specifically concerning the stability analysis of a numerical scheme. All necessary information is provided, and there are no contradictions or ambiguities.\n\nThe given partial differential equation (PDE) is the one-dimensional linear advection equation:\n$$u_{t} + a\\,u_{x} = 0$$\nwhere the advection speed $a$ is a positive constant ($a > 0$).\n\nThe specified numerical scheme uses a forward-Euler method for time integration and a first-order upwind method for spatial discretization.\n\nThe time derivative term, $u_t$, is approximated by a first-order forward difference:\n$$\\frac{\\partial u}{\\partial t} \\approx \\frac{u_{j}^{n+1} - u_{j}^{n}}{\\Delta t}$$\nwhere $u_j^n$ represents the numerical solution at spatial node $x_j = j\\,\\Delta x$ and time level $t^n = n\\,\\Delta t$.\n\nThe spatial derivative term, $u_x$, is approximated by a first-order upwind difference. Since $a > 0$, the \"upwind\" direction is from the left (i.e., information propagates from smaller $x$ to larger $x$). This corresponds to a first-order backward difference:\n$$\\frac{\\partial u}{\\partial x} \\approx \\frac{u_{j}^{n} - u_{j-1}^{n}}{\\Delta x}$$\nSubstituting these discrete approximations into the PDE yields the fully discretized equation:\n$$\\frac{u_{j}^{n+1} - u_{j}^{n}}{\\Delta t} + a \\left(\\frac{u_{j}^{n} - u_{j-1}^{n}}{\\Delta x}\\right) = 0$$\nTo obtain the explicit update scheme for $u_{j}^{n+1}$, we rearrange the terms:\n$$u_{j}^{n+1} - u_{j}^{n} = -a \\frac{\\Delta t}{\\Delta x} \\left(u_{j}^{n} - u_{j-1}^{n}\\right)$$\nWe introduce the Courant–Friedrichs–Lewy (CFL) number, defined as $\\nu = \\frac{a\\,\\Delta t}{\\Delta x}$. Substituting $\\nu$ into the equation gives:\n$$u_{j}^{n+1} = u_{j}^{n} - \\nu \\left(u_{j}^{n} - u_{j-1}^{n}\\right)$$\n$$u_{j}^{n+1} = (1 - \\nu)u_{j}^{n} + \\nu u_{j-1}^{n}$$\nThis is the finite difference scheme for which we must perform a von Neumann stability analysis. The analysis proceeds by substituting a single Fourier mode, $u_{j}^{n} = \\hat{u}^{n}\\,\\exp(i\\,j\\,\\theta)$, into the scheme. Here, $\\hat{u}^{n}$ is the amplitude of the mode at time step $n$, $i=\\sqrt{-1}$, and $\\theta = k_x \\Delta x$ is the nondimensional wavenumber, with $k_x$ being the wavenumber.\n\nThe terms in the scheme become:\n$$u_{j}^{n+1} = \\hat{u}^{n+1}\\,\\exp(i\\,j\\,\\theta)$$\n$$u_{j}^{n} = \\hat{u}^{n}\\,\\exp(i\\,j\\,\\theta)$$\n$$u_{j-1}^{n} = \\hat{u}^{n}\\,\\exp(i\\,(j-1)\\,\\theta) = \\hat{u}^{n}\\,\\exp(i\\,j\\,\\theta)\\,\\exp(-i\\,\\theta)$$\nSubstituting these into the discrete equation:\n$$\\hat{u}^{n+1}\\,\\exp(i\\,j\\,\\theta) = (1 - \\nu)\\hat{u}^{n}\\,\\exp(i\\,j\\,\\theta) + \\nu \\hat{u}^{n}\\,\\exp(i\\,j\\,\\theta)\\,\\exp(-i\\,\\theta)$$\nWe can divide the entire equation by the common factor $\\exp(i\\,j\\,\\theta)$, which is non-zero:\n$$\\hat{u}^{n+1} = (1 - \\nu)\\hat{u}^{n} + \\nu \\hat{u}^{n}\\,\\exp(-i\\,\\theta)$$\nFactoring out $\\hat{u}^n$ on the right-hand side gives:\n$$\\hat{u}^{n+1} = [1 - \\nu + \\nu \\exp(-i\\,\\theta)]\\,\\hat{u}^{n}$$\nThe amplification factor, $G(\\theta)$, is defined by the relation $\\hat{u}^{n+1} = G(\\theta)\\,\\hat{u}^{n}$. By comparison, we find the expression for $G(\\theta)$:\n$$G(\\theta) = 1 - \\nu + \\nu \\exp(-i\\,\\theta)$$\nThis is the first part of the required answer.\n\nFor the scheme to be stable, the modulus of the amplification factor must not exceed unity for any value of the nondimensional wavenumber $\\theta$. The von Neumann stability condition is:\n$$|G(\\theta)| \\le 1 \\quad \\forall \\theta \\in [-\\pi, \\pi]$$\nTo analyze this condition, we compute the modulus squared, $|G(\\theta)|^2$. Using Euler's formula, $\\exp(-i\\,\\theta) = \\cos(\\theta) - i\\,\\sin(\\theta)$, we can write $G(\\theta)$ in terms of its real and imaginary parts:\n$$G(\\theta) = (1 - \\nu + \\nu \\cos(\\theta)) - i\\,(\\nu \\sin(\\theta))$$\nThe modulus squared is the sum of the squares of the real and imaginary parts:\n$$|G(\\theta)|^2 = (1 - \\nu + \\nu \\cos(\\theta))^2 + (-\\nu \\sin(\\theta))^2$$\n$$|G(\\theta)|^2 = (1 - \\nu(1 - \\cos(\\theta)))^2 + \\nu^2 \\sin^2(\\theta)$$\nExpanding the squared terms:\n$$|G(\\theta)|^2 = 1 - 2\\nu(1 - \\cos(\\theta)) + \\nu^2(1 - \\cos(\\theta))^2 + \\nu^2 \\sin^2(\\theta)$$\n$$|G(\\theta)|^2 = 1 - 2\\nu(1 - \\cos(\\theta)) + \\nu^2(1 - 2\\cos(\\theta) + \\cos^2(\\theta)) + \\nu^2 \\sin^2(\\theta)$$\n$$|G(\\theta)|^2 = 1 - 2\\nu(1 - \\cos(\\theta)) + \\nu^2(1 - 2\\cos(\\theta) + \\cos^2(\\theta) + \\sin^2(\\theta))$$\nUsing the identity $\\cos^2(\\theta) + \\sin^2(\\theta) = 1$:\n$$|G(\\theta)|^2 = 1 - 2\\nu(1 - \\cos(\\theta)) + \\nu^2(1 - 2\\cos(\\theta) + 1)$$\n$$|G(\\theta)|^2 = 1 - 2\\nu(1 - \\cos(\\theta)) + \\nu^2(2 - 2\\cos(\\theta))$$\n$$|G(\\theta)|^2 = 1 - 2\\nu(1 - \\cos(\\theta)) + 2\\nu^2(1 - \\cos(\\theta))$$\n$$|G(\\theta)|^2 = 1 + (2\\nu^2 - 2\\nu)(1 - \\cos(\\theta))$$\n$$|G(\\theta)|^2 = 1 + 2\\nu(\\nu - 1)(1 - \\cos(\\theta))$$\nThe stability condition $|G(\\theta)|^2 \\le 1$ becomes:\n$$1 + 2\\nu(\\nu - 1)(1 - \\cos(\\theta)) \\le 1$$\n$$2\\nu(\\nu - 1)(1 - \\cos(\\theta)) \\le 0$$\nWe analyze the factors in this inequality:\n1.  The CFL number $\\nu = a\\,\\Delta t / \\Delta x$ is positive since $a > 0$, $\\Delta t > 0$, and $\\Delta x > 0$. Thus, $\\nu > 0$.\n2.  The term $(1 - \\cos(\\theta))$ is always non-negative for any real $\\theta$, as $-1 \\le \\cos(\\theta) \\le 1$. It ranges from $0$ to $2$.\nSince $2\\nu > 0$ and $(1 - \\cos(\\theta)) \\ge 0$, the inequality can only be satisfied for all $\\theta$ if the remaining factor $(\\nu-1)$ is non-positive.\n$$\\nu - 1 \\le 0 \\implies \\nu \\le 1$$\nCombining this with $\\nu > 0$, the stability condition for the scheme is $0  \\nu \\le 1$.\nThe question asks for the largest admissible value of the CFL number $\\nu$ for which the scheme is stable. This corresponds to the upper bound of the stability range.\n$$\\nu_{\\text{max}} = 1$$\nThis is the second part of the required answer.",
            "answer": "$$\\boxed{\\begin{pmatrix} 1 - \\nu + \\nu \\exp(-i\\theta)  1 \\end{pmatrix}}$$"
        },
        {
            "introduction": "The Lax Equivalence Theorem states that for a consistent linear scheme, stability is the necessary and sufficient condition for convergence. This practice provides a compelling hands-on test of this theorem by exploring a scenario highly relevant to Earth system modeling: a non-uniform grid. You will see firsthand how a scheme that is consistent can fail to converge if the stability condition—dictated by the *smallest* grid spacing—is violated, a crucial lesson for models employing stretched or adaptive meshes. ",
            "id": "3217060",
            "problem": "Consider the one-dimensional heat equation $u_t = u_{xx}$ on the spatial interval $x \\in (0,1)$ with homogeneous Dirichlet boundary conditions $u(0,t) = 0$ and $u(1,t) = 0$, and the smooth initial condition $u(x,0) = \\sin(\\pi x)$. The goal is to examine the interaction of consistency, stability, and convergence for an explicit time-stepping scheme on nonuniform grids, and to test the Lax equivalence theorem in practice.\n\nStarting from core definitions:\n- Consistency: the local truncation error tends to zero as the spatial steps $h_i$ and the time step $\\Delta t$ tend to zero.\n- Stability: the discrete solution operator is bounded with respect to perturbations in input data or roundoff, typically characterized by a bound on the amplification factor.\n- Convergence: the numerical solution approaches the exact solution of the original continuous model in a chosen norm (here the square-integrable norm).\n\nConstruct the explicit forward Euler method of lines scheme using a nonuniform second-derivative finite difference at interior nodes $x_i$ as\n$$u^{n+1}_i = u^n_i + \\Delta t \\, D^{(2)}u^n_i,$$\nwhere $D^{(2)}$ is the three-point second derivative approximation derived by Taylor expansions on a nonuniform mesh with spacings $h_{i-1} = x_i - x_{i-1}$ and $h_{i} = x_{i+1} - x_i$,\n$$D^{(2)}u_i \\approx 2\\left(\\frac{u_{i-1}}{h_{i-1}(h_{i-1}+h_i)} - \\frac{u_i}{h_{i-1}h_i} + \\frac{u_{i+1}}{h_i(h_{i-1}+h_i)}\\right).$$\nImpose the boundary conditions by setting $u^n_0 = 0$ and $u^n_{N+1} = 0$.\n\nDefine the discrete spatial operator $L$ as the matrix representation of $D^{(2)}$ acting on the vector of interior nodal values $\\mathbf{u}^n = (u^n_1,\\dots,u^n_N)^\\top$, so that the method can be written as $\\mathbf{u}^{n+1} = \\left(I + \\Delta t\\, L\\right)\\mathbf{u}^n$. For the exact solution with the given initial condition, one has $u(x,t) = e^{-\\pi^2 t}\\sin(\\pi x)$.\n\nYou must:\n1. Implement the nonuniform grid second-derivative operator $L$ on a strictly increasing grid $\\{x_i\\}_{i=0}^{N+1}$ with $x_0 = 0$ and $x_{N+1} = 1$.\n2. For each test case, compute:\n   - The maximum one-step amplification factor $a_{\\max} = \\max_{\\lambda \\in \\mathrm{spec}(L)} |1 + \\Delta t\\, \\lambda|$, where $\\mathrm{spec}(L)$ denotes the spectrum (set of eigenvalues) of $L$.\n   - The discrete square-integrable norm (the $L^2$ norm) of the one-step error compared to $u(x,\\Delta t)$, using quadrature weights $w_i = \\tfrac{h_{i-1} + h_i}{2}$ for interior nodes and defining the norm $\\|\\mathbf{v}\\|_{L^2} = \\left(\\sum_{i=1}^N w_i v_i^2\\right)^{1/2}$.\n   - The refinement error ratio $r = E_{2N} / E_{N}$, where $E_{N}$ is the one-step discrete $L^2$ error on a grid with $N$ interior points and $E_{2N}$ is the analogous error on the grid with $2N$ interior points, both using the same step-selection policy as described below.\n   - The stability boolean defined by $a_{\\max} \\le 1$.\n3. Explain, via the computed values, how the scheme can be pointwise consistent (local truncation error goes to zero as $N \\to \\infty$ and $\\Delta t \\to 0$) yet unstable and therefore nonconvergent in the $L^2$ norm if the time step is not scaled with the smallest mesh size. Specifically, show that when the grid is strongly nonuniform, scaling $\\Delta t$ with the average step size squared can yield $a_{\\max} > 1$, violating stability and preventing convergence by the Lax equivalence theorem.\n\nUse the following test suite. For each case, build the grid and choose the time step according to the specified policy:\n- Case A (happy path, uniform and stable): $N = 64$, uniform grid $x_i = i/(N+1)$, choose $\\Delta t = 0.45\\, h_{\\min}^2$ where $h_{\\min} = \\min_i (x_{i+1} - x_i)$.\n- Case B (edge case, nonuniform and unstable by average scaling): $N = 64$, graded grid $x_i = \\left(\\frac{i}{N+1}\\right)^p$ with $p = 2$, choose $\\Delta t = 0.45\\, \\bar{h}^2$ where $\\bar{h} = \\frac{1}{N+1}\\sum_{i=0}^N (x_{i+1} - x_i)$.\n- Case C (nonuniform but stable by minimum scaling): $N = 64$, graded grid $x_i = \\left(\\frac{i}{N+1}\\right)^p$ with $p = 2$, choose $\\Delta t = 0.45\\, h_{\\min}^2$.\n\nFor each case, compute $a_{\\max}$, the stability boolean, and the refinement error ratio $r$ by comparing $E_N$ to $E_{2N}$ under the same policy. All quantities are dimensionless.\n\nYour program should produce a single line of output containing the results, formatted as a comma-separated list enclosed in square brackets with no spaces, where each case contributes a sublist of the form $[$stable\\_boolean$,a_{\\max},r]$. For example, an output with three cases should look like $[[\\mathrm{True},0.9,0.5],[\\mathrm{False},3.1,1.8],[\\mathrm{True},0.8,0.6]]$ with no spaces anywhere in the line.",
            "solution": "The problem as stated is a well-posed and scientifically sound exercise in numerical analysis, designed to investigate the interdependence of consistency, stability, and convergence for a numerical scheme solving the one-dimensional heat equation. All provided equations, conditions, and definitions are standard and correct. The problem is valid.\n\nThe core of this problem lies in the Lax Equivalence Theorem, which states that for a consistent linear finite difference scheme, stability is the necessary and sufficient condition for convergence. We will demonstrate this principle by applying an explicit forward-in-time, centered-in-space (FTCS) scheme to the heat equation $u_t = u_{xx}$ on nonuniform grids.\n\nThe numerical method is defined by the update rule $\\mathbf{u}^{n+1} = \\left(I + \\Delta t\\, L\\right)\\mathbf{u}^n$, where $\\mathbf{u}^n$ is the vector of numerical solutions at the interior grid points at time step $n$, $I$ is the identity matrix, $\\Delta t$ is the time step, and $L$ is the matrix representation of the second-derivative operator $D^{(2)}$ given by\n$$D^{(2)}u_i = 2\\left(\\frac{u_{i-1}}{h_{i-1}(h_{i-1}+h_i)} - \\frac{u_i}{h_{i-1}h_i} + \\frac{u_{i+1}}{h_i(h_{i-1}+h_i)}\\right)$$\nfor a grid with spacings $h_{i-1} = x_i - x_{i-1}$ and $h_i = x_{i+1} - x_i$. This operator is consistent with the continuous second derivative $u_{xx}$; its local truncation error tends to zero as mesh spacings tend to zero.\n\nThe stability of this explicit scheme is governed by the spectral radius of the amplification matrix $G = I + \\Delta t\\, L$. Stability requires that the one-step amplification factor, $a_{\\max} = \\rho(G) = \\max_{\\lambda \\in \\mathrm{spec}(L)} |1 + \\Delta t\\, \\lambda|$, must not exceed $1$. The eigenvalues $\\lambda$ of the discrete Laplacian operator $L$ are real and non-positive. Let $\\lambda_{\\min}$ be the most negative eigenvalue of $L$. The stability condition simplifies to $1 + \\Delta t\\, \\lambda_{\\min} \\ge -1$, which yields the constraint:\n$$\\Delta t \\le \\frac{-2}{\\lambda_{\\min}}$$\nFor a nonuniform grid, the magnitude of $\\lambda_{\\min}$ is dictated by the smallest grid spacing, $h_{\\min}$. It can be shown that $|\\lambda_{\\min}|$ scales as $1/h_{\\min}^2$. This leads to the well-known stability requirement for explicit schemes:\n$$\\Delta t \\le C \\cdot h_{\\min}^2$$\nfor some constant $C$ (for the uniform grid case, $C=1/2$). A crucial insight is that stability depends on the *minimum* spacing, $h_{\\min}$, not the average spacing, $\\bar{h}$. The problem's test cases are designed to illustrate this point.\n\nFor each case, we will compute the maximum amplification factor $a_{\\max}$, determine stability via the condition $a_{\\max} \\le 1$, and assess convergence behavior through the one-step error refinement ratio $r = E_{2N} / E_N$. A ratio $r  1$ indicates convergence, while $r \\ge 1$ suggests divergence.\n\n**Case A: Uniform Grid, Stable Time Step**\nThe grid is uniform, meaning $h_i = h = \\bar{h} = h_{\\min}$ for all $i$. The time step is chosen as $\\Delta t = 0.45\\, h_{\\min}^2 = 0.45\\, h^2$. This satisfies the stability condition $\\Delta t \\le 0.5\\, h^2$. Consequently, we expect the scheme to be stable, with $a_{\\max} \\le 1$. Since the scheme is consistent and stable, the Lax Equivalence Theorem guarantees convergence. This should be reflected by a refinement ratio $r  1$.\n\n**Case B: Nonuniform Grid, Unstable Time Step**\nA graded mesh $x_i = (i/(N+1))^2$ is employed, which concentrates points near $x=0$, resulting in a very small $h_{\\min}$ compared to the average spacing $\\bar{h}$. The time step is set to $\\Delta t = 0.45\\, \\bar{h}^2$. Since $\\bar{h} \\gg h_{\\min}$, this choice of $\\Delta t$ will be far larger than what is permitted by the stability condition based on $h_{\\min}^2$.\n$$\\Delta t = 0.45\\, \\bar{h}^2 = 0.45 \\left(\\frac{\\bar{h}}{h_{\\min}}\\right)^2 h_{\\min}^2 \\gg h_{\\min}^2$$\nWe therefore predict that the scheme will be unstable, with $a_{\\max} > 1$. Despite being a consistent scheme, this instability will lead to non-convergence, which should be demonstrated by an error ratio $r \\ge 1$.\n\n**Case C: Nonuniform Grid, Stable Time Step**\nThis case uses the same graded mesh as Case B but corrects the flaw in the time-stepping policy. The time step is chosen as $\\Delta t = 0.45\\, h_{\\min}^2$. This choice respects the constraint imposed by the smallest mesh cells and is designed to satisfy the stability condition. We expect to find $a_{\\max} \\le 1$. With both consistency and stability re-established, the scheme should again be convergent, yielding a refinement ratio $r  1$.\n\nThe implementation will construct the matrix $L$, compute its eigenvalues to find $a_{\\max}$, and calculate the one-step $L^2$ error against the exact solution $u(x,t) = e^{-\\pi^2 t}\\sin(\\pi x)$ to determine the refinement ratio $r$. The results will provide a practical demonstration of the Lax Equivalence Theorem and the critical importance of selecting a time step based on the most restrictive local grid spacing.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_case_metrics(N, p, dt_policy):\n    \"\"\"\n    Computes stability and error metrics for a given grid and time step policy.\n\n    Args:\n        N (int): Number of interior grid points.\n        p (float): Power for graded grid generation. p=1 gives a uniform grid.\n        dt_policy (str): Time step policy, either 'min' or 'avg'.\n\n    Returns:\n        tuple: A tuple containing:\n            - l2_error (float): The discrete L2 norm of the one-step error.\n            - a_max (float): The maximum one-step amplification factor.\n            - is_stable (bool): True if the scheme is stable, False otherwise.\n    \"\"\"\n    # 1. Grid Generation\n    i_vals = np.arange(N + 2, dtype=float)\n    x = (i_vals / (N + 1))**p\n    h = np.diff(x)  # h has length N+1, h_i = x_{i+1} - x_i\n\n    # 2. Time Step Calculation\n    h_min = np.min(h)\n    # The problem defines h_bar as the sum over N+1 spacings divided by N+1\n    h_bar = np.mean(h)\n    \n    if dt_policy == 'min':\n        dt = 0.45 * h_min**2\n    elif dt_policy == 'avg':\n        dt = 0.45 * h_bar**2\n    else:\n        raise ValueError(\"Invalid dt_policy specified.\")\n\n    # 3. Construct the discrete operator matrix L\n    L = np.zeros((N, N))\n    # Loop over interior nodes i = 1, ..., N\n    # Matrix row j = i - 1 corresponds to node i\n    for j in range(N):\n        h_im1 = h[j]      # This is h_{i-1}\n        h_i   = h[j + 1]  # This is h_i\n        \n        # Diagonal term (coefficient of u_i)\n        L[j, j] = 2.0 * (-1.0 / (h_im1 * h_i))\n        \n        # Sub-diagonal term (coefficient of u_{i-1})\n        if j > 0:\n            L[j, j - 1] = 2.0 / (h_im1 * (h_im1 + h_i))\n        \n        # Super-diagonal term (coefficient of u_{i+1})\n        if j  N - 1:\n            L[j, j + 1] = 2.0 / (h_i * (h_im1 + h_i))\n\n    # 4. Compute stability metrics\n    eigenvalues = np.linalg.eigvals(L)\n    a_max = np.max(np.abs(1.0 + dt * eigenvalues))\n    is_stable = a_max = 1.0\n\n    # 5. Compute one-step L2 error\n    x_interior = x[1:N + 1]\n    \n    # Initial condition at interior nodes\n    u0 = np.sin(np.pi * x_interior)\n    \n    # Numerical solution at t = dt\n    u1_num = u0 + dt * (L @ u0)\n    \n    # Exact solution at t = dt\n    u1_exact = np.exp(-np.pi**2 * dt) * np.sin(np.pi * x_interior)\n    \n    # Error vector\n    error_vec = u1_num - u1_exact\n    \n    # Quadrature weights for L2 norm\n    # w_i = (h_{i-1} + h_i)/2. For interior nodes i=1..N, these are h_0..h_{N-1} + h_1..h_N\n    weights = 0.5 * (h[0:N] + h[1:N + 1])\n    \n    l2_error = np.sqrt(np.sum(weights * error_vec**2))\n    \n    return l2_error, a_max, is_stable\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    # (N_base, p, dt_policy) for each case\n    # p=1 represents a uniform grid as (i/(N+1))^1.\n    test_cases_params = [\n        (64, 1.0, 'min'),  # Case A: Uniform grid, stable by h_min\n        (64, 2.0, 'avg'),  # Case B: Graded grid, unstable by h_bar\n        (64, 2.0, 'min'),  # Case C: Graded grid, stable by h_min\n    ]\n\n    final_results = []\n    for N_base, p, policy in test_cases_params:\n        # Calculate metrics for the base grid N\n        E_N, a_max, is_stable = compute_case_metrics(N_base, p, policy)\n        \n        # Calculate error for the refined grid 2N to find the ratio\n        E_2N, _, _ = compute_case_metrics(2 * N_base, p, policy)\n        \n        # Refinement error ratio\n        r = E_2N / E_N\n        \n        final_results.append([is_stable, a_max, r])\n    \n    # Format the output string exactly as specified: [[val,val,val],[val,val,val],...]\n    case_strings = []\n    for s_bool, a_val, r_val in final_results:\n        # Python's bool __str__ is 'True' or 'False'\n        case_strings.append(f\"[{str(s_bool)},{a_val},{r_val}]\")\n    \n    print(f\"[{','.join(case_strings)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "In climate and Earth system modeling, we are often concerned with simulations over very long timescales where the conservation of quantities like energy is paramount. This exercise explores the concept of 'weak instability,' where a numerical method can cause a slow but systematic drift in energy, even if it is formally convergent on finite intervals. By analyzing the explicit midpoint method on a simple harmonic oscillator, a proxy for many oscillatory phenomena in geophysical systems, you will discover why certain schemes are unsuitable for long-term climate simulations. ",
            "id": "3217024",
            "problem": "Consider the explicit midpoint method for solving an Ordinary Differential Equation (ODE). The method defines a one-step update using the midpoint of the velocity field. Analyze its behavior on oscillatory problems from first principles of numerical stability and then demonstrate the observed behavior computationally.\n\nYou must start from the following fundamental bases:\n- The linear test equation for stability analysis: $y'(t) = \\lambda y(t)$, where $\\lambda \\in \\mathbb{C}$.\n- The simple harmonic oscillator model: $x''(t) + \\omega^2 x(t) = 0$ with angular frequency $\\omega > 0$.\n- The energy of the simple harmonic oscillator with unit mass: $E(t) = \\tfrac{1}{2}\\left(v(t)^2 + \\omega^2 x(t)^2\\right)$, where $v(t) = x'(t)$.\n\nTasks:\n1. Derive, from the definition of the explicit midpoint method and the linear test equation $y'(t) = \\lambda y(t)$, the one-step amplification factor $R(z)$ as a function of $z = h\\lambda$, where $h > 0$ is the time step. Specialize to the purely imaginary case $\\lambda = i\\omega$ with $\\omega > 0$. Show that the modulus $\\lvert R(i\\omega h) \\rvert$ exceeds $1$ for any nonzero step size $h$, and explain why this implies weak instability for oscillatory dynamics, even though the method is consistent and convergent on finite intervals.\n2. Implement a program that integrates the simple harmonic oscillator $x''(t) + \\omega^2 x(t) = 0$ by rewriting it as a first-order system $y'(t) = f(y(t))$ with $y(t) = \\begin{bmatrix}x(t) \\\\ v(t)\\end{bmatrix}$ and $f(y) = \\begin{bmatrix}v \\\\ -\\omega^2 x\\end{bmatrix}$. Use the explicit midpoint method to update the state:\n   - Compute $k_1 = f(y_n)$,\n   - Compute the midpoint state $y_{n+\\frac{1}{2}} = y_n + \\tfrac{h}{2}k_1$,\n   - Compute $k_2 = f(y_{n+\\frac{1}{2}})$,\n   - Update $y_{n+1} = y_n + h k_2$.\n3. For each simulation, use initial conditions $x(0) = 1$ and $v(0) = 0$. Let one period be $T_p = \\tfrac{2\\pi}{\\omega}$. For a given number of periods $M$, integrate for a total time $T = M T_p$ using an integer number of steps $N = \\left\\lfloor \\tfrac{T}{h} \\right\\rfloor$ with fixed step size $h$. Compute and return the energy ratio $r = \\tfrac{E_N}{E_0}$, where $E_0 = \\tfrac{1}{2}(\\omega^2 x(0)^2 + v(0)^2)$ and $E_N$ is the energy after $N$ steps. All quantities are dimensionless; no physical units are required.\n\nTest suite:\n- Case $1$: $\\omega = 1$, $h = 0.5$, $M = 50$.\n- Case $2$: $\\omega = 1$, $h = 0.1$, $M = 200$.\n- Case $3$: $\\omega = 1$, $h = 0.01$, $M = 200$.\n- Case $4$: $\\omega = 2$, $h = 0.05$, $M = 200$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[r_1,r_2,r_3,r_4]$), where each $r_j$ is the energy ratio for the corresponding test case in the order provided above.",
            "solution": "The problem statement is critically validated before a solution is attempted.\n\n### Problem Validation\n\n**Step 1: Extract Givens**\n- **Method**: Explicit midpoint method for ODEs.\n- **Update Steps**:\n  1. $k_1 = f(y_n)$\n  2. $y_{n+\\frac{1}{2}} = y_n + \\tfrac{h}{2}k_1$\n  3. $k_2 = f(y_{n+\\frac{1}{2}})$\n  4. $y_{n+1} = y_n + h k_2$\n- **Linear Test Equation**: $y'(t) = \\lambda y(t)$, where $\\lambda \\in \\mathbb{C}$.\n- **Simple Harmonic Oscillator (SHO)**: $x''(t) + \\omega^2 x(t) = 0$, with angular frequency $\\omega > 0$.\n- **SHO Energy**: $E(t) = \\tfrac{1}{2}\\left(v(t)^2 + \\omega^2 x(t)^2\\right)$, where $v(t) = x'(t)$ and mass is unity.\n- **Task 1**: Derive the amplification factor $R(z)$ for $z = h\\lambda$, show that for $\\lambda = i\\omega$, the modulus $\\lvert R(i\\omega h) \\rvert > 1$ for $h > 0$, and explain the implication of weak instability.\n- **Task 2**: Implement the method for the SHO as a first-order system $y'(t) = f(y(t))$ with $y(t) = \\begin{bmatrix}x(t) \\\\ v(t)\\end{bmatrix}$ and $f(y) = \\begin{bmatrix}v \\\\ -\\omega^2 x\\end{bmatrix}$.\n- **Task 3**: Run simulations with initial conditions $x(0) = 1$, $v(0) = 0$. Integrate over $M$ periods, $T = M T_p = M \\frac{2\\pi}{\\omega}$, using $N = \\left\\lfloor \\tfrac{T}{h} \\right\\rfloor$ steps of size $h$. Compute the energy ratio $r = E_N / E_0$.\n- **Test Suite**:\n  - Case 1: $\\omega = 1$, $h = 0.5$, $M = 50$.\n  - Case 2: $\\omega = 1$, $h = 0.1$, $M = 200$.\n  - Case 3: $\\omega = 1$, $h = 0.01$, $M = 200$.\n  - Case 4: $\\omega = 2$, $h = 0.05$, $M = 200$.\n\n**Step 2: Validate Using Extracted Givens**\nThe problem is assessed against the required criteria:\n- **Scientifically Grounded**: The problem is fundamentally sound. It involves the stability analysis of a standard explicit Runge-Kutta method (the explicit midpoint method, RK2) applied to the canonical linear test equation and the simple harmonic oscillator. These are cornerstone topics in the field of numerical ordinary differential equations.\n- **Well-Posed**: The problem is well-posed. It provides a complete algorithmic description, a set of specific initial conditions and parameters, and a clear objective for both the analytical derivation and the computational experiment. The tasks are unambiguous and lead to a unique, verifiable solution.\n- **Objective**: The problem is stated in objective, formal language, free of any subjectivity or bias. All terms are standard within mathematics and scientific computing.\n- **Flaw Checklist**: The problem does not exhibit any of the invalidating flaws. It is not scientifically unsound, incomplete, contradictory, unrealistic, or ill-posed.\n\n**Step 3: Verdict and Action**\nThe problem is **valid**. A complete solution will be provided.\n\n### Solution\n\nThis problem requires a two-part analysis of the explicit midpoint method: a theoretical stability analysis using the linear test equation, and a computational demonstration of its behavior on the simple harmonic oscillator, a system whose dynamics are purely oscillatory.\n\n**1. Stability Analysis and Amplification Factor**\n\nWe begin by analyzing the method's behavior on the linear test equation, $y'(t) = \\lambda y(t)$. The numerical solution at step $n$, denoted $y_n$, should ideally follow the behavior of the exact solution, $y(t_n)$. The explicit midpoint method is applied as follows:\n\nLet $f(y) = \\lambda y$. The steps to advance from $y_n$ to $y_{n+1}$ are:\n1.  Compute the first stage slope: $k_1 = f(y_n) = \\lambda y_n$.\n2.  Compute the state at the midpoint in time, using the slope $k_1$: $y_{n+\\frac{1}{2}} = y_n + \\frac{h}{2}k_1 = y_n + \\frac{h}{2}(\\lambda y_n) = (1 + \\frac{h\\lambda}{2})y_n$.\n3.  Compute the slope at the midpoint state: $k_2 = f(y_{n+\\frac{1}{2}}) = \\lambda y_{n+\\frac{1}{2}} = \\lambda(1 + \\frac{h\\lambda}{2})y_n$.\n4.  Update the state using the midpoint slope $k_2$: $y_{n+1} = y_n + h k_2 = y_n + h \\left[\\lambda(1 + \\frac{h\\lambda}{2})y_n\\right]$.\n\nFactoring out $y_n$ from the final expression gives the one-step update rule:\n$$y_{n+1} = \\left(1 + h\\lambda + \\frac{(h\\lambda)^2}{2}\\right) y_n$$\n\nThe term in parentheses is the amplification factor, $R(z)$, which determines how the numerical solution is scaled at each step. It is a polynomial function of $z = h\\lambda$.\n$$R(z) = 1 + z + \\frac{z^2}{2}$$\nThis is recognized as the second-order Taylor series expansion of $e^z$, which is consistent with the method's second-order accuracy.\n\nFor oscillatory problems, the eigenvalues of the system Jacobian lie on the imaginary axis. We model this by setting $\\lambda = i\\omega$, where $\\omega > 0$ is a real frequency. Consequently, $z = i\\omega h$. We substitute this into the amplification factor:\n$$R(i\\omega h) = 1 + (i\\omega h) + \\frac{(i\\omega h)^2}{2} = 1 + i\\omega h - \\frac{(\\omega h)^2}{2}$$\nThis complex number can be written in terms of its real and imaginary parts:\n$$R(i\\omega h) = \\left(1 - \\frac{(\\omega h)^2}{2}\\right) + i(\\omega h)$$\n\nThe stability of the method for oscillatory problems depends on the modulus of this amplification factor. If $\\lvert R(i\\omega h) \\rvert \\le 1$, the method is stable; otherwise, the amplitude of the numerical solution will grow artificially. We compute the modulus squared:\n$$\\lvert R(i\\omega h) \\rvert^2 = \\left(\\text{Re}[R(i\\omega h)]\\right)^2 + \\left(\\text{Im}[R(i\\omega h)]\\right)^2$$\n$$\\lvert R(i\\omega h) \\rvert^2 = \\left(1 - \\frac{(\\omega h)^2}{2}\\right)^2 + (\\omega h)^2$$\nExpanding the squared term:\n$$\\lvert R(i\\omega h) \\rvert^2 = \\left(1 - 2 \\cdot \\frac{(\\omega h)^2}{2} + \\frac{(\\omega h)^4}{4}\\right) + (\\omega h)^2$$\n$$\\lvert R(i\\omega h) \\rvert^2 = 1 - (\\omega h)^2 + \\frac{(\\omega h)^4}{4} + (\\omega h)^2$$\n$$\\lvert R(i\\omega h) \\rvert^2 = 1 + \\frac{(\\omega h)^4}{4}$$\nThus, the modulus is:\n$$\\lvert R(i\\omega h) \\rvert = \\sqrt{1 + \\frac{(\\omega h)^4}{4}}$$\nFor any non-zero step size $h > 0$ and frequency $\\omega > 0$, the term $(\\omega h)^4$ is strictly positive. Therefore, $\\frac{(\\omega h)^4}{4} > 0$, which implies $1 + \\frac{(\\omega h)^4}{4} > 1$, and consequently, $\\lvert R(i\\omega h) \\rvert > 1$.\n\nThis result proves that the explicit midpoint method is unconditionally unstable on the imaginary axis. The amplitude of the numerical solution is amplified by a factor greater than $1$ at every step. This leads to an exponential growth in the solution's norm over long integration times, a phenomenon known as weak instability. While the method is consistent (local error is $\\mathcal{O}(h^3)$) and therefore convergent on any finite time interval $[0, T]$, the error constant grows exponentially with $T$, making the method unsuitable for long-term simulations of conservative systems like the simple harmonic oscillator, where energy should be conserved. The numerical energy will systematically increase, as will be demonstrated computationally.\n\n**2. Computational Implementation and Energy Analysis**\n\nThe second-order SHO equation $x''(t) + \\omega^2 x(t) = 0$ is converted into a first-order system by defining the state vector $y(t) = \\begin{bmatrix} x(t) \\\\ v(t) \\end{bmatrix}$, where $v(t) = x'(t)$. The system dynamics are given by:\n$$y'(t) = \\begin{bmatrix} x'(t) \\\\ v'(t) \\end{bmatrix} = \\begin{bmatrix} v(t) \\\\ -\\omega^2 x(t) \\end{bmatrix} = f(y(t))$$\nWe will integrate this system using the explicit midpoint method with the specified test case parameters. At each step from $y_n = \\begin{bmatrix} x_n \\\\ v_n \\end{bmatrix}$ to $y_{n+1}$:\n1.  $k_1 = \\begin{bmatrix} k_{1,x} \\\\ k_{1,v} \\end{bmatrix} = \\begin{bmatrix} v_n \\\\ -\\omega^2 x_n \\end{bmatrix}$.\n2.  $y_{n+\\frac{1}{2}} = \\begin{bmatrix} x_n \\\\ v_n \\end{bmatrix} + \\frac{h}{2} \\begin{bmatrix} v_n \\\\ -\\omega^2 x_n \\end{bmatrix} = \\begin{bmatrix} x_n + \\frac{h}{2}v_n \\\\ v_n - \\frac{h}{2}\\omega^2 x_n \\end{bmatrix}$.\n3.  $k_2 = \\begin{bmatrix} k_{2,x} \\\\ k_{2,v} \\end{bmatrix} = f(y_{n+\\frac{1}{2}}) = \\begin{bmatrix} v_n - \\frac{h}{2}\\omega^2 x_n \\\\ -\\omega^2(x_n + \\frac{h}{2}v_n) \\end{bmatrix}$.\n4.  $y_{n+1} = \\begin{bmatrix} x_{n+1} \\\\ v_{n+1} \\end{bmatrix} = \\begin{bmatrix} x_n \\\\ v_n \\end{bmatrix} + h k_2 = \\begin{bmatrix} x_n + h(v_n - \\frac{h}{2}\\omega^2 x_n) \\\\ v_n - h\\omega^2(x_n + \\frac{h}{2}v_n) \\end{bmatrix}$.\n\nThe initial state is $y_0 = \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix}$. The initial energy is $E_0 = \\frac{1}{2}(v(0)^2 + \\omega^2 x(0)^2) = \\frac{1}{2}(0^2 + \\omega^2 \\cdot 1^2) = \\frac{\\omega^2}{2}$.\nAfter $N$ steps, the final state is $y_N = \\begin{bmatrix} x_N \\\\ v_N \\end{bmatrix}$. The final energy is $E_N = \\frac{1}{2}(v_N^2 + \\omega^2 x_N^2)$. The program will compute the ratio $r = E_N/E_0$ for each test case. This ratio quantifies the numerical energy drift predicted by the stability analysis.\nThe growth in energy is expected to be more pronounced for larger values of the dimensionless product $\\omega h$ and for a larger number of integration steps $N$.\nSpecifically, the energy ratio $r_N = E_N/E_0$ is expected to grow approximately as $(1 + \\frac{(\\omega h)^4}{4})^N$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Analyzes the explicit midpoint method on the simple harmonic oscillator.\n\n    This function implements the explicit midpoint method to solve the\n    simple harmonic oscillator equation system for four different test cases.\n    It calculates the ratio of the final numerical energy to the initial\n    analytical energy, demonstrating the method's weak instability for\n    oscillatory problems.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each tuple is (omega, h, M)\n    test_cases = [\n        (1.0, 0.5, 50),\n        (1.0, 0.1, 200),\n        (1.0, 0.01, 200),\n        (2.0, 0.05, 200),\n    ]\n\n    results = []\n    for omega, h, M in test_cases:\n        # Initial conditions\n        x0 = 1.0\n        v0 = 0.0\n        y = np.array([x0, v0], dtype=np.float64)\n\n        # System definition f(y) = [v, -omega^2 * x]\n        def f(state_vec, omega_val):\n            x, v = state_vec\n            return np.array([v, -omega_val**2 * x], dtype=np.float64)\n\n        # Simulation time parameters\n        # T_p is one period\n        T_p = 2.0 * np.pi / omega\n        # T is total integration time\n        T = M * T_p\n        # N is the total number of integer steps\n        N = int(np.floor(T / h))\n\n        # Calculate initial energy E_0\n        # E(t) = 0.5 * (v(t)^2 + omega^2 * x(t)^2)\n        E0 = 0.5 * (y[1]**2 + omega**2 * y[0]**2)\n\n        # Integration loop using explicit midpoint method\n        for _ in range(N):\n            # k1 = f(y_n)\n            k1 = f(y, omega)\n            \n            # y_mid = y_n + (h/2) * k1\n            y_mid = y + (h / 2.0) * k1\n            \n            # k2 = f(y_mid)\n            k2 = f(y_mid, omega)\n            \n            # y_{n+1} = y_n + h * k2\n            y = y + h * k2\n\n        # Calculate final energy E_N\n        EN = 0.5 * (y[1]**2 + omega**2 * y[0]**2)\n        \n        # Avoid division by zero if initial energy is zero, though not possible\n        # with the given ICs.\n        if E0 == 0:\n            energy_ratio = np.inf\n        else:\n            energy_ratio = EN / E0\n        \n        results.append(energy_ratio)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}