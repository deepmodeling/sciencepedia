{
    "hands_on_practices": [
        {
            "introduction": "第一个练习为理解CFL条件奠定了基础。我们从一维线性平流方程入手，这是输运现象最简单的模型。本练习侧重于直接应用CFL公式来计算模拟所需的时间步长，从而强化传播速度、网格分辨率和数值稳定性之间的核心关系。掌握这一基本计算是建立可靠数值模型的第一步。",
            "id": "2139558",
            "problem": "一个计算科学家团队正在模拟信号沿一维传输线的传播。信号电压 $u(x, t)$ 的行为由以下线性平流方程建模：\n$$ \\frac{\\partial u}{\\partial t} + v \\frac{\\partial u}{\\partial x} = 0 $$\n其中 $v$ 是信号的恒定传播速度。\n\n该模拟在具有均匀空间步长 $\\Delta x$ 的网格上使用有限差分格式。已知所选的数值方法仅在满足 Courant-Friedrichs-Lewy (CFL) 条件时才稳定。Courant 数 $C$ 定义为 $C = |v| \\frac{\\Delta t}{\\Delta x}$，其中 $\\Delta t$ 是时间步长。\n\n对于这个特定的模拟，传播速度为 $v = 2.5 \\times 10^8\\,\\mathrm{m/s}$，空间步长为 $\\Delta x = 1.25\\,\\mathrm{cm}$。为确保高精度并避免数值振荡，该团队决定在 Courant 数恰好为 $C = 0.75$ 的条件下运行。\n\n本次模拟所需的时间步长 $\\Delta t$ 是多少？请以纳秒 (ns) 为单位表示你的答案，并四舍五入到两位有效数字。",
            "solution": "我们使用线性平流方程离散化的 Courant 数定义：\n$$\nC=\\frac{|v|\\,\\Delta t}{\\Delta x}\n$$\n求解时间步长可得\n$$\n\\Delta t=\\frac{C\\,\\Delta x}{|v|}\n$$\n代入给定值，将空间步长转换为米：$\\Delta x=1.25\\times 10^{-2}\\,\\mathrm{m}$，$|v|=2.5\\times 10^{8}\\,\\mathrm{m/s}$，以及 $C=0.75$：\n$$\n\\Delta t=\\frac{0.75\\,(1.25\\times 10^{-2})}{2.5\\times 10^{8}}\\,\\mathrm{s}\n$$\n计算数值因子：\n$$\n\\Delta t=\\frac{0.9375\\times 10^{-2}}{2.5\\times 10^{8}}\\,\\mathrm{s}\n=\\left(\\frac{0.9375}{2.5}\\right)\\times 10^{-10}\\,\\mathrm{s}\n=0.375\\times 10^{-10}\\,\\mathrm{s}\n=3.75\\times 10^{-11}\\,\\mathrm{s}\n$$\n使用 $1\\,\\mathrm{ns}=10^{-9}\\,\\mathrm{s}$ 转换为纳秒：\n$$\n\\Delta t=3.75\\times 10^{-11}\\,\\mathrm{s}=3.75\\times 10^{-2}\\,\\mathrm{ns}=0.0375\\,\\mathrm{ns}\n$$\n四舍五入到两位有效数字，得到 $0.038\\,\\mathrm{ns}$。",
            "answer": "$$\\boxed{0.038}$$"
        },
        {
            "introduction": "现实世界中的系统，例如流体流动，通常由非线性方程控制，其中的波速不是恒定的，而是随解本身变化。本练习使用无粘性伯格斯方程（Burgers' equation）作为模型，引入了这种复杂性。你将学习如何通过根据给定时刻在整个区域内存在的最大速度来确定时间步长，从而使CFL条件适应此类情况 。这项实践对于为环境建模中普遍存在的非线性偏微分方程开发稳定格式至关重要。",
            "id": "2139603",
            "problem": "一个计算工程师团队正在为一个长通道内的一维、无粘性、可压缩流体流动开发一个模拟程序。该流体动力学由无粘性伯格斯方程（一个基本的非线性偏微分方程 (PDE)）建模：\n$$ u_t + u u_x = 0 $$\n其中 $u(x,t)$ 是在位置 $x$ 和时间 $t$ 处的流体速度。\n\n该团队计划在一个间距为 $\\Delta x$ 的均匀空间网格上，使用显式有限差分格式对该方程进行数值求解。该格式的稳定性由 Courant-Friedrichs-Lewy (CFL) 条件决定。对于所使用的特定格式，该条件由下式给出：\n$$ \\frac{\\max_x |u(x, t)| \\Delta t}{\\Delta x} \\le 1 $$\n其中 $\\Delta t$ 是时间步长。这意味着对于每个时间步，$\\Delta t$ 的选择必须足够小，以满足基于该瞬间整个空间域上存在的最大速度大小的条件。\n\n该模拟在 $t=0$ 时，在域 $x \\in [-L, L]$ 上使用以下速度分布进行初始化：\n$$ u(x, 0) = A \\sin\\left(\\frac{\\pi x}{L}\\right) + B $$\n模拟的参数如下：\n- 通道半长, $L = 5.00\\,\\mathrm{m}$\n- 速度振幅, $A = 2.00\\,\\mathrm{m/s}$\n- 速度偏移, $B = 0.500\\,\\mathrm{m/s}$\n- 空间网格间距, $\\Delta x = 0.100\\,\\mathrm{m}$\n\n计算可用于模拟第一步（即从 $t=0$ 推进到 $t=\\Delta t$）的最大稳定时间步长 $\\Delta t_{max}$。答案以秒为单位，并四舍五入到三位有效数字。",
            "solution": "数值稳定性由 Courant-Friedrichs-Lewy 条件决定，对于该格式，该条件为\n$$\n\\frac{\\max_{x}|u(x,t)|\\Delta t}{\\Delta x}\\leq 1.\n$$\n对于 $t=0$ 时的第一个时间步，这给出\n$$\n\\Delta t_{\\max}=\\frac{\\Delta x}{\\max_{x}|u(x,0)|}.\n$$\n初始条件为\n$$\nu(x,0)=A\\sin\\!\\left(\\frac{\\pi x}{L}\\right)+B,\\quad x\\in[-L,L].\n$$\n令 $s=\\sin\\!\\left(\\frac{\\pi x}{L}\\right)$，则在 $x\\in[-L,L]$ 上有 $s\\in[-1,1]$。定义\n$$\ng(s)=|A s+B|,\\quad s\\in[-1,1].\n$$\n由于 $g(s)$ 是 $s$ 的仿射函数的绝对值，因此它是凸函数，所以它在闭区间上的最大值在端点处取得。因此，\n$$\n\\max_{x\\in[-L,L]}|u(x,0)|=\\max_{s\\in[-1,1]}|A s+B|=\\max\\big(|A+B|,\\;|B-A|\\big).\n$$\n代入 $A=2.00$ 和 $B=0.500$，\n$$\n|A+B|=2.50,\\qquad |B-A|=1.50,\n$$\n因此\n$$\n\\max_{x}|u(x,0)|=2.50.\n$$\n当 $\\Delta x=0.100$ 时，最大稳定时间步长为\n$$\n\\Delta t_{\\max}=\\frac{0.100}{2.50}=0.0400,\n$$\n四舍五入到三位有效数字。",
            "answer": "$$\\boxed{0.0400}$$"
        },
        {
            "introduction": "最后的这项实践从纸笔计算转向动手编程实验，连接了理论稳定性分析与实际计算结果之间的鸿沟。你将为一个平流方程实现一个数值格式，并直接观察当CFL条件被满足和被违反时解的行为 。通过测量特定傅里叶模式的放大因子，你将对为什么CFL条件是防止数值误差灾难性增长的必要条件，获得一个具体而直观的理解。",
            "id": "3922279",
            "problem": "考虑周期性域中被动示踪剂的一维线性平流，其由偏微分方程 $\\partial \\phi/\\partial t + u\\,\\partial \\phi/\\partial x = 0$ 建模，其中 $\\phi(x,t)$ 是示踪剂浓度，$u$ 是恒定的平流速度，空间域被离散为 $N$ 个网格点，均匀间距为 $\\Delta x$。 Courant-Friedrichs-Lewy (CFL) 条件是一项稳定性要求，它通过无量綱数 $C = u\\,\\Delta t/\\Delta x$ 约束了时间步长 $\\Delta t$、网格间距 $\\Delta x$ 和特征速度 $u$ 之间的关系。\n\n对于 $u>0$，在周期性边界条件下，使用前向欧拉时间步进和空间上的一阶迎风差分，在网格索引 $i$ 和时间层 $n$ 的完全离散更新公式为\n$$\n\\phi_i^{n+1} = \\phi_i^n - C\\left(\\phi_i^n - \\phi_{i-1}^n\\right),\n$$\n其中 $C = u\\,\\Delta t/\\Delta x$，且周期性意味着 $\\phi_{-1}^n = \\phi_{N-1}^n$。\n\n构建一个数值实验，将示踪剂初始化为网格上最高可分辨的波数模式，即对所有 $i \\in \\{0,1,\\dots,N-1\\}$，$\\phi_i^0 = (-1)^i$，然后使用上述格式将解推进指定的步数。在每一步，通过投影到 $(-1)^i$ 来计算该最高波数模式的标量振幅：\n$$\nA^n = \\frac{1}{N}\\sum_{i=0}^{N-1} \\phi_i^n\\,(-1)^i.\n$$\n将每步放大因子定义为整个演化过程中绝对比值 $|A^{n+1}/A^n|$ 的几何平均值：\n$$\n\\mathcal{G} = \\left(\\prod_{n=0}^{n_{\\text{steps}}-1} \\left|\\frac{A^{n+1}}{A^n}\\right|\\right)^{1/n_{\\text{steps}}}.\n$$\n\n您的程序必须：\n- 实现上述带有周期性边界的数值格式。\n- 初始化 $\\phi_i^0 = (-1)^i$。\n- 对于每个测试用例，计算并返回每步放大因子 $\\mathcal{G}$，结果为四舍五入到六位小数的浮点数。\n\n使用物理上一致的单位：$u$ 的单位为 $\\mathrm{m/s}$, $\\Delta x$ 的单位为 $\\mathrm{m}$, $\\Delta t$ 的单位为 $\\mathrm{s}$。在涉及波数-相位关系时，角度应理解为弧度。不涉及百分比。\n\n测试套件：\n- 用例 $1$ (超出稳定性阈值的增长): $N=64$, $\\Delta x = 100\\,\\mathrm{m}$, $u = 10\\,\\mathrm{m/s}$, $\\Delta t = 12\\,\\mathrm{s}$, $n_{\\text{steps}} = 8$。 这得到 $C = 1.2$。\n- 用例 $2$ (稳定性边界): $N=64$, $\\Delta x = 100\\,\\mathrm{m}$, $u = 10\\,\\mathrm{m/s}$, $\\Delta t = 10\\,\\mathrm{s}$, $n_{\\text{steps}} = 8$。 这得到 $C = 1.0$。\n- 用例 $3$ (稳定且强衰减): $N=64$, $\\Delta x = 100\\,\\mathrm{m}$, $u = 10\\,\\mathrm{m/s}$, $\\Delta t = 3\\,\\mathrm{s}$, $n_{\\text{steps}} = 8$。 这得到 $C = 0.3$。\n- 用例 $4$ (稳定且中等衰减): $N=64$, $\\Delta x = 100\\,\\mathrm{m}$, $u = 10\\,\\mathrm{m/s}$, $\\Delta t = 7.5\\,\\mathrm{s}$, $n_{\\text{steps}} = 8$。 这得到 $C = 0.75$。\n\n最终输出格式：\n您的程序应生成一行输出，其中包含四个测试用例的结果，格式为方括号括起来的逗号分隔列表，例如 `[r_1,r_2,r_3,r_4]`，其中每个 `r_j` 是四舍五入到六位小数的每步放大因子 $\\mathcal{G}$。",
            "solution": "问题陈述已经过验证，被认为是**有效的**。它具有科学依据、是适定的、客观的，并包含构建一个唯一的、可验证的解所需的所有必要信息。该问题描述了计算流体动力学中的一个标准数值实验，用于研究线性平流方程的一阶迎风格式的稳定性。\n\n### 1. 理论分析：放大因子\n\n该问题通过分析数值格式对单个傅里葉模式的影响来研究其稳定性。离散更新方程由下式给出\n$$\n\\phi_i^{n+1} = \\phi_i^n - C\\left(\\phi_i^n - \\phi_{i-1}^n\\right)\n$$\n其中 $C = u\\,\\Delta t/\\Delta x$ 是 Courant 数。\n\n为确定该格式的稳定性，我们使用 von Neumann 稳定性分析。我们考虑形式为 $\\phi_j^n = \\hat{\\phi}^n e^{i k x_j}$ 的单个傅里葉模式，其中 $k$ 是波数，$x_j = j\\Delta x$ 是网格点位置，$\\hat{\\phi}^n$ 是时间层 $n$ 的复振幅。将此代入离散方程可得：\n$$\n\\hat{\\phi}^{n+1} e^{ikj\\Delta x} = \\hat{\\phi}^n e^{ikj\\Delta x} - C \\left( \\hat{\\phi}^n e^{ikj\\Delta x} - \\hat{\\phi}^n e^{ik(j-1)\\Delta x} \\right)\n$$\n放大因子 $G(k)$ 是连续时间步长中振幅的比率，$G(k) = \\hat{\\phi}^{n+1} / \\hat{\\phi}^n$。将方程两边同除以 $\\hat{\\phi}^n e^{ikj\\Delta x}$ 可得：\n$$\nG(k) = 1 - C(1 - e^{-ik\\Delta x})\n$$\n问题指定了初始条件 $\\phi_i^0 = (-1)^i$。此特定模式对应于网格上的最高可分辨波数，通常称为 Nyquist 频率。它可以写作 $\\phi_i^0 = e^{i\\pi i}$，这意味着无量纲波数 $k\\Delta x = \\pi$。\n\n将 $k\\Delta x = \\pi$ 代入放大因子表达式：\n$$\nG(k\\Delta x = \\pi) = 1 - C(1 - e^{-i\\pi}) = 1 - C(1 - (-1)) = 1 - 2C\n$$\n这表明对于特定模式 $\\phi_i^n = A^n (-1)^i$，下一个时间步的振幅由 $A^{n+1} = (1-2C) A^n$ 给出。因此，每个时间步的绝对振幅之比是恒定的：\n$$\n\\left|\\frac{A^{n+1}}{A^n}\\right| = |1 - 2C|\n$$\n问题将每步放大因子 $\\mathcal{G}$ 定义为在 $n_{\\text{steps}}$ 步数上这些比率的几何平均值：\n$$\n\\mathcal{G} = \\left(\\prod_{n=0}^{n_{\\text{steps}}-1} \\left|\\frac{A^{n+1}}{A^n}\\right|\\right)^{1/n_{\\text{steps}}}\n$$\n由于该比率为常数值 $|1 - 2C|$，所以几何平均值就是该值：\n$$\n\\mathcal{G} = \\left( \\prod_{n=0}^{n_{\\text{steps}}-1} |1-2C| \\right)^{1/n_{\\text{steps}}} = \\left( (|1-2C|)^{n_{\\text{steps}}} \\right)^{1/n_{\\text{steps}}} = |1-2C|\n$$\n因此，问题中描述的数值实验对于每个测试用例，都应得出 $\\mathcal{G}$ 的结果等于 $|1-2C|$。\n\n### 2. 算法实现\n\n数值实验通过遵循所提供的离散方程和定义来实现。\n\n**初始化**：对于每个测试用例，给定网格大小 $N$、网格间距 $\\Delta x$、速度 $u$、时间步长 $\\Delta t$ 和步数 $n_{\\text{steps}}$。首先计算 Courant 数 $C = u\\,\\Delta t/\\Delta x$。初始化一个大小为 $N$ 的一维数组 `phi` 来表示 $t=0$ 时的示踪剂浓度，其值为 $\\phi_i^0 = (-1)^i$。\n\n**时间演化**：解在 $n_{\\text{steps}}$ 步的循环中推进。在每次迭代中，代表从时间层 $n$ 到 $n+1$ 的一步：\n1.  使用当前状态 $\\phi^n$ 来计算下一个状态 $\\phi^{n+1}$。更新方程 $\\phi_i^{n+1} = \\phi_i^n - C(\\phi_i^n - \\phi_{i-1}^n)$ 同时应用于所有网格点。这可以通过向量运算高效实现。项 $\\phi_{i-1}^n$ 需要访问相邻网格点的值。对于周期性域，$\\phi_{-1}^n = \\phi_{N-1}^n$。这种周期性移位可以通过 `numpy.roll` 函数优雅地处理，该函数循环移位 `phi` 数组的元素。\n2.  在更新前计算最高波数模式的振幅 $A^n$，更新后计算 $A^{n+1}$。公式 $A^k = \\frac{1}{N}\\sum_{i=0}^{N-1} \\phi_i^k (-1)^i$ 实现为状态向量 `phi` 与一个元素为 $(-1)^i$ 的预计算投影向量的点积，然后除以 $N$。\n3.  计算并存储绝对比值 $|A^{n+1}/A^n|$。\n\n**最终计算**：时间步进循环完成后，将每步放大因子 $\\mathcal{G}$ 计算为所有存储比率的几何平均值。这通过计算这些比率的乘积，然后取其 $1/n_{\\text{steps}}$ 次方得到。由于该问题中 $A^{n+1}/A^n = 1-2C$ 关系的精确性，每个计算出的比率将是相同的（在浮点精度范围内），几何平均值将等于这个常数值。\n\n此过程直接实现了问题陈述中的定义，并作为对上述解析结果的数值验证。\n\n测试用例涵盖了格式不稳定 ($C > 1$)、临界稳定 ($C=1$) 和稳定 ($0  C  1$) 的情况，展示了放大因子在每种情况下的行为。\n-   用例 1 ($C=1.2$): $\\mathcal{G} = |1 - 2.4| = 1.4$。不稳定增长。\n-   用例 2 ($C=1.0$): $\\mathcal{G} = |1 - 2.0| = 1.0$。临界稳定，振幅无变化。\n-   用例 3 ($C=0.3$): $\\mathcal{G} = |1 - 0.6| = 0.4$。稳定，强衰减。\n-   用例 4 ($C=0.75$): $\\mathcal{G} = |1 - 1.5| = 0.5$。稳定，中度衰减。\n\n程序以数值方式计算这些值。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the numerical experiment problem for the 1D linear advection equation.\n\n    For each test case, it simulates the evolution of the highest-wavenumber mode\n    using a first-order upwind scheme and computes the per-step amplification factor.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (N, delta_x, u, delta_t, n_steps)\n        # Case 1 (growth beyond stability threshold)\n        (64, 100.0, 10.0, 12.0, 8),\n        # Case 2 (boundary of stability)\n        (64, 100.0, 10.0, 10.0, 8),\n        # Case 3 (stable with strong decay)\n        (64, 100.0, 10.0, 3.0, 8),\n        # Case 4 (stable with moderate decay)\n        (64, 100.0, 10.0, 7.5, 8),\n    ]\n\n    results = []\n    for case in test_cases:\n        N, delta_x, u, delta_t, n_steps = case\n        \n        # Calculate the Courant number, C = u * dt / dx.\n        C = u * delta_t / delta_x\n        \n        # Initialize the tracer field phi for the highest resolvable wavenumber mode.\n        # phi_i^0 = (-1)^i\n        indices = np.arange(N)\n        phi = (-1.0)**indices\n        \n        # Define the projection vector (-1)^i for calculating the amplitude A^n.\n        projection_vector = (-1.0)**indices\n        \n        # Calculate the initial amplitude A^0.\n        # A^0 = (1/N) * sum(phi_i^0 * (-1)^i) = (1/N) * sum((-1)^i * (-1)^i)\n        #   = (1/N) * sum(1) = 1.0\n        # We calculate it numerically for completeness.\n        A_current = (1.0 / N) * np.dot(phi, projection_vector)\n\n        # List to store the per-step amplitude ratios |A^{n+1}/A^n|.\n        ratios = []\n        \n        # Main time-stepping loop.\n        for _ in range(n_steps):\n            # Store the current state phi^n.\n            phi_old = phi\n            \n            # Get phi_{i-1} for all i, applying periodic boundary condition.\n            # np.roll(phi_old, 1) shifts elements to the right, so the new element\n            # at index i is the old element from index i-1.\n            phi_prev = np.roll(phi_old, 1)\n            \n            # Update phi to phi^{n+1} using the first-order upwind scheme.\n            # phi_i^{n+1} = phi_i^n - C * (phi_i^n - phi_{i-1}^n)\n            phi = phi_old - C * (phi_old - phi_prev)\n            \n            # Calculate the new amplitude A^{n+1}.\n            A_next = (1.0 / N) * np.dot(phi, projection_vector)\n            \n            # Calculate the ratio of absolute amplitudes and store it.\n            # Since test cases do not result in C=0.5, A_current will not be zero,\n            # so direct division is safe.\n            ratio = np.abs(A_next / A_current)\n            ratios.append(ratio)\n            \n            # Update the amplitude for the next iteration.\n            A_current = A_next\n        \n        # Compute the per-step amplification factor G as the geometric mean of the ratios.\n        product_of_ratios = np.prod(ratios)\n        geo_mean = product_of_ratios**(1.0 / n_steps)\n        \n        results.append(geo_mean)\n\n    # Format the results to six decimal places and print in the required format.\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}