{
    "hands_on_practices": [
        {
            "introduction": "在数值模型中，精确地表达质量守恒是至关重要的，而离散散度算子是实现这一目标的核心。本练习将指导您在阿拉卡瓦C网格（Arakawa C-grid）上实现一个离散散度算子，并学习如何处理不可穿透边界条件。通过这个基础实践，您将理解C网格交错布局如何自然地与有限体积法的通量计算相结合 ()。",
            "id": "3863000",
            "problem": "考虑一个尺寸为 $L_x$ 和 $L_y$ 的矩形域，使用 Arakawa C-网格交错约定，在 $x$ 方向上离散为 $N_x$ 个网格单元，在 $y$ 方向上离散为 $N_y$ 个网格单元。在 Arakawa C-网格上，水平速度分量 $u$ 位于垂直网格面的中心，垂直速度分量 $v$ 位于水平网格面的中心，而标量（例如，质量或压力）位于网格中心。设均匀网格间距为 $\\Delta x = L_x / N_x$ 和 $\\Delta y = L_y / N_y$。\n\n对于不可压缩流，质量守恒由无散条件 $\\nabla \\cdot \\mathbf{u} = 0$ 给出。对于面积为 $A = \\Delta x \\Delta y$ 的单个矩形网格单元，其有限体积形式的积分表达式为\n$$\n\\int_V \\nabla \\cdot \\mathbf{u} \\, dV = \\oint_{\\partial V} \\mathbf{u} \\cdot \\mathbf{n} \\, dS,\n$$\n对于均匀笛卡尔网格，这在每个网格中心 $(i+\\tfrac{1}{2}, j+\\tfrac{1}{2})$ 处产生离散散度\n$$\n(\\nabla \\cdot \\mathbf{u})_{i+\\frac{1}{2}, j+\\frac{1}{2}} = \\frac{u_{i+1, j} - u_{i, j}}{\\Delta x} + \\frac{v_{i, j+1} - v_{i, j}}{\\Delta y},\n$$\n其中 $u_{i,j}$ 表示位于 $x = i \\Delta x$, $y = \\left(j + \\tfrac{1}{2}\\right) \\Delta y$ 的垂直面上的 $u$ 值，其中 $i = 0, 1, \\dots, N_x$ 且 $j = 0, 1, \\dots, N_y - 1$；$v_{i,j}$ 表示位于 $x = \\left(i + \\tfrac{1}{2}\\right) \\Delta x$, $y = j \\Delta y$ 的水平面上的 $v$ 值，其中 $i = 0, 1, \\dots, N_x - 1$ 且 $j = 0, 1, \\dots, N_y$。\n\n在所有四个域边界上施加以下物理边界条件：\n- 无法向流（不可穿透壁）：边界处 $\\mathbf{u} \\cdot \\mathbf{n} = 0$，这意味着在西侧（$i = 0$）和东侧（$i = N_x$）域面上 $u = 0$，在南侧（$j = 0$）和北侧（$j = N_y$）域面上 $v = 0$。\n- 切向速度分量的自由滑移（零剪切应力）：边界处 $\\partial u_t / \\partial n = 0$，其中 $u_t$ 是切向分量，$n$ 是外法线。在 C-网格上，可以使用域外的虚拟值来一致地施加此条件。例如，在西边界 $x = 0$ 处，切向分量是 $v$，在 $x=0$ 处的二阶精确离散 Neumann 条件 $\\partial v / \\partial x = 0$ 可以通过设置虚拟值来满足，使得单侧二阶有限差分近似为零：\n$$\n\\left.\\frac{\\partial v}{\\partial x}\\right|_{x=0} \\approx \\frac{-3 v_{0,j} + 4 v_{1,j} - v_{2,j}}{2 \\Delta x} = 0 \\quad \\Rightarrow \\quad v_{0,j} = \\frac{4 v_{1,j} - v_{2,j}}{3},\n$$\n在 $x = L_x$ 处对 $v$ 以及在 $y = 0$ 和 $y = L_y$ 处对 $u$ 进行类似的处理。尽管散度算子不直接使用切向导数，但当存在涉及切向分量的微分算子时，需要这种边界封闭来保持交错布置的一致性。\n\n你的任务是为以下测试套件在 Arakawa C-网格上实现离散散度，按照上述规定通过无法向流条件强制施加不可穿透壁。对于每个测试用例，从在适当的交错位置采样的给定解析定义构建交错速度场 $(u, v)$，在域边界面上对 $u$ 和 $v$ 应用无法向流边界条件，并计算所有网格中心上离散散度的最大绝对值：\n$$\nD_{\\max} = \\max_{i=0,\\dots,N_x-1 \\atop j=0,\\dots,N_y-1} \\left| \\frac{u_{i+1, j} - u_{i, j}}{\\Delta x} + \\frac{v_{i, j+1} - v_{i, j}}{\\Delta y} \\right|.\n$$\n为每个测试用例报告以秒的倒数 ($s^{-1}$) 为单位的 $D_{\\max}$，结果为浮点数。\n\n在交错位置采样的解析速度场定义：\n- 用例 A（通过流函数的涡旋型不可压缩流）：设流函数为 $\\psi(x,y) = \\sin\\left(\\pi x / L_x\\right) \\sin\\left(\\pi y / L_y\\right)$。定义\n$$\nu(x,y) = \\frac{\\partial \\psi}{\\partial y} = \\frac{\\pi}{L_y} \\cos\\left(\\pi y / L_y\\right) \\sin\\left(\\pi x / L_x\\right), \\quad v(x,y) = -\\frac{\\partial \\psi}{\\partial x} = -\\frac{\\pi}{L_x} \\cos\\left(\\pi x / L_x\\right) \\sin\\left(\\pi y / L_y\\right).\n$$\n- 用例 B（在施加前违反垂直边界上无法向流条件的均匀流）：定义\n$$\nu(x,y) = U_0, \\quad v(x,y) = 0,\n$$\n速度为常数 $U_0$。\n- 用例 C（具有与用例 A 相同基于流函数的定义的单网格单元域），用于测试在最小网格中的边界处理。\n\n测试套件参数集：\n- 用例 A：$L_x = 1$ m, $L_y = 1$ m, $N_x = 16$, $N_y = 12$。\n- 用例 B：$L_x = 3$ m, $L_y = 2$ m, $N_x = 9$, $N_y = 6$, $U_0 = 0.5$ m/s。\n- 用例 C：$L_x = 1$ m, $L_y = 1$ m, $N_x = 1$, $N_y = 1$。\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，“[`result_A`, `result_B`, `result_C`]”），其中每个 `result_*` 是相应情况下 $D_{\\max}$ 的浮点值，以 $s^{-1}$ 表示。",
            "solution": "该问题要求在 Arakawa C-网格上实现一个离散散度算子，并将其应用于三个测试用例。任务的核心是正确表示交错速度场，应用指定的边界条件，并计算整个计算域上的最大绝对散度。\n\n**1. Arakawa C-网格与离散散度**\n\nArakawa C-网格是一种交错网格布置，常用于计算流体力学，特别是地球物理流。其关键特征是不同物理变量在空间上的偏移。在此问题中，标量（如压力，或在本例中为散度本身）位于网格单元的中心 $(i+\\tfrac{1}{2}, j+\\tfrac{1}{2})$，而矢量分量位于网格面上。\n- 水平速度分量 $u$ 定义在垂直面的中心。其位置由坐标 $(x_i, y_{j+1/2}) = (i\\Delta x, (j+\\tfrac{1}{2})\\Delta y)$ 给出，其中 $i \\in \\{0, 1, \\dots, N_x\\}$ 且 $j \\in \\{0, 1, \\dots, N_y-1\\}$。这可以由一个尺寸为 $(N_x+1) \\times N_y$ 的二维数组表示。\n- 垂直速度分量 $v$ 定义在水平面的中心。其位置由坐标 $(x_{i+1/2}, y_j) = ((i+\\tfrac{1}{2})\\Delta x, j\\Delta y)$ 给出，其中 $i \\in \\{0, 1, \\dots, N_x-1\\}$ 且 $j \\in \\{0, 1, \\dots, N_y\\}$。这可以由一个尺寸为 $N_x \\times (N_y+1)$ 的二维数组表示。\n\n不可压缩流体的质量守恒为 $\\nabla \\cdot \\mathbf{u} = 0$。在 C-网格上，对于网格单元 $(i, j)$（中心在 $(x_{i+1/2}, y_{j+1/2})$）的有限体积离散化由下式给出：\n$$\n(\\nabla \\cdot \\mathbf{u})_{i+\\frac{1}{2}, j+\\frac{1}{2}} = \\frac{u_{i+1, j} - u_{i, j}}{\\Delta x} + \\frac{v_{i, j+1} - v_{i, j}}{\\Delta y}\n$$\n此处，$u_{i+1, j} - u_{i, j}$ 表示 $u$-速度分量在 $x$ 方向上流出网格单元的净通量，$v_{i, j+1} - v_{i, j}$ 表示 $v$-速度分量在 $y$ 方向上流出网格单元的净通量。索引对应于网格面上速度分量的数组位置。散度本身是为 $N_x \\times N_y$ 个网格单元中的每一个计算的。\n\n**2. 边界条件**\n\n问题在所有四个域边界上指定了不可穿透壁（无法向流）边界条件，$\\mathbf{u} \\cdot \\mathbf{n} = 0$。在 C-网格上，此条件直接施加在垂直于边界的速度分量上。\n- 西边界（$x=0$, $i=0$）：法向速度为 $u$。条件为对所有 $j \\in \\{0, \\dots, N_y-1\\}$，$u_{0, j} = 0$。\n- 东边界（$x=L_x$, $i=N_x$）：法向速度为 $u$。条件为对所有 $j \\in \\{0, \\dots, N_y-1\\}$，$u_{N_x, j} = 0$。\n- 南边界（$y=0$, $j=0$）：法向速度为 $v$。条件为对所有 $i \\in \\{0, \\dots, N_x-1\\}$，$v_{i, 0} = 0$。\n- 北边界（$y=L_y$, $j=N_y$）：法向速度为 $v$。条件为对所有 $i \\in \\{0, \\dots, N_x-1\\}$，$v_{i, N_y} = 0$。\n\n注意到了关于自由滑移切向速度边界条件的讨论，但正如问题陈述所确认的，散度算子本身不依赖于切向导数或虚拟单元。因此，对于此特定计算，仅需要无法向流条件。\n\n**3. 测试用例分析**\n\n对于每个用例，我们首先定义网格参数，然后通过在适当的交错网格位置对给定的解析函数进行采样来创建速度场，施加无法向流边界条件，计算散度场，最后找到最大绝对值 $D_{\\max}$。\n\n**用例 A：涡旋型流**\n- 参数：$L_x = 1$ m, $L_y = 1$ m, $N_x = 16$, $N_y = 12$。\n- 速度场源自流函数 $\\psi(x,y) = \\sin(\\pi x / L_x) \\sin(\\pi y / L_y)$。\n- 通过在各自的交错网格点上采样 $u(x,y) = \\frac{\\pi}{L_y} \\cos(\\pi y / L_y) \\sin(\\pi x / L_x)$ 和 $v(x,y) = -\\frac{\\pi}{L_x} \\cos(\\pi x / L_x) \\sin(\\pi y / L_y)$ 来填充 $u$ 和 $v$ 场。\n- 关键是，这个解析速度场已经满足了无法向流条件。例如，在西边界 $x=0$ 处，$u(0,y) \\propto \\sin(0) = 0$。在北边界 $y=L_y$ 处，$v(x,L_y) \\propto \\sin(\\pi L_y / L_y) = \\sin(\\pi) = 0$。其他边界同样如此。因此，在采样后无需对边界速度进行显式修改。\n- 连续的解析散度恰好为零。计算出的离散散度将是一个小的非零值，代表了二阶有限差分格式的截断误差。\n\n**用例 B：均匀流**\n- 参数：$L_x = 3$ m, $L_y = 2$ m, $N_x = 9$, $N_y = 6$, $U_0 = 0.5$ m/s。\n- 初始速度场为 $u(x,y) = U_0$ 和 $v(x,y) = 0$。我们将 $u$-数组初始化为 $U_0$，$v$-数组初始化为 $0$。\n- 这个初始场在西边界和东边界违反了无法向流条件。我们必须通过将 $u$ 数组的第一列和最后一列设置为 $0$ 来强制施加这些条件：$u_{0,j} = 0$ 和 $u_{N_x, j} = 0$。$v$-场已经满足了南边界和北边界的条件。\n- 然后计算散度。它将仅在邻近西边界和东边界的网格单元中为非零。\n- 对于最西侧列（$i=0$）中的单元，散度为 $\\frac{u_{1, j} - u_{0, j}}{\\Delta x} = \\frac{U_0 - 0}{\\Delta x}$。\n- 对于最东侧列（$i=N_x-1$）中的单元，散度为 $\\frac{u_{N_x, j} - u_{N_x-1, j}}{\\Delta x} = \\frac{0 - U_0}{\\Delta x}$。\n- 对于所有内部单元，散度为 $0$。\n- 因此，$D_{\\max} = \\left| \\frac{U_0}{\\Delta x} \\right| = \\frac{0.5}{3/9} = \\frac{0.5}{1/3} = 1.5$ s$^{-1}$。\n\n**用例 C：单网格单元涡旋**\n- 参数：$L_x = 1$ m, $L_y = 1$ m, $N_x = 1$, $N_y = 1$。\n- 速度场与用例 A 相同，但在一个最小的 $1 \\times 1$ 网格上采样。\n- 该网格由一个单元组成。我们需要计算 $u_{0,0}$、$u_{1,0}$、$v_{0,0}$ 和 $v_{0,1}$。\n- 速度分量的网格位置：\n  - $u_{0,0}$ 位于 $(x,y) = (0, 0.5)$。$u(0, 0.5) \\propto \\sin(0) = 0$。\n  - $u_{1,0}$ 位于 $(x,y) = (1, 0.5)$。$u(1, 0.5) \\propto \\sin(\\pi) = 0$。\n  - $v_{0,0}$ 位于 $(x,y) = (0.5, 0)$。$v(0.5, 0) \\propto \\sin(0) = 0$。\n  - $v_{0,1}$ 位于 $(x,y) = (0.5, 1)$。$v(0.5, 1) \\propto \\sin(\\pi) = 0$。\n- 由于特定的采样位置恰好落在三角函数的零点上，所有相关的速度分量都恰好为零。\n- 离散散度为 $\\frac{u_{1,0} - u_{0,0}}{\\Delta x} + \\frac{v_{0,1} - v_{0,0}}{\\Delta y} = \\frac{0-0}{1} + \\frac{0-0}{1} = 0$。\n- 因此，$D_{\\max} = 0$。\n\n实现过程将通过构建一个函数来完成，该函数接收用例参数，建立网格，填充并修正速度场，计算散度，并返回最大绝对值。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_dmax(params: dict) -> float:\n    \"\"\"\n    Calculates the maximum absolute divergence on an Arakawa C-grid.\n\n    Args:\n        params: A dictionary containing the parameters for the simulation case.\n                Keys include 'case', 'Lx', 'Ly', 'Nx', 'Ny', and 'U0' if applicable.\n\n    Returns:\n        The maximum absolute value of the discrete divergence (D_max).\n    \"\"\"\n    case = params['case']\n    Lx, Ly = params['Lx'], params['Ly']\n    Nx, Ny = int(params['Nx']), int(params['Ny'])\n\n    dx = Lx / Nx\n    dy = Ly / Ny\n\n    u_shape = (Nx + 1, Ny)\n    v_shape = (Nx, Ny + 1)\n    \n    if case in ['A', 'C']:\n        # Case A and C: Vortex-type incompressible flow via streamfunction\n        \n        # Create coordinate grids for u and v velocity components.\n        # u is located at (i*dx, (j+0.5)*dy)\n        u_x_coords = np.linspace(0.0, Lx, Nx + 1)\n        u_y_coords = np.linspace(0.5 * dy, Ly - 0.5 * dy, Ny)\n        u_xx, u_yy = np.meshgrid(u_x_coords, u_y_coords, indexing='ij')\n\n        # v is located at ((i+0.5)*dx, j*dy)\n        v_x_coords = np.linspace(0.5 * dx, Lx - 0.5 * dx, Nx)\n        v_y_coords = np.linspace(0.0, Ly, Ny + 1)\n        v_xx, v_yy = np.meshgrid(v_x_coords, v_y_coords, indexing='ij')\n\n        # Populate velocity fields using the analytic functions.\n        # The analytic functions naturally satisfy the no-normal-flow boundary conditions.\n        u = (np.pi / Ly) * np.cos(np.pi * u_yy / Ly) * np.sin(np.pi * u_xx / Lx)\n        v = -(np.pi / Lx) * np.cos(np.pi * v_xx / Lx) * np.sin(np.pi * v_yy / Ly)\n        \n    elif case == 'B':\n        # Case B: Uniform flow that violates no-normal-flow initially\n        U0 = params['U0']\n        \n        # Initialize uniform velocity fields.\n        u = np.full(u_shape, U0)\n        v = np.zeros(v_shape)\n\n        # Enforce no-normal-flow boundary conditions (impermeable walls).\n        # Set u=0 at western (i=0) and eastern (i=Nx) boundaries.\n        u[0, :] = 0.0\n        u[-1, :] = 0.0\n        \n        # Set v=0 at southern (j=0) and northern (j=Ny) boundaries.\n        # The v field is already initialized to zeros, so this is satisfied.\n        v[:, 0] = 0.0\n        v[:, -1] = 0.0\n\n    else:\n        raise ValueError(f\"Unknown case: {case}\")\n\n    # Calculate the discrete divergence at each cell center.\n    # The divergence field has dimensions (Nx, Ny).\n    # du_dx corresponds to (u_{i+1,j} - u_{i,j}) / dx\n    # dv_dy corresponds to (v_{i,j+1} - v_{i,j}) / dy\n    \n    du_dx = (u[1:, :] - u[:-1, :]) / dx\n    dv_dy = (v[:, 1:] - v[:, :-1]) / dy\n\n    divergence = du_dx + dv_dy\n    \n    # Compute the maximum absolute value of the divergence.\n    d_max = np.max(np.abs(divergence))\n    \n    return d_max\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'case': 'A', 'Lx': 1.0, 'Ly': 1.0, 'Nx': 16, 'Ny': 12},\n        {'case': 'B', 'Lx': 3.0, 'Ly': 2.0, 'Nx': 9, 'Ny': 6, 'U0': 0.5},\n        {'case': 'C', 'Lx': 1.0, 'Ly': 1.0, 'Nx': 1, 'Ny': 1},\n    ]\n\n    results = []\n    for params in test_cases:\n        result = calculate_dmax(params)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "许多地球系统流体模型（如海洋和部分大气模型）都基于不可压缩假设，即速度场的散度为零（$\\nabla \\cdot \\mathbf{u} = 0$）。投影法是强制满足此约束的经典算法，其核心是求解一个关于压力的泊松方程。本练习将带您在阿拉卡瓦A网格和C网格上同时实现投影法，通过对比二者的表现，深刻揭示C网格在避免数值伪模和保持算子相容性方面的优势 ()。",
            "id": "3862986",
            "problem": "考虑 Boussinesq 近似下密度恒定的不可压缩动量方程，其中速度场受无散度条件的约束。核心约束是速度场 $\\mathbf{u} = (u, v)$ 必须满足 $\\nabla \\cdot \\mathbf{u} = 0$。在不可压缩流的投影方法中，我们先计算一个不一定满足无散度约束的中间速度 $\\mathbf{u}^{\\ast}$，然后使用一个标量压力场 $p$ 将其投影到无散度场空间，使得修正后的速度 $\\mathbf{u}^{n+1}$ 是无散度的。投影步骤强制要求 $\\mathbf{u}^{n+1} = \\mathbf{u}^{\\ast} - \\Delta t \\nabla p$ 与 $\\nabla \\cdot \\mathbf{u}^{n+1} = 0$ 同时成立，这意味着压力的离散泊松方程为，\n$$\n\\nabla^2 p = \\frac{1}{\\Delta t} \\nabla \\cdot \\mathbf{u}^{\\ast},\n$$\n并采用周期性边界条件。在 Arakawa 网格交错布置中，有两种典型的布局：Arakawa A-网格（所有预报变量位于单元中心）和 Arakawa C-网格（压力位于单元中心，$u$ 速度分量位于垂直单元面，$v$ 速度分量位于水平单元面）。对于一个具有 $N_x \\times N_y$ 个单元、网格间距为 $\\Delta x$ 和 $\\Delta y$、时间步长为 $\\Delta t$ 的均匀二维周期性矩形域，请在 Arakawa A-网格和 Arakawa C-网格上实现投影方法，使用与各网格布局相对应的离散算子：\n- 在 Arakawa C-网格上，将单元中心的离散散度定义为面法向通量的差分，并将离散梯度定义为与散度算子相一致的单元中心压力的面法向差分。\n- 在 Arakawa A-网格上，使用与周期性边界条件相一致的二阶中心差分来定义单元中心的离散散度和梯度。\n\n使用一个周期性离散泊松求解器来获取单元中心的压力 $p$。该求解器必须能处理周期性边界条件下的离散泊松方程，包括与常数模态相关的零空间。您的程序必须为每个测试用例计算比率\n$$\nR = \\frac{\\|\\nabla \\cdot \\mathbf{u}^{n+1}\\|_2}{\\|\\nabla \\cdot \\mathbf{u}^{\\ast}\\|_2},\n$$\n其中 $\\|\\cdot\\|_2$ 表示在所有单元中心集合上的离散 $\\ell^2$ 范数。如果分母为零，则定义 $R = 0$。\n\n根据网格类型，以一种确定性且尊重周期性的方式构造中间速度 $\\mathbf{u}^{\\ast}$。对于每个测试，使用以下构造场：\n- Arakawa C-网格：$u^{\\ast}$ 定义在由 $(i,j)$ 索引的垂直面上，其中 $i = 0, \\ldots, N_x$ 且 $j = 0, \\ldots, N_y-1$；$v^{\\ast}$ 定义在由 $(i,j)$ 索引的水平面上，其中 $i = 0, \\ldots, N_x-1$ 且 $j = 0, \\ldots, N_y$。具体如下：\n$$\nu^{\\ast}_{i,j} = \\sin\\left( \\frac{2\\pi i}{N_x} \\right) + 0.3 \\cos\\left( \\frac{2\\pi j}{N_y} \\right), \\quad v^{\\ast}_{i,j} = 0.7 \\cos\\left( \\frac{2\\pi i}{N_x} \\right) - \\sin\\left( \\frac{2\\pi j}{N_y} \\right).\n$$\n- Arakawa A-网格：$u^{\\ast}$ 和 $v^{\\ast}$ 定义在由 $(i,j)$ 索引的单元中心，其中 $i = 0, \\ldots, N_x-1$ 且 $j = 0, \\ldots, N_y-1$。具体如下：\n$$\nu^{\\ast}_{i,j} = \\sin\\left( \\frac{2\\pi i}{N_x} \\right) + 0.3 \\cos\\left( \\frac{2\\pi j}{N_y} \\right), \\quad v^{\\ast}_{i,j} = 0.7 \\cos\\left( \\frac{2\\pi i}{N_x} \\right) - \\sin\\left( \\frac{2\\pi j}{N_y} \\right).\n$$\n这些定义确保了周期性。离散算子和投影步骤的构造方式必须使其在所选网格上是伴随一致的，即 $\\nabla^2$ 是梯度的散度。\n\n使用快速傅里叶变换（FFT）方法实现一个用于求解单元中心压力 $p$ 的周期性离散泊松求解器。该求解器必须通过选择压力均值为零来显式处理零波数。\n\n测试套件：\n提供以下四组参数集的结果。每个测试用例是一个元组 $(\\text{grid\\_type}, N_x, N_y, \\Delta x, \\Delta y, \\Delta t)$，其中 $\\text{grid\\_type} \\in \\{\\text{\"C\"}, \\text{\"A\"}\\}$：\n1. $(\\text{\"C\"}, 16, 12, 1.0, 2.0, 0.2)$\n2. $(\\text{\"A\"}, 16, 12, 1.0, 2.0, 0.15)$\n3. $(\\text{\"C\"}, 3, 3, 1.3, 0.9, 0.25)$\n4. $(\\text{\"A\"}, 8, 2, 0.8, 1.2, 0.05)$\n\n最终输出格式：\n您的程序应生成单行输出，其中包含四个测试用例的 $R$ 值，格式为方括号内以逗号分隔的列表（例如，“[r1,r2,r3,r4]”）。不需要物理单位；所有量均为无量纲。三角函数中出现的所有角度，根据离散算子的构造，均以弧度为单位。输出值必须是浮点数。",
            "solution": "该问题要求实现一种投影方法，以在二维周期性域上对速度场强制施加不可压缩性约束。这是计算流体动力学中模拟不可压缩流的一项基本技术。该方法的有效性将在两种不同的网格交错布置上进行评估：Arakawa A-网格（同位网格）和 Arakawa C-网格（交错网格）。性能指标是投影后速度散度的 $\\ell^2$ 范数与投影前速度散度的 $\\ell^2$ 范数之比 $R$。\n\n投影法是一种分数步长算法。给定一个时间步长上不一定无散度的中间速度场 $\\mathbf{u}^{\\ast} = (u^{\\ast}, v^{\\ast})$，目标是找到一个涉及标量压力场 $p$ 的修正项，使得最终的速度场 $\\mathbf{u}^{n+1}$ 是无散度的。这是通过将 $\\mathbf{u}^{\\ast}$ 投影到无散度矢量场空间来实现的。该投影由两个条件定义：\n1. 速度通过压力梯度进行更新：\n$$ \\mathbf{u}^{n+1} = \\mathbf{u}^{\\ast} - \\Delta t \\nabla p $$\n其中 $\\Delta t$ 是时间步长。\n2. 最终速度场必须是无散度的：\n$$ \\nabla \\cdot \\mathbf{u}^{n+1} = 0 $$\n对第一个方程求散度，并代入第二个方程，可得：\n$$ \\nabla \\cdot (\\mathbf{u}^{\\ast} - \\Delta t \\nabla p) = 0 $$\n$$ \\nabla \\cdot \\mathbf{u}^{\\ast} - \\Delta t \\nabla^2 p = 0 $$\n这就得到了关于压力场 $p$ 的泊松方程：\n$$ \\nabla^2 p = \\frac{1}{\\Delta t} \\nabla \\cdot \\mathbf{u}^{\\ast} $$\n该方程的解提供了将速度场投影到无散度子空间所需的压力。问题指定了尺寸为 $N_x \\times N_y$ 个单元、网格间距为 $\\Delta x$ 和 $\\Delta y$ 的矩形域的周期性边界条件。\n\n散度 ($\\nabla \\cdot$)、梯度 ($\\nabla$) 和拉普拉斯 ($\\nabla^2$) 算子的离散化取决于网格布局。\n\n在 Arakawa A-网格上，所有变量（$u, v, p$）都位于单元中心，由 $(i,j)$ 索引，其中 $i=0, \\dots, N_x-1$ 且 $j=0, \\dots, N_y-1$。我们对算子使用二阶中心有限差分：\n在单元 $(i,j)$ 处，速度场 $\\mathbf{u}=(u,v)$ 的散度为：\n$$ (\\nabla \\cdot \\mathbf{u})_{i,j} = \\frac{u_{i+1,j} - u_{i-1,j}}{2 \\Delta x} + \\frac{v_{i,j+1} - v_{i,j-1}}{2 \\Delta y} $$\n在单元 $(i,j)$ 处，标量压力场 $p$ 的梯度为：\n$$ (\\nabla p)_{x, i,j} = \\frac{p_{i+1,j} - p_{i-1,j}}{2 \\Delta x}, \\quad (\\nabla p)_{y, i,j} = \\frac{p_{i,j+1} - p_{i,j-1}}{2 \\Delta y} $$\n所有索引都进行周期性处理（例如，$u_{N_x, j} = u_{0, j}$，$u_{-1, j} = u_{N_x-1, j}$）。\n\n在 Arakawa C-网格上，变量是交错布置的。压力 $p$ 位于单元中心 $(i,j)$。水平速度分量 $u$ 位于垂直单元面上，此处的索引方式使得 $u_{i,j}$ 位于单元 $(i-1,j)$ 和 $(i,j)$ 之间的面上。垂直速度分量 $v$ 位于水平单元面上，其中 $v_{i,j}$ 位于单元 $(i,j-1)$ 和 $(i,j)$ 之间的面上。\n单元中心 $(i,j)$ 的离散散度定义为流出该单元的净通量：\n$$ (\\nabla \\cdot \\mathbf{u})_{i,j} = \\frac{u_{i+1,j} - u_{i,j}}{\\Delta x} + \\frac{v_{i,j+1} - v_{i,j}}{\\Delta y} $$\n单元中心压力 $p$ 的离散梯度在单元面上产生分量，与速度分量的位置相一致：\n$$ (\\nabla p)_{x, i,j} = \\frac{p_{i,j} - p_{i-1,j}}{\\Delta x}, \\quad (\\nabla p)_{y, i,j} = \\frac{p_{i,j} - p_{i,j-1}}{\\Delta y} $$\nC-网格交错布置的一个重要特性是，通过组合散度算子和梯度算子（$\\nabla^2 = \\nabla \\cdot \\nabla$）构成的离散拉普拉斯算子，会得到标准的五点模板，这与 A-网格的二阶中心拉普拉斯算子相同：\n$$ (\\nabla^2 p)_{i,j} = \\frac{p_{i+1,j} - 2 p_{i,j} + p_{i-1,j}}{(\\Delta x)^2} + \\frac{p_{i,j+1} - 2 p_{i,j} + p_{i,j-1}}{(\\Delta y)^2} $$\n这种伴随一致性是 C-网格的一个关键优势。\n\n对于两种网格，中间速度场 $\\mathbf{u}^{\\ast}$ 都由一个构造解给出。这些场的位置由问题指定：\n对于 A-网格，$u^{\\ast}$ 和 $v^{\\ast}$ 定义在单元中心 $(i,j)$：\n$$ u^{\\ast}_{i,j} = \\sin\\left( \\frac{2\\pi i}{N_x} \\right) + 0.3 \\cos\\left( \\frac{2\\pi j}{N_y} \\right), \\quad v^{\\ast}_{i,j} = 0.7 \\cos\\left( \\frac{2\\pi i}{N_x} \\right) - \\sin\\left( \\frac{2\\pi j}{N_y} \\right) $$\n对于 C-网格，$u^{\\ast}$ 定义在垂直面上，$v^{\\ast}$ 定义在水平面上，使用相同的函数形式，但应用于各自的交错网格坐标。\n\n离散泊松方程 $\\hat{L}p = f$，其中 $\\hat{L}$ 是离散拉普拉斯算子，$f = \\frac{1}{\\Delta t} \\nabla \\cdot \\mathbf{u}^{\\ast}$，可以使用快速傅里叶变换（FFT）高效求解。对该方程应用二维离散傅里叶变换，将拉普拉斯算子的空间卷积转换成傅里叶空间中的简单乘法：\n$$ \\tilde{L}_{m,n} \\tilde{p}_{m,n} = \\tilde{f}_{m,n} $$\n其中 $\\tilde_.$ 表示傅里叶变换，$(m, n)$ 是整数波数索引。五点拉普拉斯算子的傅里叶符号 $\\tilde{L}_{m,n}$ 是：\n$$ \\tilde{L}_{m,n} = -\\frac{4}{(\\Delta x)^2} \\sin^2\\left(\\frac{\\pi m}{N_x}\\right) - \\frac{4}{(\\Delta y)^2} \\sin^2\\left(\\frac{\\pi n}{N_y}\\right) $$\n对于零波数模式 $(m,n)=(0,0)$，$\\tilde{L}_{0,0} = 0$。这反映了压力解的唯一性只在相差一个任意常数的情况下成立。问题指定通过强制压力均值为零来解决这个模糊性，这对应于将其傅里叶变换的零波数分量设为零：$\\tilde{p}_{0,0} = 0$。对于所有其他模式 $(m,n) \\neq (0,0)$，傅里叶空间中的压力为 $\\tilde{p}_{m,n} = \\tilde{f}_{m,n} / \\tilde{L}_{m,n}$。然后通过应用二维逆傅里叶变换恢复压力场 $p$。\n\n每个测试用例的总体算法如下：\n1. 在相应的网格（A 或 C）上构造中间速度场 $u^{\\ast}$ 和 $v^{\\ast}$。\n2. 使用适合该网格的离散散度算子计算初始散度场 $D^{\\ast} = \\nabla \\cdot \\mathbf{u}^{\\ast}$。\n3. 计算比率的分母：$\\|\\nabla \\cdot \\mathbf{u}^{\\ast}\\|_2 = \\|D^{\\ast}\\|_2$。如果此范数为零，则 $R=0$。\n4. 使用基于 FFT 的求解器求解离散泊松方程 $\\nabla^2 p = \\frac{1}{\\Delta t} D^{\\ast}$ 以得到 $p$。\n5. 使用适合该网格的离散梯度算子计算压力梯度 $\\nabla p$。\n6. 计算投影后的速度场：$\\mathbf{u}^{n+1} = \\mathbf{u}^{\\ast} - \\Delta t \\nabla p$。\n7. 计算最终的散度场 $D^{n+1} = \\nabla \\cdot \\mathbf{u}^{n+1}$。\n8. 计算比率的分子：$\\|\\nabla \\cdot \\mathbf{u}^{n+1}\\|_2 = \\|D^{n+1}\\|_2$。\n9. 计算最终比率 $R = \\|\\nabla \\cdot \\mathbf{u}^{n+1}\\|_2 / \\|\\nabla \\cdot \\mathbf{u}^{\\ast}\\|_2$。该比率应接近浮点零，表示投影成功。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function that iterates through test cases and prints the results.\n    \"\"\"\n    test_cases = [\n        (\"C\", 16, 12, 1.0, 2.0, 0.2),\n        (\"A\", 16, 12, 1.0, 2.0, 0.15),\n        (\"C\", 3, 3, 1.3, 0.9, 0.25),\n        (\"A\", 8, 2, 0.8, 1.2, 0.05),\n    ]\n\n    results = []\n    for case in test_cases:\n        grid_type, Nx, Ny, dx, dy, dt = case\n        \n        # --- 1. Construct intermediate velocity fields u* ---\n        if grid_type == \"A\":\n            # Collocated grid: u*, v*, p are at cell centers (Nx, Ny)\n            i_coords, j_coords = np.mgrid[0:Nx, 0:Ny]\n            u_star = np.sin(2 * np.pi * i_coords / Nx) + 0.3 * np.cos(2 * np.pi * j_coords / Ny)\n            v_star = 0.7 * np.cos(2 * np.pi * i_coords / Nx) - np.sin(2 * np.pi * j_coords / Ny)\n        elif grid_type == \"C\":\n            # Staggered grid: p at centers, u on vertical faces, v on horizontal faces\n            # u* on vertical faces: (Nx+1, Ny) with u[0,:]=u[Nx,:]\n            i_u, j_u = np.mgrid[0:Nx + 1, 0:Ny]\n            u_star = np.sin(2 * np.pi * i_u / Nx) + 0.3 * np.cos(2 * np.pi * j_u / Ny)\n            # v* on horizontal faces: (Nx, Ny+1) with v[:,0]=v[:,Ny]\n            i_v, j_v = np.mgrid[0:Nx, 0:Ny + 1]\n            v_star = 0.7 * np.cos(2 * np.pi * i_v / Nx) - np.sin(2 * np.pi * j_v / Ny)\n\n        # --- 2. Compute initial divergence div(u*) ---\n        if grid_type == \"A\":\n            du_dx = (np.roll(u_star, -1, axis=0) - np.roll(u_star, 1, axis=0)) / (2 * dx)\n            dv_dy = (np.roll(v_star, -1, axis=1) - np.roll(v_star, 1, axis=1)) / (2 * dy)\n            div_u_star = du_dx + dv_dy\n        elif grid_type == \"C\":\n            du_dx = (u_star[1:, :] - u_star[:-1, :]) / dx\n            dv_dy = (v_star[:, 1:] - v_star[:, :-1]) / dy\n            div_u_star = du_dx + dv_dy\n\n        # --- 3. Compute L2 norm of initial divergence ---\n        norm_div_u_star = np.linalg.norm(div_u_star)\n        if norm_div_u_star == 0.0:\n            results.append(0.0)\n            continue\n            \n        # --- 4. Solve Poisson equation for pressure p ---\n        # Right-hand side of the Poisson equation\n        rhs = div_u_star / dt\n        \n        # FFT of the RHS\n        rhs_tilde = np.fft.fft2(rhs)\n        \n        # Wavenumbers for the FFT\n        m = np.fft.fftfreq(Nx) * Nx\n        n = np.fft.fftfreq(Ny) * Ny\n        mm, nn = np.meshgrid(m, n, indexing='ij')\n\n        # Fourier symbol of the Laplacian operator\n        laplacian_tilde = (-4 / (dx**2)) * np.sin(np.pi * mm / Nx)**2 \\\n                        + (-4 / (dy**2)) * np.sin(np.pi * nn / Ny)**2\n        \n        # Avoid division by zero for the zero-wavenumber mode\n        laplacian_tilde[0, 0] = 1.0\n        \n        # Solve for p in Fourier space\n        p_tilde = rhs_tilde / laplacian_tilde\n        \n        # Enforce zero mean pressure\n        p_tilde[0, 0] = 0.0\n        \n        # Inverse FFT to get pressure in physical space\n        p = np.fft.ifft2(p_tilde).real\n\n        # --- 5. Compute pressure gradient grad(p) ---\n        if grid_type == \"A\":\n            grad_p_x = (np.roll(p, -1, axis=0) - np.roll(p, 1, axis=0)) / (2 * dx)\n            grad_p_y = (np.roll(p, -1, axis=1) - np.roll(p, 1, axis=1)) / (2 * dy)\n        elif grid_type == \"C\":\n            # Gradient on x-faces\n            grad_p_x = (p - np.roll(p, 1, axis=0)) / dx\n            # Extend to be periodic with shape (Nx+1, Ny)\n            grad_p_x = np.concatenate((grad_p_x, grad_p_x[0:1, :]), axis=0)\n\n            # Gradient on y-faces\n            grad_p_y = (p - np.roll(p, 1, axis=1)) / dy\n            # Extend to be periodic with shape (Nx, Ny+1)\n            grad_p_y = np.concatenate((grad_p_y, grad_p_y[:, 0:1]), axis=1)\n\n        # --- 6. Update velocity to be u_new = u_star - dt*grad(p) ---\n        u_new = u_star - dt * grad_p_x\n        v_new = v_star - dt * grad_p_y\n\n        # --- 7. Compute final divergence div(u_new) ---\n        if grid_type == \"A\":\n            du_dx_new = (np.roll(u_new, -1, axis=0) - np.roll(u_new, 1, axis=0)) / (2 * dx)\n            dv_dy_new = (np.roll(v_new, -1, axis=1) - np.roll(v_new, 1, axis=1)) / (2 * dy)\n            div_u_new = du_dx_new + dv_dy_new\n        elif grid_type == \"C\":\n            du_dx_new = (u_new[1:, :] - u_new[:-1, :]) / dx\n            dv_dy_new = (v_new[:, 1:] - v_new[:, :-1]) / dy\n            div_u_new = du_dx_new + dv_dy_new\n\n        # --- 8. Compute L2 norm of final divergence ---\n        norm_div_u_new = np.linalg.norm(div_u_new)\n\n        # --- 9. Compute the ratio R ---\n        ratio = norm_div_u_new / norm_div_u_star\n        results.append(ratio)\n        \n    print(f\"[{','.join(f'{r:.15e}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "真实世界的地球物理模拟常常需要使用曲线坐标系来更好地拟合不规则的地理边界或地球的曲率。在这样的坐标系中，控制方程会引入“地图因子”（或称尺度因子），这要求我们重新推导和实现离散算子。本练习将引导您从基本守恒定律出发，为正交曲线坐标系推导并实现一个保守的离散散度算子，从而掌握在高级模型开发中处理复杂几何的关键技能 ()。",
            "id": "3862994",
            "problem": "您的任务是使用 Arakawa 网格交错，为正交曲线网格设计并实现一个保守的、有限体积的离散散度算子，并在几个测试用例上验证其性质。计算必须遵循基于质量守恒连续性方程的第一性原理。\n\n从不可压缩流在正交曲线坐标 $(\\xi,\\eta)$ 中的连续性方程微分形式开始，其尺度因子为 $h_\\xi(\\xi,\\eta)$ 和 $h_\\eta(\\xi,\\eta)$：\n$$\n\\nabla \\cdot \\mathbf{u} \\;=\\; \\frac{1}{h_\\xi h_\\eta}\\left(\\frac{\\partial}{\\partial \\xi}\\big(h_\\eta \\, u_\\xi\\big) \\;+\\; \\frac{\\partial}{\\partial \\eta}\\big(h_\\xi \\, u_\\eta\\big)\\right),\n$$\n其中 $u_\\xi$ 和 $u_\\eta$ 分别是与 $\\xi$ 和 $\\eta$ 坐标对齐的逆变速度分量。该关系通过速度场的散度表达了质量守恒，并且是您推导离散算子所必须依据的基础表达式。\n\n使用 Arakawa C-网格交错，其配置如下：\n- 标量场（例如，质量或类压力量，以及本任务中的散度本身）位于网格中心，索引为 $(i,j)$。\n- 与 $\\xi$ 对齐的逆变速度分量 $u_\\xi$ 位于垂直于 $\\xi$ 方向且沿 $\\eta$ 方向居中的网格面上，索引为 $(i+\\tfrac{1}{}{2},j)$。\n- 与 $\\eta$ 对齐的逆变速度分量 $u_\\eta$ 位于垂直于 $\\eta$ 方向且沿 $\\xi$ 方向居中的网格面上，索引为 $(i,j+\\tfrac{1}{}{2})$。\n\n假设在单位正方形 $[0,1]\\times[0,1]$ 上，$\\xi$ 和 $\\eta$ 方向均为周期性域，对于整数 $N_x$ 和 $N_y$，均匀计算间距为 $\\Delta \\xi = 1/N_x$ 和 $\\Delta \\eta = 1/N_y$。尺度因子 $h_\\xi$ 和 $h_\\eta$ 的单位是米/坐标单位，速度分量 $u_\\xi$ 和 $u_\\eta$ 的单位是米/秒，散度 $\\nabla \\cdot \\mathbf{u}$ 必须以 $\\mathrm{s}^{-1}$ 表示。\n\n您的程序必须：\n1. 推导、论证并实现在网格中心处的有限体积离散散度。该散度使用跨网格面的通量，并包含尺度因子 $h_\\xi$ 和 $h_\\eta$，以确保格式是保守的且与上述正交曲线散度公式一致。设计必须能正确处理带有周期性边界条件的 Arakawa C-网格索引。\n2. 构建以下测试套件并计算指定的误差度量。三角函数中的所有角度均以弧度为单位。对于所有情况，以 $\\mathrm{s}^{-1}$ 为单位报告所要求的输出。\n\n按如下方式定义网格坐标数组：\n- 网格中心坐标：$\\xi_i = \\frac{i+\\tfrac{1}{}{2}}{N_x}$，其中 $i = 0,1,\\dots,N_x-1$；以及 $\\eta_j = \\frac{j+\\tfrac{1}{}{2}}{N_y}$，其中 $j = 0,1,\\dots,N_y-1$。\n- $\\xi$-面坐标：$\\xi^{(u)}_i = \\frac{i}{N_x}$，其中 $i = 0,1,\\dots,N_x-1$，且沿 $\\eta$ 方向以 $\\eta_j$ 为中心。\n- $\\eta$-面坐标：$\\eta^{(v)}_j = \\frac{j}{N_y}$，其中 $j = 0,1,\\dots,N_y-1$，且沿 $\\xi$ 方向以 $\\xi_i$ 为中心。\n\n对于曲线网格测试，通过以下公式定义尺度因子：\n$$\nh_\\xi(\\xi,\\eta) \\;=\\; 1 \\;+\\; a \\,\\sin(2\\pi \\xi)\\,\\cos(2\\pi \\eta), \\quad\nh_\\eta(\\xi,\\eta) \\;=\\; 1 \\;+\\; a \\,\\cos(2\\pi \\xi)\\,\\sin(2\\pi \\eta),\n$$\n其中 $a=0.3$，对于均匀网格测试，使用 $h_\\xi = 1, h_\\eta = 1$。\n\n定义以下测试用例：\n- A 例 (均匀网格，恒定流场)：$N_x = 16$，$N_y = 16$，$h_\\xi = 1$，$h_\\eta = 1$，所有 $\\xi$-面上的 $u_\\xi = U_0$（其中 $U_0 = 3$ m/s），所有 $\\eta$-面上的 $u_\\eta = 0$。计算所有网格上的最大绝对散度，并以 $\\mathrm{s}^{-1}$ 为单位报告。\n- B 例 (曲线网格，通过流函数得到的无散度解析场)：$N_x = 32$，$N_y = 24$，使用如上定义的曲线尺度因子 $h_\\xi(\\xi,\\eta)$ 和 $h_\\eta(\\xi,\\eta)$。定义流函数 $\\psi(\\xi,\\eta) = \\sin(2\\pi \\xi)\\,\\sin(2\\pi \\eta)$，并通过在 $\\xi$-面 $(\\xi^{(u)}_i,\\eta_j)$ 上计算 $u_\\xi = \\frac{1}{h_\\eta}\\,\\frac{\\partial \\psi}{\\partial \\eta}$ 和在 $\\eta$-面 $(\\xi_i,\\eta^{(v)}_j)$ 上计算 $u_\\eta = -\\frac{1}{h_\\xi}\\,\\frac{\\partial \\psi}{\\partial \\xi}$ 来设置逆变分量。计算并报告所有网格上离散散度的均方根值，单位为 $\\mathrm{s}^{-1}$。\n- C 例 (均匀网格，周期性解析散度)：$N_x = 3$，$N_y = 3$，$h_\\xi = 1$，$h_\\eta = 1$，$u_\\xi(\\xi,\\eta) = \\sin(2\\pi \\xi)$ 位于 $\\xi$-面 $(\\xi^{(u)}_i,\\eta_j)$ 上，$u_\\eta(\\xi,\\eta) = \\sin(2\\pi \\eta)$ 位于 $\\eta$-面 $(\\xi_i,\\eta^{(v)}_j)$ 上。网格中心处的解析散度为 $\\nabla\\cdot\\mathbf{u} = 2\\pi \\cos(2\\pi \\xi) + 2\\pi \\cos(2\\pi \\eta)$。计算离散散度与解析散度之间的均方根误差，并以 $\\mathrm{s}^{-1}$ 为单位报告。\n- D 例 (曲线网格，随机周期性速度，守恒性检验)：$N_x = 17$，$N_y = 19$，使用如上定义的曲线尺度因子 $h_\\xi(\\xi,\\eta)$ 和 $h_\\eta(\\xi,\\eta)$，并确定性地为伪随机数生成器设置种子。在各自的面上生成 $u_\\xi$ 和 $u_\\eta$ 作为独立的随机值。计算面积加权平均散度，定义为\n$$\n\\overline{D} \\;=\\; \\frac{\\sum_{i,j}\\big(\\nabla\\cdot\\mathbf{u}\\big)_{i,j} \\, h_{\\xi,i,j}\\,h_{\\eta,i,j}\\,\\Delta\\xi\\,\\Delta\\eta}{\\sum_{i,j} h_{\\xi,i,j}\\,h_{\\eta,i,j}\\,\\Delta\\xi\\,\\Delta\\eta},\n$$\n并以 $\\mathrm{s}^{-1}$ 为单位报告 $|\\overline{D}|$。\n\n您的程序必须产生单行输出，其中包含一个用方括号括起来的逗号分隔列表，按四个案例的顺序排列：$[\\text{CaseA},\\text{CaseB},\\text{CaseC},\\text{CaseD}]$。每个条目必须是 $s^{-1}$ 为单位的浮点数（对于 D 例，由于面积平均，单位也是 $s^{-1}$）。不得打印任何额外文本。实现必须是自包含的，不需要用户输入，并遵循带有周期性环绕的精确 Arakawa C-网格索引。请从给定的基本方程仔细论证您的计算模板、索引和尺度因子的使用，不要在问题陈述中引入快捷公式。",
            "solution": "该问题要求针对带有 Arakawa C-网格交错的正交曲线网格，设计并实现一个保守的有限体积散度算子。推导过程必须基于所提供的连续性方程的微分形式。\n\n### 步骤 1：离散散度算子的推导\n\n有限体积法的基础是守恒律的积分形式。给定的不可压缩流体连续性方程的微分形式为：\n$$\n\\nabla \\cdot \\mathbf{u} \\;=\\; \\frac{1}{h_\\xi h_\\eta}\\left(\\frac{\\partial}{\\partial \\xi}\\big(h_\\eta \\, u_\\xi\\big) \\;+\\; \\frac{\\partial}{\\partial \\eta}\\big(h_\\xi \\, u_\\eta\\big)\\right)\n$$\n其中 $(\\xi, \\eta)$ 是带有尺度因子 $h_\\xi$ 和 $h_\\eta$ 的正交曲线坐标，$\\mathbf{u} = (u_\\xi, u_\\eta)$ 是具有逆变分量的速度矢量。\n\n为了推导有限体积离散格式，我们将此方程在一个网格单元（或控制体积）$V_{i,j}$ 上积分。该单元以坐标 $(\\xi_i, \\eta_j)$ 为中心，在 $\\xi$ 方向上从 $\\xi_i - \\frac{\\Delta\\xi}{2}$ 延伸到 $\\xi_i + \\frac{\\Delta\\xi}{2}$，在 $\\eta$ 方向上从 $\\eta_j - \\frac{\\Delta\\eta}{2}$ 延伸到 $\\eta_j + \\frac{\\Delta\\eta}{2}$。物理空间中的微分面积元为 $dA = h_\\xi h_\\eta d\\xi d\\eta$。\n\n将该方程在物理空间的单元面积上积分，我们得到：\n$$\n\\iint_{V_{i,j}} (\\nabla \\cdot \\mathbf{u}) \\, h_\\xi h_\\eta \\, d\\xi d\\eta = \\iint_{V_{i,j}} \\left(\\frac{\\partial}{\\partial \\xi}\\big(h_\\eta \\, u_\\xi\\big) \\;+\\; \\frac{\\partial}{\\partial \\eta}\\big(h_\\xi \\, u_\\eta\\big)\\right) d\\xi d\\eta\n$$\n\n方程左侧可以通过取网格中心处的散度值 $(\\nabla \\cdot \\mathbf{u})_{i,j}$，并乘以该单元的面积 $A_{i,j}$ 来近似。单元面积近似为 $A_{i,j} \\approx h_{\\xi,i,j} h_{\\eta,i,j} \\Delta\\xi \\Delta\\eta$，其中 $h_{\\xi,i,j}$ 和 $h_{\\eta,i,j}$ 是在网格中心 $(\\xi_i, \\eta_j)$ 处求值的尺度因子。\n$$\n(\\nabla \\cdot \\mathbf{u})_{i,j} \\, A_{i,j} \\approx \\iint_{V_{i,j}} (\\nabla \\cdot \\mathbf{u}) \\, h_\\xi h_\\eta \\, d\\xi d\\eta\n$$\n\n对于方程右侧，我们应用散度定理（或在每个方向上应用微积分基本定理）：\n$$\n\\text{RHS} = \\int_{\\eta_j - \\Delta\\eta/2}^{\\eta_j + \\Delta\\eta/2} \\left[ (h_\\eta u_\\xi)\\big|_{\\xi_i+\\frac{\\Delta\\xi}{2}} - (h_\\eta u_\\xi)\\big|_{\\xi_i-\\frac{\\Delta\\xi}{2}} \\right] d\\eta + \\int_{\\xi_i - \\Delta\\xi/2}^{\\xi_i + \\Delta\\xi/2} \\left[ (h_\\xi u_\\eta)\\big|_{\\eta_j+\\frac{\\Delta\\eta}{2}} - (h_\\xi u_\\eta)\\big|_{\\eta_j-\\frac{\\Delta\\eta}{2}} \\right] d\\xi\n$$\n\n该表达式表示流出控制体积的净通量。现在，我们对该积分进行离散化。Arakawa C-网格交错将速度分量放置在控制体积的面上：\n- $u_\\xi$ 位于垂直于 $\\xi$ 方向的面上，我们用索引 $(i\\pm\\frac{1}{2}, j)$ 表示。\n- $u_\\eta$ 位于垂直于 $\\eta$ 方向的面上，我们用索引 $(i, j\\pm\\frac{1}{2})$ 表示。\n\n使用中点法则近似积分，右侧（RHS）变为：\n$$\n\\text{RHS} \\approx \\left[ (h_\\eta u_\\xi)_{i+1/2, j} - (h_\\eta u_\\xi)_{i-1/2, j} \\right] \\Delta\\eta + \\left[ (h_\\xi u_\\eta)_{i, j+1/2} - (h_\\xi u_\\eta)_{i, j-1/2} \\right] \\Delta\\xi\n$$\n此处，通量项 $(h_\\eta u_\\xi)_{i+1/2, j}$ 在单元 $(i,j)$ 的“右”面上求值，而 $(h_\\xi u_\\eta)_{i, j+1/2}$ 在“顶”面上求值。速度分量 $u_\\xi$ 和 $u_\\eta$ 已在这些位置上定义。尺度因子 $h_\\xi$ 和 $h_\\eta$ 以连续函数形式给出，必须在相应的面位置上求值以保持一致性。\n\n令两侧相等，求解离散散度 $(\\nabla \\cdot \\mathbf{u})_{i,j}$：\n$$\n(\\nabla \\cdot \\mathbf{u})_{i,j} \\approx \\frac{1}{A_{i,j}} \\left( \\left[ (h_\\eta u_\\xi)_{i+1/2, j} - (h_\\eta u_\\xi)_{i-1/2, j} \\right] \\Delta\\eta + \\left[ (h_\\xi u_\\eta)_{i, j+1/2} - (h_\\xi u_\\eta)_{i, j-1/2} \\right] \\Delta\\xi \\right)\n$$\n代入 $A_{i,j} \\approx h_{\\xi,i,j} h_{\\eta,i,j} \\Delta\\xi \\Delta\\eta$ 并化简，我们得到最终的离散公式：\n$$\n(\\nabla \\cdot \\mathbf{u})_{i,j} = \\frac{1}{h_{\\xi,i,j} h_{\\eta,i,j}} \\left( \\frac{(h_\\eta u_\\xi)_{i+1/2, j} - (h_\\eta u_\\xi)_{i-1/2, j}}{\\Delta\\xi} + \\frac{(h_\\xi u_\\eta)_{i, j+1/2} - (h_\\xi u_\\eta)_{i, j-1/2}}{\\Delta\\eta} \\right)\n$$\n这个公式是原始微分算子的一个二阶精确的中心有限差分近似，它是从保守的有限体积原理推导出来的。\n\n### 步骤 2：实现与守恒性\n在实现中，我们使用从零开始的数组索引。令 `u[i, j]` 对应于 $(\\xi^{(u)}_i, \\eta_j)$ 处的 $u_{\\xi}$，`v[i, j]` 对应于 $(\\xi_i, \\eta^{(v)}_j)$ 处的 $u_{\\eta}$。对于单元 $(i,j)$，位于 $i+1/2$ 处的面对应索引 $i+1$，位于 $j+1/2$ 处的面对应索引 $j+1$。在周期性边界条件下，这些索引使用模运算符进行环绕处理。对于 `numpy` 实现，`np.roll` 是执行此操作的自然选择。\n\n在 $\\xi$ 方向上，单元 `(i,j)` 左侧面的通量为 $F_{\\xi,i,j} = (h_\\eta u_\\xi)|_{(\\xi^{(u)}_i, \\eta_j)}$。右侧面的通量为 $F_{\\xi,i+1,j}$。那么单元 `(i,j)` 的离散散度为：\n$$\nD_{i,j} = \\frac{1}{h_{\\xi,i,j} h_{\\eta,i,j}} \\left( \\frac{F_{\\xi,i+1,j} - F_{\\xi,i,j}}{\\Delta\\xi} + \\frac{F_{\\eta,i,j+1} - F_{\\eta,i,j}}{\\Delta\\eta} \\right)\n$$\n（对 $i+1$ 和 $j+1$ 使用环绕索引）。\n\n该格式的一个关键性质是其守恒性。对于周期性域，散度的全局积分必须为零。我们可以通过计算所有单元上散度的面积加权和来验证我们的离散算子是否满足此性质：\n$$\n\\sum_{i,j} D_{i,j} A_{i,j} = \\sum_{i,j} \\left( \\left[ F_{\\xi, i+1/2, j} - F_{\\xi, i-1/2, j} \\right] \\Delta\\eta + \\left[ F_{\\eta, i, j+1/2} - F_{\\eta, i, j-1/2} \\right] \\Delta\\xi \\right)\n$$\n对于固定的 $j$，求和 $\\sum_i (F_{\\xi, i+1/2, j} - F_{\\xi, i-1/2, j})$ 是一个伸缩级数。由于周期性，离开行中最后一个单元的通量会重新进入第一个单元，导致总和恰好为零。同样的逻辑也适用于对 $j$ 的求和。因此，总的面积加权和为零，证实了该格式的守恒性。这在 D 例中进行了测试，我们期望结果在机器精度范围内为零。\n\n实现将按以下步骤进行：定义网格，在所需的交错位置上计算尺度因子和速度场，计算通量，然后应用最终的散度公式。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Arakawa C-grid divergence problem for four test cases.\n    \"\"\"\n\n    def divergence_op(u, v, h_eta_u, h_xi_v, h_xi_c, h_eta_c, dxi, dyi):\n        \"\"\"\n        Computes the discrete divergence on an Arakawa C-grid.\n        \n        Args:\n            u (np.ndarray): u-velocity component at xi-faces.\n            v (np.ndarray): v-velocity component at eta-faces.\n            h_eta_u (np.ndarray): arakawa grid scale factor h_eta at u-points.\n            h_xi_v (np.ndarray): scale factor h_xi at v-points.\n            h_xi_c (np.ndarray): scale factor h_xi at cell centers.\n            h_eta_c (np.ndarray): scale factor h_eta at cell centers.\n            dxi (float): Grid spacing in xi.\n            dyi (float): Grid spacing in eta.\n            \n        Returns:\n            np.ndarray: Discrete divergence at cell centers.\n        \"\"\"\n        # Fluxes are F_xi = h_eta * u, F_eta = h_xi * v\n        flux_xi = h_eta_u * u\n        flux_eta = h_xi_v * v\n\n        # Difference of fluxes across cell boundaries using periodic wrapping\n        # np.roll(A, -1, axis=0) gets the (i+1) element for each i\n        flux_xi_diff = (np.roll(flux_xi, -1, axis=0) - flux_xi) / dxi\n        # np.roll(A, -1, axis=1) gets the (j+1) element for each j\n        flux_eta_diff = (np.roll(flux_eta, -1, axis=1) - flux_eta) / dyi\n\n        # Combine terms and divide by cell area factor\n        divergence = (1.0 / (h_xi_c * h_eta_c)) * (flux_xi_diff + flux_eta_diff)\n        \n        return divergence\n\n    results = []\n    \n    # --- Case A: Uniform grid, constant flow ---\n    Nx, Ny = 16, 16\n    U0 = 3.0\n    dxi, dyi = 1.0/Nx, 1.0/Ny\n    \n    u = np.full((Nx, Ny), U0)\n    v = np.zeros((Nx, Ny))\n    \n    h_xi = np.ones((Nx, Ny))\n    h_eta = np.ones((Nx, Ny))\n    \n    # In uniform grid, all h factors are 1\n    div_A = divergence_op(u, v, h_eta, h_xi, h_xi, h_eta, dxi, dyi)\n    results.append(np.max(np.abs(div_A)))\n\n    # --- Case B: Curvilinear grid, divergence-free field ---\n    Nx, Ny = 32, 24\n    a = 0.3\n    dxi, dyi = 1.0/Nx, 1.0/Ny\n\n    # Grid coordinates\n    xi_c = (np.arange(Nx) + 0.5) / Nx\n    eta_c = (np.arange(Ny) + 0.5) / Ny\n    XI_c, ETA_c = np.meshgrid(xi_c, eta_c, indexing='ij')\n\n    xi_u = np.arange(Nx) / Nx\n    XI_u, ETA_u = np.meshgrid(xi_u, eta_c, indexing='ij')\n\n    eta_v = np.arange(Ny) / Ny\n    XI_v, ETA_v = np.meshgrid(xi_c, eta_v, indexing='ij')\n\n    # Scale factor functions\n    h_xi_fn = lambda xi, eta: 1.0 + a * np.sin(2 * np.pi * xi) * np.cos(2 * np.pi * eta)\n    h_eta_fn = lambda xi, eta: 1.0 + a * np.cos(2 * np.pi * xi) * np.sin(2 * np.pi * eta)\n\n    # Scale factors on staggered grids\n    h_xi_c = h_xi_fn(XI_c, ETA_c)\n    h_eta_c = h_eta_fn(XI_c, ETA_c)\n    h_eta_u = h_eta_fn(XI_u, ETA_u)\n    h_xi_v = h_xi_fn(XI_v, ETA_v)\n\n    # Velocity components from streamfunction psi = sin(2*pi*xi)*sin(2*pi*eta)\n    # u_xi = (1/h_eta) * d(psi)/d(eta)\n    u = (1.0 / h_eta_u) * (2 * np.pi * np.sin(2 * np.pi * XI_u) * np.cos(2 * np.pi * ETA_u))\n    # u_eta = -(1/h_xi) * d(psi)/d(xi)\n    v = -(1.0 / h_xi_v) * (2 * np.pi * np.cos(2 * np.pi * XI_v) * np.sin(2 * np.pi * ETA_v))\n\n    div_B = divergence_op(u, v, h_eta_u, h_xi_v, h_xi_c, h_eta_c, dxi, dyi)\n    results.append(np.sqrt(np.mean(div_B**2)))\n\n\n    # --- Case C: Uniform grid, analytic divergence ---\n    Nx, Ny = 3, 3\n    dxi, dyi = 1.0 / Nx, 1.0 / Ny\n\n    # Grid coordinates\n    xi_c = (np.arange(Nx) + 0.5) / Nx\n    eta_c = (np.arange(Ny) + 0.5) / Ny\n    XI_c, ETA_c = np.meshgrid(xi_c, eta_c, indexing='ij')\n\n    xi_u = np.arange(Nx) / Nx\n    XI_u, ETA_u_dummy = np.meshgrid(xi_u, eta_c, indexing='ij') # eta is dummy here\n\n    eta_v = np.arange(Ny) / Ny\n    XI_v_dummy, ETA_v = np.meshgrid(xi_c, eta_v, indexing='ij') # xi is dummy here\n    \n    # Velocity fields\n    u = np.sin(2 * np.pi * XI_u)\n    v = np.sin(2 * np.pi * ETA_v)\n    \n    # Scale factors are all 1\n    h_xi_c_C = np.ones((Nx, Ny))\n    h_eta_c_C = np.ones((Nx, Ny))\n    h_eta_u_C = np.ones((Nx, Ny))\n    h_xi_v_C = np.ones((Nx, Ny))\n\n    # Discrete divergence\n    div_C_discrete = divergence_op(u, v, h_eta_u_C, h_xi_v_C, h_xi_c_C, h_eta_c_C, dxi, dyi)\n\n    # Analytic divergence: 2*pi*cos(2*pi*xi) + 2*pi*cos(2*pi*eta)\n    div_C_analytic = 2 * np.pi * np.cos(2 * np.pi * XI_c) + 2 * np.pi * np.cos(2 * np.pi * ETA_c)\n    \n    rms_error = np.sqrt(np.mean((div_C_discrete - div_C_analytic)**2))\n    results.append(rms_error)\n    \n    # --- Case D: Curvilinear grid, conservation check ---\n    Nx, Ny = 17, 19\n    a = 0.3\n    dxi, dyi = 1.0/Nx, 1.0/Ny\n    \n    # Deterministic seed for reproducibility\n    np.random.seed(0)\n\n    # Grid coordinates\n    xi_c = (np.arange(Nx) + 0.5) / Nx\n    eta_c = (np.arange(Ny) + 0.5) / Ny\n    XI_c, ETA_c = np.meshgrid(xi_c, eta_c, indexing='ij')\n\n    xi_u = np.arange(Nx) / Nx\n    XI_u, ETA_u = np.meshgrid(xi_u, eta_c, indexing='ij')\n\n    eta_v = np.arange(Ny) / Ny\n    XI_v, ETA_v = np.meshgrid(xi_c, eta_v, indexing='ij')\n    \n    # Scale factors on staggered grids\n    h_xi_c = h_xi_fn(XI_c, ETA_c)\n    h_eta_c = h_eta_fn(XI_c, ETA_c)\n    h_eta_u = h_eta_fn(XI_u, ETA_u)\n    h_xi_v = h_xi_fn(XI_v, ETA_v)\n    \n    # Random velocity fields\n    u = np.random.rand(Nx, Ny)\n    v = np.random.rand(Nx, Ny)\n    \n    div_D = divergence_op(u, v, h_eta_u, h_xi_v, h_xi_c, h_eta_c, dxi, dyi)\n    \n    # Area-weighted mean divergence\n    cell_area = h_xi_c * h_eta_c * dxi * dyi\n    total_area = np.sum(cell_area)\n    \n    # Numerator is the sum of (divergence * cell_area) over the domain\n    # This should be zero to machine precision due to conservation\n    integrated_div = np.sum(div_D * cell_area)\n    \n    mean_div = integrated_div / total_area\n    results.append(np.abs(mean_div))\n\n    # Format output as requested\n    print(f\"[{','.join(f'{r:.18e}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}