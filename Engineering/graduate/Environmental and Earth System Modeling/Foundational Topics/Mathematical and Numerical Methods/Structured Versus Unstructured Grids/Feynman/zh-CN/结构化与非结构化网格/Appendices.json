{
    "hands_on_practices": [
        {
            "introduction": "为守恒律设计数值方法的一个关键原则是，离散算子应模仿其连续对应物的性质，这被称为“模拟离散化”。此练习  将指导您完成任何有限体积代码的基本验证测试：确保一个恒定的无散速度场在离散化后仍然精确地保持无散。通过在结构化和非结构化网格上实现这一点，您将获得处理有限体积法基础几何计算的实践经验，并确认您的网格表示在几何上是一致的。",
            "id": "3918705",
            "problem": "您的任务是设计并实现一个基于第一性原理的验证测试，以确认在环境和地球系统建模中常用的结构化和非结构化网格上，离散散度算子能够精确保持一个恒定的无散速度场。设计必须从散度定理出发，推导出一个与有限体积法 (FVM) 一致的、基于控制体的离散散度。您的程序必须计算量化与零散度偏差的残差，并为多个测试案例汇总这些残差。\n\n基本原理：\n- 散度定理（高斯定理）指出，对于一个足够光滑的向量场 $\\mathbf{u}(\\mathbf{x})$ 和一个封闭的控制体 $V$，其边界为 $\\partial V$，外向单位法向量为 $\\mathbf{n}$，\n$$\n\\int_V \\nabla \\cdot \\mathbf{u} \\, dV = \\int_{\\partial V} \\mathbf{u} \\cdot \\mathbf{n} \\, dS.\n$$\n- 有限体积法 (FVM) 通过将边界积分近似为面通量的总和来离散化散度。对于体积为 $|V_c|$ 的单个控制体（单元）$c$，其面由 $f$ 索引，面积为 $|S_f|$，离散散度由通量平衡导出：\n$$\n\\left(\\nabla \\cdot \\mathbf{u}\\right)_c \\approx \\frac{1}{|V_c|} \\sum_{f \\in \\partial c} \\left( \\mathbf{u}_f \\cdot \\mathbf{n}_f \\right) |S_f|.\n$$\n- 在连续设定下，一个恒定速度场 $\\mathbf{u}(\\mathbf{x}) = \\mathbf{u}_0$ 具有 $\\nabla \\cdot \\mathbf{u} = 0$，并且通过任何闭合曲面的精确通量必须为零，因为在一个闭合曲面上所有外向面积向量的总和（或在二维中一个闭合多边形上所有外向法向长度向量的总和）为零。\n\n您的任务：\n1. 对于二维结构化笛卡尔网格，定义宽度为 $dx$、高度为 $dy$ 的单元，其面与坐标轴对齐。使用 FVM 控制体通量平衡和面的精确几何形状，为恒定速度 $\\mathbf{u}_0 = (u_x, u_y)$ 计算每个单元的离散散度，需使用每个面上的外向法线方向。计算定义为所有单元上离散散度绝对值的最大值的残差。当速度单位为 $\\mathrm{m/s}$、长度单位为 $\\mathrm{m}$ 时，散度的单位为 $\\mathrm{s}^{-1}$。以 $\\mathrm{s}^{-1}$ 为单位报告残差。\n2. 对于二维非结构化多边形网格，通过其顶点 $(x_i, y_i)$（单位为 $\\mathrm{m}$）将每个单元定义为一个简单多边形，顶点按顺序形成一个闭合环路（如果需要，您的程序必须确保逆时针排序）。使用鞋带公式计算多边形面积 $|V_c|$，并通过将边向量旋转 $-90^\\circ$ 来计算沿每条边的外向单位法向量 $\\mathbf{n}_f$，以获得逆时针方向的外向法向量。使用 FVM 通量平衡计算恒定速度 $\\mathbf{u}_0 = (u_x, u_y)$ 的离散散度，并像结构化情况一样计算相应的残差。以 $\\mathrm{s}^{-1}$ 为单位报告残差。\n\n约束和预期：\n- 仅使用面和单元体积的精确几何量；由于 $\\mathbf{u}$ 是恒定的，不要为面上的通量引入数值积分。\n- 计算必须是每个单元局部的，并且不能依赖于边界条件或鬼单元，因为通量平衡是在闭合控制体上计算的。\n- 残差应极度接近于零，任何非零值都仅可归因于浮点舍入。\n\n测试套件：\n提供并计算以下五个测试案例的残差。所有距离单位为 $\\mathrm{m}$，速度单位为 $\\mathrm{m/s}$，并以 $\\mathrm{s}^{-1}$ 为单位报告残差。\n\n- 测试案例 1（结构化，一般情况）：\n  - 网格：$N_x = 10$，$N_y = 8$，$dx = 3700$，$dy = 2100$。\n  - 恒定速度：$\\mathbf{u}_0 = (3.2, -5.4)$。\n- 测试案例 2（结构化，边界大小的单单元）：\n  - 网格：$N_x = 1$，$N_y = 1$，$dx = 0.001$，$dy = 0.001$。\n  - 恒定速度：$\\mathbf{u}_0 = (123.456, -654.321)$。\n- 测试案例 3（结构化，具有类无理数分量的各向异性单元尺寸）：\n  - 网格：$N_x = 45$，$N_y = 60$，$dx = 1.0$，$dy = 1000.0$。\n  - 恒定速度：$\\mathbf{u}_0 = (1.41421356237, 3.14159265359)$。\n- 测试案例 4（非结构化，三角形）：\n  - 多边形（每个单元是一个三角形，顶点以逆时针顺序列出，单位为 $\\mathrm{m}$）：\n    - 三角形 1：$(0, 0)$, $(2, 0)$, $(0, 1)$。\n    - 三角形 2：$(1, 1)$, $(3, 1)$, $(2, 3)$。\n    - 三角形 3：$(5, 0)$, $(6, 2)$, $(4, 2)$。\n  - 恒定速度：$\\mathbf{u}_0 = (1.41421356237, 3.14159265359)$。\n- 测试案例 5（非结构化，用于探究数值鲁棒性的高度扭曲四边形）：\n  - 多边形（每个单元是一个四边形，顶点单位为 $\\mathrm{m}$）：\n    - 四边形 1：$(0, 0)$, $(10, 0.1)$, $(10.2, 50)$, $(0, 49.9)$。\n    - 四边形 2：$(20, 0)$, $(30, 0.05)$, $(30.05, 100)$, $(20, 99.95)$。\n  - 恒定速度：$\\mathbf{u}_0 = (3.2, -5.4)$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含五个测试案例的残差，按顺序排列，形式为方括号内的逗号分隔列表，例如 $[r_1,r_2,r_3,r_4,r_5]$，其中每个 $r_i$ 是一个浮点数，单位为 $\\mathrm{s}^{-1}$，表示该测试案例中所有单元上离散散度的最大绝对值。不应打印任何额外文本。",
            "solution": "该问题是有效的。它提出了一个来自计算流体力学领域的、结构良好且有科学依据的验证练习，专门关于结构化和非结构化网格上离散算子的性质。所有必要的数据和定义都已提供，并且问题内部逻辑一致。\n\n这个问题的核心在于验证有限体积法 (FVM) 离散化的一个基本性质：精确保持一个恒定的、无散的速度场。对于任何用于守恒律的数值格式来说，这是一个至关重要的测试，因为它表明离散算子在最简单的非平凡情况下正确地模拟了其连续对应物的性质。\n\n其支配原理是散度定理，它将向量场 $\\mathbf{u}$ 的散度的体积积分与该场通过该体积的闭合边界 $\\partial V$ 的通量联系起来：\n$$\n\\int_V \\nabla \\cdot \\mathbf{u} \\, dV = \\oint_{\\partial V} \\mathbf{u} \\cdot \\mathbf{n} \\, dS\n$$\n这里，$\\mathbf{n}$ 是边界表面元 $dS$ 的外向单位法向量。\n\n在 FVM 中，我们考虑单个控制体（一个单元 $c$）并近似该单元上的平均散度。积分形式除以单元体积 $|V_c|$：\n$$\n\\frac{1}{|V_c|} \\int_{V_c} \\nabla \\cdot \\mathbf{u} \\, dV = \\frac{1}{|V_c|} \\oint_{\\partial V_c} \\mathbf{u} \\cdot \\mathbf{n} \\, dS\n$$\n左侧代表单元平均散度 $(\\nabla \\cdot \\mathbf{u})_c$。右侧的积分被离散化为单元各面 $f$ 上的通量之和：\n$$\n(\\nabla \\cdot \\mathbf{u})_c \\approx \\frac{1}{|V_c|} \\sum_{f \\in \\partial c} \\left( \\mathbf{u}_f \\cdot \\mathbf{n}_f \\right) |S_f|\n$$\n其中 $\\mathbf{u}_f$ 是面上的速度，$\\mathbf{n}_f$ 是面的外向单位法向量，而 $|S_f|$ 是面的面积（在二维中是长度）。\n\n问题指定了一个恒定速度场 $\\mathbf{u}(\\mathbf{x}) = \\mathbf{u}_0$。对于这样的场，连续散度恒为零：$\\nabla \\cdot \\mathbf{u}_0 = 0$。由于速度是恒定的，任何面上的速度 $\\mathbf{u}_f$ 都只是 $\\mathbf{u}_0$。离散散度公式变为：\n$$\n(\\nabla \\cdot \\mathbf{u})_c \\approx \\frac{1}{|V_c|} \\sum_{f \\in \\partial c} \\left( \\mathbf{u}_0 \\cdot \\mathbf{n}_f \\right) |S_f| = \\frac{1}{|V_c|} \\mathbf{u}_0 \\cdot \\left( \\sum_{f \\in \\partial c} \\mathbf{n}_f |S_f| \\right)\n$$\n这个方程揭示了，一个恒定场的离散散度为零，当且仅当所有外向法向量乘以其面面积的矢量和为零向量。这是一个纯粹的几何性质，被称为几何守恒律：对于任何闭合体积，其所有外向面法向面积向量的总和必须为零。一个有效的 FVM 离散化必须精确满足这个条件。\n$$\n\\sum_{f \\in \\partial c} \\mathbf{n}_f |S_f| = \\mathbf{0}\n$$\n我们的任务是在数值上为结构化和非结构化网格验证此性质。计算出的残差将是所有单元上离散散度的最大绝对值，理想情况下应为零，任何非零值都可归因于浮点运算误差。\n\n**1. 结构化笛卡尔网格 (2D)**\n\n对于一个二维结构化网格，一个单元是一个宽度为 $dx$、高度为 $dy$ 的矩形。其面积为 $|V_c| = dx \\cdot dy$。该单元有四个面（东、北、西、南）。我们定义外向法向长度向量，即乘积 $\\mathbf{n}_f |S_f|$：\n- 东面：法向量 $\\mathbf{n}_e=(1, 0)$，长度 $|S_e|=dy$。向量：$(dy, 0)$。\n- 北面：法向量 $\\mathbf{n}_n=(0, 1)$，长度 $|S_n|=dx$。向量：$(0, dx)$。\n- 西面：法向量 $\\mathbf{n}_w=(-1, 0)$，长度 $|S_w|=dy$。向量：$(-dy, 0)$。\n- 南面：法向量 $\\mathbf{n}_s=(0, -1)$，长度 $|S_s|=dx$。向量：$(0, -dx)$。\n\n这些向量的和是：\n$$\n\\sum_{f \\in \\partial c} \\mathbf{n}_f |S_f| = (dy, 0) + (0, dx) + (-dy, 0) + (0, -dx) = (dy - dy, dx - dx) = (0, 0)\n$$\n几何守恒律得到满足。总通量是通过将恒定速度 $\\mathbf{u}_0 = (u_x, u_y)$ 与每个法向长度向量的点积求和来计算的：\n$$\n\\text{Flux}_{total} = u_x \\cdot dy + u_y \\cdot dx + u_x \\cdot (-dy) + u_y \\cdot (-dx) = (u_x dy - u_x dy) + (u_y dx - u_y dx) = 0\n$$\n离散散度为 $\\frac{\\text{Flux}_{total}}{|V_c|} = \\frac{0}{dx \\cdot dy} = 0$。这对网格中的每个单元都成立。\n\n**2. 非结构化多边形网格 (2D)**\n\n对于一个二维非结构化网格，一个单元是由序列 $i=0, \\dots, N-1$ 的 $N$ 个顶点 $(x_i, y_i)$ 定义的简单多边形，按逆时针 (CCW) 排序。\n单元面积 $|V_c|$ 使用鞋带公式计算：\n$$\n|V_c| = \\frac{1}{2} \\sum_{i=0}^{N-1} (x_i y_{i+1} - x_{i+1} y_i)\n$$\n其中顶点索引 $N$ 等价于 $0$。正值结果确认了逆时针排序。\n\n一个面 $f_i$ 是连接顶点 $i$ 和顶点 $i+1$ 的边。边向量为 $\\Delta\\mathbf{s}_i = (x_{i+1} - x_i, y_{i+1} - y_i) = (\\Delta x_i, \\Delta y_i)$。对于逆时针排序的多边形，外向法向长度向量通过将边向量旋转 $-90^\\circ$ 得到：\n$$\n\\mathbf{n}_{f_i} |S_{f_i}| = (\\Delta y_i, -\\Delta x_i)\n$$\n在闭合多边形的所有面上，这些向量的总和是：\n$$\n\\sum_{i=0}^{N-1} (\\Delta y_i, -\\Delta x_i) = \\left( \\sum_{i=0}^{N-1} (y_{i+1} - y_i), -\\sum_{i=0}^{N-1} (x_{i+1} - x_i) \\right)\n$$\n这些是伸缩求和。对于一个闭合多边形，其中 $(x_N, y_N) = (x_0, y_0)$：\n$$\n\\sum_{i=0}^{N-1} (y_{i+1} - y_i) = y_N - y_0 = 0 \\quad \\text{and} \\quad \\sum_{i=0}^{N-1} (x_{i+1} - x_i) = x_N - x_0 = 0\n$$\n因此，法向长度向量的总和是 $(0, 0)$，再次满足了几何守恒律。总通量通过将点积 $\\mathbf{u}_0 \\cdot (\\mathbf{n}_{f_i} |S_{f_i}|)$ 求和来计算：\n$$\n\\text{Flux}_{total} = \\sum_{i=0}^{N-1} \\mathbf{u}_0 \\cdot (\\Delta y_i, -\\Delta x_i) = \\sum_{i=0}^{N-1} (u_x \\Delta y_i - u_y \\Delta x_i) = u_x \\sum \\Delta y_i - u_y \\sum \\Delta x_i = u_x \\cdot 0 - u_y \\cdot 0 = 0\n$$\n每个多边形单元的离散散度为 $\\frac{\\text{Flux}_{total}}{|V_c|} = 0$。实现将为每个指定的单元计算此值，并报告最大绝对值作为残差。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_structured_residual(dx, dy, u0):\n    \"\"\"\n    Computes the discrete divergence for a single cell in a structured grid.\n    For a constant velocity field on a uniform Cartesian grid, the result\n    is identical for all cells.\n    \n    Args:\n        dx (float): Cell width in meters.\n        dy (float): Cell height in meters.\n        u0 (tuple): Constant velocity vector (ux, uy) in m/s.\n        \n    Returns:\n        float: The absolute value of the discrete divergence in s^-1.\n    \"\"\"\n    ux, uy = u0\n    \n    # Cell area (which is the 2D volume)\n    cell_area = dx * dy\n    if cell_area == 0:\n        return 0.0\n\n    # Fluxes across a cell's four faces (East, North, West, South).\n    # The flux for a face f is (u0 . n_f) * |S_f|, where n_f is the outward\n    # unit normal and |S_f| is the face length. This is equivalent to\n    # u0 . (n_f * |S_f|), where (n_f * |S_f|) is the normal-length vector.\n    # East face: normal-length vector is (dy, 0)\n    # North face: normal-length vector is (0, dx)\n    # West face: normal-length vector is (-dy, 0)\n    # South face: normal-length vector is (0, -dx)\n    \n    flux_east = ux * dy\n    flux_north = uy * dx\n    flux_west = -ux * dy\n    flux_south = -uy * dx\n    \n    # Summing the fluxes. Grouping identical terms to improve numerical stability.\n    total_flux = (flux_east + flux_west) + (flux_north + flux_south)\n    \n    divergence = total_flux / cell_area\n    \n    return abs(divergence)\n\ndef calculate_unstructured_residual(polygons, u0):\n    \"\"\"\n    Computes the maximum absolute discrete divergence over a set of \n    unstructured polygonal cells.\n    \n    Args:\n        polygons (list): A list of numpy arrays, where each array contains the\n                         (x, y) vertices of a cell in meters.\n        u0 (tuple): Constant velocity vector (ux, uy) in m/s.\n        \n    Returns:\n        float: The maximum absolute discrete divergence over all cells in s^-1.\n    \"\"\"\n    ux, uy = u0\n    all_divergences = []\n    \n    for poly_verts in polygons:\n        # Ensure vertices are in counter-clockwise (CCW) order by checking\n        # the sign of the shoelace formula for area.\n        num_verts = len(poly_verts)\n        signed_area = 0.5 * sum(\n            poly_verts[i, 0] * poly_verts[(i + 1) % num_verts, 1] -\n            poly_verts[(i + 1) % num_verts, 0] * poly_verts[i, 1]\n            for i in range(num_verts)\n        )\n        \n        if signed_area < 0:\n            # Reverse vertices if clockwise (CW)\n            poly_verts = np.flip(poly_verts, axis=0)\n            cell_area = -signed_area\n        else:\n            cell_area = signed_area\n\n        if cell_area == 0:\n            all_divergences.append(0.0)\n            continue\n            \n        total_flux = 0.0\n        # Loop over polygon edges (faces) to compute total flux\n        for i in range(num_verts):\n            p1 = poly_verts[i]\n            p2 = poly_verts[(i + 1) % num_verts]\n            \n            # Edge vector (dx, dy)\n            dx = p2[0] - p1[0]\n            dy = p2[1] - p1[1]\n\n            # Outward normal-length vector (dy, -dx) for CCW.\n            # Flux for this edge is u0 . (normal-length vector)\n            flux = ux * dy - uy * dx\n            total_flux += flux\n            \n        divergence = total_flux / cell_area\n        all_divergences.append(divergence)\n        \n    if not all_divergences:\n        return 0.0\n        \n    return np.max(np.abs(all_divergences))\n\ndef solve():\n    \"\"\"\n    Runs the verification tests for both structured and unstructured grids\n    and prints the residuals in the specified format.\n    \"\"\"\n    test_cases = [\n        # Test case 1 (structured)\n        {'type': 'structured', 'params': {'dx': 3700.0, 'dy': 2100.0, 'u0': (3.2, -5.4)}},\n        # Test case 2 (structured)\n        {'type': 'structured', 'params': {'dx': 0.001, 'dy': 0.001, 'u0': (123.456, -654.321)}},\n        # Test case 3 (structured)\n        {'type': 'structured', 'params': {'dx': 1.0, 'dy': 1000.0, 'u0': (1.41421356237, 3.14159265359)}},\n        # Test case 4 (unstructured)\n        {'type': 'unstructured', 'params': {\n            'polygons': [\n                np.array([(0., 0.), (2., 0.), (0., 1.)]),\n                np.array([(1., 1.), (3., 1.), (2., 3.)]),\n                np.array([(5., 0.), (6., 2.), (4., 2.)])\n            ],\n            'u0': (1.41421356237, 3.14159265359)\n        }},\n        # Test case 5 (unstructured)\n        {'type': 'unstructured', 'params': {\n            'polygons': [\n                np.array([(0., 0.), (10., 0.1), (10.2, 50.), (0., 49.9)]),\n                np.array([(20., 0.), (30., 0.05), (30.05, 100.), (20., 99.95)])\n            ],\n            'u0': (3.2, -5.4)\n        }}\n    ]\n\n    results = []\n    for case in test_cases:\n        if case['type'] == 'structured':\n            residual = calculate_structured_residual(**case['params'])\n            results.append(residual)\n        elif case['type'] == 'unstructured':\n            residual = calculate_unstructured_residual(**case['params'])\n            results.append(residual)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在证明数值格式具有几何一致性之后，下一个关键步骤是评估其在动态问题中的精度。线性平流方程是输运格式的典型测试案例。在此练习  中，您将在均匀结构化网格和非均匀非结构化网格上，使用简单的一阶迎风格式求解线性平流方程。通过将数值结果与已知的解析解进行比较，并计算各种误差范数（$L^1$、$L^2$ 和 $L^{\\infty}$），您将直接量化网格结构和分辨率如何影响数值扩散和整体解的精度。",
            "id": "3918663",
            "problem": "考虑一维线性平流偏微分方程 (PDE) $u_t + a u_x = 0$，其定义域为周期性的 $x \\in [0,1)$，其中 $a \\in \\mathbb{R}$ 是一个恒定的平流速度。设初始条件为 $u(x,0) = u_0(x)$，其中\n$$\nu_0(x) = \\sin(2\\pi x) + 0.25 \\exp\\left(-100 (x-0.5)^2 \\right).\n$$\n在时间 $t$ 的解析解为 $u(x,t) = u_0\\big((x - a t) \\bmod 1\\big)$。\n\n您将通过在两种网格类型上计算验证指标来评估网格依赖的性能：\n- 结构化网格：$N$ 个均匀的控制体积，其边界位于 $x_j = j/N$，其中 $j=0,\\dots,N$。\n- 非结构化网格：$N$ 个非均匀的控制体积，其长度 $\\Delta x_i$ 由正权重 $w_i = 1 + \\eta \\xi_i$ 构造，其中 $\\xi_i \\sim \\mathcal{U}[-1,1]$ 是使用指定的伪随机种子生成的独立同分布随机变量。单元长度为 $\\Delta x_i = w_i / \\sum_{k=1}^{N} w_k$，周期性边界为 $x_0 = 0$，$x_i = \\sum_{k=1}^{i} \\Delta x_k$（对于 $i=1,\\dots,N$），且 $x_N = 1$。\n\n在每个网格上使用一阶有限体积迎风法对该偏微分方程进行离散化。用 $U_i^n \\approx \\frac{1}{\\Delta x_i} \\int_{x_{i-1}}^{x_i} u(x,t^n)\\,dx$ 表示单元平均值。对于从 $t^n$ 到 $t^{n+1} = t^n + \\Delta t$ 的一个显式时间步，有限体积更新公式为\n$$\nU_i^{n+1} = U_i^n - \\frac{\\Delta t}{\\Delta x_i} \\left( F_{i+1/2} - F_{i-1/2} \\right),\n$$\n其中在面 $i+1/2$ 处的数值通量由针对常数速度 $a$ 的迎风选择给出：\n$$\nF_{i+1/2} =\n\\begin{cases}\na \\, U_i^n, & a \\ge 0, \\\\\na \\, U_{i+1}^n, & a < 0,\n\\end{cases}\n$$\n在周期性网格上，索引对 $N$ 取模。通过库朗数 $C \\in (0,1]$ 选择时间步长 $\\Delta t$ 如下\n$$\n\\Delta t = C \\, \\frac{\\min_i \\Delta x_i}{|a|},\n$$\n对于 $a \\ne 0$。\n\n为了将一个迎风时间步后的离散解与平流后的解析场进行比较，请使用通过高阶求积计算的单元平均值。具体来说，对于长度为 $\\Delta x_i$ 的单元区间 $[x_{i-1}, x_i]$，使用至少八点的高斯-勒让德法则来近似函数 $f(x)$ 的单元平均值：\n$$\n\\frac{1}{\\Delta x_i} \\int_{x_{i-1}}^{x_i} f(x) \\, dx \\approx \\frac{1}{2} \\sum_{q=1}^{m} w_q \\, f\\!\\left( \\frac{x_i - x_{i-1}}{2} \\, \\xi_q + \\frac{x_i + x_{i-1}}{2} \\right),\n$$\n其中 $m \\ge 8$，$\\{(\\xi_q, w_q)\\}_{q=1}^{m}$ 是 $[-1,1]$ 上的高斯-勒让德节点和权重。此法则既用于计算 $u_0(x)$ 的初始单元平均值 $U_i^0$，也用于计算在时间 $\\Delta t$ 时平流场 $u_0\\big((x - a \\Delta t) \\bmod 1\\big)$ 的精确单元平均值。\n\n对于每个网格，在一个时间步后，定义离散误差 $e_i = U_i^{1} - \\bar{u}_i^{\\mathrm{exact}}$，其中 $\\bar{u}_i^{\\mathrm{exact}}$ 是在时间 $\\Delta t$ 时通过求积近似的精确单元平均值。计算以下验证指标：\n- $L^1$ 范数,\n$$\n\\|e\\|_{L^1} \\approx \\sum_{i=1}^{N} |e_i| \\, \\Delta x_i.\n$$\n- $L^2$ 范数,\n$$\n\\|e\\|_{L^2} \\approx \\left( \\sum_{i=1}^{N} e_i^2 \\, \\Delta x_i \\right)^{1/2}.\n$$\n- $L^{\\infty}$ 范数,\n$$\n\\|e\\|_{L^{\\infty}} = \\max_{1 \\le i \\le N} |e_i|.\n$$\n- 由集总质量矩阵（单元体积）导出的能量范数，\n$$\n\\|e\\|_{E} = \\left( e^{\\top} M e \\right)^{1/2}, \\quad M = \\mathrm{diag}(\\Delta x_1,\\dots,\\Delta x_N).\n$$\n\n在下述每个测试案例中，对结构化和非结构化网格均实现上述步骤，求积时使用 $m = 8$ 个高斯-勒让德点。对于非结构化网格，使用指定的伪随机种子生成 $\\xi_i$，并使用 $\\eta$ 作为不规则性振幅。\n\n测试套件（每个参数元组为 $(N, a, C, \\eta, \\text{seed})$）：\n1. $(100, 1.0, 0.5, 0.3, 42)$\n2. $(20, 1.0, 0.9, 0.5, 123)$\n3. $(8, -1.0, 0.4, 0.8, 7)$\n\n您的程序必须：\n- 为每个测试案例构建所定义的结构化和非结构化网格。\n- 在每个网格上计算从 $t=0$ 到 $t=\\Delta t$ 的一个迎风有限体积时间步。\n- 使用通过求积定义的单元平均值，在每个网格上计算四个误差指标。\n- 对于每个测试案例，按以下顺序输出一个包含八个浮点数的列表\n$$\n[\\|e\\|_{L^1}^{\\mathrm{struct}}, \\|e\\|_{L^2}^{\\mathrm{struct}}, \\|e\\|_{L^{\\infty}}^{\\mathrm{struct}}, \\|e\\|_{E}^{\\mathrm{struct}}, \\|e\\|_{L^1}^{\\mathrm{unstruct}}, \\|e\\|_{L^2}^{\\mathrm{unstruct}}, \\|e\\|_{L^{\\infty}}^{\\mathrm{unstruct}}, \\|e\\|_{E}^{\\mathrm{unstruct}} ].\n$$\n- 将所有测试案例的结果汇总到一个单一的外部列表中。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个逗号分隔的 Python 风格列表的列表形式的结果，每个浮点数四舍五入到八位小数，且不含任何额外文本。例如：“[[0.12345678,0.23456789,0.34567890,0.45678901,0.11111111,0.22222222,0.33333333,0.44444444],[...],[...]]”。此问题不要求角度和物理单位；所有量均为无量纲。输出必须只有一行，不含任何尾随或前导空格，也不含单位。",
            "solution": "用户提供的问题是偏微分方程（PDE）数值分析领域一个定义明确的任务。在着手解决之前，我将首先验证其有效性。\n\n### 第一步：提取已知信息\n\n- **偏微分方程（PDE）**：一维线性平流方程，$u_t + a u_x = 0$，在周期性定义域 $x \\in [0,1)$ 上，其中 $a \\in \\mathbb{R}$ 是一个恒定速度。\n- **初始条件**：$u(x,0) = u_0(x) = \\sin(2\\pi x) + 0.25 \\exp\\left(-100 (x-0.5)^2 \\right)$。\n- **解析解**：$u(x,t) = u_0\\big((x - a t) \\bmod 1\\big)$。\n- **网格**：定义了两种包含 $N$ 个单元的网格类型：\n    1.  **结构化网格**：均匀单元，其边界位于 $x_j = j/N$，其中 $j=0, \\dots, N$。单元长度为 $\\Delta x_j = 1/N$。\n    2.  **非结构化网格**：非均匀单元。由权重 $w_i = 1 + \\eta \\xi_i$ 生成，其中 $\\xi_i$ 是使用给定种子从 $\\mathcal{U}[-1,1]$ 中抽取的独立同分布样本。单元长度为 $\\Delta x_i = w_i / \\sum_{k=1}^{N} w_k$。边界为 $x_0 = 0$，$x_i = \\sum_{k=1}^{i} \\Delta x_k$。\n- **数值离散化**：一阶有限体积迎风法。\n    - **更新法则**：$U_i^{n+1} = U_i^n - \\frac{\\Delta t}{\\Delta x_i} \\left( F_{i+1/2} - F_{i-1/2} \\right)$。\n    - **数值通量**：如果 $a \\ge 0$，则 $F_{i+1/2} = a U_i^n$；如果 $a < 0$，则 $F_{i+1/2} = a U_{i+1}^n$。索引是周期性的（对 $N$ 取模）。\n- **时间步**：$\\Delta t = C \\frac{\\min_i \\Delta x_i}{|a|}$，对于库朗数 $C \\in (0,1]$。\n- **单元平均值**：任意函数 $f(x)$ 在 $[x_{i-1}, x_i]$ 上的单元平均值将通过一个 $m$ 点高斯-勒让德求积法则（$m \\ge 8$）来近似。公式给出为 $\\frac{1}{2} \\sum_{q=1}^{m} w_q f(\\dots)$。这既用于初始条件，也用于在时间 $\\Delta t$ 的精确解。\n- **误差指标**：\n    - $L^1$ 范数：$\\|e\\|_{L^1} \\approx \\sum_{i=1}^{N} |e_i| \\, \\Delta x_i$。\n    - $L^2$ 范数：$\\|e\\|_{L^2} \\approx \\left( \\sum_{i=1}^{N} e_i^2 \\, \\Delta x_i \\right)^{1/2}$。\n    - $L^{\\infty}$ 范数：$\\|e\\|_{L^{\\infty}} = \\max_{1 \\le i \\le N} |e_i|$。\n    - 能量范数：$\\|e\\|_{E} = \\left( e^{\\top} M e \\right)^{1/2}$，其中 $M = \\mathrm{diag}(\\Delta x_1, \\dots, \\Delta x_N)$。\n- **任务**：对于每个测试案例，计算一个时间步，并为结构化和非结构化网格评估四种误差指标。\n- **测试套件**：$(N, a, C, \\eta, \\text{seed})$ 元组：\n    1.  $(100, 1.0, 0.5, 0.3, 42)$\n    2.  $(20, 1.0, 0.9, 0.5, 123)$\n    3.  $(8, -1.0, 0.4, 0.8, 7)$\n- **输出格式**：一个列表的列表，每个内部列表包含八个四舍五入到八位小数的浮点数，分别对应于结构化网格的四个范数，其后是非结构化网格的四个范数。\n\n### 第二步：使用提取的已知信息进行验证\n\n- **科学依据**：该问题基于基本的一维线性平流方程，这是流体动力学和输运现象的基石。所用的数值方法（一阶迎风法）、稳定性条件（CFL）、网格生成程序和误差分析都是数值分析中标准且正确的概念。所有前提在科学上都是合理的。\n- **适定性**：该问题是适定的。具有给定光滑初始条件和周期性边界条件的偏微分方程存在唯一、稳定的解析解。数值问题也是适定的；离散化是标准的，时间步的选择保证了稳定性。该过程是确定性的（给定随机数生成器的种子），并将产生唯一的结果。\n- **客观性**：问题以精确、客观的数学语言陈述。所有术语都已定义，任务明确无歧义。\n- **完整性与一致性**：为每个测试案例提供了所有必要的参数（$N, a, C, \\eta, \\text{seed}$）、函数（$u_0(x)$）和程序。没有矛盾之处。能量范数 $\\|e\\|_{E} = (\\sum e_i^2 \\Delta x_i)^{1/2}$ 的定义与所提供的离散 $L^2$ 范数相同。这是一种冗余，而非矛盾。它仅仅意味着两个计算值将是相同的。\n- **现实性与可行性**：该问题是数值方法中的一个标准学术练习。所有参数都在合理范围内，计算完全可行。\n- **结构与非平凡性**：问题结构良好且并非无足轻重。它要求正确实现网格生成、数值积分、PDE 求解器和误差分析，从而检验对这些相互关联概念的理解。\n\n### 第三步：结论与行动\n\n问题陈述是有效的。这是一个清晰、自洽且科学上合理的计算科学练习。我现在将着手解决。\n\n### 解决方案原则与设计\n\n解决方案将使用 Python 实现，利用 `numpy` 库进行高效的数组操作，并利用 `scipy` 库实现专门的科学函数。该实现将遵循模块化设计，将问题分解为不同且可管理的组件。\n\n1.  **网格生成**：将创建两个函数：一个用于结构化网格，它只计算均匀的间距；另一个用于非结构化网格，它使用一个随机数生成器（为保证可复现性而设定种子）来按规定创建非均匀的单元宽度。\n\n2.  **函数定义**：初始条件 $u_0(x)$ 和解析解 $u(x,t)$ 将被定义为可对 `numpy` 数组进行操作的 Python 函数，以实现矢量化计算。\n\n3.  **高阶求积**：一个核心工具函数将计算给定函数在指定网格上的单元平均值。该函数将使用 $8$ 点高斯-勒让德求积法则。节点和权重将使用 `scipy.special.roots_legendre` 预先计算。该函数会将这些节点映射到每个单元区间，并应用求积公式来近似积分，然后除以单元宽度得到平均值。\n\n4.  **数值时间步**：一个函数将实现一阶迎风有限体积法的单个时间步。为提高效率，此实现将被矢量化。它将根据平流速度 $a$ 的符号有条件地处理通量计算。对于 $a \\ge 0$，通量取决于当前单元和左侧单元（`i` 和 `i-1`）的状态；对于 $a < 0$，它取决于当前单元和右侧单元（`i` 和 `i+1`）的状态。周期性边界条件将使用 `numpy.roll` 来循环单元平均值数组的元素来处理。\n\n5.  **误差计算**：一个函数将接收单元误差向量和相应的单元宽度，以计算所需的四个范数：$L^1$、$L^2$、$L^{\\infty}$ 和能量范数 $E$。如前所述，$L^2$ 和 $E$ 范数在数学上是等价的，将使用相同的公式计算。\n\n6.  **主循环**：主函数将协调整个过程。它将遍历所提供的测试案例。对于每个案例，它将：\n    a.  对结构化网格执行比较：生成网格，确定 $\\Delta t$，计算初始单元平均值 `U0_s`，执行迎风步得到 `U1_s`，计算在 $t=\\Delta t$ 时的精确单元平均值 `U_exact_s`，计算误差 `e_s = U1_s - U_exact_s`，并计算四个误差指标。\n    b.  对非结构化网格重复此过程，使用其特定的几何形状和因此而不同的 $\\Delta t$。\n    c.  按指定顺序收集八个产生的误差指标。\n\n7.  **输出格式化**：最后，将所有测试案例收集到的结果格式化为单个字符串——一个浮点数列表的列表，其中每个数字都四舍五入到八位小数——并打印到标准输出。",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import roots_legendre\n\n# Use a constant for the number of Gauss points as specified.\nNUM_GAUSS_POINTS = 8\n\ndef u0(x: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Computes the initial condition u(x,0). The function is vectorized.\n    \"\"\"\n    return np.sin(2 * np.pi * x) + 0.25 * np.exp(-100 * (x - 0.5)**2)\n\ndef u_analytical(x: np.ndarray, t: float, a: float) -> np.ndarray:\n    \"\"\"\n    Computes the analytical solution u(x,t) for the 1D linear advection equation.\n    \"\"\"\n    # Python's '%' operator correctly handles the periodic domain for (x - a*t).\n    return u0((x - a * t) % 1)\n\ndef generate_structured_grid(N: int) -> tuple[np.ndarray, np.ndarray]:\n    \"\"\"\n    Generates a structured grid with N uniform cells on the domain [0,1).\n    Returns cell edges and cell widths.\n    \"\"\"\n    edges = np.linspace(0, 1, N + 1)\n    delta_x = np.full(N, 1.0 / N)\n    return edges, delta_x\n\ndef generate_unstructured_grid(N: int, eta: float, seed: int) -> tuple[np.ndarray, np.ndarray]:\n    \"\"\"\n    Generates an unstructured grid with N non-uniform cells on [0,1).\n    Returns cell edges and cell widths.\n    \"\"\"\n    rng = np.random.default_rng(seed)\n    xi = rng.uniform(-1, 1, N)\n    weights = 1 + eta * xi\n    delta_x = weights / np.sum(weights)\n    edges = np.zeros(N + 1)\n    edges[1:] = np.cumsum(delta_x)\n    return edges, delta_x\n\ndef compute_cell_averages(func: callable, edges: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Computes cell averages of a function on a grid using Gauss-Legendre quadrature.\n    \"\"\"\n    N = len(edges) - 1\n    averages = np.zeros(N)\n    nodes, weights = roots_legendre(NUM_GAUSS_POINTS)\n    \n    for i in range(N):\n        x_left, x_right = edges[i], edges[i+1]\n        delta_x_i = x_right - x_left\n        x_center = (x_right + x_left) / 2.0\n        \n        # Transform Gauss-Legendre nodes from [-1, 1] to [x_left, x_right]\n        mapped_nodes = x_center + (delta_x_i / 2.0) * nodes\n        \n        # Evaluate function at mapped nodes\n        func_values = func(mapped_nodes)\n        \n        # The cell average is 1/Delta_x * integral(f(x)dx).\n        # The integral is approx. (Delta_x/2) * sum(w_q * f(x_q)).\n        # Thus, the average is approx. (1/2) * sum(w_q * f(x_q)).\n        averages[i] = 0.5 * np.sum(weights * func_values)\n        \n    return averages\n\ndef upwind_step(U0: np.ndarray, delta_x: np.ndarray, dt: float, a: float) -> np.ndarray:\n    \"\"\"\n    Performs one time step of the first-order upwind finite volume scheme.\n    \"\"\"\n    if a >= 0:\n        # Upwind flux from the left. Flux difference is a*(U_i - U_{i-1}).\n        flux_diff = a * (U0 - np.roll(U0, 1))\n    else:  # a < 0\n        # Upwind flux from the right. Flux difference is a*(U_{i+1} - U_i).\n        flux_diff = a * (np.roll(U0, -1) - U0)\n        \n    U1 = U0 - (dt / delta_x) * flux_diff\n    return U1\n\ndef compute_error_metrics(error: np.ndarray, delta_x: np.ndarray) -> list[float]:\n    \"\"\"\n    Computes the L1, L2, L-infinity, and Energy norms for the error vector.\n    \"\"\"\n    l1_norm = np.sum(np.abs(error) * delta_x)\n    l2_norm = np.sqrt(np.sum(error**2 * delta_x))\n    linf_norm = np.max(np.abs(error))\n    \n    # Per the problem description, the energy norm is mathematically\n    # identical to the discrete L2 norm.\n    energy_norm = l2_norm\n    \n    return [l1_norm, l2_norm, linf_norm, energy_norm]\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        (100, 1.0, 0.5, 0.3, 42),\n        (20, 1.0, 0.9, 0.5, 123),\n        (8, -1.0, 0.4, 0.8, 7)\n    ]\n\n    all_results = []\n    for params in test_cases:\n        N, a, C, eta, seed = params\n        \n        # --- Structured Grid Calculation ---\n        edges_s, delta_x_s = generate_structured_grid(N)\n        dt_s = C * (1.0 / N) / abs(a)\n        \n        U0_s = compute_cell_averages(u0, edges_s)\n        U1_s = upwind_step(U0_s, delta_x_s, dt_s, a)\n        \n        u_exact_s_func = lambda x: u_analytical(x, dt_s, a)\n        U_exact_s = compute_cell_averages(u_exact_s_func, edges_s)\n        \n        error_s = U1_s - U_exact_s\n        metrics_s = compute_error_metrics(error_s, delta_x_s)\n        \n        # --- Unstructured Grid Calculation ---\n        edges_u, delta_x_u = generate_unstructured_grid(N, eta, seed)\n        dt_u = C * np.min(delta_x_u) / abs(a)\n\n        U0_u = compute_cell_averages(u0, edges_u)\n        U1_u = upwind_step(U0_u, delta_x_u, dt_u, a)\n\n        u_exact_u_func = lambda x: u_analytical(x, dt_u, a)\n        U_exact_u = compute_cell_averages(u_exact_u_func, edges_u)\n        \n        error_u = U1_u - U_exact_u\n        metrics_u = compute_error_metrics(error_u, delta_x_u)\n\n        # Combine results into a single list for the test case\n        all_results.append(metrics_s + metrics_u)\n\n    # Format the final output string as specified\n    formatted_results = []\n    for case_res in all_results:\n        formatted_case = [f\"{x:.8f}\" for x in case_res]\n        formatted_results.append(f\"[{','.join(formatted_case)}]\")\n        \n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "现实世界中的地球系统模型通常是复杂的系统，由多个分量（如大气、海洋和陆地模型）组成，每个分量可能使用不同类型的网格。在不违反基本守恒定律的情况下在这些分量之间传输数据是一项关键挑战。这项高级实践  直面这一挑战，指导您实现一阶守恒重映射方案。您将学习使用多边形裁剪算法计算结构化网格单元和非结构化三角形之间的相交区域，从而生成权重，以确保在网格重构过程中标量守恒。对于从事耦合模型开发或分析的任何人来说，这都是一项非常实用的技能。",
            "id": "3918651",
            "problem": "您正在执行一项局部环境建模任务，该任务要求在经纬度结构化网格和三角形非结构化网格之间进行守恒重映射。目标是通过计算源网格单元和目标三角形之间的多边形交集，来推导并实现保持面积的重映射权重。该区域足够小，因此局部平面近似是合理的。\n\n基本原理和定义：\n- 假设一个标量场在一组源网格（索引为 $i$）上表示为分段常数，每个网格的面积为 $A_i$，值为常数 $s_i$。目标网格由三角形元素（索引为 $j$）组成，每个三角形的面积为 $A_j$。\n- 守恒重映射要求标量场的离散积分在映射下保持不变，这意味着只要覆盖相同的空间域，从源网格计算的总“质量”等于从目标元素计算的总“质量”。\n- 在目标三角形 $j$ 上的重映射值（表示为 $v_j$）是使用源网格 $i$ 和目标三角形 $j$ 之间的重叠区域 $A_{ij}$ 定义的。\n- 面积必须以平方千米计算，经纬度角必须以度为单位。\n\n平面近似：\n- 使用以参考纬度 $lat_0$（单位为度）为中心的局部平面等距圆柱（等矩形）投影。设地球半径为 $R=6371$ 公里。将经纬度 $(\\lambda,\\phi)$（单位为度）通过以下公式转换为平面坐标 $(x,y)$（单位为公里）：\n$$\nx = R \\cos\\left(\\frac{\\pi}{180} lat_0\\right)\\,\\frac{\\pi}{180}\\,\\lambda, \\quad\ny = R\\,\\frac{\\pi}{180}\\,\\phi.\n$$\n\n守恒重映射原理：\n- 重映射权重 $w_{ij}$ 定义为：\n$$\nw_{ij} = \\frac{A_{ij}}{A_j},\n$$\n其中 $A_{ij}$ 是源网格 $i$ 和目标三角形 $j$ 之间相交多边形的面积，而 $A_j$ 是目标三角形 $j$ 的面积。\n- 重映射的目标值为：\n$$\nv_j = \\sum_i w_{ij}\\,s_i.\n$$\n- 一阶守恒重映射的精确面积守恒可由下式得出：\n$$\n\\sum_j v_j A_j = \\sum_j \\left(\\sum_i s_i\\,\\frac{A_{ij}}{A_j}\\right) A_j = \\sum_i s_i \\left(\\sum_j A_{ij}\\right),\n$$\n当目标多边形的并集恰好覆盖源网格的并集时，有 $\\sum_j A_{ij} = A_i$，得出：\n$$\n\\sum_j v_j A_j = \\sum_i s_i A_i.\n$$\n\n算法要求：\n- 通过平面裁剪实现三角形与轴对齐矩形之间的多边形相交。使用 Sutherland–Hodgman 多边形裁剪算法，根据矩形的四个半平面进行裁剪。在平面 $(x,y)$ 坐标系中使用鞋带公式计算多边形面积。\n- 计算 $A_{ij}$ 的方法是：将三角形多边形裁剪到源矩形 $i$ 的范围内，使用指定的投影将顶点从度转换为 $(x,y)$ 坐标，然后取裁剪后多边形的面积。在相同的投影中计算 $A_j$ 作为三角形的面积。\n- 为所有源网格 $i$ 和每个三角形 $j$ 计算权重 $w_{ij} = A_{ij}/A_j$。\n\n结构化网格规格：\n- 使用一个 $2\\times 2$ 的经纬度结构化网格，其纬度线位于 $\\{34^\\circ, 35^\\circ, 36^\\circ\\}$，经度线位于 $\\{-120^\\circ, -119^\\circ, -118^\\circ\\}$，形成四个矩形源网格：\n  - 左下：$\\lambda \\in [-120^\\circ,-119^\\circ], \\phi \\in [34^\\circ,35^\\circ]$，\n  - 右下：$\\lambda \\in [-119^\\circ,-118^\\circ], \\phi \\in [34^\\circ,35^\\circ]$，\n  - 左上：$\\lambda \\in [-120^\\circ,-119^\\circ], \\phi \\in [35^\\circ,36^\\circ]$，\n  - 右上：$\\lambda \\in [-119^\\circ,-118^\\circ], \\phi \\in [35^\\circ,36^\\circ]$。\n- 在投影中使用 $lat_0 = 35^\\circ$。\n\n目标三角形网格测试套件（角度单位为度）：\n- 三角形 $T_1$（完全位于左下网格内）：顶点位于 $(-119.8^\\circ, 34.2^\\circ)$、$(-119.6^\\circ, 34.4^\\circ)$、$(-119.7^\\circ, 34.6^\\circ)$。\n- 三角形 $T_2$（跨越下排位于 $\\lambda=-119^\\circ$ 的垂直边界）：顶点位于 $(-119.2^\\circ, 34.6^\\circ)$、$(-118.9^\\circ, 34.7^\\circ)$、$(-118.95^\\circ, 34.4^\\circ)$。\n- 三角形 $T_3$（一条边与边界 $\\lambda=-119^\\circ$ 完全对齐）：顶点位于 $(-119.0^\\circ, 34.3^\\circ)$、$(-119.0^\\circ, 34.8^\\circ)$、$(-118.7^\\circ, 34.5^\\circ)$。\n- 三角形 $T_4$（部分位于结构化网格域之外）：顶点位于 $(-118.1^\\circ, 35.8^\\circ)$、$(-117.9^\\circ, 36.2^\\circ)$、$(-118.5^\\circ, 36.1^\\circ)$。\n\n每个测试用例的所需输出：\n- 对于 $T_1$：计算绝对守恒偏差 $\\left|\\sum_i w_{i1} - 1\\right|$，结果为浮点数。\n- 对于 $T_2$：计算与下排两个网格对应的两个非零权重 $\\{w_{i2}\\}$ 的列表，按升序排列，结果为浮点数列表。\n- 对于 $T_3$：计算一个布尔值，指示左下网格的权重在容差 $10^{-12}$ 内是否精确为零（即 $w_{LL,3} \\le 10^{-12}$）。\n- 对于 $T_4$：计算所有四个源网格的覆盖分数 $\\sum_i w_{i4}$，结果为浮点数（该值小于 $1$，因为 $T_4$ 的一部分位于结构化网格域之外）。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序为 $[T_1\\ \\text{结果},\\ T_2\\ \\text{结果},\\ T_3\\ \\text{结果},\\ T_4\\ \\text{结果}]$。例如，打印的结构必须类似于 $[x,[a,b],y,z]$，其中 $x$ 和 $z$ 是浮点数，$[a,b]$ 是一个包含两个浮点数的列表，$y$ 是一个布尔值。\n\n角度单位说明：\n- 所有输入的经纬度均以度为单位。\n- 面积必须以平方千米为单位进行计算和守恒。",
            "solution": "该问题要求实现一个在结构化经纬度网格和非结构化三角形网格之间的一阶守恒重映射方案。这是环境建模中的一项常见任务，用于在采用不同网格系统的不同模型组件之间传输数据。解决方案涉及在局部平面投影中进行几何计算。任务的核心是计算每个目标三角形被每个源网格单元覆盖的面积分数。这些分数用作重映射权重。\n\n方法论的步骤结构如下：\n1.  **坐标投影**：将所有地理坐标（纬度、经度）转换为平面笛卡尔坐标系 $(x,y)$。这简化了面积和相交等几何计算。\n2.  **多边形裁剪**：对于每一对源网格（一个矩形）和目标元素（一个三角形），计算它们的相交多边形。\n3.  **面积计算**：计算原始目标三角形及其相交多边形的面积。\n4.  **权重计算**：根据相交面积与总三角形面积的比率计算重映射权重。\n5.  **测试用例评估**：应用计算出的权重来评估每个测试用例所需的特定指标。\n\n**1. 平面坐标系：等矩形投影**\n对于局部区域，平面近似是合理的。问题指定了等距圆柱（等矩形）投影。给定地球半径 $R = 6371$ 公里和参考纬度 $lat_0 = 35^\\circ$，一个经度为 $\\lambda$、纬度为 $\\phi$（均以度为单位）的点通过以下变换映射到平面坐标 $(x,y)$（以公里为单位）：\n$$\nx = R \\cos\\left(\\frac{\\pi}{180} lat_0\\right) \\left(\\frac{\\pi}{180}\\lambda\\right)\n$$\n$$\ny = R \\left(\\frac{\\pi}{180}\\phi\\right)\n$$\n通过预先计算缩放因子，可以简化这些方程。设 $\\lambda_{rad} = \\lambda \\cdot \\pi/180$ 和 $\\phi_{rad} = \\phi \\cdot \\pi/180$ 为弧度单位的角度。变换变为：\n$$\nx = \\left(R \\cos(lat_{0,rad})\\right) \\lambda_{rad}\n$$\n$$\ny = R \\phi_{rad}\n$$\n该投影将等经度线和等纬度线分别映射为垂直和水平的直线。因此，$(\\lambda, \\phi)$ 空间中的矩形源网格单元在 $(x,y)$ 平面中变为轴对齐的矩形。\n\n**2. 核心算法：相交面积计算**\n源网格 $i$（一个矩形）和目标三角形 $j$ 之间的相交面积 $A_{ij}$ 是通过将三角形多边形与源网格矩形的四个边界进行裁剪来计算的。\n\n**2.1. Sutherland–Hodgman 多边形裁剪**\n此任务采用 Sutherland–Hodgman 算法。该算法通过依次处理被裁剪多边形与裁剪多边形的每条边，来将被裁剪多边形与一个凸裁剪多边形（在我们的案例中是矩形源网格）进行裁剪。一个由经度范围 $[\\lambda_{min}, \\lambda_{max}]$ 和纬度范围 $[\\phi_{min}, \\phi_{max}]$ 定义的源网格被投影到 $(x,y)$ 平面中的一个矩形，其角点位于 $(x(\\lambda_{min}), y(\\phi_{min}))$ 和 $(x(\\lambda_{max}), y(\\phi_{max}))$。这个矩形定义了四个裁剪边界或半平面：\n- 左边界：$x \\ge x_{min}$\n- 右边界：$x \\le x_{max}$\n- 下边界：$y \\ge y_{min}$\n- 上边界：$y \\le y_{max}$\n\n该算法首先获取目标三角形（以其投影形式）的顶点列表，并根据第一个边界对其进行裁剪。生成的顶点列表（形成新的被裁剪多边形）随后作为输入，用于根据第二个边界进行裁剪，依此类推，直到处理完所有四个边界。\n\n对于单个裁剪边（例如，一条垂直线 $x = x_{clip}$），算法会遍历被裁剪多边形的各条边。对于从顶点 $P_1$ 到 $P_2$ 的每条边：\n- 如果 $P_1$ 和 $P_2$ 都在半平面内，则只将 $P_2$ 添加到输出顶点列表中。\n- 如果 $P_1$ 在内部而 $P_2$ 在外部，则计算边与裁剪边界的交点，并将其添加到输出列表中。\n- 如果 $P_1$ 和 $P_2$ 都在外部，则不添加任何内容。\n- 如果 $P_1$ 在外部而 $P_2$ 在内部，则将交点和 $P_2$ 添加到输出列表中。\n\n在对所有四个边界进行裁剪后，最终的顶点列表定义了相交多边形。如果此列表为空或顶点数少于3个，则相交面积 $A_{ij}$ 为 $0$。\n\n**2.2. 鞋带公式计算面积**\n任何简单多边形（包括原始三角形和相交多边形）的面积，其顶点 $(x_0, y_0), (x_1, y_1), \\dots, (x_{N-1}, y_{N-1})$ 按逆时针或顺时针顺序列出，可使用鞋带（或测量员）公式计算：\n$$\nA = \\frac{1}{2} \\left| \\sum_{k=0}^{N-1} (x_k y_{k+1} - x_{k+1} y_k) \\right|\n$$\n其中 $(x_N, y_N)$ 被视为与 $(x_0, y_0)$ 相同。此公式应用于平面 $(x,y)$ 坐标系，以计算目标三角形的总面积 $A_j$ 和相交多边形的面积 $A_{ij}$。\n\n**3. 重映射权重的推导**\n一阶守恒重映射权重 $w_{ij}$ 是目标三角形 $j$ 位于源网格 $i$ 内的面积分数。其定义为：\n$$\nw_{ij} = \\frac{A_{ij}}{A_j}\n$$\n其中 $A_{ij}$ 是相交面积，$A_j$ 是目标三角形的总面积。根据问题要求，两个面积都在相同的投影坐标系中计算，以确保该比率是无量纲且正确的。三角形 $j$ 上的重映射值是源网格值的加权平均：$v_j = \\sum_i w_{ij} s_i$。\n\n**4. 应用于测试用例**\n将定义的流程应用于每个测试用例：\n- 四个源网格分别索引为 $0$（左下）、$1$（右下）、$2$（左上）和 $3$（右上）。\n- 对于每个目标三角形 $T_j$ ($j=1,2,3,4$)：\n    1. 将 $T_j$ 的顶点投影到 $(x,y)$ 平面。\n    2. 计算投影后三角形的总面积 $A_j$。\n    3. 对四个源网格 $i=0,1,2,3$ 进行循环。在每次迭代中：\n        - 在 $(\\lambda, \\phi)$ 中定义网格 $i$ 的边界，然后投影以在 $(x,y)$ 中形成一个裁剪矩形。\n        - 将投影后的三角形 $T_j$ 与此矩形进行裁剪。\n        - 计算得到的相交多边形的面积 $A_{ij}$。\n        - 计算权重 $w_{ij} = A_{ij} / A_j$。如果 $A_j$ 为零（退化三角形），则权重取为零。\n    4. 使用这组四个权重 $\\{w_{0j}, w_{1j}, w_{2j}, w_{3j}\\}$ 来计算该测试用例所需的特定输出。例如，对于 $T_1$，计算量 $|\\sum_i w_{i1} - 1|$。对于 $T_3$，将权重 $w_{0,3}$（对应于左下角网格）与容差 $10^{-12}$ 进行比较。这个系统化的过程会产生所需的数值结果。",
            "answer": "```python\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Computes conservative remapping weights between a structured grid and a triangular mesh.\n    \"\"\"\n\n    # --- Constants and Definitions ---\n    R_EARTH = 6371.0  # Earth radius in km\n    LAT_0_DEG = 35.0  # Reference latitude in degrees\n    LAT_0_RAD = math.radians(LAT_0_DEG)\n\n    # --- Coordinate Projection ---\n    def project(lon_deg, lat_deg):\n        \"\"\"Converts (lon, lat) in degrees to planar (x, y) in km.\"\"\"\n        lon_rad = math.radians(lon_deg)\n        lat_rad = math.radians(lat_deg)\n        x = R_EARTH * math.cos(LAT_0_RAD) * lon_rad\n        y = R_EARTH * lat_rad\n        return np.array([x, y])\n\n    # --- Geometric Algorithms ---\n    def polygon_area(vertices):\n        \"\"\"Computes polygon area using the shoelace formula.\"\"\"\n        if len(vertices) < 3:\n            return 0.0\n        \n        v = np.array(vertices)\n        x = v[:, 0]\n        y = v[:, 1]\n        \n        # Shift vertices for vectorized calculation\n        x_shifted = np.roll(x, -1)\n        y_shifted = np.roll(y, -1)\n        \n        area = 0.5 * np.abs(np.sum(x * y_shifted - x_shifted * y))\n        return area\n\n    def clip_polygon(subject_polygon, clip_bounds):\n        \"\"\"\n        Clips a polygon using the Sutherland-Hodgman algorithm against a rectangular clip_bounds.\n        clip_bounds = (xmin, ymin, xmax, ymax)\n        \"\"\"\n        clipped = list(subject_polygon)\n        \n        # Clip against the 4 edges of the rectangle\n        # 0: left, 1: right, 2: bottom, 3: top\n        for i in range(4):\n            if not clipped:\n                break\n            \n            input_list = clipped\n            clipped = []\n            s = input_list[-1]\n            \n            for j in range(len(input_list)):\n                e = input_list[j]\n                \n                # Check if points are inside the current clip edge\n                s_inside = False\n                e_inside = False\n                if i == 0:  # Left edge: x >= xmin\n                    s_inside = s[0] >= clip_bounds[0]\n                    e_inside = e[0] >= clip_bounds[0]\n                elif i == 1:  # Right edge: x <= xmax\n                    s_inside = s[0] <= clip_bounds[2]\n                    e_inside = e[0] <= clip_bounds[2]\n                elif i == 2:  # Bottom edge: y >= ymin\n                    s_inside = s[1] >= clip_bounds[1]\n                    e_inside = e[1] >= clip_bounds[1]\n                elif i == 3:  # Top edge: y <= ymax\n                    s_inside = s[1] <= clip_bounds[3]\n                    e_inside = e[1] <= clip_bounds[3]\n\n                if s_inside and e_inside:\n                    clipped.append(e)\n                elif s_inside and not e_inside:\n                    # Going from inside to outside, add intersection\n                    intersection = _get_intersection(s, e, i, clip_bounds)\n                    clipped.append(intersection)\n                elif not s_inside and e_inside:\n                    # Going from outside to inside, add intersection and end point\n                    intersection = _get_intersection(s, e, i, clip_bounds)\n                    clipped.append(intersection)\n                    clipped.append(e)\n                # If both are outside, do nothing.\n                \n                s = e\n        \n        return clipped\n\n    def _get_intersection(p1, p2, edge_index, clip_bounds):\n        \"\"\"Helper to find intersection of segment p1-p2 with a clip edge.\"\"\"\n        dx, dy = p2[0] - p1[0], p2[1] - p1[1]\n\n        if edge_index == 0:  # Left\n            x_clip = clip_bounds[0]\n            if dx == 0: return np.array([x_clip, p1[1]])\n            t = (x_clip - p1[0]) / dx\n            return np.array([x_clip, p1[1] + t * dy])\n        elif edge_index == 1:  # Right\n            x_clip = clip_bounds[2]\n            if dx == 0: return np.array([x_clip, p1[1]])\n            t = (x_clip - p1[0]) / dx\n            return np.array([x_clip, p1[1] + t * dy])\n        elif edge_index == 2:  # Bottom\n            y_clip = clip_bounds[1]\n            if dy == 0: return np.array([p1[0], y_clip])\n            t = (y_clip - p1[1]) / dy\n            return np.array([p1[0] + t * dx, y_clip])\n        elif edge_index == 3:  # Top\n            y_clip = clip_bounds[3]\n            if dy == 0: return np.array([p1[0], y_clip])\n            t = (y_clip - p1[1]) / dy\n            return np.array([p1[0] + t * dx, y_clip])\n\n    # --- Grid and Mesh Definitions ---\n    source_cells_lonlat = [\n        # (lon_min, lon_max, lat_min, lat_max)\n        (-120.0, -119.0, 34.0, 35.0),  # Lower-Left (LL)\n        (-119.0, -118.0, 34.0, 35.0),  # Lower-Right (LR)\n        (-120.0, -119.0, 35.0, 36.0),  # Upper-Left (UL)\n        (-119.0, -118.0, 35.0, 36.0),  # Upper-Right (UR)\n    ]\n\n    destination_triangles_lonlat = [\n        # T1: Fully inside LL cell\n        [(-119.8, 34.2), (-119.6, 34.4), (-119.7, 34.6)],\n        # T2: Straddles vertical boundary at lambda=-119\n        [(-119.2, 34.6), (-118.9, 34.7), (-118.95, 34.4)],\n        # T3: One edge aligned with boundary lambda=-119\n        [(-119.0, 34.3), (-119.0, 34.8), (-118.7, 34.5)],\n        # T4: Partially outside the domain\n        [(-118.1, 35.8), (-117.9, 36.2), (-118.5, 36.1)],\n    ]\n    \n    source_cells_proj = [\n        (project(b[0], b[2])[0], project(b[0], b[2])[1], \n         project(b[1], b[3])[0], project(b[1], b[3])[1])\n        for b in source_cells_lonlat\n    ]\n\n    all_results = []\n    \n    # --- Main Loop over Test Cases ---\n    for j, tri_lonlat in enumerate(destination_triangles_lonlat):\n        \n        projected_triangle = [project(lon, lat) for lon, lat in tri_lonlat]\n        \n        total_triangle_area = polygon_area(projected_triangle)\n        \n        weights = []\n        for i, cell_bounds_proj in enumerate(source_cells_proj):\n            if total_triangle_area == 0:\n                weights.append(0.0)\n                continue\n\n            intersection_polygon = clip_polygon(projected_triangle, cell_bounds_proj)\n            intersection_area = polygon_area(intersection_polygon)\n            weight = intersection_area / total_triangle_area\n            weights.append(weight)\n\n        # --- Process results for each test case ---\n        if j == 0: # T1: Absolute conservation deviation\n            result = abs(sum(weights) - 1.0)\n            all_results.append(result)\n        \n        elif j == 1: # T2: Two non-zero weights, sorted\n            nonzero_weights = sorted([w for w in weights if w > 1e-12])\n            all_results.append(nonzero_weights)\n\n        elif j == 2: # T3: Check if LL cell weight is zero\n            # LL cell is index 0\n            result = weights[0] <= 1e-12\n            all_results.append(result)\n\n        elif j == 3: # T4: Coverage fraction\n            result = sum(weights)\n            all_results.append(result)\n\n    # --- Format final output ---\n    formatted_results = []\n    for res in all_results:\n      if isinstance(res, list):\n        # Format list without spaces, e.g., [0.1,0.2]\n        formatted_results.append(f\"[{','.join(map(str, res))}]\")\n      else:\n        formatted_results.append(str(res))\n    \n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}