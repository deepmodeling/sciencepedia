{
    "hands_on_practices": [
        {
            "introduction": "种群的长期增长率，由其Leslie矩阵的主导特征值 $\\lambda$ 决定，是种群生态学中的一个核心概念。然而，仅凭 $\\lambda$ 的值来预测种群的短期命运可能会产生误导。本练习探讨瞬时动态（transient dynamics）现象，通过一个具体的案例展示，即使一个种群注定会长期增长（$\\lambda \\gt 1$），不平衡的初始年龄结构也可能导致其在短期内经历令人意外的衰退。",
            "id": "1830225",
            "problem": "一个生态学家团队正在研究一种新发现的岛屿爬行动物物种。他们使用年龄结构模型来模拟其种群动态，时间步长为一年。种群被分为四个年龄组：\n-   第1组：孵化幼体（0至1岁）\n-   第2组：幼体（1至2岁）\n-   第3组：成体（2至3岁）\n-   第4组：衰老个体（3至4岁）\n\n没有个体能存活超过4年。年龄组 $i$ 中个体的单位繁殖率，记作 $F_i$，是该个体每年产下的平均孵化幼体数量。年龄组 $i$ 中个体的存活率，记作 $S_i$，是其存活并进入年龄组 $i+1$ 的概率。生态学家已经确定了以下生命率：\n-   繁殖率：$F_1 = 0$, $F_2 = 1.0$, $F_3 = 2.0$, $F_4 = 0$。\n-   存活率：$S_1 = 0.8$, $S_2 = 0.6$, $S_3 = 0.3$。\n\n在时间 $t=0$ 时对种群进行了初始普查，得到每个年龄组的数量如下：\n-   $n_1(0) = 100$ 孵化幼体\n-   $n_2(0) = 100$ 幼体\n-   $n_3(0) = 100$ 成体\n-   $n_4(0) = 2000$ 衰老个体\n\n尽管该种群的长期增长率大于1，但初始年龄分布可能会引起瞬时动态。计算时间 $t=1$ 年时的总种群数量与时间 $t=0$ 时的总种群数量之比。将您的最终答案四舍五入到三位有效数字。",
            "solution": "设 $n_{i}(t)$ 表示在时间 $t$ 时年龄组 $i$ 中的个体数量，设 $N(t)=\\sum_{i=1}^{4}n_{i}(t)$ 为时间 $t$ 时的总种群数量。对于一个时间步长为一年的Leslie矩阵模型，其年龄结构更新方程为\n$$\nn_{1}(t+1)=\\sum_{i=1}^{4}F_{i}\\,n_{i}(t),\\quad\nn_{2}(t+1)=S_{1}\\,n_{1}(t),\\quad\nn_{3}(t+1)=S_{2}\\,n_{2}(t),\\quad\nn_{4}(t+1)=S_{3}\\,n_{3}(t).\n$$\n使用给定的繁殖率 $F_{1}=0$, $F_{2}=1.0$, $F_{3}=2.0$, $F_{4}=0$ 和存活率 $S_{1}=0.8$, $S_{2}=0.6$, $S_{3}=0.3$，以及初始普查数据 $n_{1}(0)=100$, $n_{2}(0)=100$, $n_{3}(0)=100$, $n_{4}(0)=2000$，我们计算：\n$$\nn_{1}(1)=F_{1}n_{1}(0)+F_{2}n_{2}(0)+F_{3}n_{3}(0)+F_{4}n_{4}(0)=0\\cdot 100+1.0\\cdot 100+2.0\\cdot 100+0\\cdot 2000=300,\n$$\n$$\nn_{2}(1)=S_{1}n_{1}(0)=0.8\\cdot 100=80,\\quad\nn_{3}(1)=S_{2}n_{2}(0)=0.6\\cdot 100=60,\\quad\nn_{4}(1)=S_{3}n_{3}(0)=0.3\\cdot 100=30.\n$$\n因此，\n$$\nN(0)=n_{1}(0)+n_{2}(0)+n_{3}(0)+n_{4}(0)=100+100+100+2000=2300,\n$$\n$$\nN(1)=n_{1}(1)+n_{2}(1)+n_{3}(1)+n_{4}(1)=300+80+60+30=470.\n$$\n所求的比率为\n$$\n\\frac{N(1)}{N(0)}=\\frac{470}{2300}=0.204347826\\ldots\n$$\n四舍五入到三位有效数字，结果是 $0.204$。",
            "answer": "$$\\boxed{0.204}$$"
        },
        {
            "introduction": "瞬时动态不仅是生态学上的一个有趣现象，其背后还有着深刻的数学原理。上一个练习展示了增长型种群的暂时衰退，而本练习将探讨一个更引人注目的情况：一个渐近衰退的种群（$\\lambda \\lt 1$）如何在短期内经历显著的增长。通过分析一个非正规（non-normal）Leslie矩阵的性质，您将亲手揭示非正交的特征向量如何导致这种与直觉相悖的瞬时增长。",
            "id": "3860255",
            "problem": "考虑一个具有两个年龄组（幼体和成体）的离散时间年龄结构种群模型，其动态由一个 Leslie 矩阵控制。设时间 $t$ 的种群状态为 $n_t \\in \\mathbb{R}^2_{\\ge 0}$，更新法则为 $n_{t+1} = L n_t$，其中 Leslie 矩阵 $L$ 由下式给出：\n$$\nL = \\begin{pmatrix}\nf_1 & f_2 \\\\\ns_1 & 0\n\\end{pmatrix}.\n$$\n假设以下符合生物学实际的参数：幼体生育率 $f_1 = 0.3$，成体生育率 $f_2 = 1.5$，以及幼体存活率 $s_1 = 0.4$。矩阵 $L$ 的元素是非负的，代表了与标准年龄结构种群模型一致的特定年龄的生育率和存活率。\n\n仅从 Leslie 矩阵、谱半径、特征向量和非正规性的定义出发，分析该系统，证明此矩阵 $L$ 是非正规的，并且其主特征值 $\\lambda$ 严格小于 $1$。解释右特征向量的非正交性如何在主特征值小于 $1$ 的情况下产生瞬时增长，从而构建一个主特征值 $\\lambda < 1$ 且表现出瞬时增长的非正规 Leslie 矩阵的明确示例。\n\n将时间 $t$ 的总种群数量定义为 $\\|n_t\\|_1 = |(n_t)_1| + |(n_t)_2|$。对于满足 $\\|n_0\\|_1 = 1$ 的初始状态 $n_0$，两个时间步内的最大瞬时增长因子为\n$$\nG_{\\max}(2) \\equiv \\sup_{\\|n_0\\|_1 = 1} \\frac{\\|n_2\\|_1}{\\|n_0\\|_1}.\n$$\n计算上述指定矩阵 $L$ 的 $G_{\\max}(2)$。将最终答案表示为一个无单位数，并四舍五入到四位有效数字。",
            "solution": "该问题要求对一个给定的 $2 \\times 2$ Leslie 矩阵进行分析，包括证明其非正规性、证明其主特征值小于 $1$、解释瞬时增长现象，以及计算两个时间步内的最大增长因子 $G_{\\max}(2)$。\n\n该问题被验证为具有科学依据、问题明确且客观。所有必要信息均已提供，该任务是数理种群生物学中的一个标准练习。\n\n首先，我们将给定的参数值，即幼体生育率 $f_1 = 0.3$、成体生育率 $f_2 = 1.5$ 和幼体存活率 $s_1 = 0.4$，代入 Leslie 矩阵 $L$：\n$$\nL = \\begin{pmatrix} f_1 & f_2 \\\\ s_1 & 0 \\end{pmatrix} = \\begin{pmatrix} 0.3 & 1.5 \\\\ 0.4 & 0 \\end{pmatrix}\n$$\n\n**1. 矩阵 $L$ 的非正规性**\n\n如果一个矩阵 $A$ 与其共轭转置 $A^*$ 可交换，即 $AA^* = A^*A$，则该矩阵被定义为正规矩阵。对于像 $L$ 这样的实矩阵，该条件变为 $LL^T = L^T L$，其中 $L^T$ 是 $L$ 的转置。\n\n$L$ 的转置为：\n$$\nL^T = \\begin{pmatrix} 0.3 & 0.4 \\\\ 1.5 & 0 \\end{pmatrix}\n$$\n现在，我们计算乘积 $LL^T$ 和 $L^T L$：\n$$\nLL^T = \\begin{pmatrix} 0.3 & 1.5 \\\\ 0.4 & 0 \\end{pmatrix} \\begin{pmatrix} 0.3 & 0.4 \\\\ 1.5 & 0 \\end{pmatrix} = \\begin{pmatrix} (0.3)^2 + (1.5)^2 & (0.3)(0.4) \\\\ (0.4)(0.3) & (0.4)^2 \\end{pmatrix} = \\begin{pmatrix} 0.09 + 2.25 & 0.12 \\\\ 0.12 & 0.16 \\end{pmatrix} = \\begin{pmatrix} 2.34 & 0.12 \\\\ 0.12 & 0.16 \\end{pmatrix}\n$$\n$$\nL^T L = \\begin{pmatrix} 0.3 & 0.4 \\\\ 1.5 & 0 \\end{pmatrix} \\begin{pmatrix} 0.3 & 1.5 \\\\ 0.4 & 0 \\end{pmatrix} = \\begin{pmatrix} (0.3)^2 + (0.4)^2 & (0.3)(1.5) \\\\ (1.5)(0.3) & (1.5)^2 \\end{pmatrix} = \\begin{pmatrix} 0.09 + 0.16 & 0.45 \\\\ 0.45 & 2.25 \\end{pmatrix} = \\begin{pmatrix} 0.25 & 0.45 \\\\ 0.45 & 2.25 \\end{pmatrix}\n$$\n由于 $LL^T \\neq L^T L$，矩阵 $L$ 是非正规的。\n\n**2. 特征值分析**\n\n$L$ 的特征值 $\\lambda$ 是特征方程 $\\det(L - \\lambda I) = 0$ 的根，其中 $I$ 是单位矩阵。\n$$\n\\det \\begin{pmatrix} 0.3 - \\lambda & 1.5 \\\\ 0.4 & -\\lambda \\end{pmatrix} = 0\n$$\n$$\n(0.3 - \\lambda)(-\\lambda) - (1.5)(0.4) = 0\n$$\n$$\n-0.3\\lambda + \\lambda^2 - 0.6 = 0\n$$\n$$\n\\lambda^2 - 0.3\\lambda - 0.6 = 0\n$$\n使用二次公式 $\\lambda = \\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a}$：\n$$\n\\lambda = \\frac{0.3 \\pm \\sqrt{(-0.3)^2 - 4(1)(-0.6)}}{2} = \\frac{0.3 \\pm \\sqrt{0.09 + 2.4}}{2} = \\frac{0.3 \\pm \\sqrt{2.49}}{2}\n$$\n两个特征值为 $\\lambda_1 = \\frac{0.3 + \\sqrt{2.49}}{2}$ 和 $\\lambda_2 = \\frac{0.3 - \\sqrt{2.49}}{2}$。\n决定种群长期渐进行为的主特征值是模最大的那个特征值。根据非负矩阵的 Perron-Frobenius 定理，这个值是正实数特征值，即 $\\lambda = \\lambda_1$。\n\n我们需要证明 $\\lambda < 1$：\n$$\n\\frac{0.3 + \\sqrt{2.49}}{2} < 1\n$$\n$$\n0.3 + \\sqrt{2.49} < 2\n$$\n$$\n\\sqrt{2.49} < 1.7\n$$\n两边平方（两边均为正数）：\n$$\n2.49 < (1.7)^2 = 2.89\n$$\n此不等式成立，因此主特征值 $\\lambda$ 严格小于 $1$。这意味着对于任何初始状态 $n_0$，种群数量将渐进衰减至零，即 $\\lim_{t\\to\\infty} n_t = 0$。\n\n**3. 由非正规性引起的瞬时增长**\n\n已确立的事实是：(i) $L$ 是非正规的，以及 (ii) 其主特征值（谱半径）$\\rho(L) = \\lambda < 1$。\nL 的非正规性意味着其特征向量不是正交的。一个初始种群向量 $n_0$ 可以投影到特征向量构成的基上。种群的演化由 $n_t = L^t n_0$ 给出。由于特征向量的非正交性，在短时间内各分量之间可能发生相长干涉。这可能导致在由 $\\rho(L) < 1$ 决定的最终衰减接管之前，种群数量（由选定的范数衡量）出现暂时性增加。这种现象被称为瞬时增长。\n\n更正式地说，如果对于某个整数 $k \\ge 1$，矩阵范数 $\\|L^k\\|$ 大于 $1$，则可能出现瞬时增长。对于一个正规矩阵 $A$，其诱导 2-范数满足 $\\|A^k\\|_2 = (\\rho(A))^k$。如果 $\\rho(A) < 1$，则对于所有 $k \\ge 1$，都有 $\\|A^k\\|_2 < 1$，从而排除了瞬时增长（在 2-范数下）的可能性。对于像 $L$ 这样的非正规矩阵，即使 $\\rho(L) < 1$，也可能出现 $\\|L^k\\| > 1$ 的情况。这个矩阵 $L$ 提供了一个明确的例子。\n\n**4. $G_{\\max}(2)$ 的计算**\n\n两个时间步内的最大瞬时增长因子 $G_{\\max}(2)$ 定义为：\n$$\nG_{\\max}(2) = \\sup_{\\|n_0\\|_1 = 1} \\frac{\\|n_2\\|_1}{\\|n_0\\|_1}\n$$\n由于 $n_2 = L^2 n_0$ 并且我们考虑的是满足 $\\|n_0\\|_1 = 1$ 的初始状态，这可以简化为：\n$$\nG_{\\max}(2) = \\sup_{\\|n_0\\|_1 = 1} \\|L^2 n_0\\|_1\n$$\n这个表达式是矩阵 $L^2$ 的诱导矩阵 1-范数的定义，记为 $\\|L^2\\|_1$。矩阵的 1-范数是其各列绝对值之和的最大值。\n\n首先，我们计算矩阵 $L^2$：\n$$\nL^2 = L \\cdot L = \\begin{pmatrix} 0.3 & 1.5 \\\\ 0.4 & 0 \\end{pmatrix} \\begin{pmatrix} 0.3 & 1.5 \\\\ 0.4 & 0 \\end{pmatrix}\n$$\n$$\nL^2 = \\begin{pmatrix} (0.3)(0.3) + (1.5)(0.4) & (0.3)(1.5) + (1.5)(0) \\\\ (0.4)(0.3) + (0)(0.4) & (0.4)(1.5) + (0)(0) \\end{pmatrix}\n$$\n$$\nL^2 = \\begin{pmatrix} 0.09 + 0.60 & 0.45 \\\\ 0.12 & 0.60 \\end{pmatrix} = \\begin{pmatrix} 0.69 & 0.45 \\\\ 0.12 & 0.60 \\end{pmatrix}\n$$\n$L^2$ 的所有元素都是非负的，因此求和中的绝对值是多余的。我们计算 $L^2$ 的每一列的和：\n第 1 列的和：$0.69 + 0.12 = 0.81$\n第 2 列的和：$0.45 + 0.60 = 1.05$\n\n诱导 1-范数是这些和的最大值：\n$$\n\\|L^2\\|_1 = \\max(0.81, 1.05) = 1.05\n$$\n因此，两个时间步内的最大瞬时增长因子为 $G_{\\max}(2) = 1.05$。由于 $G_{\\max}(2) > 1$，尽管该系统是渐进稳定的，它在两个时间步内表现出瞬时增长。\n\n问题要求答案四舍五入到四位有效数字。\n$$\n1.05 = 1.050\n$$",
            "answer": "$$\\boxed{1.050}$$"
        },
        {
            "introduction": "理论模型为我们理解种群动态提供了框架，但在实际研究中，模型必须从经验数据中构建和验证。本练习将引导您完成一个核心的生态建模任务：根据离散的体型分组普查数据，从头开始构建一个阶段结构矩阵。您不仅需要估计存活、生长和繁殖率等关键参数，还需应用统计检验来评估模型的一个基本假设——马尔可夫性质（Markovian assumption），这是确保模型有效性的关键一步。",
            "id": "3860290",
            "problem": "给定的是在固定时间步长上监测的单个物种的离散体型分箱普查和转移数据。目标是构建一个阶段结构投影矩阵，该矩阵基于生存、生长和繁殖将种群向量从一个时间步推进到下一个时间步，并评估阶段层面的动态是否与马尔可夫过程假设一致。此构建的基本基础包括以下经过充分检验的事实和核心定义：阶段结构种群由作用于阶段丰度向量的非负投影矩阵表示；离散阶段之间的生存和生长可以通过与马尔可夫链一致的阶段间转移概率矩阵来建模；繁殖可以表示为各阶段对预定义的新生阶段的贡献；根据 Perron-Frobenius 定理，非负矩阵的主特征值决定了渐近增长率；多项式模型的最大似然估计 (MLE) 产生相对频率估计量，而狄利克雷共轭先验产生正则化估计量，以避免零计数的退化情况。\n\n你必须在程序中从第一性原理出发实现以下概念：\n- 假设有 $K$ 个离散的体型阶段，索引为 $i \\in \\{1,\\dots,K\\}$。令 $n_t(j)$ 表示在当前时间 $t$ 在阶段 $j$ 观察到的个体数量，令 $N(i,j)$ 表示在存活者中观察到从时间 $t$ 的阶段 $j$ 转移到时间 $t+1$ 的阶段 $i$ 的个体数量。特定阶段存活率 $s_j$ 是在阶段 $j$ 的个体中存活到下一个时间步任何阶段的个体比例，给定存活的情况下，目标阶段的条件生长分布由每个 $j$ 对应于所有 $i$ 的概率向量表示，记为 $p_{ij}$，应使用最大似然估计从 $N(i,j)$ 估计，并可选地通过浓度参数为 $\\alpha_{\\text{Dir}}$ 的对称狄利克雷先验进行正则化以处理零计数。阶段层面的马尔可夫假设是指，下一阶段结果的分布仅取决于当前阶段 $j$，而不取决于 $j$ 之前的阶段。\n- 令 $f_j$ 表示各阶段繁殖力，定义为在时间 $t$ 处于阶段 $j$ 的一个个体在时间 $t+1$ 贡献的进入阶段 $i=1$ 的新生个体期望数量。使用阶段 $j$ 的总后代数除以该时间段内阶段 $j$ 的抽样亲本个体数来估计 $f_j$。\n- 构建阶段结构投影矩阵 $A \\in \\mathbb{R}^{K \\times K}$，使得 $A_{ij}$ 等于在时间 $t$ 处于阶段 $j$ 的每个个体在时间 $t+1$ 产生的处于阶段 $i$ 的个体期望数量。在第一行（新生阶段）适当地结合生存-生长和繁殖力。渐近增长率 $\\lambda$ 是 $A$ 的主特征值，稳定阶段分布是与 $\\lambda$ 相关联并归一化使其总和为 1 的特征向量。\n- 使用连续三个时间步的聚合三元转移计数来评估马尔可夫假设。对于每个当前阶段 $j$，给定进入下一阶段 $i$ 的转移总计数，这些计数根据前一阶段历史的两个类别（例如，相对于 $j$ 的“前一阶段-低”与“前一阶段-高”）进行划分。在固定的 $j$ 上，使用适当的拟合优度检验来检验两个前一阶段类别间的分布是否相等，并确定在水平 $\\alpha_{\\text{Sig}}$ 上是否存在统计上显著的反对马尔可夫假设的证据。如果任何阶段 $j$ 显示出对前一阶段类别的显著依赖性，则认为该测试案例违反了马尔可夫假设。如果由于计数不足而无法对某个 $j$ 进行检验，则视该 $j$ 未提供反对该假设的证据。\n\n你的程序必须纯粹使用数学和逻辑运算来实现以上内容。以下测试套件提供了三个科学上合理的案例，所有量均为无单位。对于每个案例，构建 $A$，计算主特征值 $\\lambda$，并评估马尔可夫假设以产生布尔类型的结论。使用给定的 $K$、$n_t$、$N$、繁殖力親本样本计数 $m_j$、繁殖力后代计数 $b_j$、狄利克雷集中度 $\\alpha_{\\text{Dir}}$ 和马尔可夫检验显著性水平 $\\alpha_{\\text{Sig}}$。所有整数和实数均在测试套件中提供。需要时，通过对称狄利克雷正则化处理零计数。如果 $n_t(j)=0$，则设置 $s_j=0$，并确保相应的列（如果存在）仅贡献繁殖力。\n\n测试套件：\n- 案例 1 (理想路径，中等计数，适度正则化，无马尔可夫违例)：\n    - $K=4$\n    - $n_t = [120, 80, 60, 40]$\n    - $N$ 的列对应 $j=1,2,3,4$；行对应目标 $i=1,2,3,4$：\n      - 第 1 列： $[50, 30, 8, 2]$\n      - 第 2 列： $[10, 28, 18, 4]$\n      - 第 3 列： $[0, 6, 28, 14]$\n      - 第 4 列： $[0, 2, 8, 22]$\n    - 繁殖力亲本 $m = [60, 50, 40, 30]$\n    - 繁殖力后代 $b = [10, 25, 80, 90]$\n    - $\\alpha_{\\text{Dir}} = 0.5$\n    - $\\alpha_{\\text{Sig}} = 0.05$\n    - 三元聚合计数，对于每个当前阶段 $j$，两个前一阶段类别，每个都是关于下一阶段 $i$ 的数组：\n      - $j=1$：前一阶段-低 $[40, 25, 10, 2]$，前一阶段-高 $[35, 22, 9, 3]$\n      - $j=2$：前一阶段-低 $[12, 25, 14, 5]$，前一阶段-高 $[10, 22, 12, 6]$\n      - $j=3$：前一阶段-低 $[2, 6, 28, 10]$，前一阶段-高 $[0, 4, 30, 12]$\n      - $j=4$：前一阶段-低 $[0, 4, 12, 20]$，前一阶段-高 $[0, 2, 10, 22]$\n- 案例 2 (含零边界情况，依赖正则化，计数少，因检验效能低无马尔可夫违例)：\n    - $K=4$\n    - $n_t = [50, 0, 15, 5]$\n    - $N$:\n      - 第 1 列： $[15, 5, 0, 0]$\n      - 第 2 列： $[0, 0, 0, 0]$\n      - 第 3 列： $[3, 3, 2, 1]$\n      - 第 4 列： $[0, 1, 1, 2]$\n    - $m = [50, 0, 15, 5]$\n    - $b = [5, 0, 10, 8]$\n    - $\\alpha_{\\text{Dir}} = 1.0$\n    - $\\alpha_{\\text{Sig}} = 0.05$\n    - 三元聚合计数：\n      - $j=1$：前一阶段-低 $[8, 10, 2, 0]$，前一阶段-高 $[7, 9, 2, 0]$\n      - $j=3$：前一阶段-低 $[2, 3, 3, 1]$，前一阶段-高 $[1, 2, 3, 3]$\n      - $j=4$：前一阶段-低 $[0, 1, 1, 2]$，前一阶段-高 $[0, 1, 1, 2]$\n- 案例 3 (一个当前阶段有明显非马尔可夫信号)：\n    - $K=4$\n    - $n_t = [100, 100, 100, 100]$\n    - $N$:\n      - 第 1 列： $[40, 20, 10, 0]$\n      - 第 2 列： $[10, 30, 30, 10]$\n      - 第 3 列： $[5, 20, 40, 20]$\n      - 第 4 列： $[0, 10, 30, 50]$\n    - $m = [100, 100, 100, 100]$\n    - $b = [20, 40, 80, 100]$\n    - $\\alpha_{\\text{Dir}} = 0.3$\n    - $\\alpha_{\\text{Sig}} = 0.01$\n    - 三元聚合计数：\n      - $j=1$：前一阶段-低 $[30, 25, 15, 0]$，前一阶段-高 $[28, 22, 18, 2]$\n      - $j=2$：前一阶段-低 $[12, 30, 25, 13]$，前一阶段-高 $[5, 20, 35, 20]$\n      - $j=3$：前一阶段-低 $[3, 15, 45, 17]$，前一阶段-高 $[10, 30, 30, 15]$\n      - $j=4$：前一阶段-低 $[0, 10, 30, 50]$，前一阶段-高 $[0, 10, 30, 50]$\n\n算法要求：\n- 使用 $n_t(j)$ 和 $N(\\cdot,j)$ 估计 $s_j$。\n- 使用多项式最大似然估计（可选地通过由 $\\alpha_{\\text{Dir}}$ 控制的对称狄利克雷正则化）来估计 $p_{ij}$。如果阶段 $j$ 的总存活计数为零，则使用目标阶段上的均匀分布来构建 $A$ 中的 $p_{ij}$，注意生存因子将使这些项归零。\n- 使用聚合的后代数 $b_j$ 除以亲本样本量 $m_j$ 来估计 $f_j$，并约定若 $m_j=0$ 则 $f_j=0$。\n- 通过组合生存-生长转移和对新生阶段 $i=1$ 的繁殖力贡献来构建 $A$。\n- 计算 $\\lambda$ 作为 $A$ 的主特征值，并将其报告为浮点数。\n- 对于每个当前阶段 $j$ 的马尔可夫假设检验，应用皮尔逊卡方检验来检验两个前一阶段类别间的下一阶段分布是否相等。如果阶段 $j$ 的总计数不足以进行可靠检验，则跳过该 $j$。汇总所有 $j$ 的决策：如果在指定的显著性水平 $\\alpha_{\\text{Sig}}$ 下未检测到违例，则报告一个布尔值“真”，否则报告“假”。\n\n最终输出格式规范：\n你的程序应生成一行输出，其中包含三个测试案例的结果，格式为逗号分隔的列表，并用方括号括起，其中每个元素都是一个包含两个项目的列表 $[\\lambda,\\text{markov\\_ok}]$，$\\lambda$ 是浮点数，$\\text{markov\\_ok}$ 是布尔值。例如，你的最终输出必须看起来像 $[[\\lambda_1,\\text{True}],[\\lambda_2,\\text{False}],[\\lambda_3,\\text{True}]]$，其中的数值是你的程序计算出的实际值。",
            "solution": "从体型分箱数据构建阶段结构投影矩阵始于对生存、条件生长转移和繁殖力的定义。设 $K$ 为阶段数。在时间 $t$，各阶段的丰度向量表示为 $n_t(j)$，$j \\in \\{1,\\dots,K\\}$。观测到的转移计数 $N(i,j)$ 汇总了在时间 $t$ 处于阶段 $j$ 并在存活者中于时间 $t+1$ 观测到处于阶段 $i$ 的个体。从阶段 $j$ 存活的个体数量为 $\\sum_{i=1}^K N(i,j)$，特定阶段存活率分数为 $s_j = \\frac{\\sum_{i=1}^K N(i,j)}{n_t(j)}$（当 $n_t(j)>0$ 时），并约定当 $n_t(j)=0$ 时 $s_j=0$。这是在假设普查 $n_t(j)$ 和转移 $N(i,j)$ 是在同一区间测量的情况下，直接应用基于频率的生存估计。\n\n在存活的条件下，处于阶段 $j$ 的个体转移到阶段 $i$ 的概率被建模为关于 $i$ 的多项式分布。当分母为正时，多项式模型的最大似然估计 (MLE) 产生相对频率估计量 $p_{ij} = \\frac{N(i,j)}{\\sum_{i=1}^K N(i,j)}$。为了对有零值的情况进行正则化并提高稳定性，可以采用一个带有集中度参数 $\\alpha_{\\text{Dir}}$ 的对称狄利克雷先验。狄利克雷先验是多项式似然的共轭先验，类别概率的后验均值为\n$$\np_{ij} = \\frac{N(i,j) + \\alpha_{\\text{Dir}}}{\\sum_{i=1}^K N(i,j) + K \\,\\alpha_{\\text{Dir}}}.\n$$\n此表达式源于狄利克雷先验与多项式似然的共轭性，其中后验参数是先验参数加上观测计数。如果 $\\sum_{i=1}^K N(i,j) = 0$，则后验均值自动简化为均匀分布 $p_{ij} = \\frac{1}{K}$，但由于在这种情况下 $s_j=0$，阶段 $j$ 的生存-生长贡献在投影矩阵中将为零。\n\n繁殖力定义为当前时间步处于阶段 $j$ 的每个个体在下一个时间步贡献的进入第一阶段的新生个体的期望数量。使用聚合的后代计数 $b_j$ 和亲本样本量 $m_j$，繁殖力估计量为\n$$\nf_j = \\begin{cases}\n\\frac{b_j}{m_j}, & m_j > 0,\\\\\n0, & m_j=0,\n\\end{cases}\n$$\n这与计数比率估计量一致，其假设是后代被正确归因于亲本阶段，并且 $m_j$ 反映了抽样的贡献亲本数量。\n\n阶段结构投影矩阵 $A \\in \\mathbb{R}^{K\\times K}$ 汇集了从每个当前阶段 $j$ 到每个下一阶段 $i$ 的期望贡献。从阶段 $j$ 到阶段 $i$ 的生存-生长贡献是所有 $i$ 的乘积 $s_j \\, p_{ij}$，因为在 $n_t(j)$ 个体中，有比例为 $s_j$ 的个体存活，并根据 $p_{ij}$ 分布到目标阶段。繁殖贡献被假定进入新生阶段 $i=1$，因此繁殖力加到 $A$ 的第一行。因此，\n$$\nA_{ij} = \\begin{cases}\ns_j \\, p_{ij} + f_j, & i=1,\\\\\ns_j \\, p_{ij}, & i\\in\\{2,\\dots,K\\}.\n\\end{cases}\n$$\n第一行中的加法结构反映了处于阶段 $j$ 的个体既可以通过生存-生长存活并出现在阶段 $i=1$，也可以独立地通过繁殖产生进入阶段 $i=1$ 的新生个体。\n\n给定 $A$，渐近增长率由 $A$ 的主特征值 $\\lambda$ 决定。由于 $A$ 是非负矩阵，Perron-Frobenius (PF) 定理保证存在一个等于谱半径的实数主特征值 $\\lambda$ 和一个相应的正特征向量。在数值上，人们计算 $A$ 的特征值和特征向量，取实部最大的特征值作为 $\\lambda$，并通过将相关的右特征向量归一化使其总和为 1 来获得稳定阶段分布：\n$$\n\\lambda = \\max_{k} \\Re(\\mu_k), \\quad \\text{where } A v_k = \\mu_k v_k,\n$$\n稳定分布 $w$ 是 $w = \\frac{\\Re(v_{k^\\star})}{\\sum_i \\Re(v_{k^\\star,i})}$，其中 $k^\\star$ 是达到最大值的索引。\n\n为了在阶段层面评估马尔可夫假设，考虑连续三个时间步，并对固定的当前阶段 $j$，将进入下一阶段 $i$ 的转移总计数按两个前一阶段类别进行汇总。马尔可夫假设假定下一阶段结果的分布仅取决于 $j$；因此，两个前一阶段类别间的关于 $i$ 的分布应该是相等的。这可以通过对每个 $j$ 的 $2 \\times K$ 列联表进行皮尔遜卡方独立性检验来测试。对于阶段 $j$，构建表格\n$$\n\\begin{pmatrix}\nc^{(1)}_1 & c^{(1)}_2 & \\dots & c^{(1)}_K\\\\\nc^{(2)}_1 & c^{(2)}_2 & \\dots & c^{(2)}_K\n\\end{pmatrix},\n$$\n其中 $c^{(1)}_i$ 和 $c^{(2)}_i$ 是两个前一阶段类别进入下一阶段 $i$ 的转移计数。计算卡方检验统计量和 $p$-值。如果 $p$-值小于指定的显著性水平 $\\alpha_{\\text{Sig}}$，则对于该 $j$ 拒绝分布相等的原假设，表明有证据反对马尔可夫假设。如果计数不足（例如，总数太小或有零行），可以跳过对该 $j$ 的检验以避免虚假的结论。汇总所有 $j$ 的结果：如果有任何被检验的 $j$ 拒绝了原假设，则声明存在违例；否则，接受该案例的马尔可夫假设。\n\n将这些步骤应用于测试套件：\n- 对于案例 1，使用 $n_t$ 和 $N$ 计算 $s_j$，用 $\\alpha_{\\text{Dir}}=0.5$ 估计 $p_{ij}$，使用 $b$ 和 $m$ 估计 $f_j$，构建 $A$，并计算 $\\lambda$。在 $\\alpha_{\\text{Sig}}=0.05$ 的水平下对每个当前阶段 $j$ 进行卡方检验；鉴于提供的三元计数，前一阶段类别间的分布是相似的，因此检验不应拒绝原假设，从而对马尔可夫假设得出“真”的结论。\n- 对于案例 2，$n_t$ 和 $N$ 中的零值需要使用 $\\alpha_{\\text{Dir}}=1.0$ 的正则化以避免退化的转移。相应地计算 $s_j$、$p_{ij}$、$f_j$ 和 $A$。三元计数很小；在 $\\alpha_{\\text{Sig}}=0.05$ 水平下，有限的检验效能加上类别间的相似模式不应导致拒绝，因此马尔可夫结论应为“真”。\n- 对于案例 3，在 $\\alpha_{\\text{Dir}}=0.3$ 下计算 $s_j$、$p_{ij}$、$f_j$、$A$ 和 $\\lambda$。所构建的三元计数旨在显示至少一个当前阶段（例如 $j=2$ 和 $j=3$）的前一阶段类别间存在显著差异，并且在更严格的水平 $\\alpha_{\\text{Sig}}=0.01$ 下，卡方检验应对这些 $j$ 拒绝原假设，从而导致对马尔可夫假设得出“假”的结论。\n\n因此，程序为每个案例输出配对 $[\\lambda,\\text{markov\\_ok}]$ 并将它们聚合成指定的单行列表格式。特征值和卡方 $p$-值的数值计算依赖于与上述数学定义一致的既定线性代数和统计检验程序。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import chi2_contingency\n\ndef estimate_survival(n_t, N):\n    \"\"\"\n    Estimate stage-specific survival s_j as survivors / initial counts.\n    n_t: array of shape (K,)\n    N: array of shape (K,K) with columns j and rows i (destinations)\n    Returns s: array of shape (K,)\n    \"\"\"\n    K = len(n_t)\n    s = np.zeros(K, dtype=float)\n    for j in range(K):\n        survivors = float(np.sum(N[:, j]))\n        if n_t[j] > 0:\n            s[j] = survivors / float(n_t[j])\n        else:\n            s[j] = 0.0\n    # Clip to [0,1] for numerical safety\n    return np.clip(s, 0.0, 1.0)\n\ndef estimate_p_ij(N, alpha_dirichlet):\n    \"\"\"\n    Estimate conditional transition probabilities p_{ij} per column j.\n    Uses multinomial MLE with symmetric Dirichlet regularization alpha_dirichlet.\n    N: array (K,K), columns j, rows i\n    Returns P: array (K,K) where columns sum to 1 (unless total survivors=0 -> uniform).\n    \"\"\"\n    K = N.shape[0]\n    P = np.zeros_like(N, dtype=float)\n    for j in range(K):\n        col = N[:, j].astype(float)\n        total = float(np.sum(col))\n        if total > 0.0:\n            # Posterior mean under symmetric Dirichlet prior\n            P[:, j] = (col + alpha_dirichlet) / (total + K * alpha_dirichlet)\n        else:\n            # No survivors: uniform distribution (will be zeroed by s_j anyway)\n            P[:, j] = np.full(K, 1.0 / K)\n    return P\n\ndef estimate_fecundity(b, m):\n    \"\"\"\n    Estimate per-stage fecundity f_j = b_j / m_j with f_j=0 when m_j=0.\n    b: array (K,) offspring counts per stage\n    m: array (K,) parent sample sizes per stage\n    Returns f: array (K,)\n    \"\"\"\n    f = np.zeros_like(b, dtype=float)\n    for j in range(len(b)):\n        if m[j] > 0:\n            f[j] = float(b[j]) / float(m[j])\n        else:\n            f[j] = 0.0\n    return f\n\ndef build_projection_matrix(n_t, N, b, m, alpha_dirichlet):\n    \"\"\"\n    Construct the stage-structured projection matrix A.\n    A_{ij} = s_j * p_{ij} for all i, with fecundity added to first row: A_{1j} += f_j.\n    \"\"\"\n    K = len(n_t)\n    s = estimate_survival(n_t, N)\n    P = estimate_p_ij(N, alpha_dirichlet)\n    f = estimate_fecundity(b, m)\n    A = np.zeros((K, K), dtype=float)\n    # Survival-growth contributions\n    for j in range(K):\n        A[:, j] = s[j] * P[:, j]\n    # Fecundity contributions to recruit stage (i=0 in zero-based indexing)\n    A[0, :] += f\n    return A\n\ndef dominant_eigenvalue(A):\n    \"\"\"\n    Compute the dominant eigenvalue (largest real part) of nonnegative matrix A.\n    \"\"\"\n    w, v = np.linalg.eig(A)\n    # Select eigenvalue with largest real part\n    idx = np.argmax(w.real)\n    lam = float(w.real[idx])\n    return lam\n\ndef test_markov_assumption(triplet_counts_by_j, alpha_sig, min_total_per_group=4):\n    \"\"\"\n    Evaluate the Markovian assumption using Pearson Chi-Square test per current stage j.\n    triplet_counts_by_j: dict mapping j (0-based) -> {'prev_low': array(K,), 'prev_high': array(K,)}\n    alpha_sig: significance level for rejecting equality of distributions\n    min_total_per_group: minimum total counts per group to attempt test\n    Returns True if no violation detected; False otherwise.\n    \"\"\"\n    violation = False\n    for j, groups in triplet_counts_by_j.items():\n        low = np.array(groups['prev_low'], dtype=float)\n        high = np.array(groups['prev_high'], dtype=float)\n        if np.sum(low) < min_total_per_group or np.sum(high) < min_total_per_group:\n            # Insufficient counts: skip this stage\n            continue\n        table = np.vstack([low, high])\n        # Perform chi-square test for independence\n        try:\n            chi2, pval, dof, expected = chi2_contingency(table, correction=False)\n        except Exception:\n            # In case of numerical issues, add small smoothing and retry\n            eps = 1e-8\n            table = table + eps\n            chi2, pval, dof, expected = chi2_contingency(table, correction=False)\n        if pval < alpha_sig:\n            violation = True\n            # No need to continue if violation found; but continue to parse all to be thorough\n    return not violation\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case is a dict encoding K, n_t, N, m, b, alpha_dirichlet, alpha_sig, triplet_counts_by_j\n    test_cases = [\n        {\n            \"K\": 4,\n            \"n_t\": np.array([120, 80, 60, 40], dtype=int),\n            \"N\": np.array([\n                [50, 10, 0, 0],\n                [30, 28, 6, 2],\n                [8, 18, 28, 8],\n                [2, 4, 14, 22]\n            ], dtype=int),\n            \"m\": np.array([60, 50, 40, 30], dtype=int),\n            \"b\": np.array([10, 25, 80, 90], dtype=int),\n            \"alpha_dirichlet\": 0.5,\n            \"alpha_sig\": 0.05,\n            \"triplet\": {\n                0: {\"prev_low\": np.array([40, 25, 10, 2], dtype=int),\n                    \"prev_high\": np.array([35, 22, 9, 3], dtype=int)},\n                1: {\"prev_low\": np.array([12, 25, 14, 5], dtype=int),\n                    \"prev_high\": np.array([10, 22, 12, 6], dtype=int)},\n                2: {\"prev_low\": np.array([2, 6, 28, 10], dtype=int),\n                    \"prev_high\": np.array([0, 4, 30, 12], dtype=int)},\n                3: {\"prev_low\": np.array([0, 4, 12, 20], dtype=int),\n                    \"prev_high\": np.array([0, 2, 10, 22], dtype=int)}\n            }\n        },\n        {\n            \"K\": 4,\n            \"n_t\": np.array([50, 0, 15, 5], dtype=int),\n            \"N\": np.array([\n                [15, 0, 3, 0],\n                [5, 0, 3, 1],\n                [0, 0, 2, 1],\n                [0, 0, 1, 2]\n            ], dtype=int),\n            \"m\": np.array([50, 0, 15, 5], dtype=int),\n            \"b\": np.array([5, 0, 10, 8], dtype=int),\n            \"alpha_dirichlet\": 1.0,\n            \"alpha_sig\": 0.05,\n            \"triplet\": {\n                0: {\"prev_low\": np.array([8, 10, 2, 0], dtype=int),\n                    \"prev_high\": np.array([7, 9, 2, 0], dtype=int)},\n                2: {\"prev_low\": np.array([2, 3, 3, 1], dtype=int),\n                    \"prev_high\": np.array([1, 2, 3, 3], dtype=int)},\n                3: {\"prev_low\": np.array([0, 1, 1, 2], dtype=int),\n                    \"prev_high\": np.array([0, 1, 1, 2], dtype=int)}\n            }\n        },\n        {\n            \"K\": 4,\n            \"n_t\": np.array([100, 100, 100, 100], dtype=int),\n            \"N\": np.array([\n                [40, 10, 5, 0],\n                [20, 30, 20, 10],\n                [10, 30, 40, 30],\n                [0, 10, 20, 50]\n            ], dtype=int),\n            \"m\": np.array([100, 100, 100, 100], dtype=int),\n            \"b\": np.array([20, 40, 80, 100], dtype=int),\n            \"alpha_dirichlet\": 0.3,\n            \"alpha_sig\": 0.01,\n            \"triplet\": {\n                0: {\"prev_low\": np.array([30, 25, 15, 0], dtype=int),\n                    \"prev_high\": np.array([28, 22, 18, 2], dtype=int)},\n                1: {\"prev_low\": np.array([12, 30, 25, 13], dtype=int),\n                    \"prev_high\": np.array([5, 20, 35, 20], dtype=int)},\n                2: {\"prev_low\": np.array([3, 15, 45, 17], dtype=int),\n                    \"prev_high\": np.array([10, 30, 30, 15], dtype=int)},\n                3: {\"prev_low\": np.array([0, 10, 30, 50], dtype=int),\n                    \"prev_high\": np.array([0, 10, 30, 50], dtype=int)}\n            }\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        K = case[\"K\"]\n        n_t = case[\"n_t\"]\n        N = case[\"N\"]\n        m = case[\"m\"]\n        b = case[\"b\"]\n        alpha_dir = case[\"alpha_dirichlet\"]\n        alpha_sig = case[\"alpha_sig\"]\n        triplet = case[\"triplet\"]\n\n        # Build projection matrix\n        A = build_projection_matrix(n_t, N, b, m, alpha_dir)\n        # Compute dominant eigenvalue\n        lam = dominant_eigenvalue(A)\n        # Evaluate Markov assumption\n        markov_ok = test_markov_assumption(triplet, alpha_sig, min_total_per_group=K)\n\n        # Round lambda for neat output\n        lam_rounded = round(lam, 6)\n        results.append([lam_rounded, markov_ok])\n\n    # Final print statement in the exact required format.\n    print(f\"[[{results[0][0]}, {results[0][1]}],[{results[1][0]}, {results[1][1]}],[{results[2][0]}, {results[2][1]}]]\".replace(\"True\", \"True\").replace(\"False\", \"False\"))\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}