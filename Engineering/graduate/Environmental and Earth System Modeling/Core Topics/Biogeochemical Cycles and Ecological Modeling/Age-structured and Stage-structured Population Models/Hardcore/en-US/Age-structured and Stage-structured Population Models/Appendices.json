{
    "hands_on_practices": [
        {
            "introduction": "While the dominant eigenvalue, $\\lambda$, of a Leslie matrix determines the long-term asymptotic growth rate of a population, the short-term or transient dynamics can be dramatically different. This exercise explores a classic scenario where a population, despite being destined for long-term growth, experiences a temporary decline due to a skewed initial age distribution. Understanding these transient effects is critical for conservation biology and resource management, where short-term population viability can determine the success or failure of an intervention .",
            "id": "1830225",
            "problem": "A team of ecologists is studying a newly discovered species of island reptile. They model its population dynamics using an age-structured approach with a time step of one year. The population is categorized into four age classes:\n-   Class 1: Hatchlings (0 to 1 year old)\n-   Class 2: Juveniles (1 to 2 years old)\n-   Class 3: Adults (2 to 3 years old)\n-   Class 4: Senescent (3 to 4 years old)\n\nNo individual survives beyond 4 years. The per-capita fecundity rate for an individual in age class $i$, denoted $F_i$, is the average number of hatchlings produced per year by that individual. The survival rate for an individual in age class $i$, denoted $S_i$, is the probability that it survives to enter age class $i+1$. The ecologists have determined the following vital rates:\n-   Fecundity rates: $F_1 = 0$, $F_2 = 1.0$, $F_3 = 2.0$, $F_4 = 0$.\n-   Survival rates: $S_1 = 0.8$, $S_2 = 0.6$, $S_3 = 0.3$.\n\nAn initial census of the population is conducted at time $t=0$, yielding the following numbers for each age class:\n-   $n_1(0) = 100$ Hatchlings\n-   $n_2(0) = 100$ Juveniles\n-   $n_3(0) = 100$ Adults\n-   $n_4(0) = 2000$ Senescent individuals\n\nAlthough the long-term growth rate for this population is greater than one, the initial age distribution may cause transient dynamics. Calculate the ratio of the total population size at $t=1$ year to the total population size at $t=0$. Round your final answer to three significant figures.",
            "solution": "Let $n_{i}(t)$ denote the number of individuals in age class $i$ at time $t$, and let $N(t)=\\sum_{i=1}^{4}n_{i}(t)$ be the total population at time $t$. For a Leslie matrix model with time step one year, the age-structured update equations are\n$$\nn_{1}(t+1)=\\sum_{i=1}^{4}F_{i}\\,n_{i}(t),\\quad\nn_{2}(t+1)=S_{1}\\,n_{1}(t),\\quad\nn_{3}(t+1)=S_{2}\\,n_{2}(t),\\quad\nn_{4}(t+1)=S_{3}\\,n_{3}(t).\n$$\nUsing the given rates $F_{1}=0$, $F_{2}=1.0$, $F_{3}=2.0$, $F_{4}=0$, and $S_{1}=0.8$, $S_{2}=0.6$, $S_{3}=0.3$, together with the initial census $n_{1}(0)=100$, $n_{2}(0)=100$, $n_{3}(0)=100$, $n_{4}(0)=2000$, we compute:\n$$\nn_{1}(1)=F_{1}n_{1}(0)+F_{2}n_{2}(0)+F_{3}n_{3}(0)+F_{4}n_{4}(0)=0\\cdot 100+1.0\\cdot 100+2.0\\cdot 100+0\\cdot 2000=300,\n$$\n$$\nn_{2}(1)=S_{1}n_{1}(0)=0.8\\cdot 100=80,\\quad\nn_{3}(1)=S_{2}n_{2}(0)=0.6\\cdot 100=60,\\quad\nn_{4}(1)=S_{3}n_{3}(0)=0.3\\cdot 100=30.\n$$\nTherefore,\n$$\nN(0)=n_{1}(0)+n_{2}(0)+n_{3}(0)+n_{4}(0)=100+100+100+2000=2300,\n$$\n$$\nN(1)=n_{1}(1)+n_{2}(1)+n_{3}(1)+n_{4}(1)=300+80+60+30=470.\n$$\nThe requested ratio is\n$$\n\\frac{N(1)}{N(0)}=\\frac{470}{2300}=0.204347826\\ldots\n$$\nRounded to three significant figures, this is $0.204$.",
            "answer": "$$\\boxed{0.204}$$"
        },
        {
            "introduction": "Building on the concept of transient dynamics, we now delve into the underlying mathematical mechanism that permits such behavior. This practice demonstrates that a population can experience short-term growth even if its long-term fate is extinction, a phenomenon possible when the projection matrix is non-normal. By analyzing the properties of the matrix, you will connect abstract concepts from linear algebra, such as non-orthogonality of eigenvectors, to the tangible ecological outcome of transient amplification, providing a deeper, mechanistic understanding of population projections .",
            "id": "3860255",
            "problem": "Consider a discrete-time age-structured population model with two age classes (juveniles and adults), whose dynamics are governed by a Leslie matrix. Let the population state at time $t$ be $n_t \\in \\mathbb{R}^2_{\\ge 0}$ and the update rule be $n_{t+1} = L n_t$, where the Leslie matrix $L$ is given by\n$$\nL = \\begin{pmatrix}\nf_1  f_2 \\\\\ns_1  0\n\\end{pmatrix}.\n$$\nAssume the following biologically plausible parameters: juvenile fertility $f_1 = 0.3$, adult fertility $f_2 = 1.5$, and juvenile survival $s_1 = 0.4$. The entries of $L$ are nonnegative and represent age-specific fertility and survival consistent with standard age-structured population models.\n\nStarting only from the definitions of a Leslie matrix, spectral radius, eigenvectors, and non-normality, analyze this system to demonstrate that this $L$ is non-normal and has dominant eigenvalue $\\lambda$ strictly less than $1$. Explain how non-orthogonality of the right eigenvectors can generate transient growth even when the dominant eigenvalue is less than $1$, thus constructing an explicit example of a non-normal Leslie matrix with $\\lambda1$ exhibiting transient growth.\n\nDefine the total population size at time $t$ as $\\|n_t\\|_1 = |(n_t)_1| + |(n_t)_2|$. For initial states $n_0$ satisfying $\\|n_0\\|_1 = 1$, the maximal transient growth factor over two time steps is\n$$\nG_{\\max}(2) \\equiv \\sup_{\\|n_0\\|_1 = 1} \\frac{\\|n_2\\|_1}{\\|n_0\\|_1}.\n$$\nCompute $G_{\\max}(2)$ for the matrix $L$ specified above. Express your final answer as a unitless number rounded to four significant figures.",
            "solution": "The problem asks for an analysis of a given $2 \\times 2$ Leslie matrix, including a demonstration of its non-normality, a proof that its dominant eigenvalue is less than $1$, an explanation of transient growth, and the computation of the maximal growth factor over two time steps, $G_{\\max}(2)$.\n\nThe problem is validated as scientifically grounded, well-posed, and objective. All necessary information is provided, and the task is a standard exercise in mathematical population biology.\n\nFirst, we substitute the given parameter values, juvenile fertility $f_1 = 0.3$, adult fertility $f_2 = 1.5$, and juvenile survival $s_1 = 0.4$, into the Leslie matrix $L$:\n$$\nL = \\begin{pmatrix} f_1  f_2 \\\\ s_1  0 \\end{pmatrix} = \\begin{pmatrix} 0.3  1.5 \\\\ 0.4  0 \\end{pmatrix}\n$$\n\n**1. Non-Normality of the Matrix $L$**\n\nA matrix $A$ is defined as normal if it commutes with its conjugate transpose, $AA^* = A^*A$. For a real matrix like $L$, this condition becomes $LL^T = L^T L$, where $L^T$ is the transpose of $L$.\n\nThe transpose of $L$ is:\n$$\nL^T = \\begin{pmatrix} 0.3  0.4 \\\\ 1.5  0 \\end{pmatrix}\n$$\nNow, we compute the products $LL^T$ and $L^T L$:\n$$\nLL^T = \\begin{pmatrix} 0.3  1.5 \\\\ 0.4  0 \\end{pmatrix} \\begin{pmatrix} 0.3  0.4 \\\\ 1.5  0 \\end{pmatrix} = \\begin{pmatrix} (0.3)^2 + (1.5)^2  (0.3)(0.4) \\\\ (0.4)(0.3)  (0.4)^2 \\end{pmatrix} = \\begin{pmatrix} 0.09 + 2.25  0.12 \\\\ 0.12  0.16 \\end{pmatrix} = \\begin{pmatrix} 2.34  0.12 \\\\ 0.12  0.16 \\end{pmatrix}\n$$\n$$\nL^T L = \\begin{pmatrix} 0.3  0.4 \\\\ 1.5  0 \\end{pmatrix} \\begin{pmatrix} 0.3  1.5 \\\\ 0.4  0 \\end{pmatrix} = \\begin{pmatrix} (0.3)^2 + (0.4)^2  (0.3)(1.5) \\\\ (1.5)(0.3)  (1.5)^2 \\end{pmatrix} = \\begin{pmatrix} 0.09 + 0.16  0.45 \\\\ 0.45  2.25 \\end{pmatrix} = \\begin{pmatrix} 0.25  0.45 \\\\ 0.45  2.25 \\end{pmatrix}\n$$\nSince $LL^T \\neq L^T L$, the matrix $L$ is non-normal.\n\n**2. Eigenvalue Analysis**\n\nThe eigenvalues $\\lambda$ of $L$ are the roots of the characteristic equation $\\det(L - \\lambda I) = 0$, where $I$ is the identity matrix.\n$$\n\\det \\begin{pmatrix} 0.3 - \\lambda  1.5 \\\\ 0.4  -\\lambda \\end{pmatrix} = 0\n$$\n$$\n(0.3 - \\lambda)(-\\lambda) - (1.5)(0.4) = 0\n$$\n$$\n-0.3\\lambda + \\lambda^2 - 0.6 = 0\n$$\n$$\n\\lambda^2 - 0.3\\lambda - 0.6 = 0\n$$\nUsing the quadratic formula, $\\lambda = \\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a}$:\n$$\n\\lambda = \\frac{0.3 \\pm \\sqrt{(-0.3)^2 - 4(1)(-0.6)}}{2} = \\frac{0.3 \\pm \\sqrt{0.09 + 2.4}}{2} = \\frac{0.3 \\pm \\sqrt{2.49}}{2}\n$$\nThe two eigenvalues are $\\lambda_1 = \\frac{0.3 + \\sqrt{2.49}}{2}$ and $\\lambda_2 = \\frac{0.3 - \\sqrt{2.49}}{2}$.\nThe dominant eigenvalue, which determines the long-term asymptotic behavior of the population, is the one with the largest magnitude. By the Perron-Frobenius theorem for non-negative matrices, this is the positive real eigenvalue, $\\lambda = \\lambda_1$.\n\nWe need to show that $\\lambda  1$:\n$$\n\\frac{0.3 + \\sqrt{2.49}}{2}  1\n$$\n$$\n0.3 + \\sqrt{2.49}  2\n$$\n$$\n\\sqrt{2.49}  1.7\n$$\nSquaring both sides (both are positive):\n$$\n2.49  (1.7)^2 = 2.89\n$$\nThis inequality is true, so the dominant eigenvalue $\\lambda$ is strictly less than $1$. This implies that the population size will asymptotically decay to zero, i.e., $\\lim_{t\\to\\infty} n_t = 0$ for any initial state $n_0$.\n\n**3. Transient Growth from Non-Normality**\n\nThe established facts are: (i) $L$ is non-normal, and (ii) its dominant eigenvalue (spectral radius) $\\rho(L) = \\lambda  1$.\nThe non-normality of $L$ implies that its eigenvectors are not orthogonal. An initial population vector $n_0$ can be projected onto the basis of eigenvectors. The evolution of the population is given by $n_t = L^t n_0$. Due to the non-orthogonality of the eigenvectors, there can be constructive interference between the components for short time periods. This can lead to a temporary increase in the population size, as measured by a chosen norm, before the eventual decay dictated by $\\rho(L)  1$ takes over. This phenomenon is known as transient growth.\n\nMore formally, transient growth is possible if the matrix norm $\\|L^k\\|$ is greater than $1$ for some integer $k \\ge 1$. For a normal matrix $A$, the induced $2$-norm satisfies $\\|A^k\\|_2 = (\\rho(A))^k$. If $\\rho(A)  1$, then $\\|A^k\\|_2  1$ for all $k \\ge 1$, precluding transient growth (in the $2$-norm). For a non-normal matrix like $L$, it is possible to have $\\|L^k\\|  1$ even when $\\rho(L)  1$. This matrix $L$ provides an explicit example.\n\n**4. Computation of $G_{\\max}(2)$**\n\nThe maximal transient growth factor over two time steps, $G_{\\max}(2)$, is defined as:\n$$\nG_{\\max}(2) = \\sup_{\\|n_0\\|_1 = 1} \\frac{\\|n_2\\|_1}{\\|n_0\\|_1}\n$$\nSince $n_2 = L^2 n_0$ and we are considering initial states with $\\|n_0\\|_1 = 1$, this simplifies to:\n$$\nG_{\\max}(2) = \\sup_{\\|n_0\\|_1 = 1} \\|L^2 n_0\\|_1\n$$\nThis expression is the definition of the induced matrix $1$-norm of the matrix $L^2$, denoted $\\|L^2\\|_1$. The $1$-norm of a matrix is the maximum of the absolute column sums.\n\nFirst, we calculate the matrix $L^2$:\n$$\nL^2 = L \\cdot L = \\begin{pmatrix} 0.3  1.5 \\\\ 0.4  0 \\end{pmatrix} \\begin{pmatrix} 0.3  1.5 \\\\ 0.4  0 \\end{pmatrix}\n$$\n$$\nL^2 = \\begin{pmatrix} (0.3)(0.3) + (1.5)(0.4)  (0.3)(1.5) + (1.5)(0) \\\\ (0.4)(0.3) + (0)(0.4)  (0.4)(1.5) + (0)(0) \\end{pmatrix}\n$$\n$$\nL^2 = \\begin{pmatrix} 0.09 + 0.60  0.45 \\\\ 0.12  0.60 \\end{pmatrix} = \\begin{pmatrix} 0.69  0.45 \\\\ 0.12  0.60 \\end{pmatrix}\n$$\nThe entries of $L^2$ are all non-negative, so the absolute values in the sum are redundant. We compute the sum of each column of $L^2$:\nSum of column 1: $0.69 + 0.12 = 0.81$\nSum of column 2: $0.45 + 0.60 = 1.05$\n\nThe induced $1$-norm is the maximum of these sums:\n$$\n\\|L^2\\|_1 = \\max(0.81, 1.05) = 1.05\n$$\nTherefore, the maximal transient growth factor over two time steps is $G_{\\max}(2) = 1.05$. Since $G_{\\max}(2)  1$, this system exhibits transient growth over two steps, despite being asymptotically stable.\n\nThe problem requires the answer to be rounded to four significant figures.\n$$\n1.05 = 1.050\n$$",
            "answer": "$$\\boxed{1.050}$$"
        },
        {
            "introduction": "This final practice moves from analyzing pre-defined models to the applied work of building and critiquing them from empirical data. You will undertake the complete workflow of a population modeler: estimating survival, growth, and fecundity rates from raw census counts to construct a stage-structured projection matrix. Furthermore, you will learn to test a fundamental assumption of these models—that transitions are Markovian—using statistical methods, developing the essential skills for validating models against real-world evidence .",
            "id": "3860290",
            "problem": "You are given discrete size-binned census and transition data for a single species monitored at regular time steps. The aim is to construct a stage-structured projection matrix that advances the population vector from one time step to the next based on survival, growth, and reproduction, and to evaluate whether the stage-level dynamics are consistent with a Markov process assumption. The fundamental base for this construction consists of the following well-tested facts and core definitions: a stage-structured population is represented by a nonnegative projection matrix acting on a stage-abundance vector; survival and growth between discrete stages can be modeled by a stage-to-stage transition probability matrix consistent with a Markov chain; reproduction can be represented as per-stage contributions to a predefined recruit stage; the dominant eigenvalue of a nonnegative matrix determines the asymptotic growth rate by the Perron-Frobenius theorem; and Maximum Likelihood Estimation (MLE) for a multinomial model yields relative-frequency estimators, while a Dirichlet-conjugate prior yields a regularized estimator that avoids degeneracies for zero counts.\n\nYou must implement the following concepts in your program from first principles:\n- Let there be $K$ discrete size stages indexed by $i \\in \\{1,\\dots,K\\}$. Let $n_t(j)$ denote the number of individuals observed in stage $j$ at the current time $t$, and let $N(i,j)$ denote the number of individuals observed to transition from stage $j$ at time $t$ to stage $i$ at time $t+1$ among survivors. The stage-specific survival $s_j$ is the fraction of individuals in stage $j$ that survived to any stage at the next time step, and the conditional growth-distribution over destination stages given survival is represented by a probability vector across $i$ for each $j$, denoted by $p_{ij}$, which should be estimated from $N(i,j)$ using Maximum Likelihood Estimation and optionally regularized by a symmetric Dirichlet prior with concentration parameter $\\alpha_{\\text{Dir}}$ to handle zero counts. The Markovian assumption at the stage level is that the distribution of next-stage outcomes depends only on the current stage $j$ and not on the previous stage before $j$.\n- Let $f_j$ denote the per-stage fecundity, defined as the expected number of recruits entering stage $i=1$ at time $t+1$ contributed by an individual in stage $j$ at time $t$. Estimate $f_j$ using aggregated offspring counts for stage $j$ divided by the number of sampled parent individuals in stage $j$ over the interval.\n- Construct the stage-structured projection matrix $A \\in \\mathbb{R}^{K \\times K}$ such that $A_{ij}$ equals the expected number of individuals in stage $i$ at time $t+1$ produced per individual in stage $j$ at time $t$. Combine survival-growth and fecundity in the first row (recruit stage) appropriately. The asymptotic growth rate $\\lambda$ is the dominant eigenvalue of $A$ and the stable stage distribution is the eigenvector associated with $\\lambda$ normalized to sum to $1$.\n- Evaluate the Markovian assumption using aggregated triplet transition counts over three successive time steps. For each current stage $j$, you are given aggregated counts of transitions into next stage $i$ split by two categories of previous stage history (for example, \"previous-low\" versus \"previous-high\" relative to $j$). Use an appropriate goodness-of-fit test for equality of distributions across the two previous-stage categories at fixed $j$ and determine whether there is statistically significant evidence against the Markovian assumption at level $\\alpha_{\\text{Sig}}$. If any stage $j$ shows significant dependence on the previous stage category, then the Markovian assumption is considered violated for that test case. If a test for some $j$ is not applicable because of insufficient counts, treat that $j$ as not providing evidence against the assumption.\n\nYour program must implement the above using purely mathematical and logical operations. The following test suite provides three scientifically plausible cases, with all quantities unitless. For each case, construct $A$, compute the dominant eigenvalue $\\lambda$, and evaluate the Markovian assumption to produce a boolean verdict. Use the given $K$, $n_t$, $N$, fecundity parent-sample counts $m_j$, fecundity offspring counts $b_j$, Dirichlet concentration $\\alpha_{\\text{Dir}}$, and the Markov test significance $\\alpha_{\\text{Sig}}$. All integers and reals are provided in the test suite. When needed, handle zero counts via symmetric Dirichlet regularization. If $n_t(j)=0$, set $s_j=0$ and ensure the corresponding column contributes only fecundity if present.\n\nTest suite:\n- Case $1$ (happy path, moderate counts, modest regularization, no Markov violation):\n    - $K=4$\n    - $n_t = [120, 80, 60, 40]$\n    - $N$ columns correspond to $j=1,2,3,4$; rows correspond to destination $i=1,2,3,4$:\n      - Column $1$: $[50, 30, 8, 2]$\n      - Column $2$: $[10, 28, 18, 4]$\n      - Column $3$: $[0, 6, 28, 14]$\n      - Column $4$: $[0, 2, 8, 22]$\n    - Fecundity parents $m = [60, 50, 40, 30]$\n    - Fecundity offspring $b = [10, 25, 80, 90]$\n    - $\\alpha_{\\text{Dir}} = 0.5$\n    - $\\alpha_{\\text{Sig}} = 0.05$\n    - Triplet aggregated counts, for each current stage $j$, two previous-stage categories, each an array over next-stage $i$:\n      - $j=1$: previous-low $[40, 25, 10, 2]$, previous-high $[35, 22, 9, 3]$\n      - $j=2$: previous-low $[12, 25, 14, 5]$, previous-high $[10, 22, 12, 6]$\n      - $j=3$: previous-low $[2, 6, 28, 10]$, previous-high $[0, 4, 30, 12]$\n      - $j=4$: previous-low $[0, 4, 12, 20]$, previous-high $[0, 2, 10, 22]$\n- Case $2$ (boundary with zeros, relies on regularization, small counts, no Markov violation due to low power):\n    - $K=4$\n    - $n_t = [50, 0, 15, 5]$\n    - $N$:\n      - Column $1$: $[15, 5, 0, 0]$\n      - Column $2$: $[0, 0, 0, 0]$\n      - Column $3$: $[3, 3, 2, 1]$\n      - Column $4$: $[0, 1, 1, 2]$\n    - $m = [50, 0, 15, 5]$\n    - $b = [5, 0, 10, 8]$\n    - $\\alpha_{\\text{Dir}} = 1.0$\n    - $\\alpha_{\\text{Sig}} = 0.05$\n    - Triplet aggregated counts:\n      - $j=1$: previous-low $[8, 10, 2, 0]$, previous-high $[7, 9, 2, 0]$\n      - $j=3$: previous-low $[2, 3, 3, 1]$, previous-high $[1, 2, 3, 3]$\n      - $j=4$: previous-low $[0, 1, 1, 2]$, previous-high $[0, 1, 1, 2]$\n- Case $3$ (clear non-Markovian signal in one current stage):\n    - $K=4$\n    - $n_t = [100, 100, 100, 100]$\n    - $N$:\n      - Column $1$: $[40, 20, 10, 0]$\n      - Column $2$: $[10, 30, 30, 10]$\n      - Column $3$: $[5, 20, 40, 20]$\n      - Column $4$: $[0, 10, 30, 50]$\n    - $m = [100, 100, 100, 100]$\n    - $b = [20, 40, 80, 100]$\n    - $\\alpha_{\\text{Dir}} = 0.3$\n    - $\\alpha_{\\text{Sig}} = 0.01$\n    - Triplet aggregated counts:\n      - $j=1$: previous-low $[30, 25, 15, 0]$, previous-high $[28, 22, 18, 2]$\n      - $j=2$: previous-low $[12, 30, 25, 13]$, previous-high $[5, 20, 35, 20]$\n      - $j=3$: previous-low $[3, 15, 45, 17]$, previous-high $[10, 30, 30, 15]$\n      - $j=4$: previous-low $[0, 10, 30, 50]$, previous-high $[0, 10, 30, 50]$\n\nAlgorithmic requirements:\n- Estimate $s_j$ using $n_t(j)$ and $N(\\cdot,j)$.\n- Estimate $p_{ij}$ using Multinomial Maximum Likelihood Estimation with optional symmetric Dirichlet regularization controlled by $\\alpha_{\\text{Dir}}$. If the total survivor count for stage $j$ is zero, use the uniform distribution over destination stages for $p_{ij}$ to construct $A$, noting that the survival factor will zero out those entries.\n- Estimate $f_j$ using the aggregated offspring $b_j$ divided by the parent sample size $m_j$, with the convention $f_j=0$ if $m_j=0$.\n- Construct $A$ by combining survival-growth transitions and fecundity contributions to the recruit stage $i=1$.\n- Compute $\\lambda$ as the dominant eigenvalue of $A$ and report it as a float.\n- For the Markovian assumption test at each current stage $j$, apply a Pearson Chi-Square test for equality of next-stage distributions across the two previous-stage categories. If the total counts at stage $j$ are insufficient for a reliable test, skip that $j$. Aggregate the decision across $j$: report a boolean that is true if no violation is detected at the specified significance level $\\alpha_{\\text{Sig}}$, and false otherwise.\n\nFinal output format specification:\nYour program should produce a single line of output containing the results for the three test cases as a comma-separated list enclosed in square brackets, where each element is a two-item list $[\\lambda,\\text{markov\\_ok}]$ with $\\lambda$ a float and $\\text{markov\\_ok}$ a boolean. For example, your final output must look like $[[\\lambda_1,\\text{True}],[\\lambda_2,\\text{False}],[\\lambda_3,\\text{True}]]$ with the actual numeric values computed by your program.",
            "solution": "The construction of a stage-structured projection matrix from size-binned data begins with the definitions of survival, conditional growth transitions, and fecundity. Let $K$ be the number of stages. At time $t$, the abundance vector over stages is denoted by $n_t(j)$ for $j \\in \\{1,\\dots,K\\}$. Observed transition counts $N(i,j)$ aggregate individuals that were in stage $j$ at time $t$ and observed in stage $i$ at time $t+1$ among those that survived. The number of survivors from stage $j$ is $\\sum_{i=1}^K N(i,j)$, and the stage-specific survival fraction is $s_j = \\frac{\\sum_{i=1}^K N(i,j)}{n_t(j)}$ when $n_t(j)0$, with the convention $s_j=0$ when $n_t(j)=0$. This is a direct application of frequency-based survival estimation under the assumption that the census $n_t(j)$ and the transitions $N(i,j)$ are measured over the same interval.\n\nConditional on survival, the probability that an individual in stage $j$ moves to stage $i$ is modeled as a multinomial distribution over $i$. Maximum Likelihood Estimation (MLE) for the multinomial model yields the relative-frequency estimator $p_{ij} = \\frac{N(i,j)}{\\sum_{i=1}^K N(i,j)}$ when the denominator is positive. To regularize cases with zeros and improve stability, a symmetric Dirichlet prior with concentration parameter $\\alpha_{\\text{Dir}}$ can be adopted. The Dirichlet prior is conjugate to the multinomial likelihood, and the posterior mean for the category probabilities is\n$$\np_{ij} = \\frac{N(i,j) + \\alpha_{\\text{Dir}}}{\\sum_{i=1}^K N(i,j) + K \\,\\alpha_{\\text{Dir}}}.\n$$\nThis expression follows from the conjugacy of the Dirichlet prior with the multinomial likelihood, where the posterior parameters are the prior parameters plus the observed counts. If $\\sum_{i=1}^K N(i,j) = 0$, then the posterior mean automatically reduces to the uniform distribution $p_{ij} = \\frac{1}{K}$, but because $s_j=0$ in such a case, the survival-growth contributions from stage $j$ will be zero in the projection matrix.\n\nFecundity is defined as the expected number of recruits entering the first stage at the next time step per individual in stage $j$ at the current time step. Using aggregated offspring counts $b_j$ and parent sample sizes $m_j$, the fecundity estimator is\n$$\nf_j = \\begin{cases}\n\\frac{b_j}{m_j},  m_j  0,\\\\\n0,  m_j=0,\n\\end{cases}\n$$\nwhich is consistent with the ratio-of-counts estimator under the assumption that offspring are correctly attributed to parent stages and that $m_j$ reflects the number of contributing parents sampled.\n\nThe stage-structured projection matrix $A \\in \\mathbb{R}^{K\\times K}$ collects the expected contributions from each current stage $j$ to each next stage $i$. Survival-growth contributions from stage $j$ to stage $i$ are the product $s_j \\, p_{ij}$ for all $i$, because among $n_t(j)$ individuals, a fraction $s_j$ survive and are distributed among destination stages according to $p_{ij}$. Reproductive contributions are assumed to enter the recruit stage $i=1$, so fecundity adds to the first row of $A$. Thus,\n$$\nA_{ij} = \\begin{cases}\ns_j \\, p_{ij} + f_j,  i=1,\\\\\ns_j \\, p_{ij},  i\\in\\{2,\\dots,K\\}.\n\\end{cases}\n$$\nThe additive structure in the first row reflects that an individual in stage $j$ both can survive and appear in stage $i=1$ by survival-growth, and independently can produce recruits entering stage $i=1$ via reproduction.\n\nGiven $A$, the asymptotic growth rate is determined by the dominant eigenvalue $\\lambda$ of $A$. Since $A$ is nonnegative, the Perron-Frobenius theorem (PF) guarantees the existence of a real dominant eigenvalue $\\lambda$ equal to the spectral radius and a corresponding positive eigenvector. Numerically, one computes the eigenvalues and eigenvectors of $A$, takes $\\lambda$ as the eigenvalue with maximum real part, and obtains the stable stage distribution by normalizing the associated right eigenvector to sum to $1$:\n$$\n\\lambda = \\max_{k} \\Re(\\mu_k), \\quad \\text{where } A v_k = \\mu_k v_k,\n$$\nand the stable distribution $w$ is $w = \\frac{\\Re(v_{k^\\star})}{\\sum_i \\Re(v_{k^\\star,i})}$ with $k^\\star$ the index attaining the maximum.\n\nTo evaluate the Markovian assumption at the stage level, consider three successive time steps and aggregate counts of transitions into next stage $i$ split by two previous-stage categories for a fixed current stage $j$. The Markovian assumption posits that the distribution of next-stage outcomes depends only on $j$; hence, the distributions over $i$ should be equal across the two previous-stage categories. This is testable via the Pearson Chi-Square test for independence on a $2 \\times K$ contingency table for each $j$. For stage $j$, construct the table\n$$\n\\begin{pmatrix}\nc^{(1)}_1  c^{(1)}_2  \\dots  c^{(1)}_K\\\\\nc^{(2)}_1  c^{(2)}_2  \\dots  c^{(2)}_K\n\\end{pmatrix},\n$$\nwhere $c^{(1)}_i$ and $c^{(2)}_i$ are the counts of transitions into next stage $i$ for the two previous-stage categories. Compute the Chi-Square test statistic and $p$-value. If the $p$-value is less than the specified significance level $\\alpha_{\\text{Sig}}$, the null hypothesis of equal distributions is rejected for that $j$, indicating evidence against the Markovian assumption. If counts are insufficient (for example, totals too small or a zero row), one may skip the test for that $j$ to avoid spurious conclusions. Aggregate across all $j$: if any tested $j$ rejects the null, declare a violation; otherwise, accept the Markovian assumption for that case.\n\nApplying these steps to the test suite:\n- For Case $1$, compute $s_j$ using $n_t$ and $N$, estimate $p_{ij}$ with $\\alpha_{\\text{Dir}}=0.5$, estimate $f_j$ using $b$ and $m$, construct $A$, and compute $\\lambda$. Perform the Chi-Square tests at $\\alpha_{\\text{Sig}}=0.05$ for each current stage $j$; given the provided triplet counts, the distributions across previous-stage categories are similar, so the tests should not reject, yielding a true verdict for the Markovian assumption.\n- For Case $2$, zeros in $n_t$ and $N$ necessitate $\\alpha_{\\text{Dir}}=1.0$ regularization to avoid degenerate transitions. Compute $s_j$, $p_{ij}$, $f_j$, and $A$ accordingly. Triplet counts are small; at $\\alpha_{\\text{Gis}}=0.05$, limited power combined with similar patterns across categories should not produce rejections, so the Markovian verdict should be true.\n- For Case $3$, compute $s_j$, $p_{ij}$ under $\\alpha_{\\text{Dir}}=0.3$, $f_j$, $A$, and $\\lambda$. The triplet counts are constructed to show noticeable differences across previous-stage categories for at least one current stage (for instance, $j=2$ and $j=3$), and at a stricter level $\\alpha_{\\text{Sig}}=0.01$, the Chi-Square tests should reject for those $j$, resulting in a false verdict for the Markovian assumption.\n\nThe program thus outputs for each case the pair $[\\lambda,\\text{markov\\_ok}]$ and aggregates them into the specified single-line list format. Numerical computation of eigenvalues and Chi-Square $p$-values relies on established linear algebra and statistical test procedures consistent with the mathematical definitions described above.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import chi2_contingency\n\ndef estimate_survival(n_t, N):\n    \"\"\"\n    Estimate stage-specific survival s_j as survivors / initial counts.\n    n_t: array of shape (K,)\n    N: array of shape (K,K) with columns j and rows i (destinations)\n    Returns s: array of shape (K,)\n    \"\"\"\n    K = len(n_t)\n    s = np.zeros(K, dtype=float)\n    for j in range(K):\n        survivors = float(np.sum(N[:, j]))\n        if n_t[j] > 0:\n            s[j] = survivors / float(n_t[j])\n        else:\n            s[j] = 0.0\n    # Clip to [0,1] for numerical safety\n    return np.clip(s, 0.0, 1.0)\n\ndef estimate_p_ij(N, alpha_dirichlet):\n    \"\"\"\n    Estimate conditional transition probabilities p_{ij} per column j.\n    Uses multinomial MLE with symmetric Dirichlet regularization alpha_dirichlet.\n    N: array (K,K), columns j, rows i\n    Returns P: array (K,K) where columns sum to 1 (unless total survivors=0 -> uniform).\n    \"\"\"\n    K = N.shape[0]\n    P = np.zeros_like(N, dtype=float)\n    for j in range(K):\n        col = N[:, j].astype(float)\n        total = float(np.sum(col))\n        if total > 0.0:\n            # Posterior mean under symmetric Dirichlet prior\n            P[:, j] = (col + alpha_dirichlet) / (total + K * alpha_dirichlet)\n        else:\n            # No survivors: uniform distribution (will be zeroed by s_j anyway)\n            P[:, j] = np.full(K, 1.0 / K)\n    return P\n\ndef estimate_fecundity(b, m):\n    \"\"\"\n    Estimate per-stage fecundity f_j = b_j / m_j with f_j=0 when m_j=0.\n    b: array (K,) offspring counts per stage\n    m: array (K,) parent sample sizes per stage\n    Returns f: array (K,)\n    \"\"\"\n    f = np.zeros_like(b, dtype=float)\n    for j in range(len(b)):\n        if m[j] > 0:\n            f[j] = float(b[j]) / float(m[j])\n        else:\n            f[j] = 0.0\n    return f\n\ndef build_projection_matrix(n_t, N, b, m, alpha_dirichlet):\n    \"\"\"\n    Construct the stage-structured projection matrix A.\n    A_{ij} = s_j * p_{ij} for all i, with fecundity added to first row: A_{1j} += f_j.\n    \"\"\"\n    K = len(n_t)\n    s = estimate_survival(n_t, N)\n    P = estimate_p_ij(N, alpha_dirichlet)\n    f = estimate_fecundity(b, m)\n    A = np.zeros((K, K), dtype=float)\n    # Survival-growth contributions\n    for j in range(K):\n        A[:, j] = s[j] * P[:, j]\n    # Fecundity contributions to recruit stage (i=0 in zero-based indexing)\n    A[0, :] += f\n    return A\n\ndef dominant_eigenvalue(A):\n    \"\"\"\n    Compute the dominant eigenvalue (largest real part) of nonnegative matrix A.\n    \"\"\"\n    w, v = np.linalg.eig(A)\n    # Select eigenvalue with largest real part\n    idx = np.argmax(w.real)\n    lam = float(w.real[idx])\n    return lam\n\ndef test_markov_assumption(triplet_counts_by_j, alpha_sig, min_total_per_group=4):\n    \"\"\"\n    Evaluate the Markovian assumption using Pearson Chi-Square test per current stage j.\n    triplet_counts_by_j: dict mapping j (0-based) -> {'prev_low': array(K,), 'prev_high': array(K,)}\n    alpha_sig: significance level for rejecting equality of distributions\n    min_total_per_group: minimum total counts per group to attempt test\n    Returns True if no violation detected; False otherwise.\n    \"\"\"\n    violation = False\n    for j, groups in triplet_counts_by_j.items():\n        low = np.array(groups['prev_low'], dtype=float)\n        high = np.array(groups['prev_high'], dtype=float)\n        if np.sum(low)  min_total_per_group or np.sum(high)  min_total_per_group:\n            # Insufficient counts: skip this stage\n            continue\n        table = np.vstack([low, high])\n        # Perform chi-square test for independence\n        try:\n            chi2, pval, dof, expected = chi2_contingency(table, correction=False)\n        except Exception:\n            # In case of numerical issues, add small smoothing and retry\n            eps = 1e-8\n            table = table + eps\n            chi2, pval, dof, expected = chi2_contingency(table, correction=False)\n        if pval  alpha_sig:\n            violation = True\n            # No need to continue if violation found; but continue to parse all to be thorough\n    return not violation\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case is a dict encoding K, n_t, N, m, b, alpha_dirichlet, alpha_sig, triplet_counts_by_j\n    test_cases = [\n        {\n            \"K\": 4,\n            \"n_t\": np.array([120, 80, 60, 40], dtype=int),\n            \"N\": np.array([\n                [50, 10, 0, 0],\n                [30, 28, 6, 2],\n                [8, 18, 28, 8],\n                [2, 4, 14, 22]\n            ], dtype=int),\n            \"m\": np.array([60, 50, 40, 30], dtype=int),\n            \"b\": np.array([10, 25, 80, 90], dtype=int),\n            \"alpha_dirichlet\": 0.5,\n            \"alpha_sig\": 0.05,\n            \"triplet\": {\n                0: {\"prev_low\": np.array([40, 25, 10, 2], dtype=int),\n                    \"prev_high\": np.array([35, 22, 9, 3], dtype=int)},\n                1: {\"prev_low\": np.array([12, 25, 14, 5], dtype=int),\n                    \"prev_high\": np.array([10, 22, 12, 6], dtype=int)},\n                2: {\"prev_low\": np.array([2, 6, 28, 10], dtype=int),\n                    \"prev_high\": np.array([0, 4, 30, 12], dtype=int)},\n                3: {\"prev_low\": np.array([0, 4, 12, 20], dtype=int),\n                    \"prev_high\": np.array([0, 2, 10, 22], dtype=int)}\n            }\n        },\n        {\n            \"K\": 4,\n            \"n_t\": np.array([50, 0, 15, 5], dtype=int),\n            \"N\": np.array([\n                [15, 0, 3, 0],\n                [5, 0, 3, 1],\n                [0, 0, 2, 1],\n                [0, 0, 1, 2]\n            ], dtype=int),\n            \"m\": np.array([50, 0, 15, 5], dtype=int),\n            \"b\": np.array([5, 0, 10, 8], dtype=int),\n            \"alpha_dirichlet\": 1.0,\n            \"alpha_sig\": 0.05,\n            \"triplet\": {\n                0: {\"prev_low\": np.array([8, 10, 2, 0], dtype=int),\n                    \"prev_high\": np.array([7, 9, 2, 0], dtype=int)},\n                2: {\"prev_low\": np.array([2, 3, 3, 1], dtype=int),\n                    \"prev_high\": np.array([1, 2, 3, 3], dtype=int)},\n                3: {\"prev_low\": np.array([0, 1, 1, 2], dtype=int),\n                    \"prev_high\": np.array([0, 1, 1, 2], dtype=int)}\n            }\n        },\n        {\n            \"K\": 4,\n            \"n_t\": np.array([100, 100, 100, 100], dtype=int),\n            \"N\": np.array([\n                [40, 10, 5, 0],\n                [20, 30, 20, 10],\n                [10, 30, 40, 30],\n                [0, 10, 20, 50]\n            ], dtype=int),\n            \"m\": np.array([100, 100, 100, 100], dtype=int),\n            \"b\": np.array([20, 40, 80, 100], dtype=int),\n            \"alpha_dirichlet\": 0.3,\n            \"alpha_sig\": 0.01,\n            \"triplet\": {\n                0: {\"prev_low\": np.array([30, 25, 15, 0], dtype=int),\n                    \"prev_high\": np.array([28, 22, 18, 2], dtype=int)},\n                1: {\"prev_low\": np.array([12, 30, 25, 13], dtype=int),\n                    \"prev_high\": np.array([5, 20, 35, 20], dtype=int)},\n                2: {\"prev_low\": np.array([3, 15, 45, 17], dtype=int),\n                    \"prev_high\": np.array([10, 30, 30, 15], dtype=int)},\n                3: {\"prev_low\": np.array([0, 10, 30, 50], dtype=int),\n                    \"prev_high\": np.array([0, 10, 30, 50], dtype=int)}\n            }\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        K = case[\"K\"]\n        n_t = case[\"n_t\"]\n        N = case[\"N\"]\n        m = case[\"m\"]\n        b = case[\"b\"]\n        alpha_dir = case[\"alpha_dirichlet\"]\n        alpha_sig = case[\"alpha_sig\"]\n        triplet = case[\"triplet\"]\n\n        # Build projection matrix\n        A = build_projection_matrix(n_t, N, b, m, alpha_dir)\n        # Compute dominant eigenvalue\n        lam = dominant_eigenvalue(A)\n        # Evaluate Markov assumption\n        markov_ok = test_markov_assumption(triplet, alpha_sig, min_total_per_group=K)\n\n        # Round lambda for neat output\n        lam_rounded = round(lam, 6)\n        results.append([lam_rounded, markov_ok])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}