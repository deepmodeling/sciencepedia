{
    "hands_on_practices": [
        {
            "introduction": "从原始传感器数据到有意义的物理量是环境建模的关键一步。本练习模拟了处理电导率-温度-深度（CTD）剖面仪原始数据的完整流程，这是海洋学和湖沼学中的一项基本任务。通过这个实践，您将学习如何通过实施包括去峰、分箱、求导和误差传播在内的稳健计算程序，从充满噪声的时间序列中估算出浮力频率平方（$N^2$）的垂向剖面，并量化其不确定性 。",
            "id": "3918419",
            "problem": "给定三个合成的原始时间序列，它们代表来自电导率-温度-深度（CTD）剖面仪的测量值：温度 $T(t)$（单位：摄氏度），实用盐度 $S(t)$（单位：无量纲的实用盐度单位），以及压力 $p(t)$（单位：分巴）。您的任务是实现一个完整的流程，从这些原始时间序列中估算作为垂直坐标 $z$（定义为向上为正）的函数的浮力频率平方剖面 $N^2(z)$，该流程包括去峰、按压力分箱、以及带有不确定性量化（误差棒）的导数估计。\n\n请使用以下基本依据、假设和定义：\n- 重力加速度为 $g = 9.81 \\, \\text{m} \\cdot \\text{s}^{-2}$。\n- 采用 Boussinesq 近似，并使用围绕参考状态的海水密度的线性化状态方程：\n  $$\\rho \\approx \\rho_0 \\left(1 - \\alpha (T - T_0) + \\beta (S - S_0)\\right),$$\n  其中 $\\rho_0$ 是一个恒定的参考密度，$T_0$ 和 $S_0$ 是参考温度和盐度，$\\alpha$（热膨胀系数）和 $\\beta$（盐缩系数）在本次计算中被视作常数。\n- 浮力频率的平方定义为（垂直坐标 $z$ 向上为正）：\n  $$N^2(z) = -\\frac{g}{\\rho_0}\\frac{d\\rho}{dz}.$$\n  在线性化状态方程下，并假设密度的压力依赖性可以忽略不计（即，局部使用位势密度并忽略可压缩性），该公式简化为\n  $$N^2(z) \\approx g\\left(\\alpha\\frac{dT}{dz} - \\beta\\frac{dS}{dz}\\right).$$\n- 使用 $1$ 分巴 $\\approx 1$ 米的近似关系将压力转换为深度，并定义 $z$ 为 $z = -\\mathrm{depth}$，因此 $z$ 向上增加。您的数值导数必须是关于 $z$ 的导数。\n\n流程要求：\n1. 去峰：\n   - 使用如中位数绝对偏差之类的稳健统计量来识别并移除原始 $T(t)$ 和 $S(t)$ 序列中的尖峰。如果一个数据点与中位数的绝对偏差超过中位数绝对偏差的指定倍数，则该点被视为尖峰。对所有三个时间序列应用相同的移除掩码以保持对齐。\n2. 分箱：\n   - 将去峰后的数据按压力分入宽度为 $\\Delta p$（单位：分巴）的均匀箱中，计算箱中心 $p_b$，并使用 $1$ 分巴 $\\approx 1$ 米的近似关系将其转换为深度 $d_b$（单位：米），然后转换为 $z_b = -d_b$（单位：米）。\n   - 对于每个箱 $b$，计算平均值 $\\overline{T}_b$、平均值 $\\overline{S}_b$ 和样本数 $n_b$。同时计算箱内的样本方差 $\\mathrm{Var}(T)_b$ 和 $\\mathrm{Var}(S)_b$。使用最小样本数阈值舍弃样本过少的箱。\n   - 仪器噪声标准差由温度的 $\\sigma_T$ 和盐度的 $\\sigma_S$ 给出。将仪器噪声视为独立的，并与样本方差相加。箱均值的方差应估计为\n     $$\\mathrm{Var}(\\overline{T}_b) \\approx \\frac{\\mathrm{Var}(T)_b + \\sigma_T^2}{n_b}, \\quad \\mathrm{Var}(\\overline{S}_b) \\approx \\frac{\\mathrm{Var}(S)_b + \\sigma_S^2}{n_b}.$$\n3. 导数估计：\n   - 使用中心差分法估计内部箱中心的 $dT/dz$ 和 $dS/dz$：\n     $$\\left.\\frac{dX}{dz}\\right|_{b} \\approx \\frac{\\overline{X}_{b+1} - \\overline{X}_{b-1}}{z_{b+1} - z_{b-1}}, \\quad X \\in \\{T,S\\}.$$\n   - 假设箱均值独立，进行不确定性传播：\n     $$\\mathrm{Var}\\left(\\left.\\frac{dX}{dz}\\right|_b\\right) \\approx \\frac{\\mathrm{Var}(\\overline{X}_{b+1}) + \\mathrm{Var}(\\overline{X}_{b-1})}{\\left(z_{b+1} - z_{b-1}\\right)^2}.$$\n   - 对于无法使用中心差分的箱（边缘），如果需要可以使用单边差分；但是，下面的测试查询将针对内部箱。\n4. 浮力频率和误差棒：\n   - 计算箱 $b$ 处的 $N^2_b$ 为\n     $$N^2_b = g\\left(\\alpha \\left.\\frac{dT}{dz}\\right|_b - \\beta \\left.\\frac{dS}{dz}\\right|_b\\right),$$\n     并估计其方差（忽略温度和盐度导数估计值之间的协方差）：\n     $$\\mathrm{Var}(N^2_b) \\approx g^2\\left(\\alpha^2\\,\\mathrm{Var}\\left(\\left.\\frac{dT}{dz}\\right|_b\\right) + \\beta^2\\,\\mathrm{Var}\\left(\\left.\\frac{dS}{dz}\\right|_b\\right)\\right).$$\n   - 将单标准差不确定性报告为 $\\sigma_{N^2_b} = \\sqrt{\\mathrm{Var}(N^2_b)}$。\n\n在所有计算中使用的常数和仪器特性：\n- $g = 9.81 \\, \\text{m} \\cdot \\text{s}^{-2}$，\n- $\\alpha = 2.0 \\times 10^{-4} \\, \\text{K}^{-1}$，\n- $\\beta = 8.0 \\times 10^{-4}$ (无量纲，每实用盐度单位)，\n- $\\sigma_T = 0.002 \\, \\text{K}$，\n- $\\sigma_S = 0.002$ (实用盐度单位)，\n- 尖峰阈值乘数 $k = 5$（即，移除与中位数的绝对偏差超过中位数绝对偏差 $k$ 倍的点），\n- 压力箱宽度 $\\Delta p = 5$ 分巴，\n- 最小箱样本数 $n_{\\min} = 8$。\n\n测试套件：\n在以下三个合成案例上实现并运行您的算法。对于每个案例，生成 $N$ 个均匀分布在指定范围内的压力时间样本，添加小的随机抖动以模拟剖面测量，然后计算“真实”剖面 $T_{\\mathrm{true}}(p)$ 和 $S_{\\mathrm{true}}(p)$，并添加标准差为 $\\sigma_T$ 和 $\\sigma_S$ 的高斯仪器噪声。在去峰之前，以低概率在 $T$ 和 $S$ 中都插入随机尖峰。\n\n- 案例 1（理想路径，清晰分层）：\n  - $N = 3000$，压力范围 $p \\in [0, 100]$ 分巴。\n  - 真实剖面：\n    $$T_{\\mathrm{true}}(p) = 20 - 0.05\\,p + 0.2\\sin\\left(\\frac{2\\pi p}{50}\\right), \\quad S_{\\mathrm{true}}(p) = 34 + 0.01\\,p.$$\n  - 尖峰：每个样本以 $0.002$ 的概率为 $T$ 添加 $\\pm 1.0$ K 的偏移，为 $S$ 添加 $\\pm 0.5$ 的偏移（独立随机选择符号）。\n  - 目标评估深度：$z_{\\mathrm{target}} = -50$ 米（即，大约在 $50$ 米深度处；注意 $z$ 向上为正）。\n- 案例 2（近均匀，边界条件）：\n  - $N = 3000$，压力范围 $p \\in [0, 100]$ 分巴。\n  - 真实剖面：\n    $$T_{\\mathrm{true}}(p) = 10 + 0.001\\,p, \\quad S_{\\mathrm{true}}(p) = 35 + 0.0002\\,p.$$\n  - 尖峰：每个样本以 $0.002$ 的概率为 $T$ 添加 $\\pm 1.0$ K 的偏移，为 $S$ 添加 $\\pm 0.5$ 的偏移。\n  - 目标评估深度：$z_{\\mathrm{target}} = -50$ 米。\n- 案例 3（边缘案例，包含一个不稳定的近表层）：\n  - $N = 3000$，压力范围 $p \\in [0, 100]$ 分巴。\n  - 真实剖面：\n    $$T_{\\mathrm{true}}(p) = \\begin{cases} 14 + 0.03\\,p,  p  25, \\\\ 14 + 0.03\\cdot 25 - 0.05\\,(p-25),  p \\ge 25, \\end{cases} \\quad S_{\\mathrm{true}}(p) = 35 + 0.0005\\,p.$$\n  - 尖峰：每个样本以 $0.002$ 的概率为 $T$ 添加 $\\pm 1.0$ K 的偏移，为 $S$ 添加 $\\pm 0.5$ 的偏移。\n  - 目标评估深度：$z_{\\mathrm{target}} = -15$ 米（以捕捉受不稳定层影响的区域）。\n\n输出规范：\n- 对于每个案例，在可以使用中心差分的箱（即内部箱）中，找到最接近指定 $z_{\\mathrm{target}}$ 的箱中心 $z_b$。报告数值对 $\\left[N^2(z_b), \\sigma_{N^2}(z_b)\\right]$，单位为 s$^{-2}$。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，每个案例贡献一个包含两个浮点数的列表：\n  $$\\left[\\left[N^2_1, \\sigma_{N^2,1}\\right], \\left[N^2_2, \\sigma_{N^2,2}\\right], \\left[N^2_3, \\sigma_{N^2,3}\\right]\\right].$$",
            "solution": "用户提供了一个在计算物理海洋学领域中定义明确的问题。任务是实现一个完整的数据处理流程，用于从温度 $T(t)$、实用盐度 $S(t)$ 和压力 $p(t)$ 的合成原始时间序列中，估算表示为 $N^2(z)$ 的浮力频率平方剖面。该流程包括数据生成、去峰、分箱平均、数值微分和不确定性传播。该问题在科学上是合理的、适定的，并提供了所有必要的参数和方程。\n\n该问题的科学基础是浮力频率的概念，它是衡量分层环境中流体块静态稳定性的指标。对于一个垂直位移的流体块，$N^2$ 的符号决定了它是倾向于返回其原始位置（振荡）还是继续远离（翻转）。正的 $N^2$ 表示稳定，而负的 $N^2$ 则表示不稳定。\n\n核心关系是海水密度 $\\rho$ 的线性化状态方程：\n$$ \\rho \\approx \\rho_0 \\left(1 - \\alpha (T - T_0) + \\beta (S - S_0)\\right) $$\n其中 $\\rho_0, T_0, S_0$ 是参考值，$\\alpha$ 是热膨胀系数，$\\beta$ 是盐缩系数。\n浮力频率的平方，其中垂直坐标 $z$ 定义为向上为正，由下式给出：\n$$ N^2(z) = -\\frac{g}{\\rho_0}\\frac{d\\rho}{dz} $$\n代入线性化状态方程，并假设密度的局部压力影响可忽略不计，我们得到工作方程：\n$$ N^2(z) \\approx g\\left(\\alpha\\frac{dT}{dz} - \\beta\\frac{dS}{dz}\\right) $$\n垂直坐标 $z$ 是使用静水压力近似 $z \\approx -p$ 从压力 $p$（单位：分巴）推导出来的。\n\n实现将按指定步骤逐步进行。\n\n1.  **合成数据生成**：对于每个测试案例，我们首先生成原始数据。\n    - 创建一个包含 $N$ 个样本的压力时间序列 $p(t)$，这些样本在指定的压力范围内均匀分布。\n    - 根据每个案例给定的解析函数，计算“真实”的温度 $T_{\\mathrm{true}}(p)$ 和盐度 $S_{\\mathrm{true}}(p)$ 剖面。\n    - 为了模拟仪器测量，将具有指定标准差 $\\sigma_T$ 和 $\\sigma_S$ 的高斯噪声添加到真实剖面中。\n    - 最后，将给定幅度的随机尖峰添加到一小部分温度和盐度数据点上，以模拟测量误差。\n\n2.  **去峰**：原始观测数据经常被伪尖峰污染。我们采用一种稳健的统计方法来识别并移除它们。\n    - 对于温度和盐度时间序列，我们都计算中位数和中位数绝对偏差（MAD），其定义为 $\\mathrm{MAD} = \\mathrm{median}(|x_i - \\mathrm{median}(x)|)$。\n    - 如果一个数据点 $x_i$ 与序列中位数的绝对偏差超过一个阈值，即 $|x_i - \\mathrm{median}(x)|  k \\times \\mathrm{MAD}$（其中 $k$ 是一个指定的乘数），则该点被标记为尖峰。\n    - 创建一个组合掩码，标记任何 $T(t)$ 或 $S(t)$ 为尖峰的时间步。移除整个时间步（包括相应的 $p(t)$ 值），以确保数据集的对齐和完整性。\n\n3.  **分箱平均**：将去峰后的高频数据进行分箱，以创建随深度变化的平滑剖面。\n    - 在压力范围内定义固定宽度为 $\\Delta p$ 的压力箱。\n    - 将去峰后的数据点 $(p, T, S)$ 分配到各自的压力箱中。\n    - 样本数少于最小数量 $n_{\\min}$ 的箱将被丢弃，以确保统计稳健性。\n    - 对于每个有效的箱 $b$，我们计算箱中心压力 $p_b$（并因此得到 $z_b = -p_b$）、样本数 $n_b$、平均温度 $\\overline{T}_b$、平均盐度 $\\overline{S}_b$ 以及它们的样本方差 $\\mathrm{Var}(T)_b$ 和 $\\mathrm{Var}(S)_b$。\n\n4.  **箱均值的不确定性**：分箱平均量的不确定性来源于箱内的环境变异性（由样本方差捕获）和仪器噪声。\n    - 每个箱的均值方差是通过组合这两个来源来估计的，假设它们是独立的：\n      $$ \\mathrm{Var}(\\overline{T}_b) \\approx \\frac{\\mathrm{Var}(T)_b + \\sigma_T^2}{n_b} $$\n      $$ \\mathrm{Var}(\\overline{S}_b) \\approx \\frac{\\mathrm{Var}(S)_b + \\sigma_S^2}{n_b} $$\n\n5.  **数值微分和不确定性传播**：从分箱后的剖面中估计垂直梯度 $dT/dz$ 和 $dS/dz$。\n    - 我们对内部箱使用二阶中心差分格式，它比单边差分提供更高的精度：\n      $$ \\left.\\frac{dX}{dz}\\right|_{b} \\approx \\frac{\\overline{X}_{b+1} - \\overline{X}_{b-1}}{z_{b+1} - z_{b-1}}, \\quad \\text{for } X \\in \\{T,S\\} $$\n    - 这些梯度的不确定性是通过传播箱均值的不确定性来确定的。假设箱均值 $\\overline{X}_{b+1}$ 和 $\\overline{X}_{b-1}$ 是独立的随机变量，则导数估计的方差为：\n      $$ \\mathrm{Var}\\left(\\left.\\frac{dX}{dz}\\right|_b\\right) \\approx \\frac{\\mathrm{Var}(\\overline{X}_{b+1}) + \\mathrm{Var}(\\overline{X}_{b-1})}{\\left(z_{b+1} - z_{b-1}\\right)^2} $$\n\n6.  **浮力频率和最终不确定性**：最后一步是组合梯度以计算 $N^2_b$ 及其总不确定性。\n    - 内部箱 $b$ 处的浮力频率平方计算如下：\n      $$ N^2_b = g\\left(\\alpha \\left.\\frac{dT}{dz}\\right|_b - \\beta \\left.\\frac{dS}{dz}\\right|_b\\right) $$\n    - 假设 $dT/dz$ 和 $dS/dz$ 估计中的误差不相关，$N^2_b$ 的方差传播如下：\n      $$ \\mathrm{Var}(N^2_b) \\approx g^2\\left(\\alpha^2\\,\\mathrm{Var}\\left(\\left.\\frac{dT}{dz}\\right|_b\\right) + \\beta^2\\,\\mathrm{Var}\\left(\\left.\\frac{dS}{dz}\\right|_b\\right)\\right) $$\n    - 最终报告的不确定性是标准差，$\\sigma_{N^2_b} = \\sqrt{\\mathrm{Var}(N^2_b)}$。\n\n7.  **目标值提取**：对于每个测试案例，问题要求报告其中心 $z_b$ 最接近指定目标深度 $z_{\\mathrm{target}}$ 的内部箱的计算值 $N^2_b$ 和 $\\sigma_{N^2_b}$。这涉及在内部箱深度的数组上进行简单搜索。",
            "answer": "```python\nimport numpy as np\nfrom scipy.stats import median_abs_deviation\n\ndef process_ctd_profile(case_params, constants, sim_params):\n    \"\"\"\n    Generates synthetic CTD data and computes the buoyancy frequency profile.\n    \"\"\"\n    # Unpack parameters\n    T_func, S_func = case_params['profiles']\n    z_target = case_params['z_target']\n    \n    g = constants['g']\n    alpha = constants['alpha']\n    beta = constants['beta']\n    \n    sigma_T = constants['sigma_T']\n    sigma_S = constants['sigma_S']\n    despike_k = constants['despike_k']\n    dp_bin = constants['dp_bin']\n    n_min = constants['n_min']\n\n    N_samples = sim_params['N']\n    p_range = sim_params['p_range']\n    spike_prob = sim_params['spike_prob']\n    spike_mag_T = sim_params['spike_mag_T']\n    spike_mag_S = sim_params['spike_mag_S']\n    \n    # 1. Data Generation\n    rng = np.random.default_rng(seed=case_params['seed'])\n    \n    p_raw = rng.uniform(p_range[0], p_range[1], N_samples)\n    \n    T_true = T_func(p_raw)\n    S_true = S_func(p_raw)\n    \n    T_noisy = T_true + rng.normal(0, sigma_T, N_samples)\n    S_noisy = S_true + rng.normal(0, sigma_S, N_samples)\n\n    # Add spikes\n    T_spiked, S_spiked = T_noisy.copy(), S_noisy.copy()\n    spike_indices = rng.choice([False, True], size=N_samples, p=[1 - spike_prob, spike_prob])\n    \n    spike_offsets_T = rng.choice([-spike_mag_T, spike_mag_T], size=N_samples)\n    spike_offsets_S = rng.choice([-spike_mag_S, spike_mag_S], size=N_samples)\n    \n    T_spiked[spike_indices] += spike_offsets_T[spike_indices]\n    S_spiked[spike_indices] += spike_offsets_S[spike_indices]\n    \n    # 2. Despiking\n    median_T = np.median(T_spiked)\n    mad_T = median_abs_deviation(T_spiked, scale=1)\n    is_spike_T = np.abs(T_spiked - median_T)  despike_k * mad_T if mad_T  0 else np.zeros_like(T_spiked, dtype=bool)\n\n    median_S = np.median(S_spiked)\n    mad_S = median_abs_deviation(S_spiked, scale=1)\n    is_spike_S = np.abs(S_spiked - median_S)  despike_k * mad_S if mad_S  0 else np.zeros_like(S_spiked, dtype=bool)\n\n    valid_mask = ~(is_spike_T | is_spike_S)\n    p_d, T_d, S_d = p_raw[valid_mask], T_spiked[valid_mask], S_spiked[valid_mask]\n    \n    # 3. Binning\n    p_bins = np.arange(p_range[0], p_range[1] + dp_bin, dp_bin)\n    bin_centers = p_bins[:-1] + dp_bin / 2.0\n    \n    p_b, z_b = [], []\n    T_b_mean, S_b_mean = [], []\n    var_T_b_mean, var_S_b_mean = [], []\n\n    for i in range(len(p_bins) - 1):\n        bin_mask = (p_d = p_bins[i])  (p_d  p_bins[i+1])\n        T_in_bin, S_in_bin = T_d[bin_mask], S_d[bin_mask]\n        n_b = len(T_in_bin)\n        \n        if n_b = n_min:\n            p_b.append(bin_centers[i])\n            z_b.append(-bin_centers[i])\n            \n            T_b_mean.append(np.mean(T_in_bin))\n            S_b_mean.append(np.mean(S_in_bin))\n\n            # 4. Uncertainty of Bin Means\n            var_T_sample = np.var(T_in_bin, ddof=1) if n_b  1 else 0\n            var_S_sample = np.var(S_in_bin, ddof=1) if n_b  1 else 0\n\n            var_T_b_mean.append((var_T_sample + sigma_T**2) / n_b)\n            var_S_b_mean.append((var_S_sample + sigma_S**2) / n_b)\n\n    # Convert to numpy arrays for vectorized operations\n    z_b = np.array(z_b)\n    T_b_mean, S_b_mean = np.array(T_b_mean), np.array(S_b_mean)\n    var_T_b_mean, var_S_b_mean = np.array(var_T_b_mean), np.array(var_S_b_mean)\n\n    if len(z_b)  3:\n        return [np.nan, np.nan] # Not enough bins for central difference\n\n    # 5. Derivative Estimation  Uncertainty\n    z_interior = z_b[1:-1]\n    \n    # Numerators for central difference\n    dT = T_b_mean[2:] - T_b_mean[:-2]\n    dS = S_b_mean[2:] - S_b_mean[:-2]\n    # Denominator\n    dz = z_b[2:] - z_b[:-2]\n\n    # Gradients\n    dTdz = dT / dz\n    dSdz = dS / dz\n    \n    # Variance of derivatives\n    var_dT = var_T_b_mean[2:] + var_T_b_mean[:-2]\n    var_dS = var_S_b_mean[2:] + var_S_b_mean[:-2]\n    \n    var_dTdz = var_dT / dz**2\n    var_dSdz = var_dS / dz**2\n    \n    # 6. Buoyancy Frequency  Final Uncertainty\n    N2 = g * (alpha * dTdz - beta * dSdz)\n    var_N2 = g**2 * (alpha**2 * var_dTdz + beta**2 * var_dSdz)\n    sigma_N2 = np.sqrt(var_N2)\n    \n    # 7. Target Value Extraction\n    target_idx = np.argmin(np.abs(z_interior - z_target))\n    \n    return [N2[target_idx], sigma_N2[target_idx]]\n\ndef solve():\n    constants = {\n        'g': 9.81, 'alpha': 2.0e-4, 'beta': 8.0e-4,\n        'sigma_T': 0.002, 'sigma_S': 0.002,\n        'despike_k': 5, 'dp_bin': 5, 'n_min': 8\n    }\n    \n    sim_params = {\n        'N': 3000, 'p_range': [0, 100], 'spike_prob': 0.002,\n        'spike_mag_T': 1.0, 'spike_mag_S': 0.5\n    }\n\n    test_cases = [\n        {\n            'profiles': (\n                lambda p: 20 - 0.05 * p + 0.2 * np.sin(2 * np.pi * p / 50),\n                lambda p: 34 + 0.01 * p\n            ),\n            'z_target': -50,\n            'seed': 42\n        },\n        {\n            'profiles': (\n                lambda p: 10 + 0.001 * p,\n                lambda p: 35 + 0.0002 * p\n            ),\n            'z_target': -50,\n            'seed': 43\n        },\n        {\n            'profiles': (\n                lambda p: np.where(p  25, \n                                   14 + 0.03 * p, \n                                   14 + 0.03 * 25 - 0.05 * (p - 25)),\n                lambda p: 35 + 0.0005 * p\n            ),\n            'z_target': -15,\n            'seed': 44\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = process_ctd_profile(case, constants, sim_params)\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "获得了可靠的层结剖面 $N^2$ 后，一个核心应用是量化湍流混合。本练习探讨了层结如何通过著名的 Osborn 模型，将湍动能耗散率（$\\epsilon$）的微结构测量值与跨等密度面扩散率（$K_\\rho$）联系起来。通过这个实践，您将掌握如何利用观测数据估算这一对全球热量、盐分和生物地球化学物质输运至关重要的关键混合参数，并评估其不确定性 。",
            "id": "3918390",
            "problem": "您将获得在指定深度上的微结构湍动能耗散率、由浮力频率平方量化的层化强度以及相关测量不确定度的垂直剖面。您的目标是基于湍动能收支的基本原理以及不可逆浮力通量与标量输运之间的联系，为每个剖面推导、计算并报告跨等密度面扩散系数剖面及其不确定度。\n\n从湍动能（TKE）的稳态平衡和混合效率的定义出发，推导跨等密度面扩散系数 $K_{\\rho}$ 的表达式，然后通过梯度-扩散闭合将不可逆浮力通量与标量梯度联系起来。在您的推导中，请使用以下基本原理：\n- 稳定层化条件下，根据背景密度梯度和重力加速度定义的浮力频率平方 $N^2$。\n- 层化流体中的稳态TKE收支，它通过浮力通量将耗散率与TKE到势能的不可逆转换联系起来。\n- 一个恒定的混合效率 $\\Gamma$，它将不可逆浮力通量与耗散率联系起来。\n- 一个菲克闭合，它将垂直浮力通量与作用于背景密度层化的跨等密度面扩散系数联系起来。\n\n假设微结构耗散率 $\\epsilon$、层化强度 $N^2$ 和混合效率 $\\Gamma$ 的不确定度是独立的，每个都以一倍标准差的值给出。使用关于推导出的 $K_{\\rho}$ 的一阶不确定度传播，计算每个深度的一倍标准差不确定度 $\\sigma_{K_{\\rho}}$。确保对于提供的测试数据，计算出的 $K_{\\rho}$ 值为非负且有限。\n\n报告所有扩散系数及其不确定度，单位为平方米/秒 ($\\text{m}^2/\\text{s}$)。将每个报告的浮点值四舍五入到 $3$ 位有效数字。\n\n测试套件：\n对于每种情况，您将获得在指定深度上的数值数组和一倍标准差不确定度数组。所有 $\\epsilon$ 的单位为瓦特/千克 ($\\text{m}^2/\\text{s}^3$)，所有 $N^2$ 的单位为 s$^{-2}$，而 $\\Gamma$ 是无量纲的。\n\n- 情况A（温跃层式层化）：\n  - 深度：$\\{5,15,50,100\\}$ 米\n  - $\\epsilon$: $\\{2\\times10^{-8},1.5\\times10^{-8},1\\times10^{-8},0.8\\times10^{-8}\\}$\n  - $\\sigma_{\\epsilon}$: $\\{0.5\\times10^{-8},0.3\\times10^{-8},0.2\\times10^{-8},0.1\\times10^{-8}\\}$\n  - $N^2$: $\\{1\\times10^{-4},0.7\\times10^{-4},0.3\\times10^{-4},0.1\\times10^{-4}\\}$\n  - $\\sigma_{N^2}$: $\\{1\\times10^{-5},0.7\\times10^{-5},0.3\\times10^{-5},0.1\\times10^{-5}\\}$\n  - $\\Gamma$ 平均值和一倍标准差：平均值 $0.2$，$\\sigma_{\\Gamma}=0.05$\n\n- 情况B（弱层化，高变率）：\n  - 深度：$\\{10,30,60,120\\}$ 米\n  - $\\epsilon$: $\\{5\\times10^{-9},4\\times10^{-9},3\\times10^{-9},2\\times10^{-9}\\}$\n  - $\\sigma_{\\epsilon}$: $\\{1\\times10^{-9},0.8\\times10^{-9},0.6\\times10^{-9},0.4\\times10^{-9}\\}$\n  - $N^2$: $\\{5\\times10^{-6},3\\times10^{-6},2\\times10^{-6},1\\times10^{-6}\\}$\n  - $\\sigma_{N^2}$: $\\{0.8\\times10^{-6},0.6\\times10^{-6},0.4\\times10^{-6},0.2\\times10^{-6}\\}$\n  - $\\Gamma$ 平均值和一倍标准差：平均值 $0.2$，$\\sigma_{\\Gamma}=0.07$\n\n- 情况C（强层化）：\n  - 深度：$\\{20,40,80,150\\}$ 米\n  - $\\epsilon$: $\\{2\\times10^{-9},1.5\\times10^{-9},1\\times10^{-9},0.7\\times10^{-9}\\}$\n  - $\\sigma_{\\epsilon}$: $\\{0.5\\times10^{-9},0.4\\times10^{-9},0.3\\times10^{-9},0.2\\times10^{-9}\\}$\n  - $N^2$: $\\{3\\times10^{-4},4\\times10^{-4},5\\times10^{-4},6\\times10^{-4}\\}$\n  - $\\sigma_{N^2}$: $\\{3\\times10^{-5},3.5\\times10^{-5},4\\times10^{-5},4.5\\times10^{-5}\\}$\n  - $\\Gamma$ 平均值和一倍标准差：平均值 $0.2$，$\\sigma_{\\Gamma}=0.03$\n\n您的程序必须：\n- 实现您推导的表达式，使用具有独立误差的一阶不确定度传播，为每种情况计算每个深度的 $K_{\\rho}$ 和 $\\sigma_{K_{\\rho}}$。\n- 将所有输出四舍五入到 $3$ 位有效数字。\n- 生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。每个测试用例的结果必须是一个列表，包含两个列表：舍入后的跨等密度面扩散系数值 $[K_{\\rho,1},\\dots,K_{\\rho,n}]$ 和相应舍入后的不确定度 $[\\sigma_{K_{\\rho,1}},\\dots,\\sigma_{K_{\\rho,n}}]$，单位均为 m$^2$/s。最终输出格式必须为：\n$[[[K_{\\rho}^{A}], [\\sigma_{K_{\\rho}}^{A}]], [[K_{\\rho}^{B}], [\\sigma_{K_{\\rho}}^{B}]], [[K_{\\rho}^{C}], [\\sigma_{K_{\\rho}}^{C}]]]$\n其中每个带括号的列表包含相应情况下在指定深度的值。",
            "solution": "用户提供的问题经评估有效。它在科学上基于地球物理流体动力学原理，特别是层化流体中湍流混合的理论。问题设定良好，提供了足够的信息以推导出唯一解。语言客观，数据在物理上是现实的。我们开始进行求解。\n\n主要目标是推导跨等密度面扩散系数 $K_{\\rho}$ 及其相关不确定度 $\\sigma_{K_{\\rho}}$ 的表达式，然后为给定的测试用例计算这些值。\n\n**跨等密度面扩散系数 $K_{\\rho}$ 的推导**\n\n推导从问题陈述中概述的物理原理开始。\n\n1.  **湍动能（TKE）收支与混合效率（$\\Gamma$）**：在稳定层化的流体中，湍涡在克服背景浮力梯度的过程中做功，将动能转化为势能。这部分功的一部分导致不可逆的混合。这种不可逆转换的速率就是浮力通量 $B$。在稳态TKE收支中，TKE耗散率 $\\epsilon$（单位为 $\\text{m}^2/\\text{s}^3$ 或 W/kg）通过一个无量纲的混合效率因子 $\\Gamma$ 与浮力通量相关联。该关系式为：\n    $$ B = \\Gamma \\epsilon $$\n    在这里，$\\Gamma$ 代表贡献于不可逆混合的耗散湍动能的比例。海洋学中常用的一个典型值是 $\\Gamma = 0.2$。\n\n2.  **梯度-扩散（菲克）闭合**：浮力通量 $B$ 也可以被参数化为一个作用于背景密度梯度的扩散过程。这是一种菲克型闭合，其中通量与梯度成正比。跨等密度面扩散系数 $K_{\\rho}$（单位为 $\\text{m}^2/\\text{s}$）是比例系数：\n    $$ B = -K_{\\rho} \\frac{g}{\\rho_0} \\frac{d\\bar{\\rho}}{dz} $$\n    其中 $g$ 是重力加速度，$\\rho_0$ 是参考密度，$\\frac{d\\bar{\\rho}}{dz}$ 是平均垂直密度梯度。\n\n3.  **浮力频率（$N^2$）**：层化的稳定性由浮力频率平方 $N^2$（单位为 $\\text{s}^{-2}$）量化，其定义为：\n    $$ N^2 = -\\frac{g}{\\rho_0} \\frac{d\\bar{\\rho}}{dz} $$\n    对于稳定层化，$\\frac{d\\bar{\\rho}}{dz}  0$，因此 $N^2  0$。将 $N^2$ 的定义代入 $B$ 的表达式：\n    $$ B = K_{\\rho} N^2 $$\n\n4.  **$K_{\\rho}$ 的最终表达式**：通过令浮力通量 $B$ 的两个表达式相等，我们得到了可测量的湍流参数（$\\epsilon$，$N^2$）与跨等密度面扩散系数 $K_{\\rho}$ 之间的直接关系：\n    $$ K_{\\rho} N^2 = \\Gamma \\epsilon $$\n    求解 $K_{\\rho}$ 得到 Osborn 模型（1980）：\n    $$ K_{\\rho} = \\frac{\\Gamma \\epsilon}{N^2} $$\n    这是所有后续计算所使用的表达式。\n\n**跨等密度面扩散系数不确定度 $\\sigma_{K_{\\rho}}$ 的推导**\n\n$K_{\\rho}$ 的不确定度是使用独立变量的一阶不确定度传播来计算的。函数为 $K_{\\rho} = f(\\Gamma, \\epsilon, N^2)$。方差 $\\sigma_{K_{\\rho}}^2$ 的通用公式为：\n$$ \\sigma_{K_{\\rho}}^2 = \\left( \\frac{\\partial K_{\\rho}}{\\partial \\Gamma} \\sigma_{\\Gamma} \\right)^2 + \\left( \\frac{\\partial K_{\\rho}}{\\partial \\epsilon} \\sigma_{\\epsilon} \\right)^2 + \\left( \\frac{\\partial K_{\\rho}}{\\partial N^2} \\sigma_{N^2} \\right)^2 $$\n其中 $\\sigma_{\\Gamma}$、$\\sigma_{\\epsilon}$ 和 $\\sigma_{N^2}$ 分别是相应变量的一倍标准差不确定度。\n\n1.  **偏导数**：所需的 $K_{\\rho}$ 的偏导数是：\n    -   $\\frac{\\partial K_{\\rho}}{\\partial \\Gamma} = \\frac{\\epsilon}{N^2}$\n    -   $\\frac{\\partial K_{\\rho}}{\\partial \\epsilon} = \\frac{\\Gamma}{N^2}$\n    -   $\\frac{\\partial K_{\\rho}}{\\partial N^2} = -\\frac{\\Gamma \\epsilon}{(N^2)^2}$\n\n2.  **不确定度传播**：将导数代入方差公式会得到一个繁琐的表达式。使用相对不确定度更为方便。对于形式为 $y = c \\cdot x_1^{a_1} x_2^{a_2} \\dots$ 的函数，相对不确定度的平方由下式给出：\n    $$ \\left( \\frac{\\sigma_y}{y} \\right)^2 = \\sum_{i} \\left( a_i \\frac{\\sigma_{x_i}}{x_i} \\right)^2 $$\n    对于我们的函数 $K_{\\rho} = \\Gamma^1 \\epsilon^1 (N^2)^{-1}$，指数分别为 $a_{\\Gamma}=1$，$a_{\\epsilon}=1$ 和 $a_{N^2}=-1$。应用该公式：\n    $$ \\left( \\frac{\\sigma_{K_{\\rho}}}{K_{\\rho}} \\right)^2 = \\left( 1 \\cdot \\frac{\\sigma_{\\Gamma}}{\\Gamma} \\right)^2 + \\left( 1 \\cdot \\frac{\\sigma_{\\epsilon}}{\\epsilon} \\right)^2 + \\left( -1 \\cdot \\frac{\\sigma_{N^2}}{N^2} \\right)^2 $$\n    这简化为：\n    $$ \\left( \\frac{\\sigma_{K_{\\rho}}}{K_{\\rho}} \\right)^2 = \\left( \\frac{\\sigma_{\\Gamma}}{\\Gamma} \\right)^2 + \\left( \\frac{\\sigma_{\\epsilon}}{\\epsilon} \\right)^2 + \\left( \\frac{\\sigma_{N^2}}{N^2} \\right)^2 $$\n\n3.  **$\\sigma_{K_{\\rho}}$ 的最终表达式**：通过求解 $\\sigma_{K_{\\rho}}$，得到 $K_{\\rho}$ 的一倍标准差不确定度的最终表达式：\n    $$ \\sigma_{K_{\\rho}} = K_{\\rho} \\sqrt{ \\left( \\frac{\\sigma_{\\Gamma}}{\\Gamma} \\right)^2 + \\left( \\frac{\\sigma_{\\epsilon}}{\\epsilon} \\right)^2 + \\left( \\frac{\\sigma_{N^2}}{N^2} \\right)^2 } $$\n    该表达式将用于不确定度的计算。\n\n**计算策略**\n\n对于每个测试用例和每个指定深度，执行以下步骤：\n1.  使用推导出的公式 $K_{\\rho} = \\Gamma \\epsilon / N^2$ 计算 $K_{\\rho}$。\n2.  使用相对不确定度传播公式计算相应的不确定度 $\\sigma_{K_{\\rho}}$。\n3.  将 $K_{\\rho}$ 和 $\\sigma_{K_{\\rho}}$ 四舍五入到3位有效数字。在程序实现中，最稳健的方法是将数值输出格式化为具有两位小数的科学记数法字符串（例如，`'1.23e-05'`），这内在地表示了3位有效数字。\n4.  将给定情况的所有深度的结果收集到两个列表中，一个用于 $K_{\\rho}$，一个用于 $\\sigma_{K_{\\rho}}$。然后将它们格式化为最终所需的输出字符串。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives, computes, and reports diapycnal diffusivity and its uncertainty\n    based on microstructure measurements.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"epsilon\": np.array([2e-8, 1.5e-8, 1e-8, 0.8e-8]),\n            \"sigma_epsilon\": np.array([0.5e-8, 0.3e-8, 0.2e-8, 0.1e-8]),\n            \"N2\": np.array([1e-4, 0.7e-4, 0.3e-4, 0.1e-4]),\n            \"sigma_N2\": np.array([1e-5, 0.7e-5, 0.3e-5, 0.1e-5]),\n            \"Gamma\": 0.2,\n            \"sigma_Gamma\": 0.05\n        },\n        {\n            \"epsilon\": np.array([5e-9, 4e-9, 3e-9, 2e-9]),\n            \"sigma_epsilon\": np.array([1e-9, 0.8e-9, 0.6e-9, 0.4e-9]),\n            \"N2\": np.array([5e-6, 3e-6, 2e-6, 1e-6]),\n            \"sigma_N2\": np.array([0.8e-6, 0.6e-6, 0.4e-6, 0.2e-6]),\n            \"Gamma\": 0.2,\n            \"sigma_Gamma\": 0.07\n        },\n        {\n            \"epsilon\": np.array([2e-9, 1.5e-9, 1e-9, 0.7e-9]),\n            \"sigma_epsilon\": np.array([0.5e-9, 0.4e-9, 0.3e-9, 0.2e-9]),\n            \"N2\": np.array([3e-4, 4e-4, 5e-4, 6e-4]),\n            \"sigma_N2\": np.array([3e-5, 3.5e-5, 4e-5, 4.5e-5]),\n            \"Gamma\": 0.2,\n            \"sigma_Gamma\": 0.03\n        }\n    ]\n\n    def format_to_sf(value, sf):\n        \"\"\"\n        Formats a number to a string with a specified number of significant figures,\n        using scientific notation.\n        \"\"\"\n        precision = sf - 1\n        return f\"'{value:.{precision}e}'\"\n\n    all_cases_results = []\n\n    for case in test_cases:\n        gamma = case[\"Gamma\"]\n        sigma_gamma = case[\"sigma_Gamma\"]\n        epsilon = case[\"epsilon\"]\n        sigma_epsilon = case[\"sigma_epsilon\"]\n        N2 = case[\"N2\"]\n        sigma_N2 = case[\"sigma_N2\"]\n\n        # Calculate K_rho\n        # K_rho = (Gamma * epsilon) / N^2\n        K_rhos = (gamma * epsilon) / N2\n\n        # Calculate uncertainty in K_rho\n        # (sigma_K/K)^2 = (sigma_Gamma/Gamma)^2 + (sigma_eps/eps)^2 + (sigma_N2/N2)^2\n        rel_unc_gamma_sq = (sigma_gamma / gamma)**2\n        rel_unc_eps_sq = (sigma_epsilon / epsilon)**2\n        rel_unc_n2_sq = (sigma_N2 / N2)**2\n        \n        # Calculate sigma_K_rho\n        sigma_K_rhos = K_rhos * np.sqrt(rel_unc_gamma_sq + rel_unc_eps_sq + rel_unc_n2_sq)\n\n        # Round to 3 significant figures by formatting the string output\n        rounded_K_rhos = [format_to_sf(k, 3) for k in K_rhos]\n        rounded_sigma_K_rhos = [format_to_sf(s, 3) for s in sigma_K_rhos]\n        \n        all_cases_results.append([rounded_K_rhos, rounded_sigma_K_rhos])\n\n    # Construct the final output string exactly as specified.\n    case_strings = []\n    for K_list, sigma_list in all_cases_results:\n        k_str = f\"[{','.join(K_list)}]\"\n        s_str = f\"[{','.join(sigma_list)}]\"\n        case_strings.append(f\"[{k_str},{s_str}]\")\n\n    final_output = f\"[{','.join(case_strings)}]\"\n    \n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "除了调节混合，层结还为内波的存在和传播提供了必要的恢复力。本练习深入探讨了内重力波的动力学，这是在海洋和大气中输运能量和动量的基本过程。您将首先从第一性原理推导出理想化条件下的内波色散关系，然后设计一个数值实验来评估不同时间积分方案在模拟这些波时引入的数值色散误差 。这项任务将理论物理与计算实践相结合，让您从模型开发者的角度审视数值精度问题。",
            "id": "3918378",
            "problem": "要求您设计一个独立的数值实验，用于量化在分层流体中模拟内重力波传播时，由时间步进格式引入的色散误差。物理设置为二维、无粘、无旋的线性 Boussinesq 流，其浮力频率 $N(z)$ 具有给定的垂直廓线。为了本实验的目的，请使用常数廓线 $N(z) = N_0$ 以分离和评估纯粹的时间色散。垂直域在 $z=0$ 和 $z=H$ 处由刚性盖限定，水平方向 $x$ 是无界的。\n\n从适用于此背景的线性化 Boussinesq 方程和基本定义开始：\n- 水平动量：$\\partial_t u = - \\frac{1}{\\rho_0} \\partial_x p$。\n- 垂直动量：$\\partial_t w = - \\frac{1}{\\rho_0} \\partial_z p + b$。\n- 浮力演变：$\\partial_t b + N^2 w = 0$。\n- 不可压缩性：$\\partial_x u + \\partial_z w = 0$。\n\n在刚性盖边界条件 $w(x,0,t) = w(x,H,t) = 0$ 下，从第一性原理推导具有水平波数 $k$ 和第 $n$ 阶垂直模态的平面波解的内重力波色散关系，并将精确角频率 $\\omega_{\\text{true}}$ 表示为 $N_0$、$k$、$H$ 和模态指数 $n$ 的函数。利用边界条件确定适用于该问题的离散垂直波数 $m$。\n\n为了量化纯粹的时间色散误差，将波场中任意单个傅里叶模态的时间演化表示为标量常微分方程 $\\partial_t y = i \\omega_{\\text{true}} y$，其中 $y(t)$ 表示该模态的复振幅。考虑将以下单步时间步进格式应用于 $\\partial_t y = \\lambda y$（其中 $\\lambda = i \\omega_{\\text{true}}$）：\n- Forward Euler。\n- 二阶 Runge–Kutta (RK) (显式中点法)。\n- 经典四阶 Runge–Kutta (RK4)。\n- Crank–Nicolson (CN)。\n\n对于每种格式，其在大小为 $\\Delta t$ 的单个时间步长上的作用可以由一个稳定函数 $R(\\lambda \\Delta t)$ 概括，使得 $y^{n+1} = R(\\lambda \\Delta t) y^n$。数值角频率 $\\omega_{\\text{num}}$ 由单步复数放大因子定义为 $\\omega_{\\text{num}} = \\frac{\\arg(R(i \\omega_{\\text{true}} \\Delta t))}{\\Delta t}$，其中 $\\arg(\\cdot)$ 是以弧度为单位的辐角主值。需要报告的相对色散误差是无量纲量 $\\varepsilon = \\frac{\\omega_{\\text{um}} - \\omega_{\\text{true}}}{\\omega_{\\text{true}}}$。\n\n实现一个完整、可运行的程序，该程序：\n1. 根据为常数 $N_0$ 和刚性盖边界物理推导出的色散关系计算 $\\omega_{\\text{true}}$。\n2. 对于每个指定的测试用例，使用相应稳定函数对 $\\omega_{\\text{num}}$ 的定义，为上述四种格式计算 $\\varepsilon$。\n\n使用以下测试套件。所有量都必须按指定的物理单位处理：\n- 情况 1 (理想情况)：$N_0 = 0.01$ s$^{-1}$，$H = 1000$ m，$k = 0.001$ m$^{-1}$，$n = 1$，$\\Delta t = 10$ s。\n- 情况 2 (高垂直模态)：$N_0 = 0.01$ s$^{-1}$，$H = 1000$ m，$k = 0.001$ m$^{-1}$，$n = 10$，$\\Delta t = 10$ s。\n- 情况 3 (小时间步长)：$N_0 = 0.02$ s$^{-1}$，$H = 2000$ m，$k = 0.005$ m$^{-1}$，$n = 1$，$\\Delta t = 1$ s。\n- 情况 4 (大时间步长)：$N_0 = 0.01$ s$^{-1}$，$H = 1000$ m，$k = 0.002$ m$^{-1}$，$n = 1$，$\\Delta t = 500$ s。\n- 情况 5 (长波，深域)：$N_0 = 0.005$ s$^{-1}$，$H = 4000$ m，$k = 0.0002$ m$^{-1}$，$n = 3$，$\\Delta t = 100$ s。\n\n对于每种情况，按以下固定的格式顺序计算并记录四个相对色散误差 $\\varepsilon$：二阶 Runge–Kutta (RK2)、经典四阶 Runge–Kutta (RK4)、Crank–Nicolson (CN)、Forward Euler。最终输出格式必须是单行，包含一个用方括号括起来的逗号分隔列表，其条目严格按照情况和格式的顺序排列：\n$[\\text{Case1\\_RK2}, \\text{Case1\\_RK4}, \\text{Case1\\_CN}, \\text{Case1\\_Euler}, \\text{Case2\\_RK2}, \\dots, \\text{Case5\\_Euler}]$。\n所有输出都必须是无量纲小数 (浮点数)。不应打印任何额外文本。",
            "solution": "该问题要求对内重力波的数值色散进行分析。求解过程包括两个主要阶段：首先，从控制方程推导精确的物理色散关系；其次，评估几种常用时间步进格式引入的色散误差。\n\n**1. 精确色散关系的推导**\n\n物理系统由二维、线性化的 Boussinesq 方程描述，适用于具有恒定浮力频率 $N_0$ 的无粘、无旋流体：\n$$ \\partial_t u = - \\frac{1}{\\rho_0} \\partial_x p $$\n$$ \\partial_t w = - \\frac{1}{\\rho_0} \\partial_z p + b $$\n$$ \\partial_t b + N_0^2 w = 0 $$\n$$ \\partial_x u + \\partial_z w = 0 $$\n这里，$u$ 和 $w$ 是水平和垂直速度分量，$p$ 是压力扰动，$b$ 是浮力，$\\rho_0$ 是恒定参考密度。域在 $z=0$ 和 $z=H$ 处由刚性盖限定，施加边界条件 $w(z=0)=0$ 和 $w(z=H)=0$。\n\n我们寻找形式为 $f(x,z,t) = \\hat{f}(z) e^{i(kx - \\omega t)}$ 的平面波解，其中 $k$ 是水平波数，$\\omega$ 是角频率。将此形式代入控制方程，得到一个关于 $z$ 的常微分方程组：\n$$ -i\\omega \\hat{u} = -\\frac{1}{\\rho_0} ik \\hat{p} \\quad \\implies \\quad \\omega \\hat{u} = \\frac{k}{\\rho_0} \\hat{p} $$\n$$ -i\\omega \\hat{w} = -\\frac{1}{\\rho_0} \\frac{d\\hat{p}}{dz} + \\hat{b} $$\n$$ -i\\omega \\hat{b} + N_0^2 \\hat{w} = 0 \\quad \\implies \\quad \\hat{b} = \\frac{i N_0^2}{\\omega} \\hat{w} $$\n$$ ik \\hat{u} + \\frac{d\\hat{w}}{dz} = 0 \\quad \\implies \\quad \\hat{u} = \\frac{i}{k} \\frac{d\\hat{w}}{dz} $$\n\n从第一个和第四个变换后的方程，我们可以将 $\\hat{p}$ 表示为 $\\hat{w}$ 的函数：\n$$ \\omega \\left(\\frac{i}{k} \\frac{d\\hat{w}}{dz}\\right) = \\frac{k}{\\rho_0} \\hat{p} \\quad \\implies \\quad \\hat{p} = \\frac{i \\omega \\rho_0}{k^2} \\frac{d\\hat{w}}{dz} $$\n将 $\\hat{p}$ 和 $\\hat{b}$ 的表达式代入第二个变换后的（垂直动量）方程，可以消去除 $\\hat{w}$ 之外的所有变量：\n$$ -i\\omega \\hat{w} = -\\frac{1}{\\rho_0} \\frac{d}{dz}\\left(\\frac{i \\omega \\rho_0}{k^2} \\frac{d\\hat{w}}{dz}\\right) + \\frac{i N_0^2}{\\omega} \\hat{w} $$\n将此方程除以 $i$ 并重新整理各项，可得：\n$$ -\\omega \\hat{w} = -\\frac{\\omega}{k^2} \\frac{d^2\\hat{w}}{dz^2} + \\frac{N_0^2}{\\omega} \\hat{w} $$\n$$ \\frac{\\omega}{k^2} \\frac{d^2\\hat{w}}{dz^2} + \\left(\\omega - \\frac{N_0^2}{\\omega}\\right) \\hat{w} = 0 $$\n$$ \\frac{d^2\\hat{w}}{dz^2} + \\frac{k^2(N_0^2 - \\omega^2)}{\\omega^2} \\hat{w} = 0 $$\n这是一个描述波的垂直结构的标准二阶常微分方程。我们定义垂直波数 $m$ 使得 $m^2 = \\frac{k^2(N_0^2 - \\omega^2)}{\\omega^2}$。该方程变为简谐振子方程：\n$$ \\frac{d^2\\hat{w}}{dz^2} + m^2 \\hat{w} = 0 $$\n$\\hat{w}(z)$ 的通解是 $\\hat{w}(z) = A \\sin(mz) + B \\cos(mz)$。应用刚性盖边界条件：\n-   $w(z=0) = 0 \\implies \\hat{w}(0)=0 \\implies A \\sin(0) + B \\cos(0) = 0 \\implies B=0$。\n-   $w(z=H) = 0 \\implies \\hat{w}(H)=0 \\implies A \\sin(mH) = 0$。\n对于非平凡解 ($A \\neq 0$)，必须有 $\\sin(mH)=0$，这将垂直波数 $m$ 量子化：\n$$ mH = n\\pi, \\quad \\text{其中整数 } n = 1, 2, 3, \\ldots $$\n因此，垂直波数由 $m_n = \\frac{n\\pi}{H}$ 给出。\n\n最后，我们使用 $m^2$ 的定义求解频率 $\\omega$：\n$$ m^2 = \\left(\\frac{n\\pi}{H}\\right)^2 = \\frac{k^2(N_0^2 - \\omega^2)}{\\omega^2} $$\n$$ \\omega^2 m^2 = k^2 N_0^2 - k^2 \\omega^2 $$\n$$ \\omega^2 (k^2 + m^2) = k^2 N_0^2 $$\n$$ \\omega^2 = \\frac{k^2 N_0^2}{k^2 + m^2} $$\n第 $n$ 阶垂直模态的精确角频率，记为 $\\omega_{\\text{true}}$，是其正根：\n$$ \\omega_{\\text{true}}(k, n) = \\sqrt{\\frac{k^2 N_0^2}{k^2 + (n\\pi/H)^2}} = \\frac{N_0 k}{\\sqrt{k^2 + (n\\pi/H)^2}} $$\n\n**2. 数值色散分析**\n\n单个傅里叶模态的时间演化由常微分方程 $\\partial_t y = i \\omega_{\\text{true}} y$ 控制。我们将各种数值时间步进格式应用于此模型问题，其中 $\\lambda = i \\omega_{\\text{true}}$。一个单步格式将时间 $t^{n+1}$ 的解近似为 $y^{n+1} = R(\\lambda \\Delta t) y^n$，其中 $R(z)$ 是该格式的稳定函数，$z = \\lambda \\Delta t$。对于此问题，$z = i \\omega_{\\text{true}} \\Delta t$。令 $x = \\omega_{\\text{true}} \\Delta t$，则 $z=ix$。\n\n数值角频率 $\\omega_{\\text{num}}$ 由格式在单个时间步长内所赋予的相位旋转定义：\n$$ \\omega_{\\text{num}} = \\frac{\\arg(R(ix))}{\\Delta t} $$\n相对色散误差 $\\varepsilon$ 则为：\n$$ \\varepsilon = \\frac{\\omega_{\\text{num}} - \\omega_{\\text{true}}}{\\omega_{\\text{true}}} = \\frac{\\arg(R(ix)) / \\Delta t}{\\omega_{\\text{true}}} - 1 = \\frac{\\arg(R(ix))}{x} - 1 $$\n所需格式的稳定函数是：\n-   **Forward Euler**：$y^{n+1} = y^n + \\Delta t (\\lambda y^n)$。$R_{FE}(z) = 1 + z$。\n-   **二阶 Runge-Kutta (显式中点法)**：$y^{n+1} = y^n + \\Delta t \\lambda(y^n + \\frac{\\Delta t}{2}\\lambda y^n)$。$R_{RK2}(z) = 1 + z + \\frac{z^2}{2}$。\n-   **经典四阶 Runge-Kutta**：$R_{RK4}(z) = 1 + z + \\frac{z^2}{2!} + \\frac{z^3}{3!} + \\frac{z^4}{4!}$。\n-   **Crank-Nicolson**：$y^{n+1} = y^n + \\frac{\\Delta t}{2}(\\lambda y^n + \\lambda y^{n+1})$。$R_{CN}(z) = \\frac{1+z/2}{1-z/2}$。\n\n代入 $z=ix$，我们得到复数放大因子及其辐角（使用 $\\arg(a+ib) = \\mathrm{atan2}(b,a)$ 计算）：\n-   $R_{FE}(ix) = 1 + ix$。$\\arg(R_{FE}) = \\mathrm{atan2}(x, 1)$。\n-   $R_{RK2}(ix) = 1 - x^2/2 + ix$。$\\arg(R_{RK2}) = \\mathrm{atan2}(x, 1 - x^2/2)$。\n-   $R_{RK4}(ix) = (1 - x^2/2 + x^4/24) + i(x - x^3/6)$。$\\arg(R_{RK4}) = \\mathrm{atan2}(x - x^3/6, 1 - x^2/2 + x^4/24)$。\n-   $R_{CN}(ix) = \\frac{1+ix/2}{1-ix/2}$。$\\arg(R_{CN}) = 2 \\arctan(x/2)$。\n\n每个测试用例的计算步骤如下：\n1.  给定 $N_0$、$H$、$k$、$n$ 和 $\\Delta t$。\n2.  使用推导出的色散关系计算 $\\omega_{\\text{true}}$。\n3.  计算无量纲参数 $x = \\omega_{\\text{true}} \\Delta t$。\n4.  对于每种格式 (RK2, RK4, CN, Euler)，计算其稳定函数 $R(ix)$ 的辐角。\n5.  计算相对色散误差 $\\varepsilon = \\frac{\\arg(R(ix))}{x} - 1$。\n6.  按指定顺序收集结果以备最终输出。\n\n这种方法系统地量化了每种数值格式在多大程度上保持了波的相位，这是精确模拟波传播的一个关键方面。像 Forward Euler 和 Runge-Kutta 这样的显式格式在大的时间步长（大的 $x$）下可能会变得不稳定，导致非物理的振幅增长，但如此定义的色散误差仍然可以计算。对于这个问题，Crank-Nicolson 格式是幺正的（$|R_{CN}(ix)|=1$），这意味着它没有振幅误差，只有色散误差。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the numerical dispersion error for several time-stepping schemes\n    simulating internal gravity wave propagation.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: ideal case\n        {'N0': 0.01, 'H': 1000, 'k': 0.001, 'n': 1, 'dt': 10},\n        # Case 2: high vertical mode\n        {'N0': 0.01, 'H': 1000, 'k': 0.001, 'n': 10, 'dt': 10},\n        # Case 3: small time step\n        {'N0': 0.02, 'H': 2000, 'k': 0.005, 'n': 1, 'dt': 1},\n        # Case 4: large time step\n        {'N0': 0.01, 'H': 1000, 'k': 0.002, 'n': 1, 'dt': 500},\n        # Case 5: long wave, deep domain\n        {'N0': 0.005, 'H': 4000, 'k': 0.0002, 'n': 3, 'dt': 100},\n    ]\n\n    def calculate_omega_true(N0, H, k, n):\n        \"\"\"Calculates the exact internal gravity wave frequency.\"\"\"\n        m = n * np.pi / H\n        omega_sq = (k**2 * N0**2) / (k**2 + m**2)\n        return np.sqrt(omega_sq)\n\n    def error_euler(x):\n        \"\"\"Dispersion error for Forward Euler.\"\"\"\n        # R(ix) = 1 + ix\n        # arg(R) = atan2(x, 1)\n        arg_R = np.arctan2(x, 1.0)\n        return arg_R / x - 1.0\n\n    def error_rk2(x):\n        \"\"\"Dispersion error for RK2 (explicit midpoint).\"\"\"\n        # R(ix) = 1 + ix + (ix)^2/2 = (1 - x^2/2) + ix\n        real_part = 1.0 - x**2 / 2.0\n        imag_part = x\n        arg_R = np.arctan2(imag_part, real_part)\n        return arg_R / x - 1.0\n\n    def error_rk4(x):\n        \"\"\"Dispersion error for classical RK4.\"\"\"\n        # R(ix) = 1 + ix + (ix)^2/2! + (ix)^3/3! + (ix)^4/4!\n        # R(ix) = (1 - x^2/2 + x^4/24) + i*(x - x^3/6)\n        real_part = 1.0 - x**2/2.0 + x**4/24.0\n        imag_part = x - x**3/6.0\n        arg_R = np.arctan2(imag_part, real_part)\n        return arg_R / x - 1.0\n\n    def error_cn(x):\n        \"\"\"Dispersion error for Crank-Nicolson.\"\"\"\n        # R(ix) = (1 + ix/2) / (1 - ix/2)\n        # arg(R) = 2 * arctan(x/2)\n        arg_R = 2.0 * np.arctan(x / 2.0)\n        return arg_R / x - 1.0\n\n    results = []\n    for case in test_cases:\n        N0, H, k, n, dt = case['N0'], case['H'], case['k'], case['n'], case['dt']\n\n        omega_true = calculate_omega_true(N0, H, k, n)\n        x = omega_true * dt\n\n        # Calculate errors for all schemes\n        err_rk2 = error_rk2(x)\n        err_rk4 = error_rk4(x)\n        err_cn = error_cn(x)\n        err_euler = error_euler(x)\n\n        # Append results in the specified order: RK2, RK4, CN, Euler\n        results.extend([err_rk2, err_rk4, err_cn, err_euler])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.15f}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}