{
    "hands_on_practices": [
        {
            "introduction": "This exercise grounds our understanding of convection at the most fundamental level: the journey of a single air parcel. We will explore how entrainment, the continuous mixing of cooler and drier environmental air, fundamentally alters a parcel's buoyancy profile as it rises. By numerically integrating the parcel's path, you will calculate the Convective Inhibition (CIN), which represents the energy barrier that must be overcome to trigger a storm, providing a tangible metric for convective potential .",
            "id": "3896701",
            "problem": "Consider a one-dimensional entraining plume model used to approximate convective parcel ascent in environmental and earth system modeling. Let $z$ denote height in meters, with $z = 0$ at the surface and $z \\ge 0$ upwards. Define the environmental virtual potential temperature profile as a linear function of height,\n$$\\theta_{v,e}(z) = \\theta_{v,0} + \\gamma_e z,$$\nwhere $\\theta_{v,0}$ is the surface environmental virtual potential temperature in kelvin and $\\gamma_e$ is a constant environmental gradient in kelvin per meter. An ascending parcel experiences fractional entrainment at rate $\\epsilon$ (in inverse meters), modeled as first-order mixing of parcel properties with the environment. Neglect detrainment effects on parcel properties. Above the Lifting Condensation Level (LCL), latent heating is parameterized as a constant source term that increases parcel virtual potential temperature at rate $h_m$ (in kelvin per meter). The parcel virtual potential temperature $\\theta_{v,p}(z)$ evolves according to the ordinary differential equation\n$$\\frac{d\\theta_{v,p}}{dz} = \\epsilon\\left(\\theta_{v,e}(z) - \\theta_{v,p}(z)\\right) + H(z),$$\nwhere\n$$H(z) = \\begin{cases}\n0,  0 \\le z  z_{\\mathrm{LCL}},\\\\\nh_m,  z \\ge z_{\\mathrm{LCL}}.\n\\end{cases}$$\nThe parcel buoyancy relative to the environment is given by\n$$B(z) = g \\frac{\\theta_{v,p}(z) - \\theta_{v,e}(z)}{\\theta_{v,e}(z)},$$\nwhere $g$ is gravitational acceleration in meters per second squared. Convective Inhibition (CIN) is the minimum mechanical work per unit mass needed to lift the parcel from the surface to its Level of Free Convection (LFC), where buoyancy first becomes nonnegative. Formally, with $z_{\\mathrm{LFC}}$ defined as the smallest height where $B(z) \\ge 0$, the CIN is\n$$\\mathrm{CIN}(\\epsilon) = - \\int_0^{z_{\\mathrm{LFC}}} \\min\\left(B(z), 0\\right) \\, dz.$$\nIf no such $z_{\\mathrm{LFC}}$ exists up to a fixed domain top $z_{\\mathrm{top}}$, define\n$$\\mathrm{CIN}(\\epsilon) = - \\int_0^{z_{\\mathrm{top}}} \\min\\left(B(z), 0\\right) \\, dz.$$\nAssume the following physically plausible constants for all test cases:\n- $g = 9.81$ meters per second squared,\n- $\\theta_{v,0} = 300$ kelvin,\n- $\\gamma_e = 0.003$ kelvin per meter,\n- $z_{\\mathrm{LCL}} = 800$ meters,\n- $h_m = 0.005$ kelvin per meter,\n- $z_{\\mathrm{top}} = 3000$ meters,\n- numerical integration step $\\Delta z = 10$ meters.\n\nYou must discretize the height and integrate the parcel evolution equation and buoyancy profile to compute $\\mathrm{CIN}(\\epsilon)$ for each parameter set. Use a stable method to detect $z_{\\mathrm{LFC}}$ as the first height at which $B(z)$ becomes nonnegative; if buoyancy becomes nonnegative at the surface, the convective inhibition is zero.\n\nExpress each final $\\mathrm{CIN}$ in joules per kilogram, rounded to one decimal place. Angles do not appear, so no angle-unit specification is needed. The final output must be a single line with the results aggregated as a comma-separated list enclosed in square brackets.\n\nTest Suite:\nCompute $\\mathrm{CIN}(\\epsilon)$ for the following four cases, each defined by the fractional entrainment rate $\\epsilon$ (in inverse meters) and the initial parcel virtual potential temperature $\\theta_{v,p}(0)$ (in kelvin):\n1. $(\\epsilon, \\theta_{v,p}(0)) = (0.0, 300.0)$,\n2. $(\\epsilon, \\theta_{v,p}(0)) = (2\\times 10^{-4}, 299.5)$,\n3. $(\\epsilon, \\theta_{v,p}(0)) = (10^{-3}, 299.0)$,\n4. $(\\epsilon, \\theta_{v,p}(0)) = (5\\times 10^{-4}, 301.0)$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3,result4]\"), where each result is the computed $\\mathrm{CIN}$ in joules per kilogram rounded to one decimal place for the corresponding test case.",
            "solution": "The problem statement has been analyzed and is deemed valid. It is scientifically grounded in the principles of atmospheric thermodynamics and convection, employing a standard one-dimensional entraining plume model. The problem is well-posed, providing a first-order ordinary differential equation with a well-defined initial condition and all necessary parameters. The language is objective and the requirements are clear and unambiguous.\n\nThe solution to this problem involves the numerical integration of the parcel's virtual potential temperature profile, the subsequent calculation of its buoyancy profile, and finally, the numerical evaluation of the Convective Inhibition (CIN) integral. The procedure is executed for each specified test case.\n\nThe algorithmic steps are as follows:\n\n1.  **Domain Discretization**: The continuous vertical domain $z \\in [0, z_{\\mathrm{top}}]$ is discretized into a finite number of points. We define a uniform grid $z_i = i \\cdot \\Delta z$ for $i = 0, 1, 2, \\dots, N$, where $N = z_{\\mathrm{top}} / \\Delta z$. The given parameters are $z_{\\mathrm{top}} = 3000$ m and $\\Delta z = 10$ m, resulting in $N=300$ intervals and $301$ grid points.\n\n2.  **Environmental Profile**: The environmental virtual potential temperature, $\\theta_{v,e}(z)$, is a linear function of height. Its value at each discrete grid point $z_i$ is calculated as:\n    $$ \\theta_{v,e}(z_i) = \\theta_{v,0} + \\gamma_e z_i $$\n    where $\\theta_{v,0} = 300$ K and $\\gamma_e = 0.003$ K/m.\n\n3.  **Parcel Virtual Potential Temperature Profile**: The evolution of the parcel's virtual potential temperature, $\\theta_{v,p}(z)$, is governed by the ordinary differential equation (ODE):\n    $$ \\frac{d\\theta_{v,p}}{dz} = \\epsilon\\left(\\theta_{v,e}(z) - \\theta_{v,p}(z)\\right) + H(z) $$\n    This is an initial value problem, with $\\theta_{v,p}(0)$ provided for each test case. We solve this ODE numerically. A first-order Euler forward method is sufficient and appropriate for this problem structure. The iterative scheme to find $\\theta_{v,p}$ at grid point $z_{i+1}$ from the value at $z_i$ is:\n    $$ \\theta_{v,p}(z_{i+1}) = \\theta_{v,p}(z_i) + \\Delta z \\left[ \\epsilon\\left(\\theta_{v,e}(z_i) - \\theta_{v,p}(z_i)\\right) + H(z_i) \\right] $$\n    The heating term $H(z_i)$ is determined by the height relative to the Lifting Condensation Level, $z_{\\mathrm{LCL}} = 800$ m, with $h_m = 0.005$ K/m:\n    $$ H(z_i) = \\begin{cases} 0,  z_i  z_{\\mathrm{LCL}} \\\\ h_m,  z_i \\ge z_{\\mathrm{LCL}} \\end{cases} $$\n    This integration is performed iteratively from $z_0 = 0$ to $z_N = z_{\\mathrm{top}}$.\n\n4.  **Buoyancy Profile**: Once the parcel and environmental temperature profiles, $\\theta_{v,p}(z_i)$ and $\\theta_{v,e}(z_i)$, are known for all grid points, the buoyancy profile $B(z_i)$ is calculated using its definition:\n    $$ B(z_i) = g \\frac{\\theta_{v,p}(z_i) - \\theta_{v,e}(z_i)}{\\theta_{v,e}(z_i)} $$\n    where $g = 9.81$ m/s².\n\n5.  **Level of Free Convection (LFC)**: The LFC, $z_{\\mathrm{LFC}}$, is the lowest altitude at which the parcel's buoyancy becomes non-negative.\n    *   First, we check the buoyancy at the surface, $B(0)$. If $B(0) \\ge 0$, the parcel is initially buoyant or neutral. In this scenario, $z_{\\mathrm{LFC}} = 0$ and $\\mathrm{CIN} = 0$.\n    *   If $B(0)  0$, we search the discrete buoyancy profile $B(z_i)$ for the first index $i_{\\mathrm{LFC}}$ where $B(z_{i_{\\mathrm{LFC}}}) \\ge 0$. The corresponding height is $z_{\\mathrm{LFC}} = z_{i_{\\mathrm{LFC}}}$.\n    *   If no such height exists within the domain (i.e., $B(z_i)  0$ for all $z_i \\le z_{\\mathrm{top}}$), the upper limit for the CIN integration becomes $z_{\\mathrm{top}}$.\n\n6.  **Convective Inhibition (CIN) Calculation**: CIN is computed by numerically integrating the negative buoyancy from the surface to the LFC. The definition is:\n    $$ \\mathrm{CIN}(\\epsilon) = - \\int_0^{z_{\\mathrm{limit}}} \\min\\left(B(z), 0\\right) \\, dz $$\n    where $z_{\\mathrm{limit}}$ is the LFC or $z_{\\mathrm{top}}$ if the LFC is not reached. We employ the trapezoidal rule for this numerical quadrature, which approximates the integral over the discrete grid from $z_0$ to $z_{\\mathrm{limit}} = z_{i_{\\mathrm{limit}}}$. The integrand is $f(z_i) = \\min(B(z_i), 0)$.\n    $$ \\int_0^{z_{\\mathrm{limit}}} f(z) \\, dz \\approx \\sum_{j=0}^{i_{\\mathrm{limit}}-1} \\frac{f(z_j) + f(z_{j+1})}{2} \\Delta z $$\n    The final CIN is the negative of this value.\n\nThis complete algorithm is implemented for each of the four test cases, and the resulting CIN values are rounded to one decimal place as required.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the convective inhibition problem for all test cases.\n    \"\"\"\n\n    # Define the physical constants provided in the problem statement.\n    constants = {\n        'g': 9.81,          # Gravitational acceleration (m/s^2)\n        'theta_v0': 300.0,    # Surface environmental virtual potential temperature (K)\n        'gamma_e': 0.003,     # Environmental gradient (K/m)\n        'z_lcl': 800.0,       # Lifting Condensation Level (m)\n        'h_m': 0.005,         # Latent heating rate (K/m)\n        'z_top': 3000.0,      # Domain top (m)\n        'dz': 10.0,           # Numerical integration step (m)\n    }\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (epsilon, theta_p_initial)\n    test_cases = [\n        (0.0, 300.0),\n        (2e-4, 299.5),\n        (1e-3, 299.0),\n        (5e-4, 301.0),\n    ]\n\n    results = []\n    for epsilon, theta_p_initial in test_cases:\n        # Calculate CIN for a single case.\n        result = calculate_cin_for_case(epsilon, theta_p_initial, constants)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef calculate_cin_for_case(epsilon, theta_p_initial, constants):\n    \"\"\"\n    Calculates CIN for a single set of parameters.\n    \n    Args:\n        epsilon (float): Fractional entrainment rate (1/m).\n        theta_p_initial (float): Initial parcel virtual potential temperature (K).\n        constants (dict): Dictionary of physical constants.\n        \n    Returns:\n        float: The calculated CIN in J/kg, rounded to one decimal place.\n    \"\"\"\n    g = constants['g']\n    theta_v0 = constants['theta_v0']\n    gamma_e = constants['gamma_e']\n    z_lcl = constants['z_lcl']\n    h_m = constants['h_m']\n    z_top = constants['z_top']\n    dz = constants['dz']\n\n    # Step 1: Discretize the vertical domain.\n    z_grid = np.arange(0, z_top + dz, dz)\n    n_levels = len(z_grid)\n\n    # Step 2: Calculate the environmental virtual potential temperature profile.\n    theta_e_profile = theta_v0 + gamma_e * z_grid\n\n    # Check for initial buoyancy. If non-negative, CIN is zero.\n    initial_buoyancy = g * (theta_p_initial - theta_e_profile[0]) / theta_e_profile[0]\n    if initial_buoyancy >= 0:\n        return 0.0\n\n    # Step 3: Integrate the parcel's virtual potential temperature profile.\n    theta_p_profile = np.zeros(n_levels)\n    theta_p_profile[0] = theta_p_initial\n\n    for i in range(n_levels - 1):\n        z_i = z_grid[i]\n        theta_p_i = theta_p_profile[i]\n        theta_e_i = theta_e_profile[i]\n\n        # Determine the heating term H(z)\n        H_i = h_m if z_i >= z_lcl else 0.0\n\n        # Calculate the derivative d(theta_p)/dz\n        dtheta_p_dz = epsilon * (theta_e_i - theta_p_i) + H_i\n\n        # Perform a single Euler forward step\n        theta_p_profile[i + 1] = theta_p_i + dtheta_p_dz * dz\n\n    # Step 4: Calculate the buoyancy profile.\n    buoyancy_profile = g * (theta_p_profile - theta_e_profile) / theta_e_profile\n\n    # Step 5: Find the Level of Free Convection (LFC).\n    # Find indices where buoyancy is non-negative.\n    lfc_indices = np.where(buoyancy_profile >= 0)[0]\n    \n    if len(lfc_indices) == 0:\n        # LFC is not found within the domain; integrate to the top.\n        i_limit = n_levels - 1\n    else:\n        # LFC is the first height where buoyancy is non-negative.\n        i_limit = lfc_indices[0]\n\n    # The problem implies surface LFC is handled, but to be safe:\n    if i_limit == 0:\n        return 0.0\n\n    # Step 6: Calculate CIN using numerical integration.\n    # The integration range is from z=0 to z_LFC (or z_top).\n    integration_z_points = z_grid[:i_limit + 1]\n    buoyancy_to_integrate = buoyancy_profile[:i_limit + 1]\n    \n    # The integrand is min(B(z), 0).\n    integrand = np.minimum(buoyancy_to_integrate, 0)\n    \n    # Use numpy's trapezoidal rule for numerical quadrature.\n    cin_integral = np.trapz(integrand, x=integration_z_points)\n    \n    # CIN is the negative of the integrated negative buoyancy.\n    cin = -cin_integral\n\n    return round(cin, 1)\n\nsolve()\n```"
        },
        {
            "introduction": "Moving beyond a single parcel, this practice introduces the mass-flux framework, a cornerstone of modern convective parameterization. Here, you will model the updraft as a plume with an evolving mass flux $M(z)$ coupled with its thermodynamic properties. This exercise  challenges you to implement and contrast different entrainment parameterizations, including a constant rate versus a height-dependent one, revealing how these choices directly influence the simulated plume's strength and vertical structure.",
            "id": "3896699",
            "problem": "You are asked to implement and compare two entrainment parameterizations for a one-dimensional steady convective updraft plume using a mass-flux framework in the context of environmental and earth system modeling. The comparison is between a constant entrainment rate and a height-dependent entrainment rate. The goal is to compute vertical profiles of updraft mass flux and buoyancy for a given environmental sounding and to summarize specific diagnostic outputs.\n\nUse the following foundational base, which you must derive from first principles to obtain the working equations:\n- Mass conservation for a steady entraining plume and scalar mixing applied to virtual potential temperature. These together imply a coupled system of Ordinary Differential Equations (ODEs) for the updraft mass flux and the updraft thermodynamic property under entrainment and detrainment.\n- The definition of buoyancy based on virtual potential temperature, consistent with the Boussinesq approximation.\n\nEnvironmental sounding and constants:\n- The environmental virtual potential temperature profile is specified by a linear function of height given by $\\theta_{v,e}(z) = \\theta_{v,\\text{sfc}} + \\gamma z$, where $\\theta_{v,\\text{sfc}} = 300\\,\\mathrm{K}$ and $\\gamma = 0.004\\,\\mathrm{K\\,m^{-1}}$.\n- Gravitational acceleration is $g = 9.81\\,\\mathrm{m\\,s^{-2}}$.\n- The lower bound of the plume is $z_0 = 500\\,\\mathrm{m}$ and the model top is $z_{\\text{top}} = 3000\\,\\mathrm{m}$.\n- The initial updraft mass flux at $z_0$ is $M_0 = 0.08\\,\\mathrm{kg\\,m^{-2}\\,s^{-1}}$.\n- The initial updraft virtual potential temperature is set by an environmental perturbation: $\\theta_{v,u}(z_0) = \\theta_{v,e}(z_0) + \\Delta\\theta_{v,0}$ with $\\Delta\\theta_{v,0} = 2.0\\,\\mathrm{K}$.\n- Detrainment is parameterized as a fixed fraction of entrainment: $\\delta(z) = \\alpha\\,\\epsilon(z)$ with $\\alpha$ constant per test case.\n\nParameterizations to compare:\n- Constant entrainment rate: $\\epsilon(z) = \\epsilon_0$, with $\\epsilon_0$ given per test case.\n- Height-dependent entrainment rate: $\\epsilon(z) = \\epsilon_0\\left(1 + \\frac{z}{H}\\right)$, where $H$ is a specified depth scale per test case.\n\nTasks:\n- Starting from mass conservation and scalar mixing for an entraining plume, derive the governing ODEs for the updraft mass flux $M(z)$ and the updraft virtual potential temperature $\\theta_{v,u}(z)$ under entrainment and detrainment. Then derive the expression for the buoyancy $b(z)$ in terms of the environmental and updraft virtual potential temperatures.\n- Implement a numerical integration in height from $z_0$ to $z_{\\text{top}}$ using a fixed vertical step $\\Delta z = 10\\,\\mathrm{m}$ to obtain $M(z)$ and $b(z)$ for each parameterization case in the test suite. Ensure scientific realism by correctly applying the entrainment and detrainment effects, and by computing buoyancy from the thermodynamic difference between the updraft and environment.\n\nRequired outputs per test case:\n- The updraft mass flux at model top: $M(z_{\\text{top}})$ in $\\mathrm{kg\\,m^{-2}\\,s^{-1}}$.\n- The buoyancy at model top: $b(z_{\\text{top}})$ in $\\mathrm{m\\,s^{-2}}$.\n- The first neutral height $z_\\text{neutral}$ in meters, defined as the lowest $z \\in [z_0, z_{\\text{top}}]$ at which $b(z)$ first becomes non-positive. If no neutral height occurs in the interval, return $-1.0$.\n\nTest suite:\n- Case $1$ (happy path): constant entrainment with $\\epsilon_0 = 1.0\\times 10^{-4}\\,\\mathrm{m^{-1}}$ and $\\alpha = 0.2$.\n- Case $2$ (height-dependent): height-dependent entrainment with $\\epsilon_0 = 1.0\\times 10^{-4}\\,\\mathrm{m^{-1}}$, $H = 2000\\,\\mathrm{m}$, and $\\alpha = 0.2$.\n- Case $3$ (boundary, no entrainment): constant entrainment with $\\epsilon_0 = 0.0\\,\\mathrm{m^{-1}}$ and $\\alpha = 0.2$.\n- Case $4$ (boundary, mass-flux neutral detrainment): constant entrainment with $\\epsilon_0 = 1.0\\times 10^{-4}\\,\\mathrm{m^{-1}}$ and $\\alpha = 1.0$.\n\nUnits:\n- Return $M(z_{\\text{top}})$ in $\\mathrm{kg\\,m^{-2}\\,s^{-1}}$, $b(z_{\\text{top}})$ in $\\mathrm{m\\,s^{-2}}$, and $z_\\text{neutral}$ in $\\mathrm{m}$ as floating-point numbers. Do not use percentages.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list of lists enclosed in square brackets. Each inner list corresponds to a test case and must be ordered as $[M(z_{\\text{top}}), b(z_{\\text{top}}), z_\\text{neutral}]$. For example: $[[m_1,b_1,z_1],[m_2,b_2,z_2],[m_3,b_3,z_3],[m_4,b_4,z_4]]$.",
            "solution": "We begin from a mass-flux representation of a steady convective updraft in a one-dimensional framework. Let $M(z)$ denote the updraft mass flux per unit area, and let $\\epsilon(z)$ and $\\delta(z)$ denote entrainment and detrainment rates per unit height, respectively. Let $\\theta_{v,u}(z)$ denote the updraft virtual potential temperature and $\\theta_{v,e}(z)$ the environmental virtual potential temperature. The buoyancy is defined by $b(z) = g\\,\\frac{\\theta_{v,u}(z) - \\theta_{v,e}(z)}{\\theta_{v,e}(z)}$, consistent with the Boussinesq approximation. The derivation proceeds from the following foundational principles.\n\nFrom mass conservation for a steady entraining plume, the rate of change of mass flux with height equals the net gain from entrainment minus the net loss from detrainment. The inflow of environmental mass into the plume per unit height is $\\epsilon(z)\\,M(z)$, and the outflow from the plume due to detrainment per unit height is $\\delta(z)\\,M(z)$. Therefore,\n$$\n\\frac{dM}{dz} = \\left[\\epsilon(z) - \\delta(z)\\right]\\,M(z).\n$$\nWe parameterize detrainment as a fraction of entrainment, $\\delta(z) = \\alpha\\,\\epsilon(z)$, with $0 \\le \\alpha \\le 1$ to maintain physical realism in the test cases. Substituting yields\n$$\n\\frac{dM}{dz} = \\left[1 - \\alpha\\right]\\,\\epsilon(z)\\,M(z).\n$$\n\nNext, for a conserved scalar $\\chi$ carried by the updraft (neglecting internal sources and sinks), the scalar budget for a steady plume is\n$$\n\\frac{d}{dz}\\left[M(z)\\,\\chi_u(z)\\right] = \\epsilon(z)\\,M(z)\\,\\chi_e(z) - \\delta(z)\\,M(z)\\,\\chi_u(z),\n$$\nwhere $\\chi_u$ denotes the updraft scalar and $\\chi_e$ the environmental scalar. Dividing by $M(z)$ and using $\\frac{dM}{dz}$ from the mass budget,\n$$\n\\frac{d\\chi_u}{dz} + \\frac{1}{M(z)}\\frac{dM}{dz}\\,\\chi_u(z) = \\epsilon(z)\\,\\chi_e(z) - \\delta(z)\\,\\chi_u(z),\n$$\n$$\n\\frac{d\\chi_u}{dz} + \\left[1 - \\alpha\\right]\\,\\epsilon(z)\\,\\chi_u(z) = \\epsilon(z)\\,\\chi_e(z) - \\alpha\\,\\epsilon(z)\\,\\chi_u(z),\n$$\nwhich simplifies to\n$$\n\\frac{d\\chi_u}{dz} = \\epsilon(z)\\,\\left[\\chi_e(z) - \\chi_u(z)\\right].\n$$\nTaking $\\chi \\equiv \\theta_{v}$, we obtain\n$$\n\\frac{d\\theta_{v,u}}{dz} = \\epsilon(z)\\,\\left[\\theta_{v,e}(z) - \\theta_{v,u}(z)\\right].\n$$\n\nBuoyancy is then computed as\n$$\nb(z) = g\\,\\frac{\\theta_{v,u}(z) - \\theta_{v,e}(z)}{\\theta_{v,e}(z)}.\n$$\nWith the environmental sounding specified as\n$$\n\\theta_{v,e}(z) = \\theta_{v,\\text{sfc}} + \\gamma z,\n$$\nwith $\\theta_{v,\\text{sfc}} = 300\\,\\mathrm{K}$ and $\\gamma = 0.004\\,\\mathrm{K\\,m^{-1}}$, and constants $g = 9.81\\,\\mathrm{m\\,s^{-2}}$, the problem reduces to numerically integrating the coupled system:\n- $\\frac{dM}{dz} = \\left[1 - \\alpha\\right]\\,\\epsilon(z)\\,M(z)$,\n- $\\frac{d\\theta_{v,u}}{dz} = \\epsilon(z)\\,\\left[\\theta_{v,e}(z) - \\theta_{v,u}(z)\\right]$,\nwith initial conditions at $z_0 = 500\\,\\mathrm{m}$:\n- $M(z_0) = M_0 = 0.08\\,\\mathrm{kg\\,m^{-2}\\,s^{-1}}$,\n- $\\theta_{v,u}(z_0) = \\theta_{v,e}(z_0) + \\Delta\\theta_{v,0}$ with $\\Delta\\theta_{v,0} = 2.0\\,\\mathrm{K}$,\nand integration up to $z_{\\text{top}} = 3000\\,\\mathrm{m}$.\n\nEntrainment parameterizations:\n- Constant: $\\epsilon(z) = \\epsilon_0$.\n- Height-dependent: $\\epsilon(z) = \\epsilon_0\\left(1 + \\frac{z}{H}\\right)$.\n\nNumerical method:\n- Use a fixed-step forward Euler scheme with $\\Delta z = 10\\,\\mathrm{m}$ to advance $M$ and $\\theta_{v,u}$:\n$$\nM_{n+1} = M_n + \\left[1 - \\alpha\\right]\\,\\epsilon(z_n)\\,M_n\\,\\Delta z,\n$$\n$$\n\\theta_{v,u,n+1} = \\theta_{v,u,n} + \\epsilon(z_n)\\left[\\theta_{v,e}(z_n) - \\theta_{v,u,n}\\right]\\Delta z.\n$$\nAt each level compute buoyancy\n$$\nb_n = g\\,\\frac{\\theta_{v,u,n} - \\theta_{v,e}(z_n)}{\\theta_{v,e}(z_n)}.\n$$\nRecord the first neutral height $z_\\text{neutral}$ where $b$ becomes non-positive. To increase accuracy, if $b_{n}  0$ and $b_{n+1} \\le 0$, linearly interpolate within the interval:\n$$\nz_\\text{neutral} \\approx z_n + \\Delta z\\,\\frac{0 - b_n}{b_{n+1} - b_n}.\n$$\nIf no crossing is found on $[z_0,z_{\\text{top}}]$, return $-1.0$.\n\nTest suite parameters:\n- Case $1$: $\\epsilon_0 = 1.0\\times 10^{-4}\\,\\mathrm{m^{-1}}$, $\\alpha = 0.2$ (constant).\n- Case $2$: $\\epsilon_0 = 1.0\\times 10^{-4}\\,\\mathrm{m^{-1}}$, $H = 2000\\,\\mathrm{m}$, $\\alpha = 0.2$ (height-dependent).\n- Case $3$: $\\epsilon_0 = 0.0\\,\\mathrm{m^{-1}}$, $\\alpha = 0.2$ (constant; boundary of no entrainment).\n- Case $4$: $\\epsilon_0 = 1.0\\times 10^{-4}\\,\\mathrm{m^{-1}}$, $\\alpha = 1.0$ (constant; boundary where detrainment exactly offsets entrainment in the mass budget so $M$ is constant with height).\n\nAlgorithmic outputs per case:\n- $M(z_{\\text{top}})$ in $\\mathrm{kg\\,m^{-2}\\,s^{-1}}$,\n- $b(z_{\\text{top}})$ in $\\mathrm{m\\,s^{-2}}$,\n- $z_\\text{neutral}$ in $\\mathrm{m}$, or $-1.0$ if no neutral level exists.\n\nThe final program aggregates these per-case results into a single printed line as a comma-separated list of lists, matching the required format.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef integrate_case(case, params):\n    # Unpack global parameters\n    z0 = params['z0']\n    z_top = params['z_top']\n    dz = params['dz']\n    g = params['g']\n    theta_sfc = params['theta_sfc']\n    gamma = params['gamma']\n    M0 = params['M0']\n    dtheta0 = params['dtheta0']\n    H_default = params['H_default']\n\n    case_type = case['type']           # 'const' or 'linear'\n    eps0 = case['eps0']                # base entrainment [1/m]\n    alpha = case['alpha']              # detrainment fraction of entrainment\n    H = case.get('H', H_default)       # depth scale [m] for linear entrainment\n\n    # Environmental virtual potential temperature profile\n    def theta_env(z):\n        return theta_sfc + gamma * z\n\n    # Entrainment parameterization function\n    if case_type == 'const':\n        def eps(z):\n            return eps0\n    elif case_type == 'linear':\n        def eps(z):\n            return eps0 * (1.0 + z / H)\n    else:\n        raise ValueError(\"Unknown case type.\")\n\n    # Initialize state at z0\n    z_levels = np.arange(z0, z_top + dz, dz)\n    M = M0\n    theta_u = theta_env(z0) + dtheta0\n    b_prev = g * (theta_u - theta_env(z0)) / theta_env(z0)\n    neutral_height = None\n\n    # March upward\n    for i in range(1, len(z_levels)):\n        z = z_levels[i-1]\n        z_next = z_levels[i]\n        # Compute entrainment\n        eps_z = eps(z)\n\n        # Update mass flux\n        dM = (1.0 - alpha) * eps_z * M * dz\n        M_next = M + dM\n\n        # Update updraft virtual potential temperature\n        theta_e_z = theta_env(z)\n        dtheta_u = eps_z * (theta_e_z - theta_u) * dz\n        theta_u_next = theta_u + dtheta_u\n\n        # Compute buoyancy at next level\n        theta_e_next = theta_env(z_next)\n        b_next = g * (theta_u_next - theta_e_next) / theta_e_next\n\n        # Detect first neutral level\n        if neutral_height is None and (b_prev > 0.0) and (b_next = 0.0):\n            # Linear interpolation for crossing within [z, z_next]\n            frac = (0.0 - b_prev) / (b_next - b_prev) if (b_next - b_prev) != 0.0 else 0.0\n            neutral_height = z + dz * max(0.0, min(1.0, frac))\n\n        # Advance\n        M = M_next\n        theta_u = theta_u_next\n        b_prev = b_next\n\n    # Final outputs\n    M_top = M\n    b_top = b_prev\n    z_neutral = neutral_height if neutral_height is not None else -1.0\n\n    return [M_top, b_top, z_neutral]\n\ndef solve():\n    # Global parameters from the problem statement\n    params = {\n        'z0': 500.0,            # m\n        'z_top': 3000.0,        # m\n        'dz': 10.0,             # m\n        'g': 9.81,              # m/s^2\n        'theta_sfc': 300.0,     # K\n        'gamma': 0.004,         # K/m\n        'M0': 0.08,             # kg m^-2 s^-1\n        'dtheta0': 2.0,         # K\n        'H_default': 2000.0     # m\n    }\n\n    # Define the test cases from the problem statement\n    test_cases = [\n        # Case 1: Constant epsilon, alpha=0.2\n        {'type': 'const', 'eps0': 1.0e-4, 'alpha': 0.2},\n        # Case 2: Height-dependent epsilon, alpha=0.2, H=2000 m\n        {'type': 'linear', 'eps0': 1.0e-4, 'alpha': 0.2, 'H': 2000.0},\n        # Case 3: No entrainment, alpha=0.2\n        {'type': 'const', 'eps0': 0.0, 'alpha': 0.2},\n        # Case 4: Constant epsilon, alpha=1.0 (mass-flux neutral detrainment)\n        {'type': 'const', 'eps0': 1.0e-4, 'alpha': 1.0},\n    ]\n\n    results = []\n    for case in test_cases:\n        M_top, b_top, z_neutral = integrate_case(case, params)\n        results.append([M_top, b_top, z_neutral])\n\n    # Format output: single line, comma-separated lists with no spaces\n    def format_sublist(lst):\n        return \"[\" + \",\".join(f\"{x:.6f}\" for x in lst) + \"]\"\n    output = \"[\" + \",\".join(format_sublist(r) for r in results) + \"]\"\n    print(output)\n\nsolve()\n```"
        },
        {
            "introduction": "This capstone practice integrates the preceding concepts into a comprehensive and more physically realistic plume model. You will manage the budgets for multiple water species—vapor ($q_v$), cloud water ($q_c$), and rain ($q_r$)—and implement the microphysical processes that govern their transformations. The ultimate goal is to verify that your numerical model conserves energy , a critical test of physical consistency and a fundamental requirement for any parameterization used in long-term climate simulations.",
            "id": "3896770",
            "problem": "Consider a one-dimensional, steady, entraining plume model for convection in which the plume transports four scalars: water vapor mixing ratio $q_v$ (kilogram per kilogram), cloud liquid water mixing ratio $q_c$ (kilogram per kilogram), rain water mixing ratio $q_r$ (kilogram per kilogram), and moist static energy $h$ (joule per kilogram). The plume has vertical mass flux $M(z)$ (kilogram per square meter per second) and exchanges mass with the environment through entrainment rate $e(z)$ (per meter) and detrainment rate $d(z)$ (per meter). The environment has prescribed profiles of temperature $T_{\\mathrm{env}}(z)$ (kelvin) and water vapor mixing ratio $q_{v,\\mathrm{env}}(z)$ (kilogram per kilogram).\n\nDefine moist static energy $h$ by $h = c_p T + g z + L_v q_v$, where $c_p$ (joule per kilogram per kelvin) is the specific heat at constant pressure of dry air, $T$ (kelvin) is the plume temperature, $g$ (meter per square second) is gravitational acceleration, $z$ (meter) is height, and $L_v$ (joule per kilogram) is latent heat of vaporization. For energy conservation verification, also define the generalized moist static energy $h_g = c_p T + g z + L_v (q_v + q_c + q_r)$, which accounts for latent energy stored in all hydrometeors.\n\nAssume the following foundational laws and definitions:\n- Scalar conservation in a steady entraining/detraining plume is written for any plume scalar $\\phi$ as the vertical flux budget\n$$\\frac{d}{dz}\\left(M \\phi\\right) = e M \\left(\\phi_{\\mathrm{env}} - \\phi\\right) - d M \\left(\\phi - \\phi_{\\mathrm{env}}\\right) + S_\\phi,$$\nwhere $\\phi_{\\mathrm{env}}$ is the environmental counterpart of $\\phi$ and $S_\\phi$ represents internal source/sink terms due to microphysics. Note that the mixing term simplifies to $(e + d) M (\\phi_{\\mathrm{env}} - \\phi)$.\n- Plume mass flux evolves as\n$$\\frac{dM}{dz} = \\left(e - d\\right) M.$$\n- Pressure $p(z)$ (pascal) is hydrostatic and approximated by an exponential profile $p(z) = p_0 \\exp\\left(-\\frac{z}{H}\\right)$, with reference pressure $p_0$ (pascal) and scale height $H$ (meter).\n- The saturation vapor pressure $e_s(T)$ (pascal) follows the Clausius–Clapeyron relation\n$$e_s(T) = e_0 \\exp\\left(\\frac{L_v}{R_v}\\left(\\frac{1}{T_0} - \\frac{1}{T}\\right)\\right),$$\nwith $e_0$ (pascal) at $T_0$ (kelvin), and water vapor gas constant $R_v$ (joule per kilogram per kelvin). The saturation mixing ratio $q_{\\mathrm{sat}}(T,p)$ (kilogram per kilogram) is\n$$q_{\\mathrm{sat}}(T,p) = \\epsilon \\frac{e_s(T)}{p - e_s(T)},$$\nwhere $\\epsilon$ is the ratio of the gas constant of dry air to the gas constant of water vapor.\n\nMicrophysics is parameterized with per-meter rates (mixing ratio change per meter) that are functions of plume state:\n- Condensation rate $r_C = \\max\\left(q_v - q_{\\mathrm{sat}}, 0\\right)/\\ell_{\\mathrm{cond}}$ transfers from $q_v$ to $q_c$ when supersaturated, with condensation length scale $\\ell_{\\mathrm{cond}}$ (meter).\n- Evaporation of rain $r_E = \\mathbf{1}_{q_{\\mathrm{sat}} > q_v} \\cdot \\min\\left(q_{\\mathrm{sat}} - q_v, q_r\\right)/\\ell_{\\mathrm{evap}}$ transfers from $q_r$ to $q_v$ when subsaturated, with evaporation length scale $\\ell_{\\mathrm{evap}}$ (meter).\n- Autoconversion $r_A = \\max\\left(q_c - q_{\\mathrm{auto}}, 0\\right)/\\ell_{\\mathrm{auto}}$ transfers from $q_c$ to $q_r$ when cloud water exceeds threshold $q_{\\mathrm{auto}}$ (kilogram per kilogram), with autoconversion length scale $\\ell_{\\mathrm{auto}}$ (meter).\n- Sedimentation $r_S = q_r / \\ell_{\\mathrm{sed}}$ removes rain from the plume (precipitation leaving the column), with sedimentation length scale $\\ell_{\\mathrm{sed}}$ (meter).\n\nThe microphysical source terms in the flux budgets are then\n$$S_{q_v} = M\\left(-r_C + r_E\\right), \\quad S_{q_c} = M\\left(r_C - r_A\\right), \\quad S_{q_r} = M\\left(r_A - r_E - r_S\\right), \\quad S_h = 0,$$\nand for generalized moist static energy\n$$S_{h_g} = - L_v M r_S,$$\nsince phase changes internal to the column do not alter $h_g$, while precipitation (sedimentation) removes latent energy from the column.\n\nYour task is to implement a numerical solver that:\n1. Discretizes the column from $z = 0$ (meter) to $z = z_{\\mathrm{top}}$ (meter) into $N$ equally spaced levels.\n2. Initializes plume state at $z = 0$ using given base values $T(0)$ (kelvin), $q_v(0)$ (kilogram per kilogram), $q_c(0) = 0$ (kilogram per kilogram), $q_r(0) = 0$ (kilogram per kilogram), and $M(0)$ (kilogram per square meter per second). Set $h(0) = c_p T(0) + g\\cdot 0 + L_v q_v(0)$.\n3. Prescribes environment profiles: $T_{\\mathrm{env}}(z) = T_{\\mathrm{env},0} - \\Gamma z$ (kelvin) with lapse rate $\\Gamma$ (kelvin per meter), $q_{v,\\mathrm{env}}(z) = q_{v,\\mathrm{env},0} \\exp\\left(-z/\\Lambda_q\\right)$ (kilogram per kilogram) with moisture scale height $\\Lambda_q$ (meter), and $h_{\\mathrm{env}}(z) = c_p T_{\\mathrm{env}}(z) + g z + L_v q_{v,\\mathrm{env}}(z)$.\n4. Marches upward with a forward-Euler scheme in $z$ for each scalar flux $F_\\phi = M \\phi$ using the budgets above and updates $M$ using $\\frac{dM}{dz} = (e - d)M$. At each level, recovers $T$ from $h = c_p T + g z + L_v q_v$ via $T = \\left(h - g z - L_v q_v\\right)/c_p$, computes $q_{\\mathrm{sat}}(T,p)$, and then computes $r_C$, $r_E$, $r_A$, and $r_S$ along with $S_\\phi$. Keep $q_v$, $q_c$, and $q_r$ nonnegative by clipping at $0$ (kilogram per kilogram).\n5. Computes the cumulative precipitation mass flux leaving the column,\n$$P = \\int_0^{z_{\\mathrm{top}}} M(z) r_S(z) \\, dz,$$\nin kilogram per square meter per second.\n6. Verifies column generalized energy conservation by numerically checking the integral form of the $h_g$ flux budget:\n$$\\left[M h_g\\right]_{z=0}^{z=z_{\\mathrm{top}}} \\stackrel{?}{=} \\int_0^{z_{\\mathrm{top}}} \\left( (e+d) M \\left(h_{g,\\mathrm{env}} - h_g\\right) - L_v M r_S \\right) dz,$$\nwhere $h_g = c_p T + g z + L_v (q_v + q_c + q_r)$ and $h_{g,\\mathrm{env}} = c_p T_{\\mathrm{env}} + g z + L_v q_{v,\\mathrm{env}}$.\n7. Returns a boolean indicating whether the absolute residual between the left-hand side and right-hand side is below a tolerance scaled by the magnitude of the two sides. Use the criterion\n$$\\left|\\Delta\\right| \\le \\tau \\cdot \\max\\left(\\left|L\\right| + \\left|R\\right|, \\delta\\right),$$\nwith $\\tau = 10^{-6}$ and $\\delta = 10^{-12}$, where $\\Delta$ is the difference between left-hand side and right-hand side, $L$ is the left-hand side, and $R$ is the right-hand side.\n\nConstants and units to use in all test cases:\n- $c_p = 1004$ (joule per kilogram per kelvin), $g = 9.81$ (meter per square second), $L_v = 2.5 \\times 10^6$ (joule per kilogram), $\\epsilon = 0.622$ (dimensionless), $p_0 = 1.0 \\times 10^5$ (pascal), $H = 7000$ (meter), $e_0 = 611.2$ (pascal), $T_0 = 273.15$ (kelvin), $R_v = 461.0$ (joule per kilogram per kelvin).\n\nTest suite:\nProvide four parameter sets to exercise different regimes. All heights are in meter, temperatures in kelvin, and mixing ratios in kilogram per kilogram. The column top is $z_{\\mathrm{top}} = 5000$ (meter), discretized with $N = 101$ levels.\n- Case A (general moist convection, moderate precipitation): $M(0) = 0.05$, $e = 1.0 \\times 10^{-4}$, $d = 0.7 \\times 10^{-4}$, $\\ell_{\\mathrm{cond}} = 100.0$, $\\ell_{\\mathrm{evap}} = 150.0$, $\\ell_{\\mathrm{auto}} = 200.0$, $\\ell_{\\mathrm{sed}} = 500.0$, $q_{\\mathrm{auto}} = 1.0 \\times 10^{-4}$, $T(0) = 300.0$, $q_v(0) = 0.018$, $T_{\\mathrm{env},0} = 298.0$, $\\Gamma = 6.0 \\times 10^{-3}$, $q_{v,\\mathrm{env},0} = 0.015$, $\\Lambda_q = 2000.0$.\n- Case B (no mixing, microphysics only): $M(0) = 0.05$, $e = 0.0$, $d = 0.0$, $\\ell_{\\mathrm{cond}} = 120.0$, $\\ell_{\\mathrm{evap}} = 150.0$, $\\ell_{\\mathrm{auto}} = 220.0$, $\\ell_{\\mathrm{sed}} = 600.0$, $q_{\\mathrm{auto}} = 1.2 \\times 10^{-4}$, $T(0) = 300.0$, $q_v(0) = 0.018$, $T_{\\mathrm{env},0} = 298.0$, $\\Gamma = 6.0 \\times 10^{-3}$, $q_{v,\\mathrm{env},0} = 0.015$, $\\Lambda_q = 2000.0$.\n- Case C (strong entrainment, dry environment, prevalent evaporation): $M(0) = 0.05$, $e = 3.0 \\times 10^{-4}$, $d = 2.0 \\times 10^{-4}$, $\\ell_{\\mathrm{cond}} = 100.0$, $\\ell_{\\mathrm{evap}} = 80.0$, $\\ell_{\\mathrm{auto}} = 220.0$, $\\ell_{\\mathrm{sed}} = 600.0$, $q_{\\mathrm{auto}} = 1.0 \\times 10^{-4}$, $T(0) = 299.0$, $q_v(0) = 0.017$, $T_{\\mathrm{env},0} = 296.0$, $\\Gamma = 6.5 \\times 10^{-3}$, $q_{v,\\mathrm{env},0} = 0.010$, $\\Lambda_q = 1000.0$.\n- Case D (moist environment, efficient autoconversion, heavy precipitation): $M(0) = 0.08$, $e = 1.0 \\times 10^{-4}$, $d = 0.5 \\times 10^{-4}$, $\\ell_{\\mathrm{cond}} = 90.0$, $\\ell_{\\mathrm{evap}} = 140.0$, $\\ell_{\\mathrm{auto}} = 80.0$, $\\ell_{\\mathrm{sed}} = 300.0$, $q_{\\mathrm{auto}} = 1.0 \\times 10^{-4}$, $T(0) = 302.0$, $q_v(0) = 0.022$, $T_{\\mathrm{env},0} = 300.0$, $\\Gamma = 6.0 \\times 10^{-3}$, $q_{v,\\mathrm{env},0} = 0.020$, $\\Lambda_q = 2500.0$.\n\nYour program should numerically integrate these budgets for each test case and for each case output a boolean indicating whether the generalized energy conservation check in item $6$ passes under the tolerance in item $7$. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[result_1,result_2,result_3,result_4]$), where each $result_i$ is either $True$ or $False$.",
            "solution": "The user has provided a problem that requires the development of a numerical solver for a one-dimensional, steady-state entraining plume model. The model describes the evolution of vertical mass flux ($M$) and four conserved scalars: water vapor ($q_v$), cloud water ($q_c$), rain water ($q_r$), and moist static energy ($h$). The task is to implement this solver, apply it to four distinct test cases, and for each case, verify the numerical conservation of a related quantity, the generalized moist static energy ($h_g$), against a specified tolerance.\n\nBefore proceeding, a rigorous validation of the problem statement is mandatory.\n\n### Problem Validation\n\nThe problem is validated against the required criteria.\n\n**Step 1: Extraction of Givens**\nAll data, equations, constants, initial conditions, and numerical parameters have been meticulously extracted from the problem statement. These include:\n- The system of five coupled ordinary differential equations for $M(z)$, $M(z)q_v(z)$, $M(z)q_c(z)$, $M(z)q_r(z)$, and $M(z)h(z)$.\n- The definitions of moist static energy ($h$) and generalized moist static energy ($h_g$).\n- The auxiliary physical relations for pressure ($p(z)$), saturation vapor pressure ($e_s(T)$), and saturation mixing ratio ($q_{\\mathrm{sat}}(T, p)$).\n- Parameterizations for microphysical processes: condensation ($r_C$), evaporation ($r_E$), autoconversion ($r_A$), and sedimentation ($r_S$), along with their corresponding source terms ($S_\\phi$) in the flux budget equations.\n- The specified numerical method (forward-Euler), grid configuration ($z_{\\mathrm{top}}, N$), and physical constraints (non-negativity of mixing ratios).\n- The precise equation for the integral conservation law of generalized moist static energy to be verified.\n- The numerical tolerance criterion for this verification.\n- A complete set of physical constants and parameters for four distinct test cases.\n\n**Step 2: Validation Using Extracted Givens**\n- **Scientific Groundedness**: The model is based on established principles of fluid dynamics and thermodynamics as applied to atmospheric convection. The entraining plume concept, conservation of mass and scalar quantities, hydrostatic balance, and Clausius-Clapeyron thermodynamics are all cornerstones of atmospheric science. The microphysical parameterizations are simplified but represent standard approaches in atmospheric modeling. The model is scientifically sound.\n- **Well-Posedness**: The problem sets up an initial value problem for a system of ordinary differential equations. Given the initial conditions at $z=0$, the system can be integrated to produce a unique solution. The task is clearly defined, and all necessary information to produce a solution is provided.\n- **Objectivity**: The problem is stated in precise, quantitative, and objective language. There are no subjective or opinion-based components.\n- **Completeness and Consistency**: The problem is self-contained. The provided equations are internally consistent. For example, the integral form of the $h_g$ conservation law presented for verification is the correct mathematical consequence of the differential form of the $h_g$ flux budget equation also provided.\n- **Feasibility**: The specified physical parameters and initial conditions are within a realistic range for atmospheric phenomena. The numerical task is computationally feasible with standard tools.\n\n**Step 3: Verdict and Action**\nThe problem is well-defined, scientifically valid, and internally consistent. It constitutes a standard, albeit comprehensive, numerical modeling exercise in the field of atmospheric science. Therefore, the problem is deemed **valid**, and a solution will be developed.\n\n### Solution and Algorithmic Design\n\nThe solution involves numerically integrating a system of ordinary differential equations from a specified initial state. The core of the algorithm is a step-by-step upward march in altitude, from the base of the atmospheric column to its top.\n\n**1. Discretization and Initialization**\nThe vertical domain, from $z=0$ to $z=z_{\\mathrm{top}}$, is discretized into $N$ equally spaced levels. This defines a grid of heights $z_i = i \\cdot \\Delta z$ for $i=0, \\dots, N-1$, where the step size is $\\Delta z = z_{\\mathrm{top}} / (N-1)$.\n\nArrays are initialized to store the plume's state variables—$M, q_v, q_c, q_r, h$—at each grid level. The environmental profiles for temperature ($T_{\\mathrm{env}}(z)$), water vapor ($q_{v,\\mathrm{env}}(z)$), and pressure ($p(z)$) are pre-calculated and stored for all grid levels based on the provided analytic functions.\n\nThe plume's state at the base level, $z_0=0$, is set according to the given initial conditions: $M(0)$, $T(0)$, and $q_v(0)$ are specified, while $q_c(0)=0$ and $q_r(0)=0$. The initial moist static energy is calculated as $h(0) = c_p T(0) + L_v q_v(0)$.\n\n**2. Numerical Integration with a Forward-Euler Scheme**\nThe system is integrated upward from level $i$ to $i+1$ for $i=0, \\dots, N-2$. The problem specifies a forward-Euler method to be applied to the flux quantities $F_\\phi = M \\phi$ and the mass flux $M$. The update rules are:\n$$M_{i+1} = M_i + \\left(\\frac{dM}{dz}\\right)_i \\Delta z$$\n$$F_{\\phi, i+1} = F_{\\phi, i} + \\left(\\frac{dF_\\phi}{dz}\\right)_i \\Delta z$$\nwhere the subscript $i$ denotes evaluation at level $z_i$.\n\nThe procedure at each step $i$ is as follows:\n- **State Recovery**: The plume temperature $T_i$ is diagnosed from the prognostic variable $h_i$ and the other state variables: $T_i = (h_i - g z_i - L_v q_{v,i}) / c_p$. This step is crucial as it implicitly accounts for latent heating/cooling from phase changes, which conserve $h$ but alter $T$ and $q_v$.\n- **Thermodynamic State**: Using the recovered temperature $T_i$ and the pre-computed pressure $p_i$, the saturation mixing ratio $q_{\\mathrm{sat},i}$ is calculated via the Clausius-Clapeyron and derived relations.\n- **Microphysical Rates**: The per-meter rates for condensation ($r_{C,i}$), evaporation ($r_{E,i}$), autoconversion ($r_{A,i}$), and sedimentation ($r_{S,i}$) are computed based on the current plume state ($q_{v,i}, q_{c,i}, q_{r,i}, q_{\\mathrm{sat},i}$) and the specified length scales.\n- **Source Term Calculation**: The microphysical rates are used to calculate the source terms $S_{\\phi,i}$ for the flux equations of $q_v, q_c$, and $q_r$. As specified, $S_{h,i} = 0$.\n- **Derivative Calculation**: The derivatives $\\left(\\frac{dM}{dz}\\right)_i$ and $\\left(\\frac{dF_\\phi}{dz}\\right)_i$ are computed using the governing equations provided, evaluated with quantities at level $i$. For scalars $\\phi \\in \\{q_c, q_r\\}$, the environmental value $\\phi_{\\mathrm{env}}$ is zero.\n- **State Update**: The values of $M_{i+1}$ and the fluxes $F_{\\phi, i+1}$ are calculated using the forward-Euler formulas.\n- **Scalar Recovery**: The scalar mixing ratios at level $i+1$ are recovered by dividing their respective fluxes by the new mass flux: $\\phi_{i+1} = F_{\\phi, i+1} / M_{i+1}$.\n- **Physical Constraint**: As instructed, the water species mixing ratios ($q_v, q_c, q_r$) are constrained to be non-negative by clipping any negative values to zero. This numerical procedure can introduce small conservation errors, a known artifact of simple advection schemes.\n\n**3. Energy Conservation Verification**\nAfter the integration is complete over the full column, the numerical conservation of generalized moist static energy, $h_g$, is checked. This involves evaluating both sides of the integral conservation law:\n$$\\left[M h_g\\right]_{z=0}^{z_{\\mathrm{top}}} = \\int_0^{z_{\\mathrm{top}}} \\left( (e+d) M \\left(h_{g,\\mathrm{env}} - h_g\\right) - L_v M r_S \\right) dz$$\n- **Left-Hand Side (LHS)**: This is the net flux of $h_g$ out of the domain, computed as $(M h_g)_{N-1} - (M h_g)_0$. The values of $h_g$ at each level are diagnosed from the final computed state variables $T_i, q_{v,i}, q_{c,i}, q_{r,i}$.\n- **Right-Hand Side (RHS)**: This represents the net source of $h_g$ within the domain due to lateral mixing with the environment and removal by precipitation. The integrand is computed at every grid point $i$. The integral is then numerically approximated using the trapezoidal rule, which offers second-order accuracy and is well-suited for this verification.\n- **Comparison**: The absolute difference between the LHS and RHS, $\\Delta = \\mathrm{LHS} - \\mathrm{RHS}$, is compared against the specified relative tolerance: $|\\Delta| \\le \\tau \\cdot \\max(\\left|\\mathrm{LHS}\\right| + \\left|\\mathrm{RHS}\\right|, \\delta)$. The result of this comparison, a boolean value, is the final output for the test case.\n\nThis comprehensive procedure ensures that the model is implemented as specified and that its self-consistency is rigorously tested, adhering to the principles of numerical analysis and scientific computing.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the entraining plume model simulation for all test cases\n    and report on the generalized energy conservation check.\n    \"\"\"\n\n    # --- Physical Constants ---\n    CONST = {\n        'cp': 1004.0,       # J/kg/K\n        'g': 9.81,          # m/s^2\n        'Lv': 2.5e6,        # J/kg\n        'eps': 0.622,       # dimensionless\n        'p0': 1.0e5,        # Pa\n        'H': 7000.0,        # m\n        'e0': 611.2,        # Pa at T0\n        'T0': 273.15,       # K\n        'Rv': 461.0,        # J/kg/K\n    }\n\n    # --- Simulation Parameters ---\n    z_top = 5000.0  # m\n    N = 101         # number of levels\n    \n    # --- Test Cases ---\n    test_cases = [\n        # Case A: General moist convection\n        {'name': 'A', 'M0': 0.05, 'e': 1.0e-4, 'd': 0.7e-4, 'l_cond': 100.0, 'l_evap': 150.0, 'l_auto': 200.0, 'l_sed': 500.0, 'q_auto': 1.0e-4, 'T0': 300.0, 'qv0': 0.018, 'T_env0': 298.0, 'Gamma': 6.0e-3, 'qv_env0': 0.015, 'Lambda_q': 2000.0},\n        # Case B: No mixing\n        {'name': 'B', 'M0': 0.05, 'e': 0.0, 'd': 0.0, 'l_cond': 120.0, 'l_evap': 150.0, 'l_auto': 220.0, 'l_sed': 600.0, 'q_auto': 1.2e-4, 'T0': 300.0, 'qv0': 0.018, 'T_env0': 298.0, 'Gamma': 6.0e-3, 'qv_env0': 0.015, 'Lambda_q': 2000.0},\n        # Case C: Strong entrainment, dry environment\n        {'name': 'C', 'M0': 0.05, 'e': 3.0e-4, 'd': 2.0e-4, 'l_cond': 100.0, 'l_evap': 80.0, 'l_auto': 220.0, 'l_sed': 600.0, 'q_auto': 1.0e-4, 'T0': 299.0, 'qv0': 0.017, 'T_env0': 296.0, 'Gamma': 6.5e-3, 'qv_env0': 0.010, 'Lambda_q': 1000.0},\n        # Case D: Moist environment, efficient autoconversion\n        {'name': 'D', 'M0': 0.08, 'e': 1.0e-4, 'd': 0.5e-4, 'l_cond': 90.0, 'l_evap': 140.0, 'l_auto': 80.0, 'l_sed': 300.0, 'q_auto': 1.0e-4, 'T0': 302.0, 'qv0': 0.022, 'T_env0': 300.0, 'Gamma': 6.0e-3, 'qv_env0': 0.020, 'Lambda_q': 2500.0},\n    ]\n\n    results = []\n    for params in test_cases:\n        conservation_passed = run_simulation(params, CONST, z_top, N)\n        results.append(conservation_passed)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\n\ndef run_simulation(params, C, z_top, N):\n    \"\"\"\n    Runs a single simulation for a given parameter set and checks energy conservation.\n    \"\"\"\n    # --- Grid setup ---\n    z = np.linspace(0, z_top, N)\n    dz = z[1] - z[0]\n\n    # --- Initialize state arrays ---\n    M = np.zeros(N)\n    qv = np.zeros(N)\n    qc = np.zeros(N)\n    qr = np.zeros(N)\n    h = np.zeros(N)\n    T = np.zeros(N)\n    \n    # --- Environment profiles ---\n    p_env = C['p0'] * np.exp(-z / C['H'])\n    T_env = params['T_env0'] - params['Gamma'] * z\n    qv_env = params['qv_env0'] * np.exp(-z / params['Lambda_q'])\n    h_env = C['cp'] * T_env + C['g'] * z + C['Lv'] * qv_env\n    # Assume environment has no cloud or rain for hg_env\n    hg_env = h_env \n\n    # --- Initial conditions (z=0) ---\n    M[0] = params['M0']\n    T[0] = params['T0']\n    qv[0] = params['qv0']\n    qc[0] = 0.0\n    qr[0] = 0.0\n    h[0] = C['cp'] * T[0] + C['Lv'] * qv[0]\n    \n    # --- Integration loop ---\n    for i in range(N - 1):\n        # 1. Diagnose current state temperature T[i]\n        # T[i] was set at the end of the previous loop (or initialization for i=0)\n        # So we can proceed to calculate rates at i.\n\n        # 2. Saturation properties at level i\n        es_i = C['e0'] * np.exp((C['Lv'] / C['Rv']) * (1/C['T0'] - 1/T[i]))\n        qsat_i = C['eps'] * es_i / (p_env[i] - es_i)\n\n        # 3. Microphysical rates at level i (per meter)\n        rC_i = max(0, qv[i] - qsat_i) / params['l_cond']\n        rE_i = (1 if qsat_i > qv[i] else 0) * min(qsat_i - qv[i], qr[i]) / params['l_evap']\n        rA_i = max(0, qc[i] - params['q_auto']) / params['l_auto']\n        rS_i = qr[i] / params['l_sed']\n        \n        # 4. Source terms for fluxes at level i\n        S_qv_i = M[i] * (-rC_i + rE_i)\n        S_qc_i = M[i] * (rC_i - rA_i)\n        S_qr_i = M[i] * (rA_i - rE_i - rS_i)\n        S_h_i = 0.0\n\n        # 5. Flux derivatives at level i\n        e_plus_d = params['e'] + params['d']\n        dFqv_dz = e_plus_d * M[i] * (qv_env[i] - qv[i]) + S_qv_i\n        dFqc_dz = e_plus_d * M[i] * (0.0 - qc[i]) + S_qc_i\n        dFqr_dz = e_plus_d * M[i] * (0.0 - qr[i]) + S_qr_i\n        dFh_dz = e_plus_d * M[i] * (h_env[i] - h[i]) + S_h_i\n\n        # 6. Mass flux derivative at level i\n        dM_dz = (params['e'] - params['d']) * M[i]\n\n        # 7. Update to level i+1 using Forward Euler\n        M[i+1] = M[i] + dM_dz * dz\n        \n        Fqv_i1 = (M[i] * qv[i]) + dFqv_dz * dz\n        Fqc_i1 = (M[i] * qc[i]) + dFqc_dz * dz\n        Fqr_i1 = (M[i] * qr[i]) + dFqr_dz * dz\n        Fh_i1 = (M[i] * h[i]) + dFh_dz * dz\n\n        # 8. Recover scalars at i+1\n        if M[i+1] > 1e-12: # Avoid division by zero\n            qv[i+1] = Fqv_i1 / M[i+1]\n            qc[i+1] = Fqc_i1 / M[i+1]\n            qr[i+1] = Fqr_i1 / M[i+1]\n            h[i+1] = Fh_i1 / M[i+1]\n        else: # If mass flux vanishes, plume dies\n            M[i+1:] = 0\n            qv[i+1:] = qv_env[i+1]\n            qc[i+1:] = 0\n            qr[i+1:] = 0\n            h[i+1:] = h_env[i+1]\n            break\n\n        # 9. Clip for non-negativity\n        qv[i+1] = max(0, qv[i+1])\n        qc[i+1] = max(0, qc[i+1])\n        qr[i+1] = max(0, qr[i+1])\n        \n        # 10. Diagnose T[i+1] for next iteration\n        T[i+1] = (h[i+1] - C['g'] * z[i+1] - C['Lv'] * qv[i+1]) / C['cp']\n    \n    # --- Conservation Check ---\n    # Need to compute rates and integrand at all levels for trapezoidal rule\n    rS = np.zeros(N)\n    for i in range(N):\n        rS[i] = qr[i] / params['l_sed']\n\n    # Generalized moist static energy\n    hg = C['cp'] * T + C['g'] * z + C['Lv'] * (qv + qc + qr)\n\n    # Left-hand side of conservation equation\n    LHS = (M[-1] * hg[-1]) - (M[0] * hg[0])\n\n    # Right-hand side of conservation equation\n    integrand = (params['e'] + params['d']) * M * (hg_env - hg) - C['Lv'] * M * rS\n    RHS = np.trapz(integrand, x=z)\n    \n    # Tolerance check\n    Delta = LHS - RHS\n    tau = 1e-6\n    delta_min = 1e-12\n    threshold = tau * max(abs(LHS) + abs(RHS), delta_min)\n    \n    return abs(Delta) = threshold\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}