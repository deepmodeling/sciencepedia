{"hands_on_practices": [{"introduction": "伯努利试验是理解更复杂概率模型的基石。在深入探讨之前，让我们从一个基本但至关重要的问题开始：我们如何量化单个试验结果的不确定性？本练习将指导您探索伯努利分布的方差，并找出何时这种“不可预测性”达到最大。这个练习不仅能巩固您对核心公式的理解，还能揭示一个深刻的直觉：当成功与失败的概率相等时，结果的不确定性最高。[@problem_id:1392744]", "problem": "一个工程师团队正在设计一种新型的二进制通信信道。在这个信道中，单个比特被逐一传输。由于系统中的固有噪声，传输的比特可能会被翻转。传输单个比特的结果被建模为一个随机事件。令随机变量 $X$ 描述接收比特的状态，其中当比特被正确接收时 $X=1$，当比特被错误接收（即翻转）时 $X=0$。\n\n正确传输的概率由 $P(X=1) = p$ 给出，其中 $p$ 是信道的一个可调设计参数，且 $0 \\le p \\le 1$。因此，错误传输的概率是 $P(X=0) = 1-p$。\n\n对于一个特定的密码学应用，该信道必须被设计成在其结果中具有最大可能的“不可预测性”。这种不可预测性由随机变量 $X$ 的统计方差来量化衡量。确定使 $X$ 的方差最大化的参数 $p$ 的值。你的答案应该是一个单一的数值。", "solution": "我们将接收的比特建模为一个伯努利随机变量 $X$，其中 $P(X=1)=p$ 且 $P(X=0)=1-p$。对于一个伯努利变量，有 $E[X]=p$，并且由于 $X^{2}=X$，我们有 $E[X^{2}]=E[X]=p$。因此，方差为\n$$\n\\operatorname{Var}(X)=E[X^{2}]-(E[X])^{2}=p-p^{2}=p(1-p).\n$$\n为了在 $p \\in [0,1]$ 上最大化 $\\operatorname{Var}(X)$，定义 $f(p)=p(1-p)$。计算其导数：\n$$\nf'(p)=1-2p.\n$$\n令 $f'(p)=0$ 来寻找临界点：\n$$\n1-2p=0 \\;\\Rightarrow\\; p=\\frac{1}{2}.\n$$\n二阶导数为\n$$\nf''(p)=-2<0,\n$$\n这证实了 $p=\\frac{1}{2}$ 是一个局部最大值。评估端点值，有 $f(0)=0$ 和 $f(1)=0$，而 $f\\!\\left(\\frac{1}{2}\\right)=\\frac{1}{4}$，因此在 $[0,1]$ 上的最大值出现在 $p=\\frac{1}{2}$ 处。因此，使方差最大化的 $p$ 的值是 $\\frac{1}{2}$。", "answer": "$$\\boxed{\\frac{1}{2}}$$", "id": "1392744"}, {"introduction": "在现实世界中，事件很少孤立发生。理解多个独立事件之间的相互作用是概率论应用的关键。这个练习模拟了一个常见的情景：我们观察到了一个综合结果（“两个警报中只有一个响了”），并需要推断其中某个特定事件（“是警报A响了”）发生的概率。通过解决这个问题，您将练习使用条件概率进行推断，这是在不完整信息下做出明智判断的核心技能。[@problem_id:1392770]", "problem": "一家科技公司正在为一个数据中心测试两种不同且独立的火灾报警系统，模型A和模型B。设模型A检测到火灾的事件由随机变量 $X_A$ 表示，模型B检测到火灾的事件由 $X_B$ 表示。两者都被建模为伯努利试验。模型A成功检测到火灾的概率为 $p_A$，所以 $P(X_A=1) = p_A$ 且 $P(X_A=0) = 1-p_A$。类似地，模型B成功检测到火灾的概率为 $p_B$，即 $P(X_B=1) = p_B$ 且 $P(X_B=0) = 1-p_B$。这两个系统独立运行。\n\n在一个特定的测试日，启动了一场小型的受控火灾。监控系统报告称，两个报警器中只有一个被触发，但未指明是哪一个。根据此信息，求检测到火灾的是模型A的概率。请用 $p_A$ 和 $p_B$ 将答案表示为一个闭式解析表达式。", "solution": "设 $X_A$ 和 $X_B$ 分别是表示火灾报警器模型A和模型B结果的随机变量。根据题意，这两个是独立的伯努利试验，成功概率分别为 $p_A$ 和 $p_B$。\n$P(X_A=1) = p_A$, $P(X_A=0) = 1-p_A$\n$P(X_B=1) = p_B$, $P(X_B=0) = 1-p_B$\n\n我们要求解的是在两个模型中只有一个检测到火灾的条件下，模型A检测到火灾的条件概率。用我们的随机变量表示，即求解 $P(X_A=1 | X_A + X_B = 1)$。\n\n根据条件概率的定义，我们有：\n$$P(X_A=1 | X_A + X_B = 1) = \\frac{P(X_A=1 \\text{ and } X_A + X_B = 1)}{P(X_A + X_B = 1)}$$\n\n我们首先分析分子，即两个事件交集的概率。事件“$X_A=1$ 且 $X_A + X_B = 1$”仅在 $X_A=1$ 且 $X_B=0$ 时发生。所以，分子为：\n$$P(X_A=1, X_B=0)$$\n由于 $X_A$ 和 $X_B$ 是独立的，我们可以将其写为它们各自概率的乘积：\n$$P(X_A=1, X_B=0) = P(X_A=1) P(X_B=0) = p_A (1-p_B)$$\n\n接下来，我们分析分母 $P(X_A + X_B = 1)$。这是恰好有一个报警器被触发的概率。这可以通过两种互斥的方式发生：\n1. 模型A触发而模型B未触发 ($X_A=1, X_B=0$)。\n2. 模型A未触发而模型B触发 ($X_A=0, X_B=1$)。\n\n所以，我们可以将该概率写为这两个事件的概率之和：\n$$P(X_A + X_B = 1) = P(X_A=1, X_B=0) + P(X_A=0, X_B=1)$$\n再次利用 $X_A$ 和 $X_B$ 的独立性：\n$$P(X_A + X_B = 1) = P(X_A=1)P(X_B=0) + P(X_A=0)P(X_B=1)$$\n代入给定的概率：\n$$P(X_A + X_B = 1) = p_A(1-p_B) + (1-p_A)p_B$$\n\n现在，我们可以结合分子和分母来求得最终的条件概率：\n$$P(X_A=1 | X_A + X_B = 1) = \\frac{p_A(1-p_B)}{p_A(1-p_B) + (1-p_A)p_B}$$\n这个表达式就是最终答案。分子可以展开为 $p_A - p_A p_B$，分母可以展开为 $p_A - p_A p_B + p_B - p_A p_B = p_A + p_B - 2p_A p_B$，但因式分解的形式更清晰。", "answer": "$$\\boxed{\\frac{p_A(1-p_B)}{p_A(1-p_B) + (1-p_A)p_B}}$$", "id": "1392770"}, {"introduction": "我们如何从一个有偏见的、不完美的信息来源中提取出公正、无偏的结果？这个问题不仅是理论上的好奇，也是密码学和计算机模拟等领域的实际挑战。这个由伟大的数学家 John von Neumann 提出的经典算法提供了一个极为巧妙的解决方案。通过分析这个算法，您不仅能加深对伯努利试验的理解，还能接触到期望值和概率算法设计的思想，体验到概率论在解决工程问题时的优雅与力量。[@problem_id:1392786]", "problem": "一位工程师正在为深空探测器设计一个子系统，该子系统依赖于一个本质上具有噪声的物理过程来生成随机比特。原始输出是一个比特序列 $X_1, X_2, X_3, \\dots$，可以建模为一系列独立同分布的伯努利随机变量。对于每个比特 $X_i$，其为‘1’的概率是一个未知但恒定的值 $p$，其为‘0’的概率是 $1-p$。系统在约束条件下运行，即 $p$ 严格介于 0 和 1 之间，即 $p \\in (0,1)$。\n\n为了生成一个“公平”比特（即，为‘1’的概率为 0.5 的比特），该工程师实现了一个通常归功于 John von Neumann 的算法：\n1.  原始比特以不重叠的连续比特对的形式被消耗：$(X_1, X_2), (X_3, X_4), (X_5, X_6), \\dots$。\n2.  每个比特对根据以下规则进行处理：\n    *   如果比特对是 $(0,1)$，算法输出一个比特‘0’并停止。\n    *   如果比特对是 $(1,0)$，算法输出一个比特‘1’并停止。\n    *   如果比特对是 $(0,0)$ 或 $(1,1)$，则丢弃该比特对，算法继续处理下一个比特对以重复该过程。\n\n该过程保证最终会生成一个输出比特。我们将这个首先生成的输出比特称为 $Y$。\n\n(a) 计算输出比特为‘1’的概率，即求 $P(Y=1)$。\n(b) 计算为了生成单个输出比特 $Y$ 所必须消耗的源序列（$X_i$）中的原始比特的期望数量。\n\n请以一个行矩阵的形式提供您的答案，其中按顺序包含 (a) 部分和 (b) 部分的符号表达式。请用 $p$ 来表示 (b) 部分的答案。", "solution": "设原始比特是独立同分布的，其中 $P(X_{i}=1)=p$ 且 $P(X_{i}=0)=1-p$，并且 $p\\in(0,1)$。考虑不相交的连续比特对 $(X_{1},X_{2}), (X_{3},X_{4}), \\dots$。由于 $X_{i}$ 的独立性和同分布性，这些比特对也是独立同分布的。\n\n对于单个比特对，其结果的概率为：\n$$\nP((1,0))=p(1-p),\\quad P((0,1))=(1-p)p,\\quad P(\\text{equal})=P((0,0))+P((1,1))=p^{2}+(1-p)^{2}.\n$$\n定义 $q=P(\\text{unequal})=P((1,0))+P((0,1))=2p(1-p)$。\n\n算法在第一个不相等的比特对处停止。令 $K$ 为这第一个不相等比特对的索引。那么 $K$ 是一个在 $\\{1,2,\\dots\\}$ 上，成功概率为 $q=2p(1-p)$ 的几何随机变量：\n$$\nP(K=k)=\\left(p^{2}+(1-p)^{2}\\right)^{k-1}\\cdot 2p(1-p).\n$$\n\n(a) 当且仅当第一个不相等的比特对是 $(1,0)$ 时，算法输出 $Y=1$。因此\n$$\nP(Y=1)=\\sum_{k=1}^{\\infty}\\left(p^{2}+(1-p)^{2}\\right)^{k-1}\\cdot p(1-p)\n= p(1-p)\\sum_{k=1}^{\\infty}\\left(p^{2}+(1-p)^{2}\\right)^{k-1}.\n$$\n这是一个公比为 $r=p^{2}+(1-p)^{2}$ 的几何级数，所以\n$$\n\\sum_{k=1}^{\\infty}r^{\\,k-1}=\\frac{1}{1-r}=\\frac{1}{1-\\left(p^{2}+(1-p)^{2}\\right)}=\\frac{1}{2p(1-p)}.\n$$\n因此，\n$$\nP(Y=1)=p(1-p)\\cdot \\frac{1}{2p(1-p)}=\\frac{1}{2}.\n$$\n\n(b) 每个处理的比特对恰好消耗 2 个原始比特。由于 $K$ 是一个成功概率为 $q=2p(1-p)$ 的几何随机变量，其期望为 $E[K]=\\frac{1}{q}=\\frac{1}{2p(1-p)}$。因此，消耗的原始比特的期望数量是\n$$\nE[\\text{bits}]=2E[K]=\\frac{2}{2p(1-p)}=\\frac{1}{p(1-p)}.\n$$\n因此，所需的表达式为 $P(Y=1)=\\frac{1}{2}$ 和 $E[\\text{bits}]=\\frac{1}{p(1-p)}$。", "answer": "$$\\boxed{\\begin{pmatrix}\\frac{1}{2} & \\frac{1}{p(1-p)}\\end{pmatrix}}$$", "id": "1392786"}]}