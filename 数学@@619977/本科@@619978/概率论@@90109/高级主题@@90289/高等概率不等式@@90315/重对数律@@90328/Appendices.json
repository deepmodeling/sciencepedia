{"hands_on_practices": [{"introduction": "第一个练习让你有机会直接应用 Hartman-Wintner 重对数律。通过计算一个具体的拉普拉斯分布的方差，并将其代入重对数律的公式中，你将练习并掌握该定理的核心计算步骤。这个过程将抽象的数学定律与一个具体的概率模型联系起来，是理论走向应用的第一步。[@problem_id:783079]", "problem": "设 $X_1, X_2, X_3, \\dots$ 为一列独立同分布（i.i.d.）的随机变量。令 $S_n = \\sum_{i=1}^n X_i$ 为这些变量的部分和。Hartman-Wintner 重对数律指出，如果随机变量的均值为 $E[X_i] = 0$ 且方差有限 $\\text{Var}(X_i) = \\sigma^2 > 0$，则\n$$\n\\limsup_{n \\to \\infty} \\frac{S_n}{\\sqrt{2n \\ln(\\ln n)}} = \\sigma\n$$\n几乎必然成立。\n\n考虑一列独立同分布的随机变量 $X_1, X_2, \\dots$ 服从尺度参数为 $b > 0$ 的中心化拉普拉斯分布。每个 $X_i$ 的概率密度函数（PDF）由下式给出：\n$$\nf(x) = \\frac{1}{2b} \\exp\\left(-\\frac{|x|}{b}\\right)\n$$\n其中 $x \\in (-\\infty, \\infty)$。\n\n根据重对数律，存在一个常数 $C$ 使得\n$$\n\\limsup_{n \\to \\infty} \\frac{S_n}{\\sqrt{n \\ln(\\ln n)}} = C\n$$\n几乎必然成立。请用参数 $b$ 推导出此常数 $C$ 的值。", "solution": "1. 对于尺度为 $b$ 的中心化拉普拉斯分布，我们有\n$$\n\\mathrm{Var}(X_i)=2b^2\\,,\\qquad \\sigma=\\sqrt{2b^2}=b\\sqrt{2}\\,. \n$$\n2. 根据 Hartman–Wintner 重对数律，\n$$\n\\limsup_{n\\to\\infty}\\frac{S_n}{\\sqrt{2n\\ln(\\ln n)}}=\\sigma\\quad\\text{a.s.}\n$$\n3. 因此\n$$\n\\limsup_{n\\to\\infty}\\frac{S_n}{\\sqrt{n\\ln(\\ln n)}}\n=\\sqrt{2}\\,\\sigma\n=\\sqrt{2}\\,(b\\sqrt{2})\n=2b\\quad\\text{a.s.}\n$$", "answer": "$$\\boxed{2b}$$", "id": "783079"}, {"introduction": "这个练习超越了简单的公式代入，旨在建立你对重对数律含义的深刻直觉。你将探索一个简单随机游走的长期行为，并找出一个关键的幂律边界指数，它精确地地区分了随机游走最终被束缚于某个区域内，还是会无限次地穿越该边界。这个问题精彩地展示了重对数律如何为随机过程的波动范围给出了一个极其精确的“包络”描述。[@problem_id:1400265]", "problem": "考虑一个一维简单对称随机游走 (SSRW)，记作 $S_n$，它从原点 $S_0 = 0$ 开始。在时间步 $n$ 的位置由和式 $S_n = \\sum_{i=1}^{n} X_i$ 给出，其中步长 $X_i$ 是独立同分布的随机变量，其概率质量函数为 $P(X_i = 1) = P(X_i = -1) = 1/2$。\n\n我们感兴趣的是将此随机游走的长期行为与一个形式为 $f(n, \\alpha) = n^{\\alpha}$ 的幂律边界进行比较，其中 $\\alpha > 0$ 是一个实值指数。根据 $\\alpha$ 的值，该游走的行为可以分为两种截然不同的情况。对于某些 $\\alpha$ 值，游走最终会被边界所包含，这意味着对于几乎每一个游走的实现，不等式 $|S_n| \\leq n^{\\alpha}$ 对所有足够大的整数 $n$ 都成立。对于另一些 $\\alpha$ 值，游走会无限次地逃离该边界，这意味着以概率一，对于无限多个 $n$ 值，有 $|S_n| > n^{\\alpha}$。\n\n存在一个临界指数 $\\alpha_c$，它标志着这两种情况之间的转换。对于任何 $\\alpha > \\alpha_c$，游走最终会被边界 $n^{\\alpha}$ 所包含。对于任何 $0 < \\alpha < \\alpha_c$，游走会无限次地逃离边界 $n^{\\alpha}$。\n\n确定此临界指数 $\\alpha_c$ 的值。", "solution": "简单对称随机游走 $S_{n}=\\sum_{i=1}^{n}X_{i}$ 具有独立增量，且 $\\mathbb{E}[X_{i}]=0$ 和 $\\mathrm{Var}(X_{i})=1$。根据 Kolmogorov 重对数律 (LIL)，几乎必然地有\n$$\n\\limsup_{n\\to\\infty}\\frac{|S_{n}|}{\\sqrt{2n\\ln(\\ln n)}}=1.\n$$\n这确定了 $S_{n}$ 的精确几乎必然涨落尺度为 $\\sqrt{n\\ln(\\ln n)}$。\n\n为了确定边界 $n^{\\alpha}$ 的临界指数 $\\alpha_{c}$，我们将 $n^{\\alpha}$ 与 LIL 尺度进行比较。\n\n1) 情况 $\\alpha>\\frac{1}{2}$。令 $\\alpha=\\frac{1}{2}+\\delta$，其中 $\\delta>0$。根据 LIL，对任意 $\\epsilon>0$，存在一个 $N_{1}$，使得对所有 $n\\geq N_{1}$，有\n$$\n|S_{n}|\\leq (1+\\epsilon)\\sqrt{2n\\ln(\\ln n)}.\n$$\n考虑比值\n$$\n\\frac{n^{\\alpha}}{\\sqrt{2n\\ln(\\ln n)}}=\\frac{n^{\\delta}}{\\sqrt{2\\ln(\\ln n)}}.\n$$\n由于 $n^{\\delta}$ 多项式地趋于 $\\infty$，而 $\\sqrt{\\ln(\\ln n)}$ 仅对数地趋于 $\\infty$，该比值趋于 $\\infty$。因此存在一个 $N_{2}$，使得对所有 $n\\geq N_{2}$，有\n$$\nn^{\\alpha}\\geq (1+\\epsilon)\\sqrt{2n\\ln(\\ln n)}.\n$$\n对于 $n\\geq \\max\\{N_{1},N_{2}\\}$，结合这两个不等式可得 $|S_{n}|\\leq n^{\\alpha}$。因此，对于 $\\alpha>\\frac{1}{2}$，该游走几乎必然地最终会被边界 $n^{\\alpha}$ 所包含。\n\n2) 情况 $0<\\alpha<\\frac{1}{2}$。令 $\\alpha=\\frac{1}{2}-\\delta$，其中 $\\delta>0$。根据 LIL，对任意 $\\epsilon\\in(0,1)$，存在无限多个 $n$ 使得\n$$\n|S_{n}|\\geq (1-\\epsilon)\\sqrt{2n\\ln(\\ln n)}.\n$$\n对这些 $n$，有\n$$\n\\frac{(1-\\epsilon)\\sqrt{2n\\ln(\\ln n)}}{n^{\\alpha}}=(1-\\epsilon)\\sqrt{2}\\,n^{\\delta}\\sqrt{\\ln(\\ln n)}\\to\\infty,\n$$\n因此对所有足够大的此类 $n$，有 $|S_{n}|>n^{\\alpha}$。因为存在无限多个这样的 $n$，所以该游走几乎必然地无限多次超越边界 $n^{\\alpha}$。\n\n3) 边界情况 $\\alpha=\\frac{1}{2}$。LIL 给出\n$$\n\\frac{|S_{n}|}{\\sqrt{n}}\\geq (1-\\epsilon)\\sqrt{2\\ln(\\ln n)}\n$$\n无限多次成立，并且由于 $\\ln(\\ln n)\\to\\infty$，这表明 $|S_{n}|>n^{1/2}$ 几乎必然地无限多次成立。因此在 $\\alpha=\\frac{1}{2}$ 时，不会最终被包含。\n\n综合这些推论，转换发生在 $\\alpha_{c}=\\frac{1}{2}$：对于 $\\alpha>\\alpha_{c}$，游走最终被包含；对于 $0<\\alpha<\\alpha_{c}$，游走会无限多次逃离。", "answer": "$$\\boxed{\\frac{1}{2}}$$", "id": "1400265"}, {"introduction": "理论的生命力在于其可被验证性。这最后一个练习让你扮演一名计算科学家的角色，挑战你设计一个算法来通过数值模拟验证重对数律。正确地设计这个算法，不仅能帮助你区分序列的极限与上极限（$\\\\limsup$）的根本区别，还能让你亲身体验如何通过编程和模拟来探索和印证抽象的数学真理。[@problem_id:1400273]", "problem": "一位计算概率学家正在研究一维简单对称随机游走的长期行为。该游走由一系列独立同分布 (i.i.d.) 的随机变量 $X_1, X_2, \\dots$ 构成，其中向右或向左移动的概率相等，即对于每个 $i$，$P(X_i = 1) = P(X_i = -1) = 1/2$。随机游走在 $n$ 步后的位置由和式 $S_n = \\sum_{i=1}^{n} X_i$ 给出，初始位置为 $S_0 = 0$。\n\n为了研究游走波动的边界，这位概率学家有兴趣计算序列 $Z_n$，其中 $n = 3, 4, \\dots, N$，$N$ 是一个大整数。序列 $Z_n$ 定义为游走归一化绝对位置的运行最大值：\n$$\nZ_n = \\max_{3 \\le k \\le n} \\frac{|S_k|}{\\sqrt{2 k \\ln(\\ln(k))}}\n$$\n这里，$\\ln$ 表示自然对数。最大值取自所有从 3 到 $n$ (含) 的整数步长 $k$。\n\n任务是设计一个高效的计算算法，对于随机游走的单条模拟路径，生成数值列表 $[Z_3, Z_4, \\dots, Z_N]$。提出了四种伪代码大纲。以下哪种算法能正确且高效地生成目标序列？\n\nA.\n1. Initialize `current_S = 0`.\n2. Initialize `results_list` as an empty list.\n3. For `k` from 1 to `N`:\n4.   Generate a random step `X` from `{-1, 1}`.\n5.   Update `current_S = current_S + X`.\n6.   If `k >= 3`:\n7.     Calculate `current_Y_k = |current_S| / sqrt(2 * k * ln(ln(k)))`.\n8.     Append `current_Y_k` to `results_list`.\n9. Return `results_list`.\n\nB.\n1. Initialize `current_S = 0` and `running_max_S = 0`.\n2. Initialize `results_list` as an empty list.\n3. For `k` from 1 to `N`:\n4.   Generate a random step `X` from `{-1, 1}`.\n5.   Update `current_S = current_S + X`.\n6.   If `k >= 3`:\n7.     Update `running_max_S = max(running_max_S, |current_S|)`.\n8.     Calculate `intermediate_Z = running_max_S / sqrt(2 * k * ln(ln(k)))`.\n9.     Append `intermediate_Z` to `results_list`.\n10. Return `results_list`.\n\nC.\n1. Initialize `current_S = 0` and `running_max_Z = 0`.\n2. Initialize `results_list` as an empty list.\n3. For `k` from 1 to `N`:\n4.   Generate a random step `X` from `{-1, 1}`.\n5.   Update `current_S = current_S + X`.\n6.   If `k >= 3`:\n7.     Calculate `current_Y_k = |current_S| / sqrt(2 * k * ln(ln(k)))`.\n8.     Update `running_max_Z = max(running_max_Z, current_Y_k)`.\n9.     Append `running_max_Z` to `results_list`.\n10. Return `results_list`.\n\nD.\n1. Initialize `current_S = 0` and `running_max_Z = 0`.\n2. Initialize `results_list` as an empty list.\n3. For `k` from 1 to `N`:\n4.   Generate a random step `X` from `{-1, 1}`.\n5.   Update `current_S = current_S + X`.\n6.   Calculate `current_Y_k = |current_S| / sqrt(2 * k * ln(ln(k)))`.\n7.   Update `running_max_Z = max(running_max_Z, current_Y_k)`.\n8.   If `k >= 3`:\n9.     Append `running_max_Z` to `results_list`.\n10. Return `results_list`.", "solution": "我们给定一个简单对称随机游走，其增量为 $X_{i} \\in \\{-1,1\\}$，独立同分布且 $P(X_{i}=1)=P(X_{i}=-1)=\\frac{1}{2}$。部分和为 $S_{n}=\\sum_{i=1}^{n}X_{i}$，且 $S_{0}=0$。对于每个 $n \\geq 3$，目标量为\n$$\nZ_{n}=\\max_{3 \\leq k \\leq n}\\frac{|S_{k}|}{\\sqrt{2k\\ln(\\ln(k))}}.\n$$\n定义 $Y_{k}=\\frac{|S_{k}|}{\\sqrt{2k\\ln(\\ln(k))}}$ （对于 $k \\geq 3$）。那么根据定义，\n$$\nZ_{n}=\\max\\{Y_{3},Y_{4},\\dots,Y_{n}\\}.\n$$\n因此，当我们按顺序模拟 $k=1,2,\\dots,N$ 的路径时，一旦 $k \\geq 3$，我们就可以从当前的 $S_{k}$ 计算出 $Y_{k}$，并用一个适当初始化的 $M_{2}$ 来更新运行最大值 $M_{k}=\\max\\{M_{k-1},Y_{k}\\}$。那么在时间 $n$ 的期望输出是 $Z_{n}=M_{n}$ (对于 $n \\geq 3$）。\n\n现在我们根据这个定义来分析每种提出的算法。\n\n算法A计算并在每个 $k \\geq 3$ 时附加 $Y_{k}$，但没有取运行最大值。因此，它生成的是序列 $[Y_{3},Y_{4},\\dots,Y_{N}]$ 而不是 $[Z_{3},Z_{4},\\dots,Z_{N}]$，其中 $Z_{n}=\\max_{3 \\leq k \\leq n}Y_{k}$。因此A不正确。\n\n算法B维护 $r=\\max_{j \\leq k}|S_{j}|$，然后构成\n$$\n\\frac{r}{\\sqrt{2k\\ln(\\ln(k))}}.\n$$\n然而，$Z_{n}=\\max_{3 \\leq k \\leq n}\\frac{|S_{k}|}{\\sqrt{2k\\ln(\\ln(k))}}$ 要求对每个 $k$ 的比率与其自身的分母 $\\sqrt{2k\\ln(\\ln(k))}$ 进行最大化。在仍使用时间 $k$ 的当前分母进行除法的同时，将 $|S_{k}|$ 替换为 $\\max_{j \\leq k}|S_{j}|$，通常不等于 $\\max_{3 \\leq j \\leq k}\\frac{|S_{j}|}{\\sqrt{2j\\ln(\\ln(j))}}$，因为使 $|S_{j}|$ 最大化的时间索引，在被随时间变化的分母缩放后，不必也使该比率最大化。因此B不正确。\n\n算法C在当前的 $k$（对于 $k \\geq 3$）计算 $Y_{k}$，更新这些比率的运行最大值，并附加该运行最大值。形式上，它为 $k \\geq 3$ 构造 $M_{k}=\\max\\{M_{k-1},Y_{k}\\}$，并在每一步 $k$ 输出 $M_{k}$。这与 $Z_{n}$ 的定义相匹配，是单次遍历，时间复杂度为 $O(N)$，额外空间复杂度为 $O(1)$，因此它是正确且高效的。\n\n算法D更新所有 $k$（包括 $k<3$）的 $Y_{k}$ 的运行最大值，并且仅在 $k \\geq 3$ 时附加结果。这有两方面的缺陷：首先，当 $k=1$ 时 $Y_{k}$ 未定义，因为 $\\ln(\\ln(1))$ 未定义；当 $k=2$ 时也有问题，因为 $\\ln(\\ln(2))<0$ 使得平方根中的分母为虚数；其次，即使忽略定义域问题，将 $k<3$ 的值纳入运行最大值中也会污染本应是 $\\max_{3 \\leq j \\leq k}Y_{j}$ 的值。因此D不正确。\n\n因此，唯一能够正确且高效地生成序列 $[Z_{3},Z_{4},\\dots,Z_{N}]$ 的算法是算法C。", "answer": "$$\\boxed{C}$$", "id": "1400273"}]}