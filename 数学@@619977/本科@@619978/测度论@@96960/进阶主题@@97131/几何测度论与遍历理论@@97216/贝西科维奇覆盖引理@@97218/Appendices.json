{"hands_on_practices": [{"introduction": "这个练习旨在让你亲身体验贪心选取算法，这是许多覆盖引理证明的核心。通过手动操作一个具体的例子，你将学习如何系统地从一个大的集合中筛选出一个有效的子覆盖，并分析其重叠特性 [@problem_id:1446802]。这个实践将为你理解这些算法的内在机制打下坚实的基础。", "problem": "考虑用取自以下有限集合 $\\mathcal{F}$ 的一个区间子集来覆盖区间 $E = [0, 1]$：\n$I_A = [-0.1, 0.2]$\n$I_B = [0.1, 0.4]$\n$I_C = [0.3, 0.6]$\n$I_D = [0.15, 0.7]$\n$I_E = [0.65, 0.8]$\n$I_F = [0.75, 1.0]$\n$I_G = [0.5, 0.9]$\n$I_H = [-0.05, 0.25]$\n\n我们将使用以下贪心算法来构建一个特定的子集，称之为 $\\mathcal{G}$：\n\n1.  初始化选定的子集 $\\mathcal{G}$ 为空集，可用区间集合 $\\mathcal{F}_{\\text{avail}}$ 为完整集合 $\\mathcal{F}$，已覆盖区域 $U$ 为空集。\n2.  当目标集 $E$ 未被已覆盖区域 $U$ 完全包含时：\n    a. 确定 $E$ 中尚未被覆盖的最小点 $x = \\inf(E \\setminus U)$。\n    b. 从 $\\mathcal{F}_{\\text{avail}}$ 中找出所有包含点 $x$ 的候选区间。\n    c. 从这组候选中，选择右端点最大的区间，我们称之为 $I_{\\text{next}}$。如果有两个或多个候选区间的右端点相同且最大，则选择其中左端点最小的那个。\n    d. 将 $I_{\\text{next}}$ 添加到子集 $\\mathcal{G}$ 中，将其从 $\\mathcal{F}_{\\text{avail}}$ 中移除，并更新已覆盖区域 $U$ 为 $U$ 与 $I_{\\text{next}}$ 的并集。\n\n在使用此过程构建了覆盖 $E = [0,1]$ 的子集 $\\mathcal{G}$ 之后，确定该覆盖的最大重数。某一点的重数是指 $\\mathcal{G}$ 中包含该点的区间的数量。最大重数是在 $\\mathbb{R}$ 中所有点上此值的最大值。\n\n最终得到的子集 $\\mathcal{G}$ 的最大重数是多少？", "solution": "问题要求计算使用特定贪心算法从给定集合 $\\mathcal{F}$ 中构建的 $E=[0,1]$ 的子覆盖 $\\mathcal{G}$ 的最大重数。我们将逐步应用该算法。\n\n初始状态为：\n- 子覆盖 $\\mathcal{G} = \\emptyset$。\n- 已覆盖区域 $U = \\emptyset$。\n- 可用区间集合为 $\\mathcal{F}_{\\text{avail}} = \\{I_A, I_B, I_C, I_D, I_E, I_F, I_G, I_H\\}$。\n$I_A = [-0.1, 0.2]$, $I_B = [0.1, 0.4]$, $I_C = [0.3, 0.6]$, $I_D = [0.15, 0.7]$, $I_E = [0.65, 0.8]$, $I_F = [0.75, 1.0]$, $I_G = [0.5, 0.9]$, $I_H = [-0.05, 0.25]$。\n\n**第 1 轮迭代：**\n- 目标集 $E=[0,1]$ 不是 $U=\\emptyset$ 的子集。\n- $E$ 中尚未被覆盖的最小点是 $x_1 = \\inf([0,1] \\setminus \\emptyset) = 0$。\n- 我们在 $\\mathcal{F}_{\\text{avail}}$ 中找出包含 $x_1=0$ 的候选区间。\n  - $I_A = [-0.1, 0.2]$ 包含 0。其右端点为 $0.2$。\n  - $I_H = [-0.05, 0.25]$ 包含 0。其右端点为 $0.25$。\n- 比较候选区间，$I_H$ 的右端点更大 ($0.25 > 0.2$)。\n- 我们选择 $I_{\\text{next}} = I_H$。\n- 更新：\n  - $\\mathcal{G} = \\{I_H\\}$。\n  - $\\mathcal{F}_{\\text{avail}} = \\mathcal{F} \\setminus \\{I_H\\}$。\n  - $U = \\emptyset \\cup [-0.05, 0.25] = [-0.05, 0.25]$。\n\n**第 2 轮迭代：**\n- $E = [0,1]$ 不是 $U = [-0.05, 0.25]$ 的子集。\n- $E$ 中尚未被覆盖的最小点是 $x_2 = \\inf([0,1] \\setminus [-0.05, 0.25]) = \\inf((0.25, 1]) = 0.25$。\n- 我们在当前的 $\\mathcal{F}_{\\text{avail}}$ 中找出包含 $x_2=0.25$ 的候选区间。\n  - $I_B = [0.1, 0.4]$ 包含 $0.25$。其右端点为 $0.4$。\n  - $I_D = [0.15, 0.7]$ 包含 $0.25$。其右端点为 $0.7$。\n- 其他可用区间（$I_A, I_C, I_E, I_F, I_G$）不包含 $0.25$。\n- 比较候选区间 $I_B$ 和 $I_D$，$I_D$ 的右端点更大 ($0.7 > 0.4$)。\n- 我们选择 $I_{\\text{next}} = I_D$。\n- 更新：\n  - $\\mathcal{G} = \\{I_H, I_D\\}$。\n  - $\\mathcal{F}_{\\text{avail}} = \\mathcal{F} \\setminus \\{I_H, I_D\\}$。\n  - $U = [-0.05, 0.25] \\cup [0.15, 0.7] = [-0.05, 0.7]$。\n\n**第 3 轮迭代：**\n- $E=[0,1]$ 不是 $U = [-0.05, 0.7]$ 的子集。\n- $E$ 中尚未被覆盖的最小点是 $x_3 = \\inf([0,1] \\setminus [-0.05, 0.7]) = \\inf((0.7, 1]) = 0.7$。\n- 我们在当前的 $\\mathcal{F}_{\\text{avail}}$ 中找出包含 $x_3=0.7$ 的候选区间。\n  - $I_E = [0.65, 0.8]$ 包含 $0.7$。其右端点为 $0.8$。\n  - $I_G = [0.5, 0.9]$ 包含 $0.7$。其右端点为 $0.9$。\n- 其他可用区间不包含 $0.7$。\n- 比较候选区间 $I_E$ 和 $I_G$，$I_G$ 的右端点更大 ($0.9 > 0.8$)。\n- 我们选择 $I_{\\text{next}} = I_G$。\n- 更新：\n  - $\\mathcal{G} = \\{I_H, I_D, I_G\\}$。\n  - $\\mathcal{F}_{\\text{avail}} = \\mathcal{F} \\setminus \\{I_H, I_D, I_G\\}$。\n  - $U = [-0.05, 0.7] \\cup [0.5, 0.9] = [-0.05, 0.9]$。\n\n**第 4 轮迭代：**\n- $E=[0,1]$ 不是 $U = [-0.05, 0.9]$ 的子集。\n- $E$ 中尚未被覆盖的最小点是 $x_4 = \\inf([0,1] \\setminus [-0.05, 0.9]) = \\inf((0.9, 1]) = 0.9$。\n- 我们在当前的 $\\mathcal{F}_{\\text{avail}}$ 中找出包含 $x_4=0.9$ 的候选区间。\n  - $I_F = [0.75, 1.0]$ 包含 $0.9$。其右端点为 $1.0$。\n- 只有一个候选区间。\n- 我们选择 $I_{\\text{next}} = I_F$。\n- 更新：\n  - $\\mathcal{G} = \\{I_H, I_D, I_G, I_F\\}$。\n  - $\\mathcal{F}_{\\text{avail}} = \\mathcal{F} \\setminus \\{I_H, I_D, I_G, I_F\\}$。\n  - $U = [-0.05, 0.9] \\cup [0.75, 1.0] = [-0.05, 1.0]$。\n\n现在，目标集 $E=[0,1]$ 已被覆盖区域 $U = [-0.05, 1.0]$ 完全包含。算法终止。\n\n选定的子集是 $\\mathcal{G} = \\{I_H, I_D, I_G, I_F\\}$，它们分别是：\n- $J_1 = I_H = [-0.05, 0.25]$\n- $J_2 = I_D = [0.15, 0.7]$\n- $J_3 = I_G = [0.5, 0.9]$\n- $J_4 = I_F = [0.75, 1.0]$\n\n现在我们必须找到这个覆盖的最大重数。我们来分析这四个区间的交集情况。\n- 单重叠或无重叠的区域：例如，区间 $[0, 0.15)$ 只在 $J_1$ 中。\n- 双重重叠的区域：\n  - $J_1 \\cap J_2 = [-0.05, 0.25] \\cap [0.15, 0.7] = [0.15, 0.25]$。此区间中的任何点都恰好在 $\\mathcal{G}$ 的两个区间内。\n  - $J_2 \\cap J_3 = [0.15, 0.7] \\cap [0.5, 0.9] = [0.5, 0.7]$。此区间中的任何点都恰好在 $\\mathcal{G}$ 的两个区间内。\n  - $J_3 \\cap J_4 = [0.5, 0.9] \\cap [0.75, 1.0] = [0.75, 0.9]$。此区间中的任何点都恰好在 $\\mathcal{G}$ 的两个区间内。\n- 我们来检查三重重叠：\n  - $J_1 \\cap J_2 \\cap J_3 = [0.15, 0.25] \\cap [0.5, 0.9] = \\emptyset$。\n  - $J_1 \\cap J_2 \\cap J_4 = [0.15, 0.25] \\cap [0.75, 1.0] = \\emptyset$。\n  - $J_1 \\cap J_3 \\cap J_4 = [-0.05, 0.25] \\cap [0.75, 0.9] = \\emptyset$。\n  - $J_2 \\cap J_3 \\cap J_4 = [0.5, 0.7] \\cap [0.75, 1.0] = \\emptyset$。\n\n因为 $\\mathcal{G}$ 中任意三个区间的交集均为空集，所以不存在包含在三个或更多区间中的点。\n因此，有公共点的区间的最大数量是 2。\n最大重数为 2。", "answer": "$$\\boxed{2}$$", "id": "1446802"}, {"introduction": "这个练习突显了算法生成解与全局最优解之间的重要区别。你将比较一个贪心策略产生的结果和一个具有绝对最小重叠数的“最佳”覆盖，这揭示了覆盖引理的一个关键思想：它们保证了重叠是有界的，但不一定是最小的，这在算法分析中是一个核心概念 [@problem_id:1446782]。", "problem": "在测度论中，像 Besicovitch 覆盖引理这样的覆盖引理为分析学提供了强大的工具。它们通常通过从一个更大的集合族中构造一个“好的”子覆盖来发挥作用，其中“好的”意味着具有有界的重叠。尽管这些构造在算法上是高效的，但它们不一定能生成具有绝对最小可能重叠度的子覆盖。寻找这样的最优子覆盖通常是一个计算上困难的组合问题。\n\n本问题探究了最优解与贪心近似之间的对比。考虑在实数轴上覆盖目标区间 $E = [0, 10]$ 的任务。给定以下闭区间的有限集族 $\\mathcal{C}$：\n- $I_A = [0, 8]$\n- $I_B = [1, 9]$\n- $I_C = [0, 2]$\n- $I_D = [2, 4]$\n- $I_E = [4, 6]$\n- $I_F = [6, 8]$\n- $I_G = [8, 10]$\n\n如果 $E \\subseteq \\bigcup_{I \\in \\mathcal{S}} I$，则子集族 $\\mathcal{S} \\subseteq \\mathcal{C}$ 是 $E$ 的一个“覆盖”。子集族 $\\mathcal{S}$ 的“重叠数”定义为 $\\mathcal{S}$ 中包含任意一个公共点的区间的最大数量，即 $\\max_{x \\in \\mathbb{R}} |\\{I \\in \\mathcal{S} \\mid x \\in I\\}|$。\n\n您需要确定两个值：\n1.  $N_{opt}$：在所有构成 $E$ 的覆盖的 $\\mathcal{C}$ 的子集族中，最小的可能重叠数。\n2.  $N_{greedy}$：由下文所述的“最长区间优先”(LIF) 贪心算法生成的特定子覆盖的重叠数。\n\n**“最长区间优先” (LIF) 贪心算法：**\n1.  创建一个包含 $\\mathcal{C}$ 中所有区间的列表 $L$，按其长度降序排序。如果长度相同，则优先选择左端点较小的区间。\n2.  将贪心子覆盖初始化为空集，$\\mathcal{S}_{greedy} = \\emptyset$。\n3.  将未覆盖点集初始化为 $U = E$。\n4.  从头到尾遍历排序后的列表 $L$。对于 $L$ 中的每个区间 $I$：\n    a. 如果 $I$ 与当前未覆盖点集 $U$ 的交集非空（即 $I \\cap U \\neq \\emptyset$），则将 $I$ 添加到 $\\mathcal{S}_{greedy}$，并通过从中移除 $I$ 中的点来更新 $U$（即 $U \\leftarrow U \\setminus I$）。\n5.  遍历完整个列表 $L$ 后，如果 $U$ 为空，则算法终止。其结果为子覆盖 $\\mathcal{S}_{greedy}$。\n\n计算 $N_{opt}$ 和 $N_{greedy}$ 的值。您的最终答案应为整数对 $(N_{opt}, N_{greedy})$。", "solution": "我们首先确定在使用 $\\mathcal{C}$ 的子集族构成的所有 $E=[0,10]$ 的覆盖中，最小的可能重叠数。\n\n要使重叠数为 $1$，每个点 $x$ 最多只能属于一个选定的区间。由于 $\\mathcal{C}$ 中没有单个区间能覆盖 $[0,10]$，任何覆盖都必须使用至少两个区间。为了用闭区间覆盖连通集 $[0,10]$，区间的并集必须包含 $[0,10]$。如果区间的内部互不相交，它们的并集将是不连通的（除非它们能完美地拼接起来，但这在此处不可能）。因此，区间的内部必须重叠，这意味着重叠数至少为 2。因此任何覆盖都满足 $N \\ge 2$。\n\n存在一个能达到重叠数 $2$ 的覆盖，例如：\n$$\n\\{I_{A},I_{G}\\}=\\{[0,8],[8,10]\\}\n$$\n其重叠数为 $2$（最大重叠发生在 $x=8$ 处）。因此，\n$$\nN_{opt}=2\n$$\n\n接下来，我们计算由 LIF 贪心算法产生的重叠数。\n\n步骤 1：按长度降序排序，长度相同时按左端点从小到大排序。各区间的长度为\n$|I_{A}|=8$, $|I_{B}|=8$, $|I_{C}|=|I_{D}|=|I_{E}|=|I_{F}|=|I_{G}|=2$。\n所以排序后的列表为\n$L=(I_{A},I_{B},I_{C},I_{D},I_{E},I_{F},I_{G})=( [0,8],[1,9],[0,2],[2,4],[4,6],[6,8],[8,10] )$。\n\n初始化 $\\mathcal{S}_{greedy}=\\emptyset$ 和 $U=[0,10]$。\n\n处理 $I_{A}=[0,8]$：由于 $I_{A}\\cap U\\neq\\emptyset$，添加 $I_{A}$。更新\n$U\\leftarrow U\\setminus I_{A}=[0,10]\\setminus[0,8]=(8,10]$。\n\n处理 $I_{B}=[1,9]$：$I_{B}\\cap U=(8,9]\\neq\\emptyset$，所以添加 $I_{B}$。更新\n$U\\leftarrow U\\setminus I_{B}=(8,10]\\setminus[1,9]=(9,10]$。\n\n处理 $I_{C},I_{D},I_{E},I_{F}$：它们与 $(9,10]$ 的交集均为空，所以跳过。\n\n处理 $I_{G}=[8,10]$：$I_{G}\\cap U=(9,10]\\neq\\emptyset$，所以添加 $I_{G}$。更新\n$U\\leftarrow U\\setminus I_{G}=(9,10]\\setminus[8,10]=\\emptyset$。\n因此 $\\mathcal{S}_{greedy}=\\{I_{A},I_{B},I_{G}\\}$。\n\n计算其重叠数。对于 $x\\in[1,8)$，$I_{A}$ 和 $I_{B}$ 都包含 $x$（重叠数为 2）。对于 $x\\in(8,9]$，$I_{B}$ 和 $I_{G}$ 都包含 $x$（重叠数为 2）。在 $x=8$ 处，所有三个区间都包含 $8$，因此重叠数为\n$\\max_{x}|\\{I\\in\\mathcal{S}_{greedy}\\mid x\\in I\\}|=3$。\n因此，\n$N_{greedy}=3$。\n\n综上所述，我们得到\n$N_{opt}=2$，$N_{greedy}=3$。", "answer": "$$\\boxed{(2, 3)}$$", "id": "1446782"}, {"introduction": "这个练习从计算转向了概念推理，旨在检验你对 Besicovitch 覆盖引理核心精髓的理解。问题设计的目的不是让你运行一个算法，而是让你运用引理中“有界重叠”这一关键保证来进行逻辑推导 [@problem_id:1446847]。通过这个思想实验，你将看到一个抽象的数学性质如何在一个具体场景中导出强有力的结论。", "problem": "在 $\\mathbb{R}^n$ 的测度论中，一个以 $x$ 为中心、半径为 $r  0$ 的闭球记为 $\\bar{B}(x, r) = \\{ y \\in \\mathbb{R}^n \\mid \\|y - x\\| \\le r \\}$。\n\nBesicovitch 覆盖引理为处理球族提供了一个强大的工具。其内容如下：令 $A$ 为 $\\mathbb{R}^n$ 的一个有界子集。令 $\\mathcal{F}$ 为一个闭球族，使得 $A$ 中的每个点 $x \\in A$ 都是 $\\mathcal{F}$ 中某个球的中心。那么，存在一个子族 $\\mathcal{G} \\subseteq \\mathcal{F}$ 满足：\n1.  子族 $\\mathcal{G}$ 覆盖集合 $A$，即 $A \\subseteq \\bigcup_{B \\in \\mathcal{G}} B$。\n2.  子族 $\\mathcal{G}$ 具有有界重叠。这意味着存在一个仅依赖于维度 $n$ 的整数常数 $N(n)$，使得 $\\mathbb{R}^n$ 中的任意点 $p$ 至多被 $\\mathcal{G}$ 中的 $N(n)$ 个球所包含。\n\n现在，考虑 $\\mathbb{R}^n$ 中的一个特定情形。令 $E$ 是一个仅包含单个点的集合，$E = \\{x_0\\}$。令 $\\mathcal{F}$ 为如下给出的无穷闭球族：\n$$ \\mathcal{F} = \\{ \\bar{B}(x_0, 1/k) \\mid k = 1, 2, 3, \\dots \\} $$\n注意，$E$ 中的每个点（即 $x_0$ 本身）都是 $\\mathcal{F}$ 中球的中心。令 $\\mathcal{G}$ 是 $\\mathcal{F}$ 的一个子族，其存在性由 Besicovitch 覆盖引理对集合 $E$ 和球族 $\\mathcal{F}$ 保证。\n\n对于任意这样的子族 $\\mathcal{G}$，下列哪个陈述必定为真？\n\nA. $\\mathcal{G}$ 必须是整个原始族 $\\mathcal{F}$。\nB. $\\mathcal{G}$ 必须是 $\\mathcal{F}$ 的一个无穷子族。\nC. $\\mathcal{G}$ 必须是 $\\mathcal{F}$ 的一个非空有限子族。\nD. $\\mathcal{G}$ 必须只包含一个球，即 $\\bar{B}(x_0, 1)$。\nE. $\\mathcal{G}$ 必须是空集。", "solution": "给定 $E=\\{x_{0}\\}\\subset \\mathbb{R}^{n}$ 和 $\\mathcal{F}=\\{\\bar{B}(x_{0},1/k):k\\in\\mathbb{N}\\}$，其中 $\\mathcal{F}$ 中的每个球都包含 $x_{0}$。Besicovitch 覆盖引理保证存在一个子族 $\\mathcal{G}\\subseteq\\mathcal{F}$ 满足：\n1) $E\\subseteq\\bigcup_{B\\in\\mathcal{G}}B$，并且\n2) 存在一个整数 $N(n)$，使得对于每个 $p\\in\\mathbb{R}^{n}$，都有\n$$\n\\#\\{B\\in\\mathcal{G}:p\\in B\\}\\leq N(n)\n$$\n\n首先，覆盖条件要求 $\\mathcal{G}$ 必须非空。事实上，由于 $E=\\{x_{0}\\}$ 且 $\\mathcal{F}$ 中的每个球 $B$ 都包含 $x_{0}$，我们有 $x_{0}\\in\\bigcup_{B\\in\\mathcal{G}}B$ 当且仅当 $\\mathcal{G}\\neq\\varnothing$。因此，选项 E 是不可能的，任何有效的 $\\mathcal{G}$ 都必须是非空的。\n\n其次，考虑在点 $p=x_{0}$ 处的有界重叠条件。每个球 $B=\\bar{B}(x_{0},1/k)$ 都包含 $x_{0}$。因此，对于任何子族 $\\mathcal{G}\\subseteq\\mathcal{F}$，有\n$$\n\\#\\{B\\in\\mathcal{G}:x_{0}\\in B\\}=\\#\\mathcal{G}\n$$\n如果 $\\mathcal{G}$ 是无穷的，那么上式左侧将为无穷大，这不可能被任何有限整数 $N(n)$ 作为上界。这与有界重叠的要求相矛盾。因此，任何满足引理条件的子族 $\\mathcal{G}$ 都必须是有限的。\n\n综合这两个结论，任何有效的 $\\mathcal{G}$ 都必须是一个非空有限子族。它不必是整个球族（因此 A 是错误的），它不能是无穷的（因此 B 是错误的），它也不必特地是 $\\{\\bar{B}(x_{0},1)\\}$，因为任何单个球 $\\{\\bar{B}(x_{0},1/k)\\}$ 都足以满足条件（因此 D 是错误的），并且它不能为空（因此 E 是错误的）。唯一必须成立的陈述是 $\\mathcal{G}$ 是一个非空有限子族，即 C。", "answer": "$$\\boxed{C}$$", "id": "1446847"}]}