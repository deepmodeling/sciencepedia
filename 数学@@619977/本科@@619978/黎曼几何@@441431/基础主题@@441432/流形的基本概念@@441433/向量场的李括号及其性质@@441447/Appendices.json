{"hands_on_practices": [{"introduction": "要真正掌握李括号，最好的起点莫过于亲手进行一次直接计算。这个练习将引导你使用李括号最根本的定义——作为光滑函数上导数的交换子——来计算$\\mathbb{R}^2$上两个具体向量场的李括号。通过将李括号作用于坐标函数$x$和$y$，你将能揭示其结果向量场的分量，从而将抽象的定义转化为具体的计算方法。[@problem_id:3073904]", "problem": "设 $M=\\mathbb{R}^{2}$ 具有其标准光滑结构和标准坐标标架 $\\{\\partial_{x},\\partial_{y}\\}$。考虑 $M$ 上的光滑向量场 $X$ 和 $Y$，由 $X=x^{2}\\,\\partial_{x}+x y\\,\\partial_{y}$ 和 $Y=y\\,\\partial_{x}+x\\,\\partial_{y}$ 给出。仅使用向量场李括号作为光滑函数上导子的交换子的定义，即对于任意光滑函数 $f$ 有 $[X,Y](f)=X\\big(Y(f)\\big)-Y\\big(X(f)\\big)$，计算 $[X,Y]$ 关于标架 $\\{\\partial_{x},\\partial_{y}\\}$ 的坐标表达式。然后，根据您的计算，确定 $X$ 和 $Y$ 是否在整个 $M$ 上交换。\n\n将 $[X,Y]$ 的分量函数对按 $(\\partial_{x},\\partial_{y})$ 的顺序，以单行矩阵的形式作为最终答案给出。无需数值近似。", "solution": "我们从向量场李括号作为光滑函数上导子的交换子的定义开始：对于任意光滑函数 $f$，李括号定义为 $[X,Y](f)=X\\big(Y(f)\\big)-Y\\big(X(f)\\big)$。为了确定向量场 $Z=A\\,\\partial_{x}+B\\,\\partial_{y}$ 在标架 $\\{\\partial_{x},\\partial_{y}\\}$ 中的坐标分量，只需在坐标函数 $x$ 和 $y$ 上计算 $Z$ 即可，因为根据 $\\partial_{x}(x)=1$、$\\partial_{y}(x)=0$、$\\partial_{x}(y)=0$ 和 $\\partial_{y}(y)=1$ 这些事实，可以得出 $Z(x)=A$ 和 $Z(y)=B$。\n\n我们将此应用于 $[X,Y]$。首先计算 $[X,Y](x)$：\n- 计算 $Y(x)$。使用 $Y=y\\,\\partial_{x}+x\\,\\partial_{y}$ 以及 $\\partial_{x}(x)=1$, $\\partial_{y}(x)=0$，我们得到 $Y(x)=y\\cdot 1+x\\cdot 0=y$。\n- 然后计算 $X\\big(Y(x)\\big)=X(y)$。使用 $X=x^{2}\\,\\partial_{x}+x y\\,\\partial_{y}$ 以及 $\\partial_{x}(y)=0$, $\\partial_{y}(y)=1$，我们得到 $X(y)=x^{2}\\cdot 0+x y\\cdot 1=x y$。\n- 接着计算 $X(x)$。使用 $\\partial_{x}(x)=1$, $\\partial_{y}(x)=0$，我们发现 $X(x)=x^{2}\\cdot 1+x y\\cdot 0=x^{2}$。\n- 然后计算 $Y\\big(X(x)\\big)=Y(x^{2})$。使用 $Y=y\\,\\partial_{x}+x\\,\\partial_{y}$ 以及 $\\partial_{x}(x^{2})=2x$, $\\partial_{y}(x^{2})=0$，我们得到 $Y(x^{2})=y\\cdot 2x+x\\cdot 0=2 x y$。\n因此，\n$$\n[X,Y](x)=X\\big(Y(x)\\big)-Y\\big(X(x)\\big)=x y-2 x y=-x y.\n$$\n所以 $[X,Y]$ 的 $\\partial_{x}$-分量是 $-x y$。\n\n接下来计算 $[X,Y](y)$：\n- 计算 $Y(y)$。使用 $\\partial_{x}(y)=0$, $\\partial_{y}(y)=1$，我们发现 $Y(y)=y\\cdot 0+x\\cdot 1=x$。\n- 那么 $X\\big(Y(y)\\big)=X(x)$。从上面可知，$X(x)=x^{2}$。\n- 计算 $X(y)$。从上面可知，$X(y)=x y$。\n- 然后计算 $Y\\big(X(y)\\big)=Y(x y)$。使用导子的乘法法则，或直接通过坐标计算，注意到 $\\partial_{x}(x y)=y$ 和 $\\partial_{y}(x y)=x$，所以 $Y(x y)=y\\cdot y+x\\cdot x=y^{2}+x^{2}$。\n因此，\n$$\n[X,Y](y)=X\\big(Y(y)\\big)-Y\\big(X(y)\\big)=x^{2}-(y^{2}+x^{2})=-y^{2}.\n$$\n所以 $[X,Y]$ 的 $\\partial_{y}$-分量是 $-y^{2}$。\n\n收集各分量，我们得到\n$$\n[X,Y]=-x y\\,\\partial_{x}-y^{2}\\,\\partial_{y}.\n$$\n这个向量场在 $\\mathbb{R}^{2}$ 上不是零向量场，例如，在任何 $y\\neq 0$ 的点上它都是非零的。因此，向量场 $X$ 和 $Y$ 在整个 $M$ 上不是交换的。\n\n所要求的 $[X,Y]$ 按 $(\\partial_{x},\\partial_{y})$ 顺序的坐标分量是 $(-x y,\\,-y^{2})$。", "answer": "$$\\boxed{\\begin{pmatrix}-xy  -y^2\\end{pmatrix}}$$", "id": "3073904"}, {"introduction": "在掌握了基本计算之后，让我们将视野从欧氏空间扩展到更广泛的几何结构中。这个练习探讨了$n$维环面$T^n$上的左不变向量场，这是一个紧致李群的典型例子。通过计算这些具有常系数的特殊向量场的李括号，你会发现一个深刻的联系：李括号为零的计算结果直接反映了环面作为一个阿贝尔群（交换群）的内在代数结构。[@problem_id:3073919]", "problem": "设 $T^n$ 表示 $n$ 维环面，实现为 $(\\mathbb{R}/2\\pi \\mathbb{Z})^n$，其全局角坐标为 $(\\theta^1,\\dots,\\theta^n)$，其中角度以弧度为单位。考虑 $T^n$ 上的群结构，该结构由模 $2\\pi$ 的分量加法给出，因此 $T^n$ 是一个紧李群。为 $T^n$ 配备一个黎曼度量 $g$，该度量由全局坐标标架 $\\left\\{\\frac{\\partial}{\\partial \\theta^1},\\dots,\\frac{\\partial}{\\partial \\theta^n}\\right\\}$ 中的一个常数、对称、正定矩阵 $G$ 指定，使得在每一点上都有 $g\\left(\\frac{\\partial}{\\partial \\theta^i},\\frac{\\partial}{\\partial \\theta^j}\\right)=G_{ij}$。\n\n如果一个 $T^n$ 上的向量场 $X$ 在群结构中的左平移前推下保持不变，则称其为左不变向量场。在这些全局坐标中，一个左不变向量场具有常系数，可以写成 $X=\\sum_{i=1}^n a_i \\frac{\\partial}{\\partial \\theta^i}$，其中 $a_1,\\dots,a_n\\in\\mathbb{R}$ 为常数。类似地，设 $Y=\\sum_{j=1}^n b_j \\frac{\\partial}{\\partial \\theta^j}$ 是另一个左不变向量场，其中 $b_1,\\dots,b_n\\in\\mathbb{R}$ 为常数。\n\n仅使用基本定义和法则，除了李括号的定义外不援引任何现成的恒等式，通过在任意光滑函数 $f:T^n\\to\\mathbb{R}$ 上计算 $[X,Y](f)$ 来计算作为向量场的李括号 $[X,Y]$。你的推导应从向量场李括号 $[X,Y]$ 的定义和光滑函数上偏导数的标准性质开始。判断 $[X,Y]$ 是否为零，并解释为什么这反映了 $T^n$ 的李代数的结构。\n\n将你的最终答案表示为 $[X,Y]$ 在全局坐标标架中的单个解析表达式。", "solution": "两个向量场 $X$ 和 $Y$ 的李括号是第三个向量场 $[X,Y]$，其定义为其在任意光滑函数 $f \\in C^\\infty(T^n)$ 上的作用。定义如下：\n$$[X,Y](f) = X(Y(f)) - Y(X(f))$$\n这里，$X(f)$ 表示 $f$ 沿着向量场 $X$ 的方向导数。\n\n给定的向量场在全局坐标基 $\\left\\{\\frac{\\partial}{\\partial \\theta^k}\\right\\}_{k=1}^n$ 中表示为：\n$$X = \\sum_{i=1}^n a_i \\frac{\\partial}{\\partial \\theta^i}$$\n$$Y = \\sum_{j=1}^n b_j \\frac{\\partial}{\\partial \\theta^j}$$\n其中系数 $a_i$ 和 $b_j$ 对于所有 $i, j \\in \\{1, \\dots, n\\}$ 都是实常数。\n\n首先，我们计算 $Y$ 在 $f$ 上的作用。根据向量场作用于函数的定义：\n$$Y(f) = \\left(\\sum_{j=1}^n b_j \\frac{\\partial}{\\partial \\theta^j}\\right)(f) = \\sum_{j=1}^n b_j \\frac{\\partial f}{\\partial \\theta^j}$$\n这个结果是 $T^n$ 上的一个新的光滑函数。\n\n接下来，我们将向量场 $X$ 应用于函数 $Y(f)$：\n$$X(Y(f)) = X\\left(\\sum_{j=1}^n b_j \\frac{\\partial f}{\\partial \\theta^j}\\right) = \\left(\\sum_{i=1}^n a_i \\frac{\\partial}{\\partial \\theta^i}\\right)\\left(\\sum_{j=1}^n b_j \\frac{\\partial f}{\\partial \\theta^j}\\right)$$\n由于偏导数算子 $\\frac{\\partial}{\\partial \\theta^i}$ 是线性的，且系数 $a_i$ 和 $b_j$ 是常数，我们可以分配这些算子：\n$$X(Y(f)) = \\sum_{i=1}^n \\sum_{j=1}^n a_i b_j \\frac{\\partial}{\\partial \\theta^i}\\left(\\frac{\\partial f}{\\partial \\theta^j}\\right) = \\sum_{i=1}^n \\sum_{j=1}^n a_i b_j \\frac{\\partial^2 f}{\\partial \\theta^i \\partial \\theta^j}$$\n\n现在，我们以对称的方式计算第二项 $Y(X(f))$。首先，我们计算 $X(f)$：\n$$X(f) = \\left(\\sum_{i=1}^n a_i \\frac{\\partial}{\\partial \\theta^i}\\right)(f) = \\sum_{i=1}^n a_i \\frac{\\partial f}{\\partial \\theta^i}$$\n\n然后，我们将 $Y$ 应用于函数 $X(f)$：\n$$Y(X(f)) = Y\\left(\\sum_{i=1}^n a_i \\frac{\\partial f}{\\partial \\theta^i}\\right) = \\left(\\sum_{j=1}^n b_j \\frac{\\partial}{\\partial \\theta^j}\\right)\\left(\\sum_{i=1}^n a_i \\frac{\\partial f}{\\partial \\theta^i}\\right)$$\n再次，利用线性和系数为常数的事实：\n$$Y(X(f)) = \\sum_{j=1}^n \\sum_{i=1}^n b_j a_i \\frac{\\partial}{\\partial \\theta^j}\\left(\\frac{\\partial f}{\\partial \\theta^i}\\right) = \\sum_{i=1}^n \\sum_{j=1}^n a_i b_j \\frac{\\partial^2 f}{\\partial \\theta^j \\partial \\theta^i}$$\n\n现在我们将这两个结果代入李括号的定义中：\n$$[X,Y](f) = \\sum_{i=1}^n \\sum_{j=1}^n a_i b_j \\frac{\\partial^2 f}{\\partial \\theta^i \\partial \\theta^j} - \\sum_{i=1}^n \\sum_{j=1}^n a_i b_j \\frac{\\partial^2 f}{\\partial \\theta^j \\partial \\theta^i}$$\n$$[X,Y](f) = \\sum_{i=1}^n \\sum_{j=1}^n a_i b_j \\left( \\frac{\\partial^2 f}{\\partial \\theta^i \\partial \\theta^j} - \\frac{\\partial^2 f}{\\partial \\theta^j \\partial \\theta^i} \\right)$$\n因为 $f$ 是一个光滑函数（$C^\\infty$ 类，当然至少是 $C^2$ 类），关于二阶偏导数对称性的克莱罗定理(Clairaut's theorem)成立。该定理指出，对于一个具有连续二阶偏导数的函数，微分的顺序无关紧要：\n$$\\frac{\\partial^2 f}{\\partial \\theta^i \\partial \\theta^j} = \\frac{\\partial^2 f}{\\partial \\theta^j \\partial \\theta^i}$$\n因此，对于所有的 $i$ 和 $j$，括号中的项都为零：\n$$\\frac{\\partial^2 f}{\\partial \\theta^i \\partial \\theta^j} - \\frac{\\partial^2 f}{\\partial \\theta^j \\partial \\theta^i} = 0$$\n这导致了括号作用于 $f$ 的最终结果：\n$$[X,Y](f) = \\sum_{i=1}^n \\sum_{j=1}^n a_i b_j (0) = 0$$\n因为对于 $T^n$ 上的任意光滑函数 $f$，都有 $[X,Y](f) = 0$，所以向量场 $[X,Y]$ 必定是零向量场。\n$$[X,Y] = 0$$\n\n**解释**\n一个李群 $G$ 上所有左不变向量场的集合构成一个向量空间，该空间与单位元处的切空间 $T_e G$ 同构。这个向量空间在被赋予李括号运算后，被定义为该群的李代数，记作 $\\mathfrak{g}$。\n\n我们的计算表明，对于环面 $T^n$ 上的任意两个左不变向量场 $X$ 和 $Y$，它们的李括号是零向量场：$[X,Y] = 0$。这意味着 $T^n$ 的李代数（记作 $\\mathfrak{t}^n$）是一个阿贝尔李代数。这个结果是底层群结构的直接反映。李群 $T^n$ 是一个阿贝尔（交换）群，因为它的运算是分量加法，而分量加法是可交换的。李群理论中的一个基本定理指出，一个李群是阿贝尔群当且仅当其李代数是阿贝尔的。我们所做的计算是对 $n$ 维环面这一特定情况对此原理的显式验证。在一个坐标图中，具有常系数的向量场相互交换，这是一个一般性的结果，而在本例中，$T^n$ 上的全局坐标图使得这一性质可以推广到所有左不变场。", "answer": "$$\\boxed{0}$$", "id": "3073919"}, {"introduction": "理论学习的最终目的是应用于实践，而现代科学计算为此提供了强有力的工具。本练习旨在连接理论推导与计算验证，你将首先推导出李括号在任意坐标系下的通用分量表达式，这是一个至关重要的理论成果。随后，你将通过编写程序，利用这个公式来数值验证李括号的双线性和反交换性等基本代数性质，这些性质正是定义李代数结构的基石。[@problem_id:2987430]", "problem": "您需要从第一性原理出发，实现欧几里得空间上光滑向量场的李括号的坐标计算，并数值验证其定义的代数性质。在具有全局笛卡尔坐标的光滑流形 $\\mathbb{R}^{n}$ 的框架下进行全部工作。$\\mathbb{R}^{n}$ 上的光滑向量场 $X$ 为每个点 $p \\in \\mathbb{R}^{n}$ 指定一个切向量 $X(p) \\in T_{p}\\mathbb{R}^{n} \\cong \\mathbb{R}^{n}$，并通过 $X(f)$ 的形式作为导子作用于光滑函数 $f \\colon \\mathbb{R}^{n} \\to \\mathbb{R}$。两个光滑向量场 $X$ 和 $Y$ 的李括号 $[X,Y]$ 定义为导子的交换子，即对于任意光滑函数 $f$，有 $[X,Y](f) \\coloneqq X(Y(f)) - Y(X(f))$。从这些核心定义和 $\\mathbb{R}^{n}$ 上的标准坐标基出发，推导 $[X,Y]$ 的坐标表达式，并实现一个数值程序，用于在 $\\mathbb{R}^{n}$ 中的指定点上对其求值。\n\n您的程序必须：\n- 用标准坐标下具有多项式系数的分量函数来表示 $\\mathbb{R}^{n}$ 上的向量场 $X$。\n- 使用您选择的、与数据光滑性相符的有限差分格式，数值计算分量函数的偏导数。\n- 使用推导出的李括号 $[X,Y]$ 的坐标表达式，在给定的点 $p \\in \\mathbb{R}^{n}$ 上计算 $[X,Y](p)$。\n- 在固定的测试集上，在指定的容差范围内，数值验证李括号对每个参数的双线性和反对称性。\n\n使用以下固定的测试集，您必须完全按照说明实现：\n\n- 维度：$n = 3$。\n- 求值点：$p_{1} = (0,0,0)$，$p_{2} = (1,-1,2)$，$p_{3} = \\left(\\tfrac{1}{2}, -2, 1\\right)$。\n- $\\mathbb{R}^{3}$ 上的向量场：\n  - $X(x,y,z) = \\big(x^{2} y,\\,-y z,\\, x + 2\\big)$。\n  - $Y(x,y,z) = \\big(y^{2},\\, x z,\\, -x y\\big)$。\n  - $Z(x,y,z) = \\big(1,\\, x,\\, z^{2}\\big)$。\n  - 零向量场 $O(x,y,z) = (0,0,0)$。\n- 实标量：$a = 2$, $b = -3$。\n- 有限差分步长：$h = 10^{-6}$。\n- 数值相等的容差：$\\varepsilon = 10^{-9}$。\n\n使用这些数据，您的程序必须计算以下五种情况的布尔结果，每种情况都解释为在所有三个求值点 $p_{1}, p_{2}, p_{3}$ 上的统一界，使用分量上的最大绝对差值进行判断：\n1. 反对称性：验证在每个求值点上，$[X,Y] + [Y,X]$ 在容差 $\\varepsilon$ 内等于零向量场。\n2. 第一参数的双线性：验证在每个求值点上，$[a X + b Y, Z]$ 在容差 $\\varepsilon$ 内等于 $a[X,Z] + b[Y,Z]$。\n3. 第二参数的双线性：验证在每个求值点上，$[X, a Y + b Z]$ 在容差 $\\varepsilon$ 内等于 $a[X,Y] + b[X,Z]$。\n4. 零向量场：验证在每个求值点上，$[O, Y]$ 在容差 $\\varepsilon$ 内等于零向量场。\n5. 相同向量场：验证在每个求值点上，$[X, X]$ 在容差 $\\varepsilon$ 内等于零向量场。\n\n您的程序应生成单行输出，其中包含测试 1 到 5 的结果，结果为逗号分隔的列表，并用方括号括起来。例如，输出格式必须与 $[r_{1},r_{2},r_{3},r_{4},r_{5}]$ 完全一样，其中每个 $r_k$ 是字面量 $True$ 或 $False$。此问题不涉及任何物理单位或角度单位，也不需要百分比。所有计算必须是自包含的，且不需要用户输入。", "solution": "该问题是有效的，因为它是一个基于微分几何基本原理的、适定且自包含的数学练习。我们的任务是推导欧几里得空间上向量场李括号的坐标表达式，进行数值实现，并验证其核心代数性质。\n\n### 李括号坐标表达式的推导\n\n设背景为具有全局笛卡尔坐标 $(x^1, x^2, \\ldots, x^n)$ 的光滑流形 $\\mathbb{R}^{n}$。任意点的切空间的标准基为 $\\{\\frac{\\partial}{\\partial x^1}, \\frac{\\partial}{\\partial x^2}, \\ldots, \\frac{\\partial}{\\partial x^n}\\}$。一个光滑向量场 $X$ 可以写成这些基向量的线性组合，其系数为光滑分量函数 $X^i \\colon \\mathbb{R}^{n} \\to \\mathbb{R}$：\n$$\nX = \\sum_{i=1}^{n} X^i(x^1, \\ldots, x^n) \\frac{\\partial}{\\partial x^i}\n$$\n向量场 $X$ 作用于光滑函数 $f \\colon \\mathbb{R}^{n} \\to \\mathbb{R}$ 的结果，记为 $X(f)$，是 $f$ 沿着 $X$ 的方向导数：\n$$\nX(f) = \\sum_{i=1}^{n} X^i \\frac{\\partial f}{\\partial x^i}\n$$\n两个光滑向量场 $X$ 和 $Y$ 的李括号 $[X,Y]$ 是通过其对任意光滑函数 $f$ 的作用来定义的，即作为导子 $X$ 和 $Y$ 的交换子：\n$$\n[X,Y](f) \\coloneqq X(Y(f)) - Y(X(f))\n$$\n为了找到向量场 $[X,Y]$ 的分量，我们展开此定义。设 $X = \\sum_i X^i \\frac{\\partial}{\\partial x^i}$ 和 $Y = \\sum_j Y^j \\frac{\\partial}{\\partial x^j}$。\n\n首先，我们计算 $X(Y(f))$：\n$$\nY(f) = \\sum_{j=1}^{n} Y^j \\frac{\\partial f}{\\partial x^j}\n$$\n因为 $Y^j$ 和 $\\frac{\\partial f}{\\partial x^j}$ 都是光滑函数，所以 $Y(f)$ 也是一个光滑函数。现在我们将 $X$ 作用于这个函数：\n$$\nX(Y(f)) = X\\left( \\sum_{j=1}^{n} Y^j \\frac{\\partial f}{\\partial x^j} \\right) = \\sum_{i=1}^{n} X^i \\frac{\\partial}{\\partial x^i} \\left( \\sum_{j=1}^{n} Y^j \\frac{\\partial f}{\\partial x^j} \\right)\n$$\n使用导数的乘法法则 $\\frac{\\partial}{\\partial x^i}(ab) = (\\frac{\\partial a}{\\partial x^i})b + a(\\frac{\\partial b}{\\partial x^i})$，我们得到：\n$$\nX(Y(f)) = \\sum_{i=1}^{n} \\sum_{j=1}^{n} X^i \\left( \\frac{\\partial Y^j}{\\partial x^i} \\frac{\\partial f}{\\partial x^j} + Y^j \\frac{\\partial^2 f}{\\partial x^i \\partial x^j} \\right)\n$$\n$$\nX(Y(f)) = \\sum_{j=1}^{n} \\left( \\sum_{i=1}^{n} X^i \\frac{\\partial Y^j}{\\partial x^i} \\right) \\frac{\\partial f}{\\partial x^j} + \\sum_{i,j=1}^{n} X^i Y^j \\frac{\\partial^2 f}{\\partial x^i \\partial x^j}\n$$\n通过对称性，我们可以通过交换 $X$ 和 $Y$ 的角色以及下标 $i$ 和 $j$ 来得到 $Y(X(f))$：\n$$\nY(X(f)) = \\sum_{j=1}^{n} \\left( \\sum_{i=1}^{n} Y^i \\frac{\\partial X^j}{\\partial x^i} \\right) \\frac{\\partial f}{\\partial x^j} + \\sum_{i,j=1}^{n} Y^i X^j \\frac{\\partial^2 f}{\\partial x^i \\partial x^j}\n$$\n现在，我们计算交换子 $[X,Y](f) = X(Y(f)) - Y(X(f))$。涉及 $f$ 的二阶导数的项是：\n$$\n\\sum_{i,j=1}^{n} X^i Y^j \\frac{\\partial^2 f}{\\partial x^i \\partial x^j} - \\sum_{i,j=1}^{n} Y^i X^j \\frac{\\partial^2 f}{\\partial x^i \\partial x^j}\n$$\n由于 $f$ 是光滑的，其混合偏导数相等 (克莱罗定理)：$\\frac{\\partial^2 f}{\\partial x^i \\partial x^j} = \\frac{\\partial^2 f}{\\partial x^j \\partial x^i}$。通过在第二项中重新标记求和下标 ($i \\leftrightarrow j$)，它变为 $\\sum_{j,i=1}^{n} Y^j X^i \\frac{\\partial^2 f}{\\partial x^j \\partial x^i} = \\sum_{i,j=1}^{n} X^i Y^j \\frac{\\partial^2 f}{\\partial x^i \\partial x^j}$。因此，二阶导数项相互抵消。\n\n剩下的项给出：\n$$\n[X,Y](f) = \\sum_{j=1}^{n} \\left( \\sum_{i=1}^{n} X^i \\frac{\\partial Y^j}{\\partial x^i} \\right) \\frac{\\partial f}{\\partial x^j} - \\sum_{j=1}^{n} \\left( \\sum_{i=1}^{n} Y^i \\frac{\\partial X^j}{\\partial x^i} \\right) \\frac{\\partial f}{\\partial x^j}\n$$\n$$\n[X,Y](f) = \\sum_{j=1}^{n} \\left( \\sum_{i=1}^{n} \\left( X^i \\frac{\\partial Y^j}{\\partial x^i} - Y^i \\frac{\\partial X^j}{\\partial x^i} \\right) \\right) \\frac{\\partial f}{\\partial x^j}\n$$\n此表达式的形式为 $\\sum_j Z^j \\frac{\\partial f}{\\partial x^j}$，这表明 $[X,Y]$ 确实是一个向量场。$[X,Y]$ 的第 $j$ 个分量，记为 $([X,Y])^j$，是：\n$$\n([X,Y])^j = \\sum_{i=1}^{n} \\left( X^i \\frac{\\partial Y^j}{\\partial x^i} - Y^i \\frac{\\partial X^j}{\\partial x^i} \\right)\n$$\n这可以用向量场的雅可比矩阵紧凑地表示。设 $X$ 和 $Y$ 表示为其分量函数的列向量。设 $J_X$ 和 $J_Y$ 为它们的雅可比矩阵，其中 $(J_V)_{ji} = \\frac{\\partial V^j}{\\partial x^i}$。表达式 $\\sum_i X^i \\frac{\\partial Y^j}{\\partial x^i}$ 是矩阵-向量乘积 $J_Y X$ 的第 $j$ 个分量。因此，向量 $[X,Y]$ 由下式给出：\n$$\n[X,Y] = J_Y X - J_X Y\n$$\n这就是我们将要实现的坐标公式。\n\n### 数值实现与验证\n\n数值程序包括三个主要部分：\n1.  **表示向量场**：$\\mathbb{R}^3$ 上的向量场 $X$、$Y$ 和 $Z$ 实现为函数，这些函数接受一个三维点（作为 NumPy 数组）并返回在该点求值的、由其分量组成的三维向量（NumPy 数组）。\n2.  **数值微分**：为了计算在点 $p$ 处的雅可比矩阵 $J_X$ 和 $J_Y$，我们需要其分量函数的偏导数。由于这些函数是光滑的（多项式），我们可以使用二阶中心有限差分格式，它在精度和简单性之間取得了良好的平衡。函数 $g$ 关于 $x^i$ 在点 $p$ 处的偏导数近似为：\n    $$\n    \\frac{\\partial g}{\\partial x^i}(p) \\approx \\frac{g(p + h \\cdot e_i) - g(p - h \\cdot e_i)}{2h}\n    $$\n    其中 $e_i$ 是第 $i$ 个方向的标准基向量，$h = 10^{-6}$ 是一个很小的步长。该公式应用于向量场的每个分量，以逐列构建其雅可比矩阵。\n3.  **计算李括号**：有了计算雅可比矩阵和求值向量场的能力，在点 $p$ 处的李括号 $[X,Y]$ 可以使用推导出的公式 $[X,Y](p) = J_Y(p)X(p) - J_X(p)Y(p)$ 直接计算。\n4.  **性质验证**：对指定的五个代数性质进行数值测试。对于每个性质，检查形式为 $LHS = RHS$ 的恒等式。我们在三个求值点 $p_1, p_2, p_3$ 中的每一个点上计算对应于左侧（LHS）和右侧（RHS）的向量。如果在给定点，LHS 和 RHS 向量分量之间的最大绝对差小于容差 $\\varepsilon = 10^{-9}$，则认为该恒等式在该点得到数值验证。只有当所有三个点都满足此条件时，该性质才被确认为 `True`。\n\n这五个测试是：\n1.  **反对称性**：$[X,Y] + [Y,X] = O$。\n2.  **双线性（第一参数）**：$[aX+bY, Z] = a[X,Z] + b[Y,Z]$。\n3.  **双线性（第二参数）**：$[X, aY+bZ] = a[X,Y] + b[X,Z]$。\n4.  **零向量场性质**：$[O,Y] = O$。\n5.  **相同向量场性质**：$[X,X] = O$。\n\n有限差分近似产生的数值误差约为 $O(h^2) \\approx 10^{-12}$ 量级。所选容差 $\\varepsilon = 10^{-9}$ 足够大，可以涵盖这些截断误差和浮点舍入误差，同时又足够小以确认恒等式成立。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and verifies properties of the Lie bracket for vector fields on R^3.\n    \"\"\"\n    # Define the test suite parameters from the problem statement.\n    n = 3\n    p1 = np.array([0.0, 0.0, 0.0])\n    p2 = np.array([1.0, -1.0, 2.0])\n    p3 = np.array([0.5, -2.0, 1.0])\n    evaluation_points = [p1, p2, p3]\n\n    a = 2.0\n    b = -3.0\n    h = 1e-6\n    epsilon = 1e-9\n\n    # --- Vector Field Definitions ---\n    # The vector fields are functions that take a point p (numpy array)\n    # and return a vector (numpy array).\n    def X_vf(p):\n        x, y, z = p\n        return np.array([x**2 * y, -y * z, x + 2.0])\n\n    def Y_vf(p):\n        x, y, z = p\n        return np.array([y**2, x * z, -x * y])\n\n    def Z_vf(p):\n        x, y, z = p\n        return np.array([1.0, x, z**2])\n\n    def O_vf(p):\n        return np.zeros(n)\n\n    # --- Core Numerical Functions ---\n    def numerical_jacobian(vf, p, h_step, dim):\n        \"\"\"\n        Computes the Jacobian matrix of a vector field vf at point p\n        using a central finite-difference scheme.\n        (J_vf)_ji = d(vf_j)/d(x_i)\n        \"\"\"\n        J = np.zeros((dim, dim))\n        for i in range(dim):\n            p_plus = p.copy()\n            p_minus = p.copy()\n            p_plus[i] += h_step\n            p_minus[i] -= h_step\n            \n            # The i-th column of the Jacobian is the partial derivative\n            # of the vector field with respect to the i-th coordinate.\n            J[:, i] = (vf(p_plus) - vf(p_minus)) / (2.0 * h_step)\n        return J\n\n    def lie_bracket(vf1, vf2, p, h_step, dim):\n        \"\"\"\n        Computes the Lie bracket [vf1, vf2] at point p using the formula\n        [vf1, vf2] = J_vf2 @ vf1 - J_vf1 @ vf2.\n        \"\"\"\n        J1 = numerical_jacobian(vf1, p, h_step, dim)\n        J2 = numerical_jacobian(vf2, p, h_step, dim)\n        \n        v1_p = vf1(p)\n        v2_p = vf2(p)\n        \n        return J2 @ v1_p - J1 @ v2_p\n\n    results = []\n\n    # --- Test 1: Antisymmetry: [X,Y] + [Y,X] = 0 ---\n    test1_valid = True\n    for p in evaluation_points:\n        lhs = lie_bracket(X_vf, Y_vf, p, h, n) + lie_bracket(Y_vf, X_vf, p, h, n)\n        rhs = O_vf(p)\n        if np.max(np.abs(lhs - rhs)) = epsilon:\n            test1_valid = False\n            break\n    results.append(test1_valid)\n\n    # --- Test 2: Bilinearity in the first slot: [aX + bY, Z] = a[X,Z] + b[Y,Z] ---\n    test2_valid = True\n    # Define the combined vector field for the LHS\n    vf_ax_by = lambda p_vec: a * X_vf(p_vec) + b * Y_vf(p_vec)\n    for p in evaluation_points:\n        lhs = lie_bracket(vf_ax_by, Z_vf, p, h, n)\n        rhs = a * lie_bracket(X_vf, Z_vf, p, h, n) + b * lie_bracket(Y_vf, Z_vf, p, h, n)\n        if np.max(np.abs(lhs - rhs)) = epsilon:\n            test2_valid = False\n            break\n    results.append(test2_valid)\n\n    # --- Test 3: Bilinearity in the second slot: [X, aY + bZ] = a[X,Y] + b[X,Z] ---\n    test3_valid = True\n    # Define the combined vector field for the LHS\n    vf_ay_bz = lambda p_vec: a * Y_vf(p_vec) + b * Z_vf(p_vec)\n    for p in evaluation_points:\n        lhs = lie_bracket(X_vf, vf_ay_bz, p, h, n)\n        rhs = a * lie_bracket(X_vf, Y_vf, p, h, n) + b * lie_bracket(X_vf, Z_vf, p, h, n)\n        if np.max(np.abs(lhs - rhs)) = epsilon:\n            test3_valid = False\n            break\n    results.append(test3_valid)\n\n    # --- Test 4: Zero field: [O, Y] = 0 ---\n    test4_valid = True\n    for p in evaluation_points:\n        lhs = lie_bracket(O_vf, Y_vf, p, h, n)\n        rhs = O_vf(p)\n        if np.max(np.abs(lhs - rhs)) = epsilon:\n            test4_valid = False\n            break\n    results.append(test4_valid)\n\n    # --- Test 5: Identical fields: [X, X] = 0 ---\n    test5_valid = True\n    for p in evaluation_points:\n        lhs = lie_bracket(X_vf, X_vf, p, h, n)\n        rhs = O_vf(p)\n        if np.max(np.abs(lhs - rhs)) = epsilon:\n            test5_valid = False\n            break\n    results.append(test5_valid)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2987430"}]}