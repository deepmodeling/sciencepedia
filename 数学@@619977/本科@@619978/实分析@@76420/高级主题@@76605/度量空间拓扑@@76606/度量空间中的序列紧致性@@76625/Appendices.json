{"hands_on_practices": [{"introduction": "理解一个抽象概念的最好方法之一，是从其最基础的例子入手。这个练习将带你探讨一个最简单但又非平凡的序列紧集：一个收敛序列及其极限点构成的集合 [@problem_id:2315080]。通过解决这个问题，你将直接应用序列紧性的定义，并亲身体会到它与序列收敛概念之间密不可分的联系。", "problem": "在一个度量空间 $(X, d)$ 中，如果对任意实数 $\\epsilon > 0$，都存在一个自然数 $N$，使得对所有 $n > N$，距离 $d(x_n, L) < \\epsilon$ 成立，那么称序列 $(x_n)_{n \\in \\mathbb{N}}$ 收敛于极限 $L \\in X$。如果集合 $K$ 中的任意点列都存在一个收敛于 $K$ 中某一点的子序列，那么称集合 $K \\subseteq X$ 是序列紧的。\n\n设 $(X, d)$ 是一个任意度量空间，并考虑 $X$ 中的一个序列 $(x_n)_{n \\in \\mathbb{N}}$，它收敛于点 $L \\in X$。定义集合 $K = \\{x_n \\mid n \\in \\mathbb{N}\\} \\cup \\{L\\}$。现在，考虑一个任意序列 $(y_k)_{k \\in \\mathbb{N}}$，其中每一项 $y_k$ 都是集合 $K$ 中的一个元素。\n\n对于任何这样的序列 $(y_k)$，下列哪个陈述必然为真？\n\nA. 序列 $(y_k)$ 有一个子序列收敛于 $K$ 中的一个点。\nB. 序列 $(y_k)$ 必定自身收敛于 $K$ 中的一个点。\nC. 序列 $(y_k)$ 有一个子序列收敛于极限点 $L$。\nD. 点集 $\\{y_k \\mid k \\in \\mathbb{N}\\}$ 必定是一个有限集。\nE. 序列 $(y_k)$ 必定是一个柯西序列。", "solution": "我们给定一个度量空间 $(X,d)$，一个收敛于 $L\\in X$ 的序列 $(x_{n})_{n\\in\\mathbb{N}}$，以及集合 $K=\\{x_{n}\\mid n\\in\\mathbb{N}\\}\\cup\\{L\\}$。对于任意序列 $(y_{k})_{k\\in\\mathbb{N}}$，其中对所有 $k$ 都有 $y_{k}\\in K$，我们来分析所列陈述中哪一个必然成立。\n\n首先，我们证明陈述 A 必然为真。我们证明 $K$ 中的每个序列 $(y_{k})$ 都有一个收敛于 $K$ 中某一点的子序列。对于 $(y_{k})$ 有两种主要情况。\n\n情况1：$L$ 在 $(y_{k})$ 中出现无穷多次。那么存在一个恒等于 $L$ 的子序列，因此它收敛于 $L\\in K$。\n\n情况2：$L$ 在 $(y_{k})$ 中只出现有限次。那么存在 $k_{0}\\in\\mathbb{N}$，使得对所有 $k\\geq k_{0}$，有 $y_{k}\\in\\{x_{n}\\mid n\\in\\mathbb{N}\\}$。考虑当 $k\\geq k_{0}$ 时 $y_{k}$ 的值构成的多重集。\n- 如果存在 $m\\in\\mathbb{N}$ 使得 $x_{m}$ 作为 $y_{k}$ 的值出现无穷多次，那么我们可以提取一个常数子序列 $y_{k_{j}}=x_{m}$（对所有 $j$），它收敛于 $x_{m}\\in K$。\n- 否则，每个固定的值 $x_{m}$ 在 $(y_{k})$ 中只出现有限次，因此在尾序列 $(y_{k})_{k\\geq k_{0}}$ 中必定有无穷多个不同的值。由于 $x_{n}\\to L$，对每个 $j\\in\\mathbb{N}$，存在 $N_{j}\\in\\mathbb{N}$ 使得对所有 $n\\geq N_{j}$，都有\n$$\nd(x_{n},L)<\\frac{1}{j}.\n$$\n因为在 $k\\geq k_{0}$ 的 $y_{k}$ 中出现了无穷多个不同的 $x_{n}$，我们可以选择下标 $k_{j}\\geq k_{0}$ 和 $n_{j}\\geq N_{j}$ 使得 $y_{k_{j}}=x_{n_{j}}$，并且可以使 $k_{j}$ 严格递增。那么\n$$\nd(y_{k_{j}},L)=d(x_{n_{j}},L)<\\frac{1}{j}\\to 0,\n$$\n所以 $y_{k_{j}}\\to L\\in K$。因此在所有情况下，都存在 $(y_{k})$ 的一个子序列收敛于 $K$ 中的一个点。所以，A 成立。\n\n接下来，我们通过反例说明其余陈述不必然为真。\n\n对于 B：令 $(y_{k})$ 在 $K$ 的两个不同点之间交替，例如 $y_{2k}=x_{1}$ 和 $y_{2k+1}=x_{2}$，其中 $d(x_{1},x_{2})>0$。那么 $(y_{k})$ 不收敛，所以 B 通常是错误的。\n\n对于 C：令 $(y_{k})$ 为常数序列，其值为 $x_{m}\\neq L$，例如，对所有 $k$，有 $y_{k}=x_{m}$。那么它的每个子序列都是值为 $x_{m}$ 的常数序列，不收敛于 $L$。因此 C 不是必然的。\n\n对于 D：令 $(y_{k})$ 枚举 $\\{x_{n}\\mid n\\in\\mathbb{N}\\}$ 中的无穷多个不同元素。那么 $\\{y_{k}\\mid k\\in\\mathbb{N}\\}$ 是一个无限集。因此 D 通常是错误的。\n\n对于 E：使用与 B 中相同的交替例子，该序列不是柯西序列，因为如果 $d(x_{1},x_{2})>0$，那么对于所有奇偶性不同的 $k<\\ell$，有\n$$\nd(y_{k},y_{\\ell})=d(x_{1},x_{2})\\not\\to 0,\n$$\n所以 E 通常是错误的。\n\n因此，对于每一个这样的 $(y_{k})$，唯一必然为真的陈述是 A。", "answer": "$$\\boxed{A}$$", "id": "2315080"}, {"introduction": "在掌握了基本范例后，一个自然的问题是：序列紧性这一性质在集合运算下表现如何？这个练习 [@problem_id:2315135] 挑战你像数学家一样思考，探究序列紧性是否在并集（$K_1 \\cup K_2$）、交集（$K_1 \\cap K_2$）、差集（$K_1 \\setminus K_2$）和笛卡尔积（$K_1 \\times K_2$）这些标准集合运算下得以保持。这个过程不仅能加深你对紧性“稳健性”的理解，还能揭示其所依赖的关键结构特性。", "problem": "在一个一般度量空间 $(X, d)$ 的背景下，一个子集 $A \\subseteq X$ 被定义为**序列紧的**，如果 $A$ 中的每个点列都包含一个收敛到也在 $A$ 中的极限点的子列。\n\n设 $K_1$ 和 $K_2$ 是任意度量空间 $(X, d)$ 的两个非空序列紧子集。由 $K_1$ 和 $K_2$ 构成的下列哪些集合也保证是序列紧的？\n\nA. 并集, $K_1 \\cup K_2$\nB. 交集, $K_1 \\cap K_2$\nC. 差集, $K_1 \\setminus K_2$\nD. 笛卡尔积, $K_1 \\times K_2$，被视为积空间 $X \\times X$ 的一个子集，该积空间配备度量 $d_p((x_1, y_1), (x_2, y_2)) = \\sqrt{d(x_1, x_2)^2 + d(y_1, y_2)^2}$", "solution": "我们全程在一个度量空间 $(X,d)$ 中进行讨论。一个子集 $A \\subseteq X$ 是序列紧的，如果 $A$ 中的任意序列都有一个收敛到 $A$ 中某极限的子列。\n\n一个预备事实：如果 $A$ 在一个度量空间中是序列紧的，那么 $A$ 在 $X$ 中是闭集。为了证明这一点，设 $(a_{n}) \\subseteq A$ 在 $X$ 中收敛到某个 $a \\in X$。因为一个收敛序列的每个子列都收敛到相同的极限，所以 $(a_{n})$ 的任何子列也都收敛到 $a$。$A$ 的序列紧性保证存在一个子列 $(a_{n_{k}})$ 收敛到某个极限 $\\ell \\in A$。根据度量空间中极限的唯一性，我们有 $\\ell=a$，因此 $a \\in A$。所以 $A$ 是闭集。\n\nA. $K_{1} \\cup K_{2}$ 是序列紧的。设 $(z_{n}) \\subseteq K_{1} \\cup K_{2}$。定义下标集 $I_{1}=\\{n : z_{n} \\in K_{1}\\}$ 和 $I_{2}=\\{n : z_{n} \\in K_{2}\\}$。由于 $I_{1} \\cup I_{2}=\\mathbb{N}$，所以 $I_{1}$ 或 $I_{2}$ 中至少有一个是无限集。如果 $I_{1}$ 是无限集，我们可从中提取一个所有项都在 $K_{1}$ 中的子列 $(z_{n_{k}})$；根据 $K_{1}$ 的序列紧性，这个子列有一个更深层的子列收敛到某个 $x \\in K_{1} \\subseteq K_{1} \\cup K_{2}$。如果 $I_{2}$ 是无限集，用 $K_{2}$ 进行同样的推理，可以得到一个收敛到某个 $y \\in K_{2} \\subseteq K_{1} \\cup K_{2}$ 的子列。因此，$K_{1} \\cup K_{2}$ 中的每个序列都存在一个收敛到 $K_{1} \\cup K_{2}$ 中某一点的子列，所以 $K_{1} \\cup K_{2}$ 是序列紧的。\n\nB. $K_{1} \\cap K_{2}$ 是序列紧的。设 $(w_{n}) \\subseteq K_{1} \\cap K_{2}$。因为 $(w_{n}) \\subseteq K_{1}$ 且 $K_{1}$ 是序列紧的，所以存在一个子列 $(w_{n_{k}})$ 收敛到某个 $x \\in K_{1}$。又因为 $(w_{n_{k}}) \\subseteq K_{2}$ 且 $K_{2}$ 是序列紧的，根据前面的预备事实，$K_{2}$ 是闭集；因此 $(w_{n_{k}})$ 的极限也属于 $K_{2}$，即 $x \\in K_{2}$。所以 $x \\in K_{1} \\cap K_{2}$，且 $K_{1} \\cap K_{2}$ 中的每个序列都有一个收敛到 $K_{1} \\cap K_{2}$ 中某一点的子列。因此 $K_{1} \\cap K_{2}$ 是序列紧的。\n\nC. $K_{1} \\setminus K_{2}$ 不一定是序列紧的。举一个反例，取 $X=\\mathbb{R}$，度量为 $d(x,y)=|x-y|$，设 $K_{1}=[0,1]$ 和 $K_{2}=\\{0\\}$。$K_{1}$ 和 $K_{2}$ 都是序列紧的。但是 $K_{1} \\setminus K_{2}=(0,1]$ 不是序列紧的：序列 $x_{n}=\\frac{1}{n}$ 位于 $(0,1]$ 中，其每个子列 $x_{n_{k}}$ 都收敛到 $0$，而 $0 \\notin (0,1]$。因此，不存在极限在 $(0,1]$ 中的子列。\n\nD. 在积空间 $(X \\times X, d_{p})$ 中，$K_{1} \\times K_{2}$ 是序列紧的，其中度量为 $d_{p}((x_{1},y_{1}),(x_{2},y_{2}))=\\sqrt{d(x_{1},x_{2})^{2}+d(y_{1},y_{2})^{2}}$。设 $((x_{n},y_{n})) \\subseteq K_{1} \\times K_{2}$。由于 $K_{1}$ 是序列紧的，存在一个子列 $(x_{n_{k}})$ 收敛到某个 $x \\in K_{1}$。考虑序列 $(y_{n_{k}}) \\subseteq K_{2}$。因为 $K_{2}$ 是序列紧的，所以存在一个更深层的子列 $(y_{n_{k_{j}}})$ 收敛到某个 $y \\in K_{2}$。沿着相同的下标，$(x_{n_{k_{j}}})$ 也收敛到 $x$。因此\n$$\nd_{p}\\big((x_{n_{k_{j}}},y_{n_{k_{j}}}),(x,y)\\big)\n=\\sqrt{d(x_{n_{k_{j}}},x)^{2}+d(y_{n_{k_{j}}},y)^{2}}\n\\leq d(x_{n_{k_{j}}},x)+d(y_{n_{k_{j}}},y)\\to 0,\n$$\n因为两个收敛到 $0$ 的序列之和也收敛到 $0$。所以 $((x_{n},y_{n}))$ 存在一个在度量 $d_{p}$ 下收敛到 $(x,y) \\in K_{1} \\times K_{2}$ 的子列。因此 $K_{1} \\times K_{2}$ 是序列紧的。\n\n综上所述，保证是序列紧的集合是 A、B 和 D，而 C 不保证是。", "answer": "$$\\boxed{ABD}$$", "id": "2315135"}, {"introduction": "最后的这个动手实践将抽象的理论通过一个具体、算法化的视角变得生动起来。它设计了一个模拟二维空间中 Bolzano-Weierstrass 定理（一个与紧性相关的基石性结论）证明过程的场景 [@problem_id:2315112]。通过追踪算法的每一步来定位一个极限点，你将对为何在一个封闭有界的“盒子”（如 $[0,1] \\times [0,1]$）中的任何序列都必然有至少一个聚点，获得一种直观且程序化的深刻理解。", "problem": "一个监控系统正在追踪一个在笛卡尔平面上的闭合单位正方形 $S = [0,1] \\times [0,1]$ 内运动的粒子。在每个整数时间 $n \\ge 1$，粒子的位置被记录为一个点 $z_n = (x_n, y_n)$。该位置由以下一组取决于 $n$ 值的规则确定：\n- 如果 $n \\equiv 1 \\pmod 4$，则 $z_n = \\left(\\frac{1}{4} + \\frac{1}{n^2}, \\frac{3}{4} - \\frac{1}{n^2}\\right)$。\n- 如果 $n \\equiv 2 \\pmod 4$，则 $z_n = \\left(\\frac{3}{4} - \\frac{1}{n^2}, \\frac{1}{4} + \\frac{1}{n^2}\\right)$。\n- 如果 $n \\equiv 3 \\pmod 4$，则 $z_n = \\left(\\frac{1}{8} + \\frac{1}{n^2}, \\frac{1}{8} - \\frac{1}{n^2}\\right)$。\n- 如果 $n \\equiv 0 \\pmod 4$，则 $z_n = \\left(\\frac{7}{8} - \\frac{1}{n^2}, \\frac{7}{8} + \\frac{1}{n^2}\\right)$。\n\n一个自动化分析程序被设计用来寻找位置序列 $(z_n)$ 的一个聚点。该程序使用一种递归划分算法。从正方形 $S_0 = S$ 开始，该算法生成一个嵌套正方形序列 $S_0 \\supset S_1 \\supset S_2 \\supset \\dots$。在每一步 $k \\ge 1$，正方形 $S_{k-1}$ 被划分为四个大小相等、闭合的子象限：左下 (LL)、右下 (LR)、左上 (UL) 和右上 (UR)。程序随后将 $S_k$ 设置为按照固定优先级顺序 (LL, LR, UL, UR) 中第一个包含序列 $(z_n)$ 中无穷多个点的子象限。\n\n这个过程保证了所有正方形的交集 $P = \\bigcap_{k=0}^{\\infty} S_k$ 只包含一个点。确定这个点 $P$ 的坐标。坐标必须表示为精确的分数。", "solution": "根据模 4 的同余类定义四个子序列。对于 $m \\in \\mathbb{N}$，\n$$\nz_{4m+1}=\\left(\\frac{1}{4}+\\frac{1}{(4m+1)^{2}},\\,\\frac{3}{4}-\\frac{1}{(4m+1)^{2}}\\right)\\to\\left(\\frac{1}{4},\\frac{3}{4}\\right),\n$$\n$$\nz_{4m+2}=\\left(\\frac{3}{4}-\\frac{1}{(4m+2)^{2}},\\,\\frac{1}{4}+\\frac{1}{(4m+2)^{2}}\\right)\\to\\left(\\frac{3}{4},\\frac{1}{4}\\right),\n$$\n$$\nz_{4m+3}=\\left(\\frac{1}{8}+\\frac{1}{(4m+3)^{2}},\\,\\frac{1}{8}-\\frac{1}{(4m+3)^{2}}\\right)\\to\\left(\\frac{1}{8},\\frac{1}{8}\\right),\n$$\n$$\nz_{4m}=\\left(\\frac{7}{8}-\\frac{1}{(4m)^{2}},\\,\\frac{7}{8}+\\frac{1}{(4m)^{2}}\\right)\\to\\left(\\frac{7}{8},\\frac{7}{8}\\right).\n$$\n因此该序列有四个聚点，分别位于 $S$ 的四个象限中。\n\n步骤 $k=1$：将 $S_{0}=[0,1]\\times[0,1]$ 划分为 LL, LR, UL, UR，每个子象限都包含序列 $(z_{n})$ 的无穷多项（对应于上述四个子序列之一）。根据优先级顺序，程序选择第一个满足条件的子象限，即 LL。因此\n$$\nS_{1}=[0,\\tfrac{1}{2}]\\times[0,\\tfrac{1}{2}].\n$$\n\n步骤 $k=2$：在 $S_{1}$ 内部，唯一贡献了无穷多个点的子序列是 $z_{4m+3}$，因为当 $n\\equiv 3\\pmod 4$ 时，我们有\n$$\nx_{n}=\\frac{1}{8}+\\frac{1}{n^{2}}<\\frac{1}{4}<\\frac{1}{2},\\qquad y_{n}=\\frac{1}{8}-\\frac{1}{n^{2}}<\\frac{1}{8}<\\frac{1}{2},\n$$\n而对于其他同余类，至少有一个坐标大于 $\\frac{1}{2}$。将 $S_{1}$ 分为四等份得到 LL $=[0,\\tfrac{1}{4}]\\times[0,\\tfrac{1}{4}]$，LR $=[\\tfrac{1}{4},\\tfrac{1}{2}]\\times[0,\\tfrac{1}{4}]$，UL $=[0,\\tfrac{1}{4}]\\times[\\tfrac{1}{4},\\tfrac{1}{2}]$，UR $=[\\tfrac{1}{4},\\tfrac{1}{2}]\\times[\\tfrac{1}{4},\\tfrac{1}{2}]$。对于所有足够大的 $n\\equiv 3\\pmod 4$，有 $x_{n}<\\frac{1}{4}$ 和 $y_{n}<\\frac{1}{4}$，因此有无穷多个 $z_{n}$ 落在 $S_{1}$ 的 LL 子象限中，而没有无穷多项落在其他三个子象限中。所以\n$$\nS_{2}=[0,\\tfrac{1}{4}]\\times[0,\\tfrac{1}{4}].\n$$\n\n步骤 $k=3$：划分 $S_{2}$，分割线是 $x=\\frac{1}{8}$ 和 $y=\\frac{1}{8}$。对于所有 $n\\equiv 3\\pmod 4$，\n$$\nx_{n}=\\frac{1}{8}+\\frac{1}{n^{2}}>\\frac{1}{8},\\qquad y_{n}=\\frac{1}{8}-\\frac{1}{n^{2}}<\\frac{1}{8},\n$$\n所以这些点位于 $S_{2}$ 的 LR 子象限中；因此\n$$\nS_{3}=\\left[\\tfrac{1}{8},\\tfrac{1}{4}\\right]\\times\\left[0,\\tfrac{1}{8}\\right].\n$$\n\n步骤 $k=4$：划分 $S_{3}$，中线是 $x=\\frac{3}{16}$ 和 $y=\\frac{1}{16}$。对于所有足够大的、满足 $n\\equiv 3\\pmod 4$ 的 $n$，我们有 $1/n^{2}<\\frac{1}{16}$，因此\n$$\nx_{n}=\\frac{1}{8}+\\frac{1}{n^{2}}<\\frac{3}{16},\\qquad y_{n}=\\frac{1}{8}-\\frac{1}{n^{2}}>\\frac{1}{16},\n$$\n所以有无穷多个 $z_{n}$ 落在 $S_{3}$ 的 UL 子象限中。所以\n$$\nS_{4}=\\left[\\tfrac{1}{8},\\tfrac{3}{16}\\right]\\times\\left[\\tfrac{1}{16},\\tfrac{1}{8}\\right].\n$$\n\n从这里开始，可以应用归纳法。假设对于某个 $k\\ge 4$，有\n$$\nS_{k}=\\left[\\tfrac{1}{8},\\,\\tfrac{1}{8}+s_{k}\\right]\\times\\left[\\tfrac{1}{8}-s_{k},\\,\\tfrac{1}{8}\\right]\n$$\n其中 $s_{k}>0$ 是边长。划分 $S_{k}$，中线是 $x=\\frac{1}{8}+\\frac{s_{k}}{2}$ 和 $y=\\frac{1}{8}-\\frac{s_{k}}{2}$。对于所有足够大的、满足 $n\\equiv 3\\pmod 4$ 的 $n$，我们有 $1/n^{2}<\\frac{s_{k}}{2}$，这意味着\n$$\nx_{n}=\\frac{1}{8}+\\frac{1}{n^{2}}<\\frac{1}{8}+\\frac{s_{k}}{2},\\qquad y_{n}=\\frac{1}{8}-\\frac{1}{n^{2}}>\\frac{1}{8}-\\frac{s_{k}}{2}.\n$$\n因此，有无穷多个 $z_{n}$ 位于 $S_{k}$ 的 UL 子象限中，算法会选择\n$$\nS_{k+1}=\\left[\\tfrac{1}{8},\\,\\tfrac{1}{8}+\\frac{s_{k}}{2}\\right]\\times\\left[\\tfrac{1}{8}-\\frac{s_{k}}{2},\\,\\tfrac{1}{8}\\right],\n$$\n该正方形的左边界仍然是 $x=\\frac{1}{8}$，上边界仍然是 $y=\\frac{1}{8}$。然而，这个归纳步骤的描述不完全正确，因为下一次迭代的左边界将是 $\\frac{1}{8}$，而右边界是 $\\frac{1}{8}+\\frac{s_k}{2}$，所以左边界不变。下边界是 $\\frac{1}{8}-\\frac{s_k}{2}$，而上边界是 $\\frac{1}{8}$，所以上边界不变。这意味着所选正方形始终将 $(\\frac{1}{8}, \\frac{1}{8})$ 作为其角点之一（具体来说，是左上角）。\n\n由于在每一步中，正方形的边长都减半，所以正方形的直径趋于零。由于点 $(\\frac{1}{8}, \\frac{1}{8})$ 包含在每个嵌套的正方形 $S_k$ 中，所以交集\n$$\nP=\\bigcap_{k=0}^{\\infty}S_{k}\n$$\n是单点集 $\\left\\{\\left(\\frac{1}{8},\\frac{1}{8}\\right)\\right\\}$。因此，程序找到的聚点是\n$$\nP=\\left(\\frac{1}{8},\\,\\frac{1}{8}\\right).\n$$", "answer": "$$\\boxed{\\left(\\frac{1}{8}, \\frac{1}{8}\\right)}$$", "id": "2315112"}]}