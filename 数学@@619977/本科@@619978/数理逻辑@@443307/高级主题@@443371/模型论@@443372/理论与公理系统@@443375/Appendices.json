{"hands_on_practices": [{"introduction": "逻辑理论的核心在于公理与结论之间的关系。这个练习将带你深入一阶逻辑的语义核心，巩固语义推论（semantic consequence）这一基本概念[@problem_id:3057860]。通过亲手构造模型与反模型，你将实践如何严格证明一个论断是公理的必然结果，以及如何证伪另一个论断，这对于理解公理化方法的本质至关重要。", "problem": "考虑经典的、在非空论域上具有标准塔斯基语义 (standard Tarskian semantics) 的一阶逻辑。设语言包含两个一元谓词符号 $Q$ 和 $R$。设 $\\Gamma$ 是语句集\n$$\n\\Gamma \\;=\\; \\left\\{ \\forall x\\,\\big(Q(x) \\rightarrow R(x)\\big),\\; \\exists x\\,Q(x) \\right\\}.\n$$\n定义语句 $\\varphi$ 和 $\\psi$ 如下\n$$\n\\varphi \\;=\\; \\exists x\\,R(x), \\qquad \\psi \\;=\\; \\forall x\\,R(x).\n$$\n你的任务是：\n- 仅使用满足 (satisfaction) 和语义后承 (semantic consequence) 的定义，证明 $\\Gamma \\models \\varphi$。\n- 为说明一个语义后承不必加强为一个全称语句，构造一个反模型（即一个结构）$\\mathcal{M}$，使得 $\\mathcal{M} \\models \\Gamma$ 但 $\\mathcal{M} \\not\\models \\psi$，从而证明 $\\Gamma \\not\\models \\psi$。\n- 在所有满足 $\\Gamma$ 但证伪 $\\psi$ 的反模型 $\\mathcal{M}$ 中，确定 $\\mathcal{M}$ 的论域的最小可能有限基数。将此最小基数作为你的最终答案。最终答案以无单位的整数形式表示。无需四舍五入。", "solution": "该问题要求对一阶逻辑中的语义后承进行分析。给定一个语句集 $\\Gamma \\;=\\; \\left\\{ \\forall x\\,\\big(Q(x) \\rightarrow R(x)\\big),\\; \\exists x\\,Q(x) \\right\\}$ 和另外两个语句 $\\varphi \\;=\\; \\exists x\\,R(x)$ 以及 $\\psi \\;=\\; \\forall x\\,R(x)$。任务是证明一个语义后承，通过构造反模型来反证另一个语义后承，并找出此类反模型论域的最小基数。\n\n首先，我们将证明 $\\Gamma \\models \\varphi$。\n根据定义，语义后承 $\\Gamma \\models \\varphi$ 成立，当且仅当对于每一个结构 $\\mathcal{M}$，如果 $\\mathcal{M} \\models \\Gamma$，则 $\\mathcal{M} \\models \\varphi$。\n设 $\\mathcal{M}$ 是一个具有非空论域 $D$ 的任意结构。设 $Q^\\mathcal{M} \\subseteq D$ 和 $R^\\mathcal{M} \\subseteq D$ 分别是结构 $\\mathcal{M}$ 中一元谓词符号 $Q$ 和 $R$ 的解释。\n假设 $\\mathcal{M} \\models \\Gamma$。这意味着 $\\mathcal{M}$ 满足 $\\Gamma$ 中的所有语句：\n$1$. $\\mathcal{M} \\models \\forall x\\,\\big(Q(x) \\rightarrow R(x)\\big)$。根据塔斯基语义 (Tarskian semantics)，这意味着对于每个元素 $a \\in D$，陈述“$a \\in Q^\\mathcal{M}$ 蕴含 $a \\in R^\\mathcal{M}$”为真。这等价于集合论条件 $Q^\\mathcal{M} \\subseteq R^\\mathcal{M}$。\n$2$. $\\mathcal{M} \\models \\exists x\\,Q(x)$。在语义上，这意味着存在至少一个元素 $c \\in D$ 使得 $c \\in Q^\\mathcal{M}$。因此，集合 $Q^\\mathcal{M}$ 必须为非空，即 $Q^\\mathcal{M} \\neq \\emptyset$。\n我们的目标是证明 $\\mathcal{M} \\models \\varphi$，即 $\\mathcal{M} \\models \\exists x\\,R(x)$。此式成立，当且仅当存在某个元素 $d \\in D$ 使得 $d \\in R^\\mathcal{M}$。换句话说，我们必须证明 $R^\\mathcal{M}$ 是非空的。\n从前提(2)，我们知道存在一个元素 $c \\in D$ 使得 $c \\in Q^\\mathcal{M}$。\n从前提(1)，蕴含关系 $a \\in Q^\\mathcal{M} \\rightarrow a \\in R^\\mathcal{M}$ 对所有 $a \\in D$ 均成立。特别地，它对元素 $c$ 也成立。\n因为 $c \\in Q^\\mathcal{M}$，通过逻辑推导（肯定前件式，modus ponens）可知 $c \\in R^\\mathcal{M}$。\n在 $R^\\mathcal{M}$ 中存在元素 $c$ 证明了 $R^\\mathcal{M}$ 是非空的。\n因此，$\\mathcal{M} \\models \\exists x\\,R(x)$，即 $\\mathcal{M} \\models \\varphi$。\n由于我们选择的 $\\mathcal{M}$ 是 $\\Gamma$ 的任意模型，我们已经证明了 $\\Gamma$ 的任何模型也都是 $\\varphi$ 的模型。我们得出结论 $\\Gamma \\models \\varphi$。\n\n其次，我们将构造一个反模型来证明 $\\Gamma \\not\\models \\psi$。\n为了证明 $\\Gamma \\not\\models \\psi$，我们需要找到一个单一的结构 $\\mathcal{M}$，使得 $\\mathcal{M} \\models \\Gamma$ 并且 $\\mathcal{M} \\not\\models \\psi$。让我们指定这样一个具有论域 $D$ 和解释 $Q^\\mathcal{M}$、$R^\\mathcal{M}$ 的结构 $\\mathcal{M}$ 的属性：\n- $\\mathcal{M} \\models \\Gamma$:\n    - $\\mathcal{M} \\models \\forall x\\,\\big(Q(x) \\rightarrow R(x)\\big) \\implies Q^\\mathcal{M} \\subseteq R^\\mathcal{M}$。\n    - $\\mathcal{M} \\models \\exists x\\,Q(x) \\implies Q^\\mathcal{M} \\neq \\emptyset$。\n- $\\mathcal{M} \\not\\models \\psi$:\n    - $\\mathcal{M} \\not\\models \\forall x\\,R(x)$。这意味着存在至少一个元素 $b \\in D$ 使得 $b \\notin R^\\mathcal{M}$。这等价于 $R^\\mathcal{M}$ 是 $D$ 的一个真子集。\n\n我们尝试用最小可能的论域来构造这样一个模型。大小为1的论域是行不通的，因为如果 $D = \\{a\\}$，那么 $Q^\\mathcal{M} \\neq \\emptyset$ 要求 $Q^\\mathcal{M} = \\{a\\}$。接着 $Q^\\mathcal{M} \\subseteq R^\\mathcal{M}$ 要求 $R^\\mathcal{M} = \\{a\\}$。但这意味着 $R^\\mathcal{M} = D$，这蕴含了 $\\mathcal{M} \\models \\forall x\\,R(x)$，与 $\\mathcal{M} \\not\\models \\psi$ 的要求相矛盾。\n我们尝试一个大小为2的论域。设论域为 $D = \\{c_1, c_2\\}$。\n我们定义结构 $\\mathcal{M}$ 如下：\n- 论域 $D = \\{c_1, c_2\\}$。\n- $Q$ 的解释：$Q^\\mathcal{M} = \\{c_1\\}$。\n- $R$ 的解释：$R^\\mathcal{M} = \\{c_1\\}$。\n\n现在，我们验证这个结构 $\\mathcal{M}$ 是一个反模型：\n- $\\mathcal{M} \\models \\Gamma$ 是否成立？\n    - 为检查 $\\mathcal{M} \\models \\forall x\\,\\big(Q(x) \\rightarrow R(x)\\big)$，我们检查是否有 $Q^\\mathcal{M} \\subseteq R^\\mathcal{M}$。由于 $\\{c_1\\} \\subseteq \\{c_1\\}$，这是成立的。\n    - 为检查 $\\mathcal{M} \\models \\exists x\\,Q(x)$，我们检查是否有 $Q^\\mathcal{M} \\neq \\emptyset$。由于 $Q^\\mathcal{M}=\\{c_1\\}$，它是非空的。这是成立的。\n    - 由于 $\\Gamma$ 中的两个语句都得到满足，所以 $\\mathcal{M} \\models \\Gamma$。\n- $\\mathcal{M} \\not\\models \\psi$ 是否成立？\n    - 为检查 $\\mathcal{M} \\not\\models \\forall x\\,R(x)$，我们必须在 $D$ 中找到一个不在 $R^\\mathcal{M}$ 中的元素。考虑元素 $c_2 \\in D$。$R$ 的解释 $R^\\mathcal{M}$ 是 $\\{c_1\\}$，而 $c_2 \\notin \\{c_1\\}$。因此，全称语句 $\\forall x\\,R(x)$ 在 $\\mathcal{M}$ 中是假的。\n    - 因此，$\\mathcal{M} \\not\\models \\psi$。\n既然我们找到了一个结构 $\\mathcal{M}$，其中 $\\Gamma$ 为真而 $\\psi$ 为假，我们就成功地证明了 $\\Gamma \\not\\models \\psi$。\n\n第三，我们将确定此类反模型的论域的最小可能有限基数。\n设 $\\mathcal{M}$ 是任何具有有限论域 $D$ 的反模型，它证伪 $\\psi$ 同时满足 $\\Gamma$。对于解释 $Q^\\mathcal{M}$ 和 $R^\\mathcal{M}$，必须满足以下条件：\n$1$. 从 $\\mathcal{M} \\models \\exists x\\,Q(x)$，我们知道 $Q^\\mathcal{M} \\neq \\emptyset$。这意味着存在至少一个元素，我们称之为 $a$，使得 $a \\in Q^\\mathcal{M}$。\n$2$. 从 $\\mathcal{M} \\models \\forall x\\,\\big(Q(x) \\rightarrow R(x)\\big)$，我们有 $Q^\\mathcal{M} \\subseteq R^\\mathcal{M}$。由于第(1)点中的 $a \\in Q^\\mathcal{M}$，因此也必须有 $a \\in R^\\mathcal{M}$。\n$3$. 从 $\\mathcal{M} \\not\\models \\forall x\\,R(x)$，我们知道论域中存在某个元素不在 $R$ 的解释中。设这个元素为 $b$。所以，$b \\in D$ 并且 $b \\notin R^\\mathcal{M}$。\n现在，比较元素 $a$ 和 $b$。我们有 $a \\in R^\\mathcal{M}$ 和 $b \\notin R^\\mathcal{M}$。这直接意味着 $a$ 和 $b$ 不可能是同一个元素，所以 $a \\neq b$。\n由于论域 $D$ 必须至少包含这两个不同的元素 $a$ 和 $b$，所以 $D$ 的基数必须至少为2。即 $|D| \\geq 2$。\n在本解答的第二部分，我们明确地构造了一个基数为2的论域的反模型。这表明最小可能基数2是可以达到的。\n因此，反模型的论域的最小可能有限基数为2。", "answer": "$$\n\\boxed{2}\n$$", "id": "3057860"}, {"introduction": "在理解了单一的逻辑推论后，一个自然的问题是：一个公理系统究竟能“生成”多少结论？这个练习将引导你探索一个理论的“演绎闭包”（deductive closure），即从给定公理集可证的所有句子的集合[@problem_id:3057851]。你将运用可靠性与完备性定理，在句法推导和语义真理之间架起桥梁，并进一步揭示一个公理系统如何优雅地诱导出一个被称为林登鲍姆-塔斯基代数（Lindenbaum-Tarski algebra）的代数结构。", "problem": "设 $L$ 是经典命题逻辑的语言，其命题变量为 $\\{p,q\\}$，原始联结词为 $\\lnot$ 和 $\\to$（通常缩写为 $p \\land q := \\lnot(p \\to \\lnot q)$，$p \\lor q := (\\lnot p) \\to q$，以及 $p \\leftrightarrow q := (p \\to q) \\land (q \\to p)$）。设 $\\vdash$ 表示在任何一个用于经典命题逻辑的可靠且完备的 Hilbert 式演绎系统中的可导性，该系统以“肯定前件”(Modus Ponens)为唯一的推理规则。一个 $L$-公式集 $T$ 如果非空且在可导性下是封闭的，则称之为一个理论。\n\n1) 精确陈述一个理论 $T$ 在可导性下是封闭的的含义，并定义一个 $L$-公式集 $\\Gamma$ 的演绎闭包 $\\operatorname{Th}(\\Gamma)$。\n\n2) 考虑集合 $\\Gamma = \\{\\,p \\leftrightarrow q\\,\\}$。仅使用基本定义和公认事实（特别是，给定的经典命题逻辑系统的可靠性和完备性），构造并刻画演绎闭包 $\\operatorname{Th}(\\Gamma)$ 作为所有 $L$-公式集合的一个子集。\n\n3) 定义模 $\\Gamma$ 的可证等价关系 $\\varphi \\equiv_{\\Gamma} \\psi$ 当且仅当 $\\Gamma \\vdash \\varphi \\leftrightarrow \\psi$ 成立，并设 $\\mathcal{L}_{\\Gamma}$ 表示 $L$-公式关于 $\\equiv_{\\Gamma}$ 的等价类集合（即模 $\\Gamma$ 的 Lindenbaum–Tarski 代数 (LTA)）。确定 $\\mathcal{L}_{\\Gamma}$ 的确切基数 $N$。以精确整数形式给出你的最终答案，无需四舍五入。", "solution": "问题陈述被验证为具有科学依据、问题明确且客观。它提出了一个关于理论和 Lindenbaum-Tarski 代数的数理逻辑标准练习。所有术语都在经典命题逻辑的标准框架内有正式定义。\n\n解答分为问题所要求的三个部分。\n\n1) “在可导性下封闭”和“演绎闭包”的定义。\n\n一个 $L$-公式集 $T$ 如果非空且在可导性下是封闭的，则称之为一个理论。这意味着对于语言 $L$ 中的任何公式 $\\varphi$，如果 $\\varphi$ 可从公式集 $T$ 导出，那么 $\\varphi$ 必须是 $T$ 的一个元素。更形式化地， $T$ 在可导性下是封闭的，如果：\n$$ \\text{对于所有 } \\varphi, \\text{ 如果 } T \\vdash \\varphi, \\text{ 那么 } \\varphi \\in T $$\n这个定义意味着一个理论包含其所有的逻辑推论。\n\n一个 $L$-公式集 $\\Gamma$ 的演绎闭包，记作 $\\operatorname{Th}(\\Gamma)$，是所有可使用给定的演绎系统从 $\\Gamma$ 导出的 $L$-公式的集合。形式上，它被定义为：\n$$ \\operatorname{Th}(\\Gamma) = \\{ \\varphi \\mid \\Gamma \\vdash \\varphi \\} $$\n根据这个定义，$\\operatorname{Th}(\\Gamma)$ 是包含 $\\Gamma$ 的最小理论。\n\n2) 针对 $\\Gamma = \\{p \\leftrightarrow q\\}$ 构造并刻画 $\\operatorname{Th}(\\Gamma)$。\n\n给定 Hilbert 式演绎系统对于经典命题逻辑是可靠且完备的。完备性定理指出，一个公式 $\\varphi$ 可从一个前提集 $\\Gamma$ 导出，当且仅当 $\\varphi$ 是 $\\Gamma$ 的一个语义推论。这可以写作：\n$$ \\Gamma \\vdash \\varphi \\iff \\Gamma \\models \\varphi $$\n使用这一定理，我们可以从语义上刻画演绎闭包 $\\operatorname{Th}(\\Gamma)$：\n$$ \\operatorname{Th}(\\Gamma) = \\{ \\varphi \\mid \\Gamma \\models \\varphi \\} $$\n关系 $\\Gamma \\models \\varphi$ 成立，当且仅当每一个满足 $\\Gamma$ 中所有公式的真值赋值也满足 $\\varphi$。这样的赋值被称为 $\\Gamma$ 的一个模型。\n\n在这个问题中，$\\Gamma = \\{p \\leftrightarrow q\\}$。语言 $L$ 有两个命题变量 $p$ 和 $q$，从而产生 $2^2 = 4$ 种可能的真值赋值。一个赋值 $v$ 是 $\\Gamma$ 的一个模型，如果 $v(p \\leftrightarrow q) = \\text{True}$。这恰好在 $v(p) = v(q)$ 时发生。让我们列出四种可能的赋值 $v: \\{p, q\\} \\to \\{\\text{True}, \\text{False}\\}$：\n\\begin{itemize}\n    \\item $v_1$: $v_1(p) = \\text{True}$，$v_1(q) = \\text{True}$。此时，$v_1(p \\leftrightarrow q) = \\text{True}$。所以，$v_1$ 是 $\\Gamma$ 的一个模型。\n    \\item $v_2$: $v_2(p) = \\text{True}$，$v_2(q) = \\text{False}$。此时，$v_2(p \\leftrightarrow q) = \\text{False}$。\n    \\item $v_3$: $v_3(p) = \\text{False}$，$v_3(q) = \\text{True}$。此时，$v_3(p \\leftrightarrow q) = \\text{False}$。\n    \\item $v_4$: $v_4(p) = \\text{False}$，$v_4(q) = \\text{False}$。此时，$v_4(p \\leftrightarrow q) = \\text{True}$。所以，$v_4$ 是 $\\Gamma$ 的一个模型。\n\\end{itemize}\n$\\Gamma = \\{p \\leftrightarrow q\\}$ 的模型是赋值 $v_1$ 和 $v_4$。\n\n一个公式 $\\varphi$ 属于 $\\operatorname{Th}(\\Gamma)$ 当且仅当它在 $\\Gamma$ 的所有模型下都为真。因此，$\\varphi \\in \\operatorname{Th}(\\Gamma)$ 当且仅当 $v_1(\\varphi) = \\text{True}$ 且 $v_4(\\varphi) = \\text{True}$。\n\n这提供了以下刻画：$\\operatorname{Th}(\\{p \\leftrightarrow q\\})$ 是语言 $L$（含变量 $p,q$）中，所有在 $p$ 和 $q$ 具有相同真值时为真的公式的集合。\n\n3) 确定 Lindenbaum-Tarski 代数 $\\mathcal{L}_{\\Gamma}$ 的基数。\n\n集合 $\\mathcal{L}_{\\Gamma}$ 是 $L$-公式在关系 $\\equiv_{\\Gamma}$ 下的等价类集合。该关系定义为：\n$$ \\varphi \\equiv_{\\Gamma} \\psi \\iff \\Gamma \\vdash \\varphi \\leftrightarrow \\psi $$\n再次使用完备性定理，这等价于：\n$$ \\varphi \\equiv_{\\Gamma} \\psi \\iff \\Gamma \\models \\varphi \\leftrightarrow \\psi $$\n条件 $\\Gamma \\models \\varphi \\leftrightarrow \\psi$ 意味着对于 $\\Gamma$ 的每一个模型 $v$，公式 $\\varphi \\leftrightarrow \\psi$ 必须为真。这等价于说，对于 $\\Gamma$ 的每一个模型 $v$，$v(\\varphi) = v(\\psi)$。\n\n从第 2 部分可知，$\\Gamma = \\{p \\leftrightarrow q\\}$ 的模型是 $v_1$ 和 $v_4$。因此，两个公式 $\\varphi$ 和 $\\psi$ 模 $\\Gamma$ 等价，当且仅当它们在这两个模型下具有相同的真值：\n$$ \\varphi \\equiv_{\\Gamma} \\psi \\iff (v_1(\\varphi) = v_1(\\psi) \\text{ and } v_4(\\varphi) = v_4(\\psi)) $$\n这意味着一个等价类 $[\\varphi]_{\\equiv_{\\Gamma}}$ 由真值对 $(v_1(\\varphi), v_4(\\varphi))$ 唯一确定。一个公式在给定赋值下的真值可以是真（$T$）或假（$F$）。因此，最多有 $2 \\times 2 = 4$ 种可能的真值对，从而最多有 $4$ 个不同的等价类。这些可能的行为是 $(T,T)$, $(T,F)$, $(F,T)$ 和 $(F,F)$。\n\n为证明恰好有 4 个类，我们必须证明这四种行为中的每一种都可以由语言 $L$ 中的至少一个公式实现。\n\n\\begin{itemize}\n    \\item **行为 $(T,T)$**：我们需要一个公式 $\\varphi$ 使得 $v_1(\\varphi)=T$ 且 $v_4(\\varphi)=T$。任何重言式，例如 $\\varphi_1 = p \\to p$，都满足这个条件。它对于所有赋值的真值都是 $T$。所以，$[\\varphi_1]$ 对应于 $(T,T)$。集合 $\\operatorname{Th}(\\Gamma)$ 本身就是这个等价类，因为 $\\varphi \\in \\operatorname{Th}(\\Gamma)$ 意味着 $\\Gamma \\vdash \\varphi \\leftrightarrow (p \\to p)$。\n\n    \\item **行为 $(T,F)$**：我们需要一个公式 $\\varphi$ 使得 $v_1(\\varphi)=T$ 且 $v_4(\\varphi)=F$。我们来测试 $\\varphi_2 = p$。$v_1(p)=T$ 因为在 $v_1$ 中 $p$ 被赋值为真。$v_4(p)=F$ 因为在 $v_4$ 中 $p$ 被赋值为假。所以，公式 $p$ 实现了行为 $(T,F)$。公式 $q$ 也实现了这个行为，而且确实有 $p \\equiv_\\Gamma q$，因为 $\\Gamma \\vdash p \\leftrightarrow q$。所以 $[\\varphi_2] = [p]_\\Gamma$ 对应于 $(T,F)$。\n\n    \\item **行为 $(F,T)$**：我们需要一个公式 $\\varphi$ 使得 $v_1(\\varphi)=F$ 且 $v_4(\\varphi)=T$。我们来测试 $\\varphi_3 = \\lnot p$。$v_1(\\lnot p) = \\lnot v_1(p) = \\lnot T = F$。$v_4(\\lnot p) = \\lnot v_4(p) = \\lnot F = T$。所以，公式 $\\lnot p$ 实现了行为 $(F,T)$。公式 $\\lnot q$ 也是如此，且有 $\\lnot p \\equiv_\\Gamma \\lnot q$。所以 $[\\varphi_3] = [\\lnot p]_\\Gamma$ 对应于 $(F,T)$。\n\n    \\item **行为 $(F,F)$**：我们需要一个公式 $\\varphi$ 使得 $v_1(\\varphi)=F$ 且 $v_4(\\varphi)=F$。任何矛盾式，例如 $\\varphi_4 = p \\land \\lnot p$，都满足这个条件。它对于所有赋值的真值都是 $F$。所以，$[\\varphi_4]$ 对应于 $(F,F)$。\n\\end{itemize}\n\n因为我们已经为 $\\Gamma$ 模型上的四种可能的真值对中的每一种找到了对应的公式，所以恰好存在四个不同的等价类。\n\n因此，Lindenbaum-Tarski 代数 $\\mathcal{L}_{\\Gamma}$ 的基数 $N$ 是 4。", "answer": "$$\\boxed{4}$$", "id": "3057851"}, {"introduction": "逻辑学的探索不止于证明定理，更在于理解公理系统本身的性质，尤其是其计算特性。这个终极练习将带你进入元数学的迷人领域，体验哥德尔配数法（Gödel numbering）的威力[@problem_id:3057862]。通过将句法和证明过程算术化，你将学习如何形式化“证明”这一概念，并最终论证一个公理模式所生成的所有定理的集合是递归可枚举的（recursively enumerable），这为你一窥哥德尔不完备性定理的深刻思想提供了具体实践。", "problem": "设 $\\mathcal{L}_{\\to}$ 是一个命题语言，它只有一个命题字母 $p$ 和一个二元联结词 $\\to$。公式是完全加括号的。考虑希尔伯特公理模式 $\\mathrm{Ax}_{1}$，由 $A \\to (B \\to A)$ 给出，其中 $A$ 和 $B$ 遍历所有 $\\mathcal{L}_{\\to}$-公式。我们对字母表 $\\Sigma=\\{(,),\\to,p\\}$ 上的有限符号串使用以下哥德尔编码。\n\n1. 分配符号代码：$c(()=1$，$c())=2$，$c(\\to)=3$，$c(p)=4$。\n2. 令 $\\pi_0=2,\\pi_1=3,\\pi_2=5,\\pi_3=7,\\ldots$ 是递增的素数序列。如果一个有限串的符号代码序列为 $(a_0,\\ldots,a_{n-1})$，定义其哥德尔码为\n$$\n\\langle a_0,\\ldots,a_{n-1}\\rangle \\;=\\; \\left(\\prod_{i=0}^{n-1} \\pi_i^{\\,a_i+1}\\right)\\cdot \\pi_n.\n$$\n因此，末尾的因子 $\\pi_n$ 用来编码长度。\n\n你可以不加证明地使用以下基础事实和定义：原始递归函数类在复合和原始递归下是封闭的；$p$-进赋值 $\\nu_{p}(x)$ 是原始递归的；返回第 $i$ 个素数 $\\pi_i$ 的函数是原始递归的；以及在上述编码下对有限序列的基本操作（长度、第 $i$ 个条目、连接）是原始递归的。\n\n任务 A. 显式定义一个原始递归函数 $g\\colon \\mathbb{N}\\to\\mathbb{N}$，其值域恰好是 $\\mathcal{L}_{\\to}$-公式的哥德尔码集合。你的 $g$ 必须通过对 $n$ 的原始递归来定义，并且只使用原始递归的子程序。然后定义一个原始递归函数 $E\\colon \\mathbb{N}\\to\\mathbb{N}$，使得 $E(n)$ 是公理实例 $A \\to (B \\to A)$ 的哥德尔码，其中 $A$ 是由 $g(\\nu_{2}(n))$ 编码的公式，$B$ 是由 $g(\\nu_{3}(n))$ 编码的公式。\n\n任务 B. 使用 $E$，定义一个原始递归二元关系 $\\mathrm{Proof}(s,\\varphi)$，它形式化了“$s$ 是一个有限希尔伯特式证明的哥德尔码，该证明的最后一行是哥德尔码为 $\\varphi$ 的公式”，其中唯一的公理模式是由 $E$ 生成的 $\\mathrm{Ax}_{1}$ 的实例，唯一的推理规则是肯定前件。从第一性原理证明集合 $\\mathrm{Th}=\\{\\varphi \\in \\mathbb{N} \\mid \\exists s\\, \\mathrm{Proof}(s,\\varphi)\\}$ 是递归可枚举的（递归可枚举 (r.e.) 指的是存在一个原始递归谓词 $R(s,\\varphi)$ 使得 $\\varphi\\in \\mathrm{Th}$ 当且仅当 $\\exists s\\,R(s,\\varphi)$）。\n\n任务 C. 计算特定公理实例 $(p \\to (p \\to p))$ 的哥德尔数（在上述编码下）。你的最终答案必须是一个单一的精确表达式。不要进行数值简化；将其表示为带有指数的素数的有限乘积。不需要四舍五入。", "solution": "该问题提出了一个分为三部分的任务，涉及哥德尔编码、原始递归函数以及一个简单命题逻辑中定理集合的递归可枚举性。该问题陈述在数理逻辑领域内被验证为是合理的、自洽的且良构的。\n\n### 任务 A：函数 $g$ 和 $E$ 的定义\n\n$\\mathcal{L}_{\\to}$-公式的集合是归纳定义的：\n1.  命题字母 $p$ 是一个公式。\n2.  如果 $A$ 和 $B$ 是公式，那么 $(A \\to B)$ 是一个公式。\n\n我们被要求定义一个原始递归(PR)函数 $g \\colon \\mathbb{N} \\to \\mathbb{N}$，其值域是所有这类公式的哥德尔码的集合。该函数必须通过对 $n$ 的原始递归来定义。这表明需要一种通过从较简单的公式构建更复杂公式的枚举方法。\n\n令 $\\pi(i,j) = \\frac{1}{2}(i+j)(i+j+1)+j$ 为康托尔配对函数（Cantor pairing function），它是一个从 $\\mathbb{N}^2$到 $\\mathbb{N}$ 的原始递归双射。令 $\\pi_1(n)$ 和 $\\pi_2(n)$ 为其原始递归的反函数，使得 $\\pi(\\pi_1(n), \\pi_2(n)) = n$。\n\n首先，我们定义单个符号的哥德尔码，它们是常量：\n$\\ulcorner(\\urcorner = \\langle c(() \\rangle = \\langle 1 \\rangle = \\pi_0^{1+1} \\cdot \\pi_1 = 2^2 \\cdot 3$。\n$\\ulcorner)\\urcorner = \\langle c()) \\rangle = \\langle 2 \\rangle = \\pi_0^{2+1} \\cdot \\pi_1 = 2^3 \\cdot 3$。\n$\\ulcorner\\to\\urcorner = \\langle c(\\to) \\rangle = \\langle 3 \\rangle = \\pi_0^{3+1} \\cdot \\pi_1 = 2^4 \\cdot 3$。\n$\\ulcorner p\\urcorner = \\langle c(p) \\rangle = \\langle 4 \\rangle = \\pi_0^{4+1} \\cdot \\pi_1 = 2^5 \\cdot 3$。\n\n我们还假设存在一个原始递归函数 $\\mathrm{concat}(s_1, \\dots, s_k)$，它接受若干字符串的哥德尔码并返回它们连接后的哥德尔码。这是原始递归函数理论中的一个标准结果。\n\n我们如下定义函数 $g(n)$：\n- **基本情况：** $g(0) = \\ulcorner p \\urcorner = 2^5 \\cdot 3$。\n- **递归步骤：** 对于 $n  0$，令 $n-1 = \\pi(i,j)$，其中 $i=\\pi_1(n-1)$ 且 $j=\\pi_2(n-1)$。我们定义 $g(n)$ 为公式 $(A \\to B)$ 的哥德尔码，其中 $A$ 是码为 $g(i)$ 的公式，$B$ 是码为 $g(j)$ 的公式。因此，\n$$\ng(n) = \\mathrm{concat}(\\ulcorner(\\urcorner, g(\\pi_1(n-1)), \\ulcorner\\to\\urcorner, g(\\pi_2(n-1)), \\ulcorner)\\urcorner) \\quad \\text{for } n0\n$$\n这个定义确保了 $g$ 的值域恰好是 $\\mathcal{L}_{\\to}$-公式的哥德尔码集合。基本情况提供了原子公式。递归步骤从任意两个先前生成的公式 $A$ 和 $B$ 生成所有可能的复合公式 $(A \\to B)$，因为 $\\pi$ 是一个双射，对于任何索引对 $(i,j)$，存在一个唯一的 $n = \\pi(i,j)+1$ 来组合公式 $g(i)$ 和 $g(j)$。\n\n这个定义是行程值递归（course-of-values recursion）的一个实例，因为 $g(n)$ 依赖于 $g(i)$ 和 $g(j)$ 的值，其中 $i,j  n$（因为 $\\pi_1(k), \\pi_2(k) \\le k$）。已知行程值递归可以归约为原始递归。我们可以定义一个辅助函数 $\\bar{g}(n) = \\prod_{k=0}^{n-1} \\pi_k^{g(k)}$，它编码了序列 $(g(0), \\ldots, g(n-1))$。$\\bar{g}(n)$ 可以通过原始递归定义，然后 $g(n)$ 可以用 $\\bar{g}(n)$ 来定义。因此，$g(n)$ 是一个原始递归函数。\n\n接下来，我们定义原始递归函数 $E(n)$。$E(n)$ 是公理实例 $A \\to (B \\to A)$ 的哥德尔码，其中 $A$ 是由 $g(\\nu_{2}(n))$ 编码的公式，$B$ 是由 $g(\\nu_{3}(n))$ 编码的公式。令 $\\varphi_A = g(\\nu_{2}(n))$ 和 $\\varphi_B = g(\\nu_{3}(n))$。\n首先，我们构建子公式 $(B \\to A)$ 的码：\n$$\n\\varphi_{(B \\to A)} = \\mathrm{concat}(\\ulcorner(\\urcorner, \\varphi_B, \\ulcorner\\to\\urcorner, \\varphi_A, \\ulcorner)\\urcorner)\n$$\n然后，我们构建完整公理实例 $(A \\to (B \\to A))$ 的码：\n$$\nE(n) = \\mathrm{concat}(\\ulcorner(\\urcorner, \\varphi_A, \\ulcorner\\to\\urcorner, \\varphi_{(B \\to A)}, \\ulcorner)\\urcorner)\n$$\n函数 $E(n)$ 是通过函数 $g$、$\\nu_2$、$\\nu_3$、$\\mathrm{concat}$ 和常数函数的复合来构造的。由于所有这些函数都是原始递归的，并且PR函数类在复合运算下是封闭的，所以 $E(n)$ 是一个原始递归函数。\n\n### 任务 B：关系 $\\mathrm{Proof}(s,\\varphi)$ 和 $\\mathrm{Th}$ 的递归可枚举性\n\n我们被要求定义一个原始递归二元关系 $\\mathrm{Proof}(s,\\varphi)$，它形式化了 $s$ 是一个证明了码为 $\\varphi$ 的公式的证明的码。一个证明是一个有限的公式序列，其中每个公式要么是一个公理，要么是通过肯定前件（Modus Ponens）从前面的两个公式推导出来的。\n\n首先，让我们建立一种处理哥德尔数序列的原始递归方法。一个有限的数字序列 $(\\varphi_0, \\varphi_1, \\ldots, \\varphi_k)$ 可以被一个单一的数 $s$ 编码，例如，$s = \\prod_{i=0}^k \\pi_i^{\\varphi_i+1}$。从 $s$ 中，序列的长度 $k+1$ 及其元素 $\\varphi_i$ 可以通过PR函数检索。令 $\\mathrm{len}(s)$ 和 $\\mathrm{get}(s,i)$ 为这样的PR函数。\n\n关系 $\\mathrm{Proof}(s,\\varphi)$ 必须是原始递归的。这意味着检查一个公式是否是公理或肯定前件的结果必须是一个PR操作。\n\n1.  **公理检查**：一个码为 $\\psi$ 的公式是公理，如果它在由 $E$ 生成的 $\\mathrm{Ax}_1$ 实例集合中。如在任务A中所确立的，$g$ 的值域是所有公式码的集合。由于当 $n$ 遍历 $\\mathbb{N}$ 时，$\\nu_2(n)$ 和 $\\nu_3(n)$ 都遍历所有自然数，因此项 $g(\\nu_2(n))$ 和 $g(\\nu_3(n))$ 遍历所有可能的公式码。因此，$E$ 的值域是所有句法上有效的模式 $A \\to (B \\to A)$ 的实例的哥德尔码的集合。\n    因此，要检查一个码为 $\\psi$ 的公式是否是公理，我们不需要检查 $\\psi \\in \\mathrm{range}(E)$。我们只需要检查由 $\\psi$ 表示的公式是否具有句法结构 $(A \\to (B \\to A))$，其中 $A$ 和 $B$ 是某些合式公式。这个检查可以通过一个PR函数 $\\mathrm{IsAxiom}(\\psi)$ 来执行，该函数解析由 $\\psi$ 编码的字符串。解析涉及查找子串和检查括号平衡，这些都是基于算术哥德尔编码的PR操作。\n\n2.  **肯定前件检查**：一个公式 $\\psi_k$ 通过肯定前件（MP）从 $\\psi_i$ 和 $\\psi_j$（$i,j  k$）得出，如果 $\\psi_j$ 的公式形式为 $(A \\to B)$，$\\psi_i$ 的公式为 $A$，而 $\\psi_k$ 的公式为 $B$。这个检查对应于验证 $\\psi_j = \\mathrm{concat}(\\ulcorner(\\urcorner, \\psi_i, \\ulcorner\\to\\urcorner, \\psi_k, \\ulcorner)\\urcorner)$ 是否成立。这是一个PR关系，我们记作 $\\mathrm{IsMP}(\\psi_k, \\psi_i, \\psi_j)$。\n\n有了这些构建块，我们可以定义 $\\mathrm{Proof}(s,\\varphi)$：\n$\\mathrm{Proof}(s, \\varphi) \\iff$\n  (1) $\\mathrm{get}(s, \\mathrm{len}(s)-1) = \\varphi$\n  $\\land$\n  (2) $(\\forall i  \\mathrm{len}(s)) \\Big[ \\mathrm{IsAxiom}(\\mathrm{get}(s,i)) \\lor \\big( (\\exists j  i)(\\exists k  i) \\mathrm{IsMP}(\\mathrm{get}(s,i), \\mathrm{get}(s,k), \\mathrm{get}(s,j)) \\big) \\Big]$\n\n这个定义使用了有界全称量词（$\\forall i  N$）和存在量词（$\\exists j  N$），以及PR谓词（$\\mathrm{get}$, $\\mathrm{len}$, $\\mathrm{IsAxiom}$, $\\mathrm{IsMP}$）的布尔组合。原始递归关系类在这些操作下是封闭的。因此，$\\mathrm{Proof}(s,\\varphi)$ 是一个原始递归二元关系。\n\n现在，我们证明定理集合 $\\mathrm{Th} = \\{\\varphi \\in \\mathbb{N} \\mid \\exists s\\, \\mathrm{Proof}(s,\\varphi)\\}$ 是递归可枚举的（r.e.）。\n根据定义，一个集合 $X$ 是 r.e. 的，如果存在一个原始递归谓词 $R(s,x)$ 使得 $x \\in X \\iff \\exists s, R(s,x)$。\n对于集合 $\\mathrm{Th}$，我们正好构造了这样一个谓词，即 $\\mathrm{Proof}(s,\\varphi)$。\n因此，$\\varphi \\in \\mathrm{Th} \\iff \\exists s, \\mathrm{Proof}(s,\\varphi)$。\n由于 $\\mathrm{Proof}(s,\\varphi)$ 是一个原始递归关系，根据定义，集合 $\\mathrm{Th}$ 是递归可枚举的。\n\n### 任务 C：计算哥德尔数\n\n我们需要计算公式 $(p \\to (p \\to p))$ 的哥德尔数。\n符号序列为：$(, p, \\to, (, p, \\to, p, ), )$。\n该序列的长度为 $n=9$。\n符号代码为：$c(()=1$, $c())=2$, $c(\\to)=3$, $c(p)=4$。\n符号代码序列 $(a_0, a_1, \\ldots, a_8)$ 为：\n$a_0 = c(() = 1$\n$a_1 = c(p) = 4$\n$a_2 = c(\\to) = 3$\n$a_3 = c(() = 1$\n$a_4 = c(p) = 4$\n$a_5 = c(\\to) = 3$\n$a_6 = c(p) = 4$\n$a_7 = c()) = 2$\n$a_8 = c()) = 2$\n\n哥德尔码由公式 $\\langle a_0,\\ldots,a_{n-1}\\rangle = \\left(\\prod_{i=0}^{n-1} \\pi_i^{\\,a_i+1}\\right)\\cdot \\pi_n$ 给出，其中 $\\pi_i$ 是第 $i$ 个素数（$\\pi_0=2, \\pi_1=3, \\ldots$）。\n对于 $n=9$，该公式变为：\n$$\n\\langle a_0,\\ldots,a_8\\rangle = \\left(\\prod_{i=0}^{8} \\pi_i^{\\,a_i+1}\\right)\\cdot \\pi_9\n$$\n我们列出所需的素数：$\\pi_0=2, \\pi_1=3, \\pi_2=5, \\pi_3=7, \\pi_4=11, \\pi_5=13, \\pi_6=17, \\pi_7=19, \\pi_8=23, \\pi_9=29$。\n\n现在我们计算指数 $a_i+1$：\n$a_0+1 = 1+1 = 2$\n$a_1+1 = 4+1 = 5$\n$a_2+1 = 3+1 = 4$\n$a_3+1 = 1+1 = 2$\n$a_4+1 = 4+1 = 5$\n$a_5+1 = 3+1 = 4$\n$a_6+1 = 4+1 = 5$\n$a_7+1 = 2+1 = 3$\n$a_8+1 = 2+1 = 3$\n\n乘积部分是：\n$\\pi_0^{a_0+1} \\cdot \\pi_1^{a_1+1} \\cdot \\pi_2^{a_2+1} \\cdot \\pi_3^{a_3+1} \\cdot \\pi_4^{a_4+1} \\cdot \\pi_5^{a_5+1} \\cdot \\pi_6^{a_6+1} \\cdot \\pi_7^{a_7+1} \\cdot \\pi_8^{a_8+1}$\n$= 2^{2} \\cdot 3^{5} \\cdot 5^{4} \\cdot 7^{2} \\cdot 11^{5} \\cdot 13^{4} \\cdot 17^{5} \\cdot 19^{3} \\cdot 23^{3}$\n\n最后，我们乘以长度编码因子 $\\pi_9=29$：\n哥德尔数 $= 2^2 \\cdot 3^5 \\cdot 5^4 \\cdot 7^2 \\cdot 11^5 \\cdot 13^4 \\cdot 17^5 \\cdot 19^3 \\cdot 23^3 \\cdot 29$。", "answer": "$$\\boxed{2^2 \\cdot 3^5 \\cdot 5^4 \\cdot 7^2 \\cdot 11^5 \\cdot 13^4 \\cdot 17^5 \\cdot 19^3 \\cdot 23^3 \\cdot 29}$$", "id": "3057862"}]}