{"hands_on_practices": [{"introduction": "要掌握算术层级，第一步是能够对一个给定的公式进行准确分类。本练习将引导你直接应用 $\\Sigma_{n}^{0}$ 和 $\\Pi_{n}^{0}$ 类的定义，通过分析一个处于前束范式（prenex normal form）的公式，练习如何识别其量词前束的结构、计算量词交错的次数，并最终确定其所属的层级。这个过程是理解量词复杂性如何决定问题可计算性复杂度的基础。[@problem_id:3055111]", "problem": "设所有量词的作用范围是自然数集 $\\mathbb{N}$。考虑语句 $\\varphi := \\exists x\\, \\forall y\\, \\exists z\\, R(x,y,z)$，其中 $R$ 是 $\\mathbb{N}^{3}$ 上的一个固定的原始递归关系。仅使用算术分层的定义和性质，根据前束范式的标准分类，确定 $\\varphi$ 所属的算术类。你的论证必须明确引用 $R$ 的原始递归性以及无界量词的交替模式所起的作用。在你的论证中，解释为什么这种分类在一般情况下是最优的，即存在一些原始递归关系，使得该量词模式不能被降低到分层结构中任何严格更低的层级。将你的最终分类写成 $\\Sigma^{0}_{n}$ 或 $\\Pi^{0}_{n}$ 形式的单个表达式。", "solution": "该问题要求在算术分层中对语句 $\\varphi := \\exists x\\, \\forall y\\, \\exists z\\, R(x,y,z)$ 进行分类，其中 $R$ 是 $\\mathbb{N}^{3}$ 上的一个原始递归关系。\n\n算术分层根据自然数集（并由此引申到关于自然数的逻辑公式）在前束范式中定义的复杂性对其进行分类。一个集合 $S \\subseteq \\mathbb{N}^k$ 的分类是基于定义它的公式中量词的结构，前提是该公式的无量词部分（基式）描述了一个递归关系。\n\n类 $\\Sigma^{0}_{n}$ 和 $\\Pi^{0}_{n}$ 是对 $n \\in \\mathbb{N}$ 归纳定义的。\n如果一个关系是递归关系，那么它就在 $\\Sigma^{0}_{0} = \\Pi^{0}_{0}$ 中。这些关系的特征函数是全递归函数。\n\n对于 $n \\ge 1$，一个关系 $P(\\vec{a})$ 属于 $\\Sigma^{0}_{n}$，如果它等价于一个形如\n$$\n\\exists x_1 \\forall x_2 \\dots Q x_n S(\\vec{a}, x_1, \\dots, x_n)\n$$\n的公式，其中 $S$ 是一个递归关系，量词前束由 $n$ 个交替的同类量词块组成，以存在量词开始。符号 $Q$ 表示 $\\exists$ 或 $\\forall$，取决于 $n$ 的奇偶性。\n\n类似地，对于 $n \\ge 1$，一个关系 $P(\\vec{a})$ 属于 $\\Pi^{0}_{n}$，如果它等价于一个形如\n$$\n\\forall x_1 \\exists x_2 \\dots Q x_n S(\\vec{a}, x_1, \\dots, x_n)\n$$\n的公式，其中 $S$ 是一个递归关系，量词前束由 $n$ 个交替的同类量词块组成，以全称量词开始。\n\n我们给定的语句是 $\\varphi := \\exists x\\, \\forall y\\, \\exists z\\, R(x,y,z)$。\n首先，我们分析此公式的基式，即关系 $R(x,y,z)$。问题陈述 $R$ 是一个原始递归关系。可计算性理论中的一个基本结果是，每个原始递归关系也是一个递归关系。递归关系集真包含原始递归关系集。因此，基式 $R(x,y,z)$ 满足算术分层定义所要求的递归性条件。\n\n接下来，我们分析公式的量词前束：$\\exists x\\, \\forall y\\, \\exists z$。该公式已经是前束范式。我们计算量词交替块的数量。\n1. 第一个块是 $\\exists x$ (存在量词)。\n2. 第二个块是 $\\forall y$ (全称量词)。\n3. 第三个块是 $\\exists z$ (存在量词)。\n\n从第一个块 ($\\exists$) 到第二个块 ($\\forall$) 有一次交替，从第二个块 ($\\forall$) 到第三个块 ($\\exists$) 有另一次交替。量词块的总数是 $n=3$。\n\n分类为 $\\Sigma^{0}_{n}$ 还是 $\\Pi^{0}_{n}$ 由前束中的第一个量词决定。由于第一个量词是存在量词 ($\\exists$)，该公式属于类 $\\Sigma^{0}_{n}$。当 $n=3$ 时，语句 $\\varphi$ 属于类 $\\Sigma^{0}_{3}$。\n\n该问题还要求解释为什么这种分类是最优的，即存在原始递归关系 $R$，使得该量词结构不能简化到分层结构中严格更低的层级（例如 $\\Sigma^{0}_{2}$ 或 $\\Pi^{0}_{2}$）。\n\n这种分类的最优性是 Kleene-Post 分层定理的直接推论。该定理确立了算术分层是严格的，这意味着对于每个 $n \\ge 1$：\n$$\n\\Sigma^{0}_{n} \\subsetneq \\Pi^{0}_{n+1} \\quad \\text{and} \\quad \\Pi^{0}_{n} \\subsetneq \\Sigma^{0}_{n+1}\n$$\n这意味着 $\\Sigma^{0}_{n} \\cup \\Pi^{0}_{n}$ 是 $\\Sigma^{0}_{n+1} \\cap \\Pi^{0}_{n+1}$ 的真子集。具体来说，对于 $n=3$，这意味着 $\\Sigma^{0}_{3}$ 不包含在 $\\Pi^0_2$ 或 $\\Sigma^0_2$ 中。\n\n为了具体地证明这种最优性，可以构造一个 $\\Sigma^{0}_{3}$-完全集。一个集合是 $\\Sigma^{0}_{3}$-完全的，如果它属于 $\\Sigma^{0}_{3}$，并且每个其他 $\\Sigma^{0}_{3}$ 集合都可以多一归约到它。根据定义，一个类的完全集不能属于分层结构中的任何更低层级（假设分层结构不塌陷）。\n\n存在一些典范的 $\\Sigma^{0}_{3}$-完全集，可以精确地表示为给定形式。例如，其定义域为余有限的图灵机指数集，记为 COFIN，是一个著名的 $\\Sigma^{0}_{3}$-完全集。语句“$W_e$ 是余有限的”，其中 $W_e$ 是第 $e$ 个部分递归函数的定义域，可以表述为：\n$$\ne \\in \\text{COFIN} \\iff \\exists n \\forall m > n \\exists s \\, (T(e, m, s))\n$$\n其中 $T(e,m,s)$ 是 Kleene T-谓词，如果第 $e$ 个图灵机在输入 $m$ 上恰好在 $s$ 步后停机，则该谓词为真。Kleene T-谓词是原始递归的。有界量词 $\\forall m > n$ 可以被吸收到一个新的原始递归谓词中，从而得到一个具有 $\\exists n \\forall m' \\exists s' \\, R(e,n,m',s')$ 结构的公式，其中 $R$ 是原始递归的。通过重新标记变量，这与结构 $\\exists x \\forall y \\exists z R'(x,y,z)$ 相匹配。\n\n由于存在这样一个谓词 $R$，使得该公式定义了一个 $\\Sigma^{0}_{3}$-完全集，所以这个集合不能用任何更低层级（如 $\\Sigma^{0}_{2}$ 或 $\\Pi^{0}_{2}$）的公式来描述。因此，对于一般情况下的 $\\exists \\forall \\exists R(\\dots)$ 形式的公式，分类 $\\Sigma^{0}_{3}$ 是最紧密的可能分类，这证明了其最优性。", "answer": "$$\\boxed{\\Sigma^{0}_{3}}$$", "id": "3055111"}, {"introduction": "在算术公式中，并非所有量词都会增加其在层级中的复杂性。本练习将探讨一个关键概念：有界量词，并说明为何它们不会提升公式的层级。你将通过一个精巧的逻辑转换，学习如何将一个看似复杂的量词结构（包含有界量词）等价地转化为一个更简单的形式，这深刻揭示了递归函数在编码有限信息方面的能力。[@problem_id:3055121]", "problem": "在一阶算术的标准语言中，其符号为 $0$、$S$、$+$ 和 $\\times$，令 $g(x)$ 为一个项，并令 $S(x,y,z)$ 为一个 $\\Delta_{0}$ 公式（即一个所有量词均为有界量词的公式）。考虑公式\n$$\n\\varphi \\;\\equiv\\; \\exists x\\, \\forall y  g(x) \\, \\exists z \\, S(x,y,z)\n$$\n证明 $\\varphi$ 等价于一个 $\\Sigma_1^0$ 公式。", "solution": "该问题的目标是证明公式 $\\varphi \\equiv \\exists x\\, \\forall y  g(x) \\, \\exists z \\, S(x,y,z)$ 等价于一个 $\\Sigma_1^0$ 公式，其中 $S$ 是一个 $\\Delta_0$（递归）公式。\n\n根据定义，一个公式是 $\\Sigma_1^0$ 的，如果它可以表示为 $\\exists w \\, R(w, \\dots)$ 的形式，其中 $R$ 是一个递归谓词（关系）。\n\n我们的公式 $\\varphi$ 包含一个有界的全称量词 $\\forall y  g(x)$ 嵌套在一个无界的存在量词 $\\exists x$ 和另一个无界的存在量词 $\\exists z$ 之间。我们的策略是将内部的量词结构“吸收”到一个单一的存在量词中。\n\n公式 $\\varphi$ 为真，当且仅当：\n存在一个自然数 $x$，使得对于所有小于 $g(x)$ 的自然数 $y$（即 $y = 0, 1, \\dots, g(x)-1$），都存在一个自然数 $z_y$ 使得 $S(x, y, z_y)$ 成立。\n\n这里的关键思想是，我们可以将为每个 $y$ 找到的所有“见证者” $z_0, z_1, \\dots, z_{g(x)-1}$ 编码成一个单一的自然数。在可计算性理论中，有标准的方法（如哥德尔编码或使用配对函数）来编码有限序列。假设我们有一个编码函数 `encode` 和一个解码函数 `decode(w, i)` (通常写作 $(w)_i$)，它们都是原始递归的，因此也是递归的。`encode` 可以将一个序列 $[z_0, \\dots, z_k]$ 编码成一个数 $w$，而 `decode(w, i)` 可以从 $w$ 中解码出第 $i$ 个元素 $z_i$。\n\n利用这个工具，我们可以重写 $\\varphi$。$\\varphi$ 等价于声称存在一个 $x$ 和一个编码了所有必要见证者 $z_y$ 的数 $w$：\n$$ \\exists x \\exists w \\left( \\text{IsSequenceOfLength}(w, g(x)) \\land \\forall y  g(x) \\, S(x, y, (w)_y) \\right) $$\n在这里：\n1.  `IsSequenceOfLength(w, g(x))` 是一个递归谓词，它检查 $w$ 是否正确地编码了一个长度为 $g(x)$ 的序列。\n2.  $(w)_y$ 是一个递归函数，用于从 $w$ 中解码出第 $y$ 个元素。\n3.  $S(x, y, (w)_y)$ 是一个递归谓词，因为 $S$ 是递归的，$(w)_y$ 是递归函数，而递归谓词在递归函数代入后仍然是递归的。\n4.  $\\forall y  g(x) \\, \\dots$ 是一个有界量化。一个关于递归谓词的有界量化仍然是递归的。这是因为要检查 `for all y  g(x)`，我们只需要对有限数量的 $y$ 值（从 $0$ 到 $g(x)-1$）进行检查，这可以在有限时间内完成。\n5.  因此，整个方括号内的表达式，我们称之为 $R(x,w)$，是一个递归谓词，因为它是由递归谓词和函数通过合取 ($\\land$) 和有界量化构成的。\n\n现在我们的公式变成了 $\\exists x \\exists w \\, R(x,w)$。两个相邻的存在量词可以合并成一个。我们可以定义一个新的数 $v = \\langle x, w \\rangle$ (使用一个递归的配对函数)。那么公式就等价于：\n$$ \\exists v \\, R((v)_0, (v)_1) $$\n令 $R'(v) = R((v)_0, (v)_1)$。由于 $R$ 和解码函数 $(v)_0, (v)_1$ 都是递归的，所以 $R'(v)$ 也是一个递归谓词。\n\n最终，我们已经将 $\\varphi$ 转换成了 $\\exists v \\, R'(v)$ 的形式，其中 $R'$ 是一个递归谓词。这正是 $\\Sigma_1^0$ 公式的定义。因此，$\\varphi$ 属于 $\\Sigma_1^0$ 类。", "answer": "$$\\boxed{\\Sigma_{1}^{0}}$$", "id": "3055121"}, {"introduction": "将理论知识转化为可执行的步骤是检验理解深度的最佳方式。本练习将挑战你将算术层级的分类规则形式化为一个精确的算法。通过设计一个能够自动处理各种量词前束的程序，你不仅能巩固对 $\\Sigma_n^0$、$\\Pi_n^0$ 和 $\\Delta_n^0$ 定义的理解，还能体会到逻辑、可计算性与计算机科学之间的深刻联系。[@problem_id:3055137]", "problem": "您正在处理自然数上的一阶算术，其中的公式采用前束范式：所有量词都出现在前缀中，其后跟着一个无量词的矩阵。如果量词的形式为 $\\forall x  t\\,\\varphi$ 或 $\\exists x  t\\,\\varphi$（其中 $t$ 是一个项，$\\varphi$ 是一个公式），则称其为有界量词；否则它是无界的（即普通的 $\\forall x\\,\\varphi$ 或 $\\exists x\\,\\varphi$）。在算术分层中，类 $\\Sigma_n^0$ 和 $\\Pi_n^0$ 是根据前缀中无界量词的存在和模式来定义的，有界量词可以出现在任何位置，而矩阵是无量词的。直观地说，无界量词的交替控制着层级 $n$，而有界量词不增加层级。类 $\\Delta_n^0$ 定义为 $\\Sigma_n^0 \\cap \\Pi_n^0$。对于此任务，您必须执行句法分类：当没有无界量词时，公式属于 $\\Delta_0^0$；否则，公式属于 $\\Sigma_n^0$ 或 $\\Pi_n^0$，这取决于第一个无界量词的类型以及前缀中无界量词之间的交替次数。\n\n设计并实现一个算法，该算法接收一个前束范式公式的量词前缀（表示为一个被标注为有界或无界的量词序列），并确定该公式属于 $\\Sigma_n^0$、$\\Pi_n^0$ 还是 $\\Delta_n^0$。您的算法在确定层级和主导类时必须忽略有界量词。输出应编码为一个整数对 $[c,n]$，其中 $c \\in \\{0,1,2\\}$ 编码类（$0$ 代表 $\\Delta_n^0$，$1$ 代表 $\\Sigma_n^0$，$2$ 代表 $\\Pi_n^0$），$n \\in \\mathbb{N}$ 是层级。在纯句法分类下：如果没有无界量词，则输出 $[0,0]$；否则，如果第一个无界量词是 $\\exists$，则输出 $[1,n]$，如果第一个无界量词是 $\\forall$，则输出 $[2,n]$，其中 $n$ 是前缀中无界量词 $\\exists$ 和 $\\forall$ 之间交替的次数加一。\n\n使用以下量词前缀的测试套件。每个测试用例是一个序对 $(q,b)$ 的列表，其中 $q$ 是等于 \"E\"（代表 $\\exists$）或 \"A\"（代表 $\\forall$）的字符串，而 $b$ 是整数 $1$（代表有界）或 $0$（代表无界）。例如，序对 $(\"E\",0)$ 表示一个无界存在量词 $\\exists$，而序对 $(\"A\",1)$ 表示一个有界全称量词，例如 $\\forall x  t$。\n- 测试用例 1: `[]`\n- 测试用例 2: `[(\"E\", 1), (\"A\", 1), (\"E\", 1)]`\n- 测试用例 3: `[(\"E\", 0)]`\n- 测试用例 4: `[(\"A\", 0), (\"A\", 0), (\"A\", 0)]`\n- 测试用例 5: `[(\"E\", 0), (\"A\", 1), (\"A\", 0), (\"E\", 1), (\"E\", 0)]`\n- 测试用例 6: `[(\"A\", 0), (\"E\", 0), (\"A\", 0), (\"E\", 0), (\"A\", 0)]`\n- 测试用例 7: `[(\"E\", 0), (\"E\", 0), (\"A\", 0)]`\n- 测试用例 8: `[(\"E\", 1), (\"A\", 0), (\"E\", 1)]`\n\n你的解决方案应将所有测试用例的结果打印为单个 JSON 格式的列表，例如 `[[c1,n1],[c2,n2],...]`。", "solution": "该问题要求实现一个算法，将一阶算术公式按照算术分层进行句法分类。分类基于公式前束范式的前缀。输入是一个量词序列，每个量词都标记为有界或无界。输出必须是一个序对 $[c,n]$，其中 $c$ 编码类（$\\Delta$、$\\Sigma$ 或 $\\Pi$），$n$ 是分层中的层级。\n\n为该句法分类提供的规则是精确的，可以直接转化为算法。核心原则如下：\n$1$. 分类完全由**无界**量词的序列决定。有界量词被忽略。\n$2$. 没有无界量词的公式属于类 $\\Delta_0^0$。\n$3$. 如果存在无界量词，则类由第一个无界量词的类型决定。存在量词（$\\exists$，表示为 \"E\"）对应于类 $\\Sigma_n^0$，全称量词（$\\forall$，表示为 \"A\"）对应于类 $\\Pi_n^0$。\n$4$. 层级 $n$ 定义为无界量词序列中 $\\forall$ 和 $\\exists$ 之间交替的次数加 $1$。\n\n设输入前缀为一个序对 $(q, b)$ 的列表，其中 $q$ 是量词类型（\"E\" 或 \"A\"），$b$ 是一个标志，其中 $b=0$ 表示无界，$b=1$ 表示有界。算法按以下步骤进行：\n\n**步骤 1：分离无界量词**\n首先，我们过滤输入列表，创建一个只包含无界量词的新的有序序列。当且仅当输入项 $(q, b)$ 的有界性标志 $b$ 等于 $0$ 时，它才被包含在内。将这个新的量词类型序列记为 $Q_U$。\n\n**步骤 2：基本情况分析 ($\\Delta_0^0$)**\n我们检查序列 $Q_U$。如果 $Q_U$ 为空，则意味着公式前缀中没有无界量词。根据问题的定义，这样的公式被分类为属于 $\\Delta_0^0$。这对应于输出序对 $[c,n]$ 为 $[0,0]$，其中 $c=0$ 代表 $\\Delta$，$n=0$ 是层级。\n\n**步骤 3：一般情况分析 ($\\Sigma_n^0$ 或 $\\Pi_n^0$)**\n如果序列 $Q_U$ 不为空，则公式被分类为 $\\Sigma_n^0$ 或 $\\Pi_n^0$。分类涉及确定类 $c$ 和层级 $n$。\n\n**步骤 3a：确定类 ($c$)**\n类由序列 $Q_U$ 中的第一个量词决定。\n- 如果 $Q_U$ 的第一个元素是 \"E\"（代表 $\\exists$），则公式属于一个 $\\Sigma$ 类。类代码 $c$ 设为 $1$。\n- 如果 $Q_U$ 的第一个元素是 \"A\"（代表 $\\forall$），则公式属于一个 $\\Pi$ 类。类代码 $c$ 设为 $2$。\n\n**步骤 3b：确定层级 ($n$)**\n层级 $n$ 根据序列 $Q_U$ 内量词类型的交替次数计算。当量词后面跟着一个不同类型的量词时，就发生了一次交替。对于序列 $Q_U = [q_1, q_2, \\dots, q_k]$，交替次数是满足 $q_i \\neq q_{i+1}$ 的索引 $i$（从 $1$ 到 $k-1$）的数量。\n设交替次数为 $A$。层级 $n$ 定义为 $n = A + 1$。\n\n例如，考虑无界量词序列 $Q_U = [\\text{\"E\"}, \\text{\"A\"}, \\text{\"A\"}, \\text{\"E\"}]$。\n- 第一个量词是 \"E\"，所以类是 $\\Sigma$，且 $c=1$。\n- 交替情况是：从 \"E\" 到 \"A\"（一次交替），从 \"A\" 到 \"A\"（无交替），以及从 \"A\" 到 \"E\"（第二次交替）。总交替次数 $A$ 为 $2$。\n- 层级是 $n = A + 1 = 2 + 1 = 3$。\n- 最终分类为 $\\Sigma_3^0$，表示为序对 $[1,3]$。\n\n这个完整的流程提供了一种确定性的方法，可以根据问题中指定的规则对任何给定的量词前缀进行分类。实现将系统地将这些步骤应用于每个测试用例。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ... # Not used for this problem\n\ndef classify_formula(prefix):\n    \"\"\"\n    Classifies a formula based on its quantifier prefix according to the arithmetical hierarchy.\n\n    Args:\n        prefix: A list of tuples (q, b), where q is \"E\" or \"A\" and b is 0 (unbounded) or 1 (bounded).\n\n    Returns:\n        A list [c, n] where c is the class (0 for Delta, 1 for Sigma, 2 for Pi) and n is the level.\n    \"\"\"\n    # Step 1: Filter the prefix to get only the unbounded quantifiers.\n    # The unbounded quantifiers are those where the second element of the pair is 0.\n    unbounded_quantifiers = [q for q, b in prefix if b == 0]\n\n    # Step 2: Handle the base case where there are no unbounded quantifiers.\n    # This corresponds to the class Delta_0^0.\n    if not unbounded_quantifiers:\n        return [0, 0]\n\n    # Step 3: If there are unbounded quantifiers, determine the class and level.\n    \n    # Step 3a: Determine the class (c) based on the first unbounded quantifier.\n    first_unbounded = unbounded_quantifiers[0]\n    if first_unbounded == \"E\":\n        c = 1  # Corresponds to Sigma_n^0\n    else:  # first_unbounded == \"A\"\n        c = 2  # Corresponds to Pi_n^0\n\n    # Step 3b: Determine the level (n) by counting alternations.\n    # The level n is 1 + (number of alternations).\n    alternations = 0\n    # Iterate through the sequence of unbounded quantifiers to count changes.\n    for i in range(len(unbounded_quantifiers) - 1):\n        if unbounded_quantifiers[i] != unbounded_quantifiers[i+1]:\n            alternations += 1\n    \n    n = alternations + 1\n    \n    return [c, n]\n\ndef solve():\n    \"\"\"\n    Runs the classification algorithm on the provided test suite and prints the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        [],  # Case 1\n        [(\"E\", 1), (\"A\", 1), (\"E\", 1)],  # Case 2\n        [(\"E\", 0)],  # Case 3\n        [(\"A\", 0), (\"A\", 0), (\"A\", 0)],  # Case 4\n        [(\"E\", 0), (\"A\", 1), (\"A\", 0), (\"E\", 1), (\"E\", 0)],  # Case 5\n        [(\"A\", 0), (\"E\", 0), (\"A\", 0), (\"E\", 0), (\"A\", 0)],  # Case 6\n        [(\"E\", 0), (\"E\", 0), (\"A\", 0)],  # Case 7\n        [(\"E\", 1), (\"A\", 0), (\"E\", 1)],  # Case 8\n    ]\n\n    results = []\n    for case in test_cases:\n        result = classify_formula(case)\n        # Format each result pair as a string \"[c,n]\" to be joined later.\n        results.append(f\"[{result[0]},{result[1]}]\")\n\n    # Final print statement in the exact required format: [[c1,n1],[c2,n2],...]\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3055137"}]}