{"hands_on_practices": [{"introduction": "柯里-霍华德同构的核心思想是“命题即类型，证明即程序”。本练习将通过构造一个 lambda 项来证明一个逻辑命题，以此来让你亲身体验这一思想。我们将为类型 $(A \\to B) \\to (C \\to A) \\to (C \\to B)$ 构造一个证明，这个过程实际上等同于编写一个高阶函数，该函数组合了另外两个函数，从而清晰地展示了证明构造与程序设计之间的深刻联系。[@problem_id:3056165]", "problem": "在简单类型 lambda 演算（STLC）的 Curry–Howard 同构框架下工作，其中命题是类型，证明是类型化的 lambda 项。仅使用函数类型的核心定型规则，即蕴涵引入和消除规则（对于箭头），以及避免捕获的替换和 $\\beta$-归约的标准定义，完成以下任务。\n\n1. 构造一个封闭的 lambda 项 $t$，使其属于类型 $(A \\to B) \\to (C \\to A) \\to (C \\to B)$。\n2. 仅使用函数引入和消除的定型规则，通过一个形式化的定型论证，从第一性原理出发推导 $t$ 的类型。\n3. 设 $f : A \\to B$、$g : C \\to A$ 和 $x : C$ 为变量。通过一个显式的 $\\beta$-归约序列，计算完全应用的项 $(t\\ f\\ g\\ x)$ 的 $\\beta$-范式，并根据 $\\beta$-归约和避免捕获的替换的定义来证明每一步。\n4. 将 $(t\\ f\\ g\\ x)$ 的 $\\beta$-范式的最终答案表示为一个单一的闭式解析表达式。\n\n不需要数值计算。最终答案必须是使用标准 lambda 演算应用表示法表示的单一符号表达式。不包含任何单位。不要写成方程；只给出最终的表达式。", "solution": "该问题是有效的，因为它是良构的，在简单类型 lambda 演算的形式系统中有科学依据，并且是内部一致的。我们开始解答，根据题目要求，解答分为三个部分：构造项、形式化定型推导和范式计算。\n\n### 1. Lambda 项的构造\n\n目标是构造一个封闭的 lambda 项 $t$，它属于（或者说具有）类型 $(A \\to B) \\to (C \\to A) \\to (C \\to B)$。此类型表示一个以柯里化方式接受三个参数的函数。我们可以通过分析类型的结构来构造这个项。\n\n类型是 $(A \\to B) \\to ((C \\to A) \\to (C \\to B))$。这是一个函数类型，所以项 $t$ 必须是一个 lambda 抽象。我们为第一个参数引入一个约束变量，称之为 $f$，其类型为 $A \\to B$。\n$$t = \\lambda f : A \\to B . \\text{body}_1$$\n这个抽象的体 $\\text{body}_1$ 必须具有类型 $(C \\to A) \\to (C \\to B)$。这也是一个函数类型，所以 $\\text{body}_1$ 必须是另一个 lambda 抽象。我们为其参数引入一个约束变量 $g$，其类型为 $C \\to A$。\n$$t = \\lambda f : A \\to B . \\lambda g : C \\to A . \\text{body}_2$$\n接下来的体 $\\text{body}_2$ 必须具有类型 $C \\to B$。这又是一个函数类型，需要第三个 lambda 抽象。我们为其类型为 $C$ 的参数引入一个约束变量 $x$。\n$$t = \\lambda f : A \\to B . \\lambda g : C \\to A . \\lambda x : C . \\text{body}_3$$\n此时，最终的体 $\\text{body}_3$ 必须具有类型 $B$。为了构造这个项，我们可以使用上下文中可用的变量：\n- $f : A \\to B$\n- $g : C \\to A$\n- $x : C$\n\n我们的目标是产生一个类型为 $B$ 的表达式。唯一能通过应用产生类型为 $B$ 的值的变量是 $f$。函数 $f$ 需要一个类型为 $A$ 的参数。我们可以通过将函数 $g : C \\to A$ 应用于一个类型为 $C$ 的参数来产生一个类型为 $A$ 的项。我们有这样一个参数，即变量 $x : C$。\n应用 $(g\\ x)$ 是类型正确的，其结果是一个类型为 $A$ 的项。\n现在，我们可以将这个项 $(g\\ x)$ 作为参数提供给 $f$。应用 $(f\\ (g\\ x))$ 是类型正确的，其结果是一个类型为 $B$ 的项。这正是 $\\text{body}_3$ 所需要的。\n\n将此代回到我们的结构中，我们得到完整的封闭 lambda 项：\n$$t = \\lambda f : A \\to B . \\lambda g : C \\to A . \\lambda x : C . (f\\ (g\\ x))$$\n这个项表示两个函数的复合。\n\n### 2. 形式化定型推导\n\n我们现在使用蕴涵引入（$\\to_I$）和蕴涵消除（$\\to_E$）的核心定型规则来推导所构造项 $t$ 的类型。规则如下：\n- 蕴涵消除（$\\to_E$ 规则，或称应用）：\n$$ \\frac{\\Gamma \\vdash M : T_1 \\to T_2 \\quad \\Gamma \\vdash N : T_1}{\\Gamma \\vdash (M\\ N) : T_2} $$\n- 蕴涵引入（$\\to_I$ 规则，或称抽象）：\n$$ \\frac{\\Gamma, v:T_1 \\vdash M : T_2}{\\Gamma \\vdash (\\lambda v:T_1 . M) : T_1 \\to T_2} $$\n\n让我们定义定型上下文序列：\n- $\\Gamma_0 = \\emptyset$ (空上下文)\n- $\\Gamma_1 = \\{ f : A \\to B \\}$\n- $\\Gamma_2 = \\{ f : A \\to B, g : C \\to A \\}$\n- $\\Gamma_3 = \\{ f : A \\to B, g : C \\to A, x : C \\}$\n\n推导过程如下，从最内层的上下文 $\\Gamma_3$ 中的变量开始：\n1. 从上下文 $\\Gamma_3$ 中，我们可以推断出我们变量的类型（通过变量规则，或称公理）：\n   - $\\Gamma_3 \\vdash f : A \\to B$\n   - $\\Gamma_3 \\vdash g : C \\to A$\n   - $\\Gamma_3 \\vdash x : C$\n2. 对步骤1中的项 $g$ 和 $x$ 使用 $\\to_E$ 规则：\n   $$ \\frac{\\Gamma_3 \\vdash g : C \\to A \\quad \\Gamma_3 \\vdash x : C}{\\Gamma_3 \\vdash (g\\ x) : A} $$\n3. 再次使用 $\\to_E$ 规则，这次是对步骤1中的项 $f$ 和步骤2中的项 $(g\\ x)$：\n   $$ \\frac{\\Gamma_3 \\vdash f : A \\to B \\quad \\Gamma_3 \\vdash (g\\ x) : A}{\\Gamma_3 \\vdash (f\\ (g\\ x)) : B} $$\n4. 现在，我们应用 $\\to_I$ 规则对 $x$ 进行抽象，消除假设 $x:C$ 并从上下文 $\\Gamma_3$ 移动到 $\\Gamma_2$：\n   $$ \\frac{\\Gamma_3 \\vdash (f\\ (g\\ x)) : B}{\\Gamma_2 \\vdash (\\lambda x : C . (f\\ (g\\ x))) : C \\to B} $$\n5. 我们再次应用 $\\to_I$ 规则对 $g$ 进行抽象，消除假设 $g:C \\to A$ 并从上下文 $\\Gamma_2$ 移动到 $\\Gamma_1$：\n   $$ \\frac{\\Gamma_2 \\vdash (\\lambda x : C . (f\\ (g\\ x))) : C \\to B}{\\Gamma_1 \\vdash (\\lambda g : C \\to A . \\lambda x : C . (f\\ (g\\ x))) : (C \\to A) \\to (C \\to B)} $$\n6. 最后，我们最后一次应用 $\\to_I$ 规则对 $f$ 进行抽象，消除假设 $f:A \\to B$ 并从上下文 $\\Gamma_1$ 移动到空上下文 $\\Gamma_0$：\n   $$ \\frac{\\Gamma_1 \\vdash (\\lambda g : C \\to A . \\lambda x : C . (f\\ (g\\ x))) : (C \\to A) \\to (C \\to B)}{\\Gamma_0 \\vdash (\\lambda f : A \\to B . \\lambda g : C \\to A . \\lambda x : C . (f\\ (g\\ x))) : (A \\to B) \\to (C \\to A) \\to (C \\to B)} $$\n这就完成了项 $t$ 具有指定类型的形式化证明。\n\n### 3. $\\beta$-范式的计算\n\n我们被要求计算项 $(t\\ f\\ g\\ x)$ 的 $\\beta$-范式，其中 $t$ 是我们构造的项，而 $f : A \\to B$、$g : C \\to A$ 和 $x : C$ 是给定的变量。\n\n为了避免 $t$ 中的约束变量与我们正在应用的自由变量 $f$、$g$ 和 $x$ 之间产生混淆，我们将用带撇号的约束变量来写 $t$：\n$$t = \\lambda f' : A \\to B . \\lambda g' : C \\to A . \\lambda x' : C . (f'\\ (g'\\ x'))$$\n待归约的项是 $(((t\\ f)\\ g)\\ x)$，因为应用是左结合的。\n\n$\\beta$-归约的定义是 $(\\lambda v. E)\\ M \\to_\\beta E[v \\leftarrow M]$，其中 $E[v \\leftarrow M]$ 表示将 $M$ 替换 $E$ 中所有 $v$ 的自由出现，并避免捕获。\n\n**步骤1：第一次 $\\beta$-归约**\n最外层的项是 $(t\\ f)$，它是一个 $\\beta$-可归约式：\n$$(t\\ f) = (\\lambda f' : A \\to B . \\lambda g' : C \\to A . \\lambda x' : C . (f'\\ (g'\\ x')))\\ f$$\n我们在抽象的体中用 $f$ 替换 $f'$：\n$$ \\to_\\beta (\\lambda g' : C \\to A . \\lambda x' : C . (f'\\ (g'\\ x')))[f' \\leftarrow f] $$\n$$ = \\lambda g' : C \\to A . \\lambda x' : C . (f\\ (g'\\ x')) $$\n该替换是有效的，因为变量 $f$ 没有可以被绑定子 $\\lambda g'$ 或 $\\lambda x'$ 捕获的自由变量。\n此步骤之后，完整表达式变为：\n$$(((\\lambda g' . \\lambda x' . (f\\ (g'\\ x')))\\ g)\\ x)$$\n\n**步骤2：第二次 $\\beta$-归约**\n下一个可归约式是对 $g$ 的应用：\n$$((\\lambda g' : C \\to A . \\lambda x' : C . (f\\ (g'\\ x')))\\ g)$$\n我们在体 $\\lambda x' : C . (f\\ (g'\\ x'))$ 中用 $g$ 替换 $g'$：\n$$ \\to_\\beta (\\lambda x' : C . (f\\ (g'\\ x')))[g' \\leftarrow g] $$\n$$ = \\lambda x' : C . (f\\ (g\\ x')) $$\n同样，该替换是避免捕获的，因为 $g$ 没有可以被 $\\lambda x'$ 捕获的自由变量。\n现在完整表达式是：\n$$(\\lambda x' : C . (f\\ (g\\ x')))\\ x$$\n\n**步骤3：第三次也是最后一次 $\\beta$-归约**\n最后的表达式是一个可归约式：\n$$(\\lambda x' : C . (f\\ (g\\ x')))\\ x$$\n我们在体 $(f\\ (g\\ x'))$ 中用 $x$ 替换 $x'$：\n$$ \\to_\\beta (f\\ (g\\ x'))[x' \\leftarrow x] $$\n$$ = (f\\ (g\\ x)) $$\n该替换是安全的。结果项是 $(f\\ (g\\ x))$。此项处于 $\\beta$-范式，因为它是一个应用，其头部 $f$ 是一个变量，而不是一个 lambda 抽象。因此，不可能再进行 $\\beta$-归约。\n\n显式的归约序列是：\n$$((( \\lambda f' . \\lambda g' . \\lambda x' . (f'\\ (g'\\ x')) )\\ f )\\ g )\\ x$$\n$$ \\to_\\beta ((\\lambda g' . \\lambda x' . (f\\ (g'\\ x')))\\ g)\\ x $$\n$$ \\to_\\beta (\\lambda x' . (f\\ (g\\ x')))\\ x $$\n$$ \\to_\\beta (f\\ (g\\ x)) $$\n$(t\\ f\\ g\\ x)$ 的最终 $\\beta$-范式是 $(f\\ (g\\ x))$，这直观上对应于将 $f$ 和 $g$ 的复合应用于参数 $x$。", "answer": "$$\\boxed{(f\\ (g\\ x))}$$", "id": "3056165"}, {"introduction": "在掌握了抽象的“命题即类型”思想后，让我们将其应用于一个更具体的场景：对数据类型的计算。本练习将背景设定为带有皮亚诺算术（Peano arithmetic）的简单类型 lambda 演算，你将操作一个在自然数上定义的函数。通过这个过程，你将看到类型检查如何确保程序的正确性，以及程序的求值（归约）过程如何对应于在具体数据结构上执行的逻辑推导。[@problem_id:3056166]", "problem": "考虑在 Curry-Howard 同构下的单纯类型lambda演算 (STLC)，其中类型是命题，类型化的项是证明。使用自然数基类型 $\\mathbb{N}$，其配备了常量 $0 : \\mathbb{N}$ 和 $\\mathsf{succ} : \\mathbb{N} \\to \\mathbb{N}$，以及柯里化的加法算子 $\\mathsf{add} : \\mathbb{N} \\to \\mathbb{N} \\to \\mathbb{N}$。假设使用标准的传值调用小步操作语义，包括 $\\beta$-归约和用于加法的常规皮亚诺方程：\n- $\\mathsf{add}(0)(n) \\to n$，\n- $\\mathsf{add}(\\mathsf{succ}(m))(n) \\to \\mathsf{succ}(\\mathsf{add}(m)(n))$。\n\n定义项\n$$f := \\lambda x:\\mathbb{N}.\\ \\mathsf{add}(x)\\big(\\mathsf{succ}(\\mathsf{succ}(x))\\big)$$\n以及参数\n$$a := \\mathsf{succ}(\\mathsf{succ}(0)).$$\n\n使用函数类型（箭头）的标准类型规则和上述操作语义，首先通过箭头消除（函数应用）的一个实例来证明应用 $f\\,a$ 是良类型的，然后将 $f\\,a$ 求值至范式。将最终结果表示为一个整数。无需四舍五入。", "solution": "该问题是有效的，因为它在科学上基于数理逻辑，特别是单纯类型lambda演算，并且问题是适定的，提供了所有必要的定义和规则以获得唯一解。\n\n该问题要求完成两项任务：首先，证明应用 $f\\,a$ 是良类型的；其次，将其求值至范式。\n\n让我们从第一个任务开始：类型检查。类型上下文 $\\Gamma$ 包含给定常量的类型：\n$\\Gamma = \\{ 0 : \\mathbb{N}, \\mathsf{succ} : \\mathbb{N} \\to \\mathbb{N}, \\mathsf{add} : \\mathbb{N} \\to \\mathbb{N} \\to \\mathbb{N} \\}$。\n我们将使用的单纯类型lambda演算 (STLC) 的核心类型规则是：\n1.  **变量**：如果 $(x:T) \\in \\Gamma$，那么 $\\Gamma \\vdash x:T$。\n2.  **应用（箭头消除）**：如果 $\\Gamma \\vdash t_1 : T_1 \\to T_2$ 并且 $\\Gamma \\vdash t_2 : T_1$，那么 $\\Gamma \\vdash t_1\\,t_2 : T_2$。\n3.  **抽象（箭头引入）**：如果 $\\Gamma, x:T_1 \\vdash t:T_2$，那么 $\\Gamma \\vdash (\\lambda x:T_1.\\,t) : T_1 \\to T_2$。\n\n首先，我们推导参数 $a := \\mathsf{succ}(\\mathsf{succ}(0))$ 的类型。\n1.  从上下文中，我们有 $\\Gamma \\vdash 0 : \\mathbb{N}$ 和 $\\Gamma \\vdash \\mathsf{succ} : \\mathbb{N} \\to \\mathbb{N}$。\n2.  根据应用规则，$\\Gamma \\vdash \\mathsf{succ}(0) : \\mathbb{N}$。\n3.  再次应用该规则，使用 $\\Gamma \\vdash \\mathsf{succ} : \\mathbb{N} \\to \\mathbb{N}$ 和 $\\Gamma \\vdash \\mathsf{succ}(0) : \\mathbb{N}$，我们得到 $\\Gamma \\vdash \\mathsf{succ}(\\mathsf{succ}(0)) : \\mathbb{N}$。\n因此，$a$ 的类型是 $\\mathbb{N}$。\n\n接下来，我们推导函数 $f := \\lambda x:\\mathbb{N}.\\ \\mathsf{add}(x)\\big(\\mathsf{succ}(\\mathsf{succ}(x))\\big)$ 的类型。\n为此，我们使用抽象规则。我们假设 $x$ 的类型为 $\\mathbb{N}$，并推导函数体的类型。令 $\\Gamma' = \\Gamma, x:\\mathbb{N}$。\n1.  从 $\\Gamma'$ 中，我们有 $\\Gamma' \\vdash x : \\mathbb{N}$ 和 $\\Gamma' \\vdash \\mathsf{succ} : \\mathbb{N} \\to \\mathbb{N}$。通过应用规则，$\\Gamma' \\vdash \\mathsf{succ}(x) : \\mathbb{N}$。再次应用，$\\Gamma' \\vdash \\mathsf{succ}(\\mathsf{succ}(x)) : \\mathbb{N}$。\n2.  从 $\\Gamma'$ 中，我们有 $\\Gamma' \\vdash \\mathsf{add} : \\mathbb{N} \\to \\mathbb{N} \\to \\mathbb{N}$ 和 $\\Gamma' \\vdash x : \\mathbb{N}$。通过应用规则，部分应用的项的类型为 $\\Gamma' \\vdash \\mathsf{add}(x) : \\mathbb{N} \\to \\mathbb{N}$。\n3.  现在我们考虑整个函数体，它是一个应用：$\\mathsf{add}(x)\\big(\\mathsf{succ}(\\mathsf{succ}(x))\\big)$。使用步骤1和2的结果，我们有一个类型为 $\\mathbb{N} \\to \\mathbb{N}$ 的函数应用于一个类型为 $\\mathbb{N}$ 的参数。根据应用规则，结果的类型为 $\\mathbb{N}$。所以，$\\Gamma' \\vdash \\mathsf{add}(x)\\big(\\mathsf{succ}(\\mathsf{succ}(x))\\big) : \\mathbb{N}$。\n4.  既然我们已经证明了假设 $x:\\mathbb{N}$ 可以让我们推导出函数体的类型为 $\\mathbb{N}$ (即 $\\Gamma, x:\\mathbb{N} \\vdash \\text{body} : \\mathbb{N}$)，我们可以使用抽象规则来推断出 $f$ 的类型：\n    $$ \\Gamma \\vdash \\lambda x:\\mathbb{N}.\\ \\mathsf{add}(x)\\big(\\mathsf{succ}(\\mathsf{succ}(x))\\big) : \\mathbb{N} \\to \\mathbb{N} $$\n因此，$f$ 的类型是 $\\mathbb{N} \\to \\mathbb{N}$。\n\n最后，我们证明应用 $f\\,a$ 是良类型的。\n我们已经推导出 $\\Gamma \\vdash f : \\mathbb{N} \\to \\mathbb{N}$ 和 $\\Gamma \\vdash a : \\mathbb{N}$。\n根据箭头消除规则（函数应用），由于参数 $a$ 的类型（$\\mathbb{N}$）与函数 $f$ 的输入类型（$\\mathbb{N} \\to \\mathbb{N}$ 的定义域）匹配，因此应用 $f\\,a$ 是良类型的。结果类型是函数的输出类型，即 $\\mathbb{N}$。所以，$\\Gamma \\vdash f\\,a : \\mathbb{N}$。\n在 Curry-Howard 同构中，这是肯定前件 (Modus Ponens) 的一个实例：从 $\\mathbb{N} \\implies \\mathbb{N}$ 的一个证明（项 $f$）和 $\\mathbb{N}$ 的一个证明（项 $a$），我们可以构造出 $\\mathbb{N}$ 的一个证明（项 $f\\,a$）。\n\n现在进行第二个任务：求值。我们需要使用传值调用小步语义将 $f\\,a$ 求值至范式。\n表达式是：\n$$ (\\lambda x:\\mathbb{N}.\\ \\mathsf{add}(x)\\big(\\mathsf{succ}(\\mathsf{succ}(x))\\big))(\\mathsf{succ}(\\mathsf{succ}(0))) $$\n在传值调用语义中，参数必须在替换前被求值为一个值。这里，参数 $a = \\mathsf{succ}(\\mathsf{succ}(0))$ 已经是一个值，因为它是由构造子应用于常量 $0$ 构成的。我们可以将此值表示为 $2$ 的皮亚诺数。\n\n我们通过将值 $\\mathsf{succ}(\\mathsf{succ}(0))$ 替换 lambda 项体中 $x$ 的每个自由出现来执行 $\\beta$-归约：\n$$ \\mathsf{add}(\\mathsf{succ}(\\mathsf{succ}(0)))\\big(\\mathsf{succ}(\\mathsf{succ}(\\mathsf{succ}(\\mathsf{succ}(0))))\\big) $$\n为了使归约过程更清晰，我们使用记法 $S(m)$ 代表 $\\mathsf{succ}(m)$ 并使用皮亚诺数。该项是 $\\mathsf{add}(S(S(0)))(S(S(S(S(0)))))$。这对应于操作 $\\mathsf{add}(2)(4)$。\n\n我们现在应用给定的加法归约规则：\n-   规则 1：$\\mathsf{add}(0)(n) \\to n$\n-   规则 2：$\\mathsf{add}(\\mathsf{succ}(m))(n) \\to \\mathsf{succ}(\\mathsf{add}(m)(n))$\n\n让我们一步步地追踪求值过程：\n$$ \\mathsf{add}(S(S(0)))(S(S(S(S(0))))) $$\n应用规则2，其中 $m = S(0)$ 且 $n = S(S(S(S(0))))$:\n$$ \\to \\mathsf{succ}\\Big(\\mathsf{add}(S(0))\\big(S(S(S(S(0))))\\big)\\Big) $$\n再次对括号内应用规则2，其中 $m = 0$ 且 $n = S(S(S(S(0))))$:\n$$ \\to \\mathsf{succ}\\Big(\\mathsf{succ}\\big(\\mathsf{add}(0)(S(S(S(S(0)))))\\big)\\Big) $$\n现在，我们可以对最内层的项应用规则1，其中 $n = S(S(S(S(0))))$:\n$$ \\to \\mathsf{succ}\\Big(\\mathsf{succ}\\big(S(S(S(S(0))))\\big)\\Big) $$\n组合 $\\mathsf{succ}$ 的应用，我们得到：\n$$ \\mathsf{succ}(\\mathsf{succ}(S(S(S(S(0)))))) = \\mathsf{succ}(\\mathsf{succ}(\\mathsf{succ}(\\mathsf{succ}(\\mathsf{succ}(\\mathsf{succ}(0)))))) $$\n这个项是范式，因为没有更多的归约规则可以应用。它包含对常量 $0$ 的六次后继函数 $\\mathsf{succ}$ 的应用。这是自然数 $6$ 的皮亚诺表示法。\n\n问题要求最终结果为整数。因此，范式 $\\mathsf{succ}(\\mathsf{succ}(\\mathsf{succ}(\\mathsf{succ}(\\mathsf{succ}(\\mathsf{succ}(0))))))$ 对应于整数 $6$。", "answer": "$$\\boxed{6}$$", "id": "3056166"}, {"introduction": "一个可靠的类型系统如同一个严谨的逻辑系统，其规则不容侵犯。类型安全（Type Safety）是连接程序可靠性与逻辑一致性的桥梁，它通常由“进程”（Progress）和“保持”（Preservation）两个定理来保证。本练习通过一个思想实验，让你探索当“类型保持”被一个不合理的规则破坏时会发生什么。通过构造一个在增强系统中会“卡住”（stuck）的项，你将深刻理解类型系统对于保证计算能够顺利进行并最终得出有意义结果的重要性。[@problem_id:3056147]", "problem": "考虑在Curry-Howard对应（CHC）下的一个简单类型lambda演算的片段，其中类型对应于命题，项对应于证明。该语言具有基本类型 $\\mathsf{Bool}$ 和 $\\mathsf{Nat}$，常量 $0$、$\\mathsf{true}$、$\\mathsf{false}$，以及用于自然数的一元构造子 $\\mathsf{succ}\\, t$。类型规则包括 $\\Gamma \\vdash 0 : \\mathsf{Nat}$、$\\Gamma \\vdash \\mathsf{true} : \\mathsf{Bool}$、$\\Gamma \\vdash \\mathsf{false} : \\mathsf{Bool}$，以及若 $\\Gamma \\vdash t : \\mathsf{Nat}$ 则 $\\Gamma \\vdash \\mathsf{succ}\\, t : \\mathsf{Nat}$。小步操作语义包括后继算子的标准求值上下文规则：若 $t \\to t'$，则 $\\mathsf{succ}\\, t \\to \\mathsf{succ}\\, t'$。值被归纳定义为 $v ::= 0 \\mid \\mathsf{succ}\\, v \\mid \\mathsf{true} \\mid \\mathsf{false}$。\n\n用一条非类型保持的额外规则来增强该归约系统：\n$$\n0 \\to \\mathsf{true}.\n$$\n仅使用上述基本定义以及广为接受的、关于未修改系统的进展性与保持性的事实作为基础，构造一个闭合的、良类型的项，该项在增强的归约系统下，会归约为一个既不是值也不能被任何规则归约的项（一个停滞项）。从第一性原理出发，精确解释在添加这个非类型保持规则后，在CHC和类型规程下出现了何种失败，并推导出由该添加规则驱动的单步上下文步骤所产生的显式停滞项。你的最终答案必须是作为一个单一符号数学表达式的显式停滞项。不需要进行四舍五入或使用物理单位。", "solution": "问题陈述被评估为有效。它提出了一个基于简单类型lambda演算的、定义明确的形式系统，并要求分析用一个特定的、非类型保持的归约规则来增强该系统所带来的后果。该问题在科学上基于类型论和操作语义的原理，内部一致，并要求根据所提供的定义进行严格的推导。\n\n一个可靠的类型演算的基础，并延伸至Curry-Howard对应（CHC），依赖于类型安全这一属性。类型安全通常由两个关键定理来建立：保持性（preservation）和进展性（progress）。该问题假设了一个系统，其中标准的、已知拥有这些属性的简单类型lambda演算被一条破坏此基础的规则所增强。\n\n让我们正式陈述这些关键原则：\n1.  **保持性（主语归约）：** 如果一个项 $t$ 在上下文 $\\Gamma$ 中是类型为 $T$ 的良类型项（记作 $\\Gamma \\vdash t : T$），并且它一步归约为项 $t'$（记作 $t \\to t'$），那么 $t'$ 也必须是类型为 $T$ 的良类型项（即 $\\Gamma \\vdash t' : T$）。该定理确保了计算会保持表达式的类型。\n2.  **进展性：** 对于任何闭合的、良类型的项 $t$（即对于某个类型 $T$，有 $\\emptyset \\vdash t : T$），要么 $t$ 是一个值，要么存在一个项 $t'$ 使得 $t \\to t'$。该定理确保了一个良类型的程序永远不会在非终止状态“停滞”。\n\n问题引入了归约规则 $0 \\to \\mathsf{true}$。让我们在保持性属性的背景下分析这条规则。\n根据给定的类型规则：\n-   项 $0$ 的类型是 $\\mathsf{Nat}$，形式上为 $\\Gamma \\vdash 0 : \\mathsf{Nat}$。\n-   项 $\\mathsf{true}$ 的类型是 $\\mathsf{Bool}$，形式上为 $\\Gamma \\vdash \\mathsf{true} : \\mathsf{Bool}$。\n\n归约 $0 \\to \\mathsf{true}$ 将一个类型为 $\\mathsf{Nat}$ 的项转换为一个类型为 $\\mathsf{Bool}$ 的项。由于 $\\mathsf{Nat} \\neq \\mathsf{Bool}$，该规则明确违反了保持性定理。单步归约改变了项的类型，这在类型安全的系统中是被禁止的。\n\n问题的核心是展示这种对保持性的违反如何导致对进展性定理的违反。我们需要构造一个闭合的、良类型的项，它会归约为一个“停滞”状态——即一个既不是值，也没有任何归约规则可以应用的项。\n\n我们可以利用给定归约语义的上下文敏感性。问题提供了一个构造子 $\\mathsf{succ}$ 和一个相应的求值上下文规则：若 $t \\to t'$，则 $\\mathsf{succ}\\, t \\to \\mathsf{succ}\\, t'$。该规则允许归约发生在 $\\mathsf{succ}$ 构造子内部的项上。为了使项 $\\mathsf{succ}\\, t$ 是良类型的，其参数 $t$ 必须具有类型 $\\mathsf{Nat}$。\n\n让我们使用这种结构构造一个项。\n1.  从类型为 $\\mathsf{Nat}$ 的最简单的项开始：常量 $0$。根据给定的类型规则，我们有 $\\emptyset \\vdash 0 : \\mathsf{Nat}$。\n2.  将 $\\mathsf{succ}$ 构造子应用于该项。$\\mathsf{succ}$ 的类型规则规定，若 $\\Gamma \\vdash t : \\mathsf{Nat}$，则 $\\Gamma \\vdash \\mathsf{succ}\\, t : \\mathsf{Nat}$。应用此规则，因为我们有 $\\emptyset \\vdash 0 : \\mathsf{Nat}$，我们可以推导出 $\\emptyset \\vdash \\mathsf{succ}\\, 0 : \\mathsf{Nat}$。\n3.  因此，项 $\\mathsf{succ}\\, 0$ 是一个闭合的、良类型的项。\n\n现在，我们在增强系统中分析该项的归约。\n-   我们的起始项是 $\\mathsf{succ}\\, 0$。\n-   系统包括针对 $\\mathsf{succ}$ 的求值上下文规则：若 $t \\to t'$，则 $\\mathsf{succ}\\, t \\to \\mathsf{succ}\\, t'$。\n-   系统还包括非类型保持规则 $0 \\to \\mathsf{true}$。\n-   我们可以通过令 $t = 0$ 和 $t' = \\mathsf{true}$ 来应用上下文规则。上下文规则的前提 $0 \\to \\mathsf{true}$ 被满足。\n-   因此，我们推导出一单步归约：$\\mathsf{succ}\\, 0 \\to \\mathsf{succ}\\, \\mathsf{true}$。\n\n良类型的项 $\\mathsf{succ}\\, 0$ 归约为项 $\\mathsf{succ}\\, \\mathsf{true}$。现在让我们分析这个结果项，以确定它是否停滞。\n1.  **$\\mathsf{succ}\\, \\mathsf{true}$ 是一个值吗？** 值的定义被给出为 $v ::= 0 \\mid \\mathsf{succ}\\, v \\mid \\mathsf{true} \\mid \\mathsf{false}$。对于形式为 $\\mathsf{succ}\\, t$ 的项要成为一个值，$t$ 本身必须是形式为 $0$ 或 $\\mathsf{succ}\\, v'$ 的值。在我们的例子中，$\\mathsf{succ}$ 的参数是 $\\mathsf{true}$。虽然 $\\mathsf{true}$ 是一个值，但根据自然数的归纳结构（$v_{nat} ::= 0 \\mid \\mathsf{succ}\\, v_{nat}$），它不是一个自然数值。因此，项 $\\mathsf{succ}\\, \\mathsf{true}$ 不匹配值的模式。它不是一个值。\n\n2.  **$\\mathsf{succ}\\, \\mathsf{true}$ 可以被归约吗？** 我们必须检查是否有任何归约规则适用。\n    -   唯一适用于以 $\\mathsf{succ}$ 开头的项的规则是上下文规则：若 $t \\to t'$，则 $\\mathsf{succ}\\, t \\to \\mathsf{succ}\\, t'$。为了让此规则应用于 $\\mathsf{succ}\\, \\mathsf{true}$，其内部的项 $\\mathsf{true}$ 必须能够进行归约步骤。\n    -   然而，$\\mathsf{true}$ 是一个值。根据定义，值是计算的终止形式，没有进一步的归约。\n    -   由于内部的项 $\\mathsf{true}$ 无法归约，上下文规则的前提未被满足。\n    -   没有定义其他能够匹配 $\\mathsf{succ}\\, \\mathsf{true}$ 结构的归约规则。\n\n项 $\\mathsf{succ}\\, \\mathsf{true}$ 不是一个值，并且没有归约规则可以应用于它。根据定义，它是一个停滞项。\n\n总而言之，良类型的项 $\\mathsf{succ}\\,0$ 归约为停滞项 $\\mathsf{succ}\\,\\mathsf{true}$。这构成了对进展性定理的违反。这一失败是规则 $0 \\to \\mathsf{true}$ 违反保持性定理的直接后果。在Curry-Howard对应下，这意味着逻辑一致性的崩溃。命题 $\\mathsf{Nat}$ 的“证明” $\\mathsf{succ}\\,0$ 被转换为 $\\mathsf{succ}\\,\\mathsf{true}$，这是一个无意义的构造，在原始系统中既不对应于一个有效的证明，也不对应于一个命题。它代表了证明正规化过程中的失败，而证明正规化是计算在逻辑上的对应物。推导出的停滞项是这种系统性失败的显式产物。", "answer": "$$\n\\boxed{\\mathsf{succ}\\,\\mathsf{true}}\n$$", "id": "3056147"}]}