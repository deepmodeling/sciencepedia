{"hands_on_practices": [{"introduction": "在深入探讨可表示性的一般理论之前，首先通过一个具体的例子来建立直观理解是至关重要的。这个练习将引导你使用皮亚诺算术（PA）的公理，来证明关于乘法的一些基本性质。通过这个过程，你将亲身体验如何在形式系统内部进行推导，并理解PA的公理是如何为算术运算提供坚实基础的。[@problem_id:3050644]", "problem": "在一阶皮亚诺算术 (PA) 中进行推演，该算术的语言包含符号 $0$, $S$, $+$, $\\cdot$, 和 $=$，以及适用于所有公式 $\\varphi(y)$ 的完整归纳模式。回顾以下基础公理：\n- 等式公理和一阶逻辑的常规规则。\n- 后继公理：$\\forall x\\, (S(x) \\neq 0)$ 和 $\\forall x\\, \\forall y\\, (S(x)=S(y) \\rightarrow x=y)$。\n- 加法公理：$\\forall x\\, (x+0=x)$ 和 $\\forall x\\, \\forall y\\, (x+S(y)=S(x+y))$。\n- 乘法公理：$\\forall x\\, (x\\cdot 0=0)$ 和 $\\forall x\\, \\forall y\\, (x\\cdot S(y)=x\\cdot y + x)$。\n- 归纳模式：对于每个公式 $\\varphi(y)$，公理 $\\big(\\varphi(0)\\wedge \\forall y\\,(\\varphi(y)\\rightarrow \\varphi(S(y)))\\big)\\rightarrow \\forall y\\, \\varphi(y)$ 成立。\n\n数码是形如 $\\overline{n}=S^n(0)$（其中 $n\\in \\mathbb{N}$）的项。一个函数 $f:\\mathbb{N}^k\\to \\mathbb{N}$ 在 PA 中是（强）可表示的，如果存在一个公式 $\\varphi(\\vec{x},z)$，使得 PA 证明 $\\forall \\vec{x}\\, \\exists ! z\\, \\varphi(\\vec{x},z)$，并且对于每个 $\\vec{n}$，PA 证明 $\\varphi(\\overline{\\vec{n}},\\overline{f(\\vec{n})})$。\n\n仅使用这些基础，选择下面所有关于 PA 能证明什么以及乘法公理如何产生数码乘法事实的正确陈述：\n\nA. PA 证明 $\\forall x\\, (x\\cdot 0=0)$ 和 $\\forall x\\, \\forall y\\, (x\\cdot S(y)=x\\cdot y + x)$。因此，PA 证明 $\\forall x\\, \\forall y\\, \\exists ! z\\, (z = x\\cdot y)$。\n\nB. 对于每个 $m,n\\in \\mathbb{N}$，PA 通过一个可以通过迭代定义方程构建的推导来证明 $\\overline{m}\\cdot \\overline{n}=\\overline{m\\cdot n}$，并且该推导的长度以 $m+n$ 的一个多项式为界。\n\nC. 即使没有假设关于 $\\cdot$ 的公理，PA（仅使用关于 $+$ 的公理和归纳模式）也能证明 $\\forall x\\, (x\\cdot 0=0)$ 和 $\\forall x\\, \\forall y\\, (x\\cdot S(y)=x\\cdot y + x)$。\n\nD. 根据给定的关于 $+$ 和 $\\cdot$ 的公理，PA 证明 $\\forall x\\, (x\\cdot S(0)=x)$，并且更一般地，对于每个固定的数码 $\\overline{n}$，PA 证明 $\\forall x\\, \\big(x\\cdot \\overline{n}=\\underbrace{x+\\cdots + x}_{n\\ \\text{个加数}}\\big)$。\n\nE. 由于乘法是一个可计算（实际上是原始递归）函数，因此在 PA 的语言中存在一个公式 $\\varphi(x,y,z)$，它在强意义上表示 PA 中的乘法图像：PA 证明 $\\forall x\\, \\forall y\\, \\exists ! z\\, \\varphi(x,y,z)$，并且对于所有 $m,n\\in \\mathbb{N}$，PA 证明 $\\varphi(\\overline{m},\\overline{n},\\overline{m\\cdot n})$。\n\n选择所有适用的选项：A, B, C, D, E。", "solution": "问题陈述对一阶皮亚诺算术 (PA) 和函数强可表示性的定义给出了一个正确且标准的表述。该问题在科学上是合理的、提法得当且客观的。这是一个有效的数理逻辑问题。我将逐一分析每个选项。\n\n### 选项 A 分析\n陈述 A：`PA 证明 $\\forall x\\, (x\\cdot 0=0)$ 和 $\\forall x\\, \\forall y\\, (x\\cdot S(y)=x\\cdot y + x)$。因此，PA 证明 $\\forall x\\, \\forall y\\, \\exists ! z\\, (z = x\\cdot y)$。`\n\n陈述的第一部分，“PA 证明 $\\forall x\\, (x\\cdot 0=0)$ 和 $\\forall x\\, \\forall y\\, (x\\cdot S(y)=x\\cdot y + x)$”，根据定义是正确的，因为它们在问题描述中被列为 PA 的公理。\n\n第二部分声称，作为推论，PA 证明了乘法函数的全局性和单值性，形式化表述为 $\\forall x\\, \\forall y\\, \\exists ! z\\, (z = x\\cdot y)$。我们来验证这个说法。证明必须在 PA 内部进行。\n\n1.  **存在性**：我们需要证明 $\\forall x\\, \\forall y\\, \\exists z\\, (z = x\\cdot y)$。我们固定一个任意的 $x$，并对变量 $y$ 使用归纳模式。令 $\\varphi(y)$ 为公式 $\\exists z\\, (z = x\\cdot y)$。\n    *   **基本情况 ($y=0$):** 我们必须证明 $\\varphi(0)$，即 $\\exists z\\, (z = x\\cdot 0)$。根据公理 $\\forall x\\, (x\\cdot 0=0)$，我们有 $x\\cdot 0=0$。根据一阶逻辑的规则（存在量词引入），从 $x\\cdot 0=0$ 我们可以推导出 $\\exists z\\, (z=x\\cdot 0)$。因此，PA 证明 $\\varphi(0)$。\n    *   **归纳步骤：** 我们假设对于任意 $y$，$\\varphi(y)$ 成立，即归纳假设为 $\\exists z\\, (z = x\\cdot y)$。我们用 $w$ 来称呼这样一个 $z$，所以 $w = x\\cdot y$。我们必须证明 $\\varphi(S(y))$，即 $\\exists z'\\, (z' = x\\cdot S(y))$。\n        根据第二条乘法公理，我们有 $x\\cdot S(y) = x\\cdot y + x$。\n        使用归纳假设，我们可以用 $w$ 替换 $x\\cdot y$，得到 $x\\cdot S(y) = w+x$。\n        函数 $+$ 在 PA 中也是全局的（可以通过类似的归纳证明），所以对于任何 $w$ 和 $x$，存在一个数等于它们的和 $w+x$。设这个数为 $v$。所以 $v=w+x$。\n        因此，$v = x\\cdot S(y)$。通过存在量词引入，我们得到 $\\exists v\\, (v = x\\cdot S(y))$，这就是 $\\varphi(S(y))$。\n    *   根据归纳模式 $\\big(\\varphi(0)\\wedge \\forall y\\,(\\varphi(y)\\rightarrow \\varphi(S(y)))\\big)\\rightarrow \\forall y\\, \\varphi(y)$，我们得出结论，PA 证明 $\\forall y\\, \\varphi(y)$，即 $\\forall y\\, \\exists z\\, (z=x\\cdot y)$。由于 $x$ 是任意的，我们可以进行全称量词推广得到 $\\forall x\\, \\forall y\\, \\exists z\\, (z=x\\cdot y)$。\n\n2.  **唯一性**：我们需要证明对于任何 $x, y$，如果 $z_1 = x\\cdot y$ 且 $z_2 = x\\cdot y$，那么 $z_1=z_2$。这是等式性质的直接推论（特别是传递性：如果 $z_1 = x \\cdot y$ 且 $x \\cdot y = z_2$，那么 $z_1 = z_2$）。因此，唯一性部分可以从等式公理中证明。\n\n结合存在性和唯一性，PA 证明 $\\forall x\\, \\forall y\\, \\exists ! z\\, (z = x\\cdot y)$。“因此”一词在 PA 内部工作的语境下是恰当的，因为证明依赖于给定的公理和归纳模式。\n\nA 的结论：**正确**。\n\n### 选项 B 分析\n陈述 B：`对于每个 $m,n\\in \\mathbb{N}$，PA 通过一个可以通过迭代定义方程构建的推导来证明 $\\overline{m}\\cdot \\overline{n}=\\overline{m\\cdot n}$，并且该推导的长度以 $m+n$ 的一个多项式为界。`\n\n这个陈述提出了两个主张。\n1.  **通过迭代的可证明性**：PA 证明对于任何具体的数码 $\\overline{m}$ 和 $\\overline{n}$，$\\overline{m}\\cdot \\overline{n}=\\overline{m \\cdot n}$ 成立。证明过程通过对 $\\overline{n}$ 进行递归。\n    *   如果 $n=0$，我们证明 $\\overline{m}\\cdot\\overline{0}=\\overline{0}$，即 $\\overline{m}\\cdot 0=0$。这是公理 $\\forall x(x\\cdot 0=0)$ 的一个实例。\n    *   如果 $n0$，那么 $\\overline{n}=S(\\overline{n-1})$，我们有 $\\overline{m}\\cdot S(\\overline{n-1}) = \\overline{m}\\cdot\\overline{n-1} + \\overline{m}$。通过（元）归纳，我们假设我们可以证明 $\\overline{m}\\cdot\\overline{n-1} = \\overline{m(n-1)}$。所以我们有 $\\overline{m(n-1)} + \\overline{m}$。一个类似的关于加法定义的迭代过程证明了 $\\overline{a}+\\overline{b}=\\overline{a+b}$ 的步骤数与 $b$ 成正比。这里，我们需要证明 $\\overline{m(n-1)} + \\overline{m} = \\overline{m(n-1)+m} = \\overline{mn}$。这需要 $m$ 次应用加法的后继规则。因此，整个过程“迭代了定义方程”。\n2.  **证明长度**：乘法的主要递归步骤数为 $n$。每一步都涉及一个加法 $\\overline{a}+\\overline{m}$，这需要 $m$ 次加法的递归步骤。递归公理的总应用次数大约是 $O(m \\cdot n)$。数码本身，例如 $\\overline{m \\cdot n}$，其长度（符号数量）与 $m \\cdot n$ 成正比。证明的总长度（所有公式的长度之和）将是 $m$ 和 $n$ 的一个多项式函数。任何关于两个变量 $m, n$ 的多项式都可以被它们和 $m+n$ 的一个多项式所界定，因为 $m \\le m+n$ 且 $n \\le m+n$。因此，像 $m^a n^b$ 这样的项被 $(m+n)^a (m+n)^b = (m+n)^{a+b}$ 所界定。这是证明论中关于 PA 中无量词语句形式化证明效率的一个已知结果。\n\nB 的结论：**正确**。\n\n### 选项 C 分析\n陈述 C：`即使没有假设关于 $\\cdot$ 的公理，PA（仅使用关于 $+$ 的公理和归纳模式）也能证明 $\\forall x\\, (x\\cdot 0=0)$ 和 $\\forall x\\, \\forall y\\, (x\\cdot S(y)=x\\cdot y + x)$。`\n\n这个陈述是错误的。如果符号 $\\cdot$ 包含在语言中，但没有提供任何公理来规定其行为，它就是一个未解释的函数符号。可以构造一个其余 PA 公理（关于 $0, S, +$ 和归纳）的模型，其中 $\\cdot$ 的解释不满足所述性质。\n\n例如，让论域为 $\\mathbb{N}$，其中 $0, S, +$ 被解释为通常的运算。让符号 $\\cdot$ 的解释，记作 $f(x,y) = x \\cdot y$，为常数函数 $f(x,y)=1$ 对所有 $x,y \\in \\mathbb{N}$。这个结构是没有乘法公理的 PA 的一个模型。在这个模型中，陈述 $\\forall x\\, (x\\cdot 0=0)$ 转化为“对所有 $x \\in \\mathbb{N}, f(x,0)=0$”，这意味着“$1=0$”。这是错误的，并且实际上与 PA 公理 $\\forall x(S(x) \\neq 0)$ 相矛盾，从该公理可以证明 $\\overline{1} \\neq 0$。\n\n因为我们找到了一个简化理论的模型，其中乘法公理是假的，所以它们不可能是该理论的定理。乘法公理不是冗余的。\n\nC 的结论：**不正确**。\n\n### 选项 D 分析\n陈述 D：`根据给定的关于 $+$ 和 $\\cdot$ 的公理，PA 证明 $\\forall x\\, (x\\cdot S(0)=x)$，并且更一般地，对于每个固定的数码 $\\overline{n}$，PA 证明 $\\forall x\\, \\big(x\\cdot \\overline{n}=\\underbrace{x+\\cdots + x}_{n\\ \\text{个加数}}\\big)$。`\n\n第一部分：证明 $\\forall x\\, (x\\cdot S(0)=x)$。\n注意 $S(0)$ 是数码 $\\overline{1}$。\n从乘法公理 $\\forall x\\, \\forall y\\, (x\\cdot S(y)=x\\cdot y + x)$，我们将 $y$ 实例化为 $0$：PA 证明 $\\forall x\\, (x\\cdot S(0)=x\\cdot 0 + x)$。\n从另一个乘法公理 $\\forall x\\, (x\\cdot 0=0)$，我们代入得到：PA 证明 $\\forall x\\, (x\\cdot S(0)=0 + x)$。\n我们现在需要证明 PA 证明 $\\forall x\\,(0+x=x)$。这是加法的左单位元性质。它不是一个公理，但可以通过对 $x$ 的归纳来证明。\n令 $\\varphi(x)$ 为 $0+x=x$。\n*   **基本情况 ($x=0$):** $\\varphi(0)$ 是 $0+0=0$。这可以从公理 $\\forall z(z+0=z)$ 中通过令 $z=0$ 得出。\n*   **归纳步骤：** 假设 $\\varphi(x)$，即 $0+x=x$。我们必须证明 $\\varphi(S(x))$，即 $0+S(x)=S(x)$。根据第二条加法公理 $\\forall z\\forall y(z+S(y)=S(z+y))$，令 $z=0, y=x$，我们得到 $0+S(x)=S(0+x)$。根据归纳假设，$0+x=x$，所以 $S(0+x)=S(x)$。因此，$0+S(x)=S(x)$。\n通过归纳，PA 证明 $\\forall x\\, (0+x=x)$。将此结果代入我们早前的结果，PA 证明 $\\forall x\\, (x\\cdot S(0)=x)$。\n\n第二部分：证明对于每个 $n \\in \\mathbb{N}$，PA 证明 $\\forall x\\, \\big(x\\cdot \\overline{n}=\\underbrace{x+\\cdots + x}_{n\\ \\text{个加数}}\\big)$。令 $T_n(x)$ 表示项 $\\underbrace{x+\\cdots + x}_{n\\ \\text{个加数}}$（其中 $T_0(x)$ 为 $0$）。我们通过对 $n$ 的元归纳来证明这一点。\n*   **基本情况 ($n=0$):** 我们必须证明 PA 证明 $\\forall x(x\\cdot\\overline{0}=T_0(x))$，即 $\\forall x(x\\cdot 0=0)$。这是一个公理。\n*   **归纳步骤：** 假设对于某个 $k \\in \\mathbb{N}$，PA 证明 $\\forall x(x\\cdot\\overline{k}=T_k(x))$。我们想要证明 PA 证明 $\\forall x(x\\cdot\\overline{k+1}=T_{k+1}(x))$。\n    $\\overline{k+1}$ 是 $S(\\overline{k})$。该项是 $x \\cdot S(\\overline{k})$。\n    根据乘法公理，PA 证明 $x \\cdot S(\\overline{k}) = (x\\cdot\\overline{k}) + x$。\n    根据元归纳假设，PA 证明 $x \\cdot \\overline{k} = T_k(x)$。\n    代入此式得到 $x \\cdot S(\\overline{k}) = T_k(x) + x$。\n    根据定义，$T_{k+1}(x)$ 是 $T_k(x) + x$。\n    因此，PA 证明 $\\forall x \\, (x \\cdot \\overline{k+1} = T_{k+1}(x))$。\n元归纳成立，所以该陈述是正确的。\n\nD 的结论：**正确**。\n\n### 选项 E 分析\n陈述 E：`由于乘法是一个可计算（实际上是原始递归）函数，因此在 PA 的语言中存在一个公式 $\\varphi(x,y,z)$，它在强意义上表示 PA 中的乘法图像：PA 证明 $\\forall x\\, \\forall y\\, \\exists ! z\\, \\varphi(x,y,z)$，并且对于所有 $m,n\\in \\mathbb{N}$，PA 证明 $\\varphi(\\overline{m},\\overline{n},\\overline{m\\cdot n})$。`\n\n这个陈述基于数理逻辑中的一个主要定理提出了一个主张。\n1.  **前提**：自然数上的乘法是一个原始递归函数，它是可计算（或全递归）函数的一个子集。这是可计算性理论中的一个正确陈述。\n2.  **推论**：形式算术理论的一个基础性结果（首先由 Gödel 证明）是，所有可计算函数在 PA 中都是强可表示的。由于乘法是可计算的，它必须在 PA 中是强可表示的。\n3.  **公式的存在性**：该陈述断言存在一个具有强表示性质的公式 $\\varphi(x,y,z)$。根据一般定理，这样的公式必须存在。\n4.  **一个具体例子**：我们甚至可以直接给出一个这样的公式。让我们选择最自然的候选者：$\\varphi(x,y,z) \\equiv (z = x \\cdot y)$。这个公式在 PA 的语言中。\n    *   PA 是否证明 $\\forall x\\, \\forall y\\, \\exists ! z\\, (z=x\\cdot y)$？是的，正如在选项 A 的分析中所确立的。\n    *   对于所有 $m,n\\in \\mathbb{N}$，PA 是否证明 $\\varphi(\\overline{m},\\overline{n},\\overline{m\\cdot n})$？这是陈述 PA 证明 $\\overline{m\\cdot n} = \\overline{m} \\cdot \\overline{n}$。正如在选项 B 的分析中所确立的，这对于所有 $m,n \\in \\mathbb{N}$ 都成立。\n\n该选项中提供的推理是合理的，其主张本身是关于 PA 的一个基本事实。\n\nE 的结论：**正确**。\n\n### 总结\n分析表明，陈述 A, B, D 和 E 是对皮亚诺算术的定理或性质的正确描述，而陈述 C 是不正确的。\n- **A** 是正确的，因为 PA 足够强大，可以证明由其公理定义的原始递归函数的全局性。\n- **B** 是正确的，因为 PA 可以执行计算，并且对于终止计算的证明长度有可行的界限。\n- **C** 是不正确的，因为乘法公理不能从其他公理中推导出来。\n- **D** 是正确的，展示了 PA 如何从递归定义中证明基本的代数恒等式。\n- **E** 是正确的，因为它是关于 PA 中可计算函数可表示性的基本定理的一个实例。\n\n正确的选项是 A, B, D, 和 E。", "answer": "$$\\boxed{ABDE}$$", "id": "3050644"}, {"introduction": "现在，我们将从单个函数的例子转向一个宏伟的定理：所有原始递归函数都可以在PA中表示。这个综合性练习将指导你完成整个结构归纳法证明，包括处理初始函数、复合运算闭包，以及最关键的原始递归闭包步骤。通过运用序列编码这一强大工具，你将为一般情况构造出表示公式，从而深刻理解数理逻辑中这一里程碑式的成果。[@problem_id:3042040]", "problem": "设算术的一阶语言由符号 $0$, $S$, $+$, $\\cdot$, $=$, 以及通常的逻辑联结词和量词给出。考虑皮亚诺算术 (PA)，它是该语言上带有归纳模式的算术公理化。一个全函数 $f:\\mathbb{N}^{k}\\to\\mathbb{N}$ 被称为是原始递归的，如果它能通过有限次应用函数复合和原始递归，从初始函数 $Z(\\bar{x})=0$、后继函数 $S(x)$ 和投影函数 $U_{i}^{k}(x_{1},\\dots,x_{k})=x_{i}$ 得到。其中，原始递归将一对函数 $(f,g)$ 映射到一个满足以下条件的函数 $h$：\n$$\nh(0,\\bar{x})=f(\\bar{x}) \\quad\\text{和}\\quad h(S(y),\\bar{x})=g\\big(y,h(y,\\bar{x}),\\bar{x}\\big).\n$$\n一个函数 $f$ 在皮亚诺算术 (PA) 中是可表示的，如果存在该语言中的一个公式 $\\varphi_{f}(\\bar{x},y)$，使得对于每一个 $\\bar{n}\\in\\mathbb{N}^{k}$ 和 $m\\in\\mathbb{N}$，$\\mathrm{PA}$ 证明 $\\exists! y\\,\\varphi_{f}(\\bar{\\overline{n}},y)$，并且 $\\mathrm{PA}$ 证明 $\\varphi_{f}(\\bar{\\overline{n}},\\overline{f(\\bar{n})})$。这里 $\\overline{n}$ 表示 $n$ 的数码，$\\bar{\\overline{n}}$ 表示数码的元组。\n\n假设以下经过充分检验的基础性事实：存在一个原始递归的序列编码函数 $\\beta(s,i)$ 和算术语言中的一个有界公式 $\\mathrm{Seq}(s,\\ell)$，使得对于每个有限函数 $a:\\{0,\\dots,\\ell-1\\}\\to\\mathbb{N}$，存在一个 $s$ 满足 $\\mathrm{Seq}(s,\\ell)$ 且对于所有 $i  \\ell$ 都有 $\\beta(s,i)=a(i)$，并且关于 $\\beta$ 和 $\\mathrm{Seq}$ 的这些性质在 $\\mathrm{PA}$ 中是可证的。\n\n仅使用上述定义和此编码事实作为基本依据，完成以下任务：\n\n- 解释在 $\\mathrm{PA}$ 中的可表示性需要什么，并说明为什么初始函数是可表示的。\n- 通过对原始递归函数的构造进行结构归纳，证明如果 $f$ 和 $g_i$ 是可表示的，那么它们的复合 $h(\\bar{x})=f(g_{1}(\\bar{x}),\\dots,g_{m}(\\bar{x}))$ 也是可表示的。\n- 使用序列编码事实，通过结构归纳证明，如果 $f$ 和 $g$ 是可表示的，那么由 $f$ 和 $g$ 决定的原始递归 $h$ 也是可表示的。\n- 总结出每个原始递归函数在 $\\mathrm{PA}$ 中都是可表示的。\n- 作为示例，为原始递归加法函数 $\\mathrm{add}(x,y)=x+y$ 给出一个在算术语言中的显式表示公式。\n\n你最终报告的答案必须是你的显式加法公式中使用的表示项，写成一个不含等号或逻辑联结词的单一封闭形式符号表达式。不要包含单位。", "solution": "问题陈述是数理逻辑中一个标准练习，涉及原始递归函数在一阶皮亚诺算术 (PA) 中的可表示性。\n\n### 问题验证\n**步骤1：提取已知条件**\n-   算术语言：符号 $0$, $S$, $+$, $\\cdot$, $=$, 逻辑联结词和量词。\n-   理论：带归纳模式的皮亚诺算术 (PA)。\n-   原始递归 (PR) 函数的定义：初始函数（零函数 $Z$、后继函数 $S$、投影函数 $U_{i}^{k}$）在复合和原始递归运算下的闭包。\n    -   初始函数：$Z(\\bar{x})=0$；$S(x)=x+1$；$U_{i}^{k}(x_{1},\\dots,x_{k})=x_{i}$。\n    -   复合：$h(\\bar{x})=f(g_{1}(\\bar{x}),\\dots,g_{m}(\\bar{x}))$。\n    -   原始递归：$h(0,\\bar{x})=f(\\bar{x})$ 且 $h(S(y),\\bar{x})=g(y,h(y,\\bar{x}),\\bar{x})$。\n-   可表示性定义：一个函数 $f:\\mathbb{N}^{k}\\to\\mathbb{N}$ 在 PA 中是可表示的，如果存在一个公式 $\\varphi_{f}(\\bar{x},y)$，使得对于任意 $\\bar{n}\\in\\mathbb{N}^{k}$，PA 证明 $\\exists! y\\,\\varphi_{f}(\\bar{\\overline{n}},y)$ 并且 PA 证明 $\\varphi_{f}(\\bar{\\overline{n}},\\overline{f(\\bar{n})})$。这里，$\\overline{n}$ 是数字 $n$ 的数码，即应用 $n$ 次 $S$ 的项 $S(S(\\dots S(0)\\dots))$。\n-   假设事实 (Gödel 的 β-函数引理)：存在一个 PR 序列编码函数 $\\beta(s,i)$ 和一个有界公式 $\\mathrm{Seq}(s,\\ell)$，其性质在 PA 中可证，允许对任意自然数有限序列进行编码。具体来说，关系 $v = \\beta(s,i)$ 可由算术语言中的一个公式定义，我们记为 $\\psi_{\\beta}(s,i,v)$。\n\n**步骤2：使用提取的已知条件进行验证**\n问题具有科学依据、提法明确且客观。\n-   **科学依据**：该问题是可计算性理论和形式算术研究的核心课题。定义和假设的引理是这些领域的标准和基础。它不违反任何数学原理。\n-   **提法明确**：该问题要求证明一个公认的定理。步骤清晰，提供的定义足以构建证明。存在唯一且正确的证明。\n-   **客观性**：语言形式化且精确。诸如“皮亚诺算术”、“原始递归”和“可表示”等术语在数理逻辑中有明确的定义。\n\n**步骤3：结论与行动**\n问题是有效的。将按要求进行解答。\n\n### 原始递归函数在 PA 中可表示性的证明\n\n我们对原始递归函数类进行结构归纳。\n\n**1. 初始函数的可表示性**\n\n如果存在一个公式 $\\varphi_f(\\bar{x},y)$，使得 PA 证明 $\\forall \\bar{x} \\exists!y \\varphi_f(\\bar{x},y)$ 并且对于所有 $\\bar{n} \\in \\mathbb{N}^k$，PA 证明 $\\varphi_f(\\bar{\\overline{n}}, \\overline{f(\\bar{n})})$，那么函数 $f$ 在 PA 中是可表示的。对于给定的 $\\bar{x}$，$y$ 的存在性和唯一性是至关重要的。\n\n-   **零函数**：$Z(x_{1},\\dots,x_{k})=0$。该函数由公式 $\\varphi_{Z}(\\bar{x},y) \\equiv y=0$ 表示。\n    -   PA 显然证明 $\\forall \\bar{x} \\exists!y (y=0)$，因为 $y$ 必须是 $0$。\n    -   对于任意 $\\bar{n}\\in\\mathbb{N}^k$, $Z(\\bar{n})=0$。我们需要证明 PA 证明 $\\varphi_{Z}(\\bar{\\overline{n}},\\overline{0})$，即 $\\overline{0}=0$。数码 $\\overline{0}$ 是常数符号 $0$，所以这是一个平凡的逻辑真理 $0=0$。\n\n-   **后继函数**：$S(x)=x+1$。该函数由公式 $\\varphi_{S}(x,y) \\equiv y=S(x)$ 表示。\n    -   对于任意项 $t$，PA 证明 $\\exists!y (y=t)$。所以 $\\forall x \\exists!y (y=S(x))$ 是可证的。\n    -   对于任意 $n\\in\\mathbb{N}$，$S(n)=n+1$。我们需要证明 PA 证明 $\\varphi_{S}(\\overline{n},\\overline{n+1})$。这就是公式 $\\overline{n+1} = S(\\overline{n})$。根据数码的定义，$\\overline{n+1}$ 就是项 $S(\\overline{n})$，所以这是一个逻辑恒等式 $S(\\overline{n}) = S(\\overline{n})$。\n\n-   **投影函数**：$U_{i}^{k}(x_{1},\\dots,x_{k})=x_i$。该函数由公式 $\\varphi_{U_i^k}(\\bar{x},y) \\equiv y=x_i$ 表示。\n    -   PA 证明 $\\forall \\bar{x} \\exists!y (y=x_i)$。\n    -   对于任意 $\\bar{n}=(n_1,\\dots,n_k)\\in\\mathbb{N}^k$，$U_i^k(\\bar{n})=n_i$。我们需要证明 PA 证明 $\\varphi_{U_i^k}(\\bar{\\overline{n}},\\overline{n_i})$，即 $\\overline{n_i}= \\overline{n_i}$，这是一个逻辑恒等式。\n\n因此，所有初始函数在 PA 中都是可表示的。\n\n**2. 复合运算下的封闭性**\n\n设 $h(\\bar{x}) = f(g_{1}(\\bar{x}),\\dots,g_{m}(\\bar{x}))$。假设 $f$ 以及对于 $i=1,\\dots,m$ 的每个 $g_i$ 分别由公式 $\\varphi_f(y_1,\\dots,y_m,z)$ 和 $\\varphi_{g_i}(\\bar{x},y_i)$ 在 PA 中可表示。我们定义 $h$ 的表示公式为：\n$$ \\varphi_h(\\bar{x},z) \\equiv \\exists y_1 \\dots \\exists y_m \\left( \\bigwedge_{i=1}^{m} \\varphi_{g_i}(\\bar{x}, y_i) \\land \\varphi_f(y_1, \\dots, y_m, z) \\right) $$\n我们必须证明这个公式表示 $h$。对于任意数码元组 $\\bar{\\overline{n}}$：\n-   **正确性和存在性**：对每个 $i$，令 $k_i=g_i(\\bar{n})$，并令 $p=f(k_1,\\dots,k_m)=h(\\bar{n})$。根据 $g_i$ 和 $f$ 的可表示性，PA 证明对每个 $i$ 都有 $\\varphi_{g_i}(\\bar{\\overline{n}},\\overline{k_i})$，并且 PA 证明 $\\varphi_f(\\overline{k_1},\\dots,\\overline{k_m},\\overline{p})$。通过用数码 $\\overline{k_1},\\dots,\\overline{k_m}$ 实例化 $\\varphi_h(\\bar{\\overline{n}},\\overline{p})$ 中的存在量词，我们看到 PA 证明了 $\\varphi_h(\\bar{\\overline{n}},\\overline{p})$。这确立了正确性，并蕴含了 $\\exists z \\varphi_h(\\bar{\\overline{n}},z)$ 的存在性。\n\n-   **唯一性**：假设 PA 证明了 $\\varphi_h(\\bar{\\overline{n}},z_1)$ 和 $\\varphi_h(\\bar{\\overline{n}},z_2)$。我们必须证明 PA 证明 $z_1=z_2$。\n    前提是：\n    $\\exists y_1 \\dots \\exists y_m (\\bigwedge_i \\varphi_{g_i}(\\bar{\\overline{n}}, y_i) \\land \\varphi_f(y_1, \\dots, y_m, z_1))$\n    $\\exists y'_1 \\dots \\exists y'_m (\\bigwedge_i \\varphi_{g_i}(\\bar{\\overline{n}}, y'_i) \\land \\varphi_f(y'_1, \\dots, y'_m, z_2))$\n    根据每个 $g_i$ 的唯一性属性，PA 证明对于任何 $y_i, y'_i$，如果 $\\varphi_{g_i}(\\bar{\\overline{n}},y_i)$ 和 $\\varphi_{g_i}(\\bar{\\overline{n}},y'_i)$ 成立，则 $y_i=y'_i$。因此，PA 证明对于所有 $i=1,\\dots,m$ 都有 $y_i=y'_i$。\n    代入这些等式，第二个前提蕴含 $\\varphi_f(y_1, \\dots, y_m, z_2)$。\n    现在我们有 $\\varphi_f(y_1, \\dots, y_m, z_1)$ 和 $\\varphi_f(y_1, \\dots, y_m, z_2)$。根据 $f$ 的唯一性属性，PA 证明 $z_1=z_2$。\n    因此，PA 证明 $\\exists! z \\varphi_h(\\bar{\\overline{n}},z)$。可表示函数集在复合运算下是封闭的。\n\n**3. 原始递归下的封闭性**\n\n设 $h$ 由 $f$ 和 $g$ 通过原始递归定义：\n$h(0, \\bar{x}) = f(\\bar{x})$\n$h(S(y), \\bar{x}) = g(y, h(y, \\bar{x}), \\bar{x})$\n假设 $f$ 和 $g$ 分别由 $\\varphi_f(\\bar{x},z)$ 和 $\\varphi_g(y,u,\\bar{x},v)$ 表示。值 $h(y,\\bar{x})$ 可以看作一个序列的第 $(y+1)$ 项，该序列的项是递归定义的。我们使用提供的序列编码机制来形式化这一点。关系 $v=\\beta(s,i)$ 可由一个公式 $\\psi_{\\beta}(s,i,v)$ 定义。公式 $\\varphi_h(y,\\bar{x},z)$ 表明存在一个长度为 $S(y)$（即 $y+1$）的序列 $s$，其第一个元素是 $f(\\bar{x})$，后续元素由 $g$ 生成，而 $z$ 是最后一个元素。\n$$\n\\varphi_h(y,\\bar{x},z) \\equiv \\exists s \\Bigg( \\mathrm{Seq}(s, S(y)) \\land \\exists v_0 \\bigg( \\psi_{\\beta}(s,0,v_0) \\land \\varphi_f(\\bar{x},v_0) \\bigg) \\land \\\\ \\forall i  y \\bigg( \\exists u \\exists v \\Big( \\psi_{\\beta}(s,i,u) \\land \\psi_{\\beta}(s,S(i),v) \\land \\varphi_g(i,u,\\bar{x},v) \\Big) \\bigg) \\land \\psi_{\\beta}(s,y,z) \\Bigg)\n$$\n-   **正确性和存在性**：对于任意 $n_y \\in \\mathbb{N}$ 和 $\\bar{n}_x \\in \\mathbb{N}^k$，考虑值的有限序列 $a_i = h(i, \\bar{n}_x)$，其中 $i=0,\\dots,n_y$。根据 $\\beta$-函数的假设性质，存在一个数 $s_0$ 编码该序列，即 PA 证明 $\\mathrm{Seq}(\\overline{s_0}, S(\\overline{n_y}))$ 并且对于 $i \\le n_y$ 有 $\\psi_\\beta(\\overline{s_0}, \\bar{i}, \\overline{a_i})$。根据 $f$ 和 $g$ 的可表示性以及 $h$ 的定义，PA 可以证明该序列满足递归条件。具体来说，PA 证明 $\\varphi_f(\\bar{\\overline{n}_x}, \\overline{a_0})$ 并且对于 $i  n_y$，PA 证明 $\\varphi_g(\\bar{i}, \\overline{a_i}, \\bar{\\overline{n}_x}, \\overline{a_{i+1}})$。将所有这些事实组合起来，PA 证明 $\\varphi_h(\\overline{n_y}, \\bar{\\overline{n}_x}, \\overline{a_{n_y}})$，因为我们可以用 $\\overline{s_0}$ 作为存在量词 $\\exists s$ 的见证。\n\n-   **唯一性**：唯一性证明更为复杂，需要对 $y$ 使用归纳。PA 可以证明，对于任意给定的 $y$ 和 $\\bar{x}$，满足条件的序列 $s$ 编码的值是唯一确定的。也就是说，如果 $s_1$ 和 $s_2$ 都满足 $\\varphi_h$ 中的条件，那么它们编码的序列在直到第 $y$ 项之前都必须是相同的。这可以通过在 PA 内部对 $i \\le y$ 进行归纳来证明。因此，最终值 $\\psi_\\beta(s,y,z)$ 也是唯一确定的。\n\n**4. 结论**\n\n通过对原始递归函数的定义进行结构归纳，我们已经表明：\n1.  所有初始函数在 PA 中都是可表示的。\n2.  如果 $f$ 和 $g_i$ 是可表示的，那么它们的复合也是可表示的。\n3.  如果 $f$ 和 $g$ 是可表示的，那么由它们定义的原始递归函数也是可表示的。\n因此，所有原始递归函数在 PA 中都是可表示的。\n\n**5. 示例：加法**\n\n加法函数 $\\mathrm{add}(x,y)=x+y$ 可以通过原始递归定义：\n-   $\\mathrm{add}(x,0) = x$ （基函数是投影 $U_1^1(x)=x$）\n-   $\\mathrm{add}(x, S(y)) = S(\\mathrm{add}(x,y))$ （递归函数是 $S$ 和投影的复合）\n\n然而，符号 $+$ 已经存在于 PA 的语言中，并且由公理定义。这些公理使我们能够证明 $z=x+y$ 满足强可表示性条件。因此，我们可以使用一个更简单的公式来表示加法函数。\n表示加法函数 $\\mathrm{add}(x,y)=z$ 的最直接的公式是：\n$$ \\varphi_{\\mathrm{add}}(x,y,z) \\equiv z = x+y $$\n正如问题要求，表示项本身是 $x+y$。", "answer": "$$\n\\boxed{x+y}\n$$", "id": "3042040"}, {"introduction": "我们的最终练习将可表示性的概念从原始递归函数推广到更广泛的可计算枚举集。我们将通过一种强大的技术——计算过程的算术化——来实现这一目标，即将一个机器的完整执行历史编码为单个自然数。你将定义一个捕捉“停机计算”概念的形式化公式，并利用它进行一次具体的编码计算，从而在形式算术和计算理论之间建立起一座坚实的桥梁。[@problem_id:3042000]", "problem": "我们在带加法和乘法符号的语言中，在一阶皮亚诺算术（PA）内进行工作。我们按如下方式固定标准的素数幂序列编码。令 $p_i$ 表示第 $i$ 个素数，其中 $p_0 = 2$，$p_1 = 3$，$p_2 = 5$，以此类推。对于一个自然数的有限序列 $\\langle a_0,\\dots,a_n \\rangle$，其编码是自然数\n$$\n\\prod_{i=0}^{n} p_i^{a_i+1}.\n$$\n我们将对带有一个指令指针的单寄存器确定性寄存器机 $e$ 的计算进行建模。一个构型（configuration）是一个序对 $(\\mathit{ip}, r)$，其中 $\\mathit{ip}$ 是当前指令的标签，$r$ 是唯一寄存器的内容。停机状态由 $\\mathit{ip} = 0$ 编码。一个构型 $(\\mathit{ip}, r)$ 的编码是\n$$\n\\mathrm{ConfCode}(\\mathit{ip}, r) \\;=\\; 2^{\\mathit{ip}+1} \\cdot 3^{r+1}.\n$$\n一次有限计算（运行）是一个构型的有限序列 $\\langle c_0, c_1, \\dots, c_m \\rangle$，满足 $c_0$ 是给定输入的初始构型，每个相邻序对 $(c_i, c_{i+1})$ 都由机器的单步转换关系所关联，并且 $c_m$ 是停机状态（其指令指针为 $0$）。这样一次运行的编码是构型编码序列的素数幂编码：\n$$\n\\mathrm{RunCode}(c_0,\\dots,c_m) \\;=\\; \\prod_{i=0}^{m} p_i^{\\mathrm{ConfCode}(c_i)+1}.\n$$\n任务：\n- 仅使用一阶算术和上述编码，定义一个公式 $\\mathrm{Halt}_e(x,y)$，它表示“$y$ 是机器 $e$ 在输入 $x$ 上的一次停机计算的编码”，其中一次计算是一个从初始构型开始到停机构型结束的有限构型序列，且连续的构型遵循 $e$ 的单步转换关系。你的定义必须属于 $\\Sigma_1$ 类。\n- 证明你的公式 $\\mathrm{Halt}_e(x,y)$ 是 $\\Sigma_1$ 的，并解释为什么这种 $\\Sigma_1$ 可定义性是通过形如 $\\exists y\\, \\mathrm{Halt}_e(x,y)$ 的谓词，在皮亚诺算术中实现所有可计算枚举集的可表示性的基础。\n- 考虑具有两条指令的特定机器 $e$：\n  1. 指令标签 $1$：将寄存器加一，并跳转到标签 $2$。\n  2. 指令标签 $2$：停机。\n  在输入 $x=1$ 的情况下，根据上述方案计算编码唯一停机计算的运行编码 $y$ 的确切值。以素数幂乘积的封闭形式给出最终答案。不要将其展开为十进制数。\n提供 $y$ 的最终值作为你的答案。无需四舍五入。", "solution": "该问题被认定为有效，因为它在数理逻辑上有科学依据，问题提出得当且客观。它不包含矛盾、歧义或不合理的假设。因此，我们可以着手解决。\n\n该问题包含三个任务：定义一个公式 `Halt_e(x, y)`，证明其性质以及与可计算枚举集的关系，并计算一个特定的运行编码。\n\n### 任务1：公式 $\\mathrm{Halt}_e(x,y)$ 的定义\n\n我们被要求在包含加法（$+$）和乘法（$\\cdot$）符号的一阶皮亚诺算术（PA）语言中，定义一个公式 $\\mathrm{Halt}_e(x,y)$，用以表示“$y$ 是机器 $e$ 在输入 $x$ 上的一次停机计算的编码”。该公式必须属于算术层级中的 $\\Sigma_1$ 类。\n\n一个数 $y$ 编码了一次停机计算，如果它是构型编码的有限序列 $\\langle c_0, c_1, \\dots, c_m \\rangle$ 的素数幂编码，并且满足以下条件：\n1.  该序列非空。\n2.  第一个构型 $c_0$ 是给定输入 $x$ 的初始构型。对于一个确定性寄存器机，初始构型通常是 $(\\mathit{ip}_{start}, x)$。我们假设初始指令指针 $\\mathit{ip}_{start}$ 为 $1$。\n3.  最后一个构型 $c_m$ 是一个停机构型，意味着其指令指针为 $0$。\n4.  序列中的每个后续构型 $c_{i+1}$ 都是由前一个构型 $c_i$ 经过机器 $e$ 的一步执行得到的，该执行由其转换关系定义。\n\n为了将其形式化，我们从几个辅助谓词构建公式 $\\mathrm{Halt}_e(x,y)$。这些谓词在 PA 中是可定义的。关键在于诸如素性测试、第 $i$ 个素数函数 ($p_i$) 和幂运算 ($a^b$) 等函数的可定义性。尽管 PA 的语言仅包含 $+$ 和 $\\cdot$，但这些概念确实是可定义的。特别地，幂运算是 $\\Delta_1$-可定义的。所有原始递归函数和关系在 PA 中都是 $\\Delta_1$-可定义的。由 $\\mathrm{Halt}_e(x,y)$ 表示的关系是原始递归的，这保证了其 $\\Delta_1$-可定义性，因此也保证了等价的 $\\Sigma_1$ 公式的存在。\n\n让我们来定义该公式的各个组成部分。\n\n**辅助谓词：**\n\n-   $\\mathrm{IsPrime}(p)$: 一个陈述 $p$ 是素数的公式。\n    $\\mathrm{IsPrime}(p) \\equiv p  1 \\land \\forall d  p (d  1 \\to \\neg(\\exists k  p (d \\cdot k = p)))$。这是一个 $\\Delta_0$ 公式。\n-   $\\mathrm{NthPrime}(i, p)$: 一个陈述 $p$ 是第 $i$ 个素数（$p_i$）的公式。这是 $\\Delta_1$-可定义的。\n-   $\\mathrm{exp}(n, p, k)$: 一个陈述 $k$ 是素数 $p$ 在 $n$ 的素数分解中的指数的公式。\n    $\\mathrm{exp}(n, p, k) \\equiv p^k | n \\land \\neg(p^{k+1} | n)$。由于幂运算，这是 $\\Delta_1$ 的。\n-   $\\mathrm{GetElem}(y, i, c)$: 一个陈述 $c$ 是由 $y$ 编码的序列中第 $(i+1)$ 个元素的公式。根据问题的编码方式，这意味着 $c+1$ 是 $p_i$ 的指数。\n    $\\mathrm{GetElem}(y, i, c) \\equiv \\exists p (\\mathrm{NthPrime}(i, p) \\land \\mathrm{exp}(y, p, c+1))$。\n-   $\\mathrm{Len}(y, m)$: 一个陈述由 $y$ 编码的序列长度为 $m$ 的公式。\n    $\\mathrm{Len}(y, m) \\equiv \\exists p, q (\\mathrm{NthPrime}(m-1, p) \\land p|y \\land \\mathrm{NthPrime}(m, q) \\land \\neg(q|y))$。\n\n**构型谓词：**\n\n-   $\\mathrm{ConfCode}(ip, r, c)$: 一个陈述 $c$ 是构型 $(\\mathit{ip}, r)$ 的编码的公式。\n    $\\mathrm{ConfCode}(ip, r, c) \\equiv c = 2^{\\mathit{ip}+1} \\cdot 3^{r+1}$。\n-   $\\mathrm{GetIP}(c, ip)$: 一个从构型编码 $c$ 中提取指令指针的公式。\n    $\\mathrm{GetIP}(c, ip) \\equiv \\mathrm{exp}(c, 2, \\mathit{ip}+1)$。\n-   $\\mathrm{GetR}(c, r)$: 一个从构型编码 $c$ 中提取寄存器值的公式。\n    $\\mathrm{GetR}(c, r) \\equiv \\mathrm{exp}(c, 3, r+1)$。\n\n**计算步骤谓词：**\n\n-   $\\mathrm{Transition}_e(c, c')$: 一个陈述构型 $c'$ 在机器 $e$ 的一步操作后由 $c$ 得到的公式。这是对 $e$ 的所有指令的析取。对于一个有 $k$ 条指令的机器，其形式为：\n    $\\mathrm{Transition}_e(c, c') \\equiv \\bigvee_{j=1}^{k} \\Phi_j(c, c')$, 其中 $\\Phi_j$ 形式化了指令 $j$ 的效果。每个 $\\Phi_j$ 的形式为 $\\exists \\mathit{ip}, r, \\mathit{ip}', r' (\\mathrm{GetIP}(c, \\mathit{ip}) \\land \\mathrm{GetR}(c, r) \\land \\mathit{ip}=j \\land (\\text{指令 } j \\text{ 的逻辑}) \\land \\mathrm{ConfCode}(\\mathit{ip}', r', c'))$。\n\n**完整的公式 $\\mathrm{Halt}_e(x,y)$：**\n\n结合这些，我们如下定义 $\\mathrm{Halt}_e(x,y)$。它断言计算序列存在一个长度 $m+1$，并且对于从 $0$ 到 $m-1$ 的所有步骤 $i$，从构型 $i$ 到 $i+1$ 的转换都是有效的。\n\n$\\mathrm{Halt}_e(x,y) \\equiv$\n$\\exists m  0 \\, \\Big( \\mathrm{Len}(y, m+1) \\land $\n$\\quad \\exists c_0 \\, \\big( \\mathrm{GetElem}(y, 0, c_0) \\land \\mathrm{ConfCode}(1, x, c_0) \\big) \\land $\n$\\quad \\exists c_m \\, \\big( \\mathrm{GetElem}(y, m, c_m) \\land \\exists \\mathit{ip}_m (\\mathrm{GetIP}(c_m, \\mathit{ip}_m) \\land \\mathit{ip}_m = 0) \\big) \\land $\n$\\quad \\forall i  m \\, \\exists c_i, c_{i+1} \\, \\big( \\mathrm{GetElem}(y, i, c_i) \\land \\mathrm{GetElem}(y, i+1, c_{i+1}) \\land \\mathrm{Transition}_e(c_i, c_{i+1}) \\big) \\Big)$\n\n此公式中的所有量词都是有界的（例如，$m  y$，$c_i  y$），除了那些隐藏在辅助谓词中的量词（特别是幂运算）。该关系是原始递归的，所以它是 $\\Delta_1$ 的。根据算术层级的定义，一个 $\\Delta_1$ 公式可证明地等价于一个 $\\Sigma_1$ 公式。因此，这个构造定义了所求的关系，并且存在一个等价的 $\\Sigma_1$ 公式。\n\n### 任务2：$\\Sigma_1$ 可定义性与可表示性的证明\n\n**$\\Sigma_1$ 可定义性：** 如果一个公式形如 $\\exists z_1 \\dots \\exists z_k \\phi$，其中 $\\phi$ 是一个 $\\Delta_0$ 公式（其所有量词都有界），那么这个公式就是 $\\Sigma_1$ 的。谓词 $R(x,y) \\equiv$ “$y$ 是机器 $e$ 在输入 $x$ 上的一次停机计算的编码”是一个可判定谓词。给定 $x$ 和 $y$，可以在有限步内机械地检查 $y$ 是否具有所需的属性。这样的谓词被称为“原始递归”的。由 Gödel 建立的可计算性理论和逻辑的一个基本结果是，每个原始递归关系在皮亚诺算术中都可由一个 $\\Delta_1$ 公式定义。如果一个公式在 PA 中既等价于一个 $\\Sigma_1$ 公式，又等价于一个 $\\Pi_1$ 公式，那么它就是 $\\Delta_1$ 的。因此，我们的谓词 $\\mathrm{Halt}_e(x,y)$ 是 $\\Sigma_1$-可定义的。上面提供的半形式化定义是这一事实的证明草图。\n\n**与可计算枚举集的关系：** 这种 $\\Sigma_1$ 可定义性是在 PA 内表示所有可计算枚举（CE）集的基础。\n1.  一个集合 $S \\subseteq \\mathbb{N}$ 是可计算枚举的，当且仅当存在一个寄存器机 $e$，它在输入 $x$ 上停机，当且仅当 $x \\in S$。\n2.  “机器 $e$ 在输入 $x$ 上停机”这一陈述等价于断言存在一次相应的停机计算。\n3.  在我们的形式系统中，这转化为：“存在一个数 $y$，它是机器 $e$ 在输入 $x$ 上的一次停机计算的编码”。\n4.  这可以用我们定义的谓词写成公式 $\\exists y \\, \\mathrm{Halt}_e(x, y)$。\n5.  由于 $\\mathrm{Halt}_e(x, y)$ 可由一个 $\\Sigma_1$ 公式定义（如上文所述），设为 $\\psi(x, y)$，则公式 $\\exists y \\, \\psi(x, y)$ 也是 $\\Sigma_1$ 的。\n这就建立了一个直接的对应关系：对于每个 CE 集 $S$，都有一个形如 $\\exists y \\, \\mathrm{Halt}_e(x, y)$ 的 $\\Sigma_1$ 公式 $\\Phi_S(x)$，使得 $x \\in S \\iff \\mathbb{N} \\models \\Phi_S(x)$。这表明 $\\Sigma_1$-可定义的集合类恰好就是可计算枚举集合类。\n此外，PA 的 $\\Sigma_1$ 可靠性（Soundness）和完备性（Completeness）定理指出，对于任何 $\\Sigma_1$ 语句 $\\phi$，有 $\\mathbb{N} \\models \\phi \\iff PA \\vdash \\phi$。这意味着对于任何 $n \\in S$，不仅 $\\Phi_S(\\bar{n})$ 为真，而且它在 PA 中也是可证的。这个性质被称为 CE 集在 PA 中的 $\\Sigma_1$-可表示性。\n\n### 任务3：运行编码的计算\n\n我们给定了一个特定的机器 $e$ 和输入 $x=1$。\n-   **机器 $e$**：\n    1.  标签 $1$ 处的指令：将寄存器加一，跳转到标签 $2$。\n    2.  标签 $2$ 处的指令：停机（即跳转到标签 $0$）。\n-   **输入**：$x=1$。\n\n我们追踪这次计算，它是一个构型序列 $(\\mathit{ip}, r)$。\n1.  **初始构型 ($c_0$)**：计算从指令标签 $1$ 开始，寄存器中存有输入 $x=1$。\n    $c_0 = (\\mathit{ip}=1, r=1)$。\n2.  **步骤 1**：执行指令 $1$。寄存器 $r$ 被加一（$r \\to 1+1=2$），指令指针 $\\mathit{ip}$ 跳转到 $2$。下一个构型是：\n    $c_1 = (\\mathit{ip}=2, r=2)$。\n3.  **步骤 2**：执行指令 $2$。这是一条停机指令，我们将其建模为将指令指针设为 $0$。寄存器值保持不变。最终构型是：\n    $c_2 = (\\mathit{ip}=0, r=2)$。\n由于 $\\mathit{ip}=0$，机器已经停机。完整的计算轨迹是序列 $\\langle c_0, c_1, c_2 \\rangle$。\n\n接下来，我们使用 $\\mathrm{ConfCode}(\\mathit{ip}, r) = 2^{\\mathit{ip}+1} \\cdot 3^{r+1}$ 计算每个构型的编码。\n-   对于 $c_0 = (1, 1)$：编码 $a_0 = \\mathrm{ConfCode}(1, 1) = 2^{1+1} \\cdot 3^{1+1} = 2^2 \\cdot 3^2 = 4 \\cdot 9 = 36$。\n-   对于 $c_1 = (2, 2)$：编码 $a_1 = \\mathrm{ConfCode}(2, 2) = 2^{2+1} \\cdot 3^{2+1} = 2^3 \\cdot 3^3 = 8 \\cdot 27 = 216$。\n-   对于 $c_2 = (0, 2)$：编码 $a_2 = \\mathrm{ConfCode}(0, 2) = 2^{0+1} \\cdot 3^{2+1} = 2^1 \\cdot 3^3 = 2 \\cdot 27 = 54$。\n\n构型编码的序列是 $\\langle a_0, a_1, a_2 \\rangle = \\langle 36, 216, 54 \\rangle$。\n\n最后，我们使用公式 $\\mathrm{RunCode} = \\prod_{i=0}^{m} p_i^{a_i+1}$ 来计算运行编码 $y$，其中 $m=2$。素数为 $p_0=2$，$p_1=3$，$p_2=5$。\n指数为 $a_i+1$：\n-   对于 $i=0$：指数为 $a_0+1 = 36+1 = 37$。\n-   对于 $i=1$：指数为 $a_1+1 = 216+1 = 217$。\n-   对于 $i=2$：指数为 $a_2+1 = 54+1 = 55$。\n\n运行编码 $y$是这些素数幂的乘积：\n$$y = p_0^{a_0+1} \\cdot p_1^{a_1+1} \\cdot p_2^{a_2+1} = 2^{37} \\cdot 3^{217} \\cdot 5^{55}$$", "answer": "$$\n\\boxed{2^{37} \\cdot 3^{217} \\cdot 5^{55}}\n$$", "id": "3042000"}]}