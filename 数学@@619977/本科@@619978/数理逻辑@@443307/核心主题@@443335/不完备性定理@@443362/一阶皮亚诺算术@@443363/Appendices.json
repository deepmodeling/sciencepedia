{"hands_on_practices": [{"introduction": "在我们能够陈述和证明关于自然数的定理之前，我们必须首先有一种在形式语言中明确“写下”这些数的方法。这个练习将向您展示如何仅使用皮亚诺算术最基本的符号——常数 $0$ 和后继函数符号 $S$ ——来系统地表示任何自然数。这项基本技能将直观的数字概念与它们在形式系统中的严格符号表示联系起来，这是迈向算术形式化的第一步 [@problem_id:3042003]。", "problem": "考虑皮亚诺算术（PA）的一阶语言，记为 $\\mathcal{L}_{PA}$，其非逻辑符号为常数符号 $0$、一元函数符号 $S$、二元函数符号 $+$ 和 $\\cdot$，以及二元谓词符号 $=$。在此语言中，一个项由以下基本句法规则构成：如果 $c$ 是一个常数符号，那么 $c$ 是一个项；如果 $f$ 是一个 $k$-元函数符号且 $t_{1},\\dots,t_{k}$ 是项，那么 $f(t_{1},\\dots,t_{k})$ 是一个项；并且每个变量都是一个项。一个不含变量的项称为闭项。$S$ 的预期解释是 $\\mathbb{N}$ 上的后继运算。\n\n请仅使用上述构成规则以及符号 $0$ 和 $S$，为每个 $n \\in \\mathbb{N}$ 定义一个闭 $\\mathcal{L}_{PA}$-项 $\\overline{n}$，称为 $n$ 的数码，它在 $\\mathcal{L}_{PA}$ 内部句法地表示 $n$。请通过基于项的基本规则的构造来证明您的定义是良基的，并解释为什么对于每个 $n \\in \\mathbb{N}$，所得到的 $\\overline{n}$ 都是一个闭项。然后，计算特定数码 $\\overline{4}$ 关于 $S$ 和 $0$ 的闭式表达式。您的最终答案必须是一个单一的符号表达式，无需四舍五入。", "solution": "问题陈述已经过严格验证。它在科学上是合理的，问题提法是适定的，客观的，并且完全符合一阶逻辑和皮亚诺算术的既定原则。其前提准确，语言精确，任务是数理逻辑中一个标准的、基本的练习。因此，该问题被认定为有效。\n\n任务是在皮亚诺算术的一阶语言 $\\mathcal{L}_{PA}$ 中为每个自然数 $n \\in \\mathbb{N}$ 定义一个句法表示。这些表示称为数码，记作 $\\overline{n}$，它们必须是仅使用常数符号 $0$ 和一元函数符号 $S$ 构造的闭项。\n\n数码 $\\overline{n}$ 的定义是通过对自然数 $n$ 的递归给出的。这种方法反映了自然数本身的归纳结构，其中每个数要么是 $0$，要么是另一个数的后继。\n\n形式化的递归定义如下：\n1.  **基本情况**：对于自然数 $0$，相应的数码 $\\overline{0}$ 被定义为语言 $\\mathcal{L}_{PA}$ 中的常数符号 $0$。\n    $$ \\overline{0} := 0 $$\n2.  **递归步骤**：对于任意自然数 $n$，如果数码 $\\overline{n}$ 已被定义，那么 $n$ 的后继（记作 $n+1$）的数码被定义为将后继函数符号 $S$ 应用于项 $\\overline{n}$。\n    $$ \\overline{n+1} := S(\\overline{n}) $$\n\n为了证明这个定义对每个 $n \\in \\mathbb{N}$ 都产生一个有效的项，我们对 $n$ 使用数学归纳法原理。\n**基本情况 ($n=0$)**：数码是 $\\overline{0} := 0$。根据问题的项构成规则，“如果 $c$ 是一个常数符号，那么 $c$ 是一个项”。因为 $0$ 是 $\\mathcal{L}_{PA}$ 中的一个常数符号，所以 $\\overline{0}$ 是一个有效的项。\n**归纳步骤**：假设归纳假设成立，即对于某个 $k \\in \\mathbb{N}$，数码 $\\overline{k}$ 是一个有效的项。我们必须证明 $\\overline{k+1}$ 也是一个有效的项。根据递归定义，$\\overline{k+1} := S(\\overline{k})$。符号 $S$ 是一个 $1$-元（一元）函数符号，并且根据归纳假设，$\\overline{k}$ 是一个项。项构成的第二条规则指出，“如果 $f$ 是一个 $k$-元函数符号且 $t_{1},\\dots,t_{k}$ 是项，那么 $f(t_{1},\\dots,t_{k})$ 是一个项”。将此规则应用于 $f$ 为 $S$ 且项 $t_1$ 为 $\\overline{k}$ 的情况，我们得出结论 $S(\\overline{k})$ 是一个有效的项。因此，$\\overline{k+1}$ 是一个有效的项。\n根据数学归纳法原理，对于所有 $n \\in \\mathbb{N}$，$\\overline{n}$ 都是一个良定义的项。\n\n接下来，我们必须解释为什么对于每个 $n \\in \\mathbb{N}$，$\\overline{n}$ 都是一个闭项。一个项如果不含自由变量，则称为闭项。我们再次对 $n$ 进行归纳。\n**基本情况 ($n=0$)**：项是 $\\overline{0} := 0$。常数符号不是变量，所以项 $0$ 不含变量。因此，$\\overline{0}$ 是一个闭项。\n**归纳步骤**：假设归纳假设成立，即对于某个 $k \\in \\mathbb{N}$，数码 $\\overline{k}$ 是一个闭项，意味着它不含变量。数码 $\\overline{k+1}$ 被构造为 $S(\\overline{k})$。引入的唯一新符号是函数符号 $S$ 和括号，它们都不是变量。由于根据假设，子项 $\\overline{k}$ 不含变量，所以整个项 $S(\\overline{k})$ 也必定不含变量。因此，$\\overline{k+1}$ 是一个闭项。\n根据数学归纳法原理，对于所有 $n \\in \\mathbb{N}$，$\\overline{n}$ 都是一个闭项。\n\n最后，我们被要求计算特定数码 $\\overline{4}$ 的闭式表达式。我们逐步应用递归定义：\n$0$ 的数码是 $\\overline{0} := 0$。\n$1$ 的数码是 $\\overline{1} := S(\\overline{0}) = S(0)$。\n$2$ 的数码是 $\\overline{2} := S(\\overline{1}) = S(S(0))$。\n$3$ 的数码是 $\\overline{3} := S(\\overline{2}) = S(S(S(0)))$。\n$4$ 的数码是 $\\overline{4} := S(\\overline{3}) = S(S(S(S(0))))$。\n这个最终表达式是一个完全由符号 $S$ 和 $0$ 构成的闭项，符合要求。", "answer": "$$\n\\boxed{S(S(S(S(0))))}\n$$", "id": "3042003"}, {"introduction": "一旦我们掌握了如何构造表示数字的项（term），下一步就是将它们组合成有意义的陈述，即“合式公式”（well-formed formulas）。这个练习要求您运用递归定义来验证一个表达式的语法正确性，并区分公式中的自由变量和约束变量 [@problem_id:3042045]。理解量词的作用域对于精确地解释和操作逻辑陈述至关重要，就像学习一门语言的语法一样，是进行形式推理的基础。", "problem": "在皮亚诺算术（PA）的标准一阶语言（记为 $L_{\\mathrm{PA}}$）中进行演算，其非逻辑符号为常数符号 $0$、一元函数符号 $S$、二元函数符号 $+$ 和 $\\times$，以及二元谓词符号 $=$。逻辑符号为 $\\forall$、$\\exists$、$\\wedge$、括号和变量。考虑 $L_{\\mathrm{PA}}$ 表达式\n$$\n\\forall x\\,\\exists y\\,\\bigl(y = S(x) \\wedge \\exists z\\,(z = x + y \\wedge x = z \\times 0)\\bigr).\n$$\n仅使用一阶逻辑中项和公式的原始构成规则以及 $L_{\\mathrm{PA}}$ 中的符号元数，从第一性原理出发，证明所显示的表达式是一个合式公式。然后确定其自由变量的集合。将自由变量集合的基数作为你的最终答案。无需四舍五入。", "solution": "本问题将首先通过验证其陈述来解决，在确认其有效性后，再进行详细解答。\n\n### 问题验证\n\n**第1步：提取已知条件**\n-   **语言：**皮亚诺算术的标准一阶语言，记为 $L_{\\mathrm{PA}}$。\n-   **非逻辑符号：**\n    -   常数符号：$0$（元数为 $0$）\n    -   一元函数符号：$S$（元数为 $1$）\n    -   二元函数符号：$+$（元数为 $2$）、$\\times$（元数为 $2$）\n    -   二元谓词符号：$=$（元数为 $2$）\n-   **逻辑符号：**$\\forall$、$\\exists$、$\\wedge$、括号和变量。\n-   **待分析的表达式：** $\\forall x\\,\\exists y\\,\\bigl(y = S(x) \\wedge \\exists z\\,(z = x + y \\wedge x = z \\times 0)\\bigr)$。\n-   **任务：**\n    1.  从第一性原理出发，证明该表达式是一个合式公式（wff）。\n    2.  确定其自由变量的集合。\n    3.  将自由变量集合的基数作为最终答案报告。\n\n**第2步：使用提取的已知条件进行验证**\n-   **科学依据：** 该问题牢固地植根于数理逻辑，具体来说是一阶逻辑和形式算术。语言 $L_{\\mathrm{PA}}$、构成项和公式的规则，以及自由变量的概念都是该领域标准的、明确定义的组成部分。不存在科学上或事实上的不健全之处。\n-   **适定性：** 任务清晰，并具有唯一的、可验证的答案。证明合式性的过程和识别自由变量的过程是算法性的，并且基于一阶逻辑中语法的归纳定义。\n-   **客观性：** 问题使用形式化的、无歧义的语言陈述。所有术语都在 $L_{\\mathrm{PA}}$ 的上下文中被精确定义。\n-   **结论：** 问题陈述是自洽的、一致的且适定的。它没有违反任何指定的有效性标准。因此，可以构建一个解决方案。\n\n### 解答\n\n根据要求，解答分为两部分：首先，证明该表达式是一个合式公式（wff）；其次，确定其自由变量的集合。\n\n**第1部分：合式性的证明**\n\n我们使用一阶语言中项和公式的递归定义。设给定的表达式为 $\\Phi$。\n\n**$L_{\\mathrm{PA}}$ 中项的递归定义：**\n1.  任何变量（例如，$x$、$y$、$z$）都是一个项。\n2.  常数符号 $0$ 是一个项。\n3.  如果 $t$ 是一个项，那么 $S(t)$ 是一个项。\n4.  如果 $t_1$ 和 $t_2$ 是项，那么 $(t_1+t_2)$ 和 $(t_1 \\times t_2)$ 是项。（按照惯例，最外层的括号通常被省略）。\n\n**$L_{\\mathrm{PA}}$ 中公式的递归定义：**\n1.  如果 $t_1$ 和 $t_2$ 是项，那么 $t_1 = t_2$ 是一个原子公式。\n2.  如果 $\\phi$ 和 $\\psi$ 是公式，那么 $(\\phi \\wedge \\psi)$ 是一个公式。\n3.  如果 $\\phi$ 是一个公式且 $v$ 是一个变量，那么 $\\exists v\\,\\phi$ 和 $\\forall v\\,\\phi$ 是公式。\n\n我们现在自底向上地构造给定的表达式 $\\Phi$，证明每个组成部分要么是一个有效的项，要么是一个有效的公式。\n\n1.  **项：**\n    -   变量 $x$、$y$、$z$ 根据定义是项（项规则1）。\n    -   常数符号 $0$ 根据定义是项（项规则2）。\n    -   因为 $x$ 是一个项，所以 $S(x)$ 是一个项（项规则3）。\n    -   因为 $x$ 和 $y$ 是项，所以 $x+y$ 是一个项（项规则4）。\n    -   因为 $z$ 和 $0$ 是项，所以 $z \\times 0$ 是一个项（项规则4）。\n\n2.  **原子公式：**\n    -   因为 $z$ 和 $x+y$ 是项，所以 $z = x+y$ 是一个原子公式（公式规则1）。我们称之为 $\\phi_A$。\n    -   因为 $x$ 和 $z \\times 0$ 是项，所以 $x = z \\times 0$ 是一个原子公式（公式规则1）。我们称之为 $\\phi_B$。\n    -   因为 $y$ 和 $S(x)$ 是项，所以 $y = S(x)$ 是一个原子公式（公式规则1）。我们称之为 $\\phi_C$。\n\n3.  **复合公式：**\n    -   因为 $\\phi_A$ 和 $\\phi_B$ 是公式，所以 $(\\phi_A \\wedge \\phi_B)$ 是一个公式（公式规则2）。这对应于 $(z = x + y \\wedge x = z \\times 0)$。我们称这个公式为 $\\psi_1$。\n    -   因为 $\\psi_1$ 是一个公式且 $z$ 是一个变量，所以 $\\exists z\\,\\psi_1$ 是一个公式（公式规则3）。这对应于 $\\exists z\\,(z = x + y \\wedge x = z \\times 0)$。我们称这个公式为 $\\psi_2$。\n    -   因为 $\\phi_C$ 和 $\\psi_2$ 是公式，所以 $(\\phi_C \\wedge \\psi_2)$ 是一个公式（公式规则2）。这对应于 $(y = S(x) \\wedge \\exists z\\,(z = x + y \\wedge x = z \\times 0))$。给定的表达式使用 $\\bigl( \\dots \\bigr)$ 进行分组，这在语法上等同于 $(\\dots)$。我们称这个公式为 $\\psi_3$。\n    -   因为 $\\psi_3$ 是一个公式且 $y$ 是一个变量，所以 $\\exists y\\,\\psi_3$ 是一个公式（公式规则3）。我们称这个公式为 $\\psi_4$。\n    -   因为 $\\psi_4$ 是一个公式且 $x$ 是一个变量，所以 $\\forall x\\,\\psi_4$ 是一个公式（公式规则3）。这就是原始表达式 $\\Phi$。\n\n这个基于项和公式的原始构成规则的逐步构造过程，证明了表达式 $\\forall x\\,\\exists y\\,\\bigl(y = S(x) \\wedge \\exists z\\,(z = x + y \\wedge x = z \\times 0)\\bigr)$ 是 $L_{\\mathrm{PA}}$ 中的一个合式公式。\n\n**第2部分：确定自由变量的集合**\n\n公式 $\\phi$ 的自由变量集合，记为 $FV(\\phi)$，是递归定义的。\n\n**自由变量（$FV$）的递归定义：**\n1.  对于原子公式 $t_1 = t_2$，有 $FV(t_1 = t_2) = V(t_1) \\cup V(t_2)$，其中 $V(t)$ 是出现在项 $t$ 中的变量集合。\n2.  对于公式 $(\\phi \\wedge \\psi)$，有 $FV(\\phi \\wedge \\psi) = FV(\\phi) \\cup FV(\\psi)$。\n3.  对于公式 $\\exists v\\,\\phi$，有 $FV(\\exists v\\,\\phi) = FV(\\phi) \\setminus \\{v\\}$。\n4.  对于公式 $\\forall v\\,\\phi$，有 $FV(\\forall v\\,\\phi) = FV(\\phi) \\setminus \\{v\\}$。\n\n我们将这些规则应用于公式 $\\Phi$ 及其在第1部分中识别出的子公式。\n\n1.  **原子公式：**\n    -   $FV(\\phi_A) = FV(z = x+y) = V(z) \\cup V(x+y) = \\{z\\} \\cup (\\{x\\} \\cup \\{y\\}) = \\{x, y, z\\}$。\n    -   $FV(\\phi_B) = FV(x = z \\times 0) = V(x) \\cup V(z \\times 0) = \\{x\\} \\cup \\{z\\} = \\{x, z\\}$。\n    -   $FV(\\phi_C) = FV(y = S(x)) = V(y) \\cup V(S(x)) = \\{y\\} \\cup \\{x\\} = \\{x, y\\}$。\n\n2.  **复合公式：**\n    -   $FV(\\psi_1) = FV(\\phi_A \\wedge \\phi_B) = FV(\\phi_A) \\cup FV(\\phi_B) = \\{x, y, z\\} \\cup \\{x, z\\} = \\{x, y, z\\}$。\n    -   $FV(\\psi_2) = FV(\\exists z\\,\\psi_1) = FV(\\psi_1) \\setminus \\{z\\} = \\{x, y, z\\} \\setminus \\{z\\} = \\{x, y\\}$。\n    -   $FV(\\psi_3) = FV(\\phi_C \\wedge \\psi_2) = FV(\\phi_C) \\cup FV(\\psi_2) = \\{x, y\\} \\cup \\{x, y\\} = \\{x, y\\}$。\n    -   $FV(\\psi_4) = FV(\\exists y\\,\\psi_3) = FV(\\psi_3) \\setminus \\{y\\} = \\{x, y\\} \\setminus \\{y\\} = \\{x\\}$。\n    -   $FV(\\Phi) = FV(\\forall x\\,\\psi_4) = FV(\\psi_4) \\setminus \\{x\\} = \\{x\\} \\setminus \\{x\\} = \\emptyset$。\n\n给定公式中的自由变量集合是空集 $\\emptyset$。没有自由变量的公式被称为一个句子或一个闭合公式。\n\n**第3部分：自由变量集合的基数**\n\n一个集合的基数是该集合中元素的数量。自由变量的集合是 $\\emptyset$。\n空集 $\\emptyset$ 的基数 $|\\emptyset|$ 是 $0$。", "answer": "$$\\boxed{0}$$", "id": "3042045"}, {"introduction": "一个形式表达式，例如 $S(0) + S(0)$，本身只是一串符号。它究竟“意味着”什么？这就引出了语法（syntax）和语义（semantics）之间的关键区别。这个练习挑战您去辨析“语法相等”（即符号串完全相同）与“语义相等”（即在某个具体的解释下，比如在自然数集合中，代表相同的值）[@problem_id:3042049]。这一区分是数理逻辑的核心，它将纯粹的符号操作（可证明性）与数学结构中的真值（模型论）清晰地分离开来。", "problem": "考虑用于 Peano 算术 (PA) 的标准一阶算术语言 $\\mathcal{L}_{\\mathrm{PA}}$，其非逻辑符号为常数 $0$、一元函数符号 $S$、二元函数符号 $+$ 和 $\\times$，以及意为恒等的等号 $=$。在此设定中，项是根据通常的构成规则由变量、常数和函数符号构成的。一个解释提供一个论域以及非逻辑符号的指称，一个变量赋值将变量映射到论域中的元素。\n\n哪个选项同时给出了 $\\mathcal{L}_{\\mathrm{PA}}$-项的句法相等的精确定义、两个项相对于一个解释和一个变量赋值的语义相等的精确定义，以及在标准模型 $\\mathbb{N}$（其中 $0$ 被解释为数字零，$S$ 被解释为后继函数 $n \\mapsto n+1$，$+$ 和 $\\times$ 被解释为 $\\mathbb{N}$ 上的通常加法和乘法）中两个不同的闭项指称同一个元素的正确例子？\n\nA. 句法相等：两个项 $t_1$ 和 $t_2$ 是句法相等的，当且仅当它们是字面上相同的有限符号序列（逐个符号相同）。语义相等：对于一个解释 $\\mathcal{M}$ 和变量赋值 $s$，两个项 $t_1$ 和 $t_2$ 是语义相等的，当且仅当 $\\llbracket t_1 \\rrbracket^{\\mathcal{M},s} = \\llbracket t_2 \\rrbracket^{\\mathcal{M},s}$。在 $\\mathbb{N}$ 中的例子：项 $S(S(0))$ 和 $S(0) + S(0)$ 都指称 $2$。\n\nB. 句法相等：两个项 $t_1$ 和 $t_2$ 是句法相等的，当且仅当 PA 证明公式 $t_1 = t_2$。语义相等：两个项是语义相等的，当且仅当公式 $t_1 = t_2$ 在 $\\mathcal{L}_{\\mathrm{PA}}$ 的每个解释中都为真。在 $\\mathbb{N}$ 中的例子：$S(0)$ 和 $0$ 指称同一个元素。\n\nC. 句法相等：如果两个项可以通过使用 PA 中关于 $+$ 和 $\\times$ 的公理（例如，结合律或交换律）重写它们使之变得相同，那么它们是句法相等的。语义相等：对于一个解释 $\\mathcal{M}$ 和赋值 $s$，如果 PA 证明 $t_1 = t_2$，则两个项是语义相等的。在 $\\mathbb{N}$ 中的例子：$0 + 0$ 和 $0$ 指称同一个元素。\n\nD. 句法相等：两个项是句法相等的，当且仅当它们是相同的符号序列。语义相等：对于一个解释 $\\mathcal{M}$ 和赋值 $s$，两个项是语义相等的，当且仅当它们的指称在 $\\mathcal{M}$ 和 $s$ 下重合。在 $\\mathbb{N}$ 中的例子：$S(0)$ 和 $S(0) + S(0)$ 指称同一个元素。\n\nE. 句法相等：如果两个项在标准模型 $\\mathbb{N}$ 中指称同一个元素，那么它们是句法相等的。语义相等：两个项是语义相等的，当且仅当它们是字面上相同的字符串。在 $\\mathbb{N}$ 中的例子：$0 \\times S(0)$ 和 $0$ 指称同一个元素。", "solution": "在尝试给出解答之前，必须首先验证问题陈述的科学性和逻辑完整性。\n\n### 问题验证\n\n**第 1 步：提取已知条件**\n- 语言是标准的一阶算术语言，记作 $\\mathcal{L}_{\\mathrm{PA}}$。\n- $\\mathcal{L}_{\\mathrm{PA}}$ 的非逻辑符号是：常数符号 $0$、一元函数符号 $S$、二元函数符号 $+$ 和 $\\times$，以及等号 $=$。\n- 项是根据标准的递归规则由变量、常数和函数符号构成的。\n- 一个解释 $\\mathcal{M}$ 指定一个论域并为非逻辑符号提供指称。\n- 一个变量赋值 $s$ 将变量映射到解释论域中的元素。\n- 问题关注项的句法相等和语义相等之间的区别。\n- 指定了算术的标准模型：其论域是自然数集 $\\mathbb{N}$，其中 $0$ 被解释为数字零，$S$ 被解释为后继函数 $n \\mapsto n+1$，$+$ 和 $\\times$ 被解释为标准加法和乘法。\n- 问题要求选出同时提供以下三项内容的选项：\n    1. $\\mathcal{L}_{\\mathrm{PA}}$-项的句法相等的精确定义。\n    2. 两个项相对于一个解释和一个变量赋值的语义相等的精确定义。\n    3. 在标准模型 $\\mathbb{N}$ 中，两个不同的闭项指称同一个元素的正确例子。\n\n**第 2 步：使用提取的已知条件进行验证**\n- **科学依据：** 该问题牢固地植根于数理逻辑，特别是一阶算术的模型论。语言、项、解释、句法相等和语义相等的概念都是该领域标准的、定义明确的基本概念。\n- **良定的：** 问题是明确的。它要求识别出正确陈述三个不同、可验证事实的选项。预期在选项中存在唯一的正确答案。\n- **客观性：** 问题使用了形式逻辑中的精确技术语言，没有主观解释的余地。\n- **完整性和一致性：** 问题提供了关于语言 $\\mathcal{L}_{\\mathrm{PA}}$ 及其标准解释 $\\mathbb{N}$ 的所有必要背景信息，确保其自洽。没有内部矛盾。\n\n**第 3 步：结论与行动**\n问题陈述是**有效的**。这是一个数理逻辑中的标准且良定的问题。可以通过分析所提供选项中每个组成部分的正确性来推导出解答。\n\n### 解答推导\n\n为了正确评估这些选项，我们首先陈述所讨论概念的形式化定义。\n\n1.  **项的句法相等：** 在形式语言中，项是句法对象，即有限的符号序列。两个项 $t_1$ 和 $t_2$ 是句法相等（或恒等）的，通常写作 $t_1 \\equiv t_2$，当且仅当它们由完全相同的符号序列以相同的顺序组成。这纯粹是对作为字符串的项的结构性比较。这与在像 Peano 算术 (PA) 这样的理论中可证明相等（即 $PA \\vdash t_1 = t_2$）的概念是不同的。\n\n2.  **项的语义相等：** 语义学为句法对象赋予意义。给定一个 $\\mathcal{L}_{\\mathrm{PA}}$-解释 $\\mathcal{M}$，其论域为 $D_{\\mathcal{M}}$，以及一个变量赋值 $s: \\text{Variables} \\to D_{\\mathcal{M}}$，每个项 $t$ 都被赋予一个值，或称指称，$\\llbracket t \\rrbracket^{\\mathcal{M},s} \\in D_{\\mathcal{M}}$。这个赋值是根据项的结构递归定义的。两个项 $t_1$ 和 $t_2$ 相对于解释 $\\mathcal{M}$ 和赋值 $s$ 是语义相等的，当且仅当它们的指称是论域中的同一个元素，即 $\\llbracket t_1 \\rrbracket^{\\mathcal{M},s} = \\llbracket t_2 \\rrbracket^{\\mathcal{M},s}$。\n\n3.  **在标准模型 $\\mathcal{N}$ 中的例子：** 标准模型 $\\mathcal{N}$ 以自然数集 $\\mathbb{N} = \\{0, 1, 2, ...\\}$ 为其论域。对于闭项（不含变量的项），其指称独立于任何变量赋值。我们需要找到两个句法上不同的闭项 $t_1$ 和 $t_2$，使得 $\\llbracket t_1 \\rrbracket^{\\mathcal{N}} = \\llbracket t_2 \\rrbracket^{\\mathcal{N}}$。\n\n在确立了这些原则之后，我们分析每个选项。\n\n**A. 句法相等：两个项 $t_1$ 和 $t_2$ 是句法相等的，当且仅当它们是字面上相同的有限符号序列（逐个符号相同）。语义相等：对于一个解释 $\\mathcal{M}$ 和变量赋值 $s$，两个项 $t_1$ 和 $t_2$ 是语义相等的，当且仅当 $\\llbracket t_1 \\rrbracket^{\\mathcal{M},s} = \\llbracket t_2 \\rrbracket^{\\mathcal{M},s}$。在 $\\mathbb{N}$ 中的例子：项 $S(S(0))$ 和 $S(0) + S(0)$ 都指称 $2$。**\n- 句法相等的定义是正确的。它精确地捕捉了结构同一性的概念。\n- 语义相等的定义是正确的。这是标准的模型论定义。\n- 例子也是正确的。项 $S(S(0))$ 和 $S(0)+S(0)$ 是句法上不同的符号序列。在标准模型 $\\mathcal{N}$ 中，$\\llbracket S(S(0)) \\rrbracket^{\\mathcal{N}} = S^{\\mathcal{N}}(S^{\\mathcal{N}}(0)) = 1+1 = 2$，而 $\\llbracket S(0) + S(0) \\rrbracket^{\\mathcal{N}} = \\llbracket S(0) \\rrbracket^{\\mathcal{N}} +^{\\mathcal{N}} \\llbracket S(0) \\rrbracket^{\\mathcal{N}} = 1+1=2$。这两个不同的项指称同一个数。\n- **结论：** 正确。\n\n**B. 句法相等：两个项 $t_1$ 和 $t_2$ 是句法相等的，当且仅当 PA 证明公式 $t_1 = t_2$。语义相等：两个项是语义相等的，当且仅当公式 $t_1 = t_2$ 在 $\\mathcal{L}_{\\mathrm{PA}}$ 的每个解释中都为真。在 $\\mathbb{N}$ 中的例子：$S(0)$ 和 $0$ 指称同一个元素。**\n- 句法相等的定义是错误的。它描述的是 PA-可证明相等，这是一个比句法同一性严格更弱的关系。例如，$S(0)+S(0)$ 和 $S(S(0))$ 在 PA 中是可证明相等的，但它们在句法上不相等。\n- 语义相等的定义是错误的。它定义的是等式 $t_1 = t_2$ 的逻辑有效性（即 $\\models t_1 = t_2$），而不是相对于特定解释的语义相等。\n- 例子是错误的。在 $\\mathbb{N}$ 中，$\\llbracket S(0) \\rrbracket^{\\mathcal{N}} = 1$，而 $\\llbracket 0 \\rrbracket^{\\mathcal{N}} = 0$。由于 $1 \\neq 0$，它们不指称同一个元素。\n- **结论：** 错误。\n\n**C. 句法相等：如果两个项可以通过使用 PA 中关于 $+$ 和 $\\times$ 的公理（例如，结合律或交换律）重写它们使之变得相同，那么它们是句法相等的。语义相等：对于一个解释 $\\mathcal{M}$ 和赋值 $s$，如果 PA 证明 $t_1 = t_2$，则两个项是语义相等的。在 $\\mathbb{N}$ 中的例子：$0 + 0$ 和 $0$ 指称同一个元素。**\n- 句法相等的定义是错误的。这是对 PA-可证明相等的一种非形式化描述，而不是句法同一性。\n- 语义相等的定义是错误的。它错误地将模型 $\\mathcal{M}$ 中的真（一个语义概念）与 PA 中的可证明性（一个句法概念）等同起来。\n- 例子是正确的：$0+0$ 和 $0$ 在句法上是不同的，并且 $\\llbracket 0+0 \\rrbracket^{\\mathcal{N}} = \\llbracket 0 \\rrbracket^{\\mathcal{N}} = 0$。然而，错误的定义使该选项无效。\n- **结论：** 错误。\n\n**D. 句法相等：两个项是句法相等的，当且仅当它们是相同的符号序列。语义相等：对于一个解释 $\\mathcal{M}$ 和赋值 $s$，两个项是语义相等的，当且仅当它们的指称在 $\\mathcal{M}$ 和 $s$ 下重合。在 $\\mathbb{N}$ 中的例子：$S(0)$ 和 $S(0) + S(0)$ 指称同一个元素。**\n- 句法相等的定义是正确的。\n- 语义相等的定义是正确的。\n- 然而，例子是错误的。在 $\\mathbb{N}$ 中，$\\llbracket S(0) \\rrbracket^{\\mathcal{N}} = 1$，而 $\\llbracket S(0) + S(0) \\rrbracket^{\\mathcal{N}} = 1+1=2$。由于 $1 \\neq 2$，它们不指称同一个元素。\n- **结论：** 错误。\n\n**E. 句法相等：如果两个项在标准模型 $\\mathbb{N}$ 中指称同一个元素，那么它们是句法相等的。语义相等：两个项是语义相等的，当且仅当它们是字面上相同的字符串。在 $\\mathbb{N}$ 中的例子：$0 \\times S(0)$ 和 $0$ 指称同一个元素。**\n- 句法相等的定义是错误的；它将一个句法属性与一个特定模型中的语义属性相混淆。\n- 语义相等的定义是错误的；它将语义相等与句法相等相混淆。这两个定义基本上被互换并被错误地陈述了。\n- 例子是正确的：$0 \\times S(0)$ 和 $0$ 是不同的项，并且 $\\llbracket 0 \\times S(0) \\rrbracket^{\\mathcal{N}} = 0 \\times 1 = 0$，而 $\\llbracket 0 \\rrbracket^{\\mathcal{N}} = 0$。然而，这些定义存在根本性缺陷。\n- **结论：** 错误。\n\n只有选项 A 为句法相等和语义相等提供了正确的定义，并附带了一个正确的说明性例子。", "answer": "$$\\boxed{A}$$", "id": "3042049"}]}