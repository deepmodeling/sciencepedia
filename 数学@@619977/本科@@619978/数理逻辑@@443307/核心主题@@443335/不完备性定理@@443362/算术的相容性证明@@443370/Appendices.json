{"hands_on_practices": [{"introduction": "在证明算术的相容性之前，我们必须首先理解基本的算术事实是如何在皮亚诺算术（PA）这个形式系统内部被表达和推导的。这个练习将让你亲手实践 PA 中加法的基本递归公理，展示像 “$2+3=5$” 这样的简单陈述本身并非公理，而是从更基本的原则推导出的定理。通过这个过程，你将对“PA 中的一个证明”是什么样子建立起具体而坚实的理解。[@problem_id:3039646]", "problem": "在皮亚诺算术 (PA) 中，我们在一个一阶语言中工作，该语言包含常量符号 $0$、表示后继的一元函数符号 $S$ 以及二元函数符号 $+$ 和 $\\cdot$。数码是闭项 $\\bar{n}$，其定义为 $\\bar{0} := 0$ 和 $\\bar{n+1} := S(\\bar{n})$。后继公理规定，$S$ 是单射的且 $S(x) \\neq 0$ 等等，但对于本任务，您可以将注意力限制在使用 $+$ 和 $\\cdot$ 的定义方程来操作闭项。加法和乘法通过以下定义方程，在第二个参数上以原始递归的方式被公理化地给出\n$$\\forall x\\ (x + 0 = x), \\qquad \\forall x\\,\\forall y\\ (x + S(y) = S(x + y)),$$\n和\n$$\\forall x\\ (x \\cdot 0 = 0), \\qquad \\forall x\\,\\forall y\\ (x \\cdot S(y) = (x \\cdot y) + x).$$\n请解释在 PA 中，这些方程如何将 $+$ 和 $\\cdot$ 刻画为在第二个参数上进行原始递归的函数，即它们通过迭代使用方程和数码的定义，唯一地确定了所有数码的 $x+y$ 和 $x \\cdot y$ 的值。然后，仅使用这些关于 $+$ 的定义方程以及数码的定义，推导项 $\\bar{2} + \\bar{3}$ 的闭式形式，并将其完全化简为一个单一的数码。将您的最终答案写成结果数码 $\\bar{n}$ 的形式。无需四舍五入。", "solution": "问题要求解释在皮亚诺算术 (PA) 中，给定的加法 ($+$) 和乘法 ($\\cdot$) 的公理化定义如何将这些运算刻画为通过原始递归定义的函数，并要求对 $\\bar{2} + \\bar{3}$ 的值进行形式推导。\n\n首先，我们来讨论通过原始递归的刻画。一个具有 $k+1$ 个参数的函数 $f$ 的原始递归定义模式，是根据一个具有 $k$ 个参数的函数 $g$ 和一个具有 $k+2$ 个参数的函数 $h$ 定义的，如下所示：\n$$f(x_1, \\dots, x_k, 0) = g(x_1, \\dots, x_k)$$\n$$f(x_1, \\dots, x_k, S(y)) = h(x_1, \\dots, x_k, y, f(x_1, \\dots, x_k, y))$$\n该模式定义了函数 $f$ 在参数为 $0$ 时的值，并根据其在 $y$ 处的值来定义其在 $S(y)$ 处的值。由于每个自然数要么是 $0$，要么是另一个自然数的后继，因此这就在其最后一个参数上为所有自然数递归地定义了该函数。\n\n在此背景下，我们来考察所提供的加法和乘法的定义方程。变量 $x$ 和 $y$ 被理解为在该结构的定义域上取值，对于 PA 而言，该定义域是自然数。数码 $\\bar{n}$ 是 PA 语言中表示自然数的形式项。\n\n对于加法，我们将其运算表示为函数 $f_+(x, y) = x+y$。其定义方程为：\n1. $\\forall x\\ (x + 0 = x)$\n2. $\\forall x\\,\\forall y\\ (x + S(y) = S(x + y))$\n\n这符合 $k=1$（一个参数 $x$）的原始递归模式。\n基本情况是第二个参数为 $0$：\n$x+0 = x$。这匹配 $f_+(x, 0) = g(x)$ 的形式，其中 $g(x) = x$ 是恒等函数。\n递归步骤是第二个参数为后继 $S(y)$：\n$x+S(y) = S(x+y)$。这匹配 $f_+(x, S(y)) = h(x, y, f_+(x, y))$ 的形式。这里，$f_+(x, y)$ 是 $x+y$，而右侧是 $S(x+y)$。所以函数 $h$ 是 $h(x, y, z) = S(z)$，其中 $z = f_+(x, y)$。函数 $h$ 只是将后继函数应用于前一步递归的结果。由于恒等函数和后继函数是构建所有原始递归函数的基本函数，因此加法确实是通过原始递归定义的。\n\n对于乘法，我们将其运算表示为函数 $f_\\cdot(x, y) = x \\cdot y$。其定义方程为：\n1. $\\forall x\\ (x \\cdot 0 = 0)$\n2. $\\forall x\\,\\forall y\\ (x \\cdot S(y) = (x \\cdot y) + x)$\n\n这也符合 $k=1$ 的原始递归模式。\n基本情况是第二个参数为 $0$：\n$x \\cdot 0 = 0$。这匹配 $f_\\cdot(x, 0) = g(x)$ 的形式，其中 $g(x) = 0$ 是常数零函数。\n递归步骤是第二个参数为后继 $S(y)$：\n$x \\cdot S(y) = (x \\cdot y) + x$。这匹配 $f_\\cdot(x, S(y)) = h(x, y, f_\\cdot(x, y))$ 的形式。这里，$f_\\cdot(x, y)$ 是 $x \\cdot y$，而右侧是 $(x \\cdot y) + x$。所以函数 $h$ 是 $h(x, y, z) = z+x$，其中 $z = f_\\cdot(x, y)$。函数 $h$ 使用了加法运算，而我们已经证明加法运算是原始递归的。这是一个有效的构造，因此乘法也是通过原始递归定义的。\n\n这种递归结构确保了对于任意两个数码，例如 $\\bar{m}$ 和 $\\bar{n}$，项 $\\bar{m} + \\bar{n}$ 和 $\\bar{m} \\cdot \\bar{n}$ 是唯一确定的。求值过程通过重复应用递归规则进行，这会降低第二个参数中数码的复杂性。由于对于 $n > 0$ 的任何数码 $\\bar{n}$ 都可以写成 $S(S(...S(0)...))$（$n$ 次），因此递归在 $n$ 步之后，当第二个参数达到 $\\bar{0}$ 的基本情况时，保证会终止。\n\n现在，我们将仅使用数码的定义和加法的定义方程来推导项 $\\bar{2} + \\bar{3}$ 的闭式形式。\n\n首先，我们确立所涉及数码的定义：\n$\\bar{0} := 0$\n$\\bar{1} := S(\\bar{0})$\n$\\bar{2} := S(\\bar{1}) = S(S(\\bar{0}))$\n$\\bar{3} := S(\\bar{2}) = S(S(S(\\bar{0})))$\n$\\bar{4} := S(\\bar{3})$\n$\\bar{5} := S(\\bar{4})$\n\n推导过程如下：\n$$ \\bar{2} + \\bar{3} = \\bar{2} + S(\\bar{2}) \\quad (\\text{根据 } \\bar{3} \\text{ 的定义}) $$\n我们应用加法的第二条公理 $\\forall x\\,\\forall y\\ (x + S(y) = S(x + y))$，令 $x = \\bar{2}$ 且 $y = \\bar{2}$：\n$$ \\bar{2} + S(\\bar{2}) = S(\\bar{2} + \\bar{2}) $$\n现在我们必须计算内项 $\\bar{2} + \\bar{2}$：\n$$ \\bar{2} + \\bar{2} = \\bar{2} + S(\\bar{1}) \\quad (\\text{根据 } \\bar{2} \\text{ 的定义}) $$\n再次应用加法的第二条公理，令 $x = \\bar{2}$ 且 $y = \\bar{1}$：\n$$ \\bar{2} + S(\\bar{1}) = S(\\bar{2} + \\bar{1}) $$\n接下来，我们计算 $\\bar{2} + \\bar{1}$：\n$$ \\bar{2} + \\bar{1} = \\bar{2} + S(\\bar{0}) \\quad (\\text{根据 } \\bar{1} \\text{ 的定义}) $$\n应用加法的第二条公理，令 $x = \\bar{2}$ 且 $y = \\bar{0}$：\n$$ \\bar{2} + S(\\bar{0}) = S(\\bar{2} + \\bar{0}) $$\n最后，我们计算 $\\bar{2} + \\bar{0}$。为此，我们使用加法的第一条公理 $\\forall x\\ (x+0=x)$，令 $x = \\bar{2}$：\n$$ \\bar{2} + \\bar{0} = \\bar{2} $$\n现在我们将结果代回原始表达式：\n$$ \\bar{2} + \\bar{3} = S(\\bar{2} + \\bar{2}) = S(S(\\bar{2} + \\bar{1})) = S(S(S(\\bar{2} + \\bar{0}))) = S(S(S(\\bar{2}))) $$\n问题要求将此化简为 $\\bar{n}$ 形式的单个数字。我们使用数码的定义 $\\overline{k+1} = S(\\bar{k})$ 来化简表达式：\n$$ S(\\bar{2}) = \\bar{3} $$\n$$ S(S(\\bar{2})) = S(\\bar{3}) = \\bar{4} $$\n$$ S(S(S(\\bar{2}))) = S(\\bar{4}) = \\bar{5} $$\n因此，推导的结果是数码 $\\bar{5}$。\n$$ \\bar{2} + \\bar{3} = \\bar{5} $$", "answer": "$$\\boxed{\\bar{5}}$$", "id": "3039646"}, {"introduction": "根岑（Gentzen）的相容性证明依赖于一种衡量证明“复杂度”的方法，但这并非通过证明的长度等简单指标，而是通过超限序数。这个练习将带你进入序数算术这个奇特的新世界，它是理解相容性证明的关键。通过具体的计算，你将体会到它与我们所熟悉的自然数算术有何不同，并为理解为何需要序数奠定基础。[@problem_id:3039662]", "problem": "在 Gentzen 对皮亚诺算术（PA）的一致性证明中，归约是通过低于 $\\varepsilon_{0}$ 的序数来度量的，这使用了通过超限递归定义的序数算术。从序数的 von Neumann 定义和序数上的超限递归定理出发，完成以下任务：\n\n1. 通过为每个运算指定基底、后繼和极限子句来定义序数的加法、乘法和指数运算。您的定义必须以对第二个（右侧）参数的递归子句形式给出。\n\n2. 仅使用您的定义和 von Neumann 序数的基本性质（特别是，一个序数集合的上确界是它们的并集），计算并将以下表达式简化为标准序数表示法：\n   - $\\omega + 1$,\n   - $1 + \\omega$,\n   - $\\omega \\cdot 2$.\n\n将您的最终结果以单行向量的形式陈述，顺序为 $(\\omega+1,\\;1+\\omega,\\;\\omega\\cdot 2)$。最终答案必须是单个表达式。除了证明您的计算所必需的元定理外，不要证明任何其他元定理。无需四舍五入，也不涉及单位。", "solution": "该问题是有效的，因为它问题明確，科学上基于数理逻辑和集合论的原理，并包含严谨求解所需的所有必要信息。\n\n这个问题的基础是 von Neumann 序数定义，其中每个序数 $\\alpha$ 是所有比它小的序数的集合，即 $\\alpha = \\{\\beta \\mid \\beta  \\alpha\\}$。序数 $\\alpha$ 的后继是 $\\alpha+1 = \\alpha \\cup \\{\\alpha\\}$。一个非零且不是后继的序数是极限序数。第一个无限序数 $\\omega$ 是所有有限序数的集合，$\\omega = \\{0, 1, 2, \\dots\\}$。从此定义导出的一个关键性质是，对于任何序数集合 $S$，其上确界 $\\sup(S)$ 是它们的并集 $\\bigcup S$。\n\n**1. 序数运算的定义**\n\n序数的加法、乘法和指数运算通过对第二个（右侧）参数的超限递归来定义。设 $\\alpha$ 和 $\\beta$ 为序数。\n\n*序数加法 ($\\alpha + \\beta$):*\n1.  **基底情况 (${\\beta = 0}$):** $\\alpha + 0 = \\alpha$。\n2.  **后继情况 (${\\beta = \\gamma + 1}$):** $\\alpha + (\\gamma + 1) = (\\alpha + \\gamma) + 1$。\n3.  **极限情况 (${\\beta}$ 是极限序数):** $\\alpha + \\beta = \\sup\\{\\alpha + \\delta \\mid \\delta  \\beta\\}$。\n\n*序数乘法 ($\\alpha \\cdot \\beta$):*\n1.  **基底情况 (${\\beta = 0}$):** $\\alpha \\cdot 0 = 0$。\n2.  **后继情况 (${\\beta = \\gamma + 1}$):** $\\alpha \\cdot (\\gamma + 1) = (\\alpha \\cdot \\gamma) + \\alpha$。\n3.  **极限情况 (${\\beta}$ 是极限序数):** $\\alpha \\cdot \\beta = \\sup\\{\\alpha \\cdot \\delta \\mid \\delta  \\beta\\}$。\n\n*序数指数运算 ($\\alpha^\\beta$):*\n1.  **基底情况 (${\\beta = 0}$):** $\\alpha^0 = 1$。\n2.  **后继情况 (${\\beta = \\gamma + 1}$):** $\\alpha^{\\gamma+1} = \\alpha^\\gamma \\cdot \\alpha$。\n3.  **极限情况 (${\\beta}$ 是极限序数):** 对于 $\\alpha > 0$，$\\alpha^\\beta = \\sup\\{\\alpha^\\delta \\mid \\delta  \\beta\\}$。对于 $\\alpha = 0$，如果 $\\beta > 0$，则 $0^\\beta = 0$。\n\n**2. 表达式的计算与化简**\n\n我们现在仅使用这些定义和 von Neumann 序数的指定性质来计算给定的表达式。\n\n*${\\omega + 1}$ 的计算*\n该表达式涉及 $\\omega$ 与后继序数 $1$ 的加法。由于 $1$ 被定义为 $0$ 的后继，即 $1 = 0+1$，我们可以应用加法的后继子句，令 $\\alpha = \\omega$ 并使用 $1=\\gamma+1$（其中 $\\gamma=0$）：\n$$ \\omega + 1 = \\omega + (0 + 1) = (\\omega + 0) + 1 $$\n根据加法的基底子句，$\\alpha + 0 = \\alpha$，所以 $\\omega + 0 = \\omega$。将其代回可得：\n$$ (\\omega + 0) + 1 = \\omega + 1 $$\n表达式 $\\omega + 1$ 已经处于其标准的、简化的形式。它表示序数 $\\omega$ 的直接后继。\n\n*${1 + \\omega}$ 的计算*\n该表达式涉及极限序数 $\\omega$作为第二个参数。我们使用加法的极限子句，令 $\\alpha=1$ 且 $\\beta=\\omega$：\n$$ 1 + \\omega = \\sup\\{1 + \\delta \\mid \\delta  \\omega\\} $$\n满足 $\\delta  \\omega$ 的序数 $\\delta$ 是有限序数 $n \\in \\{0, 1, 2, \\dots\\}$。因此，上确界中的集合是 $\\{1+0, 1+1, 1+2, \\dots, 1+n, \\dots\\}$。对于有限序数，序数加法与标准算術一致，所以这个集合是 $\\{1, 2, 3, \\dots, n+1, \\dots\\}$。\n这个序数集合的上确界是大于或等于集合中每个元素的最小序数。使用上确界是并集这一性质：\n$$ \\sup\\{1, 2, 3, \\dots\\} = \\bigcup\\{\\{0\\}, \\{0,1\\}, \\{0,1,2\\}, \\dots\\} $$\n这些集合的并集是 $\\{0, 1, 2, \\dots\\}$，这就是 $\\omega$ 的定义。\n因此，化简后的结果是：\n$$ 1 + \\omega = \\omega $$\n\n*${\\omega \\cdot 2}$ 的计算*\n该表达式涉及与后继序数 $2$ 的乘法。我们将 $2$ 写为 $1+1$，并应用乘法的后繼子句，令 $\\alpha = \\omega$ 并使用 $2=\\gamma+1$（其中 $\\gamma=1$）：\n$$ \\omega \\cdot 2 = \\omega \\cdot (1+1) = (\\omega \\cdot 1) + \\omega $$\n为了计算这个表达式，我们必须先计算 $\\omega \\cdot 1$。我们再次使用后继子句，令 $1 = 0+1$，并设 $\\gamma=0$：\n$$ \\omega \\cdot 1 = \\omega \\cdot (0+1) = (\\omega \\cdot 0) + \\omega $$\n根据乘法的基底子句，$\\alpha \\cdot 0 = 0$，所以 $\\omega \\cdot 0 = 0$。这得到：\n$$ \\omega \\cdot 1 = 0 + \\omega $$\n现在我们计算 $0+\\omega$。由于 $\\omega$ 是一个极限序数，我们使用加法的极限子句：\n$$ 0 + \\omega = \\sup\\{0 + \\delta \\mid \\delta  \\omega\\} $$\n由于 $0$ 是序数加法的单位元，$0+\\delta = \\delta$ 对任何序数 $\\delta$ 都成立。因此：\n$$ 0 + \\omega = \\sup\\{\\delta \\mid \\delta  \\omega\\} = \\sup\\{0, 1, 2, \\dots\\} = \\omega $$\n将此代回，我们得到 $\\omega \\cdot 1 = \\omega$。\n最后，我们将其代入 $\\omega \\cdot 2$ 的表达式中：\n$$ \\omega \\cdot 2 = (\\omega \\cdot 1) + \\omega = \\omega + \\omega $$\n表达式 $\\omega + \\omega$ 表示序数，其序类型为两个 $\\omega$ 的副本一个接一个地排列。这正是标准记法 $\\omega \\cdot 2$所表示的。因此，计算证实了该等式，且简化后的表达式为 $\\omega \\cdot 2$。\n\n最终结果是 $(\\omega+1, \\omega, \\omega \\cdot 2)$。", "answer": "$$\n\\boxed{\n(\\omega+1, \\omega, \\omega \\cdot 2)\n}\n$$", "id": "3039662"}, {"introduction": "根岑证明的核心是一种被称为“切消定理”（Cut-Elimination Theorem）的程序，该程序可以系统地将任何证明转化为一种更简单的“无切”（cut-free）形式。这个练习将前两个概念联系起来：你将执行一次简单的切归约（cut-reduction），并使用序数来计算变换前后的证明“复杂度”。你将亲眼见证，这个归约步骤如何保证证明所对应的序数严格下降，而这正是整个相容性证明能够最终成功的关键。[@problem_id:3039618]", "problem": "考虑用于一阶算术的 Gentzen 式相容性证明中的切消框架，并在 Gentzen 的直觉主义矢列演算（LJ）中进行。使用以下基础数据。\n\n- 公式秩（逻辑复杂度）$\\rho(\\cdot)$ 通过对公式的递归定义：对于原子公式 $A$，$\\rho(A)=0$；对于像合取这样的二元联结词，$\\rho(A \\land B)=\\max\\{\\rho(A),\\rho(B)\\}+1$。\n- 序数取自 $\\epsilon_{0}$ 以下，使用序数加法和乘法写成康托尔范式。使用通常的序数定律：$\\omega^{0}=1$，序数加法和乘法是结合的，对于有限的 $m,n \\in \\mathbb{N}$，$m+n$ 是普通的整数加法，而 $\\omega \\cdot m$ 表示在右侧与有限的 $m$ 进行序数乘法。\n- 通过对最后一步推理的递归，为推导 $\\mathcal{D}$ 定义一个序数赋值 $o(\\mathcal{D})$：\n  1. 如果 $\\mathcal{D}$ 是一个初始公理 $A \\vdash A$，则 $o(\\mathcal{D})=1$。\n  2. 如果 $\\mathcal{D}$ 的最后一步推理是一个单前提非切规则（结构性或逻辑性），其直接子推导为 $\\mathcal{D}_{1}$，则 $o(\\mathcal{D})=o(\\mathcal{D}_{1})+1$。\n  3. 如果 $\\mathcal{D}$ 的最后一步推理是一个双前提非切规则（例如，$\\land$-右），其直接子推导为 $\\mathcal{D}_{1}$ 和 $\\mathcal{D}_{2}$，则 $o(\\mathcal{D})=\\max\\{o(\\mathcal{D}_{1}),o(\\mathcal{D}_{2})\\}+1$。\n  4. 如果 $\\mathcal{D}$ 的最后一步推理是在公式 $C$ 上的切，其直接子推导为 $\\mathcal{D}_{L}$ 和 $\\mathcal{D}_{R}$，则\n  $$o(\\mathcal{D}) \\;=\\; \\omega^{\\rho(C)} \\cdot \\bigl(o(\\mathcal{D}_{L}) + o(\\mathcal{D}_{R})\\bigr) + 1.$$\n\n构建以下具体的推导 $\\mathcal{D}$，它在公式 $P \\land Q$ 上使用单个切，其中 $P$ 和 $Q$ 是原子公式：\n\n- 左前提 $\\mathcal{D}_{L}$ 通过首先从初始公理 $P \\vdash P$ 和 $Q \\vdash Q$ 使用左弱化推导出 $P,Q \\vdash P$ 和 $P,Q \\vdash Q$，然后应用 $\\land$-右规则，来推导出 $P,Q \\vdash P \\land Q$。\n- 右前提 $\\mathcal{D}_{R}$ 通过对初始公理 $P \\vdash P$ 应用 $\\land$-左$_1$ 规则，来推导出 $P \\land Q \\vdash P$。\n- 通过在 $P \\land Q$ 上对 $\\mathcal{D}_{L}$ 和 $\\mathcal{D}_{R}$ 进行切来推断 $P,Q \\vdash P$。\n\n然后，当右前提以 $\\land$-左$_1$ 结束时，对 LJ 中合取上的切执行单个标准的切归约步骤：将切推到 $\\land$-左$_1$ 下方，用在 $P$ 上的切替换在 $P \\land Q$ 上的切，使用 $\\mathcal{D}_{L}$ 的相应左子推导，该子推导推导出 $P,Q \\vdash P$。\n\n使用上面的序数赋值，明确计算：\n- 归约前的序数测度 $o(\\mathcal{D})$（即，在 $P \\land Q$ 上的单切推导）。\n- 单个切归约步骤后的序数测度 $o(\\mathcal{D}')$（即，得到的在 $P$ 上有单个切的推导）。\n\n以康托尔范式给出两个测度。您的最终答案必须是这两个序数表达式的有序对，写成一个行矩阵。无需舍入。", "solution": "该问题已被验证为数理逻辑（证明论）领域内一个良定、自洽且有科学依据的问题。所有必要的定义和条件都已提供，任务是将这些定义直接应用于一个具体例子。因此，我们将着手进行解答。\n\n问题要求计算两个序数测度 $o(\\mathcal{D})$ 和 $o(\\mathcal{D}')$，它们分别对应于逻辑推导在切归约步骤之前和之后的情况。框架是 Gentzen 的直觉主义矢列演算 LJ。\n\n首先，我们计算初始推导的序数 $o(\\mathcal{D})$。推导 $\\mathcal{D}$ 通过在公式 $P \\land Q$ 上的切来推断 $P,Q \\vdash P$。其结构是：\n$$\n\\mathcal{D} = \\frac{\n  \\mathcal{D}_{L}: P,Q \\vdash P \\land Q\n  \\quad\n  \\mathcal{D}_{R}: P \\land Q \\vdash P\n}{P,Q \\vdash P} (\\text{在 } P \\land Q \\text{ 上的切})\n$$\n我们必须计算子推导 $\\mathcal{D}_L$ 和 $\\mathcal{D}_R$ 的序数。\n\n左前提 $\\mathcal{D}_L$ 使用 $\\land$-右规则作用于两个子推导（我们称之为 $\\mathcal{D}_{LP}$ 和 $\\mathcal{D}_{LQ}$）来推导出 $P,Q \\vdash P \\land Q$：\n$$\n\\mathcal{D}_L = \\frac{\n  \\mathcal{D}_{LP}: P,Q \\vdash P\n  \\quad\n  \\mathcal{D}_{LQ}: P,Q \\vdash Q\n}{P,Q \\vdash P \\land Q} (\\land\\text{-R})\n$$\n- $\\mathcal{D}_{LP}$ 是通过对公理 $P \\vdash P$ 应用左弱化形成的。设 $\\mathcal{A}_P$ 是 $P \\vdash P$ 的公理推导。根据所给规则，$o(\\mathcal{A}_P) = 1$。弱化是单前提非切规则，因此根据规则2，$o(\\mathcal{D}_{LP}) = o(\\mathcal{A}_P) + 1 = 1 + 1 = 2$。\n- 类似地，$\\mathcal{D}_{LQ}$ 是通过对公理 $Q \\vdash Q$ 应用左弱化形成的。设 $\\mathcal{A}_Q$ 是 $Q \\vdash Q$ 的公理推导，所以 $o(\\mathcal{A}_Q) = 1$。则 $o(\\mathcal{D}_{LQ}) = o(\\mathcal{A}_Q) + 1 = 1 + 1 = 2$。\n$\\land$-右规则是双前提非切规则。根据规则3，$\\mathcal{D}_L$ 的序数是：\n$$o(\\mathcal{D}_L) = \\max\\{o(\\mathcal{D}_{LP}), o(\\mathcal{D}_{LQ})\\} + 1 = \\max\\{2, 2\\} + 1 = 2 + 1 = 3$$\n\n右前提 $\\mathcal{D}_R$ 通过对公理 $P \\vdash P$ 应用 $\\land$-左$_1$ 规则来推导出 $P \\land Q \\vdash P$。这是一个单前提非切规则。根据规则2：\n$$o(\\mathcal{D}_R) = o(\\mathcal{A}_P) + 1 = 1 + 1 = 2$$\n\n现在我们计算完整推导 $\\mathcal{D}$ 的序数，它使用了切规则。我们首先需要切公式 $C = P \\land Q$ 的秩。由于 $P$ 和 $Q$ 是原子的，$\\rho(P) = 0$ 且 $\\rho(Q) = 0$。秩定义为 $\\rho(P \\land Q) = \\max\\{\\rho(P), \\rho(Q)\\} + 1 = \\max\\{0, 0\\} + 1 = 1$。\n使用规则4计算切：\n$$o(\\mathcal{D}) = \\omega^{\\rho(P \\land Q)} \\cdot \\bigl(o(\\mathcal{D}_{L}) + o(\\mathcal{D}_{R})\\bigr) + 1$$\n代入计算出的值：\n$$o(\\mathcal{D}) = \\omega^{1} \\cdot (3 + 2) + 1$$\n对于有限序数，加法是标准的。所以，$3 + 2 = 5$。\n$$o(\\mathcal{D}) = \\omega \\cdot 5 + 1$$\n这个表达式是康托尔范式。\n\n接下来，我们分析归约后的推导 $\\mathcal{D}'$。当右前提是 $\\land$-左$_1$ 规则的结论时，对合取上的切的切归约步骤将用一个新的、更简单的切替换在 $P \\land Q$ 上的切。原始推导是：\n$$ \\frac{ \\frac{P,Q \\vdash P \\quad P,Q \\vdash Q}{P,Q \\vdash P \\land Q} (\\land\\text{-R}) \\qquad \\frac{P \\vdash P}{P \\land Q \\vdash P} (\\land\\text{-L}_1) }{P,Q \\vdash P} (\\text{在 } P \\land Q \\text{ 上的切}) $$\n归约将其替换为一个推导 $\\mathcal{D}'$，它将原始 $\\land$-右规则的左前提（$\\mathcal{D}_{LP}: P,Q \\vdash P$）与原始 $\\land$-左$_1$ 规则的前提（$\\mathcal{A}_P: P \\vdash P$）进行切。新的切作用于一个更简单的公式 $P$。\n归约后的推导 $\\mathcal{D}'$ 是：\n$$\n\\mathcal{D}' = \\frac{ \\mathcal{D}_{LP}: P,Q \\vdash P \\qquad \\mathcal{A}_P: P \\vdash P }{P,Q \\vdash P} (\\text{在 } P \\text{ 上的切})\n$$\n我们使用规则4计算序数 $o(\\mathcal{D}')$。\n- 新的切公式是 $P$。其秩为 $\\rho(P) = 0$。\n- 新切的左前提是 $\\mathcal{D}_{LP}$，我们已经求得 $o(\\mathcal{D}_{LP}) = 2$。\n- 新切的右前提是公理 $\\mathcal{A}_P$，其 $o(\\mathcal{A}_P) = 1$。\n应用序数的切规则：\n$$o(\\mathcal{D}') = \\omega^{\\rho(P)} \\cdot \\bigl(o(\\mathcal{D}_{LP}) + o(\\mathcal{A}_P)\\bigr) + 1 = \\omega^{0} \\cdot (2 + 1) + 1$$\n使用序数定律 $\\omega^0 = 1$：\n$$o(\\mathcal{D}') = 1 \\cdot (3) + 1 = 3 + 1 = 4$$\n数字 $4$ 是一个有限序数，并且是康托尔范式。\n\n计算出的序数对是 $(o(\\mathcal{D}), o(\\mathcal{D}')) = (\\omega \\cdot 5 + 1, 4)$。正如预期的那样，在归约步骤之后，序数测度严格减小，因为 $\\omega \\cdot 5 + 1 > 4$。", "answer": "$$\\boxed{(\\omega \\cdot 5 + 1, 4)}$$", "id": "3039618"}]}