{"hands_on_practices": [{"introduction": "要实现语法的算术化，第一步便是将基本的句法属性翻译成算术语言。一个变量在公式中是“绑定的”还是“自由的”，这是一个基础但至关重要的区分。本练习将引导你具体实践如何利用原始递归谓词来捕捉“变量被绑定”这一属性 [@problem_id:3043163]，从而直观地展示算术化如何将公式的结构性分析转化为数字计算。", "problem": "在一个固定的、带有变量 $v_0, v_1, v_2, \\dots$ 的一阶语言中，假设我们有一个标准的哥德尔编码，它为每个合式公式分配一个自然数编码 $x$。已编码公式的语法分析树中的位置由子索引的有限序列表示，该序列通过素数幂方案编码：序列 $\\langle a_0, a_1, \\dots, a_{n-1} \\rangle$ 被编码为 $\\prod_{k  n} p_k^{a_k + 1}$，其中 $p_k$ 是第 $k$ 个素数。对于此类编码，一个标准的事实是，基本序列操作（长度、索引处元素、连接、前缀）以及检查给定地址的节点是否为特定符号（例如，变量 $v_i$ 或量词 $(\\forall v_i)$ 或 $(\\exists v_i)$）的句法谓词都是原始递归的。\n\n假设在语法分析树中，一个量词节点 $(Q v_i)$（其中 $Q \\in \\{\\forall, \\exists\\}$）由数对 $\\langle Q, i \\rangle$ 标记，并且只有一个子节点，该子节点是其作用域的根。变量节点的标签是数对 $\\langle \\mathrm{var}, i \\rangle$。设 $\\mathrm{IsVar}(x,p,i)$ 是一个原始递归谓词，它当且仅当由 $x$ 编码的公式的语法分析树中地址为 $p$ 的节点被标记为 $\\langle \\mathrm{var}, i \\rangle$ 时成立。设 $\\mathrm{IsQuant}(x,q,i)$ 是一个原始递归谓词，它当且仅当地址为 $q$ 的节点被标记为 $\\langle Q, i \\rangle$（对于某个 $Q \\in \\{\\forall, \\exists\\}$）时成立。设 $\\mathrm{Prefix}(q,p)$ 是一个原始递归谓词，它当且仅当地址 $q$ 是地址 $p$ 的前缀时成立（因此地址 $q$ 处的节点是地址 $p$ 处的节点的祖先）。\n\n我们想要一个原始递归谓词 $\\mathrm{BoundAt}(x,i,p)$，其意图是当且仅当由 $x$ 编码的公式的语法分析树中地址为 $p$ 处的 $v_i$ 的出现是约束的（在一阶逻辑的通常意义下）时成立，即从该节点到根的唯一路径上出现了一个量词 $(\\forall v_i)$ 或 $(\\exists v_i)$，其作用域包含该出现。\n\n以下哪一个是使用语法分析树中的路径对 $\\mathrm{BoundAt}(x,i,p)$ 的正确原始递归规范？\n\nA. 定义 $\\mathrm{BoundAt}(x,i,p)$ 成立，当且仅当 $\\mathrm{IsVar}(x,p,i)$ 且存在 $q \\le p$ 使得 $\\mathrm{Prefix}(q,p)$ 和 $\\mathrm{IsQuant}(x,q,i)$。\n\nB. 定义 $\\mathrm{BoundAt}(x,i,p)$ 成立，当且仅当 $\\mathrm{IsVar}(x,p,i)$ 且 $p$ 的父节点（即唯一的 $q$ 满足 $\\mathrm{Prefix}(q,p)$ 和 $\\mathrm{len}(q) = \\mathrm{len}(p) - 1$）满足 $\\mathrm{IsQuant}(x,q,i)$。\n\nC. 定义 $\\mathrm{BoundAt}(x,i,p)$ 成立，当且仅当 $\\mathrm{IsVar}(x,p,i)$ 且对于所有 $q \\preceq p$ （即所有满足 $\\mathrm{Prefix}(q,p)$ 的 $q$），我们有 $\\lnot \\mathrm{IsQuant}(x,q,i)$。\n\nD. 定义 $\\mathrm{BoundAt}(x,i,p)$ 成立，当且仅当 $\\mathrm{IsVar}(x,p,i)$ 且存在 $q \\preceq p$ 使得 $\\mathrm{IsQuant}(x,q,j)$ 对于某个 $j$（可能 $j \\ne i$）成立。\n\n此处，$\\le$ 是 $\\mathbb{N}$ 上的通常顺序，$\\preceq$ 是 $\\mathrm{Prefix}$ 关系的缩写。假设所有提到的辅助概念都通过所选的哥德尔编码和序列编码以通常的原始递归方式进行编码。", "solution": "我们从原始递归函数和谓词的基本定义开始：它们由零函数、后继函数和投影函数通过复合和原始递归生成，并且在界限项是原始递归的情况下，对于有界搜索（有界存在量化和全称量化）是封闭的。在语法的算术化中，这是一个标准结果：对于一阶公式的固定哥德尔编码和有限序列的固定编码，以下各项是原始递归的：合式公式的编码集合、序列编码 $p$ 是编码为 $x$ 的公式的语法分析树中的有效地址这一关系、检索节点标签的函数，以及谓词 $\\mathrm{IsVar}(x,p,i)$ 和 $\\mathrm{IsQuant}(x,q,i)$。此外，对于素数幂序列编码，诸如长度、前缀和元素访问之类的序列操作是原始递归的。因此，对此类关系的合取和有界量化仍属于原始递归类的范畴。\n\n$\\mathrm{BoundAt}(x,i,p)$ 的预期含义是：地址为 $p$ 的节点是变量 $v_i$，并且从该节点到根的路径上某处出现了一个约束 $v_i$ 的量词。在我们的树模型中，量词节点 $(Q v_i)$（其中 $Q \\in \\{\\forall, \\exists\\}$）只有一个子节点，该子节点是其作用域的根。因此，当且仅当 $q$ 是 $p$ 的前缀时，地址 $p$ 处的 $v_i$ 的出现才在地址 $q$ 处的量词 $(Q v_i)$ 的作用域内。因此，自然的公式化是：\n$$\n\\mathrm{BoundAt}(x,i,p) \\;\\equiv\\; \\mathrm{IsVar}(x,p,i) \\,\\wedge\\, \\exists q \\text{ with } \\mathrm{Prefix}(q,p) \\text{ and } \\mathrm{IsQuant}(x,q,i).\n$$\n为了确保原始递归性，我们将存在量词表示为有界的。一个简单的界限是数值不等式 $q \\le p$，这是充分的，因为在素数幂方案中， $p$ 的任何前缀的编码 $q$ 都是 $p$ 的一个因子，因此满足 $q \\le p$；扫描所有 $q \\le p$ 并测试 $\\mathrm{Prefix}(q,p)$ 是对一个原始递归谓词的有界搜索。或者，可以通过 $p$ 的长度来设定界限，将 $q$ 视为长度至多为 $\\mathrm{len}(p)$ 的某个前缀的编码；这两种界限都是原始递归的。关键点是，对所有祖先的搜索是有限的并且是原始递归的，因为 $p$ 的前缀数量最多为 $\\mathrm{len}(p) + 1$。\n\n我们现在评估每个选项。\n\n选项 A：$\\mathrm{BoundAt}(x,i,p)$ 成立，当且仅当 $\\mathrm{IsVar}(x,p,i)$ 且存在 $q \\le p$ 使得 $\\mathrm{Prefix}(q,p)$ 和 $\\mathrm{IsQuant}(x,q,i)$。这恰好捕捉了预期的条件：$p$ 处的变量是 $v_i$，并且存在某个祖先 $q$ 被一个关于 $v_i$ 的量词标记。存在量化受 $q \\le p$ 限制，内部测试 $\\mathrm{Prefix}(q,p) \\wedge \\mathrm{IsQuant}(x,q,i)$ 是原始递归的。因此，这个定义在意义上是正确的，并且是原始递归的。结论：正确。\n\n选项 B：$\\mathrm{BoundAt}(x,i,p)$ 成立，当且仅当 $p$ 的父节点是一个关于 $v_i$ 的量词。这个条件过于严格。通常，一个 $v_i$ 的约束出现不必紧邻在一个量词节点之下；它可以嵌套在量词作用域内的联结词或函数符号下。例如，在公式 $(\\forall v_i)\\,(R(f(v_i)) \\wedge S)$ 中， $f(v_i)$ 内部的 $v_i$ 的出现被位于该变量出现位置的父节点之上的某个祖先地址 $q$ 处的量词所约束。选项 B 在这种情况下会错误地返回假。结论：不正确。\n\n选项 C：$\\mathrm{BoundAt}(x,i,p)$ 成立，当且仅当 $p$ 处的节点是 $v_i$ 并且没有关于 $v_i$ 的祖先量词。这与通常的定义相矛盾：它断言的是与被约束完全相反的情况。缺少这样的量词表征的是 $v_i$ 的自由出现，而不是约束出现。结论：不正确。\n\n选项 D：$\\mathrm{BoundAt}(x,i,p)$ 成立，当且仅当 $p$ 处的节点是 $v_i$ 并且存在一个关于某个变量 $v_j$（可能 $j \\ne i$）的祖先量词。这个条件太弱了：它会将任何碰巧位于某个量词作用域内的 $v_i$ 的出现都归类为约束的，即使该量词是关于一个不同变量的。例如，在 $(\\forall v_7)\\,P(v_3)$ 中，$v_3$ 的出现是自由的，但存在一个关于 $v_7$ 的祖先量词，所以选项D会错误地返回真。结论：不正确。\n\n因此，这些选项中唯一正确的规范是选项 A。它使用语法分析树中的一条路径来检查是否存在一个约束相同变量索引的祖先量词，并且由于有界搜索下的封闭性和句法及序列编码谓词的原始递归性，得到的谓词是原始递归的。", "answer": "$$\\boxed{A}$$", "id": "3043163"}, {"introduction": "在掌握了如何表示静态属性后，我们进入一个更复杂的挑战：算术化地表示对公式的动态操作。代入是其中最重要也最精巧的操作，其难点在于必须避免“变元捕获”这一常见陷阱。本练习深入探讨了如何构建一个“避免捕获的”代入函数 [@problem_id:3043154]，包括重命名绑定变元（即 α-变换）的关键技术，并论证了为何这个保留了逻辑正确性的复杂操作依然是原始递归的。", "problem": "考虑一个固定的一阶逻辑（FOL）语言，其变量为 $v_0, v_1, v_2, \\dots$，并有一个固定的哥德尔编码，该编码为该语言字母表上的每个有限字符串分配一个自然数，使得用于位置、长度和符号识别的解码函数都是原始递归的。假设基于算术基本定理（FTA）对有限序列进行标准的素数幂编码，并且谓词“$x$ 编码一个项”、“$x$ 编码一个公式”以及“$x$ 含有变量 $v_i$ 的约束出现”都可以通过原始递归的方式判定。设 $\\mathrm{Free}(x,i)$ 是一个原始递归谓词，表示由 $x$ 编码的公式含有 $v_i$ 的自由出现，并设 $\\mathrm{Vars}(y)$ 表示在由 $y$ 编码的项中出现的变量索引的有限集合；两者都是通过使用固定的哥德尔编码对语法进行算术化得到的。我们的目标是构造避免捕获的替换函数 $\\mathrm{Sub}(x,i,y)$，该函数输出一个哥德爾编码，该编码对应于从由 $x$ 编码的公式通过将由 $y$ 编码的项替换变量 $v_i$ 而得到的公式，同时避免变量捕获。\n\n从这些基本假设和定义出发，分析避免捕获的替换的算术化过程，以及为了防止变量捕获而重命名约束变量的必要性。特别地，考虑 $\\mathrm{Sub}(x,i,y)$ 必须如何处理量词和约束构造以保留被替换项的自由变量。仅基于第一性原理，选择下面所有正确的陈述。\n\nA. 如果 $y$ 编码一个变量 $v_j$，并且由 $x$ 编码的公式包含一个量词，该量词在 $v_i$ 将被替换的作用域内约束了 $v_j$，那么朴素的替换可能会将 $y$ 中的 $v_j$ 的自由出现变为结果中的约束出现。因此，避免捕获的 $\\mathrm{Sub}(x,i,y)$ 必须检测此类冲突，并在替换前对 $x$ 中的约束变量进行系统的重命名（α-变换）为新变量。\n\nB. 函数 $\\mathrm{Sub}(x,i,y)$ 可以通过对代码 $x$ 的句法结构进行递归来定义为一个原始递归函数，前提是使用一个原始递归的“新变量”选择器，例如 $1+\\max(\\mathrm{Vars}(x)\\cup \\mathrm{Vars}(y))$，来处理量词下的重命名。这种算术化不需要借助选择公理（AC）。\n\nC. 如果 $y$ 编码的项，其所有变量都与在由 $x$ 编码的公式中任何地方出现的每个约束变量都不同，那么将 $y$ 朴素地替换 $x$ 中的 $v_i$ 不会导致变量捕获。\n\nD. 可以通过保留无限多个变量符号，并规定 $y$ 永远不使用任何在 $x$ 中约束出现的变量符号，从而完全避免处理约束变量重命名的需要，因此 $\\mathrm{Sub}(x,i,y)$ 无需检查约束变量冲突。\n\n选择所有适用的选项。", "solution": "问题要求分析一阶逻辑中避免捕获的替换函数（记为 $\\mathrm{Sub}(x,i,y)$）的算术化。该函数接受公式 $\\phi$ 的哥德尔数 $x$、变量 $v_i$ 的索引 $i$ 以及项 $t$ 的哥德尔数 $y$，并应返回公式 $\\phi[t/v_i]$ 的哥德尔数，其中 $\\phi$ 中 $v_i$ 的所有自由出现都被 $t$ 替换，并且 $t$ 中的自由变量在此过程中没有变成约束变量。\n\n令 $\\phi_x$ 表示哥德尔数为 $x$ 的公式， $v_i$ 表示索引为 $i$ 的变量， $t_y$ 表示哥德尔数为 $y$ 的项。该操作是在 $\\phi_x$ 中用 $t_y$ 替换 $v_i$。\n\n核心问题是“变量捕获”。如果一个变量 $v_j$ 在 $t_y$ 中是自由的，并且替换操作将 $t_y$ 置于一个约束 $v_j$ 的量词（即 $\\forall v_j$ 或 $\\exists v_j$）的作用域内，那么这个变量 $v_j$ 就被捕获了。\n例如，考虑公式 $\\phi_x \\equiv \\exists v_j (v_i = v_j)$ 和项 $t_y \\equiv v_j$。$t_y$ 中的自由变量集合是 $\\{v_j\\}$。如果我们朴素地用 $t_y$ 替换 $\\phi_x$ 中的 $v_i$，我们会得到公式 $\\exists v_j (v_j = v_j)$。在原公式 $\\phi_x$ 中，变量 $v_i$ 是自由的。替换了包含自由变量 $v_j$ 的项 $t_y$ 后，公式的含义发生了巨大变化，因为来自 $t_y$ 的自由变量 $v_j$ 被量词 $\\exists v_j$ “捕获”了。\n\n一个正确的避免捕获的替换过程必须防止这种情况。标准方法是重命名量词中的约束变量。在该示例中，我们会首先将 $\\phi_x$ 中的约束变量 $v_j$ 重命名为一个新变量，比如 $v_k$，其中 $v_k$ 不出现在 $\\phi_x$ 中，也不出现在 $t_y$ 中。公式 $\\phi_x$ 逻辑上等价于 $\\phi'_{x} \\equiv \\exists v_k (v_i = v_k)$。现在，在 $\\phi'_{x}$ 中用 $t_y$ 替换 $v_i$ 会得到 $\\exists v_k (v_j = v_k)$，这正确地保留了逻辑结构。来自项的自由变量 $v_j$ 在结果公式中仍然是自由的。\n\n问题陈述了，对于哥德尔数上的基本句法操作，如解析、识别项和公式（$\\mathrm{Free}(x,i)$、$\\mathrm{Vars}(y)$ 等），都有原始递归函数和谓词可用。我们必须在这些假设的基础上分析完全的避免捕获的替换函数 $\\mathrm{Sub}(x,i,y)$ 的性质。\n\n**逐项分析**\n\n**A. 如果 $y$ 编码一个变量 $v_j$，并且由 $x$ 编码的公式包含一个量词，该量词在 $v_i$ 将被替换的作用域内约束了 $v_j$，那么朴素的替换可能会将 $y$ 中的 $v_j$ 的自由出现变为结果中的约束出现。因此，避免捕获的 $\\mathrm{Sub}(x,i,y)$ 必须检测此类冲突，并在替换前对 $x$ 中的约束变量进行系统的重命名（α-变换）为新变量。**\n\n该陈述准确地描述了变量捕获的典型场景。令 $\\phi_x$ 为由 $x$ 编码的公式，假设其结构为 $\\dots \\forall v_j (\\dots v_i \\dots) \\dots$。要替换的项（由 $y$ 编码）是变量 $v_j$。替换的对象是 $v_i$。朴素的替换将导致 $\\dots \\forall v_j (\\dots v_j \\dots) \\dots$。被替换进来的 $v_j$（它本身是自由的，因为它是被替换的整个项）被量词 $\\forall v_j$ 约束了。这正是变量捕获的含义。所描述的补救措施，即检测此类冲突并执行约束变量的重命名（一个称为α-变换或α-等价的过程），是正确实现避免捕获的替换的标准且必要的过程。函数 $\\mathrm{Sub}(x,i,y)$ 必须实现这一逻辑。\n\n**结论：**正确。\n\n**B. 函数 $\\mathrm{Sub}(x,i,y)$ 可以通过对代码 $x$ 的句法结构进行递归来定义为一个原始递归函数，前提是使用一个原始递归的“新变量”选择器，例如 $1+\\max(\\mathrm{Vars}(x)\\cup \\mathrm{Vars}(y))$，来处理量词下的重命名。这种算术化不需要借助选择公理（AC）。**\n\n这个陈述提出了两个主张：$\\mathrm{Sub}(x,i,y)$ 是原始递归的，并且其构造是构造性的（不需要选择公理 AC）。\n1.  **原始递归性：** 函数 $\\mathrm{Sub}(x,i,y)$ 是通过对公式 $\\phi_x$ 的结构进行递归来定义的。这对应于对哥德尔数 $x$ 的值程递归。\n    *   基础情况（原子公式）：替换是简单的替换，在算术上是对哥德尔数的原始递归操作。\n    *   递归步骤（连接词）：对于 $\\phi_x = \\neg \\psi_z$ 或 $\\phi_x = \\psi_{z_1} \\land \\psi_{z_2}$，结果由递归调用的结果构建，例如 $\\mathrm{Sub}(z_1, i, y)$ 和 $\\mathrm{Sub}(z_2, i, y)$。这些组合是原始递归的。\n    *   递归步骤（量词）：对于 $\\phi_x = \\forall v_k \\psi_z$。\n        *   如果 $i=k$，则 $v_i$ 是约束变量，因此在该量词的作用域内没有可被替换的自由出现。公式不变。\n        *   如果 $i \\neq k$，我们必须检查是否存在冲突。如果 $v_k$ 是项 $t_y$ 中的一个自由变量，则发生冲突。这个检查是 $\\exists j \\in \\mathrm{Vars}(y) \\text{ such that } j=k$，在给定假设下这是原始递归的。\n        *   如果没有冲突，结果是 $\\forall v_k (\\text{result of } \\mathrm{Sub}(z, i, y))$。这是一个原始递归的构造。\n        *   如果存在冲突，我们必须重命名 $v_k$。我们需要一个“新”的变量索引 $m$。所提出的选择器 $m = 1+\\max(\\mathrm{Vars}(x)\\cup \\mathrm{Vars}(y))$ 提供了这样一个索引。$\\mathrm{Vars}(x)$ 和 $\\mathrm{Vars}(y)$ 是索引的有限集合，因此它们的并集是有限的，最大值和后继运算都是原始递归的。找到这个 $m$ 是一个原始递归过程。然后，我们执行两次替换：首先，在 $\\psi_z$ 中将 $v_k$ 重命名为 $v_m$ 以得到 $\\psi'_{z'}$（这是对 $\\mathrm{Sub}(z, k, \\text{code of } v_m)$ 的递归调用），然后在 $\\psi'_{z'}$ 中用 $t_y$ 替换 $v_i$。\n    由于所有操作（情况分析、检查冲突、选择新变量和组合哥德尔数）都是原始递归的，并且递归是在公式的结构（一个良基序）上进行的，因此整个函数 $\\mathrm{Sub}(x,i,y)$ 确实是原始递归的。\n2.  **选择公理：** 当必须做出无限次无法给出规则的任意选择时，才需要AC。在这里，新变量的选择是完全构造性的和确定性的。规则 $m = 1+\\max(\\mathrm{Vars}(x)\\cup \\mathrm{Vars}(y))$ 提供了一个具体的、可计算的索引 $m$。没有做出“任意选择”。因此，不需要选择公理。\n\n该陈述中的两个主张都是正确的。\n\n**结论：**正确。\n\n**C. 如果 $y$ 编码的项，其所有变量都与在由 $x$ 编码的公式中任何地方出现的每个约束变量都不同，那么将 $y$ 朴素地替换 $x$ 中的 $v_i$ 不会导致变量捕获。**\n\n设 $t_y$ 为由 $y$ 编码的项，$\\phi_x$ 为由 $x$ 编码的公式。设 $\\mathrm{FreeVars}(t_y)$ 为 $t_y$ 中自由变量的索引集合，$\\mathrm{BoundVars}(\\phi_x)$ 为在 $\\phi_x$ 中任何地方被约束的变量的索引集合。给定的条件是 $\\mathrm{FreeVars}(t_y) \\cap \\mathrm{BoundVars}(\\phi_x) = \\emptyset$。\n当我们用 $t_y$ 替换一个在某个量词（比如 $\\forall v_k$）作用域内的 $v_i$ 的自由出现，并且 $v_k \\in \\mathrm{FreeVars}(t_y)$ 时，就会发生变量捕获。根据定义，变量 $v_k$ 是 $\\phi_x$ 中的一个约束变量，所以 $k \\in \\mathrm{BoundVars}(\\phi_x)$。前提明确指出，对于任何这样的 $k$，$k \\notin \\mathrm{FreeVars}(t_y)$。因此，变量捕获的条件永远不会满足。一个朴素的替换，即直接将所有 $v_i$ 的自由出现替换为 $t_y$ 而不进行任何检查或重命名，在这个强假设下是安全的。\n\n**结论：**正确。\n\n**D. 可以通过保留无限多个变量符号，并规定 $y$ 永远不使用任何在 $x$ 中约束出现的变量符号，从而完全避免处理约束变量重命名的需要，因此 $\\mathrm{Sub}(x,i,y)$ 无需检查约束变量冲突。**\n\n该陈述提出了一种约定来回避变量捕获的问题。该约定是，对于任何替换操作 $\\mathrm{Sub}(x,i,y)$，输入都必须满足条件 $\\mathrm{FreeVars}(t_y) \\cap \\mathrm{BoundVars}(\\phi_x) = \\emptyset$。虽然遵循这个约定确实会使朴素替换变得安全（如在选项 C 中所确立的），但这并不能“完全避免”在一个通用替换函数中处理重命名的需要。\n一个形式系统通常需要不满足此条件的替换。例如，在证明中，可能需要用一个项 $t$ 来例示一个全称量化公式 $\\forall v_i \\phi$，从而得到 $\\phi[t/v_i]$。$t$ 的选择是由证明的逻辑决定的，而不是由一个方便的约定决定的。例如，可能需要将 $t_y \\equiv v_j$ 替换到一个包含 $\\forall v_j$ 作为子公式的公式 $\\phi_x$ 中。一个通用的替换函数必须足够强大以正确处理这种情况，这需要重命名。\n该陈述提出了两个有问题的主张：\n1.  这种需要被“完全避免”了：这是错误的。一个完全通用的 $\\mathrm{Sub}$ 函数，如算术化元数学（例如，为了证明哥德尔定理）所要求的，必须能够处理所有有效的输入 $x, i, y$，包括那些违反所提议约定的输入。这种需要只在*受限类别*的替换中被避免。\n2.  $\\mathrm{Sub}(x,i,y)$“无需检查”：这也是不正确的。为了强制执行该约定，函数需要检查条件是否满足，如果不满足，可能就停止并报错。这仍然是一种检查。一个真正的避免捕获的函数不会停止；它会执行重命名。因此，检测冲突的内部逻辑必须存在，这与它无需检查的主张相矛盾。\n无限多变量的存在是重命名的前提条件，而不是避免重命名的方法。核心问题是算法性的，而不是资源限制问题。\n\n**结论：**不正确。\n\n总结：选项 A、B 和 C 是对避免捕获的替换的性质和要求的正确描述，而选项 D 提出了一个不切实际的约定，未能解决普遍性问题。", "answer": "$$\\boxed{ABC}$$", "id": "3043154"}, {"introduction": "本章的最后一个练习是我们将前面所学工具融会贯通的顶峰之作，旨在实现语法算术化的一个核心目标：编码数学证明这一宏大概念。本练习将探讨如何将“$y$ 是 $x$ 的一个证明”这一判断形式化为一个原始递归谓词 $\\mathrm{Prf}_T(x,y)$，并且这个结论不依赖于所选用的具体证明系统 [@problem_id:3043156]。这一构造直接导向了数理逻辑中最深刻的结论之一：一个理论中所有可证定理的集合 $\\mathrm{Prov}_T(x)$ 是一个 $\\Sigma_1$ 集合，为哥德尔不完备性定理铺平了道路。", "problem": "设 $L$ 是一个可计算的一阶（FO）语言，具有一个固定的哥德尔配数（GN），该配数将 $L$ 的每个表达式赋一个自然数。设 $T$ 是 $L$ 中的一个有效公理化（EA）理论，这意味着存在一个原始递归谓词 $Ax_T(u)$，它能判定 $u$ 是否是 $T$ 的一个公理的编码。使用原始递归的配对函数和序列解码函数，固定一种将有限序列和有限树编码为自然数的方法。对于一个选定的证明演算，定义二元谓词 $\\mathrm{Prf}_T(x,y)$ 来表示 $y$ 是编码为 $x$ 的公式的一个 $T$-证明的编码，并定义一元谓词 $\\mathrm{Prov}_T(x)$ 如下：\n$$\n\\mathrm{Prov}_T(x) \\;\\equiv\\; \\exists y\\, \\mathrm{Prf}_T(x,y).\n$$\n考虑 $L$ 上的一阶逻辑的两种标准证明演算：希尔伯特式演算（推理规则少但公理模式多）和自然演绎演算（具有消除假设的树形推导）。两种演算都只使用有限多个规则模式，并且每个规则都应用于前面行或子证明的有限元组。\n\n下列哪个陈述是正确的？\n\nA. 对于任何有效公理化理论 $T$，使用希尔伯特演算或自然演绎演算定义的谓词 $\\mathrm{Prf}_T(x,y)$ 都是原始递归的，因为验证每个证明行或推理是一个由原始递归操作构成的有界的、句法上的检查；因此，在任一演算中 $\\mathrm{Prov}_T(x)$ 都是 $\\Sigma_1$ 的。\n\nB. $\\mathrm{Prov}_T(x)$ 作为 $\\Sigma_1$ 公式的分类依赖于完全性定理，因此对于自然演绎演算可能会失败，除非限制在最大紧凑的规则集上。\n\nC. 存在一个原始递归函数 $f$，使得对于任意一个编码为 $x$ 的公式的自然演绎证明的编码 $y$，$f(y)$ 是同一公式的一个希尔伯特式证明的编码；因此，$\\mathrm{Prf}_T$ 的两个版本在证明编码的原始递归翻译下是外延等价的。\n\nD. 因为自然演绎有具有无限多实例的规则模式（例如，可以应用于任何公式的量词规则），所以 $\\mathrm{Prf}_T(x,y)$ 在该系统中不可能是原始递归的，并且需要一个 $\\mu$-递归检查。\n\nE. 如果 $T$ 作为定理集合是不可判定的，那么 $\\mathrm{Prov}_T(x)$ 不能被算术化为一个 $\\Sigma_1$ 公式，因为判定 $y$ 是否编码了 $x$ 的一个有效证明需要对假定证明的所有行进行全称量化。", "solution": "题干是数理逻辑中的一个有效练习，特别是关于语法的算术化和递归论。所使用的所有术语都是标准的、良定义的，并且前提是一致的，足以进行严谨的分析。\n\n问题的核心围绕着谓词 $\\mathrm{Prf}_T(x,y)$ 和 $\\mathrm{Prov}_T(x)$ 的可计算性类。我们先来分析这一点。\n\n谓词 $\\mathrm{Prf}_T(x,y)$ 形式化了“$y$ 是理论 $T$ 中哥德尔数为 $x$ 的公式的一个有效证明的哥德尔数”这一陈述。要确定对于给定的自然数对 $(x, y)$，$\\mathrm{Prf}_T(x,y)$ 是否为真，我们必须对 $y$ 进行一次算法检验。\n\n验证一个证明的过程，无论是在希尔伯特式系统中的公式序列，还是在自然演绎系统中的公式树，都包含有限个机械步骤。我们已知证明的编码（作为序列或树）是使用原始递归函数完成的。这意味着将 $y$ 解码为其组成部分（公式的序列或树）是一个原始递归操作。\n\n让我们考虑每种演算的验证过程：\n\n1.  **希尔伯特式演算：** 一个证明是一个有限的公式序列，比如 $(\\phi_1, \\phi_2, \\ldots, \\phi_n)$。数字 $y$ 编码了这个序列。\n    *   首先，我们解码 $y$ 以获得 $\\phi_1, \\ldots, \\phi_n$ 的哥德尔数。这是一个原始递归操作。\n    *   我们检查最后一个公式 $\\phi_n$ 的哥德尔数是否等于 $x$。这是一个原始递归检查。\n    *   然后我们从 $i=1$ 到 $n$ 进行迭代。对于每个公式 $\\phi_i$，我们必须检查它在该步骤是否有效。这意味着 $\\phi_i$ 必须是：\n        a.  一个逻辑公理。公理模式的数量是有限的。检查一个公式是否是给定模式的一个实例是一个纯粹的句法模式匹配操作，这是原始递归的。\n        b.  理论 $T$ 的一个公理。我们已知 $T$ 是有效公理化的，这意味着谓词 $Ax_T(u)$（检查 $u$ 是否是 $T$ 的一个公理的编码）是原始递归的。\n        c.  使用推理规则（例如，肯定前件式）从序列中前面的公式推导出来。对于肯定前件式，我们会检查是否存在 $j, k  i$，使得 $\\phi_k$ 是公式 $(\\phi_j \\to \\phi_i)$。这需要在一个有限数量的先前配对中进行搜索，这是一个有界搜索。这个操作是原始递归的。\n    *   由于循环运行有限步（证明的长度 $n$ 由 $y$ 决定），并且循环内的每个检查都是原始递归的，所以整个谓词 $\\mathrm{Prf}_T(x,y)$ 是原始递归的。在一个原始递归关系上的有界全称量词（$\\forall i  n$）产生一个原始递归关系。\n\n2.  **自然演绎演算：** 一个证明是一个有限的公式树。数字 $y$ 编码了这棵树。\n    *   我们解码 $y$ 以获得树结构和每个节点上的公式。这是一个原始递归操作。\n    *   我们检查树根处的公式的哥德尔数是否为 $x$。\n    *   我们对树结构进行递归验证。对于每个节点，我们根据有限数量的推理规则模式之一，检查该节点上的公式是否正确地从其子节点上的公式推导出来。这涉及检查公式的句法形式和规则名称，这是原始递归的。我们还必须正确管理消除的假设，这涉及检查树结构上的注释，这也是一个原始递归的任务。\n    *   树的叶子必须是 $T$ 的公理（用原始递归的 $Ax_T$ 检查）或被树中更高层的规则应用正确消除的假设。\n    *   这个验证可以通过对由 $y$ 编码的证明树的结构进行递归来定义。由于编码函数是原始递归的，这对应于对 $y$ 的值程递归，这是一个原始递归过程。\n\n在这两种情况下，验证一个证明都是一个有限的、句法上的过程，可以通过一个总能终止的算法来执行。这个算法可以只使用原始递归函数和有界递归/迭代来构建。因此，对于任何标准的证明演算，谓词 $\\mathrm{Prf}_T(x,y)$ 都是原始递归的。\n\n因此，可证性谓词定义为 $\\mathrm{Prov}_T(x) \\equiv \\exists y\\, \\mathrm{Prf}_T(x,y)$，它涉及在一个原始递归谓词上的一个无界存在量词。根据算术层级的定义，这使得 $\\mathrm{Prov}_T(x)$ 成为一个 $\\Sigma_1$ 谓词。\n\n现在我们来评估给出的选项。\n\n**A. 对于任何有效公理化理论 $T$，使用希尔伯特演算或自然演绎演算定义的谓词 $\\mathrm{Prf}_T(x,y)$ 都是原始递归的，因为验证每个证明行或推理是一个由原始递归操作构成的有界的、句法上的检查；因此，在任一演算中 $\\mathrm{Prov}_T(x)$ 都是 $\\Sigma_1$ 的。**\n这个陈述是上述分析的精确总结。证明检查是一个有界的句法检查的推理是正确的。这使得 $\\mathrm{Prf}_T(x,y)$ 是原始递归的结论是正确的。最后的推论，即 $\\mathrm{Prov}_T(x)$ 因此是 $\\Sigma_1$ 的，直接从定义得出。\n**结论：正确。**\n\n**B. $\\mathrm{Prov}_T(x)$ 作为 $\\Sigma_1$ 公式的分类依赖于完全性定理，因此对于自然演绎演算可能会失败，除非限制在最大紧凑的规则集上。**\n这个陈述是不正确的。$\\mathrm{Prov}_T(x)$ 的分类是*语法*算术化和可计算性理论的结果。它关系到检查证明的算法复杂性。完全性定理（$\\phi$ 是 $T$ 的逻辑推论当且仅当 $\\phi$ 可以从 $T$ 证明）将语法与*语义学*（在模型中的真）联系起来。可证性的算术化不依赖于这种联系。关于“最大紧凑规则集”的说法是一个没有根据的干扰项；标准的自然演绎系统完全可以进行算术化，从而得到一个 $\\Sigma_1$ 的可证性谓词。\n**结论：不正确。**\n\n**C. 存在一个原始递归函数 $f$，使得对于任意一个编码为 $x$ 的公式的自然演绎证明的编码 $y$，$f(y)$ 是同一公式的一个希尔伯特式证明的编码；因此，$\\mathrm{Prf}_T$ 的两个版本在证明编码的原始递归翻译下是外延等价的。**\n这个陈述是正确的。这是证明论中的一个标准结果，即一阶逻辑的常见形式系统（如希尔伯特式、自然演绎和相继式演算）证明相同的定理集，并且存在有效的算法可以将证明从一个系统翻译到另一个系统。这些翻译的算法是纯粹的句法操作。例如，将自然演绎证明翻译为希尔伯特式证明，涉及通过使用演绎定理的构造性证明来系统地消除像条件证明这样的规则。这个过程可以通过对自然演绎证明树的结构进行递归来定义。这种对哥德尔数的递归转换可以形式化为一个原始递归函数。因此，存在一个原始递归函数 $f$，它将一个自然演绎证明的编码映射到一个等价的希尔伯特式证明的编码。\n**结论：正确。**\n\n**D. 因为自然演绎有具有无限多实例的规则模式（例如，可以应用于任何公式的量词规则），所以 $\\mathrm{Prf}_T(x,y)$ 在该系统中不可能是原始递归的，并且需要一个 $\\mu$-递归检查。**\n这个陈述是基于一个误解。希尔伯特式系统也有具有无限多实例的公理模式。关键点在于*模式的数量是有限的*。要检查一个给定的公式是否是一个模式的实例，需要执行一个有限的、句法上的模式匹配过程。这个过程是可判定的，实际上是原始递归的。它不需要无界搜索（一个 $\\mu$-算子）。存在无限多个可能的实例，并不妨碍对*给定*公式的检查是原始递归的。\n**结论：不正确。**\n\n**E. 如果 $T$ 作为定理集合是不可判定的，那么 $\\mathrm{Prov}_T(x)$ 不能被算术化为一个 $\\Sigma_1$ 公式，因为判定 $y$ 是否编码了 $x$ 的一个有效证明需要对假定证明的所有行进行全称量化。**\n这个陈述不正确，主要有两个原因。首先，前提推不出结论。对于任何足够强的、一致的、有效公理化的理论 $T$（如皮亚诺算术），其定理集是不可判定的（这是哥德尔第一不完全性定理的一个推论）。然而，其可证性谓词 $\\mathrm{Prov}_T(x)$ 是 $\\Sigma_1$-完全集的典型例子。所以，不可判定与是 $\\Sigma_1$ 的并不矛盾。不可判定仅仅意味着它不是递归的（即，不能被一个对所有输入都停机的算法所判定）。其次，所提供的推理是有缺陷的。“对假定证明的所有行进行全称量化”是一个*有界*量化，因为被检查的证明（由 $y$ 编码）是一个具有特定长度的有限对象。在一个原始递归谓词上的有界全称量词产生一个原始递归谓词。它不会在算术层级中使谓词更复杂。\n**结论：不正确。**\n\n总之，陈述 A 和 C 是对逻辑算术化中基本结果的正确描述。", "answer": "$$\\boxed{AC}$$", "id": "3043156"}]}