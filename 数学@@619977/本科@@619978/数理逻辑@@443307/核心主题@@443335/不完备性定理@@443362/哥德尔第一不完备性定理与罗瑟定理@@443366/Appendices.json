{"hands_on_practices": [{"introduction": "理解哥德尔不完备性定理的第一步，是掌握其核心技术——算术化（arithmetization）。这个过程将抽象的逻辑符号、公式和证明转化为独特的自然数，从而允许算术理论“谈论”自身的句法属性。本练习将引导您使用基于素数分解的经典哥德尔编码方法，亲手计算一个算术公式的哥德尔数，从而将这一抽象概念变得具体可感。[@problem_id:3043011]", "problem": "您将在一阶算术语言中工作，该语言包含符号 $($, $)$, $=$, $+$, $0$，全称量词 $\\forall$ 和变量符号 $x$。规定以下哥德尔配数方案。\n\n- 为每个基本符号分配一个正整数编码 $c(\\cdot)$，具体如下：\n  - $c(\\forall)=1$\n  - $c(x)=2$\n  - $c(()=3$\n  - $c())=4$\n  - $c(+)=5$\n  - $c(0)=6$\n  - $c(=)=7$\n- 令 $\\{p_{k}\\}_{k \\geq 1}$ 为递增的素数序列，因此 $p_{1}=2$，$p_{2}=3$，$p_{3}=5$，$p_{4}=7$，$p_{5}=11$，$p_{6}=13$，$p_{7}=17$，$p_{8}=19$，$p_{9}=23$，依此类推。\n- 对于任意有限符号序列 $s_{1}s_{2}\\dots s_{n}$，将其哥德尔编码定义为\n  $$G(s_{1}s_{2}\\dots s_{n}) \\;=\\; \\prod_{k=1}^{n} p_{k}^{\\,c(s_{k})}.$$\n\n将目标公式\n$$\\forall x\\,(x+0=x)$$\n视为精确的符号序列\n$$\\forall,\\; x,\\; (, \\; x,\\; +,\\; 0,\\; =,\\; x,\\; ).$$\n\n任务：\n1. 根据上述方案，明确计算哥德尔编码 $G(\\forall x (x+0=x))$，并用指定的 $p_{1}$ 到 $p_{9}$ 将答案表示为单个精确的素数幂乘积。\n2. 通过描述使用唯一素数分解的解码步骤，验证您的编码可以恢复出原始的符号序列。\n\n答案规格：\n- 将最终的哥德尔编码以单个精确表达式的形式提供。不要进行近似或四舍五入。\n- 不涉及物理单位；以精确的符号形式报告表达式。", "solution": "该问题要求计算一个特定公式的哥德尔编码，并验证解码过程。该过程基于所提供的哥德尔配数方案。\n\n首先，我们解决任务1：计算哥德尔编码 $G(\\forall x (x+0=x))$。\n\n目标公式被给出为精确的符号序列 $s = s_{1}s_{2}\\dots s_{9}$，其中：\n$s_{1} = \\forall$\n$s_{2} = x$\n$s_{3} = ($\n$s_{4} = x$\n$s_{5} = +$\n$s_{6} = 0$\n$s_{7} = =$\n$s_{8} = x$\n$s_{9} = )$\n\n该序列的长度为 $n=9$。\n\n接下来，我们根据提供的列表，将序列中的每个符号 $s_k$ 映射到其分配的正整数编码 $c(s_k)$：\n$c(s_{1}) = c(\\forall) = 1$\n$c(s_{2}) = c(x) = 2$\n$c(s_{3}) = c(() = 3$\n$c(s_{4}) = c(x) = 2$\n$c(s_{5}) = c(+) = 5$\n$c(s_{6}) = c(0) = 6$\n$c(s_{7}) = c(=) = 7$\n$c(s_{8}) = c(x) = 2$\n$c(s_{9}) = c()) = 4$\n\n哥德尔编码 $G(s)$ 定义为乘积 $\\prod_{k=1}^{n} p_{k}^{c(s_{k})}$，其中 $p_k$ 是第 $k$ 个素数。对于我们长度为 $n=9$ 的序列，我们需要前九个素数：\n$p_{1} = 2$\n$p_{2} = 3$\n$p_{3} = 5$\n$p_{4} = 7$\n$p_{5} = 11$\n$p_{6} = 13$\n$p_{7} = 17$\n$p_{8} = 19$\n$p_{9} = 23$\n\n现在，我们通过将符号编码作为序列中相应素数的指数来构建哥德尔编码：\n$$G(\\forall x (x+0=x)) = p_{1}^{c(s_1)} \\cdot p_{2}^{c(s_2)} \\cdot p_{3}^{c(s_3)} \\cdot p_{4}^{c(s_4)} \\cdot p_{5}^{c(s_5)} \\cdot p_{6}^{c(s_6)} \\cdot p_{7}^{c(s_7)} \\cdot p_{8}^{c(s_8)} \\cdot p_{9}^{c(s_9)}$$\n代入具体的素数及其对应的符号编码指数：\n$$G = 2^{1} \\cdot 3^{2} \\cdot 5^{3} \\cdot 7^{2} \\cdot 11^{5} \\cdot 13^{6} \\cdot 17^{7} \\cdot 19^{2} \\cdot 23^{4}$$\n这个表达式就是根据任务1的要求明确计算出的公式 $\\forall x (x+0=x)$ 的哥德尔编码。\n\n接下来，我们解决任务2：验证该编码可以恢复出原始的符号序列。\n\n解码过程是编码过程的逆过程，并关键地依赖于**算术基本定理**。该定理保证任何大于1的整数都有唯一的素数分解。根据其构造，哥德尔数 $G$ 已经以其唯一的素数幂分解形式表示。\n\n设哥德尔数为 $G_0 = 2^{1} \\cdot 3^{2} \\cdot 5^{3} \\cdot 7^{2} \\cdot 11^{5} \\cdot 13^{6} \\cdot 17^{7} \\cdot 19^{2} \\cdot 23^{4}$。\n要解码这个数，我们执行以下步骤：\n1. 找到 $G_0$ 的素数分解。如上所示，素因子为 $p_1=2$，$p_2=3$，$p_3=5$，$p_4=7$，$p_5=11$，$p_6=13$，$p_7=17$，$p_8=19$ 和 $p_9=23$。最大的素因子是 $p_9=23$，这表明原始序列的长度为 $n=9$。\n2. 提取与有序素数 $p_1, p_2, \\dots, p_9$ 相对应的指数序列：\n    $p_1=2$ 的指数是 $1$。\n    $p_2=3$ 的指数是 $2$。\n    $p_3=5$ 的指数是 $3$。\n    $p_4=7$ 的指数是 $2$。\n    $p_5=11$ 的指数是 $5$。\n    $p_6=13$ 的指数是 $6$。\n    $p_7=17$ 的指数是 $7$。\n    $p_8=19$ 的指数是 $2$。\n    $p_9=23$ 的指数是 $4$。\n    这给出了编码序列 $(1, 2, 3, 2, 5, 6, 7, 2, 4)$。\n3. 使用函数 $c(\\cdot)$ 的逆，将此序列中的每个编码映射回其对应的符号。\n    - 编码 $1 \\rightarrow c^{-1}(1) = \\forall$ (这将是 $s_1$)\n    - 编码 $2 \\rightarrow c^{-1}(2) = x$ (这将是 $s_2$)\n    - 编码 $3 \\rightarrow c^{-1}(3) = ($ (这将是 $s_3$)\n    - 编码 $2 \\rightarrow c^{-1}(2) = x$ (这将是 $s_4$)\n    - 编码 $5 \\rightarrow c^{-1}(5) = +$ (这将是 $s_5$)\n    - 编码 $6 \\rightarrow c^{-1}(6) = 0$ (这将是 $s_6$)\n    - 编码 $7 \\rightarrow c^{-1}(7) = =$ (这将是 $s_7$)\n    - 编码 $2 \\rightarrow c^{-1}(2) = x$ (这将是 $s_8$)\n    - 编码 $4 \\rightarrow c^{-1}(4) = )$ (这将是 $s_9$)\n4. 按顺序重新组装这些符号以重构原始序列：\n    $$s_1s_2s_3s_4s_5s_6s_7s_8s_9 = \\forall, x, (, x, +, 0, =, x, )$$\n这正是公式 $\\forall x (x+0=x)$ 的符号序列。素数分解的唯一性确保了解码过程是无歧义的，并且总是能恢复出唯一的原始符号序列。这确立了哥德尔配数方案的单射性。", "answer": "$$\\boxed{2^{1} \\cdot 3^{2} \\cdot 5^{3} \\cdot 7^{2} \\cdot 11^{5} \\cdot 13^{6} \\cdot 17^{7} \\cdot 19^{2} \\cdot 23^{4}}$$", "id": "3043011"}, {"introduction": "在手动计算一个哥德尔数之后，下一个自然的步骤是探索如何将整个编码过程系统化和程序化，并了解不同的编码方案。本练习将指导您实现一种替代的哥德尔编码方案，该方案使用基数17表示法来编码公式，并使用康托尔配对函数来编码证明序列。通过完成这个练习，您将深刻体会到，编码的具体方法并非关键，重要的是存在一种有效的、可计算的机制，能够将整个形式系统的句法结构映射到自然数中。[@problem_id:3043021]", "problem": "设 $T$ 是一个固定的、可计算公理化的一阶算术理论。Gödel第一不完备性定理和Rosser定理背后的核心机制是语法的有效算术化：公式、证明以及关系“$p$ 是 $\\varphi$ 的一个 $T$-证明”都可以通过原始递归编码表示为自然数。在本问题中，您将为一个具有少量公理的简单算术理论 $T$ 显式地实现这样一个编码，然后枚举前几个证明的代码及其所证明定理的代码。\n\n将使用的基本基础和定义：\n- 如果一个理论的公理集是可判定的，则称其为“有效公理化的”；如果其定理集是递归可枚举的，则称其为“递归可公理化的”。Robinson算术 $Q$ 是一个标准的有穷公理化和有效公理化的算术理论，足以表示原始递归的语法编码。\n- 将字符串原始递归编码为自然数的方法是，在固定的基数 $B$ 中解释符号序列，并通过一个原始递归的配对函数组合有限序列。\n- Cantor配对函数 $\\pi$ 定义为 $\\pi(a,b) = \\frac{(a+b)(a+b+1)}{2} + b$，是 $\\mathbb{N} \\times \\mathbb{N}$ 到 $\\mathbb{N}$ 的一个双射；它是原始递归的。\n\n语言、符号集和符号到代码的映射：\n考虑以下一阶算术语言，其符号集为 $\\Sigma = \\{ \"(\", \")\", \"=\", \"+\", \"*\", \"0\", \"S\", \"x\", \"y\", \"z\", \"¬\", \"→\", \"∀\", \"∃\" \\}$。固定基本符号编码 $c : \\Sigma \\to \\mathbb{N}$，由以下给出\n$c(\"(\") = 1$, $c(\")\") = 2$, $c(\"=\") = 3$, $c(\"+\") = 4$, $c(\"*\") = 5$, $c(\"0\") = 6$, $c(\"S\") = 7$, $c(\"x\") = 8$, $c(\"y\") = 9$, $c(\"z\") = 10$, $c(\"¬\") = 11$, $c(\"→\") = 12$, $c(\"∀\") = 13$, $c(\"∃\") = 14$。\n\n公式和证明的编码：\n- 固定基数 $B = 17$。对于一个由有限符号序列 $(t_0, t_1, \\dots, t_{n-1})$ 表示的公式，其中每个 $t_j \\in \\Sigma$，其公式代码定义为\n$$\\mathrm{code}_{\\mathrm{form}}(t_0 \\dots t_{n-1}) = \\sum_{j=0}^{n-1} c(t_j) \\cdot B^{j}。$$\n- 对于一个由公式代码序列 $(f_1, f_2, \\dots, f_m)$ 组成的有限证明，其证明代码通过迭代Cantor配对函数定义为\n$$\\mathrm{code}_{\\mathrm{proof}}(f_1,\\dots,f_m) = \\pi(\\pi(\\dots \\pi(\\pi(0, f_1), f_2) \\dots ), f_m)。$$\n该定义是原始递归的，并且对于有限序列是单射的。\n\n理论 $T$：\n令 $T$ 为Robinson算术 $Q$，具有以下七条公理（所有变量都假定被适当地限制在自然数范围内，并且量词绑定其最近的变量）：\n1. $\\,\\forall x \\, \\neg ( S(x) = 0 )$。\n2. $\\,\\forall x \\, \\forall y \\, \\big( S(x) = S(y) \\to x = y \\big)$。\n3. $\\,\\forall x \\, \\big( \\neg ( x = 0 ) \\to \\exists y \\, ( x = S(y) ) \\big)$。\n4. $\\,\\forall x \\, \\big( x + 0 = x \\big)$。\n5. $\\,\\forall x \\, \\forall y \\, \\big( x + S(y) = S( x + y ) \\big)$。\n6. $\\,\\forall x \\, \\big( x * 0 = 0 \\big)$。\n7. $\\,\\forall x \\, \\forall y \\, \\big( x * S(y) = x * y + x \\big)$。\n\n为了本练习的目的，将每条公理本身视为一个定理，其证明仅包含该公理这一行。因此，对于每个公理字符串，您将计算其公式代码，然后计算仅包含该公式代码的单元素证明序列的证明代码。\n\n任务：\n- 实现如上所述的符号编码 $c$，并能够将每个代码移动一个整数偏移量 $o \\geq 0$，即使用 $c_o(\\sigma) = c(\\sigma) + o$。这使您能够测试编码方案对于系统性地重新编号符号是否具有鲁棒性。\n- 实现公理字符串的符号化，通过移除空格并将每个字符读取为一个符号，其中字符 $\"$∀\"$, $\"$∃\"$, $\"$¬\"$ 和 $\"$→\"$ 是单字符符号。\n- 使用基数 $B = 17$ 计算 $\\mathrm{code}_{\\mathrm{form}}$，并如上定义通过迭代Cantor配对函数计算 $\\mathrm{code}_{\\mathrm{proof}}$。\n- 按顺序枚举 $Q$ 的前 $k$ 条公理作为单行证明，并生成它们的证明代码列表以及它们对应公式代码的列表。\n\n测试套件和输出规范：\n使用以下测试用例，每个用例由 $(k,o)$ 参数化，其中 $k$ 是要枚举的公理数量（从列表开头算起），$o$ 是符号代码的偏移量：\n- 测试用例 1：$(k,o) = (4, 0)$，即“理想路径”，包含四条公理和基本编码。\n- 测试用例 2：$(k,o) = (0, 0)$，即边界情况，不产生任何证明。\n- 测试用例 3：$(k,o) = (2, 1)$，即边缘情况，使用两条公理和代码偏移量 $o = 1$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。每个测试用例贡献一对列表 $[\\,[p_1,\\dots,p_k],[t_1,\\dots,t_k]\\,]$，其中 $p_i = \\mathrm{code}_{\\mathrm{proof}}$，$t_i = \\mathrm{code}_{\\mathrm{form}}$ 分别是第 $i$ 个枚举公理的证明代码和公式代码。例如，整体输出格式必须为\n$$[\\,[[p_1,\\dots,p_k],[t_1,\\dots,t_k]],\\,[\\dots],\\,[\\dots]\\,].$$\n所有输出均为整数；本问题不涉及物理单位。", "solution": "问题陈述已经过验证，被认为是一项真实、严谨的数理逻辑练习。它在科学上基于可计算性理论和数学基础的原理，特别涉及语法的算术化，这是Gödel不完备性定理的基石。该问题是自包含的，所有必要的定义、公理和函数都已明确提供。给定的参数和约束是一致且计算上可行的。因此，我将提供一个完整的解决方案。\n\n问题的核心是为算术的一个片段实现一个特定版本的Gödel数，这个过程被称为算术化。这涉及到将一个形式理论 $T$ 的句法对象——公式和证明——映射到自然数。在算术内部表示关于语法的语句的能力，使得构造自指句子成为可能，从而导致不完备性结果。\n\n解决方案设计为三个逻辑步骤，反映了编码方案的层次结构。\n\n1.  **分词与符号编码**\n    第一步是将理论 $T$ 的公理（以字符串形式给出）转换为自然数序列。所提供的形式语言使用了一个有限的符号集 $\\Sigma = \\{ \"(\", \")\", \"=\", \"+\", \"*\", \"0\", \"S\", \"x\", \"y\", \"z\", \"¬\", \"→\", \"∀\", \"∃\" \\}$。一个基本编码函数 $c: \\Sigma \\to \\mathbb{N}$ 将每个符号映射到一个唯一的正整数。问题引入了一个可编程的偏移量 $o \\ge 0$ 来定义一个更通用的编码 $c_o(\\sigma) = c(\\sigma) + o$。这展示了该方案的鲁棒性，因为具体的数字选择并非关键，关键在于映射是有效的（即可计算的）。公理字符串首先通过移除空格并视每个字符为不同符号来进行分词。例如，公理字符串 `∀x (x + 0 = x)` 被转换为符号序列 $(\\text{‘∀’}, \\text{‘x’}, \\text{‘(’}, \\text{‘x’}, \\text{‘+’}, \\text{‘0’}, \\text{‘=’}, \\text{‘x’}, \\text{‘)’})$。然后使用 $c_o$ 将此符号序列映射为整数序列。\n\n2.  **公式编码**\n    第二步是为每个公式分配一个唯一的自然数，称为Gödel数或代码。问题指定了一个位置编码方案。给定一个由符号序列 $(t_0, t_1, \\dots, t_{n-1})$ 表示的公式，其代码计算如下：\n    $$\n    \\mathrm{code}_{\\mathrm{form}}(t_0 \\dots t_{n-1}) = \\sum_{j=0}^{n-1} c_o(t_j) \\cdot B^{j}\n    $$\n    其中 $B = 17$ 是所选的基数。基数 $B$ 必须大于任何可能的符号代码 $c_o(t_j)$，以确保编码是单射的（即每个不同的公式映射到不同的数字）。鉴于最大基本代码为 $c(\\text{‘∃’}) = 14$，测试的最大偏移量为 $o=1$，因此最大符号代码为 $15$，这安全地小于基数 $B=17$。这个将有限数字序列映射到单个数字的函数是一个原始递归函数。这个性质对于Gödel定理的形式证明至关重要，因为它确保了“作为一个公式的代码”这一属性可以在算术理论本身中表达。\n\n3.  **证明编码**\n    最后一步是编码证明。在一个形式系统中，证明是一个有限的公式序列，其中每个公式要么是一个公理，要么是通过推理规则从前面的公式推导出来的。问题通过将理论 $Q$ 的每条公理视为一个定理来简化此过程，其证明仅由该公理所在的单行组成。因此，一个证明由一个包含单个公式代码的序列 $(f_1)$ 表示。对于一个公式代码序列 $(f_1, f_2, \\dots, f_m)$ 的编码，是通过迭代应用Cantor配对函数 $\\pi(a,b) = \\frac{1}{2}(a+b)(a+b+1) + b$ 来定义的：\n    $$\n    \\mathrm{code}_{\\mathrm{proof}}(f_1, \\dots, f_m) = \\pi(\\pi(\\dots \\pi(\\pi(0, f_1), f_2) \\dots ), f_m)\n    $$\n    该过程从一个基值 $0$ 开始。对于指定的单行证明，这简化为：\n    $$\n    \\mathrm{code}_{\\mathrm{proof}}(f_1) = \\pi(0, f_1)\n    $$\n    Cantor配对函数是一个著名的从 $\\mathbb{N} \\times \\mathbb{N}$ 到 $\\mathbb{N}$ 的原始递归双射。其迭代使用提供了一种将任何有限自然数序列原始递归地编码为单个自然数的方法。\n\n实现将针对每个测试用例 $(k, o)$ 系统地应用这三个阶段，用指定的代码偏移量 $o$ 处理前 $k$ 条公理。使用Python的任意精度整数是至关重要的，因为Gödel数增长得非常快。最终输出被格式化为一个由列表对组成的列表，其中包含每个测试用例产生的证明代码和公式代码。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    # Per the execution environment, numpy is available. It is not used in this specific\n    # implementation as Python's arbitrary-precision integers are more suitable for the\n    # very large numbers generated by Gödel numbering.\n\n    # The seven axioms of Robinson Arithmetic Q, as provided in the problem statement.\n    # Spaces are included as in the problem's presentation and will be removed during tokenization.\n    AXIOMS = [\n        \"∀x ¬( S(x) = 0 )\",\n        \"∀x ∀y ( S(x) = S(y) → x = y )\",\n        \"∀x ( ¬( x = 0 ) → ∃y ( x = S(y) ) )\",\n        \"∀x ( x + 0 = x )\",\n        \"∀x ∀y ( x + S(y) = S( x + y ) )\",\n        \"∀x ( x * 0 = 0 )\",\n        \"∀x ∀y ( x * S(y) = x * y + x )\"\n    ]\n\n    # The fixed base symbol encoding map `c`.\n    CODE_MAP = {\n        \"(\": 1, \")\": 2, \"=\": 3, \"+\": 4, \"*\": 5, \"0\": 6, \"S\": 7,\n        \"x\": 8, \"y\": 9, \"z\": 10, \"¬\": 11, \"→\": 12, \"∀\": 13, \"∃\": 14\n    }\n\n    # The base B for formula encoding.\n    BASE = 17\n\n    def cantor_pairing(a, b):\n        \"\"\"\n_        Computes the Cantor pairing function π(a,b).\n_        Uses integer arithmetic to handle large numbers.\n_        \"\"\"\n        return ((a + b) * (a + b + 1)) // 2 + b\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (4, 0),\n        (0, 0),\n        (2, 1),\n    ]\n\n    all_results_as_strings = []\n    for k, o in test_cases:\n        proof_codes = []\n        theorem_codes = []\n\n        # Select the first k axioms for processing.\n        axioms_to_process = AXIOMS[:k]\n\n        for axiom_str in axioms_to_process:\n            # Step 1: Tokenize the axiom string by removing spaces.\n            tokens = [char for char in axiom_str if char != ' ']\n\n            # Step 2: Compute the formula code (`code_form`).\n            formula_code = 0\n            for j, token in enumerate(tokens):\n                # Apply the offset `o` to the base symbol code from the map.\n                symbol_code = CODE_MAP[token] + o\n                # Add the contribution of this token to the base-B expansion.\n                formula_code += symbol_code * (BASE ** j)\n            theorem_codes.append(formula_code)\n            \n            # Step 3: Compute the proof code (`code_proof`) for a one-line proof.\n            # For a single formula f1, the proof code is π(0, f1).\n            proof_code = cantor_pairing(0, formula_code)\n            proof_codes.append(proof_code)\n            \n        # Format the result for the current test case into the specified string format.\n        case_result_str = f\"[[{','.join(map(str, proof_codes))}],[{','.join(map(str, theorem_codes))}]]\"\n        all_results_as_strings.append(case_result_str)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(all_results_as_strings)}]\")\n\nsolve()\n```", "id": "3043021"}, {"introduction": "一旦我们能够用算术语言来表示“可证性”这一概念，我们就可以构建出一些具有非常微妙甚至反直觉性质的理论。本练习旨在通过一个经典的“思想实验”——构建一个协调但ω不协调的理论，来揭示哥德尔第一不完备性定理原始证明中的一个关键假设。理解协调性（consistency）与更强的ω协调性（omega-consistency）之间的差异，对于领会罗瑟定理如何改进并加强哥德尔的原始结果至关重要。[@problem_id:3044068]", "problem": "考虑皮亚诺算术（PA），这是一种具有递归公理集的标准一阶算术理论。回顾算术语言中理论 $T$ 的以下基本概念：\n- 如果理论 $T$ 的公理集是可计算可枚举的，则称 $T$ 是递归公理化的。\n- 如果不存在公式 $\\varphi$ 使得 $\\varphi$ 和 $\\neg \\varphi$ 在 $T$ 中都可证，则称 $T$ 是相容的。\n- 对于任意公式 $\\varphi(x)$，如果 $T$ 对所有数码 $\\overline{n}$ 都能证明 $\\neg \\varphi(\\overline{0}), \\neg \\varphi(\\overline{1}), \\neg \\varphi(\\overline{2}), \\dots$，但不能证明 $\\exists x\\, \\varphi(x)$，则称 $T$ 是 $\\omega$-相容的。\n- 令 $\\mathrm{Pr}_T(n,m)$ 为一个标准的原始递归证明谓词，表示 $n$ 编码了哥德尔数为 $m$ 的公式的一个 $T$-证明。\n- 令 $\\mathrm{Con}(T)$ 为一个算术语句，它形式化了不存在 $n$ 使得 $\\mathrm{Pr}_T(n,\\ulcorner 0=1\\urcorner)$，即 $T$ 不会证明一个矛盾。\n\n使用这些基本定义以及以下公认事实：(i) 证明谓词 $\\mathrm{Pr}_T$ 是原始递归的，并且在算术内部正确地表示了可证性，(ii) 皮亚诺算术可以证明所有关于数码的真有界量词（$\\Delta_0$）事实，以及 (iii) 哥德尔第二不完备性定理：如果 $T$ 是一个相容的、足够强的、递归公理化的理论（例如，能够表示基本算术的 PA 的一个扩展），那么 $T \\nvdash \\mathrm{Con}(T)$。\n\n哪个选项正确地给出了一个 PA 的递归公理化扩展的例子，该扩展是相容的但不是 $\\omega$-相容的，并准确解释了这个例子如何限制了哥德尔第一不完备性定理中的假设？\n\nA. 取 $T = \\mathrm{PA} + \\neg \\mathrm{Con}(\\mathrm{PA})$。假设 $\\mathrm{PA}$ 是相容的，那么根据哥德尔第二不完备性定理的逆否命题，$T$ 是递归公理化且相容的：如果 $T$ 是不相容的，那么 $\\mathrm{PA} \\vdash \\mathrm{Con}(\\mathrm{PA})$，这与哥德尔第二定理矛盾。然而，$T$ 不是 $\\omega$-相容的，因为 $T \\vdash \\exists n\\, \\mathrm{Pr}_{\\mathrm{PA}}(n,\\ulcorner 0=1\\urcorner)$，而对于每个数码 $\\overline{k}$，$T$ 利用 PA 检查每个具体原始递归实例的能力证明了 $\\neg \\mathrm{Pr}_{\\mathrm{PA}}(\\overline{k},\\ulcorner 0=1\\urcorner)$。这表明哥德尔最初的第一不完备性定理关键性地使用了 $\\omega$-相容性来确保其哥德尔语句的不可判定性；如果没有 $\\omega$-相容性，该理论可能会反驳哥德尔语句。Rosser 的强化版本移除了对 $\\omega$-相容性的需求，仅在纯粹相容性的条件下建立了不完备性。\n\nB. 取 $T = \\mathrm{PA} + \\neg \\mathrm{Con}(\\mathrm{PA})$。假设 $\\mathrm{PA}$ 是相容的，$T$ 是不相容的，因为它断言了其自身的不相容性。这表明哥德尔第一不完备性定理只需要相容性，因为 $\\omega$-相容性可以从相容性中得出。\n\nC. 取 $T = \\mathrm{PA} + \\mathrm{Con}(\\mathrm{PA})$。这个理论 $T$ 是递归公理化的且不是 $\\omega$-相容的，因为它断言了其自身的相容性，这违反了哥德尔第一不完备性定理。因此，即使在 $\\omega$-相容性的条件下，第一不完备性定理也不成立。\n\nD. 取 $T = \\mathrm{PA} + \\forall n\\, \\neg \\mathrm{Pr}_{\\mathrm{PA}}(n,\\ulcorner 0=1\\urcorner)$，也就是 $\\mathrm{PA} + \\mathrm{Con}(\\mathrm{PA})$。由于 $T$ 证明了不存在矛盾的编码，所以它是相容的但不是递归公理化的，这表明 $\\omega$-相容性在哥德尔第一不完备性定理中是不必要的。", "solution": "### 问题验证\n\n#### 步骤 1：提取已知条件\n- 理论：皮亚诺算术（PA），具有递归公理集的标准一阶算术理论。\n- 定义：如果一个理论 $T$ 的公理集是可计算可枚举的，则称该理论是递归公理化的。\n- 定义：如果不存在公式 $\\varphi$ 使得 $\\varphi$ 和 $\\neg \\varphi$ 在理论 $T$ 中都可证，则称 $T$ 是相容的。\n- 定义：对于任意公式 $\\varphi(x)$，如果 $T$ 对所有数码 $\\overline{n}$ 都能证明 $\\neg \\varphi(\\overline{0}), \\neg \\varphi(\\overline{1}), \\neg \\varphi(\\overline{2}), \\dots$，但不能证明 $\\exists x\\, \\varphi(x)$，则称 $T$ 是 $\\omega$-相容的。\n- 定义：令 $\\mathrm{Pr}_T(n,m)$ 为一个标准的原始递归证明谓词，表示 $n$ 编码了哥德尔数为 $m$ 的公式的一个 $T$-证明。\n- 定义：令 $\\mathrm{Con}(T)$ 为一个算术语句，它形式化了不存在 $n$ 使得 $\\mathrm{Pr}_T(n,\\ulcorner 0=1\\urcorner)$，即 $T$ 不会证明一个矛盾。\n- 事实 (i)：证明谓词 $\\mathrm{Pr}_T$ 是原始递归的，并且在算术内部正确地表示了可证性。\n- 事实 (ii)：皮亚诺算术可以证明所有关于数码的真有界量词（$\\Delta_0$）事实。\n- 事实 (iii)：哥德尔第二不完备性定理：如果 $T$ 是一个相容的、足够强的、递归公理化的理论（例如，能够表示基本算术的 PA 的一个扩展），那么 $T \\nvdash \\mathrm{Con}(T)$。\n- 问题：哪个选项正确地给出了一个 PA 的递归公理化扩展的例子，该扩展是相容的但不是 $\\omega$-相容的，并准确解释了这个例子如何限制了哥德尔第一不完备性定理中的假设？\n\n#### 步骤 2：使用提取的已知条件进行验证\n问题陈述是数理逻辑中的一个标准练习，具体涉及算术基础和哥德尔不完备性定理。\n- **科学依据（关键）**：所有定义（递归公理化、相容、$\\omega$-相容、$\\mathrm{Pr}_T$、$\\mathrm{Con}(T)$）和引用的定理（哥德尔第二不完备性定理）在数理逻辑领域都是标准的且陈述准确。\n- **问题明确**：问题没有歧义，要求一种特定的逻辑构造及其解释，这是一个定义明确的任务。\n- **客观性（关键）**：语言形式化且精确，没有主观或非数学内容。\n该问题没有指令中列出的缺陷。它是可形式化的、相关的、完整的，并提出了一个在数学中非平凡且可验证的问题。\n\n#### 步骤 3：结论与行动\n问题有效。将推导完整解答。\n\n### 解答推导\n问题要求一个理论 $T$ 的例子，该理论是皮亚诺算术（PA）的一个递归公理化扩展，是相容的，但不是 $\\omega$-相容的。它还问到这个例子与哥德尔第一不完备性定理的相关性。让我们分析一下某些选项中提出的典型例子。\n\n考虑理论 $T = \\mathrm{PA} + \\neg \\mathrm{Con}(\\mathrm{PA})$。我们必须在 PA 本身是相容的标准假设下验证其性质。\n\n1.  **$T$ 是递归公理化的吗？**\n    PA 的公理集是递归公理化的（根据定义，可计算可枚举）。理论 $T$ 是通过向 PA 的公理中添加单个公理 $\\neg \\mathrm{Con}(\\mathrm{PA})$ 构成的。递归公理化理论的有限扩展仍然是递归公理化的。因此，$T$ 是递归公理化的。\n\n2.  **$T$ 是相容的吗？**\n    我们假设 PA 是一个相容的理论。哥德尔第二不完备性定理指出，对于任何这样的理论（相容的、递归公理化的且足够强的，PA 满足所有这些条件），$\\mathrm{PA} \\nvdash \\mathrm{Con}(\\mathrm{PA})$。这意味着语句 $\\mathrm{Con}(\\mathrm{PA})$ 不能从 PA 的公理中证明。\n    现在，考虑我们的理论 $T = \\mathrm{PA} + \\neg \\mathrm{Con}(\\mathrm{PA})$。如果 $T$ 是不相容的，那么从它的公理可以推导出一个矛盾。这将意味着 $\\mathrm{PA} \\cup \\{\\neg \\mathrm{Con}(\\mathrm{PA})\\} \\vdash 0=1$。根据演绎定理，这等价于 $\\mathrm{PA} \\vdash \\neg \\mathrm{Con}(\\mathrm{PA}) \\rightarrow 0=1$。根据经典逻辑，这等价于 $\\mathrm{PA} \\vdash \\mathrm{Con}(\\mathrm{PA})$。然而，这与哥德尔第二不完备性定理矛盾。因此，我们最初关于 $T$ 不相容的假设必定是错误的。所以，$T$ 是相容的。\n\n3.  **$T$ 是 $\\omega$-相容的吗？**\n    如果存在一个公式 $\\varphi(x)$，使得理论对每个自然数 $n$ 都证明了 $\\neg \\varphi(\\overline{n})$，但它也证明了 $\\exists x\\, \\varphi(x)$，那么该理论是 $\\omega$-不相容的。让我们根据这个定义来检验 $T$。\n    令公式为 $\\varphi(x) \\equiv \\mathrm{Pr}_{\\mathrm{PA}}(x, \\ulcorner 0=1 \\urcorner)$。这个公式表示“$x$ 是 PA 中 `0=1` 的一个证明的哥德尔数”。\n    - 根据其公理之一，$T$ 证明了 $\\neg \\mathrm{Con}(\\mathrm{PA})$。语句 $\\mathrm{Con}(\\mathrm{PA})$ 是形式化陈述 $\\forall x\\, \\neg \\mathrm{Pr}_{\\mathrm{PA}}(x, \\ulcorner 0=1 \\urcorner)$。因此，$\\neg \\mathrm{Con}(\\mathrm{PA})$ 在逻辑上等价于 $\\exists x\\, \\mathrm{Pr}_{\\mathrm{PA}}(x, \\ulcorner 0=1 \\urcorner)$。所以，我们有 $T \\vdash \\exists x\\, \\mathrm{Pr}_{\\mathrm{PA}}(x, \\ulcorner 0=1 \\urcorner)$。\n    - 现在考虑对于每个单独的数码 $\\overline{n}$（其中 $n \\in \\{0, 1, 2, ...\\}$）的陈述 $\\neg \\mathrm{Pr}_{\\mathrm{PA}}(\\overline{n}, \\ulcorner 0=1 \\urcorner)$。谓词 $\\mathrm{Pr}_{\\mathrm{PA}}(x,y)$ 是原始递归的。对于任何特定的数码 $\\overline{n}$ 和 $\\overline{m}$，陈述 $\\mathrm{Pr}_{\\mathrm{PA}}(\\overline{n}, \\overline{m})$ 是一个有界量词（$\\Delta_0$）的陈述，其真伪可以通过有限计算来检验。\n    - 由于我们假设 PA 是相容的，所以在 PA 中不存在矛盾的证明。因此，对于每个自然数 $n$，陈述“n 是 PA 中 $0=1$ 的一个证明的哥德尔数”是假的。\n    - 这意味着对于每个 $n \\in \\mathbb{N}$，算术语句 $\\neg \\mathrm{Pr}_{\\mathrm{PA}}(\\overline{n}, \\ulcorner 0=1 \\urcorner)$ 是一个真的 $\\Delta_0$（或者更准确地说，是一个 $\\Delta_0$ 的否定）语句。\n    - PA 的一个关键性质是它足够强，可以证明每个真的 $\\Sigma_1$ 语句，并由此可以证明每个真的 $\\Delta_0$ 语句，以及在其为假时证明其否定。在这种情况下，对于任何 $\\overline{n}$，$\\mathrm{Pr}_{\\mathrm{PA}}(\\overline{n}, \\ulcorner 0=1 \\urcorner)$ 都是假的，所以 PA 对每个自然数 $n$ 都证明了 $\\neg \\mathrm{Pr}_{\\mathrm{PA}}(\\overline{n}, \\ulcorner 0=1 \\urcorner)$。\n    - 由于 $T$ 是 PA 的一个扩展，所以 $T$ 对每个 $n \\in \\mathbb{N}$ 也证明了 $\\neg \\mathrm{Pr}_{\\mathrm{PA}}(\\overline{n}, \\ulcorner 0=1 \\urcorner)$。\n    - 总结如下：\n        $$ T \\vdash \\exists x\\, \\mathrm{Pr}_{\\mathrm{PA}}(x, \\ulcorner 0=1 \\urcorner) $$\n        $$ \\text{并且对于每个 } n \\in \\mathbb{N}, \\quad T \\vdash \\neg \\mathrm{Pr}_{\\mathrm{PA}}(\\overline{n}, \\ulcorner 0=1 \\urcorner) $$\n    这正是 $\\omega$-不相容理论的定义。因此，$T = \\mathrm{PA} + \\neg \\mathrm{Con}(\\mathrm{PA})$ 不是 $\\omega$-相容的。\n\n4.  **与哥德尔第一不完备性定理的相关性：**\n    第一不完备性定理的原始证明构造了一个语句 $G$（哥德尔语句），该语句断言其自身不可证。证明 $T \\nvdash G$ 仅需要 $T$ 的相容性。然而，证明 $T \\nvdash \\neg G$ 需要更强的 $\\omega$-相容性假设。这是因为 $\\neg G$ 等价于 $\\mathrm{Prov}_T(\\ulcorner G \\urcorner)$，这是一个 $\\Sigma_1$ 语句。如果 $T$ 是 $\\omega$-不相容的，它可能证明一个像 $\\exists x\\, \\varphi(x)$ 这样的 $\\Sigma_1$ 语句，即使它也对每个 $n$ 证明了 $\\neg \\varphi(\\overline{n})$。在我们的例子中，理论 $T = \\mathrm{PA} + \\neg \\mathrm{Con}(\\mathrm{PA})$ 是相容的但不是 $\\omega$-相容的。这个理论是一个可能在不导致不相容的情况下“侥幸”证明 $\\neg G$ 的例子。事实上，这样的理论可以证明在标准算术模型中为假的陈述。这个例子的存在表明，在哥德尔的原始定理表述中，$\\omega$-相容性的假设并非多余。J.B. Rosser 后来通过构造一个不同的不可判定语句（Rosser 语句）强化了该定理，该语句的不可判定性证明仅需要理论的简单相容性，从而使得 $\\omega$-相容性假设变得不必要。\n\n### 逐项分析\n\n**A. 取 $T = \\mathrm{PA} + \\neg \\mathrm{Con}(\\mathrm{PA})$。假设 $\\mathrm{PA}$ 是相容的，那么根据哥德尔第二不完备性定理的逆否命题，$T$ 是递归公理化且相容的：如果 $T$ 是不相容的，那么 $\\mathrm{PA} \\vdash \\mathrm{Con}(\\mathrm{PA})$，这与哥德尔第二定理矛盾。然而，$T$ 不是 $\\omega$-相容的，因为 $T \\vdash \\exists n\\, \\mathrm{Pr}_{\\mathrm{PA}}(n,\\ulcorner 0=1\\urcorner)$，而对于每个数码 $\\overline{k}$，$T$ 利用 PA 检查每个具体原始递归实例的能力证明了 $\\neg \\mathrm{Pr}_{\\mathrm{PA}}(\\overline{k},\\ulcorner 0=1\\urcorner)$。这表明哥德尔最初的第一不完备性定理关键性地使用了 $\\omega$-相容性来确保其哥德尔语句的不可判定性；如果没有 $\\omega$-相容性，该理论可能会反驳哥德尔语句。Rosser 的强化版本移除了对 $\\omega$-相容性的需求，仅在纯粹相容性的条件下建立了不完备性。**\n\n这个选项完美地呈现了标准例子 $T = \\mathrm{PA} + \\neg \\mathrm{Con}(\\mathrm{PA})$。其关于 $T$ 是递归公理化和相容的论证是正确的。其关于 $T$ 为何不是 $\\omega$-相容的解释是精确的，并与上述推导相符。最后，其关于这个例子在理解哥德尔第一不完备性定理的假设以及 Rosser 随后的改进中所起作用的解释是完全准确的。\n**结论：正确**\n\n**B. 取 $T = \\mathrm{PA} + \\neg \\mathrm{Con}(\\mathrm{PA})$。假设 $\\mathrm{PA}$ 是相容的，$T$ 是不相容的，因为它断言了其自身的不相容性。这表明哥德尔第一不完备性定理只需要相容性，因为 $\\omega$-相容性可以从相容性中得出。**\n\n这个选项包含多个严重错误。首先，如推导和选项 A 所示，如果 PA 相容，则 $T$ 相容。断言 $\\neg \\mathrm{Con}(\\mathrm{PA})$ 是一个关于 PA 的陈述，而不是关于 $T$ 本身的。$T$ 自身相容性的陈述将是 $\\mathrm{Con}(T)$，或 $\\mathrm{Con}(\\mathrm{PA} + \\neg \\mathrm{Con}(\\mathrm{PA}))$，这是一个不同且更复杂的公式。其次，声称 $\\omega$-相容性可以从相容性中得出是错误的。相容性是一个比 $\\omega$-相容性严格弱的性质，而理论 $T = \\mathrm{PA} + \\neg \\mathrm{Con}(\\mathrm{PA})$ 就是典型的反例。\n**结论：错误**\n\n**C. 取 $T = \\mathrm{PA} + \\mathrm{Con}(\\mathrm{PA})$。这个理论 $T$ 是递归公理化的且不是 $\\omega$-相容的，因为它断言了其自身的相容性，这违反了哥德尔第一不完备性定理。因此，即使在 $\\omega$-相容性的条件下，第一不完备性定理也不成立。**\n\n这个选项的概念非常混乱。理论 $T = \\mathrm{PA} + \\mathrm{Con}(\\mathrm{PA})$ 通常被认为是 $\\omega$-相容的（如果 PA 相容）。它没有提供一个 $\\omega$-不相容理论的例子。此外，断言相容性并不违反哥德尔的*第一*不完备性定理（该定理是关于不完备性的）；是哥德尔的*第二*不完备性定理说一个理论不能*证明*其自身的相容性。通过将 $\\mathrm{Con}(\\mathrm{PA})$ 作为公理加入，我们创建了一个新理论 $T$，它仍然是不完备的（它不能证明其自身的相容性，即 $\\mathrm{Con}(T)$）。最后的结论，即 G1 “即使在 $\\omega$-相容性的条件下也不成立”，直接与公认的数学事实相矛盾。\n**结论：错误**\n\n**D. 取 $T = \\mathrm{PA} + \\forall n\\, \\neg \\mathrm{Pr}_{\\mathrm{PA}}(n,\\ulcorner 0=1\\urcorner)$，也就是 $\\mathrm{PA} + \\mathrm{Con}(\\mathrm{PA})$。由于 $T$ 证明了不存在矛盾的编码，所以它是相容的但不是递归公理化的，这表明 $\\omega$-相容性在哥德尔第一不完备性定理中是不必要的。**\n\n这个选项开头正确地指出了理论是 $T = \\mathrm{PA} + \\mathrm{Con}(\\mathrm{PA})$，与 C 相同。然后它对这个理论做出了错误的断言。称 $T$ “不是递归公理化的”是错误的。作为 PA 的一个有限扩展，它是递归公理化的。“由于 $T$ 证明了不存在矛盾的编码，所以它是相容的”这一推理在逻辑上也是有缺陷的，尽管其结论（假设 PA 相容，$T$ 就是相容的）是正确的。最后的陈述，即 $\\omega$-相容性是不必要的，在这种情况下具有误导性；该例子本身对于证明它试图说明的观点是错误的。\n**结论：错误**", "answer": "$$\\boxed{A}$$", "id": "3044068"}]}