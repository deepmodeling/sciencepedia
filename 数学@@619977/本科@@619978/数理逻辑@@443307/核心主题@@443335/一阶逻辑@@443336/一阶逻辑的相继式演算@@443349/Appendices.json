{"hands_on_practices": [{"introduction": "掌握了矢列演算的基本规则后，首要的实践就是亲手构建一个证明。本练习 [@problem_id:3052306] 将引导你为一个命题逻辑中的重言式构建一个无切的（cut-free）证明，并挑战你寻找应用逻辑规则次数最少的证明路径。这不仅能巩固你对规则的理解，还能锻炼你进行策略性证明搜索的核心技能。", "problem": "在经典的一阶逻辑的 Gentzen 风格矢列演算（LK）中进行演算，并限制在其命题片段内。使用以下内容作为基本基础：对于任意公式 $A$ 的形如 $A \\vdash A$ 的初始（同一性）公理，结构规则（弱化、收缩、交换），以及命题联结词 $\\land$、$\\lor$、$\\to$ 和 $\\lnot$ 的标准左引入和右引入规则。不允许使用切断规则（仅限无切断证明）。在本问题中，您只需计算左侧或右侧的命题逻辑规则的应用次数（即 $\\land L$、$\\land R$、$\\lor L$、$\\lor R$、$\\to L$、$\\to R$、$\\lnot L$、$\\lnot R$）。不计算结构规则或初始公理。\n\n考虑矢列\n$$\\vdash \\left(((P \\to Q) \\land (Q \\to R)) \\land (R \\to S)\\right) \\to (P \\to S),$$\n其中 $P$、$Q$、$R$ 和 $S$ 是命题原子，$\\land$ 被解析为二元联结词，括号如式中所示。\n\n在该矢列的所有无切断 LK 证明中，确定从初始公理出发完成证明所需的最少命题逻辑规则（计算左引入和右引入）应用次数 $N$。请以单个整数形式提供您的最终答案。无需四舍五入。", "solution": "问题要求在无切断的 Gentzen 风格矢列演算（LK）中，证明矢列 $\\vdash \\left(((P \\to Q) \\land (Q \\to R)) \\land (R \\to S)\\right) \\to (P \\to S)$ 所需的命题逻辑规则应用的最小次数。\n\n首先，我们必须验证该问题。\n**步骤1：提取已知条件**\n- 演算：经典 Gentzen 风格矢列演算（LK），限制于其命题片段。\n- 公理：对于任意公式 $A$，为 $A \\vdash A$。\n- 结构规则：弱化、收缩、交换（不计数）。\n- 逻辑规则：$\\land, \\lor, \\to, \\lnot$ 的标准左/右引入规则。\n- 限制：无切断规则。\n- 计数的运算：仅命题逻辑规则的应用（$\\land L, \\land R, \\lor L, \\lor R, \\to L, \\to R, \\lnot L, \\lnot R$）。\n- 待证矢列：$\\vdash \\left(((P \\to Q) \\land (Q \\to R)) \\land (R \\to S)\\right) \\to (P \\to S)$。\n- 目标：找到计数的运算的最小次数 $N$。\n\n**步骤2：使用提取的已知条件进行验证**\n该问题在数理逻辑（特别是证明论）领域内是良定义的。所指定的演算、规则以及待证矢列都是标准的。该矢列是一个已知的重言式（蕴含传递性的一个实例）。在规则应用次数方面寻找最小证明是一个标准的证明论问题。该问题是自包含的、有科学依据的、客观的。没有矛盾、歧义或伪科学主张。\n\n**结论：该问题有效。**\n\n我们现在将通过从目标开始反向应用 LK 的规则来构造该矢列的证明。目标是找到一个使用最少逻辑规则应用次数的证明。证明是一棵树，其中每个节点都是一个矢列，根是待证矢列，叶是形如 $A \\vdash A$ 的初始公理。\n\n待证矢列为：\n$$ \\vdash \\left(((P \\to Q) \\land (Q \\to R)) \\land (R \\to S)\\right) \\to (P \\to S) $$\n主联结词是 $\\to$。唯一可以应用的规则是蕴含的右引入规则（$\\to R$），其形式为 $\\frac{\\Gamma, A \\vdash B, \\Delta}{\\Gamma \\vdash A \\to B, \\Delta}$。\n应用此规则是我们的第一次逻辑规则应用（$N=1$）。\n$$ \\frac{((P \\to Q) \\land (Q \\to R)) \\land (R \\to S) \\vdash P \\to S}{\\vdash \\left(((P \\to Q) \\land (Q \\to R)) \\land (R \\to S)\\right) \\to (P \\to S)} (\\to R) $$\n新的目标是此规则的前提。右侧的公式是 $P \\to S$。我们必须再次应用 $\\to R$ 规则。这是我们的第二次逻辑规则应用（$N=2$）。\n$$ \\frac{P, ((P \\to Q) \\land (Q \\to R)) \\land (R \\to S) \\vdash S}{((P \\to Q) \\land (Q \\to R)) \\land (R \\to S) \\vdash P \\to S} (\\to R) $$\n现在要证明的矢列是 $P, ((P \\to Q) \\land (Q \\to R)) \\land (R \\to S) \\vdash S$。要继续进行，我们必须分解左侧（前件）的复杂公式。主联结词是合取。我们应用合取的左引入规则（$\\land L$），即 $\\frac{\\Gamma, A, B \\vdash \\Delta}{\\Gamma, A \\land B \\vdash \\Delta}$。这算作我们的第三次逻辑规则应用（$N=3$）。\n$$ \\frac{P, (P \\to Q) \\land (Q \\to R), R \\to S \\vdash S}{P, ((P \\to Q) \\land (Q \\to R)) \\land (R \\to S) \\vdash S} (\\land L) $$\n我们在左侧还有另一个合取，$(P \\to Q) \\land (Q \\to R)$。我们再次应用 $\\land L$ 规则。这是我们的第四次逻辑规则应用（$N=4$）。\n$$ \\frac{P, P \\to Q, Q \\to R, R \\to S \\vdash S}{P, (P \\to Q) \\land (Q \\to R), R \\to S \\vdash S} (\\land L) $$\n当前的目标矢列是 $P, P \\to Q, Q \\to R, R \\to S \\vdash S$。至此，初始公式已被完全分解为一组前提。为了完成证明，我们必须证明 $S$ 可以从这些前提中推导出来。这需要使用蕴含式。我们必须应用蕴含的左引入规则（$\\to L$），其形式为 $\\frac{\\Gamma \\vdash A, \\Delta \\quad B, \\Gamma \\vdash \\Delta}{\\Gamma, A \\to B \\vdash \\Delta}$。这个规则将证明分为两个分支。为了得到一个最小证明，我们必须有策略地选择应用此规则的顺序。\n\n一个高效的策略是模拟从已知原子 $P$ 开始的正向链式推理。\n我们的前件中有 $P$。我们对公式 $P \\to Q$ 应用 $\\to L$ 规则。这是第五次逻辑规则应用（$N=5$）。\n$$ \\frac{P, Q \\to R, R \\to S \\vdash P, S \\quad (\\text{分支 1}) \\qquad Q, P, Q \\to R, R \\to S \\vdash S \\quad (\\text{分支 2})}{P, P \\to Q, Q \\to R, R \\to S \\vdash S} (\\to L) $$\n我们来分析这两个新分支：\n- **分支1：** $P, Q \\to R, R \\to S \\vdash P, S$。这是一个初始公理，因为公式 $P$ 同时出现在左侧和右侧。证明的这个分支无需更多逻辑规则即已完成。\n- **分支2：** $Q, P, Q \\to R, R \\to S \\vdash S$。现在必须证明这个矢列。我们的前件中现在有 $Q$。我们接着对链中的下一个蕴含式 $Q \\to R$ 应用 $\\to L$。这是我们的第六次逻辑规则应用（$N=6$）。\n$$ \\frac{Q, P, R \\to S \\vdash Q, S \\quad (\\text{分支 2a}) \\qquad R, Q, P, R \\to S \\vdash S \\quad (\\text{分支 2b})}{Q, P, Q \\to R, R \\to S \\vdash S} (\\to L) $$\n分析新的子分支：\n- **分支2a：** $Q, P, R \\to S \\vdash Q, S$。这是一个初始公理，因为 $Q$ 同时出现在两边。这个分支已完成。\n- **分支2b：** $R, Q, P, R \\to S \\vdash S$。这是我们的新目标。我们的前件中有 $R$。最后一步是使用最后一个蕴含式 $R \\to S$。我们应用 $\\to L$ 规则。这是我们的第七次也是最后一次逻辑规则应用（$N=7$）。\n$$ \\frac{R, Q, P \\vdash R, S \\quad (\\text{分支 2b-i}) \\qquad S, R, Q, P \\vdash S \\quad (\\text{分支 2b-ii})}{R, Q, P, R \\to S \\vdash S} (\\to L) $$\n分析这两个最后的分支：\n- **分支2b-i：** $R, Q, P \\vdash R, S$。这是一个初始公理，因为有 $R$。\n- **分支2b-ii：** $S, R, Q, P \\vdash S$。这是一个初始公理，因为有 $S$。\n\n证明的所有分支都终止于初始公理。所应用的逻辑规则总数为 $7$。\n\n为确认这是最小数目，我们论证每一步的必要性：\n1.  两次应用 $\\to R$ 是不可避免的，因为需要分解后件中嵌套的蕴含结构。\n2.  两次应用 $\\land L$ 是不可避免的，因为需要分解前件中嵌套的合取结构。\n3.  这将我们引至矢列 $P, P \\to Q, Q \\to R, R \\to S \\vdash S$。为了从前提 $P$ 证明 $S$，证明必须逻辑上遍历蕴含链 $P \\to Q$、$Q \\to R$ 和 $R \\to S$。在无切断的 LK 中，每个这样的遍历步骤（等同于一次分离规则的应用）主要通过 $\\to L$ 规则来完成。三个蕴含式中的每一个都必须通过一次 $\\to L$ 的应用来“激活”，以便将 $P$ 与 $S$ 连接起来。因此，至少需要三次 $\\to L$ 的应用。\n\n逻辑规则应用的最小总次数是这些必要步骤的总和：$2 (\\to R) + 2 (\\land L) + 3 (\\to L) = 7$。\n所构造的证明达到了这个下界。因此，最小应用次数为 $7$。", "answer": "$$\n\\boxed{7}\n$$", "id": "3052306"}, {"introduction": "切削规则（cut rule）虽然在推导中非常强大，但其存在使得证明的自动搜索和性质分析变得复杂。切削消去定理（Cut-Elimination Theorem）是证明论的基石之一，它保证了任何有切的证明都可以转化为无切的证明。通过这个练习 [@problem_id:3052309]，你将不再是抽象地理解该定理，而是通过追踪一个具体切削公式的逐步“消解”过程并量化其复杂度 $|\\varphi|$ 的变化，来具体地感受这个核心过程。", "problem": "考虑经典的一阶矢列演算，它包含联结词 $\\land$、$\\lor$、$\\to$、$\\neg$ 和量词 $\\forall$、$\\exists$ 的常规结构规则和逻辑规则。$\\mathsf{cut}$ 规则是一条推理规则，它从矢列 $\\Gamma \\vdash \\Delta, \\chi$ 和 $\\Gamma', \\chi \\vdash \\Delta'$ 推导出矢列 $\\Gamma, \\Gamma' \\vdash \\Delta, \\Delta'$，这是通过对公式 $\\chi$ 进行切割实现的。公式 $\\varphi$ 的秩（rank） $|\\varphi|$ 递归定义如下：对于任意原子公式 $P(t_{1}, \\dots, t_{n})$，其秩为 $|P(t_{1}, \\dots, t_{n})| = 1$；对于否定，其秩为 $|\\neg \\alpha| = 1 + |\\alpha|$；对于二元联结词 $\\circ \\in \\{\\land, \\lor, \\to\\}$，其秩为 $|\\alpha \\circ \\beta| = 1 + |\\alpha| + |\\beta|$；对于量词，其秩为 $|\\forall x\\, \\alpha| = 1 + |\\alpha|$ 和 $|\\exists x\\, \\alpha| = 1 + |\\alpha|$。一个推导的切割秩（cut-rank）是在该推导中出现的所有切割公式 $\\chi$ 的最大秩 $|\\chi|$。\n\n假设在此矢列演算中，一个推导有且仅有一个 $\\mathsf{cut}$，其切割公式为\n$$\\forall x\\,\\big(P(x) \\land (\\neg Q \\lor R)\\big),$$\n其中 $P$、$Q$ 和 $R$ 是原子公式。考虑执行由切割消除定理所保证的标准切割消减步骤：首先，通过用一个自由变量 $t$ 替换 $x$，将对全称量词的切割消减为对一个特定实例的切割；然后，通过将合取项分开，将对合取的切割消减为对两个合取项的两个切割。仅使用上述定义以及“当切割公式的主联结词或量词被分解时，每个消减步骤都会严格减小切割秩的度量”这一事实，计算经过这两个消减步骤后所得推导的最大切割秩。\n\n你的最终答案必须是一个精确书写的整数，不得进行近似或四舍五入。答案不带任何单位。不要对任何数值进行四舍五入，并给出确切的值。", "solution": "该问题要求计算一个矢列演算推导在执行了两个特定的切割消减步骤之后的最大切割秩。\n\n首先，对给定的问题陈述进行验证。该问题位于一阶矢列演算和证明论的标准框架内。它为公式的秩提供了清晰、明确且自洽的定义，并描述了切割消减的标准程序。问题是形式化的、客观的且定义良好的，要求根据给定的初始条件和规则推导出一个特定的值。其中没有矛盾、歧义或科学上的不准确之处。因此，该问题被认定为有效。\n\n解决方案的步骤是跟踪切割公式的变换，并计算每个阶段的秩。\n\n**步骤 1：分析初始状态**\n\n初始推导包含对公式 $\\chi$ 的单个 $\\mathsf{cut}$：\n$$ \\chi = \\forall x\\,\\big(P(x) \\land (\\neg Q \\lor R)\\big) $$\n这个初始推导的切割秩是 $\\chi$ 的秩，记为 $|\\chi|$。我们使用提供的递归定义来计算这个秩。问题陈述 $P$、$Q$ 和 $R$ 是原子公式。对于任意项 $t$，原子成分的秩为 $|P(t)| = 1$、 $|Q| = 1$ 和 $|R| = 1$。\n\n我们从其子公式开始向上计算 $\\chi$ 的秩：\n- 否定公式 $\\neg Q$ 的秩为 $|\\neg Q| = 1 + |Q| = 1 + 1 = 2$。\n- 析取式 $\\neg Q \\lor R$ 的秩为 $|\\neg Q \\lor R| = 1 + |\\neg Q| + |R| = 1 + 2 + 1 = 4$。\n- 对于任意变量 $x$，量词内合取式的秩为 $|P(x) \\land (\\neg Q \\lor R)| = 1 + |P(x)| + |\\neg Q \\lor R| = 1 + 1 + 4 = 6$。\n- 最后，初始切割公式 $\\chi$ 的秩为 $|\\chi| = |\\forall x\\,\\big(P(x) \\land (\\neg Q \\lor R)\\big)| = 1 + |P(x) \\land (\\neg Q \\lor R)| = 1 + 6 = 7$。\n\n所以，推导的初始切割秩为 $7$。\n\n**步骤 2：对全称量词的第一步消减**\n\n如前所述，第一步消减处理的是 $\\chi$ 的主联结词，即全称量词 $\\forall x$。对于一个主 $\\forall$-切割，标准的切割消除程序是将对 $\\forall x\\, A(x)$ 的切割替换为对一个特定实例 $A(t)$ 的切割，其中 $t$ 是一个项（在本例中，被描述为一个自由变量）。这严格地降低了切割公式的复杂性。\n\n对 $\\chi = \\forall x\\,\\big(P(x) \\land (\\neg Q \\lor R)\\big)$ 的切割被替换为对新公式 $\\chi_1$ 的一个新切割：\n$$ \\chi_1 = P(t) \\land (\\neg Q \\lor R) $$\n这个新切割公式的秩是 $|\\chi_1|$。根据我们之前的计算，这个秩是 $|\\chi_1| = |P(t) \\land (\\neg Q \\lor R)| = 6$。此步骤后，推导中有一个秩为 $6$ 的切割。推导的最大切割秩现在是 $6$。\n\n**步骤 3：对合取的第二步消减**\n\n第二步消减处理的是新切割公式 $\\chi_1$ 的主联结词，即合取 $\\land$。问题指明此消减将一个切割分解为“对两个合取项的两个切割”。这对应于标准的消减步骤，即对公式 $A \\land B$ 的切割被一个更复杂的推导结构所取代，该结构涉及一个对公式 $A$ 的切割和另一个对公式 $B$ 的切割。\n\n因此，对 $\\chi_1 = P(t) \\land (\\neg Q \\lor R)$ 的切割被消除，并被两个新的切割所取代。这两个切割的公式是 $\\chi_1$ 的合取项：\n- 第一个新切割公式是 $\\chi_2 = P(t)$。\n- 第二个新切割公式是 $\\chi_3 = \\neg Q \\lor R$。\n\n**步骤 4：计算最终的最大切割秩**\n\n最终的推导不再包含对 $\\chi$ 或 $\\chi_1$ 的切割。取而代之的是，它包含对 $\\chi_2$ 和 $\\chi_3$ 的两个切割。这个最终推导的切割秩是其中存在的所有切割公式的秩的最大值。我们必须计算 $\\chi_2$ 和 $\\chi_3$ 的秩。\n- $\\chi_2 = P(t)$ 的秩是 $|\\chi_2| = |P(t)| = 1$，因为 $P$ 是一个原子公式。\n- $\\chi_3 = \\neg Q \\lor R$ 的秩是 $|\\chi_3| = |\\neg Q \\lor R| = 4$，如步骤 1 中所计算。\n\n所得推导中切割公式的秩的集合是 $\\{1, 4\\}$。最大切割秩是此集合中的最大值。\n$$ \\text{最大切割秩} = \\max(|\\chi_2|, |\\chi_3|) = \\max(1, 4) = 4 $$\n每个消减步骤都严格减小了被切割公式的秩（$|\\chi_1| = 6  |\\chi| = 7$，以及 $|\\chi_2| = 1  |\\chi_1| = 6$ 和 $|\\chi_3| = 4  |\\chi_1| = 6$），这与切割消除定理是一致的。所得推导的最大切割秩由新切割公式中最复杂的公式决定，即秩为 $4$ 的 $\\chi_3$。", "answer": "$$\\boxed{4}$$", "id": "3052309"}, {"introduction": "矢列演算不仅是分析单一逻辑系统的工具，也是连接不同逻辑系统的桥梁。哥德尔-根岑负翻译（Gödel–Gentzen negative translation）是探索经典逻辑（LK）和直觉主义逻辑（LJ）之间关系的标准方法。这个练习 [@problem_id:3052311] 要求你系统地应用这种翻译，并通过计算一个特定公式族在翻译后否定符号 $\\neg$ 的数量，来精确地理解两种逻辑在句法层面上的差异。", "problem": "考虑通过哥德尔-根岑负翻译将经典矢列演算（LK）嵌入到直觉主义矢列演算（LJ）中，这是一种用于展示经典可证性与直觉主义可证性之间差异的标准工具。我们在一个一阶语言中进行演算，该语言包含谓词符号 $P_{i}$、联结词 $\\land$、$\\lor$、$\\to$、谬 $\\bot$ 以及量词 $\\forall$、$\\exists$。在翻译的目标中，将 $\\neg \\varphi$ 写为原始符号，但在与直觉主义推理相关联时，将 $\\neg \\varphi$ 理解为 $\\varphi \\to \\bot$ 的缩写。\n\n将哥德尔-根岑负翻译 $N(\\cdot)$ 在一阶公式上归纳定义如下：\n- 对于原子公式 $A$，有 $N(A) := \\neg \\neg A$。\n- $N(\\bot) := \\bot$。\n- $N(\\varphi \\land \\psi) := N(\\varphi) \\land N(\\psi)$。\n- $N(\\varphi \\lor \\psi) := \\neg \\neg \\bigl(N(\\varphi) \\lor N(\\psi)\\bigr)$。\n- $N(\\varphi \\to \\psi) := N(\\varphi) \\to N(\\psi)$。\n- $N(\\forall x\\,\\varphi) := \\forall x\\, N(\\varphi)$。\n- $N(\\exists x\\,\\varphi) := \\neg \\neg \\exists x\\, N(\\varphi)$。\n\n对于一个固定的正整数 $n$，考虑以下经典公式\n$$\n\\varphi_{n} \\;:=\\; \\bigwedge_{i=1}^{n} \\exists x_{i}\\,\\Bigl( P_{i}(x_{i}) \\;\\lor\\; \\forall y\\,\\bigl(P_{i}(y)\\to \\bot\\bigr) \\Bigr).\n$$\n\n当使用上述归纳定义展开 $N(\\varphi_{n})$ 时，计算结果公式中否定符号 $\\neg$ 的总出现次数，其中 $\\neg$ 的每次出现都单独计数。请用一个关于 $n$ 的封闭形式解析表达式来表示你的最终答案。无需四舍五入，也不涉及单位。你的答案必须是单个表达式。", "solution": "用户提供了一个在数理逻辑中定义明确的问题。任务是将哥德尔-根岑负翻译应用于一个给定的一阶公式，并计算结果表达式中否定符号的数量。所有定义都是精确的，问题是自包含的。因此，该问题是有效的，我将着手提供一个完整的解答。\n\n设 $\\mathcal{C}(\\phi)$ 是一个函数，用于计算翻译后的公式 $N(\\phi)$ 中否定符号 $\\neg$ 的总出现次数。根据翻译 $N(\\cdot)$ 的归纳定义，我们可以为 $\\mathcal{C}(\\phi)$ 建立一组递推关系：\n\\begin{itemize}\n    \\item 对于原子公式 $A$，$N(A) = \\neg \\neg A$。因此，$\\mathcal{C}(A) = 2$。\n    \\item $N(\\bot) = \\bot$。因此，$\\mathcal{C}(\\bot) = 0$。\n    \\item $N(\\varphi \\land \\psi) = N(\\varphi) \\land N(\\psi)$。否定符号的数量是相加的。因此，$\\mathcal{C}(\\varphi \\land \\psi) = \\mathcal{C}(\\varphi) + \\mathcal{C}(\\psi)$。\n    \\item $N(\\varphi \\lor \\psi) = \\neg \\neg (N(\\varphi) \\lor N(\\psi))$。这在子公式的否定符号之外引入了两个新的否定符号。因此，$\\mathcal{C}(\\varphi \\lor \\psi) = 2 + \\mathcal{C}(\\varphi) + \\mathcal{C}(\\psi)$。\n    \\item $N(\\varphi \\to \\psi) = N(\\varphi) \\to N(\\psi)$。否定符号的数量是相加的。因此，$\\mathcal{C}(\\varphi \\to \\psi) = \\mathcal{C}(\\varphi) + \\mathcal{C}(\\psi)$。\n    \\item $N(\\forall x\\,\\varphi) = \\forall x\\, N(\\varphi)$。量词不增加否定符号。因此，$\\mathcal{C}(\\forall x\\,\\varphi) = \\mathcal{C}(\\varphi)$。\n    \\item $N(\\exists x\\,\\varphi) = \\neg \\neg \\exists x\\, N(\\varphi)$。这引入了两个新的否定符号。因此，$\\mathcal{C}(\\exists x\\,\\varphi) = 2 + \\mathcal{C}(\\varphi)$。\n\\end{itemize}\n\n待分析的公式为 $\\varphi_{n} \\;:=\\; \\bigwedge_{i=1}^{n} \\psi_i$，其中每个子公式 $\\psi_i$ 由下式给出\n$$\n\\psi_i \\;:=\\; \\exists x_{i}\\,\\Bigl( P_{i}(x_{i}) \\;\\lor\\; \\forall y\\,\\bigl(P_{i}(y)\\to \\bot\\bigr) \\Bigr).\n$$\n使用合取规则， $N(\\varphi_n)$ 中否定符号的总数是每个翻译后合取项计数的总和：\n$$\n\\mathcal{C}(\\varphi_n) = \\mathcal{C}\\left(\\bigwedge_{i=1}^{n} \\psi_i\\right) = \\sum_{i=1}^{n} \\mathcal{C}(\\psi_i).\n$$\n每个公式 $\\psi_i$ 的结构都是相同的，涉及一个唯一的谓词 $P_i$ 和一个约束变量 $x_i$，但否定符号的计数规则与具体的谓词名称或变量名称无关。因此，对于所有从 $1$ 到 $n$ 的 $i$，$\\mathcal{C}(\\psi_i)$ 的值是恒定的。设这个恒定值为 $C$。那么总计数为 $\\mathcal{C}(\\varphi_n) = nC$。\n\n我们的任务简化为计算任意单个实例 $i$ 的 $C = \\mathcal{C}(\\psi_i)$ 的值。为清晰起见，我们省略下标 $i$ 并为以下公式计算 $\\mathcal{C}(\\psi)$\n$$\n\\psi \\;:=\\; \\exists x\\,\\Bigl( P(x) \\;\\lor\\; \\forall y\\,\\bigl(P(y)\\to \\bot\\bigr) \\Bigr).\n$$\n我们从最外层的算子向内系统地应用递推关系。\n\n设 $\\theta(x) := P(x) \\lor \\forall y\\,\\bigl(P(y)\\to \\bot\\bigr)$。那么 $\\psi = \\exists x\\,\\theta(x)$。\n应用存在量词的规则：\n$$\n\\mathcal{C}(\\psi) = \\mathcal{C}(\\exists x\\,\\theta(x)) = 2 + \\mathcal{C}(\\theta(x)).\n$$\n接下来，我们确定 $\\mathcal{C}(\\theta(x))$。设 $\\sigma := \\forall y\\,\\bigl(P(y)\\to \\bot\\bigr)$。那么 $\\theta(x) = P(x) \\lor \\sigma$。\n应用析取规则：\n$$\n\\mathcal{C}(\\theta(x)) = \\mathcal{C}(P(x) \\lor \\sigma) = 2 + \\mathcal{C}(P(x)) + \\mathcal{C}(\\sigma).\n$$\n这里，$P(x)$ 是一个原子公式。根据我们的规则，$\\mathcal{C}(P(x)) = 2$。\n所以，我们有 $\\mathcal{C}(\\theta(x)) = 2 + 2 + \\mathcal{C}(\\sigma) = 4 + \\mathcal{C}(\\sigma)$。\n\n现在，我们必须找到 $\\mathcal{C}(\\sigma)$。设 $\\rho(y) := P(y)\\to \\bot$。那么 $\\sigma = \\forall y\\,\\rho(y)$。\n应用全称量词的规则：\n$$\n\\mathcal{C}(\\sigma) = \\mathcal{C}(\\forall y\\,\\rho(y)) = \\mathcal{C}(\\rho(y)).\n$$\n最后，我们计算 $\\mathcal{C}(\\rho(y))$。该公式为 $\\rho(y) = P(y)\\to \\bot$。\n应用蕴含规则：\n$$\n\\mathcal{C}(\\rho(y)) = \\mathcal{C}(P(y) \\to \\bot) = \\mathcal{C}(P(y)) + \\mathcal{C}(\\bot).\n$$\n$P(y)$ 是一个原子公式，所以 $\\mathcal{C}(P(y)) = 2$。\n公式 $\\bot$ 是一个基本情况，所以 $\\mathcal{C}(\\bot) = 0$。\n因此，$\\mathcal{C}(\\rho(y)) = 2 + 0 = 2$。\n\n现在，我们将结果代回到计算链中：\n\\begin{enumerate}\n    \\item $\\mathcal{C}(\\sigma) = \\mathcal{C}(\\rho(y)) = 2$。\n    \\item $\\mathcal{C}(\\theta(x)) = 4 + \\mathcal{C}(\\sigma) = 4 + 2 = 6$。\n    \\item $\\mathcal{C}(\\psi) = 2 + \\mathcal{C}(\\theta(x)) = 2 + 6 = 8$。\n\\end{enumerate}\n所以，每个子公式 $\\psi_i$ 的否定符号计数常数为 $C=8$。\n\n$N(\\varphi_n)$ 中否定符号的总数是 $n$ 个子公式的计数总和：\n$$\n\\mathcal{C}(\\varphi_n) = \\sum_{i=1}^{n} \\mathcal{C}(\\psi_i) = \\sum_{i=1}^{n} 8 = 8n.\n$$\n否定符号的总出现次数是 $8n$。", "answer": "$$\n\\boxed{8n}\n$$", "id": "3052311"}]}