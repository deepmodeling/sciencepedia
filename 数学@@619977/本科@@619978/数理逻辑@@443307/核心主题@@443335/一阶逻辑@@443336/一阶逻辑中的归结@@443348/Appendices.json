{"hands_on_practices": [{"introduction": "归结原理在一阶逻辑中的应用，要求逻辑语句必须首先被转换成一种称为“子句范式”（Clausal Form）的标准化格式。这个练习将引导你完成将一个标准的一阶逻辑语句转换为子句范式的完整流程，这是任何基于归结的自动定理证明系统的关键预处理步骤。通过这个实践，你将掌握包括消除蕴含、斯科伦化（Skolemization）和转换为合取范式（CNF）在内的一系列核心技术。[@problem_id:3050816]", "problem": "设 $\\Phi$ 为一阶逻辑 (FOL) 中的一阶句子，其表达式为\n$$\n\\forall x\\,\\exists y\\,\\big(R(x,y)\\,\\land\\,\\forall z\\,(R(y,z)\\rightarrow R(x,z))\\big).\n$$\n从一阶逻辑的基本等价变换（蕴含消除、使用量词定律移至前束范式，以及 Skolem 化，即将每个存在量词量化的变量替换为一个 Skolem 函数，该函数的参数为所有在其作用域内的全称量词量化的变量）出发，对 $\\Phi$ 执行完整的子句转换，将其化为合取范式 (CNF)。这包括按顺序执行以下步骤：消除蕴含、内移否定、生成前束范式、变量标准化、使用具有正确依赖关系的 Skolem 符号对存在量词进行 Skolem 化、去掉全称量词、分配以转换为合取范式，最后形成子句集，其中子句间的变量是标准化的，并且移除了重复的文字和重言式子句。\n\n计算最终子句集中不同子句的总数。以单个整数形式给出最终答案。", "solution": "问题要求对给定的一阶逻辑 (FOL) 句子 $\\Phi$ 进行子句转换，并确定结果集中的子句数量。这个问题是适定的，并且基于数理逻辑的原理。我将按照指定的转换步骤序列来解答。\n\n初始的 FOL 句子是：\n$$ \\Phi \\equiv \\forall x\\,\\exists y\\,\\big(R(x,y)\\,\\land\\,\\forall z\\,(R(y,z)\\rightarrow R(x,z))\\big) $$\n\n第一步是消除蕴含。子公式 $R(y,z)\\rightarrow R(x,z)$ 使用等价式 $A \\rightarrow B \\equiv \\neg A \\lor B$ 进行转换。应用该变换后，句子变为：\n$$ \\Phi_1 \\equiv \\forall x\\,\\exists y\\,\\big(R(x,y)\\,\\land\\,\\forall z\\,(\\neg R(y,z)\\lor R(x,z))\\big) $$\n\n第二步是内移否定。在 $\\Phi_1$ 中，唯一的否定符号 $\\neg$ 已经直接作用于原子公式 $R(y,z)$。因此，此步骤无需更改。\n\n第三步是将公式转换为前束范式，即所有量词都在最前面。在 $\\Phi_1$ 中，量词 $\\forall z$ 位于合取式的作用域内。变量 $z$ 在第一个合取项 $R(x,y)$ 中不是自由变量。因此，我们可以使用等价式 $P \\land (\\forall z\\,Q(z)) \\equiv \\forall z\\,(P \\land Q(z))$（其中 $z$ 在 $P$ 中不是自由变量）将量词 $\\forall z$ 外移。应用该变换后得到：\n$$ \\Phi_2 \\equiv \\forall x\\,\\exists y\\,\\forall z\\,\\big(R(x,y)\\,\\land\\,(\\neg R(y,z)\\lor R(x,z))\\big) $$\n该公式现在是前束范式。\n\n第四步是变量标准化。在 $\\Phi_2$ 中，每个量词（$\\forall x$, $\\exists y$, $\\forall z$）都约束一个唯一的变量名。在此阶段无需重命名。\n\n第五步是 Skolem 化，该步骤消除存在量词。句子 $\\Phi_2$ 有一个存在量词 $\\exists y$。变量 $y$ 处于全称量词 $\\forall x$ 的作用域内。因此，我们用一个关于 $x$ 的 Skolem 函数替换 $y$。设该函数用符号 $f$ 表示。我们将所有出现的 $y$ 替换为 $f(x)$，并去掉量词 $\\exists y$。得到的公式为：\n$$ \\Phi_3 \\equiv \\forall x\\,\\forall z\\,\\big(R(x,f(x))\\,\\land\\,(\\neg R(f(x),z)\\lor R(x,z))\\big) $$\n\n第六步是去掉所有全称量词。现在变量 $x$ 和 $z$ 被认为是隐式全称量化的。这给我们留下了无量词的矩阵：\n$$ M \\equiv R(x,f(x))\\,\\land\\,(\\neg R(f(x),z)\\lor R(x,z)) $$\n\n第七步是将矩阵 $M$ 转换为合取范式 (CNF)。公式 $M$ 已经是 CNF，因为它是一个由两个子句组成的合取式。第一个子句是文字 $R(x,f(x))$，第二个子句是两个文字的析取 $\\neg R(f(x),z)\\lor R(x,z)$。无需进一步的分配。\n\n第八步是形成子句集。从 CNF 公式 $M$ 中，我们提取子句。子句集为：\n$$ S = \\{ \\{R(x,f(x))\\}, \\{\\neg R(f(x),z), R(x,z)\\} \\} $$\n在子句集中，不同子句中的变量是相互独立的。为清晰起见，我们可以认为第一个子句中的 $x$ 和第二个子句中的 $x$ 是不同的变量。\n\n第九步是检查重复文字和重言式。\n- 第一个子句 $\\{R(x,f(x))\\}$ 只包含一个文字，不是重言式。\n- 第二个子句 $\\{\\neg R(f(x),z), R(x,z)\\}$ 由两个不同的文字组成。它不是重言式，因为一个子句是重言式当且仅当它包含一个文字及其精确的补（例如，$L$ 和 $\\neg L$）。在这里，文字是 $\\neg R(f(x),z)$ 和 $R(x,z)$，它们不是彼此的补，因为它们的参数不同。\n因此，子句集已经是其最终的简化形式。\n\n最后一步是计算所得集合 $S$ 中不同子句的总数。该集合包含两个不同的子句：\n1. $C_1 = \\{R(x,f(x))\\}$\n2. $C_2 = \\{\\neg R(f(x),z), R(x,z)\\}$\n因此，子句的总数是 $2$。", "answer": "$$\n\\boxed{2}\n$$", "id": "3050816"}, {"introduction": "一阶逻辑归结与命题逻辑归结的核心区别在于“合一”（Unification）机制，它使得我们能够处理带有变量的项。这个练习将该关键步骤独立出来，让你判断两个给定的项是否可以被合一，即通过变量替换使它们变得在语法上完全相同。这个过程将特别突出一个常见的陷阱——“出现检查”（occurs check），它是防止产生无限循环定义从而保证算法正确终止的重要规则。[@problem_id:3050868]", "problem": "在一阶逻辑中，当存在函数符号和变量时，归结（resolution）依赖于对项进行合一（unify）的能力。合一试图找到一个代换（substitution），使得两个项在句法上完全相同，同时需要满足出现检查（occurs check），该检查禁止将一个变量赋值给一个包含该变量自身的项。考虑在一门语言上的项集合 $\\{f(x,x), f(g(y), y)\\}$，该语言包含一元函数符号 $g$ 和二元函数符号 $f$，以及变量 $x$ 和 $y$。请通过系统地尝试求解其对应子项所导出的方程，并识别任何违反出现检查的情况，来确定这两个项在出现检查的约束下是否可合一。如果它们是可合一的，请以集合表示法 $\\{x \\mapsto t_{x}, y \\mapsto t_{y}\\}$ 的形式，提供一个单一的最概括合一（Most General Unifier, MGU）。如果它们在出现检查下不可合一，则你的最终答案必须是空集 $\\varnothing$，表示合一子的集合为空。最终答案必须是单个符号数学表达式。", "solution": "该问题要求确定项 $f(x,x)$ 和 $f(g(y), y)$ 在满足出现检查的条件下是否可合一。合一（Unification）是寻找一个变量的代换，使得两个逻辑表达式在句法上完全相同的过程。如果存在这样的代换，这些项就是可合一的；否则，它们就不是。最概括合一（MGU）是一个比任何其他合一子都更具一般性的代换。\n\n我们首先在两个项之间建立一个方程：\n$$f(x,x) = f(g(y), y)$$\n\n合一算法通过分解初始方程来进行。由于两边最外层的函数符号相同（都是 $f$），我们可以使其各自的参数相等。这产生了一组包含两个联立方程的方程组：\n1. $$x = g(y)$$\n2. $$x = y$$\n\n必须求解这个方程组 $\\{x = g(y), x = y\\}$ 以找到一个一致的代换。我们可以尝试通过将一个方程代入另一个方程来解这个方程组。\n\n我们使用第二个方程 $x = y$。这个方程建议一个代换，即用 $y$ 替换 $x$ 或用 $x$ 替换 $y$。我们选择代换 $\\sigma_1 = \\{x \\mapsto y\\}$。我们将此代换应用于第一个方程 $x = g(y)$。\n\n将 $\\sigma_1$ 应用于第一个方程的左侧 $x$，得到 $y$。\n将 $\\sigma_1$ 应用于右侧 $g(y)$，得到 $g(y)$（因为变量 $x$ 未出现）。\n\n这将第一个方程转换为：\n$$y = g(y)$$\n\n现在我们有一个新的方程需要求解。根据合一的规则，形式为 $V = T$ 的方程（其中 $V$ 是一个变量，$T$ 是一个项）可以通过代换 $\\{V \\mapsto T\\}$ 来解决。然而，只有当变量 $V$ 不出现在项 $T$ 中时，这才是允许的。这个条件被称为**出现检查**（occurs check）。\n\n在我们推导出的方程 $y = g(y)$ 中，要被代换的变量是 $y$，而项是 $g(y)$。我们必须执行出现检查：变量 $y$ 是否出现在项 $g(y)$ 中？是的，它很明显出现在其中。\n\n代换 $\\{y \\mapsto g(y)\\}$ 会导致无限回归。用 $g(y)$ 代换 $y$ 将得到 $g(y) = g(g(y))$，再次应用代换后又会简化为 $y = g(y)$，如此循环往复。这代表试图将一个变量与一个包含该变量自身的项进行合一，从而产生一个无限项，这在标准一阶逻辑中是不允许的。\n\n因为变量 $y$ 出现在项 $g(y)$ 中，所以出现检查失败。在这一步出现检查的失败意味着不存在任何有限的代换可以使原始方程组保持一致。\n\n因此，合一过程以失败告终。项 $f(x,x)$ 和 $f(g(y), y)$ 是不可合一的。因此，合一子的集合是空集。", "answer": "$$\\boxed{\\varnothing}$$", "id": "3050868"}, {"introduction": "掌握了如何将公式转换为子句范式以及如何合一项之后，就该将所有知识融会贯通，进行一次完整的证明了。这个练习要求你从一个给定的子句集出发，通过反复应用归结和合一，最终推导出矛盾（即空子句）。这个过程完整地展示了归结作为一阶逻辑完备反驳系统的强大能力，是理解自动推理过程的经典实践。[@problem_id:3050890]", "problem": "设 $\\mathcal{L}$ 为一个一阶语言，其包含一个常量符号 $a$、一个一元函数符号 $f$ 和一个一元谓词符号 $P$。考虑以下子句形式的子句集：\n- $C_{1}: P(a)$，\n- $C_{2}: \\lnot P(x) \\lor P(f(x))$，\n- $C_{3}: \\lnot P(f(f(a)))$。\n\n任务：\n1. 使用带标准合一的一阶归结规则，构造一个完整的归结反驳，从 $\\{C_{1}, C_{2}, C_{3}\\}$ 推导出空子句 $\\Box$。\n2. 定义一个二元归结推理为在两个子句之间对恰好一对互补文字进行归结以生成它们的归结式（不允许使用因子分解、等价代换或其他推理规则）。仅将此类二元归结推理计为步骤。反驳 $\\{C_{1}, C_{2}, C_{3}\\}$ 所需的最小二元归结推理次数是多少？\n\n请从子句、合一和归结规则的第一性原理出发，给出你的推理过程。最终答案必须是给出最小二元归结推理次数的单个整数。无需四舍五入。", "solution": "我们旨在从给定的子句集 $\\{C_1, C_2, C_3\\}$ 中推导出空子句 $\\Box$，并找到所需的最少归结步骤数。\n\n给定的子句是：\n- $C_1: \\{P(a)\\}$\n- $C_2: \\{\\lnot P(x) \\lor P(f(x))\\}$\n- $C_3: \\{\\lnot P(f(f(a)))\\}$\n\n归结反驳的构造如下：\n\n**步骤 1:** 对 $C_1$ 和 $C_2$ 进行归结。\n- 父子句 1: $C_1 = \\{P(a)\\}$\n- 父子句 2: $C_2 = \\{\\lnot P(x) \\lor P(f(x))\\}$\n- 为了归结，我们需要合一原子 $P(a)$ 和 $P(x)$。\n- 最一般合一子 (MGU) 是 $\\theta_1 = \\{x \\mapsto a\\}$。\n- 将 $\\theta_1$ 应用于 $C_2$ 的其余部分 $P(f(x))$，我们得到归结式：\n- $C_4 = \\{P(f(a))\\}$\n\n**步骤 2:** 对新生成的子句 $C_4$ 和 $C_2$ 进行归结。\n- 父子句 1: $C_4 = \\{P(f(a))\\}$\n- 父子句 2: $C_2 = \\{\\lnot P(y) \\lor P(f(y))\\}$ (为避免混淆，将变量 $x$ 重命名为 $y$)\n- 我们合一原子 $P(f(a))$ 和 $P(y)$。\n- 最一般合一子 (MGU) 是 $\\theta_2 = \\{y \\mapsto f(a)\\}$。\n- 将 $\\theta_2$ 应用于 $C_2$ 的其余部分 $P(f(y))$，我们得到归结式：\n- $C_5 = \\{P(f(f(a)))\\}$\n\n**步骤 3:** 对 $C_5$ 和 $C_3$ 进行归结。\n- 父子句 1: $C_5 = \\{P(f(f(a)))\\}$\n- 父子句 2: $C_3 = \\{\\lnot P(f(f(a)))\\}$\n- 我们归结互补文字 $P(f(f(a)))$ 和 $\\lnot P(f(f(a)))$。\n- 归结式是空子句：\n- $C_6 = \\Box$\n\n我们成功地在 3 次二元归结推理后推导出了空子句，证明了原集合是不可满足的。\n\n**最小步数分析：**\n- 我们的目标是从 $P(a)$ 开始，最终与 $\\lnot P(f(f(a)))$ 产生矛盾。\n- 子句 $C_2: \\{\\lnot P(x) \\lor P(f(x))\\}$ 是唯一能从一个项 $t$ 推导出更复杂项 $f(t)$ 的规则（即从 $P(t)$ 推导出 $P(f(t))$）。\n- 为了从 $P(a)$ 生成能够与 $\\lnot P(f(f(a)))$ 冲突的文字 $P(f(f(a)))$，我们需要两次应用函数 $f$。\n- 第一次应用 $C_2$（与 $C_1$ 归结）将 $a$ 转换为 $f(a)$，得到 $P(f(a))$。这需要 **1 步**。\n- 第二次应用 $C_2$（与 $P(f(a))$ 归结）将 $f(a)$ 转换为 $f(f(a))$，得到 $P(f(f(a)))$。这需要 **1 步**。\n- 最后，将 $P(f(f(a)))$ 与 $C_3$ 归结得到空子句。这需要 **1 步**。\n- 任何其他归结组合，例如 $C_2$ 与 $C_3$ 之间，或者 $C_1$ 与 $C_3$ 之间，都不可能直接进行，因为它们不包含互补文字。\n- 因此，这个三步序列是推导出矛盾所必需的。总共需要 $1 + 1 + 1 = 3$ 步。\n\n所以，所需的最少二元归结推理次数是 3。", "answer": "$$ \\boxed{3} $$", "id": "3050890"}]}