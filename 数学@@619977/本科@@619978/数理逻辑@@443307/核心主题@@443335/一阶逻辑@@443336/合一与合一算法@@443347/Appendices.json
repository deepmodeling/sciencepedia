{"hands_on_practices": [{"introduction": "合一不仅是理论上的概念，更是一种强大的模式匹配工具。本练习将合一算法应用于一个常见的数据结构——列表，通过使用 `cons` 和 `nil` 构造函数，你将亲身体验算法如何通过分解（Decomposition）和变量消元（Variable Elimination）来解构复杂项并找到最通用的解。这个过程揭示了合一在逻辑编程和类型推断中是如何工作的。[@problem_id:3059832]", "problem": "考虑由构造子 $\\mathrm{nil}/0$ 和 $\\mathrm{cons}/2$ 构建的列表的一阶签名。令 $a/0$ 为一个常量符号，令 $x$、$y$ 和 $z$ 为变量。代换是从变量到项的映射，该映射同态地扩展到所有项；将代换 $\\sigma$ 应用于项 $t$ 记作 $t\\sigma$。两个项 $s$ 和 $t$ 的合一子是一个代换 $\\sigma$，使得 $s\\sigma = t\\sigma$。最一般合一子 (MGU) 是一个合一子 $\\sigma$，使得任何其他合一子 $\\tau$ 都可以通过 $\\sigma$ 因子化，即存在一个代换 $\\theta$ 使得 $\\tau = \\theta \\circ \\sigma$，其中 $\\circ$ 表示代换复合。\n\n仅使用上述基本定义和带有出现检查（对相同函数符号进行分解，当变量未出现在与其相等的项中时进行变量消除，以及对称性）的标准 Robinson 合一算法，确定方程\n$$\n\\mathrm{cons}(x,\\mathrm{cons}(a,\\mathrm{nil})) \\doteq \\mathrm{cons}(\\mathrm{cons}(y,\\mathrm{nil}),z).\n$$\n的一个 MGU。\n从陈述的基本规则出发，证明你推理的每一步，并通过建立所需的因子化性质来验证你的合一子是最一般的。\n\n答案规格：作为你最终方框内的答案，请提供将你计算出的 MGU $\\sigma$ 应用于变量 $z$ 所得到的单个封闭形式的项，即 $z\\sigma$。无需数值取整，也无单位。最终方框内的答案除了该项本身外，不应包含任何其他文本。", "solution": "在进行解答之前，首先对问题进行验证。\n\n### 步骤 1：提取已知条件\n- **签名：** 构造子 $\\mathrm{nil}/0$（一个零元函数符号，或称常量）和 $\\mathrm{cons}/2$（一个二元函数符号）。\n- **常量符号：** $a/0$。\n- **变量：** $x$、$y$、$z$。\n- **代换的定义：** 从变量到项的映射，$t\\sigma$ 是将代换 $\\sigma$ 应用于项 $t$。\n- **合一子的定义：** 对于两个项 $s$ 和 $t$，合一子是一个代换 $\\sigma$，使得 $s\\sigma = t\\sigma$。\n- **最一般合一子 (MGU) 的定义：** 一个合一子 $\\sigma$，使得任何其他合一子 $\\tau$ 都可以写成 $\\tau = \\theta \\circ \\sigma$ 的形式，其中 $\\theta$ 是某个代换。\n- **算法：** 带出现检查的 Robinson 合一算法。\n- **允许的规则：** 分解、变量消除、对称。\n- **问题方程：** $\\mathrm{cons}(x,\\mathrm{cons}(a,\\mathrm{nil})) \\doteq \\mathrm{cons}(\\mathrm{cons}(y,\\mathrm{nil}),z)$。\n- **要求输出：** 将计算出的 MGU $\\sigma$ 应用于变量 $z$ 所得到的项，记作 $z\\sigma$。\n\n### 步骤 2：使用提取的已知条件进行验证\n该问题在数理逻辑和计算机科学领域内定义明确，特别涉及项重写和合一理论。所有术语，如“签名”、“代换”、“合一子”、“MGU”以及“Robinson 合一算法”，都是标准的且有严格定义。该问题提供了一个具体方程，并要求应用指定算法来寻找解。在此形式系统内，前提条件在事实上是可靠的。该问题是自包含的、一致的，并且允许一个唯一的解（在变量重命名下）。它是客观的，不依赖于任何非科学或模糊的主张。\n\n### 步骤 3：结论与行动\n该问题是**有效的**。将提供完整的解答。\n\n### 解答推导\n目标是为方程 $\\mathrm{cons}(x,\\mathrm{cons}(a,\\mathrm{nil})) \\doteq \\mathrm{cons}(\\mathrm{cons}(y,\\mathrm{nil}),z)$ 找到一个最一般合一子 (MGU)。我们将使用 Robinson 合一算法，该算法作用于一个待解的方程组。\n\n令初始方程组为 $E_0 = \\{ \\mathrm{cons}(x,\\mathrm{cons}(a,\\mathrm{nil})) \\doteq \\mathrm{cons}(\\mathrm{cons}(y,\\mathrm{nil}),z) \\}$。\n\n**步骤 1：分解**\n$E_0$ 中方程两边的根符号是相同的函数符号 $\\mathrm{cons}/2$。我们应用**分解**规则，该规则规定方程 $f(s_1, \\dots, s_n) \\doteq f(t_1, \\dots, t_n)$ 可以被方程组 $\\{ s_1 \\doteq t_1, \\dots, s_n \\doteq t_n \\}$ 替代。\n将此规则应用于 $E_0$ 中的单个方程，我们得到一个新的方程组 $E_1$：\n$$ E_1 = \\{ x \\doteq \\mathrm{cons}(y,\\mathrm{nil}), \\quad \\mathrm{cons}(a,\\mathrm{nil}) \\doteq z \\} $$\n此时，合一算法尚未生成任何代换分量。\n\n**步骤 2：变量消除**\n我们从 $E_1$ 中选择一个形式为 $v \\doteq t$ 的方程，其中 $v$ 是一个变量。我们选择第一个方程，$x \\doteq \\mathrm{cons}(y,\\mathrm{nil})$。\n我们应用**变量消除**规则，这需要进行**出现检查**。变量 $x$ 没有出现在项 $\\mathrm{cons}(y,\\mathrm{nil})$ 中。因此，我们可以继续。\n我们生成代换分量 $\\sigma_1 = \\{ x \\mapsto \\mathrm{cons}(y,\\mathrm{nil}) \\}$。\n我们将此代换应用于方程组中的其余方程。唯一剩下的方程是 $\\mathrm{cons}(a,\\mathrm{nil}) \\doteq z$。由于 $x$ 没有出现在这个方程中，应用 $\\sigma_1$ 没有效果。\n新的方程组是 $E_2 = \\{ \\mathrm{cons}(a,\\mathrm{nil}) \\doteq z \\}$，我们累积的代换是 $\\sigma_1$。\n\n**步骤 3：对称与变量消除**\n我们现在处理 $E_2$ 中的单个方程，即 $\\mathrm{cons}(a,\\mathrm{nil}) \\doteq z$。\n这是一个 $t \\doteq v$ 形式的方程。我们首先应用**对称**规则将其转换为 $v \\doteq t$ 的形式：\n$$ z \\doteq \\mathrm{cons}(a,\\mathrm{nil}) $$\n现在我们应用**变量消除**。**出现检查**得到满足，因为变量 $z$ 没有出现在项 $\\mathrm{cons}(a,\\mathrm{nil})$ 中。\n我们生成代换分量 $\\sigma_2 = \\{ z \\mapsto \\mathrm{cons}(a,\\mathrm{nil}) \\}$。\n我们必须将 $\\sigma_2$ 应用于先前累积的代换 $\\sigma_1$ 的值域。$\\sigma_1$ 的值域是项 $\\mathrm{cons}(y,\\mathrm{nil})$。由于 $z$ 没有出现在这个项中，应用 $\\sigma_2$ 没有效果。剩余的方程组现在为空。\n算法成功终止。\n\n**步骤 4：复合代换**\n最终的 MGU $\\sigma$ 是所生成代换的复合：$\\sigma = \\sigma_2 \\circ \\sigma_1$。\n要复合 $\\sigma_1 = \\{ x \\mapsto \\mathrm{cons}(y,\\mathrm{nil}) \\}$ 和 $\\sigma_2 = \\{ z \\mapsto \\mathrm{cons}(a,\\mathrm{nil}) \\}$，我们将 $\\sigma_1$ 应用于 $\\sigma_2$ 的值域，并将得到的绑定与 $\\sigma_1$ 取并集。（注：此处原文描述$\\sigma = \\sigma_1 \\circ \\sigma_2$与后面解释相反，正确的复合$\\sigma_2 \\circ \\sigma_1$是将$\\sigma_1$应用于$\\sigma_2$的值域，然后取并集。然而，由于两个代换的定义域和变量范围不重叠，$\\sigma_1 \\circ \\sigma_2 = \\sigma_2 \\circ \\sigma_1 = \\sigma_1 \\cup \\sigma_2$。）\n因此，最终的 MGU 是：\n$$ \\sigma = \\{ x \\mapsto \\mathrm{cons}(y,\\mathrm{nil}), \\quad z \\mapsto \\mathrm{cons}(a,\\mathrm{nil}) \\} $$\n变量 $y$ 保持未实例化，这是预期的，因为它参数化了所有可能的合一子的族。\n\n### MGU 的验证\n首先，我们通过将 $\\sigma$ 应用于原方程的两边来验证它是一个合一子。\n左边：\n$ (\\mathrm{cons}(x,\\mathrm{cons}(a,\\mathrm{nil})))\\sigma = \\mathrm{cons}(x\\sigma, (\\mathrm{cons}(a,\\mathrm{nil}))\\sigma) = \\mathrm{cons}(\\mathrm{cons}(y,\\mathrm{nil}), \\mathrm{cons}(a,\\mathrm{nil})) $\n右边：\n$ (\\mathrm{cons}(\\mathrm{cons}(y,\\mathrm{nil}),z))\\sigma = \\mathrm{cons}((\\mathrm{cons}(y,\\mathrm{nil}))\\sigma, z\\sigma) = \\mathrm{cons}(\\mathrm{cons}(y,\\mathrm{nil}), \\mathrm{cons}(a,\\mathrm{nil})) $\n由于两边产生相同的项，$\\sigma$ 是一个合一子。\n\n其次，我们必须验证 $\\sigma$ 是一个*最一般*合一子。令 $\\tau$ 为原方程的任何其他合一子。我们必须证明存在一个代换 $\\theta$ 使得 $\\tau = \\theta \\circ \\sigma$。\n因为 $\\tau$ 是一个合一子，我们有 $(\\mathrm{cons}(x,\\mathrm{cons}(a,\\mathrm{nil})))\\tau = (\\mathrm{cons}(\\mathrm{cons}(y,\\mathrm{nil}),z))\\tau$。\n展开此等式，我们得到 $\\mathrm{cons}(x\\tau, \\mathrm{cons}(a,\\mathrm{nil})) = \\mathrm{cons}(\\mathrm{cons}(y\\tau,\\mathrm{nil}), z\\tau)$。\n通过分解，这蕴含了两个恒等式：\n1. $x\\tau = \\mathrm{cons}(y\\tau,\\mathrm{nil})$\n2. $z\\tau = \\mathrm{cons}(a,\\mathrm{nil})$\n\n关系 $\\tau = \\theta \\circ \\sigma$ 意味着对于任何变量 $v$，都有 $v\\tau = (v\\sigma)\\theta$。让我们对所有相关变量进行检验。\n- 对于变量 $x$：我们需要 $x\\tau = (x\\sigma)\\theta$。我们有 $x\\sigma = \\mathrm{cons}(y,\\mathrm{nil})$。所以我们需要 $x\\tau = (\\mathrm{cons}(y,\\mathrm{nil}))\\theta = \\mathrm{cons}(y\\theta,\\mathrm{nil})$。根据恒等式 (1)，我们知道 $x\\tau = \\mathrm{cons}(y\\tau, \\mathrm{nil})$。比较这些，我们需要 $y\\theta = y\\tau$。\n- 对于变量 $z$：我们需要 $z\\tau = (z\\sigma)\\theta$。我们有 $z\\sigma = \\mathrm{cons}(a,\\mathrm{nil})$。所以我们需要 $z\\tau = (\\mathrm{cons}(a,\\mathrm{nil}))\\theta = \\mathrm{cons}(a,\\mathrm{nil})$。恒等式 (2) 证实了这是正确的。\n- 对于变量 $y$：我们需要 $y\\tau = (y\\sigma)\\theta$。由于 $y$ 不在 $\\sigma$ 的定义域中，所以 $y\\sigma = y$。因此我们需要 $y\\tau = y\\theta$。这与我们为 $x$ 找到的约束相同。\n- 对于任何其他变量 $w \\notin \\{x, y, z\\}$：我们需要 $w\\tau = (w\\sigma)\\theta = w\\theta$。\n\n我们可以如下构造所需的代换 $\\theta$。令不在 $\\sigma$ 的定义域 $D(\\sigma) = \\{x, z\\}$ 中的变量集合为 $V' = V \\setminus D(\\sigma)$。我们定义 $\\theta$，使得对于每个变量 $v \\in V'$，都有 $v\\theta = v\\tau$。\n这个定义满足 $y\\theta=y\\tau$ 以及对于任何其他变量 $w$ 的 $w\\theta=w\\tau$。这种 $\\theta$ 的构造总是可能的。因此，我们已经证明了 $\\tau$ 可以通过 $\\sigma$ 因子化，从而证实了 $\\sigma$ 是一个最一般合一子。\n\n### 最终答案的构建\n问题要求得到项 $z\\sigma$。根据我们的 MGU $\\sigma = \\{ x \\mapsto \\mathrm{cons}(y,\\mathrm{nil}), z \\mapsto \\mathrm{cons}(a,\\mathrm{nil}) \\}$，我们可以直接找到这个项：\n$$ z\\sigma = \\mathrm{cons}(a,\\mathrm{nil}) $$\n这就是最终答案。", "answer": "$$\n\\boxed{\\mathrm{cons}(a,\\mathrm{nil})}\n$$", "id": "3059832"}, {"introduction": "合一算法的一个基本约束是它必须生成有限的项，避免无限循环。这个约束通过“出现检查”（occurs-check）来强制执行，它防止了像 $x \\doteq f(x)$ 这样的自引用绑定。本练习将引导你追踪一个经典的合一失败案例，展示出现检查在何处以及为何触发，从而保证算法的终止和逻辑的严谨性。[@problem_id:3059943]", "problem": "考虑一个一阶项代数，其签名包含一元函数符号 $f$ 和 $g$，以及变量 $x$ 和 $y$。一个合一问题 (unification problem) 是一个形如 $s \\doteq t$ 的项之间的有限方程组，其中 $\\doteq$ 表示 $s$ 和 $t$ 必须通过一个替换 (substitution) 变得完全相同。带有出现检查 (occurs-check) 的 Martelli–Montanari 合一算法 (MMUA) 通过对一个有序的方程列表重复应用以下规则来进行，并受出现检查的约束：Delete (删除 $s \\doteq s$)，Decompose (将 $f(s_{1},\\dots,s_{n}) \\doteq f(t_{1},\\dots,t_{n})$ 替换为集合 $\\{s_{1} \\doteq t_{1},\\dots,s_{n} \\doteq t_{n}\\}$) ，Orient (将 $t \\doteq x$ 交换为 $x \\doteq t$)，以及 Eliminate (在出现检查 $x \\notin \\mathrm{Vars}(t)$ 成功的前提下，将 $x \\doteq t$ 替换为将 $x \\mapsto t$ 应用于所有剩余方程)。这里 $\\mathrm{Vars}(t)$ 表示在项 $t$ 中出现的变量集合。算法在任何出现检查失败时立即终止。\n\n从有序方程组\n$$\n\\{\\,x \\doteq f(x),\\; g(y) \\doteq g(f(y))\\,\\},\n$$\n开始，在一个确定性控制策略下执行一个逐步的失败追踪：在每一步中，选择当前列表最左边的方程，并按照 Delete、Decompose、Orient、Eliminate 的优先顺序应用第一个可用的规则（出现检查在 Eliminate 之前立即执行）。解释出现检查在哪个点被触发，并论证为什么在带出现检查的一阶合一下不存在最概合一子 (most general unifier, MGU)。\n\n最后，报告在该控制策略下，算法终止前执行的出现检查的总次数。以一个精确的数字作为最终答案。", "solution": "该问题要求在一个给定的方程组上，使用特定的控制策略执行 Martelli–Montanari 合一算法 (MMUA)，以确定失败点和出现检查的总调用次数。\n\n初始的有序方程列表是 $E_0 = [\\,x \\doteq f(x),\\; g(y) \\doteq g(f(y))\\,]$。算法在每一步选择最左边的方程，并从优先列表 Delete、Decompose、Orient、Eliminate 中应用第一个可用的规则。出现检查 $v \\notin \\mathrm{Vars}(t)$ 是 Eliminate 规则 ($v \\doteq t$) 的一个先决条件。\n\n**执行追踪：**\n\n**步骤 1：**\n算法从方程列表 $E_0 = [\\,x \\doteq f(x),\\; g(y) \\doteq g(f(y))\\,]$ 开始。\n\n*   **选择：** 根据确定性控制策略，选择最左边的方程：$e_1 = (x \\doteq f(x))$。\n*   **规则应用：** 算法从优先列表中检查适用于 $e_1$ 的第一个规则：\n    1.  **Delete** ($s \\doteq s$)：此规则不适用，因为项 $x$ 与项 $f(x)$ 在句法上不相同。\n    2.  **Decompose** ($h(s_1, \\dots) \\doteq h(t_1, \\dots)$)：此规则不适用，因为左侧的 $x$ 是一个变量，而不是一个以函数符号为根的复合项。\n    3.  **Orient** ($t \\doteq x$，其中 $t$ 不是变量)：此规则不适用，因为变量 $x$ 已经在左侧。\n    4.  **Eliminate** ($x \\doteq t$，其中 $x$ 是变量)：此规则的形式与方程 $x \\doteq f(x)$ 匹配，其中变量是 $x$，项 $t$ 是 $f(x)$。\n\n*   **出现检查：** 在应用 Eliminate 规则之前，必须执行强制性的出现检查。条件是 $x \\notin \\mathrm{Vars}(t)$。\n    *   在这里， $t$ 是项 $f(x)$。\n    *   $t$ 中的变量集合，记为 $\\mathrm{Vars}(t)$，是 $\\mathrm{Vars}(f(x)) = \\{x\\}$。\n    *   因此，检查为 $x \\notin \\{x\\}$，这是假的。\n    *   这是本次执行追踪中**第一次也是唯一一次**调用出现检查。\n\n*   **终止：** 出现检查失败。问题陈述中说明：“算法在任何出现检查失败时立即终止。”因此，合一过程在此时停止。第二个方程 $g(y) \\doteq g(f(y))$ 从未被处理。\n\n**关于最概合一子 (MGU) 不存在的论证：**\n\n方程 $x \\doteq f(x)$ 上的出现检查失败表明，在一阶逻辑的标准理论中（该理论处理有限项），这个方程是不可合一的。一个合一子 (unifier) 是一个替换 $\\sigma$，它在应用后使两个项在句法上变得相同。要使原始方程组有合一子，这样的合一子必须满足集合中的所有方程，包括 $x \\doteq f(x)$。\n\n假设 $\\sigma$ 是一个合一子。将 $\\sigma$ 应用于 $x \\doteq f(x)$ 必须产生一个恒等式：\n$$\n\\sigma(x) \\equiv \\sigma(f(x))\n$$\n根据替换在项上应用的定义，$\\sigma(f(x))$ 等价于 $f(\\sigma(x))$。因此，条件变为：\n$$\n\\sigma(x) \\equiv f(\\sigma(x))\n$$\n令 $T = \\sigma(x)$。合一所需的方程是 $T \\equiv f(T)$。这断言一个项 $T$ 在句法上与项 $f(T)$ 相同。然而，在有限项的标准代数中（表示为有限树），一个项不能与其自身的真子项 (proper subterm) 相同。项 $f(T)$ 总是包含 $T$ 作为一个直接子项，并且其结构深度严格大于 $T$ 的深度。没有有限项 $T$ 能满足这个恒等式。因为没有替换 $\\sigma$ 能满足方程 $x \\doteq f(x)$，所以初始方程组不存在合一子。根据定义，最概合一子 (MGU) 是一个合一子。由于不存在合一子，所以 MGU 也不可能存在。\n\n总而言之，算法正确地终止并报告失败，因为方程 $x \\doteq f(x)$ 在有限项合一的领域中没有解。\n\n**出现检查总调用次数：**\n\n算法只执行了一个需要出现检查的操作：即对方程 $x \\doteq f(x)$ 考虑应用 Eliminate 规则。这个检查失败了，导致立即终止。因此，执行的出现检查总调用次数为 $1$。", "answer": "$$\\boxed{1}$$", "id": "3059943"}, {"introduction": "成功的合一需要找到一组一致的变量绑定。但如果推导出的约束相互矛盾，会发生什么？本练习探讨了这种情况，即当一个变量被要求同时等于两个不同的值时，算法会如何处理。通过这个例子，你将理解“冲突”（Clash）规则的重要性，它是算法检测并报告无解情况的关键机制。[@problem_id:3059950]", "problem": "考虑标准一阶项代数，其符号集 $\\Sigma$ 由不同的常量符号 $a$、$b$（其中 $a \\neq b$）、一个一元函数符号 $h$ 以及二元函数符号 $f$、$g$ 和 $s$ 组成。设 $x$、$u$、$z$ 为变量符号。定义项对\n$$\nt_{1} \\;=\\; g\\!\\big(f(x,x),\\, s(u,u)\\big), \\qquad\nt_{2} \\;=\\; g\\!\\big(f(a,b),\\, s(h(b),\\,h(a))\\big).\n$$\n在一阶项的句法理论中进行演算，使用标准的代换和合一概念，并假定使用带出现检查的常规 Martelli–Montanari 合一算法。从代换、合一子和复合项的结构分解等核心定义出发，推导是否存在一个代换 $\\sigma$ 使得 $\\sigma(t_{1}) = \\sigma(t_{2})$，并确定所有此类合一子的集合 $\\mathcal{U}$ 的基数（如果存在）。您的推导必须是形式化的，并且除了项的句法相等性之外，不得借助任何等式理论。将您的最终答案表示为一个精确整数。", "solution": "问题要求我们确定两个项 $t_1$ 和 $t_2$ 是否可合一，如果可合一，则求出其合一子集合的基数。这两个项定义在符号集 $\\Sigma$ 上，该符号集包含常量 $a, b$（其中 $a \\neq b$）、一个一元函数 $h$ 和二元函数 $f, g, s$。变量为 $x$、$u$ 和 $z$。这两个项是：\n$$\nt_1 = g(f(x,x), s(u,u))\n$$\n$$\nt_2 = g(f(a,b), s(h(b), h(a)))\n$$\n代换 $\\sigma$ 是一个从变量到项的映射。对于项对 $t_1$ 和 $t_2$，其合一子是一个代换 $\\sigma$，使得将 $\\sigma$ 应用于这两个项后，会得到句法上完全相同的项，即 $\\sigma(t_1) = \\sigma(t_2)$。我们旨在确定合一子的集合 $\\mathcal{U} = \\{\\sigma \\mid \\sigma(t_1) = \\sigma(t_2)\\}$ 是否非空，并求出其基数 $|\\mathcal{U}|$。如果存在合一子，那么就存在一个最一般合一子（MGU），所有其他合一子都可以由它派生而来。然而，问题只要求所有合一子的集合的基数。\n\n判断两个项是否可合一的问题，等价于求解关于代换的方程 $t_1 \\doteq t_2$。我们使用一个标准的合一算法，例如 Martelli 和 Montanari 提出的算法，该算法对一个方程组进行操作。初始方程组包含我们希望求解的单个方程：\n$$\nE_0 = \\{ g(f(x,x), s(u,u)) \\doteq g(f(a,b), s(h(b), h(a))) \\}\n$$\n该算法通过对这个集合应用转换规则来执行。这里适用的第一个规则是**分解（Decomposition）**。形式为 $g(s_1, \\dots, s_n) \\doteq g(t_1, \\dots, t_n)$ 的方程与方程组 $\\{s_1 \\doteq t_1, \\dots, s_n \\doteq t_n\\}$ 具有相同的合一子集。由于 $E_0$ 中方程两边的最外层函数符号都是 $g$，我们将其分解为其参数的方程组：\n$$\nE_1 = \\{ f(x,x) \\doteq f(a,b), \\quad s(u,u) \\doteq s(h(b), h(a)) \\}\n$$\n现在，我们可以处理 $E_1$ 中的方程。我们选择第一个方程 $f(x,x) \\doteq f(a,b)$。同样，最外层的函数符号 $f$ 在两边是相同的。我们再次对该方程应用**分解**规则，得到其参数的方程组：\n$$\n\\{ x \\doteq a, \\quad x \\doteq b \\}\n$$\n将此代回我们的系统中，得到需要求解的新方程组：\n$$\nE_2 = \\{ x \\doteq a, \\quad x \\doteq b, \\quad s(u,u) \\doteq s(h(b), h(a)) \\}\n$$\n现在我们来处理方程 $x \\doteq a$。该方程是**变量消去（Variable Elimination）**规则的候选。该规则规定，对于方程 $v \\doteq t$，其中 $v$ 是一个变量，$t$ 是一个不含 $v$ 的项（“出现检查”），我们可以将代换 $\\{v \\mapsto t\\}$ 应用于系统中的所有其他方程。在这里，$v=x$ 且 $t=a$。由于 $a$ 是一个常量，$x$ 不出现在 $a$ 中。我们将代换 $\\sigma_1 = \\{x \\mapsto a\\}$ 应用于 $E_2$ 中的其余方程：\n\\begin{enumerate}\n    \\item $x \\doteq b$ 变为 $a \\doteq b$。\n    \\item $s(u,u) \\doteq s(h(b), h(a))$ 保持不变，因为它不包含变量 $x$。\n\\end{enumerate}\n代换分量 $\\sigma_1$ 被视为已解形式的一部分，剩余的方程组变为：\n$$\nE_3 = \\{ a \\doteq b, \\quad s(u,u) \\doteq s(h(b), h(a)) \\}\n$$\n算法现在检查 $E_3$ 中的方程。第一个方程是 $a \\doteq b$。合一算法包含一个**冲突（Clash/Conflict）**规则。该规则规定，如果系统包含形式为 $k_1 \\doteq k_2$ 的方程，其中 $k_1$ 和 $k_2$ 是不同的常量符号，则合一失败。\n在我们的问题中，已知条件明确指出 $a$ 和 $b$ 是不同的常量符号，这意味着 $a \\neq b$。因此，方程 $a \\doteq b$ 触发了**冲突**规则。\n\n合一算法终止并报告失败。这意味着原始方程组无解，项 $t_1$ 和 $t_2$ 是不可合一的。合一子的集合 $\\mathcal{U}$ 是空集，即 $\\mathcal{U} = \\emptyset$。\n\n问题要求集合 $\\mathcal{U}$ 的基数。空集的基数是 $0$。\n$$\n|\\mathcal{U}| = |\\emptyset| = 0\n$$\n第二个方程 $s(u,u) \\doteq s(h(b), h(a))$ 的存在与结果无关，因为在这个方程需要被解析之前就已经发现了矛盾。从第一个分量 $f(x,x) \\doteq f(a,b)$ 推导出矛盾，足以证明其不可合一性。", "answer": "$$\\boxed{0}$$", "id": "3059950"}]}