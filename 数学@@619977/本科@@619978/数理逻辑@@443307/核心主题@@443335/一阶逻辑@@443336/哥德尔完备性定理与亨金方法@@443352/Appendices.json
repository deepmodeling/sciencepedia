{"hands_on_practices": [{"introduction": "哥德尔完备性定理深刻地揭示了句法（可证明性）与语义（真理性）之间的桥梁。在深入探讨证明细节之前，我们必须对定理所涉及的核心语义概念有清晰的认识。这个练习旨在巩固有效性（在所有模型中为真）和可满足性（在至少一个模型中为真）这两个基本概念，通过构建具体的模型和反模型来判断语句的语义状态，从而为理解完备性定理的宏大图景打下坚实的基础 [@problem_id:3042828]。", "problem": "假设经典一阶逻辑 (FOL) 带等词（等价关系）、标准 Tarskian 语义和非空论域。令 $\\varphi_1 := \\forall x\\,(P(x)\\lor \\neg P(x))$ 且 $\\varphi_2 := \\exists x\\,\\forall y\\,(x=y)$。请定义 FOL 中的有效性和可满足性的语义概念，然后判断在这些语义下，关于 $\\varphi_1$ 和 $\\varphi_2$ 的哪一个组合评估是正确的。在适当的情况下，通过明确描述一个模型或反模型来证明你的选择。最后，指出哥德尔完备性定理对每个句子相应的句法地位蕴含了什么。\n\n选择唯一一个选项：\n\n- A. $\\varphi_1$ 是有效的；$\\varphi_2$ 是可满足的。\n\n- B. $\\varphi_1$ 是有效的；$\\varphi_2$ 在任何非空论域中都不可满足。\n\n- C. $\\varphi_1$ 不是有效的；$\\varphi_2$ 是可满足的。\n\n- D. $\\varphi_1$ 不是有效的；$\\varphi_2$ 是不可满足的。", "solution": "该问题要求在经典一阶逻辑 (FOL) 带等词、标准 Tarskian 语义和非空论域的假设下，分析两个句子。我们将首先定义必要的语义概念，然后分析每个句子，最后评估所提供的选项。\n\n### 定义\n一阶语言的**模型**（或结构）$\\mathcal{M}$ 由一个非空集合 $D$（称为**论域**或全域）和一个解释函数 $I$ 组成，该函数将适当的语义值赋给非逻辑符号（常数、函数符号、谓词符号）。\n\n如果存在至少一个模型 $\\mathcal{M}$ 使得句子 $\\psi$ 为真，则称 $\\psi$ 是**可满足的**。我们记作 $\\mathcal{M} \\models \\psi$。\n\n如果一个句子 $\\psi$ 在*每一个*模型 $\\mathcal{M}$ 中都为真，则称它是**有效的**（或逻辑真理）。我们记作 $\\models \\psi$。一个不是有效的句子称为无效的；对于一个无效的句子，存在至少一个**反模型**（一个使该句子为假的模型）。\n\n问题要求分析以下句子：\n1.  $\\varphi_1 := \\forall x\\,(P(x)\\lor \\neg P(x))$\n2.  $\\varphi_2 := \\exists x\\,\\forall y\\,(x=y)$\n\n### 对 $\\varphi_1 := \\forall x\\,(P(x)\\lor \\neg P(x))$ 的分析\n\n要确定 $\\varphi_1$ 是否有效，我们必须确定它在任何任意模型 $\\mathcal{M} = (D, I)$ 中是否为真。\n令 $\\mathcal{M}$ 为一个具有非空论域 $D$ 和解释函数 $I$ 的任意模型。一元谓词符号 $P$ 的解释是论域的一个子集，记作 $P^{\\mathcal{M}} \\subseteq D$。\n\n句子 $\\varphi_1$ 在 $\\mathcal{M}$ 中为真，当且仅当对于 $D$ 中的每一个元素 $d \\in D$，在将 $x$ 赋值为 $d$ 的赋值下，公式 $P(x) \\lor \\neg P(x)$ 为真。\n\n对于任何选定的元素 $d \\in D$，根据作为 Tarskian 语义基础的经典集合论，存在两种互斥且穷尽的可能性：\n1.  元素 $d$ 在集合 $P^{\\mathcal{M}}$ 中，即 $d \\in P^{\\mathcal{M}}$。在这种情况下，陈述 $P(d)$ 在 $\\mathcal{M}$ 中为真。因此，析取式 $P(d) \\lor \\neg P(d)$ 为真。\n2.  元素 $d$ 不在集合 $P^{\\mathcal{M}}$ 中，即 $d \\notin P^{\\mathcal{M}}$。在这种情况下，陈述 $\\neg P(d)$ 在 $\\mathcal{M}$ 中为真。因此，析取式 $P(d) \\lor \\neg P(d)$ 为真。\n\n由于对于论域 $D$ 中的任何元素 $d$，公式 $P(d) \\lor \\neg P(d)$ 必然为真，所以全称量化句 $\\forall x\\,(P(x)\\lor \\neg P(x))$ 在模型 $\\mathcal{M}$ 中为真。\n\n因为我们选择的模型 $\\mathcal{M}$ 是任意的，所以 $\\varphi_1$ 在所有模型中都为真。因此，$\\varphi_1$ 是**有效的**。这是排中律的一个实例，它是经典逻辑的一个基本原则。\n\n### 对 $\\varphi_2 := \\exists x\\,\\forall y\\,(x=y)$ 的分析\n\n句子 $\\varphi_2$ 断言存在一个元素 $x$，它与论域中的每一个元素 $y$ 都相同。这等价于陈述论域只包含一个元素。\n\n**$\\varphi_2$ 的可满足性**：\n要检查可满足性，我们需要找到至少一个使 $\\varphi_2$ 为真的模型。问题规定论域必须非空。让我们构造一个模型 $\\mathcal{M}_1$，其论域为 $D_1 = \\{c\\}$，包含单个元素 $c$。\n要检查 $\\mathcal{M}_1 \\models \\varphi_2$ 是否成立，我们必须看 $\\exists x\\,\\forall y\\,(x=y)$ 是否在 $\\mathcal{M}_1$ 中成立。让我们选择 $x$ 为唯一可用的元素 $c$。现在我们必须检查子公式 $\\forall y\\,(c=y)$ 的真值。要使其为真，对于 $D_1$ 中的每一个元素 $d$，陈述 $c=d$ 必须成立。$D_1$ 中唯一的元素是 $c$ 本身。所以我们必须检查 $c=c$ 是否成立。根据等价关系的自反性，这是真的。\n因此，$\\forall y\\,(c=y)$ 在 $\\mathcal{M}_1$ 中为真。因为我们找到了一个元素 $x$（即 $c$）使其成立，所以句子 $\\exists x\\,\\forall y\\,(x=y)$ 在 $\\mathcal{M}_1$ 中为真。\n因此，$\\varphi_2$ 是**可满足的**。\n\n**$\\varphi_2$ 的有效性**：\n要检查有效性，我们必须确定 $\\varphi_2$ 是否在*每一个*模型中都为真。如果我们能找到一个使 $\\varphi_2$ 为假的反模型，那么它就不是有效的。\n让我们构造一个模型 $\\mathcal{M}_2$，其论域包含多于一个元素。例如，令 $D_2 = \\{a, b\\}$，其中 $a \\neq b$。\n要检查 $\\mathcal{M}_2 \\models \\varphi_2$ 是否成立，我们必须看 $\\exists x\\,\\forall y\\,(x=y)$ 是否成立。\n-   假设我们选择 $x$ 为 $a$。子公式变为 $\\forall y\\,(a=y)$。这为真吗？对于 $y=b$，我们有 $a=b$，这在此模型中为假。所以 $\\forall y\\,(a=y)$ 为假。\n-   假设我们选择 $x$ 为 $b$。子公式变为 $\\forall y\\,(b=y)$。这为真吗？对于 $y=a$，我们有 $b=a$，这为假。所以 $\\forall y\\,(b=y)$ 为假。\n由于没有其他元素可供选择作为 $x$，在 $D_2$ 中不存在元素 $x$ 使得 $\\forall y\\,(x=y)$ 为真。因此，$\\exists x\\,\\forall y\\,(x=y)$ 在 $\\mathcal{M}_2$ 中为假。\n因为我们找到了一个反模型，所以 $\\varphi_2$ 是**无效的**。\n\n### 语义地位总结\n-   $\\varphi_1$ 是**有效的**。\n-   $\\varphi_2$ 是**可满足的**（但不是有效的）。\n\n### 哥德尔完备性定理的蕴涵\n\n哥德尔完备性定理为 FOL 建立了语义真理（有效性）和句法可证明性之间的基本对应关系。它指出，一个句子 $\\psi$ 是有效的（$\\models \\psi$）当且仅当它可以从 FOL 的公理中证明（$\\vdash \\psi$）。\n\n-   对于 $\\varphi_1$：既然我们已经确定 $\\varphi_1$ 是有效的（$\\models \\forall x\\,(P(x)\\lor \\neg P(x))$），完备性定理蕴含了 $\\varphi_1$ 是 FOL 的一个定理。也就是说，存在一个从逻辑公理到 $\\varphi_1$ 的形式推导，即 $\\vdash \\forall x\\,(P(x)\\lor \\neg P(x))$。\n\n-   对于 $\\varphi_2$：我们发现 $\\varphi_2$ 是可满足的但不是有效的。\n    -   由于 $\\varphi_2$ 不是有效的（$\\not\\models \\exists x\\,\\forall y\\,(x=y))$），完备性定理蕴含了它不是 FOL 的一个定理，即 $\\not\\vdash \\exists x\\,\\forall y\\,(x=y)$。\n    -   由于 $\\varphi_2$ 是可满足的，所以它在句法上是一致的。一个句子 $\\psi$ 是可满足的当且仅当其否定 $\\neg\\psi$ 不是有效的。$\\varphi_2$ 的否定是 $\\neg\\varphi_2 \\equiv \\forall x\\,\\exists y\\,(x \\neq y)$。这个否定不是有效的（它在任何只有一个元素的模型中都为假）。根据完备性定理，$\\not\\vdash \\neg\\varphi_2$。一个句子 $\\psi$ 是一致的如果 $\\not\\vdash \\neg\\psi$。因此，$\\varphi_2$ 是一致的。\n\n### 选项评估\n\n基于以上分析：\n-   $\\varphi_1$ 是有效的。\n-   $\\varphi_2$ 是可满足的。\n\n我们现在评估每个选项：\n\n-   **A. $\\varphi_1$ 是有效的；$\\varphi_2$ 是可满足的。**\n    这个陈述与我们得出的结论完全匹配。\n    结论：**正确**。\n\n-   **B. $\\varphi_1$ 是有效的；$\\varphi_2$ 在任何非空论域中都不可满足。**\n    第一部分是正确的。第二部分是错误的。我们明确地构造了一个带有非空论域 $D_1 = \\{c\\}$ 的模型来满足 $\\varphi_2$。\n    结论：**错误**。\n\n-   **C. $\\varphi_1$ 不是有效的；$\\varphi_2$ 是可满足的。**\n    第一部分是错误的。作为经典逻辑中排中律的一个实例，$\\varphi_1$ 是有效的。第二部分是正确的。\n    结论：**错误**。\n\n-   **D. $\\varphi_1$ 不是有效的；$\\varphi_2$ 是不可满足的。**\n    这个陈述的两个部分都是错误的。\n    结论：**错误**。", "answer": "$$\\boxed{A}$$", "id": "3042828"}, {"introduction": "在宏观上理解了有效性和可满足性之后，我们现在需要深入其微观机制：在一个具体的数学结构（即模型）中，我们究竟如何精确地判定一个公式的真假？本练习将引导你运用 Tarski 的满足性递归定义——这是整个一阶逻辑语义学的基石。通过在一个给定的模型中，从项的解释到原子公式的真值，再到处理量词，你将一步步地将抽象的定义转化为一个具体的、可操作的计算过程 [@problem_id:3042855]。", "problem": "考虑用于证明哥德尔完备性定理的标准模型论语义，例如Henkin方法，对于一阶逻辑（FOL）。设语言 $\\mathcal{L}$ 包含一个一元函数符号 $f$，一个二元关系符号 $R$，以及一个常数符号 $a$。给定 $\\mathcal{L}$ 的一个结构 $\\mathcal{M}$，其论域为 $M = \\mathbb{Z}$，解释如下\n$$\na^{\\mathcal{M}} = -5,\\qquad f^{\\mathcal{M}}(n) = 2n + 1,\\qquad R^{\\mathcal{M}} = \\{(u,v) \\in \\mathbb{Z}^2 : u  v\\}.\n$$\n固定一个变量赋值 $s$，其中 $s(x) = 0$（其他任何变量可取任意值）。\n\n任务1：陈述原子公式的Tarski满足性定义，并给出布尔联结词和量词的归纳子句。仅使用一阶逻辑语义的基本标准子句，从项的求值和满足性的定义开始，不援引任何完备性定理。\n\n任务2：使用这些子句，判断在给定结构中 $\\mathcal{M}, s \\models \\exists x\\, R(f(x), a)$ 是否成立。你的推理必须从任务1中的定义开始，并逐步通过项的求值和满足关系进行。\n\n将最终的真值表示为单个实数，其中 $1$ 表示“满足”，$0$ 表示“不满足”。无需四舍五入，不涉及物理单位。", "solution": "### 任务1：Tarski满足性定义\n\n设 $\\mathcal{L}$ 是一个一阶语言，$\\mathcal{M}$ 是 $\\mathcal{L}$ 的一个结构，其论域为 $M$， $s$ 是一个将变量映射到 $M$ 中元素的变量赋值。\n\n**项的求值**\n一个项 $t$ 在结构 $\\mathcal{M}$ 中，在赋值 $s$ 下的值，记为 $t^{\\mathcal{M}}[s]$，被递归定义如下：\n1.  如果 $t$ 是一个变量 $v$，那么 $t^{\\mathcal{M}}[s] = s(v)$。\n2.  如果 $t$ 是一个常数符号 $c$，那么 $t^{\\mathcal{M}}[s] = c^{\\mathcal{M}}$，其中 $c^{\\mathcal{M}}$ 是 $c$ 在 $\\mathcal{M}$ 中的解释。\n3.  如果 $t$ 的形式为 $f(t_1, \\dots, t_k)$，其中 $f$ 是一个 $k$ 元函数符号，$t_1, \\dots, t_k$ 是项，那么 $t^{\\mathcal{M}}[s] = f^{\\mathcal{M}}(t_1^{\\mathcal{M}}[s], \\dots, t_k^{\\mathcal{M}}[s])$，其中 $f^{\\mathcal{M}}$ 是 $f$ 在 $\\mathcal{M}$ 中的解释。\n\n**公式的满足性**\n一个公式 $\\phi$ 在结构 $\\mathcal{M}$ 中，在赋值 $s$ 下被满足，记为 $\\mathcal{M}, s \\models \\phi$，被递归定义如下：\n\n**1. 原子公式：**\n*   如果 $\\phi$ 的形式为 $R(t_1, \\dots, t_k)$，其中 $R$ 是一个 $k$ 元关系符号，那么 $\\mathcal{M}, s \\models R(t_1, \\dots, t_k)$ 当且仅当元组 $(t_1^{\\mathcal{M}}[s], \\dots, t_k^{\\mathcal{M}}[s])$ 是 $R^{\\mathcal{M}}$ 的一个元素，$R^{\\mathcal{M}}$ 是 $R$ 在 $\\mathcal{M}$ 中的解释。\n*   如果 $\\phi$ 的形式为 $t_1 = t_2$，那么 $\\mathcal{M}, s \\models t_1 = t_2$ 当且仅当 $t_1^{\\mathcal{M}}[s] = t_2^{\\mathcal{M}}[s]$。\n\n**2. 布尔联结词：**\n*   $\\mathcal{M}, s \\models \\neg\\psi$ 当且仅当 $\\mathcal{M}, s \\models \\psi$ 不成立。\n*   $\\mathcal{M}, s \\models (\\psi_1 \\wedge \\psi_2)$ 当且仅当 $\\mathcal{M}, s \\models \\psi_1$ 且 $\\mathcal{M}, s \\models \\psi_2$。\n*   $\\mathcal{M}, s \\models (\\psi_1 \\vee \\psi_2)$ 当且仅当 $\\mathcal{M}, s \\models \\psi_1$ 或 $\\mathcal{M}, s \\models \\psi_2$。\n\n**3. 量词：**\n*   $\\mathcal{M}, s \\models \\forall x \\, \\psi$ 当且仅当对于每一个元素 $m \\in M$，我们有 $\\mathcal{M}, s[x/m] \\models \\psi$，其中 $s[x/m]$ 是一个变量赋值，它在除 $x$ 之外的所有变量上都与 $s$ 一致，并将 $x$ 映射到 $m$。也就是说，$(s[x/m])(x) = m$，且对于任何变量 $y \\neq x$，有 $(s[x/m])(y) = s(y)$。\n*   $\\mathcal{M}, s \\models \\exists x \\, \\psi$ 当且仅当存在一个元素 $m \\in M$ 使得 $\\mathcal{M}, s[x/m] \\models \\psi$。\n\n### 任务2：确定 $\\exists x\\, R(f(x), a)$ 的真值\n\n我们要判断 $\\mathcal{M}, s \\models \\exists x\\, R(f(x), a)$ 是否成立。给定的结构 $\\mathcal{M}$ 的论域为 $M = \\mathbb{Z}$，解释为 $a^{\\mathcal{M}} = -5$，$f^{\\mathcal{M}}(n) = 2n + 1$，$R^{\\mathcal{M}} = \\{(u,v) \\in \\mathbb{Z}^2 : u  v\\}$。初始赋值为 $s(x) = 0$。\n\n1.  **应用存在量词的子句：**\n    根据定义，$\\mathcal{M}, s \\models \\exists x\\, R(f(x), a)$ 为真，当且仅当存在一个元素 $m \\in M$（即 $m \\in \\mathbb{Z}$），使得 $\\mathcal{M}, s[x/m] \\models R(f(x), a)$。我们将修改后的赋值记为 $s' = s[x/m]$，其中 $s'(x) = m$。注意，一个句子（没有自由变量的公式）的真值与初始赋值 $s$ 无关。\n\n2.  **应用原子公式的子句：**\n    原子公式 $\\mathcal{M}, s' \\models R(f(x), a)$ 的满足性成立，当且仅当求值后的项对 $((f(x))^{\\mathcal{M}}[s'], a^{\\mathcal{M}}[s'])$ 在关系 $R^{\\mathcal{M}}$ 中。\n\n3.  **在赋值 $s'$ 下对项进行求值：**\n    *   **项 $a$**：这是一个常数符号。它的求值与赋值 $s'$ 无关。\n        $$a^{\\mathcal{M}}[s'] = a^{\\mathcal{M}} = -5$$\n    *   **项 $f(x)$**：这是一个复合项。我们首先对内部的项 $x$ 进行求值。\n        $$x^{\\mathcal{M}}[s'] = s'(x) = m$$\n        现在我们将函数解释 $f^{\\mathcal{M}}$ 应用于此结果：\n        $$(f(x))^{\\mathcal{M}}[s'] = f^{\\mathcal{M}}(x^{\\mathcal{M}}[s']) = f^{\\mathcal{M}}(m) = 2m + 1$$\n\n4.  **检验关系：**\n    现在我们将求值后的项代回到原子公式的满足条件中。我们需要检验项对 $( (f(x))^{\\mathcal{M}}[s'], a^{\\mathcal{M}}[s'] )$ 是否在 $R^{\\mathcal{M}}$ 中。\n    这对应于检验 $(2m + 1, -5) \\in R^{\\mathcal{M}}$。\n    根据 $R^{\\mathcal{M}}$ 的定义，这当且仅当第一个分量小于第二个分量时成立：\n    $$2m + 1  -5$$\n\n5.  **求解 $m$：**\n    我们必须确定是否存在一个整数 $m \\in \\mathbb{Z}$ 满足这个不等式。\n    $$2m  -5 - 1$$\n    $$2m  -6$$\n    $$m  -3$$\n\n6.  **结论：**\n    存在量词陈述为真的条件可以归结为问题：“是否存在一个整数 $m$ 使得 $m  -3$？”\n    答案是肯定的。例如，我们可以选择 $m = -4$。因为 $-4$ 是一个整数且 $-4  -3$，我们找到了论域中满足该条件的一个元素。\n    让我们用 $m = -4$ 来验证一下：\n    *   在赋值 $s[x/-4]$ 下，$f(x)$ 的值为 $f^{\\mathcal{M}}(-4) = 2(-4) + 1 = -7$。\n    *   $a$ 的值为 $-5$。\n    *   关系 $R(f(x), a)$ 变为 $R(-7, -5)$。\n    *   如果 $(-7, -5) \\in R^{\\mathcal{M}}$，即 $-7  -5$，则该关系被满足。这是真的。\n    由于我们找到了至少一个这样的整数 $m$，存在量词陈述 $\\exists x\\, R(f(x), a)$ 在结构 $\\mathcal{M}$ 中是满足的。\n    真值为“真”或“满足”，用数字 $1$ 表示。", "answer": "$$\\boxed{1}$$", "id": "3042855"}, {"introduction": "Henkin 证明法的精妙之处在于它能够为任何相容的理论“凭空”构造出一个模型，其核心步骤是为理论中的存在性语句引入“见证者”（witnesses）。然而，这一过程必须小心翼翼，以避免引入矛盾。本练习聚焦于 Henkin 构造中的一个关键技术细节：为什么必须使用“全新的”或“新鲜的”常数作为见证者。通过一个具体的反例，你将看到，复用一个已有名称可能导致其固有属性与新的见证属性发生冲突，从而引发逻辑矛盾，这不仅揭示了该技术要求的必要性，也让你能更深刻地体会到 Henkin 证明设计的严谨与巧妙 [@problem_id:3042834]。", "problem": "考虑一个一阶语言 $L$ 和一个在带等词的经典一阶逻辑中的理论 $T$。如果不存在任何语句 $\\sigma$ 使得 $\\sigma$ 和其否定 $\\lnot \\sigma$ 都能从 $T$ 推导出来，那么理论 $T$ 就被称为是一致的，这等价于 $T$ 有一个模型。在用于证明哥德尔完备性定理的Henkin方法中，人们通过为每个形如 $\\exists x\\, \\varphi(x)$ 的公式添加一条Henkin公理 $\\exists x \\varphi(x) \\to \\varphi(c_{\\varphi})$，将理论 $T$ 扩充为一个Henkin化理论 $T^{\\ast}$，其中 $c_{\\varphi}$ 是一个之前不在语言中或未用于任何其他目的的新常量符号。要求每个 $c_{\\varphi}$ 都是新的（即，不在 $L$ 中且之前未被引入）是一个标准要求。\n\n基于这样一个基本的模型论事实：如果 $M \\vDash T$ 且 $c_{\\varphi}$ 是一个新符号，那么当 $M \\vDash \\exists x\\, \\varphi(x)$ 时，$M$ 可以被扩充为一个 $L \\cup \\{c_{\\varphi}\\}$-结构，将 $c_{\\varphi}$ 解释为某个满足 $\\varphi(a)$ 的见证 $a \\in M$。请解释为什么违反新颖性要求（即，重用一个已有的常量）会破坏这种扩充的可能性，从而导致不一致性或意想不到的后果。选择一个正确陈述了原因并给出了一个有效的、具体的失败示例的选项。\n\nA. 需要新颖性是因为重用一个常量会强制该常量已表示的特定元素去满足新的见证属性，这可能与关于该元素的现有承诺相矛盾。例如，设 $L=\\{P, c\\}$，包含一个一元谓词 $P$ 和一个常量 $c$，并设 $T_{0}=\\{P(c), \\exists x \\lnot P(x)\\}$。理论 $T_{0}$ 是一致的（例如，它有一个包含两个元素的模型，将 $c$ 解释为一个满足 $P(a)$ 为真的元素 $a$，并将某个其他元素 $b$ 满足 $\\lnot P(b)$）。如果通过使用已有的常量 $c$ 作为 $\\exists x \\lnot P(x)$ 的见证来违反新颖性，就会添加公理 $\\lnot P(c)$，那么 $T_{0} \\cup \\{\\lnot P(c)\\}$ 将变得不一致，因为它同时包含了 $P(c)$ 和 $\\lnot P(c)$。相比之下，使用一个新的常量 $d$，添加 $\\lnot P(d)$ 会保持一致性并允许模型扩充。\n\nB. 只有当语言包含等词时才需要新颖性。在没有 $=$ 的语言中，重用一个已有的常量作为见证总是安全的，因为无法表达两个项表示不同的元素，所以不会产生矛盾。\n\nC. 根据紧致性定理，重用一个已有的常量不会引入不一致性：如果扩充后的理论不一致，那么它的某个有限子集也会不一致，这与原始理论是一致的这一事实相矛盾。\n\nD. Skolem化消除了Henkin方法中对新颖性的需求，因为Skolem函数可以使用语言中已有的符号来定义，而无需引入新符号，并且这样做不会影响一致性。", "solution": "### 解决方案推导\n\nHenkin方法的目的是为一个一致的理论 $T$ 构造一个模型。该构造过程通过用新常量扩充语言 $L$ 和用称为Henkin公理的新公理扩充理论 $T$ 来进行，并且每一步都保持一致性。\n\n设 $T_0$ 是语言 $L_0$ 中的一个一致理论。Henkin化的过程涉及构建一个理论序列 $T_0 \\subseteq T_1 \\subseteq \\dots$ 和一个语言序列 $L_0 \\subseteq L_1 \\subseteq \\dots$。为了从 $L_i, T_i$ 得到 $L_{i+1}, T_{i+1}$，对于语言 $L_i$ 中每个形如 $\\exists x \\, \\varphi(x)$ 的语句，人们添加一个新的“见证”常量 $c_{\\exists x \\varphi}$ 和一条新公理 $\\exists x \\, \\varphi(x) \\to \\varphi(c_{\\exists x \\varphi})$。关键步骤是这些常量必须是新的，或“fresh”。\n\n我们来分析为什么新颖性对于保持一致性是必要的。假设我们在语言 $L$ 中有一个一致的理论 $T$。我们想为公式 $\\exists x \\, \\varphi(x)$ 添加一个见证。\n\n**情况1：使用新常量**\n\n设 $c$ 是一个不在 $L$ 中的常量符号。我们形成新理论 $T' = T \\cup \\{\\exists x \\varphi(x) \\to \\varphi(c)\\}$。为了反证，假设 $T'$ 是不一致的。这意味着 $T \\cup \\{\\exists x \\varphi(x) \\to \\varphi(c)\\} \\vdash \\bot$，其中 $\\bot$ 代表矛盾。在构建极大一致集的上下文中，我们只会在 $\\exists x \\varphi(x)$ 本身在我们的一致集中时才关心这一点。在这种情况下，我们有效地添加了 $\\varphi(c)$。如果 $T \\cup \\{\\varphi(c)\\}$ 不一致，则 $T \\vdash \\lnot \\varphi(c)$。由于 $c$ 是一个不出现在 $T$ 中的新符号，它起到一个通用元素的作用。因此，如果我们能从 $T$ 证明 $\\lnot \\varphi(c)$，我们就可以对这个结论进行全称推广。即 $T \\vdash \\forall x \\, \\lnot \\varphi(x)$。这在逻辑上等价于 $T \\vdash \\lnot (\\exists x \\, \\varphi(x))$。所以，为一个新常量 $c$ 添加见证公理只会在理论 $T$ 已经证明不存在这样的见证时才会引入不一致性。这保证了在使用新常量时可以保持一致性。\n\n**情况2：重用已有常量**\n\n现在，假设我们违反了新颖性要求。设 $c_0$ 是语言 $L$ 中已有的一个常量。我们试图通过向 $T$ 添加公理 $\\exists x \\varphi(x) \\to \\varphi(c_0)$ 来使用 $c_0$ 作为 $\\exists x \\, \\varphi(x)$ 的见证。\n\n问题在于，理论 $T$ 可能已经包含了指定由 $c_0$ 表示的对象属性的公理。例如，$T$ 可能蕴含某个语句 $\\psi(c_0)$。如果语句 $\\psi(x)$ 和 $\\varphi(x)$ 是矛盾的（例如，如果 $\\varphi(x)$ 是 $\\lnot \\psi(x)$），那么新理论 $T'$ 将可能是不一致的。如果 $T$ 也蕴含 $\\exists x \\varphi(x)$，那么 $T'$ 将同时蕴含 $\\psi(c_0)$（来自 $T$）和 $\\varphi(c_0)$（来自新公理和蕴含的 $\\exists x \\varphi(x)$）。例如，如果 $\\varphi(c_0)$ 是 $\\lnot \\psi(c_0)$，那么 $T'$ 蕴含 $\\psi(c_0) \\land \\lnot \\psi(c_0)$，这是一个矛盾。\n\n本质上，通过重用一个已有的常量 $c_0$，我们是在强迫由 $c_0$ 表示的元素同时满足它所有来自 $T$ 的预先存在的属性以及新的见证属性 $\\varphi$。如果这些属性不一致，一致性就被破坏了。这正是使用新常量所避免的；一个新符号没有任何先前的承诺，可以自由地被解释为所需的见证，而不会产生冲突。\n\n### 逐项分析\n\n**A. 需要新颖性是因为重用一个常量会强制该常量已表示的特定元素去满足新的见证属性，这可能与关于该元素的现有承诺相矛盾。例如，设 $L=\\{P, c\\}$，包含一个一元谓词 $P$ 和一个常量 $c$，并设 $T_{0}=\\{P(c), \\exists x \\lnot P(x)\\}$。理论 $T_{0}$ 是一致的（例如，它有一个包含两个元素的模型，将 $c$ 解释为一个满足 $P(a)$ 为真的元素 $a$，并将某个其他元素 $b$ 满足 $\\lnot P(b)$）。如果通过使用已有的常量 $c$ 作为 $\\exists x \\lnot P(x)$ 的见证来违反新颖性，就会添加公理 $\\lnot P(c)$，那么 $T_{0} \\cup \\{\\lnot P(c)\\}$ 将变得不一致，因为它同时包含了 $P(c)$ 和 $\\lnot P(c)$。相比之下，使用一个新的常量 $d$，添加 $\\lnot P(d)$ 会保持一致性并允许模型扩充。**\n\n这个选项提供了一个与上述推导完全一致的绝佳解释。它正确地指出了核心问题：重用常量的预先存在属性与分配给它的新属性之间可能存在的矛盾。所提供的例子清晰、简单，并准确地展示了这种失败。\n*   理论 $T_0 = \\{P(c), \\exists x \\lnot P(x)\\}$ 是一致的。一个模型是 $D=\\{a_1, a_2\\}$，$c^M=a_1$，$P^M=\\{a_1\\}$。$M \\vDash P(c)$ 因为 $a_1 \\in P^M$。$M \\vDash \\exists x \\lnot P(x)$ 因为对于 $x=a_2$，$a_2 \\notin P^M$。\n*   通过使用 $c$ 作为 $\\exists x \\lnot P(x)$ 的见证来违反新颖性，意味着添加公理 $\\exists x \\lnot P(x) \\to \\lnot P(c)$。由于 $T_0$ 包含 $\\exists x \\lnot P(x)$，新理论将推导出 $\\lnot P(c)$。\n*   新理论 $\\{P(c), \\exists x \\lnot P(x), \\exists x \\lnot P(x) \\to \\lnot P(c)\\}$ 明显不一致，因为它推导出矛盾的语句对 $P(c)$ 和 $\\lnot P(c)$。\n*   关于使用新常量 $d$ 的最后说明也是正确的。理论 $\\{P(c), \\exists x \\lnot P(x), \\exists x \\lnot P(x) \\to \\lnot P(d)\\}$ 仍然是一致的。\n\n结论：**正确**。\n\n**B. 只有当语言包含等词时才需要新颖性。在没有 $=$ 的语言中，重用一个已有的常量作为见证总是安全的，因为无法表达两个项表示不同的元素，所以不会产生矛盾。**\n\n这个陈述是错误的。选项A中给出的例子没有使用等号（$=$），但它展示了重用常量如何导致不一致性。矛盾 $P(c) \\land \\lnot P(c)$ 是一个逻辑矛盾，不依赖于语言中是否存在等词谓词。因此，即使在没有等词的语言中，新颖性也是必需的。\n\n结论：**错误**。\n\n**C. 根据紧致性定理，重用一个已有的常量不会引入不一致性：如果扩充后的理论不一致，那么它的某个有限子集也会不一致，这与原始理论是一致的这一事实相矛盾。**\n\n这是一个错误地解释了紧致性定理的谬论。紧致性定理指出，一个理论有模型当且仅当它的每个有限子集都有模型。如果我们将一条公理 $\\sigma$ 添加到一个一致的理论 $T$ 中得到 $T' = T \\cup \\{\\sigma\\}$，而 $T'$ 结果是不一致的，那么根据证明的定义，存在一个 $T'$ 的不一致的有限子集。这个有限子集的形式将是 $\\{\\tau_1, \\dots, \\tau_n, \\sigma\\}$，其中 $\\{\\tau_1, \\dots, \\tau_n\\} \\subseteq T$。紧致性定理并不排除这种可能性。在选项A的例子中，不一致的有限子集是 $\\{P(c), \\exists x \\lnot P(x) \\to \\lnot P(c)\\}$（它与 $T_0$ 中的 $P(c)$ 一起导致矛盾）。原始理论是一致的这一事实，并不能阻止新公理与一条或多条原始公理产生矛盾。\n\n结论：**错误**。\n\n**D. Skolem化消除了Henkin方法中对新颖性的需求，因为Skolem函数可以使用语言中已有的符号来定义，而无需引入新符号，并且这样做不会影响一致性。**\n\n这个选项在多个方面都是不正确的。首先，它将Henkin方法与Skolemn化混为一谈，而它们是不同（尽管相关）的过程。其次，更重要的是，标准的Skolem化过程本身*需要*引入新的函数/常量符号来替换存在量化的变量。对于公式 $\\forall x_1 \\dots \\forall x_n \\exists y \\, \\psi(x_1, \\dots, x_n, y)$，人们会引入一个新的函数符号 $f$，并将公式替换为 $\\forall x_1 \\dots \\forall x_n \\, \\psi(x_1, \\dots, x_n, f(x_1, \\dots, x_n))$。Skolem化中等可满足性的保持，关键取决于这些新的Skolem符号的新颖性，其原因与Henkin方法中需要新颖性的原因完全相同。重用一个已有的函数符号很容易引入矛盾。该选项的前提存在根本性缺陷。\n\n结论：**错误**。", "answer": "$$\\boxed{A}$$", "id": "3042834"}]}