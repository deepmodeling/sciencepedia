{"hands_on_practices": [{"introduction": "在尝试复杂的重命名证明之前，掌握一个快速的检验方法会非常有用。α-等价的一个基本性质是它保持自由变量的集合不变，因此，如果两个项的自由变量集不同，它们必然不是 α-等价的。这个练习 [@problem_id:3060354] 要求你应用这一原理，像进行“石蕊测试”一样，通过计算并比较两个 λ-项的自由变量来快速判定它们是否可能等价。", "problem": "在无类型 lambda 演算中，考虑项的语法由 $t ::= x \\mid t_1\\,t_2 \\mid \\lambda x.\\,t$ 给出，其中 $x$ 的取值范围是一个可数无限的变量集合。自由变量集合 $\\mathrm{FV}(t)$ 由以下基本规则归纳定义：$\\mathrm{FV}(x) = \\{x\\}$，$\\mathrm{FV}(t_1\\,t_2) = \\mathrm{FV}(t_1) \\cup \\mathrm{FV}(t_2)$，以及 $\\mathrm{FV}(\\lambda x.\\,t) = \\mathrm{FV}(t) \\setminus \\{x\\}$。Alpha 等价（$\\alpha$-等价）是最小的同余关系，它将仅因绑定变量使用避免捕获的替换进行一致性重命名而不同的项等同起来：如果 $z \\notin \\mathrm{FV}(M)$，则 $\\lambda x.\\,M \\equiv_{\\alpha} \\lambda z.\\,M[z/x]$，并且 $\\equiv_{\\alpha}$ 在应用和抽象下保持不变。\n\n令 $M = \\lambda x.\\,(x\\ y)$ 和 $N = \\lambda y.\\,(y\\ y)$。定义指示符\n$$\nI \\;=\\; \\begin{cases}\n1  \\text{如果 } M \\equiv_{\\alpha} N,\\\\\n0  \\text{其他情况。}\n\\end{cases}\n$$\n请仅使用上述核心定义，以及关于自由变量、绑定变量和避免捕获的重命名的严谨推理，通过检查变量 $y$ 在 $M$ 和 $N$ 中的状态来确定 $I$ 的值。你的最终答案必须是单个数字 $0$ 或 $1$。", "solution": "问题陈述经核实具有科学依据、问题明确且客观。这是一个在无类型 lambda 演算的成熟框架内的形式化问题。所有定义都是标准的，并且足以推导出唯一解。\n\n任务是确定指示符 $I$ 的值，这取决于 lambda 项 $M = \\lambda x.\\,(x\\ y)$ 和 $N = \\lambda y.\\,(y\\ y)$ 是否是 $\\alpha$-等价的。如果一个项可以通过对另一个项进行一系列绑定变量的重命名而得到，那么这两个项就是 $\\alpha$-等价的，记作 $\\equiv_{\\alpha}$。$\\alpha$-等价的一个关键性质是它保持自由变量集合不变。也就是说，如果两个项 $T_1$ 和 $T_2$ 是 $\\alpha$-等价的，那么它们的自由变量集合必须相同：$T_1 \\equiv_{\\alpha} T_2 \\implies \\mathrm{FV}(T_1) = \\mathrm{FV}(T_2)$。我们可以使用这个必要条件来检验非等价性。如果自由变量集合不同，那么这两个项就不可能是 $\\alpha$-等价的。\n\n我们使用所提供的归纳规则，计算每个项 $M$ 和 $N$ 的自由变量集合。\n\n首先，我们分析项 $M = \\lambda x.\\,(x\\ y)$。\n自由变量集合的计算方式为 $\\mathrm{FV}(\\lambda x.\\,t) = \\mathrm{FV}(t) \\setminus \\{x\\}$。\n在我们的例子中，抽象的主体是项 $t = (x\\ y)$。\n我们首先找出主体的自由变量：\n$$\n\\mathrm{FV}(x\\ y) = \\mathrm{FV}(x) \\cup \\mathrm{FV}(y)\n$$\n使用定义的基础情况，$\\mathrm{FV}(x) = \\{x\\}$ 和 $\\mathrm{FV}(y) = \\{y\\}$。\n因此，\n$$\n\\mathrm{FV}(x\\ y) = \\{x\\} \\cup \\{y\\} = \\{x, y\\}\n$$\n现在，我们应用 lambda 抽象的规则来找出 $M$ 的自由变量：\n$$\n\\mathrm{FV}(M) = \\mathrm{FV}(\\lambda x.\\,(x\\ y)) = \\mathrm{FV}(x\\ y) \\setminus \\{x\\} = \\{x, y\\} \\setminus \\{x\\} = \\{y\\}\n$$\n在项 $M$ 中，变量 $x$ 被 lambda 抽象所绑定，而变量 $y$ 是自由的。\n\n接下来，我们分析项 $N = \\lambda y.\\,(y\\ y)$。\n自由变量集合的计算方式为 $\\mathrm{FV}(\\lambda y.\\,t) = \\mathrm{FV}(t) \\setminus \\{y\\}$。\n这里，抽象的主体是项 $t = (y\\ y)$。\n我们找出主体的自由变量：\n$$\n\\mathrm{FV}(y\\ y) = \\mathrm{FV}(y) \\cup \\mathrm{FV}(y)\n$$\n使用基础情况 $\\mathrm{FV}(y) = \\{y\\}$，我们得到：\n$$\n\\mathrm{FV}(y\\ y) = \\{y\\} \\cup \\{y\\} = \\{y\\}\n$$\n现在，我们应用 lambda 抽象的规则来找出 $N$ 的自由变量：\n$$\n\\mathrm{FV}(N) = \\mathrm{FV}(\\lambda y.\\,(y\\ y)) = \\mathrm{FV}(y\\ y) \\setminus \\{y\\} = \\{y\\} \\setminus \\{y\\} = \\emptyset\n$$\n在项 $N$ 中，变量 $y$ 的两次出现都被 lambda 抽象所绑定。项 $N$ 没有自由变量。\n\n我们现在比较 $M$ 和 $N$ 的自由变量集合：\n$$\n\\mathrm{FV}(M) = \\{y\\}\n$$\n$$\n\\mathrm{FV}(N) = \\emptyset\n$$\n由于 $\\mathrm{FV}(M) \\neq \\mathrm{FV}(N)$，$\\alpha$-等价的必要条件未被满足。因此，项 $M$ 和 $N$ 不是 $\\alpha$-等价的：\n$$\nM \\not\\equiv_{\\alpha} N\n$$\n指示符 $I$ 的定义如下：\n$$\nI \\;=\\; \\begin{cases}\n1  \\text{如果 } M \\equiv_{\\alpha} N,\\\\\n0  \\text{其他情况。}\n\\end{cases}\n$$\n因为我们已经严谨地证明了 $M \\not\\equiv_{\\alpha} N$，所以条件评估为“其他情况”。\n因此，指示符的值为 $I = 0$。", "answer": "$$\\boxed{0}$$", "id": "3060354"}, {"introduction": "当同一个变量名出现在嵌套的作用域中时（这种情况被称为“变量遮蔽”），计算自由变量会变得棘手。这个练习 [@problem_id:3060306] 提供了一个经典的例子，并引导你首先通过 α-重命名来明确各个变量的作用域，从而消除歧义。这种实践对于准确解析复杂逻辑表达式和 λ-项的结构至关重要，也是理解词法作用域（lexical scoping）的关键一步。", "problem": "设 $t$ 为无类型 lambda 演算项\n$$\nt \\;=\\; \\lambda x.\\,\\big( f(x,y)\\ \\ (\\lambda y.\\, g(y,z)) \\big),\n$$\n其中应用是左结合的，且 $f(x,y)$ 是 $((f\\ x)\\ y)$ 的简写。将 $f$ 和 $g$ 视作变量标识符（它们可能表示高阶函数），$x$、$y$、$z$ 也视作变量标识符。仅从无类型 lambda 演算中自由变量和约束变量的标准归纳定义，以及 alpha 等价（约束变量的重命名）的定义出发，计算项 $t$ 的自由变量集合 $\\mathrm{FV}(t)$，并对每个变量的包含或排除给出理由。在你的推导过程中，首先对内部的绑定符 $\\lambda y$ 执行一次避免捕获的 alpha 重命名，将其换成一个新变量，以明确指出 $f(x,y)$ 中外部出现的 $y$ 不受内部的 $\\lambda y$ 约束。你的最终答案必须以一个集合表达式的形式给出，其中精确地包含 $t$ 的所有自由变量。", "solution": "这个问题是有效的，因为它是无类型 lambda 演算这一形式系统内的一个明确定义的问题，而无类型 lambda 演算是数理逻辑和理论计算机科学的核心主题。问题陈述是自包含的、无歧义的，并依赖于标准定义。\n\n给定的 lambda 演算项是：\n$$\nt \\;=\\; \\lambda x.\\,\\big( f(x,y)\\ \\ (\\lambda y.\\, g(y,z)) \\big)\n$$\n符号 $f(x,y)$ 是 $((f\\ x)\\ y)$ 的简写。鉴于应用是左结合的，项 $t$ 可以写成完全括号化的形式：\n$$\nt \\;=\\; \\lambda x.\\,\\Big( \\big( (f\\ x)\\ y \\big)\\ \\big( \\lambda y.\\, ((g\\ y)\\ z) \\big) \\Big)\n$$\n核心任务是计算自由变量的集合，记作 $\\mathrm{FV}(t)$。我们将使用自由变量的标准归纳定义：\n1.  对于任意变量 $v$，$\\mathrm{FV}(v) = \\{v\\}$。\n2.  对于应用，$\\mathrm{FV}(E_1\\ E_2) = \\mathrm{FV}(E_1) \\cup \\mathrm{FV}(E_2)$。\n3.  对于 lambda 抽象，$\\mathrm{FV}(\\lambda v. E) = \\mathrm{FV}(E) \\setminus \\{v\\}$。\n\n问题要求我们首先对内部的绑定符 $\\lambda y$ 执行一次避免捕获的 alpha 重命名。项 $t$ 中包含变量标识符 $y$ 的两个不同作用域。$y$ 在 $((f\\ x)\\ y)$ 中的第一次出现，其作用域是外部的 $\\lambda x$ 绑定符。$y$ 的第二次和第三次出现是在子项 $\\lambda y.\\, ((g\\ y)\\ z)$ 中，其中 $(g\\ y)$ 中的 $y$ 被内部的 $\\lambda y$ 约束。为了明确作用域并避免混淆，我们对内部的约束变量进行重命名。\n\n让我们选择一个新变量名 $w$，它在 $t$ 中没有出现过。我们对内部子项执行 alpha 转换：\n$$\n\\lambda y.\\, ((g\\ y)\\ z) \\quad \\xrightarrow{\\alpha} \\quad \\lambda w.\\, ((g\\ w)\\ z)\n$$\n这是一个有效的 alpha 等价变换，因为 $w$ 是新的，并且不会被 $((g\\ y)\\ z)$ 中的任何其他绑定符捕获，也不会捕获该子项中的任何自由变量。\n\n将这个重命名后的子项代换回 $t$ 中，我们得到一个 alpha 等价的项，称之为 $t'$：\n$$\nt' \\;=\\; \\lambda x.\\,\\Big( \\big( (f\\ x)\\ y \\big)\\ \\big( \\lambda w.\\, ((g\\ w)\\ z) \\big) \\Big)\n$$\n由于 $t$ 和 $t'$ 是 alpha 等价的（$t \\equiv_\\alpha t'$），它们具有相同的自由变量集合，即 $\\mathrm{FV}(t) = \\mathrm{FV}(t')$。现在我们可以通过递归应用定义来计算 $\\mathrm{FV}(t')$。\n\n设 $B$ 为 $t'$ 中主 lambda 抽象的体：\n$$\nB \\;=\\; \\big( (f\\ x)\\ y \\big)\\ \\big( \\lambda w.\\, ((g\\ w)\\ z) \\big)\n$$\n根据 lambda 抽象的定义：\n$$\n\\mathrm{FV}(t') = \\mathrm{FV}(\\lambda x. B) = \\mathrm{FV}(B) \\setminus \\{x\\}\n$$\n现在，我们计算 $\\mathrm{FV}(B)$。根据应用的定义：\n$$\n\\mathrm{FV}(B) = \\mathrm{FV}\\big( (f\\ x)\\ y \\big) \\cup \\mathrm{FV}\\big( \\lambda w.\\, ((g\\ w)\\ z) \\big)\n$$\n让我们分别计算每个部分的自由变量。\n\n对于第一部分，$\\mathrm{FV}\\big( (f\\ x)\\ y \\big)$：\n$$\n\\mathrm{FV}\\big( (f\\ x)\\ y \\big) = \\mathrm{FV}(f\\ x) \\cup \\mathrm{FV}(y)\n$$\n$$\n= \\big( \\mathrm{FV}(f) \\cup \\mathrm{FV}(x) \\big) \\cup \\mathrm{FV}(y)\n$$\n对每个变量应用基本情况 $\\mathrm{FV}(v) = \\{v\\}$：\n$$\n= \\big( \\{f\\} \\cup \\{x\\} \\big) \\cup \\{y\\} = \\{f, x, y\\}\n$$\n这个表达式中的变量 $y$ 显然是自由的。\n\n对于第二部分，$\\mathrm{FV}\\big( \\lambda w.\\, ((g\\ w)\\ z) \\big)$：\n$$\n\\mathrm{FV}\\big( \\lambda w.\\, ((g\\ w)\\ z) \\big) = \\mathrm{FV}\\big( ((g\\ w)\\ z) \\big) \\setminus \\{w\\}\n$$\n首先，我们找出体 $((g\\ w)\\ z)$ 的自由变量：\n$$\n\\mathrm{FV}\\big( ((g\\ w)\\ z) \\big) = \\mathrm{FV}(g\\ w) \\cup \\mathrm{FV}(z) = \\big(\\mathrm{FV}(g) \\cup \\mathrm{FV}(w)\\big) \\cup \\mathrm{FV}(z)\n$$\n$$\n= \\big(\\{g\\} \\cup \\{w\\}\\big) \\cup \\{z\\} = \\{g, w, z\\}\n$$\n现在，我们移除约束变量 $w$：\n$$\n\\mathrm{FV}\\big( \\lambda w.\\, ((g\\ w)\\ z) \\big) = \\{g, w, z\\} \\setminus \\{w\\} = \\{g, z\\}\n$$\n\n现在，我们合并结果以求得 $\\mathrm{FV}(B)$：\n$$\n\\mathrm{FV}(B) = \\{f, x, y\\} \\cup \\{g, z\\} = \\{f, x, y, g, z\\}\n$$\n最后，我们通过移除被最外层 lambda 绑定的变量 $x$ 来计算 $\\mathrm{FV}(t')$：\n$$\n\\mathrm{FV}(t') = \\mathrm{FV}(B) \\setminus \\{x\\} = \\{f, x, y, g, z\\} \\setminus \\{x\\} = \\{f, y, g, z\\}\n$$\n由于 $\\mathrm{FV}(t) = \\mathrm{FV}(t')$，原始项 $t$ 的自由变量集合是 $\\{f, y, g, z\\}$。\n\n每个变量的理由说明：\n- $f$：它在应用 $((f\\ x)\\ y)$ 中作为函数出现，并且没有被任何 lambda 抽象所约束。因此，$f$ 是自由的。\n- $g$：它在内部 lambda 的应用 $((g\\ y)\\ z)$ 中作为函数出现，但既不受 $\\lambda y$（重命名后为 $\\lambda w$）约束，也不受外部的 $\\lambda x$ 约束。因此，$g$ 是自由的。\n- $y$：在 $((f\\ x)\\ y)$ 中出现的 $y$ 不在内部 $\\lambda y$ 绑定符的作用域内。它仅处于外部 $\\lambda x$ 绑定符的作用域内，而后者绑定的是 $x$，不是 $y$。因此，这个出现的 $y$ 是自由的。在 $\\lambda y. g(y,z)$ 中出现的 $y$ 是被绑定的，因此对整个项的自由变量集合没有贡献。\n- $z$：它在 $((g\\ y)\\ z)$ 中作为参数出现，并且不受内部 $\\lambda y$ 或外部 $\\lambda x$ 的约束。因此，$z$ 是自由的。\n- $x$：它出现在 $((f\\ x)\\ y)$ 中，但被最外层的抽象 $\\lambda x$ 所约束。因此，$x$ 不是自由的。", "answer": "$$\n\\boxed{\\{f, g, y, z\\}}\n$$", "id": "3060306"}, {"introduction": "虽然不同的自由变量集合可以证明两个项不等价，但相同的自由变量集合并不能自动证明它们等价。这最后一个练习 [@problem_id:3060326] 要求你进行一个更进一步的挑战：正式证明两个项是 α-等价的，即使其中一个项包含由变量遮蔽所造成的“空洞”绑定。通过系统地应用避免捕获的重命名步骤，你将看到表面上看起来不同的表达式如何能够代表相同的底层逻辑结构。", "problem": "考虑无类型 $\\lambda$-演算项 $t_{1} = \\lambda x.(\\lambda x.(x\\ x))$ 和 $t_{2} = \\lambda y.(\\lambda z.(z\\ z))$。请仅使用自由变量和约束变量、避免捕获的 $\\alpha$ 转换的形式化定义，以及将 $\\alpha$ 等价性定义为在避免捕获的约束变量重命名下封闭的最小同余关系的归纳定义，来判断 $t_{1}$ 和 $t_{2}$ 是否是 $\\alpha$ 等价的。您的推导过程必须通过验证相关的自由变量边条件来明确证明每个重命名步骤的合理性，并且必须解释这些项中是如何处理变量遮蔽的。\n\n请以单个数字形式提供您的最终答案：如果 $t_{1}$ 和 $t_{2}$ 是 $\\alpha$ 等价的，则写 $1$，否则写 $0$。不需要四舍五入。不要包含任何单位。", "solution": "问题是判断两个 $\\lambda$-演算项 $t_1 = \\lambda x.(\\lambda x.(x\\ x))$ 和 $t_2 = \\lambda y.(\\lambda z.(z\\ z))$ 是否 $\\alpha$ 等价。我们将通过严格应用自由变量、避免捕获的 $\\alpha$ 转换和 $\\alpha$ 等价的形式化定义来进行判断。\n\n首先，我们陈述必要的定义。\n一个项 $M$ 的自由变量集合，记作 $FV(M)$，被归纳定义如下：\n1.  对于任意变量 $v$，$FV(v) = \\{v\\}$。\n2.  对于任意项 $M$ 和 $N$，$FV(M\\ N) = FV(M) \\cup FV(N)$。\n3.  对于任意变量 $v$ 和项 $M$，$FV(\\lambda v.M) = FV(M) \\setminus \\{v\\}$。\n\n一个项中出现的变量 $v$ 如果在一个形如 $\\lambda v.M$ 的子项内，则它是约束的。如果一个出现不是约束的，则它是自由的。在具有相同变量名的嵌套抽象的情况下，一个变量的出现被最内层的抽象所约束。这种现象被称为变量遮蔽。\n\n避免捕获的 $\\alpha$ 转换（或重命名）规定，对于一个抽象 $\\lambda x.M$，我们可以将约束变量 $x$ 重命名为一个新变量 $y$，写作 $\\lambda x.M \\to_\\alpha \\lambda y.(M[x \\mapsto y])$，当且仅当 $y$ 不在 $M$ 中作为自由变量出现（即 $y \\notin FV(M)$）且 $y$ 不等于 $x$。符号 $M[x \\mapsto y]$ 表示将 $M$ 中所有自由出现的 $x$ 替换为 $y$。\n\n$\\alpha$ 等价，记作 $=_\\alpha$，是包含 $\\to_\\alpha$ 的最小等价关系。它是一种同余关系，意味着它在项构造子下是保持的。具体来说：\n- 如果 $M =_\\alpha N$，那么 $\\lambda v.M =_\\alpha \\lambda v.N$。\n- 如果 $M_1 =_\\alpha M_2$ 且 $N_1 =_\\alpha N_2$，那么 $(M_1\\ N_1) =_\\alpha (M_2\\ N_2)$。\n\n我们现在来分析项 $t_1 = \\lambda x.(\\lambda x.(x\\ x))$。这个项表现出变量遮蔽。外部的绑定符是 $\\lambda x$，其作用域是项 $M_1 = \\lambda x.(x\\ x)$。内部的绑定符也是 $\\lambda x$，其作用域是项 $M_2 = (x\\ x)$。在 $(x\\ x)$ 中变量 $x$ 的两次出现都在两个绑定符的作用域内。然而，根据最内层作用域规则，它们被内部的 $\\lambda x$ 所约束。因此，在外部抽象的项体中没有自由出现的 $x$ 可供其绑定。为了形式化地验证这一点，我们计算外部 $\\lambda x$ 的项体（即项 $M_1$）的自由变量：\n$FV(M_1) = FV(\\lambda x.(x\\ x)) = FV(x\\ x) \\setminus \\{x\\}$。\n$FV(x\\ x) = FV(x) \\cup FV(x) = \\{x\\} \\cup \\{x\\} = \\{x\\}$。\n因此，$FV(M_1) = \\{x\\} \\setminus \\{x\\} = \\emptyset$。\n由于外部抽象 $\\lambda x$ 的项体没有自由变量，这个绑定符是空泛的。\n\n接下来，我们分析项 $t_2 = \\lambda y.(\\lambda z.(z\\ z))$。外部抽象 $\\lambda y$ 的项体是项 $N = \\lambda z.(z\\ z)$。我们计算其自由变量：\n$FV(N) = FV(\\lambda z.(z\\ z)) = FV(z\\ z) \\setminus \\{z\\}$。\n$FV(z\\ z) = FV(z) \\cup FV(z) = \\{z\\} \\cup \\{z\\} = \\{z\\}$。\n因此，$FV(N) = \\{z\\} \\setminus \\{z\\} = \\emptyset$。\n与 $t_1$ 类似，$t_2$ 中的外部绑定符 $\\lambda y$ 也是空泛的。\n\n现在我们可以构造一个 $\\alpha$ 等价链来检查是否 $t_1 =_\\alpha t_2$。策略是证明两个项都可以被转换为一个公共形式。\n\n步骤 1：重命名 $t_1$ 的外部约束变量。\n我们有 $t_1 = \\lambda x.M_1$，其中 $M_1 = \\lambda x.(x\\ x)$。我们想将外部的 $x$ 重命名为 $y$ 以匹配 $t_2$ 的外部变量。$\\alpha$ 转换的规则是，如果 $y \\notin FV(M_1)$，则 $\\lambda x.M_1 \\to_\\alpha \\lambda y.(M_1[x \\mapsto y])$。我们已经计算出 $FV(M_1) = \\emptyset$。对于任何变量 $y$，条件 $y \\notin \\emptyset$ 都是平凡成立的。替换 $M_1[x \\mapsto y]$ 意味着我们将 $M_1$ 中所有自由出现的 $x$ 替换为 $y$。由于 $M_1$ 中没有自由出现的 $x$，替换没有任何效果：$M_1[x \\mapsto y] = M_1$。\n因此，我们有 $t_1 = \\lambda x.(\\lambda x.(x\\ x)) =_\\alpha \\lambda y.(\\lambda x.(x\\ x))$。\n\n步骤 2：重命名新项的内部约束变量。\n新项是 $\\lambda y.(\\lambda x.(x\\ x))$。让我们关注其项体 $\\lambda x.(x\\ x)$。我们想将约束变量 $x$ 重命名为 $z$ 以匹配 $t_2$ 的内部结构。这个内部抽象的项体是 $(x\\ x)$。该项体中的自由变量集合是 $FV(x\\ x) = \\{x\\}$。重命名条件是新变量 $z$ 不在该集合中。假设 $z$ 是一个与 $x$ 不同的变量，条件 $z \\notin \\{x\\}$ 成立。\n替换是 $(x\\ x)[x \\mapsto z]$，结果为 $(z\\ z)$。\n因此，$\\lambda x.(x\\ x) =_\\alpha \\lambda z.((x\\ x)[x \\mapsto z]) = \\lambda z.(z\\ z)$。\n\n步骤 3：应用同余性质。\n由于 $\\lambda x.(x\\ x) =_\\alpha \\lambda z.(z\\ z)$，抽象的同余规则允许我们在步骤 1 的较大表达式中替换等价的项：\n$\\lambda y.(\\lambda x.(x\\ x)) =_\\alpha \\lambda y.(\\lambda z.(z\\ z))$。\n\n步骤 4：合并步骤。\n通过 $\\alpha$ 等价的传递性，我们合并我们各步骤的结果：\n$t_1 = \\lambda x.(\\lambda x.(x\\ x))$\n$=_\\alpha \\lambda y.(\\lambda x.(x\\ x))$ (来自步骤 1)\n$=_\\alpha \\lambda y.(\\lambda z.(z\\ z))$ (来自步骤 2 和 3)\n最终得到的项 $\\lambda y.(\\lambda z.(z\\ z))$ 正是 $t_2$。\n因此，我们已形式化地证明了 $t_1 =_\\alpha t_2$。\n\n此等价关系的关键在于 $t_1$ 中存在的变量遮蔽。外部的 $\\lambda x$ 是一个空泛的绑定符，意味着它不绑定任何变量的出现。因此，它可以被重命名为任何其他变量（如 $y$）而不会改变项的含义，因为那个新变量也将是一个空泛的绑定符。一旦外部变量匹配，内部的抽象 $\\lambda x.(x\\ x)$ 和 $\\lambda z.(z\\ z)$ 就可以通过对其各自约束变量的简单重命名而直接地被证明是 $\\alpha$ 等价的。\n\n因为 $t_1$ 与 $t_2$ 是 $\\alpha$ 等价的，所以答案是 $1$。", "answer": "$$\\boxed{1}$$", "id": "3060326"}]}