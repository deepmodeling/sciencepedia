{"hands_on_practices": [{"introduction": "阿克曼函数以其惊人的增长速度而闻名，但其初始层级实际上与我们熟悉的算术运算紧密相关。这个练习将引导你手动展开并求解阿克曼函数的前几个层级 ($m=0, 1, 2$)。通过这个过程 [@problem_id:3049711]，你不仅能熟练掌握其递归定义，还能直观地看到它是如何从简单的后继函数和加法开始构建更为复杂运算的。", "problem": "设 $\\mathbb{N}=\\{0,1,2,\\dots\\}$。考虑由以下基本定义式定义的二元 Ackermann–Péter 函数 $A:\\mathbb{N}\\times\\mathbb{N}\\to\\mathbb{N}$：\n$$\nA(0,n)=n+1,\\quad A(m+1,0)=A(m,1),\\quad A(m+1,n+1)=A\\bigl(m,\\,A(m+1,n)\\bigr),\n$$\n对所有 $m,n\\in\\mathbb{N}$ 成立。仅使用这些定义式，并在适当时对 $n$ 使用数学归纳法，推导三个一元函数 $n\\mapsto A(0,n)$、$n\\mapsto A(1,n)$ 和 $n\\mapsto A(2,n)$ 关于 $n$ 的显式封闭形式，并通过基于给定定义方程的完整归纳论证来验证每一个结果。将您的最终结果以行矩阵 $\\bigl(A(0,n)\\;A(1,n)\\;A(2,n)\\bigr)$ 的形式报告，作为一个不含自由参数的关于 $n$ 的封闭形式表达式。不需要数值近似。", "solution": "任务是基于 Ackermann-Péter 函数 $A:\\mathbb{N}\\times\\mathbb{N}\\to\\mathbb{N}$ 的定义式，找出并验证函数 $n \\mapsto A(0,n)$、$n \\mapsto A(1,n)$ 和 $n \\mapsto A(2,n)$ 的封闭形式表达式，其中 $\\mathbb{N}=\\{0,1,2,\\dots\\}$。定义式如下：\n$$\n\\begin{align*}\nA(0,n) = n+1 \\quad (1) \\\\\nA(m+1,0) = A(m,1) \\quad (2) \\\\\nA(m+1,n+1) = A\\bigl(m,\\,A(m+1,n)\\bigr) \\quad (3)\n\\end{align*}\n$$\n我们将依次处理 $m=0, 1, 2$ 的每种情况。\n\n**情况 1：$A(0,n)$ 的推导与验证**\n\n$A(0,n)$ 的封闭形式由定义的条款 (1) 明确给出：\n$$\nA(0,n) = n+1\n$$\n根据定义，此方程对所有 $n \\in \\mathbb{N}$ 成立。题目要求通过完整的归纳论证进行验证。然而，由于待证性质 $P(n): A(0,n)=n+1$ 本身就是该函数对所有 $n$ 的基本定义条款之一，因此归纳证明将成为一个重言式。该公式根据公理对所有 $n \\in \\mathbb{N}$ 成立，无需进一步验证。\n\n**情况 2：$A(1,n)$ 的推导与验证**\n\n我们寻求 $A(1,n)$ 的封闭形式。首先，我们建立一个关于 $n$ 的 $A(1,n)$ 的递推关系。使用条款 (3)，令 $m=0$：\n$$\nA(1,n+1) = A(0, A(1,n))\n$$\n根据 $m=0$ 的结果，我们知道对任意 $x \\in \\mathbb{N}$，有 $A(0,x) = x+1$。代入 $x=A(1,n)$，我们得到：\n$$\nA(1,n+1) = A(1,n) + 1\n$$\n这是一个一阶线性递推关系。为了找到唯一解，我们需要一个 $n=0$ 的基本情况。使用条款 (2)，令 $m=0$：\n$$\nA(1,0) = A(0,1)\n$$\n使用 $A(0,n)$ 的公式，我们发现 $A(0,1) = 1+1=2$。因此，基本情况是 $A(1,0)=2$。\n展开递推关系 $A(1,n+1) = A(1,n)+1$：\n$$\nA(1,n) = A(1,n-1)+1 = A(1,n-2)+2 = \\dots = A(1,0) + n\n$$\n代入基本情况 $A(1,0)=2$，我们推导出封闭形式：\n$$\nA(1,n) = n+2\n$$\n现在，我们按要求对 $n$ 进行归纳来验证这个结果。设 $P(n)$ 为命题 $A(1,n)=n+2$。\n\n**基本情况 ($n=0$)：**\n我们必须证明 $P(0)$ 为真，即 $A(1,0)=0+2=2$。\n根据条款 (2)，令 $m=0$，有 $A(1,0)=A(0,1)$。\n根据条款 (1)，令 $n=1$，有 $A(0,1)=1+1=2$。\n因此，$A(1,0)=2$，基本情况成立。\n\n**归纳假设：**\n假设对某个任意的 $k \\in \\mathbb{N}$，$P(k)$ 为真，即 $A(1,k)=k+2$。\n\n**归纳步骤：**\n我们必须证明 $P(k+1)$ 为真，即 $A(1,k+1)=(k+1)+2=k+3$。\n根据条款 (3)，令 $m=0$ 和 $n=k$：\n$$\nA(1,k+1) = A(0, A(1,k))\n$$\n应用归纳假设 $A(1,k)=k+2$，我们得到：\n$$\nA(1,k+1) = A(0, k+2)\n$$\n根据条款 (1)，我们知道 $A(0,x)=x+1$。设 $x=k+2$：\n$$\nA(1,k+1) = (k+2)+1 = k+3\n$$\n这完成了归纳步骤。根据数学归纳法原理，$A(1,n)=n+2$ 对所有 $n \\in \\mathbb{N}$ 成立。\n\n**情况 3：$A(2,n)$ 的推导与验证**\n\n我们对 $A(2,n)$ 采用类似的方法。我们使用条款 (3) 并令 $m=1$ 来建立一个递推关系：\n$$\nA(2,n+1) = A(1, A(2,n))\n$$\n根据我们对 $m=1$ 的已验证结果，我们知道 $A(1,x) = x+2$。代入 $x=A(2,n)$：\n$$\nA(2,n+1) = A(2,n) + 2\n$$\n这是另一个一阶线性递推关系。使用条款 (2) 并令 $m=1$ 可找到 $n=0$ 的基本情况：\n$$\nA(2,0) = A(1,1)\n$$\n使用 $A(1,n)$ 的公式，我们发现 $A(1,1)=1+2=3$。因此，基本情况是 $A(2,0)=3$。\n展开递推关系 $A(2,n+1) = A(2,n)+2$：\n$$\nA(2,n) = A(2,n-1)+2 = A(2,n-2)+2\\cdot 2 = \\dots = A(2,0) + n\\cdot 2\n$$\n代入基本情况 $A(2,0)=3$，我们推导出封闭形式：\n$$\nA(2,n) = 2n+3\n$$\n现在我们对 $n$ 进行归纳来验证这个结果。设 $Q(n)$ 为命题 $A(2,n)=2n+3$。\n\n**基本情况 ($n=0$)：**\n我们必须证明 $Q(0)$ 为真，即 $A(2,0)=2(0)+3=3$。\n根据条款 (2)，令 $m=1$，有 $A(2,0)=A(1,1)$。\n根据我们已证明的 $A(1,n)$ 的公式，$A(1,1)=1+2=3$。\n因此，$A(2,0)=3$，基本情况成立。\n\n**归纳假设：**\n假设对某个任意的 $k \\in \\mathbb{N}$，$Q(k)$ 为真，即 $A(2,k)=2k+3$。\n\n**归纳步骤：**\n我们必须证明 $Q(k+1)$ 为真，即 $A(2,k+1)=2(k+1)+3=2k+5$。\n根据条款 (3)，令 $m=1$ 和 $n=k$：\n$$\nA(2,k+1) = A(1, A(2,k))\n$$\n应用归纳假设 $A(2,k)=2k+3$，我们得到：\n$$\nA(2,k+1) = A(1, 2k+3)\n$$\n根据我们已证明的 $A(1,n)$ 的公式，我们知道 $A(1,x)=x+2$。设 $x=2k+3$：\n$$\nA(2,k+1) = (2k+3)+2 = 2k+5\n$$\n这完成了归纳步骤。根据数学归纳法原理，$A(2,n)=2n+3$ 对所有 $n \\in \\mathbb{N}$ 成立。\n\n总之，封闭形式表达式为 $A(0,n)=n+1$、$A(1,n)=n+2$ 和 $A(2,n)=2n+3$。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\nn+1  n+2  2n+3\n\\end{pmatrix}\n}\n$$", "id": "3049711"}, {"introduction": "在熟悉了阿克曼函数的前几个线性增长的层级之后，我们将探索其第一个展现出超增长特性的层级。本练习要求你推导出 $A(3,n)$ 的闭合形式，你将会发现其结果是一个指数函数 [@problem_id:3049702]。这个实践将具体展示阿克曼函数增长速度的急剧飞跃，帮助你理解为何它被视为计算理论中一个关键的非原始递归增长的例子。", "problem": "设 $A(m,n)$ 表示定义在 $\\mathbb{N} \\times \\mathbb{N}$ 上的经典双变量阿克曼函数，其基本定义条款如下：\n1. 对所有 $n \\in \\mathbb{N}$，有 $A(0,n)=n+1$，\n2. 对所有 $m \\in \\mathbb{N}$，有 $A(m+1,0)=A(m,1)$，\n3. 对所有 $m,n \\in \\mathbb{N}$，有 $A(m+1,n+1)=A(m, A(m+1,n))$。\n\n对于一个固定的 $m \\in \\mathbb{N}$，映射 $n \\mapsto A(m,n)$ 是通过上述定义条款以原始递归方式得到的。对所有 $n \\in \\mathbb{N}$，定义 $T_n := A(3,n)$。\n\n仅从上述三条定义条款和原始递归的概念出发（不使用任何预先记下的封闭形式），完成以下任务：\n- 根据定义条款，显式计算 $T_0$。\n- 通过使用定义条款将 $A(3,n+1)$ 表示为 $A(3,n)$ 的函数，推导出 $T_n$ 满足的一个形如 $T_{n+1}=\\alpha\\,T_n+\\beta$（其中常数 $\\alpha,\\beta \\in \\mathbb{Z}$）的一阶线性递推关系。\n- 使用你计算出的初始值求解此递推关系，并化简得到对所有 $n \\in \\mathbb{N}$ 都有效的 $A(3,n)$ 的封闭形式解析表达式。\n\n将你的最终答案表示为一个关于 $n$ 的单一简化解析表达式。无需进行数值四舍五入。", "solution": "问题是要求解 $A(3,n)$ 的封闭形式解析表达式，其中 $A(m,n)$ 是由给定条款定义的阿克曼函数。推导必须从第一性原理出发，不使用任何预先记下的关于 $A(m,n)$ 的公式。我们将遵循指定的步骤：计算初始值 $A(3,0)$，推导 $A(3,n)$ 的递推关系，并求解它。\n\n为了系统地完成这个任务，我们首先需要理解 $m=1$ 和 $m=2$ 时 $A(m,n)$ 的行为，因为 $A(3,n)$ 的定义依赖于它们。\n\n首先，我们来求 $A(1,n)$ 的封闭形式。\n根据条款2，初始值为 $A(1,0) = A(0+1, 0) = A(0,1)$。\n根据条款1，$A(0,1) = 1+1 = 2$。因此，$A(1,0)=2$。\n对于递推步骤，我们使用条款3：$A(1,n+1) = A(0+1,n+1) = A(0, A(1,n))$。\n使用条款1，对任意 $k \\in \\mathbb{N}$ 有 $A(0,k) = k+1$。将其应用于我们的情况，其中 $k = A(1,n)$，我们得到：\n$$A(1,n+1) = A(1,n) + 1$$\n这是一个简单的等差数列。我们可以推导出 $A(1,n)$ 的封闭形式，并通过归纳法证明它。我们断言 $A(1,n) = n+2$。\n基础情形 ($n=0$)：$A(1,0) = 0+2 = 2$，这与我们计算出的值相符。\n归纳步骤：假设对某个 $k \\in \\mathbb{N}$，有 $A(1,k) = k+2$。我们必须证明 $A(1,k+1) = (k+1)+2 = k+3$。\n从递推关系可知，$A(1,k+1) = A(1,k)+1$。使用归纳假设，$A(1,k+1) = (k+2)+1 = k+3$。该公式是正确的。\n所以，对所有 $n \\in \\mathbb{N}$，有 $A(1,n)=n+2$。\n\n接下来，我们求 $A(2,n)$ 的封闭形式。\n根据条款2，初始值为 $A(2,0) = A(1+1, 0) = A(1,1)$。\n使用我们关于 $A(1,n)$ 的结果，我们有 $A(1,1) = 1+2 = 3$。因此，$A(2,0)=3$。\n对于递推步骤，我们使用条款3：$A(2,n+1) = A(1+1,n+1) = A(1, A(2,n))$。\n使用我们推导出的公式 $A(1,k) = k+2$，并令 $k=A(2,n)$，我们得到：\n$$A(2,n+1) = A(2,n) + 2$$\n这是一个首项为 $A(2,0)=3$、公差为 2 的等差数列。其封闭形式为 $A(2,n) = A(2,0) + 2n = 3+2n$。\n我们通过归纳法验证这一点。我们断言 $A(2,n) = 2n+3$。\n基础情形 ($n=0$)：$A(2,0) = 2(0)+3 = 3$，这与我们计算出的值相符。\n归纳步骤：假设对某个 $k \\in \\mathbb{N}$，有 $A(2,k)=2k+3$。我们必须证明 $A(2,k+1) = 2(k+1)+3 = 2k+5$。\n从递推关系可知，$A(2,k+1) = A(2,k)+2$。使用归纳假设，$A(2,k+1) = (2k+3)+2 = 2k+5$。该公式是正确的。\n所以，对所有 $n \\in \\mathbb{N}$，有 $A(2,n)=2n+3$。\n\n现在我们可以处理关于 $T_n = A(3,n)$ 的具体任务了。\n\n1.  计算 $T_0$：\n    $T_0 = A(3,0)$。根据条款2，$A(3,0) = A(2+1,0) = A(2,1)$。\n    使用我们推导出的关于 $A(2,n)$ 的公式，我们有 $A(2,1) = 2(1)+3 = 5$。\n    因此，$T_0=5$。\n\n2.  推导 $T_n$ 的递推关系：\n    我们考虑 $T_{n+1} = A(3,n+1)$。根据条款3，$A(3,n+1) = A(2+1,n+1) = A(2, A(3,n))$。\n    代入 $T_n=A(3,n)$，我们得到 $T_{n+1} = A(2, T_n)$。\n    使用我们推导出的公式 $A(2,k)=2k+3$ 并令 $k=T_n$，这就变成了：\n    $$T_{n+1} = 2T_n + 3$$\n    这就是所需的一阶线性递推关系，其中常数为 $\\alpha=2$ 和 $\\beta=3$。\n\n3.  求解递推关系以求得 $A(3,n)$ 的封闭形式：\n    我们必须解递推关系 $T_{n+1} = 2T_n + 3$ 以及初始条件 $T_0=5$。\n    这是一个线性非齐次递推关系。我们通过将齐次解与一个特解相加来求其通解。\n    齐次部分是 $T_{n+1}^{(h)} = 2T_n^{(h)}$，其解为 $T_n^{(h)} = C \\cdot 2^n$，其中 $C$ 是某个常数。\n    对于一个特解，由于非齐次项是常数 $3$，我们尝试一个常数特解 $T_n^{(p)} = K$。\n    代入递推关系中：$K = 2K + 3 \\implies -K = 3 \\implies K = -3$。\n    通解是齐次解与特解之和，即 $T_n = T_n^{(h)} + T_n^{(p)} = C \\cdot 2^n - 3$。\n    我们使用初始条件 $T_0=5$ 来确定常数 $C$：\n    $T_0 = C \\cdot 2^0 - 3 = C - 3$。\n    $5 = C - 3 \\implies C = 8$。\n    因此，特定的解是 $T_n = 8 \\cdot 2^n - 3$。\n    这可以化简为：$T_n = 2^3 \\cdot 2^n - 3 = 2^{n+3} - 3$。\n\n对所有 $n \\in \\mathbb{N}$ 都有效的 $A(3,n)$ 的封闭形式解析表达式是 $A(3,n) = 2^{n+3} - 3$。", "answer": "$$\\boxed{2^{n+3} - 3}$$", "id": "3049702"}, {"introduction": "虽然阿克曼函数不是原始递归的，但原始递归函数类本身却异常强大，能够涵盖许多直观上可计算的函数。这个练习旨在通过一个经典的例子——斐波那契数列，来展示原始递归的构造能力，你需要使用状态编码技术来构建一个看似需要多于一个先前值的递归 [@problem_id:3049701]。这项实践对于理解原始递归的形式化定义以及计算模型如何通过巧妙的编码来克服表面上的限制至关重要。", "problem": "设 $\\mathbb{N}$ 表示包含 $0$ 的自然数集。在原始递归的框架下，如果一个函数可以从初始函数——零函数 $Z(x)=0$、后继函数 $S(x)=x+1$ 和投影函数 $P^{n}_{i}(x_{0},\\dots,x_{n-1})=x_{i}$——通过有限次应用复合和原始递归模式得到，则该函数称为原始递归（PR）函数：给定函数 $f$ 和 $g$，由 $h(0,\\vec{x})=f(\\vec{x})$ 和 $h(n+1,\\vec{x})=g(n,h(n,\\vec{x}),\\vec{x})$ 定义的函数 $h$ 是原始递归的。\n\n你的任务是，仅使用从初始函数开始的原始递归定义，构造一个原始递归函数 $\\mathrm{Fib}:\\mathbb{N}\\to\\mathbb{N}$，它将 $n$ 映射到第 $n$ 个斐波那契数 $F_{n}$，其中 $F_{0}=0$，$F_{1}=1$，且对于所有 $n\\geq 1$ 有 $F_{n+1}=F_{n}+F_{n-1}$。你必须通过对 $n$ 的有界递归和状态的配对累积编码来完成此任务，其中有序对 $(a,b)$ 被编码为单个自然数\n$$E(a,b)=2^{a}\\cdot 3^{b}。$$\n具体来说：\n- 从基本原理出发，定义实现 $E$ 下的配对编码和解码所需的辅助原始递归函数，包括幂运算 $p^{k}$、相等性检验、有界整除谓词，以及分别返回能整除 $m$ 的 $2$ 和 $3$ 的最大指数的素数指数函数 $v_{2}(m)$ 和 $v_{3}(m)$。\n- 定义一个作用于编码的原始递归更新函数 $U$，对于给定的 $e=E(a,b)$，它返回下一个编码 $E(b,a+b)$，且不脱离原始递归框架。\n- 通过对 $n$ 的原始递归定义一个原始递归函数 $G$，其基例为 $G(0)=E(F_{0},F_{1})$，步骤为 $G(n+1)=U(G(n))$，并设 $\\mathrm{Fib}(n)=v_{2}(G(n))$。\n- 在每一步中，证明所构造的函数是原始递归的，并且 $G(n)$ 的语义对应于所需的目标对 $(F_{n},F_{n+1})$。\n\n最后，计算 $\\mathrm{Fib}(9)$。将最终答案以单个整数形式给出。无需四舍五入。", "solution": "该问题要求将斐波那契函数构造为一个原始递归（PR）函数，从初始原始递归函数开始，并仅使用复合和原始递归模式。指定的方法涉及对数字对进行编码，并基于这些编码定义一个递归函数。我们将首先构建必要的辅助原始递归函数，然后构造主函数，证明其性质，最后计算所要求的值。\n\n**1. 基础原始递归函数**\n\n初始函数是零函数 $Z(x)=0$、后继函数 $S(x)=x+1$ 和投影函数 $P^{n}_{i}(\\vec{x}) = x_i$。所有其他原始递归函数都由这些函数构建。\n\n- **加法**: $\\mathrm{add}(x,y)$，记作 $x+y$。\n  $\\mathrm{add}(x,0) = x$\n  $\\mathrm{add}(x, S(y)) = S(\\mathrm{add}(x,y))$\n  这是原始递归模式的一个应用，因此加法是原始递归的。\n\n- **乘法**: $\\mathrm{mult}(x,y)$，记作 $x \\cdot y$。\n  $\\mathrm{mult}(x,0) = 0$\n  $\\mathrm{mult}(x, S(y)) = \\mathrm{add}(x, \\mathrm{mult}(x,y))$\n  这是原始递归的，因为它通过使用已经建立的原始递归函数——加法——进行递归定义。\n\n- **幂运算**: $\\mathrm{expn}(x,y)$，记作 $x^y$。\n  $\\mathrm{expn}(x,0) = S(Z(x)) = 1$\n  $\\mathrm{expn}(x, S(y)) = \\mathrm{mult}(x, \\mathrm{expn}(x,y))$\n  这是原始递归的，通过使用乘法进行递归定义。\n\n- **前驱函数**: $\\mathrm{pred}(x)$。\n  $\\mathrm{pred}(0) = 0$\n  $\\mathrm{pred}(S(x)) = x$\n  这通过递归模式是原始递归的。\n\n- **正常减法**: $\\mathrm{sub}(x,y)$，记作 $x-y$。如果 $x \\ge y$，它返回 $x-y$，否则返回 $0$。\n  $\\mathrm{sub}(x,0) = x$\n  $\\mathrm{sub}(x, S(y)) = \\mathrm{pred}(\\mathrm{sub}(x,y))$\n  这是原始递归的，通过使用前驱函数进行递归定义。\n\n**2. 原始递归谓词和有界运算**\n\n谓词由其特征函数表示，真时返回 $1$，假时返回 $0$。\n\n- **符号函数 (非零的特征函数)**: $\\mathrm{sg}(x)$。\n  $\\mathrm{sg}(0) = 0$\n  $\\mathrm{sg}(x+1) = 1$\n  这是原始递归的。\n\n- **零检验 (零的特征函数)**: $\\mathrm{is\\_zero}(x)$。\n  $\\mathrm{is\\_zero}(x) = 1 - \\mathrm{sg}(x)$。这是原始递归函数的复合，因此是原始递归的。\n\n- **相等性检验**: $\\mathrm{eq}(x,y)$。\n  两个数 $x$ 和 $y$ 相等，当且仅当 $x-y=0$ 和 $y-x=0$ 同时成立。\n  $\\mathrm{eq}(x,y) = \\mathrm{is\\_zero}((x-y) + (y-x))$。这是原始递归函数的复合，因此是原始递归的。\n\n- **有界和与有界积**: 如果 $f(i, \\vec{z})$ 是一个原始递归函数，那么有界和 $g(y, \\vec{z}) = \\sum_{i=0}^{y} f(i, \\vec{z})$ 和有界积 $h(y, \\vec{z}) = \\prod_{i=0}^{y} f(i, \\vec{z})$ 也是原始递归的，因为它们可以通过原始递归来定义。\n\n- **有界整除谓词**: $\\mathrm{divides}(d,n)$。如果 $d|n$ 且 $d \\neq 0$，此函数为 $1$，否则为 $0$。为简单起见，我们假设 $d0$，将 $d=0$ 作为特殊情况处理。语句“$d$ 整除 $n$”等价于“存在一个 $k$ 满足 $0 \\le k \\le n$，使得 $n = d \\cdot k$”。\n  这个有界存在量化的特征函数 $(\\exists k \\le n)[\\mathrm{eq}(n, d \\cdot k)=1]$ 可以定义为 $\\mathrm{sg}(\\sum_{k=0}^{n} \\mathrm{eq}(n, d \\cdot k))$。由于 $\\mathrm{eq}$、乘法和有界和都是原始递归的，它们的复合 $\\mathrm{divides}(d,n)$ 也是原始递归的。\n\n- **有界最大化**: 如果 $f(i)$ 是一个原始递归函数，那么 $g(y) = \\max_{i=0}^{y} f(i)$ 也是原始递归的。它可以由递归 $g(0) = f(0)$ 和 $g(y+1) = \\max(g(y), f(y+1))$ 定义，其中 $\\max(a,b) = a+(b-a)$ 是一个原始递归函数。\n\n**3. 编码和解码函数**\n\n问题指定了有序对 $(a,b)$ 的编码函数为 $E(a,b) = 2^a \\cdot 3^b$。解码函数 $v_{2}(m)$ 和 $v_{3}(m)$ 从整数 $m$ 中提取素数 $2$ 和 $3$ 的指数。\n\n- **素数指数函数**: $v_p(m)$ 是使得 $p^k$ 整除 $m$ 的最大整数 $k$。如果 $m=0$，$v_p(0)=0$。对于 $m0$，$p^k \\le m$，这意味着 $k \\le m$。因此，对 $k$ 的搜索是有界的，其界限为 $m$。\n  我们定义一个辅助函数 $H(k,m,p) = k \\cdot \\mathrm{divides}(p^k, m)$。这个函数是原始递归的。如果 $p^k|m$，它等于 $k$，否则为 $0$。\n  那么，$v_p(m) = \\max_{k=0}^{m} H(k,m,p)$。因为这是一个原始递归函数的有界最大化，所以 $v_p(m)$ 是原始递归的。\n  具体来说，所需的解码函数是：\n  $v_2(m) = \\max_{k=0}^{m} \\{ k \\cdot \\mathrm{divides}(2^k, m) \\}$。\n  $v_3(m) = \\max_{k=0}^{m} \\{ k \\cdot \\mathrm{divides}(3^k, m) \\}$。\n  $v_2(m)$ 和 $v_3(m)$ 都是原始递归的。\n\n**4. 斐波那契函数的递归构造**\n\n现在我们使用已开发的工具来构造斐波那契函数。递归的状态需要前两个斐波那契数 $(F_n, F_{n+1})$，它被存储在一个单一的整数编码中。\n\n- **更新函数 $U$**: 这个函数接收一个编码 $e = E(a,b) = 2^a \\cdot 3^b$ 并返回下一个状态的编码 $E(b, a+b) = 2^b \\cdot 3^{a+b}$。\n  为了计算这个，我们首先解码 $e$：$a = v_2(e)$ 和 $b = v_3(e)$。\n  然后我们计算新的指数：新的以2为底的指数是 $b=v_3(e)$，新的以3为底的指数是 $a+b = v_2(e)+v_3(e)$。\n  因此更新函数是 $U(e) = 2^{v_3(e)} \\cdot 3^{v_2(e) + v_3(e)}$。\n  由于 $v_2$、$v_3$、加法和幂运算都是原始递归的，它们的复合 $U(e)$ 也是一个原始递归函数。\n\n- **状态函数 $G$**: 这个函数迭代地应用更新函数 $U$。它由原始递归定义。\n  基例：$G(0) = E(F_0, F_1) = E(0,1) = 2^0 \\cdot 3^1 = 3$。这是一个常数函数，它是原始递归的。\n  递归步骤：$G(n+1) = U(G(n))$。\n  这符合原始递归模式 $h(n+1) = g(n, h(n))$，其中 $g(n,y) = U(y)$ 是原始递归的。因此，$G(n)$ 是一个原始递归函数。\n\n- **$G(n)$ 的正确性**: 我们用归纳法证明 $G(n) = E(F_n, F_{n+1}) = 2^{F_n} \\cdot 3^{F_{n+1}}$。\n  基例 ($n=0$)：$G(0) = 3 = 2^0 \\cdot 3^1 = E(0,1) = E(F_0, F_1)$。该性质成立。\n  归纳步骤：假设对于某个 $k \\ge 0$ 有 $G(k) = E(F_k, F_{k+1})$。\n  我们必须证明 $G(k+1) = E(F_{k+1}, F_{k+2})$。\n  根据定义，$G(k+1) = U(G(k))$。\n  使用归纳假设，$G(k) = 2^{F_k} \\cdot 3^{F_{k+1}}$。\n  由此，我们有 $v_2(G(k)) = F_k$ 和 $v_3(G(k)) = F_{k+1}$。\n  应用 $U$ 的定义：\n  $G(k+1) = U(G(k)) = 2^{v_3(G(k))} \\cdot 3^{v_2(G(k)) + v_3(G(k))} = 2^{F_{k+1}} \\cdot 3^{F_k + F_{k+1}}$。\n  根据斐波那契数列的定义，$F_{k+2} = F_{k+1} + F_k$。\n  因此，$G(k+1) = 2^{F_{k+1}} \\cdot 3^{F_{k+2}} = E(F_{k+1}, F_{k+2})$。\n  该性质对 $k+1$ 成立。根据归纳原理，$G(n)$ 的公式对所有 $n \\in \\mathbb{N}$ 都成立。\n\n- **斐波那契函数 $\\mathrm{Fib}(n)$**: 该函数定义为 $\\mathrm{Fib}(n) = v_2(G(n))$。\n  因为我们已经证明 $G(n) = 2^{F_n} \\cdot 3^{F_{n+1}}$，所以：\n  $\\mathrm{Fib}(n) = v_2(G(n)) = v_2(2^{F_n} \\cdot 3^{F_{n+1}}) = F_n$。\n  函数 $\\mathrm{Fib}(n)$ 是原始递归函数 $G$ 和 $v_2$ 的复合，因此它是一个正确计算第 $n$ 个斐波那契数的原始递归函数。\n\n**5. 最终计算**\n\n问题要求计算 $\\mathrm{Fib}(9)$。根据我们的构造，这等价于求第9个斐波那契数 $F_9$。\n$F_0 = 0$\n$F_1 = 1$\n$F_2 = F_1 + F_0 = 1+0=1$\n$F_3 = F_2 + F_1 = 1+1=2$\n$F_4 = F_3 + F_2 = 2+1=3$\n$F_5 = F_4 + F_3 = 3+2=5$\n$F_6 = F_5 + F_4 = 5+3=8$\n$F_7 = F_6 + F_5 = 8+5=13$\n$F_8 = F_7 + F_6 = 13+8=21$\n$F_9 = F_8 + F_7 = 21+13=34$\n\n因此，$\\mathrm{Fib}(9) = 34$。", "answer": "$$\\boxed{34}$$", "id": "3049701"}]}