{"hands_on_practices": [{"introduction": "归约是证明问题不可判定性的核心工具，但它的逻辑方向至关重要。本练习旨在阐明一个常见的概念误区：为了证明一个新问题 $P$ 是不可判定的，我们必须将一个已知的不可判定问题 $U$ 归约到 $P$（即证明 $U \\le_m P$），而不是相反。通过分析这个错误的证明尝试，您可以巩固对归约证明背后严谨逻辑的理解，这是掌握计算理论的关键一步 [@problem_id:1457073]。", "problem": "一个正在上计算理论课程的学生 Alice，被要求证明一个特定的语言 `TOTAL_TM` 是不可判定的。该语言定义为 `TOTAL_TM` $= \\{ \\langle M \\rangle \\mid M \\text{ 是一个在所有可能的输入串上都会停机的图灵机 (TM)} \\}$。\n\nAlice 知道标准的停机问题 $A_{TM} = \\{ \\langle M, w \\rangle \\mid M \\text{ 是一个在输入 } w \\text{ 上停机的图灵机} \\}$ 是一个著名的不可判定语言。\n\n为了证明她的论断，她正确地构造了一个可计算函数 $f$，该函数将 `TOTAL_TM` 的任何实例 $\\langle M \\rangle$ 转换为 $A_{TM}$ 的一个实例 $\\langle M', w' \\rangle = f(\\langle M \\rangle)$，使得 $\\langle M \\rangle \\in \\text{`TOTAL_TM`}$ 当且仅当 $\\langle M', w' \\rangle \\in A_{TM}$。这建立了一个从 `TOTAL_TM` 到 $A_{TM}$ 的映射归约（记为 $\\text{TOTAL\\_TM} \\le_{m} A_{TM}$）。\n\n然后 Alice 总结了她的证明：“既然我已经证明了 `TOTAL_TM` 可以归约到 $A_{TM}$，并且我们知道 $A_{TM}$ 是不可判定的，因此从逻辑上可以得出 `TOTAL_TM` 也必定是不可判定的。”\n\n以下哪个陈述最好地解释了 Alice 推理中的根本性缺陷？\n\nA. 为了通过归约证明一个语言 $P$ 是不可判定的，必须将一个已知的不可判定语言 $U$ *归约到* $P$（即，证明 $U \\le_m P$），而不是反过来。Alice 的归约方向对于她声称的目的来说是错误的。\nB. 语言 `TOTAL_TM` 不是图灵可识别的，而 $A_{TM}$ 是。映射归约只在处于相同可识别性类别的语言之间有效（即，两者都是可识别的，或两者都不是）。\nC. Alice 的论证是循环论证。为了构造可计算函数 $f$，她必须隐含地假设了一种判定 `TOTAL_TM` 的方法，这与她试图证明的论断相矛盾。\nD. 这个归约是无效的，因为已知 `TOTAL_TM` 是一个比 $A_{TM}$ 更“难”的问题。计算理论的一个基本定理是，不能将一个计算上更难的问题归约到一个更容易的问题。\nE. 任何从一个接受单个编码 $\\langle M \\rangle$ 作为输入的语言到一个接受一个对 $\\langle M, w \\rangle$ 作为输入的语言的归约都是内在地有缺陷的，因为它需要制造原始输入中不存在的信息（字符串 $w$）。", "solution": "我们已知语言 $\\text{TOTAL\\_TM} = \\{ \\langle M \\rangle \\mid M \\text{ 在所有输入上停机} \\}$ 和停机问题 $A_{TM} = \\{ \\langle M, w \\rangle \\mid M \\text{ 在输入 } w \\text{ 上停机} \\}$，其中 $A_{TM}$ 是已知的不可判定语言。Alice 展示了一个映射归约 $\\text{TOTAL\\_TM} \\le_{m} A_{TM}$ 并得出结论说 $\\text{TOTAL\\_TM}$ 是不可判定的。\n\n回顾定义：对于语言 $A$ 和 $B$，$A \\le_{m} B$ 意味着存在一个全可计算函数 $f$，使得对于所有字符串 $x$，\n$$x \\in A \\iff f(x) \\in B.$$\n\n映射归约的关键性质：\n- 如果 $A \\le_{m} B$ 且 $B$ 是可判定的，那么 $A$ 也是可判定的。证明：给定一个 $B$ 的判定器，通过计算 $f(x)$ 并运行 $B$ 的判定器来判定输入为 $x$ 的 $A$；当且仅当 $B$ 的判定器接受时接受。\n- 该命题的逆否命题是：如果 $A$ 是不可判定的且 $A \\le_{m} B$，那么 $B$ 也是不可判定的。\n\n因此，要通过归约证明目标语言 $P$ 是不可判定的，必须将一个已知的不可判定语言 $U$ 归约到 $P$，即证明 $U \\le_{m} P$。这样，如果 $P$ 是可判定的，那么 $U$ 也将是可判定的，这与 $U$ 的已知不可判定性相矛盾。\n\n然而 Alice 证明的是 $\\text{TOTAL\\_TM} \\le_{m} A_{TM}$。根据上述基本性质，这个蕴含关系只能得出：\n$$\\text{如果 } A_{TM} \\text{ 是可判定的，那么 } \\text{TOTAL\\_TM} \\text{ 也将是可判定的。}$$\n但由于 $A_{TM}$ 是不可判定的，这个条件句并没有告诉我们任何关于 $\\text{TOTAL\\_TM}$ 可判定性的信息。因此 Alice 的结论不成立。\n\n一个具体的例子说明这样的归约方向不能证明不可判定性：设 $L$ 是任意一个可判定语言。设 $D$ 是它的判定器。定义一个可计算函数 $f$，在输入 $x$ 上，运行 $D(x)$，如果 $D$ 接受，则输出一个固定的对 $\\langle M_{halt}, w_{halt} \\rangle \\in A_{TM}$；如果 $D$ 拒绝，则输出一个固定的对 $\\langle M_{loop}, w_{loop} \\rangle \\notin A_{TM}$。那么 $x \\in L \\iff f(x) \\in A_{TM}$，因此 $L \\le_{m} A_{TM}$，然而 $L$ 是可判定的。所以，证明 $P \\le_{m} A_{TM}$ 并不能确定 $P$ 是不可判定的。\n\n因此，根本性缺陷在于归约的方向。这对应于选项 A。其他选项是不正确的，因为：映射归约不要求具有相同的可识别性状态（B 是错误的），构造 $f$ 并不假设存在一个 `TOTAL_TM` 的判定器（C 是错误的），“从更难到更容易”的说法不是这里所涉及的形式化标准（D 具有误导性），以及通过可计算的填充或硬编码从单个输入生成配对是标准做法（E 是错误的）。", "answer": "$$\\boxed{A}$$", "id": "1457073"}, {"introduction": "在掌握了归约证明的正确方向后，我们来看一个经典应用。本练习展示了如何通过归约来确定一个全新问题的计算特性。当一个问题 $P$ 被证明足够“强大”，以至于可以用来解决停机问题（即 $H_{TM} \\le_T P$）时，我们就能对其可判定性做出决定性的结论 [@problem_id:1468148]。这个过程是理论计算机科学中证明问题难度的基石。", "problem": "在可计算性理论中，如果一个问题 $A$ 的算法可以借助一个假设存在的子程序（称为谕示机）来构造，而该谕示机可以在单一步骤内解决问题 $B$ 的任何实例，那么我们称问题 $A$ 可图灵归约到问题 $B$，记作 $A \\le_T B$。这意味着如果我们有办法解决 $B$，我们也就有办法解决 $A$。\n\n该理论的一个基石是图灵机停机问题 (TMs)，我们将其表示为 $H_{TM}$。这是一个判定问题：根据对任意图灵机和输入的描述，确定该图灵机最终是会停机还是会永远运行下去。$H_{TM}$ 是一个不可判定问题，这是一个基础性结论；不存在可以解决所有停机问题实例的算法。\n\n假设一位计算机科学家正在研究一个与数据库查询优化相关的新的、深奥的问题，我们称之为问题 $P$。经过重大突破，他们成功证明了停机问题可以图灵归约到问题 $P$。也就是说，他们已经形式化地证明了 $H_{TM} \\le_T P$。\n\n仅基于这个已证明的归约，关于问题 $P$ 的可判定性，能得出的最精确的结论是什么？\n\nA. 问题 $P$ 是可判定的。\nB. 问题 $P$ 是不可判定的。\nC. 问题 $P$ 的可判定性无法确定；它既可能是可判定的，也可能是不可判定的。\nD. 这种情况不可能发生，因为不可判定的停机问题不能图灵归约到任何其他问题。", "solution": "根据定义，$A \\le_T B$ 意味着存在一个谕示图灵机，在给定问题 $B$ 的谕示机的情况下，该图灵机可以判定问题 $A$。形式上，给定 $H_{TM} \\le_T P$，存在一个谕示图灵机 $M^{P}$，使得在能够访问问题 $P$ 的谕示机的情况下，$M^{P}$ 可以判定 $H_{TM}$。\n\n为了导出矛盾，我们假设 $P$ 是可判定的。那么，就存在一个标准的（非谕示）图灵机 $D_{P}$ 来判定 $P$，即 $D_{P}$ 在所有输入上都会停机，并正确回答输入是否属于 $P$。\n\n我们可以构造一个标准的图灵机 $N$ 来判定 $H_{TM}$，其方法是模拟 $M^{P}$。每当 $M^{P}$ 向 $P$ 发出谕示查询时，$N$ 会转而对该查询运行 $D_{P}$，并使用其结果代替谕示机的回答。因为 $D_{P}$ 在所有输入上都会停机，所以每次模拟的谕示查询都会在有限时间内返回。因此，$N$ 也会在所有输入上停机，从而能够判定 $H_{TM}$。\n\n这就得出了以下蕴涵关系\n$$\nH_{TM} \\le_T P \\land \\text{$P$ 可判定} \\implies \\text{$H_{TM}$ 可判定}.\n$$\n然而，一个已知的事实是 $H_{TM}$ 是不可判定的，这与上述结论相矛盾。因此，关于 $P$ 是可判定的这一假设必定是错误的，所以 $P$ 是不可判定的。\n\n因此，最精确的结论是 $P$ 是不可判定的。这种情况并非不可能：有很多问题都可以让 $H_{TM}$ 图灵归约到它们。", "answer": "$$\\boxed{B}$$", "id": "1468148"}, {"introduction": "不可判定性似乎是一个绝对的概念，但它的应用范围有其边界。本练习通过一个看似矛盾的例子，揭示了这一边界：为什么针对所有图灵机的停机问题是不可判定的，而一个仅限于有限状态数量的类似问题却是可判定的。理解这种差异有助于澄清一个核心原则，即经典不可判定性证明通常依赖于问题定义的无限性 [@problem_id:1457046]，从而加深您对不可判定性理论适用范围的认识。", "problem": "在计算理论中，图灵机（TM）是一种计算的数学模型，由一组状态、一个带字母表和一个转移函数来描述。图灵机的编码，记作 $\\langle M \\rangle$，是一个表示机器 $M$ 的有限字符串。空字符串用 $\\epsilon$ 表示。\n\n该领域的一个核心问题是空输入停机问题，它对应于语言 $HALT_{\\epsilon}$。该语言定义如下：\n$$HALT_{\\epsilon} = \\{ \\langle M \\rangle \\mid M \\text{ 是一个在输入 } \\epsilon \\text{ 上停机的图灵机} \\}$$\n一个公认的定理是，$HALT_{\\epsilon}$ 是一个不可判定的语言。这意味着不存在任何算法，可以对任意给定的图灵机，正确地判定它是否在空输入上停机。\n\n现在，考虑一个不同的语言，我们称之为 $L_{20}$。这个语言是为使用固定带字母表 $\\Gamma = \\{0, 1, \\text{空白符}\\}$ 的图灵机定义的，其定义如下：\n$$L_{20} = \\{ \\langle M \\rangle \\mid M \\text{ 是一个最多有 20 个状态且在输入 } \\epsilon \\text{ 上停机的图灵机} \\}$$\n事实上，与 $HALT_{\\epsilon}$ 不同，语言 $L_{20}$ 是可判定的。这可能看起来很矛盾，因为 $L_{20}$ 似乎是停机问题的一个特例。\n\n下列哪个陈述为 $L_{20}$ 是可判定的，并且这一事实与 $HALT_{\\epsilon}$ 的不可判定性不矛盾，提供了最准确和根本的解释？\n\nA. 一台通用图灵机可以模拟任何最多有20个状态的图灵机，直到它停机。这种模拟只保证对于状态数量少且有限的机器才会终止。\n\nB. $HALT_{\\epsilon}$ 的不可判定性是通过从通用停机问题 $A_{TM}$ 进行归约来证明的。如果目标机器被限制为最多有20个状态，那么这种归约技术是无效的。\n\nC. 任何在输入 $\\epsilon$ 上不停机的、拥有20个或更少状态的图灵机，都必然会在带上进入一个简单的、重复的构型循环。判定器可以检测到这个循环，而这对于拥有更多状态的图灵机来说是不可能做到的。\n\nD. “在输入 $\\epsilon$ 上停机”是图灵机的一个非平凡性质。根据莱斯定理，这意味着不可判定性。然而，莱斯定理对于状态数量少的机器有一个例外。\n\nE. 所有具有固定字母表和有界状态数量的不同图灵机的集合是有限的。因此，可以构建一个判定器，其内部硬编码了一个列表，包含了所有已知在 $\\epsilon$ 上停机的此类机器。这种方法对于 $HALT_{\\epsilon}$ 是不可能的，因为所有可能的图灵机集合是无限的。", "solution": "我们已知 $HALT_{\\epsilon}=\\{\\langle M\\rangle\\mid M\\text{ 在 }\\epsilon\\text{ 上停机}\\}$ 是不可判定的，而 $L_{20}=\\{\\langle M\\rangle\\mid M\\text{ 使用 }\\Gamma=\\{0,1,\\text{空白符}\\}\\text{，最多有 }20\\text{ 个状态，且在 }\\epsilon\\text{ 上停机}\\}$ 是可判定的。我们必须解释为什么 $L_{20}$ 是可判定的，同时不与 $HALT_{\\epsilon}$ 的不可判定性相矛盾。\n\n步骤1（具有有界状态和固定字母表的机器集合的有限性）：固定带字母表 $\\Gamma=\\{0,1,\\text{空白符}\\}$ 和一个状态集 $Q$，其中 $1\\leq |Q|\\leq 20$。对于一个确定性单带图灵机，转移函数是一个部分函数 $\\delta:Q\\times\\Gamma\\to\\Gamma\\times\\{L,R\\}\\times(Q\\cup\\{\\text{停机-接受},\\text{停机-拒绝}\\})$。对于每一对 $(q,a)\\in Q\\times\\Gamma$，$\\delta(q,a)$ 的选择数量是有限的，因为：\n- 写入的符号来自有限集 $\\Gamma$，\n- 磁头的移动来自有限集 $\\{L,R\\}$，\n- 下一个控制状态从有限集 $Q\\cup\\{\\text{停机-接受},\\text{停机-拒绝}\\}$ 中选择。\n因此，对于固定的 $Q$ 和 $\\Gamma$，所有可能的转移表的集合是有限集的有限积，所以是有限的。对所有 $|Q|\\leq 20$ 的情况取并集，仍然得到一个有限集。因此，所有使用带字母表 $\\Gamma=\\{0,1,\\text{空白符}\\}$ 且最多有 $20$ 个状态的图灵机的集合是有限的。如果编码 $\\langle\\cdot\\rangle$ 是固定的并且是单射的，那么这类机器的有效编码的集合也是有限的。\n\n步骤2（由有限性得到的可判定性）：设 $S$ 为所有使用带字母表 $\\Gamma=\\{0,1,\\text{空白符}\\}$ 且最多有 $20$ 个状态的图灵机的编码的有限集合。那么 $L_{20}\\subseteq S$ 并且 $L_{20}$ 本身是有限的。任何有限语言都是可判定的：可以构建一个判定器，它在输入 $x$ 时，首先检查 $x\\in S$ 是否成立（若不成立则拒绝），如果 $x\\in S$，则当且仅当 $x$ 属于一个有限的硬编码子集 $H\\subseteq S$ 时接受，该子集恰好由那些已知在输入 $\\epsilon$ 上停机的编码组成。等价地，可以为 $H$ 实现一个有限的查找表。\n\n步骤3（与 $HALT_{\\epsilon}$ 的不可判定性不矛盾）：$HALT_{\\epsilon}$ 的不可判定性涉及到具有无限数量状态和转移可能性的机器的无限域。将注意力限制在一个有限的机器子集（那些在固定字母表上最多有 $20$ 个状态的机器）上会产生一个有限语言，这个语言是平凡可判定的。通过归约或莱斯定理证明的不可判定性结论不适用于输入域的有限限制；因此不存在矛盾。\n\n对选项的评估：\n- A 是错误的：对于不停机的机器，模拟并不保证终止，无论其是否最多有 $20$ 个状态。\n- B 是误导性的：虽然标准的归约针对的是无限制的机器，但这并不能解释可判定性；核心原因是有限性。\n- C 是错误的：一个不停机的图灵机不一定会进入一个简单的重复构型循环；它可以无限地写入新的带符号而从不重复一个构型。\n- D 是错误的：莱斯定理没有“状态数量少”的例外情况；更确切地说，它不适用于机器集合的有限限制。\n- E 是正确的：这类机器的集合是有限的，因此可以通过有限查找来判定，这与 $HALT_{\\epsilon}$ 的不可判定性不矛盾，因为后者涵盖了一个无限的集合。", "answer": "$$\\boxed{E}$$", "id": "1457046"}]}