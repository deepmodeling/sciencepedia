{"hands_on_practices": [{"introduction": "我们将从可计算函数的基础构件开始探索。这个练习 [@problem_id:3048525] 聚焦于原始递归函数——可计算性理论中的一个核心概念。通过从最基本的初始函数和规则出发，一步步构建出加法、乘法等我们熟悉的算术运算，你将亲身体会到复杂的计算过程是如何从简单、明确的步骤中产生的，从而深刻理解一个函数在形式上“可计算”的含义。", "problem": "在整个问题中，我们使用标准的自然数 $\\mathbb{N}=\\{0,1,2,\\ldots\\}$ 和原始递归函数类。原始递归函数类是 $\\mathbb{N}$ 上全函数的最小类，它包含以下初始函数，并对以下运算封闭：\n- 初始函数：\n  - 零函数 $Z:\\mathbb{N}\\to\\mathbb{N}$，定义为 $Z(x)=0$。\n  - 后继函数 $S:\\mathbb{N}\\to\\mathbb{N}$，定义为 $S(x)=x+1$。\n  - 投影函数 $U_i^n:\\mathbb{N}^n\\to\\mathbb{N}$，对于每个 $n\\in\\mathbb{N}$ 和 $1\\leq i\\leq n$ 定义为 $U_i^n(x_1,\\ldots,x_n)=x_i$。\n- 在复合运算下封闭：如果 $g:\\mathbb{N}^m\\to\\mathbb{N}$ 和 $h_1,\\ldots,h_m:\\mathbb{N}^n\\to\\mathbb{N}$ 在该类中，那么由 $f(\\vec{x})=g(h_1(\\vec{x}),\\ldots,h_m(\\vec{x}))$ 给出的复合函数 $f:\\mathbb{N}^n\\to\\mathbb{N}$ 也在该类中。\n- 在原始递归运算下封闭：如果 $g:\\mathbb{N}^k\\to\\mathbb{N}$ 和 $h:\\mathbb{N}^{k+2}\\to\\mathbb{N}$ 在该类中，那么通过对最后一个参数进行原始递归得到的函数 $f:\\mathbb{N}^{k+1}\\to\\mathbb{N}$ 也在该类中。该函数由以下方程唯一确定：\n$$\nf(\\vec{x},0)=g(\\vec{x}),\\qquad f(\\vec{x},y+1)=h(\\vec{x},y,f(\\vec{x},y)),\n$$\n\n仅使用这些初始函数和封闭运算，从第一性原理出发完成以下任务：\n- 精确地说明上面使用的在 $\\mathbb{N}$ 上的原始递归模式，包括所涉及函数的作用和元数，并论证为什么对于 $g$ 和 $h$ 的每种选择，它都会生成一个唯一的全函数。\n- 在原始递归函数类中定义加法函数 $add:\\mathbb{N}^2\\to\\mathbb{N}$、乘法函数 $mul:\\mathbb{N}^2\\to\\mathbb{N}$ 和指数函数 $exp:\\mathbb{N}^2\\to\\mathbb{N}$，通过仅使用 $Z$、$S$、 $U_i^n$、复合和原始递归来展示它们的构造。您的定义不能先验地假设任何这些函数。\n- 使用您的构造，计算表达式\n$$\nE \\;=\\; exp(2,3)\\;+\\; mul(3,\\, add(2,2)).\n$$\n给出您的最终答案为精确整数，不进行四舍五入。", "solution": "所述问题是有效的。这是可计算性理论领域的一个适定问题，该领域是数理逻辑的一个分支学科。所提供的原始递归函数类的定义是标准的且正确的。任务规定清晰，逻辑一致，并要求严格应用所提供的定义。问题是自洽的，没有科学或事实上的不健全、模糊或主观因素。因此，我们可以着手解决。\n\n该问题要求基于所提供的原始递归函数定义，从第一性原理出发完成三项任务。\n\n### 第1部分：原始递归模式\n\n原始递归模式是一种运算，它从两个已定义的函数 $g$ 和 $h$ 定义一个新函数 $f$。\n\n**模式说明：**\n设 $k \\in \\mathbb{N}$ 是一个自然数，表示参数的数量。\n1.  **输入函数**：该模式需要两个函数 $g$ 和 $h$，假设它们属于原始递归函数类（因此是其定义域上的全函数）。\n    -   $g: \\mathbb{N}^k \\to \\mathbb{N}$ 是一个 $k$ 元函数。它提供了递归的基本情况。如果 $k=0$，$g$ 是一个常数，即 $\\mathbb{N}$ 的一个元素。\n    -   $h: \\mathbb{N}^{k+2} \\to \\mathbb{N}$ 是一个 $k+2$ 元函数。它提供了递归步骤。\n\n2.  **输出函数**：该模式生成一个新函数 $f: \\mathbb{N}^{k+1} \\to \\mathbb{N}$。$f$ 的参数是一个 $k$ 维参数向量，表示为 $\\vec{x} = (x_1, \\ldots, x_k)$，以及一个递归变量 $y$。\n\n3.  **定义方程**：函数 $f$ 由以下两个方程对所有 $\\vec{x} \\in \\mathbb{N}^k$ 和 $y \\in \\mathbb{N}$ 唯一确定：\n    $$\n    f(\\vec{x}, 0) = g(\\vec{x}) \\quad (\\text{基本情况})\n    $$\n    $$\n    f(\\vec{x}, y+1) = h(\\vec{x}, y, f(\\vec{x}, y)) \\quad (\\text{递归步骤})\n    $$\n    $h$ 的参数是参数向量 $\\vec{x}$、递归变量 $y$ 的当前值，以及函数 $f$ 在步骤 $y$ 的值，即 $f(\\vec{x},y)$。\n\n**关于 $f$ 的唯一性和全函数性的论证**：\n我们必须论证，对于任何原始递归（因此是全函数）的函数 $g$ 和 $h$ 的选择，函数 $f$ 在其定义域 $\\mathbb{N}^{k+1}$ 上都是一个唯一的全函数。该论证通过对递归变量 $y$ 进行数学归纳法来展开。\n\n设 $\\vec{x} \\in \\mathbb{N}^k$ 为任意固定的参数向量。我们将证明对于所有 $y \\in \\mathbb{N}$，$f(\\vec{x}, y)$ 都是唯一定义的。\n\n-   **基本情况 ($y=0$)**：$f(\\vec{x}, 0)$ 的值由方程 $f(\\vec{x}, 0) = g(\\vec{x})$ 给出。由于根据假设 $g$ 是一个全函数，对于任何给定的 $\\vec{x}$，$g(\\vec{x})$ 都会计算出一个唯一的自然数。因此，$f(\\vec{x}, 0)$ 是唯一定义的。\n\n-   **归纳步骤**：假设对于某个 $y \\in \\mathbb{N}$，值 $f(\\vec{x}, y)$ 是唯一定义的。我们必须证明 $f(\\vec{x}, y+1)$ 也是唯一定义的。递归步骤的方程是 $f(\\vec{x}, y+1) = h(\\vec{x}, y, f(\\vec{x}, y))$。函数 $h$ 的参数是三元组 $(\\vec{x}, y, f(\\vec{x}, y))$。\n    -   $\\vec{x}$ 是我们固定的参数向量。\n    -   $y$ 是一个自然数。\n    -   根据归纳假设，$f(\\vec{x}, y)$ 是一个唯一的自然数。\n    由于根据假设 $h$ 是一个全函数，它对于任何有效的输入元组都会产生一个唯一的自然数作为输出。因此，$h(\\vec{x}, y, f(\\vec{x}, y))$ 是唯一定义的。这意味着 $f(\\vec{x}, y+1)$ 是唯一定义的。\n\n-   **结论**：根据对 $y$ 的数学归纳法原理，$f(\\vec{x}, y)$ 对于所有 $y \\in \\mathbb{N}$ 和所有 $\\vec{x} \\in \\mathbb{N}^k$ 都是唯一定义的。这证实了 $f$ 是 $\\mathbb{N}^{k+1}$ 上的一个全函数，并且其定义是明确的。\n\n### 第2部分：`add`、`mul` 和 `exp` 的构造\n\n我们仅使用初始函数（$Z$、$S$、$U_i^n$）和复合及原始递归运算来构造这些函数。\n\n**1. 加法：$add(x,y) = x+y$**\n加法通过对 $y$ 进行原始递归来定义。参数是 $x$（$k=1$）。\n-   基本情况：$add(x, 0) = x$。\n-   递归步骤：$add(x, y+1) = S(add(x, y))$。\n\n为了将其形式化：\n-   基本情况函数是 $g(x) = x$。这是投影函数 $U_1^1$。所以，$g = U_1^1$。\n-   递归步骤函数是 $h(x, y, z) = S(z)$，其中 $z = add(x,y)$。函数 $h$ 必须形式上是三变量函数。我们通过复合来实现这一点：$h(x,y,z) = S(U_3^3(x,y,z))$。由于 $S$ 和 $U_3^3$ 是初始函数，通过复合，$h$ 是原始递归的。\n-   因此，$add: \\mathbb{N}^2 \\to \\mathbb{N}$ 定义如下：\n    $$add(x,0) = U_1^1(x)$$\n    $$add(x,y+1) = S(U_3^3(x,y,add(x,y)))$$\n\n**2. 乘法：$mul(x,y) = x \\cdot y$**\n乘法通过对 $y$ 进行原始递归并使用加法来定义。参数是 $x$（$k=1$）。\n-   基本情况：$mul(x, 0) = 0$。\n-   递归步骤：$mul(x, y+1) = mul(x,y) + x = add(mul(x,y), x)$。\n\n为了将其形式化：\n-   基本情况函数是 $g(x) = 0$。这是零函数 $Z(x)$。为了完全形式化，我们可以写成 $g(x) = Z(U_1^1(x))$。\n-   递归步骤函数是 $h(x,y,z) = add(z,x)$，其中 $z = mul(x,y)$。我们使用复合与投影函数来构造 $h$：$h(x,y,z) = add(U_3^3(x,y,z), U_1^3(x,y,z))$。由于 $add$、$U_1^3$ 和 $U_3^3$ 都是原始递归的，所以 $h$ 是原始递归的。\n-   因此，$mul: \\mathbb{N}^2 \\to \\mathbb{N}$ 定义如下：\n    $$mul(x,0) = Z(U_1^1(x))$$\n    $$mul(x,y+1) = add(U_3^3(x,y,mul(x,y)), U_1^3(x,y,mul(x,y)))$$\n\n**3. 指数运算：$exp(x,y) = x^y$**\n在此上下文中，约定 $0^0=1$。指数运算通过对 $y$ 进行原始递归并使用乘法来定义。参数是 $x$（$k=1$）。\n-   基本情况：$exp(x, 0) = 1$。\n-   递归步骤：$exp(x, y+1) = exp(x,y) \\cdot x = mul(exp(x,y), x)$。\n\n为了将其形式化：\n-   基本情况函数是 $g(x) = 1$。这个常数函数可以构造成 $S(Z(x))$，或者更形式化地，$g(x) = S(Z(U_1^1(x)))$。\n-   递归步骤函数是 $h(x,y,z) = mul(z,x)$，其中 $z = exp(x,y)$。这可以构造成 $h(x,y,z) = mul(U_3^3(x,y,z), U_1^3(x,y,z))$。由于 $mul$、$U_1^3$ 和 $U_3^3$ 都是原始递归的，所以 $h$ 是原始递归的。\n-   因此，$exp: \\mathbb{N}^2 \\to \\mathbb{N}$ 定义如下：\n    $$exp(x,0) = S(Z(U_1^1(x)))$$\n    $$exp(x,y+1) = mul(U_3^3(x,y,exp(x,y)), U_1^3(x,y,exp(x,y)))$$\n\n### 第3部分：表达式求值\n\n我们使用上面推导出的定义来计算 $E = exp(2,3) + mul(3, add(2,2))$，这可以转化为 $add(exp(2,3), mul(3, add(2,2)))$。我们从最内层的表达式开始向外计算。\n\n**1. 计算 $add(2,2)$：**\n$add(x,y+1) = S(add(x,y))$\n-   $add(2,0) = 2$\n-   $add(2,1) = add(2,0+1) = S(add(2,0)) = S(2) = 3$\n-   $add(2,2) = add(2,1+1) = S(add(2,1)) = S(3) = 4$\n所以，$add(2,2) = 4$。\n\n**2. 计算 $mul(3, add(2,2)) = mul(3,4)$：**\n$mul(x,y+1) = add(mul(x,y), x)$\n-   $mul(3,0) = 0$\n-   $mul(3,1) = mul(3,0+1) = add(mul(3,0), 3) = add(0,3) = S(S(S(add(0,0)))) = S(S(S(0))) = 3$\n-   $mul(3,2) = mul(3,1+1) = add(mul(3,1), 3) = add(3,3) = S(S(S(add(3,0)))) = S(S(S(3))) = 6$\n-   $mul(3,3) = mul(3,2+1) = add(mul(3,2), 3) = add(6,3) = S(S(S(add(6,0)))) = S(S(S(6))) = 9$\n-   $mul(3,4) = mul(3,3+1) = add(mul(3,3), 3) = add(9,3) = S(S(S(add(9,0)))) = S(S(S(9))) = 12$\n所以，$mul(3,4) = 12$。\n\n**3. 计算 $exp(2,3)$：**\n$exp(x,y+1) = mul(exp(x,y), x)$\n-   $exp(2,0) = S(Z(2)) = S(0) = 1$\n-   $exp(2,1) = exp(2,0+1) = mul(exp(2,0), 2) = mul(1,2)$。\n    -   $mul(1,0) = 0$\n    -   $mul(1,1) = add(mul(1,0), 1) = add(0,1) = 1$\n    -   $mul(1,2) = add(mul(1,1), 1) = add(1,1) = S(add(1,0)) = S(1) = 2$。\n    所以 $exp(2,1) = 2$。\n-   $exp(2,2) = exp(2,1+1) = mul(exp(2,1), 2) = mul(2,2)$。\n    -   我们已经计算出 $add(2,2)=4$。根据乘法的定义，$mul(2,2)=add(mul(2,1),2)=add(add(mul(2,0),2),2)=add(add(0,2),2)=add(2,2)=4$。\n    所以 $exp(2,2) = 4$。\n-   $exp(2,3) = exp(2,2+1) = mul(exp(2,2), 2) = mul(4,2)$。\n    -   $mul(4,0) = 0$\n    -   $mul(4,1) = add(mul(4,0),4) = add(0,4)=4$\n    -   $mul(4,2) = add(mul(4,1),4) = add(4,4) = S(S(S(S(add(4,0))))) = S(S(S(S(4)))) = 8$。\n所以，$exp(2,3) = 8$。\n\n**4. 最终计算：$add(exp(2,3), mul(3,4)) = add(8,12)$：**\n-   $add(8,0) = 8$\n-   $add(8,1) = S(8) = 9$\n-   ...\n-   $add(8,12) = S^{12}(add(8,0)) = S^{12}(8)$\n将后继函数应用于 $8$ 共 $12$ 次，得到 $8+12 = 20$。\n所以，$add(8,12) = 20$。\n\n表达式 $E$ 的值为 $20$。", "answer": "$$\n\\boxed{20}\n$$", "id": "3048525"}, {"introduction": "并非所有可计算过程都能保证终止。这个练习 [@problem_id:3048531] 探讨了有界最小化与无界最小化之间的关键区别：前者保证函数是全函数，而后者则可能产生部分函数。通过对比一个确保终止的有界搜索和一个与停机问题相关的开放式搜索，你将清晰地看到计算中的“不终止”现象是如何产生的，为理解莱斯定理揭示的算法判定能力的深刻限制打下坚实基础。", "problem": "设 $\\{\\varphi_{e}\\}_{e \\in \\mathbb{N}}$ 是由图灵机（Turing machine, TM）的哥德尔编号导出的所有部分可计算函数 $\\varphi_{e} : \\mathbb{N} \\to \\mathbb{N}$ 的一个固定标准枚举。对于 $e, x, t \\in \\mathbb{N}$，设 $H(e,x,t)$ 是一个原始递归谓词，它成立当且仅当第 $e$ 台图灵机在输入 $x$ 上于 $t$ 个计算步骤内停机（等价地，存在某个 $y$ 使得第 $e$ 台图灵机在输入 $x$ 上于 $t$ 步内停机并输出 $y$）。仅使用部分递归函数和一般递归函数理论中的基本定义以及 Rice 定理，解决以下问题。\n\n1. 通过有界最小化定义函数 $f : \\mathbb{N} \\to \\mathbb{N}$\n$$\nf(n) \\;=\\; \\mu y \\leq n \\;\\big[y^{2} \\geq n\\big],\n$$\n也就是说，$f(n)$ 是满足 $y \\leq n$ 和 $y^{2} \\geq n$ 的最小的 $y \\in \\mathbb{N}$（如果在此界限内不存在这样的 $y$，则无定义）。从核心定义出发，证明为什么在这种情况下有界最小化产生一个全可计算函数。通过从序和平方的第一性原理推导出一个闭式刻画，用更熟悉的解析术语来识别 $f(n)$。\n\n2. 通过无界最小化定义函数 $g : \\mathbb{N} \\rightharpoonup \\mathbb{N}$\n$$\ng(e) \\;=\\; \\mu t \\;\\big[ H(e,0,t) \\big],\n$$\n也就是说，$g(e)$ 是使得第 $e$ 台图灵机在输入 $0$ 上于 $t$ 步内停机的最小计算时间 $t$，如果存在这样的 $t$；否则 $g(e)$ 无定义。仅使用无界最小化和部分可计算性的基本定义，解释 $g$ 如何可能不是全函数。给出一个具体的机器描述，其指标 $e_{\\mathrm{loop}}$ 导致 $g(e_{\\mathrm{loop}})$ 无定义，并证明这一主张。\n\n3. 使用 Rice 定理，严格论证为什么指标集\n$$\nD \\;=\\; \\{\\, e \\in \\mathbb{N} : g(e) \\text{ is defined} \\,\\}\n$$\n是不可判定的。你的论证应从 Rice 定理的陈述开始，并解释为什么所讨论的性质是语义性的和非平凡的。\n\n作为你的最终答案，提供 $f(2024)$ 的精确整数值，无需四舍五入，也无需单位。你的最终答案必须是一个数字。不要在最终答案中包含任何解释。", "solution": "此问题包含三个与可计算函数理论相关的部分。我们根据所提供的定义，依次处理每个部分。\n\n1. 对函数 $f(n) = \\mu y \\leq n \\;[y^{2} \\geq n]$ 的分析。\n\n首先，我们证明为什么这个函数是全可计算的。函数 $f$ 是通过有界最小化定义的。由有界最小化定义的函数的一般形式为 $h(\\vec{x}) = \\mu y \\leq z \\; [P(\\vec{x}, y)]$，其中 $P$ 是一个谓词。可计算性理论的一个基本定理指出，如果谓词 $P$ 是全可计算的，那么函数 $h$ 也是全可计算的，前提是对于每个输入 $\\vec{x}$，在搜索范围 $[0, z]$ 中至少存在一个 $y$ 使得谓词 $P(\\vec{x}, y)$ 为真。\n\n在我们的例子中，函数是 $f(n)$，谓词是 $P(n, y) \\equiv (y^2 \\geq n)$，界限是 $z=n$。谓词 $P(n,y)$ 是原始递归的，因此是全可计算的，因为它只涉及将一个整数平方并与另一个整数比较，这两者都是原始递归操作。\n\n要证明 $f(n)$ 是全函数，我们必须表明对于任何给定的 $n \\in \\mathbb{N}$，至少存在一个整数 $y$ 使得 $0 \\leq y \\leq n$ 且 $y^2 \\geq n$。\n我们考虑 $n$ 的两种情况：\n情况1：$n=0$。定义变为 $f(0) = \\mu y \\leq 0 \\; [y^{2} \\geq 0]$。搜索仅限于 $y=0$。对于 $y=0$，谓词是 $0^2 \\geq 0$，这是真的。因此，最小化过程找到 $y=0$ 并终止。所以，$f(0) = 0$。\n情况2：$n > 0$。我们需要在范围 $\\{0, 1, \\dots, n\\}$ 中找到一个满足 $y^2 \\geq n$ 的 $y$。让我们测试值 $y=n$。因为 $n \\in \\mathbb{N}$ 且 $n > 0$，所以有 $n \\geq 1$。两边同乘以 $n$（为正数），得到 $n^2 \\geq n$。因此，选择 $y=n$ 总是满足谓词 $y^2 \\geq n$。由于这个选择在搜索界限 $\\{0, 1, \\dots, n\\}$ 之内，有界最小化过程保证能找到一个值（它会找到*最小*的这样的 $y$，这个值小于或等于 $n$）并停机。\n\n因为对于每个 $n \\in \\mathbb{N}$，在界限内都存在一个合适的 $y$，并且谓词是全可计算的，所以函数 $f(n)$ 是一个全可计算函数。\n\n接下来，我们推导 $f(n)$ 的一个闭式刻画。定义指出 $f(n)$ 是满足 $y^2 \\geq n$ 的最小非负整数 $y$。（约束 $y \\leq n$ 是多余的，正如已证明的，对于 $y_{min} = \\lceil\\sqrt{n}\\rceil$，当 $n \\geq 1$ 时我们有 $y_{min} \\leq n$，而对于 $n=0$ 则平凡成立）。对不等式 $y^2 \\geq n$ 的两边取平方根，得到 $|y| \\geq \\sqrt{n}$。由于我们考虑的是 $y \\in \\mathbb{N}$，所以 $y$ 是非负的，因此条件简化为 $y \\geq \\sqrt{n}$。\n因此，$f(n)$ 是大于或等于实数 $\\sqrt{n}$ 的最小整数 $y$。这是向上取整函数（ceiling function）的定义。\n因此，$f(n)$ 的闭式刻画为\n$$\nf(n) = \\lceil \\sqrt{n} \\rceil.\n$$\n\n2. 对函数 $g(e) = \\mu t \\;[ H(e,0,t) ]$ 的分析。\n\n首先，我们解释为什么 $g$ 可能不是全函数。函数 $g(e)$ 是通过无界最小化定义的。表达式 $g(e) = \\mu t \\;[P(e,t)]$，其中 $P(e,t) \\equiv H(e,0,t)$，给出使谓词 $P(e,t)$ 为真的最小 $t \\in \\mathbb{N}$。如果不存在这样的 $t$，则函数对于该输入 $e$ 无定义。\n谓词 $H(e,0,t)$ 为真，当且仅当第 $e$ 台图灵机在输入 $0$ 上于 $t$ 步内停机。因此，函数 $g(e)$ 有定义当且仅当存在某个有限时间 $t$ 使得第 $e$ 台图灵机在输入 $0$ 上停机。这等价于说计算 $\\varphi_e(0)$ 停机，或 $\\varphi_e(0) \\downarrow$。\n停机问题是可计算性理论的一个基石性结果，它指出判定任意图灵机在任意输入上是否停机是不可判定的。一个直接的推论是，必然存在在某些输入上不停机的图灵机。特别地，存在在输入 $0$ 上不停机的图灵机。\n设 $e_{\\mathrm{loop}}$ 是一个被设计为在输入 $0$ 上永不停机的图灵机的哥德尔数。对于这个指标 $e_{\\mathrm{loop}}$，“该图灵机在输入 $0$ 上停机”这一陈述是假的。这意味着不存在任何步数 $t$ 使得谓词 $H(e_{\\mathrm{loop}},0,t)$ 为真。无界最小化过程 $\\mu t \\;[H(e_{\\mathrm{loop}},0,t)]$ 将从 $t=0, 1, 2, \\dots$ 开始无限地搜索这样的 $t$，并且永远也找不到。根据无界最小化的定义，$g(e_{\\mathrm{loop}})$ 是无定义的。\n由于存在至少一个输入 $e_{\\mathrm{loop}}$ 使得 $g(e_{\\mathrm{loop}})$ 无定义，函数 $g$ 是一个部分函数，而不是一个全函数。\n\n作为一个具体的例子，考虑一台图灵机 $M$，它有一个起始状态 $q_0$，其转移函数 $\\delta$ 定义如下：对于带上的任何符号 $a$，$\\delta(q_0, a) = (q_0, a, R)$。这条规则表示，当处于状态 $q_0$ 时，机器读取符号 $a$，写回相同的符号 $a$，将其读写头向右移动一个位置（$R$），并保持在状态 $q_0$。这台机器没有停机状态。当在任何输入（包括输入 $0$）上启动时，它将无休止地向右移动其读写头，永不停机。设 $e_{\\mathrm{loop}}$ 是这台机器 $M$ 的指标（哥德尔数）。那么，根据其构造，$\\varphi_{e_{\\mathrm{loop}}}(0)$ 是无定义的。这意味着对于所有的 $t \\in \\mathbb{N}$，谓词 $H(e_{\\mathrm{loop}}, 0, t)$ 都是假的。因此，$g(e_{\\mathrm{loop}})$ 是无定义的。\n\n3. 集合 $D = \\{\\, e \\in \\mathbb{N} : g(e) \\text{ is defined} \\,\\}$ 的不可判定性。\n\n我们使用 Rice 定理来证明 $D$ 是不可判定的。Rice 定理指出，对于部分可计算函数的任何非平凡语义性质 $\\mathcal{P}$，其指标集 $I_{\\mathcal{P}} = \\{ e \\in \\mathbb{N} \\mid \\varphi_e \\in \\mathcal{P} \\}$ 是不可判定的。要应用该定理，我们必须证明 $D$ 是一个同时具有语义性和非平凡性性质的指标集。\n\n步骤 1：识别性质。\n集合 $D$ 定义为 $\\{ e \\in \\mathbb{N} \\mid g(e) \\text{ is defined}\\}$。如第2部分所述，$g(e)$ 有定义当且仅当计算 $\\varphi_e(0)$ 停机。因此，$D$ 是“部分可计算函数在输入 $0$ 上有定义”这一性质的指标集。设该性质为 $\\mathcal{P}$。\n$$\n\\mathcal{P} = \\{ h : \\mathbb{N} \\rightharpoonup \\mathbb{N} \\mid h \\text{ 是部分可计算的且 } h(0) \\text{ 有定义} \\}\n$$\n集合 $D$ 正是指标集 $I_{\\mathcal{P}}$，因为 $e \\in D \\iff \\varphi_e \\in \\mathcal{P}$。\n\n步骤 2：证明该性质是语义性的。\n如果一个性质仅依赖于函数的行为（即其图像），而不依赖于其具体实现（即其指标），那么该性质就是语义性的。这意味着如果两个指标 $e_1$ 和 $e_2$ 计算相同的函数（$\\varphi_{e_1} = \\varphi_{e_2}$），那么它们必须要么都具有该性质，要么都不具有。\n假设 $\\varphi_{e_1} = \\varphi_{e_2}$。这个等式意味着它们有相同的定义域，并且对定义域中的每个输入产生相同的输出。性质 $\\mathcal{P}$ 是函数在输入 $0$ 上有定义。如果 $\\varphi_{e_1} \\in \\mathcal{P}$，那么 $\\varphi_{e_1}(0)$ 有定义。因为 $\\varphi_{e_1} = \\varphi_{e_2}$，所以 $\\varphi_{e_2}(0)$ 也必定有定义，这意味着 $\\varphi_{e_2} \\in \\mathcal{P}$。反之，如果 $\\varphi_{e_1} \\notin \\mathcal{P}$，那么 $\\varphi_{e_1}(0)$ 无定义，这意味着 $\\varphi_{e_2}(0)$ 也无定义，所以 $\\varphi_{e_2} \\notin \\mathcal{P}$。在输入 $0$ 上是否有定义的性质只取决于函数本身，所以该性质是语义性的。\n\n步骤 3：证明该性质是非平凡的。\n如果一个性质既不是全集也不是空集，那么它就是非平凡的。也就是说，必须至少有一个部分可计算函数具有该性质，且至少有一个不具有该性质。\n为了证明 $\\mathcal{P}$ 不是空集，我们必须给出一个在 $\\mathcal{P}$ 中的函数。考虑对所有 $x \\in \\mathbb{N}$ 都成立的全可计算函数 $c(x) = 0$。这个函数对所有输入都有定义，包括 $x=0$。因此，$c \\in \\mathcal{P}$。\n为了证明 $\\mathcal{P}$ 不是所有部分可计算函数的集合，我们必须给出一个不在 $\\mathcal{P}$ 中的函数。这在第2部分已经做过了。对应于总是向右移动的图灵机的函数 $\\varphi_{e_{\\mathrm{loop}}}$ 对所有输入（包括 $x=0$）都无定义。因此，$\\varphi_{e_{\\mathrm{loop}}} \\notin \\mathcal{P}$。\n由于 $\\mathcal{P}$ 既不是空集也不是全集，它是一个非平凡的性质。\n\n步骤 4：结论。\n集合 $D$ 是部分可计算函数的一个语义性的、非平凡性质的指标集。根据 Rice 定理，$D$ 是一个不可判定的集合。\n\n最后，我们计算所需的 $f(2024)$ 的值。\n使用推导出的闭式表达式，我们需要计算 $f(2024) = \\lceil \\sqrt{2024} \\rceil$。\n我们可以找到其平方能够界定 $2024$ 的整数。\n我们知道 $40^2 = 1600$ 且 $50^2 = 2500$。\n让我们尝试 $45^2$：$45^2 = 2025$。\n让我们尝试 $44^2$：$44^2 = (45 - 1)^2 = 45^2 - 2 \\cdot 45 + 1 = 2025 - 90 + 1 = 1936$。\n我们有不等式 $1936  2024  2025$，这等价于 $44^2  2024  45^2$。\n对所有部分取平方根，得到 $44  \\sqrt{2024}  45$。\n向上取整函数 $\\lceil x \\rceil$ 得出大于或等于 $x$ 的最小整数。对于一个严格介于两个连续整数 $k$ 和 $k+1$ 之间的值 $x$，$\\lceil x \\rceil = k+1$。\n由于 $44  \\sqrt{2024}  45$，我们有 $\\lceil \\sqrt{2024} \\rceil = 45$。\n因此，$f(2024)=45$。", "answer": "$$\n\\boxed{45}\n$$", "id": "3048531"}, {"introduction": "莱斯定理是一个强大的工具，但了解其适用边界至关重要。这个练习 [@problem_id:3048534] 通过辨析函数的语义（外延）性质与程序代码的句法（内涵）性质之间的差异，阐明了莱斯定理的适用范围。莱斯定理断言了任何非平凡的语义性质都是不可判定的，但它对句法性质却无约束力；通过本练习，你将学会识别那些可判定的句法性质，从而避免滥用该定理，并更精确地把握其真正威力。", "problem": "固定一个标准有效枚举 $e \\mapsto \\varphi_{e}$，它涵盖了所有从 $\\mathbb{N}$ 到 $\\mathbb{N}$ 的部分递归（部分可计算）函数，其中每个自然数 $e \\in \\mathbb{N}$ 编码了一台计算部分函数 $\\varphi_{e}$ 的图灵机（TM）。程序代码的一个性质是任意子集 $S \\subseteq \\mathbb{N}$。如果对于所有 $e, e' \\in \\mathbb{N}$，等式 $\\varphi_{e} = \\varphi_{e'}$ 蕴含着 $e \\in S$ 当且仅当 $e' \\in S$，则这样的性质称为外延性的。否则，它是内涵性的。如果存在一个全递归（一般递归）特征函数 $\\chi_{S} \\colon \\mathbb{N} \\to \\{0,1\\}$，满足 $\\chi_{S}(e) = 1$ 当且仅当 $e \\in S$ 且 $\\chi_{S}(e) = 0$ 当 $e \\notin S$ 时，则性质 $S \\subseteq \\mathbb{N}$ 是可判定的。Rice's theorem 指出，部分可计算函数的任何非平凡的外延性质都具有一个不可判定的指标集。\n\n选择下面所有描述程序代码的可判定内涵性质的选项，并为你所选的选项解释为什么 Rice's theorem 不禁止它们的可判定性。\n\nA. $E_{\\mathrm{even}} = \\{e \\in \\mathbb{N} : e \\text{ 是偶数}\\}$。\n\nB. $T = \\{e \\in \\mathbb{N} : \\varphi_{e} \\text{ 是全函数}\\}$。\n\nC. $H_{10} = \\{e \\in \\mathbb{N} : \\text{代码为 } e \\text{ 的图灵机在输入为 } 0 \\text{ 时，在至多 } 10 \\text{ 步内停机}\\}$。\n\nD. $Z = \\{e \\in \\mathbb{N} : \\exists x \\in \\mathbb{N} \\text{ 使得 } \\varphi_{e}(x) = 0\\}$。\n\nE. $S_{01} = \\{e \\in \\mathbb{N} : e \\text{ 的二进制编码包含子串 } 01\\}$。", "solution": "问题陈述是计算理论中的一个有效练习。所提供的所有定义——部分递归函数、有效枚举、外延和内涵性质、可判定性以及 Rice's theorem——都是标准的且陈述正确。该问题是自包含的，在数理逻辑中有科学依据，并且是良定的。我们可以开始解题。\n\n任务是识别出给定的性质 $S \\subseteq \\mathbb{N}$ 中哪些既是可判定的又是内涵性的。让我们回顾一下定义。\n如果性质 $S$ 的特征函数 $\\chi_S$ 是一个全可计算函数，那么该性质是**可判定的**。这意味着存在一个算法，对于任何输入 $e \\in \\mathbb{N}$，如果 $e \\in S$，该算法会停机并输出 $1$；如果 $e \\notin S$，则输出 $0$。\n如果性质 $S$ 是关于所计算的函数的性质，而不是程序代码本身的性质，那么它是**外延性的**。形式上，对于任意两个代码 $e, e' \\in \\mathbb{N}$，如果它们计算相同的函数（即 $\\varphi_e = \\varphi_{e'}$），那么必须满足 $e \\in S$ 当且仅当 $e' \\in S$。\n如果一个性质不是外延性的，那么它是**内涵性的**。这意味着至少存在两个代码 $e, e' \\in \\mathbb{N}$，使得 $\\varphi_e = \\varphi_{e'}$，但一个代码在 $S$ 中，而另一个不在。\n**Rice's theorem** 指出，任何非平凡的（即不是 $\\emptyset$ 也不是 $\\mathbb{N}$）外延性质都是不可判定的。一个直接的推论是，任何可判定的非平凡性质都必须是内涵性的。\n\n我们现在来分析每个选项。\n\n**A. $E_{\\mathrm{even}} = \\{e \\in \\mathbb{N} : e \\text{ 是偶数}\\}$**\n\n*   **可判定性：** 这个性质是可判定的。要确定一个给定的自然数 $e$ 是否在 $E_{\\mathrm{even}}$ 中，我们只需计算 $e \\pmod 2$。如果结果为 $0$，那么 $e \\in E_{\\mathrm{even}}$；否则，$e \\notin E_{\\mathrm{even}}$。这是一个简单的、会停机的算法。因此，特征函数 $\\chi_{E_{\\mathrm{even}}}$ 是全可计算的。该性质是**可判定的**。\n*   **内涵性：** 要检查该性质是否是内涵性的，我们必须确定是否存在两个代码 $e_1, e_2$，使得 $\\varphi_{e_1} = \\varphi_{e_2}$，但一个是偶数而另一个是奇数。根据 Padding Lemma（或者更通俗地说，即为图灵机添加冗余指令的能力），任何部分可计算函数都有无穷多个不同的代码（指标）。对于任何给定的函数，这个无限的代码集合不可能只包含偶数或只包含奇数。因此，对于任何部分可计算函数 $f$，我们都可以找到一个偶数指标 $e_1$ 和一个奇数指标 $e_2$，使得 $\\varphi_{e_1} = f$ 且 $\\varphi_{e_2} = f$。在这种情况下，$\\varphi_{e_1} = \\varphi_{e_2}$，但是 $e_1 \\in E_{\\mathrm{even}}$ 且 $e_2 \\notin E_{\\mathrm{even}}$。这违反了外延性的条件。因此，该性质是**内涵性的**。\n*   **结论：** 该性质既是可判定的也是内涵性的。Rice's theorem 不禁止其可判定性，因为该定理仅适用于外延性质，而 $E_{\\mathrm{even}}$ 是一个内涵性质。它描述的是代码 $e$ 本身的句法特征，而不是函数 $\\varphi_e$ 的语义特征。\n*   **结论：** **正确**。\n\n**B. $T = \\{e \\in \\mathbb{N} : \\varphi_{e} \\text{ 是全函数}\\}$**\n\n*   **可判定性：** 函数是否为全函数是一个经典的不可判定问题。为了使用 Rice's theorem 证明这一点，我们首先检查其条件。\n*   **内涵性：** 该性质是**外延性的**。如果 $\\varphi_e = \\varphi_{e'}$，那么这两个函数是相同的。它们必须有相同的定义域。因此，$\\varphi_e$ 是全函数当且仅当 $\\varphi_{e'}$ 是全函数。\n*   **平凡性：** 该性质是非平凡的。存在全函数（例如，常数零函数，$f(x)=0$），所以 $T \\neq \\emptyset$。也存在不是全函数的函数（例如，处处无定义的函数），所以 $T \\neq \\mathbb{N}$。\n*   **结论：** 由于 $T$ 是一个非平凡的外延性质，根据 Rice's theorem，它是**不可判定的**。\n*   **结论：** **不正确**。\n\n**C. $H_{10} = \\{e \\in \\mathbb{N} : \\text{代码为 } e \\text{ 的图灵机在输入为 } 0 \\text{ 时，在至多 } 10 \\text{ 步内停机}\\}$**\n\n*   **可判定性：** 这个性质是可判定的。给定一个指标 $e$，我们可以模拟它所编码的图灵机在输入 0 上的运行。我们最多模拟 $10+1$ 步。如果机器在 10 步内停机，我们接受 $e$（输出 1）。如果机器在 10 步后仍未停机，我们停止模拟并拒绝 $e$（输出 0）。由于模拟有时间限制，这个过程对任何输入 $e$ 总是会终止。因此，该性质是**可判定的**。\n*   **内涵性：** 这个性质是**内涵性的**。它依赖于机器 $e$ 的特定操作行为（步数），而不仅仅是它所计算的函数 $\\varphi_e$。为了证明这一点，考虑常数函数 $f(x) = 0$。我们可以构造一个非常高效的图灵机 $M_1$，其代码为 $e_1$，它计算这个函数并在输入 0 时，比如说，在 5 步内停机。因此，$e_1 \\in H_{10}$。我们也可以构造另一个图灵机 $M_2$，其代码为 $e_2$，它计算相同的函数 $f(x)=0$，但在进入主计算之前，先执行 20 个无用的、浪费时间的操作（比如来回移动读写头）。这台机器 $M_2$ 在输入 0 时会在超过 10 步后停机，所以 $e_2 \\notin H_{10}$。由于 $\\varphi_{e_1} = \\varphi_{e_2}$ 但 $e_1 \\in H_{10}$ 且 $e_2 \\notin H_{10}$，该性质不是外延性的。\n*   **结论：** 该性质既是可判定的也是内涵性的。Rice's theorem 不适用，因为该性质是内涵性的。它关心的是特定程序的性能，而不是它所计算的数学函数的性质。\n*   **结论：** **正确**。\n\n**D. $Z = \\{e \\in \\mathbb{N} : \\exists x \\in \\mathbb{N} \\text{ 使得 } \\varphi_{e}(x) = 0\\}$**\n\n*   **可判定性：** 这个性质询问数字 0 是否在函数 $\\varphi_e$ 的值域中。\n*   **内涵性：** 这个性质是**外延性的**。如果 $\\varphi_e = \\varphi_{e'}$，它们是同一个函数，因此具有相同的值域。如果存在一个 $x$ 使得 $\\varphi_e(x)=0$，那么 $\\varphi_{e'}(x)=0$ 也同样成立。所以，$e \\in Z$ 当且仅当 $e' \\in Z$。\n*   **平凡性：** 该性质是非平凡的。常数零函数的值域中包含 0，所以 $Z \\neq \\emptyset$。常数一函数 ($f(x)=1$) 的值域中不包含 0，所以 $Z \\neq \\mathbb{N}$。\n*   **结论：** 由于 $Z$ 是一个非平凡的外延性质，根据 Rice's theorem，它是**不可判定的**。\n*   **结论：** **不正确**。\n\n**E. $S_{01} = \\{e \\in \\mathbb{N} : e \\text{ 的二进制编码包含子串 } 01\\}$**\n\n*   **可判定性：** 这个性质是可判定的。给定一个数 $e$，我们可以将其转换为二进制字符串表示，然后对子串“$01$”进行简单的字符串搜索。这个算法总是会终止。因此，该性质是**可判定的**。\n*   **内涵性：** 这个性质是**内涵性的**。它纯粹是句法上的，仅依赖于整数 $e$ 的表示。正如选项 A 中所解释的，任何部分可计算函数都有无穷多个指标。我们总能为同一个函数找到两个指标 $e_1$ 和 $e_2$，使得 $e_1$ 的二进制表示包含子串“$01$”，而 $e_2$ 的二进制表示不包含。例如，二进制形式中*不*包含“$01$”的数字集合是形如 $2^k-1$ 后跟任意数量的零的数字（即二进制形式为 $\\underbrace{11\\dots1}_{k}\\underbrace{00\\dots0}_{j}$ 的数，其值为 $(2^k-1) \\cdot 2^j$）。这个集合是无限的。任何函数的指标集也是无限的。一个函数的无限指标集不可能是一个其二进制形式缺少“$01$”的数字集合的子集。因此，必然存在一个在 $S_{01}$ 中的指标 $e_1$ 和一个不在 $S_{01}$ 中的指标 $e_2$，它们计算的是同一个函数。\n*   **结论：** 该性质既是可判定的也是内涵性的。Rice's theorem 不适用，因为该性质是内涵性的，仅关心指标的句法，而不关心函数的语义。\n*   **结论：** **正确**。", "answer": "$$\\boxed{ACE}$$", "id": "3048534"}]}