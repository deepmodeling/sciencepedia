{"hands_on_practices": [{"introduction": "一阶逻辑的不可判定性是阿隆佐·邱奇（Alonzo Church）提出的一个基石性成果，其证明通常与已知的停机问题的不可判定性相关联。本练习将引导您体验这一证明的核心：将图灵机的整个计算过程编码为一个单一的一阶逻辑句子。通过成功设计此编码，您将深刻体会到逻辑的表达能力，并理解计算问题如何能转化为逻辑可满足性问题。[@problem_id:3059496]", "problem": "考虑一个确定性单带图灵机 (TM) $\\mathcal{M} = (Q, \\Gamma, \\sqcup, \\delta, q_0, q_{\\mathrm{halt}})$，其中 $Q$ 是一个有限状态集，其大小为 $|Q| = q$；$\\Gamma$ 是一个有限带字母表，其大小为 $|\\Gamma| = s$，包含一个指定的空白符号 $\\sqcup$；$\\delta$ 是转移函数；$q_0 \\in Q$ 是初始状态；$q_{\\mathrm{halt}} \\in Q$ 是停机状态。在一阶逻辑 (FOL) 的单类论域中进行操作。您的目标是设计一个一阶标记，并解释它如何将 $\\mathcal{M}$ 在离散时间步上的计算进行编码，这种编码方式适用于将停机问题归约到一阶逻辑的可满足性问题，这也是 Church 定理（一阶逻辑有效性的不可判定性）的基础。\n\n仅从图灵机和一阶逻辑的核心定义出发，构造一个一阶标记 $\\Sigma$，该标记包括：\n\n- 一个二元关系符号 $T(t, t')$，意在表示时间步上的后继关系（因此 $T(t, t')$ 意味着 $t'$ 是紧随 $t$ 之后的下一个时间）。\n- 一个二元谓词符号 $H(t, c)$，用于指示读写头在带上的位置（因此 $H(t, c)$ 意味着在时间 $t$，读写头扫描单元格 $c$）。\n- 对于每个带符号 $a \\in \\Gamma$，一个二元谓词符号 $S_a(t, c)$，用于指示带上内容（因此 $S_a(t, c)$ 意味着在时间 $t$，单元格 $c$ 上的符号是 $a$）。\n- 对于每个机器状态 $p \\in Q$，一个一元谓词符号 $Q_p(t)$，用于指示状态（因此 $Q_p(t)$ 意味着在时间 $t$，机器处于状态 $p$）。\n\n为了充分编码读写头的移动和带的结构，请包含所需的最少的额外非逻辑符号，以便您的公理能够表达读写头在相邻单元格之间的左移和右移，并确定初始格局。您必须确保您的设计在科学上是合理的，并且足以描述一个离散的时空计算。假设该标记在其他方面尽可能精简，并避免添加冗余符号。\n\n请连贯地描述该标记如何支持以下公理的实施：\n\n- 在每个时间 $t$，恰好有一个状态成立，恰好有一个读写头位置成立，并且每个单元格上恰好有一个带符号。\n- 二元关系 $T$ 是时间点上的离散后继关系。\n- 所选的单元格上的带关系是单元格上的离散后继关系，以支持左移和右移。\n- 转移子句忠实地反映了 $\\delta$，以便从时间 $t$ 的格局出发，在 $T(t, t')$ 成立的时间 $t'$，带上内容、读写头位置和机器状态完全按照 $\\delta$ 的规定演化。\n\n解释这种编码如何产生一个从 $(\\mathcal{M}, w)$（其中输入词为 $w \\in \\Gamma^*$）到一个一阶逻辑句子的有效映射，该句子的可满足性捕获了 $\\mathcal{M}$ 是否在输入 $w$ 上停机，从而建立了从停机问题到一阶逻辑可满足性问题的归约。\n\n最后，以封闭形式计算您的标记 $\\Sigma$ 中不同非逻辑符号的最小总数，作为 $q$ 和 $s$ 的函数。这里的“非逻辑符号”包括所有常量符号、函数符号和谓词/关系符号；等号被视为逻辑符号，不计算在内。您的最终答案必须是关于 $q$ 和 $s$ 的单个封闭形式解析表达式。", "solution": "所提出的问题是数理逻辑和可计算性理论中的一个标准的、典型的练习。它要求构造一个一阶标记来编码图灵机的计算，解释这种编码的工作原理，并统计所涉及的符号数量。这是通过从停机问题进行归约来证明一阶逻辑不可判定性（Church 定理）的核心部分。该问题具有科学依据，提法恰当，客观且完全明确，没有任何缺陷。因此，我们可以直接进行解答。\n\n目标是构造一个一阶标记 $\\Sigma$ 和一组公理，以描述给定确定性单带图灵机 $\\mathcal{M} = (Q, \\Gamma, \\sqcup, \\delta, q_0, q_{\\mathrm{halt}})$ 的计算，其中 $|Q| = q$ 且 $|\\Gamma| = s$。编码必须使得“$\\mathcal{M}$ 是否在给定输入词 $w$ 上停机”这一问题等价于某个特定一阶句子的可满足性。\n\n首先，我们设计标记 $\\Sigma$。我们预期解释的论域将是一个表示离散时间步和离散带单元格位置的元素集合。问题规定了一组特定的非逻辑符号，我们将添加满足要求所需的最少数量的符号。\n\n标记 $\\Sigma$ 包含以下非逻辑符号：\n\n1.  **谓词符号 (关系):**\n    *   $Q_p(t)$: 一组 $q$ 个一元谓词，每个状态 $p \\in Q$ 对应一个。$Q_p(t)$ 意为当且仅当机器在时间 $t$ 处于状态 $p$ 时为真。\n    *   $S_a(t, c)$: 一组 $s$ 个二元谓词，每个带符号 $a \\in \\Gamma$ 对应一个。$S_a(t, c)$ 意为当且仅当带单元格 $c$ 在时间 $t$ 包含符号 $a$ 时为真。\n    *   $H(t, c)$: 一个二元谓词。$H(t, c)$ 意为当且仅当机器的读写头在时间 $t$ 扫描单元格 $c$ 时为真。\n    *   $T(t, t')$: 一个二元谓词。$T(t, t')$ 意为当且仅当 $t'$ 是紧随时间 $t$ 之后的时间步时为真。\n    *   $C(c, c')$: 一个二元谓词。这是表达带单元格之间空间关系所需的最小补充。$C(c, c')$ 意为当且仅当单元格 $c'$ 紧邻单元格 $c$ 的右侧时为真。这单个关系足以描述左移和右移，因为移动到 $c$ 的左侧就是移动到满足 $C(c', c)$ 的单元格 $c'$。\n\n2.  **常量符号:**\n    *   $t_0$: 一个常量符号，表示初始时间步，即时间 $0$。\n    *   $c_0$: 一个常量符号，表示初始带单元格，即单元格 $0$，读写头从这里开始。\n    这些是提供时间和空间原点以“确定初始格局”所需的最小补充。\n\n3.  **函数符号:**\n    *   无。可以构造一个不含函数符号的最小标记，这遵循了问题中包含 $T(t, t')$ 所建议的关系式风格。\n\n$\\Sigma$ 中这些不同非逻辑符号的总数是谓词符号和常量符号数量的总和。\n谓词符号数量 = $q$ (状态) $+ s$ (字母表) $+ 1$ (读写头) $+ 1$ (时间) $+ 1$ (单元格) $= q + s + 3$。\n常量符号数量 = $1$ (初始时间) $+ 1$ (初始单元格) $= 2$。\n非逻辑符号总数为 $(q + s + 3) + 2 = q + s + 5$。\n\n接下来，我们描述这个标记如何支持一组公理，这些公理共同构成一个句子 $\\Phi_{\\mathcal{M}, w}$。该句子是按目的分组的公式的合取。该句子的一个模型将对应于 $\\mathcal{M}$ 在输入 $w$ 上的一个有效的、停机的计算历史。\n\n1.  **结构公理：** 这些公理约束 $T$ 和 $C$ 的解释，以表示离散的后继关系，并约束论域表示一组时间点和带单元格。\n    *   **时间结构：** 时间从 $t_0$ 开始并线性前进。\n        *   $\\forall t \\exists t' \\, T(t, t')$ (每个时间都有一个后继)。\n        *   $\\forall t, t'_1, t'_2 \\, (T(t, t'_1) \\land T(t, t'_2) \\implies t'_1 = t'_2)$ (后继是唯一的)。\n        *   $\\forall t \\, \\neg T(t, t_0)$ ($t_0$ 是第一个时间步)。\n    *   **带结构：** 带是双向无限的离散单元格序列。\n        *   $\\forall c \\exists c' \\, C(c, c')$ (每个单元格都有一个右邻居)。\n        *   $\\forall c, c'_1, c'_2 \\, (C(c, c'_1) \\land C(c, c'_2) \\implies c'_1 = c'_2)$ (右邻居是唯一的)。\n        *   $\\forall c' \\exists c \\, C(c, c')$ (每个单元格都有一个左邻居)。\n        *   $\\forall c', c_1, c_2 \\, (C(c_1, c') \\land C(c_2, c') \\implies c_1 = c_2)$ (左邻居是唯一的)。\n\n2.  **唯一性公理：** 这些公理确保在任何给定时间，机器格局都是良定义的。\n    *   **唯一状态：** $\\forall t \\, \\left( (\\bigvee_{p \\in Q} Q_p(t)) \\land (\\bigwedge_{p_1 \\neq p_2 \\in Q} \\neg(Q_{p_1}(t) \\land Q_{p_2}(t))) \\right)$。\n    *   **唯一读写头位置：** $\\forall t \\, ((\\exists c \\, H(t, c)) \\land (\\forall c_1, c_2 \\, (H(t, c_1) \\land H(t, c_2) \\implies c_1 = c_2)))$。\n    *   **每个单元格唯一符号：** $\\forall t, c \\, \\left( (\\bigvee_{a \\in \\Gamma} S_a(t, c)) \\land (\\bigwedge_{a_1 \\neq a_2 \\in \\Gamma} \\neg(S_{a_1}(t, c) \\land S_{a_2}(t, c))) \\right)$。\n\n3.  **初始格局公理：** 设输入词为 $w = w_1 w_2 \\dots w_m \\in \\Gamma^*$。\n    *   **初始状态：** $Q_{q_0}(t_0)$。\n    *   **初始读写头位置：** $H(t_0, c_0)$。\n    *   **初始带内容：** 我们必须断言输入词 $w$ 从 $c_0$ 开始写在带上，所有其他单元格都是空白的 ($\\sqcup$)。这需要定义相对于 $c_0$ 的单元格位置 $c_1, \\dots, c_{m-1}$。\n        *   $\\exists c_1, \\dots, c_{m-1} \\left(C(c_0, c_1) \\land C(c_1, c_2) \\land \\dots \\land C(c_{m-2}, c_{m-1}) \\land S_{w_1}(t_0, c_0) \\land \\dots \\land S_{w_m}(t_0, c_{m-1}) \\land \\forall c' ((\\bigwedge_{i=0}^{m-1} c' \\neq c_i) \\implies S_\\sqcup(t_0, c')) \\right)$。\n\n4.  **转移公理：** 这些公理编码了转移函数 $\\delta$。对于 $\\delta$ 中的每条规则，我们添加一个相应的公理。\n    *   **状态和带的改变：** 对于每个转移 $\\delta(p, a) = (p', a', d)$，其中 $p \\in Q \\setminus \\{q_{\\mathrm{halt}}\\}$，$a \\in \\Gamma$，且 $d$ 是读写头移动方向（左 L、右 R 或不移动 N）：\n        *   如果 $d = \\text{Right}$ (右移): $\\forall t, t', c, c' \\Big[ \\big( T(t, t') \\land Q_p(t) \\land H(t, c) \\land S_a(t, c) \\land C(c, c') \\big) \\implies \\big( Q_{p'}(t') \\land S_{a'}(t', c) \\land H(t', c') \\big) \\Big]$。\n        *   如果 $d = \\text{Left}$ (左移): $\\forall t, t', c, c'' \\Big[ \\big( T(t, t') \\land Q_p(t) \\land H(t, c) \\land S_a(t, c) \\land C(c'', c) \\big) \\implies \\big( Q_{p'}(t') \\land S_{a'}(t', c) \\land H(t', c'') \\big) \\Big]$。\n        *   如果 $d = \\text{No-move}$ (不移动): $\\forall t, t', c \\Big[ \\big( T(t, t') \\land Q_p(t) \\land H(t, c) \\land S_a(t, c) \\big) \\implies \\big( Q_{p'}(t') \\land S_{a'}(t', c) \\land H(t', c) \\big) \\Big]$。\n    *   **框架公理 (惯性)：** 不在读写头下的单元格其符号不改变。\n        *   $\\forall t, t', c_{head}, c_{other}, a \\Big[ \\big( T(t, t') \\land H(t, c_{head}) \\land c_{head} \\neq c_{other} \\land S_a(t, c_{other}) \\big) \\implies S_a(t', c_{other}) \\Big]$。\n\n最后，为了解决停机问题，我们需要询问机器是否会到达停机状态 $q_{\\mathrm{halt}}$。这由公式 $\\exists t \\, Q_{q_{\\mathrm{halt}}}(t)$ 捕获。\n\n归约过程如下：给定 $(\\mathcal{M}, w)$，我们通过将上面描述的所有公理（结构、唯一性、初始、转移）和停机条件进行合取，构造一个单一的一阶逻辑句子 $\\Phi_{\\mathcal{M}, w}$：\n$\\Phi_{\\mathcal{M}, w} \\equiv (\\text{Axioms}_{\\text{Structure}}) \\land (\\text{Axioms}_{\\text{Uniqueness}}) \\land (\\text{Axioms}_{\\text{Initial}}) \\land (\\text{Axioms}_{\\text{Transition}}) \\land (\\exists t \\, Q_{q_{\\mathrm{halt}}}(t))$。\n\n从 $\\mathcal{M}$ 和 $w$ 构造 $\\Phi_{\\mathcal{M}, w}$ 是一个有效的、算法化的过程。我们建立归约的正确性：\n*   **($\\Rightarrow$) 如果 $\\mathcal{M}$ 在输入 $w$ 上停机**，则存在一个有限的计算历史，即一个格局序列 $C_0, C_1, \\dots, C_N$，其中 $C_0$ 是输入 $w$ 的初始格局，$C_N$ 是处于状态 $q_{\\mathrm{halt}}$ 的格局。这个历史可以用来为 $\\Phi_{\\mathcal{M}, w}$ 定义一个模型。例如，论域可以是整数集。谓词 $Q_p, S_a, H$ 的解释根据计算历史逐步定义。根据构造，这种解释满足所有公理，包括最后一个公理，因为在时间 $N$，机器处于状态 $q_{\\mathrm{halt}}$。因此，$\\Phi_{\\mathcal{M}, w}$ 是可满足的。\n*   **($\\Leftarrow$) 如果 $\\Phi_{\\mathcal{M}, w}$ 是可满足的**，那么存在一个模型 $\\mathfrak{A}$ 使该句子为真。公理强制该模型描述一个从输入 $w$ 开始的 $\\mathcal{M}$ 的有效计算历史。子句 $\\exists t \\, Q_{q_{\\mathrm{halt}}}(t)$ 在 $\\mathfrak{A}$ 中为真，意味着在这个计算历史中，机器在某个时间到达状态 $q_{\\mathrm{halt}}$。因此，$\\mathcal{M}$ 在输入 $w$ 上停机。\n\n这建立了一个从停机问题到一阶逻辑可满足性问题的多一归约。由于停机问题是不可判定的，因此一阶逻辑可满足性问题也是不可判定的。由于有效性与可满足性是相互定义的（$\\phi$ 是有效的当且仅当 $\\neg\\phi$ 是不可满足的），可满足性的不可判定性直接蕴含了有效性的不可判定性，这便是 Church 定理。\n\n最后的任务是计算我们的最小标记 $\\Sigma$ 中非逻辑符号的总数。如前所述，这是 $q+s+3$ 个谓词符号和 $2$ 个常量符号的总和。", "answer": "$$\n\\boxed{q+s+5}\n$$", "id": "3059496"}, {"introduction": "在我们对图灵机计算进行编码的过程中，用于表示时间步骤的结构至关重要。本练习专注于使用一阶公理来形式化地定义这个结构，确保它的行为如同一个离散且无尽的瞬间序列。通过探索满足这些公理的模型的属性，您将发现一个关键的洞见：任何这样的结构都必须是无限的，这对于理解为何一阶逻辑无法将计算“限制”在有限步骤内具有深远的影响。[@problem_id:3059502]", "problem": "考虑一阶逻辑 (FOL) 标记 $\\mathcal{L}=\\{,S,0\\}$，其中 $$ 和 $S$ 是二元关系符号，$0$ 是常数符号。在许多用于证明一阶有效性不可判定性（Church 定理）的标准归约中，人们通过使用带有直接后继关系的离散线性时间步序，在模型内部编码图灵机计算。你的任务是：\n\n1. 写出一个有限的 $\\mathcal{L}$-句子集合，该集合在任何 $\\mathcal{L}$-结构 $\\mathcal{M}$ 中强制执行以下性质：\n   - $$ 是一个严格线性序，其最小元为 $0$。\n   - $S$ 与由 $$ 导出的直接后继关系一致（即，$S(x,y)$ 成立当且仅当 $y$ 是大于 $x$ 的 $$-最小元）。\n   - 每个元素都有一个 $S$-后继（因此没有最后的时间步）。\n   - 每个非零元素都有一个 $S$-前驱（所有非零元素左侧的离散性）。\n   这些公理应确保时间步以离散、线序的方式索引，适合于编码连续的计算阶段。\n\n2. 仅使用你的公理所强制的性质以及严格线性序和离散性的基本定义，确定满足你所有公理的、基数为 $n=23$ 的非同构 $\\mathcal{L}$-结构的数量。以单个整数形式给出你的最终答案。无需四舍五入。", "solution": "所述问题是有效的。这是一个在数理逻辑和模型论中基于既定形式体系的适定问题。它是客观的、自足的，并且与用于证明不可判定性的逻辑基础直接相关。任务是构建一个一阶理论，然后分析其模型，这是逻辑学中的一个标准程序。\n\n该问题分为两部分。首先，我们必须在语言 $\\mathcal{L}=\\{,S,0\\}$ 中提供一个有限的一阶公理集合，用以刻画一个有最小元但无最大元的离散线性序。其次，我们必须确定该理论具有特定有限基数的非同构模型的数量。\n\n**第一部分：公理化**\n\n我们将所需性质表述为一阶逻辑中的一个有限句子集合。\n\n1.  **严格线性序：** 关系 $$ 必须是反自反的、传递的和全序的。\n    *   反自反性：$\\forall x \\, \\neg(x  x)$\n    *   传递性：$\\forall x \\forall y \\forall z \\, ((x  y \\land y  z) \\to x  z)$\n    *   全序性：$\\forall x \\forall y \\, (x  y \\lor y  x \\lor x = y)$\n\n2.  **最小元：** 常数 $0$ 是序关系 $$ 下的最小元素。\n    *   $\\forall x \\, (x=0 \\lor 0  x)$\n\n3.  **后继关系：** 关系 $S(x,y)$ 成立当且仅当 $y$ 是 $x$ 在 $$ 关系下的直接后继。这被定义为 $y$ 是严格大于 $x$ 的 $$-最小元。\n    *   $\\forall x \\forall y \\, (S(x,y) \\leftrightarrow (x  y \\land \\forall z \\, (x  z \\to (y  z \\lor y = z))))$\n    这个公理使得符号 $S$ 的解释依赖于 $$ 的解释。\n\n4.  **后继存在性：** 每个元素都必须有一个 $S$-后继。这确保了序中没有最大元。\n    *   $\\forall x \\exists y \\, S(x,y)$\n\n5.  **非零元素的前驱存在性：** 除 $0$ 之外的每个元素都必须是某个其他元素的 $S$-后继。这确保了第一个元素之后没有“间隙”。\n    *   $\\forall x \\, (\\neg(x=0) \\to \\exists y \\, S(y,x))$\n\n这七个句子的集合构成了所需的有限 $\\mathcal{L}$-句子集。我们将这个理论称为 $T$。$T$ 的标准模型是自然数结构 $(\\mathbb{N}, , S, 0)$，其中 $$ 是通常的序关系，$S$ 是后继函数 $n \\mapsto n+1$，$0$ 是数字零。\n\n**第二部分：基数为 $23$ 的非同构模型数量**\n\n我们被要求找出具有基数 $n=23$ 的、满足第一部分中定义的理论 $T$ 的所有公理的非同构 $\\mathcal{L}$-结构的数量。\n\n设 $\\mathcal{M}$ 是一个 $\\mathcal{L}$-结构，其论域（全集）为 $M$，使得 $|M|=23$。为得出矛盾，我们假设 $\\mathcal{M}$ 是 $T$ 的一个模型。\n\n1.  关于 $$ 的公理强制 $(M, ^{\\mathcal{M}})$ 是一个严格线序集。由于 $M$ 是有限的，基数为 $23$，它必须既有最小元，也有最大（极大）元。设元素排序为 $m_0 ^{\\mathcal{M}} m_1 ^{\\mathcal{M}} \\dots ^{\\mathcal{M}} m_{22}$。\n\n2.  关于常数 $0$ 的公理指出 $0^{\\mathcal{M}}$ 是最小元。因此，我们必须有 $0^{\\mathcal{M}} = m_0$。\n\n3.  $T$ 中的一条公理是后继存在性公理：$\\forall x \\exists y \\, S(x,y)$。它指出论域 $M$ 中的每个元素都有一个 $S$-后继。\n\n4.  我们来考虑 $M$ 上序关系的最大元 $m_{22}$。根据后继存在性公理，这个元素 $m_{22}$ 必须有一个 $S$-后继。设这个所谓的后继是 $y \\in M$。因此，$S(m_{22}, y)$ 必须在 $\\mathcal{M}$ 中成立。\n\n5.  根据定义 $S$ 的公理，$S(m_{22}, y)$ 这个陈述等价于：\n    $$m_{22} ^{\\mathcal{M}} y \\land \\forall z \\in M \\, (m_{22} ^{\\mathcal{M}} z \\to (y ^{\\mathcal{M}} z \\lor y = z))$$\n\n6.  这个合取式的第一部分是 $m_{22} ^{\\mathcal{M}} y$。然而，$m_{22}$ 是有限线性序 $(M, ^{\\mathcal{M}})$ 的最大元。根据最大元的定义，在 $M$ 中不存在元素 $y$ 使得 $m_{22} ^{\\mathcal{M}} y$。\n\n7.  因此，对于 $M$ 中的每一个 $y$，谓词 $m_{22} ^{\\mathcal{M}} y$ 都是假的。这意味着定义 $S(m_{22}, y)$ 的合取式对于 $M$ 中的每一个 $y$ 都是假的。\n\n8.  这意味着在 $M$ 中不存在元素 $y$ 使得 $S(m_{22}, y)$ 成立。换句话说，陈述 $\\neg \\exists y \\, S(m_{22}, y)$ 在 $\\mathcal{M}$ 中为真。\n\n9.  这直接与后继存在性公理 $\\forall x \\exists y \\, S(x,y)$ 相矛盾，而该公理在 $\\mathcal{M}$ 中必须为真。\n\n存在一个基数为 $23$ 的 $T$ 的模型的假设导致了逻辑矛盾。公理集 $T$ 仅在无限论域中是可满足的。任何有限线性序都拥有一个最大元，而这个最大元不可能有理论所要求意义上的后继。\n\n因此，没有任何基数为 $n=23$ 的 $\\mathcal{L}$-结构能够满足所有指定的公理。这类非同构结构的数量是零。", "answer": "$$\\boxed{0}$$", "id": "3059502"}, {"introduction": "我们已经确定一阶逻辑是不可判定的，这意味着不存在一个算法能在有限时间内判定任何给定公式的有效性。但这在实践中是怎样的呢？本练习提供了一个简单的、可满足的公式，并邀请您追踪归结（resolution）证明过程——一种常见的自动推理技术。您将亲眼观察到一个算法，在它公正地寻找矛盾的过程中，如何生成一个永不停止的新结论序列，从而具体地展示了半可判定性（semi-decidability）的含义。[@problem_id:3059505]", "problem": "设词汇表为 $\\{c, s, Q\\}$，其中 $c$ 是一个常量符号，$s$ 是一个一元函数符号，$Q$ 是一个一元谓词符号。考虑闭合一阶句子\n$$\\Phi \\;=\\; Q(c) \\,\\wedge\\, \\forall x\\,\\bigl(Q(x)\\rightarrow Q(s(x))\\bigr).$$\n请在不含等词的经典一阶逻辑框架内进行全部操作。令子句形式指代保持可满足性的常规子句转换（其结果为不含前束量词的子句集）。令归结指代标准的子句二元归结规则，并令公平策略为任何一种随时间推移不会永久忽略任何可归结对或其基实例的策略。\n\n任务：\n1. 从结构、解释和满足的基本定义出发，构造一个模型以证明 $\\Phi$ 是可满足的。\n2. 将 $\\Phi$ 转换为子句形式，并明确列出所得的子句集。\n3. 仅使用归结的可靠性和公平归结策略的定义，论证对第 2 部分所得子句集进行的归结反驳搜索不会终止，从而说明一个与一阶可满足性的不可判定性（丘奇定理）相一致的具体限制。\n4. 在基项上定义项深度函数 $\\operatorname{depth}$ 为 $\\operatorname{depth}(c)=0$ 和 $\\operatorname{depth}(s(t))=1+\\operatorname{depth}(t)$。考虑一个广度优先的公平饱和过程，该过程重复地将第 2 部分中具有蕴含形式的子句与任何形如 $Q(t)$ 的可用单元子句进行归结，以推导出新的单元子句 $Q(s(t))$。令 $N(n)$ 表示在此过程中可推导出的、满足 $\\operatorname{depth}(t)\\le n$ 的、形如 $Q(t)$ 的不同单元子句的数量。计算 $N(n)$ 作为 $n$ 的函数的封闭形式表达式。\n\n你的最终答案必须是关于 $n$ 的单个封闭形式解析表达式。无需取整。", "solution": "该问题对一个一阶句子进行了多部分的分析，重点关注其可满足性、到子句形式的转换、在归结下的行为，以及对一个特定推导过程的量化分析。该问题定义明确，并基于数理逻辑的原理。\n\n**第 1 部分：$\\Phi$ 的可满足性**\n为证明句子 $\\Phi$ 是可满足的，我们必须构造一个使 $\\Phi$ 为真的结构（一个模型）。对于给定的词汇表 $\\{c, s, Q\\}$，一个结构 $\\mathcal{M}$ 由一个非空论域 $D$ 和一个解释函数 $I$ 组成。\n\n令论域 $D$ 为自然数集 $\\mathbb{N} = \\{0, 1, 2, \\dots\\}$。\n令解释函数 $I$ 定义如下：\n$1$. 常量符号 $c$ 的解释，记为 $c^{\\mathcal{M}}$，是数 $0 \\in \\mathbb{N}$。\n$2$. 一元函数符号 $s$ 的解释，记为 $s^{\\mathcal{M}}$，是 $\\mathbb{N}$ 上的后继函数。对任意 $d \\in \\mathbb{N}$，有 $s^{\\mathcal{M}}(d) = d+1$。\n$3$. 一元谓词符号 $Q$ 的解释，记为 $Q^{\\mathcal{M}}$，是所有自然数的集合，即 $Q^{\\mathcal{M}} = \\mathbb{N}$。\n\n现在，我们验证句子 $\\Phi \\equiv Q(c) \\wedge \\forall x (Q(x) \\rightarrow Q(s(x)))$ 在此模型中为真，记为 $\\mathcal{M} \\models \\Phi$。要使一个合取式为真，其两个合取项都必须为真。\n\n第一个合取项：$Q(c)$。\n$\\mathcal{M} \\models Q(c)$ 成立的条件是 $c^{\\mathcal{M}}$ 必须是集合 $Q^{\\mathcal{M}}$ 的一个元素。根据我们的解释，$c^{\\mathcal{M}} = 0$ 且 $Q^{\\mathcal{M}} = \\mathbb{N}$。陈述 $0 \\in \\mathbb{N}$ 是真的。因此，$\\mathcal{M} \\models Q(c)$。\n\n第二个合取项：$\\forall x (Q(x) \\rightarrow Q(s(x)))$。\n要使这个全称量化公式在 $\\mathcal{M}$ 中为真，对于将 $x$ 赋为论域 $D = \\mathbb{N}$ 中任意一个元素的所有情况，子公式 $Q(x) \\rightarrow Q(s(x))$ 都必须被满足。令 $d$ 为 $\\mathbb{N}$ 中的任意元素。我们必须检查蕴含关系是否成立：如果 $d \\in Q^{\\mathcal{M}}$，则 $s^{\\mathcal{M}}(d) \\in Q^{\\mathcal{M}}$。\n代入我们的解释，我们必须对任意 $d \\in \\mathbb{N}$ 进行检查：如果 $d \\in \\mathbb{N}$，那么 $d+1 \\in \\mathbb{N}$。\n对任意自然数 $d$，前提 $d \\in \\mathbb{N}$ 根据定义为真。结论 $d+1 \\in \\mathbb{N}$ 也为真，因为自然数集在后继运算下是封闭的。因此，该蕴含关系对所有 $d \\in \\mathbb{N}$ 都为真，于是我们有 $\\mathcal{M} \\models \\forall x (Q(x) \\rightarrow Q(s(x)))$。\n\n由于两个合取项在 $\\mathcal{M}$ 中都为真，所以句子 $\\Phi$ 在 $\\mathcal{M}$ 中为真。这个模型的存在证明了 $\\Phi$ 是可满足的。\n\n**第 2 部分：转换为子句形式**\n我们将句子 $\\Phi \\equiv Q(c) \\wedge \\forall x (Q(x) \\rightarrow Q(s(x)))$ 转换为其可满足性等价的子句形式。\n该句子是一个合取式，因此我们分别处理每个合取项。\n\n第一个合取项：$Q(c)$。这是一个原子公式，也是一个正文字。它直接构成单元子句 $\\{Q(c)\\}$。\n\n第二个合取项：$\\forall x (Q(x) \\rightarrow Q(s(x)))$。我们应用标准算法：\n$1$. **消除蕴含：** 形式 $A \\rightarrow B$ 等价于 $\\neg A \\vee B$。这得到 $\\forall x (\\neg Q(x) \\vee Q(s(x)))$。\n$2$. **前束范式：** 量词已经位于公式的开头。\n$3$. **Skolem 化：** 没有存在量词，所以此步骤没有效果。\n$4$. **去掉全称量词：** 变量现在被隐式地全称量化。这得到 $\\neg Q(x) \\vee Q(s(x))$。\n$5$. **合取范式（CNF）转换：** 该公式是文字的析取，已经处于合取范式。这表示子句 $\\{\\neg Q(x), Q(s(x))\\}$。\n\n完整的子句集是各部分子句的合取：\n$C = \\{\\{Q(c)\\}, \\{\\neg Q(x), Q(s(x))\\}\\}$。\n\n**第 3 部分：归结的非终止性**\n我们论证，对子句集 $C = \\{\\{Q(c)\\}, \\{\\neg Q(x), Q(s(x))\\}\\}$ 进行的归结反驳搜索不会终止。\n\n$1$. **可满足性：** 到子句形式的转换保持可满足性。由于我们在第 1 部分证明了 $\\Phi$ 是可满足的，其子句形式 $C$ 也必定是可满足的。\n$2$. **归结的可靠性：** 归结推理规则是可靠的。这意味着如果一个子句集 $C$ 是可满足的，那么从 $C$ 推导出空子句 $\\Box$ 是不可能的。推导出 $\\Box$ 等价于证明不可满足性。\n$3$. **从可靠性得出的结论：** 根据第 1 点和第 2 点，由于 $C$ 是可满足的，空子句 $\\Box$ 不能从 $C$ 推导出来。一个归结反驳搜索当且仅当它推导出 $\\Box$ 时才成功终止。因此，该搜索不能以一次成功的反驳而终止。\n$4$. **公平性与无限生成：** 我们还必须证明搜索不会因穷尽所有可能的归结步骤而终止。一个公平的策略保证任何可归结的子句对最终都会被考虑。让我们来考察从 $C$ 出发的推导过程。\n令 $C_1 = \\{Q(c)\\}$ 和 $C_2 = \\{\\neg Q(x), Q(s(x))\\}$。\n将 $C_1$ 与 $C_2$ 进行归结（将 $Q(c)$ 与 $Q(x)$ 合一）产生一个新子句 $C_3 = \\{Q(s(c))\\}$。\n一个公平的策略现在必须考虑将 $C_3$ 与 $C_2$ 进行归结（将 $Q(s(c))$ 与 $Q(x)$ 合一），这会产生一个新子句 $C_4 = \\{Q(s(s(c)))\\}$。\n这个过程会无限持续下去。对于任何形如 $\\{Q(s^k(c))\\}$（其中 $k \\ge 0$）的已推导子句，与 $C_2$ 进行归结都会产生一个新的、不同的子句 $\\{Q(s^{k+1}(c))\\}$。\n由于在每个阶段都可以生成新的子句，可推导子句的集合是无限的。一个公平的策略永远不会穷尽所有可能的归结。\n\n因为空子句是不可推导的（根据可靠性），并且新的子句被无限地生成，所以一个公平的归结搜索不会终止。这说明了一个案例，其中用于不可满足性的半判定过程（归结所提供的）对于一个可满足的公式正确地未能停止，这一行为与一阶逻辑的不可判定性（丘奇定理）相一致。\n\n**第 4 部分：$N(n)$ 的封闭形式表达式**\n$N(n)$ 是满足 $\\operatorname{depth}(t) \\le n$ 的、形如 $\\{Q(t)\\}$ 的不同可推导单元子句的数量。推导过程从子句集 $C$ 开始，并重复地将子句 $\\{\\neg Q(x), Q(s(x))\\}$ 与可用的单元子句进行归结。\n\n初始单元子句是 $\\{Q(c)\\}$。其项为 $t_0 = c$。根据定义，$\\operatorname{depth}(t_0) = 0$。\n第一步归结使用 $\\{Q(c)\\}$ 推导出 $\\{Q(s(c))\\}$。其项为 $t_1 = s(c)$。它的深度是 $\\operatorname{depth}(t_1) = 1 + \\operatorname{depth}(c) = 1+0 = 1$。\n下一步使用 $\\{Q(s(c))\\}$ 推导出 $\\{Q(s(s(c)))\\}$。其项为 $t_2 = s(s(c))$。它的深度是 $\\operatorname{depth}(t_2) = 1 + \\operatorname{depth}(s(c)) = 1+1 = 2$。\n\n通过归纳法，该过程生成一系列单元子句 $\\{Q(s^k(c))\\}$，其中 $k = 0, 1, 2, \\dots$。第 $k$ 个这样的子句（从 $k=0$ 开始）中的项是 $t_k = s^k(c)$。\n项 $t_k$ 的深度由递归定义 $\\operatorname{depth}(s(t)) = 1 + \\operatorname{depth}(t)$ 计算得出：\n$\\operatorname{depth}(t_k) = \\operatorname{depth}(s^k(c)) = k$。\n\n所有不同的可推导单元子句的集合是 $\\{\\{Q(s^k(c))\\} \\mid k \\in \\mathbb{N}, k \\ge 0\\}$。\n我们需要计算这些子句中有多少个其项 $t$ 满足 $\\operatorname{depth}(t) \\le n$。\n代入 $t = s^k(c)$ 和 $\\operatorname{depth}(t) = k$，条件变为 $k \\le n$。\n由于 $k$ 必须是一个非负整数，我们正在计算集合 $\\{0, 1, 2, \\dots, n\\}$ 中整数的数量。\n这个集合中元素的数量是 $(n - 0) + 1 = n+1$。\n\n因此，$N(n)$ 的封闭形式表达式是 $n+1$。", "answer": "$$\n\\boxed{n+1}\n$$", "id": "3059505"}]}