{"hands_on_practices": [{"introduction": "可计算函数理论的核心在于从一套简单的初始函数和规则出发，构建出所有能够被算法执行的复杂操作。本练习将带你亲手实践这一构造过程，通过原始递归的形式化定义，一步步构建出加法、乘法和截断减法等我们熟悉的算术函数。这个过程将加深你对“计算”本质的理解，并为你掌握更高级的理论打下坚实基础。[@problem_id:3038773]", "problem": "令 $\\mathbb{N}$ 表示自然数集。$\\mathbb{N}^{k}$ 上的原始递归 (PR) 函数类是由初始函数在复合和原始递归运算下闭合生成的。初始函数包括零函数 $Z^{n}:\\mathbb{N}^{n}\\to\\mathbb{N}$（定义为 $Z^{n}(\\vec{x})=0$），后继函数 $S:\\mathbb{N}\\to\\mathbb{N}$（定义为 $S(x)=x+1$），以及投影函数 $U^{n}_{i}:\\mathbb{N}^{n}\\to\\mathbb{N}$（定义为 $U^{n}_{i}(x_{1},\\dots,x_{n})=x_{i}$，其中 $1\\leq i\\leq n$）。复合运算将函数 $f$ 和 $g_{1},\\dots,g_{m}$ 映射为 $C(f,g_{1},\\dots,g_{m})(\\vec{x})=f(g_{1}(\\vec{x}),\\dots,g_{m}(\\vec{x}))$。原始递归运算将函数 $g:\\mathbb{N}^{n}\\to\\mathbb{N}$ 和 $h:\\mathbb{N}^{n+2}\\to\\mathbb{N}$ 映射为满足以下条件的唯一函数 $f:\\mathbb{N}^{n+1}\\to\\mathbb{N}$：\n$$\nf(0,\\vec{x})=g(\\vec{x}),\\quad f(S(y),\\vec{x})=h\\big(y,\\vec{x},f(y,\\vec{x})\\big).\n$$\n仅从这些基本定义出发，构造显式的原始递归模式，以证明以下三个函数是原始递归 (PR) 的：\n- 加法 $A:\\mathbb{N}^{2}\\to\\mathbb{N}$，其中 $A(x,y)=x+y$。\n- 乘法 $M:\\mathbb{N}^{2}\\to\\mathbb{N}$，其中 $M(x,y)=x\\cdot y$。\n- 截断减法 $T:\\mathbb{N}^{2}\\to\\mathbb{N}$，其中 $T(x,y)=\\max(x-y,0)$。\n\n在你的构造中，你可以引入并证明你所需要的辅助 PR 函数（例如，前驱函数）。完成构造后，定义复合函数\n$$\nF(x,y)\\;=\\;T\\Big(M\\big(x,\\,S(S(y))\\big),\\;A\\big(x,\\,T\\big(y,\\,S(x)\\big)\\big)\\Big),\n$$\n并计算 $F(3,5)$ 的值。将你的最终答案以单个实数的形式给出。无需四舍五入。", "solution": "该问题是有效的，因为它是可计算性理论中的一个标准练习，基于原始递归函数的明确定义和数学上合理的原则。所有术语都是标准的，任务陈述清晰明确。\n\n我们将从初始函数（零函数 $Z^n$、后继函数 $S$ 和投影函数 $U^n_i$）以及复合和原始递归运算出发，显式地构造所需的函数。我们假设自然数集为 $\\mathbb{N}=\\{0, 1, 2, \\dots\\}$，这与原始递归定义中的基本情况 $f(0,\\vec{x})$ 相一致。\n\n1.  **加法: $A(x,y) = x+y$**\n\n    我们通过对第一个参数 $x$ 进行递归来定义加法。\n    函数 $A:\\mathbb{N}^2 \\to \\mathbb{N}$ 满足以下两个方程：\n    $$A(0,y) = y$$\n    $$A(S(x),y) = (x+1)+y = (x+y)+1 = S(A(x,y))$$\n    这是一个原始递归模式 $f(0,\\vec{x}) = g(\\vec{x})$ 和 $f(S(y),\\vec{x}) = h(y, \\vec{x}, f(y,\\vec{x}))$ 的实例。在我们的例子中，递归是针对 $x$ 的，参数是 $y$，函数是 $A(x,y)$。\n    $A(x,y)$ 的模式如下：\n    -   基本情况: $A(0,y) = g(y)$。我们有 $A(0,y) = y$，因此可以定义 $g:\\mathbb{N} \\to \\mathbb{N}$ 为 $g(y) = y$。这是投影函数 $U^1_1(y)$。函数 $U^1_1$ 是一个初始函数，因此是原始递归 (PR) 的。\n    -   递归步骤: $A(S(x), y) = h(x,y,A(x,y))$。我们有 $A(S(x),y) = S(A(x,y))$。因此我们定义 $h:\\mathbb{N}^3 \\to \\mathbb{N}$ 为 $h(x,y,z) = S(z)$，其中 $z$ 代表 $A(x,y)$ 的值。形式上表示为 $h(x,y,z) = S(U^3_3(x,y,z))$。这个函数是初始函数 $S$ 和初始函数 $U^3_3$ 的复合，因此是 PR 的。\n    因为 $g=U^1_1$ 和 $h=S \\circ U^3_3$ 都是 PR 的，所以由它们通过原始递归定义的函数 $A$ 也是 PR 的。\n\n2.  **乘法: $M(x,y) = x \\cdot y$**\n\n    我们利用前面已证明为 PR 的加法函数 $A$，通过对 $x$ 进行递归来定义乘法。\n    函数 $M:\\mathbb{N}^2 \\to \\mathbb{N}$ 满足：\n    $$M(0,y) = 0 \\cdot y = 0$$\n    $$M(S(x),y) = (x+1) \\cdot y = x \\cdot y + y = A(M(x,y), y)$$\n    这符合 $M(x,y)$ 的原始递归模式：\n    -   基本情况: $M(0,y) = g(y)$。我们有 $M(0,y)=0$。因此我们定义 $g:\\mathbb{N} \\to \\mathbb{N}$ 为 $g(y)=0$。这是零函数 $Z^1(y)$，它是一个初始函数，因此是 PR 的。\n    -   递归步骤: $M(S(x),y) = h(x,y,M(x,y))$。我们有 $M(S(x),y) = A(M(x,y), y)$。令 $z = M(x,y)$，则我们需要 $h(x,y,z) = A(z,y)$。形式上，这是 $h(x,y,z) = A(U^3_3(x,y,z), U^3_2(x,y,z))$。由于 $A$ 是 PR 的，并且投影函数是初始函数，所以 $h$ 是通过 PR 函数的复合得到的，因此是 PR 的。\n    因为 $g=Z^1$ 和 $h=A \\circ (U^3_3, U^3_2)$ 都是 PR 的，所以通过原始递归定义的函数 $M$ 也是 PR 的。\n\n3.  **截断减法: $T(x,y) = \\max(x-y,0)$**\n\n    为了定义截断减法，我们首先需要一个辅助函数，即前驱函数 $P(x) = \\max(x-1,0)$。\n    -   **辅助函数: 前驱函数 $P(x)$**\n        函数 $P:\\mathbb{N} \\to \\mathbb{N}$ 通过对 $x$ 进行递归定义：\n        $$P(0)=0$$\n        $$P(S(x)) = x$$\n        对于一元函数，原始递归模式为 $f(0)=c$ 和 $f(S(x))=h(x,f(x))$。\n        -   基本情况: $P(0)=0$。常数 $0$ 由零函数 $Z^0()$ 给出。\n        -   递归步骤: $P(S(x)) = h(x,P(x))$。我们有 $P(S(x))=x$，所以 $h(x,z) = x$。这是投影函数 $U^2_1(x,z)$。\n        由于常数 $0$ 和函数 $U^2_1$ 都是 PR 的，所以前驱函数 $P$ 是 PR 的。\n\n    现在我们定义截断减法 $T(x,y)$，也记作 $x \\dot{-} y$。递归必须对被定义函数的第一个参数进行。为了对 $y$ 进行递归，我们定义一个中间函数 $f(y,x) = x \\dot{-} y$。\n    $$f(0,x) = x \\dot{-} 0 = x$$\n    $$f(S(y),x) = x \\dot{-} (y+1) = P(x \\dot{-} y) = P(f(y,x))$$\n    -   基本情况: $f(0,x) = g(x)$。我们有 $f(0,x)=x$。所以 $g(x) = U^1_1(x)$，它是 PR 的。\n    -   递归步骤: $f(S(y),x) = h(y,x,f(y,x))$。我们有 $f(S(y),x) = P(f(y,x))$。令 $z=f(y,x)$，所以 $h(y,x,z) = P(z) = P(U^3_3(y,x,z))$。由于 $P$ 是 PR 的且 $U^3_3$ 是初始函数，所以 $h$ 通过复合也是 PR 的。\n    因此，$f(y,x)$ 是 PR 的。所求函数为 $T(x,y) = x \\dot{-} y = f(y,x)$。我们可以通过交换参数从 $f$ 获得 $T$，这是一个复合运算：$T(x,y) = f(U^2_2(x,y), U^2_1(x,y))$。由于 $f$ 和投影函数都是 PR 的，所以 $T$ 也是 PR 的。\n\n4.  **计算 $F(3,5)$**\n\n    复合函数由下式给出：\n    $$F(x,y)\\;=\\;T\\Big(M\\big(x,\\,S(S(y))\\big),\\;A\\big(x,\\,T\\big(y,\\,S(x)\\big)\\big)\\Big)$$\n    我们需要计算 $F(3,5)$。我们代入 $x=3$ 和 $y=5$：\n    $$F(3,5)\\;=\\;T\\Big(M\\big(3,\\,S(S(5))\\big),\\;A\\big(3,\\,T\\big(5,\\,S(3)\\big)\\big)\\Big)$$\n    我们从内到外计算各项。\n    -   $S(3) = 3+1 = 4$。\n    -   $S(5) = 5+1 = 6$。\n    -   $S(S(5)) = S(6) = 6+1 = 7$。\n    代入这些值可得：\n    $$F(3,5)\\;=\\;T\\Big(M(3, 7),\\;A\\big(3,\\,T(5, 4)\\big)\\Big)$$\n    现在我们计算最外层函数 $T$ 的参数：\n    -   第一个参数是 $M(3, 7) = 3 \\cdot 7 = 21$。\n    -   第二个参数是 $A\\big(3,\\,T(5, 4)\\big)$。我们首先计算 $T(5,4)$：\n        $T(5,4) = \\max(5-4, 0) = \\max(1, 0) = 1$。\n        现在我们计算 $A(3,1)$：\n        $A(3,1) = 3+1 = 4$。\n    所以，第二个参数是 $4$。\n    最后，我们将这些值代回到 $F(3,5)$ 的表达式中：\n    $$F(3,5) = T(21, 4)$$\n    我们计算最终结果：\n    $$T(21, 4) = \\max(21-4, 0) = \\max(17, 0) = 17$$\n    $F(3,5)$ 的值为 $17$。", "answer": "$$\\boxed{17}$$", "id": "3038773"}, {"introduction": "在掌握了如何构造可计算函数之后，一个关键问题随之而来：关于这些函数，有哪些性质是我们可以通过算法自动判定的？莱斯定理（Rice's Theorem）为我们揭示了一个深刻的限制，即任何关于函数行为的非平凡性质都是不可判定的。本练习旨在帮助你精确理解该定理的适用范围，通过区分程序的“句法”属性（其代码的表面特征）和“语义”属性（其计算的行为和结果），这是理解计算极限的关键一步。[@problem_id:3038772]", "problem": "固定一种图灵机（TM）程序的标准有效编码，使得每个程序都被赋予自然数集 $\\mathbb{N}$ 中的一个唯一的 Gödel 编码。对于每个编码 $e \\in \\mathbb{N}$，令 $\\varphi_e$ 表示由编码为 $e$ 的图灵机程序计算的部分可计算函数。如果一个子集 $A \\subseteq \\mathbb{N}$ 的特征函数 $\\chi_A \\colon \\mathbb{N} \\to \\{0,1\\}$ 是可计算的，则称该子集是可判定的。如果一个程序的性质仅依赖于程序的表示或描述（例如，其长度或其代码中是否存在特定符号），则称该性质是句法性的；如果它仅依赖于所计算函数的外延行为（例如，$\\varphi_e$ 的值域和定义域），则称该性质是语义性的。\n\n选择所有正确指出了一个句法性且可判定的性质，并正确解释了为什么 Rice 定理不适用于它的选项。每个选项描述了一个索引集合和简要的理由。\n\nA. $S_{\\text{len}} = \\{ e \\in \\mathbb{N} : \\text{编码为 } e \\text{ 的程序指令少于 } 100 \\text{ 条} \\}$。该性质是可判定的，因为可以通过解析有限的代码并计算指令数量来确定；Rice 定理不适用，因为该性质依赖于程序的句法，而不是函数 $\\varphi_e$。\n\nB. $Z = \\{ e \\in \\mathbb{N} : \\text{对所有 } x \\in \\mathbb{N} \\text{，都有 } \\varphi_e(x) = 0 \\}$。该性质是可判定的，因为可以通过测试输入来确定；Rice 定理不适用，因为该性质与程序的句法有关。\n\nC. $D_0 = \\{ e \\in \\mathbb{N} : \\varphi_e(0) \\text{ 有定义} \\}$。该性质是句法性的且可判定的，因为可以检查输入为 0 时的代码路径来确定；Rice 定理适用，意味着它是不可判定的。\n\nD. $P_{\\text{prime}} = \\{ e \\in \\mathbb{N} : e \\text{ 是一个素数} \\}$。该性质是可判定的，因为可以使用素性测试来确定；Rice 定理不适用，因为该性质仅依赖于数值 Gödel 编码 $e$，而不依赖于 $\\varphi_e$ 的外延行为。\n\nE. $T = \\{ e \\in \\mathbb{N} : \\varphi_e \\text{ 是全函数} \\}$。该性质是可判定的，因为一个不循环的程序必然在每个输入上停机；Rice 定理在这里不相关。\n\n选择所有正确的选项。", "solution": "用户希望我识别出哪些选项正确地描述了一个图灵机程序的性质，该性质是句法性的、可判定的，并且其中对 Rice 定理不适用性的解释是正确的。\n\n首先，让我们根据问题陈述来确定核心定义和定理。\n- Gödel 编码为每个图灵机程序分配一个唯一的自然数 $e \\in \\mathbb{N}$。$\\varphi_e$ 表示由编码为 $e$ 的程序计算的部分可计算函数。\n- 如果一个集合 $A \\subseteq \\mathbb{N}$ 的特征函数 $\\chi_A: \\mathbb{N} \\to \\{0, 1\\}$ 是可计算的，则该集合是可判定的。这意味着存在一个算法，对于任何输入 $n \\in \\mathbb{N}$，如果 $n \\in A$，该算法停机并输出 1；如果 $n \\notin A$，该算法停机并输出 0。\n- 如果一个程序的性质仅依赖于代码 $e$ 本身，则该性质是**句法性的**。形式上，如果一个性质（由索引集 S ⊆ N 表示）不是语义性的，则称其为句法性的。\n- 如果一个程序的性质依赖于该程序计算的函数 $\\varphi_e$，则该性质是**语义性的**。形式上，如果对于任意两个程序编码 $e, f \\in \\mathbb{N}$，若 $\\varphi_e = \\varphi_f$（意味着它们计算相同的部分函数），则 $e \\in S$ 当且仅当 $f \\in S$，那么索引集 $S \\subseteq \\mathbb{N}$ 代表一个语义性质。\n- **Rice 定理**：部分可计算函数的任何非平凡语义性质都是不可判定的。如果至少存在一个具有该性质的可计算函数，并且至少存在一个不具有该性质的可计算函数，则该性质是非平凡的。\n\n任务是找出描述的索引集 S 满足三个标准的选项：\n1. 定义 S 的性质是句法性的。\n2. 集合 S 是可判定的。\n3. 关于 Rice 定理不适用的解释是正确的。\n\n让我们逐一评估每个选项。\n\n**A. $S_{\\text{len}} = \\{ e \\in \\mathbb{N} : \\text{编码为 } e \\text{ 的程序指令少于 } 100 \\text{ 条} \\}$。该性质是可判定的，因为可以通过解析有限的代码并计算指令数量来确定；Rice 定理不适用，因为该性质依赖于程序的句法，而不是函数 $\\varphi_e$。**\n\n1. **句法性质**：指令数量是程序描述（其代码）的一个特征，而不是它所计算的函数的特征。可以创建两个不同的程序，$p_1$ 和 $p_2$，其编码为 $e_1$ 和 $e_2$，使得 $\\varphi_{e_1} = \\varphi_{e_2}$，但 $p_1$ 的指令少于 100 条，而 $p_2$ 有 100 条或更多（例如，通过向 $p_1$ 添加多余的“无操作”指令来创建 $p_2$）。因此，即使它们计算相同的函数，$e_1$ 可能在 $S_{\\text{len}}$ 中，而 $e_2$ 不在。这违反了语义性质的条件，因此该性质是句法性的。这部分陈述是正确的。\n\n2. **可判定集**：问题陈述中提到存在“标准有效编码”。这意味着给定一个数字 $e$，我们可以通过算法将其解码以获得程序的表示。解码后，计算指令数量是对有限字符串或结构的简单解析任务。一个算法可以接受 $e$ 作为输入，对其进行解码，计算指令数，将计数与 100 比较，如果计数小于 100 则输出 1，否则输出 0。该算法总是停机。因此，集合 $S_{\\text{len}}$ 是可判定的。这部分陈述是正确的。\n\n3. **对 Rice 定理的解释**：给出的解释是“Rice 定理不适用，因为该性质依赖于程序的句法，而不是函数 $\\varphi_e$”。这完全正确。Rice 定理仅适用于非平凡的*语义*性质。由于此性质是句法性的，因此 Rice 定理不适用。\n\n**对 A 的结论**：此选项正确地指出了一个句法性、可判定的性质，并为 Rice 定理的不适用性提供了正确的理由。**正确**。\n\n**B. $Z = \\{ e \\in \\mathbb{N} : \\text{对所有 } x \\in \\mathbb{N} \\text{，都有 } \\varphi_e(x) = 0 \\}$。该性质是可判定的，因为可以通过测试输入来确定；Rice 定理不适用，因为该性质与程序的句法有关。**\n\n1. **句法性质**：计算常数零函数的性质是函数行为（其输入-输出映射）的性质。如果 $\\varphi_e$ 是常数零函数且 $\\varphi_f = \\varphi_e$，那么 $\\varphi_f$ 也必须是常数零函数。所以，$e \\in Z \\iff f \\in Z$。这是语义性质的定义。声称它“与程序的句法有关”是错误的。\n\n2. **可判定集**：“计算常数零函数”这一性质是一个非平凡的语义性质。常数零函数是可计算的，所以有些程序具有此性质。后继函数 $s(x) = x+1$ 也是可计算的，但不具有此性质。因此，根据 Rice 定理，集合 $Z$ 是不可判定的。声称它“可通过测试输入来判定”是错误的，因为无法在有限时间内测试所有无限多个输入 $x \\in \\mathbb{N}$。\n\n3. **对 Rice 定理的解释**：该选项声称 Rice 定理不适用。这是错误的。由于该性质是非平凡的和语义性的，Rice 定理恰恰是证明其不可判定性的工具。\n\n**对 B 的结论**：此选项在所有三个方面都是错误的。该性质是语义性的和不可判定的，并且 Rice 定理确实适用。**不正确**。\n\n**C. $D_0 = \\{ e \\in \\mathbb{N} : \\varphi_e(0) \\text{ 有定义} \\}$。该性质是句法性的且可判定的，因为可以检查输入为 0 时的代码路径来确定；Rice 定理适用，意味着它是不可判定的。**\n\n1. **句法性质**：$\\varphi_e(0)$ 是否停机是函数 $\\varphi_e$ 定义域的一个性质。如果 $\\varphi_e = \\varphi_f$，它们的定义域必须相同。因此，如果 $\\varphi_e(0)$ 有定义，那么 $\\varphi_f(0)$ 也必须有定义。这是一个语义性质。声称它是句法性的是错误的。\n\n2. **可判定集**：集合 $D_0$ 是在输入 0 上停机的程序的索引集。这是针对固定输入的停机问题，通常表示为 $K_0$。在可计算性理论中，这是一个经典结果，即该集合是不可判定的。声称它“可通过检查代码路径来判定”是错误的；这种检查恰恰就是停机问题。\n\n3. **对 Rice 定理的解释**：该选项的陈述自相矛盾。它首先声称该性质是可判定的，然后又说“Rice 定理适用，意味着不可判定性”。虽然 Rice 定理确实适用（该性质是非平凡的和语义性的）并意味着不可判定性，但这与最初的可判定性断言相矛盾。整个陈述是不一致的。\n\n**对 C 的结论**：该选项错误地将性质识别为句法性和可判定的。其推理是自相矛盾的。**不正确**。\n\n**D. $P_{\\text{prime}} = \\{ e \\in \\mathbb{N} : e \\text{ 是一个素数} \\}$。该性质是可判定的，因为可以使用素性测试来确定；Rice 定理不适用，因为该性质仅依赖于数值 Gödel 编码 $e$，而不依赖于 $\\varphi_e$ 的外延行为。**\n\n1. **句法性质**：整数 $e$ 是否为素数这一性质仅取决于 $e$ 本身的值。它与编码为 $e$ 的程序所计算的函数 $\\varphi_e$ 没有任何关系。我们可以有两个编码为 $e$ 和 $f$ 的程序，使得 $\\varphi_e = \\varphi_f$，但 $e$ 是素数而 $f$ 是合数。这是索引的性质，而不是函数的性质，因此是句法性的。这部分陈述是正确的。\n\n2. **可判定集**：素数集是 $\\mathbb{N}$ 的一个可判定子集。存在许多众所周知的算法（例如，试除法、埃拉托斯特尼筛法、Miller-Rabin 测试），可以在有限步骤内确定给定数 $e$ 是否为素数。这部分陈述是正确的。\n\n3. **对 Rice 定理的解释**：解释是 Rice 定理不适用，因为该性质仅依赖于编码 $e$ 而不依赖于函数 $\\varphi_e$。这是正确的。Rice 定理仅适用于语义性质。由于索引 $e$ 的素性是一个句法性质，Rice 定理与其可判定性无关。\n\n**对 D 的结论**：此选项正确地指出了一个句法性、可判定的性质，并为 Rice 定理的不适用性提供了正确的理由。**正确**。\n\n**E. $T = \\{ e \\in \\mathbb{N} : \\varphi_e \\text{ 是全函数} \\}$。该性质是可判定的，因为一个不循环的程序必然在每个输入上停机；Rice 定理在这里不相关。**\n\n1. **句法性质**：全性（在所有输入上停机）是函数 $\\varphi_e$ 的一个性质。如果 $\\varphi_e = \\varphi_f$ 并且 $\\varphi_e$ 是全函数，那么 $\\varphi_f$ 也必须是全函数。这是一个语义性质。\n\n2. **可判定集**：全性是一个非平凡的语义性质。恒等函数是全函数，而一个处处无定义的函数则不是。根据 Rice 定理，集合 $T$ 是不可判定的。事实上，一个众所周知的结果是，$T$ 甚至不是半可判定的（它在算术层次结构中是 $\\Pi_2$-完备的）。声称它是可判定的是错误的。\n\n3. **对 Rice 定理的解释**：该选项声称 Rice 定理“在这里不相关”。这是错误的。由于该性质是非平凡的和语义性的，Rice 定理直接相关，并且是用于证明 $T$ 不可判定性的标准工具。\n\n**对 E 的结论**：此选项是错误的。该性质是语义性的和不可判定的，并且 Rice 定理直接适用。**不正确**。\n\n总之，只有选项 A 和 D 满足所有要求的条件。", "answer": "$$\\boxed{AD}$$", "id": "3038772"}, {"introduction": "本练习将多个核心概念融会贯通，引导你分析可计算性理论中最著名也最重要的集合之一——对角停机集 $K$。你将运用偏递归函数、半可判定性以及莱斯定理等工具，不仅证明该集合是半可判定的，还将推断出其补集并非半可判定。这个实践将全面展示理论工具的威力，让你亲身体验如何证明关于计算本身固有限制的深刻结论。[@problem_id:3048503]", "problem": "设 $\\{\\varphi_{e}\\}_{e \\in \\mathbb{N}}$ 是所有从 $\\mathbb{N}$ 到 $\\mathbb{N}$ 的部分递归（部分可计算）函数的一个标准有效枚举，该枚举由一个通用部分递归函数 $U$ 导出，满足对所有 $e,x \\in \\mathbb{N}$ 都有 $U(e,x) \\simeq \\varphi_{e}(x)$。定义部分递归谓词 $P(x)$，它当且仅当 $\\varphi_{x}(x)$ 停机时为真。等价地，记集合 $A \\subseteq \\mathbb{N}$ 为 $A = \\{x \\in \\mathbb{N} : P(x) \\text{ 为真}\\} = \\{x \\in \\mathbb{N} : \\varphi_{x}(x) \\downarrow\\}$，其中 $\\downarrow$ 表示收敛。\n\n仅使用部分递归函数和一般递归函数理论的基本定义和事实，完成以下任务：\n\n1) 根据 $U$ 构造一个部分函数 $f \\colon \\mathbb{N} \\rightharpoonup \\mathbb{N}$，其定义域恰好是 $A$。证明 $f$ 是部分递归的。\n\n2) 根据此构造以及递归可枚举集与部分递归函数定义域之间的标准等价性，推断 $A$ 是否是半可判定的（递归可枚举的）。\n\n3) 使用 Rice 定理（该定理指出部分可计算函数的任意非平凡外延性质都是不可判定的），确定 $A$ 是否是可判定的。并由此推断其补集 $\\overline{A}$ 是否是半可判定的。\n\n4) 定义指示值 $\\chi_{A}$ 和 $\\chi_{\\overline{A}}$：如果 $A$ 是半可判定的，则 $\\chi_{A} = 1$，否则 $\\chi_{A} = 0$；$\\chi_{\\overline{A}}$ 的定义类似。计算单个实数值\n$$\nS \\;=\\; \\chi_{A} \\;+\\; \\chi_{\\overline{A}}.\n$$\n\n你的最终答案必须是单个数字。无需四舍五入。不要包含任何单位。", "solution": "首先将根据指定标准验证问题陈述。\n\n### 第1步：提取已知条件\n- $\\{\\varphi_{e}\\}_{e \\in \\mathbb{N}}$：一个从 $\\mathbb{N}$ 到 $\\mathbb{N}$ 的所有部分递归函数的标准有效枚举。\n- $U$：一个通用部分递归函数，满足对所有 $e,x \\in \\mathbb{N}$ 都有 $U(e,x) \\simeq \\varphi_{e}(x)$。\n- $P(x)$：一个部分递归谓词，当且仅当 $\\varphi_{x}(x)$ 停机时为真。\n- $A$：集合 $A = \\{x \\in \\mathbb{N} : P(x) \\text{ 为真}\\} = \\{x \\in \\mathbb{N} : \\varphi_{x}(x) \\downarrow\\}$。\n- 任务1：根据 $U$ 构造一个部分函数 $f \\colon \\mathbb{N} \\rightharpoonup \\mathbb{N}$，其定义域恰好是 $A$，并证明 $f$ 是部分递归的。\n- 任务2：根据任务1的构造推断 $A$ 是否是半可判定的（递归可枚举的）。\n- 任务3：使用 Rice 定理确定 $A$ 是否是可判定的，并由此推断其补集 $\\overline{A}$ 是否是半可判定的。\n- 任务4：定义 $\\chi_{A} = 1$ 如果 $A$ 是半可判定的，否则 $\\chi_{A} = 0$，对 $\\chi_{\\overline{A}}$ 也类似。计算 $S = \\chi_{A} + \\chi_{\\overline{A}}$。\n\n### 第2步：使用提取的已知条件进行验证\n- **科学基础：** 该问题完全设置在可计算性理论（数理逻辑的一个分支）的形式框架内。所使用的所有定义和概念——例如部分递归函数、通用函数、半可判定性（递归可枚举）、可判定性（递归）和 Rice 定理——都是该领域的标准和基础概念。集合 $A$ 是经典的对角停机问题集，通常记作 $K$。\n- **良构性：** 该问题被构造为四个清晰且相互关联的任务序列。每个问题都是精确的，并且在已建立的理论中都有确定且唯一的答案。\n- **客观性：** 语言是形式化的，没有任何主观或模棱两可的术语。\n- **结论：** 该问题是自洽的、逻辑一致的且科学上合理的。它是数理逻辑中的一个有效问题。\n\n### 第3步：结论与行动\n该问题有效。将提供完整的解答。\n\n### 解答\n\n解答过程按顺序处理四个任务。\n\n**1) 部分函数 $f$ 的构造**\n\n我们被要求构造一个部分函数 $f \\colon \\mathbb{N} \\rightharpoonup \\mathbb{N}$，其定义域为集合 $A = \\{x \\in \\mathbb{N} : \\varphi_{x}(x) \\downarrow\\}$。部分函数的定义域是使其收敛（停机）的输入集合。我们已知一个通用部分递归函数 $U$，满足 $U(e,x) \\simeq \\varphi_e(x)$。\n\n让我们如下定义函数 $f$：\n$$f(x) \\simeq U(x,x)$$\n这个定义使用了通用函数 $U$，并将其两个参数都设置为输入 $x$。\n\n我们必须证明这个 $f$ 是一个部分递归函数。递归函数理论确立了新的部分递归函数可以通过组合现有函数来构造。这里，$f$ 是通过通用函数 $U$ 与投影函数 $\\pi_1^1(x)=x$ 和 $\\pi_1^1(x)=x$ 的复合来定义的。形式上，$f(x) \\simeq U(\\pi_1^1(x), \\pi_1^1(x))$。由于根据定义 $U$ 是部分递归的，并且投影函数是原始递归的（因此也是部分递归的），它们的复合 $f$ 也是一个部分递归函数。\n\n接下来，我们必须证明 $f$ 的定义域，记作 $\\text{dom}(f)$，恰好是 $A$。\n$f$ 的定义域是所有使 $f(x)$ 停机的 $x \\in \\mathbb{N}$ 的集合。\n$$\\text{dom}(f) = \\{x \\in \\mathbb{N} : f(x) \\downarrow\\}$$\n根据我们对 $f$ 的定义，$f(x) \\downarrow$ 当且仅当 $U(x,x) \\downarrow$。\n根据通用函数的定义，$U(x,x) \\downarrow$ 当且仅当 $\\varphi_x(x) \\downarrow$。\n这恰好是集合 $A$ 的定义。因此，\n$$\\text{dom}(f) = \\{x \\in \\mathbb{N} : \\varphi_x(x) \\downarrow\\} = A$$\n这就完成了第一个任务的构造和证明。\n\n**2) $A$ 的半可判定性**\n\n可计算性理论中的一个基本结果建立了递归可枚举集与部分递归函数定义域之间的等价性。一个集合 $S \\subseteq \\mathbb{N}$ 是递归可枚举的（RE），当且仅当存在一个部分递归函数 $g$ 使得 $S = \\text{dom}(g)$。“半可判定的”是“递归可枚举的”的同义词。一个图灵机半判定一个集合 $S$ 是指，当且仅当 $x \\in S$ 时，该图灵机在输入 $x$ 上停机。计算第(1)部分中构造的函数 $f$ 的图灵机对集合 $A$ 所做的正是如此。\n\n因为我们已经构造了一个部分递归函数 $f$ 使得 $\\text{dom}(f) = A$，我们可以直接从这个定理得出结论：集合 $A$ 是递归可枚举的，因此是半可判定的。\n\n**3) $A$ 的可判定性与 $\\overline{A}$ 的半可判定性**\n\n首先，我们确定 $A$ 是否是可判定的（或递归的）。题目指示我们使用 Rice 定理。Rice 定理指出，对于部分递归函数的任何非平凡性质 $\\mathcal{P}$，其指标集 $I_{\\mathcal{P}} = \\{e \\in \\mathbb{N} : \\varphi_e \\in \\mathcal{P}\\}$ 是不可判定的。一个性质是非平凡的，如果至少有一个部分递归函数具有该性质，且至少有一个不具有。\n\n集合 $A = \\{x : \\varphi_x(x) \\downarrow\\}$ 并不是 Rice 定理所需形式的直接指标集。但是，我们可以使用 Rice 定理来证明停机问题是不可判定的，然后将停机问题归约到 $A$。\n\n让我们考虑“在输入 $0$ 上停机”这个性质。设此性质为 $\\mathcal{P}_0 = \\{\\psi : \\psi(0) \\downarrow\\}$。\n- 这个性质是非平凡的：处处无定义的函数不具有性质 $\\mathcal{P}_0$。对所有 $x$ 都有 $g(x) = 0$ 的函数具有性质 $\\mathcal{P}_0$。\n- 根据 Rice 定理，这个性质的指标集 $H_0 = \\{e \\in \\mathbb{N} : \\varphi_e(0) \\downarrow\\}$ 是不可判定的。\n\n现在，我们证明如果 $A$ 是可判定的，那么 $H_0$ 也将是可判定的，这是一个矛盾。我们构造一个从 $H_0$ 到 $A$ 的多一归约。根据 s-m-n 定理（或参数定理），对于任意给定的指标 $e$，存在一个全递归函数 $s(e)$，使得对所有 $y \\in \\mathbb{N}$：\n$$\\varphi_{s(e)}(y) \\simeq \\varphi_e(0)$$\n这意味着函数 $\\varphi_{s(e)}$ 是一个常数函数，其行为（停机或发散）与 $\\varphi_e(0)$ 的行为相同。\n现在，考虑 $\\varphi_{s(e)}$ 在其自身指标 $s(e)$ 上的行为。根据上述定义：\n$$\\varphi_{s(e)}(s(e)) \\text{ 停机 } \\iff \\varphi_e(0) \\text{ 停机}$$\n这等价于逻辑陈述：\n$$s(e) \\in A \\iff e \\in H_0$$\n这构成了从 $H_0$ 到 $A$ 的一个多一归约。如果 $A$ 是可判定的，我们就可以通过先计算指标 $s(e)$（因为 $s$ 是全递归的），然后使用 $A$ 的判定器来检查 $s(e) \\in A$ 是否成立，从而判定任意 $e$ 是否属于 $H_0$。这将使得 $H_0$ 成为可判定的，这与 Rice 定理的推论相矛盾。因此，我们的初始假设必定是错误的：**$A$ 是不可判定的**。\n\n接下来，我们推断补集 $\\overline{A} = \\{x \\in \\mathbb{N} : \\varphi_x(x) \\uparrow\\}$ 是否是半可判定的。我们使用一个被称为 Post 定理的核心结果，该定理指出，一个集合 $S$ 是可判定的（递归的），当且仅当 $S$ 和其补集 $\\overline{S}$ 都是半可判定的（递归可枚举的）。\n\n根据我们的分析：\n- 在第(2)部分，我们确定了 $A$ 是半可判定的。\n- 我们刚刚证明了 $A$ 是不可判定的。\n\n如果我们假设 $\\overline{A}$ 也是半可判定的，那么根据 Post 定理，由于 $A$ 和 $\\overline{A}$ 都将是半可判定的，所以 $A$ 必须是可判定的。这与我们发现 $A$ 是不可判定的结论直接矛盾。因此，关于 $\\overline{A}$ 是半可判定的假设必定是错误的。我们得出结论：**$\\overline{A}$ 不是半可判定的**。\n\n**4) $S$ 的计算**\n\n问题根据相应集合是否半可判定来定义指示值 $\\chi_{A}$ 和 $\\chi_{\\overline{A}}$。\n- 如果 $A$ 是半可判定的，则 $\\chi_{A} = 1$，否则 $\\chi_{A} = 0$。\n- 如果 $\\overline{A}$ 是半可判定的，则 $\\chi_{\\overline{A}} = 1$，否则 $\\chi_{\\overline{A}} = 0$。\n\n我们被要求计算 $S = \\chi_{A} + \\chi_{\\overline{A}}$。\n- 从第(2)部分，我们得出结论 $A$ 是半可判定的。因此，$\\chi_{A} = 1$。\n- 从第(3)部分，我们得出结论 $\\overline{A}$ 不是半可判定的。因此，$\\chi_{\\overline{A}} = 0$。\n\n将这些值代入 $S$ 的表达式：\n$$S = \\chi_{A} + \\chi_{\\overline{A}} = 1 + 0 = 1$$\n最终值为 $1$。", "answer": "$$\\boxed{1}$$", "id": "3048503"}]}