{"hands_on_practices": [{"introduction": "克林递归定理的核心思想是，对于任何可计算的程序转换，总存在一个“不动点”程序，其行为在转换前后保持不变。这个练习将帮助我们直接应用这一强大的存在性结论。我们将利用递归定理 [@problem_id:3045831] 来证明一个非常基础的函数——常数零函数——确实拥有一个对应的程序索引，而无需我们手动构造这个程序。", "problem": "设 $\\{\\varphi_{e}\\}_{e \\in \\mathbb{N}}$ 是所有部分可计算函数 $\\mathbb{N} \\to \\mathbb{N}$ 的一个固定有效枚举，该枚举通过一个通用部分可计算函数 $U$ 给出，使得对于所有 $e,x \\in \\mathbb{N}$ 都有 $\\varphi_{e}(x) = U(e,x)$。假设存在一个全可计算函数 $f \\colon \\mathbb{N} \\to \\mathbb{N}$，其性质为：对于每个索引 $e \\in \\mathbb{N}$ 和所有输入 $x \\in \\mathbb{N}$，索引为 $f(e)$ 的函数计算的是常数零函数，即 $\\varphi_{f(e)}(x) = 0$。仅使用可计算性的核心定义（包括通用部分可计算函数的存在性和参数化引理，也称为 $\\text{s-m-n}$ 定理）以及克林递归定理的机制，严格证明存在一个索引 $e \\in \\mathbb{N}$，使得 $\\varphi_{e}$ 是常数零函数。然后，确定 $\\varphi_{e}\\!\\left(2^{10} + 3\\right)$ 的确切值。将你的最终答案表示为单个数字。无需四舍五入。", "solution": "该问题陈述是可计算性理论中的一个有效练习。它要求使用克林递归定理来证明常数零函数索引的存在性，然后计算该函数的一个值。我们可以进行形式化的解答。\n\n所需的核心工具是克林第二递归定理，其陈述如下：对于任何全可计算函数 $g \\colon \\mathbb{N} \\to \\mathbb{N}$，存在一个索引 $n \\in \\mathbb{N}$，使得对于所有 $x \\in \\mathbb{N}$，由 $n$ 和 $g(n)$ 索引的部分可计算函数是相同的。用符号表示为 $\\varphi_n = \\varphi_{g(n)}$。这个索引 $n$ 通常被称为函数 $g$ 的一个不动点。\n\n问题提供了一个全可计算函数 $f \\colon \\mathbb{N} \\to \\mathbb{N}$。因此，我们可以将克林递归定理直接应用于这个函数 $f$。根据该定理，必然存在一个索引，我们称之为 $e \\in \\mathbb{N}$，使得 $\\varphi_e = \\varphi_{f(e)}$。\n\n接下来，我们使用问题陈述中给出的函数 $f$ 的性质。陈述中说明，对于每个索引 $k \\in \\mathbb{N}$ 和所有输入 $x \\in \\mathbb{N}$，索引为 $f(k)$ 的函数是常数零函数。这意味着对于所有 $k, x \\in \\mathbb{N}$，有 $\\varphi_{f(k)}(x) = 0$。\n\n现在，我们可以结合这两个事实。我们有一个特定的索引 $e$，它是 $f$ 的一个不动点。函数 $f$ 的性质对任何索引 $k$ 都成立，因此它也必须对我们的特定索引 $e$ 成立。将 $k=e$ 代入 $f$ 的性质中，我们发现函数 $\\varphi_{f(e)}$ 是常数零函数。也就是说，对于所有 $x \\in \\mathbb{N}$，有 $\\varphi_{f(e)}(x) = 0$。\n\n因为我们从递归定理知道 $\\varphi_e = \\varphi_{f(e)}$，所以可以立即推断出 $\\varphi_e$ 也必须是常数零函数。因此，对于我们的不动点索引 $e$，对于所有 $x \\in \\mathbb{N}$，$\\varphi_e(x) = 0$ 成立。这严格证明了常数零函数的索引 $e$ 的存在性，符合问题的要求。\n\n问题的第二部分要求计算 $\\varphi_e(2^{10} + 3)$ 的值。我们刚刚确定了 $\\varphi_e$ 是常数零函数，这意味着对于其定义域 $\\mathbb{N}$ 中的任何输入，其输出都是 $0$。输入是 $2^{10} + 3 = 1024 + 3 = 1027$，这是一个自然数。\n\n因此，我们可以计算该函数的值：\n$$\n\\varphi_e(2^{10} + 3) = \\varphi_e(1027) = 0\n$$\n其值恰好是 $0$。", "answer": "$$\\boxed{0}$$", "id": "3045831"}, {"introduction": "理论的强大不仅在于它告诉我们“什么”存在，更在于它能指导我们“如何”构造。这个练习将带我们从存在性证明走向构造性证明，去完成计算理论中最迷人的任务之一：构建一个“奎因”（Quine）[@problem_id:2970608]。通过遵循克林递归定理的构造性证明过程，我们将创建一个能够输出自身索引的程序，从而亲手触摸到“自引用”这一深刻概念。", "problem": "固定一个可接受的部分可计算函数哥德尔编号，使得对每个 $e \\in \\mathbb{N}$，指标 $e$ 命名一个一元部分可计算函数 $y \\mapsto \\varphi_{e}(y)$，并且对每个 $e \\in \\mathbb{N}$，指标 $e$ 也命名一个二元部分可计算函数 $(x,y) \\mapsto \\varphi_{e}^{(2)}(x,y)$（通过任何标准的对输入的一致配对得到）。假设以下基本事实。\n\n1. 存在一个全原始递归配对函数 $\\langle \\cdot,\\cdot \\rangle : \\mathbb{N}^{2} \\to \\mathbb{N}$，它是一个双射，并有原始递归的投影函数。\n2. 对于二元枚举，存在一个通用指标 $U$，使得对所有 $e,a,y \\in \\mathbb{N}$，有 $\\varphi_{U}^{(2)}(\\langle e,a \\rangle, y) = \\varphi_{e}^{(2)}(a,y)$。\n3. (克林 $s$-$m$-$n$ 定理) 存在一个全原始递归函数 $s : \\mathbb{N}^{2} \\to \\mathbb{N}$，使得对所有 $e,a,y \\in \\mathbb{N}$，有 $\\varphi_{s(e,a)}(y) = \\varphi_{e}^{(2)}(a,y)$。\n4. 固定一个二元“打印”程序的指标 $p$，其定义为对所有 $x,y \\in \\mathbb{N}$，$\\varphi_{p}^{(2)}(x,y) = x$。\n\n将二元部分可计算函数 $D : \\mathbb{N}^{2} \\rightrightarrows \\mathbb{N}$ 定义为\n$$\nD(x,y) \\;=\\; \\varphi_{s(p,\\,s(x,x))}(y),\n$$\n并固定任何满足对所有 $x,y \\in \\mathbb{N}$ 都有 $\\varphi_{d}^{(2)}(x,y) = D(x,y)$ 的指标 $d$。\n\n仅使用上述基本事实（特别是克林递归定理和 $s$-$m$-$n$ 定理），构建一个一元自指程序（一个“奎因程序”），它在任何输入 $y$ 上都输出其自身的指标。你的构建过程必须从第一性原理出发，通过给定的原语 $s$、$p$ 和所选指标 $d$ 显式地将该指标构建为一个可计算表达式。在你的推导过程中，解释 $s$-$m$-$n$ 定理在实现自引用方面所起的概念性作用。\n\n对于这样一个奎因程序的指标 $e^{\\star}$，用上面介绍的符号 $s$ 和 $d$ 表示的单个封闭形式表达式是什么？请以单个符号表达式的形式提供最终答案。不需要进行数值近似或舍入。", "solution": "问题陈述是有效的。这是一个在可计算性理论（数理逻辑的一个子领域）的既定框架内的适定问题。它具有科学依据、客观，并包含得出唯一解所需的所有必要信息。任务是从一组给定的原始可计算函数和指标中构建一个自指程序（奎因程序）的指标。\n\n目标是找到一个指标 $e^{\\star} \\in \\mathbb{N}$，使得对所有输入 $y \\in \\mathbb{N}$，部分可计算函数 $\\varphi_{e^{\\star}}$ 停机并输出其自身的指标：$\\varphi_{e^{\\star}}(y) = e^{\\star}$。\n\n该构建从根本上依赖于克林 $s$-$m$-$n$ 定理。该定理提供了一个全原始递归函数 $s: \\mathbb{N}^2 \\to \\mathbb{N}$，使得对于任何二元部分可计算函数 $\\varphi_e^{(2)}(x,y)$ 的指标 $e$ 和第一个输入的任何值 $a \\in \\mathbb{N}$，我们可以计算出所得一元函数的新指标 $s(e,a)$。即 $\\varphi_{s(e,a)}(y) = \\varphi_e^{(2)}(a,y)$。从概念上讲，$s$-$m$-$n$ 定理将特化或部分求值的过程形式化：它提供了一种可计算的方法，通过固定其中一个输入，将通用程序（指标 $e$）转换为特化程序（指标 $s(e,a)$）。正如克林递归定理的构造性证明所示，程序能够机械地生成其他程序的指标，正是这种能力，构成了实现奎因程序所需自引用的关键机制。\n\n构建过程首先分析问题陈述中提供的函数 $D(x,y)$。该函数定义为 $D(x,y) = \\varphi_{s(p, s(x,x))}(y)$。我们已知 $d$ 是这个函数的指标，意味着对所有 $x,y \\in \\mathbb{N}$，有 $\\varphi_d^{(2)}(x,y) = D(x,y)$。\n\n让我们简化 $D(x,y)$ 的表达式。\n根据 $s$-$m$-$n$ 定理的定义，我们可以陈述对任意 $e, a, y \\in \\mathbb{N}$：\n$$\n\\varphi_{s(e,a)}(y) = \\varphi_{e}^{(2)}(a,y)\n$$\n在 $D(x,y)$ 的表达式中，我们可以识别出 $e=p$ 和 $a=s(x,x)$。应用该定理得到：\n$$\n\\varphi_{s(p, s(x,x))}(y) = \\varphi_{p}^{(2)}(s(x,x), y)\n$$\n问题将指标 $p$ 定义为对应于二元“打印”程序，使得对所有 $z, y \\in \\mathbb{N}$，有 $\\varphi_{p}^{(2)}(z,y) = z$。代入 $z = s(x,x)$，我们得到：\n$$\n\\varphi_{p}^{(2)}(s(x,x), y) = s(x,x)\n$$\n综合这些结果，我们得到 $D(x,y)$ 的简化形式：\n$$\nD(x,y) = \\varphi_{s(p, s(x,x))}(y) = s(x,x)\n$$\n由于 $d$ 是 $D(x,y)$ 的指标，我们已经确立了指标为 $d$ 的程序的一个关键属性：\n$$\n\\varphi_{d}^{(2)}(x,y) = s(x,x)\n$$\n这意味着指标为 $d$ 的二元程序接受两个输入 $x$ 和 $y$，忽略第二个输入 $y$，并返回值 $s(x,x)$。\n\n我们现在采用一种模仿克林递归定理证明的构造方法来寻找所需的不动点。该定理的构造性证明表明，对于像 $\\varphi_d^{(2)}$ 这样的函数，不动点通常可以通过将 $s$ 函数应用于该函数自身的指标来找到。让我们提出我们的奎因程序的候选指标 $e^{\\star}$ 为：\n$$\ne^{\\star} = s(d,d)\n$$\n为了验证该指标对应一个奎因程序，我们必须对任意输入 $y \\in \\mathbb{N}$ 求值函数 $\\varphi_{e^{\\star}}(y)$。\n\n根据 $e^{\\star}$ 的定义，我们有：\n$$\n\\varphi_{e^{\\star}}(y) = \\varphi_{s(d,d)}(y)\n$$\n我们将 $s$-$m$-$n$ 定理应用于右侧，其中 $e=d$ 且 $a=d$：\n$$\n\\varphi_{s(d,d)}(y) = \\varphi_{d}^{(2)}(d,y)\n$$\n现在，我们使用先前推导出的函数 $\\varphi_d^{(2)}$ 的性质，即对所有 $x,y$ 都有 $\\varphi_d^{(2)}(x,y) = s(x,x)$。我们代入 $x=d$：\n$$\n\\varphi_{d}^{(2)}(d,y) = s(d,d)\n$$\n将这些等式串联起来，我们得到：\n$$\n\\varphi_{e^{\\star}}(y) = \\varphi_{s(d,d)}(y) = \\varphi_{d}^{(2)}(d,y) = s(d,d)\n$$\n由于我们定义了 $e^{\\star} = s(d,d)$，我们已经证明了对任何输入 $y$，\n$$\n\\varphi_{e^{\\star}}(y) = e^{\\star}\n$$\n这证实了指标 $e^{\\star} = s(d,d)$ 确实是一个奎因程序的指标。该表达式完全由给定的原语 $s$ 和 $d$ 构建，符合要求。", "answer": "$$\n\\boxed{s(d,d)}\n$$", "id": "2970608"}, {"introduction": "程序的世界充满了微妙的区别，其中最根本的是其“语法”（代码本身）与“语义”（代码执行的行为）之间的差异。这个综合性练习将引导我们运用克林递归定理和 $s$-$m$-$n$ 定理，巧妙地构造出两个代码不同但功能完全相同的程序 [@problem_id:2982151]。通过分析它们在不同性质（可判定的语法性质与不可判定的语义性质）下的表现，我们将深刻理解莱斯定理的内涵以及程序分析的根本局限。", "problem": "设 $\\{\\phi_{e}\\}_{e \\in \\mathbb{N}}$ 是所有从 $\\mathbb{N}$ 到 $\\mathbb{N}$ 的部分可计算函数通过图灵机（TM）编码的一个标准有效枚举。如果对于所有 $e, e' \\in \\mathbb{N}$，当 $\\phi_{e} = \\phi_{e'}$ 作为部分函数成立时，都有 $E(e) = E(e')$，则称标号的一个性质 $E$ 是外延的。如果一个标号的性质 $S$ 可以依赖于标号的具体编码，而不必由其所计算的部分函数决定，则称该性质是句法的。\n\n从上述基本定义以及计算理论中以下公认的事实出发：\n\n- $s$-$m$-$n$（参数化）定理：存在一个全可计算函数 $s$，使得对于每个可计算函数 $\\psi(n,p,x)$，都存在 $s(n,p)$ 满足对所有 $x$ 有 $\\phi_{s(n,p)}(x) = \\psi(n,p,x)$。\n- 克林递归定理：对于任意关于标号的全可计算变换器 $F$，都存在一个 $p$ 使得 $\\phi_{p} = \\phi_{F(p)}$。\n- Rice 定理：部分可计算函数的任何非平凡外延性质都是不可判定的。\n\n请完成以下任务：\n\n1. 使用克林递归定理来证明存在一个标号 $p$，使得对于所有 $x \\in \\mathbb{N}$，都有 $\\phi_{p}(x) = 0$。\n2. 使用 $s$-$m$-$n$ 定理，定义一个全可计算且单射的“包装”函数 $b \\colon \\mathbb{N} \\times \\mathbb{N} \\to \\mathbb{N}$，使得对于所有 $n, p, x \\in \\mathbb{N}$，标号 $b(n,p)$ 编码的程序会先执行整整 $n$ 个句法上的“空操作”步骤，然后模拟 $\\phi_{p}(x)$，因此有 $\\phi_{b(n,p)}(x) = \\phi_{p}(x)$。你可以假设底层的编码模型允许将 $n$ 字面地嵌入到程序中，从而使 $b(n,p)$ 对于数对 $(n,p)$ 是单射的。\n3. 构造两个不同的标号 $e_{1} = b(3,p)$ 和 $e_{2} = b(7,p)$，并从第一性原理出发论证 $\\phi_{e_{1}} = \\phi_{e_{2}}$ 且 $e_{1} \\neq e_{2}$。\n4. 定义外延性质 $E(e)$ 为\n   $$E(e) = \\begin{cases}\n   1  \\text{若 } \\forall x \\in \\mathbb{N},\\, \\phi_{e}(x) = 0,\\\\\n   0  \\text{否则。}\n   \\end{cases}$$\n   解释为什么 Rice 定理意味着 $E$ 是不可判定的，并直接验证 $E(e_{1}) = E(e_{2})$。\n5. 定义句法性质 $S(e)$ 为由包装函数 $b$ 生成的代码中前导空操作步骤的数量。形式上，设\n   $$S(e) = \\begin{cases}\n   n  \\text{若对于第 1 部分中固定的 } p \\text{ 存在 } e = b(n,p),\\\\\n   0  \\text{否则。}\n   \\end{cases}$$\n   证明 $S$ 是可判定的，并且 $S(e_{1}) \\neq S(e_{2})$。\n\n最后，计算实值量\n$$F \\;=\\; E(e_{1}) \\;+\\; E(e_{2}) \\;+\\; \\big|S(e_{1}) - S(e_{2})\\big|.$$\n无需四舍五入。请将最终答案表示为一个不带单位的数字。", "solution": "该问题被评估为有效。它在可计算性理论中有科学依据，问题提出得当且客观。这是一个标准的练习题，阐释了克林递归定理、$s$-$m$-$n$ 定理和 Rice 定理的应用，以及程序的外延性质和句法性质之间的关键区别。我们接下来进行完整解答。\n\n该问题要求逐步进行构造和分析，并以最终计算作结。我们将按顺序处理每个部分。\n\n1.  **常数零函数的标号 $p$ 的存在性**\n\n我们被要求使用克林递归定理来证明存在一个标号 $p$，使得对于所有 $x \\in \\mathbb{N}$，都有 $\\phi_{p}(x) = 0$。\n\n考虑函数 $\\psi(e, x) = 0$。这个函数显然是全可计算的，因为它忽略其输入并输出一个常数。根据 s-m-n 定理（以一种简化形式，其中第二个参数不存在），存在一个全可计算函数，我们将其表示为 $F: \\mathbb{N} \\to \\mathbb{N}$，使得对于任何标号 $e \\in \\mathbb{N}$，都有 $\\phi_{F(e)}(x) = \\psi(e, x)$。代入 $\\psi$ 的定义，我们得到对于所有 $x \\in \\mathbb{N}$，都有 $\\phi_{F(e)}(x) = 0$。\n\n函数 $F$ 是一个关于标号的全可计算变换器。根据克林递归定理，这个变换器必定存在一个不动点，即一个标号 $p \\in \\mathbb{N}$，使得 $\\phi_{p} = \\phi_{F(p)}$。\n\n根据 $F$ 的定义，我们知道 $\\phi_{F(p)}$ 是这样一个部分函数：它计算 $\\phi_{F(p)}(x) = 0$ 对所有 $x \\in \\mathbb{N}$ 成立。既然 $\\phi_{p} = \\phi_{F(p)}$，直接可得对于所有 $x \\in \\mathbb{N}$，都有 $\\phi_{p}(x) = 0$。这便确立了所要求的标号 $p$ 的存在性。在问题的其余部分，我们固定使用这个特定的标号 $p$。\n\n2.  **包装函数 $b(n, p)$ 的定义**\n\n我们需要使用 s-m-n 定理来定义一个全可计算且单射的函数 $b(n, p)$。这个函数应该生成一个程序的标号，该程序的行为与标号为 $p$ 的程序完全相同，但在执行 $n$ 个句法上的“空操作”（no operation）步骤之后。\n\n让我们定义一个三元函数 $\\Psi(n, p, x)$。$\\Psi$ 的预期行为是模拟 $\\phi_{p}(x)$ 的计算，但 $\\Psi$ 的底层图灵机编码在句法上将依赖于 $n$。然而，其*函数*输出与 $n$ 无关。我们将该函数定义为 $\\Psi(n, p, x) = \\phi_{p}(x)$。根据 Church-Turing 论题和通用图灵机的存在性，函数 $\\Psi(n, p, x)$ 是其三个参数的部分可计算函数。\n\n根据 s-m-n 定理，存在一个全可计算函数，我们称之为 $b$，使得对于所有 $n, p, x \\in \\mathbb{N}$，我们有 $\\phi_{b(n,p)}(x) = \\Psi(n,p,x)$。代入我们对 $\\Psi$ 的定义，得到 $\\phi_{b(n,p)}(x) = \\phi_{p}(x)$。\n\n问题陈述中提到，我们可以假设底层模型允许将 $n$ 字面地作为一系列空操作指令嵌入到程序 $b(n,p)$ 的编码中。这确保了如果 $(n_1, p_1) \\neq (n_2, p_2)$，那么得到的编码 $b(n_1, p_1)$ 和 $b(n_2, p_2)$ 是不同的。因此，函数 $b: \\mathbb{N} \\times \\mathbb{N} \\to \\mathbb{N}$ 是单射的。\n\n3.  **$e_1$ 和 $e_2$ 的构造与分析**\n\n令 $p$ 为第 1 部分中找到的常数零函数的标号。我们使用第 2 部分的包装函数 $b$ 定义两个新标号 $e_1$ 和 $e_2$：\n$$e_1 = b(3, p)$$\n$$e_2 = b(7, p)$$\n\n首先，我们论证 $\\phi_{e_1} = \\phi_{e_2}$。根据 $b$ 的定义，我们有 $\\phi_{b(n,p)}(x) = \\phi_{p}(x)$ 对所有 $n, p, x$ 成立。\n对于 $e_1$，我们有 $\\phi_{e_1}(x) = \\phi_{b(3,p)}(x) = \\phi_{p}(x)$ 对所有 $x$ 成立。\n对于 $e_2$，我们有 $\\phi_{e_2}(x) = \\phi_{b(7,p)}(x) = \\phi_{p}(x)$ 对所有 $x$ 成立。\n由于 $\\phi_{e_1}$ 和 $\\phi_{e_2}$ 都等于同一个函数 $\\phi_p$，它们必然彼此相等：$\\phi_{e_1} = \\phi_{e_2}$。\n\n接下来，我们论证 $e_1 \\neq e_2$。函数 $b$ 是单射的。对于 $e_1$ 和 $e_2$，$b$ 的输入分别是数对 $(3, p)$ 和 $(7, p)$。由于 $3 \\neq 7$，这两个数对是不同的：$(3, p) \\neq (7, p)$。因为 $b$ 是单射的，它将不同的输入映射到不同的输出。因此，$b(3,p) \\neq b(7,p)$，这意味着 $e_1 \\neq e_2$。\n\n4.  **外延性质 $E(e)$**\n\n性质 $E$ 定义为：\n$$E(e) = \\begin{cases} 1  \\text{若 } \\forall x \\in \\mathbb{N},\\, \\phi_{e}(x) = 0, \\\\ 0  \\text{否则。} \\end{cases}$$\nRice 定理指出，任何非平凡的部分可计算函数的外延性质都是不可判定的。要应用该定理，我们必须验证 $E$ 既是外延的，也是非平凡的。\n\n- **外延性**：假设 $\\phi_e = \\phi_{e'}$。如果 $\\forall x, \\phi_e(x)=0$，那么也必然有 $\\forall x, \\phi_{e'}(x)=0$。在这种情况下，$E(e) = 1$ 且 $E(e')=1$。如果不是 $\\forall x, \\phi_e(x)=0$ 的情况，那么对 $\\phi_{e'}$ 也同样不是。在这种情况下，$E(e)=0$ 且 $E(e')=0$。在所有情况下，如果 $\\phi_e = \\phi_{e'}$，那么 $E(e) = E(e')$。因此，$E$ 是一个外延性质。\n\n- **非平凡性**：一个性质是非平凡的，如果它对至少一个函数为真，且对至少另一个函数为假。在第 1 部分，我们确立了存在一个标号 $p$，使得 $\\phi_p$ 是常数零函数。所以，$E(p) = 1$。现在考虑一个处处无定义的函数。该函数的一个标号可以是一个立即进入无限循环的程序，我们称这个标号为 $u$。由于 $\\phi_u$ 不是常数零函数，所以 $E(u) = 0$。因为该性质对某些标号成立而对另一些不成立，所以它是非平凡的。\n\n由于 $E$ 是一个非平凡的外延性质，Rice 定理意味着 $E$ 是不可判定的。\n\n最后，我们验证 $E(e_1) = E(e_2)$。从第 3 部分我们知道 $\\phi_{e_1} = \\phi_{e_2} = \\phi_p$。由于 $\\phi_p$ 是常数零函数，$\\phi_{e_1}$ 和 $\\phi_{e_2}$ 也都是常数零函数。根据 $E$ 的定义，这意味着 $E(e_1) = 1$ 且 $E(e_2) = 1$。因此，$E(e_1) = E(e_2)$。\n\n5.  **句法性质 $S(e)$**\n\n对于第 1 部分中固定的标号 $p$，性质 $S$ 定义为：\n$$S(e) = \\begin{cases} n  \\text{若对于某个 } n \\in \\mathbb{N} \\text{ 有 } e = b(n,p), \\\\ 0  \\text{否则。} \\end{cases}$$\n我们必须证明 $S$ 是可判定的。要计算给定输入 $e$ 的 $S(e)$，我们需要一个总是停机的算法。$S$ 的定义基于标号 $e$ 是否具有特定的句法结构，即由包装函数 $b(n,p)$ 产生的结构。\n\n函数 $b$ 是全可计算的。标号 $p$ 是一个固定的常数。一个判定 $S(e)$ 的算法可以设计如下：\n给定一个输入标号 $e$，我们可以分析其代码结构。我们可以检查机器 $e$ 的代码是否以一个空操作指令块开始，以及代码的其余部分是否实现了对具有已知标号 $p$ 的机器的模拟。这种结构分析或“反编译”是一个有限的过程，它操作的是程序代码的句法，而不是其行为。\n形式上，算法如下：\n1.  解析具有编码 $e$ 的图灵机的描述。\n2.  检查它是否匹配模板“一个空操作指令序列，后跟一个通用图灵机模拟机器 $p$ 的代码”。\n3.  如果不匹配此模板，则停机并输出 $0$。\n4.  如果匹配，则计算前导空操作指令的数量，记为 $n$。停机并输出 $n$。\n\n这个过程总是终止的，因为它是一个对给定代码 $e$ 的结构的有限检查。因此，函数 $S(e)$ 是可计算的，意味着性质 $S$ 是可判定的。\n\n接下来，我们证明 $S(e_1) \\neq S(e_2)$。\n对于 $e_1 = b(3, p)$，输入 $e_1$ 匹配条件 $e = b(n,p)$，其中 $n=3$。根据 $S$ 的定义，我们有 $S(e_1) = 3$。\n对于 $e_2 = b(7, p)$，输入 $e_2$ 匹配条件 $e = b(n,p)$，其中 $n=7$。根据 $S$ 的定义，我们有 $S(e_2) = 7$。\n由于 $3 \\neq 7$，我们有 $S(e_1) \\neq S(e_2)$。这突显了 $S$ 是一个句法性质，因为它可以区分两个不同的程序（$e_1 \\neq e_2$），即使它们计算完全相同的函数（$\\phi_{e_1} = \\phi_{e_2}$）。\n\n**最终计算**\n\n我们被要求计算 $F$ 的值：\n$$F = E(e_{1}) + E(e_{2}) + \\big|S(e_{1}) - S(e_{2})\\big|$$\n使用我们在前面部分推导出的值：\n- 从第 4 部分， $E(e_1) = 1$。\n- 从第 4 部分， $E(e_2) = 1$。\n- 从第 5 部分， $S(e_1) = 3$。\n- 从第 5 部分， $S(e_2) = 7$。\n\n将这些值代入 $F$ 的表达式中：\n$$F = 1 + 1 + |3 - 7|$$\n$$F = 2 + |-4|$$\n$$F = 2 + 4$$\n$$F = 6$$\n最终值为 $6$。", "answer": "$$\\boxed{6}$$", "id": "2982151"}]}