{"hands_on_practices": [{"introduction": "通用图灵机 (UTM) 可以计算任何可计算函数，但莱斯定理揭示了一个深刻的限制：我们无法通过算法判定程序的任何有趣的*语义*属性。本练习旨在探讨不可判定的语义属性 (程序*做什么*) 与可判定的句法属性 (程序*是什么*) 之间的关键区别。理解这一区别对于实际的程序分析至关重要，并阐明了为什么某些关于程序的看似简单的问题，例如判断程序 $\\varphi^{U}_{p}$ 是否具备某种行为，实际上是无法解决的。[@problem_id:2988385]", "problem": "给定一台固定的通用图灵机 (UTM) $U$，其程序采用标准的二进制编码，表示为有限二进制字符串。对于任意二进制字符串 $p$，令 $\\varphi^{U}_{p}$ 表示将 $p$作为程序在 $U$ 上运行时所计算的偏可计算函数。如果一个程序的性质仅取决于其所计算的偏函数，则称该性质是外延的。也就是说，如果对于所有编码 $p, q$，当 $\\varphi^{U}_{p} = \\varphi^{U}_{q}$ 且 $p \\in S$ 时，总有 $q \\in S$，那么编码集合 $S \\subseteq \\{0,1\\}^{\\ast}$ 是（相对于 $U$ 的）外延的。如果一个性质不是外延的，则称其为内涵的。也就是说，它可以区分计算相同偏函数的不同编码。Rice 定理指出，对于任意非平凡的偏可计算函数类 $\\mathcal{C}$（非空且不包含所有此类函数），其指标集 $\\{\\,p : \\varphi^{U}_{p} \\in \\mathcal{C}\\,\\}$ 对于任何固定的 $U$ 都是不可判定的。\n\n考虑以下几种通过关注 $U$ 程序之内涵性质来“规避” Rice 定理的候选方法。选择所有正确识别了一个可判定的内涵性质，并正确说明了 Rice 定理为何不适用的陈述。\n\nA. 固定 $U$ 和 $k \\in \\mathbb{N}$。定义 $P_{k} = \\{\\,p : p \\text{ 是一个语法有效的 } U\\text{-程序且 } |p| \\leq k\\,\\}$。那么 $P_{k}$ 是可判定的，因为可以通过计算 $|p|$ 并检查语法的良构性来判断。Rice 定理不适用，因为 $P_{k}$ 不是关于偏函数 $\\varphi^{U}_{p}$ 的性质：存在 $p,q$ 使得 $\\varphi^{U}_{p} = \\varphi^{U}_{q}$ 但 $|p| \\neq |q|$，所以 $P_{k}$ 不是外延的。\n\nB. 固定 $U$ 和 $k \\in \\mathbb{N}$。定义 $Q_{k} = \\{\\,p : \\exists q \\text{ 使得 } |q| \\leq k \\text{ 且 } \\varphi^{U}_{q} = \\varphi^{U}_{p}\\,\\}$。那么 $Q_{k}$ 是可判定的，因为可以通过枚举所有满足 $|q| \\leq k$ 的 $q$，并在所有输入上模拟 $U(q)$ 和 $U(p)$ 来检查等价性。Rice 定理在此不适用，因为 $U$ 是固定的。\n\nC. 固定 $U$。因为编码是固定的，所以 $U$-程序的每个非平凡性质都是可判定的（不可判定性的唯一来源是编码的可变性），因此对于所有这些性质，都避免了 Rice 定理。\n\nD. 固定 $U$ 和一个有限二进制字符串 $s$。定义 $R_{s} = \\{\\,p : p \\text{ 的编码中包含 } s \\text{ 作为连续子串}\\,\\}$。那么 $R_{s}$ 是可判定的，因为可以通过扫描 $p$ 的编码来判断。Rice 定理不适用，因为 $R_{s}$ 是纯粹内涵的，并且在将 $p$ 替换为任何满足 $\\varphi^{U}_{q} = \\varphi^{U}_{p}$ 的 $q$ 时，该性质不是不变的。\n\nE. 固定 $U$。集合 $T = \\{\\,p : \\varphi^{U}_{p} \\text{ 是全函数}\\,\\}$ 是可判定的，因为可以通过在所有输入上进行交叉模拟（dovetailing）$U(p)$ 并检测到没有输入会发散。Rice 定理不适用，因为当 $U$ 固定时，全函数性是 $U$-程序的一个语法性质。\n\n给出你的选择，并准备从第一性原理出发，证明为什么正确的选项确实通过转向内涵性质来规避了 Rice 定理，以及为什么 Rice 定理不适用于这些选项。", "solution": "我们从第一性原理开始：一台通用图灵机 (UTM) $U$ 是一台固定的图灵机，给定一个程序编码 $p$ 和输入 $x$，它会模拟由 $p$ 编码的在 $x$ 上的计算。因此，每个编码 $p$ 确定一个偏可计算函数 $\\varphi^{U}_{p} \\colon \\{0,1\\}^{\\ast} \\rightharpoonup \\{0,1\\}^{\\ast}$。一个程序的性质如果是外延的，则它仅取决于 $\\varphi^{U}_{p}$；否则它是内涵的。Rice 定理指出：对于任意固定的 $U$，偏可计算函数的任何非平凡外延性质（等价地，在等价关系 $p \\sim q \\iff \\varphi^{U}_{p} = \\varphi^{U}_{q}$ 下不变的任何非平凡指标集）是不可判定的。因此，要“规避” Rice 定理，必须跳出其假设的范围，例如，通过考虑非外延的性质（即内涵的，取决于语法表示 $p$ 本身的性质）。这样的性质可以是可判定的，因为它们避免了触发 Rice 定理的语义内容。\n\n我们现在分析每个选项。\n\n选项 A：定义 $P_{k} = \\{\\,p : p \\text{ 是一个语法有效的 } U\\text{-程序且 } |p| \\leq k\\,\\}$。可判定性：给定 $p$，可以计算其长度 $|p|$ 并根据所选的语法编码规则检查二进制字符串 $p$ 是否是 $U$ 的一个良构编码（此检查是基于编码规则的有限、机械的扫描）。这两个检查都是可计算的，它们的合取也是可计算的，因此 $P_{k}$ 是可判定的。Rice 定理的不适用性：$P_{k}$ 明显不是外延的。存在编码 $p,q$ 使得 $\\varphi^{U}_{p} = \\varphi^{U}_{q}$ 但 $|p| \\neq |q|$；例如，$q$ 可能是 $p$ 的一个填充或重构版本，它以不同的长度计算相同的函数。因此 $P_{k}$ 在等价关系 $p \\sim q$ 下不是不变的，所以它不是关于所计算的偏函数的性质；因此 Rice 定理不适用。结论：正确。\n\n选项 B：定义 $Q_{k} = \\{\\,p : \\exists q \\text{ 使得 } |q| \\leq k \\text{ 且 } \\varphi^{U}_{q} = \\varphi^{U}_{p}\\,\\}$。首先，观察到 $Q_{k}$ 是外延的：$p \\in Q_{k}$ 是否成立仅取决于函数 $\\varphi^{U}_{p}$，因为它询问由 $p$ 计算的函数是否有一个长度至多为 $k$ 的描述（在 $U$ 下）。如果 $\\varphi^{U}_{p} = f$，那么 $p \\in Q_{k}$ 当且仅当 $f$ 的 $U$-Kolmogorov 复杂度（相对于 $U$ 的描述复杂度）至多为 $k$。这是偏可计算函数的一个非平凡性质：一些函数有短程序，而另一些则没有。因此，根据 Rice 定理，该指标集是不可判定的。所提出的判定方法是无效的：偏可计算函数 $\\varphi^{U}_{q} = \\varphi^{U}_{p}$ 的等价性是不可判定的；在“所有输入”上进行有限模拟无法证明等价性，因为发散和不一致可能发生在任意远的位置。因此，与所声称的相反，$Q_{k}$ 是不可判定的，并且 Rice 定理确实适用。结论：不正确。\n\n选项 C：该陈述声称，固定编码（和 $U$）会使 $U$-程序的每个非平凡性质都变得可判定。这是错误的。对于一个固定的 $U$，许多非平凡的外延性质仍然是不可判定的；例如，停机问题集 $K = \\{\\,p : \\exists x \\text{ 使得 } U(p,x) \\downarrow\\,\\}$ 和全函数性集 $T = \\{\\,p : \\forall x, U(p,x) \\downarrow\\,\\}$ 都是经典的不可判定集。固定 $U$ 本身就是 Rice 定理通常表述的一部分；该定理是对一个固定的枚举进行量化的。因此，该选项中给出的论点误解了 Rice 定理。结论：不正确。\n\n选项 D：定义 $R_{s} = \\{\\,p : p \\text{ 包含 } s \\text{ 作为连续子串}\\,\\}$。可判定性：给定 $p$ 和固定的 $s$，可以在线性时间内扫描 $p$ 来查找 $s$；因此 $R_{s}$ 是可计算的。Rice 定理的不适用性：$R_{s}$ 是纯粹语法的，因而是内涵的。它在关系 $p \\sim q \\iff \\varphi^{U}_{p} = \\varphi^{U}_{q}$ 下不是不变的，因为人们通常可以修改一个程序的编码，在保持其计算的函数不变的同时，改变特定子串 $s$ 是否存在。因此 $R_{s}$ 不是偏可计算函数的一个外延性质，所以 Rice 定理不适用。结论：正确。\n\n选项 E：集合 $T = \\{\\,p : \\varphi^{U}_{p} \\text{ 是全函数}\\,\\}$ 被断言为可通过交叉模拟（dovetailing）来判定。这是不正确的。全函数性问题是一个非平凡外延性质的典型例子；根据 Rice 定理，它是不可判定的。交叉模拟允许在特殊情况下半判定全函数性的补集，或者半判定其他性质，但没有算法可以对所有的 $p$ 判定其全函数性。此外，其理由“Rice 定理不适用，因为当 $U$ 固定时，全函数性是语法的”是错误的：全函数性是函数 $\\varphi^{U}_{p}$ 的一个外延的、语义的性质，而这正是 Rice 定理所处理的那种性质。结论：不正确。\n\n综上所述，正确地展示了内涵性质如何规避 Rice 定理，并正确说明了 Rice 定理为何不适用的选项是选项 A 和选项 D。", "answer": "$$\\boxed{AD}$$", "id": "2988385"}, {"introduction": "递归定理是可计算性理论的基石之一，它指出程序可以获取并操作自身的代码，实现“自引用”。这常常看起来像一个悖论，特别是考虑到停机问题（即集合 $K$ 的不可判定性）。本练习将帮助你厘清这一困惑，展示这种强大的自引用能力是如何通过对程序索引 $e$ 进行纯粹的句法操作实现的，而无需解决任何不可判定的问题，从而揭示通用计算的深刻内涵。[@problem_id:2988379]", "problem": "设 $\\{ \\varphi_{e} \\}_{e \\in \\mathbb{N}}$ 是一个由图灵机计算的部分可计算函数的标准可接受枚举，并设 $U$ 是一个通用部分可计算函数（通用图灵机），满足\n$$\nU(\\langle e,x \\rangle) \\simeq \\varphi_{e}(x),\n$$\n对于一个固定的有效配对函数 $\\langle \\cdot,\\cdot \\rangle$，其中 $\\simeq$ 表示两边在完全相同的输入上有定义，并且在有定义时值相等。设停机集为\n$$\nK \\;=\\; \\{ \\langle e,x \\rangle \\in \\mathbb{N} : \\varphi_{e}(x) \\downarrow \\},\n$$\n已知该集合是不可判定的。同时回顾克林递归定理：对于每个全可计算函数 $f:\\mathbb{N} \\to \\mathbb{N}$，存在一个 $e \\in \\mathbb{N}$ 使得\n$$\n\\varphi_{e} \\;=\\; \\varphi_{f(e)}.\n$$\n在递归定理的证明中，自引用仅通过有效一致参数化（$s$-$m$-$n$ 定理）和通用机 $U$ 的存在来实现，而无需借助任何关于 $K$ 的判定过程。\n\n下列哪个陈述正确解释了为什么递归定理与停机问题的不可判定性不矛盾，以及自引用是如何在不判定停机的情况下实现的？选择所有适用项。\n\nA. 递归定理使用通用函数 $U$ 和有效参数化来构建索引，这些索引包含其自身代码的副本作为数据；这种“引用”是通过对代码的全可计算转换实现的，并且不包含任何用于判定任意计算 $\\varphi_{e}(x)$ 是否停机的过程。因此，它没有给出判定 $K$ 的算法。\n\nB. 因为递归定理保证了对于任意全可计算函数 $f$，都存在一个索引 $e$ 使得 $\\varphi_{e}=\\varphi_{f(e)}$，所以可以通过检查 $\\varphi_{f(e)}(e)$ 是否停机来判定 $\\varphi_{e}(e)$ 是否停机；因此停机问题变得可判定，这表明递归定理是非构造性的，并且其陈述不可能是正确的。\n\nC. 获得自引用的唯一方法是在所有输入上运行 $U$，并等待它通过检测何时 $\\varphi_{e}=\\varphi_{f(e)}$ 来发现自己的索引 $e$；这个搜索过程需要隐式地判定停机，因此通过假设一个 $K$ 的预言机，递归定理与不可判定性得以调和。\n\nD. 递归定理提供的不动点 $e$ 可能计算一个在许多输入上发散的部分函数，并且该定理的证明从不需要测试任意 $x$ 的 $\\varphi_{e}(x)$ 是否停机；构造的任何一步都没有提供能够判定 $K$ 中成员身份的信息。\n\nE. 根据莱斯定理，部分可计算函数的任何非平凡语义属性都是不可判定的，包括索引集 $\\{e : \\varphi_{e}=\\varphi_{f(e)}\\}$（当它既非空也非全集时）。递归定理断言了对于每个全可计算函数 $f$，至少存在一个这样的不动点 $e$，但没有提供一个算法来识别对于给定的 $e$，是否有 $\\varphi_{e}=\\varphi_{f(e)}$。因此，它没有产生一个判定 $K$ 的过程，也不与不可判定性矛盾。", "solution": "用户希望对克林递归定理与停机问题不可判定性之间的关系进行批判性分析。\n\n首先，我将验证问题陈述。\n\n### 第一步：提取已知条件\n- 部分可计算函数的标准可接受枚举：$\\{ \\varphi_{e} \\}_{e \\in \\mathbb{N}}$。\n- 一个通用部分可计算函数 $U$，满足 $U(\\langle e,x \\rangle) \\simeq \\varphi_{e}(x)$。\n- 一个有效的配对函数 $\\langle \\cdot,\\cdot \\rangle$。\n- 符号 $\\simeq$ 表示部分函数相等（定义域相同且在该域上取值相同）。\n- 停机集：$K = \\{ \\langle e,x \\rangle \\in \\mathbb{N} : \\varphi_{e}(x) \\downarrow \\}$，其中 $\\downarrow$ 表示“停机”。\n- 一个已知事实：停机集 $K$ 是不可判定的。\n- 克林递归定理：对于每个全可计算函数 $f:\\mathbb{N} \\to \\mathbb{N}$，存在一个索引 $e \\in \\mathbb{N}$，使得 $\\varphi_{e} = \\varphi_{f(e)}$。\n- 关于递归定理证明的一个前提：它使用 S-m-n 定理（有效一致参数化）和一个通用机 $U$，但没有使用任何关于 $K$ 的判定过程。\n- 问题是找出哪些陈述正确地解释了为什么递归定理不与 $K$ 的不可判定性相矛盾，以及自引用是如何在不判定停机的情况下实现的。\n\n### 第二步：使用提取的已知条件进行验证\n- **科学上合理（批判性）：** 该问题植根于基础可计算性理论。所有定义（可接受枚举、通用函数、停机集）和定理（克林递归定理、$K$的不可判定性）都是标准的且陈述正确。\n- **问题定义良好：** 该问题要求对可计算性理论中一个众所周知的概念点进行解释。解决这种表面上的张力是一个标准的教学主题，并且在理论中存在明确的解释。\n- **客观（批判性）：** 问题以精确、正式的语言陈述，没有歧义或主观内容。\n\n问题陈述完全有效。这是数理逻辑和理论计算机科学中的一个标准问题。未检测到任何缺陷。\n\n### 第三步：结论与行动\n问题有效。我将进行全面的推导和分析。\n\n### 基于原理的推导\n\n问题的核心在于克林递归定理的构造性证明。设 $f:\\mathbb{N} \\to \\mathbb{N}$ 是任意一个全可计算函数。我们希望找到一个索引 $e$，使得 $\\varphi_{e} = \\varphi_{f(e)}$。\n\n标准证明如下：\n1.  定义一个部分函数 $\\psi(x, y)$ 为 $\\psi(x, y) \\simeq \\varphi_{f(\\varphi_x(x))}(y)$。这个函数是部分可计算的。一个计算 $\\psi$ 的机器会首先计算 $\\varphi_x(x)$。如果这个计算停机并输出 $z$，它接着计算 $f(z)$（由于 $f$ 是全函数，保证停机），如果结果是 $w$，它最终计算 $\\varphi_w(y)$。如果 $\\varphi_x(x)$ 发散，那么 $\\psi(x, y)$ 也发散。这个定义不需要一个判定器来判断 $\\varphi_x(x)$ 是否停机；它只是将 $\\varphi_x(x)$ 的潜在发散性构建到 $\\psi$ 的定义中。\n\n2.  根据 S-m-n 定理，存在一个全可计算函数 $s(x)$，对于任何索引 $x$，它能生成函数 $\\lambda y . \\psi(x,y)$ 的一个索引 $s(x)$。也就是说，对于所有 $x, y$，$\\varphi_{s(x)}(y) \\simeq \\psi(x, y)$。代入 $\\psi$ 的定义，我们得到 $\\varphi_{s(x)}(y) \\simeq \\varphi_{f(\\varphi_x(x))}(y)$。S-m-n 定理提供了一种纯粹的算法方式来操作程序索引——这是一种句法转换。\n\n3.  由于 $s$ 是一个全可计算函数，它至少有一个索引，记为 $c$。所以，对于所有 $x$，$s(x) = \\varphi_c(x)$。\n\n4.  现在，我们将函数 $s$ 应用于其自身的索引 $c$。令 $e = s(c)$。由于 $s$ 是一个全函数，计算 $\\varphi_c(c)$ 会停机，且 $e$ 是一个明确定义的整数。\n\n5.  这个索引 $e$ 就是所期望的不动点。我们可以验证这一点：\n    - 根据 $e$ 的定义，我们有 $\\varphi_e(y) = \\varphi_{s(c)}(y)$。\n    - 从第2步，令 $x=c$，我们有 $\\varphi_{s(c)}(y) \\simeq \\varphi_{f(\\varphi_c(c))}(y)$。\n    - 从第4步，我们有 $\\varphi_c(c) = s(c) = e$。\n    - 将此代入上一行，得到 $\\varphi_e(y) \\simeq \\varphi_{f(e)}(y)$。\n    - 这对所有 $y$ 都成立，所以 $\\varphi_e = \\varphi_{f(e)}$。\n\n这个证明构造性地提供了索引 $e$。“自引用”是通过步骤 $e = s(c) = \\varphi_c(c)$ 实现的，其中用于计算 $s$ 的程序被应用于其自身的描述 $c$ 以产生 $e$。然后，可以认为 $e$ 的程序包含了它自己的索引。\n\n关键的观察是，整个构造过程只涉及通过可计算函数（$f$、$s$ 以及 S-m-n 定理和通用机中隐含的函数）对索引（句法对象）进行操作。在任何时候，构造过程都不需要测试一个语义属性，例如“这个程序是否停机？”。这个构造之所以能行，恰恰因为它不试图分析它正在构建的程序的行为；它只是构建它们。这就是为什么它没有提供一个工具来判定停机问题 $K$ 的原因。\n\n### 逐项分析\n\n**A. 递归定理使用通用函数 $U$ 和有效参数化来构建索引，这些索引包含其自身代码的副本作为数据；这种“引用”是通过对代码的全可计算转换实现的，并且不包含任何用于判定任意计算 $\\varphi_{e}(x)$ 是否停机的过程。因此，它没有给出判定 $K$ 的算法。**\n这个陈述准确地描述了递归定理证明的机制。构造 $e = s(c)$ 是一个程序获取自身索引的方法，是一种“引用”形式。这是通过“有效参数化”（S-m-n 定理）并涉及“对代码的全可计算转换”（函数 $s$）来完成的。它正确地指出这些是句法操作，不涉及任何停机判定过程。因此，它没有提供判定 $K$ 的方法的结论是正确的。这个陈述提供了一个完整且准确的解释。\n**结论：正确。**\n\n**B. 因为递归定理保证了对于任意全可计算函数 $f$，都存在一个索引 $e$ 使得 $\\varphi_{e}=\\varphi_{f(e)}$，所以可以通过检查 $\\varphi_{f(e)}(e)$ 是否停机来判定 $\\varphi_{e}(e)$ 是否停机；因此停机问题变得可判定，这表明递归定理是非构造性的，并且其陈述不可能是正确的。**\n这个论证是错误的。知道 $\\varphi_e(e)$ 的停机等价于 $\\varphi_{f(e)}(e)$ 的停机，仅仅是将停机问题的一个实例归约到另一个实例。它并没有为任何一个问题提供解决方案。这是一个循环论证，而不是一个判定过程。停机问题变得可判定的结论是错误的，因此随后的关于递归定理不正确的断言也是错误的。\n**结论：不正确。**\n\n**C. 获得自引用的唯一方法是在所有输入上运行 $U$，并等待它通过检测何时 $\\varphi_{e}=\\varphi_{f(e)}$ 来发现自己的索引 $e$；这个搜索过程需要隐式地判定停机，因此通过假设一个 $K$ 的预言机，递归定理与不可判定性得以调和。**\n这描述的是一种暴力搜索不动点的方法，而不是递归定理的证明方式。如上所述，标准证明是一个直接的构造。此外，检查语义属性 $\\varphi_e = \\varphi_{f(e)}$ 的暴力搜索将需要一个至少与停机预言机一样强大的过程（实际上更强）。前提（“唯一方法是……”）是错误的，结论（“假设一个 $K$ 的预言机”）也是错误的。递归定理在标准可计算性理论中成立，无需任何此类假设。\n**结论：不正确。**\n\n**D. 递归定理提供的不动点 $e$ 可能计算一个在许多输入上发散的部分函数，并且该定理的证明从不需要测试任意 $x$ 的 $\\varphi_{e}(x)$ 是否停机；构造的任何一步都没有提供能够判定 $K$ 中成员身份的信息。**\n这个陈述正确地指出了两个关键事实。首先，该定理不保证得到的函数 $\\varphi_e$ 是全函数，所以它没有消除不停机的问题。其次，它正确地陈述了为什么不与 $K$ 的不可判定性产生矛盾的核心原因：证明是纯粹构造性的，并且“从不需要测试 $\\varphi_e(x)$ 是否停机”。它操作的是程序描述，而不需要知道关于它们行为的任何信息。这直接解释了为什么该定理的证明没有提供一个 $K$ 的判定器。\n**结论：正确。**\n\n**E. 根据莱斯定理，部分可计算函数的任何非平凡语义属性都是不可判定的，包括索引集 $\\{e : \\varphi_{e}=\\varphi_{f(e)}\\}$（当它既非空也非全集时）。递归定理断言了对于每个全可计算函数 $f$，至少存在一个这样的不动点 $e$，但没有提供一个算法来识别对于给定的 $e$，是否有 $\\varphi_{e}=\\varphi_{f(e)}$。因此，它没有产生一个判定 $K$ 的过程，也不与不可判定性矛盾。**\n这个陈述提出了一个正确且深刻的观点。不动点索引集 $S_f = \\{e \\mid \\varphi_e = \\varphi_{f(e)}\\}$ 是一个语义属性。对于大多数 $f$，这个集合非空（根据递归定理）且不是 $\\mathbb{N}$ 的全部，所以它是一个非平凡属性。根据莱斯定理，$S_f$ 是不可判定的。递归定理给出了一个构造性方法来找到这个不可判定集合的*一个*元素，但它没有提供一个方法来*判定*集合的*成员资格*。在生成一个实例和识别该属性之间的区别是根本性的。这解释了为什么该定理尽管强大，却存在于一个普遍存在不可判定性的框架内，并且不与之矛盾。这是对理论一致性的一个有效解释。\n**结论：正确。**", "answer": "$$\\boxed{ADE}$$", "id": "2988379"}, {"introduction": "通用图灵机 (UTM) 的核心能力在于它可以模拟任何其他图灵机，但这种模拟并非没有代价。本练习将通过一个具体的计算，将这一抽象概念付诸实践。通过分析一个特定的模拟方案，你将精确计算出在程序长度上的“开销”$c$，从而将通用机器的理论与算法信息论中的柯尔莫哥洛夫复杂性 $K_U(x)$ 联系起来，量化通用性所带来的成本。[@problem_id:3060172]", "problem": "考虑二进制串和一个固定的通用图灵机 (UTM) $U$，其定义域是无前缀的。对于任何无前缀 UTM $M$ 和任何有限二进制串 $x$，将相对于 $M$ 的柯尔莫哥洛夫复杂度定义为 $K_{M}(x) = \\min\\{\\,|p| : M(p) = x\\,\\}$，其中 $|p|$ 表示程序 $p$ 的比特长度。\n\n设 $V$ 是另一个具有以下输入约定的无前缀 UTM。对于形式为 $C(w)\\,p$ 的输入，机器 $V$ 首先解码自限定前缀 $C(w)$ 以恢复 $w$，然后将 $w$ 作为解释器在输入 $p$ 上执行以产生输出。自限定编码器 $C$ 定义为 $C(w) = 1^{|w|}0w$，它是无前缀的，长度为 $|C(w)| = 2|w| + 1$ 比特。\n\n假设存在一个长度为 $|s| = 19$ 比特的固定解释器（翻译器）$s$，使得对于每个二进制程序 $q$，计算 $V(C(s)\\,q)$ 产生与 $U(q)$ 完全相同的输出。仅使用上述定义和为 $V$ 陈述的输入约定，确定最小的常数 $c$（以比特为单位），使得对于每个有限二进制串 $x$，不等式 $K_{V}(x) \\leq K_{U}(x) + c$ 在此方案下成立。将 $c$ 表示为精确的比特数整数。不需要近似，您应该报告一个纯粹的比特数。", "solution": "问题陈述是算法信息论领域内一个定义明确的问题。所有术语，例如通用图灵机 (UTM)、无前缀定义域和柯尔莫哥洛夫复杂度，都是标准的。为特定机器 $U$ 和 $V$、编码器 $C$ 和解释器 $s$ 提供的定义是清晰、自洽且数学上一致的。其中没有科学或逻辑上的缺陷、歧义或缺失的信息。因此，该问题被认为是有效的，并且可以推导出形式化的解。\n\n目标是确定最小的常数 $c$，一个表示比特数的整数，使得对于每个有限二进制串 $x$，不等式 $K_{V}(x) \\leq K_{U}(x) + c$ 成立。\n\n根据相对于机器 $M$ 的柯尔莫哥洛夫复杂度的定义，即 $K_{M}(x) = \\min\\{\\,|p| : M(p) = x\\,\\}$，存在一个用于机器 $U$ 的最小长度程序 $p_U^*$，它生成字符串 $x$。该程序的属性是：\n$1.$ $U(p_U^*) = x$\n$2.$ $|p_U^*| = K_U(x)$\n\n该问题提供了一种将机器 $U$ 的计算与机器 $V$ 关联起来的机制。具体来说，它指出存在一个长度为 $|s| = 19$ 比特的固定解释器字符串 $s$，使得对于任何程序 $q$，计算 $V(C(s)\\,q)$ 产生与 $U(q)$ 相同的输出。\n\n我们可以利用这种关系为机器 $V$ 构造一个输出 $x$ 的程序。让我们选择程序 $q$ 为 $U$ 输出 $x$ 的最短程序，即 $p_U^*$。\n根据给定的规则，我们有：\n$$V(C(s)\\,p_U^*) = U(p_U^*)$$\n因为我们知道 $U(p_U^*) = x$，所以：\n$$V(C(s)\\,p_U^*) = x$$\n这表明连接后的字符串 $P_V = C(s)\\,p_U^*$ 是一个为机器 $V$ 产生输出 $x$ 的程序。\n\n柯尔莫哥洛夫复杂度 $K_V(x)$ 是为 $V$ 输出 $x$ 的*最短*程序的长度。因此，我们构造的程序 $P_V$ 的长度是 $K_V(x)$ 的一个上界。\n$$K_V(x) \\leq |P_V|$$\n程序 $P_V$ 的长度是其组成部分长度的总和，因为它是一个简单的连接：\n$$|P_V| = |C(s)\\,p_U^*| = |C(s)| + |p_U^*|$$\n我们知道 $|p_U^*| = K_U(x)$，所以我们可以写成：\n$$K_V(x) \\leq |C(s)| + K_U(x)$$\n这个不等式具有所需的形式 $K_V(x) \\leq K_U(x) + c$，其中常数 $c$ 等于 $|C(s)|$。\n\n现在，我们必须计算这个常数的值。问题将自限定编码器 $C$ 定义为 $C(w) = 1^{|w|}0w$，并指出其长度为 $|C(w)| = 2|w| + 1$。\n给定解释器字符串 $s$ 的长度为 $|s|=19$ 比特。我们可以计算其编码版本的长度 $|C(s)|$：\n$$|C(s)| = 2|s| + 1$$\n代入给定值 $|s|=19$：\n$$|C(s)| = 2(19) + 1 = 38 + 1 = 39$$\n因此常数 $c$ 为 $39$ 比特。\n\n推导出的不等式是 $K_V(x) \\leq K_U(x) + 39$。这个不等式对于每个有限二进制串 $x$ 都成立。问题要求的是使这个关系成立的*最小*常数 $c$。常数 $c=39$ 表示了指导机器 $V$ 使用提供的解释器 $s$ 和编码方案 $C$ 来模拟机器 $U$ 所需的固定开销（以比特为单位）。这种模拟方法是问题中指定的 $U$ 和 $V$ 之间的唯一联系。因为我们必须找到一个对*所有*字符串 $x$ 都成立的常数，我们必须考虑到这样一种可能性，即对于某些字符串，这种对最短 $U$ 程序的模拟，实际上是在 $V$ 上生成它们的最高效方式。因此，我们无法保证一个更小的常数会对每个可能的字符串 $x$ 满足该不等式。值 $c=|C(s)|$ 代表了基于给定信息可以建立的最紧可能上界。\n\n因此，最小常数 $c$ 是 $39$。", "answer": "$$\\boxed{39}$$", "id": "3060172"}]}