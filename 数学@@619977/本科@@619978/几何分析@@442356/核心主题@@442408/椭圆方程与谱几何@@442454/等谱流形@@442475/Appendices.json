{"hands_on_practices": [{"introduction": "在比较不同形状的“声音”之前，我们必须首先学会如何确定一个形状的声音。本练习将引导你完成计算一个典型例子——单位球面——上拉普拉斯-贝尔特拉米算子（Laplace-Beltrami operator）完整谱的基本过程。通过解析地解决这个特征值问题[@problem_id:3054034]，你不仅能推导出著名的球谐函数（spherical harmonics），还能通过外尔定律（Weyl's law）看到一个关键的几何不变量——球的面积——是如何从其特征值的渐近分布中浮现出来的。", "problem": "考虑单位2-球面 $S^2 \\subset \\mathbb{R}^3$，其上的圆度量由欧几里得度量诱导。令 $\\Delta_{S^2}$ 表示 $S^2$ 上的拉普拉斯-贝尔特拉米算子。在标准球坐标 $(\\theta,\\varphi)$（其中 $\\theta \\in (0,\\pi)$ 且 $\\varphi \\in (0,2\\pi)$）下，圆度量的形式为 $ds^2 = d\\theta^2 + \\sin^2\\theta \\, d\\varphi^2$。从通过公式 $\\Delta f = \\frac{1}{\\sqrt{|g|}} \\partial_{i}\\!\\left(\\sqrt{|g|}\\, g^{ij}\\partial_{j}f\\right)$ 推导出的拉普拉斯-贝尔特拉米算子的坐标表达式出发，求解该算子的特征值问题：\n$$\n\\Delta_{S^2} f + \\lambda f = 0,\n$$\n通过分离变量法 $f(\\theta,\\varphi) = \\Theta(\\theta)\\Phi(\\varphi)$，并要求函数在 $S^2$ 上是光滑和单值的。找出所有允许的特征值及相关的特征函数族（球谐函数），并计算每个特征空间的维数。然后，定义谱计数函数 $N(\\Lambda)$ 为 $-\\Delta_{S^2}$ 的不超过 $\\Lambda$ 的特征值数量（计入重数），并用满足 $L(L+1) \\le \\Lambda$ 的最大整数 $L$ 来精确表示 $N(\\Lambda)$。最后，使用你得到的 $N(\\Lambda)$ 的精确表达式来确定 Weyl 渐进律中的常数 $C$：\n$$\nN(\\Lambda) \\sim C\\, \\Lambda \\quad \\text{as } \\Lambda \\to \\infty,\n$$\n并解释 $C$ 如何与 $S^2$ 的几何面积相关联，从而联系到等谱流形的概念。\n\n你最终报告的答案必须是一个单行矩阵，按顺序包含：\n- 特征值（作为整数阶数 $l$ 的函数），\n- 重数（作为 $l$ 的函数），\n- 单位2-球面上 Weyl 定律中的常数 $C$。\n\n无需四舍五入。最终报告的答案中不要包含单位。", "solution": "该问题陈述是几何分析和数学物理中的一个标准且适定的练习。它包含了所有必要信息，科学上是合理的，并且没有矛盾或含糊之处。因此，该问题是有效的，我们可以着手求解。\n\n问题要求对单位2-球面 $S^2$ 上的拉普拉斯-贝尔特拉米算子进行完整的光谱分析。我们将分几步进行：首先，在球坐标中推导该算子；其次，使用分离变量法求解特征值问题；第三，确定特征值及其重数；第四，计算谱计数函数 $N(\\Lambda)$；最后，确定 Weyl 渐进律中的常数。\n\n首先，我们求出拉普拉斯-贝尔特拉米算子 $\\Delta_{S^2}$ 的表达式。度量由 $ds^2 = d\\theta^2 + \\sin^2\\theta \\, d\\varphi^2$ 给出。在坐标 $(x^1, x^2) = (\\theta, \\varphi)$ 下的度量张量为\n$$\ng_{ij} = \\begin{pmatrix} 1  0 \\\\ 0  \\sin^2\\theta \\end{pmatrix}\n$$\n度量的行列式为 $|g| = \\det(g_{ij}) = \\sin^2\\theta$。因为 $\\theta \\in (0, \\pi)$，所以 $\\sin\\theta > 0$，故 $\\sqrt{|g|} = \\sin\\theta$。逆度量张量 $g^{ij}$ 是矩阵 $g_{ij}$ 的逆：\n$$\ng^{ij} = \\begin{pmatrix} 1  0 \\\\ 0  \\frac{1}{\\sin^2\\theta} \\end{pmatrix}\n$$\n使用给定的公式 $\\Delta f = \\frac{1}{\\sqrt{|g|}} \\partial_{i}\\!\\left(\\sqrt{|g|}\\, g^{ij}\\partial_{j}f\\right)$（默认对重复指标求和），并注意到 $g^{ij}$ 是对角的，我们得到：\n$$\n\\Delta f = \\frac{1}{\\sin\\theta} \\left[ \\partial_{\\theta}\\!\\left(\\sin\\theta \\cdot g^{\\theta\\theta} \\cdot \\partial_{\\theta}f\\right) + \\partial_{\\varphi}\\!\\left(\\sin\\theta \\cdot g^{\\varphi\\varphi} \\cdot \\partial_{\\varphi}f\\right) \\right]\n$$\n代入 $g^{ij}$ 的分量：\n$$\n\\Delta f = \\frac{1}{\\sin\\theta} \\left[ \\partial_{\\theta}\\!\\left(\\sin\\theta \\cdot 1 \\cdot \\partial_{\\theta}f\\right) + \\partial_{\\varphi}\\!\\left(\\sin\\theta \\cdot \\frac{1}{\\sin^2\\theta} \\cdot \\partial_{\\varphi}f\\right) \\right]\n$$\n涉及 $\\partial_{\\varphi}f$ 的项在导数之外不含 $\\varphi$ 依赖，所以我们可以简化。然而，公式是 $\\partial_{\\varphi}(\\sqrt{|g|}...)$，而不是 $(\\sqrt{|g|}) \\partial_{\\varphi}(...)$，所以 $\\sin\\theta$ 项在关于 $\\varphi$ 的导数内部。\n求和的正确应用是：\n$$\n\\Delta f = \\frac{1}{\\sqrt{|g|}}\\left( \\partial_{\\theta}(\\sqrt{|g|} g^{\\theta\\theta} \\partial_{\\theta}f + \\sqrt{|g|} g^{\\theta\\varphi} \\partial_{\\varphi}f) + \\partial_{\\varphi}(\\sqrt{|g|} g^{\\varphi\\theta} \\partial_{\\theta}f + \\sqrt{|g|} g^{\\varphi\\varphi} \\partial_{\\varphi}f) \\right)\n$$\n因为 $g^{\\theta\\varphi} = g^{\\varphi\\theta} = 0$，这简化为：\n$$\n\\Delta f = \\frac{1}{\\sin\\theta} \\left[ \\partial_{\\theta}(\\sin\\theta \\cdot 1 \\cdot \\partial_{\\theta}f) + \\partial_{\\varphi}\\left(\\sin\\theta \\cdot \\frac{1}{\\sin^2\\theta} \\cdot \\partial_{\\varphi}f\\right) \\right]\n$$\n哎呀，重新检查公式发现 $\\sin\\theta$ 不应对 $\\varphi$求导。公式是对 $i$ 和 $j$ 求和的。对于对角度量，这应该是 $\\frac{1}{\\sqrt{|g|}}\\sum_i \\partial_i (\\sqrt{|g|} g^{ii} \\partial_i f)$。\n$$\n\\Delta f = \\frac{1}{\\sin\\theta} \\partial_\\theta \\left( \\sin\\theta \\, g^{\\theta\\theta} \\partial_\\theta f \\right) + \\frac{1}{\\sin\\theta} \\partial_\\varphi \\left( \\sin\\theta \\, g^{\\varphi\\varphi} \\partial_\\varphi f \\right)\n$$\n因为 $g^{\\varphi\\varphi} = 1/\\sin^2\\theta$ 且 $\\partial_\\varphi(\\sin\\theta) = 0$：\n$$\n\\Delta f = \\frac{1}{\\sin\\theta} \\frac{\\partial}{\\partial\\theta}\\left(\\sin\\theta \\frac{\\partial f}{\\partial\\theta}\\right) + \\frac{1}{\\sin\\theta} \\frac{\\sin\\theta}{\\sin^2\\theta} \\frac{\\partial^2 f}{\\partial\\varphi^2}\n$$\n所以 $S^2$ 上的拉普拉斯-贝尔特拉米算子是：\n$$\n\\Delta_{S^2} f = \\frac{1}{\\sin\\theta} \\frac{\\partial}{\\partial\\theta}\\left(\\sin\\theta \\frac{\\partial f}{\\partial\\theta}\\right) + \\frac{1}{\\sin^2\\theta} \\frac{\\partial^2f}{\\partial\\varphi^2}\n$$\n接下来，我们求解特征值问题 $\\Delta_{S^2} f + \\lambda f = 0$。我们使用分离变量法，设 $f(\\theta, \\varphi) = \\Theta(\\theta)\\Phi(\\varphi)$。将此代入特征值方程得到：\n$$\n\\frac{\\Phi(\\varphi)}{\\sin\\theta} \\frac{d}{d\\theta}\\left(\\sin\\theta \\frac{d\\Theta}{d\\theta}\\right) + \\frac{\\Theta(\\theta)}{\\sin^2\\theta} \\frac{d^2\\Phi}{d\\varphi^2} + \\lambda\\Theta(\\theta)\\Phi(\\varphi) = 0\n$$\n乘以 $\\frac{\\sin^2\\theta}{\\Theta(\\theta)\\Phi(\\varphi)}$ 可将变量分离：\n$$\n\\frac{\\sin\\theta}{\\Theta(\\theta)} \\frac{d}{d\\theta}\\left(\\sin\\theta \\frac{d\\Theta}{d\\theta}\\right) + \\lambda\\sin^2\\theta = -\\frac{1}{\\Phi(\\varphi)}\\frac{d^2\\Phi}{d\\varphi^2}\n$$\n左边只依赖于 $\\theta$，右边只依赖于 $\\varphi$。因此，两边必须等于一个常数，我们记为 $m^2$。这产生两个常微分方程。\n\n关于 $\\Phi(\\varphi)$ 的方程是：\n$$\n\\frac{d^2\\Phi}{d\\varphi^2} + m^2\\Phi = 0\n$$\n特征函数 $f$ 在球面上必须是单值函数的条件意味着 $\\Phi(\\varphi)$ 必须是周期为 $2\\pi$ 的函数，即 $\\Phi(\\varphi+2\\pi) = \\Phi(\\varphi)$。通解为 $\\Phi(\\varphi) = A e^{im\\varphi} + B e^{-im\\varphi}$。周期性要求 $m$ 必须是整数，$m \\in \\mathbb{Z}$。我们可以考虑解的基底为 $\\Phi_m(\\varphi) = e^{im\\varphi}$，其中 $m \\in \\mathbb{Z}$。\n\n关于 $\\Theta(\\theta)$ 的方程是：\n$$\n\\frac{\\sin\\theta}{\\Theta(\\theta)} \\frac{d}{d\\theta}\\left(\\sin\\theta \\frac{d\\Theta}{d\\theta}\\right) + \\lambda\\sin^2\\theta = m^2\n$$\n整理后得到：\n$$\n\\frac{1}{\\sin\\theta} \\frac{d}{d\\theta}\\left(\\sin\\theta \\frac{d\\Theta}{d\\theta}\\right) + \\left(\\lambda - \\frac{m^2}{\\sin^2\\theta}\\right)\\Theta = 0\n$$\n我们进行变量替换 $x = \\cos\\theta$。那么 $dx = -\\sin\\theta \\, d\\theta$，并且 $\\frac{d}{d\\theta} = -\\sin\\theta \\frac{d}{dx}$。该方程变换为连带勒让德方程：\n$$\n\\frac{d}{dx}\\left((1-x^2)\\frac{d\\Theta}{dx}\\right) + \\left(\\lambda - \\frac{m^2}{1-x^2}\\right)\\Theta = 0, \\quad x \\in [-1, 1]\n$$\n为了使特征函数在整个球面上光滑，解 $\\Theta(x)$ 必须在极点（即 $x = \\pm 1$ 处）是有限的。奇异 Sturm-Liouville 问题的理论指出，这种正则解仅在特征值参数 $\\lambda$ 取特定值时存在。这些值为 $\\lambda = l(l+1)$，其中 $l$ 是满足 $l \\ge |m|$ 的非负整数。因此，对于每个整数 $l = 0, 1, 2, \\dots$， $m$ 的有效取值为 $m = -l, -l+1, \\dots, l-1, l$。\n解 $\\Theta(x)$ 是连带勒让德多项式，记为 $P_l^m(x)$。\n\n因此，$-\\Delta_{S^2}$ 的特征值为 $\\lambda_l = l(l+1)$，其中 $l=0, 1, 2, \\ldots$。相应的特征函数，即球谐函数，为 $Y_l^m(\\theta, \\varphi) = C_{lm} P_l^m(\\cos\\theta)e^{im\\varphi}$，其中 $C_{lm}$ 是归一化常数。\n\n每个特征值 $\\lambda_l$ 的重数是相应特征空间的维数。由于特征值 $\\lambda_l = l(l+1)$ 只依赖于 $l$，所有具有相同 $l$ 但不同有效 $m$ 值的特征函数都是简并的。对于给定的 $l$，$m$ 的可能取值个数是 $l - (-l) + 1 = 2l+1$。函数集 $\\{Y_l^m\\}_{m=-l}^l$ 构成了特征空间的一个基底。因此，该特征空间的维数，即特征值 $\\lambda_l$ 的重数，是 $2l+1$。\n\n谱计数函数 $N(\\Lambda)$ 是 $-\\Delta_{S^2}$ 的小于或等于 $\\Lambda$ 的特征值数量，计入其重数。特征值为 $\\lambda_l=l(l+1)$。我们需要对所有满足 $l(l+1) \\le \\Lambda$ 的整数 $l \\ge 0$ 求和其重数 $(2l+1)$。设 $L$ 为满足此条件的最大整数。\n$$\nN(\\Lambda) = \\sum_{l=0}^{L} (2l+1)\n$$\n这个和可以精确计算：\n$$\nN(\\Lambda) = 2 \\sum_{l=0}^{L} l + \\sum_{l=0}^{L} 1 = 2 \\frac{L(L+1)}{2} + (L+1) = L(L+1) + (L+1) = (L+1)^2\n$$\n所以，$N(\\Lambda) = (L+1)^2$，其中 $L = \\max\\{l \\in \\mathbb{Z}_{\\ge 0} \\mid l(l+1) \\le \\Lambda\\}$。\n\n最后，我们确定 Weyl 渐进律 $N(\\Lambda) \\sim C\\Lambda$（当 $\\Lambda \\to \\infty$ 时）中的常数 $C$。从条件 $L(L+1) = L^2+L \\le \\Lambda$ 出发，我们可以找到 $L$ 的渐进行为。对于大的 $\\Lambda$，$L$ 也会很大，且 $L^2+L \\approx L^2$。所以 $L^2 \\approx \\Lambda$，这意味着 $L \\sim \\sqrt{\\Lambda}$。更精确地，解方程 $L^2+L-\\Lambda = 0$ 得到 $L>0$ 的解为 $L = \\frac{-1+\\sqrt{1+4\\Lambda}}{2} \\sim \\frac{\\sqrt{4\\Lambda}}{2} = \\sqrt{\\Lambda}$（当 $\\Lambda\\to\\infty$ 时）。\n将此代入我们得到的 $N(\\Lambda)$ 的精确表达式中：\n$$\nN(\\Lambda) = (L+1)^2 \\sim (\\sqrt{\\Lambda}+1)^2 = \\Lambda + 2\\sqrt{\\Lambda} + 1\n$$\n当 $\\Lambda \\to \\infty$ 时，首项是 $\\Lambda$。因此，$N(\\Lambda) \\sim \\Lambda$。与 $N(\\Lambda) \\sim C\\Lambda$ 比较，我们发现常数 $C=1$。\n\n对于一个一般的 $n$ 维紧黎曼流形 $(M,g)$，Weyl 定律为 $N(\\Lambda) \\sim \\frac{\\omega_n \\text{vol}(M,g)}{(2\\pi)^n}\\Lambda^{n/2}$，其中 $\\omega_n$ 是 $\\mathbb{R}^n$ 中单位球的体积。对于2-球面 $S^2$，我们有 $n=2$，面积 $\\text{vol}(S^2) = 4\\pi$（对单位球面而言），以及 $\\omega_2 = \\pi$。该公式给出：\n$$\nC = \\frac{\\omega_2 \\text{vol}(S^2)}{(2\\pi)^2} = \\frac{\\pi (4\\pi)}{(2\\pi)^2} = \\frac{4\\pi^2}{4\\pi^2} = 1\n$$\n这验证了我们的直接计算。这种联系表明，特征值计数函数的首项由流形的体积（面积）决定。这是谱几何学中的一个基本结果，也是一个人能够“听”到的关于流形形状（即 Kac 问题中的“鼓”）的首批信息之一，这对于研究等谱流形至关重要。\n\n所要求的量是：\n1. 作为 $l$ 的函数的特征值：$\\lambda_l = l(l+1)$，其中 $l \\in \\{0, 1, 2, \\ldots\\}$。\n2. $\\lambda_l$ 的重数：$2l+1$。\n3. Weyl 定律中的常数 $C$：$1$。", "answer": "$$\n\\boxed{\\begin{pmatrix} l(l+1)  2l+1  1 \\end{pmatrix}}\n$$", "id": "3054034"}, {"introduction": "虽然计算谱是基础，但等谱几何最引人入胜之处在于存在听起来相同但形状不同的非等距（non-isometric）流形。本练习将深入探讨 Sunada 方法的代数核心，这是一种构造此类流形对的强大技术。你将通过手动计算来验证对称群 $S_4$ 中的一对特定子群满足“几乎共轭”（almost conjugacy）条件[@problem_id:3054467]，从而为一个能够生成等谱“鼓”的群论机制提供一个具体实例。", "problem": "设 $M$ 是一个紧黎曼流形，$\\pi:\\widetilde{M}\\to M$ 是一个有限正规覆盖，其覆盖变换群为 $G\\cong S_4$。回顾一下，一个三元组 $(G,H,K)$ 被称为Sunada三元组，如果对于 $G$ 中的每一个共轭类 $C\\subset G$，都有 $\\lvert H\\cap C\\rvert=\\lvert K\\cap C\\rvert$。这个条件等价于作为 $G$-模的置换表示相等，即 $\\mathbb{C}[G/H]\\cong \\mathbb{C}[G/K]$，并且它意味着商空间 $\\widetilde{M}/H$ 和 $\\widetilde{M}/K$ 关于Laplace–Beltrami算子是等谱的。\n\n考虑 $G=S_4$。定义子群\n$$\nH=\\langle (1234),(13)\\rangle,\\qquad K=(12)\\,H\\,(12)^{-1}.\n$$\n仅使用群论的基本事实和 $S_4$ 中共轭类按循环类型的分类，通过计算 $S_4$ 的每个共轭类 $C$ 的数值 $\\lvert H\\cap C\\rvert$ 和 $\\lvert K\\cap C\\rvert$，来手动验证 $(G,H,K)$ 是一个Sunada三元组。特别地，列出共同的五元组数值\n$$\n\\big(\\lvert H\\cap C_{\\text{id}}\\rvert,\\ \\lvert H\\cap C_{(2)}\\rvert,\\ \\lvert H\\cap C_{(3)}\\rvert,\\ \\lvert H\\cap C_{(2,2)}\\rvert,\\ \\lvert H\\cap C_{(4)}\\rvert\\big),\n$$\n其中 $C_{\\text{id}}$ 是单位元类，$C_{(2)}$ 是对换类，$C_{(3)}$ 是3-循环类，$C_{(2,2)}$ 是双对换类，$C_{(4)}$ 是4-循环类。将此五元组作为你的最终答案。\n\n你的最终答案必须是包含这五个整数的单行矩阵，顺序如上所述。无需四舍五入。", "solution": "我们从对称群 $S_4$ 中共轭类的基本定义以及Sunada三元组的定义开始。$S_4$ 中的共轭类由循环类型决定，恰好有五个类：\n- $C_{\\text{id}}=\\{e\\}$，\n- $C_{(2)}=$ 所有对换，共6个，\n- $C_{(3)}=$ 所有3-循环，共8个，\n- $C_{(2,2)}=$ 所有双对换，共3个，\n- $C_{(4)}=$ 所有4-循环，共6个。\n\n根据构造，$K=(12)\\,H\\,(12)^{-1}$ 在 $S_4$ 中与 $H$ 共轭。因此，对于 $S_4$ 中的每个共轭类 $C\\subset S_4$，都有 $\\lvert H\\cap C\\rvert=\\lvert K\\cap C\\rvert$，因为共轭运算保持循环类型，并诱导了一个从 $H$ 到 $K$ 的双射。因此，我们只需计算 $H$ 的计数。\n\n我们计算 $H=\\langle r,s\\rangle$ 的元素，其中 $r=(1234)$，$s=(13)$。由 $r$ 和 $s$ 生成的子群是一个8阶二面体群，因为 $srs^{-1}=r^{-1}$。$H$ 的元素是\n$$\ne,\\ r,\\ r^2,\\ r^3,\\ s,\\ rs,\\ r^2s,\\ r^3s.\n$$\n现在我们确定它们的循环类型：\n- $e$ 是单位元，所以 $e\\in C_{\\text{id}}$。\n- $r=(1234)$ 是一个4-循环，所以 $r\\in C_{(4)}$。\n- $r^2=(1234)^2=(13)(24)$ 是一个双对换，所以 $r^2\\in C_{(2,2)}$。\n- $r^3=(1234)^3=(1432)$ 是一个4-循环，所以 $r^3\\in C_{(4)}$。\n- $s=(13)$ 是一个对换，所以 $s\\in C_{(2)}$。\n- $rs=(1234)(13)$ 通过复合来计算（先应用 $(13)$，再应用 $(1234)$）。作用于 $1$，$1\\mapsto 3\\mapsto 4$；作用于 $4$，$4\\mapsto 4\\mapsto 1$；作用于 $2$，$2\\mapsto 2\\mapsto 3$；作用于 $3$，$3\\mapsto 1\\mapsto 2$。因此 $rs=(14)(23)$，是一个双对换，所以 $rs\\in C_{(2,2)}$。\n- $r^2s=(13)(24)\\,(13)$ 同样地计算（先应用 $(13)$，再应用 $(13)(24)$）。作用于 $2$，$2\\mapsto 2\\mapsto 4$；作用于 $4$，$4\\mapsto 4\\mapsto 2$；作用于 $1$，$1\\mapsto 3\\mapsto 1$；作用于 $3$，$3\\mapsto 1\\mapsto 3$。因此 $r^2s=(24)$，是一个对换，所以 $r^2s\\in C_{(2)}$。\n- $r^3s=(1432)(13)$，通过类似的计算，可以得到 $r^3s=(12)(34)$，是一个双对换，所以 $r^3s\\in C_{(2,2)}$。\n\n按共轭类对 $H$ 的元素进行汇总计数：\n- $C_{\\text{id}}$：恰好1个元素（$e$）。\n- $C_{(2)}$：恰好2个元素（$(13)$ 和 $(24)$）。\n- $C_{(3)}$：$H$ 中没有元素是3-循环，所以为0。\n- $C_{(2,2)}$：恰好3个元素（$(13)(24)$、$(14)(23)$ 和 $(12)(34)$）。\n- $C_{(4)}$：恰好2个元素（$(1234)$ 和 $(1432)$）。\n\n因此，$H$ 的五元组是 $(1,2,0,3,2)$。因为 $K$ 与 $H$ 共轭，所以对 $K$ 也成立相同的计数。因此，对于 $S_4$ 中的每个共轭类 $C\\subset S_4$，都有 $\\lvert H\\cap C\\rvert=\\lvert K\\cap C\\rvert$，所以 $(G,H,K)$ 是一个Sunada三元组。\n\n所要求的行矩阵，按照 $(C_{\\text{id}}, C_{(2)}, C_{(3)}, C_{(2,2)}, C_{(4)})$ 的顺序，是 $(1,2,0,3,2)$。", "answer": "$$\\boxed{\\begin{pmatrix}1  2  0  3  2\\end{pmatrix}}$$", "id": "3054467"}, {"introduction": "在现实世界中，大多数区域的形状过于复杂，无法解析地计算出其谱。这时，计算方法就变得不可或缺。这个动手编程任务让你扮演数值分析师的角色，通过实现有限差分格式（finite difference scheme）来近似计算多边形“鼓”的特征值[@problem_id:3054056]。通过比较不同形状的计算谱，你将在数值上验证或反驳等谱性的论断方面获得实践经验，从而架起抽象理论与可触摸结果之间的桥梁。", "problem": "你需要编写一个完整、可运行的程序，该程序能数值近似计算平面多边形域上拉普拉斯算子的低频狄利克雷特征值，并使用这些近似值来评估两个候选鼓面基于移植的等谱性论断。请完全在纯数学环境下工作：拉普拉斯算子、狄利克雷边界条件和有限差分法离散化。不涉及任何物理单位。\n\n背景与基础：对于一个边界足够光滑的有界域 $D \\subset \\mathbb{R}^2$，拉普拉斯算子的狄利克雷特征值问题旨在寻找非平凡函数 $u \\in H_0^1(D)$ 和标量 $\\lambda \\in \\mathbb{R}$，使得\n$$\n-\\Delta u = \\lambda u \\quad \\text{in } D, \\qquad u|_{\\partial D} = 0.\n$$\n其谱由一个离散、无界、正的序列 $0 < \\lambda_1 \\le \\lambda_2 \\le \\cdots \\to \\infty$ 构成，该序列仅在无穷远处累积。如果两个域 $D_1$ 和 $D_2$ 的谱（计算重数）完全相同，则称它们是等谱的。移植构造法提供了一些非平凡的例子，其中不同的域是等谱的。\n\n需使用的数值方法：你必须在尺寸为 $h > 0$ 的均匀笛卡尔网格上，使用标准的五点有限差分格式来近似带狄利克雷边界条件的算子 $-\\Delta$。设 $\\mathcal{G}_h$ 为包含该多边形的一个包围盒内的网格点集合，并设 $I_h \\subset \\mathcal{G}_h$ 为严格位于多边形域 $D$ 内部的网格点集合。离散狄利克雷拉普拉斯算子 $L_h$ 作用于函数 $u_h : I_h \\to \\mathbb{R}$ 的方式如下：\n$$\n(L_h u_h)(x) = \\frac{1}{h^2}\\left(4 u_h(x) - \\sum_{y \\in N(x) \\cap I_h} u_h(y)\\right),\n$$\n其中 $N(x)$ 是 $x$ 在 $\\mathcal{G}_h$ 中沿坐标轴方向的四个相邻点，而 $I_h$ 之外的邻点被视为值为 $0$ 的边界点。离散特征值问题是\n$$\nL_h u_h = \\lambda_h u_h,\n$$\n当 $h \\to 0$ 时，其最小的正特征值 $\\lambda_h$ 近似于连续特征值 $\\lambda$。\n\n算法要求：\n- 实现一个点在多边形内测试，以判断对于一个由其顶点按逆时针顺序指定的简单多边形，哪些网格点属于 $I_h$。\n- 在 $I_h$ 上使用五点模板组装 $L_h$ 的稀疏矩阵。\n- 使用一个可靠的、带位移求逆的稀疏对称特征值求解器，计算给定多边形域的 $k$ 个最小正特征值 $\\lambda_{h,1} \\le \\cdots \\le \\lambda_{h,k}$。\n- 给定两个域 $D_1, D_2$，如果在容差 $\\tau$ 内满足以下条件，则声明它们在数值上是等谱的：\n$$\n\\max_{1 \\le i \\le k} \\frac{\\lvert \\lambda^{(1)}_{h,i} - \\lambda^{(2)}_{h,i} \\rvert}{\\max\\{ \\lambda^{(1)}_{h,i}, \\lambda^{(2)}_{h,i} \\}} \\le \\tau.\n$$\n\n测试套件：使用网格尺寸 $h = 0.05$ 并为每个域计算前 $k = 6$ 个特征值。用容差 $\\tau = 10^{-3}$ 评估以下四种情况：\n\n- 案例 A（通过等距变换进行的健全性检查）：$D_1$ 是具有以下顶点的 L 形多边形\n  $$\n  (0,0),\\ (2,0),\\ (2,1),\\ (1,1),\\ (1,2),\\ (0,2),\n  $$\n  而 $D_2$ 是将 $D_1$ 围绕点 $(1,1)$ 逆时针旋转 $90^\\circ$ 得到的。在指定的 $h$ 下，这对域在数值上应该是等谱的。\n- 案例 B（候选移植对，预期失败）：$D_1$ 与案例 A 中的 L 形多边形相同，而 $D_2$ 是具有以下顶点的 T 形多边形\n  $$\n  (0,0),\\ (2,0),\\ (2,0.5),\\ (1.25,0.5),\\ (1.25,2),\\ (0.75,2),\\ (0.75,0.5),\\ (0,0.5).\n  $$\n  这是一个非平凡的候选对；你必须测试其数值谱是否在容差范围内匹配。\n- 案例 C（面积相等的对照组，预期非等谱）：$D_1$ 是具有以下顶点的单位正方形\n  $$\n  (0,0),\\ (1,0),\\ (1,1),\\ (0,1),\n  $$\n  而 $D_2$ 是具有以下顶点的矩形\n  $$\n  (0,0),\\ (2,0),\\ (2,0.5),\\ (0,0.5),\n  $$\n  其面积与单位正方形相同。这对域在数值上应该不是等谱的。\n- 案例 D（同一性检查）：$D_1$ 和 $D_2$ 都是单位正方形。这对域必须在数值上是等谱的。\n\n最终输出格式：你的程序应生成单行输出，其中包含一个对应于案例 A、B、C 和 D 的四个布尔值的列表，分别指示每对域是否在前 $k$ 个特征值下、在容差 $\\tau$ 内是数值等谱的。输出必须是单行，格式完全如下\n[bool_A,bool_B,bool_C,bool_D]\n其中布尔字面量写作 True 或 False。", "solution": "用户提供的问题是数值谱几何中一个明确定义的任务。它要求对几对平面多边形域的等谱性进行数值验证。方法论是预先指定的：使用五点有限差分格式离散化连续的拉普拉斯-狄利克雷特征值问题，然后求解由此产生的矩阵特征值问题。该问题在科学上是合理的，自成一体，并且在算法上是明确的。因此，它是有效的，下面提供了解决方案。\n\n该解决方案的实现方式是开发一个数值过程，用于计算给定多边形域 $D$ 的前 $k$ 个最小狄利克雷拉普拉斯特征值。然后将此过程应用于四个指定测试用例中的每个域，并比较所得的谱。\n\n整个算法包括四个主要阶段：\n1.  **域离散化**：在域上叠加一个均匀的笛卡尔网格。识别严格位于多边形内部的网格点。\n2.  **矩阵组装**：基于内部网格点的连通性，将离散拉普拉斯算子 $L_h$ 构造为一个稀疏矩阵。\n3.  **特征值计算**：使用专门的数值求解器计算所得矩阵的特征值。\n4.  **等谱性测试**：使用指定的相对误差度量，比较成对域的计算出的特征值。\n\n每个步骤的详细说明如下。\n\n**1. 域离散化与内部点识别**\n\n给定一个由其顶点定义的多边形，我们首先确定一个包围盒。然后用间距为 $h$ 的均匀笛卡尔网格点填充该盒。设这些网格点的集合为 $\\mathcal{G}_h$。核心任务是识别出严格位于域 $D$ 内部的点子集 $I_h \\subset \\mathcal{G}_h$。\n\n这个识别过程通过对每个网格点 $p \\in \\mathcal{G}_h$ 进行两步的点在多边形内测试来完成：\n- **边界检查**：首先，我们确定 $p$ 是否位于边界 $\\partial D$ 上。如果一个点与多边形的某条边共线，并且位于该边两个端点之间，则该点在边界上。由于浮点运算，此检查使用一个小的容差 $\\epsilon$ 进行。如果 $p$ 在边界上，它就不在严格内部，并从 $I_h$ 中排除。\n- **内部检查**：如果 $p$ 不在边界上，我们使用环绕数算法来确定它是否在内部。该算法计算多边形围绕点 $p$ 的环绕数。对于一个顶点按逆时针顺序排列的简单多边形，内部点的环绕数为 $1$，外部点为 $0$。因此，如果点 $p$ 的环绕数非零，则将其添加到 $I_h$ 中。\n\n这个稳健的两阶段过程正确地识别了 $N = |I_h|$ 个内部网格点的集合。然后将这些点映射到从 $0$ 到 $N-1$ 的整数索引，以便于矩阵的构建。\n\n**2. 离散拉普拉斯算子的矩阵组装**\n\n连续算子 $-\\Delta$ 由离散拉普拉斯算子 $L_h$ 近似。$L_h$ 作用于定义在内部网格点 $I_h$ 上的函数 $u_h$ 的方式由五点模板给出：\n$$\n(L_h u_h)(x) = \\frac{1}{h^2}\\left(4 u_h(x) - \\sum_{y \\in N(x) \\cap I_h} u_h(y)\\right)\n$$\n其中 $N(x)$ 是 $x$ 的四个轴向相邻点。狄利克雷边界条件 $u|_{\\partial D} = 0$ 通过仅对同在 $I_h$ 内的邻点求和而隐式地强制执行。\n\n这个线性系统可以表示为一个矩阵方程。设 $u_h$ 在 $N$ 个内部点的值排列成一个向量 $\\mathbf{u} \\in \\mathbb{R}^N$。离散特征值问题 $L_h u_h = \\lambda_h u_h$ 变为矩阵特征值问题 $A \\mathbf{u} = (h^2 \\lambda_h) \\mathbf{u}$，其中 $A$ 是一个 $N \\times N$ 的稀疏矩阵。\n\n矩阵 $A$ 的构造如下：\n- 对于每个索引为 $i \\in \\{0, \\dots, N-1\\}$ 的内部点 $p_i$，对角线元素为 $A_{ii} = 4$。\n- 对于 $p_i$ 的每个邻点 $p_j$，如果它也是一个内部点（索引为 $j$），则非对角线元素为 $A_{ij} = -1$。\n- 所有其他元素均为零。\n\n所得矩阵 $A$ 是稀疏、对称且正定的。\n\n**3. 特征值计算**\n\n任务简化为找到矩阵问题 $A \\mathbf{u} = \\mu \\mathbf{u}$ 的最小特征值，其中 $\\mu = h^2 \\lambda_h$。由于 $A$ 是一个大型、稀疏、对称的矩阵，使用像兰佐斯算法这样的迭代方法可以高效地解决这个问题。`scipy.sparse.linalg.eigsh` 函数非常适合此目的。\n\n为了找到原问题的 $k$ 个最小特征值，我们寻求 $A$ 的 $k$ 个最小特征值 $\\mu$。这通过调用 `eigsh` 并设置参数 `which='SM'` 来实现，该参数指示求解器寻找最小幅值的特征值。对于正定矩阵 $A$，这些就是最小的正特征值。获得 $A$ 的特征值 $\\mu_1, \\dots, \\mu_k$ 后，通过关系式 $\\lambda_{h,i} = \\mu_i / h^2$ 恢复离散拉普拉斯算子 $L_h$ 相应的特征值。\n\n**4. 等谱性评估**\n\n对于测试套件中的每一对域 $(D_1, D_2)$，我们计算它们各自的前 $k$ 个特征值集合，即 $\\{\\lambda_{h,i}^{(1)}\\}_{i=1}^k$ 和 $\\{\\lambda_{h,i}^{(2)}\\}_{i=1}^k$。如果相应特征值之间的最大相对差异在给定容差 $\\tau$ 之内，则声明这两个域在数值上是等谱的。条件是：\n$$\n\\max_{1 \\le i \\le k} \\frac{\\lvert \\lambda^{(1)}_{h,i} - \\lambda^{(2)}_{h,i} \\rvert}{\\max\\{ \\lambda^{(1)}_{h,i}, \\lambda^{(2)}_{h,i} \\}} \\le \\tau\n$$\n对四种情况中的每一种都执行此过程，并将布尔结果收集到一个列表中作为最终输出。使用的参数是 $h = 0.05$，$k=6$ 和 $\\tau=10^{-3}$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import sparse\nfrom scipy.sparse.linalg import eigsh\n\ndef solve():\n    \"\"\"\n    Main function to run the isospectrality tests for all four cases.\n    \"\"\"\n    \n    # --- Problem Parameters ---\n    h = 0.05\n    k = 6\n    tau = 1e-3\n\n    # --- Test Case Definitions ---\n\n    # Case A: L-shape vs. Rotated L-shape\n    l_shape_vertices = np.array([\n        (0.0, 0.0), (2.0, 0.0), (2.0, 1.0), (1.0, 1.0), (1.0, 2.0), (0.0, 2.0)\n    ])\n    # Rotation by 90 deg CCW about (1,1): (x,y) -> (1-(y-1), 1+(x-1)) = (2-y, x)\n    rotation_center = np.array([1.0, 1.0])\n    rotated_l_shape_vertices = np.array([\n        (rotation_center[0] - (v[1] - rotation_center[1]), rotation_center[1] + (v[0] - rotation_center[0]))\n        for v in l_shape_vertices\n    ])\n    \n    # Case B: L-shape vs. T-shape\n    t_shape_vertices = np.array([\n        (0.0, 0.0), (2.0, 0.0), (2.0, 0.5), (1.25, 0.5), (1.25, 2.0),\n        (0.75, 2.0), (0.75, 0.5), (0.0, 0.5)\n    ])\n\n    # Case C: Unit square vs. Rectangle of same area\n    unit_square_vertices = np.array([\n        (0.0, 0.0), (1.0, 0.0), (1.0, 1.0), (0.0, 1.0)\n    ])\n    rectangle_vertices = np.array([\n        (0.0, 0.0), (2.0, 0.0), (2.0, 0.5), (0.0, 0.5)\n    ])\n\n    # Case D: Unit square vs. itself\n    # Uses unit_square_vertices from Case C\n\n    test_cases = [\n        {\"D1\": l_shape_vertices, \"D2\": rotated_l_shape_vertices},\n        {\"D1\": l_shape_vertices, \"D2\": t_shape_vertices},\n        {\"D1\": unit_square_vertices, \"D2\": rectangle_vertices},\n        {\"D1\": unit_square_vertices, \"D2\": unit_square_vertices}\n    ]\n\n    all_results = []\n\n    # Memoization to avoid recomputing eigenvalues for the same shape\n    memo = {}\n\n    for case in test_cases:\n        D1_key = tuple(map(tuple, case[\"D1\"]))\n        D2_key = tuple(map(tuple, case[\"D2\"]))\n        \n        if D1_key not in memo:\n            memo[D1_key] = compute_eigenvalues(case[\"D1\"], h, k)\n        if D2_key not in memo:\n            memo[D2_key] = compute_eigenvalues(case[\"D2\"], h, k)\n            \n        eigs1 = memo[D1_key]\n        eigs2 = memo[D2_key]\n        \n        if len(eigs1)  k or len(eigs2)  k:\n            # Handle cases where not enough eigenvalues are found (e.g., small domains)\n            # Declaring non-isospectral is a safe action.\n            is_isospectral = False\n        else:\n            max_rel_diff = np.max(\n                np.abs(eigs1 - eigs2) / np.maximum(eigs1, eigs2)\n            )\n            is_isospectral = max_rel_diff = tau\n        \n        all_results.append(is_isospectral)\n\n    print(f\"[{','.join(map(str, all_results))}]\")\n\n\ndef compute_eigenvalues(polygon_vertices, h, k):\n    \"\"\"\n    Computes the k smallest Dirichlet eigenvalues for a polygonal domain.\n    \"\"\"\n    # Floating point tolerance for geometric checks\n    epsilon = 1e-9\n\n    def is_on_boundary(p, vertices):\n        \"\"\"Check if a point p is on the boundary of the polygon.\"\"\"\n        for i in range(len(vertices)):\n            p1 = vertices[i]\n            p2 = vertices[(i + 1) % len(vertices)]\n            # Check for collinearity using cross product\n            cross_product = (p[1] - p1[1]) * (p2[0] - p1[0]) - \\\n                            (p[0] - p1[0]) * (p2[1] - p1[1])\n            if abs(cross_product)  epsilon:\n                # Check if point is between segment endpoints\n                dot_product = (p[0] - p1[0]) * (p2[0] - p1[0]) + \\\n                              (p[1] - p1[1]) * (p2[1] - p1[1])\n                squared_length = (p2[0] - p1[0])**2 + (p2[1] - p1[1])**2\n                if 0 = dot_product = squared_length:\n                    return True\n        return False\n\n    def is_inside(p, vertices):\n        \"\"\"\n        Check if a point p is strictly inside a polygon using the winding number algorithm.\n        This assumes the point is NOT on the boundary.\n        \"\"\"\n        wn = 0  # Winding number\n        for i in range(len(vertices)):\n            p1 = vertices[i]\n            p2 = vertices[(i + 1) % len(vertices)]\n            if p1[1] = p[1]:\n                if p2[1] > p[1]:  # An upward crossing\n                    # is_left > 0 for p left of edge\n                    is_left = (p2[0] - p1[0]) * (p[1] - p1[1]) - \\\n                              (p[0] - p1[0]) * (p2[1] - p1[1])\n                    if is_left > 0:\n                        wn += 1\n            elif p2[1] = p[1]:  # A downward crossing\n                is_left = (p2[0] - p1[0]) * (p[1] - p1[1]) - \\\n                          (p[0] - p1[0]) * (p2[1] - p1[1])\n                if is_left  0:\n                    wn -= 1\n        return wn != 0\n\n    # 1. Grid generation and interior point identification\n    xmin, ymin = np.min(polygon_vertices, axis=0) - 2 * h\n    xmax, ymax = np.max(polygon_vertices, axis=0) + 2 * h\n\n    # Use indices for grid points to avoid float precision issues\n    x_indices = np.arange(round(xmin / h), round(xmax / h) + 1)\n    y_indices = np.arange(round(ymin / h), round(ymax / h) + 1)\n    \n    interior_grid_indices = []\n    for i in x_indices:\n        for j in y_indices:\n            px, py = i * h, j * h\n            point = np.array([px, py])\n            if not is_on_boundary(point, polygon_vertices) and is_inside(point, polygon_vertices):\n                interior_grid_indices.append((i, j))\n\n    if len(interior_grid_indices) = k:\n        return np.array([]) # Not enough interior points\n\n    grid_idx_to_matrix_idx = {idx: i for i, idx in enumerate(interior_grid_indices)}\n    N = len(interior_grid_indices)\n\n    # 2. Matrix assembly\n    A = sparse.lil_matrix((N, N))\n    for matrix_idx, grid_idx in enumerate(interior_grid_indices):\n        i, j = grid_idx\n        A[matrix_idx, matrix_idx] = 4.0\n        \n        neighbors = [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]\n        for neighbor_idx in neighbors:\n            if neighbor_idx in grid_idx_to_matrix_idx:\n                neighbor_matrix_idx = grid_idx_to_matrix_idx[neighbor_idx]\n                A[matrix_idx, neighbor_matrix_idx] = -1.0\n    \n    A = A.tocsc()\n    \n    # 3. Eigenvalue computation\n    # Find eigenvalues of A, which are mu = lambda * h^2\n    # eigsh(which='SM') finds eigenvalues with smallest magnitude.\n    # Sigma is implicitly 0.\n    try:\n        # Use A.shape[0] - 1 for k if k is too large for matrix dimension\n        num_eigs_to_find = min(k, N - 1)\n        mu, _ = eigsh(A, k=num_eigs_to_find, which='SM')\n    except Exception:\n        # Failsafe for convergence issues\n        return np.array([])\n    \n    # Sort eigenvalues by magnitude and get the smallest ones\n    mu = np.sort(mu)\n    \n    # 4. Convert to eigenvalues of the Laplacian\n    lambdas = mu / (h**2)\n    \n    return lambdas\n\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3054056"}]}