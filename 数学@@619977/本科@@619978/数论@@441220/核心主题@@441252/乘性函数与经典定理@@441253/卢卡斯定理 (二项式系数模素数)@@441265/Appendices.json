{"hands_on_practices": [{"introduction": "在深入应用卢卡斯定理之前，理解其根本原理至关重要。本练习将引导你通过一个具体例子，逐步从第一性原理（即模 $p$ 多项式环的性质）出发，推导出定理的结果。通过这个过程，你将亲手揭示 $p$-进制表示法与模算术下二项式展开之间的深刻联系，为后续学习打下坚实的概念基础。[@problem_id:3087050]", "problem": "在素数模整数环中，二项式系数的同余式可以通过以素数为底的展开式进行分析。完全在模素数 $p$ 的意义下，仅利用二项式定理以及“对于素数 $p$ 和满足 $0  r  p$ 的所有整数 $r$，$\\binom{p}{r}$ 能被 $p$ 整除”这一事实，求 $\\binom{83}{27}$ 模 $5$ 的值。", "solution": "目标是求出二项式系数 $\\binom{83}{27}$ 模素数 $p=5$ 的最小非负余数。我们被限制只能使用二项式定理以及“对于素数 $p$ 和满足 $0  r  p$ 的所有整数 $r$，$\\binom{p}{r}$ 能被 $p$ 整除”这一事实。\n\n我们首先分析在记作 $\\mathbb{Z}_p[x]$ 的模 $p$ 整数系数多项式环中的多项式 $(1+x)^p$。根据二项式定理，有 $(1+x)^p = \\sum_{r=0}^{p} \\binom{p}{r} x^r$。\n展开此和式得到：\n$$(1+x)^p = \\binom{p}{0}x^0 + \\binom{p}{1}x^1 + \\dots + \\binom{p}{p-1}x^{p-1} + \\binom{p}{p}x^p$$\n我们知道 $\\binom{p}{0} = 1$ 且 $\\binom{p}{p} = 1$。问题陈述中给出了对于 $0  r  p$，系数 $\\binom{p}{r}$ 能被 $p$ 整除，这意味着 $\\binom{p}{r} \\equiv 0 \\pmod{p}$。\n因此，当考虑模 $p=5$ 的多项式时，所有中间项都消失了：\n$$(1+x)^5 \\equiv 1 \\cdot x^0 + 0 \\cdot x^1 + \\dots + 0 \\cdot x^4 + 1 \\cdot x^5 \\pmod{5}$$\n$$(1+x)^5 \\equiv 1 + x^5 \\pmod{5}$$\n这个结果有时被称为“大一新生之梦”。我们可以将这个性质推广到素数 $p$ 的更高次幂。例如，对于 $p^2$：\n$$(1+x)^{p^2} = ((1+x)^p)^p \\equiv (1+x^p)^p \\pmod{p}$$\n对以变量 $y=x^p$ 构成的多项式应用同样的性质，我们得到 $(1+y)^p \\equiv 1+y^p \\pmod{p}$。将 $y=x^p$ 代回：\n$$(1+x^p)^p \\equiv 1 + (x^p)^p = 1 + x^{p^2} \\pmod{p}$$\n通过归纳法，这可以推广到对于任何非负整数 $j$ 都有 $(1+x)^{p^j} \\equiv 1+x^{p^j} \\pmod{p}$。当 $p=5$ 时，我们有 $(1+x)^{5^j} \\equiv 1+x^{5^j} \\pmod{5}$。\n\n下一步是将整数 $n=83$ 和 $k=27$ 表示为以 $p=5$ 为底的进制。\n对于 $n=83$：\n$83 = 3 \\times 25 + 8 = 3 \\times 5^2 + 8$\n$8 = 1 \\times 5 + 3 = 1 \\times 5^1 + 3$\n$3 = 3 \\times 1 = 3 \\times 5^0$\n所以，$n=83$ 的 $5$-进制展开式为 $n = 3 \\cdot 5^2 + 1 \\cdot 5^1 + 3 \\cdot 5^0$。我们可以将其写作 $n=(313)_5$。令其各位数字为 $n_2=3$，$n_1=1$ 和 $n_0=3$。\n\n对于 $k=27$：\n$27 = 1 \\times 25 + 2 = 1 \\times 5^2 + 2$\n$2 = 0 \\times 5 + 2 = 0 \\times 5^1 + 2$\n$2 = 2 \\times 1 = 2 \\times 5^0$\n所以，$k=27$ 的 $5$-进制展开式为 $k = 1 \\cdot 5^2 + 0 \\cdot 5^1 + 2 \\cdot 5^0$。我们可以将其写作 $k=(102)_5$。令其各位数字为 $k_2=1$，$k_1=0$ 和 $k_0=2$。\n\n二项式系数 $\\binom{n}{k} = \\binom{83}{27}$ 根据定义是 $(1+x)^n = (1+x)^{83}$ 展开式中 $x^k=x^{27}$ 项的系数。我们将通过模 5 运算来求这个系数。\n我们使用 $n=83$ 的 $5$-进制展开式来分解多项式：\n$$(1+x)^{83} = (1+x)^{3 \\cdot 5^2 + 1 \\cdot 5^1 + 3 \\cdot 5^0} = (1+x)^{3 \\cdot 25} (1+x)^{1 \\cdot 5} (1+x)^{3}$$\n$$(1+x)^{83} = \\left((1+x)^{25}\\right)^3 \\left((1+x)^5\\right)^1 (1+x)^3$$\n使用同余式 $(1+x)^{5^j} \\equiv 1+x^{5^j} \\pmod{5}$，我们可以将此表达式模 5 进行化简：\n$$(1+x)^{83} \\equiv (1+x^{25})^3 (1+x^5)^1 (1+x)^3 \\pmod{5}$$\n我们现在需要求右侧展开式中 $x^{27}$ 的系数。我们用二项式定理展开每个因子：\n\\begin{itemize}\n    \\item $(1+x^{25})^3 = \\sum_{i_2=0}^{3} \\binom{3}{i_2} (x^{25})^{i_2} = \\binom{3}{0} + \\binom{3}{1}x^{25} + \\binom{3}{2}x^{50} + \\binom{3}{3}x^{75}$\n    \\item $(1+x^5)^1 = \\sum_{i_1=0}^{1} \\binom{1}{i_1} (x^5)^{i_1} = \\binom{1}{0} + \\binom{1}{1}x^5$\n    \\item $(1+x)^3 = \\sum_{i_0=0}^{3} \\binom{3}{i_0} x^{i_0} = \\binom{3}{0} + \\binom{3}{1}x + \\binom{3}{2}x^2 + \\binom{3}{3}x^3$\n\\end{itemize}\n这三个多项式展开式乘积中的一个通项，是由从每个展开式中选取一项构成的。这样的项具有以下形式：\n$$\\left( \\binom{3}{i_2} x^{25 i_2} \\right) \\left( \\binom{1}{i_1} x^{5 i_1} \\right) \\left( \\binom{3}{i_0} x^{i_0} \\right) = \\binom{3}{i_2} \\binom{1}{i_1} \\binom{3}{i_0} x^{25 i_2 + 5 i_1 + i_0}$$\n其中指数必须在 $0 \\le i_2 \\le 3$，$0 \\le i_1 \\le 1$ 和 $0 \\le i_0 \\le 3$ 的范围内。\n\n我们在寻找 $x^{27}$ 的系数。这要求指数为 27：\n$$25 i_2 + 5 i_1 + i_0 = 27$$\n这个方程是数字 27 在 5 进制系统中的一种表示。因为一个整数在给定基数下的表示是唯一的，并且我们知道 $27 = 1 \\cdot 25 + 0 \\cdot 5 + 2$，所以满足 $0 \\le i_j  5$ 的唯一整数解是 $i_2=1$，$i_1=0$ 和 $i_0=2$。\n我们必须验证这个唯一解在二项式展开的指数约束下是有效的：\n\\begin{itemize}\n    \\item $i_2 = 1$ 在范围 $0 \\le i_2 \\le 3$ 内。\n    \\item $i_1 = 0$ 在范围 $0 \\le i_1 \\le 1$ 内。\n    \\item $i_0 = 2$ 在范围 $0 \\le i_0 \\le 3$ 内。\n\\end{itemize}\n所有约束都满足。因此，在乘积中只有一项组合能产生 $x^{27}$。$x^{27}$ 的系数是这些特定项的系数之积。这对应于与 $n=(n_2 n_1 n_0)_5$ 和 $k=(k_2 k_1 k_0)_5$ 的 5 进制数字相关联的二项式系数 $\\binom{n_j}{k_j}$ 的乘积。\n该系数为：\n$$C = \\binom{3}{1} \\binom{1}{0} \\binom{3}{2}$$\n我们计算每个二项式系数：\n$$\\binom{3}{1} = \\frac{3!}{1!(3-1)!} = 3$$\n$$\\binom{1}{0} = \\frac{1!}{0!(1-0)!} = 1$$\n$$\\binom{3}{2} = \\frac{3!}{2!(3-2)!} = \\frac{3 \\times 2}{2 \\times 1} = 3$$\n乘积为 $C = 3 \\times 1 \\times 3 = 9$。\n我们已经证明了 $\\binom{83}{27} \\equiv C \\pmod{5}$。现在我们求 $9$ 模 $5$ 的最小非负余数：\n$$9 = 1 \\times 5 + 4$$\n因此，$9 \\equiv 4 \\pmod{5}$。\n\n最终结果是 $\\binom{83}{27}$ 模 $5$ 的最小非负余数是 $4$。", "answer": "$$\\boxed{4}$$", "id": "3087050"}, {"introduction": "卢卡斯定理最直接的应用之一，是无需计算庞大的数值就能判断二项式系数 $\\binom{n}{k}$ 是否能被素数 $p$ 整除。本练习旨在通过系统地检验不同情况——当 $k$ 的 $p$-进制数位小于、大于或等于 $n$ 相应的数位时——来巩固你对这一定理核心思想的理解。这将帮助你掌握卢卡斯定理在数论问题中的预测能力。[@problem_id:3087022]", "problem": "设素数 $p=7$。对于整数 $n$ 和 $k$，其 $p$-进制展开式为 $n=\\sum_{i=0}^{r} n_i p^i$ 和 $k=\\sum_{i=0}^{r} k_i p^i$，其中每一位数字 $n_i,k_i\\in\\{0,1,\\dots,p-1\\}$。已知二项式系数 $\\binom{n}{k}$ 模 $p$ 的整除性反映了 $p$-进制数位 $k_i$ 和 $n_i$ 之间的逐位比较。仅使用 $p$-进制展开的基本定义、二项式系数的定义 $\\binom{n}{k}=\\dfrac{n!}{k!(n-k)!}$ 以及关于素数模的模算术的标准性质，分析以下三个在素数 $p=7$ 下的二项式系数，以说明逐位条件 $k_i\\le n_i$ 对于 $\\binom{n}{k}\\not\\equiv 0 \\pmod{p}$ 的充分性和必要性，并检验某些 $k_i=n_i$ 的边界情况。\n\n1. 设 $n_1=124$ 和 $k_1=60$。将 $n_1$ 和 $k_1$ 表示为 $7$-进制，比较对应的数位，并确定 $\\binom{n_1}{k_1}$ 模7的余数。\n\n2. 设 $n_2=66$ 和 $k_2=61$。将 $n_2$ 和 $k_2$ 表示为 $7$-进制，比较对应的数位，并确定 $\\binom{n_2}{k_2}$ 模7的余数。\n\n3. 设 $n_3=137$ 和 $k_3=116$。将 $n_3$ 和 $k_3$ 表示为 $7$-进制，比较对应的数位，并确定 $\\binom{n_3}{k_3}$ 模7的余数，特别注意 $k_i=n_i$ 的位置。\n\n最后，定义 $R$ 为集合 $\\{0,1,2,3,4,5,6\\}$ 中与\n$$\\binom{n_1}{k_1}+\\binom{n_2}{k_2}+\\binom{n_3}{k_3}\\pmod{7}$$\n同余的唯一整数。计算 $R$。你的最终答案必须是一个不带单位的整数。", "solution": "题目要求分析三个二项式系数模素数 $p=7$ 的值。如题目所述，核心原理是对于一个素数 $p$，二项式系数 $\\binom{n}{k}$ 模 $p$ 的值由 $n$ 和 $k$ 的 $p$-进制展开式决定。设 $p$-进制展开式为 $n = \\sum_{i=0}^{r} n_i p^i$ 和 $k = \\sum_{i=0}^{r} k_i p^i$，其中 $0 \\le n_i, k_i  p$。相关的定理，即卢卡斯定理，表明\n$$ \\binom{n}{k} \\equiv \\prod_{i=0}^{r} \\binom{n_i}{k_i} \\pmod{p} $$\n该定理的一个直接推论是 $\\binom{n}{k} \\not\\equiv 0 \\pmod{p}$ 当且仅当对所有 $i$ 都有 $\\binom{n_i}{k_i} \\not\\equiv 0 \\pmod{p}$。由于 $n_i$ 和 $k_i$ 是小于素数 $p$ 的数字，项 $\\binom{n_i}{k_i}$ 非零当且仅当 $k_i \\le n_i$。因此，$\\binom{n}{k} \\not\\equiv 0 \\pmod{p}$ 当且仅当对所有 $i$ 都有 $k_i \\le n_i$。我们将使用这个原理来分析 $p=7$ 的每一种情况。\n\n首先，我们分析 $n_1=124$ 和 $k_1=60$ 的情况。\n为了找到 $n_1=124$ 的 $7$-进制展开式，我们连续除以7：\n$124 = 17 \\times 7 + 5$\n$17 = 2 \\times 7 + 3$\n$2 = 0 \\times 7 + 2$\n从下往上读取余数，我们得到 $n_1 = (235)_7$。所以，$n_1 = 2 \\cdot 7^2 + 3 \\cdot 7^1 + 5 \\cdot 7^0$。其数位为 $n_{1,2}=2$，$n_{1,1}=3$ 和 $n_{1,0}=5$。\n接着，对于 $k_1=60$：\n$60 = 8 \\times 7 + 4$\n$8 = 1 \\times 7 + 1$\n$1 = 0 \\times 7 + 1$\n所以，$k_1 = (114)_7$。其数位为 $k_{1,2}=1$，$k_{1,1}=1$ 和 $k_{1,0}=4$。\n我们比较数位：$k_{1,2}=1 \\le n_{1,2}=2$，$k_{1,1}=1 \\le n_{1,1}=3$ 以及 $k_{1,0}=4 \\le n_{1,0}=5$。因为对所有 $i$ 都有 $k_{1,i} \\le n_{1,i}$，我们预期 $\\binom{124}{60} \\not\\equiv 0 \\pmod{7}$。应用卢卡斯定理：\n$$ \\binom{124}{60} \\equiv \\binom{2}{1} \\binom{3}{1} \\binom{5}{4} \\pmod{7} $$\n$$ \\binom{124}{60} \\equiv (2)(3)(5) = 30 \\pmod{7} $$\n由于 $30 = 4 \\times 7 + 2$，我们有 $\\binom{124}{60} \\equiv 2 \\pmod{7}$。这说明了该条件的充分性。\n\n其次，我们分析 $n_2=66$ 和 $k_2=61$ 的情况。\n对于 $n_2=66$：\n$66 = 9 \\times 7 + 3$\n$9 = 1 \\times 7 + 2$\n$1 = 0 \\times 7 + 1$\n所以，$n_2 = (123)_7$。其数位为 $n_{2,2}=1$，$n_{2,1}=2$ 和 $n_{2,0}=3$。\n对于 $k_2=61$：\n$61 = 8 \\times 7 + 5$\n$8 = 1 \\times 7 + 1$\n$1 = 0 \\times 7 + 1$\n所以，$k_2 = (115)_7$。其数位为 $k_{2,2}=1$，$k_{2,1}=1$ 和 $k_{2,0}=5$。\n我们比较数位：$k_{2,2}=1 \\le n_{2,2}=1$，$k_{2,1}=1 \\le n_{2,1}=2$，但是 $k_{2,0}=5 > n_{2,0}=3$。因为存在一个索引 $i=0$，使得条件 $k_{2,i} \\le n_{2,i}$ 不成立，我们预期 $\\binom{66}{61} \\equiv 0 \\pmod{7}$。应用卢卡斯定理：\n$$ \\binom{66}{61} \\equiv \\binom{1}{1} \\binom{2}{1} \\binom{3}{5} \\pmod{7} $$\n由于 $3  5$，系数 $\\binom{3}{5} = \\frac{3!}{5!(-2)!}$ 定义为 $0$。因此：\n$$ \\binom{66}{61} \\equiv (1)(2)(0) = 0 \\pmod{7} $$\n这说明了该条件的必要性：如果对任何一个数位不成立，那么二项式系数就能被该素数整除。\n\n第三，我们分析 $n_3=137$ 和 $k_3=116$ 的情况，这可以检验边界条件。\n对于 $n_3=137$：\n$137 = 19 \\times 7 + 4$\n$19 = 2 \\times 7 + 5$\n$2 = 0 \\times 7 + 2$\n所以，$n_3 = (254)_7$。其数位为 $n_{3,2}=2$，$n_{3,1}=5$ 和 $n_{3,0}=4$。\n对于 $k_3=116$：\n$116 = 16 \\times 7 + 4$\n$16 = 2 \\times 7 + 2$\n$2 = 0 \\times 7 + 2$\n所以，$k_3 = (224)_7$。其数位为 $k_{3,2}=2$，$k_{3,1}=2$ 和 $k_{3,0}=4$。\n我们比较数位：$k_{3,2}=2 \\le n_{3,2}=2$，$k_{3,1}=2 \\le n_{3,1}=5$ 以及 $k_{3,0}=4 \\le n_{3,0}=4$。该条件对所有数位都成立，包括两个 $k_i=n_i$ 的位置。我们预期一个非零结果。\n$$ \\binom{137}{116} \\equiv \\binom{2}{2} \\binom{5}{2} \\binom{4}{4} \\pmod{7} $$\n我们计算各个系数：$\\binom{2}{2}=1$，$\\binom{5}{2} = \\frac{5 \\cdot 4}{2 \\cdot 1} = 10$，以及 $\\binom{4}{4}=1$。\n$$ \\binom{137}{116} \\equiv (1)(10)(1) = 10 \\pmod{7} $$\n由于 $10 = 1 \\times 7 + 3$，我们有 $\\binom{137}{116} \\equiv 3 \\pmod{7}$。这表明边界情况 $k_i=n_i$ 贡献一个因子 $\\binom{n_i}{n_i}=1$，并不会导致总结果为零。\n\n最后，我们计算 $R$ 的值。\n$R$ 被定义为在集合 $\\{0,1,2,3,4,5,6\\}$ 中与三个余数之和模7同余的唯一整数。\n$$ R \\equiv \\left(\\binom{n_1}{k_1} + \\binom{n_2}{k_2} + \\binom{n_3}{k_3}\\right) \\pmod{7} $$\n代入我们计算出的值：\n$$ R \\equiv (2 + 0 + 3) \\pmod{7} $$\n$$ R \\equiv 5 \\pmod{7} $$\n指定集合中的唯一整数是 $5$。", "answer": "$$\\boxed{5}$$", "id": "3087022"}, {"introduction": "将理论知识转化为实际的计算能力是学习数学的关键一步。最后一个练习将挑战你综合所学，设计一个通用算法来计算 $\\binom{n}{k} \\pmod p$。这个过程不仅能巩固你对卢卡斯定理逻辑的理解，还能将抽象的数学洞察力转化为一个强大的计算工具。[@problem_id:3087055]", "problem": "设计并实现一个程序，给定整数 $n$, $k$ 和一个素数 $p$，通过将 $n$ 和 $k$ 分解为其 $p$-进制数位并组合相应数位的贡献，来计算二项式系数 $ \\binom{n}{k} $ 模 $p$ 的余数。你的解法应从基本原理推导得出，从模算术、二项式系数的定义以及整数的 $p$-进制展开开始。除了模算术和素性的性质等被广泛接受的数论事实外，你的推导不得假设任何专门的定理。\n\n你的算法设计应：\n- 从 $p$-进制表示 $n = \\sum_{i \\ge 0} n_i p^i$ 和 $k = \\sum_{i \\ge 0} k_i p^i$ 开始，其中数位 $0 \\le n_i, k_i  p$。\n- 仅使用源于二项式系数定义、素数模的模算术性质以及二项式展开的性质，来证明一种按数位分解的方法是合理的，该方法将 $\\binom{n}{k} \\pmod p$ 的计算简化为仅依赖于数位对 $(n_i,k_i)$ 的项的乘积。\n- 描述如何对于 $0 \\le a,b  p$ 的情况，使用模 $p$ 的乘法逆元高效地计算每个数位级别的二项式系数 $\\binom{a}{b} \\pmod p$，并通过一个当 $p$ 是素数时成立的性质来证明其合理性。清楚地说明如何处理 $b  a$ 的情况。\n\n实现要求：\n- 根据你的推导实现一个计算 $\\binom{n}{k} \\pmod p$ 的函数。\n- 程序必须是自包含的，且不得读取任何输入；它应执行一个固定的测试套件并打印结果。\n- 所有答案均为整数。\n\n测试套件：\n在以下参数三元组 $(n,k,p)$ 上评估你的程序：\n- $(123,58,7)$\n- $(100,35,13)$\n- $(12345,0,101)$\n- $(50,60,5)$\n- $(10,6,3)$\n- $(29,13,2)$\n- $(10,3,101)$\n\n最终输出格式：\n- 你的程序应产生单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表，其顺序与测试套件相同（例如 $[r_1,r_2,\\dots]$）。不应打印任何额外文本。", "solution": "问题是计算二项式系数 $\\binom{n}{k}$ 模一个素数 $p$ 的值。推导将从第一性原理出发，具体来说是利用有限域 $\\mathbb{Z}_p$ 上多项式的性质，来建立一个按数位计算的公式。这个结果被称为卢卡斯定理。\n\n我们的出发点是二项式定理，该定理指出 $\\binom{n}{k}$ 是 $(1+x)^n$ 多项式展开式中 $x^k$ 项的系数：\n$$ (1+x)^n = \\sum_{i=0}^{n} \\binom{n}{i} x^i $$\n我们希望求出这个系数模 $p$ 的值。这等价于求多项式 $(1+x)^n$ 中 $x^k$ 的系数，其中系数被视为有限域 $\\mathbb{Z}_p$ 中的元素。\n\n首先，我们建立 $\\mathbb{Z}_p[x]$ 中多项式的一个基本性质。对于一个素数 $p$，我们有以下同余式：\n$$ (a+b)^p \\equiv a^p + b^p \\pmod{p} $$\n这可以从 $(a+b)^p$ 的二项式展开式看出：\n$$ (a+b)^p = \\sum_{i=0}^{p} \\binom{p}{i} a^{p-i} b^i = \\binom{p}{0}a^p + \\binom{p}{1}a^{p-1}b + \\dots + \\binom{p}{p-1}ab^{p-1} + \\binom{p}{p}b^p $$\n两端的系数是 $\\binom{p}{0}=1$ 和 $\\binom{p}{p}=1$。对于任何满足 $1 \\le i \\le p-1$ 的中间整数 $i$，二项式系数由 $\\binom{p}{i} = \\frac{p!}{i!(p-i)!}$ 给出。由于 $p$ 是素数，分子 $p!$ 可以被 $p$ 整除。分母 $i!(p-i)!$ 不能被 $p$ 整除，因为它的所有素因子都小于 $p$。因此，对于 $1 \\le i \\le p-1$，$\\binom{p}{i}$ 是 $p$ 的整数倍。这意味着：\n$$ \\binom{p}{i} \\equiv 0 \\pmod{p} \\quad \\text{for } 1 \\le i \\le p-1 $$\n因此，展开式中的所有中间项在模 $p$ 意义下都为零，只剩下 $(a+b)^p \\equiv a^p + b^p \\pmod{p}$。\n通过重复应用此性质，它可以推广到 $p$ 的幂。对于任何整数 $j \\ge 1$：\n$$ (a+b)^{p^j} \\equiv (a^{p^{j-1}} + b^{p^{j-1}})^p \\equiv (a^{p^{j-1}})^p + (b^{p^{j-1}})^p \\equiv a^{p^j} + b^{p^j} \\pmod{p} $$\n令 $a=1$ 和 $b=x$，我们得到关于多项式 $(1+x)^n$ 的一个关键恒等式：\n$$ (1+x)^{p^j} \\equiv 1 + x^{p^j} \\pmod{p} $$\n\n现在，我们将整数 $n$ 表示为其 $p$-进制形式：\n$$ n = \\sum_{i=0}^{m} n_i p^i = n_m p^m + \\dots + n_1 p + n_0 $$\n其中 $0 \\le n_i  p$ 是 $n$ 在 $p$-进制下的数位。\n我们现在可以按如下方式将多项式 $(1+x)^n$ 模 $p$ 分解：\n$$ (1+x)^n = (1+x)^{\\sum_{i=0}^{m} n_i p^i} = \\prod_{i=0}^{m} (1+x)^{n_i p^i} = \\prod_{i=0}^{m} \\left((1+x)^{p^i}\\right)^{n_i} $$\n应用我们推导出的同余式：\n$$ (1+x)^n \\equiv \\prod_{i=0}^{m} (1+x^{p^i})^{n_i} \\pmod{p} $$\n根据二项式定理，乘积中的每一项可以展开为：\n$$ (1+x^{p^i})^{n_i} = \\sum_{j=0}^{n_i} \\binom{n_i}{j} (x^{p^i})^j = \\sum_{j=0}^{n_i} \\binom{n_i}{j} x^{j \\cdot p^i} $$\n由于 $0 \\le n_i  p$，系数 $\\binom{n_i}{j}$ 先验地是整数。我们关心的是它们模 $p$ 的值。\n$(1+x)^n$ 模 $p$ 的完整表达式为：\n$$ (1+x)^n \\equiv \\prod_{i=0}^{m} \\left( \\sum_{k_i=0}^{n_i} \\binom{n_i}{k_i} x^{k_i p^i} \\right) \\pmod{p} $$\n我们要找的是 $x^k$ 的系数。我们也将 $k$ 表示为其 $p$-进制形式，位数与 $n$ 相同（必要时用前导零填充）：\n$$ k = \\sum_{i=0}^{m} k_i p^i = k_m p^m + \\dots + k_1 p + k_0 $$\n其中 $0 \\le k_i  p$。\n当我们展开这个和的乘积时，一个通用项是通过从乘积中的每个和式中选择一项来构成的：\n$$ \\left( \\binom{n_0}{k_0} x^{k_0 p^0} \\right) \\left( \\binom{n_1}{k_1} x^{k_1 p^1} \\right) \\dots \\left( \\binom{n_m}{k_m} x^{k_m p^m} \\right) = \\left( \\prod_{i=0}^{m} \\binom{n_i}{k_i} \\right) x^{\\sum_{i=0}^{m} k_i p^i} $$\n这个通用项中 $x$ 的指数是 $\\sum_{i=0}^{m} k_i p^i$。由于 $0 \\le k_i  p$，这是某个整数唯一的 $p$-进制表示。要使这个指数等于 $k$，我们必须匹配各个数位，即，和式中每一项的索引 $k_i$ 必须等于 $k$ 的第 $i$ 个数位。\n因此，$(1+x)^n$ 模 $p$ 展开式中 $x^k$ 的系数是各部分系数的乘积，其中项的选择对应于 $k$ 的数位。这就得出了最终结果：\n$$ \\binom{n}{k} \\equiv \\prod_{i=0}^{m} \\binom{n_i}{k_i} \\pmod{p} $$\n\n算法思路是遍历 $n$ 和 $k$ 的 $p$-进制数位，对每一对数位 $(n_i, k_i)$ 计算 $\\binom{n_i}{k_i} \\pmod{p}$，然后将这些结果在模 $p$ 意义下相乘。\n\n要为数位 $0 \\le a,b  p$ 计算 $\\binom{a}{b} \\pmod{p}$：\n1.  如果 $b > a$，二项式系数 $\\binom{a}{b}$ 定义为 $0$。这是合理的，因为不可能从一个包含 $a$ 个元素的集合中选择 $b$ 个元素。\n2.  如果 $b \\le a$，我们有 $\\binom{a}{b} = \\frac{a!}{b!(a-b)!}$。为了计算模 $p$ 的值，我们不能直接进行除法。相反，我们使用模乘法逆元。\n    $$ \\binom{a}{b} \\equiv a! \\cdot (b!)^{-1} \\cdot ((a-b)! )^{-1} \\pmod{p} $$\n    一个整数 $x$ 模一个素数 $p$ 的乘法逆元存在的充要条件是 $x$ 不是 $p$ 的倍数。由于 $b \\le a  p$，$b!$ 和 $(a-b)!$ 中的所有因子都小于 $p$，因此不能被 $p$ 整除。因此，阶乘本身不能被 $p$ 整除，它们的逆元存在。\n    根据费马小定理，对于任何不能被素数 $p$ 整除的整数 $x$，我们有 $x^{p-1} \\equiv 1 \\pmod{p}$。这意味着模逆元是 $x^{-1} \\equiv x^{p-2} \\pmod{p}$。这可以使用模幂运算（二进制取幂）高效地计算。\n    一种更直接的计算方法是：\n    $$ \\binom{a}{b} = \\frac{a \\cdot (a-1) \\cdots (a-b+1)}{b \\cdot (b-1) \\cdots 1} \\equiv \\left( \\prod_{i=0}^{b-1} (a-i) \\right) \\cdot \\left( \\left( \\prod_{i=1}^{b} i \\right)^{-1} \\right) \\pmod{p} $$\n    这避免了计算大的阶乘。\n\n整体算法如下：\n1.  初始化一个结果变量为 $1$。\n2.  如果 $k > n$，返回 $0$。\n3.  当 $n > 0$ 时循环：\n    a. 提取 $n$ 和 $k$ 在 $p$-进制下的最低有效位：$n_i = n \\pmod p$ 和 $k_i = k \\pmod p$。\n    b. 计算 $c = \\binom{n_i}{k_i} \\pmod p$。如果 $k_i > n_i$，$c=0$，最终的乘积将为 $0$。\n    c. 更新结果：`result = (result * c) % p`。\n    d. 通过整除移除最低有效位：$n = n // p$ 和 $k = k // p$。\n4.  返回最终结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Computes binomial coefficients modulo a prime for a suite of test cases\n    based on a first-principles derivation of Lucas's theorem.\n    \"\"\"\n\n    # === Helper Functions ===\n\n    def mod_inverse(n, modulus):\n        \"\"\"\n        Computes the modular multiplicative inverse of n modulo modulus.\n        It is assumed that modulus is a prime number.\n        The inverse is computed using Fermat's Little Theorem: n^(p-2) mod p.\n        \"\"\"\n        return pow(n, modulus - 2, modulus)\n\n    def small_binom_mod_p(n, k, p):\n        \"\"\"\n        Computes C(n, k) mod p for 0 = n, k  p.\n        p is assumed to be a prime number.\n        \"\"\"\n        # C(n, k) = 0 if k > n\n        if k  0 or k > n:\n            return 0\n        \n        # C(n, 0) = 1, C(n, n) = 1\n        if k == 0 or k == n:\n            return 1\n        \n        # Use symmetry C(n, k) = C(n, n-k) to minimize calculations\n        if k > n // 2:\n            k = n - k\n\n        # Calculate numerator: n * (n-1) * ... * (n-k+1) mod p\n        numerator = 1\n        for i in range(k):\n            numerator = (numerator * (n - i)) % p\n\n        # Calculate denominator: k! mod p\n        denominator = 1\n        for i in range(1, k + 1):\n            denominator = (denominator * i) % p\n\n        # Result is numerator * (denominator)^(-1) mod p\n        return (numerator * mod_inverse(denominator, p)) % p\n\n    def lucas_theorem_binom(n, k, p):\n        \"\"\"\n        Computes C(n, k) mod p using Lucas's theorem.\n        n, k are non-negative integers, p is a prime number.\n        \"\"\"\n        # Base case: if k is negative or larger than n, C(n, k) is 0.\n        if k  0 or k > n:\n            return 0\n        \n        # If p is not a prime, or n, k are small, this might not be the best method,\n        # but problem statement guarantees p is prime.\n\n        result = 1\n        # Loop until both n and k are 0\n        while n > 0 or k > 0:\n            ni = n % p\n            ki = k % p\n\n            # Compute C(ni, ki) mod p\n            term = small_binom_mod_p(ni, ki, p)\n            \n            # If any term is 0, the whole product is 0.\n            if term == 0:\n                return 0\n\n            result = (result * term) % p\n            \n            # Move to the next digits\n            n //= p\n            k //= p\n            \n        return result\n\n    # === Test Suite Execution ===\n\n    test_cases = [\n        (123, 58, 7),\n        (100, 35, 13),\n        (12345, 0, 101),\n        (50, 60, 5),\n        (10, 6, 3),\n        (29, 13, 2),\n        (10, 3, 101),\n    ]\n\n    results = []\n    for n, k, p in test_cases:\n        res = lucas_theorem_binom(n, k, p)\n        results.append(res)\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3087055"}]}