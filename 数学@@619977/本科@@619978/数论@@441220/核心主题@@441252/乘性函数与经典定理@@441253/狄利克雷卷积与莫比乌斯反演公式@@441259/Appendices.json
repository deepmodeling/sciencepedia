{"hands_on_practices": [{"introduction": "我们的第一个练习直击狄利克雷逆元的核心。我们将仅使用基本定义，一步步地计算一个特殊构造函数的逆元。这个练习 [@problem_id:3081462] 将强化你对逆元计算的递归性质的理解，并揭示一个关键点：一个函数并不需要是积性的才拥有逆元。", "problem": "考虑算术函数 $f:\\mathbb{N}\\to\\mathbb{C}$，其定义为 $f(1)=1$，$f(2)=3$，$f(3)=0$，且对所有 $n\\ge 4$ 有 $f(n)=1$。对于算术函数 $f$ 和 $g$，狄利克雷卷积 $(f*g):\\mathbb{N}\\to\\mathbb{C}$ 定义为 $(f*g)(n)=\\sum_{d\\mid n} f(d)\\,g\\!\\left(\\frac{n}{d}\\right)$。狄利克雷卷积的单位元 $\\varepsilon$ 定义为 $\\varepsilon(1)=1$ 且对所有 $n>1$ 有 $\\varepsilon(n)=0$。\n\n- 首先，通过明确指出存在互质整数 $m$ 和 $n$ 使得 $f(mn)\\ne f(m)f(n)$，来验证 $f$ 不是积性函数。\n\n- 仅使用狄利克雷卷积的定义和单位元 $\\varepsilon$，证明存在唯一的算术函数 $g$ 使得 $f*g=\\varepsilon$，并导出一个递推关系，该关系能以递归方式计算 $g(n)$。", "solution": "我们从定义开始。一个算术函数 $f$ 是积性函数，如果对所有互质的 $m,n\\in\\mathbb{N}$，都有 $f(mn)=f(m)f(n)$。对于给定的 $f$，取 $m=2$ 和 $n=3$，它们是互质的。那么 $f(2)=3$，$f(3)=0$，并且由于 $6\\ge 4$，$f(6)=1$。因此 $f(2)f(3)=3\\cdot 0=0$ 而 $f(6)=1$，所以 $f(6)\\ne f(2)f(3)$，故 $f$ 不是积性函数。\n\n接下来，我们使用狄利克雷卷积及其单位元的定义。根据定义，$g$ 是 $f$ 的狄利克雷逆，当且仅当对所有 $n\\in\\mathbb{N}$ 都有\n$$\n(f*g)(n)=\\sum_{d\\mid n} f(d)\\,g\\!\\left(\\frac{n}{d}\\right)=\\varepsilon(n)\n$$\n其中 $\\varepsilon(1)=1$ 且对 $n>1$ 有 $\\varepsilon(n)=0$。\n\n我们导出一个递推关系，以递归地计算 $g(n)$。我们将和式中对应于 $d=1$ 的项分离出来：\n$$\nf(1)g(n) + \\sum_{d\\mid n, d>1} f(d)\\,g\\!\\left(\\frac{n}{d}\\right)=\\varepsilon(n)\n$$\n由于 $f(1)=1$，我们可以解出 $g(n)$：\n$$\ng(n) = \\varepsilon(n) - \\sum_{d\\mid n, d>1} f(d)\\,g\\!\\left(\\frac{n}{d}\\right)\n$$\n对于 $n>1$，$\\varepsilon(n)=0$，所以递推关系简化为\n$$\ng(n) = -\\sum_{d\\mid n, d>1} f(d)\\,g\\!\\left(\\frac{n}{d}\\right)\n$$\n这个公式表明，$g(n)$ 的值可以由 $g(k)$ 的值（其中 $k=n/d<n$）唯一确定。这证明了 $g$ 的存在性和唯一性。\n\n现在我们计算 $g(n)$ 的前六个值：\n$g(1) = \\varepsilon(1) = 1$\n$g(2) = -f(2)g(1) = -3\\cdot 1 = -3$\n$g(3) = -f(3)g(1) = -0\\cdot 1 = 0$\n$g(4) = -\\big(f(2)g(2) + f(4)g(1)\\big) = -\\big(3(-3)+1(1)\\big) = -(-9+1) = 8$\n$g(5) = -f(5)g(1) = -1\\cdot 1 = -1$\n$g(6) = -\\big(f(2)g(3) + f(3)g(2) + f(6)g(1)\\big) = -\\big(3(0)+0(-3)+1(1)\\big) = -1$\n\n这给出了前六个值 $(1, -3, 0, 8, -1, -1)$。", "answer": "$$\\boxed{\\begin{pmatrix}1  -3  0  8  -1  -1\\end{pmatrix}}$$", "id": "3081462"}, {"introduction": "现在我们已经熟悉了基本计算方法，让我们将莫比乌斯反演应用于一个经典问题。从简单的函数 $F(n)=n$ 出发，通过探寻哪个函数 $f(n)$ 在除数和下能生成它，我们将揭示数论中最重要的函数之一。这个练习 [@problem_id:3081485] 不仅展示了反演的威力，还将其与群论中一个优美的组合解释联系起来。", "problem": "设 $f$ 和 $F$ 为正整数上的算术函数，它们通过除数和恒等式\n$$\nF(n)=\\sum_{d\\mid n} f(d)\\quad\\text{for every positive integer }n.\n$$\n相关联。\n假设对于每个正整数 $n$，$F(n)=n$。请从基本原理出发，推导出用 $F$ 和除数和的基本性质表示的 $f(n)$ 的显式表达式。然后，计算 $f(n)$ 在 $1\\le n\\le 20$ 时的值。最后，在您选择的、与关系式 $F(n)=\\sum_{d\\mid n} f(d)$ 及 $F(n)=n$ 一致的组合模型中解释所得的值（例如，通过计算有限循环群中指定阶的元素数量）。请将 $(f(1),f(2),\\dots,f(20))$ 的最终数值答案以单行向量的形式给出。无需四舍五入，您必须给出精确整数。", "solution": "该问题通过除数和恒等式将两个算术函数 $f$ 和 $F$ 联系起来：\n$$\nF(n) = \\sum_{d \\mid n} f(d)\n$$\n对于每个正整数 $n$。这个和是函数 $f$ 和常数函数 $\\mathbf{1}$ 的狄利克雷卷积，其中 $\\mathbf{1}$ 定义为对所有 $k \\in \\mathbb{Z}^+$ 都有 $\\mathbf{1}(k)=1$。用这种记法，该恒等式写作 $F = f * \\mathbf{1}$。\n\n问题陈述 $F(n)=n$ 对所有 $n$ 成立。令 $\\mathrm{id}$ 表示恒等函数，$\\mathrm{id}(n)=n$。因此，给定的关系是 $\\mathrm{id} = f * \\mathbf{1}$。我们的目标是找到 $f(n)$ 的一个显式表达式。\n\n为此，我们使用莫比乌斯反演公式，该公式提供了一种用 $F$ 表示 $f$ 的方法。该公式依赖于莫比乌斯函数 $\\mu(n)$，它是常数函数 $\\mathbf{1}$ 的狄利克雷逆。逆的定义性质是 $(\\mathbf{1} * \\mu)(n) = (\\mu * \\mathbf{1})(n) = \\epsilon(n)$，其中 $\\epsilon$ 是狄利克雷卷积的单位元，定义为 $\\epsilon(1)=1$ 且当 $n>1$ 时 $\\epsilon(n)=0$。莫比乌斯函数 $\\mu(n)$ 对正整数 $n$ 的定义如下：\n$$\n\\mu(n) = \\begin{cases}\n1  \\text{如果 } n=1 \\\\\n(-1)^k  \\text{如果 } n \\text{ 是 } k \\text{ 个不同素数的乘积} \\\\\n0  \\text{如果 } n \\text{ 有平方素因子}\n\\end{cases}\n$$\n性质 $\\sum_{d \\mid n} \\mu(d) = \\epsilon(n)$ 是数论中的一个基本结果。\n\n为了从基本原理推导 $f(n)$ 的表达式，我们从给定关系 $\\mathrm{id} = f * \\mathbf{1}$ 开始，并将两边与莫比乌斯函数 $\\mu$ 进行卷积：\n$$\n\\mathrm{id} * \\mu = (f * \\mathbf{1}) * \\mu\n$$\n狄利克雷卷积满足结合律，所以我们可以重组右边的项：\n$$\n\\mathrm{id} * \\mu = f * (\\mathbf{1} * \\mu)\n$$\n根据 $\\mu$ 作为 $\\mathbf{1}$ 的逆的定义，我们有 $\\mathbf{1} * \\mu = \\epsilon$。将此代入方程得到：\n$$\n\\mathrm{id} * \\mu = f * \\epsilon\n$$\n函数 $\\epsilon$ 是卷积的单位元，意味着对于任何算术函数 $g$，都有 $g * \\epsilon = g$。因此，$f * \\epsilon = f$。这就得出了 $f$ 的所求表达式：\n$$\nf = \\mathrm{id} * \\mu\n$$\n将其写成和的形式，我们得到 $f(n)$ 的显式公式：\n$$\nf(n) = (\\mathrm{id} * \\mu)(n) = \\sum_{d \\mid n} \\mathrm{id}(d) \\mu\\left(\\frac{n}{d}\\right)\n$$\n由于 $\\mathrm{id}(d)=d$，表达式为：\n$$\nf(n) = \\sum_{d \\mid n} d \\mu\\left(\\frac{n}{d}\\right)\n$$\n这个表达式是著名的欧拉函数 $\\phi(n)$ 的公式，它计算的是小于等于 $n$ 且与 $n$ 互质的正整数的个数。因此，我们证明了 $f(n) = \\phi(n)$。\n\n接下来，我们需要提供一个组合解释。我们考虑 $n$ 阶有限循环群，记作 $C_n$。该群中的元素总数为 $|C_n|=n$。我们设 $F(n) = |C_n| = n$，这与问题陈述一致。$C_n$ 中任何元素的阶都必须是 $n$ 的一个因子 $d$。我们可以将群 $C_n$ 分割成不相交的子集，其中每个子集包含所有特定阶 $d$ 的元素。如果我们令 $f(d)$ 表示群 $C_n$ 中阶为 $d$ 的元素数量，那么群中的总元素数就是这些子集大小的和：\n$$\n|C_n| = \\sum_{d \\mid n} (\\text{阶为 } d \\text{ 的元素数量})\n$$\n代入我们的函数记法，这就变成了 $F(n) = \\sum_{d \\mid n} f(d)$，这与给定的关系完全匹配。在这个模型中，函数 $f(n)$ 代表群 $C_n$ 中阶为 $n$ 的元素数量。这些恰好是群的生成元。群论的一个基本定理指出，$n$ 阶循环群的生成元数量由欧拉函数 $\\phi(n)$ 给出。因此，这个组合模型证实了我们的发现，即 $f(n)=\\phi(n)$。\n\n最后，我们计算 $f(n) = \\phi(n)$ 在 $1 \\le n \\le 20$ 时的值。我们使用公式 $\\phi(n) = n \\prod_{p|n} (1 - 1/p)$，其中乘积是对 $n$ 的所有不同素因子进行的。\n$f(1) = \\phi(1) = 1$\n$f(2) = \\phi(2) = 2(1 - 1/2) = 1$\n$f(3) = \\phi(3) = 3(1 - 1/3) = 2$\n$f(4) = \\phi(4) = 4(1 - 1/2) = 2$\n$f(5) = \\phi(5) = 5(1 - 1/5) = 4$\n$f(6) = \\phi(6) = 6(1 - 1/2)(1 - 1/3) = 2$\n$f(7) = \\phi(7) = 7(1 - 1/7) = 6$\n$f(8) = \\phi(8) = 8(1 - 1/2) = 4$\n$f(9) = \\phi(9) = 9(1 - 1/3) = 6$\n$f(10) = \\phi(10) = 10(1 - 1/2)(1 - 1/5) = 4$\n$f(11) = \\phi(11) = 11(1 - 1/11) = 10$\n$f(12) = \\phi(12) = 12(1 - 1/2)(1 - 1/3) = 4$\n$f(13) = \\phi(13) = 13(1 - 1/13) = 12$\n$f(14) = \\phi(14) = 14(1 - 1/2)(1 - 1/7) = 6$\n$f(15) = \\phi(15) = 15(1 - 1/3)(1 - 1/5) = 8$\n$f(16) = \\phi(16) = 16(1 - 1/2) = 8$\n$f(17) = \\phi(17) = 17(1 - 1/17) = 16$\n$f(18) = \\phi(18) = 18(1 - 1/2)(1 - 1/3) = 6$\n$f(19) = \\phi(19) = 19(1 - 1/19) = 18$\n$f(20) = \\phi(20) = 20(1 - 1/2)(1 - 1/5) = 8$\n\n$f(n)$ 对于 $n$ 从 $1$ 到 $20$ 的值序列为 $(1, 1, 2, 2, 4, 2, 6, 4, 6, 4, 10, 4, 12, 6, 8, 8, 16, 6, 18, 8)$。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n1  1  2  2  4  2  6  4  6  4  10  4  12  6  8  8  16  6  18  8\n\\end{pmatrix}\n}\n$$", "id": "3081485"}, {"introduction": "在我们的最后一个练习中，我们将在抽象数学和实际计算之间架起一座桥梁。你将把莫比乌斯反演的递归公式转化为一个可工作的计算机算法。这项任务 [@problem_id:3256582] 展示了理论数论如何为解决具体计算问题提供强大工具，并将从一个不同的角度巩固你对反演过程的理解。", "problem": "给定一个为正整数定义的算术函数 $g : \\mathbb{N} \\to \\mathbb{Z}$，它通过因数和关系 $g(n) = \\sum_{d \\mid n} f(d)$ 由一个未知的算术函数 $f : \\mathbb{N} \\to \\mathbb{Z}$ 定义。请利用积性数论和狄利克雷卷积理论中的基本概念，设计并实现一个算法，该算法能根据给定的 $g(1), g(2), \\ldots, g(N)$ 的有限值列表，精确计算出相应的列表 $f(1), f(2), \\ldots, f(N)$。\n\n您可以使用的基本原理包括：\n- $\\mathbb{N}$ 上因数和算术函数的定义。\n- 狄利克雷卷积的定义：对于算术函数 $a$ 和 $b$，$(a * b)(n) = \\sum_{d \\mid n} a(d)\\,b\\!\\left(\\frac{n}{d}\\right)$。\n- 存在一个积性函数，作为常数一函数在狄利克雷卷积下的逆元，该函数可由容斥原理导出。\n- 无平方因子数的性质以及质因数分解在定义积性函数中的结构性作用。\n\n您的程序必须为以下每个测试套件中的所有 $n$ 计算 $f(n)$，其中每个套件提供了 $g(n)$ 的具体值：\n- 测试套件 $1$：$N = 10$, $g(1..10) = [1,2,2,3,2,4,2,4,3,4]$。\n- 测试套件 $2$：$N = 12$, $g(1..12) = [1,2,3,4,5,6,7,8,9,10,11,12]$。\n- 测试套件 $3$：$N = 1$, $g(1..1) = [5]$。\n- 测试套件 $4$：$N = 15$, $g(1..15) = [0,0,-1,1,-1,1,-2,3,-4,2,-3,6,-4,2,-7]$。\n- 测试套件 $5$：$N = 16$, $g(1..16) = [3,2,7,2,1,7,3,7,4,0,5,6,3,2,12,3]$。\n\n测试覆盖的设计如下：\n- 测试套件 $1$ 提供了一个由统一的底层 $f(n)$ 产生的基线情况。\n- 测试套件 $2$ 检验了从数据中恢复一个隐含的经典积性函数的能力。\n- 测试套件 $3$ 是 $N=1$ 且值为非平凡的最小边界情况。\n- 测试套件 $4$ 在隐含的 $f(n)$ 中包含了混合符号和零，以测试鲁棒性。\n- 测试套件 $5$ 考察了从任意整数数据中恢复的能力。\n\n您的程序必须生成单行输出，包含一个用方括号括起来的逗号分隔列表，其中不含空格。外层列表的每个条目对应一个测试套件，并且必须是该套件的整数内层列表 $[f(1),f(2),\\ldots,f(N)]$。例如，格式必须严格为 $[[\\cdots],[\\cdots],\\ldots]$ 的形式，列表内使用逗号分隔，且不含任何空格。", "solution": "问题要求从一个相关的算术函数 $g$ 计算整数值算术函数 $f$。这两个函数的关系由因数和 $g(n) = \\sum_{d \\mid n} f(d)$ 给出，其中 $n=1, 2, \\ldots, N$。这是一个数论中的经典反演问题。\n\n$f$ 和 $g$ 之间的关系可以用狄利克雷卷积来正式表达。对于两个算术函数 $a, b: \\mathbb{N} \\to \\mathbb{Z}$，它们的狄利克雷卷积（记为 $(a * b)$）是一个算术函数，定义如下：\n$$ (a * b)(n) = \\sum_{d \\mid n} a(d) b\\left(\\frac{n}{d}\\right) $$\n设 $\\mathbf{1}$ 为常数算术函数，定义为对所有 $n \\in \\mathbb{N}$ 都有 $\\mathbf{1}(n) = 1$。给定的关系 $g(n) = \\sum_{d \\mid n} f(d)$ 可以重写为：\n$$ g(n) = \\sum_{d \\mid n} f(d) \\cdot 1 = \\sum_{d \\mid n} f(d) \\mathbf{1}\\left(\\frac{n}{d}\\right) = (f * \\mathbf{1})(n) $$\n因此，我们得到简洁的关系式 $g = f * \\mathbf{1}$。为了求出 $f$，我们需要“除以” $\\mathbf{1}$，这意味着将 $g$ 与 $\\mathbf{1}$ 的狄利克雷逆元作卷积。\n\n在狄利克雷卷积下，所有满足 $h(1) \\neq 0$ 的算术函数构成一个群。其单位元是函数 $\\epsilon$，定义为 $\\epsilon(1)=1$ 且对于 $n  1$ 有 $\\epsilon(n)=0$。$\\mathbf{1}$ 的逆元记为 $\\mu$，即莫比乌斯函数。其定义如下：\n$$ \\mu(n) = \\begin{cases} 1  \\text{如果 } n=1 \\\\ (-1)^k  \\text{如果 } n \\text{ 是 } k \\text{ 个不同素数的乘积（无平方因子）} \\\\ 0  \\text{如果 } n \\text{ 有平方素因子（非无平方因子）} \\end{cases} $$\n根据逆元的定义，$\\mathbf{1} * \\mu = \\epsilon$。将 $g = f * \\mathbf{1}$ 两边同时与 $\\mu$ 作卷积，可得：\n$$ g * \\mu = (f * \\mathbf{1}) * \\mu = f * (\\mathbf{1} * \\mu) = f * \\epsilon = f $$\n这就得到了著名的莫比乌斯反演公式：\n$$ f(n) = (g * \\mu)(n) = \\sum_{d \\mid n} g(d) \\mu\\left(\\frac{n}{d}\\right) $$\n虽然这个公式提供了一种计算 $f(n)$ 的方法，但它需要预先计算 $k=1, \\ldots, N$ 的莫比乌斯函数 $\\mu(k)$。\n\n对于给定的约束条件，一个更直接且计算上更简单的方法可以通过重新整理 $g(n)$ 的原始定义得到。我们可以从和式中分离出 $f(n)$ 项：\n$$ g(n) = \\sum_{d \\mid n} f(d) = f(n) + \\sum_{d \\mid n, d  n} f(d) $$\n这导出了一个计算 $f(n)$ 的递推公式：\n$$ f(n) = g(n) - \\sum_{d \\mid n, d  n} f(d) $$\n这个递推关系是我们算法的基础。它表明 $f(n)$ 可以由 $g(n)$ 的值以及 $n$ 的所有真因数 $d$ 对应的 $f(d)$ 的值确定。由于 $n$ 的每个真因数 $d$ 都满足 $d  n$，我们可以按顺序计算 $f$ 的值。\n\n算法流程如下：\n1.  初始化一个数组，例如 `f_values`，用于存储 $f(1), f(2), \\ldots, f(N)$ 的结果。\n2.  计算 $f(1)$：$1$ 的唯一因数是 $1$ 本身。对真因数的求和是空的（等于 $0$）。因此，$f(1) = g(1)$。\n3.  对 $n = 2, 3, \\ldots, N$ 进行迭代：\n    a.  为了计算 $f(n)$，首先计算和 $S_n = \\sum_{d \\mid n, d  n} f(d)$。\n    b.  这个求和所需的项 $f(d)$ 的索引满足 $d  n$，因此它们在之前的迭代步骤中已经被计算出来了。\n    c.  然后通过 $f(n) = g(n) - S_n$ 求出 $f(n)$ 的值。\n    d.  将这个值存储在 `f_values` 中。\n\n为了实现和 $S_n$ 的计算，我们可以遍历从 $1$ 到 $n-1$ 的所有整数 $d$，并检查 $d$ 是否是 $n$ 的因数。如果 $n \\pmod d = 0$，我们就将先前计算出的 $f(d)$ 的值加到一个累加和中。对于问题中的小 $N$ 值，这种方法的计算复杂度（大约为 $O(N^2)$）是完全可以接受的。\n鉴于输入格式中 $g$ 是从0开始索引的列表，我们将 $g_{\\text{list}}[i-1]$ 映射到 $g(i)$。为了方便实现，直接将数学符号映射到代码，使用从1开始索引的数组会很方便。", "answer": "[[1,1,1,1,1,1,1,1,1,1],[1,1,2,2,4,2,6,4,6,4,10,4],[5],[0,0,-1,1,-1,2,-2,2,-3,3,-3,4,-4,4,-5],[3,-1,4,0,-2,1,0,5,-3,0,2,-1,0,0,7,-4]]", "id": "3256582"}]}