{"hands_on_practices": [{"introduction": "学习莫比乌斯函数的第一步是牢固掌握其定义。本练习旨在通过对具体整数进行直接计算，来巩固你对该函数定义的理解。通过分解质因数并应用其三条核心规则，你将能够亲手算出$\\mu(n)$的值，这是后续更深入学习的基础。[@problem_id:3092142]", "problem": "设 $\\mu(n)$ 表示莫比乌斯函数，其中 $n$ 为正整数。仅使用给定整数的质因数分解以及由 $\\mu(n)$ 的定义直接得出的基本性质，确定当 $n \\in \\{330,756,385,2002\\}$ 时 $\\mu(n)$ 的精确值。通过判断 $n$ 是否能被质数的平方整除，如果不能，则通过确定不同质因数的数量，来证明你每一步的计算过程。将你的最终答案按 $\\mu(330), \\mu(756), \\mu(385), \\mu(2002)$ 的顺序表示为单个行向量。无需四舍五入。", "solution": "莫比乌斯函数，记为 $\\mu(n)$，对任意正整数 $n$ 都有定义。其定义基于 $n$ 的质因数分解：\n1. $\\mu(1) = 1$。\n2. 如果 $n$ 含有平方质因数（即 $n$ 不是无平方因子数），则 $\\mu(n) = 0$。这意味着存在一个质数 $p$ 使得 $p^2$ 整除 $n$。\n3. 如果 $n$ 是 $k$ 个不同质数的乘积（即 $n$ 是无平方因子数且有 $k$ 个质因数），则 $\\mu(n) = (-1)^k$。\n\n我们将通过首先确定给定整数 $n \\in \\{330, 756, 385, 2002\\}$ 中每一个的质因数分解来计算 $\\mu(n)$。\n\n计算 $n = 330$ 的情况：\n首先，我们求 $330$ 的质因数分解。\n$330 = 10 \\times 33 = (2 \\times 5) \\times (3 \\times 11)$。\n其质因数分解为 $330 = 2^1 \\times 3^1 \\times 5^1 \\times 11^1$。\n我们检查 $330$ 是否能被任何质数的平方整除。由于其质因数分解中所有指数均为 $1$，所以数字 $330$ 是无平方因子数。\n接下来，我们确定不同质因数的数量，记为 $k$。不同的质因数是 $2$、$3$、$5$ 和 $11$。因此，$k=4$。\n根据定义，$\\mu(330) = (-1)^k = (-1)^4 = 1$。\n\n计算 $n = 756$ 的情况：\n我们求 $756$ 的质因数分解。\n$756 = 2 \\times 378 = 2 \\times (2 \\times 189) = 2^2 \\times 189$。\n$189 = 3 \\times 63 = 3 \\times (3 \\times 21) = 3^2 \\times (3 \\times 7) = 3^3 \\times 7$。\n合并这些，其质因数分解为 $756 = 2^2 \\times 3^3 \\times 7^1$。\n我们检查 $756$ 是否能被任何质数的平方整除。其分解式包含 $2^2$ 和 $3^3 = 3^2 \\times 3$。因此，$756$ 能被 $2^2=4$ 整除，也能被 $3^2=9$ 整除。因为它不是无平方因子数，我们应用定义的第二种情况。\n根据定义，$\\mu(756) = 0$。\n\n计算 $n = 385$ 的情况：\n我们求 $385$ 的质因数分解。该数以 $5$ 结尾，因此能被 $5$ 整除。\n$385 = 5 \\times 77$。\n分解 $77$，我们得到 $77 = 7 \\times 11$。\n其质因数分解为 $385 = 5^1 \\times 7^1 \\times 11^1$。\n我们检查 $385$ 是否能被任何质数的平方整除。其分解式中所有指数均为 $1$，所以 $385$ 是无平方因子数。\n接下来，我们确定不同质因数的数量 $k$。不同的质因数是 $5$、$7$ 和 $11$。因此，$k=3$。\n根据定义，$\\mu(385) = (-1)^k = (-1)^3 = -1$。\n\n计算 $n = 2002$ 的情况：\n我们求 $2002$ 的质因数分解。\n$2002 = 2 \\times 1001$。\n为分解 $1001$，我们测试小的质除数。它不能被 $3$ 整除（各位数字之和为 $2$）。它不能被 $5$ 整除。对于 $7$，我们有 $1001 = 7 \\times 143$。\n为分解 $143$，我们测试质数。它不能被 $7$ 整除。对于 $11$，我们有 $143 = 11 \\times 13$。\n其质因数分解为 $2002 = 2^1 \\times 7^1 \\times 11^1 \\times 13^1$。\n我们检查 $2002$ 是否能被任何质数的平方整除。其分解式中所有指数均为 $1$，所以 $2002$ 是无平方因子数。\n接下来，我们确定不同质因数的数量 $k$。不同的质因数是 $2$、$7$、$11$ 和 $13$。因此，$k=4$。\n根据定义，$\\mu(2002) = (-1)^k = (-1)^4 = 1$。\n\n这些值分别为 $\\mu(330)=1$，$\\mu(756)=0$，$\\mu(385)=-1$ 和 $\\mu(2002)=1$。我们按照要求的顺序将它们表示为单个行向量。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n1  0  -1  1\n\\end{pmatrix}\n}\n$$", "id": "3092142"}, {"introduction": "莫比乌斯函数的真正威力体现在它与其它算术函数的相互作用中，尤其是在狄利克雷卷积和莫比乌斯反演公式中的核心作用。本练习将引导你通过一个涉及自然对数$\\ln(n)$的具体求和实例，探索这一深刻联系。你会发现，这个看似复杂的求和最终会揭示出整数的内在素数幂结构，从而体会到$\\mu(n)$作为分析工具的强大功能。[@problem_id:3092134]", "problem": "设 $\\mu(n)$ 表示莫比乌斯函数，其定义为 $\\mu(1)=1$，若 $n$ 能被某素数的平方整除，则 $\\mu(n)=0$，若 $n$ 是 $k$ 个不同素数的乘积，则 $\\mu(n)=(-1)^{k}$。对于一个固定的正整数 $n$ 和一个算术函数 $f$，考虑除数和 $S(n;f)=\\sum_{d\\mid n}\\mu(d)\\,f(n/d)$。仅使用 $\\mu(n)$ 的基本定义、狄利克雷卷积、算术基本定理（唯一分解定理）以及自然对数的基本性质，求下式的精确值\n$$\nS(81;\\ln)=\\sum_{d\\mid 81}\\mu(d)\\,\\ln\\!\\left(\\frac{81}{d}\\right),\n$$\n并根据 $81$ 的素数幂结构解释其结果。给出精确答案（不要四舍五入）。在整个过程中使用自然对数。", "solution": "该问题陈述是数论领域内一个定义明确且数学上合理的问题。它自成体系、客观，并依赖于已建立的定义和原则。因此，该问题有效，我们可以进行正式求解。\n\n题目要求计算以下和式的值：\n$$\nS(81; \\ln) = \\sum_{d\\mid 81}\\mu(d)\\,\\ln\\!\\left(\\frac{81}{d}\\right)\n$$\n其中 $\\mu(n)$ 是莫比乌斯函数。我们需要运用基本原理计算此和并解释结果。\n\n我们将用两种方法解决这个问题：首先，根据所给定义进行直接计算；其次，利用更具一般性的狄利克雷卷积框架来揭示其内在结构并给出所要求的解释。\n\n**方法一：直接计算**\n\n首先，我们确定在 $n=81$ 这一特定情况下的和式各项。\n\n根据算术基本定理，$n=81$ 的唯一素数分解为 $81 = 3^4$。$81$ 的正因数 $d$ 是形如 $3^k$ 的整数，其中 $k \\in \\{0, 1, 2, 3, 4\\}$。因此，因数集合为 $\\{1, 3, 9, 27, 81\\}$。\n\n接下来，我们计算每个因数的莫比乌斯函数 $\\mu(d)$ 的值：\n\\begin{itemize}\n    \\item 对于 $d=1$：根据定义，$\\mu(1) = 1$。\n    \\item 对于 $d=3$：由于 $3$ 是 $k=1$ 个不同素数的乘积，$\\mu(3) = (-1)^1 = -1$。\n    \\item 对于 $d=9=3^2$：由于 $9$ 能被素数 $3$ 的平方整除，$\\mu(9)=0$。\n    \\item 对于 $d=27=3^3$：由于 $27$ 能被素数 $3$ 的平方整除（因为 $27 = 3 \\cdot 3^2$），$\\mu(27)=0$。\n    \\item 对于 $d=81=3^4$：由于 $81$ 能被素数 $3$ 的平方整除，$\\mu(81)=0$。\n\\end{itemize}\n求和式中包含形如 $\\mu(d) \\ln(81/d)$ 的项。对于 $d=9$、$d=27$ 和 $d=81$ 的项，其值为零，因为这些因数的 $\\mu(d)=0$。我们只需考虑 $d=1$ 和 $d=3$ 的项。\n\n和式为：\n$$\nS(81; \\ln) = \\mu(1)\\ln\\left(\\frac{81}{1}\\right) + \\mu(3)\\ln\\left(\\frac{81}{3}\\right) + \\mu(9)\\ln\\left(\\frac{81}{9}\\right) + \\mu(27)\\ln\\left(\\frac{81}{27}\\right) + \\mu(81)\\ln\\left(\\frac{81}{81}\\right)\n$$\n代入 $\\mu(d)$ 的值：\n$$\nS(81; \\ln) = (1) \\cdot \\ln(81) + (-1) \\cdot \\ln(27) + (0) \\cdot \\ln(9) + (0) \\cdot \\ln(3) + (0) \\cdot \\ln(1)\n$$\n$$\nS(81; \\ln) = \\ln(81) - \\ln(27)\n$$\n使用自然对数的性质 $\\ln(a) - \\ln(b) = \\ln(a/b)$，我们得到：\n$$\nS(81; \\ln) = \\ln\\left(\\frac{81}{27}\\right) = \\ln(3)\n$$\n或者，使用性质 $\\ln(x^y) = y \\ln(x)$：\n$$\nS(81; \\ln) = \\ln(3^4) - \\ln(3^3) = 4\\ln(3) - 3\\ln(3) = (4-3)\\ln(3) = \\ln(3)\n$$\n直接计算得出精确值 $\\ln(3)$。\n\n**方法二：狄利克雷卷积与解释**\n\n为了在更广阔的背景下解释这一结果，我们考虑该和式的结构。给定的和式 $S(n; f) = \\sum_{d \\mid n} \\mu(d) f(n/d)$ 是莫比乌斯函数 $\\mu$ 与算术函数 $f$ 的狄利克雷卷积。我们将其记为 $(\\mu \\ast f)(n)$。题目要求计算 $(\\mu \\ast \\ln)(81)$。\n\n这个表达式是莫比乌斯反演公式的一个实例。让我们引入冯·曼戈尔特函数 $\\Lambda(n)$，其定义如下：\n$$\n\\Lambda(n) =\n\\begin{cases}\n\\ln(p)  \\text{若 } n=p^k \\text{，其中 } p \\text{ 为素数且整数 } k \\ge 1 \\\\\n0  \\text{其他情况}\n\\end{cases}\n$$\n数论中一个基本恒等式通过对因数的求和将自然对数与冯·曼戈尔特函数联系起来：\n$$\n\\sum_{d \\mid n} \\Lambda(d) = \\ln(n)\n$$\n用狄利克雷卷积的语言，这个恒等式写作 $(\\Lambda \\ast 1)(n) = \\ln(n)$，其中 $1(n)$ 是常数函数，对所有 $n \\in \\mathbb{Z}^+$ 都有 $1(n)=1$。\n\n我们需要计算的和是 $(\\mu \\ast \\ln)(n)$。代入 $\\ln(n)$ 的恒等式：\n$$\n(\\mu \\ast \\ln)(n) = (\\mu \\ast (\\Lambda \\ast 1))(n)\n$$\n狄利克雷卷积是可结合的，因此我们可以重新组合各项：\n$$\n(\\mu \\ast (\\Lambda \\ast 1))(n) = ((\\mu \\ast 1) \\ast \\Lambda)(n)\n$$\n莫比乌斯函数的一个定义性性质是它是常数函数 $1(n)$ 的狄利克雷逆。也就是说，它们的卷积得到狄利克雷卷积的单位元 $\\epsilon$：\n$$\n(\\mu \\ast 1)(n) = \\epsilon(n) =\n\\begin{cases}\n1  \\text{若 } n=1 \\\\\n0  \\text{若 } n1\n\\end{cases}\n$$\n将此代回我们的表达式中：\n$$\n((\\mu \\ast 1) \\ast \\Lambda)(n) = (\\epsilon \\ast \\Lambda)(n)\n$$\n任何算术函数 $f$ 与单位元 $\\epsilon$ 的卷积都返回函数 $f$ 本身：$(\\epsilon \\ast f)(n) = f(n)$。因此：\n$$\n(\\epsilon \\ast \\Lambda)(n) = \\Lambda(n)\n$$\n我们因此证明了一个普遍的恒等式：\n$$\nS(n; \\ln) = \\sum_{d\\mid n}\\mu(d)\\,\\ln\\!\\left(\\frac{n}{d}\\right) = \\Lambda(n)\n$$\n问题简化为计算 $n=81$ 时的冯·曼戈尔特函数值。\n由于 $81=3^4$，它是素数 $p=3$ 的幂，指数为 $k=4 \\ge 1$。根据 $\\Lambda(n)$ 的定义，我们有：\n$$\n\\Lambda(81) = \\ln(3)\n$$\n这验证了直接计算的结果。\n\n**解释**\n\n恒等式 $\\sum_{d\\mid n}\\mu(d)\\,\\ln(n/d) = \\Lambda(n)$ 提供了所要求的解释。给定的求和式是冯·曼戈尔特函数的一个公式。冯·曼戈尔特函数 $\\Lambda(n)$ 是专门为检测素数幂而设计的。只有当其参数 $n$ 是单一素数 $p$ 的幂 $p^k$ 时，其值才非零。在这种情况下，其值为 $\\ln(p)$，这分离出了素数底数 $p$ 的对数。\n\n对于 $n=81$ 的具体情况，这个数是一个纯素数幂 $3^4$。该求和式等价于 $\\Lambda(81)$，其计算结果正确地为 $\\ln(3)$。这个结果精确地分离并揭示了 $81$ 的唯一素数底数。如果 $n$ 是一个有多个不同素因数的数（例如，$n=12=2^2 \\cdot 3^1$），那么和式的值将为 $\\Lambda(12)=0$。因此，这个运算对整数的素数幂结构进行了基本分析，而结果 $\\ln(3)$ 表明 $81$ 是素数 $3$ 的一个幂。", "answer": "$$\n\\boxed{\\ln(3)}\n$$", "id": "3092134"}, {"introduction": "理论知识与计算实践相结合，是现代数论研究的重要方法。本练习要求你设计并实现一个算法，以高效计算莫比乌斯函数的值，并进一步探索其累加和——著名的梅滕斯函数 $M(x)$ 的行为。通过对$M(x)$的数值进行分析，你将直观地感受到$\\mu(n)$值的正负抵消现象，并一窥其与数论中一些最深刻的未解之谜（如黎曼猜想）之间的神秘联系。[@problem_id:3092145]", "problem": "要求您实现一个程序，计算莫比乌斯函数在正整数初始段上的累积行为，并从数值上量化其产生的抵消效应。请完全基于定义和标准的数论构造进行操作。\n\n用作唯一概念基础的定义：\n- 对每个正整数 $\\,n\\,$，莫比乌斯函数 $\\,\\mu(n)\\,$ 定义如下：\n  - $\\,\\mu(1)=1$，\n  - $\\,\\mu(n)=0\\,$，如果存在素数 $\\,p\\,$ 使得 $p^2 \\mid n$，\n  - $\\,\\mu(n)=(-1)^k\\,$，如果 $\\,n\\,$ 是 $\\,k\\,$ 个不同素数的乘积。\n- 梅滕斯函数 $\\,M(x)\\,$ 是求和函数 $M(x)=\\sum_{n\\le x}\\mu(n)$，其中 $\\,x\\,$ 为正整数。\n- 令 $Q(x)=\\sum_{n\\le x}|\\mu(n)|$，它计算了不大于 $\\,x\\,$ 的无平方因子数的个数。\n\n您的任务：\n- 从上述定义出发，设计并实现一个算法，该算法利用基于无平方因子数定义以及乘以一个新素数对 $\\,\\mu(n)\\,$ 符号的影响的筛法式构造，为给定的 $\\,N\\,$ 高效地确定所有 $\\,1\\le n\\le N\\,$ 的 $\\,\\mu(n)\\,$。\n- 使用计算出的值，为所有 $\\,1\\le x\\le N\\,$ 构造 $\\,M(x)\\,$ 和 $\\,Q(x)\\,$ 的累积数组。\n- 对每个指定的测试值 $\\,x\\,$，输出五元组\n  $$[\\,x,\\;M(x),\\;Q(x),\\;M(x)/x,\\;Q(x)/x\\,],$$\n  其中两个比率是四舍五入到 $\\,6\\,$ 位小数的实数。\n\n测试集：\n- 使用输入集 $\\,\\{\\,1,\\,10,\\,100,\\,1000,\\,10000,\\,100000\\,\\}\\,$。\n\n覆盖性设计：\n- $\\,x=1\\,$ 测试边界情况。\n- $\\,x=10\\,$ 和 $\\,x=100\\,$ 测试小规模行为。\n- $\\,x=1000\\,$ 和 $\\,x=10000\\,$ 测试中等范围。\n- $\\,x=100000\\,$ 测试一个更大但仍可处理的范围，以检验性能和累积行为。\n\n最终输出格式：\n- 您的程序必须生成单行输出，该行包含一个列表的列表，每个内部列表对应一个按给定顺序的测试值，且每个内部列表等于 $[\\,x,M(x),Q(x),M(x)/x,Q(x)/x\\,]$，其中两个比率四舍五入到 $\\,6\\,$ 位小数。整个输出必须是如下形式的单行：\n  $$[\\,[x_1,M(x_1),Q(x_1),M(x_1)/x_1,Q(x_1)/x_1],\\,[x_2,M(x_2),Q(x_2),M(x_2)/x_2,Q(x_2)/x_2],\\,\\dots\\,].$$\n\n您的实现必须是自包含的，不得读取输入，并且除了必需的单行输出外，不得写入任何其他内容。不涉及物理单位或角度。所有报告的比率都是纯实数，并且必须四舍五入到 $\\,6\\,$ 位小数。", "solution": "题目描述经评估有效。这是一个定义明确的计算数论练习，基于标准的、普遍接受的定义。任务要求实现一个高效算法来计算莫比乌斯函数 $\\,\\mu(n)\\,$ 及其累积和，这是一个标准课题。所有定义都精确无误，目标清晰且可通过计算验证。\n\n问题的核心是计算从 $\\,1\\,$ 到给定最大值 $\\,N\\,$ 的所有整数 $\\,n\\,$ 的莫比乌斯函数 $\\,\\mu(n)\\,$ 的值。对每个整数 $\\,n\\,$ 进行因式分解以确定 $\\,\\mu(n)\\,$ 的朴素方法计算成本高昂，其复杂度差于 $\\,O(N\\sqrt{N})$。一个更高效的方法，如问题所建议，是采用筛法式算法。我们将开发一种线性筛法，它能在 $\\,O(N)\\,$ 时间内计算出所有 $\\,n \\le N\\,$ 的 $\\,\\mu(n)\\,$。\n\n设 $\\,N\\,$ 为测试集所需的最大值，即 $\\,N=100000$。\n\n### 算法设计\n\n**1. 莫比乌斯函数 $\\,\\mu(n)\\,$ 的筛法**\n\n我们将改编一种常用于寻找素数的线性筛法算法，来计算 $\\,n \\in [1, N]\\,$ 的 $\\,\\mu(n)\\,$。该算法确保每个合数仅被处理一次。\n\n该算法需要三个主要数据结构：\n- 一个大小为 $\\,N+1\\,$ 的数组 `mu`，用于存储 $\\,\\mu(n)\\,$ 的值。\n- 一个大小为 $\\,N+1\\,$ 的数组 `lp`，用于存储每个数 $\\,n\\,$ 的最小素因子。\n- 一个列表 `primes`，用于按升序存储找到的素数。\n\n筛法过程如下：\n- **初始化**：\n  - 设置 $\\,\\mu[1] = 1$。\n  - 用零初始化 `lp` 数组。\n- **迭代**：遍历从 $\\,2\\,$ 到 $\\,N\\,$ 的整数 $\\,i\\,$。\n  - **素数情况**：如果 $\\,lp[i]\\,$ 仍为 $\\,0$，意味着 $\\,i\\,$ 没有比自身更小的素因子，因此 $\\,i\\,$ 必定是素数。\n    - 我们将其最小素因子设置为 $\\,lp[i] = i$。\n    - 根据定义，对于素数 $\\,i\\,$，$\\,\\mu(i) = (-1)^1 = -1\\,$。\n    - 将 $\\,i\\,$ 添加到我们的 `primes` 列表中。\n  - **合数情况**：对于我们 `primes` 列表中的每个素数 $\\,p\\,$：\n    - 令 $\\,j = i \\cdot p$。如果 $\\,j  N$，我们可以停止处理当前 $\\,i\\,$ 的倍数，因为它们将超出我们的界限。\n    - 我们通过设置合数 $\\,j\\,$ 的最小素因子来标记它：$\\,lp[j] = p$。\n    - 现在我们基于 $\\,\\mu(i)\\,$ 和 $\\,p\\,$ 确定 $\\,\\mu(j)\\,$：\n      - **情况 1：$\\,p\\,$ 整除 $\\,i\\,$**。这当且仅当 $\\,p\\,$ 是 $\\,i\\,$ 的最小素因子时发生，即 $\\,p = lp[i]$。在这种情况下，$\\,i\\,$ 的素因子分解已经包含至少一个因子 $\\,p$。乘以 $\\,p\\,$ 会在 $\\,j\\,$ 中引入一个平方因子 ($\\,p^2\\,$)。根据定义，如果一个整数能被一个素数的平方整除，其莫比乌斯函数值为 $\\,0$。因此，$\\,\\mu[j] = 0$。处理完这种情况后，我们中断对素数的内层循环。这个中断是筛法达到线性时间复杂度的关键，因为它确保了任何合数 $\\,j\\,$ 都只被其最小素因子“划掉”。\n      - **情况 2：$\\,p\\,$ 不整除 $\\,i\\,$**。这在 $\\,p   lp[i]$ 时发生。这里，$\\,p\\,$ 是 $\\,j\\,$ 的一个新素因子，它不在 $\\,i\\,$ 的因式分解中。$\\,j\\,$ 的不同素因子个数比 $\\,i\\,$ 多一个。因此，莫比乌斯函数的符号翻转：$\\,\\mu[j] = -\\mu[i]$。我们继续处理 `primes` 列表中的下一个素数。\n\n这个过程正确且高效地填充了 `mu` 数组，覆盖了直到 $\\,N\\,$ 的所有整数。\n\n**2. 累积函数 $\\,M(x)\\,$ 和 $\\,Q(x)\\,$ 的计算**\n\n一旦 `mu` 数组计算完成，我们就可以通过预先计算所有 $\\,x \\in [1, N]\\,$ 的值来求出求和函数 $\\,M(x) = \\sum_{n \\le x} \\mu(n)\\,$ 和 $\\,Q(x) = \\sum_{n \\le x} |\\mu(n)|\\,$。这通过计算 `mu` 数组和 `abs(mu)` 数组的累积和来完成。\n\n- 设 `M_cum` 是一个大小为 $\\,N+1\\,$ 的数组。我们可以迭代地计算它：\n  $$ M_{\\text{cum}}[x] = M_{\\text{cum}}[x-1] + \\mu[x] $$\n  基础情况为 $\\,M_{\\text{cum}}[0] = 0$。\n\n- 类似地，对于一个大小为 $\\,N+1\\,$ 的数组 `Q_cum`：\n  $$ Q_{\\text{cum}}[x] = Q_{\\text{cum}}[x-1] + |\\mu[x]| $$\n  基础情况为 $\\,Q_{\\text{cum}}[0] = 0$。\n\n有了这些累积和数组，我们可以在常数时间 $\\,O(1)\\,$ 内检索任何测试值 $\\,x \\le N\\,$ 的 $\\,M(x)\\,$ 和 $\\,Q(x)\\,$。\n\n**3. 生成最终输出**\n\n对于集合 $\\,\\{\\,1, 10, 100, 1000, 10000, 100000\\,\\}\\,$ 中的每个指定测试值 $\\,x\\,$：\n1. 检索 $\\,M(x) = M_{\\text{cum}}[x]\\,$ 和 $\\,Q(x) = Q_{\\text{cum}}[x]$。\n2. 计算比率 $\\,M(x)/x\\,$ 和 $\\,Q(x)/x$。\n3. 按要求将两个比率四舍五入到 $\\,6\\,$ 位小数。\n4. 构建五元组列表 $\\,[\\,x, M(x), Q(x), M(x)/x, Q(x)/x\\,]$。\n5. 将所有这些五元组收集到一个列表中，并将其格式化为最终输出字符串。\n\n值得注意的是，我们计算的这些量具有理论背景。函数 $\\,Q(x)\\,$ 计算了不大于 $\\,x\\,$ 的无平方因子数的数量。已知无平方因子数的密度收敛于 $\\,1/\\zeta(2) = 6/\\pi^2 \\approx 0.607927$。我们期望随着 $\\,x\\,$ 的增长，比率 $\\,Q(x)/x\\,$ 会趋近这个值。梅滕斯函数 $\\,M(x)\\,$ 的行为则更为神秘，并与黎曼猜想密切相关，黎曼猜想等价于断言对于任意 $\\,\\epsilon  0\\,$ 都有 $\\,M(x) = O(x^{1/2+\\epsilon})\\,$。我们的计算将提供对 $\\,M(x)\\,$ 所捕捉的复杂抵消现象的数值一瞥。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Computes statistics related to the Möbius and Mertens functions for a given\n    set of test values.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [1, 10, 100, 1000, 10000, 100000]\n\n    # Set the upper bound for the sieve from the test cases.\n    N = max(test_cases)\n\n    # Step 1: Compute mu(n) for n up to N using a linear sieve.\n    # lp[i] stores the least prime factor of i.\n    # mu[i] stores the Mobius function value mu(i).\n    lp = np.zeros(N + 1, dtype=int)\n    mu = np.zeros(N + 1, dtype=int)\n    primes = []\n    \n    mu[1] = 1\n\n    for i in range(2, N + 1):\n        if lp[i] == 0:\n            # i is a prime\n            lp[i] = i\n            mu[i] = -1\n            primes.append(i)\n        \n        for p in primes:\n            # Conditions to break the inner loop:\n            # The product must not exceed our limit N.\n            if i * p > N:\n                break\n\n            j = i * p\n            lp[j] = p\n            if p == lp[i]:\n                # p is a factor of i, so p^2 is a factor of j.\n                # mu(j) is 0 because j is not squarefree.\n                mu[j] = 0\n                break # Essential for linear time performance\n            else:\n                # p is not a factor of i (and p  lp[i]), so it's a new prime factor for j.\n                # The sign of mu flips.\n                mu[j] = -mu[i]\n\n    # Step 2: Compute cumulative sum arrays for M(x) and Q(x).\n    # M(x) is the sum of mu(n) up to x.\n    # Q(x) is the sum of |mu(n)| up to x (count of squarefree integers).\n    # numpy.cumsum provides an efficient way to do this.\n    M_cum = np.cumsum(mu)\n    Q_cum = np.cumsum(np.abs(mu))\n\n    # Step 3: Generate results for each test case.\n    results = []\n    for x in test_cases:\n        # Retrieve pre-computed cumulative sums.\n        m_x = int(M_cum[x])  # M_cum is int64 by default, cast to Python int\n        q_x = int(Q_cum[x])  # Q_cum is int64 by default, cast to Python int\n        \n        # Calculate ratios and round to 6 decimal places.\n        m_ratio = round(m_x / x, 6)\n        q_ratio = round(q_x / x, 6)\n        \n        # Assemble the quintuple for this test case.\n        result_quintuple = [x, m_x, q_x, m_ratio, q_ratio]\n        results.append(result_quintuple)\n\n    # Final print statement in the exact required format.\n    # The format is a string representation of a list of lists.\n    # e.g., [[x1, M1, ...], [x2, M2, ...]]\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3092145"}]}