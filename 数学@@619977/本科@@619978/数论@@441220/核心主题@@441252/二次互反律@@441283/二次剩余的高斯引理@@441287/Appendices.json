{"hands_on_practices": [{"introduction": "理论学习的最佳伙伴是动手实践。本练习将引导你直接应用高斯引理的核心机制，通过具体计算来确定勒让德符号的值。你将亲手处理一系列乘积的最小绝对值剩余，并对其中的负数进行计数，从而揭示高斯引理是如何将一个二次剩余问题转化为一个简单的奇偶性判断问题的 [@problem_id:3085442]。", "problem": "设 $p$ 为一个奇素数，整数 $x$ 模 $p$ 的最小绝对余数是唯一的整数 $\\rho$，满足 $-\\frac{p-1}{2} \\le \\rho \\le \\frac{p-1}{2}$ 且 $\\rho \\equiv x \\pmod{p}$。对于 $p=41$ 和 $a=13$，考虑倍数集合 $\\{13, 26, \\dots, 13 \\cdot 20\\}$ 及其模 $41$ 的最小绝对余数。设 $m$ 表示这些最小绝对余数中负数的个数。使用勒让德符号 $\\left(\\frac{a}{p}\\right)$ 的定义和作为基础工具的高斯引理，通过从这些余数中显式计算 $m$ 并推导由 $(-1)^{m}$ 决定的符号，来确定勒让德符号 $\\left(\\frac{13}{41}\\right)$ 的精确值。\n\n你的最终答案必须是 $\\left(\\frac{13}{41}\\right)$ 的单个数值。", "solution": "用户提供的问题是有效的，因为它是一个在初等数论领域内完全自洽、适定且有科学依据的问题。它要求直接应用一个标准定理，即高斯引理，并提供了所有必要的参数。\n\n该问题要求通过明确应用高斯引理来确定勒让德符号 $\\left(\\frac{13}{41}\\right)$ 的值。设 $p$ 为一个奇素数，$a$ 为一个不能被 $p$ 整除的整数。高斯引理指出\n$$\n\\left(\\frac{a}{p}\\right) = (-1)^m\n$$\n其中 $m$ 是集合 $S = \\{a, 2a, 3a, \\dots, \\frac{p-1}{2}a\\}$ 中，其模 $p$ 的最小非负余数大于 $\\frac{p}{2}$ 的整数的个数。一个等价的条件是，$m$ 是集合 $S$ 中模 $p$ 的最小绝对余数为负的元素的个数。\n\n在这个问题中，给定 $a=13$ 和 $p=41$。由于 $41$ 是一个奇素数，且 $13$ 不是 $41$ 的倍数，所以勒让德符号 $\\left(\\frac{13}{41}\\right)$ 是有明确定义的。\n\n首先，我们确定倍数 $ka$ 中整数 $k$ 的范围。倍数集合是为 $k$ 从 $1$ 到 $\\frac{p-1}{2}$ 定义的。\n对于 $p=41$，我们有 $\\frac{p-1}{2} = \\frac{41-1}{2} = 20$。\n因此，我们必须考虑倍数集合 $S = \\{13k \\mid 1 \\le k \\le 20\\}$。\n\n该问题将整数 $x$ 模 $p$ 的最小绝对余数定义为唯一的整数 $\\rho$，满足 $-\\frac{p-1}{2} \\le \\rho \\le \\frac{p-1}{2}$ 且 $\\rho \\equiv x \\pmod{p}$。\n对于 $p=41$，这个范围是 $-\\frac{41-1}{2} \\le \\rho \\le \\frac{41-1}{2}$，化简为 $-20 \\le \\rho \\le 20$。\n\n我们需要找到 $m$，即对于 $k=1, \\dots, 20$，其倍数 $13k$ 模 41 的最小绝对余数为负数的个数。在这个系统中，如果一个余数的标准最小非负余数 $r$ (其中 $0 \\le r  p$) 落在范围 $\\frac{p}{2}  r  p$ 内，则该余数为负。对于 $p=41$，这意味着 $20.5  r  41$。\n\n现在我们将为每个 $k$ 从 $1$ 到 $20$ 计算最小非负余数 $r_k = 13k \\pmod{41}$，并确定是否 $r_k > 20.5$。这种情况的计数将是我们的 $m$ 值。\n\n对于 $k=1$：$13 \\cdot 1 = 13 \\equiv 13 \\pmod{41}$。$13 \\ngtr 20.5$。最小绝对余数是 $13$。\n对于 $k=2$：$13 \\cdot 2 = 26 \\equiv 26 \\pmod{41}$。$26 > 20.5$。最小绝对余数是 $26 - 41 = -15$。（计数：1）\n对于 $k=3$：$13 \\cdot 3 = 39 \\equiv 39 \\pmod{41}$。$39 > 20.5$。最小绝对余数是 $39 - 41 = -2$。（计数：2）\n对于 $k=4$：$13 \\cdot 4 = 52 \\equiv 11 \\pmod{41}$。$11 \\ngtr 20.5$。最小绝对余数是 $11$。\n对于 $k=5$：$13 \\cdot 5 = 65 \\equiv 24 \\pmod{41}$。$24 > 20.5$。最小绝对余数是 $24 - 41 = -17$。（计数：3）\n对于 $k=6$：$13 \\cdot 6 = 78 \\equiv 37 \\pmod{41}$。$37 > 20.5$。最小绝对余数是 $37 - 41 = -4$。（计数：4）\n对于 $k=7$：$13 \\cdot 7 = 91 = 2 \\cdot 41 + 9 \\equiv 9 \\pmod{41}$。$9 \\ngtr 20.5$。最小绝对余数是 $9$。\n对于 $k=8$：$13 \\cdot 8 = 104 = 2 \\cdot 41 + 22 \\equiv 22 \\pmod{41}$。$22 > 20.5$。最小绝对余数是 $22 - 41 = -19$。（计数：5）\n对于 $k=9$：$13 \\cdot 9 = 117 = 2 \\cdot 41 + 35 \\equiv 35 \\pmod{41}$。$35 > 20.5$。最小绝对余数是 $35 - 41 = -6$。（计数：6）\n对于 $k=10$：$13 \\cdot 10 = 130 = 3 \\cdot 41 + 7 \\equiv 7 \\pmod{41}$。$7 \\ngtr 20.5$。最小绝对余数是 $7$。\n对于 $k=11$：$13 \\cdot 11 = 143 = 3 \\cdot 41 + 20 \\equiv 20 \\pmod{41}$。$20 \\ngtr 20.5$。最小绝对余数是 $20$。\n对于 $k=12$：$13 \\cdot 12 = 156 = 3 \\cdot 41 + 33 \\equiv 33 \\pmod{41}$。$33 > 20.5$。最小绝对余数是 $33 - 41 = -8$。（计数：7）\n对于 $k=13$：$13 \\cdot 13 = 169 = 4 \\cdot 41 + 5 \\equiv 5 \\pmod{41}$。$5 \\ngtr 20.5$。最小绝对余数是 $5$。\n对于 $k=14$：$13 \\cdot 14 = 182 = 4 \\cdot 41 + 18 \\equiv 18 \\pmod{41}$。$18 \\ngtr 20.5$。最小绝对余数是 $18$。\n对于 $k=15$：$13 \\cdot 15 = 195 = 4 \\cdot 41 + 31 \\equiv 31 \\pmod{41}$。$31 > 20.5$。最小绝对余数是 $31 - 41 = -10$。（计数：8）\n对于 $k=16$：$13 \\cdot 16 = 208 = 5 \\cdot 41 + 3 \\equiv 3 \\pmod{41}$。$3 \\ngtr 20.5$。最小绝对余数是 $3$。\n对于 $k=17$：$13 \\cdot 17 = 221 = 5 \\cdot 41 + 16 \\equiv 16 \\pmod{41}$。$16 \\ngtr 20.5$。最小绝对余数是 $16$。\n对于 $k=18$：$13 \\cdot 18 = 234 = 5 \\cdot 41 + 29 \\equiv 29 \\pmod{41}$。$29 > 20.5$。最小绝对余数是 $29 - 41 = -12$。（计数：9）\n对于 $k=19$：$13 \\cdot 19 = 247 = 6 \\cdot 41 + 1 \\equiv 1 \\pmod{41}$。$1 \\ngtr 20.5$。最小绝对余数是 $1$。\n对于 $k=20$：$13 \\cdot 20 = 260 = 6 \\cdot 41 + 14 \\equiv 14 \\pmod{41}$。$14 \\ngtr 20.5$。最小绝对余数是 $14$。\n\n通过计算最小非负余数大于 $20.5$ 的实例（这对应于负的最小绝对余数），我们发现有 $9$ 个这样的情况。\n因此，$m=9$。\n\n根据高斯引理，勒让德符号的值由 $(-1)^m$ 给出。\n$$\n\\left(\\frac{13}{41}\\right) = (-1)^m = (-1)^9 = -1\n$$\n这意味着 $13$ 是模 $41$ 的二次非剩余。", "answer": "$$\\boxed{-1}$$", "id": "3085442"}, {"introduction": "掌握一个定理不仅要知道如何使用它，更要理解其构造的精妙之处。本练习旨在深化你对高斯引理的理解，通过辨析一个常见的误区来揭示为何引理中的求和上限是 $\\frac{p-1}{2}$ 而非 $p-1$。通过分析这种选择背后的对称性，你将能更深刻地把握该引理的证明逻辑 [@problem_id:3013379]。", "problem": "设 $p$ 是一个奇素数，且 $a \\in \\mathbb{Z}$ 满足 $\\gcd(a,p)=1$。勒让德符号 $\\left(\\frac{a}{p}\\right)$ 的定义是：如果 $a$ 是模 $p$ 的二次剩余，则 $\\left(\\frac{a}{p}\\right)=1$；否则 $\\left(\\frac{a}{p}\\right)=-1$。在将 $\\left(\\frac{a}{p}\\right)$ 与一个来自乘积的符号相关联的一种标准方法中，许多证明会考虑对于 $1 \\le j \\le \\frac{p-1}{2}$，乘积 $j a$ 模 $p$ 的最小正剩余，然后相对于阈值 $\\frac{p}{2}$ 进行奇偶性计数。\n\n一名学生却提出了一个不同的方案：将 $j$ 的范围取遍 $1 \\le j \\le p-1$，计算 $j a \\bmod p$ 的最小正剩余中有多少个落在开区间 $\\left(\\frac{p}{2},p\\right)$ 内，并使用这个计数的奇偶性作为 $\\left(\\frac{a}{p}\\right)$ 的代理。请指出该提案中的确切逻辑错误，并选择能使该计数论证有效的最小修正。\n\n选择唯一的最佳答案。\n\nA. 在整个范围 $1 \\le j \\le p-1$ 内， $j a \\bmod p$ 的最小正剩余的多重集是 $\\{1,2,\\dots,p-1\\}$ 的一个排列。对于每一对 $\\{j,p-j\\}$，其对应的剩余 $r_j$ 和 $r_{p-j}$ 满足 $r_{p-j}=p-r_j$。由于 $p$ 是奇数， $r_j$ 和 $r_{p-j}$ 中恰好有一个落在 $\\left(\\frac{p}{2},p\\right)$ 内，因此所提议的计数总是 $\\frac{p-1}{2}$，与 $a$ 无关。因此，该方法无法区分二次剩余和非二次剩余。最小的修正是通过将范围限制在 $1 \\le j \\le \\frac{p-1}{2}$（等价于从每对 $\\{j,p-j\\}$ 中选择一个代表）来打破这种对称性，然后相对于 $\\frac{p}{2}$ 进行奇偶性计数。\n\nB. 唯一的错误是遗漏了 $j=0$。如果对 $0 \\le j \\le p-1$ 的最小正剩余进行计数，并使用超过 $\\frac{p}{2}$ 的那些数的奇偶性，该方法无需进一步修改即可变得有效。\n\nC. 缺陷源于选择了阈值 $\\frac{p}{2}$。保持 $1 \\le j \\le p-1$ 的范围，但改为计算落在 $\\left(\\frac{p}{3},p\\right)$ 内的最小正剩余数量，可以为所有奇素数 $p$ 恢复其正确性。\n\nD. 该论证仅在 $p \\equiv 1 \\pmod{4}$ 时失败。当 $p \\equiv 3 \\pmod{4}$ 时，取 $1 \\le j \\le p-1$ 并计算落在 $\\left(\\frac{p}{2},p\\right)$ 内的最小正剩余数量，确实能得出 $\\left(\\frac{a}{p}\\right)$ 的正确奇偶性。\n\nE. 没有错误：因为乘以 $a$ 会排列模 $p$ 的非零剩余类，所以 $j a \\bmod p$ 的最小正剩余中落在 $\\left(\\frac{p}{2},p\\right)$ 内的数量取决于 $a$，因此其奇偶性可以为所有 $a$ 正确地恢复 $\\left(\\frac{a}{p}\\right)$。", "solution": "用户提供的问题陈述是有效的。这是一个在初等数论领域内，基于已确立的数学原理的适定问题。\n\n学生的提议是通过计算在 $1 \\le j \\le p-1$ 范围内 $ja \\pmod p$ 的最小正剩余中，有多少个落在区间 $\\left(\\frac{p}{2},p\\right)$ 内，然后检查这个计数的奇偶性，来计算勒让德符号 $\\left(\\frac{a}{p}\\right)$。\n\n我们来分析这个提议。\n设 $S = \\{1, 2, \\dots, p-1\\}$。学生考虑的是最小正剩余的多重集 $R_a = \\{ (ja \\pmod p) \\mid j \\in S \\}$。\n因为 $p$ 是素数且 $\\gcd(a,p)=1$，映射 $x \\mapsto ax$ 是模 $p$ 整数乘法群 $(\\mathbb{Z}/p\\mathbb{Z})^\\times$ 的一个自同构。$(\\mathbb{Z}/p\\mathbb{Z})^\\times$ 中元素的最小正代表集恰好是集合 $S$。\n因此，对于任何满足 $\\gcd(a,p)=1$ 的 $a$，剩余集 $R_a$ 仅仅是集合 $S$ 的一个排列。作为集合，它们是相同的：\n$$R_a = \\{1, 2, \\dots, p-1\\}$$\n学生提议计算 $R_a$ 中落在开区间 $\\left(\\frac{p}{2}, p\\right)$ 内的元素数量。设这个计数为 $N$。由于无论 $a$ 是多少，$R_a$ 总是集合 $\\{1, 2, \\dots, p-1\\}$，所以计数 $N$ 将与 $a$ 无关。\n\n我们来计算 $N$。满足 $1 \\le k \\le p-1$ 和 $\\frac{p}{2}  k  p$ 的整数是从 $\\lfloor \\frac{p}{2} \\rfloor + 1$ 到 $p-1$ 的整数。\n由于 $p$ 是一个奇素数，我们可以将其写成 $p = 2k_0+1$，其中 $k_0 \\ge 1$ 是某个整数。那么 $\\frac{p-1}{2} = k_0$，且 $\\frac{p}{2} = k_0 + \\frac{1}{2}$。\n条件变为 $k_0 + \\frac{1}{2}  k  2k_0+1$。满足此条件的整数是 $k_0+1, k_0+2, \\dots, 2k_0$。\n这些整数的数量是 $N = 2k_0 - (k_0+1) + 1 = k_0$。因此，计数总是 $N = k_0 = \\frac{p-1}{2}$。\n\n学生的方法提出 $\\left(\\frac{a}{p}\\right)$ 由 $N$ 的奇偶性给出，具体来说是 $(-1)^N = (-1)^{(p-1)/2}$。\n根据二次剩余理论，一个已知的结论（作为二次互反律第一补充定律的一部分）是 $\\left(\\frac{-1}{p}\\right) = (-1)^{(p-1)/2}$。\n所以，学生的方法计算的不是 $\\left(\\frac{a}{p}\\right)$，而是 $\\left(\\frac{-1}{p}\\right)$，这是一个与 $a$ 无关的值。对于给定的 $p$，该方法无法区分二次剩余和非二次剩余。这就是确切的逻辑错误。\n\n学生的提议所类似的标准方法是高斯引理。高斯引理将 $j$ 的范围限制在 $1 \\le j \\le \\frac{p-1}{2}$。设 $m$ 为对于 $j \\in \\{1, \\dots, \\frac{p-1}{2}\\}$，$ja \\pmod p$ 的最小正剩余中大于 $\\frac{p}{2}$ 的数量。高斯引理指出 $\\left(\\frac{a}{p}\\right) = (-1)^m$。与学生的计数 $N$ 不同，计数 $m$ *确实*取决于 $a$。学生方法失败的原因是其对称的范围 $1 \\le j \\le p-1$。对于任何 $j_0 \\in \\{1, \\dots, p-1\\}$，设 $r_{j_0}$ 是 $j_0 a \\pmod p$ 的最小正剩余。那么对于 $j = p - j_0$，其剩余是 $(p-j_0)a \\pmod p \\equiv -j_0 a \\pmod p$，其最小正剩余是 $p-r_{j_0}$。对于 $j=1, \\dots, p-1$ 的剩余集 $\\{r_j\\}$ 由成对的 $(r_{j_0}, p-r_{j_0})$ 组成。由于 $p$ 是奇数， $p/2$ 不是整数。对于任何一对 $(r, p-r)$，恰好有一个元素在区间 $\\left(\\frac{p}{2}, p\\right)$ 内。这样的下标对 $\\{j_0, p-j_0\\}$ 有 $\\frac{p-1}{2}$ 个，所以总计数总是 $\\frac{p-1}{2}$。将 $j$ 限制在 $1 \\le j \\le \\frac{p-1}{2}$ 打破了这种对称性，使得计数可以依赖于 $a$。\n\n现在，我们来评估每个选项。\n\nA. 该选项正确地指出剩余集是 $\\{1, 2, \\dots, p-1\\}$ 的一个排列。它正确地识别了对称性：对于每一对下标 $\\{j, p-j\\}$，其剩余是 $r_j$ 和 $p-r_j$。它正确地得出结论，这意味着这两个剩余中恰好有一个在 $\\left(\\frac{p}{2}, p\\right)$ 内。它正确地推断出总计数因此总是 $\\frac{p-1}{2}$，与 $a$ 无关，这是核心错误。然后，它正确地指出了最小的修正：将 $j$ 的范围限制在 $1 \\le j \\le \\frac{p-1}{2}$，这打破了对称性，并将有缺陷的论证变成了高斯引理。这个选项是一个完整而准确的分析。这是**正确的**。\n\nB. 该选项建议包含 $j=0$。乘积 $0 \\cdot a = 0$，所以剩余是 $0$。数字 $0$ 不在区间 $\\left(\\frac{p}{2}, p\\right)$ 内。加入这个值不会改变该区间内剩余的数量。总计数将保持为 $\\frac{p-1}{2}$，并且该方法仍然与 $a$ 无关。这是**不正确的**。\n\nC. 该选项建议将阈值从 $\\frac{p}{2}$ 更改为 $\\frac{p}{3}$。如初始分析所示，要计数的剩余集总是 $\\{1, 2, \\dots, p-1\\}$。计算这些数中有多少落在 $\\left(\\frac{p}{3}, p\\right)$ 内，将得出一个等于 $(p-1) - \\lfloor\\frac{p}{3}\\rfloor$ 的计数。这个数字同样与 $a$ 无关。使用整个范围 $1 \\le j \\le p-1$ 的根本缺陷没有得到解决。这是**不正确的**。\n\nD. 该选项声称该论证仅在 $p \\equiv 1 \\pmod{4}$ 时失败。根据推导，学生的方法总是得出 $(-1)^{(p-1)/2}$。如果 $p \\equiv 3 \\pmod{4}$，那么 $\\frac{p-1}{2}$ 是奇数，所以该方法的结果总是 $-1$。然而，对于任何素数 $p$，都存在二次剩余 $a$ 使得 $\\left(\\frac{a}{p}\\right)=1$（例如 $a=1$）。因此，该方法在 $p \\equiv 3 \\pmod{4}$ 时同样失败，就像在 $p \\equiv 1 \\pmod{4}$ 时一样。该说法是错误的。这是**不正确的**。\n\nE. 该选项声称没有错误。这显然是错误的。它正确地指出了乘以 $a$ 会排列剩余类，但得出了错误的结论，即计数因此必须依赖于 $a$。被排列的元素集合是固定的，因此具有某个属性（大于 $\\frac{p}{2}$）的元素数量与具体的排列无关。这是**不正确的**。\n\n唯一正确识别错误、解释其来源并提出正确最小修正的选项是 A。", "answer": "$$\\boxed{A}$$", "id": "3013379"}, {"introduction": "在现代，数论的应用常常与高效的计算密不可分。这个练习将挑战你将高斯引理的数学步骤转化为一个精确的计算机算法。你不仅需要设计出这个算法，还需要分析其在不同计算模型下的时间复杂度，从而将抽象的数学理论与具体的计算性能联系起来 [@problem_id:3085438]。", "problem": "设 $p$ 是一个奇素数，$a$ 是任意整数。勒让德符号 $\\left(\\frac{a}{p}\\right)$ 由以下三类情况定义：如果 $p$ 整除 $a$，则 $\\left(\\frac{a}{p}\\right)=0$；如果 $a$ 是模 $p$ 的二次剩余，则 $\\left(\\frac{a}{p}\\right)=1$；否则 $\\left(\\frac{a}{p}\\right)=-1$。请设计并实现一个算法，该算法基于高斯引理，通过以下步骤计算 $\\left(\\frac{a}{p}\\right)$：将 $a$ 对模 $p$ 约化为集合 $\\{0,1,2,\\dots,p-1\\}$ 中的一个代表元；如果约化后的值为 $0$，则返回 $0$。否则，对于从 $1$ 到 $\\frac{p-1}{2}$ 的每个整数 $k$，将 $ka$ 对模 $p$ 约化，然后将结果映射到区间 $(-\\frac{p}{2}, \\frac{p}{2}]$ 内的最小绝对剩余；统计这些最小绝对剩余中有多少个是负数，并用此计数来确定 $\\left(\\frac{a}{p}\\right)$。您的设计必须从勒让德符号和最小绝对剩余的基本定义出发，并以基本原理进行论证；避免引入任何关于该符号的现成快捷公式。\n\n除了算法设计，还需分析其作为 $p$ 的函数的运行时间。请用大O表示法陈述其复杂度，并在随机存取机（RAM）计算模型下进行论证，该模型下每次对大小为 $O(\\log p)$ 位的整数进行的算术运算计为 $O(1)$ 时间。此外，请讨论当每次算术运算的成本随所涉及的位数扩展时的位复杂度。\n\n请将该算法实现在一个完整的程序中，该程序硬编码以下 $(a,p)$ 对的测试套件，并按指定顺序生成它们的勒让德符号值：\n- 测试 1：$a=2$, $p=3$。\n- 测试 2：$a=3$, $p=7$。\n- 测试 3：$a=5$, $p=11$。\n- 测试 4：$a=2$, $p=29$。\n- 测试 5：$a=0$, $p=19$。\n- 测试 6：$a=-1$, $p=13$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如 $\\left[\\,r_1,r_2,\\dots,r_6\\,\\right]$），其中每个 $r_i$ 是对应测试的 $\\left(\\frac{a}{p}\\right)$ 的整数值。唯一允许的输出类型是布尔型、整型、浮点型或这些基本类型的列表；对于本任务，每个 $r_i$ 必须是集合 $\\{-1,0,1\\}$ 中的一个整数。", "solution": "问题陈述经评估有效。它提出了一个计算数论中定义明确的任务，该任务科学上合理、内容自洽且一致。任务是设计、分析并实现一个基于高斯引理的程序来计算勒让德符号的算法。\n\n### 算法设计与理论论证\n\n目标是计算整数 $a$ 和奇素数 $p$ 的勒让德符号 $\\left(\\frac{a}{p}\\right)$。\n\n**1. 勒让德符号的定义**\n\n对于整数 $a$ 和奇素数 $p$，勒让德符号 $\\left(\\frac{a}{p}\\right)$ 定义如下：\n$$\n\\left(\\frac{a}{p}\\right) = \n\\begin{cases}\n\\phantom{-}0  \\text{若 } a \\equiv 0 \\pmod{p} \\\\\n\\phantom{-}1  \\text{若 } a \\not\\equiv 0 \\pmod{p} \\text{ 且存在整数 } x \\text{ 使得 } x^2 \\equiv a \\pmod{p} \\\\\n-1  \\text{若 } a \\not\\equiv 0 \\pmod{p} \\text{ 且不存在这样的 } x\n\\end{cases}\n$$\n满足第二种情况的整数 $a$ 称为模 $p$ 的二次剩余。满足第三种情况的整数称为模 $p$ 的二次非剩余。\n\n**2. 高斯引理**\n\n指定的算法是高斯引理的直接应用，高斯引理是计算勒让德符号的一个基本定理。该引理陈述如下：\n\n设 $p$ 是一个奇素数， $a$ 是一个与 $p$ 互素的整数，即 $\\gcd(a, p) = 1$。考虑整数集合 $S$：\n$$ S = \\left\\{ a, 2a, 3a, \\dots, \\left(\\frac{p-1}{2}\\right)a \\right\\} $$\n设 $n$ 为集合 $S$ 中，其模 $p$ 的最小非负剩余大于 $\\frac{p}{2}$ 的元素个数。那么，勒让德符号由下式给出：\n$$ \\left(\\frac{a}{p}\\right) = (-1)^n $$\n\n问题要求计算负的最小绝对剩余的数量。让我们将此联系形式化。模 $p$ 的最小绝对剩余集是区间 $(-\\frac{p}{2}, \\frac{p}{2}]$ 内的整数集。对于奇素数 $p$，这个整数集是 $\\{ -\\frac{p-1}{2}, \\dots, -1, 0, 1, \\dots, \\frac{p-1}{2} \\}$。\n对于任意整数 $m$，其模 $p$ 的最小非负剩余是一个值 $r \\in \\{0, 1, \\dots, p-1\\}$。其最小绝对剩余 $r'$ 与 $r$ 的关系如下：\n- 如果 $0 \\le r \\le \\frac{p-1}{2}$，则 $r' = r$。这些值是非负的。\n- 如果 $\\frac{p+1}{2} \\le r \\le p-1$，则 $r' = r-p$。这些值是负的，具体来说 $r' \\in \\{-\\frac{p-1}{2}, \\dots, -1\\}$。\n\n条件 $r > \\frac{p}{2}$ 对于整数 $r$ 来说等价于 $r \\ge \\frac{p+1}{2}$。因此，统计集合 $S$ 中满足其最小非负剩余 $r = (ka \\pmod p) > \\frac{p}{2}$ 的元素 $ka$ 的数量，与统计其最小绝对剩余为负数的元素的数量是相同的。高斯引理中的整数 $n$ 正是这个计数值。\n\n**3. 算法**\n\n基于上述原理，设计出如下正式算法：\n\n**输入**：一个整数 $a$ 和一个奇素数 $p$。\n**输出**：勒让德符号 $\\left(\\frac{a}{p}\\right)$ 的值，属于 $\\{-1, 0, 1\\}$。\n\n1.  **处理整除性**：计算剩余 $a' = a \\pmod p$。根据定义，如果 $a' = 0$，则勒让德符号为 $0$。算法返回 $0$ 并终止。\n\n2.  **初始化计数器**：如果 $a' \\neq 0$，初始化计数器 $n=0$。此计数器将存储大于 $\\frac{p}{2}$ 的剩余的数量。\n\n3.  **迭代和计数**：对从 $1$ 到 $\\frac{p-1}{2}$（含）的整数 $k$ 进行循环。对于每个 $k$：\n    a. 计算乘积 $m = k \\cdot a'$。\n    b. 求最小非负剩余 $r = m \\pmod p$。\n    c. 检查是否有 $r > \\frac{p}{2}$。如果此条件为真，则计数器 $n$ 加一。\n\n4.  **确定结果**：循环结束后，勒让德符号的值由 $n$ 的奇偶性决定。\n    - 如果 $n$ 是偶数，$\\left(\\frac{a}{p}\\right) = (-1)^n = 1$。\n    - 如果 $n$ 是奇数，$\\left(\\frac{a}{p}\\right) = (-1)^n = -1$。\n    算法相应地返回 $1$ 或 $-1$。\n\n### 复杂度分析\n\n首先在随机存取机（RAM）模型下进行分析，然后考虑位复杂度。\n\n**1. RAM 模型分析**\n\n该模型假定对适合机器字的整数进行的算术运算（加、乘、带余除法）需要常数时间，即 $O(1)$。我们假设 $p$ 以及所有中间值（如 $k$、$a'$ 和 $r$）都适合一个机器字。这与问题规范中对大小为 $O(\\log p)$ 位的整数进行操作的要求一致。\n\n- **步骤 1 (剩余计算)**：计算 $a' = a \\pmod p$ 需要 $O(1)$ 时间，假设 $a$ 也适合常数个机器字。\n- **步骤 2 (初始化)**：$n=0$ 需要 $O(1)$ 时间。\n- **步骤 3 (循环)**：循环执行 $\\frac{p-1}{2}$ 次，即 $O(p)$ 次迭代。\n    - 在循环内部，乘法 $k \\cdot a'$、取模运算 $m \\pmod p$、比较 $r > \\frac{p}{2}$ 以及可能对 $n$ 的递增，在此模型下都被视为 $O(1)$ 操作。\n    - 因此，循环的总时间为 $O(p) \\times O(1) = O(p)$。\n- **步骤 4 (最终结果)**：检查 $n$ 的奇偶性是 $O(1)$ 操作。\n\n算法的主要部分是循环。因此，在RAM模型下，算法的总时间复杂度为 $O(p)$。\n\n**2. 位复杂度分析**\n\n该模型考虑了数字的位数。设 $b = \\lceil \\log_2 p \\rceil$ 是表示 $p$ 所需的位数。所有整数 $k$、$a'$ 和 $r$ 的大小都是 $O(b) = O(\\log p)$。设 $M(b)$ 表示两个 $b$ 位整数相乘的时间复杂度。使用传统的笔算乘法，$M(b) = O(b^2)$。两个 $b$ 位数的带余除法具有相似的复杂度，$O(M(b))$。\n\n- **步骤 1 (剩余计算)**：假设 $a$ 的大小与 $p$ 相当，计算 $a' = a \\pmod p$ 需要 $O(M(b))$ 时间。\n- **步骤 3 (循环)**：循环运行 $O(p)$ 次。\n    - 在循环内部，整数 $k$ 和 $a'$ 有 $O(b)$ 位。\n    - 乘积 $k \\cdot a'$ 产生一个最多 $2b$ 位的整数。乘法需要 $O(M(b))$ 时间。\n    - 取模运算 $(k \\cdot a') \\pmod p$ 涉及一个 $O(b)$ 位数除以另一个 $O(b)$ 位数，需要 $O(M(b))$ 时间。\n    - 循环单次迭代的总时间由这些算术运算主导，总计为 $O(M(b))$。\n- **总复杂度**：总位复杂度是迭代次数乘以每次迭代的复杂度：$O(p \\cdot M(\\log p))$。\n\n如果我们假设笔算乘法，$M(b) = O(b^2)$，则位复杂度为 $O(p \\cdot (\\log p)^2)$。使用更快的乘法算法，如 Karatsuba 算法（$M(b) = O(b^{\\log_2 3})$）或 Schönhage-Strassen 算法（$M(b) = O(b \\log b \\log \\log b)$），将会得到相应更低的总复杂度。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef compute_legendre(a: int, p: int) - int:\n    \"\"\"\n    Computes the Legendre symbol (a/p) using Gauss's Lemma.\n\n    Args:\n        a: An integer.\n        p: An odd prime number.\n\n    Returns:\n        The Legendre symbol, which is 1, -1, or 0.\n    \"\"\"\n    # Step 1: Reduce a modulo p. If a is divisible by p, the symbol is 0.\n    # The definition is (a/p) = 0 if a is congruent to 0 mod p.\n    if a % p == 0:\n        return 0\n\n    # According to Gauss's lemma, we need to count the number of residues\n    # in a specific set that are greater than p/2.\n    # The set is {1*a, 2*a, ..., ((p-1)/2)*a} mod p.\n    \n    # Step 2: Initialize a counter for residues greater than p/2.\n    # This counter corresponds to n in the formula (-1)^n.\n    n = 0\n    \n    # The upper bound for the loop, (p-1)/2.\n    upper_bound = (p - 1) // 2\n    \n    # Step 3: Iterate from k=1 to (p-1)/2 and count relevant residues.\n    for k in range(1, upper_bound + 1):\n        # Calculate the least non-negative residue of k*a mod p.\n        residue = (k * a) % p\n        \n        # Check if the residue is in the upper half of the range [1, p-1].\n        # This is equivalent to its least absolute residue being negative.\n        if residue > p / 2:\n            n += 1\n            \n    # Step 4: Determine the Legendre symbol based on the parity of n.\n    # (a/p) = (-1)^n.\n    if n % 2 == 0:\n        return 1\n    else:\n        return -1\n\ndef solve():\n    \"\"\"\n    Solves the problem by running the specified test cases through\n    the Legendre symbol computation algorithm.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (2, 3),   # Test 1\n        (3, 7),   # Test 2\n        (5, 11),  # Test 3\n        (2, 29),  # Test 4\n        (0, 19),  # Test 5\n        (-1, 13)  # Test 6\n    ]\n\n    results = []\n    for a, p in test_cases:\n        # Calculate the Legendre symbol for the current case.\n        result = compute_legendre(a, p)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3085438"}]}