{"hands_on_practices": [{"introduction": "要真正掌握一个数学工具，我们必须首先理解其内在的运作原理。本练习将引导你从费马小定理等基本原理出发，推导出欧拉判别法。通过首先证明该判则，然后将其应用于一个具体的计算示例中 [@problem_id:3084828]，你将为这个优雅的判则为何能准确识别二次剩余建立坚实的直观理解。", "problem": "设 $p$ 为一个奇素数，并令 $(\\frac{a}{p})$ 表示勒让德符号，其定义为：如果存在整数 $x \\in \\mathbb{Z}$ 使得 $x^{2} \\equiv a \\pmod{p}$，则 $(\\frac{a}{p})=1$；如果 $\\gcd(a,p)=1$ 且不存在这样的 $x$，则 $(\\frac{a}{p})=-1$；如果 $p \\mid a$，则 $(\\frac{a}{p})=0$。仅使用此定义、乘法群 $(\\mathbb{Z}/p\\mathbb{Z})^{\\times}$ 的结构以及费马小定理，证明对于任意满足 $\\gcd(a,p)=1$ 的 $a$，值 $a^{(p-1)/2}$ 模 $p$ 必定同余于 $1$ 或 $-1$，并且证明该值等于 $1$ 当且仅当 $a$ 是模 $p$ 的二次剩余。然后，对于 $a=3$ 和 $p=43$，显式计算 $3^{(43-1)/2} \\bmod 43$ 以确定其符号，从而确定勒让德符号 $(\\frac{3}{43})$ 的值。请以单个整数形式提供最终答案。无需四舍五入。", "solution": "设 $p$ 为一个奇素数， $a$ 为一个整数且满足 $\\gcd(a,p)=1$。模 $p$ 整数乘法群，记作 $(\\mathbb{Z}/p\\mathbb{Z})^\\times$，其阶为 $p-1$。\n\n首先，我们将证明 $a^{(p-1)/2}$ 模 $p$ 必定同余于 $1$ 或 $-1$。\n根据费马小定理，对于任何不能被 $p$ 整除的整数 $a$，我们有 $a^{p-1} \\equiv 1 \\pmod{p}$。\n由于 $p$ 是一个奇素数，$p-1$ 是一个偶数，所以我们可以写成 $p-1 = 2 \\cdot \\frac{p-1}{2}$。\n该同余式可以改写为：\n$$ a^{2 \\cdot (p-1)/2} \\equiv 1 \\pmod{p} $$\n$$ \\left(a^{(p-1)/2}\\right)^2 \\equiv 1 \\pmod{p} $$\n设 $y = a^{(p-1)/2}$。则同余式为 $y^2 \\equiv 1 \\pmod{p}$，这意味着 $y^2 - 1 \\equiv 0 \\pmod{p}$。\n对左侧进行因式分解，我们得到 $(y-1)(y+1) \\equiv 0 \\pmod{p}$。\n因为 $p$ 是一个素数，如果它整除两个整数的乘积，那么它必须至少整除其中一个。因此，要么 $p \\mid (y-1)$，要么 $p \\mid (y+1)$。\n这等价于 $y \\equiv 1 \\pmod{p}$ 或 $y \\equiv -1 \\pmod{p}$。\n将 $y = a^{(p-1)/2}$ 代回，我们证明了 $a^{(p-1)/2} \\equiv 1 \\pmod{p}$ 或 $a^{(p-1)/2} \\equiv -1 \\pmod{p}$。\n\n接下来，我们将证明 $a^{(p-1)/2} \\equiv 1 \\pmod{p}$ 当且仅当 $a$ 是模 $p$ 的二次剩余。\n\n$(\\Rightarrow)$ 假设 $a$ 是模 $p$ 的二次剩余。根据所给定义，存在一个整数 $x$ 使得 $x^2 \\equiv a \\pmod{p}$。因为 $\\gcd(a,p)=1$，所以 $x$ 必不为 $p$ 的倍数，即 $\\gcd(x,p)=1$。\n用 $x^2$ 替换 $a$，我们有：\n$$ a^{(p-1)/2} \\equiv (x^2)^{(p-1)/2} \\equiv x^{p-1} \\pmod{p} $$\n根据费马小定理，因为 $\\gcd(x,p)=1$，我们有 $x^{p-1} \\equiv 1 \\pmod{p}$。\n因此，如果 $a$ 是模 $p$ 的二次剩余，那么 $a^{(p-1)/2} \\equiv 1 \\pmod{p}$。\n\n$(\\Leftarrow)$ 假设 $a^{(p-1)/2} \\equiv 1 \\pmod{p}$。我们必须证明 $a$ 是模 $p$ 的二次剩余。\n群 $(\\mathbb{Z}/p\\mathbb{Z})^\\times$ 是循环群。设 $g$ 是一个生成元（一个模 $p$ 的原根）。任何元素 $a \\in (\\mathbb{Z}/p\\mathbb{Z})^\\times$ 都可以写成 $a \\equiv g^k \\pmod{p}$ 的形式，其中 $k$ 是范围 $1 \\le k \\le p-1$ 内的唯一整数。\n条件 $a^{(p-1)/2} \\equiv 1 \\pmod{p}$ 变为 $(g^k)^{(p-1)/2} \\equiv 1 \\pmod{p}$，即 $g^{k(p-1)/2} \\equiv 1 \\pmod{p}$。\n由于 $g$ 是一个生成元，它的阶是 $p-1$。因此，$g^m \\equiv 1 \\pmod{p}$ 当且仅当 $p-1$ 整除 $m$。\n所以，$p-1$ 必须整除 $k(p-1)/2$。这意味着 $k/2$ 必须是一个整数，即 $k$ 必须是偶数。\n如果 $k$ 是偶数，比如说 $k=2j$ 对于某个整数 $j$，那么 $a \\equiv g^k \\equiv g^{2j} \\equiv (g^j)^2 \\pmod{p}$。\n如果我们令 $x = g^j$，那么我们就找到了一个整数 $x$ 使得 $x^2 \\equiv a \\pmod{p}$。根据定义，这意味着 $a$ 是模 $p$ 的二次剩余。\n综合这两个方向，我们证明了 $a^{(p-1)/2} \\equiv 1 \\pmod{p}$ 当且仅当 $a$ 是模 $p$ 的二次剩余。\n由此以及我们早先的结果可得，如果 $a$ 是模 $p$ 的二次非剩余，我们必定有 $a^{(p-1)/2} \\equiv -1 \\pmod{p}$。\n这个关系式 $a^{(p-1)/2} \\equiv (\\frac{a}{p}) \\pmod{p}$，被称为欧拉判别法。\n\n现在，我们将此准则应用于 $a=3$ 和 $p=43$ 的具体情况。我们需要计算 $3^{(43-1)/2} \\pmod{43}$，即 $3^{21} \\pmod{43}$。我们使用二进制幂（也称为平方求幂）。\n指数是 $21$。在二进制中，$21 = 16+4+1$，所以我们将计算 $3^{21} = 3^{16} \\cdot 3^4 \\cdot 3^1 \\pmod{43}$。\n首先，我们通过连续平方计算所需的 $3$ 的幂：\n$$ 3^1 \\equiv 3 \\pmod{43} $$\n$$ 3^2 \\equiv 9 \\pmod{43} $$\n$$ 3^4 \\equiv 9^2 = 81 \\equiv 81 - 43 = 38 \\equiv -5 \\pmod{43} $$\n$$ 3^8 \\equiv (3^4)^2 \\equiv (-5)^2 = 25 \\pmod{43} $$\n$$ 3^{16} \\equiv (3^8)^2 \\equiv 25^2 = 625 \\pmod{43} $$\n为了将 $625$ 对 $43$ 取模，我们进行带余除法：$625 = 14 \\times 43 + 23$。\n因此，$3^{16} \\equiv 23 \\pmod{43}$。\n现在我们组合 $3^{21}$ 的乘积：\n$$ 3^{21} = 3^{16} \\cdot 3^4 \\cdot 3^1 \\equiv 23 \\cdot (-5) \\cdot 3 \\pmod{43} $$\n首先，我们计算前两项的乘积：\n$$ 23 \\cdot (-5) = -115 \\pmod{43} $$\n为了将 $-115$ 对 $43$ 取模：$-115 = -3 \\times 43 + 14$，因为 $-3 \\times 43 = -129$。所以，$-115 \\equiv 14 \\pmod{43}$。\n现在我们乘以最后一项：\n$$ 3^{21} \\equiv 14 \\cdot 3 = 42 \\pmod{43} $$\n因为 $42 = 43 - 1$，我们有 $42 \\equiv -1 \\pmod{43}$。\n所以，我们发现 $3^{21} \\equiv -1 \\pmod{43}$。\n\n根据欧拉判别法，勒让德符号 $(\\frac{3}{43})$ 的值与 $3^{(43-1)/2}$ 模 $43$ 同余。\n因此，$(\\frac{3}{43}) \\equiv -1 \\pmod{43}$。\n对于 $\\gcd(a,p)=1$ 的情况，勒让德符号 $(\\frac{a}{p})$ 只能取值 $1$ 或 $-1$。该同余式唯一地确定了其值。\n因此，勒让德符号 $(\\frac{3}{43})$ 的值为 $-1$。", "answer": "$$ \\boxed{-1} $$", "id": "3084828"}, {"introduction": "勒让德符号是为素数模定义的，但当模是合数时会发生什么呢？这个练习 [@problem_id:3084835] 引入了雅可比符号，并探讨了一个关键的细微差别：雅可比符号值为1并不保证一个数是二次剩余。通过解决这个例子，你将学会领会雅可比符号、中国剩余定理以及合数模下二次剩余的精确定义之间的相互作用。", "problem": "设 $n=15$。对于每个满足 $1 \\leq a \\leq 14$ 且 $\\gcd(a,15)=1$ 的整数 $a$，计算雅可比符号 $\\left(\\frac{a}{15}\\right)$ 并通过求解 $x^{2} \\equiv a \\pmod{15}$ 来判断 $a$ 是否是模15的二次剩余。你的推理应从基本定义和已证实的结论出发：奇素数的勒让德符号的定义、奇素数的欧拉判别法、雅可比符号对其下方宗量的乘法性质，以及中国剩余定理 (CRT)。不要假设任何未从这些基础建立的性质。\n\n设 $F$ 为在此范围内（且 $\\gcd(a,15)=1$）的 $a$ 的值的数量，使得 $\\left(\\frac{a}{15}\\right)=1$ 但 $a$ 不是模15的二次剩余。请给出你的最终答案，即精确整数 $F$。", "solution": "问题要求在集合 $S = \\{a \\in \\mathbb{Z} \\mid 1 \\leq a \\leq 14, \\gcd(a,15)=1\\}$ 中，满足雅可比符号 $\\left(\\frac{a}{15}\\right)=1$ 但 $a$ 不是模15的二次剩余的整数 $a$ 的数量。设这个数量为 $F$。\n\n首先，我们确定集合 $S$。在1和14之间与15互质的整数 $a$ 是那些不能被3或5整除的数。这个集合是 $S = \\{1, 2, 4, 7, 8, 11, 13, 14\\}$。\n\n我们从指定的定义和定理开始。设 $n=15$。由于 $15 = 3 \\times 5$，其中3和5是不同的奇素数，我们可以通过考虑模3和模5的性质来分析模15的性质。\n\n1.  **雅可比符号**：对于一个整数 $a$ 和一个奇正整数 $n = p_1 p_2 \\dots p_k$ 其中 $p_i$ 是素数因子（不一定不同），雅可比符号被定义为相应勒让德符号的乘积：\n    $$ \\left(\\frac{a}{n}\\right) = \\left(\\frac{a}{p_1}\\right) \\left(\\frac{a}{p_2}\\right) \\dots \\left(\\frac{a}{p_k}\\right) $$\n    对于 $n=15$，雅可比符号是 $\\left(\\frac{a}{15}\\right) = \\left(\\frac{a}{3}\\right)\\left(\\frac{a}{5}\\right)$。\n\n2.  **二次剩余与中国剩余定理 (CRT)**：如果同余式 $x^2 \\equiv a \\pmod{15}$ 有解，则整数 $a$ 是模15的二次剩余。根据中国剩余定理，这个同余式等价于同余方程组：\n    $$\n    \\begin{cases}\n    x^2 \\equiv a \\pmod{3} \\\\\n    x^2 \\equiv a \\pmod{5}\n    \\end{cases}\n    $$\n    这个方程组有解当且仅当每个单独的同余式都有解。由于 $\\gcd(a,15)=1$，我们有 $\\gcd(a,3)=1$ 和 $\\gcd(a,5)=1$。单个同余式 $x^2 \\equiv a \\pmod{p}$ (对于素数 $p$) 有解，当且仅当 $a$ 是模 $p$ 的二次剩余，即勒让德符号 $\\left(\\frac{a}{p}\\right)=1$。\n    因此，$a$ 是模15的二次剩余，当且仅当 $a$ 是模3的二次剩余 并且 $a$ 是模5的二次剩余。这意味着：\n    $$ \\left(\\frac{a}{3}\\right) = 1 \\quad \\text{且} \\quad \\left(\\frac{a}{5}\\right) = 1 $$\n\n我们的任务是找到集合 $S$ 中满足以下条件的整数 $a$ 的数量：\n(i) $\\left(\\frac{a}{15}\\right) = 1$\n(ii) $a$ 不是模15的二次剩余。\n\n从条件 (i) 和雅可比符号的定义，我们有 $\\left(\\frac{a}{3}\\right)\\left(\\frac{a}{5}\\right) = 1$。这个等式成立的条件是两个勒让德符号都为1，或者都为-1。\n$$ \\left(\\left(\\frac{a}{3}\\right)=1 \\text{ 且 } \\left(\\frac{a}{5}\\right)=1\\right) \\quad \\text{或} \\quad \\left(\\left(\\frac{a}{3}\\right)=-1 \\text{ 且 } \\left(\\frac{a}{5}\\right)=-1\\right) $$\n从条件 (ii) 和我们使用 CRT 的分析，$a$ 不是模15的二次剩余意味着 $\\left(\\frac{a}{3}\\right)=1$ 和 $\\left(\\frac{a}{5}\\right)=1$ 不能同时成立。\n\n结合这两个要求，一个整数 $a$ 要同时满足这两个条件的唯一可能性是：\n$$ \\left(\\frac{a}{3}\\right) = -1 \\quad \\text{且} \\quad \\left(\\frac{a}{5}\\right) = -1 $$\n\n现在我们使用欧拉判别法将这些关于勒让德符号的条件转换成关于 $a$ 的同余关系。\n对于 $p=3$：\n$\\left(\\frac{a}{3}\\right) = -1 \\iff a^{(3-1)/2} \\equiv a^1 \\equiv -1 \\pmod{3}$。由于 $-1 \\equiv 2 \\pmod 3$，这等价于 $a \\equiv 2 \\pmod{3}$。\n\n对于 $p=5$：\n$\\left(\\frac{a}{5}\\right) = -1 \\iff a^{(5-1)/2} \\equiv a^2 \\equiv -1 \\pmod{5}$。模5的二次剩余是 $1^2 \\equiv 1$ 和 $2^2 \\equiv 4$。二次非剩余是2和3。因此，这等价于 $a \\equiv 2 \\pmod{5}$ 或 $a \\equiv 3 \\pmod{5}$。\n\n我们必须找到集合 $S$ 中满足这些同余条件的整数 $a$。这导致了两个同余方程组：\n\n方程组 1：\n$$\n\\begin{cases}\na \\equiv 2 \\pmod{3} \\\\\na \\equiv 2 \\pmod{5}\n\\end{cases}\n$$\n根据中国剩余定理 (CRT)，在模 $15$ 下存在唯一解。通过检验可得，解为 $a \\equiv 2 \\pmod{15}$。在集合 $S$ 中满足此条件的唯一整数是 $a=2$。\n对于 $a=2$，我们验证：$\\left(\\frac{2}{3}\\right) = -1$ 和 $\\left(\\frac{2}{5}\\right)=-1$。因此 $\\left(\\frac{2}{15}\\right)=(-1)(-1)=1$。然而，由于 $a$ 不是模 $3$ 的二次剩余，所以它也不是模 $15$ 的二次剩余。因此 $a=2$ 是一个符合题意的解。\n\n方程组 2：\n$$\n\\begin{cases}\na \\equiv 2 \\pmod{3} \\\\\na \\equiv 3 \\pmod{5}\n\\end{cases}\n$$\n从第一个同余式，有 $a = 3k+2$，其中 $k$ 为某个整数。将此代入第二个同余式：\n$$ 3k+2 \\equiv 3 \\pmod{5} \\implies 3k \\equiv 1 \\pmod{5} $$\n为了解出 $k$，我们乘以3模5的模逆元，即2（因为 $3 \\times 2 = 6 \\equiv 1 \\pmod{5}$）：\n$$ 2 \\times (3k) \\equiv 2 \\times 1 \\pmod{5} \\implies k \\equiv 2 \\pmod{5} $$\n所以 $k$ 可以写成 $k=5j+2$ 的形式，其中 $j$ 为某个整数。将此代回 $a$ 的表达式中：\n$$ a = 3(5j+2)+2 = 15j+6+2 = 15j+8 $$\n解为 $a \\equiv 8 \\pmod{15}$。在集合 $S$ 中满足此条件的唯一整数是 $a=8$。\n对于 $a=8$，我们验证：$8 \\equiv 2 \\pmod 3 \\implies \\left(\\frac{8}{3}\\right)=-1$。且 $8 \\equiv 3 \\pmod 5 \\implies \\left(\\frac{8}{5}\\right)=-1$。因此 $\\left(\\frac{8}{15}\\right)=(-1)(-1)=1$。然而，由于 $a$ 不是模 $3$ 的二次剩余，所以它也不是模 $15$ 的二次剩余。因此 $a=8$ 是第二个符合题意的解。\n\n综上，在指定范围内满足条件的整数为 $2$ 和 $8$。因此，符合条件的整数共有两个。\n因此，$F$ 的值为 $2$。", "answer": "$$\\boxed{2}$$", "id": "3084835"}, {"introduction": "当理论知识转化为高效的算法时，它将获得巨大的力量。本练习 [@problem_id:3084857] 挑战你通过设计并实现一个使用欧拉判别法计算勒让德符号的算法，来连接理论与计算。你不仅将通过二元幂算法（也称快速幂算法）将计算过程形式化，还将分析其计算效率，这是现代数论和密码学中的一项关键技能。", "problem": "设 $p$ 为一个奇素数，$a$ 为任意整数。目标是从基本原理出发，推导出一个使用平方求幂（repeated squaring）计算 $a^{\\frac{p-1}{2}} \\bmod p$ 的算法，并根据二次剩余的定义，确定勒让德符号（Legendre symbol）$\\left(\\frac{a}{p}\\right)$ 的值，其中 $\\left(\\frac{a}{p}\\right) \\in \\{-1,0,1\\}$。从以下基础概念开始：\n- 模 $p$ 的二次剩余（quadratic residue）的定义：如果存在一个整数 $x$ 使得 $x^2 \\equiv a \\pmod{p}$，则整数 $a$ 是模 $p$ 的二次剩余；否则 $a$ 是模 $p$ 的二次非剩余（quadratic non-residue）。\n- 勒让德符号的定义：如果 $p \\mid a$，则 $\\left(\\frac{a}{p}\\right) = 0$；如果 $a$ 是模 $p$ 的二次剩余且 $\\gcd(a,p)=1$（最大公约数，GCD），则 $\\left(\\frac{a}{p}\\right) = 1$；如果 $a$ 是模 $p$ 的二次非剩余，则 $\\left(\\frac{a}{p}\\right) = -1$。\n- 费马小定理（Fermat's little theorem）：对于任意满足 $\\gcd(a,p)=1$ 的整数 $a$，有 $a^{p-1} \\equiv 1 \\pmod{p}$。\n\n仅使用这些事实，推导为什么计算 $a^{\\frac{p-1}{2}} \\bmod p$ 足以判断 $a$ 是否为模 $p$ 的二次剩余，从而确定 $\\left(\\frac{a}{p}\\right)$ 的值。设计一个基于平方求幂（也称为二进制幂（binary exponentiation））的算法来计算 $a^{\\frac{p-1}{2}} \\bmod p$，并解释如何将输出映射到勒让德符号 $\\left(\\frac{a}{p}\\right)$ 的值。根据 $p$ 的比特长度（即 $\\log p$），分析算法的时间复杂度，明确给出模乘法（modular multiplication）的数量和整数乘法的成本模型。\n\n你的程序必须实现用于模幂运算的平方求幂算法，不得依赖任何内置的模幂运算快捷方式。对于每个测试用例，程序必须：\n- 计算 $r \\equiv a^{\\frac{p-1}{2}} \\bmod p$。\n- 根据定义，使用计算出的 $r$ 和模 $p$ 的剩余类，输出勒让德符号的值 $\\left(\\frac{a}{p}\\right)$。\n\n使用以下测试套件，它涵盖了一般情况、边界条件和重要的边缘情况：\n- $(p,a) = (\\,3,\\,2\\,)$,\n- $(p,a) = (\\,3,\\,0\\,)$,\n- $(p,a) = (\\,11,\\,5\\,)$,\n- $(p,a) = (\\,29,\\,7\\,)$,\n- $(p,a) = (\\,13,\\,-1\\,)$,\n- $(p,a) = (\\,101,\\,25\\,)$,\n- $(p,a) = (\\,29,\\,29\\,)$,\n- $(p,a) = (\\,1000000007,\\,2\\,)$.\n\n你的程序应生成单行输出，其中包含上述测试用例的勒让德符号值，以逗号分隔的整数列表形式，并用方括号括起来，顺序与列表中的顺序相同（例如，$[1,0,-1]$）。输出不涉及物理或角度单位，所有值均为整数。", "solution": "### 理论推导与算法设计\n\n核心任务是为一个奇素数 $p$ 和一个整数 $a$ 计算勒让德符号 $\\left(\\frac{a}{p}\\right)$ 的方法提供理论证明并加以实现。该问题要求基于勒让德符号的值与 $a^{\\frac{p-1}{2}}$ 模 $p$ 同余这一事实进行推导。此关系被称为欧拉判别法。\n\n我们将通过考虑 $\\left(\\frac{a}{p}\\right)$ 的三种可能值：$0$、$1$ 和 $-1$ 来推导该准则。\n\n**情况1：$\\left(\\frac{a}{p}\\right) = 0$**\n根据定义，$\\left(\\frac{a}{p}\\right) = 0$ 当且仅当 $p \\mid a$，这等价于 $a \\equiv 0 \\pmod{p}$。\n由于 $p$ 是一个奇素数，所以 $p \\geq 3$，这意味着指数 $\\frac{p-1}{2}$ 是一个正整数。\n因此，如果 $a \\equiv 0 \\pmod{p}$，则 $a^{\\frac{p-1}{2}} \\equiv 0^{\\frac{p-1}{2}} \\equiv 0 \\pmod{p}$。\n在这种情况下，欧拉判别法成立。\n\n**情况2：$\\left(\\frac{a}{p}\\right) = 1$**\n根据定义，$\\left(\\frac{a}{p}\\right) = 1$ 当且仅当 $a$ 是模 $p$ 的二次剩余且 $\\gcd(a,p)=1$。\n这意味着存在一个整数 $x$ 使得 $x^2 \\equiv a \\pmod{p}$。由于 $\\gcd(a,p)=1$，那么也必然有 $\\gcd(x,p)=1$（如果 $p \\mid x$，则 $p \\mid x^2$，这将意味着 $p \\mid a$）。\n根据费马小定理，由于 $\\gcd(x,p)=1$，我们有 $x^{p-1} \\equiv 1 \\pmod{p}$。\n现在我们将 $a$ 升到 $\\frac{p-1}{2}$ 次幂并对 $p$ 取模：\n$$\na^{\\frac{p-1}{2}} \\equiv (x^2)^{\\frac{p-1}{2}} \\equiv x^{2 \\cdot \\frac{p-1}{2}} \\equiv x^{p-1} \\pmod{p}\n$$\n代入 $x^{p-1} \\equiv 1 \\pmod{p}$，我们得到：\n$$\na^{\\frac{p-1}{2}} \\equiv 1 \\pmod{p}\n$$\n在这种情况下，欧拉判别法成立。\n\n**情况3：$\\left(\\frac{a}{p}\\right) = -1$**\n根据定义，$\\left(\\frac{a}{p}\\right) = -1$ 当且仅当 $a$ 是模 $p$ 的二次非剩余。这意味着 $\\gcd(a,p)=1$。\n根据费马小定理，由于 $\\gcd(a,p)=1$，我们有 $a^{p-1} \\equiv 1 \\pmod{p}$。\n这可以改写为 $a^{p-1} - 1 \\equiv 0 \\pmod{p}$。\n将左侧因式分解为平方差形式，得到：\n$$\n(a^{\\frac{p-1}{2}} - 1)(a^{\\frac{p-1}{2}} + 1) \\equiv 0 \\pmod{p}\n$$\n由于 $p$ 是素数，这意味着 $a^{\\frac{p-1}{2}} - 1 \\equiv 0 \\pmod{p}$ 或 $a^{\\frac{p-1}{2}} + 1 \\equiv 0 \\pmod{p}$。\n这意味着 $a^{\\frac{p-1}{2}}$ 模 $p$ 的结果必须同余于 $1$ 或 $-1$。\n从情况2我们知道，如果 $a$ 是一个二次剩余，则 $a^{\\frac{p-1}{2}} \\equiv 1 \\pmod{p}$。二次剩余的集合是多项式同余方程 $X^{\\frac{p-1}{2}} - 1 \\equiv 0 \\pmod{p}$ 的根。根据关于多项式同余的拉格朗日定理，该多项式模 $p$ 最多有 $\\frac{p-1}{2}$ 个根。根据群论中的一个已知结果（模 $p$ 的单位群 $\\mathbb{Z}_p^*$ 是循环群），恰好有 $\\frac{p-1}{2}$ 个二次剩余和 $\\frac{p-1}{2}$ 个二次非剩余。\n由于在这种情况下 $a$ 是一个二次非剩余，它不可能是 $X^{\\frac{p-1}{2}} - 1 \\equiv 0 \\pmod{p}$ 的根。因此，$a^{\\frac{p-1}{2}} \\equiv 1 \\pmod{p}$ 不成立。\n唯一剩下的可能性是：\n$$\na^{\\frac{p-1}{2}} \\equiv -1 \\pmod{p}\n$$\n在这种情况下，欧拉判别法成立。\n\n**结论（欧拉判别法）**\n综合以上三种情况，我们建立了以下关系：\n$$\n\\left(\\frac{a}{p}\\right) \\equiv a^{\\frac{p-1}{2}} \\pmod{p}\n$$\n其中模 $p$ 的幂运算结果若为 $p-1$，则被解释为 $-1$。这为计算勒让德符号提供了一种直接的计算方法。\n\n### 模幂运算算法（平方求幂）\n\n为了高效地计算 $r \\equiv a^{\\frac{p-1}{2}} \\pmod{p}$，我们使用平方求幂法（也称为二进制幂运算）。该算法避免了在取模之前计算 $a^{\\frac{p-1}{2}}$ 这个非常大的中间值。\n\n设底数为 $b$，指数为 $e$，模为 $m$。我们想计算 $b^e \\pmod{m}$。该算法通过考虑指数 $e$ 的二进制表示 $e = \\sum_{i=0}^{k} c_i 2^i$（其中 $c_i \\in \\{0, 1\\}$）来进行工作。\n计算过程如下：\n1. 初始化一个结果变量为 $1$。\n2. 将底数 $b$ 对 $m$ 取模。\n3. 当指数 $e > 0$ 时，进行迭代：\n   a. 如果当前指数 $e$ 是奇数（即，最后一位是 $1$），则将结果乘以当前的底数（对 $m$ 取模）。\n   b. 将指数右移一位（相当于整数除以 $2$），这实际上是从最低有效位到最高有效位处理比特。\n   c. 将底数平方（对 $m$ 取模）。这为处理指数的下一位做好了准备（例如，从 $b^{2^i}$ 到 $b^{2^{i+1}}$）。\n\n对于我们的问题，$b=a$，$e=\\frac{p-1}{2}$，$m=p$。\n\n### 映射到勒让德符号\n\n最终的算法如下：\n1. 给定 $a$ 和一个奇素数 $p$。首先，将 $a$ 对 $p$ 取模。让这个新值也为 $a$。即，$a \\leftarrow a \\pmod{p}$。\n2. 如果 $a=0$，则 $\\left(\\frac{a}{p}\\right)=0$。\n3. 如果 $a \\neq 0$，使用上面描述的平方求幂算法计算 $r = a^{\\frac{p-1}{2}} \\pmod{p}$。\n4. 根据推导：\n   - 如果 $r=1$，则 $\\left(\\frac{a}{p}\\right)=1$。\n   - 如果 $r=p-1$（即 $\\equiv -1 \\pmod{p}$），则 $\\left(\\frac{a}{p}\\right)=-1$。\n\n### 复杂度分析\n\n设 $n = \\log_2 p$ 为素数 $p$ 的比特长度。指数为 $E = \\frac{p-1}{2}$，其比特长度也大约为 $n$。\n\n1.  **模乘法次数**：平方求幂算法的主循环迭代次数与指数 $E$ 的比特数相同。迭代次数为 $\\lfloor \\log_2 E \\rfloor + 1 \\approx n$。在循环内部，总会执行一次模平方运算。仅当指数的对应比特为 $1$ 时，才会执行一次模乘法。在最坏情况下（所有比特都为 $1$），大约有 $n$ 次平方和 $n$ 次乘法，总共为 $2n$ 次模乘法。因此，模乘法的次数是 $O(\\log p)$。\n\n2.  **整数运算成本**：乘法中涉及的数都小于 $p$，所以它们的比特长度最多为 $n = \\lceil \\log_2 p \\rceil$。设 $M(n)$ 是两个 $n$ 比特整数相乘的时间复杂度。\n    - 使用标准的“教科书式”乘法算法，$M(n) = O(n^2)$。\n    - 一次模乘法 $(x \\cdot y) \\pmod p$ 包含一次整数乘法（成本为 $M(n)$）和一次带余数的整数除法，其成本相似，对于简单算法通常也是 $O(n^2)$。因此，一次模乘法的成本为 $O((\\log p)^2)$。\n\n3.  **总时间复杂度**：总时间复杂度是模乘法的次数乘以每次乘法的成本。\n    $$\n    \\text{复杂度} = O(\\log p) \\times (\\text{一次模乘法的成本})\n    $$\n    $$\n    \\text{复杂度} = O(\\log p) \\times O((\\log p)^2) = O((\\log p)^3)\n    $$\n    使用更快的整数乘法算法，如 Karatsuba 算法（$M(n) = O(n^{\\log_2 3})$），可以降低整体复杂度。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the Legendre symbol for a series of test cases using Euler's criterion\n    and a custom implementation of the repeated squaring algorithm.\n    \"\"\"\n\n    def custom_mod_pow(base, exp, mod):\n        \"\"\"\n        Computes (base^exp) % mod using repeated squaring (binary exponentiation).\n        This implementation is required by the problem statement and does not use\n        the built-in pow(base, exp, mod) function.\n        \"\"\"\n        result = 1\n        base = base % mod\n        while exp > 0:\n            # If exponent is odd, multiply base with result\n            if exp % 2 == 1:\n                result = (result * base) % mod\n            # Exponent must be even now, so we can halve it\n            exp = exp >> 1 # equivalent to exp // 2\n            # Square the base\n            base = (base * base) % mod\n        return result\n\n    def legendre_symbol(a, p):\n        \"\"\"\n        Computes the Legendre symbol (a/p) for an odd prime p.\n        (a/p) = 0 if p | a\n        (a/p) = 1 if a is a quadratic residue mod p and p does not divide a.\n        (a/p) = -1 if a is a quadratic non-residue mod p.\n        This is determined by computing a^((p-1)/2) mod p.\n        \"\"\"\n        # The problem statement guarantees p is an odd prime.\n        \n        # Reduce a modulo p. This handles large and negative inputs for a.\n        a = a % p\n        \n        # Case 1: (a/p) = 0 if a is a multiple of p\n        if a == 0:\n            return 0\n        \n        # Case 2  3: (a/p) is 1 or -1, determined by Euler's criterion.\n        exponent = (p - 1) // 2\n        result = custom_mod_pow(a, exponent, p)\n        \n        # According to the derived theory, the result must be 1 or p-1 (which is -1 mod p).\n        if result == 1:\n            return 1\n        else:\n            # The result must be p-1\n            return -1\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (3, 2),\n        (3, 0),\n        (11, 5),\n        (29, 7),\n        (13, -1),\n        (101, 25),\n        (29, 29),\n        (1000000007, 2),\n    ]\n\n    results = []\n    for p, a in test_cases:\n        # Main logic to calculate the result for one case goes here.\n        result = legendre_symbol(a, p)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3084857"}]}