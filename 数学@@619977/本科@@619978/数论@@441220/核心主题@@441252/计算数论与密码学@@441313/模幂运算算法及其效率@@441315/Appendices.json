{"hands_on_practices": [{"introduction": "这项练习结合了数论中的几个强大工具。当模数 $m$ 是一个合数时，计算 $a^e \\pmod{m}$ 的任务通常可以通过分解模数来简化。这个练习 [@problem_id:3087333] 将引导你使用中国剩余定理 (Chinese Remainder Theorem, CRT) 将一个大问题分解为多个更小、更易于管理的同余方程，然后使用模幂运算技巧来解决它们。这完美地展示了不同概念如何协同工作，从而高效地完成复杂计算。", "problem": "设 $m$ 是一个正整数模数，且 $a,b \\in \\mathbb{Z}$。回顾模运算的基本性质：如果 $a \\equiv b \\pmod{m}$，那么对于任意 $c \\in \\mathbb{Z}$，都有 $a+c \\equiv b+c \\pmod{m}$ 和 $ac \\equiv bc \\pmod{m}$，并且重复使用这些规则可以证明在计算的每一步将中间和与积对模 $m$ 进行约化是合理的。仅使用这些性质以及任何可以从第一性原理证明其陈述的初等数论中的标准定理（例如，欧拉定理和中国剩余定理），通过系统地将中间乘积模 $1000$ 进行约化，并解释每次约化的有效性，计算 $7^{123}$ 模 $1000$ 的最小非负余数。你的最终答案必须是 $\\{0,1,2,\\dots,999\\}$ 中的一个整数。", "solution": "问题是要求出 $7^{123}$ 模 $1000$ 的最小非负余数。设 $x = 7^{123}$。我们需要计算 $x \\pmod{1000}$。\n\n模数是 $m = 1000$。我们可以将模数分解为 $1000 = 10^3 = (2 \\cdot 5)^3 = 2^3 \\cdot 5^3 = 8 \\cdot 125$。因子 $m_1=8$ 和 $m_2=125$ 是互质的，即 $\\gcd(8, 125)=1$。这种结构提示我们可以使用中国剩余定理（CRT）。CRT提供了一种求解同余方程组的方法。具体来说，如果我们能求出 $7^{123}$ 模 $8$ 和模 $125$ 的余数，我们就可以将它们组合起来，求出模 $1000$ 的唯一解。使用CRT是合理的，因为它是初等数論中的一个标准定理，可以由问题陈述中提供的同余基本性质推导出来。\n\n我们将分别求解同余方程 $x \\equiv 7^{123} \\pmod{8}$ 和 $x \\equiv 7^{123} \\pmod{125}$。\n\n首先，我们计算 $7^{123} \\pmod{8}$。\n底数是 $7$。我们注意到 $7 \\equiv -1 \\pmod{8}$。问题陈述中提到，如果 $a \\equiv b \\pmod{m}$，那么 $ac \\equiv bc \\pmod{m}$。对任意正整数指数 $k$ 重复应用此性质，我们可以得出结论 $a^k \\equiv b^k \\pmod{m}$。将此应用于我们的情况：\n$$7^{123} \\equiv (-1)^{123} \\pmod{8}$$\n由于 $123$ 是奇数，所以 $(-1)^{123} = -1$。\n因此，\n$$7^{123} \\equiv -1 \\equiv 7 \\pmod{8}$$\n\n其次，我们计算 $7^{123} \\pmod{125}$。\n模数是 $125 = 5^3$。由于 $\\gcd(7, 125) = 1$，我们可以应用欧拉定理。该定理是合理的，因为它是将拉格朗日定理应用于模 $m$ 整数乘法群 $(\\mathbb{Z}/m\\mathbb{Z})^\\times$ 的直接结果，该群的阶由欧拉函数 $\\phi(m)$ 给出。对于任何与 $m$ 互质的 $a$，有 $a^{\\phi(m)} \\equiv 1 \\pmod{m}$。\n对于素数幂 $p^k$，欧拉函数由 $\\phi(p^k) = p^k - p^{k-1}$ 给出。在我们的例子中，$m=125=5^3$，所以\n$$\\phi(125) = \\phi(5^3) = 5^3 - 5^{3-1} = 125 - 25 = 100$$\n根据欧拉定理，我们有 $7^{\\phi(125)} \\equiv 7^{100} \\equiv 1 \\pmod{125}$。\n我们可以利用这个结果来简化指数 $123$。\n$$7^{123} = 7^{100} \\cdot 7^{23}$$\n$$7^{123} \\equiv 1 \\cdot 7^{23} \\equiv 7^{23} \\pmod{125}$$\n这一步是有效的，因为我们可以对乘积中的因子进行模 $m$ 约化。\n现在，我们必须计算 $7^{23} \\pmod{125}$。我们使用平方求幂法，该方法系统地对中间乘积进行模 $125$ 约化。每一步约化的有效性同样由以下性质保证：如果 $a \\equiv b \\pmod m$ 且 $c \\equiv d \\pmod m$，那么 $ac \\equiv bd \\pmod m$。\n我们来计算 $7$ 的各次幂模 $125$ 的值：\n$$7^1 \\equiv 7 \\pmod{125}$$\n$$7^2 = 49 \\equiv 49 \\pmod{125}$$\n$$7^4 = (7^2)^2 \\equiv 49^2 = 2401 \\pmod{125}$$\n由于 $2401 = 19 \\cdot 125 + 26$，我们有 $7^4 \\equiv 26 \\pmod{125}$。\n$$7^8 = (7^4)^2 \\equiv 26^2 = 676 \\pmod{125}$$\n由于 $676 = 5 \\cdot 125 + 51$，我们有 $7^8 \\equiv 51 \\pmod{125}$。\n$$7^{16} = (7^8)^2 \\equiv 51^2 = 2601 \\pmod{125}$$\n由于 $2601 = 20 \\cdot 125 + 101$，我们有 $7^{16} \\equiv 101 \\pmod{125}$。\n要计算 $7^{23}$，我们可以将指数分解为 $23 = 16+4+3$。一个更直接的方法是注意到 $23=20+3$。让我们来计算 $7^{20}$：\n$$7^{20} = 7^{16} \\cdot 7^4 \\equiv 101 \\cdot 26 \\pmod{125}$$\n乘积为 $101 \\cdot 26 = 2626$。由于 $2626 = 21 \\cdot 125 + 1$，我们有 $7^{20} \\equiv 1 \\pmod{125}$。\n现在我们可以如下计算 $7^{23}$：\n$$7^{23} = 7^{20} \\cdot 7^3 \\equiv 1 \\cdot 7^3 \\equiv 7^3 \\pmod{125}$$\n我们计算 $7^3$：\n$$7^3 = 7 \\cdot 7^2 = 7 \\cdot 49 = 343$$\n由于 $343 = 2 \\cdot 125 + 93$，我们有 $7^3 \\equiv 93 \\pmod{125}$。\n因此，$7^{23} \\equiv 93 \\pmod{125}$。这意味着 $7^{123} \\equiv 93 \\pmod{125}$。\n\n现在我们为 $x = 7^{123}$ 建立了以下同余方程组：\n$$\n\\begin{cases}\nx \\equiv 7 \\pmod{8} \\\\\nx \\equiv 93 \\pmod{125}\n\\end{cases}\n$$\n从第二个同余方程，我们知道 $x$ 必须是 $x = 125k + 93$ 的形式，其中 $k$ 是某个整数。我们将这个表达式代入第一个同余方程：\n$$125k + 93 \\equiv 7 \\pmod{8}$$\n为了解出 $k$，我们首先将系数对模 $8$ 进行约化：\n$125 = 15 \\cdot 8 + 5 \\implies 125 \\equiv 5 \\pmod{8}$。\n$93 = 11 \\cdot 8 + 5 \\implies 93 \\equiv 5 \\pmod{8}$。\n同余方程变为：\n$$5k + 5 \\equiv 7 \\pmod{8}$$\n两边同时减去 $5$：\n$$5k \\equiv 2 \\pmod{8}$$\n为了分离出 $k$，我们需要乘以 $5$ 模 $8$ 的乘法逆元。通过检验，$5 \\cdot 5 = 25 = 3 \\cdot 8 + 1$，所以 $5^{-1} \\equiv 5 \\pmod{8}$。两边同时乘以 $5$：\n$$5 \\cdot (5k) \\equiv 5 \\cdot 2 \\pmod{8}$$\n$$25k \\equiv 10 \\pmod{8}$$\n$$k \\equiv 2 \\pmod{8}$$\n这意味着 $k$ 可以写成 $k = 8j + 2$ 的形式，其中 $j$ 是某个整数。我们将它代回 $x$ 的表达式中：\n$$x = 125(8j + 2) + 93$$\n$$x = 125 \\cdot 8j + 125 \\cdot 2 + 93$$\n$$x = 1000j + 250 + 93$$\n$$x = 1000j + 343$$\n这意味着 $x \\equiv 343 \\pmod{1000}$。\n$7^{123}$ 模 $1000$ 的最小非负余数是 $343$，它在所要求的集合 $\\{0,1,2,\\dots,999\\}$ 中。", "answer": "$$\\boxed{343}$$", "id": "3087333"}, {"introduction": "平方-乘算法是模算术中快速计算大整数幂的基本方法。其效率源于对指数的二进制表示进行处理。这项练习 [@problem_id:3087367] 要求你手动追踪该算法的从左到右版本，让你清晰地、亲手地理解指数的每一位如何决定模平方和模乘法的具体序列。", "problem": "在模算术中，可以通过处理指数的二进制展开，并结合模平方和模乘法来高效地计算重复幂运算。该方法基于模 $n$ 同余的定义、整数的二进制表示，以及模 $n$ 乘法群中乘法的封闭性。使用从左到右平方乘 (LTR) 方法，该方法从最高有效位到最低有效位扫描指数的二进制位，计算 $3^{1001}$ 模 $437$ 的余数。您必须明确列出由 $1001$ 的二进制展开的各位所决定的每个平方和乘法步骤，并在每一步中指明是否发生了乘法。将最终余数表示为集合 $\\{0,1,2,\\dots,436\\}$ 中的一个整数。不需要四舍五入。", "solution": "该计算基于两个基本事实：(i) 对于整数 $a$、$b$ 和 $n$，如果 $a \\equiv b \\pmod{n}$，那么 $a \\cdot c \\equiv b \\cdot c \\pmod{n}$ 且 $a^{2} \\equiv b^{2} \\pmod{n}$；(ii) 每个正整数都有唯一的二进制展开，这使得幂运算可以分解为一系列平方和条件乘法。\n\n我们应用从左到右平方乘 (LTR) 方法。将指数 $e = 1001$ 写成二进制形式。计算其二进制展开：\n$$\n1001_{10} = 1111101001_{2},\n$$\n其从最高有效位到最低有效位的二进制位为 $b_{9} = 1$、$b_{8} = 1$、$b_{7} = 1$、$b_{6} = 1$、$b_{5} = 1$、$b_{4} = 0$、$b_{3} = 1$、$b_{2} = 0$、$b_{1} = 0$、$b_{0} = 1$。\n\nLTR 过程从最高位开始初始化。由于 $b_{9} = 1$，设\n$$\nc \\leftarrow 3 \\bmod 437.\n$$\n对于从 $i = 8$ 到 $i = 0$ 的每个后续位 $b_{i}$，执行一次模平方 $c \\leftarrow c^{2} \\bmod 437$；如果 $b_{i} = 1$，则再执行一次模乘法 $c \\leftarrow c \\cdot 3 \\bmod 437$。\n\n我们明确列出这些步骤：\n\n- 位 $b_{8} = 1$：\n  - 平方：$c \\leftarrow 3^{2} \\bmod 437 = 9$。\n  - 乘法：$c \\leftarrow 9 \\cdot 3 \\bmod 437 = 27$。\n\n- 位 $b_{7} = 1$：\n  - 平方：$c \\leftarrow 27^{2} \\bmod 437 = 729 \\bmod 437 = 292$ (因为 $729 - 437 = 292$)。\n  - 乘法：$c \\leftarrow 292 \\cdot 3 \\bmod 437 = 876 \\bmod 437 = 2$ (因为 $876 - 2 \\cdot 437 = 2$)。\n\n- 位 $b_{6} = 1$：\n  - 平方：$c \\leftarrow 2^{2} \\bmod 437 = 4$。\n  - 乘法：$c \\leftarrow 4 \\cdot 3 \\bmod 437 = 12$。\n\n- 位 $b_{5} = 1$：\n  - 平方：$c \\leftarrow 12^{2} \\bmod 437 = 144$。\n  - 乘法：$c \\leftarrow 144 \\cdot 3 \\bmod 437 = 432$。\n\n- 位 $b_{4} = 0$：\n  - 平方：$c \\leftarrow 432^{2} \\bmod 437$。注意 $432 \\equiv -5 \\pmod{437}$，所以 $432^{2} \\equiv (-5)^{2} = 25 \\pmod{437}$。因此 $c \\leftarrow 25$。\n  - 无乘法。\n\n- 位 $b_{3} = 1$：\n  - 平方：$c \\leftarrow 25^{2} \\bmod 437 = 625 \\bmod 437 = 188$ (因为 $625 - 437 = 188$)。\n  - 乘法：$c \\leftarrow 188 \\cdot 3 \\bmod 437 = 564 \\bmod 437 = 127$ (因为 $564 - 437 = 127$)。\n\n- 位 $b_{2} = 0$：\n  - 平方：$c \\leftarrow 127^{2} \\bmod 437$。计算 $127^{2} = 16129$。因为 $437 \\cdot 36 = 15732$，余数为 $16129 - 15732 = 397$。因此 $c \\leftarrow 397$。\n  - 无乘法。\n\n- 位 $b_{1} = 0$：\n  - 平方：$c \\leftarrow 397^{2} \\bmod 437$。注意 $397 \\equiv -40 \\pmod{437}$，所以 $397^{2} \\equiv (-40)^{2} = 1600 \\pmod{437}$。因为 $437 \\cdot 3 = 1311$，余数为 $1600 - 1311 = 289$。因此 $c \\leftarrow 289$。\n  - 无乘法。\n\n- 位 $b_{0} = 1$：\n  - 平方：$c \\leftarrow 289^{2} \\bmod 437$。计算 $289^{2} = 83521$。因为 $437 \\cdot 191 = 83467$，余数为 $83521 - 83467 = 54$。因此 $c \\leftarrow 54$。\n  - 乘法：$c \\leftarrow 54 \\cdot 3 \\bmod 437 = 162$。\n\n因此，\n$$\n3^{1001} \\bmod 437 = 162.\n$$\n\n作为使用中国剩余定理 (CRT) 的一致性检验，注意 $437 = 19 \\cdot 23$，其中 $\\varphi(19) = 18$ 且 $\\varphi(23) = 22$，以及 $\\gcd(3,437) = 1$。那么\n$$\n3^{1001} \\equiv 3^{11} \\pmod{19} \\quad \\text{且} \\quad 3^{1001} \\equiv 3^{11} \\pmod{23},\n$$\n因为 $1001 \\equiv 11 \\pmod{18}$ 且 $1001 \\equiv 11 \\pmod{22}$。可以算出 $3^{11} \\equiv 10 \\pmod{19}$ 且 $3^{11} \\equiv 1 \\pmod{23}$。解方程组\n$$\nx \\equiv 10 \\pmod{19}, \\quad x \\equiv 1 \\pmod{23}\n$$\n得到 $x = 162$，这与计算出的余数相匹配。\n\nLTR 计算使用了 $9$ 次模平方（除最高位外的每一位一次）和 $6$ 次模乘法（除最高位外，每一位为 $1$ 的位一次），这说明了其效率与指数的位长度和汉明权重有关。", "answer": "$$\\boxed{162}$$", "id": "3087367"}, {"introduction": "虽然标准的二进制方法相比于朴素的幂运算已经是一个巨大的飞跃，但我们能做得更好吗？这项练习 [@problem_id:3087355] 介绍了滑动窗口法，这是一种更高级的算法，它通过一次性处理指数的多个比特来优化性能。通过实现基准的二进制算法和滑动窗口法，你不仅将解决幂运算问题，还将进行直接的成本比较，从而量化地理解算法优化如何带来切实的效率提升。", "problem": "设计并实现一个程序，用于计算模幂运算，并在一个清晰、可复现的成本模型下比较算法效率。您必须实现两种计算 $a^e \\bmod m$ 余数的算法：\n\n1. 一种基准的从左到右二进制方法（也称为从最高有效位开始扫描的重复平方法）。\n2. 一种窗口大小固定为 $w = 5$ 的从左到右滑动窗口方法。\n\n从数论和算术的以下基本事实开始：\n- 对于整数 $a$、$b$ 和正模数 $m$，取模性质 $(ab) \\bmod m = \\big((a \\bmod m)(b \\bmod m)\\big) \\bmod m$ 成立。\n- 如果 $e$ 是一个非负整数，其二进制展开式为 $e = \\sum_{i=0}^{L-1} b_i 2^i$，其中每个 $b_i \\in \\{0,1\\}$ 并且当 $e > 0$ 时 $b_{L-1} = 1$，那么 $a^e$ 可以通过由比特 $b_i$ 指导的平方和乘法构建。\n- 两种算法都必须纯粹用模 $m$ 的模乘法和模约简来表示。\n\n要实现的成本模型和计数规则：\n- 将每次模 $m$ 的模乘法计为单位成本 $1$。这包括平方，因为平方是乘法的一种特殊情况。\n- 对于基准二进制方法：没有预计算成本。该方法从最高有效位到最低有效位扫描 $e$ 的比特。对于每个比特，首先将当前累加器模 $m$ 平方，然后，如果该比特为 $1$，则乘以底数模 $m$。对于 $e = 0$，直接返回 $1$，成本为零。\n- 对于窗口大小 $w = 5$ 的滑动窗口方法：\n  - 如果 $e = 0$，直接返回 $1$，成本为零，并跳过预计算。\n  - 预计算底数的奇数次幂，直到小于 $2^w$ 的最大奇数：为每个奇数 $u$（满足 $1 \\le u  2^w$）存储 $a^u \\bmod m$。使用递推关系 $a^1 \\bmod m = a \\bmod m$，计算 $a^2 \\bmod m$，然后对于 $u = 3,5,\\dots,2^w-1$，通过乘以 $a^2 \\bmod m$ 从先前的值计算 $a^u \\bmod m$。计算此预计算中的每一次模乘法。\n  - 从最高有效位到最低有效位扫描 $e$ 的比特。当遇到一个 $0$ 比特时，对累加器进行一次模 $m$ 平方。当在位置 $i$ 遇到一个 $1$ 比特时，选择从 $i$ 开始的长度为 $\\ell \\le w$ 的最长比特窗口，使得窗口的最后一位是 $1$；将该窗口解释为 $\\{1,3,\\dots,2^w-1\\}$ 中的一个奇整数 $u$；对累加器执行 $\\ell$ 次平方，然后与预计算的 $a^u \\bmod m$ 进行一次乘法；前进 $\\ell$ 个比特。计算所有的模乘法，包括用于平方的乘法和与 $a^u \\bmod m$ 的乘法。\n\n您的程序必须：\n- 完全按照上述规定实现两种算法，并返回计算出的余数以及在给定成本模型下的总模乘法计数。\n- 对于每个测试用例，使用两种方法计算余数，并验证余数是否一致。\n- 对于每个测试用例，报告基准成本、滑动窗口成本以及观察到的加速比，加速比定义为比率 $\\text{speedup} = \\dfrac{\\text{基准成本}}{\\text{滑动窗口成本}}$。如果两种成本都为零，则将加速比定义为 $1.0$。\n\n要实现和评估的测试套件：\n- 案例 A (主要): $a = 13$, $e = 1234567$, $m = 10^9 + 7$, $w = 5$。\n- 案例 B (边界指数): $a = 13$, $e = 0$, $m = 10^9 + 7$, $w = 5$。\n- 案例 C (小指数): $a = 13$, $e = 1$, $m = 10^9 + 7$, $w = 5$。\n- 案例 D (幂等底数): $a = 1$, $e = 987654321$, $m = 10^9 + 7$, $w = 5$。\n- 案例 E (混合比特指数): $a = 123456789$, $e = 2^{20} + 123$, $m = 10^9 + 7$, $w = 5$。\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含一个以逗号分隔的列表的列表，用方括号括起来，不含空格。每个内部列表必须具有 $[v,b,w,s]$ 的形式，其中：\n  - $v$ 是公共余数 $a^e \\bmod m$（整数），\n  - $b$ 是基准模乘法计数（整数），\n  - $w$ 是滑动窗口模乘法计数（整数），\n  - $s$ 是加速比（浮点数，四舍五入到六位小数）。\n- 对于五个测试用例 A 到 E，输出必须是单行形式\n  $[[v_A,b_A,w_A,s_A],[v_B,b_B,w_B,s_B],[v_C,b_C,w_C,s_C],[v_D,b_D,w_D,s_D],[v_E,b_E,w_E,s_E]]$。\n\n此任务不涉及物理单位、角度单位或百分比；所有输出均为指定的纯数字。", "solution": "问题要求实现并比较两种模幂算法的效率：一种基准的从左到右二进制方法和一种窗口大小固定为 $w=5$ 的从左到右滑动窗口方法。比较将在一个特定的成本模型下进行，其中每次模乘法（包括平方）贡献单位成本 $1$。\n\n### 问题验证\n对问题陈述进行有效性分析。\n\n**步骤 1：提取已知条件**\n- **算法**：\n  1.  **基准二进制方法**：计算 $a^e \\pmod m$。对于 $e0$，从最高有效位到最低有效位遍历 $e$ 的比特。对于每个比特，首先将累加器平方，如果该比特为 $1$，则乘以 $a$。对于 $e=0$，结果为 $1$。\n  2.  **滑动窗口方法 ($w=5$)**：计算 $a^e \\pmod m$。对于 $e0$，首先预计算所有在 $[1, 2^w-1]$ 范围内的奇数 $u$ 对应的 $a^u \\pmod m$。然后，扫描 $e$ 的比特。对于 '0'，将累加器平方。对于 '1'，找到以 '1' 结尾且长度 $\\ell \\le w$ 的最长有效窗口，执行 $\\ell$ 次平方，并乘以预计算的幂。对于 $e=0$，结果为 $1$。\n- **成本模型**：\n  - 每次模乘法或平方的成本为 $1$。\n  - **基准成本**：幂运算循环中乘法和平方的总和。对于 $e=0$，成本为 $0$。\n  - **滑动窗口成本**：预计算和幂运算成本的总和。对于 $e=0$，成本为 $0$。\n- **测试套件**：提供了五个测试用例（A-E），包含 $a$、$e$ 和 $m$ 的值。\n- **输出**：一个单行字符串，表示一个列表的列表，其中每个内部列表为 $[v, b, w, s]$，分别对应余数、基准成本、滑动窗口成本和加速比 ($b/w$)。\n\n**步骤 2：使用提取的已知条件进行验证**\n- **科学依据**：该问题在数论和算法分析方面有充分的依据。所描述的模算术性质和幂运算算法是标准且正确的。\n- **适定性**：问题被完全指定。所有输入、算法步骤和成本计算规则都得到了明确的定义。每个测试用例都存在唯一、确定性的解。\n- **客观性**：问题以精确、客观的语言陈述，不含主观断言。\n- **缺陷分析**：\n  - 问题在科学上是合理的，并且可以形式化。\n  - 设置是完整且内部一致的。基准算法的描述（“在每个比特处，首先平方...”）是具体的，对于一个比特长度为 $L$、汉明重量（置位比特数）为 $\\text{popcount}(e)$ 的指数，其成本恰好为 $L + \\text{popcount}(e)$，这是二进制方法的一个有效但略非最优的变体。\n  - 滑动窗口算法的描述，包括预计算和窗口查找规则，也是精确的，可以直接实现。\n  - 该问题既不简单也非同义反复；它提出了一个实质性的实现和分析任务。\n\n**步骤 3：结论与行动**\n该问题被判定为**有效**。这是一个在计算数论领域中适定且有科学依据的问题。将按规定进行求解。\n\n### 算法设计与实现\n\n**1. 基准从左到右二进制方法**\n\n该方法基于 $e$ 的二进制表示来计算 $a^e \\pmod m$。设 $e = (b_{L-1} b_{L-2} \\dots b_0)_2$。\n\n- **初始化**：如果 $e=0$，结果为 $1$，成本为 $0$。否则，累加器 `result` 初始化为 $1$，成本为 $0$。\n- **迭代**：算法从最高有效位 ($b_{L-1}$) 到最低有效位 ($b_0$) 迭代 $L$ 次。在每个步骤 $i$ 中：\n    1.  累加器平方：`result = (result * result) % m`。这会使成本增加 $1$。\n    2.  如果当前比特 $b_{L-1-i}$ 为 $1$，则累加器乘以底数：`result = (result * a) % m`。这也会使成本增加 $1$。\n- **成本分析**：设 $L$ 为 $e$ 的比特长度，$\\text{popcount}(e)$ 为置位比特的数量，循环执行 $L$ 次平方和 $\\text{popcount}(e)$ 次乘法。总成本为 $L + \\text{popcount}(e)$。\n\n**2. 从左到右滑动窗口方法 ($w=5$)**\n\n该方法通过一次处理多个比特（一个“窗口”）来改进二进制方法。\n\n- **初始化**：如果 $e=0$，结果为 $1$，成本为 $0$。\n- **预计算 ($w=5$)**：对于 $e0$，我们预计算 $a$ 的奇数次幂。\n    1.  计算 $a^2 \\pmod m$。成本：$1$。\n    2.  预计算幂的表格填充有 $a^1, a^3, \\dots, a^{31}$。\n    3.  $a^1 \\pmod m$ 是给定的。\n    4.  后续的奇数次幂 $a^u \\pmod m$ 通过 $a^u = a^{u-2} \\cdot a^2 \\pmod m$ 计算。对于 $u \\in \\{3, 5, \\dots, 31\\}$，共有 $15$ 次这样的乘法。\n    5.  总预计算成本：$1 + 15 = 16$。\n- **幂运算**：从左到右扫描 $e$ 的二进制字符串。\n    - 如果当前比特为 $0$，则将累加器平方，并前进一个位置。成本：$1$ 次平方。\n    - 如果当前比特为 $1$，我们找到从当前位置开始、长度为 $\\ell \\le w$ 的最长可能窗口，其值代表一个奇数（即其最后一位是 $1$）。此窗口对应于一个已预计算的奇数次幂 $a^u$。然后将累加器平方 $\\ell$ 次，接着与预计算的 $a^u \\pmod m$ 进行一次乘法。然后我们前进 $\\ell$ 个位置。成本：$\\ell$ 次平方和 $1$ 次乘法。\n- **成本分析**：平方的总次数始终等于指数的比特长度 $L$。额外乘法的次数等于找到的窗口数。总滑动窗口成本是预计算成本和幂运算成本之和：$16 + L + (\\text{窗口数量})$。\n\n**3. 程序结构**\n\n解决方案被封装在一个 `solve` 函数中。两个辅助函数 `baseline_binary_method` 和 `sliding_window_method` 实现了上述逻辑。主函数遍历测试套件，调用两个辅助函数，验证计算出的余数是否匹配，计算加速比，并按要求格式化输出字符串。加速比定义为基准成本与滑动窗口成本的比率。如果两个成本都为零（仅当 $e=0$ 时），则加速比定义为 $1.0$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Implements and compares two modular exponentiation algorithms\n    based on the problem specification.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (a, e, m, w)\n        (13, 1234567, 10**9 + 7, 5),          # Case A\n        (13, 0, 10**9 + 7, 5),                # Case B\n        (13, 1, 10**9 + 7, 5),                # Case C\n        (1, 987654321, 10**9 + 7, 5),         # Case D\n        (123456789, 2**20 + 123, 10**9 + 7, 5) # Case E\n    ]\n\n    def baseline_binary_method(a, e, m):\n        \"\"\"\n        Computes (a^e mod m) using the specified baseline left-to-right binary method.\n        Returns the result and the total cost in modular multiplications.\n        \"\"\"\n        if e == 0:\n            return 1, 0\n\n        a_mod = a % m\n        e_bin = bin(e)[2:]\n        e_len = len(e_bin)\n        \n        cost = 0\n        result = 1\n        \n        for i in range(e_len):\n            # Square\n            result = (result * result) % m\n            cost += 1\n            # Multiply if bit is 1\n            if e_bin[i] == '1':\n                result = (result * a_mod) % m\n                cost += 1\n        \n        return result, cost\n\n    def sliding_window_method(a, e, m, w):\n        \"\"\"\n        Computes (a^e mod m) using the specified left-to-right sliding-window method.\n        Returns the result and the total cost in modular multiplications.\n        \"\"\"\n        if e == 0:\n            return 1, 0\n\n        a_mod = a % m\n        \n        # --- Precomputation Step ---\n        precomp_cost = 0\n        precomputed_powers = {}\n        \n        # a^1 is the base\n        precomputed_powers[1] = a_mod\n        \n        # Compute a^2\n        if w = 2:\n            a_sq = (a_mod * a_mod) % m\n            precomp_cost += 1\n        \n        # Compute odd powers a^3, a^5, ..., a^(2^w - 1)\n        # using u_i = u_{i-1} * a^2\n        limit = 2**w\n        for u in range(3, limit, 2):\n            prev_u_power = precomputed_powers[u-2]\n            current_u_power = (prev_u_power * a_sq) % m\n            precomp_cost += 1\n            precomputed_powers[u] = current_u_power\n            \n        # --- Exponentiation Step ---\n        exp_cost = 0\n        result = 1\n        \n        e_bin = bin(e)[2:]\n        e_len = len(e_bin)\n        i = 0\n        while i  e_len:\n            if e_bin[i] == '0':\n                # Process a zero bit: one squaring\n                result = (result * result) % m\n                exp_cost += 1\n                i += 1\n            else:\n                # Process a one bit: find longest valid window\n                search_end = min(i + w, e_len)\n                window_end_idx = i # Default to a 1-bit window\n                \n                # Find the end of the longest valid window (must end in '1')\n                # by searching backwards from the end of the potential window area.\n                for j in range(search_end - 1, i - 1, -1):\n                    if e_bin[j] == '1':\n                        window_end_idx = j\n                        break\n                \n                l = window_end_idx - i + 1\n                window_str = e_bin[i : window_end_idx + 1]\n                u = int(window_str, 2)\n                \n                # Perform l squarings\n                for _ in range(l):\n                    result = (result * result) % m\n                    exp_cost += 1\n                \n                # Perform one multiplication by the precomputed odd power\n                result = (result * precomputed_powers[u]) % m\n                exp_cost += 1\n                \n                i += l\n                \n        total_cost = precomp_cost + exp_cost\n        return result, total_cost\n\n    results_data = []\n    for case in test_cases:\n        a, e, m, w_val = case\n\n        v_base, b = baseline_binary_method(a, e, m)\n        v_win, w_cost = sliding_window_method(a, e, m, w_val)\n        \n        # This assertion verifies correctness; it should always pass for a correct implementation.\n        if v_base != v_win:\n             raise ValueError(f\"Mismatch in results for case {case}: base={v_base}, win={v_win}\")\n\n        if b == 0 and w_cost == 0:\n            s = 1.0\n        else:\n            # Avoid division by zero, though w_cost should not be 0 if b is not 0\n            s = round(b / w_cost, 6) if w_cost  0 else float('inf')\n\n        results_data.append(f\"[{v_base},{b},{w_cost},{s}]\")\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results_data)}]\")\n\nsolve()\n```", "id": "3087355"}]}