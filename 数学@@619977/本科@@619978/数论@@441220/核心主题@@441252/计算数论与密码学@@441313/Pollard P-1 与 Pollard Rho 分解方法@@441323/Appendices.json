{"hands_on_practices": [{"introduction": "要真正理解Pollard Rho算法，没有什么比一步步地亲自演算更能加深理解了。本练习要求您在一个小的合数上，使用Floyd判圈法手动运行该算法。通过追踪“乌龟”和“兔子”序列，您将亲眼见证在一个未知的素因子$p$模下发生的一次碰撞$x_k \\equiv y_k \\pmod{p}$，是如何通过一个简单的最大公约数（GCD）计算 $\\gcd(|x_k - y_k|, n)$ 来揭示原数的一个非平凡因子的。[@problem_id:3088119]", "problem": "设 $n$ 是合数 $697$。考虑使用多项式映射 $f(x) \\equiv x^{2} + 1 \\pmod{n}$ 和初始种子 $x_{0} = 2$ 的 Pollard rho 分解算法。通过生成两个序列 $(x_{k})$ 和 $(y_{k})$ 来实现 Floyd 判圈算法（Floyd），其定义为 $x_{k+1} \\equiv f(x_{k}) \\pmod{n}$ 和 $y_{k+1} \\equiv f(f(y_{k})) \\pmod{n}$，初始值均为 $x_{0} = y_{0} = 2$。在每次迭代 $k \\geq 1$ 时，计算最大公约数 (GCD)，$d_{k} = \\gcd(|x_{k} - y_{k}|, n)$。\n\n仅使用模算术的基本性质和最大公约数的定义，证明为何一旦迭代项的余数在模 $n$ 的一个素因子下重合，即使它们在模 $n$ 下不重合，该过程也能揭示 $n$ 的一个非平凡因子。然后，对连续的迭代显式地运行该算法，展示 $x_{k}$、$y_{k}$ 和 $d_{k}$ 的值，直到第一次迭代出现 $1  d_{k}  n$。\n\n给出你最终的答案，即由此发现的第一个非平凡因子的精确整数值。无需四舍五入。", "solution": "该问题是有效的，因为它提出了一个定义明确的数学任务，该任务基于数论中已建立的原理，即用于整数分解的 Pollard rho 算法。所提供的整数、函数和初始条件是完整且一致的，可以得到唯一的解。\n\n首先，我们将提供该过程为何有效的理论证明。设 $n$ 是一个合数，并设 $p$ 是 $n$ 的一个未知素因子。该算法从一个种子 $x_0$ 开始，使用迭代 $x_{k+1} \\equiv f(x_k) \\pmod n$ 生成一个序列 $(x_k)$。让我们分析这个序列模素因子 $p$ 的行为。\n\n我们定义第二个序列 $(z_k)$ 为 $z_k \\equiv x_k \\pmod p$。这个序列的递推关系是 $z_{k+1} \\equiv f(z_k) \\pmod p$，因为如果对于某个整数 $m$ 有 $x_{k+1} = f(x_k) - m \\cdot n$，那么 $x_{k+1} \\pmod p = (f(x_k) - m \\cdot n) \\pmod p$。由于 $p|n$，所以 $m \\cdot n \\equiv 0 \\pmod p$，因此 $x_{k+1} \\equiv f(x_k) \\pmod p$。这等价于 $z_{k+1} \\equiv f(z_k) \\pmod p$。\n\n序列 $(z_k)$ 的取值范围是有限集 $\\{0, 1, \\dots, p-1\\}$。根据鸽巢原理，这个序列最终必然会重复，从而变得具有周期性。Floyd 判圈算法旨在通过生成两个序列来找到这样的环：一个“乌龟”序列 $(x_k)$ 每次移动一步，以及一个“兔子”序列 $(y_k)$ 每次移动两步。具体来说，$x_{k+1} = f(x_k)$ 和 $y_{k+1} = f(f(y_k))$，且 $x_0 = y_0$。注意，对于所有 $k \\geq 0$，$y_k \\equiv x_{2k} \\pmod n$。\n\n当迭代项的余数重合时，即 $z_k \\equiv z_{2k} \\pmod p$ 时，在第一次迭代 $k \\geq 1$ 时发生模 $p$ 的碰撞。这等价于 $x_k \\equiv x_{2k} \\pmod p$，也就是 $x_k \\equiv y_k \\pmod p$。\n这个同余关系意味着 $x_k - y_k$ 是 $p$ 的倍数，所以 $p | (x_k - y_k)$。\n根据定义，$p$ 是 $n$ 的一个素因子，所以我们也有 $p | n$。\n因此，$p$ 是 $|x_k - y_k|$ 和 $n$ 的一个公因子。根据最大公约数 (GCD) 的定义，$d_k = \\gcd(|x_k - y_k|, n)$ 必须是 $p$ 的倍数。由于 $p$ 是素数，$p > 1$，这确保了 $d_k > 1$。\n\n如果 $d_k  n$，算法就成功地找到了一个非平凡因子。这种情况发生在 $x_k \\equiv y_k \\pmod p$ 但 $x_k \\not\\equiv y_k \\pmod n$ 时。因为序列 $(z_k)$ 的可能取值空间 ($p$) 比序列 $(x_k)$ 的可能取值空间 ($n$ 种可能性) 小得多，所以很可能在模 $p$ 下的碰撞会远早于在模 $n$ 下的碰撞发生。因此，我们期望找到一个 $k$，使得 $d_k$ 是 $n$ 的一个真因子。该算法仅在一种不太可能的情况下失败：即在同一个首次碰撞步骤 $k$ 中，对于 $n$ 的所有素因子 $q$，都有 $x_k \\equiv y_k \\pmod q$，这将导致 $d_k = n$。\n\n现在，我们对 $n = 697$，$f(x) \\equiv x^2 + 1 \\pmod{697}$ 和 $x_0 = y_0 = 2$ 执行该算法。\n\n**迭代 $k=1$:**\n$x_1 \\equiv f(x_0) \\equiv f(2) \\equiv 2^2 + 1 \\equiv 5 \\pmod{697}$。\n$y_1 \\equiv f(f(y_0)) \\equiv f(f(2)) \\equiv f(5) \\equiv 5^2 + 1 \\equiv 26 \\pmod{697}$。\n$d_1 = \\gcd(|x_1 - y_1|, n) = \\gcd(|5 - 26|, 697) = \\gcd(21, 697)$。\n使用欧几里得算法：$697 = 33 \\times 21 + 4$，$21 = 5 \\times 4 + 1$。因此，$d_1 = 1$。\n\n**迭代 $k=2$:**\n$x_2 \\equiv f(x_1) \\equiv f(5) \\equiv 26 \\pmod{697}$。\n$y_2 \\equiv f(f(y_1)) \\equiv f(f(26))$。\n$f(26) \\equiv 26^2 + 1 \\equiv 676 + 1 \\equiv 677 \\pmod{697}$。\n$f(677) \\equiv 677^2 + 1 \\equiv (-20)^2 + 1 \\equiv 400 + 1 \\equiv 401 \\pmod{697}$。所以，$y_2 = 401$。\n$d_2 = \\gcd(|x_2 - y_2|, n) = \\gcd(|26 - 401|, 697) = \\gcd(375, 697)$。\n$375$ 的质因数分解是 $3 \\times 5^3$。因为 $697$ 不能被 $3$ 或 $5$ 整除，所以 $d_2 = 1$。\n\n**迭代 $k=3$:**\n$x_3 \\equiv f(x_2) \\equiv f(26) \\equiv 677 \\pmod{697}$。\n$y_3 \\equiv f(f(y_2)) \\equiv f(f(401))$。\n$f(401) \\equiv 401^2 + 1 \\equiv 160802 \\equiv 230 \\times 697 + 492 \\equiv 492 \\pmod{697}$。\n$f(492) \\equiv 492^2 + 1 \\equiv 242065 \\equiv 347 \\times 697 + 206 \\equiv 206 \\pmod{697}$。所以，$y_3 = 206$。\n$d_3 = \\gcd(|x_3 - y_3|, n) = \\gcd(|677 - 206|, 697) = \\gcd(471, 697)$。\n$471 = 3 \\times 157$。$3$ 和 $157$ 都不能整除 $697$。因此，$d_3 = 1$。\n\n**迭代 $k=4$:**\n$x_4 \\equiv f(x_3) \\equiv f(677) \\equiv 401 \\pmod{697}$。\n$y_4 \\equiv f(f(y_3)) \\equiv f(f(206))$。\n$f(206) \\equiv 206^2 + 1 \\equiv 42437 \\equiv 60 \\times 697 + 617 \\equiv 617 \\pmod{697}$。\n$f(617) \\equiv 617^2 + 1 \\equiv (-80)^2 + 1 \\equiv 6401 \\equiv 9 \\times 697 + 128 \\equiv 128 \\pmod{697}$。所以，$y_4 = 128$。\n$d_4 = \\gcd(|x_4 - y_4|, n) = \\gcd(|401 - 128|, 697) = \\gcd(273, 697)$。\n$273 = 3 \\times 7 \\times 13$。这些素因子都不能整除 $697$。因此，$d_4 = 1$。\n\n**迭代 $k=5$:**\n$x_5 \\equiv f(x_4) \\equiv f(401) \\equiv 492 \\pmod{697}$。\n$y_5 \\equiv f(f(y_4)) \\equiv f(f(128))$。\n$f(128) \\equiv 128^2 + 1 \\equiv 16385 \\equiv 23 \\times 697 + 354 \\equiv 354 \\pmod{697}$。\n$f(354) \\equiv 354^2 + 1 \\equiv 125317 \\equiv 179 \\times 697 + 554 \\equiv 554 \\pmod{697}$。所以，$y_5 = 554$。\n$d_5 = \\gcd(|x_5 - y_5|, n) = \\gcd(|492 - 554|, 697) = \\gcd(62, 697)$。\n$62 = 2 \\times 31$。这两个因子都不能整除 $697$。因此，$d_5 = 1$。\n\n**迭代 $k=6$:**\n$x_6 \\equiv f(x_5) \\equiv f(492) \\equiv 206 \\pmod{697}$。\n$y_6 \\equiv f(f(y_5)) \\equiv f(f(554))$。\n$f(554) \\equiv 554^2 + 1 \\equiv 306917 \\equiv 440 \\times 697 + 237 \\equiv 237 \\pmod{697}$。\n$f(237) \\equiv 237^2 + 1 \\equiv 56170 \\equiv 80 \\times 697 + 410 \\equiv 410 \\pmod{697}$。所以，$y_6 = 410$。\n$d_6 = \\gcd(|x_6 - y_6|, n) = \\gcd(|206 - 410|, 697) = \\gcd(204, 697)$。\n为了计算 $\\gcd(204, 697)$，我们使用欧几里得算法：\n$697 = 3 \\times 204 + 85$\n$204 = 2 \\times 85 + 34$\n$85 = 2 \\times 34 + 17$\n$34 = 2 \\times 17 + 0$\n最大公约数是 $17$。\n所以，$d_6 = 17$。\n\n在迭代 $k=6$ 时，我们发现 $d_6 = 17$。由于 $1  17  697$，这是 $697$ 的一个非平凡因子。算法终止，成功找到了一个因子。\n\n每一步计算出的值是：\n$k=1: x_1=5, y_1=26, d_1=1$\n$k=2: x_2=26, y_2=401, d_2=1$\n$k=3: x_3=677, y_3=206, d_3=1$\n$k=4: x_4=401, y_4=128, d_4=1$\n$k=5: x_5=492, y_5=554, d_5=1$\n$k=6: x_6=206, y_6=410, d_6=17$\n发现的第一个非平凡因子是 $17$。", "answer": "$$\\boxed{17}$$", "id": "3088119"}, {"introduction": "Pollard p-1算法的有效性，关键取决于被分解数其素因子$p$的特性。该方法在$p-1$是“光滑”的（即其所有素因子都足够小）情况下尤其高效。本练习设定了一个假想场景，其中一个数$n$由两个结构迥异的素因子构成，一个因子的$p-1$值是光滑的，而另一个则不是。您的任务是分析为什么p-1方法能够找到其中一个因子而非另一个，从而巩固对该算法核心原理的理解。[@problem_id:3088143]", "problem": "设 $n=(2^{31}-1)\\cdot G$，其中 $G$ 是一个素数，满足 $2^{17}-100  G  2^{17}+100$，并且已知 $G-1$ 至少有一个素因数 $q  331$。使用 Pollard $p-1$ 方法的第一阶段，以 $a=2$ 为底数和光滑界 $B_1 = 331$ 来尝试分解 $n$。分析该方法为何能找到 $n$ 的一个非平凡因数，并计算出该因数的整数值。", "solution": "问题要求分析 Pollard 的 $p-1$ 因数分解法第一阶段对于给定整数 $n$ 和特定参数的成功性，并计算由此得到的非平凡因数。\n\n待分解的整数是 $n=(2^{31}-1)\\cdot G$。$n$ 的素因数是 $p_1 = 2^{31}-1$ 和 $p_2 = G$。在数论中，这是一个公认的事实：$p_1 = 2^{31}-1$ 是一个梅森素数。问题指出 $G$ 是一个满足 $2^{17}-100  G  2^{17}+100$ 的素数。\n\nPollard $p-1$ 方法的第一阶段尝试通过计算 $d = \\gcd(a^M - 1, n)$ 来找到 $n$ 的一个非平凡因数。给定的参数是底数 $a=2$ 和光滑界 $B_1 = 331$。值 $M$ 定义为从 $1$ 到 $B_1$ 的所有整数的最小公倍数，即 $M = \\mathrm{lcm}\\{1, 2, \\dots, 331\\}$。\n\n$n$ 的一个素因数 $p$ 是 $d$ 的因数，当且仅当 $p$ 整除 $a^M - 1$。这等价于同余式 $a^M \\equiv 1 \\pmod{p}$。\n问题提供了两个关键事实：\n1. 对于素数 $p$ 和整数 $a$（满足 $\\gcd(a,p)=1$），$a$ 模 $p$ 的乘法阶，记为 $\\mathrm{ord}_p(a)$，整除 $p-1$。\n2. 如果 $\\mathrm{ord}_p(a)$ 整除 $M$，则 $a^M \\equiv 1 \\pmod{p}$。\n\n结合这两点，$p$ 是 $d$ 的因数的一个充分条件是 $p-1$ 整除 $M$。一个数 $k$ 整除 $M = \\mathrm{lcm}\\{1, 2, \\dots, B_1\\}$，当且仅当 $k$ 的每个素数幂因数都小于或等于 $B_1$。\n\n让我们分别分析 $n$ 的两个素因数。\n\n首先，考虑因数 $p_1 = 2^{31}-1$。我们必须检验 $p_1-1$ 的素因数分解：\n$p_1-1 = (2^{31}-1)-1 = 2^{31}-2 = 2(2^{30}-1)$。\n我们使用平方差公式，$x^2-1 = (x-1)(x+1)$：\n$2^{30}-1 = (2^{15}-1)(2^{15}+1)$。\n所以，$p_1-1 = 2(2^{15}-1)(2^{15}+1)$。\n\n现在，我们分解 $2^{15}-1$ 和 $2^{15}+1$ 这两项：\n$2^{15}-1 = (2^5-1)(2^{10}+2^5+1) = 31 \\cdot (1024+32+1) = 31 \\cdot 1057$。\n检查 $1057$ 的小素因数：$1057 = 7 \\cdot 151$。\n所以，$2^{15}-1 = 7 \\cdot 31 \\cdot 151$。\n\n$2^{15}+1 = (2^5+1)(2^{10}-2^5+1) = 33 \\cdot (1024-32+1) = (3 \\cdot 11) \\cdot 993$。\n检查 $993$ 的素因数：$993 = 3 \\cdot 331$。\n所以，$2^{15}+1 = 3 \\cdot 11 \\cdot 3 \\cdot 331 = 3^2 \\cdot 11 \\cdot 331$。\n\n结合这些结果，$p_1-1$ 的完全因数分解是：\n$p_1-1 = 2 \\cdot (7 \\cdot 31 \\cdot 151) \\cdot (3^2 \\cdot 11 \\cdot 331) = 2 \\cdot 3^2 \\cdot 7 \\cdot 11 \\cdot 31 \\cdot 151 \\cdot 331$。\n$p_1-1$ 的素数幂因数是 $2^1=2$，$3^2=9$，$7^1=7$，$11^1=11$，$31^1=31$，$151^1=151$ 和 $331^1=331$。\n光滑界为 $B_1=331$。$p_1-1$ 的每个素数幂因数都小于或等于 $331$。因此，$p_1-1$ 必定整除 $M = \\mathrm{lcm}\\{1, 2, \\dots, 331\\}$。\n由于 $\\mathrm{ord}_{p_1}(2)$ 整除 $p_1-1$，因此 $\\mathrm{ord}_{p_1}(2)$ 整除 $M$。\n根据给定的事实，这蕴涵了 $2^M \\equiv 1 \\pmod{p_1}$。\n因此，$p_1$ 整除 $2^M-1$。\n\n接下来，考虑因数 $p_2 = G$。问题指出 $G-1$ 至少有一个素因数 $q$ 满足 $q > 331$。\n$M = \\mathrm{lcm}\\{1, 2, \\dots, 331\\}$ 的所有素因数都小于或等于 $331$。由于 $G-1$ 有一个素因数 $q>331$，所以 $G-1$ 不能整除 $M$。\n该方法找到 $G$ 的充分条件未被满足。要使该方法未能发现因数 $G$，必须有 $G$ 不整除 $2^M-1$，这意味着 $\\mathrm{ord}_G(2)$ 不整除 $M$。\n虽然理论上 $\\mathrm{ord}_G(2)$ 并非不可能整除 $M$（如果 $\\mathrm{ord}_G(2)$ 是 $(G-1)/q$ 的一个因数），但 Pollard $p-1$ 方法的分析依赖于一个启发式假设，即 $\\mathrm{ord}_p(a)$ 很可能是一个大数，并与 $p-1$ 共享其任何大的素因数。该问题的结构旨在得到一个确定性的结果，这意味着我们应该遵循这种标准分析。因此，我们得出结论，$G-1$ 中存在大素因数 $q > 331$ 会阻止 $\\mathrm{ord}_G(2)$ 整除 $M$。\n这导致 $2^M \\not\\equiv 1 \\pmod{G}$，意味着 $\\gcd(2^M-1, G) = 1$。\n\n现在我们可以确定 $d$ 的值：\n$d = \\gcd(2^M-1, n) = \\gcd(2^M-1, p_1 G)$。\n由于 $p_1$ 和 $G$ 是不同的素数，$\\gcd(p_1, G)=1$。我们可以使用性质 $\\gcd(A, BC) = \\gcd(A, B) \\cdot \\gcd(A, C)$（如果 $\\gcd(B,C)=1$）。\n$d = \\gcd(2^M-1, p_1) \\cdot \\gcd(2^M-1, G)$。\n根据我们的分析：\n$\\gcd(2^M-1, p_1) = p_1$，因为 $p_1$ 整除 $2^M-1$。\n$\\gcd(2^M-1, G) = 1$，因为我们得出的结论是 $G$ 不整除 $2^M-1$。\n因此，$d=p_1 \\cdot 1 = p_1$。\n\n第一阶段的结果是因数 $d=p_1$。由于 $G$ 是一个素数（因此 $G>1$），我们有 $1  p_1  p_1 G = n$。因数 $d=p_1$ 是非平凡的。因此，算法的第一阶段成功了。\n\n问题要求这个非平凡素因数的整数值，即 $p_1 = 2^{31}-1$。\n我们计算其值：\n$2^{31} - 1 = 2 \\cdot 2^{30} - 1 = 2 \\cdot (2^{10})^3 - 1 = 2 \\cdot (1024)^3 - 1$。\n$1024^2 = 1048576$。\n$1024^3 = 1048576 \\cdot 1024 = 1073741824$。\n$2^{31} = 2 \\cdot 1073741824 = 2147483648$。\n$p_1 = 2^{31}-1 = 2147483648 - 1 = 2147483647$。\n\nPollard $p-1$ 方法第一阶段找到的 $n$ 的非平凡素因数是 $2147483647$。", "answer": "$$\n\\boxed{2147483647}\n$$", "id": "3088143"}, {"introduction": "一个强大的算法，是能够优雅地处理其潜在失败情况的算法。在本练习中，我们将探讨Pollard p-1方法中一个常见的失败场景，即算法因$a^M - 1$同时被$n$的多个素因子整除而返回了平凡因子$n$。您将分析这种情况发生的原因，并识别一种通过分阶段或回溯求幂过程来最终分解出非平凡因子的策略，这体现了算法设计中的一个重要原则。[@problem_id:3088200]", "problem": "设 $n = p q$ 是两个不同奇素数 $p$ 和 $q$ 的乘积，设 $a$ 是一个与 $n$ 互素的整数，即 $\\gcd(a,n) = 1$。Pollard 的 $p-1$ 方法选择一个光滑指数 $M$（例如，许多小整数的最小公倍数），并计算 $g = \\gcd(a^{M} - 1, n)$，希望能得到 $n$ 的一个非平凡因子。该方法依赖于这样一个事实：根据费马小定理，在模素数 $r$ 的乘法群中，任何元素的阶都整除 $r-1$，因此如果 $r-1$ 整除 $M$，那么 $a^M \\equiv 1 \\pmod{r}$。假设对于所选的 $M$，我们有 $a^{M} \\equiv 1 \\pmod{p}$ 和 $a^{M} \\equiv 1 \\pmod{q}$。请通过模 $p$ 和模 $q$ 的乘法群结构以及中国剩余定理（CRT）来解释为什么在这种情况下 $g$ 可能等于 $n$。然后，选择一个策略，该策略正确描述了如何在不改变底数 $a$ 或光滑数界限的情况下，通过适当地组织求幂过程，使得在两个同余式同时满足之前出现一个成功的最大公约数，从而从这种情况中恢复一个非平凡因子。\n\n哪个选项是正确的？\n\nA. 因为 $a^{M} \\equiv 1 \\pmod{p}$ 且 $a^{M} \\equiv 1 \\pmod{q}$，所以整数 $a^{M} - 1$ 同时被 $p$ 和 $q$ 整除，因此 $g = \\gcd(a^{M} - 1, n)$ 可能等于 $n$。为了恢复一个因子，将 $M$ 写成素数幂的乘积，并形成一个递增序列 $M_1 \\mid M_2 \\mid \\cdots \\mid M$，在每一步计算 $g_i = \\gcd(a^{M_i} - 1, n)$。在第一个满足 $1  g_i  n$ 的 $i$ 处停止，这将得到一个非平凡因子。如果最后得到 $g = n$，则在最后一个素数幂块内回溯，通过测试中间的幂来找到一个索引，使得其中一个素数整除 $a^{M_i} - 1$ 而另一个不整除。\n\nB. 因为 $\\mathbb{Z}_{n}^{\\times}$ 是一个已知阶的循环群，所以取 $g = \\gcd\\!\\left(a^{M/2} - 1, n\\right)$ 必定能将 $n$ 分解为其素因子。\n\nC. 因为失败是由底数 $a$ 引起的，所以选择任何不同的 $a$ 并重新计算总能恢复一个因子，因此不需要对指数进行进一步的组织。\n\nD. 因为只要 $a^{M} \\equiv 1 \\pmod{p}$ 和 $a^{M} \\equiv 1 \\pmod{q}$，就有 $\\gcd(a^{M} - 1, n) = 1$，所以使用中国剩余定理（CRT）直接计算 $\\varphi(n)$ 并推导出 $p$ 和 $q$。", "solution": "我们从模素数的乘法群结构开始。对于一个素数 $r$，模 $r$ 的单位群是 $\\mathbb{Z}_{r}^{\\times}$，其阶为 $r-1$。根据费马小定理，对于任何满足 $\\gcd(a,r) = 1$ 的 $a$，都有 $a^{r-1} \\equiv 1 \\pmod{r}$。等价地，$a$ 在 $\\mathbb{Z}_{r}^{\\times}$ 中的阶整除 $r-1$。\n\nPollard 的 $p-1$ 方法利用了这种整除性：如果选择的 $M$ 使得 $p-1 \\mid M$，那么 $a^{M} \\equiv 1 \\pmod{p}$。如果此外还有 $q-1 \\nmid M$，那么通常 $a^{M} \\not\\equiv 1 \\pmod{q}$，因此 $a^{M} - 1$ 能被 $p$ 整除但不能被 $q$ 整除。在这种情况下，期望 $g = \\gcd(a^{M} - 1, n)$ 能揭示因子 $p$。\n\n现在假设 $a^{M} \\equiv 1 \\pmod{p}$ 并且 $a^{M} \\equiv 1 \\pmod{q}$。由于 $n = p q$，中国剩余定理（CRT）意味着模 $p$ 和模 $q$ 的同余式可以合并成一个模 $n$ 的同余式。具体来说，如果一个整数 $x$ 满足 $x \\equiv 1 \\pmod{p}$ 和 $x \\equiv 1 \\pmod{q}$，那么 $x \\equiv 1 \\pmod{n}$。将此应用于 $x = a^{M}$，我们得到 $a^{M} \\equiv 1 \\pmod{n}$，所以 $a^{M} - 1$ 同时被 $p$ 和 $q$ 整除，因此也被 $n$ 整除。所以\n$$\ng \\;=\\; \\gcd(a^{M} - 1, n) \\;=\\; n,\n$$\n这是平凡的最大公约数，不产生任何因子。\n\n为了在这种情况下在不改变底数 $a$ 或光滑数界限的情况下恢复一个非平凡因子，应该组织求幂过程，以便在两个同余式同时满足之前，在中间的指数处计算最大公约数。具体地，将光滑指数 $M$ 分解为素数幂的乘积，\n$$\nM \\;=\\; \\prod_{\\ell \\leq B} \\ell^{e_{\\ell}},\n$$\n并定义一个递增的指数链\n$$\nM_1 \\mid M_2 \\mid \\cdots \\mid M_k \\;=\\; M,\n$$\n其中每个 $M_{i+1}$ 是通过将 $M_i$ 乘以一个小的素数 $\\ell$ 或一个素数幂 $\\ell^{e}$ 得到的。在每一步计算 $g_i = \\gcd(a^{M_i} - 1, n)$。如果在某个索引 $i$ 处，有 $p-1 \\mid M_i$ 但 $q-1 \\nmid M_i$，那么 $a^{M_i} \\equiv 1 \\pmod{p}$ 而 $a^{M_i} \\not\\equiv 1 \\pmod{q}$，因此 $1  g_i  n$，从而得到一个非平凡因子。如果最后一步得到 $g_k = n$，则在最后一个素数幂块内回溯：如果 $M_k = M_{k-1} \\cdot \\ell^{e}$，则对 $j = 1,2,\\dots,e$ 依次计算 $b_j \\equiv a^{M_{k-1} \\cdot \\ell^{j}} \\pmod{n}$，并在每个 $j$ 处测试 $g_j = \\gcd(b_j - 1, n)$。将会存在第一个索引 $j^{\\ast}$，使得另一个素数的同余式 $a^{M_{k-1} \\cdot \\ell^{j^{\\ast}}} \\equiv 1 \\pmod{q}$ 成立；在此之前，$g_{j^{\\ast}-1}$ 满足 $1  g_{j^{\\ast}-1}  n$ 并提供一个因子。\n\n我们现在评估每个选项：\n\nA. 这个选项正确地解释了为什么 $g$ 可以等于 $n$：如果 $a^{M}$ 对 $p$ 和 $q$ 都模 1，那么 $a^{M} - 1$ 同时被这两个素数整除，所以 $\\gcd(a^{M} - 1, n) = n$。所描述的恢复方法——将 $M$ 分解为素数幂块，沿着递增的指数序列计算 $\\gcd(a^{M_i} - 1, n)$，并在需要时在最后一个块内回溯——与上面基于原理推导出的方法相匹配，并且是在两个同余式同时成立之前提取因子的标准方法。结论：正确。\n\nB. 这个选项错误地断言 $\\mathbb{Z}_{n}^{\\times}$ 是一个已知阶的循环群，并且取一半的指数必定能分解 $n$。一般来说，对于合数 $n$，$\\mathbb{Z}_{n}^{\\times}$ 不是循环群，其阶为 $\\varphi(n)$，而在不分解 $n$ 的情况下是未知的。即使卡迈克尔函数 $\\lambda(n)$ 已知，$\\gcd(a^{\\lambda(n)/2} - 1, n)$ 也不能保证分解成功。结论：不正确。\n\nC. 这个选项声称选择一个不同的底数 $a$ 并重新计算总能恢复一个因子。虽然改变 $a$ 是避免同时同余的一个合理启发式方法，但它并不总是成功，也不能提供保证。其确定性的断言使得该陈述本身是错误的。结论：不正确。\n\nD. 这个选项声称在同时同余的条件下 $\\gcd(a^{M} - 1, n) = 1$，并建议通过中国剩余定理直接计算 $\\varphi(n)$。在这种情况下，最大公约数是 $n$，而不是 $1$，并且在不知道 $n$ 的因数分解的情况下，无法计算 $\\varphi(n)$。结论：不正确。", "answer": "$$\\boxed{A}$$", "id": "3088200"}]}