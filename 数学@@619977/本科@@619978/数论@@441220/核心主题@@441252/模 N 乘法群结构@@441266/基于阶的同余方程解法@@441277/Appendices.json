{"hands_on_practices": [{"introduction": "计算像 $3^{2023}$ 这样巨大的幂在模算术中似乎是一项艰巨的任务。然而，借助“阶”的概念，我们可以找到一个强大的捷径。本练习将引导你利用元素的乘法阶来简化指数，将一个看似无法处理的计算转变为几次简单的乘法，从而直观地展示阶在解决同余问题中的实用价值。[@problem_id:3087787]", "problem": "令 $n=17$ 且 $a=3$。定义乘法阶 $\\operatorname{ord}_{n}(a)$ 为满足 $\\gcd(a,n)=1$ 和 $a^{t}\\equiv 1 \\pmod{n}$ 的最小正整数 $t$。在模 $n$ 的整数环和模 $n$ 的单位群中进行运算。仅使用以下基础事实：对于素数 $p$，模 $p$ 的非零剩余类在乘法下构成一个阶为 $p-1$ 的有限群，以及在任何有限群中，元素的阶整除群的阶。按以下步骤进行：\n\n- 通过测试 $\\varphi(17)$ 的适当因子来确定 $\\operatorname{ord}_{17}(3)$，其中 $\\varphi$ 表示欧拉总计函数。\n- 使用 $\\operatorname{ord}_{17}(3)$ 的值来减小指数，并计算余数 $3^{2023}\\bmod 17$。\n- 通过计算每种方法中的模乘法次数，简要对比这种基于阶的降幂法与直接的二进制幂算法（从左到右的重复平方，不事先进行指数约减）。在你的比较中，将一次模平方计算为一次模乘法，假设在有利时重复使用任何已计算的中间幂，并考虑指数的二进制展开。\n\n仅报告 $\\{0,1,\\dots,16\\}$ 中的最终剩余类代表元作为你的数值答案。无需四舍五入，也不涉及单位。", "solution": "该问题经验证是自洽的，在初等数论中有科学依据，并且是适定的。所有需要的数据和定义均已提供，任务明确无歧义。\n\n该问题要求完成关于模 $n=17$ 和底 $a=3$ 的模算术的三个不同但相关的任务。我们将依次处理每一项任务。\n\n首先，我们确定 $3$ 模 $17$ 的乘法阶，记为 $\\operatorname{ord}_{17}(3)$。问题陈述我们要在模 $n$ 的单位群中进行运算。对于 $n=17$（一个素数），单位群 $(\\mathbb{Z}/17\\mathbb{Z})^\\times$ 由乘法下的非零剩余类 $\\{1, 2, \\dots, 16\\}$ 组成。该群的阶由欧拉总计函数给出，即 $|\\left(\\mathbb{Z}/17\\mathbb{Z}\\right)^\\times|=\\varphi(17)$。由于 $17$ 是素数，$\\varphi(17) = 17 - 1 = 16$。\n$\\operatorname{ord}_{n}(a)$ 的定义要求 $\\gcd(a,n)=1$。对于 $a=3$ 和 $n=17$，我们有 $\\gcd(3,17)=1$，符合要求。\n群论的一个基本原理（Lagrange 定理）指出，元素的阶必须整除群的阶。因此，$\\operatorname{ord}_{17}(3)$ 必须是 $16$ 的一个因子。$16$ 的正因子是 $1, 2, 4, 8, 16$。为了找到阶（即最小的这样的正整数），我们按升序测试这些因子。\n所有同余式均以 $17$ 为模。\n\\begin{itemize}\n    \\item 对于指数 $t=1$：$3^1 \\equiv 3 \\not\\equiv 1 \\pmod{17}$。\n    \\item 对于指数 $t=2$：$3^2 = 9 \\equiv 9 \\not\\equiv 1 \\pmod{17}$。\n    \\item 对于指数 $t=4$：$3^4 = (3^2)^2 \\equiv 9^2 = 81$。由于 $81 = 4 \\times 17 + 13$，我们有 $3^4 \\equiv 13 \\not\\equiv 1 \\pmod{17}$。\n    \\item 对于指数 $t=8$：$3^8 = (3^4)^2 \\equiv 13^2 = 169$。由于 $169 = 9 \\times 17 + 16$，我们有 $3^8 \\equiv 16 \\equiv -1 \\pmod{17}$。这不是 $1$。\n\\end{itemize}\n由于阶不是 $1, 2, 4$ 或 $8$，它必定是 $16$。我们可以验证这一点：$3^{16} = (3^8)^2 \\equiv (-1)^2 \\equiv 1 \\pmod{17}$。这也是费马小定理的直接推论。\n因此，$3$ 模 $17$ 的乘法阶为 $\\operatorname{ord}_{17}(3) = 16$。\n\n其次，我们使用这个阶来计算 $3^{2023}$ 模 $17$ 的余数。阶的性质允许我们将指数对阶取模。具体来说，如果 $t = \\operatorname{ord}_{n}(a)$，那么 $a^k \\equiv a^{k \\pmod t} \\pmod n$。\n我们需要求出 $2023$ 除以阶 $16$ 的余数。\n$$2023 = 16 \\times 126 + 7$$\n这意味着 $2023 \\equiv 7 \\pmod{16}$。\n因此，我们可以简化原始计算：\n$$3^{2023} \\equiv 3^{16 \\times 126 + 7} \\equiv (3^{16})^{126} \\cdot 3^7 \\pmod{17}$$\n由于 $3^{16} \\equiv 1 \\pmod{17}$，上式可简化为：\n$$1^{126} \\cdot 3^7 \\equiv 3^7 \\pmod{17}$$\n现在我们计算 $3^7 \\pmod{17}$。我们可以使用之前计算的中间幂：$3^1 \\equiv 3$, $3^2 \\equiv 9$, 和 $3^4 \\equiv 13$。\n$$3^7 = 3^{4+2+1} = 3^4 \\cdot 3^2 \\cdot 3^1$$\n$$3^7 \\equiv 13 \\cdot 9 \\cdot 3 \\pmod{17}$$\n首先，我们计算 $13 \\cdot 9 = 117$。除以 $17$，$117 = 6 \\times 17 + 15$，所以 $117 \\equiv 15 \\pmod{17}$。\n接下来，我们计算 $15 \\cdot 3 = 45$。除以 $17$，$45 = 2 \\times 17 + 11$，所以 $45 \\equiv 11 \\pmod{17}$。\n因此，$3^{2023} \\equiv 11 \\pmod{17}$。所求的剩余类代表元是 $11$。\n\n第三，我们对比两种方法所需的模乘法次数。一次模平方计为一次模乘法。\n\n方法1：基于阶的降幂法。\n\\begin{enumerate}\n    \\item 求阶 $\\operatorname{ord}_{17}(3)$。这涉及计算 $3^2, 3^4$ 和 $3^8$。\n    \\begin{itemize}\n        \\item $3^2 = 3 \\cdot 3$：$1$ 次乘法（一次平方）。\n        \\item $3^4 = (3^2)^2$：$1$ 次平方。\n        \\item $3^8 = (3^4)^2$：$1$ 次平方。\n    \\end{itemize}\n    此步骤总共需要 $3$ 次模乘法。\n    \\item 计算 $3^7 \\pmod{17}$。我们重用已计算的幂 $3^1, 3^2, 3^4$。\n    $3^7 = 3^4 \\cdot 3^2 \\cdot 3^1$。\n    \\begin{itemize}\n        \\item 令 $P = 3^4 \\cdot 3^2$：$1$ 次乘法。\n        \\item 结果 $= P \\cdot 3^1$：$1$ 次乘法。\n    \\end{itemize}\n    此步骤需要额外的 $2$ 次模乘法。\n\\end{enumerate}\n基于阶的方法总共需要的模乘法次数是 $3 + 2 = 5$。\n\n方法2：直接的二进制幂算法（从左到右的重复平方）。\n我们直接计算 $3^{2023} \\pmod{17}$。\n指数是 $2023$。其二进制表示为：\n$2023 = 1024 + 512 + 256 + 128 + 64 + 32 + 4 + 2 + 1 = 2^{10} + 2^9 + 2^8 + 2^7 + 2^6 + 2^5 + 2^2 + 2^1 + 2^0$。\n所以，$2023_{10} = 11111100111_2$。\n该二进制表示有 11 位长（从第 0 位到第 10 位）。该算法所需的平方次数是最高比特位的位置，即 10。\n乘法次数是二进制字符串中置位（1）的数量减一（因为前导位）。1 的数量（汉明权重）是 $9$。所以，乘法次数是 $9-1=8$。\n总操作次数是平方和乘法次数的总和。\n总模乘法次数 = $10$（平方）$+ 8$（乘法）$= 18$。\n对于这个问题，比较显示基于阶的方法（5 次乘法）相比于直接的二进制幂算法（18 次乘法）有显著的效率提升。\n\n所要求的最终数值答案是 $3^{2023} \\bmod 17$ 的余数，即 $11$。", "answer": "$$\n\\boxed{11}\n$$", "id": "3087787"}, {"introduction": "在我们学会如何使用一个元素的阶之后，一个自然的问题是：这个元素的幂的阶与其本身有何关系？本练习将从应用转向理论，指导你从第一性原理出发，推导计算 $\\operatorname{ord}_n(a^k)$ 的基本公式。掌握这一关系对于更深入地理解乘法群的结构至关重要。[@problem_id:3087796]", "problem": "设 $a$ 是乘法群 $\\left(\\mathbb{Z}/37\\mathbb{Z}\\right)^{\\times}$ 中的一个元素，其 $\\operatorname{ord}_{37}(a)=36$，其中 $\\operatorname{ord}_{37}(a)$ 表示 $a$ 模 $37$ 的乘法阶，定义为满足 $a^{t}\\equiv 1 \\pmod{37}$ 的最小正整数 $t$。确定 $\\operatorname{ord}_{37}(a^{9})$。您的证明必须从乘法阶的定义出发，并且只使用基本的整除性质，包括这样一个事实：如果 $a^{n}\\equiv 1 \\pmod{37}$，则 $\\operatorname{ord}_{37}(a)$ 整除 $n$。在您的推理中，请从基本原理出发，清晰地推导您在 $\\operatorname{ord}_{37}(a)$ 和 $\\operatorname{ord}_{37}(a^{k})$ 之间使用的任何一般关系，并明确指出最大公约数 (GCD) 所起的任何作用。请以单个整数形式提供您的最终答案。", "solution": "设 $o = \\operatorname{ord}_{37}(a)$ 且 $m = \\operatorname{ord}_{37}(a^{9})$。已知 $o=36$。我们的任务是求出 $m$ 的值。\n\n根据明确的指示，我们首先从基本原理推导元素 $a$ 的阶与该元素幂 $a^k$ 的阶之间的一般关系。设模为一个一般整数 $N1$，尽管在我们的情况下 $N=37$。设 $o = \\operatorname{ord}_{N}(a)$，并设 $m' = \\operatorname{ord}_{N}(a^k)$，其中 $k$ 为某个整数。\n\n根据阶的定义，$m'$ 是使得 $(a^k)^{m'} \\equiv 1 \\pmod{N}$ 成立的最小正整数。这等价于同余式 $a^{km'} \\equiv 1 \\pmod{N}$。\n\n我们要使用这样一个性质：如果 $a^n \\equiv 1 \\pmod{N}$，那么 $\\operatorname{ord}_{N}(a)$ 必须整除 $n$。将此性质应用于同余式 $a^{km'} \\equiv 1 \\pmod{N}$，我们推断 $o$ 必须整除指数 $km'$。\n因此，我们有条件 $o \\mid km'$。\n\n设 $d$ 是 $k$ 和 $o$ 的最大公约数，记为 $d = \\gcd(k,o)$。根据 GCD 的定义，我们可以将 $k$ 和 $o$ 写成 $k = k'd$ 和 $o = o'd$，其中 $k'$ 和 $o'$ 是某个整数，使得 $\\gcd(k', o') = 1$。GCD 的作用是分解出 $k$ 和 $o$ 的公共部分，留下两个互质的整数 $k'$ 和 $o'$。\n\n将这些表达式代入我们的整除条件 $o \\mid km'$，我们得到：\n$o'd \\mid (k'd)m'$\n\n由于 $d = \\gcd(k,o)$ 是一个正整数，我们可以在整除关系的两边同时除以 $d$：\n$o' \\mid k'm'$\n\n根据 Euclid 的引理，由于 $\\gcd(k', o') = 1$，必然有 $o'$ 整除 $m'$。这意味着 $m'$ 必须是 $o'$ 的倍数。由于 $m'$ 被定义为满足其同余式的*最小正*整数，它必须是 $o'$ 的最小正倍数。让我们检验一下 $m' = o'$ 是否是一个有效的解。\n\n我们必须检查是否 $(a^k)^{o'} \\equiv 1 \\pmod{N}$。\n$(a^k)^{o'} = a^{ko'} = a^{(k'd)o'} = a^{k'(do')} = a^{k'o}$\n\n由于 $o = \\operatorname{ord}_{N}(a)$，我们有 $a^o \\equiv 1 \\pmod{N}$。因此：\n$a^{k'o} = (a^o)^{k'} \\equiv 1^{k'} \\equiv 1 \\pmod{N}$\n\n条件对于 $m' = o'$ 成立。由于我们已经确定任何有效的 $m'$ 都必须是 $o'$ 的倍数，因此 $m'$ 的最小正值必须是 $o'$ 本身。\n因此，我们推导出了这个一般关系：\n$$m' = o' = \\frac{o}{d} = \\frac{\\operatorname{ord}_{N}(a)}{\\gcd(k, \\operatorname{ord}_{N}(a))}$$\n\n现在，我们将这个推导出的公式应用于给定的具体问题。\n我们有 $a \\in \\left(\\mathbb{Z}/37\\mathbb{Z}\\right)^{\\times}$，所以模是 $N=37$。\n已知 $\\operatorname{ord}_{37}(a) = 36$。\n我们想求 $\\operatorname{ord}_{37}(a^9)$。在这种情况下，$k=9$。\n\n使用我们的公式：\n$\\operatorname{ord}_{37}(a^9) = \\frac{\\operatorname{ord}_{37}(a)}{\\gcd(9, \\operatorname{ord}_{37}(a))}$\n\n代入给定值 $\\operatorname{ord}_{37}(a)=36$：\n$\\operatorname{ord}_{37}(a^9) = \\frac{36}{\\gcd(9, 36)}$\n\n为了求出 $9$ 和 $36$ 的最大公约数，我们注意到 $36 = 4 \\times 9$。因此，$9$ 是 $36$ 的一个约数。所以，最大公约数是 $9$：\n$\\gcd(9, 36) = 9$\n\n将这个值代回表达式中：\n$\\operatorname{ord}_{37}(a^9) = \\frac{36}{9} = 4$\n\n$a^9$ 模 $37$ 的阶是 $4$。", "answer": "$$\\boxed{4}$$", "id": "3087796"}, {"introduction": "对于较小的数，通过逐一测试除数来手动寻找阶是可行的，但这种方法很快就变得不切实际。本项终极实践挑战你综合运用所学知识，构建一个能够计算任意整数模 $n$ 的阶的通用算法。通过引入卡迈克尔函数 $\\lambda(n)$ 作为最紧的指数上界，你将设计出一个高效、普适的计算工具，这代表了对本章知识的全面掌握。[@problem_id:3087777]", "problem": "要求您设计一个算法，使用基于基础数论中阶的方法来计算在合数模下的乘法阶。整数 $a$ 模 $n$ 的乘法阶，记作 $\\operatorname{ord}_n(a)$，定义为满足 $a^k \\equiv 1 \\pmod{n}$ 的最小正整数 $k$，其前提条件是 $\\gcd(a,n)=1$，其中 $\\gcd$ 表示最大公约数 (GCD)。如果 $\\gcd(a,n) \\neq 1$，则在模 $n$ 的单位群中乘法阶是未定义的。在这种情况下，为完成本任务，您的程序必须输出 $0$。\n\n从模算术和有限群的基本定义出发，并利用诸如模 $n$ 单位群存在普遍指数等经过充分检验的事实，设计并实现一个算法，通过利用模 $n$ 单位群的普遍指数的因数分解来计算 $\\operatorname{ord}_n(a)$。具体来说，使用 Carmichael 函数 $\\lambda(n)$（即模 $n$ 乘法单位群的指数）作为您的普遍上界，并通过其素因数来减小它，以获得满足 $a^d \\equiv 1 \\pmod{n}$ 的最小指数 $d$。您的算法必须：\n\n- 正确处理所有 $n \\geq 1$ 和整数 $a$。\n- 当 $\\gcd(a,n) \\neq 1$ 时返回 $0$。\n- 通过将 $n$ 分解为素数幂并通过最小公倍数 (LCM) 组合它们的贡献来计算 $\\lambda(n)$。\n- 将 $\\lambda(n)$ 分解为素数，并对于满足同余式 $a^{\\lambda(n)/q} \\equiv 1 \\pmod{n}$ 的素因数 $q$ 进行迭代相除，直到无法再进行除法为止。\n- 以满足 $a^d \\equiv 1 \\pmod{n}$ 的最小 $d$ 终止。\n\n根据乘法阶的定义和模 $n$ 单位群的普遍指数性质，证明您的算法的正确性和终止性。\n\n将您的算法实现为一个完整的、可运行的程序。您的程序不得读取输入；相反，它必须为以下参数对 $(a,n)$ 的测试套件计算乘法阶：\n\n- 测试用例 1：$(a,n) = (2,29)$。\n- 测试用例 2：$(a,n) = (3,16)$。\n- 测试用例 3：$(a,n) = (2,27)$。\n- 测试用例 4：$(a,n) = (2,45)$。\n- 测试用例 5：$(a,n) = (10,40)$。\n- 测试用例 6：$(a,n) = (2,231)$。\n- 测试用例 7：$(a,n) = (2,9)$。\n- 测试用例 8：$(a,n) = (1,2)$。\n\n您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表。例如，如果结果为 $r_1, r_2, \\dots, r_8$，则输出必须为 $\\left[ r_1, r_2, \\dots, r_8 \\right]$ 的精确格式，无任何附加文本。每个测试用例的结果必须是一个整数，如上所述，当 $\\gcd(a,n) \\neq 1$ 时使用 $0$。", "solution": "该问题要求设计并实现一个算法，用于计算整数 $a$ 模 $n$ 的乘法阶，记作 $\\operatorname{ord}_n(a)$。其定义为满足 $a^k \\equiv 1 \\pmod{n}$ 的最小正整数 $k$，前提条件是 $\\gcd(a, n) = 1$。如果不满足此条件，则在模 $n$ 的单位群中阶是未定义的，并且指定的输出为 $0$。\n\n该算法的设计基于群论和数论的基本原理，特别是利用了 Carmichael 函数 $\\lambda(n)$ 的性质。\n\n**理论基础**\n\n与 $n$ 互质的模 $n$ 整数集合在乘法下形成一个有限阿贝尔群，称为模 $n$ 整数乘法群或单位群，记作 $(\\mathbb{Z}/n\\mathbb{Z})^\\times$。该群的阶由 Euler's totient 函数 $\\phi(n)$ 给出。\n\n根据 Lagrange 定理，有限群中任何元素的阶必须整除群的阶。因此，对于任何满足 $\\gcd(a,n)=1$ 的 $a$，其乘法阶 $\\operatorname{ord}_n(a)$ 必须整除 $\\phi(n)$。这就得到了 Euler's totient 定理：$a^{\\phi(n)} \\equiv 1 \\pmod{n}$。\n\nCarmichael 函数 $\\lambda(n)$ 提供了一个更强的结果。Carmichael 函数 $\\lambda(n)$ 定义为对所有与 $n$ 互质的整数 $a$ 都满足 $a^m \\equiv 1 \\pmod{n}$ 的最小正整数 $m$。用群论的术语来说，$\\lambda(n)$ 是群 $(\\mathbb{Z}/n\\mathbb{Z})^\\times$ 的指数。因此，对于该群中的任何单个元素 $a$，其阶必须整除群的指数。于是，我们得到一个关键性质：\n$$ \\operatorname{ord}_n(a) \\mid \\lambda(n) $$\n该性质为阶提供了比 $\\phi(n)$ 更紧的上界，并且是指定算法的基石。\n\nCarmichael 函数 $\\lambda(n)$ 的计算基于 $n$ 的素因数分解：\n1. $\\lambda(1) = 1$。\n2. $\\lambda(2) = 1$。\n3. $\\lambda(4) = 2$。\n4. 对于 $k \\geq 3$，$\\lambda(2^k) = 2^{k-2}$。\n5. 对于奇素数 $p$，$\\lambda(p^k) = p^{k-1}(p-1) = \\phi(p^k)$。\n6. 对于 $n = p_1^{k_1} p_2^{k_2} \\cdots p_r^{k_r}$，$\\lambda(n) = \\operatorname{lcm}(\\lambda(p_1^{k_1}), \\lambda(p_2^{k_2}), \\ldots, \\lambda(p_r^{k_r}))$。\n\n**算法设计**\n\n该算法的核心原则是利用 $\\operatorname{ord}_n(a)$ 是 $\\lambda(n)$ 的一个因数这一事实。我们可以从候选值 $\\lambda(n)$ 开始，系统地移除其素因数，从而找到 $\\operatorname{ord}_n(a)$。\n\n令 $L = \\lambda(n)$。设 $L$ 的素因数分解为 $L = q_1^{e_1} q_2^{e_2} \\cdots q_m^{e_m}$。阶 $\\operatorname{ord}_n(a)$ 必具有 $q_1^{f_1} q_2^{f_2} \\cdots q_m^{f_m}$ 的形式，其中对所有 $i$ 都有 $0 \\leq f_i \\leq e_i$。该算法确定正确的指数 $f_i$。\n\n详细步骤如下：\n1.  **输入：** 整数 $a$ 和 $n \\geq 1$。\n2.  **GCD 检查：** 计算 $g = \\gcd(a, n)$。如果 $g  1$，则在单位群中阶未定义。返回 $0$。\n3.  **Carmichael 函数：** 计算 $L = \\lambda(n)$。这需要用于 $n$ 的素因数分解、计算素数幂的 $\\lambda$ 值以及计算最小公倍数 (LCM) 的辅助函数。\n4.  **阶的初始化：** 初始化阶的候选值 $d = L$。\n5.  **Lambda 的素因数分解：** 找到 $L$ 的唯一素因数集合，设为 $\\{q_1, q_2, \\ldots, q_m\\}$。\n6.  **迭代缩减：** 对于集合中的每个素因数 $q_i$：当 $d$ 能被 $q_i$ 整除且同余式 $a^{d/q_i} \\equiv 1 \\pmod{n}$ 成立时，更新候选阶，令 $d = d/q_i$。此步骤使用模幂运算来高效计算 $a^k \\pmod{n}$。\n7.  **终止：** 遍历完 $L$ 的所有唯一素因数后，$d$ 的最终值是满足阶定义的 $L$ 的最小因数。这个最终的 $d$ 就是 $\\operatorname{ord}_n(a)$。返回 $d$。\n\n**正确性与终止性证明**\n\n**正确性：** 设真实的阶为 $k = \\operatorname{ord}_n(a)$。我们知道 $k \\mid \\lambda(n)$。算法初始化候选阶 $d_0 = \\lambda(n)$，因此 $k \\mid d_0$ 成立。算法通过生成一个候选序列 $d_0, d_1, \\ldots, d_{\\text{final}}$ 来进行。在每一步中，仅当 $a^{d_j/q} \\equiv 1 \\pmod{n}$ 时（其中 $q$ 是一个素数），候选值 $d_j$ 才会被更新为 $d_{j+1} = d_j/q$。根据阶的基本性质，如果 $a^m \\equiv 1 \\pmod{n}$，则 $k \\mid m$。因此，更新 $d_j$ 的条件意味着 $k \\mid (d_j/q)$。这意味着不变量 $k \\mid d_j$ 在算法的每一步都得以保持。终止时，我们得到一个最终候选值 $d_{\\text{final}}$，使得 $k \\mid d_{\\text{final}}$。终止条件是，对于 $d_{\\text{final}}$ 的每个素因数 $p$，都有 $a^{d_{\\text{final}}/p} \\not\\equiv 1 \\pmod{n}$。现在，我们用反证法，假设 $k$ 是 $d_{\\text{final}}$ 的一个真因数。这意味着对于某个整数 $m  1$，有 $d_{\\text{final}} = k \\cdot m$。设 $p$ 是 $m$ 的任意一个素因数。那么 $p$ 也是 $d_{\\text{final}}$ 的一个素因数，并且 $k$ 整除 $d_{\\text{final}}/p$。这意味着 $a^{d_{\\text{final}}/p} \\equiv 1 \\pmod{n}$，这与终止条件相矛盾。因此，我们的假设必为假。唯一的可能性是 $m=1$，这意味着 $d_{\\text{final}} = k$。该算法正确地计算了阶。\n\n**终止性：** 算法的主循环遍历 $\\lambda(n)$ 的唯一素因数集合，这是一个有限集。内部的 `while` 循环通过将候选阶 $d$ 除以一个素数 $q  1$ 来减小它。由于 $d$ 被初始化为一个有限正整数 $\\lambda(n)$，并且在内部循环的每一步中都严格递减，因此该内部循环必须终止。总的除法次数受 $\\lambda(n)$ 素因数分解中各指数之和的限制。因此，整个算法保证会终止。\n\n以下 Python 代码实现了这个经过验证的算法。", "answer": "```python\nimport math\n\n# Although numpy and scipy are permitted by the execution environment, they are not\n# necessary for this number-theoretic problem. This implementation uses only the\n# Python standard library for clarity and efficiency.\n# The `numpy` import is included to exactly match the problem's code structure example.\nimport numpy as np\n\n\ndef gcd(a, b):\n    \"\"\"Computes the greatest common divisor of a and b using the Euclidean algorithm.\"\"\"\n    while b:\n        a, b = b, a % b\n    return a\n\ndef lcm(a, b):\n    \"\"\"Computes the least common multiple of a and b.\"\"\"\n    if a == 0 or b == 0:\n        return 0\n    return abs(a * b) // gcd(a, b)\n\ndef power(base, exp, mod):\n    \"\"\"\n    Computes (base^exp) % mod efficiently using exponentiation by squaring.\n    \"\"\"\n    res = 1\n    base %= mod\n    while exp  0:\n        if exp % 2 == 1:\n            res = (res * base) % mod\n        base = (base * base) % mod\n        exp //= 2\n    return res\n\ndef get_prime_factorization(num):\n    \"\"\"\n    Returns the prime factorization of num as a dictionary {prime: exponent}.\n    \"\"\"\n    factors = {}\n    d = 2\n    temp_num = num\n    while d * d = temp_num:\n        while temp_num % d == 0:\n            factors[d] = factors.get(d, 0) + 1\n            temp_num //= d\n        d += 1\n    if temp_num  1:\n        factors[temp_num] = factors.get(temp_num, 0) + 1\n    return factors\n\ndef carmichael_lambda(n):\n    \"\"\"\n    Computes the Carmichael function lambda(n).\n    \"\"\"\n    if n == 1:\n        return 1\n    \n    prime_factors = get_prime_factorization(n)\n    \n    lcm_components = []\n    for p, k in prime_factors.items():\n        if p == 2:\n            if k == 1:\n                lcm_components.append(1)  # lambda(2) = 1\n            elif k == 2:\n                lcm_components.append(2)  # lambda(4) = 2\n            else:\n                lcm_components.append(2**(k - 2))  # lambda(2^k) = 2^(k-2) for k=3\n        else: # odd prime\n            lcm_components.append((p - 1) * (p**(k - 1))) # lambda(p^k) = phi(p^k)\n\n    result = 1\n    for component in lcm_components:\n        result = lcm(result, component)\n    return result\n\ndef multiplicative_order(a, n):\n    \"\"\"\n    Computes the multiplicative order of a modulo n.\n    Returns 0 if gcd(a, n) != 1.\n    \"\"\"\n    if n == 1:\n        return 1\n        \n    if gcd(a, n) != 1:\n        return 0\n\n    lam = carmichael_lambda(n)\n    \n    # Get unique prime factors of lambda(n)\n    prime_factors_of_lam = list(get_prime_factorization(lam).keys())\n    \n    order = lam\n    for p in prime_factors_of_lam:\n        while order % p == 0 and power(a, order // p, n) == 1:\n            order //= p\n            \n    return order\n\n\ndef solve():\n    \"\"\"\n    Solves the problem for the given test suite of parameter pairs (a, n).\n    \"\"\"\n    test_cases = [\n        (2, 29),    # Test case 1\n        (3, 16),    # Test case 2\n        (2, 27),    # Test case 3\n        (2, 45),    # Test case 4\n        (10, 40),   # Test case 5\n        (2, 231),   # Test case 6\n        (2, 9),     # Test case 7\n        (1, 2),     # Test case 8\n    ]\n\n    results = []\n    for a, n in test_cases:\n        result = multiplicative_order(a, n)\n        results.append(result)\n\n    # Print results in the exact required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3087777"}]}