{"hands_on_practices": [{"introduction": "理解法里数列 ($Farey$ $sequence$) 的最好方法之一就是亲手构建一个。这个练习将指导你从头开始构建一个简单的法里数列 $F_5$，并通过直接计算来验证其相邻项之间的一个关键性质。这个过程不仅能加深你对法里数列定义的理解，还能让你直观地感受到其独特的结构。[@problem_id:3085131]", "problem": "令 $F_{n}$ 表示 $n$ 阶法里序列，定义为在区间 $[0,1]$ 内，所有满足 $0 \\leq p \\leq q \\leq n$ 和 $\\gcd(p,q) = 1$ 的既约分数 $\\frac{p}{q}$ 按升序排列所组成的序列，并包括端点 $\\frac{0}{1}$ 和 $\\frac{1}{1}$。两个分母为正的分数 $\\frac{a}{b}$ 和 $\\frac{c}{d}$ 的中介数定义为 $\\frac{a+c}{b+d}$。\n\n严格根据这些定义：\n- 通过枚举并排序所有分母至多为 $5$ 的既约分数，显式计算出 $F_{5}$。\n- 仅使用中介数的定义和算术不等式，验证对于你计算出的 $F_{5}$ 中的每一对相邻项 $\\frac{a}{b}  \\frac{c}{d}$，不存在满足 $1 \\leq s \\leq 5$ 的既约分数 $\\frac{r}{s}$ 使得 $\\frac{a}{b}  \\frac{r}{s}  \\frac{c}{d}$。\n\n对于你最终报告的值，请给出确切的基数 $|F_{5}|$。不需要四舍五入，也不涉及单位。", "solution": "该问题要求根据所提供的法里数列 $F_n$ 和两个分数的中介数的定义来完成三项任务。首先，我们必须显式计算出5阶法里数列，记为 $F_5$。其次，我们必须对这个计算出的序列的相邻项验证一个特定属性。第三，我们必须给出 $F_5$ 的基数。\n\n首先，我们计算 $F_5$。定义指出，$F_n$ 是在区间 $[0,1]$ 内，所有满足 $0 \\leq p \\leq q \\leq n$ 和 $\\gcd(p,q) = 1$ 的既约分数 $\\frac{p}{q}$ 按升序排列所组成的序列。对于 $n=5$，我们枚举所有分母 $q$ 从 $1$ 到 $5$ 的此类分数。\n\n- 当 $q=1$ 时：可能的分数为 $\\frac{0}{1}$ 和 $\\frac{1}{1}$。我们检查最大公约数(GCD)：$\\gcd(0,1)=1$ 和 $\\gcd(1,1)=1$。两者都包括在内。\n- 当 $q=2$ 时：可能的分子是 $p=1$。$\\frac{1}{2}$ 在区间 $[0,1]$ 内。我们检查 $\\gcd(1,2)=1$。所以，$\\frac{1}{2}$ 包括在内。分数 $\\frac{0}{2}$ 等价于 $\\frac{0}{1}$ 但不是既约分数，$\\frac{2}{2}$ 等价于 $\\frac{1}{1}$ 但不是既约分数。\n- 当 $q=3$ 时：既约分数的可能分子是 $p=1, 2$。我们检查 $\\gcd(1,3)=1$ 和 $\\gcd(2,3)=1$。所以，分数 $\\frac{1}{3}$ 和 $\\frac{2}{3}$ 包括在内。\n- 当 $q=4$ 时：既约分数的可能分子是 $p=1, 3$。我们检查 $\\gcd(1,4)=1$ 和 $\\gcd(3,4)=1$。分数 $\\frac{1}{4}$ 和 $\\frac{3}{4}$ 包括在内。$\\gcd(2,4)=2 \\neq 1$，所以 $\\frac{2}{4}$ 被排除。\n- 当 $q=5$ 时：既约分数的可能分子是 $p=1, 2, 3, 4$。对于所有这些分子，它们与 $5$ 的最大公约数都是 $1$，因为 $5$ 是一个素数。所以，分数 $\\frac{1}{5}, \\frac{2}{5}, \\frac{3}{5}, \\frac{4}{5}$ 都包括在内。\n\n所有这些分数的集合是 $\\left\\{ \\frac{0}{1}, \\frac{1}{1}, \\frac{1}{2}, \\frac{1}{3}, \\frac{2}{3}, \\frac{1}{4}, \\frac{3}{4}, \\frac{1}{5}, \\frac{2}{5}, \\frac{3}{5}, \\frac{4}{5} \\right\\}$。\n为了构成 $F_5$，我们必须将这些分数按升序排列。\n为了排序，转换为小数形式：\n$\\frac{0}{1} = 0.0$\n$\\frac{1}{5} = 0.2$\n$\\frac{1}{4} = 0.25$\n$\\frac{1}{3} \\approx 0.333$\n$\\frac{2}{5} = 0.4$\n$\\frac{1}{2} = 0.5$\n$\\frac{3}{5} = 0.6$\n$\\frac{2}{3} \\approx 0.667$\n$\\frac{3}{4} = 0.75$\n$\\frac{4}{5} = 0.8$\n$\\frac{1}{1} = 1.0$\n\n因此，排序后的序列 $F_5$ 是：\n$$ F_5 = \\left( \\frac{0}{1}, \\frac{1}{5}, \\frac{1}{4}, \\frac{1}{3}, \\frac{2}{5}, \\frac{1}{2}, \\frac{3}{5}, \\frac{2}{3}, \\frac{3}{4}, \\frac{4}{5}, \\frac{1}{1} \\right) $$\n\n第二，我们必须验证，对于我们计算出的 $F_5$ 中的每一对相邻项 $\\frac{a}{b}  \\frac{c}{d}$，不存在满足 $1 \\leq s \\leq 5$ 的既约分数 $\\frac{r}{s}$ 使得 $\\frac{a}{b}  \\frac{r}{s}  \\frac{c}{d}$。\n\n让我们假设对于 $F_5$ 中的一对相邻项 $\\frac{a}{b}$ 和 $\\frac{c}{d}$，存在这样一个分数 $\\frac{r}{s}$。\n条件 $\\frac{a}{b}  \\frac{r}{s}$ 意味着 $as  br$，因为 $b,s > 0$。由于所有分子和分母都是整数，这等价于 $br - as \\geq 1$。\n条件 $\\frac{r}{s}  \\frac{c}{d}$ 意味着 $rd  sc$，这等价于 $sc - rd \\geq 1$。\n\n我们可以操作这些不等式。将第一个不等式乘以 $d$，第二个不等式乘以 $b$：\n$bdr - ads \\geq d$\n$bcs - bdr \\geq b$\n将这两个不等式相加得到：\n$(bdr - ads) + (bcs - bdr) \\geq b+d$\n$bcs - ads \\geq b+d$\n$s(bc-ad) \\geq b+d$\n\n这意味着如果存在一个中间分数 $\\frac{r}{s}$，其分母 $s$ 必须满足 $s \\geq \\frac{b+d}{bc-ad}$。\n\n现在，我们将对我们计算出的 $F_5$ 中的所有相邻对验证两个属性：\n1. 表达式 $bc-ad$ 的值。\n2. 分母之和 $b+d$ 的值。\n\n$F_5$ 中的相邻对 $(\\frac{a}{b}, \\frac{c}{d})$ 是：\n1. $(\\frac{0}{1}, \\frac{1}{5})$: $a=0,b=1,c=1,d=5$。$bc-ad = (1)(1)-(0)(5) = 1$。$b+d=1+5=6$。\n2. $(\\frac{1}{5}, \\frac{1}{4})$: $a=1,b=5,c=1,d=4$。$bc-ad = (5)(1)-(1)(4) = 1$。$b+d=5+4=9$。\n3. $(\\frac{1}{4}, \\frac{1}{3})$: $a=1,b=4,c=1,d=3$。$bc-ad = (4)(1)-(1)(3) = 1$。$b+d=4+3=7$。\n4. $(\\frac{1}{3}, \\frac{2}{5})$: $a=1,b=3,c=2,d=5$。$bc-ad = (3)(2)-(1)(5) = 1$。$b+d=3+5=8$。\n5. $(\\frac{2}{5}, \\frac{1}{2})$: $a=2,b=5,c=1,d=2$。$bc-ad = (5)(1)-(2)(2) = 1$。$b+d=5+2=7$。\n6. $(\\frac{1}{2}, \\frac{3}{5})$: $a=1,b=2,c=3,d=5$。$bc-ad = (2)(3)-(1)(5) = 1$。$b+d=2+5=7$。\n7. $(\\frac{3}{5}, \\frac{2}{3})$: $a=3,b=5,c=2,d=3$。$bc-ad = (5)(2)-(3)(3) = 1$。$b+d=5+3=8$。\n8. $(\\frac{2}{3}, \\frac{3}{4})$: $a=2,b=3,c=3,d=4$。$bc-ad = (3)(3)-(2)(4) = 1$。$b+d=3+4=7$。\n9. $(\\frac{3}{4}, \\frac{4}{5})$: $a=3,b=4,c=4,d=5$。$bc-ad = (4)(4)-(3)(5) = 1$。$b+d=4+5=9$。\n10. $(\\frac{4}{5}, \\frac{1}{1})$: $a=4,b=5,c=1,d=1$。$bc-ad = (5)(1)-(4)(1) = 1$。$b+d=5+1=6$。\n\n对于 $F_5$ 中的每一对相邻项 $\\frac{a}{b}, \\frac{c}{d}$，我们都已确认 $bc-ad=1$。\n将此代入我们关于 $s$ 的不等式中：\n$s \\geq \\frac{b+d}{1} \\implies s \\geq b+d$。\n\n我们还从上面的列表中观察到，对于每一对相邻项，分母之和 $b+d$ 都严格大于 $5$。最小的和是 $6$。\n因此，对于任何要位于 $F_5$ 中一对相邻项之间的分数 $\\frac{r}{s}$，其分母 $s$ 必须大于或等于 $b+d$，并且由于 $b+d > 5$，我们必须有 $s > 5$。\n这与 $\\frac{r}{s}$ 是一个分母 $s \\leq 5$ 的既约分数的条件相矛盾。\n因此，我们的初始假设是错误的。在 $F_5$ 的任何一对相邻项之间，不存在满足 $1 \\leq s \\leq 5$ 的既约分数 $\\frac{r}{s}$。验证完成。\n\n第三，我们求 $F_5$ 的基数，记为 $|F_5|$。通过计算我们构建的序列中的元素个数：\n$$ F_5 = \\left( \\frac{0}{1}, \\frac{1}{5}, \\frac{1}{4}, \\frac{1}{3}, \\frac{2}{5}, \\frac{1}{2}, \\frac{3}{5}, \\frac{2}{3}, \\frac{3}{4}, \\frac{4}{5}, \\frac{1}{1} \\right) $$\n序列中有 $11$ 个项。因此，基数是 $11$。\n$|F_5| = 11$。", "answer": "$$\\boxed{11}$$", "id": "3085131"}, {"introduction": "掌握了基本构造后，我们可以探索一个更深刻的联系。这个练习将揭示，通过中介数 ($mediant$)（施特恩-布罗科特树 ($Stern-Brocot tree$) 的构建基础）来定位一个有理数的过程，如何惊人地对应于该数的连分数 ($continued$ $fraction$) 展开。通过具体计算，你将亲身体验数论中两个看似无关的概念是如何优雅地统一起来的。[@problem_id:3085116]", "problem": "设 $x$ 是一个正有理数。对于两个既约分数 $\\frac{a}{b}$ 和 $\\frac{c}{d}$（其中 $b>0$ 且 $d>0$），它们的中介数（mediant）定义为 $\\frac{a+c}{b+d}$。施特恩-布罗科特树的构造方法是：从边界分数 $\\frac{0}{1}$ 和 $\\frac{1}{0}$ 开始，递归地在相邻分数之间插入中介数。对于一个给定的有理数 $x$，从 $\\frac{0}{1}$ 和 $\\frac{1}{0}$ 到 $x$ 的唯一路径是通过在每一步将 $x$ 与当前边界的中介数进行比较，并相应地更新左边界或右边界来获得的。一个实数 $x$ 的简单连分数是形如 $[a_{0};a_{1},a_{2},\\dots,a_{n}]$ 的表达式，其中 $a_{0}\\in\\mathbb{Z}$ 且对于 $i\\geq 1$ 有 $a_{i}\\in\\mathbb{N}$，它通过对有理数使用欧几里得算法得到；其主渐近分数是截断形式 $[a_{0};a_{1},\\dots,a_{k}]$，其中 $0\\leq k\\leq n$。\n\n仅使用这些定义和欧几里得算法，对 $x=\\frac{37}{23}$ 执行以下操作：\n- 推导 $\\frac{37}{23}$ 的简单连分数并列出其主渐近分数。\n- 通过逐次取中介数，构造从 $\\frac{0}{1}$ 和 $\\frac{1}{0}$ 到 $\\frac{37}{23}$ 的唯一施特恩-布罗科特路径，并记录路径上遇到的完整中介数序列。\n- 从基本原理出发，解释为什么此路径上遇到的中介数会重现 $\\frac{37}{23}$ 的连分数渐近分数（并指明当最终的部分商超过 1 时，中间中介数在何处对应于中间渐近分数）。\n\n最后，报告从初始边界 $\\frac{0}{1}$ 和 $\\frac{1}{0}$ 到达 $\\frac{37}{23}$ 所需的中介数步骤总数（即沿路径产生新中介数的比较次数）。将最终答案表示为一个不带单位的整数。无需四舍五入。", "solution": "此问题要求我们对有理数 $x=\\frac{37}{23}$ 进行三部分分析，涉及其简单连分数、在施特恩-布罗科特树中的路径，并最终计算该路径的总步数。\n\n**1. 简单连分数及主渐近分数**\n\n我们使用欧几里得算法来推导 $\\frac{37}{23}$ 的简单连分数。\n$x_0 = \\frac{37}{23} = 1 + \\frac{14}{23}$  ($a_0 = 1$)\n$x_1 = \\frac{23}{14} = 1 + \\frac{9}{14}$   ($a_1 = 1$)\n$x_2 = \\frac{14}{9} = 1 + \\frac{5}{9}$    ($a_2 = 1$)\n$x_3 = \\frac{9}{5} = 1 + \\frac{4}{5}$     ($a_3 = 1$)\n$x_4 = \\frac{5}{4} = 1 + \\frac{1}{4}$     ($a_4 = 1$)\n$x_5 = 4$                       ($a_5 = 4$)\n因此，$\\frac{37}{23}$ 的简单连分数为 $[1; 1, 1, 1, 1, 4]$。\n\n接下来，我们计算其主渐近分数 $C_k = \\frac{p_k}{q_k}$：\n- $C_0 = [1] = \\frac{1}{1}$\n- $C_1 = [1; 1] = \\frac{2}{1}$\n- $C_2 = [1; 1, 1] = \\frac{3}{2}$\n- $C_3 = [1; 1, 1, 1] = \\frac{5}{3}$\n- $C_4 = [1; 1, 1, 1, 1] = \\frac{8}{5}$\n- $C_5 = [1; 1, 1, 1, 1, 4] = \\frac{37}{23}$\n主渐近分数序列为：$\\frac{1}{1}, \\frac{2}{1}, \\frac{3}{2}, \\frac{5}{3}, \\frac{8}{5}, \\frac{37}{23}$。\n\n**2. 施特恩-布罗科特路径**\n\n我们从边界 $[L, R] = [\\frac{0}{1}, \\frac{1}{0}]$ 开始，寻找 $x = \\frac{37}{23} \\approx 1.6087$。在每一步，我们计算中介数 $m = \\frac{a+c}{b+d}$ 并更新边界。\n1.  $m = \\frac{0+1}{1+0} = \\frac{1}{1}$。因为 $x > m$，新边界为 $[\\frac{1}{1}, \\frac{1}{0}]$。\n2.  $m = \\frac{1+1}{1+0} = \\frac{2}{1}$。因为 $x  m$，新边界为 $[\\frac{1}{1}, \\frac{2}{1}]$。\n3.  $m = \\frac{1+2}{1+1} = \\frac{3}{2} = 1.5$。因为 $x > m$，新边界为 $[\\frac{3}{2}, \\frac{2}{1}]$。\n4.  $m = \\frac{3+2}{2+1} = \\frac{5}{3} \\approx 1.667$。因为 $x  m$，新边界为 $[\\frac{3}{2}, \\frac{5}{3}]$。\n5.  $m = \\frac{3+5}{2+3} = \\frac{8}{5} = 1.6$。因为 $x > m$，新边界为 $[\\frac{8}{5}, \\frac{5}{3}]$。\n6.  $m = \\frac{8+5}{5+3} = \\frac{13}{8} = 1.625$。因为 $x  m$，新边界为 $[\\frac{8}{5}, \\frac{13}{8}]$。\n7.  $m = \\frac{8+13}{5+8} = \\frac{21}{13} \\approx 1.615$。因为 $x  m$，新边界为 $[\\frac{8}{5}, \\frac{21}{13}]$。\n8.  $m = \\frac{8+21}{5+13} = \\frac{29}{18} \\approx 1.611$。因为 $x  m$，新边界为 $[\\frac{8}{5}, \\frac{29}{18}]$。\n9.  $m = \\frac{8+29}{5+18} = \\frac{37}{23}$。找到目标分数。\n从初始边界到达 $\\frac{37}{23}$ 共需 9 步中介数计算。路径上遇到的完整中介数序列为：$\\frac{1}{1}, \\frac{2}{1}, \\frac{3}{2}, \\frac{5}{3}, \\frac{8}{5}, \\frac{13}{8}, \\frac{21}{13}, \\frac{29}{18}, \\frac{37}{23}$。\n\n**3. 关系解释**\n\n我们可以观察到，连分数的主渐近分数是施特恩-布罗科特路径上遇到的一部分中介数。具体来说，当连分数的部分商 $a_k=1$ 时，路径上的下一个中介数就是一个新的主渐近分数。当部分商 $a_k > 1$ 时（在本例中是 $a_5=4$），路径会连续向同一个方向移动 $a_k$ 次，生成 $a_k-1$ 个“中间渐近分数”（intermediate convergents），最后一步才生成下一个主渐近分数。\n例如，在本例中，从渐近分数 $\\frac{8}{5}$ (对应 $C_4$) 到 $\\frac{37}{23}$ (对应 $C_5$) 的路径，由于相应的连分数系数 $a_5=4$，施特恩-布罗科特算法会进行4次中介数计算：它先生成3个中间中介数 $\\frac{13}{8}, \\frac{21}{13}, \\frac{29}{18}$，然后才在第4步到达最终的渐近分数 $\\frac{37}{23}$。这些中间渐近分数可以表示为 $[1; 1, 1, 1, 1, j]$，其中 $j=1, 2, 3$。\n\n最终，到达 $\\frac{37}{23}$ 所需的中介数步骤总数是 9。", "answer": "$$\\boxed{9}$$", "id": "3085116"}, {"introduction": "法里数列和连分数不仅仅是理论上的构造，它们在有理逼近 ($rational$ $approximation$) 问题中扮演着核心角色。这个计算练习将引导你使用编程来比较两种逼近无理数 $\\sqrt{2}$ 的方法：一种是通过法里数列中的数，另一种是通过连分数的渐进分数 ($convergents$)。通过这个实践，你将从经验上验证一个深刻的结论：为什么连分数提供了“最佳”的有理逼近。[@problem_id:3085115]", "problem": "考虑在区间 $\\left[1,2\\right]$ 上的 $N$ 阶局部法里集，其定义为所有满足 $1 \\leq \\frac{a}{b} \\leq 2$、$\\gcd(a,b)=1$ 且 $b \\leq N$ 的既约分数 $\\frac{a}{b}$ 按升序排列构成的集合。两个分数 $\\frac{a}{b}$ 和 $\\frac{c}{d}$ 的中介数是 $\\frac{a+c}{b+d}$。在数论中，实数 $x$ 的简单连分数展开会生成其渐近分数，这是一个由有理数近似值构成的特殊序列 $\\frac{p_k}{q_k}$，可通过递推关系式 $p_{-2}=0$, $p_{-1}=1$, $p_k=a_k p_{k-1}+p_{k-2}$ 和 $q_{-2}=1$, $q_{-1}=0$, $q_k=a_k q_{k-1}+q_{k-2}$ 计算，其中 $a_k=\\lfloor x_k \\rfloor$ 且 $x_{k+1}=\\frac{1}{x_k-a_k}$，$x_0=x$，$\\lfloor \\cdot \\rfloor$ 表示向下取整函数。\n\n仅使用这些基本定义和事实，实现一个程序，对于每个指定的阶数 $N$，针对无理数 $\\sqrt{2}$ 执行以下任务：\n\n1. 构造在 $\\left[1,2\\right]$ 上的 $N$ 阶局部法里集，并确定将 $\\sqrt{2}$ 包夹在内的两个法里邻项，即 $L_N=\\max\\left\\{\\frac{a}{b} : \\frac{a}{b}\\sqrt{2}, \\ b\\leq N, \\ \\gcd(a,b)=1, \\ 1 \\leq \\frac{a}{b} \\leq 2\\right\\}$ 和 $U_N=\\min\\left\\{\\frac{a}{b} : \\frac{a}{b}>\\sqrt{2}, \\ b\\leq N, \\ \\gcd(a,b)=1, \\ 1 \\leq \\frac{a}{b} \\leq 2\\right\\}$。计算它们的绝对误差 $E_L=\\sqrt{2}-L_N$ 和 $E_U=U_N-\\sqrt{2}$，并定义最佳局部法里误差 $E_F(N)=\\min\\{E_L,E_U\\}$。\n\n2. 生成 $\\sqrt{2}$ 的简单连分数展开中所有分母满足 $q_k \\leq N$ 的渐近分数 $\\frac{p_k}{q_k}$，并计算它们的绝对误差 $E_k=\\left|\\frac{p_k}{q_k}-\\sqrt{2}\\right|$。定义最佳渐近分数误差 $E_C(N)=\\min\\left\\{E_k : q_k \\leq N\\right\\}$。\n\n3. 通过报告 $E_F(N)$ 和 $E_C(N)$ 这两个值以及一个布尔值来比较它们，该布尔值指示最佳局部法里近似值是否等于最佳渐近分数（也就是说，实现 $E_F(N)$ 的有理数是否与实现 $E_C(N)$ 的 $\\frac{p_k}{q_k}$ 完全相同）。\n\n您的程序必须仅使用整数算术生成有理数，并使用欧几里得算法进行 $\\gcd$ 计算，同时使用 $\\sqrt{2}$ 的浮点数估值进行误差计算。不要使用任何硬编码的 $\\sqrt{2}$ 渐近分数；它们必须通过上述连分数过程从第一性原理生成。\n\n测试套件：\n- 使用以下阶数 $N$ 来测试计算的不同方面：$N=1$（边界情况）、$N=2$（第一个非平凡情况）、$N=5$（中等情况）、$N=12$（较大的中等范围）和 $N=50$（主要情况）。\n- 对于测试套件中的每个 $N$，计算并报告三元组 $\\left(E_F(N),E_C(N),\\text{Equal}(N)\\right)$，其中 $\\text{Equal}(N)$ 是一个布尔值，说明最佳局部法里近似值是否等于分母至多为 $N$ 的最佳渐近分数。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表。按 $N=1,2,5,12,50$ 的顺序附加每个测试用例的值，并在每个测试用例中，依次附加 $E_F(N)$、$E_C(N)$ 和 $\\text{Equal}(N)$。例如，输出应类似于 $\\left[\\text{value}_{1},\\text{value}_{2},\\text{value}_{3},\\ldots\\right]$，对于五个测试用例，该扁平列表总共包含 $15$ 个条目。所有误差都是无单位的实数。", "solution": "用户的请求是一个定义明确的数论计算问题。它要求实现算法，从两个不同的候选集合中找到 $\\sqrt{2}$ 的最佳有理数近似值：一个是“局部法里集”，另一个是连分数渐近分数的集合。该问题是有效的，因为它基于标准的、数学上合理的定义，并要求进行具体、可验证的计算。\n\n解决方案将构建为一系列函数，每个函数处理问题的一部分。一个主循环将遍历指定的阶数 $N$ 的测试用例。\n\n### 数学和算法策略\n\n问题的核心是实现两个不同的程序来寻找 $\\sqrt{2}$ 的有理数近似值，然后比较它们的结果。目标值为 $x = \\sqrt{2}$。\n\n#### 1. 局部法里集分析\n\n问题将区间 $[1, 2]$ 上的 $N$ 阶“局部法里集”定义为满足 $1 \\le b \\le N$ 和 $1 \\le \\frac{a}{b} \\le 2$ 的既约分数 $\\frac{a}{b}$ 的集合。任务是找到这个集合中最紧密地包夹 $\\sqrt{2}$ 的两个分数，一个从下方逼近（$L_N$），一个从上方逼近（$U_N$）。\n\n寻找 $L_N$ 和 $U_N$ 的算法将是基于所提供定义的直接搜索：\n1.  将下界近似值 $L_N$ 初始化为 $\\frac{1}{1}$，上界 $U_N$ 初始化为 $\\frac{2}{1}$。它们是区间 $[1, 2]$ 的端点，并且保证对于任何 $N \\ge 1$ 都在集合中。\n2.  遍历所有可能的分母 $b$（从 $1$ 到 $N$）。\n3.  对于每个 $b$，遍历所有可能的分子 $a$，使得分数 $\\frac{a}{b}$ 位于区间 $[1, 2]$ 内。这对应于范围 $b \\le a \\le 2b$。\n4.  对于每对 $(a, b)$，通过计算 $\\gcd(a, b)$ 来检查分数是否为既约分数。此步骤使用欧几里得算法。\n5.  如果 $\\gcd(a, b) = 1$，则分数 $\\frac{a}{b}$ 是局部法里集的一个成员。我们将其与 $\\sqrt{2}$ 进行比较：\n    -   如果 $L_N  \\frac{a}{b}  \\sqrt{2}$，我们找到了一个更好的下界，因此我们更新 $L_N = \\frac{a}{b}$。\n    -   如果 $\\sqrt{2}  \\frac{a}{b}  U_N$，我们找到了一个更好的上界，因此我们更新 $U_N = \\frac{a}{b}$。\n6.  在检查完所有有效的数对 $(a, b)$ 后，我们就能找到所需的 $L_N$ 和 $U_N$。\n7.  计算误差 $E_L = \\sqrt{2} - L_N$ 和 $E_U = U_N - \\sqrt{2}$。\n8.  最佳局部法里误差为 $E_F(N) = \\min(E_L, E_U)$。将对应于此最小误差的分数存储起来，以备最终比较。\n\n#### 2. 生成连分数渐近分数\n\n问题要求使用给定的递推关系式从第一性原理生成 $\\sqrt{2}$ 的渐近分数 $\\frac{p_k}{q_k}$。\n\n生成渐近分数并找到分母 $q_k \\le N$ 的最佳渐近分数的算法如下：\n1.  初始化递推关系式的各项：$p_{-2}=0, p_{-1}=1$ 和 $q_{-2}=1, q_{-1}=0$。\n2.  初始化连分数算法的值：$x_0 = \\sqrt{2}$。\n3.  启动一个循环来生成系数 $a_k$ 和渐近分数 $\\frac{p_k}{q_k}$：\n    -   计算整数部分：$a_k = \\lfloor x_k \\rfloor$。\n    -   使用递推式计算新的渐近分数的分子和分母：$p_k = a_k p_{k-1} + p_{k-2}$ 和 $q_k = a_k q_{k-1} + q_{k-2}$。\n    -   如果 $q_k > N$，则分母已超过允许的限制。循环终止。\n    -   存储有效的渐近分数 $\\frac{p_k}{q_k}$。\n    -   为下一次迭代更新 $x_k$：$x_{k+1} = \\frac{1}{x_k - a_k}$。其中包含一个防止除以零的检查，尽管对于像 $\\sqrt{2}$ 这样的无理数来说这不是问题。\n    -   为下一次递推计算更新 $p$ 和 $q$ 序列的前两项。\n4.  一旦生成了所有满足 $q_k \\le N$ 的渐近分数，就遍历它们以找到具有最小绝对误差 $E_k = |\\frac{p_k}{q_k} - \\sqrt{2}|$ 的那个。\n5.  这个最小误差就是 $E_C(N)$，并将相应的分数 $\\frac{p_k}{q_k}$ 存储起来以备最终比较。\n\n#### 3. 比较与最终输出\n\n对于测试套件中的每个 $N$ 值：\n1.  执行上述两个过程，以找到 $E_F(N)$、$E_C(N)$、最佳局部法里近似值和最佳渐近分数。\n2.  通过比较两个最佳近似分数的分子和分母来确定一个布尔值 $\\text{Equal}(N)$。\n3.  将得到的三元组 $(E_F(N), E_C(N), \\text{Equal}(N))$ 存储起来。\n4.  处理完所有测试用例后，将收集到的结果按规定格式化为单个扁平列表，形式为方括号内由逗号分隔的字符串。\n\n该方法严格遵守了问题的约束，仅使用基本定义和整数算术来生成分数，同时使用浮点数进行误差评估。", "answer": "```python\nimport math\n\ndef solve():\n    \"\"\"\n    Solves the number theory problem for a given set of orders N.\n    \"\"\"\n\n    def get_farey_approximation(N, target):\n        \"\"\"\n        Constructs the localized Farey set of order N on [1, 2] and finds the\n        best approximation to the target value.\n        \"\"\"\n        # Initialize lower and upper bounds with the interval endpoints [1, 2].\n        # These are guaranteed to be in the set for N >= 1.\n        l_n_num, l_n_den = 1, 1\n        u_n_num, u_n_den = 2, 1\n\n        # Brute-force search over all possible fractions\n        for b in range(1, N + 1):\n            # The condition 1 = a/b = 2 implies b = a = 2b.\n            for a in range(b, 2 * b + 1):\n                if math.gcd(a, b) == 1:\n                    frac_val = a / b\n                    if frac_val  target:\n                        # Better lower bound\n                        if frac_val > l_n_num / l_n_den:\n                            l_n_num, l_n_den = a, b\n                    elif frac_val > target:\n                        # Better upper bound\n                        if frac_val  u_n_num / u_n_den:\n                            u_n_num, u_n_den = a, b\n\n        # Calculate errors for the best lower and upper bounds\n        e_l = target - (l_n_num / l_n_den)\n        e_u = (u_n_num / u_n_den) - target\n\n        # Determine the best Farey approximation\n        if e_l  e_u:\n            e_f_n = e_l\n            best_farey_approximant = (l_n_num, l_n_den)\n        else:\n            e_f_n = e_u\n            best_farey_approximant = (u_n_num, u_n_den)\n\n        return e_f_n, best_farey_approximant\n\n    def get_convergent_approximation(N, target):\n        \"\"\"\n        Generates continued fraction convergents of the target and finds the best\n        approximation with denominator at most N.\n        \"\"\"\n        # Initialize recurrence relations as per the problem statement\n        p_prev2, p_prev1 = 0, 1\n        q_prev2, q_prev1 = 1, 0\n\n        x_k = target\n        \n        convergents = []\n        \n        while True:\n            a_k = math.floor(x_k)\n\n            # Calculate the next convergent using the recurrence\n            p_k = a_k * p_prev1 + p_prev2\n            q_k = a_k * q_prev1 + q_prev2\n            \n            # Stop if the denominator exceeds the order N\n            if q_k > N:\n                break\n\n            convergents.append((p_k, q_k))\n\n            # Update state for the next iteration\n            p_prev2, p_prev1 = p_prev1, p_k\n            q_prev2, q_prev1 = q_prev1, q_k\n            \n            # Calculate the next x_k for the continued fraction expansion\n            remainder = x_k - a_k\n            # Avoid division by zero (for rational numbers, though not an issue here)\n            if abs(remainder)  1e-15:\n                break\n            x_k = 1.0 / remainder\n        \n        if not convergents:\n            return float('inf'), (None, None)\n\n        # Find the convergent with the minimum error\n        best_convergent_error = float('inf')\n        best_convergent = None\n        for p, q in convergents:\n            error = abs(p / q - target)\n            if error  best_convergent_error:\n                best_convergent_error = error\n                best_convergent = (p, q)\n        \n        e_c_n = best_convergent_error\n\n        return e_c_n, best_convergent\n\n    # The irrational number to approximate\n    target_val = math.sqrt(2)\n    # Test cases specified in the problem\n    test_cases = [1, 2, 5, 12, 50]\n\n    results = []\n    for N in test_cases:\n        e_f_n, best_farey_frac = get_farey_approximation(N, target_val)\n        e_c_n, best_convergent_frac = get_convergent_approximation(N, target_val)\n        \n        # Compare the fractions to determine equality\n        is_equal = (best_farey_frac == best_convergent_frac)\n\n        results.extend([e_f_n, e_c_n, is_equal])\n\n    # Format the final output as a single comma-separated list string\n    # Using a high precision format for the floating point numbers\n    formatted_results = [f\"{v:.16f}\" if isinstance(v, float) else str(v) for v in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3085115"}]}