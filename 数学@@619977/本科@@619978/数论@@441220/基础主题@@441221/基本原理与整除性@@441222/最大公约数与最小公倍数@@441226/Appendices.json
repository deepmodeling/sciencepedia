{"hands_on_practices": [{"introduction": "欧几里得算法是计算最大公约数（GCD）的基石，是数论中最古老也最重要的算法之一。本次练习的目标不仅仅是应用算法求出答案，更在于从第一性原理出发，深刻理解该算法为何有效。通过追踪计算过程中的每一步，并证明其核心不变量 $\\gcd(r_{i}, r_{i+1}) = \\gcd(a, b)$ 始终成立，你将建立对算法正确性的直观而坚实的理解。[@problem_id:3085697]", "problem": "设正整数 $a = 123456$ 和 $b = 7890$。目标是计算 $a$ 和 $b$ 的最大公约数 (GCD)，并从第一性原理出发证明欧几里得算法的正确性。按以下步骤进行：\n- 仅使用最大公约数 (GCD) 的定义和除法算法：对于整数 $x$ 和 $y$ (其中 $y \\neq 0$)，存在唯一的整数 $q$ 和 $r$ 使得 $x = qy + r$ 且 $0 \\le r  y$。对 $a$ 和 $b$ 应用欧几里得算法，执行连续的除法，并在每一步记录商和余数。将余数序列记为 $r_{0} = a$，$r_{1} = b$，并且对于 $i \\ge 1$，将 $r_{i+1}$ 定义为 $r_{i-1}$ 除以 $r_{i}$ 的余数。\n- 仅使用整除性的定义和除法算法，在每个阶段证明为何不变量 $\\gcd(r_{i}, r_{i+1}) = \\gcd(a, b)$ 保持成立，直到算法终止。您的证明应基于连续步骤中公约数集合的等价性。\n- 以单个整数形式报告 $\\gcd(123456, 7890)$ 的精确值。无需四舍五入，不涉及单位。最终答案必须是单个数字。", "solution": "该问题是有效的，因为它是初等数论中一个适定问题，基于已建立的数学原理，并为唯一解提供了所有必要的信息。我们被要求计算两个整数 $a = 123456$ 和 $b = 7890$ 的最大公约数 (GCD)，并证明用于此计算的欧几里得算法的正确性。\n\n证明的关键在于源自除法算法的一个基本性质。设 $x$ 和 $y$ 为整数，其中 $y \\neq 0$。除法算法指出，存在唯一的整数 $q$ (商) 和 $r$ (余数) 使得 $x = qy + r$ 且 $0 \\le r  |y|$。欧几里得算法的核心原理是，$x$ 和 $y$ 的最大公约数与 $y$ 和 $r$ 的最大公约数相同。用符号表示为 $\\gcd(x, y) = \\gcd(y, r)$。\n\n为从第一性原理证明这一点，我们必须证明 $x$ 和 $y$ 的公约数集合与 $y$ 和 $r$ 的公约数集合是相同的。设 $C(u, v)$ 表示整数 $u$ 和 $v$ 的公约数集合。我们需要证明 $C(x, y) = C(y, r)$。\n\n首先，设 $d$ 是 $x$ 和 $y$ 的一个公约数。这意味着 $d|x$ 且 $d|y$。从除法算法的等式中，我们可以将余数写为 $r = x - qy$。由于 $d|x$ 且 $d|y$，$d$ 也必定能整除 $x$ 和 $y$ 的任何整数线性组合，包括 $x - qy$。因此，$d|r$。因为 $d$ 已经能整除 $y$，所以 $d$ 是 $y$ 和 $r$ 的一个公约数。这表明 $C(x, y)$ 的任何元素也是 $C(y, r)$ 的一个元素，所以 $C(x, y) \\subseteq C(y, r)$。\n\n其次，设 $d'$ 是 $y$ 和 $r$ 的一个公约数。这意味着 $d'|y$ 且 $d'|r$。从等式 $x = qy + r$ 中，我们看到由于 $d'|y$ 且 $d'|r$，$d'$ 也必定能整除线性组合 $qy + r$。因此，$d'|x$。因为 $d'$ 已经能整除 $y$，所以 $d'$ 是 $x$ 和 $y$ 的一个公约数。这表明 $C(y, r)$ 的任何元素也是 $C(x, y)$ 的一个元素，所以 $C(y, r) \\subseteq C(x, y)$。\n\n由于 $C(x, y) \\subseteq C(y, r)$ 且 $C(y, r) \\subseteq C(x, y)$，这两个集合必然相等：$C(x, y) = C(y, r)$。因为公约数的集合是相同的，它们的最大元素也必然相同。因此，$\\gcd(x, y) = \\gcd(y, r)$。\n\n欧几里得算法是该原理的连续应用。给定 $r_0 = a$ 和 $r_1 = b$，我们生成一个余数序列 $r_2, r_3, \\dots, r_{n+1}$，其中对于 $i \\ge 1$ 有 $r_{i-1} = q_i r_i + r_{i+1}$ 且 $0 \\le r_{i+1}  r_i$。这个余数序列是严格递减且非负的，所以它最终必须达到余数 $0$。设 $r_{n+1} = 0$。最后一个非零余数 $r_n$ 就是 $a$ 和 $b$ 的最大公约数。这可以从以下等式链得出：\n$\\gcd(a, b) = \\gcd(r_0, r_1) = \\gcd(r_1, r_2) = \\dots = \\gcd(r_{n-1}, r_n) = \\gcd(r_n, r_{n+1}) = \\gcd(r_n, 0)$。\n任何非零整数 $k$ 和 $0$ 的最大公约数是 $|k|$，因为任何非零整数都能整除 $0$。由于我们的余数都是非负的，所以 $\\gcd(r_n, 0) = r_n$。\n\n我们现在将此算法应用于 $a = 123456$ 和 $b = 7890$。\n设 $r_0 = 123456$ 且 $r_1 = 7890$。\n\n第1步：将 $r_0$ 除以 $r_1$。\n$123456 = 15 \\times 7890 + 5106$。\n这里，商 $q_1 = 15$，余数是 $r_2 = 5106$。\n根据我们已建立的原理，$\\gcd(123456, 7890) = \\gcd(7890, 5106)$。\n\n第2步：将 $r_1$ 除以 $r_2$。\n$7890 = 1 \\times 5106 + 2784$。\n这里，商 $q_2 = 1$，余数是 $r_3 = 2784$。\n这意味着 $\\gcd(7890, 5106) = \\gcd(5106, 2784)$。\n\n第3步：将 $r_2$ 除以 $r_3$。\n$5106 = 1 \\times 2784 + 2322$。\n这里，商 $q_3 = 1$，余数是 $r_4 = 2322$。\n这意味着 $\\gcd(5106, 2784) = \\gcd(2784, 2322)$。\n\n第4步：将 $r_3$ 除以 $r_4$。\n$2784 = 1 \\times 2322 + 462$。\n这里，商 $q_4 = 1$，余数是 $r_5 = 462$。\n这意味着 $\\gcd(2784, 2322) = \\gcd(2322, 462)$。\n\n第5步：将 $r_4$ 除以 $r_5$。\n$2322 = 5 \\times 462 + 12$。\n这里，商 $q_5 = 5$，余数是 $r_6 = 12$。\n这意味着 $\\gcd(2322, 462) = \\gcd(462, 12)$。\n\n第6步：将 $r_5$ 除以 $r_6$。\n$462 = 38 \\times 12 + 6$。\n这里，商 $q_6 = 38$，余数是 $r_7 = 6$。\n这意味着 $\\gcd(462, 12) = \\gcd(12, 6)$。\n\n第7步：将 $r_6$ 除以 $r_7$。\n$12 = 2 \\times 6 + 0$。\n这里，商 $q_7 = 2$，余数是 $r_8 = 0$。\n这意味着 $\\gcd(12, 6) = \\gcd(6, 0)$。\n\n算法因余数为 $0$ 而终止。最后一个非零余数是 $r_7 = 6$。\n结合等式链：\n$\\gcd(123456, 7890) = \\gcd(7890, 5106) = \\gcd(5106, 2784) = \\gcd(2784, 2322) = \\gcd(2322, 462) = \\gcd(462, 12) = \\gcd(12, 6) = \\gcd(6, 0) = 6$。\n\n因此，$123456$ 和 $7890$ 的最大公约数是 $6$。", "answer": "$$\\boxed{6}$$", "id": "3085697"}, {"introduction": "在掌握了欧几里得算法的基本原理后，我们可以探索其强大的扩展形式，它揭示了关于最大公约数的更深层次的结构。本练习要求你实现扩展欧几里得算法，用以寻找贝祖系数——即满足贝祖等式 $ax + by = \\gcd(a,b)$ 的一对整数 $x$ 和 $y$。通过将抽象理论转化为一个完整的、可运行的计算机程序，你不仅能巩固对算法的理解，还能学习如何处理编程实践中遇到的边界情况（如零和负数输入）和计算限制（如整数溢出），这是连接理论与应用的宝贵一课。[@problem_id:3085685]", "problem": "您需要实现一个完整的、可运行的程序，该程序通过扩展欧几里得算法计算整数对的裴蜀系数，同时计算最大公约数和最小公倍数。整数的界限为 $\\lvert a \\rvert, \\lvert b \\rvert \\le 10^9$。您的方法必须从基本的数论定义出发，并且除了这些基础知识外，不得假定任何预先封装好的结果。\n\n基本原理：\n- 最大公约数的定义：对于不全为零的整数 $a$ 和 $b$，最大公约数 $\\gcd(a,b)$ 是唯一的非负整数 $g$，使得 $g \\mid a$，$g \\mid b$，并且对于任何满足 $d \\mid a$ 和 $d \\mid b$ 的整数 $d$，都有 $d \\le g$。\n- 带余除法（除法算法）：对于整数 $x$ 和 $y \\ne 0$，存在唯一的整数 $q$ 和 $r$，使得 $x = y q + r$ 且 $0 \\le r  \\lvert y \\rvert$。\n- 欧几里得算法：余数序列 $r_0 = \\lvert a \\rvert$, $r_1 = \\lvert b \\rvert$ 以及 $r_{k+1} = r_{k-1} - q_k r_k$（其中 $q_k = \\lfloor r_{k-1} / r_k \\rfloor$）将终止于 $r_m = \\gcd(\\lvert a \\rvert, \\lvert b \\rvert)$。\n- 裴蜀系数的定义：整数 $x$ 和 $y$ 满足 $a x + b y = \\gcd(a,b)$。\n- 最小公倍数的定义：最小公倍数 $\\operatorname{lcm}(a,b)$ 是能同时被 $a$ 和 $b$ 整除的最小非负整数；对于不全为零的 $a$ 和 $b$，$\\operatorname{lcm}(a,b) = \\lvert a b \\rvert / \\gcd(a,b)$，且 $\\operatorname{lcm}(0,0) = 0$。\n\n任务：\n- 根据上述原理实现扩展欧几里得算法，为每个测试用例计算一个四元组 $\\big(\\gcd(a,b), x, y, \\operatorname{lcm}(a,b)\\big)$，其中 $x$ 和 $y$ 满足 $a x + b y = \\gcd(a,b)$ 且 $\\gcd(a,b) \\ge 0$。约定 $\\gcd(0,0) = 0$，此时任何有效的裴蜀系数对均为 $x = 0, y = 0$。\n- 根据底层整数算術，解释如何避免在系数更新（例如 $s_{k+1} = s_{k-1} - q_k s_k$ 和 $t_{k+1} = t_{k-1} - q_k t_k$）中出现整数溢出，以及如何以避免溢出的方式计算 $\\operatorname{lcm}(a,b)$。\n\n约束条件：\n- 输入满足 $\\lvert a \\rvert, \\lvert b \\rvert \\le 10^9$。\n- 最小公倍数应报告为非负整数，对于任何整数 $b$，$\\operatorname{lcm}(0,b) = 0$。\n\n测试套件：\n您的程序必须为以下整数对 $(a,b)$ 列表计算结果：\n- $(12,18)$\n- $(0,0)$\n- $(0,5)$\n- $(10^9,1)$\n- $(-10^9,10^9)$\n- $(832040,514229)$\n- $(-24,-18)$\n- $(123456789,987654321)$\n- $(0,-7)$\n- $(1,10^9)$\n- $(7,-3)$\n\n答案规格：\n- 对于每个测试用例，输出列表 $[\\gcd(a,b), x, y, \\operatorname{lcm}(a,b)]$。\n- 将所有测试用例的结果按给定顺序汇总到单行中，该行是一个用方括号括起来的逗号分隔列表，其中每个元素本身是对应一个测试用例的列表。例如，整体格式必须类似于 $[[g_1,x_1,y_1,\\ell_1],[g_2,x_2,y_2,\\ell_2],\\dots]$。\n- 输出必须是程序打印的单行内容。不应打印任何额外的注释。\n\n您的提交必须是如上所述的完整、可运行的程序，无用户输入。", "solution": "该问题经评估有效。它在数论方面有科学依据，问题提出得当且客观。它提供了一整套定义、约束和测试用例，构成了一个自洽且一致的计算任务规范。我们可以着手解决。\n\n### 数学基础\n\n1.  **最大公约数（GCD）与欧几里得算法**：欧几里得算法是计算两个整数最大公约数（GCD）的高效方法。它基于原理 $\\gcd(a, b) = \\gcd(b, a \\pmod b)$。该算法迭代应用此性质。给定输入 $r_0 = a$ 和 $r_1 = b$，序列由 $r_{k+1} = r_{k-1} \\pmod{r_k}$ 定义，这等同于带余除法中的 $r_{k-1} = q_k r_k + r_{k+1}$。最后一个非零余数 $r_m$ 即为 GCD。GCD 定义为非负数，因此我们通常使用绝对值：$\\gcd(a,b) = \\gcd(\\lvert a \\rvert, \\lvert b \\rvert)$。按照约定，$\\gcd(0,0)=0$。\n\n2.  **扩展欧几里得算法与裴蜀恒等式**：裴蜀恒等式指出，对于整数 $a$ 和 $b$，存在整数 $x$ 和 $y$（裴蜀系数），使得 $ax + by = \\gcd(a,b)$。扩展欧几里得算法在计算 GCD 的同时计算这些系数。它维护两个序列 $s_k$ 和 $t_k$，使得在每一步 $k$，恒等式 $r_k = a s_k + b t_k$ 都成立。\n    从 $r_0=a$ 和 $r_1=b$ 开始，我们有：\n    - $r_0 = a \\cdot 1 + b \\cdot 0 \\implies (s_0, t_0) = (1, 0)$\n    - $r_1 = a \\cdot 0 + b \\cdot 1 \\implies (s_1, t_1) = (0, 1)$\n    余数的递推关系为 $r_{k+1} = r_{k-1} - q_k r_k$。代入裴蜀表达式：\n    $$a s_{k+1} + b t_{k+1} = (a s_{k-1} + b t_{k-1}) - q_k (a s_k + b t_k)$$\n    $$a s_{k+1} + b t_{k+1} = a(s_{k-1} - q_k s_k) + b(t_{k-1} - q_k t_k)$$\n    这导出了系数的递推关系：\n    - $s_{k+1} = s_{k-1} - q_k s_k$\n    - $t_{k+1} = t_{k-1} - q_k t_k$\n    算法在 $r_{k+1}=0$ 时终止，此时 $r_k = \\gcd(a,b)$，对应的系数为 $s_k$ 和 $t_k$。\n\n3.  **最小公倍数（LCM）**：对于非零的 $a, b$，最小公倍数由恒等式 $\\operatorname{lcm}(a,b) = \\frac{\\lvert a b \\rvert}{\\gcd(a,b)}$ 定义。问题规定对于任何整数 $b$，$\\operatorname{lcm}(a,0)=\\operatorname{lcm}(0,b)=0$。\n\n### 算法实现\n\n该实现将包含一个主函数，用于处理所有情况，包括一个或两个输入为零的边缘情况。对于非零输入的一般情况，它将使用一个实现扩展欧几里得算法的辅助函数。\n\n**处理特殊情况**：\n- 如果 $a = 0$ 且 $b = 0$：问题规定 $\\gcd(0,0) = 0$，我们选择 $x=0, y=0$，因此 $0 \\cdot 0 + 0 \\cdot 0 = 0$。$\\operatorname{lcm}(0,0)=0$。结果是 $(0, 0, 0, 0)$。\n- 如果 $a = 0, b \\ne 0$：$\\gcd(0,b) = \\lvert b \\rvert$。我们需要 $0 \\cdot x + b \\cdot y = \\lvert b \\rvert$。这简化为 $b \\cdot y = \\lvert b \\rvert$。一个解是 $y = \\lvert b \\rvert / b = \\operatorname{sgn}(b)$，我们可以选择 $x=0$。$\\operatorname{lcm}(0,b)=0$。例如，对于 $(0,5)$，结果是 $(5, 0, 1, 0)$。对于 $(0,-7)$，结果是 $(7, 0, -1, 0)$。\n- 如果 $a \\ne 0, b = 0$：对称地，$\\gcd(a,0) = \\lvert a \\rvert$。我们需要 $a \\cdot x + 0 \\cdot y = \\lvert a \\rvert$。这得出 $x = \\lvert a \\rvert / a = \\operatorname{sgn}(a)$，我们可以选择 $y=0$。$\\operatorname{lcm}(a,0)=0$。\n\n**一般情况（$a \\ne 0, b \\ne 0$）：**\n为简化逻辑，首先将扩展欧几里得算法应用于输入的绝对值 $\\lvert a \\rvert$ 和 $\\lvert b \\rvert$。假设这得到 $(g, x', y')$ 使得 $\\lvert a \\rvert x' + \\lvert b \\rvert y' = g$，其中 $g = \\gcd(\\lvert a \\rvert, \\lvert b \\rvert) = \\gcd(a,b)$。我们需要为原始的 $a, b$ 找到 $x, y$。\n我们可以写成 $a = \\operatorname{sgn}(a) \\lvert a \\rvert$ 和 $b = \\operatorname{sgn}(b) \\lvert b \\rvert$，其中我们定义 $\\operatorname{sgn}(n)=1$ 如果 $n \\ge 0$ 且 $\\operatorname{sgn}(n)=-1$ 如果 $n  0$。将这些代入算法得到的恒等式中：\n$$g = \\lvert a \\rvert x' + \\lvert b \\rvert y' = \\left(\\frac{a}{\\operatorname{sgn}(a)}\\right) x' + \\left(\\frac{b}{\\operatorname{sgn}(b)}\\right) y' = a \\left(\\frac{x'}{\\operatorname{sgn}(a)}\\right) + b \\left(\\frac{y'}{\\operatorname{sgn}(b)}\\right)$$\n由于 $\\operatorname{sgn}(n)$ 是其自身的逆（即为 $\\pm 1$），我们有 $1/\\operatorname{sgn}(n) = \\operatorname{sgn}(n)$。\n$$g = a (\\operatorname{sgn}(a)x') + b (\\operatorname{sgn}(b)y')$$\n因此，我们可以将最终系数设置为 $x = \\operatorname{sgn}(a) x'$ 和 $y = \\operatorname{sgn}(b) y'$。这系统地处理了所有符号组合。\n\n### 避免整数溢出\n\n问题要求解释如何管理潜在的整数溢出，这在使用固定大小整数的语言（例如C++中的64位 `long long`）中尤其重要。Python的任意精度整数将此问题抽象掉了，但底层的算术原理很重要。\n\n1.  **裴蜀系数更新**：更新步骤是 $s_{\\text{new}} = s_{\\text{old}} - q \\cdot s$ 和 $t_{\\text{new}} = t_{\\text{old}} - q \\cdot t$。系数 $s$ 和 $t$ 在算法执行过程中会增长。一个已知的结果是（例如，源自 Knuth 的《计算机程序设计艺术》第二卷），对于正整数 $a, b$，标准算法产生的最终裴蜀系数 $x, y$ 满足 $\\lvert x \\rvert \\le b/\\gcd(a,b)$ 和 $\\lvert y \\rvert \\le a/\\gcd(a,b)$。中间系数的大小受这些最终值限制。商 $q = \\lfloor r_{\\text{old}}/r \\rfloor$ 在 $r$很小时可能会很大。例如，对于输入 $(A, 1)$，第一个商是 $A$。更新乘积之一，如 $q \\cdot t$，可能大至 $A \\cdot 1 = A$。在更复杂的情况下，可以估算乘积 $q \\cdot t$。我们有 $r_{\\text{old}} \\approx q \\cdot r$，并且知道 $r_{\\text{old}} = a \\cdot s_{\\text{old}} + b \\cdot t_{\\text{old}}$ 和 $r = a \\cdot s + b \\cdot t$。因此，$a \\cdot s_{\\text{old}} + b \\cdot t_{\\text{old}} \\approx q(a \\cdot s + b \\cdot t)$。像 $q \\cdot t$ 这样的中间乘积的最大值受 $\\frac{\\lvert ab \\rvert}{\\gcd(a,b)^2}$ 的限制。对于给定的约束 $\\lvert a \\rvert, \\lvert b \\rvert \\le 10^9$，最大可能值出现在互质数的情况下，其数量级可达 $\\lvert ab \\rvert \\approx (10^9)^2 = 10^{18}$。这个值可以容纳在一个标准的64位有符号整数中（其最大值约为 $9 \\times 10^{18}$）。因此，使用64位整数类型进行计算足以防止系数更新中的溢出。Python的标准整数满足这一要求。\n\n2.  **LCM计算**：LCM的公式是 $\\operatorname{lcm}(a,b) = \\frac{\\lvert a \\cdot b \\rvert}{\\gcd(a,b)}$。对分子 $\\lvert a \\cdot b \\rvert$ 的朴素计算在 $a$ 和 $b$ 很大时可能会溢出。当 $\\lvert a \\rvert, \\lvert b \\rvert \\le 10^9$ 时，乘积可高达 $10^{18}$，如前所述，这可以容纳在64位整数中。然而，对于一个通用的库函数来说，最佳实践是避免这个中间乘积。由于 $\\gcd(a,b)$ 能同时整除 $a$ 和 $b$，可以在乘法之前执行除法。这能确保中间结果不会不必要地增大。计算LCM的安全方法是：\n    $$\\operatorname{lcm}(a,b) = \\left( \\frac{\\lvert a \\rvert}{\\gcd(a,b)} \\right) \\cdot \\lvert b \\rvert$$\n    除法 $\\lvert a \\rvert / \\gcd(a,b)$ 会得到一个精确的整数。随后的乘法得到最终的LCM，对于给定的约束，这个结果也能容纳在64位整数中。\n\n所提供的Python代码实现了这一逻辑。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases.\n    \"\"\"\n\n    def _compute_bezout_lcm(a, b):\n        \"\"\"\n        Computes the GCD, Bézout coefficients (x, y), and LCM for a pair of integers (a, b).\n        The result is a tuple (g, x, y, l) where:\n        - g = gcd(a, b) = 0\n        - ax + by = g\n        - l = lcm(a, b) = 0\n        \"\"\"\n        if a == 0 and b == 0:\n            return 0, 0, 0, 0\n\n        # Handle cases where one input is zero.\n        # gcd(a, 0) = |a|, lcm(a, 0) = 0.\n        # ax + 0y = |a| = x = |a|/a = sgn(a), y can be 0.\n        if b == 0:\n            g = abs(a)\n            x = 1 if a = 0 else -1\n            y = 0\n            lcm = 0\n            return g, x, y, lcm\n        \n        # gcd(0, b) = |b|, lcm(0, b) = 0.\n        # 0x + by = |b| = y = |b|/b = sgn(b), x can be 0.\n        if a == 0:\n            g = abs(b)\n            x = 0\n            y = 1 if b = 0 else -1\n            lcm = 0\n            return g, x, y, lcm\n\n        # General case (a!=0, b!=0)\n        # We run the extended Euclidean algorithm on |a| and |b|\n        # to ensure the gcd is non-negative and simplify the iteration.\n        sign_a = 1 if a  0 else -1\n        sign_b = 1 if b  0 else -1\n        abs_a = abs(a)\n        abs_b = abs(b)\n\n        # Extended Euclidean Algorithm\n        # Initializes such that old_r = old_s*abs_a + old_t*abs_b and r = s*abs_a + t*abs_b\n        s, old_s = 0, 1\n        t, old_t = 1, 0\n        r, old_r = abs_b, abs_a\n        \n        while r != 0:\n            quotient = old_r // r\n            old_r, r = r, old_r - quotient * r\n            old_s, s = s, old_s - quotient * s\n            old_t, t = t, old_t - quotient * t\n\n        # Result of algorithm on absolute values:\n        # g = gcd(|a|, |b|), x_abs = old_s, y_abs = old_t\n        # such that |a|*x_abs + |b|*y_abs = g\n        g = old_r\n        x_abs = old_s\n        y_abs = old_t\n\n        # Adjust coefficients for original signs of a and b.\n        # We want a*x + b*y = g.\n        # We have |a|*x_abs + |b|*y_abs = g.\n        # Substituting a = sgn(a)*|a| and b = sgn(b)*|b|:\n        # a/(sgn(a))*x_abs + b/(sgn(b))*y_abs = g\n        # a*(sgn(a)*x_abs) + b*(sgn(b)*y_abs) = g\n        # So x = sgn(a)*x_abs and y = sgn(b)*y_abs\n        x = x_abs * sign_a\n        y = y_abs * sign_b\n        \n        # Calculate LCM safely to avoid overflow\n        # lcm(a,b) = (|a| * |b|) / gcd(a,b)\n        # To avoid intermediate overflow, compute as (|a| / gcd) * |b|\n        lcm = (abs_a // g) * abs_b\n        \n        return g, x, y, lcm\n\n    test_cases = [\n        (12, 18),\n        (0, 0),\n        (0, 5),\n        (10**9, 1),\n        (-10**9, 10**9),\n        (832040, 514229),\n        (-24, -18),\n        (123456789, 987654321),\n        (0, -7),\n        (1, 10**9),\n        (7, -3),\n    ]\n\n    results = []\n    for a, b in test_cases:\n        g, x, y, l = _compute_bezout_lcm(a, b)\n        results.append(f\"[{g},{x},{y},{l}]\")\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3085685"}, {"introduction": "除了算法视角，我们还可以从整数的内在结构来理解最大公约数（GCD）和最小公倍数（LCM）。算术基本定理保证了每个整数都拥有唯一的素数分解“蓝图”。本练习将引导你使用 $p$-adic 赋值（$p$-adic valuation）这一概念，从素数分解的角度直接“读取”两个整数的GCD和LCM，并验证这些结构性定义与它们的数值结果相符。这个过程将深刻揭示整数的整除性质是如何通过其素因子的指数来体现的，并让你掌握公式 $v_{p}(\\gcd(a,b)) = \\min(v_{p}(a), v_{p}(b))$ 和 $v_{p}(\\operatorname{lcm}(a,b)) = \\max(v_{p}(a), v_{p}(b))$ 的应用。[@problem_id:3085692]", "problem": "设 $a$ 和 $b$ 为正整数，其唯一的素数分解由算术基本定理保证。对于一个固定的素数 $p$，正整数 $n$ 的 $p$-进赋值 $v_{p}(n)$ 是 $n$ 的素数分解中 $p$ 的指数。最大公约数 $\\gcd(a,b)$ 定义为能同时整除 $a$ 和 $b$ 的最大正整数，最小公倍数 $\\operatorname{lcm}(a,b)$ 定义为同时是 $a$ 和 $b$ 的倍数的最小正整数。考虑\n$$\na = 2^{5}\\,3^{2}, \\qquad b = 2^{3}\\,3^{7}.\n$$\n仅使用上述定义和素数分解的唯一性，确定 $v_{2}(\\gcd(a,b))$, $v_{3}(\\gcd(a,b))$, $v_{2}(\\operatorname{lcm}(a,b))$ 和 $v_{3}(\\operatorname{lcm}(a,b))$。然后，写下由您的赋值所蕴含的明确整数 $\\gcd(a,b)$ 和 $\\operatorname{lcm}(a,b)$，并从基本原理出发（即直接根据所述定义）验证您的值满足最大公约数和最小公倍数的定义性质。提供这四个赋值的最终数值结果以及 $\\gcd(a,b)$ 和 $\\operatorname{lcm}(a,b)$ 的数值。", "solution": "该问题已经过验证，是一个适定且初等数论中的标准练习。所有定义都是标准的，所有给定条件都是一致的。\n\n设 $a$ 和 $b$ 为正整数。问题给出了素数分解 $a = 2^{5} \\cdot 3^{2}$ 和 $b = 2^{3} \\cdot 3^{7}$。$p$-进赋值 $v_p(n)$ 定义为整数 $n$ 的素数分解中素数 $p$ 的指数。\n\n首先，我们确定最大公约数 $\\gcd(a,b)$ 的 $p$-进赋值。设 $d = \\gcd(a,b)$。根据定义，$d$ 必须同时整除 $a$ 和 $b$。整数 $x$ 整除整数 $y$（记作 $x|y$）的条件等价于对于每一个素数 $p$，$x$ 的 $p$-进赋值小于或等于 $y$ 的 $p$-进赋值。形式上，$x|y \\iff$ 对所有素数 $p$ 都有 $v_p(x) \\le v_p(y)$。\n为了使 $d$ 成为 $a$ 和 $b$ 的公约数，我们必须有 $d|a$ 和 $d|b$。这意味着：\n对所有素数 $p$，$v_p(d) \\le v_p(a)$。\n对所有素数 $p$，$v_p(d) \\le v_p(b)$。\n结合这两个条件，我们得到对所有素数 $p$，$v_p(d) \\le \\min(v_p(a), v_p(b))$。\n因为 $\\gcd(a,b)$ 是*最大*公约数，其值必须最大化。这可以通过最大化其每个 $p$-进赋值来实现。因此，我们必须选择等式成立：\n$$v_p(\\gcd(a,b)) = \\min(v_p(a), v_p(b))$$\n根据给定的分解，我们有 $v_2(a)=5$，$v_3(a)=2$，且对于 $p \\notin \\{2, 3\\}$ 有 $v_p(a)=0$。类似地，$v_2(b)=3$，$v_3(b)=7$，且对于 $p \\notin \\{2, 3\\}$ 有 $v_p(b)=0$。\n应用 $\\gcd$ 赋值的公式：\n$v_{2}(\\gcd(a,b)) = \\min(v_2(a), v_2(b)) = \\min(5, 3) = 3$。\n$v_{3}(\\gcd(a,b)) = \\min(v_3(a), v_3(b)) = \\min(2, 7) = 2$。\n对于不等于 $2$ 或 $3$ 的任何素数 $p$，$v_p(\\gcd(a,b)) = \\min(0, 0) = 0$。\n\n接下来，我们确定最小公倍数 $\\operatorname{lcm}(a,b)$ 的 $p$-进赋值。设 $m = \\operatorname{lcm}(a,b)$。根据定义，$m$ 必须是 $a$ 和 $b$ 的公倍数。这意味着 $a|m$ 和 $b|m$。用 $p$-进赋值表示：\n对所有素数 $p$，$v_p(a) \\le v_p(m)$。\n对所有素数 $p$，$v_p(b) \\le v_p(m)$。\n结合这两个条件，我们得到对所有素数 $p$，$v_p(m) \\ge \\max(v_p(a), v_p(b))$。\n因为 $\\operatorname{lcm}(a,b)$ 是*最小*正公倍数，其值必须最小化。这可以通过最小化其每个 $p$-进赋值来实现。因此，我们必须选择等式成立：\n$$v_p(\\operatorname{lcm}(a,b)) = \\max(v_p(a), v_p(b))$$\n应用此公式和给定的赋值：\n$v_{2}(\\operatorname{lcm}(a,b)) = \\max(v_2(a), v_2(b)) = \\max(5, 3) = 5$。\n$v_{3}(\\operatorname{lcm}(a,b)) = \\max(v_3(a), v_3(b)) = \\max(2, 7) = 7$。\n对于不等于 $2$ 或 $3$ 的任何素数 $p$，$v_p(\\operatorname{lcm}(a,b)) = \\max(0, 0) = 0$。\n\n使用这些赋值，我们可以构造整数 $\\gcd(a,b)$ 和 $\\operatorname{lcm}(a,b)$：\n$\\gcd(a,b) = 2^{v_{2}(\\gcd(a,b))} \\cdot 3^{v_{3}(\\gcd(a,b))} = 2^3 \\cdot 3^2 = 8 \\cdot 9 = 72$。\n$\\operatorname{lcm}(a,b) = 2^{v_{2}(\\operatorname{lcm}(a,b))} \\cdot 3^{v_{3}(\\operatorname{lcm}(a,b))} = 2^5 \\cdot 3^7 = 32 \\cdot 2187 = 69984$。\n\n问题要求从基本原理进行验证。\n**验证 $\\gcd(a,b) = 72$**：\n设 $d = 72$。首先，我们确认 $d$ 是一个公约数。\n$\\frac{a}{d} = \\frac{2^5 \\cdot 3^2}{2^3 \\cdot 3^2} = 2^{2} = 4$，这是一个整数。因此，$72|a$。\n$\\frac{b}{d} = \\frac{2^3 \\cdot 3^7}{2^3 \\cdot 3^2} = 3^{5} = 243$，这是一个整数。因此，$72|b$。\n所以，$72$ 是一个公约数。\n接下来，我们证明它是最大的。设 $c$ 是 $a$ 和 $b$ 的任意正公约数。由于 $c|a$ 和 $c|b$， $c$ 的素因子只能是 $2$ 和 $3$。设 $c=2^x 3^y$。\n$c | a \\implies v_2(c) \\le v_2(a) \\text{ 且 } v_3(c) \\le v_3(a) \\implies x \\le 5 \\text{ 且 } y \\le 2$。\n$c | b \\implies v_2(c) \\le v_2(b) \\text{ 且 } v_3(c) \\le v_3(b) \\implies x \\le 3 \\text{ 且 } y \\le 7$。\n为了使 $c$ 成为公约数，其指数必须同时满足两个条件。因此，$x \\le \\min(5,3) = 3$ 且 $y \\le \\min(2,7) = 2$。\n满足这些约束的最大整数 $c$ 是 $2^3 \\cdot 3^2 = 72$。因此，任何公约数 $c$ 都小于或等于 $72$，这证明了 $72$ 是最大公约数。\n\n**验证 $\\operatorname{lcm}(a,b) = 69984$**：\n设 $m=69984$。首先，我们确认 $m$ 是一个公倍数。\n$\\frac{m}{a} = \\frac{2^5 \\cdot 3^7}{2^5 \\cdot 3^2} = 3^5 = 243$，这是一个整数。因此，$a|m$。\n$\\frac{m}{b} = \\frac{2^5 \\cdot 3^7}{2^3 \\cdot 3^7} = 2^2 = 4$，这是一个整数。因此，$b|m$。\n所以，$69984$ 是一个公倍数。\n接下来，我们证明它是最小的。设 $k$ 是 $a$ 和 $b$ 的任意正公倍数。设 $k$ 的素数分解为 $k = 2^x 3^y \\dots$。\n$a | k \\implies v_2(a) \\le v_2(k) \\text{ 且 } v_3(a) \\le v_3(k) \\implies 5 \\le x \\text{ 且 } 2 \\le y$。\n$b | k \\implies v_2(b) \\le v_2(k) \\text{ 且 } v_3(b) \\le v_3(k) \\implies 3 \\le x \\text{ 且 } 7 \\le y$。\n为了使 $k$ 成为公倍数，其指数必须同时满足两个条件。因此，$x \\ge \\max(5,3) = 5$ 且 $y \\ge \\max(2,7) = 7$。\n要构成最小的正整数 $k$，我们必须选择最小可能的指数，即 $x=5$ 和 $y=7$，并且没有其他素因子。\n这给出的整数是 $2^5 \\cdot 3^7 = 69984$。因此，任何正公倍数 $k$ 都大于或等于 $69984$，这证明了 $69984$ 是最小公倍数。\n\n最终的数值结果是：\n$v_{2}(\\gcd(a,b)) = 3$\n$v_{3}(\\gcd(a,b)) = 2$\n$v_{2}(\\operatorname{lcm}(a,b)) = 5$\n$v_{3}(\\operatorname{lcm}(a,b)) = 7$\n$\\gcd(a,b) = 72$\n$\\operatorname{lcm}(a,b) = 69984$", "answer": "$$\n\\boxed{\\begin{pmatrix} 3  2  5  7  72  69984 \\end{pmatrix}}\n$$", "id": "3085692"}]}