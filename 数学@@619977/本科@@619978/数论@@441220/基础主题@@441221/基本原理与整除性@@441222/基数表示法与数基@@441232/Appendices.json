{"hands_on_practices": [{"introduction": "我们都熟悉像 $1/3=0.333...$ 这样的循环小数，但这些循环节的长度背后隐藏着深刻的数论原理。本练习将引导你使用模运算来预测有理数在任意进制下循环节的长度，而无需执行冗长的除法。通过这个过程，你将发现除法算法与群论中“阶”的概念之间美妙的联系。[@problem_id:3089118]", "problem": "一个在 $b$ 进制下的有理数 $a/n$，其中 $\\gcd(b,n)=1$，其循环小数展开源于 $b$ 进制的长除法过程。该过程会产生一个模 $n$ 的有限余数序列，并且最终必然会循环。仅使用除法算法和模算术，解释为什么当 $a$ 和 $n$ 互质时，$a/n$ 的循环节长度等于满足 $b^{k} \\equiv 1 \\pmod{n}$ 的最小正整数 $k$。然后，将此推理应用于10进制和单位分数 $1/37$，通过计算10模37的乘法阶来确定其10进制展开的循环周期。最后，通过显式地对 $1/37$ 进行10进制长除法来验证你的计算，并展示其循环节。将循环周期长度以整数形式写出。无需四舍五入。", "solution": "该问题是有效的，因为它在数论中有科学依据，问题明确且客观。我们将分三部分进行：首先，对有理数基数展开的循环节长度进行一般性解释；其次，将该理论应用于10进制下的分数 $1/37$；第三，通过长除法验证结果。\n\n第一部分：循环节长度的解释\n\n设有理数为 $\\frac{a}{n}$，其中 $a, n$ 为正整数，且不失一般性，通过减去整数部分，我们可以假设 $1 \\le a  n$。问题指定了两个条件：$\\gcd(b, n) = 1$ 和 $\\gcd(a, n) = 1$。我们想要求出 $b$ 进制展开的数字 $d_1, d_2, d_3, \\dots$，其展开式为\n$$ \\frac{a}{n} = \\sum_{i=1}^{\\infty} d_i b^{-i} = 0.d_1 d_2 d_3 \\dots_b $$\n数字 $d_i$ 是满足 $0 \\le d_i  b$ 的整数。\n\n长除法算法提供了求这些数字的步骤。\n为求第一个数字 $d_1$，我们将 $\\frac{a}{n}$ 乘以 $b$：\n$$ \\frac{ab}{n} = d_1 + \\sum_{i=2}^{\\infty} d_i b^{-(i-1)} $$\n该表达式的整数部分是 $d_1$，所以 $d_1 = \\lfloor \\frac{ab}{n} \\rfloor$。根据除法算法，我们可以写出 $ab = d_1 n + r_1$，其中 $r_1$ 是余数，满足 $0 \\le r_1  n$。数字序列是由余数序列生成的。\n\n算法的下一步是对小数部分 $\\frac{r_1}{n}$ 进行操作。我们再次乘以 $b$：\n$$ \\frac{r_1 b}{n} = d_2 + \\frac{r_2}{n} $$\n这里，$d_2 = \\lfloor \\frac{r_1 b}{n} \\rfloor$，且除法算法给出 $r_1 b = d_2 n + r_2$，其中 $0 \\le r_2  n$。\n\n我们可以推广这个过程。令 $r_0 = a$。算法的第 $(i+1)$ 步由以下递归关系给出：\n$$ r_i b = d_{i+1} n + r_{i+1}, \\quad \\text{for } i \\ge 0 $$\n其中 $d_{i+1} = \\lfloor \\frac{r_i b}{n} \\rfloor$ 是第 $(i+1)$ 位数字，$r_{i+1}$ 是第 $(i+1)$ 个余数，满足 $0 \\le r_{i+1}  n$。\n\n从递归关系中，我们可以用模算术来表示余数：\n$$ r_{i+1} \\equiv r_i b \\pmod{n} $$\n从 $r_1 \\equiv r_0 b \\pmod{n} \\equiv ab \\pmod{n}$ 开始，重复应用此关系，我们得到：\n$$ r_i \\equiv r_{i-1}b \\equiv r_{i-2}b^2 \\equiv \\dots \\equiv r_0 b^i \\pmod{n} $$\n因此，对于任何 $i \\ge 1$，第 $i$ 个余数由 $r_i \\equiv ab^i \\pmod{n}$ 给出。\n\n数字序列 $d_1, d_2, \\dots$ 重复，当且仅当余数序列 $r_1, r_2, \\dots$ 重复。由于每个余数 $r_i$ 必须属于有限集合 $\\{0, 1, \\dots, n-1\\}$，该序列最终必然会重复。在给定 $\\gcd(b, n)=1$ 和 $\\gcd(a, n)=1$ 的条件下，可以证明 $r_i$ 永远不会是 $0$，因此展开式是不终止的。\n\n设展开式的周期为 $k$。这意味着余数序列是周期性的。为了使展开式是纯循环的（没有不循环部分），余数序列 $r_1, r_2, \\dots$ 必须立即开始其循环。这要求第一个重复的余数是 $r_1$。然而，展开的周期由余数序列的第一次重复决定。设 $r_k = r_j$ 是第一次重复，其中 $0 \\le j  k$。从 $r_i \\equiv r_{i-1}b \\pmod n$ 可得 $r_{j-1}b \\equiv r_j \\pmod n$ 和 $r_{k-1}b \\equiv r_k \\pmod n$。因为 $r_j=r_k$，我们推断出 $r_{j-1}b \\equiv r_{k-1}b \\pmod n$。由于 $\\gcd(b,n)=1$，$b$ 在模 $n$ 意义下是可逆的，所以我们可以乘以 $b^{-1}$ 得到 $r_{j-1} \\equiv r_{k-1} \\pmod n$。因为两者都是小于 $n$ 的有效余数，我们有 $r_{j-1}=r_{k-1}$。这个反向归纳可以重复 $j$ 次，得到 $r_0 = r_{k-j}$。这表明第一个被重复的余数确实是 $r_0=a$。\n\n因此，循环节的长度 $k$ 是使 $r_k = r_0 = a$ 成立的最小正整数。\n使用我们对余数的模算术表达式 $r_k \\equiv ab^k \\pmod{n}$，条件 $r_k = a$ 变为：\n$$ ab^k \\equiv a \\pmod{n} $$\n问题陈述了 $a$ 和 $n$ 互质，即 $\\gcd(a,n)=1$。这意味着 $a$ 在模 $n$ 意义下有乘法逆元。将同余式两边乘以 $a^{-1}$，我们得到：\n$$ b^k \\equiv 1 \\pmod{n} $$\n循环节的长度是使此同余式成立的最小正整数 $k$。根据定义，这个 $k$ 就是 $b$ 模 $n$ 的乘法阶。\n\n第二部分：应用于10进制下的 $\\frac{1}{37}$\n\n我们被要求找出 $\\frac{1}{37}$ 的10进制展开的循环周期长度。\n这里，$a=1$，$n=37$，$b=10$。我们验证条件：\n1. $\\gcd(a,n) = \\gcd(1,37) = 1$。\n2. $\\gcd(b,n) = \\gcd(10,37) = 1$，因为 $37$ 是一个素数且不能整除 $10$。\n\n条件均满足。根据上述推理，循环周期的长度是10模37的乘法阶。我们寻求满足 $10^k \\equiv 1 \\pmod{37}$ 的最小正整数 $k$。\n\n根据费马小定理 (Fermat's Little Theorem)，由于 $37$ 是素数，我们知道 $10^{36} \\equiv 1 \\pmod{37}$。因此，阶 $k$ 必须是 $36$ 的一个因子。$36$ 的因子有 $1, 2, 3, 4, 6, 9, 12, 18, 36$。我们首先测试最小的因子：\n- 对于 $k=1$：$10^1 = 10 \\not\\equiv 1 \\pmod{37}$。\n- 对于 $k=2$：$10^2 = 100$。因为 $100 = 2 \\times 37 + 26$，我们有 $10^2 \\equiv 26 \\pmod{37}$。这不等于 $1$。\n- 对于 $k=3$：$10^3 = 10^2 \\times 10 \\equiv 26 \\times 10 = 260 \\pmod{37}$。为了计算 $260 \\pmod{37}$，我们做除法：$260 = 7 \\times 37 + 1$。因此，$10^3 \\equiv 1 \\pmod{37}$。\n\n满足 $10^k \\equiv 1 \\pmod{37}$ 的最小正整数 $k$ 是 $3$。因此，$\\frac{1}{37}$ 的10进制展开的循环周期长度是 $3$。\n\n第三部分：通过长除法验证\n\n我们现在对 $\\frac{1}{37}$ 进行长除法，以明确求出其10进制展开式。\n令 $r_0 = a = 1$。\n1.  为求第一个数字 $d_1$，我们计算 $r_0 \\times 10 = 1 \\times 10 = 10$。除以 $37$ 得到 $10 = 0 \\times 37 + 10$。所以，$d_1 = 0$，余数是 $r_1=10$。\n2.  为求 $d_2$，我们计算 $r_1 \\times 10 = 10 \\times 10 = 100$。除以 $37$ 得到 $100 = 2 \\times 37 + 26$。所以，$d_2 = 2$，余数是 $r_2=26$。\n3.  为求 $d_3$，我们计算 $r_2 \\times 10 = 26 \\times 10 = 260$。除以 $37$ 得到 $260 = 7 \\times 37 + 1$。所以，$d_3 = 7$，余数是 $r_3=1$。\n4.  此时，余数是 $r_3=1$，等于我们的初始余数 $r_0=1$。余数序列 $(10, 26, 1)$ 完成了一个循环。下一次迭代将使用 $r_3=1$ 并产生与第一步相同的数字和余数（$d_4 = 0, r_4 = 10$），依此类推。\n\n生成的数字序列是 $d_1, d_2, d_3 = 0, 2, 7$。这个数字块将会重复。\n展开式为：\n$$ \\frac{1}{37} = 0.027027027\\dots = 0.\\overline{027} $$\n循环节是 `027`，其长度确实是 $3$。这验证了从模算术得到的结果。循环周期长度是 $3$。", "answer": "$$\\boxed{3}$$", "id": "3089118"}, {"introduction": "从纯粹的数学世界过渡到计算机的实际应用，数值的表示方式会受到硬件的限制。本练习模拟了一个数字信号处理器（DSP）如何使用非标准的定点格式来存储和处理数值。通过将一个十进制数转换为三进制定点数，你将亲手计算并理解“表示误差”这一核心概念，它是在所有科学计算和工程应用中都必须面对的关键问题。[@problem_id:1914509]", "problem": "正在设计一款专用的数字信号处理器（DSP），用于处理宇宙学模拟中的计算。为了优化某些张量计算，该 DSP 采用了一种不常见的基于三进制（ternary）的无符号定点数系统。数字存储在一个 8-trit 的字中，其中每个 trit 的值可以是 0、1 或 2。\n\n该 8-trit 格式定义为 $I_4 I_3 I_2 I_1 . F_1 F_2 F_3 F_4$，其中四个最高有效三进制位（$I_4$ 到 $I_1$）表示数字的整数部分，四个最低有效三进制位（$F_1$ 到 $F_4$）表示小数部分。小数点固定在 $I_1$ 和 $F_1$ 之间。\n\n模拟的一个初始条件要求将十进制值 $V = 37.58_{10}$ 表示为这种 8-trit 的三进制格式。由于该格式的小数部分三进制位数有限，转换过程中任何超过 $F_4$ 的三进制位都将被截断（即丢弃）。这会引入表示误差。\n\n计算原始十进制值 $V$ 与截断后实际存储在 8-trit DSP 寄存器中的值之间的绝对误差。将您的答案表示为十进制数。将最终答案四舍五入到五位有效数字。", "solution": "我们有一个无符号定点三进制格式，包含 4 个整数三进制位和 4 个小数三进制位：$I_{4}I_{3}I_{2}I_{1}.F_{1}F_{2}F_{3}F_{4}$。小数点固定在 $I_{1}$ 和 $F_{1}$ 之间。整数部分有 4 个三进制位，所以其最大值为 $2222_{3}=2\\cdot 3^{3}+2\\cdot 3^{2}+2\\cdot 3^{1}+2\\cdot 3^{0}=80$，这足以表示 $V=37.58$ 的整数部分。\n\n首先，将整数部分 $37$ 转换为三进制。使用 $3$ 的幂：\n$$3^{3}=27,\\quad 3^{2}=9,\\quad 3^{1}=3,\\quad 3^{0}=1.$$\n我们将 $37$ 写为 $37=1\\cdot 27+1\\cdot 9+0\\cdot 3+1\\cdot 1$，因此\n$$37_{10}=1101_{3}.$$\n因此，整数三进制位恰好是 $I_{4}I_{3}I_{2}I_{1}=1101$，没有整数误差。\n\n接下来，使用标准方法将小数部分 $x_{0}=0.58=\\frac{29}{50}$ 转换为三进制小数位：在每一步中，计算 $3x_{k}$，取 $F_{k+1}=\\lfloor 3x_{k}\\rfloor$，并设置 $x_{k+1}=3x_{k}-F_{k+1}$。使用分数进行精确计算：\n$$3x_{0}=\\frac{87}{50}=1+\\frac{37}{50}\\;\\Rightarrow\\;F_{1}=1,\\;x_{1}=\\frac{37}{50},$$\n$$3x_{1}=\\frac{111}{50}=2+\\frac{11}{50}\\;\\Rightarrow\\;F_{2}=2,\\;x_{2}=\\frac{11}{50},$$\n$$3x_{2}=\\frac{33}{50}=0+\\frac{33}{50}\\;\\Rightarrow\\;F_{3}=0,\\;x_{3}=\\frac{33}{50},$$\n$$3x_{3}=\\frac{99}{50}=1+\\frac{49}{50}\\;\\Rightarrow\\;F_{4}=1,\\;x_{4}=\\frac{49}{50}.$$\n\n因此，存储的 8-trit 值为 $1101.1201_{3}$，因为超过 $F_{4}$ 的数字被截断了。\n\n为了将精确的小数值与存储值联系起来，我们迭代恒等式 $3x_{k}=F_{k+1}+x_{k+1}$ 以得到\n$$x_{0}=F_{1}3^{-1}+x_{1}3^{-1}=F_{1}3^{-1}+F_{2}3^{-2}+x_{2}3^{-2}$$\n$$=F_{1}3^{-1}+F_{2}3^{-2}+F_{3}3^{-3}+x_{3}3^{-3}$$\n$$=F_{1}3^{-1}+F_{2}3^{-2}+F_{3}3^{-3}+F_{4}3^{-4}+x_{4}3^{-4}.$$\n因此，小数部分的截断误差等于尾数\n$$\\varepsilon_{\\text{frac}}=x_{4}3^{-4}=\\frac{49}{50}\\cdot \\frac{1}{3^{4}}=\\frac{49}{4050}.$$\n由于整数部分是精确的，因此 $V$ 与存储值之间的绝对误差恰好是\n$$|\\text{error}|=\\frac{49}{4050}.$$\n作为十进制数，这个值是\n$$\\frac{49}{4050}=0.012098765\\ldots,$$\n四舍五入到五位有效数字后为 $0.012099$。", "answer": "$$\\boxed{0.012099}$$", "id": "1914509"}, {"introduction": "传统的数字系统依赖于正数基底和一个额外的符号位来表示负数，但这是唯一的方法吗？本练习将挑战你的直觉，探索使用负数（如 $-2$）作为基底的可能性。你将惊奇地发现，负基底系统能够统一地表示所有整数，而无需符号位，这迫使我们通过打破常规来更深刻地理解位置记数法的本质。[@problem_id:3089124]", "problem": "设 $b$ 是一个满足 $|b| \\geq 2$ 的整数。整数 $n$ 以 $b$ 为底的位置基数表示法是形如 $n = \\sum_{k=0}^{m} d_{k} b^{k}$ 的表达式，其中数位 $d_{k}$ 来自一个固定的有限数位集。在标准的十进制中，使用数位 $\\{0,1,\\dots,9\\}$，负数则通过一个外部的符号位或减号来表示。相比之下，对于负二进制（以 $-2$ 为底），可以尝试使用数位集 $\\{0,1\\}$ 而无需任何外部符号位。\n\n仅使用整数环 $\\mathbb{Z}$ 中的除法算法和位置表示法的基本定义，从第一性原理出发，推导出每个整数 $n \\in \\mathbb{Z}$ 都允许一个形如 $n = \\sum_{k=0}^{m} d_{k} (-2)^{k}$ 且 $d_{k} \\in \\{0,1\\}$ 的负二进制表示，并证明该表示是唯一的。解释为什么这意味着负二进制中没有独立的符号位；也就是说，同样的数位集 $\\{0,1\\}$ 足以表示正整数和负整数。\n\n然后，通过推导其数位 $d_{k} \\in \\{0,1\\}$，显式计算整数 $n = 137$ 的负二进制展开式。\n\n接下来，使用适用于负二进制的标准列式加法和长乘法，在负二进制下执行并验证以下运算：\n- 计算 $A = 10101_{(-2)} + 1101_{(-2)}$ 并通过直接求值来确认其十进制值。\n- 计算 $B = 1011_{(-2)} \\cdot 1001_{(-2)}$ 并通过直接求值来确认其十进制值。\n\n最后，令 $E$ 表示为 $137$ 找到的负二进制数。定义 $\\mathrm{val}_{10}$ 为求值映射，它将一个负二进制数 $\\sum_{k=0}^{m} d_{k} (-2)^{k}$ 映射到其对应的十进制整数 $\\sum_{k=0}^{m} d_{k} (-2)^{k}$。计算单一数值\n$$\nS \\;=\\; \\mathrm{val}_{10}(A) \\;+\\; 2\\,\\mathrm{val}_{10}(B) \\;+\\; \\mathrm{val}_{10}(E).\n$$\n将最终答案 $S$ 表示为一个精确的十进制整数（无需舍入）。", "solution": "对问题陈述进行验证。\n\n### 步骤1：提取已知条件\n- 设 $b$ 是一个满足 $|b| \\geq 2$ 的整数。\n- 整数 $n$ 以 $b$ 为底的位置基数表示法为 $n = \\sum_{k=0}^{m} d_{k} b^{k}$。\n- 对于底 $b = -2$，数位集为 $\\{0,1\\}$。\n- 任务1：从第一性原理（$\\mathbb{Z}$中的除法算法）出发，推导每个整数 $n \\in \\mathbb{Z}$ 都有一个唯一的、数位 $d_{k} \\in \\{0,1\\}$ 的负二进制表示。\n- 任务2：解释为什么这意味着不需要独立的符号位。\n- 任务3：计算整数 $n=137$ 的负二进制展开式，记为 $E$。\n- 任务4：计算 $A = 10101_{(-2)} + 1101_{(-2)}$ 并验证其十进制值。\n- 任务5：计算 $B = 1011_{(-2)} \\cdot 1001_{(-2)}$ 并验证其十进制值。\n- 任务6：计算单一数值 $S = \\mathrm{val}_{10}(A) + 2\\,\\mathrm{val}_{10}(B) + \\mathrm{val}_{10}(E)$。\n\n### 步骤2：使用提取的已知条件进行验证\n该问题是数论中的一个标准练习，特别关注非标准的位置数字系统（负基数）。\n- **科学依据**：负二进制表示（以 $-2$ 为底）的概念是数学和计算机科学中一个完善的主题。除法算法是数论中的一个基本定理。所有原理都是合理的。\n- **适定性**：问题定义清晰。各项任务——一个证明、一个解释和几个显式计算——都是明确的，并导向一个唯一的、可验证的解。\n- **客观性**：语言正式且精确。没有主观或基于观点的陈述。\n\n该问题没有表现出验证标准中列出的任何缺陷。它是一个有效的、自洽的数学问题。\n\n### 步骤3：结论与行动\n问题有效。将提供完整的解答。\n\n### 解题推导\n\n**第1部分：负二进制表示的存在性与唯一性**\n\n我们必须证明，对于任何整数 $n \\in \\mathbb{Z}$，存在唯一的数位序列 $(d_k)_{k=0}^m$（其中 $d_k \\in \\{0, 1\\}$），使得 $n = \\sum_{k=0}^{m} d_{k} (-2)^{k}$。\n\n**存在性：**\n证明是构造性的，基于欧几里得除法算法。除法算法指出，对于任何整数 $a$ 和 $c$（其中 $c \\neq 0$），存在唯一的整数 $q$ 和 $r$，使得 $a = qc + r$ 且 $0 \\leq r  |c|$。\n让我们将此应用于我们的底 $b=-2$。对于任何整数 $n_k$，我们可以写成：\n$n_k = q (-2) + r$，其中余数 $r$ 满足 $0 \\leq r  |-2|=2$。因此，$r$ 必须在集合 $\\{0, 1\\}$ 中，这正是我们所期望的数位集。\n设 $n_0 = n$。我们如下生成一个商 $n_k$ 和余数 $d_k$ 的序列：\n$n_0 = n_{1}(-2) + d_0$\n$n_1 = n_{2}(-2) + d_1$\n...\n$n_k = n_{k+1}(-2) + d_k$\n...\n其中每一步都有 $d_k \\in \\{0, 1\\}$。从此递推关系中，我们可以写出 $n_{k+1} = (d_k - n_k)/2$。\n\n为了表明这个过程会产生一个有限的展开式，我们必须证明商序列 $n_k$ 最终会达到 $0$。让我们分析商的绝对值。\n- 如果 $|n_k| > 1$，那么 $|n_{k+1}| = |(d_k - n_k)/2| \\leq (|d_k| + |n_k|)/2 \\leq (1 + |n_k|)/2$。因为 $|n_k| > 1$，我们有 $1  |n_k|$，这意味着 $1 + |n_k|  2|n_k|$，所以 $(1 + |n_k|)/2  |n_k|$。因此，对于 $|n_k| > 1$，绝对值 $|n_{k+1}|$ 严格小于 $|n_k|$。\n- 绝对值可能不严格减小的唯一情况是 $|n_k| \\leq 1$，即 $n_k \\in \\{-1, 0, 1\\}$。\n  - 如果 $n_k = 0$，过程终止 ($d_k=0, n_{k+1}=0$）。\n  - 如果 $n_k = 1$，那么 $1 = 0 \\cdot (-2) + 1$。所以 $d_k=1$ 且 $n_{k+1}=0$。过程终止。\n  - 如果 $n_k = -1$，那么 $-1 = 1 \\cdot (-2) + 1$。所以 $d_k=1$ 且 $n_{k+1}=1$。下一步将是 $n_{k+1}=1$，我们刚才已经证明这种情况会导致终止。\n由于非零商的绝对值严格递减直到达到 $1$，商序列最终必然变为 $0$。这保证了对于任何整数 $n$，该过程都会终止，从而确立了有限负二进制展开式的存在性。\n\n**唯一性：**\n假设一个整数 $n$ 有两种不同的负二进制表示：\n$n = \\sum_{k=0}^{m} d_k (-2)^k = \\sum_{k=0}^{m} c_k (-2)^k$，其中 $d_k, c_k \\in \\{0, 1\\}$。我们可以通过添加前导零来假设长度 $m$ 是相同的。\n设 $j$ 是使 $d_j \\neq c_j$ 成立的最小索引。那么\n$\\sum_{k=j}^{m} d_k (-2)^k = \\sum_{k=j}^{m} c_k (-2)^k$。\n$(d_j - c_j)(-2)^j + \\sum_{k=j+1}^{m} (d_k - c_k)(-2)^k = 0$。\n两边除以 $(-2)^j$，我们得到：\n$d_j - c_j = -\\sum_{k=j+1}^{m} (d_k - c_k)(-2)^{k-j} = -(-2)\\sum_{k=j+1}^{m} (d_k - c_k)(-2)^{k-j-1}$。\n右边是 $2$ 的整数倍，所以它是一个偶数。\n左边 $d_j - c_j$ 的值只能在 $\\{-1, 0, 1\\}$ 中取，因为 $d_j, c_j \\in \\{0, 1\\}$。根据我们的假设，$d_j \\neq c_j$，所以 $d_j - c_j$ 必须是 $1$ 或 $-1$。\n一个奇数（$1$ 或 $-1$）不能等于一个偶数。这是一个矛盾。因此，我们最初的假设必定是错误的，不可能存在任何索引 $j$ 使得数位不同。因此，对于所有的 $k$，都有 $d_k = c_k$，表示是唯一的。\n\n**第2部分：无符号位**\n上面提供的存在性的构造性证明适用于任何整数 $n \\in \\mathbb{Z}$，无论是正数、负数还是零。算法 $n_{k+1}=(d_k-n_k)/2$（其中 $d_k=n_k \\pmod 2$，余数在 $\\{0,1\\}$ 中）对任何起始整数都能生成一个有效的、唯一的数位序列 $\\{0,1\\}$。这与标准的正基数（如十进制或二进制）形成对比，在那些系统中，标准的除法算法只为非负整数生成表示，需要一个外部符号（减号 '–'）来表示负数。在负二进制中，符号被隐式地编码在数位序列本身之中。\n\n**第3部分：$n=137$ 的负二进制展开式**\n我们应用算法 $n_{k+1} = (d_k - n_k)/2$，其中 $d_k$ 是 $n_k$ 除以 $-2$ 的余数（在 $\\{0,1\\}$ 中）。\n$n_0 = 137$: $137 = (-68) \\cdot (-2) + 1 \\implies d_0=1, n_1=-68$。\n$n_1 = -68$: $-68 = 34 \\cdot (-2) + 0 \\implies d_1=0, n_2=34$。\n$n_2 = 34$: $34 = (-17) \\cdot (-2) + 0 \\implies d_2=0, n_3=-17$。\n$n_3 = -17$: $-17 = 9 \\cdot (-2) + 1 \\implies d_3=1, n_4=9$。\n$n_4 = 9$: $9 = (-4) \\cdot (-2) + 1 \\implies d_4=1, n_5=-4$。\n$n_5 = -4$: $-4 = 2 \\cdot (-2) + 0 \\implies d_5=0, n_6=2$。\n$n_6 = 2$: $2 = (-1) \\cdot (-2) + 0 \\implies d_6=0, n_7=-1$。\n$n_7 = -1$: $-1 = 1 \\cdot (-2) + 1 \\implies d_7=1, n_8=1$。\n$n_8 = 1$: $1 = 0 \\cdot (-2) + 1 \\implies d_8=1, n_9=0$。\n过程终止。表示由数位从后到前构成：$(d_8 d_7 d_6 d_5 d_4 d_3 d_2 d_1 d_0)_{-2}$。\n因此，$137_{10} = 110011001_{(-2)}$。\n数 $E$ 是 $110011001_{(-2)}$，所以 $\\mathrm{val}_{10}(E) = 137$。\n\n**第4部分：负二进制算术**\n对于列式算术，我们需要处理进位的规则。如果一列的和是 $S$，我们写作 $S = d_{out} + (-2)c_{out}$，其中 $d_{out}$ 是该列的数位，$c_{out}$ 是到下一列的进位。\n- $S=0: 0 = 0 + (-2) \\cdot 0 \\implies d_{out}=0, c_{out}=0$。\n- $S=1: 1 = 1 + (-2) \\cdot 0 \\implies d_{out}=1, c_{out}=0$。\n- $S=2: 2 = 0 + (-2) \\cdot (-1) \\implies d_{out}=0, c_{out}=-1$。\n- $S=-1: -1 = 1 + (-2) \\cdot 1 \\implies d_{out}=1, c_{out}=1$。\n- $S=3: 3 = 1 + (-2) \\cdot (-1) \\implies d_{out}=1, c_{out}=-1$。\n\n**加法: $A = 10101_{(-2)} + 1101_{(-2)}$**\n我们将数字对齐，并从右到左（索引 $k=0$）逐列相加。\n```\n  进位：    1  -1   1  -1\n             1  0  1  0  1\n           +   0  1  1  0  1\n--------------------------\n           1  0  1  1  0\n```\n- $k=0$: $1+1 = 2 \\implies$ 和为 $0$，进位为 $-1$。\n- $k=1$: $0+0+(-1) = -1 \\implies$ 和为 $1$，进位为 $1$。\n- $k=2$: $1+1+1 = 3 \\implies$ 和为 $1$，进位为 $-1$。\n- $k=3$: $0+1+(-1) = 0 \\implies$ 和为 $0$，进位为 $0$。\n- $k=4$: $1+0+0 = 1 \\implies$ 和为 $1$，进位为 $0$。\n因此，$A = 10110_{(-2)}$。\n\n验证：\n$\\mathrm{val}_{10}(10101_{(-2)}) = 1(-2)^4 + 0(-2)^3 + 1(-2)^2 + 0(-2)^1 + 1(-2)^0 = 16 + 4 + 1 = 21$。\n$\\mathrm{val}_{10}(1101_{(-2)}) = 1(-2)^3 + 1(-2)^2 + 0(-2)^1 + 1(-2)^0 = -8 + 4 + 1 = -3$。\n和为 $21 + (-3) = 18$。\n结果为 $\\mathrm{val}_{10}(10110_{(-2)}) = 1(-2)^4 + 0(-2)^3 + 1(-2)^2 + 1(-2)^1 + 0(-2)^0 = 16 + 4 - 2 = 18$。\n计算正确。$\\mathrm{val}_{10}(A) = 18$。\n\n**乘法: $B = 1011_{(-2)} \\cdot 1001_{(-2)}$**\n我们使用长乘法。\n```\n          1  0  1  1\n        x 1  0  0  1\n-----------------\n          1  0  1  1   (1011 * 1)\n        0  0  0  0     (1011 * 0, 移位)\n      0  0  0  0       (1011 * 0, 移位)\n+   1  0  1  1         (1011 * 1, 移位)\n-----------------\n```\n现在我们对部分积求和：$1011000_{(-2)} + 1011_{(-2)}$。\n```\n  进位：     -1  0  0  -1\n             1  0  1  1  0  0  0\n           +      0  0  1  0  1  1\n--------------------------------\n           1  0  0  0  0  1  1\n```\n- $k=0: 0+1=1 \\implies$ 和为 $1$，进位为 $0$。\n- $k=1: 0+1=1 \\implies$ 和为 $1$，进位为 $0$。\n- $k=2: 0+0=0 \\implies$ 和为 $0$，进位为 $0$。\n- $k=3: 1+1=2 \\implies$ 和为 $0$，进位为 $-1$。\n- $k=4: 1+0+(-1)=0 \\implies$ 和为 $0$，进位为 $0$。\n- $k=5: 0+0+0=0 \\implies$ 和为 $0$，进位为 $0$。\n- $k=6: 1+0+0=1 \\implies$ 和为 $1$，进位为 $0$。\n因此，$B = 1000011_{(-2)}$。\n\n验证：\n$\\mathrm{val}_{10}(1011_{(-2)}) = 1(-2)^3 + 0(-2)^2 + 1(-2)^1 + 1(-2)^0 = -8 - 2 + 1 = -9$。\n$\\mathrm{val}_{10}(1001_{(-2)}) = 1(-2)^3 + 0(-2)^2 + 0(-2)^1 + 1(-2)^0 = -8 + 1 = -7$。\n乘积为 $(-9) \\cdot (-7) = 63$。\n结果为 $\\mathrm{val}_{10}(1000011_{(-2)}) = 1(-2)^6 + 1(-2)^1 + 1(-2)^0 = 64 - 2 + 1 = 63$。\n计算正确。$\\mathrm{val}_{10}(B) = 63$。\n\n**第5部分：$S$ 的最终计算**\n我们需要计算 $S = \\mathrm{val}_{10}(A) + 2\\,\\mathrm{val}_{10}(B) + \\mathrm{val}_{10}(E)$。\n使用上面推导出的值：\n- $\\mathrm{val}_{10}(A) = 18$\n- $\\mathrm{val}_{10}(B) = 63$\n- $\\mathrm{val}_{10}(E) = 137$\n\n将这些值代入 $S$ 的表达式中：\n$S = 18 + 2(63) + 137$\n$S = 18 + 126 + 137$\n$S = 144 + 137$\n$S = 281$", "answer": "$$\n\\boxed{281}\n$$", "id": "3089124"}]}