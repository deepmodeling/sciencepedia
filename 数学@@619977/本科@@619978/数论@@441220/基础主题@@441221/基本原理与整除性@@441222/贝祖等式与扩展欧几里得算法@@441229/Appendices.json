{"hands_on_practices": [{"introduction": "掌握一个算法的最好方法就是亲手计算一遍。这个练习将带你逐步完成扩展欧几里得算法的核心计算过程。通过处理一对具体的正整数，你将熟悉辗转相除法和回代过程，并亲眼见证最大公约数 $d$ 是如何被表示为初始数 $a$ 和 $b$ 的线性组合 $ax+by=d$ 的。[@problem_id:3082249]", "problem": "设整数 $a$ 和 $b$ 分别为 $a=141$ 和 $b=96$。最大公约数 $\\gcd(a,b)$ 定义为能同时整除 $a$ 和 $b$ 的最大正整数。一个基本事实是，$a$ 和 $b$ 的任何公约数都能整除它们的每一个整数组合 $ua+vb$（其中 $u$ 和 $v$ 为整数），反之，所有整数组合的集合 $\\{ua+vb: u,v \\in \\mathbb{Z}\\}$ 恰好由 $\\gcd(a,b)$ 的所有倍数构成。欧几里得算法是基于久经检验的恒等式 $\\gcd(a,b)=\\gcd(b,a \\bmod b)$，通过重复进行带余除法来计算 $\\gcd(a,b)$ 的过程。贝祖等式断言，存在整数 $x$ 和 $y$ 使得 $ax+by=\\gcd(a,b)$。扩展欧几里得算法（EEA）是在执行欧几里得算法的同时，追踪得出这种表示的整数系数的方法。\n\n基于这些基础，对 $a=141$ 和 $b=96$ 执行扩展欧几里得算法（EEA），计算出满足 $141x+96y=\\gcd(141,96)$ 的明确整数 $x$ 和 $y$。您必须展示欧几里得算法的除法过程，并通过这些方程进行回代，或者维护系数的迭代更新，从而将每个余数表示为 $141$ 和 $96$ 的整数组合。您的最终答案必须是特定的有序对 $(x,y)$，该有序对验证了贝祖等式对这些输入的成立。无需进行四舍五入。", "solution": "所述问题是有效的。这是一个在数论领域内，基于欧几里得算法和贝祖等式的既定原则，定义明确且自成体系的数学问题。所有必要信息均已提供，目标明确。\n\n任务是找到整数 $x$ 和 $y$，使得 $141x + 96y = \\gcd(141, 96)$。我们将使用扩展欧几里得算法。第一阶段是使用标准的欧几里得算法计算最大公约数 $\\gcd(141, 96)$，该算法通过一系列带余除法来进行。\n\n设 $a = 141$ 和 $b = 96$。\n\n步骤1：用 $96$ 除 $141$。\n$$141 = 1 \\cdot 96 + 45$$\n余数是 $r_1 = 45$。\n\n步骤2：用前一个余数 $45$ 除 $96$。\n$$96 = 2 \\cdot 45 + 6$$\n余数是 $r_2 = 6$。\n\n步骤3：用前一个余数 $6$ 除 $45$。\n$$45 = 7 \\cdot 6 + 3$$\n余数是 $r_3 = 3$。\n\n步骤4：用前一个余数 $3$ 除 $6$。\n$$6 = 2 \\cdot 3 + 0$$\n余数是 $r_4 = 0$。\n\n最后一个非零余数就是最大公约数。因此，$\\gcd(141, 96) = 3$。\n\n第二阶段是将这个最大公约数 $3$ 表示为 $141$ 和 $96$ 的整数线性组合。这通过回溯欧几里得算法的步骤来实现（这个过程称为回代）。\n\n我们从产生最大公约数的方程（即步骤3的方程）开始，解出余数 $3$：\n$$3 = 45 - 7 \\cdot 6$$\n\n接下来，我们使用前一步（步骤2）的方程来用 $96$ 和 $45$ 表示余数 $6$：\n$$6 = 96 - 2 \\cdot 45$$\n我们将这个 $6$ 的表达式代入我们关于 $3$ 的方程中：\n$$3 = 45 - 7 \\cdot (96 - 2 \\cdot 45)$$\n现在，我们展开并合并含有 $45$ 和 $96$ 公因子的项：\n$$3 = 45 - 7 \\cdot 96 + 14 \\cdot 45$$\n$$3 = (1 + 14) \\cdot 45 - 7 \\cdot 96$$\n$$3 = 15 \\cdot 45 - 7 \\cdot 96$$\n\n最后，我们使用第一步（步骤1）的方程来用原始数字 $141$ 和 $96$ 表示余数 $45$：\n$$45 = 141 - 1 \\cdot 96$$\n我们将这个 $45$ 的表达式代入我们当前关于 $3$ 的方程中：\n$$3 = 15 \\cdot (141 - 1 \\cdot 96) - 7 \\cdot 96$$\n再次，我们展开并合并项，这次是合并含有 $141$ 和 $96$ 公因子的项：\n$$3 = 15 \\cdot 141 - 15 \\cdot 96 - 7 \\cdot 96$$\n$$3 = 15 \\cdot 141 + (-15 - 7) \\cdot 96$$\n$$3 = 15 \\cdot 141 - 22 \\cdot 96$$\n\n这个最终方程将最大公约数 $3$ 表示为 $141$ 和 $96$ 的整数线性组合。它的形式是 $141x + 96y = 3$。通过直接比较，我们确定整数系数 $x$ 和 $y$：\n$$x = 15$$\n$$y = -22$$\n\n作为检验，我们可以计算表达式的值：$141(15) + 96(-22) = 2115 - 2112 = 3$。这证实了解答的正确性。所要求的有序对是 $(x, y)$。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n15  -22\n\\end{pmatrix}\n}\n$$", "id": "3082249"}, {"introduction": "在掌握了基本计算之后，我们来处理一些更真实、更复杂的情况。这个练习引入了负数，并要求你从无限多个可能的贝祖系数 $(x, y)$ 中，找出一个满足特定条件（例如 $\\lvert x \\rvert$ 最小）的解。这标志着从“找到一个解”到“找到最优解”的进阶，需要你更深入地理解解的结构。[@problem_id:3082279]", "problem": "设 $a=-84$ 且 $b=30$。回顾最大公约数 $\\gcd(a,b)$ 被定义为理想 $\\{au+bv: u,v \\in \\mathbb{Z}\\}$ 的唯一正生成元，且裴蜀恒等式断言存在整数 $x$ 和 $y$ 使得 $ax+by=\\gcd(a,b)$。请仅使用 $\\gcd$ 作为理想正生成元的定义以及带反向代入的欧几里得算法，来确定整数 $x$ 和 $y$ 使得 $ax+by=\\gcd(a,b)$，并确保即使 $a < 0$，也有 $\\gcd(a,b)>0$。在所有这样的整数对中，报告使 $|x|$ 最小的对 $(x,y)$。你的最终答案应为这个有序整数对。", "solution": "问题要求找到满足 $a=-84$ 和 $b=30$ 的裴蜀恒等式的整数 $x$ 和 $y$，并附加约束条件 $|x|$ 最小化。该恒等式由方程 $ax+by=\\gcd(a,b)$ 给出。\n\n首先，我们确定最大公约数 $\\gcd(a,b)$。问题陈述将 $\\gcd(a,b)$ 定义为理想 $\\{au+bv: u,v \\in \\mathbb{Z}\\}$ 的唯一正生成元。因此，$\\gcd(-84, 30)$ 必须是一个正整数。最大公约数在其参数变号时保持不变，所以 $\\gcd(-84, 30) = \\gcd(84, 30)$。我们对正整数 $84$ 和 $30$ 应用欧几里得算法：\n$$84 = 2 \\cdot 30 + 24$$\n$$30 = 1 \\cdot 24 + 6$$\n$$24 = 4 \\cdot 6 + 0$$\n最后一个非零余数是 $6$。因此，$\\gcd(-84, 30) = 6$。\n\n需要求解的方程是 $-84x + 30y = 6$。\n\n接下来，我们使用扩展欧几里得算法（通过反向代入）来找到一个特解。我们使用上述算法中的方程，从给出 gcd 作为余数的那个方程开始：\n$$6 = 30 - 1 \\cdot 24$$\n从算法的第一步，我们有 $24 = 84 - 2 \\cdot 30$。将这个 $24$ 的表达式代入到 $6$ 的方程中：\n$$6 = 30 - 1 \\cdot (84 - 2 \\cdot 30)$$\n展开括号：\n$$6 = 30 - 1 \\cdot 84 + 2 \\cdot 30$$\n合并关于 $30$ 和 $84$ 的项：\n$$6 = (1+2) \\cdot 30 - 1 \\cdot 84$$\n$$6 = 3 \\cdot 30 - 1 \\cdot 84$$\n这给出了关系式 $84(-1) + 30(3) = 6$。这是方程 $84x' + 30y' = 6$ 的一个解，其中 $(x', y') = (-1, 3)$。\n\n我们的目标方程是 $-84x + 30y = 6$。我们可以将恒等式 $84(-1) + 30(3) = 6$ 重写为：\n$$-84(1) + 30(3) = 6$$\n通过与 $-84x + 30y = 6$ 比较，我们确定一个特解 $(x_0, y_0) = (1, 3)$。\n我们来验证一下：$-84(1) + 30(3) = -84 + 90 = 6$。这个解是正确的。\n\n现在，我们求丢番图方程 $-84x + 30y = 6$ 的通解。首先，我们可以通过将所有项除以 $\\gcd(-84, 30) = 6$ 来简化方程：\n$$-14x + 5y = 1$$\n我们的特解 $(x_0, y_0) = (1, 3)$ 也满足这个简化后的方程：$-14(1) + 5(3) = -14 + 15 = 1$。\n相关的齐次方程是 $-14x + 5y = 0$，可以写成 $5y = 14x$。由于 $\\gcd(5, 14)=1$，齐次方程的通解必须是 $x_h = 5k$ 和 $y_h = 14k$ 的形式，其中 $k \\in \\mathbb{Z}$ 是任意整数。\n\n非齐次方程的通解是一个特解与齐次方程通解之和：\n$$x(k) = x_0 + x_h = 1 + 5k$$\n$$y(k) = y_0 + y_h = 3 + 14k$$\n其中 $k$ 是任意整数。\n\n问题要求我们找到使 $|x|$ 最小化的对 $(x,y)$。我们需要找到使 $|x(k)| = |1+5k|$ 最小化的整数 $k$。\n我们在寻找一个整数 $k$，使得 $1+5k$ 的值尽可能接近 $0$。\n为了找到这个 $k$，我们可以分析这个表达式。$|1+5k|$ 的最小值会在整数 $k$ 最接近使 $1+5t=0$ 的实数 $t$ 时出现，即 $t = -1/5 = -0.2$。最接近 $-0.2$ 的整数是 $0$ 和 $-1$。我们测试这些值：\n如果 $k=0$，$x(0) = 1+5(0) = 1$，且 $|x(0)|=1$。\n如果 $k=-1$，$x(-1) = 1+5(-1) = -4$，且 $|x(-1)|=4$。\n$x$ 的最小绝对值是 $1$，它在 $k=0$ 时唯一出现。\n\n最后，我们将 $k=0$ 代入 $(x,y)$ 的通解中，以找到所需的整数对：\n$$x = 1 + 5(0) = 1$$\n$$y = 3 + 14(0) = 3$$\n得到的整数对是 $(1, 3)$。\n\n我们验证这个最终答案。该对是 $(x,y)=(1,3)$。我们有 $|x|=1$，这是所有解集 $\\{\\dots, -9, -4, 1, 6, \\dots\\}$ 中可能的最小值。方程得到满足：$-84(1) + 30(3) = -84+90 = 6 = \\gcd(-84, 30)$。该解与所有条件一致。", "answer": "$$\\boxed{\\begin{pmatrix} 1  3 \\end{pmatrix}}$$", "id": "3082279"}, {"introduction": "检验你是否真正理解一个算法的最终标准，是看你是否能将它“教会”计算机。这项最终实践要求你将扩展欧几里得算法实现为一个完整的程序。这个练习将迫使你系统性地思考每一个步骤，处理所有边界情况（如输入为零），并考虑整数溢出等实际的计算问题，从而将抽象的数学理论与实用的计算机科学联系起来。[@problem_id:3085685]", "problem": "你需要实现一个完整、可运行的程序，通过扩展欧几里得算法计算整数对的贝祖系数，同时计算最大公约数和最小公倍数。整数的界限为 $\\lvert a \\rvert, \\lvert b \\rvert \\le 10^9$。你的方法必须从基本的数论定义出发，并且除了这些基础知识外，不得假定任何预先打包好的结果。\n\n基础知识：\n- 最大公约数的定义：对于不全为零的整数 $a$ 和 $b$，最大公约数 $\\gcd(a,b)$ 是唯一的非负整数 $g$，满足 $g \\mid a$，$g \\mid b$，并且对于任何满足 $d \\mid a$ 和 $d \\mid b$ 的整数 $d$，都有 $d \\le g$。\n- 带余除法：对于整数 $x$ 和 $y \\ne 0$，存在唯一的整数 $q$ 和 $r$，使得 $x = y q + r$ 且 $0 \\le r < \\lvert y \\rvert$。\n- 欧几里得算法：余数序列 $r_0 = \\lvert a \\rvert$，$r_1 = \\lvert b \\rvert$，以及 $r_{k+1} = r_{k-1} - q_k r_k$（其中 $q_k = \\lfloor r_{k-1} / r_k \\rfloor$），最终会终止于 $r_m = \\gcd(\\lvert a \\rvert, \\lvert b \\rvert)$。\n- 贝祖系数的定义：满足 $a x + b y = \\gcd(a,b)$ 的整数 $x$ 和 $y$。\n- 最小公倍数的定义：最小公倍数 $\\operatorname{lcm}(a,b)$ 是能同时被 $a$ 和 $b$ 整除的最小非负整数 $L$；对于不全为零的 $a$ 和 $b$，$\\operatorname{lcm}(a,b) = \\lvert a b \\rvert / \\gcd(a,b)$，且 $\\operatorname{lcm}(0,0) = 0$。\n\n任务：\n- 根据上述原理实现扩展欧几里得算法，为每个测试用例计算一个四元组 $\\big(\\gcd(a,b), x, y, \\operatorname{lcm}(a,b)\\big)$，其中 $x$ 和 $y$ 满足 $a x + b y = \\gcd(a,b)$ 且 $\\gcd(a,b) \\ge 0$。约定 $\\gcd(0,0) = 0$，此时任何有效的贝祖系数对 $x = 0, y = 0$ 均可。\n- 从底层整数运算的角度解释，如何避免由带余除法产生的系数更新 $x \\leftarrow x - q y$ 和 $y \\leftarrow y - q x$ 中的整数溢出，以及如何计算 $\\operatorname{lcm}(a,b)$ 以避免溢出。\n\n约束条件：\n- 输入满足 $\\lvert a \\rvert, \\lvert b \\rvert \\le 10^9$。\n- 最小公倍数应以非负整数形式报告，对于任何整数 $b$，$\\operatorname{lcm}(0,b) = 0$。\n\n测试套件：\n你的程序必须为以下 $(a,b)$ 对列表计算结果：\n- $(12,18)$\n- $(0,0)$\n- $(0,5)$\n- $(10^9,1)$\n- $(-10^9,10^9)$\n- $(832040,514229)$\n- $(-24,-18)$\n- $(123456789,987654321)$\n- $(0,-7)$\n- $(1,10^9)$\n- $(7,-3)$\n\n答案规范：\n- 对于每个测试用例，输出列表 $[\\gcd(a,b), x, y, \\operatorname{lcm}(a,b)]$。\n- 将所有测试用例的结果按给定顺序汇总到一行，形式为一个用方括号括起来的逗号分隔列表，其中每个元素本身是对应一个测试用例的列表。例如，整体格式必须类似于 $[[g_1,x_1,y_1,\\ell_1],[g_2,x_2,y_2,\\ell_2],\\dots]$。\n- 输出必须是程序打印的单行内容。不应打印任何额外的注释。\n- 你提交的必须是按规定实现的完整、可运行的程序，无需用户输入。", "solution": "该问题被评估为有效。它以数论为科学基础，问题良构且客观。它提供了一套完整的定义、约束和测试用例，构成了一个自洽且一致的计算任务规范。我们可以着手解决。\n\n### 数学基础\n\n1.  **最大公约数 (GCD) 与欧几里得算法**：欧几里得算法是计算两个整数最大公约数 (GCD) 的高效方法。它基于原理 $\\gcd(a, b) = \\gcd(b, a \\pmod b)$。该算法迭代应用此性质。给定输入 $r_0 = a$ 和 $r_1 = b$，序列由 $r_{k+1} = r_{k-1} \\pmod{r_k}$ 定义，这等价于带余除法中的 $r_{k-1} = q_k r_k + r_{k+1}$。最后一个非零余数 $r_m$ 即为 GCD。GCD 被定义为非负数，因此我们通常使用绝对值：$\\gcd(a,b) = \\gcd(\\lvert a \\rvert, \\lvert b \\rvert)$。按照惯例，$\\gcd(0,0)=0$。\n\n2.  **扩展欧几里得算法与贝祖恒等式**：Bézout 恒等式指出，对于整数 $a$ 和 $b$，存在整数 $x$ 和 $y$（贝祖系数），使得 $ax + by = \\gcd(a,b)$。扩展欧几里得算法在计算 GCD 的同时计算这些系数。它维护两个序列 $s_k$ 和 $t_k$，使得在每一步 $k$，恒等式 $r_k = a s_k + b t_k$ 都成立。\n    从 $r_0=a$ 和 $r_1=b$ 开始，我们有：\n    - $r_0 = a \\cdot 1 + b \\cdot 0 \\implies (s_0, t_0) = (1, 0)$\n    - $r_1 = a \\cdot 0 + b \\cdot 1 \\implies (s_1, t_1) = (0, 1)$\n    余数的递推关系是 $r_{k+1} = r_{k-1} - q_k r_k$。代入贝祖表达式：\n    $$a s_{k+1} + b t_{k+1} = (a s_{k-1} + b t_{k-1}) - q_k (a s_k + b t_k)$$\n    $$a s_{k+1} + b t_{k+1} = a(s_{k-1} - q_k s_k) + b(t_{k-1} - q_k t_k)$$\n    这会产生系数的递推关系：\n    - $s_{k+1} = s_{k-1} - q_k s_k$\n    - $t_{k+1} = t_{k-1} - q_k t_k$\n    当 $r_{k+1}=0$ 时算法终止，此时 $r_k = \\gcd(a,b)$，对应的系数为 $s_k$ 和 $t_k$。\n\n3.  **最小公倍数 (LCM)**：对于非零的 $a, b$，最小公倍数由恒等式 $\\operatorname{lcm}(a,b) = \\frac{\\lvert a b \\rvert}{\\gcd(a,b)}$ 定义。问题规定，对于任何整数 $b$，$\\operatorname{lcm}(a,0)=\\operatorname{lcm}(0,b)=0$。\n\n### 算法实现\n\n该实现将包含一个主函数，用于处理所有情况，包括一个或两个输入为零的边界情况。对于非零输入的一般情况，它将使用一个实现扩展欧几里得算法的辅助函数。\n\n**处理特殊情况**：\n- 如果 $a = 0$ 且 $b = 0$：问题规定 $\\gcd(0,0) = 0$，我们选择 $x=0, y=0$，因此 $0 \\cdot 0 + 0 \\cdot 0 = 0$。$\\operatorname{lcm}(0,0)=0$。结果是 $(0, 0, 0, 0)$。\n- 如果 $a = 0, b \\ne 0$：$\\gcd(0,b) = \\lvert b \\rvert$。我们需要 $0 \\cdot x + b \\cdot y = \\lvert b \\rvert$。这简化为 $b \\cdot y = \\lvert b \\rvert$。一个解是 $y = \\lvert b \\rvert / b = \\operatorname{sgn}(b)$，我们可以选择 $x=0$。$\\operatorname{lcm}(0,b)=0$。例如，对于 $(0,5)$，结果是 $(5, 0, 1, 0)$。对于 $(0,-7)$，结果是 $(7, 0, -1, 0)$。\n- 如果 $a \\ne 0, b = 0$：对称地，$\\gcd(a,0) = \\lvert a \\rvert$。我们需要 $a \\cdot x + 0 \\cdot y = \\lvert a \\rvert$。这得出 $x = \\lvert a \\rvert / a = \\operatorname{sgn}(a)$，我们可以选择 $y=0$。$\\operatorname{lcm}(a,0)=0$。\n\n**一般情况 ($a \\ne 0, b \\ne 0$)：**\n为简化逻辑，首先对输入的绝对值 $\\lvert a \\rvert$ 和 $\\lvert b \\rvert$ 应用扩展欧几里得算法。假设这得到 $(g, x', y')$ 使得 $\\lvert a \\rvert x' + \\lvert b \\rvert y' = g$，其中 $g = \\gcd(\\lvert a \\rvert, \\lvert b \\rvert) = \\gcd(a,b)$。我们需要为原始的 $a, b$ 找到 $x, y$。\n我们可以写成 $a = \\operatorname{sgn}(a) \\lvert a \\rvert$ 和 $b = \\operatorname{sgn}(b) \\lvert b \\rvert$，其中我们定义 $\\operatorname{sgn}(n)=1$ 如果 $n \\ge 0$，$\\operatorname{sgn}(n)=-1$ 如果 $n < 0$。将这些代入算法的恒等式中：\n$$g = \\lvert a \\rvert x' + \\lvert b \\rvert y' = \\left(\\frac{a}{\\operatorname{sgn}(a)}\\right) x' + \\left(\\frac{b}{\\operatorname{sgn}(b)}\\right) y' = a \\left(\\frac{x'}{\\operatorname{sgn}(a)}\\right) + b \\left(\\frac{y'}{\\operatorname{sgn}(b)}\\right)$$\n由于 $\\operatorname{sgn}(n)$ 是其自身的逆（即 $\\pm 1$），我们有 $1/\\operatorname{sgn}(n) = \\operatorname{sgn}(n)$。\n$$g = a (\\operatorname{sgn}(a)x') + b (\\operatorname{sgn}(b)y')$$\n因此，我们可以将最终系数设置为 $x = \\operatorname{sgn}(a) x'$ 和 $y = \\operatorname{sgn}(b) y'$。这样就系统地处理了所有符号组合。\n\n### 避免整数溢出\n\n问题要求解释如何管理潜在的整数溢出，这在具有固定大小整数的语言（例如 C++ 中的 64 位 `long long`）中尤其重要。Python 的任意精度整数将此问题抽象掉了，但底层的算术原理很重要。\n\n1.  **贝祖系数更新**：更新步骤为 $s_{\\text{new}} = s_{\\text{old}} - q \\cdot s$ 和 $t_{\\text{new}} = t_{\\text{old}} - q \\cdot t$。在算法执行过程中，系数 $s$ 和 $t$ 会增长。一个已知的结果（例如，来自 Knuth 的《计算机程序设计艺术》第二卷）是，对于正整数 $a, b$，标准算法产生的最终贝祖系数 $x, y$ 满足 $\\lvert x \\rvert \\le b/\\gcd(a,b)$ 和 $\\lvert y \\rvert \\le a/\\gcd(a,b)$。中间系数也受这些最终值的限制。如果 $r$ 很小，商 $q = \\lfloor r_{\\text{old}}/r \\rfloor$ 可能会很大。例如，对于输入 $(A, 1)$，第一个商是 $A$。更新乘积之一，例如 $q \\cdot t$，可能大至 $A \\cdot 1 = A$。在更复杂的情况下，可以估算乘积 $q \\cdot t$。我们有 $r_{\\text{old}} \\approx q \\cdot r$，并且我们知道 $r_{\\text{old}} = a \\cdot s_{\\text{old}} + b \\cdot t_{\\text{old}}$ 和 $r = a \\cdot s + b \\cdot t$。因此，$a \\cdot s_{\\text{old}} + b \\cdot t_{\\text{old}} \\approx q(a \\cdot s + b \\cdot t)$。像 $q \\cdot t$ 这样的中间乘积的最大值受 $\\frac{\\lvert ab \\rvert}{\\gcd(a,b)^2}$ 的限制。对于给定的约束条件 $\\lvert a \\rvert, \\lvert b \\rvert \\le 10^9$，最大可能值出现在互质数的情况下，此时其数量级可达 $\\lvert ab \\rvert \\approx (10^9)^2 = 10^{18}$。这个值可以容纳在一个标准的64位有符号整数中（其最大值约为 $9 \\times 10^{18}$）。因此，使用64位整数类型进行计算足以防止系数更新中的溢出。Python 的标准整数满足此要求。\n\n2.  **LCM 计算**：LCM 的公式是 $\\operatorname{lcm}(a,b) = \\frac{\\lvert a \\cdot b \\rvert}{\\gcd(a,b)}$。如果 $a$ 和 $b$ 很大，对分子 $\\lvert a \\cdot b \\rvert$ 的朴素计算可能会溢出。在 $\\lvert a \\rvert, \\lvert b \\rvert \\le 10^9$ 的条件下，乘积可达 $10^{18}$，如前所述，这可以容纳在64位整数中。然而，对于一个通用库函数来说，最佳实践是避免这个中间乘积。由于 $\\gcd(a,b)$ 能同时整除 $a$ 和 $b$，可以在乘法之前执行除法。这能确保中间结果不会不必要地变得过大。计算 LCM 的安全方法是：\n    $$\\operatorname{lcm}(a,b) = \\left( \\frac{\\lvert a \\rvert}{\\gcd(a,b)} \\right) \\cdot \\lvert b \\rvert$$\n    除法 $\\lvert a \\rvert / \\gcd(a,b)$ 会得到一个精确的整数。随后的乘法得出最终的 LCM，对于给定的约束，这个结果也能容纳在64位整数中。\n\n提供的 Python 代码实现了这一逻辑。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases.\n    \"\"\"\n\n    def _compute_bezout_lcm(a, b):\n        \"\"\"\n        Computes the GCD, Bézout coefficients (x, y), and LCM for a pair of integers (a, b).\n        The result is a tuple (g, x, y, l) where:\n        - g = gcd(a, b) >= 0\n        - ax + by = g\n        - l = lcm(a, b) >= 0\n        \"\"\"\n        if a == 0 and b == 0:\n            return 0, 0, 0, 0\n\n        # Handle cases where one input is zero.\n        # gcd(a, 0) = |a|, lcm(a, 0) = 0.\n        # ax + 0y = |a| => x = |a|/a = sgn(a), y can be 0.\n        if b == 0:\n            g = abs(a)\n            x = 1 if a >= 0 else -1\n            y = 0\n            lcm = 0\n            return g, x, y, lcm\n        \n        # gcd(0, b) = |b|, lcm(0, b) = 0.\n        # 0x + by = |b| => y = |b|/b = sgn(b), x can be 0.\n        if a == 0:\n            g = abs(b)\n            x = 0\n            y = 1 if b >= 0 else -1\n            lcm = 0\n            return g, x, y, lcm\n\n        # General case (a!=0, b!=0)\n        # We run the extended Euclidean algorithm on |a| and |b|\n        # to ensure the gcd is non-negative and simplify the iteration.\n        sign_a = 1 if a > 0 else -1\n        sign_b = 1 if b > 0 else -1\n        abs_a = abs(a)\n        abs_b = abs(b)\n\n        # Extended Euclidean Algorithm\n        # Initializes such that old_r = old_s*abs_a + old_t*abs_b and r = s*abs_a + t*abs_b\n        s, old_s = 0, 1\n        t, old_t = 1, 0\n        r, old_r = abs_b, abs_a\n        \n        while r != 0:\n            quotient = old_r // r\n            old_r, r = r, old_r - quotient * r\n            old_s, s = s, old_s - quotient * s\n            old_t, t = t, old_t - quotient * t\n\n        # Result of algorithm on absolute values:\n        # g = gcd(|a|, |b|), x_abs = old_s, y_abs = old_t\n        # such that |a|*x_abs + |b|*y_abs = g\n        g = old_r\n        x_abs = old_s\n        y_abs = old_t\n\n        # Adjust coefficients for original signs of a and b.\n        # We want a*x + b*y = g.\n        # We have |a|*x_abs + |b|*y_abs = g.\n        # Substituting a = sgn(a)*|a| and b = sgn(b)*|b|:\n        # a/(sgn(a))*x_abs + b/(sgn(b))*y_abs = g\n        # a*(sgn(a)*x_abs) + b*(sgn(b)*y_abs) = g\n        # So x = sgn(a)*x_abs and y = sgn(b)*y_abs\n        x = x_abs * sign_a\n        y = y_abs * sign_b\n        \n        # Calculate LCM safely to avoid overflow\n        # lcm(a,b) = (|a| * |b|) / gcd(a,b)\n        # To avoid intermediate overflow, compute as (|a| / gcd) * |b|\n        lcm = (abs_a // g) * abs_b\n        \n        return g, x, y, lcm\n\n    test_cases = [\n        (12, 18),\n        (0, 0),\n        (0, 5),\n        (10**9, 1),\n        (-10**9, 10**9),\n        (832040, 514229),\n        (-24, -18),\n        (123456789, 987654321),\n        (0, -7),\n        (1, 10**9),\n        (7, -3),\n    ]\n\n    results = []\n    for a, b in test_cases:\n        g, x, y, l = _compute_bezout_lcm(a, b)\n        results.append(f\"[{g},{x},{y},{l}]\")\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3085685"}]}