{"hands_on_practices": [{"introduction": "在深入研究复杂的不尽序列之前，我们必须首先掌握其生成函数——不尽和函数 $s(n)$ 的计算。这个练习将作为一个基础起点，引导我们从第一性原理出发，为形如 $n=p^k$（其中 $p$ 是素数）的数推导 $s(n)$ 的封闭形式表达式。通过将 $s(n)$ 的定义与几何级数求和公式联系起来，你将为后续更复杂的计算和算法设计打下坚实的基础 [@problem_id:3080650]。", "problem": "在对不尽序列与不尽类型的研究中，不尽和函数 $s(n)$ 对一个正整数 $n$ 所賦的值是其真因子（所有严格小于 $n$ 的正因子）之和。令 $\\sigma(n)$ 表示 $n$ 的所有正因子之和。根据定义，这些函数满足 $s(n)=\\sigma(n)-n$。从这些核心定义以及素数幂的因子的基本性质出发，考虑一个通用素数 $p$ 和一个整数 $k\\geq 1$。仅基于关于 $p^{k}$ 的因子的第一性原理以及关于有限几何级数的标准结论，推导不尽和 $s(p^{k})$ 的闭式表达式。将您的最终结果表示为关于 $p$ 和 $k$ 的单个解析表达式，并以通过关系式 $s(p^{k})=\\sigma(p^{k})-p^{k}$ 显式使用 $\\sigma(p^{k})$ 的形式给出。无需舍入。", "solution": "问题要求推导素数幂的真因子和 $s(p^k)$ 的闭式表达式，其中 $p$ 是素数，$k$ 是大于等于 $1$ 的整数。推导过程必须基于第一性原理及几何级数的性质。\n\n根据定义，正整数 $n$ 的真因子和 $s(n)$ 是其真因子之和，即 $n$ 的所有严格小于 $n$ 的正因子之和。$n$ 的所有正因子（包括 $n$ 本身）之和用函数 $\\sigma(n)$ 表示。这两个函数之间的关系式为：\n$$s(n) = \\sigma(n) - n$$\n我们需要求出 $s(p^k)$ 的表达式。为此，我们首先推导 $\\sigma(p^k)$ 的闭式表达式。\n\n根据算术基本定理，任何大于1的整数都有唯一的素因子分解。对于 $p^k$（其中 $p$ 为素数）形式的数，其因子的结构很简单。$p^k$ 的正因子恰好是 $p$ 从 $p^0$ 到 $p^k$ 的各次幂。\n$p^k$ 的因子集合为 $\\{p^0, p^1, p^2, \\dots, p^k\\}$。\n\n函数 $\\sigma(p^k)$ 是所有这些因子之和：\n$$\\sigma(p^k) = p^0 + p^1 + p^2 + \\dots + p^k$$\n这个和是一个有限几何级数，首项 $a = p^0 = 1$，公比 $r = p$，共有 $k+1$ 项。有限几何级数的标准求和公式为 $S_N = a \\frac{r^N - 1}{r - 1}$，其中 $N$ 是项数。\n将此公式应用于 $\\sigma(p^k)$ 的求和，其中 $a=1$，$r=p$，$N=k+1$，可得：\n$$\\sigma(p^k) = 1 \\cdot \\frac{p^{k+1} - 1}{p - 1} = \\frac{p^{k+1} - 1}{p-1}$$\n这就是 $p^k$ 的所有因子之和的闭式表达式。\n\n现在，我们将给定的关系式 $s(n) = \\sigma(n) - n$ 用于 $n=p^k$ 的特例：\n$$s(p^k) = \\sigma(p^k) - p^k$$\n代入推导出的 $\\sigma(p^k)$ 表达式，我们便得到真因子和 $s(p^k)$ 的闭式表达式：\n$$s(p^k) = \\frac{p^{k+1} - 1}{p - 1} - p^k$$\n该表达式是关于 $p$ 和 $k$ 的单个解析函数，并且其呈现形式明确地使用了推导出的 $\\sigma(p^k)$ 公式，符合问题陈述的要求。\n\n为求完整并作一致性检验，我们也可以通过直接对 $p^k$ 的真因子求和来推导 $s(p^k)$。真因子为 $\\{p^0, p^1, p^2, \\dots, p^{k-1}\\}$。它们的和是：\n$$s(p^k) = p^0 + p^1 + p^2 + \\dots + p^{k-1}$$\n这又是另一个有限几何级数，这次有 $k$ 项，首项 $a=1$，公比 $r=p$。其和为：\n$$s(p^k) = 1 \\cdot \\frac{p^k - 1}{p - 1} = \\frac{p^k - 1}{p-1}$$\n让我们验证一下我们的主要结果可以简化为此形式：\n$$s(p^k) = \\frac{p^{k+1} - 1}{p - 1} - p^k = \\frac{p^{k+1} - 1 - p^k(p-1)}{p-1} = \\frac{p^{k+1} - 1 - (p^{k+1} - p^k)}{p-1} = \\frac{p^{k+1} - 1 - p^{k+1} + p^k}{p-1} = \\frac{p^k - 1}{p-1}$$\n两种推导方法得出了相同的结果，从而证实了我们方法的正确性。然而，问题指定最终结果应以明确表达其与 $\\sigma(p^k)$ 关系的形式给出。因此，未简化的形式才是所要求的最终答案。", "answer": "$$\\boxed{\\frac{p^{k+1} - 1}{p - 1} - p^k}$$", "id": "3080650"}, {"introduction": "掌握了素数幂的计算后，我们现在将范围扩大到任意正整数。这个实践练习旨在将理论与应用联系起来，要求你利用算术基本定理和除数和函数 $\\sigma(n)$ 的乘性性质，设计一个通用算法来计算任意整数 $n$ 的 $s(n)$。此外，你还将实践根据 $s(n)$ 与 $n$ 的关系，将数分类为亏数 ($s(n)  n$)、完全数 ($s(n) = n$) 或丰数 ($s(n)  n$)，这是理解不尽序列动态行为的关键一步 [@problem_id:3080697]。", "problem": "你需要设计并实现一个算法来计算真因数和函数 $s(n)$。对于一个正整数 $n$，该函数定义为 $n$ 的所有严格小于 $n$ 的正因数之和。该算法必须基于 $n$ 的质因数分解，并从第一性原理推导得出：从因数的定义、质因数分解的概念以及因数和函数的积性性质出发。你不能假设任何特殊情况的捷径或使用预计算表。你的实现必须对给定测试套件中的任何正整数输入都是通用且正确的。\n\n你的程序必须：\n- 给定一个正整数 $n$，利用其质因数分解和因数和函数的积性结构计算 $s(n)$。\n- 对每个 $n$，还要计算其真因数类型代码 $t(n)$，定义如下：\n  - 如果 $s(n)  n$（亏数），则 $t(n)=-1$。\n  - 如果 $s(n)=n$（完全数），则 $t(n)=0$。\n  - 如果 $s(n)  n$（丰数），则 $t(n)=1$。\n- 根据定义 $s(1)=0$ 处理边界情况 $n=1$。\n\n你可以使用的基础理论包括：\n- $n$ 的因数和真因数的定义。\n- 算术基本定理，它保证了每个 $n\\ge 2$ 都能唯一地分解为素数幂的乘积。\n- 从互质整数的因数结构推导出的因数和函数的积性性质。\n- 用于计算单个素数幂因子中素数幂次和的有限几何级数恒等式。\n\n你还必须根据分解 $n$ 的复杂度来推导并说明你的算法的时间复杂度。具体来说，假设分解 $n$ 的时间是 $T_{\\mathrm{fact}}(n)$。你必须使用 $T_{\\mathrm{fact}}(n)$ 以及从分解过程中自然产生的 $n$ 的其他相关算术参数来表示总时间复杂度，并基于上述基础理论给出明确的论证。推理过程应写在你的解答文本中；程序只应执行计算。\n\n测试套件：\n- 待评估的输入 $n$：$[1,2,28,12,25,220,360,9973]$。\n- 对于给定顺序中的每个 $n$，输出数对 $[s(n),t(n)]$。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含一个由逗号分隔的方括号数对列表，该列表本身也由方括号括起，且没有多余的空格。例如，输出必须看起来像 $[[a\\_1,b\\_1],[a\\_2,b\\_2],\\dots]$，其中每个 $a\\_i$ 和 $b\\_i$ 是对应于第 $i$ 个测试输入的 $s(n)$ 和 $t(n)$ 的整数。\n- 输出必须是严格符合此格式的单行：一个顶级列表，其中包含与测试套件顺序相同的 8 个有序数对。\n- 你的程序必须是确定性的，并且不得要求任何输入。不涉及任何物理单位或角度单位；所有输出都是纯整数。测试套件的最终答案必须是指定的整数和整数列表，并按所述方式汇总为单行。", "solution": "该问题是有效的，因为它具有科学依据、问题明确且客观。它包含一个标准的数论任务，并清楚地说明了所有必要的定义和约束。\n\n该问题要求计算正整数 $n$ 的真因数和 $s(n)$。真因数和定义为 $n$ 的所有严格小于 $n$ 的正因数之和。这些因数也称为 $n$ 的真因数。$n$ 的所有正因数（包括 $n$ 本身）之和用因数和函数 $\\sigma(n)$ 表示。根据这些定义，真因数和由关系式 $s(n) = \\sigma(n) - n$ 给出。\n\n该问题还要求根据 $n$ 的真因数和对其进行分类。如果 $s(n)  n$，则整数 $n$ 被分类为亏数；如果 $s(n) = n$，则为完全数；如果 $s(n)  n$，则为丰数。这些分类分别对应于真因数类型代码 $t(n) = -1$、$t(n) = 0$ 和 $t(n) = 1$。\n\n算法的推导必须基于第一性原理，具体来说是利用 $n$ 的质因数分解。\n\n对于边界情况 $n=1$，唯一的正因数是 $1$。其真因数集合为空。因此，真因数之和为 $s(1) = 0$。由于 $s(1)  1$，数字 $1$ 是亏数，其类型代码为 $t(1)=-1$。\n\n对于任何整数 $n \\ge 2$，算术基本定理指出，$n$ 具有唯一的质因数分解形式：\n$$n = p_1^{a_1} p_2^{a_2} \\cdots p_k^{a_k} = \\prod_{i=1}^{k} p_i^{a_i}$$\n其中 $p_1, p_2, \\dots, p_k$ 是不同的素数，$a_1, a_2, \\dots, a_k$ 是正整数。\n\n$n$ 的任何因数 $d$ 必具有以下形式：\n$$d = p_1^{b_1} p_2^{b_2} \\cdots p_k^{b_k} = \\prod_{i=1}^{k} p_i^{b_i}$$\n其中对于每个 $i \\in \\{1, 2, \\dots, k\\}$，指数 $b_i$ 是满足 $0 \\le b_i \\le a_i$ 的整数。\n\n因数和函数 $\\sigma(n)$ 是所有这些因数 $d$ 的和。这可以表示为对所有可能的指数 $b_i$ 值的嵌套求和：\n$$\\sigma(n) = \\sum_{b_1=0}^{a_1} \\sum_{b_2=0}^{a_2} \\cdots \\sum_{b_k=0}^{a_k} \\left( p_1^{b_1} p_2^{b_2} \\cdots p_k^{b_k} \\right)$$\n由于乘法对加法的分配律，这个多维和可以分解为一维和的乘积：\n$$\\sigma(n) = \\left( \\sum_{b_1=0}^{a_1} p_1^{b_1} \\right) \\left( \\sum_{b_2=0}^{a_2} p_2^{b_2} \\right) \\cdots \\left( \\sum_{b_k=0}^{a_k} p_k^{b_k} \\right) = \\prod_{i=1}^{k} \\left( \\sum_{b_i=0}^{a_i} p_i^{b_i} \\right)$$\n这个表达式揭示了 $\\sigma$ 函数的积性性质。每个素数因子 $p_i^{a_i}$ 对应的项是 $\\sigma(p_i^{a_i}) = \\sum_{b_i=0}^{a_i} p_i^{b_i}$。因此，$\\sigma(n) = \\prod_{i=1}^{k} \\sigma(p_i^{a_i})$。\n\n每个和 $\\sum_{b=0}^{a} p^b = 1 + p + p^2 + \\dots + p^a$ 都是一个有限几何级数。几何级数的求和公式为 $\\sum_{j=0}^{m} r^j = \\frac{r^{m+1}-1}{r-1}$。将此公式应用于 $r=p$ 和 $m=a$，我们得到：\n$$\\sigma(p^a) = \\frac{p^{a+1}-1}{p-1}$$\n将此结果代回到 $\\sigma(n)$ 的乘积中，我们得到基于质因数分解的完整公式：\n$$\\sigma(n) = \\prod_{i=1}^{k} \\frac{p_i^{a_i+1}-1}{p_i-1}$$\n\n计算 $s(n)$ 和 $t(n)$ 的算法可以总结如下：\n1. 处理边界情况：如果 $n=1$，返回 $s(1)=0$ 和 $t(1)=-1$。\n2. 对于 $n \\ge 2$，找出其质因数分解 $n = \\prod_{i=1}^{k} p_i^{a_i}$。这将得到一组数对 $(p_i, a_i)$。\n3. 初始化因数和 $\\sigma_{val}$ 为 $1$。\n4. 对于分解中的每个数对 $(p_i, a_i)$，计算项 $\\sigma(p_i^{a_i}) = \\frac{p_i^{a_i+1}-1}{p_i-1}$。\n5. 将此项乘入运行中的乘积：$\\sigma_{val} = \\sigma_{val} \\times \\sigma(p_i^{a_i})$。\n6. 遍历所有素数因子后，最终值为 $\\sigma(n) = \\sigma_{val}$。\n7. 计算真因数和：$s(n) = \\sigma(n) - n$。\n8. 通过比较 $s(n)$ 和 $n$ 来确定真因数类型代码 $t(n)$：\n   - 如果 $s(n)  n$，$t(n) = -1$。\n   - 如果 $s(n) = n$，$t(n) = 0$。\n   - 如果 $s(n) > n$，$t(n) = 1$。\n\n该算法的时间复杂度主要由质因数分解步骤决定。设 $T_{\\mathrm{fact}}(n)$ 为找出 $n$ 的质因数分解所需的时间。分解后的步骤涉及遍历 $n$ 的 $k$ 个不同素数因子。对于每个因子 $p_i^{a_i}$，我们执行常数次算术运算（求幂、减法、除法）。不同素数因子的数量 $k$ 最多为 $O(\\log n)$。中间数和最终数的大小在 $n$ 的多项式范围内。具体来说，对这些数进行算术运算所需的时间是其比特长度的多项式函数，即 $O(\\log n)$。因此，分解后计算的总时间为 $O(\\text{poly}(\\log n))$。由于整数分解是一个计算难题，目前已知的最佳算法在 $\\log n$ 上具有超多项式复杂度，因此 $T_{\\mathrm{fact}}(n)$ 是主导项。因此，算法的总时间复杂度为 $O(T_{\\mathrm{fact}}(n))$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the aliquot sum and aliquot type for a given list of integers,\n    as per the problem statement.\n    \"\"\"\n\n    def get_prime_factorization(n):\n        \"\"\"\n        Computes the prime factorization of a positive integer n.\n        Returns a dictionary mapping each prime factor to its exponent.\n        Uses trial division, which is efficient for the given test cases.\n        \"\"\"\n        if n  1:\n            return {}\n        \n        factors = {}\n        # Handle factor 2\n        while n % 2 == 0:\n            factors[2] = factors.get(2, 0) + 1\n            n //= 2\n        \n        # Handle odd factors\n        d = 3\n        while d * d = n:\n            while n % d == 0:\n                factors[d] = factors.get(d, 0) + 1\n                n //= d\n            d += 2\n            \n        # If n is still greater than 1, it must be a prime factor itself.\n        if n > 1:\n            factors[n] = factors.get(n, 0) + 1\n            \n        return factors\n\n    def compute_s_and_t(n):\n        \"\"\"\n        Computes the aliquot sum s(n) and aliquot type code t(n).\n        \"\"\"\n        if n == 1:\n            s_n = 0\n            t_n = -1  # Deficient\n            return [s_n, t_n]\n\n        factors = get_prime_factorization(n)\n        \n        sigma_n = 1\n        for p, a in factors.items():\n            # Using the geometric series sum formula: (p^(a+1) - 1) / (p - 1)\n            sigma_p_a = (p**(a + 1) - 1) // (p - 1)\n            sigma_n *= sigma_p_a\n            \n        s_n = sigma_n - n\n        \n        if s_n  n:\n            t_n = -1  # Deficient\n        elif s_n == n:\n            t_n = 0   # Perfect\n        else:\n            t_n = 1   # Abundant\n            \n        return [s_n, t_n]\n\n    test_cases = [1, 2, 28, 12, 25, 220, 360, 9973]\n    \n    results = []\n    for n in test_cases:\n        result = compute_s_and_t(n)\n        results.append(result)\n\n    # Format the output string exactly as specified, with no extra whitespace.\n    pair_strings = [f\"[{s},{t}]\" for s, t in results]\n    final_output = f\"[{','.join(pair_strings)}]\"\n    \n    # Final print statement in the exact required format.\n    print(final_output)\n\nsolve()\n```", "id": "3080697"}, {"introduction": "这是我们的终极实践，它将前面学到的所有概念融为一体。既然我们已经能够计算 $s(n)$，我们就可以生成并分析不尽序列本身，探索它们的长期行为——这也是该领域的核心问题。这项动手任务要求你实现算法来追踪序列的轨迹，判断它最终是终止（达到 $0$）还是进入一个循环，并精确地描述这些循环的特征（如周期长度和最小元素）。通过这个练习，你将能亲身体验研究不尽序列的计算方法和挑战 [@problem_id:3080656]。", "problem": "你需要实现一个完整的、可运行的程序，为给定的起始整数计算 aliquot 序列，直到检测到序列终止或进入循环。从第一性原理出发，使用真因子和函数的定义以及由此导出的序列。推导并实现基于哈希的检测方法和 Floyd 循环发现算法，以确保程序的鲁棒性。程序必须计算指定的数值不变量，用以量化每个 aliquot 序列的行为。\n\n定义与基本原理：\n- 对于任意整数 $n \\geq 0$，定义 $n$ 的真因子集合为所有满足 $d \\mid n$ 且 $0  d  n$ 的正整数 $d$。定义真因子和函数 $s(n)$ 为 $s(n) = \\sum_{d \\mid n, \\; 0  d  n} d$，并约定 $s(0) = 0$ 和 $s(1) = 0$。\n- 从 $a_0 = n$ 开始的 aliquot 序列 $\\{a_k\\}_{k \\geq 0}$ 通过 $a_{k+1} = s(a_k)$ 对所有 $k \\geq 0$ 递归定义。\n- 如果序列在某个有限索引处达到 $0$，则称该序列终止。如果存在整数 $\\mu \\geq 0$ 和 $\\lambda \\geq 1$ 使得 $a_{\\mu} = a_{\\mu+\\lambda}$，并且此后对所有 $t \\geq \\mu$ 都有 $a_{t+\\lambda} = a_t$，则称该序列是循环的。整数 $\\mu$ 是前周期（也称为尾长），$\\lambda$ 是循环长度。\n- 为了规范地报告循环，定义循环代表元 $c$：在终止情况下为 $0$；在循环情况下为集合 $\\{a_{\\mu}, a_{\\mu+1}, \\ldots, a_{\\mu+\\lambda-1}\\}$ 中（按整数常规顺序）的最小元素。\n\n任务要求：\n- 根据其定义实现一个计算 $s(n)$ 的函数，仅使用基本的因子属性（例如，如果 $d \\mid n$ 且 $1  d \\leq \\sqrt{n}$，那么 $d$ 和 $n/d$ 都是因子）。\n- 为 $s(n)$ 生成的序列实现两种独立的循环检测策略：\n  1. 一种基于哈希的方法，记录访问过的值及其首次出现的索引，以检测首次重复并确定 $\\mu$ 和 $\\lambda$。\n  2. Floyd 循环发现算法（也称为龟兔算法），经过调整以在遇到 $0$ 时检测终止，否则恢复 $\\mu$ 和 $\\lambda$。\n- 将起始值 $n$ 的输出不变量定义为三元组 $[\\mu, \\lambda, c]$，其中当且仅当序列终止时 $c = 0$，否则 $c$ 是最终循环中的最小元素。\n\n测试套件：\n- 你的程序必须评估起始值 $n \\in \\{1, 6, 10, 13, 220, 12496\\}$，并为每个值计算对应的三元组 $[\\mu, \\lambda, c]$。\n- 这些值涵盖了一个边界情况（$n=1$）、一个作为不动点的完全数（$n=6$）、一个常规终止情况（$n=10$）、一个通过 $1$ 终止的素数（$n=13$）、一个导致 $2$-循环的亲和数对（$n=220$），以及一个长度为 $5$ 的相亲数环（$n=12496$）。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的每个条目本身都是一个在方括号内的三元组。对于指定的测试套件，输出必须具有以下形式\n$[[\\mu_1,\\lambda_1,c_1],[\\mu_2,\\lambda_2,c_2],\\ldots,[\\mu_6,\\lambda_6,c_6]]$\n且不含空格。", "solution": "计算 aliquot 序列不变量的问题是数论领域内一个定义明确的计算任务。它具有科学依据，是客观的，并包含了进行形式化求解所需的所有必要定义和约束。所提供的测试用例是用于说明 aliquot 序列不同行为的标准示例，包括终止、不动点（长度为 $1$ 的循环）、亲和数对（长度为 $2$ 的循环）和相亲数环（长度大于 $2$ 的循环）。因此，该问题被认定为是**有效的**。\n\n解决方案分三个阶段进行。首先，我们构建序列的生成器——真因子和函数 $s(n)$。其次，我们形式化 aliquot 序列的生成过程以及所需数值不变量的定义：前周期长度 $\\mu$、循环长度 $\\lambda$ 和循环代表元 $c$。最后，我们详细说明用于检测循环和终止的两种不同算法的实现——一种基于哈希的方法和 Floyd 循环发现算法——以计算任何给定起始整数 $n$ 的这些不变量。\n\n### 1. 真因子和函数 $s(n)$\n\n问题的核心是函数 $s(n)$，其定义为整数 $n$ 的所有正因子（不包括 $n$ 本身）之和。其定义为 $s(n) = \\sum_{d \\mid n, 0  d  n} d$。约定 $s(0) = 0$ 和 $s(1) = 0$。\n\n对于 $n > 1$，我们可以高效地计算 $s(n)$。整数 $1$ 始终是一个真因子，所以我们可以用 $1$ 初始化一个总和。然后我们寻找其他因子。因子的一个关键属性是它们成对出现。如果 $d$ 是 $n$ 的一个因子，那么 $n/d$ 也是一个因子。我们可以利用这一点，通过迭代测试因子 $d$，从 $2$ 遍历到 $n$ 的平方根的整数部分 $\\lfloor\\sqrt{n}\\rfloor$。\n\n算法如下：\n1.  根据定义处理基本情况：如果 $n \\le 1$，返回 $0$。\n2.  对于 $n > 1$，初始化一个变量 `total_sum` 为 $1$，计入因子 $d=1$。\n3.  使用一个整数 $d$ 从 $2$ 迭代至（并包括）$\\lfloor\\sqrt{n}\\rfloor$。\n4.  在每次迭代中，如果 $n \\pmod d = 0$，则 $d$ 是一个真因子，我们将其加到 `total_sum` 中。其对应的成对因子是 $q = n/d$。\n5.  如果 $d$ 不等于其配对的 $q$（当 $n$ 不是完全平方数时发生），则 $q$ 是另一个不同的因子。我们也把 $q$ 加到 `total_sum` 中。如果 $d=q$（即 $n=d^2$），我们已经计入了这一个因子 $d$，因此无需对这对因子做进一步操作。\n6.  `total_sum` 的最终值就是 $s(n)$。\n\n例如，计算 $s(220)$：$\\sqrt{220} \\approx 14.8$。\n- 初始化总和 = $1$。\n- 到 $14$ 为止的因子：$2, 4, 5, 10, 11$。\n- 配对因子：$220/2=110$, $220/4=55$, $220/5=44$, $220/10=22$, $220/11=20$。\n- $s(220) = 1 + 2 + 4 + 5 + 10 + 11 + 20 + 22 + 44 + 55 + 110 = 284$。\n\n### 2. Aliquot 序列不变量：$[\\mu, \\lambda, c]$\n\nAliquot 序列是通过从初始整数 $a_0 = n$ 开始迭代 $s(n)$ 函数生成的：\n$$ a_{k+1} = s(a_k) \\quad \\text{for } k \\geq 0 $$\n这个序列 $\\{a_k\\}_{k \\geq 0}$ 要么通过达到 $0$ 而终止，要么最终重复，进入一个循环。我们的任务是使用三个不变量来量化此行为：\n-   **前周期长度 ($\\mu$)**：序列在进入周期性或终止之前的项数。这是“尾部”的长度。\n-   **循环长度 ($\\lambda$)**：重复循环中唯一项的数量。对于终止序列，没有循环，因此我们约定 $\\lambda = 0$。\n-   **循环代表元 ($c$)**：对于循环序列，这是循环 $\\{a_\\mu, a_{\\mu+1}, \\ldots, a_{\\mu+\\lambda-1}\\}$ 内的最小整数值。对于终止序列，我们设定 $c = 0$。\n\n### 3. 循环与终止检测算法\n\n我们实现两种独立的算法来寻找不变量 $[\\mu, \\lambda, c]$。\n\n#### 方法 1：基于哈希的检测\n\n此方法依赖内存来跟踪序列中生成的每一项。使用哈希映射（或字典）来存储遇到的每个唯一项及其首次出现的索引。\n1.  初始化一个空序列列表 `seq`，并添加起始值 $n$，即 `seq = [n]`。\n2.  初始化一个哈希映射 `visited`，将值 $n$ 映射到其索引 $0$：`visited = {n: 0}`。\n3.  开始一个循环以生成后续项：\n    a.  设 `current_val` 为 `seq` 中的最后一项。计算 `next_val = s(current_val)`。\n    b.  **终止检查**：如果 `next_val` 为 $0$，则序列终止。前周期长度是 $0$ 之前所有项的数量，因此 $\\mu = \\text{len(seq)}$。根据约定，我们设置 $\\lambda = 0$ 和 $c = 0$。对此起始值的处理完成。\n    c.  **循环检查**：如果 `next_val` 已经是 `visited` 映射中的一个键，则检测到循环。我们第一次看到这个值的索引是 $\\mu = \\text{visited[next_val]}$。当前生成的项数为 $\\text{len(seq)}$。因此，循环长度为 $\\lambda = \\text{len(seq)} - \\mu$。循环的元素由子序列 `seq[μ:]` 给出。循环代表元是 $c = \\min(\\text{seq[μ:]})$。处理完成。\n    d.  **继续**：如果 `next_val` 不为 $0$ 且未被访问过，则记录它：将 `next_val` 及其索引添加到 `visited` 映射中，`visited[next_val] = len(seq)`，并将其附加到 `seq` 列表中。然后，继续循环。\n\n此方法简单直接，能直接得出所有三个不变量 $\\mu$、$\\lambda$ 和 $c$。\n\n#### 方法 2：Floyd 循环发现算法（龟兔算法）\n\n该算法使用两个指针，一个“乌龟”和一个“兔子”，以不同速度在序列中移动。它能以常数空间复杂度检测到循环，但需要额外的步骤来找到不变量。\n\n1.  **阶段 1：检测循环或终止**\n    a.  初始化 `tortoise = s(n)` 和 `hare = s(s(n))`。处理这些初始值可能为 $0$ 的边缘情况，这表示立即终止。\n    b.  在一个循环中推进指针：`tortoise = s(tortoise)` 和 `hare = s(s(hare))`。\n    c.  如果 `tortoise == hare`（检测到循环）或 `tortoise` 或 `hare` 变为 $0$（检测到终止），则循环终止。\n\n2.  **阶段 2：确定不变量**\n    a.  **如果检测到终止**：序列以 $0$ 结尾。为了找到 $\\mu$，我们必须从头重新追踪序列：初始化 `current_val = n` 和一个计数器 `mu_val = 0`。逐步遍历序列（`current_val = s(current_val)`）直到 `current_val` 变为 $0$，每一步都增加 `mu_val`。最终的计数就是 $\\mu$。其他不变量为 $\\lambda=0$ 和 $c=0$。\n    b.  **如果检测到循环**：指针在一个值 `tortoise` 处相遇，该值是循环内的一个元素。\n        i.  **寻找前周期长度 ($\\mu$)**：初始化一个指针 `ptr1` 指向起点 $n$，另一个指针 `ptr2` 指向相遇点 `tortoise`。两个指针每次都前进一步（`ptr1 = s(ptr1)`，`ptr2 = s(ptr2)`）。它们首次相等的位置就是循环的第一个元素 $a_\\mu$。所走的步数就是前周期长度 $\\mu$。\n        ii. **寻找循环长度 ($\\lambda$)**：从循环的第一个元素 $a_\\mu$ 开始，每次将一个指针前进一步（`ptr = s(ptr)`），直到它返回到 $a_\\mu$。所走的步数就是循环长度 $\\lambda$。\n        iii. **寻找循环代表元 ($c$)**：从 $a_\\mu$ 开始，遍历循环中的 $\\lambda$ 个元素，并找到它们的最小值。这个值就是 $c$。\n\n两种方法都在最终程序中实现。由于基于哈希的方法能更直接地计算所有三个所需的不变量，因此用它来生成最终输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# from scipy import ... is not needed for this problem.\n\ndef s(n: int) -> int:\n    \"\"\"\n    Computes the sum of proper divisors of an integer n, s(n).\n    s(n) is the sum of all positive integers d such that d | n and 0  d  n.\n    By convention, s(0) = 0 and s(1) = 0.\n    \"\"\"\n    if n = 1:\n        return 0\n    \n    # Initialize sum with 1, as 1 is a proper divisor for all n > 1.\n    total = 1\n    \n    # Iterate from 2 up to the square root of n.\n    # np.sqrt is used as per the allowed library set.\n    limit = int(np.sqrt(n))\n    for d in range(2, limit + 1):\n        if n % d == 0:\n            total += d\n            quotient = n // d\n            # Add the paired divisor if it's not the same as d (for non-perfect squares).\n            if d != quotient:\n                total += quotient\n                \n    return total\n\ndef analyze_sequence_hash(n: int) -> list[int]:\n    \"\"\"\n    Analyzes the aliquot sequence starting at n using a hashing-based method.\n    \n    Returns:\n        A list [mu, lambda, c] representing the preperiod, cycle length,\n        and cycle representative.\n    \"\"\"\n    if n == 0:\n        return [0, 1, 0] # A fixed point, but often treated as termination.\n                         # The prompt definition s(0)=0 leads to [0, 1, 0].\n                         # Let's align with the termination definition.\n                         # Sequence 0 -> 0. Preperiod 0. Cycle length 1. rep 0.\n                         # But test cases imply 0 means termination. So we just need to handle s(a_k)=0.\n    \n    sequence = [n]\n    visited = {n: 0} # Maps value to its first index\n    k = 0\n    while True:\n        # We add a practical limit to prevent potential infinite loops on\n        # sequences whose behavior is unknown (e.g., Lehmer five), though not\n        # strictly needed for the given test cases.\n        if k > 2000:\n            # This case should not be reached for the provided inputs\n            raise RuntimeError(f\"Sequence starting at {n} did not resolve within the iteration limit.\")\n\n        current_val = sequence[-1]\n        next_val = s(current_val)\n        \n        # Termination check\n        if next_val == 0:\n            mu = len(sequence)\n            lam = 0\n            c = 0\n            return [mu, lam, c]\n        \n        # Cycle detection check\n        if next_val in visited:\n            mu = visited[next_val]\n            lam = len(sequence) - mu\n            cycle = sequence[mu:]\n            c = min(cycle)\n            return [mu, lam, c]\n            \n        # Continue sequence generation\n        visited[next_val] = len(sequence)\n        sequence.append(next_val)\n        k += 1\n\ndef analyze_sequence_floyd(n: int) -> list[int]:\n    \"\"\"\n    Analyzes the aliquot sequence starting at n using Floyd's cycle-finding algorithm.\n    This function is implemented to satisfy the problem requirement but is not\n    used to generate the final output. The hash-based method is more direct.\n    \n    Returns:\n        A list [mu, lambda, c].\n    \"\"\"\n    # Handle simple termination cases first\n    if n == 0:\n        return [0, 0, 0] # Terminating\n    val_s = s(n)\n    if val_s == 0:\n        return [1, 0, 0] # n -> 0\n    val_ss = s(val_s)\n    if val_ss == 0:\n        return [2, 0, 0] # n -> s(n) -> 0\n\n    tortoise = val_s\n    hare = val_ss\n    \n    # Phase 1: Find a meeting point or termination\n    while tortoise != hare:\n        tortoise = s(tortoise)\n        hare = s(s(hare))\n        if tortoise == 0 or hare == 0:\n            # Termination found\n            mu = 0\n            curr = n\n            while curr != 0:\n                curr = s(curr)\n                mu += 1\n            return [mu, 0, 0]\n\n    # Phase 2: Cycle found, now find invariants\n    # Find preperiod length (mu)\n    mu = 0\n    ptr1 = n\n    ptr2 = tortoise\n    while ptr1 != ptr2:\n        ptr1 = s(ptr1)\n        ptr2 = s(ptr2)\n        mu += 1\n    \n    # Find cycle length (lambda)\n    lam = 1\n    ptr2 = s(ptr1)\n    cycle_min = ptr1\n    while ptr1 != ptr2:\n        cycle_min = min(cycle_min, ptr2)\n        ptr2 = s(ptr2)\n        lam += 1\n        \n    c = cycle_min\n    \n    return [mu, lam, c]\n\ndef solve():\n    \"\"\"\n    Main function to run the analysis on the test suite and print the output.\n    \"\"\"\n    test_cases = [1, 6, 10, 13, 220, 12496]\n\n    results = []\n    # We use the hash-based method as it's more direct for finding all invariants.\n    # The problem requires implementing both methods; `analyze_sequence_floyd` is also provided.\n    for n in test_cases:\n        mu, lam, c = analyze_sequence_hash(n)\n        results.append(f\"[{mu},{lam},{c}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3080656"}]}