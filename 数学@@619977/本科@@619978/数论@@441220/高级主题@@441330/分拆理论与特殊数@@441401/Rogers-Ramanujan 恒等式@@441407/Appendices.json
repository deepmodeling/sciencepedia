{"hands_on_practices": [{"introduction": "罗杰斯-拉马努金恒等式的一侧（“和侧”）描述了部分之间差异至少为2的分拆。这个抽象的条件可能看起来很棘手，但通过使用费勒图，我们可以将其转化为一个具体的计数问题。这项练习将指导您通过一种巧妙的变换，将这些特殊分拆与更熟悉的数学对象——$q$-二项式系数联系起来，从而为和侧的组合意义建立坚实的直观基础。[@problem_id:3093195]", "problem": "设 $q$ 是一个不定元。一个非负整数 $n$ 的一个分拆是一个非递增的正整数有限序列，其和为 $n$。一个分拆的费勒斯图是通过左对齐的点行来表示的，其中第 $i$ 行的点的数量与第 $i$ 个部分相等。考虑分拆集合 $\\mathcal{R}_{N}$，其中分拆 $\\lambda$ 的连续部分之差满足 $\\lambda_{i} - \\lambda_{i+1} \\ge 2$（对所有适用的索引 $i$），且最大部分满足 $\\lambda_{1} \\le N$。令 $|\\lambda|$ 表示 $\\lambda$ 的各部分之和（即其大小）。定义有限生成多项式\n$$F_{N}(q) = \\sum_{\\lambda \\in \\mathcal{R}_{N}} q^{|\\lambda|}.$$\n从分拆、费勒斯图的基本定义以及生成函数作为加权计数的解释出发，通过移除一个合适的阶梯形状，利用费勒斯图推导出一个对 $\\mathcal{R}_{N}$ 的计数方法，并将 $F_{N}(q)$ 表示为一个关于部分数和标准 $q$-模拟计数多项式的和。然后显式计算当 $N = 1,2,3,4,5,6$ 时的 $F_{N}(q)$，将每个 $F_{N}(q)$ 表示为 $q$ 的多项式。以有序 6 元组 $\\left(F_{1}(q),F_{2}(q),F_{3}(q),F_{4}(q),F_{5}(q),F_{6}(q)\\right)$ 的形式返回你的最终答案。", "solution": "该问题是有效的，因为它科学地植根于整数分拆和生成函数理论，问题提法良好，并使用了客观、无歧义的数学语言。\n\n设 $\\mathcal{R}_{N}$ 为分拆 $\\lambda = (\\lambda_1, \\lambda_2, \\dots, \\lambda_k)$ 的集合，其中各部分是正整数，满足 $\\lambda_1 \\le N$ 且 $\\lambda_i - \\lambda_{i+1} \\ge 2$（对于 $i=1, \\dots, k-1$）。空分拆 $\\lambda=()$ 是 $0$ 的一个分拆，它不证自明地满足条件，其最大部分被认为是 $0$，因此对于任何 $N \\ge 0$ 都有 $0 \\le N$。其各部分之和为 $|\\lambda| = 0$。\n\n生成函数 $F_N(q)$ 定义为 $F_{N}(q) = \\sum_{\\lambda \\in \\mathcal{R}_{N}} q^{|\\lambda|}$。我们可以根据部分数 $k$ 对集合 $\\mathcal{R}_{N}$ 进行划分。设 $\\mathcal{R}_{N,k}$ 是 $\\mathcal{R}_N$ 中恰好有 $k$ 个部分的分拆的子集。生成函数可以写成：\n$$F_N(q) = 1 + \\sum_{k=1}^{\\infty} \\sum_{\\lambda \\in \\mathcal{R}_{N,k}} q^{|\\lambda|}$$\n其中 $1$ 对应于空分拆 ($k=0$）。\n\n问题建议使用费勒斯图并移除一个“阶梯形状”。设 $\\lambda = (\\lambda_1, \\lambda_2, \\dots, \\lambda_k) \\in \\mathcal{R}_{N,k}$。对其各部分的要求是：\n1. $N \\ge \\lambda_1$\n2. $\\lambda_i - \\lambda_{i+1} \\ge 2$ 对于 $i=1, \\dots, k-1$\n3. $\\lambda_k \\ge 1$\n\n我们从 $\\lambda$ 定义一个新的整数序列 $\\mu = (\\mu_1, \\mu_2, \\dots, \\mu_k)$，通过“移除一个阶梯”。从 $\\lambda$ 的费勒斯图中移除的合适阶梯形状是分拆 $(2k-1, 2k-3, \\dots, 3, 1)$，它有 $k$ 个部分，大小为 $k^2$。这对应于变换：\n$$\\mu_i = \\lambda_i - (2(k-i)+1) \\quad \\text{for } i=1, \\dots, k$$\n我们需要验证这个变换将 $\\lambda \\in \\mathcal{R}_{N,k}$ 映射到一个标准分拆 $\\mu$，并且这个映射是一个双射。\n\n首先，我们检查 $\\mu$ 的性质：\n-   条件 $\\lambda_i - \\lambda_{i+1} \\ge 2$ 意味着：\n    $$(\\mu_i + (2k-2i+1)) - (\\mu_{i+1} + (2k-2(i+1)+1)) \\ge 2$$\n    $$\\mu_i - \\mu_{i+1} + (2k-2i+1) - (2k-2i-1) \\ge 2$$\n    $$\\mu_i - \\mu_{i+1} + 2 \\ge 2 \\implies \\mu_i \\ge \\mu_{i+1}$$\n    这表明 $\\mu_1 \\ge \\mu_2 \\ge \\dots \\ge \\mu_k$。\n-   条件 $\\lambda_k \\ge 1$ 意味着：\n    $$\\mu_k + (2(k-k)+1) \\ge 1 \\implies \\mu_k + 1 \\ge 1 \\implies \\mu_k \\ge 0$$\n    所以，$\\mu$ 是一个非负整数的分拆，这意味着它是一个标准的整数分拆，如果某些 $\\mu_i$ 为 $0$，它可能含有少于 $k$ 个正部。\n-   条件 $\\lambda_1 \\le N$ 意味着：\n    $$\\mu_1 + (2(k-1)+1) \\le N \\implies \\mu_1 + 2k - 1 \\le N \\implies \\mu_1 \\le N - 2k + 1$$\n    这个变换是一个双射。对于任何满足 $\\mu_1 \\ge \\dots \\ge \\mu_k \\ge 0$ 和 $\\mu_1 \\le N - 2k + 1$ 的分拆 $\\mu$，我们可以通过设置 $\\lambda_i = \\mu_i + (2(k-i)+1)$ 唯一地恢复出一个分拆 $\\lambda \\in \\mathcal{R}_{N,k}$。\n\n$\\lambda$ 的各部分之和与 $\\mu$ 的各部分之和相关：\n$$|\\lambda| = \\sum_{i=1}^k \\lambda_i = \\sum_{i=1}^k (\\mu_i + 2(k-i)+1) = \\sum_{i=1}^k \\mu_i + \\sum_{i=1}^k (2j-1) \\text{ where } j=k-i+1$$\n第二个和是前 $k$ 个奇数的和，即 $k^2$。因此， $|\\lambda| = |\\mu| + k^2$。\n\n$\\mathcal{R}_{N,k}$ 中分拆的生成函数是：\n$$\\sum_{\\lambda \\in \\mathcal{R}_{N,k}} q^{|\\lambda|} = \\sum_{\\mu} q^{|\\mu| + k^2} = q^{k^2} \\sum_{\\mu} q^{|\\mu|}$$\n求和遍及所有满足以下条件的分拆 $\\mu$：\n1. 部分数最多为 $k$（即其费勒斯图最多有 $k$ 行）。\n2. 最大部分最多为 $N - 2k + 1$（即其费勒斯图最多有 $N - 2k + 1$ 列）。\n\n其费勒斯图可放入 $k \\times m$ 盒子（最多 $k$ 个部分，最大部分最多为 $m$）的分拆的生成函数由 $q$-二项式系数（或高斯多项式）$\\binom{k+m}{k}_q$ 给出。\n这里，$m = N - 2k + 1$。因此 $\\mu$ 的生成函数是 $\\binom{k + (N - 2k + 1)}{k}_q = \\binom{N-k+1}{k}_q$。\n对 $\\mathcal{R}_{N,k}$ 的求和非空，当且仅当可以形成一个分拆。最小的此类分拆是 $(2k-1, 2k-3, \\dots, 1)$，其最大部分为 $\\lambda_1 = 2k-1$。我们必须有 $2k-1 \\le N$，这意味着 $k \\le (N+1)/2$。这与 $q$-二项式系数的性质一致，即如果 $kn$，则 $\\binom{n}{k}_q=0$，因为 $N-k+1  k$ 等价于 $N+1  2k$。\n\n因此，总的生成函数是：\n$$F_N(q) = 1 + \\sum_{k=1}^{\\lfloor(N+1)/2\\rfloor} q^{k^2} \\binom{N-k+1}{k}_q$$\n\n我们现在计算 $N=1, \\dots, 6$ 时的 $F_N(q)$。我们使用公式 $\\binom{n}{k}_q = \\frac{\\prod_{i=1}^n (1-q^i)}{\\left(\\prod_{i=1}^k (1-q^i)\\right)\\left(\\prod_{i=1}^{n-k} (1-q^i)\\right)}$。\n对于 $k=1$, $\\binom{n}{1}_q = \\frac{1-q^n}{1-q} = 1+q+\\dots+q^{n-1}$。对于 $k=n$, $\\binom{n}{n}_q = 1$。\n\n-   **N = 1**: $k \\le 1$。\n    $F_1(q) = 1 + q^{1^2} \\binom{1-1+1}{1}_q = 1 + q \\binom{1}{1}_q = 1 + q(1) = 1+q$。\n\n-   **N = 2**: $k \\le 1.5$，所以 $k=1$。\n    $F_2(q) = 1 + q^{1^2} \\binom{2-1+1}{1}_q = 1 + q \\binom{2}{1}_q = 1 + q(1+q) = 1+q+q^2$。\n\n-   **N = 3**: $k \\le 2$。\n    $F_3(q) = 1 + q^{1^2} \\binom{3-1+1}{1}_q + q^{2^2} \\binom{3-2+1}{2}_q = 1 + q \\binom{3}{1}_q + q^4 \\binom{2}{2}_q = 1 + q(1+q+q^2) + q^4(1) = 1+q+q^2+q^3+q^4$。\n\n-   **N = 4**: $k \\le 2.5$，所以 $k=1, 2$。\n    $F_4(q) = 1 + q \\binom{4}{1}_q + q^4 \\binom{4-2+1}{2}_q = 1 + q \\binom{4}{1}_q + q^4 \\binom{3}{2}_q$。\n    $\\binom{4}{1}_q = 1+q+q^2+q^3$。\n    $\\binom{3}{2}_q = \\binom{3}{1}_q = 1+q+q^2$。\n    $F_4(q) = 1 + q(1+q+q^2+q^3) + q^4(1+q+q^2) = 1 + q+q^2+q^3+q^4 + q^4+q^5+q^6 = 1+q+q^2+q^3+2q^4+q^5+q^6$。\n\n-   **N = 5**: $k \\le 3$。\n    $F_5(q) = 1 + q \\binom{5}{1}_q + q^4 \\binom{5-2+1}{2}_q + q^9 \\binom{5-3+1}{3}_q = 1 + q \\binom{5}{1}_q + q^4 \\binom{4}{2}_q + q^9 \\binom{3}{3}_q$。\n    $\\binom{5}{1}_q = 1+q+q^2+q^3+q^4$。\n    $\\binom{4}{2}_q = \\frac{(1-q^4)(1-q^3)}{(1-q)(1-q^2)} = (1+q^2)(1+q+q^2) = 1+q+2q^2+q^3+q^4$。\n    $\\binom{3}{3}_q = 1$。\n    $F_5(q) = 1 + q(1+q+q^2+q^3+q^4) + q^4(1+q+2q^2+q^3+q^4) + q^9(1) = 1 + (q+q^2+q^3+q^4+q^5) + (q^4+q^5+2q^6+q^7+q^8) + q^9 = 1+q+q^2+q^3+2q^4+2q^5+2q^6+q^7+q^8+q^9$。\n\n-   **N = 6**: $k \\le 3.5$，所以 $k=1, 2, 3$。\n    $F_6(q) = 1 + q\\binom{6}{1}_q + q^4\\binom{6-2+1}{2}_q + q^9\\binom{6-3+1}{3}_q = 1 + q\\binom{6}{1}_q + q^4\\binom{5}{2}_q + q^9\\binom{4}{3}_q$。\n    $\\binom{6}{1}_q = 1+q+q^2+q^3+q^4+q^5$。\n    $\\binom{5}{2}_q = \\frac{(1-q^5)(1-q^4)}{(1-q)(1-q^2)} = (1+q+q^2+q^3+q^4)(1+q^2) = 1+q+2q^2+2q^3+2q^4+q^5+q^6$。\n    $\\binom{4}{3}_q = \\binom{4}{1}_q = 1+q+q^2+q^3$。\n    $F_6(q) = 1 + q(1+q+q^2+q^3+q^4+q^5) + q^4(1+q+2q^2+2q^3+2q^4+q^5+q^6) + q^9(1+q+q^2+q^3)$。\n    $F_6(q) = 1 + (q+q^2+q^3+q^4+q^5+q^6) + (q^4+q^5+2q^6+2q^7+2q^8+q^9+q^{10}) + (q^9+q^{10}+q^{11}+q^{12})$。\n    $F_6(q) = 1+q+q^2+q^3+2q^4+2q^5+3q^6+2q^7+2q^8+2q^9+2q^{10}+q^{11}+q^{12}$。\n\n多项式的 6 元组是：\n1. $F_1(q) = 1+q$\n2. $F_2(q) = 1+q+q^2$\n3. $F_3(q) = 1+q+q^2+q^3+q^4$\n4. $F_4(q) = 1+q+q^2+q^3+2q^4+q^5+q^6$\n5. $F_5(q) = 1+q+q^2+q^3+2q^4+2q^5+2q^6+q^7+q^8+q^9$\n6. $F_6(q) = 1+q+q^2+q^3+2q^4+2q^5+3q^6+2q^7+2q^8+2q^9+2q^{10}+q^{11}+q^{12}$", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n1+q,  1+q+q^2,  1+q+q^2+q^3+q^4,  1+q+q^2+q^3+2q^4+q^5+q^6,  1+q+q^2+q^3+2q^4+2q^5+2q^6+q^7+q^8+q^9,  1+q+q^2+q^3+2q^4+2q^5+3q^6+2q^7+2q^8+2q^9+2q^{10}+q^{11}+q^{12}\n\\end{pmatrix}\n}\n$$", "id": "3093195"}, {"introduction": "与和侧的组合条件相对应，罗杰斯-拉马努金恒等式的另一侧（“积侧”）描述了由特定模类（例如，模5余1或4）的部分构成的分拆。这个练习将向您展示一种强大的分析技术——对数微分法，来从积式定义中提取其幂级数展开的系数。您将推导出一个递推关系，从而揭示了如何从其看似复杂的无限积形式中系统地计算这些分拆数的奥秘。[@problem_id:3093197]", "problem": "设 $q$ 为一不定元，Rogers–Ramanujan 函数 $R(q)$ 由以下无穷乘积定义\n$$\nR(q) \\;=\\; \\frac{1}{(q;q^{5})_{\\infty}\\,(q^{4};q^{5})_{\\infty}},\n$$\n其中 $q$-Pochhammer 符号为 $(a;q)_{\\infty} \\coloneqq \\prod_{n=0}^{\\infty} (1 - a\\,q^{n})$。根据 Rogers–Ramanujan 恒等式，此 $R(q)$ 也等于级数 $\\sum_{n=0}^{\\infty} \\frac{q^{n^{2}}}{(q;q)_{n}}$，但对于本题，你可以将无穷乘积形式作为出发点。\n\n记\n$$\nR(q) \\;=\\; \\sum_{n=0}^{\\infty} a_{n}\\,q^{n},\n$$\n并将其视为一个 $a_{0}\\neq 0$ 的形式幂级数。\n\n仅从给定的无穷乘积定义以及形式幂级数和对数微分法的基本性质出发，完成以下任务：\n\n1) 为 $q\\,\\frac{R'(q)}{R(q)}$ 推导一个函数方程，并用它来推导一个递推关系，该关系能用先前的系数确定系数 $a_{n}$。你的递推关系必须用由模 $5$ 的剩余类决定的算术数据明确表示。\n\n2) 使用你的递推关系精确计算前五个系数 $a_{0},a_{1},a_{2},a_{3},a_{4}$。\n\n你的最终答案必须仅包含这五个按顺序排列的系数，以单行矩阵的形式呈现。无需四舍五入。", "solution": "该问题要求完成与 Rogers-Ramanujan 函数 $R(q)$ 相关的两个主要任务，该函数由无穷乘积 $R(q) = \\frac{1}{(q;q^{5})_{\\infty}\\,(q^{4};q^{5})_{\\infty}}$ 定义。我们需要处理其形式幂级数表示 $R(q) = \\sum_{n=0}^{\\infty} a_{n}\\,q^{n}$。\n\n首先，我们验证问题陈述的有效性。Rogers-Ramanujan 函数和 $q$-Pochhammer 符号的定义在整数分拆理论和 $q$-级数理论中是标准的。这些任务涉及标准的数学技巧，如对数微分法和形式幂级数的处理。该问题是自洽的，在数论中有科学依据，并且是良定的。因此，问题是有效的，我们可以着手求解。\n\n**第1部分：推导递推关系**\n\n函数 $R(q)$ 由下式给出：\n$$\nR(q) = \\frac{1}{(q;q^{5})_{\\infty}\\,(q^{4};q^{5})_{\\infty}}\n$$\n使用 $q$-Pochhammer 符号的定义 $(a;q)_{\\infty} = \\prod_{k=0}^{\\infty} (1 - a\\,q^{k})$，我们可以展开分母：\n$$\nR(q) = \\frac{1}{\\left(\\prod_{k=0}^{\\infty} (1 - q \\cdot (q^5)^k)\\right) \\left(\\prod_{k=0}^{\\infty} (1 - q^4 \\cdot (q^5)^k)\\right)} = \\frac{1}{\\prod_{k=0}^{\\infty} (1 - q^{5k+1}) (1 - q^{5k+4})}\n$$\n为了求对数导数，我们取 $R(q)$ 的自然对数：\n$$\n\\ln R(q) = \\ln \\left( \\left(\\prod_{k=0}^{\\infty} (1 - q^{5k+1}) (1 - q^{5k+4})\\right)^{-1} \\right) = - \\sum_{k=0}^{\\infty} \\left[\\ln(1 - q^{5k+1}) + \\ln(1 - q^{5k+4})\\right]\n$$\n对 $q$ 求导，我们得到 $\\frac{R'(q)}{R(q)} = \\frac{d}{dq} \\ln R(q)$：\n$$\n\\frac{R'(q)}{R(q)} = - \\sum_{k=0}^{\\infty} \\left[ \\frac{-(5k+1)q^{5k}}{1 - q^{5k+1}} + \\frac{-(5k+4)q^{5k+3}}{1 - q^{5k+4}} \\right] = \\sum_{k=0}^{\\infty} \\left[ \\frac{(5k+1)q^{5k}}{1 - q^{5k+1}} + \\frac{(5k+4)q^{5k+3}}{1 - q^{5k+4}} \\right]\n$$\n问题要求一个关于 $q\\,\\frac{R'(q)}{R(q)}$ 的函数方程。两边乘以 $q$：\n$$\nq\\,\\frac{R'(q)}{R(q)} = \\sum_{k=0}^{\\infty} \\left[ \\frac{(5k+1)q^{5k+1}}{1 - q^{5k+1}} + \\frac{(5k+4)q^{5k+4}}{1 - q^{5k+4}} \\right]\n$$\n为了推导递推关系，我们将此表达式展开为幂级数。使用几何级数展开式 $\\frac{x}{1-x} = \\sum_{j=1}^{\\infty} x^j$（对形式幂级数成立）：\n$$\nq\\,\\frac{R'(q)}{R(q)} = \\sum_{k=0}^{\\infty} (5k+1) \\sum_{j=1}^{\\infty} (q^{5k+1})^j + \\sum_{k=0}^{\\infty} (5k+4) \\sum_{j=1}^{\\infty} (q^{5k+4})^j\n$$\n$$\nq\\,\\frac{R'(q)}{R(q)} = \\sum_{k=0}^{\\infty}\\sum_{j=1}^{\\infty} (5k+1)q^{j(5k+1)} + \\sum_{k=0}^{\\infty}\\sum_{j=1}^{\\infty} (5k+4)q^{j(5k+4)}\n$$\n设此级数为 $C(q) = \\sum_{m=1}^{\\infty} c_m q^m$。系数 $c_m$ 是对 $q^m$ 次幂的各项贡献之和。如果 $m = j(5k+1)$，则项 $(5k+1)q^{j(5k+1)}$ 对 $q^m$ 的系数贡献 $5k+1$。这意味着 $d = 5k+1$ 是 $m$ 的一个因数。这样的因数满足 $d \\equiv 1 \\pmod 5$。类似地，如果 $d = 5k+4$ 是 $m$ 的一个因数，则项 $(5k+4)q^{j(5k+4)}$ 贡献 $5k+4$。这样的因数满足 $d \\equiv 4 \\pmod 5$。\n因此，系数 $c_m$ 是 $m$ 的所有模 5 同余于 1 或 4 的因数之和：\n$$\nc_m = \\sum_{d|m, \\, d \\equiv 1 \\pmod 5} d + \\sum_{d|m, \\, d \\equiv 4 \\pmod 5} d\n$$\n我们有恒等式 $q R'(q) = R(q) C(q)$。代入 $R(q)$ 和 $C(q)$ 的幂级数：\n$$\nq \\frac{d}{dq} \\left(\\sum_{n=0}^{\\infty} a_n q^n\\right) = \\left(\\sum_{k=0}^{\\infty} a_k q^k\\right) \\left(\\sum_{m=1}^{\\infty} c_m q^m\\right)\n$$\n左边变为：\n$$\nq \\sum_{n=1}^{\\infty} n a_n q^{n-1} = \\sum_{n=1}^{\\infty} n a_n q^n\n$$\n右边是一个柯西乘积。$q^n$ 的系数是 $\\sum_{k=0}^{n-1} a_k c_{n-k}$。\n通过令 $n \\ge 1$ 时 $q^n$ 的系数相等，我们得到递推关系：\n$$\nn a_n = \\sum_{k=0}^{n-1} a_k c_{n-k}\n$$\n这个关系式用先前的系数 $a_0, \\dots, a_{n-1}$ 和值 $c_j$ 来确定 $a_n$（对于 $n \\ge 1$），这些 $c_j$ 就是所要求的算术数据。\n\n**第2部分：计算前五个系数**\n\n首先，我们求 $a_0 = R(0)$。根据无穷乘积定义，令 $q=0$ 可得其分母为 1。\n$$\na_0 = R(0) = 1\n$$\n接下来，我们计算所需的 $c_m$ 值：\n- $c_1$：1 的因数是 $\\{1\\}$。$1 \\equiv 1 \\pmod 5$。所以，$c_1 = 1$。\n- $c_2$：2 的因数是 $\\{1, 2\\}$。$1 \\equiv 1 \\pmod 5$，$2 \\equiv 2 \\pmod 5$。所以，$c_2 = 1$。\n- $c_3$：3 的因数是 $\\{1, 3\\}$。$1 \\equiv 1 \\pmod 5$，$3 \\equiv 3 \\pmod 5$。所以，$c_3 = 1$。\n- $c_4$：4 的因数是 $\\{1, 2, 4\\}$。$1 \\equiv 1 \\pmod 5$，$2 \\equiv 2 \\pmod 5$，$4 \\equiv 4 \\pmod 5$。所以，$c_4 = 1+4 = 5$。\n\n现在我们对 $n=1, 2, 3, 4$ 应用递推关系 $n a_n = \\sum_{k=0}^{n-1} a_k c_{n-k}$。\n\n- 对于 $n=1$：\n$$\n1 \\cdot a_1 = a_0 c_1 = 1 \\cdot 1 = 1 \\implies a_1 = 1\n$$\n- 对于 $n=2$：\n$$\n2 \\cdot a_2 = a_0 c_2 + a_1 c_1 = 1 \\cdot 1 + 1 \\cdot 1 = 2 \\implies a_2 = 1\n$$\n- 对于 $n=3$：\n$$\n3 \\cdot a_3 = a_0 c_3 + a_1 c_2 + a_2 c_1 = 1 \\cdot 1 + 1 \\cdot 1 + 1 \\cdot 1 = 3 \\implies a_3 = 1\n$$\n- 对于 $n=4$：\n$$\n4 \\cdot a_4 = a_0 c_4 + a_1 c_3 + a_2 c_2 + a_3 c_1 = 1 \\cdot 5 + 1 \\cdot 1 + 1 \\cdot 1 + 1 \\cdot 1 = 8 \\implies a_4 = 2\n$$\n前五个系数是 $a_0=1$, $a_1=1$, $a_2=1$, $a_3=1$ 和 $a_4=2$。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n1  1  1  1  2\n\\end{pmatrix}\n}\n$$", "id": "3093197"}, {"introduction": "理论理解最终需要通过计算来验证和加深。这项练习是前两个练习的综合与升华，要求您将恒等式两边的组合描述转化为具体的计算机算法。您将为积侧（一个经典的“换硬币”问题）和和侧分别设计动态规划算法，并编程实现它们来计算系数。通过运行代码并验证两边结果的一致性，您将亲手完成对这些深刻恒等式的计算验证。[@problem_id:3093186]", "problem": "设 $q$ 为一个形式变量，令 $(a;q)_n$ 表示 $q$-Pochhammer 符号，其定义为 $(a;q)_0=1$ 且对于任意整数 $n\\ge 1$，$(a;q)_n=\\prod_{k=0}^{n-1}(1-aq^k)$。考虑整数分拆，其中非负整数 $n$ 的一个分拆是指一族总和为 $n$ 的正整数构成的有限多重集。对于分拆块大小取自子集 $S\\subseteq \\mathbb{Z}_{\\ge 1}$ 的分拆，其生成函数为形式幂级数 $\\prod_{s\\in S}\\frac{1}{1-q^s}$，其中 $q^n$ 的系数等于将 $n$ 写成 $S$ 中元素的和（可无限重复，不计顺序）的方式数。\n\n定义两种分拆族：\n- 对于第一族，允许的分拆块大小为所有模 $5$ 同余于 $1$ 或 $4$ 的正整数，即 $S_1=\\{s\\in \\mathbb{Z}_{\\ge 1} : s\\equiv 1 \\text{ or } 4 \\pmod{5}\\}$。\n- 对于第二族，允许的分拆块大小为所有模 $5$ 同余于 $2$ 或 $3$ 的正整数，即 $S_2=\\{s\\in \\mathbb{Z}_{\\ge 1} : s\\equiv 2 \\text{ or } 3 \\pmod{5}\\}$。\n\n另外，独立地考虑由以下稳定截断的和式定义的两个形式幂级数：\n- $S_1^{\\text{sum}}(q)=\\sum_{m\\ge 0} \\dfrac{q^{m^2}}{(q;q)_m}$，\n- $S_2^{\\text{sum}}(q)=\\sum_{m\\ge 0} \\dfrac{q^{m(m+1)}}{(q;q)_m}$，\n其中 $(q;q)_m=\\prod_{k=1}^{m}(1-q^k)$，其倒数 $\\dfrac{1}{(q;q)_m}$ 被解释为分拆块大小为 $1$ 到 $m$ 的整数（可无限重复）的分拆的生成函数。\n\n你的任务是设计并实现一个动态规划算法，该算法在给定一个非负整数 $N$ 的情况下，计算乘积侧分拆族（分别基于 $S_1$ 和 $S_2$）的系数数组 $\\{P_1(n)\\}_{n=0}^N$ 和 $\\{P_2(n)\\}_{n=0}^N$，并计算求和侧级数 $S_1^{\\text{sum}}(q)$ 和 $S_2^{\\text{sum}}(q)$ 最高到 $N$ 次的系数数组 $\\{A_1(n)\\}_{n=0}^N$ 和 $\\{A_2(n)\\}_{n=0}^N$。\n\n算法要求：\n- 对于乘积侧数组，使用无界硬币找零动态规划递推式计算 $\\{P_1(n)\\}_{n=0}^N$ 和 $\\{P_2(n)\\}_{n=0}^N$，其中允许的分拆块大小被限制在集合 $S_1$ 和 $S_2$ 与 $\\{1,2,\\dots,N\\}$ 的交集中。\n- 对于求和侧数组，通过对 $m$ 进行动态规划，增量地构建所需的所有 $m$ 值的 $\\dfrac{1}{(q;q)_m}$ 的系数至次数 $N$。然后，通过对所有满足 $m^2\\le N$ 的整数 $m$，将与 $q^{m^2}\\dfrac{1}{(q;q)_m}$ 对应的移位数组求和，来构成 $\\{A_1(n)\\}_{n=0}^N$；并通过对所有满足 $m(m+1)\\le N$ 的整数 $m$，将与 $q^{m(m+1)}\\dfrac{1}{(q;q)_m}$ 对应的移位数组求和，来构成 $\\{A_2(n)\\}_{n=0}^N$。\n- 分析两种方法关于 $N$ 的渐近时间复杂度，并说明其对允许的分拆块数量的依赖关系。\n\n验证要求：\n- 对于每个测试值 $N$，验证等式 $P_1(n)=A_1(n)$ 和 $P_2(n)=A_2(n)$ 对所有满足 $0\\le n\\le N$ 的整数 $n$ 成立，并将此验证结果以布尔值的形式报告。\n\n测试套件：\n- 使用以下测试值 $N$：$N\\in\\{0,1,12,25,60\\}$。\n- 这些测试用例涵盖了一个平凡边界情况（$N=0$）、最小的非平凡情况（$N=1$）、一个小型通用情况（$N=12$）、一个中等情况（$N=25$）以及一个对两种算法都有压力的大型情况（$N=60$）。\n\n最终输出格式：\n- 你的程序应生成一行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。对于每个测试用例 $N$，输出列表 $[b_1,b_2]$，其中 $b_1$ 是确认 $P_1(n)=A_1(n)$ 对所有 $0\\le n\\le N$ 成立的布尔值，$b_2$ 是确认 $P_2(n)=A_2(n)$ 对所有 $0\\le n\\le N$ 成立的布尔值。因此，最后一行应类似于 $[[b_{1,1},b_{1,2}],[b_{2,1},b_{2,2}],\\dots]$。[@problem_id:483]", "solution": "该问题要求对两个 Rogers-Ramanujan 恒等式在给定整数范围内进行计算验证。这两个恒等式将两个特定的以变量 $q$ 表示的形式幂级数的无穷求和表示与无穷乘积表示联系起来。\n\n第一个恒等式是：\n$$\n\\sum_{m=0}^{\\infty} \\frac{q^{m^2}}{(q;q)_m} = \\prod_{k=0}^{\\infty} \\frac{1}{(1-q^{5k+1})(1-q^{5k+4})}\n$$\n第二个恒等式是：\n$$\n\\sum_{m=0}^{\\infty} \\frac{q^{m(m+1)}}{(q;q)_m} = \\prod_{k=0}^{\\infty} \\frac{1}{(1-q^{5k+2})(1-q^{5k+3})}\n$$\n\n这里，$(q;q)_m = \\prod_{k=1}^{m}(1-q^k)$ 是当 $a=q$ 时的 $q$-Pochhammer 符号。等式左边是“求和侧”，右边是“乘积侧”。\n\n用整数分拆的语言来说，乘积侧生成函数 $\\prod_{s \\in S} \\frac{1}{1-q^s}$ 中 $q^n$ 的系数，计算了将整数 $n$ 分拆成取自集合 $S$ 的块的方案数。\n因此，第一个恒等式表明，将 $n$ 分拆为模 $5$ 同余于 $1$ 或 $4$（集合 $S_1$）的块的方案数，等于将 $n$ 分拆为任意两块之差至少为 $2$ 的块的方案数。求和侧生成函数对应这第二个条件。\n第二个恒等式表明，将 $n$ 分拆为模 $5$ 同余于 $2$ 或 $3$（集合 $S_2$）的块的方案数，等于将 $n$ 分拆为大于 $1$ 且任意两块之差至少为 $2$ 的块的方案数。\n\n任务是使用两种不同的动态规划算法——一种用于乘积侧表示（$P_1(n)$、$P_2(n)$），另一种用于求和侧表示（$A_1(n)$、$A_2(n)$）——来计算这些级数的系数数组（最高到 $N$ 次），然后验证它们对于所有 $n \\in \\{0, 1, \\dots, N\\}$ 都相等。\n\n**算法 1：乘积侧系数计算**\n\n为了计算系数 $\\{P_1(n)\\}_{n=0}^N$ 和 $\\{P_2(n)\\}_{n=0}^N$，我们将此问题解释为无界背包问题或硬币找零问题的一个变种。使用来自集合 $S$ 的块对整数 $n$ 进行分拆的方案数，记作 $p_S(n)$，是 $\\prod_{s\\in S} \\frac{1}{1-q^s}$ 中 $q^n$ 的系数。我们可以使用动态规划来计算。\n\n设 $dp[i]$ 为使用一组给定大小的块对整数 $i$ 进行分拆的方案数。我们初始化 $dp[0] = 1$ 和 $dp[i] = 0$（对于 $i  0$）。然后我们遍历每个允许的分拆块大小 $s \\in S$（最大到 $N$），并根据递推关系更新 $dp$ 表：\n$dp_{new}[i] = dp_{old}[i] + dp_{new}[i-s]$。\n这可以通过对每个分拆块大小 $s$ 进行原地更新来实现：\n对于每个 $s \\in S \\cap \\{1, \\dots, N\\}$：\n  对于 $n$ 从 $s$ 到 $N$：\n    $dp[n] \\leftarrow dp[n] + dp[n-s]$\n\n这个过程应用两次：\n1.  对于 $\\{P_1(n)\\}_{n=0}^N$，分拆块的集合是 $S_1 = \\{s \\in \\mathbb{Z}_{\\ge 1} : s \\equiv 1 \\text{ or } 4 \\pmod{5}, s \\le N\\}$。\n2.  对于 $\\{P_2(n)\\}_{n=0}^N$，分拆块的集合是 $S_2 = \\{s \\in \\mathbb{Z}_{\\ge 1} : s \\equiv 2 \\text{ or } 3 \\pmod{5}, s \\le N\\}$。\n\n**复杂度分析（乘积侧）：** 该算法涉及一个外层循环，遍历允许的分拆块大小集合，设为 $S_N = S \\cap \\{1, \\dots, N\\}$，以及一个从 $s$ 运行到 $N$ 的内层循环。在 $S_1$ 或 $S_2$ 中，不大于 $N$ 的分拆块数量为 $|S_{i,N}| \\approx \\frac{2}{5}N$。总操作数大约为 $\\sum_{s \\in S_N} (N-s) \\approx \\int_0^N (N-x) \\frac{|S_N|}{N} dx$，这与 $N^2$ 成正比。因此，时间复杂度为 $\\mathcal{O}(|S_N| \\cdot N)$，对于给定的集合 $S_1$ 和 $S_2$，即为 $\\mathcal{O}(N^2)$。\n\n**算法 2：求和侧系数计算**\n\n为了计算系数 $\\{A_1(n)\\}_{n=0}^N$ 和 $\\{A_2(n)\\}_{n=0}^N$，我们必须计算和式 $S_1^{\\text{sum}}(q) = \\sum_{m\\ge 0} \\frac{q^{m^2}}{(q;q)_m}$ 和 $S_2^{\\text{sum}}(q) = \\sum_{m\\ge 0} \\frac{q^{m(m+1)}}{(q;q)_m}$ 最高到 $N$ 次的系数。当分子中 $q$ 的指数 $m^2$ 或 $m(m+1)$ 超过 $N$ 时，可以截断求和。这意味着求和进行到 $m \\approx \\sqrt{N}$。\n\n该算法主要分两个阶段进行：\n1.  **计算 $D_m(q) = 1/(q;q)_m$ 的系数**：我们增量地计算 $D_m(q)$ 的系数。我们从 $D_0(q)=1$ 开始，其系数数组为 $[1, 0, \\dots]$。然后，对于 $m \\ge 1$，我们使用关系式 $D_m(q) = D_{m-1}(q) \\cdot \\frac{1}{1-q^m}$。如果 $d_{k,n}$ 是 $D_k(q)$ 中 $q^n$ 的系数，则系数 $d_{m,n}$ 可以通过递推式 $d_{m,n} = d_{m-1,n} + d_{m,n-m}$ 从 $d_{m-1,n}$ 计算得出。这可以实现为对每个 $m$ 的系数数组进行原地更新。\n\n2.  **对级数项求和**：我们将结果数组 $\\{A_1(n)\\}$、$\\{A_2(n)\\}$ 初始化为零。我们从 $m=0$ 向上循环。在每次迭代 $m$ 中，我们首先如上所述计算 $D_m(q)$ 的系数数组。然后，我们将第 $m$ 项的贡献加到总和中：\n    - 对于 $A_1$，我们将 $D_m(q)$ 的系数加到数组 $A_1$ 中，索引偏移 $m^2$。这对应于将 $D_m(q)$ 乘以 $q^{m^2}$。\n    - 对于 $A_2$，我们将 $D_m(q)$ 的系数加到数组 $A_2$ 中，索引偏移 $m(m+1)$。\n    - 当 $m^2  N$ 时，对 $m$ 的循环终止，因为更高阶的项不会对次数最高为 $N$ 的系数产生贡献。\n\n**复杂度分析（求和侧）：** 主循环从 $m=1$ 迭代到最大值 $M \\approx \\sqrt{N}$。在循环内部，更新 $D_m(q)$ 的系数数组需要 $\\mathcal{O}(N)$ 的时间。将移位后的系数加到 $A_1$ 和 $A_2$ 也需要 $\\mathcal{O}(N)$ 的时间。因此，总时间复杂度为 $\\mathcal{O}(M \\cdot N) = \\mathcal{O}(N\\sqrt{N})$。\n\n**验证**\n对于每个测试用例 $N$，在计算完四个系数数组 $\\{P_1(n)\\}$、$\\{P_2(n)\\}$、$\\{A_1(n)\\}$ 和 $\\{A_2(n)\\}$（最高到 $N$ 次）后，我们进行直接的逐元素比较。生成两个布尔值：一个用于确认 $P_1(n) = A_1(n)$ 对所有 $n \\in \\{0, \\dots, N\\}$ 成立，另一个用于确认 $P_2(n) = A_2(n)$ 对所有 $n \\in \\{0, \\dots, N\\}$ 成立。由于 Rogers-Ramanujan 恒等式是已证明的定理，这些等式必然成立。", "answer": "```python\nimport numpy as np\n\ndef compute_product_side(N):\n    \"\"\"\n    Computes coefficients for the product-side generating functions using dynamic programming.\n    This is equivalent to the unbounded coin change problem.\n    Time complexity: O(N^2)\n    \"\"\"\n    if N  0:\n        return [], []\n\n    # For P1: partitions with parts congruent to 1 or 4 (mod 5)\n    S1_parts = [s for s in range(1, N + 1) if s % 5 == 1 or s % 5 == 4]\n    P1 = [0] * (N + 1)\n    P1[0] = 1\n    for s in S1_parts:\n        for n in range(s, N + 1):\n            P1[n] += P1[n - s]\n\n    # For P2: partitions with parts congruent to 2 or 3 (mod 5)\n    S2_parts = [s for s in range(1, N + 1) if s % 5 == 2 or s % 5 == 3]\n    P2 = [0] * (N + 1)\n    P2[0] = 1\n    for s in S2_parts:\n        for n in range(s, N + 1):\n            P2[n] += P2[n - s]\n\n    return P1, P2\n\ndef compute_sum_side(N):\n    \"\"\"\n    Computes coefficients for the sum-side series using dynamic programming.\n    Time complexity: O(N*sqrt(N))\n    \"\"\"\n    if N  0:\n        return [], []\n    \n    A1 = [0] * (N + 1)\n    A2 = [0] * (N + 1)\n    \n    # The sums start from m=0. The term for m=0 is q^0/(q;q)_0 = 1 for both series.\n    if N >= 0:\n        A1[0] = 1\n        A2[0] = 1\n\n    # D_coeffs stores coefficients of 1/(q;q)_m.\n    # We initialize it for m=0, where 1/(q;q)_0 = 1.\n    D_coeffs = [0] * (N + 1)\n    D_coeffs[0] = 1\n    \n    m = 1\n    while True:\n        m_squared = m * m\n        # If m^2 > N, no higher-m terms can contribute to coefficients = N.\n        if m_squared > N:\n            break\n\n        # Update D_coeffs from representing 1/(q;q)_{m-1} to 1/(q;q)_m.\n        # This is done by multiplying by 1/(1-q^m), which corresponds to the\n        # recurrence d_m[n] = d_{m-1}[n] + d_m[n-m].\n        # The inner loop performs this update in-place.\n        if m = N:\n            for n in range(m, N + 1):\n                D_coeffs[n] += D_coeffs[n - m]\n        \n        # Now D_coeffs contains coefficients for 1/(q;q)_m.\n        \n        # Add contribution to A1: q^(m^2) * [1/(q;q)_m]\n        for n in range(m_squared, N + 1):\n            A1[n] += D_coeffs[n - m_squared]\n        \n        # Add contribution to A2: q^(m(m+1)) * [1/(q;q)_m]\n        m_m_p1 = m * (m + 1)\n        if m_m_p1 = N:\n            for n in range(m_m_p1, N + 1):\n                A2[n] += D_coeffs[n - m_m_p1]\n\n        m += 1\n            \n    return A1, A2\n\ndef solve():\n    \"\"\"\n    Main solver function to run verification for all test cases.\n    \"\"\"\n    test_cases = [0, 1, 12, 25, 60]\n\n    results = []\n    for N in test_cases:\n        # Compute coefficients using both methods\n        P1, P2 = compute_product_side(N)\n        A1, A2 = compute_sum_side(N)\n\n        # Verify that the resulting coefficient arrays are identical\n        # np.array_equal is efficient for this comparison.\n        b1 = np.array_equal(P1, A1)\n        b2 = np.array_equal(P2, A2)\n        \n        results.append([b1, b2])\n\n    # Format the final output as specified in the problem statement.\n    # Example: [[True,True],[True,True]]\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3093186"}]}