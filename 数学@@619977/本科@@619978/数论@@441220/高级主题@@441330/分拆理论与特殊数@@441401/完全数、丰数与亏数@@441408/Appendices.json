{"hands_on_practices": [{"introduction": "理解新数学定义的最佳方式是通过直接应用。第一个练习将引导你通过基本计算来检验数字的分类，即亲自动手计算一些整数的约数和，并判断它们是属于完美数、丰数还是亏数。这个过程将通过直接计算来巩固核心概念。[@problem_id:3087989]", "problem": "设 $\\sigma(n)$ 表示正整数 $n$ 的所有正因数之和，丰度指数 $I(n)$ 定义为 $I(n) = \\frac{\\sigma(n)}{n}$。如果 $\\sigma(n) = 2n$，则称正整数 $n$ 为完美数；如果 $\\sigma(n)  2n$，则为过剩数；如果 $\\sigma(n)  2n$，则为亏数。仅从这些定义出发（并且不使用任何超出可以从这些定义逻辑推导出的预设公式），计算 $\\sigma(28)$ 并用它来验证 $28$ 是否是完美数。然后计算丰度指数 $I(18)$ 和 $I(27)$，并通过将每个指数与 $2$ 比较，将 $18$ 和 $27$ 分类为过剩数或亏数。以精确形式（整数或分数）表示所有计算出的量。以单行矩阵 $\\big(\\sigma(28),\\, I(18),\\, I(27)\\big)$ 的形式提供您的最终答案。不需要四舍五入。", "solution": "问题要求计算特定整数的因数和函数 $\\sigma(n)$ 和丰度指数 $I(n)$，并将这些整数分类为完美数、过剩数或亏数。分析将严格基于所提供的定义进行。\n\n首先，我们处理整数 $n=28$。函数 $\\sigma(n)$ 定义为 $n$ 的所有正因数之和。为了计算 $\\sigma(28)$，我们必须首先确定 $28$ 的所有正因数。这些因数是 $1, 2, 4, 7, 14,$ 和 $28$。\n这些因数的和是：\n$$\n\\sigma(28) = 1 + 2 + 4 + 7 + 14 + 28\n$$\n将这些值相加，我们得到：\n$$\n\\sigma(28) = 56\n$$\n一个数 $n$ 被定义为完美数，如果 $\\sigma(n) = 2n$。为验证 $28$ 是否为完美数，我们将 $\\sigma(28)$ 与 $2 \\times 28$ 进行比较。\n$$\n2 \\times 28 = 56\n$$\n由于 $\\sigma(28) = 56$，我们确认了 $\\sigma(28) = 2 \\times 28$。因此，整数 $28$ 是一个完美数。第一个要求的量是 $\\sigma(28) = 56$。\n\n接下来，我们分析整数 $n=18$。我们必须计算其丰度指数 $I(18) = \\frac{\\sigma(18)}{18}$。首先，我们找到 $18$ 的正因数。这些因数是 $1, 2, 3, 6, 9,$ 和 $18$。\n这些因数的和是：\n$$\n\\sigma(18) = 1 + 2 + 3 + 6 + 9 + 18\n$$\n将这些值相加，我们得到：\n$$\n\\sigma(18) = 39\n$$\n现在，我们计算丰度指数 $I(18)$:\n$$\nI(18) = \\frac{\\sigma(18)}{18} = \\frac{39}{18}\n$$\n这个分数可以通过将分子和分母除以它们的最大公约数 $3$ 来化简：\n$$\nI(18) = \\frac{39 \\div 3}{18 \\div 3} = \\frac{13}{6}\n$$\n为了将 $18$ 分类为过剩数或亏数，我们将其丰度指数与 $2$ 进行比较。如果 $I(n)  2$，数 $n$ 是过剩数；如果 $I(n)  2$，数 $n$ 是亏数。\n我们将 $I(18) = \\frac{13}{6}$ 与 $2$ 进行比较：\n$$\n\\frac{13}{6} \\approx 2.166...\n$$\n由于 $\\frac{13}{6}  2$ （因为 $13  6 \\times 2=12$），整数 $18$ 被分类为过剩数。第二个要求的量是 $I(18) = \\frac{13}{6}$。\n\n最后，我们分析整数 $n=27$。我们计算其丰度指数 $I(27) = \\frac{\\sigma(27)}{27}$。首先，我们找到 $27$ 的正因数。这些因数是 $1, 3, 9,$ 和 $27$。\n这些因数的和是：\n$$\n\\sigma(27) = 1 + 3 + 9 + 27\n$$\n将这些值相加，我们得到：\n$$\n\\sigma(27) = 40\n$$\n现在，我们计算丰度指数 $I(27)$:\n$$\nI(27) = \\frac{\\sigma(27)}{27} = \\frac{40}{27}\n$$\n这个分数是最简形式，因为 $40$ 的素因数分解是 $2^3 \\times 5$，$27$ 的素因数分解是 $3^3$，所以它们没有共同的素因数。\n为了对 $27$ 进行分类，我们将其丰度指数与 $2$ 进行比较：\n$$\n\\frac{40}{27} \\approx 1.481...\n$$\n由于 $\\frac{40}{27}  2$ （因为 $40  27 \\times 2=54$），整数 $27$ 被分类为亏数。第三个要求的量是 $I(27) = \\frac{40}{27}$。\n\n问题要求最终答案是一个包含 $\\sigma(28)$、$I(18)$ 和 $I(27)$ 计算值的单行矩阵。这些值分别为 $56$、$\\frac{13}{6}$ 和 $\\frac{40}{27}$。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n56 \\quad \\frac{13}{6} \\quad \\frac{40}{27}\n\\end{pmatrix}\n}\n$$", "id": "3087989"}, {"introduction": "在练习了手动计算之后，我们可以探索更高效的方法。本练习将介绍约数和函数 $\\sigma(n)$ 的一个强大性质——积性，它可以极大地简化对大数的计算。更重要的是，本练习通过一个反例，突显了该性质的适用边界，即它仅适用于互质的因子，从而帮助你建立更深刻、更严谨的理解。[@problem_id:3088008]", "problem": "设 $n \\mapsto \\sigma(n)$ 表示正整数 $n$ 的所有正因数之和，并定义丰度指数 $I(n)$ 为 $I(n) := \\frac{\\sigma(n)}{n}$。如果一个正整数 $n$ 满足 $I(n)  2$，则称其为丰数。一个经过充分验证的事实是，$\\sigma$ 函数对于互质的参数是积性函数：如果 $\\gcd(m,n)=1$，那么 $\\sigma(mn) = \\sigma(m)\\sigma(n)$，因此当 $\\gcd(m,n)=1$ 时，有 $I(mn) = I(m) I(n)$。然而，当因子含有共同的素因数时，该关系不一定成立。\n\n考虑丰数且无平方因子整数 $a = 30$。仅使用上述基本定义和 $\\sigma$ 函数对互质参数的积性性质，计算精确差值\n$$\\Delta := I(a^{2}) - I(a)\\,I(a).$$\n请将最终答案表示为一个最简分数。无需四舍五入。", "solution": "目标是计算整数 $a = 30$ 的精确差值 $\\Delta := I(a^{2}) - I(a)\\,I(a)$。丰度指数定义为 $I(n) := \\frac{\\sigma(n)}{n}$，其中 $\\sigma(n)$ 是 $n$ 的所有正因数之和。\n\n首先，我们计算 $a=30$ 时 $I(a)$ 的值。$a$ 的素因数分解为 $a = 30 = 2 \\times 3 \\times 5$。由于素因数 $2$、$3$ 和 $5$ 两两互质，我们可以使用丰度指数函数的积性性质，$I(mn) = I(m)I(n)$ 对于 $\\gcd(m,n)=1$ 成立。\n$$I(a) = I(30) = I(2 \\times 3 \\times 5) = I(2)I(3)I(5)$$\n一个素数 $p$ 的因数和为 $\\sigma(p) = 1+p$。因此，其丰度指数为 $I(p) = \\frac{1+p}{p}$。\n对于 $p=2$，$I(2) = \\frac{1+2}{2} = \\frac{3}{2}$。\n对于 $p=3$，$I(3) = \\frac{1+3}{3} = \\frac{4}{3}$。\n对于 $p=5$，$I(5) = \\frac{1+5}{5} = \\frac{6}{5}$。\n因此，$I(a)$ 为：\n$$I(30) = \\frac{3}{2} \\times \\frac{4}{3} \\times \\frac{6}{5} = \\frac{3 \\times 4 \\times 6}{2 \\times 3 \\times 5} = \\frac{72}{30} = \\frac{12}{5}$$\n由此，我们可以计算项 $I(a)\\,I(a) = (I(a))^2$：\n$$(I(a))^2 = \\left(\\frac{12}{5}\\right)^2 = \\frac{144}{25}$$\n\n接下来，我们计算 $I(a^2)$ 的值。我们有 $a^2 = 30^2 = 900$。$a^2$ 的素因数分解为：\n$$a^2 = (2 \\times 3 \\times 5)^2 = 2^2 \\times 3^2 \\times 5^2$$\n因子 $2^2=4$、$3^2=9$ 和 $5^2=25$ 两两互质。我们可以再次使用 $I(n)$ 的积性性质：\n$$I(a^2) = I(900) = I(2^2 \\times 3^2 \\times 5^2) = I(2^2)I(3^2)I(5^2)$$\n对于素数幂 $p^k$，其因数和由等比数列求和公式给出：$\\sigma(p^k) = \\sum_{j=0}^{k} p^j = \\frac{p^{k+1}-1}{p-1}$。其丰度指数为 $I(p^k) = \\frac{\\sigma(p^k)}{p^k} = \\frac{p^{k+1}-1}{p^k(p-1)}$。\n对于 $p^k = 2^2$：\n$\\sigma(2^2) = \\sigma(4) = 1+2+4 = 7$。所以，$I(2^2) = \\frac{7}{4}$。\n对于 $p^k = 3^2$：\n$\\sigma(3^2) = \\sigma(9) = 1+3+9 = 13$。所以，$I(3^2) = \\frac{13}{9}$。\n对于 $p^k = 5^2$：\n$\\sigma(5^2) = \\sigma(25) = 1+5+25 = 31$。所以，$I(5^2) = \\frac{31}{25}$。\n因此，$I(a^2)$ 为：\n$$I(a^2) = I(900) = \\frac{7}{4} \\times \\frac{13}{9} \\times \\frac{31}{25} = \\frac{7 \\times 13 \\times 31}{4 \\times 9 \\times 25} = \\frac{91 \\times 31}{900} = \\frac{2821}{900}$$\n\n最后，我们计算所求的差值 $\\Delta$：\n$$\\Delta = I(a^2) - (I(a))^2 = \\frac{2821}{900} - \\frac{144}{25}$$\n为了进行分数减法，我们找到公分母，即 $900$。\n$$\\frac{144}{25} = \\frac{144 \\times 36}{25 \\times 36} = \\frac{5184}{900}$$\n现在，我们进行减法运算：\n$$\\Delta = \\frac{2821}{900} - \\frac{5184}{900} = \\frac{2821 - 5184}{900} = -\\frac{2363}{900}$$\n我们必须确保此分数为最简形式。分母 $900 = 2^2 \\times 3^2 \\times 5^2$ 的素因数为 $2$、$3$ 和 $5$。我们检查分子 $2363$ 是否能被这些素数中的任意一个整除。\n- 被 $2$ 整除：$2363$ 是奇数，因此不能被 $2$ 整除。\n- 被 $3$ 整除：各位数字之和为 $2+3+6+3 = 14$。由于 $14$ 不能被 $3$ 整除，所以 $2363$ 也不能被 $3$ 整除。\n- 被 $5$ 整除：末位数字是 $3$，因此不能被 $5$ 整除。\n因此，分数 $-\\frac{2363}{900}$ 是最简分数。", "answer": "$$\\boxed{-\\frac{2363}{900}}$$", "id": "3088008"}, {"introduction": "最后的练习将理论与实践相结合，要求你创建一个通用的分类算法。基于积性函数的性质，你将推导出一个根据质因数分解来对任意正整数进行分类的方法，并将其编写成程序。这个练习旨在综合你目前所学的知识，并将其转化为一个实用、自动化的数字分类工具。[@problem_id:3087983]", "problem": "你需要设计并实现一个完整的、可运行的程序，该程序通过计算一个正整数 $n$ 的丰度指数 $I(n) = \\sigma(n)/n$ 并将此值与阈值 $2$ 进行比较，从而将其分类为完全数、过剩数或亏数。程序必须基于第一性原理：从约数和约数和函数 $\\sigma(n)$ 的定义出发，推导出一个仅使用 $n$ 的素因数分解和基本代数的计算方法。你不能通过枚举来求约数和，并且在与阈值 $2$ 比较时不得使用浮点运算；相反，必须进行精确的整数比较。\n\n你可以假定以下基础出发点为已知：算术基本定理（唯一素因数分解）、约数和函数 $\\sigma(n)$（定义为 $n$ 的所有正约数之和）的概念、积性函数（如果对于任意 $\\gcd(m,n)=1$ 都有 $f(mn)=f(m)f(n)$，则函数 $f$ 是积性函数）的概念，以及对于任意整数底数 $p\\ge 2$ 和指数 $a\\ge 0$ 的有限几何级数恒等式：\n$$\n1 + p + p^2 + \\cdots + p^a = \\frac{p^{a+1}-1}{p-1}.\n$$\n仅使用这些基础元素，推导出一个从素因数分解 $n=\\prod_i p_i^{a_i}$ 计算 $I(n)=\\sigma(n)/n$ 的方法，并确定相对于精确阈值 $2$ 的分类。你必须在解决方案中阐述你的推理过程，并在代码中实现该方法。\n\n分类代码规范：\n- 如果 $n$ 是亏数（即 $I(n)  2$），则输出 $-1$。\n- 如果 $n$ 是完全数（即 $I(n) = 2$），则输出 $0$。\n- 如果 $n$ 是过剩数（即 $I(n)  2$），则输出 $1$。\n\n你的程序需要计算的测试套件（按此顺序）：\n- $n \\in \\{\\,1,\\,2,\\,3,\\,4,\\,6,\\,12,\\,28,\\,32,\\,360,\\,496,\\,945,\\,9797\\,\\}$。\n\n你的程序必须：\n- 将每个 $n$ 分解为素数和指数。\n- 通过积性性质和有限几何级数，使用精确整数运算计算 $\\sigma(n)$。\n- 将 $\\sigma(n)$ 与 $2n$ 进行比较，以分配 $\\{-1,0,1\\}$ 中的分类代码。\n- 生成一行输出，其中包含测试套件的结果，格式为用方括号括起来的逗号分隔列表，例如 $[\\text{result}_1,\\text{result}_2,\\dots,\\text{result}_{12}]$。\n\n本问题不涉及物理单位、角度或百分比。所有输出均为指定的整数。", "solution": "目标是将一个正整数 $n$ 分类为亏数、完全数或过剩数。此分类由其丰度指数 $I(n) = \\sigma(n)/n$ 的值决定，其中 $\\sigma(n)$ 是约数和函数。如果 $I(n)  2$，则数 $n$ 为亏数；如果 $I(n) = 2$，则为完全数；如果 $I(n)  2$，则为过剩数。问题要求推导出一个基于第一性原理的计算方法，使用 $n$ 的素因数分解和精确整数运算，并避免在比较时使用浮点计算。\n\n首先，我们解决使用精确整数运算的约束。有理数 $I(n)$ 与整数 $2$ 的比较可以转化为一个等价的、只涉及整数的比较。由于 $n$ 是一个正整数，我们可以在关系式的两边同乘以 $n$ 而不改变其方向。\n- $I(n)  2 \\iff \\sigma(n)/n  2 \\iff \\sigma(n)  2n$\n- $I(n) = 2 \\iff \\sigma(n)/n = 2 \\iff \\sigma(n) = 2n$\n- $I(n)  2 \\iff \\sigma(n)/n  2 \\iff \\sigma(n)  2n$\n这就确立了我们方法的核心：我们将计算整数 $\\sigma(n)$，并将其直接与整数 $2n$进行比较。\n\n接下来，我们必须根据 $n$ 的素因数分解推导出 $\\sigma(n)$ 的公式。我们已知算术基本定理，该定理指出任何大于1的整数 $n$ 都有唯一的素因数分解形式 $n = p_1^{a_1} p_2^{a_2} \\cdots p_k^{a_k}$，其中 $p_i$ 是不同的素数，$a_i$ 是正整数。\n\n约数和函数 $\\sigma(n)$ 是一个积性函数。这意味着如果 $\\gcd(m, n) = 1$，那么 $\\sigma(mn) = \\sigma(m)\\sigma(n)$。$n$ 的素数幂因子 $p_1^{a_1}, p_2^{a_2}, \\ldots, p_k^{a_k}$ 是两两互素的。重复应用积性性质，我们可以将 $\\sigma(n)$ 表示为 $\\sigma$ 函数作用于其每个素数幂因子的乘积：\n$$\n\\sigma(n) = \\sigma(p_1^{a_1} p_2^{a_2} \\cdots p_k^{a_k}) = \\sigma(p_1^{a_1}) \\sigma(p_2^{a_2}) \\cdots \\sigma(p_k^{a_k}) = \\prod_{i=1}^{k} \\sigma(p_i^{a_i})\n$$\n这将问题简化为找到 $\\sigma(p^a)$ 的公式，其中 $p$ 是一个素数，$a$ 是一个正整数。根据定义，$\\sigma(p^a)$ 是 $p^a$ 的所有正约数之和。$p^a$ 的约数是 $1, p, p^2, \\ldots, p^a$。因此，它们的和是：\n$$\n\\sigma(p^a) = 1 + p + p^2 + \\cdots + p^a\n$$\n这是一个有限几何级数。问题提供了此类级数的恒等式：\n$$\n1 + p + p^2 + \\cdots + p^a = \\frac{p^{a+1}-1}{p-1}\n$$\n这个表达式保证是一个整数，因为对于任何整数 $p \\ge 2$ 和 $a \\ge 0$，$p-1$ 总是能整除 $p^{a+1}-1$。因此，我们可以使用精确整数运算来计算 $\\sigma(p^a)$。\n\n结合这些结果，我们得到了 $\\sigma(n)$ 关于其素因数分解 $n = \\prod_{i=1}^{k} p_i^{a_i}$ 的完整公式：\n$$\n\\sigma(n) = \\prod_{i=1}^{k} \\left( \\frac{p_i^{a_i+1}-1}{p_i-1} \\right)\n$$\n计算算法如下：\n1. 对于给定的整数 $n$，找出其唯一的素因数分解 $\\{ (p_1, a_1), (p_2, a_2), \\ldots, (p_k, a_k) \\}$。对于 $n=1$，素因数集合为空。\n2. 计算 $\\sigma(n)$。如果 $n=1$，则 $\\sigma(1)=1$。如果 $n  1$，则将一个乘积变量初始化为 $1$。对于分解中的每一对 $(p_i, a_i)$，使用整数除法计算项 $\\sigma(p_i^{a_i}) = (p_i^{a_i+1}-1) / (p_i-1)$。将乘积变量与该项相乘。\n3. 将计算出的整数 $\\sigma(n)$ 与整数 $2n$ 进行比较。\n4. 如果 $\\sigma(n)  2n$，则该数为亏数，输出为 $-1$。\n5. 如果 $\\sigma(n) = 2n$，则该数为完全数，输出为 $0$。\n6. 如果 $\\sigma(n)  2n$，则该数为过剩数，输出为 $1$。\n\n此过程完全依赖于所提供的基础原理，全程使用精确整数运算，并能正确分类任何给定的正整数 $n$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Solves the number classification problem for a predefined test suite.\n    \"\"\"\n    \n    def get_prime_factorization(n):\n        \"\"\"\n        Computes the prime factorization of a positive integer n.\n        Returns a dictionary mapping each prime factor to its exponent.\n        \"\"\"\n        if not isinstance(n, int) or n = 0:\n            raise ValueError(\"Input must be a positive integer.\")\n        \n        factors = {}\n        d = 2\n        temp_n = n\n        while d * d = temp_n:\n            while temp_n % d == 0:\n                factors[d] = factors.get(d, 0) + 1\n                temp_n //= d\n            d += 1\n        if temp_n  1:\n            factors[temp_n] = factors.get(temp_n, 0) + 1\n        return factors\n\n    def classify_number(n):\n        \"\"\"\n        Classifies an integer n as deficient (-1), perfect (0), or abundant (1).\n        \n        The classification is based on comparing sigma(n) with 2n, where\n        sigma(n) is the sum of the divisors of n. The calculation of sigma(n)\n        is derived from its prime factorization n = p1^a1 * p2^a2 * ...\n        and the multiplicative property of the sigma function:\n        sigma(n) = sigma(p1^a1) * sigma(p2^a2) * ...\n        where sigma(p^a) = (p^(a+1) - 1) / (p - 1).\n        \"\"\"\n        if n == 1:\n            # sigma(1) = 1. 2*n = 2. 1  2, so deficient.\n            return -1\n\n        prime_factors = get_prime_factorization(n)\n        \n        # Calculate sigma(n) using the derived formula.\n        # This uses exact integer arithmetic.\n        sigma_n = 1\n        for p, a in prime_factors.items():\n            # Calculate sigma(p^a) = (p^(a+1) - 1) / (p - 1)\n            term = (p**(a + 1) - 1) // (p - 1)\n            sigma_n *= term\n            \n        # Compare sigma(n) with 2n for classification.\n        target = 2 * n\n        if sigma_n  target:\n            return -1  # Deficient\n        elif sigma_n == target:\n            return 0   # Perfect\n        else:\n            return 1   # Abundant\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        1, 2, 3, 4, 6, 12, 28, 32, 360, 496, 945, 9797\n    ]\n\n    results = []\n    for n in test_cases:\n        result = classify_number(n)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3087983"}]}