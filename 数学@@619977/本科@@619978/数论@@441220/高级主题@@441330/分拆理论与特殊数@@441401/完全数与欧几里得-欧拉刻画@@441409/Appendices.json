{"hands_on_practices": [{"introduction": "这个练习旨在让你亲手验证一个古老的数学事实。通过计算完全数 496 的所有正因数之和，你将直接应用因数和函数 $\\sigma(n)$ 的核心性质——即它对于互质整数的积性以及其在素数幂次上的计算公式。这个实践将巩固你识别完全数所需的基础计算技能。[@problem_id:3088038]", "problem": "设 $\\sigma(n)$ 表示正整数 $n$ 的所有正因数之和。从质因数分解的唯一性和 $\\sigma(n)$ 作为因数之和的定义出发，论证为什么对于互质整数的乘积，其因数和可以分解为各因子因数和的乘积，并论证为什么质数幂 $p^{k}$ 的因数和是有限等比级数和 $1+p+p^{2}+\\cdots+p^{k}$。然后，仅使用这些基本事实，根据 $496$ 的质因数分解计算 $\\sigma(496)$，并验证其等于 $2\\cdot 496$。将您的最终答案表示为 $\\sigma(496)$ 的精确整数值。", "solution": "问题陈述已经过验证，被认为是合理、清晰且在标准数论中有科学依据的。它提供了一系列明确的任务：论证除数和函数 $\\sigma(n)$ 的基本性质，然后应用这些性质来计算 $\\sigma(496)$ 并验证一个特定属性。其中没有矛盾、歧义或事实错误。\n\n我们从基本原理开始，解决所要求的两个论证。\n\n首先，我们论证为什么对于互质整数的乘积，其因数和可以分解为各因子因数和的乘积。这个性质被称为积性。设 $\\sigma(n)$ 为一个函数，用于计算正整数 $n$ 的所有正因数之和，定义为 $\\sigma(n) = \\sum_{d|n} d$。设 $m$ 和 $n$ 是两个正整数，且它们互质，即它们的最大公约数为 $\\gcd(m, n) = 1$。\n\n根据算术基本定理，任何大于 $1$ 的整数都有唯一的质数幂乘积表示。由于 $\\gcd(m, n) = 1$，$m$ 的质因数集合与 $n$ 的质因数集合是不相交的。设 $mn$ 的任意因数为 $d$。$d$ 的质因数必须是 $mn$ 的质因数的子集。因为 $m$ 和 $n$ 的质因数是不同的，$d$ 可以唯一地写成乘积 $d = d_1 d_2$ 的形式，其中 $d_1$ 是 $m$ 的因数，$d_2$ 是 $n$ 的因数。这在 $mn$ 的因数集合与 $m$ 的因数集合和 $n$ 的因数集合的笛卡尔积之间建立了一一对应关系。\n\n利用这种对应关系，$mn$ 的因数和可以表示为：\n$$ \\sigma(mn) = \\sum_{d|mn} d = \\sum_{d_1|m, d_2|n} d_1 d_2 $$\n由于乘法对加法的分配律，这个双重求和可以被分解为：\n$$ \\sum_{d_1|m, d_2|n} d_1 d_2 = \\left( \\sum_{d_1|m} d_1 \\right) \\left( \\sum_{d_2|n} d_2 \\right) $$\n根据 $\\sigma$ 函数的定义，右边的两项分别是 $\\sigma(m)$ 和 $\\sigma(n)$。因此，我们已经证明了对于任意两个互质的整数 $m$ 和 $n$：\n$$ \\sigma(mn) = \\sigma(m)\\sigma(n) $$\n\n其次，我们论证为什么质数幂 $p^k$ 的因数和是有限等比级数和 $1 + p + p^2 + \\dots + p^k$。设 $p$ 是一个质数，$k$ 是一个非负整数。一个正整数 $d$ 是 $p^k$ 的因数的充要条件是 $d$ 具有 $p^j$ 的形式，其中 $j$ 是满足 $0 \\le j \\le k$ 的整数。这是因为 $d$ 的任何质因数也必须是 $p^k$ 的质因数，而 $p^k$ 的唯一质因数是 $p$。此外，$d$ 的质因数分解中 $p$ 的指数不能超过 $k$。因此，$p^k$ 的所有正因数集合是 $\\{p^0, p^1, p^2, \\dots, p^k\\}$，这等价于 $\\{1, p, p^2, \\dots, p^k\\}$。\n\n根据定义，这些因数的和是 $\\sigma(p^k)$：\n$$ \\sigma(p^k) = 1 + p + p^2 + \\dots + p^k $$\n这是一个有 $k+1$ 项、首项为 $1$、公比为 $p$ 的有限等比级数。该和可以用闭合形式表示为 $\\frac{p^{k+1}-1}{p-1}$。论证在于对所有可能因数的直接列举。\n\n现在，我们使用这些已确立的事实来计算 $\\sigma(496)$。首先，我们必须求出整数 $496$ 的质因数分解：\n$$ 496 = 2 \\times 248 = 2^2 \\times 124 = 2^3 \\times 62 = 2^4 \\times 31 $$\n数字 $31$ 是一个质数。因此，$496$ 的质因数分解是 $2^4 \\cdot 31^1$。\n\n因为因子 $2^4$ 和 $31$ 互质（$\\gcd(16, 31) = 1$），我们现在可以应用 $\\sigma$ 的积性性质：\n$$ \\sigma(496) = \\sigma(2^4 \\cdot 31) = \\sigma(2^4) \\sigma(31) $$\n\n接下来，我们使用等比级数和的性质计算每个质数幂因子的 $\\sigma$ 值：\n对于因子 $2^4$：\n$$ \\sigma(2^4) = 1 + 2^1 + 2^2 + 2^3 + 2^4 = 1 + 2 + 4 + 8 + 16 = 31 $$\n对于因子 $31^1$：\n$$ \\sigma(31) = \\sigma(31^1) = 1 + 31 = 32 $$\n\n将这些值代回 $\\sigma(496)$ 的表达式中：\n$$ \\sigma(496) = 31 \\times 32 $$\n乘积计算如下：\n$$ 31 \\times 32 = 992 $$\n所以，$\\sigma(496)$ 的值是 $992$。\n\n最后，问题要求验证这个结果等于 $2 \\cdot 496$。我们进行这个计算：\n$$ 2 \\cdot 496 = 992 $$\n我们计算出的 $\\sigma(496)$ 的值确实等于 $2 \\cdot 496$，这证实了 $496$ 是一个完全数。所要求的最终答案是 $\\sigma(496)$ 的精确整数值。", "answer": "$$ \\boxed{992} $$", "id": "3088038"}, {"introduction": "欧几里得-欧拉定理为偶完全数提供了精确的形式 $2^{p-1}(2^p-1)$，其中 $p$ 和 $2^p-1$ 都必须是素数。这个练习将挑战你探索当这些条件不被满足时会发生什么。通过分析一个形式上相似但其构成部分不符合素数要求的数，你将更深刻地理解为何该定理的每一个条件都至关重要。[@problem_id:3088040]", "problem": "设整数 $N$ 为 $N=2^{9}\\cdot 1023$。从正整数 $n$ 是完全数当且仅当其正因数之和 $\\sigma(n)$ 满足 $\\sigma(n)=2n$ 的定义出发，使用因数和函数对于互质因式分解的基本性质来检验 $N$ 是否为完全数。利用 $1023$ 是合数这一事实来解释你的结论。然后，为了量化 $N$ 与完全数的偏差，计算 $\\sigma(N)-2N$ 的精确整数值。将你的最终答案报告为一个整数，不要四舍五入。", "solution": "问题要求判断整数 $N=2^{9} \\cdot 1023$ 是否为完全数，并计算 $\\sigma(N) - 2N$ 的值。一个正整数 $n$ 被定义为完全数，如果其正因数之和（由因数和函数 $\\sigma(n)$ 表示）满足关系式 $\\sigma(n) = 2n$。为了分析 $N$，我们将使用因数和函数 $\\sigma$ 的性质。\n\n因数和函数 $\\sigma$ 是一个积性函数。这意味着如果两个整数 $a$ 和 $b$ 互质，那么 $\\sigma(ab) = \\sigma(a)\\sigma(b)$。这个性质可以推广到任意数量的两两互质的因子。如果一个整数 $n$ 的质因数分解为 $n = p_1^{k_1} p_2^{k_2} \\cdots p_r^{k_r}$，那么它的因数和为：\n$$ \\sigma(n) = \\sigma(p_1^{k_1}) \\sigma(p_2^{k_2}) \\cdots \\sigma(p_r^{k_r}) $$\n对于单个质数的幂 $p^k$，其因数和是一个几何级数的和：\n$$ \\sigma(p^k) = 1 + p + p^2 + \\dots + p^k = \\frac{p^{k+1}-1}{p-1} $$\n首先，我们必须找到 $N$ 的质因数分解。数 $N$ 为 $N = 2^{9} \\cdot 1023$。我们需要对 $1023$ 这一项进行因式分解。注意到 $1023 = 1024 - 1 = 2^{10} - 1$。一个形如 $a^n - 1$ 的数，如果 $n$ 是合数，那么该数也是合数。因为 $10 = 2 \\cdot 5$ 是合数，所以 $2^{10}-1$ 必定是合数。我们可以将其分解为平方差：\n$$ 1023 = 2^{10} - 1 = (2^5 - 1)(2^5 + 1) = (32 - 1)(32 + 1) = 31 \\cdot 33 $$\n数 $31$ 是质数。数 $33$ 是合数：$33 = 3 \\cdot 11$。$3$ 和 $11$ 都是质数。\n因此，$1023$ 的质因数分解是 $3 \\cdot 11 \\cdot 31$。\n\n$N$ 的完整质因数分解是：\n$$ N = 2^{9} \\cdot 3^{1} \\cdot 11^{1} \\cdot 31^{1} $$\n现在，我们可以利用其积性性质来计算 $\\sigma(N)$：\n$$ \\sigma(N) = \\sigma(2^9) \\cdot \\sigma(3^1) \\cdot \\sigma(11^1) \\cdot \\sigma(31^1) $$\n我们分别计算每一项：\n$$ \\sigma(2^9) = \\frac{2^{9+1}-1}{2-1} = 2^{10} - 1 = 1024 - 1 = 1023 $$\n$$ \\sigma(3^1) = \\frac{3^{1+1}-1}{3-1} = \\frac{3^2 - 1}{2} = \\frac{8}{2} = 4 $$\n$$ \\sigma(11^1) = \\frac{11^{1+1}-1}{11-1} = \\frac{11^2 - 1}{10} = \\frac{120}{10} = 12 $$\n$$ \\sigma(31^1) = \\frac{31^{1+1}-1}{31-1} = \\frac{31^2 - 1}{30} = \\frac{961 - 1}{30} = \\frac{960}{30} = 32 $$\n将这些值相乘得到 $\\sigma(N)$：\n$$ \\sigma(N) = 1023 \\cdot 4 \\cdot 12 \\cdot 32 = 1023 \\cdot 1536 $$\n为了检验 $N$ 是否为完全数，我们将 $\\sigma(N)$ 与 $2N$ 进行比较。\n$$ 2N = 2 \\cdot (2^9 \\cdot 1023) = 2^{10} \\cdot 1023 = 1024 \\cdot 1023 $$\n比较这两个表达式：\n$$ \\sigma(N) = 1536 \\cdot 1023 $$\n$$ 2N = 1024 \\cdot 1023 $$\n因为 $1536 \\neq 1024$，所以很明显 $\\sigma(N) \\neq 2N$。因此，整数 $N$ 不是一个完全数。\n\n按照题意，我们可以利用 $1023$ 是合数这一事实来解释这个结论。Euclid-Euler 定理给出了偶完全数的完整刻画。它指出，一个偶数是完全数，当且仅当它可以写成 $2^{p-1}(2^p-1)$ 的形式，其中 $p$ 是一个质数，并且第二个因子 $2^p-1$ 本身也是一个质数（称为梅森素数，Mersenne prime）。\n数 $N$ 为 $N = 2^9 \\cdot 1023$。我们可以将其写为 $N = 2^{10-1} \\cdot (2^{10}-1)$。这个表达式具有 $2^{k-1}(2^k-1)$ 的结构，其中 $k=10$。根据 Euclid-Euler 定理，要使 $N$ 成为完全数，必须满足两个条件：首先，指数 $k$（在此例中为 $10$）必须是质数。其次，因子 $2^k-1$（即 $1023$）也必须是质数。\n这两个条件都不满足。指数 $k=10$ 是一个合数。因此，因子 $2^{10}-1 = 1023$ 也必定是合数，这一点由其因式分解 $1023 = 3 \\cdot 11 \\cdot 31$ 所证实。因为 $1023$ 这一项是合数，所以 $N$ 未能通过成为完全数的检验。\n\n最后，题目要求我们计算与完全数的偏差的精确整数值，即 $\\sigma(N) - 2N$。使用我们推导出的表达式：\n$$ \\sigma(N) - 2N = (1023 \\cdot 1536) - (1023 \\cdot 1024) $$\n我们可以提出公因式 $1023$：\n$$ \\sigma(N) - 2N = 1023 \\cdot (1536 - 1024) $$\n括号中的差值为：\n$$ 1536 - 1024 = 512 $$\n所以表达式简化为：\n$$ \\sigma(N) - 2N = 1023 \\cdot 512 $$\n这个乘积可以计算如下：\n$$ 1023 \\cdot 512 = (1024 - 1) \\cdot 512 = (1024 \\cdot 512) - (1 \\cdot 512) $$\n注意到 $1024 = 2^{10}$ 且 $512 = 2^9$：\n$$ 1024 \\cdot 512 = 2^{10} \\cdot 2^9 = 2^{19} $$\n$2^{19}$ 的值是 $2^{10} \\cdot 2^9 = 1024 \\cdot 512 = 524288$。\n因此，最终值为：\n$$ \\sigma(N) - 2N = 524288 - 512 = 523776 $$\n$\\sigma(N) - 2N$ 的整数值是 $523776$。这个正值表示 $N$ 是一个盈数，因为其因数之和大于其本身的两倍。", "answer": "$$\n\\boxed{523776}\n$$", "id": "3088040"}, {"introduction": "从手动计算到自动化是应用数学概念的关键一步。最后的这项实践要求你设计一个算法来检验一个数是否为完全数。这项任务需要你将因数和函数 $\\sigma(n)$ 的理论性质转化为具体的计算步骤，这是一项连接数论与计算机科学的宝贵技能。[@problem_id:3088031]", "problem": "您需要设计并实现一个程序，通过将一个给定的整数分解为一个2的幂和一个奇数部分，并结合对约数和函数的高效计算，来判断该整数是否为完全数。请从以下基本原理出发：约数和函数的定义、完全数的定义、算术基本定理，以及约数和函数对互质整数的积性性质。\n\n约数和函数定义如下：对于一个正整数 $n$，定义 $\\sigma(n)$ 为 $n$ 的所有正约数之和。一个正整数 $n$ 被称为完全数，当且仅当 $\\sigma(n) = 2n$。对于本问题，您必须通过以下方式检查任意给定整数是否为完全数：首先将 $n$ 写成 $n = 2^{a} m$ 的形式，其中 $a \\ge 0$ 且 $m$ 为奇数；然后，仅使用对所有整数都有效的通用性质来计算 $\\sigma(n)$，而不依赖任何专门的预计算列表或超出算术基本定理和积性性质所能推导出的捷径。具体来说，使用以下性质：对于互质的 $u$ 和 $v$，有 $\\sigma(uv) = \\sigma(u)\\sigma(v)$；对于素数的幂 $p^{e}$，有 $\\sigma(p^{e}) = \\dfrac{p^{e+1} - 1}{p - 1}$，这是整数中等比数列求和的标准推论。您的算法应处理以下附加约束：如果 $n \\le 0$，输出应为表示假的布尔值；如果 $n$ 是奇数，输出也应为表示假的布尔值；否则，计算 $\\sigma(n)$ 并将其与 $2n$ 进行比较。\n\n您必须实现一个计算方法，给定 $n$ 后，仅使用上述基本原理执行以下步骤：提取出2的最高次幂以得到 $n = 2^{a} m$（其中 $m$ 为奇数）；直接使用素数幂公式计算 $\\sigma(2^{a})$；通过一个基于算术基本定理的方法将 $m$ 分解为素数幂的乘积，然后通过积性性质计算 $\\sigma(m)$；最后，判断是否 $\\sigma(n) = 2n$。\n\n您的程序应为以下输入测试集评估其是否为完全数的布尔结果：$2, 6, 28, 496, 8128, 464, 2096128, 9, 33550336$。选择这些测试值是为了涵盖几个方面：小的非完全偶数、已知的偶完全数、奇数部分是素数但非特殊形式的偶数、奇数部分是合数的偶数、一个奇数输入，以及一个更大的已知偶完全数。\n\n要求的最终输出格式是单行文本，其中包含用方括号括起来的、以逗号分隔的结果列表。例如，如果您的程序计算出三个结果 $r_{1}$、$r_{2}$、$r_{3}$，则必须打印单行 $[r_{1},r_{2},r_{3}]$。在本问题中，每个结果都是一个布尔值，表示对应的输入是否为完全数。不涉及物理单位，不需要角度单位，并且由于所有输出都是布尔值，因此不应有任何分数输出。", "solution": "该问题要求实现一个程序来判断整数 $n$ 是否为完全数。解决方案必须遵循一个基于基本数论原理的特定算法流程。\n\n正整数 $n$ 被定义为完全数，如果其正约数之和等于该数本身的两倍。使用约数和函数 $\\sigma(n)$，这个条件表示为 $\\sigma(n) = 2n$。\n\n验证过程首先处理题目要求的几种特殊情况：\n1.  如果输入整数 $n \\le 0$，则该数不是正整数，因此根据定义它不可能是完全数。程序必须返回 `false`。\n2.  如果输入整数 $n$ 是奇数，题目要求程序返回 `false`。这是一个算法上的约束，作为一个捷径，它与“不存在奇完全数”这一未被证实的猜想是一致的。\n\n对于 $n$ 是正偶数的主要情况，题目指定了一种基于 $n$ 的素因数分解的计算方法。任何偶数 $n$ 都可以唯一地表示为 $n = 2^{a} m$ 的形式，其中 $a \\ge 1$ 是一个整数，表示因子 $2$ 的指数，而 $m$ 是一个奇数。\n\n约数和函数 $\\sigma$ 是一个积性函数。对于任意两个互质整数 $u$ 和 $v$（即 $\\text{gcd}(u, v) = 1$），$\\sigma(uv) = \\sigma(u)\\sigma(v)$ 成立。由于 $2^a$ 和奇数 $m$ 互质，我们可以写出：\n$$ \\sigma(n) = \\sigma(2^{a} m) = \\sigma(2^{a}) \\sigma(m) $$\n\n题目给出了计算素数幂 $p^e$ 的约数和的公式，它是一个等比数列的和：\n$$ \\sigma(p^{e}) = \\sum_{i=0}^{e} p^{i} = 1 + p + p^2 + \\dots + p^e = \\frac{p^{e+1} - 1}{p - 1} $$\n\n将此公式应用于因子 $2^a$，我们得到：\n$$ \\sigma(2^{a}) = \\frac{2^{a+1} - 1}{2 - 1} = 2^{a+1} - 1 $$\n\n为了计算 $\\sigma(m)$，我们必须首先找到 $m$ 的素因数分解。根据算术基本定理，$m$ 可以唯一地写成素数幂的乘积：\n$$ m = p_1^{e_1} p_2^{e_2} \\cdots p_k^{e_k} $$\n其中 $p_1, p_2, \\dots, p_k$ 是不同的奇素数，$e_1, e_2, \\dots, e_k$ 是它们各自的指数。\n\n由于因子 $p_i^{e_i}$ 两两互质，$\\sigma$ 的积性性质允许我们将 $\\sigma(m)$ 计算为每个素数幂因子的约数和的乘积：\n$$ \\sigma(m) = \\sigma(p_1^{e_1}) \\sigma(p_2^{e_2}) \\cdots \\sigma(p_k^{e_k}) $$\n每一项 $\\sigma(p_i^{e_i})$ 都使用素数幂公式计算：\n$$ \\sigma(p_i^{e_i}) = \\frac{p_i^{e_i+1} - 1}{p_i - 1} $$\n\n实现的完整算法如下：\n1.  给定一个整数 $n$，首先检查边界条件：如果 $n \\le 0$ 或者 $n$ 是奇数，结果为 `false`。\n2.  如果 $n$ 是一个正偶数，找到其分解式 $n=2^a m$。这通过重复将 $n$ 除以 $2$ 来找到奇数部分 $m$，并计算除法次数以得到指数 $a$。\n3.  使用公式 $2^{a+1}-1$ 计算 $\\sigma(2^a)$。\n4.  计算 $\\sigma(m)$。这个任务被委托给一个辅助函数，该函数通过试除法实现对奇数 $m$ 的因式分解。对于在 $m$ 中找到的每个指数为 $e$ 的素因子 $p$，它计算 $\\sigma(p^e)$ 并将这些结果相乘以获得最终的 $\\sigma(m)$。由于 $m$ 是奇数，试除的除数从 $3$ 开始并以 $2$ 为步长递增。试除法进行到 $\\sqrt{m}$ 为止。\n5.  总约数和计算为 $\\sigma(n) = \\sigma(2^a) \\cdot \\sigma(m)$。\n6.  最后，算法返回比较 $\\sigma(n) == 2n$ 的布尔结果。\n\n此方法从第一性原理出发系统地计算 $\\sigma(n)$，并在不依赖任何预计算列表或专门定理（如 Euclid-Euler 定理）的情况下确定其是否为完全数，尽管其正确性通过它能够验证符合此类定理的数的能力得到了证明。最终的程序将此逻辑应用于提供的测试集中的每个数字。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\n\ndef solve():\n    \"\"\"\n    Solves the problem of determining if a list of numbers are perfect,\n    adhering to the specified algorithmic constraints.\n    \"\"\"\n\n    def sigma_odd(m: int) -> int:\n        \"\"\"\n        Computes the sum-of-divisors function sigma(m) for an odd integer m.\n        This is done by finding the prime factorization of m using trial division\n        and applying the multiplicative property of the sigma function.\n        m = p1^e1 * p2^e2 * ... -> sigma(m) = sigma(p1^e1) * sigma(p2^e2) * ...\n        \"\"\"\n        if m == 1:\n            return 1\n        \n        total_sigma = 1\n        temp_m = m\n        d = 3 # Start with the first odd prime\n        \n        while d * d <= temp_m:\n            if temp_m % d == 0:\n                count = 0\n                while temp_m % d == 0:\n                    count += 1\n                    temp_m //= d\n                # sigma(p^e) = (p^(e+1) - 1) / (p - 1)\n                sigma_p_e = (d**(count + 1) - 1) // (d - 1)\n                total_sigma *= sigma_p_e\n            d += 2\n            \n        # If there's a prime factor remaining (e.g., m was prime or has a large prime factor)\n        if temp_m > 1:\n            # sigma(p^1) = p + 1\n            total_sigma *= (temp_m + 1)\n            \n        return total_sigma\n\n    def is_perfect(n: int) -> bool:\n        \"\"\"\n        Checks if a number n is a perfect number based on the problem's rules.\n        A positive integer n is perfect if sigma(n) = 2n.\n        \"\"\"\n        # Constraint 1: n must be positive.\n        if n <= 0:\n            return False\n            \n        # Constraint 2: n must not be odd.\n        if n % 2 != 0:\n            return False\n\n        # If n is a positive even number, proceed with the full calculation.\n        \n        # Step 1: Factor n into 2^a * m, where m is odd.\n        a = 0\n        m = n\n        while m % 2 == 0:\n            a += 1\n            m //= 2\n        \n        # Step 2: Compute sigma(2^a). Using the formula sigma(p^e),\n        # for p=2, sigma(2^a) = 2^(a+1) - 1.\n        sigma_2_part = (1 << (a + 1)) - 1\n        \n        # Step 3: Compute sigma(m) for the odd part m.\n        sigma_m_part = sigma_odd(m)\n        \n        # Step 4: Compute sigma(n) using multiplicativity: sigma(n) = sigma(2^a) * sigma(m).\n        sigma_n = sigma_2_part * sigma_m_part\n        \n        # Step 5: Check if sigma(n) == 2n.\n        return sigma_n == 2 * n\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        2, 6, 28, 496, 8128, 464, 2096128, 9, 33550336\n    ]\n\n    results = []\n    for n in test_cases:\n        result = is_perfect(n)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3088031"}]}