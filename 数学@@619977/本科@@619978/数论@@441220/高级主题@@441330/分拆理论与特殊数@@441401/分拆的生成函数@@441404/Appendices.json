{"hands_on_practices": [{"introduction": "在整数分拆理论中，$q$-Pochhammer 符号 $(q;q)_{\\infty}$ 是一个核心的构造模块。本练习旨在通过直接的级数展开，亲手揭示其系数序列的惊人稀疏性，这一结果即是著名的欧拉五边形数定理。通过计算这些系数，你将直接体会到无限乘积与分拆计数之间的深刻组合联系 [@problem_id:3085462]。", "problem": "设 $q$ 是一个不定元，满足 $|q|<1$，定义 $q$-Pochhammer 符号为\n$$\n(q;q)_{\\infty} \\;=\\; \\prod_{n=1}^{\\infty} \\left(1 - q^{n}\\right).\n$$\n仅使用无穷乘积的定义和幂级数乘法的形式规则，直接展开该乘积，直到并包括总次数为 $15$ 的项。由此断定存在一个多项式 $S_{15}(q)$，使得\n$$\n(q;q)_{\\infty} \\;=\\; S_{15}(q) \\;+\\; \\mathcal{O}\\!\\left(q^{16}\\right),\n$$\n并确定 $S_{15}(q)$ 的显式表达式。你的最终答案必须是 $S_{15}(q)$ 作为 $q$ 的整系数多项式的封闭形式表达式。", "solution": "题目要求将 $q$-Pochhammer 符号 $(q;q)_{\\infty}$ 展开为 $q$ 的幂级数，直到并包括 $15$ 次项。其定义为一个无穷乘积：\n$$ (q;q)_{\\infty} = \\prod_{n=1}^{\\infty} (1 - q^n) = (1-q)(1-q^2)(1-q^3)\\cdots $$\n我们需要找到多项式 $S_{15}(q)$，使得 $(q;q)_{\\infty} = S_{15}(q) + \\mathcal{O}(q^{16})$。这个多项式是该无穷乘积在 $15$ 次截断的泰勒展开式。\n\n该乘积的形式展开遵循广义分配律。展开式中的一项是通过从每个因子 $(1-q^n)$ 中选择项 $1$ 或项 $-q^n$ 来形成的。为了得到形式为 $c_k q^k$ 的项，我们必须选择有限个因子，比如 $-q^{n_1}, -q^{n_2}, \\dots, -q^{n_j}$，并从所有其他因子中选择项 $1$，使得指数之和为 $k$：\n$$ n_1 + n_2 + \\dots + n_j = k $$\n由于每个因子 $(1-q^n)$ 最多只能使用一次，整数 $n_1, n_2, \\dots, n_j$ 必须是不同的。这些选定项的乘积是 $(-1)^j q^{n_1+n_2+\\dots+n_j} = (-1)^j q^k$。\n这种选择对应于将整数 $k$ 划分成 $j$ 个不同部分。因此，展开式中 $q^k$ 的系数 $c_k$ 是对所有将 $k$ 划分成 $j$ 个不同部分的所有可能划分，求和 $(-1)^j$ 的结果。\n\n设 $p_d(k)$ 是将 $k$ 划分成不同部分的划分数。设 $E_d(k)$ 是将 $k$ 划分成偶数个不同部分的划分数，而 $O_d(k)$ 是将 $k$ 划分成奇数个不同部分的划分数。系数 $c_k$ 则由下式给出：\n$$ c_k = E_d(k) - O_d(k) $$\n我们现在计算从 $k=0$ 到 $15$ 的这些系数。\n\n$k=0$: 唯一的划分是空划分，它有 $0$ 个部分（偶数）。因此，$E_d(0)=1$, $O_d(0)=0$，且 $c_0=1$。\n\n$k=1$: 唯一的划分是 $\\{1\\}$，它有 $1$ 个部分（奇数）。$O_d(1)=1$, $E_d(1)=0$。$c_1=-1$。\n\n$k=2$: 唯一的划分是 $\\{2\\}$，有 $1$ 个部分（奇数）。$O_d(2)=1$, $E_d(2)=0$。$c_2=-1$。\n\n$k=3$: 划分：$\\{3\\}$ (奇数)，$\\{2,1\\}$ (偶数)。$O_d(3)=1$, $E_d(3)=1$。$c_3=0$。\n\n$k=4$: 划分：$\\{4\\}$ (奇数)，$\\{3,1\\}$ (偶数)。$O_d(4)=1$, $E_d(4)=1$。$c_4=0$。\n\n$k=5$: 划分：$\\{5\\}$ (奇数)，$\\{4,1\\}$ (偶数)，$\\{3,2\\}$ (偶数)。$O_d(5)=1$, $E_d(5)=2$。$c_5=1$。\n\n$k=6$: 划分：$\\{6\\}$ (奇数)，$\\{5,1\\}$ (偶数)，$\\{4,2\\}$ (偶数)，$\\{3,2,1\\}$ (奇数)。$O_d(6)=2$, $E_d(6)=2$。$c_6=0$。\n\n$k=7$: 划分：$\\{7\\}$ (奇数)，$\\{6,1\\}$ (偶数)，$\\{5,2\\}$ (偶数)，$\\{4,3\\}$ (偶数)，$\\{4,2,1\\}$ (奇数)。$O_d(7)=2$, $E_d(7)=3$。$c_7=1$。\n\n$k=8$: 划分：$\\{8\\}$, $\\{7,1\\}$, $\\{6,2\\}$, $\\{5,3\\}$, $\\{5,2,1\\}$, $\\{4,3,1\\}$。$O_d(8)=3$ (来自 $\\{8\\}, \\{5,2,1\\}, \\{4,3,1\\}$)，$E_d(8)=3$ (来自 $\\{7,1\\}, \\{6,2\\}, \\{5,3\\}$)。$c_8=0$。\n\n$k=9$: 划分：$\\{9\\}$, $\\{8,1\\}$, $\\{7,2\\}$, $\\{6,3\\}$, $\\{5,4\\}$, $\\{6,2,1\\}$, $\\{5,3,1\\}$, $\\{4,3,2\\}$。$O_d(9)=4$, $E_d(9)=4$。$c_9=0$。\n\n$k=10$: 划分：$\\{10\\}$, $\\{9,1\\}$, $\\{8,2\\}$, $\\{7,3\\}$, $\\{6,4\\}$, $\\{7,2,1\\}$, $\\{6,3,1\\}$, $\\{5,4,1\\}$, $\\{5,3,2\\}$, $\\{4,3,2,1\\}$。$O_d(10)=5$, $E_d(10)=5$。$c_{10}=0$。\n\n$k=11$: 划分为偶数个部分：$\\{10,1\\}, \\{9,2\\}, \\{8,3\\}, \\{7,4\\}, \\{6,5\\}$ (5个划分)；$\\{5,3,2,1\\}$ (1个划分)。$E_d(11)=6$。\n划分为奇数个部分：$\\{11\\}$ (1个划分)；$\\{8,2,1\\}, \\{7,3,1\\}, \\{6,4,1\\}, \\{6,3,2\\}, \\{5,4,2\\}$ (5个划分)。$O_d(11)=6$。$c_{11}=0$。\n\n$k=12$: 划分为偶数个部分：$\\{11,1\\}, \\{10,2\\}, \\{9,3\\}, \\{8,4\\}, \\{7,5\\}$ (5个划分)；$\\{6,3,2,1\\}, \\{5,4,2,1\\}$ (2个划分)。$E_d(12)=7$。\n划分为奇数个部分：$\\{12\\}$ (1个划分)；$\\{9,2,1\\}, \\{8,3,1\\}, \\{7,4,1\\}, \\{6,5,1\\}, \\{7,3,2\\}, \\{6,4,2\\}, \\{5,4,3\\}$ (7个划分)。$O_d(12)=8$。$c_{12}=-1$。\n\n$k=13$: 划分为偶数个部分：$\\{12,1\\} \\dots \\{7,6\\}$ (6个划分)；$\\{7,3,2,1\\}, \\{6,4,2,1\\}, \\{5,4,3,1\\}$ (3个划分)。$E_d(13)=9$。\n划分为奇数个部分：$\\{13\\}$ (1个划分)；有3个部分的划分 (8个划分)。$O_d(13)=9$。$c_{13}=0$。\n\n$k=14$: 划分为偶数个部分：$\\{13,1\\} \\dots \\{8,6\\}$ (6个划分)；有4个部分的划分 (5个划分)。$E_d(14)=11$。\n划分为奇数个部分：$\\{14\\}$ (1个划分)；有3个部分的划分 (10个划分)。$O_d(14)=11$。$c_{14}=0$。\n\n$k=15$: 划分为偶数个部分：$\\{14,1\\} \\dots \\{8,7\\}$ (7个划分)；有4个部分的划分 (6个划分)。$E_d(15)=13$。\n划分为奇数个部分：$\\{15\\}$ (1个划分)；有3个部分的划分 (12个划分)；$\\{5,4,3,2,1\\}$ (1个划分)。$O_d(15)=14$。$c_{15}=-1$。\n\n收集这些系数，我们构造多项式 $S_{15}(q)$：\n$$ S_{15}(q) = \\sum_{k=0}^{15} c_k q^k $$\n$$ S_{15}(q) = 1 \\cdot q^0 - 1 \\cdot q^1 - 1 \\cdot q^2 + 0 \\cdot q^3 + 0 \\cdot q^4 + 1 \\cdot q^5 + 0 \\cdot q^6 + 1 \\cdot q^7 + 0 \\cdot q^8 + 0 \\cdot q^9 + 0 \\cdot q^{10} + 0 \\cdot q^{11} - 1 \\cdot q^{12} + 0 \\cdot q^{13} + 0 \\cdot q^{14} - 1 \\cdot q^{15} $$\n因此，$S_{15}(q)$ 的显式表达式为：\n$$ S_{15}(q) = 1 - q - q^2 + q^5 + q^7 - q^{12} - q^{15} $$\n这个多项式代表了 $(q;q)_{\\infty}$ 直到15次项的展开。", "answer": "$$\\boxed{1 - q - q^{2} + q^{5} + q^{7} - q^{12} - q^{15}}$$", "id": "3085462"}, {"introduction": "Rogers-Ramanujan 恒等式是分拆理论乃至整个数学领域中最优美和深刻的结果之一，它揭示了两种看似无关的分拆限制条件竟然等价。本练习提供了一个具体的机会，通过计算恒等式两边级数的前几项系数，来亲手验证这一惊人的数学事实。这个过程将加深你对解析表达式（和式）与组合构造（乘积式）之间对偶性的理解 [@problem_id:3085505]。", "problem": "设 $q$ 是一个未定元，并设 $q$-Pochhammer 符号定义为 $(q;q)_{n}=\\prod_{k=1}^{n}(1-q^{k})$，对于 $n\\in\\mathbb{Z}_{\\ge 0}$，约定 $(q;q)_{0}=1$。考虑两个形式幂级数\n$$S_{1}(q)=\\sum_{n\\ge 0}\\frac{q^{n^{2}}}{(q;q)_{n}},$$\n$$S_{2}(q)=\\sum_{n\\ge 0}\\frac{q^{n^{2}+n}}{(q;q)_{n}}。$$\n从整数分拆的核心生成函数定义出发，分别计算 $S_{1}(q)$ 和 $S_{2}(q)$ 中 $q^{N}$ 的系数 $a_{N}$ 和 $b_{N}$，其中 $0\\le N\\le 12$。然后，仅使用关于几何级数乘积的基本原理，验证这些系数（对于 $0\\le N\\le 12$）与展开乘积端\n$$P_{1}(q)=\\prod_{m\\ge 0}\\frac{1}{(1-q^{5m+1})(1-q^{5m+4})},$$\n$$P_{2}(q)=\\prod_{m\\ge 0}\\frac{1}{(1-q^{5m+2})(1-q^{5m+3})}$$\n所得到的系数一致。将你的结果表示为单个行向量\n$$(a_{0},a_{1},\\dots,a_{12},b_{0},b_{1},\\dots,b_{12})。$$\n你的最终答案必须是这个行向量，写成单个解析表达式。无需四舍五入。", "solution": "问题要求计算两个级数 $S_1(q)$ 和 $S_2(q)$ 的前 $13$ 个系数（对应 $q^0$ 到 $q^{12}$ 的幂次），并与两个无穷乘积 $P_1(q)$ 和 $P_2(q)$ 的系数进行验证。\n\n**第一部分: 计算 $S_1(q)$ 的系数 $a_N$**\n\n$S_{1}(q)$ 由 $S_{1}(q)=\\sum_{n\\ge 0}\\frac{q^{n^{2}}}{(q;q)_{n}}$ 给出。我们展开这个和的前几项。我们只需要考虑 $n^2 \\le 12$ 的项，所以 $n=0, 1, 2, 3$。\n\n对于 $n=0$: $\\frac{q^{0^2}}{(q;q)_0} = \\frac{1}{1} = 1$。\n\n对于 $n=1$: $\\frac{q^{1^2}}{(q;q)_1} = \\frac{q}{1-q} = q\\sum_{k=0}^{\\infty}q^k = q+q^2+q^3+q^4+q^5+q^6+q^7+q^8+q^9+q^{10}+q^{11}+q^{12}+\\dots$\n\n对于 $n=2$: $\\frac{q^{2^2}}{(q;q)_2} = \\frac{q^4}{(1-q)(1-q^2)}$。$\\frac{1}{(1-q)(1-q^2)}$ 的展开式是将整数分拆为大小为 1 或 2 的部分的生成函数。$q^k$ 的系数是 $p_{\\{1,2\\}}(k) = \\lfloor k/2 \\rfloor + 1$。\n$\\frac{1}{(1-q)(1-q^2)} = 1+q+2q^2+2q^3+3q^4+3q^5+4q^6+4q^7+5q^8+\\dots$\n乘以 $q^4$：\n$\\frac{q^4}{(1-q)(1-q^2)} = q^4(1+q+2q^2+\\dots) = q^4+q^5+2q^6+2q^7+3q^8+3q^9+4q^{10}+4q^{11}+5q^{12}+\\dots$\n\n对于 $n=3$: $\\frac{q^{3^2}}{(q;q)_3} = \\frac{q^9}{(1-q)(1-q^2)(1-q^3)}$。$\\frac{1}{(q;q)_3}$ 的展开式是将整数分拆为大小最多为 3 的部分的生成函数。\n$\\frac{1}{(q;q)_3} = 1+q+2q^2+3q^3+4q^4+\\dots$\n乘以 $q^9$：\n$\\frac{q^9}{(q;q)_3} = q^9(1+q+2q^2+3q^3+\\dots) = q^9+q^{10}+2q^{11}+3q^{12}+\\dots$\n\n对于 $n=4$: $\\frac{q^{4^2}}{(q;q)_4} = \\frac{q^{16}}{(q;q)_4}$。$q$ 的最低次幂是 $16$，所以此项对 $N \\le 12$ 的系数没有贡献。\n\n现在，我们将来自 $n=0,1,2,3$ 的贡献相加，来求和系数 $a_N = [q^N]S_1(q)$，其中 $0 \\le N \\le 12$：\n$a_0 = 1$ (来自 $n=0$)\n$a_1 = 1$ (来自 $n=1$)\n$a_2 = 1$ (来自 $n=1$)\n$a_3 = 1$ (来自 $n=1$)\n$a_4 = 1$ (来自 $n=1$) $+ 1$ (来自 $n=2$) $= 2$\n$a_5 = 1$ (来自 $n=1$) $+ 1$ (来自 $n=2$) $= 2$\n$a_6 = 1$ (来自 $n=1$) $+ 2$ (来自 $n=2$) $= 3$\n$a_7 = 1$ (来自 $n=1$) $+ 2$ (来自 $n=2$) $= 3$\n$a_8 = 1$ (来自 $n=1$) $+ 3$ (来自 $n=2$) $= 4$\n$a_9 = 1$ (来自 $n=1$) $+ 3$ (来自 $n=2$) $+ 1$ (来自 $n=3$) $= 5$\n$a_{10} = 1$ (来自 $n=1$) $+ 4$ (来自 $n=2$) $+ 1$ (来自 $n=3$) $= 6$\n$a_{11} = 1$ (来自 $n=1$) $+ 4$ (来自 $n=2$) $+ 2$ (来自 $n=3$) $= 7$\n$a_{12} = 1$ (来自 $n=1$) $+ 5$ (来自 $n=2$) $+ 3$ (来自 $n=3$) $= 9$\n\n系数向量为 $(a_0, \\dots, a_{12}) = (1, 1, 1, 1, 2, 2, 3, 3, 4, 5, 6, 7, 9)$。\n\n**第二部分: 用 $P_1(q)$ 验证 $a_N$**\n\n$P_1(q) = \\prod_{m\\ge 0}\\frac{1}{(1-q^{5m+1})(1-q^{5m+4})} = \\frac{1}{(1-q)(1-q^4)(1-q^6)(1-q^9)(1-q^{11})\\dots}$\n问题要求使用几何级数的基本原理进行验证。项 $\\frac{1}{1-q^k}$ 是几何级数 $1+q^k+q^{2k}+\\dots$，它是仅由大小为 $k$ 的部分构成的分拆的生成函数。因此，乘积 $P_1(q)$ 是将整数 $N$ 分拆为大小模 5 同余于 1 或 4 的部分的生成函数。我们列出 $N=0$ 到 $12$ 的这些分拆：\n$[q^0]P_1(q)$: $\\emptyset$ (1 个分拆)。$a_0=1$。匹配。\n$[q^1]P_1(q)$: $1$ (1 个分拆)。$a_1=1$。匹配。\n$[q^2]P_1(q)$: $1+1$ (1 个分拆)。$a_2=1$。匹配。\n$[q^3]P_1(q)$: $1+1+1$ (1 个分拆)。$a_3=1$。匹配。\n$[q^4]P_1(q)$: $4$, $1+1+1+1$ (2 个分拆)。$a_4=2$。匹配。\n$[q^5]P_1(q)$: $4+1$, $1+1+1+1+1$ (2 个分拆)。$a_5=2$。匹配。\n$[q^6]P_1(q)$: $6$, $4+1+1$, $1+1+1+1+1+1$ (3 个分拆)。$a_6=3$。匹配。\n$[q^7]P_1(q)$: $6+1$, $4+1+1+1$, $1\\times 7$ (3 个分拆)。$a_7=3$。匹配。\n$[q^8]P_1(q)$: $4+4$, $6+1+1$, $4+1\\times 4$, $1\\times 8$ (4 个分拆)。$a_8=4$。匹配。\n$[q^9]P_1(q)$: $9$, $6+1+1+1$, $4+4+1$, $4+1\\times 5$, $1\\times 9$ (5 个分拆)。$a_9=5$。匹配。\n$[q^{10}]P_1(q)$: $9+1$, $6+4$, $6+1\\times 4$, $4+4+1+1$, $4+1\\times 6$, $1\\times 10$ (6 个分拆)。$a_{10}=6$。匹配。\n$[q^{11}]P_1(q)$: $11$, $9+1+1$, $6+4+1$, $6+1\\times 5$, $4+4+1+1+1$, $4+1\\times 7$, $1\\times 11$ (7 个分拆)。$a_{11}=7$。匹配。\n$[q^{12}]P_1(q)$: $11+1$, $9+1+1+1$, $6+6$, $6+4+1+1$, $4+4+4$, $6+1\\times 6$, $4+4+1\\times 4$, $4+1\\times 8$, $1\\times 12$ (9 个分拆)。$a_{12}=9$。匹配。\n系数 $a_N$ 得到验证。\n\n**第三部分: 计算 $S_2(q)$ 的系数 $b_N$**\n\n$S_{2}(q)$ 由 $S_{2}(q)=\\sum_{n\\ge 0}\\frac{q^{n^{2}+n}}{(q;q)_{n}}$ 给出。我们需要 $n^2+n \\le 12$ 的项。这对于 $n=0, 1, 2, 3$ 成立。\n\n对于 $n=0$: $\\frac{q^{0^2+0}}{(q;q)_0} = \\frac{1}{1} = 1$。\n\n对于 $n=1$: $\\frac{q^{1^2+1}}{(q;q)_1} = \\frac{q^2}{1-q} = q^2\\sum_{k=0}^{\\infty}q^k = q^2+q^3+q^4+q^5+q^6+q^7+q^8+q^9+q^{10}+q^{11}+q^{12}+\\dots$\n\n对于 $n=2$: $\\frac{q^{2^2+2}}{(q;q)_2} = \\frac{q^6}{(1-q)(1-q^2)}$。使用第一部分的展开式：\n$\\frac{q^6}{(1-q)(1-q^2)} = q^6(1+q+2q^2+2q^3+3q^4+3q^5+4q^6+\\dots) = q^6+q^7+2q^8+2q^9+3q^{10}+3q^{11}+4q^{12}+\\dots$\n\n对于 $n=3$: $\\frac{q^{3^2+3}}{(q;q)_3} = \\frac{q^{12}}{(1-q)(1-q^2)(1-q^3)}$。\n$\\frac{q^{12}}{(q;q)_3} = q^{12}(1+q+\\dots) = q^{12}+\\dots$\n\n对于 $n=4$: $\\frac{q^{4^2+4}}{(q;q)_4} = \\frac{q^{20}}{(q;q)_4}$。$q$ 的最低次幂是 $20$，所以我们忽略此项。\n\n求和系数 $b_N = [q^N]S_2(q)$，其中 $0 \\le N \\le 12$：\n$b_0 = 1$ (来自 $n=0$)\n$b_1 = 0$\n$b_2 = 1$ (来自 $n=1$)\n$b_3 = 1$ (来自 $n=1$)\n$b_4 = 1$ (来自 $n=1$)\n$b_5 = 1$ (来自 $n=1$)\n$b_6 = 1$ (来自 $n=1$) $+ 1$ (来自 $n=2$) $= 2$\n$b_7 = 1$ (来自 $n=1$) $+ 1$ (来自 $n=2$) $= 2$\n$b_8 = 1$ (来自 $n=1$) $+ 2$ (来自 $n=2$) $= 3$\n$b_9 = 1$ (来自 $n=1$) $+ 2$ (来自 $n=2$) $= 3$\n$b_{10} = 1$ (来自 $n=1$) $+ 3$ (来自 $n=2$) $= 4$\n$b_{11} = 1$ (来自 $n=1$) $+ 3$ (来自 $n=2$) $= 4$\n$b_{12} = 1$ (来自 $n=1$) $+ 4$ (来自 $n=2$) $+ 1$ (来自 $n=3$) $= 6$\n\n系数向量为 $(b_0, \\dots, b_{12}) = (1, 0, 1, 1, 1, 1, 2, 2, 3, 3, 4, 4, 6)$。\n\n**第四部分: 用 $P_2(q)$ 验证 $b_N$**\n\n$P_2(q) = \\prod_{m\\ge 0}\\frac{1}{(1-q^{5m+2})(1-q^{5m+3})} = \\frac{1}{(1-q^2)(1-q^3)(1-q^7)(1-q^8)(1-q^{12})\\dots}$\n$P_2(q)$ 是将整数 $N$ 分拆为大小模 5 同余于 2 或 3 的部分的生成函数。\n$[q^0]P_2(q)$: $\\emptyset$ (1 个分拆)。$b_0=1$。匹配。\n$[q^1]P_2(q)$: (0 个分拆)。$b_1=0$。匹配。\n$[q^2]P_2(q)$: $2$ (1 个分拆)。$b_2=1$。匹配。\n$[q^3]P_2(q)$: $3$ (1 个分拆)。$b_3=1$。匹配。\n$[q^4]P_2(q)$: $2+2$ (1 个分拆)。$b_4=1$。匹配。\n$[q^5]P_2(q)$: $3+2$ (1 个分拆)。$b_5=1$。匹配。\n$[q^6]P_2(q)$: $3+3$, $2+2+2$ (2 个分拆)。$b_6=2$。匹配。\n$[q^7]P_2(q)$: $7$, $3+2+2$ (2 个分拆)。$b_7=2$。匹配。\n$[q^8]P_2(q)$: $8$, $3+3+2$, $2+2+2+2$ (3 个分拆)。$b_8=3$。匹配。\n$[q^9]P_2(q)$: $7+2$, $3+3+3$, $3+2+2+2$ (3 个分拆)。$b_9=3$。匹配。\n$[q^{10}]P_2(q)$: $8+2$, $7+3$, $3+3+2+2$, $2\\times 5$ (4 个分拆)。$b_{10}=4$。匹配。\n$[q^{11}]P_2(q)$: $8+3$, $7+2+2$, $3+3+3+2$, $3+2\\times 4$ (4 个分拆)。$b_{11}=4$。匹配。\n$[q^{12}]P_2(q)$: $12$, $8+2+2$, $7+3+2$, $3\\times 4$, $3+3+2\\times 3$, $2\\times 6$ (6 个分拆)。$b_{12}=6$。匹配。\n系数 $b_N$ 得到验证。\n\n**第五部分: 最终结果**\n\n所要求的结果是单个行向量 $(a_{0},a_{1},\\dots,a_{12},b_{0},b_{1},\\dots,b_{12})$。\n这是两个系数向量的串联：\n$(1,1,1,1,2,2,3,3,4,5,6,7,9)$ 和 $(1,0,1,1,1,1,2,2,3,3,4,4,6)$。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n1  1  1  1  2  2  3  3  4  5  6  7  9  1  0  1  1  1  1  2  2  3  3  4  4  6\n\\end{pmatrix}\n}\n$$", "id": "3085505"}, {"introduction": "生成函数的威力可以通过引入更多变量来追踪分拆的额外统计特性（如分拆的份数）而得到增强。本练习将引导你完成一个从理论到实践的完整过程：首先，从一个二元生成函数的函数方程出发，推导出一个用于计算分拆数的递推关系；然后，将这个递推关系转化为一个高效的动态规划算法。这个练习完美地展示了如何将抽象的生成函数理论转化为具体可行的计算工具 [@problem_id:3085480]。", "problem": "设 $p(n,m)$ 表示将非负整数 $n$ 分拆成恰好 $m$ 个正整数部分的方案数，其中各部分的顺序无关紧要，但各部分本身是正整数。考虑一个二元生成函数 $P(q,z)$，它通过关于 $q$ 和 $z$ 的形式幂级数，同时根据分拆的总大小和部分数量对分拆进行编码。此问题的基础包括整数分拆的定义、将生成函数解释为用于计数组合对象的形式幂级数，以及独立组合选择的乘积形式分解。\n\n从这些基础出发，推导一种使用二元生成函数 $P(q,z)$ 计算 $p(n,m)$ 的方法，并从此推导中得到一个可以通过动态规划 (DP) 高效实现的 $p(n,m)$ 的递推关系。明确说明为使递推关系对所有相关的 $(n,m)$ 都有良好定义所需的初始条件，并给出一个以 $n$ 和 $m$ 表示的具有明确复杂度界限的算法。\n\n您的程序必须实现所推导的递推关系，并为以下参数对测试套件计算 $p(n,m)$：\n- $(0,0)$,\n- $(0,1)$,\n- $(1,1)$,\n- $(5,2)$,\n- $(5,3)$,\n- $(5,4)$,\n- $(5,5)$,\n- $(10,3)$,\n- $(7,10)$,\n- $(50,1)$,\n- $(20,5)$,\n- $(30,10)$.\n\n所有输出均为整数。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果的顺序与测试套件中的顺序相同（例如，$[r_1,r_2,\\dots,r_{12}]$，其中每个 $r_i$ 是第 $i$ 个测试用例的 $p(n,m)$ 的计算值）。", "solution": "### 1. 分拆的二元生成函数\n\n设 $p(n,m)$ 表示将一个非负整数 $n$ 分拆成恰好 $m$ 个正整数部分的方案数。编码这些数字的二元生成函数 $P(q,z)$ 由以下形式幂级数定义：\n$$\nP(q,z) = \\sum_{n=0}^{\\infty} \\sum_{m=0}^{\\infty} p(n,m) q^n z^m\n$$\n在此级数中，$q$ 的指数跟踪被分拆的数 ($n$)，$z$ 的指数跟踪分拆中的部分数量 ($m$)。\n\n分拆可以通过选择使用哪些正整数作为部分来构造。对每个可能部分的选择是独立的。对于任何正整数 $k$，我们可以将其用作一个部分零次、一次、两次，依此类推。使用部分 $k$ 共 $j$ 次，对总和 $n$ 的贡献为 $j \\cdot k$，对部分总数 $m$ 的贡献为 $j$。在生成函数中，这对应于项 $(z q^k)^j$。对我们可以使用部分 $k$ 的所有可能次数 $j$ 求和，我们得到一个几何级数：\n$$\n1 + zq^k + (zq^k)^2 + (zq^k)^3 + \\dots = \\frac{1}{1 - zq^k}\n$$\n由于对每个部分 $k \\in \\{1, 2, 3, \\dots\\}$ 的选择是独立的，总生成函数是这些单个级数对所有可能部分 $k$ 的乘积：\n$$\nP(q,z) = \\prod_{k=1}^{\\infty} \\frac{1}{1 - zq^k}\n$$\n\n### 2. 递推关系的推导\n\n为了推导 $p(n,m)$ 的递推关系，我们首先建立 $P(q,z)$ 的一个函数方程。我们可以将第一项 ($k=1$) 从 $P(q,z)$ 的乘积表达式中分离出来：\n$$\nP(q,z) = \\frac{1}{1 - zq} \\cdot \\prod_{k=2}^{\\infty} \\frac{1}{1 - zq^k}\n$$\n让我们检查右侧的乘积。我们可以通过令 $j = k-1$ 来重新索引，这意味着 $k = j+1$。当 $k$ 从 $2$ 到 $\\infty$ 时，$j$ 从 $1$ 到 $\\infty$：\n$$\n\\prod_{k=2}^{\\infty} \\frac{1}{1 - zq^k} = \\prod_{j=1}^{\\infty} \\frac{1}{1 - zq^{j+1}} = \\prod_{j=1}^{\\infty} \\frac{1}{1 - (zq)q^j}\n$$\n得到的表达式恰好是 $P(q,z)$ 的定义，其中变量 $z$ 被替换为 $zq$。因此，我们有：\n$$\n\\prod_{k=2}^{\\infty} \\frac{1}{1 - zq^k} = P(q, zq)\n$$\n将此代回 $P(q,z)$ 的方程中，得到函数方程：\n$$\nP(q,z) = \\frac{1}{1 - zq} P(q,zq)\n$$\n重新整理这个方程得到：\n$$\n(1 - zq) P(q,z) = P(q, zq)\n$$\n现在，我们将 $P(q,z)$ 的幂级数定义代入此方程：\n$$\n(1 - zq) \\sum_{n,m} p(n,m) q^n z^m = \\sum_{n,m} p(n,m) q^n (zq)^m\n$$\n展开左侧并简化右侧得到：\n$$\n\\sum_{n,m} p(n,m) q^n z^m - \\sum_{n,m} p(n,m) q^{n+1} z^{m+1} = \\sum_{n,m} p(n,m) q^{n+m} z^m\n$$\n为了找到 $p(n,m)$ 的递推关系，我们令方程两侧的一般项 $q^N z^M$ 的系数相等。\n- **项 1 (LHS):** $\\sum_{n,m} p(n,m) q^n z^m$ 中 $q^N z^M$ 的系数就是 $p(N,M)$。\n- **项 2 (LHS):** $\\sum_{n,m} p(n,m) q^{n+1} z^{m+1}$ 中 $q^N z^M$ 的系数对应于 $n+1=N$ 和 $m+1=M$ 的情况，即 $n=N-1$ 和 $m=M-1$。因此系数是 $p(N-1, M-1)$。\n- **项 3 (RHS):** 我们需要 $\\sum_{n,m} p(n,m) q^{n+m} z^m$ 中 $q^N z^M$ 的系数。首先，我们固定 $m=M$。表达式变为 $\\sum_{n} p(n,M) q^{n+M} z^M$。我们需要 $\\sum_{n} p(n,M) q^{n+M}$ 中 $q^N$ 的系数。这对应于 $n+M=N$ 或 $n=N-M$ 的情况。因此系数是 $p(N-M, M)$。\n\n令左右两侧的系数相等，我们得到：\n$$\np(N,M) - p(N-1, M-1) = p(N-M, M)\n$$\n重新整理并使用通用变量 $n$ 和 $m$，我们得到所需的递推关系：\n$$\np(n,m) = p(n-1, m-1) + p(n-m, m)\n$$\n\n### 3. 初始条件与算法实现\n\n要使用此递推关系，我们必须定义初始（或边界）条件。这些条件由 $p(n,m)$ 的定义确定：\n- **$p(0,0) = 1$:** 将 $0$ 分拆成 $0$ 个部分只有一种方法：空分拆。\n- **$p(n,0) = 0$ for $n>0$:** 不可能将一个正整数分拆成零个部分。\n- **$p(0,m) = 0$ for $m>0$:** 不可能将 $0$ 分拆成正数个正整数部分。\n- **$p(n,m) = 0$ if $n  m$:** $m$ 个正整数的和必须至少为 $m$（因为每个部分至少是 $1$）。因此，如果 $n  m$，则不存在这样的分拆。这也意味着如果 $n0$，则 $p(n,m)=0$。\n\n这个递推关系可以使用动态规划高效实现。我们可以构建一个大小为 $(N_{\\max}+1) \\times (M_{\\max}+1)$ 的二维数组，称之为 $DP$，其中 $DP[i,j]$ 将存储 $p(i,j)$ 的值。\n该表用零初始化，并设置基本情况 $DP[0,0] = 1$。然后我们可以使用递推关系填充该表。$DP[i,j]$ 的值依赖于具有较小 $i$ 或较小 $j$ 的值，因此我们可以在外层循环中从 $1$ 到 $M_{\\max}$ 迭代 $j$（部分数量），在内层循环中从 $1$ 到 $N_{\\max}$ 迭代 $i$（要分拆的数）。\n\n对于每个满足 $i \\ge j > 0$ 的对 $(i,j)$：\n$$\nDP[i,j] = DP[i-1,j-1] + DP[i-j,j]\n$$\n如果 $i  j$，则 $DP[i,j] = 0$。项 $DP[i-j,j]$ 仅在 $i \\ge j$ 时才添加，这与边界条件一致。\n\n该算法的时间复杂度由两个嵌套循环决定，使其为 $O(N_{\\max} \\cdot M_{\\max})$。存储 DP 表的空间复杂度也为 $O(N_{\\max} \\cdot M_{\\max})$。考虑到测试套件中的约束，这是非常高效的。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the number of partitions of n into m parts, p(n,m), for a given\n    test suite using a dynamic programming approach based on a derived recurrence.\n\n    The recurrence relation for p(n,m) is p(n,m) = p(n-1, m-1) + p(n-m, m).\n    This is implemented using a 2D DP table.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (0, 0),\n        (0, 1),\n        (1, 1),\n        (5, 2),\n        (5, 3),\n        (5, 4),\n        (5, 5),\n        (10, 3),\n        (7, 10),\n        (50, 1),\n        (20, 5),\n        (30, 10),\n    ]\n\n    # Determine the maximum n and m required for the DP table.\n    n_max = 0\n    m_max = 0\n    if test_cases:\n        n_max = max(case[0] for case in test_cases)\n        m_max = max(case[1] for case in test_cases)\n\n    # DP table to store p(i, j)\n    # dp[i][j] will store the number of partitions of i into j parts.\n    dp = np.zeros((n_max + 1, m_max + 1), dtype=np.int64)\n\n    # Base case: There is one partition of 0 into 0 parts (the empty partition).\n    if n_max >= 0 and m_max >= 0:\n        dp[0, 0] = 1\n\n    # Fill the DP table using the recurrence relation.\n    # The loops must be structured such that dependencies are computed first.\n    # dp[i][j] depends on dp[i-1][j-1] (previous j) and dp[i-j][j] (previous i).\n    # Iterating j in the outer loop and i in the inner loop satisfies this.\n    for j in range(1, m_max + 1):\n        for i in range(1, n_max + 1):\n            # Recurrence relation: p(n,m) = p(n-1, m-1) + p(n-m, m)\n            \n            # Term p(n-1, m-1)\n            term1 = dp[i-1, j-1]\n            \n            # Term p(n-m, m). This term is only valid if n >= m.\n            term2 = 0\n            if i >= j:\n                term2 = dp[i-j, j]\n            \n            dp[i, j] = term1 + term2\n\n    # Collect results for the specified test cases.\n    results = []\n    for n, m in test_cases:\n        results.append(dp[n, m])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3085480"}]}