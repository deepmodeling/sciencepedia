{"hands_on_practices": [{"introduction": "默滕斯第二定理为素数倒数之和提供了一个令人惊讶的简洁近似。这个动手实践练习将让我们通过编写代码来计算这个和，并将其与理论近似值 $\\ln(\\ln x)$ 进行直接比较，从而亲眼见证该定理的实际效果。通过这种方式，我们可以直观地感受定理的精确度以及其误差项的行为 [@problem_id:3017421]。", "problem": "设计并实现一个完整的程序，该程序对关于素数倒数和的默滕斯第二定理进行经验性探究。令 $p$ 表示一个素数，对于任意实数 $x \\ge 2$，定义部分和 $S(x) = \\sum_{p \\le x} \\frac{1}{p}$。默滕斯第二定理断言，当 $x \\to \\infty$ 时，$S(x) - \\ln(\\ln x)$ 趋近于一个常数 $B_1$。本练习的目标是建立一个经验性测试，该测试针对一组输入值 $x$，计算 $S(x)$，将其与 $\\ln(\\ln x)$ 进行比较，并通过一种受重采样启发的近似方法，为导出的估计量 $B_1(x) = S(x) - \\ln(\\ln x)$ 构建一个经验置信区间。\n\n您必须基于以下基础进行操作：\n- 素数集合：素数是只能被 $1$ 和自身整除的整数 $p \\ge 2$。\n- 自然对数函数 $\\ln$ 及其复合函数 $\\ln(\\ln x)$（对于 $x > 1$）。\n- 埃拉托斯特尼筛法是一种有效的算法，可用于枚举直至给定上限 $X$ 的所有素数。\n- 有限多重集的基本统计量：对于数据 $y_1,\\dots,y_n$，样本均值为 $\\bar y = \\frac{1}{n}\\sum_{i=1}^n y_i$，当 $n \\ge 2$ 时无偏样本方差为 $s^2 = \\frac{1}{n-1}\\sum_{i=1}^n (y_i - \\bar y)^2$，以及在经验重采样模型下为位置参数构建对称双边置信区间的正态近似。\n\n您的程序必须：\n- 使用埃拉托斯特尼筛法生成测试套件中最大 $x$ 值之前的所有素数。\n- 对每个测试值 $x$，计算 $S(x) = \\sum_{p \\le x} \\frac{1}{p}$、$L(x) = \\ln(\\ln x)$ 和经验估计量 $B_1(x) = S(x) - L(x)$。\n- 为量化由有限截断引起的经验不确定性，请使用以下受重采样启发的近似方法，为 $B_1(x)$ 构建一个置信水平为 $0.95$ 的对称双边置信区间。将大小为 $n = \\pi(x)$ 的多重集 $\\{\\frac{1}{p} : p \\le x\\}$ 视为来自未知分布的一个经验样本，计算其样本标准差 $s$，并通过 $\\operatorname{SE}_{\\mathrm{sum}} \\approx s \\sqrt{n}$ 近似其和的标准误。然后构建一个正态近似区间\n$$\n\\bigl[B_1(x) - z_{0.975}\\,\\operatorname{SE}_{\\mathrm{sum}},\\; B_1(x) + z_{0.975}\\,\\operatorname{SE}_{\\mathrm{sum}}\\bigr],\n$$\n其中 $z_{0.975}$ 是上 $0.975$ 标准正态分位数。对于 $n = 1$ 的情况，取 $s = 0$，从而得到一个宽度为零的退化区间。\n- 全程使用自然对数。\n\n测试套件：\n- 使用以下输入 $x \\in \\{2, 10, 10^3, 10^5, 10^6\\}$。\n- 对每个 $x$，输出包含六个浮点数的元组 $[x, S(x), L(x), B_1(x), \\mathrm{CI}_{\\mathrm{low}}(x), \\mathrm{CI}_{\\mathrm{high}}(x)]$，其中 $\\mathrm{CI}_{\\mathrm{low}}(x)$ 和 $\\mathrm{CI}_{\\mathrm{high}}(x)$ 是上述置信区间的下限和上限。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含五个测试用例的结果，格式为用方括号括起来的、以逗号分隔的列表的列表，不含空格。具体来说，输出必须采用\n$\n\\bigl[\n[x_1,S(x_1),L(x_1),B_1(x_1),\\mathrm{CI}_{\\mathrm{low}}(x_1),\\mathrm{CI}_{\\mathrm{high}}(x_1)],\n\\ldots,\n[x_5,S(x_5),L(x_5),B_1(x_5),\\mathrm{CI}_{\\mathrm{low}}(x_5),\\mathrm{CI}_{\\mathrm{high}}(x_5)]\n\\bigr]\n$\n的形式，其中每个数值条目都呈现为浮点数。置信水平必须为 $0.95$，并且所有对数均为自然对数。\n\n覆盖范围考虑：\n- $x=2$ 的情况测试了 $n=1$ 的边界条件。\n- $x=10$ 的情况测试了波动较大的小 $x$ 值。\n- $x=10^3, 10^5, 10^6$ 的情况探究了逐渐增大的 $x$ 值，此时 $B_1(x)$ 应表现出稳定趋势，而经验区间的宽度在上述建模假设下会收缩。\n\n您的程序必须是自包含的，不需要任何输入，并且必须在标准环境中运行，不得读取或写入文件或使用网络访问。所有计算都必须使用浮点数算术完成，并具有足够的精度以显示所要求的值。最终打印的行必须与上述确切格式相匹配。", "solution": "我们旨在通过计算 $B_1(x) = S(x) - \\ln(\\ln x)$ 来经验性地检验 $S(x) = \\sum_{p \\le x} \\frac{1}{p}$ 相对于 $\\ln(\\ln x)$ 的行为，并对默滕斯第二定理中的常数 $B_1$ 进行数值估计。目标是从第一性原理出发，仅使用素数的定义、自然对数、枚举素数的算法和初等统计学来完成此任务。\n\n步骤 $1$：生成测试套件中最大 $x$ 值之前的所有素数。埃拉托斯特尼筛法可以在接近于 $X$ 的线性时间内构造出直至上限 $X$ 的所有素数：\n- 初始化一个长度为 $X+1$ 的布尔数组，其条目对应于整数 $0,1,\\dots,X$。\n- 将 $0$ 和 $1$ 标记为合数（非素数）。\n- 对于从 $2$ 到 $\\lfloor \\sqrt{X} \\rfloor$ 的每个整数 $m$，如果 $m$ 是素数，则将其所有倍数 $m^2, m^2+m, \\dots$ 直至 $X$ 标记为合数。\n- 未被标记的条目即代表直至 $X$ 的素数。\n\n令 $X_{\\max}$ 为所要求的 $x$ 值的最大值。我们对直至 $X_{\\max}$ 的范围进行一次筛选，以获得有序的素数列表 $p_1  p_2  \\cdots  p_{\\pi(X_{\\max})}$。这对所有测试用例的素数生成成本进行了摊销。\n\n步骤 $2$：预计算素数倒数及其平方的部分和。定义序列 $r_i = \\frac{1}{p_i}$，其中 $i = 1, \\dots, \\pi(X_{\\max})$。计算累积和\n$\nR_k = \\sum_{i=1}^k r_i\n$\n和\n$\nQ_k = \\sum_{i=1}^k r_i^2\n$\n，其中 $k = 1, \\dots, \\pi(X_{\\max})$。\n对于任意给定的 $x$，令 $n = \\pi(x)$ 为小于等于 $x$ 的素数个数，并令 $k=n$。则\n$\nS(x) = R_k.\n$\n\n步骤 $3$：对于 $x > 1$，使用自然对数计算 $L(x) = \\ln(\\ln x)$；对于所有测试值，我们有 $x \\ge 2$，因此 $L(x)$ 是有定义的。\n\n步骤 $4$：通过 $B_1(x) = S(x) - L(x)$ 定义 $B_1$ 在 $x$ 处的经验估计量。\n如果默滕斯第二定理成立，可以预期随着 $x$ 的增长，$B_1(x)$ 会趋近一个常数。\n\n步骤 $5$：通过受重采样启发的近似方法为 $B_1(x)$ 构建经验置信区间。我们并非在为素数序列中的任何真实随机性建模；相反，我们在探索性数据分析中使用一种标准启发式方法：将在给定 $x$ 处观察到的增量有限多重集 $\\{r_1, \\dots, r_n\\}$ 视为来自未知分布的样本，并用自助法-正态标准误来近似其和的变异性。在独立同分布的启发式模型下，样本均值 $\\bar r = \\frac{1}{n}\\sum_{i=1}^n r_i$ 的抽样方差近似为 $s^2 / n$，其中 $s^2$ 是当 $n \\ge 2$ 时的无偏样本方差\n$\ns^2 = \\frac{1}{n-1}\\sum_{i=1}^n (r_i - \\bar r)^2\n$\n。由于 $S(x) = \\sum_{i=1}^n r_i = n \\bar r$，其和的近似标准误为\n$\n\\operatorname{SE}_{\\mathrm{sum}} \\approx \\sqrt{\\operatorname{Var}(n \\bar r)} \\approx \\sqrt{n^2 \\cdot \\frac{s^2}{n}} = s \\sqrt{n}.\n$\n然后我们使用标准正态分位数 $z_{0.975}$ 构建一个置信水平为 $0.95$ 的对称双边正态近似区间：\n$\n\\bigl[S(x) - z_{0.975}\\, s \\sqrt{n},\\; S(x) + z_{0.975}\\, s \\sqrt{n}\\bigr].\n$\n因为 $B_1(x) = S(x) - L(x)$ 且对于固定的 $x$，$L(x)$ 是确定性的，所以 $B_1(x)$ 的导出区间可以通过从端点减去 $L(x)$ 得到：\n$\n\\bigl[B_1(x) - z_{0.975}\\, s \\sqrt{n},\\; B_1(x) + z_{0.975}\\, s \\sqrt{n}\\bigr].\n$\n对于边界情况 $n=1$（在 $x=2$ 时发生），无偏样本方差是未定义的。在这种情况下，我们设定 $s=0$，从而得到一个宽度为零的退化区间，这对于这种经验性构造是一个合理的约定。\n\n步骤 $6$：跨多个 $x$ 的高效计算。在准备好累积和 $R_k$ 和 $Q_k$ 以及素数列表后，我们可以对每个 $x$ 通过二分搜索找到 $n = \\pi(x)$，提取 $S(x) = R_n$，计算样本均值 $\\bar r = R_n / n$，对于 $n \\ge 2$ 计算\n$\ns^2 = \\frac{Q_n - n \\bar r^2}{n-1}\n$\n，然后使用固定常数 $z_{0.975}$ 构建置信区间。这种方法运行时间主要由直至 $X_{\\max}$ 的筛选过程决定，并且只需要 $O(X_{\\max})$ 的内存用于筛选，以及 $O(\\pi(X_{\\max}))$ 的内存用于存储素数列表和累积数组。\n\n测试套件和输出：我们在 $x \\in \\{2, 10, 10^3, 10^5, 10^6\\}$ 处进行评估，这探究了一个边界情况、一个小数值情况和三个逐渐增大的情况。对于每个 $x$，我们以浮点数形式输出一个 $6$ 元组\n$\n[x, S(x), L(x), B_1(x), \\mathrm{CI}_{\\mathrm{low}}(x), \\mathrm{CI}_{\\mathrm{high}}(x)]\n$\n，输出为单行、无空格、以逗号分隔的列表的列表。这种格式便于自动检查，并且可以直接从提供的定义中计算得出。\n\n科学解释：所得的 $B_1(x)$ 值应缓慢漂移，并根据默滕斯第二定理，趋向一个常数。在重采样启发式方法下，经验区间会随着 $x$ 的增加而收缩，因为在这种构造中 $s \\sqrt{n}$ 的增长速度慢于 $B_1(x)$ 的稳定速度；然而，必须强调的是，这些区间是启发式的，并不构成严格的数论误差界。它们作为一个经验性诊断工具，表明统计量 $B_1(x)$ 在整个测试套件中正在趋于稳定。\n\n所有必需的计算仅使用开篇所述的定义和经过充分测试的算法，并且程序遵守指定的输出要求。", "answer": "```python\nimport numpy as np\nimport math\n\ndef sieve_primes(n):\n    \"\"\"Return a numpy array of all primes = n using the Sieve of Eratosthenes.\"\"\"\n    if n  2:\n        return np.array([], dtype=np.int64)\n    sieve = np.ones(n + 1, dtype=bool)\n    sieve[:2] = False\n    limit = int(n**0.5)\n    for p in range(2, limit + 1):\n        if sieve[p]:\n            sieve[p*p:n+1:p] = False\n    return np.nonzero(sieve)[0]\n\ndef compute_results(x_values, z_quantile=1.959963984540054):\n    \"\"\"\n    For each x in x_values, compute:\n    - x as float\n    - S(x) = sum_{p=x} 1/p\n    - L(x) = ln(ln(x))\n    - B1_hat(x) = S(x) - L(x)\n    - CI_low, CI_high: normal-approx empirical CI using s*sqrt(n)\n    \"\"\"\n    Xmax = int(max(x_values))\n    primes = sieve_primes(Xmax)\n    if primes.size == 0:\n        recips = np.array([], dtype=float)\n    else:\n        recips = 1.0 / primes.astype(float)\n\n    # Precompute cumulative sums of reciprocals and their squares\n    if recips.size > 0:\n        cum1 = np.cumsum(recips)              # R_k\n        cum2 = np.cumsum(recips * recips)     # Q_k\n    else:\n        cum1 = np.array([], dtype=float)\n        cum2 = np.array([], dtype=float)\n\n    results = []\n    for x in x_values:\n        # count of primes = x\n        n = int(np.searchsorted(primes, x, side='right'))\n        if n == 0:\n            Sx = 0.0\n            Lx = float('nan')\n            Bhat = float('nan')\n            ci_low = float('nan')\n            ci_high = float('nan')\n        else:\n            Sx = float(cum1[n-1])\n            # natural logs\n            Lx = math.log(math.log(float(x)))\n            Bhat = Sx - Lx\n            if n == 1:\n                s = 0.0\n            else:\n                mean = Sx / n\n                # unbiased sample variance from cumulative sums:\n                var = (float(cum2[n-1]) - n * mean * mean) / (n - 1)\n                # Numerical guard\n                if var  0.0 and var > -1e-18:\n                    var = 0.0\n                s = math.sqrt(var) if var > 0.0 else 0.0\n            se_sum = s * math.sqrt(n)\n            half_width = z_quantile * se_sum\n            ci_low = Bhat - half_width\n            ci_high = Bhat + half_width\n\n        results.append([float(x), Sx, Lx, Bhat, ci_low, ci_high])\n\n    return results\n\ndef format_results_no_spaces(results, precision=12):\n    \"\"\"\n    Format the list of lists with no spaces, with each float shown to given precision.\n    \"\"\"\n    inner_strs = []\n    fmt = \"{:.\" + str(precision) + \"f}\"\n    for row in results:\n        row_str = \"[\" + \",\".join(fmt.format(float(v)) for v in row) + \"]\"\n        inner_strs.append(row_str)\n    return \"[\" + \",\".join(inner_strs) + \"]\"\n\ndef solve():\n    test_cases = [2, 10, 1000, 100000, 1000000]\n\n    results = compute_results(test_cases, z_quantile=1.959963984540054)\n    output = format_results_no_spaces(results, precision=12)\n\n    print(output)\n\nsolve()\n```", "id": "3017421"}, {"introduction": "继对素数倒数和的探索之后，我们转向默滕斯第三定理，它通过一个乘积表达式揭示了素数的集体行为。这项实践将指导你编写一个程序，以数值方式检验该定理的预测，即素数乘积 $\\prod_{p \\le x} (1-1/p)$ 在经过 $\\ln x$ 缩放后会收敛到一个与欧拉-马歇罗尼常数相关的常数 [@problem_id:3087061]。这个练习不仅能加深你对理论的理解，还能锻炼你处理数值计算和数据分析的技能。", "problem": "您需要设计并实现一个完整的程序，以数值方式研究与数论中的默滕斯定理相关的性质。对于实数 $x \\geq 1$，通过如下分段常数方式扩展定义函数 $P(x)$：对于每个整数 $n \\geq 1$，令\n$$\nP(n) \\;=\\; \\prod_{p \\leq n} \\left( 1 - \\frac{1}{p} \\right),\n$$\n其中乘积遍及所有小于等于 $n$ 的素数 $p$。对于非整数 $x$，定义 $P(x)$ 为 $P(x) = P(\\lfloor x \\rfloor)$。令 $L(x)$ 表示缩放后的乘积\n$$\nL(x) \\;=\\; (\\ln x)\\, P(x),\n$$\n其中 $\\ln$ 表示自然对数。您的目标是：\n- 测试当 $x$ 在整数上增加时 $P(x)$ 的单调性。\n- 在给定的样本集上量化 $L(x)$ 的近似恒定性。\n\n您的推理和设计必须基于基本定义和经过充分检验的事实：\n- 素数是大于 $1$ 且除了 $1$ 和自身外没有其他正因数的正整数。\n- 乘积 $P(n)$ 的定义是，对所有小于等于 $n$ 的素数 $p$，将因子 $(1 - 1/p)$ 相乘。\n- 自然对数 $\\ln x$ 在 $x > 0$ 时是严格递增的。\n\n需要实现的任务：\n1. 素数生成与累积乘积：\n   - 使用一种正确且高效的、仅基于素数定义的方法（例如，筛法），生成所有小于等于最大界限 $N_{\\max}$ 的素数。\n   - 计算累积序列 $(P(n))_{n=1}^{N_{\\max}}$，仅当 $n$ 是素数时进行更新，因为对于合数 $n$，没有新的因子加入乘积。\n\n2. 单调性测试：\n   - 对于每个界限 $N$，检查序列 $(P(1),P(2),\\dots,P(N))$ 是否为非增序列。因为每个新因子 $(1 - 1/p)$ 都满足 $0  (1 - 1/p)  1$，理想的精确算术将意味着 $P(n)$ 关于 $n$ 是非增的。在浮点数算术中，比较连续值时应允许一个最小的数值容差。\n\n3. $L(x)$ 的近似恒定性度量：\n   - 对于给定的界限 $N$ 和指定的样本集 $S \\subseteq \\{2,3,\\dots,N\\}$，定义采样值列表 $\\{L(x) : x \\in S\\}$。\n   - 通过无量纲比率来量化近似恒定性\n     $$\n     R(S) \\;=\\; \\frac{\\max_{x \\in S} L(x) \\;-\\; \\min_{x \\in S} L(x)}{\\mathrm{median}\\,\\{L(x) : x \\in S\\}},\n     $$\n     前提是中位数为正；如果中位数为零，则在该情况下设 $R(S) = 0$。\n   - 您必须为两种类型的样本集计算此比率：\n     - 整数样本集 $S_{\\mathrm{int}}(N) = \\{2,3,\\dots,N\\}$。\n     - 素数样本集 $S_{\\mathrm{prime}}(N) = \\{p \\leq N : p \\text{ 是素数}\\}$。\n   该度量用于检验默滕斯定理所启示的观点，即 $L(x)$ 随 $x$ 变化缓慢；计算应包括小素数和中等范围。\n\n测试套件：\n- 您的程序必须在无输入的情况下运行，并为以下六个参数集 $(N,\\mathrm{mode})$ 计算结果，其中 $\\mathrm{mode}$ 指示用于近似恒定性度量的样本集：\n  1. $(2,\\text{\"integers\"})$ 使用 $S_{\\mathrm{int}}(2)$。\n  2. $(2,\\text{\"primes\"})$ 使用 $S_{\\mathrm{prime}}(2)$。\n  3. $(30,\\text{\"integers\"})$ 使用 $S_{\\mathrm{int}}(30)$。\n  4. $(30,\\text{\"primes\"})$ 使用 $S_{\\mathrm{prime}}(30)$。\n  5. $(100000,\\text{\"integers\"})$ 使用 $S_{\\mathrm{int}}(100000)$。\n  6. $(100000,\\text{\"primes\"})$ 使用 $S_{\\mathrm{prime}}(100000)$。\n\n对于每个测试用例，您的程序必须输出一个双元素列表 $[b, r]$，其中 $b$ 是一个布尔值，指示 $(P(n))_{n=1}^{N}$ 是否为非增序列，而 $r$ 是指定样本集 $S$ 的 $R(S)$ 的浮点值。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表，列表中的每个元素对应于上面列出的一个测试用例，并且本身是一个双元素列表 $[b,r]$。例如，一个语法上有效的格式是\n  $$\n  [[\\text{True},0.0123],[\\text{True},0.0456],\\dots]\n  $$\n- 本问题不涉及物理单位或角度。所有数值答案均为无单位的实数。", "solution": "用户希望为一个计算数论问题编写解决方案。以下是该解决方案的分解说明。\n\n**1. 问题验证**\n该问题被认为是有效的，因为它在科学上基于数论（特别是与默滕斯定理相关的概念），问题陈述清晰，具有明确的定义和目标，并且没有歧义或矛盾。计算任务在指定的限制内是可行的。\n\n**2. 解决方案设计**\n解决方案的核心是首先预计算所需的最大界限 $N_{\\max} = 100000$ 内的必要数论数据，然后遍历指定的测试用例以执行所需的分析。\n\n**2.1. 预计算阶段**\n- **素数生成**：使用埃拉托斯特尼筛法（Sieve of Eratosthenes）生成所有小于等于 $N_{\\max}$ 的素数。此方法非常高效。创建一个大小为 $N_{\\max}+1$ 的布尔数组 `is_prime`，并将其初始化为真。然后我们从 $i=2$ 迭代到 $\\sqrt{N_{\\max}}$。如果 $i$ 被标记为素数，则其所有倍数（从 $i^2$ 开始）都被标记为合数（非素数）。这样就填充了 `is_prime` 数组，从中可以提取出素数列表。\n\n- **累积乘积 $P(n)$**：乘积序列 $(P(n))_{n=1}^{N_{\\max}}$ 是迭代计算的。问题定义 $P(n) = \\prod_{p \\leq n} (1 - 1/p)$，其中 $p$ 是素数。这意味着如果 $n$ 不是素数，则 $P(n) = P(n-1)$；如果 $n$ 是素数，则 $P(n) = P(n-1) \\times (1 - 1/n)$。我们创建一个大小为 $N_{\\max}+1$ 的浮点数数组 `P_values`。我们初始化 $P(1) = 1$（作为空积）。然后，对于从 $2$ 到 $N_{\\max}$ 的 $n$，我们设置 $P(n) = P(n-1)$，如果 $n$ 是素数，则再乘以新的因子：\n$$\nP(n) = \\begin{cases}\n    P(n-1) \\times \\left(1 - \\frac{1}{n}\\right)  \\text{if } n \\text{ is prime} \\\\\n    P(n-1)  \\text{if } n \\text{ is composite or } 1\n\\end{cases}\n$$\n基准情况为 $P(1) = 1$。这直接实现了函数对于整数参数的分段常数特性。\n\n**2.2. 测试用例处理**\n对于由界限 $N$ 和样本模式指定的每个测试用例，我们执行两个主要任务：\n\n- **单调性测试**：我们必须验证序列 $(P(1), P(2), \\dots, P(N))$ 是否为非增序列。这是通过从 $n=2$ 迭代到 $N$ 并检查条件 $P(n) \\leq P(n-1)$ 是否成立来完成的。由于潜在的浮点不精确性，检查实现为 $P(n) \\leq P(n-1) + \\epsilon$，其中 $\\epsilon$ 是一个小的正容差（例如 $10^{-12}$）。如果对于任何 $n$ 违反了此不等式，则布尔标志 $b$ 设置为 `False`。否则，它保持为 `True`。\n\n- **近似恒定性度量 $R(S)$**：此任务量化 $L(x) = (\\ln x) P(x)$ 的变化。\n    1.  **构建样本集 $S$**：根据模式，样本集 $S$ 要么是所有从 $2$ 到 $N$ 的整数集合，记为 $S_{\\mathrm{int}}(N) = \\{2, 3, \\dots, N\\}$，要么是所有小于等于 $N$ 的素数集合，记为 $S_{\\mathrm{prime}}(N) = \\{p \\leq N : p \\text{ 是素数}\\}$。\n    2.  **评估 $L(x)$**：对于每个整数 $x \\in S$，我们计算 $L(x) = (\\ln x) P(x)$。由于 $x$ 是整数，$P(x)$ 就是预先计算的值 `P_values[x]`。这将生成一个值列表 $\\{L(x) : x \\in S\\}$。\n    3.  **计算度量 $R(S)$**：近似恒定性比率 $R(S)$ 使用以下公式计算：\n        $$\n        R(S) = \\frac{\\max_{x \\in S} L(x) - \\min_{x \\in S} L(x)}{\\mathrm{median}\\,\\{L(x) : x \\in S\\}}\n        $$\n        使用 `numpy` 函数可以高效地计算 $L(x)$ 值列表的最大值、最小值和中位数。如果样本集 $S$ 为空或只包含一个元素，则分子为 $0$，因此 $R(S) = 0$。根据问题要求，中位数为零的特殊情况也已处理，尽管对于 $N \\ge 2$ 这种情况不会发生。\n\n**3. 实现与最终输出**\n整个逻辑被封装在一个使用 `numpy` 库进行数值运算的 Python 脚本中。该脚本遍历六个预定义的测试用例，为每个用例计算配对 $[b, r]$ 并存储它们。最后，结果被格式化为一个表示列表的列表的单个字符串，例如 `[[True,0.123],[False,4.56]]`，并打印到标准输出。这种格式化经过精心构造，以匹配所需的输出规范，不含多余的空白字符。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes results for a numerical investigation of Mertens' theorems.\n    \"\"\"\n    test_cases = [\n        (2, \"integers\"),\n        (2, \"primes\"),\n        (30, \"integers\"),\n        (30, \"primes\"),\n        (100000, \"integers\"),\n        (100000, \"primes\"),\n    ]\n\n    N_max = 0\n    if test_cases:\n        N_max = max(n for n, mode in test_cases)\n\n    if N_max > 0:\n        is_prime = np.ones(N_max + 1, dtype=bool)\n        if N_max >= 0:\n            is_prime[0] = False\n        if N_max >= 1:\n            is_prime[1] = False\n        for i in range(2, int(np.sqrt(N_max)) + 1):\n            if is_prime[i]:\n                is_prime[i*i::i] = False\n        \n        prime_numbers = np.where(is_prime)[0]\n\n        P_values = np.zeros(N_max + 1, dtype=np.float64)\n        if N_max >= 1:\n            P_values[1] = 1.0\n        \n        for n in range(2, N_max + 1):\n            P_values[n] = P_values[n-1]\n            if is_prime[n]:\n                P_values[n] *= (1.0 - 1.0 / n)\n\n    results = []\n    for N, mode in test_cases:\n        is_non_increasing = True\n        tolerance = 1e-12\n        for n in range(2, N + 1):\n            if P_values[n] > P_values[n-1] + tolerance:\n                is_non_increasing = False\n                break\n        \n        sample_set = np.array([], dtype=int)\n        if mode == \"integers\":\n            if N >= 2:\n                sample_set = np.arange(2, N + 1)\n        elif mode == \"primes\":\n            sample_set = prime_numbers[prime_numbers = N]\n        \n        r_metric = 0.0\n        if sample_set.size > 0:\n            L_values = np.log(sample_set) * P_values[sample_set]\n            \n            if L_values.size > 0:\n                L_median = np.median(L_values)\n                if L_median > 0:\n                    L_max = np.max(L_values)\n                    L_min = np.min(L_values)\n                    r_metric = (L_max - L_min) / L_median\n        \n        results.append([is_non_increasing, r_metric])\n\n    inner_strings = [f\"[{b},{r}]\" for b, r in results]\n    print(f\"[{','.join(inner_strings)}]\")\n\nsolve()\n```", "id": "3087061"}, {"introduction": "最后一个实践练习将带我们更深入地探究数论的优美结构。默滕斯定理中出现的常数并非各自独立，而是通过一个精确的恒等式相互关联。这项练习旨在通过计算来检验这个美妙的联系，即 $C - B_{1} = -\\gamma$，其中 $B_{1}$ 来自第二定理，而 $\\gamma$ 与第三定理相关 [@problem_id:3087073]。完成这项任务将有力地印证该理论的内在一致性与和谐之美。", "problem": "您需要编写一个完整的程序，对一个依赖于素数的常数的收敛级数进行数值评估，并在规定的数值公差内验证一个默滕斯恒等式。请使用纯数学术语和自然对数进行运算。所有数学符号必须按照数论中的标准含义进行解释。不涉及任何物理单位。\n\n定义和基本依据：\n- 令 $\\mathbb{P}$ 表示素数集合。\n- 定义常数\n$$\nC \\;=\\; -\\sum_{p \\in \\mathbb{P}} \\sum_{k \\ge 2} \\frac{1}{k\\,p^k}.\n$$\n- Meissel–Mertens 常数 $B_{1}$ 由默滕斯第二定理 (Mertens' second theorem) 中的极限定义：\n$$\n\\sum_{p \\le x} \\frac{1}{p} \\;=\\; \\ln(\\ln x) \\;+\\; B_{1} \\;+\\; o(1) \\quad \\text{as } x \\to \\infty.\n$$\n- 欧拉-马歇罗尼常数 (Euler–Mascheroni constant) $\\gamma$ 是出现在默滕斯第三定理 (Mertens' third theorem) 中的常数：\n$$\n\\prod_{p \\le x} \\left(1 - \\frac{1}{p}\\right) \\;\\sim\\; \\frac{e^{-\\gamma}}{\\ln x} \\quad \\text{as } x \\to \\infty,\n$$\n等价地，\n$$\n\\sum_{p \\le x} \\ln\\!\\left(1 - \\frac{1}{p}\\right) \\;=\\; -\\ln(\\ln x) \\;-\\; \\gamma \\;+\\; o(1).\n$$\n- 幂级数恒等式\n$$\n\\ln(1 - z) \\;=\\; -\\sum_{k \\ge 1} \\frac{z^k}{k}, \\quad |z|1,\n$$\n将用作一个基本的分析工具。\n\n任务：\n1) 使用直到截断值 $P_{C}$ 的所有素数，通过其绝对收敛的重构形式对 $C$ 进行数值近似：\n$$\nC \\;=\\; \\sum_{p \\in \\mathbb{P}} \\left[\\ln\\!\\left(1 - \\frac{1}{p}\\right) + \\frac{1}{p}\\right],\n$$\n因此，一个实际的近似计算式是：\n$$\nC(P_{C}) \\;=\\; \\sum_{p \\le P_{C}} \\left[\\ln\\!\\left(1 - \\frac{1}{p}\\right) + \\frac{1}{p}\\right].\n$$\n2) 使用直到截断值 $P_{B}$ 的所有素数，通过以下公式独立地近似 $B_{1}$：\n$$\nB_{1}(P_{B}) \\;=\\; \\sum_{p \\le P_{B}} \\frac{1}{p} \\;-\\; \\ln(\\ln P_{B}).\n$$\n3) 使用欧拉-马歇罗尼常数 $\\gamma$ 的数值，通过检验是否满足以下条件，在给定的绝对容差 $\\tau$ 内验证恒等式\n$$\nC \\;-\\; B_{1} \\;=\\; -\\gamma\n$$\n$$\n\\left|\\, C(P_{C}) \\;-\\; B_{1}(P_{B}) \\;+\\; \\gamma \\,\\right| \\;\\le\\; \\tau.\n$$\n\n实现要求：\n- 对每个测试实例，使用高效的素数筛法来枚举所有直到 $\\max\\{P_{C}, P_{B}\\}$ 的素数。\n- 所有地方都使用自然对数。为了在计算 $\\ln\\!\\left(1 - \\frac{1}{p}\\right)$ 时提高数值稳定性，可以使用数值稳定的变换 $\\ln(1 - u) = \\text{log1p}(-u)$，其中 $u = \\frac{1}{p}$。\n- 最终输出必须为整数，如果验证通过容差测试，则值为 $1$，否则为 $0$。\n\n测试套件：\n对以下参数三元组 $(P_{C}, P_{B}, \\tau)$ 运行您的程序：\n- 案例 1 (小规模，类边界情况)：$(P_{C}, P_{B}, \\tau) = (30000, 400000, 0.05)$。\n- 案例 2 (中等规模)：$(P_{C}, P_{B}, \\tau) = (150000, 1500000, 0.02)$。\n- 案例 3 (较大规模)：$(P_{C}, P_{B}, \\tau) = (1000000, 5000000, 0.01)$。\n\n最终输出格式：\n您的程序应产生单行输出，其中包含上述案例的通过或失败结果，形式为一个用方括号括起来的逗号分隔的整数列表，例如，“[1,0,1]”。如果绝对偏差 $\\left|C(P_{C}) - B_{1}(P_{B}) + \\gamma\\right|$ 至多为 $\\tau$，则每个条目为 $1$，否则为 $0$。不应打印任何其他输出。", "solution": "该问题陈述被认为是有效的。它在科学上植根于解析数论的原理，特别是关于默滕斯定理 (Mertens' theorems) 及相关的素数和常数。该问题是适定的，为唯一的、可计算的数值验证提供了所有必要的定义、约束和数据。其术语精确客观，计算任务是可行的。\n\n问题的核心是数值验证恒等式 $C - B_{1} = -\\gamma$，该恒等式可以重写为 $C - B_{1} + \\gamma = 0$。这里，$C$ 是一个定义在素数和上的常数，$B_{1}$ 是 Meissel–Mertens 常数，$\\gamma$ 是欧拉-马歇罗尼常数 (Euler–Mascheroni constant)。我们将首先根据给定的定义建立这个恒等式，然后概述其验证的数值算法。\n\n提供的基本定义是：\n1. 来自默滕斯第二定理 (Mertens' second theorem) 的 Meissel–Mertens 常数 $B_{1}$：\n$$ \\sum_{p \\le x} \\frac{1}{p} = \\ln(\\ln x) + B_{1} + o(1) $$\n2. 来自默滕斯第三定理 (Mertens' third theorem) 的涉及欧拉-马歇罗尼常数 $\\gamma$ 的关系：\n$$ \\sum_{p \\le x} \\ln\\left(1 - \\frac{1}{p}\\right) = -\\ln(\\ln x) - \\gamma + o(1) $$\n将这两个渐近关系相加，我们得到：\n$$ \\sum_{p \\le x} \\left[ \\ln\\left(1 - \\frac{1}{p}\\right) + \\frac{1}{p} \\right] = (\\ln(\\ln x) + B_{1}) + (-\\ln(\\ln x) - \\gamma) + o(1) $$\n$$ \\sum_{p \\le x} \\left[ \\ln\\left(1 - \\frac{1}{p}\\right) + \\frac{1}{p} \\right] = B_{1} - \\gamma + o(1) $$\n当 $x \\to \\infty$ 时取极限，$o(1)$ 项消失。左侧的和收敛，这个极限恰好是从其原始定义推导出的常数 $C$。\n使用幂级数 $\\ln(1-z) = -\\sum_{k \\ge 1} \\frac{z^k}{k}$，其中 $z = 1/p$：\n$$ \\ln\\left(1 - \\frac{1}{p}\\right) = -\\frac{1}{p} - \\sum_{k=2}^{\\infty} \\frac{1}{k p^k} $$\n$$ \\ln\\left(1 - \\frac{1}{p}\\right) + \\frac{1}{p} = -\\sum_{k=2}^{\\infty} \\frac{1}{k p^k} $$\n对所有素数 $p \\in \\mathbb{P}$ 求和：\n$$ \\sum_{p \\in \\mathbb{P}} \\left[ \\ln\\left(1 - \\frac{1}{p}\\right) + \\frac{1}{p} \\right] = -\\sum_{p \\in \\mathbb{P}} \\sum_{k=2}^{\\infty} \\frac{1}{k p^k} = C $$\n因此，我们建立了待验证的恒等式：$C = B_{1} - \\gamma$，或 $C - B_{1} + \\gamma = 0$。\n\n数值程序将近似此恒等式的左侧，并检查其绝对值是否在给定的容差 $\\tau$ 内。$C$ 和 $B_{1}$ 的近似值是通过在有限的截断值 $P_{C}$ 和 $P_{B}$ 处截断关于素数的无穷和来计算的。\n\n算法流程如下：\n1.  **素数生成**：实现一个高效的素数筛法，即埃拉托斯特尼筛法 (Sieve of Eratosthenes)，以生成所有直到任何测试用例所需的最大截断值 $\\max\\{P_{C}, P_{B}\\}$ 的素数。为优化性能，此操作只执行一次。\n2.  **$C$ 的近似**：对于每个测试用例 $(P_{C}, P_{B}, \\tau)$，通过 $C(P_{C})$ 近似 $C$ 的值：\n    $$ C(P_{C}) = \\sum_{p \\le P_{C}} \\left[\\ln\\left(1 - \\frac{1}{p}\\right) + \\frac{1}{p}\\right] $$\n    其中和是对所有不超过 $P_{C}$ 的素数 $p$ 进行的。为了数值稳定性，项 $\\ln(1-1/p)$ 计算为 `log1p(-1/p)`，这对于小的 $1/p$ 值更精确。为提高效率，采用了 `numpy` 的向量化计算。\n3.  **$B_{1}$ 的近似**：同时，通过 $B_{1}(P_{B})$ 近似 $B_{1}$ 的值：\n    $$ B_{1}(P_{B}) = \\sum_{p \\le P_{B}} \\frac{1}{p} - \\ln(\\ln P_{B}) $$\n    这涉及对所有直到截断值 $P_{B}$ 的素数 $p$ 的倒数求和，并减去 $\\ln(\\ln P_{B})$ 项。\n4.  **验证**：欧拉-马歇罗尼常数 $\\gamma$ 是一个标准数学常数，其值从 `numpy.euler_gamma` 获取。然后通过计算绝对偏差来进行验证测试：\n    $$ \\Delta = \\left| C(P_{C}) - B_{1}(P_{B}) + \\gamma \\right| $$\n    如果 $\\Delta \\le \\tau$，则该测试用例的结果为 $1$，否则为 $0$。\n5.  **输出格式化**：收集每个测试用例的结果（$1$ 或 $0$），并以指定的逗号分隔列表格式打印，用方括号括起来。\n\n此过程在下面的 Python 程序中实现，遵守所有指定的约束和库。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Numerically verifies the identity C - B_1 = -gamma related to Mertens' theorems.\n    \"\"\"\n    test_cases = [\n        # (P_C, P_B, tau)\n        (30000, 400000, 0.05),\n        (150000, 1500000, 0.02),\n        (1000000, 5000000, 0.01),\n    ]\n\n    def sieve_of_eratosthenes(n):\n        \"\"\"\n        Generates prime numbers up to n using the Sieve of Eratosthenes.\n        \"\"\"\n        is_prime = np.ones(n + 1, dtype=bool)\n        is_prime[0:2] = False\n        for i in range(2, int(np.sqrt(n)) + 1):\n            if is_prime[i]:\n                is_prime[i*i::i] = False\n        return np.where(is_prime)[0]\n\n    max_p_overall = 0\n    if test_cases:\n        max_p_overall = max(max(case[0], case[1]) for case in test_cases)\n    \n    all_primes = sieve_of_eratosthenes(max_p_overall)\n    \n    gamma = np.euler_gamma\n\n    results = []\n    for p_c, p_b, tau in test_cases:\n        primes_c = all_primes[all_primes = p_c]\n        inv_p_c = 1.0 / primes_c\n        c_approx = np.sum(np.log1p(-inv_p_c) + inv_p_c)\n\n        primes_b = all_primes[all_primes = p_b]\n        inv_p_b = 1.0 / primes_b\n        sum_inv_p_b = np.sum(inv_p_b)\n        b1_approx = sum_inv_p_b - np.log(np.log(p_b))\n\n        deviation = abs(c_approx - b1_approx + gamma)\n        \n        if deviation = tau:\n            results.append(1)\n        else:\n            results.append(0)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3087073"}]}