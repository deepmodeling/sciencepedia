{"hands_on_practices": [{"introduction": "狄利克雷双曲线法提供了一种在特定区域上对算术函数求和的有效方法。本练习旨在通过一个具体实例，让你手动划分求和区域，从而将抽象的方法具体化。通过明确计算每个部分的和，你将对几何划分如何转化为精确的数值恒等式获得切实的理解 [@problem_id:3090772]。", "problem": "设 $f$ 和 $g$ 是定义在正整数上的数论函数，它们的狄利克雷卷积 $(f * g)$ 定义为 $(f * g)(n) = \\sum_{ab = n} f(a) g(b)$。从这个定义以及不等式 $ab \\leq x$ 作为双曲线 $ab = x$ 下方整点格区域的计数解释出发，推导狄利克雷双曲线法分解，该方法通过在双曲线顶点处进行分割，将和式 $\\sum_{n \\leq x} (f * g)(n)$ 划分成三个部分。然后，将此方法特化到 $f = g = 1$ 和 $x = 100$ 的情形，其中 $1$ 表示对所有正整数 $n$ 恒为 $1$ 的常函数 $1(n) = 1$。\n\n执行以下步骤：\n- 通过以 $a = \\sqrt{100}$ 和 $b = \\sqrt{100}$ 为分割线，用关于 $a$ 和 $b$ 的不等式描述三个区域，为 $x = 100$ 显式地构造双曲线划分。在需要时使用最大整数函数（向下取整函数）$\\lfloor \\cdot \\rfloor$。\n- 当 $f = g = 1$ 时，计算该分解产生的三个和。\n- 数值上验证该分解与原始和 $\\sum_{n \\leq 100} \\tau(n)$ 精确相等，其中 $\\tau(n)$ 是 $n$ 的正因数个数。\n\n提供 $\\sum_{n \\leq 100} \\tau(n)$ 的最终值，结果应为一个整数。无需四舍五入。", "solution": "该问题要求使用狄利克雷双曲线法推导和式 $\\sum_{n \\leq x} (f * g)(n)$，然后将此方法应用于 $x = 100$ 且 $f$ 和 $g$ 均为常函数 $1(n)=1$（对所有正整数 $n$）的特定情形。\n\n首先，我们推导一般分解。所求的和式为：\n$$ S(x) = \\sum_{n=1}^{\\lfloor x \\rfloor} (f * g)(n) $$\n使用狄利克雷卷积的定义 $(f * g)(n) = \\sum_{ab=n} f(a)g(b)$，我们可以将和式改写为：\n$$ S(x) = \\sum_{n=1}^{\\lfloor x \\rfloor} \\sum_{ab=n} f(a)g(b) $$\n这等价于对所有满足其乘积 $ab \\leq x$ 的正整数对 $(a, b)$ 求和：\n$$ S(x) = \\sum_{ab \\leq x} f(a)g(b) $$\n对于正整数 $a$ 和 $b$，条件 $ab \\leq x$ 定义了整点格第一象限中，位于双曲线 $ab=x$ 上或其下方的一个区域。狄利克雷双曲线法提供了一种通过划分该区域来对其中的点进行计数的方法。\n\n令 $u$ 为一个正实数参数，我们设 $u = \\sqrt{x}$。求和区域 $R = \\{(a, b) \\in \\mathbb{Z}^+ \\times \\mathbb{Z}^+ \\mid ab \\leq x\\}$ 可以通过在 $a = u$ 和 $b = u$ 处分割，划分为三个不相交的子区域：\n1.  $R_1 = \\{(a, b) \\in R \\mid a \\leq u, b \\leq u\\}$\n2.  $R_2 = \\{(a, b) \\in R \\mid a \\leq u, b > u\\}$\n3.  $R_3 = \\{(a, b) \\in R \\mid a > u, b \\leq u\\}$\n注意，如果 $a > u$ 且 $b > u$，则 $ab > u^2=x$，因此在这个划分的第四个区域中没有满足 $ab \\leq x$ 的点。并集 $R_1 \\cup R_2 \\cup R_3$ 就是整个区域 $R$。\n\n总和 $S(x)$ 是这三个不相交区域贡献之和：\n$$ S(x) = \\sum_{(a,b) \\in R_1} f(a)g(b) + \\sum_{(a,b) \\in R_2} f(a)g(b) + \\sum_{(a,b) \\in R_3} f(a)g(b) $$\n令 $F(y) = \\sum_{k=1}^{\\lfloor y \\rfloor} f(k)$ 和 $G(y) = \\sum_{k=1}^{\\lfloor y \\rfloor} g(k)$ 为 $f$ 和 $g$ 的求和函数。每个区域上的和可以表示为：\n- $R_1$ 上的和：$\\sum_{a=1}^{\\lfloor u \\rfloor} \\sum_{b=1}^{\\lfloor u \\rfloor} f(a)g(b) = \\left(\\sum_{a=1}^{\\lfloor u \\rfloor} f(a)\\right) \\left(\\sum_{b=1}^{\\lfloor u \\rfloor} g(b)\\right) = F(\\lfloor u \\rfloor)G(\\lfloor u \\rfloor)$。\n- $R_2$ 上的和：$\\sum_{a=1}^{\\lfloor u \\rfloor} f(a) \\sum_{b=\\lfloor u \\rfloor+1}^{\\lfloor x/a \\rfloor} g(b) = \\sum_{a=1}^{\\lfloor u \\rfloor} f(a) \\left( G(\\lfloor x/a \\rfloor) - G(\\lfloor u \\rfloor) \\right)$。\n- $R_3$ 上的和：$\\sum_{b=1}^{\\lfloor u \\rfloor} g(b) \\sum_{a=\\lfloor u \\rfloor+1}^{\\lfloor x/b \\rfloor} f(a) = \\sum_{b=1}^{\\lfloor u \\rfloor} g(b) \\left( F(\\lfloor x/b \\rfloor) - F(\\lfloor u \\rfloor) \\right)$。\n\n现在，我们特化到问题中给出的情形：对所有 $n \\in \\mathbb{Z}^+$，$f(n) = g(n) = 1$，且 $x = 100$。\n在此情形下，卷积是除数函数 $\\tau(n) = (1 * 1)(n) = \\sum_{d|n} 1$。我们希望计算的和是 $\\sum_{n=1}^{100} \\tau(n)$。\n求和函数为 $F(y) = G(y) = \\sum_{k=1}^{\\lfloor y \\rfloor} 1 = \\lfloor y \\rfloor$。\n分割参数是 $u = \\sqrt{x} = \\sqrt{100} = 10$。因此，$\\lfloor u \\rfloor = 10$。\n\n区域 $ab \\leq 100$ 的划分如下：\n- 区域 1：$R_1 = \\{(a,b) \\in \\mathbb{Z}^+ \\times \\mathbb{Z}^+ \\mid 1 \\le a \\le 10, 1 \\le b \\le 10\\}$。\n- 区域 2：$R_2 = \\{(a,b) \\in \\mathbb{Z}^+ \\times \\mathbb{Z}^+ \\mid 1 \\le a \\le 10, 10  b \\le \\lfloor 100/a \\rfloor\\}$。\n- 区域 3：$R_3 = \\{(a,b) \\in \\mathbb{Z}^+ \\times \\mathbb{Z}^+ \\mid 10  a \\le \\lfloor 100/b \\rfloor, 1 \\le b \\le 10\\}$。\n\n我们现在计算这个分解产生的三个和。由于对所有的 $a, b$ 都有 $f(a)=g(b)=1$，所以一个区域上的和就是该区域内的整点个数。\n\n区域 1 的和：\n$R_1$ 中的点数是 $10 \\times 10$ 正方形的大小：\n$$ \\text{Sum}_1 = \\sum_{a=1}^{10} \\sum_{b=1}^{10} 1 = 10 \\times 10 = 100 $$\n\n区域 2 的和：\n$R_2$ 中的点数是：\n$$ \\text{Sum}_2 = \\sum_{a=1}^{10} \\sum_{b=11}^{\\lfloor 100/a \\rfloor} 1 = \\sum_{a=1}^{10} \\max(0, \\lfloor 100/a \\rfloor - 10) $$\n仅当 $a  10$ 时，项才非零。\n$a=1: \\lfloor 100/1 \\rfloor - 10 = 100 - 10 = 90$\n$a=2: \\lfloor 100/2 \\rfloor - 10 = 50 - 10 = 40$\n$a=3: \\lfloor 100/3 \\rfloor - 10 = 33 - 10 = 23$\n$a=4: \\lfloor 100/4 \\rfloor - 10 = 25 - 10 = 15$\n$a=5: \\lfloor 100/5 \\rfloor - 10 = 20 - 10 = 10$\n$a=6: \\lfloor 100/6 \\rfloor - 10 = 16 - 10 = 6$\n$a=7: \\lfloor 100/7 \\rfloor - 10 = 14 - 10 = 4$\n$a=8: \\lfloor 100/8 \\rfloor - 10 = 12 - 10 = 2$\n$a=9: \\lfloor 100/9 \\rfloor - 10 = 11 - 10 = 1$\n$a=10: \\lfloor 100/10 \\rfloor - 10 = 10 - 10 = 0$\n$$ \\text{Sum}_2 = 90 + 40 + 23 + 15 + 10 + 6 + 4 + 2 + 1 + 0 = 191 $$\n\n区域 3 的和：\n$R_3$ 中的点数是：\n$$ \\text{Sum}_3 = \\sum_{b=1}^{10} \\sum_{a=11}^{\\lfloor 100/b \\rfloor} 1 = \\sum_{b=1}^{10} \\max(0, \\lfloor 100/b \\rfloor - 10) $$\n根据与 $\\text{Sum}_2$ 计算的对称性，我们有：\n$$ \\text{Sum}_3 = 191 $$\n\n最后，我们数值上验证该分解给出了原始和的精确值。总和是三个不相交区域的计数之和：\n$$ \\sum_{n=1}^{100} \\tau(n) = \\text{Sum}_1 + \\text{Sum}_2 + \\text{Sum}_3 = 100 + 191 + 191 = 482 $$\n划分求和区域的方法是一个精确的计数过程。因此，数值计算证实了这三个部分的和正确地给出了总和。最终值是这个精确计算的结果。", "answer": "$$\\boxed{482}$$", "id": "3090772"}, {"introduction": "双曲线法的精确性取决于容斥原理，它确保每个格点都被精确地计算一次。本练习聚焦于对角线上的特殊点 $(\\sqrt{x}, \\sqrt{x})$，以突显双重计数校正项的工作原理。通过追踪这个特定点如何被计入又如何被减去，你将体会到容斥原理的精妙与严谨 [@problem_id:3090733]。", "problem": "设 $d(n)$ 表示正整数 $n$ 的正因数个数。对于实数参数 $x \\geq 1$，考虑除数求和函数 $\\sum_{n \\leq x} d(n)$，并回顾其基于格点计数的重新解释：$\\sum_{n \\leq x} d(n)$ 等于满足 $ab \\leq x$ 的数对 $(a,b) \\in \\mathbb{N}^{2}$ 的数量。假设 $x$ 是一个完全平方数，因此 $\\sqrt{x} \\in \\mathbb{N}$。\n\n仅使用 $d(n)$ 的基本定义和上述计数解释，将满足 $ab \\leq x$ 的数对 $(a,b)$ 集合相对于对角线 $a=b$ 分割成两个对称部分，方法是首先计算满足 $a \\leq \\sqrt{x}$ 的数对，然后计算满足 $b \\leq \\sqrt{x}$ 的数对，并通过校正任何重叠部分来避免重复计数。关注可行域角落处的唯对角线点，即 $(a,b) = (\\sqrt{x}, \\sqrt{x})$。\n\n在进行对称分割和重叠校正后，确定仅由对角线角落点 $(\\sqrt{x}, \\sqrt{x})$ 对 $\\sum_{n \\leq x} d(n)$ 产生的确切净贡献。请用一个数字作答。", "solution": "题目要求在 $x$ 是一个完全平方数的条件下，使用一种特定的计数方法计算时，特定格点 $(\\sqrt{x}, \\sqrt{x})$ 对除数求和函数 $\\sum_{n \\leq x} d(n)$ 的净贡献。\n\n设除数求和函数表示为 $S(x) = \\sum_{n \\leq x} d(n)$。函数 $d(n)$ 是 $n$ 的正因数个数。一个基本性质是 $d(n) = \\sum_{ab=n, a,b \\in \\mathbb{N}} 1$。因此，该求和函数可以表示为平面上格点的计数：\n$$ S(x) = \\sum_{n=1}^{\\lfloor x \\rfloor} \\sum_{ab=n} 1 = \\sum_{\\substack{a,b \\in \\mathbb{N} \\\\ ab \\leq x}} 1 $$\n这意味着 $S(x)$ 是满足其乘积小于或等于 $x$ 的正整数对 $(a,b)$ 的数量。这些数对对应于第一象限中位于双曲线 $ab=x$ 上或其下方的格点。\n\n题目指定了一种计算这些点的特定方法，这是容斥原理的一个教科书式应用，通常称为狄利克雷双曲线法。令 $y = \\sqrt{x}$。由于 $x$ 是一个完全平方数，所以 $y$ 是一个正整数。\n所有待计数的点的集合是 $P = \\{(a,b) \\in \\mathbb{N}^2 \\mid ab \\leq x\\}$。对于任何点 $(a,b) \\in P$，不可能同时满足 $a > y$ 和 $b > y$，因为这将意味着 $ab > y \\cdot y = x$，与条件 $ab \\leq x$ 相矛盾。因此，对于 $P$ 中的任何点，必然有 $a \\leq y$ 或 $b \\leq y$（或两者都成立）。\n\n根据题目的指示，我们定义两个集合：\n1. 满足 $a \\leq y$ 的数对集合：设其为 $P_1 = \\{(a,b) \\in \\mathbb{N}^2 \\mid ab \\leq x \\text{ and } a \\leq y\\}$。\n2. 满足 $b \\leq y$ 的数对集合：设其为 $P_2 = \\{(a,b) \\in \\mathbb{N}^2 \\mid ab \\leq x \\text{ and } b \\leq y\\}$。\n\n总的点集是这两个集合的并集，$P = P_1 \\cup P_2$。所述的计数方法是先将 $P_1$ 和 $P_2$ 的大小相加，然后减去它们交集的大小以校正重复计数。\n$$ S(x) = |P| = |P_1 \\cup P_2| = |P_1| + |P_2| - |P_1 \\cap P_2| $$\n题目要求的是特定点 $p_0 = (y,y) = (\\sqrt{x}, \\sqrt{x})$ 对此计算的“净贡献”。净贡献取决于这个特定点在公式的每一项中被计算了多少次。这可以用指示函数 $\\chi_{p_0}(A)$ 来形式化，如果 $p_0 \\in A$，则其值为 $1$，否则为 $0$。净贡献为 $\\chi_{p_0}(P_1) + \\chi_{p_0}(P_2) - \\chi_{p_0}(P_1 \\cap P_2)$。\n\n我们现在检查点 $p_0 = (y,y)$ 是否属于这些集合中的每一个。\n1.  **对 $|P_1|$ 的贡献**：\n    如果点 $p_0$ 满足条件 $ab \\leq x$ 和 $a \\leq y$，则它在 $P_1$ 中。对于 $p_0=(y,y)$，我们有 $a=y$ 和 $b=y$。\n    - 第一个条件是 $ab = y \\cdot y = y^2 = x$。所以，$ab \\leq x$ 成立。\n    - 第二个条件是 $a=y$。所以，$a \\leq y$ 成立。\n    由于两个条件都满足，点 $p_0$ 在集合 $P_1$ 中。它对计数 $|P_1|$ 的贡献是 $1$。因此，$\\chi_{p_0}(P_1) = 1$。\n\n2.  **对 $|P_2|$ 的贡献**：\n    如果点 $p_0$ 满足条件 $ab \\leq x$ 和 $b \\leq y$，则它在 $P_2$ 中。对于 $p_0=(y,y)$，我们有 $a=y$ 和 $b=y$。\n    - 第一个条件 $ab \\leq x$ 成立，如上所示。\n    - 第二个条件是 $b=y$。所以，$b \\leq y$ 成立。\n    由于两个条件都满足，点 $p_0$ 在集合 $P_2$ 中。它对计数 $|P_2|$ 的贡献是 $1$。因此，$\\chi_{p_0}(P_2) = 1$。\n\n3.  **对 $|P_1 \\cap P_2|$（重叠校正）的贡献**：\n    集合 $P_1 \\cap P_2$ 由满足所有三个条件的点 $(a,b)$ 组成：$ab \\leq x$，$a \\leq y$ 和 $b \\leq y$。减去 $|P_1 \\cap P_2|$ 的目的是移除在 $|P_1|$ 和 $|P_2|$ 中都被计数的点。\n    我们检查 $p_0=(y,y)$ 是否属于这个交集。\n    - 如前所述，$p_0$ 满足 $ab \\leq x$。\n    - 如前所述，$p_0$ 满足 $a \\leq y$。\n    - 如前所述，$p_0$ 满足 $b \\leq y$。\n    由于 $p_0$ 同时在 $P_1$ 和 $P_2$ 中，根据定义，它也在它们的交集 $P_1 \\cap P_2$ 中。它对计数 $|P_1 \\cap P_2|$ 的贡献是 $1$。因此，$\\chi_{p_0}(P_1 \\cap P_2) = 1$。\n\n最后，在分割和重叠校正后，点 $p_0 = (\\sqrt{x}, \\sqrt{x})$ 对总和 $S(x)$ 的净贡献是其各项贡献的代数和：\n$$ \\text{净贡献} = \\chi_{p_0}(P_1) + \\chi_{p_0}(P_2) - \\chi_{p_0}(P_1 \\cap P_2) = 1 + 1 - 1 = 1 $$\n这个结果与该方法的目标一致，即每个有效格点都只被计算一次。点 $(\\sqrt{x}, \\sqrt{x})$ 对应于整数 $x$ 的唯一一个因子相等的因数对。容斥原理过程在最终总和中正确地将此点计数了一次。", "answer": "$$\n\\boxed{1}\n$$", "id": "3090733"}, {"introduction": "数论中的理论洞察常常能催生强大的计算算法，狄利克雷双曲线法正是这样一个例子。此问题要求你将双曲线法的核心思想转化为计算除数函数和的高效算法。通过对 $\\lfloor x/n \\rfloor$ 取值相同的项进行分组，你将看到一个理论上的和式重排如何带来计算速度的巨大提升——从 $O(x)$ 到 $O(\\sqrt{x})$ [@problem_id:3090756]。", "problem": "你需要推导、实现并分析一种基于狄利克雷双曲线法的算法，用于计算除数函数求和。令 $d(n)$ 表示整数 $n$ 的正因数的个数。定义求和函数 $D(x)$ 为\n$$\nD(x) = \\sum_{n \\le x} d(n),\n$$\n对于任意整数 $x \\ge 0$。仅从 $d(n)$ 计算 $n$ 的正因数个数的基本定义，以及计算因数对等价于计算满足 $ab \\le x$ 的格点 $(a,b)$ 个数这一恒等式出发，通过对具有相同底函数 $\\left\\lfloor \\frac{x}{n} \\right\\rfloor$ 值的索引 $n$ 进行分组，推导出一个在 $O(\\sqrt{x})$ 时间内计算 $D(x)$ 的算法。该分组策略应被用来避免遍历所有 $n \\le x$，并应依赖于观察到 $\\left\\lfloor \\frac{x}{n} \\right\\rfloor$ 在 $n$ 的连续范围内取相同的值。\n\n你的程序必须为固定的测试套件实现此算法，并按指定格式输出结果。该测试套件包括以下 $x$ 的整数值：\n- $x = 0$ (边界情况)，\n- $x = 1$ (最小的非平凡情况)，\n- $x = 2$ (非常小的情况)，\n- $x = 10$ (小情况)，\n- $x = 100$ (中等情况)，\n- $x = 999999$ (略低于一个整数阈值的大情况)，\n- $x = 1000000$ (位于一个整数阈值的大情况)。\n\n对于测试套件中的每个 $x$，你的程序必须计算出整数 $D(x)$。你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果的顺序与测试套件中的顺序相同（例如，如果结果为 $r_1, r_2, \\ldots, r_7$，则输出必须是精确的 $[r_1,r_2,r_3,r_4,r_5,r_6,r_7]$ 格式）。\n\n此问题不涉及任何物理单位或角度。所有量都是纯整数。确保你的算法通过对具有相同 $\\left\\lfloor \\frac{x}{n} \\right\\rfloor$ 值的索引进行分组，达到 $O(\\sqrt{x})$ 的时间复杂度。", "solution": "目标是推导并实现一个算法，用于在 $O(\\sqrt{x})$ 时间内计算除数求和函数 $D(x) = \\sum_{n \\le x} d(n)$，其中 $d(n)$ 是 $n$ 的正因数的个数。推导过程将遵循狄利克雷双曲线法的原理，并利用指定的分组索引优化。\n\n首先，我们将 $D(x)$ 表示为更易处理的形式。除数函数的定义是 $d(n) = \\sum_{k|n, k0} 1$。将此代入整数 $x \\ge 0$ 的 $D(x)$ 定义中，可得：\n$$\nD(x) = \\sum_{n=1}^{\\lfloor x \\rfloor} d(n) = \\sum_{n=1}^{\\lfloor x \\rfloor} \\sum_{k|n} 1\n$$\n该双重求和计算的是满足 $k$ 整除 $n$ 且 $n \\le x$ 的正整数对 $(n, k)$ 的数量。条件 $k|n$ 意味着对于某个正整数 $m$，有 $n = km$。因此，条件 $n \\le x$ 变为 $km \\le x$。这使我们可以将求和重新索引为积 $km \\le x$ 的正整数对 $(k,m)$：\n$$\nD(x) = \\sum_{k,m \\in \\mathbb{Z}^+; km \\le x} 1\n$$\n在几何上，这个和表示第一象限中位于双曲线 $km = x$ 上或下方的整格点 $(k,m)$ 的数量。\n\n为了计算这个和，我们可以遍历一个变量，比如 $k$，对每个 $k$ 求出 $m$ 的有效计数。变量 $k$ 的范围可以从 $1$ 到 $\\lfloor x \\rfloor$。对于固定的 $k$，条件 $km \\le x$ 等价于 $m \\le \\frac{x}{k}$。由于 $m$ 必须是整数， $m$ 的可能取值个数为 $\\lfloor \\frac{x}{k} \\rfloor$。这导出了 $D(x)$ 的以下恒等式：\n$$\nD(x) = \\sum_{k=1}^{\\lfloor x \\rfloor} \\left\\lfloor \\frac{x}{k} \\right\\rfloor\n$$\n计算此和的朴素算法将从 $1$ 迭代到 $\\lfloor x \\rfloor$，其时间复杂度为 $O(x)$。对于大的 $x$，这是低效的。\n\n问题要求一个 $O(\\sqrt{x})$ 的算法，这通过对索引进行分组来实现。我们观察到 $\\lfloor \\frac{x}{k} \\rfloor$ 这一项是关于 $k$ 的一个非递增阶梯函数。对于许多连续的 $k$ 值，它取相同的值。我们可以利用这一点，将具有相同 $\\lfloor \\frac{x}{k} \\rfloor$ 值的项分组，并在一个步骤中计算它们对总和的贡献。\n\n让我们将此分组策略形式化。我们遍历索引块。假设一个块从索引 $k$ 开始。此块的底函数值为 $v = \\lfloor \\frac{x}{k} \\rfloor$。我们需要找到最大的索引 $k_{end}$，使得对于所有满足 $k \\le i \\le k_{end}$ 的整数 $i$，都有 $\\lfloor \\frac{x}{i} \\rfloor = v$。\n\n条件 $\\lfloor \\frac{x}{i} \\rfloor = v$ 等价于不等式 $v \\le \\frac{x}{i}  v+1$。\n不等式的左半部分，$v \\le \\frac{x}{i}$，意味着 $i \\le \\frac{x}{v}$。由于 $i$ 必须是整数，所以 $i \\le \\lfloor \\frac{x}{v} \\rfloor$。\n右半部分，$\\frac{x}{i}  v+1$，意味着 $i > \\frac{x}{v+1}$。\n对于任何 $i \\ge k$，我们有 $\\frac{x}{i} \\le \\frac{x}{k}$，所以 $\\lfloor \\frac{x}{i} \\rfloor \\le \\lfloor \\frac{x}{k} \\rfloor = v$。因此，我们只需要找到满足 $v \\le \\lfloor \\frac{x}{i} \\rfloor$ 的最大 $i$。这在 $i = \\lfloor \\frac{x}{v} \\rfloor$ 时发生。\n因此，对于一个起始索引 $k$，$\\lfloor \\frac{x}{i} \\rfloor$ 保持为常数 $v = \\lfloor \\frac{x}{k} \\rfloor$ 的索引块是 $[k, k_{end}]$，其中 $k_{end} = \\lfloor \\frac{x}{v} \\rfloor = \\lfloor \\frac{x}{\\lfloor x/k \\rfloor} \\rfloor$。\n\n这个块中的项数是 $(k_{end} - k + 1)$。整个块对总和的贡献是 $(k_{end} - k + 1) \\times v$。处理完这个块后，下一个要考虑的索引是 $k_{end} + 1$。\n\n算法如下：\n1. 初始化总和 $S = 0$ 和起始索引 $k = 1$。\n2. 当 $k \\le x$ 时：\n   a. 如果 $k > x$，终止。对于整数 $x$，这等价于 $k > \\lfloor x \\rfloor$。\n   b. 计算值 $v = \\lfloor \\frac{x}{k} \\rfloor$。如果 $v=0$，则所有后续项都为 $0$，可以终止。\n   c. 确定当前块的末尾，$k_{end} = \\lfloor \\frac{x}{v} \\rfloor$。\n   d. 将此块的贡献加到总和中：$S \\leftarrow S + (k_{end} - k + 1) \\times v$。\n   e. 更新索引到下一个块的开始：$k \\leftarrow k_{end} + 1$。\n3. 最终结果是 $D(x) = S$。\n\n为了分析复杂度，我们计算迭代次数。循环以跳跃方式推进 $k$。对于 $k=1, \\dots, \\lfloor x \\rfloor$，$\\lfloor \\frac{x}{k} \\rfloor$ 的唯一值的数量决定了迭代次数。\n- 对于 $k \\in [1, \\lfloor\\sqrt{x}\\rfloor]$，最多有 $\\lfloor\\sqrt{x}\\rfloor$ 个不同的 $k$ 值，因此最多有 $\\lfloor\\sqrt{x}\\rfloor$ 个不同的 $\\lfloor\\frac{x}{k}\\rfloor$ 值。\n- 对于 $k \\in (\\lfloor\\sqrt{x}\\rfloor, \\lfloor x \\rfloor]$，我们有 $k > \\sqrt{x}$，这意味着 $\\frac{x}{k}  \\sqrt{x}$。所以，值 $v = \\lfloor \\frac{x}{k} \\rfloor$ 是一个在范围 $[1, \\lfloor\\sqrt{x}\\rfloor - 1]$ 内的整数。此范围内最多有 $\\lfloor\\sqrt{x}\\rfloor - 1$ 个不同的值。\n$\\lfloor \\frac{x}{k} \\rfloor$ 的不同值的总数，也就是循环迭代的次数，其上界为 $2\\lfloor\\sqrt{x}\\rfloor$。每次迭代涉及几次算术运算，耗时为常数时间。因此，该算法的总体时间复杂度为 $O(\\sqrt{x})$。这满足了问题的要求。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef divisor_summatory_function(x: int) - int:\n    \"\"\"\n    Computes the summatory divisor function D(x) = sum_{n = x} d(n)\n    using the Dirichlet hyperbola method optimized with index grouping.\n\n    The identity D(x) = sum_{k=1}^{x} floor(x/k) is used. The sum is\n    computed in O(sqrt(x)) time by grouping terms where floor(x/k)\n    is constant.\n\n    Args:\n        x: A non-negative integer.\n\n    Returns:\n        The integer value of D(x).\n    \"\"\"\n    if x  1:\n        return 0\n\n    # According to the problem statement, all quantities are integers.\n    # Python's integers support arbitrary precision, so overflow is not a concern\n    # for the given test cases.\n    x = int(x)\n\n    total_sum = 0\n    k = 1\n    while k = x:\n        # v is the value of floor(x/k) for the current block of indices.\n        v = x // k\n\n        # k_end is the last index for which floor(x/i) has the value v.\n        # k_end = floor(x / v)\n        k_end = x // v\n\n        # The number of indices in the block [k, k_end] is (k_end - k + 1).\n        # Add the contribution of this block to the total sum.\n        num_terms = k_end - k + 1\n        total_sum += num_terms * v\n\n        # Jump to the start of the next block.\n        k = k_end + 1\n\n    return total_sum\n\ndef solve():\n    \"\"\"\n    Runs the calculation for the test suite specified in the problem statement\n    and prints the results in the required format.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        0,          # boundary case\n        1,          # smallest nontrivial case\n        2,          # very small case\n        10,         # small case\n        100,        # moderate case\n        999999,     # large case just below a round threshold\n        1000000     # large case at a round threshold\n    ]\n\n    results = []\n    for x_val in test_cases:\n        result = divisor_summatory_function(x_val)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3090756"}]}