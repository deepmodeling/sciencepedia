{"hands_on_practices": [{"introduction": "素数定理为我们理解素数的总体分布提供了美妙的渐近描述，但在需要精确数值证明时，我们需要更强的工具。这项练习将让你应用著名的 Rosser-Schoenfeld 显式界限来计算 $\\pi(x)$ 函数在 $x=10^8$ 处的一个严格的上下界，从而亲身体验理论与数论实践之间的联系。通过这个过程，你将能更深刻地理解渐近公式与具体数值认证之间的区别。[@problem_id:3084502]", "problem": "设 $\\pi(x)$ 表示素数计数函数，定义为 $\\pi(x)=|\\{p \\text{为素数} : p \\leq x\\}|$，并设 $\\ln(x)$ 表示自然对数。素数定理（PNT）断言当 $x\\to\\infty$ 时 $\\pi(x)\\sim x/\\ln(x)$，这是一个经过充分检验的事实，但对于具体的数值证明，需要使用显式不等式。Rosser–Schoenfeld 的显式界限（1962）指出，对于所有实数 $x \\geq 55$，\n$$\\frac{x}{\\ln(x)-1}  \\pi(x)  \\frac{x}{\\ln(x)-1.08366}.$$\n仅使用这些显式界限，为 $\\pi(10^{8})$ 找出一个经过证明的下界和上界，并构造比值\n$$R=\\frac{\\text{上界} - \\text{下界}}{10^{8}/\\ln(10^{8})}.$$\n计算 $R$ 并将最终答案四舍五入到四位有效数字。将答案表示为一个不带单位的纯数字。", "solution": "我们从素数计数函数 $\\pi(x)$ 和自然对数 $\\ln(x)$ 的定义开始。素数定理提供了启发式的尺度关系 $\\pi(x)\\sim x/\\ln(x)$，但为了获得经过证明的界限，我们依赖于 Rosser–Schoenfeld 不等式，这些是经过充分检验的显式公式。\n\n对于 $x=10^{8}$，Rosser–Schoenfeld 界限给出\n$$\\frac{10^{8}}{\\ln(10^{8})-1}  \\pi(10^{8})  \\frac{10^{8}}{\\ln(10^{8})-1.08366}.$$\n设 $L=\\ln(10^{8})$。那么下界和上界分别为\n$$\\text{LB}=\\frac{10^{8}}{L-1},\\qquad \\text{UB}=\\frac{10^{8}}{L-1.08366}.$$\n该证明区间的宽度为\n$$\\text{宽度}=\\text{UB}-\\text{LB}=\\frac{10^{8}}{L-1.08366}-\\frac{10^{8}}{L-1}.$$\n代数上，这个差可以简化为\n\\begin{align*}\n\\text{宽度}\n=10^{8}\\left(\\frac{1}{L-1.08366}-\\frac{1}{L-1}\\right)\n=10^{8}\\cdot\\frac{(L-1)-(L-1.08366)}{(L-1.08366)(L-1)}\\\\\n=10^{8}\\cdot\\frac{0.08366}{(L-1.08366)(L-1)}.\n\\end{align*}\n题目要求我们将此宽度与基准尺度 $10^{8}/L$ 进行比较，方法是构造比值\n$$R=\\frac{\\text{宽度}}{10^{8}/L}=\\frac{10^{8}\\cdot\\frac{0.08366}{(L-1.08366)(L-1)}}{10^{8}/L}=\\frac{0.08366\\,L}{(L-1.08366)(L-1)}.$$\n因此，该比值的精确表达式为\n$$R=\\frac{0.08366\\,\\ln(10^{8})}{\\big(\\ln(10^{8})-1.08366\\big)\\big(\\ln(10^{8})-1\\big)}.$$\n为了对 $R$ 进行数值计算，我们使用 $\\ln(10)=2.302585093$，因此\n$$L=\\ln(10^{8})=8\\ln(10)=8\\times 2.302585093=18.420680744.$$\n接下来，计算各个因子：\n\\begin{align*}\nL-1 = 18.420680744 - 1 = 17.420680744,\\\\\nL-1.08366 = 18.420680744 - 1.08366 = 17.337020744,\\\\\n(L-1.08366)(L-1) \\approx 17.337020744 \\times 17.420680744 \\approx 302.022676,\\\\\n0.08366\\,L \\approx 0.08366 \\times 18.420680744 \\approx 1.541074088.\n\\end{align*}\n因此，\n$$R \\approx \\frac{1.541074088}{302.022676} \\approx 0.005102512\\ldots.$$\n四舍五入到四位有效数字，得到\n$$R \\approx 0.005103.$$\n\n为了完整起见，我们也可以观察数值下界和上界本身：\n\\begin{align*}\n\\text{LB}=\\frac{10^{8}}{17.420680744}\\approx 5{,}740{,}304,\\\\\n\\text{UB}=\\frac{10^{8}}{17.337020744}\\approx 5{,}768{,}004,\n\\end{align*}\n所以区间宽度约等于 $27{,}700$，而 $10^{8}/L\\approx 5{,}428{,}682$，这与比值 $R\\approx 27{,}700/5{,}428{,}682\\approx 0.005103$ 一致。\n\n此计算仅使用 Rosser–Schoenfeld 显式界限作为经过充分检验的出发点，并将其证明的区间宽度与素数定理所建议的自然尺度 $10^{8}/\\ln(10^{8})$ 进行比较。", "answer": "$$\\boxed{0.005103}$$", "id": "3084502"}, {"introduction": "虽然素数定理告诉我们素数的“平均”行为，但素数的局部自分布却远非均匀。本练习从 Bertrand 猜想（即对于 $n \\ge 2$，在 $(n, 2n)$ 区间内必有一素数）出发，引导你通过直接计算来探究该区间内素数个数的变化情况。你将发现素数分布的非单调性，这揭示了素数序列中固有的不规则性，是理解素数分布复杂性的重要一步。[@problem_id:3084533]", "problem": "设 $\\pi(x)$ 表示素数计数函数，并设 $\\Delta(n) := \\pi(2n) - \\pi(n)$ 表示区间 $(n,2n]$ 中的素数个数。仅使用数论中的基本定义和广为接受的事实——具体来说，伯特兰猜想（Bertrand's postulate）（该猜想指出，对于每个整数 $n \\geq 2$，在区间 $(n,2n)$ 中都存在一个素数）以及关于 $\\pi(x)$ 的切比雪夫型界（Chebyshev-type bounds），这些界将 $\\pi(x)$ 与带有绝对常数的 $x / \\ln x$ 进行比较——解答以下问题：\n\n1. 计算使得区间 $(n,2n]$ 包含严格多于一个素数（即，满足 $\\Delta(n) \\geq 2$）的最小正整数 $n$。\n\n2. 通过基于这些事实和定义的逻辑推理，解释这个计算结果如何说明序列 $n \\mapsto \\Delta(n)$ 关于 $n$ 是否是单调的。你的解释应包括一个具体的整数例子来表明 $\\Delta(n)$ 会减少，并使用切比雪夫型界简要论证当 $n \\to \\infty$ 时 $\\Delta(n)$ 是无界的。\n\n你的最终答案必须是第 1 部分得到的那个整数。", "solution": "该问题提出了关于函数 $\\Delta(n) := \\pi(2n) - \\pi(n)$ 的两个任务，其中 $\\pi(x)$ 是素数计数函数。第一个任务是找到满足 $\\Delta(n) \\geq 2$ 的最小正整数 $n$。第二个任务是利用此结果讨论序列 $n \\mapsto \\Delta(n)$ 的单调性，并使用切比雪夫型界简要论证其无界性。\n\n首先，我们来计算使得区间 $(n, 2n]$ 至少包含两个素数（即 $\\Delta(n) \\geq 2$）的最小正整数 $n$。我们通过对连续的正整数 $n$ 计算 $\\Delta(n)$ 的值来求解。素数序列为 $2, 3, 5, 7, 11, 13, \\dots$。素数计数函数 $\\pi(x)$ 给出小于或等于 $x$ 的素数个数。\n\n对于 $n=1$：区间为 $(1, 2]$。此区间内唯一的素数是 $2$。\n因此，$\\Delta(1) = \\pi(2 \\cdot 1) - \\pi(1) = \\pi(2) - \\pi(1) = 1 - 0 = 1$。\n由于 $\\Delta(1) = 1$，不满足条件 $\\Delta(n) \\geq 2$。\n\n对于 $n=2$：区间为 $(2, 4]$。此区间内唯一的素数是 $3$。\n因此，$\\Delta(2) = \\pi(2 \\cdot 2) - \\pi(2) = \\pi(4) - \\pi(2) = 2 - 1 = 1$。\n不满足条件。对于 $n \\geq 2$，伯特兰猜想保证了 $\\Delta(n) \\geq 1$，这与我们的发现一致。\n\n对于 $n=3$：区间为 $(3, 6]$。此区间内唯一的素数是 $5$。\n因此，$\\Delta(3) = \\pi(2 \\cdot 3) - \\pi(3) = \\pi(6) - \\pi(3) = 3 - 2 = 1$。\n不满足条件。\n\n对于 $n=4$：区间为 $(4, 8]$。此区间内的素数是 $5$ 和 $7$。有两个素数。\n因此，$\\Delta(4) = \\pi(2 \\cdot 4) - \\pi(4) = \\pi(8) - \\pi(4) = 4 - 2 = 2$。\n对于 $n=4$，条件 $\\Delta(n) \\geq 2$ 被满足。\n由于对于 $n=1, 2, 3$ 条件均未满足，因此满足 $\\Delta(n) \\geq 2$ 的最小正整数是 $n=4$。\n\n接下来，我们讨论序列 $n \\mapsto \\Delta(n)$ 的单调性。一个序列如果是单调的，那么它要么是非递减的，要么是非递增的。我们目前的计算得出了从 $n=1$ 开始的 $\\Delta(n)$ 值序列：$1, 1, 1, 2$。为了检验其单调性，我们计算下一项。\n\n对于 $n=5$：区间为 $(5, 10]$。此区间内唯一的素数是 $7$。\n因此，$\\Delta(5) = \\pi(2 \\cdot 5) - \\pi(5) = \\pi(10) - \\pi(5) = 4 - 3 = 1$。\n\n对于 $n=1, 2, 3, 4, 5$，$\\Delta(n)$ 的值序列是 $1, 1, 1, 2, 1$。\n我们观察到 $\\Delta(3)=1  \\Delta(4)=2$，这表明该序列不是非递增的。\n我们还观察到 $\\Delta(4)=2 > \\Delta(5)=1$，这表明该序列不是非递减的。\n由于该序列既不是非递减的也不是非递增的，所以它不是单调的。$n=4$ 和 $n=5$ 的计算提供了一个具体的整数例子，显示了 $\\Delta(n)$ 值的减少。\n\n最后，我们使用切比雪夫型界给出一个简要的论证，说明当 $n \\to \\infty$ 时 $\\Delta(n)$ 是无界的。这些界表明，存在正常数 $c_1$ 和 $c_2$，使得对于所有足够大的 $x$，以下不等式成立：\n$$c_1 \\frac{x}{\\ln x}  \\pi(x)  c_2 \\frac{x}{\\ln x}$$\n使用这些界，我们可以为 $\\Delta(n) = \\pi(2n) - \\pi(n)$ 建立一个下界：\n$$\\Delta(n) = \\pi(2n) - \\pi(n) > c_1 \\frac{2n}{\\ln(2n)} - c_2 \\frac{n}{\\ln n}$$\n对于大的 $n$，我们可以重写右侧：\n$$c_1 \\frac{2n}{\\ln 2 + \\ln n} - c_2 \\frac{n}{\\ln n} = \\frac{n}{\\ln n} \\left( c_1 \\frac{2}{1 + \\frac{\\ln 2}{\\ln n}} - c_2 \\right)$$\n当 $n \\to \\infty$ 时，项 $\\frac{\\ln 2}{\\ln n} \\to 0$。因此，括号中的表达式趋近于一个极限：\n$$\\lim_{n\\to\\infty} \\left( c_1 \\frac{2}{1 + \\frac{\\ln 2}{\\ln n}} - c_2 \\right) = 2c_1 - c_2$$\n数论中一个广为接受的事实是（该事实源于切比雪夫的工作并在此后得到改进），常数 $c_1$ 和 $c_2$ 可以被选择以使得 $2c_1 - c_2 > 0$。例如，现代结果提供的界中，$c_1$ 和 $c_2$ 都接近于 $1$，此时 $2c_1-c_2$ 也接近于 $1$。\n令 $K = 2c_1 - c_2 > 0$。对于大的 $n$，我们对 $\\Delta(n)$ 的下界渐近等价于 $K \\frac{n}{\\ln n}$。\n由于 $\\lim_{n \\to \\infty} \\frac{n}{\\ln n} = \\infty$，$\\Delta(n)$ 的下界也趋于无穷大。\n这意味着序列 $\\Delta(n)$ 是无界的。$\\Delta(n)$ 在初始小范围内的非单调行为并不妨碍其总体的增长趋势。", "answer": "$$\\boxed{4}$$", "id": "3084533"}, {"introduction": "对素数间隙的研究是数论的核心课题之一，它连接着素数的平均分布与极端行为。在这个计算实践中，你将通过编写程序来生成大量素数，并对它们之间的间隙进行实证分析。这项任务让你能够亲手验证由素数定理预测的平均间隙大小（约为 $\\log x$），并检验关于最大间隙增长尺度（可能如 $(\\log x)^2$）的著名猜想，从而获得作为一名计算数论研究者的宝贵经验。[@problem_id:3084537]", "problem": "您需要通过计算来研究素数间隙的经验行为。设 $p_n$ 表示第 $n$ 个素数，并定义素数间隙序列 $g(p_n) = p_{n+1} - p_n$ (对于 $n \\geq 1$)。设 $\\pi(x)$ 表示素数计数函数，即小于或等于 $x$ 的素数个数。设 $\\log x$ 表示 $x$ 的自然对数。本次研究的基本依据是素数定理 (PNT)，该定理指出当 $x \\to \\infty$ 时，$\\pi(x) \\sim \\dfrac{x}{\\log x}$。这启发性地表明，在 $x$ 附近，连续素数之间的平均间距约为 $\\log x$ 的量级。另一个被广泛讨论的启发式模型，通常归功于 Cramér，表明最大间隙的增长可能在 $(\\log x)^2$ 的量级。\n\n您的任务是编写一个完整的、可运行的程序，该程序能够：\n\n- 使用基于基本数论原理（例如，埃拉托斯特尼筛法）的算法，生成所有小于等于 $X = 10^7$ 的素数。\n- 对于给定的 $x$，定义：\n  - 截至 $x$ 观察到的最大间隙，\n    $$ G_{\\max}(x) = \\max\\{ g(p_n) : p_{n+1} \\leq x \\}. $$\n  - 截至 $x$ 的经验平均间隙，\n    $$ \\overline{g}(x) = \\frac{p_k - 2}{k - 1}, \\quad \\text{其中 } p_k = \\max\\{p_n \\leq x\\} \\text{ 且 } k = \\pi(x). $$\n    通过裂项求和，该量等于 $p_{n+1} \\leq x$ 的连续素数差 $g(p_n)$ 的平均值，并且是一个可以直接与素数定理所建议的 $\\log x$ 量级进行比较的计算。\n  - 截至 $x$ 的连续素数中的最小间隙（要求两个素数均不小于 $5$，以排除 $2$ 和 $3$ 之间例外的初始间隙），\n    $$ G_{\\min}^{\\geq 5}(x) = \\min\\{ g(p_n) : p_n \\geq 5 \\text{ and } p_{n+1} \\leq x \\}. $$\n  - 观察到的最大间隙与自然对数的比值，\n    $$ R_1(x) = \\frac{G_{\\max}(x)}{\\log x}, $$\n    以及观察到的最大间隙与自然对数平方的比值，\n    $$ R_2(x) = \\frac{G_{\\max}(x)}{(\\log x)^2}. $$\n- 通过比值 $R_1(x)$ 和 $R_2(x)$，将 $G_{\\max}(x)$ 与基准 $\\log x$ 和 $(\\log x)^2$ 进行经验性比较。\n\n使用以下 $x$ 值的测试集：\n- $x = 30$ (小规模行为和边界效应),\n- $x = 10^5$,\n- $x = 10^6$,\n- $x = 3 \\cdot 10^6$,\n- $x = 10^7$ (上限)。\n\n对于测试集中的每个 $x$，计算并报告列表\n$$ [\\, x,\\; G_{\\max}(x),\\; \\overline{g}(x),\\; G_{\\min}^{\\geq 5}(x),\\; R_1(x),\\; R_2(x) \\,]. $$\n\n您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表，每个元素是对应测试用例的上述子列表，并按给定顺序排列。所有浮点值都应打印到小数点后六位。例如，外部结构应如下所示\n$$ [\\,[\\cdots],\\,[\\cdots],\\,[\\cdots],\\,[\\cdots],\\,[\\cdots]\\,] $$\n逗号后没有空格。\n\n所有答案都是没有物理单位的纯数字。不涉及角度。不涉及百分比；比率应以小数表示。程序必须是自包含的，不需要用户输入，不得访问外部文件或网络，并且必须确定性地运行。", "solution": "所提出的问题是计算数论中一个明确定义的练习，要求对素数的分布及其间隙进行经验性研究。该问题在科学上是合理的，数学上是一致的，并且在计算上是可行的。它基于已建立的数论概念，如素数定理和素数间隙的启发式模型。因此，我将继续提供一个完整的解决方案。\n\n解决方案的方法论分为两个主要阶段：首先，高效地生成截至指定上限 $X = 10^7$ 的素数列表；其次，为提供的测试集中的每个 $x$ 值计算所需的统计度量。\n\n**1. 素数生成：埃拉托斯特尼筛法**\n\n要对素数进行任何分析，我们必须首先生成它们。对于给定到 $X = 10^7$ 的范围，最合适的算法是埃拉托斯特尼筛法。这个经典算法以其效率和概念上的优雅而闻名。\n\n筛法的原理基于合数的一个基本性质：任何合数 $n$ 至少有一个素因子 $p$ 满足 $p \\leq \\sqrt{n}$。该算法的工作原理如下：\n- 我们创建一个大小为 $X+1$ 的布尔数组，称之为 `is_prime`，将从 $2$ 到 $X$ 的所有条目初始化为真。根据定义，数字 $0$ 和 $1$ 被标记为非素数。\n- 我们从第一个素数 $p=2$ 开始。我们遍历它的倍数（$2p, 3p, \\dots$），并在数组中将它们标记为非素数。\n- 然后我们找到数组中下一个仍被标记为素数的数；这必定是下一个素数，即 $3$。我们重复这个过程，将所有 $3$ 的倍数标记为非素数。\n- 这个过程对所有小于等于 $\\sqrt{X}$ 的素数 $p$ 继续进行。一个优化是从 $p^2$ 开始标记 $p$ 的倍数，因为任何更小的倍数 $k \\cdot p$（其中 $k  p$）都已经被 $k$ 的某个素因子（它小于 $p$）标记为合数了。\n\n该算法的时间复杂度约为 $O(X \\log \\log X)$，效率非常高，可以在标准计算机上几秒钟内生成高达 $10^7$ 的素数。筛法运行后，`is_prime` 数组允许我们提取一个截至 $X$ 的所有素数的有序列表。\n\n**2. 素数间隙统计的计算**\n\n有了表示为数组 `primes` 的有序素数列表，我们就可以为测试值 $x \\in \\{30, 10^5, 10^6, 3 \\cdot 10^6, 10^7\\}$ 中的每一个计算所需的量。\n\n对于每个 $x$ 值：\n\n首先，我们必须确定小于或等于 $x$ 的素数集合。设这些素数为 $\\{p_1, p_2, \\dots, p_k\\}$，其中 $p_k$ 是不超过 $x$ 的最大素数。这些素数的数量是 $k = \\pi(x)$。通过使用一个预先计算好的、包含所有截至 $10^7$ 的素数的已排序数组，我们可以通过对 $x$ 进行二分搜索来高效地找到 $k$。子数组 `primes[0:k]` 则精确地包含了我们需要的素数。\n\n所需的统计数据计算如下：\n\n-   **最大观测间隙, $G_{\\max}(x)$**：其定义为 $G_{\\max}(x) = \\max\\{ g(p_n) : p_{n+1} \\leq x \\}$。这个条件意味着我们考虑所有连续的素数对 $(p_n, p_{n+1})$，其中两个素数都小于或等于 $p_k$。这对应于 $n$ 从 $1$ 到 $k-1$ 的差值 $p_{n+1} - p_n$ 的最大值。在程序上，这可以通过取从素数子集计算出的差值数组的最大值来找到。\n\n-   **经验平均间隙, $\\overline{g}(x)$**：其由公式 $\\overline{g}(x) = \\frac{p_k - 2}{k - 1}$ 定义。该公式的有效性基于间隙的裂项求和：$\\sum_{n=1}^{k-1} g(p_n) = \\sum_{n=1}^{k-1} (p_{n+1} - p_n) = p_k - p_1$。由于 $p_1 = 2$，和为 $p_k - 2$。间隙的数量是 $k-1$。计算过程是使用已确定的 $p_k$ 和 $k$ 值直接应用此公式。这个经验平均值可以与来自素数定理的启发式值 $\\log x$ 进行比较。\n\n-   **最小间隙, $G_{\\min}^{\\geq 5}(x)$**：其定义为 $G_{\\min}^{\\geq 5}(x) = \\min\\{ g(p_n) : p_n \\geq 5 \\text{ and } p_{n+1} \\leq x \\}$。条件 $p_n \\geq 5$ 意味着我们从素数对 $(p_3, p_4) = (5, 7)$ 开始搜索间隙。只要 $p_{n+1} \\leq x$，我们就考虑所有后续的间隙 $g(p_n)$。孪生素数猜想假设存在无穷多个素数对 $(p, p+2)$，这意味着对于足够大的 $x$，$G_{\\min}^{\\geq 5}(x)$ 应该为 $2$。对于测试集中的所有 $x$ 值，都存在至少一对孪生素数 $(p, p+2)$，满足 $p \\geq 5$ 且 $p+2 \\leq x$，因此我们期望找到 $G_{\\min}^{\\geq 5}(x) = 2$。\n\n-   **比值 $R_1(x)$ 和 $R_2(x)$**：它们的定义为 $R_1(x) = \\frac{G_{\\max}(x)}{\\log x}$ 和 $R_2(x) = \\frac{G_{\\max}(x)}{(\\log x)^2}$。这些比值使用自然对数函数 `numpy.log` 和先前计算的 $G_{\\max}(x)$ 直接计算得出。$R_1(x)$ 以平均间隙大小为单位来衡量最大间隙。$R_2(x)$ 根据 Cramér 提出的启发式模型来检验最大间隙的量级。虽然 Cramér 最初的概率模型表明 $\\limsup_{n \\to \\infty} \\frac{g(p_n)}{(\\log p_n)^2} = 1$，但更精确的启发式模型表明该常数可能不同。这些经验比值为检验这些想法提供了一个简单的数值测试。\n\n实现过程将把这些步骤合成为一个单一的程序，该程序首先构建素数列表，然后遍历测试用例以计算并按规定格式化结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes empirical statistics of prime gaps up to a specified limit.\n    \"\"\"\n\n    # Define the upper bound for prime generation.\n    # The largest test case is 10^7, so we generate primes up to this limit.\n    limit = 10**7\n\n    # Step 1: Generate all primes up to the limit using the Sieve of Eratosthenes.\n    # This function returns a sorted numpy array of prime numbers.\n    def sieve_of_eratosthenes(n):\n        \"\"\"Generates primes up to n using the Sieve of Eratosthenes.\"\"\"\n        # Create a boolean array `is_prime` of size n + 1.\n        is_prime = np.ones(n + 1, dtype=bool)\n        is_prime[0] = is_prime[1] = False  # 0 and 1 are not prime.\n\n        # Iterate from p = 2 up to sqrt(n).\n        for p in range(2, int(np.sqrt(n)) + 1):\n            if is_prime[p]:\n                # Mark all multiples of p as not prime, starting from p*p.\n                is_prime[p*p::p] = False\n        \n        # Extract prime numbers from the boolean array.\n        primes = np.where(is_prime)[0]\n        return primes\n\n    primes = sieve_of_eratosthenes(limit)\n\n    # Step 2: Define the test cases from the problem statement.\n    test_cases = [\n        30,\n        100000,\n        1000000,\n        3000000,\n        10000000,\n    ]\n\n    all_results = []\n    # Step 3: Process each test case.\n    for x in test_cases:\n        # Find all primes less than or equal to x.\n        # np.searchsorted gives the index where x would be inserted to maintain order.\n        # 'right' side ensures that if x is prime, it's included.\n        k = np.searchsorted(primes, x, side='right')\n        primes_subset = primes[:k]\n        \n        # Ensure there are at least two primes to form a gap.\n        if k  2:\n            # This case is not reached with the given test suite.\n            continue\n            \n        p_k = primes_subset[-1]\n\n        # Calculate all gaps between consecutive primes up to x.\n        gaps = primes_subset[1:] - primes_subset[:-1]\n        \n        # a) Maximal observed gap up to x, G_max(x)\n        g_max = np.max(gaps) if gaps.size > 0 else 0\n\n        # b) Empirical average gap up to x, g_bar(x)\n        # Note: k is the count of primes, p_1=2, so k-1 is the number of gaps.\n        g_bar = (p_k - 2) / (k - 1)\n        \n        # c) Minimal gap for primes >= 5, G_min_geq_5(x)\n        # Find the index of the first prime >= 5.\n        # For all test cases, this will be index 2 (prime 5).\n        start_idx = np.searchsorted(primes_subset, 5)\n        \n        # Check if there are any gaps to consider.\n        if start_idx  len(gaps):\n            g_min_geq_5 = np.min(gaps[start_idx:])\n        else:\n            # No primes >= 5, so no such gaps. Not possible with given tests.\n            g_min_geq_5 = float('inf')\n\n        # d) Ratios R1(x) and R2(x)\n        ln_x = np.log(x)\n        r1 = g_max / ln_x\n        r2 = g_max / (ln_x**2)\n        \n        # Store results for this case. x, g_max, g_min are integers.\n        # g_bar, r1, r2 are floating-point values.\n        result_list = [int(x), int(g_max), g_bar, int(g_min_geq_5), r1, r2]\n        all_results.append(result_list)\n\n    # Step 4: Format and print the final output exactly as required.\n    formatted_sublists = []\n    for res in all_results:\n        x_val, gmax_val, gbar_val, gmin_val, r1_val, r2_val = res\n        s = f\"[{x_val},{gmax_val},{gbar_val:.6f},{gmin_val},{r1_val:.6f},{r2_val:.6f}]\"\n        formatted_sublists.append(s)\n\n    # The final print statement must produce a single line in the specified format.\n    print(f\"[{','.join(formatted_sublists)}]\")\n\nsolve()\n```", "id": "3084537"}]}