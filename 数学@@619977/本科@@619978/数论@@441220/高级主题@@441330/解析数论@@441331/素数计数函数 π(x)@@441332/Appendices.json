{"hands_on_practices": [{"introduction": "要研究素数计数函数 $\\pi(x)$ 的性质，我们首先需要一种有效计算其精确值的方法。虽然逐一检验每个数是否为素数是一种直接的思路，但其效率低下。本练习将引导你实现经典的埃拉托斯特尼筛法 (Sieve of Eratosthenes)，这是一种极其优雅且高效的算法，用于找出一定范围内的所有素数。通过这个实践，你不仅将把一个古老的数学思想转化为计算机代码，还将对该算法的正确性和计算复杂度进行严谨的分析 [@problem_id:3092903]。", "problem": "实现一个完整的程序，使用埃拉托斯特尼筛法计算素数计数函数 $\\pi(x)$，并在附带的书面解答中，从核心定义出发，推导其正确性并分析其关于 $x$ 的时间和空间复杂度。素数计数函数 $\\pi(x)$ 定义为小于或等于 $x$ 的素数个数。素数是大于 $1$ 且除了 $1$ 和自身之外没有其他正整数因数的正整数。埃拉托斯特尼筛法是一种经典的算法，它从最小的素数开始，通过迭代地标记合数来识别素数。你的推导必须严格地从这些定义和经过充分检验的事实出发，并且不得在没有论证的情况下假设或陈述现成的复杂度公式。你的程序实现的算法过程应遵循以下在数学上忠实的步骤：初始化一个布尔数组，表示从 $0$ 到 $x$ 的所有整数的素性；将所有大于等于 $2$ 的整数的条目设置为真；对于从 $2$ 到 $\\lfloor \\sqrt{x} \\rfloor$ 的每个整数 $p$，如果 $p$ 当前被标记为素数，则将其从 $p^2$ 到 $x$ 的所有倍数标记为合数。循环结束后，通过计算从 $2$ 到 $x$ 对应素数（真）的条目数来计算 $\\pi(x)$。确保程序能正确处理边界情况 $x = 0$ 和 $x = 1$。\n\n测试套件规范：\n- 对 $x$ 使用以下固定测试输入：$0$, $1$, $2$, $10$, $100$, $10^6$。\n- 对于测试套件中的每个 $x$，以整数形式输出 $\\pi(x)$ 的值。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含测试套件的结果，按顺序排列，形式为用方括号括起来的逗号分隔列表，没有空格。例如，对于三个结果 $a$, $b$, $c$，输出格式应为 $[a,b,c]$。", "solution": "任务是使用埃拉托斯特尼筛法实现素数计数函数 $\\pi(x)$，并对算法的正确性和复杂度进行严格的推导。函数 $\\pi(x)$ 定义为小于或等于一个非负实数 $x$ 的素数个数。素数是大于 $1$ 且除了 $1$ 和自身之外没有其他正整数因数的正整数。\n\n首先对问题进行验证。\n\n**步骤1：提取已知条件**\n- **函数定义**：$\\pi(x)$，即素数 $p \\le x$ 的数量。\n- **素数定义**：大于 $1$ 且除了 $1$ 和自身之外没有其他正整数因数的正整数。\n- **算法**：埃拉托斯特尼筛法。\n- **算法步骤**：\n    1. 初始化一个布尔数组表示从 $0$ 到 $x$ 的整数的素性。我们将其表示为 `is_prime`。\n    2. 对所有 $i \\ge 2$，设置 `is_prime[i]` 为真。\n    3. 对于从 $2$ 到 $\\lfloor \\sqrt{x} \\rfloor$ 的每个整数 $p$：\n    4. 如果 $p$ 被标记为素数（即 `is_prime[p]` 为真）：\n    5. 将从 $p^2$ 到 $x$ 的 $p$ 的每个倍数标记为合数（即对 $j = p^2, p^2+p, \\dots \\le x$，设置 `is_prime[j]` 为假）。\n    6. 循环结束后，通过计算从 $2$ 到 $x$ 中 `is_prime[i]` 为真的索引 $i$ 的数量来计算 $\\pi(x)$。\n- **边界情况**：处理 $x=0$ 和 $x=1$。\n- **测试套件**：$x \\in \\{0, 1, 2, 10, 100, 10^6\\}$。\n- **输出格式**：单行 `[r1,r2,r3,r4,r5,r6]`，其中 $r_i$ 是第 $i$ 个测试用例的结果。\n\n**步骤2：使用提取的已知条件进行验证**\n该问题在数学上和算法上都是明确定义的。它基于数论的基本概念。素数、素数计数函数以及埃拉托斯特尼筛法的步骤的定义都是标准且正确的。该问题是自洽的、一致的，并为获得唯一的、可验证的解决方案提供了清晰的路径。对于给定的测试套件，计算要求是可行的。因此，该问题被认定为**有效**。\n\n**步骤3：结论与行动**\n问题有效。将提供完整的解决方案。\n\n### 正确性推导与复杂度分析\n\n**算法规范**\n\n设 $x$ 为一个非负整数。我们希望计算 $\\pi(x)$。\n1.  创建一个大小为 $x+1$ 的布尔数组 `is_prime`。\n2.  对 $i \\in \\{0, 1\\}$，初始化 `is_prime[i] = \\text{false}`；对 $i \\in \\{2, 3, \\dots, x\\}$，初始化 `is_prime[i] = \\text{true}`。\n3.  对于从 $2$ 到 $\\lfloor \\sqrt{x} \\rfloor$ 的 $p$：\n    a. 如果 `is_prime[p]` 为真：\n    b. 对于从 $p^2$ 到 $x$、步长为 $p$ 的 $j$：\n       设置 `is_prime[j] = \\text{false}`。\n4.  计算 $\\pi(x) = \\sum_{i=2}^{x} \\mathbb{I}(\\text{is\\_prime}[i])$，其中 $\\mathbb{I}$ 是指示函数（如果为真则为1，否则为0）。\n\n**正确性推导**\n\n算法的正确性取决于每个合数都可以被因式分解这一性质，特别地，它有一个小的素因数。这源于算术基本定理，该定理指出，每个大于 $1$ 的整数要么本身是素数，要么可以表示为素数的乘积，且这种表示在不考虑因数顺序的情况下是唯一的。\n\n**引理：** 每个大于 $1$ 的合数 $n$ 至少有一个素因数 $p$ 满足 $p \\le \\sqrt{n}$。\n\n**引理证明：** 设 $n$ 是一个合数。根据定义，$n$ 可以写成 $n = a \\cdot b$ 的形式，其中 $a, b$ 是整数且 $1  a \\le b  n$。假设（为了引出矛盾）$n$ 的所有素因数都大于 $\\sqrt{n}$。由于 $a$ 是 $n$ 的一个因数，其素因数是 $n$ 的素因数的子集。因此，$a$ 的所有素因数也必须大于 $\\sqrt{n}$。因为 $a > 1$，$a$ 必须至少有一个素因数，我们称之为 $p_a$。那么 $a \\ge p_a > \\sqrt{n}$。类似地，$b > 1$，所以它必须有一个素因数 $p_b > \\sqrt{n}$，这意味着 $b \\ge p_b > \\sqrt{n}$。这导致了矛盾 $n = a \\cdot b > \\sqrt{n} \\cdot \\sqrt{n} = n$。因此，最初的假设必定是错误的。至少有一个因数，比如 $a$，必须满足 $a \\le \\sqrt{n}$。如果 $a$ 是素数，我们就找到了我们的素因数 $p=a \\le \\sqrt{n}$。如果 $a$ 是合数，它有一个素因数 $p'$，该素因数必须小于 $a$，所以 $p'  a \\le \\sqrt{n}$。在所有情况下，$n$ 都有一个素因数 $p \\le \\sqrt{n}$。\n\n**正确性主证明：**\n该算法通过排除法工作。它首先假设从 $2$ 到 $x$ 的所有数都是素数，然后迭代地标记合数。一个数 $i \\le x$ 只有在任何迭代中都未被标记为合数时，才会保持被标记为素数。\n\n设 $c$ 为任意合数，满足 $2 \\le c \\le x$。根据引理，$c$ 必须有一个素因数 $p' \\le \\sqrt{c}$。由于 $c \\le x$，因此 $\\sqrt{c} \\le \\sqrt{x}$，从而 $p' \\le \\sqrt{x}$。\n\n算法的外层循环遍历从 $2$ 到 $\\lfloor \\sqrt{x} \\rfloor$ 的整数 $p$。这个 $p$ 的范围保证了会包含任何不大于 $x$ 的合数 $c$ 的最小素因数 $p'$。当循环变量 $p$ 取到这个素数 $p'$ 的值时，条件 `is_prime[p]` 将为真（因为 $p'$ 是它所除的任何合数的*最小*素因数，它不可能被一个更小的素数所排除）。然后内层循环将执行，并将 $p'$ 的所有倍数标记为合数。由于 $c$ 是 $p'$ 的倍数，`is_prime[c]` 将被设置为假。\n\n这表明每个在 $\\{2, \\dots, x\\}$ 中的合数 $c$ 都会被正确识别并标记为非素数。因此，任何在 $\\{2, \\dots, x\\}$ 中仍然被标记为真的数 $i$，都没有小于或等于 $\\sqrt{i}$ 的素因数，根据我们引理的逆否命题，这意味著 $i$ 不可能是合数。因此，$i$ 必须是素数。\n\n**从 $p^2$ 开始的理由**：标记素数 $p$ 的倍数的内层循环从 $p^2$ 而不是 $2p$ 开始。考虑任何合数 $m = k \\cdot p$，其中 $k  p$。数字 $k$ 必须有一个素因数 $q \\le k$。由于 $k  p$，因此 $q  p$。当外层循环处理素数 $q$ 时（这发生在处理 $p$ 之前），它已经标记了 $q$ 的所有倍数，包括 $m$。因此，当算法考虑素数 $p$ 时，所有小于 $p^2$ 且以 $p$ 为因数的合数都已经被排除了。这个优化是正确的，并且提高了性能。\n\n最后，由于 `is_prime` 数组正确地识别了直到 $x$ 的所有素数，将从 $2$ 到 $x$ 的真值相加即可得到素数的总数，这正是 $\\pi(x)$ 的定义。\n\n**复杂度分析**\n\n**空间复杂度：**\n主要的数据结构是大小为 $x+1$ 的布尔数组 `is_prime`。所需的空间与 $x$ 成正比。因此，空间复杂度为 $O(x)$。\n\n**时间复杂度：**\n算法的总运行时间是三部分之和：初始化、筛选和计数。\n1.  **初始化**：创建和初始化大小为 $x+1$ 的布尔数组需要 $O(x)$ 时间。\n2.  **筛选循环**：外层循环从 $p=2$ 运行到 $\\lfloor \\sqrt{x} \\rfloor$。对于此范围内的每个素数 $p$，内层循环执行标记操作。对于给定的素数 $p$，操作次数是其从 $p^2$ 到 $x$ 的倍数数量，即 $\\lfloor x/p \\rfloor - (p-1)$。对于大的 $x$，这大约是 $x/p$。因此，标记操作的总数是所有 $p \\le \\sqrt{x}$ 的素数的总和：\n    $$ T_{sieve}(x) \\approx \\sum_{p \\le \\sqrt{x}, p \\text{ is prime}} \\frac{x}{p} $$\n    我们可以提出 $x$：\n    $$ T_{sieve}(x) \\approx x \\sum_{p \\le \\sqrt{x}} \\frac{1}{p} $$\n    解析数论中一个公认的结果，即默滕斯第二定理，指出直到数 $N$ 的素数倒数之和的渐近行为由以下公式描述：\n    $$ \\sum_{p \\le N} \\frac{1}{p} \\approx \\ln(\\ln N) + M $$\n    其中 $M$ 是 Meissel-Mertens 常数。在我们的例子中，$N = \\sqrt{x}$。因此，这个和是：\n    $$ \\sum_{p \\le \\sqrt{x}} \\frac{1}{p} \\approx \\ln(\\ln \\sqrt{x}) = \\ln(\\frac{1}{2}\\ln x) = \\ln(\\ln x) - \\ln 2 $$\n    这个和的渐近行为是 $O(\\log \\log x)$。\n    将此代入筛选时间的表达式中，我们得到：\n    $$ T_{sieve}(x) = O(x \\log \\log x) $$\n3.  **计数**：最后一步是遍历数组从 $2$ 到 $x$ 来计数素数。这需要 $O(x)$ 时间。\n\n**总时间复杂度**：总时间复杂度是这些部分复杂度的总和：$O(x) + O(x \\log \\log x) + O(x)$。主导项是 $O(x \\log \\log x)$。因此，埃拉托斯特尼筛法的总时间复杂度是 $O(x \\log \\log x)$。\n\n至此，正确性推导和复杂度分析完成。实现将基于这个经过验证的算法进行。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes pi(x) for a list of test cases and prints the results.\n    \"\"\"\n\n    def pi_sieve(x: int) - int:\n        \"\"\"\n        Calculates the prime-counting function pi(x) using the Sieve of Eratosthenes.\n\n        Args:\n            x: An integer specifying the upper bound (inclusive).\n\n        Returns:\n            The number of prime numbers less than or equal to x.\n        \"\"\"\n        # Handle edge cases for x  2, where there are no primes.\n        if x  2:\n            return 0\n\n        # Step 1  2: Initialize a boolean array 'is_prime' for integers up to x.\n        # Assume all numbers from 2 to x are prime initially.\n        # We use numpy for efficient array operations.\n        is_prime = np.ones(x + 1, dtype=bool)\n        is_prime[0] = is_prime[1] = False\n\n        # Step 3: Iterate from p = 2 up to sqrt(x).\n        # We only need to check for factors up to sqrt(x) based on the principle that\n        # any composite number n has a prime factor p = sqrt(n).\n        limit = int(np.sqrt(x))\n        for p in range(2, limit + 1):\n            # Step 4: If p is still marked as prime.\n            if is_prime[p]:\n                # Step 5: Mark all multiples of p from p^2 up to x as not prime.\n                # We start from p*p as an optimization, because any smaller multiple\n                # k*p (with k  p) would have already been marked by a prime factor of k.\n                is_prime[p*p::p] = False\n\n        # Step 6: Count the number of primes remaining in the array.\n        # np.sum() on a boolean array counts the number of True values.\n        return int(np.sum(is_prime))\n\n    # Define the test cases from the problem statement.\n    test_cases = [0, 1, 2, 10, 100, 10**6]\n\n    results = []\n    for x_val in test_cases:\n        pi_val = pi_sieve(x_val)\n        results.append(pi_val)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3092903"}, {"introduction": "在掌握了如何精确计算 $\\pi(x)$ 之后，我们转向理解其渐近行为。素数定理告诉我们 $\\pi(x)$ 可以由简单的函数 $\\frac{x}{\\ln x}$ 来近似，但一个更精确的近似是由对数积分函数 $\\mathrm{Li}(x)$ 给出。本练习将带你深入探究这两者之间的差异 [@problem_id:3092882]。你将运用积分技巧（特别是分部积分法）来从数学上揭示为什么 $\\mathrm{Li}(x)$ 是一个更高阶的近似，从而加深对素数分布理论的理解。", "problem": "设 $\\pi(x)$ 表示素数计数函数，对数积分 $\\mathrm{Li}(x)$ 由积分 $\\mathrm{Li}(x) = \\int_{2}^{x} \\frac{dt}{\\ln t}$ 定义。考虑在素数定理（PNT）的意义下，用 $\\frac{x}{\\ln x}$ 和 $\\mathrm{Li}(x)$ 对 $\\pi(x)$ 进行近似。素数定理断言 $\\pi(x)$ 与这两个函数都是渐近接近的。从 $\\mathrm{Li}(x)$ 的积分定义出发，仅使用自然对数和积分的基本性质，推导以下差值的精确表达式\n$$\n\\Delta(x) := \\mathrm{Li}(x) - \\frac{x}{\\ln x}.\n$$\n然后，确定当 $x \\to \\infty$ 时 $\\Delta(x)$ 的主项，并基于此主项解释为什么用 $\\mathrm{Li}(x)$ 替换 $\\frac{x}{\\ln x}$ 会使对 $\\pi(x)$ 的近似在 $\\ln x$ 的负幂次上改进一个阶。你的最终答案应该是当 $x \\to \\infty$ 时 $\\Delta(x)$ 主项的单一闭式符号表达式。", "solution": "问题要求分析素数计数函数 $\\pi(x)$ 的两个近似值之间的差异：对数积分 $\\mathrm{Li}(x)$ 和更简单的函数 $\\frac{x}{\\ln x}$。我们已知定义 $\\mathrm{Li}(x) = \\int_{2}^{x} \\frac{dt}{\\ln t}$ 和 $\\Delta(x) = \\mathrm{Li}(x) - \\frac{x}{\\ln x}$。我们的目标是找到 $\\Delta(x)$ 的精确表达式，确定当 x 很大时其主项，并解释该项在近似 $\\pi(x)$ 的背景下的意义。\n\n首先，我们验证问题陈述的有效性。\n**第一步：提取已知条件**\n- $\\pi(x)$：素数计数函数。\n- $\\mathrm{Li}(x) = \\int_{2}^{x} \\frac{dt}{\\ln t}$：对数积分。\n- $\\Delta(x) := \\mathrm{Li}(x) - \\frac{x}{\\ln x}$：两个近似值之间的差。\n- 素数定理（PNT）断言 $\\pi(x)$ 与 $\\frac{x}{\\ln x}$ 和 $\\mathrm{Li}(x)$ 都是渐近接近的。\n- 任务是推导 $\\Delta(x)$ 的表达式，求其当 $x \\to \\infty$ 时的主项，并解释为什么 $\\mathrm{Li}(x)$ 是比 $\\frac{x}{\\ln x}$ 更好的 $\\pi(x)$ 近似。\n\n**第二步：使用提取的已知条件进行验证**\n该问题具有科学依据，是解析数论中的一个标准课题。$\\pi(x)$、$\\mathrm{Li}(x)$ 和 PNT 的定义都是标准且正确的。问题是适定的、客观的且自包含的。它要求对一个良定义的积分进行标准的渐近分析，这是一个可形式化和可解决的任务。不存在科学缺陷、歧义或矛盾。\n\n**第三步：结论与行动**\n问题有效。我们将着手推导解答。\n\n出发点是 $\\Delta(x)$ 的定义：\n$$\n\\Delta(x) = \\mathrm{Li}(x) - \\frac{x}{\\ln x} = \\int_{2}^{x} \\frac{dt}{\\ln t} - \\frac{x}{\\ln x}\n$$\n为分析该积分项，我们使用分部积分法，这是获得此类积分的渐近展开式的标准方法。对于不定积分 $\\int \\frac{dt}{\\ln t}$，我们设 $u = \\frac{1}{\\ln t}$ 和 $dv = dt$。这得到 $du = -\\frac{1}{t(\\ln t)^2} dt$ 和 $v = t$。应用分部积分公式 $\\int u \\, dv = uv - \\int v \\, du$：\n$$\n\\int \\frac{dt}{\\ln t} = \\frac{t}{\\ln t} - \\int t \\left( -\\frac{1}{t(\\ln t)^2} \\right) dt = \\frac{t}{\\ln t} + \\int \\frac{dt}{(\\ln t)^2}\n$$\n现在，我们将此应用于定义 $\\mathrm{Li}(x)$ 的定积分：\n$$\n\\mathrm{Li}(x) = \\int_{2}^{x} \\frac{dt}{\\ln t} = \\left[ \\frac{t}{\\ln t} \\right]_{2}^{x} + \\int_{2}^{x} \\frac{dt}{(\\ln t)^2}\n$$\n$$\n\\mathrm{Li}(x) = \\left( \\frac{x}{\\ln x} - \\frac{2}{\\ln 2} \\right) + \\int_{2}^{x} \\frac{dt}{(\\ln t)^2}\n$$\n将 $\\mathrm{Li}(x)$ 的这个表达式代入 $\\Delta(x)$ 的定义，我们得到差值的精确表达式：\n$$\n\\Delta(x) = \\left( \\frac{x}{\\ln x} - \\frac{2}{\\ln 2} + \\int_{2}^{x} \\frac{dt}{(\\ln t)^2} \\right) - \\frac{x}{\\ln x}\n$$\n$$\n\\Delta(x) = \\int_{2}^{x} \\frac{dt}{(\\ln t)^2} - \\frac{2}{\\ln 2}\n$$\n这个表达式是精确的。为了求出当 $x \\to \\infty$ 时 $\\Delta(x)$ 的主项，我们必须确定积分项的渐近行为。我们可以再次对积分 $\\int_2^x \\frac{dt}{(\\ln t)^2}$ 应用分部积分法。设 $u = \\frac{1}{(\\ln t)^2}$ 和 $dv = dt$。这得到 $du = -\\frac{2}{t(\\ln t)^3} dt$ 和 $v = t$。\n$$\n\\int_{2}^{x} \\frac{dt}{(\\ln t)^2} = \\left[ \\frac{t}{(\\ln t)^2} \\right]_{2}^{x} - \\int_{2}^{x} t \\left( -\\frac{2}{t(\\ln t)^3} \\right) dt\n$$\n$$\n\\int_{2}^{x} \\frac{dt}{(\\ln t)^2} = \\frac{x}{(\\ln x)^2} - \\frac{2}{(\\ln 2)^2} + 2 \\int_{2}^{x} \\frac{dt}{(\\ln t)^3}\n$$\n现在 $\\Delta(x)$ 的完整表达式为：\n$$\n\\Delta(x) = \\left( \\frac{x}{(\\ln x)^2} - \\frac{2}{(\\ln 2)^2} + 2 \\int_{2}^{x} \\frac{dt}{(\\ln t)^3} \\right) - \\frac{2}{\\ln 2}\n$$\n当 $x \\to \\infty$ 时，常数项 $-\\frac{2}{(\\ln 2)^2}$ 和 $-\\frac{2}{\\ln 2}$ 与包含 $x$ 的项相比可以忽略不计。主导行为由项 $\\frac{x}{(\\ln x)^2}$ 和剩余的积分决定。我们可以通过对以下比值应用洛必达法则来证明该积分的阶低于 $\\frac{x}{(\\ln x)^2}$：\n$$\n\\lim_{x \\to \\infty} \\frac{\\int_{2}^{x} \\frac{dt}{(\\ln t)^3}}{\\frac{x}{(\\ln x)^2}}\n$$\n对分子（使用微积分基本定理）和分母关于 $x$ 求导：\n$$\n\\frac{d}{dx} \\int_{2}^{x} \\frac{dt}{(\\ln t)^3} = \\frac{1}{(\\ln x)^3}\n$$\n$$\n\\frac{d}{dx} \\left( \\frac{x}{(\\ln x)^2} \\right) = \\frac{1 \\cdot (\\ln x)^2 - x \\cdot 2(\\ln x)\\frac{1}{x}}{(\\ln x)^4} = \\frac{(\\ln x)^2 - 2\\ln x}{(\\ln x)^4} = \\frac{\\ln x - 2}{(\\ln x)^3}\n$$\n导数之比的极限是：\n$$\n\\lim_{x \\to \\infty} \\frac{\\frac{1}{(\\ln x)^3}}{\\frac{\\ln x - 2}{(\\ln x)^3}} = \\lim_{x \\to \\infty} \\frac{1}{\\ln x - 2} = 0\n$$\n由于此极限为 $0$，我们证明了 $\\int_{2}^{x} \\frac{dt}{(\\ln t)^3} = o\\left(\\frac{x}{(\\ln x)^2}\\right)$。这意味着积分项渐近地小于 $\\frac{x}{(\\ln x)^2}$。\n因此，当 $x \\to \\infty$ 时，$\\Delta(x)$ 的主项为：\n$$\n\\Delta(x) \\sim \\frac{x}{(\\ln x)^2}\n$$\n这个结果使我们能够理解为什么 $\\mathrm{Li}(x)$ 是比 $\\frac{x}{\\ln x}$ 更好的 $\\pi(x)$ 近似。设这两个近似的误差为 $E_1(x) = \\pi(x) - \\frac{x}{\\ln x}$ 和 $E_2(x) = \\pi(x) - \\mathrm{Li}(x)$。这些误差之间的差是：\n$$\nE_1(x) - E_2(x) = \\left(\\pi(x) - \\frac{x}{\\ln x}\\right) - \\left(\\pi(x) - \\mathrm{Li}(x)\\right) = \\mathrm{Li}(x) - \\frac{x}{\\ln x} = \\Delta(x)\n$$\n所以，$E_1(x) = \\Delta(x) + E_2(x)$。根据我们的分析，$\\Delta(x)$ 的主导行为是 $\\frac{x}{(\\ln x)^2}$。由 de la Vallée Poussin 建立的更精确版本的素数定理指出，对于某个正常数 $c$，误差 $E_2(x)$ 的阶为 $O(x \\exp(-c\\sqrt{\\ln x}))$。这个误差项比 $\\ln x$ 的任何次幂都衰减得更快，即对于任何正整数 $k$，$E_2(x) = o\\left(\\frac{x}{(\\ln x)^k}\\right)$。\n因此，误差 $E_1(x)$ 中的主导项来自 $\\Delta(x)$：\n$$\nE_1(x) = \\pi(x) - \\frac{x}{\\ln x} \\sim \\frac{x}{(\\ln x)^2}\n$$\n这表明近似 $\\pi(x) \\approx \\frac{x}{\\ln x}$ 的误差阶为 $O\\left(\\frac{x}{(\\ln x)^2}\\right)$。近似 $\\mathrm{Li}(x)$ 有效地包含了渐近级数中的下一项，因为 $\\mathrm{Li}(x) \\approx \\frac{x}{\\ln x} + \\frac{x}{(\\ln x)^2}$。通过使用 $\\mathrm{Li}(x)$，我们从一个误差阶为 $(\\ln x)^{-2}$ 的近似转移到一个误差小得多的近似，从而在 $\\ln x$ 的负幂次上将近似改进了一个阶。\n当 $x \\to \\infty$ 时 $\\Delta(x)$ 的主项是所要求的最终答案。", "answer": "$$\n\\boxed{\\frac{x}{(\\ln x)^2}}\n$$", "id": "3092882"}, {"introduction": "理论与计算的结合是现代数论研究的重要特征。本综合性练习旨在设计一个计算实验，将前面所学的知识融会贯通 [@problem_id:3092945]。你将实现一个程序，它不仅能用筛法计算出 $\\pi(x)$ 的精确值，还能计算出三种不同的理论近似值：$\\frac{x}{\\ln x}$、$\\mathrm{Li}(x)$ 以及更为精确的黎曼 $R$ 函数。通过系统地比较这些近似值与精确值在不同数值范围内的误差，你将亲身体验数学家如何利用计算工具来验证理论、探索模式并获得深刻的直觉。", "problem": "设计并实现一个完整的、可运行的程序，该程序进行一项原则性的计算实验，比较素数计数函数的三个经典近似在对数间隔输入上的表现，并量化它们与精确计数的误差。素数计数函数定义为 $\\pi(x)$，表示小于或等于实数输入 $x$ 的素数个数；对于非整数输入，定义 $\\pi(x) := \\pi(\\lfloor x \\rfloor)$。三个近似方法如下：\n- $\\frac{x}{\\ln x}$，由素数定理证明。\n- 对数积分 $\\mathrm{Li}(x)$，定义为柯西主值积分 $\\mathrm{PV} \\int_{2}^{x} \\frac{dt}{\\ln t}$。\n- 黎曼 $R$ 函数 $R(x)$，由级数 $R(x) = \\displaystyle\\sum_{n=1}^{\\infty} \\frac{\\mu(n)}{n}\\mathrm{Li}(x^{1/n})$ 定义，其中 $\\mu(n)$ 是莫比乌斯函数。\n\n基于这些定义和解析数论中经过充分检验的事实，你的程序必须：\n1. 在每个指定范围内生成对数间隔的输入点 $x_i$，其中对数间隔意味着在 $\\log_{10}(x)$ 上等距。形式上，对于参数为 $x_{\\min}, x_{\\max}, m$ 的范围，构造 $m$ 个点\n$$\nx_i = 10^{\\log_{10}(x_{\\min}) + i\\frac{\\log_{10}(x_{\\max}) - \\log_{10}(x_{\\min})}{m-1}}\\quad\\text{for}\\quad i=0,1,\\dots,m-1.\n$$\n2. 使用正确的素数筛法和累积计数，为每个采样点精确计算 $\\pi(\\lfloor x_i \\rfloor)$。\n3. 为每个采样点计算三个近似值 $\\frac{x_i}{\\ln x_i}$、$\\mathrm{Li}(x_i)$ 和一个由下式定义的截断 $R(x_i)$：\n$$\nR_N(x) = \\sum_{n=1}^{N(x)} \\frac{\\mu(n)}{n}\\mathrm{Li}(x^{1/n}),\n$$\n截断索引为 $N(x) = \\left\\lfloor \\frac{\\ln x}{\\ln 2} \\right\\rfloor,$ 这包含了所有满足 $x^{1/n} \\ge 2$ 的项。\n4. 对于一组 $m$ 个采样点上的每个近似 $A(x)$，计算相对于精确值 $\\pi(\\lfloor x \\rfloor)$ 的以下误差度量：\n   - 最大绝对误差\n     $$\n     E_{\\max} = \\max_{i} \\left| A(x_i) - \\pi(\\lfloor x_i \\rfloor) \\right|.\n     $$\n   - 均方根绝对误差\n     $$\n     E_{\\mathrm{rms}} = \\sqrt{ \\frac{1}{m} \\sum_{i=1}^{m} \\left( A(x_i) - \\pi(\\lfloor x_i \\rfloor) \\right)^2 }.\n     $$\n   - 最大相对误差\n     $$\n     R_{\\max} = \\max_{i} \\frac{\\left| A(x_i) - \\pi(\\lfloor x_i \\rfloor) \\right|}{\\pi(\\lfloor x_i \\rfloor)}.\n     $$\n   - 平均相对误差\n     $$\n     R_{\\mathrm{mean}} = \\frac{1}{m} \\sum_{i=1}^{m} \\frac{\\left| A(x_i) - \\pi(\\lfloor x_i \\rfloor) \\right|}{\\pi(\\lfloor x_i \\rfloor)}.\n     $$\n5. 按 $[\\frac{x}{\\ln x}, \\mathrm{Li}(x), R(x)]$ 的顺序聚合每个近似的度量，每个近似贡献一个有序列表 $[E_{\\max}, E_{\\mathrm{rms}}, R_{\\max}, R_{\\mathrm{mean}}]$。\n\n使用以下范围的测试套件，每个范围由参数 $(x_{\\min}, x_{\\max}, m)$ 定义：\n- 情况1（通用，宽范围）：$(10, 10^6, 64)$。\n- 情况2（小$x$行为）：$(3, 10^3, 50)$。\n- 情况3（中等范围，更精细采样）：$(10^2, 10^5, 100)$。\n- 情况4（近边界行为）：$(2, 10^2, 25)$。\n\n最终输出格式规范：\n- 你的程序应生成单行输出，其中包含一个嵌套的、逗号分隔的列表，其中不含空格。外层列表每个条目对应一个测试用例，顺序如上所述。每个测试用例条目本身是一个包含三个子列表的列表，分别对应 $[\\frac{x}{\\ln x}, \\mathrm{Li}(x), R(x)]$，每个子列表包含四个浮点数，顺序为 $[E_{\\max}, E_{\\mathrm{rms}}, R_{\\max}, R_{\\mathrm{mean}}]$。例如，结构必须类似于\n$$\n[[[e_{11},e_{12},e_{13},e_{14}],[e_{21},e_{22},e_{23},e_{24}],[e_{31},e_{32},e_{33},e_{34}]],\\dots]\n$$\n打印为单行，无空格，其中所有 $e_{jk}$ 均为十进制数。", "solution": "该实验基于围绕素数计数函数及其解析近似的标准定义和事实。我们概述了将这些数学构造与稳健的计算设计联系起来的原理和算法步骤。\n\n1. 基本定义和事实。\n   - 素数计数函数 $\\pi(x)$ 计算小于或等于 $x$ 的素数数量。对于非整数 $x$，定义 $\\pi(x) := \\pi(\\lfloor x \\rfloor)$ 确保了对实数输入的无歧义数值计算，同时保留了计数函数的单调性。\n   - 根据素数定理，$\\pi(x) \\sim \\frac{x}{\\ln x}$，这使得 $\\frac{x}{\\ln x}$ 成为一个基准近似。\n   - 对数积分 $\\mathrm{Li}(x)$ 定义为柯西主值积分 $\\mathrm{PV}\\int_{2}^{x}\\frac{dt}{\\ln t}$。这避免了在 $t=1$ 处的奇点，并产生一个数值上稳定的对象，该对象在实践中已知能更紧密地追踪 $\\pi(x)$。\n   - 黎曼 $R(x)$ 函数由莫比乌斯加权级数 $R(x) = \\sum_{n=1}^{\\infty}\\frac{\\mu(n)}{n}\\mathrm{Li}(x^{1/n})$ 给出。在 $N(x) = \\left\\lfloor \\frac{\\ln x}{\\ln 2} \\right\\rfloor$ 处截断级数，包含了所有内部参数 $x^{1/n}\\ge 2$ 的项；这种截断是自然的，因为 $\\mathrm{Li}(y)$ 是通过一个以 $2$ 为基准的积分定义的，而由于 $\\mu(n)$ 的行为，$y2$ 的贡献通常很小且交错出现。\n\n2. 通过筛法精确计算 $\\pi(\\lfloor x \\rfloor)$。\n   - 我们使用埃拉托斯特尼筛法计算测试套件中最大 $x_{\\max}$ 以内的所有素数。该算法的依据是：一个合数必有一个小于或等于其平方根的素因子这一基本性质。具体来说：\n     - 初始化一个布尔数组 $\\text{is_prime}[0..N]$，除 $0$ 和 $1$ 外均为真。\n     - 对于从 $2$ 到 $\\lfloor \\sqrt{N} \\rfloor$ 的每个整数 $p$，如果 $p$ 被标记为素数，则将其所有大于等于 $p$ 倍的倍数 $kp$ 标记为非素数。\n     - 形成前缀和 $\\pi(n) = \\sum_{k=2}^{n} \\mathbf{1}_{\\text{prime}(k)}$，以获得所有 $n\\le N$ 的精确计数。通过索引即可立即得到 $\\pi(\\lfloor x \\rfloor)$。\n\n3. 对数间隔采样。\n   - 为了探究跨尺度的近似行为，我们在 $\\log_{10}(x)$ 上均匀采样点 $x_i$。这既能捕捉小尺度行为，也能捕捉大尺度行为，而不会过分强调任何特定的数量级。每个范围使用 $m$ 个样本，我们构造出\n     $$\n     x_i = 10^{\\log_{10}(x_{\\min}) + i\\frac{\\log_{10}(x_{\\max}) - \\log_{10}(x_{\\min})}{m-1}}.\n     $$\n   - 然后我们在这些点上计算 $\\pi(\\lfloor x_i \\rfloor)$ 和各个近似值。\n\n4. $\\mathrm{Li}(x)$ 的数值计算。\n   - 积分定义 $\\mathrm{PV} \\int_{2}^{x} \\frac{dt}{\\ln t}$ 可以通过已有的特殊函数来计算。具体来说，使用恒等式\n     $$\n     \\mathrm{Li}(x) = \\mathrm{Ei}(\\ln x) - \\mathrm{Ei}(\\ln 2),\n     $$\n     其中 $\\mathrm{Ei}$ 是指数积分函数。这个表示法通过换元 $t = e^{u}$ 得出，将被积函数 $\\frac{1}{\\ln t}$ 转换为 $\\frac{1}{u}$，并由主值恰当地处理对数奇点。对于 $x>0$，该恒等式是标准的且数值稳定的。\n\n5. 莫比乌斯函数 $\\mu(n)$ 和 $R(x)$ 的截断。\n   - 莫比乌斯函数的定义为：$\\mu(1)=1$；如果 $n$ 能被一个平方数整除，则 $\\mu(n)=0$；否则 $\\mu(n)=(-1)^{k}$，其中 $k$ 是 $n$ 的不同素因子的个数。对于较小的 $n$，我们可以通过试除法计算 $\\mu(n)$，因为对于所考虑的范围，截断索引 $N(x)$ 并不大。截断和\n     $$\n     R_N(x) = \\sum_{n=1}^{N(x)} \\frac{\\mu(n)}{n}\\mathrm{Li}(x^{1/n})\n     $$\n     保留了主要贡献，同时使计算保持易于处理。\n\n6. 误差度量。\n   - 对于 $m$ 个采样点上的每个近似 $A(x)$，我们用四个度量来量化与精确计数的偏差：\n     - 最大绝对误差 $E_{\\max} = \\max \\left|A(x_i)-\\pi(\\lfloor x_i \\rfloor)\\right|$ 捕捉最坏情况下的偏差。\n     - 均方根绝对误差 $E_{\\mathrm{rms}} = \\sqrt{\\frac{1}{m}\\sum \\left(A(x_i)-\\pi(\\lfloor x_i \\rfloor)\\right)^2}$ 总结了典型的误差幅度，并对大的偏差施加惩罚。\n     - 最大相对误差 $R_{\\max} = \\max \\frac{\\left|A(x_i)-\\pi(\\lfloor x_i \\rfloor)\\right|}{\\pi(\\lfloor x_i \\rfloor)}$ 将最坏情况的误差置于 $\\pi(x)$ 的尺度下进行考量。\n     - 平均相对误差 $R_{\\mathrm{mean}} = \\frac{1}{m}\\sum \\frac{\\left|A(x_i)-\\pi(\\lfloor x_i \\rfloor)\\right|}{\\pi(\\lfloor x_i \\rfloor)}$ 提供了平均的相对差异。\n\n7. 测试套件设计。\n   - 情况1 $(10, 10^6, 64)$ 是一个宽范围的“理想路径”，测试小 $x$ 和大 $x$。\n   - 情况2 $(3, 10^3, 50)$ 关注小 $x$，在此处近似不太准确，且 $x=2$ 附近的奇异行为很重要。\n   - 情况3 $(10^2, 10^5, 100)$ 在中等范围使用更精细的采样来测试度量的稳定性和收敛性。\n   - 情况4 $(2, 10^2, 25)$ 检查从对数积分的基准点开始的近边界行为。\n\n8. 输出聚合。\n   - 对于每种情况，我们按固定顺序 $[\\frac{x}{\\ln x}, \\mathrm{Li}(x), R(x)]$ 返回三个近似度量列表，每个列表包含 $[E_{\\max}, E_{\\mathrm{rms}}, R_{\\max}, R_{\\mathrm{mean}}]$。程序打印一行包含所有情况的嵌套列表，元素以逗号分隔，无空格，并严格按照指定的顺序。\n\n该设计遵循素数计数函数及其近似的数学基础，采用数值上稳健的计算技术，并在精心选择的测试场景中提供全面的误差量化。筛法确保了精确计数，特殊函数可靠地处理了积分，$R(x)$ 的截断则平衡了准确性和计算效率。最终的输出规范使得自动化测试工具能够进行确定性验证。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import special as spsp\n\ndef logarithmic_space(x_min: float, x_max: float, m: int) - np.ndarray:\n    \"\"\"Create m points spaced equally in log10 between x_min and x_max.\"\"\"\n    return np.logspace(np.log10(x_min), np.log10(x_max), num=m)\n\ndef prime_pi_array(N: int) - np.ndarray:\n    \"\"\"\n    Compute pi(n) for all n = N using the sieve of Eratosthenes and prefix sums.\n    Returns an array pi where pi[n] = number of primes = n.\n    \"\"\"\n    if N  2:\n        # Handle trivial case\n        pi = np.zeros(N + 1, dtype=int)\n        return pi\n    is_prime = np.ones(N + 1, dtype=bool)\n    is_prime[:2] = False\n    limit = int(np.sqrt(N))\n    for p in range(2, limit + 1):\n        if is_prime[p]:\n            start = p * p\n            is_prime[start:N + 1:p] = False\n    pi = np.cumsum(is_prime.astype(int))\n    return pi\n\ndef li_offset(x: float) - float:\n    \"\"\"\n    Compute Li(x) defined as PV ∫_2^x dt / log t via special function:\n    Li(x) = Ei(log x) - Ei(log 2). This is valid for x > 0.\n    \"\"\"\n    return float(spsp.expi(np.log(x)) - spsp.expi(np.log(2.0)))\n\ndef mobius_values_up_to(K: int) - np.ndarray:\n    \"\"\"\n    Compute the Möbius function mu(n) for n = 1..K using trial division.\n    mu(1) = 1; mu(n) = 0 if n has a squared prime factor; otherwise mu(n) = (-1)^k\n    where k is the number of distinct prime factors.\n    \"\"\"\n    mu = np.zeros(K + 1, dtype=int)\n    if K >= 1:\n        mu[1] = 1\n    for n in range(2, K + 1):\n        num = n\n        parity = 0\n        square_free = True\n        p = 2\n        while p * p = num:\n            if num % p == 0:\n                cnt = 0\n                while num % p == 0:\n                    num //= p\n                    cnt += 1\n                if cnt > 1:\n                    square_free = False\n                    break\n                parity ^= 1\n            p = 3 if p == 2 else p + 2\n        if square_free:\n            # Remaining factor if >1 is prime\n            if num > 1:\n                parity ^= 1\n            mu[n] = -1 if parity == 1 else 1\n        else:\n            mu[n] = 0\n    return mu\n\ndef riemann_R_truncated(x: float, mu: np.ndarray) - float:\n    \"\"\"\n    Compute truncated R(x) = sum_{n=1}^{N(x)} mu(n)/n * Li(x^{1/n}),\n    with N(x) = floor(log(x)/log(2)), N >= 1.\n    \"\"\"\n    if x  1.0:\n        return 0.0\n    N = int(np.floor(np.log(x) / np.log(2.0)))\n    if N  1:\n        N = 1\n    # Ensure mu array is large enough\n    if len(mu) - 1  N:\n        mu = mobius_values_up_to(N)\n    total = 0.0\n    for n in range(1, N + 1):\n        term_arg = x ** (1.0 / n)\n        if mu[n] != 0 and term_arg >= 2.0:\n             total += (mu[n] / n) * li_offset(term_arg)\n    return float(total)\n\ndef compute_metrics(approx_values: np.ndarray, exact_values: np.ndarray) - list:\n    \"\"\"\n    Compute [E_max, E_rms, R_max, R_mean] for a set of approximations vs exact values.\n    \"\"\"\n    errors = approx_values - exact_values\n    abs_errors = np.abs(errors)\n    E_max = float(np.max(abs_errors))\n    E_rms = float(np.sqrt(np.mean(errors ** 2))) # Use actual errors for RMS, not absolute.\n    # Relative errors: exact_values are pi(x) >= 1 for x >= 2 in our test sets\n    # Add a small epsilon to avoid division by zero if pi(x) can be 0, though not in these tests.\n    rel_errors = abs_errors / np.maximum(exact_values, 1e-12)\n    R_max = float(np.max(rel_errors))\n    R_mean = float(np.mean(rel_errors))\n    return [E_max, E_rms, R_max, R_mean]\n\ndef serialize_no_spaces(obj) - str:\n    \"\"\"\n    Serialize nested lists of numbers into a string with no spaces, e.g., [[1.0,2.0],[3.0,4.0]] -> '[[1.0,2.0],[3.0,4.0]]'\n    \"\"\"\n    if isinstance(obj, list):\n        return \"[\" + \",\".join(serialize_no_spaces(el) for el in obj) + \"]\"\n    elif isinstance(obj, (int, np.integer)):\n        return str(int(obj))\n    elif isinstance(obj, (float, np.floating)):\n        # Format to a reasonable precision to keep output clean\n        return f\"{obj:.7f}\".rstrip('0').rstrip('.') if obj != 0 else \"0.0\"\n    else:\n        return str(obj)\n\ndef solve():\n    # Define the test cases from the problem statement: (x_min, x_max, m)\n    test_cases = [\n        (10.0, 1_000_000.0, 64),  # Case 1\n        (3.0, 1_000.0, 50),       # Case 2\n        (100.0, 100_000.0, 100),  # Case 3\n        (2.0, 100.0, 25),         # Case 4\n    ]\n\n    # Precompute pi(n) up to the largest x_max across all test cases (floor)\n    max_x = int(max(case[1] for case in test_cases))\n    pi_prefix = prime_pi_array(max_x)\n\n    results_all_cases = []\n\n    # Precompute a sufficiently large Möbius table for worst-case truncation.\n    max_N = int(np.floor(np.log(max_x) / np.log(2.0))) if max_x > 1 else 1\n    mu_table = mobius_values_up_to(max_N)\n\n    for (x_min, x_max, m) in test_cases:\n        xs = logarithmic_space(x_min, x_max, m)\n        floors = np.floor(xs).astype(int)\n        floors = np.clip(floors, 0, max_x)\n        exact = pi_prefix[floors]\n\n        # A1: x / ln x\n        with np.errstate(divide='ignore', invalid='ignore'):\n            approx_x_over_log = xs / np.log(xs)\n\n        # A2: Li(x)\n        approx_li = np.array([li_offset(float(x)) for x in xs], dtype=float)\n\n        # A3: R(x) truncated\n        approx_R = np.array([riemann_R_truncated(float(x), mu_table) for x in xs], dtype=float)\n\n        metrics_x_over_log = compute_metrics(approx_x_over_log, exact)\n        metrics_li = compute_metrics(approx_li, exact)\n        metrics_R = compute_metrics(approx_R, exact)\n\n        case_results = [metrics_x_over_log, metrics_li, metrics_R]\n        results_all_cases.append(case_results)\n\n    # Final print statement in the exact required format (no spaces).\n    print(serialize_no_spaces(results_all_cases))\n\nsolve()\n```", "id": "3092945"}]}