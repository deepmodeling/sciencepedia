{"hands_on_practices": [{"introduction": "在深入研究等差数列中的素数之前，我们必须首先确定一个基本前提：什么样的数列才可能包含多个素数。这个练习通过一个简单的例子，阐明了数列公差 $a$ 和首项 $b$ 的最大公约数 $\\gcd(a,b)$ 所扮演的关键角色。理解这个条件是应用如狄利克雷定理等更深刻理论的必要第一步。[@problem_id:3088505]", "problem": "考虑由 $10n+5$（其中 $n\\in\\mathbb{Z}_{\\ge 0}$）给出的等差数列。仅使用初等数论的核心定义，即整除性的定义、素数的定义以及模 $m$ 同余的基本性质，判断下列哪个陈述正确地解释了为什么该数列只包含素数 $5$ 而不包含其他素数。选择所有适用的选项。\n\nA. 对于任意整数 $n$，都有 $10n+5\\equiv 0\\pmod{5}$，所以 $5$ 整除 $10n+5$。$10n+5$ 能成为素数的唯一情况是 $10n+5=5$，而这恰好在 $n=0$ 时发生。\n\nB. 数列 $10n+5$ 的每一项都是奇数，并且所有大于 $5$ 的奇数都是合数，因此该数列中除了 $5$ 之外没有其他素数。\n\nC. 如果 $a$ 和 $b$ 的最大公约数 (gcd) 满足 $\\gcd(a,b)>1$，那么数列 $an+b$ 的每一项都能被 $\\gcd(a,b)$ 整除。在本题中 $\\gcd(10,5)=5$，所以每一项 $10n+5$ 都能被 $5$ 整除，其唯一可能等于的素数就是 $5$ 本身（在 $n=0$ 时）。\n\nD. 根据关于等差数列的 Dirichlet 定理，因为 $\\gcd(10,5)=5>1$，所以数列 $10n+5$ 包含无穷多个素数。\n\nE. 如果 $n$ 是素数，那么 $10n+5$ 也是素数；如果 $n$ 是合数，那么 $10n+5$ 也是合数。因此，该数列中除了 $5$ 之外没有其他素数。", "solution": "题目要求基于初等数论原理，给出一个正确的解释，说明为什么对于 $n \\in \\mathbb{Z}_{\\ge 0}$ 的等差数列 $10n+5$ 只包含一个素数，即 $5$。\n\n首先，我们将验证题目的陈述。\n**步骤 1：提取已知条件**\n- 等差数列：$a_n = 10n+5$。\n- $n$ 的定义域：$n \\in \\mathbb{Z}_{\\ge 0}$，表示非负整数集合 $\\{0, 1, 2, \\dots\\}$。\n- 允许使用的工具：整除性的定义、素数的定义、模 $m$ 同余的基本性质。\n- 隐含前提：数列 $10n+5$ 只包含素数 $5$。\n\n**步骤 2：使用提取的已知条件进行验证**\n这个问题在数学上是良定义的，并且基于初等数论。关于当 $n \\ge 0$ 时序列 $10n+5$ 只包含一个素数的这个前提是正确的。我们来验证一下。\n该序列的项由 $a_n = 10n+5$ 给出。我们可以提出公因数 $5$：\n$$a_n = 10n+5 = 5(2n+1)$$\n对于任意非负整数 $n$，项 $2n+1$ 也是一个整数。\n- 如果 $n=0$，该项为 $a_0 = 10(0)+5 = 5$。数字 $5$ 是一个素数，因为它唯一的正因数是 $1$ 和 $5$。\n- 如果 $n \\ge 1$，那么 $n$ 是一个正整数。因子 $2n+1$ 是一个满足 $2n+1 \\ge 2(1)+1 = 3$ 的整数。\n因此，对于任意 $n \\ge 1$，项 $a_n = 5(2n+1)$ 是两个都大于 $1$ 的整数 $5$ 和 $2n+1$ 的乘积。根据定义，一个由两个大于 $1$ 的整数相乘得到的数是合数。\n因此，在 $n \\ge 0$ 的序列 $10n+5$ 中，唯一的素数是 $5$，它在 $n=0$ 时出现。\n题目的陈述是科学上合理的、良构的、客观的且自洽的。\n\n**步骤 3：结论和行动**\n题目陈述有效。我们继续分析每个选项。\n\n**逐项分析**\n\n**A. 对于任意整数 $n$，都有 $10n+5\\equiv 0\\pmod{5}$，所以 $5$ 整除 $10n+5$。$10n+5$ 能成为素数的唯一情况是 $10n+5=5$，而这恰好在 $n=0$ 时发生。**\n该陈述提出了一个逻辑论证。我们来验证每一步。\n1.  $10n+5 \\equiv 0 \\pmod{5}$：我们检查同余式。$10n$ 是 $5$ 的倍数，所以 $10n \\equiv 0 \\pmod{5}$。并且 $5 \\equiv 0 \\pmod{5}$。因此，$10n+5 \\equiv 0+0 \\equiv 0 \\pmod{5}$。这是正确的。\n2.  ……所以 $5$ 整除 $10n+5$：根据同余的定义，$a \\equiv 0 \\pmod{m}$ 意味着 $m$ 整除 $a$。所以，$5$ 整除 $10n+5$。这是正确的。\n3.  $10n+5$ 为素数的唯一可能是 $10n+5=5$：设 $p = 10n+5$。我们知道 $p$ 是一个素数且 $5|p$。根据素数的定义，它唯一的正因数是 $1$ 和它本身。由于 $5 > 1$，所以 $5$ 必须等于素数 $p$。因此，我们必须有 $10n+5=5$。这个推理是合理的。\n4.  ……这恰好在 $n=0$ 时发生：解方程 $10n+5=5$ 得到 $10n=0$，这意味着 $n=0$。由于 $n=0$ 是定义域 $\\mathbb{Z}_{\\ge 0}$ 中的一个有效值，该论证成立。\n整个陈述是使用所允许的原理给出的一个正确且完整的解释。\n结论：**正确**。\n\n**B. 数列 $10n+5$ 的每一项都是奇数，并且所有大于 $5$ 的奇数都是合数，因此该数列中除了 $5$ 之外没有其他素数。**\n我们来分析其前提。\n1.  数列 $10n+5$ 的每一项都是奇数：如果一个整数 $k$ 可以写成 $2m+1$ 的形式（其中 $m$ 是某个整数），那么它就是奇数。我们有 $10n+5 = 2(5n+2)+1$。因为对于任意整数 $n$，$5n+2$ 都是整数，所以每一项确实是奇数。这部分是正确的。\n2.  ……所有大于 $5$ 的奇数都是合数：这个陈述是错误的。存在无穷多个大于 $5$ 的奇素数。例如，$7$、$11$、$13$、$17$ 等都是大于 $5$ 的奇素数。\n由于论证中的一个关键前提在事实上是错误的，所以结论不成立，该解释无效。\n结论：**不正确**。\n\n**C. 如果 $a$ 和 $b$ 的最大公约数 (gcd) 满足 $\\gcd(a,b)>1$，那么数列 $an+b$ 的每一项都能被 $\\gcd(a,b)$ 整除。在本题中 $\\gcd(10,5)=5$，所以每一项 $10n+5$ 都能被 $5$ 整除，其唯一可能等于的素数就是 $5$ 本身（在 $n=0$ 时）。**\n这个选项提出了一个普适定理并应用了它。\n1.  普适定理：设 $d = \\gcd(a,b)$。根据定义，$d|a$ 且 $d|b$。由整除性的基本性质可知，如果 $d$ 整除两个整数，它也整除这两个整数的任意整系数线性组合。所以，对于任意整数 $n$，都有 $d|(an+b)$。如果 $d>1$，这意味着该数列的每一项都有一个大于 $1$ 的因子 $d$。这个定理是正确的，并且直接源于最大公约数和整除性的定义。\n2.  应用于本题：这里 $a=10$ 且 $b=5$。我们计算最大公约数：$\\gcd(10,5)=5$。\n3.  对该数列的结论：由于 $\\gcd(10,5)=5>1$，该普适定理适用。每一项 $10n+5$ 都能被 $5$ 整除。\n4.  最终论证：正如在选项 A 的分析中确立的，如果数列中的一项能被 $5$ 整除并且也是素数，那么该项必须是 $5$。令 $10n+5=5$ 得出 $n=0$。这是 $n$ 的一个有效值。\n该推理是正确的，并基于基本的数论概念提供了一个有效的解释。\n结论：**正确**。\n\n**D. 根据关于等差数列的 Dirichlet 定理，因为 $\\gcd(10,5)=5>1$，所以数列 $10n+5$ 包含无穷多个素数。**\n这个选项引用了数论中的一个重要定理。\n关于等差数列的 Dirichlet 定理指出，一个等差数列 $an+b$ 包含无穷多个素数，当且仅当 $a$ 和 $b$ 互质，即 $\\gcd(a,b)=1$。\n在本题中，$a=10$ 且 $b=5$，所以 $\\gcd(10,5)=5$。条件 $\\gcd(a,b)=1$ 未被满足。因此，Dirichlet 定理*不*适用。事实上，正如我们所展示的，如果 $\\gcd(a,b)>1$，该数列最多只能包含一个素数（即 $\\gcd(a,b)$，如果它本身是素数且出现在序列中）。\n该陈述从根本上误解并错误应用了 Dirichlet 定理。应用该定理的前提是错误的，其结论也与事实相反。\n结论：**不正确**。\n\n**E. 如果 $n$ 是素数，那么 $10n+5$ 也是素数；如果 $n$ 是合数，那么 $10n+5$ 也是合数。因此，该数列中除了 $5$ 之外没有其他素数。**\n这个选项提出了索引 $n$ 的素性与项 $10n+5$ 的素性之间的一种关系。\n1.  “如果 $n$ 是素数，那么 $10n+5$ 也是素数”：我们用一个反例来检验。令 $n=2$，这是一个素数。那么该项是 $10(2)+5 = 25$。$25 = 5^2$ 是一个合数，不是素数。因此，这部分陈述是错误的。\n2.  “如果 $n$ 是合数，那么 $10n+5$ 也是合数”：设 $n$ 是一个合数。最小的合数是 $4$。如果 $n \\ge 4$，那么 $2n+1 \\ge 2(4)+1=9$。项 $10n+5 = 5(2n+1)$ 是两个大于 $1$ 的整数的乘积，所以它是合数。这部分陈述是正确的。\n然而，由于陈述的第一部分是错误的，整个解释是无效的。前提存在缺陷，因此即使结论碰巧正确，也无法从所述逻辑中推导出来。\n结论：**不正确**。\n\n总之，选项 A 和 C 都基于整除性和素数的基本性质，提供了正确且逻辑合理的解释。选项 A 使用了同余的语言，而选项 C 则从最大公约数的角度来阐述。两者都是有效的。", "answer": "$$\\boxed{AC}$$", "id": "3088505"}, {"introduction": "狄利克雷定理保证了在形如 $4k+3$ 的等差数列中存在无穷多个素数，但这一定理并未告诉我们如何找到它们。这个练习将理论付诸实践，要求你实现一个算法来实际地搜寻这些素数。通过从第一性原理出发编写一个素性测试函数并将其应用于该数列，你将对这些素数的分布以及如何通过计算来识别它们获得具体的理解。[@problem_id:3088516]", "problem": "给定一个由规则 $t_n = a + n d$ 定义的等差数列，其中 $n \\in \\{0,1,2,\\dots\\}$，固定参数为 $a=3$ 和 $d=4$。该数列枚举了所有形式为 $4k+3$ 的整数。素数是一个大于等于 $2$ 的整数 $p$，其正因数只有 $1$ 和它本身。你的任务是根据基本原理实现一个素性测试，并将其应用于该数列的初始段。具体来说，对于给定的截止值 $N$，检查前 $N$ 项 $\\{t_0, t_1, \\dots, t_{N-1}\\}$，并返回一个子列表，其中仅包含那些为素数的项。程序必须是自包含的，且不得读取任何输入。所使用的算术、数论和算法概念应从整除性、素数和等差数列结构等基本定义出发进行论证。\n\n测试套件：\n- 情况 $1$：$N=0$（没有项的边界情况）。\n- 情况 $2$：$N=1$（单项 $t_0=3$）。\n- 情况 $3$：$N=5$（一个同时包含素数项和合数项的小集合）。\n- 情况 $4$：$N=200$（前 $200$ 项，代表了对数列 $4k+3$ 的一次全面运行）。\n\n对于每个测试用例 $N$，要求的答案是该数列前 $N$ 项中的素数项列表。聚合输出必须是单行，其中包含四个测试用例的结果，按顺序排列，形式为一个用方括号括起来的逗号分隔列表。该外部列表中的每个元素本身必须是一个用方括号括起来的、逗号分隔的整数列表，表示为该测试用例找到的素数。因此，最终输出的形式为 $[L_0,L_1,L_2,L_3]$，其中 $L_i$ 是情况 $i$ 的素数列表。你的程序应生成单行输出，其中包含用方括号括起来的、逗号分隔的结果列表（例如，$[result_1,result_2,result_3,result_4]$）。", "solution": "该问题是有效的，因为它具有数论的科学依据，是良定的，且其所有组成部分都有形式化且明确的定义。我们将从基本原理出发进行求解。\n\n任务是识别特定等差数列初始段内的素数。这需要两个主要部分：一个生成数列项的方法和一个测试每项素性的方法。\n\n首先，我们来处理等差数列。等差数列是一个数字序列，其中任意两个连续项之间的差是恒定的。这个恒定的差称为公差，用 $d$ 表示。序列中的项 $t_n$ 由公式 $t_n = a + n d$ 定义，其中 $a$ 是第一项（对应于 $n=0$），$n$ 是一个非负整数，$n \\in \\{0, 1, 2, \\dots\\}$。问题指定了参数 $a=3$ 和 $d=4$。因此，所考虑的序列由下式给出：\n$$t_n = 3 + 4n$$\n这是一个无穷整数序列：$3, 7, 11, 15, 19, \\dots$。对于每个测试用例，我们给定一个截止值 $N$，我们的分析仅限于前 $N$ 项：$\\{t_0, t_1, \\dots, t_{N-1}\\}$。\n\n其次，我们必须建立一个严格的素性测试程序。素数被形式化定义为一个大于等于 $2$ 的整数 $p$，其唯一的正因数是 $1$ 和 $p$。大于 $1$ 而不是素数的整数称为合数。要确定给定项 $t_n$ 是否为素数，我们必须验证它是否满足此定义。\n\n最基本的素性测试方法是试除法，它直接源于定义。要测试一个整数 $m > 1$ 是否为素数，我们可以检查它是否能被 $2 \\le k  m$ 范围内的每个整数 $k$ 整除。如果任何这样的 $k$ 能整除 $m$（即 $m/k$ 的余数为 $0$），那么 $m$ 就有除 $1$ 和自身之外的因数，因此是合数。如果检查了整个范围都没有找到因数，那么 $m$ 必定是素数。\n\n这种朴素的试除法算法可以被显著优化。一个关键的数学见解是，如果一个整数 $m$ 是合数，它可以写成两个因子的乘积 $m = k_1 \\cdot k_2$。如果这两个因子都大于 $\\sqrt{m}$，它们的乘积 $k_1 \\cdot k_2$ 将会大于 $\\sqrt{m} \\cdot \\sqrt{m} = m$，这是一个矛盾。因此，如果 $m$ 是合数，它的至少一个因数必须小于或等于 $\\sqrt{m}$。这个原理使我们能够缩小潜在因数的搜索空间。我们只需要对 $2 \\le k \\le \\lfloor\\sqrt{m}\\rfloor$ 范围内的整数 $k$ 进行试除，其中 $\\lfloor \\cdot \\rfloor$ 表示向下取整函数。\n\n还可以进行进一步的优化。任何大于 $2$ 的偶数都是合数，因为它能被 $2$ 整除。我们序列中的项 $t_n = 4n+3$ 都是奇数。一个奇数不可能有任何偶数因数。因此，我们只需要测试奇数因数。数字 $2$ 可以作为特殊情况处理；它是素数。对于任何大于 $2$ 的整数 $m$，我们可以首先检查它是否为偶数。如果是，它就是合数。如果不是，我们只需要测试直到 $\\lfloor\\sqrt{m}\\rfloor$ 的奇数因数 $k \\in \\{3, 5, 7, \\dots\\}$。\n\n结合这些原理，我们为函数 `is_prime(m)` 制定了以下算法：\n1. 如果 $m \\le 1$，它不是素数。返回 false。\n2. 如果 $m = 2$，它是素数。返回 true。\n3. 如果 $m > 2$ 且 $m$ 能被 $2$ 整除，它是合数。返回 false。\n4. 对于从 $3$ 开始到 $\\lfloor\\sqrt{m}\\rfloor$（含）的所有奇数 $k$：\n   a. 如果 $m$ 能被 $k$ 整除，则 $m$ 是合数。返回 false。\n5. 如果循环完成而没有找到任何因数，则 $m$ 是素数。返回 true。\n\n这个稳健的算法将用于测试数列中的每一项。\n\n解决给定截止值 $N$ 的问题的总体步骤如下：\n1. 初始化一个空列表 `prime_terms` 来存储结果。\n2. 如果 $N = 0$，项的集合是空的，所以我们返回空列表。\n3. 如果 $N > 0$，用索引 $n$ 从 $0$ 迭代到 $N-1$。\n4. 在每次迭代中，计算项 $t_n = 3 + 4n$。\n5. 对 $t_n$ 应用 `is_prime` 函数。\n6. 如果 `is_prime(t_n)` 返回 true，则将 $t_n$ 附加到 `prime_terms` 列表中。\n7. 循环完成后，`prime_terms` 包含序列前 $N$ 项中的所有素数。\n\n这个过程将对测试套件中指定的每个 $N$ 值执行：$N=0$、$N=1$、$N=5$ 和 $N=200$。最终输出将是为每种情况生成的列表的聚合，并按指定格式化。例如，对于 $N=5$，项为 $t_0=3$、$t_1=7$、$t_2=11$、$t_3=15$ 和 $t_4=19$。应用素性测试：\n- $3$：素数。\n- $7$：素数。\n- $11$：素数。\n- $15 = 3 \\times 5$：合数。\n- $19$：素数。\n对于 $N=5$ 的结果列表是 $[3, 7, 11, 19]$。对所有测试用例重复此过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef is_prime(m):\n    \"\"\"\n    Tests if an integer m is prime using an optimized trial division method.\n\n    This function is implemented from first principles as required.\n    1. A number less than 2 is not prime.\n    2. The number 2 is the only even prime.\n    3. Any other even number is composite.\n    4. For an odd number m, we only need to check for odd divisors k\n       up to sqrt(m). If a divisor > sqrt(m) exists, a corresponding\n       divisor = sqrt(m) must also exist.\n    \"\"\"\n    if m  2:\n        return False\n    if m == 2:\n        return True\n    if m % 2 == 0:\n        return False\n    \n    # Check for odd divisors from 3 up to the square root of m.\n    limit = int(np.sqrt(m))\n    for i in range(3, limit + 1, 2):\n        if m % i == 0:\n            return False\n            \n    return True\n\ndef find_primes_in_progression(N, a, d):\n    \"\"\"\n    Generates the first N terms of an arithmetic progression and returns the\n    subset of terms that are prime.\n\n    Args:\n        N (int): The number of terms to examine, from t_0 to t_{N-1}.\n        a (int): The first term of the progression (t_0).\n        d (int): The common difference of the progression.\n\n    Returns:\n        list: A list of prime numbers found among the first N terms.\n    \"\"\"\n    prime_terms = []\n    if N == 0:\n        return []\n        \n    for n in range(N):\n        term = a + n * d\n        if is_prime(term):\n            prime_terms.append(term)\n            \n    return prime_terms\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the final result.\n    \"\"\"\n    # Define the fixed parameters for the arithmetic progression t_n = a + nd.\n    a = 3\n    d = 4\n\n    # Define the test cases from the problem statement.\n    test_cases = [0, 1, 5, 200]\n\n    results = []\n    for N in test_cases:\n        # Find the list of prime terms for the current test case.\n        result_list = find_primes_in_progression(N, a, d)\n        results.append(result_list)\n\n    # Format the final output according to the problem specification.\n    # The output must be a single line string, e.g., [[3],[7,11],[13]].\n    # Python's default string representation of a list is \"[...]\", which\n    # matches the required format for the inner lists.\n    # We join these string representations with a comma and enclose them in\n    # the outer brackets.\n    output_str = f\"[{','.join(map(str, results))}]\"\n    print(output_str)\n\nsolve()\n```", "id": "3088516"}, {"introduction": "数论中的各个概念常常是紧密相连的。这个问题完美地展示了这种关联性，它要求你先用中国剩余定理解一个同余方程组，而该方程组的通解恰好构成一个等差数列。你的最终任务是在这个派生出的数列中，运用你寻找素数的技巧来定位其最小的素数成员，从而将两个重要的数论工具联系在一起。[@problem_id:3088517]", "problem": "设整数 $x$ 满足同余方程组 $x \\equiv 3 \\pmod{4}$，$x \\equiv 1 \\pmod{5}$ 和 $x \\equiv 2 \\pmod{7}$。请从同余的定义（即 $a \\equiv b \\pmod{m}$ 意味着 $m \\mid a-b$）以及中国剩余定理（CRT）的陈述（即对于两两互质的模数，在模它们乘积的意义下存在唯一解）出发，推导出所有满足条件的 $x$ 在模 $140$ 下的唯一剩余类，并计算出最小非负解。然后，将此剩余类解释为一个等差数列，并确定该数列中的最小素数项，通过仅检验小于等于其平方根的素数来证明其素性。请给出该数列中的最小素数作为你的最终答案，表示为一个精确整数，无需四舍五入。", "solution": "用户提供了一个问题，要求解一个线性同余方程组，然后找出结果等差数列中的最小素数。\n\n**问题验证**\n\n**步骤 1：提取已知条件**\n- $x$ 是一个整数。\n- $x \\equiv 3 \\pmod{4}$\n- $x \\equiv 1 \\pmod{5}$\n- $x \\equiv 2 \\pmod{7}$\n- 同余的定义：$a \\equiv b \\pmod{m}$ 意味着 $m \\mid a-b$。\n- 中国剩余定理（CRT）陈述：对于两两互质的模数，在模它们乘积的意义下存在唯一解。\n- 任务 1：推导 $x$ 模 $140$ 的唯一剩余类。\n- 任务 2：计算 $x$ 的最小非负解。\n- 任务 3：将解解释为一个等差数列。\n- 任务 4：找出该数列中的最小素数项。\n- 任务 5：通过检验小于等于其平方根的素数来证明该项的素性。\n\n**步骤 2：使用提取的已知条件进行验证**\n- **科学依据：** 该问题是初等数论中的一个标准练习，基于公认的中国剩余定理和素数的定义。\n- **良态问题：** 模数 $4$、$5$ 和 $7$ 两两互质（$gcd(4,5)=1$，$gcd(4,7)=1$，$gcd(5,7)=1$）。中国剩余定理保证了在模 $4 \\times 5 \\times 7 = 140$ 的意义下存在唯一解。任务具体明确，会得出一个可验证的唯一答案。\n- **客观性：** 问题使用精确的数学语言陈述，没有歧义或主观论断。\n\n该问题没有表现出验证标准中列出的任何缺陷。它是科学合理的、良态的、客观的和完整的。\n\n**步骤 3：结论与行动**\n该问题是**有效的**。将提供解答。\n\n**解题推导**\n\n我们已知以下线性同余方程组：\n$$x \\equiv 3 \\pmod{4}$$\n$$x \\equiv 1 \\pmod{5}$$\n$$x \\equiv 2 \\pmod{7}$$\n\n根据第一个同余式 $x \\equiv 3 \\pmod{4}$，我们可以将 $x$ 表示为 $x = 4k_1 + 3$，其中 $k_1$ 为某个整数。\n\n我们将这个表达式代入第二个同余式 $x \\equiv 1 \\pmod{5}$：\n$$4k_1 + 3 \\equiv 1 \\pmod{5}$$\n两边同时减去 $3$ 得：\n$$4k_1 \\equiv -2 \\pmod{5}$$\n因为 $-2 \\equiv 3 \\pmod{5}$，该同余式变为：\n$$4k_1 \\equiv 3 \\pmod{5}$$\n为了解出 $k_1$，我们需要求 $4$ 模 $5$ 的乘法逆元。我们可以通过检验找到它：$4 \\times 1 \\equiv 4 \\pmod{5}$，$4 \\times 2 \\equiv 8 \\equiv 3 \\pmod{5}$，$4 \\times 3 \\equiv 12 \\equiv 2 \\pmod{5}$，$4 \\times 4 \\equiv 16 \\equiv 1 \\pmod{5}$。$4$ 模 $5$ 的逆元是 $4$。将同余式两边同时乘以 $4$：\n$$4(4k_1) \\equiv 4(3) \\pmod{5}$$\n$$16k_1 \\equiv 12 \\pmod{5}$$\n$$k_1 \\equiv 2 \\pmod{5}$$\n这意味着 $k_1$ 必须具有 $k_1 = 5k_2 + 2$ 的形式，其中 $k_2$ 为某个整数。\n\n现在，我们将 $k_1$ 的这个表达式代回我们的 $x$ 方程中：\n$$x = 4(5k_2 + 2) + 3$$\n$$x = 20k_2 + 8 + 3$$\n$$x = 20k_2 + 11$$\n这个关系式 $x \\equiv 11 \\pmod{20}$ 整合了前两个同余式。\n\n接下来，我们使用第三个同余式 $x \\equiv 2 \\pmod{7}$。代入我们新的 $x$ 表达式：\n$$20k_2 + 11 \\equiv 2 \\pmod{7}$$\n我们将系数对模 $7$ 进行化简。因为 $20 = (2 \\times 7) + 6$，所以有 $20 \\equiv 6 \\pmod{7}$，或者更方便地 $20 \\equiv -1 \\pmod{7}$。因为 $11 = (1 \\times 7) + 4$，所以有 $11 \\equiv 4 \\pmod{7}$。该同余式变为：\n$$-k_2 + 4 \\equiv 2 \\pmod{7}$$\n两边同时减去 $4$：\n$$-k_2 \\equiv -2 \\pmod{7}$$\n乘以 $-1$：\n$$k_2 \\equiv 2 \\pmod{7}$$\n这意味着 $k_2$ 可以写成 $k_2 = 7k_3 + 2$ 的形式，其中 $k_3$ 为某个整数。\n\n最后，我们将其代回表达式 $x = 20k_2 + 11$ 中：\n$$x = 20(7k_3 + 2) + 11$$\n$$x = 140k_3 + 40 + 11$$\n$$x = 140k_3 + 51$$\n这是满足该方程组的所有整数 $x$ 的通解形式。因此，模 $140$ 的唯一剩余类是 $x \\equiv 51 \\pmod{140}$。\n\n令 $k_3 = 0$ 可求得最小非负解，即 $x = 51$。\n\n非负解的集合构成一个等差数列：$a_n = 51 + 140n$，其中 $n = 0, 1, 2, \\dots$。我们需要找出这个数列中的最小素数项。\n\n我们来测试前几项：\n当 $n=0$ 时：$a_0 = 51 + 140(0) = 51$。为检验其素性，我们看到各位数字之和为 $5+1=6$，可以被 $3$ 整除。确实，$51 = 3 \\times 17$。所以，$51$ 不是素数。\n\n当 $n=1$ 时：$a_1 = 51 + 140(1) = 191$。为检验 $191$ 是否为素数，我们必须测试它是否能被小于等于 $\\sqrt{191}$ 的素数整除。我们知道 $13^2 = 169$ 且 $14^2 = 196$，所以 $\\sqrt{191}$ 在 $13$ 和 $14$ 之间。我们只需要测试小于等于 $13$ 的素数：$2, 3, 5, 7, 11, 13$。\n- 被 $2$ 整除性：$191$ 是奇数，所以不能被 $2$ 整除。\n- 被 $3$ 整除性：各位数字之和为 $1+9+1=11$，不能被 $3$ 整除。所以 $191$ 不能被 $3$ 整除。\n- 被 $5$ 整除性：末位数字是 $1$，不是 $0$ 或 $5$。所以 $191$ 不能被 $5$ 整除。\n- 被 $7$ 整除性：$191 = 7 \\times 27 + 2$。余数为 $2$，所以不能被 $7$ 整除。\n- 被 $11$ 整除性：$191 = 11 \\times 17 + 4$。余数为 $4$，所以不能被 $11$ 整除。\n- 被 $13$ 整除性：$191 = 13 \\times 14 + 9$。余数为 $9$，所以不能被 $13$ 整除。\n\n由于 $191$ 不能被任何小于或等于其平方根的素数整除，所以 $191$ 是一个素数。因为这是在该数列中找到的第一个素数（在检查了 $n=0$ 时的非素数项后，于 $n=1$ 时找到），所以它是该等差数列中的最小素数项。", "answer": "$$\\boxed{191}$$", "id": "3088517"}]}