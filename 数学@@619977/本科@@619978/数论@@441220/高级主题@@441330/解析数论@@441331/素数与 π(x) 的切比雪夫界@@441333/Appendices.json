{"hands_on_practices": [{"introduction": "理论的伟大之处在于其普适性，但理论的直观感受往往始于具体的数字。在深入研究切比雪夫界限的精妙证明之前，通过直接计算来感受素数计数函数 $\\pi(x)$ 与其近似值 $x/\\ln x$ 之间的关系，是建立直观理解的绝佳方式。这个练习将引导你通过对小数值 $x$ 的计算，亲手验证这两者在数量级上的可比性，为后续更复杂的分析奠定基础 [@problem_id:3083101]。", "problem": "设 $\\pi(x)$ 表示小于或等于 $x$ 的素数个数的素数计数函数，设 $\\lfloor \\,\\cdot\\, \\rfloor$ 表示向下取整函数，设 $\\ln$ 表示自然对数。考虑由切比雪夫型界所建议的 $\\pi(x)$ 与 $x/\\ln x$ 之间的定量比较。\n\n对于 $x \\in \\{10、100、1000\\}$，计算整数差\n$$\\Delta(x) \\coloneqq \\pi(x) - \\left\\lfloor \\frac{x}{\\ln x} \\right\\rfloor$$\n，其中使用可通过直接计数得到的 $\\pi(10)$、$\\pi(100)$ 和 $\\pi(1000)$ 的标准值。将你的最终答案以行矩阵 $\\bigl[\\Delta(10)\\ \\Delta(100)\\ \\Delta(1000)\\bigr]$ 的形式给出。\n\n然后，从 $\\pi(x)$、$\\lfloor \\,\\cdot\\, \\rfloor$ 和自然对数的定义出发，并仅使用切比雪夫界的定性内容（即对于足够大的 $x$，$\\pi(x)$ 被夹在 $x/\\ln x$ 的常数倍之间），讨论你的计算所显示的数值趋势。最终答案是整数，因此不需要四舍五入说明。", "solution": "我们回顾定义：$\\pi(x)$ 计数直到 $x$ 的素数，$\\lfloor y \\rfloor$ 是小于或等于 $y$ 的最大整数，$\\ln$ 是自然对数。切比雪夫界断言，存在绝对常数 $A$ 和 $B$ 以及一个阈值 $x_{0}$，使得对于所有 $x \\ge x_{0}$，都有\n$$A \\frac{x}{\\ln x} \\le \\pi(x) \\le B \\frac{x}{\\ln x}.$$\n这将 $\\pi(x)$ 置于与 $x/\\ln x$ 相同的尺度上，从而促使对特定的 $x$ 进行数值比较。\n\n第1步：通过直接对素数计数来计算 $\\pi(10)$、$\\pi(100)$ 和 $\\pi(1000)$。这些是标准值：\n- 不超过 $10$ 的素数是 $2,3,5,7$，因此 $\\pi(10)=4$。\n- 这是一个经典的计算（通过枚举或筛法），$\\pi(100)=25$。\n- 类似地，可以求得 $\\pi(1000)=168$。\n\n第2步：计算 $x \\in \\{10、100、1000\\}$ 时 $\\left\\lfloor \\dfrac{x}{\\ln x} \\right\\rfloor$ 的值。我们使用 $\\ln(100)=2\\ln(10)$ 和 $\\ln(1000)=3\\ln(10)$，以及一个足够精确的 $\\ln(10)$ 的计算值，来明确地确定向下取整的值。\n- 对于 $x=10$：$\\ln(10) \\approx 2.302585093$，因此\n$$\\frac{10}{\\ln(10)} \\approx \\frac{10}{2.302585093} \\approx 4.342944819,$$\n所以 $\\left\\lfloor \\dfrac{10}{\\ln(10)} \\right\\rfloor = 4$。\n- 对于 $x=100$：$\\ln(100)=2\\ln(10) \\approx 4.605170186$，因此\n$$\\frac{100}{\\ln(100)} \\approx \\frac{100}{4.605170186} \\approx 21.71472410,$$\n所以 $\\left\\lfloor \\dfrac{100}{\\ln(100)} \\right\\rfloor = 21$。\n- 对于 $x=1000$：$\\ln(1000)=3\\ln(10) \\approx 6.907755279$，因此\n$$\\frac{1000}{\\ln(1000)} \\approx \\frac{1000}{6.907755279} \\approx 144.7648273,$$\n所以 $\\left\\lfloor \\dfrac{1000}{\\ln(1000)} \\right\\rfloor = 144$。\n\n第3步：计算差值 $\\Delta(x)=\\pi(x)-\\left\\lfloor \\dfrac{x}{\\ln x} \\right\\rfloor$。\n- 对于 $x=10$：$\\Delta(10)=\\pi(10)-\\left\\lfloor \\dfrac{10}{\\ln(10)} \\right\\rfloor = 4-4=0$。\n- 对于 $x=100$：$\\Delta(100)=\\pi(100)-\\left\\lfloor \\dfrac{100}{\\ln(100)} \\right\\rfloor = 25-21=4$。\n- 对于 $x=1000$：$\\Delta(1000)=\\pi(1000)-\\left\\lfloor \\dfrac{1000}{\\ln(1000)} \\right\\rfloor = 168-144=24$。\n\n因此所求的行矩阵是 $\\bigl[0\\ 4\\ 24\\bigr]$。\n\n趋势讨论：这些值表明，对于中等大小的 $x$，$\\pi(x)$ 和 $x/\\ln x$ 已经在同一尺度上，这与切比雪夫界一致。在这些情况下，差值 $\\Delta(x)$ 是非负的，并且随着 $x$ 从 $10$ 增加到 $1000$ 而增长。由于向下取整函数最多减去 $1$，$\\Delta(x)$ 的符号和大小主要反映了 $\\pi(x)-(x/\\ln x)$ 的符号和大小。切比雪夫界没有规定 $\\pi(x)-(x/\\ln x)$ 的确切符号，但它们确实表明这两个量都以 $x/\\ln x$ 的量级增长。因此，观察到的 $\\Delta(x)$ 的增长与以下定性陈述相容：$\\pi(x)$ 和 $x/\\ln x$ 保持可比性，并且它们的绝对差可以随 $x$ 增加，同时相对于 $x/\\ln x$ 保持较小。", "answer": "$$\\boxed{\\begin{pmatrix}0  4  24\\end{pmatrix}}$$", "id": "3083101"}, {"introduction": "切比雪夫的理论证明了存在一个常数，可以为素数计数函数 $\\pi(x)$ 提供一个上界。然而，理论上的存在性与实际的最佳值之间有何关系？这个练习将让你扮演一名计算数学家的角色，通过编程来系统性地寻找在给定的大范围（例如直到一百万）内，能使不等式 $\\pi(x) \\le B \\frac{x}{\\log x}$ 成立的最小经验常数 $B(N)$ [@problem_id:3083099]。这个过程不仅能加深你对界限概念的理解，还能让你体会到理论与计算实践之间的互动。", "problem": "您的任务是使用 Chebyshev 型界来构建和分析素数计数函数的一个经验上界。设素数计数函数 $\\,\\pi(x)\\,$ 定义为小于或等于 $\\,x\\,$ 的素数个数，并设 $\\,\\log x\\,$ 表示自然对数（以 $\\,e\\,$ 为底）。Chebyshev 利用基于阶乘和二项式系数性质的论证证明了，对于足够大的 $\\,x\\,$，$\\,\\pi(x)\\,$ 的上下界均为 $\\,x/\\log x\\,$ 的常数倍。在这个问题中，您将针对有限范围计算一个最小经验常数，该常数对于直到给定界限的所有整数都成立。\n\n对于给定的整数 $\\,N \\ge 2\\,$，定义经验最小常数\n$$\nB(N) \\;=\\; \\max_{\\,2 \\le x \\le N}\\; \\frac{\\pi(x)\\,\\log x}{x}.\n$$\n注意到，$\\,B(N)\\,$ 是使得不等式\n$$\n\\pi(x) \\;\\le\\; B(N)\\,\\frac{x}{\\log x}\n$$\n对于所有满足 $\\,2 \\le x \\le N\\,$ 的整数 $\\,x\\,$ 均成立的最小常数。您的任务是实现一个程序，该程序：\n\n- 使用一种基于基本数论定义的正确且高效的方法，计算在 $[2,N]$ 区间内所有整数 $\\,x\\,$ 的 $\\,\\pi(x)\\,$ 值。\n- 计算 $\\,B(N)\\,$，即 $\\,\\pi(x)\\log x/x\\,$ 在 $\\,x = 2,3,\\dots,N\\,$ 上的最大值。\n- 为一组 $\\,N\\,$ 值的测试套件生成结果。\n\n使用以下科学依据和约束条件：\n\n- 基本定义：$\\,\\pi(x)\\,$ 计算小于或等于 $\\,x\\,$ 的素数个数，素性由可除性确定，$\\,\\log x\\,$ 是自然对数。\n- 经过充分检验的事实：Eratosthenes 筛法可以正确地找出直到界限 $\\,N\\,$ 的所有素数，其运行时间为 $\\,O(N\\log\\log N)\\,$。\n- 角度单位和物理单位不适用；确保 $\\,\\log\\,$ 是自然对数。\n- 不等式的定义域为整数 $\\,x\\,$ 且 $\\,2 \\le x \\le N\\,$，以避免在 $\\,\\log 1 = 0\\,$ 处的奇异点。\n\n针对以下界限的测试套件实现计算：\n- $N \\in \\{10、100、1000、10000、100000、1000000\\}$。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，每个条目是 $\\,B(N)\\,$，按测试套件的顺序排列，并四舍五入到恰好六位小数。例如，输出格式必须为\n$$\n[\\,B(10),B(100),B(1000),B(10000),B(100000),B(1000000)\\,]\n$$\n其中每个 $\\,B(N)\\,$ 都打印为六位小数，并且没有额外的字符或空格。", "solution": "此问题在数学上是良定义的，科学上基于已建立的数论，并且包含得出唯一解所需的所有必要信息。任务是为几个不同的 $N$ 值计算经验最小常数 $B(N)$，其中 $B(N)$ 定义为\n$$\nB(N) \\;=\\; \\max_{\\,2 \\le x \\le N}\\; \\frac{\\pi(x)\\,\\log x}{x}.\n$$\n此处，$\\pi(x)$ 是素数计数函数，$\\log x$ 是自然对数。对于在 $[2, N]$ 范围内的所有整数 $x$，常数 $B(N)$ 提供了 $\\pi(x) \\le C \\cdot \\frac{x}{\\log x}$ 形式的最紧上界。\n\n该解法以算法方式进行，利用计算数论的原理来提高效率。测试用例为 $N \\in \\{10, 100, 1000, 10000, 100000, 1000000\\}$。由于这些 $N$ 值是嵌套的，我们可以通过仅对最大值 $N_{\\max} = 1000000$ 执行一次计算最密集的部分来优化整个计算过程。\n\n**步骤 1：生成素数**\n计算 $\\pi(x)$ 的基础是拥有一种能够高效识别所有小于等于 $N_{\\max}$ 的素数的方法。Eratosthenes 筛法是完成此项任务的指定且最适合的算法。\n我们初始化一个大小为 $N_{\\max} + 1$ 的布尔数组 `is_prime`，将从索引 2 开始的所有条目设为 true，表示所有这些数最初都被认为是潜在的素数。索引为 0 和 1 的条目则被标记为 false。\n然后我们从 2 开始遍历直到 $\\sqrt{N_{\\max}}$ 的数 $p$。如果一个数 $p$ 仍然被标记为素数，我们就遍历它的倍数（$p^2, p^2+p, p^2+2p, \\dots$）并将它们标记为非素数。这个过程可以正确地排除所有合数。此步骤的时间复杂度为 $O(N_{\\max}\\log\\log N_{\\max})$。\n\n**步骤 2：计算素数计数函数 $\\pi(x)$**\n素数计数函数 $\\pi(x)$ 是小于或等于 $x$ 的素数个数。它可以正式定义为：\n$$\n\\pi(x) = \\sum_{p \\le x, p \\text{ is prime}} 1\n$$\n有了步骤 1 中的 `is_prime` 布尔数组，我们就可以高效地计算出在 $[0, N_{\\max}]$ 区间内所有 $x$ 的 $\\pi(x)$ 值。我们构建一个整数数组 `pi_values`，其中 `pi_values[x]` 将存储 $\\pi(x)$。这通过计算 `is_prime` 数组的累加和来实现。也就是说，对于 $x > 0$，\n$$\n\\text{pi\\_values}[x] = \\text{pi\\_values}[x-1] + (\\text{1 if } x \\text{ is prime, 0 otherwise}).\n$$\n这通过一次遍历就提供了所有必需的 $\\pi(x)$ 值，时间复杂度为线性的 $O(N_{\\max})$。\n\n**步骤 3：计算界定常数 $B(N)$**\n有了 `pi_values` 数组，我们现在可以为指定域 $[2, N_{\\max}]$ 中的每个整数 $x$ 计算函数 $f(x) = \\frac{\\pi(x)\\log x}{x}$。我们将这个值序列表示为 $f_x$。\n常数 $B(N)$ 是该函数在区间 $[2, N]$ 上的最大值。\n$$\nB(N) = \\max\\{f_2, f_3, \\dots, f_N\\}\n$$\n为了高效地找到测试套件中每个 $N$ 对应的 $B(N)$，我们首先计算 $x \\in [2, N_{\\max}]$ 的函数值 $f_x$ 数组。然后，我们可以计算该数组的运行最大值。设 $B_x = \\max\\{f_2, f_3, \\dots, f_x\\}$。序列 $B_x$ 可以迭代计算：$B_2 = f_2$，对于 $x > 2$，$B_x = \\max(B_{x-1}, f_x)$。\n对于测试套件中给定的每个 $N$，所需的值 $B(N)$ 就是我们运行最大值序列中预先计算好的条目 $B_N$。\n\n**步骤 4：实现与最终结果格式化**\n所述算法使用 Python 实现，并利用 `numpy` 库进行高效的数组操作。筛法、计算 $\\pi(x)$ 的累加和、计算 $f(x)$ 以及运行最大值都是向量化操作。最终，对测试套件 $\\{10, 100, 1000, 10000, 100000, 1000000\\}$ 中的每个 $N$ 计算出的 $B(N)$ 值被收集起来，并按照规定格式化为单个字符串，每个值都四舍五入到六位小数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the empirical minimal constant B(N) for a suite of N values.\n    B(N) is the maximum of pi(x)*log(x)/x for integers x in [2, N].\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [10, 100, 1000, 10000, 100000, 1000000]\n    \n    # Set the maximum limit for primate generation from the largest test case.\n    N_max = test_cases[-1]\n\n    # Step 1: Generate primes up to N_max using the Sieve of Eratosthenes.\n    # is_prime[i] will be True if i is prime, False otherwise.\n    is_prime = np.ones(N_max + 1, dtype=bool)\n    is_prime[0:2] = False  # 0 and 1 are not prime.\n    for p in range(2, int(np.sqrt(N_max)) + 1):\n        if is_prime[p]:\n            # Mark all multiples of p as not prime. Start from p*p.\n            is_prime[p*p::p] = False\n\n    # Step 2: Compute the prime-counting function pi(x) for all x = N_max.\n    # pi_values[x] = pi(x). This is the cumulative sum of the is_prime array.\n    pi_values = np.cumsum(is_prime)\n\n    # Step 3: Compute the function f(x) = pi(x) * log(x) / x for x in [2, N_max].\n    # We create a range for x starting from 2.\n    x_range = np.arange(2, N_max + 1, dtype=np.float64)\n    # Get the corresponding pi(x) values from our precomputed array.\n    pi_of_x = pi_values[2:]\n    # Compute the natural logarithm of x.\n    log_x = np.log(x_range)\n    # Calculate f(x) values.\n    f_values = pi_of_x * log_x / x_range\n\n    # Step 4: Compute the running maximum of f(x). The value at index i will be\n    # the maximum of f(x) for x from 2 up to i+2. This corresponds to B(i+2).\n    running_max_f = np.maximum.accumulate(f_values)\n    \n    # Step 5: Extract the B(N) values for each N in the test suite.\n    results = []\n    for n_val in test_cases:\n        # The index for a given N in the running_max_f array is N-2,\n        # because the array starts its indexing from x=2.\n        b_n = running_max_f[n_val - 2]\n        results.append(b_n)\n\n    # Final print statement in the exact required format.\n    # Each result is rounded to six decimal places.\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\nsolve()\n\n```", "id": "3083099"}, {"introduction": "素数的研究充满了不同函数之间的深刻联系，其中素数计数函数 $\\pi(x)$ 与第一切比雪夫函数 $\\theta(x)$ 之间的关系尤为重要。一个通过分部求和（或阿贝尔求和）得到的积分恒等式将这两者精确地联系起来。这个高级练习挑战你运用数值分析的技巧，通过对一个积分进行数值估计来近似计算 $\\theta(x)$ 的值，从而在实践中验证这一深刻的理论联系 [@problem_id:3083112]。这不仅是对你编程和数值计算能力的考验，更是对你综合运用不同数学工具解决数论问题的能力的提升。", "problem": "给定素数计数函数 $\\pi(x)$ 和第一类 Chebyshev 函数 $\\theta(x)$，其定义为 $\\pi(x) = \\#\\{p \\text{ prime} : p \\le x\\}$ 和 $\\theta(x) = \\sum_{p \\le x} \\log p$。通过分部求和（也称为 Abel 求和）和黎曼-斯蒂尔杰斯积分，可以得到一个连接这两个函数的基本恒等式，这是一个精确的关系式\n$$\n\\theta(x) = \\pi(x)\\log x - \\int_{2}^{x} \\frac{\\pi(t)}{t}\\,dt.\n$$\n设计一种数值方法，仅使用区间 $[2,x]$ 的一个划分上的 $\\pi(t)$ 值来估计 $\\theta(x)$。该方法必须从第一性原理推导得出，并且必须基于单调性给出积分的严格下界和上界，以及一个点估计和一个可计算的误差界。具体来说，设 $2 = t_{0}  t_{1}  \\cdots  t_{m} = x$ 是 $[2,x]$ 的一个划分。利用 $\\pi(t)$ 是非递减函数以及被积函数 $\\pi(t)/t$ 在素数跳跃点之外是分段常数的事实来证明以下界：\n$$\n\\sum_{k=0}^{m-1} \\pi(t_{k}) \\log\\!\\left(\\frac{t_{k+1}}{t_{k}}\\right) \\le \\int_{2}^{x} \\frac{\\pi(t)}{t}\\,dt \\le \\sum_{k=0}^{m-1} \\pi(t_{k+1}) \\log\\!\\left(\\frac{t_{k+1}}{t_{k}}\\right).\n$$\n由此推导出 $\\theta(x)$ 相应的下界和上界，并定义一个中点估计量 $\\widehat{\\theta}(x)$ 以及一个显式的误差界。解释为什么当划分由所有整数 $2,3,\\dots,x$ 组成时，该方法能得出 $\\theta(x)$ 的精确值。\n\n你的程序必须实现这个估计量，并在以下测试集上对其进行评估。在所有情况下，将 $\\log$ 视作自然对数，所有量均为没有物理单位的纯数。\n\n- 测试用例 1（顺利路径，细划分）：$x = 200$，划分为 $t_{k} = k$ 对于 $k \\in \\{2,3,\\dots,200\\}$。\n- 测试用例 2（粗略几何划分）：$x = 1000$，几何划分由 $t_{0} = 2$ 和 $t_{k+1} = \\min(x, \\max(t_{k}+1, \\lfloor r\\, t_{k} \\rfloor))$ 定义，比率 $r = 1.5$，直到 $t_{m} = x$。\n- 测试用例 3（边界情况）：$x = 2$，平凡划分为 $t_{0} = 2$, $t_{1} = 2$。\n\n对每个测试用例，计算：\n- 根据划分和 $\\pi(t)$ 值得到的中点估计 $\\widehat{\\theta}(x)$，\n- 通过枚举 $\\le x$ 的素数并对 $\\log p$ 求和得到的精确 $\\theta(x)$，\n- 绝对误差 $|\\widehat{\\theta}(x) - \\theta(x)|$。\n\n此外，为了与 Chebyshev 型的界联系起来，对于 $x = 1000$ 和 $x = 100$，计算不等式 $0.8\\,x \\le \\theta(x) \\le 1.2\\,x$ 是否成立（对每个 $x$ 输出一个布尔值）。这些检查并非断言一个定理；它们仅仅报告在指定 $x$ 下的真值。\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序如下：\n$[E_{1},E_{2},E_{3},B_{1000},B_{100}]$,\n其中 $E_{j}$ 是测试用例 $j$ 的浮点数绝对误差，$B_{1000}$ 是 $x=1000$ 时的布尔值，$B_{100}$ 是 $x=100$ 时的布尔值。不应打印其他任何文本。", "solution": "问题要求设计并实现一种数值方法，使用精确恒等式 $\\theta(x) = \\pi(x)\\log x - \\int_{2}^{x} \\frac{\\pi(t)}{t}\\,dt$ 来估计第一类 Chebyshev 函数 $\\theta(x) = \\sum_{p \\le x, p \\text{ prime}} \\log p$。该方法将基于积分区间 $[2,x]$ 的一个划分，并且必须能得出严格的界和一个点估计。\n\n设区间 $[2,x]$ 的划分为 $2 = t_{0}  t_{1}  \\cdots  t_{m} = x$。积分 $I = \\int_{2}^{x} \\frac{\\pi(t)}{t}\\,dt$ 可分解为在各子区间上的和：\n$$\nI = \\sum_{k=0}^{m-1} \\int_{t_{k}}^{t_{k+1}} \\frac{\\pi(t)}{t}\\,dt\n$$\n\n**1. 积分界的推导**\n\n素数计数函数 $\\pi(t)$ 是一个阶梯函数，它在素数之间是常数，在每个素数点上增加 $1$。因此，$\\pi(t)$ 是 $t$ 的一个非递减函数。对于任何子区间 $[t_k, t_{k+1}]$，对于所有 $t \\in [t_k, t_{k+1}]$，下式成立：\n$$\n\\pi(t_k) \\le \\pi(t) \\le \\pi(t_{k+1})\n$$\n由于因子 $1/t$ 在 $t \\in [2, x]$ 上为正，我们可以将不等式乘以 $1/t$ 而不改变不等号的方向：\n$$\n\\frac{\\pi(t_k)}{t} \\le \\frac{\\pi(t)}{t} \\le \\frac{\\pi(t_{k+1})}{t}\n$$\n将此不等式在子区间 $[t_k, t_{k+1}]$ 上积分，得到：\n$$\n\\int_{t_{k}}^{t_{k+1}} \\frac{\\pi(t_k)}{t}\\,dt \\le \\int_{t_{k}}^{t_{k+1}} \\frac{\\pi(t)}{t}\\,dt \\le \\int_{t_{k}}^{t_{k+1}} \\frac{\\pi(t_{k+1})}{t}\\,dt\n$$\n由于 $\\pi(t_k)$ 和 $\\pi(t_{k+1})$ 相对于积分变量 $t$ 是常数，我们可以将它们提出来：\n$$\n\\pi(t_k) \\int_{t_{k}}^{t_{k+1}} \\frac{1}{t}\\,dt \\le \\int_{t_{k}}^{t_{k+1}} \\frac{\\pi(t)}{t}\\,dt \\le \\pi(t_{k+1}) \\int_{t_{k}}^{t_{k+1}} \\frac{1}{t}\\,dt\n$$\n$1/t$ 的积分是 $\\log t$。因此，$\\int_{t_k}^{t_{k+1}} \\frac{1}{t}\\,dt = \\log(t_{k+1}) - \\log(t_k) = \\log\\left(\\frac{t_{k+1}}{t_k}\\right)$。将其代回得到：\n$$\n\\pi(t_k) \\log\\left(\\frac{t_{k+1}}{t_k}\\right) \\le \\int_{t_{k}}^{t_{k+1}} \\frac{\\pi(t)}{t}\\,dt \\le \\pi(t_{k+1}) \\log\\left(\\frac{t_{k+1}}{t_k}\\right)\n$$\n将这些不等式对所有子区间（从 $k=0$ 到 $k=m-1$）求和，我们得到总积分 $I$ 所需的界：\n$$\n\\underbrace{\\sum_{k=0}^{m-1} \\pi(t_{k}) \\log\\left(\\frac{t_{k+1}}{t_{k}}\\right)}_{I_L} \\le I \\le \\underbrace{\\sum_{k=0}^{m-1} \\pi(t_{k+1}) \\log\\left(\\frac{t_{k+1}}{t_{k}}\\right)}_{I_U}\n$$\n此处，$I_L$ 是积分 $I$ 的下界，$I_U$ 是其上界。\n\n**2. $\\theta(x)$ 的界的推导**\n\n连接 $\\theta(x)$ 和积分 $I$ 的恒等式是 $\\theta(x) = \\pi(x)\\log x - I$。我们可以利用 $I$ 的界来建立 $\\theta(x)$ 的界。\n从 $I_L \\le I \\le I_U$ 出发，我们乘以 $-1$ 得到 $-I_U \\le -I \\le -I_L$。将 $\\pi(x)\\log x$ 加到不等式的每一部分，得到：\n$$\n\\pi(x)\\log x - I_U \\le \\pi(x)\\log x - I \\le \\pi(x)\\log x - I_L\n$$\n这就给出了 $\\theta(x)$ 的下界 $\\theta_L(x)$ 和上界 $\\theta_U(x)$：\n$$\n\\theta_L(x) = \\pi(x)\\log x - I_U \\le \\theta(x) \\le \\pi(x)\\log x - I_L = \\theta_U(x)\n$$\n\n**3. 中点估计量与误差界**\n\n积分 $I$ 的一个自然点估计选择是其界区间 $[I_L, I_U]$ 的中点，我们将其表示为 $\\widehat{I}$：\n$$\n\\widehat{I} = \\frac{I_L + I_U}{2}\n$$\n将此估计代入 $\\theta(x)$ 的恒等式，得到中点估计量 $\\widehat{\\theta}(x)$：\n$$\n\\widehat{\\theta}(x) = \\pi(x)\\log x - \\widehat{I} = \\pi(x)\\log x - \\frac{I_L + I_U}{2}\n$$\n$\\widehat{\\theta}(x)$ 的值是区间 $[\\theta_L(x), \\theta_U(x)]$ 的中点。该估计的绝对误差 $|\\widehat{\\theta}(x) - \\theta(x)|$ 受此区间宽度的一半所限制。该宽度为：\n$$\n\\theta_U(x) - \\theta_L(x) = (\\pi(x)\\log x - I_L) - (\\pi(x)\\log x - I_U) = I_U - I_L\n$$\n因此，误差的界为：\n$$\n|\\widehat{\\theta}(x) - \\theta(x)| \\le \\frac{\\theta_U(x) - \\theta_L(x)}{2} = \\frac{I_U - I_L}{2}\n$$\n这为中点估计量提供了一个显式的、可计算的误差界：\n$$\n\\text{Error Bound} = \\frac{1}{2} \\sum_{k=0}^{m-1} \\left(\\pi(t_{k+1}) - \\pi(t_k)\\right) \\log\\left(\\frac{t_{k+1}}{t_k}\\right)\n$$\n项 $\\pi(t_{k+1}) - \\pi(t_k)$ 计算的是区间 $(t_k, t_{k+1}]$ 内素数的数量。因此，误差界由素数的密度和划分区间在对数尺度上的宽度决定。\n\n**4. 整数划分情况的分析**\n\n考虑一个特殊情况，即 $x$ 是一个整数，且划分由从 $2$ 到 $x$ 的所有整数组成：$t_k = k+2$ 对于 $k=0, \\dots, x-2$。这些区间形如 $[k, k+1]$，其中 $k=2, \\dots, x-1$。\n\n在任何这样的区间 $[k, k+1)$ 内（对于变量 $t$），函数 $\\pi(t)$ 是常数且等于 $\\pi(k)$，因为 $k$ 和 $k+1$ 之间没有整数可以是素数。因此，在该子区间上的积分为：\n$$\n\\int_{k}^{k+1} \\frac{\\pi(t)}{t}\\,dt = \\int_{k}^{k+1} \\frac{\\pi(k)}{t}\\,dt = \\pi(k) \\int_{k}^{k+1} \\frac{1}{t}\\,dt = \\pi(k) \\log\\left(\\frac{k+1}{k}\\right)\n$$\n对于此划分，积分的下和 $I_L$ 为：\n$$\nI_L = \\sum_{k=2}^{x-1} \\pi(k) \\log\\left(\\frac{k+1}{k}\\right)\n$$\n这个和精确地等于每个子区间上精确积分的和。因此，对于整数划分，下界 $I_L$ 与积分的真值 $I$ 相同：\n$$\nI_L = \\sum_{k=2}^{x-1} \\int_{k}^{k+1} \\frac{\\pi(t)}{t} dt = \\int_{2}^{x} \\frac{\\pi(t)}{t} dt = I\n$$\n因此，$\\theta(x)$ 的上界 $\\theta_U(x) = \\pi(x)\\log x - I_L$ 变为精确值：\n$$\n\\theta_U(x) = \\pi(x)\\log x - I = \\theta(x)\n$$\n这意味着“该方法”——即所提出的计算界的框架——在采用整数划分时，其上界估计 $\\theta_U(x)$ 能给出 $\\theta(x)$ 的精确值。中点估计量 $\\widehat{\\theta}(x)$ 不会是精确的，除非 $I_U = I_L$，而这要求在 $(2, x]$ 中没有素数，这是一个荒谬的结论。中点估计的绝对误差是 $|\\widehat{\\theta}(x) - \\theta(x)| = |\\frac{\\theta_L(x)+\\theta_U(x)}{2} - \\theta_U(x)| = \\frac{\\theta_U(x)-\\theta_L(x)}{2} = \\frac{I_U-I_L}{2}$，这恰好是先验误差界。\n\n**5. 数值算法**\n实现将遵循以下步骤：\n1.  使用筛法生成所有小于等于所需 $x$ 最大值（即 $1000$）的素数。\n2.  创建一个函数 `pi(t)`，给定一个数 $t$，该函数能高效地找到小于等于 $t$ 的素数个数。这可以通过在预先计算的素数列表上使用二分查找来完成。\n3.  对每个测试用例 $(x, \\text{partition})$：\n    a. 生成指定的划分数组 $T = [t_0, t_1, \\dots, t_m]$。\n    b. 计算 $\\pi$ 值的数组：$P = [\\pi(t_0), \\pi(t_1), \\dots, \\pi(t_m)]$。\n    c. 使用对 $P$ 和 $T$ 的向量运算计算积分的下界 $I_L$ 和上界 $I_U$。\n    d. 计算中点估计 $\\widehat{\\theta}(x) = \\pi(x)\\log x - (I_L + I_U)/2$。\n    e. 通过对所有小于等于 $x$ 的素数的对数求和来计算 $\\theta(x)$ 的精确值。\n    f. 计算绝对误差 $E = |\\widehat{\\theta}(x) - \\theta(x)|$。\n4.  对于 Chebyshev 界的检查，计算 $\\theta(1000)$ 和 $\\theta(100)$ 并评估给定的不等式。\n5.  将所有结果格式化为指定的最终输出字符串。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem by implementing the numerical method for theta(x),\n    evaluating it on the test cases, and performing the required checks.\n    \"\"\"\n\n    # Step 1: Generate primes using a sieve up to the max required value.\n    MAX_N = 1000\n    primes = _sieve_of_eratosthenes(MAX_N)\n\n    # Step 2: Create a pi(x) function.\n    def pi(x, precomputed_primes):\n        \"\"\"Counts primes less than or equal to x using binary search.\"\"\"\n        if x  2:\n            return 0\n        return np.searchsorted(precomputed_primes, x, side='right')\n\n    # Step 3: Implement the numerical estimation method.\n    def estimate_theta(x, partition, _pi_func, precomputed_primes):\n        \"\"\"\n        Estimates theta(x) using the midpoint rule derived from integral bounds.\n        \"\"\"\n        if x  2:\n            return 0.0, 0.0\n\n        t = np.array(partition, dtype=float)\n        \n        # Handle trivial partition (e.g., [2, 2])\n        if len(t)  2 or t[0] == t[-1]:\n            I_L, I_U = 0.0, 0.0\n        else:\n            pi_vals = np.array([_pi_func(val, precomputed_primes) for val in t])\n            log_ratios = np.log(t[1:] / t[:-1])\n            I_L = np.sum(pi_vals[:-1] * log_ratios)\n            I_U = np.sum(pi_vals[1:] * log_ratios)\n        \n        I_hat = (I_L + I_U) / 2.0\n        pi_x = _pi_func(x, precomputed_primes)\n        \n        # Guard against log(x) for x  1, though problem constraints make this safe.\n        log_x = np.log(x) if x  0 else -np.inf \n        theta_hat = pi_x * log_x - I_hat\n        \n        return theta_hat\n\n    # Helper for exact theta(x)\n    def theta_exact(x, precomputed_primes):\n        \"\"\"Calculates the exact value of theta(x).\"\"\"\n        if x  2:\n            return 0.0\n        primes_le_x = precomputed_primes[precomputed_primes = x]\n        if primes_le_x.size == 0:\n            return 0.0\n        return np.sum(np.log(primes_le_x))\n\n    results = []\n    \n    # === Test Case 1 ===\n    x1 = 200.0\n    partition1 = np.arange(2, int(x1) + 1)\n    theta_hat_1 = estimate_theta(x1, partition1, pi, primes)\n    theta_exact_1 = theta_exact(x1, primes)\n    error_1 = np.abs(theta_hat_1 - theta_exact_1)\n    results.append(error_1)\n\n    # === Test Case 2 ===\n    x2 = 1000.0\n    r = 1.5\n    partition2 = [2.0]\n    while partition2[-1]  x2:\n        next_t = min(x2, max(partition2[-1] + 1, np.floor(r * partition2[-1])))\n        partition2.append(next_t)\n    theta_hat_2 = estimate_theta(x2, partition2, pi, primes)\n    theta_exact_2 = theta_exact(x2, primes)\n    error_2 = np.abs(theta_hat_2 - theta_exact_2)\n    results.append(error_2)\n\n    # === Test Case 3 ===\n    x3 = 2.0\n    partition3 = [2.0, 2.0]\n    theta_hat_3 = estimate_theta(x3, partition3, pi, primes)\n    theta_exact_3 = theta_exact(x3, primes)\n    error_3 = np.abs(theta_hat_3 - theta_exact_3)\n    results.append(error_3)\n    \n    # === Chebyshev Bound Checks ===\n    # For x = 1000\n    theta_1000 = theta_exact_2\n    B_1000 = (0.8 * 1000 = theta_1000 = 1.2 * 1000)\n    results.append(B_1000)\n    \n    # For x = 100\n    theta_100 = theta_exact(100, primes)\n    B_100 = (0.8 * 100 = theta_100 = 1.2 * 100)\n    results.append(B_100)\n    \n    # Final print statement in the exact required format.\n    print(f\"[{results[0]},{results[1]},{results[2]},{results[3]},{results[4]}]\")\n\n\ndef _sieve_of_eratosthenes(n):\n    \"\"\"\n    Generates prime numbers up to n using the Sieve of Eratosthenes.\n    Returns a numpy array of primes.\n    \"\"\"\n    if n  2:\n        return np.array([], dtype=int)\n    primes_bool = np.ones(n + 1, dtype=bool)\n    primes_bool[0:2] = False\n    for i in range(2, int(np.sqrt(n)) + 1):\n        if primes_bool[i]:\n            primes_bool[i*i::i] = False\n    return np.where(primes_bool)[0]\n\nsolve()\n```", "id": "3083112"}]}