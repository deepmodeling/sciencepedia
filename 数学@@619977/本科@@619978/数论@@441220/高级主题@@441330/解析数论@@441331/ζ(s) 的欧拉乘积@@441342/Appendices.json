{"hands_on_practices": [{"introduction": "要真正掌握欧拉乘积公式，最好的方法莫过于亲自动手实践。这个练习将通过一个简化的例子——只考虑前三个素数 $2, 3, 5$——来揭开欧拉乘积的神秘面纱。通过展开这个有限乘积，你将亲眼见证整数项是如何从素数因子中生成的，从而直观地理解素数与整数之间深刻的乘法联系。[@problem_id:3090926]", "problem": "设 $s$ 是一个复变量，满足 $\\Re(s)  1$。考虑由素数 $2$、$3$ 和 $5$ 构成的有限积 $\\prod_{p \\in \\{2,3,5\\}} (1 - p^{-s})^{-1}$。仅使用以下基本事实：对于任何满足 $|x|  1$ 的复数 $x$，有几何级数恒等式 $(1 - x)^{-1} = \\sum_{k=0}^{\\infty} x^{k}$，以及每个正整数都有唯一的素数分解，将 $\\prod_{p \\leq 5} (1 - p^{-s})^{-1}$ 展开成一个狄利克雷级数 (Dirichlet series)，并明确指出当素数仅限于 $2$、$3$ 和 $5$ 时，该级数的项 $n^{-s}$ 中作为底数的整数 $n$ 是哪些。将您的最终展开式表示为单个求和表达式（不要逐项列出），并以闭合形式给出答案。无需四舍五入。", "solution": "该问题陈述经证实具有科学依据，问题定义明确且客观。这是解析数论中的一个标准练习。\n\n设给定的有限积为 $P(s)$，其中 $s$ 是一个复变量，满足 $\\Re(s)  1$。该乘积由下式给出：\n$$ P(s) = \\prod_{p \\in \\{2,3,5\\}} (1 - p^{-s})^{-1} $$\n这可以明确地写为：\n$$ P(s) = (1 - 2^{-s})^{-1} (1 - 3^{-s})^{-1} (1 - 5^{-s})^{-1} $$\n问题要求我们使用几何级数恒等式 $(1 - x)^{-1} = \\sum_{k=0}^{\\infty} x^{k}$，该恒等式对任何满足 $|x|  1$ 的复数 $x$ 都有效。我们必须首先验证该条件对我们乘积中的每个因子都成立。\n\n对于项 $(1 - p^{-s})^{-1}$，对应的 $x$ 值为 $p^{-s}$。我们需要检查是否 $|p^{-s}|  1$。复变量 $s$ 可以写作 $s = \\sigma + it$，其中 $\\sigma = \\Re(s)$ 和 $t = \\Im(s)$ 是实数。给定条件为 $\\sigma  1$。$p^{-s}$ 的模为：\n$$ |p^{-s}| = |p^{-(\\sigma + it)}| = |p^{-\\sigma} p^{-it}| = |p^{-\\sigma}| |p^{-it}| $$\n因为 $p$ 和 $\\sigma$ 是实数，所以项 $|p^{-\\sigma}|$ 就是 $p^{-\\sigma}$。项 $p^{-it}$ 可以使用欧拉恒等式写作 $\\exp(-it \\ln p) = \\cos(-t \\ln p) + i \\sin(-t \\ln p)$。这个复指数的模总是 $1$：\n$$ |\\exp(-it \\ln p)| = \\sqrt{\\cos^2(-t \\ln p) + \\sin^2(-t \\ln p)} = 1 $$\n因此，$p^{-s}$ 的模简化为：\n$$ |p^{-s}| = p^{-\\sigma} = \\frac{1}{p^{\\sigma}} $$\n由于素数 $p$ 为 $2$、$3$ 和 $5$，有 $p \\ge 2$。给定 $\\sigma = \\Re(s)  1$，我们有 $p^{\\sigma}  p^1 \\ge 2$。这意味着：\n$$ |p^{-s}| = \\frac{1}{p^{\\sigma}}  \\frac{1}{2}  1 $$\n几何级数收敛的条件对于乘积中的每个素数因子都满足。我们现在可以展开每一项：\n$$ (1 - 2^{-s})^{-1} = \\sum_{a=0}^{\\infty} (2^{-s})^{a} = \\sum_{a=0}^{\\infty} 2^{-as} $$\n$$ (1 - 3^{-s})^{-1} = \\sum_{b=0}^{\\infty} (3^{-s})^{b} = \\sum_{b=0}^{\\infty} 3^{-bs} $$\n$$ (1 - 5^{-s})^{-1} = \\sum_{c=0}^{\\infty} (5^{-s})^{c} = \\sum_{c=0}^{\\infty} 5^{-cs} $$\n将这些级数代回到 $P(s)$ 的乘积表达式中：\n$$ P(s) = \\left( \\sum_{a=0}^{\\infty} 2^{-as} \\right) \\left( \\sum_{b=0}^{\\infty} 3^{-bs} \\right) \\left( \\sum_{c=0}^{\\infty} 5^{-cs} \\right) $$\n由于对于 $\\Re(s)1$，这些级数中的每一个都是绝对收敛的，我们可以逐项相乘并以任意顺序重新排列各项。这是绝对收敛级数的柯西乘积（Cauchy product）的一个性质。所得展开式中的通项是每个级数中一项的乘积：\n$$ (2^{-as}) (3^{-bs}) (5^{-cs}) $$\n其中 $a, b, c$ 是选择的非负整数。使用指数定律 $(x^z y^z = (xy)^z)$，我们可以将它们合并为：\n$$ 2^{-as} 3^{-bs} 5^{-cs} = (2^a)^{-s} (3^b)^{-s} (5^c)^{-s} = (2^a 3^b 5^c)^{-s} $$\n完整的展开式是所有非负整数 $a, b, c$ 可能组合的求和：\n$$ P(s) = \\sum_{a=0}^{\\infty} \\sum_{b=0}^{\\infty} \\sum_{c=0}^{\\infty} (2^a 3^b 5^c)^{-s} $$\n这个表达式是一个狄利克雷级数。问题要求我们确定在项 $n^{-s}$ 中作为底数出现的整数 $n$。从上面的表达式可以看出，这些整数是所有可以写成以下形式的数 $n$：\n$$ n = 2^a 3^b 5^c $$\n其中 $a, b$ 和 $c$ 是非负整数（即 $a, b, c \\in \\{0, 1, 2, \\dots\\}$）。\n\n算术基本定理指出，每个正整数都有唯一的素数分解。这意味着每个不同的指数三元组 $(a, b, c)$ 对应一个唯一的整数 $n$。反之，任何其素因子完全来自集合 $\\{2, 3, 5\\}$ 的整数 $n$ 都可以表示成这种形式。这样的整数被称为 $5$-光滑数或 $\\{2,3,5\\}$-脆数。\n\n例如，如果 $(a,b,c)=(1,1,0)$，则 $n=2^1 3^1 5^0 = 6$，得到项 $6^{-s}$。如果 $(a,b,c)=(0,0,0)$，则 $n=2^0 3^0 5^0 = 1$，得到项 $1^{-s}$。像 $7$ 这样的整数不能以这种方式形成，因此项 $7^{-s}$ 不会出现在展开式中。\n\n最终的展开式，以单个求和表达式写出，即为上面推导出的嵌套求和，它包含了所有 $n$ 是 $5$-光滑数的项 $n^{-s}$。", "answer": "$$ \\boxed{\\sum_{a=0}^{\\infty}\\sum_{b=0}^{\\infty}\\sum_{c=0}^{\\infty} (2^{a} 3^{b} 5^{c})^{-s}} $$", "id": "3090926"}, {"introduction": "理解了欧拉乘积的运作机制后，我们可以探索其更深层的含义。让我们通过一个思想实验来探讨不同素数对 $\\zeta$ 函数值的贡献权重：如果宇宙中“丢失”了一个素数，会发生什么？本练习通过定义一个“相对敏感度”指标，量化了忽略一个小数和一个大素数对 $\\zeta(s)$ 值的不同影响，帮助你领会小素数在数论中扮演的关键角色。[@problem_id:3090865]", "problem": "设 $s$ 是一个复数，满足 $\\Re(s)  1$。黎曼zeta函数 $\\zeta(s)$ 由绝对收敛的级数 $\\zeta(s) = \\sum_{n=1}^{\\infty} n^{-s}$ 定义，并有欧拉乘积表示 $\\zeta(s) = \\prod_{p} \\left(1 - p^{-s}\\right)^{-1}$，其中乘积遍及所有素数 $p$。对于一个固定的素数 $p$，定义省略素数 $p$ 的修正乘积为\n$$\n\\zeta_{(\\ne p)}(s) := \\prod_{\\substack{q\\ \\text{prime} \\\\ q \\ne p}} \\left(1 - q^{-s}\\right)^{-1}.\n$$\n定义省略 $p$ 引起的相对乘法灵敏度为\n$$\n\\delta_{p}(s) := \\frac{\\left|\\zeta_{(\\ne p)}(s) - \\zeta(s)\\right|}{\\left|\\zeta(s)\\right|}.\n$$\n仅使用上述定义和绝对收敛乘积的基本性质，用 $p$ 和 $s$ 表示 $\\delta_{p}(s)$。然后，对于实数输入 $s = 2$ 的特殊情况，计算比率\n$$\nR := \\frac{\\delta_{2}(2)}{\\delta_{101}(2)}\n$$\n的精确值。请给出 $R$ 的最终结果，要求为精确数（不要四舍五入）。", "solution": "在尝试求解之前，将首先对所述问题进行严格验证，以确保其科学和数学上的完整性。\n\n**问题验证**\n\n对问题陈述的审慎检验揭示了以下几点：\n\n- **已知条件**：\n    - 复变量 $s$ 定义在半平面 $\\Re(s)  1$ 中。\n    - 黎曼zeta函数由其级数定义给出，$\\zeta(s) = \\sum_{n=1}^{\\infty} n^{-s}$。\n    - 其欧拉乘积表示已给出：$\\zeta(s) = \\prod_{p} \\left(1 - p^{-s}\\right)^{-1}$，其中 $p$ 为所有素数。\n    - 修正乘积 $\\zeta_{(\\ne p)}(s)$ 定义为省略单个素数 $p$ 的因子的欧拉乘积：$\\zeta_{(\\ne p)}(s) := \\prod_{\\substack{q\\ \\text{prime} \\\\ q \\ne p}} \\left(1 - q^{-s}\\right)^{-1}$。\n    - 灵敏度度量 $\\delta_{p}(s)$ 定义为省略素数 $p$ 的因子后zeta函数变化的相对大小：$\\delta_{p}(s) := \\frac{\\left|\\zeta_{(\\ne p)}(s) - \\zeta(s)\\right|}{\\left|\\zeta(s)\\right|}$。\n    - 目标是求出 $\\delta_{p}(s)$ 的表达式，然后计算当 $s=2$ 时的特定比率 $R := \\frac{\\delta_{2}(2)}{\\delta_{101}(2)}$。\n\n- **评估**：\n    1.  **科学基础**：该问题牢固地植根于标准的解析数论。黎曼zeta函数的定义、其级数和乘积表示，以及绝对收敛的条件 $\\Re(s)  1$ 都是正确和标准的。该问题依赖于体现在欧拉乘积中的算术基本定理。\n    2.  **适定性**：该问题是自洽且无歧义的。待求的量有明确定义。问题结构逻辑清晰，可导出一个唯一的解。已知事实是，当 $\\Re(s)  1$ 时 $\\zeta(s) \\neq 0$，这确保了 $\\delta_{p}(s)$ 定义中的分母不为零，避免了无定义的表达式。2和101都是素数，与上下文一致。\n    3.  **客观性**：语言正式而精确，没有任何主观或非数学内容。\n\n- **结论**：\n该问题被认为是**有效的**，因为它是科学上合理、适定且客观的。因此，我们可以继续推导解答。\n\n**解题推导**\n\n$\\zeta(s)$ 与修正乘积 $\\zeta_{(\\ne p)}(s)$ 之间的关系是问题的核心。我们首先从 $\\zeta(s)$ 的欧拉乘积表示中分离出对应于素数 $p$ 的因子：\n$$\n\\zeta(s) = \\prod_{q\\ \\text{prime}} \\left(1 - q^{-s}\\right)^{-1} = \\left(1 - p^{-s}\\right)^{-1} \\cdot \\left( \\prod_{\\substack{q\\ \\text{prime} \\\\ q \\ne p}} \\left(1 - q^{-s}\\right)^{-1} \\right)\n$$\n注意到右侧的第二项是 $\\zeta_{(\\ne p)}(s)$ 的定义，我们便建立了直接的联系：\n$$\n\\zeta(s) = \\left(1 - p^{-s}\\right)^{-1} \\zeta_{(\\ne p)}(s)\n$$\n当 $\\Re(s)  1$ 时，项 $(1 - p^{-s})$ 非零。因此，我们可以通过代数变换方程，用 $\\zeta(s)$ 来表示 $\\zeta_{(\\ne p)}(s)$：\n$$\n\\zeta_{(\\ne p)}(s) = \\left(1 - p^{-s}\\right) \\zeta(s)\n$$\n现在我们将此表达式代入相对灵敏度 $\\delta_{p}(s)$ 的定义中：\n$$\n\\delta_{p}(s) = \\frac{\\left|\\zeta_{(\\ne p)}(s) - \\zeta(s)\\right|}{\\left|\\zeta(s)\\right|} = \\frac{\\left|\\left(1 - p^{-s}\\right) \\zeta(s) - \\zeta(s)\\right|}{\\left|\\zeta(s)\\right|}\n$$\n我们可以从分子中模内的各项中提出因子 $\\zeta(s)$：\n$$\n\\delta_{p}(s) = \\frac{\\left|\\zeta(s) \\left( (1 - p^{-s}) - 1 \\right) \\right|}{\\left|\\zeta(s)\\right|} = \\frac{\\left|\\zeta(s)\\right| \\left| -p^{-s} \\right|}{\\left|\\zeta(s)\\right|}\n$$\n正如在验证过程中所确定的，当 $\\Re(s)  1$ 时 $\\zeta(s) \\neq 0$，所以我们可以消去非零项 $|\\zeta(s)|$：\n$$\n\\delta_{p}(s) = \\left| -p^{-s} \\right| = \\left| p^{-s} \\right|\n$$\n为了进一步简化，令 $s = \\sigma + it$，其中 $\\sigma = \\Re(s)$。项 $p^{-s}$ 即 $p^{-(\\sigma+it)} = p^{-\\sigma}p^{-it}$。因此，其模为：\n$$\n\\left| p^{-s} \\right| = \\left| p^{-\\sigma} \\right| \\left| p^{-it} \\right|\n$$\n由于 $p$ 是一个正素数且 $\\sigma$ 是实数，$p^{-\\sigma}$ 是一个正实数，所以 $|p^{-\\sigma}| = p^{-\\sigma}$。项 $p^{-it}$ 是单位圆上的一个复数，因为 $\\left|p^{-it}\\right| = \\left|\\exp(-it\\ln p)\\right| = 1$。因此，$\\delta_{p}(s)$ 的表达式简化为：\n$$\n\\delta_{p}(s) = p^{-\\sigma} = p^{-\\Re(s)}\n$$\n这就是用 $p$ 和 $s$ 表示的灵敏度的一般表达式。\n\n问题的第二部分要求计算比率 $R = \\frac{\\delta_{2}(2)}{\\delta_{101}(2)}$。输入是实数 $s=2$，此时 $\\Re(s) = 2$。\n使用推导出的 $\\delta_{p}(s)$ 公式，我们计算 $R$ 的分子和分母：\n对于 $p=2$，灵敏度为：\n$$\n\\delta_{2}(2) = 2^{-\\Re(2)} = 2^{-2} = \\frac{1}{4}\n$$\n对于 $p=101$，灵敏度为：\n$$\n\\delta_{101}(2) = 101^{-\\Re(2)} = 101^{-2} = \\frac{1}{101^2} = \\frac{1}{10201}\n$$\n现在，我们计算比率 $R$：\n$$\nR = \\frac{\\delta_{2}(2)}{\\delta_{101}(2)} = \\frac{2^{-2}}{101^{-2}} = \\frac{1/4}{1/10201} = \\frac{10201}{4}\n$$\n这就是所要求的精确值。", "answer": "$$\n\\boxed{\\frac{10201}{4}}\n$$", "id": "3090865"}, {"introduction": "理论的最终目的是应用于实践。欧拉乘积是一个涉及所有素数的无限乘积，这在实际计算中是无法直接实现的。这个练习将理论与计算相结合，要求你使用有限数目的素数因子来近似计算一个著名的数学常数 $\\zeta(2)$。更重要的是，它引导你推导并计算该近似的误差上界，让你掌握在科学计算中至关重要的一项技能：任何近似值都必须伴随着对其精度的评估。[@problem_id:3090908]", "problem": "在数论和黎曼ζ函数的欧拉乘积背景下，考虑对实数输入$s1$由狄利克雷级数$\\zeta(s)=\\sum_{n=1}^{\\infty}n^{-s}$定义的经典黎曼ζ函数。使用算术基本定理（该定理断言每个整数$n\\geq 2$都有唯一的素数分解），以及$\\zeta(s)$在$s1$时的绝对收敛性，来阐述跨素数的乘法结构如何导出将$\\zeta(s)$表示为关于素数的乘积。对于$s=2$的特殊情况，通过由截至一个界限$P$的素因子构成的有限乘法近似来估算$\\zeta(2)$，即乘以与素数$p\\leq P$相关的局部因子。然后，通过使用从$\\sum_{n=1}^{\\infty}n^{-2}$的收敛性质和积分判别法派生出的尾部界，来界定来自素数$pP$的贡献，从而估计所产生的近似误差。\n\n您的任务是：\n1. 对于给定的界限$P$，计算对$\\zeta(2)$的有限乘法近似$A_{P}$，该近似通过将所有形式为$(1-p^{-2})^{-1}$且$p\\leq P$的素数的局部素因子相乘得到。\n2. 令$Q$表示严格大于$P$的最小素数。利用各项的非负性以及任何仅由大于$P$的素数构成的整数其最小值至少为$Q$这一事实，证明所有被忽略的素数的相对尾部贡献的一个上界，并使用积分判别法证明尾部和$\\sum_{n=Q}^{\\infty}n^{-2}$的上界为$1/(Q-1)$。由此得出结论，近似$A_{P}$对$\\zeta(2)$的相对误差上界为$1/(Q-1)$，绝对误差上界为$A_{P}\\cdot 1/(Q-1)$。\n3. 实现一个程序，该程序进行这些数值计算，包括生成$p\\leq P$的素数并找到大于$P$的最小素数$Q$。\n\n程序必须：\n- 对于下面测试套件中的每个$P$，计算三元组$[A_{P},E_{\\text{abs}}(P),E_{\\text{rel}}(P)]$，其中$A_{P}$是上文定义的有限乘法近似，$E_{\\text{abs}}(P)$是绝对误差上界$A_{P}\\cdot 1/(Q-1)$，$E_{\\text{rel}}(P)$是相对误差上界$1/(Q-1)$。\n- 将所有浮点输出四舍五入到$12$位小数。\n- 如果没有素数$p\\leq P$（例如，当$P2$时），将空乘积视为$1$。\n\n测试套件（每个$P$是算法的一个整数输入）：\n- $P=1$（不包含素数的边界情况），\n- $P=2$（仅包含最小素数的边界情况），\n- $P=13$（中等情况），\n- $P=29$（指令中强调的情况）。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个条目本身是对应于$P$的三个浮点数$[A_{P},E_{\\text{abs}}(P),E_{\\text{rel}}(P)]$的逗号分隔列表，四舍五入到12位小数；例如，一个有效的输出看起来像$[[a,b,c],[d,e,f],[g,h,i],[j,k,l]]$，没有额外的文本。", "solution": "该问题被评估为有效，因为它在既定的数论中有科学依据，定义和约束条件齐全，问题明确，客观，且不违反任何无效标准。因此，我们可以着手解决。\n\n解决方案包括三个部分：首先，对黎曼ζ函数的欧拉乘积表示进行理论上的阐述；其次，推导$\\zeta(2)$情况下的指定近似及其误差界；第三，对给定的测试用例进行数值计算。\n\n**1. 欧拉乘积公式的阐述**\n\n黎曼ζ函数对任何实数$s > 1$定义为无穷级数的和：\n$$\n\\zeta(s) = \\sum_{n=1}^{\\infty} \\frac{1}{n^s} = \\frac{1}{1^s} + \\frac{1}{2^s} + \\frac{1}{3^s} + \\frac{1}{4^s} + \\dots\n$$\n对于$s > 1$，该级数是绝对收敛的。这个性质至关重要，因为它允许我们在不改变其和的情况下重新排列和重组级数的项。\n\n算术基本定理指出，任何整数$n \\geq 2$都可以写成唯一的素数幂乘积：$n = p_1^{k_1} p_2^{k_2} \\cdots p_r^{k_r}$。这种唯一的因数分解是将整数上的求和与素数上的乘积联系起来的关键。\n\n考虑所有素数$p$的项$(1 - p^{-s})^{-1}$的乘积。使用几何级数公式$\\sum_{k=0}^{\\infty} x^k = (1-x)^{-1}$（在$|x|  1$时有效），我们可以展开乘积中的每一项。对于任何素数$p \\geq 2$和任何$s > 1$，我们有$0  p^{-s} \\leq 2^{-s}  1$，所以几何级数收敛。\n$$\n(1 - p^{-s})^{-1} = 1 + p^{-s} + p^{-2s} + p^{-3s} + \\dots = \\sum_{k=0}^{\\infty} \\frac{1}{(p^k)^s}\n$$\n欧拉乘积是这些级数在所有素数$p$上的乘积：\n$$\n\\prod_{p \\text{ prime}} (1 - p^{-s})^{-1} = \\prod_{p \\text{ prime}} \\left( \\sum_{k=0}^{\\infty} p^{-ks} \\right)\n$$\n让我们为前几个素数$p_1=2, p_2=3, p_3=5, \\dots$展开这个乘积：\n$$\n\\left(1 + \\frac{1}{2^s} + \\frac{1}{4^s} + \\dots\\right) \\left(1 + \\frac{1}{3^s} + \\frac{1}{9^s} + \\dots\\right) \\left(1 + \\frac{1}{5^s} + \\frac{1}{25^s} + \\dots\\right) \\cdots\n$$\n当我们将这些级数相乘时，所得和中的一个通用项是通过从每个级数中选取一项（例如$p_1^{-k_1 s}$，$p_2^{-k_2 s}$等）形成的。这给出了一个形式如下的项：\n$$\n(p_1^{k_1})^{-s} (p_2^{k_2})^{-s} \\cdots (p_r^{k_r})^{-s} = (p_1^{k_1} p_2^{k_2} \\cdots p_r^{k_r})^{-s}\n$$\n根据算术基本定理，任何整数$n \\ge 1$（其中$n=1$对应于对所有素数选择$k_i=0$）都有唯一的素数幂乘积表示。因此，每一项$n^{-s}$在乘积的展开式中恰好出现一次。$\\zeta(s)$的绝对收敛性证明了这种形式展开和重排的合理性。因此，我们得到了欧拉乘积公式：\n$$\n\\zeta(s) = \\sum_{n=1}^{\\infty} \\frac{1}{n^s} = \\prod_{p \\text{ prime}} (1 - p^{-s})^{-1}\n$$\n\n**2. $\\zeta(2)$的有限近似和误差界**\n\n对于$s=2$的特殊情况，公式为$\\zeta(2) = \\prod_{p} (1 - p^{-2})^{-1}$。该问题通过对截至某个界限$P$的素数进行乘积来定义有限近似$A_P$：\n$$\nA_P = \\prod_{p \\le P} (1 - p^{-2})^{-1}\n$$\n$\\zeta(2)$的完整值可以分为两部分：截至$P$的乘积和大于$P$的素数的尾部乘积。\n$$\n\\zeta(2) = \\left( \\prod_{p \\le P} (1 - p^{-2})^{-1} \\right) \\left( \\prod_{p > P} (1 - p^{-2})^{-1} \\right) = A_P \\cdot T_P\n$$\n其中$T_P = \\prod_{p > P} (1 - p^{-2})^{-1}$。近似$A_P$相对于$\\zeta(2)$的相对误差可以表示为$\\frac{\\zeta(2) - A_P}{A_P} = \\frac{A_P T_P - A_P}{A_P} = T_P - 1$。\n\n为了界定这个误差，我们分析尾部乘积$T_P$。像之前一样使用几何级数展开$T_P$得到：\n$$\nT_P = \\prod_{p > P} \\left( \\sum_{k=0}^{\\infty} p^{-2k} \\right) = \\sum_{n \\in S_P} \\frac{1}{n^2}\n$$\n其中$S_P$是其素因子都严格大于$P$的整数集合。这个集合包括1（素数的空乘积），所有其他元素都是整数$n > 1$。因此，我们可以写成：\n$$\nT_P = 1 + \\sum_{n \\in S_P, n > 1} \\frac{1}{n^2}\n$$\n相对误差恰好是这个和：\n$$\nT_P - 1 = \\sum_{n \\in S_P, n > 1} \\frac{1}{n^2}\n$$\n令$Q$为严格大于$P$的最小素数。任何满足$n>1$的整数$n \\in S_P$必须由所有$\\geq Q$的素数构成。这样的最小整数是$Q$本身。因此，和中的每个整数$n$都大于或等于$Q$。集合$\\{n \\in S_P, n > 1\\}$是所有整数集合$\\{Q, Q+1, Q+2, \\dots\\}$的一个子集。由于所有项都是正的，我们可以通过对从$Q$开始的所有整数求和来建立一个上界：\n$$\n\\text{相对误差} = T_P - 1 \\le \\sum_{n=Q}^{\\infty} \\frac{1}{n^2}\n$$\n我们现在使用积分判别法来界定这个尾部和。函数$f(x) = x^{-2}$在$x \\geq 1$上是正的、连续的且递减的。这个和可以通过一个积分来界定，如下所示：\n$$\n\\sum_{n=Q}^{\\infty} \\frac{1}{n^2} \\le \\int_{Q-1}^{\\infty} \\frac{1}{x^2} dx\n$$\n计算该积分：\n$$\n\\int_{Q-1}^{\\infty} x^{-2} dx = \\left[ -x^{-1} \\right]_{Q-1}^{\\infty} = \\lim_{b \\to \\infty} \\left( -\\frac{1}{b} \\right) - \\left( -\\frac{1}{Q-1} \\right) = 0 + \\frac{1}{Q-1} = \\frac{1}{Q-1}\n$$\n这证明了相对误差的上界为$E_{\\text{rel}}(P) = \\frac{1}{Q-1}$。\n\n绝对误差为$|\\zeta(2) - A_P| = \\zeta(2) - A_P = A_P(T_P - 1)$。使用相对误差的界，我们得到绝对误差的一个上界：\n$$\n|\\zeta(2) - A_P| \\le A_P \\cdot \\frac{1}{Q-1}\n$$\n这就是指定的绝对误差上界$E_{\\text{abs}}(P) = A_P \\cdot \\frac{1}{Q-1}$。\n\n**3. 数值计算**\n\n在实现上，我们需要一个方法来生成截至$P$的素数，并找到下一个大于$P$的素数$Q$。对于给定的$P$范围，基于试除法的素性测试就足够了。\n\n每个测试用例的计算如下：\n- 对于$P=1$：没有素数$p \\le 1$。空乘积定义为1，所以$A_1 = 1$。大于1的最小素数是$Q=2$。相对误差界为$E_{\\text{rel}}(1) = 1/(2-1) = 1$。绝对误差界为$E_{\\text{abs}}(1) = A_1 \\cdot E_{\\text{rel}}(1) = 1 \\cdot 1 = 1$。\n- 对于$P=2$：唯一的素数$p \\le 2$是2。因此，$A_2 = (1 - 2^{-2})^{-1} = (1 - 1/4)^{-1} = (3/4)^{-1} = 4/3 \\approx 1.333333333333$。下一个素数是$Q=3$。相对误差界为$E_{\\text{rel}}(2) = 1/(3-1) = 0.5$。绝对误差界为$E_{\\text{abs}}(2) = (4/3) \\cdot 0.5 = 2/3 \\approx 0.666666666667$。\n- 对于$P=13$：素数为$2, 3, 5, 7, 11, 13$。下一个素数是$Q=17$。\n  $A_{13} = \\prod_{p \\in \\{2,3,5,7,11,13\\}} (1-p^{-2})^{-1} \\approx 1.621996598502$。\n  $E_{\\text{rel}}(13) = 1/(17-1) = 1/16 = 0.0625$。\n  $E_{\\text{abs}}(13) = A_{13} \\cdot (1/16) \\approx 0.101374787406$。\n- 对于$P=29$：素数为$2, 3, 5, 7, 11, 13, 17, 19, 23, 29$。下一个素数是$Q=31$。\n  $A_{29} = \\prod_{p \\le 29} (1-p^{-2})^{-1} \\approx 1.637774136611$。\n  $E_{\\text{rel}}(29) = 1/(31-1) = 1/30 \\approx 0.033333333333$。\n  $E_{\\text{abs}}(29) = A_{29} \\cdot (1/30) \\approx 0.054592471220$。\n\n程序将自动执行这些计算并按指定格式化输出。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes finite multiplicative approximations to zeta(2) and their error bounds.\n    \"\"\"\n\n    def is_prime(n):\n        \"\"\"\n        Checks if an integer n is a prime number.\n        \"\"\"\n        if n  2:\n            return False\n        if n == 2 or n == 3:\n            return True\n        if n % 2 == 0 or n % 3 == 0:\n            return False\n        i = 5\n        # Trial division up to sqrt(n)\n        while i * i = n:\n            if n % i == 0 or n % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n\n    def get_primes_up_to(P):\n        \"\"\"\n        Generates a list of prime numbers less than or equal to P.\n        \"\"\"\n        if P  2:\n            return []\n        primes_list = []\n        for i in range(2, P + 1):\n            if is_prime(i):\n                primes_list.append(i)\n        return primes_list\n\n    def get_next_prime(P):\n        \"\"\"\n        Finds the smallest prime number strictly greater than P.\n        \"\"\"\n        q = P + 1\n        while True:\n            if is_prime(q):\n                return q\n            q += 1\n\n    # Test suite from the problem statement\n    test_cases = [1, 2, 13, 29]\n    all_results = []\n\n    for P in test_cases:\n        # Task 1: Compute the finite multiplicative approximation Ap\n        primes = get_primes_up_to(P)\n        \n        if not primes:\n            # The empty product is defined as 1\n            Ap = 1.0\n        else:\n            factors = [(1.0 - p**-2)**-1 for p in primes]\n            Ap = np.prod(factors)\n\n        # Task 2: Compute the error bounds\n        # Find Q, the smallest prime strictly greater than P\n        Q = get_next_prime(P)\n\n        # Compute the relative error upper bound, E_rel(P) = 1/(Q-1)\n        E_rel = 1.0 / (Q - 1)\n\n        # Compute the absolute error upper bound, E_abs(P) = Ap * E_rel\n        E_abs = Ap * E_rel\n        \n        # Store the triple [Ap, E_abs, E_rel]\n        # The values are kept as high-precision floats until final formatting.\n        result_triple = [Ap, E_abs, E_rel]\n        all_results.append(result_triple)\n\n    # Format the final output string according to the specified format.\n    # The output must be rounded to 12 decimal places.\n    # e.g., [[a_1,b_1,c_1],[a_2,b_2,c_2],...]\n    inner_strings = []\n    for triple in all_results:\n        # Round each value to 12 decimal places and format the string.\n        # The f-string format specifier ensures 12 digits are printed, even if trailing zeros.\n        f_Ap = f\"{round(triple[0], 12):.12f}\"\n        f_E_abs = f\"{round(triple[1], 12):.12f}\"\n        f_E_rel = f\"{round(triple[2], 12):.12f}\"\n        inner_strings.append(f\"[{f_Ap},{f_E_abs},{f_E_rel}]\")\n    \n    # Combine the inner lists into the final output string.\n    output_str = f\"[{','.join(inner_strings)}]\"\n    \n    # Print the final result to stdout.\n    print(output_str)\n\nsolve()\n```", "id": "3090908"}]}