{"hands_on_practices": [{"introduction": "要真正理解 abc 猜想，最好的方法就是亲自动手处理其核心概念。在我们领会这个猜想的深刻内涵之前，我们必须首先熟练掌握它的基本构成要素：一个整数的根基（radical），记为 $\\operatorname{rad}(n)$，以及一个 abc-三元组的品质（quality），记为 $q(a,b,c)$。下面的练习 [@problem_id:3090088] 将通过一个简单而著名的例子，引导你完成这些基本计算。", "problem": "在 $abc$ 猜想的背景下，一个 $abc$ 三元组是由三个正整数 $(a,b,c)$ 组成的，满足 $a+b=c$ 且 $\\gcd(a,b)=\\gcd(a,c)=\\gcd(b,c)=1$，其中 $\\gcd$ 表示最大公约数 (GCD)。对于一个正整数 $n$，定义其根基 $\\operatorname{rad}(n)$ 为整除 $n$ 的不同素数的乘积。$abc$ 三元组的品质定义为\n$$\nq(a,b, c) = \\frac{\\ln c}{\\ln \\operatorname{rad}(abc)},\n$$\n其中 $\\ln$ 表示自然对数。\n\n考虑一个具体的小三元组，其中 $a=1$, $b=8$, $c=9$。从上述定义以及素数分解和自然对数的基本性质出发，验证 $(a,b,c)$ 是一个 $abc$ 三元组，计算 $\\operatorname{rad}(abc)$，然后计算其品质 $q(a,b,c)$。\n\n将 $q(a,b,c)$ 的最终数值答案四舍五入到 $4$ 位有效数字。", "solution": "首先对问题进行验证，以确保其科学上合理、内容自洽且提法恰当。\n\n**步骤 1：问题验证**\n\n问题要求针对一个特定的整数三元组，进行一系列与 $abc$ 猜想相关的计算。\n\n**提取的已知条件：**\n- $abc$ 三元组是一组三个正整数 $(a,b,c)$，满足 $a+b=c$ 且 $\\gcd(a,b)=\\gcd(a,c)=\\gcd(b,c)=1$。\n- 一个正整数 $n$ 的根基，记为 $\\operatorname{rad}(n)$，是整除 $n$ 的不同素数的乘积。\n- $abc$ 三元组的品质由公式 $q(a,b, c) = \\frac{\\ln c}{\\ln \\operatorname{rad}(abc)}$ 给出。\n- 待分析的具体三元组由 $a=1$, $b=8$, $c=9$ 定义。\n- 任务是：\n    1. 验证 $(1, 8, 9)$ 是一个 $abc$ 三元组。\n    2. 计算此三元组的 $\\operatorname{rad}(abc)$。\n    3. 计算品质 $q(1, 8, 9)$，并四舍五入到 $4$ 位有效数字。\n\n**验证结论：**\n问题是有效的。它基于数论中与 $abc$ 猜想相关的标准定义。解答所需的所有定义、常数和变量都已明确提供。问题逻辑一致、提法恰当且客观。它没有违反任何科学原理，也不包含任何事实错误。因此，我们可以着手解答。\n\n**步骤 2：解答**\n\n解答将按照问题陈述中列出的任务逐步构建。\n\n**第 1 部分：验证 $abc$ 三元组**\n\n给定三元组 $(a,b,c)$，其中 $a=1$, $b=8$, $c=9$。要成为一个 $abc$ 三元组，它必须满足两个条件。\n\n首先，必须满足求和条件 $a+b=c$。\n$$1 + 8 = 9$$\n该条件已满足。\n\n其次，这些整数必须两两互质，意味着 $\\gcd(a,b)=1$, $\\gcd(a,c)=1$ 且 $\\gcd(b,c)=1$。我们逐对进行检验：\n- $\\gcd(a,b) = \\gcd(1,8)$。1 与任何其他整数的最大公约数是 1。因此，$\\gcd(1,8)=1$。\n- $\\gcd(a,c) = \\gcd(1,9)$。同样，最大公约数是 1。因此，$\\gcd(1,9)=1$。\n- $\\gcd(b,c) = \\gcd(8,9)$。为了求这个值，我们检查 8 和 9 的素数分解。8 的素数分解是 $2^3$。9 的素数分解是 $3^2$。由于它们没有共同的素因子，最大公约数是 1。因此，$\\gcd(8,9)=1$。\n\n由于求和条件和两两互质条件都已满足，三元组 $(1, 8, 9)$ 被确认为一个 $abc$ 三元组。\n\n**第 2 部分：计算根基**\n\n根基 $\\operatorname{rad}(n)$ 是 $n$ 的不同素因子的乘积。我们需要计算 $\\operatorname{rad}(abc)$。\n首先，我们计算乘积 $abc$：\n$$abc = 1 \\cdot 8 \\cdot 9 = 72$$\n接下来，我们求 72 的素数分解：\n$$72 = 8 \\cdot 9 = (2 \\cdot 2 \\cdot 2) \\cdot (3 \\cdot 3) = 2^3 \\cdot 3^2$$\n72 的不同素因子是 $2$ 和 $3$。\n根据定义，72 的根基是这些不同素因子的乘积：\n$$\\operatorname{rad}(72) = 2 \\cdot 3 = 6$$\n因此，对于三元组 $(1, 8, 9)$，我们有 $\\operatorname{rad}(abc) = 6$。\n\n**第 3 部分：计算品质**\n\n三元组的品质定义为 $q(a,b, c) = \\frac{\\ln c}{\\ln \\operatorname{rad}(abc)}$。\n使用 $c=9$ 和 $\\operatorname{rad}(abc)=6$ 这两个值，我们可以计算其品质：\n$$q(1, 8, 9) = \\frac{\\ln 9}{\\ln 6}$$\n我们可以用素数的对数来表示这些对数值，以便更清晰地看到其结构：\n$$\\ln 9 = \\ln(3^2) = 2\\ln 3$$\n$$\\ln 6 = \\ln(2 \\cdot 3) = \\ln 2 + \\ln 3$$\n所以，品质为：\n$$q(1, 8, 9) = \\frac{2\\ln 3}{\\ln 2 + \\ln 3}$$\n现在，我们计算其数值。使用自然对数的标准值：\n$\\ln 9 \\approx 2.197224577$\n$\\ln 6 \\approx 1.791759469$\n$$q(1, 8, 9) \\approx \\frac{2.197224577}{1.791759469} \\approx 1.22629478$$\n问题要求将最终答案四舍五入到 4 位有效数字。前四位有效数字是 $1.226$。第五位数字是 $2$，小于 $5$，所以我们向下舍入。\n品质的最终数值为 $1.226$。", "answer": "$$\n\\boxed{1.226}\n$$", "id": "3090088"}, {"introduction": "在上一个练习中，我们学会了如何计算一个三元组的品质。现在，让我们来探讨这个“品质”数值的实际意义。abc 猜想的核心正是关于那些品质异常高的三元组。这个练习 [@problem_id:3090052] 将引入“$\\varepsilon$-例外”三元组的正式定义，并要求你检验我们之前分析过的例子是否在给定的 $\\varepsilon$ 值下满足此标准，从而将单纯的计算与猜想的核心论断联系起来。", "problem": "令 $\\varepsilon0$，考虑 $abc$ 猜想的标准设定：正整数 $a$、$b$、$c$ 满足 $a+b=c$ 且 $\\gcd(a,b)=1$，其中 $\\gcd$ 表示最大公约数（GCD）。定义一个正整数 $n$ 的根基 $\\operatorname{rad}(n)$ 为 $n$ 的不同质因数之积。对于一个满足 $a+b=c$ 和 $\\gcd(a,b)=1$ 的三元组 $(a,b,c)$，定义其品质为 $q(a,b,c)=\\dfrac{\\ln c}{\\ln \\operatorname{rad}(abc)}$，其中 $\\ln$ 是自然对数。如果一个三元组满足 $c\\operatorname{rad}(abc)^{1+\\varepsilon}$，则称其为 $\\varepsilon$-例外三元组，根据对数的单调性，这等价于 $q(a,b,c)1+\\varepsilon$。\n\n仅使用这些定义以及对数和指数的基本性质，检验三元组 $(1,8,9)$ 对于 $\\varepsilon=0.01$ 是否是 $\\varepsilon$-例外的，并根据品质 $q$ 解释你的结论。作为最终答案，请给出品质 $q(1,8,9)$ 的精确表达式（不需要小数近似值）。", "solution": "问题陈述已经过验证，被认为是有效的。它在数论领域有科学依据，定义和数据齐全，问题清晰，客观且内部一致。该问题是将所给定义直接应用于一个具体的数值案例。\n\n题目要求我们判断三元组 $(a,b,c) = (1,8,9)$ 对于 $\\varepsilon=0.01$ 是否是 $\\varepsilon$-例外的，并求出其品质 $q(1,8,9)$。\n\n首先，我们验证该三元组是否满足 $abc$-三元组的条件。\n这些整数都是正数：$a=1$、$b=8$、$c=9$。\n求和条件必须成立：$a+b=c$。我们检验 $1+8=9$，正确。\n互质条件必须成立：$\\gcd(a,b)=1$。我们检验 $\\gcd(1,8)=1$，正确。\n因此，$(1,8,9)$ 是一个有效的 $abc$-三元组。\n\n接下来，我们计算乘积 $abc$ 的根基。该乘积为 $abc = 1 \\times 8 \\times 9 = 72$。\n为了求出根基 $\\operatorname{rad}(n)$，我们需要 $n$ 的不同质因数。$72$ 的质因数分解是 $2^3 \\times 3^2$。其不同质因数为 $2$ 和 $3$。\n因此，根基是这些不同质因数的乘积：\n$$\n\\operatorname{rad}(abc) = \\operatorname{rad}(72) = 2 \\times 3 = 6\n$$\n\n现在，我们可以使用给定的公式计算该三元组的品质 $q(a,b,c)$：\n$$\nq(a,b,c) = \\frac{\\ln c}{\\ln \\operatorname{rad}(abc)}\n$$\n将我们的三元组的值 $c=9$ 和 $\\operatorname{rad}(abc)=6$ 代入，我们得到：\n$$\nq(1,8,9) = \\frac{\\ln 9}{\\ln 6}\n$$\n这就是三元组 $(1,8,9)$ 品质的精确表达式。\n\n最后，我们必须判断这个三元组对于 $\\varepsilon = 0.01$ 是否是 $\\varepsilon$-例外的。根据定义，如果一个三元组的品质大于 $1+\\varepsilon$，则它是 $\\varepsilon$-例外的。\n所以，我们必须检验以下不等式是否成立：\n$$\nq(1,8,9)  1 + 0.01\n$$\n$$\n\\frac{\\ln 9}{\\ln 6}  1.01\n$$\n因为 $\\ln 6 > \\ln 1 = 0$，我们可以在不等式两边同乘以 $\\ln 6$ 而不改变不等号的方向：\n$$\n\\ln 9  1.01 \\times \\ln 6\n$$\n我们可以将 $1.01$ 写成分数 $\\frac{101}{100}$。\n$$\n\\ln 9  \\frac{101}{100} \\ln 6\n$$\n两边同乘以 $100$：\n$$\n100 \\ln 9  101 \\ln 6\n$$\n使用对数性质 $k \\ln x = \\ln(x^k)$：\n$$\n\\ln(9^{100})  \\ln(6^{101})\n$$\n因为自然对数函数 $\\ln x$ 在 $x  0$ 上是严格递增的，所以这个不等式等价于：\n$$\n9^{100}  6^{101}\n$$\n我们可以将右边重写为 $6^{101} = 6 \\times 6^{100}$。\n$$\n9^{100}  6 \\times 6^{100}\n$$\n两边同除以 $6^{100}$（这是一个正数）：\n$$\n\\frac{9^{100}}{6^{100}}  6\n$$\n$$\n\\left(\\frac{9}{6}\\right)^{100}  6\n$$\n$$\n\\left(\\frac{3}{2}\\right)^{100}  6\n$$\n让我们计算底数 $\\frac{3}{2} = 1.5$。我们需要检验是否 $(1.5)^{100}  6$。\n我们可以测试 $1.5$ 的小次方：\n$(1.5)^2 = 2.25$\n$(1.5)^4 = (2.25)^2 = 5.0625$\n$(1.5)^5 = (1.5)^4 \\times 1.5 = 5.0625 \\times 1.5 > 5 \\times 1.5 = 7.5$\n因为 $(1.5)^5 > 7.5$，且 $7.5 > 6$，我们已经确定 $(1.5)^5 > 6$。\n因为底数 $1.5$ 大于 $1$，所以函数 $f(x) = (1.5)^x$ 是递增的。由于 $100 > 5$，可得：\n$$\n\\left(\\frac{3}{2}\\right)^{100}  \\left(\\frac{3}{2}\\right)^5  6\n$$\n该不等式成立。因此，$q(1,8,9)  1.01$。\n\n结论：品质 $q(1,8,9) = \\frac{\\ln 9}{\\ln 6}$ 大于 $1+0.01$。根据定义，三元组 $(1,8,9)$ 对于 $\\varepsilon=0.01$ 是 $\\varepsilon$-例外的。", "answer": "$$\n\\boxed{\\frac{\\ln 9}{\\ln 6}}\n$$", "id": "3090052"}, {"introduction": "从分析单个三元组到进行更广泛、更系统的搜索，是理解 abc 猜想分布规律的关键一步。虽然检验个别案例能提供直观认识，但我们需要借助计算工具来感受所有 abc-三元组的全貌。这最后一个动手实践 [@problem_id:3090061] 将指导你设计一个算法，以寻找并分析某个上限内的所有三元组，这正是在模仿数学家们探索该猜想边界的实际工作。", "problem": "你需要实现一个完整的、可运行的程序，该程序枚举所有满足 $a+b=c$ 且 $c\\leq 1000$ 的互质正整数三元组 $\\left(a,b,c\\right)$，计算每个三元组的根数 $\\operatorname{rad}(abc)$ 和品质 $q$，然后针对给定的测试界限集合，汇总指定的指标。程序必须基于基本定义推导得出，并且在科学上是现实且内部一致的。枚举过程必须使用基于基础数论的、有原则的算法来完成。\n\n定义与基本事实：\n- 对于一个正整数 $n$，其质因数分解为 $n=\\prod_{i=1}^{k} p_i^{\\alpha_i}$，其中 $p_i$ 是不同的质数，$\\alpha_i$ 是正整数。\n- $n$ 的根数，记作 $\\operatorname{rad}(n)$，定义为 $n$ 的不同质因子的乘积：$\\operatorname{rad}(n)=\\prod_{i=1}^{k} p_i$。\n- 两个整数 $x$ 和 $y$ 的最大公约数 (GCD)，记作 $\\gcd(x,y)$，是能同时整除 $x$ 和 $y$ 的最大正整数。\n- 一个互质三元组 $\\left(a,b,c\\right)$ 是指满足 $\\gcd(a,b,c)=1$ 的三元组。\n- 对于满足 $a+b=c$ 的三元组，若 $\\gcd(a,b)=1$，则 $\\gcd(a,c)=\\gcd(a,a+b)=\\gcd(a,b)=1$ 且 $\\gcd(b,c)=\\gcd(b,a+b)=\\gcd(b,a)=1$。因此，在这种情况下，检查 $\\gcd(a,b)=1$ 足以确保 $\\gcd(a,b,c)=1$。\n- 根数对于互质整数具有积性：若 $\\gcd(m,n)=1$，则 $\\operatorname{rad}(mn)=\\operatorname{rad}(m)\\operatorname{rad}(n)$。因此，对于满足 $a+b=c$ 的互质三元组，有 $\\operatorname{rad}(abc)=\\operatorname{rad}(a)\\operatorname{rad}(b)\\operatorname{rad}(c)$。\n- 三元组的品质定义为 $q(a,b,c)=\\dfrac{\\ln c}{\\ln \\operatorname{rad}(abc)}$，其中 $\\ln$ 表示以 $e$ 为底的自然对数 (LN)。该比率的值与所选的对数底无关。\n\n算法要求：\n- 通过迭代 $c$（从 $3$ 到给定的界限 $c_{\\max}$），然后迭代 $a$（从 $1$ 到 $c-1$），并设置 $b=c-a$ 来枚举所有三元组。当且仅当 $\\gcd(a,b)=1$ 时，才包含该三元组。\n- 对于每个被包含的三元组，计算 $\\operatorname{rad}(abc)$ 和 $q(a,b,c)$。\n- 为高效计算所有 $n\\leq c_{\\max}$ 的 $\\operatorname{rad}(n)$，请使用基于质因数分解的确定性方法。例如，通过筛法预先计算每个整数（直到 $c_{\\max}$）的最小质因子 (SPF)，并用它来提取每个 $n$ 的不同质数。然后利用 $\\operatorname{rad}(abc)=\\operatorname{rad}(a)\\operatorname{rad}(b)\\operatorname{rad}(c)$。\n- 为测试套件中的每个界限 $c_{\\max}$ 汇总以下指标：\n  1. 找到的满足 $a+b=c$ 和 $c\\leq c_{\\max}$ 的互质三元组 $\\left(a,b,c\\right)$ 的总数。\n  2. 此类三元组中满足 $q(a,b,c)1$ 的数量。\n  3. 在该 $c_{\\max}$ 的三元组中达到的 $q(a,b,c)$ 的最大值，四舍五入到六位小数。如果某个界限没有找到任何三元组，则将此最大值定义为 $0$。\n\n测试套件：\n- 对 $c_{\\max}$ 使用以下界限：$3$、$10$、$30$ 和 $1000$。\n- 这些值共同构成了一个边界情况 ($c_{\\max}=3$)、两个从小到中等的情况 ($c_{\\max}=10$ 和 $c_{\\max}=30$) 以及指定的上界 ($c_{\\max}=1000$) 的测试。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个条目对应于按指定顺序的一个 $c_{\\max}$，并且本身是一个包含三个值的列表 $\\left[\\text{total\\_triples},\\ \\text{count\\_q\\_gt\\_1},\\ \\text{max\\_q\\_rounded}\\right]$。例如，输出的形状必须为 $\\left[[N_1,K_1,Q_1],[N_2,K_2,Q_2],[N_3,K_3,Q_3],[N_4,K_4,Q_4]\\right]$，其中每个 $N_i$ 和 $K_i$ 是整数，每个 $Q_i$ 是一个四舍五入到六位小数的浮点数。", "solution": "用户提供的问题已经过严格验证，被确定为科学上合理、定义明确且内部一致。它提出了一个植根于既定数论的清晰计算任务。因此，我们可以着手构建一个解决方案。\n\n该解决方案的实现将程序构建为两个主要阶段：一个用于高效计算根数的预计算阶段，以及一个用于枚举三元组和汇总指定指标的主阶段。\n\n### 阶段 1：根数的预计算\n\n一个正整数 $n$ 的根数，记作 $\\operatorname{rad}(n)$，是其不同质因子的乘积。对于一个素数分解为 $n=\\prod_{i=1}^{k} p_i^{\\alpha_i}$ 的正整数 $n$，其根数为 $\\operatorname{rad}(n)=\\prod_{i=1}^{k} p_i$。\n\n问题要求枚举 $c \\le c_{\\max}$ 的三元组 $(a,b,c)$，最高界限为 $c_{\\max}=1000$。这意味着整数 $a$、$b$ 和 $c$ 不会超过 $1000$。对每个三元组即时进行质因数分解来计算 $\\operatorname{rad}(a)$、$\\operatorname{rad}(b)$ 和 $\\operatorname{rad}(c)$ 在计算上是冗余的。一个更高效的策略是预计算并缓存范围 $[1, 1000]$ 内每个整数 $n$ 的根数。\n\n这个预计算通过两个步骤完成：\n1.  **最小质因子 (SPF) 筛法**：我们首先使用一种类似于 Sieve of Eratosthenes 的筛法算法，来填充一个数组 `spf`，其中 `spf[n]` 存储 $n$ 的最小质因子。这是通过从 $p=2$ 迭代到 $\\sqrt{1000}$ 来完成的。对于每个质数 $p$，我们遍历其倍数 $j$，如果其最小质因子尚未确定，则设置 `spf[j]`$=p$。这以大约 $O(c_{\\max} \\log \\log c_{\\max})$ 的时间复杂度填充了直到 $1000$ 的所有整数的 `spf` 数组。\n2.  **根数计算**：有了 `spf` 数组，我们可以高效地计算每个整数 $n$ 的根数。我们创建一个 `rad_values` 数组，其中 `rad_values[n]` 存储 $\\operatorname{rad}(n)$。我们建立基准情况 $\\operatorname{rad}(1)=1$。对于任何整数 $n>1$，我们可以使用基于其最小质因子 $p = \\mathrm{spf}[n]$ 和整数 $m=n/p$ 的以下递推关系来找到其根数：\n    $$ \\operatorname{rad}(n) = \\begin{cases} \\operatorname{rad}(m)  \\text{如果 } p \\mid \\operatorname{rad}(m) \\\\ p \\cdot \\operatorname{rad}(m)  \\text{否则} \\end{cases} $$\n    这允许我们通过从 $n=2$ 到 $1000$ 的单次高效遍历来计算和存储所有必需的根数值。\n\n### 阶段 2：枚举与指标汇总\n\n问题的核心是枚举三元组并为测试套件中的界限 $c_{\\max} \\in \\{3, 10, 30, 1000\\}$ 计算指标。为避免冗余计算，我们采用累积汇总策略。我们从 $c=3$ 到 $1000$ 执行单次枚举遍历，同时维护所需指标的运行总计。当迭代变量 $c$ 达到指定的界限之一时，我们记录这些指标的当前状态。\n\n枚举和汇总算法如下：\n1.  初始化累积指标计数器：`total_triples_count`$=0$，`q_gt_1_count`$=0$，以及 `max_q`$=0.0$。\n2.  从 $3$ 到 $1000$ 迭代 $c$。\n3.  对于每个 $c$，按照问题规范从 $1$ 到 $c-1$ 迭代 $a$。令 $b=c-a$。请注意，由于 $c \\ge 3$，$a$ 和 $b$ 始终为正数。\n4.  如果一个三元组 $(a,b,c)$ 是互质的，则将其包含在内。问题正确地指出，对于 $a+b=c$，条件 $\\gcd(a,b)=1$ 足以确保 $a,b,c$ 两两互质，从而 $\\gcd(a,b,c)=1$。我们使用标准的欧几里得算法进行 GCD 检查。\n5.  如果 $\\gcd(a,b)=1$，我们就找到了一个有效的三元组。我们更新 `total_triples_count`。\n6.  三元组的品质由 $q(a,b,c)=\\dfrac{\\ln c}{\\ln \\operatorname{rad}(abc)}$ 给出，其中 $\\ln$ 是自然对数。因为 $a,b,c$ 两两互质，根数是积性的：$\\operatorname{rad}(abc) = \\operatorname{rad}(a)\\operatorname{rad}(b)\\operatorname{rad}(c)$。各个根数值从我们预计算的 `rad_values` 数组中检索。分母永远不为零，因为 $c \\ge 3$ 意味着 $\\operatorname{rad}(abc) > 1$。\n7.  我们将计算出的品质 $q$ 与 $1$ 进行比较。如果 $q1$，我们增加 `q_gt_1_count`。我们还更新 `max_q = \\max(\\text{max\\_q}, q)`。\n8.  在完成给定 $c$ 的内循环后，我们检查 $c$ 是否与指定的界限 $\\{3, 10, 30, 1000\\}$ 之一匹配。如果匹配，我们将 `total_triples_count`、`q_gt_1_count` 和 `max_q` 的当前值存储为该界限的结果。\n9.  循环完成后，对每个界限收集的指标进行格式化。每个界限的最大品质值四舍五入到六位小数。然后将最终的结果列表转换为精确指定的字符串格式。对于任何没有找到三元组的界限，计数指标将为 $0$，`max_q` 将保持其初始值 $0.0$，这满足了问题的要求。\n\n这种有原则的方法通过遵循数论的基本定义来确保正确性，并通过预计算和累积汇总策略来确保效率。", "answer": "```python\nimport math\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Enumerates coprime triples (a,b,c) with a+b=c, computes their quality q,\n    and aggregates metrics for specified bounds on c, following the problem's\n    definitions and algorithmic requirements.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_bounds = [3, 10, 30, 1000]\n    c_max_global = max(test_bounds)\n\n    # --- Phase 1: Precomputation of Radicals ---\n    \n    # Precompute smallest prime factors (SPF) using a sieve.\n    # spf[i] stores the smallest prime factor of integer i.\n    spf = list(range(c_max_global + 1))\n    for i in range(2, int(math.sqrt(c_max_global)) + 1):\n        if spf[i] == i:  # i is a prime\n            # Mark multiples of i.\n            for j in range(i * i, c_max_global + 1, i):\n                if spf[j] == j:  # Only update if not already updated by a smaller prime.\n                    spf[j] = i\n\n    # Precompute radicals for all numbers up to c_max_global.\n    # rad_values[n] stores the radical of n, which is the product of its distinct prime factors.\n    rad_values = [0] * (c_max_global + 1)\n    rad_values[1] = 1\n    for n in range(2, c_max_global + 1):\n        p = spf[n]\n        m = n // p\n        # Use a dynamic programming relation: rad(n) is related to rad(n/p).\n        # If p is already a factor of rad(m), then rad(n) = rad(m).\n        # Otherwise, rad(n) = rad(m) * p.\n        if rad_values[m] % p == 0:\n            rad_values[n] = rad_values[m]\n        else:\n            rad_values[n] = rad_values[m] * p\n\n    # --- Phase 2: Enumeration and Aggregation ---\n\n    # Dictionary to store final results for each test bound.\n    metrics = {}\n    \n    # Cumulative metrics updated as we iterate through c.\n    total_triples_count = 0\n    q_gt_1_count = 0\n    max_q = 0.0\n\n    # Use an iterator to track which test bound we are aiming for next.\n    test_bounds_iter = iter(sorted(test_bounds))\n    next_bound = next(test_bounds_iter, None)\n\n    # Main enumeration loop over c.\n    for c in range(3, c_max_global + 1):\n        # Per problem specification, iterate a from 1 to c-1.\n        # This counts (a,b,c) and (b,a,c) as distinct triples if a != b.\n        for a in range(1, c):\n            b = c - a\n            \n            # Condition for a valid coprime triple: gcd(a,b) = 1.\n            if math.gcd(a, b) == 1:\n                total_triples_count += 1\n                \n                # For pairwise coprime a,b,c, rad(abc) = rad(a)rad(b)rad(c).\n                rad_abc = rad_values[a] * rad_values[b] * rad_values[c]\n                \n                # Quality q = log(c) / log(rad(abc)).\n                # rad_abc  1 is guaranteed for c = 3.\n                q = math.log(c) / math.log(rad_abc)\n                \n                if q  1:\n                    q_gt_1_count += 1\n                \n                if q  max_q:\n                    max_q = q\n        \n        # If the current c matches a test bound, store the cumulative metrics.\n        if c == next_bound:\n            metrics[c] = [total_triples_count, q_gt_1_count, max_q]\n            next_bound = next(test_bounds_iter, None)\n            if next_bound is None:\n                # All bounds have been processed, we can exit early.\n                break\n\n    # --- Final Output Formatting ---\n    \n    final_results_list = []\n    for bound in test_bounds:\n        if bound in metrics:\n            N, K, Q = metrics[bound]\n            Q_rounded = round(Q, 6)\n            final_results_list.append([N, K, Q_rounded])\n        else:\n            # This case handles bounds not reached by the loop (e.g.,  3).\n            # The problem's rule: if no triples are found, metrics are 0.\n            final_results_list.append([0, 0, 0.0])\n\n    # Print the results in the exact specified format: [[...],[...],...]\n    print(f\"[{','.join(map(str, final_results_list))}]\")\n\nsolve()\n```", "id": "3090061"}]}