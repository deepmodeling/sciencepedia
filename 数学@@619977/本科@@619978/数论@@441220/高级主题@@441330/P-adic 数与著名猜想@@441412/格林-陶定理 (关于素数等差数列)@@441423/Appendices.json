{"hands_on_practices": [{"introduction": "格林-陶定理保证了任意长度的素数等差数列的存在，但这并不意味着它们的结构是完全随机的。这个练习将引导你使用基础的模运算来揭示一个深刻的“局部约束”：任何由大于 $3$ 的素数组成的 $3$ 项等差数列，其公差都必须遵循一个特定的规律。通过这个练习 [@problem_id:3091314]，你将亲手发现为何我们能观察到某些模式，而另一些则永远不会出现。", "problem": "设 $p_{1},p_{2},p_{3}$ 是一个等差数列中的三个质数（等差数列（AP）意为 $p_{2}-p_{1}=p_{3}-p_{2}$）。格林-陶定理断言，质数中包含任意长度的等差数列，但当所有项都是质数时，局部的同余阻碍仍然限制了可能的公差。请从第一性原理（质数、等差数列和基本模算术的定义）出发，解决以下问题：\n\n1. 仅使用定义，验证 $3,5,7$ 是一个由质数构成的三项等差数列。\n\n2. 设 $p,p+d,p+2d$ 是一个由质数构成的三项等差数列，其中所有三项都严格大于 $3$。推导公差 $d$ 在模 $2$ 和模 $3$ 下必须满足的同余条件，以确保这三项对于这些模都不是合数。由此得出关于 $d$ 的一个结构性限制。\n\n3. 确定满足你在第2部分中推导出的限制的最小正整数 $d$，并给出一个使用此最小 $d$ 且所有项均大于 $3$ 的三项质数等差数列 $p,p+d,p+2d$ 的具体例子。\n\n你的最终答案必须是第3部分中求得的最小正公差 $d$ 的数值；无需四舍五入。", "solution": "该问题要求分析由质数构成的三项等差数列。验证过程确认了该问题具有科学依据、问题设定良好、客观且无逻辑缺陷。我们可以按顺序解决每个部分。\n\n第1部分：验证等差数列 $3, 5, 7$。\n等差数列（AP）是一个数列，其中连续项之间的差是恒定的。设该数列为 $p_1, p_2, p_3$。要使其成为等差数列，必须满足 $p_2 - p_1 = p_3 - p_2$。\n给定的数列是 $p_1=3$, $p_2=5$, $p_3=7$。\n首先，我们验证每一项都是质数。\n- 数字 $3$ 是质数，因为它的正因数只有 $1$ 和 $3$。\n- 数字 $5$ 是质数，因为它的正因数只有 $1$ 和 $5$。\n- 数字 $7$ 是质数，因为它的正因数只有 $1$ 和 $7$。\n接下来，我们验证等差数列的性质。公差计算如下：\n$p_2 - p_1 = 5 - 3 = 2$。\n$p_3 - p_2 = 7 - 5 = 2$。\n因为差相等，所以数列 $3, 5, 7$ 是一个公差为 $d=2$ 的等差数列。因此，它是一个由质数构成的三项等差数列。\n\n第2部分：推导公差 $d$ 必须满足的同余条件。\n我们有一个由质数构成的三项等差数列 $p, p+d, p+2d$，其中每一项都严格大于 $3$。设这三个质数为 $p_1=p$, $p_2=p+d$, $p_3=p+2d$。\n所有项都是大于 $3$ 的质数这一条件，对公差 $d$ 施加了很强的约束。\n\n模 $2$ 条件：\n由于 $p, p+d, p+2d$ 都是大于 $3$ 的质数，它们必须都是奇数。唯一的偶质数是 $2$，它不大于 $3$。\n第一项 $p$ 是一个大于 $3$ 的质数，所以 $p$ 必须是奇数。这可以写作 $p \\equiv 1 \\pmod{2}$。\n第二项 $p+d$ 也必须是奇数。所以 $p+d \\equiv 1 \\pmod{2}$。代入 $p \\equiv 1 \\pmod{2}$，我们得到 $1+d \\equiv 1 \\pmod{2}$，这意味着 $d \\equiv 0 \\pmod{2}$。因此，公差 $d$ 必须是偶数。\n我们来检查第三项 $p+2d$。如果 $d$ 是偶数，则 $d=2k$（对于某个整数 $k$）。那么 $p+2d = p+2(2k) = p+4k$。由于 $p$ 是奇数，所以 $p+4k$ 也是奇数。这与 $p+2d$ 是一个大于 $3$ 的质数是一致的。条件 $d \\equiv 0 \\pmod{2}$ 是必需的。\n\n模 $3$ 条件：\n项 $p, p+d, p+2d$ 是严格大于 $3$ 的质数。这意味着它们都不能被 $3$ 整除。\n所以，$p \\not\\equiv 0 \\pmod{3}$，$p+d \\not\\equiv 0 \\pmod{3}$，以及 $p+2d \\not\\equiv 0 \\pmod{3}$。\n我们来考虑公差 $d$ 模 $3$ 的可能值。\n情况1：$d \\equiv 1 \\pmod{3}$。\n该数列的三项模 $3$ 分别为 $p$，$p+1$ 和 $p+2$。集合 $\\{p, p+1, p+2\\}$ 构成一个模 $3$ 的完全剩余系。这意味着无论 $p$ 的值是多少，这三项中必有一项同余于 $0 \\pmod{3}$。\n- 如果 $p \\equiv 1 \\pmod{3}$，那么 $p+2d \\equiv p+2(1) \\equiv 1+2 = 3 \\equiv 0 \\pmod{3}$。\n- 如果 $p \\equiv 2 \\pmod{3}$，那么 $p+d \\equiv p+1 \\equiv 2+1 = 3 \\equiv 0 \\pmod{3}$。\n（注意 $p \\not\\equiv 0 \\pmod{3}$，因为 $p$ 是一个大于 $3$ 的质数。）\n在任一子情况下，数列中都有一项是 $3$ 的倍数。由于所有项都严格大于 $3$，该项必为合数。这与所有项都是质数的前提相矛盾。因此，必须有 $d \\not\\equiv 1 \\pmod{3}$。\n\n情况2：$d \\equiv 2 \\pmod{3}$。\n该数列的三项模 $3$ 分别为 $p$，$p+2$ 和 $p+2d \\equiv p+2(2) = p+4 \\equiv p+1 \\pmod{3}$。\n这些项模 $3$ 的集合是 $\\{p, p+1, p+2\\}$，这同样构成一个模 $3$ 的完全剩余系。\n- 如果 $p \\equiv 1 \\pmod{3}$，那么 $p+d \\equiv p+2 \\equiv 1+2 = 3 \\equiv 0 \\pmod{3}$。\n- 如果 $p \\equiv 2 \\pmod{3}$，那么 $p+2d \\equiv p+1 \\equiv 2+1 = 3 \\equiv 0 \\pmod{3}$。\n同样，必有一项是 $3$ 的倍数且大于 $3$，这是一个矛盾。因此，必须有 $d \\not\\equiv 2 \\pmod{3}$。\n\n情况3：$d \\equiv 0 \\pmod{3}$。\n唯一剩下的可能性是 $d$ 是 $3$ 的倍数。\n该数列的三项模 $3$ 分别为 $p$，$p+0$ 和 $p+2(0)$。也就是说，所有三项都同余于 $p \\pmod{3}$。\n没有任何项能被 $3$ 整除的条件，简化为单一条件 $p \\not\\equiv 0 \\pmod{3}$。这一点已经由 $p$ 是一个严格大于 $3$ 的质数这一事实所保证。\n因此，为了使一个所有项都大于 $3$ 的三项质数等差数列存在，公差 $d$ 必须能被 $3$ 整除。所以，$d \\equiv 0 \\pmod{3}$ 是一个必要条件。\n\n$d$ 的结构性限制：\n我们已经推导出两个必要条件：\n1. $d \\equiv 0 \\pmod{2}$\n2. $d \\equiv 0 \\pmod{3}$\n由于 $2$ 和 $3$ 互质，这两个同余式可以使用中国剩余定理合并。一个数能同时被 $2$ 和 $3$ 整除，当且仅当它能被它们的乘积 $2 \\times 3 = 6$ 整除。\n因此，对 $d$ 的结构性限制是它必须是 $6$ 的倍数。这可以写作 $d \\equiv 0 \\pmod{6}$。\n\n第3部分：确定最小正整数 $d$ 并提供一个例子。\n$d$ 的必要条件是它必须是 $6$ 的正倍数。$d$ 的可能值集合是 $\\{6, 12, 18, \\dots\\}$。满足此条件的最小正整数是 $d=6$。\n\n现在，我们必须给出一个公差 $d=6$ 且所有项都大于 $3$ 的三项质数等差数列 $p, p+d, p+2d$ 的具体例子。该数列的形式为 $p, p+6, p+12$。我们需要找到一个质数 $p > 3$，使得 $p+6$ 和 $p+12$ 也都是质数。\n我们可以从大于 $3$ 的最小质数开始，测试 $p$ 的质数值。\n- 设 $p=5$。数列为 $5, 5+6, 5+12$，即 $5, 11, 17$。这三个数（$5, 11, 17$）都是质数，且都大于 $3$。这是一个有效的例子。\n- 为完整起见，我们检查下一个质数。设 $p=7$。数列为 $7, 7+6, 7+12$，即 $7, 13, 19$。这三个数都是质数。这是另一个有效的例子。\n- 我们检查 $p=11$。数列为 $11, 11+6, 11+12$，即 $11, 17, 23$。这三个数都是质数。\n- 我们检查 $p=13$。数列为 $13, 13+6, 13+12$，即 $13, 19, 25$。这里，$25 = 5^2$ 是合数，所以这不是一个质数等差数列。\n\n题目要求一个具体例子。我们找到的第一个例子 $5, 11, 17$ 就足够了。\n满足所推导限制的最小正整数 $d$ 是 $6$。", "answer": "$$\\boxed{6}$$", "id": "3091314"}, {"introduction": "在上一个练习中，我们发现了素数等差数列存在的局部约束。那么，数学家们在证明格林-陶定理时是如何系统性地处理这些约束的呢？本练习将向你介绍证明中的一个关键预备步骤——“W-trick”。通过将研究对象限制在特定的剩余类中，我们可以有效地“筛除”由小素因子引起的确定性模式，从而使研究的数集表现得更像一个随机集合 [@problem_id:3091310]。这个练习让你通过具体计算，亲身体验这一高级技巧。", "problem": "在Green–Tao框架中，为了研究素数中的等差数列，我们首先通过所谓的$W$-技巧来消除小的素数可除性障碍。固定一个整数参数 $w \\geq 2$ 并定义\n$$\nW = \\prod_{p \\leq w} p\n$$\n其中该乘积遍历所有满足 $p \\leq w$ 的素数 $p$。对于一个剩余 $b \\in \\{0,1,\\dots,W-1\\}$，我们称 $b$ 是可行的，当且仅当 $\\gcd(b,W)=1$。可行性这一概念的动机源于以下观察：如果 $\\gcd(b,W) \\neq 1$，那么每个形如 $Wn+b$ 的整数都能被 $W$ 的一个素因子整除，因此是合数，所以这样的剩余类除了可能包含一个无关紧要的小素数外，不能包含其他素数。\n\n从这些定义以及素数、最大公约数和模算术的基本性质出发，计算当 $w=5$ 时的 $W$，并列出所有能使形如 $Wn+b$ 的整数可能为素数的模 $W$ 可行剩余 $b$。将你的最终答案表示为一个单行矩阵，其中第一个元素是 $W$，其余元素是按升序排列的可行剩余。", "solution": "问题要求在参数 $w$ 设为 $5$ 的特定情况下，计算整数参数 $W$ 并找出所有模 $W$ 的可行剩余 $b$。定义和条件已在问题陈述中给出。\n\n首先，我们来计算 $W$。给出的定义是\n$$\nW = \\prod_{p \\leq w} p\n$$\n其中乘积是对所有小于或等于 $w$ 的素数 $p$ 进行的。问题指定 $w=5$。满足条件 $p \\leq 5$ 的素数是 $2$、$3$ 和 $5$。因此，我们可以将 $W$ 计算为这些素数的乘积：\n$$\nW = 2 \\times 3 \\times 5 = 30\n$$\n\n其次，我们必须找出所有模 $W$ 的可行剩余 $b$。一个剩余 $b \\in \\{0, 1, \\dots, W-1\\}$ 被定义为可行的，当且仅当 $\\gcd(b, W) = 1$。使用我们计算出的值 $W=30$，这个条件变为：\n$$\n\\gcd(b, 30) = 1, \\quad \\text{for } b \\in \\{0, 1, \\dots, 29\\}\n$$\n为了使 $b$ 和 $30$ 的最大公约数为 $1$，$b$ 必须不与 $30$ 共享任何素因子。$W=30$ 的素因子分解是 $2 \\times 3 \\times 5$。因此，一个剩余 $b$ 是可行的，当且仅当它不能被 $2$ 整除，不能被 $3$ 整除，也不能被 $5$ 整除。\n\n我们现在系统地检查指定范围 $\\{0, 1, \\dots, 29\\}$ 内的每个整数 $b$。\n满足 $1 \\leq b  W$ 和 $\\gcd(b,W)=1$ 的整数 $b$ 的集合是模 $W$ 整数乘法群的元素，记作 $(\\mathbb{Z}/W\\mathbb{Z})^\\times$。这类元素的数量由欧拉函数 $\\phi(W)$ 给出。对于 $W=30$，我们可以这样计算：\n$$\n\\phi(30) = \\phi(2 \\times 3 \\times 5) = \\phi(2) \\times \\phi(3) \\times \\phi(5) = (2-1)(3-1)(5-1) = 1 \\times 2 \\times 4 = 8\n$$\n这证实了在范围 $1 \\leq b \\leq 29$ 内恰好有 $8$ 个可行剩余。注意，对于 $b=0$，$\\gcd(0, 30) = 30 \\neq 1$，所以 $0$ 不是一个可行剩余。\n\n我们现在列出在范围 $1 \\leq b \\leq 29$ 内与 $30$ 互素的整数 $b$：\n- $b=1$: $\\gcd(1, 30) = 1$。可行。\n- $b=2, 3, 4, 5, 6$: 都与 $30$ 有公因子。不可行。\n- $b=7$: 与 $30$ 没有公因子。可行。\n- $b=8, 9, 10$: 不可行。\n- $b=11$: 与 $30$ 没有公因子。可行。\n- $b=12$: 不可行。\n- $b=13$: 与 $30$ 没有公因子。可行。\n- $b=14, 15, 16$: 不可行。\n- $b=17$: 与 $30$ 没有公因子。可行。\n- $b=18$: 不可行。\n- $b=19$: 与 $30$ 没有公因子。可行。\n- $b=20, 21, 22$: 不可行。\n- $b=23$: 与 $30$ 没有公因子。可行。\n- $b=24, 25, 26, 27, 28$: 不可行。\n- $b=29$: 与 $30$ 没有公因子。可行。\n\n因此，所有可行剩余 $b$ 的集合是 $\\{1, 7, 11, 13, 17, 19, 23, 29\\}$。\n\n问题要求最终答案为一个单行矩阵，其中第一个元素是 $W$，后续元素是按升序排列的可行剩余。综合我们的结果，我们得到 $W=30$ 和可行剩余的有序列表。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n30   1  7  11  13  17  19  23  29\n\\end{pmatrix}\n}\n$$", "id": "3091310"}, {"introduction": "在探索了理论约束和证明技巧之后，是时候去寻找这些神秘的素数等差数列了。这个练习将带领你从理论走向计算实践。通过设计并实现一个算法 [@problem_id:3091302]，你将能够精确地计算出在给定范围内 $3$ 项素数等差数列的数量。这不仅能证实这些理论上的对象确实存在，还能让你对它们的稀有程度有一个直观的感受。", "problem": "设 $A$ 是前 $N$ 个正整数的集合，$A = \\{1,2,\\dots,N\\}$。一个三项等差数列是一个有序三元组 $(a, a+d, a+2d)$，其中 $a \\in \\mathbb{N}$，$d \\in \\mathbb{N}$，且 $d  0$。一个数 $p \\in \\mathbb{N}$ 是素数，如果 $p \\geq 2$ 且 $p$ 的正因数只有 $1$ 和 $p$。\n\n关于素数等差数列的 Green-Tao 定理指出，素数集合中包含任意长度的等差数列。在本问题中，您将解决一个受此定理启发的有限范围实例：对于给定的 $N$，计算包含在集合 $\\{1,2,\\dots,N\\}$ 中且 $a$、$a+d$ 和 $a+2d$ 均为素数的三项等差数列 $(a, a+d, a+2d)$ 的数量。\n\n从上述基本定义出发，设计并实现一个算法，对于每个指定的 $N$，计算满足以下条件的三元组 $(a, a+d, a+2d)$ 的数量：\n- $a$、$a+d$ 和 $a+2d$ 都是素数，\n- $a \\in \\{1,2,\\dots,N\\}$，\n- $a+d \\in \\{1,2,\\dots,N\\}$，\n- $a+2d \\in \\{1,2,\\dots,N\\}$，\n- $d \\in \\mathbb{N}$ 且 $d  0$。\n\n计算必须精确且确定地进行，不得使用启发式捷径，并且必须依赖于素数和等差数列的第一性原理性质。您的程序应使用提供的 $N$ 值测试套件，并以整数形式生成计数结果。\n\n测试套件（需要评估的 $N$ 值）：\n- $N = 5$，\n- $N = 7$，\n- $N = 30$，\n- $N = 100$，\n- $N = 1000$。\n\n最终输出规范：\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，顺序与测试套件中 $N$ 的值（即 $N = 5, 7, 30, 100, 1000$）相同。例如，输出形式应为 $[r_1,r_2,r_3,r_4,r_5]$，其中每个 $r_i$ 是对应 $N$ 的三项素数等差数列的整数计数。", "solution": "用户提供的问题已经过分析，被认为是有效的。该问题在数论方面有科学依据，问题陈述清晰，约束条件一致，并以客观的数学语言表述。其解可以被确定性地计算出来。\n\n### 问题形式化\n目标是计算三项等差数列 $(a, a+d, a+2d)$ 的数量，其中所有三项都是素数，并且包含在前 $N$ 个正整数的集合 $\\{1, 2, \\dots, N\\}$ 中。约束条件如下：\n1. $a$、$a+d$ 和 $a+2d$ 均为素数。\n2. $a \\in \\{1, 2, \\dots, N\\}$，$a+d \\in \\{1, 2, \\dots, N\\}$，且 $a+2d \\in \\{1, 2, \\dots, N\\}$。\n3. 公差 $d$ 为正整数，$d  0$。\n\n条件 $a+2d \\leq N$，结合 $a  0$ 和 $d  0$，自动确保了 $a$ 和 $a+d$ 也包含在集合 $\\{1, 2, \\dots, N\\}$ 内。\n\n### 算法策略\n解决此问题的直接且精确的算法包括两个主要阶段：\n1.  **生成素数：** 高效地找出上限为 $N$ 的所有素数。这种预计算允许对范围内的任何数字进行常数时间素性测试。\n2.  **系统性搜索：** 遍历生成的素数，以识别所有可以作为有效等差数列前两项的素数对，然后验证第三项。\n\n### 步骤 1：通过埃拉托斯特尼筛法（Sieve of Eratosthenes）生成素数\n生成上限为 $N$ 的所有素数的最合适算法是埃拉托斯特尼筛法。该方法效率很高，时间复杂度约为 $O(N \\log \\log N)$。\n\n其过程如下：\n- 创建一个大小为 $N+1$ 的布尔数组 `is_prime`，并将从索引 $2$ 到 $N$ 的所有条目初始化为 `true`。将索引 $0$ 和 $1$ 标记为 `false`。\n- 遍历从 $2$ 到 $\\sqrt{N}$ 的数字 $p$。\n- 如果 `is_prime[p]` 为 `true`，则表示 $p$ 是一个素数。对于每个这样的素数 $p$，遍历其倍数（从 $p^2$ 开始），并通过将 `is_prime[p*p]`、`is_prime[p*p + p]` 等设置为 `false` 来将它们标记为非素数。\n\n筛法完成后，如果 $k$ 是素数，则 `is_prime[k]` 将为 `true`，否则为 `false`，从而为我们范围内的素性测试提供了 $O(1)$ 的查找时间。然后，使用此布尔数组生成一个小于或等于 $N$ 的所有素数的有序列表，我们可以将其表示为 $P_N$。\n\n### 步骤 2：搜索等差数列\n利用素数列表 $P_N$ 和 `is_prime` 数组，我们可以系统地搜索所有符合条件的三项等差数列。设这样一个数列为 $(p_1, p_2, p_3)$。我们可以通过找到它的前两项来确定它。\n\n该算法通过遍历列表 $P_N$ 中所有满足 $p_i  p_j$ 的有序素数对 $(p_i, p_j)$ 来进行。\n- 设数列的第一项为 $a = p_i$。\n- 设第二项为 $a+d = p_j$。\n- 由此，公差被唯一确定为 $d = p_j - p_i$。由于我们确保了 $p_i  p_j$，条件 $d > 0$ 自动满足。\n- 数列的第三项则必须是 $a+2d = p_j + d = p_j + (p_j - p_i) = 2p_j - p_i$。设这个候选的第三项为 $p_k$。\n\n对于每一对 $(p_i, p_j)$，我们计算 $p_k$ 并检查它是否构成一个有效的数列：\n1.  **范围检查：** 我们必须验证 $p_k \\leq N$。如果此条件不满足，则第三项超出了允许的集合范围。\n2.  **素性检查：** 我们必须验证 $p_k$ 是一个素数。这可以通过检查 `is_prime[p_k]` 在常数时间内完成。\n\n如果两个条件都满足，则三元组 $(p_i, p_j, p_k)$ 是一个有效的三项素数等差数列。每找到这样一个三元组，我们就将计数器加一。\n\n在搜索过程中可以进行优化。由于素数列表 $P_N$ 是有序的，对于固定的第一项 $p_i$，当第二项 $p_j$ 增加时，第三项 $p_k = 2p_j - p_i$ 也会增加。如果我们找到了一个 $p_j$ 使得 $p_k > N$，那么（对于同一个 $p_i$）任何后续的第二项选择也将导致第三项大于 $N$。因此，我们可以中断内层循环，继续处理下一个 $p_i$。\n\n此外，可以证明最小的三项素数等差数列是 $(3, 5, 7)$。这要求 $N \\geq 7$。对于任何 $N  7$，计数为零。这可以作为一个基本情况来处理。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef count_progressions(N: int) - int:\n    \"\"\"\n    Counts the number of 3-term arithmetic progressions of primes up to N.\n\n    A 3-term arithmetic progression is (a, a+d, a+2d) where a  0, d  0,\n    and all three terms are prime and less than or equal to N.\n    \"\"\"\n    # The smallest 3-term AP of primes is (3, 5, 7), which requires N = 7.\n    if N  7:\n        return 0\n\n    # Step 1: Generate primes up to N using the Sieve of Eratosthenes.\n    # is_prime[i] will be True if i is prime, False otherwise.\n    is_prime = np.ones(N + 1, dtype=bool)\n    is_prime[0] = is_prime[1] = False\n    for p in range(2, int(np.sqrt(N)) + 1):\n        if is_prime[p]:\n            # Mark all multiples of p (starting from p*p) as not prime.\n            is_prime[p * p::p] = False\n\n    # Step 2: Extract the prime numbers into a sorted list.\n    primes = np.where(is_prime)[0]\n\n    # Step 3: Iterate through pairs of primes to find progressions.\n    count = 0\n    num_primes = len(primes)\n    \n    # We can skip p1=2 because (2, 2+d, 2+2d) cannot be an all-prime\n    # progression for d0. If d is odd, 2+d is odd but 2+2d=2(1+d) is even  2.\n    # If d is even, 2+d is even  2. Thus the first term must be an odd prime.\n    start_index = 1 # Start from prime 3.\n    \n    for i in range(start_index, num_primes):\n        for j in range(i + 1, num_primes):\n            p1 = primes[i]\n            p2 = primes[j]\n            \n            # The first two terms p1 and p2 define the progression.\n            # a = p1, a+d = p2  = d = p2 - p1\n            # The third term is a+2d = p2 + d.\n            d = p2 - p1\n            p3 = p2 + d\n\n            # Since the primes list is sorted, if p3  N, all subsequent\n            # p3 for this p1 will also be  N. We can break the inner loop.\n            if p3  N:\n                break\n            \n            # Check if the third term is also prime using our sieve.\n            if is_prime[p3]:\n                # Found a valid 3-term prime arithmetic progression.\n                count += 1\n    \n    return count\n\ndef solve():\n    \"\"\"\n    Main function to run the computation for the specified test suite\n    and print the results in the required format.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [5, 7, 30, 100, 1000]\n\n    results = []\n    for n_val in test_cases:\n        # Calculate the result for each value of N.\n        result = count_progressions(n_val)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\n# Execute the solver.\nsolve()\n```", "id": "3091302"}]}