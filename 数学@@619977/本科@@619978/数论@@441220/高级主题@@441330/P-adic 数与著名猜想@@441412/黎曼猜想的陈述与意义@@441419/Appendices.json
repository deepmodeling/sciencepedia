{"hands_on_practices": [{"introduction": "黎曼zeta函数 $\\zeta(s)$ 在其收敛域 $\\Re(s) \\gt 1$ 内被定义为一个无穷级数。然而，在任何实际计算中，我们都只能使用有限项的部分和来近似其值。这就自然引出了一个核心问题：这个近似的精度如何？本练习将指导你使用微积分中的一个标准技巧——积分判别法——来推导一个具体的误差界。通过这个过程，你不仅能练习分析定义 $\\zeta(s)$ 的级数的收敛性，还能掌握在解析数论中控制无穷和与积分之间误差的基本方法。[@problem_id:3093088]", "problem": "设$\\zeta(\\sigma)$表示实数$\\sigma>1$时的黎曼zeta函数，由绝对收敛级数$\\zeta(\\sigma)=\\sum_{n=1}^{\\infty} n^{-\\sigma}$定义。在研究黎曼猜想（RH）时，一个核心步骤是有效地控制半平面$\\operatorname{Re}(s)>1$内的$\\zeta(s)$，以证明解析延拓的合理性，并建立将$\\zeta(s)$与素数计数函数联系起来的围线积分。考虑截断和\n$$S_{N}(\\sigma)=\\sum_{n=1}^{N} n^{-\\sigma},$$\n并定义其尾项（截断误差）\n$$R_{N}(\\sigma)=\\zeta(\\sigma)-S_{N}(\\sigma)=\\sum_{n=N+1}^{\\infty} n^{-\\sigma}.$$\n仅使用$\\zeta(\\sigma)$的定义、当$\\sigma>1$时$x^{-\\sigma}$的单调性，以及一个针对正项递减函数的标准积分比较法，导出一个闭式上界$B(\\sigma,N)$，使得$R_{N}(\\sigma)\\leq B(\\sigma,N)$，该上界是关于$\\sigma$和$N$的显式表达式。然后，将情况特殊化至$\\sigma=2$，并确定最小整数$N$，使得该界保证\n$$\\left|\\zeta(2)-\\sum_{n=1}^{N} \\frac{1}{n^{2}}\\right|\\leq 10^{-6}.$$\n将该最小整数$N$作为你的最终答案。在你的推导过程中，简要说明为什么在讨论黎曼猜想（RH）的重要性时，在半平面$\\operatorname{Re}(s)>1$内的这种有效界是相关的。除了选择满足所推导不等式的最小整数$N$之外，不需要进行其他舍入。", "solution": "该问题被评估为有效。这是一个在初等分析和数论领域中提法恰当、具有科学依据的问题。它是自洽的、客观的，并且没有任何科学或数学上的缺陷。\n\n该问题要求导出黎曼zeta函数级数尾项的一个上界，然后利用这个界来找到一个特定的截断数$N$。\n\n设$\\sigma > 1$为一个实数。黎曼zeta函数定义为$\\zeta(\\sigma) = \\sum_{n=1}^{\\infty} n^{-\\sigma}$。级数前$N$项之后的尾项由下式给出\n$$ R_{N}(\\sigma) = \\zeta(\\sigma) - S_{N}(\\sigma) = \\sum_{n=N+1}^{\\infty} n^{-\\sigma} $$\n其中$S_{N}(\\sigma) = \\sum_{n=1}^{N} n^{-\\sigma}$。\n\n我们被要求使用积分比较法导出$R_{N}(\\sigma)$的一个上界。设函数$f(x) = x^{-\\sigma}$。对于$\\sigma > 1$和$x > 0$，该函数是正的、连续的且严格递减的。和$R_{N}(\\sigma)$可以被解释为一系列矩形的面积之和。具体来说，项$n^{-\\sigma}$是一个宽度为$1$（从$n-1$到$n$）高度为$n^{-\\sigma}$的矩形面积。\n\n对于任意整数$n \\geq 1$，以及对于区间$[n, n+1]$中的任意$x$，由于$f(x)$的递减性，我们有$x^{-\\sigma} \\le n^{-\\sigma}$。将此不等式在区间$[n, n+1]$上积分，得到：\n$$ \\int_{n}^{n+1} x^{-\\sigma} \\,dx \\le \\int_{n}^{n+1} n^{-\\sigma} \\,dx = n^{-\\sigma} \\cdot ((n+1) - n) = n^{-\\sigma} $$\n这个不等式 $\\int_{n}^{n+1} x^{-\\sigma} \\,dx \\le n^{-\\sigma}$ 与另一个方向的不等式 $n^{-\\sigma} \\le \\int_{n-1}^{n} x^{-\\sigma} \\,dx$ 都可以用来界定求和。为了界定尾项 $\\sum_{n=N+1}^{\\infty}$，后者更直接。\n\n我们可以将此应用于尾项和$R_{N}(\\sigma)$，通过从$n = N+1$到$\\infty$求和：\n$$ R_{N}(\\sigma) = \\sum_{n=N+1}^{\\infty} n^{-\\sigma} \\le \\sum_{n=N+1}^{\\infty} \\int_{n-1}^{n} x^{-\\sigma} \\,dx $$\n右侧的积分和是关于相邻区间的求和，可以合并成一个单一的积分：\n$$ \\sum_{n=N+1}^{\\infty} \\int_{n-1}^{n} x^{-\\sigma} \\,dx = \\int_{N}^{N+1} x^{-\\sigma} \\,dx + \\int_{N+1}^{N+2} x^{-\\sigma} \\,dx + \\dots = \\int_{N}^{\\infty} x^{-\\sigma} \\,dx $$\n因此，我们建立了上界：\n$$ R_{N}(\\sigma) \\le \\int_{N}^{\\infty} x^{-\\sigma} \\,dx $$\n现在，我们计算这个瑕积分。由于$\\sigma > 1$，我们有$1-\\sigma \\neq 0$。\n$$ \\int_{N}^{\\infty} x^{-\\sigma} \\,dx = \\lim_{M \\to \\infty} \\int_{N}^{M} x^{-\\sigma} \\,dx = \\lim_{M \\to \\infty} \\left[ \\frac{x^{1-\\sigma}}{1-\\sigma} \\right]_{N}^{M} = \\lim_{M \\to \\infty} \\left( \\frac{M^{1-\\sigma}}{1-\\sigma} - \\frac{N^{1-\\sigma}}{1-\\sigma} \\right) $$\n因为$\\sigma > 1$，指数$1-\\sigma$为负。因此，当$M \\to \\infty$时，项$M^{1-\\sigma} \\to 0$。该积分计算结果为：\n$$ 0 - \\frac{N^{1-\\sigma}}{1-\\sigma} = \\frac{N^{1-\\sigma}}{\\sigma - 1} $$\n所以，我们导出了闭式上界$B(\\sigma, N)$：\n$$ R_{N}(\\sigma) \\le \\frac{N^{1-\\sigma}}{\\sigma-1} = B(\\sigma, N) $$\n接下来，我们特殊化到$\\sigma = 2$的情况。需要限定边界的量是$|\\zeta(2) - \\sum_{n=1}^{N} \\frac{1}{n^2}| = R_{N}(2)$。我们要求它小于或等于$10^{-6}$。\n使用导出的上界，我们对$B(2, N)$施加条件：\n$$ R_N(2) \\le B(2, N) \\le 10^{-6} $$\n对于$\\sigma=2$，该上界为：\n$$ B(2, N) = \\frac{N^{1-2}}{2-1} = \\frac{N^{-1}}{1} = \\frac{1}{N} $$\n不等式变为：\n$$ \\frac{1}{N} \\le 10^{-6} $$\n求解$N$，我们发现：\n$$ N \\ge \\frac{1}{10^{-6}} = 10^6 $$\n满足此条件的最小整数$N$是$N=10^6$。\n\n最后，简要说明一下此类界的现实意义。黎曼猜想（RH）是一个关于复变量$s$的$\\zeta(s)$函数零点的猜想，特别是在“临界带”$0 \\le \\operatorname{Re}(s) \\le 1$内的零点。然而，其定义级数$\\sum n^{-s}$仅在$\\operatorname{Re}(s) > 1$时收敛。要在临界带中研究$\\zeta(s)$，必须首先进行解析延拓。这通常通过推导$\\zeta(s)$的积分表示来实现。\n此类积分表示的推导（例如，通过欧拉-麦克劳林公式）依赖于在收敛半平面$\\operatorname{Re}(s)>1$内严格地控制部分和$S_N(s)$和余项$R_N(s)$。找到$R_N(s)$的显式有效界的能力，就像这里推导出的这个一样，是关键的第一步。它验证了用于建立解析延拓的极限过程的有效性，并为发展关于$|\\zeta(s)|$在整个复平面上的量值的更复杂的估计提供了基础。在解析数论中，这些估计是不可或缺的工具，用于将$\\zeta(s)$的零点与素数的分布联系起来。", "answer": "$$\\boxed{10^6}$$", "id": "3093088"}, {"introduction": "在我们熟悉了zeta函数在其级数收敛域内的性质后，现在我们将探索未知的领域。当 $\\Re(s) \\le 1$ 时，级数 $\\sum n^{-s}$ 是发散的，那么我们如何谈论像 $\\zeta(-1)$ 这样的值呢？这个实践将展示复分析的基石——解析延拓 (analytic continuation) 这一强大概念。通过将 $\\zeta(s)$ 与性质更好的狄利克雷eta函数 $\\eta(s)$ 联系起来，我们将进行一个多步骤的计算，最终得到那个著名而出人意料的结果 $\\zeta(-1) = -1/12$，从而揭示zeta函数在整个复平面上的“隐藏”结构。[@problem_id:3093060]", "problem": "设 $\\zeta(s)$ 表示 Riemann zeta 函数，当 $\\Re(s) > 1$ 时，由狄利克雷级数 $\\zeta(s) = \\sum_{n=1}^{\\infty} n^{-s}$ 定义。设 $\\eta(s)$ 表示 Dirichlet eta 函数，当 $\\Re(s) > 0$ 时，由交错狄利克雷级数 $\\eta(s) = \\sum_{n=1}^{\\infty} (-1)^{n-1} n^{-s}$ 定义。\n\n从这些定义出发，并仅使用收敛幂级数和解析延拓的基本性质，完成以下任务：\n\n- 在两个级数都收敛的区域内，通过按奇偶性对项进行分组，建立 $\\eta(s)$ 和 $\\zeta(s)$ 之间的关系。解释为什么除了 $\\zeta(s)$ 的极点外，该关系可以亚纯延拓到所有复数 $s$。\n\n- 考虑幂级数 $f(x) = \\sum_{n=1}^{\\infty} (-1)^{n-1} n x^{n}$ (对于 $|x|  1$)，将其表示为闭合形式，然后取其在 $x \\to 1^{-}$ 时的极限，从而计算发散级数 $\\sum_{n=1}^{\\infty} (-1)^{n-1} n$ 的 Abel 和。将此极限解释为解析延拓值 $\\eta(-1)$。\n\n- 使用你的结果计算 $\\zeta(-1)$ 的精确值。\n\n作为与 Bernoulli 数相关的一致性检验，回想 Bernoulli 数 $B_{n}$ 由生成函数 $\\frac{x}{\\exp(x) - 1} = \\sum_{n=0}^{\\infty} B_{n} \\frac{x^{n}}{n!}$ 定义。从此生成函数确定 $B_{2}$，并验证你计算的 $\\zeta(-1)$ 值与 $-B_{2}/2$ 一致，这是通过解析延拓方法得到的 $\\zeta(-n)$ 与 Bernoulli 数之间一般关系的一个特例。\n\n最后，陈述 Riemann 猜想 (RH)，并用一两句话简要解释为什么解析延拓和像 $\\zeta(-1)$ 这样的特殊值能够说明 $\\zeta(s)$ 在数论中的更广泛意义。\n\n你的最终数值答案必须是 $\\zeta(-1)$ 的精确值，表示为一个无单位的最简分数。", "solution": "该问题被验证为是自洽的、有科学依据且定义明确的，允许一个完整且合理的解答。\n\n第一步是建立 Riemann zeta 函数 $\\zeta(s)$ 和 Dirichlet eta 函数 $\\eta(s)$ 之间的关系。定义是在复平面 $s$ 的特定区域内给出的。\n当 $\\Re(s) > 1$ 时，Riemann zeta 函数由级数定义：\n$$\n\\zeta(s) = \\sum_{n=1}^{\\infty} \\frac{1}{n^s} = 1^{-s} + 2^{-s} + 3^{-s} + 4^{-s} + \\dots\n$$\n当 $\\Re(s) > 0$ 时，Dirichlet eta 函数由级数定义：\n$$\n\\eta(s) = \\sum_{n=1}^{\\infty} \\frac{(-1)^{n-1}}{n^s} = 1^{-s} - 2^{-s} + 3^{-s} - 4^{-s} + \\dots\n$$\n在公共收敛域 $\\Re(s) > 1$ 内，我们可以处理 $\\zeta(s)$ 的级数。我们将和式分为偶数和奇数索引的项（$n = 2k$ 和 $n = 2k-1$，其中 $k \\in \\{1, 2, 3, \\dots\\}$）。\n$$\n\\zeta(s) = \\sum_{k=1}^{\\infty} \\frac{1}{(2k-1)^s} + \\sum_{k=1}^{\\infty} \\frac{1}{(2k)^s}\n$$\n第二个和式可以重写为：\n$$\n\\sum_{k=1}^{\\infty} \\frac{1}{(2k)^s} = \\sum_{k=1}^{\\infty} 2^{-s} k^{-s} = 2^{-s} \\sum_{k=1}^{\\infty} k^{-s} = 2^{-s} \\zeta(s)\n$$\n将此代回，我们得到：\n$$\n\\zeta(s) = \\sum_{k=1}^{\\infty} \\frac{1}{(2k-1)^s} + 2^{-s} \\zeta(s)\n$$\n这使我们能够将奇数项的和表示为：\n$$\n\\sum_{k=1}^{\\infty} \\frac{1}{(2k-1)^s} = (1 - 2^{-s}) \\zeta(s)\n$$\n现在我们来考察 eta 函数 $\\eta(s)$。它也可以被分成奇数项和偶数项：\n$$\n\\eta(s) = \\sum_{k=1}^{\\infty} \\frac{1}{(2k-1)^s} - \\sum_{k=1}^{\\infty} \\frac{1}{(2k)^s}\n$$\n代入我们找到的用 $\\zeta(s)$ 表示的表达式：\n$$\n\\eta(s) = (1 - 2^{-s})\\zeta(s) - 2^{-s}\\zeta(s) = (1 - 2 \\cdot 2^{-s})\\zeta(s) = (1 - 2^{1-s})\\zeta(s)\n$$\n这个关系 $\\eta(s) = (1 - 2^{1-s})\\zeta(s)$ 是在 $\\Re(s) > 1$ 的条件下推导出来的。然而，$\\eta(s)$ 的级数对所有 $\\Re(s) > 0$ 的 $s$ 都收敛，在该半平面上定义了一个解析函数。函数 $(1 - 2^{1-s})$ 是一个整函数。根据解析延拓原理，关系式 $\\zeta(s) = \\frac{\\eta(s)}{1 - 2^{1-s}}$ 将 $\\zeta(s)$ 的定义亚纯地延拓到整个复平面，可能的极点出现在 $1 - 2^{1-s} = 0$ 的地方。这发生在 $s = 1 - \\frac{2\\pi i k}{\\ln 2}$ (对于任意整数 $k$)。当 $k=0$ 时，我们有 $s=1$，这对应于 $\\zeta(s)$ 的已知单极点。\n\n接下来，我们计算发散级数 $\\sum_{n=1}^{\\infty} (-1)^{n-1} n$ 的 Abel 和。这个和在形式上对应于 $\\eta(-1)$。我们考虑幂级数 $f(x) = \\sum_{n=1}^{\\infty} (-1)^{n-1} n x^{n}$ (对于 $|x|  1$)。为了找到它的闭合形式，我们从几何级数开始：\n$$\n\\frac{1}{1+x} = \\sum_{n=0}^{\\infty} (-x)^n = \\sum_{n=0}^{\\infty} (-1)^n x^n, \\quad \\text{for } |x|  1\n$$\n对 $x$ 求导得到：\n$$\n-\\frac{1}{(1+x)^2} = \\sum_{n=1}^{\\infty} (-1)^n n x^{n-1}\n$$\n乘以 $-x$：\n$$\n\\frac{x}{(1+x)^2} = -x \\sum_{n=1}^{\\infty} (-1)^n n x^{n-1} = \\sum_{n=1}^{\\infty} (-1)^{n-1} n x^n = f(x)\n$$\n所以，闭合形式是 $f(x) = \\frac{x}{(1+x)^2}$。Abel 和是 $f(x)$ 当 $x \\to 1^{-}$ 时的极限。\n$$\n\\eta(-1) \\equiv \\lim_{x \\to 1^{-}} f(x) = \\lim_{x \\to 1^{-}} \\frac{x}{(1+x)^2} = \\frac{1}{(1+1)^2} = \\frac{1}{4}\n$$\n这个极限是 $\\eta(s)$ 在 $s = -1$ 处的解析延拓值。\n\n使用已建立的关系，我们现在可以计算 $\\zeta(-1)$。\n$$\n\\zeta(s) = \\frac{\\eta(s)}{1 - 2^{1-s}}\n$$\n代入 $s = -1$：\n$$\n\\zeta(-1) = \\frac{\\eta(-1)}{1 - 2^{1-(-1)}} = \\frac{\\eta(-1)}{1 - 2^2} = \\frac{1/4}{1-4} = \\frac{1/4}{-3} = -\\frac{1}{12}\n$$\n\n作为一致性检验，我们使用 Bernoulli 数 $B_n$ 的生成函数：\n$$\n\\frac{x}{\\exp(x) - 1} = \\sum_{n=0}^{\\infty} B_n \\frac{x^n}{n!}\n$$\n我们将左侧在 $x=0$ 附近展开为 Taylor 级数。\n$$\n\\exp(x) - 1 = \\left(1 + x + \\frac{x^2}{2!} + \\frac{x^3}{3!} + \\dots\\right) - 1 = x + \\frac{x^2}{2} + \\frac{x^3}{6} + \\dots\n$$\n$$\n\\frac{x}{\\exp(x) - 1} = \\frac{x}{x(1 + \\frac{x}{2} + \\frac{x^2}{6} + \\dots)} = \\frac{1}{1 + (\\frac{x}{2} + \\frac{x^2}{6} + \\dots)}\n$$\n使用几何级数展开 $\\frac{1}{1+u} = 1 - u + u^2 - \\dots$，其中 $u = \\frac{x}{2} + \\frac{x^2}{6} + \\dots$：\n$$\n1 - \\left(\\frac{x}{2} + \\frac{x^2}{6} + \\dots\\right) + \\left(\\frac{x}{2} + \\dots\\right)^2 - \\dots = 1 - \\frac{x}{2} - \\frac{x^2}{6} + \\frac{x^2}{4} + O(x^3)\n$$\n$$\n= 1 - \\frac{1}{2}x + \\left(-\\frac{1}{6} + \\frac{1}{4}\\right)x^2 + O(x^3) = 1 - \\frac{1}{2}x + \\frac{1}{12}x^2 + O(x^3)\n$$\n与级数 $B_0 + B_1 x + \\frac{B_2}{2} x^2 + \\dots$ 比较系数：\n$$\n\\frac{B_2}{2!} = \\frac{B_2}{2} = \\frac{1}{12} \\implies B_2 = \\frac{2}{12} = \\frac{1}{6}\n$$\n问题陈述了关系 $\\zeta(-1) = -B_2/2$。我们来检验一下：\n$$\n-\\frac{B_2}{2} = -\\frac{1/6}{2} = -\\frac{1}{12}\n$$\n这与我们计算出的 $\\zeta(-1)$ 的值相符，证实了结果。\n\n最后，我们陈述 Riemann 猜想并解释解析延拓的意义。\nRiemann 猜想 (RH) 是指 Riemann zeta 函数 $\\zeta(s)$ 的所有非平凡零点都位于“临界线”上，即实部等于 $1/2$ 的复数直线。\n解析延拓将 $\\zeta(s)$ 的定义域从其原始定义（通过欧拉乘积与素数相连）扩展到整个复平面，揭示了其完整结构。这种强大的技术揭示了编码在该函数特殊值（如 $\\zeta(-1) = -1/12$）中的深层算术信息，并将素数的分布与该函数零点的位置联系起来。", "answer": "$$\n\\boxed{-\\frac{1}{12}}\n$$", "id": "3093060"}, {"introduction": "黎曼zeta函数的深远意义在于它与素数分布之间存在着深刻的联系。这个实践将通过编程计算，将这种联系生动地展现出来。我们将聚焦于zeta函数的对数导数 $-\\frac{\\zeta'(s)}{\\zeta(s)}$，它可以通过冯·曼戈尔特函数 ($\\Lambda(n)$) 表示为一个关于素数幂的级数。你将编写一个程序来数值计算这个级数的部分和及其误差，从而在微积分世界的解析对象与离散而基本的素数世界之间建立起一座切实的桥梁。[@problem_id:3093072]", "problem": "要求您实现并分析黎曼ζ函数对数导数的一个数值近似，该近似使用一个素数加权的狄利克雷级数。请完全使用实数输入和输出，并且不要使用任何外部数据文件或网络访问。\n\n背景与基本原理：\n- 对于$\\Re(s) > 1$，Riemann zeta函数$\\zeta(s)$由绝对收敛的Dirichlet级数$\\zeta(s) = \\sum_{n=1}^{\\infty} n^{-s}$定义，并且在同一半平面上，它也允许使用Euler乘积$\\zeta(s) = \\prod_{p} (1 - p^{-s})^{-1}$（其中$p$为素数）来表示。\n- von Mangoldt函数$\\Lambda(n)$的定义如下：如果$n = p^{k}$（其中$p$为素数，$k \\ge 1$为整数），则$\\Lambda(n) = \\log p$；否则$\\Lambda(n) = 0$。这里的$\\log$表示自然对数。\n- 在解析数论中，一个经过充分验证的事实是以下恒等式（在$\\Re(s) > 1$时成立），它将素数的分布与$\\zeta(s)$的对数导数联系起来：\n$$\n- \\frac{\\zeta'(s)}{\\zeta(s)} = \\sum_{n=1}^{\\infty} \\frac{\\Lambda(n)}{n^{s}}.\n$$\n\n任务：\n1. 对于实数参数$\\sigma > 1$和正整数截断值$X \\ge 1$，定义有限和\n$$\nS_{X}(\\sigma) := \\sum_{n \\le X} \\frac{\\Lambda(n)}{n^{\\sigma}}.\n$$\n实现一个程序，通过以下步骤计算$S_{X}(\\sigma)$：\n   - 根据$\\Lambda(n)$的定义，精确计算所有$1 \\le n \\le X$的$\\Lambda(n)$值。\n   - 对得到的$\\Lambda(n) n^{-\\sigma}$值求和。\n\n2. 对于每一对$(\\sigma, X)$，提供截断误差的一个严格上界\n$$\nE_{X}(\\sigma) := \\left| \\sum_{n > X} \\frac{\\Lambda(n)}{n^{\\sigma}} \\right|.\n$$\n仅使用基本不等式来证明您的界，特别是对于$n \\ge 2$有$\\Lambda(n) \\le \\log n$以及当$\\sigma > 1$时函数$t \\mapsto t^{-\\sigma}$的单调性。一个允许使用的界是\n$$\nE_{X}(\\sigma) \\le \\sum_{n > X} \\frac{\\log n}{n^{\\sigma}} \\le \\log X \\cdot X^{-\\sigma} + \\int_{X}^{\\infty} \\frac{\\log t}{t^{\\sigma}} \\, dt,\n$$\n并且您必须计算该积分的封闭形式解。您的程序必须为每个测试用例计算并返回此界的数值，以及$S_{X}(\\sigma)$的值。\n\n3. 在您的解题思路中，讨论该近似如何与Riemann hypothesis的陈述和意义相关联，特别是在素数分布以及当$\\sigma > 1$时部分和的行为方面。\n\n需要实现的测试套件：\n- 按以下确切顺序使用下列$(\\sigma, X)$对：\n  - $(\\sigma, X) = (1.05, 50000)$\n  - $(\\sigma, X) = (1.10, 100000)$\n  - $(\\sigma, X) = (1.30, 100000)$\n  - $(\\sigma, X) = (2.00, 100000)$\n  - $(\\sigma, X) = (2.00, 1)$\n\n输出规格：\n- 对于每个测试用例，计算两个浮点数：近似值$S_{X}(\\sigma)$和如上推导的截断误差$E_{X}(\\sigma)$的严格上界。\n- 您的程序应生成单行输出，其中包含所有结果，形式为方括号内用逗号分隔的列表。结果必须按以下顺序排列\n  $[S_{X}(\\sigma), E_{X}(\\sigma), S_{X}(\\sigma), E_{X}(\\sigma), \\dots]$\n  与上述测试套件的顺序相对应。\n- 每个浮点数必须打印并四舍五入到恰好十位小数。", "solution": "用户提供的问题是解析数论和计算数学领域一个有效的练习。它要求为Riemann zeta函数的对数导数$-\\frac{\\zeta'(\\sigma)}{\\zeta(\\sigma)}$（对于实数参数$\\sigma > 1$）实现一个数值近似，并进行相应的误差界分析。所给出的定义和公式都是标准且正确的。该问题定义明确，所有必要的数据和约束都已指定。\n\n问题的核心在于对实数$\\sigma > 1$成立的恒等式：\n$$\n- \\frac{\\zeta'(\\sigma)}{\\zeta(\\sigma)} = \\sum_{n=1}^{\\infty} \\frac{\\Lambda(n)}{n^{\\sigma}}\n$$\n其中$\\Lambda(n)$是von Mangoldt函数。我们的任务是计算部分和$S_X(\\sigma) = \\sum_{n \\le X} \\frac{\\Lambda(n)}{n^{\\sigma}}$作为近似值，并对截断误差$E_X(\\sigma) = \\left| \\sum_{n > X} \\frac{\\Lambda(n)}{n^{\\sigma}} \\right|$进行定界。\n\n解决方案分为三个主要部分：$S_X(\\sigma)$的计算，误差界的推导与计算，以及与Riemann Hypothesis相关背景的讨论。\n\n**1. 近似值$S_X(\\sigma)$的计算**\n\n主要的计算任务是评估$S_X(\\sigma) = \\sum_{n=1}^{X} \\frac{\\Lambda(n)}{n^{\\sigma}}$。这需要计算从$1$到$X$所有整数$n$的von Mangoldt函数值$\\Lambda(n)$。定义指出，如果$n$是素数$p$的幂（即$n=p^k$，$k \\ge 1$），则$\\Lambda(n) = \\log p$；否则$\\Lambda(n)=0$。$\\Lambda(1)$定义为$0$。\n\n对每个$n$（直到$X$）进行因式分解的直接、朴素方法在计算上是低效的。我们将实现一种更优越的、基于素数筛的方法。算法流程如下：\n- 首先，使用Sieve of Eratosthenes生成所有小于等于$X$的素数。一个布尔类型的数组`is_prime`用于记录素性。\n- 初始化一个大小为$X+1$的数值数组`lambda_vals`，并用零填充。\n- 遍历从$2$到$X$的每个数$p$。如果`is_prime[p]`为真，则对于这个素数$p$：\n    - 计算其自然对数$\\log p$。\n    - 遍历它的幂：$p, p^2, p^3, \\dots, p^k$，只要$p^k \\le X$。对于每个这样的幂，将我们数组中的对应项`lambda_vals[$p^k$]`设置为$\\log p$。\n- 此过程结束后，`lambda_vals`数组正确地存储了$n \\in [1, X]$的所有$\\Lambda(n)$值。\n- 然后通过对$n=1, \\dots, X$的项$\\Lambda(n) n^{-\\sigma}$求和来计算$S_X(\\sigma)$。\n\n这种基于筛法的方法是高效的，并且正确地实现了$\\Lambda(n)$的定义。\n\n**2. 误差界$E_X(\\sigma)$的推导与计算**\n\n问题要求计算截断误差$E_X(\\sigma) = \\sum_{n > X} \\frac{\\Lambda(n)}{n^{\\sigma}}$的一个上界。对于$\\sigma > 1$，所有项都是正的，因此绝对值是不必要的。问题提供了一个特定的不等式序列以供使用：\n$$\nE_X(\\sigma) \\le \\sum_{n > X} \\frac{\\log n}{n^{\\sigma}} \\le \\log X \\cdot X^{-\\sigma} + \\int_{X}^{\\infty} \\frac{\\log t}{t^{\\sigma}} \\, dt\n$$\n该界可以通过基本不等式$\\Lambda(n) \\le \\log n$（对于$n \\ge 2$）以及用积分来界定求和来证明。我们的任务是计算该积分的封闭形式解。\n\n设$I = \\int \\frac{\\log t}{t^{\\sigma}} \\, dt$。我们使用分部积分法$\\int u \\, dv = uv - \\int v \\, du$，选择：\n- $u = \\log t \\implies du = \\frac{1}{t} dt$\n- $dv = t^{-\\sigma} dt \\implies v = \\frac{t^{1-\\sigma}}{1-\\sigma}$\n\n积分结果为：\n$$\nI = (\\log t) \\left(\\frac{t^{1-\\sigma}}{1-\\sigma}\\right) - \\int \\left(\\frac{t^{1-\\sigma}}{1-\\sigma}\\right) \\frac{1}{t} \\, dt = \\frac{t^{1-\\sigma}\\log t}{1-\\sigma} - \\frac{1}{1-\\sigma} \\int t^{-\\sigma} \\, dt\n$$\n$$\nI = \\frac{t^{1-\\sigma}\\log t}{1-\\sigma} - \\frac{1}{1-\\sigma} \\left(\\frac{t^{1-\\sigma}}{1-\\sigma}\\right) = - \\frac{t^{1-\\sigma}}{\\sigma-1} \\log t - \\frac{t^{1-\\sigma}}{(\\sigma-1)^2} = - \\frac{t^{1-\\sigma}}{\\sigma-1} \\left( \\log t + \\frac{1}{\\sigma-1} \\right)\n$$\n现在我们计算从$X$到$\\infty$的定积分：\n$$\n\\int_{X}^{\\infty} \\frac{\\log t}{t^{\\sigma}} \\, dt = \\left[ - \\frac{t^{1-\\sigma}}{\\sigma-1} \\left( \\log t + \\frac{1}{\\sigma-1} \\right) \\right]_{X}^{\\infty}\n$$\n由于$\\sigma>1$，则$1-\\sigma  0$，这意味着当$t \\to \\infty$时，$t^{1-\\sigma} \\to 0$和$t^{1-\\sigma}\\log t \\to 0$均成立。因此，表达式在上限处的值为$0$。\n$$\n\\int_{X}^{\\infty} \\frac{\\log t}{t^{\\sigma}} \\, dt = 0 - \\left( - \\frac{X^{1-\\sigma}}{\\sigma-1} \\left( \\log X + \\frac{1}{\\sigma-1} \\right) \\right) = \\frac{X^{1-\\sigma}}{\\sigma-1} \\left( \\log X + \\frac{1}{\\sigma-1} \\right)\n$$\n对于$X=1$，由于$\\log 1 = 0$，该式简化为$\\frac{1}{(\\sigma-1)^2}$。\n\n需要计算的总上界为$B_X(\\sigma) = \\log X \\cdot X^{-\\sigma} + \\frac{X^{1-\\sigma}}{\\sigma-1} \\left( \\log X + \\frac{1}{\\sigma-1} \\right)$。该公式被直接实现。对于$X=1$的测试用例，该界正确地简化为$B_1(\\sigma) = \\frac{1}{(\\sigma-1)^2}$。\n\n**3. 与Riemann Hypothesis的关联及意义**\n\nRiemann Hypothesis (RH)是一个关于Riemann zeta函数$\\zeta(s)$的非平凡零点位置的猜想。它假定所有这些零点都位于“临界线”$\\Re(s) = 1/2$上。这个猜想对素数的分布具有深远的影响。\n\n这种联系是通过我们在本问题中使用的、连接$\\zeta(s)$与素数的恒等式建立的。更高级的结果，即所谓的“显式公式”，使这种关系变得精确。例如，von Mangoldt求和函数$\\psi(x) = \\sum_{n \\le x} \\Lambda(n)$可以表示为：\n$$\n\\psi(x) = x - \\sum_{\\rho} \\frac{x^{\\rho}}{\\rho} - \\log(2\\pi) - \\frac{1}{2}\\log(1-x^{-2})\n$$\n其中求和是针对$\\zeta(s)$的所有非平凡零点$\\rho$。$x$项是主项，而对零点的求和$\\sum \\frac{x^\\rho}{\\rho}$构成了误差项。RH通过将$\\rho$的实部限制为$1/2$，为这个误差项的增长提供了最紧密的界，从而得出估计$\\psi(x) = x + O(x^{1/2}\\log^2 x)$。这是一个关于素数分布规律性的强有力陈述。\n\n我们对$\\sigma > 1$时$S_X(\\sigma)$的数值计算，是在其绝对收敛域内对函数$-\\zeta'(\\sigma)/\\zeta(\\sigma)$的一次探索。尽管我们的计算远离RH所涉及的临界带（$0  \\Re(s)  1$），但它们展示了连接zeta函数的解析性质与素数的算术性质的基础恒等式。当$s$从右侧趋近临界带时，这些和以及它们所收敛到的函数的行为，在数论中至关重要。当$\\sigma \\to 1^+$时，$-\\zeta'(\\sigma)/\\zeta(\\sigma) \\sim (\\sigma-1)^{-1}$的发散性等价于素数定理（$\\psi(x) \\sim x$）。RH是一个关于围绕此渐近行为的波动的更深刻的陈述。", "answer": "```python\n# The final answer must be a single, complete, standalone program.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (1.05, 50000),\n        (1.10, 100000),\n        (1.30, 100000),\n        (2.00, 100000),\n        (2.00, 1),\n    ]\n\n    results = []\n    \n    # The maximum value of X is needed to pre-compute von Mangoldt values once.\n    max_X = 0\n    if test_cases:\n        max_X = max(case[1] for case in test_cases)\n    \n    # Pre-compute von Mangoldt values up to the maximum X required.\n    lambda_vals_all = compute_von_mangoldt(max_X)\n\n    for sigma, X in test_cases:\n        s_x_sigma, e_x_sigma = compute_approx_and_bound(sigma, X, lambda_vals_all)\n        results.append(f\"{s_x_sigma:.10f}\")\n        results.append(f\"{e_x_sigma:.10f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\ndef compute_von_mangoldt(X):\n    \"\"\"\n    Computes the von Mangoldt function Lambda(n) for 1 = n = X.\n    Uses a sieve method for efficiency. Lambda(n) is log(p) if n = p^k, and 0 otherwise.\n    \"\"\"\n    if X  1:\n        return np.array([])\n    \n    lambdas = np.zeros(X + 1, dtype=np.float64) # lambdas[n] will store Lambda(n)\n    is_prime = np.ones(X + 1, dtype=bool)\n    is_prime[0:2] = False\n    \n    # Standard Sieve of Eratosthenes to identify prime numbers.\n    for p in range(2, int(np.sqrt(X)) + 1):\n        if is_prime[p]:\n            for i in range(p * p, X + 1, p):\n                is_prime[i] = False\n                \n    # Use the list of primes to populate the Lambda values.\n    for p in range(2, X + 1):\n        if is_prime[p]:\n            log_p = np.log(p)\n            power = p\n            while power = X:\n                lambdas[power] = log_p\n                # Use floating point division to be safe with large numbers\n                if power > X / p:\n                    break\n                power *= p\n                \n    return lambdas\n\ndef compute_approx_and_bound(sigma, X, lambda_vals_all):\n    \"\"\"\n    Computes S_X(sigma) and the error bound E_X(sigma).\n    \n    Args:\n        sigma (float): The real parameter sigma > 1.\n        X (int): The integer cutoff X >= 1.\n        lambda_vals_all (np.array): Pre-computed von Mangoldt values.\n        \n    Returns:\n        tuple: A pair of floats (s_x_sigma, e_x_sigma).\n    \"\"\"\n    # 1. Compute S_X(sigma) = sum_{n = X} Lambda(n) / n^sigma\n    lambda_vals = lambda_vals_all[:X + 1]\n    n_vals = np.arange(1, X + 1, dtype=np.float64)\n    # The sum starts from n=1, but Lambda(1)=0, so it doesn't contribute.\n    terms = np.divide(lambda_vals[1:], np.power(n_vals, sigma), \n                      where=(lambda_vals[1:] != 0))\n    s_x_sigma = np.sum(terms)\n\n    # 2. Compute the error bound E_X(sigma)\n    # The bound is given by: log(X)/X^sigma + Integral[X, inf](log(t)/t^sigma dt)\n    sigma_minus_1 = sigma - 1.0\n    \n    # Handle the special case X=1, for which log(X)=0 and the formula simplifies.\n    if X == 1:\n        # The bound is log(1)*1^{-sigma} + integral from 1 to oo of log(t)/t^sigma dt.\n        # The first term is 0. The integral evaluates to 1/(sigma-1)^2.\n        e_x_sigma = 1.0 / (sigma_minus_1**2)\n    else:\n        # For X > 1, use the full formula for the bound.\n        log_X = np.log(X)\n        X_pow_sigma = X**sigma\n        X_pow_1_minus_sigma = X**(1.0 - sigma)\n        \n        # This is the closed-form evaluation of the integral part\n        integral_part = X_pow_1_minus_sigma * (log_X / sigma_minus_1 + 1.0 / (sigma_minus_1**2))\n        \n        # This is the first term provided in the permissible bound formula\n        first_term = log_X / X_pow_sigma\n        \n        e_x_sigma = first_term + integral_part\n        \n    return s_x_sigma, e_x_sigma\n\nsolve()\n```", "id": "3093072"}]}