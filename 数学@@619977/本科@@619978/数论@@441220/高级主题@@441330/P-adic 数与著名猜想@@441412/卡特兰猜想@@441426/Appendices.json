{"hands_on_practices": [{"introduction": "在直接挑战一个著名的猜想之前，熟悉其核心研究对象——完美幂（perfect power），是至关重要的第一步。这个练习鼓励你通过编写代码来探索完美幂的分布规律以及它们之间的间隔，从而对它们的性质有一个直观的感受。通过计算不同上界内的完美幂集合，并分析它们之间的最小间距或是否存在连续的数对，你将建立起对卡塔兰猜想背后数字景观的初步认识 [@problem_id:3082991]。", "problem": "令 $x$、$y$、$a$ 和 $b$ 为整数，满足 $x \\ge 2$、$y \\ge 2$、$a \\ge 2$ 和 $b \\ge 2$。如果存在整数 $u \\ge 2$ 和 $v \\ge 2$ 使得 $n = u^v$，则称正整数 $n$ 为完全幂。卡塔兰猜想（已由米哈伊列斯库定理证明）指出，对于指数丢番图方程 $x^a - y^b = 1$（其中 $x \\ge 2$，$y \\ge 2$，$a \\ge 2$，$b \\ge 2$），其在正整数中的唯一解是 $3^2 - 2^3 = 1$。这等价于说，唯一的连续完全幂对是 $\\{8,9\\}$。\n\n请仅使用基本定义和经过充分验证的事实，实现一个程序，对以给定整数 $B$ 为上界的完全幂进行小规模的计算搜索和情况检查。对于每个测试用例，将给出一对 $(B,m)$，其中 $B$ 是搜索的包含性上界，$m$ 指示计算模式。对于给定的上界 $B$，定义集合\n$$\nS_B = \\{\\,u^v \\mid u \\in \\mathbb{Z},\\ v \\in \\mathbb{Z},\\ u \\ge 2,\\ v \\ge 2,\\ u^v \\le B \\,\\}.\n$$\n你的程序必须构建 $S_B$，然后根据模式 $m$ 计算以下其中之一：\n\n- 模式 $m = 0$（非卡塔兰连续完全幂的存在性）：判断是否存在一对不同的元素 $p, q \\in S_B$ 使得 $|p - q| = 1$ 且 $\\{p,q\\} \\ne \\{8,9\\}$。如果存在这样的对，则返回布尔值 `True`，否则返回 `False`。\n\n- 模式 $m = 1$（完全幂之间的最小间距）：计算 $S_B$ 中不同元素 $p, q$ 之间的最小绝对差 $|p - q|$。如果 $S_B$ 的元素少于两个，则返回 $-1$。否则，返回所有不同对的 $|p - q|$ 的最小可能整数值。\n\n- 模式 $m = 2$（连续完全幂对的数量）：计算 $S_B$ 中满足 $p  q$ 且 $q - p = 1$ 的不同元素有序对 $(p,q)$ 的数量。以整数形式返回此计数。请注意，这会将每个有序对计数一次；例如，当 $8$ 和 $9$ 都在 $S_B$ 中时，对 $\\{8,9\\}$ 对计数的贡献恰好为一。\n\n为确保科学真实性和清晰性，请将您的解决方案基于以下基本组成部分：\n- 如上所述的完全幂的定义。\n- 整数和顺序的基本性质：如果一个有限整数集合按升序排序，则不同元素之间的最小绝对差出现在排序后列表中的相邻元素之间。\n- 指数的对数界限：由于对于 $S_B$ 中存在的任何指数 $v$都有 $2^v \\le B$，因此可以得出 $v \\le \\lfloor \\log_2(B) \\rfloor$。\n\n实现您的程序以处理以下 $(B,m)$ 对的测试套件：\n- 测试用例 1：$(B,m) = (3,0)$。\n- 测试用例 2：$(B,m) = (10,2)$。\n- 测试用例 3：$(B,m) = (100,1)$。\n- 测试用例 4：$(B,m) = (15,0)$。\n- 测试用例 5：$(B,m) = (7,1)$。\n\n您的程序应生成一行输出，其中包含这些测试用例的结果，结果为逗号分隔的列表，并用方括号括起来，顺序与测试套件相同（例如，$[result_1,result_2,result_3,result_4,result_5]$）。所有输出必须是指定的基本类型：模式 $m=0$ 为布尔值，模式 $m=1$ 和 $m=2$ 为整数。此问题不涉及物理单位，也无需报告角度或百分比。", "solution": "该问题已经过验证，被确定为数论中一个有效、适定的计算问题。它在科学上基于完全幂的定义和卡塔兰猜想，其组成部分定义清晰，没有矛盾或歧义。\n\n核心任务是实现一个算法，对于给定的整数上界 $B$，构建完全幂集合 $S_B$，然后根据模式参数 $m$ 执行三种计算之一。该集合定义为：\n$$\nS_B = \\{\\,u^v \\mid u \\in \\mathbb{Z},\\ v \\in \\mathbb{Z},\\ u \\ge 2,\\ v \\ge 2,\\ u^v \\le B \\,\\}\n$$\n解决方案涉及两个主要阶段：首先，高效地生成集合 $S_B$；其次，为每个指定的模式 $m \\in \\{0, 1, 2\\}$ 实现相应的逻辑。\n\n**阶段 1：生成集合 $S_B$**\n\n为了构建给定上界 $B$ 的集合 $S_B$，我们必须找到所有形式为 $u^v$ 且小于或等于 $B$ 的整数，同时满足约束条件 $u \\ge 2$ 和 $v \\ge 2$。直接搜索所有小于等于 $B$ 的整数以检查它们是否为完全幂是低效的。一种更系统的方法是通过迭代可能的底数 $u$ 和指数 $v$ 来生成幂。\n\n底数 $u$ 和指数 $v$ 的搜索空间可以被约束。\n1.  对于底数 $u$：由于 $v \\ge 2$，任何底数 $u$ 的最小幂是 $u^2$。必须满足条件 $u^2 \\le B$，这意味着 $u \\le \\sqrt{B}$。因此，底数 $u$ 仅需在 $2 \\le u \\le \\lfloor \\sqrt{B} \\rfloor$ 范围内检查。\n2.  对于指数 $v$：对于给定的底数 $u$，我们必须找到所有满足 $u^v \\le B$ 的指数 $v \\ge 2$。\n\n算法流程如下：\n- 初始化一个空集合数据结构来存储完全幂。使用集合是为了自动处理重复项，例如 $64 = 8^2 = 4^3 = 2^6$。\n- 从 $2$ 到 $\\lfloor \\sqrt{B} \\rfloor$ 遍历每个可能的底数 $u$。\n- 对于每个底数 $u$，从 $v=2$ 开始计算其幂 $u^v$。我们从值 $p = u^2$ 开始。\n- 只要 $p \\le B$，我们就将 $p$ 添加到集合中。然后，我们将 $p$ 更新为下一个幂，即 $p \\leftarrow p \\cdot u$，并重复检查。\n- 如果在任何时候 $p > B$，那么该底数 $u$ 的所有后续幂也将超过 $B$，因此我们可以终止内层循环，继续处理下一个底数 $u+1$。\n- 处理完所有有效的底数后，得到的集合包含 $S_B$ 的所有唯一元素。为了进行后续处理，将此集合转换为一个排序列表（我们称之为 $L_B$）是非常有利的。\n\n**阶段 2：特定模式的计算**\n\n一旦获得了完全幂的排序列表 $L_B$，我们就可以为每种模式执行所需的计算。\n\n- **模式 $m = 0$（非卡塔兰连续完全幂的存在性）：**\n目标是判断是否存在一对不同的元素 $p, q \\in S_B$ 使得 $|p - q| = 1$ 且 $\\{p,q\\} \\ne \\{8,9\\}$。由于 $L_B$ 是排序的，任何差值为 1 的此类对必定在列表中是相邻的。算法会遍历 $L_B$ 并检查每一对相邻元素 $(L_B[i], L_B[i+1])$。对于每一对，它检查是否 $L_B[i+1] - L_B[i] = 1$。如果满足此条件，它会进一步检查该对是否为 $\\{8, 9\\}$。如果找到一个非 $\\{8, 9\\}$ 的连续对，函数返回 `True`。如果遍历完整个列表都没有找到这样的对，函数返回 `False`。\n\n- **模式 $m = 1$（完全幂之间的最小间距）：**\n任务是找到 $S_B$ 中任意两个不同元素 $p, q$ 之间的最小绝对差 $|p-q|$。问题正确地指出，对于一个排序的数字列表，这个最小差值总是出现在两个相邻元素之间。首先，我们处理边界情况：如果 $S_B$ 包含的元素少于两个（即 $L_B$ 的长度小于 2），则无法计算差值，必须返回 $-1$。否则，我们将一个变量 `min_gap` 初始化为一个大值（或前两个元素的差值 $L_B[1] - L_B[0]$）。然后，我们遍历 $L_B$ 中的相邻对，从 $(L_B[0], L_B[1])$ 到 $(L_B[k-2], L_B[k-1])$，其中 $k$ 是列表的大小。在每一步中，我们计算差值 $L_B[i+1] - L_B[i]$，如果这个新差值更小，就更新 `min_gap`。`min_gap` 的最终值就是结果。\n\n- **模式 $m = 2$（连续完全幂对的数量）：**\n此模式要求计算 $S_B$ 中满足 $p  q$ 且 $q - p = 1$ 的不同元素有序对 $(p,q)$ 的数量。再次强调，使用排序列表 $L_B$ 是最优的。任何这样的对在 $L_B$ 中必定是相邻的。我们将一个计数器初始化为 0。我们从头开始遍历 $L_B$ 的相邻元素。对于每一对 $(L_B[i], L_B[i+1])$，我们检查是否 $L_B[i+1] - L_B[i] = 1$。如果是，我们就增加计数器。计数器的最终值即为返回结果。如果 $8$ 和 $9$ 都存在于 $S_B$ 中，这种方法能正确地将对 $\\{8,9\\}$ 计数一次。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# No other non-standard libraries are used.\n\ndef calculate_result(B, m):\n    \"\"\"\n    Calculates the result for a given test case (B, m).\n    \n    This function first generates the set S_B of perfect powers up to B,\n    then performs a computation based on the mode m.\n    \"\"\"\n\n    # Stage 1: Generate the set S_B of perfect powers\n    # A perfect power n = u^v with u>=2, v>=2.\n    # The smallest power is 2^2 = 4, so if B  4, the set is empty.\n    if B  4:\n        sorted_powers = []\n    else:\n        perfect_powers = set()\n        # The base u must satisfy u^2 = B, so u = sqrt(B).\n        u_limit = int(np.sqrt(B))\n        for u in range(2, u_limit + 1):\n            # Calculate powers of u starting from u^2.\n            power = u * u\n            while power = B:\n                perfect_powers.add(power)\n                # To prevent potential overflow on large numbers and for efficiency,\n                # check if the next multiplication would exceed B.\n                if B // u  power:\n                    break\n                power *= u\n        \n        sorted_powers = sorted(list(perfect_powers))\n\n    # Stage 2: Mode-specific computations\n    if m == 0:\n        # Mode 0: Check for existence of a non-Catalan consecutive pair.\n        for i in range(len(sorted_powers) - 1):\n            p = sorted_powers[i]\n            q = sorted_powers[i+1]\n            if q - p == 1:\n                # Catalan's pair is {8, 9}. We are looking for others.\n                if not (p == 8 and q == 9):\n                    return True\n        return False\n\n    elif m == 1:\n        # Mode 1: Find the minimal gap between distinct perfect powers.\n        if len(sorted_powers)  2:\n            return -1\n        \n        min_gap = np.inf\n        for i in range(len(sorted_powers) - 1):\n            gap = sorted_powers[i+1] - sorted_powers[i]\n            if gap  min_gap:\n                min_gap = gap\n        return int(min_gap)\n\n    elif m == 2:\n        # Mode 2: Count the number of consecutive perfect power pairs.\n        count = 0\n        for i in range(len(sorted_powers) - 1):\n            p = sorted_powers[i]\n            q = sorted_powers[i+1]\n            if q - p == 1:\n                count += 1\n        return count\n    \n    # Should not be reached with valid mode values.\n    return None\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (3, 0),\n        (10, 2),\n        (100, 1),\n        (15, 0),\n        (7, 1),\n    ]\n\n    results = []\n    for case in test_cases:\n        B, m = case\n        result = calculate_result(B, m)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3082991"}, {"introduction": "掌握了完美幂的基本计算和性质后，我们可以将注意力集中在卡塔兰猜想的核心方程 $x^a - y^b = 1$ 上。这个练习旨在通过设计一个系统性的搜索算法，来找出所有满足该方程的整数解。与前一个练习相比，它不仅目标更明确，还引入了一个简单而强大的数论工具——奇偶性分析，来过滤掉不可能是解的候选项，从而提高搜索效率 [@problem_id:3082993]。", "problem": "考虑由形如 $x^a$ 的整数定义的完美幂集合，其中整数 $x \\ge 2$，且整数 $a \\ge 2$。被称为卡塔兰猜想（已作为米哈伊列斯库定理被证明）的经典论断，断言了整数中连续完美幂的唯一性。在此问题中，您将设计并实现一种系统性的枚举和搜索策略，以在给定范围内找出所有满足以下条件的整数四元组 $(x,a,y,b)$，其中 $x \\ge 2$，$y \\ge 2$，$a \\ge 2$，$b \\ge 2$：\n$$\nx^a - y^b = 1,\n$$\n并受限于约束条件 $x^a \\le N$ 和 $y^b \\le N$，其中 $N \\in \\mathbb{Z}$，$N \\ge 1$ 为给定的上界。\n\n您的算法必须基于以下基本原理从头推导：\n\n- 完美幂的定义：一个整数 $n$ 如果能表示为 $n = x^a$（其中整数 $x \\ge 2$ 且 $a \\ge 2$），则 $n$ 是一个完美幂。\n- 整数幂运算的单调性：对于固定的 $a \\ge 2$，函数 $f(x) = x^a$ 在 $x \\ge 2$ 上是严格递增的；对于固定的 $x \\ge 2$，函数 $g(a) = x^a$ 在 $a \\ge 2$ 上是严格递增的。\n- 基本不等式和定界：对于任何固定的指数 $e \\ge 2$，满足 $x^e \\le N$ 的最大底数是 $x \\le \\lfloor N^{1/e} \\rfloor$。\n- 基本的奇偶性和因式分解事实：\n  - 如果 $u$ 和 $v$ 是整数，则 $u^2 - v^2 = (u - v)(u + v)$。\n  - 模 $4$ 的平方数同余于 $0$ 或 $1$。\n  - 如果指数 $a$ 和 $b$ 都是偶数，则 $x^a$ 和 $y^b$ 都是平方数，而两个平方数之差等于 $1$（在 $x \\ge 2, y \\ge 2$ 的条件下）是不可能的，因为 $(u - v)(u + v) = 1$ 在 $u + v > 1$ 时没有解。\n\n利用这些基本原理，推导出一个枚举和搜索策略，该策略：\n\n1. 通过对由不等式 $x \\le \\lfloor N^{1/a} \\rfloor$ 确定的可行指数和底数进行循环，生成所有不超过给定界限 $N$ 的完美幂 $x^a$（其中 $x \\ge 2, a \\ge 2$）。\n2. 将生成的完美幂组织在一个数据结构中，该结构能高效地检测连续整数，特别是两个成员都是完美幂的数对 $(v+1, v)$。\n3. 对于每个检测到的连续数对，生成所有满足 $x^a = v+1$ 和 $y^b = v$ 的四元组 $(x,a,y,b)$，同时严格应用奇偶性过滤器，排除 $a$ 和 $b$ 均为偶数的候选解。\n4. 对四元组进行去重，并以确定性的、排序后的顺序输出。\n\n设计考虑：\n\n- 您的枚举必须利用单调性和定界原理来限制循环，从而避免不必要的工作。\n- 您的搜索应依赖于连续配对思想：如果 $x^a - y^b = 1$ 且两者都至多为 $N$，则存在一个完美幂 $v$ 及其后继数 $v+1$，使得 $y^b = v$ 且 $x^a = v+1$。\n- 同一个完美幂的多种表示形式（例如，$16 = 2^4 = 4^2$）必须保留，因为不同的表示形式可能构成不同的四元组。\n\n输入和输出：\n\n- 无输入。您的程序应在内部执行一个固定的测试套件。\n- 对于测试套件中的每个 $N$，计算满足上述条件的所有四元组 $(x,a,y,b)$ 的列表。每个四元组表示为一个列表 $[x,a,y,b]$。\n- 您的程序应生成单行输出，包含所有测试用例的结果，格式为一个逗号分隔的列表，并用方括号括起，其中每个测试用例的结果是形如 $[x,a,y,b]$ 的四元组列表。\n\n测试套件：\n\n- 使用以下四个 $N$ 值：\n  - $N = 10$ （包含已知连续完美幂对的通用“理想路径”案例），\n  - $N = 8$ （边界条件，上界仅包含较低的成员 $y^b$ 但不包含 $x^a$），\n  - $N = 1$ （边缘案例，没有满足 $x \\ge 2, a \\ge 2$ 的完美幂），\n  - $N = 100000$ （一个较大的界限，用于测试剪枝和枚举的效率与正确性）。\n\n答案规范：\n\n- 对于每个 $N$，答案必须是一个 $[x,a,y,b]$ 形式的四元组列表，该列表可能为空。\n- 最终输出必须将所有测试用例的结果聚合到单行中，格式严格如下：\n$$\n[\\text{Case}_1,\\text{Case}_2,\\text{Case}_3,\\text{Case}_4],\n$$\n其中每个 $\\text{Case}_i$ 本身是一个类似 $[[x,a,y,b],\\dots]$ 的四元组列表。\n\n此问题不涉及物理单位、角度单位或百分比。", "solution": "我们从完美幂的定义开始：一个整数 $n$ 如果能表示为 $n = x^a$（其中整数 $x \\ge 2$ 且 $a \\ge 2$），则它是一个完美幂。我们的目标是找到所有满足 $x^a - y^b = 1$ 的四元组 $(x,a,y,b)$，其中 $x \\ge 2$，$y \\ge 2$，$a \\ge 2$，$b \\ge 2$，并受限于 $x^a \\le N$ 和 $y^b \\le N$ 的界限。\n\n指导枚举的原则：\n\n1. 对于一个固定的指数 $e \\ge 2$，函数 $f(x) = x^e$ 在 $x \\ge 2$ 上是严格递增的。因此，对于给定的界限 $N$，可行的底数 $x$ 为 $x \\in \\{2,3,\\dots,\\lfloor N^{1/e} \\rfloor\\}$。通过让 $e$ 在范围 $e \\in \\{2,3,\\dots,\\lfloor \\log_2 N \\rfloor\\}$ 内循环，以及让 $x$ 循环至 $\\lfloor N^{1/e} \\rfloor$，可以完整地枚举出所有不大于 $N$ 的完美幂。\n2. 对于每个枚举出的数对 $(x,e)$，计算 $v = x^e$，并将其表示 $(x,e)$ 存储在一个以 $v$ 为键的关联结构中。这个结构是一个从值到表示形式列表的映射 $M$：\n   $$\n   M[v] = \\{(x,e) : x^e = v,\\ x \\ge 2,\\ e \\ge 2,\\ v \\le N\\}。\n   $$\n   这可以容纳多种表示形式，如 $16 = 2^4 = 4^2$。\n3. 如果 $x^a - y^b = 1$ 且两项都至多为 $N$，则对于某个整数 $v$ 有 $y^b = v$ 和 $x^a = v+1$。因此，解恰好对应于连续的数对 $(v, v+1)$，其中 $v \\in \\operatorname{keys}(M)$ 且 $v+1 \\in \\operatorname{keys}(M)$。所以，我们扫描 $M$ 的已排序键，对于每个满足 $v+1$ 也是键的 $v$，构建所有来自 $M[v+1]$ 的组合 $(x,a)$ 和来自 $M[v]$ 的组合 $(y,b)$。\n4. 基于奇偶性的剪枝：如果指数 $a$ 和 $b$ 都是偶数，则 $x^a$ 和 $y^b$ 都是平方数，比如 $x^a = u^2$ 和 $y^b = v^2$。恒等式\n   $$\n   u^2 - v^2 = (u - v)(u + v)\n   $$\n   表明，如果 $u^2 - v^2 = 1$ 且 $u \\ge 2, v \\ge 2$，则 $(u - v)(u + v) = 1$，这是不可能的，因为 $u + v \\ge 4$。因此，任何两个指数都为偶数的数对都不能满足 $x^a - y^b = 1$。应用此过滤器可以事先移除这类数对，从而在不牺牲正确性的前提下提高效率。\n5. 去重与排序：由于允许同一个完美幂有多种表示形式，可能会产生不同的组合。将四元组 $(x,a,y,b)$ 存储在一个集合中以确保唯一性，然后生成一个确定性排序的列表（例如，按字典序排序）。\n\n正确性论证：\n\n- 完备性：对于每个可行的指数 $e$ 和底数 $x$，所有完美幂 $x^e \\le N$ 都被枚举了，因为底数范围恰好是 $2 \\le x \\le \\lfloor N^{1/e} \\rfloor$，而指数范围是 $2 \\le e \\le \\lfloor \\log_2 N \\rfloor$，这已足够，因为对于 $x \\ge 2$，任何更高的指数都会使 $x^e$ 超过 $N$。\n- 连续扫描的必要性：如果 $x^a - y^b = 1$ 且 $x^a \\le N$ 和 $y^b \\le N$，则对于某个整数 $v$ 存在 $y^b = v$ 和 $x^a = v+1$，所以 $v$ 和 $v+1$ 都必须是枚举集合中的完美幂。因此，遍历映射键中的数对 $(v, v+1)$ 可以捕获所有可能性。\n- 剪枝的有效性：排除偶-偶指数对的奇偶性规则是从因式分解推导出来的，是严格有效的。它不会丢弃任何有效的解，因此保持了完备性。\n\n复杂度分析：\n\n令 $E = \\lfloor \\log_2 N \\rfloor$。对于每个 $e \\in \\{2,\\dots,E\\}$，底数的数量是 $\\lfloor N^{1/e} \\rfloor$。枚举的总次数为\n$$\n\\sum_{e=2}^{E} \\lfloor N^{1/e} \\rfloor。\n$$\n这个和主要由 $e=2$ 的项决定，该项约为 $\\sqrt{N}$，并且随着 $e$ 的增加而迅速减小。因此，枚举的运行时间大致为 $O(\\sqrt{N})$，对于给定的测试套件（包括 $N = 100000$）是高效的。\n\n测试套件行为：\n\n- 对于 $N = 10$，枚举包含 $8 = 2^3$ 和 $9 = 3^2$，经过奇偶性过滤和邻近检测后，得到四元组 $[3,2,2,3]$。\n- 对于 $N = 8$，包含 $8$ 但不包含 $9$，因此不存在连续的完美幂；结果为空列表。\n- 对于 $N = 1$，没有满足 $x \\ge 2$ 和 $a \\ge 2$ 的完美幂 $x^a \\le 1$；结果为空列表。\n- 对于 $N = 100000$，尽管界限很大，唯一连续的完美幂仍然是 $8$ 和 $9$，产生相同的四元组 $[3,2,2,3]$（其他地方的多种表示形式不会产生连续的数对）。如果在邻近检查中出现偶-偶指数组合，奇偶性过滤器会将其排除。\n\n输出格式：\n\n程序将构建并打印单行，格式如下\n$$\n[\\text{Case}_1,\\text{Case}_2,\\text{Case}_3,\\text{Case}_4],\n$$\n其中每个 $\\text{Case}_i$ 是为相应 $N$ 找到的四元组 $[x,a,y,b]$ 的列表。对于指定的测试套件，这将是一个包含四个列表的列表。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport math\nfrom typing import Dict, List, Tuple\n\ndef enumerate_perfect_powers(N: int) -> Dict[int, List[Tuple[int, int]]]:\n    \"\"\"\n    Enumerate all perfect powers x^e = N with x >= 2 and e >= 2.\n    Returns a dictionary mapping value -> list of (base, exponent) representations.\n    \"\"\"\n    value_map: Dict[int, List[Tuple[int, int]]] = {}\n    if N  4:\n        return value_map  # Small N has no perfect powers with base>=2 and exponent>=2 (2^2=4 is minimal)\n\n    # Max exponent is floor(log2(N)), since 2^e = N => e = log2(N)\n    max_exp = int(math.log2(N))\n    for e in range(2, max_exp + 1):\n        # Compute the maximal base such that base**e = N using floating root, then correct by adjustment\n        # Use float power as initial estimate\n        max_base = int(N ** (1.0 / e))\n        # Adjust upwards if rounding down too much\n        while (max_base + 1) ** e = N:\n            max_base += 1\n        # Adjust downwards if rounding up too much\n        while max_base >= 2 and (max_base) ** e > N:\n            max_base -= 1\n\n        for x in range(2, max_base + 1):\n            val = x ** e\n            # Store representation (x, e)\n            value_map.setdefault(val, []).append((x, e))\n    return value_map\n\ndef find_consecutive_power_quads(value_map: Dict[int, List[Tuple[int, int]]]) -> List[Tuple[int, int, int, int]]:\n    \"\"\"\n    Given a map of perfect power values to representations, find all quadruples (x,a,y,b)\n    such that x^a - y^b = 1. Apply parity filter: skip cases where both a and b are even.\n    Return a sorted list of unique quadruples.\n    \"\"\"\n    quads_set = set()\n    keys = sorted(value_map.keys())\n    keys_set = set(keys)\n\n    for v in keys:\n        u = v + 1\n        if u in keys_set:\n            reps_u = value_map[u]  # (x, a) such that x^a = u\n            reps_v = value_map[v]  # (y, b) such that y^b = v\n            for (x, a) in reps_u:\n                for (y, b) in reps_v:\n                    # Parity filter: if both exponents are even, difference of squares cannot be 1\n                    if (a % 2 == 0) and (b % 2 == 0):\n                        continue\n                    quads_set.add((x, a, y, b))\n\n    # Sort lexicographically for deterministic output\n    quads = sorted(list(quads_set))\n    return quads\n\ndef solve():\n    # Define the test cases from the problem statement: values of N\n    test_cases = [10, 8, 1, 100000]\n\n    results: List[List[Tuple[int, int, int, int]]] = []\n    for N in test_cases:\n        value_map = enumerate_perfect_powers(N)\n        quads = find_consecutive_power_quads(value_map)\n        results.append(quads)\n\n    # Format output exactly: a single line with a comma-separated list enclosed in square brackets.\n    # Each test case's result is a list of quadruples, each quadruple formatted as [x,a,y,b].\n    def format_quad(quad: Tuple[int, int, int, int]) -> str:\n        x, a, y, b = quad\n        return f\"[{x},{a},{y},{b}]\"\n\n    def format_case(case: List[Tuple[int, int, int, int]]) -> str:\n        return f\"[{','.join(format_quad(q) for q in case)}]\"\n\n    output = f\"[{','.join(format_case(case) for case in results)}]\"\n    print(output)\n\nsolve()\n```", "id": "3082993"}, {"introduction": "卡塔兰猜想仅仅是更广泛的丢番图问题中的一个特例。通过将方程 $x^a - y^b = 1$ 推广到皮莱方程（Pillai's Equation）$m^a - n^b = k$，我们可以更好地理解为什么 $k=1$ 的情况如此特殊。这个练习要求你为一个给定的 $k$ 值寻找皮莱方程的解，这不仅将卡塔兰猜想置于更广阔的背景中，还促使你思考更高效的算法策略，例如通过预计算和哈希表查找来优化搜索过程，这对解决更复杂的计算问题至关重要 [@problem_id:3082995]。", "problem": "设 $m$、$n$、$a$、$b$ 和 $k$ 为整数，满足 $m \\ge 2$、$n \\ge 2$、$a \\ge 2$、$b \\ge 2$ 和 $k \\ge 1$。皮莱方程是丢番图关系式 $m^a - n^b = k$。一个完全幂是指形如 $x^y$ 的任意整数，其中整数 $x \\ge 2$ 且 $y \\ge 2$。卡塔兰猜想（已被证明为米哈伊列斯库定理）指出，唯一相差为 $1$ 的连续完全幂是 $3^2$ 和 $2^3$。在本问题中，您将通过在有限边界内枚举解，并按测试用例汇总这些解，来探索皮莱方程的计算方面及其与卡塔兰猜想的关系。\n\n允许使用的基本定义和事实：\n- 整数求幂：对于整数 $u \\ge 2$ 和 $v \\ge 2$，完全幂 $u^v$ 是通过在整数环中进行重复相乘计算得出的。\n- 不等式和正性的基本性质：$m^a - n^b = k$ 且 $k \\ge 1$ 意味着 $m^a > n^b$。\n\n您的任务是实现一个程序，对于每个给定的测试用例，枚举所有满足 $m^a - n^b = k$ 的整数四元组 $[m,a,n,b]$，其中 $2 \\le m \\le M$、$2 \\le n \\le N$、$2 \\le a \\le A_{\\max}$、$2 \\le b \\le B_{\\max}$ 且 $k \\ge 1$。枚举必须在给定边界内是穷举的。每个解必须表示为列表 $[m,a,n,b]$。对于每个测试用例，将所有解收集到一个列表中，然后将所有测试用例的列表汇总到一个外部列表中。\n\n测试套件（每个测试用例是一个元组 $(k,M,N,A_{\\max},B_{\\max})$）：\n- 用例 $1$：$(1,20,20,10,10)$。\n- 用例 $2$：$(2,200,200,10,10)$。\n- 用例 $3$：$(5,50,50,10,10)$。\n- 用例 $4$：$(7,100,100,10,10)$。\n- 用例 $5$：$(15,100,100,10,10)$。\n- 用例 $6$：$(6,100,100,10,10)$。\n- 用例 $7$：$(32,100,100,10,10)$。\n- 用例 $8$：$(17,100,100,10,10)$。\n- 用例 $9$：$(65,100,100,10,10)$。\n\n最终输出规范：\n- 您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的列表形式的结果。\n- 该外部列表的每个元素对应一个测试用例，其本身是一个由 $[m,a,n,b]$ 解组成的列表，并为了可复现性按 $(m,a,n,b)$ 的字典序排列。\n- 例如，输出的形式应为 $[[\\dots],[\\dots],\\dots]$，其中每个内部列表按上述顺序包含相应测试用例的解。", "solution": "该问题要求在一个有界域内搜索皮莱方程 $m^a - n^b = k$ 的整数解。对所有四个变量 $(m,a,n,b)$ 进行直接的暴力枚举，其复杂度约为 $O(M \\cdot N \\cdot A_{\\max} \\cdot B_{\\max})$，对于给定的边界来说计算量过大。\n\n一个更高效的策略是利用“空间换时间”的思想。我们可以将方程重排为 $m^a - k = n^b$，这样就将变量 $(m,a)$ 和 $(n,b)$ 分离到了等式的两边。该策略包含两个主要阶段：\n\n**1. 预计算阶段：**\n我们首先生成并存储所有在给定边界内的完美幂 $n^b$。具体来说，我们遍历所有可能的底数 $n$（从 $2$ 到 $N$）和指数 $b$（从 $2$ 到 $B_{\\max}$），计算出完美幂 $v = n^b$。为了能够快速查找，我们将这些结果存储在一个哈希映射（例如 Python 中的字典）中。该映射的键是完美幂的值 $v$，值是一个列表，包含所有可以生成该值的 `[n,b]` 对。例如，对于值 $64$，它可能存储了 `[[2,6], [4,3], [8,2]]`。\n\n**2. 搜索与查找阶段：**\n在预计算完成后，我们遍历所有可能的 $(m,a)$ 对，即 $m$ 从 $2$ 到 $M$，$a$ 从 $2$ 到 $A_{\\max}$。对于每一对，我们计算目标值 `target`$= m^a - k$。然后，我们在预先构建的哈希映射中查找这个 `target` 值。\n\n如果 `target` 存在于哈希映射中，说明我们找到了一个或多个满足 $n^b = \\text{target}$ 的 $(n,b)$ 对。我们将当前的 $[m,a]$ 与哈希映射中 `target` 对应的每一个 $[n,b]$ 配对，就构成了一个完整的解四元组 $[m,a,n,b]$。\n\n**排序与输出：**\n为了确保输出的解是按字典序排列的，我们可以在生成解的过程中自然地维持顺序。只要我们在预计算阶段将同一个幂值对应的 `[n,b]` 对按 $n$ 排序，并且在搜索阶段按顺序遍历 $m$ 和 $a$，最终得到的解列表就会自然地按字典序排列，无需在最后进行代价高昂的全局排序。\n\n这种方法的复杂度大约为 $O(N \\cdot B_{\\max} + M \\cdot A_{\\max})$，远低于暴力搜索，因此对于本问题给定的约束是高效的。Python 的原生整数支持任意精度算术，可以自动处理计算中可能出现的非常大的数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\n\ndef solve():\n    \"\"\"\n    Main function to solve all test cases and print the final result.\n    \"\"\"\n    test_cases = [\n        # (k, M, N, A_max, B_max)\n        (1, 20, 20, 10, 10),\n        (2, 200, 200, 10, 10),\n        (5, 50, 50, 10, 10),\n        (7, 100, 100, 10, 10),\n        (15, 100, 100, 10, 10),\n        (6, 100, 100, 10, 10),\n        (32, 100, 100, 10, 10),\n        (17, 100, 100, 10, 10),\n        (65, 100, 100, 10, 10),\n    ]\n\n    all_results = []\n    for case in test_cases:\n        k, M, N, A_max, B_max = case\n        result_for_case = solve_one_case(k, M, N, A_max, B_max)\n        all_results.append(result_for_case)\n\n    # The output format requires a compact string representation of the list of lists.\n    # Python's str() function includes spaces, which we remove.\n    # e.g., str([[1, 2]]) -> '[[1, 2]]' -> '[[1,2]]'\n    final_output_str = str(all_results).replace(\" \", \"\")\n    print(final_output_str)\n\ndef solve_one_case(k, M, N, A_max, B_max):\n    \"\"\"\n    Enumerates solutions for a single test case using a pre-computation approach.\n    \n    The method rearranges m^a - n^b = k to m^a - k = n^b. It pre-computes\n    all possible n^b values and stores them in a hash map for efficient lookup.\n    \n    Args:\n        k (int): The constant difference in Pillai's equation.\n        M (int): The upper bound for the base m.\n        N (int): The upper bound for the base n.\n        A_max (int): The upper bound for the exponent a.\n        B_max (int): The upper bound for the exponent b.\n        \n    Returns:\n        list: A list of all solution quadruples [m, a, n, b], sorted lexicographically.\n    \"\"\"\n    \n    # 1. Pre-computation phase: Store all n^b powers in a dictionary.\n    # The keys are the perfect power values, and the values are lists of [n, b] pairs.\n    nb_powers = {}\n    for n in range(2, N + 1):\n        # Using pow(n, b) is clean and efficient in Python for large integers.\n        try:\n            val = pow(n, 2)\n        except OverflowError:\n            continue\n        \n        for b in range(2, B_max + 1):\n            if val not in nb_powers:\n                nb_powers[val] = []\n            nb_powers[val].append([n, b])\n            \n            # Check for overflow before next multiplication\n            if val > (2**64) // n: # A reasonable large number to prevent overflow in fixed-size integers, though Python handles it.\n                break\n            val *= n\n\n\n    # To ensure lexicographical output, sort the lists of [n, b] pairs by n.\n    # This matters when a single value has multiple representations (e.g., 64 = 8^2 = 4^3 = 2^6).\n    # The sorted list will be [[2, 6], [4, 3], [8, 2]].\n    for val in nb_powers:\n        nb_powers[val].sort()\n        \n    # 2. Search and Lookup phase\n    solutions = []\n    for m in range(2, M + 1):\n        for a in range(2, A_max + 1):\n            # Calculate the target value m^a - k\n            try:\n                val_ma = pow(m, a)\n            except OverflowError:\n                break\n            \n            target = val_ma - k\n            \n            # Perform a fast lookup in the pre-computed dictionary.\n            if target in nb_powers:\n                # If the target is a known perfect power, we have found solutions.\n                for n_b_pair in nb_powers[target]:\n                    solutions.append([m, a] + n_b_pair)\n\n    # The solutions are naturally generated in lexicographical order due to:\n    # a) The loops for m and a being in increasing order.\n    # b) The lists in nb_powers being sorted by n.\n    # No final sort of `solutions` is needed.\n    return solutions\n\nsolve()\n```", "id": "3082995"}]}