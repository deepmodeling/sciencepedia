{"hands_on_practices": [{"introduction": "赫克算子理论联系了抽象代数结构与模形式的傅里叶系数，后者蕴含着深刻的算术信息。为了真正掌握这一理论，我们必须能够将其抽象定义转化为具体的计算。这个练习将指导你从赫克算子 $T_p$ 的基本定义出发，推导它如何作用于模形式的 $q$-展开式系数，并将其实现为一个计算机程序。这项实践旨在将理论付诸实践，是进行更深入研究的基础。[@problem_id:3085846]", "problem": "实现一个程序，该程序从基本原理出发，计算素数 $2$ 处的赫克算子（Hecke operator）在整数权 $k \\ge 2$ 的模形式（modular forms）的截断 $q$-展开式上的作用，并验证其线性。在完全模群上的全纯模形式空间中进行计算。从权 $k$ 模形式上赫克算子的核心定义开始，\n$$(T_n f)(z) \\;=\\; n^{k-1} \\sum_{ad = n} \\sum_{b \\,(\\mathrm{mod}\\, d)} d^{-k} \\, f\\!\\left(\\frac{a z + b}{d}\\right),$$\n对于素数 $p$，该定义可特化为\n$$(T_p f)(z) \\;=\\; p^{k-1} f(p z) \\;+\\; p^{-1} \\sum_{r=0}^{p-1} f\\!\\left(\\frac{z + r}{p}\\right)。$$\n以此为基础，推导 $T_2$ 在 $q$-展开式上的显式逐系数作用。设 $q = e^{2 \\pi i z}$，且 $f(z)$ 由一个截断的 $q$-展开式给出\n$$f(z) \\;=\\; \\sum_{n=0}^{10} a_n \\, q^n,$$\n其中 $a_n \\in \\mathbb{C}$，截断意味着对于 $n > 10$，有 $a_n = 0$。推导 $(T_2 f)(z)$ 的 $q$-展开式直到并包含 $q^{10}$ 项的公式，该公式应完全用给定的系数 $(a_0,\\dots,a_{10})$ 和权 $k$ 来表示。您的实现不得假定 $a_{10}$ 之后的任何系数是已知的，因此必须将任何需要的 $m > 10$ 的 $a_m$ 视为 $0$。仅使用上述定义和关于单位根上指数和的成熟结论来推导系数法则；不要依赖任何预先给出的简化公式。\n\n程序必须实现这个推导出的系数法则，并验证 $T_2$ 的线性，即对于任何标量 $\\alpha$ 和 $\\beta$ 以及任何 $f$ 和 $g$，都有\n$$T_2(\\alpha f + \\beta g) \\;=\\; \\alpha \\, T_2 f \\;+\\; \\beta \\, T_2 g,$$\n逐系数地直到并包含 $q^{10}$ 项。\n\n测试套件。您的程序必须执行以下五个测试用例，每个用例都相互独立。在所有情况下，计算或比较直到并包含 $q^{10}$ 的系数。\n\n- 测试 1（直接计算至 $q^{10}$）：设 $k = 4$，$f$ 的系数为 $[a_0,\\dots,a_{10}] = [1,2,3,4,5,6,7,8,9,10,11]$。输出 $(T_2 f)(z)$ 的系数列表 $[c_0,\\dots,c_{10}]$。\n- 测试 2（线性，一般情况）：设 $k = 6$，$f$ 如测试 1 所示，$g$ 的系数为 $[0,1,0,1,0,1,0,1,0,1,0]$。设 $\\alpha = 3$ 和 $\\beta = -2$。输出一个布尔值，指示 $T_2(\\alpha f + \\beta g)$ 是否在系数上（直到 $q^{10}$）等于 $\\alpha T_2 f + \\beta T_2 g$。\n- 测试 3（常数形式边界情况）：设 $k = 8$，$f$ 的系数为 $[5,0,0,0,0,0,0,0,0,0,0]$。输出 $(T_2 f)(z)$ 的系数列表。\n- 测试 4（边界处理，其中 $2n > 10$）：设 $k = 2$，$f$ 的系数为 $[1,1,1,1,1,1,1,1,1,1,1]$。输出 $(T_2 f)(z)$ 的系数列表。\n- 测试 5（线性，退化标量）：设 $k = 10$，$f$ 的系数为 $[2,3,5,7,11,13,17,19,23,29,31]$，$g$ 的系数为 $[1,0,1,0,1,0,1,0,1,0,1]$，且 $\\alpha = 0$，$\\beta = 0$。输出一个布尔值，指示 $T_2(\\alpha f + \\beta g)$ 是否在系数上（直到 $q^{10}$）等于 $\\alpha T_2 f + \\beta T_2 g$。\n\n最终输出格式。您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表，列表内任何地方都不能有空格。每个测试用例为此顶级列表贡献一个元素，按测试 1 到 5 的顺序排列。直接计算的结果是包含 11 个整数的列表 $[c_0,\\dots,c_{10}]$，线性检查的结果是一个布尔值。例如，最终输出应类似于\n$[[\\dots],\\mathrm{True},[\\dots],[\\dots],\\mathrm{False}]$\n不含空格。本问题不涉及任何物理单位、角度单位或百分比；所有输出均为指定的纯数字或布尔值。", "solution": "任务是推导 $T_2$ 在 $q$-展开式系数上的作用。\n设 $f(z) = \\sum_{m=0}^{\\infty} a_m q^m = \\sum_{m=0}^{\\infty} a_m e^{2\\pi i m z}$。给定素数 $p$ 的特化形式：\n$$(T_p f)(z) = p^{k-1} f(pz) + p^{-1} \\sum_{r=0}^{p-1} f\\left(\\frac{z+r}{p}\\right)$$\n对于 $p=2$，这变为：\n$$(T_2 f)(z) = 2^{k-1} f(2z) + \\frac{1}{2} \\sum_{r=0}^{1} f\\left(\\frac{z+r}{2}\\right) = 2^{k-1} f(2z) + \\frac{1}{2} f\\left(\\frac{z}{2}\\right) + \\frac{1}{2} f\\left(\\frac{z+1}{2}\\right)$$\n设 $(T_2 f)(z) = \\sum_{n=0}^{\\infty} c_n q^n$。我们需要找到用 $a_m$ 表示 $c_n$ 的公式。\n我们来分析 $(T_2 f)(z)$ 表达式中的每一项。\n\n**第 1 项：$2^{k-1} f(2z)$**\n如果 $f(z) = \\sum_{m=0}^{\\infty} a_m e^{2\\pi i m z}$，那么\n$$f(2z) = \\sum_{m=0}^{\\infty} a_m e^{2\\pi i m (2z)} = \\sum_{m=0}^{\\infty} a_m e^{2\\pi i (2m) z} = \\sum_{m=0}^{\\infty} a_m q^{2m}$$\n所以，$2^{k-1} f(2z) = 2^{k-1} \\sum_{m=0}^{\\infty} a_m q^{2m}$。\n此级数中 $q^n$ 的系数在 $n$ 为偶数时是 $2^{k-1} a_{n/2}$，在 $n$ 为奇数时是 $0$。\n\n**第 2 项：$\\frac{1}{2} f\\left(\\frac{z}{2}\\right)$**\n$$f\\left(\\frac{z}{2}\\right) = \\sum_{m=0}^{\\infty} a_m e^{2\\pi i m (z/2)} = \\sum_{m=0}^{\\infty} a_m (e^{\\pi i z})^m = \\sum_{m=0}^{\\infty} a_m (q^{1/2})^m$$\n这是一个关于 $q^{1/2}$ 的级数，而不是 $q$。\n\n**第 3 项：$\\frac{1}{2} f\\left(\\frac{z+1}{2}\\right)$**\n$$f\\left(\\frac{z+1}{2}\\right) = \\sum_{m=0}^{\\infty} a_m e^{2\\pi i m (z+1)/2} = \\sum_{m=0}^{\\infty} a_m e^{\\pi i m z} e^{\\pi i m} = \\sum_{m=0}^{\\infty} a_m (q^{1/2})^m (-1)^m$$\n因为 $e^{\\pi i} = -1$。\n\n现在，我们合并第 2 项和第 3 项：\n$$\\frac{1}{2} \\left[ f\\left(\\frac{z}{2}\\right) + f\\left(\\frac{z+1}{2}\\right) \\right] = \\frac{1}{2} \\left[ \\sum_{m=0}^{\\infty} a_m q^{m/2} + \\sum_{m=0}^{\\infty} a_m (-1)^m q^{m/2} \\right]$$\n$$ = \\frac{1}{2} \\sum_{m=0}^{\\infty} a_m (1 + (-1)^m) q^{m/2}$$\n项 $(1 + (-1)^m)$ 在 $m$ 为偶数时为 $2$，在 $m$ 为奇数时为 $0$。\n所以，我们只对偶数 $m$ 求和。设 $m=2n$。\n$$ = \\frac{1}{2} \\sum_{n=0}^{\\infty} a_{2n} (1 + (-1)^{2n}) q^{(2n)/2} = \\frac{1}{2} \\sum_{n=0}^{\\infty} a_{2n} (2) q^n = \\sum_{n=0}^{\\infty} a_{2n} q^n$$\n这是一个漂亮的简化。这是一个非常标准的技巧。问题陈述中提到“使用关于单位根上指数和的成熟结论”。这正是该结论的应用。\n更一般地，$\\sum_{r=0}^{p-1} e^{2\\pi i m r / p}$ 在 $p$ 整除 $m$ 时为 $p$，否则为 $0$。\n这里，$\\sum_{r=0}^{p-1} f\\left(\\frac{z+r}{p}\\right) = \\sum_{r=0}^{p-1} \\sum_{m=0}^{\\infty} a_m e^{2\\pi i m (z+r)/p} = \\sum_{m=0}^{\\infty} a_m e^{2\\pi i m z / p} \\sum_{r=0}^{p-1} e^{2\\pi i m r / p}$。\n内层和为 $p \\cdot \\delta_{p|m}$（克罗内克（Kronecker）$\\delta$ 函数，条件为 $p$ 整除 $m$）。\n所以该和为 $\\sum_{m=0, p|m}^{\\infty} a_m e^{2\\pi i m z/p} \\cdot p$。设 $m=np$。\n这变为 $\\sum_{n=0}^{\\infty} a_{np} e^{2\\pi i (np) z/p} \\cdot p = p \\sum_{n=0}^{\\infty} a_{np} e^{2\\pi i n z} = p \\sum_{n=0}^{\\infty} a_{np} q^n$。\n所以，$T_p$ 公式的第二部分是：\n$$p^{-1} \\sum_{r=0}^{p-1} f\\left(\\frac{z+r}{p}\\right) = p^{-1} \\left( p \\sum_{n=0}^{\\infty} a_{np} q^n \\right) = \\sum_{n=0}^{\\infty} a_{np} q^n$$\n这验证了我对 $p=2$ 的推导。\n\n所以，我们得到了 $(T_2 f)(z)$ 的 $q$-展开式的完整公式：\n$$(T_2 f)(z) = \\sum_{n=0}^{\\infty} c_n q^n = \\left( 2^{k-1} \\sum_{m=0}^{\\infty} a_m q^{2m} \\right) + \\left( \\sum_{n=0}^{\\infty} a_{2n} q^n \\right)$$\n现在我们求这个和中 $q^n$ 的系数 $c_n$。\n第一个求和对 $q^n$ 的系数有贡献，当且仅当 $n$ 是偶数。设 $n=2m$，则贡献来自求和的第 $m$ 项，即 $2^{k-1} a_m q^{2m} = 2^{k-1} a_{n/2} q^n$。\n第二个求和贡献了 $a_{2n} q^n$ 这一项。\n\n所以，对于给定的 $n$：\n系数 $c_n$ 是来自两部分的 $q^n$ 系数之和。\n来自 $2^{k-1} f(2z)$ 的 $q^n$ 系数是：\n- 如果 $n$ 是偶数，为 $2^{k-1} a_{n/2}$。\n- 如果 $n$ 是奇数，为 $0$。\n\n来自 $\\frac{1}{2} \\sum_{r=0}^{1} f\\left(\\frac{z+r}{2}\\right)$ 的 $q^n$ 系数是：\n- $a_{2n}$\n\n将它们组合起来：\n$$c_n = a_{2n} + \\begin{cases} 2^{k-1} a_{n/2}  \\text{若 } n \\text{ 为偶数} \\\\ 0  \\text{若 } n \\text{ 为奇数} \\end{cases}$$\n所以，\n$$c_n = a_{2n} \\qquad \\text{若 } n \\text{ 为奇数}$$\n$$c_n = a_{2n} + 2^{k-1} a_{n/2} \\qquad \\text{若 } n \\text{ 为偶数}$$\n\n我们来分析截断展开所需的系数。给定 $f(z) = \\sum_{n=0}^{10} a_n q^n$，这意味着对于 $n > 10$，$a_n = 0$。我们希望计算 $(T_2 f)(z) = \\sum_{n=0}^{10} c_n q^n$ 的系数 $c_n$。\n\n对于 $n \\in \\{0, 1, \\dots, 10\\}$，系数 $c_n$ 由推导出的公式给出，其中任何 $m>10$ 的系数 $a_m$ 都被视为 $0$。\n\n- 对于 $n=0$ (偶数): $c_0 = a_0 + 2^{k-1} a_0 = (1 + 2^{k-1})a_0$。\n- 对于 $n=1$ (奇数): $c_1 = a_2$。\n- 对于 $n=2$ (偶数): $c_2 = a_4 + 2^{k-1} a_1$。\n- 对于 $n=3$ (奇数): $c_3 = a_6$。\n- 对于 $n=4$ (偶数): $c_4 = a_8 + 2^{k-1} a_2$。\n- 对于 $n=5$ (奇数): $c_5 = a_{10}$。\n- 对于 $n=6$ (偶数): $c_6 = a_{12} + 2^{k-1} a_3$。因为 $12 > 10$，$a_{12}=0$，所以 $c_6 = 2^{k-1} a_3$。\n- 对于 $n=7$ (奇数): $c_7 = a_{14}$。因为 $14 > 10$，$a_{14}=0$，所以 $c_7 = 0$。\n- 对于 $n=8$ (偶数): $c_8 = a_{16} + 2^{k-1} a_4$。因为 $16 > 10$，$a_{16}=0$，所以 $c_8 = 2^{k-1} a_4$。\n- 对于 $n=9$ (奇数): $c_9 = a_{18}$。因为 $18 > 10$，$a_{18}=0$，所以 $c_9 = 0$。\n- 对于 $n=10$ (偶数): $c_{10} = a_{20} + 2^{k-1} a_5$。因为 $20 > 10$，$a_{20}=0$，所以 $c_{10} = 2^{k-1} a_5$。\n\n这些具体公式提供了从 $[a_0, \\dots, a_{10}]$ 和权 $k$ 计算系数 $[c_0, \\dots, c_{10}]$ 的完整算法。\n\n$T_2$ 算子的线性是一个基本性质。给定两个函数 $f$ 和 $g$，其傅里叶系数分别为 $a_n$ 和 $b_n$，以及标量 $\\alpha, \\beta \\in \\mathbb{C}$，函数 $h = \\alpha f + \\beta g$ 的系数为 $d_n = \\alpha a_n + \\beta b_n$。对 $(T_2 h)(z)$ 的系数（记为 $e_n$）应用推导出的规则：\n对于奇数 $n$，$e_n = d_{2n} = \\alpha a_{2n} + \\beta b_{2n} = \\alpha c_n^{(f)} + \\beta c_n^{(g)}$，其中 $c_n^{(f)}$ 和 $c_n^{(g)}$ 分别是 $(T_2 f)(z)$ 和 $(T_2 g)(z)$ 的系数。\n对于偶数 $n$，$e_n = d_{2n} + 2^{k-1} d_{n/2} = (\\alpha a_{2n} + \\beta b_{2n}) + 2^{k-1}(\\alpha a_{n/2} + \\beta b_{n/2}) = \\alpha(a_{2n} + 2^{k-1}a_{n/2}) + \\beta(b_{2n} + 2^{k-1}b_{n/2}) = \\alpha c_n^{(f)} + \\beta c_n^{(g)}$。\n因此，线性逐系数成立，$T_2(\\alpha f + \\beta g) = \\alpha T_2 f + \\beta T_2 g$。程序将对指定的测试用例进行数值验证。\n\n实现将包括一个函数，该函数将推导出的规则应用于一个包含 11 个系数的向量。然后，此函数将用于执行五个指定测试用例的计算和线性检查。", "answer": "```python\nimport numpy as np\n\ndef apply_T2(coeffs_a, k):\n    \"\"\"\n    Computes the action of the Hecke operator T_2 on a truncated q-expansion.\n\n    Args:\n        coeffs_a (np.ndarray): An array of 11 coefficients [a_0, ..., a_10].\n        k (int): The integer weight of the modular form, k >= 2.\n\n    Returns:\n        np.ndarray: An array of 11 coefficients for (T_2 f)(z).\n    \"\"\"\n    coeffs_c = np.zeros(11, dtype=np.int64)\n    p = 2\n    \n    # Pre-calculate a term that is used repeatedly\n    pk_minus_1 = p**(k - 1)\n\n    for n in range(11):\n        # Term a_{2n}\n        a_2n = 0\n        if 2 * n = 10:\n            a_2n = coeffs_a[2 * n]\n\n        # Term p^{k-1} * a_{n/p}\n        a_n_div_p = 0\n        if n % p == 0:\n            # For p=2, this means n is even\n            a_n_div_p = pk_minus_1 * coeffs_a[n // p]\n        \n        coeffs_c[n] = a_2n + a_n_div_p\n\n    return coeffs_c\n\ndef solve():\n    \"\"\"\n    Runs the five test cases specified in the problem statement and formats the output.\n    \"\"\"\n    results = []\n\n    # Test 1: Direct computation\n    k1 = 4\n    a1 = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], dtype=np.int64)\n    c1 = apply_T2(a1, k1)\n    results.append(c1.tolist())\n\n    # Test 2: Linearity check, general case\n    k2 = 6\n    f_coeffs2 = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], dtype=np.int64)\n    g_coeffs2 = np.array([0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0], dtype=np.int64)\n    alpha2, beta2 = 3, -2\n    \n    lhs_coeffs = apply_T2(alpha2 * f_coeffs2 + beta2 * g_coeffs2, k2)\n    rhs_coeffs = alpha2 * apply_T2(f_coeffs2, k2) + beta2 * apply_T2(g_coeffs2, k2)\n    is_linear2 = np.array_equal(lhs_coeffs, rhs_coeffs)\n    results.append(is_linear2)\n    \n    # Test 3: Constant form edge case\n    k3 = 8\n    a3 = np.array([5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], dtype=np.int64)\n    c3 = apply_T2(a3, k3)\n    results.append(c3.tolist())\n\n    # Test 4: Boundary handling\n    k4 = 2\n    a4 = np.array([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], dtype=np.int64)\n    c4 = apply_T2(a4, k4)\n    results.append(c4.tolist())\n\n    # Test 5: Linearity check, degenerate scalars\n    k5 = 10\n    f_coeffs5 = np.array([2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31], dtype=np.int64)\n    g_coeffs5 = np.array([1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1], dtype=np.int64)\n    alpha5, beta5 = 0, 0\n\n    lhs_coeffs5 = apply_T2(alpha5 * f_coeffs5 + beta5 * g_coeffs5, k5)\n    rhs_coeffs5 = alpha5 * apply_T2(f_coeffs5, k5) + beta5 * apply_T2(g_coeffs5, k5)\n    is_linear5 = np.array_equal(lhs_coeffs5, rhs_coeffs5)\n    results.append(is_linear5)\n    \n    # Format the final output string according to the problem specification (no spaces).\n    formatted_results = []\n    for res in results:\n        if isinstance(res, list):\n            # Format lists as [i,j,k] with no spaces\n            formatted_results.append(f\"[{','.join(map(str, res))}]\")\n        elif isinstance(res, (bool, np.bool_)):\n            # Format booleans as True or False\n            formatted_results.append(str(bool(res)).title())\n        else:\n            # Fallback for other types\n            formatted_results.append(str(res))\n            \n    # The boolean conversion needs to be careful with numpy types.\n    # The output format requests \"True\" or \"False\", not \"true\" or \"false\".\n    # str(True) is \"True\", which is correct. str(False) is \"False\", which is correct.\n    print(f\"[{','.join(formatted_results)}]\"\n          .replace(\"True\", \"true\").replace(\"False\", \"false\")\n          .replace(\"true\", \"True\").replace(\"false\", \"False\"))\n\nsolve()\n```", "id": "3085846"}, {"introduction": "理论的威力在于其解决问题的能力。对于归一化赫克特征形式，$T_n$ 算子的特征值恰好是其第 $n$ 个傅里叶系数，这一性质极为强大。它为我们判定两个特征形式是否相等提供了一座桥梁，将一个看似需要无限次验证的问题转化为有限步的计算。这个高级练习要求你综合运用赫克特征值的性质和数论中的一个深刻结果——施图姆界 (Sturm bound)，来设计一个算法，以有限的计算量确定两个给定的赫克特征形式是否完全相同。这完美地展示了如何利用理论工具解决实际的计算问题。[@problem_id:3085771]", "problem": "设计并实现一个程序，该程序对于给定的、在同余子群 $\\Gamma_0(N)$ 上权重为 $k$ 的尖点形式空间中的成对归一化 Hecke 特征形式，通过仅检查有限多个 Hecke 算子 $T_n$ 来判断每对形式是否共享所有 Hecke 特征值。该判定必须由一个基于基本定义和 Sturm 界推出的、有原理依据的算法来证明。\n\n可供使用的定义和基本事实：\n- 一个权重为 $k$、水平为 $N$ 的模形式具有傅里叶展开 $f(z) = \\sum_{n \\ge 0} a_n q^n$，其中 $q = e^{2\\pi i z}$，而一个尖点形式有 $a_0 = 0$。尖点形式的空间记为 $S_k(\\Gamma_0(N))$。\n- 对于归一化 Hecke 特征形式 $f \\in S_k(\\Gamma_0(N))$，Hecke 算子 $T_n$ 的作用满足 $T_n f = a_n f$，对所有 $n \\ge 1$ 成立，其中 $a_n$ 是第 $n$ 个傅里叶系数，归一化意味着 $a_1 = 1$。\n- 水平为 $N$ 的 Hecke 代数由 $T_n$（$n \\ge 1$）生成（对于素数 $p \\mid N$，通常写作 $U_p$，但其在归一化特征形式上的特征值仍然是傅里叶系数 $a_p$）。\n- Sturm 界：如果 $f, g \\in M_k(\\Gamma_0(N))$ 是具有相同权重和水平的模形式，其傅里叶系数分别为 $a_n$ 和 $b_n$，并且如果对于所有 $1 \\le n \\le B$ 都有 $a_n = b_n$，其中\n$$\nB \\;=\\; \\left\\lfloor \\frac{k}{12} \\cdot \\left[ \\mathrm{SL}_2(\\mathbb{Z}) : \\Gamma_0(N) \\right] \\right\\rfloor,\n$$\n那么 $f = g$。该指数满足\n$$\n\\left[ \\mathrm{SL}_2(\\mathbb{Z}) : \\Gamma_0(N) \\right] \\;=\\; N \\prod_{p \\mid N} \\left(1 + \\frac{1}{p}\\right),\n$$\n其中乘积遍及 $N$ 的所有不同素因子 $p$。\n\n任务：\n- 仅使用上述原理，推导一个算法来判定两个给定的、在 $S_k(\\Gamma_0(N))$ 中的归一化 Hecke 特征形式是否共享所有 Hecke 特征值，方法是检查有限多个 $T_n$。您的算法必须利用 Sturm 界以及 $T_n$ 特征值与 $q$-展开系数之间的关系，将无限验证问题简化为有限检查。\n- 将此算法实现为一个程序。该程序必须是自包含的，没有外部输入：它必须包含一个内部测试套件，其中包含由其初始 $q$-展开系数表示的成对归一化特征形式，以及它们对应的水平 $N$ 和权重 $k$，并为每个案例输出判定结果。\n\n测试套件：\n在您的程序中提供以下四个测试用例。每个测试用例是一个元组，包含 $(N, k, \\text{coeffs}_f, \\text{coeffs}_g)$，其中 $\\text{coeffs}_f$ 和 $\\text{coeffs}_g$ 是两个在 $S_k(\\Gamma_0(N))$ 中的归一化 Hecke 特征形式 $f$ 和 $g$ 的前几个傅里叶系数 $(a_1, a_2, \\dots, a_L)$ 和 $(b_1, b_2, \\dots, b_L)$ 的列表：\n1. $(N, k) = (\\,11,\\, 2\\,)$，其中\n   $\\text{coeffs}_f = [\\,1,\\,-1,\\,-1,\\,1,\\,0,\\,-1,\\,1,\\,0,\\,-1,\\,1,\\,0,\\,-1\\,]$ 和\n   $\\text{coeffs}_g = [\\,1,\\,-1,\\,-1,\\,1,\\,0,\\,-1,\\,1,\\,0,\\,-1,\\,1,\\,0,\\,-1\\,]$。\n2. $(N, k) = (\\,6,\\, 4\\,)$，其中\n   $\\text{coeffs}_f = [\\,1,\\,0,\\,-2,\\,3,\\,0,\\,-1\\,]$ 和\n   $\\text{coeffs}_g = [\\,1,\\,0,\\,5,\\,3,\\,0,\\,-1\\,]$。\n3. $(N, k) = (\\,6,\\, 2\\,)$，其中\n   $\\text{coeffs}_f = [\\,1,\\,-1,\\,2,\\,0\\,]$ 和\n   $\\text{coeffs}_g = [\\,1,\\,2,\\,2,\\,0\\,]$。\n4. $(N, k) = (\\,15,\\, 6\\,)$，其中\n   $\\text{coeffs}_f = [\\,1,\\,1,\\,-1,\\,0,\\,2,\\,-2,\\,1,\\,0,\\,-1,\\,3,\\,-2,\\,0\\,]$ 和\n   $\\text{coeffs}_g = [\\,1,\\,1,\\,-1,\\,0,\\,2,\\,-2,\\,1,\\,0,\\,-1,\\,3,\\,-2,\\,0\\,]$。\n\n假设：\n- 对于其 $(N, k)$，每个列表 $\\text{coeffs}_f$ 和 $\\text{coeffs}_g$ 至少包含 $B$ 项，因此 Sturm 界检查是适定的。\n- 所有形式都是归一化 Hecke 特征形式，因此对于所有 $n \\ge 1$，它们的 $T_n$ 特征值等于其傅里叶系数 $a_n$，并满足 $a_1 = 1$。\n\n要求输出：\n- 对于每个测试用例，您的程序必须输出一个布尔值，指示这两种形式是否共享所有 Hecke 特征值，该结果由基于 Sturm 界的有限检查所证明。\n- 您的程序应生成单行输出，其中包含四个测试用例的结果，形式为方括号内以逗号分隔的布尔值列表，例如，\"[True,False,True,False]\"。输出中不允许有空格。", "solution": "### 基于原理的算法推导\n\n目标是确定两个在 $S_k(\\Gamma_0(N))$ 中的归一化 Hecke 特征形式 $f(z) = \\sum_{n=1}^\\infty a_n q^n$ 和 $g(z) = \\sum_{n=1}^\\infty b_n q^n$ 是否共享它们所有的 Hecke 特征值。\n\n1.  **将 Hecke 特征值与傅里叶系数关联**：问题陈述，对于一个归一化 Hecke 特征形式，其在 Hecke 算子 $T_n$ 下的特征值是它的第 $n$ 个傅里叶系数。对于 $f$，特征值为 $\\{a_n\\}_{n \\ge 1}$，对于 $g$，特征值为 $\\{b_n\\}_{n \\ge 1}$。因此，这两个形式共享所有 Hecke 特征值的充要条件是对于所有整数 $n \\ge 1$ 都有 $a_n = b_n$。\n\n2.  **形式的等价性**：如果对所有 $n \\ge 1$ 都有 $a_n = b_n$，那么它们的傅里叶级数是相同的：$\\sum_{n=1}^\\infty a_n q^n = \\sum_{n=1}^\\infty b_n q^n$。这意味着形式本身是相同的，即 $f = g$。反之，如果 $f = g$，它们的傅里叶展开必须相同，这意味着对所有 $n \\ge 1$ 都有 $a_n = b_n$。因此，该问题等价于判断是否 $f = g$。\n\n3.  **将无限检查简化为有限检查**：对所有无限多个 $n$ 验证 $a_n = b_n$ 在计算上是不可行的。问题正是为此目的提供了 Sturm 界。该定理指出，对于同一空间 $M_k(\\Gamma_0(N))$ 中（包括其尖点形式子空间 $S_k(\\Gamma_0(N))$）的任意两个模形式，如果它们的傅里叶系数在一个特定的有限界限内一致，那么这两个形式是相同的。\n\n4.  **算法**：因此，判定过程如下：\n    a. 对于给定的水平 $N$ 和权重 $k$，首先计算 Sturm 界 $B$。这需要计算指数 $\\mu_N = \\left[ \\mathrm{SL}_2(\\mathbb{Z}) : \\Gamma_0(N) \\right]$。\n    b. 指数使用提供的公式计算：\n       $$ \\mu_N = N \\prod_{p \\mid N} \\left(1 + \\frac{1}{p}\\right) $$\n       其中乘积遍及 $N$ 的不同素因子。这可以通过首先找到 $N$ 的不同素因子然后应用该公式来计算。为了进行稳健的整数运算，这等价于 $\\mu_N = \\prod_{p | N} (p^{v_p(N)} + p^{v_p(N)-1})$，其中 $v_p(N)$ 是 $p$ 在 $N$ 的素数分解中的指数。\n    c. 一旦指数 $\\mu_N$ 已知，Sturm 界 $B$ 的计算公式为：\n       $$ B = \\left\\lfloor \\frac{k \\cdot \\mu_N}{12} \\right\\rfloor $$\n    d. 现在，比较从 $1$ 到 $B$ 的所有整数 $n$ 的傅里叶系数 $a_n$ 和 $b_n$。问题保证系数列表足够长。\n    e. 如果对于所有 $n \\in \\{1, 2, \\dots, B\\}$ 都有 $a_n = b_n$，则 Sturm 界定理证明 $f = g$。如前所述，这意味着它们共享所有 Hecke 特征值。结果为 `True`。\n    f. 如果我们找到哪怕一个整数 $n_0 \\in \\{1, 2, \\dots, B\\}$ 使得 $a_{n_0} \\neq b_{n_0}$，那么形式 $f$ 和 $g$ 就不相同。它们的傅里叶级数不同，意味着它们不共享所有 Hecke 特征值。结果为 `False`。\n\n该算法通过执行有限次数的比较来提供确定性答案，直接实现了问题陈述中给出的原理。实现将对每个测试用例遵循这些步骤。", "answer": "```python\nimport numpy as np\n\ndef get_distinct_prime_factors(n):\n    \"\"\"\n    Computes the set of distinct prime factors of an integer n.\n    \"\"\"\n    factors = set()\n    d = 2\n    temp_n = n\n    while d * d = temp_n:\n        if temp_n % d == 0:\n            factors.add(d)\n            while temp_n % d == 0:\n                temp_n //= d\n        d += 1\n    if temp_n > 1:\n        factors.add(temp_n)\n    return factors\n\ndef are_hecke_eigenforms_identical(N, k, coeffs_f, coeffs_g):\n    \"\"\"\n    Determines if two normalized Hecke eigenforms are identical using the Sturm bound.\n\n    Args:\n        N (int): The level of the congruence subgroup Gamma_0(N).\n        k (int): The weight of the modular forms.\n        coeffs_f (list): The first Fourier coefficients of form f.\n        coeffs_g (list): The first Fourier coefficients of form g.\n\n    Returns:\n        bool: True if the forms are identical, False otherwise.\n    \"\"\"\n    # Step 1: Calculate the index [SL_2(Z) : Gamma_0(N)].\n    # The index is given by N * product_{p|N} (1 + 1/p).\n    # We use integer arithmetic to avoid floating point issues.\n    prime_factors = get_distinct_prime_factors(N)\n    \n    index = N\n    for p in prime_factors:\n        index = index * (p + 1) // p\n    \n    # Step 2: Calculate the Sturm bound B.\n    # B = floor(k/12 * index)\n    sturm_bound = (k * index) // 12\n    \n    # Step 3: Compare Fourier coefficients up to the Sturm bound.\n    # The problem guarantees that the coefficient lists are long enough.\n    # We check coefficients a_n for n from 1 to B.\n    # In the 0-indexed list, this corresponds to indices 0 to B-1.\n    for i in range(sturm_bound):\n        if coeffs_f[i] != coeffs_g[i]:\n            return False # A mismatch implies the forms are different.\n            \n    # If all coefficients up to the bound match, the forms are identical.\n    return True\n\ndef solve():\n    \"\"\"\n    Solves the problem of determining if pairs of Hecke eigenforms are identical\n    by applying the Sturm bound.\n    \"\"\"\n    # Test suite as specified in the problem statement.\n    # Each case is a tuple: (N, k, coeffs_f, coeffs_g)\n    # coeffs are 1-indexed Fourier coefficients a_n, stored in 0-indexed lists.\n    test_cases = [\n        (11, 2, \n         [1, -1, -1, 1, 0, -1, 1, 0, -1, 1, 0, -1], \n         [1, -1, -1, 1, 0, -1, 1, 0, -1, 1, 0, -1]),\n        (6, 4, \n         [1, 0, -2, 3, 0, -1], \n         [1, 0, 5, 3, 0, -1]),\n        (6, 2, \n         [1, -1, 2, 0], \n         [1, 2, 2, 0]),\n        (15, 6, \n         [1, 1, -1, 0, 2, -2, 1, 0, -1, 3, -2, 0], \n         [1, 1, -1, 0, 2, -2, 1, 0, -1, 3, -2, 0])\n    ]\n\n    results = []\n    for N, k, coeffs_f, coeffs_g in test_cases:\n        decision = are_hecke_eigenforms_identical(N, k, coeffs_f, coeffs_g)\n        results.append(decision)\n\n    # Format the final output as a single-line string.\n    print(f\"[{','.join(map(lambda x: str(x).title(), results))}]\")\n\nsolve()\n```", "id": "3085771"}]}