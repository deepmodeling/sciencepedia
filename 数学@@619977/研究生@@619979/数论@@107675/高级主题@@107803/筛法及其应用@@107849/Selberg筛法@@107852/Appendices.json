{"hands_on_practices": [{"introduction": "应用塞尔伯格筛法的第一步是理解序列在剩余类中的分布。这需要计算局部密度 $\\rho(p)$，并将其合成为主项因子 $V(z)$。本练习 [@problem_id:3029476] 提供了为经典且重要的序列 $f(n) = n^2 + 1$ 推导 $V(z)$ 的实践机会，这项任务将筛法理论与二次剩余的性质以及素数在算术级数中的分布联系起来。", "problem": "设 $f(n) = n^{2} + 1$，并设 $A = \\{1 \\leq n \\leq x\\}$，其中 $x \\geq 2$ 是一个大的实参数。对于一个满足 $2 \\leq z \\leq x^{1/10}$ 的实参数 $z$，记 $P(z) = \\prod_{p  z} p$ 为所有小于 $z$ 的素数的乘积。考虑估计筛选集合\n$$\nS(A,z) = \\#\\{1 \\leq n \\leq x : \\gcd(f(n), P(z)) = 1\\}\n$$\n的大小的问题。\n使用 Selberg 筛法的框架，从多项式序列的标准局部数据出发，推导控制着模素数剩余类移除的乘性局部密度。具体而言：\n\n- 对每个素数 $p$，定义 $\\rho(p)$ 为满足 $f(a) \\equiv 0 \\pmod{p}$ 的剩余类 $a \\pmod{p}$ 的数量。\n- 仅使用二次剩余理论和算术级数中素数分布理论中经过充分检验的事实，即对于奇素数 $p$，同余式 $n^{2} \\equiv -1 \\pmod{p}$ 有解当且仅当 $p \\equiv 1 \\pmod{4}$，此时它恰有两个模 $p$ 的解；而 $n^{2} \\equiv -1 \\pmod{2}$ 恰有一个模 $2$ 的解。\n- 使用当 $z \\to \\infty$ 时，\n$$\n\\sum_{\\substack{p \\leq z \\\\ p \\equiv 1 \\, (\\bmod\\, 4)}} \\frac{1}{p} = \\frac{1}{2} \\ln \\ln z + M_{1} + o(1),\n$$\n其中 $M_{1}$ 是一个绝对常数，并且 $\\sum_{\\substack{p \\equiv 1 \\, (\\bmod\\, 4)}} \\frac{1}{p^{2}}$ 收敛。\n\n从 Selberg 筛法的基本原理和刚才描述的乘性局部密度出发，推导主项 $V(z)$ 的显式欧拉乘积表达式，该主项预测了集合 $A$ 中满足 $f(n)$ 不含小于 $z$ 的素因子的元素比例。然后，从上述引用的素数和的渐近式，推导出当 $z \\to \\infty$ 时 $V(z)$ 的主阶渐进行为，并将其中的隐含常数通过一个关于素数的收敛级数表示为封闭解析形式。\n\n最后，给出 $V(z)$ 的显式解析表达式，以及满足 $f(n)$ 不含小于 $z$ 的素因子的整数 $n \\leq x$ 的比例的主阶渐近估计（在 Selberg 筛法下，这一比例的一阶近似预测为 $V(z)$）。你的最终答案必须是单个解析表达式或由解析表达式组成的行矩阵。不需要数值近似或四舍五入。", "solution": "用户希望使用 Selberg 筛法解决一个数论问题。\n\n### 问题验证\n\n**步骤一：提取已知条件**\n- 函数为 $f(n) = n^{2} + 1$。\n- 待筛选的集合源于大实参数 $x \\geq 2$ 下的整数集合 $A = \\{1 \\leq n \\leq x\\}$。\n- 筛选素数是那些小于 $z$ 的素数，其中 $2 \\leq z \\leq x^{1/10}$。这些素数的乘积为 $P(z) = \\prod_{p  z} p$。\n- 筛选集合为 $S(A,z) = \\#\\{1 \\leq n \\leq x : \\gcd(f(n), P(z)) = 1\\}$。\n- 对于每个素数 $p$，$\\rho(p)$ 是同余方程 $f(a) \\equiv 0 \\pmod{p}$ 的解的数量。\n- $\\rho(p)$ 的值由同余方程 $n^2 \\equiv -1 \\pmod{p}$ 的解的数量确定：\n    - 对 $p=2$，有一个解（$n=1$），因此 $\\rho(2)=1$。\n    - 对奇素数 $p$，若 $p \\equiv 1 \\pmod{4}$，则有两个解，因此 $\\rho(p)=2$。\n    - 对奇素数 $p$，若 $p \\equiv 3 \\pmod{4}$，则没有解，因此 $\\rho(p)=0$。\n- 提供了以下渐近公式：当 $z \\to \\infty$ 时，\n$$\n\\sum_{\\substack{p \\leq z \\\\ p \\equiv 1 \\, (\\bmod\\, 4)}} \\frac{1}{p} = \\frac{1}{2} \\ln \\ln z + M_{1} + o(1),\n$$\n其中 $M_1$ 为某个常数。\n- 同时给定级数 $\\sum_{\\substack{p \\equiv 1 \\, (\\bmod\\, 4)}} \\frac{1}{p^{2}}$ 收敛。\n\n**步骤二：使用提取的条件进行验证**\n该问题是解析数论中筛法的一个标准应用。\n- **科学性**：该问题基于数论的既定原理，包括二次剩余的性质和算术级数中的素数分布。Selberg 筛法是该领域的基本工具。所有前提条件均符合事实。\n- **良定性**：问题陈述清晰，要求推导一个标准量 $V(z)$ 及其渐进行为。所提供的信息足以且必要地得出一个唯一的、有意义的解。\n- **客观性**：问题以精确的数学语言表述，没有歧义或主观论断。\n\n**步骤三：结论与行动**\n问题有效。现在开始求解过程。\n\n### 解的推导\n\n问题要求两个主要结果：在 Selberg 筛法背景下主项密度 $V(z)$ 的显式公式，及其主阶渐进行为。\n\n**第一部分：$V(z)$ 的欧拉乘积**\n\n在筛法理论中，经过小于 $z$ 的素数筛选后剩余元素的比例，可以通过启发式方法由局部存活密度的乘积给出。对一个素数 $p$，有 $\\rho(p)$ 个模 $p$ 的“禁止”剩余类。对于一个随机整数 $n$，$f(n)$ 能被 $p$ 整除的概率为 $\\rho(p)/p$。因此 $f(n)$ 不能被 $p$ 整除的概率是 $1 - \\rho(p)/p$。假设对不同素数是独立的，则 $f(n)$ 不能被任何小于 $z$ 的素数 $p$ 整除的 $n$ 的比例由这些素数的乘积给出。\n\n这个量记为 $V(z)$，定义为：\n$$\nV(z) = \\prod_{pz} \\left(1 - \\frac{\\rho(p)}{p}\\right)\n$$\n对于多项式 $f(n) = n^2+1$，我们已知 $\\rho(p)$ 的值：\n- $\\rho(2) = 1$\n- 若 $p \\equiv 1 \\pmod{4}$，则 $\\rho(p) = 2$\n- 若 $p \\equiv 3 \\pmod{4}$，则 $\\rho(p) = 0$\n\n将这些代入 $V(z)$ 的定义中：\n$$\nV(z) = \\left(1 - \\frac{\\rho(2)}{2}\\right) \\prod_{2  p  z} \\left(1 - \\frac{\\rho(p)}{p}\\right)\n$$\n$$\nV(z) = \\left(1 - \\frac{1}{2}\\right) \\prod_{\\substack{2  p  z \\\\ p \\equiv 1 \\pmod{4}}} \\left(1 - \\frac{2}{p}\\right) \\prod_{\\substack{2  p  z \\\\ p \\equiv 3 \\pmod{4}}} \\left(1 - \\frac{0}{p}\\right)\n$$\n第二个乘积是各项均为 1 的乘积。由于素数 2 不满足 $p \\equiv 1 \\pmod 4$，我们可以将表达式简化为：\n$$\nV(z) = \\frac{1}{2} \\prod_{\\substack{p  z \\\\ p \\equiv 1 \\pmod{4}}} \\left(1 - \\frac{2}{p}\\right)\n$$\n这就是 $V(z)$ 的显式欧拉乘积表达式。\n\n**第二部分：$V(z)$ 的渐进行为**\n\n为了找到当 $z \\to \\infty$ 时 $V(z)$ 的渐进行为，我们分析这个乘积。一个关键步骤是将项 $(1 - 2/p)$ 与出现在 Mertens 定理中更标准的项 $(1-1/p)$ 联系起来。我们使用恒等式：\n$$\n1 - \\frac{2}{p} = \\left(1 - \\frac{1}{p}\\right)^2 \\frac{1 - 2/p}{(1-1/p)^2} = \\left(1 - \\frac{1}{p}\\right)^2 \\frac{p(p-2)}{(p-1)^2} = \\left(1 - \\frac{1}{p}\\right)^2 \\left(\\frac{p^2-2p}{p^2-2p+1}\\right) = \\left(1 - \\frac{1}{p}\\right)^2 \\left(1 - \\frac{1}{(p-1)^2}\\right)\n$$\n将此应用于 $V(z)$ 的表达式：\n$$\nV(z) = \\frac{1}{2} \\prod_{\\substack{p  z \\\\ p \\equiv 1 \\pmod{4}}} \\left[ \\left(1 - \\frac{1}{p}\\right)^2 \\left(1 - \\frac{1}{(p-1)^2}\\right) \\right]\n$$\n$$\nV(z) = \\frac{1}{2} \\left[ \\prod_{\\substack{p  z \\\\ p \\equiv 1 \\pmod{4}}} \\left(1 - \\frac{1}{(p-1)^2}\\right) \\right] \\left[ \\prod_{\\substack{p  z \\\\ p \\equiv 1 \\pmod{4}}} \\left(1 - \\frac{1}{p}\\right) \\right]^2\n$$\n第一个乘积在 $z \\to \\infty$ 时收敛，因为其项为 $1 - O(1/p^2)$ 且 $\\sum 1/p^2$ 收敛。令 $C_1 = \\prod_{p \\equiv 1 \\pmod{4}} \\left(1 - \\frac{1}{(p-1)^2}\\right)$。\n\n第二部分涉及乘积 $P_1(z) = \\prod_{pz, p\\equiv 1(4)} (1 - 1/p)$。我们使用关于算术级数的 Mertens 定理。令 $P_3(z) = \\prod_{pz, p\\equiv 3(4)} (1 - 1/p)$。\n所有奇素数的乘积为：\n$$\nP_1(z) P_3(z) = \\prod_{2  p  z} \\left(1 - \\frac{1}{p}\\right) = \\frac{\\prod_{pz}(1-1/p)}{1-1/2} = 2 \\prod_{pz}\\left(1 - \\frac{1}{p}\\right)\n$$\n根据 Mertens 第三定理，$\\prod_{pz}(1-1/p) \\sim e^{-\\gamma}/\\ln z$，其中 $\\gamma$ 是欧拉-马斯刻若尼常数。因此，\n$$\nP_1(z) P_3(z) \\sim \\frac{2e^{-\\gamma}}{\\ln z}\n$$\n现在，考虑模 4 的非主 Dirichlet 特征 $\\chi(n)$，其中若 $n\\equiv 1 \\pmod 4$ 则 $\\chi(n)=1$，若 $n\\equiv 3 \\pmod 4$ 则 $\\chi(n)=-1$，若 $n$ 是偶数则 $\\chi(n)=0$。Dirichlet L-函数 $L(s,\\chi) = \\sum_{n=1}^\\infty \\chi(n)n^{-s}$ 的值为 $L(1,\\chi) = \\pi/4$。\n$L(s,\\chi)$ 的欧拉乘积为 $\\prod_p (1-\\chi(p)p^{-s})^{-1}$。乘积 $\\prod_{p2} (1 - \\chi(p)/p)$ 收敛于 $L(1,\\chi)^{-1} = 4/\\pi$。我们可以将此乘积写为：\n$$\n\\lim_{z\\to\\infty} \\prod_{2  p  z} \\left(1 - \\frac{\\chi(p)}{p}\\right) = \\lim_{z\\to\\infty} \\left[ \\prod_{\\substack{pz \\\\ p\\equiv 1(4)}} \\left(1-\\frac{1}{p}\\right) \\prod_{\\substack{pz \\\\ p\\equiv 3(4)}} \\left(1+\\frac{1}{p}\\right) \\right] = \\frac{4}{\\pi}\n$$\n令 $P_3'(z) = \\prod_{pz, p\\equiv 3(4)} (1+1/p)$。则 $\\lim_{z\\to\\infty} P_1(z)P_3'(z) = 4/\\pi$。\n我们将 $P_3(z)$ 和 $P_3'(z)$ 联系起来：\n$$\nP_3(z) P_3'(z) = \\prod_{\\substack{pz \\\\ p\\equiv 3(4)}} \\left(1 - \\frac{1}{p^2}\\right) \\to C_3 = \\prod_{p\\equiv 3(4)} \\left(1 - \\frac{1}{p^2}\\right) \\quad \\text{当 } z \\to \\infty.\n$$\n从这些关系中，我们推断出 $P_1(z)$ 的渐进行为。\n$P_1(z) \\sim K_1 (\\ln z)^{-1/2}$ 且 $P_3(z) \\sim K_3 (\\ln z)^{-1/2}$，其中 $K_1, K_3$ 为某些常数。\n从 $P_1(z) P_3(z) \\sim 2e^{-\\gamma}/\\ln z$ 我们得到 $K_1 K_3 = 2e^{-\\gamma}$。\n从 $P_1(z) P_3'(z) \\to 4/\\pi$ 和 $P_3'(z) \\sim C_3/P_3(z) \\sim C_3/(K_3 (\\ln z)^{-1/2})$，我们得到\n$ (K_1 (\\ln z)^{-1/2}) (C_3 K_3^{-1} (\\ln z)^{1/2}) \\to \\frac{K_1 C_3}{K_3} = \\frac{4}{\\pi}$，所以 $\\frac{K_1}{K_3} = \\frac{4}{\\pi C_3}$。\n解出 $K_1^2$：\n$$\nK_1^2 = (K_1 K_3) \\left(\\frac{K_1}{K_3}\\right) = (2e^{-\\gamma})\\left(\\frac{4}{\\pi C_3}\\right) = \\frac{8e^{-\\gamma}}{\\pi \\prod_{p\\equiv 3(4)}(1-1/p^2)}\n$$\n因此，$P_1(z)^2 = \\left[ \\prod_{pz, p\\equiv 1(4)} (1 - 1/p) \\right]^2 \\sim K_1^2 (\\ln z)^{-1}$。\n\n最后，我们组合出 $V(z)$ 的渐近式：\n$$\nV(z) \\sim \\frac{1}{2} \\cdot C_1 \\cdot P_1(z)^2 \\sim \\frac{1}{2} \\left[ \\prod_{p \\equiv 1(4)} \\left(1 - \\frac{1}{(p-1)^2}\\right) \\right] \\left[ \\frac{8e^{-\\gamma}}{\\pi \\ln z \\prod_{p\\equiv 3(4)}(1-1/p^2)} \\right]\n$$\n$$\nV(z) \\sim \\frac{1}{\\ln z} \\cdot \\frac{4e^{-\\gamma}}{\\pi} \\frac{\\prod_{p \\equiv 1 \\pmod 4} \\left(1 - \\frac{1}{(p-1)^2}\\right)}{\\prod_{p\\equiv 3 \\pmod 4}\\left(1-1/p^2\\right)}\n$$\n这就是该比例的主阶渐近估计。\n\n### 结果总结\n\n1. $V(z)$ 的显式解析表达式为：\n$$ V(z) = \\frac{1}{2} \\prod_{\\substack{pz \\\\ p \\equiv 1 \\pmod 4}} \\left(1 - \\frac{2}{p}\\right) $$\n\n2. 满足 $f(n)$ 不含小于 $z$ 的素因子的整数 $n \\le x$ 的比例预测为 $V(z)$。其当 $z \\to \\infty$ 时的领先阶渐近估计是：\n$$ V(z) \\sim \\frac{C_f}{\\ln z}, \\quad \\text{其中 } C_f = \\frac{4e^{-\\gamma}}{\\pi} \\frac{\\prod_{p \\equiv 1 \\pmod 4} \\left(1 - \\frac{1}{(p-1)^2}\\right)}{\\prod_{p\\equiv 3 \\pmod 4}\\left(1-1/p^2\\right)} $$\n\n这两个表达式为问题提供了完整的答案。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{1}{2} \\prod_{\\substack{pz \\\\ p \\equiv 1 \\pmod 4}} \\left(1 - \\frac{2}{p}\\right)  \\frac{1}{\\ln z} \\frac{4e^{-\\gamma}}{\\pi} \\frac{\\prod_{p \\equiv 1 \\pmod 4} \\left(1 - \\frac{1}{(p-1)^2}\\right)}{\\prod_{p\\equiv 3 \\pmod 4}\\left(1-\\frac{1}{p^2}\\right)}\n\\end{pmatrix}\n}\n$$", "id": "3029476"}, {"introduction": "一次成功的筛法应用不仅需要一个主项估计，还需要对误差项进行精细的管理。塞尔伯格筛上界涉及到一个权衡：一方面是由 $V(z)$ 控制的主项大小，另一方面是由分布水平 $D$ 控制的累积误差。这个练习 [@problem_id:3029457] 将引导你完成优化筛法参数以获得尽可能紧的上界的基本过程，揭示筛法威力与局限性背后的核心机制。", "problem": "设 $X \\geq 3$ 为一个大数。考虑将经典的一维塞尔伯格筛法（Selberg sieve）应用于序列 $\\mathcal{A}=\\{1,2,\\dots,\\lfloor X\\rfloor\\}$，其中筛分素数集合为 $\\mathcal{P}$，筛分参数为 $z$。将被筛集合的塞尔伯格筛法上界写成以下形式\n$$\nS(\\mathcal{A},\\mathcal{P},z)\\ \\leq\\ X\\,V(z)\\,F(s)\\ +\\ \\sum_{d\\leq D}|R_d|,\n$$\n其中 $V(z)$ 是通常的筛分密度，$F(s)$ 是线性筛上界函数，其筛法参数为 $s=\\frac{\\ln D}{\\ln z}$，$R_d$ 是由以下偏差产生的余项\n$$\n\\sum_{\\substack{n\\leq X\\\\ n\\equiv 0\\ (\\mathrm{mod}\\ d)}}1\\ =\\ \\frac{X}{d}\\ +\\ R_d,\n$$\n对于无平方因子的 $d$。假设对于所有无平方因子的 $d\\leq D$，平凡余项界 $|R_d|\\leq 1$ 成立。\n\n仅使用关于一维塞尔伯格筛法和默滕斯定理（Mertens’ theorem）的公认结果，选择 $z$ 和 $D$（等价地，选择 $s$ 和 $D$），以在 $X\\to\\infty$ 的渐近情形下最小化右侧表达式 $X\\,V(z)\\,F(s)+\\sum_{d\\leq D}|R_d|$，并从筛法的基本原理出发证明你对 $s$ 的选择是合理的。你的最终答案应为最小化后上界的渐近主项，表示为关于 $X$ 的显式闭式解析表达式。无需进行舍入。", "solution": "用户希望我验证并解决一个关于优化一维塞尔伯格筛法上界的问题。\n\n### 第一步：提取已知条件\n- 被筛序列：$\\mathcal{A}=\\{1,2,\\dots,\\lfloor X\\rfloor\\}$，其中 $X \\geq 3$ 为大数。\n- 筛分集合：一个素数集合 $\\mathcal{P}$。\n- 筛分参数：$z$。\n- 筛法水平（或分布水平）：$D$。\n- 筛法参数：$s=\\frac{\\ln D}{\\ln z}$。\n- 上界不等式：$S(\\mathcal{A},\\mathcal{P},z) \\leq X\\,V(z)\\,F(s) + \\sum_{d\\leq D}|R_d|$。\n- 筛分密度：$V(z)$。\n- 筛函数：$F(s)$，线性筛上界函数。\n- 余项定义：对于无平方因子整数 $d$，$\\sum_{n\\leq X, n\\equiv 0 \\pmod{d}} 1 = \\frac{X}{d} + R_d$。\n- 余项界：对于所有无平方因子的 $d\\leq D$，有 $|R_d|\\leq 1$。\n- 任务：选择 $z$ 和 $D$（等价地，选择 $s$ 和 $D$）以在 $X\\to\\infty$ 的渐近极限下最小化不等式右侧。提供最小化后上界的主项，作为关于 $X$ 的闭式表达式。\n\n### 第二步：使用提取的已知条件进行验证\n问题陈述在科学上是合理的、适定的且客观的。\n- **科学合理性**：该问题是解析数论中的一个标准练习，特别是在筛法领域。塞尔伯格筛法上界的公式、参数 $s, z, D$ 的定义、筛分密度 $V(z)$ 以及余项 $R_d$ 的表述都与已有的文献（例如 Friedlander 和 Iwaniec 的《Opera de Cribro》，Halberstam 和 Richert 的《Sieve Methods》）一致。维度被指定为一，这对应于“线性筛”。使用默滕斯定理是恰当的。\n- **适定性**：任务是通过选择参数来最小化一个给定的表达式，这是一个明确定义的优化问题。寻找渐近主项是该领域的标准目标。\n- **客观性**：问题以精确的数学语言陈述，没有歧义或主观论断。\n\n该问题未违反任何无效性标准。这是一个与塞尔伯格筛法这一特定主题直接相关的、正式的、非平凡的数学问题。\n\n### 第三步：结论与行动\n问题有效。我将继续进行解答。\n\n### 解题推导\n\n目标是最小化上界表达式，我们将其表示为 $B$：\n$$\nB(z, D) = X\\,V(z)\\,F(s) + \\sum_{d\\leq D}|R_d|\n$$\n其中 $s = \\frac{\\ln D}{\\ln z}$。\n\n首先，我们确定表达式中各项的渐近形式。\n\n筛分作用于所有整数构成的序列，因此对于素数 $p$，被筛除的剩余类的数量为 $\\omega(p)=1$。假设筛分集合 $\\mathcal{P}$ 是所有素数的集合，则筛分密度 $V(z)$ 由下式给出\n$$\nV(z) = \\prod_{pz} \\left(1 - \\frac{\\omega(p)}{p}\\right) = \\prod_{pz} \\left(1 - \\frac{1}{p}\\right)\n$$\n根据默滕斯第三定理，对于大的 $z$，其渐近行为为\n$$\nV(z) \\sim \\frac{e^{-\\gamma}}{\\ln z}\n$$\n其中 $\\gamma$ 是欧拉-马斯刻若尼常数。\n\n余项和为 $\\sum_{d\\leq D}|R_d|$。问题为无平方因子的 $d$ 定义了 $R_d$，并给出了界 $|R_d| \\leq 1$。该和式是对 $d \\le D$ 求和，在塞尔伯格筛法的背景下，这些 $d$ 来自于 $P(z)=\\prod_{pz}p$ 的无平方因子除数。在应用中，一个标准且有效的余项和界是通过对所有小于等于 $D$ 的整数求和得到的：\n$$\n\\sum_{d\\leq D}|R_d| \\leq \\sum_{d\\leq D} 1 = \\lfloor D \\rfloor \\leq D\n$$\n注意，更精确的处理方法将对无平方因子的 $d$ 求和，得到界 $\\frac{6}{\\pi^2}D+o(D)$，但这个常数因子不影响最终结果的主阶。我们使用界 $D$ 来处理误差项。\n\n现在需要最小化的表达式渐近地为\n$$\nB(z, D) \\approx X \\frac{e^{-\\gamma}}{\\ln z} F(s) + D\n$$\n我们需要选择参数 $z$ 和 $D$ 来最小化此表达式。使用参数 $s$ 和 $D$ 更为方便。我们将 $\\ln z$ 用 $s$ 和 $D$ 表示：\n$$\n\\ln z = \\frac{\\ln D}{s}\n$$\n将其代入 $B$ 的表达式，我们得到\n$$\nB(s, D) \\approx X e^{-\\gamma} F(s) \\frac{s}{\\ln D} + D\n$$\n优化可以分两步进行。首先，对于一个固定的分布水平 $D$，我们选择 $s$（这等价于选择 $z$）来最小化主项。这要求我们最小化乘积 $sF(s)$。\n\n问题指明 $F(s)$ 是“线性筛上界函数”。这个函数在 Jurkat 和 Richert 的工作中是众所周知的。对于筛法维度 $\\kappa=1$，其关键性质是\n$$\nF(s) = \\frac{2e^\\gamma}{s} \\quad \\text{对于 } 0  s \\leq 3\n$$\n对于 $s3$，函数 $sF(s)$ 是严格递增的。因此，乘积 $sF(s)$ 在区间 $(0, \\infty)$ 上的最小值通过取 $(0, 3]$ 范围内的任意 $s$ 得到。在此范围内，最小值为\n$$\n\\min_{s0} \\{sF(s)\\} = s \\cdot \\frac{2e^\\gamma}{s} = 2e^\\gamma\n$$\n选择 s 的理由：优化筛法上界的首要原则是选择能使表达式最小化的参数。通过用 $s$ 和 $D$ 对上界进行参数化，我们看到对 $s$ 的依赖性体现在因子 $sF(s)$ 中。对标准线性筛函数 $F(s)$ 的分析表明，$sF(s)$ 在 $s \\in (0,3]$ 时取最小值。因此，此范围内的任何选择对于这部分最小化都是最优的。一个通常做出的典型选择是 $s=2$，这对应于筛法理论中的“奇偶性障碍”，即 $D=z^2$。我们将 $s$ 选在这个最优范围内。\n\n当 $sF(s) = 2e^\\gamma$ 时，我们的上界变成仅关于 $D$ 的函数：\n$$\ng(D) = X e^{-\\gamma} \\frac{2e^\\gamma}{\\ln D} + D = \\frac{2X}{\\ln D} + D\n$$\n现在，我们必须对 $g(D)$ 关于 $D$ 进行最小化。我们对 $g(D)$ 求导并令其等于零：\n$$\ng'(D) = -\\frac{2X}{D(\\ln D)^2} + 1 = 0\n$$\n这给出了最优 $D$ 的条件：\n$$\nD(\\ln D)^2 = 2X\n$$\n为了找到最小化上界的渐近行为，我们首先找到 $D$ 的渐近行为。对该条件取对数得到 $\\ln D + 2\\ln(\\ln D) = \\ln(2X)$。对于大的 $X$，$\\ln D$ 项必定占主导，因此 $\\ln D \\approx \\ln(2X) \\approx \\ln X$。更精确地说，$\\ln D = \\ln X + O(\\ln\\ln X)$。\n\n上界的最小值为 $g(D) = \\frac{2X}{\\ln D} + D$。利用条件 $D = \\frac{2X}{(\\ln D)^2}$，我们可以将上界写为\n$$\ng(D) = \\frac{2X}{\\ln D} + \\frac{2X}{(\\ln D)^2}\n$$\n当 $X \\to \\infty$ 时，我们有 $\\ln D \\to \\infty$。第一项 $\\frac{2X}{\\ln D}$ 主导第二项 $\\frac{2X}{(\\ln D)^2}$。\n因此，最小化上界的主项是\n$$\n\\frac{2X}{\\ln D}\n$$\n使用渐近等价关系 $\\ln D \\sim \\ln X$，最小化上界的主项是\n$$\n\\frac{2X}{\\ln X}\n$$\n这个结果是使用线性筛法估计素数数量时上界中出现的“因子2”的经典体现，而真实的渐近值为 $X/\\ln X$。", "answer": "$$\\boxed{\\frac{2X}{\\ln(X)}}$$", "id": "3029457"}, {"introduction": "理论上的筛法构造常常使用可能导致数值不稳定的“硬”截断。在计算实践中，对截断水平 $D$ 附近的筛分权重进行平滑处理，可以显著提高所得界限的稳定性和鲁棒性。这个编程练习 [@problem_id:3029494] 让你能够通过代码实现并数值验证平滑截断函数的优势，为现代计算筛法理论中的一个重要技术提供了实践性的证明。", "problem": "设计并实现一个完整的、可运行的程序，该程序在数值上阐明在参数 $D$ 附近平滑截断对塞尔伯格筛上界稳定性的影响。在埃拉托斯特尼-勒让德筛法的经典背景下进行，其中处理的序列是正整数的初始段。你的任务是针对两族筛权重（一族是硬指示函数截断，另一族是在 $D$ 附近的平滑过渡）计算、比较并汇总其稳定性指标。\n\n基本原理与设置：\n- 令 $A = \\{1,2,\\dots,x\\}$，其计数权重为 $a_n = 1$（对所有 $n$）。\n- 令 $\\mathcal{P}$ 表示所有素数的集合。对参数 $z \\geq 2$，定义 $P(z) = \\prod_{p \\in \\mathcal{P},\\, p  z} p$。\n- 定义筛选计数 $S(A,\\mathcal{P},z)$ 为集合 $A$ 中没有小于 $z$ 的素因子的元素个数，即满足 $\\gcd(n, P(z)) = 1$ 的 $n \\leq x$ 的数量。\n- 令 $\\mu(d)$ 表示莫比乌斯函数。考虑复数权重 $\\lambda_d$，其支撑集为满足 $d \\mid P(z)$ 和 $d \\leq D$ 的无平方因子数 $d$，并归一化为 $\\lambda_1 = 1$。\n- 塞尔伯格筛上界不等式指出，对于任何如此选择的权重，有\n$$\nS(A,\\mathcal{P},z) \\leq \\sum_{n \\leq x} \\Bigg( \\sum_{\\substack{d \\mid n \\\\ d \\mid P(z)}} \\lambda_d \\Bigg)^2.\n$$\n你的程序将计算不等式右侧作为可操作的上界，并比较当 $D$ 发生微小变化时，两种 $\\lambda_d$ 截断方案下的数值稳定性。\n\n待比较的权重族：\n- 硬截断权重：对于满足 $d \\mid P(z)$ 和 $d \\leq D$ 的无平方因子数 $d$，设 $\\lambda_d^{\\mathrm{hard}} = \\mu(d)$，否则设 $\\lambda_d^{\\mathrm{hard}} = 0$。这是一种截断的容斥原理选择。\n- 平滑截断权重：固定一个平滑窗参数 $\\eta \\in (0,1)$。对于满足 $d \\mid P(z)$ 和 $d \\leq D$ 的无平方因子数 $d$，定义\n$$\nu(d) = \\min\\!\\left\\{ 1,\\; \\max\\!\\left\\{ 0,\\; \\frac{\\log(D/d)}{\\eta \\log D} \\right\\} \\right\\},\n\\quad s(u) = 3u^2 - 2u^3,\n\\quad \\lambda_d^{\\mathrm{sm}} = \\mu(d) \\, s\\!\\big(u(d)\\big),\n$$\n否则设 $\\lambda_d^{\\mathrm{sm}} = 0$。因此，对于 $d \\leq D^{1-\\eta}$，有 $\\lambda_d^{\\mathrm{sm}} = \\mu(d)$，并当 $d \\to D$ 时，权重平滑地过渡到 $0$。\n\n待计算的可操作上界：\n- 对于满足支撑集和归一化约束的任何权重 $\\lambda_d$ 选择，定义\n$$\n\\mathcal{U}(x,z,D;\\lambda) = \\sum_{n \\leq x} \\left( \\sum_{\\substack{d \\mid n \\\\ d \\mid P(z)}} \\lambda_d \\right)^2.\n$$\n通过对每个 $n \\leq x$ 的因数求和来精确计算这个量，使用高效的“因数-倍数”累加法，而非渐近逼近。通过倍数累加隐式地使用向下取整的计数恒等式 $\\sum_{n \\leq x} 1_{m \\mid n} = \\lfloor x/m \\rfloor$，以在计数层面保持整数精度；不涉及任何物理单位。\n\n稳定性指标：\n- 对于一个固定的四元组 $(x,z,\\{D_1,D_2,D_3\\},\\eta)$ 和一个固定的权重族，计算集合 $\\{\\mathcal{U}(x,z,D_j;\\lambda)\\}_{j=1}^3$。定义相对不稳定性为\n$$\n\\mathrm{var\\_rel} = \\frac{\\max_j \\mathcal{U}(x,z,D_j;\\lambda) - \\min_j \\mathcal{U}(x,z,D_j;\\lambda)}{\\frac{1}{3}\\sum_{j=1}^3 \\mathcal{U}(x,z,D_j;\\lambda)}.\n$$\n数值上比较硬截断权重和平滑截断权重的 $\\mathrm{var\\_rel}$ 值以评估稳定性。不涉及角度或百分比；将所有实值输出报告为十进制浮点数。\n\n测试集：\n实现程序以评估以下四个测试用例。每个用例指定了 $(x,z,\\{D_1,D_2,D_3\\},\\eta)$。\n\n- 用例1：$x = 100000$, $z = 50$, $\\{D_1,D_2,D_3\\} = \\{2800, 3000, 3200\\}$, $\\eta = 0.25$。\n- 用例2：$x = 100000$, $z = 80$, $\\{D_1,D_2,D_3\\} = \\{2600, 2800, 3000\\}$, $\\eta = 0.25$。\n- 用例3：$x = 50000$, $z = 30$, $\\{D_1,D_2,D_3\\} = \\{600, 800, 1000\\}$, $\\eta = 0.25$。\n- 用例4：$x = 80000$, $z = 60$, $\\{D_1,D_2,D_3\\} = \\{2000, 2200, 2400\\}$, $\\eta = 0.25$。\n\n要求的最终输出格式：\n- 对于每个测试用例，生成一个列表 $[\\mathrm{var\\_rel}^{\\mathrm{hard}}, \\mathrm{var\\_rel}^{\\mathrm{sm}}, \\mathrm{improved}]$，其中 $\\mathrm{improved}$ 是一个布尔值，当且仅当 $\\mathrm{var\\_rel}^{\\mathrm{sm}}  \\mathrm{var\\_rel}^{\\mathrm{hard}}$ 时为真。\n- 将这四个列表聚合为一个单一列表，并精确地打印一行，该行包含这个外层列表，格式为方括号和逗号分隔，例如 $[[\\dots],[\\dots],[\\dots],[\\dots]]$。", "solution": "在尝试提出解决方案之前，对所述问题进行了严格的验证。\n\n### 第一步：提取已知条件\n- **序列和权重**: $A = \\{1,2,\\dots,x\\}$，计数权重为 $a_n = 1$。\n- **筛选素数**: $\\mathcal{P}$ 是所有素数的集合。对于参数 $z \\geq 2$，$P(z) = \\prod_{p \\in \\mathcal{P},\\, p  z}$。\n- **筛选计数**: $S(A,\\mathcal{P},z) = |\\{n \\leq x : \\gcd(n, P(z)) = 1\\}|$。\n- **筛权重**: $\\lambda_d$ 是复数，其支撑集为满足 $d \\mid P(z)$ 和 $d \\leq D$ 的无平方因子数 $d$。$\\mu(d)$ 是莫比乌斯函数。归一化条件为 $\\lambda_1 = 1$。\n- **塞尔伯格上界**: $S(A,\\mathcal{P},z) \\leq \\sum_{n \\leq x} \\left( \\sum_{d \\mid n, d \\mid P(z)} \\lambda_d \\right)^2$。\n- **权重族1 (硬截断)**: 对于满足 $d \\mid P(z)$ 的无平方因子数 $d$，如果 $d \\leq D$，则 $\\lambda_d^{\\mathrm{hard}} = \\mu(d)$，否则为 $0$。\n- **权重族2 (平滑截断)**: 对于平滑参数 $\\eta \\in (0,1)$，以及满足 $d \\mid P(z)$ 和 $d \\leq D$ 的无平方因子数 $d$，权重定义为 $\\lambda_d^{\\mathrm{sm}} = \\mu(d) \\, s(u(d))$，其中 $u(d) = \\min\\{ 1, \\max\\{ 0, \\frac{\\log(D/d)}{\\eta \\log D} \\} \\}$ 且 $s(u) = 3u^2 - 2u^3$。若 $d  D$ 或其他条件不满足，则 $\\lambda_d^{\\mathrm{sm}} = 0$。\n- **可操作的上界**: $\\mathcal{U}(x,z,D;\\lambda) = \\sum_{n \\leq x} \\left( \\sum_{d \\mid n, d \\mid P(z)} \\lambda_d \\right)^2$。这个值需要精确计算，而非渐近计算。\n- **稳定性指标**: 对于一组三个参数 $\\{D_1, D_2, D_3\\}$，相对不稳定性为 $\\mathrm{var\\_rel} = \\frac{\\max_j \\mathcal{U}(x,z,D_j;\\lambda) - \\min_j \\mathcal{U}(x,z,D_j;\\lambda)}{\\frac{1}{3}\\sum_{j=1}^3 \\mathcal{U}(x,z,D_j;\\lambda)}$。\n- **测试集**:\n    1.  $x = 100000$, $z = 50$, $\\{D_1,D_2,D_3\\} = \\{2800, 3000, 3200\\}$, $\\eta = 0.25$。\n    2.  $x = 100000$, $z = 80$, $\\{D_1,D_2,D_3\\} = \\{2600, 2800, 3000\\}$, $\\eta = 0.25$。\n    3.  $x = 50000$, $z = 30$, $\\{D_1,D_2,D_3\\} = \\{600, 800, 1000\\}$, $\\eta = 0.25$。\n    4.  $x = 80000$, $z = 60$, $\\{D_1,D_2,D_3\\} = \\{2000, 2200, 2400\\}$, $\\eta = 0.25$。\n- **输出格式**: 一个包含四个列表的列表，每个列表的形式为 $[\\mathrm{var\\_rel}^{\\mathrm{hard}}, \\mathrm{var\\_rel}^{\\mathrm{sm}}, \\mathrm{improved}]$，其中 $\\mathrm{improved}$ 是一个布尔值，表示 $\\mathrm{var\\_rel}^{\\mathrm{sm}}  \\mathrm{var\\_rel}^{\\mathrm{hard}}$ 是否成立。\n\n### 第二步：使用提取的已知条件进行验证\n该问题定义明确且在科学上是合理的。\n1.  **科学基础**: 该问题植根于解析数论，特别是塞尔伯格筛法。塞尔伯格不等式是现代筛法理论的基石。$\\lambda_d^{\\mathrm{hard}}$ 权重的选择对应于一个截断的容斥原理，而 $\\lambda_d^{\\mathrm{sm}}$ 权重引入了一种标准的解析平滑技术。函数 $s(u)=3u^2-2u^3$ 是一个常见的平滑阶跃多项式。研究数值稳定性作为筛参数的函数是计算数论中一个有意义的练习。\n2.  **适定性与完备性**: 该问题是适定的。每个测试用例的所有参数（$x, z, D_j, \\eta$）都已指定。权重的数学定义和稳定性指标是明确无误的。存在唯一的数值解，并且在计算上是可行的。使用“因数-倍数”累加法的提示指向了一种高效算法，考虑到 $x$ 的量级，这是必要的。\n3.  **客观性**: 语言是形式化和客观的。任务是纯粹的计算，并基于已建立的数学公式。\n\n### 第三步：结论与行动\n问题有效。将开发并实现一个合理的解决方案。\n\n### 解决方案与算法设计\n\n目标是数值比较在两种不同权重 $\\lambda_d$ 选择下，一个塞尔伯格筛上界的稳定性。稳定性是通过观察上界 $\\mathcal{U}(x, z, D; \\lambda)$ 在截断参数 $D$ 受扰动时的变化来衡量的。问题的核心是高效而精确地计算此上界。\n\n可操作的上界由下式给出：\n$$\n\\mathcal{U}(x,z,D;\\lambda) = \\sum_{n=1}^{x} \\left( \\sum_{\\substack{d \\mid n \\\\ d \\mid P(z) \\\\ d \\leq D}} \\lambda_d \\right)^2\n$$\n对 $n$、其因数 $d$、然后再进行平方的朴素三重循环在计算上是不可行的。一个更高效的策略，如问题所建议的，是首先为每个 $n$ 计算内层和。令 $S_n = \\sum_{d \\mid n, d \\mid P(z), d \\leq D} \\lambda_d$。然后我们可以计算 $\\mathcal{U} = \\sum_{n=1}^{x} S_n^2$。\n\n“因数-倍数”累加技术被用来高效地计算所有 $S_n$ 的值。这包括以下步骤：\n1.  初始化一个大小为 $x+1$ 的实值数组 `S_array` 为零。\n2.  遍历每个相关的因数 $d$（即无平方因子、 $d \\mid P(z)$、$d \\leq D$）。对于每个这样的 $d$，其对应的权重 $\\lambda_d$ 是非零的。\n3.  对于每个 $d$，将其权重 $\\lambda_d$ 加到 `S_array` 中索引为 $d$ 的倍数的位置上。也就是说，对于每个 $n = kd \\leq x$，我们执行更新 `S_array[n] += lambda_d`。\n4.  遍历所有相关 $d$ 后，`S_array[n]` 的条目将持有 $S_n$ 的值。这个过程的计算复杂度约为 $\\sum_{d \\leq D} \\frac{x}{d} \\approx x \\log D$，对于给定的参数来说足够高效。\n5.  最后，通过对 `S_array` 中从索引 1 到 $x$ 的元素求平方和来计算上界 $\\mathcal{U}$。\n\n整体算法结构如下：\n\n1.  **预处理**: 对于每个测试用例及其参数 $(x, z, \\{D_1,D_2,D_3\\}, \\eta)$，确定 $D$ 的最大值，记为 $D_{\\max} = \\max\\{D_1, D_2, D_3\\}$。\n    - 使用埃拉托斯特尼筛法生成小于 $z$ 的素数列表。\n    - 生成所有满足 $d \\leq D_{\\max}$ 且所有素因子都小于 $z$ 的无平方因子数 $d$ 的集合。这等价于找到所有满足 $d \\leq D_{\\max}$ 的 $d \\mid P(z)$。这可以通过一个递归（深度优先搜索）算法完成，从 $d=1$ 开始，并逐次乘以生成的素数列表中的素数。在此生成过程中，也计算了莫比乌斯函数 $\\mu(d)$，因为两种权重族都需要它。我们将这些存储为一个从 $d$ 到 $\\mu(d)$ 的映射。\n\n2.  **主循环**: 程序遍历三个截断值 $D_j \\in \\{D_1, D_2, D_3\\}$ 中的每一个。对于每个 $D_j$：\n    - **硬截断权重**: 创建一组权重 $\\{\\lambda_d^{\\mathrm{hard}}\\}$。对于每个生成的无平方因子因数 $d$，如果 $d \\leq D_j$，则 $\\lambda_d^{\\mathrm{hard}} = \\mu(d)$。\n    - **平滑截断权重**: 创建一组权重 $\\{\\lambda_d^{\\mathrm{sm}}\\}$。对于每个生成的无平方因子因数 $d \\leq D_j$，计算值 $\\lambda_d^{\\mathrm{sm}} = \\mu(d) s(u(d))$，其中 $u(d) = \\min\\{1, \\max\\{0, \\frac{\\log(D_j/d)}{\\eta \\log D_j}\\}\\}$ 且 $s(u) = 3u^2 - 2u^3$。注意，对于 $dD_j$，$u(d)=0$，因此 $\\lambda_d^{\\mathrm{sm}}=0$。\n    - **计算上界**: 使用上述的因数-倍数累加法，计算上界 $\\mathcal{U}(x, z, D_j; \\lambda^{\\mathrm{hard}})$ 和 $\\mathcal{U}(x, z, D_j; \\lambda^{\\mathrm{sm}})$。这些值被存储在两个列表中，一个用于硬截断结果，一个用于平滑截断结果。\n\n3.  **稳定性计算**: 为一个测试用例处理完所有三个 $D_j$ 值后，使用结果集 $\\{\\mathcal{U}^{\\mathrm{hard}}_j\\}_{j=1}^3$ 和 $\\{\\mathcal{U}^{\\mathrm{sm}}_j\\}_{j=1}^3$ 来为两种权重族计算相对不稳定性指标 $\\mathrm{var\\_rel}$。\n    $$\n    \\mathrm{var\\_rel}^{\\mathrm{hard}} = \\frac{\\max_j \\mathcal{U}^{\\mathrm{hard}}_j - \\min_j \\mathcal{U}^{\\mathrm{hard}}_j}{\\mathrm{mean}(\\{\\mathcal{U}^{\\mathrm{hard}}_j\\})} \\quad \\text{和} \\quad \\mathrm{var\\_rel}^{\\mathrm{sm}} = \\frac{\\max_j \\mathcal{U}^{\\mathrm{sm}}_j - \\min_j \\mathcal{U}^{\\mathrm{sm}}_j}{\\mathrm{mean}(\\{\\mathcal{U}^{\\mathrm{sm}}_j\\})}\n    $$\n    确定布尔标志 $\\mathrm{improved} = (\\mathrm{var\\_rel}^{\\mathrm{sm}}  \\mathrm{var\\_rel}^{\\mathrm{hard}})$。\n\n4.  **聚合**: 存储最终的三元组 $[\\mathrm{var\\_rel}^{\\mathrm{hard}}, \\mathrm{var\\_rel}^{\\mathrm{sm}}, \\mathrm{improved}]$。对所有四个测试用例重复此过程，并将结果聚合到一个最终列表中以供输出。\n\n该设计直接实现了指定的数学框架，并为核心数值任务利用了高效算法，确保计算在合理时间内是可行的。使用 NumPy 允许进行向量化操作，这显著加速了因数-倍数累加步骤。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef sieve_of_eratosthenes(n):\n    \"\"\"Generates primes strictly less than n.\"\"\"\n    if n  3:\n        return []\n    primes = np.ones(n // 2, dtype=bool)\n    for i in range(3, int(n**0.5) + 1, 2):\n        if primes[i // 2]:\n            primes[i*i // 2::i] = False\n    prime_numbers = [2] + [2*i + 1 for i in range(1, n // 2) if primes[i]]\n    return prime_numbers\n\ndef generate_squarefree_from_primes(max_d, primes):\n    \"\"\"\n    Generates squarefree numbers d = max_d with prime factors from the given list.\n    Also computes the Mobius function mu(d).\n    Returns a dictionary {d: mu(d)}.\n    \"\"\"\n    d_mu_map = {}\n    \n    def _dfs(d, mu, prime_idx):\n        d_mu_map[d] = mu\n        for i in range(prime_idx, len(primes)):\n            p = primes[i]\n            new_d = d * p\n            if new_d  max_d:\n                break\n            _dfs(new_d, -mu, i + 1)\n            \n    _dfs(1, 1, 0)\n    return d_mu_map\n    \ndef compute_U_from_lambdas(x, lambda_map):\n    \"\"\"\n    Computes the Selberg upper bound U using divisor-multiple accumulation.\n    \"\"\"\n    S_n = np.zeros(x + 1, dtype=np.float64)\n    \n    # Sort by d to potentially improve cache performance, though not strictly necessary for correctness.\n    sorted_d = sorted(lambda_map.keys())\n\n    for d in sorted_d:\n        lam = lambda_map[d]\n        if d  0 and abs(lam)  1e-15: # d=0 is not possible in this problem setup\n            S_n[d::d] += lam\n            \n    U = np.sum(np.square(S_n[1:]))\n    return U\n\ndef run_one_case(x, z, Ds, eta):\n    \"\"\"\n    Runs a single test case to compute and compare stability metrics.\n    \"\"\"\n    max_D = max(Ds)\n    primes = sieve_of_eratosthenes(z)\n    d_mu_map = generate_squarefree_from_primes(max_D, primes)\n    \n    U_hard_list = []\n    U_smooth_list = []\n    \n    for D in Ds:\n        # 1. Hard cutoff weights\n        lambda_hard = {d: float(mu) for d, mu in d_mu_map.items() if d = D}\n        U_hard = compute_U_from_lambdas(x, lambda_hard)\n        U_hard_list.append(U_hard)\n        \n        # 2. Smooth cutoff weights\n        lambda_smooth = {}\n        log_D = np.log(D)\n        \n        # Denominator for u(d) to avoid recomputing. Check for D=1 or eta=0.\n        denominator = eta * log_D if eta  0 and D  1 else 1.0\n\n        for d, mu in d_mu_map.items():\n            if d  D:\n                continue\n            \n            if eta == 0 or D == 1:\n                u = 1.0 if d == 1 else 0.0\n            else:\n                # Handle d=0 case to prevent log domain error, though not expected\n                if d == 0: continue\n                log_ratio = np.log(D / d)\n                u = min(1.0, max(0.0, log_ratio / denominator))\n            \n            s = 3.0 * u**2 - 2.0 * u**3\n            lambda_smooth[d] = mu * s\n            \n        U_smooth = compute_U_from_lambdas(x, lambda_smooth)\n        U_smooth_list.append(U_smooth)\n\n    # Compute stability metrics\n    mean_hard = np.mean(U_hard_list)\n    var_rel_hard = (np.max(U_hard_list) - np.min(U_hard_list)) / mean_hard if mean_hard  1e-9 else 0.0\n\n    mean_smooth = np.mean(U_smooth_list)\n    var_rel_smooth = (np.max(U_smooth_list) - np.min(U_smooth_list)) / mean_smooth if mean_smooth  1e-9 else 0.0\n    \n    improved = var_rel_smooth  var_rel_hard\n    \n    return [var_rel_hard, var_rel_smooth, improved]\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and print results in the required format.\n    \"\"\"\n    test_cases = [\n        (100000, 50, [2800, 3000, 3200], 0.25),\n        (100000, 80, [2600, 2800, 3000], 0.25),\n        (50000, 30, [600, 800, 1000], 0.25),\n        (80000, 60, [2000, 2200, 2400], 0.25),\n    ]\n\n    results = []\n    for case in test_cases:\n        x, z, Ds, eta = case\n        result = run_one_case(x, z, Ds, eta)\n        results.append(result)\n\n    # Format the final output string as per requirements.\n    # e.g., [[val1,val2,true],[val3,val4,false],...]\n    case_strings = []\n    for res in results:\n        # Format floats to a reasonable precision and boolean to lowercase.\n        # This creates a compact, readable, and machine-friendly string.\n        res_str = f\"[{res[0]:.8f},{res[1]:.8f},{str(res[2]).lower()}]\"\n        case_strings.append(res_str)\n    \n    print(f\"[{','.join(case_strings)}]\")\n\nsolve()\n```", "id": "3029494"}]}