{"hands_on_practices": [{"introduction": "要掌握布朗筛法，第一步是理解其基本构件：每个素数 $p$ 如何在筛分过程中“剔除”不符合条件的数。这个过程的效率由局部密度 $r(p)$ 决定，即模 $p$ 有多少个剩余类被排除。对于孪生素数问题，其对应的多项式为 $n(n+2)$，大多数素数会排除两个剩余类，但素数 $p=2$ 是个例外。这个练习将引导你通过基本模算术精确计算这个“例外素数”的局部影响因子 $f_2$，这是构建筛法主项和理解孪生素数常数的关键细节 [@problem_id:3009398]。", "problem": "考虑二元模式 $\\mathcal{H}=\\{0,2\\}$，它编码了对整数 $n$ 的孪生素数约束，要求 $n$ 和 $n+2$ 均不被小的素数整除。在 Brun 纯筛法的框架下，我们研究对序列 $\\{n \\leq x\\}$ 的筛选过程，即移除那些对于低于某个阈值的任意素数 $p$ 满足 $p \\mid n(n+2)$ 的 $n$。对于一个素数 $p$，令 $r(p)$ 表示使 $a(a+2) \\equiv 0 \\pmod{p}$ 成立的模 $p$ 的剩余类 $a$ 的数量。在 $k=2$ 模式的归一化筛密度中，与 $p$ 相关联的局部乘性因子定义为\n$$\nf_{p} \\;=\\; \\frac{1-\\frac{r(p)}{p}}{\\left(1-\\frac{1}{p}\\right)^{2}} \\, .\n$$\n在这种情况下，素数 $p=2$ 是例外的，因为 $\\mathcal{H}$ 中的两个平移模 $2$ 是重合的。仅使用 $r(p)$ 的定义和基本的模运算，计算因子 $f_{2}$ 的精确值。\n\n请给出单个精确数值作为答案。", "solution": "问题要求在 Brun 纯筛法的背景下，计算与孪生素数问题相关的局部乘性因子 $f_{2}$。该因子对素数 $p$ 定义如下：\n$$\nf_{p} \\;=\\; \\frac{1-\\frac{r(p)}{p}}{\\left(1-\\frac{1}{p}\\right)^{2}}\n$$\n其中 $r(p)$ 是使得表示素数模式的多项式（在本例中为 $a(a+2)$）与零同余的模 $p$ 的剩余类 $a$ 的数量。\n\n为了求出 $f_{2}$ 的值，我们必须首先确定 $r(2)$ 的值。根据所给定义，$r(2)$ 是同余方程\n$$\na(a+2) \\equiv 0 \\pmod{2}\n$$\n的不同解的数量，其中 $a$ 是模 $2$ 的一个剩余类。模 $2$ 的整数包含两个剩余类，由 $a=0$ 和 $a=1$ 代表。我们对每种情况进行检验：\n\n情况 1：$a \\equiv 0 \\pmod{2}$\n将 $a=0$ 代入同余方程，我们得到：\n$$\n0 \\cdot (0+2) \\equiv 0 \\cdot 2 \\equiv 0 \\pmod{2}\n$$\n此同余式成立。因此，$a \\equiv 0 \\pmod{2}$ 是一个解。\n\n情况 2：$a \\equiv 1 \\pmod{2}$\n将 $a=1$ 代入同余方程，我们得到：\n$$\n1 \\cdot (1+2) \\equiv 1 \\cdot 3 \\equiv 3 \\pmod{2}\n$$\n由于 $3 \\equiv 1 \\pmod{2}$，该同余方程变为 $1 \\equiv 0 \\pmod{2}$，这不成立。因此，$a \\equiv 1 \\pmod{2}$ 不是一个解。\n\n从这两种情况中，我们发现只有一个模 $2$ 的剩余类满足条件，即 $a \\equiv 0 \\pmod{2}$。因此，这种剩余类的数量为 $r(2) = 1$。\n\n这个结果阐明了为什么对于孪生素数问题，$p=2$ 被视为一个例外的素数。对于任何其他素数 $p>2$，同余方程 $a(a+2) \\equiv 0 \\pmod{p}$ 有两个不同的解：$a \\equiv 0 \\pmod{p}$ 和 $a \\equiv -2 \\pmod{p}$（因为 $p>2$，所以 $0 \\not\\equiv -2 \\pmod{p}$）。因此，对于 $p>2$，我们有 $r(p)=2$。对于 $p=2$，两个可能的根 $0$ 和 $-2$ 模 $2$ 同余，因此它们合并成一个根，得到 $r(2)=1$。\n\n现在，我们可以将 $p=2$ 和 $r(2)=1$ 代入 $f_{p}$ 的公式中：\n$$\nf_{2} = \\frac{1-\\frac{r(2)}{2}}{\\left(1-\\frac{1}{2}\\right)^{2}} = \\frac{1-\\frac{1}{2}}{\\left(1-\\frac{1}{2}\\right)^{2}}\n$$\n该表达式可以被简化。分子是：\n$$\n1-\\frac{1}{2} = \\frac{1}{2}\n$$\n分母是：\n$$\n\\left(1-\\frac{1}{2}\\right)^{2} = \\left(\\frac{1}{2}\\right)^{2} = \\frac{1}{4}\n$$\n因此，$f_{2}$ 的值是分子与分母之比：\n$$\nf_{2} = \\frac{\\frac{1}{2}}{\\frac{1}{4}} = \\frac{1}{2} \\cdot \\frac{4}{1} = 2\n$$\n因子 $f_{2}$ 的精确值是 $2$。", "answer": "$$\n\\boxed{2}\n$$", "id": "3009398"}, {"introduction": "在理解了筛法的局部行为之后，我们转向全局视角。任何筛法都面临一个核心权衡：使用更多的素数（即选择更大的筛分水平 $z$）可以更精细地筛分主项，但也导致误差项急剧增大。这个练习通过一个在解析数论中极具代表性的模型函数 $U(x,z)$，将这个权衡问题转化为一个具体的优化问题。通过求解最佳的 $z$，你将亲身体会到为何布朗纯筛法虽能得到非凡的上界，却因误差项的限制而无法得到正的下界，从而揭示了该方法的根本局限性 [@problem_id:3009399]。", "problem": "设 $x \\geq \\exp(\\exp(1))$ 为一个大的实参数。考虑将布朗纯筛法 (Brun's pure sieve) 应用于集合 $\\mathcal{A} = \\{n \\leq x : n \\text{ 和 } n+2 \\text{ 均为素数}\\}$，其中筛集合 $\\mathcal{P}$ 为全体素数集合，筛水平为 $z \\in [2,x)$。对于多项式 $n(n+2)$，该筛法的维数是 $\\kappa = 2$，其在经典纯筛法框架下的上界可分离为主项和误差项。使用维数 $\\kappa = 2$ 和素数上的默滕斯型乘积估计 (Mertens-type product estimates)，主项可以被一致地建模为一个 $(\\ln z)^{-2}$ 阶的因子，而截断误差可被一个关于 $z$ 的多项式项所控制。特别地，在这些广为接受的筛法启发式假设下，可以得到以下形式的上界\n$$\nU(x,z) \\leq \\frac{A\\,x}{(\\ln z)^{2}} + B\\,z^{2},\n$$\n其中 $A>0$ 和 $B>0$ 是绝对常数，分别来自于筛法的局部权重（对于 $\\kappa = 2$）和组合截断余项，且与 $x$ 和 $z$ 无关。\n\n将 $U(x,z)$ 视为固定大数 $x$ 下关于 $z$ 的函数，确定一个渐近最优选择 $z = z^{\\ast}(x)$，使得当 $x \\to \\infty$ 时 $U(x,z)$ 最小。该选择需用 $x$、$A$ 和 $B$ 的闭式解表示。您的最终答案必须是单个解析表达式。无需四舍五入。", "solution": "该问题要求我们找到筛水平 $z$ 的渐近最优选择，记为 $z^{\\ast}(x)$，它对于一个固定的大的 $x$ 值，能使上界函数 $U(x,z)$ 最小化。该函数由下式给出：\n$$U(x,z) = \\frac{A x}{(\\ln z)^{2}} + B z^{2}$$\n其中 $x$ 是一个大参数，$z \\in [2, x)$ 是待优化的变量，$A > 0, B > 0$ 是绝对常数。\n\n为了找到使 $U(x,z)$ 最小化的 $z$ 值，我们将 $U$ 视为 $z$ 的函数，并使用微积分来找到其临界点。我们计算 $U(x,z)$ 关于 $z$ 的一阶导数，并令其为零。\n\n令 $f(z) = U(x,z)$。$f(z)$ 关于 $z$ 的导数是：\n$$\\frac{d f}{dz} = \\frac{d}{dz} \\left( A x (\\ln z)^{-2} + B z^{2} \\right)$$\n使用链式法则和幂法则进行微分：\n$$\\frac{d}{dz} \\left( A x (\\ln z)^{-2} \\right) = A x \\cdot (-2) (\\ln z)^{-3} \\cdot \\frac{d}{dz}(\\ln z) = -2 A x (\\ln z)^{-3} \\cdot \\frac{1}{z} = -\\frac{2 A x}{z (\\ln z)^{3}}$$\n第二项的导数是：\n$$\\frac{d}{dz} (B z^{2}) = 2 B z$$\n综合起来，$f(z)$ 的导数是：\n$$\\frac{d f}{dz} = 2 B z - \\frac{2 A x}{z (\\ln z)^{3}}$$\n为了找到最小值，我们令导数为零，这发生在 $z = z^{\\ast}$ 处：\n$$2 B z^{\\ast} - \\frac{2 A x}{z^{\\ast} (\\ln z^{\\ast})^{3}} = 0$$\n$$2 B z^{\\ast} = \\frac{2 A x}{z^{\\ast} (\\ln z^{\\ast})^{3}}$$\n两边乘以 $z^{\\ast}$ 并除以 $2$，我们得到定义最优 $z^{\\ast}$ 的方程：\n$$B (z^{\\ast})^{2} (\\ln z^{\\ast})^{3} = A x$$\n$$(z^{\\ast})^{2} (\\ln z^{\\ast})^{3} = \\frac{A x}{B}$$\n这个方程无法用初等函数解出 $z^{\\ast}$。然而，问题要求的是当 $x \\to \\infty$ 时的渐近最优选择。我们可以求出 $z^{\\ast}$ 的一个渐近解。\n\n当 $x \\to \\infty$ 时，等式右边 $\\frac{A x}{B}$ 增长，这意味着 $z^{\\ast}$ 也必须增长。让我们对等式两边取自然对数：\n$$\\ln\\left((z^{\\ast})^{2} (\\ln z^{\\ast})^{3}\\right) = \\ln\\left(\\frac{A x}{B}\\right)$$\n$$2 \\ln(z^{\\ast}) + 3 \\ln(\\ln z^{\\ast}) = \\ln(x) + \\ln\\left(\\frac{A}{B}\\right)$$\n对于大的 $x$，$z^{\\ast}$ 也很大，且 $\\ln(z^{\\ast})$ 的增长速度远快于 $\\ln(\\ln z^{\\ast})$。因此，方程中的主导项是左边的 $2 \\ln(z^{\\ast})$ 和右边的 $\\ln(x)$。这给了我们一个一阶渐近近似：\n$$2 \\ln(z^{\\ast}) \\approx \\ln(x)$$\n$$\\ln(z^{\\ast}) \\approx \\frac{1}{2} \\ln(x)$$\n现在我们可以用这个近似来找到 $z^{\\ast}$ 的渐近表达式。从方程 $(z^{\\ast})^{2} (\\ln z^{\\ast})^{3} = \\frac{A x}{B}$，我们可以写出：\n$$(z^{\\ast})^{2} = \\frac{A x}{B(\\ln z^{\\ast})^{3}}$$\n$$z^{\\ast} = \\sqrt{\\frac{A x}{B(\\ln z^{\\ast})^{3}}} = \\left(\\frac{A x}{B}\\right)^{1/2} (\\ln z^{\\ast})^{-3/2}$$\n将我们的近似 $\\ln(z^{\\ast}) \\approx \\frac{1}{2} \\ln(x)$ 代入此表达式：\n$$z^{\\ast} \\approx \\left(\\frac{A x}{B}\\right)^{1/2} \\left(\\frac{1}{2} \\ln x\\right)^{-3/2}$$\n$$z^{\\ast} \\approx \\left(\\frac{A}{B}\\right)^{1/2} x^{1/2} \\left(\\frac{1}{2}\\right)^{-3/2} (\\ln x)^{-3/2}$$\n由于 $(\\frac{1}{2})^{-3/2} = (2^{ -1})^{-3/2} = 2^{3/2} = 2\\sqrt{2}$，我们有：\n$$z^{\\ast} \\approx \\left(\\frac{A}{B}\\right)^{1/2} x^{1/2} (2\\sqrt{2}) (\\ln x)^{-3/2}$$\n$$z^{\\ast} \\approx 2\\sqrt{2} \\sqrt{\\frac{A}{B}} \\frac{x^{1/2}}{(\\ln x)^{3/2}}$$\n这可以更紧凑地写为：\n$$z^{\\ast} \\approx \\sqrt{\\frac{8A}{B}} \\frac{x^{1/2}}{(\\ln x)^{3/2}}$$\n这就是最优筛水平 $z^{\\ast}(x)$ 的主阶渐近表达式。\n\n为了确认这是一个最小值，我们可以检查 $f(z)$ 二阶导数的符号：\n$$\\frac{d^2 f}{dz^2} = \\frac{d}{dz} \\left( 2 B z - 2 A x z^{-1} (\\ln z)^{-3} \\right)$$\n$$\\frac{d^2 f}{dz^2} = 2 B - 2 A x \\left( (-1)z^{-2}(\\ln z)^{-3} + z^{-1}(-3)(\\ln z)^{-4} \\frac{1}{z} \\right)$$\n$$\\frac{d^2 f}{dz^2} = 2 B + 2 A x \\left( z^{-2}(\\ln z)^{-3} + 3 z^{-2}(\\ln z)^{-4} \\right)$$\n$$\\frac{d^2 f}{dz^2} = 2 B + \\frac{2 A x}{z^2 (\\ln z)^3} \\left( 1 + \\frac{3}{\\ln z} \\right)$$\n在临界点 $z^{\\ast}$ 处，我们知道 $B(z^{\\ast})^2(\\ln z^{\\ast})^3 = Ax$。因此，$\\frac{Ax}{(z^{\\ast})^2(\\ln z^{\\ast})^3} = B$。将此代入在 $z=z^{\\ast}$ 处求值的二阶导数表达式中：\n$$\\left. \\frac{d^2 f}{dz^2} \\right|_{z=z^{\\ast}} = 2 B + 2 B \\left( 1 + \\frac{3}{\\ln z^{\\ast}} \\right) = 4 B + \\frac{6 B}{\\ln z^{\\ast}}$$\n由于 $B > 0$ 且 $z^{\\ast}$ 很大（因此 $\\ln z^{\\ast} > 0$），二阶导数为正。因此，临界点 $z^{\\ast}$ 对应一个局部最小值，由于函数的形状，这也是在指定范围内 $z$ 的全局最小值。\n因此，渐近最优选择 $z = z^{\\ast}(x)$ 由推导出的表达式给出。", "answer": "$$\\boxed{\\sqrt{\\frac{8A}{B}} \\frac{x^{1/2}}{(\\ln x)^{3/2}}}$$", "id": "3009399"}, {"introduction": "理论学习最终要通过实践来巩固。这个压轴练习将理论与计算相结合，要求你亲手实现一个针对孪生素数问题的布朗纯筛法。你将编写代码来执行实际的筛分过程，计算筛后集合的大小 $S_z(x)$，并将其与基于局部密度模型的启发式预测 $U_{\\text{prod}}(x,z)$ 进行对比。更重要的是，你将构建并验证一个严格的数学上界 $U_{\\text{bound}}(x,z)$，从而清晰地看到理论是如何转化为具体、可计算且严谨的结果的，这对于深刻理解筛法在数论研究中的实际应用至关重要 [@problem_id:3009401]。", "problem": "在布伦纯筛法的框架内考虑孪生素数问题。令 $x \\in \\mathbb{N}$ 为一个量级参数，令 $z \\in \\mathbb{N}$ 为一个筛分水平。将孪生素数的候选基集定义为奇数集合\n$$\n\\mathcal{A}(x) := \\{ n \\in \\mathbb{N} : 3 \\le n \\le x-2, \\; n \\text{ odd} \\}.\n$$\n对每个素数 $p$，定义排除集\n$$\n\\mathcal{A}_p := \\{ n \\in \\mathcal{A}(x) : p \\mid n \\text{ or } p \\mid (n+2) \\}.\n$$\n令 $\\mathbb{P}_{\\le z}$ 表示不大于 $z$ 的素数集合。为避免被素数 $p=2$ 平凡筛除，本筛法将只使用奇素数，即\n$$\n\\mathbb{P}^{\\text{odd}}_{\\le z} := \\{ p \\in \\mathbb{P}_{\\le z} : p \\ge 3 \\}.\n$$\n定义水平 $z$ 处的筛后集为\n$$\nS_z(x) := \\left| \\mathcal{A}(x) \\setminus \\bigcup_{p \\in \\mathbb{P}^{\\text{odd}}_{\\le z}} \\mathcal{A}_p \\right|,\n$$\n即满足对于任意不大于 $z$ 的奇素数 $p$，$p \\mid n$ 和 $p \\mid (n+2)$ 均不成立的 $n \\in \\mathcal{A}(x)$ 的数量。\n\n通过布伦纯筛法对 $S_z(x)$ 进行建模的基本依据是剩余类排除原理：对于一个固定的奇素数 $p$，恰好有两个模 $p$ 的剩余类会被条件 $p \\mid n$ 或 $p \\mid (n+2)$ 排除，即 $n \\equiv 0 \\pmod{p}$ 和 $n \\equiv -2 \\pmod{p}$。在一个均匀性假设（纯筛法所基于的组合独立性理想化）下，每个素数 $p$ 对应的预期存活密度因此是 $1 - \\frac{2}{p}$，而达到水平 $z$ 的存活因子的启发式乘积为\n$$\nW(z) := \\prod_{p \\in \\mathbb{P}^{\\text{odd}}_{\\le z}} \\left(1 - \\frac{2}{p}\\right).\n$$\n令\n$$\nX(x) := |\\mathcal{A}(x)| = \\max\\!\\left( \\left\\lfloor \\frac{x-1}{2} \\right\\rfloor - 1, \\, 0 \\right),\n$$\n它计算的是 $[3, x-2]$ 内奇数 $n$ 的数量。相应的，筛后计数的乘性模型预测值为\n$$\nU_{\\text{prod}}(x,z) := X(x) \\cdot W(z).\n$$\n\n为了与孪生素数建立联系，定义截至 $x$ 的精确孪生素数计数函数\n$$\nT(x) := \\left| \\{ n \\in \\mathbb{N} : 3 \\le n \\le x-2, \\; n \\text{ and } n+2 \\text{ are both prime} \\} \\right|.\n$$\n观察到，任何两个素数均大于 $z$ 的孪生素数对，必然能在所有不大于 $z$ 的奇素数的筛除中存活下来，因此属于筛后集。然而，至少有一个素数不大于 $z$ 的孪生素数对可能会被筛法排除。为了恢复一个上界，我们定义\n$$\nB_z(x) := \\left| \\{ n \\in \\mathbb{N} : 3 \\le n \\le \\min(x-2, z), \\; n \\text{ and } n+2 \\text{ are both prime} \\} \\right|,\n$$\n其为较小成员不大于 $z$ 的孪生素数对的数量。那么，量\n$$\nU_{\\text{bound}}(x,z) := S_z(x) + B_z(x)\n$$\n是 $T(x)$ 的一个显式的、可计算的上界，即对于所有的 $x$ 和 $z$ 都有 $T(x) \\le U_{\\text{bound}}(x,z)$。\n\n您的任务是实现一个完整的、可运行的程序，该程序为每个测试用例 $(x,z)$ 计算五元组\n$$\n\\left[ S_z(x), \\; U_{\\text{prod}}(x,z), \\; U_{\\text{bound}}(x,z), \\; T(x), \\; \\big( T(x) \\le U_{\\text{bound}}(x,z) \\big) \\right].\n$$\n所有计算在适当之处（如计数）必须精确执行，在涉及乘积时需以合理的精度进行数值计算；您的程序应将浮点值 $U_{\\text{prod}}(x,z)$ 四舍五入到6位小数。\n\n测试套件：\n- 案例1：$(x,z) = (200,13)$，中等量级，非平凡筛分水平。\n- 案例2：$(x,z) = (1000,37)$，较大量级，中等筛分水平。\n- 案例3：$(x,z) = (50,2)$，边界筛分水平，没有不大于 $z$ 的奇素数，用于检查基集行为。\n- 案例4：$(x,z) = (10000,97)$，更大量级，较高筛分水平。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个由方括号括起来的、以逗号分隔的结果列表。外层列表的每个元素必须是对应测试用例的列表\n$$\n\\left[ S_z(x), \\; U_{\\text{prod}}(x,z), \\; U_{\\text{bound}}(x,z), \\; T(x), \\; \\big( T(x) \\le U_{\\text{bound}}(x,z) \\big) \\right]\n$$\n且顺序与上面列出的顺序一致。例如，输出格式应如下所示\n$$\n\\big[ [\\cdots], [\\cdots], [\\cdots], [\\cdots] \\big].\n$$", "solution": "用户提供了一个定义明确的数论计算问题，具体涉及到将布伦纯筛法应用于孪生素数问题。在进行完整解答之前，我将首先验证问题的完整性。\n\n### 第1步：提取已知条件\n-   **量级参数**: $x \\in \\mathbb{N}$\n-   **筛分水平**: $z \\in \\mathbb{N}$\n-   **基集**: $\\mathcal{A}(x) := \\{ n \\in \\mathbb{N} : 3 \\le n \\le x-2, \\; n \\text{ odd} \\}$\n-   **排除集**: 对于素数 $p$, $\\mathcal{A}_p := \\{ n \\in \\mathcal{A}(x) : p \\mid n \\text{ or } p \\mid (n+2) \\}$\n-   **筛分素数**: $\\mathbb{P}^{\\text{odd}}_{\\le z} := \\{ p \\in \\mathbb{P}_{\\le z} : p \\ge 3 \\}$, 其中 $\\mathbb{P}_{\\le z}$ 是不大于 $z$ 的素数集合。\n-   **筛后集计数**: $S_z(x) := \\left| \\mathcal{A}(x) \\setminus \\bigcup_{p \\in \\mathbb{P}^{\\text{odd}}_{\\le z}} \\mathcal{A}_p \\right|$\n-   **启发式存活因子**: $W(z) := \\prod_{p \\in \\mathbb{P}^{\\text{odd}}_{\\le z}} \\left(1 - \\frac{2}{p}\\right)$\n-   **基集大小**: $X(x) := |\\mathcal{A}(x)| = \\max\\!\\left( \\left\\lfloor \\frac{x-1}{2} \\right\\rfloor - 1, \\, 0 \\right)$\n-   **乘性模型预测**: $U_{\\text{prod}}(x,z) := X(x) \\cdot W(z)$\n-   **孪生素数计数函数**: $T(x) := |\\{ n \\in \\mathbb{N} : 3 \\le n \\le x-2, \\; n \\text{ and } n+2 \\text{ are both prime} \\}|$\n-   **边界孪生素数计数**: $B_z(x) := |\\{ n \\in \\mathbb{N} : 3 \\le n \\le \\min(x-2, z), \\; n \\text{ and } n+2 \\text{ are both prime} \\}|$\n-   **孪生素数的上界**: $U_{\\text{bound}}(x,z) := S_z(x) + B_z(x)$\n-   **约束条件**: 对于所有 $x, z$, $T(x) \\le U_{\\text{bound}}(x,z)$。\n-   **任务**: 为每个测试用例 $(x,z)$，计算五元组 $[ S_z(x), \\; U_{\\text{prod}}(x,z), \\; U_{\\text{bound}}(x,z), \\; T(x), \\; ( T(x) \\le U_{\\text{bound}}(x,z) ) ]$。\n-   **输出规格**: $U_{\\text{prod}}(x,z)$ 必须四舍五入到6位小数。最终输出是这些五元组的列表。\n-   **测试套件**: $(200,13)$, $(1000,37)$, $(50,2)$, $(10000,97)$。\n\n### 第2步：使用提取的已知条件进行验证\n该问题在科学上有筛法理论作为依据，这是解析数论的一个标准分支。所有定义都是形式化的、内部一致的，并与既有概念相对应。上界 $T(x) \\le S_z(x) + B_z(x)$ 的前提在逻辑上是合理的：$T(x)$ 计算所有满足 $n \\le x-2$ 的孪生素数对 $(n, n+2)$。这些素数对可以划分为 $n \\le z$ 的对（由 $B_z(x)$ 计数）和 $n > z$ 的对。对于一个 $n>z$ 且两个元素都是素数的对 $(n, n+2)$，$n$ 必须在所有不大于 $z$ 的奇素数 $p$ 的筛法中存活下来，因为这些素数都小于 $n$ 和 $n+2$。因此，这类素数对的数量由 $S_z(x)$ 作为上界。所以，总和 $S_z(x) + B_z(x)$ 是 $T(x)$ 的一个有效上界。该问题是适定的、客观的，并且对于给定的测试用例在计算上是可行的。\n\n### 第3步：结论与行动\n问题陈述是有效的。将开发并实现一个解决方案。\n\n### 解决方案与算法设计\n\n该任务要求为每对给定的 $(x,z)$ 计算五个不同的量。总体策略是为每个量实现独立的程序，并利用预先计算的素数来提高效率。\n\n**1. 素数生成**\n埃拉托斯特尼筛法是生成所有不大于给定上限的素数的最有效方法。由于测试套件中 $x$ 的最大值为 $10000$，且需要对不大于 $x$ 的数进行素性测试，我们将预先计算所有不大于一个安全上限（例如，$10002$）的素数。这个预计算过程会产生一个用于常数时间素性测试的布尔数组和一个排序的素数列表。\n\n**2. 计算 $S_z(x)$**\n$S_z(x)$ 是在筛分过程中存活下来的基集 $\\mathcal{A}(x)$ 中元素的数量。\n-   基集是 $\\mathcal{A}(x) = \\{ n \\mid 3 \\le n \\le x-2, n \\text{ is odd} \\}$。这个集合的大小是 $X(x) = \\max(\\lfloor (x-1)/2 \\rfloor - 1, 0)$。\n-   我们可以用一个大小为 $X(x)$、初始值全为 `true` 的布尔数组 `survivors` 來表示 $\\mathcal{A}(x)$ 的元素。\n-   该数组中的索引 $k$ 可以映射到一个整数 $n_k = 2k+3$。这覆盖了从3开始的所有奇数。\n-   筛分素数是那些不大于 $z$ 的奇素数 $p$。\n-   对于每个这样的素数 $p$，我们必须排除所有满足 $p \\mid n_k$ 或 $p \\mid (n_k+2)$ 的 $n_k$。这些条件转换为 $n_k$ 模 $p$ 的两个剩余类：$n_k \\equiv 0 \\pmod p$ 和 $n_k \\equiv -2 \\pmod p$。\n-   使用映射 $n_k = 2k+3$，这些条件变成了关于索引 $k$ 的线性同余方程：\n    -   $2k+3 \\equiv 0 \\pmod p \\implies 2k \\equiv -3 \\pmod p \\implies k \\equiv -3 \\cdot 2^{-1} \\pmod p$。\n    -   $2k+3 \\equiv -2 \\pmod p \\implies 2k \\equiv -5 \\pmod p \\implies k \\equiv -5 \\cdot 2^{-1} \\pmod p$。\n    对于奇素数 $p$，模 $p$ 的乘法逆元 $2^{-1}$ 是 $(p+1)/2$。\n-   对每个 $p$，我们计算两个起始索引 $k_0, k_1 \\in [0, p-1]$，并将算术级数 $k_0+j p$ 和 $k_1+j p$ 中所有 $k$ 对应的 `survivors[k]` 标记为 `false`。\n-   最终计数 $S_z(x)$ 是 `survivors` 数组中剩余 `true` 值的数量。\n\n**3. 计算 $U_{\\text{prod}}(x,z)$**\n这是基于其定义的直接计算：$U_{\\text{prod}}(x,z) = X(x) \\cdot W(z)$。\n-   $X(x)$ 如上计算。\n-   $W(z) = \\prod_{p \\in \\mathbb{P}^{\\text{odd}}_{\\le z}} \\left(1 - \\frac{2}{p}\\right)$ 的计算方法是遍历预计算好的不大于 $z$ 的奇素数列表并乘以各个因子。如果不存在这样的素数（例如 $z < 3$），则空积为 $1$。\n-   最终结果四舍五入到6位小数。\n\n**4. 计算 $T(x)$ 和 $B_z(x)$**\n这些是直接的计数问题。\n-   $T(x)$: 我们遍历从 $3$ 到 $x-2$ 的所有奇数 $n$。对于每个 $n$，我们使用预计算的素性测试来检查 $n$ 和 $n+2$ 是否都是素数。每找到这样一个孪生素数对，计数器就加一。\n-   $B_z(x)$: 过程与计算 $T(x)$ 的过程相同，但对 $n$ 的迭代在 $\\min(x-2, z)$ 处停止。\n\n**5. 组装五元组**\n计算完所有部分后，我们组装最终的列表：\n-   $U_{\\text{bound}}(x,z)$ 计算为 $S_z(x)$ 和 $B_z(x)$ 的和。\n-   执行布尔检查 $(T(x) \\le U_{\\text{bound}}(x,z))$。\n-   将这五个值——$S_z(x)$、$U_{\\text{prod}}(x,z)$、$U_{\\text{bound}}(x,z)$、$T(x)$ 和布尔结果——收集到一个列表中，构成一个测试用例的结果。对所有测试用例重复此过程。\n\n这种结构化的方法确保了正确性和效率，满足了问题陈述的所有要求。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef sieve_eratosthenes(n_max):\n    \"\"\"\n    Generates primes up to n_max using the Sieve of Eratosthenes.\n    Returns:\n        is_prime (np.ndarray): A boolean array where is_prime[i] is True if i is prime.\n        primes (list): A list of prime numbers up to n_max.\n    \"\"\"\n    if n_max < 2:\n        return np.zeros(n_max + 1, dtype=bool), []\n    \n    is_prime = np.ones(n_max + 1, dtype=bool)\n    is_prime[0:2] = False\n    for i in range(2, int(np.sqrt(n_max)) + 1):\n        if is_prime[i]:\n            is_prime[i*i::i] = False\n    \n    primes = np.where(is_prime)[0].tolist()\n    return is_prime, primes\n\ndef compute_quintuple(x, z, all_primes, is_prime):\n    \"\"\"\n    Computes the quintuple [S_z(x), U_prod(x,z), U_bound(x,z), T(x), check]\n    for a given (x, z) test case.\n    \"\"\"\n    # Calculate X(x): size of the base set A(x) = {n odd: 3 <= n <= x-2}\n    X = max(((x - 1) // 2) - 1, 0)\n\n    # Calculate S_z(x): sifted set count\n    if X <= 0:\n        S_z_x = 0\n    else:\n        # Array of booleans representing n_k = 2k+3 for k in [0, X-1]\n        survivors = np.ones(X, dtype=bool)\n        sieve_primes = [p for p in all_primes if 3 <= p <= z]\n        \n        for p in sieve_primes:\n            # Modular inverse of 2 mod p is (p+1)/2 for odd prime p\n            inv2 = (p + 1) // 2\n            \n            # Find starting index k for n = 0 (mod p)\n            # 2k + 3 = 0 (mod p) => 2k = -3 (mod p) => k = -3 * inv2 (mod p)\n            k0 = (-3 * inv2) % p\n            \n            # Find starting index k for n = -2 (mod p)\n            # 2k + 3 = -2 (mod p) => 2k = -5 (mod p) => k = -5 * inv2 (mod p)\n            k1 = (-5 * inv2) % p\n            \n            # Sieve the candidates array\n            if k0 < X:\n                survivors[k0::p] = False\n            # k0 != k1 for odd p, so no need to check for double-sieving the same progression\n            if k1 < X:\n                survivors[k1::p] = False\n                \n        S_z_x = int(np.sum(survivors))\n\n    # Calculate W(z) and U_prod(x, z)\n    sieve_primes_for_W = [p for p in all_primes if 3 <= p <= z]\n    W_z = 1.0\n    if sieve_primes_for_W:\n        factors = [1.0 - 2.0/p for p in sieve_primes_for_W]\n        W_z = np.prod(factors)\n    \n    U_prod_x_z = round(X * W_z, 6)\n\n    # Calculate T(x): twin prime counting function up to x\n    T_x = 0\n    upper_n_T = x - 2\n    # n must be odd so we can step by 2\n    for n in range(3, upper_n_T + 1, 2):\n        if n + 2 < len(is_prime) and is_prime[n] and is_prime[n+2]:\n            T_x += 1\n\n    # Calculate B_z(x): twin primes with smaller member <= min(x-2, z)\n    B_z_x = 0\n    upper_n_B = min(x - 2, z)\n    for n in range(3, upper_n_B + 1, 2):\n        if n + 2 < len(is_prime) and is_prime[n] and is_prime[n+2]:\n            B_z_x += 1\n            \n    # Calculate U_bound(x, z)\n    U_bound_x_z = S_z_x + B_z_x\n    \n    # Check the inequality T(x) <= U_bound(x, z)\n    bound_check = bool(T_x <= U_bound_x_z)\n    \n    return [S_z_x, U_prod_x_z, U_bound_x_z, T_x, bound_check]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (200, 13),\n        (1000, 37),\n        (50, 2),\n        (10000, 97),\n    ]\n\n    max_x = 0\n    if test_cases:\n        max_x = max(case[0] for case in test_cases)\n\n    # Pre-compute primes up to a safe limit. Primality of n+2 for n up to x-2 is needed.\n    # The largest n+2 is max_x.\n    prime_limit = max_x\n    is_prime, all_primes = sieve_eratosthenes(prime_limit)\n\n    results = []\n    for x, z in test_cases:\n        result = compute_quintuple(x, z, all_primes, is_prime)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    result_strings = [str(r).replace(' ', '') for r in results]\n    print(f\"[{','.join(result_strings)}]\")\n\nsolve()\n```", "id": "3009401"}]}