{"hands_on_practices": [{"introduction": "理论学习的最佳方式之一是将其付诸实践。本练习旨在巩固您对埃拉托斯特尼-勒让德筛法基本公式的理解。通过对一个具体的小数据集（$x=50, z=7$）进行计算，您将直接应用容斥原理，并将抽象的$\\sum_{d \\mid M(z)} \\mu(d) \\lfloor x/d \\rfloor$公式转化为一个具体的数值。这个过程不仅能帮助您掌握计算技巧，还能通过列举被计数的整数来直观地验证结果，从而加深对“筛选”过程的物理感受[@problem_id:3025971]。", "problem": "设 $\\mathcal{A} = \\{n \\in \\mathbb{N} : 1 \\leq n \\leq x\\}$ 且设 $\\mathcal{P}$ 表示素数集合。对于一个实数参数 $z > 1$，定义埃拉托斯特尼-勒让德（Eratosthenes–Legendre）筛量\n$$\nS(\\mathcal{A}, \\mathcal{P}, z) := \\left|\\left\\{n \\in \\mathcal{A} : p \\nmid n \\text{ for all primes } p \\in \\mathcal{P} \\text{ with } p < z \\right\\}\\right|.\n$$\n从整除性和莫比乌斯（Möbius）函数 $\\mu(n)$（其定义为 $\\mu(1) = 1$，若 $n$ 能被一个平方数整除则 $\\mu(n) = 0$，若 $n$ 是无平方因子数且有 $\\omega(n)$ 个不同的素因子则 $\\mu(n) = (-1)^{\\omega(n)}$）的基本定义出发，当 $\\mathcal{A} = \\{1,2,\\dots,x\\}$ 时，通过对小于 $z$ 的素数之积的所有无平方因子数除数作容斥求和，推导出 $S(\\mathcal{A}, \\mathcal{P}, z)$ 的表达式。然后，对特定值 $x = 50$ 和 $z = 7$ 计算 $S(\\mathcal{A}, \\mathcal{P}, z)$ 的值，并明确列出在 $\\{1,2,\\dots,50\\}$ 中被 $S(\\mathcal{A}, \\mathcal{P}, 7)$ 计数的整数。你最终报告的量应为 $S(\\mathcal{A}, \\mathcal{P}, 7)$ 的精确值。无需四舍五入。", "solution": "我们首先重述我们所关注的量。对于 $\\mathcal{A} = \\{1,2,\\dots,x\\}$ 和 $z > 1$，由 $S(\\mathcal{A}, \\mathcal{P}, z)$ 计数的集合包含那些不被任何严格小于 $z$ 的素数整除的 $n \\leq x$。设\n$$\nM(z) := \\prod_{p \\in \\mathcal{P},\\, p < z} p,\n$$\n即小于 $z$ 的所有素数之积。那么条件“没有素数 $p < z$ 整除 $n$”等价于 $\\gcd(n, M(z)) = 1$。\n\n一个源自容斥原理和莫比乌斯反演的标准筛法恒等式用莫比乌斯函数表示互质指示函数：\n$$\n\\mathbf{1}_{\\gcd(n, M(z)) = 1} = \\sum_{d \\mid \\gcd(n, M(z))} \\mu(d) = \\sum_{\\substack{d \\mid M(z) \\\\ d \\mid n}} \\mu(d).\n$$\n这可由莫比乌斯函数的积性性质以及以下恒等式得出\n$$\n\\sum_{d \\mid m} \\mu(d) =\n\\begin{cases}\n1 & \\text{if } m = 1, \\\\\n0 & \\text{if } m > 1,\n\\end{cases}\n$$\n并结合 $m = \\gcd(n, M(z))$。对 $n \\leq x$ 求和可得\n$$\nS(\\mathcal{A}, \\mathcal{P}, z) = \\sum_{n \\leq x} \\sum_{\\substack{d \\mid M(z) \\\\ d \\mid n}} \\mu(d)\n= \\sum_{d \\mid M(z)} \\mu(d) \\sum_{\\substack{n \\leq x \\\\ d \\mid n}} 1\n= \\sum_{d \\mid M(z)} \\mu(d) \\left\\lfloor \\frac{x}{d} \\right\\rfloor.\n$$\n这就是埃拉托斯特尼-勒让德筛法对于区间 $\\{1,\\dots,x\\}$ 在层级 $z$ 对筛后集合大小的容斥计算。\n\n现在我们具体取 $x=50$ 和 $z=7$。严格小于 $z=7$ 的素数是 $2$、$3$ 和 $5$，因此\n$$\nM(7) = 2 \\cdot 3 \\cdot 5 = 30.\n$$\n$30$ 的无平方因子数除数 $d$ 是 $1, 2, 3, 5, 6, 10, 15, 30$。它们的莫比乌斯函数值分别为\n$$\n\\mu(1) = 1,\\quad \\mu(2) = -1,\\quad \\mu(3) = -1,\\quad \\mu(5) = -1,\\quad \\mu(6) = 1,\\quad \\mu(10) = 1,\\quad \\mu(15) = 1,\\quad \\mu(30) = -1.\n$$\n因此，\n\\begin{align*}\nS(\\mathcal{A}, \\mathcal{P}, 7)\n&= \\mu(1)\\left\\lfloor \\frac{50}{1} \\right\\rfloor\n+ \\mu(2)\\left\\lfloor \\frac{50}{2} \\right\\rfloor\n+ \\mu(3)\\left\\lfloor \\frac{50}{3} \\right\\rfloor\n+ \\mu(5)\\left\\lfloor \\frac{50}{5} \\right\\rfloor \\\\\n&\\quad + \\mu(6)\\left\\lfloor \\frac{50}{6} \\right\\rfloor\n+ \\mu(10)\\left\\lfloor \\frac{50}{10} \\right\\rfloor\n+ \\mu(15)\\left\\lfloor \\frac{50}{15} \\right\\rfloor\n+ \\mu(30)\\left\\lfloor \\frac{50}{30} \\right\\rfloor \\\\\n&= 1 \\cdot 50\n+ (-1) \\cdot 25\n+ (-1) \\cdot 16\n+ (-1) \\cdot 10\n+ 1 \\cdot 8\n+ 1 \\cdot 5\n+ 1 \\cdot 3\n+ (-1) \\cdot 1 \\\\\n&= 50 - 25 - 16 - 10 + 8 + 5 + 3 - 1 \\\\\n&= 14.\n\\end{align*}\n\n为了解释这个结果并明确列出被计数的整数，我们注意到条件是“不能被 $2, 3$ 或 $5$ 整除”，也就是与 $30$ 互质。模 $30$ 与 $30$ 互质的余数是 $1, 7, 11, 13, 17, 19, 23, 29$，因此在 $\\{1,\\dots,50\\}$ 中被 $S(\\mathcal{A}, \\mathcal{P}, 7)$ 计数的整数是\n$$\n1,\\, 7,\\, 11,\\, 13,\\, 17,\\, 19,\\, 23,\\, 29,\\, 31,\\, 37,\\, 41,\\, 43,\\, 47,\\, 49,\n$$\n这证实了恰好有 $14$ 个这样的整数。\n\n因此，对于 $x=50$，其精确值为 $S(\\mathcal{A}, \\mathcal{P}, 7) = 14$。", "answer": "$$\\boxed{14}$$", "id": "3025971"}, {"introduction": "在掌握了基本公式后，下一个挑战是如何高效地进行计算。直接计算容斥求和式中的所有项在$z$较大时是不可行的，因为除数$d$的数目会呈指数级增长。本练习将引导您利用莫比乌斯函数 $\\mu(n)$的关键性质——乘法性，将一个复杂的求和问题$\\sum_{d|P(z)}\\mu(d)/d$转化为一个简单的连乘积。这一转变不仅是理论上的一个优美结果，更是计算数论中一个核心的优化思想，它使得筛法在实际应用中变得可行[@problem_id:3025989]。", "problem": "设 $z$ 为一个正整数，并令 $P(z)$ 表示所有小于或等于 $z$ 的素数的乘积，即 $P(z)=\\prod_{p\\le z}p$。考虑算术函数 $\\mu$，即莫比乌斯函数，其在正整数上的定义为 $\\mu(1)=1$，若 $n$ 有平方素数因子则 $\\mu(n)=0$，若 $n$ 是 $k$ 个不同素数的乘积则 $\\mu(n)=(-1)^k$。定义和\n$$\nS(z)=\\sum_{d\\mid P(z)}\\frac{\\mu(d)}{d}.\n$$\n当通过对剩余类的贡献进行重新加权，以估计不被小素数整除的整数数量时，这个和在埃拉托斯特尼-勒让德筛法 (ELS) 的组合公式中会自然出现。\n\n从以下基本原理出发：\n- 莫比乌斯函数 $\\mu$ 是积性函数，即当 $\\gcd(a,b)=1$ 时，$\\mu(ab)=\\mu(a)\\mu(b)$。\n- 函数 $f(n)=\\mu(n)/n$ 是积性函数，因为两个积性函数的商在互素的参数上也是积性的。\n- 如果 $f$ 是积性函数，那么对于任何由两两互素的整数组成的有限集 $\\{n_i\\}$，有 $\\sum_{d\\mid \\prod_i n_i} f(d)=\\prod_i \\left(\\sum_{e\\mid n_i} f(e)\\right)$，这是对因子和的积性性质的重述。\n- 如果 $p$ 是素数，那么 $p$ 的因子只有 $1$ 和 $p$，因此 $\\sum_{e\\mid p} f(e)=f(1)+f(p)$。\n\n你的任务是：\n1. 仅使用上述基本原理，推导出 $S(z)$ 的一个恒等式，该恒等式将 $S(z)$ 表示为关于小于或等于 $z$ 的素数的有限乘积。推导过程必须是纯数学的，并清楚地解释该恒等式是什么，为什么成立，以及它如何从积性性质和 $P(z)$ 的结构中得出。\n2. 解释所推导的恒等式如何避免了遍历 $P(z)$ 的所有因子 $d$ 的需要，以及为什么这能在埃拉托斯特尼-勒让德筛法框架内带来一个计算上高效的算法。\n3. 实现一个完整的、可运行的程序，该程序：\n   - 使用经典的埃拉托斯特尼筛法生成所有小于或等于 $z$ 的素数。\n   - 使用任务1中推导出的关于素数的乘积恒等式计算 $S(z)$，而不遍历所有因子 $d$。\n   - 生成四舍五入到 $12$ 位小数的浮点数结果，以小数形式表示。\n\n测试套件与输出规范：\n- 对 $z$ 使用以下输入值测试套件：$z\\in\\{1,2,10,1000,100000\\}$。\n- 对于测试套件中的每个 $z$，将 $S(z)$ 的值作为浮点数输出，四舍五入到 $12$ 位小数。\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[r_1,r_2,r_3,r_4,r_5]$），其中 $r_i$ 对应于按上述顺序指定的第 $i$ 个测试用例的结果。", "solution": "该问题要求推导和 $S(z) = \\sum_{d\\mid P(z)}\\frac{\\mu(d)}{d}$ 的恒等式，解释其计算效用，并基于此恒等式实现一个算法。此处，$z$ 是一个正整数，$P(z) = \\prod_{p \\le z} p$ 是 $z$ 的素数阶乘，而 $\\mu$ 是莫比乌斯函数。\n\n### 任务1：$S(z)$ 恒等式的推导\n\n出发点是该和的定义：\n$$\nS(z) = \\sum_{d\\mid P(z)}\\frac{\\mu(d)}{d}\n$$\n我们定义一个算术函数 $f(n) = \\frac{\\mu(n)}{n}$。问题陈述正确地指出此函数是积性函数。这是因为莫比乌斯函数 $\\mu(n)$ 和恒等函数 $g(n)=n$ 都是积性函数，而两个积性函数的商本身也是积性函数。通过这个定义，和变为：\n$$\nS(z) = \\sum_{d\\mid P(z)} f(d)\n$$\n数 $P(z)$ 是所有小于或等于 $z$ 的不同素数的乘积。设这些素数为 $p_1, p_2, \\dots, p_k$，其中对所有 $i=1, \\dots, k$ 都有 $p_i \\le z$。因此，$P(z) = p_1 p_2 \\cdots p_k$。根据定义，素数 $p_1, \\dots, p_k$ 是两两互素的。\n\n问题提供了一个关于积性函数在因子上的和的基本性质：如果 $f$ 是一个积性函数，且 $\\{n_i\\}$ 是一个由两两互素的整数组成的有限集，则\n$$\n\\sum_{d\\mid \\prod_i n_i} f(d)=\\prod_i \\left(\\sum_{e\\mid n_i} f(e)\\right)\n$$\n我们将此性质应用于我们的和 $S(z)$，其中两两互素的整数集是小于或等于 $z$ 的素数集。这得到：\n$$\nS(z) = \\sum_{d\\mid \\prod_{p\\le z} p} f(d) = \\prod_{p\\le z} \\left(\\sum_{e\\mid p} f(e)\\right)\n$$\n下一步是计算内层的和 $\\sum_{e\\mid p} f(e)$，针对单个素数 $p$。一个素数 $p$ 的因子恰好是 $1$ 和 $p$。因此，对这些因子的求和为：\n$$\n\\sum_{e\\mid p} f(e) = f(1) + f(p)\n$$\n现在我们使用定义 $f(n) = \\mu(n)/n$ 和莫比乌斯函数的性质来计算 $f(1)$ 和 $f(p)$：\n1. 对于 $n=1$，$\\mu(1) = 1$。因此，$f(1) = \\frac{\\mu(1)}{1} = \\frac{1}{1} = 1$。\n2. 对于一个素数 $n=p$，$p$ 是 $k=1$ 个不同素数的乘积。根据定义，$\\mu(p) = (-1)^1 = -1$。因此，$f(p) = \\frac{\\mu(p)}{p} = \\frac{-1}{p}$。\n\n将这些值代回到关于 $p$ 的因子和的表达式中：\n$$\n\\sum_{e\\mid p} f(e) = 1 + \\left(-\\frac{1}{p}\\right) = 1 - \\frac{1}{p}\n$$\n最后，我们将内层和的这个结果代回到 $S(z)$ 的乘积表达式中。这就得到了所求的恒等式：\n$$\nS(z) = \\prod_{p\\le z} \\left(1 - \\frac{1}{p}\\right)\n$$\n这个恒等式将 $S(z)$ 表示为关于小于或等于 $z$ 的素数的有限乘积，符合要求。这是欧拉乘积的一个特例。\n\n### 任务2：计算效率分析\n\n与直接计算和 $S(z) = \\sum_{d \\mid P(z)} \\frac{\\mu(d)}{d}$ 相比，推导出的恒等式 $S(z) = \\prod_{p \\le z} \\left(1 - \\frac{1}{p}\\right)$ 提供了巨大的计算优势。\n\n令 $\\pi(z)$ 表示小于或等于 $z$ 的素数个数。\n原始公式要求对 $P(z) = \\prod_{p \\le z} p$ 的所有因子 $d$ 进行求和。由于 $P(z)$ 是 $\\pi(z)$ 个不同素数的乘积， $P(z)$ 的任何因子都是通过选择这些素数的一个子集并将它们相乘而形成的。这样的子集有 $2^{\\pi(z)}$ 个，因此这也是 $P(z)$ 的因子数。\n直接计算该和的算法将具有以下结构：\n1. 找出所有小于等于 $z$ 的 $\\pi(z)$ 个素数。\n2. 生成 $P(z)$ 的所有 $2^{\\pi(z)}$ 个因子。\n3. 对于每个因子 $d$，计算 $\\mu(d)$，执行除法 $\\frac{\\mu(d)}{d}$，并将其加到一个运行总和上。\n项数 $2^{\\pi(z)}$ 随着素数个数呈指数级增长。对于 $z=1000$，$\\pi(1000) = 168$，导致有 $2^{168} \\approx 3.7 \\times 10^{50}$ 项，这在计算上是不可行的。\n\n相比之下，该乘积恒等式导出了一个效率高得多的算法：\n1. 生成所有小于或等于 $z$ 的 $\\pi(z)$ 个素数 $p$。这可以使用埃拉托斯特尼筛法高效完成，时间复杂度约为 $O(z \\log \\log z)$。\n2. 初始化一个乘积变量为 $1.0$。\n3. 遍历这 $\\pi(z)$ 个素数的列表。对于每个素数 $p$，计算项 $1 - \\frac{1}{p}$ 并将其与运行乘积相乘。这涉及 $\\pi(z)$ 次减法、$\\pi(z)$ 次除法和 $\\pi(z)-1$ 次乘法。\n在初始生成素数后，计算的复杂度与 $\\pi(z)$ 成正比，根据素数定理，$\\pi(z)$ 约等于 $z/\\ln z$。这是一个从指数复杂度 $O(2^{\\pi(z)})$ 到一个基本与素数数量呈线性关系的复杂度的巨大改进。对于 $z=100000$，其中 $\\pi(100000) = 9592$，该乘积只涉及不到 $10000$ 次乘法，对现代计算机来说是微不足道的任务。\n\n这种从指数时间求和到近线性时间乘积的转换，是数论恒等式在设计高效算法方面强大作用的一个经典例子。正是这种效率使得像埃拉托斯特尼-勒让德筛法这样的筛法在计算素数或其他类似数集时变得实用。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes S(z) for a suite of test cases and prints the results.\n    S(z) is defined as the sum of mu(d)/d over divisors d of P(z),\n    where P(z) is the product of primes <= z.\n    The computation uses the derived product identity: S(z) = product_{p<=z} (1 - 1/p).\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [1, 2, 10, 1000, 100000]\n\n    def sieve_of_eratosthenes(n: int) -> list[int]:\n        \"\"\"\n        Generates all prime numbers up to n using the Sieve of Eratosthenes.\n        Uses numpy for efficient boolean array operations.\n\n        Args:\n            n: The upper limit for prime generation (inclusive).\n\n        Returns:\n            A list of prime numbers less than or equal to n.\n        \"\"\"\n        if n < 2:\n            return []\n        \n        # Create a boolean array `is_prime` of size n+1, initialized to True.\n        # is_prime[i] will be False if i is not a prime, and True otherwise.\n        is_prime = np.ones(n + 1, dtype=bool)\n        \n        # 0 and 1 are not prime numbers.\n        is_prime[0:2] = False\n        \n        # Iterate from p = 2 up to sqrt(n).\n        for p in range(2, int(np.sqrt(n)) + 1):\n            if is_prime[p]:\n                # If p is prime, then all its multiples are not prime.\n                # We can start marking from p*p, as smaller multiples\n                # would have been marked by smaller primes.\n                is_prime[p*p::p] = False\n        \n        # Return the indices where is_prime is True.\n        return np.where(is_prime)[0].tolist()\n\n    def calculate_S_z(z: int) -> float:\n        \"\"\"\n        Calculates S(z) using the product identity over primes.\n\n        Args:\n            z: The integer parameter defining the product range.\n\n        Returns:\n            The computed value of S(z) as a float.\n        \"\"\"\n        # For z < 2, the set of primes is empty. The empty product is defined as 1.\n        if z < 2:\n            return 1.0\n        \n        # Generate primes up to z.\n        primes = sieve_of_eratosthenes(z)\n        \n        # Compute the product S(z) = product_{p<=z} (1 - 1/p).\n        s_z = 1.0\n        for p in primes:\n            s_z *= (1.0 - 1.0 / p)\n            \n        return s_z\n\n    results = []\n    for z in test_cases:\n        # Calculate S(z) for the current test case.\n        result = calculate_S_z(z)\n        \n        # Round the result to 12 decimal places as specified.\n        rounded_result = round(result, 12)\n        results.append(rounded_result)\n\n    # Format the final output as a single-line, comma-separated list in brackets.\n    # The map(str, ...) converts each float to its string representation.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3025989"}, {"introduction": "本章的最后一个实践将带您从组合筛法过渡到解析数论的领域。当参数$z$变得很大时，筛法的结果会揭示出深刻的渐近行为。这个练习让您探索筛出整数的密度 $\\prod_{p<z}(1-1/p)$，并将其与解析数论中的一个经典结果——梅滕斯第三定理（Mertens' third theorem）联系起来。通过计算并比较这两种模型，您将理解埃拉托斯特尼-勒让德筛法预测的主项与实际密度之间的关系，并接触到重要的数学常数$e^{-\\gamma}$[@problem_id:3025994]，这对于理解更高级筛法的误差项至关重要。", "problem": "设 $x$ 是一个大的正实数， $z$ 是一个满足 $z \\geq 2$ 的正实数参数。定义 $S(x,z)$ 为小于等于 $x$ 且其所有素因数都不小于 $z$ 的正整数 $n$ 的个数。由埃拉托斯特尼-勒让德筛法预测的一阶主项，是通过在单素数层级截断容斥展开，并将不被每个素数 $p<z$ 整除的整数密度建模为 $1-1/p$ 来获得的。在此近似下，该筛法预测的主项形式为\n$$\nx \\prod_{p<z}\\left(1-\\frac{1}{p}\\right).\n$$\n对于具体参数 $x=10^{9}$ 和 $z=10^{4}$，基于经过充分检验的解析数论输入，计算此主项的数值近似，并将其与用 $1/\\ln z$ 替代比例 $\\prod_{p<z}\\left(1-\\frac{1}{p}\\right)$ 的朴素模型进行比较。为量化此比较，请报告无量纲比\n$$\n\\mathcal{R}(z)\\;=\\;\\ln z\\;\\prod_{p<z}\\left(1-\\frac{1}{p}\\right),\n$$\n其中使用自然对数。将您报告的 $\\mathcal{R}(10^{4})$ 值四舍五入到三位有效数字。此计算不涉及物理单位。", "solution": "本题要求计算在特定参数 $z = 10^4$ 下无量纲比 $\\mathcal{R}(z)$ 的数值。该比率定义为：\n$$\n\\mathcal{R}(z) = \\ln z \\prod_{p<z}\\left(1-\\frac{1}{p}\\right)\n$$\n其中，乘积遍及所有严格小于 $z$ 的素数 $p$，$\\ln$ 表示自然对数。对于给定值 $z = 10^4$，我们需要计算：\n$$\n\\mathcal{R}(10^4) = \\ln(10^4) \\prod_{p<10^4}\\left(1-\\frac{1}{p}\\right)\n$$\n题目陈述通过将此比率与埃拉托斯特尼-勒让德筛法相关联，为其提供了背景。表达式 $\\prod_{p<z}(1-1/p)$ 表示一个简单筛法模型所预测的、不被任何小于 $z$ 的素数整除的整数的密度。一个更粗略的“朴素”模型将此密度近似为 $1/\\ln z$。因此，比率 $\\mathcal{R}(z)$ 量化了这两种近似之间的关系。\n\n直接计算所有小于 $10^4$ 的素数（共有 $1229$ 个）的乘积，计算量大且无必要。“基于经过充分检验的解析数论输入”这一表述，指引我们对该乘积使用一个强大的渐进结果。\n\n相关的结果是默滕斯第三定理，它是解析数论的基石之一。该定理描述了对素数求和的项 $(1-1/p)$ 的乘积的渐进行为。该定理的标准形式表述为：\n$$\n\\lim_{Z\\to\\infty} \\left( \\ln(Z) \\prod_{p \\leq Z} \\left(1-\\frac{1}{p}\\right) \\right) = e^{-\\gamma}\n$$\n其中 $\\gamma$ 是欧拉-马歇罗尼常数。\n\n我们问题中的乘积 $\\prod_{p<z}(1-1/p)$，是遍及严格小于 $z$ 的素数。对于任何非素数值的 $z$，例如 $z=10^4$，素数集合 $\\{p | p < z\\}$ 与某个 $z' < z$ 的集合 $\\{p | p \\leq z'\\}$ 是相同的。具体来说，对于 $z=10^4$，乘积遍及小于 $10^4$ 的最大素数（即 $9973$）及之前的所有素数。当 $z \\to \\infty$ 时，在极限中使用 $p<z$ 和 $p\\leq z$ 之间的差异是无关紧要的。因此，当 $z \\to \\infty$ 时，表达式 $\\mathcal{R}(z)$ 的极限恰好是默滕斯定理给出的常数：\n$$\n\\lim_{z\\to\\infty} \\mathcal{R}(z) = \\lim_{z\\to\\infty} \\left( \\ln z \\prod_{p<z}\\left(1-\\frac{1}{p}\\right) \\right) = e^{-\\gamma}\n$$\n题目要求计算 $\\mathcal{R}(10^4)$ 的数值近似。由于 $z = 10^4$ 是一个很大的值，渐进极限 $e^{-\\gamma}$ 为 $\\mathcal{R}(10^4)$ 提供了一个极佳的近似。更高级的误差界，例如 Rosser 和 Schoenfeld 给出的误差界，证实了对于 $z=10^4$，$\\mathcal{R}(10^4)$ 的值非常接近 $e^{-\\gamma}$，且其差异在四舍五入到所需精度时不会影响结果。\n\n我们接下来计算 $e^{-\\gamma}$ 的值。欧拉-马歇罗尼常数约等于：\n$$\n\\gamma \\approx 0.5772156649\n$$\n使用这个值，我们计算 $\\mathcal{R}(10^4)$ 的近似值：\n$$\n\\mathcal{R}(10^4) \\approx e^{-\\gamma} \\approx \\exp(-0.5772156649) \\approx 0.5614594836\n$$\n题目要求将此值四舍五入到三位有效数字。前三位有效数字是 $5$、$6$ 和 $1$。第四位有效数字是 $4$，小于 $5$，因此我们向下舍入。\n$$\n\\mathcal{R}(10^4) \\approx 0.561\n$$\n这个结果意味着，对于 $z=10^4$，朴素密度模型 $1/\\ln z$ 高估了筛法密度 $\\prod_{p<z}(1-1/p)$，其高估的倍数约为 $1/0.561 \\approx 1.78$。常数 $e^{-\\gamma}$ 是在渐进极限下协调这两个模型的修正因子。", "answer": "$$\\boxed{0.561}$$", "id": "3025994"}]}