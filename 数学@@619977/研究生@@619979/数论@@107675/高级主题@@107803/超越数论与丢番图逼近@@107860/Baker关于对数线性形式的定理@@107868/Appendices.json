{"hands_on_practices": [{"introduction": "要真正掌握一个深刻的理论，最好的方法之一就是亲手计算一个具体实例。本练习旨在揭开 Baker 理论（在此为 Matveev 定理的一个特例）的神秘面纱，指导您为一个简单的双对数线性型计算一个明确的下界 [@problem_id:3008823]。通过逐步确定数域次数 $D$、代数数的绝对对数高 $h(\\alpha)$ 以及其他相关参数，您将把抽象的定理转化为一个切实的数值结果，从而加深对这些核心概念的理解。", "problem": "设 $K$ 为数域 $\\mathbb{Q}$，并考虑对数线性形式 $\\Lambda = \\ln 2 - 2 \\ln 3$。使用 $\\mathbb{Q}$ 上的绝对对数 Weil 高度，以及 Matveev 定理为代数数的对数线性形式提供的一般显式下界，请按以下步骤进行：\n\n- 确定域次数 $D = [K : \\mathbb{Q}]$。\n- 计算绝对对数高度 $h(2)$ 和 $h(3)$。\n- 确定量 $|\\ln 2|$ 和 $|\\ln 3|$。\n- 设 $B$ 为该线性形式中整数系数绝对值的最大值。\n- 根据 Matveev 下界的标准假设，从中选择参数 $A_{1}$ 和 $A_{2}$（即，每个 $A_{i}$ 必须不小于域次数加权的高度、对数的绝对值以及一个固定的正下阈值）。\n- 应用 Matveev 对 $|\\Lambda|$ 的显式下界，使用这些选择的参数，并采用适用于两个对数的标准常数。\n\n您的任务是计算 $|\\ln 2 - 2 \\ln 3|$ 的一个具体的显式下界，并将其表示为单个闭式解析表达式。不要简化该线性形式本身，也不要使用任何对消恒等式。最终下界请使用 $\\ln$ 表示自然对数。无需进行四舍五入。", "solution": "用户提供了一个问题，要求使用 Matveev 定理计算一个对数线性形式的下界。\n\n### 步骤 1：问题验证\n\n问题陈述要求将数论中的一个特定定理（Matveev 定理）应用于给定的对数线性形式 $\\Lambda = \\ln 2 - 2 \\ln 3$。\n\n-   **提取已知条件：**\n    -   数域：$K = \\mathbb{Q}$。\n    -   线性形式：$\\Lambda = \\ln 2 - 2 \\ln 3$。\n    -   方法：Matveev 的代数数对数线性形式定理。\n    -   高度函数：绝对对数 Weil 高度 $h(\\cdot)$。\n    -   问题提供了一系列需要遵循的步骤：确定域次数 $D$、计算高度 $h(\\alpha_i)$、确定 $|\\ln \\alpha_i|$、找到系数界 $B$、选择参数 $A_i$ 并应用该下界。\n\n-   **使用提取的已知条件进行验证：**\n    1.  **科学性：** 该问题深植于超越数理论，并涉及一个重要且已确立的成果（Matveev 定理）的直接应用。数域、对数高度和对数线性形式等概念是该领域的标准内容。\n    2.  **适定性：** 该问题是适定的。它提供了一个特定的线性形式、一个确定的上下文（域 $\\mathbb{Q}$）以及应用特定定理的清晰步骤。其目标是计算一个单一的具体值（下界的解析表达式）。条件 $\\Lambda \\neq 0$ 对于下界的非平凡性至关重要，并且该条件是满足的，因为 $\\ln 2 - 2 \\ln 3 = \\ln (2/9) \\neq \\ln 1 = 0$。\n    3.  **客观性：** 该问题以精确、客观和形式化的数学语言陈述。\n    4.  **完整性：** 该问题是自洽的。它指定了所有必要组成部分：数、系数、域以及要使用的定理。虽然“适用于两个对数的标准常数”这一短语可能略显含糊，但一个合理的解释是，将 Matveev 通用定理中的常数特化到 $n=2$ 的情况，这是一个标准做法。\n\n-   **结论：**\n    该问题有效。它是在数论中应用一个关键定理的明确练习。\n\n### 步骤 2：求解\n\n我们按照问题陈述中概述的步骤，计算 $|\\Lambda|$ 的下界，其中 $\\Lambda = \\ln 2 - 2 \\ln 3$。\n\n该线性形式的类型为 $\\Lambda = b_1 \\ln \\alpha_1 + b_2 \\ln \\alpha_2$，包含 $n=2$ 个对数。\n与给定形式进行比较，我们确定以下组成部分：\n-   代数数：$\\alpha_1 = 2$ 和 $\\alpha_2 = 3$。\n-   整数系数：$b_1 = 1$ 和 $b_2 = -2$。\n\n**域次数 $D$**\n数域 $K$ 被指定为 $\\mathbb{Q}$。代数数 $\\alpha_1 = 2$ 和 $\\alpha_2 = 3$ 是有理数，因此它们生成的域是 $\\mathbb{Q}(2, 3) = \\mathbb{Q}$。该域在 $\\mathbb{Q}$ 上的次数是：\n$$D = [K : \\mathbb{Q}] = [\\mathbb{Q} : \\mathbb{Q}] = 1$$\n\n**绝对对数高度**\n对于有理数 $\\alpha = p/q$（其中 $p, q$ 是互质整数），其绝对对数 Weil 高度 $h(\\alpha)$ 由 $h(\\alpha) = \\ln(\\max\\{|p|, |q|\\})$ 给出。\n-   对于 $\\alpha_1 = 2 = 2/1$：整数 $p=2, q=1$ 互质。\n    $$h(2) = \\ln(\\max\\{|2|, |1|\\}) = \\ln 2$$\n-   对于 $\\alpha_2 = 3 = 3/1$：整数 $p=3, q=1$ 互质。\n    $$h(3) = \\ln(\\max\\{|3|, |1|\\}) = \\ln 3$$\n\n**对数的绝对值**\n由于 $2 > 1$ 且 $3 > 1$，它们的自然对数都是正数。\n-   $|\\ln \\alpha_1| = |\\ln 2| = \\ln 2$。\n-   $|\\ln \\alpha_2| = |\\ln 3| = \\ln 3$。\n\n**系数界 $B$**\n界 $B$ 是整数系数 $b_i$ 绝对值的最大值。\n$$B = \\max\\{|b_1|, |b_2|\\} = \\max\\{|1|, |-2|\\} = 2$$\n\n**参数 $A_1$ 和 $A_2$**\n对于每个 $i \\in \\{1, 2\\}$，我们必须选择 $A_i$ 使得 $A_i \\ge \\max\\{D h(\\alpha_i), |\\ln \\alpha_i|, 0.16\\}$。\n-   对于 $\\alpha_1 = 2$：\n    我们需要 $A_1 \\ge \\max\\{D h(2), |\\ln 2|, 0.16\\} = \\max\\{1 \\cdot \\ln 2, \\ln 2, 0.16\\}$。\n    由于 $\\ln 2 \\approx 0.6931$，大于 $0.16$，因此最大值为 $\\ln 2$。我们选择最小的有效值：\n    $$A_1 = \\ln 2$$\n-   对于 $\\alpha_2 = 3$：\n    我们需要 $A_2 \\ge \\max\\{D h(3), |\\ln 3|, 0.16\\} = \\max\\{1 \\cdot \\ln 3, \\ln 3, 0.16\\}$。\n    由于 $\\ln 3 \\approx 1.0986$，大于 $0.16$，因此最大值为 $\\ln 3$。我们选择最小的有效值：\n    $$A_2 = \\ln 3$$\n\n**应用 Matveev 定理**\n我们使用 Matveev (2000) 研究工作中的一般显式下界。该结果的一个常用表述是，对于一个非零线性形式 $\\Lambda$：\n$$\\ln|\\Lambda| > -C(n) D^2 (1+\\ln D) (1+\\ln B) A_1 \\cdots A_n$$\n其中常数 $C(n)$ 由 $C(n) = 1.4 \\cdot 30^{n+3} \\cdot n^{4.5}$ 给出。\n我们代入上面确定的参数：\n-   $n = 2$\n-   $D = 1$\n-   $B = 2$\n-   $A_1 = \\ln 2$\n-   $A_2 = \\ln 3$\n\n首先，我们计算依赖于 $n$ 和 $D$ 的乘法常数因子。短语“适用于两个对数的标准常数”被解释为将通用常数特化到 $n=2$ 的情况。\n项 $(1+\\ln D)$ 变为 $(1+\\ln 1) = 1+0 = 1$。\n下界中的常数部分为：\n$$C(2) D^2 (1+\\ln D) = (1.4 \\cdot 30^{2+3} \\cdot 2^{4.5}) \\cdot 1^2 \\cdot (1+\\ln 1) = 1.4 \\cdot 30^5 \\cdot 2^{4.5}$$\n注意 $2^{4.5} = 2^{9/2}$。\n\n现在，我们组合得到 $\\ln|\\Lambda|$ 的完整不等式：\n$$\\ln|\\Lambda| > -(1.4 \\cdot 30^5 \\cdot 2^{9/2}) \\cdot (1+\\ln B) \\cdot A_1 \\cdot A_2$$\n代入 $B=2$、$A_1=\\ln 2$ 和 $A_2=\\ln 3$：\n$$\\ln|\\ln 2 - 2 \\ln 3| > -(1.4 \\cdot 30^5 \\cdot 2^{9/2}) \\cdot (1+\\ln 2) \\cdot (\\ln 2) \\cdot (\\ln 3)$$\n\n为了求出 $|\\Lambda|$ 的下界，我们对不等式两边取指数：\n$$|\\ln 2 - 2 \\ln 3| > \\exp\\left( -(1.4 \\cdot 30^5 \\cdot 2^{9/2}) (1+\\ln 2) (\\ln 2) (\\ln 3) \\right)$$\n\n问题要求的是具体的显式下界，即此不等式右侧的值。这就是最终的表达式。", "answer": "$$\\boxed{\\exp\\left(-1.4 \\cdot 30^5 \\cdot 2^{9/2} (1+\\ln 2) (\\ln 2)(\\ln 3)\\right)}$$", "id": "3008823"}, {"introduction": "在应用 Baker 定理之前，一个至关重要的前提是确保我们处理的对数线性型不为零。本练习 [@problem_id:3008814] 旨在阐明这一基本要求及其与乘法独立性的关系。您将学习如何严格证明一组整数的乘法独立性，并更重要的是，理解 Baker 定理的角色：它为*非零*线性型提供一个定量的正下界，而不是用来证明线性型本身是否为零。这个练习将帮助您区分代数依赖性问题（一个代数问题）和对非零值的量化估计（一个超越数论问题）。", "problem": "设 $a_1,\\dots,a_n \\in \\mathbb{Z}_{\\ge 2}$，且回顾可知，如果满足 $\\prod_{i=1}^n a_i^{b_i}=1$ 的唯一整数元组 $(b_1,\\dots,b_n)\\in\\mathbb{Z}^n$ 是 $(b_1,\\dots,b_n)=(0,\\dots,0)$，则称集合 $\\{a_1,\\dots,a_n\\}$ 是乘法独立的。一种经典方法将依赖关系式 $\\prod_{i=1}^n a_i^{b_i}=1$ 化为对数线性形式 $\\Lambda(b):=\\sum_{i=1}^n b_i \\log a_i$ 的值为零。而Baker的对数线性形式定理（一个经过充分检验的基础性结果）断言，对于非零的 $\\Lambda(b)$，存在形如 $|\\Lambda(b)| > c \\, H^{-A}$ 的显式下界，其中 $H=\\max_i |b_i|$，并且 $c,A>0$ 是仅依赖于 $a_1,\\dots,a_n$ 的有效可计算常数。\n\n考虑具体集合 $\\{6,10,15\\} \\subset \\mathbb{Z}_{\\ge 2}$。哪个选项正确地描述了一种严谨有效的方法，该方法通过首先检查 $\\prod_i a_i^{b_i}=1$ 是否存在非平凡整数解，然后应用Baker的对数线性形式定理来验证 $\\{6,10,15\\}$ 的乘法独立性？\n\nA. 对每个整数进行因数分解：$6=2\\cdot 3$, $10=2\\cdot 5$, $15=3\\cdot 5$。为 $(6,10,15)$ 的指数引入未知数 $(x,y,z)\\in\\mathbb{Z}^3$。对恒等式 $6^x 10^y 15^z=1$ 应用 p-进赋值 $v_2$, $v_3$, $v_5$，得到线性方程组 $x+y=0$, $x+z=0$, $y+z=0$，其唯一的整数解是 $(x,y,z)=(0,0,0)$；因此该集合是乘法独立的。此外，Baker 定理给出了有效可计算的常数 $c,A>0$ (仅依赖于 $6,10,15$)，使得对于任何 $(x,y,z)\\in\\mathbb{Z}^3\\setminus\\{(0,0,0)\\}$，当 $H=\\max\\{|x|,|y|,|z|\\}$ 时，有 $\\left|x\\log 6+y\\log 10+z\\log 15\\right|> c\\,H^{-A}$。因此，对 $\\Lambda(x,y,z)$ 进行任何精度小于 $\\tfrac{1}{2}c\\,H^{-A}$ 的高精度数值检验，都可以证明对于给定的 $(x,y,z)$ 不会发生偶然的近似抵消，而这与赋值检验（已经排除了非平凡解）相结合，便得出了一个严谨的验证。\n\nB. 观察到 $\\log 6/\\log 10$ 是无理数，这意味着 $\\log 6,\\log 10,\\log 15$ 在 $\\mathbb{Q}$ 上线性无关。因此，无需任何进一步的工作，该集合就是乘法独立的。\n\nC. 计算一个 $3\\times 3$ 矩阵，其第一行为 $(\\log 6,\\log 10,\\log 15)$，其余行为 $(1,1,1)$ 和 $(0,0,0)$，并数值检验其行列式非零。这种数值上的非零性足以证明乘法独立性，使得任何对Baker定理的引用都变得不必要。\n\nD. 整数 $a_1,\\dots,a_n\\ge 2$ 乘法独立的一个充分必要条件是它们两两互质。由于 $6,10,15$ 不是两两互质的，所以它们是乘法相关的。\n\nE. Baker 定理指出，任何非平凡的线性形式 $\\sum_i b_i \\log a_i$ 都严格远离于 $0$，因此永远不可能存在精确的关系式 $\\prod_i a_i^{b_i}=1$（其中 $b_i$ 是整数），除非所有的 $b_i=0$。因此，可以跳过检查整数解的步骤，仅凭 Baker 定理直接得出乘法独立的结论。", "solution": "用户需要对问题陈述进行批判性验证，然后是详细的解决方案和对所有选项的评估。\n\n### 问题验证\n\n**第一步：提取已知条件**\n\n*   $a_1, \\dots, a_n \\in \\mathbb{Z}_{\\ge 2}$ 是整数。\n*   如果满足方程 $\\prod_{i=1}^n a_i^{b_i} = 1$ 的唯一整数解 $(b_1, \\dots, b_n) \\in \\mathbb{Z}^n$ 是平凡解 $(b_1, \\dots, b_n) = (0, \\dots, 0)$，则集合 $\\{a_1, \\dots, a_n\\}$ 被定义为乘法独立的。\n*   方程 $\\prod_{i=1}^n a_i^{b_i} = 1$ 等价于对数线性形式 $\\Lambda(b) := \\sum_{i=1}^n b_i \\log a_i = 0$ 为零。\n*   Baker 定理为非零的对数线性形式提供了一个下界：对于 $\\Lambda(b) \\neq 0$，存在有效可计算的常数 $c, A > 0$（取决于 $a_1, \\dots, a_n$），使得 $|\\Lambda(b)| > c \\, H^{-A}$，其中 $H = \\max_i |b_i|$。\n*   所考虑的具体集合是 $\\{6, 10, 15\\}$。\n*   问题要求找出正确描述了验证 $\\{6, 10, 15\\}$ 乘法独立性的严谨有效方法的选项。该方法被指定包含两个部分：首先，检查定义方程是否存在非平凡整数解；其次，应用 Baker 定理。\n\n**第二步：使用提取的已知条件进行验证**\n\n*   **科学依据：** 问题陈述牢牢植根于数论。乘法独立的定义和 Baker 定理的定性陈述都是标准且正确的。\n*   **良态问题：** 问题定义明确。它要求评估几种用于验证给定数集的特定数学性质的提议方法。可以通过严谨的数学分析确定正确答案。\n*   **客观性：** 语言正式、精确且客观。\n\n问题陈述没有科学或事实上的不健全之处，并非不完整或矛盾，不是病态问题，并且与所述主题直接相关。这是一个有效的数论问题。\n\n**第三步：结论与行动**\n\n问题是有效的。我现在将继续进行解答。\n\n### 解答推导\n\n首要任务是确定整数集合 $\\{6, 10, 15\\}$ 是否是乘法独立的。根据定义，这需要检查方程\n$$\n6^x 10^y 15^z = 1\n$$\n的唯一整数解 $(x, y, z) \\in \\mathbb{Z}^3$ 是否为平凡解 $(x, y, z) = (0, 0, 0)$。\n\n一种标准且有效的方法是使用素因数分解。涉及的素因数是 $2$、$3$ 和 $5$。我们可以用这些素数表示基数：\n*   $6 = 2^1 \\cdot 3^1 \\cdot 5^0$\n*   $10 = 2^1 \\cdot 3^0 \\cdot 5^1$\n*   $15 = 2^0 \\cdot 3^1 \\cdot 5^1$\n\n将这些代入方程：\n$$\n(2^1 \\cdot 3^1)^x (2^1 \\cdot 5^1)^y (3^1 \\cdot 5^1)^z = 1\n$$\n使用指数定律，我们汇集每个素数的幂：\n$$\n2^{x+y} \\cdot 3^{x+z} \\cdot 5^{y+z} = 2^0 \\cdot 3^0 \\cdot 5^0\n$$\n根据算术基本定理（素因数分解的唯一性），每个对应素数底数的指数必须相等。这为整数未知数 $x, y, z$ 产生了一个齐次线性方程组：\n1.  $x + y = 0$\n2.  $x + z = 0$\n3.  $y + z = 0$\n\n我们可以解这个方程组。由方程(1)，$y = -x$。由方程(2)，$z = -x$。将这些代入方程(3)得到：\n$$\n(-x) + (-x) = 0 \\implies -2x = 0 \\implies x = 0\n$$\n由于 $x=0$，可得 $y = -0 = 0$ 且 $z = -0 = 0$。唯一的整数解是 $(x, y, z) = (0, 0, 0)$。\n因此，集合 $\\{6, 10, 15\\}$ 是乘法独立的。\n\n这个分析对应于问题所要求方法的第一部分。第二部分涉及应用 Baker 定理。以上分析证明了线性形式 $\\Lambda(x, y, z) = x \\log 6 + y \\log 10 + z \\log 15$ 等于零当且仅当 $(x, y, z) = (0, 0, 0)$。对于任何非零整数三元组 $(x, y, z)$，该线性形式非零。然后，Baker 定理对这些非零值提供了一个定量陈述：存在有效可计算的常数 $c > 0$ 和 $A > 0$，使得对于任何 $(x, y, z) \\in \\mathbb{Z}^3 \\setminus \\{(0, 0, 0)\\}$，\n$$\n|x \\log 6 + y \\log 10 + z \\log 15| > c \\cdot (\\max\\{|x|, |y|, |z|\\})^{-A}\n$$\n该定理提供了一个“排斥”性质，保证这些对数的任何非平凡整数组合都不能任意接近于零。这对于（除其他事项外）建立数值检验的严谨性至关重要。\n\n有了这个基础，我们就可以评估所提供的选项了。\n\n### 逐项分析选项\n\n**A. 对每个整数进行因数分解：$6=2\\cdot 3$, $10=2\\cdot 5$, $15=3\\cdot 5$。为 $(6,10,15)$ 的指数引入未知数 $(x,y,z)\\in\\mathbb{Z}^3$。对恒等式 $6^x 10^y 15^z=1$ 应用 p-进赋值 $v_2$, $v_3$, $v_5$，得到线性方程组 $x+y=0$, $x+z=0$, $y+z=0$，其唯一的整数解是 $(x,y,z)=(0,0,0)$；因此该集合是乘法独立的。此外，Baker 定理给出了有效可计算的常数 $c,A>0$ (仅依赖于 $6,10,15$)，使得对于任何 $(x,y,z)\\in\\mathbb{Z}^3\\setminus\\{(0,0,0)\\}$，当 $H=\\max\\{|x|,|y|,|z|\\}$ 时，有 $\\left|x\\log 6+y\\log 10+z\\log 15\\right|> c\\,H^{-A}$。因此，对 $\\Lambda(x,y,z)$ 进行任何精度小于 $\\tfrac{1}{2}c\\,H^{-A}$ 的高精度数值检验，都可以证明对于给定的 $(x,y,z)$ 不会发生偶然的近似抵消，而这与赋值检验（已经排除了非平凡解）相结合，便得出了一个严谨的验证。**\n\n该选项准确地描述了这个两步过程。第一部分，使用p-进赋值（这是对素因数分解中指数计数的正式表述），正确地推导出了线性方程组及其唯一的平凡解，从而证明了乘法独立性。第二部分正确地陈述了 Baker 定理对该集合的推论，并正确地解释了它通过建立一个与零的最小距离，为数值计算提供严谨证明的用途。整个描述在数学上是合理的，并遵循了问题所要求的结构。\n**结论：正确。**\n\n**B. 观察到 $\\log 6/\\log 10$ 是无理数，这意味着 $\\log 6,\\log 10,\\log 15$ 在 $\\mathbb{Q}$ 上线性无关。因此，无需任何进一步的工作，该集合就是乘法独立的。**\n\n此选项包含一个严重的逻辑缺陷。$\\log 6 / \\log 10$ 的无理性确立了 $\\{6, 10\\}$ 的乘法独立性，这等价于 $\\{\\log 6, \\log 10\\}$ 在 $\\mathbb{Q}$ 上的线性无关。然而，一个子集的线性无关并不意味着整个集合的线性无关。举一个反例，集合 $\\{\\log 2, \\log 3\\}$ 在 $\\mathbb{Q}$ 上是线性无关的，但集合 $\\{\\log 2, \\log 3, \\log 6\\}$ 不是，因为 $\\log 6 - \\log 2 - \\log 3 = 0$。所提出的推理是无效的。\n**结论：不正确。**\n\n**C. 计算一个 $3\\times 3$ 矩阵，其第一行为 $(\\log 6,\\log 10,\\log 15)$，其余行为 $(1,1,1)$ 和 $(0,0,0)$，并数值检验其行列式非零。这种数值上的非零性足以证明乘法独立性，使得任何对Baker定理的引用都变得不必要。**\n\n这个选项是无稽之谈。任何含有一个全零行的矩阵，其行列式都为零。因此，所提议的矩阵的行列式总是 $0$，无论其他项是什么。此外，对于非零性的“数值检验”通常不是一个严谨的证明，因为一个真正的零值可能会由于精度误差被计算为一个小的非零浮点数。声称这已足够且使 Baker 定理变得不必要的说法是错误的。\n**结论：不正确。**\n\n**D. 整数 $a_1,\\dots,a_n\\ge 2$ 乘法独立的一个充分必要条件是它们两两互质。由于 $6,10,15$ 不是两两互质的，所以它们是乘法相关的。**\n\n这个陈述在数学上是错误的。两两互质是乘法独立性的一个*充分*条件，但不是*必要*条件。如上所证，集合 $\\{6, 10, 15\\}$ 是乘法独立的，但其成员并非两两互质（例如，$\\gcd(6, 10) = 2 \\neq 1$）。从这个错误前提得出的结论也是不正确的。\n**结论：不正确。**\n\n**E. Baker 定理指出，任何非平凡的线性形式 $\\sum_i b_i \\log a_i$ 都严格远离于 $0$，因此永远不可能存在精确的关系式 $\\prod_i a_i^{b_i}=1$（其中 $b_i$ 是整数），除非所有的 $b_i=0$。因此，可以跳过检查整数解的步骤，仅凭 Baker 定理直接得出乘法独立的结论。**\n\n这个选项误解了 Baker 定理的逻辑结构。该定理的前提是对数线性形式是*非零*的。它陈述的是：如果 $\\sum_i b_i \\log a_i \\neq 0$，那么 $|\\sum_i b_i \\log a_i| > \\text{界限}$。它本身并不能证明对于非平凡的整数系数 $b_i$，该形式是非零的。这是一个独立的问题——正是乘法独立性本身的问题。你不能用一个假设为 `P` 的定理来证明 `P`。检查整数解（如选项A所示）恰恰是确定该线性形式对于非平凡系数是非零所必需的步骤。\n**结论：不正确。**", "answer": "$$\\boxed{A}$$", "id": "3008814"}, {"introduction": "我们学习理论的最终目的之一是解决实际问题。本练习展示了 Baker 理论在解决指数丢番图方程这一经典问题上的强大威力 [@problem_id:3008764]。您将实现一个综合策略，它将来自对数线性型理论的抽象下界与诸如模运算排除和目标枚举等计算技巧相结合。通过这个实践，您将体会到如何将一个理论上极小的下界（一个超越数论结果）转化为一个有限且可操作的整数解搜索范围，这是将抽象理论应用于具体问题求解的典范。", "problem": "设 $a$、$b$ 和 $c$ 为固定整数，其中 $a \\geq 2$，$b \\geq 2$，且 $c \\in \\mathbb{Z}$。考虑指数丢番图方程\n$$\na^{x} - b^{y} = c\n$$\n其中整数 $x \\geq 1$ 且 $y \\geq 1$。目标是实现一个实用策略，该策略利用对数线性型的有效下界、模约束和目标枚举来排除或确认小指数解的存在性。该策略必须从以下基本且经过充分检验的事实出发：\n\n- 定义对数线性型\n$$\n\\Lambda(x,y) = x \\log a - y \\log b,\n$$\n其中 $\\log$ 表示自然对数（以 e 为底）。若 $a$ 和 $b$ 是乘法独立的（即不存在非零整数 $u$ 和 $v$ 使得 $a^{u} = b^{v}$），则对于所有整数对 $(x,y)$，$\\Lambda(x,y) \\neq 0$，除非 $a^{x} = b^{y}$。\n- 从方程 $a^{x} - b^{y} = c$ 出发，重排得到 $a^{x} / b^{y} = 1 + c / b^{y}$，因此\n$$\n\\Lambda(x,y) = \\log\\!\\left(1 + \\frac{c}{b^{y}}\\right).\n$$\n- 对于满足 $|t| \\leq \\tfrac{1}{2}$ 的实数 $t$，不等式\n$$\n\\left|\\log(1+t)\\right| \\leq 2|t|\n$$\n是成立的，并为右侧提供了一个经过充分检验的上界。\n- 假设已经根据对数线性型理论（例如，通过 Alan Baker 的工作或 Kurt Mahler 和 Kalin Georgiev Matveev 提出的更强界）计算出了给定对 $(a,b)$ 的一个显式下界。具体来说，假设给定正参数 $U$ 和 $K$，使得对于所有满足 $1 \\leq x,y \\leq U$ 和 $\\Lambda(x,y) \\neq 0$ 的整数 $x, y$，有\n$$\n|\\Lambda(x,y)| \\geq U^{-K}.\n$$\n这被视为算法的一个输入，并被当作一个显式可用的界。\n- 结合前两点，当 $\\left|\\frac{c}{b^{y}}\\right| \\leq \\tfrac{1}{2}$（等价于 $b^{y} \\geq 2|c|$）时，任何解都必须满足\n$$\nU^{-K} \\leq |\\Lambda(x,y)| = \\left|\\log\\!\\left(1 + \\frac{c}{b^{y}}\\right)\\right| \\leq \\frac{2|c|}{b^{y}},\n$$\n因此\n$$\nb^{y} \\leq \\frac{2|c|}{U^{-K}} = 2|c|\\,U^{K}.\n$$\n这就得到了一个可计算的 $y$ 的上界，即\n$$\ny \\leq \\left\\lfloor \\log_{b}\\!\\big(2|c|\\,U^{K}\\big) \\right\\rfloor,\n$$\n只要 $b^{y} \\geq 2|c|$。对于剩下有限个 $b^{y} < 2|c|$ 的情况，直接枚举即可。\n\n除了下界论证，模约束通常可以裁剪搜索空间。对于固定的模 $m \\in \\mathbb{Z}_{\\geq 2}$，同余式\n$$\na^{x} \\equiv b^{y} + c \\pmod{m}\n$$\n必须对任何解都成立。对于每个固定的 $y$，可以计算其模余 $r_{m}(y) \\equiv b^{y} + c \\pmod{m}$，然后检查当 $x$ 遍历正整数时，$r_{m}(y)$ 是否在 $a^{x} \\pmod{m}$ 可达的 $\\mathbb{Z}/m\\mathbb{Z}$ 子集中。如果存在一个模 $m$ 使得 $r_{m}(y)$ 不可达，那么该 $y$ 值就可以被完全排除。\n\n您的任务是实现以下算法：\n\n1. 对于每个测试用例 $(a,b,c)$，您还会被给予枚举界 $B_{\\mathrm{enum}}$ 和如上所述的显式下界参数 $(U,K)$。计算 $L = U^{-K}$。\n2. 计算阈值\n$$\ny_{\\tfrac{1}{2}} = \\left\\lceil \\log_{b}\\!\\big(2|c|\\big) \\right\\rceil,\n$$\n此阈值保证对于所有 $y \\geq y_{\\tfrac{1}{2}}$，$\\left|\\frac{c}{b^{y}}\\right| \\leq \\tfrac{1}{2}$ 成立。\n3. 使用下界推导出\n$$\ny \\leq Y_{\\mathrm{Baker}} := \\left\\lfloor \\log_{b}\\!\\big(2|c|/L\\big) \\right\\rfloor = \\left\\lfloor \\log_{b}\\!\\big(2|c|\\,U^{K}\\big) \\right\\rfloor.\n$$\n4. 将要枚举的最大 $y$ 值设为\n$$\ny_{\\max} = \\min\\!\\big(B_{\\mathrm{enum}},\\,\\max(1,\\,\\max(Y_{\\mathrm{Baker}},\\,y_{\\tfrac{1}{2}}-1))\\big).\n$$\n5. 对于 $1 \\leq y \\leq y_{\\max}$ 中的每个 $y$，使用一组小模（例如 $m \\in \\{4,5,7,8,9,11,13\\}$）进行模裁剪。如果任何模排除了 $y$，则跳过该 $y$。否则，执行 $x$ 的目标枚举：\n   - 如果 $y < y_{\\tfrac{1}{2}}$，枚举所有 $1 \\leq x \\leq B_{\\mathrm{enum}}$ 的 $x$。\n   - 如果 $y \\geq y_{\\tfrac{1}{2}}$，使用不等式\n     $$\n     \\big|x - y \\tfrac{\\log b}{\\log a}\\big| \\leq \\frac{2|c|}{b^{y}\\log a}\n     $$\n     将 $x$ 限制在 $y \\frac{\\log b}{\\log a}$ 周围的一个窄区间内，并且只在该区间的一个小的安全边际内枚举整数 $x$（您可以将区间扩展一个小的固定整数边际以考虑粗略常数）。\n   - 对于窄化区间中的每个候选 $x$，使用精确整数算术检查 $a^{x} - b^{y} = c$ 是否成立。\n6. 如果任何 $(x,y)$ 对满足该方程，则小指数解未被排除；为该测试用例返回布尔值 $\\mathrm{False}$。否则，返回 $\\mathrm{True}$，表示在给定的显式界和模约束下，规定范围内的小指数解已被排除。\n\n测试套件和要求的最终输出：\n\n使用以下六个测试用例，每个用例以 $(a,b,c,B_{\\mathrm{enum}},U,K)$ 形式给出，其中 $\\log$ 为自然对数：\n\n- 案例 1：$(2,3,5,50,1000,6)$。\n- 案例 2：$(3,2,7,50,1000,6)$。\n- 案例 3：$(5,3,2,30,1000,6)$。\n- 案例 4：$(7,2,3,40,1000,6)$。\n- 案例 5：$(2,3,-1,50,1000,6)$。\n- 案例 6：$(2,3,4,50,1000,6)$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如 $[r_{1},r_{2},\\dots,r_{6}]$），其中每个 $r_{i}$ 是一个布尔值，指示所述策略是否已排除该案例的小指数解。不涉及物理单位或角度单位；所有对数均为自然对数，并且输出必须严格遵循指定的列表格式。", "solution": "该问题提供了一个详细的算法，用于寻找或排除指数丢番图方程 $a^x - b^y = c$ 的小指数整数解 $(x,y)$。该方法将源自贝克对数线性型理论的理论界与实用的计算搜索技术（即模运算和目标枚举）相结合。\n\n### 问题验证\n\n首先，对问题陈述进行严格验证。\n\n1.  **已知条件提取**：\n    -   方程为 $a^x - b^y = c$，其中整数 $x \\geq 1$, $y \\geq 1$。\n    -   常数为整数 $a \\geq 2$, $b \\geq 2$，且 $c \\in \\mathbb{Z}$。\n    -   算法由一系列计算步骤定义，涉及：\n        -   枚举界 $B_{\\mathrm{enum}}$。\n        -   用于对数线性型 $\\Lambda(x,y) = x \\log a - y \\log b$ 的显式下界 $|\\Lambda(x,y)| \\geq U^{-K}$ 的参数 $U, K$。\n        -   阈值 $y_{\\tfrac{1}{2}} = \\lceil \\log_{b}(2|c|) \\rceil$。\n        -   上界 $Y_{\\mathrm{Baker}} = \\lfloor \\log_{b}(2|c|\\,U^{K}) \\rfloor$。\n        -   搜索限制 $y_{\\max} = \\min(B_{\\mathrm{enum}}, \\max(1, \\max(Y_{\\mathrm{Baker}}, y_{\\tfrac{1}{2}}-1)))$。\n        -   使用模 $m \\in \\{4,5,7,8,9,11,13\\}$ 进行模裁剪。\n        -   对 $x$ 进行目标枚举，对于 $y \\ge y_{\\tfrac{1}{2}}$ 的搜索区间由 $|x - y\\frac{\\log b}{\\log a}| \\le \\frac{2|c|}{b^y \\log a}$ 给出。\n    -   测试套件包含六个元组 $(a,b,c,B_{\\mathrm{enum}},U,K)$。\n\n2.  **验证检查**：\n    -   **科学基础**：该问题在数论中有扎实的基础。使用对数线性型是解决丢番图方程的一种标准而强大的技术。所呈现的不等式是该理论在数学上的正确推论。\n    -   **适定性**：该问题指定了一个确定性算法，具有清晰的输入和唯一定义的输出格式。计算步骤明确无误，对每个测试用例都能得出单一、可验证的结果。\n    -   **客观性**：问题以精确、客观的数学语言陈述，不含任何主观性。\n    -   **完整性与一致性**：所有必需的常数、公式和测试用例均已提供。理论基础与算法步骤一致。“小安全边际”的微小模糊性是一个实现中的实践细节，可通过选择一个合理的固定整数（如 $2$）来解决。$c \\neq 0$ 的假设在涉及 $\\log|c|$ 的公式中是隐含的，并且对所有测试用例都成立。$(a,b)$ 对的乘法独立性对所有测试用例也均满足，确保了 $\\Lambda(x,y) \\neq 0$。\n\n3.  **结论**：该问题被认为是有效的，因为它科学上合理、适定、客观且自洽。\n\n### 解法推导\n\n解法涉及按描述实现算法。设计一个函数来处理每个测试用例，如果在指定的搜索空间内未找到解（即解被排除），则返回 `True`，如果找到解，则返回 `False`。\n\n对于给定的测试用例 $(a,b,c,B_{\\mathrm{enum}},U,K)$，主要步骤如下：\n\n1.  **初始化与预计算**：\n    -   用于裁剪的模集为 $M = \\{4,5,7,8,9,11,13\\}$。\n    -   为高效地应用模约束，对于每个模 $m \\in M$，我们预先计算模余集 $R_m = \\{a^x \\pmod m \\mid x \\ge 1\\}$。由于幂序列是周期的，该集合是有限的。\n\n2.  **计算 $y$ 的搜索界**：\n    -   计算阈值 $y_{\\tfrac{1}{2}}$。对于 $y \\ge y_{\\tfrac{1}{2}}$，不等式 $|\\log(1 + c/b^y)| \\le 2|c|/b^y$ 成立。\n        $y_{\\tfrac{1}{2}} = \\max(1, \\lceil \\log_b(2|c|) \\rceil)$。\n    -   计算来自贝克方法的 $y$ 的理论上界：\n        $Y_{\\mathrm{Baker}} = \\lfloor \\log_b(2|c|\\,U^K) \\rfloor = \\lfloor \\frac{\\log(2|c|) + K\\log U}{\\log b} \\rfloor$。\n    -   通过将这些与给定的枚举界 $B_{\\mathrm{enum}}$ 结合，确定 $y$ 的最终有效搜索限制：\n        $y_{\\max} = \\min(B_{\\mathrm{enum}}, \\max(1, Y_{\\mathrm{Baker}}, y_{\\tfrac{1}{2}}-1))$。\n\n3.  **迭代搜索**：算法从 $1$ 到 $y_{\\max}$ 迭代每个整数 $y$。对于每个 $y$：\n\n    -   **模裁剪**：使用每个模 $m \\in M$ 来测试解存在的可能性。对于给定的 $y$，我们计算同余式 $a^x \\equiv b^y+c \\pmod m$ 的右侧。如果该值 $(b^y+c) \\pmod m$ 不在预先计算的模余集 $R_m$ 中，则没有整数 $x \\ge 1$ 能满足该同余式。因此，该 $y$ 值被排除，算法继续处理下一个 $y$。\n\n    -   **$x$ 的目标枚举**：如果 $y$ 通过了模裁剪，则进行对 $x$ 的搜索。\n        -   如果 $y < y_{\\tfrac{1}{2}}$，线性型近似不保证有效。对 $x$ 进行从 $1$ 到 $B_{\\mathrm{enum}}$ 的直接搜索。\n        -   如果 $y \\ge y_{\\tfrac{1}{2}}$，我们使用不等式 $|x \\log a - y \\log b| \\le \\frac{2|c|}{b^y}$，这意味着 $|x - y\\frac{\\log b}{\\log a}| \\le \\frac{2|c|}{b^y\\log a}$。这将 $x$ 限制在实数 $y \\frac{\\log b}{\\log a}$ 周围的一个非常小的区间内。我们在此区间内枚举整数 $x$，并扩展一个小的安全边际（例如，每边扩展 $2$）以考虑近似误差。\n\n    -   **解的检验**：对于每个生成的候选对 $(x,y)$，使用精确整数算术来检验方程 $a^x - b^y = c$ 是否成立。Python 的任意精度整数对此非常适用，因为幂可能会变得非常大。如果找到解，函数立即返回 `False`。\n\n4.  **最终结果**：如果遍历从 $1$ 到 $y_{\\max}$ 的所有 $y$ 的整个循环完成而没有找到任何解，则函数返回 `True`，表示在给定约束下，小指数解已被排除。\n\n例如，对于案例 6，$2^x - 3^y = 4$，算法将迅速确定不存在解。使用模 $m=4$ 的模约束为 $2^x - (-1)^y \\equiv 0 \\pmod 4$。如果 $x=1$，则为 $2 - (-1)^y \\not\\equiv 0$。如果 $x \\ge 2$，则为 $0 - (-1)^y \\not\\equiv 0$。由于对于任何 $x, y \\ge 1$ 的组合都不成立，模检验将排除所有 $y$ 值，算法将正确返回 `True`。对于其他案例，将会找到小解，从而导致输出 `False`。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Solves the exponential Diophantine equation a^x - b^y = c for small integer solutions\n    using the specified algorithm.\n    \"\"\"\n\n    test_cases = [\n        # (a, b, c, B_enum, U, K)\n        (2, 3, 5, 50, 1000, 6),\n        (3, 2, 7, 50, 1000, 6),\n        (5, 3, 2, 30, 1000, 6),\n        (7, 2, 3, 40, 1000, 6),\n        (2, 3, -1, 50, 1000, 6),\n        (2, 3, 4, 50, 1000, 6),\n    ]\n\n    MODULI = [4, 5, 7, 8, 9, 11, 13]\n    SAFETY_MARGIN = 2\n\n    def get_residues(base, mod):\n        \"\"\"Computes the set of residues {base^x mod mod} for x >= 1.\"\"\"\n        if mod == 1:\n            return {0}\n        residues = set()\n        val = base % mod\n        while val not in residues:\n            residues.add(val)\n            val = (val * base) % mod\n            if val == 0 and 0 in residues: # Handle cycles that hit 0\n                break\n        return residues\n\n    def check_case(a, b, c, B_enum, U, K):\n        \"\"\"\n        Implements the specified algorithm for a single test case.\n        Returns True if solutions are ruled out, False if a solution is found.\n        \"\"\"\n        # Pre-compute modular residues for a^x for each modulus\n        ax_residues = {m: get_residues(a, m) for m in MODULI}\n\n        # The problem formulation implies c != 0, which is true for all test cases.\n        # If c were 0, log(2*abs(c)) would be undefined.\n        \n        # Calculate bounds on y\n        log_b = np.log(b)\n        \n        # y_1/2: threshold for the validity of the log inequality\n        # This is ceil(log_b(2*|c|))\n        if 2 * abs(c) = 1:\n            y_one_half = 1\n        else:\n            y_one_half = math.ceil(np.log(2 * abs(c)) / log_b)\n        y_one_half = max(1, y_one_half)\n        \n        # Y_Baker: upper bound on y from Baker's theory\n        # This is floor(log_b(2*|c|*U^K))\n        log_U = np.log(U)\n        y_baker = math.floor((np.log(2 * abs(c)) + K * log_U) / log_b)\n        \n        # y_max: final enumeration bound for y\n        y_max = min(B_enum, max(1, y_baker, y_one_half - 1))\n\n        # Main search loop over y\n        for y in range(1, y_max + 1):\n            # 1. Modular Pruning\n            is_ruled_out = False\n            for m in MODULI:\n                rhs_mod = (pow(b, y, m) + c) % m\n                if rhs_mod not in ax_residues[m]:\n                    is_ruled_out = True\n                    break\n            if is_ruled_out:\n                continue\n            \n            # 2. Targeted Enumeration of x\n            if y  y_one_half:\n                # For small y, enumerate x up to B_enum\n                for x in range(1, B_enum + 1):\n                    if pow(a, x) - pow(b, y) == c:\n                        return False\n            else: # y >= y_one_half\n                # For large y, use inequality to narrow down search for x\n                log_a = np.log(a)\n                x_center = y * log_b / log_a\n                x_delta = (2 * abs(c)) / (pow(b, y) * log_a)\n                \n                x_min = max(1, math.floor(x_center - x_delta) - SAFETY_MARGIN)\n                x_max = math.ceil(x_center + x_delta) + SAFETY_MARGIN\n                \n                for x in range(x_min, x_max + 1):\n                    if pow(a, x) - pow(b, y) == c:\n                        return False\n                        \n        return True\n\n    results = []\n    for case in test_cases:\n        result = check_case(*case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(lambda b: str(b), results))}]\")\n\nsolve()\n```", "id": "3008764"}]}