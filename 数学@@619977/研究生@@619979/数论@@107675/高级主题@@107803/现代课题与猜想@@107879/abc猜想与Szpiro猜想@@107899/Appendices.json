{"hands_on_practices": [{"introduction": "理解像abc猜想这样的抽象概念，最好的方法就是从具体的计算开始。这个练习将引导你运用根数 ($\\operatorname{rad}$) 和品质 ($q$) 的定义，对一个非常基础的三元组 $(a,b,c)=(2,3,5)$ 进行计算。通过处理这个例子，你将为abc猜想中何为“通常”情况建立一个直观的基准，并理解为什么品质小于1是普遍现象 [@problem_id:3024518]。", "problem": "令 $\\left(a,b,c\\right)=\\left(2,3,5\\right)$ 为满足 $a+b=c$ 的一个互质三元组。回顾以下标准定义。\n- 对于一个非零整数 $n$，其根基 $\\operatorname{rad}\\!\\left(n\\right)$ 是 $n$ 的不同素因数的乘积。\n- 对于一个满足 $a+b=c$ 的互质三元组 $\\left(a,b,c\\right)$，其品质定义为 $q\\!\\left(a,b,c\\right)=\\dfrac{\\ln c}{\\ln \\operatorname{rad}\\!\\left(abc\\right)}$，其中 $\\ln$ 表示自然对数。\n\n从这些定义、abc 猜想的通常表述（该猜想断言对于任意 $\\epsilon>0$，仅存在有限多个满足 $a+b=c$ 且 $c>\\operatorname{rad}\\!\\left(abc\\right)^{1+\\epsilon}$ 的互质三元组 $\\left(a,b,c\\right)$），以及 abc 猜想与关于 $\\mathbb{Q}$ 上椭圆曲线的 Szpiro 猜想的等价性出发，完成以下任务：\n- 计算 $\\left(a,b,c\\right)=\\left(2,3,5\\right)$ 的 $\\operatorname{rad}\\!\\left(abc\\right)$。\n- 计算品质 $q\\!\\left(a,b,c\\right)$。\n- 仅使用这些基本定义和事实，评估所计算出的品质相对于 abc 猜想及其与 Szpiro 猜想的等价性所提出的猜想界限而言是否典型，并从概念上证明你的评估。\n\n将 $q\\!\\left(a,b,c\\right)$ 的精确符号表达式作为你的最终答案。不要进行数值近似，也不要在最终答案框中包含解释性文本。", "solution": "该问题被评估为有效。所提供的数据、定义和条件是自洽的、数学上合理的，并在数论领域构成一个适定问题。前提 $(a,b,c) = (2,3,5)$ 正确地构成一个满足 $a+b=c$ 的互质三元组，因为 $2+3=5$ 且 $\\gcd(2,3)=\\gcd(2,5)=\\gcd(3,5)=1$。根基和品质的定义，以及 abc 猜想的陈述，都是标准的。\n\n解答按要求分为三部分：计算根基、计算品质以及对品质进行概念性评估。\n\n首先，我们计算根基 $\\operatorname{rad}(abc)$。\n给定的三元组是 $(a,b,c) = (2,3,5)$。其乘积为 $abc = 2 \\times 3 \\times 5 = 30$。\n一个非零整数 $n$ 的根基，记作 $\\operatorname{rad}(n)$，是整除 $n$ 的不同素数的乘积。$30$ 的素因数分解是 $2^1 \\cdot 3^1 \\cdot 5^1$。不同的素因数是 $2$、$3$ 和 $5$。\n因此，根基为：\n$$ \\operatorname{rad}(abc) = \\operatorname{rad}(30) = 2 \\times 3 \\times 5 = 30 $$\n\n其次，我们计算品质 $q(a,b,c)$。\n一个满足 $a+b=c$ 的互质三元组 $(a,b,c)$ 的品质定义为：\n$$ q(a,b,c) = \\frac{\\ln c}{\\ln \\operatorname{rad}(abc)} $$\n代入我们特定三元组的值 $c=5$ 和 $\\operatorname{rad}(abc)=30$：\n$$ q(2,3,5) = \\frac{\\ln 5}{\\ln 30} $$\n这就是品质的精确符号表达式。\n\n第三，我们评估这个计算出的品质在 abc 猜想的背景下是否典型。\nabc 猜想指出，对于任何实数 $\\epsilon > 0$，满足 $a+b=c$ 且 $c > (\\operatorname{rad}(abc))^{1+\\epsilon}$ 的互质三元组 $(a,b,c)$ 只有有限多个。\n为了从品质的角度理解这一点，我们可以变换这个不等式。对两边取自然对数（这是一个严格递增函数，会保持不等关系）：\n$$ \\ln c > \\ln\\left( (\\operatorname{rad}(abc))^{1+\\epsilon} \\right) $$\n使用对数性质 $\\ln(x^y) = y \\ln x$：\n$$ \\ln c > (1+\\epsilon) \\ln(\\operatorname{rad}(abc)) $$\n对于任何非平凡的三元组，$a,b,c$ 都是正整数，因此 $\\operatorname{rad}(abc) \\ge \\operatorname{rad}(1 \\cdot 2 \\cdot 3) = 6 > 1$，这意味着 $\\ln(\\operatorname{rad}(abc)) > 0$。因此，我们可以用 $\\ln(\\operatorname{rad}(abc))$ 来除不等式两边，而无需改变不等号的方向：\n$$ \\frac{\\ln c}{\\ln(\\operatorname{rad}(abc))} > 1+\\epsilon $$\n左边是品质 $q(a,b,c)$ 的定义。因此，abc 猜想等价于这样一个陈述：对于任何 $\\epsilon > 0$，只有有限个三元组的品质 $q(a,b,c) > 1+\\epsilon$。这意味着几乎所有的三元组都预期具有品质 $q(a,b,c) \\le 1$。品质 $q > 1$ 的三元组被认为是高品质的，并且是该猜想所关注的罕见例外。该猜想通常表述为 $\\limsup q(a,b,c) = 1$。\n\n对于我们的三元组 $(2,3,5)$，品质为 $q(2,3,5) = \\frac{\\ln 5}{\\ln 30}$。\n由于 $5 < 30$，且自然对数函数 $\\ln(x)$ 在 $x > 0$ 时是严格递增的，因此可以得出 $\\ln 5 < \\ln 30$。\n因此，品质为：\n$$ q(2,3,5) = \\frac{\\ln 5}{\\ln 30} < 1 $$\n小于 $1$ 的品质是完全普通的，不属于 abc 猜想所描述的例外三元组范畴。该猜想关注的是那些 $c$ 相对于整除 $a,b,c$ 的素数乘积“出奇地大”的三元组的稀有性。在我们的例子中，$c=5$ 远小于 $\\operatorname{rad}(abc)=30$，导致品质较低。事实上，由于 $a,b,c$ 本身就是素数，其乘积 $abc$ 是无平方因子的，这意味着 $\\operatorname{rad}(abc) = abc$。这导致品质值相对于许多其他三元组而言特别小。\n提及与 abc 猜想等价的 Szpiro 猜想提供了一个几何视角。一个高品质的 abc-三元组会产生一个 Frey 椭圆曲线，其判别式相对于其导子而言异常大。三元组 $(2,3,5)$ 将对应于一个从 Szpiro 不等式的角度看并不引人注目的椭圆曲线。\n总之，计算出的品质 $q(2,3,5)$ 小于 $1$，因此被认为是典型且非例外的。这与根据 abc 猜想，绝大多数整数三元组所预期的行为完全一致。", "answer": "$$\\boxed{\\frac{\\ln 5}{\\ln 30}}$$", "id": "3024518"}, {"introduction": "abc猜想的真正魅力在于那些罕见但极为重要的“高品质”三元组。这个练习将带你探究这些特殊三元组的来源，我们将分析著名的例子 $(1,8,9)$ [@problem_id:3024524]。你会发现，当三元组中的数字是完美幂（perfect powers）时，根数 $\\operatorname{rad}(abc)$ 会显著减小，从而可能产生大于1的品质值 $q(a,b,c)$，这正是abc猜想所要约束的非凡情况。", "problem": "考虑$abc$猜想的背景：一个$abc$三元组是由满足$a+b=c$的三个互质正整数$(a,b,c)$构成的三元组。对于一个整数$n \\geq 1$，其根基$\\operatorname{rad}(n)$定义为整除$n$的所有不同素因数的乘积。对于一个满足$\\gcd(a,b,c)=1$的$abc$三元组$(a,b,c)$，其品质定义为$q(a,b,c)=\\frac{\\ln c}{\\ln \\operatorname{rad}(abc)}$，其中$\\ln$表示自然对数。\n\n仅根据以上定义，考虑三元组$(a,b,c)=(1,8,9)$（该三元组满足$a+b=c$和$\\gcd(a,b,c)=1$），并：\n- 计算$\\operatorname{rad}(abc)$，\n- 以精确的符号形式计算$q(a,b,c)$，以及\n- 在$abc$猜想及其与Szpiro猜想的关联背景下，解释$c$是完全平方数这一事实如何影响$\\operatorname{rad}(abc)$相对于$c$的大小。\n\n将最后计算出的两个量（按$\\operatorname{rad}(abc)$、$q(a,b,c)$的顺序）表示为精确表达式。不需要四舍五入。", "solution": "该问题是有效的，因为它是自洽的，科学上基于已建立的数论，并且是良构的。所有定义和条件都是标准且一致的。\n\n该问题要求完成关于$abc$三元组$(a,b,c)=(1,8,9)$的三个任务。\n首先，我们要计算乘积$abc$的根基。\n其次，我们要计算该三元组的品质$q(a,b,c)$。\n第三，我们必须就$c$是完全平方数的影响提供一个解释。\n\n让我们按顺序处理每个任务。\n\n1.  **计算$\\operatorname{rad}(abc)$**\n\n给定的三元组是$(a,b,c) = (1,8,9)$。这些整数是正数、互质（$\\gcd(1,8,9)=1$），并且因为$1+8=9$，所以满足$a+b=c$。\n乘积$abc$是$1 \\times 8 \\times 9 = 72$。\n\n一个整数$n$的根基，记作$\\operatorname{rad}(n)$，是其不同素因数的乘积。为了求出$\\operatorname{rad}(72)$，我们首先找到$72$的素因数分解。\n$$72 = 8 \\times 9 = 2^3 \\times 3^2$$\n72的不同素因数是$2$和$3$。\n因此，根基是这些不同素数的乘积：\n$$\\operatorname{rad}(abc) = \\operatorname{rad}(72) = 2 \\times 3 = 6$$\n\n2.  **计算$q(a,b,c)$**\n\n一个$abc$三元组的品质定义为$q(a,b,c) = \\frac{\\ln c}{\\ln \\operatorname{rad}(abc)}$。\n对于我们的三元组，有$c=9$，并且从上一步可知$\\operatorname{rad}(abc)=6$。\n将这些值代入品质公式，得到：\n$$q(1,8,9) = \\frac{\\ln 9}{\\ln 6}$$\n为了使用对数性质将其表示为更详细的符号形式，我们可以写出$\\ln 9 = \\ln(3^2) = 2 \\ln 3$和$\\ln 6 = \\ln(2 \\times 3) = \\ln 2 + \\ln 3$。\n所以，品质的精确符号形式是：\n$$q(1,8,9) = \\frac{2 \\ln 3}{\\ln 2 + \\ln 3}$$\n从数值上看，这个值约等于$1.226$，大于$1$。在$abc$猜想的研究中，品质大于$1$的三元组尤其引人关注。\n\n3.  **解释$c$是完全平方数的影响**\n\n$abc$猜想断言，对于任意实数$\\varepsilon > 0$，仅存在有限多个$abc$三元组满足$c > (\\operatorname{rad}(abc))^{1+\\varepsilon}$。这等价于说，只有有限多个三元组的品质$q(a,b,c) = \\frac{\\ln c}{\\ln \\operatorname{rad}(abc)}$会超过$1+\\varepsilon$。该猜想意味着根基$\\operatorname{rad}(abc)$通常不会比$c$小很多。\n\n$\\operatorname{rad}(n)$相对于$n$的大小之所以小，恰恰是因为$n$是一个“幂数”，即其素因数分解包含素数的高次幂。$c$是完全平方数是这种情况的一个特例。\n如果一个整数$c$是完全平方数，比如$c=k^2$（其中$k>1$为整数），那么它的素因数分解由提升到偶数次幂的素数组成。根基$\\operatorname{rad}(c)$只考虑了不同的素因数，所以$\\operatorname{rad}(c) = \\operatorname{rad}(k)$。由于$\\operatorname{rad}(k) \\le k$，我们有$\\operatorname{rad}(c) \\le \\sqrt{c}$。对于我们的三元组，$c=9=3^2$，所以$\\operatorname{rad}(c)=\\operatorname{rad}(9)=3$，确实有$\\operatorname{rad}(9) = \\sqrt{9}$。\n一般而言，如果一个整数$n$是完全$m$次幂，即$n=k^m$，那么$\\operatorname{rad}(n) = \\operatorname{rad}(k) \\le k = n^{1/m}$。这表明，一个数是完全幂数会显著减小其根基相对于该数本身的大小。\n\n在一个$abc$三元组中，由于$a,b,c$两两互质，所以$\\operatorname{rad}(abc) = \\operatorname{rad}(a)\\operatorname{rad}(b)\\operatorname{rad}(c)$。当其中一个分量（如$c$）是完全幂数时，它对根基的贡献$\\operatorname{rad}(c)$相对于它对和的贡献（因为$c=a+b$）要小。这倾向于使得总根基$\\operatorname{rad}(abc)$与$c$相比显得很小。对于我们的三元组，$a=1$，$b=8=2^3$，$c=9=3^2$。$b$和$c$都是完全幂数，这使得$\\operatorname{rad}(b)=2$（远小于$8$）且$\\operatorname{rad}(c)=3$（小于$9$）。这导致总根基$\\operatorname{rad}(abc)=6$与$c=9$相比很小，从而得到一个很高的品质$q(1,8,9) > 1$。包含完全幂数的三元组是检验$abc$猜想极限的高品质例子的主要来源。\n\n与Szpiro猜想的联系源于对椭圆曲线的研究。对于任何$abc$三元组，可以构造一个相应的Frey-Hellegouarch椭圆曲线，例如$y^2 = x(x-a)(x+b)$。Szpiro猜想的一个版本通过不等式$|\\Delta| \\le C(\\varepsilon) N^{6+\\varepsilon}$（对于任意$\\varepsilon > 0$）将$\\mathbb{Q}$上椭圆曲线的最小判别式$\\Delta$和导子$N$联系起来。对于与$abc$三元组相关联的Frey曲线，导子$N$本质上是$\\operatorname{rad}(abc)$，而判别式$\\Delta$与$(abc)^2$成正比。一个其中一项是高次幂（如$c$是完全平方数）的$abc$三元组，会导出一个导子$N$相对于判别式$|\\Delta|$异常小的Frey曲线。在Szpiro猜想的背景下，这样的曲线是一个“极端”案例，正如相应的$abc$三元组对于$abc$猜想是一个“极端”案例一样。事实上，已知这两个猜想是等价的。", "answer": "$$\\boxed{\\begin{pmatrix} 6 & \\frac{2 \\ln 3}{\\ln 2 + \\ln 3} \\end{pmatrix}}$$", "id": "3024524"}, {"introduction": "虽然分析单个给定的三元组富有启发性，但真正深入地理解abc猜想，则需要我们具备系统性搜寻这些例子的能力。这个实践将理论与计算探索相结合，要求你设计一个算法来枚举abc-三元组，并找出在给定范围内品质最高的三元组 [@problem_id:3024529]。这项任务不仅能巩固你对核心概念的理解，还能让你体验到计算方法在现代数论研究中的强大作用。", "problem": "给定满足 $a+b=c$ 和 $\\gcd(a,b)=1$ 的正整数 $a$、$b$ 和 $c$，三元组 $(a,b,c)$ 被称为一个 $abc$ 三元组。对于一个正整数 $n$，定义其根基 $\\operatorname{rad}(n)$ 为 $n$ 的不同素因数的乘积。与三元组 $(a,b,c)$ 相关的 $abc$ 品质是一个对数量\n$$\nq_{\\log}(a,b,c) = \\frac{\\log c}{\\log \\operatorname{rad}(abc)},\n$$\n其中 $\\log$ 表示自然对数。一个相关的尺度敏感指标是比率\n$$\nq_{\\mathrm{ratio}}(a,b,c) = \\frac{c}{\\operatorname{rad}(abc)}.\n$$\n其数论背景是，$abc$ 猜想预测对于任意 $\\varepsilon>0$，仅存在有限多个三元组满足 $c > \\operatorname{rad}(abc)^{1+\\varepsilon}$，并且观测到较大的 $q_{\\log}$ 和 $q_{\\mathrm{ratio}}$ 值是罕见且具有内在意义的。该猜想与椭圆曲线的 Szpiro 猜想有深刻联系，对 $abc$ 三元组的计算探索被用于寻找挑战猜想边界的例子。\n\n您的任务是设计一个完整的算法并加以实现，以对于给定的界限 $B$，枚举所有满足 $a+b=c$、$1 \\le a \\le b$ 且 $3 \\le c \\le B$ 的互质三元组 $(a,b,c)$，计算 $\\operatorname{rad}(abc)$、$q_{\\log}(a,b,c)$ 和 $q_{\\mathrm{ratio}}(a,b,c)$，并对每个 $B$ 跟踪具有最大 $q_{\\log}$ 的三元组。您必须：\n- 从 $\\gcd$、素数和 $\\operatorname{rad}(n)$ 的基本定义出发。\n- 使用基于成熟算法（如埃拉托斯特尼筛法和最小素因子数组）的素因数分解策略，为所有 $n \\le B$ 高效地计算 $\\operatorname{rad}(n)$。\n- 将每个 $n$ 的素因数表示为适当的数据结构（例如，素数集合），以便通过取 $a$、$b$ 和 $c$ 的素因数的并集并将并集中的素数相乘来获得 $\\operatorname{rad}(abc)$。\n- 维护一个数据结构，以跟踪至今观测到的最大 $q_{\\log}$ 值及其对应的三元组 $(a,b,c)$，以及 $\\operatorname{rad}(abc)$ 和 $q_{\\mathrm{ratio}}(a,b,c)$。\n\n您必须将该算法实现为一个完整的、可运行的程序，该程序：\n- 使用从埃拉托斯特尼筛法派生的最小素因子数组，为整个测试套件中所有 $n \\le \\max \\{B\\}$ 预计算素因数。\n- 枚举所有满足 $a+b=c$、$1 \\le a \\le b$、$3 \\le c \\le B$ 和 $\\gcd(a,b)=1$ 的三元组 $(a,b,c)$。\n- 通过取 $a$、$b$ 和 $c$ 的素因数的并集并将并集中的不同素数相乘来计算 $\\operatorname{rad}(abc)$。\n- 计算每个三元组的 $q_{\\log}(a,b,c)$ 和 $q_{\\mathrm{ratio}}(a,b,c)$，并跟踪具有最大 $q_{\\log}$ 的三元组。\n\n测试套件：\n- 使用界限 $B \\in \\{3, 50, 200, 500, 2000\\}$。\n- $B=3$ 的情况作为边界条件，此时只可能出现最小的非平凡三元组。\n- 更大的界限用于在更宽的搜索空间中测试数据结构和枚举算法的效率与正确性。\n\n最终输出格式：\n- 您的程序应生成一行输出，其中包含一个由方括号括起来的逗号分隔列表形式的结果。\n- 每个测试用例的结果必须是 $[B, q_{\\log}^{\\ast}, a^{\\ast}, b^{\\ast}, c^{\\ast}, \\operatorname{rad}(a^{\\ast}b^{\\ast}c^{\\ast}), q_{\\mathrm{ratio}}^{\\ast}]$ 形式的列表，其中上标 $\\ast$ 表示在给定界限 $B$ 下使 $q_{\\log}$ 最大化的项。\n- 将 $q_{\\log}^{\\ast}$ 和 $q_{\\mathrm{ratio}}^{\\ast}$ 表示为四舍五入到十位小数的十进制浮点数。\n- 因此，单行输出应如下所示：$[[B_1,q_{\\log,1},a_1,b_1,c_1,\\operatorname{rad}_1,q_{\\mathrm{ratio},1}],[B_2,q_{\\log,2},a_2,b_2,c_2,\\operatorname{rad}_2,q_{\\mathrm{ratio},2}],\\dots]$，不含其他文本。\n\n科学真实性与推导要求：\n- 从素数的定义、用于生成素数和最小素因子的埃拉托斯特尼筛法，以及 $\\operatorname{rad}(n)$ 的定义开始推导您的算法。\n- 不要引入简便公式；请论证素因数集合的并集如何得出 $\\operatorname{rad}(abc)$，以及为什么 $\\gcd(a,b)=1$ 是 $abc$ 三元组的充分互质条件。\n- 清晰地解释数据结构如何确保枚举和最大值跟踪的正确性与效率，并提供一个基于 $B$ 的简要复杂度分析。", "solution": "所提出的问题是一项数论领域的计算任务，专注于探索 $abc$ 三元组，这是 $abc$ 猜想的核心。目标是对于 $c$ 的不同上界 $B$，找到使品质指标 $q_{\\log}(a,b,c)$ 最大化的 $abc$ 三元组 $(a,b,c)$。\n\n解决方案分为两个主要阶段：一个预计算阶段，用于高效地确定直至最大搜索界限的任何整数的根基；以及一个枚举阶段，用于系统地搜索和评估所有有效的 $abc$ 三元组。\n\n### 第一部分：理论基础与定义\n\n一个 $abc$ 三元组是一组满足以下两个条件的三个正整数 $(a, b, c)$：\n1.  $a + b = c$\n2.  $\\gcd(a,b) = 1$ (它们互质)\n\n一个正整数 $n$ 的根基，记作 $\\operatorname{rad}(n)$，被定义为其不同素因数的乘积。\n$$\n\\operatorname{rad}(n) = \\prod_{p | n, p \\text{ is prime}} p\n$$\n\n一个 $abc$ 三元组的品质通过两个指标进行评估：\n$$\nq_{\\log}(a,b,c) = \\frac{\\log c}{\\log \\operatorname{rad}(abc)} \\quad \\text{和} \\quad q_{\\mathrm{ratio}}(a,b,c) = \\frac{c}{\\operatorname{rad}(abc)}\n$$\n我们的目标是找到在 $c \\le B$ 的条件下使 $q_{\\log}$ 最大化的三元组。\n\n$abc$ 三元组的一个关键性质是整数 $a, b, c$ 两两互质。证明如下：\n- 已知 $\\gcd(a,b)=1$。\n- 设 $d = \\gcd(a,c)$。因为 $d$ 整除 $a$ 和 $c$，所以它也必然整除它们的差 $c-a=b$。因此，$d$ 是 $a$ 和 $b$ 的一个公因数。由于 $\\gcd(a,b)=1$，所以必有 $d=1$。因此，$\\gcd(a,c)=1$。\n- 类似地，设 $d' = \\gcd(b,c)$。因为 $d'$ 整除 $b$ 和 $c$，所以它必然整除 $c-b=a$。因此，$d'$ 是 $a$ 和 $b$ 的一个公因数。由于 $\\gcd(a,b)=1$，所以必有 $d'=1$。因此，$\\gcd(b,c)=1$。\n\n由于 $a$、$b$ 和 $c$ 两两互质，它们的素因数集合互不相交。乘积 $abc$ 的素因数集合是这些不相交集合的并集。因此，乘积的根基是各个根基的乘积：\n$$\n\\operatorname{rad}(abc) = \\operatorname{rad}(a) \\operatorname{rad}(b) \\operatorname{rad}(c)\n$$\n这个性质极大地简化了 $\\operatorname{rad}(abc)$ 的计算，因为我们可以独立地计算 $a$、$b$ 和 $c$ 的根基。\n\n### 第二部分：算法设计\n\n**2.1. 根基的高效预计算**\n在搜索过程中对每个整数进行因数分解的朴素方法，其计算成本过高。整个算法的复杂度由三元组枚举主导，约为 $O(B^2 \\log B)$，因此主循环内部的单次计算必须非常高效。因此，我们预先计算测试套件中指定的最大界限 $B_{\\max}$ 内每个整数的根基。\n\n预计算利用一种筛法来首先找出每个数的最小素因子 (SPF)。\n1.  创建一个大小为 $B_{\\max}+1$ 的数组 `spf`，并初始化 `spf[i] = i`。\n2.  使用埃拉托斯特尼筛法的一个变体来填充 `spf`。从 $p=2$ 迭代到 $\\sqrt{B_{\\max}}$。如果 `spf[p] == p`（$p$ 是素数），则遍历其倍数 $i = p^2, p^2+p, \\dots, B_{\\max}$，如果 `spf[i]` 仍为 $i$，则设置 `spf[i] = p`。此过程的时间复杂度为 $O(B_{\\max} \\log \\log B_{\\max})$。\n\n有了 `spf` 数组，我们可以高效地计算 `radicals` 数组。\n1.  创建一个大小为 $B_{\\max}+1$ 的数组 `rad`。初始化 `rad[1] = 1`。\n2.  从 $i=2$ 迭代到 $B_{\\max}$。令 $p=\\text{spf}[i]$ 且 $m=i/p$。$i$ 的素因数是 $m$ 的素因数加上可能的 $p$。\n    - 如果 $p$ 也是 $m$ 的一个素因数（可以通过测试 $\\text{spf}[m] == p$ 来检查），那么 $\\operatorname{rad}(i)=\\operatorname{rad}(m)$。\n    - 否则，$p$ 是一个新的素因数，所以 $\\operatorname{rad}(i)=\\operatorname{rad}(m) \\cdot p$。\n每次计算 $i$ 的根基耗时为常数时间，所以在 `spf` 数组可用后，构建 `rad` 数组是一个 $O(B_{\\max})$ 的操作。总预计算时间由筛法主导：$O(B_{\\max} \\log \\log B_{\\max})$。\n\n**2.2. 三元组枚举与最大化**\n通过系统地遍历所有有效候选者来搜索最优三元组。为了提高在包含多个界限 $B \\in \\{B_1, B_2, \\dots, B_k\\}$ 的测试套件上的效率，我们按升序对界限进行排序，并执行一次累积搜索。\n\n枚举过程如下：\n1.  初始化一个变量 `max_q_log` 为 $0.0$，以及一个结构来保存目前找到的最佳三元组的数据。\n2.  遍历排序后的界限 $B_j$。对于每个 $B_j$，从上一个界限 $B_{j-1}$ 搜索结束的位置继续搜索 $c$。\n3.  主搜索由嵌套循环组成：\n    - 外层循环：`for c from 3 to B`。\n    - 内层循环：`for a from 1 to c/2`。条件 $1 \\le a \\le b$ 结合 $a+b=c$ 意味着 $2a \\le c$，因此我们只需要检查 $a \\le \\lfloor c/2 \\rfloor$。\n4.  在循环内部：\n    a. 计算 $b = c-a$。\n    b. 检查互质性：`if gcd(a,b) == 1`。用于求最大公约数的欧几里得算法非常高效，复杂度为 $O(\\log a)$。\n    c. 如果互质，我们便得到了一个有效的 $abc$ 三元组。使用预计算的 `rad` 数组计算 `rad_abc = rad[a] * rad[b] * rad[c]`。\n    d. 计算 $q_{\\log} = \\log(c) / \\log(\\text{rad\\_abc})$。\n    e. 将 $q_{\\log}$ 与 `max_q_log` 进行比较。如果新值更大，则更新 `max_q_log` 并存储当前三元组 $(a,b,c)$ 的所有相关数据：$q_{\\log}$、$a$、$b$、$c$、$\\operatorname{rad}(abc)$ 和 $q_{\\mathrm{ratio}} = c/\\operatorname{rad}(abc)$。\n\n在给定界限 $B_j$ 的循环完成后，当前存储的最佳三元组即为该界限的解。对所有界限重复此过程。\n\n**2.3. 总体复杂度**\n-   **预计算**：$O(B_{\\max} \\log \\log B_{\\max})$。\n-   **枚举**：对于单个界限 $B$，两个嵌套循环大约运行 $\\sum_{c=3}^{B} c/2 \\approx B^2/4$ 次。每一步都涉及一次 GCD 计算，时间复杂度为 $O(\\log c)$。因此，枚举到界限 $B$ 的总时间大约是 $O(B^2 \\log B)$。\n-   对于整个测试套件，复杂度由搜索最大界限 $B_{\\max}$ 的过程主导，总复杂度为 $O(B_{\\max}^2 \\log B_{\\max})$。对于 $B_{\\max} = 2000$，这大约是 $(2000)^2 \\log(2000) \\approx 3 \\times 10^7$ 次操作，在计算上是可行的。\n\n该算法设计是正确的，从基本原理出发，并且效率足够高，可以在合理的时间限制内解决问题。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Solves the abc-triple problem by enumerating triples and finding the one\n    that maximizes the q_log quality for a series of given bounds.\n    \"\"\"\n    test_cases = [3, 50, 200, 500, 2000]\n    \n    # Use an efficient cumulative search by sorting the bounds.\n    sorted_bounds = sorted(test_cases)\n    max_B = sorted_bounds[-1]\n\n    def precompute_radicals(limit):\n        \"\"\"\n        Precomputes radicals for all integers up to a given limit.\n        This is done by first sieving for the Smallest Prime Factor (SPF)\n        and then iteratively building the radical array.\n        \n        Complexity: O(limit * log(log(limit)))\n        \"\"\"\n        spf = list(range(limit + 1))\n        # Sieve for Smallest Prime Factor (SPF)\n        for i in range(2, int(math.sqrt(limit)) + 1):\n            if spf[i] == i:  # i is prime\n                for j in range(i * i, limit + 1, i):\n                    if spf[j] == j:  # Only update if not already set\n                        spf[j] = i\n        \n        # Compute radicals using the SPF array\n        rad = [0] * (limit + 1)\n        rad[1] = 1\n        for i in range(2, limit + 1):\n            p = spf[i]\n            m = i // p\n            # If the smallest prime factor of i/p is p itself,\n            # this means p was already a factor of m, so the distinct prime\n            # factors are the same for i and m.\n            if spf[m] == p:\n                rad[i] = rad[m]\n            else:\n                # p is a new prime factor.\n                rad[i] = rad[m] * p\n        return rad\n\n    radicals = precompute_radicals(max_B)\n\n    # State for tracking the maximum q_log and its corresponding triple data\n    # format: [q_log, a, b, c, rad_abc, q_ratio]\n    max_q_log = 0.0\n    best_triple_data = [0.0, 0, 0, 0, 0, 0.0]\n\n    results_map = {}\n    current_c = 3\n    \n    for b_bound in sorted_bounds:\n        # Enumerate triples from the last c checked up to the current bound\n        for c in range(current_c, b_bound + 1):\n            # Iterate a from 1 up to c/2. a<=b and a+b=c implies 2a<=c.\n            for a in range(1, c // 2 + 1):\n                b = c - a\n                # The core condition for an abc-triple\n                if math.gcd(a, b) == 1:\n                    # 'a,b,c' are pairwise coprime, so rad(abc) = rad(a)rad(b)rad(c)\n                    rad_abc = radicals[a] * radicals[b] * radicals[c]\n\n                    # The problem statement guarantees rad(abc) > 1 for valid triples.\n                    q_log = np.log(c) / np.log(rad_abc)\n                    \n                    if q_log > max_q_log:\n                        max_q_log = q_log\n                        q_ratio = c / rad_abc\n                        best_triple_data = [q_log, a, b, c, rad_abc, q_ratio]\n\n        # Store the best result found up to this bound\n        results_map[b_bound] = [\n            b_bound,\n            round(best_triple_data[0], 10),\n            best_triple_data[1],\n            best_triple_data[2],\n            best_triple_data[3],\n            best_triple_data[4],\n            round(best_triple_data[5], 10)\n        ]\n        \n        current_c = b_bound + 1\n\n    # Assemble the final output in the original order of test cases\n    final_output_list = []\n    for b_val in test_cases:\n        result_list = results_map[b_val]\n        # Format numbers to match required output, especially floats\n        formatted_parts = [str(result_list[0])]\n        formatted_parts.append(f\"{result_list[1]:.10f}\")\n        formatted_parts.extend(map(str, result_list[2:6]))\n        formatted_parts.append(f\"{result_list[6]:.10f}\")\n        \n        final_output_list.append(f\"[{','.join(formatted_parts)}]\")\n        \n    print(f\"[{','.join(final_output_list)}]\")\n\nsolve()\n```", "id": "3024529"}]}