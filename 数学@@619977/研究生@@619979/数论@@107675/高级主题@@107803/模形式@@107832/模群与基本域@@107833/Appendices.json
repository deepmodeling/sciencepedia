{"hands_on_practices": [{"introduction": "虽然上半平面 $\\mathbb{H}$ 中的大多数点在 $PSL(2,\\mathbb{Z})$ 的作用下都只有平凡的稳定子群，但一些被称为椭圆不动点的特殊点，却能被非平凡的子群所固定。本练习提供了一个从基本定义出发，亲手计算出最重要的椭圆点之一 $\\rho = e^{\\pi i / 3}$ 的稳定子群的机会。完成此计算能帮助您深入理解群论如何与模曲面在其“角点”上的几何结构产生关联。", "problem": "令 $\\mathbb{H}=\\{z\\in\\mathbb{C}:\\Im(z)>0\\}$ 为复上半平面。射影特殊线性群 (PSL) $\\mathrm{PSL}(2,\\mathbb{Z})$ 通过分式线性变换作用于 $\\mathbb{H}$：对于一个矩阵 $\\gamma=\\begin{pmatrix} a & b \\\\ c & d \\end{pmatrix}$（其中 $a,b,c,d\\in\\mathbb{Z}$ 且 $ad-bc=1$）的类，定义 $\\gamma\\cdot z=\\dfrac{a z + b}{c z + d}$，其中 $z\\in\\mathbb{H}$。考虑点 $\\rho=\\exp(\\pi i/3)\\in\\mathbb{H}$。\n\n仅从作用和 $\\mathrm{PSL}(2,\\mathbb{Z})$ 的定义出发：\n- 通过求解方程 $\\dfrac{a\\rho+b}{c\\rho+d}=\\rho$（在约束条件 $a,b,c,d\\in\\mathbb{Z}$，$ad-bc=1$ 下），并理解相差一个 $-I$ 乘积的矩阵在 $\\mathrm{PSL}(2,\\mathbb{Z})$ 中代表相同元素，确定 $\\mathrm{PSL}(2,\\mathbb{Z})$ 中所有固定 $\\rho$ 的元素。\n- 通过展示一个显式的生成元并通过直接计算其适当的幂次来验证其有限阶，证明稳定子群 $\\mathrm{Stab}_{\\mathrm{PSL}(2,\\mathbb{Z})}(\\rho)$ 是有限循环群。\n- 最终确定 $\\mathrm{Stab}_{\\mathrm{PSL}(2,\\mathbb{Z})}(\\rho)$ 的确切阶数。\n\n请给出 $\\mathrm{Stab}_{\\mathrm{PSL}(2,\\mathbb{Z})}(\\rho)$ 的阶数作为最终答案，形式为一个整数。无需四舍五入。", "solution": "该问题要求计算在模群 $\\mathrm{PSL}(2,\\mathbb{Z})$ 的作用下，复上半平面 $\\mathbb{H}$ 中点 $\\rho=\\exp(\\pi i/3)$ 的稳定子群的阶。\n\n复数 $\\rho$ 由下式给出\n$$ \\rho = \\exp\\left(\\frac{\\pi i}{3}\\right) = \\cos\\left(\\frac{\\pi}{3}\\right) + i\\sin\\left(\\frac{\\pi}{3}\\right) = \\frac{1}{2} + i\\frac{\\sqrt{3}}{2} $$\n该点是多项式 $z^2 - z + 1 = 0$ 的一个根。这可以通过注意到 $\\rho^3 = \\exp(\\pi i)=-1$ 来证实，因此 $\\rho^3+1=0$。因式分解得到 $(\\rho+1)(\\rho^2-\\rho+1)=0$。因为 $\\rho \\neq -1$，所以必然有 $\\rho^2-\\rho+1=0$。这导出一个有用的代数恒等式：\n$$ \\rho^2 = \\rho - 1 $$\n\n一个元素 $\\gamma \\in \\mathrm{PSL}(2,\\mathbb{Z})$（由矩阵 $\\begin{pmatrix} a & b \\\\ c & d \\end{pmatrix}$ 表示，其中 $a, b, c, d \\in \\mathbb{Z}$ 且 $ad-bc=1$）在点 $z \\in \\mathbb{H}$ 上的作用由分式线性变换 $\\gamma \\cdot z = \\frac{az+b}{cz+d}$ 给出。\n\n为了找到 $\\rho$ 的稳定子，我们必须找到所有固定 $\\rho$ 的元素 $\\gamma$，即满足 $\\gamma \\cdot \\rho = \\rho$。我们求解以下方程：\n$$ \\frac{a\\rho+b}{c\\rho+d} = \\rho $$\n整理该方程，我们得到：\n$$ a\\rho + b = \\rho(c\\rho+d) $$\n$$ a\\rho + b = c\\rho^2 + d\\rho $$\n这导出了一个关于 $\\rho$ 的二次方程：\n$$ c\\rho^2 + (d-a)\\rho - b = 0 $$\n现在，我们代入恒等式 $\\rho^2 = \\rho-1$：\n$$ c(\\rho-1) + (d-a)\\rho - b = 0 $$\n$$ c\\rho - c + d\\rho - a\\rho - b = 0 $$\n将包含 $\\rho$ 的项组合在一起：\n$$ (c+d-a)\\rho - (b+c) = 0 $$\n由于 $a,b,c,d$ 是整数，系数 $(c+d-a)$ 和 $-(b+c)$ 是实数。数 $\\rho$ 不是实数；它的虚部 $\\Im(\\rho) = \\frac{\\sqrt{3}}{2} \\neq 0$。一个复数为零，其充要条件是其实部和虚部都为零。方程 $(c+d-a)\\rho = b+c$ 只有在两边的实部和虚部系数相等时才能成立。这意味着实系数 $(c+d-a)$ 和 $(b+c)$ 必须都为零。这给了我们一个由两个线性方程组成的方程组：\n1.  $c+d-a = 0 \\implies a = c+d$\n2.  $b+c = 0 \\implies b = -c$\n\n这些关系必须被任何固定 $\\rho$ 的 $\\mathrm{SL}(2,\\mathbb{Z})$ 矩阵的整数元素所满足。我们现在使用行列式条件 $ad-bc=1$：\n$$ (c+d)d - (-c)c = 1 $$\n$$ cd + d^2 + c^2 = 1 $$\n我们必须找到丢番图方程 $c^2 + cd + d^2 = 1$ 的所有整数解 $(c,d)$。我们可以将此方程视为关于 $c$ 的二次方程来分析它：$c^2 + dc + (d^2-1) = 0$。为了使 $c$ 存在整数解，其判别式必须是一个完全平方数：$D = d^2 - 4(d^2-1) = 4-3d^2 = k^2$，其中 $k \\ge 0$ 为某个整数。\n由于 $d$ 是一个整数，$d^2$ 可以是 $0, 1, 4, \\dots$。\n- 如果 $d^2=0$, 则 $d=0$。此时 $D=4=2^2$，是一个完全平方数。$c$ 的解是 $c = \\frac{-0 \\pm 2}{2} = \\pm 1$。所以我们有数对 $(c,d) = (1,0)$ 和 $(-1,0)$。\n- 如果 $d^2=1$, 则 $d=\\pm 1$。此时 $D=4-3=1=1^2$，是一个完全平方数。\n  - 当 $d=1$ 时，$c$ 的方程是 $c^2+c=0 \\implies c(c+1)=0$，所以 $c=0$ 或 $c=-1$。我们得到数对 $(0,1)$ 和 $(-1,1)$。\n  - 当 $d=-1$ 时，$c$ 的方程是 $c^2-c=0 \\implies c(c-1)=0$，所以 $c=0$ 或 $c=1$。我们得到数对 $(0,-1)$ 和 $(1,-1)$。\n- 如果 $d^2 \\ge 2$, 那么 $3d^2 \\ge 6$，所以 $D = 4-3d^2 < 0$。$c$ 没有实数解，因此没有整数解。\n\n总共有六对满足条件的整数对 $(c,d)$：\n$$(1,0), (-1,0), (0,1), (-1,1), (0,-1), (1,-1)$$\n\n对于每一对，我们找出相应的 $a=c+d$ 和 $b=-c$ 来构造 $\\mathrm{SL}(2,\\mathbb{Z})$ 中的矩阵：\n1.  $(c,d)=(1,0) \\implies a=1, b=-1 \\implies M_1 = \\begin{pmatrix} 1 & -1 \\\\ 1 & 0 \\end{pmatrix}$\n2.  $(c,d)=(-1,0) \\implies a=-1, b=1 \\implies M_2 = \\begin{pmatrix} -1 & 1 \\\\ -1 & 0 \\end{pmatrix} = -M_1$\n3.  $(c,d)=(0,1) \\implies a=1, b=0 \\implies M_3 = \\begin{pmatrix} 1 & 0 \\\\ 0 & 1 \\end{pmatrix} = I$\n4.  $(c,d)=(0,-1) \\implies a=-1, b=0 \\implies M_4 = \\begin{pmatrix} -1 & 0 \\\\ 0 & -1 \\end{pmatrix} = -I$\n5.  $(c,d)=(1,-1) \\implies a=0, b=-1 \\implies M_5 = \\begin{pmatrix} 0 & -1 \\\\ 1 & -1 \\end{pmatrix}$\n6.  $(c,d)=(-1,1) \\implies a=0, b=1 \\implies M_6 = \\begin{pmatrix} 0 & 1 \\\\ -1 & 1 \\end{pmatrix} = -M_5$\n\n在 $\\mathrm{PSL}(2,\\mathbb{Z})$ 中，一个矩阵与它的负矩阵被视为相同。因此，这六个矩阵对应于三个不同的元素：\n- $I$ 和 $-I$ 的类，它是 $\\mathrm{PSL}(2,\\mathbb{Z})$ 的单位元 $[I]$。\n- $M_1$ 和 $-M_1=M_2$ 的类，我们记为 $[M_1]$。\n- $M_5$ 和 $-M_5=M_6$ 的类，我们记为 $[M_5]$。\n\n所以，稳定子群 $\\mathrm{Stab}_{\\mathrm{PSL}(2,\\mathbb{Z})}(\\rho)$ 恰好有三个元素：$\\{[I], [M_1], [M_5]\\}$。它拥有的元素数量是有限的（3个）这一事实证明了它是一个有限群。\n\n为了证明它是循环群，我们展示一个生成元并验证它的阶。我们选择元素 $[M_1]$ 并计算它的幂。我们在 $\\mathrm{SL}(2,\\mathbb{Z})$ 中使用代表矩阵进行计算。\n$$ [M_1]^2 = \\left[ M_1^2 \\right] = \\left[ \\begin{pmatrix} 1 & -1 \\\\ 1 & 0 \\end{pmatrix} \\begin{pmatrix} 1 & -1 \\\\ 1 & 0 \\end{pmatrix} \\right] = \\left[ \\begin{pmatrix} 0 & -1 \\\\ 1 & -1 \\end{pmatrix} \\right] = [M_5] $$\n$[M_1]$ 的平方是另一个非单位元 $[M_5]$。现在我们计算三次方：\n$$ [M_1]^3 = [M_1^2 M_1] = [M_5 M_1] = \\left[ \\begin{pmatrix} 0 & -1 \\\\ 1 & -1 \\end{pmatrix} \\begin{pmatrix} 1 & -1 \\\\ 1 & 0 \\end{pmatrix} \\right] = \\left[ \\begin{pmatrix} -1 & 0 \\\\ 0 & -1 \\end{pmatrix} \\right] = [-I] = [I] $$\n$[M_1]$ 的幂是 $[M_1]^1 = [M_1]$，$[M_1]^2 = [M_5]$ 和 $[M_1]^3 = [I]$。这些是稳定子群的所有元素。因此，该群是循环群，由 $[M_1]$ 生成。\n\n循环群的阶等于其生成元的阶。由于 $[M_1]^3 = [I]$ 且 $[M_1]$ 没有更小的正整数次幂等于单位元，所以 $[M_1]$ 的阶是 $3$。\n因此，稳定子群 $\\mathrm{Stab}_{\\mathrm{PSL}(2,\\mathbb{Z})}(\\rho)$ 的阶是 $3$。", "answer": "$$\\boxed{3}$$", "id": "3028049"}, {"introduction": "在研究了 $\\mathbb{H}$ 内部被椭圆元素固定的点之后，我们现在将注意力转向一种不同类型的变换：双曲元素。这些等距变换并不固定上半平面内的任何点，而是保持一条唯一的测地线不变，并沿着该测地线进行平移。本实践将引导您通过矩阵的迹来识别双曲元素，然后通过定位其在实数边界上的不动点找到其不变轴，从而在矩阵的代数分类与其几何动力学之间建立起关键的联系。", "problem": "设 $SL(2,\\mathbb{Z})$ 表示行列式为 $1$ 的 $2\\times 2$ 整数矩阵构成的特殊线性群，它通过线性分式变换 $z\\mapsto \\dfrac{az+b}{cz+d}$ （其中 $A=\\begin{pmatrix}a & b \\\\ c & d\\end{pmatrix}$）作用于上半平面 $\\mathbb{H}=\\{z\\in\\mathbb{C}:\\operatorname{Im}(z)>0\\}$。如果 $SL(2,\\mathbb{Z})$ 中的一个元素 $A$ 的迹满足 $|\\operatorname{tr}(A)|>2$，则称该元素为双曲元。在庞加莱上半平面模型（即配备了双曲度量的 $\\mathbb{H}$）中，一条双曲测地线是与实轴正交的欧几里得半圆或一条垂直线。\n\n从这些定义以及 $\\mathbb{H}$ 中线性分式变换和双曲测地线的基本性质出发，按以下步骤进行：\n\n1. 构造一个具体的双曲元 $A\\in SL(2,\\mathbb{Z})$，并从基本原理出发证明其是双曲的。\n2. 对于具体矩阵\n$$A=\\begin{pmatrix}4 & 1 \\\\ 3 & 1\\end{pmatrix},$$\n验证 $A\\in SL(2,\\mathbb{Z})$ 且 $|\\operatorname{tr}(A)|>2$。\n3. 推导并求解由变换 $z\\mapsto \\dfrac{4z+1}{3z+1}$ 在 $\\mathbb{H}\\cup\\mathbb{R}$ 上导出的不动点所满足的二次方程，并以精确形式求出两个不同的实不动点 $x_{-}<x_{+}\\in\\mathbb{R}$。\n4. 仅使用 $\\mathbb{H}$ 中双曲测地线是与 $\\mathbb{R}$ 正交的欧几里得半圆这一基本描述，解释为何在 $A$ 作用下唯一不变的双曲测地线是以 $x_{-}$ 和 $x_{+}$ 为端点的半圆，并以精确形式确定其欧几里得中心 $m$（位于实轴上）和欧几里得半径 $r$。\n\n将最终答案表示为一个包含四个量 $(x_{-},\\,x_{+},\\,m,\\,r)$ 的单行矩阵。无需四舍五入，不涉及单位。最终答案中不得包含任何方程或不等式；只允许使用精确表达式。", "solution": "该问题是自洽的，其科学基础在于模群理论和双曲几何，并且是适定的。我们按顺序逐部分进行求解。\n\n$SL(2, \\mathbb{Z})$ 中的一个元素 $A = \\begin{pmatrix} a & b \\\\ c & d \\end{pmatrix}$ 是一个 $2 \\times 2$ 矩阵，其元素 $a, b, c, d \\in \\mathbb{Z}$ 为整数，且行列式 $\\det(A) = ad-bc = 1$。如果其迹 $\\operatorname{tr}(A) = a+d$ 满足条件 $|\\operatorname{tr}(A)| > 2$，则该元素被定义为双曲元。\n\n第 1 部分：构造一个双曲元\n我们需要找到一个矩阵 $A$，其系数为整数，行列式为 $1$，且迹的绝对值大于 $2$。我们选择一些简单的整数值。\n设 $A = \\begin{pmatrix} 2 & 1 \\\\ 1 & 1 \\end{pmatrix}$。\n所有元素都是整数。\n行列式为 $\\det(A) = (2)(1) - (1)(1) = 2 - 1 = 1$。因此，$A \\in SL(2, \\mathbb{Z})$。\n迹为 $\\operatorname{tr(A)} = 2 + 1 = 3$。\n我们检验其是否为双曲的条件：$|\\operatorname{tr}(A)| = |3| = 3$。由于 $3 > 2$，该条件得到满足。\n因此，$A = \\begin{pmatrix} 2 & 1 \\\\ 1 & 1 \\end{pmatrix}$ 是 $SL(2, \\mathbb{Z})$ 中一个双曲元的具体例子。\n\n第 2 部分：对给定矩阵进行验证\n给定矩阵 $A = \\begin{pmatrix} 4 & 1 \\\\ 3 & 1 \\end{pmatrix}$。\n首先，我们验证 $A \\in SL(2, \\mathbb{Z})$。元素 $4, 1, 3, 1$ 均为整数。我们计算其行列式：\n$$ \\det(A) = (4)(1) - (1)(3) = 4 - 3 = 1 $$\n由于行列式为 $1$，所以 $A$ 确实是 $SL(2, \\mathbb{Z})$ 的一个元素。\n接下来，我们验证 $A$ 是双曲的。我们计算其迹：\n$$ \\operatorname{tr}(A) = 4 + 1 = 5 $$\n我们检验条件 $|\\operatorname{tr}(A)| > 2$：\n$$ |\\operatorname{tr}(A)| = |5| = 5 > 2 $$\n该条件得到满足，因此矩阵 $A$ 是一个双曲元。\n\n第 3 部分：推导与求解不动点\n由 $A$ 导出的线性分式变换为 $g(z) = \\frac{4z+1}{3z+1}$。此变换的一个不动点是满足 $g(z) = z$ 的值 $z$。\n$$ z = \\frac{4z+1}{3z+1} $$\n假设 $3z+1 \\neq 0$，我们可以将等式两边同乘以 $(3z+1)$：\n$$ z(3z+1) = 4z+1 $$\n$$ 3z^2 + z = 4z+1 $$\n整理各项，得到不动点所满足的二次方程：\n$$ 3z^2 - 3z - 1 = 0 $$\n我们使用二次方程求根公式 $z = \\frac{-b \\pm \\sqrt{b^2-4ac}}{2a}$ 来解此方程，其中 $a=3, b=-3, c=-1$。\n$$ z = \\frac{-(-3) \\pm \\sqrt{(-3)^2 - 4(3)(-1)}}{2(3)} $$\n$$ z = \\frac{3 \\pm \\sqrt{9 + 12}}{6} $$\n$$ z = \\frac{3 \\pm \\sqrt{21}}{6} $$\n判别式 $21 > 0$，因此有两个不同的实不动点。按题目要求，我们将其标记为 $x_{-} < x_{+}$。\n$$ x_{-} = \\frac{3 - \\sqrt{21}}{6} $$\n$$ x_{+} = \\frac{3 + \\sqrt{21}}{6} $$\n由于 $\\sqrt{21} > 0$，显然 $x_{-} < x_{+}$。\n\n第 4 部分：确定不变测地线\n一个具有实系数的线性分式变换，如 $g(z) = \\frac{4z+1}{3z+1}$，将实轴 $\\mathbb{R}$（更准确地说是扩展实直线 $\\mathbb{R} \\cup \\{\\infty\\}$）映射到其自身。因此，它也将上半平面 $\\mathbb{H}$ 映射到其自身。\n$\\mathbb{H}$ 中的一条双曲测地线由其在边界 $\\partial\\mathbb{H} = \\mathbb{R} \\cup \\{\\infty\\}$ 上的两个端点唯一确定。\n设 $\\gamma$ 是以不动点 $x_{-}$ 和 $x_{+}$ 为端点的双曲测地线。\n变换 $g$ 将测地线映射到测地线。$\\gamma$ 在 $g$ 作用下的像，记作 $g(\\gamma)$，是以 $g(x_{-})$ 和 $g(x_{+})$ 为端点的测地线。\n根据定义，$x_{-}$ 和 $x_{+}$ 是 $g$ 的不动点，所以 $g(x_{-}) = x_{-}$ 且 $g(x_{+}) = x_{+}$。\n这意味着 $g(\\gamma)$ 的端点与 $\\gamma$ 的端点相同。由于一条测地线由其端点唯一确定，我们必有 $g(\\gamma) = \\gamma$。因此，以 $x_{-}$ 和 $x_{+}$ 为端点的测地线在 $A$ 的作用下是不变的。\n问题陈述了双曲测地线是与实轴正交的欧几里得半圆或垂直线。一条垂直线的一个端点在 $\\infty$ 处。由于我们的不动点 $x_{-}$ 和 $x_{+}$ 都是有限的实数，因此不变测地线必定是一个欧几里得半圆。要使一个半圆与实轴正交，其直径必须位于实轴上。该直径的端点即为 $x_{-}$ 和 $x_{+}$。\n该半圆的欧几里得中心 $m$ 必然是连接 $x_{-}$ 和 $x_{+}$ 的线段的中点。\n$$ m = \\frac{x_{-} + x_{+}}{2} = \\frac{1}{2} \\left( \\frac{3 - \\sqrt{21}}{6} + \\frac{3 + \\sqrt{21}}{6} \\right) = \\frac{1}{2} \\left( \\frac{3 - \\sqrt{21} + 3 + \\sqrt{21}}{6} \\right) = \\frac{1}{2} \\left( \\frac{6}{6} \\right) = \\frac{1}{2} $$\n该半圆的欧几里得半径 $r$ 是两端点之间距离的一半。\n$$ r = \\frac{x_{+} - x_{-}}{2} = \\frac{1}{2} \\left( \\frac{3 + \\sqrt{21}}{6} - \\frac{3 - \\sqrt{21}}{6} \\right) = \\frac{1}{2} \\left( \\frac{3 + \\sqrt{21} - 3 + \\sqrt{21}}{6} \\right) = \\frac{1}{2} \\left( \\frac{2\\sqrt{21}}{6} \\right) = \\frac{\\sqrt{21}}{6} $$\n所求的四个量为 $x_{-}$、$x_{+}$、$m$ 和 $r$。", "answer": "$$\\boxed{\\begin{pmatrix} \\frac{3 - \\sqrt{21}}{6} & \\frac{3 + \\sqrt{21}}{6} & \\frac{1}{2} & \\frac{\\sqrt{21}}{6} \\end{pmatrix}}$$", "id": "3028062"}, {"introduction": "前面的练习侧重于特定类型元素的行为，现在我们将这些思想整合为一个强大的计算工具：一个可将任何点 $z \\in \\mathbb{H}$ 映射到其在标准基本域 $F$ 中唯一代表的算法。通过迭代地应用群生成元 $T$（平移）和 $S$（反演），本实践构造性地展示了整个上半平面是如何由 $F$ 的像所铺成的，从而让您对商空间 $\\mathbb{H}/PSL(2,\\mathbb{Z})$ 的结构获得一种切实的感受。", "problem": "令 $\\mathbb{H} = \\{ z \\in \\mathbb{C} \\mid \\operatorname{Im}(z) > 0 \\}$ 表示上半平面。模群 $\\mathrm{PSL}(2,\\mathbb{Z})$ 是特殊线性群 $\\mathrm{SL}(2,\\mathbb{Z}) = \\{ \\begin{pmatrix} a & b \\\\ c & d \\end{pmatrix} \\mid a,b,c,d \\in \\mathbb{Z},\\, ad - bc = 1 \\}$ 对其正规子群 $\\{ \\pm I \\}$ 的商群，它通过分式线性变换作用于 $\\mathbb{H}$\n$$\n\\begin{pmatrix} a & b \\\\ c & d \\end{pmatrix} \\cdot z = \\frac{a z + b}{c z + d}.\n$$\n此作用的一个标准基本域 $F$ 选择为\n$$\nF = \\{ z \\in \\mathbb{H} \\mid -\\tfrac{1}{2} \\le \\operatorname{Re}(z) \\le \\tfrac{1}{2},\\; |z| \\ge 1 \\},\n$$\n通常约定，边界上的点在 $\\mathrm{PSL}(2,\\mathbb{Z})$ 的作用下被等同，以便一旦采用确定性的决胜规则，每个轨道在 $F$ 中都有唯一的代表元。\n\n定义生成元 $T = \\begin{pmatrix} 1 & 1 \\\\ 0 & 1 \\end{pmatrix}$ 和 $S = \\begin{pmatrix} 0 & -1 \\\\ 1 & 0 \\end{pmatrix}$ 于 $\\mathrm{SL}(2,\\mathbb{Z})$ 中，它们代表 $\\mathrm{PSL}(2,\\mathbb{Z})$ 的元素。元素 $T$ 的作用为 $z \\mapsto z + 1$，元素 $S$ 的作用为 $z \\mapsto -1/z$。\n\n仅从上述定义出发，设计并实现一个算法，对于给定的 $z \\in \\mathbb{H}$，构建一个由生成元 $S$ 和 $T$ 的乘积构成的元素 $g \\in \\mathrm{PSL}(2,\\mathbb{Z})$，使得 $g \\cdot z \\in F$。该算法应迭代执行以下步骤：\n- 应用 $T^{-\\operatorname{nint}(\\operatorname{Re}(z))}$，其中 $\\operatorname{nint}(x) = \\lfloor x + \\tfrac{1}{2} \\rfloor$ 是最近整数函数，以确保 $\\operatorname{Re}(z)$ 位于 $[-\\tfrac{1}{2}, \\tfrac{1}{2})$ 区间内。\n- 如果 $|z| < 1$，则应用 $S$ 将 $z$ 变换到单位圆外，注意此操作会增加虚部大小并保持点仍在 $\\mathbb{H}$ 中。\n\n重复此过程直到 $z$ 位于 $F$ 中，使用确定性的决胜规则（$\\operatorname{nint}(x) = \\lfloor x + \\tfrac{1}{2} \\rfloor$ 的选择确保了右边界 $\\operatorname{Re}(z) = \\tfrac{1}{2}$ 被映射到左边界 $\\operatorname{Re}(z) = -\\tfrac{1}{2}$）。\n\n您的程序必须：\n- 根据所描述的算法，将 $g$ 表示为矩阵 $\\begin{pmatrix} a & b \\\\ c & d \\end{pmatrix} \\in \\mathrm{SL}(2,\\mathbb{Z})$，其满足 $ad - bc = 1$，该矩阵通过 $T^{-\\operatorname{nint}(\\operatorname{Re}(z))}$ 和 $S$ 的乘积构建。\n- 对于每个输入 $z$，返回矩阵项 $(a,b,c,d)$（作为整数）、$g \\cdot z$ 的实部和虚部（作为四舍五入到 $12$ 位小数的浮点数），以及生成元应用的总次数（作为整数，每次非平凡的平移 $T^{-\\operatorname{nint}(\\operatorname{Re}(z))}$ 算作一次应用，每次应用 $S$ 也算作一次）。\n\n不涉及角度单位。不涉及物理单位。\n\n测试套件：\n使用以下以有序对 $(\\operatorname{Re}(z), \\operatorname{Im}(z))$ 表示的输入 $z \\in \\mathbb{H}$：\n1. $(0.3, 0.4)$，一个严格在单位圆内的点。\n2. $(10.2, 1.2)$，一个需要大幅平移的点。\n3. $(-3.7, 0.8)$，一个具有较大负实部的点。\n4. $(0.5, 0.9)$，一个位于右边界线 $\\operatorname{Re}(z) = \\tfrac{1}{2}$ 上的点。\n5. $(-0.49, 0.1)$，一个靠近左侧带状区域边界且在单位圆内的点。\n6. $(0.001, 0.001)$，一个在 $\\mathbb{H}$ 中且在单位圆内、模长极小的点。\n7. $(0.0, 5.0)$，一个已在基本域中的对称点。\n8. $(2.5, 0.3)$，一个实部为半整数、需要仔细取整的点。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表。每个测试用例的结果本身必须是一个形如 $[a,b,c,d,r,i,s]$ 的列表，其中 $a,b,c,d$ 是矩阵 $g$ 的整数项，$r,i$ 是 $g \\cdot z$ 的实部和虚部（四舍五入到 $12$ 位小数），$s$ 是生成元应用次数的整数计数。例如，最终输出必须如下所示：\n$[[a_1,b_1,c_1,d_1,r_1,i_1,s_1],[a_2,b_2,c_2,d_2,r_2,i_2,s_2],\\dots]$。", "solution": "问题陈述已经过验证，被认为是有效的。这是一个计算数论中的良构问题，基于模群理论的标准定义。所有必要的组成部分——域、群、群作用、基本域、生成元、确定性算法和精确的输出格式——均已提供且在数学上是合理的。\n\n任务是实现一个给定的算法，该算法对于复上半平面 $\\mathbb{H}$ 中的任意点 $z$，找到模群 $\\mathrm{PSL}(2,\\mathbb{Z})$ 的一个元素 $g$，使得 $g \\cdot z$ 位于标准基本域 $F$ 内。元素 $g$ 将被构建为群生成元 $S$ 和 $T$ 的乘积，并用一个 $\\mathrm{SL}(2,\\mathbb{Z})$ 中的矩阵表示。\n\n该算法以迭代方式运行。一个点 $z$ 被不断变换，直到它满足位于基本域 $F = \\{ z \\in \\mathbb{H} \\mid -\\tfrac{1}{2} \\le \\operatorname{Re}(z) \\le \\tfrac{1}{2},\\; |z| \\ge 1 \\}$ 的条件。该过程保证会终止，因为在算法的特定步骤中，点 $z$ 的虚部会增加，并且对于任何给定的轨道，其虚部都是有上界的。\n\n实现将按以下步骤进行：\n\n1.  **表示**：\n    -   复数 $z = x + iy$ 将使用 Python 的原生 `complex` 数据类型表示。\n    -   变换矩阵 $g \\in \\mathrm{SL}(2,\\mathbb{Z})$ 是一个具有整数项的 $2 \\times 2$ 矩阵。它将由一个 `numpy` 数组表示，数据类型为 $64$ 位整数，以防止矩阵乘法期间发生溢出。该过程从 $g$ 为单位矩阵 $I = \\begin{pmatrix} 1 & 0 \\\\ 0 & 1 \\end{pmatrix}$ 开始。\n    -   步数计数器 $s$ 初始化为 $0$。\n\n2.  **迭代算法**：执行一个循环，直到点 $z$ 在指定的变换下变得稳定。当 $z$ 位于基本域内时（特定的边界条件由算法的确定性性质处理），就达到了这种稳定性。\n\n3.  **变换步骤**：在循环内部，按顺序考虑两种变换：\n\n    a.  **平移**：使用平移生成元 $T = \\begin{pmatrix} 1 & 1 \\\\ 0 & 1 \\end{pmatrix}$ 的幂，将当前点 $z$ 的实部移入区间 $[-\\tfrac{1}{2}, \\tfrac{1}{2})$。具体的幂由最近整数函数确定，$n = \\operatorname{nint}(\\operatorname{Re}(z)) = \\lfloor \\operatorname{Re}(z) + \\tfrac{1}{2} \\rfloor$。应用于该点的变换是 $z \\mapsto z - n$，这对应于矩阵 $T^{-n} = \\begin{pmatrix} 1 & -n \\\\ 0 & 1 \\end{pmatrix}$ 的作用。如果 $n \\ne 0$，则通过左乘更新总变换矩阵 $g \\mapsto T^{-n} g$，并将步数计数 $s$ 增加 $1$。此步骤确保任何满足 $\\operatorname{Re}(z) = \\tfrac{1}{2}$ 的点都被映射到 $\\operatorname{Re}(z) = -\\tfrac{1}{2}$，从而遵守问题的决胜规则。\n\n    b.  **反演**：如果点 $z$（在可能的平移之后）位于单位圆盘内部，即 $|z| < 1$，则应用反演变换 $S = \\begin{pmatrix} 0 & -1 \\\\ 1 & 0 \\end{pmatrix}$。通过 $z \\mapsto -1/z$ 来更新该点。此变换将单位圆盘的内部映射到其外部，从而增加其模长。通过左乘更新总变换矩阵 $g \\mapsto S g$，并将步数计数 $s$ 增加 $1$。\n\n4.  **终止**：当一次完整的迭代完成，既没有进行平移（$n=0$）也没有进行反演时，循环终止。此时，条件 $-\\tfrac{1}{2} \\le \\operatorname{Re}(z) < \\tfrac{1}{2}$ 和 $|z| \\ge 1$ 均被满足，这意味着最终点 $z$ 位于基本域 $F$ 内（并遵守边界约定）。\n\n5.  **输出**：终止时，收集最终矩阵 $g$ 的整数项 $(a,b,c,d)$、最终点 $g \\cdot z$ 的实部和虚部（四舍五入到 $12$ 位小数）以及总步数 $s$，并按要求格式化。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    \n    def solve_single_case(z_real, z_imag):\n        \"\"\"\n        Applies the specified algorithm to map a point z from the upper half-plane\n        into the standard fundamental domain F.\n\n        Args:\n            z_real (float): The real part of the initial point z.\n            z_imag (float): The imaginary part of the initial point z.\n\n        Returns:\n            list: A list containing [a, b, c, d, r, i, s], where (a,b,c,d) are the\n                  integer entries of the final transformation matrix g, (r,i) are the\n                  real and imaginary parts of the final point g*z, and s is the\n                  total number of generator applications.\n        \"\"\"\n        current_z = complex(z_real, z_imag)\n        \n        # g represents the transformation matrix, starting as the identity matrix.\n        # Using 64-bit integers to be safe with matrix multiplication.\n        g = np.identity(2, dtype=np.int64)\n        \n        # s is the count of generator applications.\n        s = 0\n\n        # The algorithm is guaranteed to terminate. A loop cap is a good safeguard.\n        max_iter = 100\n        for _ in range(max_iter):\n            transformed_in_iteration = False\n\n            # Step 1: Translation.\n            # Apply T^(-n) where n = nint(Re(z)) to bring Re(z) into [-0.5, 0.5).\n            # The problem defines nint(x) = floor(x + 0.5).\n            n = int(np.floor(current_z.real + 0.5))\n            \n            if n != 0:\n                current_z -= n\n                T_inv_n = np.array([[1, -n], [0, 1]], dtype=np.int64)\n                g = T_inv_n @ g\n                s += 1\n                transformed_in_iteration = True\n\n            # Step 2: Inversion.\n            # If |z| < 1, apply the S transformation.\n            if abs(current_z) < 1.0:\n                # The point z cannot be 0 as Im(z) > 0 is an invariant.\n                current_z = -1.0 / current_z\n                S_mat = np.array([[0, -1], [1, 0]], dtype=np.int64)\n                g = S_mat @ g\n                s += 1\n                transformed_in_iteration = True\n            \n            # If no transformation occurred, the point is stable and in the fundamental domain.\n            if not transformed_in_iteration:\n                break\n        else:\n            # This block is executed if the for loop completes without a break.\n            raise RuntimeError(f\"Algorithm did not converge for z = {complex(z_real, z_imag)}\")\n\n        # Unpack the matrix g for the output.\n        a, b = g[0]\n        c, d = g[1]\n        \n        # Return the required values as a list.\n        return [int(a), int(b), int(c), int(d), current_z.real, current_z.imag, s]\n\n    # Test suite provided in the problem statement.\n    test_cases = [\n        (0.3, 0.4),\n        (10.2, 1.2),\n        (-3.7, 0.8),\n        (0.5, 0.9),\n        (-0.49, 0.1),\n        (0.001, 0.001),\n        (0.0, 5.0),\n        (2.5, 0.3),\n    ]\n\n    all_results = []\n    for case in test_cases:\n        result = solve_single_case(case[0], case[1])\n        all_results.append(result)\n\n    # Format the final output string exactly as specified in the problem.\n    result_strings = []\n    for res in all_results:\n        a, b, c, d, r, i, s_count = res\n        r_rounded = round(r, 12)\n        i_rounded = round(i, 12)\n        \n        # Normalize -0.0 to 0.0 for cleaner output.\n        if r_rounded == -0.0: r_rounded = 0.0\n        if i_rounded == -0.0: i_rounded = 0.0\n        \n        result_strings.append(f\"[{a},{b},{c},{d},{r_rounded},{i_rounded},{s_count}]\")\n    \n    print(f\"[{','.join(result_strings)}]\")\n\nsolve()\n```", "id": "3028074"}]}