{"hands_on_practices": [{"introduction": "理论知识需要通过实践来巩固。在深入研究黎曼Zeta函数的零点之前，首要的一步是掌握如何在关键区域（特别是临界线）上精确计算其函数值。本练习将引导你使用近似泛函方程这一强大工具，通过编写程序来计算在临界线 $\\operatorname{Re}(s) = 1/2$ 上的 $\\zeta(s)$ 值，这对于任何关于零点的数值研究都是一项基础而核心的技能。[@problem_id:3031521]", "problem": "设 $s = \\sigma + i t$，考虑 Riemann zeta 函数 $\\zeta(s)$ 及其函数方程，该方程可通过完备 zeta 函数 $\\xi(s) = \\pi^{-s/2} \\Gamma\\!\\left(\\frac{s}{2}\\right) \\zeta(s)$ 表示为 $\\xi(s) = \\xi(1-s)$。在临界线 $\\sigma = \\tfrac{1}{2}$ 上，可以推导出 $\\zeta\\!\\left(\\tfrac{1}{2}+i t\\right)$ 的一个近似函数方程。该方程包含两个长度相当的有限 Dirichlet 型和以及一个余项，此余项可通过渐近分析和 Gamma 函数的 Stirling 型估计来定界。你的任务是使用这样一个近似函数方程，实现对 $\\zeta\\!\\left(\\tfrac{1}{2}+i t\\right)$ 的数值计算，其中包含对称截断和一个对余项的显式、保守的界。\n\n实现一个程序，该程序对于给定的实数参数 $t$ 执行以下步骤：\n\n1. 定义 $s = \\tfrac{1}{2} + i t$ 和因子\n   $$\\chi(s) = \\pi^{s - \\frac{1}{2}} \\frac{\\Gamma\\!\\left(\\frac{1 - s}{2}\\right)}{\\Gamma\\!\\left(\\frac{s}{2}\\right)}.$$\n2. 选择一个对称截断参数\n   $$N = \\max\\!\\left(1, \\left\\lceil \\sqrt{\\frac{t}{2 \\pi}} \\right\\rceil\\right).$$\n3. 计算截断和\n   $$A_N(s) = \\sum_{n=1}^{N} n^{-s}, \\quad B_N(s) = \\sum_{n=1}^{N} n^{s-1}.$$\n4. 构造近似式\n   $$\\widetilde{\\zeta}(s; N) = A_N(s) + \\chi(s)\\, B_N(s).$$\n5. 为余项提供一个保守的数值界\n   $$R(s; N) = \\zeta(s) - \\widetilde{\\zeta}(s; N),$$\n   使用经典的 Riemann–Siegel 理论的尺度。具体来说，将其大小限定为\n   $$\\lvert R(s; N) \\rvert \\leq B(t, N), \\quad \\text{其中} \\quad B(t, N) = 4\\, (t + 1)^{-1/4} + N^{-1/2}.$$\n   该界反映了临界线上来自 Riemann–Siegel 公式的通用 $t^{-1/4}$ 尺度，并附加一个保守的修正项 $N^{-1/2}$，以覆盖较小的 $t$ 值和粗略的截断 $N$。\n\n你必须使用复数算术和通过 Lanczos 近似法对复 Gamma 函数的精确计算来实现上述内容。不允许调用任何特殊的 zeta 函数例程；求值必须基于步骤 1-4，并结合步骤 5 计算界。\n\n测试套件：\n- 案例 1 (边界情况)：$t = 0$。\n- 案例 2 (第一个非平凡零点附近的中等情况)：$t = 14.134725141$。\n- 案例 3 (较大值情况)：$t = 100$。\n\n对于每个测试案例，生成三元组\n$$\\left[\\operatorname{Re}\\left(\\widetilde{\\zeta}\\!\\left(\\tfrac{1}{2}+i t; N\\right)\\right),\\ \\operatorname{Im}\\left(\\widetilde{\\zeta}\\!\\left(\\tfrac{1}{2}+i t; N\\right)\\right),\\ B(t, N)\\right],$$\n其中前两个条目是给出近似值实部和虚部的实数，第三个条目是按规定给出余项界的实数。\n\n最终输出格式：\n你的程序应生成单行输出，包含三个结果，形式为用逗号分隔并用方括号括起来的列表，每个结果本身也是按上述顺序给出的列表。例如，\n$$\\big[\\,[\\cdot,\\cdot,\\cdot],\\,[\\cdot,\\cdot,\\cdot],\\,[\\cdot,\\cdot,\\cdot]\\,\\big].$$\n不涉及物理单位。所有角度都通过复指数和对数以弧度为单位进行隐式处理，你必须在实现中一致地使用它们。", "solution": "问题要求对给定的实数参数 $t$，在临界线 $s = \\frac{1}{2} + i t$ 上对 Riemann zeta 函数 $\\zeta(s)$ 进行数值计算。该计算需使用一种特定形式的近似函数方程，它为 $\\zeta(s)$ 提供一个估计值 $\\widetilde{\\zeta}(s; N)$。此近似的结构如下：\n$$\n\\widetilde{\\zeta}(s; N) = \\sum_{n=1}^{N} n^{-s} + \\chi(s) \\sum_{n=1}^{N} n^{s-1}\n$$\n其中 $N$ 是一个依赖于 $t$ 的截断参数，而 $\\chi(s)$ 是从 $\\zeta(s)$ 的精确函数方程中导出的一个相位因子：\n$$\n\\chi(s) = \\pi^{s - \\frac{1}{2}} \\frac{\\Gamma\\left(\\frac{1 - s}{2}\\right)}{\\Gamma\\left(\\frac{s}{2}\\right)}\n$$\n此处，$\\Gamma(z)$ 是复 Gamma 函数。问题还为余项 $R(s; N) = \\zeta(s) - \\widetilde{\\zeta}(s; N)$ 的大小指定了一个保守界的公式。任务的核心是数值实现这些公式。\n\n一个关键组成部分是精确计算复变量的 Gamma 函数 $\\Gamma(z)$。按照规定，禁止为此使用预先存在的特殊函数库。实现将基于 Lanczos 近似法，这是一种用于此目的的高精度方法。所选的 Lanczos 公式将 $\\Gamma(z+1)$ 近似为：\n$$\n\\Gamma(z+1) = \\sqrt{2\\pi}(z+g+1/2)^{z+1/2} e^{-(z+g+1/2)} \\left( p_0 + \\sum_{k=1}^{N_p-1} \\frac{p_k}{z+k} \\right)\n$$\n其中 $g$ 是一个自由选择的常数，$\\{p_k\\}$ 是预先计算好的系数。我们使用标准的高精度值 $g=7$ 和一组 $N_p=9$ 个系数 $\\{p_k\\}_{k=0}^8$。为了计算某个参数 $s$ 的 $\\Gamma(s)$，我们设置 $z = s-1$ 并应用该公式。此近似在 $\\operatorname{Re}(z) > 0$（等价于 $\\operatorname{Re}(s) > 1$）时有效。问题要求在例如 $s/2 = \\frac{1}{4} + i\\frac{t}{2}$ 这样的自变量处计算 $\\Gamma$ 函数，其自变量的实部小于 1。为了处理 $\\operatorname{Re}(s) \\le 1$ 的自变量 $s$，我们可以使用递推关系。具体来说，对于实部 $\\operatorname{Re}(s) < 1/2$ 的自变量 $s$，我们采用 Euler 反射公式：\n$$\n\\Gamma(s) = \\frac{\\pi}{\\sin(\\pi s) \\Gamma(1-s)}\n$$\n这将 $\\Gamma(s)$ 的计算归约到计算 $\\Gamma(1-s)$。由于 $\\operatorname{Re}(s) < 1/2$，新自变量的实部 $\\operatorname{Re}(1-s)=1-\\operatorname{Re}(s)$ 大于 $1/2$。因此，我们的实现分为两种情况：如果 $\\operatorname{Re}(s) < 1/2$，我们应用反射公式；否则，我们通过设置 $z=s-1$ 直接应用 Lanczos 公式。\n\n对于 $t$ 的每个测试用例值，完整的计算遵循以下步骤：\n令 $s = \\frac{1}{2} + i t$。\n\n首先，确定截断参数 $N$：\n$$\nN = \\max\\left(1, \\left\\lceil \\sqrt{\\frac{t}{2 \\pi}} \\right\\rceil\\right)\n$$\n这一选择是标准的，能确保近似中的两个和具有可比的“解析长度”。对于 $t=0$，这给出 $N=1$。\n\n其次，计算两个有限 Dirichlet 级数 $A_N(s)$ 和 $B_N(s)$：\n$$\nA_N(s) = \\sum_{n=1}^{N} n^{-s} = \\sum_{n=1}^{N} n^{-1/2} e^{-it\\ln n}\n$$\n$$\nB_N(s) = \\sum_{n=1}^{N} n^{s-1} = \\sum_{n=1}^{N} n^{-1/2} e^{+it\\ln n}\n$$\n从这些表达式中可以明显看出 $B_N(s)$ 是 $A_N(s)$ 的复共轭，即 $B_N(s) = \\overline{A_N(s)}$，因为 $s = \\frac{1}{2}+it$ 且 $n$ 是实数。\n\n第三，计算相位因子 $\\chi(s)$。当 $s = \\frac{1}{2} + i t$ 时，该因子变为：\n$$\n\\chi(s) = \\pi^{it} \\frac{\\Gamma\\left(\\frac{1/2 - it}{2}\\right)}{\\Gamma\\left(\\frac{1/2 + it}{2}\\right)} = e^{it \\ln \\pi} \\frac{\\Gamma\\left(\\frac{1}{4} - i\\frac{t}{2}\\right)}{\\Gamma\\left(\\frac{1}{4} + i\\frac{t}{2}\\right)}\n$$\nGamma 函数的两个自变量 $\\frac{1}{4} \\pm i\\frac{t}{2}$ 是复共轭的。Gamma 函数的 Schwarz 反射原理指出 $\\Gamma(\\bar{z}) = \\overline{\\Gamma(z)}$。因此，$\\Gamma(\\frac{1}{4} - i\\frac{t}{2}) = \\overline{\\Gamma(\\frac{1}{4} + i\\frac{t}{2})}$。这意味着 $\\chi(s)$ 是一个模为 1 的复数，代表一个旋转。\n\n第四，组合得到近似值 $\\widetilde{\\zeta}(s;N)$：\n$$\n\\widetilde{\\zeta}(s; N) = A_N(s) + \\chi(s) B_N(s)\n$$\n使用关系式 $B_N(s) = \\overline{A_N(s)}$，我们可以将其写为 $\\widetilde{\\zeta}(s; N) = A_N(s) + \\chi(s)\\overline{A_N(s)}$，这显示了该近似值是如何由一个和与一个旋转构造出来的。\n\n最后，根据给定公式计算保守误差界 $B(t, N)$：\n$$\nB(t, N) = 4 (t+1)^{-1/4} + N^{-1/2}\n$$\n该值提供了我们的近似值与 $\\zeta(s)$ 真实值之间差的大小的上限。\n\n所提供的解决方案是使用 Python 的 `numpy` 库实现的，因为它能稳健地处理复数和数学函数。一个独立的函数 `gamma(z)` 封装了复 Gamma 函数的 Lanczos 近似法和反射公式。主函数 `solve()` 遍历 $t$ 的测试用例，构造 $s$，计算 $N$、和 $A_N(s)$ 和 $B_N(s)$、因子 $\\chi(s)$，最后计算近似值 $\\widetilde{\\zeta}(s; N)$ 和误差界 $B(t, N)$。对每个案例，将所得的三元组 $[\\operatorname{Re}(\\widetilde{\\zeta}), \\operatorname{Im}(\\widetilde{\\zeta}), B(t,N)]$ 存储起来，并以指定格式打印。", "answer": "```python\nimport numpy as np\n\n# Coefficients for the Lanczos approximation of the Gamma function.\n# These are for g=7, N_p=9 from a standard implementation by Paul Godfrey.\nLANCZOS_G = 7\nLANCZOS_P = [\n    0.99999999999980993,\n    676.5203681218851,\n    -1259.1392167224028,\n    771.32342877765313,\n    -176.61502916214059,\n    12.507343278686905,\n    -0.13857109526572012,\n    9.9843695780195716e-6,\n    1.5056327351493116e-7,\n]\n\ndef gamma(z: complex) -> complex:\n    \"\"\"\n    Computes the complex Gamma function using the Lanczos approximation.\n    Handles Re(z) < 0.5 via the reflection formula.\n    \"\"\"\n    if z.real < 0.5:\n        # Use Euler's reflection formula: Gamma(z) * Gamma(1-z) = pi / sin(pi*z)\n        # This calls gamma(1-z) where Re(1-z) > 0.5, ensuring termination.\n        return np.pi / (np.sin(np.pi * z) * gamma(1 - z))\n    else:\n        # Apply the Lanczos approximation for Re(z) >= 0.5\n        # The formula is for Gamma(z+1), so we shift the argument.\n        z -= 1\n        x = LANCZOS_P[0]\n        for i in range(1, len(LANCZOS_P)):\n            x += LANCZOS_P[i] / (z + i)\n        \n        t = z + LANCZOS_G + 0.5\n        \n        # Compute Gamma(z+1). Using np.power handles complex base and exponent.\n        # Gamma(z+1) = sqrt(2*pi) * t^(z+0.5) * exp(-t) * x\n        gamma_z_plus_1 = np.sqrt(2 * np.pi) * np.power(t, z + 0.5) * np.exp(-t) * x\n        \n        return gamma_z_plus_1\n\n\ndef solve():\n    \"\"\"\n    Main function to compute and print the zeta function approximations.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        0.0,\n        14.134725141,\n        100.0,\n    ]\n\n    results = []\n    for t in test_cases:\n        # Step 1: Define s = 1/2 + i*t\n        s = 0.5 + 1j * t\n\n        # Step 2: Choose a symmetric truncation parameter N\n        # N = max(1, ceil(sqrt(t / (2*pi))))\n        if t <= 0:\n            N = 1\n        else:\n            N = int(np.ceil(np.sqrt(t / (2 * np.pi))))\n            N = max(1, N)\n\n        # Step 3: Compute the truncated sums A_N(s) and B_N(s)\n        n_vals = np.arange(1, N + 1, dtype=np.float64)\n        A_N = np.sum(np.power(n_vals, -s))\n        B_N = np.sum(np.power(n_vals, s - 1))\n        \n        # Sanity check: on the critical line, B_N(s) should be the conjugate of A_N(s)\n        # assert np.isclose(B_N, np.conj(A_N))\n\n        # First, compute the factor chi(s)\n        # chi(s) = pi^(s - 1/2) * Gamma((1-s)/2) / Gamma(s/2)\n        s_minus_half = s - 0.5  # This is purely imaginary: i*t\n        pi_factor = np.power(np.pi, s_minus_half)\n        \n        arg1_gamma = (1 - s) / 2\n        arg2_gamma = s / 2\n        \n        gamma_factor = gamma(arg1_gamma) / gamma(arg2_gamma)\n        \n        chi_s = pi_factor * gamma_factor\n        \n        # Step 4: Form the approximation tilde_zeta\n        tilde_zeta = A_N + chi_s * B_N\n        \n        # Step 5: Provide a conservative numerical bound for the remainder\n        # B(t, N) = 4*(t+1)^(-1/4) + N^(-1/2)\n        bound = 4.0 * np.power(t + 1.0, -0.25) + np.power(N, -0.5)\n\n        # Store the triplet [Re(zeta), Im(zeta), Bound]\n        result_triplet = [tilde_zeta.real, tilde_zeta.imag, bound]\n        results.append(result_triplet)\n\n    # Final print statement in the exact required format.\n    # The string representation of a list in Python includes spaces,\n    # which matches the format example's style.\n    formatted_results = [f\"[{r[0]},{r[1]},{r[2]}]\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3031521"}, {"introduction": "掌握了如何计算Zeta函数值后，我们将探索其零点的深刻意义。解析数论中的显式公式（explicit formula）在素数的分布（通过切比雪夫函数 $\\psi(x)$ 体现）与Zeta函数的非平凡零点之间建立了一座直接的桥梁。本练习将让你利用已知的零点列表来近似计算 $\\psi(x)$ 的行为，从而亲手构建和验证素数世界与Zeta函数零点世界之间的这一迷人联系。[@problem_id:3031529]", "problem": "设 $x$ 是一个大于 1 的实数，并令 $\\psi(x)$ 表示 Chebyshev 函数 $\\psi(x) = \\sum_{n \\le x} \\Lambda(n)$，其中 $\\Lambda(n)$ 是 von Mangoldt 函数。考虑一个显式公式，它用 Riemann zeta 函数 $\\zeta(s)$ 的非平凡零点来表示 $\\psi(x)$，其中每个非平凡零点记为 $\\rho = \\beta + i \\gamma$，且 $0 < \\beta < 1$。对于不为精确素数幂的 $x$，显式公式的一个经典形式为\n$$\n\\psi(x) \\;=\\; x \\;-\\; \\sum_{\\rho} \\frac{x^{\\rho}}{\\rho} \\;-\\; \\log(2\\pi) \\;-\\; \\frac{1}{2}\\log\\bigl(1 - x^{-2}\\bigr),\n$$\n其中求和项遍历 $\\zeta(s)$ 的所有非平凡零点 $\\rho$（按重数计）。在本问题中，你将计算该显式公式的一个截断版本，以在 $x = 10^{6}$ 处估计 $\\psi(x) - x$ 的值。你将使用一个已知的有限零点纵坐标列表，并假定对于所使用的零点，Riemann 猜想 (Riemann Hypothesis, RH) 成立，因此这些零点的 $\\beta = \\tfrac{1}{2}$。你还将评估该估计值对这些零点位置的微小扰动的敏感度。\n\n你必须遵守以下算法和数学要求：\n- 使用 $x = 10^{6}$。\n- 设可用零点纵坐标集合为位于临界线 $\\operatorname{Re}(s) = \\tfrac{1}{2}$ 上的 $\\zeta(s)$ 的非平凡零点的前十个正纵坐标 $\\gamma_{k}$，如下所列：\n  - $\\gamma_{1} = 14.134725141734693$,\n  - $\\gamma_{2} = 21.022039638771555$,\n  - $\\gamma_{3} = 25.010857580145688$,\n  - $\\gamma_{4} = 30.424876125859513$,\n  - $\\gamma_{5} = 32.935061587739189$,\n  - $\\gamma_{6} = 37.586178158825671$,\n  - $\\gamma_{7} = 40.918719012147495$,\n  - $\\gamma_{8} = 43.327073280914999$,\n  - $\\gamma_{9} = 48.005150881167159$,\n  - $\\gamma_{10} = 49.773832477672302$。\n- 对于截断水平 $N \\in \\{0,1,\\dots,10\\}$，近似计算\n$$\n\\psi(x) - x \\;\\approx\\; - \\sum_{k=1}^{N} \\left( \\frac{x^{\\rho_{k}}}{\\rho_{k}} + \\frac{x^{\\overline{\\rho_{k}}}}{\\overline{\\rho_{k}}} \\right) \\;-\\; \\log(2\\pi) \\;-\\; \\frac{1}{2}\\log\\bigl(1 - x^{-2}\\bigr),\n$$\n其中 $\\rho_{k} = \\tfrac{1}{2} + i \\gamma_{k}$ 且 $\\overline{\\rho_{k}} = \\tfrac{1}{2} - i \\gamma_{k}$。注意，对于实数 $x$，每一对都贡献一个实数值，并且成对的和可以简化为\n$$\n\\frac{x^{\\rho_{k}}}{\\rho_{k}} + \\frac{x^{\\overline{\\rho_{k}}}}{\\overline{\\rho_{k}}}\n\\;=\\;\n2\\, x^{1/2}\\, \\frac{\\tfrac{1}{2}\\cos(\\gamma_{k}\\log x) + \\gamma_{k}\\sin(\\gamma_{k}\\log x)}{\\tfrac{1}{4} + \\gamma_{k}^{2}}。\n$$\n- 为评估估计值对零点位置的敏感度，对一个选定的纵坐标引入扰动：对于给定的索引 $j \\in \\{1,\\dots,N\\}$ 和一个小的实数扰动 $\\delta$，将 $\\gamma_{j}$ 替换为 $\\gamma_{j} + \\delta$ 并重新计算截断估计值。将敏感度度量定义为扰动后和未扰动估计值之间的绝对差。\n\n所有计算均为纯数学计算且无单位；所有对数均使用自然对数。你应当使用实数算术和上面给出的三角函数简化形式来实现该算法。\n\n测试套件：\n- 使用 $x = 10^{6}$ 和上述 $\\gamma_{k}$ 列表。计算以下五个输出：\n  1) 当 $N = 0$ 时的截断估计值（边界情况，不使用零点）。\n  2) 当 $N = 5$ 时的截断估计值（基线部分和）。\n  3) 当 $N = 10$ 时的截断估计值（更大的部分和）。\n  4) 当 $N = 10$ 时，对第 $j = 5$ 个纵坐标施加 $\\delta = 10^{-6}$ 的扰动后的敏感度。\n  5) 当 $N = 10$ 时，对第 $j = 1$ 个纵坐标施加 $\\delta = 10^{-6}$ 的扰动后的敏感度。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含五个计算结果，格式为方括号括起来的逗号分隔列表，并按上述顺序列出。例如，输出行必须如下所示：\n$[\\text{result}_{1},\\text{result}_{2},\\text{result}_{3},\\text{result}_{4},\\text{result}_{5}]$\n其中每个 $\\text{result}_{k}$ 是一个以标准十进制表示法书写的实数。", "solution": "用户希望计算 Chebyshev 函数 $\\psi(x)$ 显式公式的截断版本，并评估其对 Riemann zeta 函数零点位置扰动的敏感度。\n\n### 基于原理的设计\n\n该问题围绕解析数论中的显式公式展开，该公式将素数计数函数 $\\psi(x)$ 与 Riemann zeta 函数 $\\zeta(s)$ 的非平凡零点 $\\rho$ 联系起来。提供的公式为：\n$$\n\\psi(x) \\;=\\; x \\;-\\; \\sum_{\\rho} \\frac{x^{\\rho}}{\\rho} \\;-\\; \\log(2\\pi) \\;-\\; \\frac{1}{2}\\log\\bigl(1 - x^{-2}\\bigr)\n$$\n这可以重排以表示 $\\psi(x)$ 相对于 $x$ 的偏差：\n$$\n\\psi(x) - x \\;=\\; -\\sum_{\\rho} \\frac{x^{\\rho}}{\\rho} \\;-\\; \\log(2\\pi) \\;-\\; \\frac{1}{2}\\log\\bigl(1 - x^{-2}\\bigr)\n$$\n求和遍历所有非平凡零点 $\\rho$。这些零点以复共轭对的形式出现。如果 $\\rho = \\beta + i\\gamma$ 是一个零点，那么它的共轭 $\\overline{\\rho} = \\beta - i\\gamma$ 也是一个零点。该问题假定对于给定的零点 Riemann 猜想成立，这意味着它们的实部是 $\\beta = \\frac{1}{2}$。在此假设下，对于一个正纵坐标 $\\gamma_k > 0$，一对零点由 $\\rho_k = \\frac{1}{2} + i\\gamma_k$ 和 $\\overline{\\rho_k} = \\frac{1}{2} - i\\gamma_k$ 给出。\n\n算法的核心是通过对前 $N$ 对零点求和来计算 $\\psi(x) - x$ 的截断近似值。该近似值（我们记为 $E(x, N, \\{\\gamma_k\\})$）为：\n$$\nE(x, N, \\{\\gamma_k\\}) \\;\\approx\\; - \\sum_{k=1}^{N} \\left( \\frac{x^{\\rho_{k}}}{\\rho_{k}} + \\frac{x^{\\overline{\\rho_{k}}}}{\\overline{\\rho_{k}}} \\right) \\;-\\; \\log(2\\pi) \\;-\\; \\frac{1}{2}\\log\\bigl(1 - x^{-2}\\bigr)\n$$\n来自每对共轭零点的贡献是一个实值项。如问题所述，该项简化为：\n$$\n\\frac{x^{\\rho_{k}}}{\\rho_{k}} + \\frac{x^{\\overline{\\rho_{k}}}}{\\overline{\\rho_{k}}}\n\\;=\\;\n2\\, x^{1/2}\\, \\frac{\\tfrac{1}{2}\\cos(\\gamma_{k}\\log x) + \\gamma_{k}\\sin(\\gamma_{k}\\log x)}{\\tfrac{1}{4} + \\gamma_{k}^{2}}\n$$\n我们的算法实现了一个函数 `compute_psi_minus_x`，用于计算这个截断估计值 $E(x, N, \\{\\gamma_k\\})$。\n\n**算法步骤：**\n\n1.  **定义输入和常量：** 将 $x$ 的值设为 $10^6$。存储前 10 个正纵坐标 $\\{\\gamma_k\\}$ 的列表。\n\n2.  **模块化函数：** 设计一个函数 `compute_psi_minus_x(x, gammas_list)` 来计算该估计值。它接受 $x$ 和一个纵坐标列表作为输入，其中列表的长度对应于截断水平 $N$。\n\n3.  **常数项计算：** 该函数首先计算表达式中与零点无关的部分：$C(x) = \\log(2\\pi) + \\frac{1}{2}\\log(1 - x^{-2})$。总估计值为 $-S - C(x)$，其中 $S$ 是对零点的求和。为了在 $x$ 很大时保持数值稳定性，项 $\\log(1 - x^{-2})$ 使用 `np.log1p(-x**-2)` 计算，这对于接近 0 的参数更精确。\n\n4.  **对零点求和：** 然后，函数遍历所提供的 `gammas_list`。对于每个 $\\gamma_k$，它使用简化的实值公式计算相应零点对的贡献。将这些贡献相加得到总和 $S = \\sum_{k=1}^{N} \\left( \\frac{x^{\\rho_{k}}}{\\rho_{k}} + \\frac{x^{\\overline{\\rho_{k}}}}{\\overline{\\rho_{k}}} \\right)$。\n\n5.  **最终估计：** 函数返回最终估计值 $-S - C(x)$。\n\n6.  **测试用例计算：** 通过使用 `gammas` 列表的适当切片调用 `compute_psi_minus_x` 来计算 $N=0$、$N=5$ 和 $N=10$ 时的估计值。对于 $N=0$，传递一个空列表，导致和 $S=0$。将 $N=10$ 时的基线估计值存储起来，用于敏感度分析。\n\n7.  **敏感度分析：** 为评估敏感度，需要计算一个扰动后的估计值。制作一个完整的 `gammas` 列表（用于 $N=10$）的副本。通过添加一个小的扰动 $\\delta = 10^{-6}$ 来修改选定的纵坐标 $\\gamma_j$。使用这个扰动后的列表调用 `compute_psi_minus_x` 函数。然后将敏感度计算为该扰动后估计值与基线 $N=10$ 估计值之间的绝对差。对 $j=1$ 和 $j=5$ 执行此过程。\n\n8.  **输出格式化：** 将五个所需的数值结果收集到一个列表中，并按照指定格式化为单个输出字符串。\n\n这种结构化方法通过直接实现既定的数学公式来确保正确性，并通过利用 `numpy` 库中的适当函数来提供稳健的数值结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_psi_minus_x(x, gammas_list):\n    \"\"\"\n    Computes the truncated explicit formula approximation for psi(x) - x.\n\n    Args:\n        x (float): The value at which to evaluate the function. Must be > 1.\n        gammas_list (list of float): A list of the positive ordinates of the\n                                     nontrivial zeros of the Riemann zeta function.\n\n    Returns:\n        float: The approximated value of psi(x) - x.\n    \"\"\"\n    log_x = np.log(x)\n    x_sqrt = np.sqrt(x)\n\n    # Calculate the constant terms: -log(2*pi) - 0.5*log(1 - x**-2)\n    # Using np.log1p(y) = log(1+y) for better precision when y is close to 0.\n    # Here, y = -x**-2, which is very close to 0 for x=10^6.\n    const_term = -(np.log(2 * np.pi) + 0.5 * np.log1p(-x**-2))\n\n    # Calculate the sum over the nontrivial zeros.\n    sum_zeros = 0.0\n    for gamma in gammas_list:\n        arg = gamma * log_x\n        # Contribution from the pair of zeros (1/2 + i*gamma, 1/2 - i*gamma)\n        numerator = 0.5 * np.cos(arg) + gamma * np.sin(arg)\n        denominator = 0.25 + gamma**2\n        term = 2 * x_sqrt * numerator / denominator\n        sum_zeros += term\n    \n    # The full formula is -sum_zeros + const_term\n    return -sum_zeros + const_term\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem as specified.\n    \"\"\"\n    # Define the parameters and test cases from the problem statement.\n    x = 10.0**6\n    gammas = [\n        14.134725141734693,\n        21.022039638771555,\n        25.010857580145688,\n        30.424876125859513,\n        32.935061587739189,\n        37.586178158825671,\n        40.918719012147495,\n        43.327073280914999,\n        48.005150881167159,\n        49.773832477672302\n    ]\n    delta = 1e-6\n\n    # 1) Compute the truncated estimate with N = 0 (no zeros used)\n    est_N0 = compute_psi_minus_x(x, [])\n    \n    # 2) Compute the truncated estimate with N = 5\n    est_N5 = compute_psi_minus_x(x, gammas[:5])\n\n    # 3) Compute the truncated estimate with N = 10\n    est_N10 = compute_psi_minus_x(x, gammas)\n\n    # 4) Compute the sensitivity for N = 10 when perturbing gamma_5\n    gammas_pert_j5 = gammas[:]  # Create a copy\n    gammas_pert_j5[4] += delta   # j=5 corresponds to index 4\n    est_pert_j5 = compute_psi_minus_x(x, gammas_pert_j5)\n    sens_j5 = abs(est_pert_j5 - est_N10)\n\n    # 5) Compute the sensitivity for N = 10 when perturbing gamma_1\n    gammas_pert_j1 = gammas[:]  # Create a copy\n    gammas_pert_j1[0] += delta   # j=1 corresponds to index 0\n    est_pert_j1 = compute_psi_minus_x(x, gammas_pert_j1)\n    sens_j1 = abs(est_pert_j1 - est_N10)\n\n    results = [est_N0, est_N5, est_N10, sens_j5, sens_j1]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3031529"}, {"introduction": "超越单个零点的影响，我们进一步考察它们的集体统计特性。格拉姆定律（Gram's Law）为零点的分布提供了一个简单但惊人准确的启发式规则，即零点倾向于在格拉姆点之间有序出现。通过本练习，你将通过编程寻找该“定律”失效的具体反例，这不仅揭示了零点分布的微妙与复杂性，也激发了对零点统计行为进行更深层次研究的兴趣。[@problem_id:3031532]", "problem": "设 $\\zeta(s)$ 表示黎曼zeta函数，当 $\\Re(s) > 1$ 时，它由级数 $\\zeta(s) = \\sum_{n=1}^{\\infty} n^{-s}$ 定义，并通过解析延拓扩展到整个复平面，但在 $s=1$ 处有一个简单极点。定义 Hardy $Z$-函数为 $Z(t) = e^{i \\theta(t)} \\zeta\\!\\left(\\tfrac{1}{2} + i t\\right)$，其中 $\\theta(t)$ 是 Riemann–Siegel theta 函数，由下式给出\n$$\n\\theta(t) = \\arg \\Gamma\\!\\left(\\tfrac{1}{4} + \\tfrac{i t}{2}\\right) - \\tfrac{t}{2} \\log \\pi,\n$$\n其中幅角的分支在 $t \\ge 0$ 时连续选取。Gram点 $\\{g_n\\}_{n \\ge 0}$ 由 $\\theta(g_n) = n \\pi$（对于整数 $n \\ge 0$）隐式定义。Gram定律断言，从启发式角度看，$Z(g_n)$ 的值在连续的Gram点上应该符号交替。当两个连续值 $Z(g_n)$ 和 $Z(g_{n+1})$ 具有相同符号（或其中一个为零）时，便观测到Gram定律的失效，此时符号交替性质被违反。\n\n从以下基本依据出发：\n- 黎曼zeta函数的函数方程，其等价形式为Hardy $Z$-函数 $Z(t)$ 对于实数 $t$ 是实值的。\n- 从gamma函数的Stirling近似导出的，针对大 $t$ 值的Riemann–Siegel theta函数的渐近式：\n$$\n\\theta(t) \\approx \\tfrac{t}{2} \\log\\!\\left(\\tfrac{t}{2\\pi}\\right) - \\tfrac{t}{2} - \\tfrac{\\pi}{8} + \\tfrac{1}{48 t} + \\tfrac{7}{5760 t^3} + \\tfrac{31}{80640 t^5},\n$$\n其导数为\n$$\n\\theta'(t) \\approx \\tfrac{1}{2} \\log\\!\\left(\\tfrac{t}{2\\pi}\\right) - \\tfrac{1}{48 t^2} - \\tfrac{7}{1920 t^4} - \\tfrac{31}{16128 t^6}.\n$$\n- $Z(t)$ 的Riemann–Siegel近似函数方程，它给出了截断主和\n$$\nZ(t) \\approx 2 \\sum_{n=1}^{N} n^{-1/2} \\cos\\!\\big(\\theta(t) - t \\log n\\big), \\quad \\text{其中 } N = \\left\\lfloor \\sqrt{\\tfrac{t}{2\\pi}} \\right\\rfloor,\n$$\n且对于中等到较大的 $t$ 值，被忽略的余项是低阶的。\n\n你的任务是构建一个程序，通过在选定的索引范围内计算连续的Gram点 $g_n$，通过截断的Riemann–Siegel主和计算 $Z(g_n)$，并检查 $Z(g_n)$ 的符号是否交替，从而展示一个Gram定律失效的具体实例。使用上述渐近展开式计算 $\\theta(t)$ 和 $\\theta'(t)$，并使用一种稳定的求根方法（例如，在需要时可稳健回退至二分法的Newton法）数值求解方程 $\\theta(t) = n \\pi$ 以得到 $t$。然后，计算 $Z(t)$ 的截断和并确定其符号。将那些数值上与零无法区分（在某个小的绝对容差范围内）的 $Z(t)$ 值视为破坏了符号交替性。\n\n设计程序以处理以下索引范围 $(n_{\\text{start}}, n_{\\text{end}})$ 的测试套件：\n- 案例1（理想路径）：$(10, 30)$。\n- 案例2（定向失效搜索）：$(120, 140)$。\n- 案例3（更大的索引窗口）：$(500, 520)$。\n\n对于每个案例，从 $n_{\\text{start}}$ 到 $n_{\\text{end}}-1$ 扫描 $n$，计算 $g_n$ 和 $g_{n+1}$，并确定区间内使得 $Z(g_n)$ 和 $Z(g_{n+1})$ 符号不交替的最小整数 $n$。如果在整个区间内符号交替性都成立，则该案例返回 $-1$。因此，这三个案例所需的输出是整数。\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，“[result1,result2,result3]”）。不需要物理单位或角度单位。你实现的数值算法必须在科学上是合理的，并且与给定的基本公式一致，你的数值容差必须被合理地选择，以反映所涉及的近似。", "solution": "所提出的问题是数论中一个定义明确的计算练习，要求对黎曼zeta函数的Gram定律进行数值研究。该问题提供了继续进行所需的所有必要数学定义和近似。它有科学依据、内部一致，并且不需要任何超出所提供信息的内容。因此，该问题被视为有效，并将给出一个解决方案。\n\n任务的核心是在指定的范围 $(n_{\\text{start}}, n_{\\text{end}})$ 内，找到使Gram定律失效的最小整数索引 $n$。Gram定律启发式地预测Hardy $Z$-函数 $Z(t)$ 的符号在连续的Gram点 $g_n$ 和 $g_{n+1}$ 处交替。如果 $Z(g_n)$ 和 $Z(g_{n+1})$ 符号相同，或者其中一个为零，则发生失效。这等价于检验条件 $\\text{sign}(Z(g_n)) \\cdot \\text{sign}(Z(g_{n+1})) \\neq -1$。\n\n解决方案通过一系列有条理的步骤构建：\n1. 实现所提供的Riemann-Siegel theta函数 $\\theta(t)$ 及其导数 $\\theta'(t)$ 的渐近公式。\n2. 开发一个数值程序，通过求解方程 $\\theta(g_n) = n\\pi$ 来找到Gram点 $g_n$。\n3. 实现所提供的截断Riemann-Siegel主和，以近似Hardy $Z$-函数 $Z(t)$。\n4. 系统地扫描给定的索引范围，以检测符号交替的首次失效。\n\n**1. 渐近公式的实现**\n\n问题提供了Riemann-Siegel theta函数 $\\theta(t)$ 及其导数 $\\theta'(t)$ 的特定渐近展开式。这些函数是计算的基础。\n\n- 函数 $\\theta(t)$ 使用以下展开式实现：\n$$\n\\theta(t) \\approx \\tfrac{t}{2} \\log\\!\\left(\\tfrac{t}{2\\pi}\\right) - \\tfrac{t}{2} - \\tfrac{\\pi}{8} + \\tfrac{1}{48 t} + \\tfrac{7}{5760 t^3} + \\tfrac{31}{80640 t^5}\n$$\n此近似对大的 $t$ 有效。\n\n- 求根算法所需的导数 $\\theta'(t)$ 使用其对应的展开式实现：\n$$\n\\theta'(t) \\approx \\tfrac{1}{2} \\log\\!\\left(\\tfrac{t}{2\\pi}\\right) - \\tfrac{1}{48 t^2} - \\tfrac{7}{1920 t^4} - \\tfrac{31}{16128 t^6}\n$$\n\n**2. Gram点的计算**\n\nGram点 $\\{g_n\\}$ 被定义为方程 $\\theta(t) = n\\pi$ （对于非负整数 $n$）的解。这是一个针对函数 $f(t) = \\theta(t) - n\\pi$ 的求根问题。鉴于解析导数 $f'(t) = \\theta'(t)$ 可用，如问题建议，Newton法是一个高效且合适的选择。其迭代更新规则是：\n$$\nt_{k+1} = t_k - \\frac{f(t_k)}{f'(t_k)} = t_k - \\frac{\\theta(t_k) - n\\pi}{\\theta'(t_k)}\n$$\n为确保收敛，需要一个好的 $g_n$ 初始猜测值 $t_0$。通过反演 $\\theta(t)$ 展开式的主导项 $\\theta(t) \\approx \\frac{t}{2} \\log(\\frac{t}{2\\pi})$，我们可以推导出一个合适的起始值。设 $n\\pi \\approx \\frac{t}{2}\\log(\\frac{t}{2\\pi})$，我们得到近似关系 $t \\approx 2\\pi n / \\log(n)$。这为足够大的 $n$ 提供了Newton-Raphson迭代的稳健初始猜测。实现将使用 `scipy.optimize.newton` 函数，它提供了一个可靠的预构建求解器。\n\n**3. Hardy Z-函数的求值**\n\nHardy $Z$-函数使用所提供的截断Riemann-Siegel主和进行求值：\n$$\nZ(t) \\approx 2 \\sum_{k=1}^{N} k^{-1/2} \\cos\\!\\big(\\theta(t) - t \\log k\\big)\n$$\n其中和中的项数 $N$ 由 $N = \\lfloor \\sqrt{t/(2\\pi)} \\rfloor$ 给出。余弦项中所需的 $\\theta(t)$ 值使用与第1步中相同的渐近公式计算。这个 $Z(t)$ 的近似对于中等大的 $t$ 值是准确的，这与所研究的索引范围相对应。\n\n**4. Gram定律失效的检测**\n\n算法的最后阶段是测试失效情况。对于给定范围 $[n_{\\text{start}}, n_{\\text{end}}-1]$ 中的每个整数 $n$，执行以下过程：\na. 使用第2步中的Newton法程序计算Gram点 $g_n$ 和 $g_{n+1}$。\nb. 使用第3步中的公式求值相应的 $Z$-函数值 $Z(g_n)$ 和 $Z(g_{n+1})$。\nc. 确定这两个值的符号。对于一个小的容差 $\\epsilon = 10^{-9}$，如果 $|v| < \\epsilon$，则值 $v$ 被认为是零。符号定义如下：\n$$\n\\text{sign}(v) = \\begin{cases} 1 & \\text{if } v > \\epsilon \\\\ -1 & \\text{if } v < -\\epsilon \\\\ 0 & \\text{if } |v| \\le \\epsilon \\end{cases}\n$$\nd. 检查符号是否未能交替。如果 $\\text{sign}(Z(g_n)) \\cdot \\text{sign}(Z(g_{n+1})) \\neq -1$，则记录一次失效。这个条件正确地捕捉了符号相同（乘积为 $1$）或其中一个值在数值上为零（乘积为 $0$）的情况。\ne. 如果找到了索引 $n$ 的失效情况，该值将被记录为给定范围的结果，并且该范围的搜索终止。如果循环完成而没有发现任何失效，则结果记录为 $-1$。\n\n这个完整的算法设计在附带的Python脚本中实现，该脚本处理指定的测试案例并生成所需的输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import newton\n\ndef solve():\n    \"\"\"\n    Computes the smallest index n of a Gram's law failure in given ranges.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        (10, 30),\n        (120, 140),\n        (500, 520),\n    ]\n\n    # Numerical tolerance for treating a value as zero\n    ZERO_TOLERANCE = 1e-9\n\n    memoized_theta = {}\n    \n    def theta(t: float) -> float:\n        \"\"\"\n        Asymptotic expansion for the Riemann-Siegel theta function.\n        \"\"\"\n        if t in memoized_theta:\n            return memoized_theta[t]\n        \n        if t <= 0:\n            return 0.0\n            \n        # Per the problem statement\n        t_inv = 1.0 / t\n        t_inv_3 = t_inv**3\n        t_inv_5 = t_inv**5\n        \n        term1 = t / 2.0 * np.log(t / (2.0 * np.pi))\n        term2 = -t / 2.0\n        term3 = -np.pi / 8.0\n        term4 = 1.0 / 48.0 * t_inv\n        term5 = 7.0 / 5760.0 * t_inv_3\n        term6 = 31.0 / 80640.0 * t_inv_5\n        \n        result = term1 + term2 + term3 + term4 + term5 + term6\n        memoized_theta[t] = result\n        return result\n\n    def theta_prime(t: float) -> float:\n        \"\"\"\n        Derivative of the asymptotic expansion for theta(t).\n        \"\"\"\n        if t <= 0:\n            return np.inf  # Avoid division by zero, effectively pushing solver away\n\n        t_inv_2 = 1.0 / (t * t)\n        t_inv_4 = t_inv_2 * t_inv_2\n        t_inv_6 = t_inv_4 * t_inv_2\n\n        term1 = 0.5 * np.log(t / (2.0 * np.pi))\n        term2 = -1.0 / (48.0) * t_inv_2\n        term3 = -7.0 / (1920.0) * t_inv_4\n        term4 = -31.0 / (16128.0) * t_inv_6\n        \n        return term1 + term2 + term3 + term4\n\n    memoized_gram_points = {}\n    \n    def find_gram_point(n: int) -> float:\n        \"\"\"\n        Finds the n-th Gram point g_n by solving theta(t) = n*pi.\n        \"\"\"\n        if n in memoized_gram_points:\n            return memoized_gram_points[n]\n\n        # Objective function for root finding: f(t) = theta(t) - n*pi\n        func = lambda t: theta(t) - n * np.pi\n        \n        # Derivative of the objective function\n        fprime = theta_prime\n        \n        # Initial guess from inverting the leading term of theta(t)\n        # t/2*log(t/(2*pi)) ~ n*pi => x*log(x) ~ n where x=t/(2*pi)\n        # For large n, t ~ 2*pi*n / log(n)\n        if n > 1:\n            t_guess = 2 * np.pi * n / np.log(n)\n        else: # Heuristic for small n where log(n) is problematic\n            t_guess = 20.0 \n\n        # Use Scipy's Newton-Raphson solver\n        gram_point = newton(func, t_guess, fprime=fprime, tol=1e-12, maxiter=100)\n        memoized_gram_points[n] = gram_point\n        return gram_point\n\n    memoized_z_values = {}\n\n    def Z_func(t: float) -> float:\n        \"\"\"\n        Approximates the Hardy Z-function using the truncated Riemann-Siegel main sum.\n        \"\"\"\n        if t in memoized_z_values:\n            return memoized_z_values[t]\n\n        N = int(np.sqrt(t / (2.0 * np.pi)))\n        if N == 0:\n            return 0.0\n\n        theta_val = theta(t)\n        \n        k_vals = np.arange(1, N + 1)\n        \n        terms = (1.0 / np.sqrt(k_vals)) * np.cos(theta_val - t * np.log(k_vals))\n        total_sum = np.sum(terms)\n        \n        result = 2.0 * total_sum\n        memoized_z_values[t] = result\n        return result\n\n    def get_sign(value: float) -> int:\n        \"\"\"\n        Determines the sign of a value, treating small values as zero.\n        \"\"\"\n        if value > ZERO_TOLERANCE:\n            return 1\n        elif value < -ZERO_TOLERANCE:\n            return -1\n        else:\n            return 0\n\n    results = []\n    for n_start, n_end in test_cases:\n        found_failure_index = -1\n        for n in range(n_start, n_end):\n            # We need to evaluate Z at g_n and g_{n+1}\n            g_n = find_gram_point(n)\n            g_n_plus_1 = find_gram_point(n + 1)\n\n            z_n = Z_func(g_n)\n            z_n_plus_1 = Z_func(g_n_plus_1)\n\n            sign_n = get_sign(z_n)\n            sign_n_plus_1 = get_sign(z_n_plus_1)\n\n            # A failure occurs if signs do not alternate\n            if sign_n * sign_n_plus_1 != -1:\n                found_failure_index = n\n                break\n        \n        results.append(found_failure_index)\n        \n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3031532"}]}