{"hands_on_practices": [{"introduction": "本练习将引导你完成计算实二次域调节子 (regulator) 的基本过程，这是调节子不平凡的最简单情形。通过处理 $K=\\mathbb{Q}(\\sqrt{2})$ 这个例子，你将练习使用狄利克雷单位定理 (Dirichlet's Unit Theorem) 确定单位群的结构，并通过求解佩尔型方程 (Pell-type equation) 找到基本单位。这个动手计算为理解调节子的定义及其与数域算术的联系提供了坚实的具体基础。[@problem_id:3022829]", "problem": "令 $K=\\mathbb{Q}(\\sqrt{2})$。利用二次域的整数环结构、范数映射以及数域的 Dirichlet 单位定理（DUT），从基本原理出发确定 $K$ 的基本单位并计算其正则子 $R_{K}$。您的推导应包括：\n- 确定整数环 $\\mathcal{O}_{K}$以及 $K$ 的实嵌入。\n- 通过分析与 $K$ 相关的 Pell 型范数方程，证明单位群 $\\mathcal{O}_{K}^{\\times}$ 的秩为 $1$ 并确定其自由部分的生成元。\n- 通过对数嵌入及其对单位秩为 $1$ 的实二次域的余体积解释，计算正则子 $R_{K}$。\n\n以单一闭式表达式给出 $R_{K}$ 的精确值。不需要数值近似。", "solution": "本题要求计算数域 $K=\\mathbb{Q}(\\sqrt{2})$ 的正则子 $R_K$。推导过程必须遵循指定步骤，从基本原理出发。\n\n首先，我们确定给定的数域及其性质。该域为 $K = \\mathbb{Q}(\\sqrt{2})$，是一个形如 $\\mathbb{Q}(\\sqrt{d})$ 的实二次域，其中 $d=2$。由于 $d=2$ 是一个无平方因子整数且 $2 \\equiv 2 \\pmod{4}$，所以 $K$ 的整数环是 $\\mathcal{O}_K = \\mathbb{Z}[\\sqrt{2}]$。$\\mathcal{O}_K$ 中的元素形如 $a+b\\sqrt{2}$，其中 $a$ 和 $b$ 是整数，$a, b \\in \\mathbb{Z}$。\n\n接下来，我们确定 $K$ 到复数域 $\\mathbb{C}$ 的嵌入。由于 $K$ 是一个实二次域，存在两个不同的实嵌入，没有非实复嵌入。这些嵌入 $\\sigma_1, \\sigma_2: K \\to \\mathbb{R}$ 由下式给出：\n$\\sigma_1(a+b\\sqrt{2}) = a+b\\sqrt{2}$ （恒等嵌入）\n$\\sigma_2(a+b\\sqrt{2}) = a-b\\sqrt{2}$ （共轭嵌入）\n实嵌入的个数为 $r_1=2$，共轭复嵌入对的个数为 $r_2=0$。\n\n根据 Dirichlet 单位定理， $\\mathcal{O}_K$ 的单位群（记作 $\\mathcal{O}_K^\\times$）是一个有限生成阿贝尔群，其结构为 $\\mathcal{O}_K^\\times \\cong \\mu(K) \\times \\mathbb{Z}^r$。这里，$\\mu(K)$ 是 $K$ 中单位根构成的有限群，而群的自由部分的秩 $r$ 由公式 $r = r_1 + r_2 - 1$ 给出。对于 $K=\\mathbb{Q}(\\sqrt{2})$，秩为 $r = 2 + 0 - 1 = 1$。由于 $K$ 是 $\\mathbb{R}$ 的子域，其包含的单位根仅为 $\\{1, -1\\}$，因此 $\\mu(K) \\cong \\mathbb{Z}/2\\mathbb{Z}$。所以，单位群为 $\\mathcal{O}_K^\\times \\cong \\{\\pm 1\\} \\times \\mathbb{Z}$。这意味着存在一个基本单位 $\\epsilon > 1$，它生成该群的自由部分。任何单位 $u \\in \\mathcal{O}_K^\\times$ 都可以唯一地表示为 $u = \\pm \\epsilon^n$，其中 $n \\in \\mathbb{Z}$ 是某个整数。\n\n为了找到这个基本单位 $\\epsilon$，我们必须找到 $\\mathcal{O}_K$ 中的单位。$\\mathcal{O}_K$ 中的一个元素 $\\alpha = a+b\\sqrt{2}$ 是一个单位，当且仅当其域范数 $N_{K/\\mathbb{Q}}(\\alpha)$ 是 $\\mathbb{Z}$ 中的单位，即 $N_{K/\\mathbb{Q}}(\\alpha) = \\pm 1$。范数的计算方式如下：\n$$N_{K/\\mathbb{Q}}(a+b\\sqrt{2}) = (a+b\\sqrt{2})(a-b\\sqrt{2}) = a^2 - 2b^2$$\n因此，寻找单位等价于寻找 Pell 型方程 $a^2 - 2b^2 = \\pm 1$ 的整数解 $(a, b)$。基本单位是大于 $1$ 的最小单位。我们寻找能产生大于 $1$ 的单位的最小正整数 $a$ 和 $b$ 的解。让我们从 $b=1$ 开始测试整数值。\n当 $b=1$ 时，方程变为 $a^2 - 2(1)^2 = \\pm 1$，即 $a^2 = 2 \\pm 1$。\n$a^2 = 3$ 的情况没有整数解 $a$。\n$a^2 = 1$ 的情况得出 $a=1$（我们寻求大于 $1$ 的单位，对于 $a+b\\sqrt{2}$ 来说，这意味着 $a>0, b>0$）。\n解 $(a,b) = (1,1)$ 给出代数整数 $1+\\sqrt{2}$。它的范数是 $1^2 - 2(1)^2 = -1$，这证实了它是一个单位。它的值是 $1+\\sqrt{2} \\approx 2.414$，大于 $1$。由于这个单位来自 Pell 型方程的最小可能正整数解 $(a,b)=(1,1)$，所以 $1+\\sqrt{2}$ 是大于 $1$ 的最小单位。因此，$K=\\mathbb{Q}(\\sqrt{2})$ 的基本单位是 $\\epsilon = 1+\\sqrt{2}$。\n\n最后，我们计算正则子 $R_K$。正则子是根据单位的对数嵌入来定义的。对于一个一般的数域，对数映射为 $L: \\mathcal{O}_K^\\times \\to \\mathbb{R}^{r_1+r_2}$，由 $u \\mapsto (\\log|\\sigma_1(u)|, \\dots, \\log|\\sigma_{r_1+r_2}(u)|)$ 给出。对于 $K=\\mathbb{Q}(\\sqrt{2})$，这变为 $L: u \\mapsto (\\log|\\sigma_1(u)|, \\log|\\sigma_2(u)|)$。正则子 $R_K$ 是由基本单位基 $\\{\\epsilon_i\\}_{i=1,\\dots,r}$ 的向量 $L(\\epsilon_i)$ 构成，并去掉其中任意一列后形成的 $r \\times r$ 矩阵的行列式的绝对值。\n在我们的例子中，$r=1$，基由单个基本单位 $\\epsilon=1+\\sqrt{2}$ 组成。对数向量是：\n$$L(\\epsilon) = (\\log|\\sigma_1(1+\\sqrt{2})|, \\log|\\sigma_2(1+\\sqrt{2})|)$$\n$$L(\\epsilon) = (\\log|1+\\sqrt{2}|, \\log|1-\\sqrt{2}|) = (\\log(1+\\sqrt{2}), \\log(\\sqrt{2}-1))$$\n为了计算正则子，我们取其中一个分量（例如，第一个分量）形成一个 $1 \\times 1$ 矩阵。正则子是其行列式的绝对值：\n$$R_K = |\\det(\\log(1+\\sqrt{2}))| = \\log(1+\\sqrt{2})$$\n因为 $1+\\sqrt{2} > 1$，所以这个值是正的。如果我们选择第二个分量，我们将得到 $|\\log(\\sqrt{2}-1)| = |-\\log(1+\\sqrt{2})| = \\log(1+\\sqrt{2})$，结果相同。这是有保证的，因为对于任何单位 $u$，$L(u)$ 的分量之和是 $\\log|N(u)| = \\log(1) = 0$。\n问题中提到的“余体积解释”指的是这样一个事实，$R_K$ 是格 $L(\\mathcal{O}_K^\\times / \\mu(K))$ 在迹为零的超平面中的基本域的体积。我们所做的计算正是这个体积。对于一个实二次域，正则子就是 $R_K = \\log(\\epsilon)$，其中 $\\epsilon$ 是大于 $1$ 的基本单位。\n\n因此，$K=\\mathbb{Q}(\\sqrt{2})$ 的正则子的精确值是 $\\log(1+\\sqrt{2})$。", "answer": "$$\\boxed{\\ln(1+\\sqrt{2})}$$", "id": "3022829"}, {"introduction": "在本实践中，我们将注意力转向虚二次域，即高斯域 $K=\\mathbb{Q}(i)$，以探索一种特殊但重要的情景。你会发现其单位群的秩为零，这按照惯例导致其调节子 $R_K$ 为 1。本练习的主要目标是理解这个看似简单的值如何融入宏大的解析类数公式 (analytic class number formula) 中，将代数不变量与戴德金 zeta 函数 (Dedekind zeta function) 的解析行为联系起来。[@problem_id:3022871]", "problem": "令 $K=\\mathbb{Q}(i)$ 为高斯数域。仅使用代数数论中的基础定义和公认事实，按以下步骤进行。\n\n1. 通过分析其到 $\\mathbb{R}$ 和 $\\mathbb{C}$ 上的域嵌入，确定 $K$ 的符号参数 $(r_{1},r_{2})$，并计算 $K$ 中单位根的数目 $w_{K}$。\n\n2. 使用 Dirichlet 单位定理，推导单位群 $\\mathcal{O}_{K}^{\\times}$ 的秩，并解释在此情况下为何调节子 (regulator) $R_{K}$ 等于 $1$。\n\n3. 利用整数环 $\\mathbb{Z}[i]$ 的结构，确定类数 $h_{K}$ 和判别式的绝对值 $|D_{K}|$。\n\n4. 最后，应用解析类数公式，计算 Dedekind zeta 函数 $\\zeta_{K}(s)$ 在 $s=1$ 处的留数的精确值。将最终答案表示为一个封闭形式的解析表达式。无需四舍五入。", "solution": "该问题涉及高斯数域，定义为 $K=\\mathbb{Q}(i)$，其中 $i$ 是满足 $i^2 = -1$ 的虚数单位。我们将遵循指定的四个步骤来计算 Dedekind zeta 函数 $\\zeta_{K}(s)$ 在 $s=1$ 处的留数。\n\n首先，我们确定 $K$ 的符号。域扩张 $K/\\mathbb{Q}$ 的次数为 $n = [K:\\mathbb{Q}] = 2$，因为 $i$ 在 $\\mathbb{Q}$ 上的最小多项式是 $x^2+1=0$。$K$ 到复数域 $\\mathbb{C}$ 的嵌入由 $i$ 的像决定，而 $i$ 的像必须是此多项式的根。这些根是 $i$ 和 $-i$。这就给出了两个嵌入：恒等映射 $\\sigma_1(a+bi) = a+bi$ 和复共轭映射 $\\sigma_2(a+bi) = a-bi$。实嵌入的数目 $r_1$ 是指满足 $\\sigma_j(K) \\subseteq \\mathbb{R}$ 的嵌入 $\\sigma_j$ 的个数。由于 $i$ 和 $-i$ 都不是实数，所以没有实嵌入，因此 $r_1=0$。共轭复嵌入的对数 $r_2$ 满足 $n = r_1 + 2r_2$。代入已知值，我们有 $2 = 0 + 2r_2$，解得 $r_2=1$。因此，$K$ 的符号为 $(r_1, r_2) = (0,1)$。\n\n接着，我们求 $K$ 中的单位根数目 $w_K$。$K$ 的整数环是高斯整数环，$\\mathcal{O}_K = \\mathbb{Z}[i]$。$K$ 中的单位根 $\\zeta$ 必须是代数整数，因此 $\\zeta \\in \\mathcal{O}_K$。设 $\\zeta = a+bi$，其中 $a,b \\in \\mathbb{Z}$。它还必须满足 $|\\zeta| = 1$。其范数的平方为 $N(\\zeta) = \\zeta\\overline{\\zeta} = a^2+b^2$，对于单位根，该值必须为 $1$。方程 $a^2+b^2=1$ 的整数解为 $(a,b) = (1,0), (-1,0), (0,1), (0,-1)$。这些解对应于元素 $\\{1, -1, i, -i\\}$。这是一个4阶循环群，所以单位根的数目是 $w_K=4$。\n\n第二，我们分析单位群 $\\mathcal{O}_K^{\\times}$ 的结构。Dirichlet 单位定理指出，$\\mathcal{O}_K^{\\times}$ 是一个秩为 $r = r_1+r_2-1$ 的阿贝尔群。使用我们之前计算的符号，其秩为 $r = 0+1-1=0$。秩为 $0$ 意味着单位群的自由部分是平凡的。因此，单位群仅由单位根组成：$\\mathcal{O}_K^{\\times} = \\{1, -1, i, -i\\}$。根据定义，调节子 $R_K$ 是由一组基本单位的绝对值的对数构成的 $r \\times r$ 矩阵的行列式的绝对值。由于秩 $r=0$，该矩阵是一个 $0 \\times 0$ 矩阵。按照惯例，$0 \\times 0$ 矩阵的行列式为 1。因此，调节子为 $R_K=1$。\n\n第三，我们确定类数 $h_K$ 和判别式 $D_K$。整数环 $\\mathcal{O}_K = \\mathbb{Z}[i]$ 是一个唯一分解整环 (UFD)。代数数论的一个基本定理指出，对于整数环，身为唯一分解整环等价于身为一个主理想整环 (PID)。类数 $h_K$ 是理想类群的阶，它衡量了整数环在多大程度上不是一个主理想整环。由于 $\\mathbb{Z}[i]$ 是一个主理想整环，每个理想都是主理想，理想类群是平凡群，因此其阶（即类数）为 $h_K=1$。为了求判别式，我们可以使用二次域 $K = \\mathbb{Q}(\\sqrt{d})$（其中 $d$ 无平方因子）的公式。对于 $K=\\mathbb{Q}(\\sqrt{-1})$，我们有 $d=-1$。由于 $-1 \\equiv 3 \\pmod{4}$，判别式由 $D_K = 4d = 4(-1) = -4$ 给出。其绝对值为 $|D_K|=4$。\n\n最后，我们应用解析类数公式。这个公式将数域的不变量与其 Dedekind zeta 函数在单极点 $s=1$ 处的留数联系起来：\n$$ \\lim_{s \\to 1} (s-1)\\zeta_K(s) = \\frac{2^{r_1}(2\\pi)^{r_2} h_K R_K}{w_K \\sqrt{|D_K|}} $$\n我们已经具备了所有必要的分量：\n- $r_1=0$\n- $r_2=1$\n- $h_K=1$\n- $R_K=1$\n- $w_K=4$\n- $|D_K|=4$\n\n将这些值代入公式：\n$$ \\lim_{s \\to 1} (s-1)\\zeta_K(s) = \\frac{2^0 (2\\pi)^1 \\cdot 1 \\cdot 1}{4 \\sqrt{4}} = \\frac{1 \\cdot 2\\pi}{4 \\cdot 2} = \\frac{2\\pi}{8} = \\frac{\\pi}{4} $$\n因此，$\\zeta_K(s)$ 在 $s=1$ 处的留数为 $\\frac{\\pi}{4}$。这个结果与著名的 Leibniz π 公式有关，因为它等于 $L(1,\\chi_{-4}) = 1 - \\frac{1}{3} + \\frac{1}{5} - \\frac{1}{7} + \\dots$ 的值。", "answer": "$$\\boxed{\\frac{\\pi}{4}}$$", "id": "3022871"}, {"introduction": "要想真正掌握一个概念，一个有效的方法是尝试将它“教”给计算机。这最后一个实践将挑战你把调节子的抽象定义转化为具体的数值算法。你将实现寻找域嵌入 (embedding)、构造对数向量 (logarithmic vector) 以及计算所得单位格 (unit lattice) 体积的过程，从而对调节子的几何本质获得一种操作性的、稳健的理解。[@problem_id:3022842]", "problem": "设 $K$ 是一个次数为 $n$ 的数域，有 $r_1$ 个实嵌入和 $r_2$ 对复嵌入，因此 $n = r_1 + 2 r_2$。Dirichlet 单位定理表明，单位群 $\\mathcal{O}_K^\\times$ 的秩为 $r = r_1 + r_2 - 1$，且调节子 $R_K$ 是在对数嵌入下 $\\mathcal{O}_K^\\times$ 自由部分的 $\\mathbb{Z}$-基的像的余体积。从基本定义和乘积公式出发，设计并实现一个数值稳定的算法来近似计算 $R_K$，步骤如下：\n\n- 通过找到本原元 $\\theta$ (使得 $K = \\mathbb{Q}(\\theta)$) 的定义极小多项式 $f(x) \\in \\mathbb{Z}[x]$ 的所有复根，计算 $K$ 到复数的所有嵌入。将这些嵌入分为 $r_1$ 个实嵌入（虚部为零的根）和 $r_2$ 个复嵌入（由每个复共轭对中的一个根表示）。\n- 对于每个以在 $\\theta$ 处求值的多项式 $p_u(x) \\in \\mathbb{Z}[x]$ 形式给出的单位 $u$，计算其对数嵌入向量 $\\ell(u)$。该向量的坐标定义为：在每个嵌入处计算 $p_u$ 的值，然后取其绝对值的对数，并约定复坐标计算两次。具体而言，对于每个实嵌入 $\\sigma_i$，包含坐标 $\\log |\\sigma_i(u)|$；对于每个复嵌入代表元 $\\sigma_j$，包含坐标 $2 \\log |\\sigma_j(u)|$。\n- 使用数值稳定的过程计算由 $\\ell(u_i)$ 在乘积公式定义的超平面中张成的平行多面体的 $r$ 维体积。乘积公式意味着对于单位而言，$\\ell(u)$ 的坐标之和为 $0$，因此其像位于 $\\mathbb{R}^{r_1 + r_2}$ 中余维数为 $1$ 的超平面内。为减轻数值漂移，需将 $\\ell(u_i)$ 显式地投影到此超平面上，然后通过稳定的 Gram 计算或奇异值计算来计算其 $r$ 维体积。\n- 如果 $r = 0$（即 $r_1 + r_2 - 1 = 0$），则按约定输出 $1$。\n\n输入表示和计算模型：\n\n- 每个域由 $\\theta$ 的极小多项式 $f(x)$ 指定，其形式为按 $x$ 的升幂排列的整数系数列表，即 $[a_0, a_1, \\dots, a_n]$ 代表 $f(x) = a_0 + a_1 x + \\cdots + a_n x^n$。对于首一极小多项式，$a_n = 1$。\n- 每个单位 $u$ 由一个多项式 $p_u(x)$ 指定，其形式为按升幂排列的整数系数列表 $[b_0, b_1, \\dots, b_m]$，代表 $p_u(x) = b_0 + b_1 x + \\cdots + b_m x^m$，且 $u = p_u(\\theta)$。\n- 通过数值近似计算 $f(x)$ 的所有复根来计算嵌入，并为每个复共轭对选择一个代表元（例如，虚部严格为正的根）。\n\n您的程序必须实现此算法，并为以下测试套件生成 $R_K$ 的数值近似值。在所有情况下，请使用自然对数，并确保能稳定地投影到上述超平面。\n\n测试套件：\n\n- 案例 A：$K = \\mathbb{Q}(\\sqrt{2})$，其中 $\\theta$ 是 $f(x) = x^2 - 2$ 的一个根。单位由 $u_1 = 1 + \\theta$ 给出，表示为 $p_{u_1}(x) = x + 1$。\n- 案例 B：$K = \\mathbb{Q}(\\sqrt{3})$，其中 $\\theta$ 是 $f(x) = x^2 - 3$ 的一个根。单位由 $u_1 = 2 + \\theta$ 给出，表示为 $p_{u_1}(x) = x + 2$。\n- 案例 C：$K = \\mathbb{Q}(\\theta)$，其中 $\\theta$ 是 $f(x) = x^2 - x - 1$ 的一个根。单位由 $u_1 = \\theta$ 给出，表示为 $p_{u_1}(x) = x$。\n- 案例 D：$K = \\mathbb{Q}(i)$，其中 $\\theta$ 是 $f(x) = x^2 + 1$ 的一个根。不存在无限阶单位，因此提供一个空的单位列表，并按约定输出 $1$。\n\n输出规格：\n\n- 您的程序应生成单行输出，其中包含案例 A、B、C 和 D 的结果（按此顺序），形式为用方括号括起来的逗号分隔列表，例如 $[r_A,r_B,r_C,r_D]$，其中每个 $r_\\cdot$ 是一个浮点数，代表您的算法计算出的近似调节子 $R_K$。\n\n边界情况和鲁棒性要求：\n\n- 使用数值容差来将根分类为实数或复数，并可靠地对复共轭对进行分组。\n- 在通过 Gram 方法或奇异值方法计算 $r$ 维体积之前，通过将 $\\ell(u_i)$ 显式投影到和为零的超平面来确保数值稳定性。\n- 通过输出 $1$ 来处理 $r=0$ 的边界情况。", "solution": "用户要求设计并实现一个算法来计算数域 $K$ 的调节子。该问题陈述经确认为科学上合理、适定且客观。它基于代数数论的基本原理，并为计算提供了一个清晰、可形式化的过程。\n\n调节子 $R_K$是数域 $K$ 的一个基本不变量。设 $K = \\mathbb{Q}(\\theta)$ 是 $\\mathbb{Q}$ 上的一个 $n$ 次数域，其中 $\\theta$ 是一个极小多项式 $f(x) \\in \\mathbb{Z}[x]$ 的根。数域 $K$ 有 $n$ 个不同的到复数 $\\mathbb{C}$ 的嵌入。这些嵌入可分为 $r_1$ 个实嵌入（$\\sigma: K \\to \\mathbb{R}$）和 $r_2$ 对复共轭嵌入（$\\sigma, \\bar{\\sigma}: K \\to \\mathbb{C} \\setminus \\mathbb{R}$），使得 $n = r_1 + 2r_2$。\n\n根据 Dirichlet 单位定理，$K$ 的整数环的单位群（记作 $\\mathcal{O}_K^\\times$）是一个秩为 $r = r_1 + r_2 - 1$ 的有限生成阿贝尔群。具体来说，$\\mathcal{O}_K^\\times \\cong \\mu(K) \\times \\mathbb{Z}^r$，其中 $\\mu(K)$ 是 $K$ 中的单位根构成的有限群。\n\n调节子是通过对数嵌入定义的，这是一个群同态 $\\ell: \\mathcal{O}_K^\\times \\to \\mathbb{R}^{r_1+r_2}$。我们对嵌入进行排序，首先取 $r_1$ 个实嵌入，然后从 $r_2$ 对复共轭嵌入中各选一个代表元。对于一个单位 $u \\in \\mathcal{O}_K^\\times$，其对数嵌入向量 $\\ell(u)$ 定义为：\n$$\n\\ell(u) = (\\log|\\sigma_1(u)|, \\dots, \\log|\\sigma_{r_1}(u)|, 2\\log|\\sigma_{r_1+1}(u)|, \\dots, 2\\log|\\sigma_{r_1+r_2}(u)|)\n$$\n对于任意单位 $u$，其范数 $\\text{N}_{K/\\mathbb{Q}}(u)$ 为 $\\pm 1$。乘积公式表明 $\\prod_{\\sigma} |\\sigma(u)| = |\\text{N}_{K/\\mathbb{Q}}(u)| = 1$。取对数后，我们发现 $\\ell(u)$ 的各分量之和为零：\n$$\n\\sum_{i=1}^{r_1} \\log|\\sigma_i(u)| + \\sum_{j=1}^{r_2} 2\\log|\\sigma_{r_1+j}(u)| = \\sum_{\\text{all embeddings}} \\log|\\sigma(u)| = 0\n$$\n这意味着像 $\\ell(\\mathcal{O}_K^\\times)$ 位于迹为零的超平面 $H = \\{\\mathbf{x} \\in \\mathbb{R}^{r_1+r_2} \\mid \\sum_{k=1}^{r_1+r_2} x_k = 0\\}$ 内，这是一个维数为 $r=r_1+r_2-1$ 的向量空间。单位群自由部分的像 $\\ell(\\mathbb{Z}^r)$ 在此超平面中形成一个格。\n\n调节子 $R_K$ 定义为这个格在 $H$ 中的余体积。如果 $\\{u_1, \\dots, u_r\\}$ 是 $\\mathcal{O}_K^\\times$ 自由部分的一组基（一组基本单位），那么 $R_K$ 就是由向量 $\\{\\ell(u_1), \\dots, \\ell(u_r)\\}$ 在超平面 $H$ 内张成的平行多面体的 $r$ 维体积。\n\n计算 $R_K$ 的算法步骤如下：\n\n1.  **确定域的符号差：** 给定极小多项式 $f(x)$，其复根通过数值方法计算。这些根对应于 $\\theta$ 在各个嵌入下的值。虚部接近零（在小容差范围内）的根被归类为实根。其余的复根被分组成共轭对。我们计数实根的数量 $r_1$ 和复共轭对的数量 $r_2$。单位群的秩即为 $r = r_1+r_2-1$。如果 $r=0$，按约定调节子为 $1$。\n\n2.  **构造对数嵌入向量：** 对于每个给定的基单位 $u_i = p_{u_i}(\\theta)$，我们首先计算它在每个嵌入下的像。如果 $f(x)$ 的一个根是 $z_j$，则相应的嵌入将 $u_i$ 映射到 $p_{u_i}(z_j)$。这个值通过多项式求值计算。然后，我们使用上述公式构造对数向量 $\\ell(u_i) \\in \\mathbb{R}^{r_1+r_2}$。\n\n3.  **通过投影确保数值稳定性：** 由于有限精度算术，计算出的向量 $\\ell(u_i)$ 的分量之和可能不完全为零。为了强制满足此属性并增强数值稳定性，每个向量 $\\mathbf{v} = \\ell(u_i)$ 都被显式投影到超平面 $H$ 上。投影由 $\\mathbf{v}_{\\text{proj}} = \\mathbf{v} - \\bar{v}\\mathbf{1}$ 给出，其中 $\\bar{v}$ 是 $\\mathbf{v}$ 各分量的平均值，$\\mathbf{1}$ 是全一向量。此变换确保 $\\mathbf{v}_{\\text{proj}}$ 的分量之和恰好为零。\n\n4.  **通过 Gram 行列式计算体积：** 计算由 $r$ 个投影向量集合 $\\{\\mathbf{v}_{1, \\text{proj}}, \\dots, \\mathbf{v}_{r, \\text{proj}}\\}$ 张成的平行多面体的 $r$ 维体积。这些向量位于 $(r_1+r_2)$ 维空间 $\\mathbb{R}^{r_1+r_2}$ 中。一个鲁棒的方法是使用 Gram 行列式。设 $L$ 是一个 $(r_1+r_2) \\times r$ 矩阵，其列是投影后的向量。Gram 矩阵是 $G = L^T L$，这是一个 $r \\times r$ 矩阵。调节子则由其行列式的平方根给出：\n    $$\n    R_K = \\sqrt{\\det(G)} = \\sqrt{\\det(L^T L)}\n    $$\n    该公式等价于计算 $L$ 的奇异值之积，并且是数值稳定的。对于秩为 1 的情况（$r=1$），这简化为计算单个投影向量的欧几里得范数，$R_K = \\sqrt{\\mathbf{v}_{1, \\text{proj}}^T \\mathbf{v}_{1, \\text{proj}}} = ||\\mathbf{v}_{1, \\text{proj}}||_2$。\n\n该过程为问题陈述中定义的调节子近似计算提供了一个完整且数值稳定的算法。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_regulator(poly_f_asc, poly_units_asc):\n    \"\"\"\n    Computes the regulator of a number field K specified by a minimal polynomial\n    and a set of fundamental units.\n\n    Args:\n        poly_f_asc (list): Coefficients of the minimal polynomial f(x) of a\n                           primitive element theta, in ascending powers.\n        poly_units_asc (list): A list of polynomials representing the units.\n                               Each polynomial is a list of coefficients in\n                               ascending powers. u_i = p_i(theta).\n\n    Returns:\n        float: The computed regulator R_K.\n    \"\"\"\n    # Numpy expects coefficients in descending order of powers.\n    poly_f_desc = np.array(poly_f_asc[::-1], dtype=float)\n\n    # Step 1: Compute embeddings and find the signature (r1, r2)\n    roots = np.roots(poly_f_desc)\n\n    real_roots = []\n    complex_reps = []\n    # A tolerance for classifying roots as real\n    tol = 1e-9\n\n    # Sort roots to have a canonical order\n    sorted_roots = sorted(roots, key=lambda z: (z.real, z.imag))\n    \n    processed_roots = set()\n    for z in sorted_roots:\n        if z in processed_roots:\n            continue\n        \n        if abs(z.imag)  tol:\n            real_roots.append(z.real)\n            processed_roots.add(z)\n        elif z.imag > 0: # Take only one from a conjugate pair\n            complex_reps.append(z)\n            processed_roots.add(z)\n            processed_roots.add(z.conjugate())\n\n    r1 = len(real_roots)\n    r2 = len(complex_reps)\n    rank = r1 + r2 - 1\n\n    # Step Check: Handle r=0 case\n    if rank == 0:\n        return 1.0\n\n    # These are the specific roots corresponding to our chosen embeddings\n    embedding_roots = real_roots + complex_reps\n\n    # Step 2: Construct Logarithmic Embedding Vectors\n    log_vectors = []\n    for p_u_asc in poly_units_asc:\n        p_u_desc = np.array(p_u_asc[::-1], dtype=float)\n        log_vec = np.zeros(r1 + r2)\n\n        for i, z in enumerate(embedding_roots):\n            # Evaluate u = p_u(z)\n            u_val = np.polyval(p_u_desc, z)\n            \n            # Take log of absolute value\n            log_abs_u = np.log(np.abs(u_val))\n\n            # Weight by 1 for real, 2 for complex embeddings\n            weight = 1 if i  r1 else 2\n            log_vec[i] = weight * log_abs_u\n        \n        log_vectors.append(log_vec)\n    \n    # Step 3: Projection onto the trace-zero hyperplane for numerical stability\n    projected_vectors = []\n    for v in log_vectors:\n        v_proj = v - np.mean(v)\n        projected_vectors.append(v_proj)\n\n    # Step 4: Compute Volume via Gram Determinant\n    # The number of provided units must match the rank\n    if len(projected_vectors) != rank:\n        raise ValueError(f\"Expected {rank} units for rank {rank} field, but got {len(projected_vectors)}.\")\n\n    # Form the matrix L with projected vectors as columns\n    L = np.array(projected_vectors).T\n\n    # For rank 1, volume is the norm of the single vector\n    if rank == 1:\n        regulator = np.linalg.norm(L[:, 0])\n    else:\n        # For rank > 1, compute Gram determinant\n        gram_matrix = L.T @ L\n        det_G = np.linalg.det(gram_matrix)\n        # Take abs for safety against small negative numerical errors\n        regulator = np.sqrt(abs(det_G))\n\n    return regulator\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        # Case A: K = Q(sqrt(2)), f(x) = x^2 - 2, u1 = 1 + theta\n        ([-2, 0, 1], [[1, 1]]),\n        \n        # Case B: K = Q(sqrt(3)), f(x) = x^2 - 3, u1 = 2 + theta\n        ([-3, 0, 1], [[2, 1]]),\n\n        # Case C: K = Q(theta), f(x) = x^2 - x - 1, u1 = theta\n        ([-1, -1, 1], [[0, 1]]),\n\n        # Case D: K = Q(i), f(x) = x^2 + 1, no infinite order units\n        ([1, 0, 1], []),\n    ]\n\n    results = []\n    for case in test_cases:\n        poly_f, poly_units = case\n        result = compute_regulator(poly_f, poly_units)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3022842"}]}