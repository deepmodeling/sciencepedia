{"hands_on_practices": [{"introduction": "理论学习之后，最好的巩固方式莫过于动手实践。本练习旨在通过对一个具体数字（$n=9$）的所有整数划分进行彻底的分析，来建立对划分组合结构的直观理解。我们将为每一个划分计算由Dyson和Andrews引入的两个关键统计量——秩（rank）与拐（crank），这些统计量在解释拉马努金同余式的深刻规律中扮演着核心角色[@problem_id:3015948]。通过这个过程，你不仅能掌握这些定义的具体计算，还能亲眼见证它们分布的对称性之美。", "id": "3015948", "problem": "设 $n$ 为一个正整数，一个整数 $n$ 的分拆 $\\pi$ 是指一个和为 $n$ 的正整数的有限非递增序列。用 $p(n)$ 表示 $n$ 的分拆数。对于一个分拆 $\\pi$，定义其秩 $\\mathrm{rank}(\\pi)$ 为 $\\pi$ 的最大部分减去 $\\pi$ 的部分数。其曲秩 $\\mathrm{crank}(\\pi)$ 定义如下：记 $\\lambda(\\pi)$为 $\\pi$ 的最大部分，$\\mu(\\pi)$ 为 $\\pi$ 中 $1$ 的个数，$\\nu(\\pi)$ 为 $\\pi$ 中严格大于 $\\mu(\\pi)$ 的部分数。则\n- 如果 $\\mu(\\pi)=0$，令 $\\mathrm{crank}(\\pi)=\\lambda(\\pi)$，\n- 如果 $\\mu(\\pi)>0$，令 $\\mathrm{crank}(\\pi)=\\nu(\\pi)-\\mu(\\pi)$。\n\n对于一个固定的 $n$，定义秩分布多项式和曲秩分布多项式\n$$R_{n}(z)=\\sum_{\\pi\\vdash n} z^{\\mathrm{rank}(\\pi)}\\quad\\text{以及}\\quad C_{n}(z)=\\sum_{\\pi\\vdash n} z^{\\mathrm{crank}(\\pi)},$$\n其中求和遍历 $n$ 的所有分拆 $\\pi$，而 $z$ 是一个形式变量。\n\n从上述定义和 Ferrers 图共轭的基本性质出发，通过枚举 $9$ 的所有分拆，确定每个分拆的 $\\mathrm{rank}(\\pi)$ 和 $\\mathrm{crank}(\\pi)$，并对它们的贡献求和，以此显式计算 $R_{9}(z)$ 和 $C_{9}(z)$。然后，通过识别适当的组合对合并确认系数序列是对称的，来验证当 $n=9$ 时这些分布在 $z\\mapsto z^{-1}$ 变换下的对称性质。将你的最终答案表示为关于 $z$ 的闭式多项式 $R_{9}(z)$ 和 $C_{9}(z)$。", "solution": "本题要求计算整数 $n=9$ 的分拆的秩分布多项式 $R_{9}(z)$ 和曲秩分布多项式 $C_{9}(z)$。此任务需要显式地枚举 $9$ 的所有分拆，然后计算每个分拆的秩和曲秩。\n\n$n=9$ 的分拆数，记为 $p(9)$，是 $30$。$9$ 的分拆如下：\n$1$. $\\pi_1 = (9)$\n$2$. $\\pi_2 = (8,1)$\n$3$. $\\pi_3 = (7,2)$\n$4$. $\\pi_4 = (7,1,1)$\n$5$. $\\pi_5 = (6,3)$\n$6$. $\\pi_6 = (6,2,1)$\n$7$. $\\pi_7 = (6,1,1,1)$\n$8$. $\\pi_8 = (5,4)$\n$9$. $\\pi_9 = (5,3,1)$\n$10$. $\\pi_{10} = (5,2,2)$\n$11$. $\\pi_{11} = (5,2,1,1)$\n$12$. $\\pi_{12} = (5,1,1,1,1)$\n$13$. $\\pi_{13} = (4,4,1)$\n$14$. $\\pi_{14} = (4,3,2)$\n$15$. $\\pi_{15} = (4,3,1,1)$\n$16$. $\\pi_{16} = (4,2,2,1)$\n$17$. $\\pi_{17} = (4,2,1,1,1)$\n$18$. $\\pi_{18} = (4,1,1,1,1,1)$\n$19$. $\\pi_{19} = (3,3,3)$\n$20$. $\\pi_{20} = (3,3,2,1)$\n$21$. $\\pi_{21} = (3,3,1,1,1)$\n$22$. $\\pi_{22} = (3,2,2,2)$\n$23$. $\\pi_{23} = (3,2,2,1,1)$\n$24$. $\\pi_{24} = (3,2,1,1,1,1)$\n$25$. $\\pi_{25} = (3,1,1,1,1,1,1)$\n$26$. $\\pi_{26} = (2,2,2,2,1)$\n$27$. $\\pi_{27} = (2,2,2,1,1,1)$\n$28$. $\\pi_{28} = (2,2,1,1,1,1,1)$\n$29$. $\\pi_{29} = (2,1,1,1,1,1,1,1)$\n$30$. $\\pi_{30} = (1,1,1,1,1,1,1,1,1)$\n\n首先，我们计算秩分布多项式 $R_{9}(z)$。一个分拆 $\\pi$ 的秩定义为 $\\mathrm{rank}(\\pi) = \\lambda(\\pi) - k(\\pi)$，其中 $\\lambda(\\pi)$ 是最大部分，$k(\\pi)$ 是部分数。我们计算 $9$ 的每个分拆的秩：\n$\\mathrm{rank}(\\pi_1) = 9-1=8$\n$\\mathrm{rank}(\\pi_2) = 8-2=6$\n$\\mathrm{rank}(\\pi_3) = 7-2=5$\n$\\mathrm{rank}(\\pi_4) = 7-3=4$\n$\\mathrm{rank}(\\pi_5) = 6-2=4$\n$\\mathrm{rank}(\\pi_6) = 6-3=3$\n$\\mathrm{rank}(\\pi_7) = 6-4=2$\n$\\mathrm{rank}(\\pi_8) = 5-2=3$\n$\\mathrm{rank}(\\pi_9) = 5-3=2$\n$\\mathrm{rank}(\\pi_{10}) = 5-3=2$\n$\\mathrm{rank}(\\pi_{11}) = 5-4=1$\n$\\mathrm{rank}(\\pi_{12}) = 5-5=0$\n$\\mathrm{rank}(\\pi_{13}) = 4-3=1$\n$\\mathrm{rank}(\\pi_{14}) = 4-3=1$\n$\\mathrm{rank}(\\pi_{15}) = 4-4=0$\n$\\mathrm{rank}(\\pi_{16}) = 4-4=0$\n$\\mathrm{rank}(\\pi_{17}) = 4-5=-1$\n$\\mathrm{rank}(\\pi_{18}) = 4-6=-2$\n$\\mathrm{rank}(\\pi_{19}) = 3-3=0$\n$\\mathrm{rank}(\\pi_{20}) = 3-4=-1$\n$\\mathrm{rank}(\\pi_{21}) = 3-5=-2$\n$\\mathrm{rank}(\\pi_{22}) = 3-4=-1$\n$\\mathrm{rank}(\\pi_{23}) = 3-5=-2$\n$\\mathrm{rank}(\\pi_{24}) = 3-6=-3$\n$\\mathrm{rank}(\\pi_{25}) = 3-7=-4$\n$\\mathrm{rank}(\\pi_{26}) = 2-5=-3$\n$\\mathrm{rank}(\\pi_{27}) = 2-6=-4$\n$\\mathrm{rank}(\\pi_{28}) = 2-7=-5$\n$\\mathrm{rank}(\\pi_{29}) = 2-8=-6$\n$\\mathrm{rank}(\\pi_{30}) = 1-9=-8$\n\n秩分布多项式为 $R_{9}(z)=\\sum_{i=1}^{30} z^{\\mathrm{rank}(\\pi_i)}$。我们合并具有相同指数的项：\n- $z^8$ 的系数：$1$\n- $z^6$ 的系数：$1$\n- $z^5$ 的系数：$1$\n- $z^4$ 的系数：$2$\n- $z^3$ 的系数：$2$\n- $z^2$ 的系数：$3$\n- $z^1$ 的系数：$3$\n- $z^0$ 的系数：$4$\n- $z^{-1}$ 的系数：$3$\n- $z^{-2}$ 的系数：$3$\n- $z^{-3}$ 的系数：$2$\n- $z^{-4}$ 的系数：$2$\n- $z^{-5}$ 的系数：$1$\n- $z^{-6}$ 的系数：$1$\n- $z^{-8}$ 的系数：$1$\n所有其他系数均为 $0$。\n因此，该多项式为：\n$R_{9}(z) = z^{8} + z^{6} + z^{5} + 2z^{4} + 2z^{3} + 3z^{2} + 3z + 4 + 3z^{-1} + 3z^{-2} + 2z^{-3} + 2z^{-4} + z^{-5} + z^{-6} + z^{-8}$。\n\n从显式计算中可以明显看出系数的对称性，即 $z^k$ 的系数等于 $z^{-k}$ 的系数。这种对称性是由 Ferrers 图共轭的组合对合所保证的。对于任意分拆 $\\pi$，其共轭分拆 $\\pi'$ 的最大部分等于 $\\pi$ 的部分数，而其部分数等于 $\\pi$ 的最大部分。即 $\\lambda(\\pi')=k(\\pi)$ 且 $k(\\pi')=\\lambda(\\pi)$。因此，$\\mathrm{rank}(\\pi') = \\lambda(\\pi') - k(\\pi') = k(\\pi) - \\lambda(\\pi) = -\\mathrm{rank}(\\pi)$。该对合将秩为 $k$ 的分拆与秩为 $-k$ 的分拆配对。秩为 $0$ 的分拆要么是自共轭的（即在此对合下不动），要么以秩为 $0$ 的共轭对形式出现。\n\n接下来，我们计算曲秩分布多项式 $C_{9}(z)$。曲秩是使用 $\\lambda(\\pi)$（最大部分）、$\\mu(\\pi)$（1的个数）和 $\\nu(\\pi)$（大于 $\\mu(\\pi)$ 的部分数）来定义的。如果 $\\mu(\\pi)=0$，则 $\\mathrm{crank}(\\pi) = \\lambda(\\pi)$。如果 $\\mu(\\pi)>0$，则 $\\mathrm{crank}(\\pi) = \\nu(\\pi) - \\mu(\\pi)$。\n$\\mathrm{crank}(\\pi_1)$: $\\mu(\\pi_1)=0$，所以 $\\mathrm{crank}(\\pi_1)=9$。\n$\\mathrm{crank}(\\pi_2)$: $\\mu(\\pi_2)=1$，部分为 $(8,1)$。$\\nu(\\pi_2)$=大于 $1$ 的部分数，为 $1$。$\\mathrm{crank}(\\pi_2)=1-1=0$。\n$\\mathrm{crank}(\\pi_3)$: $\\mu(\\pi_3)=0$，所以 $\\mathrm{crank}(\\pi_3)=7$。\n$\\mathrm{crank}(\\pi_4)$: $\\mu(\\pi_4)=2$，部分为 $(7,1,1)$。$\\nu(\\pi_4)$=大于 $2$ 的部分数，为 $1$。$\\mathrm{crank}(\\pi_4)=1-2=-1$。\n$\\mathrm{crank}(\\pi_5)$: $\\mu(\\pi_5)=0$，所以 $\\mathrm{crank}(\\pi_5)=6$。\n$\\mathrm{crank}(\\pi_6)$: $\\mu(\\pi_6)=1$，部分为 $(6,2,1)$。$\\nu(\\pi_6)$=大于 $1$ 的部分数，为 $2$。$\\mathrm{crank}(\\pi_6)=2-1=1$。\n$\\mathrm{crank}(\\pi_7)$: $\\mu(\\pi_7)=3$，部分为 $(6,1,1,1)$。$\\nu(\\pi_7)$=大于 $3$ 的部分数，为 $1$。$\\mathrm{crank}(\\pi_7)=1-3=-2$。\n$\\mathrm{crank}(\\pi_8)$: $\\mu(\\pi_8)=0$，所以 $\\mathrm{crank}(\\pi_8)=5$。\n$\\mathrm{crank}(\\pi_9)$: $\\mu(\\pi_9)=1$，部分为 $(5,3,1)$。$\\nu(\\pi_9)$=大于 $1$ 的部分数，为 $2$。$\\mathrm{crank}(\\pi_9)=2-1=1$。\n$\\mathrm{crank}(\\pi_{10})$: $\\mu(\\pi_{10})=0$，所以 $\\mathrm{crank}(\\pi_{10})=5$。\n$\\mathrm{crank}(\\pi_{11})$: $\\mu(\\pi_{11})=2$，部分为 $(5,2,1,1)$。$\\nu(\\pi_{11})$=大于 $2$ 的部分数，为 $1$。$\\mathrm{crank}(\\pi_{11})=1-2=-1$。\n$\\mathrm{crank}(\\pi_{12})$: $\\mu(\\pi_{12})=4$，部分为 $(5,1,1,1,1)$。$\\nu(\\pi_{12})$=大于 $4$ 的部分数，为 $1$。$\\mathrm{crank}(\\pi_{12})=1-4=-3$。\n$\\mathrm{crank}(\\pi_{13})$: $\\mu(\\pi_{13})=1$，部分为 $(4,4,1)$。$\\nu(\\pi_{13})$=大于 $1$ 的部分数，为 $2$。$\\mathrm{crank}(\\pi_{13})=2-1=1$。\n$\\mathrm{crank}(\\pi_{14})$: $\\mu(\\pi_{14})=0$，所以 $\\mathrm{crank}(\\pi_{14})=4$。\n$\\mathrm{crank}(\\pi_{15})$: $\\mu(\\pi_{15})=2$，部分为 $(4,3,1,1)$。$\\nu(\\pi_{15})$=大于 $2$ 的部分数，为 $2$。$\\mathrm{crank}(\\pi_{15})=2-2=0$。\n$\\mathrm{crank}(\\pi_{16})$: $\\mu(\\pi_{16})=1$，部分为 $(4,2,2,1)$。$\\nu(\\pi_{16})$=大于 $1$ 的部分数，为 $3$。$\\mathrm{crank}(\\pi_{16})=3-1=2$。\n$\\mathrm{crank}(\\pi_{17})$: $\\mu(\\pi_{17})=3$，部分为 $(4,2,1,1,1)$。$\\nu(\\pi_{17})$=大于 $3$ 的部分数，为 $1$。$\\mathrm{crank}(\\pi_{17})=1-3=-2$。\n$\\mathrm{crank}(\\pi_{18})$: $\\mu(\\pi_{18})=5$，部分為 $(4,1^5)$。$\\nu(\\pi_{18})$=大于 $5$ 的部分数，为 $0$。$\\mathrm{crank}(\\pi_{18})=0-5=-5$。\n$\\mathrm{crank}(\\pi_{19})$: $\\mu(\\pi_{19})=0$，所以 $\\mathrm{crank}(\\pi_{19})=3$。\n$\\mathrm{crank}(\\pi_{20})$: $\\mu(\\pi_{20})=1$，部分为 $(3,3,2,1)$。$\\nu(\\pi_{20})$=大于 $1$ 的部分数，为 $3$。$\\mathrm{crank}(\\pi_{20})=3-1=2$。\n$\\mathrm{crank}(\\pi_{21})$: $\\mu(\\pi_{21})=3$，部分为 $(3,3,1^3)$。$\\nu(\\pi_{21})$=大于 $3$ 的部分数，为 $0$。$\\mathrm{crank}(\\pi_{21})=0-3=-3$。\n$\\mathrm{crank}(\\pi_{22})$: $\\mu(\\pi_{22})=0$，所以 $\\mathrm{crank}(\\pi_{22})=3$。\n$\\mathrm{crank}(\\pi_{23})$: $\\mu(\\pi_{23})=2$，部分为 $(3,2,2,1,1)$。$\\nu(\\pi_{23})$=大于 $2$ 的部分数，为 $1$。$\\mathrm{crank}(\\pi_{23})=1-2=-1$。\n$\\mathrm{crank}(\\pi_{24})$: $\\mu(\\pi_{24})=4$，部分为 $(3,2,1^4)$。$\\nu(\\pi_{24})$=大于 $4$ 的部分数，为 $0$。$\\mathrm{crank}(\\pi_{24})=0-4=-4$。\n$\\mathrm{crank}(\\pi_{25})$: $\\mu(\\pi_{25})=6$，部分为 $(3,1^6)$。$\\nu(\\pi_{25})$=大于 $6$ 的部分数，为 $0$。$\\mathrm{crank}(\\pi_{25})=0-6=-6$。\n$\\mathrm{crank}(\\pi_{26})$: $\\mu(\\pi_{26})=1$，部分为 $(2^4,1)$。$\\nu(\\pi_{26})$=大于 $1$ 的部分数，为 $4$。$\\mathrm{crank}(\\pi_{26})=4-1=3$。\n$\\mathrm{crank}(\\pi_{27})$: $\\mu(\\pi_{27})=3$，部分为 $(2^3,1^3)$。$\\nu(\\pi_{27})$=大于 $3$ 的部分数，为 $0$。$\\mathrm{crank}(\\pi_{27})=0-3=-3$。\n$\\mathrm{crank}(\\pi_{28})$: $\\mu(\\pi_{28})=5$，部分为 $(2^2,1^5)$。$\\nu(\\pi_{28})$=大于 $5$ 的部分数，为 $0$。$\\mathrm{crank}(\\pi_{28})=0-5=-5$。\n$\\mathrm{crank}(\\pi_{29})$: $\\mu(\\pi_{29})=7$，部分为 $(2,1^7)$。$\\nu(\\pi_{29})$=大于 $7$ 的部分数，为 $0$。$\\mathrm{crank}(\\pi_{29})=0-7=-7$。\n$\\mathrm{crank}(\\pi_{30})$: $\\mu(\\pi_{30})=9$，部分为 $(1^9)$。$\\nu(\\pi_{30})$=大于 $9$ 的部分数，为 $0$。$\\mathrm{crank}(\\pi_{30})=0-9=-9$。\n\n曲秩分布多项式为 $C_{9}(z)=\\sum_{i=1}^{30} z^{\\mathrm{crank}(\\pi_i)}$。我们合并各项：\n- $z^9, z^7, z^6, z^4, z^{-4}, z^{-6}, z^{-7}, z^{-9}$ 的系数：各为 $1$\n- $z^5, z^2, z^{-2}, z^{-5}$ 的系数：各为 $2$\n- $z^3, z, z^{-1}, z^{-3}$ 的系数：各为 $3$\n- $z^0$ 的系数：$2$\n因此，该多项式为：\n$C_{9}(z) = z^{9} + z^{7} + z^{6} + 2z^{5} + z^{4} + 3z^{3} + 2z^{2} + 3z + 2 + 3z^{-1} + 2z^{-2} + 3z^{-3} + z^{-4} + 2z^{-5} + z^{-6} + z^{-7} + z^{-9}$。\n\n同样，通过直接计算证实了系数的对称性。这是曲秩分布多项式的一个普遍性质。其组合证明依赖于由 Andrews 和 Garvan 构造的一个作用于分拆集合上的双射，该双射将曲秩为 $k$ 的分拆映射到曲秩为 $-k$ 的分拆。这个对合的存在证明了 $n$ 的曲秩为 $k$ 的分拆数等于曲秩为 $-k$ 的分拆数，从而保证了 $C_n(z)$ 系数的对称性。\n\n最终导出的多项式是：\n$R_{9}(z) = z^{8} + z^{6} + z^{5} + 2z^{4} + 2z^{3} + 3z^{2} + 3z + 4 + 3z^{-1} + 3z^{-2} + 2z^{-3} + 2z^{-4} + z^{-5} + z^{-6} + z^{-8}$\n$C_{9}(z) = z^{9} + z^{7} + z^{6} + 2z^{5} + z^{4} + 3z^{3} + 2z^{2} + 3z + 2 + 3z^{-1} + 2z^{-2} + 3z^{-3} + z^{-4} + 2z^{-5} + z^{-6} + z^{-7} + z^{-9}$", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\nz^{8} + z^{6} + z^{5} + 2z^{4} + 2z^{3} + 3z^{2} + 3z + 4 + 3z^{-1} + 3z^{-2} + 2z^{-3} + 2z^{-4} + z^{-5} + z^{-6} + z^{-8} & z^{9} + z^{7} + z^{6} + 2z^{5} + z^{4} + 3z^{3} + 2z^{2} + 3z + 2 + 3z^{-1} + 2z^{-2} + 3z^{-3} + z^{-4} + 2z^{-5} + z^{-6} + z^{-7} + z^{-9}\n\\end{pmatrix}\n}\n$$"}, {"introduction": "当$n$增大时，手动枚举所有整数划分变得不切实际。幸运的是，我们可以借助生成函数的强大威力，将组合计数问题转化为代数运算，从而推导出高效的计算方法。本练习的核心任务是实现基于欧拉五边形数定理的递归关系式，这是计算划分函数$p(n)$的标准且高效的算法[@problem_id:3015984]。通过编写代码将这一深刻的数学理论付诸实践，你将能计算出远超手动范围的$p(n)$值，并深刻体会解析数论在算法设计中的力量。", "id": "3015984", "problem": "设 $p(n)$ 表示非负整数 $n$ 的整数分拆数，其中一个分拆是和为 $n$ 的正整数的多重集，且加数的顺序无关紧要。目标是使用从基本原理推导出的递推关系来计算 $p(50)$，并对此计算过程进行高效实现以用于一个小的测试套件。\n\n基本原理：\n- 分拆函数 $p(n)$ 的普通生成函数是无穷乘积\n$$\\sum_{n=0}^{\\infty} p(n) q^n = \\prod_{m=1}^{\\infty} \\frac{1}{1 - q^m},$$\n对于复数 $q$ 且 $|q| < 1$ 时有效。\n- Euler 的五边形数定理指出\n$$\\prod_{m=1}^{\\infty} (1 - q^m) = \\sum_{k=-\\infty}^{\\infty} (-1)^k q^{k(3k-1)/2},$$\n其中指数 $k(3k-1)/2$ 为广义五边形数。\n\n任务：\n1. 严格从上述两个基本事实出发，推导出一个有限递推关系，该关系用先前计算出的值 $p(n-g)$ 来表示 $p(n)$，其中 $g$ 的取值范围是不超过 $n$ 的广义五边形数。推导过程必须通过生成函数的代数变换和系数提取来进行，不得引入任何外部的简便公式。\n2. 设计并实现一个算法，使用推导出的递推关系计算给定非负整数 $n$ 的 $p(n)$。您的算法必须：\n   - 按规范顺序 $1, 2, 5, 7, 12, 15, \\dots$（对应于索引序列 $k = 1, -1, 2, -2, 3, -3, \\dots$）生成广义五边形数，并进行截断，只使用偏移量 $g \\le n$。\n   - 应用推导中隐含的正确交替符号模式。\n   - 使用动态规划在 $O(n \\sqrt{n})$ 时间和 $O(n)$ 空间内计算所有 $0 \\le m \\le n$ 的 $p(m)$。\n   - 采用标准约定 $p(0) = 1$ 以及对于 $n < 0$ 有 $p(n) = 0$。\n3. 除了计算 $p(50)$，还将您的实现应用于测试套件 $n \\in \\{0, 1, 5, 50, 100\\}$。对于测试套件中的每个 $n$，您还必须列出用于计算 $p(n)$ 的广义五边形数偏移量序列 $O(n)$，并按上述顺序排列。\n4. 最终输出格式规范：\n   - 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。\n   - 此顶层列表的每个元素按顺序 $[0, 1, 5, 50, 100]$ 对应一个测试用例。\n   - 对于测试用例值 $n$，该元素必须是双项列表 $[p(n), O(n)]$，其中 $p(n)$ 是一个整数，$O(n)$ 是所使用的广义五边形数偏移量列表（整数）。\n   - 例如，整体结构必须形如\n     $$\\big[[p(0), O(0)], [p(1), O(1)], [p(5), O(5)], [p(50), O(50)], [p(100), O(100)]\\big],$$\n     使用标准列表表示法打印为单行。此问题不涉及任何物理单位、角度单位或百分比。\n\n您的程序必须是自包含的，且不得读取任何输入；它必须直接计算指定的输出，并以所描述的精确格式打印它们。实现语言不受数学规范的限制，但您最终提交的答案必须是能够生成所需单行输出的可执行代码。", "solution": "问题陈述已经过分析并被确定为有效。它在已建立的数论数学领域，特别是整数分拆理论中，具有科学依据。该问题定义明确、客观且自包含，为推导唯一且可验证的解提供了所有必要的定义、基本原理和约束。\n\n任务是为分拆函数 $p(n)$ 推导出一个递推关系，并实现它以计算给定测试套件的 $p(n)$。推导必须从两个基本原理开始：$p(n)$ 的生成函数和 Euler 的五边形数定理。\n\n### 递推关系的推导\n\n我们从提供的两个恒等式开始。分拆函数 $p(n)$ 的普通生成函数由下式给出：\n$$P(q) = \\sum_{n=0}^{\\infty} p(n) q^n = \\prod_{m=1}^{\\infty} \\frac{1}{1 - q^m}$$\nEuler 的五边形数定理为上述表达式的分母提供了无穷乘积展开：\n$$E(q) = \\prod_{m=1}^{\\infty} (1 - q^m) = \\sum_{k=-\\infty}^{\\infty} (-1)^k q^{g_k}$$\n其中 $g_k = \\frac{k(3k-1)}{2}$ 是广义五边形数。这些数由 $k = 0, 1, -1, 2, -2, \\dots$ 生成，得到序列 $0, 1, 2, 5, 7, \\dots$。\n\n从 $P(q)$ 的定义可以看出，$P(q) = 1/E(q)$。因此，它们的乘积必须等于 $1$：\n$$P(q) \\cdot E(q) = 1$$\n代入 $P(q)$ 和 $E(q)$ 的级数展开式，我们得到：\n$$\\left( \\sum_{n=0}^{\\infty} p(n) q^n \\right) \\left( \\sum_{k=-\\infty}^{\\infty} (-1)^k q^{g_k} \\right) = 1$$\n右侧的 $1$ 是一个幂级数，其常数项为 $1$，所有其他系数均为 $0$。左侧的表达式是两个幂级数的柯西乘积。乘积级数中 $q^n$ 的系数，记为 $[q^n](P(q)E(q))$，可以通过对两个级数中 $q$ 的幂次之和为 $n$ 的系数乘积求和得到。\n\n让我们分析结果级数的系数。\n\n对于 $n=0$，系数是两个级数常数项的乘积。从 $\\sum p(n)q^n$ 中，常数项是 $p(0)$。从 $\\sum (-1)^k q^{g_k}$ 中，常数项对应于 $k=0$，即 $(-1)^0 q^{g_0} = (-1)^0 q^0 = 1$。因此，乘积的常数项是 $p(0) \\cdot 1 = p(0)$。将其与右侧的常数项相等，我们得到 $p(0)=1$，这证实了给定的约定。\n\n对于任何整数 $n > 0$，右侧 $q^n$ 的系数为 $0$。左侧的系数由柯西乘积公式给出：\n$$[q^n](P(q)E(q)) = \\sum_{k=-\\infty}^{\\infty} [q^{n-g_k}]\\left(\\sum_{j=0}^{\\infty} p(j)q^j\\right) \\cdot [q^{g_k}]\\left(\\sum_{l=-\\infty}^{\\infty} (-1)^l q^{g_l}\\right)$$\n这可以简化为对来自 Euler 乘积的项求和，将每一项与相应的分拆函数值配对：\n$$[q^n](P(q)E(q)) = \\sum_{k=-\\infty}^{\\infty} (-1)^k p(n - g_k) = 0$$\n这里我们使用约定，对于任何 $m < 0$，$p(m)=0$。由于当 $|k|$ 足够大时，$g_k > n$，因此 $p(n - g_k) = 0$，所以这个和是有限的。\n\n为了得到 $p(n)$ 的递推关系，我们分离出 $k=0$ 的项。$k=0$ 时的五边形数是 $g_0 = 0$。和式中对应的项是 $(-1)^0 p(n - 0) = p(n)$。\n$$p(n) + \\sum_{k \\in \\mathbb{Z}, k \\neq 0} (-1)^k p(n - g_k) = 0$$\n$$p(n) = - \\sum_{k \\in \\mathbb{Z}, k \\neq 0} (-1)^k p(n - g_k) = \\sum_{k \\in \\mathbb{Z}, k \\neq 0} (-1)^{k-1} p(n - g_k)$$\n可以将和式通过配对 $k$ 的正负值来组织：\n$$p(n) = \\sum_{k=1}^{\\infty} (-1)^{k-1} \\left( p(n - g_k) + p(n - g_{-k}) \\right)$$\n其中 $g_k = \\frac{k(3k-1)}{2}$ 且 $g_{-k} = \\frac{-k(3(-k)-1)}{2} = \\frac{k(3k+1)}{2}$。\n写出前几项，我们得到 Euler 的五边形数递推关系：\n$$p(n) = p(n-1) + p(n-2) - p(n-5) - p(n-7) + p(n-12) + p(n-15) - \\dots$$\n\n### 算法设计\n推导出的递推关系适合使用动态规划来高效计算 $p(n)$。我们可以按顺序计算 $m = 1, 2, \\dots, n$ 的 $p(m)$ 值，并将每个结果存储在数组或列表中。\n\n1.  **初始化**：创建一个数据结构，例如大小为 $n+1$ 的数组 `partitions`，用于存储分拆函数的值。初始化 `partitions[0]` 为 $p(0)=1$。\n2.  **迭代**：对 $m$ 从 $1$ 到 $n$ 进行循环以计算 `partitions[m]`。要计算 `partitions[m]`，应用递推关系：\n    $$\\text{partitions}[m] = \\sum_{k=1}^{\\infty} (-1)^{k-1} (\\text{partitions}[m - g_k] + \\text{partitions}[m - g_{-k}])$$\n    当广义五边形数 $g_k$ 或 $g_{-k}$ 超过 $m$ 时，求和终止。\n3.  **五边形数生成**：在 $m$ 的循环内部，为 $k=1, 2, 3, \\dots$ 生成广义五边形数 $g_k$ 和 $g_{-k}$。所需的规范顺序是 $g_1, g_{-1}, g_2, g_{-2}, \\dots$。这对应于序列 $1, 2, 5, 7, 12, 15, \\dots$。对于每个 $k$，我们加上 $p(m-g_k)$ 和 $p(m-g_{-k})$ 的项，并乘以符号 $(-1)^{k-1}$。\n4.  **偏移量列表生成**：对于测试套件中的每个 $n$ 值，我们还必须生成广义五边形数偏移量列表 $O(n)$。该列表包含所有满足偏移量小于或等于 $n$ 的 $g_k$ 和 $g_{-k}$（对于 $k \\ge 1$），按 $g_1, g_{-1}, g_2, g_{-2}, \\dots$ 的顺序排列。\n\n这种动态规划方法确保了每当需要一个值 `partitions[m - g]` 时，它都已在之前的步骤中计算出来了。\n\n### 复杂度分析\n- **时间复杂度**：主要计算涉及一个从 $m=1$ 到 $n$ 的循环。在此循环内部，我们对涉及五边形数的项求和。小于或等于 $m$ 的五边形数的数量与 $\\sqrt{m}$ 成正比，因为 $g_k \\approx \\frac{3k^2}{2}$。因此，总操作数约为 $\\sum_{m=1}^{n} c\\sqrt{m}$，其中 $c$ 是某个常数。这个和的界是积分 $\\int_1^n \\sqrt{x} dx = \\frac{2}{3} n^{3/2}$，因此时间复杂度为 $O(n\\sqrt{n})$。\n- **空间复杂度**：我们需要存储所有 $m \\le n$ 的 $p(m)$ 值。这需要一个大小为 $n+1$ 的数组，因此空间复杂度为 $O(n)$。\n\n设计的算法满足指定的复杂度约束。该实现将计算给定测试套件的分拆数，并按要求格式化输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Computes partition numbers p(n) and related data for a test suite,\n    adhering to the problem's specifications.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [0, 1, 5, 50, 100]\n    n_max = max(test_cases) if test_cases else 0\n\n    # Use a standard Python list for the DP table to support\n    # arbitrary-precision integers, as partition numbers grow very fast.\n    # partitions[i] will store p(i).\n    partitions = [0] * (n_max + 1)\n    \n    # Base case: p(0) = 1 (the empty partition).\n    partitions[0] = 1\n\n    # Fill the DP table using Euler's pentagonal number recurrence.\n    # p(n) = p(n-1) + p(n-2) - p(n-5) - p(n-7) + ...\n    for n in range(1, n_max + 1):\n        k = 1\n        while True:\n            # The sign alternates every two terms, corresponding to (-1)^(k-1).\n            sign = 1 if (k - 1) % 2 == 0 else -1\n            \n            # Generalized pentagonal number for index k\n            g1 = k * (3 * k - 1) // 2\n            if n - g1 < 0:\n                # All subsequent pentagonal numbers will also be > n.\n                break\n            partitions[n] += sign * partitions[n - g1]\n\n            # Generalized pentagonal number for index -k\n            g2 = k * (3 * k + 1) // 2\n            if n - g2 < 0:\n                break\n            partitions[n] += sign * partitions[n - g2]\n            \n            k += 1\n\n    # Prepare results for each test case.\n    results = []\n    for n in test_cases:\n        # Retrieve the pre-computed partition number p(n).\n        p_n = partitions[n]\n        \n        # Generate the list of generalized pentagonal offsets O(n).\n        # These are the pentagonal numbers g <= n, ordered by k=1,-1,2,-2,...\n        offsets = []\n        k = 1\n        while True:\n            g1 = k * (3 * k - 1) // 2\n            if g1 > n:\n                break\n            offsets.append(g1)\n            \n            g2 = k * (3 * k + 1) // 2\n            if g2 > n:\n                break\n            offsets.append(g2)\n            k += 1\n        \n        # The result for one case is the list [p(n), O(n)].\n        result_pair = [p_n, offsets]\n        results.append(result_pair)\n\n    # Format the final output exactly as specified.\n    # The required format is a string representation of a list of lists,\n    # with no spaces.\n    # e.g., [[1,[]],[1,[1]]]\n    # `str(results)` produces \"[<item1>, <item2>]\", including spaces.\n    # By replacing spaces, we match the implied compact format.\n    final_output_string = str(results).replace(\" \", \"\")\n    \n    print(final_output_string)\n\nsolve()\n```"}, {"introduction": "拥有了计算$p(n)$的有效工具后，我们便可以像真正的数学家一样，用它来探索和验证数论中一些最令人惊奇的现象。本练习将引导你聚焦于拉马努金发现的著名同余式，特别是$p(5n+4) \\equiv 0 \\pmod{5}$这一优美的规律[@problem_id:3015946]。通过在模$5$的算术体系下实现划分函数递归，你将能够通过计算来检验这一深刻结论，体验从理论到计算验证的全过程，感受数字世界中隐藏的和谐秩序。", "id": "3015946", "problem": "您需要编写一个完整、可运行的程序，通过从形式幂级数环中的基本恒等式推导并实现一个有根据的递推关系，来计算整数划分函数在一个固定模数下的值。您的实现必须基于一个推导过程，该过程从整数划分函数的生成函数定义以及关于形式幂级数的标准结论出发，且不预设任何预计算的划分函数值。具体而言，请从形式幂级数环中的基本恒等式开始\n$$\n\\sum_{n\\ge 0} p(n)\\,x^n \\;=\\; \\prod_{k\\ge 1}\\frac{1}{1-x^k},\n$$\n其中 $p(n)$ 表示整数 $n$ 的划分数，并推导出一个有效的、有限的递推关系，使您能够计算给定界限内所有 $n$ 的 $p(n)\\bmod m$ 值。您可以使用在此框架内能从生成函数严格推导出的任何经典结论，以及可以在系数为模 $m$ 整数的形式幂级数环内按模 $m$ 进行计算这一事实。\n\n您的程序必须执行以下任务：\n- 计算所有满足 $0\\le n\\le 34$ 的整数 $n$ 的 $p(n)\\bmod 5$ 值。\n- 提取所有满足 $0\\le k\\le 6$ 的整数 $k$ 的子序列 $p(5k+4)\\bmod 5$。\n- 计算验证同余式 $p(5n+4)\\equiv 0 \\pmod{5}$ 是否对所有满足 $0\\le n\\le 6$ 的整数 $n$ 成立。\n\n测试套件和要求的输出：\n- 使用参数 $n_{\\max}=34$ 和 $m=5$。\n- 您的程序必须产生三个结果，以共同检验正确性和边界行为：\n    1. 所有满足 $0\\le n\\le 34$ 的整数 $n$ 的完整余数列表 $[p(n)\\bmod 5]$（该列表长度为 $35$，包含边界情况 $n=0$）。\n    2. 所有满足 $0\\le k\\le 6$ 的整数 $k$ 的提取余数列表 $[p(5k+4)\\bmod 5]$（对应于索引 $4,9,14,19,24,29,34$）。\n    3. 一个布尔值，用以表示第二个列表中的所有项在 $\\mathbb{Z}/5\\mathbb{Z}$ 中是否都等于 $0$。\n\n最终输出格式：\n- 您的程序应生成一行输出，其中包含一个用方括号括起来的、以逗号分隔的列表。第一个元素必须是第 1 项的列表，第二个元素必须是第 2 项的列表，第三个元素必须是第 3 项的布尔值。例如，您的输出应具有以下形式\n$$\n[\\,[\\dots 35\\ \\text{integers}\\dots],\\,[\\dots 7\\ \\text{integers}\\dots],\\,\\text{True or False}\\,].\n$$\n程序不应从标准输入读取任何输入，也不得使用任何外部文件。所有整数应报告为不带任何单位的纯整数。布尔值必须是字面布尔值。", "solution": "问题要求计算整数划分函数 $p(n)$ 在素数模 $m=5$ 下、上限为 $n_{\\max}=34$ 的值。我们需要从 $p(n)$ 在形式幂级数环 $\\mathbb{Z}[[x]]$ 中的生成函数推导出一个有效的计算递推关系。\n\n整数 $n$ 的划分数（记为 $p(n)$）的生成函数由以下恒等式给出：\n$$P(x) = \\sum_{n=0}^{\\infty} p(n)x^n = \\prod_{k=1}^{\\infty} \\frac{1}{1-x^k}$$\n按照惯例，$p(0)=1$，对应于 $0$ 的唯一划分（空划分）。对于 $n<0$，我们定义 $p(n)=0$。\n\n此恒等式在形式幂级数环 $\\mathbb{Z}[[x]]$ 中成立。$P(x)$ 的乘法逆元因此是：\n$$\\Phi(x) = P(x)^{-1} = \\prod_{k=1}^{\\infty} (1-x^k)$$\n划分理论中的一个基本结果，即 Euler 五边形数定理，为 $\\Phi(x)$ 提供了一个级数展开：\n$$\\Phi(x) = \\sum_{j=-\\infty}^{\\infty} (-1)^j x^{\\omega_j} = 1 - x - x^2 + x^5 + x^7 - x^{12} - x^{15} + \\dots$$\n其中指数 $\\omega_j = \\frac{j(3j-1)}{2}$ 是对于 $j \\in \\mathbb{Z}$ 的广义五边形数。\n\n$P(x)$ 与其逆元 $\\Phi(x)$ 的乘积是 $\\mathbb{Z}[[x]]$ 中的乘法单位元，即形式幂级数 $1$：\n$$P(x) \\Phi(x) = \\left(\\sum_{n=0}^{\\infty} p(n)x^n\\right) \\left(\\sum_{j=-\\infty}^{\\infty} (-1)^j x^{\\omega_j}\\right) = 1$$\n对于任何 $n>0$，乘积级数中 $x^n$ 的系数必须为 $0$。使用 Cauchy 乘积公式计算 $x^n$ 的系数（我们记为 $[x^n]$），我们得到：\n$$[x^n](P(x)\\Phi(x)) = \\sum_{j=-\\infty}^{\\infty} \\left( [x^{\\omega_j}]\\Phi(x) \\right) \\cdot \\left( [x^{n-\\omega_j}]P(x) \\right) = \\sum_{j=-\\infty}^{\\infty} (-1)^j p(n-\\omega_j) = 0$$\n这对所有 $n>0$ 成立。$j=0$ 的项对应于 $\\omega_0=0$，得到 $(-1)^0 p(n-0) = p(n)$。因此我们可以从和式中分离出 $p(n)$：\n$$p(n) + \\sum_{j \\in \\mathbb{Z}, j \\neq 0} (-1)^j p(n-\\omega_j) = 0$$\n这就得到了我们期望的 $p(n)$ 的递推关系：\n$$p(n) = -\\sum_{j \\in \\mathbb{Z}, j \\neq 0} (-1)^j p(n-\\omega_j) = \\sum_{j \\in \\mathbb{Z}, j \\neq 0} (-1)^{j-1} p(n-\\omega_j)$$\n为了计算方便，将 $j=k$ 和 $j=-k$（$k \\in \\mathbb{Z}, k \\ge 1$）的项分组。对应的五边形数是 $\\omega_k = \\frac{k(3k-1)}{2}$ 和 $\\omega_{-k} = \\frac{k(3k+1)}{2}$。递推关系变为：\n$$p(n) = \\sum_{k=1}^{\\infty} (-1)^{k-1} \\left( p\\left(n - \\frac{k(3k-1)}{2}\\right) + p\\left(n - \\frac{k(3k+1)}{2}\\right) \\right)$$\n可以更明确地写为：\n$$p(n) = [p(n-1)+p(n-2)] - [p(n-5)+p(n-7)] + [p(n-12)+p(n-15)] - \\dots$$\n其中和式是有限的，因为当 $k<0$ 时 $p(k)=0$。\n\n这个递推关系只涉及整数加减法。因此，所有计算在模一个整数 $m$ 的情况下进行是有效的。具体来说，我们计算 $p(n) \\pmod 5$：\n$$p(n) \\equiv \\sum_{k=1}^{\\infty} (-1)^{k-1} \\left( p\\left(n - \\frac{k(3k-1)}{2}\\right) + p\\left(n - \\frac{k(3k+1)}{2}\\right) \\right) \\pmod 5$$\n\n算法流程如下：\n1.  初始化一个大小为 $n_{\\max}+1=35$ 的数组（例如 `p_mod_m`），用于存储 $p(n) \\bmod 5$ 的值。\n2.  设置基本情况：`p_mod_m[0] = 1`。\n3.  对 $n$ 从 $1$ 到 $34$ 进行迭代。在每次迭代中，使用递推关系计算 `p_mod_m[n]`。每个 $p(n)$ 的计算都使用先前计算出的 $p(k)$ 值，其中 $k < n$。\n4.  计算出所有直至 $p(34) \\pmod 5$ 的值后，形成一个包含这 $35$ 个余数的列表。\n5.  提取第二个列表，其中包含 $k \\in \\{0, 1, \\dots, 6\\}$ 时 $p(5k+4) \\pmod 5$ 的值。这些值对应主列表中的索引 $4, 9, 14, 19, 24, 29, 34$。\n6.  最后，通过检查第二个列表中的所有元素是否都同余于 $0 \\pmod 5$ 来确定一个布尔值。这在计算上验证了 Ramanujan 同余式 $p(5k+4) \\equiv 0 \\pmod 5$ 的一个特例。\n然后将这三个结果对象——完整的余数列表、提取的子列表和布尔验证——格式化为所需的最终输出字符串。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes partition function values p(n) modulo 5 based on a recurrence\n    derived from the generating function, then verifies a Ramanujan congruence.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    n_max = 34\n    m = 5\n\n    # 1. Compute p(n) mod m for 0 <= n <= n_max.\n    \n    # Initialize an array to store p(n) mod m.\n    # We use a numpy array for efficient integer operations.\n    p = np.zeros(n_max + 1, dtype=int)\n    \n    # Base case: p(0) = 1 (the empty partition).\n    p[0] = 1\n\n    # Apply the recurrence relation derived from Euler's Pentagonal Number Theorem.\n    # p(n) = sum_{k=1 to inf} (-1)^(k-1) * [p(n - k(3k-1)/2) + p(n - k(3k+1)/2)]\n    for n in range(1, n_max + 1):\n        val = 0\n        sign = 1\n        k = 1\n        while True:\n            # Generalized pentagonal numbers for k and -k.\n            pent_k = k * (3 * k - 1) // 2\n            pent_minus_k = k * (3 * k + 1) // 2\n            \n            # Add p(n - pent_k) term.\n            if n - pent_k >= 0:\n                val += sign * p[n - pent_k]\n            else:\n                # Since pentagonal numbers are strictly increasing with k,\n                # we can break if n - pent_k is negative.\n                break\n\n            # Add p(n - pent_minus_k) term.\n            if n - pent_minus_k >= 0:\n                val += sign * p[n - pent_minus_k]\n\n            # Alternate the sign for the next pair of terms.\n            sign *= -1\n            k += 1\n        \n        # Store the result modulo m. Python's % operator handles negative\n        # results correctly for modular arithmetic (e.g., -1 % 5 == 4).\n        p[n] = val % m\n\n    # Convert the numpy array of all results to a standard Python list.\n    full_residue_list = p.tolist()\n\n    # 2. Extract the subsequence p(5k+4) mod 5.\n    subsequence_indices = [5 * k + 4 for k in range(7)] # k from 0 to 6\n    extracted_subsequence = [p[i] for i in subsequence_indices]\n\n    # 3. Verify the congruence p(5n+4) = 0 (mod 5).\n    is_congruence_verified = all(x == 0 for x in extracted_subsequence)\n    \n    # Final print statement in the exact required format.\n    # Python's str() for lists and booleans matches the required format.\n    print(f\"[{full_residue_list},{extracted_subsequence},{is_congruence_verified}]\")\n\nsolve()\n\n```"}]}