{"hands_on_practices": [{"introduction": "本实践将引导你回归卡迈克尔函数 $\\lambda(n)$ 的基本原理。你将不再仅仅是套用公式，而是要从第一性原理出发，推导出 $\\lambda(n)$ 是其各素数幂次因子的指数的最小公倍数这一关键性质，该性质是中国剩余定理的直接推论。这个练习旨在锻炼你将抽象的群论与具体的数论计算联系起来的能力。[@problem_id:3020154]", "problem": "设 $n$ 是一个正整数，并令 $\\lambda(n)$ 表示乘法群 $(\\mathbb{Z}/n\\mathbb{Z})^{\\times}$ 的指数，定义为满足对所有 $a \\in (\\mathbb{Z}/n\\mathbb{Z})^{\\times}$ 都有 $a^{m} \\equiv 1 \\pmod{n}$ 成立的最小正整数 $m$。从 $\\lambda(n)$ 作为群指数的基本定义出发，并且仅使用关于 $(\\mathbb{Z}/n\\mathbb{Z})^{\\times}$ 的公认结构性质以及中国剩余定理 (CRT)，证明为什么有限群直积的指数是其各因子群指数的最小公倍数。然后，利用已知的关于素数幂 $p^{k}$ 的 $(\\mathbb{Z}/p^{k}\\mathbb{Z})^{\\times}$ 的结构——包括奇素数幂存在原根的情况以及 $2$ 的幂的特殊情况——计算 $\\lambda(72)$，其中 $72 = 2^{3} \\cdot 3^{2}$。给出 $\\lambda(72)$ 的最终数值。无需四舍五入。", "solution": "该问题要求证明卡迈克尔函数 $\\lambda(n)$ 的一个性质，并应用该性质计算 $\\lambda(72)$。验证过程确认了该问题是适定的、有科学依据的，并且包含了所有必要信息。我们进行完整的解答。\n\n函数 $\\lambda(n)$ 定义为乘法群 $(\\mathbb{Z}/n\\mathbb{Z})^{\\times}$ 的指数。它是满足对所有与 $n$ 互质的整数 $a$ 都有 $a^m \\equiv 1 \\pmod{n}$ 成立的最小正整数 $m$。\n\n首先，我们证明有限群直积的指数公式。设 $G = G_1 \\times G_2 \\times \\dots \\times G_k$ 是有限群的直积。设 $\\lambda(G)$ 是 $G$ 的指数，$\\lambda(G_i)$ 是每个 $G_i$（其中 $i \\in \\{1, 2, \\dots, k\\}$）的指数。\n根据定义，$\\lambda(G)$ 是满足对所有 $g \\in G$ 都有 $g^m = e_G$ 成立的最小正整数 $m$，其中 $e_G$ 是 $G$ 的单位元。$G$ 中的任意元素 $g$ 是一个元组 $(g_1, g_2, \\dots, g_k)$，其中每个 $g_i \\in G_i$。单位元是 $e_G = (e_1, e_2, \\dots, e_k)$，其中 $e_i$ 是 $G_i$ 的单位元。群运算是逐分量进行的。\n条件 $g^m = e_G$ 等价于 $(g_1^m, g_2^m, \\dots, g_k^m) = (e_1, e_2, \\dots, e_k)$。该等式成立当且仅当对所有 $i \\in \\{1, 2, \\dots, k\\}$ 都有 $g_i^m = e_i$。\n\n要使 $m = \\lambda(G)$ 成为 $G$ 的指数，这个条件必须对所有元素 $g \\in G$ 成立。这意味着对于任意给定的 $i$，关系式 $g_i^m = e_i$ 必须对每个 $g_i \\in G_i$ 都成立。根据指数 $\\lambda(G_i)$ 的定义，这意味着 $m$ 必须是 $\\lambda(G_i)$ 的倍数。由于这对所有 $i=1, \\dots, k$ 都必须成立，所以 $m$ 必须是所有指数 $\\lambda(G_1), \\lambda(G_2), \\dots, \\lambda(G_k)$ 的公倍数。\n\n设 $L = \\operatorname{lcm}(\\lambda(G_1), \\lambda(G_2), \\dots, \\lambda(G_k))$。因为 $\\lambda(G)$ 必须是所有 $\\lambda(G_i)$ 的公倍数，所以必然有 $\\lambda(G) \\ge L$。\n\n现在，我们考虑整数 $L$。根据其定义，$L$ 是每个 $\\lambda(G_i)$ 的倍数。因此，对于任何 $i$ 和任何 $g_i \\in G_i$，我们有 $g_i^{\\lambda(G_i)} = e_i$。由于 $L$ 是 $\\lambda(G_i)$ 的倍数，我们可以写成 $L = c_i \\lambda(G_i)$，其中 $c_i$ 是某个整数。那么 $g_i^L = g_i^{c_i \\lambda(G_i)} = (g_i^{\\lambda(G_i)})^{c_i} = (e_i)^{c_i} = e_i$。这对所有 $i=1, \\dots, k$ 都成立。\n因此，对于 $G$ 中的任何元素 $g = (g_1, g_2, \\dots, g_k)$，我们有 $g^L = (g_1^L, g_2^L, \\dots, g_k^L) = (e_1, e_2, \\dots, e_k) = e_G$。\n这表明 $L$ 具有使 $G$ 中所有元素变为单位元的性质。因为 $\\lambda(G)$ 是具有此性质的*最小*正整数，所以必有 $\\lambda(G) \\le L$。\n\n结合两个不等式 $\\lambda(G) \\ge L$ 和 $\\lambda(G) \\le L$，我们得出结论 $\\lambda(G) = L$。也就是说，有限群直积的指数是其各因子群指数的最小公倍数。\n\n接下来，我们将此结果应用于 $(\\mathbb{Z}/n\\mathbb{Z})^{\\times}$。设 $n$ 的素数分解为 $n = p_1^{k_1} p_2^{k_2} \\dots p_r^{k_r}$。根据中国剩余定理，存在一个群同构：\n$$ (\\mathbb{Z}/n\\mathbb{Z})^{\\times} \\cong (\\mathbb{Z}/p_1^{k_1}\\mathbb{Z})^{\\times} \\times (\\mathbb{Z}/p_2^{k_2}\\mathbb{Z})^{\\times} \\times \\dots \\times (\\mathbb{Z}/p_r^{k_r}\\mathbb{Z})^{\\times} $$\n根据我们之前的推导，群 $(\\mathbb{Z}/n\\mathbb{Z})^{\\times}$ 的指数 $\\lambda(n)$ 是各因子群指数 $\\lambda(p_i^{k_i})$ 的最小公倍数。\n$$ \\lambda(n) = \\operatorname{lcm}(\\lambda(p_1^{k_1}), \\lambda(p_2^{k_2}), \\dots, \\lambda(p_r^{k_r})) $$\n\n要计算 $\\lambda(72)$，我们使用其素数分解 $72 = 2^3 \\cdot 3^2$。\n使用上述公式：\n$$ \\lambda(72) = \\operatorname{lcm}(\\lambda(2^3), \\lambda(3^2)) $$\n现在，我们利用这些单位群的已知结构来计算各素数幂因子的值。\n\n1.  对于 $\\lambda(3^2)$：素数是 $p=3$，这是一个奇素数。对于任何奇素数 $p$，群 $(\\mathbb{Z}/p^k\\mathbb{Z})^{\\times}$ 对任何整数 $k \\ge 1$ 都是循环群。循环群的指数等于其阶。$(\\mathbb{Z}/p^k\\mathbb{Z})^{\\times}$ 的阶由欧拉函数给出，即 $\\phi(p^k) = p^k - p^{k-1} = p^{k-1}(p-1)$。\n    因此，$\\lambda(3^2) = \\phi(3^2) = 3^{2-1}(3-1) = 3^1 \\cdot 2 = 6$。\n\n2.  对于 $\\lambda(2^3)$：素数是 $p=2$。$(\\mathbb{Z}/2^k\\mathbb{Z})^{\\times}$ 的结构取决于 $k$。\n    - $\\lambda(2) = 1$\n    - $\\lambda(4) = 2$\n    - 当 $k \\ge 3$ 时，群 $(\\mathbb{Z}/2^k\\mathbb{Z})^{\\times}$ 不是循环群。它同构于一个 $2$ 阶循环群与一个 $2^{k-2}$ 阶循环群的直积，即 $(\\mathbb{Z}/2\\mathbb{Z}) \\times (\\mathbb{Z}/2^{k-2}\\mathbb{Z})$。其指数为 $\\operatorname{lcm}(2, 2^{k-2})$。由于 $k \\ge 3$，我们有 $k-2 \\ge 1$，这意味着 $2^{k-2} \\ge 2$。因此, $\\operatorname{lcm}(2, 2^{k-2}) = 2^{k-2}$。\n    在我们的例子中，$k=3$，满足 $k \\ge 3$。所以我们使用公式 $\\lambda(2^k) = 2^{k-2}$。\n    $\\lambda(2^3) = 2^{3-2} = 2^1 = 2$。\n\n最后，我们合并这些结果：\n$$ \\lambda(72) = \\operatorname{lcm}(\\lambda(2^3), \\lambda(3^2)) = \\operatorname{lcm}(2, 6) $$\n$2$ 的倍数是 $2, 4, 6, 8, \\dots$。$6$ 的倍数是 $6, 12, 18, \\dots$。最小公倍数是 $6$。\n因此，$\\lambda(72) = 6$。", "answer": "$$\n\\boxed{6}\n$$", "id": "3020154"}, {"introduction": "在模 $n$ 乘法群 $(\\mathbb{Z}/n\\mathbb{Z})^{\\times}$ 结构的基础上，本实践将探讨一个重要推论：原根的存在性问题。你将通过证明对于某些合数 $n$，群的指数 $\\lambda(n)$ 严格小于群的阶 $\\phi(n)$，来揭示它们为何永远不可能有原根。这一分析对于理解模算术中循环性的局限至关重要。[@problem_id:3020151]", "problem": "设 $n$ 是一个正整数，令 $\\left(\\mathbb{Z}/n\\mathbb{Z}\\right)^{\\times}$ 表示模 $n$ 的乘法单位群。一个元素 $a \\in \\left(\\mathbb{Z}/n\\mathbb{Z}\\right)^{\\times}$ 的模 $n$ 乘法阶定义为满足 $a^{k} \\equiv 1 \\pmod{n}$ 的最小正整数 $k$。模 $n$ 的原根是 $\\left(\\mathbb{Z}/n\\mathbb{Z}\\right)^{\\times}$ 中的一个元素，其乘法阶等于群的阶 $|\\left(\\mathbb{Z}/n\\mathbb{Z}\\right)^{\\times}|$，因此 $\\left(\\mathbb{Z}/n\\mathbb{Z}\\right)^{\\times}$ 是一个循环群。\n\n仅使用基本定义和公认事实，从第一性原理出发，论证如果 $n$ 至少有两个不同的奇素因子，那么 $\\left(\\mathbb{Z}/n\\mathbb{Z}\\right)^{\\times}$ 不是循环群。你的推理过程必须遵循以下步骤：\n- 应用中国剩余定理（CRT），将 $\\left(\\mathbb{Z}/n\\mathbb{Z}\\right)^{\\times}$ 等同于模素数幂的单位群的直积。\n- 仅使用直积中元素阶的核心群论性质，解释为什么在这种情况下该直积不可能是循环群。\n\n确定满足不存在模 $n$ 的原根，且具有至少两个不同奇素因子的最小合数 $n$，并将该整数作为你的最终答案。无需四舍五入，最终答案必须是单个整数，不带单位。", "solution": "问题陈述经评估有效，因其在数论领域内数学上合理、内容完整且问题明确。我们开始进行解答。\n\n该问题包含两部分：首先，证明如果一个正整数 $n$ 至少有两个不同的奇素因子，那么模 $n$ 的乘法单位群，记作 $(\\mathbb{Z}/n\\mathbb{Z})^{\\times}$，不是循环群。其次，确定符合该条件的最小整数 $n$。\n\n设 $n$ 是一个正整数。假设 $n$ 至少有两个不同的奇素因子。设 $n$ 的素数分解为 $n = p_1^{k_1} p_2^{k_2} \\cdots p_m^{k_m}$，其中 $p_i$ 是不同的素数，$k_i \\ge 1$ 是整数。根据所述假设，这些素因子中至少有两个，例如 $p_1$ 和 $p_2$，是奇数。\n\n第一步是应用中国剩余定理 (CRT)。CRT 建立了 $\\mathbb{Z}/n\\mathbb{Z}$ 与环的直积 $\\mathbb{Z}/p_i^{k_i}\\mathbb{Z}$ 之间的一个环同构：\n$$\n\\mathbb{Z}/n\\mathbb{Z} \\cong \\mathbb{Z}/p_1^{k_1}\\mathbb{Z} \\times \\mathbb{Z}/p_2^{k_2}\\mathbb{Z} \\times \\cdots \\times \\mathbb{Z}/p_m^{k_m}\\mathbb{Z}\n$$\n该同构限制在它们各自的单位群上，产生一个群同构：\n$$\n(\\mathbb{Z}/n\\mathbb{Z})^{\\times} \\cong (\\mathbb{Z}/p_1^{k_1}\\mathbb{Z})^{\\times} \\times (\\mathbb{Z}/p_2^{k_2}\\mathbb{Z})^{\\times} \\times \\cdots \\times (\\mathbb{Z}/p_m^{k_m}\\mathbb{Z})^{\\times}\n$$\n要使 $(\\mathbb{Z}/n\\mathbb{Z})^{\\times}$ 是循环群，它必须包含一个阶等于该群的阶 $|\\left(\\mathbb{Z}/n\\mathbb{Z}\\right)^{\\times}|$ 的元素。该群的阶由欧拉函数$\\phi(n)$ (Euler's totient function) 给出。由于 $\\phi$ 函数对于互素参数的积性性质，我们有：\n$$\n|\\left(\\mathbb{Z}/n\\mathbb{Z}\\right)^{\\times}| = \\phi(n) = \\phi(p_1^{k_1}) \\phi(p_2^{k_2}) \\cdots \\phi(p_m^{k_m})\n$$\n直积中第 $i$ 个群的阶为 $|\\left(\\mathbb{Z}/p_i^{k_i}\\mathbb{Z}\\right)^{\\times}| = \\phi(p_i^{k_i}) = p_i^{k_i-1}(p_i-1)$。\n\n考虑任意元素 $a \\in (\\mathbb{Z}/n\\mathbb{Z})^{\\times}$。在 CRT 同构下，该元素对应一个元组 $(a_1, a_2, \\dots, a_m)$，其中 $a_i \\equiv a \\pmod{p_i^{k_i}}$。$a$ 的模 $n$ 乘法阶，记作 $\\operatorname{ord}_n(a)$，由其在直积中各分量的阶的最小公倍数给出：\n$$\n\\operatorname{ord}_n(a) = \\operatorname{lcm}(\\operatorname{ord}_{p_1^{k_1}}(a_1), \\operatorname{ord}_{p_2^{k_2}}(a_2), \\dots, \\operatorname{ord}_{p_m^{k_m}}(a_m))\n$$\n根据拉格朗日定理 (Lagrange's theorem)，有限群中任意元素的阶必须整除群的阶。因此，对于每个分量 $a_i$，其阶必须整除相应群的阶：\n$$\n\\operatorname{ord}_{p_i^{k_i}}(a_i) \\mid \\phi(p_i^{k_i})\n$$\n这意味着 $(\\mathbb{Z}/n\\mathbb{Z})^{\\times}$ 中任意元素 $a$ 的阶必须整除各分量群的阶的最小公倍数：\n$$\n\\operatorname{ord}_n(a) \\mid \\operatorname{lcm}(\\phi(p_1^{k_1}), \\phi(p_2^{k_2}), \\dots, \\phi(p_m^{k_m}))\n$$\n$(\\mathbb{Z}/n\\mathbb{Z})^{\\times}$ 中元素可能的最大阶被称为 Carmichael 函数 $\\lambda(n)$。\n\n现在，我们使用核心假设，即 $n$ 至少有两个不同的奇素因子，例如 $p_1$ 和 $p_2$。\n对于任何奇素数 $p$，整数 $p-1$ 是偶数。因此，群 $(\\mathbb{Z}/p^k\\mathbb{Z})^{\\times}$ 的阶，即 $\\phi(p^k) = p^{k-1}(p-1)$，对于任何 $k \\ge 1$ 都是一个偶数。\n因此，$\\phi(p_1^{k_1})$ 和 $\\phi(p_2^{k_2})$ 都是偶整数。设 $\\phi(p_1^{k_1}) = 2u$ 和 $\\phi(p_2^{k_2}) = 2v$，其中 $u$ 和 $v$ 是某个整数。\n\n$(\\mathbb{Z}/n\\mathbb{Z})^{\\times}$ 中任意元素可能的最大阶是 $\\lambda(n) = \\operatorname{lcm}(\\phi(p_1^{k_1}), \\dots, \\phi(p_m^{k_m}))$。\n由于 $\\operatorname{lcm}$ 函数的参数中至少有两个，即 $\\phi(p_1^{k_1})$ 和 $\\phi(p_2^{k_2})$，是偶数，它们的最小公倍数必定严格小于它们的乘积。具体来说，对于任意两个正偶数 $x$ 和 $y$，$\\operatorname{lcm}(x, y) = \\frac{xy}{\\gcd(x, y)}$。由于 $\\gcd(x, y) \\ge 2$，我们有 $\\operatorname{lcm}(x, y) \\le \\frac{xy}{2}$。\n这个性质可以推广到 $\\lambda(n)$ 的所有参数列表：\n$$\n\\lambda(n) = \\operatorname{lcm}(\\phi(p_1^{k_1}), \\phi(p_2^{k_2}), \\dots, \\phi(p_m^{k_m})) \\le \\frac{\\phi(p_1^{k_1})\\phi(p_2^{k_2})\\cdots\\phi(p_m^{k_m})}{2}\n$$\n如果集合中至少有两个偶数，则不等式是严格的，而我们的情况正是如此。\n群 $(\\mathbb{Z}/n\\mathbb{Z})^{\\times}$ 的阶是 $\\phi(n) = \\phi(p_1^{k_1})\\phi(p_2^{k_2})\\cdots\\phi(p_m^{k_m})$。\n因此，我们已经确定了群中任意元素可能的最大阶是\n$$\n\\lambda(n) \\le \\frac{1}{2}\\phi(n)  \\phi(n)\n$$\n由于 $(\\mathbb{Z}/n\\mathbb{Z})^{\\times}$ 中任意元素的阶至多为 $\\lambda(n)$，而 $\\lambda(n)$ 严格小于群的阶 $\\phi(n)$，所以没有元素的阶能等于群的阶。根据定义，这意味着 $(\\mathbb{Z}/n\\mathbb{Z})^{\\times}$ 不可能是循环群，因此没有原根。证明完毕。\n\n对于问题的第二部分，我们必须找到具有至少两个不同奇素因子的最小合数 $n$。要构造这样的最小整数，我们应该使用最小的可能不同奇素因子，以及它们的最低可能次幂。奇素数按升序排列为 $3, 5, 7, 11, \\dots$。最小的两个不同奇素数是 $3$ 和 $5$。由至少两个不同奇素因子构成的最小整数 $n$ 是最小的两个奇素数的乘积，每个的幂次都为 $1$。\n因此，该整数是：\n$$\nn = 3 \\times 5 = 15\n$$\n这个数 $n=15$ 是合数。它的素因子是 $3$ 和 $5$，它们是不同的奇数。任何其他具有两个不同奇素因子的整数，例如 $3 \\times 7 = 21$ 或 $5 \\times 7 = 35$，都会更大。任何具有多于两个不同奇素因子（例如 $3 \\times 5 \\times 7 = 105$）或这些素数的更高次幂（例如 $3^2 \\times 5 = 45$）的整数也都将大于 $15$。\n因此，符合该条件的最小整数是 $15$。\n作为检验，我们考察 $(\\mathbb{Z}/15\\mathbb{Z})^{\\times}$。其阶为 $\\phi(15) = \\phi(3)\\phi(5) = (3-1)(5-1) = 2 \\times 4 = 8$。\n该群同构于 $(\\mathbb{Z}/3\\mathbb{Z})^{\\times} \\times (\\mathbb{Z}/5\\mathbb{Z})^{\\times}$。这些分量群的阶分别是 $\\phi(3)=2$ 和 $\\phi(5)=4$。两者都是偶数。元素的最大阶是 $\\lambda(15) = \\operatorname{lcm}(\\phi(3), \\phi(5)) = \\operatorname{lcm}(2, 4) = 4$。由于 $\\lambda(15)=4  \\phi(15)=8$，该群不是循环群，这证实了我们的证明。", "answer": "$$\\boxed{15}$$", "id": "3020151"}, {"introduction": "最后的这项实践通过探讨迷人的卡迈克尔数，将理论与计算应用联系起来。这些合数满足费马素性检验，因而伪装成素数，这一行为可以通过与卡迈克尔函数 $\\lambda(n)$ 密切相关的科塞尔特判别法得到完美解释。你的任务是设计并论证一个算法，它不仅能识别这些“伪素数”，还能计算 $\\lambda(n)$，从而将深刻的理论洞见转化为实用的工具。[@problem_id:3013818]", "problem": "给定一个整数 $n$，目标是设计并实现一个基于基本原理和经过充分检验的数论事实的算法，以判断 $n$ 是否为卡迈克尔数。该算法必须基于对 $n$ 的因数分解并调用 Korselt 判别法，并且还必须计算 Carmichael 函数 $\\lambda(n)$。您必须论证算法的正确性，并根据其比特长度分析其计算复杂度。本问题要求算法从以下基础推导而来：欧拉函数 $\\phi(n)$ 的定义、Carmichael 函数 $\\lambda(n)$ 作为模 $n$ 乘法单位群的指数的定义、通过中国剩余定理（CRT）得到的乘法群 $(\\mathbb{Z}/n\\mathbb{Z})^\\times$ 的结构，以及作为卡迈克尔数的一个经过充分检验的刻画的 Korselt 判别法。在您的解法中，必须从这些基础出发推导和论证算法步骤，而不是使用问题陈述中的任何快捷公式。\n\n设计要求：\n- 定义并实现一个函数，该函数使用 Korselt 判别法和 $n$ 的素数分解来判断给定的整数 $n$ 是否为卡迈克尔数。\n- 定义并实现一个函数，该函数使用 $n$ 的素数幂分解来计算通用 $n$ 的 Carmichael 函数 $\\lambda(n)$。\n- 从基本原理出发，论证这两个函数的正确性，这些原理始于 $\\phi(n)$、$\\lambda(n)$ 的定义、通过 CRT 得到的 $(\\mathbb{Z}/n\\mathbb{Z})^\\times$ 的结构，以及 Korselt 判别法的陈述。\n- 分析您方法的时间复杂度，以比特长度 $b = \\lceil \\log_2 n \\rceil$ 来衡量，包括：\n  - 用于因数分解的素性检验的复杂度。\n  - 使用标准算法进行因数分解本身的复杂度。\n  - 从因数分解计算 $\\lambda(n)$ 和检查 Korselt 判别法的整除条件的复杂度。\n\n算法约束：\n- 您的程序必须完全自包含，除了必需的最终输出行外，不执行任何输入/输出。\n- 对于边界情况的处理，您的函数必须正确处理 $n = 1$、素数 $n$、非无平方因子的合数 $n$ 和无平方因子的合数 $n$。\n\n测试套件：\n- 将您的实现应用于以下整数列表：\n  - $n \\in \\{1, 2, 15, 512, 561, 1105, 1729, 2465, 6601, 8911, 41041, 294409\\}$。\n- 该集合包含一般情况、小素数、单位情况、非无平方因子的合数值以及几个已知的卡迈克尔数，以测试覆盖率。\n\n最终输出格式：\n- 对于指定顺序中的每个测试用例 $n$，产生一个形式为 $[\\text{is\\_carmichael}, \\lambda(n)]$ 的结果，其中 $\\text{is\\_carmichael}$ 是一个布尔值，$\\lambda(n)$ 是一个整数。\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表，例如：\n  - $[[\\text{True}, 80],[\\text{False}, 1],\\dots]$。\n- 除了这单行文本外，输出中不能出现任何其他文本或字符。", "solution": "目标是构建并实现一个算法，以判断一个正整数 $n$ 是否为卡迈克尔数，并计算 Carmichael 函数 $\\lambda(n)$。推导过程必须基于数论的基本原理，特别是欧拉函数 $\\phi(n)$、Carmichael 函数 $\\lambda(n)$ 的定义、模 $n$ 整数乘法群 $(\\mathbb{Z}/n\\mathbb{Z})^\\times$ 的结构，以及 Korselt 判别法。\n\n### 基本原理\n\n设 $n$ 是一个正整数。在 $\\{1, 2, \\dots, n\\}$ 中与 $n$ 互质的整数集合，在模 $n$ 乘法下构成一个群，记为 $(\\mathbb{Z}/n\\mathbb{Z})^\\times$。\n\n1.  **欧拉函数$\\phi(n)$**：此函数计算小于等于 $n$ 且与 $n$ 互质的正整数的个数。其定义为 $\\phi(n) = |\\{k \\in \\{1, \\dots, n\\} : \\gcd(k, n) = 1\\}|$。从根本上说，$\\phi(n)$ 是群 $(\\mathbb{Z}/n\\mathbb{Z})^\\times$ 的阶。\n\n2.  **Carmichael 函数, $\\lambda(n)$**：此函数定义为最小的正整数 $m$，使得对于所有与 $n$ 互质的整数 $a$，都有 $a^m \\equiv 1 \\pmod{n}$。在群论术语中，$\\lambda(n)$ 是群 $(\\mathbbZ/n\\mathbb{Z})^\\times$ 的指数，即群中所有元素阶的最小公倍数。根据 Lagrange 定理，任何元素的阶都必须整除群的阶，因此 $\\lambda(n)$ 必须整除 $\\phi(n)$。对于 $n=1$，我们定义 $\\lambda(1)=1$。\n\n3.  **中国剩余定理 (CRT)**：如果 $n$ 的素数分解为 $n = p_1^{k_1} p_2^{k_2} \\cdots p_r^{k_r}$，则 CRT 蕴含一个群同构：\n    $$ (\\mathbb{Z}/n\\mathbb{Z})^\\times \\cong (\\mathbb{Z}/p_1^{k_1}\\mathbb{Z})^\\times \\times (\\mathbb{Z}/p_2^{k_2}\\mathbb{Z})^\\times \\times \\cdots \\times (\\mathbb{Z}/p_r^{k_r}\\mathbb{Z})^\\times $$\n    群的直积的指数是各个群指数的最小公倍数（lcm）。因此，\n    $$ \\lambda(n) = \\operatorname{lcm}(\\lambda(p_1^{k_1}), \\lambda(p_2^{k_2}), \\ldots, \\lambda(p_r^{k_r})) $$\n\n4.  **卡迈克尔数**：一个合数 $n$ 是卡迈克尔数，如果对于所有与 $n$ 互质的整数 $a$，它都满足同余式 $a^{n-1} \\equiv 1 \\pmod{n}$。此条件等价于 $\\lambda(n)$ 整除 $n-1$。\n\n5.  **Korselt 判别法 (1899)**：一个合数 $n  1$ 是卡迈克尔数，当且仅当 (i) $n$ 是无平方因子的数，并且 (ii) 对于 $n$ 的每个素数因子 $p$，都有 $p-1$ 整除 $n-1$。\n\n### 计算 $\\lambda(n)$ 的算法\n\n要创建计算 $\\lambda(n)$ 的算法，我们首先需要 $\\lambda(p^k)$ 的显式公式。这些公式源自群 $(\\mathbb{Z}/p^k\\mathbb{Z})^\\times$ 的结构。\n-   对于奇素数 $p$，群 $(\\mathbb{Z}/p^k\\mathbb{Z})^\\times$ 是一个阶为 $\\phi(p^k) = p^k - p^{k-1} = p^{k-1}(p-1)$ 的循环群。循环群的指数是其阶，所以 $\\lambda(p^k) = \\phi(p^k) = p^{k-1}(p-1)$。\n-   对于 $p=2$，群结构有所不同：\n    -   对于 $k=1$, $(\\mathbb{Z}/2\\mathbb{Z})^\\times$ 是平凡群，所以 $\\lambda(2) = 1$。\n    -   对于 $k=2$, $(\\mathbb{Z}/4\\mathbb{Z})^\\times \\cong C_2$，所以 $\\lambda(4) = 2$。\n    -   对于 $k \\ge 3$, $(\\mathbb{Z}/2^k\\mathbb{Z})^\\times \\cong C_2 \\times C_{2^{k-2}}$。其指数是 $\\operatorname{lcm}(2, 2^{k-2}) = 2^{k-2}$。\n\n这产生了以下计算 $\\lambda(n)$ 的算法：\n\n1.  处理基本情况：如果 $n=1$，返回 $1$。\n2.  求 $n$ 的素数幂分解：$n = p_1^{k_1} p_2^{k_2} \\cdots p_r^{k_r}$。\n3.  对于每个因子 $p_i^{k_i}$，计算 $\\lambda(p_i^{k_i})$：\n    -   如果 $p_i$ 是奇素数，其值为 $p_i^{k_i-1}(p_i-1)$。\n    -   如果 $p_i=2$ 且 $k_i=1$，其值为 $1$。\n    -   如果 $p_i=2$ 且 $k_i=2$，其值为 $2$。\n    -   如果 $p_i=2$ 且 $k_i \\ge 3$，其值为 $2^{k_i-2}$。\n4.  计算上一步中获得的所有值的最小公倍数。这就是 $\\lambda(n)$。\n\n### 卡迈克尔数识别算法\n\n此算法是 Korselt 判别法的直接实现，其正确性由 $\\lambda(n)$ 的性质所保证。\n\n**Korselt 判别法的论证：**\n一个合数 $n$ 是卡迈克尔数，当且仅当 $\\lambda(n)$ 整除 $n-1$。\n\n首先，我们证明一个卡迈克尔数必须是无平方因子的。假设 $n$ 不是无平方因子的，那么对于某个素数 $p$ 和指数 $k \\ge 2$，有 $p^k | n$。\n-   情况 1：$p$ 是一个奇素数。那么 $\\lambda(n)$ 必须是 $\\lambda(p^k) = p^{k-1}(p-1)$ 的倍数。如果 $\\lambda(n) | n-1$，那么 $p^{k-1}(p-1) | n-1$。由于 $p$ 整除 $p^{k-1}$，所以必然有 $p | n-1$。然而，由于 $p | n$，我们有 $n-1 \\equiv -1 \\pmod{p}$，所以 $p$ 不可能整除 $n-1$。这是一个矛盾。\n-   情况 2：$p=2$ 且 $k \\ge 2$。那么 $4 | n$。\n    -   如果 $k=2$，则 $n=4m$。$\\lambda(n)$ 是 $\\lambda(4)=2$ 的倍数。$n-1=4m-1$ 是奇数，所以 $\\lambda(n)$ 不可能整除 $n-1$。\n    -   如果 $k \\ge 3$，$\\lambda(n)$ 是 $\\lambda(2^k)=2^{k-2}$ 的倍数。类似的矛盾也会出现。\n因此，$n$ 必须是无平方因子的，即 $n = p_1 p_2 \\cdots p_r$，其中 $p_i$ 是不同的素数。\n\n对于一个无平方因子的 $n$，其分解为 $n = p_1 \\cdots p_r$。$\\lambda(n)$ 的公式简化为：\n$$ \\lambda(n) = \\operatorname{lcm}(\\lambda(p_1), \\dots, \\lambda(p_r)) = \\operatorname{lcm}(p_1-1, \\dots, p_r-1) $$\n条件 $\\lambda(n) | n-1$ 变为 $\\operatorname{lcm}(p_1-1, \\dots, p_r-1) | n-1$。这当且仅当对于所有的 $i=1, \\dots, r$，都有 $(p_i-1) | (n-1)$。至此，论证完毕。\n\n算法如下：\n\n1.  根据定义，卡迈克尔数是合数。如果 $n \\le 1$ 或 $n$ 是素数，它就不是卡迈克尔数。\n2.  求 $n$ 的素数分解。将因子及其幂存储起来，例如，存储在一个字典 $\\{p_i: k_i\\}$ 中。\n3.  检查 $n$ 是否是无平方因子的：遍历幂 $k_i$。如果任何 $k_i  1$，$n$ 就不是无平方因子的。返回 `False`。（注意：一个合数必须至少有两个不同的素数因子或一个平方素数因子。步骤 1 中的素性检验和此检查覆盖了所有非合数情况或非无平方因子的合数情况）。\n4.  检查整除条件：对于每个不同的素数因子 $p_i$，验证 $(p_i - 1)$ 是否整除 $(n-1)$。如果此条件对任何 $p_i$ 不成立，返回 `False`。\n5.  如果 $n$ 是合数、无平方因子，并通过了所有整除检查，那么它就是一个卡迈克尔数。返回 `True`。\n\n### 计算复杂度分析\n\n设 $n$ 的比特长度为 $b = \\lceil \\log_2 n \\rceil$。\n\n1.  **素性检验**：对于 $n$ 的初始检查，Miller-Rabin 检验是高效的。对于比特长度为 $b$ 的输入，进行 $k$ 轮测试需要 $O(k \\cdot b^3)$ 的时间。存在确定性变体，其复杂度是 $b$ 的多项式。\n\n2.  **整数分解**：这是计算瓶颈。一个朴素的试除法算法需要 $O(\\sqrt{n}) = O(2^{b/2})$ 的时间。更先进的算法如 Pollard's rho 算法的启发式复杂度为 $O(n^{1/4}) = O(2^{b/4})$ polylog($n$)。当前最先进的算法，如一般数域筛选法（GNFS），是亚指数的，其复杂度约为 $\\exp(c \\cdot b^{1/3} (\\log b)^{2/3})$。我们将因数分解的复杂度记为 $T_{\\text{factor}}(b)$。\n\n3.  **因数分解后的步骤**：一旦知道了因数分解 $n = p_1^{k_1} \\cdots p_r^{k_r}$，剩下的计算是高效的。不同素数因子的数量 $r$ 受限于 $O(b / \\log b)$。\n    -   **计算 $\\lambda(n)$**：我们计算 $r$ 个 $\\lambda(p_i^{k_i})$ 的值，然后求它们的最小公倍数。每个 `lcm` 操作涉及一次 `gcd` 计算，使用欧几里得算法需要 $O(b^2)$ 的时间。计算 $r$ 个数字的最小公倍数的总时间是 $O(r \\cdot b^2) = O(b^3 / \\log b)$。\n    -   **检查 Korselt 判别法**：检查 $n$ 是否是无平方因子的需要 $O(r)$ 时间。检查 $r$ 个整除条件 $(p_i-1) | (n-1)$ 涉及 $r$ 次模除法，每次需要 $O(b^2)$ 时间。总时间是 $O(r \\cdot b^2) = O(b^3 / \\log b)$。\n\n总体复杂度由因数分解步骤主导：$O(\\text{Total}) \\approx T_{\\text{factor}}(b)$。对于测试集中的数字，试除法和基本的 Miller-Rabin 素性检验的组合已经足够。", "answer": "```python\nimport math\n\ndef solve():\n    \"\"\"\n    Main function to process test cases for Carmichael numbers and lambda function.\n    \"\"\"\n\n    def power(base, exp, mod):\n        \"\"\"\n        Computes (base^exp) % mod using modular exponentiation.\n        \"\"\"\n        res = 1\n        base %= mod\n        while exp > 0:\n            if exp % 2 == 1:\n                res = (res * base) % mod\n            base = (base * base) % mod\n            exp //= 2\n        return res\n\n    def is_prime(n):\n        \"\"\"\n        Miller-Rabin primality test. It is deterministic for the range of numbers\n        in the test suite.\n        \"\"\"\n        if n  2:\n            return False\n        if n == 2 or n == 3:\n            return True\n        if n % 2 == 0 or n % 3 == 0:\n            return False\n        \n        # Based on deterministic Miller-Rabin bases, for n  1,373,653,\n        # it is sufficient to test a = {2, 3}. All test cases are below this.\n        # The largest test case is 294409.\n        d = n - 1\n        s = 0\n        while d % 2 == 0:\n            d //= 2\n            s += 1\n        \n        # Test with bases sufficient for the test suite range\n        for a in [2, 3, 5, 7, 11, 13, 17]:\n            if a >= n:\n                break\n            x = power(a, d, n)\n            if x == 1 or x == n - 1:\n                continue\n            for _ in range(s - 1):\n                x = power(x, 2, n)\n                if x == n - 1:\n                    break\n            else:\n                return False\n        return True\n\n    def get_prime_factorization(n):\n        \"\"\"\n        Computes the prime factorization of n as a dictionary {p: k}.\n        Uses trial division, sufficient for the test case sizes.\n        \"\"\"\n        if n = 1:\n            return {}\n        \n        factors = {}\n        # Handle factors of 2\n        while n % 2 == 0:\n            factors[2] = factors.get(2, 0) + 1\n            n //= 2\n        \n        # Handle odd factors\n        d = 3\n        while d * d = n:\n            while n % d == 0:\n                factors[d] = factors.get(d, 0) + 1\n                n //= d\n            d += 2\n            \n        if n > 1:\n            factors[n] = factors.get(n, 0) + 1\n            \n        return factors\n\n    def compute_lambda(n, factors):\n        \"\"\"\n        Computes the Carmichael function lambda(n) using its prime factorization.\n        \"\"\"\n        if n == 1:\n            return 1\n\n        if not factors:\n             # This case handles n > 1 with no computed factors, implying n is prime.\n             # Re-checking primality is redundant if factors is always computed first.\n             # If `n` is prime, `factors` will be `{n: 1}`.\n             # This branch is for theoretical completeness.\n             return n - 1\n\n        lambda_vals = []\n        for p, k in factors.items():\n            if p == 2:\n                if k == 1:\n                    lambda_vals.append(1)\n                elif k == 2:\n                    lambda_vals.append(2)\n                else: # k >= 3\n                    lambda_vals.append(2**(k - 2))\n            else: # p is an odd prime\n                lambda_vals.append((p - 1) * (p**(k - 1)))\n        \n        if not lambda_vals:\n            return 1 # Should only happen for n=1\n            \n        res = lambda_vals[0]\n        for i in range(1, len(lambda_vals)):\n            # lcm(a, b) = (|a*b|) // gcd(a, b)\n            res = (res * lambda_vals[i]) // math.gcd(res, lambda_vals[i])\n        \n        return res\n\n    def is_carmichael(n, factors):\n        \"\"\"\n        Determines if n is a Carmichael number using Korselt's criterion.\n        \"\"\"\n        # A Carmichael number must be composite.\n        if n = 1 or is_prime(n):\n            return False\n\n        # Condition 1: n must be square-free.\n        for k in factors.values():\n            if k > 1:\n                return False\n\n        # Condition 2: For every prime factor p of n, (p-1) must divide (n-1).\n        for p in factors.keys():\n            if (n - 1) % (p - 1) != 0:\n                return False\n        \n        # Passed all conditions for a composite number.\n        return True\n\n    test_cases = [1, 2, 15, 512, 561, 1105, 1729, 2465, 6601, 8911, 41041, 294409]\n    results = []\n\n    for n in test_cases:\n        factors = get_prime_factorization(n)\n        is_c = is_carmichael(n, factors)\n        # Handle lambda for primes correctly if factorization is empty for prime `n`\n        # In this implementation, get_prime_factorization handles prime `n` correctly.\n        lambda_n = compute_lambda(n, factors)\n\n        # Python's bool `True`/`False` needs to be lowercase `true`/`false` in JSON-like output\n        results.append(f\"[{str(is_c).lower()},{lambda_n}]\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3013818"}]}