{"hands_on_practices": [{"introduction": "这项练习是理论联系实际的基础。它将引导您从第一性原理出发，推导梅滕斯第三定理的渐近形式，并特别关注截断值 $x^{\\alpha}$ 如何影响最终结果 [@problem_id:3017428]。通过这个实践，您将加深对素数乘积与欧拉-马斯刻若尼常数 $\\gamma$ 等基本常数之间深刻联系的理解。", "problem": "设 $\\alpha>0$ 为一个固定的常数。考虑基于素数的部分欧拉积\n$$\nP(y)\\;=\\;\\prod_{p\\le y}\\left(1-\\frac{1}{p}\\right),\n$$\n并将欧拉-马斯刻若尼常数 $\\gamma$ 定义为\n$$\n\\gamma\\;=\\;\\lim_{n\\to\\infty}\\left(\\sum_{k=1}^{n}\\frac{1}{k}-\\ln n\\right).\n$$\n从与默滕斯定理相关的基本原理出发——也即，黎曼zeta函数 $\\zeta(s)$ 的欧拉积、$\\zeta(s)$ 在 $s=1$ 处的洛朗展开，以及欧拉因子的对数的绝对收敛展开式——推导当 $x\\to\\infty$ 时 $P(x^{\\alpha})$ 的主渐近行为。你的推导应明确展示截断 $y=x^{\\alpha}$ 如何重新标度主项，并应指明 $\\exp(-\\gamma)$ 在常数因子中的持续出现。以 $x$ 和 $\\alpha$ 的单个闭式表达式的形式，给出 $P(x^{\\alpha})$ 的最终主渐近项。最终答案中不要提供中间过程的不等式或估计；仅需给出主项表达式。", "solution": "用户希望找到当 $x\\to\\infty$ 时，部分欧拉积 $P(x^{\\alpha}) = \\prod_{p\\le x^{\\alpha}}\\left(1-\\frac{1}{p}\\right)$ 的主渐近行为。这是默滕斯第三定理的直接应用，我们现在将从指定的基本原理出发进行推导。\n\n设 $y > 1$ 为一个实数。我们感兴趣的是当 $y$ 很大时，乘积 $P(y) = \\prod_{p\\le y}\\left(1-\\frac{1}{p}\\right)$ 的渐近行为。题目要求的是 $y=x^\\alpha$ 的情况。\n\n我们首先对 $P(y)$ 取自然对数：\n$$\n\\ln P(y) = \\ln\\left(\\prod_{p\\le y}\\left(1-\\frac{1}{p}\\right)\\right) = \\sum_{p\\le y}\\ln\\left(1-\\frac{1}{p}\\right).\n$$\n题目陈述中提到使用对数的绝对收敛展开。对于 $|u|<1$，$\\ln(1-u)$ 的泰勒级数为 $\\ln(1-u) = -\\sum_{k=1}^{\\infty} \\frac{u^k}{k}$。将此应用于 $u=1/p$，我们有：\n$$\n\\ln\\left(1-\\frac{1}{p}\\right) = -\\frac{1}{p} - \\sum_{k=2}^{\\infty}\\frac{1}{k p^k}.\n$$\n将此代入 $\\ln P(y)$ 的表达式中：\n$$\n\\ln P(y) = \\sum_{p\\le y}\\left(-\\frac{1}{p} - \\sum_{k=2}^{\\infty}\\frac{1}{k p^k}\\right) = -\\left(\\sum_{p\\le y}\\frac{1}{p}\\right) - \\sum_{p\\le y}\\sum_{k=2}^{\\infty}\\frac{1}{k p^k}.\n$$\n我们来分析右侧的两项。\n\n第一项是素数倒数的部分和 $\\sum_{p\\le y}\\frac{1}{p}$。其渐近行为由默滕斯第二定理给出，该定理指出：\n$$\n\\sum_{p\\le y}\\frac{1}{p} = \\ln(\\ln y) + M + o(1),\n$$\n其中 $M$ 是迈塞尔-默滕斯常数。\n\n第二项是 $-\\sum_{p\\le y}\\sum_{k=2}^{\\infty}\\frac{1}{k p^k}$。当 $y\\to\\infty$ 时，这个和收敛到一个常数值，因为对所有素数 $p$ 的完整求和是绝对收敛的。设这个常数为 $C'$：\n$$\nC' = -\\sum_{p}\\sum_{k=2}^{\\infty}\\frac{1}{k p^k} = \\sum_{p}\\left(\\ln\\left(1-\\frac{1}{p}\\right) + \\frac{1}{p}\\right).\n$$\n其收敛性源于 $\\ln(1-1/p) + 1/p = O(1/p^2)$。因此，当 $y\\to\\infty$ 时：\n$$\n\\sum_{p\\le y}\\sum_{k=2}^{\\infty}\\frac{1}{k p^k} = -C' + o(1).\n$$\n\n结合这些结果，$\\ln P(y)$ 的渐近行为是：\n$$\n\\ln P(y) = -(\\ln(\\ln y) + M + o(1)) - (-C' + o(1)) = -\\ln(\\ln y) - M + C' + o(1).\n$$\n\n关键步骤，正如题目中提及 $\\zeta(s)$ 的洛朗级数和欧拉-马斯刻若尼常数 $\\gamma$ 所提示的，是将常数项 $-M+C'$ 与 $-\\gamma$ 联系起来。解析数论中有一个可从指定原理推导出的基本结果，即恒等式：\n$$\nM - C' = \\gamma.\n$$\n这个恒等式将源于素数求和的常数（$M$ 和 $C'$）与源于所有整数求和（调和级数）的常数 $\\gamma$ 联系起来。我们可以通过考虑素数求和与所有整数求和的狄利克雷级数生成函数来概述此恒等式的来源。黎曼zeta函数 $\\zeta(s)=\\sum_{n=1}^\\infty n^{-s}$ 在 $s=1$ 处的洛朗展开式为 $\\zeta(s) = \\frac{1}{s-1} + \\gamma + O(s-1)$。这里明确地引入了 $\\gamma$。$\\ln \\zeta(s) = \\sum_p p^{-s} + \\text{正则项}$ 在 $s=1$ 附近的行为提供了关于素数求和的信息。通过仔细比较部分和（$\\sum_{n\\le y} 1/n$ 与 $\\sum_{p\\le y} 1/p$）的渐近行为以及它们的生成函数在 $s=1$ 附近的行为，可以建立恒等式 $M = \\gamma + C'$。\n\n将 $M-C'=\\gamma$ 代入我们为 $\\ln P(y)$ 得到的表达式中：\n$$\n\\ln P(y) = -\\ln(\\ln y) - (M-C') + o(1) = -\\ln(\\ln y) - \\gamma + o(1).\n$$\n\n为了找到 $P(y)$ 的渐近行为，我们对 $\\ln P(y)$ 的表达式取指数：\n$$\nP(y) = \\exp(-\\ln(\\ln y) - \\gamma + o(1)) = \\exp(-\\ln(\\ln y)) \\exp(-\\gamma) \\exp(o(1)).\n$$\n由于 $\\exp(-\\ln(\\ln y)) = \\frac{1}{\\ln y}$ 且 $\\exp(o(1)) = 1+o(1)$，我们便得到了默滕斯第三定理：\n$$\nP(y) \\sim \\frac{e^{-\\gamma}}{\\ln y}.\n$$\n此推导展示了因子 $e^{-\\gamma}$ 的持续出现，它源于黎曼zeta函数在其极点处的洛朗展开式中的常数项 $\\gamma$。\n\n最后，题目要求 $P(x^{\\alpha})$ 的主渐近行为。我们将 $y=x^{\\alpha}$ 代入推导出的渐近公式中。由于 $\\alpha>0$，当 $x\\to\\infty$ 时，我们也有 $y\\to\\infty$。\n截断值的对数为 $\\ln y = \\ln(x^{\\alpha}) = \\alpha \\ln x$。\n将此代入 $P(y)$ 的渐近表达式中：\n$$\nP(x^\\alpha) \\sim \\frac{e^{-\\gamma}}{\\ln(x^\\alpha)} = \\frac{e^{-\\gamma}}{\\alpha \\ln x}.\n$$\n这个表达式展示了与截断为 $x$ 的情况相比，截断 $y=x^{\\alpha}$ 如何通过一个因子 $1/\\alpha$ 来重新标度主项。常数因子 $e^{-\\gamma}$ 不受影响。\n\n因此，当 $x\\to\\infty$ 时，$P(x^{\\alpha})$ 的主渐近项为 $\\frac{e^{-\\gamma}}{\\alpha \\ln x}$。", "answer": "$$\n\\boxed{\\frac{\\exp(-\\gamma)}{\\alpha \\ln(x)}}\n$$", "id": "3017428"}, {"introduction": "解析数论中的证明常常涉及近似处理。这项练习将探讨梅滕斯定理推导过程中的一个关键简化：忽略来自高阶素数幂（即 $p^k$ 当 $k \\ge 2$ 时）的项 [@problem_id:3017438]。通过完成这一分析，您将能更深刻地领会这些项的量级，并理解为何它们仅贡献了一个可忽略的、有界的误差，从而巩固对定理结构严谨性的认识。", "problem": "设 $x \\ge 2$ 且 $\\mathcal{P}$表示素数集合。我们回顾以下三个通常被称为 Mertens 定理的经典论断：\n- 一个关于 $\\sum_{p \\le x} \\frac{1}{p}$ 的渐近规模的论断，\n- 一个关于 $\\sum_{p \\le x} \\frac{\\log p}{p}$ 的渐近规模的论断，\n- 以及一个关于部分 Euler 乘积 $\\prod_{p \\le x} \\left(1 - \\frac{1}{p}\\right)^{-1}$ 的渐近规模的论断。\n在标准证明中，涉及 $k \\ge 2$ 的素数高次幂 $p^k$ 的展开式会通过 Taylor 级数 $-\\log(1 - t) = \\sum_{k \\ge 1} \\frac{t^k}{k}$（对于 $|t| < 1$）以及 Riemann zeta 函数 $\\zeta(s)$ 的对数导数的 Dirichlet 级数自然地出现。现在考虑“重数$\\le 1$”的截断，其中每个素数 $p$ 最多被计算一次，也就是说，当这些级数展开式中出现 $k \\ge 2$ 的幂 $p^k$ 的贡献时，都将其丢弃。仅使用以下基本原理：\n- $\\Re(s) > 1$ 时 $\\zeta(s)$ 的 Euler 乘积恒等式，\n- $t \\to 0$ 时的 Taylor 级数 $-\\log(1 - t) = t + O(t^2)$，\n- 以及 $\\sum_{p \\in \\mathcal{P}} \\frac{1}{p^2}$ 和 $\\sum_{p \\in \\mathcal{P}} \\frac{\\log p}{p^2}$ 的绝对收敛性，\n判断下列哪个断言是正确的。\n\nA. 当中间展开式中所有出现的 $k \\ge 2$ 的素数幂 $p^k$ 都被丢弃时，所有三个 Mertens 定理仍然有效，且主项不变（当有界的加性修正常数被一致地吸收后，常数也保持不变）；被丢弃的项贡献了一个绝对收敛的、与 $x$ 无关的、$O(1)$ 大小的修正项。\n\nB. 只有关于 $\\sum_{p \\le x} \\frac{1}{p}$ 的论断在这种截断下仍然成立；在另外两个论断中，被丢棄的贡献以 $\\log\\log x$ 的速度增长，从而改变了主项中的常数。\n\nC. 关于 $\\sum_{p \\le x} \\frac{\\log p}{p}$ 的论断仍然成立，但在另外两个论断中，由于 $\\sum_{p} \\frac{1}{p^2}$ 缓慢发散，被丢弃的贡献发散，从而使得常数失效。\n\nD. 在这种截断下，三个论断均不成立；省略高次素数幂引入了一个与主项相当的误差（在 Euler 乘积的情况下，误差量级为 $\\log x$）。", "solution": "我们从第一性原理出发，论证为什么以0或1的重数计算素数（即，当展开式中出现由 $p^k$（$k \\ge 2$）索引的贡献时丢弃它们）不影响三个 Mertens 定理的有效性，以及为什么这种截断的影响在相关的对数表达式中至多是一个有界的加性修正项 $O(1)$。关键的输入是：\n\n- $t \\to 0$ 时的 Taylor 近似 $-\\log(1 - t) = t + O(t^2)$。\n- $\\sum_{p \\in \\mathcal{P}} \\frac{1}{p^2}$ 和 $\\sum_{p \\in \\mathcal{P}} \\frac{\\log p}{p^2}$ 的绝对收敛性。\n- $\\Re(s) > 1$ 时 Riemann zeta 函数 $\\zeta(s)$ 的 Euler 乘积以及相关的 $-\\zeta'(s)/\\zeta(s)$ 的 Dirichlet 级数。\n\n步骤1：Euler 乘积和对数级数。对于 $x \\ge 2$，\n$$\n\\log \\prod_{p \\le x} \\left(1 - \\frac{1}{p}\\right)^{-1}\n= \\sum_{p \\le x} -\\log\\!\\left(1 - \\frac{1}{p}\\right).\n$$\n使用 $-\\log(1 - t) = t + O(t^2)$ 并取 $t = \\frac{1}{p}$ 得到\n$$\n-\\log\\!\\left(1 - \\frac{1}{p}\\right) \\;=\\; \\frac{1}{p} + O\\!\\left(\\frac{1}{p^2}\\right),\n$$\n对 $p \\ge 2$ 一致成立。对 $p \\le x$ 求和得到\n$$\n\\sum_{p \\le x} -\\log\\!\\left(1 - \\frac{1}{p}\\right)\n= \\sum_{p \\le x} \\frac{1}{p} \\;+\\; O\\!\\left(\\sum_{p \\le x} \\frac{1}{p^2}\\right)\n= \\sum_{p \\le x} \\frac{1}{p} + O(1),\n$$\n因为 $\\sum_{p} \\frac{1}{p^2}$ 收敛。因此，将 $-\\log(1 - \\frac{1}{p})$ 替换为其重数$\\le 1$的截断 $\\frac{1}{p}$，会使 Euler 乘积的部分对数值最多改变一个有界的加性项 $O(1)$。取指数后，这变成一个乘法因子 $e^{O(1)}$，即一个固定的、与 $x$ 无关的常数因子，因此一旦在常数项中一致地考虑了这个有界差异，Euler 乘积渐近式中的主项和精确常数就不受影响。\n\n步骤2：$\\zeta(s)$ 的对数导数和素数幂。对于 $\\Re(s) > 1$，\n$$\n-\\frac{\\zeta'(s)}{\\zeta(s)} \\;=\\; \\sum_{n=1}^\\infty \\frac{\\Lambda(n)}{n^s}\n\\;=\\; \\sum_{p \\in \\mathcal{P}} \\sum_{k \\ge 1} \\frac{\\log p}{p^{k s}},\n$$\n其中 $\\Lambda$ 是 von Mangoldt 函数。重数$\\le 1$的截断对应于丢弃所有 $k \\ge 2$ 的项，即将 $\\sum_{k \\ge 1}$ 替换为仅有 $k=1$ 的项。在 $s$ 接近 $1$ 时，这种截断对系数序列的影响由绝对收敛性控制：\n$$\n\\sum_{p \\in \\mathcal{P}} \\sum_{k \\ge 2} \\frac{\\log p}{p^{k}} \\;=\\; \\sum_{p \\in \\mathcal{P}} \\frac{\\log p}{p^{2}} \\cdot \\frac{1}{1 - \\frac{1}{p}}\n\\;\\le\\; \\sum_{p \\in \\mathcal{P}} \\frac{\\log p}{p^{2}} \\cdot 2\n\\;<\\; \\infty.\n$$\n因此，对于任何 $x \\ge 2$，\n$$\n\\sum_{\\substack{p \\in \\mathcal{P}\\\\ p \\le x}} \\sum_{\\substack{k \\ge 2\\\\ p^k \\le x}} \\frac{\\log p}{p^{k}}\n\\;\\le\\; \\sum_{p \\in \\mathcal{P}} \\sum_{k \\ge 2} \\frac{\\log p}{p^{k}}\n\\;=\\; O(1).\n$$\n因此，\n$$\n\\sum_{\\substack{p \\in \\mathcal{P}\\\\ p \\le x}} \\frac{\\log p}{p}\n\\;=\\;\n\\sum_{\\substack{p \\in \\mathcal{P},\\, k \\ge 1\\\\ p^k \\le x}} \\frac{\\log p}{p^{k}} \\;+\\; O(1).\n$$\n这表明，用重数$\\le 1$的截断替换完整的素数幂贡献，仅使和 $\\sum_{p \\le x} \\frac{\\log p}{p}$ 改变一个有界的加性项 $O(1)$。因此，相应的 Mertens 论断中的主项和常数不变。\n\n步骤3：素数的调和和。根据定义，关于 $\\sum_{p \\le x} \\frac{1}{p}$ 的论断本身已经是以重数恰好为1来计算素数的；在该和式本身中没有出现 $k \\ge 2$ 的 $p^k$。在标准论证中，高次幂出现的唯一地方是在步骤1中回顾的 Euler 乘积的对数展开式中。由于步骤1表明截断那些高次幂仅使相关对数值改变 $O(1)$，因此，在整个过程中采用重数$\\le 1$的观点同样不影响 $\\sum_{p \\le x} \\frac{1}{p}$ 的主项和常数。\n\n结论。在所有三种情况下，丢弃展开式中出现的 $k \\ge 2$ 的贡献，最多使相关的对数表达式改变一个有界量 $O(1)$。这种有界的加性变化不会改变主项，并且当常数被一致地追踪时，也不会改变常数。因此，以0或1的重数计算素数对三个 Mertens 定理的有效性没有影响。\n\n逐个选项分析：\n- 选项A：这与上面的推导相符。对于 Euler 乘积，$-\\log(1 - \\frac{1}{p}) = \\frac{1}{p} + O(\\frac{1}{p^2})$ 且 $\\sum_{p} \\frac{1}{p^2}$ 收敛，这使得对数值产生 $O(1)$ 的差异。对于 $\\sum \\frac{\\log p}{p}$ 的论断，$\\sum_{p}\\sum_{k \\ge 2} \\frac{\\log p}{p^k}$ 收敛，同样产生 $O(1)$ 的差异。对于 $\\sum \\frac{1}{p}$，除了已经处理过的 Euler 乘积展开式外，不会出现重数。一旦这些有界修正被一致地吸收，常数保持不变。结论：正确。\n- 选项B：声称第一个和第三个论断中存在 $O(\\log\\log x)$ 的损失。这与上面得到的 $O(1)$ 界限相矛盾，该界限由 $\\sum_{p} \\frac{1}{p^2}$ 和 $\\sum_{p} \\frac{\\log p}{p^2}$ 的绝对收敛性得出。结论：不正确。\n- 选项C：断言 $\\sum_{p} \\frac{1}{p^2}$ 发散，这是错误的；因为 $\\sum_{n \\ge 2} \\frac{1}{n^2}$ 收敛，所以 $\\sum_{p} \\frac{1}{p^2}$ 当然收敛，同样地，通过与 $\\sum_{n \\ge 2} \\frac{\\log n}{n^2}$ 比较，$\\sum_{p} \\frac{\\log p}{p^2}$ 也收敛。结论：不正确。\n- 选项D：断言 Euler 乘积截断会产生 $O(\\log x)$ 的误差，而根据步骤1，其对数值的误差是 $O(1)$。结论：不正确。", "answer": "$$\\boxed{A}$$", "id": "3017438"}, {"introduction": "当我们能够用实际数字验证抽象的定理时，理论便获得了生命力。这项编程练习要求您编写代码，对梅滕斯第一定理进行经验性检验 [@problem_id:3017421]。这不仅能加深对理论陈述的理解，还能提供处理素数生成与数值分析的实践经验，从而在纯粹数学与计算科学之间架起一座桥梁。", "problem": "设计并实现一个完整的程序，对关于素数倒数之和的 Mertens 第一定理进行经验性探究。设 $p$ 表示一个素数，对于任意实数 $x \\ge 2$，定义部分和 $S(x) = \\sum_{p \\le x} \\frac{1}{p}$。Mertens 第一定理断言，当 $x \\to \\infty$ 时，$S(x) - \\log \\log x$ 趋近于一个常数 $B_1$。本练习的目标是构建一个经验性测试：对于一组输入值 $x$，计算 $S(x)$，将其与 $\\log \\log x$ 进行比较，并通过一种受重采样启发的近似方法，为导出的估计量 $B_1(x) = S(x) - \\log \\log x$ 构建一个经验置信区间。\n\n您必须基于以下基础进行操作：\n- 素数集合：素数是 $p \\ge 2$ 的整数，且只能被 $1$ 和其自身整除。\n- 自然对数函数 $\\log$ 及其复合函数 $\\log \\log x$（对于 $x > 1$）。\n- Sieve of Eratosthenes 是一个有效的算法，可用于枚举直至给定上限 $X$ 的所有素数。\n- 有限多重集的基本统计量：对于数据 $y_1,\\dots,y_n$，样本均值为 $\\bar y = \\frac{1}{n}\\sum_{i=1}^n y_i$，当 $n \\ge 2$ 时无偏样本方差为 $s^2 = \\frac{1}{n-1}\\sum_{i=1}^n (y_i - \\bar y)^2$，以及在经验重采样模型下，使用正态近似为位置参数构建对称双侧置信区间。\n\n您的程序必须：\n- 使用 Sieve of Eratosthenes 生成直至测试集中最大 $x$ 值的所有素数。\n- 对每个测试值 $x$，计算 $S(x) = \\sum_{p \\le x} \\frac{1}{p}$，$L(x) = \\log \\log x$，以及经验估计量 $B_1(x) = S(x) - L(x)$。\n- 为量化由有限截断引起的经验不确定性，使用以下受重采样启发的近似方法为 $B_1(x)$ 构建一个置信水平为 $0.95$ 的对称双侧置信区间。将大小为 $n = \\pi(x)$ 的多重集 $\\{\\frac{1}{p} : p \\le x\\}$ 视为来自未知分布的经验样本，计算其样本标准差 $s$，并通过 $\\operatorname{SE}_{\\mathrm{sum}} \\approx s \\sqrt{n}$ 来近似和的标准误。然后构建一个正态近似区间\n$$\n\\bigl[B_1(x) - z_{0.975}\\,\\operatorname{SE}_{\\mathrm{sum}},\\; B_1(x) + z_{0.975}\\,\\operatorname{SE}_{\\mathrm{sum}}\\bigr],\n$$\n其中 $z_{0.975}$ 是上 $0.975$ 标准正态分位数。对于 $n = 1$ 的情况，取 $s = 0$，从而得到宽度为零的退化区间。\n- 全程使用自然对数。\n\n测试集：\n- 使用以下输入值 $x \\in \\{2, 10, 10^3, 10^5, 10^6\\}$。\n- 对每个 $x$，输出一个包含六个浮点数的元组 $[x, S(x), L(x), B_1(x), \\mathrm{CI}_{\\mathrm{low}}(x), \\mathrm{CI}_{\\mathrm{high}}(x)]$，其中 $\\mathrm{CI}_{\\mathrm{low}}(x)$ 和 $\\mathrm{CI}_{\\mathrm{high}}(x)$ 是上述置信区间的下限和上限。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含五个测试用例的结果，格式为由逗号分隔的列表的列表，并用方括号括起来，不含空格。具体而言，输出必须采用\n$\n\\bigl[\n[x_1,S(x_1),L(x_1),B_1(x_1),\\mathrm{CI}_{\\mathrm{low}}(x_1),\\mathrm{CI}_{\\mathrm{high}}(x_1)],\n\\ldots,\n[x_5,S(x_5),L(x_5),B_1(x_5),\\mathrm{CI}_{\\mathrm{low}}(x_5),\\mathrm{CI}_{\\mathrm{high}}(x_5)]\n\\bigr]\n$\n形式，每个数值条目都呈现为浮点数。置信水平必须为 $0.95$，所有对数均为自然对数。\n\n覆盖范围考虑：\n- $x=2$ 的情况测试了 $n=1$ 时的边界条件。\n- $x=10$ 的情况测试了波动较大的小 $x$ 值。\n- $x=10^3, 10^5, 10^6$ 的情况探究了逐渐增大的 $x$ 值，此时 $B_1(x)$ 应表现出稳定趋势，而经验区间的宽度在上述建模假设下会收缩。\n\n您的程序必须是自包含的，不要求任何输入，并且必须在标准环境中运行，无需读写文件或使用网络访问。所有计算都必须使用浮点数运算，并具有足够的精度以显示所要求的值。最终打印的行必须与上述格式完全匹配。", "solution": "我们旨在通过计算 $B_1(x) = S(x) - \\log \\log x$，经验性地检验 $S(x) = \\sum_{p \\le x} \\frac{1}{p}$ 相对于 $\\log \\log x$ 的行为，并对 Mertens 第一定理中的常数 $B_1$ 形成数值估计。目标是从第一性原理出发，仅使用素数的定义、自然对数、一个枚举素数的算法和初等统计学来完成此任务。\n\n步骤 $1$：生成直至测试集中最大 $x$ 值的所有素数。Sieve of Eratosthenes 算法可以在接近于 $X$ 线性时间内构建出上限为 $X$ 的所有素数：\n- 初始化一个长度为 $X+1$ 的布尔数组，其条目对应整数 $0,1,\\dots,X$。\n- 将 $0$ 和 $1$ 标记为合数（非素数）。\n- 对于从 $2$ 到 $\\lfloor \\sqrt{X} \\rfloor$ 的每个整数 $m$，如果 $m$ 是素数，则将其所有倍数 $m^2, m^2+m, \\dots$ 直至 $X$ 标记为合数。\n- 未被标记的条目即代表直至 $X$ 的素数。\n\n设 $X_{\\max}$ 是所请求的 $x$ 值中的最大值。我们一次性筛选到 $X_{\\max}$，以获得有序的素数列表 $p_1 < p_2 < \\cdots < p_{\\pi(X_{\\max})}$。这对所有测试用例的素数生成成本进行了摊销。\n\n步骤 $2$：预计算素数倒数及其平方的部分和。定义序列 $r_i = \\frac{1}{p_i}$，其中 $i = 1, \\dots, \\pi(X_{\\max})$。计算累积和\n$\nR_k = \\sum_{i=1}^k r_i\n$\n和\n$\nQ_k = \\sum_{i=1}^k r_i^2\n$\n对于 $k = 1, \\dots, \\pi(X_{\\max})$。对于任意给定的 $x$，令 $n = \\pi(x)$ 为小于等于 $x$ 的素数个数，并令 $k=n$。则\n$\nS(x) = R_k.\n$\n\n步骤 $3$：对于 $x > 1$，使用自然对数计算 $L(x) = \\log \\log x$；对于所有测试值，我们都有 $x \\ge 2$，因此 $L(x)$ 有定义。\n\n步骤 $4$：将在 $x$ 处的 $B_1$ 的经验估计量定义为\n$\nB_1(x) = S(x) - L(x).\n$\n如果 Mertens 第一定理成立，可以预期随着 $x$ 的增长，$B_1(x)$ 会趋近于一个常数。\n\n步骤 $5$：通过一种受重采样启发的近似方法为 $B_1(x)$ 构建经验置信区间。我们并不是在为素数序列中的任何真实随机性建模；相反，我们使用探索性数据分析中的一种标准启发式方法：将在给定 $x$ 处的观测增量有限多重集 $\\{r_1, \\dots, r_n\\}$ 视为来自未知分布的样本，并用自助法-正态标准误来近似其和的变异性。在独立同分布的启发式模型下，样本均值 $\\bar r = \\frac{1}{n}\\sum_{i=1}^n r_i$ 的抽样方差近似为 $s^2 / n$，其中 $s^2$ 是当 $n \\ge 2$ 时的无偏样本方差\n$\ns^2 = \\frac{1}{n-1}\\sum_{i=1}^n (r_i - \\bar r)^2\n$\n。由于 $S(x) = \\sum_{i=1}^n r_i = n \\bar r$，其和的近似标准误为\n$\n\\operatorname{SE}_{\\mathrm{sum}} \\approx \\sqrt{\\operatorname{Var}(n \\bar r)} \\approx \\sqrt{n^2 \\cdot \\frac{s^2}{n}} = s \\sqrt{n}.\n$\n然后，我们使用标准正态分位数 $z_{0.975}$，在 $0.95$ 的水平上构建一个对称双侧正态近似区间：\n$\n\\bigl[S(x) - z_{0.975}\\, s \\sqrt{n},\\; S(x) + z_{0.975}\\, s \\sqrt{n}\\bigr].\n$\n因为 $B_1(x) = S(x) - L(x)$，且对于固定的 $x$，$L(x)$ 是确定性的，所以通过从区间端点减去 $L(x)$ 即可得到 $B_1(x)$ 的导出区间：\n$\n\\bigl[B_1(x) - z_{0.975}\\, s \\sqrt{n},\\; B_1(x) + z_{0.975}\\, s \\sqrt{n}\\bigr].\n$\n对于 $n=1$ 的边界情况（在 $x=2$ 时发生），无偏样本方差未定义。在这种情况下，我们设 $s=0$，从而得到宽度为零的退化区间，这对于此经验性构建是一个合理的约定。\n\n步骤 $6$：对多个 $x$ 进行高效计算。在准备好累积和 $R_k$ 和 $Q_k$ 以及素数列表后，我们可以对每个 $x$ 通过二分搜索找到 $n = \\pi(x)$，提取 $S(x) = R_n$，计算样本均值 $\\bar r = R_n / n$，对于 $n \\ge 2$ 计算\n$\ns^2 = \\frac{Q_n - n \\bar r^2}{n-1}\n$\n，然后使用固定常数 $z_{0.975}$ 构建置信区间。这种方法运行时间主要由筛选到 $X_{\\max}$ 的过程决定，仅需要 $O(X_{\\max})$ 的内存用于筛选，以及 $O(\\pi(X_{\\max}))$ 的内存用于存储素数列表和累积数组。\n\n测试集和输出：我们在 $x \\in \\{2, 10, 10^3, 10^5, 10^6\\}$ 处进行评估，这探究了一个边界情况、一个小数值情况和三个逐渐增大的情况。对于每个 $x$，我们以浮点数形式输出一个六元组\n$\n[x, S(x), L(x), B_1(x), \\mathrm{CI}_{\\mathrm{low}}(x), \\mathrm{CI}_{\\mathrm{high}}(x)]\n$\n，并以无空格、逗号分隔的列表的列表形式在单行上输出。这种格式便于自动检查，并且可以直接根据所提供的定义进行计算。\n\n科学解释：所得的 $B_1(x)$ 值应该会缓慢漂移，并根据 Mertens 第一定理趋向一个常数。在重采样启发式方法下，随着 $x$ 的增加，经验区间会收缩，因为在此构造中 $s \\sqrt{n}$ 的增长速度慢于 $B_1(x)$ 的稳定速度；然而，必须强调的是，这些区间是启发式的，并不构成严格的数论误差界。它们可作为一种经验性诊断工具，用以表明统计量 $B_1(x)$ 在整个测试集中正在趋于稳定。\n\n所有必需的计算仅使用开头陈述的定义和经过充分测试的算法，并且程序遵守指定的输出要求。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef sieve_primes(n):\n    \"\"\"Return a numpy array of all primes <= n using the Sieve of Eratosthenes.\"\"\"\n    if n < 2:\n        return np.array([], dtype=np.int64)\n    sieve = np.ones(n + 1, dtype=bool)\n    sieve[:2] = False\n    limit = int(n**0.5)\n    for p in range(2, limit + 1):\n        if sieve[p]:\n            sieve[p*p:n+1:p] = False\n    return np.nonzero(sieve)[0]\n\ndef compute_results(x_values, z_quantile=1.959963984540054):\n    \"\"\"\n    For each x in x_values, compute:\n    - x as float\n    - S(x) = sum_{p<=x} 1/p\n    - L(x) = log(log(x))\n    - B1_hat(x) = S(x) - L(x)\n    - CI_low, CI_high: normal-approx empirical CI using s*sqrt(n)\n    \"\"\"\n    Xmax = int(max(x_values))\n    primes = sieve_primes(Xmax)\n    if primes.size == 0:\n        # Degenerate case; but our x_values ensure x>=2\n        recips = np.array([], dtype=float)\n    else:\n        recips = 1.0 / primes.astype(float)\n\n    # Precompute cumulative sums of reciprocals and their squares\n    if recips.size > 0:\n        cum1 = np.cumsum(recips)              # R_k\n        cum2 = np.cumsum(recips * recips)     # Q_k\n    else:\n        cum1 = np.array([], dtype=float)\n        cum2 = np.array([], dtype=float)\n\n    results = []\n    for x in x_values:\n        # count of primes <= x\n        n = int(np.searchsorted(primes, x, side='right'))\n        if n == 0:\n            Sx = 0.0\n            # For x<2, but not in our test suite; safeguard:\n            Lx = float('nan')\n            Bhat = float('nan')\n            ci_low = float('nan')\n            ci_high = float('nan')\n        else:\n            Sx = float(cum1[n-1])\n            # natural logs\n            Lx = math.log(math.log(float(x)))\n            Bhat = Sx - Lx\n            if n == 1:\n                s = 0.0\n            else:\n                mean = Sx / n\n                # unbiased sample variance from cumulative sums:\n                var = (float(cum2[n-1]) - n * mean * mean) / (n - 1)\n                # Numerical guard\n                if var < 0.0 and var > -1e-18:\n                    var = 0.0\n                s = math.sqrt(var) if var > 0.0 else 0.0\n            se_sum = s * math.sqrt(n)\n            half_width = z_quantile * se_sum\n            ci_low = Bhat - half_width\n            ci_high = Bhat + half_width\n\n        # append as floats, formatting later\n        results.append([float(x), Sx, Lx, Bhat, ci_low, ci_high])\n\n    return results\n\ndef format_results_no_spaces(results, precision=12):\n    \"\"\"\n    Format the list of lists with no spaces, with each float shown to given precision.\n    \"\"\"\n    inner_strs = []\n    fmt = \"{:.\" + str(precision) + \"f}\"\n    for row in results:\n        row_str = \"[\" + \",\".join(fmt.format(float(v)) for v in row) + \"]\"\n        inner_strs.append(row_str)\n    return \"[\" + \",\".join(inner_strs) + \"]\"\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [2, 10, 1000, 100000, 1000000]\n\n    results = compute_results(test_cases, z_quantile=1.959963984540054)\n    output = format_results_no_spaces(results, precision=12)\n\n    # Final print statement in the exact required format.\n    print(output)\n\nsolve()\n```", "id": "3017421"}]}