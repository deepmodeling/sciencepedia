{"hands_on_practices": [{"introduction": "切比雪夫函数 $\\psi(x)$ 和 $\\vartheta(x)$ 都是研究素数分布的核心工具，但它们之间存在细微而重要的差异。本练习旨在通过直接计算来阐明这一差异，要求你精确计算 $\\psi(x) - \\vartheta(x)$ [@problem_id:3029744]。这个过程将加深你对冯·曼戈尔特函数 $\\Lambda(n)$ 定义的理解，并揭示高次素数幂对 $\\psi(x)$ 的贡献。", "problem": "设 $x$ 是一个正实数，定义冯·曼戈尔特函数 (von Mangoldt function) $\\Lambda(n)$ 如下：若 $n$ 是某个素数 $p$ 的整数次幂 $p^{k}$（其中 $k \\geq 1$），则 $\\Lambda(n) = \\log p$；否则 $\\Lambda(n) = 0$。定义切比雪夫函数 (Chebyshev functions) $\\vartheta(x)$ 和 $\\psi(x)$ 如下\n$$\\vartheta(x) = \\sum_{p \\leq x} \\log p \\quad \\text{以及} \\quad \\psi(x) = \\sum_{n \\leq x} \\Lambda(n),$$\n其中第一个和式是对所有素数 $p$ 求和，第二个和式是对所有正整数 $n$ 求和。\n\n仅从这些定义出发，不使用任何渐近定理或已证恒等式，通过识别那些被 $\\psi(10000)$ 计数但未被 $\\vartheta(10000)$ 计数的整数，来确定 $\\psi(10000) - \\vartheta(10000)$ 的精确值。将最终答案表示为带有整数指数的素数乘积的单个自然对数，并简化为一个闭式解析表达式。无需进行数值近似。", "solution": "本题要求仅根据所给的冯·曼戈尔特函数 (von Mangoldt function) $\\Lambda(n)$ 和切比雪夫函数 (Chebyshev functions) $\\vartheta(x)$、$\\psi(x)$ 的定义，来精确计算表达式 $\\psi(10000) - \\vartheta(10000)$ 的值。\n\n首先，我们来分析所给的定义。\n冯·曼戈尔特函数 $\\Lambda(n)$ 对正整数 $n$ 定义如下：\n$$ \\Lambda(n) = \\begin{cases} \\log p & \\text{若 } n = p^k \\text{ 对于某个素数 } p \\text{ 和整数 } k \\ge 1 \\\\ 0 & \\text{其他情况} \\end{cases} $$\n切比雪夫函数对正实数 $x$ 定义如下：\n$$ \\vartheta(x) = \\sum_{p \\le x, p \\in \\mathbb{P}} \\log p $$\n$$ \\psi(x) = \\sum_{n=1}^{\\lfloor x \\rfloor} \\Lambda(n) $$\n其中 $\\mathbb{P}$ 表示素数集合。\n\n题目要求通过识别其贡献被计入 $\\psi(10000)$ 但未被计入 $\\vartheta(10000)$ 的整数，来确定 $\\psi(10000) - \\vartheta(10000)$ 的值。\n\n让我们代入 $\\Lambda(n)$ 的定义来表示 $\\psi(x)$。该和式是对所有正整数 $n \\le x$ 求和，但只有当 $n$ 是素数的幂时，项 $\\Lambda(n)$ 才非零。因此，我们可以将 $\\psi(x)$ 的和式写成对素数幂求和的形式：\n$$ \\psi(x) = \\sum_{p^k \\le x, p \\in \\mathbb{P}, k \\ge 1} \\log p $$\n我们可以根据指数 $k$ 的值将此和式拆分：\n$$ \\psi(x) = \\sum_{k=1}^{\\infty} \\sum_{p^k \\le x, p \\in \\mathbb{P}} \\log p $$\n这个和是有限的，因为对于任意给定的 $x > 1$，如果 $2^k > x$（即 $k > \\log_2 x$），内层和式就变为空集。\n\n让我们考察 $k=1$ 的项：\n$$ \\sum_{p^1 \\le x, p \\in \\mathbb{P}} \\log p = \\sum_{p \\le x, p \\in \\mathbb{P}} \\log p $$\n这恰好是 $\\vartheta(x)$ 的定义。\n\n因此，我们可以将 $\\psi(x)$ 写成：\n$$ \\psi(x) = \\left( \\sum_{p \\le x, p \\in \\mathbb{P}} \\log p \\right) + \\left( \\sum_{p^2 \\le x, p \\in \\mathbb{P}} \\log p \\right) + \\left( \\sum_{p^3 \\le x, p \\in \\mathbb{P}} \\log p \\right) + \\dots $$\n$$ \\psi(x) = \\vartheta(x) + \\sum_{k=2}^{\\infty} \\sum_{p^k \\le x, p \\in \\mathbb{P}} \\log p $$\n\n那么，差值 $\\psi(x) - \\vartheta(x)$ 是：\n$$ \\psi(x) - \\vartheta(x) = \\sum_{k=2}^{\\infty} \\sum_{p^k \\le x, p \\in \\mathbb{P}} \\log p $$\n被 $\\psi(x)$ 计数但未被 $\\vartheta(x)$ 计数的整数是高次素数幂，即 $n = p^k$ 且 $k \\ge 2$。每个满足 $n \\le x$ 的此类整数都为 $\\psi(x)$ 的和式贡献一项 $\\Lambda(n) = \\log p$。\n\n对于本题，我们设 $x=10000$：\n$$ \\psi(10000) - \\vartheta(10000) = \\sum_{k=2}^{\\infty} \\sum_{p^k \\le 10000, p \\in \\mathbb{P}} \\log p $$\n可以按素数 $p$ 对和式进行重组。对于每个素数 $p$，每当存在一个整数 $k \\ge 2$ 使得 $p^k \\le 10000$，项 $\\log p$ 就会被加一次。对于给定的素数 $p$，这样的 $k$ 值的数量就是总和式中 $\\log p$ 的系数。\n条件 $p^k \\le 10000$ 等价于 $k \\log p \\le \\log 10000$，即 $k \\le \\log_p(10000)$。\n由于我们是对 $k \\ge 2$ 求和，所以对于给定的素数 $p$，项数为 $\\lfloor \\log_p(10000) \\rfloor - 1$。仅当 $\\lfloor \\log_p(10000) \\rfloor \\ge 2$ 时，和才非零，这意味着 $p^2 \\le 10000$，因此 $p \\le \\sqrt{10000} = 100$。\n\n因此，总和为：\n$$ \\psi(10000) - \\vartheta(10000) = \\sum_{p \\le 100, p \\in \\mathbb{P}} (\\lfloor \\log_p(10000) \\rfloor - 1) \\log p $$\n使用对数性质 $a \\log b = \\log(b^a)$，这可以写成一个单一的自然对数：\n$$ \\log \\left( \\prod_{p \\le 100, p \\in \\mathbb{P}} p^{(\\lfloor \\log_p(10000) \\rfloor - 1)} \\right) $$\n我们现在计算每个 $p \\le 100$ 的素数的指数：\n*   对于 $p=2$：$\\log_2(10000) = \\frac{\\log(10000)}{\\log(2)} \\approx 13.287$。指数为 $\\lfloor 13.287 \\rfloor - 1 = 13 - 1 = 12$。\n*   对于 $p=3$：$\\log_3(10000) = \\frac{\\log(10000)}{\\log(3)} \\approx 8.383$。指数为 $\\lfloor 8.383 \\rfloor - 1 = 8 - 1 = 7$。\n*   对于 $p=5$：$\\log_5(10000) = \\frac{\\log(10000)}{\\log(5)} \\approx 5.722$。指数为 $\\lfloor 5.722 \\rfloor - 1 = 5 - 1 = 4$。\n*   对于 $p=7$：$\\log_7(10000) = \\frac{\\log(10000)}{\\log(7)} \\approx 4.732$。指数为 $\\lfloor 4.732 \\rfloor - 1 = 4 - 1 = 3$。\n*   对于指数为 $2$ 的素数 $p$：这要求 $2 = \\lfloor \\log_p(10000) \\rfloor - 1$，所以 $3 \\le \\log_p(10000) < 4$。这意味着 $p^3 \\le 10000 < p^4$。取方根，得 $p \\le (10000)^{1/3} \\approx 21.54$ 且 $p > (10000)^{1/4} = 10$。此范围内的素数是 $11, 13, 17, 19$。\n*   对于指数为 $1$ 的素数 $p$：这要求 $1 = \\lfloor \\log_p(10000) \\rfloor - 1$，所以 $2 \\le \\log_p(10000) < 3$。这意味着 $p^2 \\le 10000 < p^3$。取方根，得 $p \\le (10000)^{1/2} = 100$ 且 $p > (10000)^{1/3} \\approx 21.54$。此范围内的素数是 $23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97$。\n综合这些结果，对数内的最终乘积是：\n$$ 2^{12} \\cdot 3^{7} \\cdot 5^{4} \\cdot 7^{3} \\cdot (11 \\cdot 13 \\cdot 17 \\cdot 19)^{2} \\cdot \\left( \\prod_{\\substack{p \\in \\mathbb{P} \\\\ 23 \\le p \\le 97}} p \\right) $$\n所求的表达式即为此乘积的单个自然对数。其中 $\\prod_{\\substack{p \\in \\mathbb{P} \\\\ 23 \\le p \\le 97}} p$ 表示所有满足 $23 \\le p \\le 97$ 的素数 $p$ 的乘积。\n\n最终表达式为：\n$$ \\log \\left( 2^{12} \\cdot 3^7 \\cdot 5^4 \\cdot 7^3 \\cdot 11^2 \\cdot 13^2 \\cdot 17^2 \\cdot 19^2 \\cdot \\prod_{\\substack{p \\in \\mathbb{P} \\\\ 23 \\le p \\le 97}} p \\right) $$", "answer": "$$\\boxed{\\log \\left( 2^{12} \\cdot 3^7 \\cdot 5^4 \\cdot 7^3 \\cdot 11^2 \\cdot 13^2 \\cdot 17^2 \\cdot 19^2 \\cdot \\prod_{\\substack{p \\in \\mathbb{P} \\\\ 23 \\le p \\le 97}} p \\right)}$$", "id": "3029744"}, {"introduction": "冯·曼戈尔特函数和切比雪夫函数的一个强大应用是分析素数在算术级数中的分布。本练习将引导你使用狄利克雷特征作为工具，来分离和比较不同余数类中的素数 [@problem_id:3029741]。通过计算特定算术级数中切比雪夫函数值的差异，你将亲身体验特征的正交性如何简化问题，并初步窥见素数分布中的“切比雪夫偏置”现象。", "problem": "设 $q$ 是一个正整数，$a$ 是一个模 $q$ 的剩余类，且 $\\gcd(a,q)=1$。定义 von Mangoldt 函数 $\\Lambda(n)$ 如下：如果 $n=p^{k}$（其中 $p$ 为素数，$k \\geq 1$ 为整数），则 $\\Lambda(n)=\\log(p)$；否则 $\\Lambda(n)=0$。定义算术级数中的 Chebyshev 函数为\n$$\\psi(x;q,a) = \\sum_{\\substack{n \\leq x \\\\ n \\equiv a \\, (\\mathrm{mod}\\, q)}} \\Lambda(n).$$\n仅使用关于模 4 的狄利克雷特征及其正交性的基础理论，推导一个恒等式，将差值 $\\psi(x;4,1)-\\psi(x;4,3)$ 化简为单个特征加权的 von Mangoldt 和。然后，对于 $x=20$ 这一具体取值，精确计算该差值。最后，从概念上解释你所推导的恒等式如何将所计算差值的观测符号与模 4 的本原二次特征关联的狄利克雷 $L$-函数的非平凡零点联系起来。给出你的最终答案，要求是单个精确表达式，而非小数近似值。", "solution": "首先，我们推导该恒等式。模 4 的既约剩余类群是 $(\\mathbb{Z}/4\\mathbb{Z})^\\times = \\{1, 3\\}$，其阶为 $\\varphi(4)=2$。存在两个模 4 的狄利克雷特征。第一个是主特征 $\\chi_0$，定义为：若 $\\gcd(n,4)=1$，则 $\\chi_0(n)=1$；若 $\\gcd(n,4)>1$，则 $\\chi_0(n)=0$。第二个是非主特征 $\\chi_1$，定义为：$\\chi_1(1)=1$，$\\chi_1(3)=-1$；若 $\\gcd(n,4)>1$，则 $\\chi_1(n)=0$。注意，对于任何奇整数 $n$，有 $\\chi_1(n) = (-1)^{(n-1)/2}$。这两个特征都是实值的。\n\n模 $q$ 的狄利克雷特征的正交关系可用于从带有同余条件的和式中分离出特定项。对于整数 $n$ 和满足 $\\gcd(a,q)=1$ 的剩余类 $a$，我们有：\n$$ \\frac{1}{\\varphi(q)} \\sum_{\\chi \\, (\\mathrm{mod}\\, q)} \\overline{\\chi(a)} \\chi(n) = \\begin{cases} 1 & \\text{若 } n \\equiv a \\, (\\mathrm{mod}\\, q) \\\\ 0 & \\text{否则} \\end{cases} $$\n利用此关系，我们可以重写 Chebyshev 函数 $\\psi(x;q,a)$：\n$$ \\psi(x;q,a) = \\sum_{\\substack{n \\leq x \\\\ n \\equiv a \\, (\\mathrm{mod}\\, q)}} \\Lambda(n) = \\sum_{n \\leq x} \\Lambda(n) \\left( \\frac{1}{\\varphi(q)} \\sum_{\\chi \\, (\\mathrm{mod}\\, q)} \\overline{\\chi(a)} \\chi(n) \\right) $$\n通过交换求和顺序，我们得到：\n$$ \\psi(x;q,a) = \\frac{1}{\\varphi(q)} \\sum_{\\chi \\, (\\mathrm{mod}\\, q)} \\overline{\\chi(a)} \\sum_{n \\leq x} \\Lambda(n) \\chi(n) $$\n我们定义特征加权和 $\\psi(x,\\chi) = \\sum_{n \\leq x} \\Lambda(n) \\chi(n)$。该表达式变为：\n$$ \\psi(x;q,a) = \\frac{1}{\\varphi(q)} \\sum_{\\chi \\, (\\mathrm{mod}\\, q)} \\overline{\\chi(a)} \\psi(x,\\chi) $$\n现在，我们令 $q=4$。由于特征是实值的，$\\overline{\\chi} = \\chi$。\n对于 $a=1$：\n$$ \\psi(x;4,1) = \\frac{1}{\\varphi(4)} \\left( \\chi_0(1) \\psi(x,\\chi_0) + \\chi_1(1) \\psi(x,\\chi_1) \\right) = \\frac{1}{2} \\left( \\psi(x,\\chi_0) + \\psi(x,\\chi_1) \\right) $$\n对于 $a=3$：\n$$ \\psi(x;4,3) = \\frac{1}{\\varphi(4)} \\left( \\chi_0(3) \\psi(x,\\chi_0) + \\chi_1(3) \\psi(x,\\chi_1) \\right) = \\frac{1}{2} \\left( \\psi(x,\\chi_0) - \\psi(x,\\chi_1) \\right) $$\n从第一个表达式中减去第二个表达式，得到所求的恒等式：\n$$ \\psi(x;4,1) - \\psi(x;4,3) = \\frac{1}{2} \\left( \\psi(x,\\chi_0) + \\psi(x,\\chi_1) \\right) - \\frac{1}{2} \\left( \\psi(x,\\chi_0) - \\psi(x,\\chi_1) \\right) = \\psi(x,\\chi_1) $$\n因此，该恒等式为 $\\psi(x;4,1) - \\psi(x;4,3) = \\sum_{n \\leq x} \\Lambda(n) \\chi_1(n)$。\n\n第二，我们计算当 $x=20$ 时该差值。我们需要计算 $\\psi(20,\\chi_1) = \\sum_{n \\leq 20} \\Lambda(n) \\chi_1(n)$。von Mangoldt 函数 $\\Lambda(n)$ 仅在 $n=p^k$（$p$ 为素数）时非零。特征 $\\chi_1(n)$ 仅在 $n$ 为奇数时非零。我们列出不大于 20 的素数幂 $n$，并计算各项 $\\Lambda(n)\\chi_1(n)$：\n\\begin{itemize}\n    \\item $n=2$ (素数): $\\chi_1(2)=0$。项为 $0$。\n    \\item $n=3$ (素数): $\\Lambda(3)=\\log(3)$，$3 \\equiv 3 \\, (\\mathrm{mod}\\, 4)$，所以 $\\chi_1(3)=-1$。项为 $-\\log(3)$。\n    \\item $n=4=2^2$: $\\chi_1(4)=0$。项为 $0$。\n    \\item $n=5$ (素数): $\\Lambda(5)=\\log(5)$，$5 \\equiv 1 \\, (\\mathrm{mod}\\, 4)$，所以 $\\chi_1(5)=1$。项为 $\\log(5)$。\n    \\item $n=7$ (素数): $\\Lambda(7)=\\log(7)$，$7 \\equiv 3 \\, (\\mathrm{mod}\\, 4)$，所以 $\\chi_1(7)=-1$。项为 $-\\log(7)$。\n    \\item $n=8=2^3$: $\\chi_1(8)=0$。项为 $0$。\n    \\item $n=9=3^2$: $\\Lambda(9)=\\log(3)$，$9 \\equiv 1 \\, (\\mathrm{mod}\\, 4)$，所以 $\\chi_1(9)=1$。项为 $\\log(3)$。\n    \\item $n=11$ (素数): $\\Lambda(11)=\\log(11)$，$11 \\equiv 3 \\, (\\mathrm{mod}\\, 4)$，所以 $\\chi_1(11)=-1$。项为 $-\\log(11)$。\n    \\item $n=13$ (素数): $\\Lambda(13)=\\log(13)$，$13 \\equiv 1 \\, (\\mathrm{mod}\\, 4)$，所以 $\\chi_1(13)=1$。项为 $\\log(13)$。\n    \\item $n=16=2^4$: $\\chi_1(16)=0$。项为 $0$。\n    \\item $n=17$ (素数): $\\Lambda(17)=\\log(17)$，$17 \\equiv 1 \\, (\\mathrm{mod}\\, 4)$，所以 $\\chi_1(17)=1$。项为 $\\log(17)$。\n    \\item $n=19$ (素数): $\\Lambda(19)=\\log(19)$，$19 \\equiv 3 \\, (\\mathrm{mod}\\, 4)$，所以 $\\chi_1(19)=-1$。项为 $-\\log(19)$。\n\\end{itemize}\n所有其他不大于 20 的整数 $n$ 要么不是素数幂（因此 $\\Lambda(n)=0$），要么是偶数（因此 $\\chi_1(n)=0$）。将非零项相加：\n$$ \\psi(20;4,1) - \\psi(20;4,3) = -\\log(3) + \\log(5) - \\log(7) + \\log(3) - \\log(11) + \\log(13) + \\log(17) - \\log(19) $$\n$$ = (\\log(5) + \\log(13) + \\log(17)) - (\\log(7) + \\log(11) + \\log(19)) $$\n$$ = \\log(5 \\times 13 \\times 17) - \\log(7 \\times 11 \\times 19) $$\n$$ = \\log(1105) - \\log(1463) = \\log\\left(\\frac{1105}{1463}\\right) $$\n由于 $1105 < 1463$，该值为负。\n\n第三，我们解释其概念上的联系。恒等式 $\\psi(x;4,1) - \\psi(x;4,3) = \\psi(x,\\chi_1)$ 是关键的联系。它将两个算术级数中素数幂计数的差值（衡量“素数竞赛”的一个指标）与单个特征和等同起来。$\\psi(x,\\chi_1)$ 的行为与狄利克雷 $L$-函数 $L(s, \\chi_1) = \\sum_{n=1}^\\infty \\chi_1(n)n^{-s}$ 的解析性质密切相关。特征 $\\chi_1$ 是模 4 的本原二次特征。\n\n其中 $\\chi$ 是本原非主特征的 $\\psi(x,\\chi)$ 的显式公式由下式给出：\n$$ \\psi(x,\\chi) = -\\sum_{\\rho} \\frac{x^\\rho}{\\rho} + O(\\log(x)) $$\n其中求和遍及 $L$-函数 $L(s,\\chi_1)$ 在临界带 $0 < \\Re(s) < 1$ 中的所有非平凡零点 $\\rho=\\beta+i\\gamma$。\n\n因此，差值 $\\psi(x;4,1) - \\psi(x;4,3)$ 的符号由和式 $-\\sum_{\\rho} x^\\rho / \\rho$ 的符号决定。我们对 $x=20$ 的计算得出了一个负结果，这意味着对于 $x$ 的这个小值，模 4 同余于 3 的素数幂在“竞赛中获胜”。这种现象是被称为“切比雪夫偏倚”的一个例子。\n\n显式公式表明，这种偏倚并非巧合，而是由 $L(s,\\chi_1)$ 的零点 $\\rho$ 的具体位置所决定的。这些零点在素数分布的一个振荡公式中充当“频率”的角色。每个零点的贡献以及和式的符号都取决于 $x$。然而，$L(s,\\chi_1)$ 的零点分布使得和式 $-\\sum_\\rho x^\\rho / \\rho$ 对于大多数“较小”的 $x$ 值倾向于为负。这主要是因为最低的零点（即虚部 $|\\gamma|$ 最小的零点）往往在和式中占主导地位，并且它们对和式的初始贡献是负的。我们计算出的负值 $\\log(1105/1463)$，是这一深刻解析原理在 $x=20$ 处的直接数值体现。观测到的符号是 $L(s,\\chi_1)$ 的非平凡零点集体影响的结果。", "answer": "$$\\boxed{\\log\\left(\\frac{1105}{1463}\\right)}$$", "id": "3029741"}, {"introduction": "解析数论的巅峰成就之一是显式公式，它将素数的离散分布（通过 $\\psi(x)$ 体现）与黎曼Zeta函数 $\\zeta(s)$ 零点的连续分布精确地联系起来。这个练习要求你将这个深刻的理论结果转化为一个可执行的计算模型 [@problem_id:3029734]。通过编程实现截断的显式公式并与 $\\psi(x)$ 的精确值进行比较，你将能够直观地验证理论的威力，并理解Zeta函数的零点如何“编码”了素数分布的信息。", "problem": "你需要实现一个完整、可运行的程序，该程序使用一个从基本定义推导出的显式公式来估计第二切比雪夫函数 $\\psi(x)$，并将此显式公式的估计值与精确的算术和定义以及 $x$ 进行比较。该显式公式应从第一性原理推导得出，并使用黎曼ζ函数 $\\zeta(s)$ 的一组有限的已知非平凡零点，以截断的、数值稳定的形式实现。\n\n基本依据：\n- 定义冯·曼戈尔特函数 $\\Lambda(n)$：若 $n = p^k$（其中 $p$ 为素数，$k \\geq 1$ 为整数），则 $\\Lambda(n) = \\log p$；否则 $\\Lambda(n) = 0$。\n- 定义第二切比雪夫函数 $\\psi(x)$：对于实数 $x \\geq 1$，$\\psi(x) = \\sum_{n \\leq x} \\Lambda(n)$。\n- 对于 $\\operatorname{Re}(s) > 1$，使用其欧拉乘积和狄利克雷级数定义黎曼ζ函数 $\\zeta(s)$，并回顾在 $\\operatorname{Re}(s) > 1$ 上成立的、将对数导数与冯·曼戈尔特函数联系起来的著名恒等式：\n$$\n-\\frac{\\zeta'(s)}{\\zeta(s)} = \\sum_{n=1}^{\\infty} \\frac{\\Lambda(n)}{n^s}.\n$$\n- 回顾 $\\zeta(s)$ 的解析结构：在 $s=1$ 处有一个留数为 $1$ 的一阶极点，在负偶整数 $s=-2,-4,\\dots$ 处有平凡零点，以及在临界带 $0 < \\operatorname{Re}(s) < 1$ 内有非平凡零点 $\\rho$。你可以假设前几个非平凡零点位于临界线 $\\operatorname{Re}(\\rho)=\\tfrac{1}{2}$ 上，并且其值是高精度已知的。\n\n任务：\n1. 从关于 $-\\zeta'(s)/\\zeta(s)$ 的恒等式出发，通过佩龙公式和围道移动，推导出一个关于 $\\psi(x)$ 平滑版本的显式公式表达式。该表达式应以 $x$ 和 $-\\zeta'(s)/\\zeta(s)$ 奇点的贡献来表示。你的推导必须分别指明来自以下各项的贡献：\n   - $s=1$ 处的极点，\n   - $\\zeta(s)$ 的非平凡零点 $\\rho$，\n   - 负偶整数处的平凡零点，\n   - 以及由函数方程和 $\\zeta(s)$ 的解析性所确定的来自 $s=0$ 的项。\n   将其重构为一个可以使用有限个非平凡零点进行数值实现的截断形式。\n\n2. 为整数输入 $x \\geq 2$ 实现两个函数：\n   - 通过求和 $\\sum_{n \\leq x} \\Lambda(n)$ 对 $\\psi(x)$ 进行精确计算。为便于实践，将其构造为对素数幂的求和：对每个素数 $p \\leq x$，对于满足 $p^k \\leq x$ 的每个指数 $k \\geq 1$，都计入一次 $\\log p$。\n   - 使用前 $K$ 个非平凡零点 $\\rho$（按其虚部 $\\gamma$ 列出，其中 $\\rho=\\tfrac{1}{2} \\pm i\\gamma$）以及你在推导中确定的平凡零点贡献和常数项，对平滑的 $\\psi(x)$ 进行截断显式公式估计。通过将共轭零点配对，以数值稳定的方式实现对零点的求和。\n\n3. 在你的截断求和中使用以下有限集合，该集合包含 $\\zeta(s)$ 前几个非平凡零点的虚部（这些数值是复数零点的辐角，因此是无量纲的）：\n   $[14.134725141734693, 21.022039638771556, 25.010857580145688, 30.424876125859513, 32.935061587739190, 37.586178158825671, 40.918719012147495, 43.327073281693326, 48.005150881167159, 49.773832477672302, 52.970321477714460, 56.446247697063394, 59.347044002602353, 60.831778524609810, 65.112544048082656, 67.079810529494173, 69.546401711173, 72.06715767448191]$.\n\n4. 设计输出格式，用于比较 $\\psi(x)$ 与 $x$ 并评估显式公式的近似效果。对于每个测试用例 $x$，计算并返回列表 $[x, \\psi(x) - x, \\widehat{\\psi}(x) - x, |\\widehat{\\psi}(x) - \\psi(x)|]$，其中 $\\widehat{\\psi}(x)$ 表示你对平滑 $\\psi(x)$ 的截断显式公式估计值。\n\n测试套件：\n- 使用以下整数值 $x$ 来评估你的实现：\n  - $x = 1000$ (基准中等值)，\n  - $x = 10000$ (较大值)，\n  - $x = 100000$ (理想路径，更大规模)，\n  - $x = 131072$ (边界情况：一个素数幂，$2^{17}$)，\n  - $x = 999983$ (接近一百万，一个大素数)，\n  - $x = 1000000$ (中等范围的边缘)。\n\n答案格式：\n- 你的程序应生成单行输出，其中包含测试套件的结果，格式为一个由方括号括起来的逗号分隔列表。此顶层列表的每个元素本身都是一个形如 $[x, \\psi(x) - x, \\widehat{\\psi}(x) - x, |\\widehat{\\psi}(x) - \\psi(x)|]$ 的列表。例如，输出必须如下所示：\n  \"[[x1,exact_minus_x1,approx_minus_x1,error1],[x2,exact_minus_x2,approx_minus_x2,error2],...]\"。", "solution": "我们从在 $\\operatorname{Re}(s) > 1$ 上成立的基本恒等式开始：\n$$\n-\\frac{\\zeta'(s)}{\\zeta(s)} = \\sum_{n=1}^{\\infty} \\frac{\\Lambda(n)}{n^s}.\n$$\n根据佩龙公式，对于 $x \\geq 2$，$\\Lambda(n)$ 的求和函数的一个平滑版本可以写成 $-\\zeta'(s)/\\zeta(s)$ 与 $x^s/s$ 的乘积的复积分。一个标准方法是考虑\n$$\nI(x; c,T) = \\frac{1}{2\\pi i}\\int_{c-iT}^{c+iT} -\\frac{\\zeta'(s)}{\\zeta(s)} \\frac{x^s}{s}\\, ds,\n$$\n其中 $c>1$，然后将围道向左移动到一条 $\\operatorname{Re}(s) < 0$ 的竖直线上，并收集 $-\\zeta'(s)/\\zeta(s) \\cdot x^s/s$ 所有奇点的留数。函数 $-\\zeta'(s)/\\zeta(s)$ 具有以下奇点结构：\n- 在 $s=1$ 处有一个留数为 $1$ 的一阶极点（来自 $\\zeta(s)$ 的一阶极点），\n- 在 $\\zeta(s)$ 的非平凡零点 $s=\\rho$ 处有一阶极点，每个都在 $-\\zeta'/\\zeta$ 中贡献留数 $-1$，\n- 在平凡零点 $s=-2,-4,-6,\\dots$ 处有一阶极点，\n- 在 $s=0$ 处是一个正则点，但在考虑使用函数方程计算常数时会产生一个非平凡的贡献。\n\n移动围道并对留数求和，得到平滑的第二切比雪夫函数的黎曼显式公式，\n$$\n\\psi_0(x) = x - \\sum_{\\rho} \\frac{x^{\\rho}}{\\rho} - \\log(2\\pi) - \\frac{1}{2}\\log\\!\\left(1 - \\frac{1}{x^2}\\right),\n$$\n其中 $\\psi_0(x)$ 表示在不连续点处的对称平均值，\n$$\n\\psi_0(x) = \\frac{1}{2}\\left(\\lim_{\\varepsilon\\to 0^+} \\psi(x+\\varepsilon) + \\lim_{\\varepsilon\\to 0^+} \\psi(x-\\varepsilon)\\right).\n$$\n项 $x$ 是来自 $s=1$ 处极点的留数贡献。和式 $\\sum_{\\rho} x^{\\rho}/\\rho$ 是对 $\\zeta(s)$ 所有非平凡零点 $\\rho$ 的求和，来自 $s=\\rho$ 处的留数。常数 $-\\log(2\\pi)$ 可以通过使用 $\\zeta(s)$ 的函数方程并仔细考虑 $s=0$ 附近的贡献来推导。项 $-\\tfrac{1}{2}\\log(1-1/x^2)$ 来自负偶整数处的平凡零点，是通过围道积分计算中的一个几何级数恒等式得到的。\n\n一个可数值实现的截断只使用有限个非平凡零点。将复共轭零点配对（根据黎曼猜想，这些零点以 $\\rho=\\tfrac{1}{2} \\pm i\\gamma$ 的形式出现，其中 $\\gamma>0$，但一般情况下通过共轭性配对也成立）可得\n$$\n\\sum_{\\rho} \\frac{x^\\rho}{\\rho} = 2\\sum_{\\gamma>0} \\operatorname{Re}\\left( \\frac{x^{\\frac{1}{2}+i\\gamma}}{\\frac{1}{2}+i\\gamma} \\right),\n$$\n其中 $x^{\\frac{1}{2}+i\\gamma} = x^{1/2} e^{i\\gamma \\log x}$。截断至前 $K$ 个 $\\gamma$ 值可得\n$$\n\\widehat{\\psi}_0(x) = x - 2\\sum_{k=1}^{K} \\operatorname{Re}\\left( \\frac{x^{\\frac{1}{2}+i\\gamma_k}}{\\frac{1}{2}+i\\gamma_k} \\right) - \\log(2\\pi) - \\frac{1}{2}\\log\\!\\left(1 - \\frac{1}{x^2}\\right).\n$$\n当 $x$ 适度大时，这提供了一个实用的估计量。每个被忽略的零点所产生的截断误差量级大致为 $O\\!\\left(\\frac{\\sqrt{x}}{\\gamma_{K}}\\right)$，因此随着 $x$ 的增长，包含更多的零点可以提高准确性。注意，$\\psi(x)$ 是一个阶梯函数，在素数幂 $p^k$ 处有大小为 $\\Lambda(p^k)$ 的跳跃，而 $\\psi_0(x)$ 是跳跃点处的对称平均值。因此，即使使用很多零点，当 $x$ 恰好等于一个素数幂时，预计仍会有高达约 $\\tfrac{1}{2}\\Lambda(p^k)$ 的偏差。\n\n$\\psi(x)$ 的精确算术计算可以组织为对素数幂的求和：\n$$\n\\psi(x) = \\sum_{p \\le x} \\left\\lfloor \\frac{\\log x}{\\log p} \\right\\rfloor \\log p,\n$$\n该式对每个使得 $p^k \\le x$ 的指数 $k$ 计入一次 $\\log p$。从算法上讲，迭代幂次方更清晰：对于每个素数 $p\\le x$，计算 $p, p^2, p^3, \\dots$ 中有多少项是 $\\le x$ 的。\n\n算法设计：\n- 精确的 $\\psi(x)$：\n  1. 使用埃拉托斯特尼筛法生成所有 $\\le x$ 的素数。\n  2. 对每个素数 $p$，当 $m \\le x$ 时迭代 $m=p, p^2, \\dots$，并对每个 $m$ 累加一次 $\\log p$（这计算了 $\\Lambda(m)$ 的贡献）。\n- 截断显式公式估计：\n  1. 预加载一个包含前 $K$ 个非平凡零点虚部 $\\gamma_k$ 的列表。\n  2. 使用复数算术计算和式 $2\\sum_{k=1}^{K} \\operatorname{Re}\\left( x^{\\frac{1}{2}+i\\gamma_k}/(\\frac{1}{2}+i\\gamma_k) \\right)$，这样做是数值稳定的，因为 $|x^{\\frac{1}{2}+i\\gamma}|=x^{1/2}$ 且除以 $\\frac{1}{2}+i\\gamma$ 会通过 $|\\frac{1}{2}+i\\gamma|$ 进行衰减。\n  3. 通过加上极点项 $x$ 并减去零点和、常数 $-\\log(2\\pi)$ 和推导出的平凡零点项 $-\\tfrac{1}{2}\\log(1-1/x^2)$来构造 $\\widehat{\\psi}_0(x)$。\n- 比较指标：\n  1. 计算 $\\psi(x)-x$ 和 $\\widehat{\\psi}_0(x)-x$。\n  2. 报告绝对误差 $|\\widehat{\\psi}_0(x)-\\psi(x)|$。\n\n所提供的测试套件涵盖：\n- 一个基准中等值 $x=1000$，\n- 较大的值 $x=10000$ 和 $x=100000$，\n- 一个素数幂边界情况 $x=131072=2^{17}$（$\\psi(x)$ 在此有跳跃），\n- 一个接近 $10^6$ 的大素数 $x=999983$，\n- 一个中等范围的边缘值 $x=1000000$。\n\n最终程序应打印单行输出，该行是针对每个测试用例的列表 $[x, \\psi(x) - x, \\widehat{\\psi}(x) - x, |\\widehat{\\psi}(x) - \\psi(x)|]$ 的逗号分隔列表，并用方括号括起来，无额外文本。该行是程序产生的唯一输出。此处不适用任何物理单位；所有量均为无量纲实数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\nimport cmath\n\ndef primes_upto(n: int):\n    \"\"\"Return list of primes up to n using a memory-efficient sieve.\"\"\"\n    if n < 2:\n        return []\n    sieve = bytearray(b'\\x01') * (n + 1)\n    sieve[0:2] = b'\\x00\\x00'\n    limit = int(n**0.5)\n    for i in range(2, limit + 1):\n        if sieve[i]:\n            step = i\n            start = i * i\n            sieve[start:n+1:step] = b'\\x00' * (((n - start) // step) + 1)\n    return [i for i in range(2, n + 1) if sieve[i]]\n\ndef psi_exact(x: int) -> float:\n    \"\"\"Compute psi(x) = sum_{n <= x} Lambda(n) exactly via prime powers.\"\"\"\n    primes = primes_upto(x)\n    total = 0.0\n    for p in primes:\n        # Count contributions for prime powers p^k <= x\n        m = p\n        logp = math.log(p)\n        while m <= x:\n            total += logp\n            # Prevent overflow in multiplication for very large p (not relevant here)\n            if x // p < m:\n                break\n            m *= p\n    return total\n\ndef psi_explicit_approx(x: int, gammas: list[float]) -> float:\n    \"\"\"\n    Truncated explicit formula approximation for the smoothed psi(x):\n    psi0(x) ≈ x - 2 * sum_{gamma>0} Re( x^{1/2 + i gamma} / (1/2 + i gamma) )\n             - log(2*pi) - (1/2) * log(1 - x^{-2}).\n    \"\"\"\n    # Sum over paired zeros (use only positive gamma and double the real part)\n    sum_zeros = 0.0\n    ln_x = math.log(x)\n    for g in gammas:\n        denom = complex(0.5, g)\n        # x^{1/2 + i g} = x**0.5 * exp(i g log x)\n        x_rho = complex(x**0.5, 0.0) * cmath.exp(1j * g * ln_x)\n        term = x_rho / denom\n        sum_zeros += 2.0 * term.real\n    # Constant and trivial zeros contributions\n    const_term = math.log(2.0 * math.pi)\n    trivial_term = 0.5 * math.log(1.0 - (1.0 / (x * x)))\n    # Assemble approximation\n    psi0_hat = x - sum_zeros - const_term - trivial_term\n    return psi0_hat\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        1000,\n        10000,\n        100000,\n        131072,  # 2^17, prime-power boundary case\n        999983,  # a large prime near 1e6\n        1000000\n    ]\n\n    # Imaginary parts of the first several nontrivial zeros of zeta(s).\n    gammas = [\n        14.134725141734693,\n        21.022039638771556,\n        25.010857580145688,\n        30.424876125859513,\n        32.935061587739190,\n        37.586178158825671,\n        40.918719012147495,\n        43.327073281693326,\n        48.005150881167159,\n        49.773832477672302,\n        52.970321477714460,\n        56.446247697063394,\n        59.347044002602353,\n        60.831778524609810,\n        65.112544048082656,\n        67.079810529494173,\n        69.546401711173,\n        72.06715767448191,\n    ]\n\n    # A check in psi_exact to avoid overflow was added.\n    # It was `m *= p` and now it has a check `if x // p  m: break`\n    # This prevents overflow for large p and x, although not strictly needed for given constraints.\n    # Let's revert it for minimalism unless it's an outright error.\n    # `m` could exceed standard integer limits in some languages, but in Python it's fine.\n    # The original was `while m = x: total += logp; m *= p`. Let's analyze if it's better.\n    # The fix is `while m = x: total += logp; if x // p  m: break; m*=p`\n    # Let's say x=100, p=11. m=11, total+=log(11). now m becomes 121. The `while` loop terminates.\n    # with the fix: m=11. total+=log(11). x//p = 100//11 = 9. 9  11. break. No m*=p.\n    # So the fix is correct and safer. Let's keep the corrected psi_exact.\n    \n    original_psi_exact = psi_exact\n    \n    def safer_psi_exact(x: int) -> float:\n        primes = primes_upto(x)\n        total = 0.0\n        for p in primes:\n            logp = math.log(p)\n            m = p\n            while m = x:\n                total += logp\n                if x // p  m: # Avoid overflow for next multiplication\n                    break\n                m *= p\n        return total\n\n    results = []\n    for x in test_cases:\n        # Use the safer implementation. The change is minimal and improves robustness.\n        psi_x = safer_psi_exact(x)\n        # In the context of the problem, the difference between psi(x) and psi_0(x) for integer x\n        # is psi(x) = psi_0(x) + 0.5 * Lambda(x) if Lambda(x) != 0.\n        # The approximation psi_hat is for psi_0(x).\n        psi_hat_0 = psi_explicit_approx(x, gammas)\n        \n        lambda_x = 0\n        is_prime_power = False\n        if x > 1:\n            primes_for_x = primes_upto(int(x**0.5) + 1)\n            for p in primes_for_x:\n                if x % p == 0:\n                    temp_x = x\n                    while temp_x % p == 0:\n                        temp_x //= p\n                    if temp_x == 1:\n                        lambda_x = math.log(p)\n                    break\n            if lambda_x == 0: # Could be a prime\n                primes_x = primes_upto(x)\n                if x in primes_x:\n                     lambda_x = math.log(x)\n\n        # The problem asks for comparison with psi(x), not psi_0(x).\n        # We can estimate psi(x) as psi_hat_0 + 0.5 * lambda_x\n        # But the problem is simpler, it asks for `|widehat(psi)(x) - psi(x)|`\n        # `widehat(psi)` is the estimate for the smoothed function `psi_0`.\n        # So we just calculate `abs(psi_hat_0 - psi_x)`. This is fine.\n        \n        exact_minus_x = psi_x - x\n        approx_minus_x = psi_hat_0 - x\n        abs_err = abs(psi_hat_0 - psi_x)\n        results.append([x, exact_minus_x, approx_minus_x, abs_err])\n\n    # Final print statement in the exact required format.\n    # Single line with list of lists.\n    print(f\"[{','.join(str(item) for item in results)}]\")\n\nsolve()\n```", "id": "3029734"}]}