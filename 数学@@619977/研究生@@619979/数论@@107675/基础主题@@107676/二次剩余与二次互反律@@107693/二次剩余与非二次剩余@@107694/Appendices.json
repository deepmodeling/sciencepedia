{"hands_on_practices": [{"introduction": "理论学习之后，最有效的巩固方式莫过于亲手计算。本练习旨在通过直接计算勒让德符号，让你熟练掌握判断二次剩余与非剩余的核心技能。通过为一系列小素数寻找最小的正二次非剩余，你不仅能锻炼计算能力，还能对二次非剩余的分布建立直观的认识。[@problem_id:3021794]", "problem": "设 $p$ 是一个奇素数，对于整数 $a$，勒让德符号 $(\\frac{a}{p})$ 定义为：如果 $a$ 是模 $p$ 的二次剩余，则 $(\\frac{a}{p}) = 1$；如果 $a$ 是模 $p$ 的二次非剩余，则 $(\\frac{a}{p}) = -1$；如果 $p$ 整除 $a$，则 $(\\frac{a}{p}) = 0$。定义 $n(p)$ 为满足 $(\\frac{n}{p}) = -1$ 的最小正整数 $n \\geq 2$。对于集合 $P = \\{3, 5, 7, 11, 13, 17, 19, 23, 29, 31\\}$ 中的每个素数 $p$，仅使用勒让德符号的基本性质（包括欧拉判别法和二次互反律），通过从 $a=2$ 开始对连续整数 $a$ 直接计算 $(\\frac{a}{p})$ 的值，来确定一个明确的数值上界 $b_{p}$，使得 $n(p) \\leq b_{p}$。然后计算单个数值 $B = \\max_{p \\in P} b_{p}$。请以精确整数形式给出最终的 $B$ 值，无需四舍五入。", "solution": "用户要求我为一组给定的素数 $p$ 找到最小二次非剩余 $n(p)$。\n\n**问题分解：**\n\n1.  **定义 $n(p)$**：对于一个奇素数 $p$，$n(p)$ 是满足 $n$ 是模 $p$ 的二次非剩余的最小正整数 $n \\ge 2$。这意味着 $(\\frac{n}{p}) = -1$。\n2.  **素数集合**：$P = \\{3, 5, 7, 11, 13, 17, 19, 23, 29, 31\\}$。\n3.  **任务**：\n    *   对于每个素数 $p \\in P$，找到 $n(p)$。问题陈述将此称为找到一个上界 $b_p$ 使得 $n(p) \\leq b_p$。指定的方法是为 $a=2, 3, 4, ...$ 直接计算 $(\\frac{a}{p})$，直到找到一个非剩余。这意味着找到的第一个非剩余*就是* $n(p)$。所以，$b_p$ 就是 $n(p)$。\n    *   计算 $B = \\max_{p \\in P} n(p)$。\n4.  **工具**：\n    *   勒让德符号 $(\\frac{a}{p})$。\n    *   欧拉判别法（Euler's criterion）：$(\\frac{a}{p}) \\equiv a^{(p-1)/2} \\pmod p$。\n    *   二次互反律（Law of Quadratic Reciprocity, LQR）：对于不同的奇素数 $p, q$，$(\\frac{p}{q}) (\\frac{q}{p}) = (-1)^{((p-1)/2)((q-1)/2)}$。\n    *   勒让德符号的性质：\n        *   $(\\frac{ab}{p}) = (\\frac{a}{p})(\\frac{b}{p})$。\n        *   $(\\frac{a^2}{p}) = 1$ 如果 $p \\nmid a$。\n        *   $(\\frac{-1}{p}) = (-1)^{(p-1)/2}$。\n        *   $(\\frac{2}{p}) = (-1)^{(p^2-1)/8}$。\n\n**验证阶段：**\n\n1.  **提取已知条件**：\n    *   $p$ 是一个奇素数。\n    *   勒让德符号 $(\\frac{a}{p})$ 定义为：二次剩余为 $1$，二次非剩余为 $-1$，当 $p|a$ 时为 $0$。\n    *   $n(p)$ 是满足 $(\\frac{n}{p}) = -1$ 的最小正整数 $n \\ge 2$。\n    *   $b_p$ 是 $n(p)$ 的一个上界，通过找到第一个非剩余来确定。所以 $b_p = n(p)$。\n    *   $P = \\{3, 5, 7, 11, 13, 17, 19, 23, 29, 31\\}$。\n    *   $B = \\max_{p \\in P} b_p$。\n    *   要使用的工具是“勒让德符号的基本性质，包括欧拉判别法和二次互反律”。\n    *   方法是从 $a=2$ 开始为连续整数 $a$ 计算 $(\\frac{a}{p})$ 的值。\n\n2.  **验证**：\n    *   **科学性**：是的，这个问题牢固地建立在数论——数学的一个分支——之上。二次剩余、勒让德符号、欧拉判别法和二次互反律等概念都是标准的、成熟的。\n    *   **适定性**：是的。对于任何奇素数 $p$，恰好有 $(p-1)/2$个二次非剩余，因此最小正非剩余 $n(p)$ 必然存在。集合 $P$ 是有限的，所以最大值 $B$ 也必然存在且唯一。该过程是明确定义的。\n    *   **客观性**：是的，语言是精确和数学化的。\n    *   **科学或事实上的不健全**：无。\n    *   **非形式化或不相关**：该问题是形式化的，并且与数论相关。\n    *   **不完整或矛盾的设置**：设置是完整和一致的。陈述“确定明确的数值上界 $b_p$，满足 $n(p) \\leq b_p$”可能看起来有点复杂，但接下来的部分阐明了这是通过“对连续整数a...直接计算 $(\\frac{a}{p})$”来完成的。这意味着我们为 $a \\geq 2$ 找到的第一个非剩余就是 $n(p)$。所以，我们只是在为每个 $p$ 找到 $n(p)$，并且我们可以设 $b_p=n(p)$。这个问题没有矛盾。\n    *   **不切实际或不可行**：计算是可行的。\n    *   **不适定或结构不良**：不，问题结构良好。\n    *   **伪深刻、琐碎或同义反复**：不，这是初等数论中的一个标准计算问题。\n    *   **超出科学可验证性**：结果是数学上可验证的。\n\n**结论**：该问题是有效的。\n\n**求解阶段 - 逐步计算：**\n\n我需要为每个 $p \\in P$ 找到 $n(p)$。我将按顺序检查 $a=2, 3, 4, ...$。\n\n*   **对于 $p=3$**：\n    *   我们需要最小的 $n \\ge 2$ 使得 $(\\frac{n}{3}) = -1$。\n    *   我们检查 $n=2$。\n    *   $(\\frac{2}{3})$。使用规则 $(\\frac{2}{p}) = (-1)^{(p^2-1)/8}$：\n        *   $(\\frac{2}{3}) = (-1)^{(3^2-1)/8} = (-1)^{8/8} = (-1)^1 = -1$。\n    *   所以，$n(3) = 2$。令 $b_3 = 2$。\n\n*   **对于 $p=5$**：\n    *   我们需要最小的 $n \\ge 2$ 使得 $(\\frac{n}{5}) = -1$。\n    *   检查 $n=2$：$(\\frac{2}{5}) = (-1)^{(5^2-1)/8} = (-1)^{24/8} = (-1)^3 = -1$。\n    *   所以，$n(5) = 2$。令 $b_5 = 2$。\n\n*   **对于 $p=7$**：\n    *   我们需要最小的 $n \\ge 2$ 使得 $(\\frac{n}{7}) = -1$。\n    *   检查 $n=2$：$(\\frac{2}{7}) = (-1)^{(7^2-1)/8} = (-1)^{48/8} = (-1)^6 = 1$。所以 $2$ 是模 $7$ 的二次剩余。\n    *   检查 $n=3$：$(\\frac{3}{7})$。使用二次互反律：\n        *   $(\\frac{3}{7})(\\frac{7}{3}) = (-1)^{((3-1)/2)((7-1)/2)} = (-1)^{(1)(3)} = -1$。\n        *   $(\\frac{7}{3}) = (\\frac{1}{3}) = 1$。\n        *   所以，$(\\frac{3}{7}) \\cdot 1 = -1 \\implies (\\frac{3}{7}) = -1$。\n    *   所以，$n(7) = 3$。令 $b_7 = 3$。\n\n*   **对于 $p=11$**：\n    *   我们需要最小的 $n \\ge 2$ 使得 $(\\frac{n}{11}) = -1$。\n    *   检查 $n=2$：$(\\frac{2}{11}) = (-1)^{(11^2-1)/8} = (-1)^{120/8} = (-1)^{15} = -1$。\n    *   所以，$n(11) = 2$。令 $b_{11} = 2$。\n\n*   **对于 $p=13$**：\n    *   我们需要最小的 $n \\ge 2$ 使得 $(\\frac{n}{13}) = -1$。\n    *   检查 $n=2$：$(\\frac{2}{13}) = (-1)^{(13^2-1)/8} = (-1)^{168/8} = (-1)^{21} = -1$。\n    *   所以，$n(13) = 2$。令 $b_{13} = 2$。\n\n*   **对于 $p=17$**：\n    *   我们需要最小的 $n \\ge 2$ 使得 $(\\frac{n}{17}) = -1$。\n    *   检查 $n=2$：$(\\frac{2}{17}) = (-1)^{(17^2-1)/8} = (-1)^{288/8} = (-1)^{36} = 1$。所以 $2$ 是模 $17$ 的二次剩余。\n    *   检查 $n=3$：$(\\frac{3}{17})$。使用二次互反律：\n        *   $(\\frac{3}{17})(\\frac{17}{3}) = (-1)^{((3-1)/2)((17-1)/2)} = (-1)^{(1)(8)} = 1$。\n        *   $(\\frac{17}{3}) = (\\frac{17 \\pmod 3}{3}) = (\\frac{2}{3}) = -1$。\n        *   所以，$(\\frac{3}{17}) \\cdot (-1) = 1 \\implies (\\frac{3}{17}) = -1$。\n    *   所以，$n(17) = 3$。令 $b_{17} = 3$。\n\n*   **对于 $p=19$**：\n    *   我们需要最小的 $n \\ge 2$ 使得 $(\\frac{n}{19}) = -1$。\n    *   检查 $n=2$：$(\\frac{2}{19}) = (-1)^{(19^2-1)/8} = (-1)^{360/8} = (-1)^{45} = -1$。\n    *   所以，$n(19) = 2$。令 $b_{19} = 2$。\n\n*   **对于 $p=23$**：\n    *   我们需要最小的 $n \\ge 2$ 使得 $(\\frac{n}{23}) = -1$。\n    *   检查 $n=2$：$(\\frac{2}{23}) = (-1)^{(23^2-1)/8} = (-1)^{528/8} = (-1)^{66} = 1$。所以 $2$ 是模 $23$ 的二次剩余。\n    *   检查 $n=3$：$(\\frac{3}{23})$。使用二次互反律：\n        *   $(\\frac{3}{23})(\\frac{23}{3}) = (-1)^{((3-1)/2)((23-1)/2)} = (-1)^{(1)(11)} = -1$。\n        *   $(\\frac{23}{3}) = (\\frac{2}{3}) = -1$。\n        *   所以，$(\\frac{3}{23}) \\cdot (-1) = -1 \\implies (\\frac{3}{23}) = 1$。所以 $3$ 是模 $23$ 的二次剩余。\n    *   检查 $n=4$：$4 = 2^2$，所以 $(\\frac{4}{23}) = (\\frac{2^2}{23}) = 1$。\n    *   检查 $n=5$：$(\\frac{5}{23})$。使用二次互反律：\n        *   $(\\frac{5}{23})(\\frac{23}{5}) = (-1)^{((5-1)/2)((23-1)/2)} = (-1)^{(2)(11)} = 1$。\n        *   $(\\frac{23}{5}) = (\\frac{3}{5})$。\n        *   $(\\frac{3}{5})(\\frac{5}{3}) = (-1)^{((3-1)/2)((5-1)/2)} = (-1)^{(1)(2)} = 1$。\n        *   $(\\frac{5}{3}) = (\\frac{2}{3}) = -1$。\n        *   所以，$(\\frac{3}{5}) \\cdot (-1) = 1 \\implies (\\frac{3}{5}) = -1$。\n        *   回到 $(\\frac{5}{23})(\\frac{23}{5}) = 1$，我们有 $(\\frac{5}{23})(\\frac{3}{5}) = 1$，所以 $(\\frac{5}{23})(-1) = 1 \\implies (\\frac{5}{23}) = -1$。\n    *   所以，$n(23) = 5$。令 $b_{23} = 5$。\n\n*   **对于 $p=29$**：\n    *   我们需要最小的 $n \\ge 2$ 使得 $(\\frac{n}{29}) = -1$。\n    *   检查 $n=2$：$(\\frac{2}{29}) = (-1)^{(29^2-1)/8} = (-1)^{840/8} = (-1)^{105} = -1$。\n    *   所以，$n(29) = 2$。令 $b_{29} = 2$。\n\n*   **对于 $p=31$**：\n    *   我们需要最小的 $n \\ge 2$ 使得 $(\\frac{n}{31}) = -1$。\n    *   检查 $n=2$：$(\\frac{2}{31}) = (-1)^{(31^2-1)/8} = (-1)^{960/8} = (-1)^{120} = 1$。所以 $2$ 是模 $31$ 的二次剩余。\n    *   检查 $n=3$：$(\\frac{3}{31})$。使用二次互反律：\n        *   $(\\frac{3}{31})(\\frac{31}{3}) = (-1)^{((3-1)/2)((31-1)/2)} = (-1)^{(1)(15)} = -1$。\n        *   $(\\frac{31}{3}) = (\\frac{1}{3}) = 1$。\n        *   所以，$(\\frac{3}{31}) \\cdot 1 = -1 \\implies (\\frac{3}{31}) = -1$。\n    *   所以，$n(31) = 3$。令 $b_{31} = 3$。\n\n**$n(p)$ 值（即 $b_p$ 值）总结：**\n*   $n(3) = 2$\n*   $n(5) = 2$\n*   $n(7) = 3$\n*   $n(11) = 2$\n*   $n(13) = 2$\n*   $n(17) = 3$\n*   $n(19) = 2$\n*   $n(23) = 5$\n*   $n(29) = 2$\n*   $n(31) = 3$\n\n**最终计算**：\n现在，我需要计算 $B = \\max_{p \\in P} b_p = \\max_{p \\in P} n(p)$。\n$n(p)$ 值的集合是 $\\{2, 2, 3, 2, 2, 3, 2, 5, 2, 3\\}$。\n此集合中的最大值是 $5$。\n所以，$B=5$。", "answer": "$$\n\\boxed{5}\n$$", "id": "3021794"}, {"introduction": "掌握了素数模下的情况后，一个自然的问题是：当模是合数时，二次同余方程会有怎样的表现？这个练习将引导你将单个素数模的知识与中国剩余定理（$CRT$）结合起来，推导出模为两个不同奇素数之积 $n=pq$ 时二次同余方程解的精确个数。这个过程不仅是理论的深化，也是理解许多现代密码学方案（如 Rabin 密码系统）背后数论原理的关键一步。[@problem_id:3021799]", "problem": "设 $p$ 和 $q$ 是不同的奇素数，且 $n = pq$。对于 $a \\in \\mathbb{Z}$，考虑同余式 $x^{2} \\equiv a \\pmod{n}$。从奇素数模下的二次剩余的定义以及中国剩余定理（CRT）出发，推导在以下两种情况下同余式 $x^{2} \\equiv a \\pmod{n}$ 的解 $x \\in \\mathbb{Z}/n\\mathbb{Z}$ 的确切数量：\n\n- 情况（i）：$\\gcd(a,n) = 1$（即，$a$ 是模 $n$ 的一个单位）。\n- 情况（ii）：$p \\mid a$ 且 $q \\nmid a$。\n\n您的推导必须是明确且自洽的，从以下基本事实开始：对于一个奇素数 $r$，同余式 $x^{2} \\equiv b \\pmod{r}$ 在 $\\mathbb{Z}/r\\mathbb{Z}$ 中有零个、一个或两个解，这分别取决于 $b \\equiv 0 \\pmod{r}$、 $b$ 是模 $r$ 的二次剩余，还是 $b$ 是模 $r$ 的二次非剩余；以及中国剩余定理（CRT）确立了 $\\mathbb{Z}/n\\mathbb{Z} \\cong \\mathbb{Z}/p\\mathbb{Z} \\times \\mathbb{Z}/q\\mathbb{Z}$。使用勒让德符号 $\\left( \\frac{a}{p} \\right)$ 和 $\\left( \\frac{a}{q} \\right)$ 以闭式形式表示您的最终答案。不需要进行数值近似。", "solution": "该问题要求在 $a \\in \\mathbb{Z}$ 的两种不同条件下，求解同余式 $x^2 \\equiv a \\pmod{n}$ 的解的数量，其中 $n=pq$，$p$ 和 $q$ 是不同的奇素数。推导将基于指定的基本原理：中国剩余定理（CRT）和奇素数模二次剩余的性质。\n\n设 $N$ 表示解 $x \\in \\mathbb{Z}/n\\mathbb{Z}$ 的数量。同余式 $x^2 \\equiv a \\pmod{n}$ 等价于以下同余方程组：\n$$\n\\begin{cases}\nx^2 \\equiv a \\pmod{p} \\\\\nx^2 \\equiv a \\pmod{q}\n\\end{cases}\n$$\n中国剩余定理建立了一个环同构 $\\mathbb{Z}/n\\mathbb{Z} \\cong \\mathbb{Z}/p\\mathbb{Z} \\times \\mathbb{Z}/q\\mathbb{Z}$。这意味着对于每一对解 $(x_p, x_q)$，其中 $x_p$ 是第一个同余式的解，$x_q$ 是第二个同余式的解，都存在一个唯一的解 $x \\pmod{n}$ 同时满足两者。因此，总解数 $N$ 是每个独立同余式解数的乘积。设 $N_p$ 为 $x^2 \\equiv a \\pmod{p}$ 的解数，$N_q$ 为 $x^2 \\equiv a \\pmod{q}$ 的解数。则 $N = N_p \\times N_q$。\n\n对于奇素数 $r$，我们已知同余式 $x^2 \\equiv b \\pmod{r}$ 的解数规则。这个数量可以用勒让德符号 $\\left(\\frac{b}{r}\\right)$ 方便地表示。勒让德符号定义为：\n$$\n\\left(\\frac{b}{r}\\right) =\n\\begin{cases}\n1 & \\text{如果 } b \\text{ 是模 } r \\text{ 的二次剩余且 } r \\nmid b \\\\\n-1 & \\text{如果 } b \\text{ 是模 } r \\text{ 的二次非剩余} \\\\\n0 & \\text{如果 } r \\mid b\n\\end{cases}\n$$\n$x^2 \\equiv b \\pmod{r}$ 的解数恰好为 $1 + \\left(\\frac{b}{r}\\right)$。该公式对所有三种情况都成立：\n- 如果 $b$ 是模 $r$ 的二次剩余，则有 $2$ 个解，且 $1 + \\left(\\frac{b}{r}\\right) = 1 + 1 = 2$。\n- 如果 $b$ 是模 $r$ 的二次非剩余，则有 $0$ 个解，且 $1 + \\left(\\frac{b}{r}\\right) = 1 + (-1) = 0$。\n- 如果 $r \\mid b$，则有 $1$ 个解（$x \\equiv 0 \\pmod{r}$），且 $1 + \\left(\\frac{b}{r}\\right) = 1 + 0 = 1$。\n\n将此应用于我们的系统，我们得到 $N_p = 1 + \\left(\\frac{a}{p}\\right)$ 和 $N_q = 1 + \\left(\\frac{a}{q}\\right)$。\n因此，$x^2 \\equiv a \\pmod{n}$ 的总解数由以下通用公式给出：\n$$\nN = \\left(1 + \\left(\\frac{a}{p}\\right)\\right) \\left(1 + \\left(\\frac{a}{q}\\right)\\right)\n$$\n我们现在使用这个公式分析指定的两种情况。\n\n情况（i）：$\\gcd(a, n) = 1$。\n条件 $\\gcd(a, n) = 1$ 等价于 $\\gcd(a, pq) = 1$。由于 $p$ 和 $q$ 是素数，这意味着 $p \\nmid a$ 且 $q \\nmid a$。\n因此，$a \\not\\equiv 0 \\pmod{p}$ 且 $a \\not\\equiv 0 \\pmod{q}$。\n这意味着勒让德符号 $\\left(\\frac{a}{p}\\right)$ 和 $\\left(\\frac{a}{q}\\right)$ 不可能为 $0$；它们必须是 $1$ 或 $-1$。\n解数 $N$ 直接由我们的通用公式给出。不需要进一步简化，因为该表达式根据 $a$ 相对于 $p$ 和 $q$ 的二次特征提供了确切的解数。\n解的数量为 $N = \\left(1 + \\left(\\frac{a}{p}\\right)\\right) \\left(1 + \\left(\\frac{a}{q}\\right)\\right)$。\n例如，如果 $a$ 同时是模 $p$ 和模 $q$ 的二次剩余，则 $\\left(\\frac{a}{p}\\right) = 1$ 且 $\\left(\\frac{a}{q}\\right) = 1$，所以 $N = (1+1)(1+1) = 4$。如果 $a$ 是模 $p$ 或模 $q$ （或两者）的二次非剩余，则至少有一个因子是 $1-1=0$，使得 $N=0$。\n\n情况（ii）：$p \\mid a$ 且 $q \\nmid a$。\n我们再次使用 $N$ 的通用公式。\n条件 $p \\mid a$ 表明 $a \\equiv 0 \\pmod{p}$。根据勒让德符号的定义，这意味着 $\\left(\\frac{a}{p}\\right) = 0$。\n$x^2 \\equiv a \\pmod{p}$ 的解数为 $N_p = 1 + \\left(\\frac{a}{p}\\right) = 1 + 0 = 1$。这对应于唯一的解 $x \\equiv 0 \\pmod{p}$。\n条件 $q \\nmid a$ 表明 $a \\not\\equiv 0 \\pmod{q}$。因此，勒让德符号 $\\left(\\frac{a}{q}\\right)$ 为 $1$ 或 $-1$。\n$x^2 \\equiv a \\pmod{q}$ 的解数为 $N_q = 1 + \\left(\\frac{a}{q}\\right)$。如果 $a$ 是模 $q$ 的二次剩余，则其值为 $2$；如果 $a$ 是模 $q$ 的二次非剩余，则其值为 $0$。\n总解数是乘积 $N = N_p \\times N_q$。\n代入 $N_p$ 和 $N_q$ 的值：\n$$\nN = 1 \\times \\left(1 + \\left(\\frac{a}{q}\\right)\\right) = 1 + \\left(\\frac{a}{q}\\right)\n$$\n这是此情况下解数的最终闭式表达式。如果 $\\left(\\frac{a}{q}\\right) = 1$，解数为 $2$；如果 $\\left(\\frac{a}{q}\\right) = -1$，解数为 $0$。", "answer": "$$\n\\boxed{\\begin{pmatrix} \\left(1 + \\left(\\frac{a}{p}\\right)\\right) \\left(1 + \\left(\\frac{a}{q}\\right)\\right) & 1 + \\left(\\frac{a}{q}\\right) \\end{pmatrix}}\n$$", "id": "3021799"}, {"introduction": "我们已经知道如何判断解的存在性并计算其个数，但如何高效地找到这些解呢？本练习将带你探索 Cipolla 算法，这是一个在有限域中计算平方根的优雅而强大的方法。这个高级实践完美地展示了抽象的代数结构（特别是二次域扩张 $\\mathbb{F}_{p^2}$）如何为具体的数论问题提供出人意料的有效解法，深刻体现了理论与实践的结合。[@problem_id:3021789]", "problem": "设 $p$ 为一个奇素数，并设 $\\mathbb{F}_{p}$ 表示具有 $p$ 个元素的有限域。如果存在 $x \\in \\mathbb{F}_{p}$ 使得 $x^2 \\equiv a \\pmod{p}$，则元素 $a \\in \\mathbb{F}_{p}$ 称为模 $p$ 的二次剩余。对于 $a \\in \\mathbb{F}_{p}^{\\times}$，勒让德符号 $\\left( \\frac{a}{p} \\right)$ 定义为：如果 $a$ 是二次剩余，则 $\\left( \\frac{a}{p} \\right) = 1$；否则 $\\left( \\frac{a}{p} \\right) = -1$。此外，定义 $\\left( \\frac{0}{p} \\right) = 0$。欧拉准则断言，对于 $a \\in \\mathbb{F}_{p}^{\\times}$，有 $a^{(p-1)/2} \\equiv \\left( \\frac{a}{p} \\right) \\pmod{p}$。\n\n从有限域、二次剩余、欧拉准则和弗罗贝尼乌斯自同态的基本性质出发，推导一个算法。当 $a$ 是模 $p$ 的二次剩余时，该算法通过在二次扩域 $\\mathbb{F}_{p^2}$ 中进行运算来计算 $a$ 的平方根。此二次扩域 $\\mathbb{F}_{p^2}$ 是通过在 $\\mathbb{F}_{p}$ 上添加一个在 $\\mathbb{F}_{p}$ 上不可约的二次多项式的根来构造的。您的推导必须从核心定义和定律开始，进而得出一个完整且逻辑上严谨的方法，该方法将提取 $\\mathbb{F}_{p}$ 中平方根的问题转化为在 $\\mathbb{F}_{p^2}$ 内的求幂问题。您必须纯粹从特征为 $p$ 的域论第一性原理（包括弗罗贝尼乌斯自同态在 $\\mathbb{F}_{p^2}$ 上的作用）来证明您方法的正确性，并论证为何当 $a$ 是二次剩余时，输出结果位于 $\\mathbb{F}_{p}$ 中。\n\n在 $\\mathbb{Z}/p\\mathbb{Z}$ 算术的标准位复杂度模型下，分析您算法的期望运行时间，并通过量化找到合适的二次非剩余所需的期望试验次数以及在 $\\mathbb{F}_{p^2}$ 中求幂的成本，证明该算法的期望运行时间是 $\\log p$ 的多项式时间。\n\n然后，将推导出的算法实现为一个程序。该程序必须：\n- 不接受任何输入，并使用以下固定的 $(a,p)$ 对（其中 $p$ 为奇素数）测试套件：\n  1. $(0,3)$，\n  2. $(2,3)$，\n  3. $(10,13)$，\n  4. $(2,13)$，\n  5. $(643499475,1000000007)$，\n  6. $(5,11)$，\n  7. $(3,11)$。\n- 对每个测试用例，如果存在，则计算 $a$ 模 $p$ 的一个平方根 $r \\in \\{0,1,\\dots,p-1\\}$。当 $a \\neq 0$ 时，输出两个根 $r$ 和 $p-r$ 中较小的一个。如果 $\\mathbb{F}_{p}$ 中不存在平方根，则输出 $-1$。对于 $a=0$ 的情况，输出 $0$。\n- 生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表，顺序与测试套件相同，且无空格。例如，格式必须类似于“[r_1,r_2,\\dots,r_7]”，其中每个 $r_i$ 是第 $i$ 个测试用例的整数结果。\n\n您的推理必须避免启发式捷径，并且必须基于所述的定义和性质基础。不涉及任何物理量，也没有角度单位。测试套件中的所有数值答案都是整数。最终程序的输出必须符合上述指定的精确单行格式。", "solution": "本题要求推导、复杂度分析并实现一个算法，用于在有限域 $\\mathbb{F}_{p}$（其中 $p$ 是奇素数）中寻找数 $a$ 的平方根。该方法必须基于二次扩域 $\\mathbb{F}_{p^2}$ 中的算术。所讨论的算法通常称为 Cipolla 算法。\n\n首先，我们必须确定 $a \\in \\mathbb{F}_p$ 的平方根是否存在。元素 $a=0$ 有唯一的平方根 $x=0$。对于非零元素 $a \\in \\mathbb{F}_p^\\times$，其平方根存在的充要条件是 $a$ 是模 $p$ 的二次剩余。这可以通过欧拉准则高效地检验，该准则指出 $\\left( \\frac{a}{p} \\right) \\equiv a^{(p-1)/2} \\pmod p$。如果 $a^{(p-1)/2} \\equiv 1 \\pmod p$，则 $a$ 是二次剩余。如果 $a^{(p-1)/2} \\equiv -1 \\pmod p$，则 $a$ 是二次非剩余，在 $\\mathbb{F}_p$ 中不存在平方根。\n\n假设 $a$ 是一个非零的二次剩余，我们继续寻找其平方根。\n\n**1. 算法推导**\n\n核心思想是在一个扩域 $\\mathbb{F}_{p^2}$ 中找到一个元素，其平方为 $a$，然后证明该元素必位于基域 $\\mathbb{F}_p$ 中。\n\n**1.1. 构造域扩张 $\\mathbb{F}_{p^2}$**\n二次扩域 $\\mathbb{F}_{p^2}$ 可以构造为商环 $\\mathbb{F}_p[x] / (f(x))$，其中 $f(x)$ 是 $\\mathbb{F}_p$ 上的一个不可约二次多项式。对此类多项式的一个简单选择是 $f(x) = x^2 - n$，其中 $n$ 是 $\\mathbb{F}_p$ 中的一个二次非剩余。如果 $x^2-n$ 在 $\\mathbb{F}_p$ 中没有根，则其不可约性得到保证，这当且仅当 $n$ 不是 $\\mathbb{F}_p$ 中的平方数，即 $n$ 是一个二次非剩余。我们将 $\\mathbb{F}_{p^2}$ 表示为元素集合 $\\{u + v\\omega \\mid u, v \\in \\mathbb{F}_p\\}$，其中 $\\omega$ 是 $x^2-n$ 的一个形式根，因此 $\\omega^2 = n$。\n\n该算法首先找到一个元素 $t \\in \\mathbb{F}_p$，使得 $n = t^2 - a$ 是一个二次非剩余。这样的 $t$ 保证存在，并且可以通过随机选择 $t$ 的值并使用欧拉准则测试 $\\left(\\frac{t^2-a}{p}\\right) = -1$ 来高效地找到。在 $n = t^2 - a$ 是非剩余的情况下，我们构造 $\\mathbb{F}_{p^2} \\cong \\mathbb{F}_p[x] / (x^2 - n)$。\n\n**1.2. 平方根公式**\n该算法断言，$a$ 的一个平方根由 $\\mathbb{F}_{p^2}$ 中的元素 $x = (t + \\omega)^{(p+1)/2}$ 给出。我们必须证明两件事：第一，$x^2 = a$；第二，$x \\in \\mathbb{F}_p$。\n\n**证明 $x^2 = a$：**\n我们计算 $x^2$：\n$$x^2 = \\left((t + \\omega)^{(p+1)/2}\\right)^2 = (t + \\omega)^{p+1} = (t + \\omega)^p (t + \\omega)$$\n为了计算 $(t + \\omega)^p$，我们使用特征为 $p$ 的域中弗罗贝尼乌斯自同态 $\\phi(z) = z^p$ 的性质。对于任意 $u, v \\in \\mathbb{F}_p$，我们有 $(u+v)^p = u^p + v^p$。由于 $\\mathbb{F}_p$ 的元素被弗罗贝尼乌斯映射固定（根据费马小定理，$u^p=u$），我们有：\n$$(t + \\omega)^p = t^p + \\omega^p = t + \\omega^p$$\n现在我们必须计算 $\\omega^p$。我们知道 $\\omega^2 = n$。\n$$\\omega^p = \\omega \\cdot \\omega^{p-1} = \\omega \\cdot (\\omega^2)^{(p-1)/2} = \\omega \\cdot n^{(p-1)/2}$$\n根据我们对 $n=t^2-a$ 的选择，它是模 $p$ 的二次非剩余。因此，根据欧拉准则，$n^{(p-1)/2} \\equiv -1 \\pmod{p}$。\n将此代回，我们得到 $\\omega^p = \\omega \\cdot (-1) = -\\omega$。\n因此，弗罗贝尼乌斯自同态作用于我们的元素的结果是 $(t + \\omega)^p = t - \\omega$。\n现在我们可以完成 $x^2$ 的计算：\n$$x^2 = (t - \\omega)(t + \\omega) = t^2 - \\omega^2$$\n根据 $\\omega$ 的定义，我们有 $\\omega^2 = n = t^2 - a$。\n$$x^2 = t^2 - (t^2 - a) = a$$\n这证明了 $x = (t + \\omega)^{(p+1)/2}$ 确实是 $a$ 在域 $\\mathbb{F}_{p^2}$ 中的一个平方根。\n\n**证明 $x \\in \\mathbb{F}_p$：**\n扩域 $\\mathbb{F}_{p^2}$ 的一个元素 $z$ 属于基域 $\\mathbb{F}_p$ 的充要条件是它被弗罗贝尼乌斯自同态固定，即 $z^p = z$。让我们计算 $x^p$：\n$$x^p = \\left((t + \\omega)^{(p+1)/2}\\right)^p = ((t+\\omega)^p)^{(p+1)/2}$$\n我们已经证明 $(t+\\omega)^p = t - \\omega$。所以，\n$$x^p = (t - \\omega)^{(p+1)/2}$$\n为了证明这等于 $x$，考虑到 $(t - \\omega)(t + \\omega) = t^2 - \\omega^2 = a$。因此，$t-\\omega = a(t+\\omega)^{-1}$。\n$$x^p = \\left(a(t+\\omega)^{-1}\\right)^{(p+1)/2} = a^{(p+1)/2} \\cdot \\left((t+\\omega)^{-1}\\right)^{(p+1)/2} = a^{(p+1)/2} \\cdot \\left((t+\\omega)^{(p+1)/2}\\right)^{-1} = a^{(p+1)/2} \\cdot x^{-1}$$\n我们有 $a^{(p+1)/2} = a \\cdot a^{(p-1)/2}$。由于 $a$ 是二次剩余，$a^{(p-1)/2} = 1$。所以，$a^{(p+1)/2} = a$。\n这给出 $x^p = a \\cdot x^{-1}$。两边乘以 $x$，得到 $x^{p+1} = a$。\n这并非我们直接需要的。让我们用一个更直接的方法。我们已经证明 $x^2=a$。因此，$x^{p-1} = (x^2)^{(p-1)/2} = a^{(p-1)/2}$。由于 $a$ 是二次剩余，$a^{(p-1)/2}=1$。因此，$x^{p-1}=1$。两边乘以 $x$（因为 $a \\neq 0$，所以 $x \\neq 0$），我们得到 $x^p = x$。这证实了 $x$ 位于基域 $\\mathbb{F}_p$ 中。\n\n因此，该算法正确地计算了 $a$ 在 $\\mathbb{F}_p$ 中的一个平方根。另一个根是 $-x \\equiv p-x \\pmod p$。\n\n**2. 复杂度分析**\n\n该算法包括三个主要步骤：\n1.  检查 $a$ 是否是二次剩余。\n2.  找到一个元素 $t$ 使得 $n = t^2 - a$ 是一个二次非剩余。\n3.  在 $\\mathbb{F}_{p^2}$ 中进行一次求幂运算。\n\n复杂度在标准位复杂度模型下进行分析，其中大小为 $p$ 的整数上的算术运算所需时间是 $\\log p$ 的多项式。模 $p$ 的一次乘法或除法需要 $O((\\log p)^2)$ 的时间。\n\n**步骤 1:** 通过 $a^{(p-1)/2} \\pmod p$ 检验 $\\left(\\frac{a}{p}\\right)$ 需要模幂运算，这可以在 $O(\\log((p-1)/2)) = O(\\log p)$ 次模乘法内完成。此步骤的总时间为 $O((\\log p)^3)$。\n\n**步骤 2:** 寻找 $t$。我们遍历 $t=1, 2, 3, \\dots$，计算 $n=t^2-a$，并使用欧拉准则检查 $n$ 是否是非剩余。使得 $t^2-a$ 是二次非剩余的 $t \\in \\mathbb{F}_p$ 的值的数量是 $N_{-1} = (p-1)/2$。这意味着随机选择的 $t$ 成功的概率是 $N_{-1}/p = (p-1)/(2p) \\approx 1/2$。因此，找到一个合适的 $t$ 的期望试验次数约为 $2$。\n每次试验涉及一次平方、一次减法和一次模幂运算以检验 $n$。每次试验的成本主要由求幂运算主导，耗时 $O((\\log p)^3)$。因此，此步骤的期望时间为 $O((\\log p)^3)$。\n\n**步骤 3:** 在 $\\mathbb{F}_{p^2}$ 中求幂。我们计算 $x=(t+\\omega)^{(p+1)/2}$。这是在 $\\mathbb{F}_{p^2}$ 中的一次模幂运算，指数大小为 $O(p)$，需要 $O(\\log p)$ 次 $\\mathbb{F}_{p^2}$ 中的乘法。\n$\\mathbb{F}_{p^2}$ 中的一次算术运算比 $\\mathbb{F}_p$ 中的成本更高。两个元素 $(u_1 + v_1\\omega)$ 和 $(u_2 + v_2\\omega)$ 的乘积是：\n$(u_1u_2 + v_1v_2n) + (u_1v_2 + u_2v_1)\\omega$。\n这需要 $4$ 次 $\\mathbb{F}_p$ 中的乘法和 $2$ 次加法（或使用 Karatsuba 算法的 $3$ 次乘法）。一次 $\\mathbb{F}_{p^2}$ 乘法的成本是 $O((\\log p)^2)$。\n求幂的总时间是 $O(\\log p) \\times O((\\log p)^2) = O((\\log p)^3)$。\n\n**总复杂度:** 算法的期望运行时间是这些步骤复杂度的总和，主要由模幂运算主导。总的期望时间复杂度为 $O((\\log p)^3)$，这是输入大小 $\\log p$ 的多项式时间。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Solves the problem for a fixed test suite of (a, p) pairs.\n    It computes a square root of a modulo p if one exists.\n    \"\"\"\n\n    test_cases = [\n        (0, 3),\n        (2, 3),\n        (10, 13),\n        (2, 13),\n        (643499475, 1000000007),\n        (5, 11),\n        (3, 11),\n    ]\n\n    def sqrt_mod_p(a, p):\n        \"\"\"\n        Computes a square root of a modulo p using Cipolla's algorithm.\n        Returns the smaller root, or -1 if no root exists.\n        \"\"\"\n        a %= p\n        if a == 0:\n            return 0\n        if p == 2:\n            return a\n\n        # Step 1: Check if a is a quadratic residue using Euler's criterion.\n        legendre = pow(a, (p - 1) // 2, p)\n        if legendre == p - 1:\n            return -1  # a is a quadratic non-residue\n\n        # If p = 3 (mod 4), there's a simpler formula.\n        # But this problem asks for the F_p^2 based derivation which works for all odd p.\n        # We will implement the general Cipolla's algorithm as required.\n        \n        # Step 2: Find t such that t^2 - a is a quadratic non-residue.\n        t = 1\n        while True:\n            n = (t * t - a) % p\n            if pow(n, (p - 1) // 2, p) == p - 1:\n                break\n            t += 1\n\n        # We need to perform arithmetic in F_p^2 = F_p[x] / (x^2 - n)\n        # An element is represented as a tuple (u, v) for u + v*omega.\n        \n        def f_p2_mul(x, y, n_val, p_val):\n            \"\"\"\n            Multiplies two numbers in F_p^2.\n            x = (x_u, x_v), y = (y_u, y_v)\n            \"\"\"\n            # (x_u + x_v*w) * (y_u + y_v*w) = x_u*y_u + (x_u*y_v + x_v*y_u)*w + x_v*y_v*w^2\n            # = (x_u*y_u + x_v*y_v*n) + (x_u*y_v + x_v*y_u)*w\n            res_u = (x[0] * y[0] + x[1] * y[1] * n_val) % p_val\n            res_v = (x[0] * y[1] + x[1] * y[0]) % p_val\n            return (res_u, res_v)\n        \n        def f_p2_pow(base, exp, n_val, p_val):\n            \"\"\"\n            Exponentiation in F_p^2 using binary exponentiation (exponentiation by squaring).\n            \"\"\"\n            res = (1, 0) # Multiplicative identity in F_p^2\n            while exp > 0:\n                if exp % 2 == 1:\n                    res = f_p2_mul(res, base, n_val, p_val)\n                base = f_p2_mul(base, base, n_val, p_val)\n                exp //= 2\n            return res\n\n        # Step 3: Compute x = (t + omega)^((p+1)/2).\n        # The base is (t, 1) which represents t + omega.\n        # The exponent is (p + 1) // 2.\n        base = (t, 1)\n        exponent = (p + 1) // 2\n        \n        root_pair = f_p2_pow(base, exponent, n, p)\n\n        # The result must be in F_p, so its imaginary part is 0.\n        # The root is the real part.\n        r1 = root_pair[0]\n        \n        # The other root is p - r1.\n        r2 = p - r1\n\n        # The problem asks for the smaller of the two roots.\n        return min(r1, r2)\n        \n    results = []\n    for a, p in test_cases:\n        result = sqrt_mod_p(a, p)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3021789"}]}