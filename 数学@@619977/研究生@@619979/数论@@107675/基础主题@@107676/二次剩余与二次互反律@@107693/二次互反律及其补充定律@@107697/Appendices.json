{"hands_on_practices": [{"introduction": "勒让德符号 $\\left(\\frac{a}{p}\\right)=1$ 保证了二次同余方程 $x^2 \\equiv a \\pmod{p}$ 有解，但当模数 $n$ 为合数时，雅可比符号 $\\left(\\frac{a}{n}\\right)=1$ 却不具备此性质。这个练习旨在通过构建一个具体的反例 [@problem_id:3021694]，来揭示这一关键区别，并加深对雅可比符号定义的理解。掌握这一概念是避免在应用二次互反律时产生常见误解的基础。", "problem": "设 $n=15$，并令 $\\left(\\frac{a}{n}\\right)$ 表示雅可比符号。找出满足 $\\gcd(a,15)=1$ 和 $\\left(\\frac{a}{15}\\right)=1$，但同余式 $x^{2}\\equiv a \\pmod{15}$ 无解的最小正整数 $a$。您的论证必须从奇素数 $p$ 的勒让德符号 $\\left(\\frac{a}{p}\\right)$、奇合数 $n$ 的雅可比符号 $\\left(\\frac{a}{n}\\right)$ 的基本定义，以及二次互反律及其补充定律出发，并且必须包含一个论据，说明尽管 $\\left(\\frac{a}{15}\\right)=1$，但 $x^{2}\\equiv a \\pmod{15}$ 无解。仅报告 $a$ 的值。无需取整。", "solution": "该问题已经过验证，被确定为一个在数论领域中提法恰当、有科学依据的问题。\n\n目标是找到满足 $\\gcd(a, 15) = 1$、雅可比符号 $\\left(\\frac{a}{15}\\right) = 1$ 且同余式 $x^2 \\equiv a \\pmod{15}$ 无解的最小正整数 $a$。\n\n给定整数 $n=15$。$n$ 的素因数分解为 $15 = 3 \\times 5$。\n\n根据定义，对于一个奇合数 $n = p_1 p_2 \\cdots p_k$，雅可比符号 $\\left(\\frac{a}{n}\\right)$ 定义为每个素因子的勒让德符号的乘积：\n$$\n\\left(\\frac{a}{n}\\right) = \\left(\\frac{a}{p_1}\\right) \\left(\\frac{a}{p_2}\\right) \\cdots \\left(\\frac{a}{p_k}\\right)\n$$\n对于 $n=15$，这变为：\n$$\n\\left(\\frac{a}{15}\\right) = \\left(\\frac{a}{3}\\right) \\left(\\frac{a}{5}\\right)\n$$\n我们已知条件 $\\left(\\frac{a}{15}\\right) = 1$。这意味着勒让德符号的乘积 $\\left(\\frac{a}{3}\\right)\\left(\\frac{a}{5}\\right)$ 必须等于 $1$。这可以通过两种方式发生：\n1. $\\left(\\frac{a}{3}\\right) = 1$ 且 $\\left(\\frac{a}{5}\\right) = 1$。\n2. $\\left(\\frac{a}{3}\\right) = -1$ 且 $\\left(\\frac{a}{5}\\right) = -1$。\n\n接下来，我们考虑二次同余式 $x^2 \\equiv a \\pmod{15}$ 的可解性。根据中国剩余定理，该同余式有解当且仅当同余方程组\n\\begin{align*}\nx^2 &\\equiv a \\pmod{3} \\\\\nx^2 &\\equiv a \\pmod{5}\n\\end{align*}\n同时有解。\n\n对于一个奇素数 $p$，同余式 $x^2 \\equiv a \\pmod{p}$ 有解当且仅当 $a$ 是模 $p$ 的二次剩余（假设 $\\gcd(a,p)=1$），这等价于勒让德符号 $\\left(\\frac{a}{p}\\right) = 1$。\n\n问题陈述 $x^2 \\equiv a \\pmod{15}$ 无解。这意味着同余式 $x^2 \\equiv a \\pmod{3}$ 或 $x^2 \\equiv a \\pmod{5}$ 中至少有一个无解。用勒让德符号表示，这等价于条件 $\\left(\\frac{a}{3}\\right) = -1$ 或 $\\left(\\frac{a}{5}\\right) = -1$。\n\n我们现在必须结合关于 $a$ 的两个主要条件：\n1. $\\left(\\frac{a}{3}\\right)\\left(\\frac{a}{5}\\right) = 1$\n2. $\\left(\\frac{a}{3}\\right) = -1$ 或 $\\left(\\frac{a}{5}\\right) = -1$\n\n如果我们有 $\\left(\\frac{a}{3}\\right) = 1$ 且 $\\left(\\frac{a}{5}\\right) = 1$，则第一个条件会满足，但第二个条件会被违反。此外，这种情况对应于 $x^2 \\equiv a \\pmod{15}$ 有解，这与问题陈述相矛盾。\n因此，同时满足这两个条件的唯一方法是两个勒让德符号都为 $-1$：\n$$\n\\left(\\frac{a}{3}\\right) = -1 \\quad \\text{and} \\quad \\left(\\frac{a}{5}\\right) = -1\n$$\n这种安排满足 $\\left(\\frac{a}{3}\\right)\\left(\\frac{a}{5}\\right) = (-1)(-1) = 1$，并且也满足至少有一个符号为 $-1$ 的条件，从而确保了 $x^2 \\equiv a \\pmod{15}$ 无解。\n\n问题现在简化为找到满足 $\\gcd(a, 15)=1$ 的最小正整数 $a$，它既是模 $3$ 的二次非剩余，也是模 $5$ 的二次非剩余。\n\n首先，我们确定模 $3$ 的二次非剩余。与 $3$ 互质的整数模 $3$ 同余于 $1$ 或 $2$。\n$1^2 \\equiv 1 \\pmod{3}$，所以 $\\left(\\frac{1}{3}\\right)=1$。\n$2^2 \\equiv 4 \\equiv 1 \\pmod{3}$。非剩余是那些不同余于任何平方数的整数。模 $3$ 的唯一二次非剩余是 $2$。\n所以，$\\left(\\frac{2}{3}\\right)=-1$。这要求 $a \\equiv 2 \\pmod{3}$。\n\n其次，我们确定模 $5$ 的二次非剩余。与 $5$ 互质的整数模 $5$ 同余于 $1, 2, 3,$ 或 $4$。\n$1^2 \\equiv 1 \\pmod{5}$\n$2^2 \\equiv 4 \\pmod{5}$\n$3^2 \\equiv 9 \\equiv 4 \\pmod{5}$\n$4^2 \\equiv 16 \\equiv 1 \\pmod{5}$\n模 $5$ 的二次剩余是 $1$ 和 $4$。二次非剩余是 $2$ 和 $3$。\n所以，$\\left(\\frac{2}{5}\\right)=-1$ 且 $\\left(\\frac{3}{5}\\right)=-1$。这要求 $a \\equiv 2 \\pmod{5}$ 或 $a \\equiv 3 \\pmod{5}$。\n\n我们寻求满足 $\\gcd(a,15)=1$ 且满足由我们的条件产生的同余方程组的最小正整数 $a$：\n$$\na \\equiv 2 \\pmod{3} \\quad \\text{and} \\quad (a \\equiv 2 \\pmod{5} \\text{ or } a \\equiv 3 \\pmod{5})\n$$\n我们现在可以从 $1$ 开始，测试与 $15$ 互质的正整数 $a$。\n这些整数是 $1, 2, 4, 7, 8, 11, 13, 14, \\dots$\n\n- 令 $a=1$。$\\gcd(1,15)=1$。但是 $1 \\equiv 1 \\pmod{3}$，这违反了 $a \\equiv 2 \\pmod{3}$。所以 $a=1$ 不是解。\n\n- 令 $a=2$。$\\gcd(2,15)=1$。\n  - 我们检查条件 $a \\equiv 2 \\pmod{3}$：$2 \\equiv 2 \\pmod{3}$。此条件满足。\n  - 我们检查条件 $a \\equiv 2 \\pmod{5}$ 或 $a \\equiv 3 \\pmod{5}$：$2 \\equiv 2 \\pmod{5}$。此条件满足。\n\n由于 $a=2$ 是继 $a=1$ 之后第一个满足必要条件的整数，因此它是最小的正整数。\n\n为根据问题陈述进行确认，我们使用二次互反律的第二补充定律，即 $\\left(\\frac{2}{p}\\right) = (-1)^{(p^2-1)/8}$。\n对于 $p=3$：$\\left(\\frac{2}{3}\\right) = (-1)^{(3^2-1)/8} = (-1)^1 = -1$。\n对于 $p=5$：$\\left(\\frac{2}{5}\\right) = (-1)^{(5^2-1)/8} = (-1)^3 = -1$。\n对于 $a=2$，这两个条件都满足。\n\n让我们验证 $a=2$ 满足原问题的所有要求：\n- 它是找到的最小正整数。\n- $\\gcd(2, 15)=1$。\n- $\\left(\\frac{2}{15}\\right) = \\left(\\frac{2}{3}\\right)\\left(\\frac{2}{5}\\right) = (-1)(-1) = 1$。\n- 同余式 $x^2 \\equiv 2 \\pmod{15}$ 无解，因为 $x^2 \\equiv 2 \\pmod{3}$ 无解，原因在于 $\\left(\\frac{2}{3}\\right)=-1$。\n\n因此，满足所有给定条件的最小正整数 $a$ 是 $2$。", "answer": "$$\\boxed{2}$$", "id": "3021694"}, {"introduction": "在掌握了基本概念之后，我们将转向一个实际的计算挑战：如何系统地计算一个看似复杂的勒让德符号。这个练习 [@problem_id:3013383] 引导我们运用乘法性质，将符号 $\\left(\\frac{-10}{p}\\right)$ 分解为更简单的部分，并依次使用第一和第二补充定律以及二次互反主定律来求解。这不仅是理论的应用，更是数论计算中的一项核心技能。", "problem": "设 $p = 2029$ 是一个奇素数。考虑同余式 $x^{2} \\equiv -10 \\pmod{p}$ 在模 $p$ 整数环中的可解性。仅使用关于乘法群 $(\\mathbb{Z}/p\\mathbb{Z})^{\\times}$ 中二次剩余的基本原理，以及基于高斯引理和欧拉判别法所提供的方法，精确计算勒让德符号 $\\left(\\frac{-10}{p}\\right)$ 的值。你的最终答案必须是一个数字。不需要四舍五入。", "solution": "我们从与二次剩余及其勒让德符号相关的核心定义和事实开始。对于一个奇素数 $p$ 和一个整数 $a$ 且 $p \\nmid a$，勒让德符号 $\\left(\\frac{a}{p}\\right)$ 定义为\n$$\n\\left(\\frac{a}{p}\\right) =\n\\begin{cases}\n1 & \\text{如果存在 } x \\in \\mathbb{Z} \\text{ 使得 } x^{2} \\equiv a \\pmod{p}, \\\\\n-1 & \\text{否则。}\n\\end{cases}\n$$\n欧拉判别法断言\n$$\n\\left(\\frac{a}{p}\\right) \\equiv a^{\\frac{p-1}{2}} \\pmod{p},\n$$\n特别地，当 $p \\nmid a$ 时，$\\left(\\frac{a}{p}\\right) \\in \\{-1,1\\}$。勒让德符号具有乘法性：\n$$\n\\left(\\frac{ab}{p}\\right) = \\left(\\frac{a}{p}\\right)\\left(\\frac{b}{p}\\right),\n$$\n这可以由欧拉判别法通过以下方式得出\n$$\n(ab)^{\\frac{p-1}{2}} \\equiv a^{\\frac{p-1}{2}} b^{\\frac{p-1}{2}} \\pmod{p}.\n$$\n\n我们的任务是计算当 $p = 2029$ 时 $\\left(\\frac{-10}{p}\\right)$ 的值。利用乘法性以及 $-1$, $2$, $5$ 与 $p$ 互素，我们将其分解为\n$$\n\\left(\\frac{-10}{p}\\right) = \\left(\\frac{-1}{p}\\right)\\left(\\frac{2}{p}\\right)\\left(\\frac{5}{p}\\right).\n$$\n我们将使用二次互反律及其补充定律来计算每个因子，而这些定律本身可以由高斯引理建立。\n\n高斯引理陈述：对于奇素数 $p$ 和整数 $a$ 且 $p \\nmid a$，考虑集合 $a,2a,3a,\\dots,\\frac{p-1}{2}a$ 模 $p$ 的最小正剩余。令 $N(a)$ 为这些剩余中超过 $\\frac{p}{2}$ 的数量。则\n$$\n\\left(\\frac{a}{p}\\right) = (-1)^{N(a)}.\n$$\n\n1. 计算 $\\left(\\frac{-1}{p}\\right)$。第一补充定律源于高斯引理，它指出\n$$\n\\left(\\frac{-1}{p}\\right) = (-1)^{\\frac{p-1}{2}}.\n$$\n对于 $p = 2029$，我们有 $\\frac{p-1}{2} = \\frac{2028}{2} = 1014$，这是一个偶数，所以\n$$\n\\left(\\frac{-1}{2029}\\right) = 1.\n$$\n\n2. 计算 $\\left(\\frac{2}{p}\\right)$。第二补充定律同样可以由高斯引理推导。该定律通常表述为：\n$$\n\\left(\\frac{2}{p}\\right) = (-1)^{\\frac{p^{2}-1}{8}}.\n$$\n这个公式等价于以下规则：\n$$\n\\left(\\frac{2}{p}\\right) =\n\\begin{cases}\n1 & \\text{如果 } p \\equiv 1 \\text{ 或 } 7 \\pmod{8}, \\\\\n-1 & \\text{如果 } p \\equiv 3 \\text{ 或 } 5 \\pmod{8}.\n\\end{cases}\n$$\n对于 $p = 2029$，我们有 $2029 = 253 \\times 8 + 5$，所以 $p \\equiv 5 \\pmod{8}$。因此，\n$$\n\\left(\\frac{2}{2029}\\right) = -1.\n$$\n\n3. 使用二次互反律计算 $\\left(\\frac{5}{p}\\right)$。二次互反律陈述：对于不同的奇素数 $p$ 和 $q$，\n$$\n\\left(\\frac{p}{q}\\right)\\left(\\frac{q}{p}\\right) = (-1)^{\\frac{p-1}{2}\\cdot \\frac{q-1}{2}}.\n$$\n特别地，当 $q \\equiv 1 \\pmod{4}$ 时，指数的因子 $\\frac{q-1}{2}$ 是偶数，所以右侧符号为 $+1$，于是 $\\left(\\frac{p}{q}\\right) = \\left(\\frac{q}{p}\\right)$。因为 $5 \\equiv 1 \\pmod{4}$，我们得到\n$$\n\\left(\\frac{5}{p}\\right) = \\left(\\frac{p}{5}\\right).\n$$\n为了计算 $\\left(\\frac{p}{5}\\right)$，我们将 $p$ 模 $5$ 并与模 $5$ 的二次剩余（即 $1$ 和 $4$）进行比较。计算 $p \\bmod 5$：$2025$ 可被 $5$ 整除，所以 $2029 \\equiv 4 \\pmod{5}$。因此\n$$\n\\left(\\frac{p}{5}\\right) = \\left(\\frac{2029}{5}\\right) = \\left(\\frac{4}{5}\\right) = 1,\n$$\n于是\n$$\n\\left(\\frac{5}{2029}\\right) = 1.\n$$\n\n将这三个因子结合起来，\n$$\n\\left(\\frac{-10}{2029}\\right) = \\left(\\frac{-1}{2029}\\right)\\left(\\frac{2}{2029}\\right)\\left(\\frac{5}{2029}\\right) = 1 \\cdot (-1) \\cdot 1 = -1.\n$$\n根据定义解释，同余式 $x^{2} \\equiv -10 \\pmod{2029}$ 在 $\\mathbb{Z}/2029\\mathbb{Z}$ 中无解，且勒让德符号的值为 $-1$，符合要求。", "answer": "$$\\boxed{-1}$$", "id": "3013383"}, {"introduction": "二次互反律中“翻转”符号的机制，不仅是一个优美的理论结果，更是构建高效计算算法的基石，其思想与欧几里得算法有异曲同工之妙。这个练习 [@problem_id:3021663] 要求我们将这一过程形式化为一个可编程的算法，并证明其终止性和正确性。通过这个实践，你将深刻体会到数论理论与计算科学之间的内在联系，并将理论知识转化为强大的解决问题的工具。", "problem": "设计并实现一个程序，该程序使用一个完全基于二次互反律及其补充定律的迭代算法，计算整数 $a$ 和奇素数 $p$ 的勒让德符号 $\\left(\\frac{a}{p}\\right)$。您的算法必须迭代地将数对 $(a,p)$ 转换为新的数对 $(a',p')$，从而将 $\\left(\\frac{a}{p}\\right)$ 的求值简化为 $\\left(\\frac{a'}{p'}\\right)$ 的求值，并乘以一个完全由二次互反律及其补充定律所要求的奇偶性条件决定的符号。该算法必须包括以下特性：\n\n- 在每个阶段将 $a$ 对 $p$ 取模，以确保 $0 \\le a < p$。\n- 通过从关于 $-1$ 的补充定律导出的适当符号因子来处理负数输入 $a$。\n- 在每个阶段从 $a$ 中移除 $2$ 的幂，并使用关于 $2$ 的补充定律累积每个提取出的因子 $2$ 所贡献的符号因子。\n- 移除因子 $2$ 后，调用互反步骤交换 $a$ 和 $p$ 的角色，符号取决于它们模 $4$ 的同余类决定的互反符号，然后通过取 $p \\bmod a$ 来化简新的分子。\n\n您的任务分为三部分：\n\n$1.$ 用文字精确地描述算法并用代码实现。您可以将二次互反律以及关于 $-1$ 和 $2$ 的补充定律作为基础输入，但不得假设或调用任何其他直接计算 $\\left(\\frac{a}{p}\\right)$ 的结果。\n\n$2.$ 证明您的算法对于所有整数输入 $a$ 和所有奇素数 $p$ 都会终止。\n\n$3.$ 证明该算法是正确的，即累积的符号和化简步骤保持勒让德符号的值不变，因此返回的输出恰好是 $\\left(\\frac{a}{p}\\right) \\in \\{-1,0,1\\}$。\n\n您的程序必须为以下每个测试用例生成勒让德符号：\n- $(a,p) = (0,3)$\n- $(a,p) = (1,5)$\n- $(a,p) = (2,7)$\n- $(a,p) = (10,11)$\n- $(a,p) = (-3,11)$\n- $(a,p) = (22,11)$\n- $(a,p) = (1024,17)$\n- $(a,p) = (123456789,31)$\n- $(a,p) = (97,13)$\n- $(a,p) = (45,23)$\n- $(a,p) = (2,3)$\n- $(a,p) = (8,5)$\n- $(a,p) = (4,29)$\n\n您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表。例如，输出格式必须严格符合以下形式：\n$[r_1,r_2,\\dots,r_{13}]$\n其中每个 $r_i \\in \\{-1,0,1\\}$ 是按上述顺序列出的相应测试用例的 $\\left(\\frac{a}{p}\\right)$ 的值。不应打印其他文本或格式。", "solution": "该问题要求设计、实现并分析一个迭代算法，用于计算整数 $a$ 和奇素数 $p$ 的勒让德符号 $\\left(\\frac{a}{p}\\right)$。该算法必须完全基于勒让德符号的性质，即二次互反律及其两个补充定律。\n\n勒让德符号 $\\left(\\frac{a}{p}\\right)$ 是为整数 $a$ 和奇素数 $p$ 定义的。如果 $a$ 是模 $p$ 的二次剩余且 $a \\not\\equiv 0 \\pmod p$，其值为 $1$；如果 $a$ 是模 $p$ 的二次非剩余，其值为 $-1$；如果 $a \\equiv 0 \\pmod p$，其值为 $0$。\n\n该算法依赖于以下基本性质：\n$1.$ 如果 $a \\equiv b \\pmod p$，那么 $\\left(\\frac{a}{p}\\right) = \\left(\\frac{b}{p}\\right)$。\n$2.$ $\\left(\\frac{ab}{p}\\right) = \\left(\\frac{a}{p}\\right)\\left(\\frac{b}{p}\\right)$ (乘法性质)。\n$3.$ 第一补充定律：$\\left(\\frac{-1}{p}\\right) = (-1)^{\\frac{p-1}{2}}$。如果 $p \\equiv 1 \\pmod 4$，其值为 $1$；如果 $p \\equiv 3 \\pmod 4$，其值为 $-1$。\n$4.$ 第二补充定律：$\\left(\\frac{2}{p}\\right) = (-1)^{\\frac{p^2-1}{8}}$。如果 $p \\equiv 1, 7 \\pmod 8$，其值为 $1$；如果 $p \\equiv 3, 5 \\pmod 8$，其值为 $-1$。\n$5.$ 二次互反律：对于不同的奇素数 $p$ 和 $q$，$\\left(\\frac{p}{q}\\right) = \\left(\\frac{q}{p}\\right)(-1)^{\\frac{p-1}{2}\\frac{q-1}{2}}$。仅当 $p$ 和 $q$ 都与 $3$ 模 $4$ 同余时，符号因子才为 $-1$。该定律可通过雅可比符号推广到适用于任何奇数对 $p, q > 1$。\n\n### $1.$ 算法详述\n\n该算法通过迭代地将数对 $(a, p)$ 化简为更简单的数对，同时跟踪一个符号乘数，来计算 $\\left(\\frac{a}{p}\\right)$。设计算的状态由三元组 $(k, n, d)$ 表示，我们旨在计算 $k \\cdot \\left(\\frac{n}{d}\\right)$ 的值。初始状态为 $(1, a, p)$。当 $n$ 变为 $0$ 或 $1$ 时，算法终止。\n\n**初始化：**\n$1.$ 设置初始累积符号 $k = 1$。\n$2.$ 初始分子是输入整数 $a$。初始分母是奇素数 $p$。\n$3.$ 应用性质 $\\left(\\frac{a}{p}\\right) = \\left(\\frac{a \\pmod p}{p}\\right)$。用 $a \\pmod p$ 替换 $a$。此步骤后，我们有 $0 \\le a < p$。\n\n**迭代：**\n算法的核心是一个循环，只要 $a \\neq 0$ 就继续。\n\n**步骤 1：基本情况。**\n- 如果 $a = 0$，勒让德符号为 $0$。算法终止并返回 $0$。\n- 如果 $a = 1$，符号为 $1$。该值由累积的符号 $k$ 决定。算法终止并返回 $k$。\n\n**步骤 2：提出 $2$ 的幂因子。**\n将分子 $a$ 分解为 $a = 2^s \\cdot m$，其中 $m$ 是奇数。使用乘法性质，我们有 $\\left(\\frac{a}{p}\\right) = \\left(\\frac{2^s m}{p}\\right) = \\left(\\frac{2}{p}\\right)^s \\left(\\frac{m}{p}\\right)$。\n- 找出 $a$ 中因子 $2$ 的数量，设为 $s$。\n- 如果 $s$ 是奇数，累积符号 $k$ 必须乘以 $\\left(\\frac{2}{p}\\right) = (-1)^{\\frac{p^2-1}{8}}$。这等价于如果 $p \\equiv 3 \\pmod 8$ 或 $p \\equiv 5 \\pmod 8$，则翻转 $k$ 的符号。\n- 在考虑符号变化后，用其奇数部分 $m$ 替换 $a$。\n- 此步骤后，$a$ 变为奇数。我们必须重新检查基本情况 $a=1$，因为原始的 $a$ 可能是一个 $2$ 的幂。如果 $a=1$，终止并返回当前的符号 $k$。\n\n**步骤 3：应用二次互反律。**\n此时，$a$ 是一个满足 $1 < a < p$ 的奇数。\n- 我们有 $\\left(\\frac{a}{p}\\right) = \\left(\\frac{p}{a}\\right) (-1)^{\\frac{a-1}{2}\\frac{p-1}{2}}$。\n- 符号 $k$ 通过乘以互反因子 $(-1)^{\\frac{a-1}{2}\\frac{p-1}{2}}$ 来更新。这等价于当且仅当 $a \\equiv 3 \\pmod 4$ 且 $p \\equiv 3 \\pmod 4$ 时，翻转 $k$ 的符号。\n- 计算 $\\left(\\frac{a}{p}\\right)$ 的问题被转换为计算 $\\left(\\frac{p}{a}\\right)$。分子和分母的角色互换。\n- 新的数对变为 $(p, a)$。为了确保终止性并以一种能够继续迭代的方式进行，我们将新的分子对新的分母取模。下一次迭代的新状态由数对 $(p \\pmod a, a)$ 定义。因此，我们设置新的 $a$ 为 $p \\pmod a$，新的 $p$ 为旧的 $a$。然后循环从步骤 1 继续。\n\n### $2.$ 终止性证明\n\n算法的终止性由以下事实保证：在每个互反步骤中，其中一个整数参数严格递减。\n\n设在主循环的某次迭代开始时处理的整数对为 $(a_i, p_i)$。\n$1.$ 初始步骤将输入 $a_{in}$ 化简为 $a_0 = a_{in} \\pmod p$，因此 $0 \\le a_0 < p$。初始分母为 $p_0=p$。\n$2.$ 在循环内部，$a_i$ 首先被处理以提取因子 $2$，得到一个奇数 $a'_i \\le a_i$。分母 $p_i$ 保持不变。\n$3.$ 互反步骤将数对 $(a'_i, p_i)$ 转换为下一次迭代的新数对 $(a_{i+1}, p_{i+1})$，其中 $a_{i+1} = p_i \\pmod{a'_i}$ 且 $p_{i+1} = a'_i$。\n$4.$ 由于 $a'_i$ 是奇数且 $1 < a'_i < p_i$ (如果 $a'_i > 1$)，我们有 $0 \\le p_i \\pmod{a'_i} < a'_i$。\n$5.$ 分母序列为 $p_0, p_1, p_2, \\ldots$。根据更新规则，$p_{i+1} = a'_i$。由于 $a'_i \\le a_i < p_i$，我们有 $p_{i+1} < p_i$。\n$6.$ 分母序列 $\\{p_i\\}$ 是一个严格递减的正整数序列。\n$7.$ 任何严格递减的正整数序列都必须是有限的。它最终必须达到一个循环终止的状态。如果 $a_i$ 变为 $0$ 或 $1$，循环就会终止。\n\n该论证结构与欧几里得算法的终止性证明类似。分母的值构成一个严格递减的正整数序列，这保证了过程会结束。\n\n### $3.$ 正确性证明\n\n算法的正确性通过证明值 $V = k \\cdot \\left(\\frac{a}{p}\\right)$ 在循环执行过程中是不变量来建立，其中 $k$ 是累积的符号，$(a, p)$ 是当前的分子和分母对。\n\n**初始状态：**\n最初，$k=1$，数对是 $(a_{in}, p_{in})$。第一步计算 $a_0 = a_{in} \\pmod{p_{in}}$。此时的不变量是 $V_0 = 1 \\cdot \\left(\\frac{a_0}{p_{in}}\\right)$。根据勒让德符号的性质，$\\left(\\frac{a_{in}}{p_{in}}\\right) = \\left(\\frac{a_{in} \\pmod{p_{in}}}{p_{in}}\\right) = \\left(\\frac{a_0}{p_{in}}\\right)$。所以不变量成立。注意，由于模运算符的定义，这个初始的化简正确地处理了负数 $a_{in}$。\n\n**循环不变量：**\n设在一次迭代开始时的状态为 $(k_i, a_i, p_i)$，其不变量值为 $V_i = k_i \\left(\\frac{a_i}{p_i}\\right)$。\n\n$1.$ **提出因子 $2$：** 设 $a_i = 2^s \\cdot m$，其中 $m$ 是奇数。算法更新 $k_{i+1} = k_i \\cdot \\left(\\frac{2}{p_i}\\right)^s$ 和 $a_{i+1} = m$。对于此步骤，分母 $p_{i+1} = p_i$ 保持不变。\n新的不变量值为 $V_{i+1} = k_{i+1} \\left(\\frac{a_{i+1}}{p_{i+1}}\\right) = \\left(k_i \\cdot \\left(\\frac{2}{p_i}\\right)^s\\right) \\left(\\frac{m}{p_i}\\right) = k_i \\left(\\frac{2^s m}{p_i}\\right) = k_i \\left(\\frac{a_i}{p_i}\\right) = V_i$。该值得以保持。\n\n$2.$ **互反步骤：** 提出因子 $2$ 后，我们得到一个状态 $(k_j, a_j, p_j)$，其中 $a_j$ 是奇数。算法将符号更新为 $k_{j+1} = k_j \\cdot (-1)^{\\frac{a_j-1}{2}\\frac{p_j-1}{2}}$。然后它将下一次循环迭代的新数对设置为 $(a_{j+1}, p_{j+1}) = (p_j \\pmod{a_j}, a_j)$。我们希望保持的值是 $V_j = k_j \\left(\\frac{a_j}{p_j}\\right)$。\n根据二次互反律，$\\left(\\frac{a_j}{p_j}\\right) = \\left(\\frac{p_j}{a_j}\\right) (-1)^{\\frac{a_j-1}{2}\\frac{p_j-1}{2}}$。\n所以，$V_j = k_j \\left(\\frac{p_j}{a_j}\\right) (-1)^{\\frac{a_j-1}{2}\\frac{p_j-1}{2}}$。\n下一状态所代表的值是 $V_{next} = k_{j+1} \\left(\\frac{a_{j+1}}{p_{j+1}}\\right) = \\left( k_j (-1)^{\\frac{a_j-1}{2}\\frac{p_j-1}{2}} \\right) \\left(\\frac{p_j \\pmod{a_j}}{a_j}\\right)$。\n使用性质 $\\left(\\frac{p_j \\pmod{a_j}}{a_j}\\right) = \\left(\\frac{p_j}{a_j}\\right)$，我们有 $V_{next} = k_j (-1)^{\\frac{a_j-1}{2}\\frac{p_j-1}{2}} \\left(\\frac{p_j}{a_j}\\right)$。\n这与 $V_j$ 完全相等。不变量在互反步骤中得以保持。\n\n**终止：**\n当 $a$ 变为 $0$ 或 $1$ 时，算法终止。\n- 如果 $a=0$，算法返回 $0$。此时的不变量值将是 $k \\cdot \\left(\\frac{0}{p}\\right) = k \\cdot 0 = 0$。这是正确的。\n- 如果 $a=1$，算法返回累积的符号 $k$。不变量值是 $k \\cdot \\left(\\frac{1}{p}\\right) = k \\cdot 1 = k$。这也是正确的。\n\n由于不变量 $V$ 在算法的每一步都保持不变，并且在终止时计算的最终值是正确的，因此初始值 $\\left(\\frac{a}{p}\\right)$ 被正确计算。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem by computing the Legendre symbol for a list of test cases.\n    \"\"\"\n\n    def legendre_symbol(a: int, p: int) -> int:\n        \"\"\"\n        Computes the Legendre symbol (a/p) using an iterative algorithm based\n        on quadratic reciprocity and supplementary laws.\n\n        Args:\n            a: An integer.\n            p: An odd prime number.\n\n        Returns:\n            The value of the Legendre symbol, which is -1, 0, or 1.\n        \"\"\"\n        if p <= 2 or p % 2 == 0:\n            raise ValueError(\"p must be an odd prime.\")\n            \n        # Step 1: Reduce a modulo p. This also handles negative a correctly,\n        # as a % p in Python for a<0 results in a number with the same sign as p.\n        # Since p is positive, the result is in [0, p-1].\n        # For example, -3 % 11 = 8. (a/p) = (a mod p / p).\n        a = a % p\n\n        # Initialize the accumulated sign.\n        sign = 1\n\n        # Main loop: continues until a is 0 or 1.\n        while a != 0:\n            # Base case: if a is 1, the result is the accumulated sign.\n            if a == 1:\n                return sign\n\n            # Step 2: Factor out powers of 2 from a.\n            # Let a = 2^k * m, where m is odd.\n            # (a/p) = (2^k * m / p) = (2/p)^k * (m/p).\n            k = 0\n            while a % 2 == 0:\n                a //= 2\n                k += 1\n\n            # Update sign based on the supplementary law for 2: (2/p) = (-1)^((p^2-1)/8).\n            # We multiply the sign by (2/p) for each factor of 2. An even number of\n            # factors has no effect. An odd number of factors contributes a (2/p) term.\n            if k % 2 == 1:\n                # (2/p) is -1 if p = 3 or 5 (mod 8).\n                p_mod_8 = p % 8\n                if p_mod_8 == 3 or p_mod_8 == 5:\n                    sign = -sign\n\n            # After removing factors of 2, a might be 1.\n            # E.g., if original a was 4, it becomes 1 here.\n            if a == 1:\n                return sign\n\n            # Step 3: Apply the Law of Quadratic Reciprocity.\n            # At this point, a is odd, and 1 < a < p.\n            # (a/p) = (p/a) * (-1)^(((a-1)/2)*((p-1)/2)).\n            # The sign factor is -1 iff both a and p are 3 (mod 4).\n            if (a % 4 == 3) and (p % 4 == 3):\n                sign = -sign\n\n            # Swap roles and reduce. The task to compute (a/p) is replaced\n            # by computing (p/a), which is equivalent to (p mod a / a).\n            # This is the core of the reduction, similar to the Euclidean algorithm.\n            old_a = a\n            a = p % old_a\n            p = old_a\n        \n        # If the loop terminates because a is 0, then the original a was a multiple of p.\n        return 0\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (0, 3),\n        (1, 5),\n        (2, 7),\n        (10, 11),\n        (-3, 11),\n        (22, 11),\n        (1024, 17),\n        (123456789, 31),\n        (97, 13),\n        (45, 23),\n        (2, 3),\n        (8, 5),\n        (4, 29),\n    ]\n\n    results = []\n    for a, p in test_cases:\n        result = legendre_symbol(a, p)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3021663"}]}