{"hands_on_practices": [{"introduction": "掌握雅可比符号的第一步是熟练运用其系列性质进行计算。本练习将引导你手动计算一个具体的雅可比符号值，这能有效巩固你对二次互反律、补充定律以及符号乘法性质的理解。这个过程类似于欧几里得算法，通过一系列化简步骤，将复杂的符号计算最终归结为一个简单的值。[@problem_id:1441656]", "problem": "在密码学算法和素性检验（例如 Solovay-Strassen 素性检验）中，雅可比符号的高效计算是一项基本运算。雅可比符号，记作 $(\\frac{a}{n})$，是为整数 $a$ 和正奇数 $n$ 定义的。雅可比符号的一个主要优点是，它的值可以被快速确定，而无需对分母 $n$ 进行素因数分解。这是通过应用一系列变换规则来实现的，这些规则在本质上类似于用欧几里得算法求最大公约数的步骤。\n\n基于这些计算性质，你的任务是计算雅可比符号 $(\\frac{38}{105})$ 的值。你的最终答案应该是一个整数。", "solution": "题目要求我们计算雅可比符号 $(\\frac{38}{105})$。我们将使用雅可比符号的性质来简化该表达式，直到得到最终值。\n\n我们将使用的主要性质如下：\n1.  分子的乘法性质：$(\\frac{ab}{n}) = (\\frac{a}{n})(\\frac{b}{n})$。\n2.  $(\\frac{2}{n})$ 的值：$(\\frac{2}{n}) = (-1)^{(n^2 - 1)/8}$，当 $n \\equiv 1, 7 \\pmod{8}$ 时，其值为 $1$；当 $n \\equiv 3, 5 \\pmod{8}$ 时，其值为 $-1$。\n3.  二次互反律：对于奇数互素整数 $m$ 和 $n$，$(\\frac{m}{n}) = (\\frac{n}{m})(-1)^{\\frac{m-1}{2}\\frac{n-1}{2}}$。符号项 $(-1)^{\\frac{m-1}{2}\\frac{n-1}{2}}$ 的值为 $-1$ 当且仅当 $m$ 和 $n$ 都与 $3 \\pmod{4}$ 同余，否则为 $1$。\n4.  分子的模约简：如果 $a \\equiv b \\pmod{n}$，那么 $(\\frac{a}{n}) = (\\frac{b}{n})$。\n5.  完全平方数：如果 $\\gcd(a, n) = 1$，那么 $(\\frac{a^2}{n}) = 1$。\n\n让我们开始计算 $(\\frac{38}{105})$。\n\n步骤 1：对分子应用乘法性质。\n$38 = 2 \\times 19$。\n$$\n\\left(\\frac{38}{105}\\right) = \\left(\\frac{2 \\cdot 19}{105}\\right) = \\left(\\frac{2}{105}\\right)\\left(\\frac{19}{105}\\right)\n$$\n\n步骤 2：计算项 $(\\frac{2}{105})$。\n我们需要确定 $105$ 模 $8$ 的值。\n$105 = 13 \\times 8 + 1$，所以 $105 \\equiv 1 \\pmod{8}$。\n根据 $(\\frac{2}{n})$ 的规则，当 $n \\equiv 1 \\pmod{8}$ 时，其值为 $1$。\n$$\n\\left(\\frac{2}{105}\\right) = 1\n$$\n将此结果代回我们的表达式中：\n$$\n\\left(\\frac{38}{105}\\right) = 1 \\cdot \\left(\\frac{19}{105}\\right) = \\left(\\frac{19}{105}\\right)\n$$\n\n步骤 3：对 $(\\frac{19}{105})$ 应用二次互反律。\n我们可以翻转分子和分母，这可能会引入符号变化。符号取决于分子和分母模 $4$ 的值。\n$m = 19$, $n = 105$。\n$19 = 4 \\times 4 + 3$，所以 $19 \\equiv 3 \\pmod{4}$。\n$105 = 26 \\times 4 + 1$，所以 $105 \\equiv 1 \\pmod{4}$。\n因为只有一个数（$m=19$）与 $3 \\pmod{4}$ 同余，所以符号项为 $(-1)^{\\frac{19-1}{2}\\frac{105-1}{2}} = (-1)^{9 \\cdot 52} = 1$。因此，没有符号变化。\n$$\n\\left(\\frac{19}{105}\\right) = \\left(\\frac{105}{19}\\right)\n$$\n\n步骤 4：通过对分子取模于分母来进行约简。\n我们计算 $105$ 模 $19$。\n$105 = 5 \\times 19 + 10 = 95 + 10$。所以，$105 \\equiv 10 \\pmod{19}$。\n根据约简性质：\n$$\n\\left(\\frac{105}{19}\\right) = \\left(\\frac{10}{19}\\right)\n$$\n\n步骤 5：现在计算简化为求 $(\\frac{10}{19})$。我们再次使用乘法性质。\n$10 = 2 \\times 5$。\n$$\n\\left(\\frac{10}{19}\\right) = \\left(\\frac{2}{19}\\right)\\left(\\frac{5}{19}\\right)\n$$\n\n步骤 6：分别计算得到的两个符号。首先是 $(\\frac{2}{19})$。\n我们需要确定 $19$ 模 $8$ 的值。\n$19 = 2 \\times 8 + 3$，所以 $19 \\equiv 3 \\pmod{8}$。\n根据 $(\\frac{2}{n})$ 的规则，当 $n \\equiv 3 \\pmod{8}$ 时，其值为 $-1$。\n$$\n\\left(\\frac{2}{19}\\right) = -1\n$$\n\n步骤 7：接下来，计算 $(\\frac{5}{19})$。我们再次应用二次互反律。\n$m = 5$, $n = 19$。\n$5 = 1 \\times 4 + 1$，所以 $5 \\equiv 1 \\pmod{4}$。\n$19 = 4 \\times 4 + 3$，所以 $19 \\equiv 3 \\pmod{4}$。\n同样，只有一个数与 $3 \\pmod{4}$ 同余，所以翻转后没有符号变化。\n$$\n\\left(\\frac{5}{19}\\right) = \\left(\\frac{19}{5}\\right)\n$$\n\n步骤 8：对分子 $19$ 取模于 $5$。\n$19 = 3 \\times 5 + 4$，所以 $19 \\equiv 4 \\pmod{5}$。\n$$\n\\left(\\frac{19}{5}\\right) = \\left(\\frac{4}{5}\\right)\n$$\n\n步骤 9：计算 $(\\frac{4}{5})$。\n因为 $4 = 2^2$ 是一个完全平方数且 $\\gcd(2, 5) = 1$，所以其雅可比符号为 $1$。\n$$\n\\left(\\frac{4}{5}\\right) = \\left(\\frac{2^2}{5}\\right) = 1\n$$\n所以，从步骤 7 可知，$(\\frac{5}{19}) = 1$。\n\n步骤 10：结合步骤 6 和步骤 9 的结果。\n从步骤 5，我们得到 $(\\frac{10}{19}) = (\\frac{2}{19})(\\frac{5}{19})$。\n$$\n\\left(\\frac{10}{19}\\right) = (-1)(1) = -1\n$$\n\n步骤 11：回溯我们的计算过程以找到最终答案。\n从步骤 4，$(\\frac{105}{19}) = (\\frac{10}{19}) = -1$。\n从步骤 3，$(\\frac{19}{105}) = (\\frac{105}{19}) = -1$。\n从步骤 2，$(\\frac{38}{105}) = (\\frac{19}{105}) = -1$。\n\n因此，雅可比符号的最终值为 $-1$。", "answer": "$$\\boxed{-1}$$", "id": "1441656"}, {"introduction": "雅可比符号 $(\\frac{a}{n})=1$ 并不保证二次同余式 $x^2 \\equiv a \\pmod{n}$ 有解，这是它与勒让德符号的一个关键区别。本练习将通过一个精心设计的思想实验，要求你识别并验证一个具体的反例。通过这个过程，你将深刻理解为何雅可比符号主要作为一种计算工具，而不是一个直接的「可解性」测试。[@problem_id:3027697]", "problem": "设 $p$ 和 $q$ 是不同的奇素数，且 $n=pq$。对于奇素数 $p$，勒让德符号 $(a/p)$ 被定义为：当且仅当同余式 $x^2\\equiv a \\pmod p$ 有解且 $p\\nmid a$ 时，$(a/p)=1$；当且仅当同余式 $x^2\\equiv a \\pmod p$ 无解且 $p\\nmid a$ 时，$(a/p)=-1$；如果 $p\\mid a$，则 $(a/p)=0$。对于奇数 $n$（其素因子分解为 $n=\\prod_{i=1}^k p_i^{e_i}$），雅可比符号 $(a/n)$ 定义为 $(a/n)=\\prod_{i=1}^k (a/p_i)^{e_i}$，对于无平方因子的 $n=pq$，它简化为 $(a/n)=(a/p)(a/q)$。中国剩余定理 (CRT) 指出，对于 $\\gcd(p,q)=1$，同余方程组 $x\\equiv x_1\\pmod p$，$x\\equiv x_2\\pmod q$ 对任意给定的 $x_1$ 和 $x_2$ 都有一个解 $x\\pmod{pq}$，特别地，$x^2\\equiv a\\pmod{pq}$ 可解当且仅当 $x^2\\equiv a\\pmod p$ 和 $x^2\\equiv a\\pmod q$ 都可解。\n\n仅使用这些基本定义和事实，找出一个具体的数对 $(n,a)$，其中 $n=pq$ 且 $p\\equiv q\\equiv 3\\bmod 4$，使得雅可比符号 $(a/n)=1$ 但同余式 $x^2\\equiv a\\pmod n$ 无解。你的选择必须满足对 $p$ 和 $q$ 的模条件，并且你必须识别出尽管 $(a/n)=1$ 但仍导致不可解性的障碍。\n\n哪个选项满足所有这些要求？\n\nA. $n=21$, $a=5$。\n\nB. $n=33$, $a=4$。\n\nC. $n=77$, $a=2$。\n\nD. $n=35$, $a=6$。", "solution": "问题陈述已经过验证，被认为是提法恰当且科学严谨的，其基础是初等数论的基本原理。\n\n任务是从给定选项中找出一个满足一组特定条件的数对 $(n,a)$。让我们首先分析这些条件，以建立一个清晰的评估标准。\n\n条件如下：\n1. $n = pq$，其中 $p$ 和 $q$ 是不同的奇素数。\n2. $p \\equiv 3 \\pmod 4$ 且 $q \\equiv 3 \\pmod 4$。\n3. 雅可比符号 $(a/n) = 1$。\n4. 同余式 $x^2 \\equiv a \\pmod n$ 无解。\n\n问题给出，$x^2 \\equiv a \\pmod n$ 可解当且仅当同余式 $x^2 \\equiv a \\pmod p$ 和 $x^2 \\equiv a \\pmod q$ 都可解。用勒让德符号表示，这意味着 $x^2 \\equiv a \\pmod n$ 可解当且仅当 $(a/p) = 1$ 且 $(a/q) = 1$。注意，为使勒让德符号为 $\\pm 1$，我们必须有 $p \\nmid a$ 和 $q \\nmid a$；如果 $p \\mid a$，则 $(a/p)=0$，同余式 $x^2 \\equiv a \\pmod p$ 变为 $x^2 \\equiv 0 \\pmod p$，其解为 $x \\equiv 0 \\pmod p$。如果对于 $a \\neq 0$ 是这种情况，那么 $a$ 将是 $p$ 的倍数，模 $n=pq$ 的可解性问题会变得更加复杂。我们将假设 $\\gcd(a,n)=1$，这对于此类问题是典型的，并且对所有提供的选项都成立。\n\n“$x^2 \\equiv a \\pmod n$ 无解”这一要求意味着，并非 $(a/p)=1$ 和 $(a/q)=1$ 同时成立。因此，$(a/p)$ 或 $(a/q)$ 中至少有一个必须是 $-1$。\n\n对雅可比符号的要求是 $(a/n) = 1$。根据定义 $(a/n) = (a/p)(a/q)$，我们有 $(a/p)(a/q) = 1$。\n\n结合这两个逻辑推论，要满足 $(a/p)(a/q) = 1$ 且其中至少一个符号为 $-1$ 的唯一方法是两者都为 $-1$。也就是说，我们必须有：\n$$(\\frac{a}{p}) = -1 \\quad \\text{和} \\quad (\\frac{a}{q}) = -1$$\n这就是问题中提到的“障碍”：尽管勒让德符号的乘积为 $1$，从而得到雅可比符号为 $1$，但同余式对素因子取模的各自不可解性，阻止了对合数 $n$ 取模的解的存在。\n\n因此，我们必须找到一个选项 $(n, a)$，使得 $n=pq$，其中 $p, q \\equiv 3 \\pmod 4$，并且 $(a/p) = -1$ 和 $(a/q) = -1$。我们将根据这些标准评估每个选项，通过枚举每个素因子模下的二次剩余来使用勒让德符号的定义。\n\n**A. $n=21, a=5$。**\n首先，我们检查 $n = 21$ 的素因子。我们有 $n=3 \\times 7$。令 $p=3$ 且 $q=7$。两者都是不同的奇素数。\n我们检查模条件：\n$p=3 \\equiv 3 \\pmod 4$。这个条件满足。\n$q=7 \\equiv 3 \\pmod 4$。这个条件满足。\n接下来，我们计算勒让德符号 $(5/3)$ 和 $(5/7)$。\n对于 $(5/3)$：$5 \\equiv 2 \\pmod 3$。我们检查 $2$ 是否是模 $3$ 的二次剩余。非零余数是 $1$ 和 $2$。将它们平方得到 $1^2 \\equiv 1 \\pmod 3$ 和 $2^2 \\equiv 4 \\equiv 1 \\pmod 3$。模 $3$ 的二次剩余集合是 $\\{1\\}$。由于 $2$ 不在此集合中，$(2/3) = -1$。因此，$(5/3) = -1$。\n对于 $(5/7)$：我们检查 $5$ 是否是模 $7$ 的二次剩余。模 $7$ 的二次剩余是 $1^2 \\equiv 1$, $2^2 \\equiv 4$, $3^2 \\equiv 9 \\equiv 2$。二次剩余的集合是 $\\{1, 2, 4\\}$。由于 $5$ 不在此集合中，$(5/7)=-1$。\n两个条件 $(a/p)=-1$ 和 $(a/q)=-1$ 都满足。\n这意味着雅可比符号 $(5/21) = (5/3)(5/7) = (-1)(-1) = 1$，满足条件3。\n此外，由于 $(5/3)=-1$，同余式 $x^2 \\equiv 5 \\pmod 3$ 无解，这又意味着 $x^2 \\equiv 5 \\pmod{21}$ 无解，满足条件4。\n这个选项满足所有要求。\n结论：**正确**。\n\n**B. $n=33, a=4$。**\n首先，我们检查 $n = 33$ 的素因子。我们有 $n=3 \\times 11$。令 $p=3$ 和 $q=11$。两者都是不同的奇素数。\n我们检查模条件：\n$p=3 \\equiv 3 \\pmod 4$。这个条件满足。\n$q=11 \\equiv 3 \\pmod 4$。这个条件满足。\n接下来，我们考察同余式 $x^2 \\equiv 4 \\pmod{33}$。\n这个同余式显然有解，因为 $x=2$ 是一个解 ($2^2 = 4$)。问题要求同余式 $x^2 \\equiv a \\pmod n$ 无解。这个选项不满足这个关键条件。为完整起见，$(4/3) = (1/3) = 1$ 且 $(4/11) = 1$，所以 $(4/33)=1$。这是一个真二次剩余的情况，而不是伪平方。\n结论：**不正确**。\n\n**C. $n=77, a=2$。**\n首先，我们检查 $n = 77$ 的素因子。我们有 $n=7 \\times 11$。令 $p=7$ 和 $q=11$。两者都是不同的奇素数。\n我们检查模条件：\n$p=7 \\equiv 3 \\pmod 4$。这个条件满足。\n$q=11 \\equiv 3 \\pmod 4$。这个条件满足。\n接下来，我们计算勒让德符号 $(2/7)$ 和 $(2/11)$。\n对于 $(2/7)$：模 $7$ 的二次剩余是 $\\{1^2, 2^2, 3^2\\} \\pmod 7 = \\{1, 4, 2\\}$。由于 $2$ 在此集合中，$(2/7)=1$。\n对于 $(2/11)$：模 $11$ 的二次剩余是 $\\{1^2, 2^2, 3^2, 4^2, 5^2\\} \\pmod{11} = \\{1, 4, 9, 16 \\equiv 5, 25 \\equiv 3\\}$。由于 $2$ 不在此集合中，$(2/11)=-1$。\n雅可比符号是 $(2/77) = (2/7)(2/11) = (1)(-1) = -1$。这不满足 $(a/n)=1$ 的条件。\n结论：**不正确**。\n\n**D. $n=35, a=6$。**\n首先，我们检查 $n = 35$ 的素因子。我们有 $n=5 \\times 7$。令 $p=5$ 和 $q=7$。\n我们检查模条件：\n$p=5 \\equiv 1 \\pmod 4$。\n$q=7 \\equiv 3 \\pmod 4$。\n两个素因子都必须同余于 $3 \\pmod 4$ 的条件未被满足。因此，这个选项从一开始就是无效的。\n结论：**不正确**。\n\n基于系统性分析，只有选项 A 满足问题规定的所有条件。", "answer": "$$\\boxed{A}$$", "id": "3027697"}, {"introduction": "将理论知识转化为实际应用是科学学习的关键环节。本练习要求你将雅可比符号的数学性质系统化，设计并实现一个高效的计算算法，其思想类似于二进制最大公约数（GCD）算法。这个练习不仅能加深你对二次互反律等规则的程序化理解，也揭示了这些数论工具在密码学和素性测试等领域中的实际计算基础。[@problem_id:3027698]", "problem": "设 $n$ 为一个正奇数，$a$ 为一个任意整数。雅可比符号 $(a/n)$ 是勒让德符号 $(a/p)$ 从奇素数 $p$ 到奇合数 $n$ 的推广。目标是推导、证明并实现一个类似二进制最大公约数（GCD）的算法，该算法仅使用二次剩余和互反律的基本性质来计算 $(a/n)$，且无需对 $n$ 进行因数分解。\n\n出发点和约束条件：\n- 仅使用以下基本事实：\n  - 勒让德符号 $(a/p)$（对于奇素数 $p$）和雅可比符号 $(a/n)$（对于奇数 $n$）的定义，及其在分子和分母上的乘法性质。\n  - 二次互反律：对于互质的奇整数 $a$ 和 $n$，有 $(a/n)\\,(n/a)=(-1)^{\\frac{(a-1)(n-1)}{4}}$。\n  - 补充定律：对于奇数 $n$，有 $(-1/n)=(-1)^{\\frac{n-1}{2}}$ 和 $(2/n)=(-1)^{\\frac{n^2-1}{8}}$。\n  - 化简性质：$(a/n)=(a \\bmod n\\,/\\,n)$。\n- 设计一个针对数对 $(a,n)$ 的化简过程，该过程模仿二进制 GCD 方法：\n  - 使用 $(2/n)$ 反复移除分子中的因子 $2$，并更新累积的符号。\n  - 在有利时应用互反律交换 $a$ 和 $n$ 的角色，并根据互反律所蕴含的奇偶性条件更新符号。\n  - 对新的分子取模以确保算法的进展。\n- 显式地跟踪符号变化，以便算法维持一个不变量，该不变量将 $(a/n)$ 的当前值表示为累积符号与一个待进一步处理的简化符号的乘积。\n- 以一个明确定义的规则终止，返回集合 $\\{-1,0,1\\}$ 中的一个整数：\n  - 如果终止时 $\\gcd(a,n)>1$，则结果必须为 $0$。\n  - 如果分母已被化简为 $1$，则结果必须是累积的符号。\n- 不要使用 $n$ 的因数分解或任何非基本的“黑箱”捷径。\n\n实现一个完整、可运行的程序，该程序：\n- 对每个测试用例，使用上述设计计算 $(a/n)$。\n- 仅使用整数算術。\n- 生成单行输出，其中包含用逗号分隔并用方括号括起来的结果列表。\n\n测试套件：\n- 案例 $1$：$a=5$, $n=11$。\n- 案例 $2$：$a=2$, $n=21$。\n- 案例 $3$：$a=10$, $n=21$。\n- 案例 $4$：$a=0$, $n=33$。\n- 案例 $5$：$a=7$, $n=15$。\n- 案例 $6$：$a=-3$, $n=35$。\n- 案例 $7$：$a=21$, $n=35$。\n- 案例 $8$：$a=1234567$, $n=1$。\n- 案例 $9$：$a=5$, $n=289$。\n- 案例 $10$：$a=3$, $n=11$。\n\n你的程序应生成一行输出，其中包含用逗号分隔并用方括号括起来的结果列表（例如，$[r_1,r_2,\\dots,r_{10}]$），其中每个 $r_i$ 是对应案例的雅可比符号在 $\\{-1,0,1\\}$ 中的整数值。", "solution": "用户希望解决一个给定的问题。\n该问题已经过验证，是合理的。\n\n该问题要求推导并实现一个算法，用于计算整数 $a$ 和正奇数 $n$ 的雅可比符号 $(a/n)$。该算法的设计风格必须类似于二进制 GCD 算法，并且必须仅依赖于一组给定的雅可比符号基本性质，而无需对 $n$ 进行因数分解。\n\n此类算法的核心原理是定义一组针对某个状态的变换，这些变换在每一步都降低问题的复杂性，同时保持最终结果不变。对于雅可比符号 $(a/n)$，其状态可以用一个三元组 $(a, n, s)$ 来表示，其中待计算的量是 $s \\cdot (a/n)$。算法从一个初始状态开始，迭代地应用变换规则，直到达到一个其值已知的终止状态。\n\n初始状态为 $(a_0, n_0, 1)$，其中 $a_0$ 和 $n_0$ 是问题的输入。我们想要计算 $1 \\cdot (a_0/n_0)$ 的值。算法流程如下：\n\n1.  **基本情况：** 定义规定，对于任意整数 $a$，有 $(a/1)=1$。因此，如果 $n=1$，结果为 $1$。另外，根据定义，如果 $\\gcd(a,n) > 1$，则 $(a/n) = 0$。处理这种情况的方法是观察到，如果算法的状态演变为 $a$ 成为 $0$ 而 $n>1$，这意味着在化简序列中较早的一个数对 $(a', n')$ 中，$n'$ 是 $a'$ 的一个因子，这会保持最大公约数不变。因此，原始的 $\\gcd(a_0, n_0)$ 必定大于 $1$。\n\n2.  **处理负数分子：** 问题陈述中包含 $a$ 為负值的情况。我们可以使用关于 $(-1/n)$ 的补充定律来处理这种情况。利用乘法性质 $(ab/n)=(a/n)(b/n)$，我们可以写出 $(-|a|/n) = (-1/n)(|a|/n)$。该定律指出 $(-1/n) = (-1)^{\\frac{n-1}{2}}$。如果 $(n-1)/2$ 为奇数（即 $n \\equiv 3 \\pmod 4$），该因子为 $-1$；如果 $(n-1)/2$ 为偶数（即 $n \\equiv 1 \\pmod 4$），则为 $1$。因此，如果 $a$ 是负数，我们将其变为正数，并在 $n \\equiv 3 \\pmod 4$ 时将累积符号 $s$ 乘以 $-1$。\n\n3.  **分子化简：** 性质 $(a/n) = (a \\bmod n\\,/\\,n)$ 允许我们减小 $a$ 的大小。我们可以随时将 $a$ 替换为 $a \\bmod n$。这一步对于确保算法终止至关重要，因为它减小了所涉及数字的大小。\n\n4.  **提取因子2：** 这一步赋予了算法“二进制 GCD”的特性。任何偶数分子 $a$ 都可以写成 $a=2^k \\cdot a'$ 的形式，其中 $a'$ 是奇数。利用乘法性质，有 $(a/n) = (2^k a'/n) = (2/n)^k (a'/n)$。对于每个因子 $2$，我们将累积符号 $s$ 乘以 $(2/n)$。第二补充定律给出 $(2/n) = (-1)^{\\frac{n^2-1}{8}}$。如果 $(n^2-1)/8$ 为奇数（即 $n \\equiv 3, 5 \\pmod 8$），该因子为 $-1$；否则为 $1$（即 $n \\equiv 1, 7 \\pmod 8$）。因此，我们可以移除 $a$ 中所有的因子 $2$，计算其数量，比如说 $k$ 个因子，如果 $k$ 是奇数，并且 $n \\equiv 3, 5 \\pmod 8$，就将 $s$ 乘以 $-1$。\n\n5.  **二次互反律：** 经过前面的步骤后，$a$ 是正数、奇数且小于 $n$。如果 $a=1$，则符号 $(1/n)=1$，其值为累积符号 $s$。如果 $a>1$，我们应用二次互反律：$(a/n)(n/a) = (-1)^{\\frac{(a-1)(n-1)}{4}}$。这使我们能够交换分子和分母：$(a/n) = (n/a) \\cdot (-1)^{\\frac{(a-1)(n-1)}{4}}$。当且仅当 $(a-1)/2$ 和 $(n-1)/2$ 均为奇数时，指数为奇数，这意味着 $a \\equiv 3 \\pmod 4$ 且 $n \\equiv 3 \\pmod 4$。所以，如果 $a$ 和 $n$ 都与 $3 \\pmod 4$ 同余，我们就将 $s$ 乘以 $-1$。然后我们交换 $a$ 和 $n$。新的问题是计算 $(n_{old}/a_{old})$，我们可以再次使用取模性质将其化简为：$(n_{old} \\bmod a_{old} \\,/\\, a_{old})$。\n\n完整的算法在一个循环中结合了这些步骤，该循环会终止，因为每次应用互反律和化简后，整数对 $(a,n)$ 的大小都会减小，这与欧几里得算法类似。\n\n算法的结构如下：\n- 初始化符号 $s=1$。\n- 处理负数 $a$ 并进行初始约简 $a \\leftarrow a \\bmod n$。\n- 进入一个只要 $a \\neq 0$ 就持续的循环：\n    - 根据 $(2/n)$ 的定律，从 $a$ 中移除所有因子 $2$ 并更新 $s$。\n    - 此后，$a$ 为奇数。如果 $a=1$，循环终止，答案为 $s$。\n    - 应用互反律来交换 $a$ 和 $n$，并在必要时更新 $s$。\n    - 将新的 $a$ 对新的 $n$ 取模。\n- 如果循环因 $a$ 变为 $0$ 而终止，则结果为 $0$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the Jacobi symbol for a list of test cases and prints the results.\n    \"\"\"\n    test_cases = [\n        (5, 11),\n        (2, 21),\n        (10, 21),\n        (0, 33),\n        (7, 15),\n        (-3, 35),\n        (21, 35),\n        (1234567, 1),\n        (5, 289),\n        (3, 11),\n    ]\n\n    def jacobi(a, n):\n        \"\"\"\n        Computes the Jacobi symbol (a/n) using a binary GCD-like algorithm.\n\n        Args:\n            a: An arbitrary integer.\n            n: A positive odd integer.\n        \n        Returns:\n            An integer in {-1, 0, 1}.\n        \"\"\"\n        # Per the problem statement, n is a positive odd integer.\n        # Rule: (a/1) = 1\n        if n == 1:\n            return 1\n\n        # State initialization: the desired value is s * (a/n)\n        s = 1\n\n        # Step 1: Handle negative a using (-1/n) = (-1)^((n-1)/2)\n        if a < 0:\n            a = -a\n            # Sign flips if n = 3 (mod 4)\n            if (n & 3) == 3:  # n % 4 == 3\n                s = -s\n        \n        # Step 2: Initial reduction\n        a %= n\n\n        # Main loop: reduces (a,n) until a is 0 or 1\n        while a != 0:\n            # Step 3: Remove factors of 2 from a, using (2/n) = (-1)^((n^2-1)/8)\n            # k is the number of factors of 2 in a.\n            # (a & -a) isolates the lowest set bit. Its bit_length - 1 is the number of trailing zeros.\n            k = (a & -a).bit_length() - 1\n            a >>= k\n            \n            # If k is odd, update sign based on n mod 8.\n            if (k & 1):  # k % 2 == 1\n                n_mod_8 = n & 7  # n % 8\n                if n_mod_8 == 3 or n_mod_8 == 5:\n                    s = -s\n            \n            # Base case for termination\n            if a == 1:\n                return s\n\n            # Step 4: Apply quadratic reciprocity: (a/n) = (n/a) * (-1)^(((a-1)/2)*((n-1)/2))\n            # Sign flips if a = 3 (mod 4) and n = 3 (mod 4)\n            if (a & 3) == 3 and (n & 3) == 3:\n                s = -s\n            \n            # Step 5: Swap a and n, and reduce. This ensures progress.\n            a, n = n, a\n            a %= n\n        \n        # If loop terminates, a became 0, which implies gcd(original_a, original_n) > 1.\n        return 0\n\n    results = [jacobi(a, n) for a, n in test_cases]\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3027698"}]}