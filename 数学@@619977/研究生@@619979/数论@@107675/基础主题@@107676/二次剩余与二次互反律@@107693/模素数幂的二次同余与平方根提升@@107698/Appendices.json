{"hands_on_practices": [{"introduction": "掌握了理论之后，首要任务是通过具体计算来巩固核心技巧。这个练习旨在通过求解一个一般形式的二次同余方程来直接应用亨塞尔引理（Hensel's Lemma）。通过完成配方并将问题转化为求解判别式 $\\Delta$ 的模 $p^k$ 平方根，你将亲手实践从模 $p$ 的初始解迭代提升至模 $p^k$ 的完整过程，这是解决多项式同余问题的基础。[@problem_id:3021640]", "problem": "设 $p$ 为一个奇素数，我们考虑在环 $\\mathbb{Z}/p^{k}\\mathbb{Z}$ 中模素数幂的同余。对于给定的整数 $b$ 和 $c$，二次同余式 $x^{2} - b x + c \\equiv 0 \\pmod{p^{k}}$ 可以通过其判别式 $\\Delta = b^{2} - 4 c$ 进行分析。从模素数幂的同余、模素数的二次剩余以及通过亨塞尔引理提升解的存在性和唯一性准则等基本定义出发，完成以下任务：\n- 判断 $\\Delta$ 是否为模 $p$ 的平方数。\n- 如果是，将 $\\Delta$ 模 $p$ 的一个适当的平方根提升为模 $p^{k}$ 的平方根。\n- 用提升后的平方根表示 $x^{2} - b x + c \\equiv 0 \\pmod{p^{k}}$ 的解，并从基本原理出发论证每一步。\n\n具体地，取 $p = 19$, $k = 4$, $b = 34$, $c = 17$。计算 $\\Delta = b^{2} - 4 c$ 模 $19^{4}$ 的一个平方根 $y$，该平方根由一个选定的模 $19$ 的平方根提升而来，然后确定以下两个解：\n$$\nx \\equiv \\frac{b \\pm y}{2} \\pmod{19^{4}}.\n$$\n在所有与区间 $[0, 19^{4} - 1]$ 内整数同余于模 $19^{4}$ 的解中，报告最小的非负解作为您的最终答案。无需取整，最终答案必须表示为单个整数。", "solution": "问题要求我们求解二次同余式 $x^{2} - b x + c \\equiv 0 \\pmod{p^{k}}$，其中具体值为 $p = 19$, $k = 4$, $b = 34$, $c = 17$。求解过程包括求判别式 $\\Delta = b^2 - 4c$ 模 $p^k$ 的平方根，然后用这些平方根来确定 $x$ 的值。\n\n给定的同余式为 $x^2 - 34x + 17 \\equiv 0 \\pmod{19^4}$。由于模 $19^4$ 是奇素数 $p=19$ 的幂，我们可以进行配方。将同余式两边乘以 $4$（$4$ 模 $19^4$ 可逆），我们得到：\n$$4x^2 - 4bx + 4c \\equiv 0 \\pmod{p^k}$$\n$$(2x - b)^2 - b^2 + 4c \\equiv 0 \\pmod{p^k}$$\n$$(2x - b)^2 \\equiv b^2 - 4c \\pmod{p^k}$$\n设 $\\Delta = b^2 - 4c$ 为判别式。同余式变为 $(2x - b)^2 \\equiv \\Delta \\pmod{p^k}$。为了解出 $x$，我们必须首先求出 $\\Delta$ 模 $p^k$ 的平方根。设 $y$ 是这样一个平方根，即 $y^2 \\equiv \\Delta \\pmod{p^k}$。于是我们有：\n$$2x - b \\equiv \\pm y \\pmod{p^k}$$\n$$2x \\equiv b \\pm y \\pmod{p^k}$$\n由于 $p=19$ 是奇数，$2$ 存在模 $p^k$ 的乘法逆元。因此，$x$ 的两个解由下式给出：\n$$x \\equiv 2^{-1}(b \\pm y) \\pmod{p^k}$$\n\n首先，我们使用给定的值 $b=34$ 和 $c=17$ 计算判别式 $\\Delta$：\n$$\\Delta = 34^2 - 4(17) = 1156 - 68 = 1088$$\n所以我们需要解 $y^2 \\equiv 1088 \\pmod{19^4}$。过程是首先找到一个模 $p=19$ 的平方根，然后使用亨塞尔引理将此根依次提升到模 $19^2$、$19^3$ 和 $19^4$。\n\n步骤 1：求 $\\Delta$ 模 $p=19$ 的平方根。\n我们需要解 $y_1^2 \\equiv 1088 \\pmod{19}$。\n$1088 = 57 \\times 19 + 5$，所以 $1088 \\equiv 5 \\pmod{19}$。\n我们需要找到 $y_1$ 使得 $y_1^2 \\equiv 5 \\pmod{19}$。我们可以测试一些值：$1^2 \\equiv 1$, $2^2 \\equiv 4$, ..., $9^2 = 81 = 4 \\times 19 + 5 \\equiv 5 \\pmod{19}$。\n所以，一个平方根是 $y_1 = 9$。另一个是 $-y_1 \\equiv -9 \\equiv 10 \\pmod{19}$。我们选择 $y_1 = 9$ 开始提升过程。\n\n步骤 2：将根从模 $19$ 提升到模 $19^2$。\n设 $f(y) = y^2 - \\Delta$。我们有 $f(y) \\equiv 0 \\pmod{19}$ 的一个根 $y_1 = 9$。我们寻找一个形式为 $y_2 = y_1 + 19t_1$ 的模 $19^2$ 的根 $y_2$。\n根据亨塞尔引理，修正项 $t_1$ 可通过求解以下线性同余式得到：\n$$f(y_1) + f'(y_1) (19 t_1) \\equiv 0 \\pmod{19^2}$$\n$$(y_1^2 - \\Delta) + (2y_1)(19t_1) \\equiv 0 \\pmod{19^2}$$\n两边同时除以 $19$（因为 $y_1^2 - \\Delta$ 是 $19$ 的倍数）：\n$$\\frac{y_1^2 - \\Delta}{19} + 2y_1 t_1 \\equiv 0 \\pmod{19}$$\n$$t_1 \\equiv -\\frac{y_1^2 - \\Delta}{19} (2y_1)^{-1} \\pmod{19}$$\n我们计算各个部分：\n$y_1^2 - \\Delta = 9^2 - 1088 = 81 - 1088 = -1007$。\n$\\frac{y_1^2 - \\Delta}{19} = \\frac{-1007}{19} = -53$。\n$-53 \\equiv -53 + 3 \\times 19 = -53 + 57 = 4 \\pmod{19}$。\n$f'(y_1) = 2y_1 = 2(9) = 18 \\equiv -1 \\pmod{19}$。其逆元为 $(f'(y_1))^{-1} \\equiv (-1)^{-1} \\equiv -1 \\pmod{19}$。\n所以，$t_1 \\equiv - (4) \\cdot (-1) \\equiv 4 \\pmod{19}$。\n提升后的根为 $y_2 = y_1 + 19t_1 = 9 + 19(4) = 9 + 76 = 85$。\n检验：$y_2^2 = 85^2 = 7225$。$y_2^2 - \\Delta = 7225 - 1088 = 6137$。并且 $6137 = 17 \\times 361 = 17 \\times 19^2$。所以 $y_2^2 \\equiv 1088 \\pmod{19^2}$。\n\n步骤 3：将根从模 $19^2$ 提升到模 $19^3$。\n我们寻找一个形式为 $y_3 = y_2 + 19^2 t_2$ 的模 $19^3$ 的根 $y_3$。修正项 $t_2$ 由下式给出：\n$$t_2 \\equiv -\\frac{y_2^2 - \\Delta}{19^2} (2y_2)^{-1} \\pmod{19}$$\n我们有 $y_2^2 - \\Delta = 6137$。\n$\\frac{y_2^2 - \\Delta}{19^2} = \\frac{6137}{361} = 17$。\n$2y_2 = 2(85) = 170$。模 $19$，$170 = 8 \\times 19 + 18 \\equiv 18 \\equiv -1 \\pmod{19}$。\n所以 $(2y_2)^{-1} \\equiv -1 \\pmod{19}$。\n$t_2 \\equiv - (17) \\cdot (-1) \\equiv 17 \\pmod{19}$。\n提升后的根为 $y_3 = y_2 + 19^2 t_2 = 85 + 361(17) = 85 + 6137 = 6222$。\n\n步骤 4：将根从模 $19^3$ 提升到模 $19^4$。\n我们寻找一个形式为 $y_4 = y_3 + 19^3 t_3$ 的模 $19^4$ 的根 $y_4$。修正项 $t_3$ 为：\n$$t_3 \\equiv -\\frac{y_3^2 - \\Delta}{19^3} (2y_3)^{-1} \\pmod{19}$$\n$y_3^2 = 6222^2 = 38713284$。\n$y_3^2 - \\Delta = 38713284 - 1088 = 38712196$。\n$\\frac{y_3^2 - \\Delta}{19^3} = \\frac{38712196}{6859} = 5644$。\n模 $19$，$5644 = 297 \\times 19 + 1 \\equiv 1 \\pmod{19}$。\n$2y_3 = 2(6222) = 12444$。模 $19$, $6222 = 327 \\times 19 + 9 \\equiv 9 \\pmod{19}$。所以 $2y_3 \\equiv 2(9) = 18 \\equiv -1 \\pmod{19}$。\n因此 $(2y_3)^{-1} \\equiv -1 \\pmod{19}$。\n$t_3 \\equiv - (1) \\cdot (-1) \\equiv 1 \\pmod{19}$。\n最终提升的根是 $y = y_4 = y_3 + 19^3 t_3 = 6222 + 6859(1) = 13081$。\n所以，$\\Delta = 1088$ 模 $19^4 = 130321$ 的一个平方根是 $y = 13081$。另一个是 $-y \\equiv -13081 \\equiv 130321 - 13081 = 117240 \\pmod{130321}$。\n\n步骤 5：计算 $x$ 的解。\n解可以通过求解 $2x \\equiv b \\pm y \\pmod{19^4}$ 来找到。我们有 $b = 34$ 和 $y = 13081$，模为 $m=19^4 = 130321$。\n\n解 1：$2x_1 \\equiv b + y = 34 + 13081 = 13115 \\pmod{130321}$。\n由于 $13115$ 是奇数，模 $130321$ 也是奇数，我们可以写成 $2x_1 \\equiv 13115 + 130321 \\pmod{130321}$，这使得右边成为偶数。\n$2x_1 \\equiv 143436 \\pmod{130321}$。\n$x_1 \\equiv \\frac{143436}{2} = 71718 \\pmod{130321}$。\n\n解 2：$2x_2 \\equiv b - y = 34 - 13081 = -13047 \\pmod{130321}$。\n我们可以写成 $2x_2 \\equiv -13047 + 130321 \\pmod{130321}$ 以使右边为正偶数。\n$2x_2 \\equiv 117274 \\pmod{130321}$。\n$x_2 \\equiv \\frac{117274}{2} = 58637 \\pmod{130321}$。\n\n在区间 $[0, 19^4-1]$ 内，$x$ 的两个解是 $71718$ 和 $58637$。\n\n步骤 6：最终答案。\n问题要求最小非负解。比较这两个解，$58637 < 71718$。\n因此，最小非负解是 $58637$。", "answer": "$$\n\\boxed{58637}\n$$", "id": "3021640"}, {"introduction": "在掌握了针对单个素数幂的提升技巧后，下一步自然是处理合数模的情况。本练习要求你综合运用中国剩余定理（CRT）和素数幂模下的求解方法。你需要分别解决模为 $2^4$、$3^3$ 和 $5$ 的同余方程——特别要注意素数 $p=2$ 的特殊性——然后将这些解合成为模 $n$ 下的完整解集，这对于理解解的整体结构至关重要。[@problem_id:3021642]", "problem": "设 $n = 2^{4} \\cdot 3^{3} \\cdot 5$ 且 $a = 1$。考虑二次同余式 $x^{2} \\equiv a \\pmod{n}$。请利用关于模素数幂的二次剩余的基本原理，并结合中国剩余定理（CRT）进行求解。具体而言：\n\n1. 在需要时，通过从素数模到素数幂的适当提升方法，确定 $x^{2} \\equiv 1 \\pmod{2^{4}}$，$x^{2} \\equiv 1 \\pmod{3^{3}}$ 和 $x^{2} \\equiv 1 \\pmod{5}$ 的所有解，然后明确地使用中国剩余定理（CRT）来构造模 $n$ 的完整解集。\n\n2. 设 $S$ 表示在标准剩余系 $0 \\leq x < n$ 中所有不同解代表元的和。计算 $S$ 的精确整数值。\n\n最终答案必须是 $S$ 的单个整数值。", "solution": "问题要求计算二次同余式 $x^{2} \\equiv 1 \\pmod{n}$ 在范围 $0 \\leq x < n$ 内所有不同解的和，其中 $n = 2^{4} \\cdot 3^{3} \\cdot 5$。\n首先，我们计算 $n$ 的值：\n$$n = 2^{4} \\cdot 3^{3} \\cdot 5 = 16 \\cdot 27 \\cdot 5 = 16 \\cdot 135 = 2160$$\n需要求解的同余式是 $x^{2} \\equiv 1 \\pmod{2160}$。\n根据中国剩余定理，求解此同余式等价于求解以下同余方程组：\n1. $x^{2} \\equiv 1 \\pmod{16}$\n2. $x^{2} \\equiv 1 \\pmod{27}$\n3. $x^{2} \\equiv 1 \\pmod{5}$\n\n我们将按照题目要求，逐个求解这些同余式。\n\n**求解 $x^{2} \\equiv 1 \\pmod{5}$**\n因为 $5$ 是一个素数，同余式 $x^{2} - 1 \\equiv 0 \\pmod{5}$，即 $(x-1)(x+1) \\equiv 0 \\pmod{5}$，意味着 $x-1 \\equiv 0 \\pmod{5}$ 或 $x+1 \\equiv 0 \\pmod{5}$。这给出了两个不同的解：\n$x \\equiv 1 \\pmod{5}$\n$x \\equiv -1 \\equiv 4 \\pmod{5}$\n因此，模 $5$ 有 $2$ 个解。\n\n**求解 $x^{2} \\equiv 1 \\pmod{27}$**\n我们必须求解 $x^{2} \\equiv 1 \\pmod{3^3}$。我们从基础情况 $x^{2} \\equiv 1 \\pmod{3}$ 开始。与模 5 的情况一样，解为 $x \\equiv \\pm 1 \\pmod{3}$。\n对于一个奇素数 $p$，$x^2 \\equiv 1 \\pmod{p^k}$ 的解可以通过从模 $p$ 的解提升得到。设 $f(x) = x^2 - 1$，则 $f'(x) = 2x$。对于 $f(x) \\equiv 0 \\pmod{p}$ 的一个解 $x_0$，如果 $f'(x_0) \\not\\equiv 0 \\pmod{p}$，那么对于任何 $k \\geq 1$，它都可以被提升为模 $p^k$ 的一个唯一解。\n$x^2 \\equiv 1 \\pmod 3$ 的解是 $x_0 = 1$ 和 $x_0 = -1$。\n对于 $x_0 = \\pm 1$，我们有 $f'(x_0) = 2(\\pm 1) = \\pm 2 \\not\\equiv 0 \\pmod{3}$。\n因此，每个解都能唯一提升。解 $x \\equiv 1 \\pmod{3}$ 对于任何 $k \\geq 1$ 都提升为 $x \\equiv 1 \\pmod{3^k}$。类似地，$x \\equiv -1 \\pmod{3}$ 提升为 $x \\equiv -1 \\pmod{3^k}$。\n因此，对于 $k=3$，$x^{2} \\equiv 1 \\pmod{27}$ 的解是：\n$x \\equiv 1 \\pmod{27}$\n$x \\equiv -1 \\equiv 26 \\pmod{27}$\n因此，模 $27$ 有 $2$ 个解。\n\n**求解 $x^{2} \\equiv 1 \\pmod{16}$**\n$p=2$ 的情况是特殊的。提升的论证方法不同。这是一个已知的结果：对于 $k \\ge 3$，同余式 $x^2 \\equiv 1 \\pmod{2^k}$ 恰好有四个解。这些解是 $x \\equiv \\pm 1 \\pmod{2^k}$ 和 $x \\equiv \\pm(1+2^{k-1}) \\pmod{2^k}$。\n对于我们的问题，我们有 $k=4$。$x^{2} \\equiv 1 \\pmod{16}$ 的解是：\n$x \\equiv 1 \\pmod{16}$\n$x \\equiv -1 \\equiv 15 \\pmod{16}$\n$x \\equiv 1+2^{4-1} = 1+8 = 9 \\pmod{16}$\n$x \\equiv -(1+2^{4-1}) = -9 \\equiv 7 \\pmod{16}$\n我们来验证这些解：$1^2 \\equiv 1 \\pmod{16}$，$15^2 = (-1)^2 \\equiv 1 \\pmod{16}$，$9^2=81 = 5 \\cdot 16 + 1 \\equiv 1 \\pmod{16}$，以及 $7^2=49 = 3 \\cdot 16 + 1 \\equiv 1 \\pmod{16}$。\n这四个解是 $x \\in \\{1, 7, 9, 15\\}$。因此，模 $16$ 有 $4$ 个解。\n\n**统合解并计算它们的和 $S$**\n根据 CRT，对于来自各个同余式的解的任意组合 $(s_1, s_2, s_3)$，其中 $s_1 \\in \\{1, 7, 9, 15\\}$，$s_2 \\in \\{1, 26\\}$，且 $s_3 \\in \\{1, 4\\}$，都存在一个唯一的模 $n=2160$ 的解 $x$。\n解的总数是每个模的解的数量的乘积：$4 \\times 2 \\times 2 = 16$。\n设 $X$ 是在标准剩余系 $0 \\leq x < n$ 中的这 16 个不同解的集合。我们需要计算 $S = \\sum_{x \\in X} x$。\n\n如果 $x$ 是 $x^2 \\equiv 1 \\pmod n$ 的一个解，那么 $(-x)^2 = x^2 \\equiv 1 \\pmod n$，所以 $-x$ 也是一个解。在剩余系 $\\{0, 1, \\dots, n-1\\}$ 中，$-x$ 的代表元是 $n-x$（对于 $x \\neq 0$）。\n因为 $1 \\not\\equiv 0 \\pmod n$，所以 $x=0$ 不是一个解。因此，对于每个解 $x$，$n-x$ 也是一个解。\n这些解可以被分组成对 $\\{x, n-x\\}$，前提是 $x \\neq n-x$。如果 $x = n-x$，那么 $2x=n$，这意味着 $x = n/2$。我们必须检查 $x=n/2$ 是否是该同余式的一个解。\n这里，$n=2160$，所以 $n/2 = 1080$。我们检查 $x=1080$ 是否满足 $x^2 \\equiv 1 \\pmod{2160}$。\n$1080^2 = (1080)(1080) = \\frac{2160}{2} \\cdot 1080 = 2160 \\cdot 540$\n所以，$1080^2 \\equiv 0 \\pmod{2160}$。\n因为 $0 \\not\\equiv 1 \\pmod{2160}$，所以 $x=1080$ 不是一个解。\n这证实了对于集合 $X$ 中的每个解 $x$，$n-x$ 也是一个解，并且 $x \\neq n-x$。因此，这 16 个解可以被划分为 $16/2 = 8$ 个形式为 $\\{x_i, n-x_i\\}$ 的不同配对。\n\n每个这样的配对中的元素之和是 $x_i + (n-x_i) = n$。\n总和 $S$ 是这 8 个配对的和：\n$$S = \\sum_{i=1}^{8} (x_i + (n-x_i)) = \\sum_{i=1}^{8} n = 8n$$\n现在，我们计算 $S$ 的数值：\n$$n = 2160$$\n$$S = 8 \\times 2160 = 17280$$\n\n所有不同解的和是 $17280$。", "answer": "$$\\boxed{17280}$$", "id": "3021642"}, {"introduction": "从理论计算到算法实现是深化理解的关键一步，本练习将引导你完成这个跨越。你需要将求解平方根的完整流程——从使用 Tonelli-Shanks 算法找到模素数 $p$ 的初始根，到反复应用亨塞尔引理的提升步骤——转化为具体的计算机程序。通过编写代码，你不仅能验证理论的正确性，还能对算法的每一步细节建立起牢固的、可操作的认识，为将来从事计算数论相关的研究打下坚实基础。[@problem_id:3021637]", "problem": "设 $p$ 是一个奇素数，$k$ 是一个正整数，$a$ 是模 $p^{k}$ 整数环中的一个单位。$\\mathbb{Z}/p^{k}\\mathbb{Z}$ 中的单位是由一个整数 $a$ 代表的等价类，其中 $\\gcd(a,p)=1$。模素数 $p$ 的单位乘法群是循环的，而模 $p$ 的二次剩余是指那些使得 $x^{2}\\equiv a\\pmod{p}$ 有解的 $a$。判断模 $p$ 二次剩余性的标准方法是 Euler 准则，它使用 Legendre 符号 $\\left(\\frac{a}{p}\\right)$，定义为 $\\left(\\frac{a}{p}\\right)\\equiv a^{\\frac{p-1}{2}}\\pmod{p}$。其中，如果 $a$ 是模 $p$ 的二次剩余，则 $\\left(\\frac{a}{p}\\right)=1$；如果 $a$ 是模 $p$ 的二次非剩余，则 $\\left(\\frac{a}{p}\\right)=-1$；如果 $p \\mid a$，则 $\\left(\\frac{a}{p}\\right)=0$。\n\n当 $p$ 是奇素数，$a$ 是一个单位且为模 $p$ 的二次剩余时，求解 $x^{2}\\equiv a\\pmod{p^{k}}$ 的一个计算路径如下：\n- 使用一种利用 $(\\mathbb{Z}/p\\mathbb{Z})^{\\times}$ 循环结构的方法找到模 $p$ 的一个平方根（例如，将 $p-1$ 分解为 $Q\\cdot 2^{S}$（其中 $Q$ 为奇数）并使用一个二次非剩余来迭代修正候选根的算法），然后\n- 使用一个在根处的 $f(x)=x^{2}-a$ 导数的非退化条件下保证提升唯一性的定理，将该根提升到 $p$ 的更高次幂，从而获得一系列模 $p^{n}$（其中 $n=2,3,\\ldots,k$）的解。\n\n你的任务是，对下方的每个测试用例，通过以下步骤实现一个特定单位 $a$ 模 $p^{10}$ 的平方根的计算：\n1. 对奇素数使用上述基于群结构的方法计算一个模 $p$ 的平方根，以及\n2. 基于导数条件应用恰好 9 次连续提升以达到模 $p^{10}$ 的结果，避免任何临时的闭式解快捷方式。\n\n假设：\n- $p$ 是一个奇素数。\n- $a$ 与 $p$ 互素，且 $a$ 是模 $p$ 的二次剩余（因此模 $p$ 的平方根存在）。\n- 对于模 $p$ 的起始根 $x$，非退化条件 $p\\nmid 2x$ 成立（对于奇素数 $p$ 和单位 $a$，此条件自动满足）。\n\n测试套件（每个用例是一个数对 $(p,a)$，其中 $a$ 是一个显式平方模 $p$ 的约化结果，以确保其二次剩余性）：\n- 用例 1：$p=101$，$a\\equiv 12^{2}\\equiv 144\\equiv 43\\pmod{101}$，因此使用 $a=43$。\n- 用例 2：$p=97$，$a\\equiv 5^{2}\\equiv 25\\pmod{97}$，因此使用 $a=25$。\n- 用例 3：$p=3$，$a\\equiv 1^{2}\\equiv 1\\pmod{3}$，因此使用 $a=1$。\n- 用例 4：$p=5$，$a\\equiv 2^{2}\\equiv 4\\pmod{5}$，因此使用 $a=4$。\n\n覆盖性设计：\n- 用例 1 测试一个普通的奇素数，其 $p-1$ 的因数分解中包含一个适中大小的 2 的幂。\n- 用例 2 测试一个奇素数 $p$，其 $p-1$ 的因数分解中包含一个更大的 2 的幂。\n- 用例 3 测试最小的奇素数 $p=3$，其 $p-1$ 的因数分解中 2 的幂最小。\n- 用例 4 测试 $p=5$，其 $p-1$ 中 2 的幂等于 2。\n\n对于每个用例，你的程序必须产出一个在范围 $0\\leq x<p^{10}$ 内的整数代表 $x$，该整数满足 $x^{2}\\equiv a\\pmod{p^{10}}$，并且其模 $p$ 的结果等于步骤 1 中获得并选定的平方根。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个条目是对应测试用例计算出的模 $p^{10}$ 的整数 $x$，并按以上列出的顺序排列（例如，$\\left[\\text{result}_{1},\\text{result}_{2},\\text{result}_{3},\\text{result}_{4}\\right]$）。不涉及任何单位；每个答案都是一个纯整数。", "solution": "任务是为几对奇素数 $p$ 和单位 $a$ 求解二次同余式 $x^2 \\equiv a \\pmod{p^{10}}$。问题指定了一种两步法：\n1.  使用Tonelli-Shanks算法找到 $a$ 模 $p$ 的一个平方根 $r_1$。\n2.  使用亨塞尔引理将这个根 $r_1$ 连续提升九次，以找到一个模 $p^{10}$ 的根。\n\n### 基于原理的算法设计\n\n**步骤 1：寻找模素数 $p$ 的平方根（Tonelli-Shanks算法）**\n\n同余式 $x^2 \\equiv a \\pmod p$ 有解，当且仅当 $a$ 是模 $p$ 的二次剩余。这等价于 Legendre 符号条件 $\\left(\\frac{a}{p}\\right) = 1$，或者根据 Euler 准则，$a^{(p-1)/2} \\equiv 1 \\pmod p$。问题保证所有测试用例都满足此条件。\n\nTonelli-Shanks算法是找到这样一个根 $x$ 的标准方法。其核心思想是在循环乘法群 $(\\mathbb{Z}/p\\mathbb{Z})^\\times$ 内进行计算。\n首先，我们将 $p-1$ 分解为 $Q \\cdot 2^S$，其中 $Q$ 是奇数且 $S \\ge 1$。\n- 如果 $S=1$，即 $p \\equiv 3 \\pmod 4$，则根可以直接计算为 $x \\equiv a^{(p+1)/4} \\pmod p$。\n- 如果 $S > 1$，即 $p \\equiv 1 \\pmod 4$，则需要一个更通用的过程。我们找到一个模 $p$ 的二次非剩余 $z$（即 $z^{(p-1)/2} \\equiv -1 \\pmod p$）。然后算法初始化一个候选根 $R = a^{(Q+1)/2} \\pmod p$ 和一个误差跟踪项 $t = a^Q \\pmod p$。$t$ 的阶必须是 2 的幂。算法通过将 $R$ 乘以精心选择的 $c=z^Q$ 的幂来迭代地降低 $t$ 的阶，直到 $t \\equiv 1 \\pmod p$。算法终止时，$R$ 就是 $a$ 的一个平方根。\n\n**步骤 2：将解提升至模 $p^k$（亨塞尔引理）**\n\n亨塞尔引理提供了一种方法，可以将一个多项式同余的解从模 $p^n$ 提升到模 $p^{n+1}$，前提是该解是非奇异的。对于我们的问题，多项式是 $f(x) = x^2 - a$。\n\n设 $r_n$ 是 $x^2 \\equiv a \\pmod{p^n}$ 的一个整数解。这意味着对于某个整数 $c_n$ 有 $r_n^2 - a = c_n p^n$。我们寻求一个模 $p^{n+1}$ 的新解 $r_{n+1}$，其形式为 $r_{n+1} = r_n + t p^n$，其中整数 $t \\in \\{0, 1, \\ldots, p-1\\}$。\n\n我们要求 $f(r_{n+1}) \\equiv 0 \\pmod{p^{n+1}}$。代入 $r_{n+1}$ 的形式：\n$$ (r_n + t p^n)^2 - a \\equiv 0 \\pmod{p^{n+1}} $$\n$$ r_n^2 + 2r_n t p^n + t^2 p^{2n} - a \\equiv 0 \\pmod{p^{n+1}} $$\n$$ (r_n^2 - a) + 2r_n t p^n + t^2 p^{2n} \\equiv 0 \\pmod{p^{n+1}} $$\n\n由于 $n \\ge 1$，项 $t^2 p^{2n}$ 可被 $p^{n+1}$ 整除，因此可以忽略。我们代入 $r_n^2 - a = c_n p^n$：\n$$ c_n p^n + 2r_n t p^n \\equiv 0 \\pmod{p^{n+1}} $$\n\n将该同余式两边除以 $p^n$，我们得到一个关于 $t$ 模 $p$ 的线性同余式：\n$$ c_n + 2r_n t \\equiv 0 \\pmod p $$\n$$ 2r_n t \\equiv -c_n \\pmod p $$\n\n由于 $p$ 是一个奇素数且 $a$ 是一个单位，初始根 $r_1$ 不能被 $p$ 整除。因此，$2r_1 \\not\\equiv 0 \\pmod p$，其模 $p$ 的乘法逆元 $(2r_1)^{-1} \\pmod p$ 存在。由于 $r_n \\equiv r_1 \\pmod p$，逆元 $(2r_n)^{-1} \\pmod p$ 也存在且等于 $(2r_1)^{-1} \\pmod p$。我们可以解出 $t$：\n$$ t \\equiv -c_n \\cdot (2r_n)^{-1} \\pmod p $$\n其中整数 $c_n$ 计算为 $c_n = (r_n^2 - a) / p^n$。\n\n提升过程如下：\n1.  从 Tonelli-Shanks算法得到的根 $r_1$ 开始，它是模 $p^1=p$ 的一个解。\n2.  对于 $n$ 从 $1$ 到 $9$：\n    a. 设当前根为 $r_n$，模为 $p^n$。\n    b. 计算误差系数 $c_n = (r_n^2 - a) // p^n$。\n    c. 计算修正项 $t \\equiv -c_n \\cdot (2r_1)^{-1} \\pmod p$。\n    d. 新根为 $r_{n+1} = r_n + t \\cdot p^n$。\n3.  经过 9 次迭代后，最终的整数 $r_{10}$ 是 $x^2 \\equiv a \\pmod{p^{10}}$ 的一个解。Python 的整数运算能力足以处理所涉及的大数。如果我们从 $r_1 \\in [0, p-1]$ 开始，并且总是选择 $t \\in [0, p-1]$，则得到的整数 $r_{10}$ 将位于所需范围 $[0, p^{10}-1]$ 内。\n\n这个两步过程将被实施于每个测试用例，以产生所需的结果。", "answer": "```python\nimport numpy as np\n\n# Note: The problem requires numpy to be imported, but it is not used as\n# Python's built-in arbitrary-precision integers are sufficient.\n\ndef solve():\n    \"\"\"\n    Solves the main problem by iterating through test cases and applying\n    the required number theory algorithms.\n    \"\"\"\n\n    def _tonelli_shanks(n, p):\n        \"\"\"\n        Implements the Tonelli-Shanks algorithm to find a square root of n mod p.\n        _tonelli_shanks(n: int, p: int) -> int\n        \n        Args:\n            n: An integer which is a quadratic residue modulo p.\n            p: An odd prime.\n            \n        Returns:\n            An integer x such that x^2 = n (mod p).\n        \"\"\"\n        # Euler's criterion check (guaranteed by problem statement)\n        if pow(n, (p - 1) // 2, p) != 1:\n            raise ValueError(\"n is not a quadratic residue modulo p\")\n\n        # Simple case for p = 3 (mod 4)\n        if p % 4 == 3:\n            return pow(n, (p + 1) // 4, p)\n\n        # Factor p-1 = Q * 2^S\n        Q = p - 1\n        S = 0\n        while Q % 2 == 0:\n            Q //= 2\n            S += 1\n\n        # Find a quadratic non-residue z\n        z = 2\n        while pow(z, (p - 1) // 2, p) == 1:\n            z += 1\n\n        # Initialize for the main loop\n        M = S\n        c = pow(z, Q, p)\n        t = pow(n, Q, p)\n        R = pow(n, (Q + 1) // 2, p)\n\n        # Main loop\n        while t != 1:\n            if t == 0:\n                return 0\n            \n            # Find the smallest i > 0 such that t^(2^i) == 1 mod p\n            i = 0\n            temp_t = t\n            while temp_t != 1:\n                temp_t = (temp_t * temp_t) % p\n                i += 1\n            \n            # This should not happen if n is a valid quadratic residue\n            if i >= M:\n                raise RuntimeError(\"Tonelli-Shanks failed, algorithm error.\")\n\n            # Update variables for the next iteration\n            b = pow(c, pow(2, M - i - 1), p)\n            M = i\n            c = (b * b) % p\n            t = (t * c) % p\n            R = (R * b) % p\n        \n        return R\n\n    def _lift_root(p, a):\n        \"\"\"\n        Computes the square root of a modulo p^10 using Tonelli-Shanks\n        and Hensel's Lemma for lifting.\n        _lift_root(p: int, a: int) -> int\n\n        Args:\n            p: An odd prime.\n            a: An integer that is a unit and quadratic residue mod p.\n\n        Returns:\n            An integer x in [0, p^10 - 1] such that x^2 = a (mod p^10).\n        \"\"\"\n        # Step 1: Find a square root modulo p\n        r1 = _tonelli_shanks(a, p)\n\n        # Step 2: Lift the root from p to p^10 (9 lifts)\n        k = 10\n        \n        # Precompute the inverse of the derivative f'(x)=2x at r1 mod p.\n        # This inverse is used in every lifting step.\n        inv_2r1 = pow(2 * r1, -1, p)\n        \n        r_current = r1\n        p_power = p\n        \n        # Perform 9 successive lifts.\n        for _ in range(1, k):\n            # Let r_current be a root mod p_power. r_current^2 - a = c * p_power.\n            # We seek a new root r_new = r_current + t * p_power mod (p_power * p).\n            # The correction term t is found by solving:\n            # t = -((r_current^2 - a) / p_power) * (2*r_current)^-1 mod p\n            \n            c = (r_current * r_current - a) // p_power\n            t = (-c * inv_2r1) % p\n            \n            # Update the root and the modulus for the next iteration.\n            r_current = r_current + t * p_power\n            p_power *= p\n            \n        return r_current\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (101, 43),  # Case 1\n        (97, 25),   # Case 2\n        (3, 1),     # Case 3\n        (5, 4),     # Case 4\n    ]\n\n    results = []\n    for p, a in test_cases:\n        result = _lift_root(p, a)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3021637"}]}