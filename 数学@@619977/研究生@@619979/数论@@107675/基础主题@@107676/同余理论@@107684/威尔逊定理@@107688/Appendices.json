{"hands_on_practices": [{"introduction": "威尔逊定理为我们提供了计算 $(p-1)!$ 模素数 $p$ 的直接方法。然而，在实际应用中，我们经常需要处理与 $(p-1)!$ 相关的其他阶乘表达式。本练习旨在引导你迈出第一步，通过简单的代数变换，将威尔逊定理应用于计算如 $(p-2)!$ 等相关表达式的模 $p$ 值，这是解决许多数论问题所需的基本技能。[@problem_id:1414794]", "problem": "在数论研究中，阶乘在模算术下的行为是一个经典课题。设整数 $N$ 由表达式 $N = 3 \\cdot (35!) + 95$ 定义。你的任务是求出 $N$ 除以素数 $37$ 时的余数。", "solution": "我们要求 $N \\bmod 37$，其中 $N = 3 \\cdot (35!) + 95$ 且 $37$ 是一个素数。根据威尔逊定理 (Wilson's theorem)，对于一个素数 $p$，有 $(p-1)! \\equiv -1 \\pmod{p}$。取 $p=37$ 可得\n$$\n36! \\equiv -1 \\pmod{37}.\n$$\n因为 $36! = 36 \\cdot 35!$ 且 $36 \\equiv -1 \\pmod{37}$，我们有\n$$\n36 \\cdot 35! \\equiv -1 \\pmod{37} \\quad \\Longrightarrow \\quad (-1)\\cdot 35! \\equiv -1 \\pmod{37}.\n$$\n两边同乘以 $-1$ 得到\n$$\n35! \\equiv 1 \\pmod{37}.\n$$\n因此，\n$$\nN \\equiv 3 \\cdot 35! + 95 \\equiv 3 \\cdot 1 + 95 \\equiv 98 \\pmod{37}.\n$$\n将 $98$ 对 $37$ 取模，注意到 $37 \\cdot 2 = 74$，因此 $98 - 74 = 24$，所以\n$$\n98 \\equiv 24 \\pmod{37}.\n$$\n因此 $N$ 除以 $37$ 的余数是 $24$。", "answer": "$$\\boxed{24}$$", "id": "1414794"}, {"introduction": "掌握了基本的计算方法后，让我们来挑战一个更具侦探趣味的“逆向”问题。在本练习中，你不再是计算一个给定表达式的余数，而是需要根据一个关于阶乘的同余关系，反向推导出满足该关系的所有素数。这种练习能够有效锻炼你的代数推演和逻辑推理能力，并让你体会到数论性质如何成为筛选可能解的有力约束条件。[@problem_id:1414837]", "problem": "求所有素数 $p$ 的和，使得整数 $(p-4)! - 6$ 是 $p$ 的倍数。", "solution": "设 $p$ 为一个素数，且 $p \\geq 5$，使得 $(p-4)!$ 有定义。根据威尔逊定理 (Wilson's theorem)，有 $(p-1)! \\equiv -1 \\pmod{p}$。注意到\n$$(p-1)!=(p-1)(p-2)(p-3)(p-4)!.$$\n将这些因子对模 $p$ 进行约化，我们有 $(p-1) \\equiv -1$，$(p-2) \\equiv -2$ 以及 $(p-3) \\equiv -3$，因此\n$$(p-1)! \\equiv (-1)(-2)(-3)(p-4)! \\equiv -6\\,(p-4)! \\pmod{p}.$$\n将此与威尔逊定理中的 $-1$ 等同，可得\n$$-6\\,(p-4)! \\equiv -1 \\pmod{p} \\quad \\Longrightarrow \\quad 6\\,(p-4)! \\equiv 1 \\pmod{p}.$$\n给定的条件是 $p$ 整除 $(p-4)! - 6$，即\n$$(p-4)! \\equiv 6 \\pmod{p}.$$\n将其代入 $6\\,(p-4)! \\equiv 1 \\pmod{p}$ 中，得到\n$$6 \\cdot 6 \\equiv 1 \\pmod{p} \\quad \\Longrightarrow \\quad 36 \\equiv 1 \\pmod{p} \\quad \\Longrightarrow \\quad p \\mid 35.$$\n35 的素因子是 5 和 7。两者都满足初始条件：\n- 当 $p=5$ 时，$(p-4)! - 6 = 1! - 6 = -5$，可被 5 整除。\n- 当 $p=7$ 时，$(p-4)! - 6 = 3! - 6 = 0$，可被 7 整除。\n\n因此，所求素数为 5 和 7，它们的和是 12。", "answer": "$$\\boxed{12}$$", "id": "1414837"}, {"introduction": "理论的优雅与计算的效率之间往往需要一座桥梁，本练习将引导你搭建这样一座桥梁，连接纯粹数论与计算科学。虽然威尔逊定理本身简洁明了，但直接计算 $(n-1)!$ 的成本极其高昂。此题要求你跳出定理的结论，专注于计算过程本身：设计一个高效的算法来计算 $(n-1)! \\pmod n$，并分析其计算复杂度。这不仅是对你编程能力的考验，更是对你将数学理论转化为高效计算实践能力的深度训练。[@problem_id:3031237]", "problem": "设计并论证一个算法，该算法使用整数 $1,2,\\dots,n-1$ 的平衡积树来计算阶乘的余数 $\\big((n-1)!\\big) \\bmod n$。同时，在标准位运算模型下对其位复杂度进行严格分析。该算法必须从第一性原理推导得出，即模运算的定义与定律、整数乘法的结合律以及公认的多精度整数乘法的渐进代价。不得引用任何为特殊类别 $n$ 给出 $\\big((n-1)!\\big) \\bmod n$ 最终值的既有定理；相反，应直接从计算的定义和结构特性推导出算法步骤和复杂度界。\n\n使用的基本原理：\n- 模约减的定义：对于整数 $a$ 和 $n \\ge 1$，$a \\bmod n$ 是唯一的整数 $r \\in \\{0,1,\\dots,n-1\\}$，满足 $a = q n + r$，其中 $q$ 为某个整数。\n- 整数乘法的结合律与交换律：对于整数 $x,y,z$，$ (xy)z = x(yz)$ 且 $xy = yx$。\n- 随机存取机 (RAM) 上的多精度算术的标准位复杂度模型：令 $M(k)$ 表示两个 $k$ 位整数相乘的位复杂度；特别地，使用快速傅里叶变换 (FFT)，$M(k) = O\\!\\big(k \\log k \\log \\log k\\big)$，且对一个 $k$ 位模数进行模约减的代价为 $O\\!\\big(M(k)\\big)$。\n\n算法设计与分析的要求：\n1. 将乘积构造为一棵平衡二叉树：在叶节点层放置 $1,2,\\dots,n-1$；在每个内部节点，将其两个子节点的余数相乘并对 $n$ 取模，即计算 $((a \\cdot b) \\bmod n)$。如果某一层有奇数个节点，则将最后一个节点不做改变地传递到上一层。\n2. 从第一性原理证明正确性：仅使用乘法结合律和模约减的定义，论证为何最终根节点的值等于 $\\big((n-1)!\\big) \\bmod n$。\n3. 当每个内部节点执行一次操作数最多为 $\\lceil \\log_2 n \\rceil$ 位的模乘法时，推导平衡积树算法位复杂度的紧渐进上界。用 $n$ 和 $M(k)$ 表示此界，其中 $k = \\lceil \\log_2 n \\rceil$。此外，与朴素的非平衡顺序算法以及假设的不取模积树（即，将所有模约减推迟到每层计算结束时）进行比较，解释为什么在节点处取模的平衡设计能避免超线性的操作数增长。\n4. 讨论一种基于检测零余数的有原则的提前终止条件：如果任何内部节点的计算结果为 $0 \\bmod n$，解释为什么最终结果必为 $0$，以及这对合数情况下的操作计数有何影响。\n\n编程任务：\n- 实现上述平衡积树算法，以计算 $\\big((n-1)!\\big) \\bmod n$。\n- 使用以下固定的输入测试集：$[1,2,4,5,6,7,8,11,25,97,100]$。\n- 对测试集中的每个 $n$，计算单个整数 $\\big((n-1)!\\big) \\bmod n$。\n- 最终输出格式：你的程序应生成单行输出，包含一个用方括号括起来的、以逗号分隔的结果列表，其顺序与测试集输入的顺序相同。例如，对于假设的结果 $r_1,r_2,\\dots,r_m$，打印 $[r_1,r_2,\\dots,r_m]$。", "solution": "我们根据所列出的基本原理，构建并分析一个用于计算 $\\big((n-1)!\\big) \\bmod n$ 的平衡积树算法。\n\n算法构造：\n- 给定 $n \\ge 1$。考虑叶节点余数列表 $L_0 = [1,2,\\dots,n-1]$。如果 $n=1$，按照惯例，空积的值为 $1$，因此 $\\big((n-1)!\\big) \\bmod n = 1 \\bmod 1 = 0$。\n- 递归地定义层级 $L_0, L_1, L_2, \\dots$。给定一个层级 $L_i$，通过成对扫描 $L_i$ 来构造 $L_{i+1}$：对于 $L_i$ 中的每对连续元素 $a,b$，将 $c = (a \\cdot b) \\bmod n$ 附加到 $L_{i+1}$。如果 $L_i$ 的长度为奇数，则将最后一个未配对的元素不做改变地附加到 $L_{i+1}$。持续此过程，直到某个层级 $L_t$ 的长度为 $1$，并返回其唯一元素 $r$。\n\n正确性证明：\n- 根据乘法结合律，所有叶节点的乘积等于任何括号组合方式下累积的乘积，特别是该二叉树所诱导的组合方式。由于每个内部节点计算 $((a \\cdot b) \\bmod n)$，并且模约减保持余数不变，所以在每个节点向上传播的值都与该节点子树下所有叶节点的乘积模 $n$ 同余。通过归纳法，根节点的值 $r$ 与所有叶节点的乘积模 $n$ 同余，即\n$$\nr \\equiv \\prod_{j=1}^{n-1} j \\pmod n,\n$$\n因此，在规范余数系统 $\\{0,1,\\dots,n-1\\}$ 中，$r = \\big((n-1)!\\big) \\bmod n$。\n\n位复杂度分析：\n- 令 $k = \\lceil \\log_2 n \\rceil$ 为 $n$ 的位长度。因为在每个内部节点我们都执行 $((a \\cdot b) \\bmod n)$，所以操作数总是对 $n$ 取模的；因此它们最多为 $k$ 位。在标准位模型中，一次模乘法（先乘后约减）的代价为 $O\\!\\big(M(k)\\big)$。\n- 一个具有 $|L_0| = n-1$ 个叶节点的完整积树，其内部节点的总数为 $|L_0| - 1 = n-2$（对于 $n \\ge 2$）：每个内部节点合并两个子节点，每次合并使节点数减少一，直到只剩下一个根节点。因此，模乘法的总次数为 $n-2$。对于 $n=1$，没有内部节点，代价为零；对于 $n=2$，只有一个叶节点，代价也为零。\n- 因此，这种在节点处取模的平衡积树的总位复杂度为\n$$\nT(n) = \\Theta\\!\\big((n-2) \\cdot M(k)\\big) = \\Theta\\!\\big(n \\cdot M(\\lceil \\log_2 n \\rceil)\\big).\n$$\n使用快速傅里叶变换 (FFT) 的乘法界 $M(k) = O\\!\\big(k \\log k \\log \\log k\\big)$，我们得到\n$$\nT(n) = O\\!\\Big(n \\cdot \\lceil \\log_2 n \\rceil \\cdot \\log \\lceil \\log_2 n \\rceil \\cdot \\log \\log \\lceil \\log_2 n \\rceil\\Big).\n$$\n- 与朴素的非平衡顺序算法的比较：对于 $j=1,2,\\dots,n-1$，迭代更新 $r \\leftarrow (r \\cdot j) \\bmod n$ 的顺序算法也执行 $n-2$ 次对 $k$ 位操作数的模乘法，因此其渐进位复杂度相同，为 $\\Theta\\!\\big(n \\cdot M(k)\\big)$。平衡树提供了结构上的优势（并行化潜力和可预测的深度），但在单模数情况下，它并不改变模运算的渐进数量。\n- 避免操作数增长：考虑一个假设的积树，它在层内延迟模约减，在约减前乘以原始整数。在高度为 $h$ 的节点，其值是 $2^h$ 个叶整数的乘积，每个整数最多为 $n$，因此位长度可能增长到 $O\\!\\big(2^h \\cdot \\log n\\big)$。在靠近根部的地方，这将产生大小为 $\\Theta\\!\\big(n \\log n\\big)$ 位的操作数，使得每次乘法的代价达到 $M\\!\\big(\\Theta(n \\log n)\\big)$，从而急剧增加总复杂度。在节点处取模的设计将每个操作数保持在 $k$ 位以内，保证了所述的 $\\Theta\\!\\big(n \\cdot M(k)\\big)$ 界。\n\n通过零检测实现提前终止：\n- 在任何内部节点，如果 $c = (a \\cdot b) \\bmod n = 0$，那么 $a \\cdot b \\equiv 0 \\pmod n$，这意味着该节点下的叶节点的乘积可以被 $n$ 整除。由于后续的乘法只是与整数进行左乘，并且模约减保持同余关系，因此根节点的值必须保持为模 $n$ 为 $0$。因此，在任何时候检测到零余数都允许立即终止并得到正确的最终结果。在操作计数方面，对于零余数出现较早的情况（对于许多合数 $n$），执行的模乘法次数少于 $n-2$ 次，尽管最坏情况下的界仍然是 $\\Theta\\!\\big(n \\cdot M(k)\\big)$。\n\n实现细节：\n- 程序如上所述构造层级 $L_i$，在每个内部节点执行 $((a \\cdot b) \\bmod n)$，并在任何节点等于 $0$ 时提前终止。对于 $n=1$，它返回 $0$，对于 $n=2$，它返回 $1$。\n\n测试集与输出：\n- 我们在固定的输入 $[1,2,4,5,6,7,8,11,25,97,100]$ 上评估该算法。\n- 对于每个 $n$，我们输出整数 $\\big((n-1)!\\big) \\bmod n$。\n- 程序以 $[r_1,r_2,\\dots,r_{11}]$ 的格式打印单行，对应于测试集的顺序。\n\n该设计严格遵循模运算和位复杂度模型，通过结合律和余数性质确立了其正确性，在实际的乘法代价 $M(k)$ 下提供了紧的渐进界，并支持在出现零余数情况下的有原则的提前终止。", "answer": "```python\n# Python 3.12 program to compute ((n-1)!) mod n using a balanced product tree,\n# and print results for a fixed test suite in the required single-line format.\n\ndef factorial_mod_via_product_tree(n: int) - int:\n    \"\"\"\n    Compute ((n-1)!) mod n using a balanced product tree.\n    Early-terminate if any internal node becomes 0 mod n.\n    \"\"\"\n    if n = 0:\n        # By convention in this context, treat n = 0 as undefined; return 0 for robustness.\n        return 0\n    if n == 1:\n        # Empty product equals 1; 1 mod 1 = 0.\n        return 0\n    if n == 2:\n        # (1!) mod 2 = 1\n        return 1\n\n    # Initialize leaves: 1..n-1\n    level = list(range(1, n))\n    # Build product tree levels until a single value remains.\n    while True:\n        if len(level) == 1:\n            return level[0] % n\n        next_level = []\n        # Combine pairs with modular multiplication.\n        it = iter(level)\n        for a in it:\n            try:\n                b = next(it)\n                c = (a * b) % n\n                # Early termination if zero residue encountered.\n                if c == 0:\n                    return 0\n                next_level.append(c)\n            except StopIteration:\n                # Odd count: carry last element upward unchanged.\n                next_level.append(a % n)\n        level = next_level\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [1, 2, 4, 5, 6, 7, 8, 11, 25, 97, 100]\n\n    results = []\n    for n in test_cases:\n        result = factorial_mod_via_product_tree(n)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3031237"}]}