{"hands_on_practices": [{"introduction": "这个练习将带你深入探究拉格朗日四平方定理的数之几何证明的核心。这个优雅的证明依赖于一个强大的工具——闵可夫斯基凸体定理（Minkowski's Convex Body Theorem），它将一个几何对象（凸体）的体积与一个算术结构（格）中点的存在性联系起来。通过从第一性原理推导这个临界半径，你将亲身体验几何方法如何“强制”产生一个数论问题的解，从而将抽象的证明转化为可触摸的计算。[@problem_id:3016909]", "problem": "设 $m \\in \\mathbb{N}$，且设 $\\Lambda \\subset \\mathbb{R}^{4}$ 是一个余体积（行列式）为 $\\det(\\Lambda) = d > 0$ 的满秩格。考虑以原点为中心的欧几里得球 $B(R) = \\{ x \\in \\mathbb{R}^{4} : \\|x\\|_{2} \\le R \\}$，它是一个中心对称凸体。在证明拉格朗日四平方和定理的数的几何方法中，人们构造了一个在 $\\mathbb{R}^{4}$ 中的格，其体积与 $m$ 相关，并援引一个体积阈值来保证在一个适当缩放的球体内部存在一个非零格点，最终得到一个将 $m$ 表示为四平方和的表示。\n\n请仅从基本定义（$\\mathbb{R}^{4}$ 中格及其余体积的定义）、关于凸体的公认事实（$\\mathbb{R}^{4}$ 中球的体积）以及闵可夫斯基凸体定理的陈述出发，确定最小半径 $R_{\\min}(d)$（作为 $d$ 的一个闭式解析表达式），使得只要 $R \\ge R_{\\min}(d)$，球 $B(R)$ 就必然包含 $\\Lambda$ 的一个非零点。\n\n你的最终答案必须是 $R_{\\min}(d)$ 的精确解析表达式，不得进行舍入。在你的推理过程中，请解释该阈值如何与证明拉格朗日四平方和定理的数的几何方法中使用的格构造相联系，但除了已声明的基础事实外，不要提供任何简化公式。", "solution": "该问题有效。这是一个基于成熟的数的几何原理的适定数学问题。\n\n问题要求我们求出4维欧几里得球 $B(R)$ 的最小半径 $R_{\\min}(d)$，该半径要能保证对于任何余体积为 $d$ 的给定满秩格 $\\Lambda \\subset \\mathbb{R}^{4}$，球内都包含一个非零点。这个确定需要使用闵可夫斯基凸体定理。\n\n让我们从陈述必要的基础原理开始。\n\n1.  **闵可夫斯基凸体定理 (Minkowski's Convex Body Theorem)**：设 $\\Lambda$ 是 $\\mathbb{R}^{n}$ 中的一个满秩格，其余体积为 $\\det(\\Lambda)$。设 $S$ 是 $\\mathbb{R}^{n}$ 的一个紧、凸、中心对称子集。如果 $S$ 的体积，记为 $\\text{vol}(S)$，满足不等式\n    $$\n    \\text{vol}(S) \\ge 2^n \\det(\\Lambda),\n    $$\n    那么 $S$ 至少包含一个除原点外的格点。\n\n2.  **n维球的体积 (Volume of an n-dimensional Ball)**：半径为 $R$ 的n维欧几里得球的体积由以下公式给出\n    $$\n    V_n(R) = \\frac{\\pi^{n/2}}{\\Gamma(\\frac{n}{2} + 1)} R^n,\n    $$\n    其中 $\\Gamma$ 是伽马函数。\n\n在给定问题的背景下，空间是 $\\mathbb{R}^{4}$，因此 $n=4$。格是 $\\Lambda$，其余体积为 $\\det(\\Lambda) = d$。凸体是以原点为中心的球 $B(R) = \\{ x \\in \\mathbb{R}^{4} : \\|x\\|_{2} \\le R \\}$。这个体是紧的、凸的且中心对称的（$x \\in B(R) \\implies -x \\in B(R)$），因此闵可夫斯基定理适用。\n\n首先，我们计算4维球 $B(R)$ 的体积。使用 $n=4$ 的通用公式：\n$$\n\\text{vol}(B(R)) = V_4(R) = \\frac{\\pi^{4/2}}{\\Gamma(\\frac{4}{2} + 1)} R^4 = \\frac{\\pi^2}{\\Gamma(3)} R^4.\n$$\n对于整数参数 $k > 0$，伽马函数满足 $\\Gamma(k) = (k-1)!$。因此，$\\Gamma(3) = (3-1)! = 2! = 2$。\n因此，4维球的体积是：\n$$\n\\text{vol}(B(R)) = \\frac{\\pi^2}{2} R^4.\n$$\n现在，我们应用闵可夫斯基定理。$B(R)$ 包含 $\\Lambda$ 的一个非零点的条件是：\n$$\n\\text{vol}(B(R)) \\ge 2^4 \\det(\\Lambda).\n$$\n代入体积和余体积 $d$ 的表达式：\n$$\n\\frac{\\pi^2}{2} R^4 \\ge 16d.\n$$\n为了找到满足此条件的半径 $R$，我们对 $R$ 解这个不等式：\n$$\n\\pi^2 R^4 \\ge 32d\n$$\n$$\nR^4 \\ge \\frac{32d}{\\pi^2}\n$$\n$$\nR \\ge \\left(\\frac{32d}{\\pi^2}\\right)^{1/4}.\n$$\n问题要求的是最小半径 $R_{\\min}(d)$，使得对于任何 $R \\ge R_{\\min}(d)$，球 $B(R)$ 都保证包含一个非零格点。根据上述不等式，这个最小半径恰好是 $R$ 有效范围的下界。\n$$\nR_{\\min}(d) = \\left(\\frac{32d}{\\pi^2}\\right)^{1/4}.\n$$\n这个表达式可以写成 $R_{\\min}(d) = \\frac{2(2d)^{1/4}}{\\pi^{1/2}}$。\n\n问题还要求解释这个阈值如何与拉格朗日四平方和定理的证明联系起来。该定理的数的几何证明过程如下：\n\n设 $m \\in \\mathbb{N}$ 是我们希望表示为四平方和的整数。为简单起见（遵循经典证明），我们假设 $m=p$ 是一个奇素数。使用欧拉四平方和恒等式可以将该证明推广到所有整数。\n\n1.  **格的构造**：首先证明存在整数 $a, b$ 使得 $a^2 + b^2 + 1 \\equiv 0 \\pmod p$。然后，构造一个由以下方式定义的特定格 $\\Lambda_p \\subset \\mathbb{Z}^4$\n    $$\n    \\Lambda_p = \\{ (x_1, x_2, x_3, x_4) \\in \\mathbb{Z}^4 \\,|\\, x_1 \\equiv ax_3 + bx_4 \\pmod p, \\, x_2 \\equiv bx_3 - ax_4 \\pmod p \\}.\n    $$\n    这是整数格 $\\mathbb{Z}^4$ 的一个满秩子格。对于 $x_3, x_4 \\pmod p$ 的每一对选择，$x_1, x_2 \\pmod p$ 的值都是唯一确定的。因此，在商群 $\\mathbb{Z}^4 / \\Lambda_p$ 中，有 $p^2$ 个不同的模 $p$ 剩余类。该格的余体积是 $\\Lambda_p$ 在 $\\mathbb{Z}^4$ 中的指数乘以 $\\mathbb{Z}^4$ 的余体积（为1），所以 $\\det(\\Lambda_p) = d = p^2$。\n\n2.  **格点性质**：这个格的一个关键性质是，对于任何点 $x = (x_1, x_2, x_3, x_4) \\in \\Lambda_p$，其欧几里得范数的平方 $\\|x\\|_2^2 = x_1^2+x_2^2+x_3^2+x_4^2$ 是 $p$ 的一个整数倍。这可以通过考虑模 $p$ 的范数来证明：\n    \\begin{align*}\n    \\|x\\|_2^2 &\\equiv (ax_3+bx_4)^2 + (bx_3-ax_4)^2 + x_3^2 + x_4^2 \\pmod p \\\\\n    &\\equiv (a^2x_3^2+2abx_3x_4+b^2x_4^2) + (b^2x_3^2-2abx_3x_4+a^2x_4^2) + x_3^2 + x_4^2 \\pmod p \\\\\n    &\\equiv (a^2+b^2)(x_3^2+x_4^2) + (x_3^2+x_4^2) \\pmod p \\\\\n    &\\equiv (a^2+b^2+1)(x_3^2+x_4^2) \\pmod p.\n    \\end{align*}\n    根据构造，$a^2+b^2+1 \\equiv 0 \\pmod p$，所以 $\\|x\\|_2^2 \\equiv 0 \\pmod p$。\n\n3.  **闵可夫斯基界的应用**：我们现在应用我们导出的最小半径结果。对于格 $\\Lambda_p$，其余体积为 $d = p^2$。闵可夫斯基定理保证只要 $R \\ge R_{\\min}(p^2)$，在球 $B(R)$ 内部就存在一个*非零*点 $x \\in \\Lambda_p$。具体来说，存在一个非零点 $x \\in \\Lambda_p$ 使得 $\\|x\\|_2 \\le R_{\\min}(p^2)$。该点的范数平方必须满足：\n    $$\n    \\|x\\|_2^2 \\le (R_{\\min}(p^2))^2 = \\left( \\left(\\frac{32p^2}{\\pi^2}\\right)^{1/4} \\right)^2 = \\left(\\frac{32p^2}{\\pi^2}\\right)^{1/2} = \\frac{\\sqrt{32}p}{\\pi} = \\frac{4\\sqrt{2}}{\\pi}p.\n    $$\n\n4.  **结论**：我们找到了一个非零整数向量 $x = (x_1, x_2, x_3, x_4)$，它满足两个条件：\n    (a) $\\|x\\|_2^2$ 是 $p$ 的一个正整数倍。\n    (b) $\\|x\\|_2^2 \\le \\frac{4\\sqrt{2}}{\\pi}p$。\n    从数值上看，$\\frac{4\\sqrt{2}}{\\pi} \\approx \\frac{4 \\times 1.4142}{3.1416} \\approx 1.799 < 2$。所以我们有 $0 < \\|x\\|_2^2 < 2p$。\n    严格小于 $2p$ 的 $p$ 的唯一正整数倍是 $p$ 本身。因此，我们必然有：\n    $$\n    \\|x\\|_2^2 = x_1^2 + x_2^2 + x_3^2 + x_4^2 = p.\n    $$\n    这证明了 $p$ 可以写成四个整数的平方和，这正是该定理的精髓。因此，阈值 $R_{\\min}(d)$ 是提供范数上界、使我们能够将其值“锁定”为恰好是 $p$ 的关键部分。", "answer": "$$\n\\boxed{\\left(\\frac{32d}{\\pi^2}\\right)^{1/4}}\n$$", "id": "3016909"}, {"introduction": "在证明了每个自然数都可以表示为四个平方数之和后，一个自然而然的问题随之而来：我们如何具体地找到这个表示？这个练习将引导你从“存在性”证明的抽象世界走向“构造性”算法的具体实践。通过将一个四维的搜索问题巧妙地简化为二维问题，你将把一个数论思想转化为一个高效且正确的计算机程序，这是现代数论研究中一项至关重要的技能。[@problem_id:3016910]", "problem": "设计并实现一个完整的、可运行的程序。该程序需针对一个固定测试套件中的每个整数输入，从基本原理出发，为其构造一个表示为四平方和的典范形式。程序不得依赖外部输入，必须直接计算并输出这些表示。目标概念植根于数论，应从整数平方的基本定义和经过充分检验的事实出发，采用算法方式进行处理。\n\n从以下基础出发：\n- 整数集 $\\mathbb{Z}$ 及其标准加法和乘法，以及对于任意整数 $k$ 其平方 $k^2$ 定义为 $k \\cdot k$。\n- 模算术的基本性质，特别是平方数模 $8$ 的余数，即任何平方数模 $8$ 同余于 $0$、$1$ 或 $4$。\n- 整数格 $\\mathbb{Z}^d$ 的结构以及 $\\mathbb{Z}^d$ 上的欧几里得范数，其对于向量 $(x_1,\\dots,x_d)$ 定义为 $\\| (x_1,\\dots,x_d) \\|^2 = \\sum_{i=1}^{d} x_i^2$，该值恒为整数。\n\n你的目标是，为测试套件中的每个整数 $n$，构造一个非负整数的非递减有序四元组 $(a,b,c,d)$，使得\n$$\na^2 + b^2 + c^2 + d^2 = n.\n$$\n算法设计必须遵循有原则的方法：推导出一个方法，将问题简化为对某个适当界限内所有两平方和之集合的操作，并证明为何组合两个这样的和足以对测试套件中的所有输入生成四平方和表示。你必须通过确定性地选择和排序四元组来确保构造是典范的，从而保证可复现性。\n\n你的程序必须实现并运用以下思想，不得采用未经证明的捷径：\n- 定义集合 $\\mathcal{S}_N = \\{ x^2 + y^2 \\mid x,y \\in \\mathbb{Z}_{\\ge 0}, \\, x^2 + y^2 \\le N \\}$，其中 $N$ 是一个根据最大测试用例导出的合适界限。\n- 证明任何表示 $n = a^2 + b^2 + c^2 + d^2$ 都可以分组为 $(a^2 + b^2) + (c^2 + d^2)$，因此对应于一个分解 $n = s + t$，其中 $s,t \\in \\mathcal{S}_N$。\n- 设计一个在 $\\mathcal{S}_N$ 上的确定性搜索策略，以找到这样的分解 $n = s + t$，并获取相应的 $(a,b,c,d)$。\n\n测试套件：\n- 测试用例为整数 $n \\in \\{\\,0,\\,1,\\,7,\\,15,\\,23,\\,310,\\,999,\\,1024,\\,12345,\\,65535\\,\\}$。\n- 此套件包括边界值（如 $n = 0$）、完全平方数（如 $n = 1024$）、形如 $4^a(8b+7)$ 的整数（如 $n = 7$ 和 $n = 65535$，它们不能表示为三平方和），以及异构的合数和素数值。\n\n答案规格：\n- 对于测试套件中的每个 $n$，生成一个非负整数列表 $[a,b,c,d]$，满足 $a \\le b \\le c \\le d$ 且 $a^2 + b^2 + c^2 + d^2 = n$。\n- 最终输出必须是单行文本，其中包含按测试套件顺序聚合的结果，形式为一个由方括号括起来的逗号分隔列表，每个条目本身是一个包含四个整数的列表。例如，输出格式必须是\n$$\n[\\,[a_1,b_1,c_1,d_1],\\,[a_2,b_2,c_2,d_2],\\,\\dots\\,]\n$$\n其中每个 $[a_i,b_i,c_i,d_i]$ 对应第 $i$ 个测试用例的表示。\n\n无需物理单位、角度单位或百分比格式；所有输出均为编码了四平方和表示的整数列表。", "solution": "我们描述并证明一个基于整数平方和格范数的基本原理，为整数构造四平方和表示的显式算法。然后，我们将其优化为一个适用于给定测试套件的确定性、高效的程序。\n\n基础设定。对于任意整数 $n \\ge 0$，整数格 $\\mathbb{Z}^4$ 包含向量 $(a,b,c,d)$，其欧几里得范数的平方为\n$$\n\\| (a,b,c,d) \\|^2 = a^2 + b^2 + c^2 + d^2.\n$$\n我们寻求非负整数 $(a,b,c,d)$ 使得 $\\| (a,b,c,d) \\|^2 = n$。一个直接的观察是，任何这样的四元组都可引出一个分解\n$$\nn = (a^2 + b^2) + (c^2 + d^2),\n$$\n即，从两平方和的集合中取出两个元素的和。这启发我们将搜索空间从 $\\mathbb{Z}_{\\ge 0}^4$ 简化为 $\\mathbb{Z}_{\\ge 0}^2$ 的组合。\n\n为界限 $N \\in \\mathbb{Z}_{\\ge 0}$ 定义，\n$$\n\\mathcal{S}_N = \\{ x^2 + y^2 \\mid x,y \\in \\mathbb{Z}_{\\ge 0}, \\, x^2 + y^2 \\le N \\}.\n$$\n关键原理在于，若 $n \\le N$ 且存在 $(a,b,c,d)$ 满足 $a^2 + b^2 + c^2 + d^2 = n$，则 $a^2 + b^2 \\in \\mathcal{S}_N$ 且 $c^2 + d^2 \\in \\mathcal{S}_N$，因此 $n$ 可分解为和 $s + t$，其中 $s,t \\in \\mathcal{S}_N$。反之，任何这样的分解 $n = s + t$（其中 $s = x^2 + y^2, t = u^2 + v^2$）可立即得到一个四平方和表示\n$$\nn = x^2 + y^2 + u^2 + v^2.\n$$\n因此，四平方和表示的存在性意味着在有界集 $\\mathcal{S}_N$ 内存在一个分解为两个两平方和的形式。此简化纯粹是组合性的，仅使用了平方和格范数的定义。\n\n确定性构造。为了构造一个典范表示，我们对一个固定的上界 $N$（选为测试套件中的最大整数）按以下步骤进行：\n- 枚举所有对 $(x,y)$，其中 $x,y \\in \\{0,1,2,\\dots,\\lfloor \\sqrt{N} \\rfloor\\}$，计算 $s = x^2 + y^2$，并为每个 $s \\le N$ 记录一个实现该 $s$ 值的典范对 $(x,y)$。这将构建一个代表 $\\mathcal{S}_N$ 的字典：\n$$\nD[s] = (x,y), \\quad s \\in \\mathcal{S}_N.\n$$\n当多个数对产生相同的 $s$ 时，我们保留首次遇到的数对以强制确定性。\n\n- 对于给定的 $n \\le N$，按 $s$ 的升序对集合 $\\mathcal{S}_N$ 进行确定性扫描。对于每个 $s \\in \\mathcal{S}_N$ 且 $s \\le n$，检查 $t = n - s$ 是否也位于 $\\mathcal{S}_N$ 中；即检查 $t \\in D$。如果找到这样的 $s$ 和 $t$，则有 $n = s + t$，其中 $s = x^2 + y^2$ 且 $t = u^2 + v^2$，对应 $(x,y) = D[s]$ 和 $(u,v) = D[t]$。于是\n$$\nn = x^2 + y^2 + u^2 + v^2,\n$$\n且四元组 $(x,y,u,v)$ 构成一个有效的表示。我们通过排序将其典范化，得到满足 $a \\le b \\le c \\le d$ 的 $(a,b,c,d)$，从而保证了确定性输出。\n\n正确性证明。枚举过程为非负数对 $(x,y)$ 完全构建了 $\\mathcal{S}_N$，其上界由 $N$ 决定，因为任何满足 $x \\le \\lfloor \\sqrt{N} \\rfloor$ 的平方 $x^2$ 都被包含在内。对于给定套件中的每个测试用例 $n$，四平方和定理保证了存在 $(a,b,c,d)$ 使得 $a^2 + b^2 + c^2 + d^2 = n$。那么 $s_1 = a^2 + b^2 \\in \\mathcal{S}_N$ 且 $s_2 = c^2 + d^2 \\in \\mathcal{S}_N$，并有 $s_1 + s_2 = n$。由于我们按升序迭代 $s$，我们最终必然会遇到 $s_1$ 或 $s_2$ 中的一个，而此时 $n - s$ 就是另一个；两者都存在于 $D$ 中，因为它们都是不大于 $N$ 的两平方和。因此，搜索总能定位到一个有效的分解，且相应的四元组存在并被显式地构造出来。\n\n边界与边缘情况：\n- 对于 $n = 0$，我们有表示 $(0,0,0,0)$。\n- 对于像 $n = 1024 = 32^2$ 这样的完全平方数，算法将发现诸如 $1024 = 1024 + 0 = 32^2 + 0^2 + 0^2 + 0^2$ 的分解。\n- 对于形如 $4^a(8b+7)$ 的整数，如 $7$ 和 $65535$，它们不能表示为三平方和，但通过两个两平方和的构造方法仍然有效，并能找到一个四平方和的表示，这与平方数模 8 的模限制是一致的。\n\n复杂度考量。构建 $D$ 需要迭代 $x,y$ 直到 $\\lfloor \\sqrt{N} \\rfloor$，其复杂度为 $O\\!\\left( \\left\\lfloor \\sqrt{N} \\right\\rfloor^2 \\right)$。对每个 $n$ 的搜索会扫描至多为 $n$ 的 $|\\mathcal{S}_N|$ 个值，每次对候选 $s$ 执行 $O(1)$ 的字典查找。对于所提供的测试套件，其中 $N$ 的大小适中，这可以在运行时环境的约束内实现高效执行。\n\n输出格式。对于按给定顺序的每个测试用例 $n$，程序输出一个非负整数列表 $[a,b,c,d]$，满足 $a^2 + b^2 + c^2 + d^2 = n$ 且 $a \\le b \\le c \\le d$。最终打印的行是一个单独的字符串，编码了按顺序排列的这些列表的列表，即\n$$\n[\\,[a_1,b_1,c_1,d_1],\\,[a_2,b_2,c_2,d_2],\\,\\dots\\,],\n$$\n其中每个 $[a_i,b_i,c_i,d_i]$ 对应于测试套件中的第 $i$ 个测试用例。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\n\ndef build_sum_of_two_squares_map(N: int):\n    \"\"\"\n    Build a dictionary mapping s = x^2 + y^2 (s <= N) to one canonical pair (x, y),\n    with x, y >= 0 and x, y <= floor(sqrt(N)).\n    Determinism is ensured by scanning x and y in ascending order and storing\n    the first occurrence for each sum s.\n    \"\"\"\n    max_root = int(N**0.5)\n    sum_map = {}\n    for x in range(max_root + 1):\n        x2 = x * x\n        for y in range(max_root + 1):\n            s = x2 + y * y\n            if s > N:\n                # Since y increases, further y will only increase s; break inner loop.\n                break\n            # Store only the first encountered pair for determinism.\n            if s not in sum_map:\n                sum_map[s] = (x, y)\n    # For deterministic iteration order later, also keep a sorted list of keys.\n    keys_sorted = sorted(sum_map.keys())\n    return sum_map, keys_sorted\n\ndef four_squares_via_two_sums(n: int, sum_map: dict, keys_sorted: list):\n    \"\"\"\n    Given n and a precomputed sum-of-two-squares map up to max N,\n    find a decomposition n = s + t with s, t in sum_map.\n    Return the canonical sorted quadruple [a, b, c, d] with a^2 + b^2 + c^2 + d^2 = n.\n    \"\"\"\n    if n == 0:\n        return [0, 0, 0, 0]\n    # Iterate sums s in ascending order up to n\n    for s in keys_sorted:\n        if s > n:\n            break\n        t = n - s\n        if t in sum_map:\n            x, y = sum_map[s]\n            u, v = sum_map[t]\n            quadruple = sorted([x, y, u, v])\n            # Verify correctness (defensive check in case of logic errors)\n            if quadruple[0]**2 + quadruple[1]**2 + quadruple[2]**2 + quadruple[3]**2 == n:\n                return quadruple\n    # In theory, for all n this should not happen due to Lagrange's theorem.\n    # As a fallback (should never trigger for the provided test suite),\n    # perform a direct nested search.\n    max_root = int(n**0.5)\n    for a in range(max_root + 1):\n        a2 = a * a\n        for b in range(max_root + 1):\n            b2 = b * b\n            for c in range(max_root + 1):\n                c2 = c * c\n                d2 = n - (a2 + b2 + c2)\n                if d2 < 0:\n                    break\n                d = int(d2**0.5)\n                if d * d == d2:\n                    quadruple = sorted([a, b, c, d])\n                    return quadruple\n    # If no representation found (should not occur), return a sentinel.\n    return [0, 0, 0, 0]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [0, 1, 7, 15, 23, 310, 999, 1024, 12345, 65535]\n    max_n = max(test_cases)\n\n    # Precompute the map of sums of two squares up to max_n.\n    sum_map, keys_sorted = build_sum_of_two_squares_map(max_n)\n\n    results = []\n    for n in test_cases:\n        quad = four_squares_via_two_sums(n, sum_map, keys_sorted)\n        results.append(quad)\n\n    # Final print statement in the exact required format.\n    # Single line: list of lists with comma-separated integers.\n    print(\"[\" + \",\".join(\"[\" + \",\".join(map(str, quad)) + \"]\" for quad in results) + \"]\")\n\nsolve()\n```", "id": "3016910"}]}