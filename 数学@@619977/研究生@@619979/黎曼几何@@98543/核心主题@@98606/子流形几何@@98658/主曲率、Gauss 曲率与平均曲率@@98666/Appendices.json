{"hands_on_practices": [{"introduction": "环面是微分几何中一个经典且重要的研究对象，因为它在足够小的局部区域内类似于欧几里得空间，但其整体拓扑结构却更为复杂。本练习将引导你手动计算环面的第一和第二基本形式，这是确定其主曲率、高斯曲率和平均曲率的基础。通过这个实践，你将掌握从参数化方程出发，运用微分和矢量运算来揭示曲面内在几何性质的核心技能。", "problem": "设 $R>0$ 和 $r>0$ 为实数且 $R>r$，考虑三维欧几里得空间 $\\mathbb{R}^{3}$ 中的一个光滑曲面，该曲面由 $xy$ 平面内一个以 $(R,0,0)$ 为中心、半径为 $r$ 的圆绕 $z$ 轴旋转而成。这个标准环面的一个光滑参数化由下式给出\n$$\nX(\\theta,\\phi)=\\big((R+r\\cos\\phi)\\cos\\theta,\\,(R+r\\cos\\phi)\\sin\\theta,\\,r\\sin\\phi\\big),\n$$\n其中 $\\theta\\in[0,2\\pi)$ 和 $\\phi\\in[0,2\\pi)$ 是以弧度为单位的角度参数。仅使用 $\\mathbb{R}^{3}$ 中的欧几里得内积和叉积，并通过切向量 $X_{\\theta}$ 和 $X_{\\phi}$ 以及由 $X_{\\theta}\\times X_{\\phi}$ 所得到的单位法向量 $N$ 的选择，根据第一和第二基本形式的定义，计算此参数化下第一基本形式的系数 $(E,F,G)$ 和第二基本形式的系数 $(e,f,g)$。\n\n请将您的最终答案表示为一个单行矩阵，其中按顺序包含六个量 $(E,F,G,e,f,g)$，并以 $R$、$r$、$\\theta$ 和 $\\phi$ 的封闭形式符号表达式写出。", "solution": "用户希望计算标准环面的第一和第二基本形式的系数。\n\n### 1. 问题验证\n\n**第 1 步：提取已知条件**\n- 两个实数 $R>0$ 和 $r>0$，约束条件为 $R>r$。\n- 三维欧几里得空间 $\\mathbb{R}^{3}$ 中的一个光滑曲面，即一个标准环面。\n- 环面的一个光滑参数化：$X(\\theta,\\phi)=\\big((R+r\\cos\\phi)\\cos\\theta,\\,(R+r\\cos\\phi)\\sin\\theta,\\,r\\sin\\phi\\big)$。\n- 角度参数的定义域：$\\theta\\in[0,2\\pi)$ 和 $\\phi\\in[0,2\\pi)$。\n- 任务是计算第一基本形式的系数 $(E,F,G)$ 和第二基本形式的系数 $(e,f,g)$。\n- 允许使用的工具是 $\\mathbb{R}^{3}$ 中的欧几里得内积和叉积。\n- 基本形式的定义需基于切向量 $X_{\\theta}$ 和 $X_{\\phi}$，以及由 $X_{\\theta}\\times X_{\\phi}$ 导出的单位法向量 $N$。\n- 最终答案应为一个包含六个量 $(E,F,G,e,f,g)$ 的单行矩阵。\n\n**第 2 步：使用提取的已知条件进行验证**\n- **科学依据：** 该问题是曲面微分几何中的一个标准、基础的计算。其参数化、定义和概念在数学中均已完善建立。该问题在科学上是有效的。\n- **适定性：** 问题陈述清晰，并提供了计算所需量的所有必要信息。系数存在唯一解。\n- **客观性：** 问题以精确、客观的数学语言陈述。\n- **缺陷分析：**\n    1.  **科学/事实不健全：** 无。\n    2.  **无法形式化/不相关：** 该问题可直接形式化，并且是曲面曲率主题的核心。\n    3.  **设置不完整/矛盾：** 无。条件 $R > r$ 确保环面不会自相交。\n    4.  **不切实际/不可行：** 无。该对象是一个标准的数学构造。\n    5.  **不适定/结构不良：** 无。计算过程直接明了。\n    6.  **伪深刻/琐碎：** 无。该计算内容充实，是该领域的典型示例。\n    7.  **超出科学可验证范围：** 无。结果可通过直接计算进行验证。\n\n**第 3 步：结论与行动**\n- 问题是**有效的**。现在开始求解过程。\n\n### 2. 解答\n\n给定的环面参数化为\n$$\nX(\\theta,\\phi) = \\big((R+r\\cos\\phi)\\cos\\theta, (R+r\\cos\\phi)\\sin\\theta, r\\sin\\phi\\big)\n$$\n其中 $R>r>0$。\n\n为求第一基本形式的系数，我们首先计算切向量 $X_{\\theta} = \\frac{\\partial X}{\\partial \\theta}$ 和 $X_{\\phi} = \\frac{\\partial X}{\\partial \\phi}$。\n$$\nX_{\\theta} = \\big(-(R+r\\cos\\phi)\\sin\\theta, (R+r\\cos\\phi)\\cos\\theta, 0\\big)\n$$\n$$\nX_{\\phi} = \\big(-r\\sin\\phi\\cos\\theta, -r\\sin\\phi\\sin\\theta, r\\cos\\phi\\big)\n$$\n第一基本形式的系数 $E$、$F$ 和 $G$ 由这些切向量的内积定义。\n$$\nE = X_{\\theta} \\cdot X_{\\theta} = \\big(-(R+r\\cos\\phi)\\sin\\theta\\big)^{2} + \\big((R+r\\cos\\phi)\\cos\\theta\\big)^{2} + 0^{2}\n$$\n$$\nE = (R+r\\cos\\phi)^{2}\\sin^{2}\\theta + (R+r\\cos\\phi)^{2}\\cos^{2}\\theta = (R+r\\cos\\phi)^{2}(\\sin^{2}\\theta + \\cos^{2}\\theta) = (R+r\\cos\\phi)^{2}\n$$\n$$\nF = X_{\\theta} \\cdot X_{\\phi} = \\big(-(R+r\\cos\\phi)\\sin\\theta\\big)(-r\\sin\\phi\\cos\\theta) + \\big((R+r\\cos\\phi)\\cos\\theta\\big)(-r\\sin\\phi\\sin\\theta) + (0)(r\\cos\\phi)\n$$\n$$\nF = r(R+r\\cos\\phi)\\sin\\phi\\sin\\theta\\cos\\theta - r(R+r\\cos\\phi)\\sin\\phi\\sin\\theta\\cos\\theta = 0\n$$\n$$\nG = X_{\\phi} \\cdot X_{\\phi} = (-r\\sin\\phi\\cos\\theta)^{2} + (-r\\sin\\phi\\sin\\theta)^{2} + (r\\cos\\phi)^{2}\n$$\n$$\nG = r^{2}\\sin^{2}\\phi\\cos^{2}\\theta + r^{2}\\sin^{2}\\phi\\sin^{2}\\theta + r^{2}\\cos^{2}\\phi = r^{2}\\sin^{2}\\phi(\\cos^{2}\\theta + \\sin^{2}\\theta) + r^{2}\\cos^{2}\\phi = r^{2}(\\sin^{2}\\phi + \\cos^{2}\\phi) = r^{2}\n$$\n因此，第一基本形式的系数为 $E=(R+r\\cos\\phi)^{2}$，$F=0$ 和 $G=r^{2}$。\n\n接下来，我们计算第二基本形式的系数 $e$、$f$ 和 $g$。这需要单位法向量 $N$ 和 $X$ 的二阶偏导数。我们首先求法向量 $X_{\\theta} \\times X_{\\phi}$。\n$$\nX_{\\theta} \\times X_{\\phi} = \\begin{vmatrix} \\mathbf{i} & \\mathbf{j} & \\mathbf{k} \\\\ -(R+r\\cos\\phi)\\sin\\theta & (R+r\\cos\\phi)\\cos\\theta & 0 \\\\ -r\\sin\\phi\\cos\\theta & -r\\sin\\phi\\sin\\theta & r\\cos\\phi \\end{vmatrix}\n$$\n叉积的分量为：\n$i$-分量: $(R+r\\cos\\phi)\\cos\\theta (r\\cos\\phi) - 0 = r(R+r\\cos\\phi)\\cos\\theta\\cos\\phi$\n$j$-分量: $0 - (-(R+r\\cos\\phi)\\sin\\theta)(r\\cos\\phi) = r(R+r\\cos\\phi)\\sin\\theta\\cos\\phi$\n$k$-分量: $(-(R+r\\cos\\phi)\\sin\\theta)(-r\\sin\\phi\\sin\\theta) - ((R+r\\cos\\phi)\\cos\\theta)(-r\\sin\\phi\\cos\\theta)$\n$= r(R+r\\cos\\phi)\\sin\\phi(\\sin^{2}\\theta + \\cos^{2}\\theta) = r(R+r\\cos\\phi)\\sin\\phi$\n因此，$X_{\\theta} \\times X_{\\phi} = r(R+r\\cos\\phi) \\big(\\cos\\theta\\cos\\phi, \\sin\\theta\\cos\\phi, \\sin\\phi\\big)$。\n\n该向量的模为：\n$$\n\\|X_{\\theta} \\times X_{\\phi}\\| = |r(R+r\\cos\\phi)| \\sqrt{(\\cos\\theta\\cos\\phi)^{2} + (\\sin\\theta\\cos\\phi)^{2} + (\\sin\\phi)^{2}}\n$$\n由于 $R>r>0$，我们有 $R+r\\cos\\phi > 0$，所以 $|r(R+r\\cos\\phi)|=r(R+r\\cos\\phi)$。\n平方根下的项可简化为 $\\sqrt{\\cos^{2}\\phi(\\cos^{2}\\theta+\\sin^{2}\\theta) + \\sin^{2}\\phi} = \\sqrt{\\cos^{2}\\phi+\\sin^{2}\\phi} = 1$。\n因此，$\\|X_{\\theta} \\times X_{\\phi}\\| = r(R+r\\cos\\phi)$。\n\n单位法向量 $N$ 为：\n$$\nN = \\frac{X_{\\theta} \\times X_{\\phi}}{\\|X_{\\theta} \\times X_{\\phi}\\|} = \\frac{r(R+r\\cos\\phi)\\big(\\cos\\theta\\cos\\phi, \\sin\\theta\\cos\\phi, \\sin\\phi\\big)}{r(R+r\\cos\\phi)} = \\big(\\cos\\theta\\cos\\phi, \\sin\\theta\\cos\\phi, \\sin\\phi\\big)\n$$\n该法向量指向环面所围体积的外部。\n\n现在我们计算 $X$ 的二阶偏导数。\n$$\nX_{\\theta\\theta} = \\frac{\\partial X_{\\theta}}{\\partial\\theta} = \\big(-(R+r\\cos\\phi)\\cos\\theta, -(R+r\\cos\\phi)\\sin\\theta, 0\\big)\n$$\n$$\nX_{\\theta\\phi} = \\frac{\\partial X_{\\theta}}{\\partial\\phi} = \\big(r\\sin\\phi\\sin\\theta, -r\\sin\\phi\\cos\\theta, 0\\big)\n$$\n$$\nX_{\\phi\\phi} = \\frac{\\partial X_{\\phi}}{\\partial\\phi} = \\big(-r\\cos\\phi\\cos\\theta, -r\\cos\\phi\\sin\\theta, -r\\sin\\phi\\big)\n$$\n第二基本形式的系数为 $e=N\\cdot X_{\\theta\\theta}$，$f=N\\cdot X_{\\theta\\phi}$ 和 $g=N\\cdot X_{\\phi\\phi}$。\n$$\ne = N \\cdot X_{\\theta\\theta} = (\\cos\\theta\\cos\\phi)\\big(-(R+r\\cos\\phi)\\cos\\theta\\big) + (\\sin\\theta\\cos\\phi)\\big(-(R+r\\cos\\phi)\\sin\\theta\\big) + (\\sin\\phi)(0)\n$$\n$$\ne = -(R+r\\cos\\phi)\\cos\\phi(\\cos^{2}\\theta+\\sin^{2}\\theta) = -(R+r\\cos\\phi)\\cos\\phi\n$$\n$$\nf = N \\cdot X_{\\theta\\phi} = (\\cos\\theta\\cos\\phi)(r\\sin\\phi\\sin\\theta) + (\\sin\\theta\\cos\\phi)(-r\\sin\\phi\\cos\\theta) + (\\sin\\phi)(0)\n$$\n$$\nf = r\\sin\\phi\\cos\\phi\\sin\\theta\\cos\\theta - r\\sin\\phi\\cos\\phi\\sin\\theta\\cos\\theta = 0\n$$\n$$\ng = N \\cdot X_{\\phi\\phi} = (\\cos\\theta\\cos\\phi)(-r\\cos\\phi\\cos\\theta) + (\\sin\\theta\\cos\\phi)(-r\\cos\\phi\\sin\\theta) + (\\sin\\phi)(-r\\sin\\phi)\n$$\n$$\ng = -r\\cos^{2}\\phi(\\cos^{2}\\theta+\\sin^{2}\\theta) - r\\sin^{2}\\phi = -r\\cos^{2}\\phi - r\\sin^{2}\\phi = -r(\\cos^{2}\\phi + \\sin^{2}\\phi) = -r\n$$\n因此，第二基本形式的系数为 $e = -(R+r\\cos\\phi)\\cos\\phi$，$f=0$ 和 $g=-r$。\n\n综合所有结果，我们得到：\n$E = (R+r\\cos\\phi)^{2}$\n$F = 0$\n$G = r^{2}$\n$e = -(R+r\\cos\\phi)\\cos\\phi$\n$f = 0$\n$g = -r$", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n(R+r\\cos\\phi)^{2} & 0 & r^{2} & -(R+r\\cos\\phi)\\cos\\phi & 0 & -r\n\\end{pmatrix}\n}\n$$", "id": "2986687"}, {"introduction": "理论研究中的曲面通常是光滑的，但在物理世界和工程应用中，我们经常会遇到带有尖点或边界的曲面。圆锥体便是一个典型的例子，其顶点是一个奇点，传统的曲率公式在此处失效。这个练习不仅要求你计算圆锥在光滑部分的曲率，更重要的是引导你思考如何在奇点处理解和量化曲率，这需要你运用“角亏”等更广义的几何概念，从而深化对曲率物理意义的理解。", "problem": "设 $S \\subset \\mathbb{R}^{3}$ 是一个半角为 $\\,\\alpha \\in (0,\\frac{\\pi}{2})\\,$ 的正圆锥，其顶点在原点，轴沿 $z$ 轴正方向。考虑 $S$ 在远离顶点处的平滑参数化，由下式给出\n$$\nX(\\rho,\\theta)=\\big(\\rho \\sin\\alpha \\cos\\theta,\\ \\rho \\sin\\alpha \\sin\\theta,\\ \\rho \\cos\\alpha\\big),\n$$\n其中参数 $\\rho \\in (0,\\infty)$ 和 $\\theta \\in (0,2\\pi)$，并采用 $z$ 分量为正的单位法向量。仅使用第一和第二基本形式、形状算子和主曲率的基本定义，推导在 $\\rho>0$ 的任意点处的主曲率，并由此计算该点的平均曲率 $H$ 和高斯曲率 $K$。\n\n然后，解释为什么这些公式在顶点处失效，并使用严谨的几何或拓扑原理，描述在其他地方平滑曲率为零的情况下，曲率如何在顶点处体现。\n\n所有角度均以弧度为单位。将最终答案表示为一个单行矩阵，其中包含 $H(\\rho)$ 和 $K(\\rho)$ 关于 $\\rho$ 和 $\\alpha$ 的闭式函数，顺序为 $[H(\\rho)\\ \\ K(\\rho)]$。不需要单位，也无需四舍五入。", "solution": "该问题是有效的，因为它是微分几何领域内一个适定且有科学依据的问题。它提供了推导圆锥曲率所需的所有必要信息和定义，而圆锥是曲面理论中的一个经典例子。\n\n解答过程分为三个部分。首先，我们通过计算第一和第二基本形式以及形状算子，来计算圆锥上 $\\rho > 0$ 的点的主曲率。其次，我们解释为什么这些结果在顶点（$\\rho=0$）处无效。第三，我们用一个几何论证来描述顶点处曲率的性质。\n\n**第一部分：$\\rho > 0$ 时的曲率**\n\n曲面 $S$ 由参数化 $X(\\rho,\\theta)=\\big(\\rho \\sin\\alpha \\cos\\theta,\\ \\rho \\sin\\alpha \\sin\\theta,\\ \\rho \\cos\\alpha\\big)$ 给出。\n\n首先，我们通过对参数 $\\rho$ 和 $\\theta$ 求偏导数来计算切向量：\n$$\nX_{\\rho} = \\frac{\\partial X}{\\partial \\rho} = \\big(\\sin\\alpha \\cos\\theta, \\sin\\alpha \\sin\\theta, \\cos\\alpha\\big)\n$$\n$$\nX_{\\theta} = \\frac{\\partial X}{\\partial \\theta} = \\big(-\\rho \\sin\\alpha \\sin\\theta, \\rho \\sin\\alpha \\cos\\theta, 0\\big)\n$$\n\n第一基本形式的系数 $E$、$F$ 和 $G$ 是这些切向量的内积：\n$E = X_{\\rho} \\cdot X_{\\rho} = (\\sin\\alpha \\cos\\theta)^2 + (\\sin\\alpha \\sin\\theta)^2 + (\\cos\\alpha)^2 = \\sin^2\\alpha(\\cos^2\\theta + \\sin^2\\theta) + \\cos^2\\alpha = \\sin^2\\alpha + \\cos^2\\alpha = 1$.\n$F = X_{\\rho} \\cdot X_{\\theta} = (\\sin\\alpha \\cos\\theta)(-\\rho \\sin\\alpha \\sin\\theta) + (\\sin\\alpha \\sin\\theta)(\\rho \\sin\\alpha \\cos\\theta) + (\\cos\\alpha)(0) = 0$.\n$G = X_{\\theta} \\cdot X_{\\theta} = (-\\rho \\sin\\alpha \\sin\\theta)^2 + (\\rho \\sin\\alpha \\cos\\theta)^2 + 0^2 = \\rho^2 \\sin^2\\alpha(\\sin^2\\theta + \\cos^2\\theta) = \\rho^2 \\sin^2\\alpha$.\n因此，第一基本形式的矩阵（度量张量）为：\n$$\ng_{ij} = \\begin{pmatrix} E & F \\\\ F & G \\end{pmatrix} = \\begin{pmatrix} 1 & 0 \\\\ 0 & \\rho^2 \\sin^2\\alpha \\end{pmatrix}\n$$\n由于 $F=0$，坐标系 $(\\rho, \\theta)$ 是正交的。\n\n接下来，我们求单位法向量 $n$。我们从叉积 $X_{\\rho} \\times X_{\\theta}$ 开始：\n$$\nX_{\\rho} \\times X_{\\theta} = \\det \\begin{pmatrix} \\mathbf{i} & \\mathbf{j} & \\mathbf{k} \\\\ \\sin\\alpha \\cos\\theta & \\sin\\alpha \\sin\\theta & \\cos\\alpha \\\\ -\\rho \\sin\\alpha \\sin\\theta & \\rho \\sin\\alpha \\cos\\theta & 0 \\end{pmatrix} = \\big(-\\rho\\sin\\alpha\\cos\\alpha\\cos\\theta, -\\rho\\sin\\alpha\\cos\\alpha\\sin\\theta, \\rho\\sin^2\\alpha\\big)\n$$\n该向量的模为：\n$$\n|X_{\\rho} \\times X_{\\theta}| = \\sqrt{\\rho^2\\sin^2\\alpha\\cos^2\\alpha(\\cos^2\\theta+\\sin^2\\theta) + \\rho^2\\sin^4\\alpha} = \\sqrt{\\rho^2\\sin^2\\alpha(\\cos^2\\alpha + \\sin^2\\alpha)} = \\rho\\sin\\alpha\n$$\n因为 $\\rho > 0$ 且 $\\alpha \\in (0, \\pi/2)$。单位法向量 $n$ 是通过将叉积除以其模得到的：\n$$\nn = \\frac{X_{\\rho} \\times X_{\\theta}}{|X_{\\rho} \\times X_{\\theta}|} = \\frac{1}{\\rho\\sin\\alpha} \\big(-\\rho\\sin\\alpha\\cos\\alpha\\cos\\theta, -\\rho\\sin\\alpha\\cos\\alpha\\sin\\theta, \\rho\\sin^2\\alpha\\big) = \\big(-\\cos\\alpha\\cos\\theta, -\\cos\\alpha\\sin\\theta, \\sin\\alpha\\big)\n$$\n此法向量的 $z$ 分量是 $\\sin\\alpha$，对于 $\\alpha \\in (0, \\pi/2)$ 为正，符合题目要求。\n\n现在，我们计算第二基本形式的系数 $L$、$M$ 和 $N$。这需要 $X$ 的二阶偏导数：\n$$\nX_{\\rho\\rho} = (0, 0, 0)\n$$\n$$\nX_{\\rho\\theta} = (-\\sin\\alpha \\sin\\theta, \\sin\\alpha \\cos\\theta, 0)\n$$\n$$\nX_{\\theta\\theta} = (-\\rho \\sin\\alpha \\cos\\theta, -\\rho \\sin\\alpha \\sin\\theta, 0)\n$$\n系数是这些向量与单位法向量 $n$ 的点积：\n$L = X_{\\rho\\rho} \\cdot n = 0$.\n$M = X_{\\rho\\theta} \\cdot n = (-\\sin\\alpha \\sin\\theta)(-\\cos\\alpha\\cos\\theta) + (\\sin\\alpha \\cos\\theta)(-\\cos\\alpha\\sin\\theta) + 0 = \\sin\\alpha\\cos\\alpha\\sin\\theta\\cos\\theta - \\sin\\alpha\\cos\\alpha\\cos\\theta\\sin\\theta = 0$.\n$N = X_{\\theta\\theta} \\cdot n = (-\\rho \\sin\\alpha \\cos\\theta)(-\\cos\\alpha\\cos\\theta) + (-\\rho \\sin\\alpha \\sin\\theta)(-\\cos\\alpha\\sin\\theta) + 0 = \\rho \\sin\\alpha \\cos\\alpha (\\cos^2\\theta + \\sin^2\\theta) = \\rho \\sin\\alpha \\cos\\alpha$.\n第二基本形式的矩阵是：\n$$\nb_{ij} = \\begin{pmatrix} L & M \\\\ M & N \\end{pmatrix} = \\begin{pmatrix} 0 & 0 \\\\ 0 & \\rho \\sin\\alpha \\cos\\alpha \\end{pmatrix}\n$$\n主曲率 $\\kappa_1$ 和 $\\kappa_2$ 是形状算子（或 Weingarten 映射）的特征值，在基 $\\{X_\\rho, X_\\theta\\}$ 下，该算子由矩阵 $W = g^{-1}b$ 表示：\n$$\nW = \\begin{pmatrix} 1 & 0 \\\\ 0 & \\rho^2 \\sin^2\\alpha \\end{pmatrix}^{-1} \\begin{pmatrix} 0 & 0 \\\\ 0 & \\rho \\sin\\alpha \\cos\\alpha \\end{pmatrix} = \\begin{pmatrix} 1 & 0 \\\\ 0 & \\frac{1}{\\rho^2 \\sin^2\\alpha} \\end{pmatrix} \\begin{pmatrix} 0 & 0 \\\\ 0 & \\rho \\sin\\alpha \\cos\\alpha \\end{pmatrix} = \\begin{pmatrix} 0 & 0 \\\\ 0 & \\frac{\\cos\\alpha}{\\rho \\sin\\alpha} \\end{pmatrix}\n$$\n由于 $W$ 是对角矩阵，其特征值（主曲率）就是其对角线上的元素：\n$$\n\\kappa_1 = 0 \\quad \\text{和} \\quad \\kappa_2 = \\frac{\\cos\\alpha}{\\rho\\sin\\alpha} = \\frac{\\cot\\alpha}{\\rho}\n$$\n对应于 $\\kappa_1=0$ 的主方向是沿着 $X_{\\rho}$，即圆锥的母线，它们是直线。对应于 $\\kappa_2$ 的主方向是沿着 $X_{\\theta}$，与圆形横截面相切。\n\n从主曲率，我们计算高斯曲率 $K$ 和平均曲率 $H$：\n高斯曲率是主曲率的乘积：\n$$\nK = \\kappa_1 \\kappa_2 = 0 \\cdot \\frac{\\cot\\alpha}{\\rho} = 0\n$$\n平均曲率是主曲率的平均值：\n$$\nH = \\frac{1}{2}(\\kappa_1 + \\kappa_2) = \\frac{1}{2}\\left(0 + \\frac{\\cot\\alpha}{\\rho}\\right) = \\frac{\\cot\\alpha}{2\\rho}\n$$\n\n**第二部分：公式在顶点处的失效**\n\n关于 $H$ 和 $K$ 的公式是在曲面光滑（正则曲面）的假设下推导的。圆锥的顶点，对应于 $\\rho=0$，是参数化和曲面本身的奇点。\n1.  **参数化奇点**：在 $\\rho=0$ 处，对于所有 $\\theta \\in (0, 2\\pi)$，都有 $X(0, \\theta) = (0,0,0)$。该映射不是从参数空间到曲面的同胚。\n2.  **退化的切空间**：在 $\\rho=0$ 处，切向量 $X_{\\theta}$ 变为零向量。无法形成切空间的基，因此无法以标准方式定义切平面。\n3.  **退化的度量**：第一基本形式的行列式是 $\\det(g_{ij}) = EG - F^2 = \\rho^2 \\sin^2\\alpha$，在 $\\rho=0$ 时为 0。这表明局部微分同胚性质在此处失效。\n4.  **曲率的发散**：平均曲率的公式 $H = \\frac{\\cot\\alpha}{2\\rho}$ 表明，当 $\\rho \\to 0$ 时，$H \\to \\infty$。经典曲率在此点无定义。本质上，圆锥在其顶点处不是一个光滑流形。\n\n**第三部分：顶点处的曲率**\n\n尽管曲率的微分几何定义在顶点处失效，但其曲率在全局意义上有所体现。通过将圆锥视为一个度量空间并应用角亏的概念，可以对此进行严格描述。\n\n如果我们将圆锥沿一条母线剪开并展开到平面上，它会形成一个扇形。这个扇形的半径是圆锥的斜高 $\\rho$。在给定的 $\\rho$ 处，圆锥上圆形横截面的周长是 $C = 2\\pi r$，其中圆的半径是 $r = \\rho\\sin\\alpha$。因此，$C = 2\\pi\\rho\\sin\\alpha$。这个周长成为平面扇形的弧长。\n一个半径为 $R_{sector}$、角度为 $\\Theta$ 的扇形的弧长 $L_{arc}$ 是 $L_{arc} = R_{sector} \\cdot \\Theta$。在这里，$R_{sector}=\\rho$ 并且 $L_{arc} = 2\\pi\\rho\\sin\\alpha$。所以，\n$$\n2\\pi\\rho\\sin\\alpha = \\rho \\cdot \\Theta \\implies \\Theta = 2\\pi\\sin\\alpha\n$$\n对于一个平面，一个点周围的角度是 $2\\pi$。对于展开的圆锥，这个角度是 $\\Theta = 2\\pi\\sin\\alpha$。由于 $\\alpha \\in (0, \\pi/2)$，我们有 $0 < \\sin\\alpha < 1$，所以 $\\Theta < 2\\pi$。\n顶点的*角亏*是平面上一个点的角度与扇形角度之间的差值：\n$$\n\\delta = 2\\pi - \\Theta = 2\\pi - 2\\pi\\sin\\alpha = 2\\pi(1 - \\sin\\alpha)\n$$\n这个正的角亏是集中在顶点的正曲率的体现。广义的 Gauss-Bonnet 定理指出，一个区域上的高斯曲率积分，加上任何锥形奇点处的角亏之和，等于该区域欧拉示性的 $2\\pi$ 倍。对于圆锥，除了顶点外，高斯曲率处处为 $K=0$。总曲率集中在这一点上，等于角亏 $2\\pi(1-\\sin\\alpha)$。这是一种分布曲率，有时用狄拉克δ函数表示。\n\n总而言之，虽然光滑曲率 $K$ 在远离顶点处为零，但顶点本身承载了圆锥的全部高斯曲率，其大小由角亏量化。\n最终答案仅需要 $\\rho>0$ 时 $H(\\rho)$ 和 $K(\\rho)$ 的表达式。", "answer": "$$\n\\boxed{\\begin{pmatrix} \\frac{\\cot\\alpha}{2\\rho} & 0 \\end{pmatrix}}\n$$", "id": "2986720"}, {"introduction": "在计算机图形学、物理仿真和建筑设计等领域，连续的光滑曲面通常被离散为三角网格进行处理。本练习旨在搭建从连续微分几何到离散微分几何的桥梁，你将通过编程实现对离散网格上高斯曲率和平均曲率的近似计算。完成这项任务，你不仅能验证理论公式在离散世界中的对应形式，还能直观地看到随着网格细化，离散曲率如何收敛于连续曲率的精确值，为你将理论知识应用于实际问题打下坚实基础。", "problem": "实现一个程序，该程序在近似球体的三角化网格上近似计算平均曲率和高斯曲率，并评估误差与网格尺寸的函数关系。您必须使用的基础是主曲率的定义，即 Weingarten 映射（形算子）$S = -\\mathrm{d}n$ 的特征值，其中 $n$ 是单位法向量场。同时，还需使用定义 $H = \\tfrac{1}{2}(k_{1}+k_{2})$ 和 $K = k_{1}k_{2}$，其中 $k_{1},k_{2}$ 是主曲率。对于嵌入在 $\\mathbb{R}^{3}$ 中半径为 $R$ 的标准球体，其精确值为 $H_{\\mathrm{exact}} = 1/R$ 和 $K_{\\mathrm{exact}} = 1/R^{2}$。所有角度均以弧度为单位。\n\n基于这些定义，使用离散微分几何中经过充分测试的公式（这些公式不是目标概念，而是作为计算桥梁），在三角网格上设计并实现一个离散近似方法，具体如下：\n- 使用平均曲率法向量的余切权重近似：对于每个顶点 $i$，计算\n$$\\mathbf{Hn}_{i} \\approx \\frac{1}{2A_{i}}\\sum_{j \\in N(i)}\\left(\\cot\\alpha_{ij}+\\cot\\beta_{ij}\\right)\\left(\\mathbf{x}_{i}-\\mathbf{x}_{j}\\right),$$\n其中 $A_{i}$ 是局部顶点区域面积，$N(i)$ 是 $i$ 的一环邻域点集，$\\alpha_{ij},\\beta_{ij}$ 是与边 $\\{i,j\\}$ 相邻的两个三角形中该边所对的角。取带符号的平均曲率 $H_{i} \\approx \\tfrac{1}{2}\\langle \\mathbf{Hn}_{i}, \\mathbf{N}_{i}\\rangle$，其中 $\\mathbf{N}_{i}$ 是单位顶点法向量。\n- 使用高斯曲率的角亏近似：对于每个顶点 $i$，\n$$K_{i} \\approx \\frac{2\\pi - \\sum_{f \\ni i} \\theta_{i}^{(f)}}{A_{i}},$$\n其中 $\\theta_{i}^{(f)}$ 是面 $f$ 中顶点 $i$ 处的角。\n- 使用重心顶点区域面积 $A_{i}$，定义为 $A_{i} := \\tfrac{1}{3}\\sum_{f \\ni i}\\mathrm{Area}(f)$，并将 $\\mathbf{N}_{i}$ 计算为相邻面法向量之和的归一化结果。使用通过边向量稳健计算的 $\\cot\\theta = \\frac{\\cos\\theta}{\\sin\\theta}$，并通过叉积的范数和点积的 $\\arctan2$ 函数来计算角度。所有角度均以弧度为单位。\n\n从一个正二十面体开始，通过中点插入的方式将每个三角形重复细分为四个，并将所有新顶点投影回半径为 $R$ 的球面上，从而生成一系列闭合的三角化网格。对于每个网格：\n- 计算平均边长 $h$（网格尺寸），即所有边长的算术平均值。\n- 计算每个顶点的近似值 $H_{i}$ 和 $K_{i}$。\n- 计算平均曲率和高斯曲率的均方根 (RMS) 绝对误差：\n$$\\mathrm{RMS}_{H} = \\sqrt{\\frac{1}{n}\\sum_{i=1}^{n}\\left(H_{i} - \\frac{1}{R}\\right)^{2}}, \\quad \\mathrm{RMS}_{K} = \\sqrt{\\frac{1}{n}\\sum_{i=1}^{n}\\left(K_{i} - \\frac{1}{R^{2}}\\right)^{2}},$$\n其中 $n$ 是顶点数。\n\n您的程序必须实现上述功能，且无需任何用户输入。使用以下参数测试套件，其中每个案例都是一个参数对 $(R, s)$，$R$ 是球体半径，$s$ 是从正二十面体开始的细分步数：\n- $(1.0, 0)$\n- $(1.0, 1)$\n- $(1.0, 2)$\n- $(1.0, 3)$\n- $(2.0, 1)$\n\n对于每个测试用例，生成网格，计算平均边长 $h$、平均曲率的 RMS 绝对误差 $\\mathrm{RMS}_{H}$ 以及高斯曲率的 RMS 绝对误差 $\\mathrm{RMS}_{K}$。角度必须以弧度为单位。此问题不涉及物理单位。\n\n最终输出格式：您的程序应生成单行输出，包含一个类 JSON 的列表之列表。每个内部列表必须严格按照 $[R, h, \\mathrm{RMS}_{H}, \\mathrm{RMS}_{K}]$ 的形式和顺序，且所有四个条目均为浮点数。整个输出必须是单一行，例如：\n[[R1,h1,eH1,eK1],[R2,h2,eH2,eK2],...]\n不应打印任何额外文本。", "solution": "用户提供了一个问题，要求实现一种数值方案，用于在三角化网格上近似计算平均曲率和高斯曲率。这些网格近似一个给定半径 $R$ 的球体。近似的质量通过计算与球体已知精确值之间的均方根 (RMS) 误差来评估。该问题定义明确，科学上合理，并为计算实现提供了所有必要的公式和参数。\n\n解决方案的结构如下：\n1. 生成三角化球面网格的方法。\n2. 曲率计算所需的离散几何量的描述。\n3. 所提供的离散高斯曲率和平均曲率公式应用的详细解析。\n4. 计算 RMS 误差的步骤。\n\n**1. 网格生成**\n\n该过程始于一个基本的正二十面体，这是一个具有 $12$ 个顶点和 $20$ 个等边三角形面的多面体。该二十面体的顶点位于半径为 R 的球面上。\n\n为了生成分辨率不断增加的网格，迭代应用一种 $1$-到-$4$ 循环细分方案。对于每个细分次数 $s$：\n- 对于当前网格中的每个三角形，计算其三条边的中点。\n- 这三个中点构成一个新的、更小的中心三角形。\n- 通过将原始三角形的每个顶点连接到其相邻的两条边的中点，形成另外三个三角形。这样，一个原始三角形就被 $4$ 个新三角形所取代。\n- 创建新顶点（中点）后，一个关键步骤是：每个新顶点都必须被投影回球面上。如果 $\\mathbf{m}$ 是一个新创建的中点，其投影后的对应点 $\\mathbf{m}'$ 由下式给出：\n$$ \\mathbf{m}' = R \\frac{\\mathbf{m}}{\\|\\mathbf{m}\\|} $$\n这确保了网格的所有顶点都位于半径为 $R$ 的球面上。该过程重复 $s$ 次。给定细分级别的整体网格分辨率由平均边长（表示为 $h$）来表征。\n\n**2. 离散几何量**\n\n在每个顶点 $\\mathbf{x}_i$ 处计算曲率需要几个源自网格拓扑的局部几何属性。\n\n- **顶点和边拓扑**：为实现高效计算，我们必须首先建立网格的连接性。这包括创建数据结构，将每个顶点映射到其相邻面（共享该顶点的面），并将每条边映射到其相邻的两个面。通过边与顶点 $i$ 连接的顶点集合称为其一环邻域，$N(i)$。\n\n- **面面积与法线**：对于一个顶点为 $\\mathbf{p}_1$、$\\mathbf{p}_2$ 和 $\\mathbf{p}_3$ 的三角形 $f$，其未归一化的法向量 $\\vec{n}_f$ 通过叉积计算得出：$\\vec{n}_f = (\\mathbf{p}_2 - \\mathbf{p}_1) \\times (\\mathbf{p}_3 - \\mathbf{p}_1)$。该面的面积是此向量模长的一半：$A_f = \\frac{1}{2}\\|\\vec{n}_f\\|$。\n\n- **顶点区域面积 $A_i$**：问题指定使用重心顶点区域面积，其定义为所有相邻面面积之和的三分之一：\n$$ A_i = \\frac{1}{3} \\sum_{f \\ni i} A_f $$\n\n- **顶点法线 $\\mathbf{N}_i$**：通过对相邻面的法线进行面积加权平均，可以计算出稳健的顶点法线。这通过对所有与顶点 $i$ 相邻的面 $f$ 的未归一化法向量 $\\vec{n}_f$ 求和，然后将结果向量归一化来实现：\n$$ \\mathbf{N}_i = \\frac{\\sum_{f \\ni i} \\vec{n}_f}{\\left\\|\\sum_{f \\ni i} \\vec{n}_f\\right\\|} $$\n\n**3. 曲率近似**\n\n在建立了局部几何量之后，我们应用所提供的离散曲率公式。\n\n- **高斯曲率 $K_i$**：顶点 $i$ 处的高斯曲率使用角亏公式进行近似。该公式将曲率与顶点周围角点角度之和与欧几里得值 $2\\pi$ 的偏差联系起来：\n$$ K_i \\approx \\frac{2\\pi - \\sum_{f \\ni i} \\theta_i^{(f)}}{A_i} $$\n此处，$\\theta_i^{(f)}$ 是面 $f$ 内顶点 $i$ 处的角度。对于形成一个角度的两个向量 $\\mathbf{u}$ 和 $\\mathbf{v}$，该角度使用 `atan2` 函数稳健地计算：$\\theta = \\mathrm{atan2}(\\|\\mathbf{u} \\times \\mathbf{v}\\|, \\mathbf{u} \\cdot \\mathbf{v})$。\n\n- **平均曲率 $H_i$**：平均曲率由离散平均曲率法向量 $\\mathbf{Hn}_i$ 导出，该向量使用余切公式进行近似。此公式是应用于顶点位置的 Laplace-Beltrami 算子的离散化。\n$$ \\mathbf{Hn}_i \\approx \\frac{1}{2A_i} \\sum_{j \\in N(i)} (\\cot\\alpha_{ij} + \\cot\\beta_{ij}) (\\mathbf{x}_i - \\mathbf{x}_j) $$\n在此表达式中，求和是针对顶点 $i$ 的一环邻域中的邻点 $j$。对于每条边 $\\{\\mathbf{x}_i, \\mathbf{x}_j\\}$，$\\alpha_{ij}$ 和 $\\beta_{ij}$ 是相邻三角形中与该边相对的两个角。由向量 $\\mathbf{u}$ 和 $\\mathbf{v}$ 形成的角度的余切值可以稳健地计算为 $\\cot\\theta = \\frac{\\mathbf{u} \\cdot \\mathbf{v}}{\\|\\mathbf{u} \\times \\mathbf{v}\\|}$。\n\n然后，根据问题的定义，通过将平均曲率法向量投影到顶点法线上并进行缩放，得到标量平均曲率 $H_i$：\n$$ H_i \\approx \\frac{1}{2}\\langle \\mathbf{Hn}_i, \\mathbf{N}_i \\rangle $$\n由余切公式定义的向量 $\\mathbf{Hn}_i$ 近似于 $2H\\mathbf{N}$。因此，此计算提供了带符号的平均曲率 $H_i$。对于具有向外法线的球体，此值为正。\n\n**4. 误差评估**\n\n离散曲率近似的准确性通过将其与半径为 $R$ 的球体的精确解析值进行比较来评估。精确的平均曲率为 $H_{\\mathrm{exact}} = 1/R$，精确的高斯曲率为 $K_{\\mathrm{exact}} = 1/R^2$。\n\n对网格的所有 $n$ 个顶点，计算平均曲率和高斯曲率的均方根 (RMS) 绝对误差：\n$$ \\mathrm{RMS}_H = \\sqrt{\\frac{1}{n} \\sum_{i=1}^n (H_i - H_{\\mathrm{exact}})^2} $$\n$$ \\mathrm{RMS}_K = \\sqrt{\\frac{1}{n} \\sum_{i=1}^n (K_i - K_{\\mathrm{exact}})^2} $$\n\n整体算法包括为每个测试用例 $(R, s)$ 执行这些步骤：生成网格，计算所有必需的几何量和曲率，最后计算平均边长 $h$ 和 RMS 误差 $\\mathrm{RMS}_H$ 与 $\\mathrm{RMS}_K$。", "answer": "```python\nimport numpy as np\n\ndef generate_sphere_mesh(radius, subdivisions):\n    \"\"\"\n    Generates a triangulated sphere mesh by subdividing an icosahedron.\n\n    Args:\n        radius (float): The radius of the sphere.\n        subdivisions (int): The number of subdivision steps.\n\n    Returns:\n        tuple: A tuple containing:\n            - np.ndarray: Vertex coordinates (n_verts, 3).\n            - np.ndarray: Face indices (n_faces, 3).\n    \"\"\"\n    t = (1.0 + np.sqrt(5.0)) / 2.0\n    \n    vertices = np.array([\n        [-1, t, 0], [1, t, 0], [-1, -t, 0], [1, -t, 0],\n        [0, -1, t], [0, 1, t], [0, -1, -t], [0, 1, -t],\n        [t, 0, -1], [t, 0, 1], [-t, 0, -1], [-t, 0, 1]\n    ], dtype=float)\n\n    faces = np.array([\n        [0, 11, 5], [0, 5, 1], [0, 1, 7], [0, 7, 10], [0, 10, 11],\n        [1, 5, 9], [5, 11, 4], [11, 10, 2], [10, 7, 6], [7, 1, 8],\n        [3, 9, 4], [3, 4, 2], [3, 2, 6], [3, 6, 8], [3, 8, 9],\n        [4, 9, 5], [2, 4, 11], [6, 2, 10], [8, 6, 7], [9, 8, 1]\n    ])\n\n    # Normalize vertices to unit sphere and scale by radius\n    vertices /= np.linalg.norm(vertices, axis=1)[:, np.newaxis]\n    \n    for _ in range(subdivisions):\n        new_faces = []\n        midpoint_cache = {}\n        \n        for face in faces:\n            v1, v2, v3 = face\n            \n            midpoints = []\n            for i, j in [(v1, v2), (v2, v3), (v3, v1)]:\n                edge = tuple(sorted((i, j)))\n                if edge not in midpoint_cache:\n                    midpoint = (vertices[i] + vertices[j]) / 2.0\n                    midpoint /= np.linalg.norm(midpoint) # Project onto unit sphere\n                    vertices = np.vstack([vertices, midpoint])\n                    midpoint_cache[edge] = len(vertices) - 1\n                midpoints.append(midpoint_cache[edge])\n            \n            m1, m2, m3 = midpoints\n            new_faces.extend([\n                [v1, m1, m3],\n                [v2, m2, m1],\n                [v3, m3, m2],\n                [m1, m2, m3]\n            ])\n        faces = np.array(new_faces)\n\n    return vertices * radius, faces\n\ndef compute_curvatures(vertices, faces):\n    \"\"\"\n    Computes per-vertex mean and Gaussian curvatures on a triangulated mesh.\n    \n    Args:\n        vertices (np.ndarray): Vertex coordinates (n_verts, 3).\n        faces (np.ndarray): Face indices (n_faces, 3).\n\n    Returns:\n        tuple: A tuple containing:\n            - np.ndarray: Per-vertex mean curvatures.\n            - np.ndarray: Per-vertex Gaussian curvatures.\n    \"\"\"\n    n_verts = len(vertices)\n    \n    # Build topological data structures\n    vertex_to_faces = [[] for _ in range(n_verts)]\n    edge_to_faces = {}\n    for i, face in enumerate(faces):\n        v1, v2, v3 = face\n        vertex_to_faces[v1].append(i)\n        vertex_to_faces[v2].append(i)\n        vertex_to_faces[v3].append(i)\n        \n        edges = [tuple(sorted((v1, v2))), tuple(sorted((v2, v3))), tuple(sorted((v3, v1)))]\n        for edge in edges:\n            if edge not in edge_to_faces:\n                edge_to_faces[edge] = []\n            edge_to_faces[edge].append(i)\n\n    # Pre-compute face normals and areas\n    face_normals = np.cross(vertices[faces[:, 1]] - vertices[faces[:, 0]], \n                            vertices[faces[:, 2]] - vertices[faces[:, 0]])\n    face_areas = np.linalg.norm(face_normals, axis=1) / 2.0\n    \n    H_per_vertex = np.zeros(n_verts)\n    K_per_vertex = np.zeros(n_verts)\n\n    for i in range(n_verts):\n        # 1. Compute Vertex Area (A_i) and Vertex Normal (N_i)\n        incident_face_indices = vertex_to_faces[i]\n        A_i = np.sum(face_areas[incident_face_indices]) / 3.0\n        \n        N_i_unnormalized = np.sum(face_normals[incident_face_indices], axis=0)\n        N_i = N_i_unnormalized / np.linalg.norm(N_i_unnormalized)\n\n        # 2. Compute Gaussian Curvature (K_i) via angle defect\n        angle_sum = 0.0\n        for face_idx in incident_face_indices:\n            face_verts = faces[face_idx]\n            other_verts = [v for v in face_verts if v != i]\n            v_i, v_j, v_k = vertices[i], vertices[other_verts[0]], vertices[other_verts[1]]\n            vec1 = v_j - v_i\n            vec2 = v_k - v_i\n            \n            # Robust angle calculation using atan2\n            dot_prod = np.dot(vec1, vec2)\n            cross_prod_norm = np.linalg.norm(np.cross(vec1, vec2))\n            angle_sum += np.arctan2(cross_prod_norm, dot_prod)\n        \n        if A_i > 1e-12:\n            K_per_vertex[i] = (2 * np.pi - angle_sum) / A_i\n        \n        # 3. Compute Mean Curvature (H_i) via cotangent formula\n        mean_curvature_vector = np.zeros(3)\n        neighbors = set()\n        for face_idx in incident_face_indices:\n            for v_idx in faces[face_idx]:\n                if v_idx != i:\n                    neighbors.add(v_idx)\n        \n        for j in neighbors:\n            edge = tuple(sorted((i, j)))\n            f1_idx, f2_idx = edge_to_faces[edge]\n            \n            # Find opposite vertices\n            p1 = [v for v in faces[f1_idx] if v != i and v != j][0]\n            p2 = [v for v in faces[f2_idx] if v != i and v != j][0]\n\n            cot_alpha = 0.0\n            cot_beta = 0.0\n\n            # Cotangent of angle at p1\n            vec_p1_i = vertices[i] - vertices[p1]\n            vec_p1_j = vertices[j] - vertices[p1]\n            dot_alpha = np.dot(vec_p1_i, vec_p1_j)\n            cross_alpha_norm = np.linalg.norm(np.cross(vec_p1_i, vec_p1_j))\n            if cross_alpha_norm > 1e-12:\n                cot_alpha = dot_alpha / cross_alpha_norm\n\n            # Cotangent of angle at p2\n            vec_p2_i = vertices[i] - vertices[p2]\n            vec_p2_j = vertices[j] - vertices[p2]\n            dot_beta = np.dot(vec_p2_i, vec_p2_j)\n            cross_beta_norm = np.linalg.norm(np.cross(vec_p2_i, vec_p2_j))\n            if cross_beta_norm > 1e-12:\n                cot_beta = dot_beta / cross_beta_norm\n            \n            mean_curvature_vector += (cot_alpha + cot_beta) * (vertices[i] - vertices[j])\n        \n        if A_i > 1e-12:\n            Hn_i = mean_curvature_vector / (2.0 * A_i)\n            H_per_vertex[i] = 0.5 * np.dot(Hn_i, N_i)\n            \n    return H_per_vertex, K_per_vertex\n\ndef compute_metrics(vertices, faces, H_per_vertex, K_per_vertex, R):\n    \"\"\"\n    Computes mesh size h and RMS errors for curvatures.\n    \n    Args:\n        vertices (np.ndarray): Vertex coordinates.\n        faces (np.ndarray): Face indices.\n        H_per_vertex (np.ndarray): Per-vertex mean curvatures.\n        K_per_vertex (np.ndarray): Per-vertex Gaussian curvatures.\n        R (float): Sphere radius.\n\n    Returns:\n        tuple: (h, RMS_H, RMS_K)\n    \"\"\"\n    n_verts = len(vertices)\n    \n    # Average edge length h\n    edge_set = set()\n    for face in faces:\n        edge_set.add(tuple(sorted((face[0], face[1]))))\n        edge_set.add(tuple(sorted((face[1], face[2]))))\n        edge_set.add(tuple(sorted((face[2], face[0]))))\n    \n    edge_lengths = [np.linalg.norm(vertices[v1] - vertices[v2]) for v1, v2 in edge_set]\n    h = np.mean(edge_lengths) if edge_lengths else 0.0\n    \n    # RMS Errors\n    H_exact = 1.0 / R\n    K_exact = 1.0 / (R**2)\n    \n    RMS_H = np.sqrt(np.mean((H_per_vertex - H_exact)**2))\n    RMS_K = np.sqrt(np.mean((K_per_vertex - K_exact)**2))\n    \n    return h, RMS_H, RMS_K\n\ndef solve():\n    \"\"\"\n    Main function to run the test cases and print the results.\n    \"\"\"\n    test_cases = [\n        (1.0, 0),\n        (1.0, 1),\n        (1.0, 2),\n        (1.0, 3),\n        (2.0, 1),\n    ]\n\n    results = []\n    for R, s in test_cases:\n        vertices, faces = generate_sphere_mesh(R, s)\n        H, K = compute_curvatures(vertices, faces)\n        h, RMS_H, RMS_K = compute_metrics(vertices, faces, H, K, R)\n        results.append([R, h, RMS_H, RMS_K])\n\n    # Format the final output string\n    result_strings = []\n    for r in results:\n        # Format numbers to avoid excessive precision, but keep as floats\n        # Using standard string conversion for floats as no specific format was requested\n        inner_list = f\"[{r[0]},{r[1]},{r[2]},{r[3]}]\"\n        result_strings.append(inner_list)\n    \n    final_output = f\"[{','.join(result_strings)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "2986728"}]}