{"hands_on_practices": [{"introduction": "在我们探索关于可证性的深刻定理之前，我们必须首先在算术的形式语言中严格定义“可证性”的含义。这个过程被称为算术化，它将公式和证明等句法对象编码为数字。\n\n本练习将引导你完成构造可证性谓词 $\\mathrm{Prov}_T(x)$ 的关键步骤。通过正确定义“y 是 x 的一个证明”的谓词，你将理解为何 $\\mathrm{Prov}_T(x)$ 是一个 $\\Sigma_1$ 公式，而这一性质对于证明可导性条件本身至关重要。[@problem_id:2971586]", "problem": "设 $T$ 是一阶算术语言中 $\\Sigma_1$ 公式归纳法 ($I\\Sigma_1$) 的一个可计算公理化扩张，并固定一个关于公式编码和证明对象的有限序列的标准原始递归 Gödel 编码。具体来说，存在一些原始递归函数，其图像在 $I\\Sigma_1$ 中可由有界 ($\\Delta_0$) 公式定义，例如，返回由 $y$ 编码的有限序列中条目数量的长度函数 $y \\mapsto \\mathrm{len}(y)$，以及当 $i<\\mathrm{len}(y)$ 时返回由 $y$ 编码的序列中第 $i$ 个条目的条目函数 $(y,i) \\mapsto \\mathrm{entry}(y,i)$。还有一个原始递归谓词 $\\mathrm{Prf}_T(y)$，表示 $y$ 在一个固定的 Hilbert 式演算中编码了一个正确的 $T$-证明，这意味着每一行要么是一个逻辑公理，要么是 $T$ 的一个公理，要么是通过分离规则 (modus ponens) 从前面的行推导出来的。\n\n可证性的算术化需要一个公式来捕捉“$p$ 是由 $y$ 编码的证明的最后一行”这一概念，并用它来定义二元证明谓词 $\\mathrm{Proof}_T(y,x)$，后者又产生一元可证性谓词 $\\mathrm{Prov}_T(x) \\equiv \\exists y\\, \\mathrm{Proof}_T(y,x)$。在 $I\\Sigma_1$ 中这类定义的正确性是 Gödel 第二不完备性定理和 Löb 定理中使用的可证性条件的基础。\n\n下列哪个选项给出了“$p$ 是由 $y$ 编码的证明的最后一行”的一个正确的 $I\\Sigma_1$-形式化，并正确解释了如何用它来定义 $\\mathrm{Proof}_T(y,x)$ 以使得 $\\mathrm{Prov}_T(x)$ 是 $\\Sigma_1$的？\n\nA. 通过有界公式定义“最后一行”关系\n$$\\mathrm{Last}(y,p)\\;\\;\\equiv\\;\\; \\mathrm{Seq}(y)\\;\\wedge\\;\\mathrm{len}(y)>0\\;\\wedge\\; p=\\mathrm{entry}\\!\\big(y,\\mathrm{len}(y)-1\\big),$$\n其中 $\\mathrm{Seq}(y)$ 断言 $y$ 编码了一个公式编码的有限序列。然后设定\n$$\\mathrm{Proof}_T(y,x)\\;\\;\\equiv\\;\\; \\mathrm{Prf}_T(y)\\;\\wedge\\;\\mathrm{Last}(y,x),$$\n并因此得到\n$$\\mathrm{Prov}_T(x)\\;\\;\\equiv\\;\\;\\exists y\\,\\mathrm{Proof}_T(y,x).$$\n因为 $\\mathrm{Prf}_T$ 和编码函数都是原始递归的，$I\\Sigma_1$ 证明了 $\\mathrm{Last}(y,p)$是 $\\Delta_0$ 的，$\\mathrm{Proof}_T(y,x)$ 也是 $\\Delta_0$ 的，这使得 $\\mathrm{Prov}_T(x)$ 成为一个 $\\Sigma_1$ 公式，并使得在 $I\\Sigma_1$ 中内化分离规则和 Hilbert–Bernays–Löb 可证性条件成为可能。\n\nB. 通过下式定义“最后一行”关系\n$$\\mathrm{Last}(y,p)\\;\\;\\equiv\\;\\; p\\in y\\;\\wedge\\;\\forall i<\\mathrm{len}(y)\\,\\big(p\\ge \\mathrm{entry}(y,i)\\big),$$\n因此最后一行是编码证明中出现的最大的 Gödel 数。然后设定\n$$\\mathrm{Proof}_T(y,x)\\;\\;\\equiv\\;\\; \\mathrm{Prf}_T(y)\\;\\wedge\\; x\\in y,$$\n因为对于可证性而言，重要的是 $x$ 出现在证明的某个地方。这通过对 $y$ 进行存在量化来确保 $\\mathrm{Prov}_T(x)$ 是 $\\Sigma_1$ 的。\n\nC. “最后一行”性质不能在 $I\\Sigma_1$ 中用有界 ($\\Delta_0$) 公式表达，因为它内在地量化了序列的所有扩展，因此需要一个 $\\Pi_2$ 条件。因此，必须定义\n$$\\mathrm{Proof}_T(y,x)\\;\\;\\equiv\\;\\;\\forall z\\,\\big(z\\text{ extends }y \\rightarrow \\text{the last entry of }z\\text{ is }x\\big),$$\n这使得 $\\mathrm{Prov}_T(x)$ 成为一个 $\\Pi_2$ 公式。这种更高的复杂性对于恢复 Gödel 定理和 Löb 定理中使用的可证性条件是必要的。\n\nD. 通过下式定义“最后一行”关系\n$$\\mathrm{Last}(y,p)\\;\\;\\equiv\\;\\;\\exists i<\\mathrm{len}(y)\\,\\big(p=\\mathrm{entry}(y,i)\\big),$$\n也就是说，$p$ 是证明的某一行。然后设定\n$$\\mathrm{Proof}_T(y,x)\\;\\;\\equiv\\;\\; \\mathrm{Prf}_T(y)\\;\\wedge\\;\\exists i<\\mathrm{len}(y)\\,\\big(x=\\mathrm{entry}(y,i)\\big),$$\n因为 $x$ 在有效证明中的任何一次出现都足以证明 $x$ 是可证的。这将 $\\mathrm{Prov}_T(x)$ 保持为 $\\Sigma_1$ 公式，并且对于可证性条件是足够的。", "solution": "任务是为一个指定的理论 $T$ 确定可证性谓词 $\\mathrm{Prov}_T(x)$ 的正确形式化，确保该谓词是一个 $\\Sigma_1$ 公式，并满足证明 Gödel 定理和 Löb 定理的要求。这取决于谓词 $\\mathrm{Proof}_T(y,x)$ 的正确算术化，该谓词代表“$y$ 是 Gödel 数为 $x$ 的公式的一个 $T$-证明的编码”。\n\n在 Hilbert 式系统中，一个形式证明是一个公式的有限序列，其中每个公式要么是一个公理，要么是通过推理规则（此处为分离规则）从前面的公式推导出来的。一个公式 $\\phi$ 被这样一个序列所证明，当且仅当 $\\phi$ 是该序列中的**最后**一个公式。\n\n$\\mathrm{Prov}_T(x)$ 的定义通常由 $\\exists y \\, \\mathrm{Proof}_T(y,x)$ 给出。根据算术层级，要使 $\\mathrm{Prov}_T(x)$ 成为一个 $\\Sigma_1$ 公式，它的母式 (matrix) $\\mathrm{Proof}_T(y,x)$ 必须是一个 $\\Delta_0$ 公式（一个所有量词都有界的公式）。\n\n公式 $\\mathrm{Proof}_T(y,x)$ 必须断言两个条件：\n1.  $y$ 编码了一个有效的 $T$-证明。这由谓词 $\\mathrm{Prf}_T(y)$ 给出。问题陈述 $\\mathrm{Prf}_T(y)$ 是一个原始递归谓词。可计算性理论的一个基本定理（在诸如 $I\\Sigma_1$ 的弱算术中可证）指出，每个原始递归谓词都可由一个 $\\Delta_0$ 公式定义。\n2.  Gödel 数为 $x$ 的公式是由 $y$ 编码的证明的结论。如前所述，这意味着 $x$ 必须是由 $y$ 编码的序列中最后一个公式的 Gödel 数。\n\n让我们为第二个条件构造公式。问题提供了一个标准的 Gödel 编码机制，用于有限序列，并带有原始递归函数 $\\mathrm{len}(y)$ 和 $\\mathrm{entry}(y,i)$，其图像可由 $\\Delta_0$ 公式定义。如果一个序列的长度大于0，则它非空。长度为 $L$ 的序列的索引从 $0$ 到 $L-1$。因此，最后一个条目位于索引 $\\mathrm{len}(y)-1$ 处。\n断言“$p$ 是由 $y$ 编码的证明的最后一行”被形式化为：“$y$ 编码了一个非空的公式序列，且 $p$ 是索引为 $\\mathrm{len}(y)-1$ 的条目”。\n以形式化符号表示，即：\n$$ \\mathrm{Last}(y,p) \\equiv \\mathrm{Seq}(y) \\land \\mathrm{len}(y) > 0 \\land p = \\mathrm{entry}(y, \\mathrm{len}(y)-1) $$\n此处，$\\mathrm{Seq}(y)$ 是一个谓词（假定为 $\\Delta_0$），用于检查 $y$ 是否是一个序列的有效编码。关系 $l = \\mathrm{len}(y)$ 和 $e = \\mathrm{entry}(y,i)$ 是 $\\Delta_0$ 的。基本算术运算和比较，如 $k = l-1$ 和 $l>0$，也是 $\\Delta_0$ 的。由于所有组件和操作都是 $\\Delta_0$ 的，复合公式 $\\mathrm{Last}(y,p)$ 是一个 $\\Delta_0$ 公式。\n\n现在，我们可以将 $\\mathrm{Proof}_T(y,x)$ 定义为这两个条件的合取：\n$$ \\mathrm{Proof}_T(y,x) \\equiv \\mathrm{Prf}_T(y) \\land \\mathrm{Last}(y,x) $$\n因为 $\\mathrm{Prf}_T(y)$ 和 $\\mathrm{Last}(y,x)$ 都是 $\\Delta_0$ 公式，它们的合取 $\\mathrm{Proof}_T(y,x)$ 也是一个 $\\Delta_0$ 公式。\n\n最后，可证性谓词定义为：\n$$ \\mathrm{Prov}_T(x) \\equiv \\exists y \\, \\mathrm{Proof}_T(y,x) $$\n这是一个 $\\Delta_0$ 公式的存在量化，根据定义，它是一个 $\\Sigma_1$ 公式。这个标准构造正是证明 Hilbert-Bernays-Löb 可证性条件所需要的，特别是第三个条件，$T \\vdash \\mathrm{Prov}_T(\\ulcorner \\phi \\urcorner) \\to \\mathrm{Prov}_T(\\ulcorner \\mathrm{Prov}_T(\\ulcorner \\phi \\urcorner) \\urcorner)$，其证明依赖于 $\\Sigma_1$ 公式 $\\mathrm{Prov}_T(\\ulcorner \\phi \\urcorner)$ 的 $\\Sigma_1$-完备性。\n\n现在我们基于此推导来评估给出的选项。\n\n**A. 通过有界公式定义“最后一行”关系...**\n这个选项展示了上面推导出的确切构造。\n-   $\\mathrm{Last}(y,p)\\;\\;\\equiv\\;\\; \\mathrm{Seq}(y)\\;\\wedge\\;\\mathrm{len}(y)>0\\;\\wedge\\; p=\\mathrm{entry}\\!\\big(y,\\mathrm{len}(y)-1\\big)$：这是序列最后一行的正确定义。\n-   $\\mathrm{Proof}_T(y,x)\\;\\;\\equiv\\;\\; \\mathrm{Prf}_T(y)\\;\\wedge\\;\\mathrm{Last}(y,x)$：这正确地将证明的有效性与结论结合起来。\n-   $\\mathrm{Prov}_T(x)\\;\\;\\equiv\\;\\;\\exists y\\,\\mathrm{Proof}_T(y,x)$：这是可证性谓词的标准定义。\n-   所提供的推理完全正确：原始递归性意味着 $\\mathrm{Prf}_T$ 和编码函数具有 $\\Delta_0$ 可表示性，这使得 $\\mathrm{Proof}_T(y,x)$ 成为一个 $\\Delta_0$ 公式，而 $\\mathrm{Prov}_T(x)$ 成为一个 $\\Sigma_1$ 公式。这种结构对于证明可证性条件至关重要。\n*   **结论：** 正确。\n\n**B. 通过...最大的 Gödel 数...定义“最后一行”关系...**\n这个选项建议将最后一行定义为证明中具有最大 Gödel 数的公式。这在概念上是错误的。一个证明的结论是由其在演绎序列中的位置决定的，而不是由其编码的数值决定的。该选项还建议定义 $\\mathrm{Proof}_T(y,x) \\equiv \\mathrm{Prf}_T(y) \\wedge x \\in y$，这意味着 $x$ 仅仅是出现在证明的任何地方。这也是不正确的；出现在证明中的公式不一定是由该证明所证明的定理。它可能是一个公理、一个子推导中的假设或一个中间引理。\n*   **结论：** 不正确。\n\n**C. “最后一行”性质不能在 $I\\Sigma_1$ 中用有界 ($\\Delta_0$) 公式表达...**\n这个选项声称形式化 “最后一行” 性质需要一个 $\\Pi_2$ 条件。这是错误的。如选项 A 的分析所示，该性质可由一个 $\\Delta_0$ 公式定义。对序列的所有扩展进行量化的想法与识别一个给定、固定序列 $y$ 的最后一个元素无关。此外，它声称这种更高的复杂性对于可证性条件是必要的，这与事实恰恰相反。标准的证明要求 $\\mathrm{Prov}_T(x)$ 是 $\\Sigma_1$ 的。一个更复杂的谓词将使第三可证性条件的通常证明无效。\n*   **结论：** 不正确。\n\n**D. 通过...$p$ 是证明的某一行...定义“最后一行”关系...**\n这个选项将关系定义为 $\\exists i<\\mathrm{len}(y)\\,\\big(p=\\mathrm{entry}(y,i)\\big)$，意味着 $p$ 是出现在证明序列中的任何公式。这与选项 B 中的概念性错误相同。虽然这会得到一个 $\\Sigma_1$ 可证性谓词，但该谓词不能代表定理性的正确概念。一个公式是可证的意味着存在一个以它为结论的证明，而不仅仅是存在一个包含它的证明。这个错误的定义将不满足可证性条件；例如，分离规则 (D2) 的形式化将会失败。\n*   **结论：** 不正确。", "answer": "$$\\boxed{A}$$", "id": "2971586"}, {"introduction": "Solovay 的一项卓越发现揭示了算术可证性谓词的行为与模态逻辑 GL (Gödel-Löb 逻辑) 之间深刻的联系。GL 的公理和规则完美地抽象了 Hilbert-Bernays-Löb 可导性条件所捕捉的原则。\n\n本练习要求你将一个 GL 中的形式证明转化为算术中的推导，从而提供对此对应关系的直接、动手实践的经验。通过使用可导性条件将每个模态推理步骤映射到其算术对应物，你将巩固对 GL 如何作为“可证性逻辑”的理解。[@problem_id:2971576]", "problem": "令 $GL$ 表示 Gödel–Löb 可证性逻辑 (GL)，这是一个正规模态逻辑，其公理化由所有命题重言式、由 $\\Box(\\varphi \\rightarrow \\psi) \\rightarrow (\\Box \\varphi \\rightarrow \\Box \\psi)$ 给出的模态公理模式 $K$、以及 Löb 公理模式 $\\Box(\\Box \\varphi \\rightarrow \\varphi) \\rightarrow \\Box \\varphi$ 构成，并且在分离规则 (modus ponens) 和必然化规则 (necessitation) 下封闭。令 $T$ 为一个固定的、递归公理化的、相容的皮亚诺算术 (Peano Arithmetic) 的扩张，该理论拥有一个标准的 $\\Sigma_{1}$ 可证性谓词 $\\operatorname{Prov}_{T}(x)$，满足 Hilbert–Bernays–Löb 可推导条件：\n- $(D1)$ 若 $T \\vdash \\varphi$，则 $T \\vdash \\operatorname{Prov}_{T}(\\ulcorner \\varphi \\urcorner)$。\n- $(D2)$ $T \\vdash \\operatorname{Prov}_{T}(\\ulcorner \\varphi \\rightarrow \\psi \\urcorner) \\rightarrow \\big(\\operatorname{Prov}_{T}(\\ulcorner \\varphi \\urcorner) \\rightarrow \\operatorname{Prov}_{T}(\\ulcorner \\psi \\urcorner)\\big)$。\n- $(D3)$ $T \\vdash \\operatorname{Prov}_{T}(\\ulcorner \\varphi \\urcorner) \\rightarrow \\operatorname{Prov}_{T}(\\ulcorner \\operatorname{Prov}_{T}(\\ulcorner \\varphi \\urcorner) \\urcorner)$。\n\n固定一个算术解释 $\\langle \\cdot \\rangle$，该解释将命题变量映为封闭的算术语句，同态地处理布尔联结词，并通过 $\\langle \\Box \\chi \\rangle := \\operatorname{Prov}_{T}(\\ulcorner \\langle \\chi \\rangle \\urcorner)$ 处理模态算子。具体来说，固定两个任意的封闭算术语句 $\\alpha$ 和 $\\beta$，并解释 $p \\mapsto \\alpha$，$q \\mapsto \\beta$。\n\n任务：\n1. 仅使用公理、分离规则和必然化规则，在 $GL$ 中给出模态公式 $\\Box p \\rightarrow \\Box(q \\rightarrow p)$ 的一个有限推导。\n2. 在该算术解释下，将每个推理步骤追踪为一个关于 $\\operatorname{Prov}_{T}(\\ulcorner \\alpha \\urcorner) \\rightarrow \\operatorname{Prov}_{T}(\\ulcorner \\beta \\rightarrow \\alpha \\urcorner)$ 的形式 $T$-推导，推导的出发点仅限于可推导条件 $(D1)$–$(D3)$ 和 $T$ 内部的命题推理。\n3. 令 $n_{1}$、$n_{2}$ 和 $n_{3}$ 分别为您在 $T$-推导中调用条件 $(D1)$、$(D2)$ 和 $(D3)$ 的次数。计算该有序三元组 $(n_{1}, n_{2}, n_{3})$。\n\n将最终的有序三元组报告为格式化为行矩阵的单个表达式。无需四舍五入。", "solution": "该问题要求完成三项任务：在模态逻辑 $GL$ 中推导一个公式，将此推导翻译成算术理论 $T$ 中的一个形式证明，并计算在该翻译后的证明中给定可推导条件的使用次数。\n\n首先，对问题进行验证。Gödel-Löb 逻辑 $GL$、算术理论 $T$、可证性谓词 $\\operatorname{Prov}_{T}(x)$ 以及三个 Hilbert–Bernays–Löb 可推导条件 ($(D1)$、$(D2)$、$(D3)$) 的定义在数理逻辑领域内都是标准的且陈述正确。该问题是自洽的、有科学依据的，并且是适定的。任务的规定足够精确，可以得出一个唯一且可验证的解决路径。因此，该问题是有效的。\n\n解答将分为三部分呈现，分别对应三项任务。\n\n### 第 1 部分：在 $GL$ 中的推导\n\n目标是在逻辑 $GL$ 中为模态公式 $\\Box p \\rightarrow \\Box(q \\rightarrow p)$ 提供一个有限推导。可用的推理规则是分离规则 (modus ponens，从 $\\varphi$ 和 $\\varphi \\rightarrow \\psi$ 推断出 $\\psi$) 和必然化规则 (necessitation，从 $\\vdash \\varphi$ 推断出 $\\vdash \\Box \\varphi$)。公理包括所有命题重言式、公理 $K: \\Box(\\varphi \\rightarrow \\psi) \\rightarrow (\\Box \\varphi \\rightarrow \\Box \\psi)$ 和 Löb 公理 $L: \\Box(\\Box \\varphi \\rightarrow \\varphi) \\rightarrow \\Box \\varphi$。\n\n目标公式 $\\Box p \\rightarrow \\Box(q \\rightarrow p)$ 是逻辑 $K$ 的一个定理，而 $K$ 是 $GL$ 的一个子逻辑。因此，我们不需要使用 Löb 公理。推导过程如下：\n\n1.  $p \\rightarrow (q \\rightarrow p)$\n    这是一个命题重言式的实例，因此它是 $GL$ 中的一条公理。\n\n2.  $\\Box(p \\rightarrow (q \\rightarrow p))$\n    这由第 (1) 行通过必然化规则得出。由于 $p \\rightarrow (q \\rightarrow p)$ 是一个定理，$\\Box(p \\rightarrow (q \\rightarrow p))$ 也是一个定理。\n\n3.  $\\Box(p \\rightarrow (q \\rightarrow p)) \\rightarrow (\\Box p \\rightarrow \\Box(q \\rightarrow p))$\n    这是公理模式 $K$ 的一个实例，即 $\\Box(A \\rightarrow B) \\rightarrow (\\Box A \\rightarrow \\Box B)$，其中代换为 $A := p$ 和 $B := q \\rightarrow p$。\n\n4.  $\\Box p \\rightarrow \\Box(q \\rightarrow p)$\n    这由第 (2) 行和第 (3) 行通过分离规则 (Modus Ponens) 得出。\n\n这便完成了该公式在 $GL$ 中的推导。\n\n### 第 2 部分：到 $T$-推导的算术翻译\n\n第二项任务是将上述推导翻译成理论 $T$ 内的一个形式证明。该解释将 $p$ 映为算术语句 $\\alpha$，$q$ 映为语句 $\\beta$，$ \\Box \\varphi$ 映为 $\\operatorname{Prov}_{T}(\\ulcorner \\langle \\varphi \\rangle \\urcorner)$。最终目标是推导出 $T \\vdash \\operatorname{Prov}_{T}(\\ulcorner \\alpha \\urcorner) \\rightarrow \\operatorname{Prov}_{T}(\\ulcorner \\beta \\rightarrow \\alpha \\urcorner)$。唯一允许使用的工具是可推导条件 $(D1)$、$(D2)$、$(D3)$ 以及 $T$ 内部的命题推理。\n\n我们逐步追踪 GL 的推导过程：\n\n1.  **GL 步骤 1：** 公理 $p \\rightarrow (q \\rightarrow p)$ 是一个命题重言式。\n    **$T$-推导步骤 1：** 其翻译 $\\alpha \\rightarrow (\\beta \\rightarrow \\alpha)$ 也是一个命题重言式。由于 $T$ 是皮亚诺算术的一个扩张，它能证明所有命题重言式的实例。\n    $$T \\vdash \\alpha \\rightarrow (\\beta \\rightarrow \\alpha)$$\n    此步骤不调用任何可推导条件。\n\n2.  **GL 步骤 2：** 公式 $\\Box(p \\rightarrow (q \\rightarrow p))$ 是通过必然化规则推导出来的。\n    **$T$-推导步骤 2：** 必然化规则对应于可推导条件 $(D1)$。由于我们在上一步骤中已经确立了 $T \\vdash \\alpha \\rightarrow (\\beta \\rightarrow \\alpha)$，我们可以应用 $(D1)$：若 $T \\vdash \\varphi$，则 $T \\vdash \\operatorname{Prov}_{T}(\\ulcorner \\varphi \\urcorner)$。\n    $$T \\vdash \\operatorname{Prov}_{T}(\\ulcorner \\alpha \\rightarrow (\\beta \\rightarrow \\alpha) \\urcorner)$$\n    此步骤构成对条件 $(D1)$ 的一次调用。\n\n3.  **GL 步骤 3：** 公式 $\\Box(p \\rightarrow (q \\rightarrow p)) \\rightarrow (\\Box p \\rightarrow \\Box(q \\rightarrow p))$ 是公理 $K$ 的一个实例。\n    **$T$-推导步骤 3：** 公理 $K$ 对应于可推导条件 $(D2)$：$T \\vdash \\operatorname{Prov}_{T}(\\ulcorner \\varphi \\rightarrow \\psi \\urcorner) \\rightarrow (\\operatorname{Prov}_{T}(\\ulcorner \\varphi \\urcorner) \\rightarrow \\operatorname{Prov}_{T}(\\ulcorner \\psi \\urcorner))$。我们使用该模式的一个实例，其中 $\\varphi$ 是语句 $\\alpha$，$\\psi$ 是语句 $\\beta \\rightarrow \\alpha$。这给了我们一个 $T$ 的定理。\n    $$T \\vdash \\operatorname{Prov}_{T}(\\ulcorner \\alpha \\rightarrow (\\beta \\rightarrow \\alpha) \\urcorner) \\rightarrow \\big(\\operatorname{Prov}_{T}(\\ulcorner \\alpha \\urcorner) \\rightarrow \\operatorname{Prov}_{T}(\\ulcorner \\beta \\rightarrow \\alpha \\urcorner)\\big)$$\n    此步骤构成对条件 $(D2)$ 的一次调用。请注意，该推导不需要条件 $(D3)$，该条件对应于模态公理 $4$ ($\\Box\\varphi \\to \\Box\\Box\\varphi$)。\n\n4.  **GL 步骤 4：** 最终公式 $\\Box p \\rightarrow \\Box(q \\rightarrow p)$ 是通过分离规则推导出来的。\n    **$T$-推导步骤 4：** 我们在理论 $T$ 内部应用分离规则 (Modus Ponens)。令 $A$ 为语句 $\\operatorname{Prov}_{T}(\\ulcorner \\alpha \\rightarrow (\\beta \\rightarrow \\alpha) \\urcorner)$，$B$ 为语句 $\\operatorname{Prov}_{T}(\\ulcorner \\alpha \\urcorner) \\rightarrow \\operatorname{Prov}_{T}(\\ulcorner \\beta \\rightarrow \\alpha \\urcorner)$。从步骤 2，我们有 $T \\vdash A$。从步骤 3，我们有 $T \\vdash A \\rightarrow B$。通过分离规则，我们得出结论 $T \\vdash B$。\n    $$T \\vdash \\operatorname{Prov}_{T}(\\ulcorner \\alpha \\urcorner) \\rightarrow \\operatorname{Prov}_{T}(\\ulcorner \\beta \\rightarrow \\alpha \\urcorner)$$\n    此步骤依赖于 $T$ 内部的命题推理，不调用任何可推导条件。\n\n### 第 3 部分：调用次数统计\n\n最后一项任务是计算有序三元组 $(n_{1}, n_{2}, n_{3})$，它表示在第 2 部分呈现的 $T$-推导中，条件 $(D1)$、$(D2)$ 和 $(D3)$ 被调用的次数。\n\n-   $n_{1}$：条件 $(D1)$ 在 $T$-推导的步骤 2 中被精确使用了一次，用于内化一个重言式的可证性。\n-   $n_{2}$：条件 $(D2)$ 在 $T$-推导的步骤 3 中被精确使用了一次，作为模态公理 $K$ 的算术对应物。\n-   $n_{3}$：条件 $(D3)$，$T \\vdash \\operatorname{Prov}_{T}(\\ulcorner \\varphi \\urcorner) \\rightarrow \\operatorname{Prov}_{T}(\\ulcorner \\operatorname{Prov}_{T}(\\ulcorner \\varphi \\urcorner) \\urcorner)$，在推导中完全没有被使用。\n\n因此，计数为 $n_{1} = 1$，$n_{2} = 1$，$n_{3} = 0$。该有序三元组是 $(1, 1, 0)$。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n1 & 1 & 0\n\\end{pmatrix}\n}\n$$", "id": "2971576"}, {"introduction": "当我们利用一个领域的成果来证明另一个领域的成果时，可证性逻辑与算术之间联系的力量就真正显现出来了。作为 Gödel 和 Löb 定理背后引擎的对角化引理，在模态逻辑 GL 中有一个惊人优雅的对应物。\n\n本练习探讨了 GL 中的模态不动点引理如何对应于算术对角化引理的一个版本。深入研究这种对应关系，可以揭示抽象的模态推理如何能够产生关于算术的具体、强大的定理，从而为元数学的结构基础提供深刻的洞见。[@problem_id:2971593]", "problem": "设 $T$ 是一个一致的、递归公理化的理论，该理论扩展了 Robinson 算术，并用一阶算术语言表述。其标准可证性谓词 $\\mathrm{Prov}_T(x)$ 在 $T$ 内部满足 Hilbert–Bernays–Löb 可证性条件。设 $\\mathsf{GL}$ 表示 Gödel–Löb 可证性逻辑（通过向基本模态逻辑 $\\mathsf{K}$ 添加 Löb 公理而得到的正规模态逻辑）。考虑相对于 $T$ 的从模态公式到算术的标准算术解释，记作 $\\varphi \\mapsto \\varphi^{*}$，它由以下方式确定：\n- 命题联结词被映射到其算术对应物，\n- 对于任意模态公式 $\\varphi$，使用子句 $\\,(\\Box \\varphi)^{*} \\equiv \\mathrm{Prov}_T(\\ulcorner \\varphi^{*} \\urcorner)\\,$。\n\n假设 $\\mathsf{GL}$ 中的模态不动点引理成立：如果 $A(p)$ 是一个带有单个命题变元 $p$ 的模态公式，且 $p$ 的每一次出现都在模态算子 $\\Box$ 的辖域内，那么存在一个模态语句 $F$，使得 $\\mathsf{GL} \\vdash F \\leftrightarrow A(F)$。\n\n固定一个算术语言中的算术公式 $\\psi(x)$，其唯一的自由变元是 $x$，并假设 $\\psi(x)$ 中 $x$ 的每一次自由出现都在某个项 $t$ 的形如 $\\mathrm{Prov}_T(t)$ 的子公式的辖域内；换句话说，$x$ 在 $\\psi(x)$ 中是 $\\mathrm{Prov}_T$-保护的。仅使用上述基本事实和定义，仔细推断在算术解释 $(-)^{*}$ 和 $\\mathrm{Prov}_T$ 的可证性条件下，模态不动点引理如何对应于 $T$ 内部关于 $\\mathrm{Prov}_T$ 的一个对角化原则。\n\n关于这个对应关系，以下哪些陈述是正确的？\n\nA. 在将 $\\,\\Box \\varphi\\,$ 映射到 $\\,\\mathrm{Prov}_T(\\ulcorner \\varphi \\urcorner)\\,$ 的算术解释下，模态不动点引理产生以下算术不动点：对于所有其中 $x$ 的自由出现都是 $\\mathrm{Prov}_T$-保护的算术公式 $\\psi(x)$，存在一个语句 $\\theta$ 使得 $\\,T \\vdash \\theta \\leftrightarrow \\psi(\\ulcorner \\theta \\urcorner)\\,$。\n\nB. 上述对应关系不需要在 $T$ 内部使用 Hilbert–Bernays–Löb 可证性条件；它仅在纯一阶逻辑中就成立。\n\nC. 只要 $T$ 是 $\\Sigma_1$-完备的，该对应关系就能为任意的 $\\psi(x)$（带有未受保护的 $x$ 的出现）无任何限制地产生完整的算术对角化引理。\n\nD. 该对应关系的证明仅使用了 $T$ 的标准可证性谓词的存在性；不需要语法的算术化。\n\nE. 为了从模态不动点 $F$ 中提取出满足 $\\,T \\vdash \\theta \\leftrightarrow \\psi(\\ulcorner \\theta \\urcorner)\\,$ 的算术不动点 $\\theta$，充分条件是 $T$ 满足 Hilbert–Bernays–Löb 可证性条件，从而使得 $\\mathsf{GL}$ 的算术解释是可靠的；Solovay 的关于 $\\mathsf{GL}$ 的算术完备性定理不是必需的。\n\n选择所有适用项。", "solution": "我们从陈述的基本基础开始：将模态公式映射到算术语句的算术解释 $(-)^{*}$ 的定义 $\\,(\\Box \\varphi)^{*} \\equiv \\mathrm{Prov}_T(\\ulcorner \\varphi^{*} \\urcorner)$，以及 $\\mathsf{GL}$ 中的模态不动点引理，该引理断言：对于任何模态公式 $A(p)$，其中 $p$ 仅出现在 $\\Box$ 的辖域内，存在一个模态语句 $F$ 使得 $\\,\\mathsf{GL} \\vdash F \\leftrightarrow A(F)$。我们还依赖于 $T$ 中的 Hilbert–Bernays–Löb 可证性条件，这确保了在解释 $(-)^{*}$ 下 $\\mathsf{GL}$ 的算术可靠性：只要 $\\,\\mathsf{GL} \\vdash \\varphi\\,$，我们就有 $\\,T \\vdash \\varphi^{*}$。\n\n我们将解释如何将一个 $\\mathrm{Prov}_T$-保护的算术公式 $\\psi(x)$ 转化为一个模态矩阵 $A(p)$，其方式是：对于任何模态语句 $G$，$A(G)$ 的算术解释在 $T$ 内部与将 $G^{*}$ 的 Gödel 数代入 $\\psi$ 的结果相一致。$\\psi$ 的这种“模态化”过程在 $\\psi$ 的结构上归纳进行，如下所示。\n\n考虑算术语言的片段 $\\mathcal{L}_{\\mathrm{Prov}}(x)$，它由形如 $\\mathrm{Prov}_T(t)$ 的原子公式的布尔组合构成，其中 $t$ 是任何可能提及 $x$ 的算术项。我们假设 $x$ 仅在这样的 $\\mathrm{Prov}_T(\\cdot)$ 内部是自由的。通过递归定义一个转换\n$$\n\\tau:\\mathcal{L}_{\\mathrm{Prov}}(x) \\to \\text{关于变元 }p \\text{ 的模态公式}\n$$\n如下：\n- $\\tau$ 与布尔联结词可交换：$\\tau(\\neg \\alpha)=\\neg \\tau(\\alpha)$，$\\tau(\\alpha \\wedge \\beta)=\\tau(\\alpha)\\wedge \\tau(\\beta)$，对于 $\\vee, \\to$ 也类似。\n- 对于原子公式，设 $\\tau(\\mathrm{Prov}_T(t(x)))=\\Box\\,\\sigma_{t}(p)$，其中 $\\sigma_t(p)$ 是一个命题模态公式，其算术解释是通过在算术内部计算当 $x$ 被实例化为 $\\ulcorner G^{*}\\urcorner$ 的数码时项 $t$ 的值，然后将该值用作 $\\mathrm{Prov}_T$ 的参数的 Gödel 编码而获得的算术语句。具体来说，我们固定一个标准的公式原始递归编码和一个原始递归函数 $\\mathrm{sub}(\\cdot,\\cdot)$ 使得 $\\mathrm{sub}(\\ulcorner \\chi(x)\\urcorner,\\ulcorner \\theta\\urcorner)=\\ulcorner \\chi(\\ulcorner \\theta\\urcorner)\\urcorner$，并且我们将 $t(x)$ 视为计算一个编码。选择模态原子 $\\sigma_t(p)$ 以至于对于任何模态语句 $G$，我们有\n$$\n(\\sigma_t(G))^{*} \\;\\equiv\\; \\text{其 Gödel 编码为 } \\bigl(t(\\ulcorner G^{*}\\urcorner)\\bigr) \\text{ 的算术语句}，\n$$\n因此\n$$\n(\\Box\\,\\sigma_t(G))^{*} \\;\\equiv\\; \\mathrm{Prov}_T\\!\\left(\\ulcorner (\\sigma_t(G))^{*} \\urcorner\\right) \\;\\equiv\\; \\mathrm{Prov}_T\\!\\bigl(t(\\ulcorner G^{*}\\urcorner)\\bigr).\n$$\n\n这样一个 $\\sigma_t(p)$ 的存在性源于标准的语法算术化以及编码和代入函数在算术中的可定义性：对于每个原始递归的 $t$，我们可以一致地为 $p$ 分配一个模态公式 $\\sigma_t(p)$，其算术解释是 Gödel 编码等于 $t(\\ulcorner p^{*}\\urcorner)$ 的唯一语句。在这里，算术化的使用是至关重要的。\n\n通过对 $\\psi$ 的结构进行归纳，可以得出对于每个模态语句 $G$，\n$$\n(\\tau(\\psi)(G))^{*} \\;\\leftrightarrow\\; \\psi(\\ulcorner G^{*}\\urcorner)\n$$\n在 $T$ 中是可证的。确实，布尔步骤由于 $(-)^{*}$ 在联结词上的同态行为而直接成立，而原子步骤则通过 $\\sigma_t(p)$ 的构造来安排。\n\n现在将 $\\mathsf{GL}$ 中的模态不动点引理应用于 $A(p):=\\tau(\\psi)(p)$。由于在 $A$ 中 $p$ 仅出现在 $\\Box$ 内部，我们得到一个模态语句 $F$ 满足\n$$\n\\mathsf{GL} \\vdash F \\leftrightarrow A(F) \\;=\\; \\tau(\\psi)(F).\n$$\n根据在 $(-)^{*}$ 下 $\\mathsf{GL}$ 的算术可靠性（这使用了 $T$ 中的 Hilbert–Bernays–Löb 可证性条件），我们推断出\n$$\nT \\vdash F^{*} \\leftrightarrow (\\tau(\\psi)(F))^{*}.\n$$\n根据 $\\tau$ 的定义性质，\n$$\nT \\vdash (\\tau(\\psi)(F))^{*} \\leftrightarrow \\psi(\\ulcorner F^{*}\\urcorner).\n$$\n综合这些，我们得出结论\n$$\nT \\vdash F^{*} \\leftrightarrow \\psi(\\ulcorner F^{*}\\urcorner).\n$$\n令 $\\theta := F^{*}$，这精确地产生了 $\\mathrm{Prov}_T$-保护的算术不动点。这就建立了所期望的对应关系。\n\n有了这个推导，我们来评估这些选项。\n\n选项 A. 这正是我们所证明的：对于任何 $\\mathrm{Prov}_T$-保护的 $\\psi(x)$，存在一个语句 $\\theta$ 使得 $T \\vdash \\theta \\leftrightarrow \\psi(\\ulcorner \\theta \\urcorner)$。这个构造使用了模态化 $\\tau$、用模态不动点引理来获得 $F$、以及用算术可靠性将 $F \\leftrightarrow \\tau(\\psi)(F)$ 转换到 $T$ 中，随后是识别 $(\\tau(\\psi)(F))^{*} \\leftrightarrow \\psi(\\ulcorner F^{*}\\urcorner)$。结论：正确。\n\n选项 B. $\\mathsf{GL}$ 相对于 $T$ 的 $\\mathrm{Prov}_T$ 的算术可靠性需要 Hilbert–Bernays–Löb 可证性条件。特别是，Löb 公理 $\\Box(\\Box p \\rightarrow p) \\rightarrow \\Box p$ 的可靠性正是 Löb 定理，其在 $T$ 中的证明使用了这些可证性条件。没有它们，通常不能从 $\\mathsf{GL} \\vdash F \\leftrightarrow A(F)$ 推断出 $T \\vdash F^{*} \\leftrightarrow A(F)^{*}$。结论：不正确。\n\n选项 C. 模态不动点引理仅保证了当 $p$ 仅出现在 $\\Box$ 下时模态矩阵 $A(p)$ 的不动点的存在。因此，通过 $\\tau$-转换，我们仅为那些 $x$ 仅出现在 $\\mathrm{Prov}_T(\\cdot)$ 内部的 $\\psi(x)$ 获得算术不动点。$x$ 的任意未受保护的出现（例如，在与 $\\mathrm{Prov}_T$ 无关的原子算术公式中，如 $x=0$ 或 $x$ 出现在算术项中）不能在纯命题模态语言中被模拟，因此超出了此对应关系的范围。对于任意 $\\psi(x)$ 的完整算术对角化引理是一个不同的定理，其证明使用了一般的代入算术化，而不仅仅是 $\\mathsf{GL}$ 不动点。结论：不正确。\n\n选项 D. 这个构造关键地使用了语法的算术化：我们需要公式的原始递归编码、代入函数的可定义性，以及对于每个模态 $G$，能够识别出作为 $\\mathrm{Prov}_T$ 参数出现的编码 $\\ulcorner G^{*}\\urcorner$ 的能力。此外，$\\mathrm{Prov}_T$ 的定义本身就是 $T$ 的证明谓词的一种算术化。因此，算术化是不可或缺的。结论：不正确。\n\n选项 E. 在将 $\\mathsf{GL} \\vdash F \\leftrightarrow A(F)$ 转换到 $T \\vdash F^{*} \\leftrightarrow A(F)^{*}$ 的过程中，仅使用了 $\\mathsf{GL}$ 对于 $\\mathrm{Prov}_T$ 的算术可靠性。这个可靠性源于 Hilbert–Bernays–Löb 可证性条件，并且不需要 Solovay 的算术完备性定理（这是反方向的命题：如果一个模态公式在所有源于合适的 $T$ 的算术解释下都有效，则它在 $\\mathsf{GL}$ 中是可证的）。因此，获得不动点对应关系并不需要 Solovay 完备性。结论：正确。\n\n因此，正确的陈述是 A 和 E。", "answer": "$$\\boxed{AE}$$", "id": "2971593"}]}