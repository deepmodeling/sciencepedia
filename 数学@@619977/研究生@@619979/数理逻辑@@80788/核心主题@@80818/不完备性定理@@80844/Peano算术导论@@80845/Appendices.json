{"hands_on_practices": [{"introduction": "在任何量化公式中，区分自由变量和约束变量是理解其确切含义的第一步。这个练习将引导你通过递归定义来精确形式化这一概念，并将其应用于一个具体的例子。这是所有后续逻辑工作中都不可或缺的一项基本功 [@problem_id:2974905]。", "problem": "考虑皮亚诺算术（PA）的标准一阶语言（记作 $L_{PA}$），其用于构造项的符号包括变量、常数符号 $0$、一元函数符号 $S$ 以及二元函数符号 $+$ 和 $\\cdot$。公式由原子公式使用二元谓词符号 $=$、命题联结词以及量词 $\\forall$ 和 $\\exists$ 构造而成。从这些构成规则出发，给出一个函数的精确归纳定义，该函数将每个项 $t$ 映射到出现在 $t$ 中的变量集合，并将每个公式 $\\varphi$ 映射到其自由变量集合 $\\mathsf{FV}(\\varphi)$。您的定义必须覆盖上述所有构造子（变量、$0$、$S$、$+$、$\\cdot$、=、命题联结词和量词），并且通过对项和公式的结构递归进行。然后，仅使用您的定义，计算公式 $\\exists x\\,\\forall y\\,(x\\cdot z=y)$ 的自由变量集合 $\\mathsf{FV}(\\exists x\\,\\forall y\\,(x\\cdot z=y))$。将您的最终答案表示为一个单独的闭式符号表达式（一个用枚举法写出的集合）。", "solution": "该问题是有效的，因为它是在数理逻辑领域内一个适定、有科学依据的客观问题。它要求在皮亚诺算术语言中，给出项中变量集合和公式中自由变量集合的标准归纳定义，随后将这些定义应用于一个具体公式。\n\n设 $L_{PA}$ 为皮亚诺算术的一阶语言。$L_{PA}$ 的所有项的集合和所有公式的集合是通过结构归纳定义的。因此，我们可以通过结构递归在这些集合上定义函数。\n\n首先，我们定义函数 $\\mathsf{Var}$，它将每个项 $t$ 映射到出现在其中的变量集合，记作 $\\mathsf{Var}(t)$。该定义是基于项 $t$ 的结构进行递归的。\n\n1.  **基本情况（变量）：** 如果 $t$ 是一个变量，例如 $x$，那么 $\\mathsf{Var}(x) = \\{x\\}$。\n2.  **基本情况（常数）：** 如果 $t$ 是常数符号 $0$，那么 $\\mathsf{Var}(0) = \\emptyset$。\n3.  **归纳步骤（后继）：** 如果 $t$ 的形式为 $S(t')$，其中 $t'$ 是一个项，那么 $\\mathsf{Var}(S(t')) = \\mathsf{Var}(t')$。\n4.  **归纳步骤（加法）：** 如果 $t$ 的形式为 $(t_1 + t_2)$，其中 $t_1$ 和 $t_2$ 是项，那么 $\\mathsf{Var}(t_1 + t_2) = \\mathsf{Var}(t_1) \\cup \\mathsf{Var}(t_2)$。\n5.  **归纳步骤（乘法）：** 如果 $t$ 的形式为 $(t_1 \\cdot t_2)$，其中 $t_1$ 和 $t_2$ 是项，那么 $\\mathsf{Var}(t_1 \\cdot t_2) = \\mathsf{Var}(t_1) \\cup \\mathsf{Var}(t_2)$。\n\n接下来，我们定义函数 $\\mathsf{FV}$，它将每个公式 $\\varphi$ 映射到其自由变量的集合，记作 $\\mathsf{FV}(\\varphi)$。该定义是基于公式 $\\varphi$ 的结构进行递归的。对于命题联结词的定义是针对一个功能完备集 $\\{\\neg, \\land\\}$ 给出的；其他联结词如 $\\lor$、 $\\to$ 和 $\\leftrightarrow$ 的定义遵循类似的模式，基于它们与 $\\neg$ 和 $\\land$ 的关系。\n\n1.  **基本情况（原子公式）：** 如果 $\\varphi$ 的形式为 $t_1 = t_2$，其中 $t_1$ 和 $t_2$ 是项，那么 $\\mathsf{FV}(t_1 = t_2) = \\mathsf{Var}(t_1) \\cup \\mathsf{Var}(t_2)$。\n2.  **归纳步骤（否定）：** 如果 $\\varphi$ 的形式为 $\\neg\\psi$，其中 $\\psi$ 是一个公式，那么 $\\mathsf{FV}(\\neg\\psi) = \\mathsf{FV}(\\psi)$。\n3.  **归纳步骤（合取）：** 如果 $\\varphi$ 的形式为 $(\\psi_1 \\land \\psi_2)$，其中 $\\psi_1$ 和 $\\psi_2$ 是公式，那么 $\\mathsf{FV}(\\psi_1 \\land \\psi_2) = \\mathsf{FV}(\\psi_1) \\cup \\mathsf{FV}(\\psi_2)$。\n4.  **归纳步骤（存在量词）：** 如果 $\\varphi$ 的形式为 $\\exists x\\,\\psi$，其中 $x$ 是一个变量，$\\psi$ 是一个公式，那么 $\\mathsf{FV}(\\exists x\\,\\psi) = \\mathsf{FV}(\\psi) \\setminus \\{x\\}$。\n5.  **归纳步骤（全称量词）：** 如果 $\\varphi$ 的形式为 $\\forall x\\,\\psi$，其中 $x$ 是一个变量，$\\psi$ 是一个公式，那么 $\\mathsf{FV}(\\forall x\\,\\psi) = \\mathsf{FV}(\\psi) \\setminus \\{x\\}$。\n\n现在，我们使用这些定义来计算公式 $\\exists x\\,\\forall y\\,(x\\cdot z=y)$ 的自由变量集合。我们通过分析公式的结构来进行，从其最内层的部分开始，由内向外分析。\n\n设给定公式为 $\\varphi = \\exists x\\,\\forall y\\,(x\\cdot z=y)$。\n设子公式 $\\forall y\\,(x\\cdot z=y)$ 记作 $\\psi$。\n设原子子公式 $x\\cdot z=y$ 记作 $\\chi$。\n\n**步骤 1：计算 $\\mathsf{FV}(\\chi)$**\n公式 $\\chi$ 是一个原子公式，形式为 $t_1 = t_2$，其中 $t_1$ 是 $x \\cdot z$，$t_2$ 是 $y$。\n根据 $\\mathsf{FV}$ 的定义 (1)，我们有：\n$$ \\mathsf{FV}(x \\cdot z=y) = \\mathsf{Var}(x \\cdot z) \\cup \\mathsf{Var}(y) $$\n我们首先计算项 $x \\cdot z$ 和 $y$ 的 $\\mathsf{Var}$ 集合。\n- 根据 $\\mathsf{Var}$ 的定义 (5)：$\\mathsf{Var}(x \\cdot z) = \\mathsf{Var}(x) \\cup \\mathsf{Var}(z)$。\n- 根据 $\\mathsf{Var}$ 的定义 (1)：$\\mathsf{Var}(x) = \\{x\\}$ 且 $\\mathsf{Var}(z) = \\{z\\}$。\n- 因此，$\\mathsf{Var}(x \\cdot z) = \\{x\\} \\cup \\{z\\} = \\{x, z\\}$。\n- 再次根据 $\\mathsf{Var}$ 的定义 (1)：$\\mathsf{Var}(y) = \\{y\\}$。\n\n将这些结果代回到 $\\mathsf{FV}(\\chi)$ 的表达式中：\n$$ \\mathsf{FV}(\\chi) = \\mathsf{FV}(x \\cdot z=y) = \\{x, z\\} \\cup \\{y\\} = \\{x, y, z\\} $$\n\n**步骤 2：计算 $\\mathsf{FV}(\\psi)$**\n公式 $\\psi$ 是 $\\forall y\\,\\chi$。其形式为 $\\forall y\\,\\dots$，其中 $y$ 是被量化的变量。\n根据 $\\mathsf{FV}$ 的定义 (5)：\n$$ \\mathsf{FV}(\\psi) = \\mathsf{FV}(\\forall y\\,\\chi) = \\mathsf{FV}(\\chi) \\setminus \\{y\\} $$\n使用步骤 1 的结果，$\\mathsf{FV}(\\chi) = \\{x, y, z\\}$：\n$$ \\mathsf{FV}(\\psi) = \\{x, y, z\\} \\setminus \\{y\\} = \\{x, z\\} $$\n\n**步骤 3：计算 $\\mathsf{FV}(\\varphi)$**\n公式 $\\varphi$ 是 $\\exists x\\,\\psi$。其形式为 $\\exists x\\,\\dots$，其中 $x$ 是被量化的变量。\n根据 $\\mathsf{FV}$ 的定义 (4)：\n$$ \\mathsf{FV}(\\varphi) = \\mathsf{FV}(\\exists x\\,\\psi) = \\mathsf{FV}(\\psi) \\setminus \\{x\\} $$\n使用步骤 2 的结果，$\\mathsf{FV}(\\psi) = \\{x, z\\}$：\n$$ \\mathsf{FV}(\\varphi) = \\{x, z\\} \\setminus \\{x\\} = \\{z\\} $$\n\n因此，公式 $\\exists x\\,\\forall y\\,(x\\cdot z=y)$ 中的自由变量集合是 $\\{z\\}$。变量 $z$ 是自由的，因为它不被任何量词约束。变量 $y$ 被全称量词 $\\forall y$ 约束，变量 $x$ 被存在量词 $\\exists x$ 约束。", "answer": "$$ \\boxed{ \\{z\\} } $$", "id": "2974905"}, {"introduction": "在掌握了自由变量和约束变量的概念之后，我们进而探讨代入操作，这是逻辑推理和语义解释中的核心机制。然而，简单的“文本替换”式代入可能导致称为“变量捕获”的严重逻辑错误，即被代入项中的自由变量被公式中已有的量词意外约束。这项练习要求你严格审视几种不同的代入定义，辨别出能够确保避免变量捕获的正确方法，从而深化对一阶逻辑句法精髓的理解 [@problem_id:2974922]。", "problem": "设 $\\mathcal{L}_{\\mathrm{PA}}$ 是皮亚诺算术 (Peano Arithmetic, PA) 的一阶语言，其包含常数符号 $0$、一元函数符号 $S$、二元函数符号 $+$ 和 $\\cdot$ 以及等号 $=$。项是由变量和这些函数符号通过常规的归纳子句构造的。公式是由形如 $t = u$ 的原子公式，使用逻辑联结词 $\\neg$、$\\wedge$、$\\vee$、$\\to$ 和量词 $\\forall$、$\\exists$ 构造的。一个项或公式的自由变量集合记为 $\\mathrm{FV}(\\,\\cdot\\,)$。如果 $z \\notin X$，则称变量 $z$ 对于变量集合 $X$ 是新鲜的 (fresh)。如果两个公式仅因对约束变量的系统性重命名而不同，则称它们是 $\\alpha$-等价的。\n\n我们希望通过结构递归来定义项上的语法替换操作 $t[x:=s]$（读作：在项 $t$ 中用项 $s$ 替换变量 $x$），并将其扩展到公式 $\\varphi[x:=s]$，且此种方式要能避免变量捕获 (variable capture)。避免捕获要求 $s$ 中的任何自由变量，在 $\\varphi[x:=s]$ 中都不会被一个 $\\varphi$ 中已有的量词所约束。\n\n考虑以下候选的子句集。每个选项都为项和公式上的替换提出了一个完整的定义。请选择所有为项的 $t[x:=s]$ 和公式的 $\\varphi[x:=s]$ 给出正确定义，且能保证避免捕获的选项，其正确性需由 $\\mathcal{L}_{\\mathrm{PA}}$ 的归纳语法和约束规则来证明。\n\nA. 项上的替换定义如下：\n- $x[x:=s] = s$ 且若 $y \\neq x$ 则 $y[x:=s] = y$。\n- 如果 $f$ 是一个 $n$-元函数符号，$t_{1},\\dots,t_{n}$ 是项，则 $f(t_{1},\\dots,t_{n})[x:=s] = f(t_{1}[x:=s],\\dots,t_{n}[x:=s])$。\n扩展到公式上：\n- $(t = u)[x:=s] := (t[x:=s] = u[x:=s])$。\n- $(\\neg \\varphi)[x:=s] := \\neg(\\varphi[x:=s])$, $(\\varphi \\circ \\psi)[x:=s] := \\varphi[x:=s] \\circ \\psi[x:=s]$，对于 $\\circ \\in \\{\\wedge,\\vee,\\to\\}$。\n- 对于量词，分情况定义 $(\\forall y\\,\\varphi)[x:=s]$：\n  1. 如果 $y = x$，则 $(\\forall y\\,\\varphi)[x:=s] := \\forall y\\,\\varphi$。\n  2. 如果 $y \\neq x$ 且 $y \\notin \\mathrm{FV}(s)$，则 $(\\forall y\\,\\varphi)[x:=s] := \\forall y\\,(\\varphi[x:=s])$。\n  3. 如果 $y \\neq x$ 且 $y \\in \\mathrm{FV}(s)$，则选择一个对于 $\\mathrm{FV}(\\varphi) \\cup \\mathrm{FV}(s) \\cup \\{x\\}$ 是新鲜的变量 $z$，并令 $(\\forall y\\,\\varphi)[x:=s] := \\forall z\\,\\big(\\varphi[y:=z]\\big)[x:=s]$。\n对 $\\exists$ 作类似处理。\n此定义意在通过仅在必要时重命名约束变量来避免捕获。\n\nB. 项上替换的定义同选项 A。通过纯结构性子句扩展到公式：\n- $(t = u)[x:=s] := (t[x:=s] = u[x:=s])$,\n- $(\\neg \\varphi)[x:=s] := \\neg(\\varphi[x:=s])$, $(\\varphi \\circ \\psi)[x:=s] := \\varphi[x:=s] \\circ \\psi[x:=s]$，对于 $\\circ \\in \\{\\wedge,\\vee,\\to\\}$，\n- $(\\forall y\\,\\varphi)[x:=s] := \\forall y\\,(\\varphi[x:=s])$ 且 $(\\exists y\\,\\varphi)[x:=s] := \\exists y\\,(\\varphi[x:=s])$，\n没有特殊情况，也没有重命名。\n\nC. 项上替换的定义同选项 A。对于公式，首先执行一个依赖于 $s$ 的统一 $\\alpha$-重命名步骤：给定 $\\varphi$，通过将 $\\varphi$ 中的每个约束符 $\\forall y$ 和 $\\exists y$ 同时替换为一个对于 $\\mathrm{FV}(\\varphi) \\cup \\mathrm{FV}(s)$ 是新鲜的变量 $y'$ 上的约束符来构造 $\\mathrm{Norm}_{s}(\\varphi)$，使得 $\\mathrm{Norm}_{s}(\\varphi)$ 与 $\\varphi$ 是 $\\alpha$-等价的，并且 $\\mathrm{Norm}_{s}(\\varphi)$ 中没有被约束的变量出现在 $\\mathrm{FV}(s)$ 中。然后在 $\\mathrm{Norm}_{s}(\\varphi)$ 上通过结构递归定义，\n- $(t = u)[x:=s] := (t[x:=s] = u[x:=s])$,\n- $(\\neg \\varphi)[x:=s] := \\neg(\\varphi[x:=s])$, $(\\varphi \\circ \\psi)[x:=s] := \\varphi[x:=s] \\circ \\psi[x:=s]$，对于 $\\circ \\in \\{\\wedge,\\vee,\\to\\}$,\n- $(\\forall y\\,\\varphi)[x:=s] := \\begin{cases}\\forall y\\,\\varphi & \\text{如果 } y = x,\\\\ \\forall y\\,(\\varphi[x:=s]) & \\text{如果 } y \\neq x,\\end{cases}$\n对 $\\exists$ 作类似处理。此定义旨在通过全局性的新鲜度预处理来避免捕获。\n\nD. 项上替换的定义同选项 A。扩展到公式上：\n- $(t = u)[x:=s] := (t[x:=s] = u[x:=s])$,\n- $(\\neg \\varphi)[x:=s] := \\neg(\\varphi[x:=s])$, $(\\varphi \\circ \\psi)[x:=s] := \\varphi[x:=s] \\circ \\psi[x:=s]$，对于 $\\circ \\in \\{\\wedge,\\vee,\\to\\}$,\n- 对于量词，如果 $y \\neq x$，则 $(\\forall y\\,\\varphi)[x:=s] := \\forall y\\,(\\varphi[x:=s])$，且 $(\\forall x\\,\\varphi)[x:=s] := \\forall x\\,(\\varphi[x:=s])$；对 $\\exists$ 作类似处理，\n其理由是，在 $\\forall x$ 或 $\\exists x$ 下的每个 $x$ 的出现都是“最内层”的，因此可以安全地进行替换。\n\nE. 项上替换的定义同选项 A。扩展到公式时，原子和布尔子句同选项 A，对于量词：\n- 如果 $y=x$，令 $(\\forall y\\,\\varphi)[x:=s] := \\forall y\\,\\varphi$。\n- 如果 $y \\neq x$ 且 $y \\notin \\mathrm{FV}(s)$，令 $(\\forall y\\,\\varphi)[x:=s] := \\forall y\\,(\\varphi[x:=s])$。\n- 如果 $y \\neq x$ 且 $y \\in \\mathrm{FV}(s)$，选择一个对于 $\\mathrm{FV}(s)$ 是新鲜的变量 $z$（但不一定对 $\\mathrm{FV}(\\varphi)$ 新鲜），并令 $(\\forall y\\,\\varphi)[x:=s] := \\forall z\\,\\big(\\varphi[y:=z]\\big)[x:=s]$。\n对 $\\exists$ 作类似处理。\n此定义意在通过重命名来避免捕获，但它只要求 $z \\notin \\mathrm{FV}(s)$。\n\n作为对您选择的健全性检查，考虑 $s \\equiv y$ 和 $\\varphi \\equiv \\forall y\\,(x = y) \\wedge (y = y)$。任何正确的定义都必须确保，在 $\\varphi[x:=s]$ 中，第二个合取项中出现的 $y$ 保持自由（即不被 $\\varphi$ 中引入的或已有的量词所捕获）。\n\n哪些选项是正确的？", "solution": "问题陈述在数理逻辑领域内提供了一个定义明确的问题。它要求为一阶语言中的公式给出避免捕获的语法替换的正确定义。所使用的所有术语都是标准的，目标也阐述得很清楚。该问题具有科学依据，提法恰当且客观。因此，该问题是有效的。\n\n任务是评估替换操作 $\\varphi[x:=s]$ 的五个提议的定义，该操作将公式 $\\varphi$ 中变量 $x$ 的所有自由出现替换为项 $s$。一个正确的定义必须避免“变量捕获”，即 $s$ 中的一个自由变量被 $\\varphi$ 中的量词所约束。所有选项对项上的替换 $t[x:=s]$ 都使用了相同的标准且正确的定义。因此，分析将集中于针对公式的子句，特别是针对量化公式的子句。\n\n对于一个量化公式 $(\\forall y\\,\\psi)[x:=s]$，避免捕获的替换的一般形式如下：\n1.  如果 $x=y$，替换变量 $x$ 被量词 $\\forall y$ 约束。在 $\\psi$ 中没有需要被替换的 $x$ 的自由出现。因此，$(\\forall x\\,\\psi)[x:=s] = \\forall x\\,\\psi$。\n2.  如果 $x \\neq y$ 且 $x$ 在 $\\psi$ 中不是自由变量，则没有什么需要替换的。所以 $(\\forall y\\,\\psi)[x:=s] = \\forall y\\,\\psi$。\n3.  如果 $x \\neq y$，$x$ 在 $\\psi$ 中是自由的，并且约束变量 $y$ 在项 $s$ 中不是自由变量（即 $y \\notin \\mathrm{FV}(s)$），那么不会发生捕获。替换可以递归地进行：$(\\forall y\\,\\psi)[x:=s] = \\forall y\\,(\\psi[x:=s])$。\n4.  如果 $x \\neq y$，$x$ 在 $\\psi$ 中是自由的，且 $y \\in \\mathrm{FV}(s)$，那么一个朴素的替换将导致捕获。为避免此情况，约束变量 $y$ 必须重命名为一个新鲜变量 $z$。一个安全的选择要求 $z$ 对于 $\\psi$ 和 $s$ 中的变量是新鲜的。然后对这个 $\\alpha$-等价的公式执行替换：$(\\forall y\\,\\psi)[x:=s] = (\\forall z\\,(\\psi[y:=z]))[x:=s]$。由于 $z$ 被选择为不同于 $x$ 且不在 $\\mathrm{FV}(s)$ 中，这便归结为情况 3：$\\forall z\\,((\\psi[y:=z])[x:=s])$。\n\n我们现在在此背景下评估每个选项。\n\n### 选项 A 分析\n该选项通过考虑三种情况来定义 $(\\forall y\\,\\varphi)[x:=s]$ 的替换：\n1.  如果 $y = x$：$(\\forall y\\,\\varphi)[x:=s] := \\forall y\\,\\varphi$。这是正确的，如上文第1点所述。\n2.  如果 $y \\neq x$ 且 $y \\notin \\mathrm{FV}(s)$：$(\\forall y\\,\\varphi)[x:=s] := \\forall y\\,(\\varphi[x:=s])$。这是非捕获情况（上文第3点），并且是正确的。\n3.  如果 $y \\neq x$ 且 $y \\in \\mathrm{FV}(s)$：$(\\forall y\\,\\varphi)[x:=s] := \\forall z\\,\\big(\\varphi[y:=z]\\big)[x:=s]$，其中 $z$ 被选择为对于 $\\mathrm{FV}(\\varphi) \\cup \\mathrm{FV}(s) \\cup \\{x\\}$ 是新鲜的。这是避免捕获的重命名步骤。$z$ 的新鲜度条件确保了：\n    -   $z \\notin \\mathrm{FV}(\\varphi)$：重命名 $\\varphi[y:=z]$ 不会捕获 $\\varphi$ 中任何已有的自由变量。\n    -   $z \\notin \\mathrm{FV}(s)$：当项 $s$ 被替换 $x$ 时，新的量词 $\\forall z$ 不会捕获 $s$ 中的任何自由变量。\n    -   $z \\neq x$：新的约束变量 $z$ 不是被替换的变量。\n    这个过程正是避免捕获的替换的标准、正确的定义，如上文第4点所述。\n\n结论：选项 A 提供了一个正确且完整的避免捕获的替换定义。\n**评定：正确**\n\n### 选项 B 分析\n此选项提出了一个纯结构性的，或“朴素的”替换：在所有情况下 $(\\forall y\\,\\varphi)[x:=s] := \\forall y\\,(\\varphi[x:=s])$（这隐含地假设 $y \\neq x$ 是唯一值得关注的情况，因为如果 $y=x$，右侧的 $\\varphi[x:=s]$ 对被约束的 $x$ 不会产生影响）。这个定义未能处理捕获的情况。\n\n为证明其错误，考虑公式 $\\psi \\equiv \\exists y\\,(x \\neq y)$ 和替换 $[x:=y]$。这里，$s \\equiv y$ 且 $\\mathrm{FV}(s) = \\{y\\}$。在一个至少有两个元素的模型中（例如，标准的算术模型），对于 $x$ 的任何解释，公式 $\\psi$ 都为真。替换后应得到一个同样为真的公式。\n根据选项 B，$(\\exists y\\,(x \\neq y))[x:=y] = \\exists y\\,((x \\neq y)[x:=y])$。内部的替换得到 $(y \\neq y)$，所以最终的公式是 $\\exists y\\,(y \\neq y)$。这个公式在任何模型中都为假。公式的含义被根本性地改变了，因为项 $s$ 中的自由变量 $y$ 被 $\\exists y$ 量词“捕获”了。\n\n问题中提供的健全性检查，即 $\\varphi \\equiv \\forall y\\,(x = y) \\wedge (y = y)$ 配合 $s \\equiv y$，不足以排除这个选项。该公式被解析为 $(\\forall y\\,(x = y)) \\wedge (y = y)$。替换产生 $(\\forall y\\,(y=y)) \\wedge (y=y)$。第二个合取项中出现的 $y$ 保持自由，因为它们的作用域在量词之外。健全性检查通过了，但如另一个例子所示，该定义是无效的。\n\n结论：选项 B 定义了朴素替换，这是不正确的，因为它不避免变量捕获。\n**评定：不正确**\n\n### 选项 C 分析\n该选项提出了一个两阶段过程：首先，对 $\\varphi$ 中所有约束变量进行 $\\alpha$-重命名，使它们相对于替换是“新鲜的”，然后应用一个更简单的替换规则。\n1.  **规范化**：对于给定的 $\\varphi$ 和 $s$，通过将 $\\varphi$ 中所有约束变量重命名为对于 $\\mathrm{FV}(\\varphi) \\cup \\mathrm{FV}(s)$ 是新鲜的变量，来构造 $\\mathrm{Norm}_s(\\varphi)$。这将生成一个与 $\\varphi$ $\\alpha$-等价的公式，其中对于任何子公式 $\\forall y' \\psi'$，我们可以保证 $y' \\notin \\mathrm{FV}(s)$。\n2.  **替换**：对 $\\mathrm{Norm}_s(\\varphi)$ 应用一个简化的递归定义。对于一个量词 $(\\forall y\\,\\psi)[x:=s]$，规则是如果 $y=x$ 则为 $\\forall y\\,\\psi$，如果 $y \\neq x$ 则为 $\\forall y\\,(\\psi[x:=s])$。\n\n这个方法是正确的。规范化步骤预先解决了所有潜在的捕获冲突。由于 $\\mathrm{Norm}_s(\\varphi)$ 中的所有约束变量都保证不在 $\\mathrm{FV}(s)$ 中，简化的递归规则 $\\forall y\\,(\\psi[x:=s])$ 可以安全应用（它总是属于非捕获情况）。这个方法是选项 A 中“即时”重命名方法的一个有效替代方案。\n\n结论：选项 C 提供了一个避免捕获的替换的正确定义，尽管在程序上有所不同。\n**评定：正确**\n\n### 选项 D 分析\n此选项对量词的定义是：如果 $y \\neq x$，则 $(\\forall y\\,\\varphi)[x:=s] := \\forall y\\,(\\varphi[x:=s])$，且 $(\\forall x\\,\\varphi)[x:=s] := \\forall x\\,(\\varphi[x:=s])$。第二种情况是正确的，但第一种情况正是选项 B 中的朴素替换子句。它不检查 $y \\in \\mathrm{FV}(s)$，因此无法防止捕获。选项中提供的理由与问题所在的 $y \\neq x$ 情况无关。此选项与选项 B 出于同样的原因是不正确的。\n\n结论：选项 D 是有缺陷的朴素替换的重述，因此是不正确的。\n**评定：不正确**\n\n### 选项 E 分析\n该选项是选项 A 的一个变体，但在避免捕获的情况下，其新鲜度条件较弱。对于 $y \\neq x$ 且 $y \\in \\mathrm{FV}(s)$ 的情况，它将约束变量 $y$ 重命名为一个新变量 $z$，该变量只被要求对于 $\\mathrm{FV}(s)$ 是新鲜的。它不要求 $z$ 对于 $\\mathrm{FV}(\\varphi)$ 或 $\\{x\\}$ 是新鲜的。这是不够的。\n\n我们来构造一个反例。设 $\\varphi \\equiv \\forall y\\,(x=y)$。我们想计算 $\\varphi[x := y+z]$。这里，$s \\equiv y+z$，所以 $\\mathrm{FV}(s) = \\{y, z\\}$。约束变量是 $y$。由于 $y \\in \\mathrm{FV}(s)$，我们处于情况 3。根据选项 E，我们必须选择一个新的约束变量，称之为 $z_{\\text{new}}$，使得 $z_{\\text{new}}$ 对于 $\\mathrm{FV}(s) = \\{y, z\\}$ 是新鲜的。规则并不禁止选择 $z_{\\text{new}} = x$，因为 $x \\notin \\{y,z\\}$。我们就做此选择。\n该定义指出结果是 $\\forall z_{\\text{new}}\\,\\big((\\varphi'[y:=z_{\\text{new}}])[x:=s]\\big)$，其中 $\\varphi' = (x=y)$。当 $z_{\\text{new}} = x$ 时，这变成 $\\forall x\\,\\big(((x=y)[y:=x])[x:=y+z]\\big)$。\n- 内部的替换 $(x=y)[y:=x]$ 结果为 $(x=x)$。\n- 表达式变为 $(\\forall x\\,(x=x))[x:=y+z]$。\n- 现在我们应用替换 $[x:=y+z]$。替换变量 $x$ 被量词 $\\forall x$ 约束。这是情况 1，公式保持不变。\n- 最终结果是 $\\forall x\\,(x=x)$。这是一个逻辑真理。\n\n我们用选项 A 来计算正确的结果。我们需要一个对于 $\\mathrm{FV}(\\varphi) \\cup \\mathrm{FV}(s) \\cup \\{x\\}$ 是新鲜的新变量 $z_{\\text{new}}$。$\\mathrm{FV}(\\varphi) = \\{x\\}$，$\\mathrm{FV}(s) = \\{y,z\\}$。需要避免的变量集合是 $\\{x,y,z\\}$。我们选择 $w$。\n结果是 $\\forall w\\,\\big(((x=y)[y:=w])[x:=y+z]\\big)$。\n- $(x=y)[y:=w]$ 得到 $(x=w)$。\n- 表达式变为 $(\\forall w\\,(x=w))[x:=y+z]$。\n- 对于这个替换，约束变量是 $w \\neq x$，并且 $w \\notin \\mathrm{FV}(y+z) = \\{y,z\\}$。所以这是情况 2。\n- 结果是 $\\forall w\\,((x=w)[x:=y+z])$。\n- 内部替换得到 $(y+z=w)$。\n- 正确的结果是 $\\forall w\\,(y+z=w)$。\n\n从选项 E 得到的结果 $\\forall x\\,(x=x)$ 是一个重言式。而正确的结果 $\\forall w\\,(y+z=w)$ 是一个偶然公式，在标准算术模型中对于任何给定的 $y,z$ 都为假。两者不等价。选项 E 中不充分的新鲜度条件导致了语义上不正确的结果。\n\n结论：选项 E 的新鲜度条件太弱，导致了不正确的替换。\n**评定：不正确**", "answer": "$$\\boxed{AC}$$", "id": "2974922"}, {"introduction": "掌握了变量和代入的句法操作后，我们现在可以将这些工具应用于皮亚诺算术最强大的公理——归纳模式。归纳模式并非单一公理，而是一个公理的无穷集合，它允许我们为语言中的任何性质陈述归纳法。这个练习的核心任务是将一个抽象的性质（如此处的 $x+x=x$）精确地翻译成归纳模式的一个具体实例，这充分展示了如何将元数学的原理转化为严格的形式化语句 [@problem_id:2974923]。", "problem": "您在皮亚诺算术（PA）的一阶语言（记为 $L_{PA}$）中工作，其非逻辑符号包括常量 $0$、表示后继的一元函数符号 $S$、二元函数符号 $+$ 和 $\\cdot$、以及二元关系符号 $\\leq$。皮亚诺算术（PA）的归纳模式适用于任何含有一个自由变量 $x$ 的 $L_{PA}$-公式 $\\varphi(x)$，并产生一个 $L_{PA}$-句子，其非形式化的部分被称为基本情形和归纳步骤。仅使用 $L_{PA}$ 符号（即，不使用除 $0$ 之外的数码或算术简写等缩写），考虑特定的 $L_{PA}$-公式 $\\varphi(x)\\equiv x + x = x$。哪个选项正确地给出了该 $\\varphi(x)$ 的归纳模式实例的单一 $L_{PA}$-句子，以及相应的基本情形和归纳步骤，两者都表示为不含缩写的 $L_{PA}$-公式？\n\nA. 归纳实例：\n$((0+0=0)\\wedge \\forall x\\,((x+x=x)\\rightarrow(S(x)+S(x)=S(x))))\\rightarrow \\forall x\\,(x+x=x)$\n基本情形：$0+0=0$\n归纳步骤：$\\forall x\\,((x+x=x)\\rightarrow(S(x)+S(x)=S(x)))$\n\nB. 归纳实例：\n$((0+0=0)\\wedge \\forall x\\,((S(x)+S(x)=S(x))\\rightarrow(x+x=x)))\\rightarrow \\forall x\\,(x+x=x)$\n基本情形：$0+0=0$\n归纳步骤：$\\forall x\\,((S(x)+S(x)=S(x))\\rightarrow(x+x=x))$\n\nC. 归纳实例：\n$((1+1=1)\\wedge \\forall x\\,((x+x=x)\\rightarrow(x+1=x)))\\rightarrow \\forall x\\,(x+x=x)$\n基本情形：$1+1=1$\n归纳步骤：$\\forall x\\,((x+x=x)\\rightarrow(x+1=x))$\n\nD. 归纳实例：\n$((0+0=0)\\wedge \\forall x\\,((x+x=x)\\rightarrow(x+S(x)=x)))\\rightarrow \\forall x\\,(x+x=x)$\n基本情形：$0+0=0$\n归纳步骤：$\\forall x\\,((x+x=x)\\rightarrow(x+S(x)=x))$\n\nE. 归纳实例：\n$(0+0=0\\rightarrow \\forall x\\,(x+x=x))\\wedge \\forall x\\,((x+x=x)\\rightarrow(S(x)+S(x)=S(x)))$\n基本情形：$0+0=0$\n归纳步骤：$\\forall x\\,((x+x=x)\\rightarrow(S(x)+S(x)=S(x)))$", "solution": "用户要求对问题陈述进行严格验证，然后给出详细的解决方案并对所提供的选项进行评估。\n\n### 问题验证\n\n**步骤1：提取已知条件**\n- 语言是皮亚诺算术的一阶语言 $L_{PA}$。\n- $L_{PA}$ 的非逻辑符号是：常量 $0$、一元函数符号 $S$、二元函数符号 $+$ 和 $\\cdot$、以及二元关系符号 $\\leq$。\n- 皮亚诺算术（PA）的归纳模式适用于任何含有一个自由变量 $x$ 的 $L_{PA}$-公式 $\\varphi(x)$。\n- 归纳模式的实例是一个由基本情形和归纳步骤组成的 $L_{PA}$-句子。\n- 要使用的具体 $L_{PA}$-公式是 $\\varphi(x) \\equiv x + x = x$。\n- 任务是确定此归纳模式实例的正确 $L_{PA}$-句子，以及其组成部分——基本情形和归纳步骤，仅使用 $L_{PA}$ 符号，不含缩写。\n\n**步骤2：使用提取的已知条件进行验证**\n- **科学基础（关键）：** 该问题完全位于数理逻辑的形式框架内，具体来说是一阶算术。语言 $L_{PA}$、皮亚诺公理和归纳模式都是标准的、明确定义的概念。该问题在科学上和数学上是合理的。\n- **良构性：** 该问题是良构的。归纳模式有精确的句法定义。给定一个特定的公式 $\\varphi(x)$，其归纳公理的相应实例是唯一确定的。\n- **客观性（关键）：** 该问题以精确、形式化的语言陈述，没有歧义或主观性。\n\n基于此分析，问题陈述没有科学不合理、歧义或信息缺失等缺陷。这是一个有效的、定义明确的数理逻辑问题。\n\n**步骤3：结论与行动**\n该问题是**有效的**。现在将进行求解过程。\n\n### 解题推导\n\n皮亚诺算术中的归纳模式指出，对于语言 $L_{PA}$ 中任何含有一个自由变量 $x$ 的公式 $\\varphi(x)$，以下句子是一个公理：\n$$(\\varphi(0) \\wedge \\forall x (\\varphi(x) \\rightarrow \\varphi(S(x)))) \\rightarrow \\forall x \\varphi(x)$$\n\n这个句子就是“归纳实例”。让我们根据题目的要求将其分解为各个组成部分：\n1.  **基本情形：** 公式 $\\varphi(0)$，它断言性质 $\\varphi$ 对数字 $0$ 成立。\n2.  **归纳步骤：** 公式 $\\forall x (\\varphi(x) \\rightarrow \\varphi(S(x)))$，它断言对于任何数字 $x$，如果性质 $\\varphi$ 对 $x$ 成立，那么它也对其后继 $S(x)$ 成立。\n3.  **结论：** 公式 $\\forall x \\varphi(x)$，它断言性质 $\\varphi$ 对所有数字都成立。\n\n问题给出了特定的公式 $\\varphi(x) \\equiv x + x = x$。我们现在将这个公式代入通用模式中。\n\n-   **求基本情形 $\\varphi(0)$：**\n    我们将 $\\varphi(x)$ 中所有自由出现的 $x$ 替换为常量符号 $0$。\n    代入 $x + x = x$，我们得到：\n    $$0 + 0 = 0$$\n\n-   **求归纳步骤 $\\forall x (\\varphi(x) \\rightarrow \\varphi(S(x)))$：**\n    这需要两个子部分：$\\varphi(x)$ 和 $\\varphi(S(x))$。\n    -   $\\varphi(x)$ 就是给定的公式：$x + x = x$。\n    -   $\\varphi(S(x))$ 是通过将 $\\varphi(x)$ 中所有自由出现的 $x$ 替换为项 $S(x)$ 得到的。\n        代入 $x + x = x$，我们得到：\n        $$S(x) + S(x) = S(x)$$\n    -   现在，我们构造蕴涵式 $\\varphi(x) \\rightarrow \\varphi(S(x))$：\n        $$(x + x = x) \\rightarrow (S(x) + S(x) = S(x))$$\n    -   最后，我们对 $x$ 进行全称量化，以形成完整的归纳步骤：\n        $$\\forall x ((x + x = x) \\rightarrow (S(x) + S(x) = S(x)))$$\n\n-   **求结论 $\\forall x \\varphi(x)$：**\n    我们对原始公式进行全称量化：\n    $$\\forall x (x + x = x)$$\n\n-   **组装完整的归纳实例：**\n    我们根据模式 $(\\varphi(0) \\wedge \\text{归纳步骤}) \\rightarrow \\text{结论}$ 组合这些部分：\n    $$((0 + 0 = 0) \\wedge \\forall x ((x + x = x) \\rightarrow (S(x) + S(x) = S(x)))) \\rightarrow \\forall x (x + x = x)$$\n\n我们现在已经推导出了所需的三个组成部分：\n-   **归纳实例：** $((0 + 0 = 0) \\wedge \\forall x ((x + x = x) \\rightarrow (S(x) + S(x) = S(x)))) \\rightarrow \\forall x (x + x = x)$\n-   **基本情形：** $0 + 0 = 0$\n-   **归纳步骤：** $\\forall x ((x + x = x) \\rightarrow (S(x) + S(x) = S(x)))$\n\n现在我们将根据这个结果评估每个选项。\n\n### 逐项分析\n\n**A. 归纳实例：**\n$((0+0=0)\\wedge \\forall x\\,((x+x=x)\\rightarrow(S(x)+S(x)=S(x))))\\rightarrow \\forall x\\,(x+x=x)$\n**基本情形：** $0+0=0$\n**归纳步骤：** $\\forall x\\,((x+x=x)\\rightarrow(S(x)+S(x)=S(x)))$\n-   这个选项与我们推导出的归纳实例、基本情形和归纳步骤完全匹配。所有公式都根据归纳模式和给定的 $\\varphi(x)$ 被正确地构造出来。\n-   **结论：** 正确。\n\n**B. 归纳实例：**\n$((0+0=0)\\wedge \\forall x\\,((S(x)+S(x)=S(x))\\rightarrow(x+x=x)))\\rightarrow \\forall x\\,(x+x=x)$\n**基本情形：** $0+0=0$\n**归纳步骤：** $\\forall x\\,((S(x)+S(x)=S(x))\\rightarrow(x+x=x))$\n-   基本情形是正确的。然而，在归纳步骤中，蕴涵关系被颠倒了。它陈述的是 $\\varphi(S(x)) \\rightarrow \\varphi(x)$，而不是正确的 $\\varphi(x) \\rightarrow \\varphi(S(x))$。这从根本上改变了数学归纳法的逻辑结构。\n-   **结论：** 不正确。\n\n**C. 归纳实例：**\n$((1+1=1)\\wedge \\forall x\\,((x+x=x)\\rightarrow(x+1=x)))\\rightarrow \\forall x\\,(x+x=x)$\n**基本情形：** $1+1=1$\n**归纳步骤：** $\\forall x\\,((x+x=x)\\rightarrow(x+1=x))$\n-   这个选项违反了只能使用 $L_{PA}$ 符号、不使用缩写的约束。数码 $1$ 是 $S(0)$ 的缩写，并非 $L_{PA}$ 中的符号。此外，基本情形必须是 $\\varphi(0)$，即 $0+0=0$，而不是 $1+1=1$。用于 $\\varphi(S(x))$ 的公式也是错误的；它应该是 $S(x)+S(x)=S(x)$，而不是 $x+1=x$。\n-   **结论：** 不正确。\n\n**D. 归纳实例：**\n$((0+0=0)\\wedge \\forall x\\,((x+x=x)\\rightarrow(x+S(x)=x)))\\rightarrow \\forall x\\,(x+x=x)$\n**基本情形：** $0+0=0$\n**归纳步骤：** $\\forall x\\,((x+x=x)\\rightarrow(x+S(x)=x))$\n-   基本情形是正确的。然而，意图表示 $\\varphi(S(x))$ 的公式被写成了 $x+S(x)=x$。正确地将 $x+x=x$ 中所有自由出现的 $x$ 替换为 $S(x)$ 应该得到 $S(x)+S(x)=S(x)$。该选项中的公式是一个不正确的替换。\n-   **结论：** 不正确。\n\n**E. 归纳实例：**\n$(0+0=0\\rightarrow \\forall x\\,(x+x=x))\\wedge \\forall x\\,((x+x=x)\\rightarrow(S(x)+S(x)=S(x)))$\n**基本情形：** $0+0=0$\n**归纳步骤：** $\\forall x\\,((x+x=x)\\rightarrow(S(x)+S(x)=S(x)))$\n-   被确定为基本情形和归纳步骤的公式本身在句法上是正确的。但是，归纳实例的主要逻辑结构是错误的。正确的形式是 $(P \\wedge Q) \\rightarrow R$，其中 $P$ 是基本情形， $Q$ 是归纳步骤， $R$ 是结论。这个选项呈现的形式是 $(P \\rightarrow R) \\wedge Q$。这不是归纳公理。\n-   **结论：** 不正确。", "answer": "$$\\boxed{A}$$", "id": "2974923"}]}