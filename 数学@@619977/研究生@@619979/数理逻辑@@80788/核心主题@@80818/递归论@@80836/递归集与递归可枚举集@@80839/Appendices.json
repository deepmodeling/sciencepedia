{"hands_on_practices": [{"introduction": "要严格研究递归集和递归可枚举集，第一步是将“计算”这一直观概念用形式化语言来精确表达。本练习将指导你使用一阶算术语言，基于给定的原始递归关系，构造出表达“图灵机停机”及其否定的公式 ([@problem_id:2986081])。通过这个过程，你将揭示停机问题集及其补集最基本的逻辑结构，并理解它们如何分别对应于算术谱系中的 $\\Sigma_1$ 类和 $\\Pi_1$ 类，为后续更深入的探索奠定基础。", "problem": "设 $N$ 表示自然数集合，我们在带有符号 $0$、后继、加法和乘法的一阶算术语言中进行工作。固定一种确定性图灵机的有效哥德尔编码，使得每台机器和每个配置都由 $N$ 中的一个数表示。假定以下可计算性理论和算术化的基础事实，你可以不加证明地使用它们：\n\n- 存在一个原始递归关系 $R(e,x,t,y)$，它当且仅当 $y$ 是由 $e$ 编码的机器在输入 $x$ 上精确运行 $t$ 步的完整计算历史（例如，一个有限的表或配置序列）的编码，并且这个历史相对于该机器的转移函数是正确的时，为真。\n- 存在一个原始递归关系 $H_{\\mathrm{fin}}(e,x,t,y)$，它当且仅当 $R(e,x,t,y)$ 为真且 $y$ 中编码的最后一个配置是停机状态（即，该机器在时间 $t$ 之前已进入一个指定的停机状态）时，为真。\n- 一个母式为原始递归关系且其量词范围为 $N$ 的公式可以被置于前束范式；它在算术分层中的级别由前导无界量词的模式决定：一个 $\\Sigma_{n}$-公式有一个前导的存在量词块，后跟 $n-1$ 次交替；一个 $\\Pi_{n}$-公式有一个前导的全称量词块，后跟 $n-1$ 次交替，所有这些都带有一个可判定（原始递归）的母式。\n\n仅使用这些基础：\n\n1. 构造一个一阶算术公式 $H(e,x)$，该公式表达“由 $e$ 编码的机器在输入 $x$ 上停机”。使用 $R$ 和 $H_{\\mathrm{fin}}$ 作为你的可判定母式。将你的公式置于前束范式，并明确指出其前导量词块和母式。\n\n2. 构造一个一阶算术公式 $NH(e,x)$，该公式表达“由 $e$ 编码的机器在输入 $x$ 上不停机”。同样只使用在 $N$ 上的量化和一个由 $R$ 和 $H_{\\mathrm{fin}}$ 构建的可判定母式。将你的公式置于前束范式，并明确指出其前导量词块和母式。\n\n3. 对于 $H(e,x)$ 和 $NH(e,x)$ 中的每一个，确定其最小算术分层级别 $L(\\cdot)$，定义如下：如果一个公式（在标准算术模型上）等价于一个具有不少于 $n$ 次交替的 $\\Sigma_{n}$-公式，则取 $L$ 为 $n$；如果它等价于一个具有不少于 $n$ 次交替的 $\\Pi_{n}$-公式，则取 $L$ 为 $n$。通过分析量词结构和母式的可判定性来证明你的分类。\n\n4. 计算 $L(H)+L(NH)$ 的精确整数值。将你的最终答案报告为一个精确的整数。无需四舍五入。", "solution": "该问题要求基于所提供的原始递归关系，为停机问题及其补集构造一阶算术公式并对其进行分类。\n\n**问题验证**\n\n首先对问题陈述进行验证。\n\n*   **步骤 1：提取已知条件**\n    *   论域：自然数集合 $N$。\n    *   语言：带符号 $0$、后继、加法和乘法的一阶算术。\n    *   哥德尔编码 (Gödel Coding)：一种有效的编码方案，将图灵机及其配置映射到 $N$ 中的数。\n    *   原始递归关系 $R(e,x,t,y)$：当且仅当 $y$ 是机器 $e$ 在输入 $x$ 上精确运行 $t$ 步的正确计算历史的编码时，该关系为真。\n    *   原始递归关系 $H_{\\mathrm{fin}}(e,x,t,y)$：当且仅当 $R(e,x,t,y)$ 为真且计算在第 $t$ 步处于停机状态时，该关系为真。\n    *   算术分层定义：如果一个公式有一个前导的存在量词块，后跟 $n-1$ 次量词交替，并且母式是可判定的，则该公式是 $\\Sigma_n$ 公式。如果一个公式有一个前导的全称量词块，后跟 $n-1$ 次量词交替，并且母式是可判定的，则该公式是 $\\Pi_n$ 公式。\n    *   级别 $L(\\cdot)$：最小的 $n \\in N, n \\ge 1$，使得一个公式等价于一个 $\\Sigma_n$ 或 $\\Pi_n$ 公式。\n\n*   **步骤 2：使用提取的已知条件进行验证**\n    该问题是可计算性理论和数理逻辑中的一个标准练习。它在科学上植根于计算的形式化（丘奇-图灵论题）及其与形式算术的关系（由 Gödel、Kleene 等人建立）。所有术语都有精确定义，前提是该领域的标准结果。该问题是适定的、客观的、自洽的，没有明显的逻辑矛盾、歧义或事实错误。\n\n*   **步骤 3：结论与行动**\n    问题被认定为有效。有必要提供完整解答。\n\n**第一部分：构造公式 $H(e,x)$**\n\n断言“由 $e$ 编码的机器在输入 $x$ 上停机”为真，当且仅当存在一个时间 $t \\in N$ 和一个相应的计算历史 $y \\in N$ 来表示一个有效的、停机的计算。谓词 $H_{\\mathrm{fin}}(e,x,t,y)$ 捕捉了特定时间 $t$ 和历史 $y$ 的这种情况。为了表达停机发生在*某个*时间，我们对 $t$ 和 $y$ 进行存在量化。\n\n因此，公式 $H(e,x)$ 是：\n$$H(e,x) \\equiv \\exists t \\exists y \\, H_{\\mathrm{fin}}(e,x,t,y)$$\n该公式是前束范式。\n*   **前导量词块：** $\\exists t \\exists y$。这是一个单一的存在量词块。\n*   **母式：** $H_{\\mathrm{fin}}(e,x,t,y)$。问题陈述此关系是原始递归的。根据定义，原始递归关系可由图灵机判定。因此，该母式是可判定的。\n\n**第二部分：构造公式 $NH(e,x)$**\n\n断言“由 $e$ 编码的机器在输入 $x$ 上不停机”是 $H(e,x)$ 的逻辑否定。\n$$NH(e,x) \\equiv \\neg H(e,x)$$\n我们代入 $H(e,x)$ 的表达式，并通过应用量词对偶规则（$\\neg \\exists z P(z) \\equiv \\forall z \\neg P(z)$）将结果公式转换为前束范式。\n$$NH(e,x) \\equiv \\neg (\\exists t \\exists y \\, H_{\\mathrm{fin}}(e,x,t,y))$$\n$$\\equiv \\forall t \\, \\neg (\\exists y \\, H_{\\mathrm{fin}}(e,x,t,y))$$\n$$\\equiv \\forall t \\forall y \\, \\neg H_{\\mathrm{fin}}(e,x,t,y)$$\n$NH(e,x)$ 的前束范式是：\n$$NH(e,x) \\equiv \\forall t \\forall y \\, \\neg H_{\\mathrm{fin}}(e,x,t,y)$$\n*   **前导量词块：** $\\forall t \\forall y$。这是一个单一的全称量词块。\n*   **母式：** $\\neg H_{\\mathrm{fin}}(e,x,t,y)$。由于 $H_{\\mathrm{fin}}$ 是一个可判定关系，其否定 $\\neg H_{\\mathrm{fin}}$ 也是可判定的。\n\n**第三部分：算术分层分类**\n\n我们确定每个公式的最小级别 $L(\\cdot)$。\n\n**$H(e,x)$ 的分类：**\n公式 $H(e,x)$ 有一个前导的存在量词块和一个可判定的母式。这种结构对应于一个 $\\Sigma_1$-公式。满足 $H(e,x)$ 的数对 $(e,x)$ 的集合是停机集，已知它是不可判定的。一个集合是可判定的，当且仅当它可由一个 $\\Delta_1$ 公式（等价于既是 $\\Sigma_1$ 又是 $\\Pi_1$ 公式）定义，这又等价于有一个无量词的定义（一个在可判定语言上的 $\\Sigma_0$ 或 $\\Pi_0$ 公式）。由于停机集是不可判定的，它不能由 $\\Sigma_0$ 公式定义。因此，其最小分类是 $\\Sigma_1$。\n这意味着 $L(H) = 1$。\n\n**$NH(e,x)$ 的分类：**\n公式 $NH(e,x)$ 有一个前导的全称量词块和一个可判定的母式。这种结构对应于一个 $\\Pi_1$-公式。满足 $NH(e,x)$ 的数对 $(e,x)$ 的集合是停机集的补集。\n1.  这个集合是不可判定的，因为如果它是可判定的，那么它的补集（停机集）也将是可判定的，这是一个已知的谬误。因此，它不可能是 $\\Sigma_0$ 或 $\\Pi_0$ 集。\n2.  我们还必须证明它不是一个 $\\Sigma_1$ 集。一个集合可由 $\\Sigma_1$ 公式定义，当且仅当它是递归可枚举的。停机集（由 $H(e,x)$ 定义）是一个 $\\Sigma_1$-集，因此它是递归可枚举的。根据 Post 定理，一个集合是可判定的（递归的），当且仅当该集合及其补集都是递归可枚举的。如果停机集的补集也是递归可枚举的（即 $\\Sigma_1$），那么停机集就将是可判定的。这是一个矛盾。\n因此，由 $NH(e,x)$ 定义的集合不是 $\\Sigma_1$。其最简单的分类是 $\\Pi_1$。\n这意味着 $L(NH) = 1$。\n\n**第四部分：最终计算**\n\n问题要求计算 $L(H) + L(NH)$ 的值。使用第三部分的结果：\n$$L(H) = 1$$\n$$L(NH) = 1$$\n和为：\n$$L(H) + L(NH) = 1 + 1 = 2$$", "answer": "$$\\boxed{2}$$", "id": "2986081"}, {"introduction": "在建立了算术谱系的基础层级后，我们可以开始探索递归可枚举集更复杂的性质。本练习 ([@problem_id:2984438]) 关注一个重要的例子：那些“补集为有限”的递归可枚举集（即余有限集）。通过分析定义这类集合的公式，你将看到更复杂的量词交替结构（如 $\\exists\\forall\\exists$）是如何自然产生的，并学习如何将其精确定位在算术谱系中的更高层级（$\\Sigma_3$），从而加深对逻辑复杂性与计算性质之间对应关系的理解。", "problem": "设语言为一阶算术，其符号包括 $0$, $1$, $+$, $\\times$ 和 $\\leq$。通过 Kleene 的 $\\mathcal{T}$-谓词，固定一种图灵机及其计算的原始递归编码：存在一个原始递归关系 $H(e,x,s)$，表示索引为 $e$ 的图灵机在输入 $x$ 上至多 $s$ 步内停机。考虑自然数上的一元谓词，由以下公式定义\n$$\n\\Theta(e)\\;:\\;\\exists m\\;\\forall x\\;\\exists s\\;\\big(x<m\\;\\lor\\;H(e,x,s)\\big).\n$$\n所有量词都是无界的；母体（matrix）内的析取是在有界不等式 $x<m$ 和原始递归谓词 $H(e,x,s)$ 之间。\n\n仅使用算术层级的核心定义、有界量词不增加算术复杂性这一事实，以及原始递归关系在布尔联结词下的基本闭包性质，确定最小的自然数 $n$，使得 $\\Theta$ 在标准模型 $\\mathbb{N}$ 上等价于一个 $\\Sigma_{n}$-公式或一个 $\\Pi_{n}$-公式。你必须证明其上界（即 $\\Theta$ 属于某个固定的层级）和下界（即在任何严格更低的非平凡层级中不存在等价公式）。\n\n最终答案只报告最小的 $n$。无需四舍五入。", "solution": "该问题是有效的，因为它是可计算性理论和数理逻辑领域内一个适定 (well-posed) 的问题，依赖于标准定义（算术层级，Kleene 的 $\\mathcal{T}$-谓词），并且没有不一致或歧义之处。\n\n任务是找到最小的自然数 $n$，使得谓词 $\\Theta(e)$ 等价于一个 $\\Sigma_n$ 或 $\\Pi_n$ 公式。该谓词定义为：\n$$\n\\Theta(e)\\;:\\;\\exists m\\;\\forall x\\;\\exists s\\;\\big(x<m\\;\\lor\\;H(e,x,s)\\big)\n$$\n其中 $H(e,x,s)$ 是一个原始递归关系，表示哥德尔数（Gödel number）为 $e$ 的图灵机在输入 $x$ 上于 $s$ 步内停机。\n\n首先，我们分析 $\\Theta(e)$ 公式背后的逻辑结构和含义。\n我们来分析对于一个固定的 $m$，子公式 $\\forall x\\;\\exists s\\;\\big(x<m\\;\\lor\\;H(e,x,s)\\big)$。我们可以将对 $x$ 的量化分为两部分：$x<m$ 和 $x\\ge m$。\n- 对于所有满足 $x<m$ 的 $x$，析取项 $x<m$ 为真。因此，内部公式 $\\big(x<m\\;\\lor\\;H(e,x,s)\\big)$ 对任何 $s$ 的选择都为真。\n- 对于所有满足 $x\\ge m$ 的 $x$，析取项 $x<m$ 为假。内部公式为真当且仅当 $\\exists s\\;H(e,x,s)$ 成立。\n\n因此，语句 $\\forall x\\;\\exists s\\;\\big(x<m\\;\\lor\\;H(e,x,s)\\big)$ 逻辑上等价于语句 $\\forall x \\;\\big(x\\ge m \\implies \\exists s\\;H(e,x,s)\\big)$。\n\n谓词 $\\exists s\\;H(e,x,s)$ 是“索引为 $e$ 的图灵机在输入 $x$ 上停机”的标准定义。设 $W_e$ 是由机器 $e$ 计算的部分可计算函数的定义域，这恰好是它停机的所有输入的集合。所以，$\\exists s\\;H(e,x,s)$ 等价于 $x \\in W_e$。\n\n将此代入 $\\Theta(e)$ 的公式，我们得到：\n$$\n\\Theta(e) \\iff \\exists m\\;\\forall x\\;\\big(x\\ge m \\implies x \\in W_e\\big)\n$$\n这个语句断言存在一个数 $m$，使得所有大于或等于 $m$ 的自然数都在集合 $W_e$ 中。这是集合 $W_e$ 为余有限（cofinite）的定义。余有限的递归可枚举集的索引集合通常表示为 $Cof$。因此，$\\Theta(e)$ 为真当且仅当 $e \\in Cof$。问题就是要确定索引集 $Cof$ 在算术层级中的分类。\n\n**上界：**\n我们通过分析其前束范式（prenex normal form）来确定 $\\Theta(e)$ 复杂度的上界。原始公式是：\n$$\n\\Theta(e) \\iff \\exists m\\;\\forall x\\;\\exists s\\;\\big(x<m\\;\\lor\\;H(e,x,s)\\big)\n$$\n该公式的母体是谓词 $M(e,m,x,s) \\equiv \\big(x<m\\;\\lor\\;H(e,x,s)\\big)$。关系 $H(e,x,s)$ 已知是原始递归的。关系 $x<m$ 也是原始递归的。原始递归关系集在布尔联结词下是闭合的，所以它们的析取 $M(e,m,x,s)$ 也是一个原始递归谓词。因为所有原始递归谓词都是递归的（可判定的），所以该母体是一个涉及自由变量 $e, m, x, s$ 的递归谓词。\n\n$\\Theta(e)$ 的公式在一个递归母体前有一个 $\\exists\\forall\\exists$ 的量词前缀。根据算术层级的定义，由一个以 $\\exists$ 开头的 $n$ 个交替量词为前缀的公式所定义的集合是一个 $\\Sigma_n$ 集合。在这里，我们有3个以 $\\exists$ 开头的交替量词。\n因此，集合 $\\{e \\mid \\Theta(e)\\}$ 属于 $\\Sigma_3$ 类。这表明 $n$ 的最小值至多为 $3$。\n\n**下界：**\n为了证明 $n=3$ 是最小值，我们必须证明 $\\Theta$ 不等价于任何 $\\Sigma_2$ 或 $\\Pi_2$ 中的公式。这可以通过证明集合 $Cof = \\{e \\mid \\Theta(e)\\}$ 是 $\\Sigma_3$-难的来实现。如果每个 $\\Sigma_n$ 集合都可以多一归约（many-one reduced）到某个集合，则该集合是 $\\Sigma_n$-难的。可计算性理论中一个著名的结果是，$Cof$ 是 $\\Sigma_3$-完全的，意味着它在 $\\Sigma_3$ 中并且是 $\\Sigma_3$-难的。\n\n为了证明其难度，我们可以简要描述一个已知的 $\\Sigma_3$-完全集到 $Cof$ 的归约。一个典型的 $\\Sigma_3$-完全集是 $Rec = \\{e \\mid W_e \\text{ 是一个递归集}\\}$。归约需要构造一个全可计算函数 $f$，使得对任意索引 $e$，有 $e \\in Rec \\iff f(e) \\in Cof$。\n索引为 $f(e)$ 的机器被构造成如下行为：\n- 机器 $M_{f(e)}$ 在输入 $s$ 上尝试寻找 $W_e$ 是递归的证据。$W_e$ 是递归的证据是存在一个索引 $i$ 使得 $W_i = \\overline{W_e}$。\n- 机器 $M_{f(e)}$ 系统地搜索这样的索引 $i$。在阶段 $s$，它可能会检查一个候选索引 $i < s$ 是否在某个初始输入段 $\\{0, 1, \\dots, k\\}$ 上看似计算了 $W_e$ 的补集，这是基于 $M_e$ 和 $M_i$ 的计算在 $s$ 步内停机的情况。\n- $M_{f(e)}$ 的行为被定义为：\n    1. 如果 $e \\in Rec$，那么存在一个正确的索引 $i_0$ 对应 $\\overline{W_e}$。搜索过程最终会找到并锁定对 $i_0$ 的验证。这个过程被设计用来确保 $M_{f(e)}$ 在除了有限多个输入之外的所有输入上停机。因此，$W_{f(e)}$ 是余有限的，所以 $f(e) \\in Cof$。\n    2. 如果 $e \\notin Rec$，那么不存在这样的索引 $i$。任何候选索引 $i$ 最终都会被发现是不正确的。机器 $M_{f(e)}$ 被设计成，这种对不正确候选者的永久性抛弃会导致 $M_{f(e)}$ 在无限多个输入上无法停机。因此，$W_{f(e)}$ 不是余有限的，所以 $f(e) \\notin Cof$。\n\n这个归约 $Rec \\le_m Cof$ 证明了 $Cof$ 是 $\\Sigma_3$-难的。根据 Post 定理，一个 $\\Sigma_n$-完全集（对于 $n \\ge 1$）不可能在 $\\Pi_n$ 中，也不可能在任何 $k < n$ 的 $\\Sigma_k$ 或 $\\Pi_k$ 中。因此，$Cof$ 不可能在 $\\Sigma_2$ 或 $\\Pi_2$ 中。\n\n由于 $\\Theta(e)$ 定义了一个 $\\Sigma_3$-完全集，它不等价于算术层级中任何低于层级 $3$ 的公式。使得 $\\Theta$ 等价于一个 $\\Sigma_n$ 或 $\\Pi_n$ 公式的最小自然数 $n$ 是 $3$，并且具体来说，它是一个 $\\Sigma_3$ 公式。", "answer": "$$\\boxed{3}$$", "id": "2984438"}, {"introduction": "从分析现有集合的性质，我们转向更高阶的挑战：主动*构造*具有特定计算性质的集合。本项高级实践将引领你进入优先方法（priority method）的核心，这是可计算性理论中用于解决存在性证明的强大构造工具 ([@problem_id:2986972])。通过解决一个构造两个图灵不可比的递归可枚举集的简化问题，你将亲身体验优先论证的关键机制：策略（strategies）、约束（restraints）和如何处理并最终克服有限次的“伤害”（injuries）。", "problem": "考虑构造递归可枚举集 $A$ 和 $B$ 的目标，这两个集合在一个有限伤害优先权框架中满足两个相互冲突的需求。该构造必须是分阶段的，使用施加和遵守约束的策略，允许可被证明是有限的伤害，并包含一个验证以确保所有需求都得到满足。在图灵可归约性和谕示计算的层面上进行研究。\n\n基本和核心定义：\n- 一个集合 $S \\subseteq \\mathbb{N}$ 是递归可枚举的（r.e.），如果存在一台图灵机（TM）能够枚举 $S$ 的所有元素。\n- 一个图灵泛函 $\\Phi_e$ 是一个索引 $e$，它编码了一个部分可计算算子。当给定一个谕示 $X \\subseteq \\mathbb{N}$ 时，该算子计算出一个（可能部分的）函数或集合 $\\Phi_e^X$。如果 $\\Phi_e^X(x)$ 收敛，我们写作 $\\Phi_e^X(x) \\downarrow$，并用 $\\mathrm{use}(\\Phi_e^X(x))$ 表示在输入为 $x$ 的计算中对谕示 $X$ 的最大查询。\n- 图灵可归约性 $A \\leq_T B$ 意味着存在一个索引 $e$，使得对于所有 $x \\in \\mathbb{N}$，$\\Phi_e^B(x)$ 停机并等于 $A$ 在 $x$ 处的特征函数。为了强制 $A \\nleq_T B$，只需满足需求 $R_e : A \\neq \\Phi_e^B$，即存在某个 $x$，使得 $\\Phi_e^B(x) \\uparrow$（不收敛）或 $\\Phi_e^B(x) \\downarrow \\neq \\chi_A(x)$。\n- 一个有限伤害优先权论证通过优先权（例如，$R_0$ 的优先权高于 $S_0$）来组织需求，分配可能对枚举施加约束的策略以保护已确定的计算，并允许较低优先权的策略被较高优先权的行动所伤害。必须证明对于每个需求，伤害只发生有限次，且验证过程必须表明每个需求最终都得到满足。\n\n示例问题设定：\n我们关注具有固定优先顺序 $R_0 \\succ S_0$ 的两个需求：\n- $R_0$：确保 $A \\neq \\Phi_0^B$。\n- $S_0$：确保 $B \\neq \\Phi_0^A$。\n\n一个分阶段的构造在阶段 $s$ 产生递增的有限近似 $A_s$ 和 $B_s$，其中 $A = \\bigcup_s A_s$ 且 $B = \\bigcup_s B_s$。策略可以对向 $B$ 中枚举施加约束 $r_{R_0}^B$，对向 $A$ 中枚举施加约束 $r_{S_0}^A$，以通过其谕示用量来保护收敛的计算。\n\n问题：\n哪个选项正确地描述了上述示例构造的有限伤害优先权论证，包括精确的策略、与谕示用量相关的约束、对伤害及其有限性的说明，以及对 $R_0$ 和 $S_0$ 均得到满足的验证？\n\n选择一个。\n\nA. $R_0$ 的策略：维护一个见证 $x_R$（初始为尚未分配的最小 $x$）。在阶段 $s$，寻找使 $\\Phi_0^{B_s}(x_R) \\downarrow$ 的情况；如果找到且 $\\mathrm{use}(\\Phi_0^{B_s}(x_R)) = u_R$，则设置约束 $r_{R_0}^B := \\max(r_{R_0}^B, u_R)$，然后向 $A$ 中枚举元素以在 $x_R$ 处强制产生不一致：如果 $\\Phi_0^{B_s}(x_R) = 0$，则在阶段 $s$ 将 $x_R$ 放入 $A$；如果 $\\Phi_0^{B_s}(x_R) = 1$，则确保 $x_R \\notin A$。行动后，$R_0$ 宣布自己已满足，并且不再更改 $x_R$。$S_0$ 的策略：维护一个见证 $y_S$。在阶段 $s$，寻找使 $\\Phi_0^{A_s}(y_S) \\downarrow$ 的情况；如果找到且 $\\mathrm{use}(\\Phi_0^{A_s}(y_S)) = v_S$，则设置约束 $r_{S_0}^A := \\max(r_{S_0}^A, v_S)$，然后类似地向 $B$ 中枚举元素以在 $y_S$ 处强制产生不一致。约束规则与伤害：在每个阶段 $s$，处理 $S_0$ 时，禁止向 $B$ 中枚举小于 $r_{R_0}^B$ 的数，从而遵守与 $\\Phi_0^{B}(x_R)$ 中当前受保护用量相关的较高优先权约束。$R_0$ 不施加约束来遵守 $S_0$ 的约束，并可能通过向 $A$ 中枚举小于 $r_{S_0}^A$ 的数来伤害 $S_0$，但 $R_0$ 最多行动一次，因此 $S_0$ 最多被伤害一次；在任何伤害之后，$S_0$ 会将 $y_S$ 重置为大于被伤害的用量的值，然后继续。验证：由于 $S_0$ 遵守 $r_{R_0}^B$，一旦 $R_0$ 看到一个收敛的计算并设置了 $r_{R_0}^B$，用量为 $u_R$ 的受保护计算 $\\Phi_0^{B}(x_R)$ 就永远不会被破坏，$R_0$ 可以在 $x_R$ 处强制 $A \\neq \\Phi_0^B$。$R_0$ 只行动一次，所以 $S_0$ 因 $A$ 的变化最多遭受一次伤害；此后，$S_0$ 最终会找到一个收敛的 $\\Phi_0^{A}(y_S)$，其用量 $v_S$ 大于 $A$ 的任何未来变化（因为更高优先权已经稳定），设置 $r_{S_0}^A$，并在 $y_S$ 处强制 $B \\neq \\Phi_0^A$。因此，两个需求都得到满足，并且每个需求只受到有限次伤害。\n\nB. $R_0$的策略：同选项 A，但在找到计算 $\\Phi_0^{B}(x_R)$ 时，对向 $A$ 的枚举设置约束 $r_{R_0}^A$ 而非对 $B$；当找到 $\\Phi_0^{A}(y_S)$ 时，$S_0$ 设置 $r_{S_0}^B$。伤害：$S_0$ 遵守 $r_{R_0}^A$ 且 $R_0$ 遵守 $r_{S_0}^B$。验证：由于每个需求都约束其自身的集合，两个计算都被保护，两个对角化都成功。\n\nC. $R_0$的策略：按递增顺序循环遍历见证 $x$，每当看到 $\\Phi_0^{B_s}(x) \\downarrow$ 时，就设置一个约束 $r_{R_0}^B := \\mathrm{use}(\\Phi_0^{B_s}(x))$ 并在 $x$ 处强制产生不一致。如果之后 $\\Phi_0^{B_t}(x) \\uparrow$，则将 $r_{R_0}^B$ 减小到前一个值并选择一个新的见证；$S_0$ 以对称的方式对 $r_{S_0}^A$ 进行操作。伤害：根据不同阶段的表面收敛情况，约束可能增加或减少。验证：由于约束适应变化的计算，最终两个对角化都成功。\n\nD. $R_0$的策略：在阶段 $s$ 预先设置一个大约束 $r_{R_0}^B := s^2$，如果 $s$ 是偶数，则将 $x_R := s$ 枚举到 $A$ 中，否则什么也不做；$S_0$ 对称地设置 $r_{S_0}^A := s^2$，如果 $s$ 是奇数，则将 $y_S := s$ 枚举到 $B$ 中。伤害：允许任意的约束增长；每个策略都忽略任何计算中的实际谕示用量。验证：由于约束无限增长，最终不会有伤害发生，并且两个对角化必须通过基于奇偶性的不一致而成立。\n\n选择一个选项，该选项正确地描述了一个有限伤害优先权论证，其中包含适当的策略、与谕示用量相关的约束、对伤害及其有限性的正确解释，以及对 $A \\neq \\Phi_0^B$ 和 $B \\neq \\Phi_0^A$ 的可靠验证。", "solution": "用户要求对所提供的问题陈述进行严格验证，然后给出详细的解决方案和对所给选项的评估。\n\n### 第1步：提取已知信息\n- **目标**：构造两个递归可枚举（r.e.）集 $A$ 和 $B$。\n- **方法**：分阶段的有限伤害优先权论证。\n- **背景**：图灵可归约性（$\\leq_T$）和谕示计算（$\\Phi_e^X$）。\n- **定义**：\n    - 一个 r.e. 集 $S \\subseteq \\mathbb{N}$ 是一个枚举图灵机的输出。\n    - $\\Phi_e$ 是一个图灵泛函。$\\Phi_e^X(x) \\downarrow$ 表示收敛，$\\mathrm{use}(\\Phi_e^X(x))$ 是最大的谕示查询。\n    - $A \\leq_T B$ 当且仅当对于某个索引 $e$，$\\chi_A = \\Phi_e^B$。\n    - 强制 $A \\nleq_T B$ 需要满足需求 $R_e : A \\neq \\Phi_e^B$。\n    - 有限伤害优先权论证涉及有优先权的需求、策略、约束以及对有限伤害的证明。\n- **示例问题**：\n    - 需求：$R_0: A \\neq \\Phi_0^B$ 和 $S_0: B \\neq \\Phi_0^A$。\n    - 优先顺序：$R_0 \\succ S_0$（$R_0$ 的优先权高于 $S_0$）。\n    - 构造细节：$A = \\bigcup_s A_s$ 和 $B = \\bigcup_s B_s$，其中 $A_s$ 和 $B_s$ 是在阶段 $s$ 的有限近似。\n    - 约束：对 $B$ 的约束 $r_{R_0}^B$ 和对 $A$ 的约束 $r_{S_0}^A$。\n- **问题**：找出正确描述此示例问题的有限伤害论证的选项，包括策略、约束、伤害分析和验证。\n\n### 第2步：使用提取的已知信息进行验证\n1.  **科学依据**：该问题明确属于可计算性理论的范畴，这是数理逻辑的一个主要分支。所有定义——递归可枚举集、图灵泛函、图灵可归约性以及优先权论证的结构——都是标准的且陈述正确。构造图灵不可比的递归可枚举集是著名的 Friedberg–Muchnik 定理的主题，有限伤害优先权方法正是为此而发明的。因此，该问题在科学上和事实上都是合理的。\n2.  **良构性**：问题是良构的。它展示了一个标准证明技术的简化“示例”版本，并要求对其中机制的正确描述。由于有限伤害方法的逻辑是明确的，因此在选项中应该有一个唯一正确的答案。\n3.  **客观性**：使用的语言是形式化的、技术性的，没有主观或模糊的术语。\n4.  **其他缺陷**：该问题没有其他无效性标准所指的缺陷。它是完整的、一致的、可形式化的且并非微不足道的。其设定直接反映了标准可计算性理论教材中介绍有限伤害方法的方式。\n\n### 第3步：结论与行动\n问题陈述是**有效的**。这是一个形式良好且标准的可计算性理论问题。我们可以继续进行解答。\n\n### 推导与选项分析\n\n目标是构造递归可枚举集 $A$ 和 $B$，使得 $A \\nleq_T B$ 且 $B \\nleq_T A$。问题将其简化为满足两个需求：$R_0: A \\neq \\Phi_0^B$ 和 $S_0: B \\neq \\Phi_0^A$，优先顺序为 $R_0 \\succ S_0$。构造按阶段 $s=0, 1, 2, \\dots$ 进行。\n\n**优先权方法的核心逻辑：**\n每个需求都有一个策略来确保其得到满足。对于像 $R_e: A \\neq \\Phi_e^B$ 这样的需求，其策略试图创造一个“不一致”，即找到一个见证 $x$，使得 $\\chi_A(x) \\neq \\Phi_e^B(x)$。\n\n1.  **$R_0: A \\neq \\Phi_0^B$ 的策略（高优先权）**\n    - 策略必须找到一个 $x$，使得 $\\chi_A(x) \\neq \\Phi_0^B(x)$。它选择一个潜在的见证，比如 $x_R$，并等待一个阶段 $s$，使得计算 $\\Phi_0^{B_s}(x_R)$ 收敛。设 $\\Phi_0^{B_s}(x_R) \\downarrow = y$。\n    - 为了创造不一致，策略希望使得 $\\chi_A(x_R) \\neq y$。由于我们只能将元素添加到递归可枚举集 $A$ 中，最简单的情况是当 $x_R \\notin A_s$ 时我们发现 $y=0$。在这种情况下，策略的行动是将 $x_R$ 枚举到 $A$ 中。\n    - 这个计算 $\\Phi_0^{B_s}(x_R)$ 仅依赖于谕示 $B_s$ 直到某个有限的用量，$u_R = \\mathrm{use}(\\Phi_0^{B_s}(x_R))$。为确保这种不一致是永久的，我们必须保护这个计算不被后续对 $B$ 的添加操作所“破坏”。\n    - 因此，$R_0$ 的策略必须**对 $B$ 施加一个约束**。它声明任何小于或等于 $u_R$ 的数都不能被枚举到 $B$ 中。我们可以定义约束函数 $r_{R_0}^B = u_R + 1$。因为 $R_0$ 具有最高优先权，所有其他策略都必须遵守这个约束。\n\n2.  **$S_0: B \\neq \\Phi_0^A$ 的策略（低优先权）**\n    - 该策略是对称的：它选择一个见证 $y_S$，并等待 $\\Phi_0^{A_s}(y_S) \\downarrow = z$。\n    - 为了创造不一致，它可能希望将 $y_S$ 枚举到 $B$ 中（如果 $z=0$ 且 $y_S \\notin B_s$）。\n    - 为了保护其计算，它将**对 $A$ 施加一个约束**，该约束基于用量 $v_S = \\mathrm{use}(\\Phi_0^{A_s}(y_S))$。设此约束为 $r_{S_0}^A = v_S+1$。\n\n3.  **优先权、伤害与验证**\n    - 由于 $R_0 \\succ S_0$，$S_0$ 的策略**必须遵守** $R_0$ 施加的任何约束 $r_{R_0}^B$。也就是说，$S_0$ 被禁止向 $B$ 中枚举任何数 $k < r_{R_0}^B$。\n    - 相反，$R_0$ **不必遵守**来自 $S_0$ 的约束。如果 $R_0$ 决定将 $x_R$ 枚举到 $A$ 中以满足自身需求，即使 $x_R < r_{S_0}^A$，它也会这样做。\n    - 当一个较高优先权的需求采取的行动使得一个较低优先权需求的受保护计算失效时，就发生了**伤害**。在这里，如果 $R_0$ 将 $x_R$ 放入 $A$ 中，且 $x_R \\leq v_S = \\mathrm{use}(\\Phi_0^{A_s}(y_S))$，那么 $S_0$ 的计算很可能会被破坏。这时，$S_0$ 就“被伤害”了。\n    - 受到伤害后，$S_0$ 必须放弃其当前的见证 $y_S$ 和策略，并重新开始（通常使用一个新的、更大的见证）。\n    - **有限伤害**：关键的洞见是，每个需求 $R_e$ 仅需行动有限次即可被永久满足。对于 $R_0$，一个简单的策略是找到第一个制造不一致的机会，采取行动，然后宣布自己已满足，永不再次行动。这意味着 $R_0$ 最多行动一次。因此，$S_0$ 最多被 $R_0$ 伤害一次。在 $R_0$ 稳定下来（通过行动或因为 $\\Phi_0^B$ 是部分的）之后，就不会再有来自 $R_0$ 对 $S_0$ 的伤害了。\n    - **最终成功**：在某个阶段 $s^*$ 之后，$R_0$ 被永久满足，其约束 $r_{R_0}^B$ 及其对 $A$ 的影响是最终的。然后，$S_0$ 的策略可以继续进行。它最终会找到一个稳定的计算 $\\Phi_0^{A_s}(y_S)$（对于 $s > s^*$），并可以通过将 $y_S$ 放入 $B$ 来满足自身需求。只要它遵守 $r_{R_0}^B$，这是可能的，这可以通过选择一个足够大的见证 $y_S$（$y_S \\geq r_{R_0}^B$）来保证。因此，两个需求最终都得到满足。\n\n在建立了这个正确的框架后，我们评估各个选项。\n\n**选项 A 评估：**\n- **$R_0$ 策略**：正确描述了选择见证 $x_R$，等待收敛 $\\Phi_0^{B_s}(x_R) \\downarrow$，根据用量 $u_R$ 对 $B$ 施加约束 $r_{R_0}^B$，并通过向 $A$ 中枚举来制造不一致的行动。它正确地指出然后 $R_0$ 就被满足了。\n- **$S_0$ 策略**：正确描述了针对 $B \\neq \\Phi_0^A$ 的对称过程，该过程对 $A$ 施加约束 $r_{S_0}^A$。\n- **规则与伤害**：正确地指出 $S_0$ 必须遵守 $r_{R_0}^B$，而 $R_0$ 不必遵守 $r_{S_0}^A$，并可能伤害 $S_0$。它正确地识别出 $R_0$ 最多行动一次意味着 $S_0$ 最多被伤害一次（有限次）。\n- **验证**：正确地论证了 $S_0$ 遵守 $r_{R_0}^B$ 确保了 $R_0$ 的成功。然后它正确地论证了在 $R_0$ 稳定后，$S_0$ 不再被伤害，可以找到自己的稳定计算并采取行动来满足自己。\n- **结论**：此选项为该问题提供了有限伤害优先权论证的完整而准确的描述。**正确**。\n\n**选项 B 评估：**\n- **策略**：此选项声称 $R_0$（处理 $\\Phi_0^B$）约束 $A$，而 $S_0$（处理 $\\Phi_0^A$）约束 $B$。这从根本上是错误的。为了保护一个计算 $\\Phi_e^X(z)$，必须约束谕示 $X$。约束一个不同的集合对于保护计算毫无意义。通过约束来保护计算的整个逻辑都被颠倒了。\n- **结论**：**不正确**。\n\n**选项 C 评估：**\n- **策略**：此选项建议，如果一个受保护的计算 $\\Phi_0^{B_t}(x)$ 变得未定义，则减小约束 $r_{R_0}^B$。这是对优先权层次的误解。$R_0$ 具有最高优先权。任何事物都不允许伤害它的计算。在设置约束后，计算 $\\Phi_0^{B_s}(x)$ 不应该变得未定义，因为约束的目的就是防止对谕示 $B$ 进行可能导致这种情况的更改。所描述的场景不应该发生。这种减小约束的机制不是标准有限伤害论证的一部分，并且曲解了优先权和保护的角色。\n- **结论**：**不正确**。\n\n**选项 D 评估：**\n- **策略**：提出的策略是任意设置约束（$r^B_{R_0} := s^2$），并根据一个简单的奇偶规则来构造集合 $A$ 和 $B$（$A$ 获得偶数，$B$ 获得奇数），完全忽略了实际的计算 $\\Phi_0^B$ 和 $\\Phi_0^A$。这不是一个优先权论证。这是一个直接的构造，未能满足问题要求。\n- **验证**：该构造产生的是可计算集 $A$ 和 $B$。可计算集之间是平凡地可相互归约的（$A \\leq_T B$ 且 $B \\leq_T A$）。因此，这个构造未能产生图灵不可比的集合，而这才是最终目标。例如，如果 $\\Phi_0$ 是一个无论其谕示如何都计算偶数特征函数的泛函，那么 $\\Phi_0^B$ 将与 $A$ 完全相同，需求 $R_0$ 将失败。所提出的策略没有机制来阻止这种情况。\n- **结论**：**不正确**。\n\n基于详细分析，选项 A 是唯一正确且准确地描述了应用于给定示例问题的有限伤害优先权论证的选项。", "answer": "$$\\boxed{A}$$", "id": "2986972"}]}