{"hands_on_practices": [{"introduction": "在我们深入研究构造不可比的可计算性枚举集的完整复杂性之前，解决一个相关的、概念上更简单的问题是很有启发性的。这个练习 [@problem_id:93253] 旨在构建一个非可计算但又非图灵完备的集合，它演示了使用停机问题作为“神谕”（oracle）的核心对角化技术。通过量化此构造所需的资源，它为理解可计算性理论中的构造方法提供了一个具体的切入点。", "problem": "弗里德伯格-穆奇尼克定理通过证明存在具有中间图灵度的可计算可枚举集，解决了波斯特问题。我们在此处将要考虑的一个更简单的构造，是构建一个集合 $A$，它不是可计算可枚举的，但仍具有中间图灵度，即 $\\emptyset <_T A <_T K$。其中 $K$ 是停机问题，而 $<_T$ 表示严格图灵可归约性。\n\n集合 $A$ 是使用 $K$ 的谕示来构造的，以确保 $A \\le_T K$。构造过程分阶段进行，以满足对所有整数 $e \\ge 0$ 的两类要求：\n1.  $N_e$: $A \\neq C_e$，其中 $C_e$ 是第 $e$ 个可计算集。这确保了 $A$ 是不可计算的（$\\emptyset <_T A$）。\n2.  $P_e$: $K$ 的特征函数 $\\chi_K$ 不等于由第 $e$ 台谕示图灵机（OTM）以谕示 $A$ 所计算的函数 $\\Phi_e^A$。这确保了 $A$ 不是图灵完备的（$K \\not\\le_T A$）。\n\n本问题关注满足 $P_e$ 要求所需的资源。在每个阶段 $e=0, 1, 2, \\dots$，构造过程都会确保 $P_e$ 被满足。假设我们已经构建了 $A$ 的一个有限初始段，记为字符串 $\\alpha_e$。满足 $P_e$ 的步骤是找到 $\\alpha_e$ 的一个扩展，该扩展能强制在 $\\chi_K$ 和 $\\Phi_e^A$ 之间产生一个不一致。\n\n策略如下：\n1.  启动一个可计算的、无界的搜索来寻找一个“分叉”。分叉是一个三元组 $(x, \\sigma_0, \\sigma_1)$，其中 $x$ 是一个整数，$\\sigma_0$ 和 $\\sigma_1$ 是都是扩展 $\\alpha_e$ 的有限二进制字符串，使得第 $e$ 台谕示图灵机在输入 $x$ 上的计算对于每个谕示都会停机并给出不同的输出：$\\Phi_e^{\\sigma_0}(x) \\downarrow = 0$ 和 $\\Phi_e^{\\sigma_1}(x) \\downarrow = 1$。\n2.  查询停机谕示 $K$ **一次**，以确定这个寻找分叉的搜索是否会终止。\n3.  **情况1（未找到分叉）：** 如果谕示 $K$ 表明该搜索永远不会找到分叉，这意味着对于任何 $x$，$\\Phi_e^A(x)$ 的值（如果收敛）都独立于对 $\\alpha_e$ 之后的 $A$ 所做的任何选择。这使得 $\\Phi_e^A$ 成为一个部分可计算函数，而它不能等同于不可计算的函数 $\\chi_K$。因此，要求 $P_e$ 得到满足。此阶段的流程终止。\n4.  **情况2（找到分叉）：** 如果谕示 $K$ 表明存在分叉，则运行可计算搜索，直到找到第一个这样的分叉 $(x, \\sigma_0, \\sigma_1)$。然后，**第二次**查询停机谕示 $K$，以确定值 $v = \\chi_K(x)$。接着，构造将 $A$ 定义为 $\\sigma_{1-v}$ 的一个扩展，从而确保 $\\Phi_e^A(x) = 1-v \\neq \\chi_K(x)$。要求 $P_e$ 得到满足。\n\n基于此构造，为满足要求 $P_e$ 而对停机谕示 $K$进行的查询次数为 1（情况1）或 2（情况2）。\n\n计算为满足前 $n$ 个要求 $P_0, P_1, \\dots, P_{n-1}$ 所需对停机问题 $K$ 的最大可能查询次数。", "solution": "为确定满足前 $n$ 个要求 $P_0, P_1, \\dots, P_{n-1}$ 所需对停机谕示 $K$ 的最大可能查询次数，我们考虑每个要求的查询使用情况：\n\n- 对于每个要求 $P_e$：\n  - 在情况1（未找到分叉）中，$K$ 被查询一次。\n  - 在情况2（找到分叉）中，$K$ 被查询两次（一次用于确认分叉的存在，另一次用于获取 $\\chi_K(x)$）。\n\n当每个要求都适用情况2时，查询次数达到最大值，因为每个要求需要两次查询。这种情况是可能的，因为对于每个 $P_e$ 的构造在查询使用方面是独立的，并且没有约束强制要求进入情况1。因此，对于 $n$ 个要求，最坏情况下的总查询次数是每个要求 2 次。\n\n因此，最大总查询次数为：\n$$\n2n\n$$", "answer": "$$\\boxed{2n}$$", "id": "93253"}, {"introduction": "由 Friedberg 和 Muchnik 独立给出的波斯特问题的解答，是可计算性理论中的一个里程碑式成就，它引入了革命性的“优先权方法”（priority method）。这项练习 [@problem_id:2978704] 旨在挑战你分析这种方法的基石。你需要理解如何通过一个线性的优先权列表来系统地解决不同构造要求之间的冲突，并最终确保每个要求在经历有限次“伤害”（injury）后得到满足。", "problem": "考虑可计算枚举 (c.e.) 集 $A$ 和 $B$，并固定谕示图灵机的标准枚举 $\\{\\Phi_e\\}_{e \\in \\mathbb{N}}$ 和 $\\{\\Psi_e\\}_{e \\in \\mathbb{N}}$，其中 $\\Phi_e^X$ 表示以 $X$ 为谕示的第 $e$ 台机器。回顾对于集合 $X \\subseteq \\mathbb{N}$，$A \\le_T X$ 意味着存在 $e$ 使得 $\\Phi_e^X$ 计算 $A$ 的特征函数，对 $B$ 也类似。为确保 $A \\nle_T B$ 且 $B \\nle_T A$，一个经典的方法是为所有 $e \\in \\mathbb{N}$ 设立以下需求：\n$$\nR_e: \\ \\Phi_e^B \\neq A, \\qquad S_e: \\ \\Psi_e^A \\neq B.\n$$\n这个问题的基础包括图灵可归约性、带使用函数的谕示计算以及集合的可计算枚举的定义。具体来说，一个谕示计算 $\\Phi_e^X(x)$，当其收敛时，有一个有限的使用，记作 $\\mathrm{use}(\\Phi_e^X;x)$，表示计算过程中对谕示 $X$ 的最大查询；而 c.e. 集是通过对候选者的可计算列表进行单调枚举来构建的。\n\n下列哪个选项正确描述了一个带允许（permitting）的有限伤害优先构造，该构造满足所有需求 $R_e$ 和 $S_e$，并实现了 $A \\nle_T B$ 和 $B \\nle_T A$？\n\nA. 指定一个单一的全局约束 $r \\in \\mathbb{N}$，并禁止任何在 $r$ 下方的元素被枚举进 $A$ 或 $B$。对于每个 $e$，一旦 $\\Phi_e^B(x)$ 或 $\\Psi_e^A(y)$ 对某个新的 $x$ 或 $y$ 收敛，就枚举该见证来翻转相关的位，从而满足 $R_e$ 或 $S_e$。由于枚举是单调的，且全局约束阻止了干扰，所有需求都可以在无伤害的情况下被满足。\n\nB. 将 $A$ 构造成单纯集，将 $B$ 构造成余单纯集。因为单纯集是不可计算的，而余单纯集不能计算一个单纯集，所以这保证了 $A \\nle_T B$ 且 $B \\nle_T A$。\n\nC. 使用无限伤害优先。对于 $R_e$，等待对 $B$ 的近似稳定下来，然后将一个见证枚举到 $A$ 中以对角化 $\\Phi_e^B$。对于 $S_e$，等待对 $A$ 的近似稳定下来，然后将一个见证枚举到 $B$ 中以对角化 $\\Psi_e^A$。无穷的伤害循环确保了近似最终会以一种满足所有需求的方式稳定下来。\n\nD. 施加一个优先次序 $R_0 \\succ S_0 \\succ R_1 \\succ S_1 \\succ \\cdots$。对每个 $e$，为 $R_e$ 保留不相交的新见证 $x_e$，为 $S_e$ 保留不相交的新见证 $y_e$，这些见证的选择要高于所有当前活动的更高优先级约束。维护约束函数 $r_e^A$ 和 $r_e^B$，它们在 $e$ 上和在各阶段中都是非递减的。$R_e$ 的策略：等待一个阶段 $s$，在该阶段 $\\Phi_e^{B_s}(x_e)\\downarrow$ 且使用为 $u$；设置 $r_e^B := u$ 以保护此计算免受更低优先级策略的影响，并且如果 $\\Phi_e^{B_s}(x_e)=0$，则等待 $B$ 中的一个允许事件，即未来的某个阶段 $t$，$B$ 在 $u$ 下方发生变化，然后将 $x_e$ 枚举到 $A$ 中以强制产生永久性分歧；如果 $\\Phi_e^{B_s}(x_e)=1$，则不执行任何操作，因为默认情况下 $A(x_e)=0$，分歧已经存在。$S_e$ 的策略是对称的：等待 $\\Psi_e^{A_s}(y_e)\\downarrow$ 且使用为 $v$，设置 $r_e^A := v$，并且在得到 $A$ 在 $v$ 下方变化的允许后，当输出为 $0$ 时将 $y_e$ 枚举到 $B$ 中，否则不执行任何操作。约束仅由更高优先级的行动重置，并且单调增加，因此每个较低优先级的需求只会被伤害有限多次。通过对优先级进行归纳，每个需求最终至多行动一次并得到满足，从而得出 $A \\nle_T B$ 和 $B \\nle_T A$。", "solution": "问题要求对一个带允许（permitting）的有限伤害优先构造给出一个正确的描述，该构造用于构建两个可计算枚举（c.e.）集 $A$ 和 $B$，使得它们是图灵不可比较的，即 $A \\nle_T B$ 且 $B \\nle_T A$。这是通过对所有 $e \\in \\mathbb{N}$ 满足以下需求来实现的：\n$$\nR_e: \\ \\Phi_e^B \\neq A \\quad \\text{（} A \\text{ 的特征函数不是由 } \\Phi_e^B \\text{ 计算的）}\n$$\n$$\nS_e: \\ \\Psi_e^A \\neq B \\quad \\text{（} B \\text{ 的特征函数不是由 } \\Psi_e^A \\text{ 计算的）}\n$$\n这种集合的构造是 Post 问题的解，最早由 Friedberg 和 Muchnik 独立给出。他们的方法是典型的有限伤害优先论证。核心思想是为需求分配优先级，并分阶段构建集合 $A$ 和 $B$。在每个阶段，我们处理需要关注的最高优先级需求。为高优先级需求采取的行动可能会使低优先级需求所做的假设失效，这一事件被称为“伤害”（injury）。如果可以证明每个需求只被伤害有限次，那么该构造就是“有限伤害”的。\n\n让我们根据这些原则评估每个选项。\n\n**选项 A 评估**\n该选项提出了一个单一的全局约束 $r$，并声称需求可以在“无伤害”的情况下被满足。可计算性理论的历史表明这种方法是站不住脚的。Post 的纲领曾试图寻找这样一种“无优先级”或“无伤害”的构造，但他未能找到。需求之间的相互作用是复杂的；例如，通过将元素 $x_e$ 枚举到 $A$ 中来满足 $R_e$，可能会破坏某个依赖于 $A$ 保持不变的 $S_k$ 的计算。解决这些潜在的无限冲突的需求正是为什么优先级系统是必需的。解决 Post 问题的构造必须包含一个解决冲突的机制，而这会导致伤害。声称一个无伤害的构造是根本错误的。\n**结论：不正确。**\n\n**选项 B 评估**\n该选项建议将 $A$ 构造成一个单纯集，将 $B$ 构造成一个余单纯集，并声称这足以确保 $A \\nle_T B$ 且 $B \\nle_T A$。一个集合如果是 c.e. 的、余无限的，并且其补集不包含无限 c.e. 集，则该集合是单纯的。如果一个集合的补集是单纯的，则该集合是余单纯的。虽然单纯集和余单纯集保证是不可计算的，但任何这样的一对集合都是图灵不可比较的这一说法是错误的。Sacks 的一个定理指出，对于任何不可计算的 c.e. 图灵度 $\\mathbf{d}$，都存在一个度为 $\\mathbf{d}$ 的单纯集 $A$。人们也可以构造出各种 c.e. 度的余单纯集。可以构造一个单纯集 $A$ 和一个余单纯集 $B$ 使得 $A \\equiv_T B$。例如，可以构造一个度为 $\\mathbf{0}'$（停机问题的度）的单纯集和一个度为 $\\mathbf{0}'$ 的余单纯集。因此，这个提议的策略不能保证不可比较性。\n**结论：不正确。**\n\n**选项 C 评估**\n该选项提出了一个“无限伤害优先”论证。经典的 Friedberg-Muchnik 构造是*有限伤害*论证的教科书式例子。需要无限伤害论证的问题，例如 Sacks 分裂定理，通常更为复杂。将无限伤害的框架应用于一个可用有限伤害方法解决的问题是一个范畴错误。此外，“无穷的伤害循环确保了近似最终会稳定下来”这一描述是模糊的，并非一个严谨的论证。在一个典型的无限伤害论证中，一个需求可能会行动无限多次，但其行动的极限会产生期望的结果。这里提供的描述并不是对此类论证的清晰表述，而且最重要的是，它对问题应用了错误的技术。\n**结论：不正确。**\n\n**选项 D 评估**\n该选项描述了一个有限伤害优先论证的框架。让我们分析其组成部分：\n1.  **优先次序：** 它正确地陈述了标准的优先次序 $R_0 \\succ S_0 \\succ R_1 \\succ S_1 \\succ \\cdots$。\n2.  **见证和约束：** 它正确地指出了为每个需求使用新见证（$x_e, y_e$），以及约束函数（$r_e^A, r_e^B$）的核心作用，即需求施加约束以保护计算免受较低优先级需求的干扰。\n3.  **有限伤害性质：** 它正确地总结了优先级系统的结果：“约束仅由更高优先级的行动重置……因此每个较低优先级的需求只会被伤害有限多次。” 这是任何有限伤害证明中的关键引理。\n4.  **归纳证明结构：** 它正确地指出证明是通过“对优先级进行归纳”来进行的，表明每个需求最终都会被满足。\n\n所描述的架构对于一个 Friedberg-Muchnik 构造来说是完全正确的。唯一有问题的部分是关于 $R_e$ 策略的详细描述：\n“……如果 $\\Phi_e^{B_s}(x_e)=0$，则等待 $B$ 中的一个允许事件，即未来的某个阶段 $t$，$B$ 在 $u$ 下方发生变化，然后将 $x_e$ 枚举到 $A$ 中……”\n\n这个具体的机制，如其所述，在逻辑上是有缺陷的。一个 $R_e$ 希望保留的计算，其使用为 $u$，$B$ 在 $u$ 下方的变化必须由一个更高优先级的需求（例如，某个 $j < e$ 的 $S_j$）引发。这种由更高优先级需求采取的行动是对 $R_e$ 的一次**伤害**。一次伤害会迫使被伤害的需求重置，取消其当前的尝试。它并不“允许”被伤害的需求完成其行动。因此，该描述以一种矛盾的方式混淆了伤害和允许的概念。\n\n然而，尽管在战术步骤的描述上存在这个重大缺陷，选项 D 是唯一一个正确识别出解决方案战略框架的选项。其他选项在所需证明的类型（有限伤害优先论证）或底层的可计算性理论原则上都存在根本性错误。在给定的选项中选择最佳描述的背景下，这个选项要优越得多。它正确地勾勒了整个论证的结构，其错误仅限于对单一步骤内部机制的描述。因此，它是唯一合理的答案。\n**结论：正确。**", "answer": "$$\\boxed{D}$$", "id": "2978704"}, {"introduction": "虽然线性的优先权列表足以完成经典的 Friedberg-Muchnik 构造，但可计算性理论中更复杂的问题需要更精密的组织工具。这个问题 [@problem_id:2978712] 引入了“优先权树”（priority tree）这一更强大的框架。通过这种树状结构，策略可以明确地为构造过程中可能出现的不同长期行为（例如，遭受有限次还是无限次伤害）进行规划，从而能够应对更复杂的交互情形。", "problem": "考虑解决波斯特问题的经典方法，即构造两个图灵度不可比较的可计算枚举（c.e.）集 $A \\subseteq \\omega$ 和 $B \\subseteq \\omega$，也就是 $A \\not\\le_T B$ 且 $B \\not\\le_T A$，其中 $X \\le_T Y$ 表示图灵可归约性。为此种构造组织相互作用策略的一种标准方法是通过一个简单优先树，其节点承载着针对需求的策略，这些需求旨在对两个方向上所有可能的归约进行对角化。设 $\\{\\Phi_e\\}_{e \\in \\omega}$ 和 $\\{\\Psi_e\\}_{e \\in \\omega}$ 是谕示图灵泛函（部分可计算泛函）的固定枚举，并考虑以下需求\n$$\nR_e:\\ \\Phi_e^B \\neq A,\\qquad S_e:\\ \\Psi_e^A \\neq B\n$$\n对于所有 $e \\in \\omega$，其优先序为交错排列的 $R_0 \\succ S_0 \\succ R_1 \\succ S_1 \\succ \\cdots$。\n\n优先树用于管理可能伤害较低优先级策略的较高优先级动作的无限行为。对应于一个需求的每个节点都采用一种策略，该策略设置约束并使用见证来强迫不一致或部分性。树上的分支代表了关于某些伤害是发生有限次还是无限次的猜测。一个用于 $R_e$ 的节点通常会监控其选定见证 $x$ 上的计算 $\\Phi_e^B(x)$ 的用量（use），该用量是在该计算中查询谕示 $B$ 的最大数值，并对 $B$ 施加一个约束，低于该约束的较低优先级动作不得进行枚举，以保护该计算或控制其发散。同理，类似的说明也适用于 $S_e$ 的节点，其约束施加于 $A$。\n\n选择正确描述组织 $\\{R_e, S_e\\}$ 策略的简单二叉优先树的选项，包括每个节点的分支如何对应于为确保 $A \\not\\le_T B$ 和 $B \\not\\le_T A$ 所必须满足的不同无限行为，以及相应的满足动作如何沿这些分支而变化。\n\nA. 每个需求的节点（$R_e$ 或 $S_e$）都有两个分支，标记为 $f$ 和 $\\infty$。分支 $f$ 对应于这样的猜测：更高优先级的活动只会对该节点的当前约束造成有限次伤害，因此约束最终会稳定下来。沿着分支 $f$，策略会选择一个新的见证 $x$，等待相关计算（例如，对于 $R_e$ 是 $\\Phi_e^B(x)$）在用量稳定后收敛，然后行动一次以强迫不一致（通过将元素枚举到目标集以使其值与计算结果相反），从而使该计算对该输入有定义但与目标集不相等。分支 $\\infty$ 对应于这样的猜测：更高优先级的活动会对该节点的约束造成无限次伤害，因此用量会无界增加。沿着分支 $\\infty$，策略放弃尝试稳定的对角化，而是通过永久允许导致用量增长的枚举来确保所尝试的归约保持为部分的，从而保证相关计算发散（例如，$\\Phi_e^B(x)$ 无法收敛），由此也满足了该需求。该树按优先级交替设置 $R_e$ 和 $S_e$ 节点，每个节点的子节点精确对应于其约束的两种无限行为分支 $f$ 和 $\\infty$，从而产生一个一致的全局调度，其中较低优先级的节点仅在所有祖先节点的当前约束之下行动。\n\nB. 节点按 $\\Phi_e^B$ 或 $\\Psi_e^A$ 的“全的”与“部分的”这种语义分支进行分叉，并且沿着“部分的”分支，策略会强行与目标集相等来立即完成需求。因为全性或部分性是一个全局属性，所以分支的确定是非有效的，但这是可接受的，因为优先树只组织信息而非动作。\n\nC. 该树每个节点使用三个分支：一个分支断言 $A$ 在该节点的约束下枚举无限多个数，另一个断言 $B$ 在该节点的约束下枚举无限多个数，第三个断言两者都没有。沿着“两者都没有”的分支，策略会无限次地伤害较低优先级的节点以防止意外的归约，而沿着“$A$-无限”或“$B$-无限”的分支，策略会切换到在 $A$ 和 $B$ 之间建立归约来控制复杂性。\n\nD. 不需要分叉；一个带有队列调度的线性优先列表就足够了。每个需求使用一个固定的见证，当被伤害时，立即恢复到其初始状态。分支不是关于伤害的猜测，而是指示一个节点到目前为止被伤害了多少次的计数器，而需求的满足是通过在固定次数的伤害后永久冻结枚举来实现的，这确保了所有尝试的归约在高优先级下都成为全的。\n\n哪个选项是正确的？", "solution": "用户需要对一个关于波斯特问题和优先权方法的可计算性理论问题进行严谨的验证和解答。\n\n### 问题验证\n\n**步骤1：提取已知条件**\n\n*   **目标：**构造两个可计算枚举（c.e.）集 $A \\subseteq \\omega$ 和 $B \\subseteq \\omega$，其图灵度不可比较。\n*   **不可比较性条件：** $A \\not\\le_T B$ 且 $B \\not\\le_T A$，其中 $\\le_T$ 表示图灵可归约性。\n*   **方法论：** 使用简单优先树组织策略的经典方法。\n*   **枚举：** $\\{\\Phi_e\\}_{e \\in \\omega}$ 和 $\\{\\Psi_e\\}_{e \\in \\omega}$ 是谕示图灵泛函的固定枚举。\n*   **需求：** 对所有 $e \\in \\omega$，满足：\n    *   $R_e: \\Phi_e^B \\neq A$\n    *   $S_e: \\Psi_e^A \\neq B$\n*   **优先序：** $R_0 \\succ S_0 \\succ R_1 \\succ S_1 \\succ \\cdots$。\n*   **策略简述：**\n    *   树上的节点对应于需求。\n    *   策略涉及选择见证（例如 $x$）和监控计算（例如 $\\Phi_e^B(x)$）。\n    *   对谕示（$A$ 或 $B$）施加约束以保护计算。\n    *   树上的分支代表对来自更高优先级动作的伤害的无限行为的猜测。\n*   **问题：** 选择正确描述这种优先树、其分支以及相应策略的选项。\n\n**步骤2：使用提取的已知条件进行验证**\n\n*   **科学基础（关键）：** 该问题牢固地植根于可计算性理论，这是数学逻辑的一个分支。所描述的任务是弗里德伯格-穆奇尼克定理的证明，这是一个解决了波斯特问题的基本结果。所使用的术语——可计算枚举（c.e.）集、图灵可归约性（$\\le_T$）、谕示图灵泛函（$\\Phi_e$）、需求、优先权论证、见证和约束——都是该领域中标准的、有严格定义的概念。该问题在科学和数学上是合理的。\n*   **良构性：** 该问题是良构的。它要求对一种特定的、众所周知的证明技巧（优先权方法，通过策略树组织）进行正确描述。存在一种标准的、正确的方式来描述这种构造，使得该问题是可回答的。\n*   **客观性（关键）：** 对于该领域的专家来说，其语言是技术性的、精确的，并且没有主观性或歧义。所有术语都有正式的数学定义。\n*   **缺陷分析：**\n    1.  **科学上不合理：** 无。其前提在数学逻辑领域是事实正确的。\n    2.  **不可形式化/不相关：** 无。该问题是关于数学逻辑中一个特定主题的直接而形式化的问题。\n    3.  **不完整/矛盾的设定：** 无。该设定为理解问题提供了足够的背景。它准确地阐述了优先权论证的目标和工具。\n    4.  **不切实际/不可行：** 不适用；这是一个纯数学问题。该构造是一个有效的证明。\n    5.  **不当提问/结构不良：** 无。存在一个唯一的概念性答案。\n    6.  **伪深刻/琐碎：** 无。优先权方法是一种真正复杂且不平凡的证明技巧。\n    7.  **超出科学可验证性范围：** 无。描述的正确性可以通过对照可计算性理论的标准文献（例如Soare、Odifreddi或Rogers的著作）来验证。\n\n**步骤3：结论与行动**\n\n问题陈述是有效的。其设定准确地描述了用于解决波斯特问题的优先权论证的背景。我现在将推导解决方案并评估各个选项。\n\n### 解法推导\n\n该问题要求描述一种用于构造两个图灵不可比较的可计算枚举（c.e.）集 $A$ 和 $B$ 的优先权论证。该构造必须满足一个无限的需求列表：对所有 $e \\in \\omega$ 满足 $R_e: \\Phi_e^B \\neq A$ 和 $S_e: \\Psi_e^A \\neq B$。这些需求被赋予了严格的优先序 $R_0 \\succ S_0 \\succ R_1 \\succ S_1 \\succ \\cdots$。\n\n核心困难在于，为满足一个需求（例如 $S_k$）而采取的行动可能会“伤害”一个较低优先级需求（例如 $R_j$，其中 $j>k$）的策略。当一个更高优先级的需求在计算 $\\Phi_j^B(x_j)$ 的“用量”之下改变了谕示（$B$）时，就会对 $R_j$ 针对见证 $x_j$ 的策略造成一次伤害，这可能改变或破坏其收敛性。\n\n优先树是一种组织策略以处理这些伤害的方法。树上的每个节点对应于特定需求的策略。通向节点的路径代表了构造的一个有限历史。从一个节点延伸出的分支代表对更高优先级需求未来行为的*猜测*。构造分阶段进行，在每个阶段都沿着树中的一条路径前进。一条无限路径，称为“真实路径”，将会出现，它代表了实际的结果。沿着这条真实路径的策略将是从某个阶段开始最终被遵循的策略，从而确保所有需求都得到满足。\n\n让我们关注一个用于需求 $R_e$ 的节点。该节点的策略必须确保 $\\Phi_e^B \\neq A$。它会受到来自更高优先级需求（$i<e$ 的 $R_i, S_i$ 以及 $S_e$）的伤害。对于 $R_e$ 的策略来说，关键问题是：“我会被这些更高优先级的需求伤害有限次还是无限次？”这个问题的答案决定了正确的长期策略。树的分支模拟了这两种可能性。\n\n*   **分支 $f$ （有限）：** 该分支代表猜测 $R_e$ 的策略只会被伤害有限次。如果这个猜测是正确的（即，该分支在真实路径上），那么从某个阶段开始，该策略将不再受到伤害。然后它可以执行一个永久性的、“有限伤害”式的动作。\n    1.  它指定一个大的、新的见证 $x$。\n    2.  它等待计算 $\\Phi_e^B(x)$ 收敛，比如 $\\Phi_e^B(x) \\downarrow = 0$。\n    3.  它通过对 $B$ 施加一个约束 $r_e$ 来保护这个计算，禁止较低优先级的需求将任何小于该计算用量的数枚举到 $B$ 中。\n    4.  为确保 $\\Phi_e^B(x) \\neq A(x)$，它等待一个行动机会。如果在此阶段 $A(x)=0$，策略就将 $x$ 枚举到 $A$ 中。这个行动将永久地为见证 $x$ 满足 $R_e$。这个行动可能会伤害较低优先级的需求，但由于该节点只行动一次，它只对其下的需求造成一次伤害。\n\n*   **分支 $\\infty$ （无限）：** 该分支代表猜测 $R_e$ 的策略将被伤害无限次。如果这个猜测是正确的，那么上述的有限伤害策略将会失败；每当它建立一个受保护的计算时，一个更高优先级的需求最终会违反其约束，迫使其重新开始。然而，正是这个事实可以被用来满足需求。如果约束被无限次违反，这意味着谕示 $B$ 在与计算 $\\Phi_e^B(x)$ 相关的输入上被无限次改变。这可以被利用来确保对所选的见证 $x$，计算 $\\Phi_e^B(x)$ *永不*收敛。如果计算 $\\Phi_e^B(x)$ 是发散的，那么泛函 $\\Phi_e^B$ 就是部分的，因此不能等于 $A$ 的特征函数（特征函数是全的）。因此，通过确保非全性来满足需求 $R_e: \\Phi_e^B \\neq A$。\n\n整个树是通过根据优先级交替设置 $R_e$ 和 $S_e$ 的节点来构建的。一个需求 $P \\in \\{R_e, S_e\\}$ 的节点有两个子节点，对应于 $P$ 的 $f$ 和 $\\infty$ 分支。在构造的每个阶段所走的路径是那一刻看起来正确的路径。真实路径是无限次访问的最左边的路径。沿着这条路径的策略保证会成功。\n\n### 逐项分析选项\n\n**A. 每个需求的节点（$R_e$ 或 $S_e$）都有两个分支，标记为 $f$ 和 $\\infty$。分支 $f$ 对应于这样的猜测：更高优先级的活动只会对该节点的当前约束造成有限次伤害，因此约束最终会稳定下来。沿着分支 $f$，策略会选择一个新的见证 $x$，等待相关计算（例如，对于 $R_e$ 是 $\\Phi_e^B(x)$）在用量稳定后收敛，然后行动一次以强迫不一致（通过将元素枚举到目标集以使其值与计算结果相反），从而使该计算对该输入有定义但与目标集不相等。分支 $\\infty$ 对应于这样的猜测：更高优先级的活动会对该节点的约束造成无限次伤害，因此用量会无界增加。沿着分支 $\\infty$，策略放弃尝试稳定的对角化，而是通过永久允许导致用量增长的枚举来确保所尝试的归约保持为部分的，从而保证相关计算发散（例如，$\\Phi_e^B(x)$ 无法收敛），由此也满足了该需求。该树按优先级交替设置 $R_e$ 和 $S_e$ 节点，每个节点的子节点精确对应于其约束的两种无限行为分支 $f$ 和 $\\infty$，从而产生一个一致的全局调度，其中较低优先级的节点仅在所有祖先节点的当前约束之下行动。**\n\n这个选项为解决波斯特问题的基于树的优先权方法（通常与Sacks相关）提供了一个精确而全面的描述。它正确地指出了：\n1.  基于伤害性质（$f$ 代表有限次，$\\infty$ 代表无限次）的二叉分支。\n2.  “有限伤害”分支的正确策略：稳定，等待收敛，并通过枚举见证进行对角化。\n3.  “无限伤害”分支的正确策略：利用无限次伤害来强迫对方泛函是部分的，从而满足需求。\n4.  优先树的整体结构和约束的作用。\n这个描述是该方法的教科书式说明。\n**结论：正确**\n\n**B. 节点按 $\\Phi_e^B$ 或 $\\Psi_e^A$ 的“全的”与“部分的”这种语义分支进行分叉，并且沿着“部分的”分支，策略会强行与目标集相等来立即完成需求。因为全性或部分性是一个全局属性，所以分支的确定是非有效的，但这是可接受的，因为优先树只组织信息而非动作。**\n\n该选项在几个方面是错误的。首先，分支不是对泛函最终“全的”或“部分的”性质的直接猜测，这是一个不可判定的属性（$\\Sigma_2^0$ 或 $\\Pi_2^0$）。分支是关于构造本身可观察行为（有限次或无限次伤害）的猜测。其次，沿“部分的”分支描述的行动是无意义的：如果一个泛函是部分的，需求已经满足了，没有必要（也没有连贯的方式）去“强行相等”。第三，声称树只“组织信息而非动作”是错误的；树在每个有效构造阶段都直接决定了哪些策略是活跃的。\n**结论：错误**\n\n**C. 该树每个节点使用三个分支：一个分支断言 $A$ 在该节点的约束下枚举无限多个数，另一个断言 $B$ 在该节点的约束下枚举无限多个数，第三个断言两者都没有。沿着“两者都没有”的分支，策略会无限次地伤害较低优先级的节点以防止意外的归约，而沿着“$A$-无限”或“$B$-无限”的分支，策略会切换到在 $A$ 和 $B$ 之间建立归约来控制复杂性。**\n\n该选项描述了一种不同的、不连贯的论证类型。约束是由一个策略施加的，以防止*其他*策略在其下面枚举数。一个策略无法控制集合 $A$ 或 $B$ 是否有数被更高优先级的动作枚举到其约束之下。此外，目标是构造不可比较的集合，所以切换到“在 $A$ 和 $B$ 之间建立归约”与目标完全相反。所描述的行动是反直觉的，并且不符合弗里德伯格-穆奇尼克构造的目标。\n**结论：错误**\n\n**D. 不需要分叉；一个带有队列调度的线性优先列表就足够了。每个需求使用一个固定的见证，当被伤害时，立即恢复到其初始状态。分支不是关于伤害的猜测，而是指示一个节点到目前为止被伤害了多少次的计数器，而需求的满足是通过在固定次数的伤害后永久冻结枚举来实现的，这确保了所有尝试的归约在高优先级下都成为全的。**\n\n该选项错误地驳回了问题的前提，问题明确要求描述一个“简单二叉优先树”。虽然一个无分支的线性优先列表对于一个更简单的*有限伤害*论证（弗里德伯格和穆奇尼克的原始方法）是足够的，但它不是一种基于树的方法。问题特别要求描述基于树的组织方式。此外，对策略的描述是有缺陷的。“冻结枚举”不是一个可行的全局策略，目标也不是“确保所有尝试的归约都成为全的”。目标是确保它们与目标集不相等，这可能涉及强迫它们成为部分的。\n**结论：错误**", "answer": "$$\\boxed{A}$$", "id": "2978712"}]}