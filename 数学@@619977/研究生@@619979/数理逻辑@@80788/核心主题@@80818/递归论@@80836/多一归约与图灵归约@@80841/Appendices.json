{"hands_on_practices": [{"introduction": "掌握多一归约 (many-one reducibility) 和图灵归约 (Turing reducibility) 的第一步是牢固理解它们的核心定义及其直接推论。这个练习旨在通过一系列基本命题，系统性地检验您对不同归约关系（$A \\le_1 B$, $A \\le_m B$, $A \\le_T B$）之间的层级关系、它们在可判定集和递归可枚举集上的闭包性质，以及完备性概念的理解。通过证明或证伪这些陈述，您将加深对计算理论基本工具的运用能力。[@problem_id:2981118]", "problem": "设 $A,B \\subseteq \\mathbb{N}$。回顾可计算性理论中的以下基本定义：\n- 如果集合 $S \\subseteq \\mathbb{N}$ 的特征函数是全可计算的，则称该集合是递归的（可判定的）。\n- 如果存在一台图灵机，它能精确地枚举出集合 $S$ 中的所有元素，或者等价地说，存在一台图灵机，它在输入 $x$ 上停机当且仅当 $x \\in S$，那么集合 $S \\subseteq \\mathbb{N}$ 是递归可枚举的 (r.e.)。\n- 多一归约（也称映射归约）定义为 $A \\leq_{m} B$，如果存在一个全可计算函数 $f:\\mathbb{N} \\to \\mathbb{N}$，使得对于所有 $x \\in \\mathbb{N}$，\n$$\nx \\in A \\iff f(x) \\in B.\n$$\n- 一一归约定义为 $A \\leq_{1} B$，如果存在一个全可计算单射函数 $f:\\mathbb{N} \\to \\mathbb{N}$，使得对于所有 $x \\in \\mathbb{N}$，\n$$\nx \\in A \\iff f(x) \\in B.\n$$\n- 图灵归约定义为 $A \\leq_{T} B$，如果存在一台以 $B$ 为预言机的预言图灵机，它能判定 $A$ 的成员关系。\n\n令 $K = \\{ e \\in \\mathbb{N} : \\varphi_{e}(e) \\downarrow \\}$ 为经典的自输入停机集，其中 $(\\varphi_{e})_{e \\in \\mathbb{N}}$ 是部分可计算函数的标准编号。\n\n选择所有正确的命题。每个选择都应根据这些核心定义和可计算性理论的一般事实来证明。\n\nA. 如果 $A \\leq_{1} B$，那么 $A \\leq_{m} B$；并且如果 $A \\leq_{m} B$，那么 $A \\leq_{T} B$。\n\nB. 如果 $A \\leq_{m} B$ 且 $B$ 是递归的，那么 $A$ 是递归的。\n\nC. 如果 $A \\leq_{T} B$ 且 $B$ 是递归的，那么 $A$ 是递归的。\n\nD. 对于每个递归可枚举集 $A$，都存在一个全可计算单射函数 $f$，使得对于所有 $x \\in \\mathbb{N}$，$x \\in A \\iff f(x) \\in K$。等价地，每个 r.e. 集 $A$ 都满足 $A \\leq_{1} K$。\n\nE. 存在递归可枚举集 $A,B$，满足 $A \\leq_{m} B$ 但 $A \\not\\leq_{1} B$。\n\nF. 如果 $A \\leq_{m} B$ 且 $B$ 是余递归可枚举的，那么 $A$ 是余递归可枚举的。\n\nG. 如果 $A \\leq_{m} B$ 且 $B$ 是递归可枚举且多一完全的（即，对于每个 r.e. 集 $C$，都有 $C \\leq_{m} B$），那么 $A$ 是递归可枚举且多一完全的。\n\nH. 如果 $A \\leq_{T} B$ 且 $B \\leq_{T} A$，那么 $A$ 和 $B$ 是多一等价的（即，$A \\leq_{m} B$ 且 $B \\leq_{m} A$）。", "solution": "问题陈述提供了可计算性理论中的标准定义，并要求基于这些定义评估八个命题的真伪。该问题定义明确，科学上合理，且内部一致。\n\nA. **如果 $A \\leq_{1} B$，那么 $A \\leq_{m} B$；并且如果 $A \\leq_{m} B$，那么 $A \\leq_{T} B$。**\n\n该命题包含两个论断。\n\n1.  如果 $A \\leq_{1} B$，那么 $A \\leq_{m} B$。\n    根据定义，$A \\leq_{1} B$ 意味着存在一个全可计算单射函数 $f: \\mathbb{N} \\to \\mathbb{N}$，使得对于所有 $x \\in \\mathbb{N}$，$x \\in A \\iff f(x) \\in B$。\n    根据定义，$A \\leq_{m} B$ 意味着存在一个全可计算函数 $g: \\mathbb{N} \\to \\mathbb{N}$，使得对于所有 $x \\in \\mathbb{N}$，$x \\in A \\iff g(x) \\in B$。\n    由于任何单射函数根据定义本身也是一个函数，因此用于 $1$-归约的全可计算单射函数 $f$ 的存在，立即意味着用于 $m$-归约的全可计算函数的存在（我们可以简单地取 $g=f$）。因此，这个蕴含关系为真。\n\n2.  如果 $A \\leq_{m} B$，那么 $A \\leq_{T} B$。\n    根据定义，$A \\leq_{m} B$ 意味着存在一个全可计算函数 $f$，使得 $x \\in A \\iff f(x) \\in B$。\n    根据定义，$A \\leq_{T} B$ 意味着存在一台以 $B$ 为预言机的预言图灵机，它能判定 $A$ 的成员关系。\n    我们可以构造这样一台预言机 $M^B$ 来判定 $A$。对于任何输入 $x \\in \\mathbb{N}$：\n    a. 计算 $y = f(x)$。由于 $f$ 是一个全可计算函数，这一步总会停机。\n    b. 对输入 $y$ 查询 $B$ 的预言机。根据定义，如果 $y \\in B$，预言机停机并返回`真`；如果 $y \\notin B$，则返回`假`。\n    c. 如果预言机返回`真`，则 $y \\in B$，这意味着 $x \\in A$。机器 $M^B$ 停机并接受。\n    d. 如果预言机返回`假`，则 $y \\notin B$，这意味着 $x \\notin A$。机器 $M^B$ 停机并拒绝。\n    这个过程是一个使用预言机 $B$ 来判定 $A$ 中成员关系的全算法。因此，$A \\leq_{T} B$。这个蕴含关系也为真。\n\n由于两个论断都为真，该命题 **正确**。\n\nB. **如果 $A \\leq_{m} B$ 且 $B$ 是递归的，那么 $A$ 是递归的。**\n\n给定 $A \\leq_{m} B$，存在一个全可计算函数 $f$ 使得 $x \\in A \\iff f(x) \\in B$。\n给定 $B$ 是递归的，其特征函数 $\\chi_B(y)$ 是一个全可计算函数，其中如果 $y \\in B$，则 $\\chi_B(y) = 1$；如果 $y \\notin B$，则 $\\chi_B(y) = 0$。\n为了证明 $A$ 是递归的，我们必须证明其特征函数 $\\chi_A(x)$ 是全可计算的。\n由归约可知，条件 $x \\in A$ 等价于 $f(x) \\in B$。这意味着 $\\chi_A(x) = 1$ 当且仅当 $\\chi_B(f(x)) = 1$。类似地，$\\chi_A(x) = 0$ 当且仅当 $\\chi_B(f(x)) = 0$。\n因此，对于所有 $x \\in \\mathbb{N}$，有 $\\chi_A(x) = \\chi_B(f(x))$。\n函数 $\\chi_A$ 被定义为两个全可计算函数 $f$ 和 $\\chi_B$ 的复合。全可计算函数类在复合运算下是封闭的。因此，$\\chi_A$ 是一个全可计算函数。\n这证明了 $A$ 是一个递归集。\n该命题 **正确**。\n\nC. **如果 $A \\leq_{T} B$ 且 $B$ 是递归的，那么 $A$ 是递归的。**\n\n给定 $A \\leq_{T} B$，存在一台预言图灵机 $M^B$ 判定 $A$ 的成员关系。这意味着 $M^B$ 在所有输入 $x \\in \\mathbb{N}$ 上都会停机，如果 $x \\in A$ 则接受，如果 $x \\notin A$ 则拒绝。\n给定 $B$ 是递归的，存在一台标准的（非预言）图灵机 $M_B$ 判定 $B$ 的成员关系。也就是说，对于任何输入 $y$，$M_B$ 会停机并接受（如果 $y \\in B$）或停机并拒绝（如果 $y \\notin B$）。\n我们可以构造一台标准图灵机 $M_A$ 来判定 $A$。$M_A$ 将模拟 $M^B$ 的执行。每当 $M^B$ 进行一次预言机查询“$y \\in B$ 吗？”，模拟就暂停。然后 $M_A$ 在输入 $y$ 上运行判定器 $M_B$。由于 $M_B$ 是一个判定器，它保证会停机。$M_A$ 使用 $M_B$ 的计算结果来为 $M^B$ 的预言机查询提供答案，然后继续模拟。\n由于 $M^B$ 保证在所有输入上停机，并且其计算中的每个预言机调用都被一个同样保证停机的计算（$M_B$ 的执行）所替代，因此整个机器 $M_A$ 将在所有输入上停机。它正确地判定 $A$ 的成员关系。\n因此，$A$ 是一个递归集。\n该命题 **正确**。\n\nD. **对于每个递归可枚举集 $A$，都存在一个全可计算单射函数 $f$，使得对于所有 $x \\in \\mathbb{N}$，$x \\in A \\iff f(x) \\in K$。等价地，每个 r.e. 集 $A$ 都满足 $A \\leq_{1} K$。**\n\n这个命题声称停机集 $K$ 对于递归可枚举 (r.e.) 集类是 $1$-完全的。\n设 $A$ 是任意一个 r.e. 集。根据定义，$A$ 是某个部分可计算函数的定义域。设这个函数对于某个指标 $a$ 是 $\\varphi_a$，所以 $A = \\text{dom}(\\varphi_a) = \\{x \\in \\mathbb{N} \\mid \\varphi_a(x) \\downarrow\\}$。\n我们想证明 $A \\leq_{1} K$。为此，我们必须构造一个全可计算单射函数 $f$ 使得 $x \\in A \\iff f(x) \\in K$。\nS-m-n 定理（在其有效版本中，也与填充引理相关）指出，存在一个全可计算*单射*函数 $f(x)$，使得对于所有的 $x$ 和 $y$，$\\varphi_{f(x)}(y) \\simeq \\psi(x, y)$。这里的单射性质是关键；它确保不同的输入 $x$ 产生不同的程序指标 $f(x)$，通常通过向程序代码中添加无用指令（“填充”）来实现。\n一个稍微不同但更直接的构造如下。对于每个 $x$，定义一个程序 $P_x$，它在任何输入 $z$ 上执行以下操作：首先运行 $\\varphi_a(x)$ 的计算，如果该计算停机，那么它就停机。填充引理保证了这个程序的指标，我们称之为 $f(x)$，可以由 $x$ 的一个全可计算单射函数给出。\n因此，对于任何 $z$，$\\varphi_{f(x)}(z)$ 停机当且仅当 $\\varphi_a(x)$ 停机。\n特别地，我们可以选择 $z = f(x)$。所以，$\\varphi_{f(x)}(f(x))$ 停机当且仅当 $\\varphi_a(x)$ 停机。\n这就给出了等价关系：$x \\in A \\iff \\varphi_a(x) \\downarrow \\iff \\varphi_{f(x)}(f(x)) \\downarrow \\iff f(x) \\in K$。\n由于 $f$ 是一个全可计算单射函数，我们证明了 $A \\leq_{1} K$。由于 $A$ 是任意一个 r.e. 集，该命题成立。\n该命题 **正确**。\n\nE. **存在递归可枚举集 $A,B$，满足 $A \\leq_{m} B$ 但 $A \\not\\leq_{1} B$。**\n\n这个命题声称多一归约严格弱于一一归约。我们来找一个 $A \\leq_{m} B \\implies A \\leq_{1} B$ 的反例。\n设 $A = \\mathbb{N} = \\{0, 1, 2, \\dots\\}$ 且 $B = \\{0\\}$。\n$A$ 和 $B$ 都是递归的（它们的特征函数显然是可计算的），因此它们也是递归可枚举的。\n1.  证明 $A \\leq_{m} B$。我们需要一个全可计算函数 $f$ 使得 $x \\in A \\iff f(x) \\in B$。\n    由于 $A = \\mathbb{N}$，条件 $x \\in A$ 总是为真。因此，我们需要 $f(x) \\in B$ 也总是为真。这意味着 $f(x)$ 必须总是 $0$。\n    令 $f(x) = 0$ 对所有 $x \\in \\mathbb{N}$ 成立。这是一个常数函数，是全可计算的。等价关系 `真 <=> 真` 对所有 $x$ 成立。因此，$\\mathbb{N} \\leq_{m} \\{0\\}$。\n2.  证明 $A \\not\\leq_{1} B$。我们需要证明不存在全可计算*单射*函数 $g$ 使得 $x \\in A \\iff g(x) \\in B$。\n    假设存在这样的函数 $g$。如前所述，$x \\in A$ 总是为真，所以我们必须有 $g(x) \\in B$ 对所有 $x \\in \\mathbb{N}$ 成立。这意味着对所有 $x$，$g(x) = 0$。\n    然而，为了使 $g$ 成为单射函数，我们必须有当 $x_1 \\neq x_2$ 时，$g(x_1) \\neq g(x_2)$。\n    取 $x_1 = 0$ 和 $x_2 = 1$。那么 $g(0)=0$ 和 $g(1)=0$，这违反了单射性。\n    因此，不存在这样的单射函数 $g$。所以 $A \\not\\leq_{1} B$。\n我们找到了满足条件的 r.e. 集 $A$ 和 $B$。\n该命题 **正确**。\n\nF. **如果 $A \\leq_{m} B$ 且 $B$ 是余递归可枚举的，那么 $A$ 是余递归可枚举的。**\n\n给定 $A \\leq_{m} B$，存在一个全可计算函数 $f$ 使得 $x \\in A \\iff f(x) \\in B$。\n对两边取非，我们得到 $x \\notin A \\iff f(x) \\notin B$。\n令 $\\bar{A} = \\mathbb{N} \\setminus A$ 和 $\\bar{B} = \\mathbb{N} \\setminus B$ 为 $A$ 和 $B$ 的补集。该等价关系可以写成 $x \\in \\bar{A} \\iff f(x) \\in \\bar{B}$。\n这表明 $\\bar{A} \\leq_{m} \\bar{B}$，通过的是同一个全可计算函数 $f$。\n我们已知 $B$ 是余递归可枚举的（co-r.e.）。根据定义，这意味着它的补集 $\\bar{B}$ 是递归可枚举的（r.e.）。\n现在我们有 $\\bar{A} \\leq_{m} \\bar{B}$ 且 $\\bar{B}$ 是 r.e. 的。我们需要证明这蕴含了 $\\bar{A}$ 是 r.e. 的。\n由于 $\\bar{B}$ 是 r.e. 的，存在一台图灵机 $M_{\\bar{B}}$，它在输入 $y$ 上停机当且仅当 $y \\in \\bar{B}$。\n我们可以构造一台图灵机 $M_{\\bar{A}}$ 来识别 $\\bar{A}$：\n对于输入 $x$：\n1. 计算 $y = f(x)$。因为 $f$ 是全可计算的，所以这一步会停机。\n2. 在输入 $y$ 上运行 $M_{\\bar{B}}$。\n$M_{\\bar{A}}$ 停机当且仅当 $M_{\\bar{B}}$ 在 $y=f(x)$ 上停机。这成立当且仅当 $f(x) \\in \\bar{B}$，而这又成立当且仅当 $x \\in \\bar{A}$。\n因此，$M_{\\bar{A}}$ 是 $\\bar{A}$ 的一个识别器，这意味着 $\\bar{A}$ 是 r.e. 的。\n如果 $\\bar{A}$ 是 r.e. 的，那么根据定义，$A$ 就是余-r.e. 的。\n该命题 **正确**。\n\nG. **如果 $A \\leq_{m} B$ 且 $B$ 是递归可枚举且多一完全的（即，对于每个 r.e. 集 $C$，都有 $C \\leq_{m} B$），那么 $A$ 是递归可枚举且多一完全的。**\n\n这个命题声称，如果一个集合能 m-归约到一个 m-完全集，那么它自身也是 m-完全的。这是错误的。一个归约 $A \\leq_m B$ 意味着 $A$ “不比” $B$ “更难”。它并不意味着 $A$ “和” $B$ “一样难”。\n我们来构造一个反例。\n设 $B = K$，即停机集。$K$ 是 r.e. 且 m-完全的。\n设 $A = \\emptyset$。空集是递归的，因此它也是 r.e. 的。\n$A \\leq_{m} B$ 是否成立？也就是说，$\\emptyset \\leq_{m} K$ 是否成立？我们需要一个全可计算函数 $f$ 使得 $x \\in \\emptyset \\iff f(x) \\in K$。\n左边，$x \\in \\emptyset$，总是假的。所以我们需要右边，$f(x) \\in K$，也总是假的。这意味着 $f$ 的值域必须是 $\\bar{K}$ 的一个子集。\n集合 $\\bar{K}$ 不是 r.e. 的，但它是非空的（实际上是无限的）。令 $k_0$ 为 $\\bar{K}$ 中的任意一个元素（例如，一个无限循环程序的指标）。\n定义 $f(x) = k_0$ 对所有 $x \\in \\mathbb{N}$ 成立。这是一个全可计算函数。\n归约条件变为 `假 <=> 假`，这对所有 $x$ 都为真。因此，$\\emptyset \\leq_{m} K$。\n所以我们有 $A = \\emptyset$，$B = K$。前提条件满足：$A \\leq_m B$ 且 $B$ 是 m-完全的。\n结论是否为真？$A = \\emptyset$ 是 r.e. 且 m-完全的吗？\n$A$ 是 r.e. 的。但它是 m-完全的吗？若要 $A$ 是 m-完全的，则每个 r.e. 集 $C$ 都必须满足 $C \\leq_m A$。\n我们选择一个非空的 r.e. 集，例如 $C=\\{0\\}$。\n如果 $\\{0\\} \\leq_m \\emptyset$，那么必须存在一个全可计算函数 $g$ 使得对于所有 $x$，$x \\in \\{0\\} \\iff g(x) \\in \\emptyset$。\n右边，$g(x) \\in \\emptyset$，总是假的。\n为了让等价关系成立，左边，$x \\in \\{0\\}$，也必须总是假的。\n但是对于 $x=0$，$x \\in \\{0\\}$ 是真的。对于 $x=0$，我们得到了矛盾 `真 <=> 假`。\n因此，不存在这样的函数 $g$。所以 $\\{0\\} \\not\\leq_m \\emptyset$。\n因此，$\\emptyset$ 不是 m-完全的。结论是假的。\n该命题 **不正确**。\n\nH. **如果 $A \\leq_{T} B$ 且 $B \\leq_{T} A$，那么 $A$ 和 $B$ 是多一等价的（即，$A \\leq_{m} B$ 且 $B \\leq_{m} A$）。**\n\n这个命题声称图灵等价 ($A \\equiv_T B$) 蕴含多一等价 ($A \\equiv_m B$)。众所周知这是错误的；图灵归约是比多一归约更粗糙的等价关系。\n我们来找一个反例。考虑 $A = K$（停机集）和 $B = \\bar{K}$（其补集）。\n1.  证明 $A \\leq_T B$ 和 $B \\leq_T A$。\n    要证明 $K \\leq_T \\bar{K}$，我们需要一台以 $\\bar{K}$ 为预言机的预言机来判定 $K$。对于输入 $x$，查询预言机：“$x \\in \\bar{K}$ 吗？”。如果预言机回答是，则 $x \\notin K$，所以拒绝。如果它回答否，则 $x \\in K$，所以接受。这是一个 $K$ 的判定器。所以 $K \\leq_T \\bar{K}$。\n    对称地，要证明 $\\bar{K} \\leq_T K$，我们使用一个以 $K$ 为预言机。对于输入 $x$，查询：“$x \\in K$ 吗？”。如果是，则 $x \\notin \\bar{K}$，所以拒绝。如果否，则 $x \\in \\bar{K}$，所以接受。这是一个 $\\bar{K}$ 的判定器。所以 $\\bar{K} \\leq_T K$。\n    因此，$K \\equiv_T \\bar{K}$。\n2.  证明并非 $A \\equiv_m B$。我们将证明 $K \\not\\leq_m \\bar{K}$。\n    我们用反证法，假设 $K \\leq_m \\bar{K}$。\n    $K$ 是一个 r.e. 集。根据定义，$\\bar{K}$ 是一个余-r.e. 集。\n    我们在命题 F 中证明了，如果 $X \\leq_m Y$ 且 $Y$ 是余-r.e. 的，那么 $X$ 也是余-r.e. 的。\n    将这个结果应用于 $X=K$ 和 $Y=\\bar{K}$：由于 $K \\leq_m \\bar{K}$（根据假设）且 $\\bar{K}$ 是余-r.e. 的，因此 $K$ 必须是余-r.e. 的。\n    所以，$K$ 将既是 r.e. 的（根据其定义）又是余-r.e. 的。\n    根据 Post 定理，一个集合是递归的，当且仅当它既是 r.e. 的又是余-r.e. 的。这将意味着 $K$ 是递归的。\n    然而，停机集 $K$ 不是递归的，这是可计算性理论的一个基本结果。这是一个矛盾。\n    因此，我们的初始假设必定是错误的。所以，$K \\not\\leq_m \\bar{K}$。\n    由于 $K \\not\\leq_m \\bar{K}$，集合 $K$ 和 $\\bar{K}$ 不是多一等价的。\n我们找到了集合 $A, B$ 使得 $A \\equiv_T B$ 但 $A \\not\\equiv_m B$。\n该命题 **不正确**。\n\n结果总结：\nA：正确\nB：正确\nC：正确\nD：正确\nE：正确\nF：正确\nG：不正确\nH：不正确\n\n因此，正确的命题是 A, B, C, D, E, 和 F。", "answer": "$$\\boxed{ABCDEF}$$", "id": "2981118"}, {"introduction": "在理解了归约的基本定义之后，我们来深入探究多一归约的结构特性。这个练习要求您为两个特别构造的语言，亲手设计多一归约函数，从而证明它们是多一等价的 ($L_A \\equiv_m L_B$)，尽管它们本身并不相等。这项实践不仅能让您具体地体会到“归约”这一过程的精髓，还能揭示为何 $\\le_m$ 关系在所有语言集合上不具备反对称性，这是理解 m-度 (m-degrees) 结构的关键一步。[@problem_id:1349294]", "problem": "设 $\\Sigma = \\{0, 1\\}$ 是一个字母表。$\\Sigma$ 上的一个语言是由符号取自 $\\Sigma$ 的有限长字符串组成的任意集合。$\\Sigma$ 上所有有限长字符串的集合记为 $\\Sigma^*$。一个函数 $f: \\Sigma^* \\to \\Sigma^*$ 被称为一个全可计算函数，如果存在一台图灵机，对于任意输入字符串 $w \\in \\Sigma^*$，该图灵机都会停机并产生输出字符串 $f(w)$。\n\n称一个语言 $L_1$ 多一归约到一个语言 $L_2$，记作 $L_1 \\le_m L_2$，如果存在一个全可计算函数 $f: \\Sigma^* \\to \\Sigma^*$，使得对于每个字符串 $w \\in \\Sigma^*$，条件 ($w \\in L_1$) 为真当且仅当条件 ($f(w) \\in L_2$) 为真。\n\n已知关系 $\\le_m$ 是自反的（对于任何语言 $L$ 都有 $L \\le_m L$）和传递的（如果 $L_1 \\le_m L_2$ 且 $L_2 \\le_m L_3$，则 $L_1 \\le_m L_3$）。\n\n现在，对于任意非空语言 $A \\subseteq \\Sigma^*$，定义两个新语言：\n$L_0(A) = \\{ 0s \\mid s \\in A \\}$\n$L_1(A) = \\{ 1s \\mid s \\in A \\}$\n这里，$0s$ 表示将符号‘0’与字符串 $s$ 拼接而成的字符串。\n\n设 $U$ 是一个特定的非空、不可判定语言（一个不存在图灵机能对所有字符串停机并正确判定其成员资格的语言）。设 $L_U^0 = L_0(U)$ 和 $L_U^1 = L_1(U)$ 是从 $U$ 构建的语言。\n\n考虑以下四个陈述：\n(I) $L_U^0 \\le_m L_U^1$。\n(II) $L_U^1 \\le_m L_U^0$。\n(III) $L_U^0 = L_U^1$。\n(IV) 关系 $\\le_m$ 在 $\\Sigma$ 上的所有语言集合上是反对称的。（一个集合 $S$ 上的关系 $R$ 是反对称的，如果对于所有 $x, y \\in S$，若 $x R y$ 且 $y R x$，则 $x=y$）。\n\n下列哪个选项正确地指出了以上列表中所有为真的陈述？\n\nA. 仅 I\nB. 仅 I 和 II\nC. I、II 和 III\nD. 仅 IV\nE. 以上陈述都不为真。", "solution": "我们在 $\\Sigma=\\{0,1\\}$ 上进行讨论。对于任意非空语言 $U \\subseteq \\Sigma^{*}$，定义 $L_{U}^{0}=\\{0s \\mid s \\in U\\}$ 和 $L_{U}^{1}=\\{1s \\mid s \\in U\\}$。\n\n为了建立 (I) $L_{U}^{0} \\le_{m} L_{U}^{1}$，我们定义一个全可计算函数 $f:\\Sigma^{*}\\to\\Sigma^{*}$ 如下：\n$$\nf(w)=\n\\begin{cases}\n1s & \\text{if } w=0s \\text{ for some } s \\in \\Sigma^{*},\\\\\n0 & \\text{otherwise.}\n\\end{cases}\n$$\n这个函数 $f$ 是可计算的，因为检查 $w$ 是否以 $0$ 开头并修改第一个符号是一个简单的有效过程，并且映射到常数 $0$ 的函数是可计算的。为了证明其正确性，考虑任意 $w \\in \\Sigma^{*}$：\n- 如果 $w=0s$，那么\n$$\nw \\in L_{U}^{0} \\iff s \\in U \\iff 1s \\in L_{U}^{1} \\iff f(w) \\in L_{U}^{1}.\n$$\n- 如果 $w$ 的形式不是 $0s$，那么根据定义 $w \\notin L_{U}^{0}$，并且 $f(w)=0 \\notin L_{U}^{1}$，因为 $L_{U}^{1}$ 中的每个字符串都以 $1$ 开头，而 $0$ 以 $0$ 开头。因此\n$$\nw \\in L_{U}^{0} \\iff f(w) \\in L_{U}^{1}\n$$\n仍然成立（两边都为假）。所以 (I) 为真。\n\n为了建立 (II) $L_{U}^{1} \\le_{m} L_{U}^{0}$，我们定义一个全可计算函数 $g:\\Sigma^{*}\\to\\Sigma^{*}$ 如下：\n$$\ng(w)=\n\\begin{cases}\n0s & \\text{if } w=1s \\text{ for some } s \\in \\Sigma^{*},\\\\\n1 & \\text{otherwise.}\n\\end{cases}\n$$\n基于同样的理由，这个函数 $g$ 是可计算的。为了证明其正确性，考虑任意 $w \\in \\Sigma^{*}$：\n- 如果 $w=1s$，那么\n$$\nw \\in L_{U}^{1} \\iff s \\in U \\iff 0s \\in L_{U}^{0} \\iff g(w) \\in L_{U}^{0}.\n$$\n- 如果 $w$ 的形式不是 $1s$，那么 $w \\notin L_{U}^{1}$，并且 $g(w)=1 \\notin L_{U}^{0}$，因为 $L_{U}^{0}$ 中的每个字符串都以 $0$ 开头，而 $1$ 以 $1$ 开头。因此\n$$\nw \\in L_{U}^{1} \\iff g(w) \\in L_{U}^{0}\n$$\n成立（两边都为假）。所以 (II) 为真。\n\n对于 (III) $L_{U}^{0}=L_{U}^{1}$，注意到 $L_{U}^{0}$ 中的每个字符串都以 $0$ 开头，而 $L_{U}^{1}$ 中的每个字符串都以 $1$ 开头。由于 $U \\neq \\varnothing$，存在 $s \\in U$，因此 $0s \\in L_{U}^{0}$ 但 $0s \\notin L_{U}^{1}$。因此 $L_{U}^{0} \\neq L_{U}^{1}$，所以 (III) 为假。\n\n对于 (IV)，反对称性要求对于所有语言 $A,B$，如果 $A \\le_{m} B$ 且 $B \\le_{m} A$，那么 $A=B$。然而，取 $A=L_{U}^{0}$ 和 $B=L_{U}^{1}$，我们已经证明了 $A \\le_{m} B$ 且 $B \\le_{m} A$，但 $A \\neq B$。因此 $\\le_{m}$ 在所有语言的集合上不是反对称的，所以 (IV) 为假。\n\n因此，为真的陈述仅有 (I) 和 (II)。", "answer": "$$\\boxed{B}$$", "id": "1349294"}, {"introduction": "多一归约和图灵归约是两种衡量问题难度的核心工具，但它们的表达能力有显著差异。本练习通过分析两个经典的不可判定问题——停机问题 ($A_{TM}$) 和空语言问题 ($EMPTY_{TM}$)——来阐明这种差异。您将通过构造证明，体验图灵归约（使用预言机）的强大能力，并理解为何在某些情况下，更严格的多一归约无法实现。这个对比是区分不同不可判定性等级的典型范例。[@problem_id:1457107]", "problem": "在计算理论中，我们分析算法可解问题的界限。其核心是不可判定问题，对于这类问题，不存在任何算法能对所有输入都给出正确的“是”或“否”的回答。两个基本的不可判定问题是图灵机的停机问题和空性问题。\n\n设一台图灵机（TM）表示为 $M$，其作为字符串的编码为 $\\langle M \\rangle$。$M$ 所接受的语言，记作 $L(M)$，是所有能使 $M$ 停机并进入接受状态的输入串的集合。\n\n停机问题是语言 $A_{TM} = \\{ \\langle M, w \\rangle \\mid M \\text{ 是一台在输入串 } w \\text{ 上停机的图灵机} \\}$。\n空性问题是语言 $EMPTY_{TM} = \\{ \\langle M \\rangle \\mid M \\text{ 是一台图灵机且 } L(M) = \\emptyset \\}$。\n\n如果一个语言 $L_1$ 可以使用一个针对 $L_2$ 的神谕机（黑盒求解器）来判定，那么称 $L_1$ 图灵可归约到 $L_2$，记作 $L_1 \\le_T L_2$。\n如果存在一个可计算函数 $f$，使得对于任意字符串 $x$， $x \\in L_1$ 当且仅当 $f(x) \\in L_2$，那么称语言 $L_1$ 多一归约到语言 $L_2$，记作 $L_1 \\le_m L_2$。\n\n考虑以下关于这些语言及其补集（$\\overline{L}$ 表示语言 $L$ 的补集）之间关系的陈述。如果存在一台图灵机，它对语言中的每个字符串都会停机并接受，而对不在此语言中的字符串则拒绝或无限循环，那么这个语言被称为可识别语言。\n\n下列陈述中，哪些是正确的？\n\nA. $EMPTY_{TM}$ 图灵可归约到 $A_{TM}$。\nB. $EMPTY_{TM}$ 多一归约到 $A_{TM}$。\nC. 空性问题的补集 $\\overline{EMPTY_{TM}}$ 是一个可识别语言。\nD. 停机问题的补集 $\\overline{A_{TM}}$ 是一个可识别语言。\nE. $A_{TM}$ 图灵可归约到 $EMPTY_{TM}$。", "solution": "我们使用标准的构造和定义来分析每个陈述。\n\n首先，回顾一下定义：\n- $A_{TM} = \\{\\langle M,w\\rangle \\mid M \\text{ 在输入 } w \\text{ 上停机}\\}$。\n- $EMPTY_{TM} = \\{\\langle M\\rangle \\mid L(M) = \\emptyset\\}$。\n- 如果某个图灵机对一个语言中的所有字符串停机并接受，那么该语言是可识别的。\n\nA. $EMPTY_{TM} \\le_{T} A_{TM}$。\n对任意给定的 $\\langle M\\rangle$，构造一台图灵机 $N_{M}$，它忽略其输入 $d$ 并按如下方式运行：交错模拟所有字符串 $x$ 并逐步模拟 $M(x)$；如果任何一个模拟到达接受状态，那么 $N_{M}$ 就在输入 $d$ 上停机（并且，比如说，接受）。于是\n$$\n\\langle M\\rangle \\in \\overline{EMPTY_{TM}} \\iff \\langle N_{M}, d\\rangle \\in A_{TM},\n$$\n因此\n$$\n\\langle M\\rangle \\in EMPTY_{TM} \\iff \\langle N_{M}, d\\rangle \\notin A_{TM}.\n$$\n通过对 $\\langle N_{M},d\\rangle$ 进行一次 $A_{TM}$ 神谕机查询并将结果取反，我们就可以判定 $EMPTY_{TM}$，这证明了 $EMPTY_{TM} \\le_{T} A_{TM}$。因此A是正确的。\n\nB. $EMPTY_{TM} \\le_{m} A_{TM}$。\n为导出矛盾，假设存在一个可计算函数 $f$ 满足\n$$\n\\langle M\\rangle \\in EMPTY_{TM} \\iff f(\\langle M\\rangle) \\in A_{TM}.\n$$\n由于 $A_{TM}$ 是可识别的，将一个用于 $A_{TM}$ 的识别器与 $f$ 复合，将会得到一个 $EMPTY_{TM}$ 的识别器。但是 $EMPTY_{TM}$ 是不可识别的（根据莱斯定理或关于图灵机性质的标准结论），这导出了矛盾。因此B是错误的。\n\nC. $\\overline{EMPTY_{TM}}$ 是可识别的。\n我们有\n$$\n\\langle M\\rangle \\in \\overline{EMPTY_{TM}} \\iff \\exists x\\,\\exists t\\ \\big[M \\text{ 在 } t \\text{ 步内接受 } x\\big].\n$$\n一个识别器可以交错地遍历所有的对 $(x,t)$，模拟 $M(x)$ 运行 $t$ 步，如果找到一个接受的计算过程，就接受。因此 $\\overline{EMPTY_{TM}}$ 是可识别的。所以C是正确的。\n\nD. $\\overline{A_{TM}}$ 是可识别的。\n由于 $A_{TM}$ 是可识别且不可判定的，如果 $\\overline{A_{TM}}$ 也是可识别的，那么通过交错运行两个识别器，$A_{TM}$ 将是可判定的，而这是不可能的。因此 $\\overline{A_{TM}}$ 是不可识别的，D是错误的。\n\nE. $A_{TM} \\le_{T} EMPTY_{TM}$。\n给定 $\\langle M,w\\rangle$，构建一台图灵机 $N_{M,w}$，它对任意输入 $y$ 模拟 $M(w)$；如果 $M(w)$ 停机，那么 $N_{M,w}$ 立即接受 $y$；否则它就无限循环。于是\n$$\n\\langle M,w\\rangle \\in A_{TM} \\iff L(N_{M,w}) = \\Sigma^{*} \\iff \\langle N_{M,w}\\rangle \\notin EMPTY_{TM}.\n$$\n因此 $A_{TM} \\le_{m} \\overline{EMPTY_{TM}}$，这意味着 $A_{TM} \\le_{T} EMPTY_{TM}$。所以E是正确的。\n\n总结：A、C 和 E 是正确的；B 和 D 是错误的。", "answer": "$$\\boxed{ACE}$$", "id": "1457107"}]}