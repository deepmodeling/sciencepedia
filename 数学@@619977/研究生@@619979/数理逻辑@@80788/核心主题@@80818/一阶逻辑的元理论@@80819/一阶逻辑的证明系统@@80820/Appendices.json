{"hands_on_practices": [{"introduction": "一阶逻辑的核心在于句法推导（证明）与语义真值（在模型中为真）之间的深刻联系。可靠性定理保证了我们能够证明的论断必然为真，这是连接这两个世界的桥梁。本练习提供了一个动手实践的机会，通过在一个具体给定的模型中直接计算一个公式的真值，来亲手验证这一基本联系，从而加深对塔斯基语义（Tarskian semantics）基础定义的理解。[@problem_id:2979687]", "problem": "设 $\\mathcal{L}$ 为一个一阶语言，含有一个常数符号 $a$，一个一元谓词符号 $P(\\cdot)$，以及一个二元谓词符号 $R(\\cdot,\\cdot)$。考虑具有以下解释和条件的一阶逻辑的标准 Tarskian 语义。\n\n基本基础和设置：\n- 一个结构 $\\mathcal{M} = \\langle D, I \\rangle$，其中论域 $D = \\{d_0, d_1, d_2\\}$。\n- 解释 $I$ 将常数符号 $a$ 映射到 $d_0$，即 $I(a) = d_0$。\n- 一元谓词 $P$ 的解释为 $I(P) = \\{d_1\\}$。\n- 二元谓词 $R$ 的解释为 $D$ 上的恒等关系，即 $I(R) = \\{(d,d) : d \\in D\\}$。\n- 一个变量赋值 $g$ 是任意但固定的。\n\n语义子句（经典 Tarskian 语义）：\n- 对于任意变量赋值 $g$ 和项 $t$，值 $I(t)^g$ 是 $t$ 在 $I$ 和 $g$ 下的解释。\n- 对于任意公式 $\\varphi$，满足关系 $\\mathcal{M}, g \\models \\varphi$ 由标准递归子句定义：对于原子公式，$\\mathcal{M}, g \\models P(t)$ 当且仅当 $I(t)^g \\in I(P)$，且 $\\mathcal{M}, g \\models R(t_1,t_2)$ 当且仅当 $(I(t_1)^g, I(t_2)^g) \\in I(R)$；对于联结词，应用经典的真值条件；对于量词，$\\mathcal{M}, g \\models \\exists x\\, \\varphi$ 当且仅当存在 $d \\in D$ 使得 $\\mathcal{M}, g[x \\mapsto d] \\models \\varphi$，且 $\\mathcal{M}, g \\models \\forall x\\, \\varphi$ 当且仅当对于每一个 $d \\in D$，$ \\mathcal{M}, g[x \\mapsto d] \\models \\varphi$。\n\n考虑中的自然演绎（ND）规则：\n- 存在消去（$\\exists$-elimination）：从 $\\exists x\\, \\varphi(x)$，以及一个假定 $\\varphi(c)$（其中 $c$ 为一个新常数，此为见证条件）并导出 $\\psi$ 的子推导，同时消除假定 $\\varphi(c)$，且 $c$ 不在 $\\psi$ 中自由出现，也不在除 $\\varphi(c)$ 外的任何未消除的假定中出现（此为消除条件），可以推断出 $\\psi$。\n\n在给定的语言和结构中，考虑前提 $\\exists x\\, P(x)$ 和 $\\forall x\\, \\big(P(x) \\rightarrow R(a,a)\\big)$，以及一个自然演绎子推导，该推导假定 $P(c)$（其中 $c$ 是一个新常数），导出语句 $R(a,a)$，消除了假定 $P(c)$，并遵守了上述的见证和消除条件。\n\n将语句 $\\chi$ 在 $\\mathcal{M}$ 中的语义求值 $v_{\\mathcal{M}}(\\chi)$ 定义为：如果 $\\mathcal{M}, g \\models \\chi$，则 $v_{\\mathcal{M}}(\\chi) = 1$，否则 $v_{\\mathcal{M}}(\\chi) = 0$。通过在所述结构和条件下进行求值，计算 $v_{\\mathcal{M}}(R(a,a))$ 的值，结果为 $\\{0,1\\}$ 中的一个实数。如果语句被满足，则返回 $1$，否则返回 $0$。无需四舍五入。请将最终答案表示为单个数字。", "solution": "首先将对问题进行严格的验证过程。\n\n### 步骤 1：提取给定信息\n- **语言 $\\mathcal{L}$**：包含一个常数符号 $a$，一个一元谓词符号 $P(\\cdot)$，以及一个二元谓词符号 $R(\\cdot,\\cdot)$。\n- **结构 $\\mathcal{M}$**：$\\mathcal{M} = \\langle D, I \\rangle$。\n- **论域 $D$**：$D = \\{d_0, d_1, d_2\\}$。\n- **解释 $I$**：\n    - $I(a) = d_0$。\n    - $I(P) = \\{d_1\\}$。\n    - $I(R) = \\{(d,d) : d \\in D\\}$。\n- **变量赋值 $g$**：任意但固定。\n- **语义**：一阶逻辑的标准 Tarskian 语义。\n    - $\\mathcal{M}, g \\models P(t)$ 当且仅当 $I(t)^g \\in I(P)$。\n    - $\\mathcal{M}, g \\models R(t_1,t_2)$ 当且仅当 $(I(t_1)^g, I(t_2)^g) \\in I(R)$。\n    - $\\mathcal{M}, g \\models \\exists x\\, \\varphi$ 当且仅当存在 $d \\in D$ 使得 $\\mathcal{M}, g[x \\mapsto d] \\models \\varphi$。\n    - $\\mathcal{M}, g \\models \\forall x\\, \\varphi$ 当且仅当对于每一个 $d \\in D$，$ \\mathcal{M}, g[x \\mapsto d] \\models \\varphi$。\n- **自然演绎（ND）上下文**：\n    - 规则：存在消去（$\\exists$-elimination）及其标准的见证和消除条件已描述。\n    - 前提：$\\exists x\\, P(x)$ 和 $\\forall x\\, \\big(P(x) \\rightarrow R(a,a)\\big)$。\n    - 子推导：描述了一个从假定 $P(c)$ 到结论 $R(a,a)$ 的正确自然演绎子推导。\n- **语义求值函数 $v_{\\mathcal{M}}$**：对于一个语句 $\\chi$，$v_{\\mathcal{M}}(\\chi) = 1$ 若 $\\mathcal{M}, g \\models \\chi$，否则 $v_{\\mathcal{M}}(\\chi) = 0$。\n- **任务**：计算 $v_{\\mathcal{M}}(R(a,a))$ 的值。\n\n### 步骤 2：使用提取的给定信息进行验证\n对问题的有效性进行评估。\n1.  **科学依据**：该问题设定在一阶逻辑的形式框架内，特别是模型论。所有定义（语言、结构、Tarskian 语义）都是标准的且在数学上是合理的。不存在科学或事实上的不健全之处。\n2.  **适定性**：问题要求基于一个完全指定的逻辑结构和语义规则来计算一个特定值 $v_{\\mathcal{M}}(R(a,a))$。该结构是有限的，解释是明确的，这保证了任何语句的真值都是唯一可确定的。存在唯一解。\n3.  **客观性**：语言是精确、形式化的，没有歧义或主观论断。\n4.  **完备性**：所有必要的信息（论域、所有非逻辑符号的解释、语义规则）都已提供，以评估所讨论语句的真值。问题是自洽的。\n5.  **干扰信息与矛盾**：关于自然演绎证明的上下文信息对于直接对 $R(a,a)$ 进行语义求值并非必要，但它并不矛盾。实际上，它起到了一个一致性检查的作用。前提 $\\exists x\\, P(x)$ 和 $\\forall x\\, \\big(P(x) \\rightarrow R(a,a)\\big)$ 在给定的结构 $\\mathcal{M}$ 中为真，而 $R(a,a)$ 是这些前提的逻辑推论。一阶逻辑的可靠性意味着，如果前提在一个模型中为真，那么结论也必须为真。这证实了通过直接求值得出的结果，而不是制造矛盾。\n\n该问题是一致的、完备的且数学上是适定的。\n\n### 步骤 3：结论与行动\n此问题是**有效的**。将提供解答。\n\n### 解答\n目标是计算 $v_{\\mathcal{M}}(R(a,a))$ 的值，其定义为：如果语句 $R(a,a)$ 在结构 $\\mathcal{M}$ 中为真（记作 $\\mathcal{M} \\models R(a,a)$），则值为 $1$，否则为 $0$。一个语句的真值与任何特定的变量赋值 $g$ 无关，因此我们需要确定是否 $\\mathcal{M} \\models R(a,a)$。\n\n语句 $R(a,a)$ 是一个形式为 $R(t_1, t_2)$ 的原子公式，其中项 $t_1$ 和 $t_2$ 都是常数符号 $a$。\n\n根据所提供的 Tarskian 语义规则，一个结构 $\\mathcal{M}$ 满足原子公式 $R(t_1, t_2)$，当且仅当项的解释对 $(I(t_1), I(t_2))$ 是谓词符号 $R$ 的解释（即 $I(R)$）的一个成员。由于这些项是常数，它们的解释与变量赋值 $g$ 无关。因此，条件是：\n$$ \\mathcal{M} \\models R(a,a) \\iff (I(a), I(a)) \\in I(R) $$\n我们在结构 $\\mathcal{M}$ 中被给予了常数 $a$ 和谓词 $R$ 的具体解释：\n1.  常数符号 $a$ 的解释是 $I(a) = d_0$。\n2.  二元谓词符号 $R$ 的解释是论域 $D$ 上的恒等关系。论域为 $D = \\{d_0, d_1, d_2\\}$。\n\n$D$ 上的恒等关系是所有形如 $(d,d)$ 的序对的集合，其中 $d$ 是 $D$ 的一个元素。因此，$R$ 的解释明确为：\n$$ I(R) = \\{(d,d) : d \\in D\\} = \\{(d_0, d_0), (d_1, d_1), (d_2, d_2)\\} $$\n现在，我们可以将 $a$ 的解释代入满足条件中：\n$$ (I(a), I(a)) = (d_0, d_0) $$\n我们必须检查这个序对是否在集合 $I(R)$ 中：\n$$ (d_0, d_0) \\in \\{(d_0, d_0), (d_1, d_1), (d_2, d_2)\\} $$\n这个条件显然为真。序对 $(d_0, d_0)$ 确实是集合 $I(R)$ 的一个元素。\n\n由于条件 $(I(a), I(a)) \\in I(R)$ 被满足，我们得出结论：语句 $R(a,a)$ 在结构 $\\mathcal{M}$ 中为真。\n$$ \\mathcal{M} \\models R(a,a) $$\n根据函数 $v_{\\mathcal{M}}$ 的定义，如果一个语句在 $\\mathcal{M}$ 中被满足，其值为 $1$。\n$$ v_{\\mathcal{M}}(R(a,a)) = 1 $$\n\n关于前提 $\\exists x\\, P(x)$、$\\forall x\\, (P(x) \\rightarrow R(a,a))$ 和自然演绎证明的上下文信息与此结果一致。作为核对，我们可以验证 $\\mathcal{M}$ 是这些前提的一个模型。\n- $\\mathcal{M} \\models \\exists x\\, P(x)$ 因为存在 $d \\in D$ 使得 $d \\in I(P)$。具体来说，对于 $d=d_1$，我们有 $d_1 \\in I(P)=\\{d_1\\}$。\n- $\\mathcal{M} \\models \\forall x\\, (P(x) \\rightarrow R(a,a))$ 因为对于每一个 $d \\in D$，蕴含式 $P(d) \\rightarrow R(a,a)$ 为真。我们已经确定 $R(a,a)$ 在 $\\mathcal{M}$ 中为真。一个后件为真的蕴含式总是为真，无论前件的真值如何。\n由于 $\\mathcal{M}$ 是前提的模型，且 $R(a,a)$ 可以从它们形式上导出，一阶逻辑的可靠性要求 $\\mathcal{M} \\models R(a,a)$，这证实了我们的直接求值。\n最终答案是赋给真语句的数值。", "answer": "$$\\boxed{1}$$", "id": "2979687"}, {"introduction": "斯科伦化（Skolemization）是自动定理证明中的一个强大工具，它通过消除存在量词来简化公式。然而，其应用需要非常小心。本练习揭示了一个常见的错误——在其他逻辑算子的作用域内草率地应用斯科伦化——并要求你构造一个反例来证明其无效性。这项实践将磨练你的模型构建技能，并深化你对为何程序性规则（如先转换为前束范式）对保证逻辑可靠性至关重要的理解。[@problem_id:2979700]", "problem": "令 $\\sigma$ 为一个一阶签名，其包含一个二元谓词符号 $P$ 和一个常量符号 $c$。考虑非前束范式公式 $\\varphi := \\neg \\exists y \\, \\forall x \\, P(x,y)$。一种朴素但错误的实践是，直接在非前束上下文（例如在否定符号下）进行Skolem化，通过将存在量化变量 $y$ 替换为新的常量 $c$ 并去掉其量词，从而得到公式 $\\psi := \\neg \\forall x \\, P(x,c)$，这等价于 $\\exists x \\, \\neg P(x,c)$。\n\n任务：\n- 仅使用一阶语义、前束范式转换和Skolem化的基本定义，提供一个严谨的论证，说明这种朴素的Skolem化可能会改变真值。在一个固定的双元素论域上构造一个显式结构，以证明 $\\varphi$ 和 $\\psi$ 可以有不同的真值。然后，陈述正确的通用过程，即首先将公式转换为前束范式，然后以对可满足性可靠的方式进行Skolem化。\n- 令论域为 $D = \\{0,1\\}$，并且令 $D$ 上的结构将 $P$ 解释为任意子集 $P^{\\mathcal{M}} \\subseteq D \\times D$，将 $c$ 解释为 $D$ 的任意元素。用 $N$ 表示使得 $\\varphi$ 为假而其朴素的Skolem化 $\\psi$ 为真的配对 $(P^{\\mathcal{M}}, c^{\\mathcal{M}})$ 的数量。计算 $N$。\n\n将你的最终答案表示为一个精确整数（无舍入）。", "solution": "该问题提出了两个任务：首先，论证“朴素Skolem化”过程的无效性并描述正确的过程；其次，计算在一个双元素论域上，使得原始公式和经过朴素转换的公式具有特定真值关系的具体结构的数量。\n\n### 问题验证\n\n**步骤1：提取已知条件**\n- 签名 `\\sigma`：一个二元谓词符号 `P` 和一个常量符号 `c`。\n- 公式 `\\varphi := \\neg \\exists y \\, \\forall x \\, P(x,y)`。\n- 朴素生成的公式 `\\psi := \\neg \\forall x \\, P(x,c)`。\n- 第二个任务的论域：`D = \\{0,1\\}`。\n- 解释：`P`被解释为任意子集`P^{\\mathcal{M}} \\subseteq D \\times D`，`c`被解释为任意元素`c^{\\mathcal{M}} \\in D`。\n- 待计算量：`N`，即使得`\\varphi`为假且`\\psi`为真的配对`(P^{\\mathcal{M}}, c^{\\mathcal{M}})`的数量。\n\n**步骤2：使用提取的已知条件进行验证**\n该问题是定义明确的，并基于一阶逻辑的原理，特别是关于Skolem化和范式的模型论和证明论。\n- **科学基础：** 一阶语义、前束范式和Skolem化的概念是数理逻辑的基础。该问题探究了关于Skolem化应用的一个常见误解，这是一个有价值的教学和理论练习。\n- **问题适定性：** 公式 `\\varphi` 和 `\\psi` 在语法上是正确的。构造反例的任务陈述清晰。计算 `N` 的组合任务在特定论域和明确条件下是定义明确的。存在唯一的整数解 `N`。\n- **客观性：** 该问题使用形式化的数学语言陈述，没有歧义或主观性。\n\n**步骤3：结论与行动**\n问题是有效的。将提供完整解答。\n\n### 第1部分：朴素Skolem化分析\n\n朴素过程将 `\\varphi := \\neg \\exists y \\, \\forall x \\, P(x,y)` 转换为 `\\psi := \\neg \\forall x \\, P(x,c)`。这个转换是不可靠的，因为它既不保持逻辑等价性，也没有正确遵循创建等可满足公式的规则。\n\n**无效性论证**\n错误的核心在于在否定符号的作用域内错误地应用了规则。\n1.  公式 `\\varphi` 是 `\\neg \\exists y \\, \\forall x \\, P(x,y)`。根据量词和否定的标准等价关系 `(\\neg \\exists z \\, \\Phi \\equiv \\forall z \\, \\neg \\Phi)`，`\\varphi` 逻辑等价于 `\\forall y \\, \\neg (\\forall x \\, P(x,y))`。\n2.  在内部应用对偶等价关系 `(\\neg \\forall z \\, \\Phi \\equiv \\exists z \\, \\neg \\Phi)`，我们得到 `\\varphi \\equiv \\forall y \\, \\exists x \\, \\neg P(x,y)`。这是 `\\varphi` 的前束范式（PNF）。该公式断言，对于论域中的*每一个*元素 `y`，都存在某个元素 `x`（可能依赖于 `y`），使得 `P(x,y)` 为假。\n3.  公式 `\\psi` 是 `\\neg \\forall x \\, P(x,c)`，它等价于 `\\exists x \\, \\neg P(x,c)`。该公式断言，对于由 `c` 表示的*特定*元素，存在某个 `x` 使得 `P(x,c)` 为假。\n4.  公式 `\\varphi` 蕴含 `\\psi`。这是因为 `\\varphi` 对所有的 `y` 做出了一个全称断言，所以它对特定元素 `c` 也必须成立。形式上，通过全称实例化，有 `\\forall y \\, \\exists x \\, \\neg P(x,y) \\models \\exists x \\, \\neg P(x,c)`。\n5.  然而，反之不成立：`\\psi` 并不蕴含 `\\varphi`。某个性质对单个元素 `c` 成立，并不能保证它对所有元素 `y` 都成立。一个转换只有在保持某种基本的逻辑性质（如等价性或可满足性）时才是可靠的。由于等价性没有被保持，这个朴素过程作为一种通用替换规则是无效的。\n\n**反例结构**\n为了证明 `\\varphi` 和 `\\psi` 可以有不同的真值，我们需要找到一个结构 `\\mathcal{M} = (D, P^{\\mathcal{M}}, c^{\\mathcal{M}})`，使得其中一个为真而另一个为假。由于 `\\varphi \\models \\psi`，唯一可能性是 `\\psi` 为真而 `\\varphi` 为假。\n令论域为 `D = \\{0,1\\}`。\n令常量 `c` 的解释为 `c^{\\mathcal{M}} = 0`。\n令谓词 `P` 的解释为 `P^{\\mathcal{M}} = \\{(0,1), (1,1)\\}`。\n\n我们现在在这个结构 `\\mathcal{M}` 中对 `\\varphi` 和 `\\psi` 进行求值。\n- **`\\varphi`的真值**：`\\varphi` 是 `\\neg \\exists y \\, \\forall x \\, P(x,y)`。如果 `\\exists y \\, \\forall x \\, P(x,y)` 为真，则它为假。让我们检查 `\\exists y \\in \\{0,1\\}`。\n    - 对于 `y=0`：`\\forall x \\in \\{0,1\\}, P(x,0)` 是否为真？这要求 `(0,0) \\in P^{\\mathcal{M}}` 且 `(1,0) \\in P^{\\mathcal{M}}`。两者都不在 `P^{\\mathcal{M}}` 中，所以这不成立。\n    - 对于 `y=1`：`\\forall x \\in \\{0,1\\}, P(x,1)` 是否为真？这要求 `(0,1) \\in P^{\\mathcal{M}}` 且 `(1,1) \\in P^{\\mathcal{M}}`。两者都在 `P^{\\mathcal{M}}` 中，所以这成立。\n    - 因为我们找到了一个见证 `y=1`，所以公式 `\\exists y \\, \\forall x \\, P(x,y)` 在 `\\mathcal{M}` 中为真。\n    - 因此，`\\varphi` 在 `\\mathcal{M}` 中为**假**。\n- **`\\psi`的真值**：`\\psi` 是 `\\neg \\forall x \\, P(x,c)`。当 `c^{\\mathcal{M}}=0` 时，它是 `\\neg \\forall x \\, P(x,0)`。如果 `\\forall x \\, P(x,0)` 为假，则它为真。\n    - `\\forall x \\, P(x,0)` 要求 `(0,0) \\in P^{\\mathcal{M}}` 且 `(1,0) \\in P^{\\mathcal{M}}`。如前所述，这是假的。\n    - 因此，`\\neg \\forall x \\, P(x,0)` 在 `\\mathcal{M}` 中为**真**。\n\n因此，在这个结构 `\\mathcal{M}` 中，`\\varphi` 为假而 `\\psi` 为真，证明了它们不是逻辑等价的。\n\n**正确的Skolem化过程**\nSkolem化是一个消除存在量词以产生等可满足公式的过程。它必须应用于处于前束范式的公式。\n1.  **转换为PNF**：如上所示，`\\varphi := \\neg \\exists y \\, \\forall x \\, P(x,y)` 等价于 `\\varphi' := \\forall y \\, \\exists x \\, \\neg P(x,y)`。\n2.  **Skolem化**：存在量词 `\\exists x` 处于全称量词 `\\forall y` 的作用域内。要消除 `\\exists x`，我们必须引入一个*新的*函数符号，例如 `f`，其元数与管辖它的全称量词的数量相匹配。在这里，`x` 依赖于 `y`，所以我们使用一个一元函数 `f(y)`。通过去掉 `\\exists x` 并将其作用域内所有 `x` 的自由出现替换为 `f(y)`，就可以得到Skolem范式。\n3.  **结果**：`\\varphi` 的正确Skolem范式是 `\\forall y \\, \\neg P(f(y),y)`。这个公式是可满足的当且仅当原始公式 `\\varphi` 是可满足的。朴素过程在两点上是失败的：它没有从PNF开始，并且错误地使用了一个常量而不是一个函数来替换因变量。\n\n### 第2部分：计算 `N`\n\n我们需要计算在论域 `D = \\{0,1\\}` 上，使得 `\\varphi` 为假且 `\\psi` 为真的配对 `(P^{\\mathcal{M}}, c^{\\mathcal{M}})` 的数量 `N`。\n- 条件“`\\varphi`为假”意味着 `\\neg\\varphi` 为真。`\\neg\\varphi \\equiv \\exists y \\, \\forall x \\, P(x,y)`。\n- 条件“`\\psi`为真”意味着 `\\psi \\equiv \\exists x \\, \\neg P(x,c)` 为真。\n\n让我们在 `D=\\{0,1\\}` 上分析这两个条件。`P` 的一个解释是 `D \\times D = \\{(0,0), (0,1), (1,0), (1,1)\\}` 的一个子集。有 `2^4=16` 种可能的关系 `P^{\\mathcal{M}}`。\n\n**条件1：`\\exists y \\, \\forall x \\, P(x,y)` 为真。**\n这意味着存在一个 `y \\in \\{0,1\\}`，使得对于所有 `x \\in \\{0,1\\}`，配对 `(x,y)` 都在 `P^{\\mathcal{M}}` 中。\n- 对于 `y=0`：`(0,0) \\in P^{\\mathcal{M}}` 且 `(1,0) \\in P^{\\mathcal{M}}`。我们用 `C_0` 表示这个命题。\n- 对于 `y=1`：`(0,1) \\in P^{\\mathcal{M}}` 且 `(1,1) \\in P^{\\mathcal{M}}`。我们用 `C_1` 表示这个命题。\n条件1是 `C_0 \\lor C_1`。\n\n**条件2：`\\exists x \\, \\neg P(x,c)` 为真。**\n这意味着存在一个 `x \\in \\{0,1\\}`，使得配对 `(x, c^{\\mathcal{M}})` *不在* `P^{\\mathcal{M}}` 中。这等价于说 `\\forall x \\, P(x, c^{\\mathcal{M}})` 为假。\n我们必须考虑 `c` 的两种可能的解释。\n\n**情况A：`c^{\\mathcal{M}} = 0`**\n- 条件2变为 `\\exists x \\, \\neg P(x,0)`，即 `\\forall x \\, P(x,0)` 的否定。在我们的记法中，这是 `\\neg C_0`。\n- 我们需要计算满足 `(C_0 \\lor C_1) \\land \\neg C_0` 的关系 `P^{\\mathcal{M}}` 的数量。\n- 根据命题逻辑，这等价于 `\\neg C_0 \\land C_1`。\n    - `C_1` 为真意味着 `(0,1) \\in P^{\\mathcal{M}}` 且 `(1,1) \\in P^{\\mathcal{M}}`。这决定了这两个配对的真值。有 `1` 种方式。\n    - `\\neg C_0` 为真意味着并非 `(0,0) \\in P^{\\mathcal{M}}` 且 `(1,0) \\in P^{\\mathcal{M}}` 同时成立。对于配对 `((0,0), (1,0))` 有 `2^2=4` 种可能性。条件 `C_0` 仅排除了两者都为真的情况。因此，有 `4-1=3` 种方式来满足 `\\neg C_0`。\n- 在这种情况下，关系 `P^{\\mathcal{M}}` 的数量是 `3 \\times 1 = 3`。\n\n**情况B：`c^{\\mathcal{M}} = 1`**\n- 条件2变为 `\\exists x \\, \\neg P(x,1)`，即 `\\forall x \\, P(x,1)` 的否定。在我们的记法中，这是 `\\neg C_1`。\n- 我们需要计算满足 `(C_0 \\lor C_1) \\land \\neg C_1` 的关系 `P^{\\mathcal{M}}` 的数量。\n- 这等价于 `C_0 \\land \\neg C_1`。\n    - `C_0` 为真意味着 `(0,0) \\in P^{\\mathcal{M}}` 且 `(1,0) \\in P^{\\mathcal{M}}`。这有 `1` 种方式。\n    - `\\neg C_1` 为真意味着并非 `(0,1) \\in P^{\\mathcal{M}}` 且 `(1,1) \\in P^{\\mathcal{M}}` 同时成立。与上面类似，有 `2^2-1=3` 种方式。\n- 在这种情况下，关系 `P^{\\mathcal{M}}` 的数量是 `1 \\times 3 = 3`。\n\n**总数 `N`**\n总数 `N` 是来自 `c` 的所有可能解释的计数之和。`c^{\\mathcal{M}}` 有 `2` 种选择。\n`N =` (当 `c^{\\mathcal{M}}=0` 时的配对 `(P^{\\mathcal{M}}, c^{\\mathcal{M}})` 数量) + (当 `c^{\\mathcal{M}}=1` 时的配对 `(P^{\\mathcal{M}}, c^{\\mathcal{M}})` 数量)\n`N = 3 + 3 = 6`。\n\n共有 `6` 对 `(P^{\\mathcal{M}}, c^{\\mathcal{M}})` 使得 `\\varphi` 为假而 `\\psi` 为真。", "answer": "$$\n\\boxed{6}\n$$", "id": "2979700"}, {"introduction": "在探讨了公式的静态属性后，我们转向寻找证明的动态过程。尽管一个有效公式总有一个证明（依据完备性定理），但找到它可能极具挑战性。这个思想实验探讨了一种看似合理的“深度有界”证明搜索策略，并揭示了其根本上的不完备性。通过构造一个需要任意复杂项才能证明的有效公式族，你将对一阶逻辑的不可判定性以及无界搜索方法的必要性获得具体而深刻的直觉。[@problem_id:2979699]", "problem": "设 $\\mathcal{L}$ 为一个一阶语言，包含一个常量符号 $0$，一个一元函数符号 $s$，以及一个一元谓词符号 $P$。对于 $\\mathcal{L}$ 中的一个基项 $t$，我们归纳地定义其深度 $\\mathrm{dp}(t)$ 为 $\\mathrm{dp}(0) = 0$ 和 $\\mathrm{dp}(s(t)) = \\mathrm{dp}(t) + 1$。对于 $k \\in \\mathbb{N}$ 且 $k \\geq 1$，考虑 $\\mathcal{L}$-矢列\n$$\n\\Sigma_k \\;:\\; P(0),\\; \\forall x\\,(P(x) \\rightarrow P(s(x))) \\;\\;\\Rightarrow\\;\\; \\exists x\\, P(s^{k}(x)),\n$$\n其中 $s^{k}(x)$ 表示将 $s$ 作用于 $x$ 的 $k$ 次迭代。\n\n我们在 Gentzen 的经典一阶逻辑的无切矢列演算（即不含切规则的 LK）中进行推导。考虑以下朴素的深度有界证明搜索过程：将所有量词实例化限制在由 $0$ 和 $s$ 构成的深度至多为 $d$ (其中 $d \\in \\mathbb{N}$) 的基项上，并将存在-右规则的见证限制在同一基项集合上。即，在应用全称-左规则时，量化变量只能用满足 $\\mathrm{dp}(t) \\leq d$ 的基项 $t$ 来实例化；在应用存在-右规则时，见证必须是满足 $\\mathrm{dp}(t) \\leq d$ 的基项 $t$。\n\n任务：\n1. 仅从无切 LK 的标准规则和上述 $\\mathrm{dp}(\\cdot)$ 的定义出发，给出一个逻辑上完备的论证，说明对每个 $k \\geq 1$，$\\Sigma_k$ 都是有效的。\n2. 证明存在一个最小界 $d(k)$，使得对于 $\\Sigma_k$，朴素的深度有界证明搜索成功的充要条件是 $d \\geq d(k)$。\n3. 计算 $d(k)$ 作为 $k$ 的函数的精确封闭形式表达式。\n\n解释为什么你的计算展示了对于任何固定的界 $d$，朴素的深度有界证明搜索的完备性存在一个反例：即，对于有效的矢列 $\\Sigma_{d+1}$，界为 $d$ 的搜索过程会失败。\n\n你的最终答案应该是一个关于 $d(k)$ 的单个封闭形式表达式。", "solution": "我们首先证明矢列 $\\Sigma_k$ 的有效性，然后确定朴素的深度有界证明搜索为获得一个无切证明所需的最小实例化深度界 $d(k)$。\n\n步骤 1：$\\Sigma_k$ 的有效性。\n固定任意一个带有对 $0$，$s$ 和 $P$ 的解释的 $\\mathcal{L}$-结构 $\\mathfrak{M}$。假设 $\\mathfrak{M} \\vDash P(0)$ 且 $\\mathfrak{M} \\vDash \\forall x\\,(P(x) \\rightarrow P(s(x)))$。通过迭代该蕴含式，我们得到 $\\mathfrak{M} \\vDash P(s(0))$，然后是 $\\mathfrak{M} \\vDash P(s(s(0)))$，并归纳地得到对每个 $n \\in \\mathbb{N}$ 都有 $\\mathfrak{M} \\vDash P(s^{n}(0))$。特别地，$\\mathfrak{M} \\vDash P(s^{k}(0))$。因此 $\\mathfrak{M} \\vDash \\exists x\\, P(s^{k}(x))$ (见证为 $x = 0$)。所以，在每个满足前件的 $\\mathfrak{M}$ 中，后件 $\\exists x\\, P(s^{k}(x))$ 都成立，故矢列 $\\Sigma_k$ 是有效的。\n\n步骤 2：所需实例化深度的上界。\n我们展示一个仅使用深度至多为 $k-1$ 的项进行量词实例化，以及一个深度为 $0$ 的存在见证的无切推导。\n\n在无切 LK 中，为在右侧推导出 $\\exists x\\,P(s^{k}(x))$，我们只需推导出 $P(s^{k}(0))$，然后以见证项 $0$（其 $\\mathrm{dp}(0)=0$）应用 $\\exists$-右规则。我们对 $\\forall x\\,(P(x) \\rightarrow P(s(x)))$ 应用全称-左规则，实例化为以下基项：\n$$\nx := 0,\\; s(0),\\; s^{2}(0),\\; \\dots,\\; s^{k-1}(0).\n$$\n这些基项中每一个的深度都以 $k-1$ 为界。其实例为以下公式：\n$$\nP(s^{i}(0)) \\rightarrow P(s^{i+1}(0)) \\quad \\text{其中 } i = 0,1,\\dots,k-1.\n$$\n利用左侧的 $P(0)$ 和这 $k$ 个蕴含式，通过 $k$ 次应用蕴含-左规则（并根据需要使用弱化和收缩规则），即可在右侧得到 $P(s^{k}(0))$。具体来说，我们执行一种形式为\n$$\nP(0),\\; P(0)\\rightarrow P(s(0)) \\;\\vdash\\; P(s(0)),\n$$\n的正向链式推理，然后是\n$$\nP(s(0)),\\; P(s(0))\\rightarrow P(s^{2}(0)) \\;\\vdash\\; P(s^{2}(0)),\n$$\n依此类推，直到 $P(s^{k}(0))$。这就证明了存在该矢列的一个无切推导，其中仅使用了深度 $\\leq k-1$ 的全称实例化和一个深度为 $0$ 的存在见证。因此，界为 $d = k-1$ 的朴素深度有界搜索会成功。故\n$$\nd(k) \\leq k-1.\n$$\n\n步骤 3：所需实例化深度的下界。\n我们现在论证没有更小的界是足够的。考虑 $\\Sigma_k$ 的任意一个无切 LK 推导，其中所有量词实例化被限制在深度至多为 $d$ 的基项上，且所有存在-右规则的见证也被限制在深度至多为 $d$ 的基项上。我们证明如果 $d \\leq k-2$，则不存在这样的推导。\n\n定义基项 $t$ 的 $s$-高度为 $h(t) := \\mathrm{dp}(t)$。我们声称，对于从左公式多重集 $\\{P(0)\\} \\cup \\{\\forall x(P(x)\\rightarrow P(s(x)))\\}$ 到右侧原子目标 $P(s^{m}(0))$ 的无切推导，存在以下不变量。\n\n不变量：在一个无切证明的任何分支上，要推导出形如 $P(s^{m}(0))$ 的右侧原子公式，必须至少有一次应用全称-左规则，将在项 $s^{m-1}(0)$（因此深度为 $m-1$）处实例化 $\\forall x\\,(P(x)\\rightarrow P(s(x)))$。更一般地，为了通过重复使用蕴含-左规则从 $P(0)$ 逐步推进到 $P(s^{m}(0))$，该分支必须包含在 $0, s(0), \\dots, s^{m-1}(0)$ 处的实例。\n\n不变量的证明：唯一能够增加右侧 $P(\\cdot)$ 目标 $s$-高度的左公式是从全称公式得到的 $P(u)\\rightarrow P(s(u))$ 的实例。应用于 $P(u)\\rightarrow P(s(u))$ 的蕴含-左规则会创建子目标，其中一个前提是推导出前件 $P(u)$（可能通过更早的步骤），另一个分支则继续处理目标 $P(s(u))$。如果目标是 $P(s^{m}(0))$，匹配此形式的唯一方法是取 $u = s^{m-1}(0)$，使得 $P(s(u)) = P(s^{m}(0))$。沿着分支向下归纳，要推导 $P(s^{m-1}(0))$，类似地需要 $u = s^{m-2}(0)$ 的实例，依此类推，直到 $u=0$ 以连接到 $P(0)$。因此，在一条成功产生 $P(s^{m}(0))$ 的分支上，证明过程必然使用了在 $s^{m-1}(0)$ 处的实例，其深度为 $m-1$。\n\n将不变量应用于 $m = k$ 的情况，任何 $P(s^{k}(0))$ 的无切推导都需要在 $x = s^{k-1}(0)$ 处进行一次全称-左实例化，而这是一个深度为 $k-1$ 的项。因此，如果所有允许的实例化项的深度必须至多为 $d$，则我们需要 $d \\geq k-1$。等价地，\n$$\nd(k) \\geq k-1.\n$$\n\n结合上界和下界，我们得到精确值\n$$\nd(k) = k-1.\n$$\n\n对于固定深度搜索不完备性的推论：对于任意固定的界 $d \\in \\mathbb{N}$，有效的矢列 $\\Sigma_{d+1}$ 需要的最小界为 $d(d+1) = (d+1)-1 = d$。此处原文有误，应为：对于任意固定的界 $d \\in \\mathbb{N}$，考虑有效的矢列 $\\Sigma_{d+2}$。其需要的最小界是 $d(d+2)=(d+2)-1 = d+1$。因此，界为 $d$ 的朴素深度有界证明搜索无法找到 $\\Sigma_{d+2}$ 的一个证明。或者，正如原文所意，考虑矢列 $\\Sigma_{d+1}$，其需要最小界 $d(d+1)=(d+1)-1 = d$。这意味着严格小于 $d$ 的界会失败，但界 $d$ 本身是成功的。为了显示界 $d$ 会失败，我们需要考虑 $\\Sigma_{k}$ 其中 $d(k) > d$，例如 $k=d+2$。因此，界为 $d$ 的搜索过程会对 $\\Sigma_{d+2}$ 失败。这表明，当深度界是预先固定且不允许增加时，朴素的深度有界证明搜索对于一阶逻辑是不完备的。\n\n因此，作为 $k$ 的函数的最小实例化深度界是\n$$\nd(k) = k-1.\n$$", "answer": "$$\\boxed{k-1}$$", "id": "2979699"}]}