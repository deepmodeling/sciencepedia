{"hands_on_practices": [{"introduction": "这个练习将搭建起逻辑连接词的“含义”（语义）与其“形式”（句法）之间的桥梁。通过从异或（XOR）算子 $p \\oplus q$ 的真值定义出发，推导其合取范式（CNF）和析取范式（DNF），你将练习运用基本的逻辑定律。这项实践对于理解范式的最小化和素蕴涵项等核心概念至关重要。[@problem_id:2971857]", "problem": "设 $p$ 和 $q$ 为命题变量。仅使用否定 $\\lnot$、合取 $\\land$ 和析取 $\\lor$ 这三种联结词，从第一性原理出发，推导出一个与异或公式 $p \\oplus q$ 逻辑等价的合取范式（conjunctive normal form, CNF）和一个析取范式（disjunctive normal form, DNF），推导的起始点为语义定义：当且仅当 $p$ 和 $q$ 中恰好有一个为真时，$p \\oplus q$ 为真。你的推导必须仅基于经典命题逻辑的核心真值函数定律，包括结合律、交换律、分配律、德摩根对偶律以及子句和项的定义。证明你得到的 CNF 和 DNF 是素的且无冗余的，并证明在所有与 $p \\oplus q$ 等价的 CNF 和 DNF 中，它们同时最小化了 (i) 子句或项的数量以及 (ii) 文字出现的总数。\n\n设 $c$ 表示与 $p \\oplus q$ 等价的所有 CNF 中子句的最小数量，设 $t$ 表示与 $p \\oplus q$ 等价的所有 DNF 中项的最小数量。计算二项式系数 $\\binom{c+t}{c}$ 并将其作为一个精确的数值报告。无需四舍五入。", "solution": "问题陈述已经过验证，被认为是有效的。这是一个经典命题逻辑中的良定问题，没有科学谬误、歧义或矛盾。所有必要的定义和约束都已提供，可以进行严谨的推导和证明。\n\n问题的核心是基于其语义定义，为异或算子 $p \\oplus q$ 推导并验证其最小范式。\n\n**1. 析取范式 (DNF) 的推导与最小性**\n\n根据语义定义，当且仅当命题变量 $p$ 或 $q$ 中恰好有一个为真时，$p \\oplus q$ 为真。这可以表示为满足此条件的两种情况的析取：\n情况 1：$p$ 为真且 $q$ 为假。这对应于合取式 $p \\land \\lnot q$。\n情况 2：$p$ 为假且 $q$ 为真。这对应于合取式 $\\lnot p \\land q$。\n\n用析取（$\\lor$）连接这两种互斥的情况，得到与 $p \\oplus q$ 逻辑等价的表达式：\n$$ (p \\land \\lnot q) \\lor (\\lnot p \\land q) $$\n该公式是析取范式 (DNF)，因为它是合取项的析取。设这些项为 $T_1 = p \\land \\lnot q$ 和 $T_2 = \\lnot p \\land q$。\n\n为了证明这是一个最小 DNF，我们必须证明它是 $p \\oplus q$ 的所有主蕴含项的无冗余析取。\n\n公式 $F$ 的一个蕴含项是一个项 $T$，使得 $T \\Rightarrow F$。主蕴含项是这样一种蕴含项：从中移除任何文字后，它就不再是蕴含项。\n\n我们来分析项 $T_1 = p \\land \\lnot q$。\n根据构造，$ (p \\land \\lnot q) \\Rightarrow (p \\oplus q) $，所以 $T_1$ 是一个蕴含项。\n为检查其是否为素的（主的），我们尝试移除每个文字：\n- 移除 $p$ 后剩下 $\\lnot q$。命题 $\\lnot q \\Rightarrow (p \\oplus q)$ 为假。一个反例是当 $p$ 为假且 $q$ 为假时。此时，$\\lnot q$ 为真，但 $p \\oplus q$ 为假。\n- 移除 $\\lnot q$ 后剩下 $p$。命题 $p \\Rightarrow (p \\oplus q)$ 为假。一个反例是当 $p$ 为真且 $q$ 为真时。此时，$p$ 为真，但 $p \\oplus q$ 为假。\n由于没有文字可以被移除，$T_1 = p \\land \\lnot q$ 是一个主蕴含项。\n\n根据对称性，同样的推理也适用于项 $T_2 = \\lnot p \\land q$。它也是一个主蕴含项。\n\n是否存在其他主蕴含项？我们可以分析 $p \\oplus q$ 的真值表：\n| $p$ | $q$ | $p \\oplus q$ | 极小项 |\n|---|---|---|---|\n| $0$ | $0$ | $0$ | |\n| $0$ | $1$ | $1$ | $\\lnot p \\land q$ |\n| $1$ | $0$ | $1$ | $p \\land \\lnot q$ |\n| $1$ | $1$ | $0$ | |\n函数 $p \\oplus q$ 是其极小项的析取，而这些极小项恰好是 $T_1$ 和 $T_2$。在卡诺图中，这两个'1'是孤立的，不能合并成更大的组合。这直观地证实了 $\\lnot p \\land q$ 和 $p \\land \\lnot q$ 是仅有的主蕴含项。\n\n最小 DNF 由一组主蕴含项的析取构成，该主蕴含项集既是完备的（覆盖所有为真的情况），又是无冗余的（没有项可以被移除）。集合 $\\{p \\land \\lnot q, \\lnot p \\land q\\}$ 包含了该函数的所有主蕴含项。移除任何一个项都会导致表达式不再与 $p \\oplus q$ 等价。例如，移除 $\\lnot p \\land q$ 会使表达式在 $p=0, q=1$ 时为假。因此，DNF $(p \\land \\lnot q) \\lor (\\lnot p \\land q)$ 是无冗余的。\n\n该 DNF 含有 $2$ 个项。因为任何等价的 DNF 都必须由主蕴含项构成，而且我们已经证明了主蕴含项恰好有两个，所以没有等价的 DNF 能含有少于 $2$ 个项。因此，这个 DNF 在项数上是最小的。我们用 $t$ 表示这个最小数量，所以 $t=2$。\n此外，它总共包含 $4$ 个文字。因为这两个主蕴含项每个都需要两个文字，所以任何含有 $2$ 个项的 DNF 都必须至少有 $4$ 个文字。因此，这个 DNF 同时也最小化了文字出现的总数。\n\n**2. 合取范式 (CNF) 的推导与最小性**\n\n可以通过考虑原公式的否定式 $\\lnot(p \\oplus q)$ 来推导合取范式 (CNF)。一个公式为假，当且仅当其否定为真。$p \\oplus q$ 为假，当且仅当 $p$ 和 $q$ 具有相同的真值。这产生了两种情况：\n情况 1：$p$ 为真且 $q$ 为真，对应于 $p \\land q$。\n情况 2：$p$ 为假且 $q$ 为假，对应于 $\\lnot p \\land \\lnot q$。\n因此，$\\lnot(p \\oplus q)$ 的 DNF 是 $(p \\land q) \\lor (\\lnot p \\land \\lnot q)$。\n\n为了求出 $p \\oplus q$ 的 CNF，我们对它否定式的 DNF 进行取反，并应用德摩根定律：\n$$ p \\oplus q \\equiv \\lnot(\\lnot(p \\oplus q)) \\equiv \\lnot( (p \\land q) \\lor (\\lnot p \\land \\lnot q) ) $$\n应用德摩根定律 $\\lnot(A \\lor B) \\equiv \\lnot A \\land \\lnot B$：\n$$ \\equiv \\lnot(p \\land q) \\land \\lnot(\\lnot p \\land \\lnot q) $$\n对两个合取项应用德摩根定律 $\\lnot(A \\land B) \\equiv \\lnot A \\lor \\lnot B$：\n$$ \\equiv (\\lnot p \\lor \\lnot q) \\land (\\lnot(\\lnot p) \\lor \\lnot(\\lnot q)) $$\n应用双重否定律 $\\lnot(\\lnot A) \\equiv A$：\n$$ \\equiv (\\lnot p \\lor \\lnot q) \\land (p \\lor q) $$\n这个表达式是 CNF 形式。它是两个子句的合取：$C_1 = \\lnot p \\lor \\lnot q$ 和 $C_2 = p \\lor q$。\n\n为了证明其最小性，我们证明这些是 $p \\oplus q$ 仅有的主蕴含子句。公式 $F$ 的一个蕴含子句是一个子句 $C$，使得 $F \\Rightarrow C$。主蕴含子句是这样一种蕴含子句：从中移除任何文字后，它就不再是蕴含子句。\n\n我们来分析子句 $C_1 = \\lnot p \\lor \\lnot q$。\n命题 $ (p \\oplus q) \\Rightarrow (\\lnot p \\lor \\lnot q) $ 为真，因为如果 $p \\oplus q$ 为真，则 $p$ 和 $q$ 不可能同时为真，这正是 $\\lnot p \\lor \\lnot q$ 所断言的。\n为检查其是否为素的（主的），我们移除文字：\n- 移除 $\\lnot p$ 后剩下 $\\lnot q$。命题 $(p \\oplus q) \\Rightarrow \\lnot q$ 为假。一个反例是 $p=0, q=1$。此时，$p \\oplus q$ 为真，但 $\\lnot q$ 为假。\n- 移除 $\\lnot q$ 后剩下 $\\lnot p$。命题 $(p \\oplus q) \\Rightarrow \\lnot p$ 为假。一个反例是 $p=1, q=0$。此时，$p \\oplus q$ 为真，但 $\\lnot p$ 为假。\n因此，$C_1$ 是一个主蕴含子句。\n\n我们来分析子句 $C_2 = p \\lor q$。\n命题 $ (p \\oplus q) \\Rightarrow (p \\lor q) $ 为真，因为如果 $p \\oplus q$ 为真，则 $p$ 或 $q$ 中至少有一个必须为真。\n为检查其是否为素的（主的），我们移除文字：\n- 移除 $p$ 后剩下 $q$。命题 $(p \\oplus q) \\Rightarrow q$ 为假。一个反例是 $p=1, q=0$。\n- 移除 $q$ 后剩下 $p$。命题 $(p \\oplus q) \\Rightarrow p$ 为假。一个反例是 $p=0, q=1$。\n因此，$C_2$ 也是一个主蕴含子句。\n\n最小 CNF 是所有主蕴含子句的合取。$p \\oplus q$ 真值表中的两个假值条目出现在 $p=0, q=0$ 和 $p=1, q=1$。它们分别对应于极大项 $(p \\lor q)$ 和 $(\\lnot p \\lor \\lnot q)$。对'0'的卡诺图分析表明它们是孤立的，这证实了这两个是仅有的主蕴含子句。\nCNF $(\\lnot p \\lor \\lnot q) \\land (p \\lor q)$ 是无冗余的，因为移除任何一个子句都会使表达式在它本应为假的输入下为真（例如，移除 $p \\lor q$ 会使其在 $p=0, q=0$ 时为真）。\n\n该 CNF 含有 $2$ 个子句。因为主蕴含子句恰好有两个，所以没有等价的 CNF 能含有更少的子句。因此，它在子句数量上是最小的。我们用 $c$ 表示这个最小数量，所以 $c=2$。\n它包含 $4$ 个文字。因为两个主蕴含子句每个都有两个文字，所以没有含 $2$ 个子句的 CNF 能有更少的文字。因此，该 CNF 在子句数和文字数上都是最小的。\n\n**3. 最终计算**\n\n我们已经确定 $p \\oplus q$ 的 CNF 的最小子句数为 $c=2$，DNF 的最小项数为 $t=2$。\n问题要求计算二项式系数 $\\binom{c+t}{c}$。\n代入数值：\n$$ \\binom{c+t}{c} = \\binom{2+2}{2} = \\binom{4}{2} $$\n$\\binom{4}{2}$ 的值计算如下：\n$$ \\binom{4}{2} = \\frac{4!}{2!(4-2)!} = \\frac{4!}{2!2!} = \\frac{4 \\times 3 \\times 2 \\times 1}{(2 \\times 1)(2 \\times 1)} = \\frac{24}{4} = 6 $$\n结果是一个精确的数字，6。", "answer": "$$ \\boxed{6} $$", "id": "2971857"}, {"introduction": "在掌握了范式转换的基础上，本练习将探讨这些转换在实践中的局限性。通过分析一个将合取范式（CNF）“朴素地”转换为析取范式（DNF）的场景，你将揭示其背后复杂度的乘法增长原理。这项实践对于理解为何直接转换在计算上常常是不可行的，并激发对更高效算法（如SAT求解器中使用的技术）的需求至关重要。[@problem_id:2971875]", "problem": "考虑一个由原子命题通过布尔连接词析取 $\\lor$ 和合取 $\\land$ 构成的命题公式。析取范式 (DNF) 定义为文字合取的析取式，其中文字是原子命题或其否定；合取范式 (CNF) 定义为文字析取的合取式。从这些定义以及布尔代数的基本定律——结合律、交换律和分配律出发，分析一个朴素的句法过程：该过程将 $\\land$ 完全分配到 $\\lor$ 上，从而从一个析取子句的合取式生成一个 DNF，过程中不执行任何通过幂等律、吸收律或矛盾律的化简，并且仅根据其在句法树中的位置将每个生成的合取项视为不同的。特别地，以具体实例 $\\varphi = (p \\lor q \\lor r) \\land (s \\lor t \\lor u)$ 为例，启发并推导该分配过程的通用组合结构。令 $k \\in \\mathbb{N}$ 为析取子句的数量，对于每个 $i \\in \\{1,\\dots,k\\}$，令第 $i$ 个子句为 $\\bigvee_{j=1}^{n_i} a_{ij}$，其中 $a_{ij}$ 是文字，而 $n_i \\in \\mathbb{N}$ 是该子句的大小。定义 $N(n_1,\\dots,n_k)$ 为：通过对 $(\\bigvee_{j=1}^{n_1} a_{1j}) \\land \\cdots \\land (\\bigvee_{j=1}^{n_k} a_{kj})$ 重复应用分配律，并遵循上述句法约定，所得到的完全分配后的 DNF 中出现的合取项的精确数量。请从第一性原理出发，推导出一个用 $n_1,\\dots,n_k$ 表示 $N(n_1,\\dots,n_k)$ 的闭式表达式，并将该表达式作为最终答案。", "solution": "对所述问题进行有效性验证。\n\n### 步骤 1：提取已知条件\n- **领域**：命题逻辑，使用析取（$\\lor$）和合取（$\\land$）连接词。\n- **定义**：\n    - 析取范式 (DNF)：文字合取的析取。\n    - 合取范式 (CNF)：文字析取的合取。\n    - 文字：原子命题或其否定。\n- **初始公式**：一个 CNF 形式的公式，由 $\\varphi = (\\bigvee_{j=1}^{n_1} a_{1j}) \\land \\cdots \\land (\\bigvee_{j=1}^{n_k} a_{kj})$ 给出。\n- **参数**：\n    - $k \\in \\mathbb{N}$：析取子句的数量。\n    - $n_i \\in \\mathbb{N}$：第 $i$ 个子句的大小（文字数量），其中 $i \\in \\{1, \\dots, k\\}$。\n    - $a_{ij}$：文字。\n- **过程**：一个“将 $\\land$ 完全分配到 $\\lor$ 上以生成 DNF 的朴素句法过程”。\n- **过程约束**：\n    - 不通过幂等律进行化简（例如 $p \\land p \\rightarrow p$）。\n    - 不通过吸收律进行化简（例如 $p \\land (p \\lor q) \\rightarrow p$）。\n    - 不通过矛盾律进行化简（例如 $p \\land \\neg p \\rightarrow \\text{False}$）。\n    - 每个生成的合取项根据其句法来源被视为不同的。\n- **目标**：推导 $N(n_1, \\dots, n_k)$ 的闭式表达式，其定义为该过程产生的 DNF 中合取项的精确数量。\n- **示例**：提供 $\\varphi = (p \\lor q \\lor r) \\land (s \\lor t \\lor u)$ 用于启发。\n\n### 步骤 2：使用提取的已知条件进行验证\n该问题在数理逻辑的形式体系内是良定义的。\n- **科学依据**：该问题基于布尔代数和命题演算的基本原理。CNF、DNF 和分配律的定义都是标准的。\n- **适定性**：该问题的规定足够精确。其约束条件——特别是禁止使用化简规则——至关重要，消除了计数过程中的歧义。这确保了存在唯一且有意义的答案。\n- **客观性**：问题以精确、形式化的语言陈述，要求给出一个数学表达式，这是一项客观的任务。\n\n该问题没有表现出任何诸如科学不健全、不完整、矛盾或模棱两可的缺陷。它提出了一个关于逻辑中句法变换的标准的、尽管是特定的组合问题。\n\n### 步骤 3：结论与行动\n此问题是**有效的**。将推导解答。\n\n### 解的推导\n问题要求计算将一个特定的 CNF 公式仅使用分配律转换为 DNF，且不进行任何后续化简时，所产生的合取项数量 $N(n_1, \\dots, n_k)$。\n\n初始公式是 $k$ 个子句的合取：\n$$\n\\varphi = \\left(\\bigvee_{j=1}^{n_1} a_{1j}\\right) \\land \\left(\\bigvee_{j=1}^{n_2} a_{2j}\\right) \\land \\cdots \\land \\left(\\bigvee_{j=1}^{n_k} a_{kj}\\right)\n$$\n这可以更紧凑地写成：\n$$\n\\varphi = \\bigwedge_{i=1}^{k} \\left(\\bigvee_{j=1}^{n_i} a_{ij}\\right)\n$$\n通过重复应用合取对析取的分配律 $A \\land (B \\lor C) = (A \\land B) \\lor (A \\land C)$，可以将其转换为 DNF。\n\n我们首先分析最终 DNF 中各项的结构。为了从给定的 CNF 得到 DNF，我们必须将 $\\land$ 运算符分配到 $\\lor$ 运算符上，直到表达式成为一个项的析取，其中每一项都是文字的合取。仔细研究分配律可以发现，最终的每一个合取项都是通过从原始的 $k$ 个析取子句中各选择一个文字而形成的。\n\n例如，最终 DNF 中的一个项将具有以下通用形式：\n$$\n(a_{1,j_1} \\land a_{2,j_2} \\land \\cdots \\land a_{k,j_k})\n$$\n其中 $a_{1,j_1}$ 是从第一个子句中选择的文字，$a_{2,j_2}$ 是从第二个子句中选择的文字，以此类推，直到从第 $k$ 个子句中选择的 $a_{k,j_k}$。对于每个 $i \\in \\{1, \\dots, k\\}$，索引 $j_i$ 必须满足 $1 \\le j_i \\le n_i$。\n\n问题指明这是一个“朴素的句法过程”，并且禁止化简。这意味着每一种唯一的选择组合（从每个子句中选择一个文字）都将在最终的 DNF 中产生一个不同的合取项。因此，该任务简化为一个组合计数问题：有多少种方法可以形成这样的合取项？\n\n这是计数基本原理（也称为乘法法则）的直接应用。我们正在执行一个包含 $k$ 个独立选择的序列：\n1.  从第一个子句 $(\\bigvee_{j=1}^{n_1} a_{1j})$ 中选择一个文字。有 $n_1$ 个文字可供选择。\n2.  从第二个子句 $(\\bigvee_{j=1}^{n_2} a_{2j})$ 中选择一个文字。有 $n_2$ 个文字可供选择。\n3.  ...\n$k$. 从第 $k$ 个子句 $(\\bigvee_{j=1}^{n_k} a_{kj})$ 中选择一个文字。有 $n_k$ 个文字可供选择。\n\n由于从每个子句中的选择独立于从其他子句中的选择，因此不同组合的总数是每一步可用选项数量的乘积。\n\n我们用所提供的例子来说明：$\\varphi = (p \\lor q \\lor r) \\land (s \\lor t \\lor u)$。\n在这里，$k=2$，第一个子句的大小为 $n_1=3$（文字为 $\\{p, q, r\\}$），第二个子句的大小为 $n_2=3$（文字为 $\\{s, t, u\\}$）。\n为了在 DNF 中形成一个合取项，我们必须从 $\\{p, q, r\\}$ 中选一个文字，并从 $\\{s, t, u\\}$ 中选一个文字。\n可能的选择对有：\n$(p, s), (p, t), (p, u)$\n$(q, s), (q, t), (q, u)$\n$(r, s), (r, t), (r, u)$\n这在最终的 DNF 中总共得到 $3 \\times 3 = 9$ 个项：\n$(p \\land s) \\lor (p \\land t) \\lor (p \\land u) \\lor (q \\land s) \\lor (q \\land t) \\lor (q \\land u) \\lor (r \\land s) \\lor (r \\land t) \\lor (r \\land u)$.\n项的数量为 $N(3, 3) = 3 \\times 3 = 9$。\n\n推广这一结果，合取项的总数 $N(n_1, \\dots, n_k)$ 是所有子句大小的乘积：\n$$\nN(n_1, \\dots, n_k) = n_1 \\times n_2 \\times \\cdots \\times n_k\n$$\n这可以用连乘积符号以闭式形式表示：\n$$\nN(n_1, \\dots, n_k) = \\prod_{i=1}^{k} n_i\n$$\n该公式精确地计算了最终 DNF 句法树中叶节点的数量，正如问题约束所规定的那样。不进行化简的完全分配过程为每条从各输入子句中选择一个文字的可能路径生成一个输出项。", "answer": "$$\n\\boxed{\\prod_{i=1}^k n_i}\n$$", "id": "2971875"}, {"introduction": "最后的这项实践将展示合取范式（CNF）在自动定理证明中的一个强大应用。你将使用归结原理——一个直接作用于子句的核心推理规则——来证明一个给定的公式是不可满足的。这个练习不仅巩固了CNF作为许多逻辑推理算法标准输入的重要性，也为掌握一种基本的证明技术提供了动手经验。[@problem_id:2971844]", "problem": "考虑一个合取范式（CNF）的命题公式，其中合取范式（CNF）指的是由文字的析取式构成的合取式，该公式为 $(p \\lor q) \\land (\\lnot p \\lor r) \\land (\\lnot q \\lor r) \\land (\\lnot r)$。子句是文字的析取，子句的宽度定义为其所含文字的数量。仅使用命题子句的标准归结规则——即从形式为 $(A \\lor x)$ 和 $(B \\lor \\lnot x)$ 的子句可以推导出归结式 $(A \\lor B)$——为上述CNF构造一个归结反驳（推导出空子句），并在整个推导过程中，确定出现的最大子句宽度（考虑初始子句和所有产生的归结式）。将你的最终答案表示为一个指示此最大宽度的整数。无需四舍五入。", "solution": "首先对问题进行验证，以确保其是适定的、有科学依据且客观的。\n\n**步骤1：提取已知条件**\n- 合取范式（CNF）的命题公式：$(p \\lor q) \\land (\\lnot p \\lor r) \\land (\\lnot q \\lor r) \\land (\\lnot r)$。\n- CNF的定义：文字的析取式的合取。\n- 子句的定义：文字的析取。\n- 子句宽度的定义：子句中文字的数量。\n- 归结规则：从子句 $(A \\lor x)$ 和 $(B \\lor \\lnot x)$，可以推导出归结式 $(A \\lor B)$。\n- 任务是构造一个归结反驳（推导出空子句），并确定整个推导过程中出现的最大子句宽度（包括初始子句和派生子句）。\n- 最终答案必须是一个整数。\n\n**步骤2：使用提取的已知条件进行验证**\n- **有科学依据：** 该问题是命题逻辑中的一个标准练习，特别是在使用归结原理的自动定理证明领域。所有概念（CNF、子句、文字、归结）在数理逻辑中都是标准且明确定义的。\n- **适定性：** 该问题提供了一个特定的不可满足的CNF公式，并要求一个归结反驳的具体属性（最大子句宽度）。对于任何不可满足的子句集，都保证存在归结反驳。该问题要求的是在单次构造的推导中的最大宽度，而不是在所有可能推导中的最小可能最大宽度，这使得任务是明确无误的。为了确认反驳的存在，我们检查其可满足性：\n    1. 子句 $(\\lnot r)$ 意味着要使整个公式为真，$r$ 必须为假。\n    2. 将 $r=\\text{false}$ 代入 $(\\lnot p \\lor r)$ 得到 $(\\lnot p \\lor \\text{false})$，简化为 $(\\lnot p)$。因此，$p$ 必须为假。\n    3. 将 $r=\\text{false}$ 代入 $(\\lnot q \\lor r)$ 得到 $(\\lnot q \\lor \\text{false})$，简化为 $(\\lnot q)$。因此，$q$ 必须为假。\n    4. 现在我们有了赋值 $p=\\text{false}$，$q=\\text{false}$，$r=\\text{false}$。在第一个子句 $(p \\lor q)$ 上测试这个赋值，得到 $(\\text{false} \\lor \\text{false})$，其结果为假。\n    5. 由于这个由其中三个子句强制得出的赋值使得第一个子句为假，因此不存在可满足赋值。该公式是不可满足的。因此，可以构造一个归结反驳。\n- **客观性：** 问题以精确、正式的语言陈述，没有歧义或主观性。\n\n**步骤3：结论与行动**\n问题是有效的。将构造一个解。\n\n**解的构造**\n给定的CNF公式对应于以下初始子句集。我们列出每个子句及其宽度，宽度定义为它所包含的文字数量。\n- $C_1: (p \\lor q)$，宽度 $w(C_1) = 2$\n- $C_2: (\\lnot p \\lor r)$，宽度 $w(C_2) = 2$\n- $C_3: (\\lnot q \\lor r)$，宽度 $w(C_3) = 2$\n- $C_4: (\\lnot r)$，宽度 $w(C_4) = 1$\n\n初始子句中的最大宽度是 $2$。我们现在开始构造一个归结反驳，这是一系列归结规则的应用，最终推导出空子句，记为 $\\Box$。我们必须跟踪每个生成的子句的宽度。\n\n一个常见且高效的归结策略是优先处理涉及单位子句（宽度为 $1$ 的子句）的归结。我们的初始集合包含一个这样的子句，$C_4$。\n\n**步骤1：** 对 $C_2$ 和 $C_4$ 进行归结。\n我们取子句 $C_2 = (\\lnot p \\lor r)$ 和子句 $C_4 = (\\lnot r)$。我们对变量 $r$ 进行归结。在规则 $(A \\lor x)$ 和 $(B \\lor \\lnot x) \\vdash (A \\lor B)$ 中，我们有 $x = r$，$A = (\\lnot p)$，而 $B$ 是空析取。归结式是 $(A \\lor B) = (\\lnot p)$。\n- $C_5 = (\\lnot p)$。\n- 这个新子句的宽度是 $w(C_5) = 1$。\n\n**步骤2：** 对 $C_3$ 和 $C_4$ 进行归结。\n我们取子句 $C_3 = (\\lnot q \\lor r)$ 和子句 $C_4 = (\\lnot r)$。我们对变量 $r$ 进行归结。这里，$x=r$，$A=(\\lnot q)$，而 $B$ 是空的。归结式是 $(\\lnot q)$。\n- $C_6 = (\\lnot q)$。\n- 宽度是 $w(C_6) = 1$。\n\n我们的子句集现在实际上包括 $C_1, C_2, C_3, C_4, C_5, C_6$。我们有更多的单位子句可以使用了。\n\n**步骤3：** 对 $C_1$ 和 $C_5$ 进行归结。\n我们取子句 $C_1 = (p \\lor q)$ 和我们派生的子句 $C_5 = (\\lnot p)$。我们对变量 $p$ 进行归结。这里，$x=p$，$A=(q)$，而 $B$ 是空的。归结式是 $(q)$。\n- $C_7 = (q)$。\n- 宽度是 $w(C_7) = 1$。\n\n**步骤4：** 对 $C_7$ 和 $C_6$ 进行归结。\n我们取派生的子句 $C_7 = (q)$ 和 $C_6 = (\\lnot q)$。我们对变量 $q$ 进行归结。这里，$x=q$，并且 $A$ 和 $B$ 都是空析取。归结式是空子句。\n- $C_8 = \\Box$。\n- 空子句的宽度是 $w(C_8) = 0$。\n\n推导出空子句完成了反驳。在整个推导过程中出现的所有子句的集合，包括初始子句和所有归结式：\n- 初始子句：$C_1, C_2, C_3, C_4$。它们的宽度是 $\\{2, 2, 2, 1\\}$。\n- 派生的归结式：$C_5, C_6, C_7, C_8$。它们的宽度是 $\\{1, 1, 1, 0\\}$。\n\n推导过程中出现的所有子句宽度的集合是 $\\{2, 1, 0\\}$。这个集合中的最大值是 $2$。\n因此，整个推导过程中出现的最大子句宽度是 $2$。", "answer": "$$\\boxed{2}$$", "id": "2971844"}]}