{"hands_on_practices": [{"introduction": "本练习旨在展示紧致性定理如何被用来分析具有无穷多约束的逻辑系统。通过构建一个由无穷蕴含式链组成的理论 [@problem_id:2970273]，我们将探讨表面上较弱的局部条件（即任何有限子集都可满足）如何通过紧致性定理导致一个强有力的、全局确定的模型结构。这个练习将引导你亲手完成从证明有限可满足性到推导全局模型的每一步，从而深刻理解紧致性定理在模型论中的力量。", "problem": "考虑可数多个命题变量 $\\{p_{n} : n \\in \\mathbb{N}\\}$ 和由下式给出的理论 $T$\n$$T \\;=\\; \\{\\, p_{n+1} \\to p_{n} : n \\in \\mathbb{N} \\,\\} \\;\\cup\\; \\{\\, \\neg p_{0} \\,\\}.$$\n在经典命题语义中进行，其中赋值 $v$ 为每个命题变量赋予一个在 $\\{0,1\\}$ 中的真值，$1$ 表示真，$0$ 表示假，并以通常的方式扩展到所有公式：$v(\\neg \\varphi) = 1 - v(\\varphi)$，$v(\\varphi \\land \\psi) = \\min\\{v(\\varphi),v(\\psi)\\}$，$v(\\varphi \\lor \\psi) = \\max\\{v(\\varphi),v(\\psi)\\}$，以及 $v(\\varphi \\to \\psi) = \\max\\{1 - v(\\varphi), v(\\psi)\\}$。\n\n你的任务是：\n- 证明 $T$ 的每个有限子集都是可满足的，方法是为一个任意有限子集显式构造一个赋值。\n- 使用命题逻辑的紧致性定理 (CTPL)，推断 $T$ 是可满足的，并推导出一个满足 $T$ 中所有公式的特定全局满足赋值 $v$。\n- 证明对于 $T$ 的任何满足赋值 $v$，都必须有对所有 $n \\in \\mathbb{N}$ 成立的 $v(p_{n}) = 0$。\n- 定义实数\n$$S \\;=\\; \\sum_{n=0}^{\\infty} 2^{-n-1} \\, v\\!\\big(p_{n+1} \\to p_{n}\\big),$$\n并精确计算 $S$ 的值。无需四舍五入。", "solution": "问题陈述经分析是有效的。这是一个数理逻辑中的适定问题，基于经典命题语义和紧致性定理的标准定义。所有术语都有定义，任务清晰且逻辑上是顺序的。\n\n将按顺序完成这四个任务来解决问题。\n\n**任务1：证明 $T$ 的每个有限子集都是可满足的。**\n\n令 $T = \\{\\, p_{n+1} \\to p_{n} : n \\in \\mathbb{N} \\,\\} \\;\\cup\\; \\{\\, \\neg p_{0} \\,\\}$。令 $S$ 为 $T$ 的任意有限子集。我们需要构造一个赋值 $v_S$，它满足 $S$ 中的所有公式。我们根据 $\\neg p_0$ 是否属于 $S$ 来考虑两种情况。\n\n情况1: $\\neg p_0 \\notin S$。\n在这种情况下，$S$ 由有限个形如 $p_{k+1} \\to p_k$ 的公式组成。我们定义一个赋值 $v_1$，使得对所有 $n \\in \\mathbb{N}$ 都有 $v_1(p_n) = 1$。\n对于 $S$ 中任何公式 $(p_{k+1} \\to p_k)$，其在 $v_1$ 下的真值为：\n$$v_1(p_{k+1} \\to p_k) = \\max\\{1 - v_1(p_{k+1}), v_1(p_k)\\} = \\max\\{1-1, 1\\} = 1.$$\n因此，$v_1$ 满足 $S$ 中的每个公式。所以，$S$ 是可满足的。\n\n情况2: $\\neg p_0 \\in S$。\n在这种情况下，$S$ 包含公式 $\\neg p_0$ 和有限个形如 $p_{k+1} \\to p_k$ 的公式。\n我们定义一个赋值 $v_0$，使得对所有 $n \\in \\mathbb{N}$ 都有 $v_0(p_n) = 0$。\n我们检查这个赋值 $v_0$ 是否满足 $S$ 中的所有公式。\n首先，考虑公式 $\\neg p_0$：\n$$v_0(\\neg p_0) = 1 - v_0(p_0) = 1 - 0 = 1.$$\n所以，$\\neg p_0$ 被 $v_0$ 满足。\n接着，考虑 $S$ 中任何公式 $(p_{k+1} \\to p_k)$：\n$$v_0(p_{k+1} \\to p_k) = \\max\\{1 - v_0(p_{k+1}), v_0(p_k)\\} = \\max\\{1-0, 0\\} = 1.$$\n所以，$S$ 中的任何蕴含式也都被 $v_0$ 满足。\n因此，$v_0$ 满足 $S$ 中的每个公式。所以，$S$ 是可满足的。\n\n由于两种情况下我们都找到了一个满足赋值，所以 $T$ 的每个有限子集 $S$ 都是可满足的。\n\n**任务2：使用 CTPL 推断 $T$ 是可满足的，并推导出一个特定的全局满足赋值。**\n\n命题逻辑的紧致性定理 (CTPL) 指出，一个命题公式集合是可满足的，当且仅当它的每个有限子集都是可满足的。\n从任务1中，我们已经证明了 $T$ 的每个有限子集都是可满足的。根据 CTPL，我们可以推断整个无限公式集 $T$ 是可满足的。\n这意味着存在一个赋值 $v$，使得对所有 $\\phi \\in T$ 都有 $v(\\phi) = 1$。让我们来确定这样的赋值 $v$ 的性质。\n\n为了使 $v$ 满足 $T$，它必须满足 $T$ 中的每个公式。\n1.  从 $\\neg p_0 \\in T$ 可知，必须有 $v(\\neg p_0) = 1$。这意味着 $1 - v(p_0) = 1$，即 $v(p_0) = 0$。\n2.  对于每个 $n \\in \\mathbb{N}$，公式 $(p_{n+1} \\to p_n) \\in T$ 必须被满足。所以，$v(p_{n+1} \\to p_n) = 1$。这等价于 $\\max\\{1 - v(p_{n+1}), v(p_n)\\} = 1$。这个条件仅在 $1 - v(p_{n+1}) = 0$ 和 $v(p_n) = 0$ 时不成立，即 $v(p_{n+1}) = 1$ 和 $v(p_n) = 0$。因此，条件 $v(p_{n+1} \\to p_n) = 1$ 等价于陈述我们不能有 $v(p_{n+1})=1$ 和 $v(p_n)=0$。由于变量只能取 $\\{0,1\\}$ 中的值，这等价于不等式 $v(p_{n+1}) \\le v(p_n)$。\n\n结合这些条件，我们得到一个关于真值的不等式链：\n$$ \\ldots \\le v(p_{n+1}) \\le v(p_n) \\le \\ldots \\le v(p_1) \\le v(p_0) $$\n因为我们已经确定 $v(p_0) = 0$，这个链变为：\n$$ \\ldots \\le v(p_{n+1}) \\le v(p_n) \\le \\ldots \\le v(p_1) \\le v(p_0) = 0 $$\n由于真值是非负的，对于任何 $n \\in \\mathbb{N}$，我们有 $0 \\le v(p_n)$。\n结合这些，我们得到对所有 $n \\in \\mathbb{N}$ 都有 $0 \\le v(p_n) \\le 0$。\n由于 $v(p_n)$ 必须在 $\\{0, 1\\}$ 中，唯一的可能性就是对所有 $n \\in \\mathbb{N}$ 都有 $v(p_n) = 0$。\n\n因此，特定的全局满足赋值 $v$ 由对所有 $n \\in \\mathbb{N}$ 都有 $v(p_n) = 0$ 给出。我们已经在任务1（情况2）中验证了这个赋值确实满足 $T$ 中的所有公式。\n\n**任务3：证明对于 $T$ 的任何满足赋值，都必须有对所有 $n \\in \\mathbb{N}$ 成立的 $v(p_n) = 0$。**\n\n这个任务是正式证明在任务2中推导出的满足赋值的唯一性。我们对 $n$ 使用数学归纳法。\n令 $v$ 是一个满足理论 $T$ 的任意赋值。\n\n奠基步骤：对于 $n=0$。\n因为 $\\neg p_0 \\in T$，必须有 $v(\\neg p_0) = 1$。根据否定的语义定义，$1 - v(p_0) = 1$，这意味着 $v(p_0) = 0$。奠基步骤成立。\n\n归纳假设：假设对于某个整数 $k \\ge 0$，$v(p_k) = 0$ 成立。\n\n归纳步骤：我们必须证明 $v(p_{k+1}) = 0$。\n理论 $T$ 包含公式 $p_{k+1} \\to p_k$。由于 $v$ 满足 $T$，我们有 $v(p_{k+1} \\to p_k) = 1$。\n蕴含的语义给出 $\\max\\{1 - v(p_{k+1}), v(p_k)\\} = 1$。\n将归纳假设 $v(p_k) = 0$ 代入此方程，我们得到：\n$$ \\max\\{1 - v(p_{k+1}), 0\\} = 1 $$\n这个等式只在 $1 - v(p_{k+1}) = 1$ 时成立。\n这意味着 $v(p_{k+1}) = 0$。\n\n结论：根据数学归纳法原理，我们已经证明了对所有 $n \\in \\mathbb{N}$ 都有 $v(p_n) = 0$。这表明赋值 $v(p_n)=0$ 对所有 $n$ 成立是理论 $T$ 的*唯一*可能的满足赋值。\n\n**任务4：计算和 $S$。**\n\n实数 $S$ 定义为：\n$$ S \\;=\\; \\sum_{n=0}^{\\infty} 2^{-n-1} \\, v\\!\\big(p_{n+1} \\to p_{n}\\big) $$\n此表达式中的赋值 $v$ 必须是理论 $T$ 的一个满足赋值。如任务3所证明，只存在一个这样的赋值，即对所有 $n \\in \\mathbb{N}$ 都有 $v(p_n) = 0$。\n我们必须首先使用这个唯一的赋值来计算 $v(p_{n+1} \\to p_n)$ 这一项。对于任何 $n \\in \\mathbb{N}$：\n$$ v(p_{n+1} \\to p_n) = \\max\\{1 - v(p_{n+1}), v(p_n)\\} = \\max\\{1 - 0, 0\\} = 1. $$\n所以，对于求和中的每一项，因子 $v(p_{n+1} \\to p_n)$ 都等于 1。\n将此结果代入 $S$ 的表达式中：\n$$ S = \\sum_{n=0}^{\\infty} 2^{-n-1} \\cdot 1 = \\sum_{n=0}^{\\infty} \\frac{1}{2^{n+1}} $$\n这是一个几何级数。我们可以写出这些项：\n$$ S = \\frac{1}{2^1} + \\frac{1}{2^2} + \\frac{1}{2^3} + \\ldots $$\n该级数的首项 $a = \\frac{1}{2}$，公比 $r = \\frac{1}{2}$。由于 $|r| < 1$，级数收敛于：\n$$ S = \\frac{a}{1-r} = \\frac{\\frac{1}{2}}{1 - \\frac{1}{2}} = \\frac{\\frac{1}{2}}{\\frac{1}{2}} = 1. $$\n另外，我们可以平移求和索引。令 $k = n+1$。当 $n$ 从 $0$ 到 $\\infty$ 时，$k$ 从 $1$ 到 $\\infty$：\n$$ S = \\sum_{k=1}^{\\infty} \\left(\\frac{1}{2}\\right)^k = \\left(\\sum_{k=0}^{\\infty} \\left(\\frac{1}{2}\\right)^k\\right) - \\left(\\frac{1}{2}\\right)^0 = \\left(\\frac{1}{1-\\frac{1}{2}}\\right) - 1 = 2 - 1 = 1. $$\n$S$ 的值恰好是 $1$。", "answer": "$$\\boxed{1}$$", "id": "2970273"}, {"introduction": "在理解了紧致性定理的抽象存在性后，我们转向一个更具构造性的视角。本练习 [@problem_id:2970281] 介绍了一种重要的证明论工具——分析树图（analytic tableau），它不仅是判断可满足性的决策过程，其本身也体现了紧致性的核心思想。你将通过实现一个树图求解器，直观地看到一个公式集不可满足的证明总是一个有限的过程，而封闭的树图就构成了这一事实的有限“证书”，从而将抽象的定理与具体的证明构造联系起来。", "problem": "你的任务是使用分析树演算为命题公式集合实现一个形式化判定过程，并用它以有限不可满足性证书的形式展示紧致性现象。教学背景是高等研究生水平的数理逻辑。程序必须是完整且可运行的。\n\n基础与范围：严格在经典命题逻辑的框架内工作。仅使用命题公式的基本语义、可满足性的定义以及分析树的标准分解规则（不得假定任何其他元定理）。一个公式集合是可满足的，如果存在一个赋值，为每个命题变量赋以真或假，使得该集合中的每个公式都为真。如果不存在这样的赋值，则该集合是不可满足的。\n\n目标：给定一个有限的公式集合，构建一个语义树，其分支由局部自分解规则构建。当一个分支同时包含某个命题变量 $p$ 的文字 $p$ 及其否定 $\\lnot p$ 时，该分支闭合。一个集合是不可满足的，当且仅当其完整语义树中的每个终端分支都闭合。你的程序必须实现这一点，并且每当输入集合不可满足时，返回一个作为证书的输入索引的有限子集。该证书是完整语义树中所有闭合分支上，其分解导致该分支上矛盾文字的原始公式索引的并集。这个并集必须是有限的，并且其本身必须是不可满足的，从而见证了紧致性。\n\n需要支持的形式语法：命题变量是由小写字母组成的标识符，可选择后跟数字或下划线，例如，$p$、$q$、$r$、$x1$、$s\\_prime$。语法：\n- 一元否定，写作 `~` 或 `¬`。\n- 合取，写作 ``。\n- 析取，写作 `|`。\n- 蕴含，写作 `->`。\n- 用于分组的括号 `(` 和 `)`。\n\n运算符优先级从高到低：否定、合取、析取、蕴含。蕴含是右结合的。\n\n分析树分解规则（仅适用于分支上出现的公式）：\n- $\\alpha$-规则（非分支）：\n  1. `A  B` 在同一分支上产生 `A` 和 `B`。\n  2. `¬(A | B)` 在同一分支上产生 `¬A` 和 `¬B`。\n  3. `¬(A -> B)` 在同一分支上产生 `A` 和 `¬B`。\n  4. `¬¬A` 在同一分支上产生 `A`。\n- $\\beta$-规则（分支）：\n  1. `A | B` 产生两个分支：一个包含 `A`，另一个包含 `B`。\n  2. `A -> B` 产生两个分支：一个包含 `¬A`，另一个包含 `B`。\n  3. `¬(A  B)` 产生两个分支：一个包含 `¬A`，另一个包含 `¬B`。\n\n文字是形如 $p$ 或 $\\lnot p$ 的公式，其中 $p$ 是一个命题变量。\n\n分支闭合：如果一个分支同时包含某个命题变量 $p$ 的 $p$ 和 $\\lnot p$，则该分支闭合。\n\n证书累积：对于每个闭合分支，记录矛盾的文字对，并回溯到其分解产生这些文字的原始输入公式的索引。不可满足输入的证书是所有闭合终端分支上这些有限索引集的并集。这个索引集合本身必须是有限且不可满足的。\n\n程序要求：\n- 根据上述语法解析给定的公式。\n- 通过在应用 $\\beta$-规则之前重复应用 $\\alpha$-规则来构建并完全展开一个语义树，直到所有分支要么闭合，要么被文字饱和且没有规则可以再应用。\n- 将已完成的语义树中至少有一个开放终端分支的输入检测为可满足的。\n- 将已完成的语义树中所有终端分支都已闭合的输入检测为不可满足的。在这种情况下，生成有限证书，即从所有闭合分支记录的索引的并集。\n\n测试套件和预期输出：\n对于每个测试用例，输入是表示公式的字符串列表。索引按其在列表中出现的顺序为 $0,1,2,\\dots$。对于每个测试用例，所需的输出是表示证书索引的整数列表（可能为空）。空列表表示输入可满足。不适用物理单位。\n\n使用以下六个案例的测试套件：\n1. `[\"p\", \"~p\"]` 测试文字的直接闭合。预期不可满足；证书应为一个有限的索引列表。\n2. `[\"p-q\", \"p\", \"~q\"]` 测试分支蕴含，闭合由两个分支共同驱动。预期不可满足；证书应包括闭合两个分支所需的所有索引。\n3. `[\"p|q\", \"~p\"]` 测试析取与否定文字，留下一个开放分支。预期可满足；输出应为空列表。\n4. `[]` 测试空集的边界情况。预期可满足；输出应为空列表。\n5. `[\"(p-q)(q-r)\", \"p\", \"~r\"]` 测试嵌套蕴含和合取。预期不可满足；证书应为一个足以闭合所有分支的有限索引列表。\n6. `[\"(p|~p)\", \"~(q|r)\", \"q\"]` 测试包含一个重言式和一个与 $q$ 强制产生矛盾的否定析取。预期不可满足；证书应避免不相关的假设，仅包括推导矛盾所必需的那些。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表。每个元素本身必须是一个整数列表，并且所有列表（包括外部列表）都必须在没有空格的情况下打印。例如：\n`\"[[],[0,1,2],[],[],[0,1,2],[1,2]]\"`", "solution": "用户要求使用分析树方法为命题逻辑实现一个形式化判定过程。其目标是确定一个给定的有限公式集合是否是可满足的。如果它是不可满足的，该过程必须生成一个原始公式的有限子集，该子集本身是不可满足的，从而证明紧致性定理。这个不可满足性证书是通过收集在语义树的每个闭合分支上导致矛盾的原始公式的索引来构建的。\n\n问题定义明确，有坚实的数理逻辑科学基础，并且所有必要的组成部分——语法、语义和证明规则——都已指定。这是一个有效的问题。\n\n解决方案的结构如下：\n1.  **抽象语法树 (AST) 表示**：命题公式将从其字符串表示解析为一个树形数据结构，以反映其逻辑结构。这对于系统地应用分解规则至关重要。我们为变量（例如，$p$）、否定（$\\lnot A$）以及二元连接词如合取（$A \\land B$）、析取（$A \\lor B$）和蕴含（$A \\rightarrow B$）定义了类。\n\n2.  **解析器**：将实现一个递归下降解析器。它首先将输入字符串分词为一系列符号（变量、运算符、括号）。然后，它构建 AST，遵循指定的运算符优先级（$\\lnot$ 最高，然后是 ``，接着是 `|`，最后是 `->` 最低）和蕴含的右结合性。例如，表达式 $p \\rightarrow q \\rightarrow r$ 被解析为 $p \\rightarrow (q \\rightarrow r)$。\n\n3.  **语义树数据结构**：语义树是一棵树，其中每个节点代表一个分支的状态。一个分支是一组被断言为同时为真的公式。在此实现中，一个分支将是一个管理一组节点的对象，其中每个节点是一个对 $(F, S)$。这里，$F$ 是一个公式的 AST，$S$ 是一个整数索引集合，指示哪些原始输入公式促成了 $F$ 在该分支上的出现。\n\n4.  **语义树构建算法**：\n    -   该过程从一个包含输入集中所有公式的单一根分支开始。索引为 $i$ 的每个公式 $F_i$ 最初与单元素索引集 $\\{i\\}$ 相关联。\n    -   算法维护一个开放（未闭合）分支的工作列表。它迭代地选择一个分支并将其展开。\n    -   **展开策略**：为了优化过程并减少分支，总是在应用 $\\beta$-规则（分支规则）之前应用 $\\alpha$-规则（非分支规则）。在给定的分支上，算法将重复查找并应用所有可能的 $\\alpha$-规则，直到没有可应用的为止。\n        -   一个 **$\\alpha$-规则**，例如从源于 $S$ 的 $A \\land B$ 派生，将 $A$ 和 $B$ 都添加到当前分支，每个的来源都是 $S$。\n        -   一个 **$\\beta$-规则**，例如从源于 $S$ 的 $A \\lor B$ 派生，将当前分支分裂成两个新分支。一个新分支包含父分支的所有公式外加 $A$（源于 $S$），另一个包含父分支的所有公式外加 $B$（源于 $S$）。\n    -   **分支闭合**：在任何公式被添加到分支后，检查该分支是否闭合。如果一个分支包含一个文字 $L$ 及其否定 $\\lnot L$，则该分支闭合。文字是命题变量或其否定。\n    -   **证书生成**：当一个分支由于源于 $S_1$ 的公式 $L_1$ 和源于 $S_2$ 的公式 $L_2$ 之间的矛盾而闭合时，索引集 $S_1 \\cup S_2$ 被添加到一个全局证书集中。这些是导致这个特定矛盾的原始公式。\n    -   **终止**：当满足以下两个条件之一时，算法终止：\n        1.  一个开放分支变为“饱和”，意味着其上所有非文字公式都已被分解，且该分支未闭合。这表示原始公式集合是**可满足的**，因为存在一条路径对应一个一致的真值赋值。在这种情况下，过程终止并返回一个空列表。\n        2.  开放分支的工作列表变空。这意味着语义树中的每个可能路径都以一个闭合分支告终。因此，原始公式集合是**不可满足的**。最终证书是从所有闭合分支收集到的所有索引集的并集。这个有限的索引集对应于原始公式的一个有限、不可满足的子集。\n\n这个系统化的过程保证对命题逻辑是终止的，因为每个规则应用都将公式分解为更简单的子公式，而子公式的数量是有限的。该过程既是可靠的（如果它宣称一个集合不可满足，那么它确实是）也是完备的（如果一个集合是不可满足的，该过程将如此宣告）。", "answer": "```python\nimport re\nfrom collections import deque\nimport sys\n\n# The default recursion limit might be too low for parsing complex, deeply nested formulas.\n# Setting it higher is a practical precaution for a recursive descent parser.\nsys.setrecursionlimit(2000)\n\n# --- Abstract Syntax Tree (AST) Node Definitions ---\n# These classes represent the structure of a propositional formula.\n\nclass Formula:\n    \"\"\"Base class for all AST nodes.\"\"\"\n    def __eq__(self, other):\n        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__\n\n    def __hash__(self):\n        # Hashing is required to store nodes in sets.\n        return hash((self.__class__, tuple(sorted(self.__dict__.items()))))\n\nclass Var(Formula):\n    \"\"\"Represents a propositional variable.\"\"\"\n    def __init__(self, name):\n        self.name = name\n\n    def __repr__(self):\n        return f\"Var({self.name})\"\n\nclass Not(Formula):\n    \"\"\"Represents a negation.\"\"\"\n    def __init__(self, operand):\n        self.operand = operand\n\n    def __repr__(self):\n        return f\"Not({self.operand})\"\n\nclass And(Formula):\n    \"\"\"Represents a conjunction (logical AND).\"\"\"\n    def __init__(self, left, right):\n        self.left = left\n        self.right = right\n\n    def __repr__(self):\n        return f\"And({self.left}, {self.right})\"\n\nclass Or(Formula):\n    \"\"\"Represents a disjunction (logical OR).\"\"\"\n    def __init__(self, left, right):\n        self.left = left\n        self.right = right\n    \n    def __repr__(self):\n        return f\"Or({self.left}, {self.right})\"\n\nclass Imp(Formula):\n    \"\"\"Represents an implication.\"\"\"\n    def __init__(self, left, right):\n        self.left = left\n        self.right = right\n    \n    def __repr__(self):\n        return f\"Imp({self.left}, {self.right})\"\n\n# --- Parser ---\n# Converts a formula string into an AST.\n\ndef tokenize(formula_string):\n    \"\"\"Tokenizes a formula string into a list of its components.\"\"\"\n    # Normalize unicode negation to tilde and remove all whitespace.\n    s = formula_string.replace('¬', '~').replace(' ', '').replace('\\t', '')\n    # Regex to find operators, parentheses, and variable names.\n    token_regex = r\"->||\\||~|\\(|\\)|[a-z][a-z0-9_]*\"\n    return re.findall(token_regex, s)\n\nclass Parser:\n    \"\"\"A recursive descent parser for propositional logic formulas.\"\"\"\n    def __init__(self, tokens):\n        self.tokens = tokens\n        self.pos = 0\n\n    def parse(self):\n        \"\"\"Main parsing method.\"\"\"\n        if not self.tokens:\n            raise ValueError(\"Cannot parse an empty formula.\")\n        expr = self.parse_implication()\n        if self.pos  len(self.tokens):\n            raise ValueError(f\"Extra tokens at end of formula: {self.tokens[self.pos:]}\")\n        return expr\n\n    def peek(self):\n        return self.tokens[self.pos] if self.pos  len(self.tokens) else None\n\n    def consume(self, expected_token=None):\n        if self.pos >= len(self.tokens):\n            raise ValueError(\"Unexpected end of formula.\")\n        token = self.tokens[self.pos]\n        if expected_token and token != expected_token:\n            raise ValueError(f\"Expected token '{expected_token}' but got '{token}'.\")\n        self.pos += 1\n        return token\n\n    # Implication is right-associative: p -> q -> r means p -> (q -> r)\n    def parse_implication(self):\n        left = self.parse_disjunction()\n        if self.peek() == '->':\n            self.consume('->')\n            right = self.parse_implication() # Recursive call for right-associativity\n            return Imp(left, right)\n        return left\n\n    # Disjunction is left-associative: p | q | r means (p | q) | r\n    def parse_disjunction(self):\n        node = self.parse_conjunction()\n        while self.peek() == '|':\n            self.consume('|')\n            node = Or(node, self.parse_conjunction())\n        return node\n    \n    # Conjunction is left-associative: p  q  r means (p  q)  r\n    def parse_conjunction(self):\n        node = self.parse_negation()\n        while self.peek() == '':\n            self.consume('')\n            node = And(node, self.parse_negation())\n        return node\n\n    # Negation is a high-precedence prefix operator.\n    def parse_negation(self):\n        if self.peek() == '~':\n            self.consume('~')\n            return Not(self.parse_negation())\n        return self.parse_atom()\n\n    # Atoms are the base cases: variables or parenthesized sub-expressions.\n    def parse_atom(self):\n        token = self.peek()\n        if token == '(':\n            self.consume('(')\n            expr = self.parse_implication() # Start parsing from the lowest precedence.\n            self.consume(')')\n            return expr\n        elif token and re.match(r\"^[a-z][a-z0-9_]*$\", token):\n            return Var(self.consume())\n        else:\n            raise ValueError(f\"Unexpected token: {token}\")\n\n# --- Analytic Tableau Solver ---\n\nclass Branch:\n    \"\"\"Represents a single branch in the semantic tableau.\"\"\"\n    def __init__(self):\n        # A node is (ast, frozenset_of_origins)\n        self.nodes = set()\n        self.is_closed = False\n        self.closure_origins = None\n\n    def add_node(self, node_ast, origins):\n        \"\"\"Adds a formula node to the branch and checks for immediate closure.\"\"\"\n        node_tuple = (node_ast, origins)\n        if node_tuple in self.nodes:\n            return  # Avoid redundant nodes and checks\n        \n        self.nodes.add(node_tuple)\n\n        # After adding a new node, check if it creates a contradiction.\n        if isinstance(node_ast, Var):\n            # Check for existing negations of this variable.\n            negation_ast = Not(node_ast)\n            for other_node_ast, other_origins in self.nodes:\n                if other_node_ast == negation_ast:\n                    self.is_closed = True\n                    self.closure_origins = origins.union(other_origins)\n                    return\n        elif isinstance(node_ast, Not) and isinstance(node_ast.operand, Var):\n            # Check for existing positive instances of this variable.\n            positive_ast = node_ast.operand\n            for other_node_ast, other_origins in self.nodes:\n                if other_node_ast == positive_ast:\n                    self.is_closed = True\n                    self.closure_origins = origins.union(other_origins)\n                    return\n\n    def copy(self):\n        \"\"\"Creates a copy of the branch for beta-rule expansion.\"\"\"\n        new_branch = Branch()\n        new_branch.nodes = self.nodes.copy()\n        # The closure state is not copied as it's specific to the branch's evolution.\n        return new_branch\n\n    @staticmethod\n    def is_literal(node_ast):\n        \"\"\"Checks if a formula is a literal (a variable or its negation).\"\"\"\n        return isinstance(node_ast, Var) or \\\n               (isinstance(node_ast, Not) and isinstance(node_ast.operand, Var))\n\n    def find_expandable(self, expanded_on_path):\n        \"\"\"Finds the next non-literal formula to expand, prioritizing alpha-rules.\"\"\"\n        alpha_node, beta_node = None, None\n        for node in self.nodes:\n            if node in expanded_on_path or self.is_literal(node[0]):\n                continue\n\n            node_ast = node[0]\n            # Alpha-rules (non-branching)\n            if isinstance(node_ast, And) or \\\n               (isinstance(node_ast, Not) and isinstance(node_ast.operand, Or)) or \\\n               (isinstance(node_ast, Not) and isinstance(node_ast.operand, Imp)) or \\\n               (isinstance(node_ast, Not) and isinstance(node_ast.operand, Not)):\n                return node, None # Return immediately with alpha node\n\n            # Beta-rules (branching)\n            if beta_node is None:\n                if isinstance(node_ast, Or) or \\\n                   isinstance(node_ast, Imp) or \\\n                   (isinstance(node_ast, Not) and isinstance(node_ast.operand, And)):\n                    beta_node = node\n        \n        return alpha_node, beta_node\n\ndef solve_tableau(formulas):\n    \"\"\"Main function to build the tableau and determine satisfiability.\"\"\"\n    if not formulas:\n        return []\n\n    initial_branch = Branch()\n    for i, f_str in enumerate(formulas):\n        ast = Parser(tokenize(f_str)).parse()\n        initial_branch.add_node(ast, frozenset([i]))\n        if initial_branch.is_closed:\n            # The initial set is contradictory on its own.\n            return sorted(list(initial_branch.closure_origins))\n\n    # Worklist of open branches to process: (branch_object, set_of_expanded_nodes_on_path)\n    open_branches = deque([(initial_branch, frozenset())])\n    global_certificate = set()\n    \n    while open_branches:\n        current_branch, expanded_nodes = open_branches.popleft()\n\n        if current_branch.is_closed: # This check is redundant but safe\n            global_certificate.update(current_branch.closure_origins)\n            continue\n        \n        alpha_node, beta_node = current_branch.find_expandable(expanded_nodes)\n\n        # --- Alpha Rule Application ---\n        if alpha_node:\n            node_ast, origins = alpha_node\n            \n            if isinstance(node_ast, And):\n                c1, c2 = node_ast.left, node_ast.right\n            elif isinstance(node_ast, Not) and isinstance(node_ast.operand, Or):\n                c1, c2 = Not(node_ast.operand.left), Not(node_ast.operand.right)\n            elif isinstance(node_ast, Not) and isinstance(node_ast.operand, Imp):\n                c1, c2 = node_ast.operand.left, Not(node_ast.operand.right)\n            else: # Double negation: Not(Not(A))\n                c1, c2 = node_ast.operand.operand, None\n            \n            current_branch.add_node(c1, origins)\n            if c2 is not None:\n                current_branch.add_node(c2, origins)\n            \n            new_expanded = expanded_nodes.union({alpha_node})\n            \n            if current_branch.is_closed:\n                global_certificate.update(current_branch.closure_origins)\n            else:\n                # Add branch back to front of deque to continue alpha-expansion.\n                open_branches.appendleft((current_branch, new_expanded))\n            continue\n\n        # --- Beta Rule Application ---\n        if beta_node:\n            node_ast, origins = beta_node\n\n            if isinstance(node_ast, Or):\n                c1, c2 = node_ast.left, node_ast.right\n            elif isinstance(node_ast, Imp):\n                c1, c2 = Not(node_ast.left), node_ast.right\n            else: # Not(And(A, B))\n                c1, c2 = Not(node_ast.operand.left), Not(node_ast.operand.right)\n            \n            new_expanded = expanded_nodes.union({beta_node})\n\n            # Create and process Branch 1\n            branch1 = current_branch.copy()\n            branch1.add_node(c1, origins)\n            if branch1.is_closed:\n                global_certificate.update(branch1.closure_origins)\n            else:\n                open_branches.append((branch1, new_expanded))\n\n            # Create and process Branch 2\n            branch2 = current_branch.copy()\n            branch2.add_node(c2, origins)\n            if branch2.is_closed:\n                global_certificate.update(branch2.closure_origins)\n            else:\n                open_branches.append((branch2, new_expanded))\n            continue\n            \n        # --- Saturated Branch ---\n        # If no expandable nodes and branch is not closed, it's an open, saturated branch.\n        if not alpha_node and not beta_node:\n            # A satisfying assignment has been found. The set is satisfiable.\n            return []\n\n    # If the loop finishes, all branches were closed. The set is unsatisfiable.\n    return sorted(list(global_certificate))\n\ndef solve():\n    \"\"\"Runs the tableau solver on the specified test suite.\"\"\"\n    test_cases = [\n        [\"p\", \"~p\"],\n        [\"p->q\", \"p\", \"~q\"],\n        [\"p|q\", \"~p\"],\n        [],\n        [\"(p->q)(q->r)\", \"p\", \"~r\"],\n        [\"(p|~p)\", \"~(q|r)\", \"q\"]\n    ]\n\n    results = []\n    for case in test_cases:\n        result = solve_tableau(case)\n        results.append(result)\n\n    # Format the final output string exactly as required, with no spaces.\n    formatted_results = [f\"[{','.join(map(str, r))}]\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n\n```", "id": "2970281"}, {"introduction": "最后一个练习 [@problem_id:2970291] 将前面的概念推向一个实际应用的高潮。在逻辑推理中，紧致性定理的一个关键推论是：任何从无穷前提集得出的结论，实际上仅依赖于其中一个有限子集。本练习要求你设计并实现一个机械化过程，从一个给定的逻辑蕴涵关系 $\\Gamma \\models \\varphi$ 中，准确地提取出这个有限的“见证”子集 $\\Delta$。这不仅是对紧致性定理的深刻应用，也直接对应于自动推理和可解释性AI等领域中寻找基本理由的核心任务。", "problem": "给定一个可数命题前提集 $\\Gamma$ 和一个目标公式 $\\varphi$，满足 $\\Gamma \\models \\varphi$。请仅使用命题逻辑的基本事实，设计并实现一个机械化过程，该过程从 $\\Gamma$ 和 $\\varphi$ 中提取一个有限子集 $\\Delta \\subseteq \\Gamma$，以见证此蕴涵关系，即 $\\Delta \\models \\varphi$。您的过程必须仅依赖于以下基础，且不得假定任何额外的快捷事实。\n\n基础理论：\n- 命题逻辑语义：赋值（valuation）为变量赋予真值，并以常规方式扩展到公式。如果存在一个赋值使得公式集 $\\Sigma$ 中的每个公式都为真，则称 $\\Sigma$ 是可满足的。蕴涵 $\\Gamma \\models \\varphi$ 意为每个满足 $\\Gamma$ 的赋值也都满足 $\\varphi$。\n- 命题逻辑完备性定理：对于一个可靠且完备的证明系统，$\\Gamma \\models \\varphi$ 当且仅当 $\\Gamma \\vdash \\varphi$。\n- 命题逻辑紧致性定理：如果一个公式集 $\\Sigma$ 的每个有限子集都是可满足的，那么 $\\Sigma$ 也是可满足的；等价地，如果 $\\Sigma$ 是不可满足的，那么存在一个有限子集 $\\Sigma_0 \\subseteq \\Sigma$ 是不可满足的。\n\n机械化方法的设计要求：\n- 将蕴涵 $\\Gamma \\models \\varphi$ 问题归约为 $\\Gamma \\cup \\{\\neg \\varphi\\}$ 的不可满足性问题，然后利用紧致性定理提取一个有限的不可满足子集。从该子集中，返回有限见证集 $\\Delta \\subseteq \\Gamma$，使得 $\\Delta \\cup \\{\\neg \\varphi\\}$ 不可满足，从而有 $\\Delta \\models \\varphi$。\n- 使用针对合取范式 (CNF) 公式的命题逻辑完备决策过程来实现可满足性检查。为此，您可以使用 Davis–Putnam–Logemann–Loveland (DPLL) 过程。\n- 通过迭代子句删除实现不可满足核的提取：给定一个不可满足的 CNF $\\Sigma$，重复尝试移除一个子句并检查可满足性；如果余下部分仍然不可满足，则保持该子句被移除的状态。此方法可生成一个在包含关系下极小的有限子集。\n\n表示方式与约束：\n- 变量由正整数表示。例如，变量 $p$ 可编码为 $1$，变量 $q$ 可编码为 $2$，以此类推。\n- 文字由带符号整数表示：正整数 $k$ 编码对应于变量 $k$ 的文字，负整数 $-k$ 编码其否定。\n- 子句表示为整数列表，编码文字的析取（逻辑“或”）。例如，子句 $p \\lor \\neg q$ 编码为 $[1,-2]$。\n- CNF 公式（子句的合取）表示为子句列表。例如，$(p) \\land (\\neg p \\lor q)$ 编码为 $[[1],[-1,2]]$。\n- 目标公式 $\\varphi$ 必须是以下受限形式之一，以确保 $\\neg \\varphi$ 具有直接的 CNF 表示：\n    1. 单个文字 $l$（类型“literal”），编码为整数。那么 $\\neg \\varphi$ 是单位子句 $[-l]$。\n    2. 单个子句 $C$（类型“clause”），编码为整数列表。那么 $\\neg \\varphi$ 是通过对 $C$ 中每个文字取反而获得的单位子句的合取。\n    3. 文字的合取 $L$（类型“conjunction”），编码为整数列表。那么 $\\neg \\varphi$ 是由 $L$ 中每个文字的否定组成的单个子句。\n\n您的程序必须：\n- 使用上述表示规则构建 $\\Sigma = \\Gamma \\cup \\{\\neg \\varphi\\}$。\n- 使用一个完备的 CNF 决策过程检查 $\\Sigma$ 是否不可满足。\n- 通过迭代删除，提取一个在包含关系下极小的有限不可满足核 $S \\subseteq \\Sigma$。\n- 输出 $\\Delta = S \\setminus \\{\\neg \\varphi\\}$（关于子句重数的多重集差集），这是 $\\Gamma$ 的一个有限子集，用于见证 $\\Delta \\models \\varphi$。\n\n测试套件：\n提供一个程序，运行以下测试用例，并为每个用例打印有限见证集 $\\Delta$。\n\n- 测试用例 1（正常路径；文字目标）：$\\Gamma = [[1],[-1,2]]$，目标类型“literal”，$\\varphi = 2$。\n  解释：$p$ 是 $1$，$q$ 是 $2$。前提断言 $p$ 和 $\\neg p \\lor q$。目标是 $q$。\n- 测试用例 2（子句目标；析取）：$\\Gamma = [[1]]$，目标类型“clause”，$\\varphi = [1,2]$。\n  解释：前提断言 $p$。目标是 $p \\lor q$。\n- 测试用例 3（合取目标；两个文字）：$\\Gamma = [[1],[2]]$，目标类型“conjunction”，$\\varphi = [1,2]$。\n  解释：前提断言 $p$ 和 $q$。目标是 $p \\land q$。\n- 测试用例 4（边界情况；$\\Gamma$ 为空时的重言式目标）：$\\Gamma = []$，目标类型“clause”，$\\varphi = [1,-1]$。\n  解释：目标是 $p \\lor \\neg p$，这是一个重言式，因此被空集蕴涵。\n\n答案规范：\n- 对于每个测试用例，答案是有限见证子集 $\\Delta \\subseteq \\Gamma$，表示为子句列表（每个子句是整数列表）。\n- 您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表，每个 $\\Delta$ 序列化为其嵌套列表表示。例如，输出格式必须严格符合 $[r_1,r_2,r_3,r_4]$ 的形式，其中每个 $r_i$ 是对应测试用例的嵌套列表。\n\n此问题不涉及物理单位、角度单位或百分比；所有输出均为纯逻辑形式，且必须按指定的单行格式打印。", "solution": "该问题要求设计并实现一个过程，在给定一个可数前提集 $\\Gamma$ 且蕴涵关系 $\\Gamma \\models \\varphi$ 成立的情况下，找到一个有限的前提集 $\\Delta \\subseteq \\Gamma$ 逻辑上蕴涵结论 $\\varphi$。该过程必须从命题逻辑的第一性原理构建，即蕴涵的语义、完备性定理和紧致性定理。\n\n解决方案建立在命题逻辑中的一个关键关系之上：语义形式的演绎定理。蕴涵 $\\Gamma \\models \\varphi$ 成立，当且仅当公式集 $\\Sigma = \\Gamma \\cup \\{\\neg\\varphi\\}$ 是不可满足的。\n\n我们来确立这个等价关系。\n1. 假设 $\\Gamma \\models \\varphi$。这意味着任何使 $\\Gamma$ 中所有公式为真的赋值（变量的真值分配）也必须使 $\\varphi$ 为真。设 $v$ 是这样一个赋值。那么对于所有 $\\gamma \\in \\Gamma$，$v(\\gamma) = \\text{真}$，这蕴涵了 $v(\\varphi) = \\text{真}$。因此，$v(\\neg\\varphi) = \\text{假}$。这表明没有赋值 $v$ 能同时满足 $\\Gamma$ 中的所有公式又满足 $\\neg\\varphi$。所以，集合 $\\Sigma = \\Gamma \\cup \\{\\neg\\varphi\\}$ 是不可满足的。\n\n2. 假设 $\\Gamma \\cup \\{\\neg\\varphi\\}$ 是不可满足的。这意味着不存在一个赋值能使 $\\Gamma$ 中所有公式为真且使 $\\neg\\varphi$ 为真。考虑任何满足所有 $\\Gamma$ 的赋值 $v$（即，对所有 $\\gamma \\in \\Gamma$，$v(\\gamma) = \\text{真}$）。对于这样的 $v$，必然有 $v(\\neg\\varphi) = \\text{假}$，否则 $v$ 将成为 $\\Gamma \\cup \\{\\neg\\varphi\\}$ 的一个满足赋值。如果 $v(\\neg\\varphi) = \\text{假}$，那么必然有 $v(\\varphi) = \\text{真}$。这对任何满足 $\\Gamma$ 的赋值 $v$ 都成立，而这正是蕴涵的定义，即 $\\Gamma \\models \\varphi$。\n\n给定 $\\Gamma \\models \\varphi$，我们已经确定了 $\\Sigma = \\Gamma \\cup \\{\\neg\\varphi\\}$ 是一个不可满足的公式集。问题指明 $\\Gamma$ 是可数的，但可能是无限的。命题逻辑的紧致性定理指出，如果一个公式集是不可满足的，那么它必然存在一个也是不可满足的有限子集。\n\n将紧致性定理应用于 $\\Sigma$，必然存在一个有限子集 $S \\subseteq \\Sigma$，使得 $S$ 是不可满足的。由于 $S$ 是 $\\Gamma \\cup \\{\\neg\\varphi\\}$ 的一个有限子集，我们可以将其划分为两部分：一部分来自 $\\Gamma$，另一部分来自 $\\{\\neg\\varphi\\}$。我们定义 $\\Delta = S \\cap \\Gamma$。另一部分是 $S \\cap \\{\\neg\\varphi\\}$。因此，$S = \\Delta \\cup (S \\cap \\{\\neg\\varphi\\})$。\n\n由于 $S$ 是不可满足的，蕴涵 $\\Delta \\models \\varphi$ 必须成立。要理解这一点，请注意 $S$ 不可满足等价于 $\\Delta \\cup (S \\cap \\{\\neg\\varphi\\}) \\models \\bot$（其中 $\\bot$ 是矛盾）。这意味着对于任何满足 $\\Delta$ 的赋值 $v$，它必不能满足 $S \\cap \\{\\neg\\varphi\\}$。因为 $S \\cap \\{\\neg\\varphi\\} \\subseteq \\{\\neg\\varphi\\}$，这意味着 $v$ 必须使 $\\neg\\varphi$ 为假，从而使 $\\varphi$ 为真。因此，任何满足 $\\Delta$ 的赋值也必然满足 $\\varphi$，这正是 $\\Delta \\models \\varphi$ 的定义。由于 $S$ 是有限的，其子集 $\\Delta$ 也是有限的。因此，$\\Delta$ 就是我们寻求的有限见证集。\n\n实现这一构造性证明的机械化过程如下：\n\n**步骤1：公式表示与 $\\Sigma$ 的构建**\n所有公式都以合取范式（CNF）表示。一个公式是子句的列表，每个子句是文字的列表，每个文字是带符号的整数。前提 $\\Gamma$ 以此形式提供。目标公式 $\\varphi$ 被限制为某些形式，以使其否定 $\\neg\\varphi$ 具有直接的 CNF 表示。\n- 如果 $\\varphi$ 是一个文字 $l$（例如，变量 $k$ 为 $k$，$\\neg k$ 为 $-k$），那么 $\\neg\\varphi$ 是文字 $\\neg l$，对应于单位子句 $[-l]$。\n- 如果 $\\varphi$ 是一个子句 $C = [l_1, l_2, \\ldots, l_m]$，那么 $\\neg\\varphi = \\neg(l_1 \\lor \\ldots \\lor l_m) \\equiv (\\neg l_1 \\land \\ldots \\land \\neg l_m)$。这是一个单位子句的合取 $\\{[-l_1], [-l_2], \\ldots, [-l_m]\\}$。\n- 如果 $\\varphi$ 是文字的合取 $L = [l_1, l_2, \\ldots, l_m]$，那么 $\\varphi \\equiv l_1 \\land \\ldots \\land l_m$。因此 $\\neg\\varphi = \\neg(l_1 \\land \\ldots \\land l_m) \\equiv (\\neg l_1 \\lor \\ldots \\lor \\neg l_m)$。这是一个单一子句 $[-l_1, -l_2, \\ldots, -l_m]$。\n通过取 $\\Gamma$ 中的子句和从 $\\neg\\varphi$ 派生的子句的并集，来构成子句集 $\\Sigma$。\n\n**步骤2：可满足性检查**\n要检查一个子句集是否不可满足，需要一个完备的决策过程。Davis-Putnam-Logemann-Loveland (DPLL) 算法就是这样一个过程。DPLL 是一种递归的、基于回溯的搜索，用于寻找满足赋值。其核心组成部分是：\n- **单位传播 (Unit Propagation)：** 如果一个子句是单位子句（只包含一个文字），那么该文字必须被赋予使其为真的真值。这个赋值可能会简化其他子句，可能产生新的单位子句。此过程重复进行，直到找不到更多单位子句。如果生成了空子句（例如，从一个子句 $[p]$ 和另一个子句 $[\\neg p]$），则发现矛盾，公式不可满足。\n- **分支 (Branching / Splitting Rule)：** 如果单位传播未能解决公式，则选择一个未赋值的变量。算法进行两次递归调用：一次将该变量赋值为真，一次赋值为假。如果任一分支找到了满足赋值，则公式是可满足的。如果两个分支都导致矛盾，则公式是不可满足的。\n\n**步骤3：不可满足核提取**\n紧致性定理保证了有限不可满足子集 $S$ 的存在。初始集 $\\Sigma = \\Gamma \\cup \\{\\neg\\varphi\\}$ 本身就是一个候选集，根据问题前提，它保证是不可满足的。目标是找到一个包含关系下极小的不可满足核。指定的方法是迭代删除：\n1. 从完整的子句集 $S = \\Sigma$ 开始。\n2. 遍历 $S$ 中的每个子句 $C$。\n3. 暂时移除 $C$，形成新集合 $S' = S \\setminus \\{C\\}$。\n4. 使用 DPLL 求解器检查 $S'$ 是否可满足。\n5. 如果 $S'$ 仍然不可满足，意味着子句 $C$ 对于矛盾并非必不可少。可以将其从工作集中永久移除。\n6. 如果 $S'$ 变为可满足，则子句 $C$ 对矛盾是必不可少的，必须保留。\n遍历所有子句后，剩下的集合就是一个极小不可满足核。请注意，结果可能取决于删除的顺序，但任何这样的核都是有效的。\n\n**步骤4：见证集提取**\n设极小不可满足核为 $S_{core}$。这个核由源自 $\\Gamma$ 的子句和源自 $\\neg\\varphi$ 的子句组成。为了分离出见证集 $\\Delta \\subseteq \\Gamma$，我们执行多重集差集运算：$\\Delta = S_{core} \\setminus \\text{clauses}(\\neg\\varphi)$。最终得到的集合 $\\Delta$ 只包含来自原始前提 $\\Gamma$ 的子句，并且是蕴涵关系 $\\Gamma \\models \\varphi$ 所需的有限见证。为正确实现此步骤，必须在整个核提取过程中跟踪每个子句的来源。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and print results.\n    \"\"\"\n    test_cases = [\n        {\"gamma\": [[1], [-1, 2]], \"phi_type\": \"literal\", \"phi\": 2},\n        {\"gamma\": [[1]], \"phi_type\": \"clause\", \"phi\": [1, 2]},\n        {\"gamma\": [[1], [2]], \"phi_type\": \"conjunction\", \"phi\": [1, 2]},\n        {\"gamma\": [], \"phi_type\": \"clause\", \"phi\": [1, -1]},\n    ]\n\n    results = []\n    for case in test_cases:\n        witness = find_witness(case[\"gamma\"], case[\"phi_type\"], case[\"phi\"])\n        results.append(witness)\n\n    # Serialize results to the specified string format\n    # str([[1],[-1,2]]) -> \"[[1], [-1, 2]]\", so we remove spaces.\n    results_str = [str(res).replace(\" \", \"\") for res in results]\n    print(f\"[{','.join(results_str)}]\")\n\ndef find_witness(gamma, phi_type, phi):\n    \"\"\"\n    Constructs Sigma, extracts the unsatisfiable core, and returns the witness Delta.\n    \"\"\"\n    neg_phi_clauses = []\n    if phi_type == \"literal\":\n        neg_phi_clauses.append([-phi])\n    elif phi_type == \"clause\":\n        for literal in phi:\n            neg_phi_clauses.append([-literal])\n    elif phi_type == \"conjunction\":\n        neg_phi_clauses.append([-literal for literal in phi])\n    \n    # Label clauses by origin to extract Delta later\n    gamma_labeled = [(tuple(sorted(c)), 'gamma') for c in gamma]\n    neg_phi_labeled = [(tuple(sorted(c)), 'neg_phi') for c in neg_phi_clauses]\n    \n    sigma_labeled = gamma_labeled + neg_phi_labeled\n\n    # The problem guarantees Sigma is unsatisfiable.\n    # unsat_core_labeled = extract_unsat_core(sigma_labeled)\n    unsat_core_labeled = extract_unsat_core_iterative(sigma_labeled)\n\n    # Witness Delta is the set of clauses from the core that originated from Gamma.\n    # Convert back from sorted tuples to original lists by finding them in input Gamma.\n    # Since Gamma might have duplicate clauses, we handle it as a multiset.\n    gamma_copy = list(gamma)\n    delta = []\n    \n    core_gamma_tuples = [c_tuple for c_tuple, origin in unsat_core_labeled if origin == 'gamma']\n    \n    # To reconstruct the original unsorted clauses from gamma\n    gamma_tuples = [tuple(sorted(c)) for c in gamma_copy]\n    \n    # This reconstruction handles multisets properly.\n    for core_tuple in core_gamma_tuples:\n        for i, gamma_tuple in enumerate(gamma_tuples):\n            if core_tuple == gamma_tuple:\n                delta.append(gamma_copy.pop(i))\n                gamma_tuples.pop(i)\n                break\n                \n    return delta\n\ndef extract_unsat_core_iterative(sigma_labeled):\n    \"\"\"\n    Extracts an inclusion-minimal unsatisfiable core by iterative clause deletion.\n    \"\"\"\n    unsat_core = list(sigma_labeled)\n    i = 0\n    while i  len(unsat_core):\n        # Create a candidate core by removing the i-th clause\n        candidate_core = unsat_core[:i] + unsat_core[i+1:]\n        \n        # is_sat_labeled expects list of tuples (clause_tuple, origin)\n        if not is_sat_labeled(candidate_core):\n            # If still unsatisfiable, the clause was redundant.\n            # The removal is permanent. Update the core.\n            unsat_core = candidate_core\n            # Do not increment i, as the list has shrunk and the new\n            # element at index i must be checked.\n        else:\n            # If it becomes satisfiable, the clause is essential.\n            # Keep it and move to the next one.\n            i += 1\n    return unsat_core\n\n\ndef is_sat_labeled(labeled_clauses):\n    \"\"\"\n    Wrapper for DPLL that takes labeled clauses.\n    \"\"\"\n    if not labeled_clauses:\n        return True\n    clauses = [list(c_tuple) for c_tuple, _ in labeled_clauses]\n    return is_sat(clauses)\n\ndef is_sat(clauses):\n    \"\"\"\n    Top-level DPLL SAT solver function.\n    \"\"\"\n    return dpll(clauses, set())\n\ndef dpll(clauses, assignment):\n    \"\"\"\n    Recursive DPLL algorithm implementation.\n    'assignment' is a set of literals assumed to be true.\n    \"\"\"\n    # 1. Simplify clauses based on the current assignment\n    simplified_clauses = []\n    \n    for c in clauses:\n        new_clause = []\n        is_clause_satisfied = False\n        for literal in c:\n            if literal in assignment:\n                is_clause_satisfied = True\n                break\n            if -literal not in assignment:\n                new_clause.append(literal)\n        \n        if not is_clause_satisfied:\n            if not new_clause:\n                # Contradiction: an empty clause was generated\n                return False\n            simplified_clauses.append(new_clause)\n\n    if not simplified_clauses:\n        # All clauses were satisfied\n        return True\n\n    # 2. Iterative Unit Propagation\n    unit_literals = {c[0] for c in simplified_clauses if len(c) == 1}\n    if unit_literals:\n        # If a literal and its negation are both units, it's a contradiction.\n        if any(-l in unit_literals for l in unit_literals):\n            return False\n        \n        new_assignment = assignment.union(unit_literals)\n        # Recurse with the new assignment due to unit propagation\n        if len(new_assignment) > len(assignment): # New information was added\n            return dpll(simplified_clauses, new_assignment)\n\n    # 3. Branching (Splitting)\n    # Find an unassigned variable to branch on.\n    remaining_vars = set()\n    for c in simplified_clauses:\n        for literal in c:\n            remaining_vars.add(abs(literal))\n            \n    if not remaining_vars:\n        # This state is unexpected if clauses are not empty.\n        # It would mean non-empty clauses with no variables.\n        # However, if all variables are assigned and clauses are not all satisfied, it's unsat.\n        return False\n        \n    # Pick a variable to branch on\n    var_to_branch = remaining_vars.pop()\n\n    # Try assigning the variable to be true\n    if dpll(simplified_clauses, assignment.union({var_to_branch})):\n        return True\n    \n    # If that fails, try assigning it to be false\n    return dpll(simplified_clauses, assignment.union({-var_to_branch}))\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2970291"}]}