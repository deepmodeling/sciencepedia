{"hands_on_practices": [{"introduction": "完备集的核心思想是，集合中的联结词不能都属于某个特定的“不良”函数族（即极大克隆）。本练习将聚焦于其中一类——仿射函数族。通过将布尔函数转换为其在有限域 $\\mathbb{F}_2$ 上的唯一多项式表示，即代数范式（ANF），我们可以通过分析其代数次数来直接判断其仿射性，这对于理解极大克隆的代数结构至关重要。[@problem_id:2968168]", "problem": "将 $\\{0,1\\}$ 视为双元素有限域 $\\mathbb{F}_{2}$，将逻辑异或写为 $\\mathbb{F}_{2}$ 中的加法 $\\oplus$，将逻辑合取写为乘法。一个布尔函数 $f \\colon \\{0,1\\}^{n} \\to \\{0,1\\}$ 在 $\\mathbb{F}_{2}$ 上具有如下形式的代数范式 (ANF) 展开式：\n$$\nf(x_{1},\\dots,x_{n}) \\;=\\; a_{\\varnothing} \\;\\oplus\\; \\bigoplus_{i} a_{\\{i\\}} x_{i} \\;\\oplus\\; \\bigoplus_{i<j} a_{\\{i,j\\}} x_{i} x_{j} \\;\\oplus\\; \\cdots \\;\\oplus\\; a_{\\{1,\\dots,n\\}} x_{1} \\cdots x_{n},\n$$\n其中系数 $a_{S} \\in \\{0,1\\}$。$f$ 的代数次数是使得 $a_{S} = 1$ 的最大基数 $|S|$。如果一个布尔函数的代数次数至多为 $1$，则称其为仿射函数。仿射克隆是所有仿射布尔函数的集合，并且在叠加（复合）、变量识别和引入哑变量的操作下是封闭的。\n\n考虑基本联结词的候选集合 $\\mathcal{C} = \\{f,g,h\\}$，其中\n- $f(x,y,z) := (x \\leftrightarrow y) \\oplus z$ 用于三元输入 $x,y,z \\in \\{0,1\\}$，其中 $x \\leftrightarrow y$ 是逻辑等价，\n- $g(x,y,z) := (x \\lor y) \\land \\neg z$ 用于三元输入，使用逻辑析取和逻辑否定，\n- $h(t) := \\neg t$ 用于一元输入 $t \\in \\{0,1\\}$。\n\n计算 $\\mathcal{C}$ 中每个基本联结词的代数范式 (ANF)，确定它们的代数次数，并利用这些信息判断由 $\\mathcal{C}$ 生成的克隆 $Cl(\\mathcal{C})$ 是否包含于仿射克隆中。将您的判断报告为指示符\n$$\n\\Delta \\;=\\; \\begin{cases}\n1 & \\text{如果 } Cl(\\mathcal{C}) \\text{ 包含于仿射克隆中,}\\\\\n0 & \\text{否则.}\n\\end{cases}\n$$\n\n您的最终答案必须是单个数字 $\\Delta$。无需四舍五入。", "solution": "我们从基本原理出发。在 $\\mathbb{F}_{2}$ 上，逻辑异或对应于加法 $\\oplus$，逻辑合取对应于乘法，逻辑否定对应于映射 $x \\mapsto 1 \\oplus x$。布尔函数的代数范式 (ANF) 是其在 $\\mathbb{F}_{2}$ 上关于变量 $x_{i}$ 的唯一多项式表示，其中每个变量满足 $x_{i}^{2} = x_{i}$。\n\n步骤1：计算 $f(x,y,z) := (x \\leftrightarrow y) \\oplus z$ 的 ANF。\n\n我们回顾恒等式 $x \\leftrightarrow y = \\neg(x \\oplus y)$ 以及 $\\mathbb{F}_{2}$ 中逻辑否定的基本性质：$\\neg u = 1 \\oplus u$。因此，\n$$\nx \\leftrightarrow y \\;=\\; 1 \\oplus (x \\oplus y) \\;=\\; 1 \\oplus x \\oplus y.\n$$\n由此可得\n$$\nf(x,y,z) \\;=\\; (x \\leftrightarrow y) \\oplus z \\;=\\; (1 \\oplus x \\oplus y) \\oplus z \\;=\\; 1 \\oplus x \\oplus y \\oplus z.\n$$\n因此，$f$ 的 ANF 是\n$$\nf(x,y,z) \\;=\\; 1 \\oplus x \\oplus y \\oplus z,\n$$\n其代数次数为 $1$，所以 $f$ 是仿射的。\n\n步骤2：计算 $g(x,y,z) := (x \\lor y) \\land \\neg z$ 的 ANF。\n\n我们使用已知的析取 ANF 恒等式：\n$$\nx \\lor y \\;=\\; x \\oplus y \\oplus x y,\n$$\n这可以通过注意到在整数上 $x \\lor y = x + y - xy$ 然后模2简化，从真值表中得到验证，或者直接通过布尔环表示得到。\n\n否定是 $\\neg z = 1 \\oplus z$。合取是在 $\\mathbb{F}_{2}$ 上的多项式乘法。因此，\n$$\ng(x,y,z) \\;=\\; (x \\lor y) \\land \\neg z \\;=\\; (x \\oplus y \\oplus x y)(1 \\oplus z).\n$$\n在 $\\mathbb{F}_{2}$ 中展开，\n\\begin{align*}\ng(x,y,z)\n&= (x \\oplus y \\oplus x y) \\oplus (x \\oplus y \\oplus x y) z \\\\\n&= x \\oplus y \\oplus x y \\oplus x z \\oplus y z \\oplus x y z.\n\\end{align*}\n因此，$g$ 的 ANF 是\n$$\ng(x,y,z) \\;=\\; x \\oplus y \\oplus x y \\oplus x z \\oplus y z \\oplus x y z.\n$$\n$g$ 的代数次数是 $3$，因为单项式 $x y z$ 的系数是 $1$。所以 $g$ 不是仿射的。\n\n步骤3：计算 $h(t) := \\neg t$ 的 ANF。\n\n使用 $\\mathbb{F}_{2}$ 中的否定运算，\n$$\nh(t) \\;=\\; 1 \\oplus t.\n$$\n这是仿射的，代数次数为 $1$。\n\n步骤4：判断 $Cl(\\mathcal{C})$ 是否包含于仿射克隆中。\n\n根据定义，$Cl(\\mathcal{C})$ 是包含 $\\mathcal{C}$ 中基本联结词的最小克隆；特别是，它包含每个基本联结词作为其元素。仿射克隆是所有代数范式 (ANF) 的代数次数至多为1的布尔函数的集合。我们已经发现：\n- $f$ 是仿射的（次数为 $1$），\n- $g$ 不是仿射的（次数为 $3$），\n- $h$ 是仿射的（次数为 $1$）。\n\n由于 $g \\in \\mathcal{C} \\subseteq Cl(\\mathcal{C})$ 且 $g$ 不是仿射的，立即可以得出 $Cl(\\mathcal{C})$ 不包含于仿射克隆中。除了观察到一个非仿射生成元本身就证明了非包含关系之外，无需再援引复合封闭性。\n\n因此，所要求的指示符为\n$$\n\\Delta \\;=\\; 0.\n$$", "answer": "$$\\boxed{0}$$", "id": "2968168"}, {"introduction": "Post 定理为判断联结词集的功能完备性提供了一个完整而有效的判据：一个集合是完备的，当且仅当它不被任何一个极大克隆所包含。本练习旨在将这个深刻的理论结果转化为一个实用的算法。你将通过编程，为任意给定的联结词实现针对保持0、保持1、单调、自对偶和仿射这五个性质的系统性检测，从而将抽象的理论定义内化为具体的计算过程。[@problem_id:2968171]", "problem": "给定一个有限的布尔联结词集合，每个联结词由其目数和真值表表示。一个布尔联结词是一个$n$-元的布尔函数 $f:\\{0,1\\}^n \\to \\{0,1\\}$。如果包含布尔联结词集合 $\\mathcal{C}$ 的最小克隆（即，在函数复合下封闭且包含所有投影函数的最小布尔函数集）是 $\\{0,1\\}$ 上的所有布尔函数的集合，那么我们称 $\\mathcal{C}$ 是功能完备的。关于布尔域上极大克隆的已知分类确定了五个预完备类（也称极大克隆），若集合包含于其中任何一个，则不具备功能完备性：单调函数、仿射函数（在 $\\mathbb{F}_2$ 上线性）、自对偶函数、保0函数和保1函数。你的任务是实现一个判定过程，对于一个有限的 $\\mathcal{C}$，通过检查其是否不被包含在这五个极大克隆中的任何一个，来算法性地判定 $\\mathcal{C}$ 是否为功能完备集，并仅依赖于布尔克隆理论中的基本定义和公认结果来确保判定的正确性。\n\n表示方式。每个联结词由其目数 $n \\in \\mathbb{N}$ 和一个长度为 $2^n$、条目为 $\\{0,1\\}$ 的真值表向量来指定。对于 $i \\in \\{0,\\dots,2^n-1\\}$，向量的第 $i$ 个条目等于 $f(\\mathbf{a})$，其中 $\\mathbf{a}=(a_1,\\dots,a_n)\\in\\{0,1\\}^n$ 是唯一的，使得对于每个 $k \\in \\{1,\\dots,n\\}$，$a_k$ 是 $i$ 的二进制表示中的第 $(k-1)$ 位（也就是说，$a_k$ 是 $i$ 的二进制展开中 $2^{k-1}$ 的系数）。例如，对于 $n=2$，输入顺序为索引0处的 $(0,0)$、索引1处的 $(1,0)$、索引2处的 $(0,1)$ 和索引3处的 $(1,1)$。\n\n需要检查是否包含在内的五个极大克隆的定义：\n- 保0类 $\\mathsf{T}_0$：如果 $f(0,\\dots,0)=0$，则函数 $f$ 属于 $\\mathsf{T}_0$。\n- 保1类 $\\mathsf{T}_1$：如果 $f(1,\\dots,1)=1$，则函数 $f$ 属于 $\\mathsf{T}_1$。\n- 单调类 $\\mathsf{M}$：如果对于所有满足 $\\mathbf{x}\\le \\mathbf{y}$（按坐标）的 $\\mathbf{x},\\mathbf{y}\\in\\{0,1\\}^n$，都有 $f(\\mathbf{x}) \\le f(\\mathbf{y})$，则函数 $f$ 属于 $\\mathsf{M}$。\n- 自对偶类 $\\mathsf{S}$：如果对于所有 $\\mathbf{x}\\in\\{0,1\\}^n$，都有 $f(\\mathbf{x}) = 1 - f(\\neg \\mathbf{x})$，其中 $\\neg \\mathbf{x}$ 表示按位取反，则函数 $f$ 属于 $\\mathsf{S}$。\n- 仿射类 $\\mathsf{L}$：如果存在系数 $a_0,\\dots,a_n\\in\\{0,1\\}$，使得对于所有 $\\mathbf{x}\\in\\{0,1\\}^n$，都有 $f(\\mathbf{x}) = a_0 \\oplus (a_1 x_1) \\oplus \\cdots \\oplus (a_n x_n)$，其中 $\\oplus$ 是模2加法，则函数 $f$ 属于 $\\mathsf{L}$。\n\n判定要求。对于一个有限集合 $\\mathcal{C}$，通过验证 $\\mathcal{C}$ 不被包含在上述五个类中的任何一个，来判定它是否是功能完备的。具体来说，你必须计算五个布尔标志，分别指示 $\\mathcal{C}$ 中的所有函数是否满足保0性、保1性、单调性、自对偶性和仿射性；当且仅当这五个标志都不为真时，集合 $\\mathcal{C}$ 才是功能完备的。\n\n实现此判定过程，并将其应用于以下测试套件。每个案例都是一个有限的联结词集合，以 $(n,\\text{tt})$ 的形式给出，其中 $n$ 是目数，$\\text{tt}$ 是按上述顺序排列的真值向量：\n- 案例 1: $\\{ \\text{NAND}_2 \\}$，其中 $n=2$，$\\text{tt} = [1,1,1,0]$。\n- 案例 2: $\\{ \\text{NOR}_2 \\}$，其中 $n=2$，$\\text{tt} = [1,0,0,0]$。\n- 案例 3: $\\{ \\text{AND}_2, \\text{NOT}_1 \\}$，其中 $\\text{AND}_2$ 由 $n=2$, $\\text{tt}=[0,0,0,1]$ 给出，$\\text{NOT}_1$ 由 $n=1$, $\\text{tt}=[1,0]$ 给出。\n- 案例 4: $\\{ \\text{OR}_2, \\text{NOT}_1 \\}$，其中 $\\text{OR}_2$ 由 $n=2$, $\\text{tt}=[0,1,1,1]$ 给出，$\\text{NOT}_1$ 同上。\n- 案例 5: $\\{ \\text{AND}_2 \\}$，其中 $n=2$，$\\text{tt}=[0,0,0,1]$。\n- 案例 6: $\\{ \\text{XOR}_2 \\}$，其中 $n=2$，$\\text{tt}=[0,1,1,0]$。\n- 案例 7: $\\{ \\text{IMPLIES}_2 \\}$，其中 $\\text{IMPLIES}_2(x_1,x_2)$ 为 $1$，除非 $x_1=1$ 且 $x_2=0$，所以 $n=2$, $\\text{tt}=[1,0,1,1]$。\n- 案例 8: $\\{ \\text{NOT}_1 \\}$，其中 $n=1$, $\\text{tt}=[1,0]$。\n\n你的程序应生成一行输出，其中包含一个逗号分隔的布尔值列表，用方括号括起来（例如 $[\\text{True},\\text{False}]$），按顺序对应案例1到8的结果。不涉及物理单位、角度单位或百分比，因此不需要单位说明。", "solution": "判定一个有限布尔联结词集合是否为功能完备集，是数理逻辑中一个明确定义的问题。其解法基于 Emil Post 的一项开创性成果，即 Post 准则或 Post 格定理。该定理对二元集合 $\\{0,1\\}$ 上的所有克隆进行了完整分类。一个布尔函数集 $\\mathcal{C}$ 是功能完备的，当且仅当它不为五个极大（或预完备）克隆中任何一个的子集。因此，判定过程包括测试给定的联结词集合 $\\mathcal{C}$ 是否被包含在这五个特定的函数类中。如果 $\\mathcal{C}$ 没有完全包含在其中任何一个类中，那么它就是功能完备的。否则，它就不是。\n\n这五个极大克隆是：\n1.  保0函数类，记为 $\\mathsf{T}_0$。如果一个函数 $f$ 满足 $f(0, 0, \\dots, 0) = 0$，则它属于 $\\mathsf{T}_0$。\n2.  保1函数类，记为 $\\mathsf{T}_1$。如果一个函数 $f$ 满足 $f(1, 1, \\dots, 1) = 1$，则它属于 $\\mathsf{T}_1$。\n3.  自对偶函数类，记为 $\\mathsf{S}$。如果一个函数 $f$ 在取反意义下是其自身的对偶，即 $f(x_1, \\dots, x_n) = \\neg f(\\neg x_1, \\dots, \\neg x_n)$，其中 $\\neg x = 1-x$，则它属于 $\\mathsf{S}$。\n4.  单调函数类，记为 $\\mathsf{M}$。如果一个函数 $f$ 保持 $\\{0,1\\}^n$ 上的自然偏序关系，则它属于 $\\mathsf{M}$。也就是说，对于任何两个输入向量 $\\mathbf{x}=(x_1, \\dots, x_n)$ 和 $\\mathbf{y}=(y_1, \\dots, y_n)$，若 $\\mathbf{x} \\le \\mathbf{y}$（意味着对所有 $k \\in \\{1, \\dots, n\\}$ 都有 $x_k \\le y_k$），则 $f(\\mathbf{x}) \\le f(\\mathbf{y})$。\n5.  仿射函数类，记为 $\\mathsf{L}$。如果一个函数 $f$ 可以表示为有限域 $\\mathbb{F}_2$ 上的线性多项式，则它属于 $\\mathsf{L}$。也就是说，存在系数 $a_0, a_1, \\dots, a_n \\in \\{0, 1\\}$，使得对于所有 $\\mathbf{x} \\in \\{0, 1\\}^n$，$f(\\mathbf{x}) = a_0 \\oplus a_1 x_1 \\oplus \\cdots \\oplus a_n x_n$，其中 $\\oplus$ 表示模2加法（异或）。\n\n为了实现对给定联结词集合 $\\mathcal{C}$ 的判定过程，我们必须首先为这五个性质中的每一个开发一个算法测试。对于 $\\mathcal{C}$ 中的每个联结词 $f$（由其目数 $n$ 和长度为 $2^n$ 的真值表向量 $\\mathbf{t}$ 表示），我们执行以下检查。输入向量 $(x_1, \\dots, x_n)$ 对应于真值表中的索引 $i = \\sum_{k=1}^n x_k 2^{k-1}$，因此 $f(x_1, \\dots, x_n) = \\mathbf{t}[i]$。\n\n**1. 保0性（$\\mathsf{T}_0$）测试**\n如果 $f(0, \\dots, 0) = 0$，则函数 $f$ 是保0的。输入向量 $(0, \\dots, 0)$ 对应于索引 $i=0$。因此，检查条件就是 $\\mathbf{t}[0] = 0$。\n\n**2. 保1性（$\\mathsf{T}_1$）测试**\n如果 $f(1, \\dots, 1) = 1$，则函数 $f$ 是保1的。输入向量 $(1, \\dots, 1)$ 对应于索引 $i = \\sum_{k=1}^n 1 \\cdot 2^{k-1} = 2^n - 1$。检查条件是 $\\mathbf{t}[2^n-1] = 1$。\n\n**3. 自对偶性（$\\mathsf{S}$）测试**\n如果对于所有 $\\mathbf{x} \\in \\{0,1\\}^n$，$f(\\mathbf{x}) = 1 - f(\\neg\\mathbf{x})$，则函数 $f$ 是自对偶的。如果输入向量 $\\mathbf{x}$ 对应于索引 $i$，那么其按位取反 $\\neg\\mathbf{x}$ 对应于索引 $(2^n-1)-i$。该条件变为，对于所有 $i \\in \\{0, \\dots, 2^n-1\\}$，都有 $\\mathbf{t}[i] = 1 - \\mathbf{t}[2^n-1-i]$。我们必须为所有索引 $i$ 验证这一点。\n\n**4. 单调性（$\\mathsf{M}$）测试**\n如果 $\\mathbf{x} \\le \\mathbf{y}$ 蕴含 $f(\\mathbf{x}) \\le f(\\mathbf{y})$，则函数 $f$ 是单调的。设 $\\mathbf{x}$ 和 $\\mathbf{y}$ 分别对应于索引 $i$ 和 $j$。条件 $\\mathbf{x} \\le \\mathbf{y}$ 等价于按位条件 $(i \\text{ AND } j) = i$。因此，我们必须验证对于 $\\{0, \\dots, 2^n-1\\}$ 中的所有索引对 $(i, j)$，如果 $(i \\text{ AND } j) = i$，那么 $\\mathbf{t}[i] \\le \\mathbf{t}[j]$。\n\n**5. 仿射性（$\\mathsf{L}$）测试**\n如果 $f(\\mathbf{x}) = a_0 \\oplus \\bigoplus_{k=1}^n a_k x_k$，则函数 $f$ 是仿射的。系数可以从函数在零向量和标准基向量上的行为唯一确定。\n-   常数项是 $a_0 = f(0, \\dots, 0) = \\mathbf{t}[0]$。\n-   对于 $k \\in \\{1, \\dots, n\\}$，令 $\\mathbf{e}_k$ 为 $x_k=1$ 且所有其他分量为 $0$ 的向量。$\\mathbf{e}_k$ 的索引是 $2^{k-1}$。那么 $f(\\mathbf{e}_k) = a_0 \\oplus a_k$，这意味着 $a_k = f(\\mathbf{e}_k) \\oplus a_0 = \\mathbf{t}[2^{k-1}] \\oplus \\mathbf{t}[0]$。\n找到这些候选系数 $a_0, a_1, \\dots, a_n$后，我们必须验证它们能否正确地重现整个真值表。我们遍历所有 $2^n$ 个输入 $\\mathbf{x}$，计算仿射形式 $a_0 \\oplus \\bigoplus_{k=1}^n a_k x_k$ 的值，并检查它是否与 $f(\\mathbf{x}) = \\mathbf{t}[i]$ 匹配。如果这对所有输入都成立，则该函数是仿射的。\n\n**最终判定逻辑：**\n对于给定的联结词集合 $\\mathcal{C}$，我们对每个性质 $\\mathsf{P} \\in \\{\\mathsf{T}_0, \\mathsf{T}_1, \\mathsf{M}, \\mathsf{S}, \\mathsf{L}\\}$，确定是否 $\\mathcal{C} \\subseteq \\mathsf{P}$。这是通过检查 $\\mathcal{C}$ 中的*每个*函数是否都具有性质 $\\mathsf{P}$ 来完成的。设 $C_P$ 是指示 $\\mathcal{C} \\subseteq \\mathsf{P}$ 的布尔标志。集合 $\\mathcal{C}$ 是功能完备的，当且仅当这些标志都不为真，即 $\\neg(C_{\\mathsf{T}_0} \\lor C_{\\mathsf{T}_1} \\lor C_{\\mathsf{M}} \\lor C_{\\mathsf{S}} \\lor C_{\\mathsf{L}})$。\n实现将对每个给定的测试用例应用此逻辑。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a decision procedure for the functional completeness of a set of Boolean connectives\n    based on Post's criterion.\n    \"\"\"\n\n    test_cases = [\n        # Case 1: {NAND2}\n        [ (2, [1, 1, 1, 0]) ],\n        # Case 2: {NOR2}\n        [ (2, [1, 0, 0, 0]) ],\n        # Case 3: {AND2, NOT1}\n        [ (2, [0, 0, 0, 1]), (1, [1, 0]) ],\n        # Case 4: {OR2, NOT1}\n        [ (2, [0, 1, 1, 1]), (1, [1, 0]) ],\n        # Case 5: {AND2}\n        [ (2, [0, 0, 0, 1]) ],\n        # Case 6: {XOR2}\n        [ (2, [0, 1, 1, 0]) ],\n        # Case 7: {IMPLIES2}\n        [ (2, [1, 0, 1, 1]) ],\n        # Case 8: {NOT1}\n        [ (1, [1, 0]) ],\n    ]\n\n    def is_T0_preserving(n, tt):\n        \"\"\"Checks if a function is 0-preserving.\"\"\"\n        if n == 0: # A 0-ary function f()=c is T0-preserving if c=0.\n            return tt[0] == 0\n        return tt[0] == 0\n\n    def is_T1_preserving(n, tt):\n        \"\"\"Checks if a function is 1-preserving.\"\"\"\n        if n == 0: # A 0-ary function f()=c is T1-preserving if c=1.\n            return tt[0] == 1\n        return tt[2**n - 1] == 1\n\n    def is_monotone(n, tt):\n        \"\"\"Checks if a function is monotone.\"\"\"\n        if n == 0:\n            return True\n        size = 2**n\n        for i in range(size):\n            for j in range(size):\n                # if input i <= input j (bitwise)\n                if (i & j) == i:\n                    if tt[i] > tt[j]:\n                        return False\n        return True\n\n    def is_self_dual(n, tt):\n        \"\"\"Checks if a function is self-dual.\"\"\"\n        if n == 0: # f()=c, f() = 1-f(). impossible for c in {0,1}.\n            return False\n        size = 2**n\n        for i in range(size):\n            # tt[i] must be equal to 1 - tt[negated_input_index]\n            negated_index = size - 1 - i\n            if tt[i] != 1 - tt[negated_index]:\n                return False\n        return True\n\n    def is_affine(n, tt):\n        \"\"\"Checks if a function is affine (linear).\"\"\"\n        if n == 0:\n            return True\n            \n        size = 1 << n\n        a0 = tt[0]\n        # Coefficients a_1, ..., a_n\n        A = [(tt[1 << k] ^ a0) for k in range(n)]\n\n        for i in range(size):\n            # Reconstruct function value based on affine form\n            val = a0\n            for k in range(n):\n                # x_{k+1} is the k-th bit of i\n                if (i >> k) & 1:\n                    val ^= A[k]\n            \n            if val != tt[i]:\n                return False\n        return True\n\n    results = []\n    check_functions = [\n        is_T0_preserving,\n        is_T1_preserving,\n        is_monotone,\n        is_self_dual,\n        is_affine\n    ]\n\n    for case in test_cases:\n        is_subset_of_maximal_clone = [True] * 5\n\n        for n, tt in case:\n            for i, check_func in enumerate(check_functions):\n                if not check_func(n, tt):\n                    is_subset_of_maximal_clone[i] = False\n        \n        # A set is adequate if it's not a subset of ANY of the five maximal clones.\n        is_adequate = not any(is_subset_of_maximal_clone)\n        results.append(is_adequate)\n\n    print(f\"[{','.join(map(lambda b: str(b), results))}]\")\n\nsolve()\n\n```", "id": "2968171"}]}