{"hands_on_practices": [{"introduction": "在形式化模型中，精确性至关重要。虽然在非正式的讨论中，“停机”和“接受”这两个术语常常可以互换使用，但在标准的图灵机模型中，它们具有截然不同的技术含义。本练习旨在巩固这一区别，并通过一个具体的归约过程，向您展示“接受”这一概念如何能够被形式化地关联到“停机”上。[@problem_id:2986077]", "problem": "考虑一个确定性图灵机（DTM）的标准模型，它被定义为一个元组 $M = (Q,\\Sigma,\\Gamma,\\delta,q_0,q_{\\mathrm{acc}},q_{\\mathrm{rej}})$，其中 $Q$ 是一个有限状态集，$\\Sigma$ 是输入字母表，$\\Gamma$ 是带字母表且 $\\Sigma \\subseteq \\Gamma$，$\\delta$ 是（部分）转移函数，$q_0 \\in Q$ 是起始状态，$q_{\\mathrm{acc}},q_{\\mathrm{rej}} \\in Q$ 是被分别指定为接受和拒绝状态的停机状态。根据定义，在输入 $x \\in \\Sigma^{\\star}$ 上，如果计算在状态 $q_{\\mathrm{acc}}$ 停机，则机器 $M$ 接受 $x$；如果计算在状态 $q_{\\mathrm{rej}}$ 停机，则拒绝 $x$；否则不停机。$M$ 所识别的语言是 $L(M) = \\{x \\in \\Sigma^{\\star} \\mid M \\text{ 在输入 } x \\text{ 上于 } q_{\\mathrm{acc}} \\text{ 状态停机}\\}$。\n\n为了具体说明停机和接受之间的区别，在任意固定的非空字母表 $\\Sigma$ 上定义一个特定的机器 $M_{\\mathrm{halt\\mbox{-}nonacc}}$ 如下：$Q = \\{q_0,q_{\\mathrm{acc}},q_{\\mathrm{rej}}\\}$，并且对于每个 $a \\in \\Gamma$，有 $\\delta(q_0,a) = (q_{\\mathrm{rej}},a,R)$，其中 $q_{\\mathrm{rej}}$ 是停机状态。因此，对于任何输入 $x \\in \\Sigma^{\\star}$，$M_{\\mathrm{halt\\mbox{-}nonacc}}$ 从 $q_0$ 执行一步移动，然后在 $q_{\\mathrm{rej}}$ 停机，从不进入 $q_{\\mathrm{acc}}$。\n\n另外，给定一个任意的 DTM $M$，定义一个转换后的机器 $H(M)$，它通过规定以下方式将接受模拟为停机：在输入 $x$ 上，$H(M)$ 一步步地模拟 $M(x)$；如果 $M$ 曾进入 $q_{\\mathrm{acc}}$，那么 $H(M)$ 进入 $q_{\\mathrm{acc}}$ 并停机；如果 $M$ 曾进入 $q_{\\mathrm{rej}}$ 或永不停机，那么 $H(M)$ 就不停机（例如，通过将进入 $q_{\\mathrm{rej}}$ 的转移替换为进入一个不停机的自循环状态的转移）。因此，$H(M)$ 在 $x$ 上停机当且仅当 $M$ 接受 $x$。\n\n仅使用上述核心定义，选择下面所有正确的陈述。\n\nA. 机器 $M_{\\mathrm{halt\\mbox{-}nonacc}}$ 在每个输入 $x \\in \\Sigma^{\\star}$ 上都会停机，但它识别的是空语言 $L(M_{\\mathrm{halt\\mbox{-}nonacc}}) = \\varnothing$，因为接受被定义为特别地在 $q_{\\mathrm{acc}}$ 状态停机。\n\nB. 如果存在一个停机问题 $\\mathrm{HALT}_{\\mathrm{DTM}} = \\{\\langle M,x\\rangle \\mid M \\text{ 在输入 } x \\text{ 上停机}\\}$ 的判定器，那么对于任何 $M$，人们可以通过构造 $H(M)$ 并询问 $H(M)$ 是否在 $x$ 上停机来判定接受问题 $\\mathrm{ACCEPT}_{\\mathrm{DTM}} = \\{\\langle M,x\\rangle \\mid M \\text{ 接受 } x\\}$。因此，$\\mathrm{ACCEPT}_{\\mathrm{DTM}}$ 的不可判定性蕴含了 $\\mathrm{HALT}_{\\mathrm{DTM}}$ 的不可判定性。\n\nC. 对于每一个 DTM $M$ 和输入 $x$，如果 $M$ 在 $x$ 上停机，那么 $M$ 接受 $x$。\n\nD. 对于每一个 DTM $M$，其停机集合 $\\{x \\in \\Sigma^{\\star} \\mid M \\text{ 在 } x \\text{ 上停机}\\}$ 与其语言 $L(M) = \\{x \\in \\Sigma^{\\star} \\mid M \\text{ 接受 } x\\}$ 是相同的。\n\nE. 在标准模型中，接受被建模为在指定的接受状态 $q_{\\mathrm{acc}}$ 停机，而在指定的拒绝状态 $q_{\\mathrm{rej}}$ 停机不构成接受。", "solution": "在尝试任何解决方案之前，对问题陈述进行验证。\n\n### 第一步：提取已知条件\n-   一个确定性图灵机（DTM）是一个元组 $M = (Q,\\Sigma,\\Gamma,\\delta,q_0,q_{\\mathrm{acc}},q_{\\mathrm{rej}})$，其中 $Q$ 是一个有限状态集，$\\Sigma$ 是输入字母表，$\\Gamma$ 是带字母表（$\\Sigma \\subseteq \\Gamma$），$\\delta$ 是一个部分转移函数，$q_0 \\in Q$ 是起始状态，$q_{\\mathrm{acc}},q_{\\mathrm{rej}} \\in Q$ 是接受和拒绝停机状态。\n-   在输入 $x \\in \\Sigma^{\\star}$ 上，如果 $M$ 在状态 $q_{\\mathrm{acc}}$ 停机，则 $M$ 接受 $x$。\n-   在输入 $x \\in \\Sigma^{\\star}$ 上，如果 $M$ 在状态 $q_{\\mathrm{rej}}$ 停机，则 $M$ 拒绝 $x$。\n-   如果以上两种情况均未发生，则 $M$ 在输入 $x$ 上不停机。\n-   $M$ 识别的语言是 $L(M) = \\{x \\in \\Sigma^{\\star} \\mid M \\text{ 在输入 } x \\text{ 上于 } q_{\\mathrm{acc}} \\text{ 状态停机}\\}$。\n-   一个特定机器 $M_{\\mathrm{halt\\mbox{-}nonacc}}$ 具有 $Q = \\{q_0,q_{\\mathrm{acc}},q_{\\mathrm{rej}}\\}$，且对于每个 $a \\in \\Gamma$，其转移为 $\\delta(q_0,a) = (q_{\\mathrm{rej}},a,R)$。它在任何输入上执行一步后在 $q_{\\mathrm{rej}}$ 状态停机。\n-   一个转换后的机器 $H(M)$ 模拟给定的 DTM $M$ 在输入 $x$ 上的行为。$H(M)$ 停机当且仅当 $M$ 进入 $q_{\\mathrm{acc}}$。如果 $M$ 进入 $q_{\\mathrm{rej}}$ 或无限循环，则 $H(M)$ 无限循环。\n\n### 第二步：使用提取的已知条件进行验证\n问题陈述被认定为有效。\n-   **科学上合理**：所提供的关于DTM、语言识别、接受和拒绝的定义在计算理论中是标准且正确的。\n-   **形式良好**：问题表述清晰。选项中提出的问题没有歧义，并且可以根据所提供的定义通过逻辑推导来评估。\n-   **客观性**：语言精确，没有主观论断。$M_{\\mathrm{halt\\mbox{-}nonacc}}$ 和 $H(M)$ 的构造是形式化且定义良好的。\n-   该问题不存在任何列出的缺陷（例如，不完整性、矛盾、不可行性）。这是可计算性理论中的一个标准练习题。\n\n### 第三步：结论与行动\n问题是有效的。将推导出一个完整的解决方案。\n\n### DTM 结果分析\n根据所提供的定义，对于任何 DTM $M$ 和输入 $x$，计算 $M(x)$ 恰好有三种可能的结果：\n1.  **接受**：机器 $M$ 进入状态 $q_{\\mathrm{acc}}$ 并停机。在这种情况下，$x \\in L(M)$。\n2.  **拒绝**：机器 $M$ 进入状态 $q_{\\mathrm{rej}}$ 并停机。在这种情况下，$x \\notin L(M)$。\n3.  **循环**：机器 $M$ 从不进入停机状态（$q_{\\mathrm{acc}}$ 或 $q_{\\mathrm{rej}}$）。在这种情况下，$x \\notin L(M)$。\n\n术语“停机”指的是结果1和2。术语“接受”专指结果1。这一区别至关重要。\n\n### 逐项评估\n\n**A. 机器 $M_{\\mathrm{halt\\mbox{-}nonacc}}$ 在每个输入 $x \\in \\Sigma^{\\star}$ 上都会停机，但它识别的是空语言 $L(M_{\\mathrm{halt\\mbox{-}nonacc}}) = \\varnothing$，因为接受被定义为特别地在 $q_{\\mathrm{acc}}$ 状态停机。**\n\n机器 $M_{\\mathrm{halt\\mbox{-}nonacc}}$ 由转移规则 $\\delta(q_0,a) = (q_{\\mathrm{rej}},a,R)$ 定义，适用于它读取的任何符号 $a$。在任何输入 $x \\in \\Sigma^{\\star}$（包括空字符串）上，机器从状态 $q_0$ 开始，读取磁头下的符号，并在单一步骤中转换到状态 $q_{\\mathrm{rej}}$。根据定义，$q_{\\mathrm{rej}}$ 是一个停机状态。因此，$M_{\\mathrm{halt\\mbox{-}nonacc}}$ 在所有可能的输入上都会停机。\n\n一个 DTM 识别的语言 $L(M)$ 是其在*接受*状态 $q_{\\mathrm{acc}}$ 停机的输入集合。机器 $M_{\\mathrm{halt\\mbox{-}nonacc}}$ 的构造使得其计算路径永不进入 $q_{\\mathrm{acc}}$；它总是在 $q_{\\mathrm{rej}}$ 状态停机。因此，不存在任何输入 $x$ 使得 $M_{\\mathrm{halt\\mbox{-}nonacc}}$ 接受它。被接受的字符串集合是空的，所以 $L(M_{\\mathrm{halt\\mbox{-}nonacc}}) = \\varnothing$。该陈述中提供的推理正是这种情况的原因。这个选项正确地说明了停机和接受之间的区别。\n\n*结论*：**正确**。\n\n**B. 如果存在一个停机问题 $\\mathrm{HALT}_{\\mathrm{DTM}} = \\{\\langle M,x\\rangle \\mid M \\text{ 在输入 } x \\text{ 上停机}\\}$ 的判定器，那么对于任何 $M$，人们可以通过构造 $H(M)$ 并询问 $H(M)$ 是否在 $x$ 上停机来判定接受问题 $\\mathrm{ACCEPT}_{\\mathrm{DTM}} = \\{\\langle M,x\\rangle \\mid M \\text{ 接受 } x\\}$。因此，$\\mathrm{ACCEPT}_{\\mathrm{DTM}}$ 的不可判定性蕴含了 $\\mathrm{HALT}_{\\mathrm{DTM}}$ 的不可判定性。**\n\n这个陈述描述了一个从接受问题 $\\mathrm{ACCEPT}_{\\mathrm{DTM}}$ 到停机问题 $\\mathrm{HALT}_{\\mathrm{DTM}}$ 的多一归约。让我们将这个论证形式化。\n假设存在一个判定器 $D_{HALT}$，使得对于任何 DTM $M$ 和输入 $x$，$D_{HALT}(\\langle M,x \\rangle)$ 如果 $M$ 在 $x$ 上停机则返回 `true`，否则返回 `false`。我们可以如下构造一个用于 $\\mathrm{ACCEPT}_{\\mathrm{DTM}}$ 的判定器 $D_{ACCEPT}$：\n在输入 $\\langle M,x \\rangle$ 上：\n1.  按照问题陈述中的描述构造 DTM $H(M)$。这是一个可计算的步骤。\n2.  在输入 $\\langle H(M),x \\rangle$ 上运行假设的判定器 $D_{HALT}$。\n3.  返回 $D_{HALT}(\\langle H(M),x \\rangle)$ 的结果。\n\n根据 $H(M)$ 的定义，“$H(M)$ 在 $x$ 上停机”等价于“$M$ 接受 $x$”。因此，$D_{HALT}(\\langle H(M),x \\rangle)$ 返回 `true` 当且仅当 $M$ 接受 $x$。这意味着我们构造的机器 $D_{ACCEPT}$ 正确地判定了语言 $\\mathrm{ACCEPT}_{\\mathrm{DTM}}$。这确立了 $\\mathrm{ACCEPT}_{\\mathrm{DTM}}$ 可归约于 $\\mathrm{HALT}_{\\mathrm{DTM}}$（$\\mathrm{ACCEPT}_{\\mathrm{DTM}} \\leq_m \\mathrm{HALT}_{\\mathrm{DTM}}$）。\n\n根据不可判定性理论，如果问题 A 可归约于问题 B，并且 A 是不可判定的，那么 B 也必须是不可判定的。一个已知的基础性结果是 $\\mathrm{ACCEPT}_{\\mathrm{DTM}}$ 是不可判定的。因此，这个归约的存在正确地蕴含了 $\\mathrm{HALT}_{\\mathrm{DTM}}$ 也必须是不可判定的。选项中提出的逻辑是完全合理的。\n\n*结论*：**正确**。\n\n**C. 对于每一个 DTM $M$ 和输入 $x$，如果 $M$ 在 $x$ 上停机，那么 $M$ 接受 $x$。**\n\n这个陈述声称任何停机计算都是接受计算。这与提供的基本定义相矛盾。一个 DTM 可以通过两种方式停机：进入 $q_{\\mathrm{acc}}$（接受）或进入 $q_{\\mathrm{rej}}$（拒绝）。一次停机计算不一定是一次接受计算。问题中描述的机器 $M_{\\mathrm{halt\\mbox{-}nonacc}}$ 是一个直接的反例。对于任何输入 $x$，$M_{\\mathrm{halt\\mbox{-}nonacc}}$ 在 $x$ 上停机（通过进入 $q_{\\mathrm{rej}}$），但它不接受 $x$。\n\n*结论*：**不正确**。\n\n**D. 对于每一个 DTM $M$，其停机集合 $\\{x \\in \\Sigma^{\\star} \\mid M \\text{ 在 } x \\text{ 上停机}\\}$ 与其语言 $L(M) = \\{x \\in \\Sigma^{\\star} \\mid M \\text{ 接受 } x\\}$ 是相同的。**\n\n这是选项 C 使用集合符号的重述。令 $S_{halt}(M) = \\{x \\in \\Sigma^{\\star} \\mid M \\text{ 在 } x \\text{ 上停机}\\}$。该陈述声称对于任何 $M$，$S_{halt}(M) = L(M)$。\n如前所述，$L(M)$ 只包含导致 $M$ 在 $q_{\\mathrm{acc}}$ 停机的输入。相比之下，$S_{halt}(M)$ 包含导致 $M$ 在*任一* $q_{\\mathrm{acc}}$ 或 $q_{\\mathrm{rej}}$ 停机的输入。\n所以，$L(M) \\subseteq S_{halt}(M)$。这两个集合仅在没有输入导致 $M$ 拒绝时才相同。这并非对所有 DTM 都成立。\n使用我们的反例 $M_{\\mathrm{halt\\mbox{-}nonacc}}$：\n-   $S_{halt}(M_{\\mathrm{halt\\mbox{-}nonacc}}) = \\Sigma^{\\star}$，因为它在所有输入上都停机。\n-   $L(M_{\\mathrm{halt\\mbox{-}nonacc}}) = \\varnothing$，因为它不接受任何输入。\n由于问题指定了一个非空字母表 $\\Sigma$，我们有 $\\Sigma^{\\star} \\neq \\varnothing$。因此，对于这台机器，这两个集合不相同，从而证伪了这个普遍性声明。\n\n*结论*：**不正确**。\n\n**E. 在标准模型中，接受被建模为在指定的接受状态 $q_{\\mathrm{acc}}$ 停机，而在指定的拒绝状态 $q_{\\mathrm{rej}}$ 停机不构成接受。**\n\n这个陈述是问题陈述的引言部分中提供的定义的总结。\n-   引言部分陈述：“如果计算在状态 $q_{\\mathrm{acc}}$ 停机，则机器 $M$ 接受 $x$”。这确认了陈述的第一部分。\n-   它还将语言定义为 $L(M) = \\{x \\in \\Sigma^{\\star} \\mid M \\text{ 在输入 } x \\text{ 上于 } q_{\\mathrm{acc}} \\text{ 状态停机}\\}$。这正式地将接受与特别地在 $q_{\\mathrm{acc}}$ 停机关联起来。\n-   它进一步将拒绝定义为在状态 $q_{\\mathrm{rej}}$ 停机。由于接受和拒绝是不同的结果（一个导致被包含在 $L(M)$ 中，另一个则不会），在 $q_{\\mathrm{rej}}$ 停机不可能是接受。该陈述是对为该问题设定的基本规则的直接而准确的复述。\n\n*结论*：**正确**。", "answer": "$$\\boxed{ABE}$$", "id": "2986077"}, {"introduction": "在掌握了核心定义之后，下一步就是运用它们进行证明。归约 (reduction) 是证明新问题不可判定的主要工具，但其逻辑必须被正确运用。本练习旨在剖析在构建此类证明时一个常见且关键的错误，以确保您深刻理解映射归约的正确方向性及其背后的逻辑。[@problem_id:1457073]", "problem": "在计算理论课程中，一名叫 Alice 的学生接到了一个任务，需要证明一个特定的语言 `TOTAL_TM` 是不可判定的。该语言定义为 `TOTAL_TM` = $\\{ \\langle M \\rangle \\mid M \\text{ 是一台图灵机 (TM)，它对所有可能的输入字符串都会停机} \\}$。\n\nAlice 知道标准停机问题 $A_{TM} = \\{ \\langle M, w \\rangle \\mid M \\text{ 是一台在输入 } w \\text{ 上会停机的图灵机} \\}$，是一个著名的不可判定语言。\n\n为了证明她的论点，她正确地构造了一个可计算函数 $f$，该函数将 `TOTAL_TM` 的任意实例 $\\langle M \\rangle$ 转换为 $A_{TM}$ 的一个实例 $\\langle M', w' \\rangle = f(\\langle M \\rangle)$，使得 $\\langle M \\rangle \\in \\text{TOTAL\\_TM}$ 当且仅当 $\\langle M', w' \\rangle \\in A_{TM}$。这建立了一个从 `TOTAL_TM` 到 $A_{TM}$ 的映射归约（记作 $\\text{TOTAL\\_TM} \\le_m A_{TM}$）。\n\n然后 Alice 总结她的证明：“因为我已经证明了 `TOTAL_TM` 可以归约到 $A_{TM}$，并且我们知道 $A_{TM}$ 是不可判定的，所以从逻辑上可以得出 `TOTAL_TM` 也必须是不可判定的。”\n\n下列哪个陈述最好地解释了 Alice 推理中的根本性错误？\n\nA. 为了通过归约证明一个语言 $P$ 是不可判定的，必须将一个已知的不可判定语言 $U$ *归约到* $P$（即，证明 $U \\le_m P$），而不是反过来。Alice 的归约方向对于她声称的目的来说是错误的。\nB. 语言 `TOTAL_TM` 不是图灵可识别的，而 $A_{TM}$ 是。映射归约仅在处于相同可识别性类别的语言之间有效（即，两者都是可识别的，或两者都不是）。\nC. Alice 的论证是循环论证。为了构造可计算函数 $f$，她必须已经隐含地假设了一种判定 `TOTAL_TM` 的方法，这与她试图证明的论点相矛盾。\nD. 该归约是无效的，因为已知 `TOTAL_TM` 是一个比 $A_{TM}$ “更难”的问题。可计算性理论的一个基本定理是，不能将一个计算上更难的问题归约到一个更容易的问题。\nE. 任何从以单个编码 $\\langle M \\rangle$ 为输入的语言到以一对 $\\langle M, w \\rangle$ 为输入的语言的归约都是有内在缺陷的，因为它需要制造原始输入中不存在的信息（字符串 $w$）。", "solution": "我们给定了语言 $\\text{TOTAL\\_TM} = \\{ \\langle M \\rangle \\mid M \\text{ 对所有输入停机} \\}$ 和停机问题 $A_{TM} = \\{ \\langle M, w \\rangle \\mid M \\text{ 在 } w \\text{ 上停机} \\}$，其中已知 $A_{TM}$ 是不可判定的。Alice 展示了一个映射归约 $\\text{TOTAL\\_TM} \\le_{m} A_{TM}$ 并得出结论 `TOTAL_TM` 是不可判定的。\n\n回顾定义：对于语言 $A$ 和 $B$，$A \\le_{m} B$ 意味着存在一个全可计算函数 $f$，使得对于所有字符串 $x$， \n$$x \\in A \\iff f(x) \\in B.$$\n\n映射归约的关键性质：\n- 如果 $A \\le_{m} B$ 且 $B$ 是可判定的，那么 $A$ 也是可判定的。证明：给定 $B$ 的一个判定器，要判定输入为 $x$ 的 $A$，可以计算 $f(x)$ 并运行 $B$ 的判定器；当且仅当 $B$ 的判定器接受时，我们接受。\n- 该陈述的逆否命题是：如果 $A$ 是不可判定的且 $A \\le_{m} B$，那么 $B$ 也是不可判定的。\n\n因此，为了通过归约证明目标语言 $P$ 是不可判定的，必须将一个已知的不可判定语言 $U$ 归约到 $P$，也就是说，证明 $U \\le_{m} P$。然后，如果 $P$ 是可判定的，那么 $U$ 也将是可判定的，这与 $U$ 的已知不可判定性相矛盾。\n\n但 Alice 证明的却是 $\\text{TOTAL\\_TM} \\le_{m} A_{TM}$。根据上述基本性质，这个蕴含关系只能得出：\n$$\\text{如果 } A_{TM} \\text{ 是可判定的，那么 } \\text{TOTAL\\_TM} \\text{ 就是可判定的。}$$\n但是由于 $A_{TM}$ 是不可判定的，这个条件句并没有告诉我们任何关于 `TOTAL_TM` 可判定性的信息。因此 Alice 的结论不成立。\n\n一个具体的例子可以说明这样的归约方向不能证明不可判定性：设 $L$ 是任意一个可判定语言。设 $D$ 是它的判定器。定义一个可计算函数 $f$，在输入 $x$ 上，它运行 $D(x)$，如果 $D$ 接受，则输出一个固定的属于 $A_{TM}$ 的对 $\\langle M_{halt}, w_{halt} \\rangle$，如果 $D$ 拒绝，则输出一个固定的不属于 $A_{TM}$ 的对 $\\langle M_{loop}, w_{loop} \\rangle$。那么 $x \\in L \\iff f(x) \\in A_{TM}$，所以 $L \\le_{m} A_{TM}$，但 $L$ 是可判定的。因此，证明 $P \\le_{m} A_{TM}$ 并不能确定 $P$ 是不可判定的。\n\n因此，根本性的错误在于归约的方向。这对应于选项 A。其他选项是错误的，因为：映射归约不要求具有相同的可识别性状态（B 是错误的），构造 $f$ 并不假设 `TOTAL_TM` 存在判定器（C 是错误的），“更难到更容易”的说法不是这里起作用的正式标准（D 具有误导性），并且通过可计算的填充或硬编码从单个元素生成对是标准操作（E 是错误的）。", "answer": "$$\\boxed{A}$$", "id": "1457073"}, {"introduction": "掌握了计算理论中的证明技巧后，我们将探索其与数理逻辑的深层联系。哥德尔 (Gödel) 和图灵 (Turing) 最深刻的洞见之一，便是关于计算的陈述可以被表达为算术公式。本练习提供了一个将停机问题“算术化”的实践机会，您将亲手构造表达“停机”与“不停机”的一阶算术公式，并根据其量词结构在算术分层中对其进行分类，从而揭示不可判定性问题内在的逻辑复杂度。[@problem_id:2986081]", "problem": "令 $N$ 表示自然数集，并在包含 $0$、后继、加法和乘法符号的一阶算术语言中进行工作。固定任意一种确定性图灵机的有效 Gödel 编码，使得每个机器和构型都由 $N$ 中的一个数表示。假设以下可计算性理论和算术化的基本事实，你可以不加证明地使用它们：\n\n- 存在一个原始递归关系 $R(e,x,t,y)$，它当且仅当 $y$ 是由 $e$ 编码的机器在输入 $x$ 上精确执行 $t$ 步的完整计算历史（例如，一个有限的表或构型序列）的编码，并且该历史相对于机器的转移函数是正确的时成立。\n- 存在一个原始递归关系 $H_{\\mathrm{fin}}(e,x,t,y)$，它当且仅当 $R(e,x,t,y)$ 成立且 $y$ 中编码的最后一个构型是停机的（即，机器在时间 $t$ 前已进入一个指定的停机状态）时成立。\n- 一个其矩阵为原始递归关系且其量词范围为 $N$ 的公式可以被置于前束范式；其在算术分层中的层级由前导无界量词的模式决定：一个 $\\Sigma_{n}$-公式有一个存在量词的前导块，后跟 $n-1$ 次交替，一个 $\\Pi_{n}$-公式有一个全称量词的前导块，后跟 $n-1$ 次交替，其矩阵均为可判定的（原始递归的）。\n\n仅使用这些基础：\n\n1. 构建一个一阶算术公式 $H(e,x)$，表示“由 $e$ 编码的机器在输入 $x$ 上停机”，使用 $R$ 和 $H_{\\mathrm{fin}}$ 作为你的可判定矩阵。将你的公式置于前束范式，并明确指出其前导量词块和矩阵。\n\n2. 构建一个一阶算术公式 $NH(e,x)$，表示“由 $e$ 编码的机器在输入 $x$ 上不停机”，同样仅使用对 $N$ 的量化和一个由 $R$ 和 $H_{\\mathrm{fin}}$ 构建的可判定矩阵。将你的公式置于前束范式，并明确指出其前导量词块和矩阵。\n\n3. 对每个 $H(e,x)$ 和 $NH(e,x)$，确定其最小算术分层层级 $L(\\cdot)$，定义如下：如果一个公式（在标准算术模型上）等价于一个具有不少于 $n$ 次交替的 $\\Sigma_{n}$-公式，则取 $L$ 为 $n$；如果它等价于一个具有不少于 $n$ 次交替的 $\\Pi_{n}$-公式，则取 $L$ 为 $n$。通过分析量词结构和矩阵的可判定性来证明你的分类。\n\n4. 计算 $L(H)+L(NH)$ 的精确整数值。将你的最终答案报告为一个精确整数。无需四舍五入。", "solution": "问题要求基于所提供的原始递归关系，为停机问题及其补集构建和分类一阶算术公式。\n\n**问题验证**\n\n首先对问题陈述进行验证。\n\n*   **步骤 1：提取已知条件**\n    *   论域：自然数集 $N$。\n    *   语言：包含 $0$、后继、加法和乘法符号的一阶算术。\n    *   Gödel 编码：一个有效的编码方案将图灵机及其构型映射到 $N$ 中的数。\n    *   原始递归关系 $R(e,x,t,y)$：当且仅当 $y$ 是机器 $e$ 在输入 $x$ 上精确执行 $t$ 步的正确计算历史的编码时成立。\n    *   原始递归关系 $H_{\\mathrm{fin}}(e,x,t,y)$：当且仅当 $R(e,x,t,y)$ 为真且计算在步骤 $t$ 处于停机状态时成立。\n    *   算术分层定义：如果一个公式有一个存在量词的前导块和 $n-1$ 次量词交替，且其矩阵是可判定的，则该公式是 $\\Sigma_n$ 的。如果一个公式有一个全称量词的前导块和 $n-1$ 次量词交替，且其矩阵是可判定的，则该公式是 $\\Pi_n$ 的。\n    *   层级 $L(\\cdot)$：使得一个公式等价于一个 $\\Sigma_n$ 或 $\\Pi_n$ 公式所需的最小 $n \\in N, n \\ge 1$。\n\n*   **步骤 2：使用提取的已知条件进行验证**\n    该问题是可计算性理论和数理逻辑中的一个标准练习。它在科学上基于计算的形式化（Church-Turing 论题）及其与形式算术的关系（由 Gödel、Kleene 等人建立）。所有术语都有精确定义，前提条件是该领域的标准结果。该问题是适定的、客观的、自洽的，没有明显的逻辑矛盾、歧义或事实不健全之处。\n\n*   **步骤 3：结论与行动**\n    问题被认为是有效的。有必要提供一个完整的解答。\n\n**第 1 部分：公式 $H(e,x)$ 的构建**\n\n“由 $e$ 编码的机器在输入 $x$ 上停机”这一断言为真，当且仅当存在一个时间 $t \\in N$ 和一个对应的计算历史 $y \\in N$ 来表示一个有效的、停机的计算。谓词 $H_{\\mathrm{fin}}(e,x,t,y)$ 捕捉了特定时间 $t$ 和历史 $y$ 的这种情况。为了表示在*某个*时间发生停机，我们对 $t$ 和 $y$ 进行存在量化。\n\n因此，公式 $H(e,x)$ 为：\n$$H(e,x) \\equiv \\exists t \\exists y \\, H_{\\mathrm{fin}}(e,x,t,y)$$\n该公式处于前束范式。\n*   **前导量词块：** $\\exists t \\exists y$。这是一个单一的存在量词块。\n*   **矩阵：** $H_{\\mathrm{fin}}(e,x,t,y)$。问题陈述该关系是原始递归的。根据定义，原始递归关系可由图灵机判定。因此，该矩阵是可判定的。\n\n**第 2 部分：公式 $NH(e,x)$ 的构建**\n\n“由 $e$ 编码的机器在输入 $x$ 上不停机”这一断言是 $H(e,x)$ 的逻辑否定。\n$$NH(e,x) \\equiv \\neg H(e,x)$$\n我们代入 $H(e,x)$ 的表达式，并通过应用量词对偶规则（$\\neg \\exists z P(z) \\equiv \\forall z \\neg P(z)$）将结果公式转换为前束范式。\n$$NH(e,x) \\equiv \\neg (\\exists t \\exists y \\, H_{\\mathrm{fin}}(e,x,t,y))$$\n$$\\equiv \\forall t \\, \\neg (\\exists y \\, H_{\\mathrm{fin}}(e,x,t,y))$$\n$$\\equiv \\forall t \\forall y \\, \\neg H_{\\mathrm{fin}}(e,x,t,y)$$\n处于前束范式的公式 $NH(e,x)$ 是：\n$$NH(e,x) \\equiv \\forall t \\forall y \\, \\neg H_{\\mathrm{fin}}(e,x,t,y)$$\n*   **前导量词块：** $\\forall t \\forall y$。这是一个单一的全称量词块。\n*   **矩阵：** $\\neg H_{\\mathrm{fin}}(e,x,t,y)$。由于 $H_{\\mathrm{fin}}$ 是一个可判定关系，其否定 $\\neg H_{\\mathrm{fin}}$ 也是可判定的。\n\n**第 3 部分：算术分层分类**\n\n我们确定每个公式的最小层级 $L(\\cdot)$。\n\n**$H(e,x)$ 的分类：**\n公式 $H(e,x)$ 有一个存在量词的前导块和一个可判定矩阵。此结构对应于一个 $\\Sigma_1$-公式。满足 $H(e,x)$ 的数对 $(e,x)$ 的集合是停机集，已知该集合是不可判定的。一个集合是可判定的，当且仅当它可由一个 $\\Delta_1$ 公式（等价于一个 $\\Sigma_1$ 和 $\\Pi_1$ 公式）定义，而这又等价于有一个无量词的定义（在一个可判定语言上的 $\\Sigma_0$ 或 $\\Pi_0$ 公式）。由于停机集是不可判定的，它不能由 $\\Sigma_0$ 公式定义。因此，其最小分类是 $\\Sigma_1$。\n这意味着 $L(H) = 1$。\n\n**$NH(e,x)$ 的分类：**\n公式 $NH(e,x)$ 有一个全称量词的前导块和一个可判定矩阵。此结构对应于一个 $\\Pi_1$-公式。满足 $NH(e,x)$ 的数对 $(e,x)$ 的集合是停机集的补集。\n1.  这个集合是不可判定的，因为如果它是可判定的，它的补集（停机集）也将是可判定的，而这是一个已知的谬误。因此，它不能是 $\\Sigma_0$ 或 $\\Pi_0$ 集。\n2.  我们还必须证明它不是一个 $\\Sigma_1$ 集。一个集合可由 $\\Sigma_1$ 公式定义，当且仅当它是递归可枚举的。停机集（由 $H(e,x)$ 定义）是一个 $\\Sigma_1$-集，因此它是递归可枚举的。根据 Post 定理，一个集合是可判定的（递归的），当且仅当该集合及其补集都是递归可枚举的。如果停机集的补集也是递归可枚举的（即 $\\Sigma_1$），那么停机集就将是可判定的。这是一个矛盾。\n因此，由 $NH(e,x)$ 定义的集合不是 $\\Sigma_1$。其最简单的分类是 $\\Pi_1$。\n这意味着 $L(NH) = 1$。\n\n**第 4 部分：最终计算**\n\n问题要求计算 $L(H) + L(NH)$ 的值。使用第 3 部分的结果：\n$$L(H) = 1$$\n$$L(NH) = 1$$\n和为：\n$$L(H) + L(NH) = 1 + 1 = 2$$", "answer": "$$\\boxed{2}$$", "id": "2986081"}]}