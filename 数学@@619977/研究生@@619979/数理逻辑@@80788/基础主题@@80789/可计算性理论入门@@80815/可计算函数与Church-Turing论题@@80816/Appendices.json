{"hands_on_practices": [{"introduction": "本练习旨在提供一次可计算性理论的基础实践：将一个直观的算法转化为图灵机的形式化语言。通过构建一台执行一元加法的图灵机，您将对“有效过程”的含义获得具体理解，从而直接接触到丘奇-图灵论题的核心主张。此练习不仅考验您对形式化定义的掌握，还旨在磨练您分析算法所需计算资源（例如执行步数）的能力[@problem_id:2970583]。", "problem": "一个确定性单带图灵机 (TM) 被形式化地定义为一个 $7$-元组 $(Q,\\Sigma,\\Gamma,\\delta,q_{0},q_{\\mathrm{acc}},q_{\\mathrm{rej}})$，其中 $Q$ 是一个有限的状态集，$\\Sigma \\subseteq \\Gamma \\setminus \\{\\sqcup\\}$ 是输入字母表，$\\Gamma$ 是带字母表，$\\delta: Q \\times \\Gamma \\to Q \\times \\Gamma \\times \\{L,N,R\\}$ 是转移函数，它将当前状态和扫描到的符号映射到一个下一状态、一个要写入的符号以及读写头的移动方向：左 ($L$)、不移动 ($N$) 或右 ($R$)，$q_{0} \\in Q$ 是起始状态，而 $q_{\\mathrm{acc}}, q_{\\mathrm{rej}} \\in Q$ 是停机接受和停机拒绝状态。一元表示法将自然数 $k$ 编码为字符串 $1^{k}$，我们将数对 $(m,n)$ 编码为带上的字符串 $1^{m} 0 1^{n}$，两侧由空白符号 $\\sqcup$ 包围。\n\n从图灵可计算性的基本定义和上述一元编码出发，构造一个确定性单带图灵机，该图灵机通过将带上内容为 $\\sqcup^{\\omega} 1^{m} 0 1^{n} \\sqcup^{\\omega}$ 的输入转换为输出 $\\sqcup^{\\omega} 1^{m+n} \\sqcup^{\\omega}$，然后在接受状态停机，来计算总函数 $f(m,n) = m + n$。读写头初始时扫描输入的最左边的非空白符号。你的构造必须通过一种“移动并擦除”的策略来实现加法：首先通过写入一个空白符号 $\\sqcup$ 来消除分隔符 $0$，从而创建一个单位单元格的间隙；然后通过一个循环将右侧的 $1$ 符号块向左移动一个单元格，该循环重复地将紧邻间隙右侧的单个 $1$ 移动并擦除到间隙中，直到间隙到达该块的右端。\n\n明确提供：\n- 带字母表 $\\Gamma$、输入字母表 $\\Sigma$、空白符号以及 $Q$ 中的命名状态集。\n- 在对形式为 $1^{m} 0 1^{n}$ 的输入进行正确计算期间出现的所有状态-符号对的转移函数 $\\delta$ 条目，覆盖扫描到分隔符、擦除分隔符、检查紧邻间隙右侧的符号、在适当时候向间隙中写入 $1$、擦除已移动的 $1$ 以及决定停机等阶段。\n- 一个基于不变量的简要第一性原理论证，说明该图灵机按照 Church–Turing 论题的规定计算了 $f(m,n) = m+n$，即消除分隔符并移动右侧块的非形式化算法是由该形式化转移系统实现的，并且对于所有指定形式的输入，它都会在产生正确输出后停机。\n\n最后，推导你的图灵机从输入为 $1^{m} 0 1^{n}$ 的初始配置开始直到停机所执行的读写头移动的确切次数，记为 $T(m,n)$。将 $T(m,n)$ 表示为关于 $m$ 和 $n$ 的单一闭式解析表达式。不需要四舍五入，也没有单位。最终答案必须是单个表达式。", "solution": "用户希望我为一个一元加法问题设计一个确定性单带图灵机 (TM)，并分析其时间复杂度。\n\n### 问题验证\n\n**步骤 1：提取已知条件**\n\n*   **图灵机形式体系**：一个 $7$-元组 $(Q,\\Sigma,\\Gamma,\\delta,q_{0},q_{\\mathrm{acc}},q_{\\mathrm{rej}})$。\n*   **状态 ($Q$)**：一个有限的状态集，包括一个起始状态 $q_0$、一个接受状态 $q_{\\mathrm{acc}}$ 和一个拒绝状态 $q_{\\mathrm{rej}}$。\n*   **输入字母表 ($\\Sigma$)**：$\\Sigma \\subseteq \\Gamma \\setminus \\{\\sqcup\\}$。\n*   **带字母表 ($\\Gamma$)**：一个包含空白符号 $\\sqcup$ 的有限符号集。\n*   **转移函数 ($\\delta$)**：$\\delta: Q \\times \\Gamma \\to Q \\times \\Gamma \\times \\{L,N,R\\}$。\n*   **输入编码**：自然数 $k$ 编码为 $1^k$。一对自然数 $(m,n)$ 编码为字符串 $1^m 0 1^n$。\n*   **初始带内容**：带上包含 $\\sqcup^{\\omega} 1^{m} 0 1^{n} \\sqcup^{\\omega}$。\n*   **初始读写头位置**：读写头扫描输入的最左边的非空白符号。\n*   **要计算的函数**：$f(m,n) = m + n$。\n*   **要求的输出带内容**：带上必须包含 $\\sqcup^{\\omega} 1^{m+n} \\sqcup^{\\omega}$。\n*   **停机条件**：图灵机必须在状态 $q_{\\mathrm{acc}}$ 停机。\n*   **指定的算法**：\n    1.  通过写入一个空白符号 $\\sqcup$ 来消除分隔符 $0$。\n    2.  通过重复地将间隙右侧的单个 $1$ 移动到间隙中，将右侧的 $1$ 块向左移动一个单元格。\n\n**步骤 2：使用提取的已知条件进行验证**\n\n*   **科学依据**：该问题是可计算性理论中的一个标准练习，该领域是数理逻辑和理论计算机科学的一个分支。所有定义和概念（图灵机、一元编码、可计算性）都是完善且科学合理的。\n*   **适定性**：该问题是适定的。输入、输出以及要实现的具体算法都得到了清晰明确的定义。这种结构允许对图灵机进行形式化构造，并唯一地推导其关于读写头移动次数的计算复杂性。\n*   **客观性**：问题陈述以精确、形式化的语言表达，没有任何主观或模棱两可的术语。\n\n**步骤 3：结论与行动**\n\n问题陈述是有效的，因为它是科学合理的、适定的、客观的和自足的。我现在将继续构造图灵机并推导其复杂性。\n\n### 图灵机构造\n\n根据指定的算法，我们可以设计图灵机的各个组件。\n\n**图灵机组件**\n\n*   **状态集 ($Q$)**：我们将状态集定义为 $Q = \\{q_0, q_{\\text{find1}}, q_{\\text{carry1}}, q_{\\text{write1}}, q_{\\text{acc}}, q_{\\text{rej}}\\}$。\n    *   $q_0$：初始状态，用于向右扫描直到分隔符 $0$。\n    *   $q_{\\text{find1}}$：在右侧块中扫描下一个要移动的 $1$。\n    *   $q_{\\text{carry1}}$：“携带”一个 $1$ 向左移动以填补当前间隙。\n    *   $q_{\\text{write1}}$：刚刚在间隙中写入一个 $1$，需要移动到新的间隙。\n    *   $q_{\\text{acc}}$：停机接受状态。\n    *   $q_{\\text{rej}}$：停机拒绝状态（对于有效输入不使用）。\n*   **输入字母表 ($\\Sigma$)**：$\\Sigma = \\{0, 1\\}$。\n*   **带字母表 ($\\Gamma$)**：$\\Gamma = \\{0, 1, \\sqcup\\}$。空白符号是 $\\sqcup$。\n\n**转移函数 ($\\delta$)**\n\n转移函数由以下规则定义，这些规则实现了指定算法的各个阶段。\n\n1.  **阶段 1：扫描到分隔符。**\n    在状态 $q_0$下，机器向右移动，越过初始的 $m$ 个 $1$ 组成的块。\n    $$ \\delta(q_0, 1) = (q_0, 1, R) $$\n\n2.  **阶段 2：擦除分隔符并开始移动。**\n    当找到分隔符 $0$ 时，它被替换为空白符号 $\\sqcup$，读写头向右移动到第二个 $1$ 块的起始处，进入主循环状态 $q_{\\text{find1}}$。\n    $$ \\delta(q_0, 0) = (q_{\\text{find1}}, \\sqcup, R) $$\n\n3.  **阶段 3：移动循环与终止。**\n    这组转移实现了一种穿梭式的运动，将块 $1^n$ 向左移动一个单元格。\n    *   在状态 $q_{\\text{find1}}$下，机器寻找下一个要移动的 $1$。如果找到一个 $1$，它通过写入一个 $\\sqcup$ 来“拾取”它，然后机器转换到状态 $q_{\\text{carry1}}$ 以将这个 $1$ 向左移动。\n        $$ \\delta(q_{\\text{find1}}, 1) = (q_{\\text{carry1}}, \\sqcup, L) $$\n    *   如果状态 $q_{\\text{find1}}$ 遇到一个 $\\sqcup$，这表示所有 $n$ 个 $1$ 都已被移动。计算完成，机器停机。\n        $$ \\delta(q_{\\text{find1}}, \\sqcup) = (q_{\\text{acc}}, \\sqcup, N) $$\n    *   在状态 $q_{\\text{carry1}}$ 下，机器向左移动以寻找应该放置 $1$ 的间隙（一个 $\\sqcup$）。构造确保读写头紧邻间隙的右侧，所以它需要向左移动一次。找到间隙后，它写入一个 $1$，进入状态 $q_{\\text{write1}}$，并向右移动。\n        $$ \\delta(q_{\\text{carry1}}, \\sqcup) = (q_{\\text{write1}}, 1, R) $$\n    *   在状态 $q_{\\text{write1}}$ 下，机器刚刚填补了旧的间隙。读写头现在位于新创建的间隙上。它向右移动以开始寻找下一个 $1$，重新进入状态 $q_{\\text{find1}}$。\n        $$ \\delta(q_{\\text{write1}}, \\sqcup) = (q_{\\text{find1}}, \\sqcup, R) $$\n\n### 基于不变量的正确性论证\n\n我们论证所构造的图灵机正确地计算了 $f(m,n)=m+n$。\n\n*   **初始化**：图灵机以带配置 $\\sqcup^{\\omega} 1^m 0 1^n \\sqcup^{\\omega}$ 开始，读写头位于最左边的 $1$ 上。\n*   **循环前**：状态 $q_0$ 的转移将读写头移动过 $m$ 个 $1$，然后用 $\\sqcup$ 替换分隔符 $0$。在此阶段结束时，带配置为 $\\sqcup^{\\omega} 1^m \\sqcup 1^n \\sqcup^{\\omega}$，机器处于状态 $q_{\\text{find1}}$，其读写头位于 $1^n$ 块的第一个 $1$ 上（如果 $n=0$，则位于 $\\sqcup$ 上）。\n*   **循环不变量**：我们为主循环的第 $k$ 次迭代（对于 $k \\in \\{1, 2, \\dots, n\\}$）的开始定义不变量。\n    *   **不变量**：带上包含字符串 $1^{m+k-1} \\sqcup 1^{n-(k-1)}$，机器处于状态 $q_{\\text{find1}}$，并且读写头扫描块 $1^{n-(k-1)}$ 的最左边的 $1$。\n    *   **基本情况 ($k=1$)**：在循环前阶段之后，带内容为 $1^m \\sqcup 1^n$，状态为 $q_{\\text{find1}}$，读写头位于 $1^n$ 的第一个 $1$ 上。这与 $k=1$ 的不变量匹配。\n    *   **归纳步骤**：假设不变量对于第 $k$ 次迭代成立。状态 $q_{\\text{find1}}$、 $q_{\\text{carry1}}$ 和 $q_{\\text{write1}}$ 的三个转移执行一次移动。它们取右侧块的最左边的 $1$，将其移入 $\\sqcup$ 间隙，从而将带内容从 $1^{m+k-1} \\sqcup 1^{n-(k-1)}$ 转换为 $1^{m+k} \\sqcup 1^{n-k}$。读写头被重新定位到新的右侧块 ($1^{n-k}$) 的最左边的 $1$ 上，状态返回到 $q_{\\text{find1}}$。这为第 $k+1$ 次迭代重新建立了不变量。\n*   **终止**：循环精确执行 $n$ 次。在第 $n$ 次迭代之后，带上包含字符串 $1^{m+n} \\sqcup$。处于状态 $q_{\\text{find1}}$ 的机器接着搜索下一个要移动的 $1$。它找到了一个 $\\sqcup$（位于第 $(n+1)$ 个 $1$ 本应在的位置）。根据转移 $\\delta(q_{\\text{find1}}, \\sqcup) = (q_{\\text{acc}}, \\sqcup, N)$，机器转换到接受状态并停机。最终的带配置如要求的那样为 $\\sqcup^{\\omega} 1^{m+n} \\sqcup^{\\omega}$。这提供了一个构造性证明，表明加法是一个可计算函数，与 Church-Turing 论题一致。\n\n### 读写头移动次数 $T(m,n)$ 的推导\n\n我们现在计算读写头移动的总次数 $T(m,n)$，作为 $m$ 和 $n$ 的函数。\n\n1.  **阶段 1（扫描到分隔符）**：读写头从 $m$ 个 $1$ 中的第一个开始，向右移动直到到达 $0$。这需要 $m$ 次右移 ($R$)。\n    *   移动次数：$m$。\n\n2.  **阶段 2（擦除分隔符）**：转移 $\\delta(q_0, 0)$ 涉及一次右移 ($R$)。\n    *   移动次数：$1$。\n\n3.  **阶段 3（移动循环）**：循环执行 $n$ 次，对 $1^n$ 块中的每个 $1$ 执行一次。我们计算单次迭代的移动次数：\n    *   $\\delta(q_{\\text{find1}}, 1)$：一次左移 ($L$)。\n    *   $\\delta(q_{\\text{carry1}}, \\sqcup)$：一次右移 ($R$)。\n    *   $\\delta(q_{\\text{write1}}, \\sqcup)$：一次右移 ($R$)。\n    因此，每次循环迭代需要 $1+1+1=3$ 次移动。由于有 $n$ 次迭代，此阶段总共需要 $3n$ 次移动。\n    *   移动次数：$3n$。\n\n4.  **阶段 4（终止）**：循环完成后，机器处于状态 $q_{\\text{find1}}$ 并读取一个 $\\sqcup$。到 $q_{\\text{acc}}$ 的转移不涉及读写头移动 ($N$)。\n    *   移动次数：$0$。\n\n读写头移动的总次数是所有阶段移动次数的总和：\n$$ T(m,n) = (\\text{阶段 1}) + (\\text{阶段 2}) + (\\text{阶段 3}) + (\\text{阶段 4}) $$\n$$ T(m,n) = m + 1 + 3n + 0 $$\n$$ T(m,n) = m + 3n + 1 $$\n这个闭式表达式对所有非负整数 $m, n \\ge 0$ 成立。", "answer": "$$\\boxed{m+3n+1}$$", "id": "2970583"}, {"introduction": "虽然原始递归函数保证是全函数，但正如丘奇-图灵论题所揭示的，计算的全部威力还包括那些可能不会在所有输入上都停机的函数。本练习通过考察无界最小化（$\\mu$-）算子，探索了从全函数到部分函数的这一关键飞跃。您将亲眼见证，将这种强大的搜索机制应用于一个简单的、性质良好的谓词，如何能够产生一个定义域非平凡的函数，这是理解不可判定性的一个基础概念[@problem_id:2970597]。", "problem": "设 $\\mathbb{N}$ 表示自然数集，并回顾原始递归的基本框架：初始函数（零函数、后继函数、投影函数）与在复合和原始递归运算下的闭包生成了原始递归函数类，并且一个关系是原始递归的，如果其特征函数是原始递归的。丘奇-图灵论题 (CTT) 断言，$\\mathbb{N}$ 上的有效可计算函数与那些可由任何合乎情理的形式体系（如图灵机）计算的函数相一致；在算术层次中，无界最小化算子将原始递归扩展为部分递归函数，这些函数不保证是全函数。\n\n定义无界最小化（$\\mu$算子）如下：对于 $\\mathbb{N}$ 上的谓词 $R(x,y)$，项 $\\mu y\\, R(x,y)$ 表示使 $R(x,y)$ 成立的最小的 $y$（如果这样的 $y$ 存在），否则它不产生值（搜索不终止）。考虑显式原始递归谓词\n$$\nR(x,y) \\equiv \\big(1<y\\big)\\wedge \\big(y<x\\big)\\wedge \\big(y \\text{ divides } x\\big),\n$$\n其中“$y$ 整除 $x$”是存在 $k\\leq x$ 使得 $y\\cdot k=x$ 的简写，不等式和乘法在 $\\mathbb{N}$ 上取其通常的算术意义。\n\n定义函数\n$$\nf(x) \\;=\\; \\mu y\\, R(x,y),\n$$\n即，如果存在，则 $f(x)$ 是 $x$ 的严格介于 $1$ 和 $x$ 之间的最小非平凡除数。\n\n从原始递归函数和关系的基本定义和闭包性质出发，证明 $R$ 是原始递归的，解释为什么应用于 $R$ 的无界 $\\mu$ 算子会产生一个部分函数（给出搜索发散时 $x$ 的明确条件），并确定 $f(2023)$ 的精确值。\n\n你的最终答案必须是一个实数值。无需四舍五入。", "solution": "该问题要求对一个使用无界最小化算子 $\\mu$ 定义的函数 $f(x)$ 进行三部分分析。分析包括：1. 证明在 $f(x)$ 定义中使用的谓词 $R(x,y)$ 是原始递归的。2. 通过确定 $x$ 在何种条件下其值未定义，来解释为什么 $f(x)$ 是一个部分函数而非全函数。3. 计算 $f(2023)$ 的具体值。\n\n首先，我们讨论谓词 $R(x,y)$ 的原始递归性。如果一个关系的特征函数是原始递归函数，则该关系被定义为原始递归的。谓词 $P$ 的特征函数 $\\chi_P$ 定义为：如果 $P(\\dots)$ 为真，则 $\\chi_P(\\dots) = 1$；如果 $P(\\dots)$ 为假，则 $\\chi_P(\\dots) = 0$。\n\n该谓词由下式给出：\n$$\nR(x,y) \\equiv \\big(1<y\\big)\\wedge \\big(y<x\\big)\\wedge \\big(y \\text{ divides } x\\big).\n$$\n原始递归关系类在逻辑运算合取 ($\\wedge$)、析取 ($\\vee$)、否定 ($\\neg$) 以及有界量化 ($\\forall z<t$, $\\exists z<t$) 下是封闭的。这是因为所得关系的特征函数可以利用原始递归函数（如乘法和加法）从原关系的特征函数构造出来。具体来说，对于两个谓词 $P_1$ 和 $P_2$，它们合取的特征函数 $\\chi_{P_1 \\wedge P_2}$ 可以表示为 $\\chi_{P_1} \\cdot \\chi_{P_2}$。因此，如果我们能证明合取的每个分量都是原始递归关系，那么 $R(x,y)$ 本身也必然是原始递归关系。\n\n三个分量谓词是：\n1.  $P_1(y) \\equiv 1 < y$\n2.  $P_2(x,y) \\equiv y < x$\n3.  $P_3(x,y) \\equiv y \\text{ divides } x$\n\n对于 $P_1$ 和 $P_2$，“小于”关系 $u < v$ 是一个标准的原始递归关系。其特征函数可以使用有限减法 (monus) 定义，记为 $u \\dot{-} v$，已知它是原始递归的。例如，$\\chi_{u<v}(u,v) = 1 \\dot{-} (1 \\dot{-} (v \\dot{-} u))$。因为常数（如 $1$）和投影函数是原始递归的，所以关系 $1 < y$ 和 $y < x$ 也是原始递归的。\n\n对于 $P_3(x,y)$，问题将“$y$ 整除 $x$”定义为存在一个 $k \\leq x$ 使得 $y \\cdot k = x$。这可以用有界存在量词正式写成：\n$$\nP_3(x,y) \\equiv (\\exists k \\leq x) [y \\cdot k = x].\n$$\n量词内的谓词是 $Q(x,y,k) \\equiv (y \\cdot k = x)$。乘法函数 ($y \\cdot k$) 是一个原始递归函数。等式关系 ($u=v$) 是一个原始递归关系（其特征函数也可以用 monus 构建：$1 \\dot{-} ((u \\dot{-} v) + (v \\dot{-} u))$）。由于由比较两个原始递归函数形成的谓词是原始递归的，因此 $Q(x,y,k)$ 是一个原始递归关系。原始递归关系类在有界存在量化下是封闭的。因此，$P_3(x,y)$ 是一个原始递归关系。\n\n由于 $P_1(y)$、$P_2(x,y)$ 和 $P_3(x,y)$ 都是原始递归关系，它们的合取 $R(x,y)$ 也是一个原始递归关系。\n\n第二，我们解释为什么 $f(x) = \\mu y\\, R(x,y)$ 可以是一个部分函数。无界最小化算子 $\\mu y \\, R(x,y)$ 被定义为使谓词 $R(x,y)$ 为真的最小自然数 $y$。计算 $f(x)$ 涉及一个搜索过程，按顺序测试 $y=0, 1, 2, \\dots$，直到找到一个满足 $R(x,y)$ 的 $y$。如果不存在这样的 $y$，搜索将永不终止，此时函数 $f(x)$ 对该输入 $x$ 未定义。\n\n对于给定的 $x$，$f(x)$ 有定义当且仅当存在一个 $y \\in \\mathbb{N}$ 使得 $R(x,y)$ 为真。如果 $y$ 是 $x$ 的一个除数，并同时满足 $1 < y < x$，则谓词 $R(x,y)$ 为真。满足 $1 < y < x$ 的 $x$ 的除数被称为真非平凡除数。存在这样的除数是合数的定义。\n\n因此，当且仅当 $x$ 是合数时，对 $y$ 的搜索才会终止。如果 $x$ 不是合数，则不存在这样的 $y$，函数 $f(x)$ 将无定义。不是合数的数是素数，以及特殊情况 $x=0$ 和 $x=1$。\n- 如果 $x$ 是素数，它唯一的正除数是 $1$ 和 $x$。两者都不满足条件 $1 < y < x$。\n- 如果 $x=1$，条件 $y<x$ (即 $y<1$) 仅由 $y=0$ 满足。但 $y=0$ 不满足 $1<y$。因此没有 $y$ 符合要求。\n- 如果 $x=0$，条件 $y<x$ (即 $y<0$) 对任何 $y \\in \\mathbb{N}$ 都不满足。\n\n因此，$f(x)$ 是一个部分函数，仅对合数 $x \\geq 4$ 有定义。对于所有素数 $x$ 以及 $x \\in \\{0, 1\\}$，$f(x)$ 是未定义的。\n\n第三，我们确定 $f(2023)$ 的值。根据定义，$f(2023)$ 是满足 $1 < y < 2023$ 且 $y$ 整除 $2023$ 的最小自然数 $y$。这等价于寻找 $2023$ 的最小素因数。我们按递增顺序测试小的素数。\n- 对于 $y=2$：$2023$ 是一个奇数，所以它不能被 $2$ 整除。\n- 对于 $y=3$：$2023$ 的各位数字之和是 $2+0+2+3=7$。因为 $7$ 不能被 $3$ 整除，所以 $2023$ 不能被 $3$ 整除。\n- 对于 $y=5$：$2023$ 的末位数字不是 $0$ 或 $5$，所以它不能被 $5$ 整除。\n- 对于 $y=7$：我们进行除法运算：$2023 \\div 7$。\n  $$\n  2023 = 2020 + 3 = (202 \\times 10) + 3\n  $$\n  这不是最直接的方法。我们来做长除法：$2023 / 7$。\n  $20 \\div 7 = 2$ 余 $6$。\n  $62 \\div 7 = 8$ 余 $6$。\n  $63 \\div 7 = 9$ 余 $0$。\n  所以，$2023 = 7 \\times 289$。\n\n由于 $y=7$ 整除 $2023$，并且它满足条件 $1 < 7$ 和 $7 < 2023$，所以谓词 $R(2023, 7)$ 为真。由于我们已经证明了没有更小的整数 $y>1$ 能整除 $2023$，因此 $y=7$ 是满足该谓词的最小自然数。\n因此，根据 $\\mu$算子的定义，$f(2023) = 7$。\n为完整起见，我们注意到 $289 = 17^2$，所以 $2023$ 的素因数分解是 $7 \\times 17^2$。$2023$ 严格介于 $1$ 和 $2023$ 之间的除数集合是 $\\{7, 17, 119, 289\\}$。该集合的最小元素确实是 $7$。", "answer": "$$\n\\boxed{7}\n$$", "id": "2970597"}, {"introduction": "形式计算理论最令人惊讶的推论之一，或许就是自引用程序的存在。这个高级练习将引导您使用克林（Kleene）的$s$-$m$-$n$定理和递归定理这一强大工具，来构造一个“quine”——一个输出自身描述的程序。通过从第一性原理出发构建这样一个程序的指标，您将揭开自引用的神秘面紗，并对这些可计算性理论的基石定理获得深刻、操作性的理解[@problem_id:2970608]。", "problem": "固定一个可接受的部分可计算函数的哥德尔配数，使得对每个 $e \\in \\mathbb{N}$，标号 $e$ 指代一个一元部分可计算函数 $y \\mapsto \\varphi_{e}(y)$，并且对每个 $e \\in \\mathbb{N}$，标号 $e$ 也指代一个二元部分可计算函数 $(x,y) \\mapsto \\varphi_{e}^{(2)}(x,y)$（通过任何标准的统一输入配对得到）。假设以下基本事实成立。\n\n1. 存在一个全原始递归配对函数 $\\langle \\cdot,\\cdot \\rangle : \\mathbb{N}^{2} \\to \\mathbb{N}$，该函数是双射的，且其投影是原始递归的。\n2. 存在一个用于二元枚举的通用标号 $U$，使得对所有的 $e,a,y \\in \\mathbb{N}$，有 $\\varphi_{U}^{(2)}(\\langle e,a \\rangle, y) = \\varphi_{e}^{(2)}(a,y)$。\n3. (克莱尼 $s$-$m$-$n$ 定理) 存在一个全原始递归函数 $s : \\mathbb{N}^{2} \\to \\mathbb{N}$，使得对所有的 $e,a,y \\in \\mathbb{N}$，有 $\\varphi_{s(e,a)}(y) = \\varphi_{e}^{(2)}(a,y)$。\n4. 固定二元“打印”程序的标号为 $p$，其定义为对所有 $x,y \\in \\mathbb{N}$，有 $\\varphi_{p}^{(2)}(x,y) = x$。\n\n定义二元部分可计算函数 $D : \\mathbb{N}^{2} \\rightrightarrows \\mathbb{N}$ 为\n$$\nD(x,y) \\;=\\; \\varphi_{s(p,\\,s(x,x))}(y),\n$$\n并固定任意一个标号 $d$ 满足对所有 $x,y \\in \\mathbb{N}$ 都有 $\\varphi_{d}^{(2)}(x,y) = D(x,y)$。\n\n仅使用上述基本事实（特别是克莱尼递归定理和 $s$-$m$-$n$ 定理），构造一个一元自指程序（一个“蒯因”），该程序对任意输入 $y$ 都输出其自身的标号。你的构造必须从第一性原理出发，通过将标号显式地构造为一个由给定原语 $s$、$p$ 和所选标号 $d$ 组成的可计算表达式。在你的推导过程中，解释 $s$-$m$-$n$ 定理在实现自引用方面所扮演的概念性角色。\n\n这样一个蒯因的标号 $e^{\\star}$，用上面介绍的符号 $s$ 和 $d$ 表示的单个闭式表达式是什么？请以单个符号表达式的形式提供你的最终答案。不需要进行数值近似或舍入。", "solution": "此问题陈述是有效的。它是在可计算性理论（数理逻辑的一个子领域）的既定框架内的一个良定问题。它具有科学依据，是客观的，并包含获得唯一解所需的所有必要信息。任务是根据一组给定的原始可计算函数和标号，构造一个自指程序（一个蒯因）的标号。\n\n目标是找到一个标号 $e^{\\star} \\in \\mathbb{N}$，使得对所有输入 $y \\in \\mathbb{N}$，部分可计算函数 $\\varphi_{e^{\\star}}$ 都会停机并输出其自身的标号：$\\varphi_{e^{\\star}}(y) = e^{\\star}$。\n\n该构造从根本上依赖于克莱尼 $s$-$m$-$n$ 定理。该定理提供了一个全原始递归函数 $s: \\mathbb{N}^2 \\to \\mathbb{N}$，使得对于二元部分可计算函数 $\\varphi_e^{(2)}(x,y)$ 的任意标号 $e$ 和第一个输入的任意值 $a \\in \\mathbb{N}$，我们可以计算出得到的一元函数的新标号 $s(e,a)$。即 $\\varphi_{s(e,a)}(y) = \\varphi_e^{(2)}(a,y)$。从概念上讲，$s$-$m$-$n$ 定理将特化或部分求值的过程形式化：它提供了一种可计算的方法，通过固定一个输入，将一个通用程序（标号 $e$）转换为一个专用程序（标号 $s(e,a)$）。程序机械地生成其他程序标号的这种能力，是实现蒯因所需自引用的关键机制，正如克莱尼递归定理的构造性证明所示。\n\n构造过程首先分析问题陈述中提供的函数 $D(x,y)$。该函数定义为 $D(x,y) = \\varphi_{s(p, s(x,x))}(y)$。我们已知 $d$ 是此函数的标号，意味着对所有 $x,y \\in \\mathbb{N}$ 都有 $\\varphi_d^{(2)}(x,y) = D(x,y)$。\n\n让我们简化 $D(x,y)$ 的表达式。\n根据 $s$-$m$-$n$ 定理的定义，我们可以陈述：对任意 $e, a, y \\in \\mathbb{N}$：\n$$\n\\varphi_{s(e,a)}(y) = \\varphi_{e}^{(2)}(a,y)\n$$\n在 $D(x,y)$ 的表达式中，我们可以确定 $e=p$ 和 $a=s(x,x)$。应用该定理可得：\n$$\n\\varphi_{s(p, s(x,x))}(y) = \\varphi_{p}^{(2)}(s(x,x), y)\n$$\n问题将标号 $p$ 定义为对应二元“打印”程序，使得对所有 $z, y \\in \\mathbb{N}$ 有 $\\varphi_{p}^{(2)}(z,y) = z$。代入 $z = s(x,x)$，我们得到：\n$$\n\\varphi_{p}^{(2)}(s(x,x), y) = s(x,x)\n$$\n结合这些结果，我们得到 $D(x,y)$ 的简化形式：\n$$\nD(x,y) = \\varphi_{s(p, s(x,x))}(y) = s(x,x)\n$$\n由于 $d$ 是 $D(x,y)$ 的标号，我们确立了标号为 $d$ 的程序的一个关键性质：\n$$\n\\varphi_{d}^{(2)}(x,y) = s(x,x)\n$$\n这意味着标号为 $d$ 的二元程序接收两个输入 $x$ 和 $y$，忽略第二个输入 $y$，并返回值 $s(x,x)$。\n\n我们现在采用一种模仿克莱尼递归定理证明的构造方法来找到所需的不动点。该定理的构造性证明表明，对于像 $\\varphi_d^{(2)}$ 这样的函数，通常可以通过将 $s$ 函数应用于函数自身的标号来找到不动点。让我们提出我们的蒯因的候选标号 $e^{\\star}$ 为：\n$$\ne^{\\star} = s(d,d)\n$$\n为验证该标号对应一个蒯因，我们必须对任意输入 $y \\in \\mathbb{N}$ 计算函数 $\\varphi_{e^{\\star}}(y)$。\n\n根据 $e^{\\star}$ 的定义，我们有：\n$$\n\\varphi_{e^{\\star}}(y) = \\varphi_{s(d,d)}(y)\n$$\n我们将 $s$-$m$-$n$ 定理应用于右侧，其中 $e=d$ 且 $a=d$：\n$$\n\\varphi_{s(d,d)}(y) = \\varphi_{d}^{(2)}(d,y)\n$$\n现在，我们使用先前推导出的函数 $\\varphi_d^{(2)}$ 的性质，该性质表明对所有 $x,y$ 都有 $\\varphi_d^{(2)}(x,y) = s(x,x)$。我们代入 $x=d$：\n$$\n\\varphi_{d}^{(2)}(d,y) = s(d,d)\n$$\n将这些等式串联起来，我们得到：\n$$\n\\varphi_{e^{\\star}}(y) = \\varphi_{s(d,d)}(y) = \\varphi_{d}^{(2)}(d,y) = s(d,d)\n$$\n由于我们定义了 $e^{\\star} = s(d,d)$，我们已经证明了对任何输入 $y$，都有\n$$\n\\varphi_{e^{\\star}}(y) = e^{\\star}\n$$\n这证实了标号 $e^{\\star} = s(d,d)$ 确实是一个蒯因的标号。该表达式完全由给定的原语 $s$ 和 $d$ 构成，符合要求。", "answer": "$$\n\\boxed{s(d,d)}\n$$", "id": "2970608"}]}