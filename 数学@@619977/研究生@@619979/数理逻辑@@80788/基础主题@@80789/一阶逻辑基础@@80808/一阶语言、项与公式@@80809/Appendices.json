{"hands_on_practices": [{"introduction": "在一阶逻辑中，项 (term) 扮演着“名词”的角色，用于指代我们所讨论域中的对象。正如自然语言中的名词短语有其语法规则，一阶逻辑中的项也必须遵循严格的递归定义来构造，例如，若 $f$ 是一个 $n$-元函数符号，$t_1, \\dots, t_n$ 是项，则 $f(t_1, \\dots, t_n)$ 也是一个项。此练习 [@problem_id:2972885] 旨在通过一个具体情景，检验您对这些构造规则的精确理解，特别是关于函数符号“元数”(arity) 的约束，这是确保我们语言表达清晰无误的第一步。", "problem": "考虑一阶逻辑中基于一个签名 $L$ 的项的抽象语法形成规则。一个签名 $L$ 由一个有限的函数符号集（每个符号都有指定的非负整数元数，其中 $0$-元函数符号是常量）和一个有限的谓词符号集（每个符号都有指定的正整数元数）组成。假设变量集是可数无限的，例如 $\\{x,y,z,u,v,w,\\dots\\}$。项的形成规则如下：(i) 每个变量都是一个项；(ii) 每个常量符号都是一个项；(iii) 如果 $f$ 是 $L$ 中的一个 $n$-元函数符号，且 $t_1,\\dots,t_n$ 是项，那么 $f(t_1,\\dots,t_n)$ 是一个项；(iv) 此外再无别的项。谓词符号和逻辑联结词用于构成公式，不允许出现在项的内部。\n\n选择一个选项，该选项指定一个有限签名 $L$ 并展示一个由 $L$ 的符号构成的具体字符串，该字符串不成其为一个 $L$-项的唯一原因是函数应用中的元数不匹配，且没有其他违反形成规则的情况（也就是说，该字符串仅使用来自 $L$ 的符号，没有在项的位置插入任何谓词应用或逻辑联结词，并使用标准的括号和逗号进行函数应用）。\n\nA. $L$ 有一元函数符号 $f$、三元函数符号 $g$、常量 $c$ 和二元谓词符号 $R$。字符串是 $f(g(x,y),c)$。\n\nB. $L$ 有一元函数符号 $f$、二元函数符号 $g$、常量 $c$ 和一元谓词符号 $R$。字符串是 $f(g(x,R(x)))$。\n\nC. $L$ 有一元函数符号 $f$、二元函数符号 $g$ 和常量 $c$。字符串是 $f(g(x,y,z))$。\n\nD. $L$ 对每个 $n \\in \\mathbb{N}$ 都有函数符号 $f_n$，其中 $f_n$ 是 $n$-元函数，以及常量 $c$。字符串是 $f_2(x,y,z)$。\n\nE. $L$ 有二元谓词符号 $p$ 和常量 $c$。字符串是 $p(c,c)$。", "solution": "首先验证问题陈述的正确性和可解性。\n\n### 步骤 1：提取已知条件\n问题为一阶语言中基于签名 $L$ 的项提供了以下定义和条件：\n-   一个签名 $L$ 由一个有限的函数符号集和一个有限的谓词符号集组成。\n-   每个函数符号都有指定的非负整数元数。$0$-元的函数符号是常量。\n-   每个谓词符号都有指定的正整数元数。\n-   变量集是可数无限的，例如 $\\{x,y,z,u,v,w,\\dots\\}$。\n-   项的形成规则是：\n    1.  每个变量都是一个项。\n    2.  每个常量符号都是一个项。\n    3.  如果 $f$ 是 $L$ 中的一个 $n$-元函数符号，且 $t_1,\\dots,t_n$ 是项，那么 $f(t_1,\\dots,t_n)$ 是一个项。\n    4.  此外再无别的项。\n-   给出了一个约束条件：谓词符号和逻辑联结词用于构成公式，不允许出现在项的内部。\n-   任务是选择一个选项，该选项指定一个有限签名 $L$ 并展示一个字符串，该字符串不成其为一个 $L$-项的*唯一*原因是函数应用中的元数不匹配，且没有其他违规行为。\n-   对于该失败情况，其他指定的条件是：字符串仅使用来自 $L$ 的符号和变量，不使用谓词应用或联结词代替项，并使用标准的函数应用语法。\n\n### 步骤 2：使用提取的已知条件进行验证\n该问题在数理逻辑的标准框架内，特别是在一阶语言的句法方面，是良定义的。\n-   **科学依据**：签名、项、元数和形成规则的定义都是一阶逻辑中标准和基础的内容。该问题在科学上是合理的。\n-   **良态**：问题是精确的。它要求在给定的签名下，识别一种特定类型的句法错误——元数不匹配——作为表达式不成其为项的唯一原因。标准很明确，意味着应该存在一个唯一的正确选项。\n-   **客观性**：问题以形式化、客观的语言陈述，没有歧义或主观元素。\n-   **完整性和一致性**：提供了项的形成规则，并详细说明了所需错误的性质。问题是自洽的。一个选项（D）提出了一个无限签名，这与问题关于 $L$ 具有“有限的函数符号集”的全局定义相矛盾。然而，问题要求“选择一个选项，该选项指定一个**有限签名** $L$”。这使得选项 D 根据问题自身的标准成为一个无效选择，但这并不使问题陈述本身无效。该问题仍然是应用给定定义的有效练习。\n\n### 步骤 3：结论与行动\n问题陈述是有效的。这是一个应用一阶逻辑句法规则的标准练习。可以开始求解过程。\n\n### 求解推导\n任务是确定一个选项，其中字符串不成其为项的原因只有一个：函数应用中的单个元数不匹配。所有其他句法规则在该特定错误点之前都必须被遵守。我们将根据项的递归定义来分析每个选项。\n\n一个项要么是一个变量，要么是一个常量，要么是一个 $n$-元函数符号 $f$ 应用于 $n$ 个其他已经形成的项 $t_1, \\dots, t_n$。当一个 $n$-元函数符号被应用于 $k \\neq n$ 个参数时，就会发生元数不匹配。如果参数本身是合法的项，并且没有违反其他规则（例如，在需要项的地方使用了谓词），那么这个错误就是“唯一的”。\n\n**选项 A. $L$ 有一元函数符号 $f$、三元函数符号 $g$、常量 $c$ 和二元谓词符号 $R$。字符串是 $f(g(x,y),c)$。**\n\n我们来解析字符串 $f(g(x,y),c)$。\n1.  最外层是函数符号 $f$ 的应用。 $f$被定义为一元函数，意味着它只接受 $1$ 个参数。该字符串提供了 $2$ 个参数：$g(x,y)$ 和 $c$。这是一个元数不匹配。\n2.  我们来检查第一个参数，$g(x,y)$。符号 $g$ 是一个三元函数，意味着它接受 $3$ 个参数。这里它被给予了 $2$ 个参数，$x$ 和 $y$（它们是合法的项，因为是变量）。这也是一个元数不匹配。\n因此，该字符串包含两个不同的元数不匹配。其不成其为项的原因不是由于“一个元数不匹配”（单数），而是至少有两个。因此，这个选项不满足“唯一原因是元数不匹配”这一标准（就单一故障点而言）。\n\n选项 A 的判定：**错误**。\n\n**选项 B. $L$ 有一元函数符号 $f$、二元函数符号 $g$、常量 $c$ 和一元谓词符号 $R$。字符串是 $f(g(x,R(x)))$。**\n\n我们来解析字符串 $f(g(x,R(x)))$。\n1.  最内层是 $R(x)$。符号 $R$ 是一个一元谓词符号。它应用于一个项（变量 $x$）会产生一个原子公式，而不是一个项。\n2.  形成规则明确指出，项只能是变量、常量或函数应用。问题进一步澄清，“谓词符号……不允许出现在项的内部”。\n3.  表达式 $g(x,R(x))$ 试图使用公式 $R(x)$ 作为函数 $g$ 的第二个参数。这违反了项的定义（规则 (iii)），该规则要求函数的所有参数本身都必须是项。\n该字符串不成其为项的原因是在需要项的位置非法使用了谓词应用。这是一种与元数不匹配不同类型的句法违规。\n\n选项 B 的判定：**错误**。\n\n**选项 C. $L$ 有一元函数符号 $f$、二元函数符号 $g$ 和常量 $c$。字符串是 $f(g(x,y,z))$。**\n\n我们来解析字符串 $f(g(x,y,z))$。\n1.  最外层是函数符号 $f$ 的应用。 $f$ 是一元的，它被给予了恰好 $1$ 个参数，即表达式 $g(x,y,z)$。在 $f$ 的应用中，元数是正确的（一元函数有 $1$ 个参数）。\n2.  要使 $f(g(x,y,z))$ 成为一个项，它的参数 $g(x,y,z)$ 必须是一个项。\n3.  我们来分析 $g(x,y,z)$。函数符号 $g$ 是二元的，意味着它需要 $2$ 个参数。在这里，它被应用于 $3$ 个参数：$x$、$y$ 和 $z$。\n4.  参数 $x$、$y$ 和 $z$ 都是变量，它们是合法的项。没有使用谓词符号。句法在其他方面是标准的。\n5.  将 $g$ 应用于 $3$ 个参数是一个元数不匹配。因此，$g(x,y,z)$ 不是一个合法的项。\n6.  由于 $g(x,y,z)$ 不是一个项，所以整个表达式 $f(g(x,y,z))$ 也不是一个项。阻止该字符串成为一个项的根本错误是 $g$ 应用中的单个元数不匹配。在此之前，字符串构建过程的所有其他方面都是正确的。这完全符合问题的描述。\n\n选项 C 的判定：**正确**。\n\n**选项 D. $L$ 对每个 $n \\in \\mathbb{N}$ 都有函数符号 $f_n$，其中 $f_n$ 是 $n$-元函数，以及常量 $c$。字符串是 $f_2(x,y,z)$。**\n\n问题陈述建立了一个全局条件：“一个签名 $L$ 由一个**有限**的函数符号集……组成”。此选项中提出的签名包含函数符号集 $\\{f_n | n \\in \\mathbb{N}\\}$，这是一个可数无限集。因此，此选项指定了一个非有限的签名，违反了问题的一个前提条件。问题要求选择一个“指定一个有限签名 $L$”的选项。此选项未能做到这一点。\n\n即使我们忽略这一违规，字符串 $f_2(x,y,z)$ 将一个二元函数符号 $f_2$ 应用于 3 个参数，这是一个元数不匹配。选项的这一部分是正确的，但关于签名的初始前提是有缺陷的。\n\n选项 D 的判定：**错误**。\n\n**选项 E. $L$ 有二元谓词符号 $p$ 和常量 $c$。字符串是 $p(c,c)$。**\n\n我们来分析字符串 $p(c,c)$。\n1.  符号 $p$ 是一个二元谓词符号。\n2.  符号 $c$ 是一个常量，因此是一个合法的项。\n3.  字符串 $p(c,c)$ 是一个二元谓词符号对 $2$ 个项的应用。这是一个合法的原子公式的定义。\n4.  问题要求一个*不成其为项*的字符串。字符串 $p(c,c)$ 是一个公式，而不是一个项。所以它确实不成其为项。\n5.  然而，这个失败的原因必须是“唯一原因是函数应用中的元数不匹配”。符号 $p$ 是一个谓词，而不是一个函数。这里没有函数应用，因此也没有函数应用的元数不匹配。该字符串不是一个项，因为它是一个公式。这是一个范畴上的差异，而不是项的构造错误。\n\n选项 E 的判定：**错误**。\n\n**结论**\n只有选项C提供了一个有限签名和一个字符串，该字符串由于函数应用中单一、局部的元数不匹配而成为一个构造错误的项，且没有其他句法错误。", "answer": "$$\\boxed{C}$$", "id": "2972885"}, {"introduction": "掌握了如何合乎语法地构造项之后，下一步是理解它们的“意义”(semantics)。这通过在一个具体的数学“结构” $\\mathcal{M}$ 或“模型”中对项进行解释来实现，我们称之为计算项 $t$ 的解释值 $\\llbracket t \\rrbracket^{\\mathcal{M}}$。此练习 [@problem_id:2972859] 提供了一个有限结构，并要求您逐步计算一个复杂嵌套项的解释值，从而将抽象的递归解释定义转化为一个具体的计算过程，深刻体会语法与语义之间的联系。", "problem": "设 $\\mathcal{L}$ 是一个一阶语言，其包含一个常量符号 $c$，一个一元函数符号 $f$，一个二元函数符号 $g$，以及一个三元函数符号 $h$。考虑一个有限 $\\mathcal{L}$-结构 $\\mathcal{M}$，其论域为 $M = \\{0,1,2,3,4,5,6\\}$，所有算术运算均在模 $7$ 下进行，且符号解释如下：\n- $c^{\\mathcal{M}} = 5$，\n- $f^{\\mathcal{M}}(u) = 3u^{2} + 1$ （在模 $7$ 下计算），\n- $g^{\\mathcal{M}}(u,v) = 2u + 4v + 3$ （在模 $7$ 下计算），\n- $h^{\\mathcal{M}}(u,v,w) = u \\cdot v - 2w$ （在模 $7$ 下计算）。\n\n设 $\\alpha$ 是一个变量赋值，其中 $\\alpha(x) = 3$ 且 $\\alpha(y) = 6$。考虑 $\\mathcal{L}$-项\n$$t := h\\big(f(g(x, f(c))),\\ g(f(x), h(c, x, y)),\\ f(f(y))\\big).$$\n\n仅使用一阶逻辑（FOL）中用于解释项的基本递归子句——即针对常量符号、变量和函数应用的子句——计算 $\\llbracket t \\rrbracket^{\\mathcal{M},\\alpha} \\in M$ 的值，并在你的推导过程中逐步验证每个子句的应用。将最终答案表示为 $M$ 中的一个精确元素。无需四舍五入，也不涉及单位。", "solution": "该问题陈述是数理逻辑领域内，特别是模型论范畴下的一个良构练习题。它提供了一个一阶语言 $\\mathcal{L}$、一个具有明确定义的论域和所有非逻辑符号解释的有限 $\\mathcal{L}$-结构 $\\mathcal{M}$、一个合式 $\\mathcal{L}$-项 $t$，以及一个覆盖了 $t$ 中所有自由变量的变量赋值 $\\alpha$。任务是计算项 $t$ 在结构 $\\mathcal{M}$ 中关于赋值 $\\alpha$ 的解释，记作 $\\llbracket t \\rrbracket^{\\mathcal{M},\\alpha}$。所有组成部分都经过了形式化定义且自洽。该问题具有科学基础、客观，并包含足够的信息以得出唯一解。因此，该问题是有效的。\n\n在一个结构 $\\mathcal{M}$ 中，一个项 $\\tau$ 在变量赋值 $\\alpha$ 下的解释，记作 $\\llbracket \\tau \\rrbracket^{\\mathcal{M},\\alpha}$，由以下一阶逻辑的基本子句递归定义：\n$1$. 如果 $\\tau$ 是一个变量 $v$，则 $\\llbracket v \\rrbracket^{\\mathcal{M},\\alpha} = \\alpha(v)$。\n$2$. 如果 $\\tau$ 是一个常量符号 $c$，则 $\\llbracket c \\rrbracket^{\\mathcal{M},\\alpha} = c^{\\mathcal{M}}$。\n$3$. 如果 $\\tau$ 是形如 $F(t_1, ..., t_n)$ 的项，其中 $F$ 是一个 $n$-元函数符号，而 $t_1, ..., t_n$ 是项，则 $\\llbracket F(t_1, ..., t_n) \\rrbracket^{\\mathcal{M},\\alpha} = F^{\\mathcal{M}}(\\llbracket t_1 \\rrbracket^{\\mathcal{M},\\alpha}, ..., \\llbracket t_n \\rrbracket^{\\mathcal{M},\\alpha})$。\n\n我们需要计算项\n$$t := h\\big(f(g(x, f(c))),\\ g(f(x), h(c, x, y)),\\ f(f(y))\\big)$$\n在论域为 $M = \\{0,1,2,3,4,5,6\\}$ 的结构 $\\mathcal{M}$ 中，以及在赋值 $\\alpha(x) = 3$，$\\alpha(y) = 6$ 下的值。我们将从最内层向外，递归地计算 $t$ 的各子项的值。所有算术运算都将在模 $7$ 下进行。\n\n设最外层函数 $h$ 的三个主要参数分别表示为：\n- $t_1 := f(g(x, f(c)))$\n- $t_2 := g(f(x), h(c, x, y))$\n- $t_3 := f(f(y))$\n\n我们的目标是计算 $\\llbracket t \\rrbracket^{\\mathcal{M},\\alpha} = h^{\\mathcal{M}}(\\llbracket t_1 \\rrbracket^{\\mathcal{M},\\alpha}, \\llbracket t_2 \\rrbracket^{\\mathcal{M},\\alpha}, \\llbracket t_3 \\rrbracket^{\\mathcal{M},\\alpha})$。\n\n**步骤 1：求值 $\\llbracket t_1 \\rrbracket^{\\mathcal{M},\\alpha}$**\n为求得 $\\llbracket t_1 \\rrbracket^{\\mathcal{M},\\alpha} = \\llbracket f(g(x, f(c))) \\rrbracket^{\\mathcal{M},\\alpha}$，我们必须首先求值其参数 $\\llbracket g(x, f(c)) \\rrbracket^{\\mathcal{M},\\alpha}$。这又需要求值 $\\llbracket x \\rrbracket^{\\mathcal{M},\\alpha}$ 和 $\\llbracket f(c) \\rrbracket^{\\mathcal{M},\\alpha}$。\n\n- 求值 $\\llbracket f(c) \\rrbracket^{\\mathcal{M},\\alpha}$：\n    - 根据子句2，常量符号 $c$ 的解释为 $\\llbracket c \\rrbracket^{\\mathcal{M},\\alpha} = c^{\\mathcal{M}} = 5$。\n    - 根据子句3，$\\llbracket f(c) \\rrbracket^{\\mathcal{M},\\alpha} = f^{\\mathcal{M}}(\\llbracket c \\rrbracket^{\\mathcal{M},\\alpha}) = f^{\\mathcal{M}}(5)$。\n    - 使用定义 $f^{\\mathcal{M}}(u) = 3u^2 + 1$，我们计算：\n    $$f^{\\mathcal{M}}(5) = 3 \\cdot 5^2 + 1 = 3 \\cdot 25 + 1 \\pmod{7}$$\n    - 因为 $25 \\equiv 4 \\pmod{7}$，我们有：\n    $$3 \\cdot 4 + 1 = 12 + 1 = 13 \\equiv 6 \\pmod{7}$$\n    - 因此，$\\llbracket f(c) \\rrbracket^{\\mathcal{M},\\alpha} = 6$。\n\n- 求值 $\\llbracket g(x, f(c)) \\rrbracket^{\\mathcal{M},\\alpha}$：\n    - 根据子句1，变量 $x$ 的解释为 $\\llbracket x \\rrbracket^{\\mathcal{M},\\alpha} = \\alpha(x) = 3$。\n    - 根据子句3，使用以上结果：\n    $$\\llbracket g(x, f(c)) \\rrbracket^{\\mathcal{M},\\alpha} = g^{\\mathcal{M}}(\\llbracket x \\rrbracket^{\\mathcal{M},\\alpha}, \\llbracket f(c) \\rrbracket^{\\mathcal{M},\\alpha}) = g^{\\mathcal{M}}(3, 6)$$\n    - 使用定义 $g^{\\mathcal{M}}(u,v) = 2u + 4v + 3$，我们计算：\n    $$g^{\\mathcal{M}}(3, 6) = 2 \\cdot 3 + 4 \\cdot 6 + 3 = 6 + 24 + 3 = 33 \\pmod{7}$$\n    - 因为 $33 = 4 \\cdot 7 + 5$，所以 $33 \\equiv 5 \\pmod{7}$。\n    - 因此，$\\llbracket g(x, f(c)) \\rrbracket^{\\mathcal{M},\\alpha} = 5$。\n\n- $\\llbracket t_1 \\rrbracket^{\\mathcal{M},\\alpha}$ 的最终求值：\n    - 根据子句3，$\\llbracket t_1 \\rrbracket^{\\mathcal{M},\\alpha} = f^{\\mathcal{M}}(\\llbracket g(x, f(c)) \\rrbracket^{\\mathcal{M},\\alpha}) = f^{\\mathcal{M}}(5)$。\n    - 我们已经计算出 $f^{\\mathcal{M}}(5) = 6$。\n    - 所以，$\\llbracket t_1 \\rrbracket^{\\mathcal{M},\\alpha} = 6$。\n\n**步骤 2：求值 $\\llbracket t_2 \\rrbracket^{\\mathcal{M},\\alpha}$**\n为求得 $\\llbracket t_2 \\rrbracket^{\\mathcal{M},\\alpha} = \\llbracket g(f(x), h(c, x, y)) \\rrbracket^{\\mathcal{M},\\alpha}$，我们必须求值其参数 $\\llbracket f(x) \\rrbracket^{\\mathcal{M},\\alpha}$ 和 $\\llbracket h(c, x, y) \\rrbracket^{\\mathcal{M},\\alpha}$。\n\n- 求值 $\\llbracket f(x) \\rrbracket^{\\mathcal{M},\\alpha}$：\n    - 我们有 $\\llbracket x \\rrbracket^{\\mathcal{M},\\alpha} = 3$。\n    - 根据子句3，$\\llbracket f(x) \\rrbracket^{\\mathcal{M},\\alpha} = f^{\\mathcal{M}}(\\llbracket x \\rrbracket^{\\mathcal{M},\\alpha}) = f^{\\mathcal{M}}(3)$。\n    - 计算：$f^{\\mathcal{M}}(3) = 3 \\cdot 3^2 + 1 = 3 \\cdot 9 + 1 = 27 + 1 = 28 \\pmod{7}$。\n    - 因为 $28 = 4 \\cdot 7 + 0$，所以 $28 \\equiv 0 \\pmod{7}$。\n    - 因此，$\\llbracket f(x) \\rrbracket^{\\mathcal{M},\\alpha} = 0$。\n\n- 求值 $\\llbracket h(c, x, y) \\rrbracket^{\\mathcal{M},\\alpha}$：\n    - 我们有 $\\llbracket c \\rrbracket^{\\mathcal{M},\\alpha} = 5$，$\\llbracket x \\rrbracket^{\\mathcal{M},\\alpha} = 3$ 以及 $\\llbracket y \\rrbracket^{\\mathcal{M},\\alpha} = \\alpha(y) = 6$。\n    - 根据子句3：$\\llbracket h(c, x, y) \\rrbracket^{\\mathcal{M},\\alpha} = h^{\\mathcal{M}}(\\llbracket c \\rrbracket^{\\mathcal{M},\\alpha}, \\llbracket x \\rrbracket^{\\mathcal{M},\\alpha}, \\llbracket y \\rrbracket^{\\mathcal{M},\\alpha}) = h^{\\mathcal{M}}(5, 3, 6)$。\n    - 使用定义 $h^{\\mathcal{M}}(u,v,w) = u \\cdot v - 2w$，我们计算：\n    $$h^{\\mathcal{M}}(5, 3, 6) = 5 \\cdot 3 - 2 \\cdot 6 = 15 - 12 = 3 \\pmod{7}$$\n    - 因此，$\\llbracket h(c, x, y) \\rrbracket^{\\mathcal{M},\\alpha} = 3$。\n\n- $\\llbracket t_2 \\rrbracket^{\\mathcal{M},\\alpha}$ 的最终求值：\n    - 根据子句3，$\\llbracket t_2 \\rrbracket^{\\mathcal{M},\\alpha} = g^{\\mathcal{M}}(\\llbracket f(x) \\rrbracket^{\\mathcal{M},\\alpha}, \\llbracket h(c, x, y) \\rrbracket^{\\mathcal{M},\\alpha}) = g^{\\mathcal{M}}(0, 3)$。\n    - 计算：$g^{\\mathcal{M}}(0, 3) = 2 \\cdot 0 + 4 \\cdot 3 + 3 = 0 + 12 + 3 = 15 \\pmod{7}$。\n    - 因为 $15 = 2 \\cdot 7 + 1$，所以 $15 \\equiv 1 \\pmod{7}$。\n    - 所以，$\\llbracket t_2 \\rrbracket^{\\mathcal{M},\\alpha} = 1$。\n\n**步骤 3：求值 $\\llbracket t_3 \\rrbracket^{\\mathcal{M},\\alpha}$**\n为求得 $\\llbracket t_3 \\rrbracket^{\\mathcal{M},\\alpha} = \\llbracket f(f(y)) \\rrbracket^{\\mathcal{M},\\alpha}$，我们首先求值内层项 $\\llbracket f(y) \\rrbracket^{\\mathcal{M},\\alpha}$。\n\n- 求值 $\\llbracket f(y) \\rrbracket^{\\mathcal{M},\\alpha}$：\n    - 我们有 $\\llbracket y \\rrbracket^{\\mathcal{M},\\alpha} = 6$。\n    - 根据子句3，$\\llbracket f(y) \\rrbracket^{\\mathcal{M},\\alpha} = f^{\\mathcal{M}}(\\llbracket y \\rrbracket^{\\mathcal{M},\\alpha}) = f^{\\mathcal{M}}(6)$。\n    - 计算：$f^{\\mathcal{M}}(6) = 3 \\cdot 6^2 + 1 \\pmod{7}$。\n    - 因为 $6 \\equiv -1 \\pmod{7}$，我们有 $6^2 \\equiv (-1)^2 = 1 \\pmod{7}$。\n    - $f^{\\mathcal{M}}(6) = 3 \\cdot 1 + 1 = 4 \\pmod{7}$。\n    - 因此，$\\llbracket f(y) \\rrbracket^{\\mathcal{M},\\alpha} = 4$。\n\n- $\\llbracket t_3 \\rrbracket^{\\mathcal{M},\\alpha}$ 的最终求值：\n    - 根据子句3，$\\llbracket t_3 \\rrbracket^{\\mathcal{M},\\alpha} = f^{\\mathcal{M}}(\\llbracket f(y) \\rrbracket^{\\mathcal{M},\\alpha}) = f^{\\mathcal{M}}(4)$。\n    - 计算：$f^{\\mathcal{M}}(4) = 3 \\cdot 4^2 + 1 = 3 \\cdot 16 + 1 \\pmod{7}$。\n    - 因为 $16 \\equiv 2 \\pmod{7}$，我们有：\n    $$f^{\\mathcal{M}}(4) = 3 \\cdot 2 + 1 = 6 + 1 = 7 \\equiv 0 \\pmod{7}$$\n    - 所以，$\\llbracket t_3 \\rrbracket^{\\mathcal{M},\\alpha} = 0$。\n\n**步骤 4：$\\llbracket t \\rrbracket^{\\mathcal{M},\\alpha}$ 的最终计算**\n现在我们已经得到了主项 $t$ 的三个参数的解释：\n- $\\llbracket t_1 \\rrbracket^{\\mathcal{M},\\alpha} = 6$\n- $\\llbracket t_2 \\rrbracket^{\\mathcal{M},\\alpha} = 1$\n- $\\llbracket t_3 \\rrbracket^{\\mathcal{M},\\alpha} = 0$\n\n对完整项 $t$ 最后一次使用子句3：\n$$\\llbracket t \\rrbracket^{\\mathcal{M},\\alpha} = h^{\\mathcal{M}}(\\llbracket t_1 \\rrbracket^{\\mathcal{M},\\alpha}, \\llbracket t_2 \\rrbracket^{\\mathcal{M},\\alpha}, \\llbracket t_3 \\rrbracket^{\\mathcal{M},\\alpha}) = h^{\\mathcal{M}}(6, 1, 0)$$\n- 使用 $h^{\\mathcal{M}}(u,v,w) = u \\cdot v - 2w$ 进行计算：\n$$h^{\\mathcal{M}}(6, 1, 0) = 6 \\cdot 1 - 2 \\cdot 0 = 6 - 0 = 6 \\pmod{7}$$\n\n项 $t$ 在结构 $\\mathcal{M}$ 中，于赋值 $\\alpha$ 下的值为 $6$。", "answer": "$$\\boxed{6}$$", "id": "2972859"}, {"introduction": "对公式进行操作是逻辑推理的核心，其中最重要的操作之一是代换，记作 $\\varphi[x := t]$。然而，在量化公式中进行代换时，一个常见的陷阱是“变量捕获”(variable capture)，即被代入的项 $t$ 中的自由变量被 $\\varphi$ 中的量词意外地绑定，根本性地改变了公式的原意。此练习 [@problem_id:2972882] 精心设计了一个会导致变量捕获的场景，要求您应用正确的避捕获代换规则，从而掌握处理量化与变量这一核心难题的必要技能。", "problem": "考虑一个语言 $\\mathcal{L}$ 上的一阶逻辑 (FOL)，该语言有一个二元谓词符号 $R$、一个一元谓词符号 $P$、变量 $x$、$y$、$z$、$w$ 以及通常的逻辑连接词和量词。仅使用自由变量和约束变量、句法替换以及约束变量重命名（也称为 $\\alpha$-变换）的核心定义。令\n$$\n\\varphi(x) \\;=\\; \\forall y \\,\\Big( R(x,y) \\;\\rightarrow\\; \\exists y \\,\\big( P(y) \\,\\land\\, R(y,x) \\big) \\Big).\n$$\n我们打算将项 $y$ 替换 $\\varphi$ 中的自由变量 $x$，记作 $\\varphi[x := y]$。根据避免捕获的替换的定义，每当替换会将替换项中的一个自由变量置于一个约束同名变量的量词之下时，必须首先对该约束变量进行系统性重命名，将其改为一个对于替换项而言是“新鲜”的变量。\n\n在 $\\alpha$-等价的意义下，以下哪个候选公式是将 $y$ 替换 $\\varphi(x)$ 中的 $x$ 进行避免捕获的替换后的正确结果？请选择所有适用的选项。不正确的选项看似合理，但因变量捕获或不正确的重命名而错误。\n\nA. $\\forall y \\,\\Big( R(y,y) \\;\\rightarrow\\; \\exists y \\,\\big( P(y) \\,\\land\\, R(y,y) \\big) \\Big)$\n\nB. $\\forall z \\,\\Big( R(y,z) \\;\\rightarrow\\; \\exists y \\,\\big( P(y) \\,\\land\\, R(y,y) \\big) \\Big)$\n\nC. $\\forall y \\,\\Big( R(y,y) \\;\\rightarrow\\; \\exists w \\,\\big( P(w) \\,\\land\\, R(w,y) \\big) \\Big)$\n\nD. $\\forall z \\,\\Big( R(y,z) \\;\\rightarrow\\; \\exists w \\,\\big( P(w) \\,\\land\\, R(w,y) \\big) \\Big)$\n\nE. $\\forall z \\,\\Big( R(y,z) \\;\\rightarrow\\; \\exists z \\,\\big( P(z) \\,\\land\\, R(z,y) \\big) \\Big)$\n\n你的推理应从形式化定义出发：如果一个变量的出现位于约束它的量词的作用域内，则它是约束的；否则它是自由的。一个公式 $\\psi$ 的自由变量集合 $FV(\\psi)$ 是根据公式结构归纳定义的。替换 $\\psi[x := t]$ 是根据 $\\psi$ 的结构归纳定义的，但有一个附加条件：在将 $t$ 替换进一个量词（该量词约束一个在 $t$ 中自由出现的变量）的作用域之前，该约束变量必须被重命名为一个不在 $t$ 中自由出现的变量（并且相对于上下文是新鲜的），以防止变量捕获。不要使用任何临时的捷径；直接根据这些定义来证明每个结论。", "solution": "用户想要在一阶逻辑中找到一个避免捕获的替换的正确结果。\n\n### 步骤 1：提取已知条件\n-   **语言 $\\mathcal{L}$**：包含一个二元谓词符号 $R$、一个一元谓词符号 $P$ 以及变量 $x$、$y$、$z$、$w$。\n-   **公式 $\\varphi(x)$**：定义为 $\\varphi(x) \\;=\\; \\forall y \\,\\Big( R(x,y) \\;\\rightarrow\\; \\exists y \\,\\big( P(y) \\,\\land\\, R(y,x) \\big) \\Big)$。\n-   **任务**：对 $\\varphi(x)$ 中的自由变量 $x$ 进行项 $y$ 的避免捕获的替换，记作 $\\varphi(x)[x := y]$。\n-   **核心定义**：推理必须基于自由变量和约束变量、句法替换和 $\\alpha$-变换（约束变量重命名）的形式化定义。避免捕获的规则明确规定：“每当替换会将替换项中的一个自由变量置于一个约束同名变量的量词之下时，必须首先对该约束变量进行系统性重命名，将其改为一个对于替换项而言是‘新鲜’的变量。”\n\n### 步骤 2：使用提取的已知条件进行验证\n-   **科学基础**：该问题是数理逻辑中的一个标准练习，具体来说是一阶谓词逻辑。自由/约束变量、替换和变量捕获等概念是 FOL 句法和语义的基础。该问题在科学上是合理的。\n-   **适定性**：公式 $\\varphi(x)$ 在句法上是良构的，即使嵌套的量词约束了同一个变量名 $y$。在形式逻辑中，内层量词 $\\exists y$ 的作用域嵌套在外层量词 $\\forall y$ 的作用域内，绑定关系由最内层的适用量词决定。任务是根据指定规则执行一个特定的、定义明确的操作（$\\varphi(x)[x := y]$）。在 $\\alpha$-等价的意义下，存在唯一的结果。该问题是适定的。\n-   **客观性**：该问题以逻辑和数学的形式化语言陈述，没有任何主观或模棱两可的术语。\n\n### 步骤 3：结论和行动\n问题陈述是有效的。这是一个在成熟的形式系统中适定的标准问题。我将继续进行推导和求解。\n\n### 正确替换的推导\n\n任务是计算 $\\varphi(x)[x := y]$，其中被替换的项是 $t=y$，公式是：\n$$\n\\varphi(x) \\;=\\; \\forall y \\,\\Big( R(x,y) \\;\\rightarrow\\; \\exists y \\,\\big( P(y) \\,\\land\\, R(y,x) \\big) \\Big)\n$$\n\n首先，我们确定公式 $\\varphi(x)$ 和项 $t=y$ 中的自由变量。\n-   在 $\\varphi(x)$ 中，变量 $x$ 出现了两次，两次都是自由的，因为它们不在约束 $x$ 的量词的作用域内。变量 $y$ 的所有出现都被外层的 $\\forall y$ 或内层的 $\\exists y$ 所约束。因此，$\\varphi(x)$ 的自由变量集合是 $FV(\\varphi(x)) = \\{x\\}$。\n-   要被替换的项是 $t = y$。这个项中的自由变量集合是 $FV(t) = \\{y\\}$。\n\n替换 $\\psi[v := t]$ 是递归定义的。对于形式为 $\\forall u \\, \\chi$ 或 $\\exists u \\, \\chi$ 的量化公式，如果 $v \\neq u$ 且 $u \\in FV(t)$，替换 $(\\forall u \\, \\chi)[v := t]$ 将导致变量捕获。在这种情况下，约束变量 $u$ 必须首先被重命名为一个不在 $FV(\\chi) \\cup FV(t)$ 中的新鲜变量 $u'$。\n\n我们现在将逐步执行替换 $\\varphi(x)[x := y]$。\n\n1.  **外层量词 $\\forall y$**：该公式的形式是 $(\\forall y \\, \\psi)[x := y]$，其中 $\\psi$ 是 $\\Big( R(x,y) \\;\\rightarrow\\; \\exists y \\,\\big( P(y) \\,\\land\\, R(y,x) \\big) \\Big)$。被替换的变量是 $x$，约束变量是 $y$。项是 $t=y$。由于约束变量 $y$ 在项 $t=y$ 中是自由变量（即 $y \\in FV(y)$），直接替换将导致项的变量 $y$ 被量词 $\\forall y$ 捕获。\n    为了避免这种捕获，我们必须将外层量词中的约束变量 $y$ 重命名为一个新鲜变量。可用的变量被指定为 $x, y, z, w$。如果一个变量不引入新的冲突，它就是新鲜的。我们选择变量 $z$。变量 $z$ 不在 $FV(\\varphi(x)) = \\{x\\}$ 中，也不在 $FV(y) = \\{y\\}$ 中。因此，我们对 $\\varphi(x)$ 进行 $\\alpha$-变换，将外层的约束变量 $y$ 重命名为 $z$：\n    $$\n    \\varphi(x) \\equiv_\\alpha \\varphi'(x) = \\forall z \\,\\Big( \\big( R(x,y) \\;\\rightarrow\\; \\exists y \\,\\dots \\big)[y := z] \\Big)\n    $$\n    替换 $[y := z]$ 仅适用于外层 $\\forall y$ 作用域内 $y$ 的自由出现。在子公式 $\\Big( R(x,y) \\;\\rightarrow\\; \\exists y \\,\\dots \\Big)$ 中，$R(x,y)$ 中的 $y$ 是自由的，但 $\\exists y \\,\\dots$ 中的 $y$ 被内层量词约束，因此不受影响。重命名的结果是：\n    $$\n    \\varphi'(x) = \\forall z \\,\\Big( R(x,z) \\;\\rightarrow\\; \\exists y \\,\\big( P(y) \\,\\land\\, R(y,x) \\big) \\Big)\n    $$\n\n2.  **对重命名后的公式进行替换**：我们现在计算 $\\varphi'(x)[x := y]$。由于新的约束变量 $z$ 不在 $FV(y) = \\{y\\}$ 中，我们可以将替换推入量词内部：\n    $$\n    \\varphi'(x)[x := y] = \\forall z \\,\\left( \\Big( R(x,z) \\;\\rightarrow\\; \\exists y \\,\\big( P(y) \\,\\land\\, R(y,x) \\big) \\Big)[x := y] \\right)\n    $$\n    替换在蕴含符号 $\\rightarrow$ 上是分配的：\n    $$\n    = \\forall z \\,\\left( R(x,z)[x := y] \\;\\rightarrow\\; \\Big(\\exists y \\,\\big( P(y) \\,\\land\\, R(y,x) \\big)\\Big)[x := y] \\right)\n    $$\n    第一部分很简单：$R(x,z)[x := y] = R(y,z)$。\n\n3.  **内层量词 $\\exists y$**：我们现在关注第二部分：$\\Big(\\exists y \\,\\big( P(y) \\,\\land\\, R(y,x) \\big)\\Big)[x := y]$。这又是一次对量化公式的替换。被替换的变量是 $x$，约束变量是 $y$，项是 $t=y$。由于约束变量 $y$ 在 $FV(t) = \\{y\\}$ 中，这是另一个变量捕获的例子。\n    为了避免捕获，我们必须将内层的约束变量 $y$ 重命名为在此上下文中是新鲜的变量。上下文是替换 $\\big(\\exists y \\, \\chi\\big)[x := y]$，其中 $\\chi = P(y) \\land R(y,x)$。一个新鲜变量不能在 $FV(\\chi) = \\{x\\}$ 或 $FV(t) = \\{y\\}$ 中。所以，新变量不能是 $x$ 或 $y$。我们选择变量 $w$（可用且满足此条件）。我们对子公式进行 $\\alpha$-变换：\n    $$\n    \\exists y \\,\\big( P(y) \\,\\land\\, R(y,x) \\big) \\equiv_\\alpha \\exists w \\,\\Big(\\big( P(y) \\,\\land\\, R(y,x) \\big)[y := w] \\Big) = \\exists w \\,\\big( P(w) \\,\\land\\, R(w,x) \\big)\n    $$\n    现在，我们可以安全地对这个重命名后的子公式执行替换 $[x := y]$：\n    $$\n    \\Big(\\exists w \\,\\big( P(w) \\,\\land\\, R(w,x) \\big)\\Big)[x := y] = \\exists w \\,\\Big(\\big( P(w) \\,\\land\\, R(w,x) \\big)[x := y]\\Big)\n    $$\n    这可以简化为：\n    $$\n    = \\exists w \\,\\big( P(w) \\,\\land\\, R(w,y) \\big)\n    $$\n\n4.  **最终组合**：结合步骤 2 和 3 的结果，我们得到最终的公式：\n    $$\n    \\forall z \\,\\Big( R(y,z) \\;\\rightarrow\\; \\exists w \\,\\big( P(w) \\,\\land\\, R(w,y) \\big) \\Big)\n    $$\n    这个公式对应于选项 D。\n\n问题要求的是在 $\\alpha$-等价意义下的所有正确结果。我们来分析一下其他新鲜变量的选择是否会导致其他选项。在重命名内层约束变量 $y$ 时，我们选择了 $w$。如果我们选择了 $z$ 会怎样？变量 $z$ 不在 $FV(\\chi) \\cup FV(t) = \\{x, y\\}$ 中，所以它也是一个有效的新鲜变量选择。将内层的 $y$ 重命名为 $z$ 得到 $\\exists z \\big( P(z) \\land R(z,x) \\big)$。然后进行替换 $[x:=y]$ 得到 $\\exists z \\big( P(z) \\land R(z,y) \\big)$。\n将其放回主公式（从步骤 2 得来）中，结果是：\n$$\n\\forall z \\,\\Big( R(y,z) \\;\\rightarrow\\; \\exists z \\,\\big( P(z) \\,\\land\\, R(z,y) \\big) \\Big)\n$$\n这个公式对应于选项 E。尽管重用约束变量名 $z$ 可能会令人困惑，但这在句法上是有效的，并且是替换过程的一个正确结果。内层量词 $\\exists z$“遮蔽”了外层量词 $\\forall z$，因此它们约束的是 $z$ 的不同出现。\n\n最后，我们必须检查选项 D 和 E 是否是 $\\alpha$-等价的。\n令 $F_D = \\forall z \\,\\Big( R(y,z) \\;\\rightarrow\\; \\exists w \\,\\big( P(w) \\,\\land\\, R(w,y) \\big) \\Big)$。\n令 $F_E = \\forall z \\,\\Big( R(y,z) \\;\\rightarrow\\; \\exists z \\,\\big( P(z) \\,\\land\\, R(z,y) \\big) \\Big)$。\n这两个公式仅在存在量词中的约束变量的名称上有所不同。$F_E$ 中的子公式 $\\exists z \\,\\big( P(z) \\,\\land\\, R(z,y) \\big)$ 可以通过将 $F_D$ 中的 $\\exists w \\,\\big( P(w) \\,\\land\\, R(w,y) \\big)$ 的约束变量 $w$ 重命名为 $z$ 来获得。这是一个有效的 $\\alpha$-变换，因为 $z$ 在存在量词的作用域 $P(w) \\land R(w,y)$ 中不是自由变量，该作用域中唯一的自由变量是 $y$。因此，$F_D \\equiv_\\alpha F_E$。\n由于 D 和 E 都是替换过程的有效结果（取决于新鲜变量名的选择），并且它们彼此是 $\\alpha$-等价的，所以它们都是正确答案。\n\n### 逐项分析\n\n*   **A. $\\forall y \\,\\Big( R(y,y) \\;\\rightarrow\\; \\exists y \\,\\big( P(y) \\,\\land\\, R(y,y) \\big) \\Big)$**\n    这个公式是对 $x$ 的每个自由出现进行简单的 $y$ 替换，而没有重命名任何约束变量的结果。在 $R(x,y)$ 中替换 $x$ 的 $y$ 被外层的 $\\forall y$ 捕获。在 $R(y,x)$ 中替换 $x$ 的 $y$ 被内层的 $\\exists y$ 捕获。这违反了避免捕获的替换的定义。\n    **结论：错误。**\n\n*   **B. $\\forall z \\,\\Big( R(y,z) \\;\\rightarrow\\; \\exists y \\,\\big( P(y) \\,\\land\\, R(y,y) \\big) \\Big)$**\n    这个公式正确地将外层约束变量 $y$ 重命名为 $z$，避免了在蕴含式第一部分的捕获，得到 $R(y,z)$。但是，它没有重命名内层约束变量 $y$。在子公式 $\\exists y \\, (P(y) \\land R(y,x))$ 中对 $x$ 进行 $y$ 的替换，简单地产生了 $\\exists y \\, (P(y) \\land R(y,y))$，其中新的 $y$ 被存在量词捕获。这是对替换规则的错误应用。\n    **结论：错误。**\n\n*   **C. $\\forall y \\,\\Big( R(y,y) \\;\\rightarrow\\; \\exists w \\,\\big( P(w) \\,\\land\\, R(w,y) \\big) \\Big)$**\n    这个公式在替换前正确地将内层约束变量 $y$ 重命名为 $w$，得到了正确的后件 $\\exists w \\, (P(w) \\land R(w,y))$。但是，它没有重命名外层约束变量 $y$。在 $R(x,y)$ 中对 $x$ 进行 $y$ 的替换导致了 $R(y,y)$，其中新的 $y$ 被全称量词捕获。这违反了替换规则。\n    **结论：错误。**\n\n*   **D. $\\forall z \\,\\Big( R(y,z) \\;\\rightarrow\\; \\exists w \\,\\big( P(w) \\,\\land\\, R(w,y) \\big) \\Big)$**\n    这个公式是正确应用避免捕获的替换的结果。外层约束变量 $y$ 被重命名为 $z$。内层约束变量 $y$ 被重命名为 $w$。两个重命名对于防止变量捕获都是必需的。如推导所示，这是一个正确的结果。\n    **结论：正确。**\n\n*   **E. $\\forall z \\,\\Big( R(y,z) \\;\\rightarrow\\; \\exists z \\,\\big( P(z) \\,\\land\\, R(z,y) \\big) \\Big)$**\n    这个公式是正确应用避免捕获的替换的另一个可能结果。外层约束变量 $y$ 被重命名为 $z$。内层约束变量 $y$ 也被重命名为 $z$。在内层替换的局部上下文中，这是一个有效的新鲜变量选择，因为它不是所涉及的自由变量 $\\{x, y\\}$ 之一。得到的公式虽然由于嵌套量词使用相同的变量名而可能令人困惑，但在形式上是正确的。此外，它与选项 D 中的公式是 $\\alpha$-等价的。\n    **结论：正确。**", "answer": "$$\\boxed{DE}$$", "id": "2972882"}]}