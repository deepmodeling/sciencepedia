{"hands_on_practices": [{"introduction": "塔斯基真理定义的核心在于其递归结构，尤其是对量化公式的处理。变量赋值 (variable assignment) $s$ 及其更新操作 $s[x\\mapsto a]$ 是这一递归机制的基石，它使我们能够精确地刻画量词（如“对于所有 $x$”）的语义。本练习旨在检验你对变量赋值及其代数性质的掌握程度，例如赋值更新的顺序无关性，以及一个公式的真值仅依赖于其自由变量的赋值这一关键性质（符合引理）。[@problem_id:2983816]", "problem": "考虑一阶逻辑 (FOL) 的一个语言 $L$，一个带有论域 $M$ 和解释函数的 $L$-结构 $\\mathcal{M}$，以及一个变量赋值 $s\\colon \\mathrm{Var}\\to M$。Tarski 满足关系 $\\mathcal{M}\\models \\varphi[s]$ 由结构 $\\mathcal{M}$ 和赋值 $s$ 决定，项的求值记作 $\\llbracket t\\rrbracket^{\\mathcal{M}}_{s}$。选择所有正确描述了赋值 $s$ 在 Tarski 语义学中的作用，并正确地形式化了更新符号 $s[x\\mapsto a]$ 及其代数性质的陈述。\n\nA. 对于任意 $s\\colon \\mathrm{Var}\\to M$ 和 $a\\in M$，更新 $s[x\\mapsto a]$ 是一个赋值 $t\\colon \\mathrm{Var}\\to M$，定义为 $t(x)=a$ 且对于所有 $y\\neq x$ 有 $t(y)=s(y)$。\n\nB. 对于任意 $x,y\\in \\mathrm{Var}$ 且 $x\\neq y$，以及任意 $a,b\\in M$，更新是可交换的：$s[x\\mapsto a][y\\mapsto b]=s[y\\mapsto b][x\\mapsto a]$。\n\nC. 对于任意公式 $\\varphi$，修改 $s$ 在 $\\varphi$ 中被约束的变量 $x$ 上的值，可以改变 $\\mathcal{M}\\models \\varphi[s]$ 的真值。\n\nD. 如果两个赋值 $s,s'\\colon \\mathrm{Var}\\to M$ 在公式 $\\varphi$ 的所有自由变量上一致，那么 $\\mathcal{M}\\models \\varphi[s]$ 当且仅当 $\\mathcal{M}\\models \\varphi[s']$。\n\nE. 对于任意项 $t$，如果 $x$ 不是 $t$ 中的变量，那么对于所有的 $a\\in M$，都有 $\\llbracket t\\rrbracket^{\\mathcal{M}}_{s}=\\llbracket t\\rrbracket^{\\mathcal{M}}_{s[x\\mapsto a]}$。\n\nF. 对于任意公式 $\\varphi$ 和任意 $a\\in M$，我们有 $\\mathcal{M}\\models \\forall x\\,\\varphi[s]$ 当且仅当存在 $a\\in M$ 使得 $\\mathcal{M}\\models \\varphi[s[x\\mapsto a]]$。", "solution": "该问题陈述是一阶逻辑中的一个标准练习，具体涉及 Tarski 的真理（或满足）定义。所提出的概念——一阶语言 $L$、$L$-结构 $\\mathcal{M}$、论域 $M$、变量赋值 $s$、满足关系 $\\mathcal{M}\\models \\varphi[s]$、项的求值 $\\llbracket t\\rrbracket^{\\mathcal{M}}_{s}$ 和赋值更新 $s[x\\mapsto a]$——都是标准的且定义明确的。这个问题是对这些概念的形式属性的一个适定探究。\n\n因此，该问题陈述是有效的。我们将逐一分析每个选项。\n\nTarski 语义学的核心依赖于满足的递归定义。一个变量赋值 $s\\colon \\mathrm{Var}\\to M$ 将所有变量的集合 $\\mathrm{Var}$ 中的每个变量映射到论域 $M$ 的一个元素。一个公式 $\\varphi$ 的真值是相对于一个结构 $\\mathcal{M}$ 和这样一个赋值 $s$ 来评估的。\n\n让我们来评估每个陈述。\n\n**A. 对于任意 $s\\colon \\mathrm{Var}\\to M$ 和 $a\\in M$，更新 $s[x\\mapsto a]$ 是一个赋值 $t\\colon \\mathrm{Var}\\to M$，定义为 $t(x)=a$ 且对于所有 $y\\neq x$ 有 $t(y)=s(y)$。**\n\n该陈述提供了符号 $s[x\\mapsto a]$ 的形式化定义。它代表一个新的赋值，我们称之为 $s'$，它是原始赋值 $s$ 的一个微小修改。新的赋值 $s'$ 将变量 $x$ 映射到特定的论域元素 $a$，而对于其他所有变量 $y$（其中 $y$ 是不同于 $x$ 的变量符号），它与原始赋值一致，即 $s'(y) = s(y)$。这是在量化公式的语义学中使用的、标准的、被普遍接受的赋值修改的定义。\n\n结论：**正确**。\n\n**B. 对于任意 $x,y\\in \\mathrm{Var}$ 且 $x\\neq y$，以及任意 $a,b\\in M$，更新是可交换的：$s[x\\mapsto a][y\\mapsto b]=s[y\\mapsto b][x\\mapsto a]$。**\n\n为了验证这一点，我们必须检查两个结果赋值是否是相同的函数。两个函数相等，当且仅当它们具有相同的定义域和上域，并且将定义域中的每个元素映射到上域中的相同元素。令 $s_1 = s[x\\mapsto a][y\\mapsto b]$ 和 $s_2 = s[y\\mapsto b][x\\mapsto a]$。我们需要证明对于任意变量 $z \\in \\mathrm{Var}$，都有 $s_1(z) = s_2(z)$。\n\n让我们考虑 $z$ 的几种可能情况：\n1.  情况 $z = x$：\n    - $s_1(x) = (s[x\\mapsto a][y\\mapsto b])(x)$。“外部”更新是关于 $y$ 的，由于 $x \\neq y$，在 $x$ 处的值由“内部”赋值 $s[x\\mapsto a]$ 决定。因此，$s_1(x) = (s[x\\mapsto a])(x) = a$。\n    - $s_2(x) = (s[y\\mapsto b][x\\mapsto a])(x)$。外部更新是关于 $x$ 的，根据定义它将 $x$ 映射到 $a$。因此，$s_2(x) = a$。\n    所以，$s_1(x) = s_2(x)$。\n\n2.  情况 $z = y$：\n    - $s_1(y) = (s[x\\mapsto a][y\\mapsto b])(y)$。外部更新是关于 $y$ 的，根据定义它将 $y$ 映射到 $b$。因此，$s_1(y) = b$。\n    - $s_2(y) = (s[y\\mapsto b][x\\mapsto a])(y)$。外部更新是关于 $x$ 的，由于 $y \\neq x$，在 $y$ 处的值由内部赋值 $s[y\\mapsto b]$ 决定。因此，$s_2(y) = (s[y\\mapsto b])(y) = b$。\n    所以，$s_1(y) = s_2(y)$。\n\n3.  情况 $z \\neq x$ 且 $z \\neq y$：\n    - $s_1(z) = (s[x\\mapsto a][y\\mapsto b])(z)$。外部更新不影响 $z$，所以其值为 $(s[x\\mapsto a])(z)$。内部更新也不影响 $z$，所以其值为 $s(z)$。\n    - $s_2(z) = (s[y\\mapsto b][x\\mapsto a])(z)$。外部更新不影响 $z$，所以其值为 $(s[y\\mapsto b])(z)$。内部更新也不影响 $z$，所以其值为 $s(z)$。\n    所以，$s_1(z) = s_2(z)$。\n\n由于 $s_1$ 和 $s_2$ 在所有变量上都一致，所以它们是同一个赋值。条件 $x \\neq y$ 是至关重要的，因为 $s[x\\mapsto a][x\\mapsto b]$ 会将 $x$ 映射到 $b$，而 $s[x\\mapsto b][x\\mapsto a]$ 会将 $x$ 映射到 $a$。\n\n结论：**正确**。\n\n**C. 对于任意公式 $\\varphi$，修改 $s$ 在 $\\varphi$ 中被约束的变量 $x$ 上的值，可以改变 $\\mathcal{M}\\models \\varphi[s]$ 的真值。**\n\n一个公式的真值仅取决于赋给其*自由*变量的值。约束变量是量化的占位符。例如，考虑公式 $\\varphi = \\forall x P(x)$。其满足条件是 $\\mathcal{M} \\models \\forall x P(x)[s]$ 当且仅当对于所有 $a \\in M$，我们有 $\\mathcal{M} \\models P(x)[s[x\\mapsto a]]$。原始值 $s(x)$ 在这个求值过程中不起任何作用；求值依赖于为来自论域的*所有*可能的 $x$ 值测试子公式 $P(x)$。因此，将 $s(x)$ 更改为某个其他值 $s'(x)$ 对 $\\mathcal{M} \\models \\forall x P(x)[s]$ 的真值没有影响。这个原则可以推广到所有量化公式和任何约束变量。该陈述主张的恰恰相反。\n\n结论：**不正确**。\n\n**D. 如果两个赋值 $s,s'\\colon \\mathrm{Var}\\to M$ 在公式 $\\varphi$ 的所有自由变量上一致，那么 $\\mathcal{M}\\models \\varphi[s]$ 当且仅当 $\\mathcal{M}\\models \\varphi[s']$。**\n\n这是模型论中的一个基本结果，通常称为**重合引理**（Coincidence Lemma）或**相关引理**（Relevance Lemma）。它形式化了这样一个直觉：一个公式的满足性仅取决于赋值对那些在该公式中实际自由出现的变量所做的事情。证明是对公式 $\\varphi$ 的复杂性进行直接的结构归纳。对于原子公式的基本情况是清楚的，因为它们的真值仅取决于其项的求值，而项的求值又仅取决于其中的变量（所有这些变量都是自由的）。对于逻辑联结词和量词的归纳步骤保持了这个性质。我们在对选项 C 的分析中简要勾勒了全称量词的证明。这个陈述是 Tarski 语义学的一个正确且核心的定理。\n\n结论：**正确**。\n\n**E. 对于任意项 $t$，如果 $x$ 不是 $t$ 中的变量，那么对于所有的 $a\\in M$，都有 $\\llbracket t\\rrbracket^{\\mathcal{M}}_{s}=\\llbracket t\\rrbracket^{\\mathcal{M}}_{s[x\\mapsto a]}$。**\n\n这是重合引理（选项 D）在项上的类似物。一个项的值 $\\llbracket t \\rrbracket^{\\mathcal{M}}_{s}$ 由常数和函数符号的解释以及由 $s$ 赋给出现在 $t$ 中的变量的值决定。如果变量 $x$ 没有出现在 $t$ 中，那么通过更新 $s[x\\mapsto a]$ 来改变 $s(x)$ 的值不会影响 $t$ 的求值。一个形式化的证明可以通过对项 $t$ 的结构进行归纳来进行。\n- 基本情况（$t$ 是一个常数 $c$）：$\\llbracket c\\rrbracket^{\\mathcal{M}}_{s} = c^{\\mathcal{M}} = \\llbracket c\\rrbracket^{\\mathcal{M}}_{s[x\\mapsto a]}$。\n- 基本情况（$t$ 是一个变量 $y$）：由于 $x$ 没有出现在 $t$ 中，所以 $y \\neq x$。那么 $\\llbracket y\\rrbracket^{\\mathcal{M}}_{s} = s(y)$ 且 $\\llbracket y\\rrbracket^{\\mathcal{M}}_{s[x\\mapsto a]} = (s[x\\mapsto a])(y) = s(y)$。它们是相等的。\n- 归纳步骤（$t$ 是 $f(t_1, \\ldots, t_k)$）：由于 $x$ 没有出现在 $t$ 中，它也不会出现在任何子项 $t_i$ 中。根据归纳假设，对于所有的 $i$，都有 $\\llbracket t_i\\rrbracket^{\\mathcal{M}}_{s} = \\llbracket t_i\\rrbracket^{\\mathcal{M}}_{s[x\\mapsto a]}$。那么 $\\llbracket t\\rrbracket^{\\mathcal{M}}_{s} = f^{\\mathcal{M}}(\\llbracket t_1\\rrbracket^{\\mathcal{M}}_{s}, \\ldots, \\llbracket t_k\\rrbracket^{\\mathcal{M}}_{s}) = f^{\\mathcal{M}}(\\llbracket t_1\\rrbracket^{\\mathcal{M}}_{s[x\\mapsto a]}, \\ldots, \\llbracket t_k\\rrbracket^{\\mathcal{M}}_{s[x\\mapsto a]}) = \\llbracket t\\rrbracket^{\\mathcal{M}}_{s[x\\mapsto a]}$。\n\n该陈述是正确的。\n\n结论：**正确**。\n\n**F. 对于任意公式 $\\varphi$ 和任意 $a\\in M$，我们有 $\\mathcal{M}\\models \\forall x\\,\\varphi[s]$ 当且仅当存在 $a\\in M$ 使得 $\\mathcal{M}\\models \\varphi[s[x\\mapsto a]]$。**\n\n该陈述从根本上歪曲了全称量词的语义。全称量化公式的 Tarski 满足定义是：\n$\\mathcal{M}\\models \\forall x\\,\\varphi[s]$ 当且仅当对于**所有**元素 $b\\in M$，都有 $\\mathcal{M}\\models \\varphi[s[x\\mapsto b]]$。\n\n给出的陈述是：\n$\\mathcal{M}\\models \\forall x\\,\\varphi[s]$ 当且仅当**存在**一个元素 $a\\in M$ 使得 $\\mathcal{M}\\models \\varphi[s[x\\mapsto a]]$。\n\n陈述中等价关系的右侧是*存在量词*的定义：$\\mathcal{M}\\models \\exists x\\,\\varphi[s]$。该陈述错误地将“对于所有”的含义等同于“存在”。这两种情况仅在论域 $M$ 只包含一个元素的微不足道且无趣的情况下是等价的（假设它非空）。在一般情况下，这是错误的。例如，在整数中，“对于所有 $x$，$x0$”是假的，但“存在 $x$ 使得 $x0$”是真的。命题开头多余的“和任意 $a \\in M$”是不规范的，增加了混淆，但并不能挽救其核心的逻辑错误。\n\n结论：**不正确**。\n\n正确陈述的总结：A, B, D, E。", "answer": "$$\\boxed{ABDE}$$", "id": "2983816"}, {"introduction": "在掌握了满足关系的技术细节之后，我们来探讨塔斯基真理理论的哲学核心——“T-约定”（Convention T）。这个约定要求任何一个令人满意的真理定义，都必须能够推导出形如“句子 $S$ 为真，当且仅当 $p$”的命题，其中 $p$ 是对 $S$ 所断言事态的元语言翻译。本练习要求你为一个具体的算术语句实例化 T-约定，这将考验你对“使用”与“提及”之间关键区别的理解，以及如何将对象语言中的断言精确地转换成关于特定数学结构的元语言陈述。[@problem_id:2983809]", "problem": "固定一个一阶语言 $L$，它包含等号 $=$、一个常数符号 $0$ 和一个二元函数符号 $+$。设 $\\mathcal{N}$ 是一个标准 $L$-结构，其论域为 $\\mathbb{N}$，它将常数符号 $0$ 解释为数 $0 \\in \\mathbb{N}$，并将函数符号 $+$ 解释为 $\\mathbb{N}$ 上的普通加法。考虑 $L$-语句 $\\forall x\\, (x+0=x)$。你的任务是为该语句实例化 T约定（塔斯基真理模式），方法是选择一个正确的元语言双条件句，该双条件句需仔细区分“使用”与“提及”，并在元语言中呈现对象语言语句关于结构 $\\mathcal{N}$ 所陈述的内容。\n\n对于给定结构中的给定语句，下列哪一项是 T 约定的正确实例？\n\nA. “$\\forall x\\,(x+0=x)$ 在 $\\mathcal{N}$ 中为真，当且仅当 $\\forall x\\,(x+0=x)$。”\n\nB. “‘$\\forall x\\,(x+0=x)$’ 在 $\\mathcal{N}$ 中为真，当且仅当对每一个 $n \\in \\mathbb{N}$，都有 $+^{\\mathcal{N}}(n,0^{\\mathcal{N}})=n$。”\n\nC. “‘$\\forall x\\,(x+0=x)$’ 在 $L$ 中为真，当且仅当对所有 $n \\in \\mathbb{N}$，都有 $n+0=n$。”\n\nD. “‘$\\forall x\\,(x+0=x)$’ 为真，当且仅当对所有赋值 $s$，都有 $\\mathcal{N} \\models x+0=x$。”\n\nE. “‘$\\forall x\\,(x+0=x)$’ 在 $\\mathcal{N}$ 中为真，当且仅当 $\\mathcal{N} \\models \\forall x\\,(x+0=x)$。”", "solution": "该问题陈述是数理逻辑中的一个有效练习。它问题适定，在模型论中有科学依据，并且所有术语和条件的规定都足够精确，足以确定一个唯一的正确答案。\n\n任务是为一个特定结构中的给定语句正确地实例化 Alfred Tarski 的 T 约定。T 约定，也称为实质适足性条件，要求对语言 $L$ 的任何令人满意的真理定义都必须能够为 $L$ 中的每个语句 $\\phi$ 推导出一个双条件陈述。这个双条件句的形式为：\n$$ \\text{\"}\\phi\\text{\" is true if and only if } P $$\n其中，左侧的“$\\phi$”是语句的*名称*（一个被提及的表达式），而右侧的 $P$ 是在元语言中被*使用*的语句本身，或者更确切地说，是 $\\phi$ 到元语言的一个*翻译*，该翻译描述了 $\\phi$ 所断定的事态。当真理是相对于一个结构（模型论真理）来定义时，该模式变为：\n$$ \\text{\"}\\phi\\text{\" is true in } \\mathcal{M} \\text{ if and only if } P_{\\mathcal{M}} $$\n其中 $\\mathcal{M}$ 是结构，而 $P_{\\mathcal{M}}$ 是描述 $\\phi$ 对 $\\mathcal{M}$ 的论域和解释所断言的条件的元语言陈述。\n\n让我们将此应用于给定的问题。\n对象语言是 $L$，包含符号 $=$、$0$ 和 $+$。\n语句是 $\\phi \\equiv \\forall x\\,(x+0=x)$。\n结构是 $\\mathcal{N}$，其论域为 $\\mathbb{N}$，其中常数符号 $0$ 被解释为数 $0 \\in \\mathbb{N}$（记作 $0^{\\mathcal{N}}$），函数符号 $+$ 被解释为 $\\mathbb{N}$ 上的标准加法（记作 $+^{\\mathcal{N}}$）。\n\nT-双条件句的左侧必须是一个陈述语句 $\\phi$ 相对于结构 $\\mathcal{N}$ 为真的断言。这必须正确地使用引号来*提及*该语句。其正确形式为：\n`‘$\\forall x\\,(x+0=x)$’ 在 $\\mathcal{N}$ 中为真 ...`\n\n右侧必须是 $\\phi$ 关于结构 $\\mathcal{N}$ 所断言内容的元语言翻译。我们通过递归地应用塔斯基真理定义来推导它：\n1. 该语句的形式为 $\\forall x \\, \\psi(x)$，其中 $\\psi(x)$ 是公式 $x+0=x$。全称量词的真理定义指出，$\\mathcal{N} \\models \\forall x \\, \\psi(x)$ 当且仅当对于 $\\mathcal{N}$ 论域中的每个元素 $d$，当变量 $x$ 被赋值为 $d$ 时，公式 $\\psi(x)$ 都被满足。$\\mathcal{N}$ 的论域是 $\\mathbb{N}$。因此，这可翻译为：“对每一个 $n \\in \\mathbb{N}$，对应于 $x+0=x$ 的条件对 $n$ 成立。”\n\n2. 现在我们为元素 $n \\in \\mathbb{N}$ 翻译原子公式 $x+0=x$。该公式是两个项 $t_1 \\equiv x+0$ 和 $t_2 \\equiv x$ 之间的等式。如果这两个项的解释相等，则该公式被满足。\n    - 项 $t_1 \\equiv x+0$ 的解释涉及将函数符号 $+$ 的解释（即函数 $+^{\\mathcal{N}}$）应用于变量 $x$ 和常数符号 $0$ 的解释。对于元素 $n \\in \\mathbb{N}$，变量 $x$ 的求值为 $n$，常数符号 $0$ 的求值为它的解释 $0^{\\mathcal{N}}$。因此，项 $x+0$ 的求值为 $+^{\\mathcal{N}}(n, 0^{\\mathcal{N}})$。\n    - 项 $t_2 \\equiv x$ 的解释就是赋给变量 $x$ 的元素 $n$。\n    - 因此，$x+0=x$ 对 $n$ 成立的条件，可翻译为元语言等式：$+^{\\mathcal{N}}(n, 0^{\\mathcal{N}}) = n$。\n\n3. 结合这些步骤，完整的元语言翻译 $P_{\\mathcal{N}}$ 为：“对每一个 $n \\in \\mathbb{N}$，都有 $+^{\\mathcal{N}}(n, 0^{\\mathcal{N}}) = n$。”\n\n将两侧放在一起，正确的T-双条件句是：\n`‘$\\forall x\\,(x+0=x)$’ 在 $\\mathcal{N}$ 中为真，当且仅当对每一个 $n \\in \\mathbb{N}$，都有 $+^{\\mathcal{N}}(n,0^{\\mathcal{N}})=n$。`\n\n现在我们来评估给出的选项。\n\n**A. “$\\forall x\\,(x+0=x)$ 在 $\\mathcal{N}$ 中为真，当且仅当 $\\forall x\\,(x+0=x)$。”**\n该选项存在致命的使用-提及混淆。左侧的短语 `$\\forall x\\,(x+0=x)$` 被用作主语，但没有放在引号中，因此未能正确地命名该语句。更根本的是，右侧只是重复了对象语言的语句。T约定要求的是翻译成描述模型论域中条件的元语言，而不是重复对象语言的语法。这个双条件句没有提供任何信息。\n**结论：错误。**\n\n**B. “‘$\\forall x\\,(x+0=x)$’ 在 $\\mathcal{N}$ 中为真，当且仅当对每一个 $n \\in \\mathbb{N}$，都有 $+^{\\mathcal{N}}(n,0^{\\mathcal{N}})=n$。”**\n该选项与我们的推导完全匹配。\n- 左侧正确地提及了语句 `‘$\\forall x\\,(x+0=x)$’` 并断定其在结构 $\\mathcal{N}$ 中为真。\n- 右侧提供了该语句含义的精确元语言翻译，描述了论域 $\\mathbb{N}$ 中元素的性质以及符号 $+^{\\mathcal{N}}$ 和 $0^{\\mathcal{N}}$ 的解释。它正确地展开了全称量词和项的解释。\n**结论：正确。**\n\n**C. “‘$\\forall x\\,(x+0=x)$’ 在 $L$ 中为真，当且仅当对所有 $n \\in \\mathbb{N}$，都有 $n+0=n$。”**\n该选项在左侧包含一个关键错误。真值是为某个语句*在某个结构*（或解释）$\\mathcal{N}$ 中定义的，而不是为语言 $L$ 定义的。一个语句在一个结构中可以为真，在另一个结构中可以为假。“在 $L$ 中为真”这个短语在语法上是错误的，在模型论中概念上是无意义的。虽然右侧是一个正确但略嫌不正式的元语言翻译，但左侧的错误使整个陈述无效。\n**结论：错误。**\n\n**D. “‘$\\forall x\\,(x+0=x)$’ 为真，当且仅当对所有赋值 $s$，都有 $\\mathcal{N} \\models x+0=x$。”**\n该选项因多个原因而存在缺陷。首先，左侧不完整，省略了“在 $\\mathcal{N}$ 中”。其次，也是更重要的一点，右侧没有提供所要求的、关于论域对象的陈述翻译。相反，它通过使用满足关系 `$\\models$`，用语义学术语来表述条件。这是循环的。陈述 `$\\mathcal{N} \\models \\forall x \\psi(x)` 本身是根据对所有赋值（或者更准确地说，对所有代入 $x$ 的论域元素）的满足来*定义*的。T约定要求从右侧消除像 `$\\models$` 这样的语义谓词，并用论域中的实际条件取而代之。\n**结论：错误。**\n\n**E. “‘$\\forall x\\,(x+0=x)$’ 在 $\\mathcal{N}$ 中为真，当且仅当 $\\mathcal{N} \\models \\forall x\\,(x+0=x)$。”**\n这个陈述是一个重言式。英文短语“`‘\\phi’` is true in $\\mathcal{N}$”仅仅是形式化记法 `$\\mathcal{N} \\models \\phi$` 的自然语言读法。因此，该选项断言一个陈述为真当且仅当它为真。这没有提供所要求的、将对象语言语句翻译成关于论域的非语义断言，因此不是 T 约定的正确实例化。\n**结论：错误。**", "answer": "$$\\boxed{B}$$", "id": "2983809"}, {"introduction": "在逻辑中，我们不仅需要在语义层面定义真值，还需要在句法层面进行推理，而代入（substitution）是连接这两个世界的关键桥梁。一个核心挑战是避免“变量捕获”——即一个被代入的项中的自由变量，被公式中原有的量词错误地约束，从而改变了公式的原意。本练习深入探讨了自由变量和约束变量的严格定义，阐明了朴素代入的陷阱，并介绍了避免捕获的代入（capture-avoiding substitution）的必要性，这是保证代入引理（Substitution Lemma）成立的基础。[@problem_id:2983801]", "problem": "在一阶逻辑 (FOL) 的设定中，设 $\\mathcal{L}$ 是一个一阶语言，包含变量、一个一元关系符号 $\\mathsf{P}$、一个二元关系符号 $\\mathsf{Q}$、一个常量符号 $\\mathsf{c}$ 以及一个二元函数符号 $\\mathsf{f}$。公式由原子公式通过布尔联结词和量词构成。在 Tarski 的真值定义下，满足关系是相对于一个解释非逻辑符号的结构 $\\mathcal{M}$ 和一个变量赋值 $s$ 来给出的。\n\n选择所有正确且严格地刻画了避免捕获的代换、自由变量和约束变量，并解释了为何朴素代换会使得 Tarski 真值定义中的量词子句失效的陈述。\n\nA. 一个变量 $v$ 在公式中的一次出现是约束的，当且仅当它位于一个形如 $\\forall v$ 或 $\\exists v$ 的量词的辖域内，且该量词约束了它；否则它是自由的。自由变量的集合是归纳定义的：如果 $\\varphi$ 是原子公式，那么 $\\mathrm{Free}(\\varphi)$ 是出现在 $\\varphi$ 的项位置中的变量集合；对于布尔联结词，$\\mathrm{Free}(\\neg\\varphi)=\\mathrm{Free}(\\varphi)$ 且对于任意二元联结词 $\\star$，$\\mathrm{Free}(\\varphi\\star\\psi)=\\mathrm{Free}(\\varphi)\\cup\\mathrm{Free}(\\psi)$；对于量词，$\\mathrm{Free}(\\forall v\\,\\varphi)=\\mathrm{Free}(\\varphi)\\setminus\\{v\\}$ 且 $\\mathrm{Free}(\\exists v\\,\\varphi)=\\mathrm{Free}(\\varphi)\\setminus\\{v\\}$。\n\nB. 将公式 $\\varphi$ 中的变量 $x$ 替换为项 $t$ 的避免捕获的代换，记作 $\\varphi[t/x]$，其定义是：将 $\\varphi$ 中 $x$ 的每个自由出现都替换为 $t$，同时首先对 $\\varphi$ 中任何满足以下条件的约束变量 $y$ 进行 $\\alpha$-重命名：$y$ 的量词辖域覆盖了 $t$ 将被插入的位置，并且 $y$ 在 $t$ 中自由出现。这样做的目的是为了在代换后，$t$ 的自由变量不会被约束。\n\nC. 在 Tarski 语义下，朴素代换——即在 $\\varphi$ 中不进行任何重命名而统一地将 $x$ 进行文本替换为 $t$——在任何结构 $\\mathcal{M}$ 和赋值 $s$ 下都不会改变 $\\varphi$ 的真值，因为量化公式的真值仅取决于 $\\mathcal{M}$ 的论域和对约束变量的赋值。\n\nD. 设 $\\varphi(x)=\\forall y\\,(\\mathsf{P}(y)\\to\\mathsf{Q}(x,y))$ 且 $t=y$。那么朴素的文本替换产生 $\\varphi[y/x]=\\forall y\\,(\\mathsf{P}(y)\\to\\mathsf{Q}(y,y))$，并且，对于每个结构 $\\mathcal{M}$ 和赋值 $s$，$\\mathcal{M},s\\models\\varphi(x)$ 当且仅当 $\\mathcal{M},s\\models\\varphi[y/x]$；因此这两个公式是等价的。\n\nE. 避免捕获的代换的代换引理陈述如下：对于任意结构 $\\mathcal{M}$、赋值 $s$、公式 $\\varphi$、变量 $x$ 和项 $t$，如果 $\\varphi[t/x]$ 是通过避免捕获的代换形成的，那么 $\\mathcal{M},s\\models\\varphi[t/x]$ 当且仅当 $\\mathcal{M},s[x\\mapsto\\llbracket t\\rrbracket_{\\mathcal{M},s}]\\models\\varphi$。当 $t$ 中的自由变量因代换而被约束时，朴素代换会破坏此等价关系，从而破坏了量词子句的归纳证明。\n\nF. 为避免捕获，在用 $t$ 代换 $x$ 之前，仅重命名 $\\varphi$ 中 $x$ 的约束出现就足够了；$t$ 的自由变量无需考虑，因为 $\\varphi$ 中的量词不与通过代换引入的变量相互作用。\n\n选择所有正确的选项。", "solution": "首先验证问题陈述，以确保其科学和逻辑上的完整性。\n\n**步骤1：提取已知条件**\n- 逻辑系统：一阶逻辑 (FOL)。\n- 语言 $\\mathcal{L}$：\n    - 一组变量，包括 $v, x, y$。\n    - 一个一元关系符号 $\\mathsf{P}$。\n    - 一个二元关系符号 $\\mathsf{Q}$。\n    - 一个常量符号 $\\mathsf{c}$。\n    - 一个二元函数符号 $\\mathsf{f}$。\n- 语义：Tarski 的真值定义，其中满足关系 ($\\models$) 是相对于一个结构 $\\mathcal{M}$ 和一个变量赋值 $s$ 定义的。\n- 任务：选择所有正确刻画以下概念的陈述：\n    1. 避免捕获的代换。\n    2. 自由变量和约束变量。\n    3. 朴素代换相对于 Tarski 语义的失效性。\n\n**步骤2：使用提取的已知条件进行验证**\n- **科学依据：**该问题牢固地根植于数理逻辑，这是数学的一个核心学科。所提及的所有概念——一阶逻辑、Tarski 语义、自由变量和约束变量、代换——都是该领域的标准、明确定义和基础性的概念。所提供的语言 $\\mathcal{L}$ 是一个典型的例子。该问题没有违反任何数学原理。\n- **良构性：**该问题要求评估关于既定逻辑概念的几个命题。对于每个命题，可以根据一阶逻辑的标准理论得出正确或不正确的明确结论。存在一组唯一的正确选项。\n- **客观性：**问题的语言是精确的，并使用了逻辑学的标准技术术语（例如，“一元关系符号”、“变量赋值”、“避免捕获的代换”）。它没有歧义和主观内容。\n\n**步骤3：结论与行动**\n问题陈述是有效的。这是一个关于一阶逻辑基本概念的良构问题。接下来进行解答和选项分析。\n\n**选项分析**\n\n**选项 A：**该陈述定义了自由变量和约束变量，并给出了公式自由变量集合 $\\mathrm{Free}(\\varphi)$ 的归纳定义。\n- “一个变量 $v$ 在公式中的一次出现是约束的，当且仅当它位于一个形如 $\\forall v$ 或 $\\exists v$ 的量词的辖域内，且该量词约束了它；否则它是自由的”这个非形式化定义是一个正确的高层描述。\n- 归纳定义根据公式的结构进行分解：\n    - 对于原子公式 $\\varphi$，$\\mathrm{Free}(\\varphi)$ 被正确地确定为出现在其项中的变量集合。\n    - 对于布尔联结词，规则 $\\mathrm{Free}(\\neg\\varphi)=\\mathrm{Free}(\\varphi)$ 和 $\\mathrm{Free}(\\varphi\\star\\psi)=\\mathrm{Free}(\\varphi)\\cup\\mathrm{Free}(\\psi)$ 是正确的，因为联结词不约束变量。\n    - 对于量词，规则 $\\mathrm{Free}(\\forall v\\,\\varphi)=\\mathrm{Free}(\\varphi)\\setminus\\{v\\}$ 和 $\\mathrm{Free}(\\exists v\\,\\varphi)=\\mathrm{Free}(\\varphi)\\setminus\\{v\\}$ 是标准定义。量词约束变量 $v$，将其从自由变量集合中移除。\n整个陈述是对一阶逻辑中自由变量概念的正确和标准的表述。\n结论：**正确**。\n\n**选项 B：**该陈述定义了避免捕获的代换，记作 $\\varphi[t/x]$。\n- 它正确地陈述了该操作将公式 $\\varphi$ 中变量 $x$ 的每个自由出现替换为项 $t$。\n- 它正确地指出了需要避免的问题：“变量捕获”，即项 $t$ 中的一个自由变量被 $\\varphi$ 中的量词所约束。\n- 它正确地描述了标准解决方案：如果变量 $y$ 在 $t$ 中自由出现，且对 $x$ 的代换会将 $t$ 放入约束 $y$ 的量词辖域内，则首先对 $\\varphi$ 中的任何此类约束变量 $y$ 执行 $\\alpha$-重命名。\n这是对避免捕获的代换过程和目的的严格而准确的描述。\n结论：**正确**。\n\n**选项 C：**该陈述声称朴素（简单的文本替换）代换总是保持真值。\n- 该论断声称，朴素代换“在任何结构 $\\mathcal{M}$ 和赋值 $s$ 下都不会改变 $\\varphi$ 的真值”。这根本上是错误的。朴素代换所允许的变量捕获确实可以改变公式的真值和逻辑意义。\n- 所提供的理由，“因为量化公式的真值仅取决于 $\\mathcal{M}$ 的论域和对约束变量的赋值”，是一个不正确的过度简化。一个量化公式 $\\forall z \\psi$ 的真值取决于对于 $z$ 的所有赋值，$\\psi$ 是否被满足，而这又取决于对 $\\psi$ 中所有谓词、函数和其他自由变量的解释。\n- 一个反例就足以反驳这一点。设 $\\varphi(x)$ 为 $\\exists y (x \\neq y)$。在任何至少有两个元素的结构中，对于 $x$ 的任何赋值，该公式都为真。现在，设 $t=y$。朴素代换得到 $\\exists y (y \\neq y)$，这个公式恒为假。真值发生了改变。\n结论：**不正确**。\n\n**选项 D：**该选项给出了一个朴素代换的具体例子，并声称所得公式在逻辑上是等价的。\n- 公式是 $\\varphi(x)=\\forall y\\,(\\mathsf{P}(y)\\to\\mathsf{Q}(x,y))$，代换是将 $t=y$ 代入 $x$。\n- 朴素代换被正确地确定为 $\\forall y\\,(\\mathsf{P}(y)\\to\\mathsf{Q}(y,y))$。在此过程中，来自项 $t$ 的自由变量 $y$ 被量词 $\\forall y$ “捕获”。\n- 该论断声称 $\\forall y\\,(\\mathsf{P}(y)\\to\\mathsf{Q}(x,y))$ 与 $\\forall y\\,(\\mathsf{P}(y)\\to\\mathsf{Q}(y,y))$ 是逻辑等价的。\n- 这个论断是错误的。第一个公式有一个自由变量 $x$，所以其真值取决于对 $x$ 的赋值。第二个公式是一个句子（没有自由变量），所以其真值仅取决于结构 $\\mathcal{M}$。一个带有自由变量的公式不能与一个句子逻辑等价（除非两者都永真或都不可满足，但这里情况并非如此）。\n- 为了证明这一点，设 $\\mathcal{M}$ 是一个论域为 $D=\\{a,b\\}$ 的结构。设 $\\mathsf{P}^{\\mathcal{M}} = D$ 且 $\\mathsf{Q}^{\\mathcal{M}} = \\{(a,a), (a,b)\\}$。\n- 考虑一个赋值 $s$ 其中 $s(x) = a$。那么 $\\mathcal{M}, s \\models \\forall y\\,(\\mathsf{P}(y)\\to\\mathsf{Q}(x,y))$ 变为 $\\mathcal{M}, s \\models \\forall y\\,\\mathsf{Q}(a,y)$。这是真的，因为 $(a,a) \\in \\mathsf{Q}^{\\mathcal{M}}$ 且 $(a,b) \\in \\mathsf{Q}^{\\mathcal{M}}$。\n- 现在考虑代换后的公式 $\\forall y\\,(\\mathsf{P}(y)\\to\\mathsf{Q}(y,y))$。在此结构中，这变为 $\\forall y\\,\\mathsf{Q}(y,y)$。这是假的，因为对于 $y=b$，条件 $\\mathsf{Q}(b,b)$ 不满足（即 $(b,b) \\notin \\mathsf{Q}^{\\mathcal{M}}$）。\n- 由于我们找到了一个结构 $\\mathcal{M}$ 和一个赋值 $s$，其中两个公式具有不同的真值，因此它们在逻辑上不等价。\n结论：**不正确**。\n\n**选项 E：**该陈述提出了代换引理，并解释了为什么朴素代换可能导致其失效。\n- 第一部分是关于避免捕获的代换的代换引理的正确陈述：$\\mathcal{M},s\\models\\varphi[t/x]$ 当且仅当 $\\mathcal{M},s[x\\mapsto\\llbracket t\\rrbracket_{\\mathcal{M},s}]\\models\\varphi$。这个引理是代换这一句法操作的关键语义依据。它断言，在一个公式中用一个项代换一个变量，其语义效果等同于在变量被赋予该项值的环境中评估原始公式。\n- 第二部分解释了朴素代换的失败之处：“当 $t$ 中的自由变量因代换而被约束时，从而破坏了量词子句的归纳证明。”这是一个精确的诊断。代换引理的证明是通过对 $\\varphi$ 的结构进行归纳。对于量词（例如 $\\forall z \\psi$）的归纳步骤依赖于 $t$ 的自由变量不被 $\\forall z$ 捕获这一事实，这使得代换可以分配到量词内部。当捕获发生时，证明中的这一步就失败了，引理也就不成立了。\n结论：**正确**。\n\n**选项 F：**该陈述提出了一种错误的替代方法来避免捕获。\n- 它提出，仅“重命名 $\\varphi$ 中 $x$ 的约束出现”就足够了。这是荒谬的。根据定义，代换仅适用于 $x$ 的*自由*出现。像 $\\forall x \\psi$ 这样的子公式中 $x$ 的约束出现不受代换 $\\varphi[t/x]$ 的影响。\n- 变量捕获的关键问题不在于被替换的变量（$x$），而在于被插入的项（$t$）中的变量。该陈述声称“$t$ 的自由变量无需考虑”，这与事实完全相反。正是 $t$ 中的自由变量有被 $\\varphi$ 中量词捕获的危险。避免捕获的程序涉及到重命名 $\\varphi$ 中与 $t$ 中自由变量冲突的约束变量。\n结论：**不正确**。\n\n**结论总结**\n- 选项 A：正确。\n- 选项 B：正确。\n- 选项 C：不正确。\n- 选项 D：不正确。\n- 选项 E：正确。\n- 选项 F：不正确。\n\n正确的选项是 A、B 和 E。", "answer": "$$\\boxed{ABE}$$", "id": "2983801"}]}