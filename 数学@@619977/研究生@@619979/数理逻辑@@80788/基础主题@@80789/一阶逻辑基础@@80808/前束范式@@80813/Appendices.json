{"hands_on_practices": [{"introduction": "此练习聚焦于前束范式（PNF）转换的基本第一步：消除蕴含（implication）。通过正确应用逻辑等价式 $A \\rightarrow B \\equiv \\neg A \\lor B$，您将观察到公式结构如何演变，为后续量词前移的操作奠定基础。这个基础步骤对于处理那些将量词“困在”复杂逻辑连接词内部的公式至关重要。[@problem_id:1464836]", "problem": "在计算复杂性理论中，量化布尔公式 (Quantified Boolean Formula, QBF) 是一种命题逻辑公式，其中的变量可以被量化。如果一个 QBF 的形式为 $Q_1 x_1 Q_2 x_2 \\dots Q_n x_n \\phi$，那么它就处于前束范式 (Prenex Normal Form, PNF)。其中，每个 $Q_i$ 是全称量词 ($\\forall$) 或存在量词 ($\\exists$)，$x_i$ 是不同的布尔变量，而 $\\phi$ 是一个无量词的布尔公式。\n\n任何 QBF 都可以被转换成一个等价的前束范式公式。考虑以下 QBF：\n$$ \\psi = (\\forall x_1: (x_1 \\land \\neg x_2)) \\rightarrow (\\exists x_3: (x_3 \\lor x_1)) $$\n将其转换为 PNF 的过程涉及一系列步骤，通过应用逻辑等价关系将所有量词移到公式的最前端。第一步通常是消除阻碍量词移动的逻辑连接词，比如蕴含 ($\\rightarrow$)。\n\n下列哪个公式与 $\\psi$ 逻辑等价，并且是应用相应规则消除蕴含连接词后的直接结果？\n\nA. $\\forall x_1 \\exists x_3: ((x_1 \\land \\neg x_2) \\rightarrow (x_3 \\lor x_1))$\n\nB. $(\\exists x_1: \\neg(x_1 \\land \\neg x_2)) \\lor (\\exists x_3: (x_3 \\lor x_1))$\n\nC. $\\neg(\\forall x_1: (x_1 \\land \\neg x_2)) \\lor (\\exists x_3: (x_3 \\lor x_1))$\n\nD. $(\\forall x_1: \\neg(x_1 \\land \\neg x_2)) \\land (\\exists x_3: (x_3 \\lor x_1))$", "solution": "我们使用标准的命题等价式来消除蕴含：对于任意公式 $A$ 和 $B$，等价关系 $A \\rightarrow B \\equiv \\neg A \\lor B$ 恒成立。\n\n将 $\\psi$ 中的前件和后件确定为：\n$$\nA = (\\forall x_{1} : (x_{1} \\land \\neg x_{2})), \\quad B = (\\exists x_{3} : (x_{3} \\lor x_{1})).\n$$\n应用该等价关系可得：\n$$\n\\psi \\equiv \\neg(\\forall x_{1} : (x_{1} \\land \\neg x_{2})) \\lor (\\exists x_{3} : (x_{3} \\lor x_{1})).\n$$\n这与选项 C 完全匹配。选项 A 保留了蕴含。选项 B 错误地更改了量词和结构。选项 D 用合取替代了蕴含，这不是正确的等价关系。", "answer": "$$\\boxed{C}$$", "id": "1464836"}, {"introduction": "当同一变量在公式的不同部分被量化时，直接移动量词可能会导致“变量捕获”（variable capture），从而根本性地改变公式的语义。本题旨在强调变量标准化（即重命名）的必要性，这是在应用量词分配律之前不可或缺的关键步骤，确保了转换过程的逻辑保真性。[@problem_id:1467507]", "problem": "在计算复杂性理论中，真量化布尔公式（True Quantified Boolean Formula, TQBF）是量化布尔逻辑中的一个公式，它被要求是前束范式。一个公式是前束范式，如果它的形式为 $\\mathcal{Q}_1 v_1 \\mathcal{Q}_2 v_2 \\dots \\mathcal{Q}_n v_n \\psi$，其中每个 $\\mathcal{Q}_i$ 是一个全称量词 ($\\forall$) 或存在量词 ($\\exists$)，$v_i$ 是不同的布尔变量，而 $\\psi$ 是一个涉及变量 $v_1, \\dots, v_n$ 以及可能包含其他自由变量的无量词布尔公式。\n\n考虑以下量化布尔公式 $\\Phi$，其中 $x, y,$ 和 $z$ 是布尔变量：\n$$ \\Phi = (\\forall x (x \\lor y)) \\lor (\\exists x (\\neg x \\land z)) $$\n下列哪个前束范式公式在逻辑上等价于 $\\Phi$？注意，变量 $a$ 和 $b$ 是为了重命名的目的而引入的新的、不同的布尔变量。\n\nA. $\\forall x \\exists x (((x \\lor y) \\lor (\\neg x \\land z)))$\n\nB. $\\forall a \\exists b (((a \\lor y) \\land (\\neg b \\land z)))$\n\nC. $\\exists b \\forall a (((a \\lor y) \\lor (\\neg b \\land z)))$\n\nD. $\\forall a \\forall b (((a \\lor y) \\lor (\\neg b \\land z)))$\n\nE. $\\exists a \\exists b (((a \\lor y) \\lor (\\neg b \\land z)))$", "solution": "我们从给定的公式开始\n$$\\Phi = (\\forall x\\,(x \\lor y)) \\lor (\\exists x\\,(\\neg x \\land z)).$$\n首先，进行$\\alpha$-变换以确保不同作用域中的约束变量是不同的。将左侧析取项中的约束变量重命名为 $a$，右侧析取项中的约束变量重命名为 $b$：\n$$\\Phi \\equiv (\\forall a\\,(a \\lor y)) \\lor (\\exists b\\,(\\neg b \\land z)).$$\n使用针对带有存在量词的析取的前束变换标准规则：如果 $b$ 在 $\\alpha$ 中不是自由变量，那么 $\\alpha \\lor (\\exists b\\,\\gamma) \\equiv \\exists b\\,(\\alpha \\lor \\gamma)$。在这里，$\\alpha$ 是 $(\\forall a\\,(a \\lor y))$ 并且 $b$ 在其中不是自由变量，所以\n$$(\\forall a\\,(a \\lor y)) \\lor (\\exists b\\,(\\neg b \\land z)) \\equiv \\exists b\\,\\big((\\forall a\\,(a \\lor y)) \\lor (\\neg b \\land z)\\big).$$\n接下来，使用针对带有全称量词的析取的前束变换规则：如果 $a$ 在 $\\beta$ 中不是自由变量，那么 $(\\forall a\\,\\varphi) \\lor \\beta \\equiv \\forall a\\,(\\varphi \\lor \\beta)$。在这里，$\\beta$ 是 $(\\neg b \\land z)$ 并且 $a$ 在其中不是自由变量，因此\n$$\\exists b\\,\\big((\\forall a\\,(a \\lor y)) \\lor (\\neg b \\land z)\\big) \\equiv \\exists b\\,\\forall a\\,\\big((a \\lor y) \\lor (\\neg b \\land z)\\big).$$\n因此，与 $\\Phi$ 等价的一个前束范式是\n$$\\exists b\\,\\forall a\\,\\big((a \\lor y) \\lor (\\neg b \\land z)\\big),$$\n这与选项 C 相匹配。（选项 A 违反了变量不同的要求；选项 B、D 和 E 以不等价于原始公式的方式改变了联结词结构或量词类型。）", "answer": "$$\\boxed{C}$$", "id": "1467507"}, {"introduction": "前束范式本身并非终点，而是许多逻辑系统，特别是自动定理证明领域，一个至关重要的预处理阶段。本练习要求您将一个由多个逻辑断言构成的复杂公式转换为前束范式，它清晰地展示了如何将多个独立的逻辑命题整合至单一的量词前缀之下，为后续的斯科伦化（Skolemization）与归结（resolution）等高级分析流程做好准备。[@problem_id:2978926]", "problem": "设 $\\mathcal{L}$ 是一个一阶语言，含有一个一元函数符号 $f$ 和一个一元谓词符号 $P$。固定一个正整数 $n \\in \\mathbb{N}$ 且 $n \\geq 1$。考虑以下闭合句子\n$$\n\\Phi_{n} \\;:=\\; \\bigl(\\exists x\\, P(x)\\bigr)\\;\\wedge\\;\\bigl(\\forall y\\,(P(y)\\rightarrow P(f(y)))\\bigr)\\;\\wedge\\;\\bigl(\\forall z\\,\\neg P(f^{n}(z))\\bigr),\n$$\n其中 $f^{n}(t)$ 表示将 $f$ 应用于项 $t$ 的 $n$ 次迭代。\n\n你的任务是：\n- 将 $\\Phi_{n}$ 转换为前束范式 (PNF)，仅使用逻辑有效的等价式和为避免捕获而进行的变量标准化来证明每个转换步骤的合理性。\n- 对PNF句子进行Skolem化以获得一个等可满足公式，并明确指出引入的Skolem符号的元数和名称。然后去掉全称量词，并将矩阵转换为合取范式 (CNF)，即文字析取的合取。陈述最终的子句集。\n- 为Skolem化的子句集定义Herbrand域 $\\mathcal{U}$ 和Herbrand基 $\\mathcal{B}$。对于一个基项 $t$，如果 $t$ 是一个常量符号，则定义其深度 $\\operatorname{depth}(t)=0$；如果 $t$ 形如 $f(t')$，则 $\\operatorname{depth}(f(t'))=1+\\operatorname{depth}(t')$。对于 $d \\in \\mathbb{N}$，令深度为d的Herbrand展开为所有子句的基实例的集合，其中每个基项的深度至多为 $d$。确定最小深度 $d_{\\min}(n)$，使得深度为$d_{\\min}(n)$的Herbrand展开是命题上不可满足的。\n- 仅使用项的深度至多为 $d_{\\min}(n)$ 的基实例，给出一个推导出空子句的归结反驳，并解释为何任何更小的深度都无法产生反驳（即验证最小性）。\n- 以关于 $n$ 的闭式表达式的形式给出 $d_{\\min}(n)$ 的最终答案。最终答案必须是单个不带单位的表达式。\n\n你的推理必须在每个阶段验证其正确性，指出转换是保持逻辑等价性还是仅保持等可满足性，并明确证明对于反驳来说项深度的界限是必要且充分的。", "solution": "该问题要求对一阶句子 $\\Phi_n$ 进行多步分析。我们将系统地处理每个任务：转换为前束范式，Skolem化并转换为合取范式，进行Herbrand分析以找到最小反驳深度，以及提供一个形式化的归结反驳。\n\n给定的句子是：\n$$\n\\Phi_{n} \\;:=\\; \\bigl(\\exists x\\, P(x)\\bigr)\\;\\wedge\\;\\bigl(\\forall y\\,(P(y)\\rightarrow P(f(y)))\\bigr)\\;\\wedge\\;\\bigl(\\forall z\\,\\neg P(f^{n}(z))\\bigr)\n$$\n对于一个正整数 $n \\geq 1$。\n\n**1. 转换为前束范式 (PNF)**\n\n目标是将所有量词移到公式的前面。该句子是三个子公式的合取，其中量化变量（$x$、$y$、$z$）是不同的。我们可以使用标准的逻辑等价式逐个将量词提出。只要 $v$ 在 $B$ 中不是自由变量，量词 $\\mathcal{Q}v$ 就可以从合取 $(\\mathcal{Q}v\\, A(v)) \\wedge B$ 中移出，形成 $\\mathcal{Q}v\\,(A(v) \\wedge B)$。\n\n我们从 $\\Phi_n$ 开始：\n$$\n\\Phi_{n} = \\bigl(\\exists x\\, P(x)\\bigr)\\;\\wedge\\;\\bigl(\\forall y\\,(P(y)\\rightarrow P(f(y)))\\bigr)\\;\\wedge\\;\\bigl(\\forall z\\,\\neg P(f^{n}(z))\\bigr)\n$$\n首先，我们移动存在量词 $\\exists x$。变量 $x$ 在第二个和第三个合取项中不作为自由变量出现。此转换保持逻辑等价性。\n$$\n\\Phi_{n} \\equiv \\exists x \\left( P(x) \\;\\wedge\\; \\bigl(\\forall y\\,(P(y)\\rightarrow P(f(y)))\\bigr)\\;\\wedge\\;\\bigl(\\forall z\\,\\neg P(f^{n}(z))\\bigr) \\right)\n$$\n接下来，我们移动全称量词 $\\forall y$。变量 $y$ 在 $P(x)$ 或第三个合取项中不作为自由变量出现。此步骤也保持逻辑等价性。\n$$\n\\Phi_{n} \\equiv \\exists x \\forall y \\left( P(x) \\;\\wedge\\; (P(y)\\rightarrow P(f(y)))\\;\\wedge\\;\\bigl(\\forall z\\,\\neg P(f^{n}(z))\\bigr) \\right)\n$$\n最后，我们移动全称量词 $\\forall z$。变量 $z$ 在 $P(x) \\wedge (P(y)\\rightarrow P(f(y)))$ 中不作为自由变量出现。此步骤保持逻辑等价性。\n$$\n\\Phi_{n} \\equiv \\exists x \\forall y \\forall z \\left( P(x) \\;\\wedge\\; (P(y)\\rightarrow P(f(y)))\\;\\wedge\\; \\neg P(f^{n}(z)) \\right)\n$$\n这就是 $\\Phi_n$ 的前束范式。前缀是 $\\exists x \\forall y \\forall z$，矩阵是 $P(x) \\wedge (P(y)\\rightarrow P(f(y))) \\wedge \\neg P(f^{n}(z))$。\n\n**2. Skolem化与转换为CNF**\n\n我们从PNF开始。Skolem化消除了存在量词。该转换保持等可满足性，但不保持逻辑等价性。\nPNF是 $\\exists x \\forall y \\forall z M(x, y, z)$，其中 $M$ 是矩阵。\n存在量词 $\\exists x$ 在最外层。它不在任何全称量词的作用域内。我们用一个新的Skolem常量（一个元数为0的函数）替换变量 $x$，我们将其命名为 $c$。\n得到的公式是：\n$$\n\\forall y \\forall z \\left( P(c) \\;\\wedge\\; (P(y)\\rightarrow P(f(y)))\\;\\wedge\\; \\neg P(f^{n}(z)) \\right)\n$$\n接下来，我们去掉全称量词，并理解为变量 $y$ 和 $z$ 是在整个公式上全称量化的。这给出了无量词矩阵：\n$$\nP(c) \\;\\wedge\\; (P(y)\\rightarrow P(f(y)))\\;\\wedge\\; \\neg P(f^{n}(z))\n$$\n现在，我们将这个矩阵转换为合取范式 (CNF)，它是一个子句（文字的析取）的合取。\n第一个合取项 $P(c)$ 是一个文字，因此是一个子句。\n第二个合取项 $P(y)\\rightarrow P(f(y))$，使用等价式 $A \\rightarrow B \\equiv \\neg A \\vee B$进行转换。这得到子句 $\\neg P(y) \\vee P(f(y))$。\n第三个合取项 $\\neg P(f^{n}(z))$ 是一个文字，因此是一个子句。\n得到的CNF公式是：\n$$\nP(c) \\;\\wedge\\; (\\neg P(y) \\vee P(f(y))) \\;\\wedge\\; \\neg P(f^{n}(z))\n$$\n相应的子句集，即归结的标准输入，是：\n$$\nS = \\left\\{ \\{P(c)\\}, \\{\\neg P(y), P(f(y))\\}, \\{\\neg P(f^{n}(z))\\} \\right\\}\n$$\n\n**3. Herbrand域、Herbrand基和最小不可满足深度**\n\n子句集 $S$ 的语言包含一个常量符号 $c$，一个一元函数符号 $f$，以及一个一元谓词符号 $P$。\n\n**Herbrand域** $\\mathcal{U}$ 是由常量和函数符号构造的所有基项的集合。\n$$\n\\mathcal{U} = \\{c, f(c), f(f(c)), \\dots\\} = \\{ f^k(c) \\mid k \\in \\mathbb{N}_0 \\}\n$$\n其中 $f^0(c)$ 表示 $c$。\n\n**Herbrand基** $\\mathcal{B}$ 是所有基原子的集合。\n$$\n\\mathcal{B} = \\{P(t) \\mid t \\in \\mathcal{U}\\} = \\{ P(f^k(c)) \\mid k \\in \\mathbb{N}_0 \\}\n$$\n基项 $t$ 的深度定义为 $\\operatorname{depth}(c) = 0$ 和 $\\operatorname{depth}(f(t')) = 1 + \\operatorname{depth}(t')$。由此可知 $\\operatorname{depth}(f^k(c)) = k$。\n\n深度为$d$的Herbrand展开，记为 $H_d$，是 $S$ 中子句的所有基实例的集合，其中所涉及的每个项的深度至多为 $d$。\n我们来分析反驳所需的子句。直观上的矛盾来自于推导出 $P(f^n(c))$ 并将其与 $\\neg P(f^n(z))$ 的一个实例进行对质。\n\n- 子句 $\\{P(c)\\}$ 是基子句，项 $c$ 的深度为0。对于任何 $d \\ge 0$，它都在 $H_d$ 中。\n- $\\{\\neg P(y), P(f(y))\\}$ 的基实例是通过用基项 $t=f^k(c) \\in \\mathcal{U}$ 替换 $y$ 形成的。这得到 $\\{\\neg P(f^k(c)), P(f^{k+1}(c))\\}$。这些项的深度分别为 $k$ 和 $k+1$。为了使该子句在 $H_d$ 中，我们需要 $\\operatorname{depth}(f^{k+1}(c)) = k+1 \\le d$，这意味着 $k \\le d-1$。\n- $\\{\\neg P(f^{n}(z))\\}$ 的基实例是通过用 $t=f^k(c) \\in \\mathcal{U}$ 替换 $z$ 形成的。这得到 $\\{\\neg P(f^n(f^k(c)))\\} = \\{\\neg P(f^{n+k}(c))\\}$。该项的深度为 $n+k$。为了使该子句在 $H_d$ 中，我们需要 $n+k \\le d$，这意味着 $k \\le d-n$。\n\n为了获得矛盾，我们需要推导出空子句。一个归结证明将按以下方式进行：\n1. 从 $\\{P(c)\\}$ 和 $\\{\\neg P(c), P(f(c))\\}$，推导出 $\\{P(f(c))\\}$。\n2. 从 $\\{P(f(c))\\}$ 和 $\\{\\neg P(f(c)), P(f^2(c))\\}$，推导出 $\\{P(f^2(c))\\}$。\n...\n$n$. 通过将这些归结链接 $n$ 次，从 $\\{P(f^{n-1}(c))\\}$ 和 $\\{\\neg P(f^{n-1}(c)), P(f^n(c))\\}$，我们推导出 $\\{P(f^n(c))\\}$。\n$n+1$. 这个推导出的子句 $\\{P(f^n(c))\\}$ 随后可以与一个负子句如 $\\{\\neg P(f^n(c))\\}$ 进行归结，以产生空子句。\n\n我们来检查此推导的深度要求。\n- 为了通过链式归结推导出 $\\{P(f^n(c))\\}$，我们需要第二个子句的所有基实例，即 $\\{\\neg P(f^k(c)), P(f^{k+1}(c))\\}$，其中 $k=0, 1, \\dots, n-1$。此链中的最后一个实例，对应 $k=n-1$，涉及项 $f^n(c)$，其深度为 $n$。因此，我们需要 $d \\ge n$。\n- 为了获得产生矛盾的负子句，我们可以用 $z=c$ 来实例化 $\\{\\neg P(f^n(z))\\}$。这得到 $\\{\\neg P(f^n(c))\\}$。项 $f^n(c)$ 的深度为 $n$。因此，为了使这个子句在我们的基集合中，我们需要 $d \\ge n$。\n\n反驳的两个基本组成部分都要求深度至少为 $n$。这表明最小深度是 $d_{\\min}(n) = n$。\n\n我们来验证这一点。\n如果 $d=n$，深度为$n$的展开 $H_n$ 包含：\n- $\\{P(c)\\}$。\n- $\\{\\neg P(f^k(c)), P(f^{k+1}(c))\\}$，其中 $k=0, 1, \\dots, n-1$。\n- $\\{\\neg P(f^{n+k}(c))\\}$，其中 $k=0$，即单个子句 $\\{\\neg P(f^n(c))\\}$。\n这个集合是不可满足的，正如将在下一节的反驳中展示的那样。因此，深度 $n$ 是充分的。\n\n现在考虑深度为 $d=n-1$。展开 $H_{n-1}$ 包含：\n- $\\{P(c)\\}$。\n- $\\{\\neg P(f^k(c)), P(f^{k+1}(c))\\}$，其中 $k=0, 1, \\dots, n-2$。\n- 对于第三种子句类型，我们需要 $n+k \\le n-1$，这意味着 $k \\le -1$。由于 $k$ 必须是一个非负整数，所以在 $H_{n-1}$ 中没有 $\\{\\neg P(f^n(z))\\}$ 的基实例。\n\n得到的子句集是 $H_{n-1} = \\{ \\{P(c)\\} \\} \\cup \\{ \\{\\neg P(f^k(c)), P(f^{k+1}(c))\\} \\mid k=0, \\dots, n-2 \\}$。\n这个集合是可满足的。考虑一个命题解释 $I$，其中对于所有的 $i \\in \\{0, \\dots, n-1\\}$，$P(f^i(c))$ 为真，而对于所有其他的基原子为假。\n- 子句 $\\{P(c)\\}$ 被满足，因为 $I(P(c))$ 为真。\n- 对于 $k \\in \\{0, \\dots, n-2\\}$ 的子句 $\\{\\neg P(f^k(c)), P(f^{k+1}(c))\\}$ 被满足，因为 $I(P(f^{k+1}(c)))$ 为真（因为 $k+1 \\le n-1$）。\n由于Herbrand展开 $H_{n-1}$ 是可满足的，所以不能从中推导出反驳。\n因此，深度 $d=n-1$ 是不充分的。\n\n最小深度是 $d_{\\min}(n) = n$。\n\n**4. 归结反驳与最小性验证**\n\n使用项的深度至多为 $d_{\\min}(n)=n$ 的基实例，我们可以构造一个归结反驳。令 $R(A, B)$ 表示子句 $A$ 和 $B$ 的归结式。\n设 $C_1 = \\{P(c)\\}$，$C_{2,k} = \\{\\neg P(f^k(c)), P(f^{k+1}(c))\\}$，以及 $C_{3,0} = \\{\\neg P(f^n(c))\\}$。所有这些子句都在 $H_n$ 中。\n\n1. $R_0 = C_1 = \\{P(c)\\}$（在 $H_n$ 中给定）\n2. $R_1 = R(R_0, C_{2,0}) = R(\\{P(c)\\}, \\{\\neg P(c), P(f(c))\\}) = \\{P(f(c))\\}$\n3. $R_2 = R(R_1, C_{2,1}) = R(\\{P(f(c))\\}, \\{\\neg P(f(c)), P(f^2(c))\\}) = \\{P(f^2(c))\\}$\n...\n$k+1$. $R_k = R(R_{k-1}, C_{2,k-1}) = \\{P(f^k(c))\\}$ 对于 $k=1, \\dots, n$。\n\n这个过程是一个归纳。设 $R_{k-1} = \\{P(f^{k-1}(c))\\}$。我们将其与 $C_{2,k-1} = \\{\\neg P(f^{k-1}(c)), P(f^k(c))\\}$ 进行归结，后者在 $H_n$ 中，因为 $k-1 \\le n-1$。归结式是 $R_k = \\{P(f^k(c))\\}$。从 $R_0=\\{P(c)\\}$ 开始，经过 $n$ 步归结，我们可以推导出 $R_n=\\{P(f^n(c))\\}$。\n\n反驳的最后一步是：\n$n+1$. $R(R_n, C_{3,0}) = R(\\{P(f^n(c))\\}, \\{\\neg P(f^n(c))\\}) = \\square$（空子句）。\n\n这样就完成了反驳。\n\n深度 $d_{\\min}(n)=n$ 的最小性已在前面确定。任何更小的深度，例如 $n-1$，都会导致一个基子句集 $H_{n-1}$，该集合不包含任何负单位子句（如 $\\{\\neg P(t)\\}$）。如前所示，$H_{n-1}$ 是可满足的。根据归结的可靠性，一个可满足的子句集不能产生一个反驳（即空子句）。因此，$d_{\\min}(n)$ 必须至少为 $n$。由于深度 $n$ 是充分的，所以它是最小的。\n\n最终答案是 $d_{\\min}(n)$ 的闭式表达式。\n基于分析，$d_{\\min}(n) = n$。", "answer": "$$\n\\boxed{n}\n$$", "id": "2978926"}]}