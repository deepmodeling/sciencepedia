{"hands_on_practices": [{"introduction": "第一个练习旨在将我们对Skolem化的理解建立在其语义基础之上。通过处理一个简单的开放公式，您将不仅仅是机械地应用规则来推导相应的Skolem化形式，而是从第一性原理出发，思考模型中的变量赋值和满足性。这个练习 [@problem_id:2982792] 对于领会为何Skolem函数的论元必须精确匹配约束原始存在量词的自由变量或全称量词至关重要。", "problem": "设 $\\mathcal{L}$ 为一阶逻辑（FOL）的单类符号集，其包含一个二元关系符号 $R$。考虑 $\\mathcal{L}$-开公式 $\\exists y\\,R(x,y)$，其中 $x$ 是一个自由变量。从 $\\mathcal{L}$-结构、变量赋值和满足性的基础语义定义出发，并依据 Skolem化 的一般构造原则（即用一个由新的函数符号构成的项来替换存在量化变量，该新函数符号的参数恰好是该存在量词所依赖的全称量化变量），推导与 $\\exists y\\,R(x,y)$ 对应的 Skolem化开公式，并从第一性原理出发，解释所产生的新的函数符号在任意 $\\mathcal{L}$-结构扩展后如何被解释。你的推导应明确说明所引入函数的元数为何是如此，以及这种解释如何与全称闭包的满足性相关联。使用标准的一阶语法，在扩展语言中将最终的 Skolem化开公式表达为单个解析表达式。无需数值舍入，也无适用物理单位。", "solution": "该问题有效。这是一个在数理逻辑领域内，特别是在关于 Skolem化 这一主题上，提法恰当且有科学依据的问题。它没有矛盾、歧义或事实错误。我们可以开始求解。\n\n设 $\\mathcal{L}$ 是指定的具有单个二元关系符号 $R$ 的一阶语言。给定 $\\mathcal{L}$-开公式 $\\phi(x) \\equiv \\exists y\\,R(x,y)$，其中 $x$ 是一个自由变量。我们的目标是推导此公式的 Skolem化形式，并从第一性原理出发解释所引入的函数符号的解释。\n\n首先，我们建立语义基础。一个 $\\mathcal{L}$-结构，记作 $\\mathcal{M}$，是一个偶对 $(M, R^{\\mathcal{M}})$，其中 $M$ 是一个非空集合，称为论域或全集，而 $R^{\\mathcal{M}}$ 是符号 $R$ 的解释，它是 $M$ 上的一个二元关系（即 $R^{\\mathcal{M}} \\subseteq M \\times M$）。在 $\\mathcal{M}$ 中的一个变量赋值是一个函数 $s: V \\to M$，其中 $V$ 是变量集合（包括 $x$ 和 $y$）。\n\n公式 $\\phi(x)$ 在结构 $\\mathcal{M}$ 中于赋值 $s$ 下的满足性，写作 $\\mathcal{M}, s \\models \\exists y\\,R(x,y)$，其定义如下：存在一个元素 $b \\in M$，使得 $\\mathcal{M}, s[y \\mapsto b] \\models R(x,y)$。此处，$s[y \\mapsto b]$ 是将 $y$ 映射到 $b$ 并且对所有其他变量都与 $s$ 一致的赋值。原子公式 $R(x,y)$ 被满足，即 $\\mathcal{M}, s[y \\mapsto b] \\models R(x,y)$，当且仅当解释后的项对 $( (s[y \\mapsto b])(x), (s[y \\mapsto b])(y) )$ 属于关系 $R^{\\mathcal{M}}$。由于 $(s[y \\mapsto b])(x) = s(x)$ 且 $(s[y \\mapsto b])(y) = b$，此条件简化为 $(s(x), b) \\in R^{\\mathcal{M}}$。\n因此，$\\mathcal{M}, s \\models \\exists y\\,R(x,y)$ 当且仅当存在一个元素 $b \\in M$，使得 $(s(x), b) \\in R^{\\mathcal{M}}$。\n\nSkolem化过程旨在用函数项替换存在量化变量，以创建一个与原公式等可满足的新公式。其核心原则是，为一个存在变量（如此处的 $y$）选择见证元（witness）可能依赖于在其外部被全称量化的变量的值。在一个开公式中，当考虑该公式的全称闭包的可满足性时，自由变量在最外层被隐式地全称量化。\n\n$\\phi(x)$ 的全称闭包是语句 $\\forall x \\,\\exists y\\,R(x,y)$。一个结构 $\\mathcal{M}$ 是此语句的模型，写作 $\\mathcal{M} \\models \\forall x\\,\\exists y\\,R(x,y)$，当且仅当对于每个元素 $a \\in M$，都存在一个元素 $b \\in M$，使得 $(a, b) \\in R^{\\mathcal{M}}$。这明确显示了 $b$ 的选择（$y$ 的见证元）依赖于 $a$ 的选择（$x$ 的值）。\n\n这种函数依赖关系正是 Skolem化所要明确表达的。我们引入一个新的、未曾用过的函数符号，我们称之为 $f$，它不在原始语言 $\\mathcal{L}$ 中。这个函数符号的元数必须等于约束该存在量词的全称量化变量的数量。在我们的例子中，存在量词 $\\exists y$ 处于自由变量 $x$ 的作用域内。因此，Skolem函数 $f$ 必须接受一个参数，对应于 $x$。其元数为 $1$。\n\n我们将语言 $\\mathcal{L}$ 扩展为一个新语言 $\\mathcal{L}' = \\mathcal{L} \\cup \\{f\\}$，其中 $f$ 是一个一元函数符号。Skolem化过程将存在量化变量 $y$ 替换为项 $f(x)$。得到的 Skolem化开公式是 $R(x, f(x))$。\n\n现在，我们必须解释 $f$ 的解释及其与全称闭包满足性的关系。假设一个 $\\mathcal{L}$-结构 $\\mathcal{M} = (M, R^{\\mathcal{M}})$ 是全称闭包 $\\forall x\\,\\exists y\\,R(x,y)$ 的一个模型。如前所述，这意味着对于每一个 $a \\in M$，集合 $S_a = \\{b \\in M \\mid (a, b) \\in R^{\\mathcal{M}}\\}$ 是非空的。选择公理保证存在一个函数，我们称之为 $g: M \\to M$，使得对于每一个 $a \\in M$，$g(a) \\in S_a$。这个函数 $g$ 是一个“选择函数”，它为每个给定的 $a$ 选择一个有效的见证元 $b$。\n\n我们可以通过定义新函数符号 $f$ 的解释（记作 $f^{\\mathcal{M}'}$）为这个选择函数 $g$，从而将 $\\mathcal{L}$-结构 $\\mathcal{M}$ 扩展为一个 $\\mathcal{L}'$-结构 $\\mathcal{M}' = (M, R^{\\mathcal{M}}, f^{\\mathcal{M}'})$。也就是说，$f^{\\mathcal{M}'} = g$。\n根据 $g$ 的构造，对于每一个 $a \\in M$，我们有 $(a, g(a)) \\in R^{\\mathcal{M}}$，这意味着 $(a, f^{\\mathcal{M}'}(a)) \\in R^{\\mathcal{M}}$。这正是结构 $\\mathcal{M}'$ 成为 Skolem化公式的全称闭包 $\\forall x\\,R(x, f(x))$ 的模型所需的语义条件。\n\n因此，$\\forall x\\,\\exists y\\,R(x,y)$ 的任何模型都可以扩展成 $\\forall x\\,R(x, f(x))$ 的一个模型。反之，$\\forall x\\,R(x, f(x))$ 的任何模型也显然是 $\\forall x\\,\\exists y\\,R(x,y)$ 的一个模型，因为 $f(x)$ 为 $y$ 提供了见证元。这便建立了两个全称闭包的等可满足性，而这正是 Skolem化的基本性质。\n\n总结来说，推导过程是通过认识到存在量化变量 $y$ 的见证元是自由变量 $x$ 的函数。引入一个新的单元函数符号 $f$ 来表示这种依赖关系。通过移除存在量词并将所有出现的 $y$ 替换为项 $f(x)$，得到 Skolem化开公式。在任何模型中，$f$ 的解释都是一个选择函数，它为 $x$ 的每个值提供一个满足关系 $R$ 的相应 $y$ 值。\n\n因此，与 $\\exists y\\,R(x,y)$ 对应的最终 Skolem化开公式是 $R(x, f(x))$，其中 $f$ 是一个新引入的一元函数符号。", "answer": "$$\n\\boxed{R(x, f(x))}\n$$", "id": "2982792"}, {"introduction": "形式化方法的威力在于其精确性，而细微的错误可能导致无效的结论。这个练习 [@problem_id:2982829] 要求您诊断一个常见但关键的Skolem化错误：为多个不同的存在量词不正确地复用同一个Skolem函数。通过构造一个反例，您将超越句法层面，深入语义层面，精确地展示这种错误如何破坏等可满足性这一基本属性。", "problem": "考虑一个前束范式的一阶逻辑（FOL）语句：$$\\forall x \\,\\exists y \\,\\exists z \\, S(x,y,z),$$ 其中 $S$ 是一个固定的带等词的一阶语言中的无量词谓词符号。一种所谓的 Skolem 化将 $\\exists y$ 和 $\\exists z$ 都替换为同一个 Skolem 函数项 $f(x)$，得到全称闭包 $$\\forall x \\, S\\big(x,f(x),f(x)\\big).$$ 从 Skolem 化的基本定义以及关于全称量化变量的依赖规则出发，找出此替换中的确切逻辑错误，并通过诉诸等可满足性和模型论语义来解释，为什么此错误对于某些结构会破坏可满足性。然后，通过引入必要的 Skolem 函数符号并根据量词前缀和作用域指定其元数，推导出正确的 Skolem 范式。最后，将正确见证存在量词的 Skolem 项有序对作为一个 LaTeX 行矩阵提供，作为你的最终答案。无需进行数值四舍五入。仅以这两个 Skolem 项的行矩阵形式表达你的最终答案。", "solution": "该问题陈述是有效的。这是一个形式逻辑中定义明确的问题，它考验了 Skolem 化的基本原理。\n\nSkolem 化过程将一个一阶逻辑公式转换为一个等可满足的 Skolem 范式公式，后者是一种只包含全称量词的前束范式公式。其核心原则是，用一个称为 Skolem 项的项来替换每个存在量化的变量。该项由一个称为 Skolem 函数的新函数符号构成，应用于所有在前束范式中出现得更早（即其作用域涵盖了正在被消除的存在量词）的全称量化变量。\n\n给定的语句是 $$\\forall x \\,\\exists y \\,\\exists z \\, S(x,y,z),$$\n所谓的 Skolem 化是 $$\\forall x \\, S\\big(x,f(x),f(x)\\big).$$\n\n此提议转换中的确切逻辑错误在于，它重复使用了同一个 Skolem 函数项 $f(x)$ 来替换两个不同的存在量化变量 $y$ 和 $z$。原始语句断言，对于任何给定的 $x$，都存在一个 $y$ 的值和一个 $z$ 的值来满足谓词 $S$。这两个值 $y$ 和 $z$ 并不要求是相同的。公式 $\\exists y \\,\\exists z \\, S(x,y,z)$ 并未对 $y$ 和 $z$ 的见证者是否相等作出任何声明。\n\n通过将 $y$ 和 $z$ 都替换为相同的项 $f(x)$，所谓的 Skolem 化隐式地引入了约束 $y=z$。得到的公式 $\\forall x \\, S\\big(x,f(x),f(x)\\big)$ 断言，对于任意 $x$，存在一个单一的值，我们称之为 $w = f(x)$，使得 $S(x,w,w)$ 成立。这是一个比原始语句在逻辑上更强的陈述。如果公式 $\\Phi$ 的每个模型也都是公式 $\\Psi$ 的模型，则称 $\\Phi$ 逻辑蕴涵 $\\Psi$（记作 $\\Phi \\models \\Psi$）。在本例中，$\\forall x \\, \\exists w \\, S(x,w,w)$ 蕴涵 $\\forall x \\, \\exists y \\, \\exists z \\, S(x,y,z)$（只需选择 $y=w$ 和 $z=w$ 即可），但反之不成立。因此，所谓的 Skolem 化与原始公式并非逻辑等价。\n\n更重要的是，Skolem 化的要求是保持可满足性（即等可满足），而非逻辑等价性。这个错误可能破坏可满足性。让我们用一个模型论的论证来证明这一点。如果一个公式至少存在一个模型（一个论域和符号的解释）使其为真，那么它就是可满足的。\n令论域为整数集 $\\mathbb{Z}$。\n令谓词 $S(x,y,z)$ 被解释为关系 $y + z = x$。\n\n原始语句变为：\n$$\\forall x \\in \\mathbb{Z} \\,\\, \\exists y \\in \\mathbb{Z} \\,\\, \\exists z \\in \\mathbb{Z} \\,\\, (y+z=x).$$\n这个陈述在整数的标准模型中为真。对于任意整数 $x$，我们总能找到合适的整数 $y$ 和 $z$。例如，我们可以选择 $y=0$ 和 $z=x$。由于存在这样的模型，原始公式是可满足的。\n\n现在，在相同的解释下考虑所谓的 Skolem 化：\n$$\\forall x \\in \\mathbb{Z} \\,\\, (f(x) + f(x) = x).$$\n这可以简化为 $\\forall x \\in \\mathbb{Z} \\,\\, (2f(x) = x)$。这个陈述断言，对于每个整数 $x$，都存在一个整数 $f(x)$（见证者），使得该整数的 2 倍等于 $x$。这是错误的。对于任何奇数，例如 $x=1$，不存在整数 $w$ 使得 $2w = 1$。因此，不存在任何函数 $f: \\mathbb{Z} \\to \\mathbb{Z}$ 能对所有 $x$ 都满足此性质。所谓的 Skolem 化公式在整数上是不可满足的。\n\n由于原始公式是可满足的，而错误 Skolem 化的公式是不可满足的，这个错误的过程破坏了可满足性，这违反了 Skolem 化过程的基本要求。\n\n为了推导出正确的 Skolem 范式，我们必须为每个存在量词引入一个唯一的 Skolem 函数。\n原始公式是 $\\forall x \\,\\exists y \\,\\exists z \\, S(x,y,z)$。\n1. 第一个存在量词是 $\\exists y$。它在全称量词 $\\forall x$ 的作用域内。因此，我们必须用一个项 $f(x)$ 来替换 $y$，其中 $f$ 是一个新的元数为 1 的函数符号。公式变为 $\\forall x \\,\\exists z \\, S(x,f(x),z)$。\n2. 第二个存在量词是 $\\exists z$。它也在 $\\forall x$ 的作用域内。我们必须用一个项 $g(x)$ 来替换 $z$，其中 $g$ 是另一个与 $f$ 不同的、元数为 1 的新函数符号。\n\n因此，正确的 Skolem 范式是：\n$$\\forall x \\, S\\big(x,f(x),g(x)\\big).$$\n这个公式与原始公式是等可满足的。如果原始公式在某个模型中为真，那么对于每个 $x$，都存在 $y_x$ 和 $z_x$。我们可以将函数 $f$ 和 $g$ 的解释定义为 $f(x) = y_x$ 和 $g(x) = z_x$。反之，如果 Skolem 化的公式在某个带有对 $f$ 和 $g$ 的解释的模型中为真，那么对于任意 $x$，我们可以选择 $y = f(x)$ 和 $z = g(x)$ 来满足原始公式。\n\n正确见证 $y$ 和 $z$ 的存在量词的 Skolem 项有序对分别是 $f(x)$ 和 $g(x)$。", "answer": "$$\\boxed{\\begin{pmatrix} f(x)  g(x) \\end{pmatrix}}$$", "id": "2982829"}, {"introduction": "Skolem化不仅是一种理论上的好奇，更是自动推理中的关键步骤，为许多证明算法提供预处理。这个练习 [@problem_id:2982796] 模拟了这一实用工作流程，要求您将一个一阶逻辑公式转换为一组适用于归结方法的子句。您将应用一系列变换——前束化、Skolem化和转换为合取范式 (CNF)——从而了解这些理论工具如何协同工作，使复杂的逻辑语句能够被计算机进行分析。", "problem": "给定一个一阶公式，其签名包含谓词符号 $P(\\cdot)$、$Q(\\cdot)$ 和 $R(\\cdot,\\cdot,\\cdot)$：\n$$\\forall x \\,\\exists y \\,\\bigl(P(x)\\land Q(y)\\land \\forall z\\,R(x,y,z)\\bigr).$$\n请仅使用一阶逻辑的基本定义和法则，按以下步骤进行操作：\n- 通过将量词移动到前面，将公式转换为显式的前束范式，同时保持逻辑等价性。请使用标准等价关系（例如，当变量在另一个合取项中不是自由变量时，全称量词在合取运算上的分配律）仔细证明每一步转换的合理性。\n- 通过使用 Skolem 函数来消除存在量词，从而对公式进行 Skolem 化。Skolem 函数的元数（arity）应与该存在量化变量所依赖的、在它之前的所有全称量化变量集合相匹配。请明确解释这种依赖关系，并说明所得到的 Skolem 函数符号。\n- 去掉所有全称量词以获得全称闭包，并将无量词的母式（matrix）转换为合取范式（CNF）。在适当的情况下，确保子句间的变量是标准分离的（standardization apart），以得到一组适用于归结方法（resolution method）的子句。\n- 最后，计算所得子句集中的不同子句的数量。你的最终答案应该只有这个数字。\n\n在每一步中，从前束范式转换、Skolem 化和子句形式的核心定义出发，给出详细的证明。最终答案必须是一个实数值，无需四舍五入。", "solution": "该问题要求将一个给定的一阶逻辑公式系统地转换为一个子句集，然后计算该集合中不同子句的数量。我们将根据数理逻辑的原理，一步一步地进行操作，并为每个转换提供严谨的证明。\n\n给定的公式是：\n$$ \\forall x \\,\\exists y \\,\\bigl(P(x)\\land Q(y)\\land \\forall z\\,R(x,y,z)\\bigr) $$\n该签名包含谓词符号 $P$（一元）、$Q$（一元）和 $R$（三元）。\n\n**第一步：转换为前束范式**\n\n如果一个公式的形式为 $Q_1 v_1 \\dots Q_n v_n \\, M$，那么它就处于前束范式（PNF）中，其中 $Q_i$ 是量词（$\\forall$ 或 $\\exists$），$v_i$ 是不同的变量，而 $M$ 是一个称为母式（matrix）的无量词公式。量词序列 $Q_1 v_1 \\dots Q_n v_n$ 被称为前缀（prefix）。\n\n初始公式为：\n$$ \\forall x \\,\\exists y \\,\\bigl(P(x)\\land Q(y)\\land \\forall z\\,R(x,y,z)\\bigr) $$\n量词 $\\forall z$ 位于量词 $\\forall x$ 和 $\\exists y$ 的辖域内。为了将公式转换为 PNF，我们必须将 $\\forall z$ 移到母式的前面，加入前缀。我们使用一个关于量词在合取上分配的标准逻辑等价式。对于任意公式 $\\psi$ 和 $\\phi$，以及一个在 $\\psi$ 中不是自由变量的变量 $v$，以下等价关系成立：\n$$ (\\psi \\land \\forall v\\,\\phi) \\leftrightarrow \\forall v\\,(\\psi \\land \\phi) $$\n在我们的公式中，在 $\\exists y$ 的辖域内，我们有子公式 $\\bigl(P(x)\\land Q(y)\\land \\forall z\\,R(x,y,z)\\bigr)$。令 $\\psi = P(x) \\land Q(y)$ 且 $\\forall v\\,\\phi = \\forall z\\,R(x,y,z)$。变量 $z$ 在 $\\psi$ 中不是自由变量。因此，我们可以应用该等价关系：\n$$ \\bigl(P(x)\\land Q(y)\\bigr) \\land \\forall z\\,R(x,y,z) \\leftrightarrow \\forall z\\,\\bigl(P(x)\\land Q(y)\\land R(x,y,z)\\bigr) $$\n将此代换回原公式，我们得到：\n$$ \\forall x \\,\\exists y \\,\\forall z\\,\\bigl(P(x)\\land Q(y)\\land R(x,y,z)\\bigr) $$\n该公式处于前束范式。其前缀是 $\\forall x \\,\\exists y \\,\\forall z$，母式是 $P(x)\\land Q(y)\\land R(x,y,z)$。\n\n**第二步：Skolem 化**\n\nSkolem 化是从 PNF 公式中消除存在量词的过程。对于每个存在量化的变量 $v$，我们引入一个新的函数符号，即 Skolem 函数，其参数是在前束范式前缀中位于 $v$ 之前的所有全称量化变量。然后，$v$ 的每次出现都被替换为该 Skolem 函数对其参数的应用，并移除存在量词 $\\exists v$。所得公式与原公式不具有逻辑等价性，但具有等可满足性（equisatisfiable），这对于像归结这样的证明方法来说是足够的。\n\n我们的 PNF 是：\n$$ \\forall x \\,\\exists y \\,\\forall z\\,\\bigl(P(x)\\land Q(y)\\land R(x,y,z)\\bigr) $$\n有一个存在量词，$\\exists y$。变量 $y$ 前面有一个全称量词 $\\forall x$。\n因此，$y$ 的存在依赖于 $x$ 的值。我们引入一个新的 Skolem 函数符号，称之为 $f$，其元数为 1。我们将变量 $y$ 的每次出现都替换为项 $f(x)$。完成此代换后，我们去掉存在量词 $\\exists y$。\n\n得到的 Skolem 化公式是：\n$$ \\forall x \\,\\forall z\\,\\bigl(P(x)\\land Q(f(x))\\land R(x,f(x),z)\\bigr) $$\n此公式只包含全称量词。\n\n**第三步：转换为子句形式（合取范式）**\n\n为了获得一组用于归结的子句，我们首先从 Skolem 化公式中去掉所有全称量词。所得的无量词母式中的变量（在此例中为 $x$ 和 $z$）被理解为在整个公式上隐式地被全称量化。\n\n去掉 $\\forall x$ 和 $\\forall z$，我们得到母式：\n$$ P(x)\\land Q(f(x))\\land R(x,f(x),z) $$\n接下来，我们必须将此母式转换为合取范式（CNF）。如果一个公式是一个或多个子句的合取，那么它就处于 CNF 中，其中每个子句是文字（原子公式或其否定）的析取。\n\n母式 $P(x)\\land Q(f(x))\\land R(x,f(x),z)$ 已经是三个原子公式的合取：$P(x)$、$Q(f(x))$ 和 $R(x,f(x),z)$。一个原子公式是一个正文字。单个文字的析取是一个子句。因此，该母式已经处于 CNF 中。\n\n子句集由合取项集合构成。这些合取项是：\n1. $P(x)$\n2. $Q(f(x))$\n3. $R(x,f(x),z)$\n\n它们对应于以下三个子句，其中每个子句是文字的集合（在这里，每个子句只包含一个文字）：\n*   子句 1: $\\{P(x)\\}$\n*   子句 2: $\\{Q(f(x))\\}$\n*   子句 3: $\\{R(x,f(x),z)\\}$\n\n问题要求在适当的情况下确保变量的标准化分离（standardization apart）。这意味着变量对于每个子句都是局部的。对于归结，我们会将 $P(x)$ 中的 $x$ 与 $Q(f(x))$ 和 $R(x,f(x),z)$ 中的 $x$ 视为不同的变量。这一点通过子句集的定义得到了隐式处理，即可以为每个子句系统地重命名变量名而不改变其逻辑含义。然而，任务是计算转换过程本身产生的子句数量，这与后续为归结步骤进行的任何重命名无关。最终的子句集包含三个语法上不同的子句。\n\n**第四步：计算不同子句的数量**\n\n从原公式派生出的子句集是 $\\{P(x), Q(f(x)), R(x,f(x),z)\\}$。这个集合的元素是上面列出的三个子句。它们是不同的，因为它们由不同的谓词符号或不同的参数组成。\n因此，所得集合中不同子句的数量是 $3$。", "answer": "$$\\boxed{3}$$", "id": "2982796"}]}