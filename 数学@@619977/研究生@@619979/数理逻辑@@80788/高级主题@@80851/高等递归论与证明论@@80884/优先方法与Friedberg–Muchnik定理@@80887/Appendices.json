{"hands_on_practices": [{"introduction": "要真正掌握优先方法中需求、约束和伤害之间的动态相互作用，最好的方法莫过于亲手模拟一次构造过程。本练习 [@problem_id:2986940] 提供了一个具体的场景，使用简化的图灵泛函，引导你逐步完成 Friedberg–Muchnik 构造的前几个阶段。通过这个过程，你将亲眼观察到需求之间的冲突是如何产生的，以及优先次序规则是如何解决这些冲突的，从而为理解更复杂的论证打下坚实的基础。", "problem": "考虑经典的 Friedberg–Muchnik 构造，用于构建两个不可比的递归可枚举 (r.e.) 集合，我们仅关注两个最低优先级的对角化需求 $R_{0}^{A}$ 和 $R_{0}^{B}$。在本问题中，我们固定一个图灵泛函 $\\left(\\Phi_{e}\\right)_{e \\in \\mathbb{N}}$ 的具体枚举如下，其中 $\\Phi_{e}^{X}$ 表示作用于神谕 $X$ 的第 $e$ 个部分泛函：\n\n1. $\\Phi_{0}^{X}(y)$: 输入为 $y$ 时，查询 $X(0), X(1), \\ldots, X(y)$ 并输出 $X(y)$。其用量为 $u_{0}(y) = y$。\n2. $\\Phi_{1}^{X}(y)$: 输入为 $y$ 时，查询 $X(0), X(1), \\ldots, X(y)$ 并输出 $\\left(\\sum_{i=0}^{y} X(i)\\right) \\bmod 2$。其用量为 $u_{1}(y) = y$。\n\n在对角化需求中，$R_{0}^{B}$ 试图确保 $\\Phi_{0}^{B} \\neq A$ (特征函数逐点不等)，而 $R_{0}^{A}$ 试图确保 $\\Phi_{1}^{A} \\neq B$。为了使阶段模拟具体化，并揭示约束和伤害的机制，假设 $R_{0}^{B}$ 和 $R_{0}^{A}$ 都旨在通过在无穷多个输入上强制产生分歧来满足其需求的更强版本，即在各自的每个阶段选择大于当前已知约束的最小新鲜见证 (witness)。\n\n采用以下阶段安排和优先级规则：\n\n- 优先级顺序: $R_{0}^{B} \\succ R_{0}^{A}$。\n- 阶段 $s \\in \\mathbb{N}$ 按照需求交替进行：如果 $s$ 是偶数，则为 $R_{0}^{B}$ 行动；如果 $s$ 是奇数，则为 $R_{0}^{A}$ 行动。\n- 在其阶段，$R_{0}^{B}$ 选择一个尚未被 $R_{0}^{B}$ 使用过的最小新鲜 $y$，并试图通过必要时将 $y$ 枚举进 $A$ 来满足 $\\Phi_{0}^{B}(y) \\neq A(y)$。然后，它设置或更新其对 $B$ 的约束为 $r_{0}^{B} := \\max\\{r_{0}^{B}, u_{0}(y)\\}$。\n- 在其阶段，$R_{0}^{A}$ 选择一个严格大于当前约束 $r_{0}^{B}$ 的最小新鲜 $y$，并试图通过必要时将 $y$ 枚举进 $B$ 来满足 $\\Phi_{1}^{A}(y) \\neq B(y)$。然后，它设置或更新其对 $A$ 的约束为 $r_{0}^{A} := \\max\\{r_{0}^{A}, u_{1}(y)\\}$。\n- 低优先级动作必须尊重高优先级约束：$R_{0}^{A}$ 绝不会将满足 $z \\leq r_{0}^{B}$ 的 $z$ 枚举进 $B$。同样，任何改变满足 $z \\leq r_{0}^{A}$ 的 $A(z)$ 值的动作都会对 $R_{0}^{A}$ 的当前计算构成一次伤害；任何改变满足 $z \\leq r_{0}^{B}$ 的 $B(z)$ 值的动作都会对 $R_{0}^{B}$ 的当前计算构成一次伤害。对于这个双需求模拟，只有 $R_{0}^{B}$ 的动作可以伤害 $R_{0}^{A}$，因为 $R_{0}^{B}$ 具有更高的优先级。\n\n在阶段 $s = 0$ 进行初始化，设定 $A = \\emptyset$, $B = \\emptyset$, $r_{0}^{B} = -1$ 以及 $r_{0}^{A} = -1$。对于阶段 $s = 0, 1, 2, 3, 4, 5$，严格按照上述规定执行构造过程，跟踪计算、用量、约束以及是否发生伤害。\n\n问题：令 $I_{0}^{A}$ 为到阶段 $s=5$ 结束时 $R_{0}^{A}$ 遭受的总伤害次数，令 $I_{0}^{B}$ 为到阶段 $s=5$ 结束时 $R_{0}^{B}$ 遭受的总伤害次数。计算行矩阵 $\\begin{pmatrix} I_{0}^{A} & I_{0}^{B} \\end{pmatrix}$。", "solution": "问题要求对一个简化的 Friedberg-Muchnik 构造的前六个阶段 ($s=0, \\ldots, 5$)进行详细模拟，该构造用于生成两个递归可枚举集 $A$ 和 $B$。我们必须跟踪构造的状态——集合 $A$ 和 $B$、约束 $r_{0}^{A}$ 和 $r_{0}^{B}$、以及每个需求所受的伤害次数——以确定总伤害次数 $I_{0}^{A}$ 和 $I_{0}^{B}$。\n\n我们给定两个需求：\n1.  $R_{0}^{B}: \\Phi_{0}^{B} \\neq A$，其优先级高于 $R_{0}^{A}$。\n2.  $R_{0}^{A}: \\Phi_{1}^{A} \\neq B$。\n\n图灵泛函定义如下：\n- $\\Phi_{0}^{X}(y) = X(y)$，用量为 $u_{0}(y) = y$。\n- $\\Phi_{1}^{X}(y) = \\left(\\sum_{i=0}^{y} X(i)\\right) \\bmod 2$，用量为 $u_{1}(y) = y$。\n\n如果另一个需求的神谕集在小于或等于需求 $R_0^Q$ 所设定的约束的输入上被修改，那么需求 $R_{0}^{Q}$ (其中 $Q \\in \\{A, B\\}$)就会受到一次伤害。具体来说：\n- 如果对于某个 $z \\leq r_{0}^{A}$，$A(z)$ 发生改变，则 $R_{0}^{A}$ 受到一次伤害。\n- 如果对于某个 $z \\leq r_{0}^{B}$，$B(z)$ 发生改变，则 $R_{0}^{B}$ 受到一次伤害。\n\n低优先级需求 $R_{0}^{A}$ 必须尊重高优先级需求 $R_{0}^{B}$ 的约束。因此，$R_{0}^{A}$ 永远不能将一个数 $z \\leq r_{0}^{B}$ 枚举到 $B$ 中。这意味着 $R_{0}^{A}$ 永远不会伤害 $R_{0}^{B}$。因此，我们可以立即得出结论 $I_{0}^{B} = 0$。我们将在模拟过程中验证这一点。\n\n阶段 $s=0$ 开始时的初始状态为：\n- $A_0 = \\emptyset$ (特征函数处处为 0)\n- $B_0 = \\emptyset$ (特征函数处处为 0)\n- $r_{0,0}^{A} = -1$\n- $r_{0,0}^{B} = -1$\n- $I_{0}^{A} = 0$, $I_{0}^{B} = 0$\n- $W_A = \\emptyset$, $W_B = \\emptyset$ (每个需求已使用的见证集合)\n\n我们逐个阶段进行。对于任何集合 $S$，我们将其在阶段 $s$ 开始时的状态表示为 $S_s$。\n\n**阶段 $s=0$ ($R_{0}^{B}$ 的行动)**\n- $R_{0}^{B}$ 行动。它选择一个尚未使用的最小新鲜见证 $y$。最小的此类 $y$ 是 $0$。\n- 我们检查是否 $\\Phi_{0}^{B_0}(0) \\neq A_0(0)$。\n- $\\Phi_{0}^{B_0}(0) = B_0(0) = 0$。\n- $A_0(0) = 0$。\n- 由于 $\\Phi_{0}^{B_0}(0) = A_0(0)$，$R_{0}^{B}$ 采取行动以制造分歧。它将 $0$ 枚举到 $A$ 中。得到的集合是 $A_1 = \\{0\\}$。\n- 如果我们改变了某个 $z \\leq r_{0,0}^{A}$ 的 $A(z)$，就会对 $R_{0}^{A}$ 造成一次伤害。这里，$z=0$ 且 $r_{0,0}^{A} = -1$。由于 $0 \\not\\leq -1$，没有发生伤害。\n- $R_{0}^{B}$ 更新其约束：$r_{0,1}^{B} = \\max(r_{0,0}^{B}, u_{0}(0)) = \\max(-1, 0) = 0$。\n- 阶段 0 结束时的状态：$A_1 = \\{0\\}$，$B_1 = \\emptyset$，$r_{0,1}^{A} = -1$，$r_{0,1}^{B} = 0$，$I_{0}^{A} = 0$，$I_{0}^{B} = 0$。\n\n**阶段 $s=1$ ($R_{0}^{A}$ 的行动)**\n- $R_{0}^{A}$ 行动。它选择满足 $y > r_{0,1}^{B}$ 的最小新鲜见证 $y$。当前约束为 $r_{0,1}^{B} = 0$。$R_0^A$ 的大于 $0$ 的最小新鲜见证是 $y=1$。\n- 我们检查是否 $\\Phi_{1}^{A_1}(1) \\neq B_1(1)$。\n- $\\Phi_{1}^{A_1}(1) = (A_1(0) + A_1(1)) \\bmod 2 = (1 + 0) \\bmod 2 = 1$。\n- $B_1(1) = 0$。\n- 由于 $\\Phi_{1}^{A_1}(1) \\neq B_1(1)$，对于这个见证，需求已经满足。不采取任何行动。\n- $R_{0}^{A}$ 更新其约束：$r_{0,2}^{A} = \\max(r_{0,1}^{A}, u_{1}(1)) = \\max(-1, 1) = 1$。\n- 阶段 1 结束时的状态：$A_2 = \\{0\\}$，$B_2 = \\emptyset$，$r_{0,2}^{A} = 1$，$r_{0,2}^{B} = 0$，$I_{0}^{A} = 0$，$I_{0}^{B} = 0$。\n\n**阶段 $s=2$ ($R_{0}^{B}$ 的行动)**\n- $R_{0}^{B}$ 行动。它选择最小的新鲜见证，即 $y=1$。\n- 我们检查是否 $\\Phi_{0}^{B_2}(1) \\neq A_2(1)$。\n- $\\Phi_{0}^{B_2}(1) = B_2(1) = 0$。\n- $A_2(1) = 0$。\n- 由于 $\\Phi_{0}^{B_2}(1) = A_2(1)$，$R_{0}^{B}$ 采取行动，将 $1$ 枚举到 $A$ 中。得到的集合是 $A_3 = \\{0, 1\\}$。\n- 我们检查是否对 $R_{0}^{A}$ 造成了伤害。我们改变了 $A(1)$。$R_{0}^{A}$ 的当前约束是 $r_{0,2}^{A} = 1$。由于 $1 \\leq r_{0,2}^{A}$，**发生一次伤害**。我们将伤害计数器增加：$I_{0}^{A} = 1$。一次伤害会使建立该约束的计算失效，因此 $r_0^A$ 被重置为其初始值 $-1$。\n- $R_{0}^{B}$ 更新其约束：$r_{0,3}^{B} = \\max(r_{0,2}^{B}, u_{0}(1)) = \\max(0, 1) = 1$。\n- 阶段 2 结束时的状态：$A_3 = \\{0, 1\\}$，$B_3 = \\emptyset$，$r_{0,3}^{A} = -1$ (已重置)，$r_{0,3}^{B} = 1$，$I_{0}^{A} = 1$，$I_{0}^{B} = 0$。\n\n**阶段 $s=3$ ($R_{0}^{A}$ 的行动)**\n- $R_{0}^{A}$ 行动。它选择满足 $y > r_{0,3}^{B}$ 的最小新鲜见证 $y$。约束为 $r_{0,3}^{B} = 1$。大于 $1$ 的最小新鲜见证是 $y=2$。\n- 我们检查是否 $\\Phi_{1}^{A_3}(2) \\neq B_3(2)$。\n- $\\Phi_{1}^{A_3}(2) = (A_3(0) + A_3(1) + A_3(2)) \\bmod 2 = (1 + 1 + 0) \\bmod 2 = 0$。\n- $B_3(2) = 0$。\n- 由于 $\\Phi_{1}^{A_3}(2) = B_3(2)$，$R_{0}^{A}$ 采取行动。它必须尊重 $r_{0,3}^{B}=1$，所以它只能将大于 1 的位置 $z$ 枚举到 $B$ 中。它将 $2$ 枚举到 $B$ 中。得到的集合是 $B_4 = \\{2\\}$。\n- 我们检查是否对 $R_{0}^{B}$ 造成了伤害。我们改变了 $B(2)$。约束是 $r_{0,3}^{B} = 1$。由于 $2 \\not\\leq 1$，没有发生伤害。\n- $R_{0}^{A}$ 更新其约束：$r_{0,4}^{A} = \\max(r_{0,3}^{A}, u_{1}(2)) = \\max(-1, 2) = 2$。\n- 阶段 3 结束时的状态：$A_4 = \\{0, 1\\}$，$B_4 = \\{2\\}$，$r_{0,4}^{A} = 2$，$r_{0,4}^{B} = 1$，$I_{0}^{A} = 1$，$I_{0}^{B} = 0$。\n\n**阶段 $s=4$ ($R_{0}^{B}$ 的行动)**\n- $R_{0}^{B}$ 行动。它选择最小的新鲜见证，即 $y=2$。\n- 我们检查是否 $\\Phi_{0}^{B_4}(2) \\neq A_4(2)$。\n- $\\Phi_{0}^{B_4}(2) = B_4(2) = 1$。\n- $A_4(2) = 0$。\n- 由于 $\\Phi_{0}^{B_4}(2) \\neq A_4(2)$，需求已经满足。不采取任何行动。\n- $R_{0}^{B}$ 更新其约束：$r_{0,5}^{B} = \\max(r_{0,4}^{B}, u_{0}(2)) = \\max(1, 2) = 2$。\n- 阶段 4 结束时的状态：$A_5 = \\{0, 1\\}$，$B_5 = \\{2\\}$，$r_{0,5}^{A} = 2$，$r_{0,5}^{B} = 2$，$I_{0}^{A} = 1$，$I_{0}^{B} = 0$。\n\n**阶段 $s=5$ ($R_{0}^{A}$ 的行动)**\n- $R_{0}^{A}$ 行动。它选择满足 $y > r_{0,5}^{B}$ 的最小新鲜见证 $y$。约束为 $r_{0,5}^{B}=2$。大于 $2$ 的最小新鲜见证是 $y=3$。\n- 我们检查是否 $\\Phi_{1}^{A_5}(3) \\neq B_5(3)$。\n- $\\Phi_{1}^{A_5}(3) = (A_5(0) + A_5(1) + A_5(2) + A_5(3)) \\bmod 2 = (1 + 1 + 0 + 0) \\bmod 2 = 0$。\n- $B_5(3) = 0$。\n- 由于 $\\Phi_{1}^{A_5}(3) = B_5(3)$，$R_{0}^{A}$ 采取行动。它必须尊重 $r_{0,5}^{B}=2$。它将 $3$ 枚举到 $B$ 中。得到的集合是 $B_6 = \\{2, 3\\}$。\n- 我们检查是否对 $R_{0}^{B}$ 造成了伤害。我们改变了 $B(3)$。约束是 $r_{0,5}^{B} = 2$。由于 $3 \\not\\leq 2$，没有发生伤害。\n- $R_{0}^{A}$ 更新其约束：$r_{0,6}^{A} = \\max(r_{0,5}^{A}, u_{1}(3)) = \\max(2, 3) = 3$。\n- 阶段 5 结束时的状态：$A_6 = \\{0, 1\\}$，$B_6 = \\{2, 3\\}$，$r_{0,6}^{A} = 3$，$r_{0,6}^{B} = 2$，$I_{0}^{A} = 1$，$I_{0}^{B} = 0$。\n\n在模拟完阶段 $s=0$ 到 $s=5$ 后，$R_{0}^{A}$ 遭受的总伤害次数为 $I_{0}^{A} = 1$，$R_{0}^{B}$ 遭受的总伤害次数为 $I_{0}^{B} = 0$。\n\n问题要求计算行矩阵 $\\begin{pmatrix} I_{0}^{A} & I_{0}^{B} \\end{pmatrix}$。结果是 $\\begin{pmatrix} 1 & 0 \\end{pmatrix}$。", "answer": "$$\\boxed{\\begin{pmatrix} 1 & 0 \\end{pmatrix}}$$", "id": "2986940"}, {"introduction": "在分阶段的构造中，每一阶段的决策都至关重要。本练习 [@problem_id:2986970] 将视角从宏观的构造流程拉近到单一阶段的微观决策上，要求你扮演算法本身的角色。你将面对一个包含有效约束和用度界限的“快照”，并需要根据严格的伤害避免规则来判断一个提议的行动是否安全，这能够锐化你在实际论证中应用核心优先原则的能力。", "problem": "考虑一个用于证明 Friedberg–Muchnik 定理的有限伤害优先构造，该定理断言存在两个图灵度不可比的计算机可枚举（c.e.）集。该构造通过满足以下形式的需求来进行：$$R_{e}:\\ A \\neq \\Phi_{e}^{B} \\quad \\text{and} \\quad S_{e}:\\ B \\neq \\Psi_{e}^{A},$$ 其中 $\\Phi_{e}$ 和 $\\Psi_{e}$ 是图灵泛函，而 $\\Phi_{e}^{B}$ 和 $\\Psi_{e}^{A}$ 分别表示使用 $B$ 和 $A$ 作为谕示的计算。需求 $R_{e}$ 通过在某个见证数 $x$ 上确保一个不一致点来满足；为保护更高优先级的计算，每个更高优先级的策略会维持数值约束和保留使用界。\n\n在当前阶段 $s$，假设以下更高优先级的保护性参数是活跃的：\n- 对 $A$ 的约束为 $$r_{A} = 30.$$\n- 对 $B$ 的约束为 $$r_{B} = 22.$$\n- 涉及 $A$ 的保留使用界为 $$u_{A}^{\\mathrm{HP}} = 28.$$\n- 涉及 $B$ 的保留使用界为 $$u_{B}^{\\mathrm{HP}} = 19.$$\n\n您正在处理需求 $R_{2}$，其当前见证数为 $$x = 10,$$ 并且您已观察到计算 $$\\Phi_{2}^{B}(x)$$ 在阶段 $s$ 收敛，其仅使用了对 $B$ 的谕示查询，且查询值低于界限 $$u_{B}^{(2)} = 21.$$ 您正在考虑两个提议的行动：\n- 对 $A$ 的提议：将数 $$a_{A} = 27$$ 枚举到 $A$ 中。\n- 对 $B$ 的提议：将数 $$b_{B} = 20$$ 枚举到 $B$ 中。\n\n在此构造中，如果一个较低优先级的行动将数 $n$ 枚举到集合 $S \\in \\{A, B\\}$ 中，而 $n$ 并非严格大于对 $S$ 的每个活跃约束和相关使用界，则该行动会伤害一个受保护的计算或约束。也就是说，为避免伤害，将 $n$ 枚举到 $S$ 的操作必须满足 $$n > r_{S} \\quad \\text{and} \\quad n > u_{S}^{\\mathrm{HP}}.$$\n\n仅使用给定的参数和此伤害避免规则，判断每个提议的行动是否会伤害更高优先级的需求。然后，计算最小的自然数 $$n_{A}$$，使得在阶段 $s$ 将 $$n_{A}$$ 枚举到 $A$ 中可以避免不必要的伤害，同时仍然允许您通过在当前阶段对 $$\\Phi_{2}^{B}(x)$$ 进行对角化来满足 $R_{2}$。您的最终答案必须是单个数字 $$n_{A}.$$", "solution": "我们首先回顾用于 Friedberg–Muchnik 定理的优先构造的基本设置。我们的目标是构造两个计算机可枚举（c.e.）集 $A$ 和 $B$，以满足需求 $$R_{e}:\\ A \\neq \\Phi_{e}^{B} \\quad \\text{and} \\quad S_{e}:\\ B \\neq \\Psi_{e}^{A}.$$ 在任何阶段 $s$，更高优先级的策略通过施加约束 $r_{A}$ 和 $r_{B}$ 以及维持保留使用界 $u_{A}^{\\mathrm{HP}}$ 和 $u_{B}^{\\mathrm{HP}}$ 来确保某些计算的保留。较低优先级的策略必须在不违反这些约束或使用的前提下行动。具体来说，仅当 $$n > r_{S} \\quad \\text{and} \\quad n > u_{S}^{\\mathrm{HP}}$$ 时，将数 $n$ 枚举到 $S \\in \\{A,B\\}$ 中才是安全的。这保证了读取低于使用界的谕示位的受保护计算不受干扰，也没有约束被违反。\n\n在阶段 $s$，给定的参数是：\n- 对于集合 $A$，$r_{A} = 30$ 且 $u_{A}^{\\mathrm{HP}} = 28$，\n- 对于集合 $B$，$r_{B} = 22$ 且 $u_{B}^{\\mathrm{HP}} = 19$，\n- 目标需求是 $R_{2}$，见证数为 $x = 10$，并且当前计算 $\\Phi_{2}^{B}(x)$ 收敛，其使用的 $B$ 的谕示位严格小于 $u_{B}^{(2)} = 21$。\n\n我们首先评估两个提议行动的安全性。\n\n1. 对 $A$ 的提议：将 $a_{A} = 27$ 枚举到 $A$ 中。\n   为保证安全，我们需要 $$a_{A} > r_{A} \\quad \\text{and} \\quad a_{A} > u_{A}^{\\mathrm{HP}}.$$ 代入给定值，我们检验 $$27 > 30 \\quad \\text{and} \\quad 27 > 28.$$ 两个不等式都不成立。因此，将 $27$ 枚举到 $A$ 中会违反对 $A$ 的约束，并伤害一个依赖于低于使用界 $u_{A}^{\\mathrm{HP}}$ 的 $A$ 的保留计算。\n\n2. 对 $B$ 的提议：将 $b_{B} = 20$ 枚举到 $B$ 中。\n   为保证安全，我们需要 $$b_{B} > r_{B} \\quad \\text{and} \\quad b_{B} > u_{B}^{\\mathrm{HP}}.$$ 代入给定值，我们检验 $$20 > 22 \\quad \\text{and} \\quad 20 > 19.$$ 第一个不等式不成立，而第二个成立。因此，将 $20$ 枚举到 $B$ 中会违反对 $B$ 的约束，从而伤害一个保护 $B$ 中小于 $22$ 部分的更高优先级需求。\n\n两个提议的行动都会伤害更高优先级的保护。\n\n接下来，我们计算最小的数 $n_{A}$，使得将 $n_{A}$ 枚举到 $A$ 中可以避免伤害。根据伤害避免规则，$n_{A}$ 必须满足 $$n_{A} > r_{A} \\quad \\text{and} \\quad n_{A} > u_{A}^{\\mathrm{HP}}.$$ 由于 $r_{A} = 30$ 和 $u_{A}^{\\mathrm{HP}} = 28$，严格不等式意味着 $$n_{A} > \\max\\{30, 28\\} = 30.$$ 因此，满足这两个约束的最小自然数是 $$n_{A} = 31.$$\n\n最后，我们验证用 $n_{A} = 31$ 对 $A$ 进行操作是否适合在当前阶段满足 $R_{2}$。需求 $R_{2}$ 旨在对 $\\Phi_{2}^{B}(x)$ 进行对角化。由于我们已观察到 $\\Phi_{2}^{B}(x)$ 在使用界为 $u_{B}^{(2)} = 21$ 时收敛，在 $31$ 处更改 $A$ 不会影响谕示 $B$，因此不会干扰该计算。此外，因为 $31$ 超过了 $r_{A}$ 和 $u_{A}^{\\mathrm{HP}}$，所以没有涉及 $A$ 的受保护计算受到伤害。因此，将 $31$ 枚举到 $A$ 中避免了不必要的伤害，并允许满足 $R_{2}$。\n\n因此，最安全的最小选择是 $$n_{A} = 31.$$", "answer": "$$\\boxed{31}$$", "id": "2986970"}, {"introduction": "优先方法的一个强大之处在于其通用性，它不仅能用于构造不可比集，还能同时满足其他性质，如“低度”（lowness）。本练习 [@problem_id:2986957] 提出了一个典型的、更为复杂的场景：一个试图枚举元素的“正”需求与一个试图保留预言机初始段（即强制施加一个约束）的“负”需求发生了冲突。解决这个看似棘手的问题，能够检验你是否深刻理解了优先级的核心原则——即更高优先级的需求如何强制约束低优先级需求的行动，从而确保所有需求最终都能在有限伤害的前提下得到满足。", "problem": "考虑构造两个可计算可枚举 (c.e.) 集 $A$ 和 $B$，旨在满足 Friedberg–Muchnik 定理的不可比性需求，即对于每个指标 $e \\in \\mathbb{N}$：\n- $R_e$：确保 $\\Phi_e^A \\neq B$，使得 $B \\nleq_T A$；对称地，\n- $S_e$：确保 $\\Psi_e^B \\neq A$，使得 $A \\nleq_T B$。\n其中 $\\Phi_e$ 和 $\\Psi_e$ 遍历一个图灵泛函的标准枚举，而 $\\leq_T$ 表示图灵可归约性。\n\n此外，假设我们为 $A$ 加入低性需求以确保 $A$ 是低集，即 $A' \\leq_T \\emptyset'$，其中 $A'$ 是 $A$ 的图灵跳跃，$\\emptyset'$ 是停机问题。一个典型的低性需求 $L_i^A$ 通过在阶段 $s$ 维持一个非递减的限制函数 $r_i^A(s)$ 来对 $A$ 施加限制，该函数禁止对 $A$ 在 $r_i^A(s)$ 以下的部分进行修改，从而保留为证成 $A' \\leq_T \\emptyset'$ 所需的某些计算。\n\n假设采用一种有限伤害优先排序（Finite Injury Priority Method (FIPM)），其中低性需求 $\\{L_i^A : i \\in \\mathbb{N}\\}$ 和不可比性需求 $\\{R_j, S_j : j \\in \\mathbb{N}\\}$ 交错排列在一个优先级随指标递增而递减的列表中。考虑相邻的优先级，其中 $L_p^A$ 的优先级紧邻于 $R_{p+1}$ 之上。假设当前阶段 $s$ 出现了以下冲突：$R_{p+1}$ 的策略识别出一个见证元 $x$，满足 $x < r_p^A(s)$，如果将 $x$ 枚举进 $A$，将会对作为从 $A$ 到 $B$ 的一个声称的归约 $\\Phi_{p+1}^A$ 进行对角化，但这次枚举会违反由 $L_p^A$ 施加的限制。\n\n以下哪种解决方案能在有限伤害的情况下，既保持 $A$ 的低性结果，又保持 $R_{p+1}$ 的不可比性结果？\n\nA. 允许 $R_{p+1}$ 不顾当前的限制 $r_p^A(s)$ 将 $x$ 枚举进 $A$，并在 $L_p^A$ 每当受到伤害时对其进行重新初始化，相信 $L_p^A$ 最终会重新建立一个稳定的限制。\n\nB. 要求 $R_{p+1}$ 遵守限制 $r_p^A(s)$，方法是丢弃当前的见证元 $x$ 并选择一个新的见证元 $y > r_p^A(s)$，并且仅在一个允许条件满足时才行动（例如，当 $\\emptyset'$ 的一个近似表明在 $y$ 以下 $r_p^A$ 不会改变时），从而使得 $L_p^A$ 只有限次地增加其限制，并且 $R_{p+1}$ 只受到有限次伤害。\n\nC. 修改 $L_p^A$，为其限制使用一个固定的可计算界 $c$，即对所有 $s$ 设定 $r_p^A(s) = c$，这样 $R_{p+1}$ 就可以总是在 $c$ 之上行动以避免冲突。\n\nD. 交换 $L_p^A$ 和 $R_{p+1}$ 的优先级，使 $R_{p+1}$ 位于 $L_p^A$ 之上，允许 $R_{p+1}$ 在任何限制之下自由地对见证元采取行动，而 $L_p^A$ 则通过根据需要提升其限制来适应伤害。\n\n选择唯一的最佳选项，并解释在所述框架下，为何它能以有限伤害的方式确保两种结果。", "solution": "## 问题验证\n\n### 步骤 1：提取已知条件\n-   **集合与性质**：两个正在构造中的可计算可枚举 (c.e.) 集 $A$ 和 $B$。\n-   **不可比性需求**：对于每个指标 $e \\in \\mathbb{N}$：\n    -   $R_e$：$\\Phi_e^A \\neq B$（以确保 $B \\nleq_T A$）。\n    -   $S_e$：$\\Psi_e^B \\neq A$（以确保 $A \\nleq_T B$）。\n    -   $\\Phi_e, \\Psi_e$ 是图灵泛函的标准枚举；$\\leq_T$ 是图灵可归约性。\n-   **低性需求**：对于集合 $A$，它必须是“低集”，意即 $A' \\leq_T \\emptyset'$，其中 $A'$ 是 $A$ 的图灵跳跃，$\\emptyset'$ 是停机问题。\n-   **低性策略**：低性需求 $L_i^A$ 在阶段 $s$ 维持一个非递减的限制函数 $r_i^A(s)$。此函数禁止对集合 $A$ 的初始段进行修改，即没有 $x < r_i^A(s)$ 可被枚举进 $A$。\n-   **构造方法**：使用有限伤害优先法 (FIPM)。\n-   **优先排序**：需求 $\\{L_i^A : i \\in \\mathbb{N}\\}$ 和 $\\{R_j, S_j : j \\in \\mathbb{N}\\}$ 被排在一个优先级递减的单一列表中。\n-   **具体冲突场景**：\n    -   需求 $L_p^A$ 的优先级高于需求 $R_{p+1}$。\n    -   在阶段 $s$，$R_{p+1}$ 的策略识别出一个见证元 $x$ 以满足其目标。\n    -   为 $R_{p+1}$ 提议的行动是将 $x$ 枚举进 $A$。\n    -   冲突的产生是因为 $x < r_p^A(s)$，其中 $r_p^A(s)$ 是由更高优先级需求 $L_p^A$ 施加的限制。\n\n### 步骤 2：使用提取的已知条件进行验证\n-   **科学依据**：该问题是可计算性理论（数理逻辑的一个子领域）的核心内容。它描述了一种经典的优先法构造，这是由 Friedberg 和 Muchnik 建立、后由 Sacks、Yates 等人完善的一项基本技术。将不可比性需求与低性需求相结合是研究 c.e. 度结构中的一个标准且重要的课题。所使用的所有术语（c.e. 集、$\\leq_T$、跳跃、低性、优先法、限制）都定义明确，并且是该领域的核心。\n-   **问题适定**：该问题描述了优先论证中的一个典型冲突：一个低优先级的正性需求（希望枚举一个元素）与一个高优先级的负性/限制性需求（希望阻止枚举）。问题要求在 FIPM 框架内找到实现所述目标的解决方案。这样的解决方案是 FIPM 设计的标准组成部分。\n-   **客观性**：问题以精确、形式化的语言陈述。没有主观或含糊的术语。\n-   **缺陷评估**：\n    1.  **科学/事实不健全**：无。该设定是可计算性理论中的一个标准场景。尽管对 $R_{p+1}$ 策略（“枚举进 $A$”）的描述对于 $S_e$ 类型的需求更为典型，但它仍然是一种有效（尽管不那么常见）的方式，通过改变谕示 $A$ 来更改 $\\Phi_{p+1}^A$ 的输出来为 $R_e$ 需求进行对角化。冲突的本质与此特定策略选择无关。\n    2.  **非形式化/不相关**：问题完全可以形式化，并直接关系到优先法。\n    3.  **不完整/矛盾**：该设定足以分析冲突解决方案。优先级排序（$L_p^A > R_{p+1}$）和冲突的性质（$x < r_p^A(s)$）都已明确说明。\n    4.  **不现实/不可行**：不适用（纯数学）。\n    5.  **问题不适定/结构不良**：问题是适定的，并且在优先论证理论中有一个标准的答案。\n    6.  **伪深刻/琐碎**：问题并不琐碎；它涉及优先构造的核心机制。\n    7.  **超出科学可验证性**：问题完全在数学证明的范畴内。\n\n### 步骤 3：结论与行动\n问题陈述有效。我将继续进行解答。\n\n---\n\n## 解题推导\n\n该问题呈现了在一个有限伤害优先法 (FIPM) 构造中，两个需求 $L_p^A$ 和 $R_{p+1}$ 之间的冲突。相对优先级已给出：$L_p^A$ 的优先级高于 $R_{p+1}$。冲突在于，低优先级需求 $R_{p+1}$ 希望采取一个行动（将 $x$ 枚举进 $A$），而这个行动被高优先级需求 $L_p^A$ 施加的限制 $r_p^A(s)$ 所禁止。\n\n任何优先法的基本原则是高优先级需求优先。一个需求 $K_e$ 所采取的行动只能在 $e < j$（即 $K_e$ 具有更高优先级）的情况下“伤害”一个需求 $K_j$。低优先级需求绝不允许伤害高优先级需求。违反这条规则会破坏“每个需求都被顾及并最终得到满足”的归纳证明。\n\n在我们的具体场景中：\n-   $L_p^A$ 是一个“低性”需求。其策略涉及施加一个限制 $r_p^A(s)$ 来保留某些计算。为了使低性性质 ($A' \\leq_T \\emptyset'$) 成立，关键在于对于每个 $i$，限制函数 $r_i^A(s)$ 必须最终稳定，即 $\\lim_{s \\to \\infty} r_i^A(s)$ 存在且有限。这只有在 $L_p^A$ 只受到有限次伤害的情况下才能得到保证。由于伤害只来自更高优先级的需求，并且比 $L_p^A$ 优先级更高的需求数量有限，因此 FIPM 框架能确保这一点，前提是 $L_p^A$ 不被任何像 $R_{p+1}$ 这样的低优先级需求所伤害。\n-   $R_{p+1}$ 是一个“正性”不可比性需求。它通过将元素枚举到其中一个集合（在此例中是 $A$）来满足。为了构造成功，$R_{p+1}$ 必须最终能够在需要时采取行动。\n\n该解决方案必须满足两个条件：\n1.  它必须保留 $L_p^A$ 的策略，确保它不被 $R_{p+1}$ 伤害。这意味着 $R_{p+1}$ 必须遵守限制 $r_p^A(s)$。\n2.  它必须允许 $R_{p+1}$ 最终成功。\n\n满足这两个条件的唯一方法是让 $R_{p+1}$ 的策略“有耐心”。当发现其见证元 $x$ 受限时（即 $x < r_p^A(s)$），$R_{p+1}$ 的策略必须不采取行动。相反，它必须等待。由于特定的见证元 $x$ 不可用，该策略必须能够丢弃它并寻找一个新的见证元。$R_{p+1}$ 的一个鲁棒策略会选择一个新的、“足够大”的见证元 $y$，具体来说，要大于所有来自更高优先级需求的当前限制，包括 $r_p^A(s)$。\n\n通过 FIPM 中的归纳法，所有比 $R_{p+1}$ 优先级高的需求（包括 $L_p^A$）都只受有限次伤害。因此，它们的限制最终会稳定下来。也就是说，存在一个阶段 $s_0$ 和一个数 $R$，使得对于所有 $s > s_0$，由比 $R_{p+1}$ 优先级高的需求施加的总限制被 $R$ 所界定。在阶段 $s_0$ 之后，$R_{p+1}$ 的策略可以选择一个新见证元 $y > R$。任何这样的见证元将永远不会被更高优先级的需求所限制。这保证了 $R_{p+1}$ 最终会找到机会行动并满足其需求，而永远不会伤害 $L_p^A$。这既确保了 $A$ 的低性，也确保了 $R_{p+1}$ 的满足。\n\n## 逐项分析\n\n**A. 允许 $R_{p+1}$ 不顾当前的限制 $r_p^A(s)$ 将 $x$ 枚举进 $A$，并在 $L_p^A$ 每当受到伤害时对其进行重新初始化，相信 $L_p^A$ 最终会重新建立一个稳定的限制。**\n-   **分析**：这描述了低优先级需求 ($R_{p+1}$) 伤害高优先级需求 ($L_p^A$) 的情况。这违反了标准 FIPM 的基本规则。如果允许 $R_{p+1}$ 这样做，它可能需要无限次行动（这对于不可比性需求是可能的），从而无限次地伤害 $L_p^A$。这将导致限制 $r_p^A(s)$ 被无限次更新，使其无法稳定。限制未能稳定将导致低性策略失败。这种解决方法是无限伤害论证的特征，这类论证更为复杂，即便如此，没有其他机制的辅助，仅仅允许这样做也会失败。它与*有限伤害*构造是背道而驰的。\n-   **结论**：**不正确**。\n\n**B. 要求 $R_{p+1}$ 遵守限制 $r_p^A(s)$，方法是丢弃当前的见证元 $x$ 并选择一个新的见证元 $y > r_p^A(s)$，并且仅在一个允许条件满足时才行动（例如，当 $\\emptyset'$ 的一个近似表明在 $y$ 以下 $r_p^A$ 不会改变时），从而使得 $L_p^A$ 只有限次地增加其限制，并且 $R_{p+1}$ 只受到有限次伤害。**\n-   **分析**：这个选项正确地描述了标准的解决方案。低优先级需求 ($R_{p+1}$) 必须“遵守”高优先级需求 ($L_p^A$) 的“限制”。这意味着它不能对其见证元 $x$ 采取行动。策略必须被设计为通过寻找一个足够大、高于当前限制的新见证元 $y$ ($y > r_p^A(s)$) 来处理这种情况。这确保了 $L_p^A$ 不被 $R_{p+1}$ 伤害。由于 $L_p^A$ 只被有限多个更高优先级的需求伤害，其限制最终会稳定下来。一旦稳定，$R_{p+1}$ 就可以选择一个足够大的见证元，使其永久不受 $L_p^A$ 和其他更高优先级需求的干扰。这使得两个需求都能成功。关于 $\\emptyset'$ 的括号内容是一个与某些高级低性构造相关的补充说明，但它并不影响所描述核心机制的正确性。\n-   **结论**：**正确**。\n\n**C. 修改 $L_p^A$，为其限制使用一个固定的可计算界 $c$，即对所有 $s$ 设定 $r_p^A(s) = c$，这样 $R_{p+1}$ 就可以总是在 $c$ 之上行动以避免冲突。**\n-   **分析**：这不是一个可行的低性策略。由 $L_p^A$ 施加的限制旨在保护在特定跳跃计算（例如 $\\Phi_j^{A_s}(k)$）中使用的谕示的初始段。这个初始段的长度（计算的“用途”）无法预先知道，也不是可计算有界的。它取决于指标 $j$ 和谕示 $A_s$ 的状态。任何固定的可计算界 $c$ 都是不够的，因为需要保护的计算可能有一个远大于 $c$ 的用途。如果限制固定为 $c$，一个低优先级的需求可以在 $c$ 和真实用途之间枚举一个元素，从而改变计算并破坏低性性质。在此类构造中，限制必须是动态的。\n-   **结论**：**不正确**。\n\n**D. 交换 $L_p^A$ 和 $R_{p+1}$ 的优先级，使 $R_{p+1}$ 位于 $L_p^A$ 之上，允许 $R_{p+1}$ 在任何限制之下自由地对见证元采取行动，而 $L_p^A$ 则通过根据需要提升其限制来适应伤害。**\n-   **分析**：这个选项提议改变优先级排序，这是对问题前提的修改，而不是在给定框架内的解决方案。此外，这种改变对整个构造都是有害的。将像 $R_{p+1}$ 这样的正性需求置于像 $L_p^A$ 这样的基于限制的需求之上是危险的。如选项 A 的分析中所述，$R_{p+1}$ 可能需要无限次行动。如果它具有更高的优先级，它将无限次伤害 $L_p^A$，阻止其限制稳定，从而注定了低性需求的失败。为使限制有效，施加限制的需求必须具有高优先级。\n-   **结论**：**不正确**。", "answer": "$$\\boxed{B}$$", "id": "2986957"}]}