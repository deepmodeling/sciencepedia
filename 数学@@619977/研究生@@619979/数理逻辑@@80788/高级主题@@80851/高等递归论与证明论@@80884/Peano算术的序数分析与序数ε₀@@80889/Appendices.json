{"hands_on_practices": [{"introduction": "古德斯坦定理（Goodstein's theorem）是数论中一个惊人的结果，它断言一个以特定方式构造的整数序列——古德斯坦序列——最终必定会达到零。然而，该定理的证明却无法在皮亚诺算术（Peano Arithmetic, PA）的框架内完成，需要借助直到序数 $\\varepsilon_0$ 的超限归纳法。这项练习将通过一个具体的计算实例，让您亲身体验一个看似简单的整数序列如何隐藏着与超限序数的深刻联系，从而为序数分析提供一个直观且富有启发性的切入点。[@problem_id:2978410]", "problem": "请考虑下述古德斯坦过程（Goodstein process）及其序数解释，它们是通过序数 $\\varepsilon_{0}$ 对皮亚诺算术（Peano Arithmetic）进行序数分析的标准工具。\n\n定义与设置：\n- 对于每个基数 $b \\geq 2$，自然数 $n$ 的遗传 $b$ 进制表示（hereditary base-$b$ representation）$H_{b}(n)$ 是通过以下方式获得的：首先将 $n$ 写成基数为 $b$ 的有限和 $\\sum_{i} c_{i} b^{e_{i}}$，其中系数 $0 \\leq c_{i}  b$，然后递归地将每个指数 $e_{i}$ 写成遗传 $b$ 进制形式。\n- 给定一个遗传 $b$ 进制项，其序数解释 $\\Phi(H_{b}(n))$ 的定义是：将每一次出现的 $b$ 替换为第一个无限序数 $\\omega$，将加法和乘法解释为序数运算，将指数解释为序数乘方。其结果是一个小于 $\\varepsilon_{0}$ 且符合康托尔范式（Cantor normal form）的序数。\n- 定义基数函数为 $b(k) \\coloneqq k+2$ 的古德斯坦序列（Goodstein sequence）$(G(k))_{k \\in \\mathbb{N}}$ 如下：\n  1. 通过其遗传 2 进制表示来确定 $G(0)$\n     $$H_{2}(G(0)) \\;=\\; 2^{2^{1}} \\;+\\; 2^{2^{1}} \\;+\\; 1.$$\n     等价地，其数值为 $G(0)=9$。\n  2. 对于每个 $k \\geq 0$，$G(k+1)$ 的获得方式是：首先在 $H_{b(k)}(G(k))$ 中将每个 $b(k)$ 替换为 $b(k+1)$，将其作为自然数求值，然后减去 $1$。\n- 对每个 $k$，定义序数测度\n  $$\\alpha_{k} \\;\\coloneqq\\; \\Phi\\!\\big(H_{b(k)}(G(k))\\big),$$\n  它是一个小于 $\\varepsilon_{0}$ 且符合康托尔范式的序数。已知 $\\alpha_{k+1}  \\alpha_{k}$。\n\n任务：\n1. 通过显式执行基数转换和减法步骤，计算 $G(1)$、$G(2)$ 和 $G(3)$，并将每个 $G(k)$ 表示为其遗传 $b(k)$ 进制形式。\n2. 对于 $k=0,1,2,3$ 中的每一个，通过在 $H_{b(k)}(G(k))$ 中将基数 $b(k)$ 替换为 $\\omega$ 来计算符合康托尔范式的 $\\alpha_{k}$。\n3. 显式验证 $\\alpha_{0}  \\alpha_{1}  \\alpha_{2}  \\alpha_{3}$ 并且所有的 $\\alpha_{k}$ 都小于 $\\varepsilon_{0}$。\n\n$\\alpha_{3}$ 的显式康托尔范式表达式是什么？请以单个闭式表达式的形式提供最终答案。无需舍入。", "solution": "该问题陈述已经过验证，被认为是自洽的、在数理逻辑上是科学严谨的，并且是适定问题。为 $G(0)$ 提供的初始表示虽然非标准，但是作为古德斯坦过程起始状态的定义，这是一种有效的问题指定方式。后续步骤也都是良定义的。\n\n问题要求的是序数 $\\alpha_3$ 的显式康托尔范式，该序数由一个类古德斯坦序列导出。我将按照任务要求，对 $k=0, 1, 2, 3$ 进行计算以推导出最终答案。步骤 $k$ 的基数是 $b(k) = k+2$。\n\n**步骤 $k=0$：**\n基数是 $b(0)=2$。初始状态由遗传 2 进制表示定义：\n$$H_{2}(G(0)) = 2^{2^{1}} + 2^{2^{1}} + 1$$\n其数值为 $G(0) = 2^{2} + 2^{2} + 1 = 4+4+1=9$。\n相应的序数 $\\alpha_0$ 是通过将基数 2 替换为 $\\omega$ 并使用序数算术解释该表达式得到的。\n$$\\alpha_0 = \\Phi(H_{2}(G(0))) = \\omega^{\\omega^{1}} + \\omega^{\\omega^{1}} + 1 = \\omega^{\\omega}2 + 1$$\n这是一个符合康托尔范式（CNF）的序数。\n\n**步骤 $k=1$：**\n基数是 $b(1) = 1+2 = 3$。为了计算 $G(1)$，我们首先在 $H_2(G(0))$ 的表达式中将基数从 2 变为 3：\n$$2^{2^{1}} + 2^{2^{1}} + 1 \\quad \\xrightarrow{\\text{base } 2 \\to 3} \\quad 3^{3^{1}} + 3^{3^{1}} + 1$$\n对这个新表达式进行数值计算，得到 $3^3 + 3^3 + 1 = 27 + 27 + 1 = 55$。\n然后，古德斯坦过程要求减去 1：\n$$G(1) = 55 - 1 = 54$$\n接下来，我们求 $G(1)=54$ 的遗传 3 进制表示。\n$$G(1) = 54 = 2 \\times 27 = 2 \\times 3^3$$\n因为指数 3 等于基数，所以它也必须用 3 进制表示：$3 = 1 \\cdot 3^1$。因此，遗传 3 进制表示为：\n$$H_{3}(G(1)) = 2 \\cdot 3^{3^{1}}$$\n相应的序数 $\\alpha_1$ 是通过应用映射 $\\Phi$ 得到的。项 $c \\cdot b^{e}$ 映射为 $\\omega^{\\Phi(e)}c$。\n$$\\alpha_1 = \\Phi(2 \\cdot 3^{3^{1}}) = \\omega^{\\Phi(3^1)}2$$\n指数的表示 $3^1$ 映射为 $\\omega^1 = \\omega$。因此：\n$$\\alpha_1 = \\omega^{\\omega}2$$\n\n**步骤 $k=2$：**\n基数是 $b(2) = 2+2 = 4$。我们取 $H_{3}(G(1)) = 2 \\cdot 3^{3^{1}}$ 并将基数从 3 变为 4：\n$$2 \\cdot 3^{3^{1}} \\quad \\xrightarrow{\\text{base } 3 \\to 4} \\quad 2 \\cdot 4^{4^{1}}$$\n对其进行数值计算得到 $2 \\cdot 4^4 = 2 \\cdot 256 = 512$。\n减去 1 得到 $G(2)$：\n$$G(2) = 512 - 1 = 511$$\n现在，我们求 $G(2)=511$ 的遗传 4 进制表示。我们可以从表达式 $2\\cdot4^4-1$ 推导出：\n$$2\\cdot4^4 - 1 = 1\\cdot4^4 + (1\\cdot4^4 - 1)$$\n使用恒等式 $b^n-1 = \\sum_{i=0}^{n-1} (b-1)b^i$，我们有 $4^4-1 = 3\\cdot4^3 + 3\\cdot4^2 + 3\\cdot4^1 + 3$。\n因此，$G(2)$ 的 4 进制表示是：\n$$G(2) = 1\\cdot4^4 + 3\\cdot4^3 + 3\\cdot4^2 + 3\\cdot4^1 + 3$$\n对于遗传表示，指数必须是 4 进制的。指数 4 写成 $1 \\cdot 4^1$。指数 3、2、1 小于基数 4，因此它们已经是正确的形式。\n$$H_{4}(G(2)) = 1 \\cdot 4^{4^{1}} + 3 \\cdot 4^3 + 3 \\cdot 4^2 + 3 \\cdot 4^1 + 3$$\n相应的序数 $\\alpha_2$ 是：\n$$\\alpha_2 = \\Phi(H_{4}(G(2))) = \\omega^{\\Phi(4^1)}1 + \\omega^{\\Phi(3)}3 + \\omega^{\\Phi(2)}3 + \\omega^{\\Phi(1)}3 + \\Phi(3)$$\n$$\\alpha_2 = \\omega^{\\omega} + \\omega^{3}3 + \\omega^{2}3 + \\omega^{1}3 + 3$$\n\n**步骤 $k=3$：**\n基数是 $b(3) = 3+2 = 5$。我们取 $H_{4}(G(2))$ 并将基数从 4 变为 5：\n$$1 \\cdot 4^{4^{1}} + 3 \\cdot 4^3 + 3 \\cdot 4^2 + 3 \\cdot 4^1 + 3 \\quad \\xrightarrow{\\text{base } 4 \\to 5} \\quad 1 \\cdot 5^{5^{1}} + 3 \\cdot 5^3 + 3 \\cdot 5^2 + 3 \\cdot 5^1 + 3$$\n数值计算：\n$$5^5 + 3\\cdot5^3 + 3\\cdot5^2 + 3\\cdot5^1 + 3 = 3125 + 3\\cdot125 + 3\\cdot25 + 3\\cdot5 + 3 = 3125 + 375 + 75 + 15 + 3 = 3593$$\n减去 1 得到 $G(3)$：\n$$G(3) = 3593 - 1 = 3592$$\n为了求得 $H_5(G(3))$，我们从 3593 的 5 进制表达式中减去 1。这只影响最后一项：\n$$H_{5}(G(3)) = 1 \\cdot 5^{5^{1}} + 3 \\cdot 5^3 + 3 \\cdot 5^2 + 3 \\cdot 5^1 + 2$$\n这已经是遗传 5 进制形式，因为所有系数都小于 5，并且指数 5 被写为 $5^1$。\n最后，我们计算序数 $\\alpha_3$，这就是问题的答案：\n$$\\alpha_3 = \\Phi(H_{5}(G(3))) = \\omega^{\\Phi(5^1)}1 + \\omega^{\\Phi(3)}3 + \\omega^{\\Phi(2)}3 + \\omega^{\\Phi(1)}3 + \\Phi(2)$$\n$$\\alpha_3 = \\omega^{\\omega} + \\omega^{3}3 + \\omega^{2}3 + \\omega^{1}3 + 2$$\n\n**验证：**\n序数序列是：\n$\\alpha_0 = \\omega^{\\omega}2 + 1$\n$\\alpha_1 = \\omega^{\\omega}2$\n$\\alpha_2 = \\omega^{\\omega} + \\omega^{3}3 + \\omega^{2}3 + \\omega 3 + 3$\n$\\alpha_3 = \\omega^{\\omega} + \\omega^{3}3 + \\omega^{2}3 + \\omega 3 + 2$\n我们可以验证 $\\alpha_0  \\alpha_1  \\alpha_2  \\alpha_3$。\n$\\alpha_1  \\alpha_0$ 因为 $\\omega^\\omega2  \\omega^\\omega2+1$。\n$\\alpha_2  \\alpha_1$ 因为 $\\alpha_1 = \\omega^\\omega + \\omega^\\omega$，而尾部 $\\omega^3 3 + \\omega^2 3 + \\omega 3 + 3$ 小于 $\\omega^\\omega$。\n$\\alpha_3  \\alpha_2$ 因为它们仅在最后一项上有所不同，其中 $2  3$。\n所有序数都小于 $\\varepsilon_0 = \\sup\\{\\omega, \\omega^\\omega, \\omega^{\\omega^\\omega}, \\dots\\}$，因为它们的最大项是 $\\omega^\\omega$。\n\n$\\alpha_3$ 的显式康托尔范式为 $\\omega^{\\omega} + \\omega^{3}3 + \\omega^{2}3 + \\omega 3 + 2$。", "answer": "$$\n\\boxed{\\omega^{\\omega} + \\omega^{3}3 + \\omega^{2}3 + \\omega 3 + 2}\n$$", "id": "2978410"}, {"introduction": "在理解了为何需要超限序数之后，我们转向根岑（Gentzen）证明其核心的证明论技术。根岑的思路是直接分析形式证明本身的结构，通过为每个证明指定一个序数，并证明其关键的“切消定理”（Cut-Elimination Theorem）过程会使该序数严格递减。这项练习将引导您深入这一核心机制：您将构造一个包含非平凡切（cut）的 PA 证明，并为其计算初始的序数权重，然后追踪切消过程如何逐步降低此序数，从而将抽象的理论转化为具体可操作的步骤。[@problem_id:2978411]", "problem": "考虑在 Gentzen 风格的一阶相继式演算中带有等号的皮亚诺算术 (PA)，其使用通常的算术语言，包含常数 $0$、用于后继的一元函数 $S(\\cdot)$ 以及二元函数符号 $+,\\times$。在由 PA 的归纳模式扩充的经典相继式演算（通常记作 LK）中进行。结构规则和逻辑规则是标准的，包括切削规则。回顾切削规则：从 $\\Gamma \\vdash \\Delta, A$ 和 $A, \\Sigma \\vdash \\Pi$，可推断出 $\\Gamma, \\Sigma \\vdash \\Delta, \\Pi$。我们将通过为证明赋予小于艾普西隆数 $\\varepsilon_{0}$ 的序数来追踪切削消除过程，使得每一步局部的切削削减都严格减小所赋予的序数。\n\n使用以下基本定义。\n\n- 通过递归定义公式 $A$ 的逻辑阶 $r(A)$：对于原子公式 $A$ (包括 $t=s$)，$r(A)=0$；对于 $A \\vee B$ 或 $A \\wedge B$，$r(A \\circ B)=\\max\\{r(A),r(B)\\}$；对于 $A \\rightarrow B$，$r(A \\rightarrow B)=\\max\\{r(A),r(B)\\}$；对于 $\\forall x\\,A$ 或 $\\exists x\\,A$，$r(Qx\\,A)=r(A)+1$。\n- 通过逻辑符号的数量定义公式 $A$ 的逻辑大小 $s(A)$：对于原子公式 $A$，$s(A)=0$；对于 $A \\vee B$，$s(A \\vee B)=s(A)+s(B)+1$；对于 $A \\wedge B$ 和 $A \\rightarrow B$ 类似；对于 $Qx\\,A$ 其中 $Q\\in\\{\\forall,\\exists\\}$，$s(Qx\\,A)=s(A)+1$。\n- 对于一个包含切削的证明 $\\mathcal{P}$，定义其初始序数权重\n$$\nW(\\mathcal{P}) \\;=\\; \\sum_{A \\in \\mathsf{Cuts}(\\mathcal{P})} \\omega^{r(A)} \\cdot s(A),\n$$\n其中该和以康托尔范式计算，$\\omega$ 是第一个无穷序数。在本任务中，请忽略来自非切削推断的任何有限高度贡献；仅关注 $W(\\mathcal{P})$。\n\n任务。明确地构造一个 PA 相继式推导，证明“每个自然数要么是零，要么是一个后继数”这一算术事实，并利用它通过一个非平凡切削来推导出相继式\n$$\n\\vdash \\forall x\\,\\exists y\\,\\big(x=0 \\,\\vee\\, S(y)=x\\big).\n$$\n具体步骤如下：\n- 首先，在谓词 $P(x) \\equiv \\big(x=0 \\,\\vee\\, \\exists y\\, S(y)=x\\big)$ 上使用归纳模式，推导出引理相继式 $\\vdash \\forall x\\,\\big(x=0 \\,\\vee\\, \\exists y\\, S(y)=x\\big)$。\n- 其次，通过对析取进行情况分析并恰当使用带有明确见证的存在右规则，推导出相继式 $x=0 \\,\\vee\\, \\exists y\\, S(y)=x \\;\\vdash\\; \\exists y\\,\\big(x=0 \\,\\vee\\, S(y)=x\\big)$。\n- 第三，在公式 $C(x) \\equiv x=0 \\,\\vee\\, \\exists y\\, S(y)=x$ 上使用一个非平凡切削，将这两个推导结合起来，以得到 $\\vdash \\exists y\\,\\big(x=0 \\,\\vee\\, S(y)=x\\big)$ 的推导，然后推广到 $\\vdash \\forall x\\,\\exists y\\,\\big(x=0 \\,\\vee\\, S(y)=x\\big)$。\n\n使用 $r(\\cdot)$ 和 $s(\\cdot)$ 的定义，计算您所构造的包含切削的证明 $\\mathcal{P}$ 的初始序数权重 $W(\\mathcal{P})$，然后对公式 $C(x)$ 上的切削执行标准的切削削减步骤，并追踪每次削减时序数权重的减小：\n- 首先将析取上的切削削减为其组分上的切削。\n- 然后将存在量词公式上的切削削减为其带有项见证的母式上的切削，并最终消除由此产生的原子切削。\n\n在每一步验证序数权重是否严格递减，并且序数权重序列以 $0$ 为下界且位于 $\\varepsilon_{0}$ 之下。以无切削的推导作为结论。您最终报告的量必须是从您构造的证明中计算出的初始序数权重 $W(\\mathcal{P})$ 的明确康托尔范式。请将您的最终答案表示为单个封闭形式的序数表达式。无需四舍五入。不涉及物理单位。角度和百分比不适用。", "solution": "问题陈述已经过验证并被认为是可靠的。它在数学逻辑的既定领域，特别是证明论和序数分析中，提出了一个适定的任务。所有定义和条件都已提供，未发现科学、逻辑或事实上的不一致之处。\n\n任务是在 Gentzen 风格的相继式演算中，为皮亚诺算术 (PA) 构造一个特定的证明，然后计算该证明中一个指定切削的初始序数权重。该证明将建立相继式 $\\vdash \\forall x\\,\\exists y\\,\\big(x=0 \\,\\vee\\, S(y)=x\\big)$。\n\n令公式 $P(x)$ 定义为 $P(x) \\equiv x=0 \\,\\vee\\, \\exists y\\, S(y)=x$。为简洁起见，当此公式用作切削公式时，我们亦将其记为 $C(x)$。\n\n**第一部分：引理 $\\vdash \\forall x\\,P(x)$ 的推导**\n\n此推导通过使用 PA 的归纳模式进行。在相继式演算中，这可以被表述为一条规则：如果可以推导出 $\\vdash P(0)$ 和 $P(x) \\vdash P(S(x))$，就可以推断出 $\\vdash \\forall x\\,P(x)$。我们将为这两个前提构造推导。\n\n**基础情况：$\\vdash P(0)$ 的推导**\n$P(0)$ 是公式 $0=0 \\vee \\exists y\\, S(y)=0$。\n1. $\\vdash 0=0$ (逻辑公理, $t=t$)\n2. $\\vdash 0=0, \\exists y\\, S(y)=0$ (在第1行上使用右弱化规则)\n3. $\\vdash 0=0 \\vee \\exists y\\, S(y)=0$ (在第2行上使用 $\\vee$-右规则)\n至此完成了 $\\vdash P(0)$ 的推导。\n\n**归纳步骤：$P(x) \\vdash P(S(x))$ 的推导**\n$P(S(x))$ 是公式 $S(x)=0 \\vee \\exists y\\, S(y)=S(x)$。我们首先直接推导 $\\vdash P(S(x))$。\n1. $\\vdash S(x)=S(x)$ (逻辑公理, $t=t$)\n2. $\\vdash \\exists y\\, S(y)=S(x)$ (在第1行上使用 $\\exists$-右规则，见证为 $t=x$)\n3. $\\vdash S(x)=0, \\exists y\\, S(y)=S(x)$ (在第2行上使用右弱化规则)\n4. $\\vdash S(x)=0 \\vee \\exists y\\, S(y)=S(x)$ (在第3行上使用 $\\vee$-右规则)\n这是 $\\vdash P(S(x))$ 的一个推导。由此，通过在左侧进行弱化，我们可以获得归纳步骤所需的相继式：\n5. $P(x) \\vdash P(S(x))$ (在第4行上使用左弱化规则，将 $P(x)$ 添加到前件)\n\n有了 $\\vdash P(0)$ 和 $P(x) \\vdash P(S(x))$ 的推导，PA 归纳规则允许我们推断出 $\\vdash \\forall x\\,P(x)$。我们将这个引理的完整推导记为 $\\mathcal{D}_{lemma}$。\n\n**第二部分：$P(x) \\vdash \\exists y\\,\\big(x=0 \\,\\vee\\, S(y)=x\\big)$ 的推导**\n\n此推导通过对公式 $P(x) \\equiv x=0 \\vee \\exists y\\, S(y)=x$ 进行情况分析来进行，这对应于相继式演算中的 $\\vee$-左规则。令 $\\Pi(x,y)$ 表示公式 $x=0 \\vee S(y)=x$。\n\n**情况 1：$x=0 \\vdash \\exists y\\,\\Pi(x,y)$**\n1. $x=0 \\vdash x=0$ (逻辑公理)\n2. $x=0 \\vdash x=0, S(0)=x$ (在第1行上使用右弱化规则)\n3. $x=0 \\vdash x=0 \\vee S(0)=x$ (在第2行上使用 $\\vee$-右规则)\n4. $x=0 \\vdash \\exists y\\,(x=0 \\vee S(y)=x)$ (在第3行上使用 $\\exists$-右规则，见证为 $t=0$)\n\n**情况 2：$\\exists y\\, S(y)=x \\vdash \\exists y\\,\\Pi(x,y)$**\n这个子推导使用 $\\exists$-左规则。我们假设 $S(a)=x$，其中 $a$ 是一个新的本征变量。\n1. $S(a)=x \\vdash S(a)=x$ (逻辑公理)\n2. $S(a)=x \\vdash x=0, S(a)=x$ (在第1行上使用右弱化规则)\n3. $S(a)=x \\vdash x=0 \\vee S(a)=x$ (在第2行上使用 $\\vee$-右规则)\n4. $S(a)=x \\vdash \\exists y\\,(x=0 \\vee S(y)=x)$ (在第3行上使用 $\\exists$-右规则，见证为 $t=a$)\n对第4行应用 $\\exists$-左规则（消除假设 $S(a)=x$）：\n5. $\\exists y\\, S(y)=x \\vdash \\exists y\\,(x=0 \\vee S(y)=x)$\n\n**合并情况：**结合情况1和情况2的结果并使用 $\\vee$-左规则：\n从 $x=0 \\vdash \\exists y\\,\\Pi(x,y)$ 和 $\\exists y\\, S(y)=x \\vdash \\exists y\\,\\Pi(x,y)$，我们推断出：\n$x=0 \\vee \\exists y\\, S(y)=x \\vdash \\exists y\\,(x=0 \\vee S(y)=x)$。\n至此完成了推导，我们将其记为 $\\mathcal{D}_{R}$。\n\n**第三部分：切削与最终证明构造**\n\n我们现在组装最终的证明 $\\mathcal{P}$，它涉及在公式 $C(x) \\equiv P(x)$ 上的单个指定切削。\n首先，从第一部分推导出的引理 $\\vdash \\forall x\\,C(x)$，我们得到 $\\vdash C(x)$ 的一个推导。这可以正式地通过与公理 $\\forall x\\,C(x) \\vdash C(x)$ 进行切削来完成，但就本问题而言，我们将从引理得到 $\\vdash C(x)$ 的推导视作一个预备步骤，它导出了我们主切削的左前提。我们将这个 $\\vdash C(x)$ 的推导记为 $\\mathcal{D}_{L}$。\n\n$\\vdash \\forall x\\,\\exists y\\,\\big(x=0 \\,\\vee\\, S(y)=x\\big)$ 的最终证明构造如下：\n1. 应用带有切削公式 $C(x)$ 的切削规则：\n   - 左前提：$\\vdash C(x)$ 的推导 $\\mathcal{D}_{L}$。\n   - 右前提：$C(x) \\vdash \\exists y\\,(x=0 \\vee S(y)=x)$ 的推导 $\\mathcal{D}_{R}$。\n   结论是相继式 $\\vdash \\exists y\\,(x=0 \\vee S(y)=x)$。令这个包含切削的证明为 $\\mathcal{P}$。\n2. 应用 $\\forall$-右规则对自由变量 $x$ 进行推广：\n   $\\vdash \\forall x\\,\\exists y\\,(x=0 \\vee S(y)=x)$。变量 $x$ 在上下文中（为空）不是自由的，因此这一步是有效的。\n\n问题要求的是在这个最终推广步骤之前的证明 $\\mathcal{P}$ 的序数权重。我们被指示唯一要考虑的切削是关于 $C(x)$ 的那个。\n\n**初始序数权重 $W(\\mathcal{P})$ 的计算**\n\n初始权重由 $W(\\mathcal{P}) = \\sum_{A \\in \\mathsf{Cuts}(\\mathcal{P})} \\omega^{r(A)} \\cdot s(A)$ 给出。\n在我们的构造中，只有一个在公式 $A = C(x) = x=0 \\vee \\exists y\\, S(y)=x$ 上的切削。因此，权重是 $W(\\mathcal{P}) = \\omega^{r(C(x))} \\cdot s(C(x))$。\n\n我们使用所提供的定义来计算阶 $r(C(x))$ 和大小 $s(C(x))$。\n令 $C_1 \\equiv x=0$ 且 $C_2 \\equiv \\exists y\\, S(y)=x$。\n公式 $S(y)=x$ 是原子的。根据定义：\n- $r(S(y)=x) = 0$\n- $s(S(y)=x) = 0$\n\n对于原子公式 $C_1 \\equiv x=0$：\n- $r(C_1) = 0$\n- $s(C_1) = 0$\n\n对于 $C_2 \\equiv \\exists y\\, S(y)=x$：\n- $r(C_2) = r(S(y)=x) + 1 = 0 + 1 = 1$\n- $s(C_2) = s(S(y)=x) + 1 = 0 + 1 = 1$\n\n对于切削公式 $C(x) = C_1 \\vee C_2$：\n- $r(C(x)) = \\max\\{r(C_1), r(C_2)\\} = \\max\\{0, 1\\} = 1$\n- $s(C(x)) = s(C_1) + s(C_2) + 1 = 0 + 1 + 1 = 2$\n\n因此，证明 $\\mathcal{P}$ 的初始序数权重是：\n$W(\\mathcal{P}) = \\omega^{r(C(x))} \\cdot s(C(x)) = \\omega^{1} \\cdot 2 = \\omega \\cdot 2$。\n\n**切削消除与序数减小分析**\n\n切削消除过程系统地降低切削的复杂度，在每一步都严格减小所赋予的序数，直到获得一个无切削的证明。\n\n1.  **初始状态：** 证明在 $C(x) = (x=0) \\vee (\\exists y\\,S(y)=x)$ 上有一个切削。序数权重为 $W_0 = \\omega \\cdot 2$。\n\n2.  **第一次削减：** 切削公式是一个析取。切削的右前提，$C(x) \\vdash \\exists y\\,\\Pi(x,y)$，主要是使用 $\\vee$-左规则推导出来的。对该析取的切削被削减为在其组分 $C_1 \\equiv x=0$ 和 $C_2 \\equiv \\exists y\\,S(y)=x$ 上的两个新切削。新证明的序数权重是这些新切削权重的序数和：\n    $W_1 = (\\omega^{r(C_1)} \\cdot s(C_1)) + (\\omega^{r(C_2)} \\cdot s(C_2))$\n    $W_1 = (\\omega^0 \\cdot 0) + (\\omega^1 \\cdot 1) = 0 + \\omega = \\omega$。\n    我们验证严格递减：$W_1 = \\omega  \\omega \\cdot 2 = W_0$。\n\n3.  **第二次削减：** 证明现在包含两个切削。\n    - 在原子公式 $C_1 \\equiv x=0$ 上的切削被直接消除（因为任何这样的切削最终都必须追溯到公理 $A \\vdash A$）。其对序数权重的贡献变为 $0$。\n    - 剩下的切削是在公式 $C_2 \\equiv \\exists y\\,S(y)=x$ 上。该切削的右前提（来自第二部分，情况2）是使用 $\\exists$-左规则推导的。削减过程将这个在存在量词公式上的切削替换为其母式 $S(y)=x$ 上的一个切削，其中本征变量被左前提中相应 $\\exists$-右规则的见证所替换。由此产生的切削公式是原子的。新的权重是：\n    $W_2 = \\omega^{r(S(t)=x)} \\cdot s(S(t)=x) = \\omega^0 \\cdot 0 = 0$。\n    我们验证严格递减：$W_2 = 0  \\omega = W_1$。\n\n4.  **最终状态：** 在第二次削减之后，任何剩余的切削都在原子公式上，然后它们被消除。最终的证明是无切削的，其序数权重为 $0$。\n\n序数权重序列为 $\\omega \\cdot 2 \\rightarrow \\omega \\rightarrow 0$。这证实了在每个削减步骤中都有严格的减小。此序列中的所有序数都小于 $\\varepsilon_0$，符合要求。\n\n所要求的最终答案是所构造证明 $\\mathcal{P}$ 的初始序数权重。", "answer": "$$\n\\boxed{\\omega \\cdot 2}\n$$", "id": "2978411"}, {"introduction": "要真正掌握一个数学概念，最好的方式之一便是将其形式化和算法化。这项练习将挑战您将序数分析中的关键步骤——切消引发的序数递减——转化为一个计算模型。您需要实现序数运算，并根据问题中定义的规则来模拟切消过程对序数度量的影响，并通过具体测试案例来验证这一过程的正确性。通过编程实践，您不仅能加深对序数算术和证明论变换的理解，还能体会到根岑一致性证明的严格构造性本质。[@problem_id:2978413]", "problem": "要求您在皮亚诺算术（PA, Peano Arithmetic）的 Gentzen 式相继演算中，形式化一个单一剪切消减步骤，并验证在此消减下所赋序数测度的严格递减。请完全在序数 $\\varepsilon_{0}$ 以下的良基序数表示系统内，使用康托尔范式进行操作。\n\n基本基础包括：\n- 通过康托尔范式定义 $\\varepsilon_{0}$ 以下的序数算术：每个序数 $\\alpha lt; \\varepsilon_{0}$ 都可以唯一地写为 $$\\alpha = \\omega^{\\alpha_{1}} \\cdot c_{1} + \\omega^{\\alpha_{2}} \\cdot c_{2} + \\cdots + \\omega^{\\alpha_{k}} \\cdot c_{k},$$ 其中 $k \\in \\mathbb{N}$，$c_{i} \\in \\mathbb{N}$，且 $\\alpha_{1} \\geq \\alpha_{2} \\geq \\cdots \\geq \\alpha_{k}$，并且每个指数 $\\alpha_{i}$ 本身也是一个小于 $\\varepsilon_{0}$ 的序数。\n- PA 相继演算中的剪切规则，以及作用于一个阶为 $r \\in \\mathbb{N}$ 的公式的单一剪切概念。\n- 为确保剪切消去的终止性，要求赋予证明的序数测度在剪切消减步骤下必须严格递减。\n\n任务：\n1. 构建一个明确的消减过程，记为 $\\mathrm{CutReduce}$，它将一个包含作用于阶为 $r$ 的公式的单一剪切的证明，转换为一个在阶 $r$ 上没有剪切或仅在严格小于 $r$ 的阶上存在剪切的证明。您的设计应捕捉复制子推导对测度的组合效应，但必须确保与阶 $r$ 相关联的序数首项被移除或严格减小。\n2. 为此类证明 $P$ 定义一个序数测度 $\\mu(P)$，其形式为 $$\\mu(P) = \\omega^{r} \\cdot h + \\sigma,$$ 其中 $h \\in \\mathbb{N}$ 反映了被消减剪切的左右推导的高度之和，而 $\\sigma$ 是一个严格小于 $\\omega^{r}$ 的背景序数，用于捕捉低阶结构的贡献。您的赋值必须与康托尔范式一致，并且必须映射到 $\\varepsilon_{0}$ 以下的序数。\n3. 证明消减过程 $\\mathrm{CutReduce}$ 严格减小了序数测度： $$\\mu\\bigl(\\mathrm{CutReduce}(P)\\bigr) lt; \\mu(P).$$\n\n实现要求：\n- 以康托尔范式表示 $\\varepsilon_{0}$ 以下的序数，具有递归指数和正整数系数。使用一种数据结构，强制指数递减，并合并指数相等的相邻项。\n- 实现康托尔范式序数的比较，以实现标准的良序关系：按字典序比较首项指数，若相等则比较系数，然后继续处理后续项。\n- 实现测度构造器 $$\\mu(r, h_{L}, h_{R}, \\sigma) = \\omega^{r} \\cdot (h_{L} + h_{R}) + \\sigma,$$ 其中 $\\sigma$ 以康托尔范式给出，且其所有指数都严格小于 $r$。这里 $h_{L}, h_{R} \\in \\mathbb{N}$。\n- 实现消减步骤 $\\mathrm{CutReduce}$，它输出一个新的测度 $$\\mu'(r, h_{L}, h_{R}, \\sigma) = \\begin{cases}\n\\sigma  \\text{if } r = 0,\\\\\n\\omega^{r-1} \\cdot k + \\sigma  \\text{if } r \\geq 1,\n\\end{cases}$$ 其中 $k \\in \\mathbb{N}$ 由复制子推导的组合学确定。选择一个具体的 $k$，它单调依赖于 $h_{L}$ 和 $h_{R}$，并且在剪切非平凡时为正，例如 $k = h_{L} \\cdot h_{R} + h_{L} + h_{R} + 1$。\n- 通过一个小型测试套件，以编程方式验证在此消减下测度是否严格递减。\n\n测试套件：\n对于每个测试用例，输入为 $(r, h_{L}, h_{R}, \\sigma)$，其中 $\\sigma$ 是一个对偶列表 $(e_{i}, c_{i})$，编码为 $\\omega^{e_{i}} \\cdot c_{i}$，且 $e_{i} \\in \\mathbb{N}$，$c_{i} \\in \\mathbb{N}$，按 $e_{i}$ 降序排列，并满足 $e_{i} lt; r$。程序必须计算\n$$\\mu'(r, h_{L}, h_{R}, \\sigma) lt; \\mu(r, h_{L}, h_{R}, \\sigma)$$\n是否成立，并为每个用例返回一个布尔值。\n\n使用以下测试用例：\n- 用例 A (一般情况): $r = 3$, $h_{L} = 2$, $h_{R} = 3$, $\\sigma = [\\, (2, 1), (1, 4) \\,]$.\n- 用例 B (最小非平凡阶的边界情况): $r = 1$, $h_{L} = 1$, $h_{R} = 1$, $\\sigma = [\\, ]$.\n- 用例 C (更高阶，非平凡背景): $r = 5$, $h_{L} = 4$, $h_{R} = 1$, $\\sigma = [\\, (3, 2), (2, 1), (1, 7) \\,]$.\n- 用例 D (一侧高度为零的边缘情况，有限尾部): $r = 2$, $h_{L} = 0$, $h_{R} = 5$, $\\sigma = [\\, (1, 1), (0, 10) \\,]$.\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，“[result1,result2,result3,result4]”），每个结果都是一个布尔值，指示相应测试用例的测度是否严格递减。不应打印任何额外文本。", "solution": "此问题是有效的。它是数理逻辑的一个子领域——证明论中一个适定且有科学依据的练习。它要求对 Gentzen 为皮亚诺算术所作的剪切消去证明中的一个关键步骤进行形式化和验证，特别是要证明序数测度的递减，这是该过程终止性论证的基石。所有定义和参数均已提供，问题是自洽且客观的。\n\n以下是附带推理的解决方案：\n\n此问题涉及皮亚诺算术（$PA$）的 Gentzen 式相继演算中证明的序数分析。该领域的核心成果是 Gentzen 的剪切消去定理，该定理指出，任何使用`cut`规则的证明都可以被转换为一个证明相同终相继式的无剪切证明。该定理的证明是构造性的：它提供了一个明确的算法来系统地移除剪切。为了证明该算法会终止，需要为每个证明从一个良序集中分配一个序数。消减算法的每一步都必须对应于这个所赋序数的严格递减。由于序数不存在无限递减链，该过程必然终止。对于$PA$，所需的序数集是序数 $\\varepsilon_0$ 以下的片段。\n\n**1. 序数表示与比较**\n\n小于 $\\varepsilon_0$ 的序数使用康托尔范式（CNF）表示。一个序数 $\\alpha  \\varepsilon_0$ 具有唯一的表示形式，即一个有限和：\n$$ \\alpha = \\omega^{\\alpha_1} \\cdot c_1 + \\omega^{\\alpha_2} \\cdot c_2 + \\dots + \\omega^{\\alpha_k} \\cdot c_k $$\n其中 $k$ 是一个非负整数，系数 $c_i$ 是正整数，指数 $\\alpha_i$ 本身是满足 $\\alpha  \\alpha_1 \\geq \\alpha_2 \\geq \\dots \\geq \\alpha_k \\geq 0$ 的序数。\n\n该问题通过指定所有指数（$\\sigma$中的$r$和$e_i$）都是自然数（即$r, e_i \\in \\mathbb{N}$）来简化这个通用结构。这将我们的注意力限制在小于 $\\omega^\\omega$ 的序数上，这是小于 $\\varepsilon_0$ 的序数的一个真初始段。\n\n序数比较是字典序的。给定两个康托尔范式下的序数，\n$$ \\alpha = \\omega^{a_1} \\cdot c_1 + \\omega^{a_2} \\cdot c_2 + \\dots $$\n$$ \\beta = \\omega^{b_1} \\cdot d_1 + \\omega^{b_2} \\cdot d_2 + \\dots $$\n如果在第一个不相同的项的索引 $i$ 处，我们有 $b_i  a_i$，或者 $b_i = a_i$ 且 $d_i  c_i$，那么我们说 $\\beta  \\alpha$。如果 $\\beta$ 的项序列是 $\\alpha$ 项序列的真前缀，那么 $\\beta  \\alpha$。\n\n**2. 证明的序数测度**\n\n该问题为一个包含特定剪切的证明 $P$ 定义了一个序数测度 $\\mu(P)$。该剪切作用于一个逻辑复杂度（或阶）为 $r \\in \\mathbb{N}$ 的公式。剪切规则的前提由高度为 $h_L, h_R \\in \\mathbb{N}$ 的子证明推导得出。该测度为：\n$$ \\mu(P) \\equiv \\mu(r, h_L, h_R, \\sigma) = \\omega^r \\cdot (h_L + h_R) + \\sigma $$\n此处，$\\sigma$ 是一个序数，代表证明所有其他部分的复杂度贡献。一个关键条件是，$\\sigma$ 的康托尔范式中的所有指数都严格小于 $r$。这确保了只要 $h_L+h_R  0$，$\\omega^r \\cdot (h_L + h_R)$ 就是 $\\mu(P)$ 的首项。\n\n**3. 剪切消减步骤**\n\nGentzen 过程的核心是将在阶为 $r$ 的公式上的剪切消减为一个或多个在阶严格小于 $r$ 的公式上的剪切。该问题模拟了此消减过程 $\\mathrm{CutReduce}$ 对序数测度的影响。新的测度 $\\mu'$ 由下式给出：\n$$ \\mu'(r, h_L, h_R, \\sigma) = \\begin{cases} \\sigma  \\text{if } r = 0 \\\\ \\omega^{r-1} \\cdot k + \\sigma  \\text{if } r \\ge 1 \\end{cases} $$\n其中 $k = h_L \\cdot h_R + h_L + h_R + 1$。整数 $k$ 组合地反映了新引入的低阶剪切的数量和复杂性。当消减一个阶为 $r \\ge 1$ 的剪切时，主公式被分解，子推导被复制，从而导致多个阶为 $r-1$ 的剪切。$k$ 的值界定了这个新配置的复杂性。\n\n**4. 序数递减的验证**\n\n我们必须证明 $\\mu'  \\mu$。我们分析 $r$ 的两种情况。\n\n**情况 1: $r \\ge 1$。** 在这种情况下，测度为：\n$$ \\mu = \\omega^r \\cdot (h_L + h_R) + \\sigma $$\n$$ \\mu' = \\omega^{r-1} \\cdot k + \\sigma $$\n一个非平凡的剪切意味着其前提的推导不为空，即 $h_L$ 或 $h_R$ 中至少有一个为正。所有测试用例都满足 $h_L+h_R  0$。在此条件下，$\\mu$ 中 $\\omega^r$ 项的系数 $(h_L+h_R)$ 是一个正整数。\n$\\mu$ 的康托尔范式为 $\\mu = \\omega^r \\cdot (h_L + h_R) + (\\text{指数小于 } r \\text{ 的项})$。其首项指数为 $r$。\n测度 $\\mu'$ 是 $\\omega^{r-1} \\cdot k$ 和 $\\sigma$ 的序数和。$\\sigma$ 中的所有指数都小于 $r$。因此，在执行加法并归一化为康托尔范式后，$\\mu'$ 中可能的最大指数是 $\\max(r-1, \\text{exponents of } \\sigma)$。由于 $\\sigma$ 中所有指数都小于 $r$，这个最大值为 $r-1$。\n所以，$\\mu$ 的首项指数是 $r$，而 $\\mu'$ 的首项指数是 $r-1$。\n根据序数比较的定义，由于 $r-1  r$，立即可以得出 $\\mu'  \\mu$。\n\n**情况 2: $r = 0$。** 阶为 0 的剪切是作用在原子公式上的剪切。这是消减的基础情况。$\\mu'$ 的规则指定该剪切被完全移除：\n$$ \\mu = \\omega^0 \\cdot (h_L + h_R) + \\sigma = 1 \\cdot (h_L + h_R) + \\sigma = (h_L+h_R) + \\sigma $$\n$$ \\mu' = \\sigma $$\n给定一个非平凡的剪切，$h_L+h_R  0$。由于序数加法通常不满足交换律，我们必须精确。项 $(h_L+h_R)$ 是一个形式为 $\\omega^0 \\cdot (h_L+h_R)$ 的序数。由于 $\\sigma$ 中最小的指数可以是 0（但小于 $r=0$ 是不可能的，因此如果我们严格遵守 $e_ir$，则 $\\sigma=0$），我们假设问题允许 $\\sigma$ 中存在 $e_i \\geq 0$ 只要 $e_i  r$。对于 $r=0$，这意味着 $\\sigma$ 必须是 $0$。在这种情况下，$\\mu=h_L+h_R$ 且 $\\mu'=0$。对于 $h_L+h_R0$ 的情况，显然有 $\\mu'  \\mu$。更一般地，如果 $\\sigma$ 可以非零，将一个正整数 $(h_L+h_R)$ 加到一个序数 $\\sigma$ 上会严格增加它，所以 $\\sigma  (h_L+h_R) + \\sigma$。因此 $\\mu'  \\mu$。\n\n在所有有效的消减场景中，序数测度都严格递减。这保证了重复应用消减过程必然会终止，从而确立了剪切消去的结果。下面的编程实现将针对所提供的具体测试用例验证此不等式。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of verifying ordinal decrease in a simulated\n    cut-elimination step for Peano Arithmetic.\n    \"\"\"\n\n    class Ordinal:\n        \"\"\"\n        Represents an ordinal below omega^omega in Cantor Normal Form.\n        The ordinal is stored as a list of (exponent, coefficient) tuples,\n        sorted in descending order of exponents. Exponents are integers.\n        \"\"\"\n        def __init__(self, terms=None):\n            \"\"\"\n            Initializes an Ordinal object.\n            Args:\n                terms (list, optional): A list of (exponent, coefficient) tuples.\n                                        Defaults to an empty list, representing the ordinal 0.\n            \"\"\"\n            if terms is None:\n                self.terms = []\n            else:\n                self.terms = self._normalize(terms)\n\n        @staticmethod\n        def _normalize(terms):\n            \"\"\"\n            Normalizes a list of terms into Cantor Normal Form:\n            1. Filters out terms with zero or negative coefficients.\n            2. Sorts terms by exponent in descending order.\n            3. Merges terms with identical exponents by summing their coefficients.\n            \"\"\"\n            # Filter terms with positive coefficients\n            filtered_terms = [t for t in terms if t[1] > 0]\n            if not filtered_terms:\n                return []\n\n            # Sort by exponent, descending\n            filtered_terms.sort(key=lambda t: t[0], reverse=True)\n\n            # Merge terms with same exponent\n            if len(filtered_terms) = 1:\n                return filtered_terms\n\n            merged = []\n            current_exp, current_coeff = filtered_terms[0]\n\n            for next_exp, next_coeff in filtered_terms[1:]:\n                if next_exp == current_exp:\n                    current_coeff += next_coeff\n                else:\n                    merged.append((current_exp, current_coeff))\n                    current_exp, current_coeff = next_exp, next_coeff\n            \n            merged.append((current_exp, current_coeff))\n            return merged\n\n        def __add__(self, other):\n            \"\"\"\n            Implements ordinal addition.\n            \"\"\"\n            if not isinstance(other, Ordinal):\n                return NotImplemented\n            # Concatenate term lists and re-normalize\n            new_terms = self.terms + other.terms\n            return Ordinal(new_terms)\n\n        def __lt__(self, other):\n            \"\"\"\n            Implements strict less-than comparison () for ordinals.\n            \"\"\"\n            if not isinstance(other, Ordinal):\n                return NotImplemented\n            \n            terms1 = self.terms\n            terms2 = other.terms\n            \n            i, j = 0, 0\n            while i  len(terms1) and j  len(terms2):\n                exp1, coef1 = terms1[i]\n                exp2, coef2 = terms2[j]\n\n                if exp1  exp2:\n                    return True  # self is smaller\n                if exp1 > exp2:\n                    return False  # self is larger\n\n                # Exponents are equal, compare coefficients\n                if coef1  coef2:\n                    return True  # self is smaller\n                if coef1 > coef2:\n                    return False  # self is larger\n\n                # Terms are identical, move to the next\n                i += 1\n                j += 1\n            \n            # One list is exhausted. If self is exhausted but other is not, self is smaller.\n            if i == len(terms1) and j  len(terms2):\n                return True\n            \n            # If other is exhausted, or both are, self is not strictly smaller.\n            return False\n\n        def __eq__(self, other):\n            \"\"\"\n            Implements equality comparison (==) for ordinals.\n            \"\"\"\n            if not isinstance(other, Ordinal):\n                return NotImplemented\n            return self.terms == other.terms\n\n        def __repr__(self):\n            \"\"\"\n            Provides a string representation for debugging purposes.\n            \"\"\"\n            if not self.terms:\n                return \"0\"\n            return \" + \".join([f\"w^{e}*{c}\" for e, c in self.terms])\n\n    def construct_mu(r, hL, hR, sigma_list):\n        \"\"\"\n        Constructs the ordinal measure mu = omega^r * (hL + hR) + sigma.\n        \"\"\"\n        h_sum = hL + hR\n        sigma_ord = Ordinal(sigma_list)\n        \n        if h_sum > 0:\n            term_r = Ordinal([(r, h_sum)])\n            return term_r + sigma_ord\n        else:\n            return sigma_ord\n\n    def construct_mu_prime(r, hL, hR, sigma_list):\n        \"\"\"\n        Constructs the reduced ordinal measure mu'.\n        \"\"\"\n        sigma_ord = Ordinal(sigma_list)\n\n        if r == 0:\n            # For r=0, the cut is removed, the measure becomes sigma.\n            # The prompt condition e_i  r means sigma_list should be empty.\n            # We follow the formula mu' = sigma.\n            return sigma_ord\n        \n        # For r = 1\n        k = hL * hR + hL + hR + 1\n        \n        if k > 0:\n            term_r_minus_1 = Ordinal([(r - 1, k)])\n            return term_r_minus_1 + sigma_ord\n        else:\n            # k is only 0 if hL, hR are not non-negative integers.\n            # For hL, hR in N, k = 1.\n            return sigma_ord\n\n    test_cases = [\n        # Case A: r=3, hL=2, hR=3, sigma=[(2,1), (1,4)]\n        (3, 2, 3, [(2, 1), (1, 4)]),\n        # Case B: r=1, hL=1, hR=1, sigma=[]\n        (1, 1, 1, []),\n        # Case C: r=5, hL=4, hR=1, sigma=[(3,2), (2,1), (1,7)]\n        (5, 4, 1, [(3, 2), (2, 1), (1, 7)]),\n        # Case D: r=2, hL=0, hR=5, sigma=[(1,1), (0,10)]\n        (2, 0, 5, [(1, 1), (0, 10)]),\n    ]\n\n    results = []\n    for r, hL, hR, sigma_list in test_cases:\n        mu = construct_mu(r, hL, hR, sigma_list)\n        mu_prime = construct_mu_prime(r, hL, hR, sigma_list)\n        results.append(mu_prime  mu)\n\n    # Format output as a single line: [result1,result2,...]\n    print(f\"[{','.join(str(r).lower() for r in results)}]\")\n\nsolve()\n```", "id": "2978413"}]}