{"hands_on_practices": [{"introduction": "我们对图灵跳跃算子的探索始于一个关于其定义一致性的基本问题。这个练习 [@problem_id:2986203] 要求你证明，无论使用哪种具体的通用谕示机，图灵跳跃的定义都是稳健的，其结果总是在同一个图灵度中。理解这种不变性至关重要，因为它确保了“跳跃”是一个自然且定义良好的概念，而非特定形式体系的人为产物。", "problem": "设 $A \\subseteq \\mathbb{N}$ 是一个作为谕示的自然数集合。对于一个带有代码 $e$ 和谕示 $A$ 的谕示图灵机，我们用 $\\Phi_e^A(x)$ 表示它在输入 $x$ 上计算的（部分）函数，用 $\\Phi_e^A(x) \\downarrow$ 表示该计算停机。一个通用谕示机是所有部分A-递归泛函的一个固定的可接受枚举，它具有这样的性质：存在一个可计算的模拟器，可以将任何其他有效的谕示程序枚举转换为这个枚举。相对于一个通用谕示机 $\\Phi$，将 $A$ 的图灵跳跃定义为\n$$\nJ_{\\Phi}(A) \\;=\\; \\{\\, e \\in \\mathbb{N} \\;:\\; \\Phi_e^A(e) \\downarrow \\,\\}.\n$$\n类似地，对于另一个通用谕示机 $\\Psi$，定义\n$$\nJ_{\\Psi}(A) \\;=\\; \\{\\, e \\in \\mathbb{N} \\;:\\; \\Psi_e^A(e) \\downarrow \\,\\}.\n$$\n回忆一下，一个集合 $X \\subseteq \\mathbb{N}$ 多一归约（也称为 m-归约）到一个集合 $Y \\subseteq \\mathbb{N}$，记作 $X \\leq_m Y$，如果存在一个全可计算函数 $f$，使得对于所有 $n \\in \\mathbb{N}$，\n$$\nn \\in X \\;\\;\\Longleftrightarrow\\;\\; f(n) \\in Y.\n$$\n一个集合 $X$ 图灵归约到 $Y$，记作 $X \\leq_T Y$，如果存在一个谕示图灵机，它使用谕示 $Y$ 来判定 $X$ 中的成员关系。\n\n仅使用通用谕示机的基本定义、谕示计算的参数化（也称 s-m-n）定理，以及多一归约和图灵归约的定义，选择一个陈述，该陈述正确地解释了为什么通过对角线停机定义的图灵跳跃在通用谕示机的选择下，在图灵等价的意义下是不变的，也就是说，为什么对于每个集合 $A$，集合 $J_{\\Phi}(A)$ 和 $J_{\\Psi}(A)$ 具有相同的图灵度。\n\n下列哪个陈述是正确的？\n\nA. 对于任意通用谕示机 $\\Phi$ 和 $\\Psi$，存在一个全可计算函数 $f$，使得对于所有集合 $A \\subseteq \\mathbb{N}$ 和所有 $e \\in \\mathbb{N}$，\n$$\n\\Phi_{f(e)}^A\\!\\big(f(e)\\big) \\downarrow \\;\\;\\Longleftrightarrow\\;\\; \\Psi_e^A(e) \\downarrow,\n$$\n因此 $J_{\\Psi}(A) \\leq_m J_{\\Phi}(A)$ 对 $A$ 一致成立，并且对称地有 $J_{\\Phi}(A) \\leq_m J_{\\Psi}(A)$；因此对于每个 $A$，$J_{\\Phi}(A)$ 和 $J_{\\Psi}(A)$ 都是图灵等价的。\n\nB. 当 $A$ 不是可计算集时，不变性可能不成立，因为通用谕示机之间的指标转换依赖于谕示 $A$，所以对于不可计算的 $A$，$J_{\\Phi}(A)$ 和 $J_{\\Psi}(A)$ 未必是图灵等价的。\n\nC. 这种不变性只在图灵归约的意义下成立，不能加强为多一归约，因为对角线输入 $e$ 阻止了保持对角线上停机性的可计算指标转换。\n\nD. 这种不变性本质上依赖于递归定理来产生自应用的固定点，如果不调用递归定理，就不能在两个通用谕示机之间统一地转换对角线计算。\n\nE. 这种不变性仅当机器枚举是 Rogers 意义下的可接受枚举时才成立，但存在不是可接受的通用谕示机，对于这些机器，跳跃集在不同枚举下可以有不同的图灵度。", "solution": "必须首先验证问题陈述的正确性、一致性和清晰度。\n\n**步骤 1：提取已知条件**\n- 谕示：一个集合 $A \\subseteq \\mathbb{N}$。\n- 谕示图灵机： $\\Phi_e^A(x)$ 是由指标为 $e$、谕示为 $A$ 的机器在输入 $x$ 上计算的部分函数。$\\Phi_e^A(x) \\downarrow$ 表示计算停机。\n- 通用谕示机：所有部分 A-递归泛函的一个固定的可接受枚举，用 $\\Phi$ 或 $\\Psi$ 表示。一个关键性质是存在一个可计算的模拟器用于在枚举之间进行转换。\n- 相对于 $\\Phi$ 的 $A$ 的图灵跳跃：$J_{\\Phi}(A) = \\{\\, e \\in \\mathbb{N} \\;:\\; \\Phi_e^A(e) \\downarrow \\,\\}$。\n- 相对于 $\\Psi$ 的 $A$ 的图灵跳跃：$J_{\\Psi}(A) = \\{\\, e \\in \\mathbb{N} \\;:\\; \\Psi_e^A(e) \\downarrow \\,\\}$。\n- 多一（m）归约：$X \\leq_m Y$ 若存在一个全可计算函数 $f$ 使得对于所有 $n \\in \\mathbb{N}$，$n \\in X \\iff f(n) \\in Y$。\n- 图灵（T）归约：$X \\leq_T Y$ 若存在一个使用谕示 $Y$ 的谕示图灵机能判定 $X$ 中的成员关系。\n- 问题要求使用基本定义、参数化（s-m-n）定理以及归约的定义。\n- 问题是找出正确的陈述，解释为什么对于任何谕示 $A$，$J_{\\Phi}(A)$ 和 $J_{\\Psi}(A)$ 具有相同的图灵度。\n\n**步骤 2：使用提取的已知条件进行验证**\n问题陈述是可计算性理论中关于图灵跳跃算子不变性的一个基本定理的标准表述。\n- **科学上合理**：所提出的概念（谕示图灵机、通用机、可接受枚举、归约性、s-m-n 定理）都是数理逻辑和理论计算机科学中的基石性定义。该问题牢固地植根于已建立的理论。\n- **良构的**：问题是良定义的。它要求从一组选项中为已知的数学结果（$J_{\\Phi}(A) \\equiv_T J_{\\Psi}(A)$）找到正确的解释。在该理论框架内存在一个唯一的、正确的解释。\n- **客观性**：语言是形式化的、精确的，并且没有主观性。\n- **完整性和一致性**：已知条件是充分的。关键短语“通用谕示机”和“可接受枚举”，以及对“参数化定理”的明确提及，为推导结果提供了所有必要的工具。没有矛盾之处。\n\n**步骤 3：结论与行动**\n问题陈述是有效的。我将继续推导解决方案并评估各个选项。\n\n**推导**\n\n目标是证明对于任何谕示 $A \\subseteq \\mathbb{N}$，集合 $J_{\\Phi}(A)$ 和 $J_{\\Psi}(A)$ 是图灵等价的（$J_{\\Phi}(A) \\equiv_T J_{\\Psi}(A)$）。这需要证明 $J_{\\Phi}(A) \\leq_T J_{\\Psi}(A)$ 和 $J_{\\Psi}(A) \\leq_T J_{\\Phi}(A)$。我们将证明一个更强的结果：它们是多一等价的（$J_{\\Phi}(A) \\equiv_m J_{\\Psi}(A)$），这意味着图灵等价。\n\n我们来证明 $J_{\\Psi}(A) \\leq_m J_{\\Phi}(A)$。根据定义，这需要找到一个全可计算函数 $f: \\mathbb{N} \\to \\mathbb{N}$，使得对于任何 $e \\in \\mathbb{N}$，\n$$\ne \\in J_{\\Psi}(A) \\;\\;\\Longleftrightarrow\\;\\; f(e) \\in J_{\\Phi}(A).\n$$\n这等价于证明：\n$$\n\\Psi_e^A(e) \\downarrow \\;\\;\\Longleftrightarrow\\;\\; \\Phi_{f(e)}^A(f(e)) \\downarrow.\n$$\n证明依赖于可接受枚举 $\\Phi$ 和 $\\Psi$ 的性质，特别是 s-m-n 定理（也称为参数化定理）。\n\n1.  对于任意固定的指标 $e \\in \\mathbb{N}$，考虑部分函数 $G_e(x)$，它对任意输入 $x$ 计算 $\\Psi_e^A(e)$。$G_e(x)$ 的计算过程如下：接受一个输入 $x$，忽略它，然后使用谕示 $A$ 运行指标为 $e$ 的 $\\Psi$-机在输入 $e$ 上的计算。这个过程可以由一个谕示图灵机实现。因此，对于每个 $e$，$G_e(x)$ 都是一个部分 A-递归函数。\n\n2.  更一般地，考虑双变量函数 $H(e, x) = \\Psi_e^A(e)$。这个函数是部分 A-递归的。一个带有谕示 $A$ 的谕示机可以通过将对 $(e,x)$ 作为输入，忽略 $x$，并模拟计算 $\\Psi_e^A(e)$ 来计算 $H(e,x)$。\n\n3.  由于 $\\Phi$ 是所有部分 A-递归泛函的一个可接受枚举，函数 $H(e,x)$ 必须对应于 $\\Phi$ 枚举中的某个泛函。也就是说，存在一个固定的指标 $v \\in \\mathbb{N}$，使得对于所有的 $e, x \\in \\mathbb{N}$ 及任何谕示 $A$：\n    $$\n    \\Phi_v^A(e, x) \\simeq H(e, x) \\simeq \\Psi_e^A(e).\n    $$\n    符号 $\\simeq$ 表示两边的计算要么都发散，要么都停机并得到相同的结果。\n\n4.  参数化（s-m-n）定理是所有可接受枚举的一个基本性质。对于枚举 $\\Phi$，它保证存在一个全可计算函数，通常记为 $s_1^1$，使得对于任何指标 $v$ 和任何 $e$：\n    $$\n    \\Phi_{s_1^1(v, e)}^A(x) \\simeq \\Phi_v^A(e, x).\n    $$\n\n5.  让我们定义函数 $f(e) = s_1^1(v, e)$。因为 $v$ 是一个固定的常数，并且 $s_1^1$ 是一个全可计算函数，所以 $f$ 也是一个全可计算函数。这个函数 $f$ 不依赖于谕示 $A$。\n\n6.  结合以上步骤，我们得到对于任意 $e, x \\in \\mathbb{N}$：\n    $$\n    \\Phi_{f(e)}^A(x) \\simeq \\Phi_{s_1^1(v, e)}^A(x) \\simeq \\Phi_v^A(e, x) \\simeq \\Psi_e^A(e).\n    $$\n    因此，我们找到了一个全可计算函数 $f$，使得对于任何谕示 $A$，指标为 $f(e)$ 的 $\\Phi$-机计算的函数在其定义域上是常数，并且其停机行为与 $\\Psi_e^A(e)$ 的停机行为相同。\n\n7.  等价关系 $\\Phi_{f(e)}^A(x) \\simeq \\Psi_e^A(e)$ 意味着停机是等价的：\n    $$\n    \\Phi_{f(e)}^A(x) \\downarrow \\;\\;\\Longleftrightarrow\\;\\; \\Psi_e^A(e) \\downarrow \\quad \\text{for all } x.\n    $$\n\n8.  由于这个等价关系对于 $\\Phi$-机的任何输入 $x$ 都成立，它也必须对于特定输入 $x = f(e)$ 成立。代入这个输入选择，我们得到：\n    $$\n    \\Phi_{f(e)}^A(f(e)) \\downarrow \\;\\;\\Longleftrightarrow\\;\\; \\Psi_e^A(e) \\downarrow.\n    $$\n\n9.  这正是从 $J_{\\Psi}(A)$到 $J_{\\Phi}(A)$ 的多一归约的条件，其中 $f$ 是归约函数。因此，$J_{\\Psi}(A) \\leq_m J_{\\Phi}(A)$。这个归约对 $A$ 是一致的，因为函数 $f$ 独立于 $A$。\n\n10. $\\Phi$ 和 $\\Psi$ 的角色是对称的。一个完全类似的论证表明，存在一个全可计算函数 $g$ 使得 $J_{\\Phi}(A) \\leq_m J_{\\Psi}(A)$。\n\n11. 从 $J_{\\Psi}(A) \\leq_m J_{\\Phi}(A)$ 和 $J_{\\Phi}(A) \\leq_m J_{\\Psi}(A)$，我们得出结论：$J_{\\Phi}(A)$ 和 $J_{\\Psi}(A)$ 是多一等价的，记作 $J_{\\Phi}(A) \\equiv_m J_{\\Psi}(A)$。\n\n12. 由于多一归约蕴含图灵归约（$X \\leq_m Y \\implies X \\leq_T Y$），因此立即得出 $J_{\\Phi}(A) \\equiv_T J_{\\Psi}(A)$。这两个集合属于同一个图灵度。\n\n**逐项分析**\n\n**A. 对于任意通用谕示机 $\\Phi$ 和 $\\Psi$，存在一个全可计算函数 $f$ 使得对于所有集合 $A \\subseteq \\mathbb{N}$ 和所有 $e \\in \\mathbb{N}$，$\\Phi_{f(e)}^A\\!\\big(f(e)\\big) \\downarrow \\;\\;\\Longleftrightarrow\\;\\; \\Psi_e^A(e) \\downarrow$，因此 $J_{\\Psi}(A) \\leq_m J_{\\Phi}(A)$ 对 $A$ 一致成立，并且对称地有 $J_{\\Phi}(A) \\leq_m J_{\\Psi}(A)$；因此对于每个 $A$，$J_{\\Phi}(A)$ 和 $J_{\\Psi}(A)$ 都是图灵等价的。**\n\n这个陈述准确地总结了上述推导过程。它正确地指出存在一个全可计算函数 $f$ 在跳跃集之间建立了一个多一归约。它正确地表述了归约条件 $\\Phi_{f(e)}^A(f(e)) \\downarrow \\iff \\Psi_e^A(e) \\downarrow$。它注意到了论证的对称性，并正确地得出结论：m-等价蕴含图灵等价。“对 A 一致”的说法也是正确的，因为归约函数 f 不依赖于谕示 A。\n\n结论：**正确**。\n\n**B. 当 $A$ 不是可计算集时，不变性可能不成立，因为通用谕示机之间的指标转换依赖于谕示 $A$，所以对于不可计算的 $A$，$J_{\\Phi}(A)$ 和 $J_{\\Psi}(A)$ 未必是图灵等价的。**\n\n这个陈述在事实上是错误的。可接受枚举的一个基本性质是，它们之间的指标转换是通过一个独立于任何谕示的全可计算函数实现的。提供这种转换的 s-m-n 定理构造了一个操作程序指标的函数，这个过程不查询谕示。跳跃算子度的不变性对*任何*谕示 A 都成立，无论 A 是否可计算。\n\n结论：**错误**。\n\n**C. 这种不变性只在图灵归约的意义下成立，不能加强为多一归约，因为对角线输入 $e$ 阻止了保持对角线上停机性的可计算指标转换。**\n\n这个陈述是错误的。正如推导所示，不变性可以通过多一归约（$J_{\\Phi}(A) \\equiv_m J_{\\Psi}(A)$）来建立。该选项中提供的理由描述了一个潜在的陷阱：将 $\\Psi_e^A$ 简单地转换为 $\\Phi_{g(e)}^A$ 会导致检查 $\\Phi_{g(e)}^A(e)$ 而不是 $\\Phi_{g(e)}^A(g(e))$。然而，这不是一个不可逾越的障碍。s-m-n 定理允许一个更复杂的构造（如主推导所示），它专门构建一个新机器来解决这个“对角线不匹配”问题，从而得到一个有效的 m-归约。\n\n结论：**错误**。\n\n**D. 这种不变性本质上依赖于递归定理来产生自应用的固定点，如果不调用递归定理，就不能在两个通用谕示机之间统一地转换对角线计算。**\n\n这个陈述错误地识别了关键工具。如上详述，不变性的标准和最直接的证明关键依赖于 s-m-n（参数化）定理，而不是递归定理。s-m-n 定理是关于可计算地参数化程序，这正是构造归约函数 $f$ 所需要的。虽然递归定理是自引用构造的强大工具，但对于这个特定的证明来说不是必需的。声称没有递归定理就*无法*证明这个结论是错误的。\n\n结论：**错误**。\n\n**E. 这种不变性仅当机器枚举是 Rogers 意义下的可接受枚举时才成立，但存在不是可接受的通用谕示机，对于这些机器，跳跃集在不同枚举下可以有不同的图灵度。**\n\n问题陈述明确将通用谕示机 $\\Phi$ 和 $\\Psi$ 定义为“可接受枚举”。因此，这个选项陈述了一个已经作为前提给出的条件。尽管其潜在主张是正确的——对于病态的（不可接受的）编码，跳跃可能不是不变的——但它没有解释*为什么*在指定情况下不变性成立。它陈述了结果的一个先决条件，而不是解释证明的机制。选项 A 提供了实际的解释机制。\n\n结论：**错误**。", "answer": "$$\\boxed{A}$$", "id": "2986203"}, {"introduction": "在确立了跳跃算子的定义之后，我们将探讨它与算术层级之间深刻的联系。这个问题 [@problem_id:2986207] 将引导你关联集合的 $\\Delta^0_2$ 类的几个关键刻画。你将看到，图灵可归约于停机问题（$0'$）的计算能力，等价于 $\\Delta^0_2$ 的逻辑定义以及极限可计算的概念。", "problem": "设 $A \\subseteq \\mathbb{N}$ 是一个自然数集合。记 $\\chi_{A} \\colon \\mathbb{N} \\to \\{0,1\\}$ 为 $A$ 的特征函数。一个全函数 $f \\colon \\mathbb{N} \\times \\mathbb{N} \\to \\{0,1\\}$ 是 $A$ 的一个可计算逼近，如果 $f$ 是（图灵）可计算的（无谕示）并且对于每个 $x \\in \\mathbb{N}$，极限 $\\lim_{s \\to \\infty} f(x,s)$ 存在且等于 $\\chi_{A}(x)$。在这种情况下，称 $A$ 是在 $\\emptyset$ 中极限可计算的（即，无谕示极限可计算的）。算术分层类 $\\Sigma^{0}_{n}$、$\\Pi^{0}_{n}$ 和 $\\Delta^{0}_{n}$ 是通过 $\\mathbb{N}$ 上的一阶公式定义的，这些公式分别具有 $n$ 个交错的量词块，分别以存在量词、全称量词和两者开始，并且其中 $\\Delta^{0}_{n} = \\Sigma^{0}_{n} \\cap \\Pi^{0}_{n}$。集合 $X \\subseteq \\mathbb{N}$ 的图灵跳跃，记作 $X'$，是集合 $X' = \\{ e \\in \\mathbb{N} : \\Phi_{e}^{X}(e) \\text{ 停机} \\}$，其中 $\\Phi_{e}^{X}$ 是带有谕示 $X$ 的第 $e$ 个图灵机。记 $0'$ 为空集的跳跃，即经典的停机问题。一个集合 $B$ 图灵可归约于 $C$（写作 $B \\leq_{T} C$），如果存在一个谕示图灵机，使用 $C$作为谕示来计算 $\\chi_{B}$。一个集合 $B$ 多一可归约于 $C$（写作 $B \\leq_{m} C$），如果存在一个全可计算函数 $g$ 使得 $x \\in B$ 当且仅当 $g(x) \\in C$。\n\n仅使用这些定义和诸如 Post 定理（即 $\\Delta^{0}_{n+1}$ 恰好是可图灵归约于 $0^{(n)}$（$\\emptyset$ 的第 $n$ 次跳跃）的集合类）等公认的定理，选择所有必然为真的陈述。\n\nA. 对于每个集合 $A$，有 $A \\in \\Delta^{0}_{2}$ 当且仅当 $A$ 在 $\\emptyset$ 中是极限可计算的。\n\nB. 对于每个集合 $A$，有 $A \\in \\Delta^{0}_{2}$ 当且仅当 $A \\leq_{m} 0'$。\n\nC. 集合 $0'$ 恰好是计算所有可计算逼近之极限的最弱谕示：对于每个全可计算函数 $f \\colon \\mathbb{N} \\times \\mathbb{N} \\to \\{0,1\\}$，函数 $x \\mapsto \\lim_{s \\to \\infty} f(x,s)$ 是 $0'$-可计算的；此外，如果一个谕示 $X$ 对每个这样的 $f$ 都能计算 $x \\mapsto \\lim_{s \\to \\infty} f(x,s)$，那么 $0' \\leq_{T} X$。\n\nD. 根据 Post 定理，$\\Delta^{0}_{2}$ 与在 $\\emptyset$ 中既是递归可枚举又是余递归可枚举（即，递归可枚举且其补集也是递归可枚举）的集合类重合。\n\nE. 一个集合 $A$ 属于 $\\Delta^{0}_{2}$ 当且仅当 $A$ 及其补集在 $0'$ 中都是递归可枚举的（等价地， $A \\in \\Sigma^{0}_{1}(0') \\cap \\Pi^{0}_{1}(0')$），因此当且仅当 $A \\leq_{T} 0'$。", "solution": "该问题要求辨别所有关于可计算性理论的真陈述，重点关注集合类 $\\Delta^{0}_{2}$及其与极限可计算性、图灵可归约性和停机问题 $0'$ 的关系。问题陈述提供了标准定义和 Post 定理，该定理指出一个集合属于 $\\Delta^{0}_{n+1}$ 当且仅当它可图灵归约于 $0^{(n)}$。对于 $n=1$，这意味着 $A \\in \\Delta^{0}_{2} \\iff A \\leq_{T} 0'$。我们将基于这些定义和可计算性理论的其他公认定理来评估每个选项。\n\nA. 对于每个集合 $A$，有 $A \\in \\Delta^{0}_{2}$ 当且仅当 $A$ 在 $\\emptyset$ 中是极限可计算的。\n\n这个陈述是 Shoenfield 极限引理的一种表述，它是可计算性理论中的一个基本结果。我们来验证一下。\n\n($\\Rightarrow$) 假设 $A$ 是极限可计算的。根据定义，存在一个全可计算函数 $f \\colon \\mathbb{N} \\times \\mathbb{N} \\to \\{0,1\\}$，使得对于每个 $x \\in \\mathbb{N}$，有 $\\chi_{A}(x) = \\lim_{s \\to \\infty} f(x,s)$。\n对于 $x \\in A$，我们有 $\\chi_{A}(x) = 1$。这意味着存在一个阶段 $s_0$，使得对于所有 $s > s_0$，有 $f(x,s) = 1$。这可以表示为：\n$x \\in A \\iff \\exists s_0 \\forall s (s > s_0 \\implies f(x,s) = 1)$。\n由于 $f$ 是一个可计算函数，量词内的谓词是可计算的。该公式具有 $\\exists \\forall$ 的形式，根据定义，这是一个 $\\Sigma^{0}_{2}$ 公式。因此，$A \\in \\Sigma^{0}_{2}$。\n对于补集 $\\bar{A}$，一个元素 $x \\in \\bar{A}$ 意味着 $\\chi_{A}(x) = 0$。这意味着存在一个阶段 $s_0$，使得对于所有 $s > s_0$，有 $f(x,s) = 0$。这可以表示为：\n$x \\in \\bar{A} \\iff \\exists s_0 \\forall s (s > s_0 \\implies f(x,s) = 0)$。\n这表明 $\\bar{A} \\in \\Sigma^{0}_{2}$。根据定义，如果一个集合的补集在 $\\Sigma^{0}_{2}$ 中，那么该集合本身就在 $\\Pi^{0}_{2}$ 中。因此，$A \\in \\Pi^{0}_{2}$。\n由于 $A \\in \\Sigma^{0}_{2}$ 且 $A \\in \\Pi^{0}_{2}$，根据定义 $A \\in \\Delta^{0}_{2}$。\n\n($\\Leftarrow$) 假设 $A \\in \\Delta^{0}_{2}$。根据所给的 Post 定理，这等价于 $A \\leq_{T} 0'$。这意味着存在一个谕示图灵机 $\\Phi_e$，使得对于所有 $x \\in \\mathbb{N}$，有 $\\chi_A(x) = \\Phi_e^{0'}(x)$。\n我们可以构造一个可计算函数 $f(x,s)$ 来逼近这个计算。谕示 $0'$ 是一个 $\\Sigma^{0}_{1}$ 集合，因此我们可以定义一个可计算的有限集序列 $0'_s$ 来从下方逼近 $0'$：$0'_s = \\{ k \\le s \\mid \\Phi_k(k) \\text{ 在至多 } s \\text{ 步内停机} \\}$。对于任何 $k$，$\\lim_{s \\to \\infty} \\chi_{0'_s}(k) = \\chi_{0'}(k)$。\n我们定义 $f(x,s)$ 为模拟计算 $\\Phi_e(x)$ 至多 $s$ 步的结果，使用 $0'_s$ 作为谕示。如果该模拟在 $s$ 步内停机并输出一个值，则 $f(x,s)$ 就是那个值。否则，我们可以定义 $f(x,s)=0$（或某个其他默认值）。\n对于任何固定的 $x$，真实的计算 $\\Phi_e^{0'}(x)$ 会在有限步（比如 $t_x$）内停机，并查询一个有限的数集 $Q_x$。设 $s_x$ 是一个足够大的阶段，使得 $s_x \\ge t_x$ 并且对于所有 $q \\in Q_x$，有 $\\chi_{0'_{s_x}}(q) = \\chi_{0'}(q)$。这样的 $s_x$ 存在是因为 $Q_x$ 是有限的。对于所有 $s \\ge s_x$，模拟的计算 $\\Phi_e^{0'_s}(x)$ 将有足够的步数和正确的谕示回答，所以其输出将是稳定且正确的：$f(x,s) = \\chi_A(x)$。\n因此，$\\lim_{s \\to \\infty} f(x,s) = \\chi_A(x)$，这意味着 $A$ 是极限可计算的。\n\n该等价关系成立。\n结论：**正确**。\n\nB. 对于每个集合 $A$，有 $A \\in \\Delta^{0}_{2}$ 当且仅当 $A \\leq_{m} 0'$。\n\n这个陈述声称对于所有集合 $A$，图灵可归约于 $0'$ 等价于多一可归约于 $0'$。蕴含关系 $A \\leq_{m} 0' \\implies A \\leq_{T} 0'$ 是正确的，因为多一归约可以用来构造一个图灵归约。然而，其逆命题 $A \\leq_{T} 0' \\implies A \\leq_{m} 0'$ 是错误的。\n考虑集合 $\\bar{0'}$，即停机问题的补集。一个集合和它的补集总是图灵等价的，所以 $0' \\equiv_T \\bar{0'}$。由于 $0' \\leq_T 0'$，我们有 $\\bar{0'} \\leq_T 0'$。根据问题中给出的 Post 定理，这意味着 $\\bar{0'} \\in \\Delta^0_2$。\n现在，我们来检验是否 $\\bar{0'} \\leq_{m} 0'$。如果这是真的，那么会存在一个全可计算函数 $g$ 使得 $x \\in \\bar{0'} \\iff g(x) \\in 0'$。这将意味着 $\\bar{0'}$ 是一个 $\\Sigma^0_1$ 集合，因为 $\\bar{0'}$ 中的成员资格可以通过检查 $g(x)$ 是否在 $\\Sigma^0_1$ 集合 $0'$ 中来判定。然而，已知 $\\bar{0'}$ 是 $\\Pi^0_1$-完全的。如果 $\\bar{0'}$ 同时也是 $\\Sigma^0_1$ 的，那么它将属于 $\\Delta^0_1$，这意味着它是一个可计算集。这将推出它的补集 $0'$ 也是可计算的，但这与停机问题的不可判定性相矛盾。\n因此，$\\bar{0'}$ 属于 $\\Delta^0_2$ 但不能多一归约于 $0'$。这是一个反例。\n结论：**错误**。\n\nC. 集合 $0'$ 恰好是计算所有可计算逼近之极限的最弱谕示：对于每个全可计算函数 $f \\colon \\mathbb{N} \\times \\mathbb{N} \\to \\{0,1\\}$，函数 $x \\mapsto \\lim_{s \\to \\infty} f(x,s)$ 是 $0'$-可计算的；此外，如果一个谕示 $X$ 对每个这样的 $f$ 都能计算 $x \\mapsto \\lim_{s \\to \\infty} f(x,s)$，那么 $0' \\leq_{T} X$。\n\n这个陈述有两部分。\n1.  对于任何全可计算函数 $f \\colon \\mathbb{N} \\times \\mathbb{N} \\to \\{0,1\\}$，如果对所有 $x$ 极限都存在，那么函数 $L_f(x) = \\lim_{s \\to \\infty} f(x,s)$是 $0'$-可计算的。\n设 $A$ 是以 $L_f$ 为特征函数的集合。那么根据定义，$A$ 是极限可计算的。根据选项 A (Shoenfield 极限引理)，任何极限可计算集都在 $\\Delta^{0}_{2}$ 中。根据给定的 Post 定理，任何在 $\\Delta^{0}_{2}$ 中的集合都可图灵归约于 $0'$。这意味着 $A$ 的特征函数，即 $L_f$，是 $0'$-可计算的。所以，第一部分是正确的。\n\n2.  如果一个谕示 $X$ 对每个这样的 $f$ 都能计算 $L_f$，那么 $0' \\leq_{T} X$。\n为了证明 $0' \\leq_{T} X$，我们需要证明我们可以使用谕示 $X$ 来计算 $0'$ 的特征函数。我们必须构造一个特定的全可计算函数 $f_0 \\colon \\mathbb{N} \\times \\mathbb{N} \\to \\{0,1\\}$，使得 $\\chi_{0'}(e) = \\lim_{s \\to \\infty} f_0(e,s)$。\n我们如下定义 $f_0(e,s)$：\n如果索引为 $e$ 的图灵机在输入 $e$ 上至多 $s$ 步内停机（$\\Phi_e(e) \\downarrow_s$），则 $f_0(e,s) = 1$。\n否则 $f_0(e,s) = 0$。\n这个函数 $f_0$ 是全的且可计算的。\n现在考虑极限：\n如果 $e \\in 0'$，那么 $\\Phi_e(e)$ 在某个步数 $s_0$ 时停机。对于所有 $s \\ge s_0$，$f_0(e,s) = 1$。因此，$\\lim_{s \\to \\infty} f_0(e,s) = 1$。\n如果 $e \\notin 0'$，那么 $\\Phi_e(e)$ 永不停机。对于所有 $s$，$f_0(e,s) = 0$。因此，$\\lim_{s \\to \\infty} f_0(e,s) = 0$。\n所以，$\\chi_{0'}(e) = \\lim_{s \\to \\infty} f_0(e,s)$。\n由于假设谕示 $X$ 能够对任何输入 $e$ 计算这个极限，所以 $X$ 能够计算 $\\chi_{0'}$。根据定义，这意味着 $0' \\leq_{T} X$。第二部分也是正确的。\n该陈述的两部分都是正确的。集合 $0'$ 代表了确定可计算序列极限所需的计算能力，因此在图灵度的意义下，它是最弱的此类谕示。\n结论：**正确**。\n\nD. 根据 Post 定理，$\\Delta^{0}_{2}$ 与在 $\\emptyset$ 中既是递归可枚举又是余递归可枚举（即，递归可枚举且其补集也是递归可枚举）的集合类重合。\n\n“在 $\\emptyset$ 中递归可枚举”的集合类就是递归可枚举（r.e.）集合类，即 $\\Sigma^0_1$。\n“在 $\\emptyset$ 中余递归可枚举”的集合类是余递归可枚举（co-r.e.）集合类，即 $\\Pi^0_1$。\n一个集合在这两个类的交集 $\\Sigma^0_1 \\cap \\Pi^0_1 = \\Delta^0_1$ 中，当且仅当它是可计算的（或递归的）。这是 Post 的一个经典定理。\n该陈述断言 $\\Delta^{0}_{2} = \\Delta^{0}_{1}$。这是错误的。算术分层是一个真分层，意味着 $\\Delta^{0}_{1} \\subset \\Delta^{0}_{2}$。例如，停机问题集 $0'$ 属于 $\\Sigma^{0}_{1}$ 但不属于 $\\Pi^{0}_{1}$，因此它不属于 $\\Delta^{0}_{1}$。然而，$0'$ 属于 $\\Delta^{0}_{2}$，因为 $0' \\in \\Sigma^{0}_{1} \\subseteq \\Pi^{0}_{2}$ 并且 $0' \\in \\Sigma^{0}_{1} \\subseteq \\Sigma^{0}_{2}$，因此 $0' \\in \\Delta^0_2$。更简单地说，$0' \\leq_T 0'$，所以根据 Post 定理，$0' \\in \\Delta^0_2$。由于 $0'$ 不是可计算的，所以 $0' \\notin \\Delta^0_1$。\n结论：**错误**。\n\nE. 一个集合 $A$ 属于 $\\Delta^{0}_{2}$ 当且仅当 $A$ 及其补集在 $0'$ 中都是递归可枚举的（等价地， $A \\in \\Sigma^{0}_{1}(0') \\cap \\Pi^{0}_{1}(0')$），因此当且仅当 $A \\leq_{T} 0'$。\n\n这个陈述断言了一系列等价关系。我们来分析它们。\n条件“$A$ 及其补集在 $0'$ 中都是递归可枚举的”，根据定义就是 $A \\in \\Sigma^{0}_{1}(0')$ 并且 $\\bar{A} \\in \\Sigma^{0}_{1}(0')$。\n条件 $\\bar{A} \\in \\Sigma^{0}_{1}(0')$ 等价于 $A \\in \\Pi^{0}_{1}(0')$。\n所以，“$A$ 及其补集在 $0'$ 中都是递归可枚举的”恰好等价于 $A \\in \\Sigma^{0}_{1}(0') \\cap \\Pi^{0}_{1}(0')$。这就是类 $\\Delta^{0}_{1}(0')$。\n\nPost 定理的相对化版本（一个集合是可计算的当且仅当它是递归可枚举且余递归可枚举的）指出，一个集合 $B$ 在一个谕示 $X$ 中是可计算的（即，$B \\leq_T X$），当且仅当 $B \\in \\Delta^0_1(X)$。对于我们的情况，其中 $X=0'$ 且 $B=A$，这意味着 $A \\leq_T 0' \\iff A \\in \\Delta^0_1(0')$。\n\n跳跃定理，是另一个基本结果，它指出对于任何 $n \\ge 1$，一个集合属于 $\\Sigma^0_{n+1}$ 当且仅当它属于 $\\Sigma^0_n(0')$，对于 $\\Pi^0_{n+1}$ 和 $\\Pi^0_n(0')$ 也是类似的。\n对于 $n=1$，我们得到：\n$A \\in \\Sigma^{0}_{2} \\iff A \\in \\Sigma^{0}_{1}(0')$\n$A \\in \\Pi^{0}_{2} \\iff A \\in \\Pi^{0}_{1}(0')$\n结合这些，我们得到：\n$A \\in \\Delta^{0}_{2} \\iff A \\in (\\Sigma^{0}_{2} \\cap \\Pi^{0}_{2}) \\iff A \\in (\\Sigma^{0}_{1}(0') \\cap \\Pi^{0}_{1}(0')) \\iff A \\in \\Delta^{0}_{1}(0')$。\n\n综上所述，我们有以下一系列等价关系，所有这些都是标准定理：\n$A \\in \\Delta^{0}_{2} \\iff A \\in \\Delta^{0}_{1}(0') \\iff A \\leq_{T} 0'$。\n该陈述正确地列出了这些等价关系。第一部分指出 $A \\in \\Delta^{0}_{2} \\iff A \\in \\Delta^{0}_{1}(0')$。“因此”部分将其与 $A \\leq_T 0'$ 联系起来，这也是一个正确的等价关系。事实上，问题陈述直接给出了 $A \\in \\Delta^0_2 \\iff A \\leq_T 0'$。这个选项正确地增加了通过相对化递归可枚举性进行的中间刻画。\n结论：**正确**。", "answer": "$$\\boxed{ACE}$$", "id": "2986207"}, {"introduction": "从理解性质转向主动构造，这最后一个练习将深入探讨优先权论证的精妙机制。这个问题 [@problem_id:2986205] 挑战你设计一个策略来构造两个集合 $A$ 和 $B$，使得它们的跳跃是图灵不可比的（$A' \\not\\leq_T B'$）。这个练习揭示了可计算性理论家如何通过设置约束和处理“伤害”（injury）来精确控制递归可枚举集及其跳跃的性质。", "problem": "设 $A \\subseteq \\mathbb{N}$ 和 $B \\subseteq \\mathbb{N}$ 是通过优先构造法构造的自然数集。回顾定义：$X$ 的图灵跳跃，记作 $X'$, 是 $X' = \\{ e \\in \\mathbb{N} : \\Phi_e^X(e) \\downarrow \\}$, 其中 $\\Phi_e$ 是第 $e$ 个部分可计算泛函，$\\downarrow$ 表示收敛。图灵可归约性 $X \\leq_T Y$ 意味着存在某个可计算泛函 $\\Psi$，使得对于所有 $n \\in \\mathbb{N}$，$\\Psi^Y(n)$ 收敛到特征函数 $\\chi_X(n)$。目标是通过满足一个一致的需求族来迫使 $A' \\not\\leq_T B'$，并描述必须如何管理伤害和约束以分离这两个跳跃，同时考虑到使用 $B'$ 的谕示计算在内部依赖于 $B$ 的有限段。\n\n你需要选择正确阐述以下内容的陈述：\n\n1. 一个足以通过优先构造法来迫使 $A' \\not\\leq_T B'$ 的一致需求族，该构造法以图灵跳跃和图灵可归约性的定义为基础；以及\n\n2. 一个管理伤害和约束的原则性策略，该策略正确地考虑到了相对于 $B'$ 的计算会引起对 $B$ 的嵌套使用，因此需要一个对 $B'$ 的近似使用“真实阶段”的概念，以确保有限伤害并最终满足所有需求。\n\n选项：\n\nA. 对于每个 $e \\in \\mathbb{N}$，设置需求 $R_e$：确保存在 $x_e$ 使得 $\\Phi_e^{B'}(x_e) \\uparrow$ 或 $\\Phi_e^{B'}(x_e) \\neq \\chi_{A'}(x_e)$。在 $R_e$ 的一个扩展阶段 $s$，当 $\\Phi_e^{B'_s}(x_e)$ 使用一个有限的 $B'$-查询向量收敛，且其关联的 $B$-计算的使用以某个 $u_e(s)$ 为界时，在 $B$ 上施加一个低于 $\\max u_e(s)$ 的约束 $r_e(s)$ 以保护那些 $B$-计算，然后通过一个受控的停机计算 $\\Gamma_e^A(x_e)$ 对 $A$ 进行操作来编码 $\\chi_{A'}(x_e)$，这个计算可以通过将一个新的标记列举到 $A$ 中（在所有当前对 $A$ 的约束之外）来翻转，从而确保 $\\Phi_e^{B'}(x_e)$ 变为错误。当更高优先级的需求将元素列举进低于较低优先级约束 $r_e$ 的 $B$ 中时，就会发生伤害，这会使 $\\Phi_e^{B'}(x_e)$ 的计算失效；较低优先级的需求会等待一个具有更大使用量的后续真实阶段，并提高其约束。因为在扩展阶段，$B'$-计算的使用量严格增加，且约束也相应地嵌套，所以每个需求只遭受有限次伤害，从而得到 $A' \\not\\leq_T B'$。\n\nB. 对于每个 $e \\in \\mathbb{N}$，设置 $R_e$：直接将元素列举到低于 $\\Phi_e^{B'}(x_e)$ 当前使用量的 $B'$ 中，以迫使 $\\Phi_e^{B'}(x_e)$ 发散。伤害通过在 $B'$ 上放置静态约束并且从不改变 $B$ 来管理，因为 $B'$ 决定 $B$。\n\nC. 对于每个 $e \\in \\mathbb{N}$，设置需求 $P_e$：确保存在 $x_e$ 使得 $\\Phi_e^{B}(x_e) \\uparrow$ 或 $\\Phi_e^{B}(x_e) \\neq \\chi_{A'}(x_e)$。在 $\\Phi_e^{B}(x_e)$ 收敛的阶段，在 $B$ 上施加一个低于其使用量的约束，然后改变 $A$ 以翻转 $\\chi_{A'}(x_e)$ 的值，从而保证 $A' \\not\\leq_T B$。\n\nD. 这种分离是不可能的：根据跳跃算子的单调性，对于任何集合 $A$ 和 $B$， $A' \\leq_T B'$ 或 $B' \\leq_T A'$ 至少有一个成立；因此，试图迫使 $A' \\not\\leq_T B'$ 的尝试是徒劳的。\n\nE. 对于每个 $e \\in \\mathbb{N}$，设置 $R_e$：选择 $x_e$ 并在某个阶段 $s$ 当 $\\Phi_e^{B'_s}(x_e)$ 收敛时采取行动，在 $B$ 上施加一个低于在 $s$ 阶段所见使用量的固定约束，并修改 $A$ 来进行对角化。由于约束一旦选定就是固定的，并且因为 $B'$ 是通过一个可计算枚举来近似的，所以简单的有限伤害就足够了，无需追踪由 $B'$-查询引起的对 $B$ 的嵌套使用，也无需借助真实阶段。", "solution": "问题要求对一个优先构造法进行正确描述，该方法用于构造集合 $A, B \\subseteq \\mathbb{N}$ 使得 $A' \\not\\leq_T B'$。\n\n首先，我们必须将目标形式化。为了确保 $A' \\not\\leq_T B'$，我们必须对每个 $e \\in \\mathbb{N}$ 满足需求 $R_e$:\n$$R_e : \\Phi_e^{B'} \\neq \\chi_{A'}$$\n这里, $\\Phi_e$ 是第 $e$ 个部分可计算泛函, $\\chi_{A'}$ 是 $A$ 的图灵跳跃的特征函数, $B'$ 是 $B$ 的图灵跳跃。满足每个 $R_e$ 的策略是找到一个见证 $x_e$, 使得 $\\Phi_e^{B'}(x_e)$ 要么未定义, 要么与 $\\chi_{A'}(x_e)$ 不同。\n\n一个标准的优先构造法分阶段进行，构造最终集合 $A = \\bigcup_s A_s$ 和 $B = \\bigcup_s B_s$ 的有限近似 $A_s$ 和 $B_s$。需求按优先级排序, $R_0, R_1, R_2, \\ldots$。\n\n单个需求 $R_e$ 的策略包含两个主要部分：\n1.  **控制 $\\chi_{A'}(x_e)$**：我们必须能够决定一个特定的数 $x_e$ 是否属于 $A'$。我们通过将 $x_e$ 定义为一个特定图灵归约的指标来实现这一点，该归约的收敛性取决于 $A$。一个简单的方法是选择一个新数（一个“标记”）$m_e$，并定义一个泛函 $\\Psi_{x_e}$，使得 $\\Psi_{x_e}^A(x_e)$ 收敛当且仅当 $m_e \\in A$。那么 $x_e \\in A' \\iff \\Psi_{x_e}^A(x_e) \\downarrow \\iff m_e \\in A$。我们通过决定是否将 $m_e$ 列举到 $A$ 中来控制 $\\chi_{A'}(x_e)$。\n\n2.  **对 $\\Phi_e^{B'}$ 进行对角化**：我们等待机会使 $\\Phi_e^{B'}(x_e)$ 给出“错误”的答案。假设我们想实现 $\\Phi_e^{B'}(x_e)=0$ 和 $\\chi_{A'}(x_e)=1$。我们开始时保持 $m_e \\notin A$，所以我们的目标是 $\\chi_{A'}(x_e)=0$。我们等待一个阶段 $s$，在该阶段计算 $\\Phi_{e,s}^{B'_s}(x_e)$ 看起来收敛到 $0$。\n\n关键的复杂性来自谕示 $B'$。在阶段 $s$，我们用 $B_s$ 近似 $B$，用 $B'_s = \\{ k \\mid \\Phi_{k,s}^{B_s}(k) \\downarrow \\}$ 近似 $B'$。一个计算 $\\Phi_{e,s}^{B'_s}(x_e)\\downarrow$ 使用该谕示 $B'_s$ 的一个有限初始段，比如用到某个使用量 $u_e$。要确定 $B'_s \\upharpoonright u_e$，必须对每个 $k < u_e$ 检查 $\\Phi_{k,s}^{B_s}(k)$ 是否收敛。\n- 如果 $\\Phi_{k,s}^{B_s}(k) \\downarrow$，这次收敛对谕示 $B_s$ 有一个使用量，比如 $v_k$。这是关于 $B'$-谕示的一条“正面”信息。\n- 如果 $\\Phi_{k,s}^{B_s}(k)$ 到阶段 $s$ 还未收敛，我们假设 $k \\notin B'_s$。这是一条“负面”信息。\n\n假设在阶段 $s$，我们观察到 $\\Phi_{e,s}^{B'_s}(x_e) \\downarrow = 0$。为了满足 $R_e$，我们现在可以采取行动，通过将 $m_e$ 列举到 $A$ 中（即 $A_{s+1} = A_s \\cup \\{m_e\\}$）来使 $\\chi_{A'}(x_e)=1$。为了使这个对角化成功，我们必须保持 $\\Phi_e^{B'}(x_e)=0$ 这个结果。这意味着我们必须保护计算中使用的 $B'$ 的谕示答案。\n为了保护“正面”信息（即，对于我们使用的每个 $k \\in B'_s$），我们必须保护底层的 $B$-计算 $\\Phi_k^B(k)$ 不改变其收敛状态。由于向 $B$ 中列举是单调的（$B_s \\subseteq B_{s+1} \\subseteq \\ldots$），一个收敛的计算将保持收敛。我们只需确保其使用量得到尊重。我们在 $B$ 上施加一个约束 $r_e(s+1)$，定义为所有正面 $B'$-查询 $k$ 在 $B_s$ 上的使用量 $\\{v_k\\}$ 的最大值。这个约束禁止任何更低优先级的需求向 $B$ 中添加低于 $r_e(s+1)$ 的数。\n\n“负面”信息是困难的来源。一个在阶段 $s$ 尚未收敛的计算 $\\Phi_k^B(k)$ 可能会在之后的阶段 $t > s$ 收敛，即使 $B$ 没有改变。更有问题的是，一个更高优先级需求 $R_j$ ($j < e$) 的行动可能会向 $B$ 中添加一个数，导致某个 $\\Phi_k^B(k)$ 收敛，从而改变 $B'$ 并“伤害”我们为 $R_e$ 所做的计算。\n\n如果一个更高优先级的需求 $R_j$ ($j<e$) 将一个数列表举到 $B$ 中，且该数低于 $R_e$ 的当前约束 $r_e$，就会对 $R_e$ 造成伤害。这会使近似 $B'_s$ 失效并破坏对角化。当 $R_e$ 受伤时，它必须放弃其尝试并等待新的机会。\n\n这个过程之所以能成功（即每个需求只受有限次伤害）的论证，依赖于这样一个事实：当 $R_e$ 受伤并在之后的阶段 $s'$ 再次尝试时，它采取行动的条件必须有所不同。通常，计算在谕示 $B'_{s'}$ 上的使用量或在底层的 $B_{s'}$ 上的使用量必须增加。这与寻找一个“真实阶段”的想法有关——一个阶段，其中有限近似 $B'_s$ 对于正在进行的查询是正确的。由于更高优先级的需求只有有限个，通过归纳法，它们只受有限次伤害，因此将存在一个最终阶段，在此之后它们不再行动。届时，$R_e$ 将能够行动，施加一个永久约束，并在不受进一步伤害的情况下满足其需求。这是一个有限伤害优先论证的精髓，因 $B'$-谕示的嵌套性质而变得复杂。\n\n现在我们根据这个分析来评估这些选项。\n\n**A.** 这个选项正确地提出了需求 $R_e$ 是要对角化 $\\Phi_e^{B'}$ 以对抗 $\\chi_{A'}$。它准确地描述了策略：等待一个收敛 $\\Phi_e^{B'_s}(x_e)$，然后通过一个受控的标记对 $A$ 采取行动以翻转 $\\chi_{A'}(x_e)$ 的值。它正确地指出这涉及到在 $B$ 上施加一个约束 $r_e(s)$，以保护建立 $B'$-谕示正面部分所需的基础 $B$-计算。它正确地将伤害定义为更高优先级的需求违反了对 $B$ 的约束的行为。关键是，它提到了等待一个“具有更大使用量的后续真实阶段”，承认了处理不稳定的 $B'$-近似的复杂性。它正确地得出结论，这个策略导致每个需求只遭受有限次伤害，从而确保所有需求都被满足。这个描述是准确和全面的。**正确**。\n\n**B.** 这个选项有根本性的错误。人们不能“直接将元素列举到 $B'$ 中”，因为 $B'$ 是一个被定义的集合，而不是被构造的集合。其成员资格由相对于 $B$ 的计算决定。“$B'$ 决定 $B$”的说法是错误的；依赖关系是相反的。 “从不改变 $B$”的策略与构建该集合的优先构造法是不兼容的。**不正确**。\n\n**C.** 这个选项描述了一个用于 $A' \\not\\leq_T B$ 的构造，而不是 $A' \\not\\leq_T B'$。需求被陈述为 $\\Phi_e^B \\neq \\chi_{A'}$，它直接使用谕示 $B$，而不是它的跳跃 $B'$。这是一个不同的、更简单的问题。**不正确**。\n\n**D.** 这个选项做出了一个错误的论断。跳跃的图灵度不是线性排序的。可计算性理论中的一个已知结果是，存在集合 $A$ 和 $B$，其跳跃 $A'$ 和 $B'$ 是图灵不可比的。问题要求的是构造这类集合的方法。**不正确**。\n\n**E.** 这个选项正确地指出了施加约束和修改 $A$ 的高层策略。然而，它包含关键错误。它错误地声称约束“一旦选定就是固定的”，这忽略了伤害。它错误地陈述 $B'$ 是通过一个“可计算枚举”来近似的。最重要的是，它忽略了核心的技术挑战，声称一个“简单的有限伤害”论证就足够了，*而无需*“追踪由 $B'$-查询引起的对 $B$ 的嵌套使用”或“借助真实阶段”。而这些正​​是处理 $B'$-谕示复杂性所必需的技术。通过否认它们的必要性，这个选项提出了一个不充分且不正确的策略。**不正确**。\n\n总之，选项 A 提供了对正确策略的唯一准确且足够详细的描述。", "answer": "$$\\boxed{A}$$", "id": "2986205"}]}