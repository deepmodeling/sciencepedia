{"hands_on_practices": [{"introduction": "可构造宇宙 $L$ 是逐层构建的。要深入理解这个层级结构，关键在于弄清楚我们熟悉的数学对象在“何时”以及“如何”于其中出现。一个对象 $x$ 首次出现的层级由其“可构造秩”$r_L(x)$ 决定，即满足 $x \\in L_{\\alpha+1}$ 的最小序数 $\\alpha$。通过计算第一个无限序数 $\\omega$ 的秩，本练习将引导你亲手实践这一基本定义，从而对 $L$ 的构造过程以及集合的可定义性获得具体而深刻的理解。[@problem_id:2985165]", "problem": "完全在可构造层级中进行讨论。令 $L_{0}=\\varnothing$，令 $L_{\\alpha+1}=\\mathrm{Def}(L_{\\alpha})$ 为所有可用 $L_{\\alpha}$ 中的参数在结构 $\\langle L_{\\alpha},\\in\\rangle$ 上作一阶定义的 $L_{\\alpha}$ 的子集构成的集合，对极限序数 $\\lambda$，令 $L_{\\lambda}=\\bigcup_{\\xi<\\lambda}L_{\\xi}$。$L$ 的典范全局良序 $<_L$ 是通过为每个 $x\\in L$ 分配一个典范编码得到的，该编码的第一个坐标是满足 $x\\in L_{\\alpha+1}$ 的最小序数 $\\alpha$，然后在固定的 $\\alpha$ 处，使用固定的公式 Gödel 编码以及对来自 $L_{\\alpha}$ 的参数元组（参数元组本身按 $<_L$ 排序）的固定字典序来解除并列关系。对于 $x\\in L$，定义其第一坐标的 $<_L$-秩为\n$$\nr_L(x)=\\min\\{\\alpha:\\ x\\in L_{\\alpha+1}\\}.\n$$\n仅使用这些定义以及关于有限和极限阶段可定义性的基本性质，计算 $r_L(\\omega)$，其中 $\\omega$ 是最小的无限序数。此外，请解释（无需计算任何进一步的用于解除并列的编码）$r_L(\\omega)$ 的值如何决定 $\\omega$ 在 $L$ 的全局编码方案中相对于来自更低和更高层级的所有集合的位置。你的最终答案必须是关于 $r_L(\\omega)$ 的一个单一的精确序数表达式（无需近似）。", "solution": "问题要求计算 $r_{L}(\\omega)$，其中 $r_{L}(x) = \\min\\{\\alpha : x \\in L_{\\alpha+1}\\}$，且 $\\omega$ 是最小的无限序数。可构造层级 $L$ 的定义由以下给出：$L_{0} = \\varnothing$；$L_{\\alpha+1} = \\mathrm{Def}(L_{\\alpha})$；以及对极限序数 $\\lambda$ 有 $L_{\\lambda} = \\bigcup_{\\xi < \\lambda} L_{\\xi}$。\n\n要找到 $r_{L}(\\omega)$，我们必须找到满足 $\\omega \\in L_{\\alpha+1}$ 的最小序数 $\\alpha$。这等价于找到最小的 $\\alpha$，使得 $\\omega$ 是 $L_{\\alpha}$ 的一个可用 $L_{\\alpha}$ 中的参数定义出来的子集。对于这样的一个 $\\alpha$，需要满足两个条件：\n1.  $\\omega \\subseteq L_{\\alpha}$。\n2.  $\\omega$ 可以使用带 $L_{\\alpha}$ 中参数的一阶公式在结构 $\\langle L_{\\alpha}, \\in \\rangle$ 中被定义。\n\n首先，我们来确定 $\\alpha$ 的一个下界。要使 $\\omega \\subseteq L_{\\alpha}$，$\\omega$的每个元素，即每个有限 von Neumann 序数 $n \\in \\omega$，都必须是 $L_{\\alpha}$ 的一个元素。我们来考察层级的前几个阶段，看看有限序数是在哪里被构造出来的。\n\n-   $L_{0} = \\varnothing$。\n-   $L_{1} = \\mathrm{Def}(L_{0}) = \\mathrm{Def}(\\varnothing)$。空集的唯一可定义子集是 $\\varnothing$ 本身（例如，通过公式 $x \\neq x$）。因此，$L_{1} = \\{\\varnothing\\} = \\{0\\}$。\n-   $L_{2} = \\mathrm{Def}(L_{1}) = \\mathrm{Def}(\\{0\\})$。因为 $L_{1}$ 是有限的，所以 $L_{1}$ 的任何子集都可用参数定义。 $L_{1}$ 的子集是 $\\varnothing=0$ 和 $\\{0\\}=1$。所以，$L_{2} = \\{0, 1\\}$。\n-   $L_{3} = \\mathrm{Def}(L_{2}) = \\mathrm{Def}(\\{0, 1\\})$。因为 $L_{2}$ 是有限的，$L_{3} = \\mathcal{P}(L_{2}) = \\{\\varnothing, \\{0\\}, \\{1\\}, \\{0,1\\}\\} = \\{0, 1, \\{1\\}, 2\\}$。\n-   一般地，对于任何有限序数 $n > 0$，集合 $L_{n}$ 是有限的。一个关键性质是，对于任何有限的 $n$，$L_{n+1} = \\mathcal{P}(L_{n})$，因为有限集的任何子集都可用参数定义。\n\n现在我们来确定有限序数 $n$ 的 $r_{L}(n)$。序数 $n$ 是集合 $\\{0, 1, \\dots, n-1\\}$。要使 $n$ 成为 $L_{k+1}$ 的一个元素，必须有 $n \\subseteq L_{k}$。这意味着对于每个 $m < n$，我们必须有 $m \\in L_{k}$。通过归纳，可以证明对于任何有限序数 $m$，使得 $m \\in L_{\\beta}$ 的最小 $\\beta$ 是：如果 $m=0,1$ 则 $\\beta=m+1$，如果 $m \\ge 2$ 则 $\\beta=m$。实际上，标准结果是对于有限序数 $m$，$m \\in L_{m+1}$ 且 $m \\notin L_m$。我们来证明对于 $m \\in \\omega$ 有 $r_L(m)=m$。\n-   $r_{L}(0)=0$ 因为 $0=\\varnothing \\in L_{1}=\\mathrm{Def}(L_0)$。\n-   $r_{L}(1)=1$ 因为 $1=\\{0\\} \\subseteq L_1$ 且在 $L_1$ 上可定义，所以 $1 \\in L_2$。它不在 $L_1$ 中。\n-   假设对所有 $k<n$ 有 $r_{L}(k)=k$。这意味着 $k \\in L_{k+1}$ 但 $k \\notin L_{k}$。要使 $n=\\{0, \\dots, n-1\\} \\in L_{\\alpha+1}$，我们需要 $n \\subseteq L_{\\alpha}$。这要求 $n-1 \\in L_{\\alpha}$。根据归纳假设，$r_L(n-1)=n-1$，所以 $n-1 \\in L_n$ 且 $n-1 \\notin L_{n-1}$。因此，要使 $n-1 \\in L_{\\alpha}$，我们必须有 $\\alpha \\ge n$。所以，使得 $n \\subseteq L_{\\alpha}$ 的最小可能值是 $\\alpha=n$。\n-   当 $\\alpha=n$ 时，我们有 $\\{0, \\dots, n-1\\} \\subseteq L_n$。因为 $L_n$ 是有限的， $n$ 是 $L_n$ 的一个可定义子集（带参数）。因此，$n \\in \\mathrm{Def}(L_n) = L_{n+1}$。\n-   因为我们必须有 $\\alpha \\ge n$，所以 $\\alpha$ 的最小值是 $n$。因此，对所有 $n \\in \\omega$ 有 $r_{L}(n) = n$。\n\n要使 $\\omega = \\{0, 1, 2, \\dots\\}$ 成为 $L_{\\alpha}$ 的子集，每个 $n \\in \\omega$ 都必须在 $L_{\\alpha}$ 中。因为 $r_{L}(n)=n$，我们知道 $n \\in L_{n+1}$。层级是累积的，即对于 $k \\le m$ 有 $L_k \\subseteq L_m$。为了让 $L_{\\alpha}$ 包含所有 $n \\in \\omega$，$\\alpha$ 必须对所有 $n \\in \\omega$ 都满足大于或等于 $n+1$。这意味着 $\\alpha$ 不可能是有限序数。满足对所有 $n \\in \\omega$ 都有 $\\alpha \\ge n+1$ 的最小序数 $\\alpha$ 是 $\\omega$ 本身，即 $\\alpha \\ge \\omega$。\n因此，使得 $\\omega \\subseteq L_{\\alpha}$ 的最小可能值 $\\alpha$ 是 $\\alpha=\\omega$。\n我们来检查是否 $\\omega \\subseteq L_{\\omega}$。根据定义，$L_{\\omega} = \\bigcup_{n < \\omega} L_{n}$。对于任何 $k \\in \\omega$，我们知道 $r_{L}(k)=k$，所以 $k \\in L_{k+1}$。因为 $k+1 < \\omega$，我们有 $L_{k+1} \\subseteq L_{\\omega}$。因此，对所有 $k \\in \\omega$ 都有 $k \\in L_{\\omega}$。这证实了 $\\omega \\subseteq L_{\\omega}$。\n\n现在我们必须检查第二个条件：$\\omega$ 在结构 $\\langle L_{\\omega}, \\in \\rangle$ 中是否可定义？我们需要找到一个无参数的一阶公式 $\\phi(x)$，使得 $\\omega = \\{x \\in L_{\\omega} \\mid \\langle L_{\\omega}, \\in \\rangle \\models \\phi(x)\\}$。\n作为 von Neumann 序数的性质在一阶集合论中是可定义的。一个常见的表述是 $\\mathrm{Ord}(x) \\equiv \\mathrm{Trans}(x) \\land (\\forall y \\in x)\\mathrm{Trans}(y)$，其中 $\\mathrm{Trans}(z) \\equiv (\\forall u \\in z)(u \\subseteq z)$。传递性的公式是一个 $\\Delta_0$ 公式（所有量词都有界）。因此，$\\mathrm{Ord}(x)$ 公式对于集合论某个包含 $L_{\\omega}$ 的充分片段的传递模型是绝对的。\n这意味着，对于任何集合 $x \\in L_{\\omega}$，陈述“x 是一个序数”在 $L_{\\omega}$ 中为真当且仅当它在整个宇宙 $V$ 中为真。\n令 $\\phi_{\\mathrm{Ord}}(x)$ 为这个一阶公式。此公式在 $L_{\\omega}$ 上定义的集合是 $\\{x \\in L_{\\omega} \\mid x \\text{ 是一个序数}\\}$。这个集合恰好是 $L_{\\omega} \\cap \\mathrm{Ord}$。\n可构造层级的一个基本定理指出，对于任何极限序数 $\\lambda$，$L_{\\lambda} \\cap \\mathrm{Ord} = \\lambda$。令 $\\lambda = \\omega$，我们得到 $L_{\\omega} \\cap \\mathrm{Ord} = \\omega$。\n因此，公式 $\\phi_{\\mathrm{Ord}}(x)$ 在结构 $\\langle L_{\\omega}, \\in \\rangle$ 上无需参数就定义了集合 $\\omega$。\n因为 $\\omega$ 是 $L_{\\omega}$ 的一个可定义子集，我们有 $\\omega \\in \\mathrm{Def}(L_{\\omega}) = L_{\\omega+1}$。\n这表明 $r_{L}(\\omega) \\le \\omega$。\n\n结合我们的发现：\n1. 我们证明了要使 $\\omega \\subseteq L_{\\alpha}$，必须有 $\\alpha \\ge \\omega$。这意味着 $r_{L}(\\omega) \\ge \\omega$。\n2. 我们证明了 $\\omega$ 是 $L_{\\omega}$ 的一个可定义子集，这意味着 $\\omega \\in L_{\\omega+1}$。这又意味着 $r_{L}(\\omega) \\le \\omega$。\n\n由 $r_{L}(\\omega) \\ge \\omega$ 和 $r_{L}(\\omega) \\le \\omega$，我们得出结论 $r_{L}(\\omega)=\\omega$。\n\n问题的第二部分询问这个值如何决定 $\\omega$ 在全局良序 $<_{L}$ 中的相对位置。序 $<_{L}$ 是在典范编码 $(\\alpha, \\ulcorner\\phi\\urcorner, p)$ 上按字典序定义的，其中 $\\alpha=r_L(x)$ 是主排序键。\n-   对于任何满足 $r_{L}(x) < r_{L}(\\omega) = \\omega$ 的集合 $x$，我们有 $x <_{L} \\omega$。$r_{L}(x) < \\omega$ 的集合 $x$ 正是 $L_{\\omega} = \\bigcup_{n<\\omega}L_{n+1}$ 的元素。所以，$\\omega$ 排在每一个在有限阶段构造出的集合之后。\n-   对于任何满足 $r_{L}(y) > r_{L}(\\omega) = \\omega$ 的集合 $y$，我们有 $\\omega <_{L} y$。这些是所有首次出现在某个层级 $L_{\\alpha+1}$（对于序数 $\\alpha > \\omega$）中的集合。\n-   对于任何满足 $r_{L}(z) = r_{L}(\\omega) = \\omega$ 的集合 $z$，$z$ 和 $\\omega$ 的相对顺序由解除并列的规则决定：定义公式的 Gödel 数和参数的字典序。\n-   由于 $\\omega$ 是由无参数公式 $\\phi_{\\mathrm{Ord}}(x)$ 定义的，它在 $L_{\\omega+1} \\setminus L_{\\omega}$ 中其他集合间的位置，取决于分配给 $\\phi_{\\mathrm{Ord}}(x)$ 的 Gödel 数相对于定义此阶段构造的其他集合的公式的 Gödel 数。\n\n总之，$r_L(\\omega)=\\omega$ 将 $\\omega$ 在 $<_L$ 序中置于所有 $L_\\omega$ 中的集合之后，以及所有在高于 $\\omega+1$ 的层级中构造的集合之前。", "answer": "$$\\boxed{\\omega}$$", "id": "2985165"}, {"introduction": "在掌握了 $L$ 的内部构造后，一个自然的问题是它如何与其他数学结构建立联系。Mostowski 同构定理为此提供了强有力的理论工具，它断言任何良基的外延结构都同一个以标准隶属关系 $\\in$ 作为其关系的传递集同构。这个练习将让你在一个具体的有限结构上动手执行“Mostowski 塌陷”，即这一同构的显式构造过程。这不仅能帮助你直观地理解该定理的内涵，还能让你体验到如何将抽象的关系结构转化为集合论宇宙中的具体对象，这是模型论中的一项基本技能。[@problem_id:2985160]", "problem": "在 Zermelo–Fraenkel 集合论 (ZF) 的框架下，并在可构造全集 $L$ 中进行讨论。回顾一下，可构造全集 $L$ 包含所有遗传有限集，特别地，包含所有 von Neumann 自然数。考虑有限的 $L$-编码结构 $\\langle A, E \\rangle$，其中论域为 $A = \\{0,1,2,3\\}$（视为 von Neumann 序数，因此也是集合），二元关系 $E \\subseteq A \\times A$ 由下式给出：\n$$\nE \\;=\\; \\{\\langle 0,1\\rangle, \\langle 0,2\\rangle, \\langle 1,2\\rangle, \\langle 0,3\\rangle, \\langle 2,3\\rangle\\},\n$$\n此处采用 Kuratowski 编码 $\\langle x,y\\rangle = \\{\\{x\\}, \\{x,y\\}\\}$。因此，对于 $a,b \\in A$，当且仅当 $\\langle b,a\\rangle \\in E$ 时，我们有 $b \\,E\\, a$。\n\n请仅使用关于 $L$ 中的良基外延关系和 Mostowski 塌缩的基础定义和经过充分检验的事实（不借助任何预先给出的简化公式），完成以下任务：\n\n- 证明 $\\langle A, E \\rangle$ 是一个良基外延结构。\n- 应用 Mostowski 塌缩，得到传递集 $M \\subseteq L$ 和同构 $\\pi \\colon \\langle A, E \\rangle \\to \\langle M, \\in \\rangle$，并为每个 $a \\in A$ 显式地计算出 $\\pi(a)$。\n- 计算传递集 $M$ 的累积层级序 $\\operatorname{rank}(M)$。\n\n请给出 $\\operatorname{rank}(M)$ 的精确值（一个整数）作为最终答案。无需四舍五入。", "solution": "问题要求我们在 Zermelo-Fraenkel 集合论 (ZF) 内部分析一个有限结构 $\\langle A, E \\rangle$，计算其 Mostowski 塌缩，并确定所得传递集的序。题目指定在可构造全集 $L$ 中进行，它是 ZF 的一个标准内模型。本问题中的所有集合都是有限的，并且可以从空集通过有限步构造出来，因此它们是遗传有限的。所有遗传有限集都属于 $L$（具体来说，属于 $L_\\omega$），所以这个条件是自然满足的。\n\n该结构是 $\\langle A, E \\rangle$，其中论域为 $A = \\{0, 1, 2, 3\\}$，其元素为 von Neumann 序数。$A$ 上的二元关系 $E$ 由以下有序对集合给出：\n$$E = \\{\\langle 0,1\\rangle, \\langle 0,2\\rangle, \\langle 1,2\\rangle, \\langle 0,3\\rangle, \\langle 2,3\\rangle\\}$$\n问题陈述“对于 $a,b \\in A$，当且仅当 $\\langle b,a\\rangle \\in E$ 时，我们有 $b \\,E\\, a$”。这是关系 $E$ 的中缀表示法的形式化定义。因此，该关系对集合 $E$ 中列出的有序对成立。例如，$0 E 1$ 成立，因为 $\\langle 0,1\\rangle \\in E$。\n\n第一步是证明 $\\langle A, E \\rangle$ 是一个良基外延结构，这是 Mostowski 同构定理的前提条件。\n\n**1. 良基性与外延性**\n\n如果 $A$ 的每个非空子集都有一个 $E$-极小元，则称集合 $A$ 上的关系 $E$ 是**良基的**。如果不存在 $y \\in S$ 使得 $y E x$，则元素 $x \\in S \\subseteq A$ 是 $S$ 中的 $E$-极小元。对于有限集 $A$，这等价于对应于关系 $E$ 的有向图中没有环。关系 $E$ 对应于顶点集 $A = \\{0, 1, 2, 3\\}$ 上的以下有向边：\n$0 \\to 1$, $0 \\to 2$, $1 \\to 2$, $0 \\to 3$, $2 \\to 3$。\n我们可以检查此图中的路径：\n- $0 \\to 1 \\to 2 \\to 3$\n- $0 \\to 2 \\to 3$\n- $0 \\to 3$\n没有从同一顶点出发并回到该顶点的路径。因此，没有环。所以关系 $E$ 是良基的。\n\n如果对于 $A$ 中任意两个不同元素 $x, y$，它们关于 $E$ 的外延（或前驱集）是不同的，则称集合 $A$ 上的关系 $E$ 是**外延的**。也就是说，对于所有 $x, y \\in A$，如果 $x \\neq y$，则 $\\{z \\in A \\mid z E x\\} \\neq \\{z \\in A \\mid z E y\\}$。\n让我们为每个元素 $a \\in A$ 计算其前驱集，我们记为 $\\text{pred}_E(a) = \\{x \\in A \\mid x E a\\}$。\n- 对于 $a=0$：不存在 $x \\in A$ 使得 $\\langle x,0\\rangle \\in E$。所以 $\\text{pred}_E(0) = \\emptyset$。\n- 对于 $a=1$：$E$ 中以 $1$ 为第二分量的唯一有序对是 $\\langle 0,1\\rangle$。所以 $\\text{pred}_E(1) = \\{0\\}$。\n- 对于 $a=2$：以 $2$ 结尾的有序对是 $\\langle 0,2\\rangle$ 和 $\\langle 1,2\\rangle$。所以 $\\text{pred}_E(2) = \\{0, 1\\}$。\n- 对于 $a=3$：以 $3$ 结尾的有序对是 $\\langle 0,3\\rangle$ 和 $\\langle 2,3\\rangle$。所以 $\\text{pred}_E(3) = \\{0, 2\\}$。\n\n前驱集为：\n- $\\text{pred}_E(0) = \\emptyset$\n- $\\text{pred}_E(1) = \\{0\\}$\n- $\\text{pred}_E(2) = \\{0, 1\\}$\n- $\\text{pred}_E(3) = \\{0, 2\\}$\n因为所有这些集合都是不同的，所以关系 $E$ 是外延的。\n\n**2. Mostowski 塌缩**\n\n由于 $\\langle A, E \\rangle$ 是一个良基外延结构，Mostowski 同构定理适用。它保证了存在唯一的传递集 $M$ 和唯一的同构 $\\pi \\colon \\langle A, E \\rangle \\to \\langle M, \\in \\rangle$，其中 $\\in$ 是标准的成员关系。同构 $\\pi$ 通过对良基关系 $E$ 的递归来定义：\n$$ \\pi(a) = \\{ \\pi(b) \\mid b \\in A \\text{ and } b E a \\} = \\{ \\pi(b) \\mid b \\in \\text{pred}_E(a) \\} $$\n我们为每个 $a \\in A$ 计算 $\\pi(a)$ 的值，从 $E$-极小元开始。\n\n- 唯一的 $E$-极小元是 $0$，因为 $\\text{pred}_E(0)=\\emptyset$。\n$$ \\pi(0) = \\{ \\pi(b) \\mid b \\in \\text{pred}_E(0) \\} = \\{ \\pi(b) \\mid b \\in \\emptyset \\} = \\emptyset $$\n集合 $\\emptyset$ 是 von Neumann 序数 $0$。\n\n- 接下来，我们计算 $\\pi(1)$，其前驱集只包含 $0$。\n$$ \\pi(1) = \\{ \\pi(b) \\mid b \\in \\text{pred}_E(1) \\} = \\{ \\pi(0) \\} = \\{ \\emptyset \\} $$\n这是 von Neumann 序数 $1$。\n\n- 接下来，我们计算 $\\pi(2)$，其前驱是 $0$ 和 $1$。\n$$ \\pi(2) = \\{ \\pi(b) \\mid b \\in \\text{pred}_E(2) \\} = \\{ \\pi(0), \\pi(1) \\} = \\{ \\emptyset, \\{\\emptyset\\} \\} $$\n这是 von Neumann 序数 $2$。\n\n- 最后，我们计算 $\\pi(3)$，其前驱是 $0$ 和 $2$。\n$$ \\pi(3) = \\{ \\pi(b) \\mid b \\in \\text{pred}_E(3) \\} = \\{ \\pi(0), \\pi(2) \\} = \\{ \\emptyset, \\{\\emptyset, \\{\\emptyset\\}\\} \\} $$\n用 von Neumann 序数表示，这是集合 $\\{0, 2\\}$。\n\n所以，同构 $\\pi$ 的值为：\n- $\\pi(0) = 0$\n- $\\pi(1) = 1$\n- $\\pi(2) = 2$\n- $\\pi(3) = \\{0, 2\\}$\n\n传递集 $M$ 是 $A$ 在 $\\pi$ 下的像：\n$$ M = \\pi[A] = \\{\\pi(0), \\pi(1), \\pi(2), \\pi(3)\\} = \\{0, 1, 2, \\{0, 2\\}\\} $$\n我们可以验证 $M$ 是传递的。如果对所有 $y \\in X$，都有 $y \\subseteq X$，则集合 $X$ 是传递的。\n- $0 = \\emptyset \\subseteq M$。\n- $1 = \\{0\\}$，并且 $0 \\in M$，所以 $1 \\subseteq M$。\n- $2 = \\{0, 1\\}$，并且 $0,1 \\in M$，所以 $2 \\subseteq M$。\n- $\\{0, 2\\}$，并且 $0,2 \\in M$，所以 $\\{0, 2\\} \\subseteq M$。\n集合 $M$ 确实是传递的。\n\n**3. 传递集 M 的序**\n\n最后的任务是计算集合 $M$ 在累积层级中的序。集合 $x$ 的序由超限递归定义如下：\n$$ \\operatorname{rank}(x) = \\sup \\{ \\operatorname{rank}(y) + 1 \\mid y \\in x \\} $$\n空集的序为 $0$。对于任何序数 $\\alpha$，有 $\\operatorname{rank}(\\alpha)=\\alpha$。\n\n为了计算 $\\operatorname{rank}(M)$，我们首先需要其元素 $0$, $1$, $2$ 和 $\\{0, 2\\}$ 的序。\n- $\\operatorname{rank}(0) = 0$。\n- $\\operatorname{rank}(1) = 1$。\n- $\\operatorname{rank}(2) = 2$。\n- 对于集合 $\\{0, 2\\}$：\n  $$ \\operatorname{rank}(\\{0, 2\\}) = \\sup\\{\\operatorname{rank}(0) + 1, \\operatorname{rank}(2) + 1\\} $$\n  $$ \\operatorname{rank}(\\{0, 2\\}) = \\sup\\{0 + 1, 2 + 1\\} = \\sup\\{1, 3\\} = 3 $$\n\n现在，我们可以计算 $M$ 本身的序了：\n$$ M = \\{0, 1, 2, \\{0, 2\\}\\} $$\n$$ \\operatorname{rank}(M) = \\sup\\{\\operatorname{rank}(0)+1, \\operatorname{rank}(1)+1, \\operatorname{rank}(2)+1, \\operatorname{rank}(\\{0,2\\})+1\\} $$\n代入我们计算出的序：\n$$ \\operatorname{rank}(M) = \\sup\\{0+1, 1+1, 2+1, 3+1\\} $$\n$$ \\operatorname{rank}(M) = \\sup\\{1, 2, 3, 4\\} $$\n这个序数集合的上确界是最大的元素，即 $4$。\n$$ \\operatorname{rank}(M) = 4 $$", "answer": "$$\\boxed{4}$$", "id": "2985160"}, {"introduction": "可构造宇宙 $L$ 的许多深刻性质，如广义连续统假设 (GCH) 的一致性，其证明都依赖于精细结构理论中的核心工具——凝聚引理 (Condensation Lemma)。而凝聚引理的基石正是 $\\Sigma_1$-Skolem 闭包的构造。一个集合 $A$ 在结构 $L_\\alpha$ 中的 $\\Sigma_1$-Skolem 闭包是在 $\\Sigma_1$ 可定义函数下封闭的最小集合，它包含了所有由 $A$ 中元素能“简单逻辑推导”出的元素。通过在一个小而可控的层级 $L_3$ 中显式地计算一个 Skolem 闭包，本练习将让你亲身体验这一构造过程，从而对 $L$ 的精细结构和凝聚引理的运作机制获得关键的洞察。[@problem_id:2985176]", "problem": "在 Zermelo–Fraenkel 集合论（ZFC）和 Gödel 可构造层级的框架下进行讨论。回顾一下，可构造宇宙由 $L=\\bigcup_{\\alpha\\in\\mathrm{Ord}}L_{\\alpha}$ 给出，其中 $L_{0}=\\emptyset$，$L_{\\beta+1}=\\mathrm{Def}(L_{\\beta})$ 是 $L_{\\beta}$ 的所有子集的集合，这些子集可以在结构 $\\langle L_{\\beta},\\in\\rangle$ 上使用来自 $L_{\\beta}$ 的参数来定义，对于极限序数 $\\lambda$，$L_{\\lambda}=\\bigcup_{\\beta<\\lambda}L_{\\beta}$。如果一个公式的所有量词都是有界的，则称其为 $\\Delta_{0}$ 公式；如果其形式为 $\\exists u\\,\\varphi(u,\\vec{v})$，其中 $\\varphi$ 是 $\\Delta_{0}$ 公式，则称其为 $\\Sigma_{1}$ 公式。对于一个固定的序数 $\\alpha$ 和一个子集 $A\\subseteq L_{\\alpha}$，$A$ 在 $L_{\\alpha}$ 中的 $\\Sigma_{1}$-Skolem 壳，记作 $\\mathrm{Hull}_{\\Sigma_{1}}^{L_{\\alpha}}(A)$，是包含 $A$ 的最小子集 $H\\subseteq L_{\\alpha}$，使得对于每个具有 $\\Delta_{0}$ 母式 $\\varphi$ 的 $\\Sigma_{1}$ 公式 $\\exists u\\,\\varphi(u,\\vec{v})$ 和每个元组 $\\vec{a}\\in H^{k}$，如果 $L_{\\alpha}\\models\\exists u\\,\\varphi(u,\\vec{a})$，则 $H$ 包含满足 $L_{\\alpha}\\models\\varphi(b,\\vec{a})$ 的 $<_L$-最小见证 $b\\in L_{\\alpha}$，其中 $<_L$ 是 $L$ 的典范良序。\n\n你的任务：\n\n1. 从上述基本定义出发，引入一个固定的 Gödel 配数方案，用自然数对公式和有限参数元组进行编码（例如，用素数幂乘积对有限序列编码，通过有限字母表对句法字符串编码）。利用这个方案，形式化地定义一个在 $\\mathbb{N}$ 上的全函数，其值域包含在 $\\mathrm{Hull}_{\\Sigma_{1}}^{L_{\\alpha}}(A)$ 中，并论证该值域穷尽了 $\\mathrm{Hull}_{\\Sigma_{1}}^{L_{\\alpha}}(A)$。从第一性原理推断，当 $A$ 是有限集时，$\\mathrm{Hull}_{\\Sigma_{1}}^{L_{\\alpha}}(A)$ 在外围宇宙 $V$ 中是可数的。\n\n2. 对于 $\\alpha=3$ 和 $A=\\{\\emptyset\\}\\subseteq L_{3}$ 这个具体情况，通过系统地应用带有 $\\Delta_{0}$ 母式的 $\\Sigma_{1}$ Skolem 函数，并使用从演进中的壳中抽取的参数，总是选取 $L_3$ 中的 $<_L$-最小见证，来显式地计算 $\\mathrm{Hull}_{\\Sigma_{1}}^{L_{3}}(A)$ 作为 $L_3$ 的一个子集。提供一个完整的推导过程，识别出壳中的每一个元素。\n\n将 $\\mathrm{Hull}_{\\Sigma_{1}}^{L_{3}}(\\{\\emptyset\\})$ 的精确基数作为你的最终答案。无需四舍五入。", "solution": "该问题分为两部分。第一部分要求在给定有限生成集的情况下，对 $\\Sigma_{1}$-Skolem 壳的可数性进行一般性证明。第二部分要求对一个特定的 Skolem 壳进行显式计算。\n\n### 第一部分：$\\Sigma_{1}$-Skolem 壳的可数性\n\n设 $\\alpha$ 为一个固定序数， $A \\subseteq L_{\\alpha}$ 为一个有限集。我们要证明 $H = \\mathrm{Hull}_{\\Sigma_{1}}^{L_{\\alpha}}(A)$ 是可数的。\n\n首先，我们为集合论的句法建立一个 Gödel 配数法。集合论的语言由一组有限的符号组成：逻辑联结词（$\\neg$, $\\land$）、量词（$\\exists$）、变量（$v_i$ for $i \\in \\mathbb{N}$）、括号以及二元关系符号 $\\in$ 和 $=$。我们可以为每个符号分配一个唯一的自然数。一个公式是这些符号的有限序列。我们可以将一个自然数的有限序列 $n_1, \\dots, n_k$ 编码成一个单一的自然数，例如，使用素因子分解 $2^{n_1} 3^{n_2} \\cdots p_k^{n_k}$，其中 $p_k$ 是第 $k$ 个素数。这就为每个公式 $\\varphi$ 分配了一个唯一的 Gödel 数 $\\ulcorner\\varphi\\urcorner \\in \\mathbb{N}$。\n\n一个公式如果是 $\\Delta_0$ 的，那么它的所有量词都是有界的，形如 $\\exists x \\in y$ 或 $\\forall x \\in y$。一个公式如果是 $\\Sigma_1$ 的，那么它的形式是 $\\exists u\\, \\varphi(u, \\vec{v})$，其中 $\\varphi$ 是一个 $\\Delta_0$ 公式。一个公式是否是合式公式、$\\Delta_0$ 公式或 $\\Sigma_1$ 公式，这些都是句法属性，可以根据其 Gödel 数通过算法判定。因此，我们可以有效地枚举所有 $\\Sigma_1$ 公式。设这个枚举为 $\\psi_0, \\psi_1, \\psi_2, \\dots$。\n\n壳 $H = \\mathrm{Hull}_{\\Sigma_{1}}^{L_{\\alpha}}(A)$ 是 $A$ 在所有 $\\Sigma_1$ Skolem 函数下的闭包。我们可以通过迭代应用这些函数来构造 $H$。令 $H_0 = A$。对于每个自然数 $n \\ge 0$，我们从 $H_n$ 定义 $H_{n+1}$ 如下：\n$$H_{n+1} = H_n \\cup \\{ b \\in L_{\\alpha} \\mid \\exists k \\in \\mathbb{N}, \\exists \\vec{p} \\in (H_n)^k, (\\text{$b$ 是 $L_{\\alpha} \\models \\psi_k(\\vec{p})$ 的 $<_L$-最小见证}) \\}$$\n壳是这个集合链的并集：$H = \\bigcup_{n \\in \\mathbb{N}} H_n$。\n\n给定 $A$ 是一个有限集，所以 $|H_0| = |A|$ 是有限的。\n现在，假设 $H_n$ 是可数的。所有来自 $H_n$ 的可能参数元组的集合是 $\\bigcup_{k \\in \\mathbb{N}} (H_n)^k$。每个 $(H_n)^k$ 是可数集的有限积，因此是可数的。这个并集是可数个可数集的并集，因此是可数的。$\\Sigma_1$ 公式的集合也是可数的。\n在阶段 $n$ 的“见证请求”集合是形如 $(\\psi_i, \\vec{p})$ 的对的集合，其中 $i \\in \\mathbb{N}$ 并且 $\\vec{p} \\in (H_n)^k$（对于适当的 $k$）。这是一个形如 $\\mathbb{N} \\times \\bigcup_{k \\in \\mathbb{N}} (H_n)^k$ 的集合，是两个可数集的积，因此是可数的。\n对于每个这样的请求，最多只有一个见证（$<L$-最小的那个）。因此，为形成 $H_{n+1}$ 而添加的所有新见证的集合也是可数的。\n由于 $H_{n+1}$ 是两个可数集（$H_n$ 和新见证的集合）的并集，所以 $H_{n+1}$ 也是可数的。\n通过归纳法，从 $H_0$ 是有限的（因此是可数的）开始，对于所有 $n \\in \\mathbb{N}$，$H_n$ 都是可数的。\n壳 $H = \\bigcup_{n \\in \\mathbb{N}} H_n$ 是可数个可数集的并集，因此在外围宇宙 $V$ 中是可数的。\n\n为了形式化地定义一个值域为 $H$ 的全函数 $f: \\mathbb{N} \\to H$，我们可以将 $H_n$ 的构造与枚举过程交错进行。设 $A = \\{a_0, \\dots, a_{m-1}\\}$ 是有限集 $A$ 的一个枚举。\n设 $\\langle \\cdot, \\dots, \\cdot \\rangle: \\bigcup_{k=1}^\\infty \\mathbb{N}^k \\to \\mathbb{N}$ 是一个可计算的双射，它将任何自然数的有限序列编码成一个单一的自然数。\n我们通过递归定义一个元素序列 $(h_n)_{n \\in \\mathbb{N}}$。\n对于 $n < m$，设 $h_n = a_n$。\n对于 $n \\ge m$，令 $j = n-m$。将 $j$ 解码为一个自然数的有限序列，$j = \\langle i, k_1, \\dots, k_r \\rangle$。这表示一个请求，即应用第 $i$ 个 $\\Sigma_1$ 公式 $\\psi_i$ 于由 $k_1, \\dots, k_r$ 索引的参数。\n设 $\\psi_i$ 是一个有 $r$ 个自由变量的公式。我们检查是否所有索引 $k_s$ 都小于 $n$ (对于 $s=1,\\dots,r$）。\n如果是，则令 $\\vec{p} = (h_{k_1}, \\dots, h_{k_r})$ 为参数元组。我们检查是否 $L_{\\alpha} \\models \\exists u\\, \\psi_i(u, \\vec{p})$。\n如果 $L_{\\alpha}$ 中存在一个见证，我们定义 $h_n$ 为 $<_L$-最小的那个见证。\n如果任何索引 $k_s \\ge n$，或者不存在见证，我们可以定义 $h_n$ 为一个默认元素，比如 $h_n = h_0$。\n\n函数 $f: \\mathbb{N} \\to L_{\\alpha}$ 定义为 $f(n) = h_n$。此函数的值域 $S = \\{h_n \\mid n \\in \\mathbb{N}\\}$，根据构造是 $\\mathrm{Hull}_{\\Sigma_{1}}^{L_{\\alpha}}(A)$ 的子集。要证明它穷尽了整个壳，我们必须证明 $S$ 在 Skolem 函数下是封闭的。设 $\\psi_i$ 是任意一个有 $r$ 个变量的 $\\Sigma_1$ 公式，并设 $\\vec{s} = (s_1, \\dots, s_r)$ 是来自 $S$ 的一个参数元组。每个 $s_t = h_{k_t}$ (对于某个索引 $k_t \\in \\mathbb{N}$)。令 $j = \\langle i, k_1, \\dots, k_r \\rangle$ 和 $n = j+m$。根据构造，$h_n$ 是对于参数 $\\vec{s}=(h_{k_1}, \\dots, h_{k_r})$ 的 $\\psi_i$ 的 $<_L$-最小见证，前提是索引有效（对所有 $t$ 都有 $k_t < n$）并且存在见证。索引条件 $k_t < j+m$ 对任何选择的 $k_t$ 最终都会满足，因为我们总能找到一个更大的 $j'$ 来编码相同的请求。一个更精细的构造将确保所有有效的请求最终都被处理。核心论点仍然是，所有可能被生成的见证的集合是可数的，而这个构造枚举了它们。因此，$S = \\mathrm{Hull}_{\\Sigma_{1}}^{L_{\\alpha}}(A)$，由于 $S$ 是一个从 $\\mathbb{N}$ 出发的函数的值域，所以它是可数的。\n\n### 第二部分：$\\mathrm{Hull}_{\\Sigma_{1}}^{L_{3}}(\\{\\emptyset\\})$ 的计算\n\n首先，我们必须确定 $L_3$ 的结构。\n$L_0 = \\emptyset$。\n$L_1 = \\mathrm{Def}(L_0) = \\{\\emptyset\\}$，因为 $\\emptyset$ 是 $L_0$ 的唯一子集，可通过 $x \\neq x$ 定义。\n$L_2 = \\mathrm{Def}(L_1)$。其定义的论域是 $L_1 = \\{\\emptyset\\}$。$L_1$ 的子集是 $\\emptyset$ 和 $\\{\\emptyset\\}$。\n$\\emptyset$ 可通过 $x \\neq x$ 定义。\n$\\{\\emptyset\\}$ 可通过 $x = x$ 定义。\n因此，$L_2 = \\{\\emptyset, \\{\\emptyset\\}\\}$。\n\n$L_3 = \\mathrm{Def}(L_2)$。定义的论域是 $L_2 = \\{\\emptyset, \\{\\emptyset\\}\\}$。$L_2$ 的子集是 $\\emptyset$、$\\{\\emptyset\\}$、$\\{\\{\\emptyset\\}\\}$ 和 $\\{\\emptyset, \\{\\emptyset\\}\\}$。我们检查哪些是在 $\\langle L_2, \\in \\rangle$ 上可定义的：\n1.  $\\emptyset$: 可通过公式 $\\phi(x) \\equiv x \\neq x$ 定义。所以 $\\emptyset \\in L_3$。\n2.  $\\{\\emptyset, \\{\\emptyset\\}\\}$: 这就是 $L_2$ 本身。可通过 $\\phi(x) \\equiv x=x$ 定义。所以 $\\{\\emptyset, \\{\\emptyset\\}\\} \\in L_3$。\n3.  $\\{\\emptyset\\}$: 我们可以使用参数 $p = \\{\\emptyset\\} \\in L_2$。公式 $\\phi(x, p) \\equiv x \\in p$ 定义了 $\\{x \\in L_2 \\mid x \\in \\{\\emptyset\\}\\} = \\{\\emptyset\\}$。所以 $\\{\\emptyset\\} \\in L_3$。\n4.  $\\{\\{\\emptyset\\}\\}$: 我们使用参数 $p = \\{\\emptyset\\} \\in L_2$。公式 $\\phi(x, p) \\equiv x = p$ 定义了 $\\{x \\in L_2 \\mid x = \\{\\emptyset\\}\\} = \\{\\{\\emptyset\\}\\}$。所以 $\\{\\{\\emptyset\\}\\} \\in L_3$。\n因此，$L_3 = \\{\\emptyset, \\{\\emptyset\\}, \\{\\{\\emptyset\\}\\}, \\{\\emptyset, \\{\\emptyset\\}\\}\\}$。它是一个有 4 个元素的集合。\n\n接下来，我们建立 $L_3$ 上的典范良序 $<_L$。排序首先按阶（rank），然后按定义对（公式，参数）的 Gödel 数。\n-   $\\mathrm{rank}(x)$ 是最小的 $\\alpha$ 使得 $x \\in L_{\\alpha+1}$。\n-   $\\emptyset \\in L_1$，所以 $\\mathrm{rank}(\\emptyset)=0$。\n-   $\\{\\emptyset\\} \\in L_2$，所以 $\\mathrm{rank}(\\{\\emptyset\\})=1$。\n-   $\\{\\{\\emptyset\\}\\} \\in L_3 \\setminus L_2$，所以 $\\mathrm{rank}(\\{\\{\\emptyset\\}\\})=2$。\n-   $\\{\\emptyset, \\{\\emptyset\\}\\} \\in L_3 \\setminus L_2$，所以 $\\mathrm{rank}(\\{\\emptyset, \\{\\emptyset\\}\\})=2$。\n\n顺序开始于：$\\emptyset <_L \\{\\emptyset\\}$。要对两个阶为 2 的元素排序，我们比较它们的定义。\n-   $e_A = \\{\\emptyset, \\{\\emptyset\\}\\}$ 是在 $L_2$ 上由公式 $\\phi_A(x) \\equiv x=x$ 定义的，没有参数。\n-   $e_B = \\{\\{\\emptyset\\}\\}$ 是在 $L_2$ 上由公式 $\\phi_B(x, p) \\equiv x=p$ 定义的，参数为 $p=\\{\\emptyset\\} \\in L_2$。\n根据 $<_L$ 的定义，没有参数的定义排在有参数的定义之前。因此，$\\{\\emptyset, \\{\\emptyset\\}\\} <_L \\{\\{\\emptyset\\}\\}$。\n$L_3$ 上的完整排序是：\n$\\emptyset <_L \\{\\emptyset\\} <_L \\{\\emptyset, \\{\\emptyset\\}\\} <_L \\{\\{\\emptyset\\}\\}$。\n\n现在我们计算当 $A=\\{\\emptyset\\}$ 时的 $H = \\mathrm{Hull}_{\\Sigma_{1}}^{L_{3}}(A)$。\n设 $H_0 = A = \\{\\emptyset\\}$。\n这个过程是迭代地为带有来自当前壳的参数的 $\\Sigma_1$ 语句添加 $<_L$-最小见证。\n\n**步骤 1：**\n唯一可用的参数是 $\\emptyset \\in H_0$。\n考虑 $\\Sigma_1$ 公式 $\\exists u (v \\in u)$ 和参数 $v = \\emptyset$。该语句是 $L_3 \\models \\exists u (\\emptyset \\in u)$。\n我们在 $L_3 = \\{\\emptyset, \\{\\emptyset\\}, \\{\\{\\emptyset\\}\\}, \\{\\emptyset, \\{\\emptyset\\}\\}\\}$ 中寻找见证。\n$L_3$ 中以 $\\emptyset$ 为成员的元素是 $\\{\\emptyset\\}$ 和 $\\{\\emptyset, \\{\\emptyset\\}\\}$。\n见证的集合是 $W_1 = \\{\\{\\emptyset\\}, \\{\\emptyset, \\{\\emptyset\\}\\}\\}$。\n我们必须选择 $<_L$-最小的见证。根据我们的排序，$\\{\\emptyset\\} <_L \\{\\emptyset, \\{\\emptyset\\}\\}$。\n要添加的见证是 $\\{\\emptyset\\}$。\n新的壳是 $H_1 = H_0 \\cup \\{\\{\\emptyset\\}\\} = \\{\\emptyset, \\{\\emptyset\\}\\}$。\n\n**步骤 2：**\n可用的参数来自 $H_1 = \\{\\emptyset, \\{\\emptyset\\}\\}$。\n我们已经考虑过参数 $\\emptyset$。现在考虑新参数 $p = \\{\\emptyset\\}$。\n使用相同的 $\\Sigma_1$ 公式 $\\exists u (v \\in u)$ 和参数 $v = \\{\\emptyset\\}$。该语句是 $L_3 \\models \\exists u (\\{\\emptyset\\} \\in u)$。\n$L_3$ 中的见证是包含 $\\{\\emptyset\\}$ 的元素。它们是 $\\{\\{\\emptyset\\}\\}$ 和 $\\{\\emptyset, \\{\\emptyset\\}\\}$。\n见证的集合是 $W_2 = \\{\\{\\{\\emptyset\\}\\}, \\{\\emptyset, \\{\\emptyset\\}\\}\\}$。\n我们选择 $<_L$-最小的见证。根据我们的排序，$\\{\\emptyset, \\{\\emptyset\\}\\} <_L \\{\\{\\emptyset\\}\\}$。\n要添加的见证是 $\\{\\emptyset, \\{\\emptyset\\}\\}$。\n新的壳是 $H_2 = H_1 \\cup \\{\\{\\emptyset, \\{\\emptyset\\}\\}\\} = \\{\\emptyset, \\{\\emptyset\\}, \\{\\emptyset, \\{\\emptyset\\}\\}\\}$。\n\n**步骤 3：**\n可用的参数来自 $H_2 = \\{\\emptyset, \\{\\emptyset\\}, \\{\\emptyset, \\{\\emptyset\\}\\}\\}$。\n我们需要找到一种方法来生成 $L_3$ 的最后一个元素，即 $\\{\\{\\emptyset\\}\\}$。\n让我们构造一个能唯一标识这个元素的公式。元素 $\\{\\{\\emptyset\\}\\}$ 是元素 $\\{\\emptyset\\}$ 的单元素集。元素 $\\{\\emptyset\\}$ 在我们当前的壳 $H_2$ 中。\n设 $p_1 = \\{\\emptyset\\} \\in H_2$。考虑一个 $\\Sigma_1$ 公式，它陈述“存在一个集合 $u$，它是 $p_1$ 的单元素集”。\n公式是 $\\exists u \\left( p_1 \\in u \\land \\forall z \\in u (z=p_1) \\right)$。括号中的部分是一个 $\\Delta_0$ 公式，所以这是一个有效的 $\\Sigma_1$ 公式。\n当 $p_1 = \\{\\emptyset\\}$ 时，该语句是 $L_3 \\models \\exists u ( \\{\\emptyset\\} \\in u \\land \\forall z \\in u (z=\\{\\emptyset\\}) )$。\n这要求集合 $\\{\\{\\emptyset\\}\\}$ 存在于 $L_3$ 中。这个集合确实是 $L_3$ 的一个元素。\n唯一的见证是 $\\{\\{\\emptyset\\}\\}$ 本身。由于它是唯一的见证，所以它平凡地是 $<_L$-最小见证。\n要添加的见证是 $\\{\\{\\emptyset\\}\\}$。\n新的壳是 $H_3 = H_2 \\cup \\{\\{\\{\\emptyset\\}\\}\\} = \\{\\emptyset, \\{\\emptyset\\}, \\{\\emptyset, \\{\\emptyset\\}\\}, \\{\\{\\emptyset\\}\\}\\}$。\n\n此时，壳 $H_3$ 等于整个集合 $L_3$。任何进一步使用来自 $H_3$ 的参数应用 Skolem 函数，都将产生位于 $L_3$ 中、因此已经位于 $H_3$ 中的见证。过程稳定下来。\n因此，$\\mathrm{Hull}_{\\Sigma_{1}}^{L_{3}}(\\{\\emptyset\\}) = L_3$。\n\n$\\mathrm{Hull}_{\\Sigma_{1}}^{L_{3}}(\\{\\emptyset\\})$ 的基数是 $L_3$ 的基数，即 $4$。", "answer": "$$\\boxed{4}$$", "id": "2985176"}]}