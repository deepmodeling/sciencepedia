{"hands_on_practices": [{"introduction": "哥德尔可构造宇宙$L$的基石是“可定义性”这一概念。本练习旨在帮助你掌握可定义性的精确模型论定义，特别是参数在其中的关键作用。理解参数如何极大地扩展了我们所能定义的集合的范围，是领会为何可构造层级$L_\\alpha$能够不断“生长”并最终形成一个足够丰富的、满足ZF公理的宇宙的第一步。[@problem_id:2973772]", "problem": "在一阶集合论的语言 $\\{\\in\\}$ 背景下，令 $\\langle M,\\in\\rangle$ 为一个结构，且令 $X\\subseteq M$。在元理论中，对于任意公式 $\\varphi$ 和元组 $\\bar a\\in M^{k}$，Tarski 满足关系 $\\,\\langle M,\\in\\rangle\\models\\varphi[\\bar a]\\,$ 由通常的归纳条款定义。在 Gödel 证明选择公理 (AC) 和广义连续统假设 (GCH) 与策梅洛-弗兰克尔集合论 (ZF) 相容的论证中，可构造层级 $L$ 是通过一个运算构建的，该运算取所有在 $\\langle M,\\in\\rangle$ 上可用 $M$ 中的参数进行一阶定义的 $M$ 的子集。\n\n下列哪个陈述正确地描述了 $X$ 在 $\\langle M,\\in\\rangle$ 上可用来自 $M$ 的参数定义是什么意思，并正确地解释了参数在这一背景下的作用？请选择所有适用的选项。\n\nA. $X$ 在 $\\langle M,\\in\\rangle$ 上可用来自 $M$ 的参数定义，当且仅当存在一个语言为 $\\{\\in\\}$ 的一阶公式 $\\varphi(x,y_{1},\\dots,y_{n})$ 和参数 $a_{1},\\dots,a_{n}\\in M$，使得对于所有 $x\\in M$，\n$$\nx\\in X\\ \\Longleftrightarrow\\ \\langle M,\\in\\rangle\\models\\varphi(x,a_{1},\\dots,a_{n}).\n$$\n\nB. $X$ 在 $\\langle M,\\in\\rangle$ 上可用来自 $M$ 的参数定义，当且仅当存在一个语言为 $\\{\\in\\}$ 的无参数一阶公式 $\\varphi(x)$，使得对于所有 $x\\in M$，\n$$\nx\\in X\\ \\Longleftrightarrow\\ \\langle M,\\in\\rangle\\models\\varphi(x).\n$$\n\nC. 在可构造层级的递归定义中，我们设置\n$$\nL_{\\alpha+1}\\ =\\ \\{\\,X\\subseteq L_{\\alpha}\\mid X \\text{ 在 }\\langle L_{\\alpha},\\in\\rangle \\text{ 上可用来自 } L_{\\alpha} \\text{ 的参数定义}\\,\\},\n$$\n并且这种对参数的使用对于 $L$ 的标准定义至关重要。\n\nD. 对于在 $\\langle M,\\in\\rangle$ 上的可定义性而言，允许使用 $M$ 之外的参数是无害的，因为任何这样的参数都可以被一个 $M$ 中的元素统一替换；因此，在 $\\langle M,\\in\\rangle$ 上可定义的 $M$ 的子集类不依赖于将参数限制在 $M$ 中。\n\nE. 如果 $M$ 是传递的，那么 $M$ 的每个子集 $X\\subseteq M$ 都在 $\\langle M,\\in\\rangle$ 上可用来自 $M$ 的参数定义，当且仅当 $M$ 满足选择公理；因此，参数保证了 AC 所需的满射。\n\nF. 说 $X$ 在 $\\langle M,\\in\\rangle$ 上可用来自 $M$ 的参数定义，等价于说 $X$ 在一个扩展语言中是无参数可定义的，该扩展语言添加了命名来自 $M$ 的特定参数的常量符号；因此，参数对应于通过在 $M$ 中解释的常量来扩展语言。", "solution": "该问题要求评估关于带参数的一阶可定义性的定义和作用的几个陈述，特别是在构建 Gödel 的可构造宇宙 $L$ 的背景下。如果存在集合论语言中的一个一阶公式 $\\varphi$ 和一些来自 $M$ 的元素 $a_1, \\dots, a_n$，使得 $X$ 恰好由那些在结构 $\\langle M, \\in \\rangle$ 中使 $\\varphi(x, a_1, \\dots, a_n)$ 为真的元素 $x \\in M$ 组成，那么我们就说结构 $\\langle M, \\in \\rangle$ 的论域 $M$ 的一个子集 $X$ 是可用来自 $M$ 的参数定义的。\n\n\n### 选项评估\n\n**A. $X$ 在 $\\langle M,\\in\\rangle$ 上可用来自 $M$ 的参数定义，当且仅当存在一个语言为 $\\{\\in\\}$ 的一阶公式 $\\varphi(x,y_{1},\\dots,y_{n})$ 和参数 $a_{1},\\dots,a_{n}\\in M$，使得对于所有 $x\\in M$，\n$$\nx\\in X\\ \\Longleftrightarrow\\ \\langle M,\\in\\rangle\\models\\varphi(x,a_{1},\\dots,a_{n}).\n$$**\n这个陈述给出了一个子集 $X \\subseteq M$ 在结构 $\\langle M, \\in \\rangle$ 上使用来自 $M$ 的参数可定义的精确、标准的模型论定义。公式 $\\varphi(x, y_1, \\dots, y_n)$ 有一组自由变量，其中一个变量 $x$ 的取值范围是正在被测试是否属于 $X$ 的元素，而其他变量 $y_1, \\dots, y_n$ 则被固定为特定的元素 $a_1, \\dots, a_n \\in M$，这些元素就是“参数”。集合 $X$ 是这样得到的一元谓词的外延。这是后续概念所依赖的基础定义。\n\n**结论：正确。**\n\n**B. $X$ 在 $\\langle M,\\in\\rangle$ 上可用来自 $M$ 的参数定义，当且仅当存在一个语言为 $\\{\\in\\}$ 的无参数一阶公式 $\\varphi(x)$，使得对于所有 $x\\in M$，\n$$\nx\\in X\\ \\Longleftrightarrow\\ \\langle M,\\in\\rangle\\models\\varphi(x).\n$$**\n这个陈述描述的是*无*参数的可定义性。带参数的可定义性是一个更普遍的概念。虽然任何无参数可定义的集合也是带参数可定义的（例如，通过使用一个带有空泛参数变量的公式），但反之不成立。例如，对于任何特定元素 $a \\in M$，单元素集 $\\{a\\}$ 可以在 $\\langle M, \\in \\rangle$ 上使用参数 $a$ 和公式 $\\varphi(x,y) \\equiv (x=y)$ 来定义。然而，在一个一般的结构 $M$ 中，并非对于每个 $a \\in M$，集合 $\\{a\\}$ 都能由一个没有参数的公式定义。这个选项混淆了两个不同的逻辑概念。\n\n**结论：不正确。**\n\n**C. 在可构造层级的递归定义中，我们设置\n$$\nL_{\\alpha+1}\\ =\\ \\{\\,X\\subseteq L_{\\alpha}\\mid X \\text{ 在 }\\langle L_{\\alpha},\\in\\rangle \\text{ 上可用来自 } L_{\\alpha} \\text{ 的参数定义}\\,\\},\n$$\n并且这种对参数的使用对于 $L$ 的标准定义至关重要。**\n所提供的公式是定义可构造层级 $L$ 的超限递归中的后继步骤的正确定义。集合 $L_{\\alpha+1}$ 是 $L_\\alpha$ 的所有子集的集合，这些子集可以在结构 $\\langle L_\\alpha, \\in \\rangle$ 上用来自 $L_\\alpha$ 的参数定义。参数是“至关重要”的这一说法是准确的。如果有人试图仅使用无参数公式来构造一个层级，比如说 $L'$，那么每个后继层级 $L'_{\\alpha+1}$ 最多是可数无限的，因为语言 $\\{\\in\\}$ 中只有可数多个公式。这将导致一个“太稀薄”而无法满足 ZF 公理的层级。例如，在这种构造下，可构造实数的集合 $\\mathcal{P}(\\omega) \\cap L'$ 将是可数的。然而，完整的宇宙 $L$ 被构造成 ZF 的一个模型，而在 $L$ 内部，$\\omega$ 的幂集是不可数的。因此，使用参数对于确保该层级足够丰富是至关重要的。\n\n**结论：正确。**\n\n**D. 对于在 $\\langle M,\\in\\rangle$ 上的可定义性而言，允许使用 $M$ 之外的参数是无害的，因为任何这样的参数都可以被一个 $M$ 中的元素统一替换；因此，在 $\\langle M,\\in\\rangle$ 上可定义的 $M$ 的子集类不依赖于将参数限制在 $M$ 中。**\n这个陈述是不正确的。Tarski 满足关系 $\\langle M,\\in\\rangle\\models\\psi[\\bar{a}]$ 仅对将变量赋值为论域 $M$ 内元素的赋值 $\\bar{a}$ 有定义。谈论在 $\\langle M, \\in \\rangle$ 上使用一个参数 $p \\notin M$ 来求值一个公式是语意不通的。虽然可以通过在一个同时包含 $M$ 和 $p$ 的更大结构中求值公式来定义一个相关概念，但这将构成在该更大结构上的可定义性，而不是在 $\\langle M, \\in \\rangle$ 上的可定义性。外部参数可以被内部参数“统一替换”的前提是毫无根据的。没有通用的方法可以实现这一点。\n\n**结论：不正确。**\n\n**E. 如果 $M$ 是传递的，那么 $M$ 的每个子集 $X\\subseteq M$ 都在 $\\langle M,\\in\\rangle$ 上可用来自 $M$ 的参数定义，当且仅当 $M$ 满足选择公理；因此，参数保证了 AC 所需的满射。**\n这个陈述是错误的。条件“$M$ 的每个子集 $X\\subseteq M$ 在 $\\langle M,\\in\\rangle$ 上可用来自 $M$ 的参数定义”断言 $M$ 的真正幂集（记作 $\\mathcal{P}(M)$）与 $M$ 的可定义子集的集合（记作 $\\text{Def}(M)$）相同。我们可以用一个简单的计数论证来证明所声称的等价关系 $\\mathcal{P}(M) = \\text{Def}(M) \\iff M \\models \\text{AC}$ 是错误的。设 $M$ 是 ZFC 的任意可数传递模型。作为 ZFC 的模型，$M$ 满足选择公理，所以等价关系的右边为真。然而，$M$ 是一个可数集。可用公式的数量是可数的，来自可数集的有限元组的数量也是可数的。因此，可定义子集的集合 $\\text{Def}(M)$ 是可数的。根据 Cantor 定理，一个可数集的幂集是不可数的，所以 $\\mathcal{P}(M)$ 是不可数的。因此，$\\text{Def}(M) \\neq \\mathcal{P}(M)$，等价关系的左边为假。因为我们找到了一个右边为真而左边为假的情况，所以该等价关系不成立。\n\n**结论：不正确。**\n\n**F. 说 $X$ 在 $\\langle M,\\in\\rangle$ 上可用来自 $M$ 的参数定义，等价于说 $X$ 在一个扩展语言中是无参数可定义的，该扩展语言添加了命名来自 $M$ 的特定参数的常量符号；因此，参数对应于通过在 $M$ 中解释的常量来扩展语言。**\n这个陈述准确地描述了模型论中的一个基本概念。如果一个集合 $X$ 是由一个带参数 $a_1,\\dots,a_n \\in M$ 的公式 $\\varphi(x,y_1,\\dots,y_n)$ 定义的，我们可以将语言 $\\{\\in\\}$ 扩展到一个新的语言 $\\mathcal{L}' = \\{\\in, c_1,\\dots,c_n\\}$，其中包含新的常量符号 $c_1,\\dots,c_n$。然后，我们可以将结构 $\\langle M,\\in\\rangle$ 扩展为一个 $\\mathcal{L}'$-结构 $\\mathcal{M}'=\\langle M,\\in,a_1,\\dots,a_n\\rangle$，其中每个 $c_i$ 被解释为 $a_i$。集合 $X$ 随后在 $\\mathcal{M}'$ 中由无参数的 $\\mathcal{L}'$-公式 $\\psi(x) \\equiv \\varphi(x,c_1,\\dots,c_n)$ 定义。反之亦然。这种等价性表明，使用参数是一种临时赋予论域中特定元素以逻辑常数地位的方法。\n\n**结论：正确。**", "answer": "$$\\boxed{ACF}$$", "id": "2973772"}, {"introduction": "在掌握了可定义性的概念后，我们来检视可构造宇宙$L$在ZF集合论框架内的实际构建过程。本练习将挑战你精确识别出在超限递归的每一步中，究竟需要哪些ZF公理的支持，例如，分离公理模式和替换公理模式在其中分别扮演了怎样的角色。通过这个练习，你将深化对ZF公理系统如何为构造复杂的数学对象提供根本工具的理解。[@problem_id:2973758]", "problem": "设 $ZF$ 表示策梅洛-弗兰克尔集合论（$ZF$），$AC$ 表示选择公理（$AC$），$GCH$ 表示广义连续统假设（$GCH$），$L$ 表示可构造全集（$L$）。在 Gödel 证明 $AC$ 和 $GCH$ 与 $ZF$ 相容的方法中，人们通过沿序数类进行的超限递归来构造内模型 $L$。此任务预设的基础内容包括以下几项：$ZF$ 的公理（外延公理、空集公理、配对公理、并集公理、幂集公理、无穷公理、分离公理模式、替换公理模式和基础公理）、序数的标准定义、超限递归原理（在 $ZF$ 中通过替换公理导出），以及在一个结构中的可定义性概念。该构造通过令 $L_{0}=\\emptyset$，$L_{\\alpha+1}$ 为 $L_{\\alpha}$ 的所有子集的集合，这些子集可以在结构 $\\langle L_{\\alpha},\\in\\rangle$ 中使用来自 $L_{\\alpha}$ 的参数进行一阶定义，对于极限序数 $\\lambda$，令 $L_{\\lambda}=\\bigcup_{\\alpha\\lambda}L_{\\alpha}$，然后令 $L=\\bigcup_{\\alpha\\in \\mathrm{On}}L_{\\alpha}$，从而定义了一个层级 $\\{L_{\\alpha}\\}_{\\alpha\\in \\mathrm{On}}$。在此背景下，可定义性使用自然数对公式和有限参数元组进行哥德尔编码。\n\n哪个选项正确地指出了执行 $L$ 的构造实际需要的 $ZF$ 公理，并准确说明了分离公理模式和替换公理模式在该构造中的具体使用位置？\n\nA. 在每个后继阶段 $\\alpha\\mapsto \\alpha+1$，应用分离公理，为每个固定的公式和来自 $L_{\\alpha}$ 的参数元组，划分出子集 $\\{x\\in L_{\\alpha}:\\langle L_{\\alpha},\\in\\rangle\\models \\varphi(x,\\vec{a})\\}$；然后使用替换公理将所有这些子集收集到单个集合 $Def(L_{\\alpha})$ 中，并在极限序数 $\\lambda$ 处再次使用它来形成集合 $\\{L_{\\beta}:\\beta\\lambda\\}$，其并集为 $L_{\\lambda}$。配对公理和并集公理用于编码和取并集，无穷公理用于通过自然数对公式进行编码，而幂集公理不用于生成 $L_{\\alpha+1}$。除了作为背景理论外，基础公理和外延公理在构造中没有被特别调用。\n\nB. 幂集公理在后继阶段是必不可少的，因为必须取 $L_{\\alpha+1}=\\mathcal{P}(L_{\\alpha})$；分离公理和替换公理在定义 $L_{\\alpha+1}$ 中不起作用，而在极限阶段仅并集公理就足够了。\n\nC. 替换公理在构造中没有使用；它只是在之后证明 $L$ 本身满足替换公理时才需要。构造在后继阶段使用分离公理，并使用幂集公理来界定 $Def(L_{\\alpha})$，而极限阶段只需要并集公理，无需进一步使用替换公理。\n\nD. 不需要分离公理，因为可定义子集是从编码和参数出发的一个可定义映射的像；因此仅替换公理就能产生 $Def(L_{\\alpha})$。在极限阶段，需要幂集公理来确保 $\\bigcup_{\\beta\\lambda}L_{\\beta}$ 存在；需要基础公理来保持层级在每个阶段都是良基的。\n\nE. 基础公理在后继阶段是必不可少的，以确保 $L_{\\alpha+1}$ 是传递的，并且替换公理是不必要的；分离公理仅用于在极限序数处从 $\\beta\\lambda$ 的 $L_{\\beta}$ 定义 $L_{\\lambda}$，而幂集公理则需要在每个阶段收集所有可定义子集。", "solution": "用户希望对问题陈述进行批判性验证，并从第一性原理推导出详细的解决方案。\n\n### 问题验证\n\n**步骤1：提取已知信息**\n\n-   **ZF**：策梅洛-弗兰克尔集合论，包括外延公理、空集公理、配对公理、并集公理、幂集公理、无穷公理、分离公理模式、替换公理模式和基础公理。\n-   **AC**：选择公理。\n-   **GCH**：广义连续统假设。\n-   **L**：可构造全集。\n-   **L-层级的构造**：类 $L$ 是通过对序数类 $\\mathrm{On}$ 进行超限递归来构造的。\n    -   $L_0 = \\emptyset$。\n    -   $L_{\\alpha+1}$ 是 $L_{\\alpha}$ 的所有子集的汇集，这些子集是在结构 $\\langle L_{\\alpha},\\in\\rangle$ 中使用来自 $L_{\\alpha}$ 的参数进行一阶定义的。这个汇集表示为 $\\text{Def}(L_{\\alpha})$。\n    -   对于极限序数 $\\lambda$，$L_{\\lambda} = \\bigcup_{\\alpha\\lambda}L_{\\alpha}$。\n    -   $L = \\bigcup_{\\alpha\\in \\mathrm{On}}L_{\\alpha}$。\n-   **背景**：分析将在 $ZF$ 框架内进行。可定义性涉及对公式和有限参数元组的哥德尔编码。问题询问构造 $L$ 需要哪些 $ZF$ 公理，并特别指出分离公理和替换公理的使用位置。\n\n**步骤2：使用提取的已知信息进行验证**\n\n-   **科学上合理**：问题陈述描述了 Gödel 对可构造全集 $L$ 的构造，这是现代集合论和数理逻辑的基石。为 $L$-层级提供的定义是标准且正确的。该主题完全属于已建立的数理逻辑领域。\n-   **适定性**：问题是精确的。它要求在一个明确定义的数学构造中，某些 $ZF$ 公理的具体作用。基于对 $L$ 构造的标准分析，存在一个唯一且正确的答案。\n-   **客观性**：语言清晰、技术性强，没有任何主观性或歧义。所使用的术语（$ZF$、$L_{\\alpha}$、可定义性、分离公理、替换公理）在集合论中具有精确、普遍接受的含义。\n\n该问题没有表现出任何无效性缺陷：\n1.  **科学/事实不健全**：前提是集合论中事实正确的描述。\n2.  **不可形式化/不相关**：问题是一个关于形式化构造的形式化问题。\n3.  **不完整/矛盾**：提供了足够的信息来分析该构造。\n4.  **不切实际/不可行**：问题涉及纯粹的数学构造，因此物理现实主义不适用。\n5.  **不适定/结构不良**：问题结构良好，并导向一个明确的答案。\n6.  **伪深刻/琐碎**：问题需要对一个非平凡构造中的公理使用进行仔细分析，这是一项实质性的任务。\n7.  **超出科学可验证性**：这些主张在 $ZF$ 集合论的形式系统内是可验证的。\n\n**步骤3：结论和行动**\n\n问题陈述是**有效的**。现在将进行求解过程。\n\n### 推导与选项分析\n\n任务是确定超限构造层级 $\\{L_{\\alpha}\\}_{\\alpha \\in \\mathrm{On}}$ 所需的 $ZF$ 公理，以及分离公理模式和替换公理模式的具体作用。该构造是一个超限递归，因此我们必须验证每一步都可以在 $ZF$ 内部执行。我们通过归纳法假设，对于所有 $\\beta  \\alpha$，$L_{\\beta}$ 都已被构造成一个集合。\n\n**1. 基础情形：$\\alpha=0$**\n定义是 $L_0 = \\emptyset$。空集的存在性由**空集公理**保证。\n\n**2. 后继阶段：$\\alpha \\to \\alpha+1$**\n定义是 $L_{\\alpha+1} = \\text{Def}(L_{\\alpha})$，即在结构 $\\langle L_{\\alpha}, \\in \\rangle$ 中可用来自 $L_{\\alpha}$ 的参数定义的所有 $L_{\\alpha}$ 的子集的集合。让我们分两部分来分析这个步骤。\n\n*   **第2a部分：形成单个可定义子集。**\n    $L_{\\alpha}$ 的一个可定义子集是形如 $S_{\\varphi, \\vec{a}} = \\{x \\in L_{\\alpha} : \\langle L_{\\alpha}, \\in \\rangle \\models \\varphi(x, \\vec{a})\\}$ 的汇集，其中 $\\varphi$ 是一个带有一个自由变量 $x$ 和一个参数自由变量元组的一阶公式，$\\vec{a}$ 是来自 $L_{\\alpha}$ 的元素元组。归纳假设指出 $L_{\\alpha}$ 是一个集合。性质“$\\langle L_{\\alpha}, \\in \\rangle \\models \\varphi(x, \\vec{a})$”是 $x$ 的一个形式性质。**分离公理模式**指出，对于任何集合 $A$ 和任何性质 $P(x)$，汇集 $\\{x \\in A : P(x)\\}$ 是一个集合。在这里，$A$ 是 $L_{\\alpha}$，$P(x)$ 是满足关系。因此，需要分离公理来保证每个单独的可定义汇集 $S_{\\varphi, \\vec{a}}$ 确实是一个集合。\n\n*   **第2b部分：收集所有可定义子集。**\n    我们现在知道，对于每个公式 $\\varphi$ 和每个来自 $L_{\\alpha}$ 的参数元组 $\\vec{a}$，对应的可定义子集 $S_{\\varphi, \\vec{a}}$ 是一个集合。我们必须将所有这些集合收集到一个单独的集合 $L_{\\alpha+1}$ 中。\n    一阶公式的集合是可数的。使用哥德尔数和**无穷公理**（它给了我们 $\\omega$），我们可以将公式集视为自然数集 $\\omega$。\n    参数 $\\vec{a}$ 是来自 $L_{\\alpha}$ 的有限元素元组。设 $P = \\bigcup_{n \\in \\omega} (L_{\\alpha})^n$ 是所有来自 $L_{\\alpha}$ 的有限序列的集合。该集合的存在性可以通过配对公理、并集公理和替换公理来确立。\n    我们可以定义一个类函数 $F$，其定义域是 $\\omega \\times P$ 的一个子集。该函数由 $F(\\langle \\ulcorner\\varphi\\urcorner, \\vec{a} \\rangle) = S_{\\varphi, \\vec{a}} = \\{x \\in L_{\\alpha} : \\langle L_{\\alpha}, \\in \\rangle \\models \\varphi(x, \\vec{a})\\}$ 给出。$F$ 的定义域是一个集合。**替换公理模式**断言，其定义域为集合的函数的像也是一个集合。因此，汇集 $\\{ S_{\\varphi, \\vec{a}} : \\varphi \\text{ 是一个公式且 } \\vec{a} \\in P \\}$ 是一个集合。这个集合正是 $L_{\\alpha+1}$。\n    注意，**幂集公理**没有被使用。我们不形成 $\\mathcal{P}(L_{\\alpha})$。我们只形成*可定义的*子集的集合，这是 $\\mathcal{P}(L_{\\alpha})$ 的一个子汇集。这种限制是使 $GCH$ 在 $L$ 中成立的原因。\n\n**3. 极限阶段：$\\alpha = \\lambda$（对于极限序数 $\\lambda$）**\n定义是 $L_{\\lambda} = \\bigcup_{\\beta  \\lambda} L_{\\beta}$。\n\n*   **第3a部分：形成集合族。**\n    我们想取汇集 $\\{L_{\\beta} : \\beta  \\lambda\\}$ 的并集。为此，这个汇集必须首先是一个集合。超限递归定义了一个类函数 $G(\\beta) = L_{\\beta}$。我们将此函数应用于小于 $\\lambda$ 的序数集合，即序数 $\\lambda$ 本身。序数 $\\lambda$ 是一个集合。**替换公理模式**指出，一个类函数在一个集合下的像是一个集合。因此，像 $\\{ G(\\beta) : \\beta \\in \\lambda \\} = \\{L_{\\beta} : \\beta  \\lambda\\}$ 是一个集合。\n\n*   **第3b部分：取并集。**\n    一旦我们有了集合 $\\mathcal{F} = \\{L_{\\beta} : \\beta  \\lambda\\}$，我们就可以对其应用**并集公理**。该公理指出，对于任何集合的集合 $\\mathcal{F}$，存在一个集合是 $\\mathcal{F}$ 所有元素的并集。因此，$\\bigcup \\mathcal{F} = \\bigcup_{\\beta  \\lambda} L_{\\beta} = L_{\\lambda}$ 是一个集合。\n\n**构造中公理使用摘要：**\n-   **空集公理**：用于定义 $L_0$。\n-   **无穷公理**：为公式的哥德尔编码提供 $\\omega$。\n-   **配对公理、并集公理**：用于处理参数元组和在极限阶段取并集。\n-   **分离公理**：在后继阶段，从 $L_{\\alpha}$ 中形成每个单独的可定义子集。\n-   **替换公理**：在后继阶段，将所有可定义子集收集到集合 $L_{\\alpha+1}$ 中。在极限阶段，形成集合 $\\{L_{\\beta} : \\beta  \\lambda\\}$。\n-   **幂集公理**：显著地*不*用于形成 $L_{\\alpha+1}$。\n-   **基础公理、外延公理**：这些是构造所在集合论全集的背景公理。它们不像其他公理那样被用于特定的构造步骤。\n\n### 选项评估\n\n**A. 在每个后继阶段 $\\alpha\\mapsto \\alpha+1$，应用分离公理，为每个固定的公式和来自 $L_{\\alpha}$ 的参数元组，划分出子集 $\\{x\\in L_{\\alpha}:\\langle L_{\\alpha},\\in\\rangle\\models \\varphi(x,\\vec{a})\\}$；然后使用替换公理将所有这些子集收集到单个集合 $Def(L_{\\alpha})$ 中，并在极限序数 $\\lambda$ 处再次使用它来形成集合 $\\{L_{\\beta}:\\beta\\lambda\\}$，其并集为 $L_{\\lambda}$。配对公理和并集公理用于编码和取并集，无穷公理用于通过自然数对公式进行编码，而幂集公理不用于生成 $L_{\\alpha+1}$。除了作为背景理论外，基础公理和外延公理在构造中没有被特别调用。**\n此选项提供了对公理作用的完整而准确的描述，与我们的推导完全匹配。它正确地指出了替换公理的两个不同用途（在后继阶段和极限阶段），分离公理的精确作用，以及幂集公理不用于形成 $L_{\\alpha+1}$ 的关键事实。\n**结论：正确。**\n\n**B. 幂集公理在后继阶段是必不可少的，因为必须取 $L_{\\alpha+1}=\\mathcal{P}(L_{\\alpha})$；分离公理和替换公理在定义 $L_{\\alpha+1}$ 中不起作用，而在极限阶段仅并集公理就足够了。**\n这是根本错误的。可构造全集的定义是 $L_{\\alpha+1} = \\text{Def}(L_{\\alpha})$，而不是 $\\mathcal{P}(L_{\\alpha})$。使用 $\\mathcal{P}(L_{\\alpha})$ 将会得到冯·诺依曼层级 $V$，而不是 $L$。声称分离公理和替换公理不起作用是错误的。声称在极限阶段仅并集公理就足够了也是错误的；首先需要替换公理来形成集合 $\\{L_{\\beta} : \\beta  \\lambda\\}$。\n**结论：不正确。**\n\n**C. 替换公理在构造中没有使用；它只是在之后证明 $L$ 本身满足替换公理时才需要。构造在后继阶段使用分离公理，并使用幂集公理来界定 $Def(L_{\\alpha})$，而极限阶段只需要并集公理，无需进一步使用替换公理。**\n这是不正确的。正如我们的分析所示，替换公理对于构造本身在后继阶段（收集可定义集）和极限阶段（形成待合并的集合族）都是至关重要的。声称“幂集公理[被用来]界定 $Def(L_{\\alpha})$”是误导性的；幂集公理并未被调用。\n**结论：不正确。**\n\n**D. 不需要分离公理，因为可定义子集是从编码和参数出发的一个可定义映射的像；因此仅替换公理就能产生 $Def(L_{\\alpha})$。在极限阶段，需要幂集公理来确保 $\\bigcup_{\\beta\\lambda}L_{\\beta}$ 存在；基础公理需要保持层级在每个阶段都是良基的。**\n这是不正确的。替换公理要求函数值域中的对象已知是集合。分離公理保证了每个 $\\{x \\in L_{\\alpha} : \\dots\\}$ 是一个集合。因此，分离公理是在后继阶段应用替换公理的先决条件。声称在极限阶段需要幂集公理是错误的；使用的是替换公理和并集公理。\n**结论：不正确。**\n\n**E. 基础公理在后继阶段是必不可少的，以确保 $L_{\\alpha+1}$ 是传递的，并且替换公理是不必要的；分离公理仅用于在极限序数处从 $\\beta\\lambda$ 的 $L_{\\beta}$ 定义 $L_{\\lambda}$，而幂集公理则需要在每个阶段收集所有可定义子集。**\n这个选项包含多个错误。如前所述，替换公理是必要的。分离公理用于后继阶段，而不是极限阶段。幂集公理不用于收集可定义子集；替换公理用于此目的。基础公理的作用是确保集合论全集的良基性，这是一个背景条件，而不是在每个阶段确保传递性（这是构造的一个可证明的性质）的构造工具。\n**结论：不正确。**", "answer": "$$\\boxed{A}$$", "id": "2973758"}, {"introduction": "构造$L$的最终目的是证明它是一个满足ZF公理的模型。本练习聚焦于该证明的核心部分：即$L$如何满足分离公理模式和替换公理模式。你将探索$L$的分层构造方法（即每一层都由前一层的可定义子集构成）如何通过形式化的满足关系$\\mathsf{Sat}$，从根本上保证了这些关键公理在$L$中成立。[@problem_id:2973768]", "problem": "在策梅洛-弗兰克尔集合论 (Zermelo–Fraenkel set theory, ZF) 的框架下进行讨论。回顾可构造层级 (constructible hierarchy) 的定义：$$L_0=\\emptyset,\\qquad L_{\\alpha+1}=\\mathrm{Def}(L_\\alpha),\\qquad L_\\lambda=\\bigcup_{\\beta\\lambda}L_\\beta \\text{ 对于极限序数 }\\lambda,$$ 其中 $$\\mathrm{Def}(L_\\alpha)=\\{X\\subseteq L_\\alpha : \\text{存在一个一阶公式 } \\varphi(u,\\vec{v}) \\text{ 和参数 } \\vec{p}\\in L_\\alpha \\text{ 使得 } X=\\{x\\in L_\\alpha : \\langle L_\\alpha,\\in\\rangle\\models\\varphi(x,\\vec{p})\\}\\}.$$ 一阶公式的哥德尔编码 (Gödel coding) 为每个公式分配一个自然数编码，对于所有足够大的 $\\alpha$，这些编码都属于 $L_\\alpha$。令 $\\mathsf{Sat}_\\alpha$ 表示结构 $\\langle L_\\alpha,\\in\\rangle$ 的满足关系 (satisfaction relation)，它被看作是 $$L_\\alpha^{\\omega}\\times L_\\alpha^{\\omega}\\times \\omega$$ 的一个子集，其中第三个分量是公式编码，前两个分量是 $L_\\alpha$ 中元素的有限序列，用作变量赋值。\n\n分离公理模式 (Separation) 和替换公理模式 (Replacement) 是策梅洛-弗兰克尔集合论 (ZF) 的公理模式，它们分别断言：对于任何集合 $A$ 和公式 $\\varphi(u,\\vec{v})$，子集 $\\{x\\in A:\\varphi(x,\\vec{p})\\}$ 存在；以及对于任何集合 $A$ 和函数性公式 $\\varphi(x,y,\\vec{v})$ (即对每个 $x$ 都存在唯一的 $y$ 使得 $\\varphi(x,y,\\vec{p})$ 成立)，像集 $\\{y:\\exists x\\in A\\,\\varphi(x,y,\\vec{p})\\}$ 存在。\n\n选择所有正确阐述“为何可定义的满足关系使得可构造全集 $L$ 能在下一阶段 $L_{\\alpha+1}$ 通过公式编码选取子集，从而实现分离公理和替换公理”的陈述。\n\nA. 对每个序数 $\\alpha$，关系 $\\mathsf{Sat}_\\alpha$ 是 $L_{\\alpha+1}$ 的一个元素，并且对任意公式编码 $e\\in\\omega\\cap L_\\alpha$ 和参数 $\\vec{p}\\in L_\\alpha$，子集 $$\\{x\\in L_\\alpha:\\mathsf{Sat}_\\alpha(e,x,\\vec{p})\\}$$ 属于 $L_{\\alpha+1}$，从而实现了相对于 $L_\\alpha$ 的分离公理。\n\nB. 需要选择公理 (Axiom of Choice, AC) 和广义连续统假设 (Generalized Continuum Hypothesis, GCH) 来确保公式在 $L_\\alpha$ 中有编码，若没有 AC 和 GCH，分离公理就无法在阶段 $L_{\\alpha+1}$ 实现。\n\nC. 如果 $A\\in L_\\alpha$ 并且 $\\varphi(x,y,\\vec{v})$ 使得 $\\langle L_\\alpha,\\in\\rangle$ 验证了对于每个 $x\\in A$ 都存在唯一的 $y\\in L_\\alpha$ 满足 $\\varphi(x,y,\\vec{p})$，那么其值域集 $$\\{y\\in L_\\alpha:\\exists x\\in A\\,\\mathsf{Sat}_\\alpha(\\ulcorner\\varphi\\urcorner,x,y,\\vec{p})\\}$$ 位于 $L_{\\alpha+1}$ 中，这在阶段 $L_{\\alpha+1}$ 证明了对于此类可定义函数的替换公理模式。\n\nD. 根据 Tarski 的真理不可定义性定理，对于任何 $\\langle L_\\alpha,\\in\\rangle$ 的满足关系在 $L$ 内部都不可定义，因此分离公理在 $L$ 中必定不成立。\n\nE. $\\Delta_0$ 公式在 $L_\\alpha$ 与背景全集之间的绝对性足以在阶段 $L_{\\alpha+1}$ 推导出 $L$ 中的完整替换公理模式，而无需使用任何满足关系或哥德尔编码。", "solution": "该问题要求辨别哪些陈述正确解释了可定义满足关系在证明可构造全集 $L$ 满足分离公理模式和替换公理模式中的作用。证明 $L$ 是策梅洛-弗兰克尔集合论的模型（$L \\models \\mathrm{ZF}$）是现代集合论的基石，由 Kurt Gödel 建立。\n\n可构造全集 $L$ 的构造是分层的，通过对序数的超限递归来定义。\n关键步骤是后继阶段：$L_{\\alpha+1} = \\mathrm{Def}(L_\\alpha)$。这意味着 $L_{\\alpha+1}$ 恰好由 $L_\\alpha$ 的所有子集组成，这些子集可以使用来自 $L_\\alpha$ 的参数通过一阶公式在结构 $\\langle L_\\alpha, \\in \\rangle$ 上定义。全集 $L$ 是所有 $L_\\alpha$ 的并集。\n\n要证明 $L \\models \\mathrm{ZF}$，必须证明对于 ZF 的每个公理 $\\psi$，其到 $L$ 的相对化（记作 $\\psi^L$）是 ZF 的一个定理。对于分离和替换这两个公理模式，需要证明对于集合论语言中的任何公式 $\\varphi$，相应的公理实例在 $L$ 中成立。这需要一种方法来处理量化“对于任何公式 $\\varphi$”。这通过哥德尔编码实现，其中每个公式 $\\varphi$ 被赋予一个唯一的自然数 $\\ulcorner\\varphi\\urcorner \\in \\omega$。由于 $\\omega \\subset L$（具体来说，$\\omega \\subseteq L_\\omega$），这些编码可以被当作可构造层级内的对象来处理。\n\n在给定其自由变量的赋值下，一个编码为 $e$ 的公式在结构 $\\langle L_\\alpha, \\in \\rangle$ 中的真值由满足关系 $\\mathsf{Sat}_\\alpha$ 捕捉。一个基本结果是 Tarski 真理不可定义性定理的一个变体，它指出 $\\mathsf{Sat}_\\alpha$ 在 $\\langle L_\\alpha, \\in \\rangle$ 结构自身内部是不可定义的，因此 $\\mathsf{Sat}_\\alpha \\notin L_\\alpha$。然而，Gödel 证明了 $\\mathsf{Sat}_\\alpha$ *是* 可以通过一个在 $L_\\alpha$ 上量化的公式来定义的。因此，代表 $L_\\alpha$ 的满足关系的集合是 $\\mathrm{Def}(L_\\alpha)$ 的一个元素，这意味着 $\\mathsf{Sat}_\\alpha \\in L_{\\alpha+1}$。这种“在下一层级可定义性”是关键机制。\n\n现在，我们来评估每个选项。\n\n**A. 对每个序数 $\\alpha$，关系 $\\mathsf{Sat}_\\alpha$ 是 $L_{\\alpha+1}$ 的一个元素，并且对任意公式编码 $e\\in\\omega\\cap L_\\alpha$ 和参数 $\\vec{p}\\in L_\\alpha$，子集 $$\\{x\\in L_\\alpha:\\mathsf{Sat}_\\alpha(e,x,\\vec{p})\\}$$ 属于 $L_{\\alpha+1}$，从而实现了相对于 $L_\\alpha$ 的分离公理。**\n\n这个陈述结合了两个关键思想。\n1.  第一句话，“对每个序数 $\\alpha$，关系 $\\mathsf{Sat}_\\alpha$ 是 $L_{\\alpha+1}$ 的一个元素”，是证明 $L \\models \\mathrm{ZF}$ 中的一个正确且关键的引理。\n2.  第二句话描述了子集的形成。记号 $\\mathsf{Sat}_\\alpha(e,x,\\vec{p})$ 是 $\\langle L_\\alpha, \\in \\rangle \\models \\varphi_e(x,\\vec{p})$ 的一种形式化写法，其中 $\\varphi_e$ 是哥德尔编码为 $e$ 的公式。集合 $S = \\{x\\in L_\\alpha:\\langle L_\\alpha, \\in \\rangle \\models \\varphi_e(x,\\vec{p})\\}$，根据 $L_{\\alpha+1}$ 的定义，是 $L_{\\alpha+1}$ 的一个元素。它是 $L_\\alpha$ 的一个子集，可用来自 $L_\\alpha$ 的参数 $e$ 和 $\\vec{p}$ 在 $\\langle L_\\alpha, \\in \\rangle$ 上定义（假设 $\\alpha\\ge\\omega$）。\n结论，“从而实现了相对于 $L_\\alpha$ 的分离公理”，也是正确的。这意味着对于任何集合 $A \\in L_\\alpha$ 和任何公式 $\\varphi$，分离出的集合 $\\{x \\in A: \\langle L_\\alpha, \\in \\rangle \\models \\varphi(x, \\vec{p})\\}$ 在 $L_{\\alpha+1}$ 中（因为它可由公式 $x \\in A \\land \\varphi(x, \\vec{p})$ 定义）。该陈述解释了 $L_{\\alpha+1}$ 的定义如何直接满足对 $L_\\alpha$ 中任何集合的分离原则。使用满足关系是捕捉“可通过公式定义”这一概念的形式化工具。\n因此，这个陈述正确地捕捉了论证的一个重要部分。\n\n**结论：正确。**\n\n**B. 需要选择公理 (AC) 和广义连续统假设 (GCH) 来确保公式在 $L_\\alpha$ 中有编码，若没有 AC 和 GCH，分离公理就无法在阶段 $L_{\\alpha+1}$ 实现。**\n\n这个陈述是根本错误的。证明 $L \\models \\mathrm{ZF}$ 的过程完全是在 ZF 集合论内部进行的。选择公理 (AC) 和广义连续统假设 (GCH) 并没有被假定；相反，它们被证明在 $L$ 中为真，这是公理 $V=L$ 的一个推论。公式的哥德尔编码是自然数，而自然数的集合 $\\omega$ 是在 ZF 内部构造的，并且是 $L_{\\omega+1}$ 的成员。因此，对于任何 $\\alpha \\ge \\omega+1$，这些编码都在 $L_\\alpha$ 中。$L$ 的构造以及验证它 remodeled ZF 并不依赖于 AC 或 GCH。\n\n**结论：不正确。**\n\n**C. 如果 $A\\in L_\\alpha$ 并且 $\\varphi(x,y,\\vec{v})$ 使得 $\\langle L_\\alpha,\\in\\rangle$ 验证了对于每个 $x\\in A$ 都存在唯一的 $y\\in L_\\alpha$ 满足 $\\varphi(x,y,\\vec{p})$，那么其值域集 $$\\{y\\in L_\\alpha:\\exists x\\in A\\,\\mathsf{Sat}_\\alpha(\\ulcorner\\varphi\\urcorner,x,y,\\vec{p})\\}$$ 位于 $L_{\\alpha+1}$ 中，这在阶段 $L_{\\alpha+1}$ 证明了对于此类可定义函数的替换公理模式。**\n\n这个陈述描述了替换公理模式的一个简化但重要的情况。它考虑了一个由公式 $\\varphi$ 定义的函数，该函数将集合 $A \\in L_\\alpha$ 映射到同样在 $L_\\alpha$ 内的目标。所描述的集合是这个函数的值域。我们称这个值域集为 $B$。一个元素 $y$ 在 $B$ 中的条件是 $y \\in L_\\alpha$ 并且存在一个 $x \\in A$ 使得 $\\langle L_\\alpha, \\in \\rangle \\models \\varphi(x,y,\\vec{p})$。$B$ 中成员资格的定义条件是公式 $\\psi(y) \\equiv \\exists x (x \\in A \\land \\varphi(x,y,\\vec{p}))$。由于 $A \\in L_\\alpha$ 且参数 $\\vec{p}$ 在 $L_\\alpha$ 中，$\\psi(y)$ 是一个带 $L_\\alpha$ 中参数的一阶公式。因此，$B$ 是 $L_\\alpha$ 的一个在 $\\langle L_\\alpha, \\in \\rangle$ 上可定义的子集。根据 $L_{\\alpha+1}$ 的定义，可以得出 $B \\in L_{\\alpha+1}$。该陈述准确地描述了这一机制，并正确地指出了它如何证明 $L$ 的构造（在下一层级）满足了对此类函数的替换公理。在 $L$ 中对替换公理的完整证明要复杂得多，因为它必须处理值域在 $L_\\alpha$ 中无界的情况，但这个选项正确地描述了这幅图景中的一个有效部分。\n\n**结论：正确。**\n\n**D. 根据 Tarski 的真理不可定义性定理，对于任何 $\\langle L_\\alpha,\\in\\rangle$ 的满足关系在 $L$ 内部都不可定义，因此分离公理在 $L$ 中必定不成立。**\n\n这个陈述误解并误用了 Tarski 的定理。Tarski 的定理意味着 $\\mathsf{Sat}_\\alpha$，即 $\\langle L_\\alpha, \\in \\rangle$ 的满足关系，在*结构* $\\langle L_\\alpha, \\in \\rangle$ *内部*是不可定义的。这意味着 $\\mathsf{Sat}_\\alpha \\notin L_\\alpha$。然而，如前所述，$\\mathsf{Sat}_\\alpha$ 在*上一层级*，即在 $L_\\alpha$ 上是可定义的，因此是 $L_{\\alpha+1}$ 的一个元素。由于 $L_{\\alpha+1} \\subset L$，满足关系 $\\mathsf{Sat}_\\alpha$ 当然是 $L$ 的一个元素，并且在 $L$ 中是可定义的。前提“对于任何...的满足关系在 L 内部都不可定义”是错误的。因此，结论“因此分离公理在 L 中必定不成立”也是错误的，并且实际上直接与 Gödel 的结果 $L \\models \\mathrm{ZF}$ 相矛盾。\n\n**结论：不正确。**\n\n**E. $\\Delta_0$ 公式在 $L_\\alpha$ 与背景全集之间的绝对性足以在阶段 $L_{\\alpha+1}$ 推导出 $L$ 中的完整替换公理模式，而无需使用任何满足关系或哥德尔编码。**\n\n如果一个公式的所有量词都是有界的（例如 $\\forall x \\in y$ 或 $\\exists x \\in y$），那么它就是 $\\Delta_0$ 公式。一个基本结果是，对于集合论一个基本片段的传递模型，$\\Delta_0$ 公式是绝对的，这意味着它们在模型中为真当且仅当它们在整个全集 $V$ 中为真。这是一个强大的工具。然而，分离公理模式和替换公理模式必须对*任何*一阶公式成立，而不仅仅是 $\\Delta_0$ 公式。带有无界量词的公式（例如 $\\exists z \\dots$）不是绝对的。处理这些任意公式需要哥德尔编码和满足关系的全套机制（或等价的工具，如 Skolem 函数和凝聚引理）来形式化关于所有公式的讨论，并为由它们定义的集合的秩设定界限。因此，声称 $\\Delta_0$ 绝对性是*充分的*，这是不正确的。\n\n**结论：不正确。**\n\n总而言之，陈述 A 和 C 正确地描述了可定义性原则（通过满足关系形式化）如何支撑在可构造全集 $L$ 中验证分离和替换公理模式。", "answer": "$$\\boxed{AC}$$", "id": "2973768"}]}