{"hands_on_practices": [{"introduction": "构建插值元最直观的方法之一是“遗忘”或量化掉非共享的信息。本练习将演示这种基于模型的构造方法，其中存在量词被用来从公式中消除局部变量，只留下共享的内容。通过这个练习，您将能够为插值元所代表的语义内容建立起强大的直觉。[@problem_id:2971064]", "problem": "设 $X$ 和 $Y$ 为有限的命题变量集，它们可以有非空交集 $X \\cap Y \\neq \\varnothing$。考虑命题公式 $A$（其变量仅来自 $X$）和 $B$（其变量仅来自 $Y$），并有语义假设 $A \\Rightarrow B$ 是有效的（即，对于变量并集的所有真值赋值，只要 $A$ 为真，$B$ 也为真）。命题逻辑中的克雷格(Craig)插值定理断言，存在一个插值式 $I$，其变量仅来自 $X \\cap Y$，并且满足 $A \\Rightarrow I$ 和 $I \\Rightarrow B$。请仅使用命题逻辑的真值函数语义和命题存在量词的语义定义，证明公式 $I := \\exists(X \\setminus Y)\\, A$ 是一个插值式，并论证 $I$ 仅涉及 $X \\cap Y$ 中的变量。此处，对于一个命题变量 $v$，存在量化定义为 $\\exists v\\, \\varphi := \\varphi[v:=\\top] \\lor \\varphi[v:=\\bot]$；对于一个变量集 $V$，$\\exists V\\, \\varphi$ 表示以任意顺序对 $V$ 中所有变量进行迭代消去。\n\n然后，对于以下具体的合取范式（CNF，Conjunctive Normal Form，是文字析取的合取）实例：\n- $X = \\{p, q, r\\}$ 和 $Y = \\{q, s\\}$，因此 $X \\cap Y = \\{q\\}$，\n- $A$ 由 CNF $A := (\\neg p \\lor q) \\land (\\neg r \\lor q) \\land (p \\lor r)$ 给出，\n- $B$ 由 $B := q$ 给出，\n\n请执行以下操作：\n- 通过生成 $A \\land \\neg B$ 的归结反驳来验证 $A \\Rightarrow B$。\n- 通过执行存在消去来显式计算插值式 $I := \\exists\\{p,r\\}\\, A$，并将结果公式化简为一个仅含变量 $q$ 的逻辑等价公式。\n\n请将您的最终答案表示为仅使用变量 $q$ 的单一封闭形式命题公式。无需四舍五入。您的最终答案必须是计算出的最简逻辑形式的插值式 $I$。", "solution": "该问题经评估为有效，因为它在数理逻辑方面有科学依据，问题表述清晰，客观且内部一致。\n\n该问题包含两部分。第一部分是关于使用存在量化构造克雷格(Craig)插值式的理论证明。第二部分是将此构造应用于一个具体实例。\n\n### 第一部分：理论证明\n\n设 $X$ 和 $Y$ 为有限的命题变量集。设 $A$ 是一个变量来自 $X$ 的公式，记为 $\\text{vars}(A) \\subseteq X$；$B$ 是一个变量来自 $Y$ 的公式，记为 $\\text{vars}(B) \\subseteq Y$。我们已知 $A \\Rightarrow B$ 是一个有效的蕴含式，记为 $A \\models B$。这意味着对于 $X \\cup Y$ 中变量的任何真值赋值 $\\mathcal{M}$，如果 $\\mathcal{M} \\models A$，那么 $\\mathcal{M} \\models B$。\n\n我们需要证明公式 $I := \\exists(X \\setminus Y) A$ 是一个克雷格插值式。这需要证明三个性质：\n$1.$ $I$ 的变量包含于 $X \\cap Y$ 中。\n$2.$ $A \\Rightarrow I$ 是有效的（$A \\models I$）。\n$3.$ $I \\Rightarrow B$ 是有效的（$I \\models B$）。\n\n设 $V = X \\setminus Y$。对变量集 $V = \\{v_1, v_2, \\dots, v_k\\}$ 的存在量词定义为单变量量词的迭代应用，即 $\\exists V \\varphi := \\exists v_1 \\exists v_2 \\dots \\exists v_k \\varphi$。单变量量化定义为 $\\exists v \\varphi := \\varphi[v:=\\top] \\lor \\varphi[v:=\\bot]$。\n\n**1. 插值式 $I$ 的变量**\n\n公式 $A$ 的变量在 $X$ 中，即 $\\text{vars}(A) \\subseteq X$。公式 $I$ 是通过对集合 $V = X \\setminus Y$ 中的所有变量进行存在量化消去而构造的。对公式 $\\varphi$ 中的变量 $v$ 进行存在量化会从结果公式的自由变量集合中移除 $v$。因此，$I$ 的变量是 $\\text{vars}(A) \\setminus V$ 的一个子集。\n$$ \\text{vars}(I) \\subseteq \\text{vars}(A) \\setminus (X \\setminus Y) \\subseteq X \\setminus (X \\setminus Y) $$\n根据集合论，$X \\setminus (X \\setminus Y) = X \\cap (X \\setminus Y)^c = X \\cap (X^c \\cup Y) = (X \\cap X^c) \\cup (X \\cap Y) = \\emptyset \\cup (X \\cap Y) = X \\cap Y$。\n因此，$\\text{vars}(I) \\subseteq X \\cap Y$。第一个性质得到满足。\n\n**2. $A \\models I$ 的证明**\n\n我们需要证明 $A \\Rightarrow \\exists(X \\setminus Y)A$ 是一个永真式。我们可以通过对 $X \\setminus Y$ 中被量化的变量数量进行归纳来证明。我们先证明单个变量 $v$ 的基本情况：$A \\models \\exists v A$。\n设 $\\mathcal{M}$ 是一个任意的真值赋值。我们必须证明如果 $\\mathcal{M} \\models A$，那么 $\\mathcal{M} \\models \\exists v A$。\n假设 $\\mathcal{M} \\models A$。$\\mathcal{M}$ 赋给变量 $v$ 的真值（我们记为 $\\mathcal{M}(v)$）要么是 $\\top$ 要么是 $\\bot$。\n情况1：$\\mathcal{M}(v) = \\top$。$\\mathcal{M}$ 满足 $A$ 等价于 $\\mathcal{M}$ 满足 $A[v:=\\top]$（因为 $v$ 已被赋值为 $\\top$）。因此，$\\mathcal{M} \\models A[v:=\\top]$。由此可得 $\\mathcal{M} \\models A[v:=\\top] \\lor A[v:=\\bot]$，这正是 $\\mathcal{M} \\models \\exists v A$ 的定义。\n情况2：$\\mathcal{M}(v) = \\bot$。类似地，$\\mathcal{M}$ 满足 $A$ 意味着 $\\mathcal{M} \\models A[v:=\\bot]$。这也意味着 $\\mathcal{M} \\models A[v:=\\top] \\lor A[v:=\\bot]$，因此 $\\mathcal{M} \\models \\exists v A$。\n在两种情况下，如果 $\\mathcal{M} \\models A$，那么 $\\mathcal{M} \\models \\exists v A$。因此，$A \\models \\exists v A$。\n\n现在，设 $X \\setminus Y = \\{v_1, v_2, \\dots, v_k\\}$。我们有 $A \\models \\exists v_1 A$。设 $A_1 = \\exists v_1 A$。对 $A_1$ 应用相同的逻辑，我们得到 $A_1 \\models \\exists v_2 A_1$，这意味着 $\\exists v_1 A \\models \\exists v_2 (\\exists v_1 A)$。根据语义蕴涵的传递性，$A \\models \\exists v_2 \\exists v_1 A$。对所有变量 $v_1, \\dots, v_k$ 继续这个过程，我们得出结论 $A \\models \\exists v_k \\dots \\exists v_1 A$，即 $A \\models I$。第二个性质得到满足。\n\n**3. $I \\models B$ 的证明**\n\n根据已知条件 $A \\models B$。我们需要证明 $I \\models B$，即 $\\exists(X \\setminus Y)A \\models B$。\n设 $\\mathcal{M}$ 是对 $\\text{vars}(I) \\cup \\text{vars}(B)$ 中变量的任意赋值。由于 $\\text{vars}(I) \\subseteq X \\cap Y$ 且 $\\text{vars}(B) \\subseteq Y$，赋值 $\\mathcal{M}$ 是为 $(X \\cap Y) \\cup Y = Y$ 中的变量定义的。\n假设 $\\mathcal{M} \\models I$。根据定义，$I = \\exists(X \\setminus Y)A$。在语义上，这等价于对 $V = X \\setminus Y$ 中变量所有可能的真值赋值的析取。设 $\\Sigma$ 是所有 $2^{|V|}$ 个真值赋值 $\\sigma: V \\to \\{\\top, \\bot\\}$ 的集合。那么 $I \\equiv \\bigvee_{\\sigma \\in \\Sigma} A[V:=\\sigma]$，其中 $A[V:=\\sigma]$ 是将公式 $A$ 中 $V$ 的变量替换为 $\\sigma$ 所赋真值的公式。\n假设 $\\mathcal{M} \\models I$ 意味着 $\\mathcal{M} \\models \\bigvee_{\\sigma \\in \\Sigma} A[V:=\\sigma]$。这意味着存在至少一个赋值 $\\sigma_0 \\in \\Sigma$ 使得 $\\mathcal{M} \\models A[V:=\\sigma_0]$。\n让我们为 $X \\cup Y$ 中所有变量定义一个新的赋值 $\\mathcal{M}^*$。令 $\\mathcal{M}^*$ 在所有 $Y$ 中的变量上与 $\\mathcal{M}$ 一致，并在所有 $V = X \\setminus Y$ 中的变量上与 $\\sigma_0$ 一致。由于 $X \\cup Y = Y \\cup (X \\setminus Y)$，$\\mathcal{M}^*$ 是对 $A$ 和 $B$ 中所有变量的一个完备赋值。\n$\\mathcal{M} \\models A[V:=\\sigma_0]$ 的满足性意味着公式 $A$ 在其 $Y \\cap X$ 中的变量根据 $\\mathcal{M}$ 赋值、其 $X \\setminus Y$ 中的变量根据 $\\sigma_0$ 赋值时为真。这正是 $\\mathcal{M}^* \\models A$ 的条件。\n由于我们已知 $A \\models B$，从 $\\mathcal{M}^* \\models A$ 我们可以得出 $\\mathcal{M}^* \\models B$。\n$B$ 的变量全在 $Y$ 中。赋值 $\\mathcal{M}^*$ 在所有 $Y$ 的变量上与 $\\mathcal{M}$ 一致。因此，$B$ 在 $\\mathcal{M}^*$ 下的真值与其在 $\\mathcal{M}$ 下的真值相同。所以，从 $\\mathcal{M}^* \\models B$，我们得出 $\\mathcal{M} \\models B$。\n我们已经证明，对于任何相关赋值 $\\mathcal{M}$，如果 $\\mathcal{M} \\models I$，则 $\\mathcal{M} \\models B$。因此，$I \\models B$。第三个性质得到满足。\n\n理论证明至此完成。\n\n### 第二部分：具体实例\n\n给定：\n- $X = \\{p, q, r\\}$ 和 $Y = \\{q, s\\}$。可得 $X \\cap Y = \\{q\\}$ 和 $X \\setminus Y = \\{p, r\\}$。\n- $A := (\\neg p \\lor q) \\land (\\neg r \\lor q) \\land (p \\lor r)$。\n- $B := q$。\n\n**1. 通过归结验证 $A \\Rightarrow B$**\n\n我们需要证明 $A \\land \\neg B$ 是不可满足的。我们将 $A \\land \\neg B$ 转换为子句集，并通过归结推导出空子句 ($\\Box$)。\n$A \\land \\neg B \\equiv ((\\neg p \\lor q) \\land (\\neg r \\lor q) \\land (p \\lor r)) \\land (\\neg q)$。\n子句集为 $S = \\{\\{\\neg p, q\\}, \\{\\neg r, q\\}, \\{p, r\\}, \\{\\neg q\\}\\}$。\n归结反驳过程如下：\n$1.$ $\\{\\neg p, q\\}$ (来自 $A$)\n$2.$ $\\{\\neg r, q\\}$ (来自 $A$)\n$3.$ $\\{p, r\\}$ (来自 $A$)\n$4.$ $\\{\\neg q\\}$ (来自 $\\neg B$)\n$5.$ $\\{\\neg p\\}$ (由 $1$ 和 $4$ 对 $q$ 进行归结得到)\n$6.$ $\\{\\neg r\\}$ (由 $2$ 和 $4$ 对 $q$ 进行归结得到)\n$7.$ $\\{r\\}$ (由 $3$ 和 $5$ 对 $p$ 进行归结得到)\n$8.$ $\\Box$ (由 $6$ 和 $7$ 对 $r$ 进行归结得到)\n空子句的推导证明了 $A \\land \\neg B$ 是不可满足的，这证实了 $A \\Rightarrow B$ 是一个永真式。\n\n**2. 插值式 $I$ 的计算**\n\n插值式为 $I := \\exists(X \\setminus Y) A = \\exists\\{p, r\\} A$。我们可以按任意顺序消去变量 $p$ 和 $r$。\n$$ I = \\exists p \\exists r ((\\neg p \\lor q) \\land (\\neg r \\lor q) \\land (p \\lor r)) $$\n首先，我们消去 $r$。设 $\\varphi(p, q, r) = (\\neg p \\lor q) \\land (\\neg r \\lor q) \\land (p \\lor r)$。\n$$ \\exists r \\varphi(p, q, r) = \\varphi(p, q, r:=\\top) \\lor \\varphi(p, q, r:=\\bot) $$\n代入 $r=\\top$：\n$$ \\varphi(p, q, \\top) = (\\neg p \\lor q) \\land (\\neg \\top \\lor q) \\land (p \\lor \\top) = (\\neg p \\lor q) \\land (\\bot \\lor q) \\land \\top = (\\neg p \\lor q) \\land q $$\n根据吸收律 $(X \\lor Y) \\land X \\equiv X$，我们有 $(\\neg p \\lor q) \\land q \\equiv q$。\n代入 $r=\\bot$：\n$$ \\varphi(p, q, \\bot) = (\\neg p \\lor q) \\land (\\neg \\bot \\lor q) \\land (p \\lor \\bot) = (\\neg p \\lor q) \\land (\\top \\lor q) \\land p = (\\neg p \\lor q) \\land p $$\n根据分配律，$(\\neg p \\lor q) \\land p = (\\neg p \\land p) \\lor (q \\land p) = \\bot \\lor (p \\land q) \\equiv p \\land q$。\n所以，$\\exists r \\varphi(p, q, r) \\equiv q \\lor (p \\land q)$。\n根据吸收律 $X \\lor (Y \\land X) \\equiv X$，我们有 $q \\lor (p \\land q) \\equiv q$。\n\n现在我们从结果公式 $q$ 中消去 $p$：\n$$ I = \\exists p (q) $$\n由于公式 $q$ 不含变量 $p$，量化没有影响：\n$$ \\exists p (q) = q[p:=\\top] \\lor q[p:=\\bot] = q \\lor q \\equiv q $$\n计算出的插值式是 $I=q$。\n\n为了验证，我们检查 $I=q$ 的性质：\n$1.$ $\\text{vars}(I) = \\{q\\}$，这确实是 $X \\cap Y$。\n$2.$ $A \\Rightarrow I$ 即 $A \\Rightarrow q$，我们已经验证过其为有效的。\n$3.$ $I \\Rightarrow B$ 即 $q \\Rightarrow q$，这是平凡有效的。\n结果是一致的。", "answer": "$$\\boxed{q}$$", "id": "2971064"}, {"introduction": "现在让我们转向对于自动推理至关重要的证明论视角。现代求解器通常通过证明 $A \\land \\neg B$ 的不可满足性来证明蕴含关系 $A \\Rightarrow B$，而决议 (resolution) 是实现这一点的核心方法。本练习将引导您逐步完成强大的 McMillan 算法，该算法通过标注一个决议证明来系统地构造插值元，这正是许多先进工具内部所采用的技术。[@problem_id:2971043]", "problem": "设 $\\mathcal{L}$ 是一个命题词汇表，被划分为三个不相交的变量集合：双方共有的符号集 $S$，左侧局部符号集 $L_{A}$，以及右侧局部符号集 $L_{B}$。考虑以下一个用于克雷格插值定理（Craig interpolation theorem, CIT）的实例。设 $S=\\{s\\}$, $L_{A}=\\{a,b\\}$, 且 $L_{B}=\\varnothing$。定义\n- 左侧公式 $A$ 为子句 $(s\\lor a)$、$(s\\lor b)$ 和 $(\\lnot a\\lor\\lnot b)$ 的合取，\n- 右侧公式 $B$ 为单文字 $s$。\n你将处理合取式 $A\\land\\lnot B$，并使用归结规则证明其不可满足性，然后在该归结证明上执行麦克米兰式插值提取（McMillan-style interpolant extraction）。\n\n仅使用命题逻辑的基本定律和核心定义以及归结规则，不借助任何快捷公式，完成以下任务：\n1. 将 $A\\land\\lnot B$ 转化为子句形式，并构造一个 $A\\land\\lnot B$ 的完整归结反驳（推导出空子句）。\n2. 沿你的归结证明执行麦克米兰式插值提取，同时遵循符号划分 $S=\\{s\\}$, $L_{A}=\\{a,b\\}$, 和 $L_{B}=\\varnothing$。在每一步，明确指出与每个初始子句和每个归结式（resolvent）相关联的插值，并根据主元变量（pivot variable）的类别（公共、$A$-局部或 $B$-局部）说明你使用的组合规则。\n3. 仅基于共享词汇表 $S$ 提供最终的插值，形式为一个封闭形式的命题公式，并尽可能简化。\n\n你的最终答案必须是一个单一的封闭形式符号表达式（不含等式或不等式）。无需数值取整。使用标准的命题连接词在 LaTeX 中表达最终的插值。", "solution": "该问题要求使用 $A \\land \\lnot B$ 的归结反驳，为给定的蕴含式 $A \\implies B$ 推导出一个克雷格插值（Craig interpolant）。我们将遵循指定的步骤：首先，构造一个归结证明；其次，应用麦克米兰式算法（McMillan-style algorithm）从该证明中提取插值。\n\n问题定义的逻辑上下文如下：\n命题词汇表 $\\mathcal{L}$ 被划分为三个不相交的集合：\n- 共享符号集，$S = \\{s\\}$。\n- 公式 $A$ 的局部符号集，$L_A = \\{a, b\\}$。\n- 公式 $B$ 的局部符号集，$L_B = \\varnothing$。\n\n公式 $A$ 和 $B$ 定义如下：\n- $A \\equiv (s \\lor a) \\land (s \\lor b) \\land (\\lnot a \\lor \\lnot b)$。\n- $B \\equiv s$。\n\n克雷格插值定理（Craig Interpolation Theorem）指出，如果 $A \\implies B$ 是一个有效的蕴含式，则存在一个插值公式 $I$，使得：\n1. $A \\implies I$ 是有效的。\n2. $I \\implies B$ 是有效的。\n3. $I$ 中的变量是共享词汇表的子集，即 $\\text{Var}(I) \\subseteq \\text{Var}(A) \\cap \\text{Var}(B) = S$。\n\n为了找到这样一个插值，我们首先证明 $A \\land \\lnot B$ 存在一个归结反驳，这等价于证明 $A \\implies B$ 是一个重言式。\n\n**第一部分：$A \\land \\lnot B$ 的归结反驳**\n\n需要被反驳的公式是 $A \\land \\lnot B$。我们将其转换为子句形式（合取范式）。\n来自 $A$ 的子句是：\n$C_1: \\{s, a\\}$\n$C_2: \\{s, b\\}$\n$C_3: \\{\\lnot a, \\lnot b\\}$\n\n公式 $\\lnot B$ 是 $\\lnot s$。对应的子句是：\n$C_4: \\{\\lnot s\\}$\n\n$A \\land \\lnot B$ 的子句集合是 $\\{C_1, C_2, C_3, C_4\\}$。现在我们使用归结规则 $\\text{Res}(C_i, C_j, p) = (C_i \\setminus \\{p\\}) \\cup (C_j \\setminus \\{\\lnot p\\})$ 推导空子句，记为 $\\bot$。我们构造一个首先从 $L_A$ 中消去局部变量的证明。\n\n1.  对 $C_1 = \\{s, a\\}$ 和 $C_3 = \\{\\lnot a, \\lnot b\\}$ 以主元变量 $a$ 进行归结：\n    $C_5 = \\text{Res}(C_1, C_3, a) = \\{s, \\lnot b\\}$。\n\n2.  对 $C_2 = \\{s, b\\}$ 和新推导出的子句 $C_5 = \\{s, \\lnot b\\}$ 以主元变量 $b$ 进行归结：\n    $C_6 = \\text{Res}(C_2, C_5, b) = \\{s, s\\} = \\{s\\}$。\n\n3.  对 $C_6 = \\{s\\}$ 和 $C_4 = \\{\\lnot s\\}$ 以主元变量 $s$ 进行归结：\n    $C_7 = \\text{Res}(C_6, C_4, s) = \\{\\} = \\bot$。\n\n空子句 $\\bot$ 的推导构成了一个有效的归结反驳。这证实了 $A \\land \\lnot B$ 是不可满足的，因此插值存在。\n\n**第二部分：麦克米兰式插值提取**\n\n我们现在将麦克米兰式算法应用于上面生成的归结证明。对于证明中的每个子句 $C$（包括初始子句和派生子句），我们在共享词汇表 $S = \\{s\\}$ 上计算一个部分插值 $I(C)$。\n\n计算插值的规则如下：\n\n- **初始化：**\n    1. 对于任何源自 $A$ 的初始子句 $C$，其插值 $I(C)$是 $C$ 中所有变量属于共享集 $S$ 的文字的析取。如果不存在这样的文字，则插值为 $\\bot$（假）。\n    2. 对于任何源自 $\\lnot B$ 的初始子句 $C$，其插值 $I(C)$ 为 $\\top$（真）。\n\n- **归结步骤的组合：**\n    设 $C = \\text{Res}(C_i, C_j, p)$，其中 $p$ 是主元变量。\n    1. 如果 $p \\in L_A$（主元是 $A$-局部的），新的插值是 $I(C) = I(C_i) \\lor I(C_j)$。\n    2. 如果 $p \\in L_B$（主元是 $B$-局部的），新的插值是 $I(C) = I(C_i) \\land I(C_j)$。在本问题中，$L_B = \\varnothing$，所以这种情况不会发生。\n    3. 如果 $p \\in S$（主元是共享的），新的插值是 $I(C) = I(C_i) \\land I(C_j)$。这个简化规则适用于一个父子句完全由 $A$-子句派生，而另一个父子句来自 $B$-子句的情况。\n\n我们现在通过归结证明来追踪插值：\n\n- **初始子句的插值：**\n    - $C_1 = \\{s, a\\}$ 来自 $A$。共享文字是 $s$。\n      $I(C_1) = s$。\n    - $C_2 = \\{s, b\\}$ 来自 $A$。共享文字是 $s$。\n      $I(C_2) = s$。\n    - $C_3 = \\{\\lnot a, \\lnot b\\}$ 来自 $A$。它不包含共享文字。\n      $I(C_3) = \\bot$。\n    - $C_4 = \\{\\lnot s\\}$ 来自 $\\lnot B$。\n      $I(C_4) = \\top$。\n\n- **派生子句的插值：**\n\n    - **步骤 1：** $C_5 = \\text{Res}(C_1, C_3, a)$。\n      - 主元是 $a$。由于 $a \\in L_A = \\{a, b\\}$，这是一个 $A$-局部主元。\n      - 我们使用规则 $I(C_5) = I(C_1) \\lor I(C_3)$。\n      - $I(C_5) = s \\lor \\bot \\equiv s$。\n\n    - **步骤 2：** $C_6 = \\text{Res}(C_2, C_5, b)$。\n      - 主元是 $b$。由于 $b \\in L_A = \\{a, b\\}$，这是一个 $A$-局部主元。\n      - 我们使用规则 $I(C_6) = I(C_2) \\lor I(C_5)$。\n      - $I(C_6) = s \\lor s \\equiv s$。\n\n    - **步骤 3：** $C_7 = \\bot = \\text{Res}(C_6, C_4, s)$。\n      - 主元是 $s$。由于 $s \\in S = \\{s\\}$，这是一个共享主元。\n      - 父子句是 $C_6$（完全由 $A$-子句派生）和 $C_4$（一个 $\\lnot B$-子句）。\n      - 我们使用规则 $I(C_7) = I(C_6) \\land I(C_4)$。\n      - $I(\\bot) = s \\land \\top \\equiv s$。\n\n**第三部分：最终插值**\n\n对于蕴含式 $A \\implies B$ 的插值是为空子句计算出的插值，$I(\\bot)$。\n因此，最终的插值是 $I = s$。\n\n我们验证 $I=s$ 是一个有效的插值：\n1.  $\\text{Var}(I) = \\{s\\}$，它是共享词汇表 $S = \\{s\\}$ 的子集。此条件成立。\n2.  $A \\implies I$ 必须有效。这意味着 $A \\land \\lnot I$ 必须是不可满足的。$A \\land \\lnot s \\equiv ((s \\lor a) \\land (s \\lor b) \\land (\\lnot a \\lor \\lnot b)) \\land \\lnot s$。如果 $s$ 为假，该式简化为 $(a) \\land (b) \\land (\\lnot a \\lor \\lnot b)$，这是一个矛盾。因此，$A \\implies s$ 是有效的。\n3.  $I \\implies B$ 必须有效。即 $s \\implies s$，这是一个平凡的重言式。\n\n推导出的公式 $s$ 满足给定实例的克雷格插值的所有属性。它已经是其最简形式。", "answer": "$$\\boxed{s}$$", "id": "2971043"}, {"introduction": "为了连接纯逻辑与在自动验证（SMT）中的实际应用，我们将探讨特定理论中的插值。现实世界的问题常常涉及如数组这样的特定数据结构。本练习深入探讨了数组的无量词理论，展示了如何通过分析理论的公理（读写公理）并将推论投影到共享词汇上来构造插值元，这对于理解程序分析和软件验证中的抽象技术至关重要。[@problem_id:2971036]", "problem": "考虑遵循 McCarthy 公理的无量词数组理论，其中索引类型和元素类型均被指定为整数。该理论有两个基本操作：对于任意数组项 $a$、索引项 $i$ 和元素项 $v$，项 $\\mathit{write}(a,i,v)$ 表示一个与 $a$ 相同的数组，只是在索引 $i$ 处的值为 $v$；项 $\\mathit{read}(a,i)$（写作 $a[i]$）表示存储在数组 $a$ 中索引 $i$ 处的元素。该理论由以下“读重写”法则（read-over-write laws）公理化：\n- $\\mathit{read}(\\mathit{write}(a,i,v),i) = v$。\n- 对于所有索引 $i,j$，如果 $i \\neq j$，则 $\\mathit{read}(\\mathit{write}(a,i,v),j) = \\mathit{read}(a,j)$。\n\nCraig 插值定理指出：若公式 $A$ 和 $B$ 使得 $A \\land B$ 不可满足，则存在一个公式 $I$，其使用的符号均属于 $A$ 和 $B$ 共享的符号集，使得 $A \\models I$ 且 $I \\land B$ 不可满足。\n\n设计一个算法，在给定不可满足的无量词数组约束 $A$ 和 $B$ 的情况下，使用索引和元素投影构造一个无量词的 Craig 插值式。你的算法应从上述公理和基本命题推理出发。它必须：\n- 解释如何形成一个索引投影，该投影以遵循共享签名域约束的方式，在应用“读重写”法则时记录下出现在 $A$ 中的索引之间的相等或不等关系。\n- 解释如何形成一个元素投影，该投影记录在同样应用“读重写”法则的情况下，由 $A$ 强制产生的元素项之间的相等关系。\n- 解释如何将这些投影组合成一个无量词插值式，该插值式只使用共享符号且被 $A$ 所蕴含。\n\n然后，将你的算法应用于以下具体实例。设 $i$ 和 $k$ 为共享索引变量，$v$ 为共享元素变量，$a$ 和 $b$ 为 $A$ 的局部数组变量。考虑\n- $A \\equiv \\big( b = \\mathit{write}(a,i,1) \\big) \\land \\big( v = \\mathit{read}(b,k) \\big)$，\n- $B \\equiv \\big( i = k \\big) \\land \\big( v \\neq 1 \\big)$。\n\n证明在无量词数组理论中，仅使用上述公理，$A \\land B$ 是不可满足的；在此实例上逐步执行你的索引和元素投影算法；并计算出在共享签名域 $\\{i,k,v\\}$ 上的插值式 $I$ 的一个单一闭式解析表达式。最终答案必须是 $I$ 的 LaTeX 句法表达式。无需四舍五入，也不涉及物理单位。将最终插值式表示为单个公式。", "solution": "此问题有效。它是在数理逻辑和自动推理这一既定领域内的一个适定问题，特别涉及可满足性模理论（SMT）和数组理论的 Craig 插值。所有术语都已正式定义，任务是基于一组明确说明的公理和初始公式，推导出一个特定的逻辑公式。\n\n总体任务是首先描述一个在无量词数组理论中构造 Craig 插值式的通用算法，然后将其应用于一个具体实例。\n\n### 数组理论中的插值通用算法\n\n设 $A$ 和 $B$ 是数组理论中的两个无量词公式，它们的合取 $A \\land B$ 是不可满足的。设 $\\Sigma_A$ 和 $\\Sigma_B$ 分别是 $A$ 和 $B$ 中的非逻辑符号（变量、常量、函数）集合。共享签名域为 $\\Sigma_{sh} = \\Sigma_A \\cap \\Sigma_B$。一个 Craig 插值式 $I$ 是满足以下条件的公式：\n1.  $A \\models I$（$A$ 蕴含 $I$）。\n2.  $I \\land B$ 是不可满足的。\n3.  $I$ 的签名域是 $\\Sigma_{sh}$ 的一个子集。\n\n该算法从 $A \\land B$ 不可满足的证明中构造 $I$。其核心思想是追踪 $A$ 的推论，但只传播那些能用共享签名域 $\\Sigma_{sh}$ 表达的信息。\n\n**步骤 1：证明生成与替换**\n首先，我们证明 $A \\land B$ 是不可满足的。对于无量词理论，这通常涉及等量代换和应用理论公理，直到推导出显式矛盾（例如 $\\perp$ 或 $x=y \\land x \\neq y$）。在此过程中，我们通过将 $A$ 的局部变量（即在 $\\Sigma_A \\setminus \\Sigma_{sh}$ 中的变量）的定义代入从 $A$ 推导出的推理的其他部分，来消除这些变量。这通常会分离出形如 $\\mathit{read}(\\mathit{write}(\\dots))$ 的项。\n\n**步骤 2：形成索引和元素投影**\n应用“读重写”公理是在数组理论中推导结论的核心步骤。当我们遇到一个从 $A$ 推导出的形如 $\\mathit{read}(\\mathit{write}(a,i,v),j)$ 的项时，我们根据索引 $i$ 和 $j$ 进行情况划分：\n\n- **情况 1：** $i = j$。该项简化为 $v$。\n- **情况 2：** $i \\neq j$。该项简化为 $\\mathit{read}(a,j)$。\n\n这种按情况划分引出了投影的生成：\n\n- **索引投影** 是一个只包含共享签名域 $\\Sigma_{sh}$ 中索引的公式。它表示对这些索引的一个条件。在上述情况划分中，如果 $i$ 和 $j$ 都在 $\\Sigma_{sh}$ 中，那么公式 $i=j$（及其否定 $i \\neq j$）就是索引投影的候选者。这个投影捕获了 $A$ 在何种情况下会产生特定信息。\n\n- **元素投影** 是一个只包含共享签名域 $\\Sigma_{sh}$ 中元素类型项的公式。它表示在某个特定索引投影下对这些项成立的推论。例如，如果在索引投影 $i=j$ 下，原始数组项简化为一个共享值 $v$，从而导出一个形如 $t=v$ 的等式（其中 $t$ 也是共享的），那么 $t=v$ 就是元素投影的候选者。如果某个情况导出的推论涉及局部变量（例如 $\\mathit{read}(a,j)$，其中 $a$ 是 $A$ 的局部变量），则该推理分支在构造插值式时将被舍弃，因为它无法在 $\\Sigma_{sh}$ 中表达。\n\n**步骤 3：将投影组合成插值式**\n插值式 $I$ 被构造为派生投影的逻辑组合。对于每个能够导出可在 $\\Sigma_{sh}$ 中表达的相应元素投影 $C_{elem}$ 的索引投影 $C_{idx}$，我们都已证明 $A \\models (C_{idx} \\Rightarrow C_{elem})$。最终的插值式 $I$ 是从证明中推导出的所有此类蕴含式的合取。这通常可以简化为单个逻辑公式。\n\n### 在具体实例上的应用\n\n给定：\n- $A \\equiv \\big( b = \\mathit{write}(a,i,1) \\big) \\land \\big( v = \\mathit{read}(b,k) \\big)$\n- $B \\equiv \\big( i = k \\big) \\land \\big( v \\neq 1 \\big)$\n- 共享签名域为 $\\Sigma_{sh} = \\{i, k, v\\}$。数组变量 $a$ 和 $b$ 是 $A$ 的局部变量。\n\n**步骤 1：证明 $A \\land B$ 的不可满足性**\n\n1.  假设 $A \\land B$ 成立。\n2.  从 $A$ 中，我们有等式 $b = \\mathit{write}(a,i,1)$ 和 $v = \\mathit{read}(b,k)$。\n3.  将第一个等式中 $b$ 的表达式代入第二个等式：$v = \\mathit{read}(\\mathit{write}(a,i,1), k)$。这个推论完全由 $A$ 导出。\n4.  从 $B$ 中，我们有等式 $i = k$。\n5.  将条件 $i=k$ 应用于步骤 3 中导出的表达式。现在 $\\mathit{read}$ 和 $\\mathit{write}$ 操作的索引相等。\n6.  根据第一条数组公理 $\\mathit{read}(\\mathit{write}(a,i,v'),i) = v'$，由于 $i=k$，我们得到 $\\mathit{read}(\\mathit{write}(a,i,1),k) = 1$。\n7.  结合步骤 3 和 6，我们推断出 $v = 1$。\n8.  从 $B$ 中，我们还有不等式 $v \\neq 1$。\n9.  步骤 7 和 8 产生了矛盾 $(v = 1) \\land (v \\neq 1)$。\n10. 因此，$A \\land B$ 是不可满足的。\n\n**步骤 2：执行投影算法**\n\n我们现在重新进行证明，并仔细追踪哪些信息可以用 $\\Sigma_{sh} = \\{i, k, v\\}$ 来表达。\n\n1.  **在 $A$ 中进行替换**：如同证明中一样，我们从 $A$ 出发，替换局部变量 $b$。这得出了 $A$ 的关键推论：\n    $$v = \\mathit{read}(\\mathit{write}(a,i,1), k)$$\n\n2.  **情况划分与投影**：我们使用数组公理分析项 $\\mathit{read}(\\mathit{write}(a,i,1), k)$。所涉及的索引是 $i$ 和 $k$。两者都在共享签名域 $\\Sigma_{sh}$ 中。\n\n    - **情况 (a)：** $i = k$。\n        - 这是一个关于共享索引的条件。这个公式 $i=k$ 就是我们的**索引投影**。\n        - 在此假设下，应用第一条数组公理：$\\mathit{read}(\\mathit{write}(a,i,1),k) = 1$。\n        - 将此代回步骤 1 的推论，得到 $v = 1$。\n        - 变量 $v$ 在 $\\Sigma_{sh}$ 中，而 $1$ 是一个常量。因此，公式 $v=1$ 可在 $\\Sigma_{sh}$ 中表达。这是我们对应于索引投影 $i=k$ 的**元素投影**。\n\n    - **情况 (b)：** $i \\neq k$。\n        - 这个条件 $i \\neq k$ 是另一个潜在的索引投影。\n        - 在此假设下，应用第二条数组公理：$\\mathit{read}(\\mathit{write}(a,i,1),k) = \\mathit{read}(a,k)$。\n        - 步骤 1 的推论变为 $v = \\mathit{read}(a,k)$。\n        - 项 $\\mathit{read}(a,k)$ 依赖于变量 $a$，而 $a$ 是 $A$ 的局部变量，不在 $\\Sigma_{sh}$ 中。因此，这个等式不能成为插值式的一部分。此路径没有产生有用的元素投影。\n\n**步骤 3：将投影组合成插值式 $I$**\n\n我们的分析只找到一条路径，它在共享签名域中产生了一个非平凡的推论：即 $i=k$ 蕴含 $v=1$ 的情况。这给了我们这个蕴含式：\n$$ (i=k) \\Rightarrow (v=1) $$\n让我们将插值式 $I$ 定义为这个公式：$I \\equiv (i=k) \\Rightarrow (v=1)$。我们必须验证它是否满足 Craig 插值式的三个条件。\n\n1.  **$A \\models I$**：我们在步骤 2 中的推导表明，从 $A$ 可以导出 $v = \\mathit{read}(\\mathit{write}(a,i,1),k)$。如果我们假设 $I$ 的前件 $i=k$，根据数组公理，该表达式简化为 $v=1$（$I$ 的后件）。这正式地表明 $A$ 蕴含 $(i=k) \\Rightarrow (v=1)$。\n\n2.  **$I \\land B$ 是不可满足的**：我们检验 $I \\equiv (i=k) \\Rightarrow (v=1)$ 和 $B \\equiv (i=k) \\land (v \\neq 1)$ 的合取：\n    $$ \\big( (i=k) \\Rightarrow (v=1) \\big) \\land \\big( (i=k) \\land (v \\neq 1) \\big) $$\n    从合取项 $(i=k) \\Rightarrow (v=1)$ 和 $i=k$，我们可以通过肯定前件式推断出 $v=1$。这与另一个合取项 $v \\neq 1$ 相矛盾。因此，$I \\land B$ 是不可满足的。\n\n3.  **$I$ 的签名域在 $\\Sigma_{sh}$ 中**：公式 $I \\equiv (i=k) \\Rightarrow (v=1)$ 只包含符号 $i$、$k$、$v$、等价谓词和常量 $1$。所有这些符号都在共享签名域 $\\Sigma_{sh} = \\{i,k,v\\}$ 中（常量和逻辑连接词被认为是默认共享的）。\n\n公式 $I \\equiv (i=k) \\Rightarrow (v=1)$ 满足给定 $A$ 和 $B$ 的 Craig 插值式的所有性质。这个公式也可以表达为其逻辑等价形式 $(i \\neq k) \\lor (v=1)$。我们提供蕴含形式作为最终答案，因为它最直接地反映了投影算法的推理过程。", "answer": "$$ \\boxed{(i = k) \\Rightarrow (v = 1)} $$", "id": "2971036"}]}