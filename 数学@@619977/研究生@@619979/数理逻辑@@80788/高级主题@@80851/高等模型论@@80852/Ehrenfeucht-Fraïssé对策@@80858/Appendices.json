{"hands_on_practices": [{"introduction": "让我们从一个具体的回合制游戏开始，热身一下。这个练习将带你逐步体验Ehrenfeucht-Fraïssé游戏的基本规则，重点是如何在每一步中维持局部同构。通过在代表字符串“abba”和“baab”的两个线性结构上进行游戏，你将练习检查一元谓词和顺序关系，这是掌握复制者（Duplicator）获胜策略的基础。[@problem_id:1420765]", "problem": "在描述复杂性理论中，Ehrenfeucht-Fraïssé（EF）博弈是一种用于判断两个逻辑结构是否初等等价的工具。考虑两个线性结构 $S_1$ 和 $S_2$，它们分别代表字符串 \"abba\" 和 \"baab\"。\n\n两个结构都拥有论域 $U = \\{1, 2, 3, 4\\}$。它们的词汇表包含一个代表整数常规顺序的二元关系符号 $<$，以及两个一元谓词符号 $P_a$ 和 $P_b$。\n- 对于结构 $S_1$ (\"abba\"): $P_a$ 对于元素 $\\{1, 4\\}$ 为真，$P_b$ 对于元素 $\\{2, 3\\}$ 为真。\n- 对于结构 $S_2$ (\"baab\"): $P_b$ 对于元素 $\\{1, 4\\}$ 为真，$P_a$ 对于元素 $\\{2, 3\\}$ 为真。\n\n在 $S_1$ 和 $S_2$ 上进行一个两轮的EF博弈。在每一轮 $i=1, 2$ 中，一个玩家（称为“破坏者”，Spoiler）从 $S_1$ 或 $S_2$ 中选择一个元素。另一个玩家（称为“复制者”，Duplicator）则从另一个结构中选择一个元素作为回应。设破坏者的选择为 $p_1, p_2$，复制者对应的选择为 $q_1, q_2$。如果对于 $i \\in \\{1, 2\\}$，映射 $f(p_i) = q_i$ 是一个部分同构，则复制者获胜。这意味着对于所有选择的元素，它们的类型和相对顺序必须被保持。具体来说，对于所有的 $i,j \\in \\{1,2\\}$：\n1. 元素 $p_i$ 在其结构中满足一个谓词（$P_a$ 或 $P_b$），当且仅当对应的元素 $q_i$ 在另一个结构中满足相同的谓词。\n2. 关系 $p_i < p_j$ 成立，当且仅当 $q_i < q_j$ 成立。\n\n假设博弈按以下方式进行：\n- **第一轮**：破坏者从结构 $S_1$ 中选择位置为 2 的元素。复制者回应，从结构 $S_2$ 中选择位置为 1 的元素。\n- **第二轮**：破坏者进行第二步移动，从结构 $S_1$ 中选择位置为 3 的元素。\n\n为了不输掉博弈，复制者必须从结构 $S_2$ 中选择哪个元素？\n\nA. 1\n\nB. 2\n\nC. 3\n\nD. 4", "solution": "让我们逐步分析博弈的状态，以确定复制者的正确移动。目标是选择第二个元素，使得最终两对点的映射构成结构 $S_1$ 和 $S_2$ 之间的部分同构。\n\n**结构：**\n- $S_1$ (\"abba\"): $P_a = \\{1, 4\\}, P_b = \\{2, 3\\}$\n- $S_2$ (\"baab\"): $P_a = \\{2, 3\\}, P_b = \\{1, 4\\}$\n关系是论域 $U = \\{1, 2, 3, 4\\}$ 上的 < 。\n\n**第一轮：**\n- 破坏者从 $S_1$ 中选择 $p_1 = 2$。\n- 复制者从 $S_2$ 中选择 $q_1 = 1$。\n\n我们来验证这第一轮的对应关系。在 $S_1$ 中，元素 2 满足谓词 $P_b$。在 $S_2$ 中，元素 1 满足谓词 $P_b$。类型匹配，因此对于第一轮来说，这是一个有效的部分同构。\n\n**第二轮：**\n- 破坏者从 $S_1$ 中选择 $p_2 = 3$。\n- 复制者必须从 $S_2$ 中选择一个元素 $q_2$，且 $q_2$ 尚未被选择过（即 $q_2 \\neq q_1=1$）。\n\n最终的映射将把来自 $S_1$ 的点对 $(p_1, p_2)$ 与来自 $S_2$ 的点对 $(q_1, q_2)$ 关联起来。该映射为 $f = \\{(p_1, q_1), (p_2, q_2)\\} = \\{(2, 1), (3, q_2)\\}$。我们必须找到使之成为部分同构的 $q_2$ 的值。\n\n**条件1：谓词保持**\n破坏者选择的元素是来自 $S_1$ 的 $p_2=3$。对此元素为真的谓词是 $P_b$。因此，复制者从 $S_2$ 中选择的 $q_2$ 也必须满足谓词 $P_b$。\n在 $S_2$ 中满足 $P_b$ 的元素是 $\\{1, 4\\}$。\n由于 $q_1=1$ 已经被选择，唯一可用的且匹配谓词的 $q_2$ 元素是 $q_2=4$。\n此时，我们已经确定，如果存在有效的移动，那一定是 $q_2=4$。选项 A、B 和 C 是不正确的，因为它们在 $S_2$ 中对应的元素要么已经被占用，要么不匹配所需的谓词类型（2 和 3 对应 $P_a$，1 对应 $P_b$）。\n\n**条件2：顺序保持**\n现在我们必须验证选择 $q_2=4$ 是否保持了顺序关系。完整的映射是 $\\{(2, 1), (3, 4)\\}$。\n我们需要为来自 $\\{1,2\\}$ 的所有索引对 $(i,j)$ 检查条件 $p_i < p_j \\iff q_i < q_j$。\n非平凡的检查是针对 $(i,j) = (1,2)$。\n- 在 $S_1$ 中，我们比较 $p_1=2$ 和 $p_2=3$。关系 $p_1 < p_2$（即 $2 < 3$）为真。\n- 在 $S_2$ 中，我们比较 $q_1=1$ 和 $q_2=4$。关系 $q_1 < q_2$（即 $1 < 4$）为真。\n\n该条件变为 真 $\\iff$ 真，这是满足的。对 $(i,j)=(2,1)$ 的检查是等价的（$p_2 < p_1 \\iff q_2 < q_1$ 变为 假 $\\iff$ 假，这也是满足的）。\n因此，选择 $q_2=4$ 既保持了谓词，也保持了顺序关系。\n\n**结论：**\n为了不在这一轮输掉，复制者唯一有效的移动是选择结构 $S_2$ 中位置为 4 的元素。这对应于选项 D。", "answer": "$$\\boxed{D}$$", "id": "1420765"}, {"introduction": "掌握了基本规则后，我们来探讨更有挑战性的策略设计。这个练习要求你为破坏者（Spoiler）设计一个必胜策略，以证明某个性质（“存在一个只有一个孩子的节点”）是可以在一阶逻辑中表达的。通过分析在两种树结构上的对决，你将深刻理解游戏的回合数与区分这两个结构的逻辑公式的量词秩之间的根本联系。[@problem_id:2972065]", "problem": "考虑一阶语言 $\\mathcal{L}$，它包含一个表示根节点的一元谓词 $R(x)$，一个解释为“$y$ 是 $x$ 的子节点”的二元关系 $C(x,y)$，以及一个解释为“$x$ 和 $y$ 是不同的兄弟节点”的二元关系 $S(x,y)$，即存在 $p$ 使得 $C(p,x)$ 和 $C(p,y)$ 成立且 $x \\neq y$。设 $\\mathcal{A}$ 和 $\\mathcal{B}$ 是标记 $\\mathcal{L}$ 下的两个有限有根树结构，二者的高度都至少为 $2$，且 $R$、$C$ 和 $S$ 具有预期的解释，并满足：\n\n- 在 $\\mathcal{A}$ 中，存在一个节点 $u$，它恰好有一个子节点 $v$，即 $C(u,v)$ 成立，且对于所有 $w$，如果 $C(u,w)$ 成立，则 $w=v$。\n- 在 $\\mathcal{B}$ 中，每个非叶节点都至少有两个子节点。\n\n假设除了上述差异外，这些树在其他方面足够相似，以至于除了单子节点与多子节点现象外，深度为 $1$ 以内的局部邻域在两个结构之间可以相互匹配。请分析在这两个结构上的 Ehrenfeucht–Fraïssé (EF) 博弈 (Ehrenfeucht–Fraïssé game)。\n\n下列哪个陈述是正确的？\n\nA. 在 $\\mathcal{A}$ 和 $\\mathcal{B}$ 上的 $2$ 轮 EF 博弈中，破坏者（Spoiler）有一个获胜策略，即在 $\\mathcal{A}$ 中放置棋子于一个父节点及其唯一的子节点上，因为在 $\\mathcal{B}$ 中，已放置棋子的元素之间的兄弟关系已经被破坏。\n\nB. 破坏者需要 $3$ 轮来造成不匹配：在 $\\mathcal{A}$ 中放置棋子于父节点 $u$ 及其唯一子节点 $v$ 之后，破坏者在第 $3$ 轮中，在 $\\mathcal{B}$ 中匹配的父节点 $u'$ 的第二个子节点 $w$ 上放置棋子；复制者（Duplicator）无法在 $\\mathcal{A}$ 中找到 $v$ 的兄弟节点（不存在）来回应，同时保持局部同构，因此破坏者在 $3$ 轮内获胜。\n\nC. “存在一个恰好有一个子节点的节点”这个一阶性质可以在 $\\mathcal{L}$ 中表达，并且区分 $\\mathcal{A}$ 和 $\\mathcal{B}$ 的语句的最小量词秩是 $3$。\n\nD. 即使在 $3$ 轮博弈中，复制者也总能通过选择叶节点来回应以保持局部同构，因此在这个标记下，EF 博弈无法检测到存在一个恰好有一个子节点的节点。\n\nE. 兄弟关系 $S(x,y)$ 对于区分这两个结构并非必不可少：在仅包含 $R(x)$ 和 $C(x,y)$ 的标记中，破坏者仍然可以在 $3$ 轮内获胜，通过在 $\\mathcal{A}$ 中放置棋子于一个父节点及其唯一子节点上，然后在 $\\mathcal{B}$ 中匹配的父节点的第二个子节点上放置棋子，从而在 $\\mathcal{A}$ 中强制造成子节点关系配置的破坏。", "solution": "首先对问题陈述进行严格的验证过程。\n\n### 第 1 步：提取已知条件\n- **语言 $\\mathcal{L}$**：一个一阶语言，其标记包含：\n    - 一个一元谓词 $R(x)$，解释为“$x$ 是一个根节点”。\n    - 一个二元关系 $C(x,y)$，解释为“$y$ 是 $x$ 的一个子节点”。\n    - 一个二元关系 $S(x,y)$，解释为“$x$ 和 $y$ 是不同的兄弟节点”，其定义为“存在 $p$ 使得 $C(p,x)$ 和 $C(p,y)$ 成立且 $x \\neq y$”。\n- **结构 $\\mathcal{A}$ 和 $\\mathcal{B}$**：标记 $\\mathcal{L}$ 下的两个有限有根树结构。\n- **结构属性**：\n    - $\\mathcal{A}$ 和 $\\mathcal{B}$ 的高度都至少为 $2$。\n    - 在结构 $\\mathcal{A}$ 中，存在一个节点 $u$，它恰好有一个子节点 $v$。\n    - 在结构 $\\mathcal{B}$ 中，每个非叶节点都至少有两个子节点。\n- **假设**：“除了上述差异外，这些树在其他方面足够相似，以至于除了单子节点与多子节点现象外，深度为 $1$ 以内的局部邻域在两个结构之间可以相互匹配。”\n- **任务**：分析在 $\\mathcal{A}$ 和 $\\mathcal{B}$ 上的 Ehrenfeucht–Fraïssé (EF) 博弈，并确定给定陈述的正确性。\n\n### 第 2 步：使用提取的已知条件进行验证\n该问题在数理逻辑，特别是模型论和有限模型论的背景下是良定义的。\n- **科学依据**：一阶语言、结构和 Ehrenfeucht-Fraïssé 博弈的概念是标准的，并且是模型论的基石。该问题的设置在理论上是合理的。\n- **适定性**：结构 $\\mathcal{A}$ 和 $\\mathcal{B}$ 的属性被给出的精度足以进行形式化分析。区分性属性被明确陈述。关于 EF 博弈结果的问题是该领域的标准形式问题。兄弟关系 $S(x,y)$ 的定义是明确的。\n- **客观性**：该问题以精确、客观和形式化的数学语言陈述。\n- **完备性**：该问题提供了进行分析所需的所有必要定义。非正式短语“otherwise similar enough”（在其他方面足够相似）是此类问题中的常见手法，旨在指示解题者专注于指定的差异，而不要被结构之间其他潜在的、琐碎的差异所分心。\n\n### 第 3 步：结论与行动\n该问题是有效的。接下来将对解决方案进行严格推导并分析各个选项。\n\n***\n\n### 解题推导\n\n此问题的核心在于 Ehrenfeucht-Fraïssé 定理，该定理在模型论概念（基本等价于某个量词秩）和博弈论概念（在 EF 博弈中存在获胜策略）之间建立了一种对偶关系。具体来说，两个结构 $\\mathcal{A}$ 和 $\\mathcal{B}$ 无法被任何量词秩至多为 $k$ 的一阶语句区分，当且仅当复制者在 $k$ 轮 EF 博弈（记为 $G_k(\\mathcal{A}, \\mathcal{B})$）中拥有获胜策略。如果破坏者拥有获胜策略，则这两个结构可以被量词秩至多为 $k$ 的语句区分。\n\n$\\mathcal{A}$ 和 $\\mathcal{B}$ 之间的定义性差异在于，$\\mathcal{A}$ 包含一个恰好有一个子节点的节点，而在 $\\mathcal{B}$ 中，所有非叶节点都至少有两个子节点。让我们将“存在一个恰好有一个子节点的节点”这一性质表达为语言 $\\mathcal{L}$ 中的一个一阶语句。一个节点 $u$ 恰好有一个子节点，当且仅当存在某个节点 $v$ 是 $u$ 的子节点，并且任何是 $u$ 的子节点的节点 $w$ 都必须与 $v$ 相同。\n\n这可以翻译为以下一阶语句 $\\Phi$：\n$$ \\Phi \\equiv \\exists u \\, \\exists v \\, (C(u,v) \\land \\forall w \\, (C(u,w) \\rightarrow w=v)) $$\n这个语句 $\\Phi$ 在 $\\mathcal{A}$ 中为真（即 $\\mathcal{A} \\models \\Phi$），在 $\\mathcal{B}$ 中为假（即 $\\mathcal{B} \\models \\neg\\Phi$）。由于量词序列 $\\exists u \\, \\exists v \\, \\forall w$，$\\Phi$ 的量词秩为 $3$。\n\n根据 Ehrenfeucht-Fraïssé 定理，存在一个量词秩为 $3$ 的区分语句意味着破坏者在 $3$ 轮博弈 $G_3(\\mathcal{A}, \\mathcal{B})$ 中有获胜策略。要确定 $3$ 是否是所需的*最小*轮数，我们必须分析 $2$ 轮博弈 $G_2(\\mathcal{A}, \\mathcal{B})$。如果复制者赢得 $G_2$，那么没有量词秩为 $2$ 的语句可以区分这两个结构，因此 $3$ 是最小秩。\n\n**$2$ 轮博弈 $G_2(\\mathcal{A}, \\mathcal{B})$ 分析**\n复制者有获胜策略。一个覆盖了 $\\mathcal{A}$ 和 $\\mathcal{B}$ 中已放置棋子的元素的局部映射 $p = \\{(a_1, b_1), \\dots, (a_i, b_i)\\}$ 是一个局部同构，如果在 $p$ 的定义域中任意选择元素 $c_1, \\dots, c_m$ 和任意原子公式 $\\psi(x_1, \\dots, x_m)$，都有 $\\mathcal{A} \\models \\psi(c_1, \\dots, c_m) \\iff \\mathcal{B} \\models \\psi(p(c_1), \\dots, p(c_m))$。原子公式包括 $x=y$、$R(x)$、$C(x,y)$ 和 $S(x,y)$。\n\n- **第 1 轮**：破坏者选择一个元素，比如 $a_1 \\in A$。如果破坏者选择 $A$ 中有唯一子节点的节点 $u$，复制者则回应以 $B$ 中的一个非叶节点 $u'$。由于两棵树的高度都至少为 $2$，这样的节点是存在的。复制者可以维持局部同构 $\\{(u, u')\\}$。例如，如果 $u$ 是 $\\mathcal{A}$ 中的根节点，复制者就选择 $\\mathcal{B}$ 中的根节点。\n- **第 2 轮**：破坏者选择另一个元素，比如 $a_2 \\in A$。\n    - 如果破坏者选择 $u$ 的唯一子节点 $v \\in A$，那么已放置棋子的集合是 $\\{u,v\\}$。关系 $C(u,v)$ 成立。复制者必须选择 $v' \\in B$ 使得 $C(u',v')$ 成立。由于 $u'$ 是非叶节点，它至少有两个子节点，所以复制者可以选择其中一个，称之为 $v'$。映射 $\\{(u,u'), (v,v')\\}$ 是一个局部同构。没有原子关系被破坏。例如，$S(u,v)$ 为假，$S(u',v')$ 也为假，因为它们不是兄弟节点。\n    - 如果破坏者选择任何其他元素 $a_2 \\in A$，复制者的策略是选择一个相应的元素 $b_2 \\in B$，使其满足相同的局部属性（例如，是根节点、叶节点、已经是棋子的元素的子节点/父节点/兄弟节点）。鉴于问题中关于相似性的假设，复制者总能找到这样的匹配。\n\n在 $2$ 轮之后，复制者总能保持局部同构。因此，复制者赢得 $G_2(\\mathcal{A}, \\mathcal{B})$。\n\n**$3$ 轮博弈 $G_3(\\mathcal{A}, \\mathcal{B})$ 分析**\n破坏者有一个获胜策略，这反映了区分语句 $\\Phi$。\n\n- **第 1 轮**：破坏者选择 $A$ 中有唯一子节点的节点 $u$。复制者必须用 $B$ 中的一个节点 $u'$ 来回应。为了避免立即失败，复制者必须选择一个非叶节点 $u'$（否则在下一步中子节点关系的属性就会不匹配）。我们得到局部同构 $\\{(u, u')\\}$。\n- **第 2 轮**：破坏者选择节点 $u$ 的唯一子节点 $v \\in A$。复制者必须用 $u'$ 的一个子节点来回应，比如说 $v' \\in B$。由于 $u'$ 是 $\\mathcal{B}$ 中的一个非叶节点，它至少有两个子节点。复制者选择其中一个。映射 $\\{(u, u'), (v, v')\\}$ 是一个局部同构。\n- **第 3 轮**：在 $\\mathcal{B}$ 中，节点 $u'$ 除了 $v'$ 之外至少还有另一个子节点。让破坏者选择这样一个子节点 $w' \\in B$。因此，$C(u', w')$ 成立，$w' \\neq v'$，并且它们是不同的兄弟节点，所以 $S(v', w')$ 成立。现在，复制者必须在 $A$ 中选择一个元素 $w$，使得映射 $\\{(u, u'), (v, v'), (w, w')\\}$ 是一个局部同构。这要求在 $\\mathcal{B}$ 中对 $(u', v', w')$ 成立的关系也必须在 $\\mathcal{A}$ 中对 $(u, v, w)$ 成立。具体来说，复制者必须找到一个 $w \\in A$ 使得：\n    1.  $C(u, w)$ 成立（因为 $C(u', w')$ 成立）。\n    2.  $w \\neq v$（因为 $w' \\neq v'$）。\n然而，根据构造，$A$ 中的 $u$ 只有一个子节点 $v$。在 $\\mathcal{A}$ 中不存在同时满足这两个条件的 $w$。复制者无法做出合法移动，破坏者获胜。\n\n这证实了破坏者赢得 $G_3(\\mathcal{A}, \\mathcal{B})$。由于复制者赢得 $G_2(\\mathcal{A}, \\mathcal{B})$，破坏者获胜所需的最小轮数是 $3$。\n\n### 逐项分析\n\n**A. 在 $\\mathcal{A}$ 和 $\\mathcal{B}$ 上的 $2$ 轮 EF 博弈中，破坏者有一个获胜策略，即在 $\\mathcal{A}$ 中放置棋子于一个父节点及其唯一的子节点上，因为在 $\\mathcal{B}$ 中，已放置棋子的元素之间的兄弟关系已经被破坏。**\n我们的分析表明，在 $2$ 轮博弈中，复制者而不是破坏者拥有获胜策略。该选项中的推理也是有缺陷的。在破坏者（在两轮中）将棋子放置在 $\\mathcal{A}$ 的 $u$ 和子节点 $v$ 上，而复制者回应以 $\\mathcal{B}$ 中的 $u'$ 和子节点 $v'$ 后，已放置棋子的配对是 $(u,v)$ 和 $(u',v')$。它们都不是兄弟节点，所以关系 $S$ 对两对都为假：$\\neg S(u,v)$ 和 $\\neg S(u',v')$。没有发生兄弟关系的破坏。\n**结论：不正确。**\n\n**B. 破坏者需要 $3$ 轮来造成不匹配：在 $\\mathcal{A}$ 中放置棋子于父节点 $u$ 及其唯一子节点 $v$ 之后，破坏者在第 $3$ 轮中，在 $\\mathcal{B}$ 中匹配的父节点 $u'$ 的第二个子节点 $w$ 上放置棋子；复制者无法在 $\\mathcal{A}$ 中找到 $v$ 的兄弟节点（不存在）来回应，同时保持局部同构，因此破坏者在 $3$ 轮内获胜。**\n该选项准确地描述了上面推导出的破坏者在 $3$ 轮博弈中的获胜策略。它正确地指出所需的轮数是 $3$。这一系列移动导致了一种情况，即复制者必须为 $\\mathcal{A}$ 中的节点 $u$ 找到第二个子节点，这是不可能的。找到这样一个子节点等同于为 $v$ 找到一个兄弟节点，而它并不存在。其推理是合理的。\n**结论：正确。**\n\n**C. “存在一个恰好有一个子节点的节点”这个一阶性质可以在 $\\mathcal{L}$ 中表达，并且区分 $\\mathcal{A}$ 和 $\\mathcal{B}$ 的语句的最小量词秩是 $3$。**\n如上所示，该性质可以由语句 $\\Phi \\equiv \\exists u \\, \\exists v \\, (C(u,v) \\land \\forall w \\, (C(u,w) \\rightarrow w=v))$ 表达。这个语句的量词秩为 $3$。由于复制者赢得 $2$ 轮博弈，没有量词秩为 $2$ 或更低的语句可以区分这两个结构。因此，区分语句的最小量词秩确实是 $3$。\n**结论：正确。**\n\n**D. 即使在 $3$ 轮博弈中，复制者也总能通过选择叶节点来回应以保持局部同构，因此在这个标记下，EF 博弈无法检测到存在一个恰好有一个子节点的节点。**\n这在事实上是不正确的。我们已经明确地构建了破坏者在 $3$ 轮博弈中的获胜策略。声称复制者总能回应（例如“通过选择叶节点”）是错误的；在破坏者获胜策略的最后一步中，复制者根本没有有效的回应，无论任何节点是否是叶节点。该性质是可检测的。\n**结论：不正确。**\n\n**E. 兄弟关系 $S(x,y)$ 对于区分这两个结构并非必不可少：在仅包含 $R(x)$ 和 $C(x,y)$ 的标记中，破坏者仍然可以在 $3$ 轮内获胜，通过在 $\\mathcal{A}$ 中放置棋子于一个父节点及其唯一子节点上，然后在 $\\mathcal{B}$ 中匹配的父节点的第二个子节点上放置棋子，从而在 $\\mathcal{A}$ 中强制造成子节点关系配置的破坏。**\n问题陈述 $S(x,y)$ 被解释为 $\\exists p (C(p,x) \\land C(p,y) \\land x \\neq y)$。这意味着 $S$ 可以用 $C$ 显式定义。向语言中添加可定义的关系不会增加其表达能力。因此，如果结构是可区分的，它们必须在没有被定义关系的原语言中也是可区分的。上面概述的破坏者的获胜策略依赖于在 $\\mathcal{B}$ 中找到 $u'$ 的第二个子节点 $w'$。复制者失败是因为它无法在 $\\mathcal{A}$ 中找到 $u$ 相应的第二个子节点 $w$。这个失败源于子节点关系 $C$ 本身的属性（$w$ 必须满足 $C(u,w)$ 和 $w \\neq v$）。兄弟关系 $S$ 对于证明矛盾并非必需。该选项正确地陈述了这一事实。\n**结论：正确。**\n\n最终总结：选项 B、C 和 E 是正确的陈述。", "answer": "$$\\boxed{BCE}$$", "id": "2972065"}, {"introduction": "为了将抽象的博弈论概念转化为可执行的计算过程，最后的练习是设计并实现一个算法来判定Ehrenfeucht-Fraïssé游戏的胜负。这个实践不仅能巩固你对游戏规则和局部同构检查的理解，还将引导你从算法设计的角度思考逻辑性质。通过编写代码来系统地探索游戏树，你将把理论知识转化为解决具体问题的强大工具。[@problem_id:2972085]", "problem": "给定两个基于一个固定的有限关系标识 $\\sigma$ 的有限关系结构 $\\mathcal{A}$ 和 $\\mathcal{B}$，以及一个非负整数 $k$。考虑长度为 $k$ 的 Ehrenfeucht–Fraïssé 博弈 $\\operatorname{EF}_k(\\mathcal{A},\\mathcal{B})$，该博弈在“破坏者”（Spoiler）和“复制者”（Duplicator）两名玩家之间进行。在每一轮中，破坏者从 $\\mathcal{A}$ 的域 $A$ 或 $\\mathcal{B}$ 的域 $B$ 中选取一个元素，复制者则从另一个结构中选取一个元素作为回应。经过 $k$ 轮后，玩家们从 $A$ 和 $B$ 中选出了两个 $k$-元组（可能包含重复元素）。如果由配对选择所决定的偏映射是一个偏同构（定义如下），则复制者获胜；否则破坏者获胜。目标是判断复制者在 $\\operatorname{EF}_k(\\mathcal{A},\\mathcal{B})$ 博弈中是否有必胜策略。\n\n使用以下基本事实和定义。\n\n- 一个有限关系标识 $\\sigma$ 是一个关系符号 $R$ 的有限集合，每个符号都有一个固定的元数 $r \\in \\mathbb{N}$，其在 $\\mathcal{A}$ 和 $\\mathcal{B}$ 上的解释分别写作 $R^{\\mathcal{A}} \\subseteq A^r$ 和 $R^{\\mathcal{B}} \\subseteq B^r$。\n- 一个偏映射 $f \\colon S \\to T$（其中 $S \\subseteq A$ 且 $T \\subseteq B$）是一个偏同构，如果 $f$ 是单射的，并且对于标识 $\\sigma$ 中的任意元数为 $r$ 的关系符号 $R$，对于任意元组 $(a_1,\\dots,a_r) \\in S^r$，等价关系\n$$R^{\\mathcal{A}}(a_1,\\dots,a_r) \\iff R^{\\mathcal{B}}(f(a_1),\\dots,f(a_r))$$\n均成立。相等关系由 $f$ 的单射性和函数性质自动保持。\n- 一个经过充分验证的事实是：复制者在 $\\operatorname{EF}_k(\\mathcal{A},\\mathcal{B})$ 中有必胜策略，当且仅当 $\\mathcal{A}$ 和 $\\mathcal{B}$ 满足所有量词秩至多为 $k$ 的相同一阶句子。\n\n设计并实现一个算法，通过系统地探索破坏者可能的移动和复制者的响应来决定胜者，同时在每次扩展时通过偏同构的一致性检查来剪除失败的分支。你的算法必须：\n\n- 表示具有域 $A$、$B$ 以及关系解释 $R^{\\mathcal{A}}$ 和 $R^{\\mathcal{B}}$ 的有限结构。\n- 维护一个由配对选择序列产生的当前单射偏映射 $f \\colon S \\to T$，其中 $S \\subseteq A$ 且 $T \\subseteq B$。\n- 在剩余 $k$ 轮的每一步中，对破坏者选择的一方（$A$ 或 $B$）及从中选择的元素进行全称量化；对于每一个这样的移动，对复制者从另一方选择的、在扩展 $f$ 时能保持单射性并满足偏同构一致性检查的允许响应进行存在量化。\n- 对 $k$ 使用带记忆化的逆向归纳法以避免重复计算，并在一致性检查失败时立即剪枝。基本情况是 $k=0$，此时复制者默认获胜。\n\n你的程序必须实现上述算法并评估以下测试套件。在所有测试中，标识 $\\sigma$ 包含一个二元关系 $E$（解释为无自环的无向边关系，编码为对称有序对）和一个一元关系 $U$（一个特殊的颜色类）。输出必须是布尔值，指示在给定输入下，复制者在 $\\operatorname{EF}_k(\\mathcal{A},\\mathcal{B})$ 中是否有必胜策略。\n\n测试套件说明：\n\n- 测试 1：$\\mathcal{A}_1$ 和 $\\mathcal{B}_1$ 都是域为 $\\{0,1,2\\}$ 上的 3-环，边为 $\\{(0,1),(1,2),(2,0)\\}$（作对称处理），两者中的 $U$ 均为空。设 $k=3$。预期行为：复制者应获胜。\n- 测试 2：$\\mathcal{A}_2$ 的域为 $\\{0,1,2\\}$，没有边，一元关系为 $U^{\\mathcal{A}_2}=\\{0\\}$；$\\mathcal{B}_2$ 的域为 $\\{0,1,2\\}$，没有边，一元关系为 $U^{\\mathcal{B}_2}=\\{0,1\\}$。设 $k=1$。预期行为：复制者应获胜。\n- 测试 3：结构与测试 2 相同，但设 $k=2$。预期行为：破坏者应获胜。\n- 测试 4：$\\mathcal{A}_3$ 的域为 $\\{0,1,2\\}$，有一条边 $E^{\\mathcal{A}_3}=\\{(0,1)\\}$（作对称处理），$U$ 为空；$\\mathcal{B}_3$ 的域为 $\\{0,1,2\\}$，没有边，$U$ 为空。设 $k=2$。预期行为：破坏者应获胜。\n- 测试 5：$\\mathcal{A}_4$ 的域大小为 1，没有边，$U$ 为空；$\\mathcal{B}_4$ 的域大小为 2，没有边，$U$ 为空。设 $k=2$。预期行为：破坏者应获胜。\n- 测试 6：$\\mathcal{A}_5$ 的域为 $\\{0,1,2\\}$，有 $E^{\\mathcal{A}_5}=\\{(0,1)\\}$（作对称处理），$U$ 为空；$\\mathcal{B}_5$ 的域为 $\\{0,1,2\\}$，有 $E^{\\mathcal{B}_5}=\\{(0,1),(1,2)\\}$（作对称处理），$U$ 为空。设 $k=1$。预期行为：复制者应获胜。\n- 测试 7：$\\mathcal{A}_6$ 的域为 $\\{0,1,2\\}$，有 $E^{\\mathcal{A}_6}=\\{(0,1)\\}$（作对称处理），$U$ 为空；$\\mathcal{B}_6$ 的域为 $\\{0,1,2,3\\}$，有 $E^{\\mathcal{B}_6}=\\{(0,1),(2,3)\\}$（作对称处理），$U$ 为空。设 $k=0$。预期行为：复制者应获胜。\n\n最终输出格式要求：\n\n- 你的程序应生成单行输出，其中包含测试 1 到 7 的结果，形式为一个由方括号括起来的、逗号分隔的布尔值列表，例如，$\\mathtt{[True,False,True,False,True,True,False]}$。不应打印任何其他文本。", "solution": "该问题要求我们判断在两个有限关系结构 $\\mathcal{A}$ 和 $\\mathcal{B}$ 上进行的、共 $k$ 轮的 Ehrenfeucht-Fraïssé 博弈（记作 $\\operatorname{EF}_k(\\mathcal{A},\\mathcal{B})$）中，复制者（Duplicator）是否有必胜策略。\n\n首先，我们必须验证问题陈述的有效性。\n\n### 第1步：提取给定信息\n- **博弈**：长度为 $k$ 的 Ehrenfeucht-Fraïssé 博弈 $\\operatorname{EF}_k(\\mathcal{A},\\mathcal{B})$。\n- **玩家**：破坏者（Spoiler）和复制者（Duplicator）。\n- **结构**：两个基于一个固定的有限关系标识 $\\sigma$ 的有限关系结构 $\\mathcal{A}$ 和 $\\mathcal{B}$。一个结构 $\\mathcal{A}$ 有一个域 $A$ 和对每个元数为 $r$ 的关系符号 $R \\in \\sigma$ 的解释 $R^{\\mathcal{A}} \\subseteq A^r$。\n- **博弈过程**：在 $k$ 轮中的每一轮，破坏者从域 $A$ 或 $B$ 中选择一个元素，复制者则从另一个域中选择一个元素。\n- **获胜条件**：$k$ 轮后，选出了一系列配对 $(a_1, b_1), \\dots, (a_k, b_k)$。令 $S = \\{a_1, \\dots, a_k\\}$ 和 $T = \\{b_1, \\dots, b_k\\}$。如果由 $f(a_i) = b_i$ 定义的映射 $f \\colon S \\to T$ 是一个偏同构，则复制者获胜。\n- **偏同构**：一个偏映射 $f \\colon S \\to T$（$S \\subseteq A, T \\subseteq B$）是一个偏同构，如果它是单射的，并且对于每个元数为 $r$ 的关系 $R \\in \\sigma$ 和每个元组 $(x_1, \\dots, x_r) \\in S^r$，条件 $R^{\\mathcal{A}}(x_1, \\dots, x_r) \\iff R^{\\mathcal{B}}(f(x_1), \\dots, f(x_r))$ 均成立。\n- **算法纲要**：问题建议使用一个带记忆化的递归算法，该算法基于对轮数 $k$ 的逆向归纳。\n- **测试套件标识**：$\\sigma = \\{E, U\\}$，其中 $E$ 是一个二元关系（无向边），$U$ 是一个一元关系（颜色）。\n- **测试用例**：\n    1. $\\mathcal{A}_1, \\mathcal{B}_1$：在 $\\{0,1,2\\}$ 上的 $3$-环；$k=3$。预期：复制者获胜。\n    2. $\\mathcal{A}_2$：$D=\\{0,1,2\\}, U=\\{0\\}$；$\\mathcal{B}_2$：$D=\\{0,1,2\\}, U=\\{0,1\\}$；$k=1$。预期：复制者获胜。\n    3. 与 2 相同，但 $k=2$。预期：破坏者获胜。\n    4. $\\mathcal{A}_3$：$D=\\{0,1,2\\}, E=\\{(0,1)\\}$；$\\mathcal{B}_3$：$D=\\{0,1,2\\}, E=\\emptyset$；$k=2$。预期：破坏者获胜。\n    5. $\\mathcal{A}_4$：域大小为 1；$\\mathcal{B}_4$：域大小为 2；$k=2$。预期：破坏者获胜。\n    6. $\\mathcal{A}_5$：$D=\\{0,1,2\\}, E=\\{(0,1)\\}$；$\\mathcal{B}_5$：$D=\\{0,1,2\\}, E=\\{(0,1),(1,2)\\}$；$k=1$。预期：复制者获胜。\n    7. $\\mathcal{A}_6$：$D=\\{0,1,2\\}, E=\\{(0,1)\\}$；$\\mathcal{B}_6$：$D=\\{0,1,2,3\\}, E=\\{(0,1),(2,3)\\}$；$k=0$。预期：复制者获胜。\n\n### 第2步：使用提取的信息进行验证\n该问题在数学和科学上是合理的。它是数理逻辑的一个分支——模型论中的一个标准问题。关系结构、偏同构和 Ehrenfeucht-Fraïssé 博弈的定义都是正确且标准的。该问题是适定 (well-posed) 的，因为对于任何有限结构和有限的 $k$，胜者都是确定的。问题是客观的，所有术语都有正式定义。提供的测试用例具体而完整。指定的算法纲要（带记忆化的递归搜索）是解决此问题的标准方法。未发现任何缺陷。\n\n### 第3步：结论与行动\n问题有效。我们开始进行求解。\n\n### 算法解决方案\n问题的核心是确定复制者是否有必胜策略。我们可以递归地形式化复制者的获胜条件。设 $W(k, p)$ 是一个谓词，当且仅当复制者从一个由 $k$ 轮剩余和一个已存在的偏同构 $p$ 定义的博弈状态出发有必胜策略时，该谓词为真。初始调用将是确定 $W(k, \\emptyset)$，其中 $\\emptyset$ 表示空偏映射。\n\n$W(k, p)$ 的递归定义如下：\n- **基本情况**：如果 $k=0$，复制者已经获胜，因为当前的偏映射 $p$ 必须是一个偏同构（这是我们维护的一个不变量）。所以，$W(0, p) = \\text{True}$。\n- **递归步骤**：对于 $k > 0$，如果复制者能响应破坏者的任何移动，则复制者获胜。破坏者有两种移动：从域 $A$ 中选取一个元素或从域 $B$ 中选取一个元素。\n    1. 对于破坏者可能从 $A \\setminus \\operatorname{dom}(p)$ 中选取的每一个元素 $a'$，必须存在一个复制者可以从 $B \\setminus \\operatorname{rng}(p)$ 中选取来回应的元素 $b'$，使得扩展后的映射 $p' = p \\cup \\{(a', b')\\}$ 是一个偏同构，并且复制者在接下来的博弈中有必胜策略，即 $W(k-1, p')$。\n    2. 对称地，对于破坏者可能从 $B \\setminus \\operatorname{rng}(p)$ 中选取的每一个元素 $b'$，必须存在一个复制者可以从 $A \\setminus \\operatorname{dom}(p)$ 中选取来回应的元素 $a'$，使得 $p' = p \\cup \\{(a', b')\\}$ 是一个偏同构，并且 $W(k-1, p')$。\n\n这可以用量词表示为：\n$W(k, p) \\iff$\n$$ \\left( \\forall a' \\in A \\setminus \\operatorname{dom}(p) \\,\\, \\exists b' \\in B \\setminus \\operatorname{rng}(p) \\text{ such that } \\operatorname{IsPartialIso}(p \\cup \\{(a', b')\\}) \\land W(k-1, p \\cup \\{(a', b')\\}) \\right) $$\n$$ \\land $$\n$$ \\left( \\forall b' \\in B \\setminus \\operatorname{rng}(p) \\,\\, \\exists a' \\in A \\setminus \\operatorname{dom}(p) \\text{ such that } \\operatorname{IsPartialIso}(p \\cup \\{(a', b')\\}) \\land W(k-1, p \\cup \\{(a', b')\\}) \\right) $$\n\n为了实现这一点，我们可以编写一个递归函数，例如 `duplicator_wins(k, p)`。为避免对同一子博弈重复计算结果，我们使用记忆化。一个状态由剩余轮数 $k$ 和当前偏映射 $p$ 唯一确定。我们可以使用一个字典（哈希映射）来存储 `duplicator_wins(k, p)` 的结果，其中键是一个二元组 `(k, p_tuple)`，`p_tuple` 是映射 $p$ 的一个规范、可哈希的表示（例如，其键值对的排序元组）。\n\n`IsPartialIso(p \\cup \\{(a', b')\\})` 的检查可以增量进行。鉴于 $p$ 已经是一个偏同构，我们只需验证涉及新配对 $(a', b')$ 的关系相对于 $p$ 中所有已存在的配对 $(a, p(a))$ 是否保持。对于带有一元关系 $U$ 和二元关系 $E$ 的标识：\n1. 一元检查：$a' \\in U^{\\mathcal{A}} \\iff b' \\in U^{\\mathcal{B}}$。\n2. 二元检查：对于所有 $a \\in \\operatorname{dom}(p)$，必须满足 $(a', a) \\in E^{\\mathcal{A}} \\iff (b', p(a)) \\in E^{\\mathcal{B}}$。\n\n该实现将为每个测试用例定义结构 $\\mathcal{A}$ 和 $\\mathcal{B}$。对于一个给定的测试用例 $(k, \\mathcal{A}, \\mathcal{B})$，我们将以 `duplicator_wins(k, {})` 初始化递归。对于每个独立的测试用例，记忆化缓存将被清除。结构本身将使用简单的容器表示。对于无向二元关系 $E$，我们使用一个包含大小为 2 的 `frozenset` 的集合来自然地处理对称性。对于一元关系 $U$，我们使用一个集合。域 $A$ 和 $B$ 也表示为集合。", "answer": "```python\nimport numpy as np\nfrom collections import namedtuple\nfrom typing import Set, Dict, Tuple, Any, FrozenSet, List\n\n# Define a simple structure to hold the relational structure's data.\nStructure = namedtuple('Structure', ['domain', 'E', 'U'])\n\ndef solve():\n    \"\"\"\n    Solves the Ehrenfeucht-Fraïssé game for a suite of test cases.\n    \"\"\"\n\n    test_cases = [\n        # Test 1: Two 3-cycles, k=3. Duplicator should win.\n        (\n            3,\n            Structure(domain={0, 1, 2}, E={frozenset({0, 1}), frozenset({1, 2}), frozenset({2, 0})}, U=set()),\n            Structure(domain={0, 1, 2}, E={frozenset({0, 1}), frozenset({1, 2}), frozenset({2, 0})}, U=set())\n        ),\n        # Test 2: Different numbers of U-elements, k=1. Duplicator should win.\n        (\n            1,\n            Structure(domain={0, 1, 2}, E=set(), U={0}),\n            Structure(domain={0, 1, 2}, E=set(), U={0, 1})\n        ),\n        # Test 3: Same as Test 2, but k=2. Spoiler should win.\n        (\n            2,\n            Structure(domain={0, 1, 2}, E=set(), U={0}),\n            Structure(domain={0, 1, 2}, E=set(), U={0, 1})\n        ),\n        # Test 4: Edge vs no edge, k=2. Spoiler should win.\n        (\n            2,\n            Structure(domain={0, 1, 2}, E={frozenset({0, 1})}, U=set()),\n            Structure(domain={0, 1, 2}, E=set(), U=set())\n        ),\n        # Test 5: Different domain sizes, k=2. Spoiler should win.\n        (\n            2,\n            Structure(domain={0}, E=set(), U=set()),\n            Structure(domain={0, 1}, E=set(), U=set())\n        ),\n         # Test 6: Path of length 1 vs path of length 2, k=1. Duplicator should win.\n        (\n            1,\n            Structure(domain={0, 1, 2}, E={frozenset({0, 1})}, U=set()),\n            Structure(domain={0, 1, 2}, E={frozenset({0, 1}), frozenset({1, 2})}, U=set())\n         ),\n        # Test 7: Trivial k=0 case. Duplicator should win.\n        (\n            0,\n            Structure(domain={0, 1, 2}, E={frozenset({0, 1})}, U=set()),\n            Structure(domain={0, 1, 2, 3}, E={frozenset({0, 1}), frozenset({2, 3})}, U=set())\n        )\n    ]\n    \n    results = []\n    for k, struct_A, struct_B in test_cases:\n        results.append(solve_one_case(k, struct_A, struct_B))\n    \n    # Capitalize boolean values for output\n    py_to_json_bool = {True: \"True\", False: \"False\"}\n    print(f\"[{','.join(py_to_json_bool[res] for res in results)}]\")\n\n\ndef solve_one_case(k_initial: int, struct_A: Structure, struct_B: Structure) -> bool:\n    \"\"\"\n    Determines if Duplicator has a winning strategy for a single EF-game instance.\n    A new memoization cache is created for each call to encapsulate the state.\n    \"\"\"\n    memo: Dict[Tuple[int, Tuple[Tuple[int, int], ...]], bool] = {}\n\n    def check_consistency(p_map: Dict[int, int], a_new: int, b_new: int) -> bool:\n        \"\"\"\n        Incrementally checks if adding (a_new, b_new) to an existing partial\n        isomorphism p_map preserves the isomorphism property.\n        \"\"\"\n        # Check unary relation U\n        if (a_new in struct_A.U) != (b_new in struct_B.U):\n            return False\n        \n        # Check binary relation E against all existing pairs in the map\n        for a_old, b_old in p_map.items():\n            edge_in_A = frozenset({a_new, a_old}) in struct_A.E\n            edge_in_B = frozenset({b_new, b_old}) in struct_B.E\n            if edge_in_A != edge_in_B:\n                return False\n                \n        return True\n\n    def duplicator_has_winning_strategy(k: int, p_map_tuple: Tuple[Tuple[int, int], ...]) -> bool:\n        \"\"\"\n        Recursive function with memoization to determine the game's winner.\n        \"\"\"\n        state = (k, p_map_tuple)\n        if state in memo:\n            return memo[state]\n\n        if k == 0:\n            return True\n\n        p_map = dict(p_map_tuple)\n        chosen_A = set(p_map.keys())\n        chosen_B = set(p_map.values())\n        \n        available_A = struct_A.domain - chosen_A\n        available_B = struct_B.domain - chosen_B\n\n        # Part 1: Spoiler picks from structure A\n        for a_new in available_A:\n            # Duplicator must find a response in B\n            duplicator_can_respond = False\n            for b_new in available_B:\n                if check_consistency(p_map, a_new, b_new):\n                    new_p_map_items = list(p_map.items()) + [(a_new, b_new)]\n                    new_p_map_tuple = tuple(sorted(new_p_map_items))\n                    if duplicator_has_winning_strategy(k - 1, new_p_map_tuple):\n                        duplicator_can_respond = True\n                        break  # Found a valid response, move to next Spoiler move\n            \n            if not duplicator_can_respond:\n                memo[state] = False\n                return False  # Spoiler found a winning move\n\n        # Part 2: Spoiler picks from structure B\n        for b_new in available_B:\n            # Duplicator must find a response in A\n            duplicator_can_respond = False\n            for a_new in available_A:\n                if check_consistency(p_map, a_new, b_new):\n                    new_p_map_items = list(p_map.items()) + [(a_new, b_new)]\n                    new_p_map_tuple = tuple(sorted(new_p_map_items))\n                    if duplicator_has_winning_strategy(k - 1, new_p_map_tuple):\n                        duplicator_can_respond = True\n                        break  # Found a valid response\n            \n            if not duplicator_can_respond:\n                memo[state] = False\n                return False  # Spoiler found a winning move\n\n        # Duplicator can counter all of Spoiler's possible moves for this round\n        memo[state] = True\n        return True\n\n    return duplicator_has_winning_strategy(k_initial, tuple())\n\nsolve()\n\n```", "id": "2972085"}]}