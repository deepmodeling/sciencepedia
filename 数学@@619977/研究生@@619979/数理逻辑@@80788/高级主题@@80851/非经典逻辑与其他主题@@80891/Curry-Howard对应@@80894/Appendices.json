{"hands_on_practices": [{"introduction": "柯里-霍华德同构的核心思想是，计算过程对应于证明的化简。这个练习提供了一个基础而典型的例子，展示了简单类型 lambda 演算中的 $\\beta$-归约如何直接对应于自然演绎中一个多余的“证明弯路”的消除。通过完成这个练习，你将亲手体验一个计算步骤是如何精确地简化一个逻辑证明的，从而对“程序即证明”的口号建立起直观的理解。", "problem": "考虑简单类型lambda演算（STLC），其中类型由基本类型和函数类型构造子 $\\,\\to\\,$ 构建，项由变量、抽象 $\\lambda x.\\,t$ 和应用 $t\\,s$ 构建。Curry-Howard对应（CHC）将类型等同于命题，将项等同于证明；特别地，一个类型为 $A \\to B$ 的项是从命题 $A$ 可以推导出命题 $B$ 的一个证明。蕴含的引入规则对应于在撤销一个假设 $x:A$ 的情况下形成一个抽象 $\\lambda x.\\,t$，而消去规则对应于当 $t:A\\to B$ 且 $s:A$ 时的应用 $t\\,s$。其计算内容由 $\\beta$-归约所支配，其中一个抽象对一个参数的应用通过替换进行归约：$(\\lambda x.\\,t)\\,s \\to_{\\beta} t[x:=s]$。如果一个项上没有任何 $\\beta$-归约可以应用，则称该项处于范式。\n\n设 $A$ 和 $B$ 为固定类型。假设变量 $u:A$ 和 $v:B$，并考虑项 $t \\equiv (\\lambda x.\\,\\lambda y.\\,x)\\,u\\,v$。仅使用上述关于类型、抽象、应用和 $\\beta$-归约的基本规则，计算 $t$ 的 $\\beta$-范式。然后，根据Curry-Howard对应，从蕴含的引入和消去的基本原理出发，解释此消去步骤对应于命题 $A \\to B \\to A$ 的自然演绎证明中的哪种迂回。\n\n你的最终答案必须是表示 $t$ 的范式的单个闭式符号表达式。不需要四舍五入，也无单位适用。", "solution": "首先将根据指定标准对问题陈述进行验证。\n\n### 步骤1：提取已知条件\n- **系统**：简单类型lambda演算 (STLC)。\n- **类型构成**：类型由基本类型和函数类型构造子 $\\to$ 构建。\n- **项构成**：项由变量、抽象 ($\\lambda x.\\,t$) 和应用 ($t\\,s$) 构建。\n- **Curry-Howard对应 (CHC)**：\n    - 类型等同于命题。\n    - 项等同于证明。\n    - 类型为 $A \\to B$ 的项是命题 $A$ 蕴含命题 $B$ 的一个证明。\n    - 蕴含引入 ($\\to I$) 对应于抽象 ($\\lambda x.\\,t$)。\n    - 蕴含消去 ($\\to E$) 对应于应用 ($t\\,s$)。\n- **计算规则**：$\\beta$-归约定义为 $(\\lambda x.\\,t)\\,s \\to_{\\beta} t[x:=s]$，其中 $t[x:=s]$ 是将 $t$ 中 $x$ 的所有自由出现替换为 $s$。\n- **范式**：如果一个项上没有 $\\beta$-归约可以应用，则该项处于范式。\n- **给定类型**：$A$ 和 $B$ 是固定类型。\n- **给定变量**：$u$ 是类型为 $A$ 的变量 (即 $u:A$)，$v$ 是类型为 $B$ 的变量 (即 $v:B$)。\n- **待分析项**：$t \\equiv (\\lambda x.\\,\\lambda y.\\,x)\\,u\\,v$。\n\n### 步骤2：使用提取的已知条件进行验证\n对问题进行验证：\n- **科学性**：该问题完全位于数理逻辑和理论计算机科学的范畴内，具体涉及简单类型lambda演算和Curry-Howard对应。这些都是完善的基础性课题。$\\beta$-归约、范式和自然演绎等概念都有严格的定义。该问题没有违反任何科学或数学原理。\n- **适定性**：该问题要求进行一项特定的计算（求给定项的 $\\beta$-范式）和一个基于所提供框架的特定概念性解释。计算规则（$\\beta$-归约）是明确且确定性的，确保了唯一范式的存在（由于STLC的强范式化性质）。结构清晰，可以推导出唯一且有意义的解。\n- **客观性**：语言是形式化且精确的。“$\\beta$-范式”、“证明迂回”和“自然演绎”在此语境下具有明确的含义。没有主观或基于观点的陈述。\n- **完整性**：该问题提供了所有必要信息：要归约的项、所涉及变量的类型以及系统的基本规则（类型、归约）。问题是自洽的。\n- **其他缺陷**：该问题不是隐喻性的、琐碎的、矛盾的或不可验证的。它是其领域的标准练习题。\n\n### 步骤3：结论与行动\n该问题是**有效的**。将提供完整解答。\n\n### 解答推导\n该问题要求两部分：首先，计算项 $t \\equiv (\\lambda x.\\,\\lambda y.\\,x)\\,u\\,v$ 的 $\\beta$-范式；其次，根据Curry-Howard对应解释其对应的逻辑现象。\n\n#### 第1部分：$\\beta$-范式的计算\n待归约的项是 $t \\equiv (\\lambda x.\\,\\lambda y.\\,x)\\,u\\,v$。在lambda演算中，应用是左结合的，因此该项被解析为 $((\\lambda x.\\,\\lambda y.\\,x)\\,u)\\,v$。\n\n归约过程分两步，应用规则 $(\\lambda z.\\,M)\\,N \\to_{\\beta} M[z:=N]$。\n\n**步骤1：** 第一次归约应用于子项 $(\\lambda x.\\,\\lambda y.\\,x)\\,u$。\n在这里，抽象是 $\\lambda x.\\,(\\lambda y.\\,x)$，参数是 $u$。根据 $\\beta$-归约规则，我们将项 $u$ 替换到抽象体（即 $\\lambda y.\\,x$）中变量 $x$ 的每个自由出现。\n$$ (\\lambda x.\\,\\lambda y.\\,x)\\,u \\to_{\\beta} (\\lambda y.\\,x)[x:=u] $$\n替换后产生项 $\\lambda y.\\,u$。在这个新项中，$u$ 是一个类型为 $A$ 的项，而抽象是针对一个在 $u$ 中不自由出现的变量 $y$。\n\n第一次归约后，原项 $t$ 变为：\n$$ t \\to_{\\beta} (\\lambda y.\\,u)\\,v $$\n\n**步骤2：** 第二次归约应用于结果项 $(\\lambda y.\\,u)\\,v$。\n在这里，抽象是 $\\lambda y.\\,u$，参数是 $v$。我们将项 $v$ 替换到抽象体（即 $u$）中变量 $y$ 的每个自由出现。\n$$ (\\lambda y.\\,u)\\,v \\to_{\\beta} u[y:=v] $$\n根据问题陈述，$u$ 是一个类型为 $A$ 的变量。变量 $y$ 在项 $u$ 中不自由出现。因此，替换 $u[y:=v]$ 的结果是项 $u$ 本身。\n$$ u[y:=v] \\equiv u $$\n\n结合这两个步骤，完整的归约序列是：\n$$ t \\equiv ((\\lambda x.\\,\\lambda y.\\,x)\\,u)\\,v \\to_{\\beta} (\\lambda y.\\,u)\\,v \\to_{\\beta} u $$\n项 $u$ 中不包含可归约式（即形如 $(\\lambda z.\\,M)\\,N$ 的子项），因此它处于 $\\beta$-范式。\n\n#### 第2部分：通过Curry-Howard对应进行解释\nCurry-Howard对应在直觉主义逻辑中的命题与类型lambda演算中的类型之间建立了一种同构关系。证明对应于项。\n\n**确定项的类型**：让我们确定项 $t$ 的类型。\n1. 子项 $\\lambda x.\\,\\lambda y.\\,x$ 是命题 $A \\to (B \\to A)$ 的一个证明。要理解这一点，我们可以在自然演绎中构建它的证明：\n    - 假设 $x:A$（$A$ 的一个证明）。这是假设 $[A]^1$。\n    - 假设 $y:B$（$B$ 的一个证明）。这是假设 $[B]^2$。\n    - 在这些假设下，我们有 $x$，它是 $A$ 的一个证明。所以我们已经推导出了 $A$。\n    - 通过蕴含引入 ($\\to I$)，我们撤销假设 $[B]^2$ 来断定 $B \\to A$。证明项是 $\\lambda y.\\,x$。\n    - 再次通过蕴含引入 ($\\to I$)，我们撤销假设 $[A]^1$ 来断定 $A \\to (B \\to A)$。证明项是 $\\lambda x.\\,\\lambda y.\\,x$。\n\n2. 该项是 $(\\lambda x.\\,\\lambda y.\\,x)\\,u\\,v$。我们有以下证明（项）和命题（类型）：\n    - $(\\lambda x.\\,\\lambda y.\\,x) : A \\to (B \\to A)$\n    - $u : A$\n    - $v : B$\n\n3. 应用 $(\\lambda x.\\,\\lambda y.\\,x)\\,u$ 对应于蕴含消去 ($\\to E$，或称肯定前件式)。我们有一个 $A \\to (B \\to A)$ 的证明和一个 $A$ 的证明，因此我们可以断定 $B \\to A$。所得的证明项是 $(\\lambda x.\\,\\lambda y.\\,x)\\,u$。\n\n4. 最后的应用 $((\\lambda x.\\,\\lambda y.\\,x)\\,u)\\,v$ 是另一次 $\\to E$ 的使用。我们有上一步得到的 $B \\to A$ 的证明，以及一个 $B$ 的证明（项 $v$），因此我们断定 $A$。所以，整个项 $t$ 的类型是 $A$。这与我们的计算结果一致，因为范式是 $u$，其类型为 $A$。\n\n**证明迂回**：自然演绎中的“证明迂回”（或“切”）指的是一个连接词被引入后立即被消去的情况。对证明项进行 $\\beta$-归约的过程，恰好对应于在相关证明中消除这些迂回的过程，此过程称为范式化或切消。\n\n1. **第一次迂回及其消除**：应用 $(\\lambda x.\\,\\lambda y.\\,x)\\,u$ 表示对 $A \\to (B \\to A)$ 中最外层蕴含的消去，而这个蕴含刚刚是通过抽象 $\\lambda x$ 引入的。\n    - **引入**：我们假设了一个 $A$ 的假设性证明 $x$ 来构造一个 $B \\to A$ 的证明，然后泛化为 $A \\to (B \\to A)$。\n    - **消去**：我们立即将这个一般性证明应用于一个 $A$ 的具体证明，即 $u$。\n    - **迂回**：这个迂回的路径是：假设 $A \\to$ 构造一个函数 $\\to$ 将该函数应用于 $A$ 的一个证明。\n    - **归约**：$\\beta$-归约 $(\\lambda x.\\,\\lambda y.\\,x)\\,u \\to_{\\beta} \\lambda y.\\,u$ 消除了这个迂回。在证明中，这对应于将占位符假设 $x$ 的每个实例替换为实际的证明 $u$。所得到的证明对象 $\\lambda y.\\,u$ 是一个直接由 $u$ 构建的 $B \\to A$ 的证明。\n\n2. **第二次迂回及其消除**：随后的应用 $(\\lambda y.\\,u)\\,v$ 代表了第二个迂回。\n    - **引入**：项 $\\lambda y.\\,u$ 构造了一个 $B \\to A$ 的证明。这是通过假设一个 $B$ 的证明 $y$ 然后证明 $A$ 来完成的。然而，$A$ 的证明（即 $u$）根本不依赖于假设 $y:B$。这被称为空洞撤销。\n    - **消去**：然后我们立即将这个构造应用于一个 $B$ 的具体证明，即 $v$。\n    - **迂回**：这个迂回是：空洞地假设 $B \\to$ 构造一个 $B \\to A$ 的证明 $\\to$ 将其应用于 $B$ 的一个证明。\n    - **归约**：$\\beta$-归约 $(\\lambda y.\\,u)\\,v \\to_{\\beta} u$ 消除了这个迂回。从逻辑上讲，如果从假设 $B$ 得出结论 $A$ 的证明实际上从未使用过假设 $B$，那么被给予一个 $B$ 的具体证明就是无关紧要的。证明简化为 $A$ 的原始证明，这正是项 $u$ 所代表的。所提供的证明 $v$ 被丢弃了。\n\n总而言之，$\\beta$-归约的序列反映了相应自然演绎证明的简化过程。与 $t$ 相对应的初始证明是一种复杂且间接的证明 $A$ 的方式。它涉及创建一般性规则 ($A \\to (B \\to A)$) 然后应用它们。范式化过程移除了这些中间的引入-消去步骤，表明在给定初始数据（$u:A$, $v:B$）的情况下，证明 $A$ 最直接的方式就是 $u$ 本身。", "answer": "$$ \\boxed{u} $$", "id": "2985657"}, {"introduction": "柯里-霍华德同构的威力远不止于命题逻辑，它优雅地扩展到了谓词逻辑，其中依赖类型（如 $\\Pi$-类型）对应于全称量词。这个练习要求你不再是分析一个给定的程序，而是亲手构造一个复杂的程序（即证明），来证明一个涉及全称量词和合取的逻辑命题。这不仅能深化你对类型构造规则和逻辑推理规则之间精确对应的理解，还能让你体会到构造性证明的精髓——一个证明就是一段可执行的代码。", "problem": "在 Curry–Howard 对应的框架下，依赖函数类型 $\\Pi_{x:A}B(x)$ 对应于全称量化 $\\forall x:A.\\,B(x)$，二元积类型 $B \\times C$ 对应于合取 $B \\land C$，而普通函数类型 $B \\to C$ 对应于蕴含 $B \\Rightarrow C$。在一个积和依赖积为基本构造的依赖类型论中工作，请按如下步骤进行：\n\n1. 只使用积和依赖积的引入和消去规则，显式地（作为一个完全类型的 $\\lambda$-项）构造出见证以下类型的典范正向映射：\n$$\n\\bigl(\\Pi_{x:A}\\,\\bigl(P(x) \\times Q(x)\\bigr)\\bigr) \\to \\bigl(\\Pi_{x:A}P(x)\\bigr) \\times \\bigl(\\Pi_{x:A}Q(x)\\bigr).\n$$\n你的构造必须从类型规则的第一性原理出发进行论证。\n\n2. 通过 Curry–Howard 对应解释，为什么你构造的项实现了逻辑蕴含：\n$$\n\\forall x.\\,\\bigl(P \\land Q\\bigr) \\;\\Rightarrow\\; \\bigl(\\forall x.\\,P\\bigr) \\land \\bigl(\\forall x.\\,Q\\bigr).\n$$\n你的解释应只涉及该对应的基本等同关系以及所涉类型的构成、引入和消去原则。\n\n3. 现在，在标准的集合论模型中解释这些类型，其中类型是集合，项是元素，$B \\times C$ 是笛卡尔积，而 $\\Pi_{x \\in A}B(x)$ 是所有选择函数 $f$ 的集合，其中对于每个 $x \\in A$ 都有 $f(x) \\in B(x)$。设 $A = \\{a_1,a_2,a_3\\}$ 是一个包含三个元素的有限集，并假设纤维的基数如下：\n$$\n|P(a_1)| = 2,\\quad |P(a_2)| = 1,\\quad |P(a_3)| = 5,\\qquad |Q(a_1)| = 3,\\quad |Q(a_2)| = 4,\\quad |Q(a_3)| = 2.\n$$\n计算依赖函数空间\n$$\n\\Pi_{x \\in A}\\bigl(P(x) \\times Q(x)\\bigr).\n$$\n的精确基数。请以单个整数形式提供最终答案，不要四舍五入。", "solution": "该问题是有效的，因为它科学地基于数学逻辑和依赖类型论的既定原则，问题陈述清晰、客观且内部一致。\n\n问题分为三个部分。我们将依次解决每一部分。\n\n### 第一部分：$\\lambda$-项的构造\n\n我们被要求构造一个居留于以下类型的项：\n$$\n\\bigl(\\Pi_{x:A}\\,\\bigl(P(x) \\times Q(x)\\bigr)\\bigr) \\to \\bigl(\\Pi_{x:A}P(x)\\bigr) \\times \\bigl(\\Pi_{x:A}Q(x)\\bigr).\n$$\n这是一个函数类型，具体来说是一个形式为 $B \\to C$ 的非依赖函数类型，其中 $B = \\Pi_{x:A}(P(x) \\times Q(x))$ 而 $C = (\\Pi_{x:A}P(x)) \\times (\\Pi_{x:A}Q(x))$。\n\n函数类型 $B \\to C$ 的引入规则是 $\\lambda$-抽象。为了构造此类型的一个项，我们假设一个定义域类型 $B$ 的变量（比如 $f$），然后构造一个余域类型 $C$ 的项。\n设 $f$ 为类型 $\\Pi_{x:A}\\,(P(x) \\times Q(x))$ 的一个变量。我们的目标是构造一个类型为 $(\\Pi_{x:A}P(x)) \\times (\\Pi_{x:A}Q(x))$ 的项。\n$$\n\\lambda f : \\Pi_{x:A}\\,(P(x) \\times Q(x)).\\; (\\text{目标项，类型为 } (\\Pi_{x:A}P(x)) \\times (\\Pi_{x:A}Q(x)))\n$$\n目标类型是一个积类型。积类型 $C_1 \\times C_2$ 的引入规则是形成一个对 $\\langle t_1, t_2 \\rangle$，其中 $t_1$ 的类型是 $C_1$，$t_2$ 的类型是 $C_2$。在此， $C_1 = \\Pi_{x:A}P(x)$ 且 $C_2 = \\Pi_{x:A}Q(x)$。\n所以，我们的目标项必须具有 $\\langle \\text{term}_1, \\text{term}_2 \\rangle$ 的形式，其中：\n- $\\text{term}_1$ 的类型是 $\\Pi_{x:A}P(x)$。\n- $\\text{term}_2$ 的类型是 $\\Pi_{x:A}Q(x)$。\n\n让我们构造 $\\text{term}_1$。类型 $\\Pi_{x:A}P(x)$ 是一个依赖函数类型。这种类型的引入规则同样是 $\\lambda$-抽象。我们必须构造一个函数，它接受一个类型为 $A$ 的项 $x$，并返回一个类型为 $P(x)$ 的项。\n设 $x$ 是类型为 $A$ 的变量。我们的目标是使用我们已有的假设 $f : \\Pi_{x:A}\\,(P(x) \\times Q(x))$ 来构造一个类型为 $P(x)$ 的项。\n$$\n\\text{term}_1 = \\lambda x:A.\\; (\\text{目标项，类型为 } P(x))\n$$\n依赖函数类型 $\\Pi$ 的消去规则是函数应用。由于 $f$ 的类型是 $\\Pi_{x:A}\\,(P(x) \\times Q(x))$ 而 $x$ 的类型是 $A$，我们可以将 $f$ 应用于 $x$。得到的项，我们记为 $f(x)$ 或 $f\\,x$，其类型为 $P(x) \\times Q(x)$。\n类型 $P(x) \\times Q(x)$ 是一个积类型。积的消去规则是投影 $\\pi_1$ 和 $\\pi_2$。\n将第一个投影 $\\pi_1$ 应用于项 $f(x)$，得到一个类型为 $P(x)$ 的项 $\\pi_1(f(x))$。这正是我们内部 lambda 体所需要的。\n因此，$\\text{term}_1 = \\lambda x:A.\\; \\pi_1(f(x))$。\n\n现在，让我们构造 $\\text{term}_2$。这个过程是对称的。其类型是 $\\Pi_{x:A}Q(x)$。我们再次使用 $\\lambda$-引入。设 $x$ 是类型为 $A$ 的变量。我们需要构造一个类型为 $Q(x)$ 的项。\n$$\n\\text{term}_2 = \\lambda x:A.\\; (\\text{目标项，类型为 } Q(x))\n$$\n如同之前，我们有 $f : \\Pi_{x:A}\\,(P(x) \\times Q(x))$ 和 $x : A$，所以 $f(x)$ 的类型是 $P(x) \\times Q(x)$。将第二个投影 $\\pi_2$ 应用于 $f(x)$，得到一个类型为 $Q(x)$ 的项 $\\pi_2(f(x))$。\n因此，$\\text{term}_2 = \\lambda x:A.\\; \\pi_2(f(x))$。\n\n组合这些部分，最终的 $\\lambda$-项是通过在对 $f$ 的初始 $\\lambda$-抽象内部将 $\\text{term}_1$ 和 $\\text{term}_2$ 配对来构造的。\n完整的项是：\n$$\n\\lambda f : \\Pi_{x:A}\\,(P(x) \\times Q(x)).\\; \\langle \\lambda x:A.\\; \\pi_1(f(x)), \\lambda x:A.\\; \\pi_2(f(x)) \\rangle\n$$\n这个项具有所需的类型，并且完全是根据指定的引入和消去规则构造的。\n\n### 第二部分：通过 Curry–Howard 对应进行的逻辑解释\n\nCurry–Howard 对应在直觉主义逻辑中的命题与合适的类型论中的类型之间建立了一个直接的同构关系。在此对应下：\n- 一个类型有居留元，当且仅当对应的命题可证。\n- 居留于某个类型的项是对应命题的一个证明。\n- 函数类型 $B \\to C$ 对应于逻辑蕴含 $B \\Rightarrow C$。\n- 积类型 $B \\times C$ 对应于逻辑合取 $B \\land C$。\n- 依赖函数类型 $\\Pi_{x:A}B(x)$ 对应于全称量化 $\\forall x:A.\\,B(x)$。\n\n让我们将第一部分中的类型翻译成一个逻辑命题。\n- 参数的类型 $\\Pi_{x:A}\\,(P(x) \\times Q(x))$ 对应于命题 $\\forall x:A.\\,(P(x) \\land Q(x))$。\n- 结果的第一个分量的类型 $\\Pi_{x:A}P(x)$ 对应于 $\\forall x:A.\\,P(x)$。\n- 结果的第二个分量的类型 $\\Pi_{x:A}Q(x)$ 对应于 $\\forall x:A.\\,Q(x)$。\n- 这两者的积 $(\\Pi_{x:A}P(x)) \\times (\\Pi_{x:A}Q(x))$ 对应于合取 $(\\forall x:A.\\,P(x)) \\land (\\forall x:A.\\,Q(x))$。\n- 最后，第一部分中的完整函数类型对应于蕴含：\n$$\n\\bigl(\\forall x:A.\\,(P(x) \\land Q(x))\\bigr) \\Rightarrow \\bigl((\\forall x:A.\\,P(x)) \\land (\\forall x:A.\\,Q(x))\\bigr).\n$$\n这与所提供的逻辑公式相匹配。在第一部分中构造的 $\\lambda$-项是此命题的一个证明对象。让我们追踪一下该项结构所反映的证明步骤。\n\n1.  **蕴含引入 ($\\Rightarrow_I$)**: 最外层的 `λf : ...` 对应于假定蕴含式的前件。我们假定我们有一个 $\\forall x:A.\\,(P(x) \\land Q(x))$ 的证明 $f$。\n\n2.  **合取引入 ($\\land_I$)**: 对构造子 $\\langle \\dots, \\dots \\rangle$ 对应于证明一个合取的目标。为了证明主后件，我们必须分别证明它的两个合取项：(i) $\\forall x:A.\\,P(x)$ 和 (ii) $\\forall x:A.\\,Q(x)$。\n\n3.  **证明第一个合取项, $\\forall x:A.\\,P(x)$**:\n    - **全称引入 ($\\forall_I$)**: 项 $\\lambda x:A.\\; \\dots$ 对应于从定义域 $A$ 中引入一个任意元素 $x$，并为它证明 $P(x)$。\n    - **全称消去 ($\\forall_E$)**: 项 $f(x)$ 对应于将我们的初始假设（即 $\\forall x:A.\\,(P(x) \\land Q(x))$ 的证明 $f$）应用于这个特定的任意元素 $x$。这给了我们一个 $P(x) \\land Q(x)$ 的证明。\n    - **合取消去 ($\\land_E$)**: 项 $\\pi_1(f(x))$ 对应于消去合取 $P(x) \\land Q(x)$ 以获得其左侧 $P(x)$ 的一个证明。这就结束了对任意 $x$ 的证明。\n\n4.  **证明第二个合取项, $\\forall x:A.\\,Q(x)$**:\n    - 推理过程是对称的。项 $\\lambda x:A.\\; \\pi_2(f(x))$ 对应于一个 $\\forall x:A.\\,Q(x)$ 的证明，通过假定一个任意的 $x:A$，实例化全称假设得到 $P(x) \\land Q(x)$，然后消去合取得到 $Q(x)$。\n\n该 $\\lambda$-项的结构是该逻辑蕴含的一个自然演绎证明的形式化编码。在该项的构造中使用的每个类型论规则（引入/消去）都精确地对应于一个逻辑推理规则。\n\n### 第三部分：基数计算\n\n在集合论模型中：\n- 一个类型被解释为一个集合。\n- 积类型 $B \\times C$ 被解释为集合 $B$ 和 $C$ 的笛卡尔积。其基数为 $|B \\times C| = |B| \\times |C|$。\n- 依赖函数类型 $\\Pi_{x \\in A} B(x)$ 被解释为所有定义域为 $A$ 的函数 $f$ 的集合，使得对于每个 $x \\in A$，都有 $f(x) \\in B(x)$。这是集合族 $\\{B(x)\\}_{x \\in A}$ 的广义笛卡尔积。\n\n这样一个依赖函数空间（或广义笛卡尔积）的基数是该族中各个集合基数的乘积：\n$$\n\\left| \\Pi_{x \\in A} B(x) \\right| = \\prod_{x \\in A} |B(x)|.\n$$\n我们被要求计算类型 $\\Pi_{x \\in A}(P(x) \\times Q(x))$ 的基数。在集合论模型中，这对应于选择函数的集合，其中对于每个 $x \\in A$ 的纤维是集合 $P(x) \\times Q(x)$。\n\n因此，基数为：\n$$\n\\left| \\Pi_{x \\in A}\\bigl(P(x) \\times Q(x)\\bigr) \\right| = \\prod_{x \\in A} |P(x) \\times Q(x)|.\n$$\n使用笛卡尔积基数的规则，我们有 $|P(x) \\times Q(x)| = |P(x)| \\times |Q(x)|$。所以，总基数是：\n$$\n\\prod_{x \\in A} \\bigl(|P(x)| \\times |Q(x)|\\bigr).\n$$\n集合 $A$ 被给出为 $A = \\{a_1, a_2, a_3\\}$。这个乘积在 $A$ 的元素上展开：\n$$\n\\bigl(|P(a_1)| \\times |Q(a_1)|\\bigr) \\times \\bigl(|P(a_2)| \\times |Q(a_2)|\\bigr) \\times \\bigl(|P(a_3)| \\times |Q(a_3)|\\bigr).\n$$\n我们被给予了以下基数：\n- $|P(a_1)| = 2$, $|Q(a_1)| = 3$\n- $|P(a_2)| = 1$, $|Q(a_2)| = 4$\n- $|P(a_3)| = 5$, $|Q(a_3)| = 2$\n\n将这些值代入表达式中：\n- 对于 $x = a_1$: $|P(a_1)| \\times |Q(a_1)| = 2 \\times 3 = 6$。\n- 对于 $x = a_2$: $|P(a_2)| \\times |Q(a_2)| = 1 \\times 4 = 4$。\n- 对于 $x = a_3$: $|P(a_3)| \\times |Q(a_3)| = 5 \\times 2 = 10$。\n\n总基数是这些结果的乘积：\n$$\n6 \\times 4 \\times 10 = 24 \\times 10 = 240.\n$$\n依赖函数空间 $\\Pi_{x \\in A}(P(x) \\times Q(x))$ 的基数是 $240$。", "answer": "$$\\boxed{240}$$", "id": "2985606"}, {"introduction": "“程序即证明”的对应关系并非一成不变，它会随着计算模型的改变而展现出不同的逻辑内涵。这个练习探讨了两种核心求值策略——传值调用 (call-by-value, CBV) 和传名调用 (call-by-name, CBN)——如何导致同一个程序产生截然不同的结果（收敛或发散）。通过分析这种差异，你将揭示出不同求值策略背后所蕴含的不同逻辑，特别是它们如何处理由递归产生的“部分证明”或无穷计算，从而更深刻地理解计算与逻辑之间动态而丰富的联系。", "problem": "在 Curry-Howard 对应关系下的类型化 lambda 演算中，考虑一个包含简单类型、积类型、自然数以及一个通用递归算子的语言。类型由以下文法生成：$\\,\\tau ::= \\mathsf{Nat} \\mid \\tau \\to \\tau \\mid \\tau \\times \\tau\\,$，而项则包括通常的变量、lambda 抽象、应用、配对和投影，以及自然数常量、后继算子和一个不动点算子。类型定则为带积类型的简单类型化 lambda 演算的标准规则，外加不动点算子的类型规则：不动点算子是一个类型为 $(\\tau \\to \\tau) \\to \\tau$ 的项 $\\mathsf{fix}$，因此对于任意类型为 $\\tau \\to \\tau$ 的项 $g$，项 $\\mathsf{fix}\\,g$ 的类型为 $\\tau$。传值调用（CBV）和传名调用（CBN）的操作语义有所不同：\n- 在传值调用（CBV）中，对于应用 $(M\\,N)$，在执行 $\\beta$-归约之前，会先将 $M$ 求值成一个值，然后将 $N$ 求值成一个值；对于配对 $\\langle M,N\\rangle$，在构成序对之前，会先将 $M$ 和 $N$ 都求值成值。投影作用于值：$\\pi_{1}\\langle V_{1},V_{2}\\rangle \\to V_{1}$ 和 $\\pi_{2}\\langle V_{1},V_{2}\\rangle \\to V_{2}$。不动点算子通过 $\\mathsf{fix}\\,g \\to g\\,(\\mathsf{fix}\\,g)$ 进行归约，这可能会发散。\n- 在传名调用（CBN）中，对于应用 $(M\\,N)$，在执行 $\\beta$-归约之前，会先将 $M$ 求值成一个值，但不会对 $N$ 求值；配对 $\\langle M,N\\rangle$ 本身就是一个值（其分量不被求值），投影通过 $\\pi_{1}\\langle M,N\\rangle \\to M$ 和 $\\pi_{2}\\langle M,N\\rangle \\to N$ 进行归约，而无需对 $M$ 或 $N$ 求值。不动点算子的归约方式与 CBV 中相同：$\\mathsf{fix}\\,g \\to g\\,(\\mathsf{fix}\\,g)$。\n\n在 Curry-Howard 对应关系下，函数类型 $\\,\\sigma \\to \\rho\\,$ 对应于逻辑蕴涵 $\\,\\sigma \\Rightarrow \\rho\\,$，积类型 $\\,\\sigma \\times \\rho\\,$ 对应于逻辑合取 $\\,\\sigma \\wedge \\rho\\,$。一个类型为 $\\,\\mathsf{Nat}\\,$ 的闭项可以被解读为被解释为自然数的数据命题的一个证明（居留元）。$\\mathsf{fix}$ 的存在引入了非终止性（非形式地用一个永不达到范式的项 $\\,\\Omega$ 来表示），这反映了部分证明或部分计算。\n\n请显式地构造一个类型为 $\\,\\mathsf{Nat}\\,$ 的闭项 $\\,M\\,$，该项在传值调用（CBV）和传名调用（CBN）下的求值行为不同，但在两种策略下其类型相同。你的构造必须仅使用上述描述的基本元素。然后，从所述的核心类型定则和操作规则出发，推导：\n1. 一个形式化的类型推导，证明 $\\,\\vdash M : \\mathsf{Nat}\\,$。\n2. 一个 CBV 求值轨迹，解释为何 $\\,M\\,$ 不会归约为一个数（即发散）。\n3. 一个 CBN 求值轨迹，解释为何 $\\,M\\,$ 会归约为一个闭合的数。\n4. 一项基于 Curry-Howard 对应关系的分析，阐述 CBV 和 CBN 中相关证明变换（范式化）的逻辑差异，这些差异解释了你构造的 $\\,M\\,$ 的发散与收敛行为，重点关注蕴涵消除和合取消除如何与由 $\\mathsf{fix}$ 产生的部分证明相互作用。\n\n最后，确定 $\\,M\\,$ 在传名调用（CBN）下归约成的那个闭合的数。将你的最终答案表示为一个标准的自然数字面量，不带单位。无需四舍五入。", "solution": "所述问题是良定的，其科学基础根植于既有的程序设计语言和逻辑理论，并包含了形式化解答所需的所有必要组成部分。我们首先构造所需的项，然后分析其行为。\n\n一个在传值调用（CBV）和传名调用（CBN）求值下表现出不同行为的项，必须利用这两种策略的核心区别：参数求值的时机。具体来说，CBN 采用惰性求值，即函数参数和数据结构的分量在其值被需要之前不会被求值。相比之下，CBV 是严格的，要求所有参数和分量在函数被调用或数据结构被构造之前都必须被求值为一个值。\n\n我们来构造一个利用这一差异的项 $M$。关键在于使用一个非终止计算作为一个数据结构的分量，该分量在 CBN 下被丢弃，但在 CBV 下却是必需的。不动点算子 $\\mathsf{fix}$ 允许我们定义这样一个非终止计算。设 $\\Omega_{\\tau}$ 是一个类型为 $\\tau$ 的通用发散项，定义为 $\\Omega_{\\tau} := \\mathsf{fix}(\\lambda x:\\tau. x)$。该项的求值展开为 $\\mathsf{fix}(\\lambda x:\\tau. x) \\to (\\lambda x:\\tau. x)(\\mathsf{fix}(\\lambda x:\\tau. x)) \\to \\mathsf{fix}(\\lambda x:\\tau. x)$，形成一个无限循环。\n\n我们如下构造类型为 $\\mathsf{Nat}$ 的闭项 $M$：\n$$M := \\pi_1(\\langle 0, \\mathsf{fix}(\\lambda y:\\mathsf{Nat}. y) \\rangle)$$\n此处，$0$ 是类型为 $\\mathsf{Nat}$ 的自然数常量，而 $\\mathsf{fix}(\\lambda y:\\mathsf{Nat}. y)$ 是一个类型为 $\\mathsf{Nat}$ 的非终止计算。序对 $\\langle 0, \\mathsf{fix}(\\lambda y:\\mathsf{Nat}. y) \\rangle$ 的类型为 $\\mathsf{Nat} \\times \\mathsf{Nat}$。投影 $\\pi_1$ 提取第一个分量，应该得到一个类型为 $\\mathsf{Nat}$ 的项。\n\n**1. 形式化类型推导**\n\n我们现在使用带积类型和不动点算子的简单类型化 lambda 演算的标准类型定则来证明 $\\vdash M : \\mathsf{Nat}$。由于 $M$ 是一个闭项，环境为空（$\\emptyset$）。设 $\\Gamma$ 表示一个类型上下文。\n\n推导如下：\n$$\n\\frac{\n  \\frac{\n    \\frac{\n      \\frac{}{y:\\mathsf{Nat} \\vdash y:\\mathsf{Nat}} \\text{(Var)}\n    }{\n      \\vdash \\lambda y:\\mathsf{Nat}. y : \\mathsf{Nat} \\to \\mathsf{Nat}\n    } \\text{(Abs)}\n  }{\n    \\vdash \\mathsf{fix}(\\lambda y:\\mathsf{Nat}. y) : \\mathsf{Nat}\n  } \\text{(Fix)}\n  \\quad\n  \\frac{}{ \\vdash 0 : \\mathsf{Nat}} \\text{(Const)}\n}{\n  \\frac{\n    \\vdash \\langle 0, \\mathsf{fix}(\\lambda y:\\mathsf{Nat}. y) \\rangle : \\mathsf{Nat} \\times \\mathsf{Nat}\n  }{\n    \\vdash \\pi_1(\\langle 0, \\mathsf{fix}(\\lambda y:\\mathsf{Nat}. y) \\rangle) : \\mathsf{Nat}\n  } \\text{(Proj1)}\n} \\text{(Pair)}\n$$\n此推导形式化地证明了我们构造的项 $M$ 是良构的，其类型为 $\\mathsf{Nat}$。无论采用 CBV 还是 CBN 求值策略，其类型推导都是相同的，因为类型定则独立于操作语义。\n\n**2. 传值调用（CBV）求值轨迹**\n\n在 CBV 下，函数参数和序对分量必须先求值为值，归约才能继续。值是一个常量（如数）、一个 lambda 抽象，或一个由值构成的序对 $\\langle V_1, V_2 \\rangle$。设 $\\Omega_{\\mathsf{Nat}} := \\mathsf{fix}(\\lambda y:\\mathsf{Nat}. y)$。\n\n$M = \\pi_1(\\langle 0, \\Omega_{\\mathsf{Nat}} \\rangle)$ 的求值过程如下：\n1.  要求值 $\\pi_1(E)$，我们必须首先将其参数 $E = \\langle 0, \\Omega_{\\mathsf{Nat}} \\rangle$ 求值为一个值。\n2.  在 CBV 中要求值序对 $\\langle E_1, E_2 \\rangle$ ，我们必须首先将 $E_1$ 求值为一个值 $V_1$，然后将 $E_2$ 求值为一个值 $V_2$。\n3.  设 $E_1 = 0$。这是一个数，它已经是一个值。因此，$V_1 = 0$。\n4.  设 $E_2 = \\Omega_{\\mathsf{Nat}} = \\mathsf{fix}(\\lambda y:\\mathsf{Nat}. y)$。我们必须将其求值为一个值。设 $g = \\lambda y:\\mathsf{Nat}. y$。\n5.  不动点算子的归约规则是 $\\mathsf{fix}\\,g \\to g\\,(\\mathsf{fix}\\,g)$。因此，$\\Omega_{\\mathsf{Nat}} \\to (\\lambda y:\\mathsf{Nat}. y)\\,\\Omega_{\\mathsf{Nat}}$。\n6.  在 CBV 中要求值此应用，我们必须首先将其参数，即 $\\Omega_{\\mathsf{Nat}}$，求值为一个值。\n7.  尝试对参数 $\\Omega_{\\mathsf{Nat}}$ 求值使我们回到了第 5 步。因此，对 $\\Omega_{\\mathsf{Nat}}$ 的求值是非终止的：\n    $$ \\Omega_{\\mathsf{Nat}} \\to (\\lambda y:\\mathsf{Nat}. y)\\,\\Omega_{\\mathsf{Nat}} \\to (\\lambda y:\\mathsf{Nat}. y)\\,((\\lambda y:\\mathsf{Nat}. y)\\,\\Omega_{\\mathsf{Nat}}) \\to \\dots $$\n由于 $E_2$ 永远不会归约为一个值，所以值序对 $\\langle V_1, V_2 \\rangle$ 永远无法形成。因此，对 $\\pi_1(\\langle 0, \\Omega_{\\mathsf{Nat}} \\rangle)$ 的初始求值无法越过对其参数求值的步骤。$M$ 的求值在 CBV 下发散。\n\n**3. 传名调用（CBN）求值轨迹**\n\n在 CBN 下，参数在传递给函数前不被求值。对于积类型，序对 $\\langle E_1, E_2 \\rangle$ 本身就被视为一个值，无论 $E_1$ 和 $E_2$ 是否为值。投影直接作用于这些未求值的序对。设 $\\Omega_{\\mathsf{Nat}} := \\mathsf{fix}(\\lambda y:\\mathsf{Nat}. y)$。\n\n$M = \\pi_1(\\langle 0, \\Omega_{\\mathsf{Nat}} \\rangle)$ 的求值过程如下：\n1.  要求值 $\\pi_1(E)$，我们检查 $E$ 是否为一个序对。\n2.  参数是 $E = \\langle 0, \\Omega_{\\mathsf{Nat}} \\rangle$。在 CBN 中，任何形如 $\\langle E_1, E_2 \\rangle$ 的项都是一个值。\n3.  投影的归约规则是 $\\pi_1(\\langle E_1, E_2 \\rangle) \\to E_1$。\n4.  应用此规则，我们得到：\n    $$ \\pi_1(\\langle 0, \\mathsf{fix}(\\lambda y:\\mathsf{Nat}. y) \\rangle) \\to 0 $$\n5.  结果是 $0$，这是一个数，因此是最终值。求值终止。\n发散项 $\\Omega_{\\mathsf{Nat}}$ 处于一个惰性上下文中（一个序对的第二个分量，随后被 $\\pi_1$ 丢弃），因此它从未被求值。\n\n**4. Curry-Howard 对应关系分析**\n\nCurry-Howard 对应关系在直觉主义逻辑中的命题与类型化 lambda 演算中的类型之间建立了一种同构。在这种同构关系下，一个给定类型的项是相应命题的一个证明，而项的求值（范式化）对应于证明的化简。\n\n- **类型作为命题**：\n  - $\\mathsf{Nat}$：一个代表自然数类型的命题。\n  - $\\tau_1 \\to \\tau_2$：逻辑蕴涵，$\\tau_1 \\Rightarrow \\tau_2$。\n  - $\\tau_1 \\times \\tau_2$：逻辑合取，$\\tau_1 \\wedge \\tau_2$。\n\n- **项作为证明**：\n  - $0 : \\mathsf{Nat}$：命题 $\\mathsf{Nat}$ 的一个典范证明（或见证）。\n  - $\\langle t_1, t_2 \\rangle : \\tau_1 \\times \\tau_2$：合取命题 $\\tau_1 \\wedge \\tau_2$ 的一个证明，由 $\\tau_1$ 的证明 $t_1$ 和 $\\tau_2$ 的证明 $t_2$ 构造而成。\n  - $\\pi_1(p) : \\tau_1$：通过合取消除（$\\wedge$-消除），从 $\\tau_1 \\wedge \\tau_2$ 的证明 $p$ 中获得的 $\\tau_1$ 的证明。\n  - $\\Omega_{\\mathsf{Nat}} = \\mathsf{fix}(\\lambda y:\\mathsf{Nat}. y)$：`fix` 算子允许存在不进行范式化的证明。这对应于一个部分证明或非构造性证明。$\\Omega_{\\mathsf{Nat}}$ 是 $\\mathsf{Nat}$ 的一个“证明”，它承诺会给出一个自然数，但其化简过程却永不产出结果。\n\n$M$ 的发散与收敛行为揭示了 CBV 和 CBN 所对应的逻辑系统之间的深刻差异，特别是在存在部分证明时关于合取规则的差异。\n\n- **CBN 逻辑**：CBN 的范式化策略是惰性的。在化简证明 $M = \\pi_1(\\langle 0, \\Omega_{\\mathsf{Nat}} \\rangle)$ 时，$\\wedge$-消除规则（$\\pi_1$）仅要求合取命题的复合证明 $\\langle 0, \\Omega_{\\mathsf{Nat}} \\rangle$ 的存在。它继续提取第一个分量 $0$，而无需化简甚至检查第二个分量 $\\Omega_{\\mathsf{Nat}}$。在 CBN 中，$\\tau_1 \\wedge \\tau_2$ 的证明就像一个可以生成 $\\tau_1$ 的证明和 $\\tau_2$ 的证明的*过程*。$\\wedge$-消除规则只是运行第一个过程，而忽略第二个。第二个过程（$\\Omega_{\\mathsf{Nat}}$）永不停止这一事实是无关紧要的。证明范式化成功。\n\n- **CBV 逻辑**：CBV 的范式化策略是严格的。要使用一个合取证明，它要求两个合取项的证明都必须*预先*完全化简为其典范形式。为了化简 $M$，CBV 首先尝试将前提 $\\langle 0, \\Omega_{\\mathsf{Nat}} \\rangle$ 化简成一个典范形式。这需要将 $0$（已经是典范形式）和 $\\Omega_{\\mathsf{Nat}}$ 都归约为其典范形式。尝试化简部分证明 $\\Omega_{\\mathsf{Nat}}$ 会导致一个无限过程。因此，复合合取证明的构造失败了。在 CBV 中，一个 $\\tau_1 \\wedge \\tau_2$ 的证明要求*已经构造好* $\\tau_1$ 和 $\\tau_2$ 的典范见证。由于第二个合取项的见证无法被构造出来，整个证明失败。\n\n总而言之，求值策略的选择对应于不同的逻辑语义。CBN 体现了一种逻辑，它容忍复合结构中的部分证明，只要该部分证明未被明确需要。CBV 则强制执行一种更严格的逻辑，其中构造性证明的任何组成部分本身都必须被完全地、构造性地建立起来。\n\n在传名调用（CBN）下，$M$ 归约成的闭合的数是 $0$。", "answer": "$$\n\\boxed{0}\n$$", "id": "2985673"}]}