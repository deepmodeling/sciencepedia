{"hands_on_practices": [{"introduction": "Before tackling the full Neumann formula, it is instructive to build our intuition using the fundamental definition of mutual inductance, $M = \\Phi_{21}/I_1$, which relates the magnetic flux through one circuit to the current in another. This first exercise explores a classic, highly symmetric configuration where a direct flux calculation is feasible. By considering a very small loop at the center of a much larger one, we can make a simplifying approximation that the magnetic field is uniform over the area of the small loop, allowing for a straightforward calculation that highlights the physical principle of flux linkage. [@problem_id:1594773]", "problem": "A large circular wire loop of radius $R$ and a very small circular wire loop of radius $r$, with the condition $r \\ll R$, are placed such that they are concentric. The plane of the small loop is tilted, forming an angle $\\theta$ with the plane of the large loop. Your goal is to determine the mutual inductance $M$ between this pair of loops. Derive an expression for $M$ in terms of the given parameters $R$, $r$, $\\theta$, and the permeability of free space, $\\mu_0$.", "solution": "Mutual inductance is defined as $M=\\frac{\\Phi_{21}}{I_{1}}$, where $\\Phi_{21}$ is the magnetic flux through loop 2 (the small loop) due to current $I_{1}$ in loop 1 (the large loop).\n\nThe magnetic field at the center of a circular loop of radius $R$ carrying current $I_{1}$ is, by the Biotâ€“Savart law result,\n$$\nB=\\frac{\\mu_{0} I_{1}}{2R}.\n$$\nFor $r \\ll R$, the small loop samples the field of the large loop over a region where the field is approximately uniform and equal to its value at the common center. The flux through the small loop is\n$$\n\\Phi_{21}=\\int \\mathbf{B}\\cdot d\\mathbf{a}=B\\,A_{2}\\cos\\theta,\n$$\nwhere $A_{2}=\\pi r^{2}$ is the area of the small loop and $\\theta$ is the angle between the normal to the small loop and the direction of $\\mathbf{B}$ (which is along the normal to the large loop). Substituting $B$ and $A_{2}$,\n$$\n\\Phi_{21}=\\left(\\frac{\\mu_{0} I_{1}}{2R}\\right)\\left(\\pi r^{2}\\right)\\cos\\theta.\n$$\nTherefore, the mutual inductance is\n$$\nM=\\frac{\\Phi_{21}}{I_{1}}=\\frac{\\mu_{0}\\pi r^{2}}{2R}\\cos\\theta.\n$$\nThis result holds to leading order in the approximation $r \\ll R$.", "answer": "$$\\boxed{\\frac{\\mu_{0}\\pi r^{2}}{2R}\\cos\\theta}$$", "id": "1594773"}, {"introduction": "While direct flux calculations are useful for simple geometries, most real-world scenarios require a more powerful and general approach. This is where the Neumann formula, $M = \\frac{\\mu_0}{4\\pi} \\oint \\oint \\frac{d\\mathbf{l}_1 \\cdot d\\mathbf{l}_2}{|\\mathbf{r}_1 - \\mathbf{r}_2|}$, proves its utility. This problem provides a direct analytical workout with the formula by calculating the mutual inductance between two coaxial circular arcs. Although the full double integral is complex, applying a physical approximation for large separations allows us to arrive at a clean analytical result, providing valuable practice in parameterizing curves and evaluating the vector components of the formula. [@problem_id:27135]", "problem": "Consider two identical, thin wire circular arcs, each of radius $R$ and subtending an angle $\\alpha$. The arcs are arranged coaxially and parallel to each other, separated by a distance $h$. Let the arcs be centered on the z-axis, lying in the planes $z=0$ and $z=h$. Assume the current flows in the same azimuthal direction in both arcs.\n\nThe mutual inductance $M$ between two circuits $\\mathcal{C}_1$ and $\\mathcal{C}_2$ is given by the Neumann formula:\n$$\nM = \\frac{\\mu_0}{4\\pi} \\oint_{\\mathcal{C}_1} \\oint_{\\mathcal{C}_2} \\frac{d\\mathbf{l}_1 \\cdot d\\mathbf{l}_2}{|\\mathbf{r}_1 - \\mathbf{r}_2|}\n$$\nwhere $d\\mathbf{l}_1$ and $d\\mathbf{l}_2$ are infinitesimal elements of length along the wires, and $|\\mathbf{r}_1 - \\mathbf{r}_2|$ is the distance between them.\n\nDerive an expression for the mutual inductance between the two arcs in the limit of large separation, i.e., $h \\gg R$. Your final answer should be the leading non-vanishing term in an expansion in the small parameter $R/h$. You should only consider the interaction between the two specified arcs, neglecting the magnetic field from any wires that might feed current to them.", "solution": "We start from the Neumann formula for mutual inductance between two current-carrying circuits $\\mathcal{C}_1$ and $\\mathcal{C}_2$,\n$$\nM=\\frac{\\mu_0}{4\\pi}\\oint_{\\mathcal{C}_1}\\oint_{\\mathcal{C}_2}\\frac{d\\mathbf{l}_1\\cdot d\\mathbf{l}_2}{|\\mathbf{r}_1-\\mathbf{r}_2|}\\,.\n$$\nParameterize the two arcs of radius $R$ and subtending angle $\\alpha$ by angles $\\phi_1,\\phi_2\\in[0,\\alpha]$:\n$$\n\\mathbf{r}_1=R(\\cos\\phi_1,\\sin\\phi_1,0),\\quad d\\mathbf{l}_1=R(-\\sin\\phi_1,\\cos\\phi_1,0)\\,d\\phi_1,\n$$\n$$\n\\mathbf{r}_2=R(\\cos\\phi_2,\\sin\\phi_2,h),\\quad d\\mathbf{l}_2=R(-\\sin\\phi_2,\\cos\\phi_2,0)\\,d\\phi_2.\n$$\nThen\n$$\nd\\mathbf{l}_1\\cdot d\\mathbf{l}_2\n=R^2[\\sin\\phi_1\\sin\\phi_2+\\cos\\phi_1\\cos\\phi_2]\\,d\\phi_1d\\phi_2\n=R^2\\cos(\\phi_1-\\phi_2)\\,d\\phi_1d\\phi_2,\n$$\nand\n$$\n|\\mathbf{r}_1-\\mathbf{r}_2|=\\sqrt{2R^2[1-\\cos(\\phi_1-\\phi_2)]+h^2}\n=h\\sqrt{1+\\frac{2R^2}{h^2}[1-\\cos\\Delta]}\\,,\n$$\nwith $\\Delta=\\phi_1-\\phi_2$.  For $h\\gg R$, expand\n$$\n\\frac1{|\\mathbf{r}_1-\\mathbf{r}_2|}\n=\\frac1h\\Bigl[1-\\frac{R^2[1-\\cos\\Delta]}{h^2}+\\mathcal{O}\\left(\\frac{R^4}{h^4}\\right)\\Bigr].\n$$\nThus the leading term in $M$ is\n$$\nM\\approx\\frac{\\mu_0R^2}{4\\pi h}\n\\int_0^\\alpha\\!\\int_0^\\alpha\\cos(\\phi_1-\\phi_2)\\,d\\phi_1d\\phi_2\n=\\frac{\\mu_0R^2}{4\\pi h}\\,2\\bigl[1-\\cos\\alpha\\bigr]\n=\\frac{\\mu_0R^2}{\\pi h}\\sin^2\\!\\frac\\alpha2\\,.\n$$\nAll higher corrections are $\\mathcal{O}(R^4/h^3)$ and hence subleading.", "answer": "$$\\boxed{\\frac{\\mu_0 R^2}{\\pi h}\\sin^2\\!\\Bigl(\\frac{\\alpha}{2}\\Bigr)}$$", "id": "27135"}, {"introduction": "In many practical engineering and physics applications, current loops have arbitrary sizes, positions, and orientations for which the Neumann formula's integral is analytically intractable. This final practice bridges the gap between theoretical formulation and modern computational methods. You are tasked with writing a program to numerically evaluate the Neumann formula for two circular loops in a general, non-coplanar, and non-coaxial arrangement. This exercise demonstrates how the formula serves as a fundamental recipe for computation, enabling the calculation of mutual inductance in complex, realistic systems where pen-and-paper methods fall short. [@problem_id:2419641]", "problem": "You are given two thin, closed, circular wire loops in free space, modeled as curves $\\mathcal{C}_1$ and $\\mathcal{C}_2$ in three-dimensional Euclidean space. Each loop $i \\in \\{1,2\\}$ is characterized by a radius $R_i$ (in meters), a center position vector $\\mathbf{c}_i$ (in meters), and a unit normal vector $\\mathbf{n}_i$ indicating the orientation of its plane. The magnetic constant $\\mu_0$ equals $4\\pi \\times 10^{-7}$ henry per meter in the International System of Units (SI). The mutual inductance $M$ (in henries) between the two loops is defined from first principles by the Neumann formula:\n$$\nM \\;=\\; \\frac{\\mu_0}{4\\pi}\\;\\oint_{\\mathcal{C}_1}\\;\\oint_{\\mathcal{C}_2}\\;\\frac{\\mathrm{d}\\mathbf{\\ell}_1 \\cdot \\mathrm{d}\\mathbf{\\ell}_2}{\\|\\mathbf{r}_1 - \\mathbf{r}_2\\|}\\,,\n$$\nwhere $\\mathbf{r}_1 \\in \\mathcal{C}_1$, $\\mathbf{r}_2 \\in \\mathcal{C}_2$, and $\\mathrm{d}\\mathbf{\\ell}_1$, $\\mathrm{d}\\mathbf{\\ell}_2$ are the differential line elements along the loops. Model each loop as an ideal circular filament. Any angular parameter used must be interpreted in radians.\n\nWrite a program that evaluates $M$ numerically for each of the following test cases. All input data are given in meters for geometric quantities and are to be treated exactly as stated. You must assume free space everywhere and no magnetic materials are present. The final answers must be expressed in henries as floating-point numbers.\n\nTest suite (process in the given order):\n\n- Case $1$ (general non-coaxial, non-coplanar, moderate separation):\n  - $R_1 = 0.10$, $\\mathbf{c}_1 = (0.00,\\,0.00,\\,0.00)$, $\\mathbf{n}_1 = (0,\\,0,\\,1)$.\n  - $R_2 = 0.08$, $\\mathbf{c}_2 = (0.05,\\,0.02,\\,0.03)$, $\\mathbf{n}_2 = \\frac{1}{\\sqrt{3}}(1,\\,1,\\,1)$.\n\n- Case $2$ (large separation, small coupling):\n  - $R_1 = 0.20$, $\\mathbf{c}_1 = (0.20,\\,-0.10,\\,0.00)$, $\\mathbf{n}_1 = (0,\\,1,\\,0)$.\n  - $R_2 = 0.15$, $\\mathbf{c}_2 = (1.00,\\,-0.50,\\,0.80)$, $\\mathbf{n}_2 = (0,\\,0,\\,1)$.\n\n- Case $3$ (nearly intersecting orientation, small offset to avoid intersection):\n  - $R_1 = 0.10$, $\\mathbf{c}_1 = (0.00,\\,0.00,\\,0.00)$, $\\mathbf{n}_1 = (0,\\,0,\\,1)$.\n  - $R_2 = 0.10$, $\\mathbf{c}_2 = (0.005,\\,0.00,\\,0.00)$, $\\mathbf{n}_2 = (0,\\,1,\\,0)$.\n\n- Case $4$ (arbitrary oblique orientations and offsets):\n  - $R_1 = 0.12$, $\\mathbf{c}_1 = (-0.03,\\,0.04,\\,0.02)$, $\\mathbf{n}_1 = \\frac{1}{\\sqrt{(0.2)^2+(0.9)^2+(0.4)^2}}(0.2,\\,0.9,\\,0.4)$.\n  - $R_2 = 0.07$, $\\mathbf{c}_2 = (0.06,\\,-0.02,\\,0.05)$, $\\mathbf{n}_2 = \\frac{1}{\\sqrt{(-0.3)^2+(0.1)^2+(0.95)^2}}(-0.3,\\,0.1,\\,0.95)$.\n\nRequirements:\n\n- Treat each loop as a perfect circle lying in the plane orthogonal to $\\mathbf{n}_i$, centered at $\\mathbf{c}_i$, with radius $R_i$.\n- You must evaluate the defining double line integral of $M$ over the angular parameters that traverse each circle once over the interval $[0,\\,2\\pi]$, with angles in radians.\n- Output unit: henries. Each result must be a floating-point number.\n- Final output format: your program should produce a single line containing a comma-separated list of the four numerical results enclosed in square brackets, in the order of cases $1$ through $4$, for example, $[m_1,m_2,m_3,m_4]$. Each $m_i$ must be formatted in scientific notation with at least $10$ significant digits (for example, $1.234567890\\times 10^{-6}$ should be printed as $1.234567890e-06$). No extra text or spaces are allowed in the output line.", "solution": "The problem as stated is scientifically sound, self-contained, and well-posed. It is a standard problem in computational electromagnetics, grounded in the fundamental principles of magnetostatics. All necessary data are provided, and the problem is objective and free of ambiguity. Therefore, a solution will be provided.\n\nThe mutual inductance $M$ between two closed current loops $\\mathcal{C}_1$ and $\\mathcal{C}_2$ is defined by the Neumann formula:\n$$\nM \\;=\\; \\frac{\\mu_0}{4\\pi}\\;\\oint_{\\mathcal{C}_1}\\;\\oint_{\\mathcal{C}_2}\\;\\frac{\\mathrm{d}\\mathbf{\\ell}_1 \\cdot \\mathrm{d}\\mathbf{\\ell}_2}{\\|\\mathbf{r}_1 - \\mathbf{r}_2\\|}\\\n$$\nHere, $\\mu_0 = 4\\pi \\times 10^{-7}$ henry per meter is the magnetic constant, which simplifies the leading factor to $\\frac{\\mu_0}{4\\pi} = 10^{-7}$ in SI units. The vectors $\\mathbf{r}_1$ and $\\mathbf{r}_2$ are position vectors pointing to points on loops $\\mathcal{C}_1$ and $\\mathcal{C}_2$, respectively, and $\\mathrm{d}\\mathbf{\\ell}_1$, $\\mathrm{d}\\mathbf{\\ell}_2$ are the differential vector line elements along these loops.\n\nTo evaluate this double line integral, we must first parameterize the circular loops. A circle $\\mathcal{C}_i$ in three-dimensional space is specified by its center $\\mathbf{c}_i$, its radius $R_i$, and a unit normal vector to its plane $\\mathbf{n}_i$. To describe points on the circle, it is convenient to establish a local right-handed orthonormal basis $(\\mathbf{u}_i, \\mathbf{v}_i, \\mathbf{n}_i)$, where the vectors $\\mathbf{u}_i$ and $\\mathbf{v}_i$ span the plane containing the circle.\n\nA robust procedure for constructing these basis vectors for a given $\\mathbf{n}_i$ is as follows:\n$1$. Select an auxiliary vector $\\mathbf{t}$ that is not collinear with $\\mathbf{n}_i$. A standard choice is $\\mathbf{t} = (0, 0, 1)$. If $\\mathbf{n}_i$ is parallel to the $z$-axis (i.e., $\\mathbf{n}_i = (0, 0, \\pm 1)$), a different vector, such as $\\mathbf{t} = (1, 0, 0)$, must be used to ensure the cross product is non-zero.\n$2$. The first planar basis vector $\\mathbf{u}_i$ is obtained by computing the cross product of $\\mathbf{n}_i$ and $\\mathbf{t}$ and normalizing the result:\n$$\n\\mathbf{u}_i = \\frac{\\mathbf{n}_i \\times \\mathbf{t}}{\\|\\mathbf{n}_i \\times \\mathbf{t}\\|}\n$$\n$3$. The second planar basis vector $\\mathbf{v}_i$ is then found by the cross product of $\\mathbf{n}_i$ and $\\mathbf{u}_i$, which completes the orthonormal set:\n$$\n\\mathbf{v}_i = \\mathbf{n}_i \\times \\mathbf{u}_i\n$$\nWith this basis, any point $\\mathbf{r}_i$ on the circle $\\mathcal{C}_i$ can be parameterized by an angular variable $\\theta_i \\in [0, 2\\pi]$:\n$$\n\\mathbf{r}_i(\\theta_i) = \\mathbf{c}_i + R_i (\\cos(\\theta_i) \\mathbf{u}_i + \\sin(\\theta_i) \\mathbf{v}_i)\n$$\nThe differential line element $\\mathrm{d}\\boldsymbol{\\ell}_i$ is found by differentiating $\\mathbf{r}_i(\\theta_i)$ with respect to its parameter $\\theta_i$:\n$$\n\\mathrm{d}\\mathbf{\\ell}_i = \\frac{\\mathrm{d}\\mathbf{r}_i}{\\mathrm{d}\\theta_i} \\mathrm{d}\\theta_i = R_i (-\\sin(\\theta_i) \\mathbf{u}_i + \\cos(\\theta_i) \\mathbf{v}_i) \\mathrm{d}\\theta_i\n$$\nBy substituting these expressions for both loops (with indices $1$ and $2$) into the Neumann formula, the double line integral is converted into a double definite integral over the parameters $\\theta_1$ and $\\theta_2$:\n$$\nM = \\frac{\\mu_0}{4\\pi} \\int_{0}^{2\\pi} \\int_{0}^{2\\pi} \\frac{\\left(\\frac{\\mathrm{d}\\mathbf{r}_1(\\theta_1)}{\\mathrm{d}\\theta_1}\\right) \\cdot \\left(\\frac{\\mathrm{d}\\mathbf{r}_2(\\theta_2)}{\\mathrm{d}\\theta_2}\\right)}{\\|\\mathbf{r}_1(\\theta_1) - \\mathbf{r}_2(\\theta_2)\\|} \\mathrm{d}\\theta_1 \\mathrm{d}\\theta_2\n$$\nThe integrand's numerator is the dot product of the two tangent vectors:\n$$\n\\left(\\frac{\\mathrm{d}\\mathbf{r}_1}{\\mathrm{d}\\theta_1}\\right) \\cdot \\left(\\frac{\\mathrm{d}\\mathbf{r}_2}{\\mathrm{d}\\theta_2}\\right) = R_1 R_2 \\left( -\\sin(\\theta_1)\\mathbf{u}_1 + \\cos(\\theta_1)\\mathbf{v}_1 \\right) \\cdot \\left(-\\sin(\\theta_2)\\mathbf{u}_2 + \\cos(\\theta_2)\\mathbf{v}_2 \\right)\n$$\nThe denominator is the magnitude of the vector separating the two points on the loops:\n$$\n\\|\\mathbf{r}_1(\\theta_1) - \\mathbf{r}_2(\\theta_2)\\| = \\|(\\mathbf{c}_1 - \\mathbf{c}_2) + R_1(\\cos(\\theta_1)\\mathbf{u}_1 + \\sin(\\theta_1)\\mathbf{v}_1) - R_2(\\cos(\\theta_2)\\mathbf{u}_2 + \\sin(\\theta_2)\\mathbf{v}_2)\\|\n$$\nThis integral does not generally have a closed-form solution and must be evaluated numerically. The program will implement this computation using a standard numerical quadrature library. The algorithm proceeds as follows for each test case:\n$1$. The loop parameters ($R_i, \\mathbf{c}_i, \\mathbf{n}_i$) are defined. Any provided normal vectors are normalized to ensure they are unit vectors.\n$2$. The orthonormal basis vectors $(\\mathbf{u}_i, \\mathbf{v}_i)$ for each loop are pre-computed.\n$3$. An integrand function is defined, which takes the integration variables $(\\theta_2, \\theta_1)$ and returns the value of the kernel. This argument order aligns with the requirements of numerical integration routines in `scipy`, which evaluate the inner integral first.\n$4$. The double integral over the domain $[0, 2\\pi] \\times [0, 2\\pi]$ is computed using `scipy.integrate.dblquad`. High precision tolerances are set to ensure accuracy, particularly for cases where the loops are in close proximity.\n$5$. The result of the integration is multiplied by the constant factor $\\frac{\\mu_0}{4\\pi} = 10^{-7}$ to yield the final mutual inductance $M$ in units of henries.\n\nThis procedure is systematically applied to all provided test cases, and the results are formatted as specified.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import dblquad\n\ndef solve():\n    \"\"\"\n    Calculates the mutual inductance between two circular loops for several test cases.\n    \"\"\"\n    \n    # Magnetic constant mu_0 / (4*pi) in H/m\n    MU0_OVER_4PI = 1e-7\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: General non-coaxial, non-coplanar, moderate separation\n        {\n            \"R1\": 0.10, \"c1\": (0.00, 0.00, 0.00), \"n1\": (0.0, 0.0, 1.0),\n            \"R2\": 0.08, \"c2\": (0.05, 0.02, 0.03), \"n2\": (1.0, 1.0, 1.0),\n        },\n        # Case 2: Large separation, small coupling\n        {\n            \"R1\": 0.20, \"c1\": (0.20, -0.10, 0.00), \"n1\": (0.0, 1.0, 0.0),\n            \"R2\": 0.15, \"c2\": (1.00, -0.50, 0.80), \"n2\": (0.0, 0.0, 1.0),\n        },\n        # Case 3: Nearly intersecting orientation\n        {\n            \"R1\": 0.10, \"c1\": (0.00, 0.00, 0.00), \"n1\": (0.0, 0.0, 1.0),\n            \"R2\": 0.10, \"c2\": (0.005, 0.00, 0.00), \"n2\": (0.0, 1.0, 0.0),\n        },\n        # Case 4: Arbitrary oblique orientations and offsets\n        {\n            \"R1\": 0.12, \"c1\": (-0.03, 0.04, 0.02), \"n1\": (0.2, 0.9, 0.4),\n            \"R2\": 0.07, \"c2\": (0.06, -0.02, 0.05), \"n2\": (-0.3, 0.1, 0.95),\n        },\n    ]\n\n    results = []\n\n    def setup_loop_basis(n_vec):\n        \"\"\"\n        Given a normal vector n, creates an orthonormal basis (u, v, n).\n        \"\"\"\n        n = np.array(n_vec, dtype=float)\n        n /= np.linalg.norm(n)\n        \n        # Choose an auxiliary vector t not parallel to n\n        if np.abs(np.dot(n, [0.0, 0.0, 1.0])) > 1.0 - 1e-9:\n            # n is parallel to the z-axis, so choose t along the x-axis\n            t = np.array([1.0, 0.0, 0.0])\n        else:\n            # n is not parallel to the z-axis, so choose t along the z-axis\n            t = np.array([0.0, 0.0, 1.0])\n            \n        u = np.cross(n, t)\n        u /= np.linalg.norm(u)\n        \n        v = np.cross(n, u)\n        return u, v\n\n    for case in test_cases:\n        # Unpack parameters\n        R1, c1, n1 = case[\"R1\"], np.array(case[\"c1\"]), np.array(case[\"n1\"])\n        R2, c2, n2 = case[\"R2\"], np.array(case[\"c2\"]), np.array(case[\"n2\"])\n        \n        # Normalize normal vectors\n        n1 /= np.linalg.norm(n1)\n        n2 /= np.linalg.norm(n2)\n        \n        # Setup local coordinate systems for loops\n        u1, v1 = setup_loop_basis(n1)\n        u2, v2 = setup_loop_basis(n2)\n        \n        # Define the integrand for dblquad\n        def integrand(theta2, theta1):\n            # Position vectors on each loop\n            r1 = c1 + R1 * (np.cos(theta1) * u1 + np.sin(theta1) * v1)\n            r2 = c2 + R2 * (np.cos(theta2) * u2 + np.sin(theta2) * v2)\n            \n            # Differential line elements (tangent vectors scaled by R)\n            dl1_dth1 = R1 * (-np.sin(theta1) * u1 + np.cos(theta1) * v1)\n            dl2_dth2 = R2 * (-np.sin(theta2) * u2 + np.cos(theta2) * v2)\n            \n            # Numerator of the Neumann formula kernel\n            numerator = np.dot(dl1_dth1, dl2_dth2)\n            \n            # Denominator of the Neumann formula kernel\n            distance = np.linalg.norm(r1 - r2)\n            \n            # The problem setup ensures distance is never zero\n            return numerator / distance\n\n        # Perform numerical integration over theta1 from 0 to 2*pi and theta2 from 0 to 2*pi\n        integral_val, _ = dblquad(\n            integrand,\n            0, 2 * np.pi,  # Outer integral limits (theta1)\n            0, 2 * np.pi,  # Inner integral limits (theta2)\n            epsabs=1e-12, epsrel=1e-12 # Strict tolerance for high accuracy\n        )\n        \n        mutual_inductance = MU0_OVER_4PI * integral_val\n        results.append(mutual_inductance)\n\n    # Format the final output string as required\n    output_str = f\"[{','.join(f'{r:.15e}' for r in results)}]\"\n    print(output_str)\n\nsolve()\n```", "id": "2419641"}]}