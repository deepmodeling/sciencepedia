{"hands_on_practices": [{"introduction": "The Turing machine is a foundational concept in computer science, representing an abstract model of computation. To truly grasp how these machines operate, there is no substitute for tracing their execution step-by-step. This exercise [@problem_id:93270] invites you to do just that, by calculating the precise number of steps a specific Turing machine takes to process an input string. This will give you a concrete understanding of its mechanical, deterministic process and the notion of computational time.", "problem": "A specific Turing machine is defined by the set of states $Q = \\{q_0, q_1, q_2, q_h\\}$, where $q_0$ is the start state and $q_h$ is the halt state. The tape alphabet is $\\Gamma = \\{0, 1, X, B\\}$, where $B$ is the blank symbol. The machine's behavior is described by the following transition function $\\delta(q, s) = (q', s', d)$, where $q$ is the current state, $s$ is the symbol under the head, $q'$ is the next state, $s'$ is the symbol to be written on the tape, and $d \\in \\{L, R\\}$ is the direction to move the head.\n\nThe transition rules are:\n1.  $\\delta(q_0, 1) = (q_1, X, R)$\n2.  $\\delta(q_0, X) = (q_0, X, R)$\n3.  $\\delta(q_0, 0) = (q_h, 0, R)$\n4.  $\\delta(q_1, 1) = (q_1, 1, R)$\n5.  $\\delta(q_1, 0) = (q_1, 0, R)$\n6.  $\\delta(q_1, B) = (q_2, B, L)$\n7.  $\\delta(q_2, 1) = (q_2, 1, L)$\n8.  $\\delta(q_2, 0) = (q_2, 0, L)$\n9.  $\\delta(q_2, X) = (q_2, X, L)$\n10. $\\delta(q_2, B) = (q_0, B, R)$\n\nThe machine starts on a tape containing the string `1^n01^m` for non-negative integers $n$ and $m$, surrounded by blank symbols. The tape configuration is `... B B 1...1 0 1...1 B B ...`, where `1...1` has length $n$ and `1...1` has length $m$. The head is initially positioned on the leftmost symbol of the input string. If $n>0$, this is the first '1'. If $n=0$, the string is `01^m`, and the head starts on the '0'.\n\nCalculate the total number of steps the Turing machine takes to enter the halt state $q_h$, as a function of the parameters $n$ and $m$.", "solution": "We analyze one “mark‐and‐return” cycle, which repeats once for each of the $n$ initial 1’s, then a final sweep to halt.\n\n1. In state $q_0$, on the $i$th cycle the head starts on the leftmost symbol (position 1) and moves right over $i-1$ X’s then reads the $i$th unmarked 1:\n$$\\text{steps in }q_0 = (i-1)+1 = i.$$\n\n2. Upon marking that 1 to X and entering $q_1$, the head moves right from position $i+1$ to the first blank B at position $n+2+m$, including the B cell:\n$$\\text{steps in }q_1 = (n+2+m)-(i+1)+1 = n+m+2-i.$$\n\n3. Upon reading the B and entering $q_2$, the head moves left from position $n+1+m$ back to the blank B at position 0, including that B:\n$$\\text{steps in }q_2 = (n+1+m)-0+1 = n+m+2.$$\n\n4. Total per cycle (independent of $i$):\n$$i + (n+m+2-i) + (n+m+2) = 2n + 2m + 4.$$\n\n5. Summing over $i=1,\\dots,n$ gives\n$$n(2n+2m+4)=2n^2+2nm+4n.$$\n\n6. After the $n$th cycle, the machine returns to $q_0$ at position 1, skips all $n$ X’s, then reads the 0 and halts. This adds\n$$n + 1$$\nsteps.\n\n7. Total steps:\n$$2n^2 +2nm+4n + (n+1)=2n^2+2nm+5n+1.$$\nOne checks that for $n=0$ the formula gives 1, matching the single‐step halt.\n\nThus the machine halts in\n$$2n^2 +2nm+5n +1$$\nsteps.", "answer": "$$\\boxed{2n^2 + 2nm + 5n + 1}$$", "id": "93270"}, {"introduction": "While Turing machines model sequential computation, Boolean circuits offer a powerful framework for understanding parallel processing. A key measure of a circuit's efficiency is its depth, which corresponds to the time it would take to compute in parallel. In this practice [@problem_id:93272], you will analyze a circuit designed to compute the parity of a bit string, revealing how a tree-like structure can solve a problem in a time that grows only logarithmically with the input size.", "problem": "In the classical theory of computation, a Boolean circuit is a directed acyclic graph that represents a Boolean function. The vertices of the graph are called gates, and the edges represent wires. The vertices with in-degree 0 are the inputs to the circuit, and some specified vertices are the outputs. Each non-input gate represents a Boolean operation, such as AND, OR, NOT, or XOR.\n\nThe depth of a circuit is defined as the length of the longest path from any input vertex to any output vertex. This metric is crucial for understanding the parallel computation time of a function.\n\nConsider the problem of computing the parity of a binary string. The parity of a string $x = x_1x_2...x_n$ is defined as $P(x) = x_1 \\oplus x_2 \\oplus \\dots \\oplus x_n$, where $\\oplus$ denotes the XOR (exclusive OR) operation, equivalent to addition modulo 2.\n\nWe are tasked with designing a circuit to compute the parity of an input string of length $n = 2^k$, where $k$ is a positive integer. The circuit can only use 2-input XOR gates. The design follows a specific cascaded structure:\n1.  The first layer of gates takes pairs of the initial $n$ input bits and computes their XOR.\n2.  Each subsequent layer takes pairs of outputs from the preceding layer and computes their XOR.\n3.  This process continues until a single bit, representing the final parity, is produced.\n\nFind the depth of this parity circuit as a function of $k$.", "solution": "The circuit for computing the parity of an input string of length $n = 2^k$ is constructed by repeatedly applying 2-input XOR gates in layers. The depth is the number of layers required to reduce the input to a single output bit.\n\n- Initially, there are $n = 2^k$ input bits.\n- After the first layer, the number of bits is halved to $n/2 = 2^{k-1}$, as each XOR gate combines two bits.\n- After the second layer, the number of bits is halved again to $2^{k-2}$.\n- This halving continues until a single bit remains.\n\nLet $d$ be the depth. After $d$ layers, the number of bits is $2^{k-d}$. Setting this equal to 1 gives:\n\n$$\n2^{k-d} = 1\n$$\n\nSince $2^0 = 1$, it follows that:\n\n$$\nk - d = 0\n$$\n\nSolving for $d$:\n\n$$\nd = k\n$$\n\nThus, the depth of the circuit is $k$.", "answer": "$$ \\boxed{k} $$", "id": "93272"}, {"introduction": "Having explored Turing machines and Boolean circuits as separate models, we now bridge the gap between them. The \"brain\" of a Turing machine is its transition function, which can be viewed as a finite state controller implementable with digital logic. This exercise [@problem_id:93292] challenges you to design and analyze the logic circuit for a Turing machine's controller, translating its abstract rules into a minimal Boolean formula and revealing the direct connection between these fundamental models of computation.", "problem": "A Turing Machine (TM) is designed to decide the language $L$ of binary strings with an even number of 1s. The language is defined over the alphabet $\\Sigma = \\{0, 1\\}$. The TM's design specifics are as follows:\n\n1.  **States:** The set of non-halting states is $Q = \\{q_{\\text{even}}, q_{\\text{odd}}\\}$, where $q_{\\text{even}}$ is the start state.\n2.  **Tape Alphabet:** The tape alphabet is $\\Gamma = \\{0, 1, B\\}$, where $B$ is the blank symbol.\n3.  **Operation:** The TM starts in state $q_{\\text{even}}$ with its head on the leftmost symbol of the input string. It reads the string from left to right.\n    *   If it reads a `0`, its state does not change.\n    *   If it reads a `1`, its state flips (from $q_{\\text{even}}$ to $q_{\\text{odd}}$ or vice-versa).\n    *   When reading a `0` or `1`, it writes the same symbol back to the tape and moves its head to the right (R).\n    *   When it reads the first blank symbol `B` (signifying the end of the input), it halts. If it halts from state $q_{\\text{even}}$, the input string is accepted. If it halts from state $q_{\\text{odd}}$, the input is rejected. When halting, it writes `B` back to the tape and moves right.\n\nThe transition function of this TM is to be realized as a combinational logic circuit. The inputs and outputs of this circuit are represented by Boolean variables based on a specific encoding scheme:\n\n*   **Inputs:**\n    *   The current non-halting state is encoded by a single bit $s_c$, with $q_{\\text{even}} \\leftrightarrow 0$ and $q_{\\text{odd}} \\leftrightarrow 1$.\n    *   The symbol read from the tape is encoded by two bits $t_1t_0$, with $0 \\leftrightarrow 00$, $1 \\leftrightarrow 01$, and $B \\leftrightarrow 10$. The input bit combination $t_1t_0 = 11$ is assumed to never occur.\n\n*   **Outputs:** The circuit has five output bits:\n    *   $H$: A halt signal. $H=1$ if the machine halts, $H=0$ otherwise.\n    *   $s_n$: The next state bit, encoded like $s_c$. This output is only relevant when $H=0$; if $H=1$, its value is a \"don't care\".\n    *   $t'_1t'_0$: The two bits for the symbol to be written to the tape, using the same encoding as the input symbol.\n    *   $d$: The head move direction. $d=1$ for Right (R) and $d=0$ for Left (L).\n\nYour task is to determine the total size of the logic for this transition function. The size is defined as the total number of literals in the minimal Disjunctive Normal Form (DNF) expressions for all five output functions ($H, s_n, t'_1, t'_0, d$) combined. A literal is a variable or its negation (e.g., the expression $a\\bar{b} \\lor c$ has 3 literals).", "solution": "We index the inputs as bits $s=s_c$, $t_1,t_0$.  We have three real symbol‐classes:  \n(1) $t_1t_0=00$ (‘0’),  \n(2) $t_1t_0=01$ (‘1’),  \n(3) $t_1t_0=10$ (blank, halt).  The case $t_1t_0=11$ is unused.  \n\nTabulating the 6 real input rows, with outputs $(H,s_n,t'_1,t'_0,d)$:\n\n1.  $t=00,s=0$:  read ‘0’ ⇒ stay in even ⇒ $H=0,\\;s_n=0,\\;t'=00,\\;d=1$.  \n2.  $t=00,s=1$:  read ‘0’ ⇒ stay in odd ⇒ $H=0,\\;s_n=1,\\;t'=00,\\;d=1$.  \n3.  $t=01,s=0$:  read ‘1’ ⇒ flip to odd ⇒ $H=0,\\;s_n=1,\\;t'=01,\\;d=1$.  \n4.  $t=01,s=1$:  read ‘1’ ⇒ flip to even⇒ $H=0,\\;s_n=0,\\;t'=01,\\;d=1$.  \n5.  $t=10,s=0$:  blank ⇒ halt in even⇒ $H=1,\\;s_n=\\text{dc},\\;t'=10,\\;d=1$.  \n6.  $t=10,s=1$:  blank ⇒ halt in odd ⇒ $H=1,\\;s_n=\\text{dc},\\;t'=10,\\;d=1$.  \n\nWe may choose the “don’t‐care’’ $s_n$ on blanks to minimize.  Set $s_n=0$ when $t=10$.  \n\nNow derive minimal DNF for each output:\n\n1.  $H=1$ exactly on $t_1t_0=10$.  Thus  \n   \n$$\n     H = t_1\\land\\neg t_0,\n   $$\n  \n   one term, 2 literals.\n\n2.  $d=1$ on all real inputs ⇒ constant 1.  DNF has 0 literals.\n\n3.  $t'_1$ equals 1 exactly when $t_1=1$ (blank), else $0$.  So  \n   \n$$\n     t'_1 = t_1,\n   $$\n  \n   one term, 1 literal.\n\n4.  $t'_0$ equals $t_0$ on all real inputs ⇒  \n   \n$$\n     t'_0 = t_0,\n   $$\n  \n   one term, 1 literal.\n\n5.  $s_n= s$ on $00$ and $s_n=\\neg s$ on $01$, and $0$ on $10$.  Thus\n   \n$$\n     s_n = (\\neg t_1\\land\\neg t_0\\land s)\n           \\;\\lor\\;\n           (\\neg t_1\\land t_0\\land\\neg s).\n   $$\n\n   Two product‐terms each of 3 literals ⇒ 6 literals total.\n\nSumming literals:  $H:2,\\;d:0,\\;t'_1:1,\\;t'_0:1,\\;s_n:6$.  \nTotal size $=2+0+1+1+6=10$.", "answer": "$$\\boxed{10}$$", "id": "93292"}]}