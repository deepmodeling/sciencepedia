{"hands_on_practices": [{"introduction": "The final quantum Fourier transform, implemented as a Hadamard transform on each qubit, is a critical step in Simon's algorithm. It is this operation that consolidates the phase information, acquired from the oracle, into measurement outcomes that reveal the structure of the secret string $s$. This exercise [@problem_id:134091] powerfully demonstrates this principle by replacing the full transform with a partial one, allowing you to see firsthand how this interference step is essential for extracting the hidden information.", "problem": "Simon's algorithm is a quantum algorithm that solves the following problem: Given a function $f: \\{0,1\\}^n \\to \\{0,1\\}^n$, we are promised that there exists a secret binary string $s \\in \\{0,1\\}^n$ such that for any two inputs $x, y \\in \\{0,1\\}^n$, the condition $f(x) = f(y)$ holds if and only if $x \\oplus y = 0^n$ or $x \\oplus y = s$, where $\\oplus$ denotes the bitwise XOR operation and $0^n$ is the string of $n$ zeros. The goal is to find the secret string $s$.\n\nThe algorithm begins with two registers of $n$ qubits each, initialized to $|0\\rangle^{\\otimes n}|0\\rangle^{\\otimes n}$. After applying a Hadamard transform to the first register and then querying the oracle $U_f$ that maps $|x\\rangle|y\\rangle$ to $|x\\rangle|y \\oplus f(x)\\rangle$, the second register is measured. If the outcome of this measurement is some value $z_0$, the state of the first register collapses to:\n$$\n|\\psi\\rangle = \\frac{1}{\\sqrt{2}}(|x_0\\rangle + |x_0 \\oplus s\\rangle)\n$$\nwhere $x_0$ is one of the two preimages of $z_0$ (i.e., $f(x_0) = z_0$). Because the initial state was a uniform superposition over all possible inputs, the pair $\\{x_0, x_0 \\oplus s\\}$ is chosen uniformly at random from the $2^{n-1}$ possible pairs that partition the input space $\\{0,1\\}^n$.\n\nConsider a modified version of Simon's algorithm for $n=3$ qubits in the first register. The secret string is known to be $s=100$. After the state of the first register collapses to $|\\psi\\rangle$ as described above, instead of applying the standard Hadamard transform $H^{\\otimes 3}$ to this register, we apply the unitary operator $U = H \\otimes I \\otimes I$, where $H$ is the single-qubit Hadamard gate and $I$ is the single-qubit identity gate.\n\nCalculate the probability of measuring the output state $y=011$ from the first register after the application of the unitary $U$.", "solution": "We have the post‐measurement state in the first register\n$$\n|\\psi\\rangle \\;=\\;\\frac{1}{\\sqrt{2}}\\bigl(|x_0\\rangle+|x_0\\oplus s\\rangle\\bigr)\n$$\nwith $s=100$.  Since the cosets are $\\{0x_1x_2,1x_1x_2\\}$, we may write \n$$\nx_0=(0,x_1,x_2), \n\\qquad\nx_0\\oplus s=(1,x_1,x_2),\n$$\nso\n$$\n|\\psi\\rangle\n=\\frac{1}{\\sqrt{2}}\\bigl(|0\\,x_1x_2\\rangle+|1\\,x_1x_2\\rangle\\bigr).\n$$\nApply $U=H\\otimes I\\otimes I$.  Using\n$$\nH|0\\rangle=\\frac{|0\\rangle+|1\\rangle}{\\sqrt{2}}, \n\\quad\nH|1\\rangle=\\frac{|0\\rangle-|1\\rangle}{\\sqrt{2}},\n$$\nwe get\n\\begin{align*}\nU|\\psi\\rangle\n&=\\frac{1}{\\sqrt{2}}\\Bigl(H|0\\rangle\\otimes|x_1x_2\\rangle+H|1\\rangle\\otimes|x_1x_2\\rangle\\Bigr)\\\\\n&=\\frac{1}{\\sqrt{2}}\\Bigl(\\frac{|0\\rangle+|1\\rangle}{\\sqrt{2}}+\\frac{|0\\rangle-|1\\rangle}{\\sqrt{2}}\\Bigr)\\otimes|x_1x_2\\rangle\\\\\n&=\\frac{1}{2}\\bigl(2\\,|0\\rangle\\bigr)\\otimes|x_1x_2\\rangle\n=|0\\,x_1x_2\\rangle.\n\\end{align*}\nThus the measurement outcome is deterministically $y=(0,x_1,x_2)$.  Since $(x_1,x_2)$ is uniform over the four bit‐pairs, \n$$\n\\Pr[y=011]\n=\\Pr[(0,x_1,x_2)=(0,1,1)]\n=\\frac{1}{4}.\n$$", "answer": "$$\\boxed{\\frac{1}{4}}$$", "id": "134091"}, {"introduction": "Simon's algorithm derives its exponential speedup from a specific promise about the function $f$: that it is exactly two-to-one, mapping inputs $x$ and $x \\oplus s$ to the same output. This practice problem [@problem_id:134055] explores the consequences of a plausible hardware fault—a miswired CNOT gate—that violates this promise by transforming the intended function into a permutation. Analyzing this scenario highlights the crucial dependence of the algorithm's success on the integrity of the oracle's implementation.", "problem": "Simon's algorithm is a quantum algorithm designed to find a hidden period $s$ of a function $f: \\{0,1\\}^n \\to \\{0,1\\}^n$. The function is promised to be such that $f(x) = f(y)$ if and only if $y = x \\oplus s$ for a secret non-zero bitstring $s \\in \\{0,1\\}^n$, or $f$ is one-to-one (in which case $s$ is the zero string). The algorithm operates on two registers of $n$ qubits each, initially in the state $|0\\rangle^{\\otimes n}|0\\rangle^{\\otimes n}$. After applying a Hadamard transform to the first register, a quantum oracle $U_f$ implementing the map $|x\\rangle|y\\rangle \\to |x\\rangle|y \\oplus f(x)\\rangle$ is applied. A final Hadamard transform on the first register is followed by a measurement of that register. This process is repeated to find $s$.\n\nConsider a specific implementation for $n=3$ designed to solve a problem with a hidden string $s=110$. The intended oracle $U_f$ was constructed using a set of CNOT gates. The mapping from the input register (control qubits `x_2, x_1, x_0`) to the output register (target qubits `y_2, y_1, y_0`) was intended to be implemented by the following sequence of gates:\n1.  A CNOT with control `x_0` and target `y_0`.\n2.  A CNOT with control `x_1` and target `y_1`.\n3.  A CNOT with control `x_2` and target `y_1`.\n\nThis set of gates correctly implements a function $f(x)$ with the period $s=110$. However, due to a manufacturing defect, the target of the third CNOT gate was miswired. Instead of targeting `y_1`, it targets `y_2`. This error has the effect of mapping the intended function $f$ to a new function $f'$ which is a permutation.\n\nThe Simon's algorithm circuit is run using this faulty oracle $U_{f'}$. What is the total probability that a measurement of the first register yields a bitstring $y$ that satisfies the condition $y \\cdot s = 0 \\pmod 2$, where $s = 110$ is the original intended hidden string?", "solution": "1. After the defective oracle, the mapping is \n   $f'(x_2,x_1,x_0) = (x_2, x_1, x_0)$,\n   which is a bijection on 3‐bit strings.  \n\n2. In Simon’s algorithm one measures the second register immediately after applying $U_{f'}$,  \n   collapsing the first register to $|x\\rangle$ for a uniformly random $x\\in\\{0,1\\}^3$.  A Hadamard $H^{\\otimes 3}$ then gives\n   $$\n     H^{\\otimes3}|x\\rangle \\;=\\;\\frac1{\\sqrt{8}}\\sum_{y\\in\\{0,1\\}^3}(-1)^{x\\cdot y}\\,|y\\rangle,\n   $$\n   so the probability of observing any given $y$ is $1/8$.  \n\n3. We seek  \n   $$\n     P\\bigl(y\\cdot s=0\\bigr)\n     \\;=\\;\\frac{\\bigl|\\{\\,y: y\\cdot(1,1,0)=0\\bigr\\}\\bigr|}{8}\n     \\;=\\;\\frac{4}{8}\n     \\;=\\;\\frac12.\n   $$\n   Here there are 4 of the 8 strings $y$ satisfying $y_2+y_1\\equiv0 \\pmod 2$.", "answer": "$$\\boxed{\\frac12}$$", "id": "134055"}, {"introduction": "The output of Simon's algorithm is not the secret string $s$ itself, but rather a set of random vectors that are orthogonal to $s$. A crucial part of the process is the classical post-processing required to deduce $s$ from this data. This exercise [@problem_id:134190] bridges the gap between quantum computation and classical statistical analysis by applying Bayesian inference to update our belief about the secret string in light of measurement outcomes, a key skill for interpreting the probabilistic results of any quantum experiment.", "problem": "Simon's algorithm is a quantum algorithm designed to find a secret string $s \\in \\{0, 1\\}^n$. The algorithm is given access to an oracle for a function $f: \\{0, 1\\}^n \\to \\{0, 1\\}^n$. The function $f$ is promised to satisfy the property that for any $x, y \\in \\{0, 1\\}^n$, $f(x) = f(y)$ if and only if $y = x \\oplus s$, where $\\oplus$ denotes bitwise XOR. The string $s$ is fixed for a given $f$. If $s = 0^n$ (the string of all zeros), the function is a permutation (1-to-1). If $s \\neq 0^n$, the function is 2-to-1.\n\nA single run of the quantum part of Simon's algorithm produces a random $n$-bit string, which we denote as a vector $y \\in \\mathbb{F}_2^n$. The probability distribution of the outcome $y$ depends on the secret string $s$ as follows:\n- If $s = 0^n$, any string $y \\in \\{0, 1\\}^n$ is produced with uniform probability $P(y|s=0^n) = 1/2^n$.\n- If $s \\neq 0^n$, a string $y$ is produced only if it is orthogonal to $s$ under the dot product modulo 2, i.e., $s \\cdot y = \\sum_{i=1}^n s_i y_i \\equiv 0 \\pmod 2$. Any such string $y$ is produced with uniform probability $P(y|s) = 1/2^{n-1}$. Strings $y$ for which $s \\cdot y \\not\\equiv 0 \\pmod 2$ have zero probability of being observed.\n\nSuppose you hold a prior belief about the secret string $s$. You believe that $s=0^n$ with probability $p$, and all $2^n-1$ non-zero strings are equally likely. You perform $k$ independent runs of the algorithm, obtaining $k$ measurement outcomes $y_1, y_2, \\ldots, y_k$ which are found to be linearly independent over the field $\\mathbb{F}_2$.\n\nGiven a specific non-zero string $s_0$ that is consistent with all $k$ measurement outcomes (i.e., $s_0 \\cdot y_i = 0 \\pmod 2$ for all $i=1, \\ldots, k$), calculate the Bayesian posterior probability that the secret string is $s_0$.", "solution": "Let $S$ be the random variable for the secret string, and $E$ be the event of observing the sequence of $k$ linearly independent outcomes $y_1, \\ldots, y_k$. We want to compute the posterior probability $P(S=s_0 | E)$ for a given non-zero string $s_0$ that satisfies $s_0 \\cdot y_i = 0 \\pmod 2$ for all $i \\in \\{1, \\ldots, k\\}$.\n\nWe use Bayes' theorem:\n$$\nP(S=s_0 | E) = \\frac{P(E | S=s_0) P(S=s_0)}{P(E)}\n$$\n\nFirst, let's establish the prior probability distribution $P(S=s)$.\nWe are given $P(S=0^n) = p$.\nThe total probability must sum to 1. Since all non-zero strings are considered equally likely, we have:\n$$\np + \\sum_{s \\neq 0^n} P(S=s) = 1\n$$\nLet $P(S=s) = q$ for any $s \\neq 0^n$. There are $2^n-1$ such strings.\n$$\np + (2^n-1)q = 1 \\implies q = \\frac{1-p}{2^n-1}\n$$\nSo, the prior for the specific non-zero string $s_0$ is:\n$$\nP(S=s_0) = \\frac{1-p}{2^n-1}\n$$\n\nNext, we determine the likelihood $P(E | S=s)$ for any given $s$. The runs are independent, so the joint probability is the product of the individual probabilities.\n$$\nP(E | S=s) = P(y_1, \\ldots, y_k | S=s) = \\prod_{i=1}^k P(y_i | S=s)\n$$\nCase 1: $s = 0^n$.\nThe probability of observing any string $y_i$ is $1/2^n$.\n$$\nP(E | S=0^n) = \\prod_{i=1}^k \\frac{1}{2^n} = \\left(\\frac{1}{2^n}\\right)^k = \\frac{1}{2^{nk}}\n$$\nCase 2: $s \\neq 0^n$.\nThe probability of observing $y_i$ is $1/2^{n-1}$ if $s \\cdot y_i = 0 \\pmod 2$, and $0$ otherwise.\nFor the event $E$ to have a non-zero probability, we must have $s \\cdot y_i = 0 \\pmod 2$ for all $i=1, \\ldots, k$. If this condition is met, the likelihood is:\n$$\nP(E | S=s) = \\prod_{i=1}^k \\frac{1}{2^{n-1}} = \\left(\\frac{1}{2^{n-1}}\\right)^k = \\frac{1}{2^{k(n-1)}}\n$$\nSince we are given that $s_0$ is consistent with the outcomes, we have:\n$$\nP(E | S=s_0) = \\frac{1}{2^{k(n-1)}}\n$$\n\nNow we compute the marginal probability of the evidence, $P(E)$, by summing over all possible secret strings:\n$$\nP(E) = P(E|S=0^n)P(S=0^n) + \\sum_{s \\neq 0^n} P(E|S=s)P(S=s)\n$$\nThe sum over non-zero $s$ can be split into strings compatible with the evidence and those that are not. Let $V = \\text{span}\\{y_1, \\ldots, y_k\\}$. A string $s$ is compatible if $s \\in V^\\perp$, where $V^\\perp = \\{s \\in \\mathbb{F}_2^n | s \\cdot v = 0 \\text{ for all } v \\in V\\}$.\nSince $y_1, \\ldots, y_k$ are linearly independent, the dimension of $V$ is $k$. The dimension of the orthogonal complement $V^\\perp$ is $n-k$. Thus, there are $2^{n-k}$ vectors in $V^\\perp$. One of these is $0^n$, so there are $2^{n-k}-1$ non-zero compatible strings.\nFor any $s \\in V^\\perp \\setminus \\{0^n\\}$, $P(E|S=s) = 1/2^{k(n-1)}$. For any $s \\notin V^\\perp$, $P(E|S=s) = 0$.\n$$\nP(E) = p \\cdot \\frac{1}{2^{nk}} + \\sum_{s \\in V^\\perp \\setminus \\{0^n\\}} \\left(\\frac{1}{2^{k(n-1)}}\\right) \\left(\\frac{1-p}{2^n-1}\\right)\n$$\nThe sum has $2^{n-k}-1$ identical terms:\n$$\nP(E) = \\frac{p}{2^{nk}} + (2^{n-k}-1) \\frac{1}{2^{k(n-1)}} \\frac{1-p}{2^n-1}\n$$\n\nFinally, we substitute the pieces into Bayes' theorem:\n$$\nP(S=s_0 | E) = \\frac{P(E | S=s_0) P(S=s_0)}{P(E)} = \\frac{\\frac{1}{2^{k(n-1)}} \\frac{1-p}{2^n-1}}{\\frac{p}{2^{nk}} + (2^{n-k}-1) \\frac{1}{2^{k(n-1)}} \\frac{1-p}{2^n-1}}\n$$\nTo simplify this expression, we can multiply the numerator and denominator by $2^{nk}$:\n$$\nP(S=s_0 | E) = \\frac{2^{nk} \\cdot \\frac{1}{2^{k(n-1)}} \\frac{1-p}{2^n-1}}{2^{nk} \\cdot \\frac{p}{2^{nk}} + 2^{nk} \\cdot (2^{n-k}-1) \\frac{1}{2^{k(n-1)}} \\frac{1-p}{2^n-1}}\n$$\nThe term $2^{nk}/2^{k(n-1)} = 2^{nk - k(n-1)} = 2^{nk - nk + k} = 2^k$.\n$$\nP(S=s_0 | E) = \\frac{2^k \\frac{1-p}{2^n-1}}{p + 2^k (2^{n-k}-1) \\frac{1-p}{2^n-1}}\n$$\nMultiplying the numerator and denominator by $(2^n-1)$ gives the final simplified expression:\n$$\nP(S=s_0 | E) = \\frac{2^k (1-p)}{p(2^n-1) + 2^k (2^{n-k}-1) (1-p)}\n$$", "answer": "$$\n\\boxed{\\frac{2^k (1-p)}{p(2^n-1) + 2^k (2^{n-k}-1) (1-p)}}\n$$", "id": "134190"}]}