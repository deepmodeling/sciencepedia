{"hands_on_practices": [{"introduction": "The Deutsch-Jozsa algorithm's remarkable efficiency hinges on the specific initial state, $|0\\rangle^{\\otimes n}|1\\rangle$, which allows for the creation of a uniform superposition across all possible inputs. This exercise challenges that foundational assumption by replacing the initial state with the highly entangled W-state. By analyzing this scenario ([@problem_id:151503]), you will gain a deeper appreciation for how the algorithm's delicate interference pattern, and thus its success, is critically dependent on the structure of the initial superposition.", "problem": "Consider the Deutsch-Jozsa algorithm designed to determine a property of a Boolean function $f: \\{0,1\\}^n \\to \\{0,1\\}$. The quantum circuit for this algorithm operates on an $(n+1)$-qubit register. The first $n$ qubits constitute the input register, and the final qubit is the ancillary register.\n\nThe standard execution of the algorithm commences with the initial state $|0\\rangle^{\\otimes n}|1\\rangle$. However, imagine a scenario where a systematic error in the state preparation leads to the system being initialized in the $(n+1)$-qubit W-state instead. The W-state is an equal superposition of all computational basis states with a Hamming weight of one:\n$$ |W_{n+1}\\rangle = \\frac{1}{\\sqrt{n+1}} \\sum_{k=0}^{n} \\left(\\bigotimes_{j=0}^{k-1}|0\\rangle_j\\right) \\otimes |1\\rangle_k \\otimes \\left(\\bigotimes_{j=k+1}^{n}|0\\rangle_j\\right) $$\nThe qubits are indexed from $0$ to $n$. Qubits $0, \\dots, n-1$ form the input register, and qubit $n$ is the ancillary register.\n\nThe Deutsch-Jozsa circuit is then applied to this initial state $|W_{n+1}\\rangle$. The sequence of operations is as follows:\n1. Apply a Hadamard gate, $H$, to each of the $n+1$ qubits.\n2. Apply the oracle unitary operator, $U_f$, defined by its action on computational basis states: $U_f|x\\rangle|y\\rangle = |x\\rangle|y \\oplus f(x)\\rangle$, where $x \\in \\{0,1\\}^n$ and $y \\in \\{0,1\\}$.\n3. Apply a Hadamard gate, $H$, to each of the first $n$ qubits (the input register).\n\nAfter the circuit has been applied, the first $n$ qubits are measured in the computational basis. Assume the function $f$ is a constant function, meaning $f(x)=c$ for all $x \\in \\{0,1\\}^n$, where $c$ is either $0$ or $1$.\n\nCalculate the probability of measuring the all-zero state, $|0\\rangle^{\\otimes n}$, in the input register.", "solution": "The initial state is the $(n+1)$-qubit W-state:\n\n$$\n|W_{n+1}\\rangle = \\frac{1}{\\sqrt{n+1}} \\sum_{k=0}^{n} \\left( \\bigotimes_{j=0}^{k-1} |0\\rangle_j \\right) \\otimes |1\\rangle_k \\otimes \\left( \\bigotimes_{j=k+1}^{n} |0\\rangle_j \\right)\n$$\n\nwhere qubits $0$ to $n-1$ are the input register and qubit $n$ is the ancillary register.\n\n**Step 1: Apply Hadamard gates to all $n+1$ qubits.**\nThe action of $H^{\\otimes (n+1)}$ on a basis state $|\\psi_k\\rangle$ (with qubit $k$ in $|1\\rangle$ and others in $|0\\rangle$) is:\n\n$$\nH^{\\otimes (n+1)} |\\psi_k\\rangle = \\frac{1}{\\sqrt{2^{n+1}}} \\sum_{z \\in \\{0,1\\}^{n+1}} (-1)^{z_k} |z\\rangle\n$$\n\nThus, the state after Hadamard gates is:\n\n$$\n|\\phi_1\\rangle = H^{\\otimes (n+1)} |W_{n+1}\\rangle = \\frac{1}{\\sqrt{(n+1) 2^{n+1}}} \\sum_{z \\in \\{0,1\\}^{n+1}} \\left( \\sum_{k=0}^{n} (-1)^{z_k} \\right) |z\\rangle\n$$\n\nExpressing $z = (x, y)$ where $x \\in \\{0,1\\}^n$ (input register) and $y \\in \\{0,1\\}$ (ancillary register):\n\n$$\n|\\phi_1\\rangle = \\frac{1}{\\sqrt{(n+1) 2^{n+1}}} \\sum_{x \\in \\{0,1\\}^n} \\sum_{y \\in \\{0,1\\}} \\left( \\sum_{k=0}^{n-1} (-1)^{x_k} + (-1)^y \\right) |x, y\\rangle\n$$\n\n\n**Step 2: Apply the oracle $U_f$.**\nGiven $f$ is constant, $f(x) = c$ for all $x$, with $c \\in \\{0,1\\}$. The oracle acts as:\n\n$$\nU_f |x, y\\rangle = |x, y \\oplus c\\rangle\n$$\n\nApplying $U_f$ to $|\\phi_1\\rangle$:\n\n$$\n|\\phi_2\\rangle = U_f |\\phi_1\\rangle = \\frac{1}{\\sqrt{(n+1) 2^{n+1}}} \\sum_{x,y} \\left( \\sum_{k=0}^{n-1} (-1)^{x_k} + (-1)^y \\right) |x, y \\oplus c\\rangle\n$$\n\nSubstituting $y' = y \\oplus c$ (and relabeling $y'$ to $y$):\n\n$$\n|\\phi_2\\rangle = \\frac{1}{\\sqrt{(n+1) 2^{n+1}}} \\sum_{x,y} \\left( \\sum_{k=0}^{n-1} (-1)^{x_k} + (-1)^{y \\oplus c} \\right) |x, y\\rangle\n$$\n\nUsing $(-1)^{y \\oplus c} = (-1)^c (-1)^y$:\n\n$$\n|\\phi_2\\rangle = \\frac{1}{\\sqrt{(n+1) 2^{n+1}}} \\sum_{x,y} \\left( \\sum_{k=0}^{n-1} (-1)^{x_k} + (-1)^c (-1)^y \\right) |x, y\\rangle\n$$\n\n\n**Step 3: Apply Hadamard gates to the first $n$ qubits.**\nThe operator is $H^{\\otimes n} \\otimes I$ on the input and ancillary registers. The action on a basis state is:\n\n$$\n(H^{\\otimes n} \\otimes I) |x, y\\rangle = \\frac{1}{\\sqrt{2^n}} \\sum_{u \\in \\{0,1\\}^n} (-1)^{u \\cdot x} |u, y\\rangle\n$$\n\nApplying to $|\\phi_2\\rangle$:\n\n$$\n|\\phi_3\\rangle = \\frac{1}{\\sqrt{(n+1) 2^{n+1}}} \\frac{1}{\\sqrt{2^n}} \\sum_{x,y} \\left( \\sum_{k=0}^{n-1} (-1)^{x_k} + (-1)^c (-1)^y \\right) \\sum_{u} (-1)^{u \\cdot x} |u, y\\rangle\n$$\n\nSimplifying the constant:\n\n$$\n|\\phi_3\\rangle = \\frac{1}{\\sqrt{(n+1) 2^{2n+1}}} \\sum_{u,y} \\sum_{x} \\left( \\sum_{k=0}^{n-1} (-1)^{x_k} + (-1)^c (-1)^y \\right) (-1)^{u \\cdot x} |u, y\\rangle\n$$\n\n\n**Probability of measuring $|0\\rangle^{\\otimes n}$ in input register.**\nThe amplitude for $|u = 0^n, y\\rangle$ is:\n\n$$\nA(0^n, y) = \\frac{1}{\\sqrt{(n+1) 2^{2n+1}}} \\sum_{x} \\left( \\sum_{k=0}^{n-1} (-1)^{x_k} + (-1)^c (-1)^y \\right) (-1)^{0 \\cdot x}\n$$\n\nSince $(-1)^{0 \\cdot x} = 1$:\n\n$$\nA(0^n, y) = \\frac{1}{\\sqrt{(n+1) 2^{2n+1}}} \\sum_{x} \\left( \\sum_{k=0}^{n-1} (-1)^{x_k} + (-1)^c (-1)^y \\right)\n$$\n\nSplit the sum:\n\n$$\n\\sum_{x} \\sum_{k=0}^{n-1} (-1)^{x_k} = \\sum_{k=0}^{n-1} \\sum_{x} (-1)^{x_k}\n$$\n\nFor each $k$, $\\sum_{x} (-1)^{x_k} = 0$ (since half the terms are $+1$ and half are $-1$), so:\n\n$$\n\\sum_{x} \\sum_{k=0}^{n-1} (-1)^{x_k} = 0\n$$\n\nThe remaining term:\n\n$$\n\\sum_{x} (-1)^c (-1)^y = (-1)^c (-1)^y \\sum_{x} 1 = (-1)^c (-1)^y \\cdot 2^n\n$$\n\nThus:\n\n$$\nA(0^n, y) = \\frac{1}{\\sqrt{(n+1) 2^{2n+1}}} (-1)^c (-1)^y 2^n = (-1)^c (-1)^y \\frac{2^n}{\\sqrt{(n+1) 2^{2n+1}}}\n$$\n\nSimplify:\n\n$$\n\\frac{2^n}{\\sqrt{(n+1) 2^{2n+1}}} = \\frac{2^n}{\\sqrt{(n+1)} \\cdot 2^n \\sqrt{2}} = \\frac{1}{\\sqrt{2(n+1)}}\n$$\n\nSo:\n\n$$\nA(0^n, y) = (-1)^c (-1)^y \\frac{1}{\\sqrt{2(n+1)}}\n$$\n\nThe magnitude squared for each $y$ is:\n\n$$\n|A(0^n, y)|^2 = \\left| (-1)^c (-1)^y \\frac{1}{\\sqrt{2(n+1)}} \\right|^2 = \\frac{1}{2(n+1)}\n$$\n\nThe total probability for measuring $|0\\rangle^{\\otimes n}$ in the input register (summing over $y$):\n\n$$\nP(|0\\rangle^{\\otimes n}) = |A(0^n, 0)|^2 + |A(0^n, 1)|^2 = \\frac{1}{2(n+1)} + \\frac{1}{2(n+1)} = \\frac{1}{n+1}\n$$\n\nThis probability is independent of the constant $c$.", "answer": "$$ \\boxed{\\dfrac{1}{n+1}} $$", "id": "151503"}, {"introduction": "In physical quantum computers, qubits rarely evolve in perfect isolation; unwanted interactions, or \"crosstalk,\" between them are a common source of coherent errors. This practice introduces a realistic error model in the form of a parasitic $ZZ$ interaction that occurs between adjacent qubits of the input register during the oracle query. Working through this problem ([@problem_id:151393]) provides valuable experience in analyzing coherent error models and demonstrates how such imperfections can systematically degrade the certainty of a quantum algorithm's output.", "problem": "The Deutsch-Jozsa algorithm determines whether a function $f: \\{0, 1\\}^n \\to \\{0, 1\\}$ is constant or balanced, with the promise that it is one of the two. The algorithm uses an $n$-qubit input register and a single-qubit ancillary register.\n\nThe standard algorithm proceeds as follows:\n1.  Initialize the state to $|0\\rangle^{\\otimes n} |1\\rangle$.\n2.  Apply a Hadamard gate $H$ to each qubit, preparing the state $\\frac{1}{\\sqrt{2^n}} \\sum_{x \\in \\{0,1\\}^n} |x\\rangle \\otimes \\frac{1}{\\sqrt{2}}(|0\\rangle - |1\\rangle)$.\n3.  Apply the oracle query $U_f$, which maps $|x\\rangle|y\\rangle \\to |x\\rangle|y \\oplus f(x)\\rangle$. The action on the prepared state induces a phase kickback, transforming the state of the input register to $\\frac{1}{\\sqrt{2^n}} \\sum_{x \\in \\{0,1\\}^n} (-1)^{f(x)} |x\\rangle$. The ancillary qubit remains in the state $\\frac{1}{\\sqrt{2}}(|0\\rangle - |1\\rangle)$ and can be ignored henceforth.\n4.  Apply a Hadamard gate $H$ to each qubit of the input register.\n5.  Measure the input register in the computational basis. If the result is $|0\\rangle^{\\otimes n}$, the function is declared constant. Otherwise, it is declared balanced. For an ideal oracle, this determination is always correct.\n\nConsider a practical implementation where the $n$ qubits of the input register are arranged in a 1D chain. During the oracle application step, a parasitic ZZ crosstalk interaction occurs between adjacent qubits. This coherent error can be modeled by a unitary operator $U_{err}$ that acts on the input register immediately after the ideal oracle $U_f$. The total transformation during the oracle step is thus $U_{err} U_f$.\n\nThe error operator is given by:\n$$\nU_{err} = \\exp\\left(-i \\theta \\sum_{j=1}^{n-1} Z_j Z_{j+1}\\right)\n$$\nwhere $Z_j$ is the Pauli-Z operator acting on the $j$-th qubit and $\\theta$ is a real, dimensionless parameter characterizing the strength of the parasitic interaction.\n\nAssuming the function $f$ is constant, calculate the probability, $P_{success}$, that the algorithm correctly identifies it as such (i.e., the final measurement of the input register yields the $|0\\rangle^{\\otimes n}$ state).", "solution": "1. After the ideal oracle for a constant function $f(x)=0$, the input register is in the state $|\\psi_1\\rangle = |+\\rangle^{\\otimes n}$. For a general constant function $f(x)=c$, there is an overall phase of $(-1)^c$ which does not affect the final probability.\n\n2. The coherent-error unitary is $U_{err} = \\exp\\left(-i\\theta\\sum_{j=1}^{n-1}Z_jZ_{j+1}\\right)$.\n\n3. The amplitude of measuring $|0\\rangle^{\\otimes n}$ after the final Hadamard layer is $A = \\langle 0|^{\\otimes n} H^{\\otimes n} U_{err} |+\\rangle^{\\otimes n}$.\n\n4. We can rewrite this amplitude using the identities $H^{\\otimes n} Z_jZ_{j+1} H^{\\otimes n}=X_jX_{j+1}$ and $H^{\\otimes n}|+\\rangle^{\\otimes n}=|0\\rangle^{\\otimes n}$. By inserting an identity $I = H^{\\otimes n}H^{\\otimes n}$, the expression for $A$ becomes:\n$$\nA = \\langle 0|^{\\otimes n} (H^{\\otimes n} U_{err} H^{\\otimes n}) (H^{\\otimes n}|+\\rangle^{\\otimes n}) = \\langle 0|^{\\otimes n} \\exp\\left(-i\\theta\\sum_j X_jX_{j+1}\\right) |0\\rangle^{\\otimes n}\n$$\n\n5. Since all terms $Z_jZ_{j+1}$ in the sum commute, the corresponding terms $X_jX_{j+1}$ also commute. This allows the exponential to be factored:\n$$\n\\exp\\left(-i\\theta\\sum_{j=1}^{n-1}X_jX_{j+1}\\right) = \\prod_{j=1}^{n-1}(\\cos\\theta\\,I - i\\sin\\theta\\,X_jX_{j+1})\n$$\nWhen taking the expectation value of this operator with respect to $|0\\rangle^{\\otimes n}$, any term in the expansion containing an $X_jX_{j+1}$ operator results in zero because it maps $|0\\rangle^{\\otimes n}$ to an orthogonal state. The only contribution comes from taking the $\\cos\\theta\\,I$ part from each factor.\n\n6. Thus, the amplitude is $A = (\\cos\\theta)^{n-1}$, and the success probability is $P_{success} = |A|^2 = \\cos^{2(n-1)}\\theta$.", "answer": "$$\\boxed{\\cos^{2(n-1)}\\theta}$$", "id": "151393"}, {"introduction": "Beyond coherent errors, quantum systems are also subject to incoherent noise from environmental interactions, a situation best described using the density matrix formalism. This exercise explores a scenario where the ancilla qubit is imperfectly prepared in a mixed state, described by $\\rho = (1-p) |1\\rangle\\langle 1| + p |0\\rangle\\langle 0|$, instead of the ideal pure state $|1\\rangle$. This practice ([@problem_id:151531]) serves as an essential introduction to analyzing the effects of decoherence on quantum algorithms, testing your understanding of the phase kickback mechanism's vulnerability to noise.", "problem": "The Deutsch-Jozsa algorithm provides a method for determining a property of a function $f: \\{0,1\\}^n \\to \\{0,1\\}$. The function is guaranteed to be either *constant* (the output is the same for all inputs) or *balanced* (the output is 0 for exactly half of the inputs and 1 for the other half).\n\nThe standard algorithm utilizes a quantum circuit with $n$ input qubits and one target (or ancilla) qubit. The initial state is $|0\\rangle^{\\otimes n}|1\\rangle$. The circuit applies a sequence of gates:\n1. A Hadamard gate on each of the $n+1$ qubits.\n2. The function oracle $U_f$, which performs the transformation $|x\\rangle|y\\rangle \\mapsto |x\\rangle|y \\oplus f(x)\\rangle$.\n3. A Hadamard gate on each of the first $n$ input qubits.\n\nFinally, the first $n$ qubits are measured in the computational basis. If the result is the all-zero state $|0\\rangle^{\\otimes n}$, the function is declared constant. If any other result is obtained, the function is declared balanced. In its ideal form, the algorithm is deterministic and always gives the correct answer.\n\nConsider a modification to this procedure where the state preparation of the target qubit is imperfect. The $n$ input qubits are correctly prepared in the state $|0\\rangle^{\\otimes n}$. However, the target qubit is prepared in the mixed state described by the density operator:\n$$\n\\rho_{\\text{target}} = (1-p) |1\\rangle\\langle 1| + p |0\\rangle\\langle 0|\n$$\nwhere $p \\in [0, 1]$ is a parameter characterizing the preparation error.\n\nThe rest of the algorithm (steps 1-3 and the final measurement rule) proceeds as described above. Assume that the function $f$ is known to be a balanced function. Calculate the probability of the algorithm correctly identifying it as balanced.", "solution": "The algorithm correctly identifies the function as balanced if the measurement of the first $n$ qubits is not the all-zero state $|0\\rangle^{\\otimes n}$. The initial state of the system is a mixed state, which can be analyzed as a statistical mixture of two pure-state scenarios. The initial density matrix is $\\rho_{in} = |0\\rangle\\langle 0|^{\\otimes n} \\otimes \\rho_{\\text{target}}$.\n\nWe can think of this as two independent cases:\n- **Scenario A (with probability $1-p$):** The initial state is $|0\\rangle^{\\otimes n}|1\\rangle$. This is the standard, ideal setup for the Deutsch-Jozsa algorithm. For a balanced function, the algorithm is designed such that the final state of the input register is orthogonal to $|0\\rangle^{\\otimes n}$. Therefore, the probability of measuring $|0\\rangle^{\\otimes n}$ is exactly 0 in this case.\n\n- **Scenario B (with probability $p$):** The initial state is $|0\\rangle^{\\otimes n}|0\\rangle$.\n    1. After applying Hadamard gates to all qubits, the state becomes $\\left( \\frac{1}{\\sqrt{2^n}}\\sum_x |x\\rangle \\right) \\otimes |+\\rangle$, where $|+\\rangle = \\frac{1}{\\sqrt{2}}(|0\\rangle+|1\\rangle)$.\n    2. The oracle $U_f$ acts on a component $|x\\rangle|+\\rangle$ as:\n       $$ U_f |x\\rangle|+\\rangle = U_f |x\\rangle \\frac{|0\\rangle+|1\\rangle}{\\sqrt{2}} = |x\\rangle \\frac{|f(x)\\rangle + |1\\oplus f(x)\\rangle}{\\sqrt{2}} $$\n       Since $f(x)$ is either 0 or 1, the set $\\{f(x), 1 \\oplus f(x)\\}$ is always $\\{0, 1\\}$. Thus, $|f(x)\\rangle + |1\\oplus f(x)\\rangle = |0\\rangle + |1\\rangle$, and the state is unchanged: $U_f |x\\rangle|+\\rangle = |x\\rangle|+\\rangle$. The oracle has no effect on the state.\n    3. The final Hadamard gates are applied to the input register. The state of the input register before this step is $\\frac{1}{\\sqrt{2^n}}\\sum_x |x\\rangle = |+\\rangle^{\\otimes n}$. Applying $H^{\\otimes n}$ yields $H^{\\otimes n}|+\\rangle^{\\otimes n} = |0\\rangle^{\\otimes n}$.\n    4. Therefore, in this scenario, the final measurement of the input register yields $|0\\rangle^{\\otimes n}$ with probability 1.\n\nThe total probability of measuring $|0\\rangle^{\\otimes n}$ is the weighted average of the probabilities from the two scenarios:\n$$\nP(\\text{measure } |0\\rangle^{\\otimes n}) = (1-p) \\cdot P(\\text{measure } |0\\rangle^{\\otimes n} | \\text{Scenario A}) + p \\cdot P(\\text{measure } |0\\rangle^{\\otimes n} | \\text{Scenario B})\n$$\n$$\nP(\\text{measure } |0\\rangle^{\\otimes n}) = (1-p) \\cdot 0 + p \\cdot 1 = p\n$$\n\nThe algorithm incorrectly declares the function as constant if $|0\\rangle^{\\otimes n}$ is measured. The probability of this error is $p$. Since the function is known to be balanced, the probability of a correct identification (declaring it balanced) is the probability of not measuring $|0\\rangle^{\\otimes n}$:\n$$\nP(\\text{correct}) = 1 - P(\\text{measure } |0\\rangle^{\\otimes n}) = 1 - p\n$$", "answer": "$$ \\boxed{1 - p} $$", "id": "151531"}]}