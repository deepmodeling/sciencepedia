{"hands_on_practices": [{"introduction": "The power of entanglement-assisted codes lies in their ability to create useful quantum codes from classical codes that would fail under the standard CSS construction. This first exercise provides a hands-on look at the fundamental trade-off equation that governs this process. By working through this problem ([@problem_id:80311]), you will see how pre-shared entanglement, quantified by the parameter $c$, can compensate for a deficit in classical code parameters to achieve a desired number of logical qubits.", "problem": "In the framework of entanglement-assisted quantum error correction (EAQEC), a quantum code can be constructed from two classical linear codes, $C_X$ and $C_Z$, defined over the field GF(2). These codes are used to detect and correct bit-flip (X) and phase-flip (Z) errors, respectively. Unlike standard Calderbank-Shor-Steane (CSS) codes, EAQEC codes can utilize pre-shared entanglement, quantified by the number of ebits $c$, to overcome situations where the classical codes do not meet the standard CSS condition ($C_Z^\\perp \\subseteq C_X$). This allows for the construction of quantum codes from a wider range of classical codes.\n\nAn EA-CSS code, denoted by $[[n, k, d; c]]$, is constructed from classical codes $C_X = [n, k_X, d_X]$ and $C_Z = [n, k_Z, d_Z]$. The number of encoded logical qubits, $k$, and the number of required ebits, $c$, are related to the parameters of the classical codes by the following fundamental trade-off relation:\n$$k = k_X + k_Z - n + c$$\nHere, $n$ is the number of physical qubits, $k_X$ is the dimension of $C_X$, and $k_Z$ is the dimension of $C_Z$. The number of logical qubits $k$ and the number of ebits $c$ must be non-negative integers.\n\nConsider the task of constructing an EA-CSS code using $n$ physical qubits. The classical code chosen for correcting X-errors is $C_X$ with parameters $[n, k_X] = [25, 10]$, and the code for correcting Z-errors is $C_Z$ with parameters $[n, k_Z] = [25, 12]$.\n\nWhat is the minimum number of ebits, $c$, required for this construction to yield a valid quantum code that encodes at least two logical qubits?", "solution": "The problem asks for the minimum number of ebits, $c$, needed to construct an EA-CSS code that encodes $k \\ge 2$ logical qubits, given the parameters of two classical codes $C_X$ and $C_Z$.\n\nFirst, we identify the given parameters from the problem statement:\n- The number of physical qubits is the same for both classical codes: $n = 25$.\n- The dimension of the classical code $C_X$ is $k_X = 10$.\n- The dimension of the classical code $C_Z$ is $k_Z = 12$.\n- The required number of logical qubits must satisfy the condition $k \\ge 2$.\n- Both $k$ and $c$ must be non-negative integers ($k \\ge 0, c \\ge 0$).\n\nThe central formula that governs the parameters of an EA-CSS code is:\n$$k = k_X + k_Z - n + c$$\n\nWe can first calculate the term $(k_X + k_Z - n)$, which represents the number of logical qubits that could be encoded by a standard CSS code (if the orthogonality condition were met and $c=0$).\n$$k_{CSS} = k_X + k_Z - n = 10 + 12 - 25$$\n$$k_{CSS} = 22 - 25 = -3$$\nSince this value is negative, it is impossible to construct a standard CSS code ($c=0$) that encodes any logical qubits ($k \\ge 0$). This demonstrates that entanglement assistance is necessary for this construction to yield any useful quantum code.\n\nThe relationship between $k$ and $c$ for this specific construction is:\n$$k = -3 + c$$\n\nThe problem requires that the resulting quantum code encodes at least two logical qubits. This translates to the mathematical inequality:\n$$k \\ge 2$$\n\nNow, we substitute the expression for $k$ in terms of $c$ into this inequality:\n$$-3 + c \\ge 2$$\n\nTo find the minimum required number of ebits, we solve this inequality for $c$:\n$$c \\ge 2 + 3$$\n$$c \\ge 5$$\n\nSince the number of ebits $c$ must be an integer, the smallest integer value that satisfies the condition $c \\ge 5$ is $c=5$.\n\nWith $c=5$, the number of encoded logical qubits would be $k = -3 + 5 = 2$. This satisfies the condition $k \\ge 2$. Any smaller integer value for $c$ (e.g., $c=4$) would result in $k = -3+4=1$, which violates the problem's requirement of $k \\ge 2$.\n\nTherefore, the minimum number of ebits required is 5.", "answer": "$$ \\boxed{5} $$", "id": "80311"}, {"introduction": "Having seen the high-level trade-off, we now delve into the mechanics of constructing an EA-CSS code. The number of required ebits is not an arbitrary choice but is determined by the degree of non-orthogonality between the classical codes used for error detection. This practice ([@problem_id:80241]) will guide you through the concrete calculation of $c$ from the parity-check matrices of the underlying classical codes, connecting abstract theory to matrix computation.", "problem": "An Entanglement-Assisted Quantum Error-Correcting (EA-QEC) code can be constructed from two classical linear codes over $\\mathbb{F}_2$. This construction, known as Entanglement-Assisted Calderbank-Shor-Steane (EA-CSS), provides a powerful generalization of the standard CSS framework.\n\nGiven two classical linear codes, $C_X$ with parameters $[n, k_X]$ and $C_Z$ with parameters $[n, k_Z]$, an EA-CSS code can be built. The $X$-type stabilizer generators for the quantum code are derived from the rows of the parity-check matrix $H_X$ of the classical code $C_X$. Similarly, the $Z$-type stabilizer generators are derived from the rows of the parity-check matrix $H_Z$ of the classical code $C_Z$.\n\nThe number of pre-shared entangled Bell pairs (ebits), denoted by $c$, required for this construction is determined by the overlap in the commutation relations of the stabilizer generators. It is given by the formula:\n$$\nc = \\text{rank}(H_X H_Z^T)\n$$\nwhere the matrix multiplication and rank are computed over the binary field $\\mathbb{F}_2$.\n\nConsider two classical linear codes, $C_X$ and $C_Z$, both of block length $n=5$.\nThe code $C_X$ is defined by the following generator matrix:\n$$\nG_X = \\begin{pmatrix} 1  0  1  1  0 \\\\ 0  1  0  1  1 \\end{pmatrix}\n$$\nThe code $C_Z$ is defined by the following generator matrix:\n$$\nG_Z = \\begin{pmatrix} 1  0  0  1  1 \\\\ 0  1  0  0  1 \\\\ 0  0  1  1  0 \\end{pmatrix}\n$$\nBoth matrices are in systematic form $G = [I_k | P]$, where $I_k$ is the $k \\times k$ identity matrix and $P$ is a $k \\times (n-k)$ matrix. The corresponding parity-check matrix is given by $H = [P^T | I_{n-k}]$.\n\nCalculate the number of ebits, $c$, required for the EA-CSS code constructed from the classical codes $C_X$ and $C_Z$.", "solution": "To determine the number of ebits $c$ for the EA-CSS code, we use the formula $c = \\text{rank}(H_X H_Z^T)$ over $\\mathbb{F}_2$, where $H_X$ and $H_Z$ are the parity-check matrices of the classical codes $C_X$ and $C_Z$, respectively.\n\nGiven the generator matrices in systematic form:\n- $G_X = \\begin{pmatrix} 1  0  1  1  0 \\\\ 0  1  0  1  1 \\end{pmatrix} = [I_2 \\mid P_X]$, so $P_X = \\begin{pmatrix} 1  1  0 \\\\ 0  1  1 \\end{pmatrix}$.\n- $G_Z = \\begin{pmatrix} 1  0  0  1  1 \\\\ 0  1  0  0  1 \\\\ 0  0  1  1  0 \\end{pmatrix} = [I_3 \\mid P_Z]$, so $P_Z = \\begin{pmatrix} 1  1 \\\\ 0  1 \\\\ 1  0 \\end{pmatrix}$.\n\nThe parity-check matrices are given by $H = [P^T \\mid I_{n-k}]$:\n- For $C_X$, $k_X = 2$, $n - k_X = 3$:\n  $$\n  H_X = [P_X^T \\mid I_3] = \\begin{pmatrix} 1  0  1  0  0 \\\\ 1  1  0  1  0 \\\\ 0  1  0  0  1 \\end{pmatrix}.\n  $$\n- For $C_Z$, $k_Z = 3$, $n - k_Z = 2$:\n  $$\n  H_Z = [P_Z^T \\mid I_2] = \\begin{pmatrix} 1  0  1  1  0 \\\\ 1  1  0  0  1 \\end{pmatrix}.\n  $$\n\nNow compute $H_Z^T$:\n$$\nH_Z^T = \\begin{pmatrix} 1  1 \\\\ 0  1 \\\\ 1  0 \\\\ 1  0 \\\\ 0  1 \\end{pmatrix}.\n$$\n\nNext, compute the product $H_X H_Z^T$ over $\\mathbb{F}_2$:\n- $H_X$ is $3 \\times 5$, $H_Z^T$ is $5 \\times 2$, so the product is $3 \\times 2$.\n- Element $(1,1)$: $(1,0,1,0,0) \\cdot (1,0,1,1,0)^T = 1\\cdot1 + 0\\cdot0 + 1\\cdot1 + 0\\cdot1 + 0\\cdot0 = 1 + 1 = 0$.\n- Element $(1,2)$: $(1,0,1,0,0) \\cdot (1,1,0,0,1)^T = 1\\cdot1 + 0\\cdot1 + 1\\cdot0 + 0\\cdot0 + 0\\cdot1 = 1$.\n- Element $(2,1)$: $(1,1,0,1,0) \\cdot (1,0,1,1,0)^T = 1\\cdot1 + 1\\cdot0 + 0\\cdot1 + 1\\cdot1 + 0\\cdot0 = 1 + 1 = 0$.\n- Element $(2,2)$: $(1,1,0,1,0) \\cdot (1,1,0,0,1)^T = 1\\cdot1 + 1\\cdot1 + 0\\cdot0 + 1\\cdot0 + 0\\cdot1 = 1 + 1 = 0$.\n- Element $(3,1)$: $(0,1,0,0,1) \\cdot (1,0,1,1,0)^T = 0\\cdot1 + 1\\cdot0 + 0\\cdot1 + 0\\cdot1 + 1\\cdot0 = 0$.\n- Element $(3,2)$: $(0,1,0,0,1) \\cdot (1,1,0,0,1)^T = 0\\cdot1 + 1\\cdot1 + 0\\cdot0 + 0\\cdot0 + 1\\cdot1 = 1 + 1 = 0$.\n\nThus,\n$$\nH_X H_Z^T = \\begin{pmatrix} 0  1 \\\\ 0  0 \\\\ 0  0 \\end{pmatrix}.\n$$\n\nNow we find the rank of this matrix over $\\mathbb{F}_2$. The row space is spanned by the non-zero rows. In this case, the only non-zero row is $(0, 1)$. Therefore, the dimension of the row space is 1.\n$$\n\\text{rank}(H_X H_Z^T) = 1.\n$$\nThe number of ebits required is $c = \\text{rank}(H_X H_Z^T) = 1$.", "answer": "$$\\boxed{1}$$", "id": "80241"}, {"introduction": "The final step in understanding any error-correcting code is to see how it detects errors. In an EAQEC, the error syndrome measurement involves not only the data qubits but also the ancillary qubits from the pre-shared ebits. This exercise ([@problem_id:80361]) provides practical experience in calculating an error syndrome by checking the commutation relations with these extended stabilizer generators, revealing how entanglement is actively used in the error detection process.", "problem": "An Entanglement-Assisted Quantum Error Correction (EAQEC) code is a type of quantum error-correcting code that utilizes pre-shared entanglement between the sender and receiver to simplify the encoding and decoding processes. An EAQEC code is defined by a stabilizer group $\\mathcal{S}$, which is an Abelian subgroup of the Pauli group $G_{n+c} = \\{\\pm 1, \\pm i\\} \\otimes (\\{I, X, Y, Z\\})^{\\otimes(n+c)}$. Here, $n$ is the number of data qubits and $c$ is the number of entangled Bell pairs (ebits) used. The codespace is the simultaneous +1 eigenspace of all operators in $\\mathcal{S}$.\n\nThe stabilizer group $\\mathcal{S}$ is specified by a set of $g$ independent and commuting generators, $\\{S_1, S_2, \\ldots, S_g\\}$. When a Pauli error $E$ occurs on the $n$ data qubits, it may anticommute with some of the stabilizer generators. The error syndrome is a classical bit string that records these commutation relations. For each generator $S_i$, a measurement is performed. If $E$ commutes with $S_i$ ($S_i E = E S_i$), the measurement outcome is $+1$, corresponding to a syndrome bit $s_i=0$. If $E$ anticommutes with $S_i$ ($S_i E = -E S_i$), the outcome is $-1$, corresponding to a syndrome bit $s_i=1$. The syndrome is the vector $(s_1, s_2, \\ldots, s_g)$.\n\nConsider a $[[n, k, d; c]] = [[4, 2, 2; 1]]$ EAQEC code. This code uses $n=4$ data qubits and $c=1$ ancillary qubit (labeled $A$), which is part of a pre-shared ebit, to encode $k=2$ logical qubits. The code is defined by the two stabilizer generators:\n1. $S_1 = X_1 \\otimes X_2 \\otimes Z_3 \\otimes Z_4 \\otimes I_A$\n2. $S_2 = Z_1 \\otimes Z_2 \\otimes I_3 \\otimes I_4 \\otimes Z_A$\n\nFor notational simplicity, we omit identity operators and write the generators as $S_1 = X_1 X_2 Z_3 Z_4$ and $S_2 = Z_1 Z_2 \\otimes Z_A$. The operator on the right of the tensor product symbol acts on the ancillary qubit $A$.\n\nSuppose a single-qubit Pauli error $E = Y_1$ occurs on the first data qubit. Determine the binary error syndrome vector $(s_1, s_2)$.", "solution": "The error syndrome $(s_1, s_2)$ is determined by checking the commutation relation of the error $E = Y_1$ with each stabilizer generator. The syndrome bit $s_i$ is 1 if they anti-commute, and 0 if they commute.\n\n**1. Commutation with $S_1 = X_1 X_2 Z_3 Z_4$:**\nThe error $E = Y_1$ acts non-trivially only on qubit 1. We check how $Y_1$ commutes with the Pauli operators in $S_1$.\n- $Y_1$ and $X_1$ anti-commute ($\\{Y_1, X_1\\} = 0$).\n- $Y_1$ commutes with $X_2$, $Z_3$, and $Z_4$ because they act on different qubits.\nAn odd number of anti-commuting pairs (in this case, one) means the overall operators $E$ and $S_1$ anti-commute. Thus, $\\{E, S_1\\} = 0$, and the first syndrome bit is $s_1 = 1$.\n\n**2. Commutation with $S_2 = Z_1 Z_2 \\otimes Z_A$:**\nWe check how $E = Y_1$ commutes with the Pauli operators in $S_2$.\n- $Y_1$ and $Z_1$ anti-commute ($\\{Y_1, Z_1\\} = 0$).\n- $Y_1$ commutes with $Z_2$ and $Z_A$ as they act on different qubits.\nAgain, there is one anti-commuting pair, so $E$ and $S_2$ anti-commute. Thus, $\\{E, S_2\\} = 0$, and the second syndrome bit is $s_2 = 1$.\n\nThe final syndrome vector is $(1, 1)$.", "answer": "$$\\boxed{(1,1)}$$", "id": "80361"}]}