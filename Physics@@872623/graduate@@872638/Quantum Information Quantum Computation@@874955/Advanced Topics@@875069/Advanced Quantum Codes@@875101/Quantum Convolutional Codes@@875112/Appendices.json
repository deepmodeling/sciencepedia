{"hands_on_practices": [{"introduction": "A crucial property for any convolutional code is that it be non-catastrophic, meaning a finite number of errors on the channel should not cause an infinite cascade of errors after decoding. This desirable trait is guaranteed if the code's polynomial generator matrix $G(D)$ has a polynomial left inverse. This exercise [@problem_id:115020] provides hands-on practice in finding such an inverse using the extended Euclidean algorithm for polynomials, a core algebraic technique in coding theory.", "problem": "In the theory of quantum convolutional codes (QCCs), which generalize quantum error-correcting codes to protect streams of quantum information, the properties of the code are often described by matrices with entries in a polynomial ring. A non-catastrophic QCC ensures that a finite-weight error pattern on the encoded qubits results in a finite-weight error on the decoded logical information.\n\nFor a certain class of $[[n,k]]$ QCCs, the encoding process can be modeled using a generator matrix $G(D)$, which is an $n \\times k$ matrix whose entries are polynomials in a formal delay variable $D$ over a finite field. For this problem, we consider a simplified model of a $[[2,1]]$ QCC, whose encoding is described by a $2 \\times 1$ generator matrix $G(D)$ over the polynomial ring $\\mathbb{F}_2[D]$. This matrix maps a single logical information stream (represented as a formal Laurent series in $D$) to two physical qubit streams.\n\nThe non-catastrophic nature of the code implies the existence of a polynomial left inverse, $G_L^{-1}(D)$. This is a $1 \\times 2$ matrix, also with entries in $\\mathbb{F}_2[D]$, that satisfies the condition $G_L^{-1}(D)G(D) = 1$. The left inverse is essential for decoding.\n\nIn general, there can be infinitely many such polynomial left inverses. We are interested in the *minimal* polynomial left inverse, which we define as the one for which the sum of the degrees of its polynomial entries is minimized.\n\nGiven the generator matrix for a non-catastrophic $[[2,1]]$ QCC:\n$$\nG(D) = \\begin{pmatrix} 1+D+D^3 \\\\ 1+D^2+D^3 \\end{pmatrix}\n$$\nCalculate the sum of the degrees of the polynomial entries of its minimal polynomial left inverse.", "solution": "We seek $a(D),b(D)\\in\\mathbb{F}_2[D]$ such that\n$$a(D)(1+D+D^3)+b(D)(1+D^2+D^3)=1\\,. $$\nThis is a Bézout identity for \n$$f(D)=D^3+D+1,\\quad g(D)=D^3+D^2+1$$\nin $\\mathbb{F}_2[D]$.  We apply the extended Euclidean algorithm:\n\n1. Set \n   $r_0=f,\\;r_1=g$, and record\n   $s_0=1,t_0=0;\\;s_1=0,t_1=1$ so that\n   $r_i=s_i f + t_i g$.\n\n2. Compute\n   $$r_2=r_0+r_1=f+g=D^2+D,\\quad\n     s_2=s_0+s_1=1,\\;t_2=t_0+t_1=1.$$\n\n3. Divide $r_1$ by $r_2$:\n   $$r_1 + D\\,r_2 = (D^3+D^2+1)+D(D^2+D)=1\\,,$$\n   giving\n   $$r_3=1,\\quad\n     s_3=s_1+D\\,s_2=D,\\quad\n     t_3=t_1+D\\,t_2=1+D.$$\n\nHence\n$$1=r_3=D\\,(D^3+D+1)+(1+D)\\,(D^3+D^2+1)\\,, $$\nso a valid left inverse is\n$$a(D)=D,\\quad b(D)=1+D.$$\nTheir degrees are $\\deg a=1$, $\\deg b=1$, and no solution with smaller total degree exists. Thus the minimal sum of degrees is\n$$1+1=2\\,. $$", "answer": "$$\\boxed{2}$$", "id": "115020"}, {"introduction": "The primary measure of a convolutional code's error-correcting capability is its free distance, which quantifies its ability to distinguish different input streams. For a quantum CSS code, this is determined by the properties of the underlying classical codes used for $X$ and $Z$ error correction. This practice problem [@problem_id:100840] walks through the process of calculating this crucial parameter by finding the minimum-weight codewords generated by a code and its dual.", "problem": "A quantum CSS (Calderbank-Shor-Steane) convolutional code can be constructed from a classical binary convolutional code $C$. In this construction, the correctable Z-type errors are associated with the code $C$, and the correctable X-type errors are associated with its dual code, $C^\\perp$. The logical Z operators are constructed from elements of the set $C \\setminus C^\\perp$, and the logical X operators from elements of $C^\\perp \\setminus C$.\n\nThe resilience of such a quantum code to errors is quantified by its quantum free distance, $d_{free, Q}$. This is defined as the minimum weight of a non-trivial logical operator, which translates to:\n$$d_{free, Q} = \\min(d_{free}(C \\setminus C^\\perp), d_{free}(C^\\perp \\setminus C))$$\nwhere $d_{free}(S)$ for a set of convolutional codewords $S$ is given by\n$$d_{free}(S) = \\min_{\\mathbf{c}(D) \\in S, \\mathbf{c}(D) \\neq \\mathbf{0}} \\{ \\text{wt}(\\mathbf{c}(D)) \\}$$\nThe term $\\mathbf{c}(D) = \\sum_{i=0}^m \\mathbf{c}_i D^i$ represents a codeword as a vector of polynomials in the delay operator $D$, generated by an information sequence of finite support. The weight, $\\text{wt}(\\mathbf{c}(D))$, is the total Hamming weight of the output sequence, i.e., $\\sum_{i=0}^m \\text{wt}(\\mathbf{c}_i)$.\n\nConsider a classical, binary, rate $k/n=1/2$ convolutional code $C$ defined by the polynomial generator matrix:\n$$G(D) = \\begin{pmatrix} 1+D^2  1+D+D^2 \\end{pmatrix}$$\nThis encoder has memory $m=2$. An information polynomial $u(D)$ is encoded into a codeword $\\mathbf{c}(D) = u(D)G(D)$.\n\nDerive the quantum free distance, $d_{free, Q}$, of the CSS quantum convolutional code constructed from $C$.", "solution": "1. Relevant definitions  \nThe quantum free distance is  \n$$d_{free,Q}=\\min\\bigl(d_{free}(C\\setminus C^\\perp),\\,d_{free}(C^\\perp\\setminus C)\\bigr),$$  \nwhere for any set of codewords $S$,  \n$$d_{free}(S)=\\min_{\\mathbf c(D)\\in S,\\;\\mathbf c(D)\\neq\\mathbf0}\\text{wt}(\\mathbf c(D)).$$  \n\n2. Free distance of $C$  \nA codeword is $\\mathbf c(D)=u(D)G(D)$ with  \n$$G(D)=\\bigl[\\,1+D^2\\,,\\,1+D+D^2\\bigr].$$  \nFor $u(D)=1$  \n$$\\mathbf c(D)=[\\,1+D^2,\\;1+D+D^2],$$  \nso in time domain  \n\n$$\nc_0=[1,1],\\;c_1=[0,1],\\;c_2=[1,1],\n$$\n  \nand  \n$$\\text{wt}(\\mathbf c(D))=2+1+2=5.$$  \nFor $u(D)=1+D$, one finds weight $7$.  Thus  \n$$d_{free}(C)=5.$$\n\n3. Characterization of $C^\\perp$  \nOrthogonality $\\mathbf c(D)\\in C^\\perp$ implies  \n$$(1+D^2)c_1(D)+(1+D+D^2)c_2(D)=0.$$  \nHence any dual codeword has the form  \n$$\\bigl(c_1,c_2\\bigr)\n=\\lambda(D)\\bigl(1+D+D^2,\\;1+D^2\\bigr),$$  \nand choosing $\\lambda(D)=1$ gives  \n$$\\mathbf c(D)=[\\,1+D+D^2,\\;1+D^2],$$  \nwith time-domain profiles  \n\n$$\nc_0=[1,1],\\;c_1=[1,0],\\;c_2=[1,1]\n$$\n\nand weight $5$.  Larger or shifted choices of $\\lambda(D)$ do not reduce the weight, so  \n$$d_{free}(C^\\perp)=5.$$\n\n4. Intersection and quantum distance  \nSince $C\\cap C^\\perp=\\{\\mathbf{0}\\}$,  \n$$d_{free}(C\\setminus C^\\perp)=d_{free}(C)=5,\\quad\nd_{free}(C^\\perp\\setminus C)=d_{free}(C^\\perp)=5.$$  \nTherefore  \n$$d_{free,Q}=\\min(5,5)=5.$$", "answer": "$$\\boxed{5}$$", "id": "100840"}, {"introduction": "Once a code's properties are understood, the next practical step is decoding—inferring the most likely error from a sequence of measured syndromes. For convolutional codes, the Viterbi algorithm provides an efficient way to do this by finding the lowest-cost path through a state-space trellis. This exercise [@problem_id:115100] offers a hands-on look at this process by asking you to compute the metric for a specific error path, connecting the abstract trellis to concrete error patterns and syndromes.", "problem": "Consider a quantum convolutional code (QCC) designed to protect a stream of qubits against bit-flip ($X$) errors. The code uses two physical qubits per time step, labeled 1 and 2. The error correction is performed by measuring a sequence of stabilizer operators. For simplicity, we focus on the part of the stabilizer group that detects $X$ errors, which are the $Z$-type stabilizers.\n\nThe code is defined by a single $Z$-type stabilizer generator, which has a time-invariant structure given by:\n$$\nS(t) = Z_1(t) \\otimes Z_2(t) \\otimes Z_2(t-1)\n$$\nHere, $Z_i(t)$ is the Pauli-$Z$ operator acting on qubit $i$ at time step $t$. This stabilizer links adjacent time blocks, giving the code a memory of one time step.\n\nAn $X$-error chain can be represented by a sequence of binary vectors $\\mathbf{e}(t) = (e_1(t), e_2(t))$, where $e_i(t)=1$ if an $X$ error occurred on qubit $i$ at time $t$, and $0$ otherwise. Measuring the stabilizer $S(t)$ yields a syndrome bit $s(t) \\in \\{0, 1\\}$. The syndrome is the sum (modulo 2) of the error bits on the qubits on which $S(t)$ acts:\n$$\ns(t) = e_1(t) \\oplus e_2(t) \\oplus e_2(t-1)\n$$\nTo find the most likely error chain that caused a given syndrome sequence, a Viterbi-like algorithm can be used on a trellis diagram. The state of the trellis at time $t$, denoted $\\sigma_t$, is determined by the error on the qubit involved in the memory of the stabilizer, i.e., $\\sigma_t = e_2(t-1)$. The trellis has two states, $\\sigma_t \\in \\{0, 1\\}$.\n\nA transition in the trellis from state $\\sigma_t$ to state $\\sigma_{t+1}$ is caused by the new error $\\mathbf{e}(t) = (e_1(t), e_2(t))$. Note that the new state is simply the error on the second qubit at time $t$, i.e., $\\sigma_{t+1} = e_2(t)$.\n\nFor a given syndrome sequence $\\{s(t)\\}$, the Viterbi algorithm finds the path through the trellis that minimizes a total cost metric. We will use the Hamming weight of the error chain as the cost metric. The branch metric for a single transition from $\\sigma_t$ to $\\sigma_{t+1}$ is the Hamming weight $w(\\mathbf{e}(t)) = e_1(t) + e_2(t)$ of the error vector that is consistent with the transition and the measured syndrome $s(t)$. The total path metric is the sum of the branch metrics along the path.\n\nAssume the system starts in an error-free state before $t=1$, which implies the initial trellis state is $\\sigma_1 = e_2(0) = 0$.\nSuppose over a period of $L=3$ time steps ($t=1, 2, 3$), the measured syndrome sequence is $\\mathbf{s} = (s(1), s(2), s(3)) = (1, 0, 1)$.\n\nCalculate the total path metric for the specific trellis path defined by the state sequence: $\\sigma_1=0 \\to \\sigma_2=1 \\to \\sigma_3=1 \\to \\sigma_4=0$.", "solution": "The problem requires calculating the total path metric for the specific trellis path with state sequence $\\sigma_1=0 \\to \\sigma_2=1 \\to \\sigma_3=1 \\to \\sigma_4=0$ over $L=3$ time steps, given the syndrome sequence $\\mathbf{s} = (1, 0, 1)$ and initial condition $\\sigma_1 = e_2(0) = 0$.\n\nFrom the state definitions:\n- $\\sigma_t = e_2(t-1)$\n- $\\sigma_{t+1} = e_2(t)$\n\nThus:\n- $\\sigma_1 = 0$ implies $e_2(0) = 0$\n- $\\sigma_2 = 1$ implies $e_2(1) = 1$\n- $\\sigma_3 = 1$ implies $e_2(2) = 1$\n- $\\sigma_4 = 0$ implies $e_2(3) = 0$\n\nThe syndrome equation is:\n$$s(t) = e_1(t) \\oplus e_2(t) \\oplus e_2(t-1)$$\nSolving for $e_1(t)$:\n$$e_1(t) = s(t) \\oplus e_2(t) \\oplus e_2(t-1)$$\n\nThe branch metric (Hamming weight) for time $t$ is:\n$$w(t) = e_1(t) + e_2(t)$$\n\nThe total path metric is the sum of branch metrics for $t=1,2,3$:\n$$\\text{Total metric} = w(1) + w(2) + w(3)$$\n\n**Time step $t=1$:**\n- $e_2(0) = \\sigma_1 = 0$\n- $e_2(1) = \\sigma_2 = 1$\n- $s(1) = 1$\n- Compute $e_1(1)$:\n  $$e_1(1) = s(1) \\oplus e_2(1) \\oplus e_2(0) = 1 \\oplus 1 \\oplus 0 = 0$$\n- Branch metric:\n  $$w(1) = e_1(1) + e_2(1) = 0 + 1 = 1$$\n\n**Time step $t=2$:**\n- $e_2(1) = \\sigma_2 = 1$\n- $e_2(2) = \\sigma_3 = 1$\n- $s(2) = 0$\n- Compute $e_1(2)$:\n  $$e_1(2) = s(2) \\oplus e_2(2) \\oplus e_2(1) = 0 \\oplus 1 \\oplus 1 = 0$$\n- Branch metric:\n  $$w(2) = e_1(2) + e_2(2) = 0 + 1 = 1$$\n\n**Time step $t=3$:**\n- $e_2(2) = \\sigma_3 = 1$\n- $e_2(3) = \\sigma_4 = 0$\n- $s(3) = 1$\n- Compute $e_1(3)$:\n  $$e_1(3) = s(3) \\oplus e_2(3) \\oplus e_2(2) = 1 \\oplus 0 \\oplus 1 = 0$$\n- Branch metric:\n  $$w(3) = e_1(3) + e_2(3) = 0 + 0 = 0$$\n\n**Total path metric:**\n$$\\text{Total metric} = w(1) + w(2) + w(3) = 1 + 1 + 0 = 2$$", "answer": "$$\\boxed{2}$$", "id": "115100"}]}