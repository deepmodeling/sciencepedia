{"hands_on_practices": [{"introduction": "The strength of a quantum error-correcting code is fundamentally measured by its distance—the weight of the smallest logical operator. This exercise provides direct practice in calculating this crucial parameter for a simple CSS code [@problem_id:123389]. By working through the definitions of the kernel and row space of the parity-check matrix, you will solidify your understanding of the distinction between trivial stabilizers and non-trivial logical operators.", "problem": "A quantum CSS (Calderbank-Shor-Steane) code is defined by two classical linear codes, $C_X$ and $C_Z$, satisfying $C_Z \\subseteq C_X$. A more general construction uses two parity check matrices, $H_X$ and $H_Z$, for the X-type and Z-type stabilizers, respectively. The stabilizers must commute, which for a CSS code translates to the condition $H_X H_Z^T = 0$ over $\\mathbb{F}_2$. The qubits of such a code are associated with the columns of these matrices.\n\nAn X-type logical operator is a Pauli operator of the form $L_X = \\bigotimes_i X_i^{\\ell_i}$, represented by a binary vector $\\ell$, that commutes with all Z-stabilizers but is not an X-stabilizer itself. The commutation condition implies $\\ell \\in \\ker(H_Z)$. The condition of not being an X-stabilizer means that $\\ell$ is not in the row space of $H_X$. The weight of $L_X$ is the Hamming weight of the vector $\\ell$.\n\nConsider a quantum code on $N=8$ qubits, constructed as a CSS code where the classical codes for both X and Z stabilizers are identical and defined by the parity check matrix $H$ over $\\mathbb{F}_2$:\n$$\nH = \\begin{pmatrix}\n1  1  1  1  0  0  0  0 \\\\\n0  0  1  1  1  1  0  0 \\\\\n0  0  0  0  1  1  1  1\n\\end{pmatrix}\n$$\nSo, $H_X = H_Z = H$. This construction defines a valid CSS code since $H H^T = 0 \\pmod 2$.\n\nYour task is to find the minimum weight of a logical X-operator for this code.", "solution": "We wish to find the minimum Hamming weight of a nontrivial $X$–logical operator, i.e.\\ a vector $\\ell\\in\\ker(H)$ but $\\ell\\notin\\operatorname{rowspace}(H)$.\n\n1.  Write the parity‐check conditions $H\\ell=0$ over $\\mathbb{F}_2$.  If $\\ell=(\\ell_1,\\dots,\\ell_8)^T$, then\n$$\n\\ell_1+\\ell_2+\\ell_3+\\ell_4=0,\n\\quad\n\\ell_3+\\ell_4+\\ell_5+\\ell_6=0,\n\\quad\n\\ell_5+\\ell_6+\\ell_7+\\ell_8=0.\n$$\n\n2.  One easily checks no weight-1 vector satisfies all three equations, while the weight-2 vector\n$$\n\\ell=e_1+e_2=(1,1,0,0,0,0,0,0)^T\n$$\ndoes:\n$$\n(1+1+0+0,\\;0+0+0+0,\\;0+0+0+0)\\equiv(0,0,0)\\pmod2.\n$$\nThus $e_1+e_2\\in\\ker(H)$.\n\n3.  We must also verify $e_1+e_2\\notin\\operatorname{rowspace}(H)$.  Any vector in $\\operatorname{rowspace}(H)$ is of the form\n$$\nx(1,1,1,1,0,0,0,0)+y(0,0,1,1,1,1,0,0)+z(0,0,0,0,1,1,1,1),\n$$\nand one checks no choice of $(x,y,z)\\in\\mathbb{F}_2^3$ yields $(1,1,0,0,0,0,0,0)$.\n\n4.  Hence the minimum weight of a nontrivial logical-$X$ is $2$.", "answer": "$$\\boxed{2}$$", "id": "123389"}, {"introduction": "Having defined a code's properties, we now turn to the dynamic process of error correction using a Belief Propagation (BP) decoder. To demystify the abstract 'message-passing' concept, this exercise guides you through the concrete numerical steps of the sum-product algorithm for a specific error scenario [@problem_id:123319]. Tracing the flow of log-likelihood ratios (LLRs) across the Tanner graph provides invaluable intuition for how the decoder collectively processes local syndrome information to build a global picture of the error.", "problem": "A quantum CSS code is constructed from two identical classical linear codes whose parity-check matrix $H$ defines a $(d_v, d_c) = (3,4)$-regular Tanner graph with $N=8$ variable nodes (qubits) and $M=6$ check nodes (stabilizer checks). The Z-errors are decoded independently using the stabilizer checks for Z-errors, whose corresponding Tanner graph is described by the following check-to-variable neighborhood lists:\n- $N(c_1) = \\{v_1, v_2, v_3, v_4\\}$\n- $N(c_2) = \\{v_5, v_6, v_7, v_8\\}$\n- $N(c_3) = \\{v_1, v_2, v_5, v_6\\}$\n- $N(c_4) = \\{v_3, v_4, v_7, v_8\\}$\n- $N(c_5) = \\{v_1, v_3, v_5, v_7\\}$\n- $N(c_6) = \\{v_2, v_4, v_6, v_8\\}$\n\nThe qubits are subject to independent noise, and the initial prior log-likelihood ratio (LLR) for a Z-error on any qubit $i$ is given by $L_{ch} = \\log \\frac{P(e_i=0)}{P(e_i=1)} = 2 \\operatorname{arctanh}(1/2)$.\n\nA single Z-error occurs on qubit $v_1$. The resulting syndrome is measured and provided to a belief propagation (sum-product) decoder. Calculate the final LLR for qubit $v_1$, denoted $L_1^{(\\text{final})}$, after two full iterations of the decoding algorithm.\n\nThe belief propagation update rules are as follows:\n- **Initialization**: Let $L_i^{(0)} = L_{ch}$ be the initial LLR for each qubit $i$. Messages from check nodes to variable nodes are initialized to zero for the first iteration, i.e., $u_{j \\to i}^{(0)}=0$.\n- **Variable-to-Check (V2C) message**: The message from variable node $i$ to check node $j$ at iteration $t$ is:\n$$m_{i \\to j}^{(t)} = L_i^{(0)} + \\sum_{k \\in N(i) \\setminus \\{j\\}} u_{k \\to i}^{(t-1)}$$\n- **Check-to-Variable (C2V) message**: The message from check node $j$ to variable node $i$ at iteration $t$ is:\n$$u_{j \\to i}^{(t)} = 2 \\operatorname{arctanh} \\left( (-1)^{s_j} \\prod_{k \\in N(j) \\setminus \\{i\\}} \\tanh\\left(\\frac{m_{k \\to j}^{(t)}}{2}\\right) \\right)$$\nwhere $s_j \\in \\{0,1\\}$ is the measured syndrome bit for check $j$.\n- **Final LLR**: After $T$ iterations, the final LLR for qubit $i$ is:\n$$L_i^{(T)} = L_i^{(0)} + \\sum_{j \\in N(i)} u_{j \\to i}^{(T)}$$", "solution": "We denote \n$$\\alpha = L_{ch} = 2\\operatorname{arctanh}\\bigl(\\tfrac12\\bigr),\\qquad\na = \\operatorname{arctanh}\\bigl(\\tfrac18\\bigr),\\qquad\nb = 2a = 2\\operatorname{arctanh}\\bigl(\\tfrac18\\bigr).$$\nAll check‐to‐variable messages at iteration 1 are\n$$u_{j\\to i}^{(1)} = 2\\operatorname{arctanh}\\bigl((-1)^{s_j}( \\tanh(\\alpha/2))^3\\bigr)\n=2\\operatorname{arctanh}\\bigl((-1)^{s_j}\\tfrac1{8}\\bigr)\n=\\begin{cases}+\\,b,s_j=0,\\\\-\\,b,s_j=1.\\end{cases}$$\nSince the single error on $v_1$ gives $s_{1,3,5}=1$ and $s_{2,4,6}=0$, we have\n$$u_{c_j\\to i}^{(1)}=-b\\quad(j=1,3,5),\\quad u_{c_j\\to i}^{(1)}=+b\\quad(j=2,4,6).$$\nAt iteration 2, the variable‐to‐check messages from each $v_i$ are\n$$m_{i\\to j}^{(2)}\n=\\alpha+\\sum_{k\\in N(i)\\setminus\\{j\\}}u_{k\\to i}^{(1)},$$\nwhich one checks case by case.  In particular for $v_1$, each\n$$m_{1\\to j}^{(2)}=\\alpha+(-b)+(-b)=\\alpha-2b\\quad(j=1,3,5).$$\nNext the check‐to‐variable messages at iteration 2 for $j\\in\\{1,3,5\\}$ are\n$$u_{j\\to1}^{(2)}\n=2\\operatorname{arctanh}\\Bigl((-1)^{s_j}\\!\\prod_{k\\in N(j)\\setminus\\{1\\}}\\tanh\\bigl(m_{k\\to j}^{(2)}/2\\bigr)\\Bigr).$$\nOne finds for each such $j$ exactly two neighbors with $m=\\alpha$ and one with $m=\\alpha+2b$, so\n$$\\tanh\\bigl(\\alpha/2\\bigr)=\\tfrac12,\\quad\n\\tanh\\bigl((\\alpha+2b)/2\\bigr)\n=\\tanh\\bigl(d+2a\\bigr)\\;\\text{with }d=\\operatorname{arctanh}(\\tfrac12)\n=\\frac{97}{146}.$$\nHence\n$$\\prod\\tanh=\\bigl(\\tfrac12\\bigr)^2\\cdot\\frac{97}{146}=\\frac{97}{584},$$\nand since $s_j=1$,\n$$u_{j\\to1}^{(2)}=2\\operatorname{arctanh}\\!\\Bigl(-\\tfrac{97}{584}\\Bigr)=-2\\operatorname{arctanh}\\!\\Bigl(\\tfrac{97}{584}\\Bigr).$$\nFinally the posterior LLR after two iterations is\n$$L_1^{(2)}=L_1^{(0)}+\\sum_{j\\in N(1)}u_{j\\to1}^{(2)}\n=\\alpha-3\\cdot2\\operatorname{arctanh}\\!\\Bigl(\\tfrac{97}{584}\\Bigr)\n=2\\operatorname{arctanh}\\!\\Bigl(\\tfrac12\\Bigr)-6\\operatorname{arctanh}\\!\\Bigl(\\tfrac{97}{584}\\Bigr).$$", "answer": "$$\\boxed{2\\operatorname{arctanh}\\!\\bigl(\\tfrac12\\bigr)\\;-\\;6\\operatorname{arctanh}\\!\\bigl(\\tfrac{97}{584}\\bigr)}$$", "id": "123319"}, {"introduction": "The ultimate goal of studying QLDPC codes is to design robust protection for realistic quantum devices, which often exhibit highly biased noise. This problem moves from analysis to design, exploring how to tailor the geometry of the surface code—a canonical example of a QLDPC code—to the specific characteristics of the noise channel [@problem_id:123416]. By balancing the protection against different logical error types, you will see a key principle of modern fault-tolerance research in action: the co-design of codes and hardware.", "problem": "A planar surface code is constructed on a rectangular lattice of data qubits, with dimensions corresponding to logical distances $d_Z = L_x$ and $d_X = L_y$. The code is subjected to a highly biased Pauli noise channel where phase-flip (Z) errors occur with physical probability $p$ per qubit, while bit-flip (X) and combined (Y) errors are completely suppressed ($\\eta = p_Z / p_{X,Y} \\to \\infty$).\n\nUnder these conditions, a logical Z-error, $Z_L$, is primarily caused by a chain of physical Z-errors that the decoder fails to correct. The probability of such a failure, $P_{Z_L}$, is well-approximated by the standard scaling for a distance $d_Z$ code:\n$$\nP_{Z_L} \\propto p^{d_Z/2}\n$$\n\nA logical X-error, $X_L$, cannot be formed by a simple chain of Z-errors. However, it can arise from a more complex failure of the decoding algorithm (e.g., Minimum Weight Perfect Matching). For pure Z-noise, it can be shown that the leading contribution to the logical X-error rate is a higher-order process. This process has a dominant probability scaling that is different from the native error channel. It is given by:\n$$\nP_{X_L} \\propto p^{d_X}\n$$\n\nTo maximize the overall performance of the quantum code for a fixed number of qubits, it is desirable to balance the protection against both types of logical errors. This is achieved when the exponential suppression from the physical error probability $p$ is the same for both logical error channels. This means their scaling exponents must be equal.\n\nDetermine the optimal geometric aspect ratio $R = L_x / L_y$ for the planar surface code that balances the logical error rates in this manner.", "solution": "1. Relevant equations for logical error scaling:\n   - Logical Z-error: $$P_{Z_L}\\propto p^{d_Z/2}\\quad\\text{with }d_Z=L_x.$$\n   - Logical X-error: $$P_{X_L}\\propto p^{d_X}\\quad\\text{with }d_X=L_y.$$\n\n2. To balance error suppression, set the exponents equal:\n   $$\\frac{L_x}{2}=L_y.$$\n\n3. Solve for the aspect ratio $R=L_x/L_y$:\n   $$\\frac{L_x}{L_y}=2.$$", "answer": "$$\\boxed{2}$$", "id": "123416"}]}