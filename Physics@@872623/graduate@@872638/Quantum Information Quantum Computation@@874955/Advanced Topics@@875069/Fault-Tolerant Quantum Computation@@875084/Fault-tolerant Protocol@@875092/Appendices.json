{"hands_on_practices": [{"introduction": "Universal quantum computation requires non-Clifford gates, which are notoriously difficult to implement fault-tolerantly. A primary strategy involves consuming high-fidelity \"magic states,\" which are themselves produced via costly distillation protocols. This exercise [@problem_id:83631] provides a practical lesson in quantum resource accounting, asking you to calculate the expected number of physical states consumed for a single logical operation and thereby developing a concrete understanding of the overheads in fault-tolerant computing.", "problem": "In fault-tolerant quantum computation schemes, such as those using the Steane $[[7,1,3]]$ code, logical operations from the Clifford group (e.g., Hadamard, Phase, CNOT) can often be implemented transversally, making them relatively low-cost. However, non-Clifford gates, like the $T$ gate ($T = \\text{diag}(1, e^{i\\pi/4})$), are essential for universal quantum computation but are much more expensive to implement fault-tolerantly.\n\nA common method for implementing a logical $T$ gate is through \"magic state injection\". This involves preparing a specialized ancilla qubit in a \"magic state\" and consuming it. These magic states must be prepared with very high fidelity, a task accomplished by a \"magic state distillation factory\".\n\nConsider a factory that runs an \"$N_{in}$-to-1\" distillation protocol. For each attempt, the protocol consumes $N_{in}$ physical magic states.\n- With a probability $p_{succ}$, the attempt is successful, producing one high-fidelity logical magic state. In this case, it is also determined that $k$ of the initial $N_{in}$ states were not corrupted by errors and can be returned to the pool of available physical states.\n- With a probability $1-p_{succ}$, the attempt fails. No logical magic state is produced, and all $N_{in}$ physical states are considered lost.\n\nFor the factory to be a net consumer of states (i.e., not a perpetual motion machine), it must satisfy the condition $N_{in}  k p_{succ}$.\n\nA logical Controlled-Phase gate ($CS$, or controlled-$S$ gate), which is a non-Clifford gate, is required for a particular algorithm. A standard decomposition of the logical $CS$ gate requires the execution of several logical Clifford gates and three logical T-family gates ($T$ or $T^\\dagger$). Assume that the cost of preparing a magic state for a $T^\\dagger$ gate is identical to that for a $T$ gate. The cost of the logical Clifford gates is considered negligible in comparison to the magic state preparation.\n\nCalculate the expected number of *net* physical magic states that are consumed to implement a single logical $CS$ gate. Your answer should be expressed in terms of the parameters $N_{in}$, $k$, and $p_{succ}$.", "solution": "To find the expected number of net physical magic states consumed to implement a single logical $CS$ gate, note that the gate requires three logical $T$-family gates (each $T$ or $T^\\dagger$). Each $T$-family gate requires one logical magic state, so three logical magic states are needed.\n\nThe expected net consumption of physical magic states to produce one logical magic state, denoted $E$, satisfies the equation derived from the distillation protocol:\n- With probability $p_{succ}$, the attempt succeeds: net consumption is $N_{in} - k$ physical states (consuming $N_{in}$ but returning $k$ uncorrupted states), and no further cost is incurred.\n- With probability $1 - p_{succ}$, the attempt fails: net consumption is $N_{in}$ physical states (all lost), and the process restarts, incurring an additional expected cost $E$.\n\nThus, the equation for $E$ is:\n\n$$\nE = p_{succ} (N_{in} - k) + (1 - p_{succ}) (N_{in} + E)\n$$\n\nSolving for $E$:\n\n$$\nE = p_{succ} N_{in} - p_{succ} k + (1 - p_{succ}) N_{in} + (1 - p_{succ}) E\n$$\n\n\n$$\nE = N_{in} - p_{succ} k + (1 - p_{succ}) E\n$$\n\n\n$$\nE - (1 - p_{succ}) E = N_{in} - p_{succ} k\n$$\n\n\n$$\np_{succ} E = N_{in} - p_{succ} k\n$$\n\n\n$$\nE = \\frac{N_{in} - p_{succ} k}{p_{succ}} = \\frac{N_{in}}{p_{succ}} - k\n$$\n\nThis is the expected net physical magic states consumed per logical magic state. For three logical magic states, the total expected net consumption is:\n\n$$\n3E = 3 \\left( \\frac{N_{in}}{p_{succ}} - k \\right)\n$$\n\nThe production of each logical magic state is identical and independent, and the expression for $E$ accounts for the reuse of returned physical states within the distillation process for that state. Therefore, the total expected net consumption for three logical magic states is $3E$.", "answer": "$$\\boxed{3\\left(\\frac{N_{in}}{p_{succ}} - k\\right)}$$", "id": "83631"}, {"introduction": "Having established the high cost of magic states, we now examine how a \"distillation factory\" actually works. These protocols are a cornerstone of fault-tolerance, consuming multiple noisy states to produce a single, higher-fidelity output. This practice [@problem_id:83563] takes you inside a specific distillation protocol, where you will analyze how its underlying error-correcting code structure filters errors to achieve a powerful quadratic improvement in state fidelity.", "problem": "The distillation of magic states is a crucial subroutine in many schemes for fault-tolerant quantum computation. This process consumes multiple noisy magic states to produce a single magic state of higher fidelity. In this problem, we will analyze the performance of a particular magic state distillation protocol.\n\nThe magic state in question is the $|H\\rangle$ state, defined as $|H\\rangle = \\frac{1}{\\sqrt{2}}(|0\\rangle + |1\\rangle)$, which is the $+1$ eigenstate of the Pauli-X operator. The protocol starts with eight noisy input states, where each state $\\rho_{in}$ is the result of a Z-error channel acting on an ideal $|H\\rangle$ state. The density matrix of each input state is given by:\n$$ \\rho_{in} = (1-\\epsilon)|H\\rangle\\langle H| + \\epsilon|-\\rangle\\langle -| $$\nwhere $|-\\rangle = \\frac{1}{\\sqrt{2}}(|0\\rangle - |1\\rangle)$ and $\\epsilon$ is the initial infidelity. An error on a given qubit corresponds to a Pauli $Z$ operator flipping the state from $|H\\rangle$ to $|-\\rangle$.\n\nThe distillation protocol is based on a specific $[[8, 1, 3]]$ quantum error-correcting code. A distance $d=3$ code can correct any single-qubit error. The protocol proceeds as follows:\n1.  Eight physical qubits are prepared, each in an identical noisy state $\\rho_{in}$. This initial 8-qubit state represents a noisy version of the logical $|\\bar{H}\\rangle$ state.\n2.  The seven stabilizer generators of the $[[8, 1, 3]]$ code are measured.\n3.  A standard error-correction procedure is applied based on the measurement outcomes (the error syndrome).\n\nThe properties of this specific code and its decoding procedure are as follows:\n*   Any single-qubit $Z$ error is perfectly corrected, meaning the final state has no logical error.\n*   Any two-qubit $Z$ error (i.e., an error of the form $Z_i Z_j$ for $i \\neq j$) is mis-corrected in such a way that it becomes a logical $Z_L$ error on the encoded qubit.\n*   Errors of weight three or higher may or may not be corrected, but their contribution to the final infidelity can be ignored for this problem.\n\nYour task is to calculate the infidelity $\\epsilon_{out}$ of the final, single-qubit logical state. The output infidelity is defined as the probability that the final state is the logical $|\\bar{-}\\rangle$ state. Please provide the expression for $\\epsilon_{out}$ to the leading, non-vanishing order in $\\epsilon$.", "solution": "The output infidelity $\\epsilon_{out}$ is defined as the probability that the final state is the logical $|\\bar{-}\\rangle$ state. This occurs when a logical $Z_L$ error is present after error correction.\n\nEach input state undergoes a Z-error channel, and the errors on different qubits are independent. The probability of a Z error on any single qubit is $\\epsilon$, and the probability of no error is $1 - \\epsilon$.\n\nBased on the properties of the $[[8, 1, 3]]$ code:\n- Any single-qubit Z error is perfectly corrected, resulting in no logical error.\n- Any two-qubit Z error (i.e., $Z_i Z_j$ for $i \\neq j$) is mis-corrected to a logical $Z_L$ error.\n- Errors of weight three or higher can be ignored for the leading order in $\\epsilon$, as per the problem statement.\n\nThe event leading to a logical $Z_L$ error at the leading non-vanishing order is exactly two Z errors occurring on the eight qubits. The probability of exactly two errors is given by the binomial distribution:\n\n$$ P(\\text{exactly two errors}) = \\binom{8}{2} \\epsilon^2 (1 - \\epsilon)^{6} $$\n\nExpanding $(1 - \\epsilon)^6$:\n\n$$ (1 - \\epsilon)^6 = 1 - 6\\epsilon + 15\\epsilon^2 - 20\\epsilon^3 + \\cdots $$\n\nMultiplying by $\\binom{8}{2} \\epsilon^2$:\n\n$$ P(\\text{exactly two errors}) = \\binom{8}{2} \\epsilon^2 (1 - 6\\epsilon + 15\\epsilon^2 - \\cdots) = \\binom{8}{2} \\epsilon^2 - 6\\binom{8}{2} \\epsilon^3 + \\cdots $$\n\nThe leading non-vanishing term is $\\binom{8}{2} \\epsilon^2$. Calculating the binomial coefficient:\n\n$$ \\binom{8}{2} = \\frac{8!}{2! \\, 6!} = \\frac{8 \\times 7}{2 \\times 1} = 28 $$\n\nThus:\n\n$$ \\epsilon_{out} = 28 \\epsilon^2 + \\mathcal{O}(\\epsilon^3) $$\n\nTherefore, to the leading non-vanishing order in $\\epsilon$, the output infidelity is $28 \\epsilon^2$.", "answer": "$$ \\boxed{28 \\epsilon^{2}} $$", "id": "83563"}, {"introduction": "While a larger code distance $d$ offers better protection against quantum errors, it also increases system complexity and can elevate the risk of classical control failures. This presents a critical engineering trade-off, as a more powerful code may also be more fragile in other ways. This final exercise [@problem_id:83559] elevates your perspective to system-level architecture, tasking you with modeling two competing error sources to find the optimal code distance that minimizes the total failure probability of the entire computer.", "problem": "An engineer is designing a fault-tolerant quantum computer based on a hypothetical topological error-correcting code. The goal is to determine the optimal code distance $d$ that minimizes the total logical error probability when running the system for a fixed total time $T$.\n\nThe model for the fault-tolerant system has the following characteristics:\n1.  **Logical Errors from Imperfect Correction:** The primary source of logical errors stems from physical errors accumulating faster than the code can correct them. For this specific code, a simplified model for the logical error probability per error correction cycle, $P_L$, is given by an exponential decay with the code distance $d$:\n    $$P_L(d) = A e^{-\\kappa d}$$\n    Here, $A$ is a dimensionless constant related to the number of low-weight error configurations, and $\\kappa$ is a positive constant that depends on the physical error rate of the underlying hardware. Higher $\\kappa$ implies better underlying hardware.\n\n2.  **Catastrophic System Failures:** A second error source exists. The complex classical control hardware required to operate the code can suffer a catastrophic failure. The probability of such a failure during a single error correction cycle, $P_C$, is found to increase with the code's complexity, which scales with the number of physical qubits ($ \\propto d^2$). This is modeled as a simple power law:\n    $$P_C(d) = B d^2$$\n    where $B$ is a small, dimensionless constant representing the failure rate of the control components.\n\n3.  **System Operation:** The computer runs for a total time $T$. For this architecture, the duration of a single error correction cycle, $t_{cycle}$, is assumed to be a constant, $\\tau_0$, irrespective of the code distance $d$. The total number of cycles is $N_{cycles} = T/\\tau_0$. The total logical failure probability, $P_{total}$, is the probability of a failure occurring in any cycle. Assuming the probability of failure per cycle is small, this can be approximated as:\n    $$P_{total}(d) \\approx N_{cycles} \\left( P_L(d) + P_C(d) \\right)$$\n\nYour task is to find the optimal code distance $d_{opt}$ that minimizes this total logical failure probability. For the purpose of optimization, treat the code distance $d$ as a continuous positive real variable.\n\nExpress your answer in terms of the constants $A$, $B$, $\\kappa$, and the principal branch of the Lambert W function, denoted as $W_0(z)$. The Lambert W function is defined as the solution to the equation $z = W(z) e^{W(z)}$.", "solution": "To minimize the total logical failure probability $ P_{\\text{total}}(d) \\approx N_{\\text{cycles}} \\left( P_L(d) + P_C(d) \\right) $, where $ N_{\\text{cycles}} = T / \\tau_0 $ is constant, $ P_L(d) = A e^{-\\kappa d} $, and $ P_C(d) = B d^2 $, the function to minimize is:\n\n$$\nf(d) = P_L(d) + P_C(d) = A e^{-\\kappa d} + B d^2\n$$\n\nsince $ N_{\\text{cycles}} $ is a multiplicative constant. The derivative of $ f(d) $ is:\n\n$$\nf'(d) = -A \\kappa e^{-\\kappa d} + 2B d\n$$\n\nSet $ f'(d) = 0 $:\n\n$$\n- A \\kappa e^{-\\kappa d} + 2B d = 0\n$$\n\n\n$$\n2B d = A \\kappa e^{-\\kappa d}\n$$\n\n\n$$\n\\frac{2B}{A \\kappa} d = e^{-\\kappa d}\n$$\n\nMultiply both sides by $ e^{\\kappa d} $:\n\n$$\n\\frac{2B}{A \\kappa} d e^{\\kappa d} = 1\n$$\n\n\n$$\nd e^{\\kappa d} = \\frac{A \\kappa}{2B}\n$$\n\nLet $ u = \\kappa d $, so:\n\n$$\n\\frac{u}{\\kappa} e^{u} = \\frac{A \\kappa}{2B}\n$$\n\n\n$$\nu e^{u} = \\frac{A \\kappa^2}{2B}\n$$\n\nThe solution is $ u = W_0 \\left( \\frac{A \\kappa^2}{2B} \\right) $, where $ W_0 $ is the principal branch of the Lambert W function. Substitute $ u = \\kappa d $:\n\n$$\n\\kappa d = W_0 \\left( \\frac{A \\kappa^2}{2B} \\right)\n$$\n\n\n$$\nd = \\frac{1}{\\kappa} W_0 \\left( \\frac{A \\kappa^2}{2B} \\right)\n$$\n\nThis critical point minimizes $ f(d) $ because the second derivative $ f''(d) = A \\kappa^2 e^{-\\kappa d} + 2B  0 $ for all $ d $, confirming a minimum.", "answer": "$$\\boxed{\\dfrac{1}{\\kappa} W_{0}\\left(\\dfrac{A \\kappa^{2}}{2B}\\right)}$$", "id": "83559"}]}