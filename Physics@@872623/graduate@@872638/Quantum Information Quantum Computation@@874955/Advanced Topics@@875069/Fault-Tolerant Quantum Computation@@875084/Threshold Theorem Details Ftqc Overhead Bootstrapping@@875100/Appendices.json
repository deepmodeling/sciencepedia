{"hands_on_practices": [{"introduction": "This first practice explores a fundamental challenge in fault-tolerant quantum computation (FTQC): managing errors that arise from both the quantum hardware and the classical electronics controlling it. You will analyze a common technique where a faulty logical measurement is repeated, and the classical results are protected by a repetition code to achieve a higher-fidelity outcome [@problem_id:177930]. This exercise demonstrates how layers of classical and quantum error correction work together to suppress noise.", "problem": "In the theory of fault-tolerant quantum computation (FTQC), a crucial step is the reliable measurement of logical qubits. Even if the underlying quantum gates are faulty, repeated measurements and classical post-processing can be used to suppress errors and obtain a highly reliable outcome.\n\nConsider a scheme to measure a logical qubit in the computational basis. A single execution of the logical measurement procedure is itself faulty, having a probability $p_L$ of returning the incorrect classical outcome (i.e., yielding '1' when the true state was logical '0', or vice versa).\n\nTo enhance the reliability of the measurement, this logical measurement procedure is repeated $N=3$ times. Each of the three resulting classical bits is stored in classical memory. This classical memory is also faulty, and each stored bit has an independent probability $p_c$ of being flipped before the final processing step.\n\nFinally, the three (potentially erroneous) classical bits are read from memory, and a majority vote is performed to determine the final outcome of the logical measurement.\n\nCalculate the total probability, $P_{\\text{fail}}$, that the final outcome determined by the majority vote is incorrect. Express your answer as a function of $p_L$ and $p_c$.", "solution": "The total probability of failure, $P_{\\text{fail}}$, is the probability that the majority vote of the three stored bits is incorrect. Each logical measurement has an error probability $p_L$, and each classical bit stored in memory has an independent error probability $p_c$.\n\nDefine $q$ as the probability that a single stored bit is incorrect. For a true state of 0:\n- The measurement is incorrect with probability $p_L$ (yielding 1), and the storage is correct with probability $1 - p_c$, so the bit remains incorrect with probability $p_L (1 - p_c)$.\n- The measurement is correct with probability $1 - p_L$ (yielding 0), and the storage is incorrect with probability $p_c$ (flipping to 1), so the bit becomes incorrect with probability $(1 - p_L) p_c$.\n\nThus, the total error probability per bit is:\n\n$$\nq = p_L (1 - p_c) + (1 - p_L) p_c = p_L + p_c - 2 p_L p_c\n$$\n\n\nThe three stored bits are independent, each erroneous with probability $q$. The majority vote fails (i.e., is incorrect) if at least two bits are erroneous. The probability of exactly two errors is $\\binom{3}{2} q^2 (1 - q)$, and the probability of three errors is $\\binom{3}{3} q^3$. Therefore:\n\n$$\nP_{\\text{fail}} = \\binom{3}{2} q^2 (1 - q) + \\binom{3}{3} q^3 = 3 q^2 (1 - q) + q^3\n$$\n\nSimplify:\n\n$$\nP_{\\text{fail}} = 3 q^2 - 3 q^3 + q^3 = 3 q^2 - 2 q^3\n$$\n\nSubstitute $q = p_L + p_c - 2 p_L p_c$:\n\n$$\nP_{\\text{fail}} = 3 (p_L + p_c - 2 p_L p_c)^2 - 2 (p_L + p_c - 2 p_L p_c)^3\n$$\n\nFactor the expression:\n\n$$\nP_{\\text{fail}} = (p_L + p_c - 2 p_L p_c)^2 \\left[ 3 - 2 (p_L + p_c - 2 p_L p_c) \\right]\n$$\n\nSimplify the term in brackets:\n\n$$\n3 - 2(p_L + p_c - 2 p_L p_c) = 3 - 2 p_L - 2 p_c + 4 p_L p_c\n$$\n\nThus:\n\n$$\nP_{\\text{fail}} = (p_L + p_c - 2 p_L p_c)^2 (3 - 2 p_L - 2 p_c + 4 p_L p_c)\n$$", "answer": "$$\n\\boxed{\\left(p_L + p_c - 2 p_L p_c\\right)^2 \\left(3 - 2 p_L - 2 p_c + 4 p_L p_c\\right)}\n$$", "id": "177930"}, {"introduction": "Building on the idea of repetition, this problem introduces the powerful concept of recursive \"bootstrapping\" to prepare high-quality ancilla states from unreliable components. You will analyze a recurrence relation that describes how the error probability decreases at each level of the protocol, a process central to the logic of the Threshold Theorem [@problem_id:177929]. This practice reveals how fault-tolerant procedures can achieve arbitrarily low error rates, provided the underlying physical error rate is below a certain threshold.", "problem": "In the construction of a fault-tolerant quantum memory based on the `[[7,1,3]]` Steane code, a critical procedure is the repeated measurement of the code's six stabilizers. For this task, specialized 4-qubit cat states, $|\\text{cat}_4\\rangle = \\frac{1}{\\sqrt{2}}(|0000\\rangle + |1111\\rangle)$, are used as ancillas. The overall logical error rate of the memory is dominated by the fallibility of these ancilla states. A faulty ancilla used in a stabilizer measurement is assumed to cause a logical error on the stored qubit with unit probability. Consequently, the logical error rate per memory cycle, $p_{log}$, is given by $p_{log} = N_{stab} P_{ancilla}$, where $N_{stab}=6$ is the number of stabilizers and $P_{ancilla}$ is the probability of a single ancilla being faulty.\n\nTo suppress $P_{ancilla}$, a recursive bootstrapping protocol is employed. Let $P_L$ be the failure probability of a cat-state ancilla prepared to fault-tolerance level $L$.\nThe base case, a \"raw\" level-0 ancilla, is prepared using a simple circuit of physical gates. Its failure probability is $P_0 = c_0 \\epsilon$, where $\\epsilon$ is the physical error rate (per gate or memory location per unit time) and $c_0$ is a constant determined by the circuit's size.\n\nFor levels $L \\ge 1$, a level-$L$ ancilla is produced and verified using circuits built from level-$(L-1)$ components. This process leads to the following recurrence relation for the failure probability:\n$$ P_L = A P_{L-1}^2 + B \\epsilon P_{L-1} $$\nHere, $A$ and $B$ are positive integer constants derived from the architecture of the verification circuit. The $A P_{L-1}^2$ term accounts for failure modes involving two faulty level-$(L-1)$ components, while the $B \\epsilon P_{L-1}$ term accounts for modes involving one faulty level-$(L-1)$ component and one new physical error.\n\nAssume the system operates with a physical error rate $\\epsilon$ that is sufficiently small. This justifies making an approximation: for any level $k \\ge 1$, the failure probability $P_k$ is small enough that the term quadratic in this error, $A P_k^2$, can be neglected when calculating the failure probability of the next level, $P_{k+1}$. Note that this approximation does **not** apply for the base case $k=0$ (i.e., in the calculation of $P_1$, both terms in the recurrence must be retained).\n\nYour task is to derive an expression for the total logical error rate per memory cycle, $p_{log}$, for a memory using ancillas prepared to a fault-tolerance level $L \\ge 1$. Express your answer in terms of $L, A, B, c_0,$ and $\\epsilon$.", "solution": "We have the following definitions and recurrence:\n\n1. Base-case ancilla failure probability\n$$P_0 = c_0 \\epsilon\\,. $$\n\n2. For levels $L\\ge1$, the exact recurrence is\n$$P_L = A P_{L-1}^2 + B \\epsilon P_{L-1}\\,. $$\n\n3. For $L\\ge1$ we assume $P_{L-1}$ is small enough that the quadratic term can be dropped when computing $P_L$, _except_ in the step $P_1$ where both terms must be retained.\n\nStep 1: Compute $P_1$ exactly.\n$$P_1 = A P_0^2 + B \\epsilon P_0\n= A (c_0 \\epsilon)^2 + B \\epsilon (c_0 \\epsilon)\n= \\bigl(A c_0^2 + B c_0\\bigr) \\epsilon^2\\,. $$\n\nDefine $D_1\\equiv A c_0^2 + B c_0$, so $P_1 = D_1 \\epsilon^2$.\n\nStep 2: For $L\\ge2$, drop the $A P_{L-1}^2$ term and use\n$$P_L \\approx B \\epsilon P_{L-1}\\,. $$\n\nBy iteration,\n$$P_2 \\approx B \\epsilon P_1 = B \\epsilon (D_1 \\epsilon^2)= D_1 B \\epsilon^3,$$\n$$P_3 \\approx B \\epsilon P_2 = D_1 B^2 \\epsilon^4,$$\nand in general for $L\\ge1$,\n$$P_L = D_1 B^{L-1} \\epsilon^{L+1}\n= \\bigl(A c_0^2 + B c_0\\bigr) B^{L-1} \\epsilon^{L+1}\\,. $$\n\nStep 3: The logical error rate per cycle is\n$$p_{log} = N_{stab} P_L = 6 P_L = 6(A c_0^2 + B c_0) B^{L-1} \\epsilon^{L+1}\\,. $$", "answer": "$$\\boxed{6 (A c_0^2 + B c_0) B^{L-1} \\epsilon^{L+1}}$$", "id": "177929"}, {"introduction": "Our final practice examines a critical, system-level feedback loop that can arise in a fault-tolerant architecture. You will model a scenario where the time required for classical decoding depends on the number of quantum errors, and this decoding time itself introduces new quantum errors due to decoherence [@problem_id:177977]. By finding the steady-state logical error rate, you will uncover the conditions under which this feedback loop is stable, providing a concrete illustration of a fault-tolerance threshold in a dynamic system.", "problem": "A fault-tolerant quantum computer uses a surface code of odd distance $d$ to protect a logical qubit. We are interested in modeling the total logical error rate, considering a scenario where the classical processing time of the decoder introduces additional errors.\n\nThe error correction cycle and noise model are defined as follows:\n1.  **Intrinsic Errors:** At the beginning of each error correction cycle, each of the $N \\approx 2d^2$ data qubits is subjected to a Pauli-Z error with an independent probability $p$. We only consider Z-errors.\n2.  **Syndrome Detection:** Stabilizer measurements are performed to detect the errors, resulting in a set of syndrome defects (violated stabilizers).\n3.  **Classical Decoding:** A Union-Find decoder is used to process the syndrome. The time required for this classical computation, $T_{decode}$, is proportional to the number of defects, $K$. To make the problem analytically tractable, we model the decoding time using the *average* number of defects, $\\bar{K}$, as $T_{decode} = \\tau_0 \\bar{K}$, where $\\tau_0$ is a characteristic processing time constant.\n4.  **Decoder Overhead Model:** The average number of defects is modeled to be directly proportional to the code's area and the effective physical Z-error rate per qubit, $p_{eff}$. The relationship is given by $\\bar{K} = \\beta d^2 p_{eff}$, where $\\beta$ is a phenomenological constant that encapsulates the details of the stabilizer graph.\n5.  **Memory Errors:** During the decoding time $T_{decode}$, the quantum state is held in memory and is subject to decoherence. This results in an additional Z-error on each qubit with probability $p_{mem}$. For a short decoding time, this probability is well approximated by $p_{mem} \\approx \\gamma T_{decode}$, where $\\gamma$ is the memory error rate per unit time.\n6.  **Error Propagation:** The effective physical error rate for any given cycle, $p_{eff}$, is the sum of the intrinsic error probability $p$ and the memory error probability $p_{mem}$ that was accumulated during the decoding phase of the *previous* cycle.\n7.  **Logical Error Rate:** The intrinsic logical error rate of the surface code, for a given effective physical error rate $p_{eff}$, is given by the formula $p_{L,int} = (c \\cdot p_{eff})^{\\frac{d+1}{2}}$, where $c$ is a constant accounting for the number of minimal-weight uncorrectable error paths.\n\nAssume that the system is run for many cycles and reaches a steady state where the effective physical error rate per cycle, $p_{eff}$, becomes constant. The total logical error rate per cycle, $p_L$, in this steady state is assumed to be dominated by the intrinsic failure probability of the code, evaluated at this steady-state effective physical error rate.\n\nDerive the expression for the steady-state logical error rate per cycle, $p_L$, as a function of the given parameters $p, d, c, \\tau_0, \\gamma,$ and $\\beta$.", "solution": "We derive the steady-state logical error rate per cycle, $ p_L $, using the given parameters and relationships.\n\n1. **Effective physical error rate ($ p_{eff} $):**\n   In steady state, the effective physical error rate per cycle is constant and satisfies:\n   \n$$\n   p_{eff} = p + p_{mem}\n   $$\n\n   where $ p $ is the intrinsic error probability per qubit, and $ p_{mem} $ is the memory error probability accumulated during the decoding of the previous cycle.\n\n2. **Memory error probability ($ p_{mem} $):**\n   The memory error probability is approximated as:\n   \n$$\n   p_{mem} = \\gamma T_{decode}\n   $$\n\n   where $ \\gamma $ is the memory error rate per unit time, and $ T_{decode} $ is the decoding time.\n\n3. **Decoding time ($ T_{decode} $):**\n   The decoding time is given by:\n   \n$$\n   T_{decode} = \\tau_0 \\bar{K}\n   $$\n\n   where $ \\tau_0 $ is a characteristic processing time constant, and $ \\bar{K} $ is the average number of defects.\n\n4. **Average number of defects ($ \\bar{K} $):**\n   The average number of defects is modeled as:\n   \n$$\n   \\bar{K} = \\beta d^2 p_{eff}\n   $$\n\n   where $ \\beta $ is a phenomenological constant, $ d $ is the code distance, and $ p_{eff} $ is the effective physical error rate.\n\n5. **Substitute expressions:**\n   Combining the above equations:\n   \n$$\n   T_{decode} = \\tau_0 \\beta d^2 p_{eff}\n   $$\n\n   \n$$\n   p_{mem} = \\gamma \\tau_0 \\beta d^2 p_{eff}\n   $$\n\n   Substituting into the equation for $ p_{eff} $:\n   \n$$\n   p_{eff} = p + \\gamma \\tau_0 \\beta d^2 p_{eff}\n   $$\n\n\n6. **Solve for $ p_{eff} $:**\n   Rearranging terms:\n   \n$$\n   p_{eff} - \\gamma \\tau_0 \\beta d^2 p_{eff} = p\n   $$\n\n   \n$$\n   p_{eff} (1 - \\gamma \\tau_0 \\beta d^2) = p\n   $$\n\n   \n$$\n   p_{eff} = \\frac{p}{1 - \\gamma \\tau_0 \\beta d^2}\n   $$\n\n   This requires $ \\gamma \\tau_0 \\beta d^2  1 $ for a valid steady state.\n\n7. **Logical error rate ($ p_L $):**\n   The intrinsic logical error rate is given by:\n   \n$$\n   p_{L} = (c \\cdot p_{eff})^{\\frac{d+1}{2}}\n   $$\n\n   where $ c $ is a constant, and $ d $ is odd.\n\n8. **Substitute $ p_{eff} $:**\n   \n$$\n   p_{L} = \\left( c \\cdot \\frac{p}{1 - \\gamma \\tau_0 \\beta d^2} \\right)^{\\frac{d+1}{2}}\n   $$", "answer": "$$\\boxed{ \\left( \\frac{c p}{1 - \\gamma \\tau_0 \\beta d^2} \\right)^{\\frac{d+1}{2}} }$$", "id": "177977"}]}