{"hands_on_practices": [{"introduction": "要真正理解切消定理的威力，最好的方法莫过于亲自动手实践其核心的归约步骤。我们首先从一个基本的情形开始：处理合取（$∧$）联结词上的主切。这个练习将展示如何将一个作用于复合公式 $A \\land B$ 上的切，转化为两个分别作用于其子公式 $A$ 和 $B$ 的更简单的切，并让你通过计算“秩”的减小来量化这一“简化”过程。", "problem": "考虑用于经典逻辑的 Gentzen 相继式演算 (LK)。一个相继式具有 $\\Gamma \\Rightarrow \\Delta$ 的形式，其中 $\\Gamma$ 和 $\\Delta$ 是（可能为空的）有限公式多重集。切规则和合取 ($\\land$) 规则由以下推理模式给出：\n$$\n\\frac{\\Gamma \\Rightarrow \\Delta, C \\qquad \\Gamma', C \\Rightarrow \\Delta'}{\\Gamma, \\Gamma' \\Rightarrow \\Delta, \\Delta'} \\quad (\\text{对 $C$ 的切})\n$$\n$$\n\\frac{\\Gamma \\Rightarrow \\Delta, A \\qquad \\Gamma \\Rightarrow \\Delta, B}{\\Gamma \\Rightarrow \\Delta, A \\land B} \\quad (\\land R)\n\\qquad\\qquad\n\\frac{\\Gamma, A, B \\Rightarrow \\Delta}{\\Gamma, A \\land B \\Rightarrow \\Delta} \\quad (\\land L)\n$$\n如果公式 $C$ 是切规则两个前提中最后一次推理的主公式，则称该切为对 $C$ 的主切。\n\n通过归纳法定义一个公式 $F$ 的复杂度（也称为阶）$c(F)$ 如下：\n- 对于每个原子命题变量 $p$，$c(p) = 0$，\n- $c(\\lnot F) = c(F) + 1$，\n- $c(F \\land G) = \\max\\{c(F), c(G)\\} + 1$，\n- $c(F \\lor G) = \\max\\{c(F), c(G)\\} + 1$，\n- $c(F \\to G) = \\max\\{c(F) + 1, c(G)\\} + 1$。\n\n一个推导的最大切阶是该推导中所有切规则实例的 $c(C)$ 的最大值，其中 $C$ 是该实例的切公式。\n\n构造以下关于 $A \\land B$ 的主切示例：\n$$\n\\frac{\n\\frac{\\Gamma \\Rightarrow \\Delta, A \\qquad \\Gamma \\Rightarrow \\Delta, B}{\\Gamma \\Rightarrow \\Delta, A \\land B}\\ (\\land R)\n\\qquad\n\\frac{\\Gamma', A, B \\Rightarrow \\Delta'}{\\Gamma', A \\land B \\Rightarrow \\Delta'}\\ (\\land L)\n}{\n\\Gamma, \\Gamma' \\Rightarrow \\Delta, \\Delta'\n}\\ \\text{(对 $A \\land B$ 的切)}\n$$\n通过给出归约后的推导，证明标准的切-归约步骤将这个对 $A \\land B$ 的主切替换为两个切，一个对 $A$，一个对 $B$。\n\n使用上述复杂度函数 $c(\\cdot)$，将 $A$ 和 $B$ 实例化为原子公式 $P$ 和 $Q$。计算此归约导致的最大切阶的严格减少量，即，对于给定示例，计算 $c_{\\text{before}}^{\\max} - c_{\\text{after}}^{\\max}$。将您的答案报告为一个精确整数。", "solution": "该问题要求分析证明论中 Gentzen 的 LK 相继式演算的一个主切归约步骤，并计算最大切阶的减少量。\n\n初始推导（我们记为 $\\mathcal{D}_1$）包含一次切规则的应用：\n$$\n\\frac{\n\\frac{\\Gamma \\Rightarrow \\Delta, A \\qquad \\Gamma \\Rightarrow \\Delta, B}{\\Gamma \\Rightarrow \\Delta, A \\land B}\\ (\\land R)\n\\qquad\n\\frac{\\Gamma', A, B \\Rightarrow \\Delta'}{\\Gamma', A \\land B \\Rightarrow \\Delta'}\\ (\\land L)\n}{\n\\Gamma, \\Gamma' \\Rightarrow \\Delta, \\Delta'\n}\\ \\text{(对 $A \\land B$ 的切)}\n$$\n这是一个主切，因为切公式 $A \\land B$ 是两个前提中最后一次推理的主公式：左边是 $(\\land R)$ 规则，右边是 $(\\land L)$ 规则。\n\n一个推导的最大切阶是该推导中任何切公式的最大复杂度。在 $\\mathcal{D}_1$ 中，只有一个切，其切公式为 $A \\land B$。因此，“之前”推导的最大切阶为：\n$$\nc_{\\text{before}}^{\\max} = c(A \\land B)\n$$\n使用所提供的合取复杂度定义，$c(F \\land G) = \\max\\{c(F), c(G)\\} + 1$，我们得到：\n$$\nc_{\\text{before}}^{\\max} = \\max\\{c(A), c(B)\\} + 1\n$$\n\n标准的归约步骤将这个对复合公式 $A \\land B$ 的单个切替换为其直接子公式 $A$ 和 $B$ 上的两个新切。归约后的推导（我们记为 $\\mathcal{D}_2$）如下：\n$$\n\\frac{\n\\Gamma \\Rightarrow \\Delta, B \\qquad \\frac{\\Gamma \\Rightarrow \\Delta, A \\qquad \\Gamma', A, B \\Rightarrow \\Delta'}{\\Gamma, \\Gamma', B \\Rightarrow \\Delta, \\Delta'}\\ \\text{(对 $A$ 的切)}\n}{\n\\Gamma, \\Gamma, \\Gamma' \\Rightarrow \\Delta, \\Delta, \\Delta'\n}\\ \\text{(对 $B$ 的切)}\n$$\n（注：问题中给出的归约后推导形式在技术上略有不同，但都实现了相同的目标。我们遵循切消证明的标准步骤，最终结果是一致的。最终结果可以通过缩并规则得到 $\\Gamma, \\Gamma' \\Rightarrow \\Delta, \\Delta'$。）\n\n这个新的推导 $\\mathcal{D}_2$ 有两个切，切公式分别是 $A$ 和 $B$。这个“之后”的推导的最大切阶是这两个切公式复杂度的最大值：\n$$\nc_{\\text{after}}^{\\max} = \\max\\{c(A), c(B)\\}\n$$\n这个归约步骤是切消定理归纳证明的关键组成部分。它表明，一个主切可以被消除，并被对复杂度严格更小的公式的切所取代。\n\n问题要求我们计算在 $A$ 和 $B$ 分别被实例化为原子公式 $P$ 和 $Q$ 的特定情况下，最大切阶的严格减少量 $c_{\\text{before}}^{\\max} - c_{\\text{after}}^{\\max}$。因此，我们设 $A = P$ 且 $B = Q$。\n\n根据所提供的复杂度定义，对于任何原子命题变量 $p$，其复杂度为 $c(p) = 0$。因此，我们有：\n$$\nc(A) = c(P) = 0\n$$\n$$\nc(B) = c(Q) = 0\n$$\n\n现在我们可以计算最大切阶的数值。\n对于“之前”的推导 $\\mathcal{D}_1$：\n$$\nc_{\\text{before}}^{\\max} = c(P \\land Q) = \\max\\{c(P), c(Q)\\} + 1 = \\max\\{0, 0\\} + 1 = 0 + 1 = 1\n$$\n\n对于“之后”的推导 $\\mathcal{D}_2$：\n$$\nc_{\\text{after}}^{\\max} = \\max\\{c(P), c(Q)\\} = \\max\\{0, 0\\} = 0\n$$\n\n最后，我们计算最大切阶的严格减少量：\n$$\nc_{\\text{before}}^{\\max} - c_{\\text{after}}^{\\max} = 1 - 0 = 1\n$$\n最大切阶的减少量为 $1$。这说明了切消过程工作的基本机制：用对较简单成分的切替换对复杂公式的切，从而降低一个良基的复杂度度量（切公式的阶）。", "answer": "$$\\boxed{1}$$", "id": "3056247"}, {"introduction": "在掌握了命题联结词的处理方法后，我们将进入一阶逻辑的领域，这里量词带来了新的挑战。本练习聚焦于存在量词（$\\exists$）的主切归约。你将看到证明论中一个非常精妙的机制：如何通过项代换来处理特征变量（eigenvariable），从而将关于量化公式的切问题，归约到关于其例化的更简单公式上。", "problem": "考虑 Gentzen 的经典逻辑相继式演算 (LK)，其中相继式写作 $\\Gamma \\Rightarrow \\Delta$，而 $\\Gamma$ 和 $\\Delta$ 是公式的多重集。左存在引入规则 $\\exists L$ 和右存在引入规则 $\\exists R$ 如下：\n$$\n\\frac{\\Gamma, A(a) \\Rightarrow \\Delta}{\\Gamma, \\exists x\\,A(x) \\Rightarrow \\Delta}\\ \\exists L\n\\qquad\n\\frac{\\Gamma \\Rightarrow \\Delta, A(t)}{\\Gamma \\Rightarrow \\Delta, \\exists x\\,A(x)}\\ \\exists R\n$$\n其中在 $\\exists L$ 中，符号 $a$ 是一个特征变元，它不在 $\\Gamma$ 或 $\\Delta$ 中自由出现，而 $t$ 是任意项。\n\n切规则是：\n$$\n\\frac{\\Gamma \\Rightarrow \\Delta, C \\qquad \\Sigma, C \\Rightarrow \\Pi}{\\Gamma, \\Sigma \\Rightarrow \\Delta, \\Pi}\\ \\mathrm{cut}\n$$\n\n设 $A(x)$ 是带有一个自由变元 $x$ 的任意一阶公式，设 $t$ 是任意项，并设 $\\Gamma, \\Delta, \\Sigma, \\Pi$ 是满足标准特征变元约束的任意上下文。假设你有一个推导，其左前提以 $\\exists R$ 规则结尾，从 $\\Sigma \\Rightarrow \\Pi, A(t)$ 生成 $\\Sigma \\Rightarrow \\Pi, \\exists x\\,A(x)$；其右前提以 $\\exists L$ 规则结尾，从 $\\Gamma, A(a) \\Rightarrow \\Delta$ 生成 $\\Gamma, \\exists x\\,A(x) \\Rightarrow \\Delta$。使用切公式 $\\exists x\\,A(x)$ 构造切，以得出结论 $\\Gamma, \\Sigma \\Rightarrow \\Delta, \\Pi$。\n\n对此配置中以 $\\exists x\\,A(x)$ 为切公式的切执行主切消解，明确指出实例化的切以及为使切公式匹配所需的对特征变元的任何代换。通过以下方式归纳定义公式 $B$ 的逻辑复杂度 $|B|$：\n- 对于原子公式 $P(u_1,\\dots,u_n)$，$|P(u_1,\\dots,u_n)| = 0$，\n- 对于任意二元联结词 $\\circ \\in \\{\\land,\\lor,\\rightarrow\\}$，$|B \\circ C| = |B| + |C| + 1$，\n- $|\\neg B| = |B| + 1$，\n- $|\\forall x\\,B| = |B| + 1$ 且 $|\\exists x\\,B| = |B| + 1$，\n并约定将项代换自由变元不改变复杂度，因此 $|A(t)| = |A(x)|$。\n\n执行主切消解后，计算切秩的净减少量 $\\Delta_{\\mathrm{rank}}$，其定义为原始切公式的复杂度与消解后切公式的复杂度之差。将你的最终答案表示为一个整数。", "solution": "该问题要求在 Gentzen 的相继式演算 LK 中执行一个主切消解步骤，并计算由此导致的切秩的减少量。\n\n初始推导涉及对公式 $C \\equiv \\exists x\\,A(x)$ 的切。此切的前提分别是 $\\exists R$ 规则和 $\\exists L$ 规则的结论，其中 $\\exists x\\,A(x)$ 在每个规则中都是主公式。这种配置被称为存在量词的主切。\n\n切规则给出如下：\n$$\n\\frac{\\Gamma' \\Rightarrow \\Delta', C \\qquad \\Sigma', C \\Rightarrow \\Pi'}{\\Gamma', \\Sigma' \\Rightarrow \\Delta', \\Pi'}\\ \\mathrm{cut}\n$$\n\n根据问题描述，主切的完整结构是：\n$$\n\\frac{\n    \\displaystyle\\frac{\\Sigma \\Rightarrow \\Pi, A(t)}{\\Sigma \\Rightarrow \\Pi, \\exists x\\,A(x)} \\exists R\n    \\qquad\n    \\displaystyle\\frac{\\Gamma, A(a) \\Rightarrow \\Delta}{\\Gamma, \\exists x\\,A(x) \\Rightarrow \\Delta} \\exists L\n}\n{\n    \\Sigma, \\Gamma \\Rightarrow \\Pi, \\Delta\n}\\ \\mathrm{cut}\n$$\n（注意：为遵循切规则的标准形式，我们调换了左右前提的顺序，但这不影响结果，因为上下文是多重集）。\n\n切消解的过程涉及将此证明转换为另一个具有相同末端相继式的证明，但其切具有更低的秩（即，作用于复杂度更低的公式）。\n\n设 $\\Gamma, A(a) \\Rightarrow \\Delta$ 的推导表示为 $\\mathcal{D}_a$。$\\exists L$ 规则要求 $a$ 是一个特征变元，这意味着它不能在结论相继式的上下文（即 $\\Gamma$ 或 $\\Delta$）中自由出现。这个条件确保了推导 $\\mathcal{D}_a$ 在结构上独立于 $a$ 的具体选择。我们可以在整个推导 $\\mathcal{D}_a$ 中将任意项代换所有自由出现的 $a$，并且仍然得到一个有效的推导。\n\n切消解的关键步骤是：将在 $\\exists R$ 规则中使用的项 $t$ 代换到 $\\exists L$ 规则推导中的特征变元 $a$。让我们将得到的推导表示为 $\\mathcal{D}_a[t/a]$。由于 $a$ 不在 $\\Gamma$ 或 $\\Delta$ 中自由出现，$\\mathcal{D}_a[t/a]$ 的结论是相继式 $\\Gamma, A(t) \\Rightarrow \\Delta$。\n\n现在，我们有两个可用的相继式，它们来自原始引入规则的前提，但已经进行了必要的代换：\n1. 导致 $\\exists R$ 前提的推导的结论：$\\Sigma \\Rightarrow \\Pi, A(t)$。\n2. 代换后的推导 $\\mathcal{D}_a[t/a]$ 的结论：$\\Gamma, A(t) \\Rightarrow \\Delta$。\n\n这两个相继式可以用作新切的前提，这次的切公式是 $A(t)$。消解后的推导是：\n$$\n\\frac{\n    \\overbrace{\\Sigma \\Rightarrow \\Pi, A(t)}^{\\text{来自原左前提的父推导}} \\qquad\n    \\overbrace{\\Gamma, A(t) \\Rightarrow \\Delta}^{\\text{来自经代换的右前提的父推导}}\n}{\n    \\Sigma, \\Gamma \\Rightarrow \\Pi, \\Delta\n}\\ \\mathrm{cut}\n$$\n这个新的推导结构证明了相同的末端相继式，但是将对 $\\exists x\\,A(x)$ 的切替换为了对 $A(t)$ 的切。\n\n问题将切秩定义为切公式的复杂度。我们现在计算这个秩的变化。\n原始切公式是 $C_{\\mathrm{orig}} = \\exists x\\,A(x)$。其复杂度 $|C_{\\mathrm{orig}}|$ 由归纳定义给出：\n$$ |C_{\\mathrm{orig}}| = |\\exists x\\,A(x)| = |A(x)| + 1 $$\n消解后推导中的新切公式是 $C_{\\mathrm{red}} = A(t)$。其复杂度是 $|C_{\\mathrm{red}}| = |A(t)|$。\n\n问题约定代换不改变复杂度，所以 $|A(x)| = |A(t)|$。我们用 $|A|$ 表示这个共同的复杂度值。\n因此，我们有：\n$$ |C_{\\mathrm{orig}}| = |A| + 1 $$\n$$ |C_{\\mathrm{red}}| = |A| $$\n\n切秩的净减少量 $\\Delta_{\\mathrm{rank}}$ 是原始切公式复杂度和消解后切公式复杂度之差：\n$$ \\Delta_{\\mathrm{rank}} = |C_{\\mathrm{orig}}| - |C_{\\mathrm{red}}| = (|A| + 1) - |A| = 1 $$\n主切消解使切秩减少了 $1$。", "answer": "$$\\boxed{1}$$", "id": "3056263"}, {"introduction": "最后，我们将通过一个综合性练习来巩固所学，该练习模拟了切消证明在处理复杂公式时的完整流程。现实世界中的逻辑公式常常包含嵌套的量词，如此处的 $\\forall x\\,\\exists y\\,A(x,y)$。这个练习将引导你分步完成对一个 $\\forall\\exists$ 型公式的切，让你体验如何组合运用前面学到的归约技巧，并要求你在此过程中仔细追踪特征变量和代换的细节。", "problem": "考虑一阶逻辑的经典双侧相继式演算（Gentzen 的 LK）。该语言包含一个常量符号 $a$、一元函数符号 $g$ 和 $w$，以及一个二元谓词符号 $A$。量词规则及其边条件如下，其中 $\\Gamma$ 和 $\\Delta$ 表示公式的（多重）集合，$t$ 表示任意项：\n\n- 全称右规则 ($\\forall R$)：从 $\\Gamma \\Rightarrow \\Delta, B(x:=\\alpha)$ 推导出 $\\Gamma \\Rightarrow \\Delta, \\forall x\\,B$，边条件是特征变元 $\\alpha$ 不在 $\\Gamma$ 或 $\\Delta$ 中自由出现。\n- 全称左规则 ($\\forall L$)：从 $B(x:=t), \\Gamma \\Rightarrow \\Delta$ 推导出 $\\forall x\\,B, \\Gamma \\Rightarrow \\Delta$。\n- 存在右规则 ($\\exists R$)：从 $\\Gamma \\Rightarrow \\Delta, B(y:=t)$ 推导出 $\\Gamma \\Rightarrow \\Delta, \\exists y\\,B$。\n- 存在左规则 ($\\exists L$)：从 $B(y:=\\beta), \\Gamma \\Rightarrow \\Delta$ 推导出 $\\exists y\\,B, \\Gamma \\Rightarrow \\Delta$，边条件是特征变元 $\\beta$ 不在 $\\Gamma$ 或 $\\Delta$ 中自由出现。\n\n切规则是：从 $\\Gamma \\Rightarrow \\Delta, C$ 和 $C, \\Sigma \\Rightarrow \\Pi$ 推导出 $\\Gamma, \\Sigma \\Rightarrow \\Delta, \\Pi$。\n\n设切公式为 $\\forall x\\,\\exists y\\,A(x,y)$。假设给定以下两个推导，其最后步骤是作为主公式引入该切公式：\n\n**左前提推导**（在右侧引入切公式）：\n一个推导，其结论为 $\\Gamma \\Rightarrow \\Delta, \\forall x\\,\\exists y\\,A(x,y)$。该推导的最后几步如下：\n1. 一个子推导，结论为 $\\Gamma \\Rightarrow \\Delta, A(\\alpha, w(\\alpha))$，其中 $\\alpha$ 是一个不在 $\\Gamma$ 或 $\\Delta$ 中自由出现的特征变元。\n2. 通过 $\\exists R$ 规则，使用项 $w(\\alpha)$，从上述结论推导出 $\\Gamma \\Rightarrow \\Delta, \\exists y\\,A(\\alpha,y)$。\n3. 通过 $\\forall R$ 规则，从上述结论推导出 $\\Gamma \\Rightarrow \\Delta, \\forall x\\,\\exists y\\,A(x,y)$。\n\n**右前提推导**（在左侧引入切公式）：\n一个推导，其结论为 $\\forall x\\,\\exists y\\,A(x,y), \\Sigma \\Rightarrow \\Pi$。该推导的最后几步如下：\n1. 一个子推导，结论为 $A(g(a),\\beta), \\Sigma \\Rightarrow \\Pi$，其中 $\\beta$ 是一个不在 $\\Sigma$ 或 $\\Pi$ 中自由出现的特征变元。\n2. 通过 $\\exists L$ 规则，从上述结论推导出 $\\exists y\\,A(g(a),y), \\Sigma \\Rightarrow \\Pi$。\n3. 通过 $\\forall L$ 规则，使用项 $g(a)$，从上述结论推导出 $\\forall x\\,\\exists y\\,A(x,y), \\Sigma \\Rightarrow \\Pi$。\n\n使用这两个推导的前提构成一个对 $\\forall x\\,\\exists y\\,A(x,y)$ 的主切，以推导出 $\\Gamma, \\Sigma \\Rightarrow \\Delta, \\Pi$。\n\n**任务**：执行切消定理所规定的主切归约步骤，仔细追踪所有边条件和显式替换，直到切公式变为原子公式。具体而言，你必须：\n- 首先，将对 $\\forall x\\,\\exists y\\,A(x,y)$ 的切，归约为一个对 $\\exists y\\,A(x,y)$ 的某个实例的切。\n- 然后，将所得的切，进一步歸约为一个对 $A(x,y)$ 的某个无量词实例的切。\n\n清晰地陈述此两步主归约序列所产生的最终原子切公式。", "solution": "我们将在 Gentzen 的 LK 系统内，对一个关于公式 $\\forall x\\,\\exists y\\,A(x,y)$ 的主切执行标准的切消归约步骤。\n\n初始的主切结构如下：\n$$\n\\frac{\n  \\overbrace{\\Gamma \\Rightarrow \\Delta, \\forall x\\,\\exists y\\,A(x,y)}^{\\text{左前提}}\n  \\qquad\n  \\overbrace{\\forall x\\,\\exists y\\,A(x,y), \\Sigma \\Rightarrow \\Pi}^{\\text{右前提}}\n}{\n  \\Gamma, \\Sigma \\Rightarrow \\Delta, \\Pi\n} (\\text{Cut})\n$$\n其中，左前提和右前提分别是由问题中描述的推导得出的。\n\n**第 1 步：对 $\\forall$ 的主归约**\n\n主切归约的第一步是处理最外层的量词，即全称量词 $\\forall$。\n- 左前提的推导最后一步是 $\\forall R$ 规则，它从 $\\Gamma \\Rightarrow \\Delta, \\exists y\\,A(\\alpha,y)$ 推导而来，其中 $\\alpha$ 是特征变元。\n- 右前提的推导第一步是 $\\forall L$ 规则，它使用了例化项 $g(a)$，其前提是 $\\exists y\\,A(g(a),y), \\Sigma \\Rightarrow \\Pi$。\n\n归约过程是将对 $\\forall x\\,\\exists y\\,A(x,y)$ 的切，替换为对更简单的公式 $\\exists y\\,A(g(a),y)$ 的切。这通过在左前提的整个推导中，将特征变元 $\\alpha$ 系统性地替换为右前提所用的项 $g(a)$ 来实现。\n- 左前提的推导源头是 $\\Gamma \\Rightarrow \\Delta, A(\\alpha, w(\\alpha))$。进行替换 $[\\alpha := g(a)]$ 后，它变为 $\\Gamma \\Rightarrow \\Delta, A(g(a), w(g(a)))$。\n- 整个左前提的推导经过替换后，其结论变为 $\\Gamma \\Rightarrow \\Delta, \\exists y\\,A(g(a),y)$。\n- 右前提的推导中 $\\forall L$ 规则的前提是 $\\exists y\\,A(g(a),y), \\Sigma \\Rightarrow \\Pi$。\n\n现在，原来的切被替换为一个新的、度更低的切：\n$$\n\\frac{\n  \\Gamma \\Rightarrow \\Delta, \\exists y\\,A(g(a),y)\n  \\qquad\n  \\exists y\\,A(g(a),y), \\Sigma \\Rightarrow \\Pi\n}{\n  \\Gamma, \\Sigma \\Rightarrow \\Delta, \\Pi\n} (\\text{Cut})\n$$\n这个新切的切公式是 $\\exists y\\,A(g(a),y)$。\n\n**第 2 步：对 $\\exists$ 的主归约**\n\n接下来，我们对上一步产生的新切进行第二次主归约，这次是针对存在量词 $\\exists$。\n- 新的左前提 $\\Gamma \\Rightarrow \\Delta, \\exists y\\,A(g(a),y)$ 是通过 $\\exists R$ 规则，从 $\\Gamma \\Rightarrow \\Delta, A(g(a), w(g(a)))$ 推导而来的。这里的见证项是 $w(g(a))$。\n- 新的右前提 $\\exists y\\,A(g(a),y), \\Sigma \\Rightarrow \\Pi$ 是通过 $\\exists L$ 规则，从 $A(g(a),\\beta), \\Sigma \\Rightarrow \\Pi$ 推导而来的，其中 $\\beta$ 是特征变元。\n\n归约过程是将对 $\\exists y\\,A(g(a),y)$ 的切，替换为对原子公式 $A(g(a), w(g(a)))$ 的切。这通过在右前提的整个推导中，将特征变元 $\\beta$ 系统性地替换为左前提所用的见证项 $w(g(a))$ 来实现。\n- 右前提的推导源头是 $A(g(a),\\beta), \\Sigma \\Rightarrow \\Pi$。进行替换 $[\\beta := w(g(a))]$ 后，它变为 $A(g(a),w(g(a))), \\Sigma \\Rightarrow \\Pi$。\n- 左前提的推导中 $\\exists R$ 规则的前提是 $\\Gamma \\Rightarrow \\Delta, A(g(a), w(g(a)))$。\n\n现在，切被再次替换，其切公式的复杂度进一步降低：\n$$\n\\frac{\n  \\Gamma \\Rightarrow \\Delta, A(g(a), w(g(a)))\n  \\qquad\n  A(g(a), w(g(a))), \\Sigma \\Rightarrow \\Pi\n}{\n  \\Gamma, \\Sigma \\Rightarrow \\Delta, \\Pi\n} (\\text{Cut})\n$$\n这个最终切的切公式是一个无量词的原子公式。\n\n**结论**\n\n经过两步主归约（先消除 $\\forall$，再消除 $\\exists$），最初对 $\\forall x\\,\\exists y\\,A(x,y)$ 的切被归约为一个对原子公式的切。这个最终的原子切公式是：\n$$A(g(a),w(g(a)))$$\n这个过程完美展示了切消定理如何通过系统性的替换（将项代入特征变元），将对复杂量化公式的切逐步“溶解”为对更简单实例的切。", "answer": "$$\\boxed{A(g(a),w(g(a)))}$$", "id": "3056281"}]}