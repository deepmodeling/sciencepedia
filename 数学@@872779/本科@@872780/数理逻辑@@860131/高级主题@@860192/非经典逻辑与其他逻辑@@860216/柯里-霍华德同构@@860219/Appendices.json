{"hands_on_practices": [{"introduction": "柯里-霍华德同构的核心思想是“命题即类型，证明即程序”。这个练习将此思想付诸实践，要求你为一个特定的逻辑命题——类型为 $((A \\to B) \\to (C \\to A) \\to (C \\to B))$——构造一个证明。这个过程将直观地展示如何将一个逻辑推理过程（即函数复合）精确地编码为一个 λ-项，从而让你亲手体验构建“证明-程序”的乐趣。[@problem_id:3056165]", "problem": "在简单类型lambda演算（STLC）的框架下，遵循Curry–Howard同构进行操作，其中命题即类型，证明即类型化lambda项。仅使用函数类型的核心定型规则，即箭头的蕴含引入和蕴含消除，以及避免捕获的替换和$\\beta$-归约的标准定义，完成以下任务。\n\n1. 构造一个居于类型 $(A \\to B) \\to (C \\to A) \\to (C \\to B)$ 的闭合lambda项 $t$。\n2. 从基本原理出发，通过一个形式化定型论证，仅使用函数引入和消除的定型规则来推导 $t$ 的类型。\n3. 设 $f : A \\to B$、$g : C \\to A$ 和 $x : C$ 为变量。通过一个显式的$\\beta$-归约序列，计算完全应用的项 $(t\\ f\\ g\\ x)$ 的$\\beta$-范式，并通过$\\beta$-归约和避免捕获的替换的定义来证明每一步的合理性。\n4. 将你的最终答案表示为 $(t\\ f\\ g\\ x)$ 的$\\beta$-范式的单一闭式解析表达式。\n\n无需进行数值计算。最终答案必须是标准lambda演算应用表示法中的单个符号表达式。不包含任何单位。不要写成方程；只给出最终的表达式。", "solution": "该问题是有效的，因为它定义明确，科学上基于简单类型lambda演算的形式系统，并且内部一致。我们按照问题陈述的要求，分三部分进行求解：项的构造、形式化定型推导和范式的计算。\n\n### 1. Lambda项的构造\n\n目标是构造一个居于（或具有）类型 $(A \\to B) \\to (C \\to A) \\to (C \\to B)$ 的闭合lambda项 $t$。该类型表示一个以柯里化方式接受三个参数的函数。我们可以通过分析该类型的结构来构造这个项。\n\n该类型为 $(A \\to B) \\to ((C \\to A) \\to (C \\to B))$。这是一个函数类型，所以项 $t$ 必须是一个lambda抽象。我们为其第一个参数引入一个绑定变量，称之为 $f$，其类型为 $A \\to B$。\n$$t = \\lambda f : A \\to B . \\text{body}_1$$\n这个抽象的体 $\\text{body}_1$ 必须具有类型 $(C \\to A) \\to (C \\to B)$。这同样是一个函数类型，所以 $\\text{body}_1$ 必须是另一个lambda抽象。我们为其参数引入一个绑定变量 $g$，其类型为 $C \\to A$。\n$$t = \\lambda f : A \\to B . \\lambda g : C \\to A . \\text{body}_2$$\n接下来的体 $\\text{body}_2$ 必须具有类型 $C \\to B$。这又是一个函数类型，需要第三个lambda抽象。我们为其参数引入一个绑定变量 $x$，其类型为 $C$。\n$$t = \\lambda f : A \\to B . \\lambda g : C \\to A . \\lambda x : C . \\text{body}_3$$\n此时，最终的体 $\\text{body}_3$ 必须具有类型 $B$。为了构造这个项，我们可以使用上下文中可用的变量：\n- $f : A \\to B$\n- $g : C \\to A$\n- $x : C$\n\n我们的目标是生成一个类型为 $B$ 的表达式。唯一能产生类型为 $B$ 的值的变量是 $f$，通过一次应用。函数 $f$ 需要一个类型为 $A$ 的参数。我们可以通过将函数 $g : C \\to A$ 应用于一个类型为 $C$ 的参数来产生一个类型为 $A$ 的项。我们有这样一个参数，即变量 $x : C$。\n应用 $(g\\ x)$ 是类型正确的，并得到一个类型为 $A$ 的项。\n现在，我们可以将这个项 $(g\\ x)$ 作为参数提供给 $f$。应用 $(f\\ (g\\ x))$ 是类型正确的，并得到一个类型为 $B$ 的项。这正是 $\\text{body}_3$ 所需的。\n\n将此代入我们的结构中，我们得到完整的闭合lambda项：\n$$t = \\lambda f : A \\to B . \\lambda g : C \\to A . \\lambda x : C . (f\\ (g\\ x))$$\n该项代表了两个函数的复合。\n\n### 2. 形式化定型推导\n\n我们现在使用蕴含引入（$\\to_I$）和蕴含消除（$\\to_E$）的核心定型规则来推导所构造的项 $t$ 的类型。规则如下：\n- 蕴含消除（$\\to_E$规则，或应用）：\n$$ \\frac{\\Gamma \\vdash M : T_1 \\to T_2 \\quad \\Gamma \\vdash N : T_1}{\\Gamma \\vdash (M\\ N) : T_2} $$\n- 蕴含引入（$\\to_I$规则，或抽象）：\n$$ \\frac{\\Gamma, v:T_1 \\vdash M : T_2}{\\Gamma \\vdash (\\lambda v:T_1 . M) : T_1 \\to T_2} $$\n\n让我们定义定型上下文序列：\n- $\\Gamma_0 = \\emptyset$ (空上下文)\n- $\\Gamma_1 = \\{ f : A \\to B \\}$\n- $\\Gamma_2 = \\{ f : A \\to B, g : C \\to A \\}$\n- $\\Gamma_3 = \\{ f : A \\to B, g : C \\to A, x : C \\}$\n\n推导过程如下，从最内层上下文 $\\Gamma_3$ 中的变量开始：\n1. 从上下文 $\\Gamma_3$ 中，我们可以推断出变量的类型（根据变量规则，或公理）：\n   - $\\Gamma_3 \\vdash f : A \\to B$\n   - $\\Gamma_3 \\vdash g : C \\to A$\n   - $\\Gamma_3 \\vdash x : C$\n2. 对步骤1中的项 $g$ 和 $x$ 使用 $\\to_E$ 规则：\n   $$ \\frac{\\Gamma_3 \\vdash g : C \\to A \\quad \\Gamma_3 \\vdash x : C}{\\Gamma_3 \\vdash (g\\ x) : A} $$\n3. 再次使用 $\\to_E$ 规则，这次是对步骤1中的项 $f$ 和步骤2中的项 $(g\\ x)$：\n   $$ \\frac{\\Gamma_3 \\vdash f : A \\to B \\quad \\Gamma_3 \\vdash (g\\ x) : A}{\\Gamma_3 \\vdash (f\\ (g\\ x)) : B} $$\n4. 现在，我们应用 $\\to_I$ 规则对 $x$ 进行抽象，从而消除假设 $x:C$ 并从上下文 $\\Gamma_3$ 移动到 $\\Gamma_2$：\n   $$ \\frac{\\Gamma_3 \\vdash (f\\ (g\\ x)) : B}{\\Gamma_2 \\vdash (\\lambda x : C . (f\\ (g\\ x))) : C \\to B} $$\n5. 我们再次应用 $\\to_I$ 规则对 $g$ 进行抽象，从而消除假设 $g:C \\to A$ 并从上下文 $\\Gamma_2$ 移动到 $\\Gamma_1$：\n   $$ \\frac{\\Gamma_2 \\vdash (\\lambda x : C . (f\\ (g\\ x))) : C \\to B}{\\Gamma_1 \\vdash (\\lambda g : C \\to A . \\lambda x : C . (f\\ (g\\ x))) : (C \\to A) \\to (C \\to B)} $$\n6. 最后，我们最后一次应用 $\\to_I$ 规则对 $f$ 进行抽象，从而消除假设 $f:A \\to B$ 并从上下文 $\\Gamma_1$ 移动到空上下文 $\\Gamma_0$：\n   $$ \\frac{\\Gamma_1 \\vdash (\\lambda g : C \\to A . \\lambda x : C . (f\\ (g\\ x))) : (C \\to A) \\to (C \\to B)}{\\Gamma_0 \\vdash (\\lambda f : A \\to B . \\lambda g : C \\to A . \\lambda x : C . (f\\ (g\\ x))) : (A \\to B) \\to (C \\to A) \\to (C \\to B)} $$\n这完成了该项 $t$ 具有指定类型的形式化证明。\n\n### 3. $\\beta$-范式的计算\n\n我们被要求计算项 $(t\\ f\\ g\\ x)$ 的$\\beta$-范式，其中 $t$ 是我们构造的项，而 $f : A \\to B$、$g : C \\to A$ 和 $x : C$ 是给定的变量。\n\n为了避免 $t$ 中的绑定变量与我们正在应用的自由变量 $f$、$g$ 和 $x$ 混淆，我们将 $t$ 中的绑定变量用撇号表示：\n$$t = \\lambda f' : A \\to B . \\lambda g' : C \\to A . \\lambda x' : C . (f'\\ (g'\\ x'))$$\n待归约的项是 $(((t\\ f)\\ g)\\ x)$，因为应用是左结合的。\n\n$\\beta$-归约的定义是 $(\\lambda v. E)\\ M \\to_\\beta E[v \\leftarrow M]$，其中 $E[v \\leftarrow M]$ 表示将 $M$ 避免捕获地替换到 $E$ 中所有 $v$ 的自由出现。\n\n**步骤 1：第一次 $\\beta$-归约**\n最外层的项是 $(t\\ f)$，它是一个$\\beta$-可归约式：\n$$(t\\ f) = (\\lambda f' : A \\to B . \\lambda g' : C \\to A . \\lambda x' : C . (f'\\ (g'\\ x')))\\ f$$\n我们将抽象体中的 $f'$ 替换为 $f$：\n$$ \\to_\\beta (\\lambda g' : C \\to A . \\lambda x' : C . (f'\\ (g'\\ x')))[f' \\leftarrow f] $$\n$$ = \\lambda g' : C \\to A . \\lambda x' : C . (f\\ (g'\\ x')) $$\n该替换是有效的，因为变量 $f$ 没有自由变量可以被绑定符 $\\lambda g'$ 或 $\\lambda x'$ 捕获。\n此步骤后，完整的表达式变为：\n$$(((\\lambda g' . \\lambda x' . (f\\ (g'\\ x')))\\ g)\\ x)$$\n\n**步骤 2：第二次 $\\beta$-归约**\n下一个可归约式是应用于 $g$ 的部分：\n$$((\\lambda g' : C \\to A . \\lambda x' : C . (f\\ (g'\\ x')))\\ g)$$\n我们在体 $\\lambda x' : C . (f\\ (g'\\ x'))$ 中将 $g'$ 替换为 $g$：\n$$ \\to_\\beta (\\lambda x' : C . (f\\ (g'\\ x')))[g' \\leftarrow g] $$\n$$ = \\lambda x' : C . (f\\ (g\\ x')) $$\n同样，该替换是避免捕获的，因为 $g$ 没有自由变量可以被 $\\lambda x'$ 捕获。\n此时完整的表达式为：\n$$(\\lambda x' : C . (f\\ (g\\ x')))\\ x$$\n\n**步骤 3：第三次也是最后一次 $\\beta$-归约**\n最后的表达式是一个可归约式：\n$$(\\lambda x' : C . (f\\ (g\\ x')))\\ x$$\n我们在体 $(f\\ (g\\ x'))$ 中将 $x'$ 替换为 $x$：\n$$ \\to_\\beta (f\\ (g\\ x'))[x' \\leftarrow x] $$\n$$ = (f\\ (g\\ x)) $$\n该替换是安全的。结果项是 $(f\\ (g\\ x))$。该项处于$\\beta$-范式，因为它是一个应用，其头部 $f$ 是一个变量，而不是一个lambda抽象。因此，不可能再进行$\\beta$-归约。\n\n显式的归约序列是：\n$$((( \\lambda f' . \\lambda g' . \\lambda x' . (f'\\ (g'\\ x')) )\\ f )\\ g )\\ x$$\n$$ \\to_\\beta ((\\lambda g' . \\lambda x' . (f\\ (g'\\ x')))\\ g)\\ x $$\n$$ \\to_\\beta (\\lambda x' . (f\\ (g\\ x')))\\ x $$\n$$ \\to_\\beta (f\\ (g\\ x)) $$\n$(t\\ f\\ g\\ x)$ 的最终$\\beta$-范式是 $(f\\ (g\\ x))$，这直观上对应于将 $f$ 和 $g$ 的复合函数应用于参数 $x$。", "answer": "$$\\boxed{(f\\ (g\\ x))}$$", "id": "3056165"}, {"introduction": "在构造了“证明-程序”之后，下一步是理解其计算行为，这在逻辑上对应于证明的化简或规范化。本练习专注于 λ-演算的核心计算规则：$\\beta$-归约。通过系统地对一个嵌套的、复杂的 λ-项进行归约，你将练习证明规范化的基本功，并见证一个复杂的证明如何通过一系列计算步骤被化简为其最简洁的形式。[@problem_id:3056182]", "problem": "在简单类型lambda演算（STLC）中，Curry-Howard 对应将函数类型 $A \\to B$ 与逻辑蕴含 $A \\Rightarrow B$ 等同起来，并将 lambda 项与证明等同起来。STLC 的一个基本运算原理是 $\\beta$-归约，它通过将参数代入函数体来执行计算。以此原理为基础，对一个编码了证明变换的闭合计算进行范式化。在一个具有单一基本类型 $A$ 和一个类型为 $A$ 的单一变量 $a$ 的上下文中进行操作。\n\n考虑以下项\n$$\nt \\;=\\; (\\lambda h^{A\\to A\\to A}.\\,\\lambda f^{A\\to A}.\\,\\lambda x^{A}.\\,h\\,(f\\,x)\\,x)\\,(\\lambda u^{A}.\\,\\lambda v^{A}.\\,u)\\,(\\lambda w^{A}.\\,w)\\,a.\n$$\n这里，$(\\lambda u^{A}.\\,\\lambda v^{A}.\\,u)$ 是一个返回其第一个参数的选择器（$\\mathbf{K}$ 组合子的类型化版本），$(\\lambda w^{A}.\\,w)$ 是 $A$ 上的恒等函数，而 $a$ 是一个类型为 $A$ 的变量。\n\n任务：仅使用 STLC 类型和 $\\beta$-归约的基本定义，计算一个完整的 $\\beta$-归约序列，将 $t$ 转化为其范式。将您的最终答案表示为完全范式化的 lambda 项。无需四舍五入，也不涉及物理单位。", "solution": "该问题要求使用 $\\beta$-归约对简单类型lambda演算（STLC）中的一个给定项进行范式化。该问题是良定义的，科学上是合理的，并且所有必要的组成部分都已提供。STLC 是强范式化的，这保证了任何 $\\beta$-归约序列都将终止于一个唯一的范式。我们将通过应用一系列 $\\beta$-归约来进行，遵循正则序策略（在每一步归约最左最外的归约基），直到没有归约基为止。一个 $\\beta$-归约基是形如 $(\\lambda x^T.\\,M)\\,N$ 的项，其归约结果是项 $M[x:=N]$，这表示用项 $N$ 替换项 $M$ 中变量 $x$ 的所有自由出现。\n\n需要被范式化的初始项是：\n$$t_0 \\;=\\; (\\lambda h^{A\\to A\\to A}.\\,\\lambda f^{A\\to A}.\\,\\lambda x^{A}.\\,h\\,(f\\,x)\\,x)\\,(\\lambda u^{A}.\\,\\lambda v^{A}.\\,u)\\,(\\lambda w^{A}.\\,w)\\,a$$\n\n根据应用的左结合性，该项被解析为：\n$$ t_0 \\;=\\; (((\\lambda h^{A\\to A\\to A}.\\,\\lambda f^{A\\to A}.\\,\\lambda x^{A}.\\,h\\,(f\\,x)\\,x)\\,(\\lambda u^{A}.\\,\\lambda v^{A}.\\,u))\\,(\\lambda w^{A}.\\,w))\\,a $$\n\n步骤 1：最左最外的归约基是第一个抽象 $(\\lambda h^{A\\to A\\to A}.\\dots)$ 应用于项 $(\\lambda u^{A}.\\,\\lambda v^{A}.\\,u)$。我们将 $(\\lambda u^{A}.\\,\\lambda v^{A}.\\,u)$ 代入第一个抽象的函数体中以替换 $h$。\n$$ t_0 \\rightarrow_{\\beta} ((\\lambda f^{A\\to A}.\\,\\lambda x^{A}.\\,(\\lambda u^{A}.\\,\\lambda v^{A}.\\,u)\\,(f\\,x)\\,x)\\,(\\lambda w^{A}.\\,w))\\,a $$\n我们将这个新项称为 $t_1$。\n\n步骤 2：$t_1$ 中最左最外的归约基是项 $(\\lambda f^{A\\to A}.\\dots)$ 应用于 $(\\lambda w^{A}.\\,w)$。我们将 $(\\lambda w^{A}.\\,w)$ 代入主抽象的函数体中以替换 $f$。\n$$ t_1 \\rightarrow_{\\beta} (\\lambda x^{A}.\\,(\\lambda u^{A}.\\,\\lambda v^{A}.\\,u)\\,((\\lambda w^{A}.\\,w)\\,x)\\,x)\\,a $$\n我们将这个新项称为 $t_2$。\n\n步骤 3：$t_2$ 中最左最外的归约基是项 $(\\lambda x^{A}.\\dots)$ 应用于 $a$。我们将 $a$ 代入抽象的函数体中以替换 $x$。\n$$ t_2 \\rightarrow_{\\beta} (\\lambda u^{A}.\\,\\lambda v^{A}.\\,u)\\,((\\lambda w^{A}.\\,w)\\,a)\\,a $$\n我们将这个新项称为 $t_3$。\n\n步骤 4：项 $t_3$ 被解析为 $((\\lambda u^{A}.\\,\\lambda v^{A}.\\,u)\\,((\\lambda w^{A}.\\,w)\\,a))\\,a$。最左最外的归约基是选择器组合子 $(\\lambda u^{A}.\\,\\lambda v^{A}.\\,u)$ 应用于其第一个参数，即项 $((\\lambda w^{A}.\\,w)\\,a)$。归约操作将此参数代入函数体 $\\lambda v^{A}.\\,u$ 中以替换 $u$。\n$$ t_3 \\rightarrow_{\\beta} (\\lambda v^{A}.\\,((\\lambda w^{A}.\\,w)\\,a))\\,a $$\n我们将这个新项称为 $t_4$。请注意，此替换不会导致变量捕获，因为 $v$ 在被代入的项中不是自由变量。\n\n步骤 5：项 $t_4$ 本身就是一个归约基。我们将 $a$ 代入函数体 $((\\lambda w^{A}.\\,w)\\,a)$ 中以替换 $v$。由于 $v$ 在函数体中没有自由出现，该替换实际上丢弃了参数 $a$ 并返回函数体本身。\n$$ t_4 \\rightarrow_{\\beta} (\\lambda w^{A}.\\,w)\\,a $$\n我们将这个新项称为 $t_5$。\n\n步骤 6：项 $t_5$ 是一个归约基，对应于恒等函数应用于项 $a$。我们将 $a$ 代入函数体 $w$ 中以替换 $w$。\n$$ t_5 \\rightarrow_{\\beta} a $$\n结果项 $a$ 是一个变量。它不包含任何 $\\beta$-归约基，因此处于范式。\n\n归约序列已经终止。Curry-Howard 对应允许将此范式化过程解释为一种证明变换。初始项 $t_0$ 是命题 $A$ 的一个复杂证明，它基于一个假设 $A$ 为真（由变量 $a:A$ 表示）而构造。$\\beta$-归约的过程逐步简化此证明，最终揭示整个构造归约为原始假设。范式化后的项 $a$ 是在此上下文中 $A$ 的最简单可能证明。", "answer": "$$\\boxed{a}$$", "id": "3056182"}, {"introduction": "一个可靠的逻辑系统必须是自洽的，柯里-霍华德同构揭示了这与编程语言中的类型安全（Type Safety）性质直接相关。这个练习是一个思想实验，旨在加深你对这一点的理解。通过特意引入一个破坏类型安全的规则，本练习将引导你构造一个“卡住”的项，从而揭示类型保持（Preservation）等性质为何是保证逻辑一致性的基石，而非可有可无的理论装饰。[@problem_id:3056147]", "problem": "考虑在柯里-霍华德同构（Curry-Howard correspondence, CHC）下的简单类型lambda演算的一个片段，其中类型对应于命题，项对应于证明。该语言具有基本类型 $\\mathsf{Bool}$ 和 $\\mathsf{Nat}$，常量 $0$、$\\mathsf{true}$、$\\mathsf{false}$，以及用于自然数的一元构造子 $\\mathsf{succ}\\, t$。类型规则包括 $\\Gamma \\vdash 0 : \\mathsf{Nat}$、$\\Gamma \\vdash \\mathsf{true} : \\mathsf{Bool}$、$\\Gamma \\vdash \\mathsf{false} : \\mathsf{Bool}$，以及若 $\\Gamma \\vdash t : \\mathsf{Nat}$ 则 $\\Gamma \\vdash \\mathsf{succ}\\, t : \\mathsf{Nat}$。小步操作语义包括后继符的标准求值上下文规则：若 $t \\to t'$，则 $\\mathsf{succ}\\, t \\to \\mathsf{succ}\\, t'$。值被归纳定义为 $v ::= 0 \\mid \\mathsf{succ}\\, v \\mid \\mathsf{true} \\mid \\mathsf{false}$。\n\n用一条额外的、非类型保持的归约系统来扩充该归约系统：\n$$\n0 \\to \\mathsf{true}.\n$$\n仅使用上述基本定义以及未经修改的系统中广为接受的进展性（progress）和保持性（preservation）作为基础，构造一个闭合的、类型良好的项，该项在扩充的归约系统下，会归约到一个既不是值也无法通过任何规则进行归约的项（一个停滞项）。从第一性原理出发，精确解释在添加这条非类型保持的规则后，CHC和类型规程下出现了什么问题，并推导出由所添加规则驱动的单步上下文步骤所产生的显式停滞项。你的最终答案必须是作为单个符号数学表达式的显式停滞项。无需进行四舍五入或使用物理单位。", "solution": "该问题陈述被评估为有效。它提出了一个基于简单类型lambda演算的、定义明确的形式系统，并要求分析用一个特定的、非类型保持的归约规则来扩充该系统所带来的后果。该问题在科学上植根于类型论和操作语义的原理，内部一致，并要求基于所提供的定义进行严格的推导。\n\n一个可靠的类型演算的基础，并延伸至柯里-霍华德同构（CHC），依赖于类型安全这一属性。类型安全通常由两个关键定理来确立：保持性（preservation）和进展性（progress）。该问题假设了一个系统，其中已知的、拥有这些性质的标准简单类型lambda演算，被一条破坏此基础的规则所扩充。\n\n让我们正式陈述这些关键原则：\n1.  **保持性（主语归约）：** 如果一个项 $t$ 在上下文 $\\Gamma$ 中是类型为 $T$ 的类型良好项（记为 $\\Gamma \\vdash t : T$），并且它一步归约到一个项 $t'$（记为 $t \\to t'$），那么 $t'$ 也必须是类型为 $T$ 的类型良好项（即 $\\Gamma \\vdash t' : T$）。该定理确保了计算会保持表达式的类型。\n2.  **进展性：** 对于任意闭合的、类型良好的项 $t$（即，对于某个类型 $T$ 有 $\\emptyset \\vdash t : T$），要么 $t$ 是一个值，要么存在一个项 $t'$ 使得 $t \\to t'$。该定理确保了一个类型良好的程序永远不会在非终止状态下“卡住”。\n\n该问题引入了归约规则 $0 \\to \\mathsf{true}$。让我们在保持性属性的背景下分析这条规则。\n根据给定的类型规则：\n-   项 $0$ 的类型是 $\\mathsf{Nat}$，形式上为 $\\Gamma \\vdash 0 : \\mathsf{Nat}$。\n-   项 $\\mathsf{true}$ 的类型是 $\\mathsf{Bool}$，形式上为 $\\Gamma \\vdash \\mathsf{true} : \\mathsf{Bool}$。\n\n归约 $0 \\to \\mathsf{true}$ 将一个类型为 $\\mathsf{Nat}$ 的项转换为一个类型为 $\\mathsf{Bool}$ 的项。由于 $\\mathsf{Nat} \\neq \\mathsf{Bool}$，这条规则明确违反了保持性定理。单步归约改变了项的类型，这在类型安全的系统中是被禁止的。\n\n问题的核心是展示这种对保持性的违反如何导致对进展性定理的违反。我们需要构造一个闭合的、类型良好的项，它会归约到一个“停滞”状态——一个既不是值也无法应用任何归约规则的项。\n\n我们可以利用给定归约语义的上下文敏感性。该问题提供了一个构造子 $\\mathsf{succ}$ 和一个相应的求值上下文规则：若 $t \\to t'$，则 $\\mathsf{succ}\\, t \\to \\mathsf{succ}\\, t'$。该规则允许在 $\\mathsf{succ}$ 构造子内部的项上进行归约。为了使项 $\\mathsf{succ}\\, t$ 类型良好，其参数 $t$ 必须具有类型 $\\mathsf{Nat}$。\n\n让我们使用这个结构来构造一个项。\n1.  从类型为 $\\mathsf{Nat}$ 的最简单的项开始：常量 $0$。根据给定的类型规则，我们有 $\\emptyset \\vdash 0 : \\mathsf{Nat}$。\n2.  将 $\\mathsf{succ}$ 构造子应用于此项。$\\mathsf{succ}$ 的类型规则规定，若 $\\Gamma \\vdash t : \\mathsf{Nat}$，则 $\\Gamma \\vdash \\mathsf{succ}\\, t : \\mathsf{Nat}$。应用此规则，因为我们有 $\\emptyset \\vdash 0 : \\mathsf{Nat}$，我们可以推导出 $\\emptyset \\vdash \\mathsf{succ}\\, 0 : \\mathsf{Nat}$。\n3.  因此，项 $\\mathsf{succ}\\, 0$ 是一个闭合的、类型良好的项。\n\n现在，我们来分析这个项在扩充系统中的归约过程。\n-   我们的起始项是 $\\mathsf{succ}\\, 0$。\n-   该系统包括 $\\mathsf{succ}$ 的求值上下文规则：若 $t \\to t'$，则 $\\mathsf{succ}\\, t \\to \\mathsf{succ}\\, t'$。\n-   该系统还包括非类型保持的规则 $0 \\to \\mathsf{true}$。\n-   我们可以通过令 $t = 0$ 和 $t' = \\mathsf{true}$ 来应用上下文规则。上下文规则的前提，$0 \\to \\mathsf{true}$，是满足的。\n-   因此，我们推导出一单步归约：$\\mathsf{succ}\\, 0 \\to \\mathsf{succ}\\, \\mathsf{true}$。\n\n类型良好的项 $\\mathsf{succ}\\, 0$ 归约到了项 $\\mathsf{succ}\\, \\mathsf{true}$。现在让我们分析这个结果项，以确定它是否停滞。\n1.  **$\\mathsf{succ}\\, \\mathsf{true}$ 是一个值吗？** 值的定义被给出为 $v ::= 0 \\mid \\mathsf{succ}\\, v \\mid \\mathsf{true} \\mid \\mathsf{false}$。对于一个形如 $\\mathsf{succ}\\, t$ 的项要成为一个值，$t$ 本身必须是一个形如 $0$ 或 $\\mathsf{succ}\\, v'$ 的值。在我们的例子中，$\\mathsf{succ}$ 的参数是 $\\mathsf{true}$。虽然 $\\mathsf{true}$ 是一个值，但根据自然数的归纳结构（$v_{nat} ::= 0 \\mid \\mathsf{succ}\\, v_{nat}$），它不是一个自然数值。因此，项 $\\mathsf{succ}\\, \\mathsf{true}$ 不匹配值的模式。它不是一个值。\n\n2.  **$\\mathsf{succ}\\, \\mathsf{true}$ 可以被归约吗？** 我们必须检查是否有任何归约规则适用。\n    -   唯一适用于以 $\\mathsf{succ}$ 开头的项的规则是上下文规则：若 $t \\to t'$，则 $\\mathsf{succ}\\, t \\to \\mathsf{succ}\\, t'$。为了让这条规则应用于 $\\mathsf{succ}\\, \\mathsf{true}$，内部项 $\\mathsf{true}$ 必须能够进行一步归约。\n    -   然而，$\\mathsf{true}$ 是一个值。根据定义，值是计算的终止形式，没有进一步的归约。\n    -   由于内部项 $\\mathsf{true}$ 无法被归约，上下文规则的前提不被满足。\n    -   没有定义其他可以匹配结构 $\\mathsf{succ}\\, \\mathsf{true}$ 的归约规则。\n\n项 $\\mathsf{succ}\\, \\mathsf{true}$ 不是一个值，且没有任何归约规则可以应用于它。根据定义，它是一个停滞项。\n\n总而言之，类型良好的项 $\\mathsf{succ}\\,0$ 归约到了停滞项 $\\mathsf{succ}\\,\\mathsf{true}$。这构成了对进展性定理的违反。这个失败是由于规则 $0 \\to \\mathsf{true}$ 违反了保持性定理的直接后果。在柯里-霍华德同构下，这意味着逻辑一致性的崩溃。命题 $\\mathsf{Nat}$ 的“证明” $\\mathsf{succ}\\,0$ 被转换成 $\\mathsf{succ}\\,\\mathsf{true}$，这是一个无意义的构造，它在原始系统中既不对应于一个有效的证明，也不对应于一个命题。它代表了证明规格化过程中的失败，而证明规格化是计算在逻辑上的对应物。推导出的停滞项是这个系统性失败的显式产物。", "answer": "$$\n\\boxed{\\mathsf{succ}\\,\\mathsf{true}}\n$$", "id": "3056147"}]}