{"hands_on_practices": [{"introduction": "爆炸原理并非一个孤立的公理，而是源于逻辑系统（如直觉主义或经典逻辑）中更基本的推理规则。通过在 Gentzen 的直觉主义相继式演算（LJ）中构造一个证明，本练习揭示了爆炸原理是如何从蕴含（$\\to$）和谬误（$\\bot$）的规则中自然产生的 [@problem_id:3057338]。掌握这种推导有助于我们从根本上理解为什么在这些逻辑中，从矛盾可以推导出任何事物。", "problem": "您正在使用根岑（Gentzen）的直觉主义相继式演算（LJ），其中相继式的形式为 $\\Gamma \\Rightarrow C$，$C$ 是单个后件，$\\Gamma$ 是一个公式的有限多重集。假设否定被定义为缩写 $\\neg A := A \\to \\bot$，其中 $\\to$ 和 $\\bot$ 是本问题中提到的仅有的原始逻辑常数。背景系统中可用的标准原始规则是同一性公理（$A \\Rightarrow A$）、切割规则、左侧的结构规则（左弱化、左收缩、交换），以及针对 $\\to$ 和 $\\bot$ 的常规逻辑规则，包括 $\\to L$、$\\to R$ 和 $\\bot L$。由于 $\\neg$ 是通过 $\\to$ 和 $\\bot$ 定义的，因此不假定存在针对 $\\neg$ 的原始规则。\n\n您的任务是从以下选项中，找出一个足以推导出相继式 $A, \\neg A \\Rightarrow B$（对于任意公式 $A$ 和 $B$）的最小相继式规则集，并正确评估在推导过程中是否需要左收缩规则。“最小”在这里指的是，从该集合中移除任何一条规则都将使得在此框架内无法完成推导。\n\n哪个选项正确地指出了这样一个最小集，并正确地说明了是否需要左收缩规则？\n\nA. 同一性公理（$A \\Rightarrow A$）、$\\to L$、$\\bot L$；不需要左收缩规则。\n\nB. 同一性公理（$A \\Rightarrow A$）、$\\to L$、$\\bot L$、切割规则；不需要左收缩规则。\n\nC. 同一性公理（$A \\Rightarrow A$）、$\\to L$、$\\bot L$；需要左收缩规则来重用 $A$。\n\nD. 同一性公理（$A \\Rightarrow A$）、$\\to L$；左收缩规则和切割规则足以替代 $\\bot L$。\n\nE. 同一性公理（$A \\Rightarrow A$）、$\\bot L$、左弱化规则；不需要左收缩规则。", "solution": "用户要求对一个关于根岑（Gentzen）直觉主义相继式演算（LJ）的问题进行分析。任务是确定推导相继式 $A, \\neg A \\Rightarrow B$（对于任意公式 $A$ 和 $B$）所需的最小规则集，并评估左收缩规则的必要性。\n\n### 第1步：问题验证\n\n首先，我将验证问题陈述。\n\n**提取的已知条件：**\n*   **逻辑系统：** 根岑的直觉主义相继式演算（LJ）。\n*   **相继式形式：** $\\Gamma \\Rightarrow C$，其中 $\\Gamma$ 是一个公式的有限多重集，$C$ 是单个公式。\n*   **否定定义：** $\\neg A$ 是 $A \\to \\bot$ 的缩写。\n*   **原始逻辑常数：** 蕴含联结词 $\\to$ 和谬误常数 $\\bot$。\n*   **假定的原始规则：**\n    *   同一性公理：$A \\Rightarrow A$。\n    *   切割规则：$\\frac{\\Gamma \\Rightarrow D \\quad \\Delta, D \\Rightarrow C}{\\Gamma, \\Delta \\Rightarrow C}$。\n    *   结构规则（左）：弱化（WL），收缩（CL），交换。\n    *   逻辑规则：\n        *   左蕴含（$\\to L$）：$\\frac{\\Gamma \\Rightarrow A \\quad \\Delta, B \\Rightarrow C}{\\Gamma, \\Delta, A \\to B \\Rightarrow C}$。\n        *   右蕴含（$\\to R$）：$\\frac{\\Gamma, A \\Rightarrow B}{\\Gamma \\Rightarrow A \\to B}$。\n        *   左谬误（$\\bot L$）：$\\frac{}{\\bot, \\Gamma \\Rightarrow C}$。\n*   **目标相继式：** $A, \\neg A \\Rightarrow B$，对于任意公式 $A$ 和 $B$。\n*   **最小性条件：** 规则集必须是“最小的”，意味着从集合中移除任何规则都会使推导变得不可能。\n\n**验证结论：**\n该问题定义明确、有科学依据且客观。这是数理逻辑的一个分支——证明论中的一个标准练习。所提供的规则是 LJ 的标准规则。问题精确而无歧义。\n1.  **科学合理性：** 该问题设置在 LJ 的形式框架内，使用标准的定义和规则。它在事实上是合理的。\n2.  **可形式化性：** 该问题本质上是形式化和数学化的。\n3.  **完备性：** 该问题提供了所有必要信息（系统、规则、目标）。\n4.  **可行性：** 该问题是理论性的，不涉及物理约束。\n5.  **适定性：** 该问题要求为一次推导找到一个最小规则集，这是一个有确定答案的问题，可以通过尝试构造证明来确定。\n\n问题有效。我现在将进行推导和分析。\n\n### 第2步：相继式的推导\n\n目标是推导相继式 $A, \\neg A \\Rightarrow B$。\n首先，我们将已定义的符号 $\\neg A$ 替换为其定义 $A \\to \\bot$。要推导的相继式变为：\n$$\nA, A \\to \\bot \\Rightarrow B\n$$\n我们从这个结论（树的根）开始，通过向上回溯的方式构造证明树。\n\n前件包含公式 $A \\to \\bot$，其主要联结词是 $\\to$。唯一可以应用于分解前件中该公式的规则是左蕴含（$\\to L$）规则。\n$\\to L$ 规则是：\n$$\n\\frac{\\Gamma \\Rightarrow A \\quad \\Delta, B \\Rightarrow C}{\\Gamma, \\Delta, A \\to B \\Rightarrow C}\n$$\n为了将此规则应用于我们的目标相继式 $A, A \\to \\bot \\Rightarrow B$，我们进行以下替换：\n*   规则中的主公式 $A \\to B$ 对应于我们相继式中的 $A \\to \\bot$。\n*   后件 $C$ 对应于 $B$。\n*   我们前件 $A, A \\to \\bot \\Rightarrow B$ 中的旁公式 $A$ 必须在前提的上下文 $\\Gamma$ 和 $\\Delta$ 之间进行划分。设旁公式的多重集为 $\\Xi = \\{A\\}$。我们需要找到 $\\Gamma$ 和 $\\Delta$，使得它们的多重集并集为 $\\Xi$。两种可能性是 $(\\Gamma = \\{A\\}, \\Delta = \\emptyset)$ 或 $(\\Gamma = \\emptyset, \\Delta = \\{A\\})$。\n\n**可能性1：** 设 $\\Gamma = \\{A\\}$ 且 $\\Delta = \\emptyset$。\n规则应用如下：\n$$\n\\frac{A \\Rightarrow A \\quad \\emptyset, \\bot \\Rightarrow B}{A, \\emptyset, A \\to \\bot \\Rightarrow B} (\\to L)\n$$\n这简化为：\n$$\n\\frac{A \\Rightarrow A \\quad \\bot \\Rightarrow B}{A, A \\to \\bot \\Rightarrow B} (\\to L)\n$$\n现在我们必须检查前提（线上方的相继式）是否可推导。\n*   **左前提：** $A \\Rightarrow A$。这是**同一性公理**的一个直接实例。证明的这个分支已经完成。\n*   **右前提：** $\\bot \\Rightarrow B$。这个相继式表明，从谬误可以推导出任意公式 $B$。这是爆炸原理的一个实例，由**左谬误（$\\bot L$）规则**所捕捉。该规则是 $\\frac{}{\\Delta', \\bot \\Rightarrow C'}$。我们的相继式 $\\bot \\Rightarrow B$ 是此规则的一个实例，其中上下文 $\\Delta'$ 为空，而 $C'$ 是 $B$。这是一个公理（没有前提的规则），所以这个分支也完成了。\n\n**可能性2：** 设 $\\Gamma = \\emptyset$ 且 $\\Delta = \\{A\\}$。\n规则应用将是：\n$$\n\\frac{\\emptyset \\Rightarrow A \\quad A, \\bot \\Rightarrow B}{\\emptyset, A, A \\to \\bot \\Rightarrow B} (\\to L)\n$$\n左前提 $\\Rightarrow A$ 对于任意公式 $A$ 是不可推导的。因此，这条路径无法得出一个普遍的证明。\n\n第一个可能性提供了一个成功的推导。完整的证明树是：\n$$\n\\frac\n{A \\Rightarrow A \\quad \\frac{}{\\bot \\Rightarrow B}(\\bot L)}\n{A, A \\to \\bot \\Rightarrow B}(\\to L)\n$$\n这个推导成功地证明了 $A, \\neg A \\Rightarrow B$。\n\n### 第3步：所用规则分析\n\n在成功的推导中使用的规则是：\n1.  **同一性公理 ($A \\Rightarrow A$)**：对左前提至关重要。没有它，相继式 $A \\Rightarrow A$ 无法被证明。\n2.  **左蕴含 ($\\to L$)**：对分解主公式 $A \\to \\bot$ 至关重要。没有它，我们无法利用假设 $\\neg A$。\n3.  **左谬误 ($\\bot L$)**：对右前提至关重要。它形式化了爆炸原理（*ex falso quodlibet*），并允许从 $\\bot$ 推导出任意公式 $B$。\n\n这个集合 {同一性公理, $\\to L$, $\\bot L$} 是充分的。它也是最小的，因为如前所述，移除这三条规则中的任何一条都会使推导变得不可能。\n\n现在，我们必须评估是否需要左收缩（CL）规则。CL 规则是 $\\frac{A, A, \\Gamma \\Rightarrow C}{A, \\Gamma \\Rightarrow C}$。\n在我们的推导中，结论的前件是多重集 $\\{A, A \\to \\bot\\}$。根据 $\\to L$ 规则，左前提的前件是 $\\{A\\}$，右前提的前件是 $\\{\\bot\\}$。在推导过程的任何一点，都没有一个公式在一个前件中出现两次而需要被收缩为单次出现。来自原始上下文的公式 $A$ 只在左前提中被精确地使用了一次。因此，**不需要左收缩规则**。\n\n### 第4步：逐项分析选项\n\n*   **A. 同一性公理（$A \\Rightarrow A$）、$\\to L$、$\\bot L$；不需要左收缩规则。**\n    *   这个选项列出了我发现的充分且必要的最小规则集 {同一性公理, $\\to L$, $\\bot L$}。\n    *   它还正确地指出此推导不需要左收缩规则。\n    *   **结论：正确。**\n\n*   **B. 同一性公理（$A \\Rightarrow A$）、$\\to L$、$\\bot L$、切割规则；不需要左收缩规则。**\n    *   这个集合包含了切割规则，但在上面展示的直接、无切割的推导中并未使用。\n    *   既然存在一个不使用切割规则的推导，那么包含切割规则的集合就不是所需的“最小”集合。问题明确要求最小集合。\n    *   **结论：错误。**\n\n*   **C. 同一性公理（$A \\Rightarrow A$）、$\\to L$、$\\bot L$；需要左收缩规则来重用 $A$。**\n    *   规则集是正确的。\n    *   然而，关于需要左收缩规则的说法是错误的。如推导所示，上下文中的公式 $A$ 在 $\\to L$ 规则应用中只被用于一个前提。不存在需要收缩的“重用”情况。\n    *   **结论：错误。**\n\n*   **D. 同一性公理（$A \\Rightarrow A$）、$\\to L$；左收缩规则和切割规则足以替代 $\\bot L$。**\n    *   这个选项提出了一个不使用 $\\bot L$ 规则的推导。$\\bot L$ 规则的作用是当 $\\bot$ 在前件中时，允许引入任意公式 $B$作为后件。没有这个规则，在所提供的系统中没有机制可以从 $\\Gamma \\Rightarrow \\bot$ 的证明推导出 $\\Gamma \\Rightarrow B$。$\\bot L$ 规则独立于 LJ 中的其他规则（同一性公理、切割规则、结构规则以及 $\\to$ 的规则）。人们可以仅使用同一性公理和 $\\to L$ 推导出 $A, \\neg A \\Rightarrow \\bot$，但从后件中的 $\\bot$ 转换到任意公式 $B$ 需要爆炸原理，而这正是 $\\bot L$ 所提供的。\n    *   **结论：错误。**\n\n*   **E. 同一性公理（$A \\Rightarrow A$）、$\\bot L$、左弱化规则；不需要左收缩规则。**\n    *   这个集合忽略了 $\\to L$ 规则。没有 $\\to L$，就不可能分析或“使用”前件中的公式 $A \\to \\bot$。推导甚至无法开始。因此，这个集合是不充分的。\n    *   **结论：错误。**\n\n基于详尽的推导和分析，选项 A 是唯一一个正确指出了所需最小规则集，并准确评估了左收缩规则必要性的选项。", "answer": "$$\\boxed{A}$$", "id": "3057338"}, {"introduction": "当数据库或知识库中出现矛盾数据时，爆炸原理会带来灾难性的后果，导致系统推断出所有信息都是真的，这种现象称为“琐碎化”。本练习通过一个包含矛盾事实 $\\{p, \\neg p\\}$ 的知识库，直观地对比了经典逻辑和一度蕴涵（FDE）这种次协调逻辑的推论闭包 [@problem_id:3057342]。通过这个实践，你将体会到次协调逻辑在容忍局部不一致性而不致使整个系统崩溃方面的强大实用价值。", "problem": "考虑一个命题知识库 $K$ 和一个有限查询集 $\\Phi$，它们建立在原子命题 $p$、$q$ 和 $r$ 之上。在两种逻辑中进行分析：经典命题逻辑和由一阶蕴涵（First Degree Entailment, FDE）给出的次协调逻辑。你的任务是确定 $K$ 在每种逻辑下关于 $\\Phi$ 的闭包，并选出正确的选择题描述。\n\n基本依据和定义：\n- 经典蕴涵：$\\Gamma \\vdash_{\\mathrm{CL}} \\varphi$ 意为 $\\varphi$ 可以通过经典命题逻辑的标准可靠规则推导出来。\n- 经典逻辑中的爆炸原理（ex contradictione quodlibet）：如果 $\\Gamma$ 包含一个矛盾 $A$ 和 $\\neg A$，那么对于任何公式 $\\psi$，都可以仅使用标准推理规则推导出 $\\psi$。\n- 一阶蕴涵（FDE）中的次协调蕴涵：$\\Gamma \\vDash_{\\mathrm{FDE}} \\varphi$ 意为对于每个赋值 $v$，如果 $\\Gamma$ 中的所有公式在 $v$ 下都被指定，那么 $\\varphi$ 在 $v$ 下也被指定。在 FDE 中，真值可以表示为序对 $(t,f)$，其中 $t,f \\in \\{0,1\\}$，分别表示一个公式是否为真（$t=1$）和/或为假（$f=1$）。四个真值分别是 $\\mathbf{T}=(1,0)$、$\\mathbf{F}=(0,1)$、$\\mathbf{B}=(1,1)$ 和 $\\mathbf{N}=(0,0)$。指定值为那些 $t=1$ 的值，即 $\\mathbf{T}$ 和 $\\mathbf{B}$。联结词具有以下语义：$v(\\neg \\alpha)=(f(\\alpha),t(\\alpha))$、$t(\\alpha \\wedge \\beta)=\\min(t(\\alpha),t(\\beta))$、$f(\\alpha \\wedge \\beta)=\\max(f(\\alpha),f(\\beta))$、$t(\\alpha \\vee \\beta)=\\max(t(\\alpha),t(\\beta))$、$f(\\alpha \\vee \\beta)=\\min(f(\\alpha),f(\\beta))$，以及 $\\alpha \\to \\beta$ 定义为 $\\neg \\alpha \\vee \\beta$。\n\n设知识库为 $K=\\{p,\\neg p\\}$，它是不一致的。设有限查询集为\n$$\n\\Phi=\\{\\,p,\\ \\neg p,\\ p \\wedge \\neg p,\\ p \\vee r,\\ \\neg p \\vee r,\\ r,\\ q,\\ q \\vee r,\\ \\neg q,\\ r \\to q\\,\\}.\n$$\n\n问题：哪个选项正确列出了经典闭包 $C= \\mathrm{Cn}_{\\mathrm{CL}}(K) \\cap \\Phi$ 和次协调闭包 $P=\\mathrm{Cn}_{\\mathrm{FDE}}(K) \\cap \\Phi$？\n\nA. $C=\\Phi$ 且 $P=\\{\\,p,\\ \\neg p,\\ p \\wedge \\neg p,\\ p \\vee r,\\ \\neg p \\vee r\\,\\}$\n\nB. $C=\\Phi$ 且 $P=\\{\\,p,\\ \\neg p,\\ p \\wedge \\neg p,\\ r,\\ p \\vee r,\\ \\neg p \\vee r\\,\\}$\n\nC. $C=\\Phi$ 且 $P=\\Phi$\n\nD. $C=\\Phi$ 且 $P=\\{\\,p,\\ \\neg p,\\ p \\vee r,\\ \\neg p \\vee r\\,\\}$", "solution": "### 第1步：提取已知条件\n- **逻辑**: 经典命题逻辑 (CL) 和一阶蕴涵 (First Degree Entailment, FDE)。\n- **原子命题**: $p$, $q$, $r$。\n- **知识库**: $K=\\{p,\\neg p\\}$。\n- **查询集**: $\\Phi=\\{\\,p,\\ \\neg p,\\ p \\wedge \\neg p,\\ p \\vee r,\\ \\neg p \\vee r,\\ r,\\ q,\\ q \\vee r,\\ \\neg q,\\ r \\to q\\,\\}$。\n- **经典蕴涵**: $\\Gamma \\vdash_{\\mathrm{CL}} \\varphi$ 由经典逻辑的标准可靠规则定义，包括爆炸原理（ex contradictione quodlibet），该原理指出从 $\\{A, \\neg A\\}$ 可以推导出任何公式 $\\psi$。\n- **次协调蕴涵 (FDE)**: $\\Gamma \\vDash_{\\mathrm{FDE}} \\varphi$ 意为对于每个 FDE 赋值 $v$，如果 $\\Gamma$ 中的所有公式在 $v$ 下都被指定，那么 $\\varphi$ 也被指定。\n- **FDE 语义**:\n    - 真值为序对 $(t,f)$，其中 $t,f \\in \\{0,1\\}$。四个真值为 $\\mathbf{T}=(1,0)$、$\\mathbf{F}=(0,1)$、$\\mathbf{B}=(1,1)$ 和 $\\mathbf{N}=(0,0)$。\n    - 指定值为 $\\mathbf{T}$ 和 $\\mathbf{B}$（即那些 $t=1$ 的值）。\n    - 联结词语义：\n        - $v(\\neg \\alpha)=(f(\\alpha),t(\\alpha))$\n        - $t(\\alpha \\wedge \\beta)=\\min(t(\\alpha),t(\\beta))$, $f(\\alpha \\wedge \\beta)=\\max(f(\\alpha),f(\\beta))$\n        - $t(\\alpha \\vee \\beta)=\\max(t(\\alpha),t(\\beta))$, $f(\\alpha \\vee \\beta)=\\min(f(\\alpha),f(\\beta))$\n        - $\\alpha \\to \\beta$ 定义为 $\\neg \\alpha \\vee \\beta$。\n- **问题**: 确定经典闭包 $C= \\mathrm{Cn}_{\\mathrm{CL}}(K) \\cap \\Phi$ 和次协调闭包 $P=\\mathrm{Cn}_{\\mathrm{FDE}}(K) \\cap \\Phi$。\n\n### 第2步：使用提取的已知条件进行验证\n该问题是形式逻辑中一个定义明确的练习，比较了经典推理和次协调推理。\n\n- **科学依据**: 该问题基于已建立的经典命题逻辑和一阶蕴涵（FDE）这一著名次协调逻辑的形式系统。所有定义在数理逻辑领域都是标准的。它在科学上和事实上都是合理的。\n- **适定性**: 知识库 $K$ 和查询集 $\\Phi$ 是有限且明确定义的。两种逻辑的蕴涵关系都已正式指定。任务是计算 $K$ 的推论集与有限集 $\\Phi$ 的交集。这种结构保证了唯一且有意义的解。\n- **客观性**: 该问题使用精确、形式化的语言和定义。没有主观或模棱两可的术语。\n- **完备性与一致性**: 该问题提供了进行推导所需的所有必要定义和数据。设置中没有内部矛盾。\n- **其他检查**: 该问题并非无足轻重，因为它需要理解 FDE 的非爆炸性。它不是隐喻性的、不切实际的，或超出数学验证范围的。\n\n### 第3步：结论与行动\n问题陈述是**有效的**。现在开始求解过程。\n\n### 推导过程\n\n**第1部分：经典闭包 ($C$)**\n\n知识库是 $K = \\{p, \\neg p\\}$。在经典命题逻辑中，一个包含某个公式及其否定的知识库，如 $\\{p, \\neg p\\}$，是一个矛盾。\n\n根据作为经典逻辑定理的爆炸原理（ex contradictione quodlibet），一个矛盾蕴涵任何任意公式。形式上，对于语言中的任何公式 $\\psi$，我们有 $\\{p, \\neg p\\} \\vdash_{\\mathrm{CL}} \\psi$。\n\n因此，$K$ 的经典闭包，记为 $\\mathrm{Cn}_{\\mathrm{CL}}(K)$，包含命题语言中的每一个合式公式。\n\n集合 $C$ 定义为该闭包与查询集 $\\Phi$ 的交集：\n$$C = \\mathrm{Cn}_{\\mathrm{CL}}(K) \\cap \\Phi$$\n因为 $\\Phi$ 中的每个公式根据定义都是一个合式公式，而 $\\mathrm{Cn}_{\\mathrm{CL}}(K)$ 包含所有这些公式，所以交集就是集合 $\\Phi$ 本身。\n$$C = \\Phi$$\n\n**第2部分：次协调闭包 ($P$)**\n\n所使用的次协调逻辑是一阶蕴涵（FDE）。闭包为 $P = \\mathrm{Cn}_{\\mathrm{FDE}}(K) \\cap \\Phi$。我们必须确定 $\\Phi$ 中的哪些公式 $\\varphi$ 是由 $K = \\{p, \\neg p\\}$ FDE-蕴涵的。\n\n蕴涵条件 $K \\vDash_{\\mathrm{FDE}} \\varphi$ 是：对于任何使得 $K$ 中所有公式都被指定的赋值 $v$，$\\varphi$ 也必须被指定。如果一个值的真值分量 $t$ 为 $1$，则该值被指定。\n\n我们首先分析知识库 $K=\\{p, \\neg p\\}$ 施加的约束。如果 $p$ 和 $\\neg p$ 都被指定，则赋值 $v$ 满足前提。\n1. 为了使 $p$ 被指定，我们必须有 $t(p) = 1$。这意味着 $v(p)$ 可以是 $\\mathbf{T}=(1,0)$ 或 $\\mathbf{B}=(1,1)$。\n2. 为了使 $\\neg p$ 被指定，我们必须有 $t(\\neg p) = 1$。根据定义，$v(\\neg p) = (f(p), t(p))$，所以我们需要 $f(p) = 1$。\n结合这两个条件，我们需要 $t(p)=1$ 和 $f(p)=1$。唯一满足此条件的真值是 $v(p) = \\mathbf{B} = (1,1)$。\n\n因此，一个公式 $\\varphi$ 属于 $\\mathrm{Cn}_{\\mathrm{FDE}}(K)$ 当且仅当对于每一个满足 $v(p) = \\mathbf{B}$ 的赋值 $v$，公式 $\\varphi$ 都被指定（即 $t(\\varphi)=1$）。请注意，其他原子命题的值 $v(q)$ 和 $v(r)$ 可以是四个 FDE 值中的任意一个。\n\n我们现在根据这个条件测试 $\\Phi$ 中的每个公式 $\\varphi$。\n\n- **$p$**: 如果 $v(p) = \\mathbf{B} = (1,1)$，那么 $t(p)=1$。所以 $p$ 被指定。因此，$p \\in P$。\n- **$\\neg p$**: 如果 $v(p) = \\mathbf{B} = (1,1)$，那么 $v(\\neg p) = (1,1) = \\mathbf{B}$，这意味着 $t(\\neg p)=1$。所以 $\\neg p$ 被指定。因此，$\\neg p \\in P$。\n- **$p \\wedge \\neg p$**: 如果 $v(p) = \\mathbf{B}$，那么 $v(\\neg p) = \\mathbf{B}$。真值分量是 $t(p \\wedge \\neg p) = \\min(t(p), t(\\neg p)) = \\min(1,1) = 1$。所以 $p \\wedge \\neg p$ 被指定。因此，$p \\wedge \\neg p \\in P$。\n- **$p \\vee r$**: 给定 $v(p) = \\mathbf{B}$，真值分量是 $t(p \\vee r) = \\max(t(p), t(r)) = \\max(1, t(r)) = 1$，无论 $v(r)$ 的值是什么。所以 $p \\vee r$ 总是被指定。因此，$p \\vee r \\in P$。\n- **$\\neg p \\vee r$**: 给定 $v(p) = \\mathbf{B}$，我们有 $v(\\neg p) = \\mathbf{B}$。真值分量是 $t(\\neg p \\vee r) = \\max(t(\\neg p), t(r)) = \\max(1, t(r)) = 1$，无论 $v(r)$ 的值是什么。所以 $\\neg p \\vee r$ 总是被指定。因此，$\\neg p \\vee r \\in P$。\n- **$r$**: 我们需要检查在所有 $v(p)=\\mathbf{B}$ 的赋值下，$r$ 是否被指定。考虑赋值 $v$，其中 $v(p)=\\mathbf{B}$ 且 $v(r)=\\mathbf{F}=(0,1)$。在此赋值下，前提 $\\{p, \\neg p\\}$ 被指定，但 $r$ 没有被指定，因为 $t(r)=0$。这构成了一个反例模型。因此，$r \\notin P$。\n- **$q$**: 与 $r$ 类似。考虑赋值 $v$，其中 $v(p)=\\mathbf{B}$ 且 $v(q)=\\mathbf{F}=(0,1)$。前提被指定，但 $q$ 没有被指定（$t(q)=0$）。因此，$q \\notin P$。\n- **$q \\vee r$**: 考虑赋值 $v$，其中 $v(p)=\\mathbf{B}$，$v(q)=\\mathbf{F}=(0,1)$ 且 $v(r)=\\mathbf{F}=(0,1)$。前提被指定。结论的真值分量是 $t(q \\vee r) = \\max(t(q), t(r)) = \\max(0,0) = 0$。结论没有被指定。这是一个反例模型。因此，$q \\vee r \\notin P$。\n- **$\\neg q$**: 考虑赋值 $v$，其中 $v(p)=\\mathbf{B}$ 且 $v(q)=\\mathbf{T}=(1,0)$。前提被指定。结论是 $\\neg q$，其值为 $v(\\neg q) = (f(q), t(q)) = (0,1) = \\mathbf{F}$。其真值分量是 $t(\\neg q) = 0$，所以它没有被指定。这是一个反例模型。因此，$\\neg q \\notin P$。\n- **$r \\to q$ (定义为 $\\neg r \\vee q$)**: 考虑赋值 $v$，其中 $v(p)=\\mathbf{B}$，$v(r)=\\mathbf{T}=(1,0)$ 且 $v(q)=\\mathbf{F}=(0,1)$。前提被指定。对于结论，我们首先求得 $v(\\neg r) = (f(r), t(r)) = (0,1) = \\mathbf{F}$。然后真值分量是 $t(\\neg r \\vee q) = \\max(t(\\neg r), t(q)) = \\max(0,0) = 0$。结论没有被指定。这是一个反例模型。因此，$r \\to q \\notin P$。\n\n综合这些结果，集合 $P$ 为：\n$$P = \\{\\,p,\\ \\neg p,\\ p \\wedge \\neg p,\\ p \\vee r,\\ \\neg p \\vee r\\,\\}$$\n\n### 逐项分析\n\n- **选项 A**: $C=\\Phi$ 且 $P=\\{\\,p,\\ \\neg p,\\ p \\wedge \\neg p,\\ p \\vee r,\\ \\neg p \\vee r\\,\\}$\n  - 对于 $C$ 的计算结果为 $C=\\Phi$，这是正确的。\n  - 对于 $P$ 的计算结果为集合 $\\{\\,p,\\ \\neg p,\\ p \\wedge \\neg p,\\ p \\vee r,\\ \\neg p \\vee r\\,\\}$，与选项完全匹配。\n  - **结论：正确。**\n\n- **选项 B**: $C=\\Phi$ 且 $P=\\{\\,p,\\ \\neg p,\\ p \\wedge \\neg p,\\ r,\\ p \\vee r,\\ \\neg p \\vee r\\,\\}$\n  - 关于 $C$ 的陈述是正确的。\n  - 关于 $P$ 的陈述错误地包含了 $r$。如前所述，$r$ 并非由 $K$ FDE-蕴涵，因为一个涉及 $p$ 的矛盾不会影响不相关的命题。\n  - **结论：错误。**\n\n- **选项 C**: $C=\\Phi$ 且 $P=\\Phi$\n  - 关于 $C$ 的陈述是正确的。\n  - 关于 $P$ 的陈述是错误的。它声称 FDE 也会导致爆炸，使得 $\\Phi$ 中的所有公式都可推导。这是错误的；FDE 是一种次协调逻辑，专门设计用来避免这种情况。如上所示，像 $q$、$r$、$q \\vee r$ 等公式并没有被蕴涵。\n  - **结论：错误。**\n\n- **选项 D**: $C=\\Phi$ 且 $P=\\{\\,p,\\ \\neg p,\\ p \\vee r,\\ \\neg p \\vee r\\,\\}$\n  - 关于 $C$ 的陈述是正确的。\n  - 关于 $P$ 的陈述错误地遗漏了 $p \\wedge \\neg p$。合取引入规则（$A, B \\vdash A \\wedge B$）在 FDE 中是有效的。如果 $v$ 指定了 $A$ 和 $B$，那么 $t(A)=1$ 且 $t(B)=1$。所以 $t(A \\wedge B) = \\min(t(A), t(B)) = 1$，意味着 $A \\wedge B$ 也被指定。因此，从 $\\{p, \\neg p\\}$ 中，我们可以推断出 $p \\wedge \\neg p$。\n  - **结论：错误。**", "answer": "$$\\boxed{A}$$", "id": "3057342"}, {"introduction": "次协调逻辑通过修改经典逻辑的真值语义来“驯服”矛盾。Graham Priest 的悖论逻辑（LP）是一个典型的例子，它引入了一个“既真又假”的第三真值，允许矛盾（如 $A \\land \\neg A$）本身被指定为真，但又不必然蕴含任意命题 [@problem_id:3057335]。通过亲手计算 LP 中的真值表和具体公式的赋值，你将深入理解这种多值语义是如何在技术层面上阻止爆炸原理的。", "problem": "在 Graham Priest 的悖论逻辑（LP）的框架内进行演算。LP 是一种次协调命题逻辑，旨在阻止爆炸原理。在 LP 中，每个公式都被赋予一个双分量语义值 $(t,f)$，其中 $t \\in \\{0,1\\}$ 表示该公式是否为真，$f \\in \\{0,1\\}$ 表示该公式是否为假。三个典范值是 $\\mathbf{T}=(1,0)$（仅为真）、$\\mathbf{F}=(0,1)$（仅为假）和 $\\mathbf{B}=(1,1)$（既真又假）。当一个值的 $t$-分量为 $1$ 时，该值被指定。仅使用此语义框架和逻辑联结词的标准真假条件，完成以下任务：\n\n1. 在三个值 $\\mathbf{T}$、$\\mathbf{B}$ 和 $\\mathbf{F}$ 上，推导并给出 LP 中否定 $\\neg$ 和实质蕴涵 $\\to$ 的完整真值表。\n\n2. 在一个赋值 $v$ 下，使得 $v(A)=\\mathbf{B}$ 且 $v(B)=\\mathbf{F}$，计算公式 $(A \\land \\neg A) \\to B$ 的 LP 值的 $t$-分量。\n\n将你的最终答案表示为等于 $v\\big((A \\land \\neg A) \\to B\\big)$ 的 $t$-分量的单个数字。无需四舍五入。", "solution": "该问题是良定的，并基于次协调逻辑的既定原则，特别是 Graham Priest 的悖论逻辑（LP）。所有术语都是标准的，任务是可计算验证的。我们将开始解题。\n\nLP 的语义框架为每个公式 $\\phi$ 赋予一个值 $v(\\phi) = (t,f)$，其中 $t, f \\in \\{0, 1\\}$。值 $t=1$ 表示公式为真，$f=1$ 表示公式为假。三个典范值是：\n-   $\\mathbf{T} = (1,0)$，代表‘仅为真’。\n-   $\\mathbf{F} = (0,1)$，代表‘仅为假’。\n-   $\\mathbf{B} = (1,1)$，代表‘既真又假’。\n\n如果一个值的 $t$-分量为 $1$，则该值被认为是‘指定的’（或直观上‘真’的）。因此，$\\mathbf{T}$ 和 $\\mathbf{B}$ 都是指定值。\n\n逻辑联结词的“标准真假条件”可以转化为关于 $(t,f)$ 对的代数规则。设 $v(P) = (t_P, f_P)$ 且 $v(Q) = (t_Q, f_Q)$。\n\n对于否定（$\\neg$）：\n-   $\\neg P$ 为真当且仅当 $P$ 为假。所以，$t_{\\neg P} = f_P$。\n-   $\\neg P$ 为假当且仅当 $P$ 为真。所以，$f_{\\neg P} = t_P$。\n-   这给出了规则：$v(\\neg P) = (f_P, t_P)$。\n\n对于实质蕴涵（$\\to$）：\n-   $P \\to Q$ 为真当且仅当 $P$ 为假或 $Q$ 为真。这里的‘或’是包容性的。这意味着如果 $f_P = 1$ 或 $t_Q = 1$，则 $t_{P \\to Q} = 1$。这对应于操作 $t_{P \\to Q} = \\max(f_P, t_Q)$。\n-   $P \\to Q$ 为假当且仅当 $P$ 为真且 $Q$ 为假。这意味着如果 $t_P = 1$ 且 $f_Q = 1$，则 $f_{P \\to Q} = 1$。这对应于操作 $f_{P \\to Q} = \\min(t_P, f_Q)$（或 $t_P \\cdot f_Q$）。\n-   这给出了规则：$v(P \\to Q) = (\\max(f_P, t_Q), \\min(t_P, f_Q))$。\n\n对于合取（$\\land$），为第二部分所需：\n-   $P \\land Q$ 为真当且仅当 $P$ 为真且 $Q$ 为真。这对应于 $t_{P \\land Q} = \\min(t_P, t_Q)$。\n-   $P \\land Q$ 为假当且仅当 $P$ 为假或 $Q$ 为假。这对应于 $f_{P \\land Q} = \\max(f_P, f_Q)$。\n-   这给出了规则：$v(P \\land Q) = (\\min(t_P, t_Q), \\max(f_P, f_Q))$。\n\n**1. 真值表的推导**\n\n我们现在将在值集合 $\\{\\mathbf{T}, \\mathbf{B}, \\mathbf{F}\\}$ 上构建 $\\neg$ 和 $\\to$ 的真值表。\n\n**否定（$\\neg$）的真值表**\n使用规则 $v(\\neg P) = (f_P, t_P)$：\n-   如果 $v(P) = \\mathbf{T} = (1,0)$，那么 $v(\\neg P) = (0,1) = \\mathbf{F}$。\n-   如果 $v(P) = \\mathbf{B} = (1,1)$，那么 $v(\\neg P) = (1,1) = \\mathbf{B}$。\n-   如果 $v(P) = \\mathbf{F} = (0,1)$，那么 $v(\\neg P) = (1,0) = \\mathbf{T}$。\n\n得到的真值表如下：\n$$\n\\begin{array}{c|c}\nP  \\neg P \\\\\n\\hline\n\\mathbf{T}  \\mathbf{F} \\\\\n\\mathbf{B}  \\mathbf{B} \\\\\n\\mathbf{F}  \\mathbf{T}\n\\end{array}\n$$\n\n**实质蕴涵（$\\to$）的真值表**\n使用规则 $v(P \\to Q) = (\\max(f_P, t_Q), \\min(t_P, f_Q))$：\n-   第 1 行：$v(P)=\\mathbf{T}=(1,0)$。\n    -   $v(Q)=\\mathbf{T}=(1,0)$: $v(P \\to Q) = (\\max(0,1), \\min(1,0)) = (1,0) = \\mathbf{T}$。\n    -   $v(Q)=\\mathbf{B}=(1,1)$: $v(P \\to Q) = (\\max(0,1), \\min(1,1)) = (1,1) = \\mathbf{B}$。\n    -   $v(Q)=\\mathbf{F}=(0,1)$: $v(P \\to Q) = (\\max(0,0), \\min(1,1)) = (0,1) = \\mathbf{F}$。\n-   第 2 行：$v(P)=\\mathbf{B}=(1,1)$。\n    -   $v(Q)=\\mathbf{T}=(1,0)$: $v(P \\to Q) = (\\max(1,1), \\min(1,0)) = (1,0) = \\mathbf{T}$。\n    -   $v(Q)=\\mathbf{B}=(1,1)$: $v(P \\to Q) = (\\max(1,1), \\min(1,1)) = (1,1) = \\mathbf{B}$。\n    -   $v(Q)=\\mathbf{F}=(0,1)$: $v(P \\to Q) = (\\max(1,0), \\min(1,1)) = (1,1) = \\mathbf{B}$。\n-   第 3 行：$v(P)=\\mathbf{F}=(0,1)$。\n    -   $v(Q)=\\mathbf{T}=(1,0)$: $v(P \\to Q) = (\\max(1,1), \\min(0,0)) = (1,0) = \\mathbf{T}$。\n    -   $v(Q)=\\mathbf{B}=(1,1)$: $v(P \\to Q) = (\\max(1,1), \\min(0,1)) = (1,0) = \\mathbf{T}$。\n    -   $v(Q)=\\mathbf{F}=(0,1)$: $v(P \\to Q) = (\\max(1,0), \\min(0,1)) = (1,0) = \\mathbf{T}$。\n\n得到的真值表如下，其中行为 $P$，列为 $Q$：\n$$\n\\begin{array}{c|ccc}\n\\to  \\mathbf{T}  \\mathbf{B}  \\mathbf{F} \\\\\n\\hline\n\\mathbf{T}  \\mathbf{T}  \\mathbf{B}  \\mathbf{F} \\\\\n\\mathbf{B}  \\mathbf{T}  \\mathbf{B}  \\mathbf{B} \\\\\n\\mathbf{F}  \\mathbf{T}  \\mathbf{T}  \\mathbf{T}\n\\end{array}\n$$\n\n**2. $v\\big((A \\land \\neg A) \\to B\\big)$ 的计算**\n\n我们给定一个赋值 $v$，使得 $v(A) = \\mathbf{B}$ 且 $v(B) = \\mathbf{F}$。请注意，符号‘$B$’既用作公式名称，也用作真值；上下文使其含义清晰。我们要求解 $v\\big((A \\land \\neg A) \\to B\\big)$ 的 $t$-分量。\n\n我们首先通过计算子公式的值来进行。\n\n步骤 1：求值 $v(\\neg A)$。\n已知 $v(A) = \\mathbf{B} = (1,1)$。\n使用否定规则 $v(\\neg A) = (f_A, t_A)$：\n$v(\\neg A) = (1,1) = \\mathbf{B}$。\n\n步骤 2：求值 $v(A \\land \\neg A)$。\n我们有 $v(A) = (1,1)$ 和 $v(\\neg A) = (1,1)$。\n使用合取规则 $v(P \\land Q) = (\\min(t_P, t_Q), \\max(f_P, f_Q))$：\n$v(A \\land \\neg A) = (\\min(1,1), \\max(1,1)) = (1,1) = \\mathbf{B}$。\n这个结果表明，在 LP 中，形如 $A \\land \\neg A$ 的矛盾不一定是假的；它可以是‘既真又假’的。\n\n步骤 3：求值 $v\\big((A \\land \\neg A) \\to B\\big)$。\n令前件为 $\\Phi = A \\land \\neg A$，后件为公式 $B$。\n我们已经计算出 $v(\\Phi) = v(A \\land \\neg A) = (1,1)$。我们将其分量表示为 $(t_\\Phi, f_\\Phi) = (1,1)$。\n我们已知 $v(B) = \\mathbf{F} = (0,1)$。我们将其分量表示为 $(t_B, f_B) = (0,1)$。\n\n使用蕴涵规则 $v(\\Phi \\to B) = (\\max(f_\\Phi, t_B), \\min(t_\\Phi, f_B))$：\n$v\\big((A \\land \\neg A) \\to B\\big) = (\\max(1, 0), \\min(1, 1)) = (1,1) = \\mathbf{B}$。\n\n在给定赋值下，完整公式 $(A \\land \\neg A) \\to B$ 的 LP 值为 $(1,1)$。这个结果展示了 LP 如何阻止爆炸原理：从一个矛盾（这里是 $A \\land \\neg A$，其值为指定的 $\\mathbf{B}$），不一定能推导出任意命题（这里是 $B$，其值为非指定的 $\\mathbf{F}$），因为连接它们的蕴涵仍然是指定的。\n\n问题要求的是这个最终值的 $t$-分量。\n最终值为 $(1,1)$。$t$-分量是 $1$。", "answer": "$$\n\\boxed{1}\n$$", "id": "3057335"}]}