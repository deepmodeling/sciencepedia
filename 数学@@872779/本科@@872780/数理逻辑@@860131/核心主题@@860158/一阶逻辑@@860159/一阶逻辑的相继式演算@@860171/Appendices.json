{"hands_on_practices": [{"introduction": "掌握矢列演算的核心在于亲手构建证明。这个练习旨在锻炼这项基本技能：从一个待证的矢列（结论）出发，逆向应用逻辑规则，逐步将其分解，直至所有分支都成为公理。通过完成这个练习 [@problem_id:3052306]，你将熟悉在无切削证明中处理蕴含联结词 $\\to$ 和合取联结词 $\\land$ 的策略，并体会到证明搜索的系统性过程。", "problem": "在经典的一阶逻辑 Gentzen 式矢列演算 (LK) 中进行演算，并将其限制于其命题片段。使用以下内容作为基本基础：对于任意公式 $A$ 的形式为 $A \\vdash A$ 的初始（同一）公理，结构规则（弱化、收缩、交换），以及命题联结词 $\\land$、$\\lor$、$\\to$ 和 $\\lnot$ 的标准左引入和右引入规则。切削规则不允许使用（仅限无切削证明）。在本题中，您只需计算左侧或右侧命题逻辑规则的应用次数（即 $\\land L$、$\\land R$、$\\lor L$、$\\lor R$、$\\to L$、$\\to R$、$\\lnot L$、$\\lnot R$）。不要计算结构规则或初始公理。\n\n考虑矢列\n$$\\vdash \\left(((P \\to Q) \\land (Q \\to R)) \\land (R \\to S)\\right) \\to (P \\to S),$$\n其中 $P$、$Q$、$R$ 和 $S$ 是命题原子，$\\land$ 被解析为带有所显示括号的二元联结词。\n\n在该矢列的所有无切削 LK 证明中，确定从初始公理完成一个证明所需的最少命题逻辑规则（计算左引入和右引入）应用次数 $N$。请以单个整数形式提供最终答案。无需四舍五入。", "solution": "问题要求在无切削的 Gentzen 式矢列演算 (LK) 中，证明矢列 $\\vdash \\left(((P \\to Q) \\land (Q \\to R)) \\land (R \\to S)\\right) \\to (P \\to S)$ 所需的命题逻辑规则应用的最小次数。\n\n首先，我们必须验证该问题。\n**步骤 1：提取已知条件**\n- 演算系统：经典的 Gentzen 式矢列演算 (LK)，限制于其命题片段。\n- 公理：对于任意公式 $A$，为 $A \\vdash A$。\n- 结构规则：弱化、收缩、交换（不计数）。\n- 逻辑规则：$\\land, \\lor, \\to, \\lnot$ 的标准左/右引入规则。\n- 限制：无切削规则。\n- 计数的运算：仅命题逻辑规则的应用（$\\land L, \\land R, \\lor L, \\lor R, \\to L, \\to R, \\lnot L, \\lnot R$）。\n- 待证矢列：$\\vdash \\left(((P \\to Q) \\land (Q \\to R)) \\land (R \\to S)\\right) \\to (P \\to S)$。\n- 目标：找到计数的运算的最小次数 $N$。\n\n**步骤 2：使用提取的已知条件进行验证**\n该问题在数理逻辑（特别是证明论）领域内是定义明确的。所指定的演算系统、规则以及用于证明的矢列都是标准的。该矢列是一个已知的重言式（蕴含传递性的一个例子）。在规则应用次数方面寻找最小证明是一个标准的证明论问题。该问题是自洽的、有科学依据的、客观的。不存在矛盾、歧义或伪科学主张。\n\n**结论：** 该问题有效。\n\n现在我们将通过从目标反向推导，应用 LK 的规则来构建该矢列的一个证明。目标是找到一个使用最少逻辑规则应用次数的证明。一个证明是一棵树，其中每个节点是一个矢列，根节点是待证明的矢列，叶节点是形式为 $A \\vdash A$ 的初始公理。\n\n待证明的矢列是：\n$$ \\vdash \\left(((P \\to Q) \\land (Q \\to R)) \\land (R \\to S)\\right) \\to (P \\to S) $$\n主联结词是 $\\to$。唯一可以应用的规则是蕴含的右引入规则（$\\to R$），其形式为 $\\frac{\\Gamma, A \\vdash B, \\Delta}{\\Gamma \\vdash A \\to B, \\Delta}$。\n应用此规则是我们的第一个逻辑规则应用（$N=1$）。\n$$ \\frac{((P \\to Q) \\land (Q \\to R)) \\land (R \\to S) \\vdash P \\to S}{\\vdash \\left(((P \\to Q) \\land (Q \\to R)) \\land (R \\to S)\\right) \\to (P \\to S)} (\\to R) $$\n新的目标是该规则的前提。右侧的公式是 $P \\to S$。我们必须再次应用 $\\to R$ 规则。这是我们的第二个逻辑规则应用（$N=2$）。\n$$ \\frac{P, ((P \\to Q) \\land (Q \\to R)) \\land (R \\to S) \\vdash S}{((P \\to Q) \\land (Q \\to R)) \\land (R \\to S) \\vdash P \\to S} (\\to R) $$\n现在要证明的矢列是 $P, ((P \\to Q) \\land (Q \\to R)) \\land (R \\to S) \\vdash S$。为了继续，我们必须分解左侧（前件）的复杂公式。主联结词是合取。我们应用合取的左引入规则（$\\land L$），其形式为 $\\frac{\\Gamma, A, B \\vdash \\Delta}{\\Gamma, A \\land B \\vdash \\Delta}$。这算作我们的第三个逻辑规则应用（$N=3$）。\n$$ \\frac{P, (P \\to Q) \\land (Q \\to R), R \\to S \\vdash S}{P, ((P \\to Q) \\land (Q \\to R)) \\land (R \\to S) \\vdash S} (\\land L) $$\n左侧还有另一个合取，$(P \\to Q) \\land (Q \\to R)$。我们再次应用 $\\land L$ 规则。这是我们的第四个逻辑规则应用（$N=4$）。\n$$ \\frac{P, P \\to Q, Q \\to R, R \\to S \\vdash S}{P, (P \\to Q) \\land (Q \\to R), R \\to S \\vdash S} (\\land L) $$\n当前的目标矢列是 $P, P \\to Q, Q \\to R, R \\to S \\vdash S$。在此阶段，初始公式已被完全分解为一组前提。为了完成证明，我们必须证明 $S$ 可以从这些前提中推出。这需要使用蕴含式。我们必须应用蕴含的左引入规则（$\\to L$），其形式为 $\\frac{\\Gamma \\vdash A, \\Delta \\quad B, \\Gamma \\vdash \\Delta}{\\Gamma, A \\to B \\vdash \\Delta}$。这个规则将证明分为两个分支。为了获得最小证明，我们必须有策略地选择应用此规则的顺序。\n\n一个高效的策略是模拟正向链接，从已知的原子 $P$ 开始。\n我们的前件中有 $P$。我们对公式 $P \\to Q$ 应用 $\\to L$ 规则。这是第五个逻辑规则应用（$N=5$）。\n$$ \\frac{P, Q \\to R, R \\to S \\vdash P, S \\quad (\\text{分支 1}) \\qquad Q, P, Q \\to R, R \\to S \\vdash S \\quad (\\text{分支 2})}{P, P \\to Q, Q \\to R, R \\to S \\vdash S} (\\to L) $$\n我们来分析这两个新分支：\n- **分支 1：** $P, Q \\to R, R \\to S \\vdash P, S$。这是一个初始公理，因为公式 $P$ 同时出现在左侧和右侧。证明的这个分支在没有更多逻辑规则的情况下就完成了。\n- **分支 2：** $Q, P, Q \\to R, R \\to S \\vdash S$。现在必须证明这个矢列。我们的前件中现在有 $Q$。我们通过对链中的下一个蕴含式 $Q \\to R$ 应用 $\\to L$ 来继续。这是我们的第六个逻辑规则应用（$N=6$）。\n$$ \\frac{Q, P, R \\to S \\vdash Q, S \\quad (\\text{分支 2a}) \\qquad R, Q, P, R \\to S \\vdash S \\quad (\\text{分支 2b})}{Q, P, Q \\to R, R \\to S \\vdash S} (\\to L) $$\n分析新的子分支：\n- **分支 2a：** $Q, P, R \\to S \\vdash Q, S$。这是一个初始公理，因为 $Q$ 同时出现在两侧。这个分支完成了。\n- **分支 2b：** $R, Q, P, R \\to S \\vdash S$。这是我们的新目标。我们的前件中有 $R$。最后一步是使用最后一个蕴含式 $R \\to S$。我们应用 $\\to L$ 规则。这是我们的第七个也是最后一个逻辑规则应用（$N=7$）。\n$$ \\frac{R, Q, P \\vdash R, S \\quad (\\text{分支 2b-i}) \\qquad S, R, Q, P \\vdash S \\quad (\\text{分支 2b-ii})}{R, Q, P, R \\to S \\vdash S} (\\to L) $$\n分析最后这两个分支：\n- **分支 2b-i：** $R, Q, P \\vdash R, S$。由于 $R$，这是一个初始公理。\n- **分支 2b-ii：** $S, R, Q, P \\vdash S$。由于 $S$，这是一个初始公理。\n\n证明的所有分支都终止于初始公理。所应用的逻辑规则总数为 $7$。\n\n为了确认这是最小数目，我们论证每一步的必要性：\n1.  两次应用 $\\to R$ 是不可避免的，需要用它们来分解后件中嵌套的蕴含结构。\n2.  两次应用 $\\land L$ 是不可避免的，需要用它们来分解前件中的嵌套合取。\n3.  这将我们带到矢列 $P, P \\to Q, Q \\to R, R \\to S \\vdash S$。为了从前提 $P$ 证明 $S$ ，证明必须逻辑上遍历蕴含链 $P \\to Q$、$Q \\to R$ 和 $R \\to S$。在无切削的 LK 中，每个这样的遍历步骤（等同于一次肯定前件式的应用）主要是通过 $\\to L$ 规则完成的。三个蕴含式中的每一个都必须通过一次 $\\to L$ 的应用来“激活”，以便将 $P$ 连接到 $S$。因此，至少需要三次 $\\to L$ 的应用。\n\n逻辑规则应用的最小总数是这些必要步骤的总和：$2 (\\to R) + 2 (\\land L) + 3 (\\to L) = 7$。\n所构建的证明达到了这个下界。因此，应用的最小次数是 $7$。", "answer": "$$\n\\boxed{7}\n$$", "id": "3052306"}, {"introduction": "切削消除定理（Cut-Elimination Theorem）是证明论的基石，它保证了任何有切削规则的证明都可以被转化为一个无切削的证明。这个练习 [@problem_id:3052309] 让你不仅仅是接受这个定理，而是亲身体验其证明机制的核心。你将对一个包含复杂公式的切削规则实例执行关键的“消减”步骤，并通过追踪“切削秩”（cut-rank）的变化，将抽象的消减过程具体化。", "problem": "考虑经典的一阶矢列演算，其具有联结词 $\\land$, $\\lor$, $\\to$, $\\neg$ 和量词 $\\forall$, $\\exists$ 的通常结构规则和逻辑规则。$\\mathsf{cut}$ 规则是一种推理，它从矢列 $\\Gamma \\vdash \\Delta, \\chi$ 和 $\\Gamma', \\chi \\vdash \\Delta'$ 出发，通过对公式 $\\chi$ 进行切削，导出矢列 $\\Gamma, \\Gamma' \\vdash \\Delta, \\Delta'$。递归地定义公式 $\\varphi$ 的秩 $|\\varphi|$：对于任意原子公式 $P(t_{1}, \\dots, t_{n})$，其秩为 $|P(t_{1}, \\dots, t_{n})| = 1$；对于否定式，其秩为 $|\\neg \\alpha| = 1 + |\\alpha|$；对于二元联结词 $\\circ \\in \\{\\land, \\lor, \\to\\}$，其秩为 $|\\alpha \\circ \\beta| = 1 + |\\alpha| + |\\beta|$；对于量词，其秩为 $|\\forall x\\, \\alpha| = 1 + |\\alpha|$ 和 $|\\exists x\\, \\alpha| = 1 + |\\alpha|$。一个推导的切削秩(cut-rank)是该推导中出现的所有切削公式 $\\chi$ 的最大秩 $|\\chi|$。\n\n假设在该矢列演算中，一个推导有且仅有一个 $\\mathsf{cut}$，其切削公式为\n$$\\forall x\\,\\big(P(x) \\land (\\neg Q \\lor R)\\big),$$\n其中 $P$, $Q$ 和 $R$ 是原子公式。考虑执行由切削消除定理所证明的标准切削消减步骤：首先，通过用自由变元 $t$ 替换 $x$，将全称量词上的切削消减为对一个特定实例的切削；然后，通过将合取式切削拆分为对两个合取项的两个切削来消减它。仅使用上述定义以及每个消减步骤在分解切削公式的主联结词或量词时严格减小切削秩度量这一事实，计算经过这两个消减步骤后所得推导的最大切削秩。\n\n你的最终答案必须是一个精确写出的整数，不得近似或取整。答案不带单位。不要进行任何舍入，给出精确值。", "solution": "该问题要求计算一个矢列演算推导在执行两个特定的切削消减步骤序列后所得的最大切削秩。\n\n首先，对给定的问题陈述进行验证。该问题处于一阶矢列演算和证明论的标准框架内。它为公式的秩提供了清晰、明确且自洽的定义，并描述了一个标准的切削消减过程。问题是形式化的、客观的且定义良好的，要求根据给定的初始条件和规则得出一个具体的值。不存在矛盾、歧义或科学上的不准确之处。因此，该问题被认为是有效的。\n\n解题过程通过追踪切削公式的变换并在每个阶段计算其秩来进行。\n\n**步骤1：初始状态分析**\n\n初始推导包含一个对公式 $\\chi$ 的单一 $\\mathsf{cut}$：\n$$ \\chi = \\forall x\\,\\big(P(x) \\land (\\neg Q \\lor R)\\big) $$\n该初始推导的切削秩是 $\\chi$ 的秩，记为 $|\\chi|$。我们使用所提供的递归定义来计算此秩。问题陈述 $P$、$Q$ 和 $R$ 是原子公式。对于任意项 $t$，原子分量的秩为 $|P(t)| = 1$、$|Q| = 1$ 和 $|R| = 1$。\n\n我们从子公式开始向上计算 $\\chi$ 的秩：\n- 否定公式 $\\neg Q$ 的秩为 $|\\neg Q| = 1 + |Q| = 1 + 1 = 2$。\n- 析取式 $\\neg Q \\lor R$ 的秩为 $|\\neg Q \\lor R| = 1 + |\\neg Q| + |R| = 1 + 2 + 1 = 4$。\n- 对于任意变元 $x$，量词内合取式的秩为 $|P(x) \\land (\\neg Q \\lor R)| = 1 + |P(x)| + |\\neg Q \\lor R| = 1 + 1 + 4 = 6$。\n- 最后，初始切削公式 $\\chi$ 的秩为 $|\\chi| = |\\forall x\\,\\big(P(x) \\land (\\neg Q \\lor R)\\big)| = 1 + |P(x) \\land (\\neg Q \\lor R)| = 1 + 6 = 7$。\n\n所以，推导的初始切削秩为 $7$。\n\n**步骤2：对全称量词进行第一步消减**\n\n如前所述，第一步消减处理 $\\chi$ 的主联结词，即全称量词 $\\forall x$。对于一个主 $\\forall$-切削，标准的切削消除过程是将对 $\\forall x\\, A(x)$ 的切削替换为对一个特定实例 $A(t)$ 的切削，其中 $t$ 是一个项（在本例中，被描述为一个自由变元）。这严格地降低了切削公式的复杂性。\n\n对 $\\chi = \\forall x\\,\\big(P(x) \\land (\\neg Q \\lor R)\\big)$ 的切削被替换为一个新的、对公式 $\\chi_1$ 的单一切削：\n$$ \\chi_1 = P(t) \\land (\\neg Q \\lor R) $$\n这个新切削公式的秩为 $|\\chi_1|$。根据我们之前的计算，这个秩是 $|\\chi_1| = |P(t) \\land (\\neg Q \\lor R)| = 6$。此步骤后，推导中有一个秩为 $6$ 的切削。此时，推导的最大切削秩为 $6$。\n\n**步骤3：对合取式进行第二步消减**\n\n第二步消减处理新切削公式 $\\chi_1$ 的主联结词，即合取 $\\land$。问题指明，此消减将该切削拆分为“对两个合取项的两个切削”。这对应于标准的消减步骤，即一个对公式 $A \\land B$ 的切削被一个更复杂的推导结构所取代，该结构涉及一个对公式 $A$ 的切削和另一个对公式 $B$ 的切削。\n\n因此，对 $\\chi_1 = P(t) \\land (\\neg Q \\lor R)$ 的切削被消除，并被两个新的切削所取代。这两个切削的公式是 $\\chi_1$ 的合取项：\n- 第一个新切削公式是 $\\chi_2 = P(t)$。\n- 第二个新切削公式是 $\\chi_3 = \\neg Q \\lor R$。\n\n**步骤4：计算最终的最大切削秩**\n\n最终的推导不再包含对 $\\chi$ 或 $\\chi_1$ 的切削。取而代之的是，它包含两个分别对 $\\chi_2$ 和 $\\chi_3$ 的切削。这个最终推导的切削秩是其中所有切削公式的秩的最大值。我们必须计算 $\\chi_2$ 和 $\\chi_3$ 的秩。\n- $\\chi_2 = P(t)$ 的秩为 $|\\chi_2| = |P(t)| = 1$，因为 $P$ 是一个原子公式。\n- $\\chi_3 = \\neg Q \\lor R$ 的秩为 $|\\chi_3| = |\\neg Q \\lor R| = 4$，如步骤1中所计算。\n\n所得推导中切削公式的秩的集合是 $\\{1, 4\\}$。最大切削秩是此集合中的最大值。\n$$ \\text{最大切削秩} = \\max(|\\chi_2|, |\\chi_3|) = \\max(1, 4) = 4 $$\n每个消减步骤都严格减小了被切削公式的秩（$|\\chi_1| = 6  |\\chi| = 7$，以及 $|\\chi_2| = 1  |\\chi_1| = 6$ 和 $|\\chi_3| = 4  |\\chi_1| = 6$），这与切削消除定理是一致的。最终推导的最大切削秩由新切削公式中最复杂的那个决定，即秩为 $4$ 的 $\\chi_3$。", "answer": "$$\\boxed{4}$$", "id": "3052309"}, {"introduction": "矢列演算等形式化方法的一个强大应用是精确比较不同逻辑系统的能力。这个练习 [@problem_id:3052311] 介绍了一种经典工具——哥德尔-根岑负翻译（Gödel–Gentzen negative translation），它能将经典逻辑公式嵌入到直觉主义逻辑的框架中。通过动手执行这个翻译过程并量化其对公式（特别是对否定符号 $\\neg$ 的引入）的影响，你将看到纯粹的句法操作如何揭示不同推理系统之间的深刻联系。", "problem": "考虑通过哥德尔-根岑负翻译将经典矢列演算（LK）嵌入到直觉主义矢列演算（LJ）中，这是一种见证经典可证性与直觉主义可证性之间差异的标准工具。我们在一个一阶语言中进行工作，该语言包含谓词符号 $P_{i}$、联结词 $\\land$、$\\lor$、$\\to$、谬误 $\\bot$ 以及量词 $\\forall$、$\\exists$。在翻译的目标中，将 $\\neg \\varphi$ 写成一个原始符号，但在与直觉主义推理相关联时，将 $\\neg \\varphi$ 理解为 $\\varphi \\to \\bot$ 的缩写。\n\n对一阶公式上的哥德尔-根岑负翻译 $N(\\cdot)$ 进行如下归纳定义：\n- 对于原子公式 $A$，有 $N(A) := \\neg \\neg A$。\n- $N(\\bot) := \\bot$。\n- $N(\\varphi \\land \\psi) := N(\\varphi) \\land N(\\psi)$。\n- $N(\\varphi \\lor \\psi) := \\neg \\neg \\bigl(N(\\varphi) \\lor N(\\psi)\\bigr)$。\n- $N(\\varphi \\to \\psi) := N(\\varphi) \\to N(\\psi)$。\n- $N(\\forall x\\,\\varphi) := \\forall x\\, N(\\varphi)$。\n- $N(\\exists x\\,\\varphi) := \\neg \\neg \\exists x\\, N(\\varphi)$。\n\n对于一个给定的正整数 $n$，考虑经典公式\n$$\n\\varphi_{n} \\;:=\\; \\bigwedge_{i=1}^{n} \\exists x_{i}\\,\\Bigl( P_{i}(x_{i}) \\;\\lor\\; \\forall y\\,\\bigl(P_{i}(y)\\to \\bot\\bigr) \\Bigr).\n$$\n\n当使用上述归纳定义展开 $N(\\varphi_{n})$ 时，计算所得公式中否定符号 $\\neg$ 的总出现次数，其中 $\\neg$ 的每次出现都单独计数。请将你的最终答案表示为一个关于 $n$ 的封闭形式解析表达式。不需要四舍五入，也不涉及单位。你的答案必须是一个单一的表达式。", "solution": "用户提供了一个定义明确的数理逻辑问题。任务是将哥德尔-根岑负翻译应用于给定的一阶公式，并计算所得表达式中否定符号的数量。所有定义都精确无误，且问题是自洽的。因此，该问题是有效的，我将给出完整的解答。\n\n令 $\\mathcal{C}(\\phi)$ 表示在翻译后的公式 $N(\\phi)$ 中否定符号 $\\neg$ 总出现次数的函数。基于翻译 $N(\\cdot)$ 的归纳定义，我们可以为 $\\mathcal{C}(\\phi)$ 建立一组递推关系：\n\\begin{itemize}\n    \\item 对于原子公式 $A$，有 $N(A) = \\neg \\neg A$。因此，$\\mathcal{C}(A) = 2$。\n    \\item $N(\\bot) = \\bot$。因此，$\\mathcal{C}(\\bot) = 0$。\n    \\item $N(\\varphi \\land \\psi) = N(\\varphi) \\land N(\\psi)$。否定符号的数量是相加的。因此，$\\mathcal{C}(\\varphi \\land \\psi) = \\mathcal{C}(\\varphi) + \\mathcal{C}(\\psi)$。\n    \\item $N(\\varphi \\lor \\psi) = \\neg \\neg (N(\\varphi) \\lor N(\\psi))$。这在子公式的否定符号之外，引入了两个新的否定符号。因此，$\\mathcal{C}(\\varphi \\lor \\psi) = 2 + \\mathcal{C}(\\varphi) + \\mathcal{C}(\\psi)$。\n    \\item $N(\\varphi \\to \\psi) = N(\\varphi) \\to N(\\psi)$。否定符号的数量是相加的。因此，$\\mathcal{C}(\\varphi \\to \\psi) = \\mathcal{C}(\\varphi) + \\mathcal{C}(\\psi)$。\n    \\item $N(\\forall x\\,\\varphi) = \\forall x\\, N(\\varphi)$。量词不增加否定符号。因此，$\\mathcal{C}(\\forall x\\,\\varphi) = \\mathcal{C}(\\varphi)$。\n    \\item $N(\\exists x\\,\\varphi) = \\neg \\neg \\exists x\\, N(\\varphi)$。这引入了两个新的否定符号。因此，$\\mathcal{C}(\\exists x\\,\\varphi) = 2 + \\mathcal{C}(\\varphi)$。\n\\end{itemize}\n\n待分析的公式为 $\\varphi_{n} \\;:=\\; \\bigwedge_{i=1}^{n} \\psi_i$，其中每个子公式 $\\psi_i$ 由下式给出\n$$\n\\psi_i \\;:=\\; \\exists x_{i}\\,\\Bigl( P_{i}(x_{i}) \\;\\lor\\; \\forall y\\,\\bigl(P_{i}(y)\\to \\bot\\bigr) \\Bigr).\n$$\n使用合取规则，$N(\\varphi_n)$ 中否定符号的总数是每个翻译后合取项计数的总和：\n$$\n\\mathcal{C}(\\varphi_n) = \\mathcal{C}\\left(\\bigwedge_{i=1}^{n} \\psi_i\\right) = \\sum_{i=1}^{n} \\mathcal{C}(\\psi_i).\n$$\n每个公式 $\\psi_i$ 的结构都是相同的，涉及一个唯一的谓词 $P_i$ 和一个约束变量 $x_i$，但否定符号的计数规则与具体的谓词名称或变量名称无关。因此，对于所有从 $1$ 到 $n$ 的 $i$，$\\mathcal{C}(\\psi_i)$ 的值是恒定的。设这个常数值为 $C$。那么总计数为 $\\mathcal{C}(\\varphi_n) = nC$。\n\n我们的任务简化为计算任意单个实例 $i$ 的 $C = \\mathcal{C}(\\psi_i)$ 的值。为清晰起见，我们省略索引 $i$，并计算以下公式的 $\\mathcal{C}(\\psi)$\n$$\n\\psi \\;:=\\; \\exists x\\,\\Bigl( P(x) \\;\\lor\\; \\forall y\\,\\bigl(P(y)\\to \\bot\\bigr) \\Bigr).\n$$\n我们从最外层的算子向内，系统地应用递推关系。\n\n令 $\\theta(x) := P(x) \\lor \\forall y\\,\\bigl(P(y)\\to \\bot\\bigr)$。那么 $\\psi = \\exists x\\,\\theta(x)$。\n应用存在量词的规则：\n$$\n\\mathcal{C}(\\psi) = \\mathcal{C}(\\exists x\\,\\theta(x)) = 2 + \\mathcal{C}(\\theta(x)).\n$$\n接下来，我们确定 $\\mathcal{C}(\\theta(x))$。令 $\\sigma := \\forall y\\,\\bigl(P(y)\\to \\bot\\bigr)$。那么 $\\theta(x) = P(x) \\lor \\sigma$。\n应用析取规则：\n$$\n\\mathcal{C}(\\theta(x)) = \\mathcal{C}(P(x) \\lor \\sigma) = 2 + \\mathcal{C}(P(x)) + \\mathcal{C}(\\sigma).\n$$\n此处，$P(x)$ 是一个原子公式。根据我们的规则，$\\mathcal{C}(P(x)) = 2$。\n所以，我们有 $\\mathcal{C}(\\theta(x)) = 2 + 2 + \\mathcal{C}(\\sigma) = 4 + \\mathcal{C}(\\sigma)$。\n\n现在，我们必须求出 $\\mathcal{C}(\\sigma)$。令 $\\rho(y) := P(y)\\to \\bot$。那么 $\\sigma = \\forall y\\,\\rho(y)$。\n应用全称量词的规则：\n$$\n\\mathcal{C}(\\sigma) = \\mathcal{C}(\\forall y\\,\\rho(y)) = \\mathcal{C}(\\rho(y)).\n$$\n最后，我们计算 $\\mathcal{C}(\\rho(y))$。公式为 $\\rho(y) = P(y)\\to \\bot$。\n应用蕴含规则：\n$$\n\\mathcal{C}(\\rho(y)) = \\mathcal{C}(P(y) \\to \\bot) = \\mathcal{C}(P(y)) + \\mathcal{C}(\\bot).\n$$\n$P(y)$ 是一个原子公式，所以 $\\mathcal{C}(P(y)) = 2$。\n公式 $\\bot$ 是一个基本情况，所以 $\\mathcal{C}(\\bot) = 0$。\n因此，$\\mathcal{C}(\\rho(y)) = 2 + 0 = 2$。\n\n现在，我们将结果代回到计算链中：\n\\begin{enumerate}\n    \\item $\\mathcal{C}(\\sigma) = \\mathcal{C}(\\rho(y)) = 2$。\n    \\item $\\mathcal{C}(\\theta(x)) = 4 + \\mathcal{C}(\\sigma) = 4 + 2 = 6$。\n    \\item $\\mathcal{C}(\\psi) = 2 + \\mathcal{C}(\\theta(x)) = 2 + 6 = 8$。\n\\end{enumerate}\n所以，每个子公式 $\\psi_i$ 的常数计数为 $C=8$。\n\n$N(\\varphi_n)$ 中否定符号的总数是 $n$ 个子公式的计数之和：\n$$\n\\mathcal{C}(\\varphi_n) = \\sum_{i=1}^{n} \\mathcal{C}(\\psi_i) = \\sum_{i=1}^{n} 8 = 8n.\n$$\n否定符号的总出现次数为 $8n$。", "answer": "$$\n\\boxed{8n}\n$$", "id": "3052311"}]}