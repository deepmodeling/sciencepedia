{"hands_on_practices": [{"introduction": "我们将从一个基本但至关重要的原则开始：α-等价的项必须具有完全相同的自由变量集合。这个练习 ([@problem_id:3060354]) 将引导你应用这一定理，通过计算和比较自由变量，快速判断两个 lambda 项是否可能等价。这不仅是一个计算练习，更是理解 α-等价核心性质的第一步，为你提供了一个证明不等价的有力工具。", "problem": "在无类型 lambda 演算中，考虑由 $t ::= x \\mid t_1\\,t_2 \\mid \\lambda x.\\,t$ 给出的项的语法，其中 $x$ 的取值范围是一个可数无限的变量集合。自由变量的集合 $\\mathrm{FV}(t)$ 由以下基本规则归纳定义：$\\mathrm{FV}(x) = \\{x\\}$，$\\mathrm{FV}(t_1\\,t_2) = \\mathrm{FV}(t_1) \\cup \\mathrm{FV}(t_2)$，以及 $\\mathrm{FV}(\\lambda x.\\,t) = \\mathrm{FV}(t) \\setminus \\{x\\}$。Alpha-等价（$\\alpha$-等价）是最小的同余关系，它识别那些仅因使用避免捕获的替换对绑定变量进行一致重命名而不同的项：如果 $z \\notin \\mathrm{FV}(M)$，那么 $\\lambda x.\\,M \\equiv_{\\alpha} \\lambda z.\\,M[x:=z]$，并且 $\\equiv_{\\alpha}$ 在应用和抽象下是保持的。\n\n令 $M = \\lambda x.\\,(x\\ y)$ 和 $N = \\lambda y.\\,(y\\ y)$。定义指示符\n$$\nI \\;=\\; \\begin{cases}\n1  \\text{若 } M \\equiv_{\\alpha} N,\\\\\n0  \\text{否则。}\n\\end{cases}\n$$\n仅使用上述核心定义，并通过关于自由变量、绑定变量和避免捕获的重命名的严谨推理，通过检查变量 $y$ 在 $M$ 和 $N$ 中的状态来确定 $I$ 的值。你的最终答案必须是单个数字 $0$ 或 $1$。", "solution": "该问题陈述经验证具有科学依据、问题明确且客观。它是无类型 lambda 演算这一成熟框架内的一个形式化问题。所有定义都是标准的，足以推导出一个唯一解。\n\n任务是确定指示符 $I$ 的值，该值取决于 lambda 项 $M = \\lambda x.\\,(x\\ y)$ 和 $N = \\lambda y.\\,(y\\ y)$ 是否是 $\\alpha$-等价的。如果一个项可以通过对绑定变量的一系列重命名从另一个项得到，那么这两个项就是 $\\alpha$-等价的，记为 $\\equiv_{\\alpha}$。$\\alpha$-等价的一个关键性质是它保持自由变量的集合不变。也就是说，如果两个项 $T_1$ 和 $T_2$ 是 $\\alpha$-等价的，那么它们的自由变量集合必须是相同的：$T_1 \\equiv_{\\alpha} T_2 \\implies \\mathrm{FV}(T_1) = \\mathrm{FV}(T_2)$。我们可以使用这个必要条件来检验不等价性。如果自由变量的集合不同，那么这两个项不可能是 $\\alpha$-等价的。\n\n我们继续使用所提供的归纳规则，计算每个项 $M$ 和 $N$ 的自由变量集合。\n\n首先，我们分析项 $M = \\lambda x.\\,(x\\ y)$。\n自由变量集合的计算方法是 $\\mathrm{FV}(\\lambda x.\\,t) = \\mathrm{FV}(t) \\setminus \\{x\\}$。\n在我们的例子中，抽象的主体是项 $t = (x\\ y)$。\n我们首先找出主体的自由变量：\n$$\n\\mathrm{FV}(x\\ y) = \\mathrm{FV}(x) \\cup \\mathrm{FV}(y)\n$$\n使用定义的基本情况，$\\mathrm{FV}(x) = \\{x\\}$ 和 $\\mathrm{FV}(y) = \\{y\\}$。\n因此，\n$$\n\\mathrm{FV}(x\\ y) = \\{x\\} \\cup \\{y\\} = \\{x, y\\}\n$$\n现在，我们应用 lambda 抽象的规则来找出 $M$ 的自由变量：\n$$\n\\mathrm{FV}(M) = \\mathrm{FV}(\\lambda x.\\,(x\\ y)) = \\mathrm{FV}(x\\ y) \\setminus \\{x\\} = \\{x, y\\} \\setminus \\{x\\} = \\{y\\}\n$$\n在项 $M$ 中，变量 $x$ 被 lambda 抽象所绑定，而变量 $y$ 是自由的。\n\n接下来，我们分析项 $N = \\lambda y.\\,(y\\ y)$。\n自由变量集合的计算方法是 $\\mathrm{FV}(\\lambda y.\\,t) = \\mathrm{FV}(t) \\setminus \\{y\\}$。\n这里，抽象的主体是项 $t = (y\\ y)$。\n我们找出主体的自由变量：\n$$\n\\mathrm{FV}(y\\ y) = \\mathrm{FV}(y) \\cup \\mathrm{FV}(y)\n$$\n使用基本情况 $\\mathrm{FV}(y) = \\{y\\}$，我们得到：\n$$\n\\mathrm{FV}(y\\ y) = \\{y\\} \\cup \\{y\\} = \\{y\\}\n$$\n现在，我们应用 lambda 抽象的规则来找出 $N$ 的自由变量：\n$$\n\\mathrm{FV}(N) = \\mathrm{FV}(\\lambda y.\\,(y\\ y)) = \\mathrm{FV}(y\\ y) \\setminus \\{y\\} = \\{y\\} \\setminus \\{y\\} = \\emptyset\n$$\n在项 $N$ 中，变量 $y$ 的两次出现都被 lambda 抽象所绑定。项 $N$ 没有自由变量。\n\n现在我们比较 $M$ 和 $N$ 的自由变量集合：\n$$\n\\mathrm{FV}(M) = \\{y\\}\n$$\n$$\n\\mathrm{FV}(N) = \\emptyset\n$$\n由于 $\\mathrm{FV}(M) \\neq \\mathrm{FV}(N)$，$\\alpha$-等价的必要条件不满足。因此，项 $M$ 和 $N$ 不是 $\\alpha$-等价的：\n$$\nM \\not\\equiv_{\\alpha} N\n$$\n指示符 $I$ 定义为：\n$$\nI \\;=\\; \\begin{cases}\n1  \\text{若 } M \\equiv_{\\alpha} N,\\\\\n0  \\text{否则。}\n\\end{cases}\n$$\n因为我们已经严格证明了 $M \\not\\equiv_{\\alpha} N$，所以条件为“否则”。\n因此，指示符的值是 $I = 0$。", "answer": "$$\\boxed{0}$$", "id": "3060354"}, {"introduction": "在 lambda 演算中，一个常见的混淆来源是“变量遮蔽”——即内部作用域的绑定变量与外部作用域的变量同名。这个练习 ([@problem_id:3060306]) 将带你直面这一挑战，通过对一个嵌套的 lambda 项进行 α-重命名来消除歧义，从而准确地计算其自由变量。掌握此技巧对于正确分析和操作复杂的函数式程序至关重要。", "problem": "设 $t$ 为无类型 lambda 演算项\n$$\nt \\;=\\; \\lambda x.\\,\\big( f(x,y)\\ \\ (\\lambda y.\\, g(y,z)) \\big),\n$$\n其中应用是左结合的，且 $f(x,y)$ 是 $((f\\ x)\\ y)$ 的简写。将 $f$ 和 $g$ 视为变量标识符（它们可能表示高阶函数），$x$，$y$，$z$ 也视为变量标识符。仅从无类型 lambda 演算中自由变量和绑定变量的标准归纳定义，以及 alpha 等价（绑定变量的重命名）的定义出发，计算项 $t$ 的自由变量集合 $\\mathrm{FV}(t)$，并对每个变量的包含或排除给出理由。在你的推导中，首先对内部绑定符 $\\lambda y$ 进行一次到新鲜变量的避免捕获的 alpha 重命名，以明确 $f(x,y)$ 中 $y$ 的外部出现不受内部 $\\lambda y$ 的约束。你的最终答案必须以一个集合表达式的形式给出，该集合精确地包含 $t$ 的所有自由变量。", "solution": "这个问题是有效的，因为它是无类型 lambda 演算这一形式系统内的一个明确定义的问题，而无类型 lambda 演算是数理逻辑和理论计算机科学的核心主题。问题陈述是自洽的、无歧义的，并依赖于标准定义。\n\n给定的 lambda 演算项是：\n$$\nt \\;=\\; \\lambda x.\\,\\big( f(x,y)\\ \\ (\\lambda y.\\, g(y,z)) \\big)\n$$\n$f(x,y)$ 这种表示法是 $((f\\ x)\\ y)$ 的简写。鉴于应用是左结合的，项 $t$ 可以用其完全括号形式写作：\n$$\nt \\;=\\; \\lambda x.\\,\\Big( \\big( (f\\ x)\\ y \\big)\\ \\big( \\lambda y.\\, ((g\\ y)\\ z) \\big) \\Big)\n$$\n核心任务是计算自由变量的集合，记作 $\\mathrm{FV}(t)$。我们将使用自由变量的标准归纳定义：\n1.  $\\mathrm{FV}(v) = \\{v\\}$，对于任意变量 $v$。\n2.  $\\mathrm{FV}(E_1\\ E_2) = \\mathrm{FV}(E_1) \\cup \\mathrm{FV}(E_2)$，对于一个应用。\n3.  $\\mathrm{FV}(\\lambda v. E) = \\mathrm{FV}(E) \\setminus \\{v\\}$，对于一个 lambda 抽象。\n\n问题要求我们首先对内部绑定符 $\\lambda y$ 进行一次避免捕获的 alpha 重命名。项 $t$ 中，变量标识符 $y$ 有两个不同的作用域。$((f\\ x)\\ y)$ 中 $y$ 的第一次出现位于外部 $\\lambda x$ 绑定符的作用域内。$y$ 的第二次和第三次出现在子项 $\\lambda y.\\, ((g\\ y)\\ z)$ 中，其中 $(g\\ y)$ 中的 $y$ 被内部的 $\\lambda y$ 绑定。为了明确这种作用域关系并避免混淆，我们重命名内部的绑定变量。\n\n我们选择一个新鲜变量名 $w$，它没有在 $t$ 的任何地方出现过。我们对内部子项进行 alpha 变换：\n$$\n\\lambda y.\\, ((g\\ y)\\ z) \\quad \\xrightarrow{\\alpha} \\quad \\lambda w.\\, ((g\\ w)\\ z)\n$$\n这是一个有效的 alpha 等价变换，因为 $w$ 是新鲜的，并且不会被 $((g\\ y)\\ z)$ 内的任何其他绑定符捕获，也不会捕获该子项中的任何自由变量。\n\n将这个重命名后的子项代回到 $t$ 中，我们得到一个 alpha 等价的项，称之为 $t'$：\n$$\nt' \\;=\\; \\lambda x.\\,\\Big( \\big( (f\\ x)\\ y \\big)\\ \\big( \\lambda w.\\, ((g\\ w)\\ z) \\big) \\Big)\n$$\n由于 $t$ 和 $t'$ 是 alpha 等价的（$t \\equiv_\\alpha t'$），它们具有相同的自由变量集合，即 $\\mathrm{FV}(t) = \\mathrm{FV}(t')$。我们现在可以通过递归应用定义来计算 $\\mathrm{FV}(t')$。\n\n设 $B$ 是 $t'$ 中主 lambda 抽象的主体：\n$$\nB \\;=\\; \\big( (f\\ x)\\ y \\big)\\ \\big( \\lambda w.\\, ((g\\ w)\\ z) \\big)\n$$\n根据 lambda 抽象的定义：\n$$\n\\mathrm{FV}(t') = \\mathrm{FV}(\\lambda x. B) = \\mathrm{FV}(B) \\setminus \\{x\\}\n$$\n现在，我们计算 $\\mathrm{FV}(B)$。根据应用的定义：\n$$\n\\mathrm{FV}(B) = \\mathrm{FV}\\big( (f\\ x)\\ y \\big) \\cup \\mathrm{FV}\\big( \\lambda w.\\, ((g\\ w)\\ z) \\big)\n$$\n我们分别计算每个部分的自由变量。\n\n对于第一部分 $\\mathrm{FV}\\big( (f\\ x)\\ y \\big)$：\n$$\n\\mathrm{FV}\\big( (f\\ x)\\ y \\big) = \\mathrm{FV}(f\\ x) \\cup \\mathrm{FV}(y)\n$$\n$$\n= \\big( \\mathrm{FV}(f) \\cup \\mathrm{FV}(x) \\big) \\cup \\mathrm{FV}(y)\n$$\n对每个变量应用基本情况 $\\mathrm{FV}(v) = \\{v\\}$：\n$$\n= \\big( \\{f\\} \\cup \\{x\\} \\big) \\cup \\{y\\} = \\{f, x, y\\}\n$$\n这个表达式中的变量 $y$ 显然是自由的。\n\n对于第二部分 $\\mathrm{FV}\\big( \\lambda w.\\, ((g\\ w)\\ z) \\big)$：\n$$\n\\mathrm{FV}\\big( \\lambda w.\\, ((g\\ w)\\ z) \\big) = \\mathrm{FV}\\big( ((g\\ w)\\ z) \\big) \\setminus \\{w\\}\n$$\n首先，我们找出主体 $((g\\ w)\\ z)$ 的自由变量：\n$$\n\\mathrm{FV}\\big( ((g\\ w)\\ z) \\big) = \\mathrm{FV}(g\\ w) \\cup \\mathrm{FV}(z) = \\big(\\mathrm{FV}(g) \\cup \\mathrm{FV}(w)\\big) \\cup \\mathrm{FV}(z)\n$$\n$$\n= \\big(\\{g\\} \\cup \\{w\\}\\big) \\cup \\{z\\} = \\{g, w, z\\}\n$$\n现在，我们移除绑定变量 $w$：\n$$\n\\mathrm{FV}\\big( \\lambda w.\\, ((g\\ w)\\ z) \\big) = \\{g, w, z\\} \\setminus \\{w\\} = \\{g, z\\}\n$$\n\n现在，我们合并结果以求得 $\\mathrm{FV}(B)$：\n$$\n\\mathrm{FV}(B) = \\{f, x, y\\} \\cup \\{g, z\\} = \\{f, x, y, g, z\\}\n$$\n最后，我们通过移除被最外层 lambda 绑定的变量 $x$ 来计算 $\\mathrm{FV}(t')$：\n$$\n\\mathrm{FV}(t') = \\mathrm{FV}(B) \\setminus \\{x\\} = \\{f, x, y, g, z\\} \\setminus \\{x\\} = \\{f, y, g, z\\}\n$$\n由于 $\\mathrm{FV}(t) = \\mathrm{FV}(t')$，原始项 $t$ 的自由变量集合是 $\\{f, y, g, z\\}$。\n\n对每个变量的理由说明：\n- $f$：它作为应用 $((f\\ x)\\ y)$ 中的函数出现，并且没有被任何 lambda 抽象绑定。因此，$f$ 是自由的。\n- $g$：它作为内部 lambda 中应用 $((g\\ y)\\ z)$ 的函数出现，但既没有被 $\\lambda y$（或重命名后的 $\\lambda w$）绑定，也没有被外部的 $\\lambda x$ 绑定。因此，$g$ 是自由的。\n- $y$：在 $((f\\ x)\\ y)$ 中出现的 $y$ 不在内部 $\\lambda y$ 绑定符的作用域内。它只在外部 $\\lambda x$ 绑定符的作用域内，而该绑定符绑定的是 $x$，不是 $y$。因此，这个出现的 $y$ 是自由的。在 $\\lambda y. g(y,z)$ 中出现的 $y$ 是被绑定的，因此对整个项的自由变量集合没有贡献。\n- $z$：它作为 $((g\\ y)\\ z)$ 中的一个参数出现，并且没有被内部的 $\\lambda y$ 或外部的 $\\lambda x$ 绑定。因此，$z$ 是自由的。\n- $x$：它出现在 $((f\\ x)\\ y)$ 中，但被最外层的抽象 $\\lambda x$ 绑定。因此，$x$ 不是自由的。", "answer": "$$\n\\boxed{\\{f, g, y, z\\}}\n$$", "id": "3060306"}, {"introduction": "我们已经学会了如何识别不等价的项和处理变量遮蔽，现在是时候综合运用这些知识来构造一个等价性证明了。本练习 ([@problem_id:3060326]) 要求你证明两个因变量遮蔽而看似不同的 lambda 项实际上是 α-等价的。你需要通过一系列严格的、避免捕获的重命名步骤，将一个项转换为另一个项，从而体验 α-等价作为一种形式变换规则的强大功能。", "problem": "考虑无类型 $\\lambda$-演算项 $t_{1} = \\lambda x.(\\lambda x.(x\\ x))$ 和 $t_{2} = \\lambda y.(\\lambda z.(z\\ z))$。仅使用自由变量和约束变量的形式化定义、避免捕获的 $\\alpha$-转换，以及 $\\alpha$-等价作为最小同余关系（在避免捕获的约束变量重命名下封闭）的归纳定义，判断 $t_{1}$ 和 $t_{2}$ 是否 $\\alpha$-等价。你的推导必须通过验证相关的自由变量边条件来明确证明每一步重命名，并且必须解释在这些项中变量遮蔽是如何处理的。\n\n以单个数字形式提供最终答案：如果 $t_{1}$ 和 $t_{2}$ 是 $\\alpha$-等价的，则写 $1$，否则写 $0$。无需四舍五入。不要包含任何单位。", "solution": "问题是判断两个 $\\lambda$-演算项 $t_1 = \\lambda x.(\\lambda x.(x\\ x))$ 和 $t_2 = \\lambda y.(\\lambda z.(z\\ z))$ 是否 $\\alpha$-等价。这个判断将通过严格应用自由变量、避免捕获的 $\\alpha$-转换和 $\\alpha$-等价的形式化定义来做出。\n\n首先，我们陈述必要的定义。\n一个项 $M$ 的自由变量集合，记作 $FV(M)$，被归纳定义如下：\n1. 对于任意变量 $v$，有 $FV(v) = \\{v\\}$。\n2. 对于任意项 $M$ 和 $N$，有 $FV(M\\ N) = FV(M) \\cup FV(N)$。\n3. 对于任意变量 $v$ 和项 $M$，有 $FV(\\lambda v.M) = FV(M) \\setminus \\{v\\}$。\n\n如果一个变量 $v$ 在项中的出现位于形如 $\\lambda v.M$ 的子项内，那么它是约束的。如果一次出现不是约束的，那么它是自由的。在具有相同变量名的嵌套抽象中，变量的出现被最内层的抽象所约束。这种现象被称为变量遮蔽。\n\n避免捕获的 $\\alpha$-转换（或重命名）规定，对于一个抽象 $\\lambda x.M$，我们可以将约束变量 $x$ 重命名为一个新变量 $y$，写作 $\\lambda x.M \\to_\\alpha \\lambda y.(M[x:=y])$，当且仅当 $y$ 不作为自由变量出现在 $M$ 中（即 $y \\notin FV(M)$）并且 $y$ 不等于 $x$。符号 $M[x:=y]$ 表示将 $M$ 中所有 $x$ 的自由出现替换为 $y$。\n\n$\\alpha$-等价，记作 $=_\\alpha$，是包含 $\\to_\\alpha$ 的最小等价关系。它是一种同余关系，意味着它在项的构造子下是保持的。具体来说：\n- 如果 $M =_\\alpha N$，那么 $\\lambda v.M =_\\alpha \\lambda v.N$。\n- 如果 $M_1 =_\\alpha M_2$ 且 $N_1 =_\\alpha N_2$，那么 $(M_1\\ N_1) =_\\alpha (M_2\\ N_2)$。\n\n我们现在分析项 $t_1 = \\lambda x.(\\lambda x.(x\\ x))$。该项表现出变量遮蔽。外部绑定是 $\\lambda x$，其作用域是项 $M_1 = \\lambda x.(x\\ x)$。内部绑定也是 $\\lambda x$，其作用域是项 $M_2 = (x\\ x)$。在 $(x\\ x)$ 中变量 $x$ 的两次出现都在两个绑定的作用域内。然而，根据最内层作用域规则，它们被内部的 $\\lambda x$ 所约束。因此，在外部抽象的主体中没有 $x$ 的自由出现可供其绑定。为了形式化地验证这一点，我们计算外部 $\\lambda x$ 的主体（即项 $M_1$）的自由变量：\n$FV(M_1) = FV(\\lambda x.(x\\ x)) = FV(x\\ x) \\setminus \\{x\\}$。\n$FV(x\\ x) = FV(x) \\cup FV(x) = \\{x\\} \\cup \\{x\\} = \\{x\\}$。\n因此，$FV(M_1) = \\{x\\} \\setminus \\{x\\} = \\emptyset$。\n由于外部抽象 $\\lambda x$ 的主体没有自由变量，所以这个绑定是空泛的。\n\n接下来，我们分析项 $t_2 = \\lambda y.(\\lambda z.(z\\ z))$。外部抽象 $\\lambda y$ 的主体是项 $N = \\lambda z.(z\\ z)$。我们计算它的自由变量：\n$FV(N) = FV(\\lambda z.(z\\ z)) = FV(z\\ z) \\setminus \\{z\\}$。\n$FV(z\\ z) = FV(z) \\cup FV(z) = \\{z\\} \\cup \\{z\\} = \\{z\\}$。\n因此，$FV(N) = \\{z\\} \\setminus \\{z\\} = \\emptyset$。\n与 $t_1$ 类似，$t_2$ 中的外部绑定 $\\lambda y$ 也是空泛的。\n\n现在我们可以构建一个 $\\alpha$-等价链来检查是否 $t_1 =_\\alpha t_2$。策略是证明两个项都可以被转换为一个共同的形式。\n\n步骤 1：重命名 $t_1$ 的外部约束变量。\n我们有 $t_1 = \\lambda x.M_1$，其中 $M_1 = \\lambda x.(x\\ x)$。我们想把外部的 $x$ 重命名为 $y$，以匹配 $t_2$ 的外部变量。$\\alpha$-转换的规则是 $\\lambda x.M_1 \\to_\\alpha \\lambda y.(M_1[x:=y])$，如果 $y \\notin FV(M_1)$。我们已经计算出 $FV(M_1) = \\emptyset$。条件 $y \\notin \\emptyset$ 对任何变量 $y$ 都平凡为真。替换 $M_1[x:=y]$ 意味着我们将 $M_1$ 中所有 $x$ 的自由出现替换为 $y$。由于 $M_1$ 中没有 $x$ 的自由出现，替换没有任何效果：$M_1[x:=y] = M_1$。\n因此，我们有 $t_1 = \\lambda x.(\\lambda x.(x\\ x)) =_\\alpha \\lambda y.(\\lambda x.(x\\ x))$。\n\n步骤 2：重命名新项的内部约束变量。\n新的项是 $\\lambda y.(\\lambda x.(x\\ x))$。让我们关注它的主体 $\\lambda x.(x\\ x)$。我们想将约束变量 $x$ 重命名为 $z$，以匹配 $t_2$ 的内部结构。这个内部抽象的主体是 $(x\\ x)$。这个主体中的自由变量集合是 $FV(x\\ x) = \\{x\\}$。重命名条件是新变量 $z$ 不在该集合中。假设 $z$ 是一个与 $x$ 不同的变量，条件 $z \\notin \\{x\\}$ 为真。\n替换是 $(x\\ x)[x:=z]$，结果为 $(z\\ z)$。\n因此，$\\lambda x.(x\\ x) =_\\alpha \\lambda z.((x\\ x)[x:=z]) = \\lambda z.(z\\ z)$。\n\n步骤 3：应用同余性质。\n由于 $\\lambda x.(x\\ x) =_\\alpha \\lambda z.(z\\ z)$，抽象的同余规则允许我们在步骤 1 的更大表达式中替换等价的项：\n$\\lambda y.(\\lambda x.(x\\ x)) =_\\alpha \\lambda y.(\\lambda z.(z\\ z))$。\n\n步骤 4：合并步骤。\n根据 $\\alpha$-等价的传递性，我们合并我们步骤的结果：\n$t_1 = \\lambda x.(\\lambda x.(x\\ x))$\n$=_\\alpha \\lambda y.(\\lambda x.(x\\ x))$ (来自步骤 1)\n$=_\\alpha \\lambda y.(\\lambda z.(z\\ z))$ (来自步骤 2 和 3)\n得到的项 $\\lambda y.(\\lambda z.(z\\ z))$ 正是 $t_2$。\n因此，我们已经形式化地证明了 $t_1 =_\\alpha t_2$。\n\n这种等价的关键在于 $t_1$ 中存在的变量遮蔽。外部的 $\\lambda x$ 是一个空泛绑定，意味着它不绑定任何变量的出现。因此，它可以被重命名为任何其他变量（如 $y$），而不会改变项的含义，因为那个新变量也将是一个空泛绑定。一旦外部变量匹配，内部的抽象 $\\lambda x.(x\\ x)$ 和 $\\lambda z.(z\\ z)$ 就可以通过简单地重命名它们各自的约束变量，直接证明是 $\\alpha$-等价的。\n\n因为 $t_1$与 $t_2$ 是 $\\alpha$-等价的，所以答案是 $1$。", "answer": "$$\\boxed{1}$$", "id": "3060326"}]}