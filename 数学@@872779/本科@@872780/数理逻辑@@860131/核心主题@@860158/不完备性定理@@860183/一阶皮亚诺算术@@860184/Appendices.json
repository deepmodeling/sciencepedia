{"hands_on_practices": [{"introduction": "在一阶算术中探索自然数的性质之前，我们必须首先建立一种方法，仅使用我们形式语言中的符号来表示它们。这个基础练习 [@problem_id:3042003] 将引导你构建“数码”——即数字在句法上的对应物。通过基于后继函数符号 $S$ 和常数符号 $0$ 来定义每个数字的表示，你将亲身体验形式定义的递归性质，并巩固对抽象概念如何编码为符号项的理解。", "problem": "考虑皮亚诺算术（PA）的一阶语言，记作 $\\mathcal{L}_{PA}$，其非逻辑符号包括常数符号 $0$、一元函数符号 $S$、二元函数符号 $+$ 和 $\\times$ 以及二元谓词符号 $=$。在该语言中，一个项（term）由以下基本句法规则构成：如果 $c$ 是一个常数符号，那么 $c$ 是一个项；如果 $f$ 是一个 $k$ 元函数符号，且 $t_{1},\\dots,t_{k}$ 是项，那么 $f(t_{1},\\dots,t_{k})$ 是一个项；并且每个变量都是一个项。如果一个项不包含任何变量，则称其为闭项。$S$ 的预期解释是 $\\mathbb{N}$ 上的后继运算。\n\n请仅使用上述构成规则以及符号 $0$ 和 $S$，为每个 $n \\in \\mathbb{N}$ 定义一个闭 $\\mathcal{L}_{PA}$-项 $\\overline{n}$，称为 $n$ 的数码（numeral），它在 $\\mathcal{L}_{PA}$ 内句法地表示 $n$。请通过一个基于项的基本规则的构造来证明你的定义是良基的（well-founded），并解释为何对于每个 $n \\in \\mathbb{N}$，所得到的 $\\overline{n}$ 都是一个闭项。然后，计算特定数码 $\\overline{4}$ 以 $S$ 和 $0$ 表示的闭式表达式。你的最终答案必须是单一的符号表达式，无需进行舍入。", "solution": "问题陈述已经过严格验证。它在科学上是合理的、良定的、客观的，并完全符合一阶逻辑和皮亚诺算术的既定原则。其前提准确，语言精确，任务是数理逻辑中一个标准的、基础的练习。因此，该问题被认为是有效的。\n\n任务是在皮亚诺算术的一阶语言 $\\mathcal{L}_{PA}$ 内，为每个自然数 $n \\in \\mathbb{N}$ 定义一个句法表示。这些表示称为数码，记作 $\\overline{n}$，它们必须是仅使用常数符号 $0$ 和一元函数符号 $S$ 构造的闭项。\n\n数码 $\\overline{n}$ 的定义是通过对自然数 $n$ 进行递归来给出的。这种方法反映了自然数自身的归纳结构，其中每个数要么是 $0$，要么是另一个数的后继。\n\n形式化的递归定义如下：\n1.  **基本情形**：对于自然数 $0$，其对应的数码 $\\overline{0}$ 定义为语言 $\\mathcal{L}_{PA}$ 中的常数符号 $0$。\n    $$ \\overline{0} := 0 $$\n2.  **递归步骤**：对于任意自然数 $n$，如果数码 $\\overline{n}$ 已被定义，那么 $n$ 的后继（记作 $n+1$）的数码被定义为将后继函数符号 $S$ 应用于项 $\\overline{n}$。\n    $$ \\overline{n+1} := S(\\overline{n}) $$\n\n为了证明该定义对每个 $n \\in \\mathbb{N}$ 都产生一个有效的项，我们使用关于 $n$ 的数学归纳法原理。\n**基本情形（$n=0$）**：数码为 $\\overline{0} := 0$。根据问题的项构成规则，“如果 $c$ 是一个常数符号，那么 $c$ 是一个项。” 由于 $0$ 是 $\\mathcal{L}_{PA}$ 中的一个常数符号，因此 $\\overline{0}$ 是一个有效的项。\n**归纳步骤**：假设作为归纳假设，对于某个 $k \\in \\mathbb{N}$，数码 $\\overline{k}$ 是一个有效的项。我们必须证明 $\\overline{k+1}$ 也是一个有效的项。根据递归定义，$\\overline{k+1} := S(\\overline{k})$。符号 $S$ 是一个 1 元（一元）函数符号，并且根据归纳假设，$\\overline{k}$ 是一个项。项构成的第二条规则指出，“如果 $f$ 是一个 $k$ 元函数符号，且 $t_{1},\\dots,t_{k}$ 是项，那么 $f(t_{1},\\dots,t_{k})$ 是一个项。” 将此规则应用于 $f$ 为 $S$ 且项 $t_1$ 为 $\\overline{k}$ 的情况，我们得出结论：$S(\\overline{k})$ 是一个有效的项。因此，$\\overline{k+1}$ 是一个有效的项。\n根据数学归纳法原理，对于所有的 $n \\in \\mathbb{N}$，$\\overline{n}$ 都是一个良定义的项。\n\n接下来，我们必须解释为什么对于每个 $n \\in \\mathbb{N}$，$\\overline{n}$ 都是一个闭项。如果一个项不包含任何自由变量，它就是闭项。我们再次对 $n$ 进行归纳。\n**基本情形（$n=0$）**：该项为 $\\overline{0} := 0$。常数符号不是变量，所以项 $0$ 不包含任何变量。因此，$\\overline{0}$ 是一个闭项。\n**归纳步骤**：假设作为归纳假设，对于某个 $k \\in \\mathbb{N}$，数码 $\\overline{k}$ 是一个闭项，即它不包含任何变量。数码 $\\overline{k+1}$ 被构造为 $S(\\overline{k})$。唯一引入的新符号是函数符号 $S$ 和括号，它们都不是变量。由于子项 $\\overline{k}$ 根据假设不含变量，整个项 $S(\\overline{k})$也必定不含变量。因此，$\\overline{k+1}$ 是一个闭项。\n根据数学归纳法原理，对于所有的 $n \\in \\mathbb{N}$，$\\overline{n}$ 都是一个闭项。\n\n最后，我们被要求计算特定数码 $\\overline{4}$ 的闭式表达式。我们逐步应用递归定义：\n$0$ 的数码是 $\\overline{0} := 0$。\n$1$ 的数码是 $\\overline{1} := S(\\overline{0}) = S(0)$。\n$2$ 的数码是 $\\overline{2} := S(\\overline{1}) = S(S(0))$。\n$3$ 的数码是 $\\overline{3} := S(\\overline{2}) = S(S(S(0)))$。\n$4$ 的数码是 $\\overline{4} := S(\\overline{3}) = S(S(S(S(0))))$.\n这个最终表达式是一个完全由符号 $S$ 和 $0$ 构成的闭项，符合要求。", "answer": "$$\n\\boxed{S(S(S(S(0))))}\n$$", "id": "3042003"}, {"introduction": "逻辑学的力量在于通过操纵公式来推导出新的真理，而代入是这一过程的基石。然而，草率地替换一个变量可能会无意中改变公式的含义，这种现象被称为“变量捕获”。这个练习 [@problem_id:3041997] 提出了一个可能发生此类错误的经典场景，要求你应用精确的、避免捕获的代入定义。掌握这项技术对于确保逻辑推导的有效性至关重要，也是理解对角引理等高级结果的先决条件。", "problem": "在记为 $\\mathcal{L}_{PA}$ 的皮亚诺算术的单一类型一阶语言中，项由变量、常量 $0$、一元函数符号 $S$ 以及二元函数符号 $+$ 和 $\\times$ 构建。公式由形如 $t_1 = t_2$ 的原子公式使用逻辑联结词和量词构建。公式中变量的一次自由出现是指未被量词约束的出现；一次约束出现是指位于约束该变量的量词作用域内的出现。一个项或公式的自由变量集合记为 $FV(\\,\\cdot\\,)$。对于项的代换 $t[x:=s]$ 和对于公式的代换 $\\varphi[x:=s]$，意在用项 $s$ 替换 $x$ 的所有自由出现，同时保持含义并避免变量捕獲。\n\n请选择一个选项，该选项给出了 $\\mathcal{L}_{PA}$ 中代换的一个正确的、完全避免捕获的定义（包括量词情况），并正确指出了在以下展示了潜在捕获的具体场景中，朴素代换和修正后代換的结果：\n\n考虑公式 $\\varphi \\equiv \\forall y\\,\\bigl(x = y + S(0)\\bigr)$ 和项 $s \\equiv y$。为避免捕獲，何时需要重命名？在避免捕獲的代换下，$\\varphi[x:=s]$ 的正确值是什么？\n\nA. 对于项：$x[x:=s] = s$，若 $y \\neq x$ 则 $y[x:=s] = y$，$0[x:=s] = 0$，$S(t)[x:=s] = S\\bigl(t[x:=s]\\bigr)$，$(t_1 + t_2)[x:=s] = t_1[x:=s] + t_2[x:=s]$，$\\times$ 也类似。对于公式：$(t_1 = t_2)[x:=s] = \\bigl(t_1[x:=s] = t_2[x:=s]\\bigr)$；代换对 $\\neg, \\land, \\lor, \\to$ 分配。对于量词：若 $y = x$，则 $(\\forall y\\,\\psi)[x:=s] = \\forall y\\,\\psi$；若 $y \\neq x$ 且 $y \\notin FV(s)$，则 $(\\forall y\\,\\psi)[x:=s] = \\forall y\\,\\bigl(\\psi[x:=s]\\bigr)$；若 $y \\neq x$ 且 $y \\in FV(s)$，则选取一个新鲜变量 $z \\notin FV(\\psi) \\cup FV(s)$ 并设置 $(\\forall y\\,\\psi)[x:=s] = \\forall z\\,\\bigl((\\psi[y:=z])[x:=s]\\bigr)$。在场景 $\\varphi \\equiv \\forall y\\,(x = y + S(0))$ 和 $s \\equiv y$ 中，朴素代换产生 $\\forall y\\,(y = y + S(0))$，这捕获了来自 $s$ 的自由变量 $y$；避免捕獲的代换首先重命名为一个新鲜变量 $z$ 并产生 $\\forall z\\,\\bigl(y = z + S(0)\\bigr)$。\n\nB. 代换无一例外地在所有量词内部统一作用：$(\\forall y\\,\\psi)[x:=s] = \\forall y\\,\\bigl(\\psi[x:=s]\\bigr)$，无论 $y$是否等于 $x$ 或 $y \\in FV(s)$。在该场景中，$\\varphi[x:=s] = \\forall y\\,(y = y + S(0))$，且不需要重命名，因为任何变量捕获都是无害的。\n\nC. 仅当 $x \\in FV(\\psi)$ 时才需要重命名；若 $x \\notin FV(\\psi)$ 则 $(\\forall y\\,\\psi)[x:=s] = \\forall y\\,\\psi$；否则 $(\\forall y\\,\\psi)[x:=s] = \\forall y\\,\\bigl(\\psi[x:=s]\\bigr)$，且永远无需考虑 $FV(s)$。在该场景中，$\\varphi[x:=s] = \\forall y\\,(y = y + S(0))$ 且变量 $y$ 不会被捕获，因为被代换的变量是 $x$。\n\nD. 对于量词，若 $y = x$ 则 $(\\forall y\\,\\psi)[x:=s] = \\forall y\\,\\bigl(\\psi[x:=s]\\bigr)$；若 $y \\neq x$ 且 $y \\in FV(s)$ 则 $(\\forall y\\,\\psi)[x:=s] = \\forall y\\,\\bigl(\\psi[x:=s]\\bigr)$ 但 $s$ 中 $y$ 的所有出现都被一个新鲜变量 $z$ 替换。在该场景中，修正后的结果是 $\\forall z\\,\\bigl(z = y + S(0)\\bigr)$ 因为左侧应该被重命名以避免捕获。\n\n选择唯一完全正确的选项。", "solution": "该问题陈述是一阶逻辑中的一个有效练习。它要求给出避免捕获的代换的正确定义，并将其应用于一个具体示例，该示例说明了在量词情况下需要谨慎的必要性。该问题提法得当，在数理逻辑中有科学依据，并使用了精确、客观的语言。所有提供的信息都是标准的，足以确定唯一的正确答案。\n\n问题的核心是代换 $\\varphi[x:=s]$ 的定义，其非形式化含义是用项 $s$ 替换公式 $\\varphi$ 中变量 $x$ 的所有自由出现。该定义在 $\\varphi$ 的结构上是递归的。非平凡的情况是当 $\\varphi$ 是一个量化公式时，例如 $\\forall y\\,\\psi$。\n\n如果项 $s$ 中的一个自由变量在代换后被 $\\varphi$ 中的量词所约束，则称该代换导致了“变量捕获”。这会改變公式的含义，必须避免。代换的标准定义，通常称为“避免捕获的代换”，包含一个防止这种情况的机制。\n\n让我们分析代換 $(\\forall y\\,\\psi)[x:=s]$。\n\n1.  如果 $x$ 不是 $\\forall y\\,\\psi$ 中的自由变量，那么就没有 $x$ 的自由出现需要替换。如果 $x$与被量化的变量 $y$ 相同，或者如果 $x$ 在子公式 $\\psi$ 中不是自由的，就会发生这种情况。在这种情况下，代换没有效果：$(\\forall y\\,\\psi)[x:=s] = \\forall y\\,\\psi$。\n\n2.  如果 $x$ 是 $\\forall y\\,\\psi$ 中的一个自由变量（这意味着 $x \\neq y$ 且 $x \\in FV(\\psi)$），我们必须考虑项 $s$ 的自由变量。\n    a.  **安全情况**：如果被量化的变量 $y$ 没有作为自由变量出现在项 $s$ 中（即 $y \\notin FV(s)$），那么 $s$ 中的任何变量都不会被量词 $\\forall y$ “捕获”。代换可以直接进入子公式：$(\\forall y\\,\\psi)[x:=s] = \\forall y\\,(\\psi[x:=s])$。\n    b.  **捕获情况**：如果被量化的变量 $y$ *確實* 作为自由变量出现在项 $s$ 中（即 $y \\in FV(s)$），直接代换 $\\forall y\\,(\\psi[x:=s])$ 将是不正确的。$s$ 中 $y$ 的自由出现将被 $\\forall y$ 约束。为避免这种情况，我们必须首先将 $\\forall y\\,\\psi$ 中的约束变量 $y$ 重命名为一个“新鲜”变量，比如 $z$。一个新鲜变量 $z$ 是指不与任何其他变量冲突的变量，意味着 $z \\notin FV(\\forall y\\,\\psi) \\cup FV(s)$。公式 $\\forall y\\,\\psi$ 逻辑等价于 $\\forall z\\,(\\psi[y:=z])$。在这次重命名之后，我们对等价的公式执行代换：\n    $(\\forall y\\,\\psi)[x:=s] = (\\forall z\\,(\\psi[y:=z]))[x:=s]$。\n    因为 $z$ 被选为新鲜变量，所以 $z \\neq x$ 且 $z \\notin FV(s)$。对于量词 $\\forall z$，我们现在处于安全情况 (2a)。因此，代换过程如下：\n    $(\\forall y\\,\\psi)[x:=s] = \\forall z\\,\\bigl((\\psi[y:=z])[x:=s]\\bigr)$。\n\n现在，我们将此应用于给定的场景：\n-   公式：$\\varphi \\equiv \\forall y\\,\\bigl(x = y + S(0)\\bigr)$。这里，子公式为 $\\psi \\equiv (x = y + S(0))$。\n-   要替换的变量：$x$。\n-   要代换的项：$s \\equiv y$。\n\n我们想要计算 $\\varphi[x:=s] \\equiv (\\forall y\\,\\psi)[x:=y]$。\n-   要被代换的变量 $x$ 不同于被量化的变量 $y$。\n-   $x$ 是 $\\psi$ 中的一个自由变量。所以，$x \\in FV(\\varphi)$。\n-   项 $s \\equiv y$ 中的自由变量集合是 $FV(s) = \\{y\\}$。\n-   被量化的变量 $y$ 在 $FV(s)$ 中。这是捕获情况 (2b)。\n\n一个**朴素代换**会忽略捕获并错误地产生 $\\forall y\\,(\\psi[x:=y])$。\n$\\psi[x:=y] \\equiv (x = y+S(0))[x:=y] \\equiv (y = y+S(0))$。\n朴素结果是 $\\forall y\\,\\bigl(y = y + S(0)\\bigr)$。这是错误的，因为来自项 $s$ 的自由变量 $y$ 被量词 $\\forall y$ 捕获了。\n\n一个**正确的、避免捕獲的代換**必须首先重命名 $\\varphi$ 中的约束变量 $y$。\n1.  选择一个新鲜变量 $z$。为了是新鲜的，$z$ 不能在 $FV(\\varphi) \\cup FV(s) = (FV(\\psi) \\setminus \\{y\\}) \\cup FV(s)$ 中。我们有 $FV(\\psi) = \\{x, y\\}$ 和 $FV(s)=\\{y\\}$，所以 $FV(\\varphi) \\cup FV(s) = \\{x\\} \\cup \\{y\\} = \\{x, y\\}$。我们选择 $z$ 使得 $z \\neq x$ 且 $z \\neq y$。\n2.  在 $\\varphi$ 中将约束变量 $y$ 重命名为 $z$。等价的公式是 $\\varphi' \\equiv \\forall z\\,\\bigl((x = y + S(0))[y:=z]\\bigr) \\equiv \\forall z\\,\\bigl(x = z + S(0)\\bigr)$。\n3.  在 $\\varphi'$ 上执行代换 $[x:=y]$。\n    $\\varphi'[x:=y] \\equiv \\bigl(\\forall z\\,(x = z + S(0))\\bigr)[x:=y]$。\n    现在的量化变量是 $z$。被代换的项是 $s=y$。因为 $z \\notin FV(y)$，这是一个安全的代换。\n    结果是 $\\forall z\\,\\bigl((x = z + S(0))[x:=y]\\bigr)$。\n    内部代换得到 $(y = z + S(0))$。\n    最终的正确结果是 $\\forall z\\,\\bigl(y = z + S(0)\\bigr)$。\n\n现在，我们评估每个选项。\n\n**选项 A:**\n-   **定义**：该选项为代换提供了一个递归定义。对于量词，它陈述：\n    -   若 $y=x$，则 $(\\forall y\\,\\psi)[x:=s] = \\forall y\\,\\psi$。正确。\n    -   若 $y \\neq x$ 且 $y \\notin FV(s)$，则 $(\\forall y\\,\\psi)[x:=s] = \\forall y\\,\\bigl(\\psi[x:=s]\\bigr)$。正确（安全情况）。\n    -   若 $y \\neq x$ 且 $y \\in FV(s)$，选取一个新鲜变量 $z \\notin FV(\\psi) \\cup FV(s)$ 并设置 $(\\forall y\\,\\psi)[x:=s] = \\forall z\\,\\bigl((\\psi[y:=z])[x:=s]\\bigr)$。正确（捕获情况）。\n-   **场景分析**：\n    -   它正确地将朴素代换的结果识别为 $\\forall y\\,(y = y + S(0))$。\n    -   它正确地指出了失败的原因是捕获了来自 $s$ 的自由变量 $y$。\n    -   它正确地陈述了避免捕获的代换会重命名约束变量，并正确地给出了最终结果为 $\\forall z\\,\\bigl(y = z + S(0)\\bigr)$。\n-   **结论**：此选项在其定义和应用上完全正确。\n\n**选项 B:**\n-   **定义**：它提议 $(\\forall y\\,\\psi)[x:=s] = \\forall y\\,\\bigl(\\psi[x:=s]\\bigr)$ 在所有情况下都成立。这是朴素代换的定义，已知是有缺陷的。\n-   **场景分析**：它给出了朴素结果并声称变量捕获是“无害的”。这从根本上是错误的，因为捕获会改變表达式的逻辑含义。\n-   **结论**：不正确。\n\n**选项 C:**\n-   **定义**：它声称重命名从不依赖于 $FV(s)$。它陈述若 $x \\in FV(\\psi)$，则 $(\\forall y\\,\\psi)[x:=s] = \\forall y\\,\\bigl(\\psi[x:=s]\\bigr)$。这忽略了表示捕获的关键条件 $y \\in FV(s)$，因此定义是有缺陷的。\n-   **场景分析**：它提供了朴素结果并给出了一个无意义的理由：“变量 $y$ 不会被捕获，因为被代换的变量是 $x$。” 这表明对变量捕获是什么完全不理解。被捕获的变量是来自被代换的项 ($s$) 的一个自由变量，而不是被替换的变量 ($x$）。\n-   **结论**：不正确。\n\n**选项 D:**\n-   **定义**：它错误地陈述对于 $y=x$，$(\\forall y\\,\\psi)[x:=s] = \\forall y\\,\\bigl(\\psi[x:=s]\\bigr)$。如果 $y=x$，$\\psi$ 中 $x$ 的所有出现都是约束的，因此对自由出现的代换没有效果。结果应该是 $\\forall y\\,\\psi$。这个提议的规则是定义不清的。规则的第二部分建议重命名项 $s$ 中的变量，这是一种非标准（尽管可能）的方法，但描述令人困惑。\n-   **场景分析**：它给出的结果是 $\\forall z\\,\\bigl(z = y + S(0)\\bigr)$。这是不正确的。正确的结果是 $\\forall z\\,\\bigl(y = z + S(0)\\bigr)$，其中 $y$ 仍然是一个自由变量。选项 D 的结果交换了常量和变量的角色。其理由“左侧应该被重命名”也令人困惑；必须重命名的是*量词的约束变量*以避免捕获，而不是被代换的表达式的一部分。\n-   **结论**：不正确。\n\n基于此分析，只有选项 A 提供了正确的定义并正确地将其应用于该场景。", "answer": "$$\\boxed{A}$$", "id": "3041997"}, {"introduction": "掌握了表示和代入等句法工具后，我们现在可以运用它们来探索皮亚诺算术本身深刻的表达极限。这个高级练习 [@problem_id:3042047] 利用对角引理构造了一个断言自身一致性的语句，这是一种受控的自引用形式。通过哥德尔第二不完备性定理的视角分析这个语句，你将揭示一个迷人的悖论，它揭示了关于形式系统能证明和不能证明关于自身的根本真理。", "problem": "设 $\\mathsf{PA}$ 表示语言 $\\mathcal{L}=\\{0,S,+,\\times\\}$ 中的一阶皮亚诺算术。固定一个关于 $\\mathcal{L}$-公式和证明的哥德尔编码，并设 $\\mathsf{Prf}_{\\mathsf{PA}+\\sigma}(y,z)$ 为一个原始递归关系，它断言 $y$ 是从公理集 $\\mathsf{PA}\\cup\\{\\sigma\\}$ 出发，对哥德尔码为 $z$ 的公式的一个 $\\mathsf{PA}$-推导的哥德尔码。假设原始递归关系在 $\\mathsf{PA}$ 中是标准可表示的，因此存在一个 $\\Delta_{0}$-公式（有界公式）来表示 $\\mathsf{Prf}_{\\mathsf{PA}+\\sigma}(y,z)$。定义带参数码 $x$ 的一致性谓词如下\n$$\n\\mathsf{Con}_{\\mathsf{PA}}(x)\\;:\\equiv\\;\\forall y\\,\\neg \\mathsf{Prf}_{\\mathsf{PA}+\\ulcorner x\\urcorner}(y,\\ulcorner 0=1\\urcorner)\n$$\n使得 $\\mathsf{Con}_{\\mathsf{PA}}(x)$ 是一个对 $x$ 一致的 $\\Pi_{1}$-公式。回想对角线引理：对于任意带一个自由变量 $x$ 的 $\\mathcal{L}$-公式 $\\varphi(x)$，存在一个句子 $\\theta$ 使得 $\\mathsf{PA}\\vdash \\theta\\leftrightarrow \\varphi(\\ulcorner \\theta\\urcorner)$。再回想哥德尔第二不完备性定理：如果 $T$ 是一个相容的、递归可公理化的理论，它扩展了算术的一个充分片段（特别是扩展了鲁滨逊算术），那么 $T\\nvdash \\mathsf{Con}(T)$，其中 $\\mathsf{Con}(T)$ 算术化了“$T$ 是相容的”这一陈述。\n\n仅使用这些基本事实，完成以下任务。\n\n1) 将对角线引理应用于 $\\varphi(x)=\\mathsf{Con}_{\\mathsf{PA}}(x)$，构造一个句子 $\\theta$ 使得 $\\mathsf{PA}\\vdash \\theta\\leftrightarrow \\mathsf{Con}_{\\mathsf{PA}}(\\ulcorner \\theta\\urcorner)$。论证 $\\mathsf{Con}_{\\mathsf{PA}}(x)$ 的算术复杂度，并由此论证右侧 $\\mathsf{Con}_{\\mathsf{PA}}(\\ulcorner \\theta\\urcorner)$ 的算术复杂度。\n\n2) 使用哥德尔第二不完备性定理和在 $\\mathsf{PA}$ 内部的基本命题推理，证明 $\\mathsf{PA}\\vdash \\neg\\theta$ 并得出结论 $\\mathsf{PA}\\vdash \\theta\\leftrightarrow (0=1)$。\n\n3) 设 $\\Pi_{k}$ 表示 $\\mathsf{PA}$ 上算术层级的第 $k$ 层，其中 $\\Pi_{0}$ 是有界公式类。确定最小的自然数 $k$，使得存在一个 $\\Pi_{k}$-句子 $\\psi$ 满足 $\\mathsf{PA}\\vdash \\theta\\leftrightarrow \\psi$。用一个单独的整数表示你的最终答案。[@problem_id:101]", "solution": "该问题要求我们在皮亚诺算术（$\\mathsf{PA}$）的背景下，分析一个通过对角线引理构造的特定句子，并确定其算术复杂度。我们按照问题陈述中列出的三个步骤进行。\n\n1) $\\theta$ 的构造与复杂度分析。\n\n问题提供了一个带参数的一致性谓词，它是一个带一个自由变量 $x$ 的公式，定义如下：\n$$\n\\mathsf{Con}_{\\mathsf{PA}}(x)\\;:\\equiv\\; \\forall y\\,\\neg \\mathsf{Prf}_{\\mathsf{PA}+\\ulcorner x\\urcorner}(y,\\ulcorner 0=1\\urcorner)\n$$\n这里，$\\mathsf{Prf}_{\\mathsf{PA}+\\ulcorner x\\urcorner}(y,z)$ 是一个带自由变量 $x, y, z$ 的公式，它表示原始递归关系“$y$ 是从 $\\mathsf{PA}$ 的公理加上哥德尔码为 $x$ 的公理出发，对哥德尔码为 $z$ 的公式的一个证明的哥德尔码”。记号 $\\ulcorner n \\urcorner$ 表示自然数 $n$ 的数码。\n\n我们被要求将对角线引理应用于公式 $\\varphi(x) = \\mathsf{Con}_{\\mathsf{PA}}(x)$。对角线引理断言，对于任何带一个自由变量 $x$ 的公式 $\\varphi(x)$，存在一个句子 $\\theta$ 使得 $\\mathsf{PA} \\vdash \\theta \\leftrightarrow \\varphi(\\ulcorner \\theta \\urcorner)$。将此应用于我们的 $\\varphi(x)$，我们得到一个满足以下条件的句子 $\\theta$：\n$$\n\\mathsf{PA} \\vdash \\theta \\leftrightarrow \\mathsf{Con}_{\\mathsf{PA}}(\\ulcorner \\theta \\urcorner)\n$$\n其中 $\\ulcorner\\theta\\urcorner$ 是句子 $\\theta$ 的哥德尔数。\n\n接下来，我们必须论证右侧 $\\mathsf{Con}_{\\mathsf{PA}}(\\ulcorner \\theta \\urcorner)$ 的算术复杂度。问题陈述指出 $\\mathsf{Prf}_{\\mathsf{PA}+\\ulcorner x\\urcorner}(y,z)$ 可由一个 $\\Delta_{0}$ 公式表示，这意味着该公式只包含有界量词。让我们用 $P(x,y,z)$ 表示这个 $\\Delta_{0}$ 公式。根据定义，一个 $\\Delta_{0}$ 公式也是一个 $\\Pi_{0}$ 公式。一个 $\\Pi_{0}$ 公式的否定也是 $\\Pi_{0}$。因此，公式 $\\neg P(x, y, \\ulcorner 0=1 \\urcorner)$ 是一个 $\\Pi_{0}$ 公式。公式 $\\mathsf{Con}_{\\mathsf{PA}}(x)$ 是 $\\forall y \\, \\neg P(x, y, \\ulcorner 0=1 \\urcorner)$。如果一个公式形如 $\\forall y_1 \\dots \\forall y_m \\, \\psi$，其中 $\\psi$ 是一个 $\\Pi_{0}$ 公式，那么它被归类为 $\\Pi_{1}$ 公式。因此，$\\mathsf{Con}_{\\mathsf{PA}}(x)$ 是一个 $\\Pi_1$ 公式。我们等价式右侧的 $\\mathsf{Con}_{\\mathsf{PA}}(\\ulcorner \\theta \\urcorner)$ 是通过将常数项 $\\ulcorner \\theta \\urcorner$ 替换自由变量 $x$ 得到的句子。这个替换不改变量词结构。因此，$\\mathsf{Con}_{\\mathsf{PA}}(\\ulcorner \\theta \\urcorner)$ 是一个 $\\Pi_1$ 句子。\n\n2) 证明 $\\mathsf{PA} \\vdash \\neg\\theta$ 和 $\\mathsf{PA} \\vdash \\theta \\leftrightarrow (0=1)$。\n\n句子 $\\mathsf{Con}_{\\mathsf{PA}}(\\ulcorner\\theta\\urcorner)$ 是理论 $T = \\mathsf{PA} + \\theta$ 相容性的标准算术化。我们用 $\\mathsf{Con}(T)$ 来表示它。我们的对角线句子 $\\theta$ 满足 $\\mathsf{PA} \\vdash \\theta \\leftrightarrow \\mathsf{Con}(T)$。\n\n从这个等价关系，我们可以推导出 $\\mathsf{PA} \\vdash \\theta \\rightarrow \\mathsf{Con}(T)$。根据理论中可证性的定义，这意味着从公理 $\\theta$ 出发，我们可以使用 $\\mathsf{PA}$ 的公理和规则推导出 $\\mathsf{Con}(T)$。换句话说，理论 $T = \\mathsf{PA}+\\theta$ 证明了自身的相容性：\n$$\n\\mathsf{PA} + \\theta \\vdash \\mathsf{Con}(\\mathsf{PA} + \\theta)\n$$\n现在我们援引哥德尔第二不完备性定理。该定理指出，对于任何扩展了算术的一个充分片段（如鲁滨逊算术 $\\mathsf{Q}$）的相容的、递归可公理化的理论 $T'$，$T'$ 不能证明自身的相容性，即 $T' \\nvdash \\mathsf{Con}(T')$。\n\n理论 $T = \\mathsf{PA}+\\theta$ 是递归可公理化的（因为 $\\mathsf{PA}$ 是，并且我们只增加了一个公理 $\\theta$），并且它扩展了 $\\mathsf{PA}$，而 $\\mathsf{PA}$ 又扩展了 $\\mathsf{Q}$。因此，如果 $T$ 是相容的，哥德尔定理就适用，我们就会有 $T \\nvdash \\mathsf{Con}(T)$。\n然而，我们已经证明了 $T \\vdash \\mathsf{Con}(T)$。这与哥德尔定理的结论直接矛盾，唯一的解决方法是定理的前提——即 $T$ 是相容的——为假。\n\n因此，理论 $T = \\mathsf{PA}+\\theta$ 必须是不相容的。一个不相容的理论能证明任何句子，包括矛盾 $0=1$。所以，我们有：\n$$\n\\mathsf{PA} + \\theta \\vdash 0=1\n$$\n根据一阶逻辑的演绎定理，这等价于：\n$$\n\\mathsf{PA} \\vdash \\theta \\rightarrow (0=1)\n$$\n在经典逻辑中，公式 $\\theta \\rightarrow (0=1)$ 等价于 $\\neg\\theta$。因此，我们已经证明了 $\\mathsf{PA} \\vdash \\neg\\theta$。\n\n现在我们必须证明 $\\mathsf{PA} \\vdash \\theta \\leftrightarrow (0=1)$。这需要在 $\\mathsf{PA}$ 内部证明两个蕴含关系：\ni) $\\mathsf{PA} \\vdash \\theta \\rightarrow (0=1)$：这正是我们刚刚证明的。\nii) $\\mathsf{PA} \\vdash (0=1) \\rightarrow \\theta$：这是爆炸原理（*ex falso quodlibet*）的一个实例，它是逻辑学的一个基本定理，指出矛盾蕴含任何命题。这在 $\\mathsf{PA}$ 底层的逻辑演算中是可证的。\n\n因为这两个蕴含在 $\\mathsf{PA}$ 中都是可证的，所以它们的合取也是可证的。因此，我们得出结论：\n$$\n\\mathsf{PA} \\vdash \\theta \\leftrightarrow (0=1)\n$$\n\n3) 确定最小的算术复杂度。\n\n我们在寻找最小的自然数 $k$，使得存在一个 $\\Pi_k$-句子 $\\psi$，满足 $\\mathsf{PA} \\vdash \\theta \\leftrightarrow \\psi$。从上一步，我们已经确立了 $\\mathsf{PA} \\vdash \\theta \\leftrightarrow (0=1)$。这意味着我们可以选择 $\\psi$ 为句子 $0=1$。\n\n我们现在需要确定句子 $0=1$ 在算术层级中的分类。算术层级根据公式的量词结构对公式进行分类。基础层 $\\Pi_0 = \\Sigma_0 = \\Delta_0$ 由有界公式组成，这些公式的量词都是形如 $\\forall x  t$ 或 $\\exists x  t$ 的，其中 $t$ 是一个不包含 $x$ 的项。\n\n句子 $0=1$ 是一个原子公式。它是由谓词符号 $=$ 应用于项 $0$ 和 $1$（其中 $1$ 是 $S(0)$ 的缩写）构成的。原子公式完全不包含量词。根据定义，任何没有无界量词的公式都是有界公式。因此，句子 $0=1$ 是一个 $\\Delta_0$ 公式，从而属于 $\\Pi_0$ 类。\n\n我们找到了一个句子 $\\psi = (0=1)$，它在 $\\Pi_0$ 类中，并且在 $\\mathsf{PA}$ 中可证地等价于 $\\theta$。算术层级是一个类序列 $\\Pi_0, \\Pi_1, \\Pi_2, \\dots$，其中对于所有 $k \\ge 0$ 都有 $\\Pi_k \\subseteq \\Pi_{k+1}$。问题要求的是存在这样一个 $\\Pi_k$-句子的*最小*自然数 $k$。既然我们已经在 $\\Pi_0$ 中找到了一个合适的句子，并且 $k$ 必须是一个非负整数，那么 $k$ 的最小可能值就是 $0$。", "answer": "$$\\boxed{0}$$", "id": "3042047"}]}