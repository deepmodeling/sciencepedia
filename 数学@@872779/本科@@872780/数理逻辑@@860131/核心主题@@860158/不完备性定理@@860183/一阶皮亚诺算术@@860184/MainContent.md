## 引言
一阶[皮亚诺算术](@entry_id:150593)（PA）是数学逻辑的基石之一，它代表了人类用有限的公理和严格的逻辑规则来精确捕捉无限的自然数世界的伟大尝试。然而，这一尝试揭示了形式系统固有的、深刻的局限性，从而永久地改变了我们对数学确定性的理解。本文旨在系统性地探索一阶[皮亚诺算术](@entry_id:150593)的理论与实践，解决的核心问题是：一个看似简单的算术公理系统，如何能产生如此丰富的数学结构，同时又内在地包含着不可判定和不可证明的真理？

为了全面解答这一问题，我们将分三个章节展开探讨。在“原理与机制”部分，我们将从PA的[形式语言](@entry_id:265110)和公理出发，构建其句法和语义基础，并引出[哥德尔不完备性定理](@entry_id:153511)这一震撼性的结论。接着，在“应用与跨学科联系”部分，我们将展示PA如何在计算理论、[证明论](@entry_id:151111)和数论中发挥核心作用，并探讨其与[希尔伯特纲领](@entry_id:636267)的深刻关联。最后，通过一系列精心设计的“动手实践”，读者将有机会亲自运用这些抽象概念，加深对算术形式化及其边界的理解。本文将引导您穿越[形式逻辑](@entry_id:263078)的严谨世界，最终领略数学基础中最令人着迷的风景。

## 原理与机制

本章旨在深入探讨一阶[皮亚诺算术](@entry_id:150593)（First-order Peano Arithmetic, PA）的核心原理与内在机制。我们将从其严格的[形式语言](@entry_id:265110)出发，逐步构建其公理体系，并阐明这些符号与公理如何共同捕获自然数世界的基本属性。随后，我们将进入语义学的领域，探讨这些形式化语句的“意义”所在，并引入算术可定义性的关键概念。最后，本章将引导读者领略数学逻辑中最深刻的几个发现——[哥德尔不完备性定理](@entry_id:153511)与[塔尔斯基真理不可定义性定理](@entry_id:153959)，揭示任何试图完全公理化算术的尝试所固有的深刻局限性，并一瞥超越标准[算术的非标准模型](@entry_id:636869)的奇特结构。

### 形式语言与句法

任何严格的数学理论都始于一种精确定义的形式语言。[皮亚诺算术](@entry_id:150593)的语言，记作 $\mathcal{L}_{PA}$，为我们提供了一套构建关于自然数陈述的符号工具箱。

#### 算术语言 $\mathcal{L}_{PA}$

$\mathcal{L}_{PA}$ 的符号系统由逻辑符号和非逻辑符号组成。逻辑符号是所有一阶逻辑理论共有的，包括变量（如 $x, y, z$）、[逻辑联结词](@entry_id:146395)（$\neg, \land, \lor, \rightarrow$）、[量词](@entry_id:159143)（$\forall, \exists$）以及一个特殊的逻辑关系符号——等号“$=$”。等号的意义在所有模型中都被固定为恒等关系。

$\mathcal{L}_{PA}$ 的独特性体现在其非逻辑符号上，这些符号旨在捕捉算术的基本结构 [@problem_id:3041998]。它们可以分为以下几类：

*   **常数符号 (Constant Symbol)**：只有一个，$0$。它用于指代算术[论域](@entry_id:265834)中的一个特定元素，即数字零。可以将其视为一个不带任何参数（元数为0）的函数。

*   **函数符号 (Function Symbols)**：共有三个。
    *   $S$：一个一元（元数为1）函数符号，代表**后继**函数（$n \mapsto n+1$）。
    *   $+$：一个二元（元数为2）函数符号，代表**加法**运算。
    *   $\times$：一个二元（元数为2）函数符号，代表**乘法**运算。

值得注意的是，$\mathcal{L}_{PA}$ 的标准版本不包含任何非逻辑的**关系符号**（或称谓词符号）。唯一的原子关系就是由逻辑符号“$=$”所构成的等式。

#### 构造项与公式

有了符号，我们便可以根据严格的递归规则来构建有意义的表达式 [@problem_id:3042053]。这些表达式分为两类：**项 (terms)** 和 **公式 (formulas)**。

**项** 在语言中代表[论域](@entry_id:265834)中的对象，也就是数字。$\mathcal{L}_{PA}$ 的项集合由以下规则归纳定义：
1.  **基本项**:
    *   任何变量（如 $x$）都是一个项。
    *   常数符号 $0$ 是一个项。
2.  **[归纳步骤](@entry_id:144594)**:
    *   如果 $t$ 是一个项，那么 $S(t)$ 也是一个项。
    *   如果 $t_1$ 和 $t_2$ 是项，那么 $(t_1 + t_2)$ 和 $(t_1 \times t_2)$ 也是项。（为清晰起见，括号通常可以省略）。

例如，$S(0)$ 是一个项（代表数字1），$(S(0) + S(S(0)))$ 是一个项（代表 $1+2$），而 $(x \times (y + S(0)))$ 也是一个项。

**公式** 在语言中代表陈述或命题，它们可以被赋予[真值](@entry_id:636547)（真或假）。$\mathcal{L}_{PA}$ 的公式集合由以下规则归纳定义：
1.  **原子公式 (Atomic Formulas)**:
    *   如果 $t_1$ 和 $t_2$ 是项，那么 $(t_1 = t_2)$ 是一个公式。这是 $\mathcal{L}_{PA}$ 中最基本的公式类型。
2.  **[归纳步骤](@entry_id:144594)**:
    *   如果 $\varphi$ 是一个公式，那么 $\neg\varphi$ 也是一个公式。
    *   如果 $\varphi$ 和 $\psi$ 是公式，那么 $(\varphi \land \psi)$、$(\varphi \lor \psi)$ 和 $(\varphi \rightarrow \psi)$ 也是公式。
    *   如果 $\varphi$ 是一个公式且 $x$ 是一个变量，那么 $\forall x\,\varphi$ 和 $\exists x\,\varphi$ 也是公式。

例如，$\forall x \, \neg(S(x) = 0)$ 是一个公式，它断言“不存在一个数，其后继是0”。另一个更复杂的例子是 $\exists y \, (x = y \times S(S(0)))$，它断言“$x$ 是一个偶数”。

### 公理系统：[皮亚诺算术](@entry_id:150593)

定义了语言之后，我们需要一套公理——一组我们预先假定为真的初始公式——来约束符号的解释，使其符合我们对自然数的直观理解。[皮亚诺算术](@entry_id:150593)的公理系统（PA）正是为此而设。它由两组基本算术公理和一个强大的归纳公理模式组成。

#### 基本算术公理

这些基本算术公理是鲁滨逊算术（Robinson Arithmetic, Q）的核心。Q是一个比PA弱得多的系统，但已足以表达所有[可计算函数](@entry_id:152169)。

首先是关于 $0$ 和后继函数 $S$ 的公理，它们奠定了自然数序列的基础结构 [@problem_id:3042020]：
1.  $\forall x \, \neg(S(x) = 0)$
    *   **语义**: 0 不是任何自然数的后继。这确立了 $0$ 作为自然数序列的起点。
2.  $\forall x \forall y \, (S(x) = S(y) \rightarrow x = y)$
    *   **语义**: 后继函数是单射的。如果两个数的后继相同，那么这两个数也必然相同。这保证了数序的唯一性，不会出现“[分叉](@entry_id:270606)后又合并”的情况。

接下来是定义加法（$+$）和乘法（$\times$）的递归公理。这些公理展示了如何从最基本的后继运算中构建出更复杂的算术运算 [@problem_id:3042042]：
3.  $\forall x \, (x + 0 = x)$
    *   **语义**: 任何数加0等于其自身（加法的基本情形）。
4.  $\forall x \forall y \, (x + S(y) = S(x + y))$
    *   **语义**: $x$ 加上 $y$ 的后继，等于 $x$ 与 $y$ 之和的后继。这本质上将加法定义为迭代的后继运算。例如，$x+2$ 就是 $S(S(x))$。
5.  $\forall x \, (x \times 0 = 0)$
    *   **语义**: 任何[数乘](@entry_id:155971)以0等于0（乘法的基本情形）。
6.  $\forall x \forall y \, (x \times S(y) = (x \times y) + x)$
    *   **语义**: $x$ 乘以 $y$ 的后继，等于 $x$ 乘以 $y$ 的结果再加上 $x$。这本质上将乘法定义为迭代的加法运算。

重要的是，诸如加法[交换律](@entry_id:141214)（$\forall x \forall y \, (x+y = y+x)$）或结合律等熟悉的算术性质，在PA中并不是公理。它们是可以通过下面介绍的归纳公理模式被**证明**的定理。这些递归公理仅仅提供了定义，而归纳公理则赋予了PA从这些定义中推导出通用性质的强大能力。

#### 归纳公理模式

PA系统中最强大的部分是归纳公理模式（Axiom Schema of Induction）。它并非单个公理，而是一个产生无穷多个公理的“模板” [@problem_id:3041973]。

**归纳公理模式**: 对于 $\mathcal{L}_{PA}$ 中的**任何**带有一个或多个自由变量（比如 $x$）的公式 $\varphi(x, y_1, \dots, y_k)$，以下公式都是PA的一条公理：
$$ \forall y_1 \dots \forall y_k \, \Big( \big( \varphi(0, \vec{y}) \land \forall x (\varphi(x, \vec{y}) \rightarrow \varphi(S(x), \vec{y})) \big) \rightarrow \forall x \, \varphi(x, \vec{y}) \Big) $$
（为简洁起见，我们常省略额外的参数 $\vec{y}$）。

这条公理模式的本质是：如果我们能证明某个性质 $\varphi$ 对 $0$ 成立（**基本情形**），并且能证明如果它对任意数 $x$ 成立，那么它也必然对 $x$ 的后继 $S(x)$ 成立（**[归纳步骤](@entry_id:144594)**），那么我们就可以断定该性质 $\varphi$ 对**所有**自然数都成立。

之所以这是一个“模式”而非单个公理，是因为[一阶逻辑](@entry_id:154340)的限制。在一阶逻辑中，我们只能对个体变量（[论域](@entry_id:265834)中的元素，即数）进行量化，而不能对“性质”或“公式”本身进行量化。我们无法写出一个形如“对于所有性质P...”的单一公理。因此，我们只能为语言中可表达的每一个性质（即每一个公式 $\varphi$）都单独提供一个归纳公理。由于 $\mathcal{L}_{PA}$ 中存在无穷多个不同的公式，PA的归纳公理也便有了无穷多条。正是这个强大的机制，使得PA能够证明关于自然数的绝大多数标准数学定理。

### 语义与模型

我们已经建立了PA的形式体系（句法），现在转向其意义（语义）。一个形式理论的语义研究的是如何解释其语言中的符号和公式。

#### 解释语言：结构与模型

为了解释 $\mathcal{L}_{PA}$，我们需要一个所谓的 **$\mathcal{L}_{PA}$-结构**（或称解释）。一个结构 $\mathcal{M}$ 由以下部分组成：
*   一个非[空集](@entry_id:261946)合，称为**[论域](@entry_id:265834) (domain)**，记作 $M$。
*   对语言中每个非逻辑符号的**解释**:
    *   对常数符号 $0$ 的解释 $0^{\mathcal{M}}$，是 $M$ 中的一个特定元素。
    *   对函数符号 $S, +, \times$ 的解释 $S^{\mathcal{M}}, +^{\mathcal{M}}, \times^{\mathcal{M}}$，它们分别是 $M$ 上的一个一元函数和两个二元函数。

如果一个结构 $\mathcal{M}$ 使得PA的所有公理在其中都为真，那么我们称 $\mathcal{M}$ 是PA的一个**模型 (model)**。

最自然、最符合直觉的P[A模型](@entry_id:158323)是**标准模型**，记作 $\mathbb{N}$。其[论域](@entry_id:265834)是自然数集 $\{0, 1, 2, \dots\}$，$0^{\mathbb{N}}$ 就是数字0，$S^{\mathbb{N}}$ 是后继函数 $n \mapsto n+1$，$+^{\mathbb{N}}$ 和 $\times^{\mathbb{N}}$ 是标准的加法和乘法运算。

#### 项与公式的意义

在一个给定的结构 $\mathcal{M}$ 中，一个项的“值”或一个公式的“[真值](@entry_id:636547)”是如何确定的呢？这需要借助一个**变量赋值 (variable assignment)** 函数 $s$，它将每个变量映射到[论域](@entry_id:265834) $M$ 中的一个元素。

一个项 $t$ 在结构 $\mathcal{M}$ 中关于赋值 $s$ 的值，记作 $t^{\mathcal{M}}[s]$，是按项的[结构递归](@entry_id:636642)定义的 [@problem_id:3041975]：
1.  如果 $t$ 是一个变量 $x$，则 $x^{\mathcal{M}}[s] = s(x)$。
2.  如果 $t$ 是常数符号 $0$，则 $0^{\mathcal{M}}[s] = 0^{\mathcal{M}}$。
3.  如果 $t$ 是复合项，例如 $S(t_1)$，则 $(S(t_1))^{\mathcal{M}}[s] = S^{\mathcal{M}}(t_1^{\mathcal{M}}[s])$。
4.  如果 $t$ 是复合项，例如 $(t_1 + t_2)$，则 $(t_1 + t_2)^{\mathcal{M}}[s] = +^{\mathcal{M}}(t_1^{\mathcal{M}}[s], t_2^{\mathcal{M}}[s])$。乘法同理。

这个定义清晰地区分了句法符号（如 $S, +$）和它们的语义解释（$S^{\mathcal{M}}, +^{\mathcal{M}}$）。项的值是通过先计算其子项的值，然后将结构中对应的函数应用于这些值来得到的。

类似地，一个公式 $\varphi$ 在结构 $\mathcal{M}$ 中关于赋值 $s$ 是否为真（记作 $\mathcal{M} \models \varphi[s]$，读作“$\mathcal{M}$ 在 $s$ 下满足 $\varphi$”）也是[递归定义](@entry_id:266613)的。例如，$\mathcal{M} \models (t_1 = t_2)[s]$ 当且仅当 $t_1^{\mathcal{M}}[s]$ 和 $t_2^{\mathcal{M}}[s]$ 是[论域](@entry_id:265834) $M$ 中的同一个元素。

#### 算术中的可定义性

可定义性是连接句法和语义的关键桥梁。标准模型 $\mathbb{N}$ 中的一个集合或关系，如果能被 $\mathcal{L}_{PA}$ 的一个公式所“描述”，我们就称它是**算术可定义的 (arithmetically definable)** [@problem_id:3042006]。

*   一个[子集](@entry_id:261956) $A \subseteq \mathbb{N}^k$ 是可定义的，如果存在一个含有 $k$ 个自由变量 $x_1, \dots, x_k$ 的 $\mathcal{L}_{PA}$-公式 $\varphi(x_1, \dots, x_k)$，使得对于所有自然数元组 $(n_1, \dots, n_k) \in \mathbb{N}^k$：
    $$ (n_1, \dots, n_k) \in A \quad \iff \quad \mathbb{N} \models \varphi(n_1, \dots, n_k) $$

事实证明，算术语言的[表达能力](@entry_id:149863)异常强大。许多重要的数论性质都是可定义的。
*   **素数集合**: 存在一个公式 $\varphi_{\text{prime}}(x)$，当且仅当 $x$ 是一个素数时，$\mathbb{N} \models \varphi_{\text{prime}}(x)$ 为真。这个公式可以表达为 “$x \gt 1$ 且 $x$ 的任何因子都不是 $1$ 或 $x$ 自身” [@problem_id:3042006]。
*   **指数关系**: 尽管 $\mathcal{L}_{PA}$ 没有指数符号，但关系 $z = x^y$ 是可定义的。这意味着存在一个公式 $\varphi_{\text{exp}}(x, y, z)$，它在 $\mathbb{N}$ 中精确地定义了指数运算 [@problem_id:3042006]。这要归功于哥德尔发现的利用中国剩余定理编码有限序列的技巧（如[哥德尔](@entry_id:637876) $\beta$-函数）。

为了更精细地研究[可定义集](@entry_id:154752)的复杂性，逻辑学家引入了**算术阶层 (Arithmetical Hierarchy)** [@problem_id:3041977]。它根据定义公式的量词结构对公式和集合进行分类。最低的几层是：
*   **$\Delta_0$ (或 $\Sigma_0, \Pi_0$)**: 由仅含**有界[量词](@entry_id:159143)**的公式组成的类。有界量词形如 $\forall x \lt t$ (等价于 $\forall x (x \lt t \rightarrow \dots)$) 或 $\exists x \lt t$ (等价于 $\exists x (x \lt t \land \dots)$)，其中 $t$ 是一个不含 $x$ 的项。这类公式的真伪可以在有限步骤内判定。例如，$\forall k \lt x \, \neg(k \times k = x)$ 是一个 $\Delta_0$ 公式。
*   **$\Sigma_1$**: 由形如 $\exists x_1 \dots \exists x_n \, \varphi$ 的公式组成的类，其中 $\varphi$ 是 $\Delta_0$ 公式。这类公式断言某个有界性质对某些（无界的）数成立。一个集合是 $\Sigma_1$ 的，意味着我们可以通过搜索来验证其成员身份：一旦找到满足条件的“见证” $x_i$，搜索就停止。
*   **$\Pi_1$**: 由形如 $\forall x_1 \dots \forall x_n \, \varphi$ 的公式组成的类，其中 $\varphi$ 是 $\Delta_0$ 公式。这类公式断言某个有界性质对所有数都成立。要[证伪](@entry_id:260896)一个 $\Pi_1$ 陈述，只需找到一个反例。

这个阶层在[可计算性理论](@entry_id:149179)和不[完备性定理](@entry_id:151598)中扮演着至关重要的角色。例如，所有**可计算的**（或称递归的）关系都是 $\Delta_1$ 可定义的（即同时等价于一个 $\Sigma_1$ 公式和一个 $\Pi_1$ 公式），而所有**可计算枚举的**关系（如[图灵机](@entry_id:153260)的[停机问题](@entry_id:265241)）都是 $\Sigma_1$ 可定义的。

### 算术的局限性：不完备性与不可定义性

PA系统非常强大，足以形式化经典数论的绝大部分内容。然而，20世纪30年代，[库尔特·哥德尔](@entry_id:148316)的革命性工作揭示了任何此类形式系统都存在着深刻的、不可避免的局限。

#### [哥德尔第一不完备性定理](@entry_id:635197)

**[哥德尔第一不完备性定理](@entry_id:635197)**对PA的陈述是：如果PA是相容的（即不能从中证明出矛盾，如 $0=1$），那么PA就是不完备的。

**不完备**意味着，存在一个 $\mathcal{L}_{PA}$-语句 $G$，使得PA既不能证明 $G$（$PA \nvdash G$），也不能证明其否定 $\neg G$（$PA \nvdash \neg G$）。这样的语句 $G$ 对于PA来说是**不可判定的 (undecidable)**。

这个定理的证明思路是现代逻辑的基石之一 [@problem_id:3041986]。它大致分为三步：
1.  **算术化 (Arithmetization)**：[哥德尔](@entry_id:637876)发明了一种精巧的编码方案，将 $\mathcal{L}_{PA}$ 的每个符号、项、公式和证明（即公式序列）都用一个唯一的自然数来表示，这个数被称为**[哥德尔](@entry_id:637876)数**。这使得关于[元数学](@entry_id:155387)（关于数学的数学）的陈述，如“公式 $\varphi$ 在PA中是可证的”，可以被翻译成关于自然数的算术陈述。

2.  **[可表示性](@entry_id:635277) (Representability)**：PA足够强大，可以**表示**所有可计算的函数和关系。特别是，[元数学](@entry_id:155387)关系“$p$ 是对公式 $f$ 的一个PA证明的[哥德尔](@entry_id:637876)数”，这个关系是可计算的，因此可以在PA内部被一个公式 $\mathrm{Prf}_{PA}(p, f)$ 所表示。基于此，我们可以定义一个**可证性谓词** $\mathrm{Prov}_{PA}(f) \equiv \exists p \, \mathrm{Prf}_{PA}(p, f)$，它在PA内部表达了“公式 $f$ 是可证的”这一概念。

3.  **对角化与[不动点引理](@entry_id:151038) (Diagonalization and Fixed-Point Lemma)**：对角化引理（或称[不动点引理](@entry_id:151038)）是一个强大的工具，它表明对于任何只有一个自由变量的公式 $\psi(x)$，都存在一个语句 $G$，使得PA可以证明 $G \leftrightarrow \psi(\ulcorner G \urcorner)$，其中 $\ulcorner G \urcorner$ 是语句 $G$ 的哥德尔数。这个引理使得构造“自指”语句成为可能。

[哥德尔](@entry_id:637876)将[不动点引理](@entry_id:151038)应用于**否定**的可证性谓词 $\neg \mathrm{Prov}_{PA}(x)$。这便构造出了一个**[哥德尔](@entry_id:637876)语句** $G$，满足：
$$ PA \vdash G \leftrightarrow \neg \mathrm{Prov}_{PA}(\ulcorner G \urcorner) $$
这个语句 $G$ 的直观意义是“我自身是不可证明的”。

通过简单的逻辑推理可以发现，如果PA是相容的，那么 $G$ 和 $\neg G$ 都不可能在PA中被证明。$G$ 就是PA中那个不可判定的语句。更进一步，因为PA不能证明 $G$，所以 $G$ 所断言的“我是不可证的”这句话实际上是真的（在标准模型 $\mathbb{N}$ 中）。因此，[哥德尔](@entry_id:637876)定理不仅找到了一个不可判定的语句，还找到了一个**为真但不可证**的语句。

#### [塔尔斯基真理不可定义性定理](@entry_id:153959)

[哥德尔](@entry_id:637876)的结果引发了一个深刻的问题：既然“可证性”可以在PA中定义，那么“真理性”呢？是否存在一个公式 $\mathsf{True}(x)$，使得对于任何语句 $\varphi$，当且仅当 $\varphi$ 在标准模型 $\mathbb{N}$ 中为真时，$\mathsf{True}(\ulcorner \varphi \urcorner)$ 也在 $\mathbb{N}$ 中为真？

**阿尔弗雷德·塔尔斯基**证明了这是不可能的。**[塔尔斯基真理不可定义性定理](@entry_id:153959)**指出：算术真理的集合在算术语言自身中是不可定义的 [@problem_id:3042035]。

其证明与哥德尔的证明异曲同工，也依赖于[对角化](@entry_id:147016)引理。假设存在这样一个真理谓词 $\mathsf{True}(x)$。我们可以应用[对角化](@entry_id:147016)引理于它的**否定** $\neg \mathsf{True}(x)$，从而构造一个“说谎者语句” $L$，它满足：
$$ \mathbb{N} \models L \leftrightarrow \neg \mathsf{True}(\ulcorner L \urcorner) $$
这个语句 $L$ 的直观意义是“我自身是假的”。现在我们来分析 $L$ 的[真值](@entry_id:636547)：
*   如果 $L$ 为真，那么根据 $\mathsf{True}$ 的定义，$\mathsf{True}(\ulcorner L \urcorner)$ 也必须为真。但根据 $L$ 的构造，$L$ 为真意味着 $\neg \mathsf{True}(\ulcorner L \urcorner)$ 为真。矛盾。
*   如果 $L$ 为假，那么根据 $\mathsf{True}$ 的定义，$\mathsf{True}(\ulcorner L \urcite)$ 必须为假，即 $\neg \mathsf{True}(\ulcorner L \urcite)$ 为真。但根据 $L$ 的构造，$\neg \mathsf{True}(\ulcorner L \urcite)$ 为真意味着 $L$ 为真。再次矛盾。

由于假设存在 $\mathsf{True}(x)$ 会导出逻辑矛盾，因此这样的公式必定不存在。

这个定理揭示了句法（可证性）和语义（真理性）之间的一道鸿沟。可证性是一个句法概念，可以被算术化和定义。而真理性是一个语义概念，它超越了算术语言自身的表达能力。[哥德尔第一不完备性定理](@entry_id:635197)正是这道鸿沟的直接体现：可证集（所有PA定理的[哥德尔](@entry_id:637876)数集合）是一个被严格包含于真理集（所有[真算术](@entry_id:148014)语句的[哥德尔](@entry_id:637876)数集合）的[子集](@entry_id:261956)。

#### [哥德尔第二不完备性定理](@entry_id:149390)

哥德尔的第一个定理已经足够震撼，而第二个定理则更进一步，直接触及了数学确定性的基础。

**[哥德尔第二不完备性定理](@entry_id:149390)**指出：如果PA是相容的，那么PA无法证明其自身的相容性。

我们可以将PA的相容性形式化为一个 $\mathcal{L}_{PA}$ 语句，记作 $\mathsf{Con}(PA)$。这个语句通常表达为“不存在对矛盾（如 $0=1$）的证明”，即 $\neg \mathrm{Prov}_{PA}(\ulcorner 0=1 \urcorner)$。第二不[完备性定理](@entry_id:151598)断言：
$$ \text{若 PA 相容, 则 } PA \nvdash \mathsf{Con}(PA) $$

这个定理的证明本质上是将**第一不[完备性定理](@entry_id:151598)的证明过程在PA内部形式化** [@problem_id:3041988]。我们之前看到，[元数学](@entry_id:155387)论证“若P[A相](@entry_id:195484)容，则 $G$ 不可证”可以得出 $G$ 为真。哥德尔表明，这个论证本身（的大部分）是足够初等的，可以在PA内部进行形式推导。

为了使这种形式化成为可能，可证性谓词 $\mathrm{Prov}_{PA}(x)$ 必须满足某些良好的性质，即**希尔伯特-伯奈斯可证性条件 (Hilbert-Bernays derivability conditions)**。这些条件确保了 $\mathrm{Prov}_{PA}(x)$ 在PA内部的行为方式与我们直观上的“可证性”概念足够相似（例如，如果PA能证 $\varphi$ 和 $\varphi \rightarrow \psi$，它也能证 $\psi$）。

在满足这些条件的前提下，可以证明以下关键蕴含关系：
$$ PA \vdash \mathsf{Con}(PA) \rightarrow G $$
这个公式的直观意义是：“PA内部可以证明，如果PA是相容的，那么[哥德尔](@entry_id:637876)语句G成立”。

现在，第二定理的结论就呼之欲出了。假如PA能够证明自己的相容性，即 $PA \vdash \mathsf{Con}(PA)$。那么根据上述已证的蕴含关系，通过形式化的分离规则（Modus Ponens），我们就能得到 $PA \vdash G$。但这与第一不[完备性定理](@entry_id:151598)的结论（如果P[A相](@entry_id:195484)容，则 $PA \nvdash G$）相矛盾。因此，最初的假设“PA能证明自己的相容性”必定是错误的。

### 超越标准：[非标准模型](@entry_id:151939)

PA的公理系统虽然精确，但它并不足以将模型的范围限定在我们所熟知的自然数 $\mathbb{N}$ 上。由[紧致性定理](@entry_id:148512)可知，PA存在**[非标准模型](@entry_id:151939)**。这些模型满足PA的全部公理（包括所有归纳公理），但其结构却与 $\mathbb{N}$ 大相径庭。

一个可数的[非标准模型](@entry_id:151939) $M$ 的序结构极为奇特 [@problem_id:3042006]。
1.  **初始标准部分**: $M$ 包含一个与 $\mathbb{N}$ 同构的初始部分，即 $\{0, S(0), S^2(0), \dots\}$。这部分的序类型是 $\omega$。
2.  **非标准部分**: $M$ 中还存在“无穷大”的非标准数，它们比任何标准数都大。
3.  **$\mathbb{Z}$-链**: 由于PA的公理保证了每个非零数都有唯一的前驱，任何一个非标准数 $c$ 都位于一个形如 $\{\dots, c-2, c-1, c, c+1, c+2, \dots\}$ 的双向无穷链中。这个链的序类型是 $\mathbb{Z}$。整个非标准部分是由无数这样的 $\mathbb{Z}$-链构成的。
4.  **链间的稠密序**: 这些 $\mathbb{Z}$-链本身是如何[排列](@entry_id:136432)的呢？可以证明，它们之间的[序关系](@entry_id:138937)是**稠密的**。即，在任意两个不同的 $\mathbb{Z}$-链之间，总能找到第三个 $\mathbb{Z}$-链。例如，对于一个非标准数 $c$，$\lfloor c/2 \rfloor$ 也是一个非标准数，并且它所在的链位于 $0$ 所在的链和 $c$ 所在的链之间。

综合来看，一个可数非标准P[A模型](@entry_id:158323)的序类型是 $\omega + (\mathbb{Z} \cdot \eta)$。这里，$\omega$ 代表初始的标准自然数部分，$\mathbb{Z}$ 代表每个非标准链的局部离散结构，而 $\eta$（有理数 $\mathbb{Q}$ 的序类型）代表了这些 $\mathbb{Z}$-链之间的全局稠密[排列](@entry_id:136432)。这表明，尽管PA的公理系统试图精确刻画自然数，但它仍然允许存在包含“无穷大”且结构极其丰富的奇异算术世界。