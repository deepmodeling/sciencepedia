{"hands_on_practices": [{"introduction": "要证明一个新问题是不可解的，最强大的技术之一就是“归约”（reduction）。这个练习展示了归约的基本逻辑：如果我们能证明，利用一个解决新问题 $P$ 的假设性“神谕”（oracle），就能解决一个已知的不可解问题（例如停机问题），那么新问题 $P$ 必然也是不可解的。这个练习 [@problem_id:1468148] 让你通过一个经典场景，掌握这一核心的证明策略。", "problem": "在可计算性理论中，如果一个问题 $A$ 的算法可以通过假设存在一个能够一步解决问题 $B$ 的任何实例的假设性子程序（称为谕示机）来构造，那么我们称问题 $A$ 图灵可归约于问题 $B$，记作 $A \\le_T B$。这意味着如果我们有办法解决 $B$，我们也能解决 $A$。\n\n该理论的一个基石是图灵机（TM）的停机问题，我们记作 $H_{TM}$。这是一个判定问题：根据任意一台图灵机的描述和输入，判断该图灵机最终是会停机还是会永远运行下去。一个基础性的结论是，$H_{TM}$ 是一个不可判定问题；不存在能够解决所有停机问题实例的算法。\n\n假设一位计算机科学家正在研究一个与数据库查询优化相关的新的、深奥的问题，我们称之为问题 $P$。经过重大突破后，他们成功证明了停机问题图灵可归约于问题 $P$。也就是说，他们已正式证明了 $H_{TM} \\le_T P$。\n\n仅基于这个已证明的归约，关于问题 $P$ 的可判定性，可以得出的最精确的结论是什么？\n\nA. 问题 $P$ 是可判定的。\nB. 问题 $P$ 是不可判定的。\nC. 问题 $P$ 的可判定性无法确定；它既可能是可判定的，也可能是不可判定的。\nD. 这种情况是不可能的，因为不可判定的停机问题不能图灵可归约于任何其他问题。", "solution": "根据定义，$A \\le_T B$ 意味着存在一个谕示图灵机，在给定问题 $B$ 的谕示机时，它能判定问题 $A$。形式上，给定 $H_{TM} \\le_T P$，存在一个谕示图灵机 $M^{P}$，使得在能够访问问题 $P$ 的谕示机的情况下，$M^{P}$ 能判定 $H_{TM}$。\n\n为了进行反证，我们假设 $P$ 是可判定的。那么，存在一个标准的（非谕示）图灵机 $D_{P}$ 来判定 $P$，即 $D_{P}$ 对所有输入都会停机，并正确回答关于 $P$ 的成员资格问题。\n\n我们可以构造一个标准图灵机 $N$ 来判定 $H_{TM}$。它通过模拟 $M^{P}$ 实现，并且每当 $M^{P}$ 需要向 $P$ 进行谕示查询时，$N$ 就转而对该查询运行 $D_{P}$，并使用其结果来代替谕示机的回答。因为 $D_{P}$ 对所有输入都会停机，所以每次模拟的谕示查询都会在有限时间内返回。因此，$N$ 能够判定 $H_{TM}$。\n\n这就得出了如下蕴含关系：\n$$\nH_{TM} \\le_T P \\land \\text{$P$ decidable} \\implies \\text{$H_{TM}$ decidable}.\n$$\n然而，众所周知，$H_{TM}$ 是不可判定的，这与结论相矛盾。因此，关于 $P$ 是可判定的假设必定是错误的，所以 $P$ 是不可判定的。\n\n因此，最精确的结论是 $P$ 是不可判定的。这种情况并非不可能：许多问题都可以让 $H_{TM}$ 图灵可归约于它们。", "answer": "$$\\boxed{B}$$", "id": "1468148"}, {"introduction": "在使用归约法时，其方向至关重要，一个错误的方向会导致完全无效的结论。这个练习 [@problem_id:1457073] 呈现了一个计算理论学生常犯的典型错误。通过分析为什么她的证明是错误的，你可以深刻理解正确运用归约来证明不可判定性的逻辑严谨性，即必须将一个已知的不可判定问题归约到你想要证明其不可判定的新问题上。", "problem": "一名正在修计算理论课程的学生 Alice，被要求证明一个特定的语言 $\\mathrm{TOTAL}_{\\mathrm{TM}}$ 是不可判定的。该语言定义为 $\\mathrm{TOTAL}_{\\mathrm{TM}}$ = $\\{ \\langle M \\rangle \\mid M \\text{ 是一台在所有可能的输入串上都会停机的图灵机 (TM)} \\}$。\n\nAlice 知道标准的停机问题，$A_{TM} = \\{ \\langle M, w \\rangle \\mid M \\text{ 是一台在输入 } w \\text{ 上会停机的图灵机} \\}$，是一个著名的不可判定语言。\n\n为了证明她的论断，她正确地构造了一个可计算函数 $f$，该函数将 $\\mathrm{TOTAL}_{\\mathrm{TM}}$ 的任意实例 $\\langle M \\rangle$ 转换为 $A_{TM}$ 的一个实例 $\\langle M', w' \\rangle = f(\\langle M \\rangle)$，使得 $\\langle M \\rangle \\in \\mathrm{TOTAL}_{\\mathrm{TM}}$ 当且仅当 $\\langle M', w' \\rangle \\in A_{TM}$。这建立了一个从 $\\mathrm{TOTAL}_{\\mathrm{TM}}$ 到 $A_{TM}$ 的映射归约（记为 $\\mathrm{TOTAL}_{\\mathrm{TM}} \\le_m A_{TM}$）。\n\nAlice 随后总结了她的证明：“既然我已经证明了 $\\mathrm{TOTAL}_{\\mathrm{TM}}$ 可归约到 $A_{TM}$，并且我们知道 $A_{TM}$ 是不可判定的，那么从逻辑上可以得出 $\\mathrm{TOTAL}_{\\mathrm{TM}}$ 也必定是不可判定的。”\n\n下列哪个陈述最好地解释了 Alice 推理中的根本性缺陷？\n\nA. 为了通过归约证明语言 $P$ 是不可判定的，必须将一个已知的不可判定语言 $U$ 归约*到* $P$（即证明 $U \\le_m P$），而不是反过来。对于她所陈述的目的而言，Alice 的归约方向是错误的。\nB. 语言 $\\mathrm{TOTAL}_{\\mathrm{TM}}$ 不是图灵可识别的，而 $A_{TM}$ 是。映射归约只在处于相同可识别性类别的语言之间有效（即，要么都是可识别的，要么都不是）。\nC. Alice 的论证是循环论证。为了构造可计算函数 $f$，她必须隐含地假设了一种判定 $\\mathrm{TOTAL}_{\\mathrm{TM}}$ 的方法，这与她试图证明的论断相矛盾。\nD. 该归约是无效的，因为已知 $\\mathrm{TOTAL}_{\\mathrm{TM}}$ 是一个比 $A_{TM}$“更难”的问题。可计算性理论的一个基本定理是，不能将一个计算上更难的问题归约到一个更容易的问题。\nE. 任何从一个接受单个编码 $\\langle M \\rangle$ 作为输入的语言到一个接受一对 $\\langle M, w \\rangle$ 作为输入的语言的归约，都存在固有缺陷，因为它需要制造原始输入中不存在的信息（字符串 $w$）。", "solution": "我们已知语言 $\\mathrm{TOTAL}_{\\mathrm{TM}} = \\{ \\langle M \\rangle \\mid M \\text{ 在所有输入上都会停机} \\}$ 和停机问题 $A_{TM} = \\{ \\langle M, w \\rangle \\mid M \\text{ 在输入 } w \\text{ 上停机} \\}$，其中 $A_{TM}$ 是已知的不可判定问题。Alice 展示了一个映射归约 $\\mathrm{TOTAL}_{\\mathrm{TM}} \\le_{m} A_{TM}$ 并得出结论说 $\\mathrm{TOTAL}_{\\mathrm{TM}}$ 是不可判定的。\n\n回顾定义：对于语言 $A$ 和 $B$，$A \\le_{m} B$ 意味着存在一个全可计算函数 $f$，使得对于所有字符串 $x$，\n$$x \\in A \\iff f(x) \\in B.$$\n\n映射归约的关键性质：\n- 如果 $A \\le_{m} B$ 且 $B$ 是可判定的，那么 $A$ 也是可判定的。证明：给定一个 $B$ 的判定器，通过计算 $f(x)$ 并运行 $B$ 的判定器来判定输入 $x$ 上的 $A$；当且仅当 $B$ 的判定器接受时，我们也接受。\n- 该陈述的逆否命题是：如果 $A$ 是不可判定的且 $A \\le_{m} B$，那么 $B$ 也是不可判定的。\n\n因此，为了通过归约证明目标语言 $P$ 是不可判定的，必须将一个已知的不可判定语言 $U$ 归约到 $P$，也就是说，证明 $U \\le_{m} P$。这样，如果 $P$ 是可判定的，那么 $U$ 也将是可判定的，这与 $U$ 的已知不可判定性相矛盾。\n\n然而 Alice 证明的是 $\\mathrm{TOTAL}_{\\mathrm{TM}} \\le_{m} A_{TM}$。根据上述基本性质，这个蕴含关系只能得出：\n$$\\text{如果 } A_{TM} \\text{ 是可判定的，那么 } \\mathrm{TOTAL}_{\\mathrm{TM}} \\text{ 也将是可判定的。}$$\n但由于 $A_{TM}$ 是不可判定的，这个条件句并没有告诉我们任何关于 $\\mathrm{TOTAL}_{\\mathrm{TM}}$ 可判定性的信息。因此，Alice 的结论是不成立的。\n\n一个具体的例子说明这样的归约方向不能证明不可判定性：设 $L$ 是任意可判定语言。设 $D$ 是它的判定器。定义一个可计算函数 $f$，它在输入 $x$ 上运行 $D(x)$，如果 $D$ 接受，则输出一个固定的对 $\\langle M_{halt}, w_{halt} \\rangle \\in A_{TM}$；如果 $D$ 拒绝，则输出一个固定的对 $\\langle M_{loop}, w_{loop} \\rangle \\notin A_{TM}$。那么 $x \\in L \\iff f(x) \\in A_{TM}$，所以 $L \\le_{m} A_{TM}$，然而 $L$ 是可判定的。因此，证明 $P \\le_{m} A_{TM}$ 并不能确定 $P$ 是不可判定的。\n\n因此，根本性的缺陷在于归约的方向。这对应于选项 A。其他选项是错误的，因为：映射归约不要求具有相同的可识别性状态（B 是错误的），构造 $f$ 并不需要假设存在一个 $\\mathrm{TOTAL}_{\\mathrm{TM}}$ 的判定器（C 是错误的），“从更难到更容易”的说法不是这里起作用的形式化标准（D 具有误导性），以及通过可计算的填充或硬编码从单个元素生成配对是标准做法（E 是错误的）。", "answer": "$$\\boxed{A}$$", "id": "1457073"}, {"introduction": "并非所有与程序“停机”相关的问题都是不可判定的。这个练习 [@problem_id:1457046] 挑战我们去思考不可判定性证明背后的一个根本性前提：无限性。通过对比通用的停机问题和一个被严格限制在有限状态机集合上的版本，我们可以揭示为什么后者是可判定的。这有助于我们精确理解停机问题不可判定性的根源，在于其适用于无限多种可能的图灵机，而非问题本身表面上的形式。", "problem": "在计算理论中，图灵机（Turing Machine, TM）是一种计算的数学模型，由一个状态集、一个带字母表和一个转移函数来描述。图灵机的编码，记作 $\\langle M \\rangle$，是一个表示该机器 $M$ 的有限字符串。空字符串用 $\\epsilon$ 表示。\n\n该领域的一个核心问题是空输入停机问题，它对应于语言 $HALT_{\\epsilon}$。该语言定义如下：\n$$HALT_{\\epsilon} = \\{ \\langle M \\rangle \\mid M \\text{ is a TM that halts on input } \\epsilon \\}$$\n一个公认的定理是，$HALT_{\\epsilon}$ 是一个不可判定语言。这意味着不存在任何算法，可以对任意一个图灵机，正确地判定它是否在空输入上停机。\n\n现在，考虑一个不同的语言，我们称之为 $L_{20}$。该语言是为使用固定带字母表 $\\Gamma = \\{0, 1, \\text{blank}\\}$ 的图灵机定义的，具体如下：\n$$L_{20} = \\{ \\langle M \\rangle \\mid M \\text{ is a TM with at most 20 states that halts on input } \\epsilon \\}$$\n事实是，与 $HALT_{\\epsilon}$ 不同，语言 $L_{20}$ 是可判定的。这似乎有些矛盾，因为 $L_{20}$ 看起来是停机问题的一个特例。\n\n下列哪个陈述为 $L_{20}$ 是可判定的，以及为何这一事实与 $HALT_{\\epsilon}$ 的不可判定性不矛盾，提供了最准确和根本的解释？\n\nA. 一个通用图灵机可以模拟任何最多有20个状态的图灵机，直到它停机。这种模拟只保证对于状态数少且有限的机器才会终止。\n\nB. $HALT_{\\epsilon}$ 的不可判定性是通过从通用停机问题 $A_{TM}$ 进行归约来证明的。如果目标机器被限制为最多有20个状态，则这种归约技术无效。\n\nC. 任何状态数不超过20个且在输入 $\\epsilon$ 上不停机的图灵机，都必须在带上进入一个简单的、重复的格局循环。一个判定器可以检测到这个循环，而这对于状态数更多的图灵机是不可能做到的。\n\nD. “在输入 $\\epsilon$ 上停机”是图灵机的一个非平凡性质。根据莱斯定理（Rice's Theorem），这意味着不可判定性。然而，莱斯定理对于状态数少的机器有一个例外。\n\nE. 所有具有固定字母表和有界状态数的不同图灵机的集合是有限的。因此，可以构建一个判定器，其内部含有一个硬编码列表，列出了所有已知的在 $\\epsilon$ 上停机的此类机器。这种方法对于 $HALT_{\\epsilon}$ 是不可能的，因为所有可能的图灵机的集合是无限的。", "solution": "我们已知 $HALT_{\\epsilon}=\\{\\langle M\\rangle\\mid M\\text{ halts on }\\epsilon\\}$ 是不可判定的，而 $L_{20}=\\{\\langle M\\rangle\\mid M\\text{ uses }\\Gamma=\\{0,1,\\text{blank}\\}\\text{, has at most }20\\text{ states, and halts on }\\epsilon\\}$ 是可判定的。我们必须解释为什么 $L_{20}$ 是可判定的，同时不与 $HALT_{\\epsilon}$ 的不可判定性相矛盾。\n\n步骤1（具有有界状态和固定字母表的机器集合的有限性）：固定带字母表 $\\Gamma=\\{0,1,\\text{blank}\\}$ 和一个状态集 $Q$，其中 $1\\leq |Q|\\leq 20$。对于一个确定性单带图灵机，其转移函数是一个部分函数 $\\delta:Q\\times\\Gamma\\to\\Gamma\\times\\{L,R\\}\\times(Q\\cup\\{\\text{halt-accept},\\text{halt-reject}\\})$。对于每一对 $(q,a)\\in Q\\times\\Gamma$，$\\delta(q,a)$ 的选择数量是有限的，因为：\n- 写入的符号来自有限集 $\\Gamma$，\n- 读写头的移动来自有限集 $\\{L,R\\}$，\n- 下一个控制状态从有限集 $Q\\cup\\{\\text{halt-accept},\\text{halt-reject}\\}$ 中选择。\n因此，对于固定的 $Q$ 和 $\\Gamma$，所有可能的转移表的集合是有限集的有限积，所以是有限的。对所有 $|Q|\\leq 20$ 的情况取并集，仍然得到一个有限集。因此，所有带字母表为 $\\Gamma=\\{0,1,\\text{blank}\\}$ 且状态数不超过20个的图灵机的集合是有限的。如果编码方式 $\\langle\\cdot\\rangle$ 是固定的且是单射的，那么这类机器的有效编码的集合也是有限的。\n\n步骤2（从有限性导出可判定性）：设 $S$ 是所有带字母表为 $\\Gamma=\\{0,1,\\text{blank}\\}$ 且状态数不超过20个的图灵机的编码所组成的有限集。那么 $L_{20}\\subseteq S$，且 $L_{20}$ 本身是有限的。任何有限语言都是可判定的：可以构建一个判定器，当输入为 $x$ 时，它首先检查 $x\\in S$ 是否成立（若不成立则拒绝），如果 $x\\in S$，则当且仅当 $x$ 属于一个有限的硬编码子集 $H\\subseteq S$ 时接受，$H$ 精确地包含了那些已知在输入 $\\epsilon$ 上停机的编码。等价地，可以为 $H$ 实现一个有限查找表。\n\n步骤3（与 $HALT_{\\epsilon}$ 的不可判定性不矛盾）：$HALT_{\\epsilon}$ 的不可判定性涉及一个无限的机器域，这些机器具有无界的状态数和转移可能性。将注意力限制在一个有限的机器子集上（即那些在固定字母表上最多有20个状态的机器），会得到一个有限语言，而有限语言是平凡可判定的。通过归约或莱斯定理证明的不可判定性结论，不适用于对输入域的有限限制；因此不存在矛盾。\n\n对选项的评估：\n- A 是错误的：无论状态数是否最多为20，模拟都不能保证对不停机的机器终止。\n- B 具有误导性：虽然标准的归约针对的是不受限制的机器，但这并不能解释其可判定性；核心原因是有限性。\n- C 是错误的：一个不停机的图灵机不一定会进入一个简单的、重复的格局循环；它可以无限地写入新的带符号而从不重复一个格局。\n- D 是错误的：莱斯定理没有“状态数少”的例外情况；更确切地说，它不适用于对机器集合的有限限制。\n- E 是正确的：这类机器的集合是有限的，因此可以通过有限查找来判定，这与 $HALT_{\\epsilon}$ 的不可判定性不矛盾，因为后者涵盖了一个无限的集合。", "answer": "$$\\boxed{E}$$", "id": "1457046"}]}