## 引言
在计算科学的宏伟蓝图中，我们常常惊叹于计算机解决复杂问题的强大能力。然而，是否存在一些问题，无论算法多么精妙、计算机多么强大，都从根本上无法解决？这正是计算理论的核心议题之一：[可计算性](@entry_id:276011)的边界。本文旨在填补从直觉理解到形式化证明之间的知识鸿沟，系统性地探讨“[不可判定性](@entry_id:145973)”（Undecidability）这一深刻概念。

我们将从计算理论的基石出发，在**“原理与机制”**一章中，以阿兰·图灵提出的**[停机问题](@entry_id:265241)**为原型，揭示第一个被证明的不可解问题。读者将学习到强大的[对角化](@entry_id:147016)论证，并掌握一种关键的证明技术——**归约**，学会如何利用它来证明其他问题的[不可判定性](@entry_id:145973)。随后，在**“应用与跨学科联系”**一章中，我们将视野扩展到计算机科学之外，探索[不可判定性](@entry_id:145973)如何在软件工程、[形式逻辑](@entry_id:263078)、纯粹数学乃至复杂系统科学中划定理论的边界，展示这些抽象概念的深远实际影响。最后，通过**“实践练习”**部分，读者将有机会通过解决具体问题来检验和巩固所学知识，深化对归约逻辑和[不可判定性](@entry_id:145973)证明的理解。

## 原理与机制

在本章中，我们将深入探讨[计算理论](@entry_id:273524)的核心——[不可判定性](@entry_id:145973)（Undecidability）的概念。继前一章对图灵机作为计算的形式化模型的介绍之后，我们将首先阐明[不可判定性](@entry_id:145973)的基本原理，以著名的**[停机问题](@entry_id:265241)（Halting Problem）**作为原型。随后，我们将系统地介绍一种强大的证明技术——**归约（Reduction）**，并展示如何利用它来证明一系列其他计算问题同样是不可解的。最后，我们将探讨可判定与不可判定之间的明确界限，考察通过何种方式限制[计算模型](@entry_id:152639)可以恢复其[可判定性](@entry_id:152003)。

### 可计算性与[不可判定性](@entry_id:145973)的形式化

在我们深入探讨[不可判定性](@entry_id:145973)之前，必须精确地定义我们所讨论的对象。一个**决策问题（Decision Problem）**可以被形式化地看作是关于一个集合的成员资格问题。给定一个固定的字母表 $\Sigma$，一个决策问题对应于字符串集合 $\Sigma^*$ 的一个[子集](@entry_id:261956) $D$。如果存在一台[图灵机](@entry_id:153260)（Turing Machine, TM），对于任何输入字符串 $x \in \Sigma^*$，它总能停机，并且当 $x \in D$ 时输出“是”（或 $1$），当 $x \notin D$ 时输出“否”（或 $0$），那么我们称该问题 $D$ 是**可判定的（Decidable）**或**递归的（Recursive）**。

然而，并非所有问题都是可判定的。对于某些问题，我们可能只能设计出一种“半解决”算法。如果一个集合 $S$ 存在一台[图灵机](@entry_id:153260)，它在输入 $x \in S$ 时停机并接受，而在输入 $x \notin S$ 时要么停机并拒绝，要么永不停机（即发散），那么我们称该集合 $S$ 是**递归可枚举的（Recursively Enumerable, r.e.）**。一个等价的定义是，存在一台图灵机可以枚举出集合 $S$ 中的所有元素。

一个基础性的结论是，一个集合 $A$ 是可判定的，当且仅当 $A$ 和它的[补集](@entry_id:161099) $\overline{A}$ 都是递归可枚举的。这个结果（[Post 定理](@entry_id:155425)的一个推论）为我们判断一个递归可枚举的集合是否可判定提供了一个强大的工具。

为了进行深入的理论分析，我们假定所有图灵机都可以被有效地编码为自然数（或字符串）。这种编码方案允许我们建立一个[图灵机](@entry_id:153260)的可数枚举 $\{M_e\}_{e \in \mathbb{N}}$，其中 $e$ 是图灵机 $M_e$ 的**索引（index）**或编码。我们用 $\varphi_e$ 表示由图灵机 $M_e$ 计算的（部分）[可计算函数](@entry_id:152169)。这种自引用的框架是揭示计算内在局限性的关键。

### 停机问题：[不可判定性](@entry_id:145973)的原型

历史上，第一个被证明为不可判定的自然问题是**停机问题**。它的定义非常直观：给定一台图灵机 $M$ 的描述和一个输入 $x$，判断 $M$ 在输入 $x$ 上是否会最终停机。我们可以将这个问题形式化为以下集合：
$$
\mathrm{HALT} = \{ \langle e,x \rangle \mid M_e \text{ 在输入 } x \text{ 上停机} \}
$$
其中 $\langle e,x \rangle$ 是对图灵机索引 $e$ 和输入 $x$ 进行配对编码的结果。

为了简化证明，我们通常关注一个更特殊的版本，即**对角停机问题（Diagonal Halting Problem）**，其集合定义为 $K$：
$$
K = \{ e \in \mathbb{N} \mid M_e \text{ 在输入 } e \text{ 上停机} \}
$$
这个集合 $K$ 询问的是：索引为 $e$ 的图灵机，在以其自身的索引 $e$ 作为输入时，是否会停机。[@problem_id:3056758]

$K$ 是递归可枚举的。我们可以构造一台[通用图灵机](@entry_id:155764)（Universal Turing Machine, UTM），在输入 $e$ 时，它模拟 $M_e$ 在输入 $e$ 上的行为。如果 $M_e(e)$ 停机，我们的模拟器也将停机并接受。如果 $M_e(e)$ 无限循环，我们的模拟器也将无限循环。根据定义，这证明了 $K$ 是递归可枚举的。

然而，$K$ 是不可判定的。这个结论的经典证明采用了**[对角化](@entry_id:147016)论证（Diagonalization Argument）**，这是一种在数学中用于证明某些集合比其他集合“更大”的强大技术。[@problem_id:1463160] 证明过程如下：

假设 $K$ 是可判定的。那么，存在一台总能停机的图灵机 $H_K$，它可以判定任何给定的 $e$ 是否属于 $K$。基于 $H_K$，我们可以构造一台新的、看似矛盾的“对角”[图灵机](@entry_id:153260) $D$，其行为如下：
对于任何输入 $e$：
1. $D$ 调用 $H_K$ 来判断 $e$ 是否在 $K$ 中（即 $M_e$ 在输入 $e$ 上是否停机）。
2. 如果 $H_K$ 回答“是”（即 $e \in K$），$D$ 就故意进入一个无限循环。
3. 如果 $H_K$ 回答“否”（即 $e \notin K$），$D$ 就立即停机。

由于 $D$ 本身也是一台合法的图灵机，它必然在我们的枚举中拥有一个索引，我们称之为 $d$。现在，我们来考察 $D$ 在以其自身的索引 $d$ 作为输入时的行为，即 $D(d)$：

- **情况 1：** 假设 $D(d)$ 停机。根据 $K$ 的定义，这意味着 $d \in K$。但是，根据 $D$ 的构造，如果 $d \in K$，$D(d)$ 应该进入无限循环，永不停机。这产生了矛盾。
- **情况 2：** 假设 $D(d)$ 不停机。根据 $K$ 的定义，这意味着 $d \notin K$。但是，根据 $D$ 的构造，如果 $d \notin K$，$D(d)$ 应该立即停机。这也产生了矛盾。

由于两种可能性都导向了矛盾，我们最初的假设——即存在一台可以判定 $K$ 的图灵机 $H_K$——必定是错误的。因此，对角停机问题 $K$ 是不可判定的。

既然我们已经知道 $K$ 是递归可枚举的，但不是可判定的，我们可以立即推断出它的[补集](@entry_id:161099) $\overline{K} = \{ e \in \mathbb{N} \mid M_e \text{ 在输入 } e \text{ 上不停机} \}$ 不是递归可枚举的。否则，如果 $\overline{K}$ 也是递归可枚举的，那么根据 [Post 定理](@entry_id:155425)，K 将是可判定的，这与我们刚刚证明的结论相悖。[@problem_id:3056758]

### 归约的力量：传递[不可判定性](@entry_id:145973)

证明了第一个[不可判定问题](@entry_id:145078)后，我们便获得了一个“困难”的参照物。**归约（Reduction）** 是一种形式化的方法，用于表明一个问题至少和另一个问题一样“困难”。具体来说，**多一归约（Many-one Reduction）**是其中最常用的一种。

我们说问题 $A$ 可多一归约到问题 $B$，记作 $A \le_m B$，如果存在一个**全[可计算函数](@entry_id:152169)（Total Computable Function）** $f$，对于所有输入 $x$，满足以下条件：
$$
x \in A \iff f(x) \in B
$$
这个函数 $f$ 充当了一个转换器：它将问题 $A$ 的任何实例 $x$ 转化为问题 $B$ 的一个实例 $f(x)$，并且保持成员资格的“真/假”值不变。重要的是，$f$ 本身必须是可计算的，且对于任何输入都必须停机并给出输出。[@problem_id:3059527]

归约的核心作用在于传递[不可判定性](@entry_id:145973)。其逻辑如下：如果我们知道 $A$ 是不可判定的，并且我们成功地构造了一个从 $A$ 到 $B$ 的归约 $A \le_m B$，那么 $B$ 也必然是不可判定的。[@problem_id:3059527] 我们可以用反证法来理解这一点：假设 $B$ 是可判定的，那么存在一个决策算法 $D_B$。我们可以通过以下步骤为 $A$ 构建一个决策算法 $D_A$：
1. 对于给定的输入 $x$，计算 $y = f(x)$。由于 $f$ 是全可计算的，此步骤总会停机。
2. 运行 $D_B$ 来判断 $y$ 是否属于 $B$。由于 $D_B$ 是决策算法，此步骤也总会停机。
3. 如果 $D_B$ 接受 $y$，则 $D_A$ 接受 $x$；如果 $D_B$ 拒绝 $y$，则 $D_A$ 拒绝 $x$。
这个过程为 $A$ 提供了一个完整的决策算法，与 $A$ 不可判定的已知事实相矛盾。因此，我们关于 $B$ 可判定的假设必定是错误的。

作为一个简单的例子，我们可以证明 $K \le_m \mathrm{HALT}$。归约函数 $f$ 可以简单地定义为 $f(e) = \langle e,e \rangle$。这个函数显然是全可计算的。根据定义，$e \in K$ 当且仅当 $M_e$ 在输入 $e$ 上停机，这又当且仅当 $\langle e,e \rangle \in \mathrm{HALT}$。因此，通过这个简单的归约，$\mathrm{HALT}$ 的[不可判定性](@entry_id:145973)就从 $K$ 的[不可判定性](@entry_id:145973)中继承而来。[@problem_id:3056758]

### 归约技巧案例研究

掌握归约的艺术是[计算理论](@entry_id:273524)中的一项关键技能。这通常涉及到一个“给定旧问题的实例，构造新问题的实例”的创造性过程。让我们通过一个例子来说明。考虑以下语言：
$$
L_P = \{ \langle M \rangle \mid \text{存在一个长度为素数的字符串 } w \text{，使得 } M \text{ 在输入 } w \text{ 上停机} \}
$$
为了证明 $L_P$ 是不可判定的，我们可以从一个已知的[不可判定问题](@entry_id:145078)（如 $\mathrm{HALT}_{\mathrm{TM}}$）构造一个到 $L_P$ 的归约。[@problem_id:3056757]

归约的构造如下：我们需要一个全[可计算函数](@entry_id:152169) $f$，它将 $\mathrm{HALT}_{\mathrm{TM}}$ 的一个实例 $\langle M,x \rangle$ 映射到 $L_P$ 的一个实例 $\langle N \rangle$。这个函数 $f$ 实际上是一个算法，它接收 $M$ 和 $x$ 的描述，然后输出一个新的图灵机 $N$ 的描述。$N$ 的行为被设计为：
对于任何输入 $y$：
1. 检查 $y$ 的长度 $|y|$ 是否为素数。
2. 如果 $|y|$ 不是素数，$N$ 进入一个无限循环。
3. 如果 $|y|$ 是素数，$N$ 开始模拟 $M$ 在输入 $x$ 上的计算。如果 $M(x)$ 停机，$N$ 就停机；如果 $M(x)$ 不停机，$N$ 也不停机。

现在我们来验证这个归约是否满足 $x \in A \iff f(x) \in B$ 的条件：
- **($\Rightarrow$)** 假设 $\langle M,x \rangle \in \mathrm{HALT}_{\mathrm{TM}}$，即 $M$ 在 $x$ 上停机。我们需要证明 $\langle N \rangle \in L_P$。根据 $L_P$ 的定义，我们只需找到一个长度为素数的字符串 $w$，使得 $N(w)$ 停机。由于素数有无穷多个，我们可以任选一个这样的 $w$（例如，长度为2的字符串）。根据 $N$ 的构造，当输入 $w$ 时，它会模拟 $M(x)$。因为 $M(x)$ 停机，模拟也会结束，$N$ 也会停机。因此，$\langle N \rangle \in L_P$。
- **($\Leftarrow$)** 假设 $\langle N \rangle \in L_P$。这意味着存在一个长度为素数的字符串 $w$，使得 $N(w)$ 停机。根据 $N$ 的构造，它只有在输入长度为素数时才有可能停机。在这种情况下，$N$ 的行为是模拟 $M(x)$。既然 $N(w)$ 停机了，那么模拟过程必然已经终止，这说明 $M$ 在输入 $x$ 上停机。因此，$\langle M,x \rangle \in \mathrm{HALT}_{\mathrm{TM}}$。

这个构造是有效的，因此我们证明了 $\mathrm{HALT}_{\mathrm{TM}} \le_m L_P$，从而证明了 $L_P$ 是不可判定的。这个例子揭示了归约设计的核心模式：利用新机器 $N$ 的行为作为“传感器”，其是否满足目标属性（在 $L_P$ 的情况下，是在某个特定类型的输入上停机）完全取决于源问题实例（$\langle M,x \rangle$）的答案。

在设计归约时，必须避免一些常见的逻辑陷阱：[@problem_id:3056757]
- **归约方向错误：** 证明 $L_P \le_m \mathrm{HALT}_{\mathrm{TM}}$ 并不能说明 $L_P$ 是不可判定的。它只说明，如果 $\mathrm{HALT}_{\mathrm{TM}}$ 是可判定的，那么 $L_P$ 也是可判定的。由于前提为假，这不能给我们任何关于 $L_P$ 的信息。
- **归约到补集：** 尝试构造 $\mathrm{HALT}_{\mathrm{TM}} \le_m \overline{L_P}$ 意味着 $\overline{\mathrm{HALT}_{\mathrm{TM}}} \le_m L_P$。然而，我们知道 $\overline{\mathrm{HALT}_{\mathrm{TM}}}$ 不是递归可枚举的，而 $L_P$ 是递归可枚举的。一个非递归可枚举的集合不可能多一归约到一个递归可枚举的集合。因此，这样的归约函数不可能存在。

### [莱斯定理](@entry_id:149389)：一个关于[不可判定性](@entry_id:145973)的通用定理

许多关于图灵机行为的问题都可以被证明是不可判定的。**[莱斯定理](@entry_id:149389)（Rice's Theorem）**提供了一个强大的、一劳永逸的方法来证明这一点。它指出：

> 任何关于部分[可计算函数](@entry_id:152169)行为的**非平凡（non-trivial）**且**外延的（extensional）**属性都是不可判定的。

让我们解析这些关键术语：[@problem_id:2988366]
- **外延的属性**：一个属性是外延的，如果它只依赖于函数本身的行为（即输入-输出的映射关系），而不是计算该函数的具体图灵机代码（索引）。换句话说，如果两个[图灵机](@entry_id:153260) $M_e$ 和 $M_d$ 计算完全相同的函数（$\varphi_e = \varphi_d$），那么它们要么都具有该属性，要么都不具有。例如，“函数是否在输入0时停机”是[外延](@entry_id:161930)的，而“[图灵机](@entry_id:153260)的描述是否包含超过100个状态”是语法的，非外延的。
- **非平凡的属性**：一个属性是非平凡的，如果存在至少一个[可计算函数](@entry_id:152169)具有该属性，且至少一个[可计算函数](@entry_id:152169)不具有该属性。

[莱斯定理](@entry_id:149389)的证明本身就是一次归约模式的精彩应用。它展示了如何从[停机问题](@entry_id:265241) $K$ 归约到任何满足上述条件的属性 $\mathcal{P}$ 的索引集 $S_{\mathcal{P}} = \{e \mid \varphi_e \in \mathcal{P}\}$。证明的核心思想是，给定一个[停机问题](@entry_id:265241)实例 $i$，我们构造一个新的[图灵机](@entry_id:153260) $M_{f(i)}$，其行为如下：在任何输入 $x$ 上，它首先使用[通用图灵机](@entry_id:155764)模拟 $M_i(i)$。如果模拟停机，它就转而计算一个已知具有属性 $\mathcal{P}$ 的函数 $g_{\mathrm{in}}$；如果模拟永不停机，那么 $M_{f(i)}$ 在 $x$ 上也永不停机（这相当于计算一个不具有属性 $\mathcal{P}$ 的函数，例如处处无定义的函数）。这样，当且仅当 $i \in K$ 时，$\varphi_{f(i)}$ 才具有属性 $\mathcal{P}$。这就建立了 $K \le_m S_{\mathcal{P}}$，从而证明了 $S_{\mathcal{P}}$ 的[不可判定性](@entry_id:145973)。[@problem_id:2988366]

需要注意的是，[莱斯定理](@entry_id:149389)只适用于[外延](@entry_id:161930)属性。例如，前面我们讨论的 $L_P$ 所对应的属性“图灵机在某个长度为素数的输入上停机”，就不是一个外延属性。我们可以构造两台[图灵机](@entry_id:153260)，它们都识别空语言（因此计算相同的函数），但一台在任何输入上都无限循环，另一台则在某个长度为素数的输入上停机并拒绝。由于这两台机器计算的函数相同，但一个在 $L_P$ 中，一个不在，所以该属性不是外延的，不能直接应用[莱斯定理](@entry_id:149389)。[@problem_id:3056757]

### 超越[停机问题](@entry_id:265241)：与逻辑的联系

计算的[不可判定性](@entry_id:145973)与数理逻辑的基本限制之间存在着深刻的联系。20世纪初，数学家 David Hilbert 提出了著名的**[判定问题](@entry_id:636780)（[Entscheidungsproblem](@entry_id:636780)）**：是否存在一个算法，能在有限步骤内判定任何给定的**[一阶逻辑](@entry_id:154340)（First-order Logic, FOL）**句子是否**普遍有效（universally valid）**？[@problem_id:3044113]

Alonzo Church 和 Alan Turing 在1936年独立地证明了这个问题的答案是否定的。他们的工作表明，[一阶逻辑](@entry_id:154340)的有效性问题是不可判定的。这个证明同样依赖于归约。标准证明构造了一个从停机问题到一阶[逻辑有效性](@entry_id:156732)问题的归约，即 $\mathrm{HALT} \le_m \mathrm{VALIDITY}$。[@problem_id:3059527]

这个归约的精髓在于，对于任何图灵机 $M$ 和输入 $w$，我们都可以通过一个纯粹的句法操作，自动地构造出一个一阶逻辑句子 $\varphi_{M,w}$。这个句子在逻辑上编码了 $M$ 在 $w$ 上的整个计算历史，并断言“存在一个时刻 $t$，使得机器在该时刻处于停机状态”。这个句子的构造方式保证了：
$$
M \text{ 在 } w \text{ 上停机} \iff \varphi_{M,w} \text{ 是一个普遍有效的句子}
$$
重要的是，这个从 $(\langle M,w \rangle)$ 到 $\varphi_{M,w}$ 的转换函数本身是一个可计算的（甚至是[原始递归](@entry_id:638015)的）过程，它只分析 $M$ 的转换规则和输入 $w$ 的结构，而不需要实际运行或模拟可能永不停机的 $M$。[@problem_id:3059536]

由于[停机问题](@entry_id:265241)是不可判定的，一阶逻辑的有效性问题也必然是不可判定的。然而，根据**[哥德尔完备性定理](@entry_id:153518)（Gödel's Completeness Theorem）**，一个句子是普遍有效的当且仅当它可以从公理系统中被证明。由于证明是有限的、可被机械验证的对象，所有有效句子的集合是递归可枚举的。因此，一阶逻辑的有效性问题是一个典型的“半可判定”问题：它是递归可枚举的，但不是可判定的。[@problem_id:3044113] [@problem_id:3059541]

我们必须仔细区分**Church 的[不可判定性](@entry_id:145973)定理**和**[哥德尔不完备性定理](@entry_id:153511)（Gödel's Incompleteness Theorems）**。不[完备性定理](@entry_id:151598)是关于特定的、足够强的、能够表达算术的公理系统（如[皮亚诺算术](@entry_id:150593)）的内在局限性，它表明任何这样的系统都存在既不能被证明也不能被[证伪](@entry_id:260896)的真命题。而 Church 的定理是关于纯逻辑本身的，它断言不存在一个通用算法来判定所有模型下的真理。算术真理的集合，即在标准自然数模型 $\mathbb{N}$ 中所有为真的句子构成的集合 $\mathrm{Th}(\mathbb{N})$，其[不可判定性](@entry_id:145973)程度甚至更高——它不是递归可枚举的。[@problem_id:3059541]

### 划定边界：可判定与不可判定

停机问题的[不可判定性](@entry_id:145973)并非意味着所有与程序终止相关的问题都是不可解的。实际上，通过对[计算模型](@entry_id:152639)施加限制，我们可以重新获得[可判定性](@entry_id:152003)。

一个重要的区别在于**有界停机问题（Bounded Halting Problem）**。考虑这样一个问题：给定 $\langle M,x,t \rangle$，判断 $M$ 在输入 $x$ 上是否能在至多 $t$ 步内停机。这个问题是完全可判定的。决策算法很简单：只需模拟 $M$ 在 $x$ 上的计算，最多模拟 $t$ 步。如果在 $t$ 步内停机，则回答“是”；否则回答“否”。这个模拟过程总会在有限时间内结束。[@problem_id:2986052]

这个看似简单的区别揭示了[不可判定性](@entry_id:145973)的根源：它来自于对计算步骤数（或时间）的**无界量化**。[停机问题](@entry_id:265241)本质上是在问“是否存在一个 $t$”，而这是一个对无限集合的量化，无法通过逐一尝试来解决。[@problem_id:2986052]

有趣的是，有界停机问题的**[计算复杂性](@entry_id:204275)**与时间界限 $t$ 的编码方式密切相关。如果 $t$ 以一元形式（如 $1^t$）给出，则输入长度与 $t$ 成正比，上述模拟算法的运行时间是输入长度的多项式，因此该问题属于复杂性类 $P$。但如果 $t$ 以二进制形式给出，则输入长度仅为 $\log t$ 的量级，而模拟时间仍与 $t$ 成正比，即输入长度的指数函数。这使得问题变得困难，但仍然是可判定的。[@problem_id:2986052]

最后，我们可以通过限制程序本身的表达能力来确保停机。以下是一些具有可判定停机问题的编程语言子类：[@problem_id:2986078]

- **LOOP 语言：** 这类程序只包含赋值、顺序执行和**有界循环**（例如 `for i from 0 to n`）。由于没有 `while` 循环或一般递归，所有循环的迭代次数上限都可以在运行前确定。因此，每个 LOOP 程序都保证停机。这类程序计算的正是[原始递归函数](@entry_id:155169)。

- **线性有界自动机（Linear Bounded Automata, LBA）：** 这是一种[图灵机](@entry_id:153260)，其工作带的长度被限制为输入长度的常数倍。对于给定的输入，LBA 的可能配置（状态、磁头位置、带子内容）总数是有限的。如果一台 LBA 运行的步数超过了这个巨大的、但有限的配置总数，它必然已经进入了无限循环。因此，通过模拟并检测循环，可以判定其是否停机。

- **强规范化的类型演算（如哥德尔的系统 T）：** 在某些带有强大类型系统的[函数式编程](@entry_id:636331)语言中，所有合法的（即类型检查通过的）程序都被数学上证明是**强规范化**的，这意味着它们的任何求值序列都必定在有限步内终止。对于这类语言，[停机问题](@entry_id:265241)是平凡可判定的——答案永远是“是”。

这些例子表明，[不可判定性](@entry_id:145973)是[图灵完备](@entry_id:271513)计算模型（即那些强大到足以模拟任何其他[图灵机](@entry_id:153260)的模型）的一个固有特性。一旦我们放弃了这种无限的模拟能力，例如通过限制循环、内存或递归的结构，[停机问题](@entry_id:265241)就可能重新变得可解。然而，值得注意的是，仅仅将我们的注意力限制在“所有保证停机的图灵机”这个类别上是行不通的，因为判断一个任意给定的图灵机是否属于这个类别本身就是一个不可判定的问题（即 $\mathrm{TOTAL}$ 问题）。[@problem_id:2986078]