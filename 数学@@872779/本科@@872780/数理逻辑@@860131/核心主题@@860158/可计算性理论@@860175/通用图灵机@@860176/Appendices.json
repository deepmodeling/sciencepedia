{"hands_on_practices": [{"introduction": "通用图灵机的一个核心思想是它们可以互相模拟，但这种模拟并非没有代价。本练习将带您深入探讨模拟开销这一概念，它是算法信息论中不变性定理的关键。通过具体的计算，您将切实理解一个通用图灵机的程序如何被“翻译”给另一个通用图灵机执行，并量化这种翻译的“成本”是多少比特。[@problem_id:3060172]", "problem": "考虑二进制字符串和一台其定义域为无前缀的固定通用图灵机 (UTM) $U$。对于任何无前缀的通用图灵机 $M$ 和任何有限二进制字符串 $x$，将相对于 $M$ 的柯尔莫哥洛夫复杂度定义为 $K_{M}(x) = \\min\\{\\,|p| : M(p) = x\\,\\}$，其中 $|p|$ 表示程序 $p$ 的比特长度。\n\n设 $V$ 是另一台无前缀的通用图灵机，其输入约定如下。对于形式为 $C(w)\\,p$ 的输入，机器 $V$ 首先解码自限定前缀 $C(w)$ 以恢复 $w$，然后将 $w$ 作为解释器在输入 $p$ 上执行以产生输出。自限定编码器 $C$ 定义为 $C(w) = 1^{|w|}0w$，它是无前缀的，长度为 $|C(w)| = 2|w| + 1$ 比特。\n\n假设存在一个长度为 $|s| = 19$ 比特的固定解释器（转换器）$s$，使得对于每个二进制程序 $q$，计算 $V(C(s)\\,q)$ 产生与 $U(q)$ 完全相同的输出。仅使用上述定义和 $V$ 的既定输入约定，确定最小常数 $c$（以比特为单位），使得对于每个有限二进制字符串 $x$，在此方案下不等式 $K_{V}(x) \\leq K_{U}(x) + c$ 成立。将 $c$ 表示为精确的比特整数计数。不需要近似值，您应该报告一个纯粹的比特数。", "solution": "问题陈述是算法信息论领域内一个定义明确的问题。所有术语，如通用图灵机 (UTM)、无前缀定义域和柯尔莫哥洛夫复杂度，都是标准的。为特定机器 $U$ 和 $V$、编码器 $C$ 和解释器 $s$ 提供的定义是清晰、自洽且数学上一致的。没有科学或逻辑上的缺陷、歧义或信息缺失。因此，该问题被认为是有效的，并且可以推导出形式解。\n\n目标是确定最小常数 $c$，一个表示比特数的整数，使得对于每个有限二进制字符串 $x$，不等式 $K_{V}(x) \\leq K_{U}(x) + c$ 成立。\n\n根据相对于机器 $M$ 的柯尔莫哥洛夫复杂度的定义 $K_{M}(x) = \\min\\{\\,|p| : M(p) = x\\,\\}$，对于机器 $U$ 存在一个能够生成字符串 $x$ 的最小长度程序 $p_U^*$。该程序的属性是：\n$1.$ $U(p_U^*) = x$\n$2.$ $|p_U^*| = K_U(x)$\n\n问题提供了一种将机器 $U$ 的计算与机器 $V$ 的计算关联起来的机制。具体来说，它指出存在一个长度为 $|s| = 19$ 比特的固定解释器字符串 $s$，使得对于任何程序 $q$，计算 $V(C(s)\\,q)$ 产生与 $U(q)$ 相同的输出。\n\n我们可以利用这种关系来为机器 $V$ 构建一个输出 $x$ 的程序。让我们选择程序 $q$ 为 $U$ 输出 $x$ 的最短程序，即 $p_U^*$。\n根据给定的规则，我们有：\n$$V(C(s)\\,p_U^*) = U(p_U^*)$$\n因为我们知道 $U(p_U^*) = x$，所以可得：\n$$V(C(s)\\,p_U^*) = x$$\n这表明连接后的字符串 $P_V = C(s)\\,p_U^*$ 是一个为机器 $V$ 产生输出 $x$ 的程序。\n\n柯尔莫哥洛夫复杂度 $K_V(x)$ 是为 $V$ 输出 $x$ 的*最短*程序的长度。因此，我们构造的程序 $P_V$ 的长度是 $K_V(x)$ 的一个上界。\n$$K_V(x) \\leq |P_V|$$\n程序 $P_V$ 的长度是其组成部分长度的总和，因为它是一个简单的连接：\n$$|P_V| = |C(s)\\,p_U^*| = |C(s)| + |p_U^*|$$\n我们知道 $|p_U^*| = K_U(x)$，所以我们可以写出：\n$$K_V(x) \\leq |C(s)| + K_U(x)$$\n这个不等式具有所需的形式 $K_V(x) \\leq K_U(x) + c$，其中常数 $c$ 等于 $|C(s)|$。\n\n现在，我们必须计算这个常数的值。问题将自限定编码器 $C$ 定义为 $C(w) = 1^{|w|}0w$，并指出其长度为 $|C(w)| = 2|w| + 1$。\n给定解释器字符串 $s$ 的长度为 $|s|=19$ 比特。我们可以计算其编码版本的长度 $|C(s)|$：\n$$|C(s)| = 2|s| + 1$$\n代入给定值 $|s|=19$：\n$$|C(s)| = 2(19) + 1 = 38 + 1 = 39$$\n因此，常数 $c$ 是 $39$ 比特。\n\n推导出的不等式是 $K_V(x) \\leq K_U(x) + 39$。这个不等式对每个有限二进制字符串 $x$ 都成立。问题要求的是使该关系成立的*最小*常数 $c$。常数 $c=39$ 代表了使用所提供的解释器 $s$ 和编码方案 $C$ 来指示机器 $V$ 模拟机器 $U$ 所需的固定比特开销。这种模拟方法是问题中指定的 $U$ 和 $V$ 之间的唯一联系。因为我们必须找到一个对*所有*字符串 $x$ 都成立的常数，所以我们必须考虑到这种可能性：对于某些字符串，模拟最短的 $U$ 程序，实际上是在 $V$ 上生成它们的最高效方式。因此，我们不能保证一个更小的常数会对每一个可能的字符串 $x$ 都满足该不等式。值 $c=|C(s)|$ 代表了基于给定信息可以确立的最紧凑的可能上界。\n\n因此，最小常数 $c$ 是 $39$。", "answer": "$$\\boxed{39}$$", "id": "3060172"}, {"introduction": "通用图灵机可以运行任何程序，但它能分析该程序的任意属性吗？莱斯定理为此设定了一个根本性的限制。这个练习将帮助您区分可判定的“句法”属性（程序是如何编写的）和不可判定的“语义”属性（程序的功能是什么）。理解这种区别对于认识计算的内在局限性至关重要，例如，为何完美的程序验证或病毒扫描是不可能实现的。[@problem_id:2988385]", "problem": "给定一台固定的通用图灵机 (UTM) $U$，它使用标准的二进制编码将程序表示为有限二进制串。对于任意二进制串 $p$，令 $\\varphi^{U}_{p}$ 表示将 $p$ 作为程序在 $U$ 上运行所计算出的部分可计算函数。如果一个程序的性质仅取决于其所计算的部分可计算函数，则称该性质是外延的。也就是说，如果对于所有代码 $p,q$，只要 $\\varphi^{U}_{p} = \\varphi^{U}_{q}$ 且 $p \\in S$，就有 $q \\in S$，那么代码集合 $S \\subseteq \\{0,1\\}^{\\ast}$ 是（相对于 $U$ 的）外延的。如果一个性质不是外延的，则称其为内涵的。也就是说，它可以区分计算相同部分可计算函数的不同代码。Rice 定理指出，对于任何非平凡的部分可计算函数类 $\\mathcal{C}$（非空且不包含所有此类函数），指标集 $\\{\\,p : \\varphi^{U}_{p} \\in \\mathcal{C}\\,\\}$ 对任何固定的 $U$ 都是不可判定的。\n\n考虑以下通过关注 $U$-程序的内涵性质来“规避”Rice 定理的候选方法。选择所有正确识别了一个可判定的内涵性质，并正确说明了 Rice 定理为何不适用的陈述。\n\nA. 固定 $U$ 和 $k \\in \\mathbb{N}$。定义 $P_{k} = \\{\\,p : p \\text{ 是一个语法上有效的 } U\\text{-程序且 } |p| \\leq k\\,\\}$。那么 $P_{k}$ 是可判定的，通过计算 $|p|$ 并检查其语法良构性即可。Rice 定理不适用，因为 $P_{k}$ 不是部分函数 $\\varphi^{U}_{p}$ 的性质：存在 $p,q$ 使得 $\\varphi^{U}_{p} = \\varphi^{U}_{q}$ 但 $|p| \\neq |q|$，因此 $P_{k}$ 不是外延的。\n\nB. 固定 $U$ 和 $k \\in \\mathbb{N}$。定义 $Q_{k} = \\{\\,p : \\exists q \\text{ 满足 } |q| \\leq k \\text{ 且 } \\varphi^{U}_{q} = \\varphi^{U}_{p}\\,\\}$。那么 $Q_{k}$ 是可判定的，通过枚举所有满足 $|q| \\leq k$ 的 $q$，并在所有输入上模拟 $U(q)$ 和 $U(p)$ 来检查其相等性。Rice 定理在此不适用，因为 $U$ 是固定的。\n\nC. 固定 $U$。因为编码是固定的，所以 $U$-程序的每个非平凡性质都是可判定的（不可判定性的唯一来源是编码的可变性），因此对于所有这类性质，都可以避免 Rice 定理。\n\nD. 固定 $U$ 和一个有限二进制串 $s$。定义 $R_{s} = \\{\\,p : p \\text{ 的代码中包含 } s \\text{ 作为连续子串}\\,\\}$。那么 $R_{s}$ 是可判定的，通过扫描 $p$ 的代码即可。Rice 定理不适用，因为 $R_{s}$ 是纯粹内涵的，并且在将 $p$ 替换为任何满足 $\\varphi^{U}_{q} = \\varphi^{U}_{p}$ 的 $q$ 时不保持不变。\n\nE. 固定 $U$。集合 $T = \\{\\,p : \\varphi^{U}_{p} \\text{ 是全函数}\\,\\}$ 是可判定的，通过在所有输入上交叉运行 $U(p)$ 并检测到没有输入发散。Rice 定理不适用，因为当 $U$ 固定时，全函数性是 $U$-程序的一个语法性质。\n\n给出你的选择，并准备从第一性原理出发，论证为什么正确的选项确实通过转向内涵性质规避了 Rice 定理，以及为什么 Rice 定理不适用于这些选项。", "solution": "我们从第一性原理开始：一台通用图灵机 (UTM) $U$ 是一台固定的图灵机，它在给定程序代码 $p$ 和输入 $x$ 时，模拟由 $p$ 编码的在 $x$ 上的计算。因此，每个代码 $p$ 确定一个部分可计算函数 $\\varphi^{U}_{p} \\colon \\{0,1\\}^{\\ast} \\rightharpoonup \\{0,1\\}^{\\ast}$。如果一个程序的性质仅取决于 $\\varphi^{U}_{p}$，那么它就是外延的；否则就是内涵的。Rice 定理指出：对于任何固定的 $U$，部分可计算函数的任何非平凡外延性质（等价地，在等价关系 $p \\sim q \\iff \\varphi^{U}_{p} = \\varphi^{U}_{q}$ 下不变的任何非平凡指标集）都是不可判定的。因此，要“规避”Rice 定理，必须跳出其假设的范围，例如，通过考虑非外延的性质（即内涵的，取决于语法表示 $p$ 本身的性质）。这类性质可以是可判定的，因为它们避免了触发 Rice 定理的语义内容。\n\n我们现在分析每个选项。\n\n选项 A：定义 $P_{k} = \\{\\,p : p \\text{ 是一个语法上有效的 } U\\text{-程序且 } |p| \\leq k\\,\\}$。可判定性：给定 $p$，可以计算其长度 $|p|$ 并根据所选的语法编码检查二进制串 $p$ 是否是 $U$ 的一个良构代码（此检查是基于编码规则的有限、机械的扫描）。这两项检查都是可计算的，它们的合取也是可计算的，因此 $P_{k}$ 是可判定的。Rice 定理的不适用性：$P_{k}$ 显然不是外延的。存在代码 $p,q$ 使得 $\\varphi^{U}_{p} = \\varphi^{U}_{q}$ 但 $|p| \\neq |q|$；例如，$q$ 可能是 $p$ 的一个填充或重构版本，它以不同的长度计算相同的函数。因此 $P_{k}$ 在等价关系 $p \\sim q$ 下不保持不变，所以它不是所计算的部分函数的性质；因此 Rice 定理不适用。结论：正确。\n\n选项 B：定义 $Q_{k} = \\{\\,p : \\exists q \\text{ 满足 } |q| \\leq k \\text{ 且 } \\varphi^{U}_{q} = \\varphi^{U}_{p}\\,\\}$。首先，注意到 $Q_{k}$ 是外延的：$p \\in Q_{k}$ 是否成立仅取决于函数 $\\varphi^{U}_{p}$，因为它询问的是由 $p$ 计算的函数是否有一个长度至多为 $k$ 的（在 $U$ 下的）描述。如果 $\\varphi^{U}_{p} = f$，那么 $p \\in Q_{k}$ 当且仅当 $f$ 的 $U$-Kolmogorov 复杂度（相对于 $U$ 的描述复杂度）至多为 $k$。这是部分可计算函数的一个非平凡性质：有些函数有短程序，有些则没有。因此，根据 Rice 定理，该指标集是不可判定的。所提出的判定方法是无效的：部分可计算函数 $\\varphi^{U}_{q} = \\varphi^{U}_{p}$ 的相等性是不可判定的；在“所有输入”上进行有限模拟无法证明相等，因为发散和不一致可能在任意远的地方出现。因此，与声称的相反，$Q_{k}$ 是不可判定的，并且 Rice 定理确实适用。结论：不正确。\n\n选项 C：该陈述声称固定编码（和 $U$）会使 $U$-程序的每个非平凡性质都可判定。这是错误的。对于固定的 $U$，许多非平凡的外延性质仍然是不可判定的；例如，停机问题集 $K = \\{\\,p : \\exists x \\text{ 使得 } U(p,x) \\downarrow\\,\\}$ 和全函数集 $T = \\{\\,p : \\forall x, U(p,x) \\downarrow\\,\\}$ 都是经典的不可判定集。固定 $U$ 已经是 Rice 定理通常表述的一部分；该定理是对一个固定的枚举进行量化的。因此，该选项中给出的论点误解了 Rice 定理。结论：不正确。\n\n选项 D：定义 $R_{s} = \\{\\,p : p \\text{ 包含 } s \\text{ 作为连续子串}\\,\\}$。可判定性：给定 $p$ 和固定的 $s$，可以在线性时间内扫描 $p$ 寻找 $s$；因此 $R_{s}$ 是可计算的。Rice 定理的不适用性：$R_{s}$ 是纯粹语法的，因此是内涵的。它在关系 $p \\sim q \\iff \\varphi^{U}_{p} = \\varphi^{U}_{q}$ 下不保持不变，因为人们通常可以修改程序的编码，在保持其计算的函数的同时，改变特定子串 $s$ 的存在与否。因此，$R_{s}$ 不是部分可计算函数的外延性质，所以 Rice 定理不适用。结论：正确。\n\n选项 E：集合 $T = \\{\\,p : \\varphi^{U}_{p} \\text{ 是全函数}\\,\\}$ 被断言为可通过交叉运行法判定。这是不正确的。全函数问题是一个非平凡外延性质的典型例子；根据 Rice 定理，它是不可判定的。交叉运行法允许在特殊情况下半判定全函数性的补集，或半判定其他性质，但没有算法可以对所有的 $p$ 判定全函数性。此外，其理由“Rice 定理不适用，因为当 $U$ 固定时全函数性是语法的”是错误的：全函数性是函数 $\\varphi^{U}_{p}$ 的一个外延的、语义的性质，而这正是 Rice 定理所针对的那类性质。结论：不正确。\n\n综上所述，正确展示了内涵性质如何规避 Rice 定理，并正确说明了 Rice 定理为何不适用的选项是选项 A 和选项 D。", "answer": "$$\\boxed{AD}$$", "id": "2988385"}, {"introduction": "递归定理揭示了程序可以引用自身代码，这个概念似乎充满了悖论，仿佛程序能够“预知”自己的行为。这个思想实验将引导您揭开自引用的神秘面紗，展示它并非通过解决停机问题，而是通过巧妙的代码构造技巧实现的。解决这个问题将加深您对可计算性理论中构造性证明的理解，并帮助您调和强大的自引用能力与停机问题等基本限制之间的关系。[@problem_id:2988379]", "problem": "设 $\\{ \\varphi_{e} \\}_{e \\in \\mathbb{N}}$ 是一个由图灵机计算的部分可计算函数的标准可接受枚举，并设 $U$ 是一个通用部分可计算函数（通用图灵机），满足\n$$\nU(\\langle e,x \\rangle) \\simeq \\varphi_{e}(x),\n$$\n其中 $\\langle \\cdot,\\cdot \\rangle$ 是一个固定的有效配对函数，且 $\\simeq$ 表示两边在完全相同的输入上有定义，并在有定义时值相等。令停机集为\n$$\nK \\;=\\; \\{ \\langle e,x \\rangle \\in \\mathbb{N} : \\varphi_{e}(x) \\downarrow \\},\n$$\n已知该集合是不可判定的。另请回顾 Kleene 递归定理：对于每个全可计算函数 $f:\\mathbb{N} \\to \\mathbb{N}$，存在一个 $e \\in \\mathbb{N}$ 使得\n$$\n\\varphi_{e} \\;=\\; \\varphi_{f(e)}.\n$$\n在递归定理的证明中，自引用仅通过有效一致参数化（$s$-$m$-$n$ 定理）和通用机 $U$ 的存在性来实现，而不借助于任何关于 $K$ 的判定过程。\n\n以下哪些陈述正确地解释了为什么递归定理与停机问题的不可判定性不矛盾，以及自引用是如何在不判定停机的情况下实现的？请选择所有适用的选项。\n\nA. 递归定理使用通用函数 $U$ 和有效参数化来构建包含自身代码副本作为数据的指标；这种“引用”是通过对代码的全可计算变换实现的，并且不包含任何判定任意计算 $\\varphi_{e}(x)$ 是否停机的过程。因此，它没有给出判定 $K$ 的算法。\n\nB. 因为递归定理保证了对于任何全可计算函数 $f$，都存在一个指标 $e$ 使得 $\\varphi_{e}=\\varphi_{f(e)}$，所以人们可以通过检查 $\\varphi_{f(e)}(e)$ 是否停机来判定 $\\varphi_{e}(e)$ 是否停机；因此停机问题变得可判定，这表明递归定理是非构造性的，并且其表述不可能正确。\n\nC. 获得自引用的唯一方法是在所有输入上运行 $U$，并等待它通过检测何时 $\\varphi_{e}=\\varphi_{f(e)}$ 来发现自己的指标 $e$；这个搜索过程隐含地需要判定停机，因此递归定理是通过假设存在一个 $K$ 的预言机才与不可判定性相协调的。\n\nD. 递归定理提供的不动点 $e$ 可能计算的是一个在许多输入上发散的部分函数，并且定理的证明从不需要测试任意的 $x$ 上 $\\varphi_{e}(x)$ 是否停机；构造过程的任何一步都没有提供能够判定 $K$ 中成员身份的信息。\n\nE. 根据 Rice 定理，部分可计算函数的任何非平凡语义属性都是不可判定的，包括指标集 $\\{e : \\varphi_{e}=\\varphi_{f(e)}\\}$（当它既非空也非全集时）。递归定理断言对于每个全可计算函数 $f$ 都至少存在一个这样的不動点 $e$，但没有提供一个算法来识别对于给定的 $e$ 是否有 $\\varphi_{e}=\\varphi_{f(e)}$。因此，它不产生一个对 $K$ 的判定过程，也不与不可判定性矛盾。", "solution": "用户想要对 Kleene 递归定理与停机问题的不可判定性之间的关系进行批判性分析。\n\n首先，我将验证问题陈述。\n\n### 第1步：提取已知条件\n- 部分可计算函数的可接受枚举：$\\{ \\varphi_{e} \\}_{e \\in \\mathbb{N}}$。\n- 一个通用部分可计算函数 $U$ 满足 $U(\\langle e,x \\rangle) \\simeq \\varphi_{e}(x)$。\n- 一个有效配对函数 $\\langle \\cdot,\\cdot \\rangle$。\n- 符号 $\\simeq$ 表示部分函数的相等性（定义域完全相同且在该定义域上值相等）。\n- 停机集：$K = \\{ \\langle e,x \\rangle \\in \\mathbb{N} : \\varphi_{e}(x) \\downarrow \\}$，其中 $\\downarrow$ 表示“停机”。\n- 一个已陈述的事实：停机集 $K$ 是不可判定的。\n- Kleene 递归定理：对于每个全可计算函数 $f:\\mathbb{N} \\to \\mathbb{N}$，存在一个指标 $e \\in \\mathbb{N}$ 使得 $\\varphi_{e} = \\varphi_{f(e)}$。\n- 关于递归定理证明的一个前提：它使用了 S-m-n 定理（有效一致参数化）和一个通用机 $U$，但没有使用任何关于 $K$ 的判定过程。\n- 问题是要确定哪些陈述正确地解释了为什么递归定理与 $K$ 的不可判定性不矛盾，以及它如何在不判定停机的情况下实现自引用。\n\n### 第2步：使用提取的已知条件进行验证\n- **科学基础（批判性）：** 问题植根于基础可计算性理论。所有定义（可接受枚举、通用函数、停机集）和定理（Kleene 递归定理、$K$ 的不可判定性）都是标准的且陈述正确。\n- **良构性：** 问题要求对可计算性理论中一个众所周知的概念点进行解释。这种明显张力的解决方案是一个标准的教学主题，并且在理论中存在明确的解释。\n- **客观性（批判性）：** 问题以精确、形式化的语言陈述，没有歧义或主观内容。\n\n问题陈述完全有效。这是数理逻辑和理论计算机科学中的一个标准问题。未检测到任何缺陷。\n\n### 第3步：结论与行动\n问题是有效的。我将进行完整的推导和分析。\n\n### 基于原理的推导\n\n问题的核心在于 Kleene 递归定理的构造性证明。设 $f:\\mathbb{N} \\to \\mathbb{N}$ 为任意全可计算函数。我们想要找到一个指标 $e$ 使得 $\\varphi_{e} = \\varphi_{f(e)}$。\n\n标准证明如下：\n1.  定义一个部分函数 $\\psi(x, y)$ 为 $\\psi(x, y) \\simeq \\varphi_{f(\\varphi_x(x))}(y)$。这个函数是部分可计算的。一个计算 $\\psi$ 的机器会首先计算 $\\varphi_x(x)$。如果它停机并输出 $z$，则接着计算 $f(z)$（由于 $f$ 是全函数，保证停机），如果结果是 $w$，它最终计算 $\\varphi_w(y)$。如果 $\\varphi_x(x)$ 发散，那么 $\\psi(x, y)$ 也发散。这个定义不需要一个判定器来判断 $\\varphi_x(x)$ 是否停机；它只是将 $\\varphi_x(x)$ 的潜在发散性构建到 $\\psi$ 的定义中。\n\n2.  根据 S-m-n 定理，存在一个全可计算函数 $s(x)$，它对于任何指标 $x$，都生成函数 $\\lambda y . \\psi(x,y)$ 的一个指标 $s(x)$。即，对于所有的 $x, y$ 都有 $\\varphi_{s(x)}(y) \\simeq \\psi(x, y)$。代入 $\\psi$ 的定义，我们得到 $\\varphi_{s(x)}(y) \\simeq \\varphi_{f(\\varphi_x(x))}(y)$。S-m-n 定理提供了一种纯算法的方式来操作程序指标——它是一种句法转换。\n\n3.  因为 $s$ 是一个全可计算函数，它至少有一个指标，比如说 $c$。所以，对于所有 $x$ 都有 $s(x) = \\varphi_c(x)$。\n\n4.  现在，我们将函数 $s$ 应用于它自己的指标 $c$。令 $e = s(c)$。由于 $s$ 是一个全函数，计算 $\\varphi_c(c)$ 会停机，并且 $e$ 是一个良定义的整数。\n\n5.  这个指标 $e$ 就是所期望的不动点。我们可以验证这一点：\n    - 根据 $e$ 的定义，我们有 $\\varphi_e(y) = \\varphi_{s(c)}(y)$。\n    - 从第 2 步，设 $x=c$，我们有 $\\varphi_{s(c)}(y) \\simeq \\varphi_{f(\\varphi_c(c))}(y)$。\n    - 从第 4 步，我们有 $\\varphi_c(c) = s(c) = e$。\n    - 将此代入上一行得到 $\\varphi_e(y) \\simeq \\varphi_{f(e)}(y)$。\n    - 这对所有 $y$ 都成立，所以 $\\varphi_e = \\varphi_{f(e)}$。\n\n这个证明构造性地提供了指标 $e$。 “自引用”是通过步骤 $e = s(c) = \\varphi_c(c)$ 实现的，其中用于计算 $s$ 的程序被应用于其自身的描述 $c$ 来产生 $e$。然后，可以认为用于计算 $e$ 的程序包含了它自己的指标。\n\n关键的观察是，这整个构造过程只涉及通过可计算函数（$f$，$s$，以及 S-m-n 定理和通用机中隐含的函数）对指标（句法对象）的操作。在任何时候，构造过程都不需要测试语义属性，例如“这个程序是否停机？”。这个构造之所以有效，正是因为它不试图分析它正在构建的程序的行为；它只是构建它们。这就是为什么它没有提供一个工具来判定停机问题 $K$。\n\n### 逐项分析\n\n**A. 递归定理使用通用函数 $U$ 和有效参数化来构建包含自身代码副本作为数据的指标；这种“引用”是通过对代码的全可计算变换实现的，并且不包含任何判定任意计算 $\\varphi_{e}(x)$ 是否停机的过程。因此，它没有给出判定 $K$ 的算法。**\n该陈述准确地描述了递归定理证明的机制。$e = s(c)$ 的构造是一种让程序获取自身指标的方法，一种“引用”的形式。这是通过“有效参数化”（S-m-n 定理）完成的，并涉及“对代码的全可计算变换”（函数 $s$）。它正确地指出这些是句法操作，不涉及任何停机判定过程。因此，它没有提供判定 $K$ 的方法的结论是正确的。该陈述提供了一个完整而准确的解释。\n**结论：正确。**\n\n**B. 因为递归定理保证了对于任何全可计算函数 $f$，都存在一个指标 $e$ 使得 $\\varphi_{e}=\\varphi_{f(e)}$，所以人们可以通过检查 $\\varphi_{f(e)}(e)$ 是否停机来判定 $\\varphi_{e}(e)$ 是否停机；因此停机问题变得可判定，这表明递归定理是非构造性的，并且其表述不可能正确。**\n这个论证是错误的。知道 $\\varphi_e(e)$ 的停机等价于 $\\varphi_{f(e)}(e)$ 的停机，仅仅是将停机问题的一个实例归约到另一个实例。它没有为任何一个提供解决方案。这是一个循环论证，而不是一个判定过程。停机问题变得可判定的结论是错误的，因此随后的递归定理不正确的说法也是错误的。\n**结论：不正确。**\n\n**C. 获得自引用的唯一方法是在所有输入上运行 $U$，并等待它通过检测何时 $\\varphi_{e}=\\varphi_{f(e)}$ 来发现自己的指标 $e$；这个搜索过程隐含地需要判定停机，因此递归定理是通过假设存在一个 $K$ 的预言机才与不可判定性相协调的。**\n这描述了一种对不动点的暴力搜索，而不是递归定理的证明方式。标准证明如上所述，是一个直接的构造。此外，暴力搜索以检查语义属性 $\\varphi_e = \\varphi_{f(e)}$ 将需要一个至少与停机预言机一样强大的过程（实际上更强大）。前提（“唯一方法是...”）是错误的，结论（“假设存在一个 $K$ 的预言机”）也是错误的。递归定理在标准可计算性理论中成立，无需任何此类假设。\n**结论：不正确。**\n\n**D. 递归定理提供的不动点 $e$ 可能计算的是一个在许多输入上发散的部分函数，并且定理的证明从不需要测试任意的 $x$ 上 $\\varphi_{e}(x)$ 是否停机；构造过程的任何一步都没有提供能够判定 $K$ 中成员身份的信息。**\n这个陈述正确地指出了两个关键事实。首先，该定理不保证得到的函数 $\\varphi_e$ 是全函数，因此它没有消除不终止的问题。其次，它正确地陈述了为什么与 $K$ 的不可判定性没有矛盾的核心原因：证明是纯粹构造性的，并且“从不需要测试...是否停机”。它操作程序描述而无需了解它们的任何行为。这直接解释了为什么该定理的证明没有提供一个 $K$ 的判定器。\n**结论：正确。**\n\n**E. 根据 Rice 定理，部分可计算函数的任何非平凡语义属性都是不可判定的，包括指标集 $\\{e : \\varphi_{e}=\\varphi_{f(e)}\\}$（当它既非空也非全集时）。递归定理断言对于每个全可计算函数 $f$ 都至少存在一个这样的不动点 $e$，但没有提供一个算法来识别对于给定的 $e$ 是否有 $\\varphi_{e}=\\varphi_{f(e)}$。因此，它不产生一个对 $K$ 的判定过程，也不与不可判定性矛盾。**\n这个陈述提出了一个正确且深刻的观点。不动点指标集 $S_f = \\{e \\mid \\varphi_e = \\varphi_{f(e)}\\}$ 是一个语义属性。对于大多数 $f$，这个集合不是空的（根据递归定理）也不是全集 $\\mathbb{N}$，所以它是一个非平凡属性。根据 Rice 定理，$S_f$ 是不可判定的。递归定理给出了一个构造性方法来找到这个不可判定集合中的*一个*元素，但它没有提供一个方法来*判定*集合的成员资格。这种在产生实例和识别属性之间的区别是根本性的。这解释了为什么这个定理，尽管其功能强大，却存在于一个不可判定性普遍存在的框架内，并且不与之矛盾。这是对该理论一致性的一个有效解释。\n**结论：正确。**", "answer": "$$\\boxed{ADE}$$", "id": "2988379"}]}