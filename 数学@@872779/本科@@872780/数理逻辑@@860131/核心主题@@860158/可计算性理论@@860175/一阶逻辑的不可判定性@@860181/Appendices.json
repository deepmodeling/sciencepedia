{"hands_on_practices": [{"introduction": "本练习是证明一阶逻辑不可判定性的核心。通过学习如何在一个静态的一阶逻辑框架内表示图灵机计算的动态步骤，我们可以将无法解决的停机问题直接转化为一个关于逻辑可满足性的问题。这个练习将搭建起计算与逻辑之间的桥梁，让你亲手构造证明的关键部分 [@problem_id:3059496]。", "problem": "考虑一台确定性单带图灵机 (TM) $\\mathcal{M} = (Q, \\Gamma, \\sqcup, \\delta, q_0, q_{\\mathrm{halt}})$，其中 $Q$ 是一个有限的状态集，其大小为 $|Q| = q$；$\\Gamma$ 是一个有限的带字母表，其大小为 $|\\Gamma| = s$，包含一个指定的空白符号 $\\sqcup$；$\\delta$ 是转移函数；$q_0 \\in Q$ 是起始状态；$q_{\\mathrm{halt}} \\in Q$ 是停机状态。在具有单类论域的一阶逻辑 (FOL) 中进行工作。您的目标是设计一个一阶署名，并解释它如何以一种适合将停机问题归约到一阶逻辑可满足性的方式，来编码 $\\mathcal{M}$ 在离散时间步上的计算。这一归约是 Church 定理（一阶逻辑有效性的不可判定性）的基础。\n\n仅从图灵机和一阶逻辑的核心定义出发，构造一个包含以下内容的一阶署名 $\\Sigma$：\n\n- 一个二元关系符号 $T(t, t')$，意在表示时间步上的后继关系（因此 $T(t, t')$ 意味着 $t'$ 是紧跟在 $t$ 之后的下一个时间）。\n- 一个二元谓词符号 $H(t, c)$，用于指示磁带上的读写头位置（因此 $H(t, c)$ 意味着在时间 $t$，读写头扫描单元格 $c$）。\n- 对于每个带符号 $a \\in \\Gamma$，一个二元谓词符号 $S_a(t, c)$，用于指示磁带内容（因此 $S_a(t, c)$ 意味着在时间 $t$，单元格 $c$ 承载符号 $a$）。\n- 对于每个机器状态 $p \\in Q$，一个一元谓词符号 $Q_p(t)$，用于指示状态（因此 $Q_p(t)$ 意味着在时间 $t$，机器处于状态 $p$）。\n\n为了充分编码读写头的移动和磁带的结构，请包含最少的必要附加非逻辑符号，以便您的公理可以表达读写头在相邻单元格之间的左右移动，并确定初始配置。您必须确保您的设计在科学上是合理的，并且足以描述一个离散的时空计算。假设该署名在其他方面尽可能精简，并避免添加冗余符号。\n\n给出一个连贯的描述，说明该署名如何支持强制执行以下内容的公理：\n\n- 在每个时间 $t$，恰好有一个状态成立，恰好有一个读写头位置成立，并且每个单元格恰好承载一个带符号。\n- 二元关系 $T$ 是时间点上的离散后继关系。\n- 所选的关于单元格的磁带关系是单元格上的离散后继关系，从而能够实现左右移动。\n- 转移子句忠实地反映了 $\\delta$，以便从时间 $t$ 的一个格局出发，在满足 $T(t, t')$ 的时间 $t'$，磁带内容、读写头位置和机器状态完全按照 $\\delta$ 的规定演变。\n\n解释这样的编码如何产生一个从 $(\\mathcal{M}, w)$（其中输入词为 $w \\in \\Gamma^{*}$）到某个一阶逻辑句子的有效映射，该句子的可满足性捕获了 $\\mathcal{M}$ 是否在 $w$ 上停机，从而建立一个从停机问题到一阶逻辑可满足性的归约。\n\n最后，以闭合形式计算您的署名 $\\Sigma$ 中不同非逻辑符号的最小总数，作为 $q$ 和 $s$ 的函数。这里的“非逻辑符号”包括所有常量符号、函数符号和谓词/关系符号；等号被视为逻辑符号并被排除在外。您的最终答案必须是一个关于 $q$ 和 $s$ 的单一闭合形式解析表达式。", "solution": "所提出的问题是数理逻辑和可计算性理论中的一个标准的、典型的练习。它要求构造一个一阶署名来编码图灵机的计算，解释该编码的工作原理，并统计所涉及的符号数量。这是通过从停机问题进行归约来证明一阶逻辑不可判定性（Church 定理）的核心部分。该问题具有科学依据，提法恰当，客观且完全明确。它没有任何缺陷。因此，我们可以直接进入解决方案。\n\n目标是构造一个一阶署名 $\\Sigma$ 和一组公理，来描述给定确定性单带图灵机 $\\mathcal{M} = (Q, \\Gamma, \\sqcup, \\delta, q_0, q_{\\mathrm{halt}})$ 的计算，其中 $|Q| = q$ 且 $|\\Gamma| = s$。该编码必须使得“$\\mathcal{M}$ 是否在给定的输入词 $w$ 上停机”这一问题等价于某个特定一阶句子的可满足性。\n\n首先，我们设计署名 $\\Sigma$。我们预期解释的论域将是一个表示离散时间步和离散磁带单元格位置的元素集合。问题规定了一组特定的非逻辑符号，我们将添加满足要求所需的最少数量的符号。\n\n署名 $\\Sigma$ 由以下非逻辑符号组成：\n\n1.  **谓词符号（关系）：**\n    *   $Q_p(t)$：一组 $q$ 个一元谓词，每个状态 $p \\in Q$ 对应一个。$Q_p(t)$ 意为当且仅当机器在时间 $t$ 处于状态 $p$ 时为真。\n    *   $S_a(t, c)$：一组 $s$ 个二元谓词，每个带符号 $a \\in \\Gamma$ 对应一个。$S_a(t, c)$ 意为当且仅当磁带单元格 $c$ 在时间 $t$ 包含符号 $a$ 时为真。\n    *   $H(t, c)$：一个二元谓词。$H(t, c)$ 意为当且仅当机器读写头在时间 $t$ 扫描单元格 $c$ 时为真。\n    *   $T(t, t')$：一个二元谓词。$T(t, t')$ 意为当且仅当 $t'$ 是紧跟在时间 $t$ 之后的下一个时间步时为真。\n    *   $C(c, c')$：一个二元谓词。这是表达磁带单元格之间空间关系所需的最小补充。$C(c, c')$ 意为当且仅当单元格 $c'$ 紧邻单元格 $c$ 的右侧时为真。这单个关系足以描述左右移动，因为向 $c$ 的左侧移动就是移动到满足 $C(c', c)$ 的单元格 $c'$。\n\n2.  **常量符号：**\n    *   $t_0$：一个常量符号，表示初始时间步，即时间 $0$。\n    *   $c_0$：一个常量符号，表示初始磁带单元格，即单元格 $0$，读写头从这里开始。\n    这些是通过提供时间和空间原点来“确定初始配置”所需的最小补充。\n\n3.  **函数符号：**\n    *   无。可以构造一个不含函数符号的最小署名，这遵循了问题中包含 $T(t, t')$ 所建议的关系式风格。\n\n署名 $\\Sigma$ 中这些不同非逻辑符号的总数是谓词符号和常量符号数量的总和。\n谓词符号数量 = $q$ (状态) $+ s$ (字母表) $+ 1$ (读写头) $+ 1$ (时间) $+ 1$ (单元格) $= q + s + 3$。\n常量符号数量 = $1$ (初始时间) $+ 1$ (初始单元格) $= 2$。\n非逻辑符号总数为 $(q + s + 3) + 2 = q + s + 5$。\n\n接下来，我们描述该署名如何支持一组公理，这些公理共同构成一个句子 $\\Phi_{\\mathcal{M}, w}$。该句子是按目的分组的公式的合取。该句子的一个模型将对应于 $\\mathcal{M}$ 在输入 $w$ 上的一个有效的、停机的计算历史。\n\n1.  **结构公理：** 这些公理约束了对 $T$ 和 $C$ 的解释，以表示离散的后继关系，并约束论域表示一组时间点和磁带单元格。\n    *   **时间结构：** 时间从 $t_0$ 开始并线性前进。\n        *   $\\forall t \\exists t' \\, T(t, t')$ (每个时间都有一个后继)。\n        *   $\\forall t, t'_1, t'_2 \\, (T(t, t'_1) \\land T(t, t'_2) \\implies t'_1 = t'_2)$ (后继是唯一的)。\n        *   $\\forall t \\, \\neg T(t, t_0)$ ($t_0$ 是第一个时间步)。\n    *   **磁带结构：** 磁带是一个双向无限的离散单元格序列。\n        *   $\\forall c \\exists c' \\, C(c, c')$ (每个单元格都有一个右邻居)。\n        *   $\\forall c, c'_1, c'_2 \\, (C(c, c'_1) \\land C(c, c'_2) \\implies c'_1 = c'_2)$ (右邻居是唯一的)。\n        *   $\\forall c' \\exists c \\, C(c, c')$ (每个单元格都有一个左邻居)。\n        *   $\\forall c', c_1, c_2 \\, (C(c_1, c') \\land C(c_2, c') \\implies c_1 = c_2)$ (左邻居是唯一的)。\n\n2.  **唯一性公理：** 这些公理确保在任何给定时间，机器的格局都是良定义的。\n    *   **唯一状态：** $\\forall t \\, \\left( (\\bigvee_{p \\in Q} Q_p(t)) \\land (\\bigwedge_{p_1 \\neq p_2 \\in Q} \\neg(Q_{p_1}(t) \\land Q_{p_2}(t))) \\right)$。\n    *   **唯一读写头位置：** $\\forall t \\, ((\\exists c \\, H(t, c)) \\land (\\forall c_1, c_2 \\, (H(t, c_1) \\land H(t, c_2) \\implies c_1 = c_2)))$。\n    *   **每个单元格唯一符号：** $\\forall t, c \\, \\left( (\\bigvee_{a \\in \\Gamma} S_a(t, c)) \\land (\\bigwedge_{a_1 \\neq a_2 \\in \\Gamma} \\neg(S_{a_1}(t, c) \\land S_{a_2}(t, c))) \\right)$。\n\n3.  **初始配置公理：** 设输入词为 $w = w_1 w_2 \\dots w_m \\in \\Gamma^*$。\n    *   **初始状态：** $Q_{q_0}(t_0)$。\n    *   **初始读写头位置：** $H(t_0, c_0)$。\n    *   **初始磁带内容：** 我们必须断言输入词 $w$ 从 $c_0$ 开始写在磁带上，并且所有其他单元格都是空白的 ($\\sqcup$)。这需要定义相对于 $c_0$ 的单元格位置 $c_1, \\dots, c_{m-1}$。\n        *   $\\exists c_1, \\dots, c_{m-1} \\left(C(c_0, c_1) \\land C(c_1, c_2) \\land \\dots \\land C(c_{m-2}, c_{m-1}) \\land S_{w_1}(t_0, c_0) \\land \\dots \\land S_{w_m}(t_0, c_{m-1}) \\land \\forall c' ((\\bigwedge_{i=0}^{m-1} c' \\neq c_i) \\implies S_\\sqcup(t_0, c')) \\right)$。\n\n4.  **转移公理：** 这些公理编码了转移函数 $\\delta$。对于 $\\delta$ 中的每条规则，我们添加一个相应的公理。\n    *   **状态和磁带变化：** 对于每个转移 $\\delta(p, a) = (p', a', d)$，其中 $p \\in Q \\setminus \\{q_{\\mathrm{halt}}\\}$，$a \\in \\Gamma$，$d$ 是读写头移动方向（L、R 或 N）：\n        *   如果 $d = \\text{Right}$：$\\forall t, t', c, c' \\Big[ \\big( T(t, t') \\land Q_p(t) \\land H(t, c) \\land S_a(t, c) \\land C(c, c') \\big) \\implies \\big( Q_{p'}(t') \\land S_{a'}(t', c) \\land H(t', c') \\big) \\Big]$。\n        *   如果 $d = \\text{Left}$：$\\forall t, t', c, c'' \\Big[ \\big( T(t, t') \\land Q_p(t) \\land H(t, c) \\land S_a(t, c) \\land C(c'', c) \\big) \\implies \\big( Q_{p'}(t') \\land S_{a'}(t', c) \\land H(t', c'') \\big) \\Big]$。\n        *   如果 $d = \\text{No-move}$：$\\forall t, t', c \\Big[ \\big( T(t, t') \\land Q_p(t) \\land H(t, c) \\land S_a(t, c) \\big) \\implies \\big( Q_{p'}(t') \\land S_{a'}(t', c) \\land H(t', c) \\big) \\Big]$。\n    *   **框架公理（惯性）：** 不在读写头下的单元格的符号不会改变。\n        *   $\\forall t, t', c_{head}, c_{other}, a \\Big[ \\big( T(t, t') \\land H(t, c_{head}) \\land c_{head} \\neq c_{other} \\land S_a(t, c_{other}) \\big) \\implies S_a(t', c_{other}) \\Big]$。\n\n最后，为了解决停机问题，我们需要询问机器是否会到达停机状态 $q_{\\mathrm{halt}}$。这被公式 $\\exists t \\, Q_{q_{\\mathrm{halt}}}(t)$ 所捕获。\n\n归约过程如下：给定 $(\\mathcal{M}, w)$，我们通过将上述所有公理（结构、唯一性、初始、转移）与停机条件进行合取，构造一个单一的一阶逻辑句子 $\\Phi_{\\mathcal{M}, w}$：\n$\\Phi_{\\mathcal{M}, w} \\equiv (\\text{公理}_{\\text{结构}}) \\land (\\text{公理}_{\\text{唯一性}}) \\land (\\text{公理}_{\\text{初始}}) \\land (\\text{公理}_{\\text{转移}}) \\land (\\exists t \\, Q_{q_{\\mathrm{halt}}}(t))$。\n\n从 $\\mathcal{M}$ 和 $w$ 构造 $\\Phi_{\\mathcal{M}, w}$ 是一个有效的、算法化的过程。我们建立归约的正确性：\n*   **($\\Rightarrow$) 如果 $\\mathcal{M}$ 在 $w$ 上停机**，则存在一个有限的计算历史，即一个格局序列 $C_0, C_1, \\dots, C_N$，其中 $C_0$ 是输入 $w$ 的初始格局，$C_N$ 是一个处于状态 $q_{\\mathrm{halt}}$ 的格局。这个历史可以用来为 $\\Phi_{\\mathcal{M}, w}$ 定义一个模型。论域可以是，例如，整数集合。谓词 $Q_p, S_a, H$ 的解释根据计算历史一步步定义。根据构造，这个解释满足所有公理，包括最后一个，因为在时间 $N$，机器处于状态 $q_{\\mathrm{halt}}$。因此，$\\Phi_{\\mathcal{M}, w}$ 是可满足的。\n*   **($\\Leftarrow$) 如果 $\\Phi_{\\mathcal{M}, w}$ 是可满足的**，那么存在一个模型 $\\mathfrak{A}$ 使得该句子为真。这些公理强制该模型描述一个 $\\mathcal{M}$ 在输入 $w$ 上开始的有效计算历史。子句 $\\exists t \\, Q_{q_{\\mathrm{halt}}}(t)$ 在 $\\mathfrak{A}$ 中为真，意味着在这个计算历史中，机器在某个时间到达了状态 $q_{\\mathrm{halt}}$。因此，$\\mathcal{M}$ 在 $w$ 上停机。\n\n这建立了一个从停机问题到一阶逻辑可满足性问题的多一归约。由于停机问题是不可判定的，因此一阶逻辑可满足性也是不可判定的。由于有效性与可满足性是可相互定义的（$\\phi$ 是有效的当且仅当 $\\neg\\phi$ 是不可满足的），可满足性的不可判定性直接意味着有效性的不可判定性，这就是 Church 定理。\n\n最后的任务是计算我们最小署名 $\\Sigma$ 中非逻辑符号的总数。如前所述，这是 $q+s+3$ 个谓词符号和 $2$ 个常量符号的总和。", "answer": "$$\n\\boxed{q+s+5}\n$$", "id": "3059496"}, {"introduction": "在学习了如何编码计算之后，我们现在聚焦于一个关键组成部分：时间的表示。这个问题要求你公理化离散时间步长的结构 [@problem_id:3059502]。通过这个练习，你将发现一阶逻辑的一个深刻限制——它无法唯一地定义标准的自然数集——并理解为什么我们的计算公理会允许“非标准”时间模型的存在。", "problem": "考虑一阶逻辑 (FOL) 标识 $\\mathcal{L}=\\{, S, 0\\}$，其中 $$ 和 $S$ 是二元关系符号，$0$ 是一个常量符号。在许多用于证明一阶有效性不可判定性（丘奇定理）的标准归约中，人们通过使用带有直接后继关系的时间步的离散线性序，将图灵机计算编码到模型内部。你的任务是：\n\n1. 编写一个有限的 $\\mathcal{L}$-句子集合，以在任何 $\\mathcal{L}$-结构 $\\mathcal{M}$ 中强制执行以下性质：\n   - $$ 是一个以 $0$ 为最小元的严格线性序。\n   - $S$ 与由 $$ 导出的直接后继关系一致（即，$S(x,y)$ 成立当且仅当 $y$ 是大于 $x$ 的 $$-最小元）。\n   - 每个元素都有一个 $S$-后继（因此没有最后的时间步）。\n   - 每个非零元素都有一个 $S$-前驱（在所有非零元素的左侧具有离散性）。\n   这些公理应确保时间步以一种离散、线性的方式索引，适合于编码连续的计算阶段。\n\n2. 仅使用你的公理所强制的性质以及严格线性序和离散性的基本定义，确定满足你所有公理的、基数为 $n=23$ 的非同构 $\\mathcal{L}$-结构的数量。你的最终答案应为一个整数。无需四舍五入。", "solution": "所陈述的问题是有效的。这是一个在数理逻辑和模型论领域内的良定问题，基于已建立的形式体系。它是客观、自洽的，并与用于不可判定性证明的逻辑基础直接相关。任务是构想一个一阶理论，然后分析其模型，这是逻辑学中的一个标准程序。\n\n问题分为两部分。首先，我们必须在语言 $\\mathcal{L}=\\{, S, 0\\}$ 中提供一个有限的一阶公理集合，用以刻画一个有最小元但无最大元的离散线性序。其次，我们必须确定这个理论具有特定有限基数的非同构模型的数量。\n\n**第 1 部分：公理化**\n\n我们将所需性质构想为一阶逻辑中的一个有限句子集合。\n\n1.  **严格线性序：** 关系 $$ 必须是反自反的、传递的和全序的。\n    *   反自反性: $\\forall x \\, \\neg(x  x)$\n    *   传递性: $\\forall x \\forall y \\forall z \\, ((x  y \\land y  z) \\to x  z)$\n    *   全序性: $\\forall x \\forall y \\, (x  y \\lor y  x \\lor x = y)$\n\n2.  **最小元：** 常量 $0$ 是序 $$ 下的最小元。\n    *   $\\forall x \\, (x=0 \\lor 0  x)$\n\n3.  **后继关系：** 关系 $S(x,y)$ 成立当且仅当 $y$ 是 $x$ 关于 $$ 的直接后继。这被定义为 $y$ 是严格大于 $x$ 的 $$-最小元。\n    *   $\\forall x \\forall y \\, (S(x,y) \\leftrightarrow (x  y \\land \\forall z \\, (x  z \\to (y  z \\lor y = z))))$\n    这条公理使得符号 $S$ 的解释依赖于 $$ 的解释。\n\n4.  **后继的存在性：** 每个元素都必须有一个 $S$-后继。这确保了序中没有最大元。\n    *   $\\forall x \\exists y \\, S(x,y)$\n\n5.  **非零元素前驱的存在性：** 除 $0$ 之外的每个元素都必须是某个其他元素的 $S$-后继。这确保了第一个元素之后没有“间隙”。\n    *   $\\forall x \\, (\\neg(x=0) \\to \\exists y \\, S(y,x))$\n\n这七个句子的集合构成了所需的有限 $\\mathcal{L}$-句子集合。我们称这个理论为 $T$。$T$ 的标准模型是自然数结构 $(\\mathbb{N}, , S, 0)$，其中 $$ 是通常的序，$S$ 是后继函数 $n \\mapsto n+1$，$0$ 是数字零。\n\n**第 2 部分：基数为 23 的非同构模型的数量**\n\n我们被要求找出论域基数为 $n=23$ 且满足第 1 部分定义的理论 $T$ 的所有公理的非同构 $\\mathcal{L}$-结构的数量。\n\n设 $\\mathcal{M}$ 是一个 $\\mathcal{L}$-结构，其论域（全集）为 $M$，使得 $|M|=23$。为了引出矛盾，我们假设 $\\mathcal{M}$ 是 $T$ 的一个模型。\n\n1.  关于 $$ 的公理强制 $(M, ^{\\mathcal{M}})$ 是一个严格线性序集。由于 $M$ 是有限的，基数为 23，它必须既有最小元，也有最大元。设元素排序为 $m_0 ^{\\mathcal{M}} m_1 ^{\\mathcal{M}} \\dots ^{\\mathcal{M}} m_{22}$。\n\n2.  关于常量 $0$ 的公理指出 $0^{\\mathcal{M}}$ 是最小元。因此，我们必须有 $0^{\\mathcal{M}} = m_0$。\n\n3.  $T$ 中的一条公理是后继存在公理：$\\forall x \\exists y \\, S(x,y)$。这表明论域 $M$ 中的每个元素都有一个 $S$-后继。\n\n4.  让我们考虑 $M$ 上序的最大元，即 $m_{22}$。根据后继存在公理，这个元素 $m_{22}$ 必须有一个 $S$-后继。设这个所谓的后继为 $y \\in M$。因此，$S(m_{22}, y)$ 必须在 $\\mathcal{M}$ 中成立。\n\n5.  从定义 $S$ 的公理可知，$S(m_{22}, y)$ 陈述等价于：\n    $$m_{22} ^{\\mathcal{M}} y \\land \\forall z \\in M \\, (m_{22} ^{\\mathcal{M}} z \\to (y ^{\\mathcal{M}} z \\lor y = z))$$\n\n6.  这个合取式的第一部分是 $m_{22} ^{\\mathcal{M}} y$。然而，$m_{22}$ 是有限线性序 $(M, ^{\\mathcal{M}})$ 的最大元。根据最大元的定义，在 $M$ 中不存在元素 $y$ 使得 $m_{22} ^{\\mathcal{M}} y$。\n\n7.  因此，对于 $M$ 中的每一个 $y$，谓词 $m_{22} ^{\\mathcal{M}} y$ 都为假。这意味着定义 $S(m_{22}, y)$ 的合取式对于 $M$ 中的每一个 $y$ 都为假。\n\n8.  这意味着在 $M$ 中不存在元素 $y$ 使得 $S(m_{22}, y)$ 成立。换句话说，陈述 $\\neg \\exists y \\, S(m_{22}, y)$ 在 $\\mathcal{M}$ 中为真。\n\n9.  这直接与后继存在公理 $\\forall x \\exists y \\, S(x,y)$ 相矛盾，而该公理在 $\\mathcal{M}$ 中必须为真。\n\n存在一个基数为 23 的 $T$ 的模型的假设导致了一个逻辑矛盾。公理集 $T$ 仅在无限论域中是可满足的。任何有限线性序都拥有一个最大元，而这个最大元不能有该理论所要求意义上的后继。\n\n因此，没有基数为 $n=23$ 的 $\\mathcal{L}$-结构可以满足所有指定的公理。这样的非同构结构的数量是零。", "answer": "$$\\boxed{0}$$", "id": "3059502"}, {"introduction": "一阶逻辑的不可判定性意味着不存在一个能判定任意句子是否有效的算法。本练习将让你亲身体验这一限制：你将分析一个简单的、可满足的句子，并看到一个标准的自动推理方法（归结）为何永不终止，因为它在徒劳地寻找一个不存在的矛盾 [@problem_id:3059505]。这具体地揭示了“半可判定性”在实践中的意义。", "problem": "设词汇表为 $\\{c, s, Q\\}$，其中 $c$ 是一个常量符号，$s$ 是一个一元函数符号，$Q$ 是一个一元谓词符号。考虑以下闭合一阶句子\n$$\\Phi \\;=\\; Q(c) \\,\\wedge\\, \\forall x\\,\\bigl(Q(x)\\rightarrow Q(s(x))\\bigr).$$\n整个过程完全在不带等词的经典一阶逻辑中进行。设子句形式指代通常的、保持可满足性的、无斯柯林化和前束范式的子句转换。设归结指代标准的子句二元归结规则，设公平策略为任何随时间推移不会永久忽略任何可归结对或其基实例的策略。\n\n任务：\n1. 从结构、解释和满足的基本定义出发，构造一个模型以证明 $\\Phi$ 是可满足的。\n2. 将 $\\Phi$ 转换为子句形式，并明确列出所得的子句集。\n3. 仅利用归结的可靠性和公平归结策略的定义，论证在第 2 部分的子句集上进行归结反驳搜索不会终止，从而说明一个与一阶可满足性不可判定性（丘奇定理）相符的具体限制。\n4. 在基项上定义项深度函数 $\\operatorname{depth}$ 为 $\\operatorname{depth}(c)=0$ 和 $\\operatorname{depth}(s(t))=1+\\operatorname{depth}(t)$。考虑一个广度优先、公平的饱和过程，该过程在第 2 部分的蕴涵形式子句和任何形如 $Q(t)$ 的可用单子句之间重复应用归结，以推导出新的单子句 $Q(s(t))$。设 $N(n)$ 表示在此过程中可推导出的、满足 $\\operatorname{depth}(t)\\le n$ 的形如 $Q(t)$ 的不同单子句的数量。计算 $N(n)$ 作为 $n$ 的函数的闭式表达式。\n\n你的最终答案必须是关于 $n$ 的单个闭式解析表达式。无需进行取整。", "solution": "该问题对一个一阶句子进行了多部分分析，重点关注其可满足性、到子句形式的转换、在归结下的行为，以及对一个特定推导过程的定量分析。该问题定义明确，并基于数理逻辑的原理。\n\n**第 1 部分：$\\Phi$ 的可满足性**\n为了证明句子 $\\Phi$ 是可满足的，我们必须构造一个使 $\\Phi$ 为真的结构（一个模型）。对于给定的词汇表 $\\{c, s, Q\\}$，一个结构 $\\mathcal{M}$ 由一个非空论域 $D$ 和一个解释函数 $I$ 组成。\n\n设论域 $D$ 为自然数集 $\\mathbb{N} = \\{0, 1, 2, \\dots\\}$。\n设解释函数 $I$ 定义如下：\n$1$. 常量符号 $c$ 的解释，记作 $c^{\\mathcal{M}}$，是数 $0 \\in \\mathbb{N}$。\n$2$. 一元函数符号 $s$ 的解释，记作 $s^{\\mathcal{M}}$，是 $\\mathbb{N}$ 上的后继函数。对于任何 $d \\in \\mathbb{N}$，$s^{\\mathcal{M}}(d) = d+1$。\n$3$. 一元谓词符号 $Q$ 的解释，记作 $Q^{\\mathcal{M}}$，是所有自然数的集合，即 $Q^{\\mathcal{M}} = \\mathbb{N}$。\n\n现在，我们验证句子 $\\Phi \\equiv Q(c) \\wedge \\forall x (Q(x) \\rightarrow Q(s(x)))$ 在此模型中为真，记作 $\\mathcal{M} \\models \\Phi$。一个合取式为真，当且仅当其所有合取项都为真。\n\n第一个合取项：$Q(c)$。\n$\\mathcal{M} \\models Q(c)$ 成立的条件是 $c^{\\mathcal{M}}$ 必须是集合 $Q^{\\mathcal{M}}$ 的一个元素。根据我们的解释，$c^{\\mathcal{M}} = 0$ 且 $Q^{\\mathcal{M}} = \\mathbb{N}$。陈述 $0 \\in \\mathbb{N}$ 是真的。因此，$\\mathcal{M} \\models Q(c)$。\n\n第二个合取项：$\\forall x (Q(x) \\rightarrow Q(s(x)))$。\n为使这个全称量化公式在 $\\mathcal{M}$ 中为真，对于 $x$ 到论域 $D = \\mathbb{N}$ 的每个元素的赋值，子公式 $Q(x) \\rightarrow Q(s(x))$ 都必须被满足。设 $d$ 是 $\\mathbb{N}$ 中的任意元素。我们必须检查蕴涵关系是否成立：若 $d \\in Q^{\\mathcal{M}}$，则 $s^{\\mathcal{M}}(d) \\in Q^{\\mathcal{M}}$。\n代入我们的解释，我们必须对任意 $d \\in \\mathbb{N}$ 检查：若 $d \\in \\mathbb{N}$，则 $d+1 \\in \\mathbb{N}$。\n对于任何自然数 $d$，前提 $d \\in \\mathbb{N}$ 根据定义为真。结论 $d+1 \\in \\mathbb{N}$ 也为真，因为自然数集在后继运算下是封闭的。因此，该蕴涵对所有 $d \\in \\mathbb{N}$ 均成立，我们有 $\\mathcal{M} \\models \\forall x (Q(x) \\rightarrow Q(s(x)))$。\n\n由于两个合取项在 $\\mathcal{M}$ 中都为真，句子 $\\Phi$ 在 $\\mathcal{M}$ 中为真。这个模型的存在证明了 $\\Phi$ 是可满足的。\n\n**第 2 部分：转换为子句形式**\n我们将句子 $\\Phi \\equiv Q(c) \\wedge \\forall x (Q(x) \\rightarrow Q(s(x)))$ 转换为其可满足性等价的子句形式。\n该句子是一个合取式，所以我们分别处理每个合取项。\n\n第一个合取项：$Q(c)$。\n这是一个原子公式，也是一个正文字。它直接构成单子句 $\\{Q(c)\\}$。\n\n第二个合取项：$\\forall x (Q(x) \\rightarrow Q(s(x)))$。\n我们应用标准算法：\n$1$. **消除蕴涵：** $A \\rightarrow B$ 的形式等价于 $\\neg A \\vee B$。这得到 $\\forall x (\\neg Q(x) \\vee Q(s(x)))$。\n$2$. **前束范式：** 量词已经位于最前面。\n$3$. **斯柯林化：** 没有存在量词，所以此步骤没有效果。\n$4$. **去掉全称量词：** 变量现在是隐式全称量化的。这得到 $\\neg Q(x) \\vee Q(s(x))$。\n$5$. **合取范式转换：** 该公式是文字的析取，已经处于合取范式中。这表示子句 $\\{\\neg Q(x), Q(s(x))\\}$。\n\n完整的子句集是各部分子句的合取：\n$C = \\{\\{Q(c)\\}, \\{\\neg Q(x), Q(s(x))\\}\\}$。\n\n**第 3 部分：归结的不终止性**\n我们论证在子句集 $C = \\{\\{Q(c)\\}, \\{\\neg Q(x), Q(s(x))\\}\\}$ 上进行归结反驳搜索不会终止。\n\n$1$. **可满足性：** 转换为子句形式保持了可满足性。由于我们在第 1 部分证明了 $\\Phi$ 是可满足的，其子句形式 $C$ 也必定是可满足的。\n$2$. **归结的可靠性：** 归结推理规则是可靠的。这意味着如果一个子句集 $C$ 是可满足的，就不可能从 $C$ 推导出空子句 $\\Box$。推导出 $\\Box$ 等价于证明不可满足性。\n$3$. **从可靠性得出的结论：** 根据第 1 点和第 2 点，由于 $C$ 是可满足的，空子句 $\\Box$ 不能从 $C$ 推导出来。当且仅当一个归结反驳搜索推导出 $\\Box$ 时，它才成功终止。因此，该搜索不能以成功反驳而终止。\n$4$. **公平性与无限生成：** 我们还必须表明搜索不会因穷尽所有可能的归结步骤而终止。一个公平的策略保证任何可归结的子句对最终都会被考虑。让我们考察从 $C$ 的推导过程。\n设 $C_1 = \\{Q(c)\\}$ 和 $C_2 = \\{\\neg Q(x), Q(s(x))\\}$。\n将 $C_1$ 与 $C_2$ 归结（通过合一 $Q(c)$ 和 $Q(x)$）产生一个新子句 $C_3 = \\{Q(s(c))\\}$。\n一个公平的策略现在必须考虑将 $C_3$ 与 $C_2$ 归结（通过合一 $Q(s(c))$ 和 $Q(x)$），这将产生一个新子句 $C_4 = \\{Q(s(s(c)))\\}$.\n这个过程可以无限持续下去。对于任何形如 $\\{Q(s^k(c))\\}$（其中 $k \\ge 0$）的已推导子句，与 $C_2$ 的归结会产生一个新的、不同的子句 $\\{Q(s^{k+1}(c))\\}$。\n由于在每个阶段都可以生成新的子句，可推导子句的集合是无限的。一个公平的策略永远不会穷尽所有可能的归结。\n\n因为空子句是不可推导的（根据可靠性），并且新子句是无限生成的，所以一个公平的归结搜索不会终止。这说明了一个案例，其中用于不可满足性的半判定过程（归结所提供的）对于一个可满足的公式正确地未能终止，这种行为与一阶逻辑的不可判定性（丘奇定理）相符。\n\n**第 4 部分：$N(n)$ 的闭式表达式**\n$N(n)$ 是满足 $\\operatorname{depth}(t) \\le n$ 的、可推导出的形如 $\\{Q(t)\\}$ 的不同单子句的数量。推导过程从子句集 $C$ 开始，并重复地将子句 $\\{\\neg Q(x), Q(s(x))\\}$ 与可用的单子句进行归结。\n\n初始单子句是 $\\{Q(c)\\}$。其项是 $t_0 = c$。根据定义，$\\operatorname{depth}(t_0) = 0$。\n第一个归结步骤使用 $\\{Q(c)\\}$ 推导出 $\\{Q(s(c))\\}$。其项是 $t_1 = s(c)$。它的深度是 $\\operatorname{depth}(t_1) = 1 + \\operatorname{depth}(c) = 1+0 = 1$。\n下一步使用 $\\{Q(s(c))\\}$ 推导出 $\\{Q(s(s(c)))\\}$。其项是 $t_2 = s(s(c))$。它的深度是 $\\operatorname{depth}(t_2) = 1 + \\operatorname{depth}(s(c)) = 1+1 = 2$。\n\n通过归纳法，该过程生成一个单子句序列 $\\{Q(s^k(c))\\}$，其中 $k = 0, 1, 2, \\dots$。第 $k$ 个这样的子句（从 $k=0$ 开始）中的项是 $t_k = s^k(c)$。\n项 $t_k$ 的深度由递归定义 $\\operatorname{depth}(s(t)) = 1 + \\operatorname{depth}(t)$ 计算得出：\n$\\operatorname{depth}(t_k) = \\operatorname{depth}(s^k(c)) = k$。\n\n所有可推导出的不同单子句的集合是 $\\{\\{Q(s^k(c))\\} \\mid k \\in \\mathbb{N}, k \\ge 0\\}$。\n我们需要计算这些子句中，有多少个子句的项 $t$ 满足 $\\operatorname{depth}(t) \\le n$。\n代入 $t = s^k(c)$ 和 $\\operatorname{depth}(t) = k$，条件变为 $k \\le n$。\n由于 $k$ 必须是一个非负整数，我们正在计算集合 $\\{0, 1, 2, \\dots, n\\}$ 中的整数数量。\n这个集合中的元素数量是 $(n - 0) + 1 = n+1$。\n\n因此，$N(n)$ 的闭式表达式是 $n+1$。", "answer": "$$\n\\boxed{n+1}\n$$", "id": "3059505"}]}