## 引言
在数字时代，算法无处不在，但哪些问题是算法能够解决的，其能力的边界又在哪里？[可计算性理论](@entry_id:149179)正是探索这一根本问题的核心领域。它用严格的数学语言精确定义了“计算”的本质，并对所有可能的问题进行了分类，揭示了计算世界中“可知”与“不可知”的明确界限。本文的核心主题——[可计算函数](@entry_id:152169)与可判定集，是构建这一宏伟理论大厦的基石。

本文旨在填补从对“算法”的直观理解到掌握其背后深刻数学原理之间的知识鸿沟。我们将不再满足于模糊的描述，而是建立一个坚实的理论框架，用以分析和理解计算的内在力量与局限。通过阅读本文，您将系统地学习到：第一章“原理与机制”将带您深入可计算性的形式化定义，探索[图灵机](@entry_id:153260)、[递归函数](@entry_id:634992)以及停机问题等核心概念；第二章“应用与跨学科关联”将展示这些抽象理论如何在逻辑学、数论和分析学等领域中产生深远影响；最后，第三章“动手实践”将通过具体的练习，巩固您对关键理论的理解与应用能力。

现在，让我们从最基本的问题出发，一同进入[可计算性](@entry_id:276011)的形式世界，探寻那些定义了我们数字时代边界的原理与机制。

## 原理与机制

在[可计算性理论](@entry_id:149179)的探索中，我们的核心任务是精确地界定哪些问题可以通过机械化、算法化的方式解决。这要求我们建立一个坚实的理论框架，用以定义“计算”、“函数”和“集合”的本质，并探索它们内在的联系与局限。本章将系统地阐述[可计算函数](@entry_id:152169)与可判定集的核心原理与机制，从基本概念出发，逐步深入到本领域的若干基石性定理。

### [可计算性](@entry_id:276011)的形式化：[丘奇-图灵论题](@entry_id:138213)

我们对“计算”的直观理解，通常是指一个遵循有限、明确规则的“有效过程”（effective procedure）。这个过程可以由人或机器在有限时间内，通过纸笔演算或机械操作来执行，并最终得到一个确定的结果。然而，这种直观描述是模糊的，不适合进行严格的数学分析。为了克服这一障碍，数学家们在20世纪30年代提出了多种形式化的计算模型，其中最著名的包括[图灵机](@entry_id:153260)（Turing machines）、[λ演算](@entry_id:148725)（lambda calculus）以及[递归函数](@entry_id:634992)（recursive functions）。

一个惊人的发现是，这些看似迥异的形式化模型，在计算能力上是等价的——任何一个模型能够计算的函数，其他模型也同样能够计算。这一发现促成了**[丘奇-图灵论题](@entry_id:138213)**（Church-Turing Thesis）的提出。该论题断言：任何直观上“有效可计算”的函数，都等同于[图灵机](@entry_id:153260)可计算的函数（也即等同于[部分递归函数](@entry_id:152803)或λ-可定义函数）。

值得强调的是，[丘奇-图灵论题](@entry_id:138213)是一个“论题”（thesis），而非一个可以被证明的“定理”（theorem）。因为它连接了非形式的直观概念（有效可计算性）与形式化的数学定义（如图灵机可计算性）。尽管无法被证明，但至今所有旨在捕捉“算法”概念的合理尝试都被证明与[图灵机](@entry_id:153260)模型等价，这为该论题提供了强有力的支持。 [@problem_id:3038765]

接受[丘奇-图灵论题](@entry_id:138213)，意味着我们可以放心地使用图灵机或[递归函数](@entry_id:634992)等形式模型，来精确研究所有可能算法的共性与边界。它为整个[可计算性理论](@entry_id:149179)提供了哲学与实践的基石，使我们能够从对特定算法的研究，上升到对“[可计算性](@entry_id:276011)”本身这一抽象概念的深刻洞察。

### [可计算函数](@entry_id:152169)的模型

我们现在借助两个等价的形式模型——图灵机和[递归函数](@entry_id:634992)——来精确定义[可计算函数](@entry_id:152169)。

#### 机器模型：[图灵机](@entry_id:153260)与部分函数

在数学中，一个从自然数集 $\mathbb{N}$ 到自身的**全函数**（total function）$f: \mathbb{N} \to \mathbb{N}$ 会为定义域中的每一个元素都指定一个唯一的输出值。然而，在计算实践中，算法并非总能对所有输入都终止并给出输出。为了模拟这种情况，我们引入了**部分函数**（partial function）的概念。

一个部分函数 $f: \mathbb{N} \rightharpoonup \mathbb{N}$ 是一个[二元关系](@entry_id:270321) $R \subseteq \mathbb{N} \times \mathbb{N}$，满足对于每个 $x \in \mathbb{N}$，至多存在一个 $y \in \mathbb{N}$ 使得 $(x, y) \in R$。如果对于给定的 $x$ 存在这样的 $y$，我们就说 $f(x)$ 是有定义的（defined），记为 $f(x) = y$；否则，$f(x)$ 是无定义的（undefined）。所有有定义输入的集合被称为函数的**定义域**（domain），记为 $\operatorname{dom}(f)$。全函数是定义域为全集 $\mathbb{N}$ 的特殊部分函数。 [@problem_id:3038783]

**部分[可计算函数](@entry_id:152169)**（partial computable function）是通过[图灵机](@entry_id:153260)（TM）来定义的。一个部分函数 $f: \mathbb{N} \rightharpoonup \mathbb{N}$ 是部分可计算的，如果存在一台[图灵机](@entry_id:153260) $M$，对于每一个输入 $x \in \mathbb{N}$：
*   如果 $f(x)$ 有定义，那么 $M$ 在输入 $x$ 上会**停机**（halts）并输出 $f(x)$。
*   如果 $f(x)$ 无定义，那么 $M$ 在输入 $x$ 上**永不停机**（does not halt），即陷入无限循环或无限计算。

因此，在[可计算性理论](@entry_id:149179)中，**无定义等价于永不停机**。这是一个核心约定，它优雅地将函数的数学属性与计算的物理行为联系起来。 [@problem_id:3038783]

一个自然的问题是：我们是否能将任意一个部分[可计算函数](@entry_id:152169)“修复”成一个全[可计算函数](@entry_id:152169)？例如，对于一个部分[可计算函数](@entry_id:152169) $f$，我们能否构造一个全[可计算函数](@entry_id:152169) $g$，使得当 $f(x)$ 有定义时 $g(x) = f(x)$，而当 $f(x)$ 无定义时 $g(x)$ 等于某个默认值（如 $0$）？答案是否定的。要计算这样的 $g(x)$，我们的算法必须能够判断 $f(x)$ 是否有定义，即判断计算 $f(x)$ 的图灵机是否在输入 $x$ 上停机。这就是著名的**停机问题**（Halting Problem），它已被证明是不可判定的。因此，不存在一个通用算法可以完成这种“修复”工作，这揭示了部分函数在[可计算性理论](@entry_id:149179)中不可或缺的、根本性的地位。 [@problem_id:3038783]

#### 函数模型：[递归函数](@entry_id:634992)

与基于机器的定义不同，[递归函数](@entry_id:634992)理论从一组极其简单的**初始函数**（basic functions）出发，通过有限次应用特定的构造规则来生成更复杂的函数。

所有[可计算函数](@entry_id:152169)的基础是三个初始函数族：
1.  **零函数**（Zero function） $Z(x) = 0$。
2.  **后继函数**（Successor function） $S(x) = x + 1$。
3.  **投影函数**（Projection functions） $U_{i}^{k}(x_{1}, \dots, x_{k}) = x_{i}$，用于从一组参数中选择一个。

在此基础上，我们可以通过以下操作构造新函数：
1.  **复合**（Composition）：将一个函数的输出作为另一个函数的输入。
2.  **[原始递归](@entry_id:638015)**（Primitive Recursion）：这是一种受控的、保证终止的递归形式，类似于编程语言中的 `for` 循环。一个函数 $f$ 由[原始递归](@entry_id:638015)定义，如果它满足如下模式：
    $f(0, \vec{x}) = g(\vec{x})$
    $f(n+1, \vec{x}) = h(n, f(n, \vec{x}), \vec{x})$
    其中 $g$ 和 $h$ 是已经定义好的函数。

由初始函数出发，通过任意有限次复合和[原始递归](@entry_id:638015)操作得到的函数类，被称为**[原始递归函数](@entry_id:155169)**（primitive recursive functions）。这个类包含了所有我们日常在算术中遇到的大多数函数，例如加法、乘法和[指数函数](@entry_id:161417)。所有[原始递归函数](@entry_id:155169)都是**全函数**，因为它们的计算过程（由 `for` 循[环的结构](@entry_id:150907)所保证）总会在有限步内终止。 [@problem_id:3038782]

然而，[原始递归函数](@entry_id:155169)的[表达能力](@entry_id:149863)是有限的。存在一些直观上可计算的全函数，但它们增长得比任何[原始递归函数](@entry_id:155169)都快，因此不属于[原始递归函数](@entry_id:155169)类。最著名的例子是**[阿克曼函数](@entry_id:636397)**（Ackermann function）。 [@problem_id:3038780]

为了达到[通用计算](@entry_id:275847)的能力，我们需要引入一个更强大的操作：
3.  **[无界最小化](@entry_id:153993)**（Unbounded Minimization），或称 **[μ-算子](@entry_id:637476)**。对于一个（可能是部分的）[可计算函数](@entry_id:152169) $g(y, \vec{x})$，函数 $f(\vec{x}) = \mu y [g(y, \vec{x}) = 0]$ 被定义为：寻找最小的自然数 $y$，使得 $g(y, \vec{x}) = 0$。如果存在这样的 $y$，则 $f(\vec{x})$ 的值就是这个最小的 $y$；如果对于给定的 $\vec{x}$，不存在任何 $y$ 使得 $g(y, \vec{x}) = 0$，那么这个寻找过程将永不终止，此时 $f(\vec{x})$ 无定义。

[μ-算子](@entry_id:637476)模拟了编程中的 `while` 循环或无界搜索。正是这个无界性引入了计算可能永不终止的情况，从而产生了部分函数。 [@problem_id:3038760] 例如，考虑一个全[可计算函数](@entry_id:152169) $g(x, y)$，其功能是：如果图灵机 $M_x$ 在输入 $x$ 上恰好在 $y$ 步后停机，则 $g(x, y) = 0$；否则 $g(x, y) = 1$。函数 $f(x) = \mu y [g(x, y) = 0]$ 会去寻找 $M_x$ 在输入 $x$ 上的停机步数。如果 $M_x$ 永不停机，那么对所有 $y$， $g(x, y)$ 恒为 $1$，[μ-算子](@entry_id:637476)的搜索过程将永远持续下去，导致 $f(x)$ 无定义。 [@problem_id:3038760]

由初始函数出发，通过有限次复合、[原始递归](@entry_id:638015)和[μ-算子](@entry_id:637476)得到的函数类，被称为**[部分递归函数](@entry_id:152803)**（partial recursive functions）。根据[丘奇-图灵论题](@entry_id:138213)，这个类精确地捕捉了所有直观上可计算的部分函数。那些恰好对所有输入都有定义的[部分递归函数](@entry_id:152803)，则构成了**[全递归函数](@entry_id:634227)**（total recursive functions）的集合。 [@problem_id:3038780]

### 问题的分类：可判定集与半可判定集

在[可计算性理论](@entry_id:149179)中，一个“问题”通常被形式化为一个自然数的集合。例如，“一个数是否为素数？”这个问题可以等同于判断该数是否属于素数集合。因此，对集合可计算性的分类，就是对问题难度等级的划分。

#### 可判定集（Decidable Sets）

一个集合 $A \subseteq \mathbb{N}$ 被称为**可判定的**（decidable）或**递归的**（recursive），如果存在一个算法，对于任何输入的自然数 $n$，该算法总能停机，并明确回答“是”（如果 $n \in A$）或“否”（如果 $n \notin A$）。

这个概念可以通过**[特征函数](@entry_id:186820)**（characteristic function） $\chi_A$ 来精确化。$\chi_A: \mathbb{N} \to \{0, 1\}$ 定义为：
$$
\chi_A(n) = \begin{cases} 1  & \text{如果 } n \in A \\ 0  & \text{如果 } n \notin A \end{cases}
$$
一个集合 $A$ 是可判定的，当且仅当它的[特征函数](@entry_id:186820) $\chi_A$ 是一个**全[可计算函数](@entry_id:152169)**。 [@problem_id:3038774] 这意味着存在一台图灵机，对任何输入 $n$ 都能在有限步内停机，并输出 $1$ 或 $0$，从而完全决定 $n$ 的成员资格。

#### 半可判定集（Semidecidable Sets）

现在考虑一种更弱的判定能力。对于一个集合 $A$，如果我们只有一个“验证器”算法，它能在有限时间内对属于 $A$ 的元素给出“是”的肯定回答并停机，但对于不属于 $A$ 的元素，它可能永远运行下去，从不给出明确的“否”的回答。这样的集合被称为**半可判定的**（semidecidable）或**递归可枚举的**（recursively enumerable, r.e.），或**可计算可枚举的**（computably enumerable, c.e.）。

半可判定集有几个等价的定义，它们从不同角度揭示了其本质：

1.  **停机集合**：一个集合 $A$ 是半可判定的，当且仅当存在一台图灵机 $M$，使得 $A$ 恰好是 $M$ 的停机输入集合（即 $A = \{n \in \mathbb{N} \mid M \text{ 在输入 } n \text{ 上停机}\}$）。 [@problem_id:3038774]
2.  **部分[函数的定义域](@entry_id:162002)**：一个集合 $A$ 是半可判定的，当且仅当它是某个部分可计算[函数的定义域](@entry_id:162002)。这与前一定义直接等价。 [@problem_id:3038783]
3.  **半[特征函数](@entry_id:186820)**：一个集合 $A$ 是半可判定的，当且仅当它的“半特征函数” $\psi_A$ 是一个部分[可计算函数](@entry_id:152169)，其中 $\psi_A(n) = 1$ 如果 $n \in A$，而当 $n \notin A$ 时 $\psi_A(n)$ 无定义。 [@problem_id:3038774]
4.  **可枚举性**：一个非空集合 $A$ 是半可判定的，当且仅当它是某个全[可计算函数](@entry_id:152169)的**值域**（range）。这意味着存在一个算法，可以像打印机一样，不重复地、无休止地打印出 $A$ 的所有元素。这也是“递归可枚举”这个名称的由来。

这种枚举过程可以通过一种称为**鸽尾法**（dovetailing）的巧妙技术来实现。假设我们想要同时模拟所有图灵机在所有输入上的计算，以找出所有停机的计算。由于有无穷多个计算任务，我们不能简单地一个接一个地运行（第一个任务可能永不停机）。鸽尾法提供了一个公平的调度策略：在第 $s$ 阶段，我们对所有满足特定条件的计算任务（例如，其图灵机编号 $e$ 和输入 $x$ 的和 $e+x \le s$）各执行一步。随着阶段 $s$ 的无限推进，任何一个需要有限步（比如 $T$ 步）才能停机的计算，都保证最终会被分配到足够的计算步骤并完成。每当一个计算停机时，我们就将其结果（如[图灵机](@entry_id:153260)编号、输入、输出）枚举出来。这个过程本身构成了一个永不停机的算法，它能成功地列出所有停机的计算，从而证明了停机集合是可计算可枚举的。 [@problem_id:3038769]

#### 两类集合的关系

可判定集与半可判定集之间存在着清晰的层级关系：
*   所有可判定集都是半可判定集。因为如果一个集合是可判定的，我们可以轻易构造一个半判定程序：运行其判定程序，如果回答“是”，则停机；如果回答“否”，则进入一个无限循环。
*   但反过来不成立。存在半可判定但不可判定的集合。**停机问题**对应的集合 $K = \{e \mid \text{第 } e \text{ 台图灵机在输入 } e \text{ 上停机}\}$ 是这一类问题的原型。$K$ 是半可判定的（可以通过[通用图灵机](@entry_id:155764)模拟来验证），但它是不可判定的。

一个深刻的结果，即**[波斯特定理](@entry_id:155425)**（Post's Theorem），完美地刻画了这两类集合之间的联系：
**一个集合 $A$ 是可判定的，当且仅当 $A$ 和它的[补集](@entry_id:161099) $\overline{A} = \mathbb{N} \setminus A$ 都是半可判定的。** [@problem_id:3038774]

这个定理的直观证明很优美：要判定一个元素 $n$ 是否属于 $A$，我们可以并行地运行 $A$ 的半判定程序和 $\overline{A}$ 的半判定程序。由于 $n$ 要么属于 $A$ 要么属于 $\overline{A}$，这两个程序中必有一个会在有限时间内停机。如果 $A$ 的程序停机，则 $n \in A$；如果 $\overline{A}$ 的程序停机，则 $n \notin A$。无论如何，我们总能得到一个确定的答案。

[波斯特定理](@entry_id:155425)的一个直接推论是，[停机问题](@entry_id:265241)集合 $K$ 的补集 $\overline{K}$ 必然**不是**半可判定的。因为如果 $\overline{K}$ 也是半可判定的，那么根据[波斯特定理](@entry_id:155425)，$K$ 就应该是可判定的，但这与已知事实矛盾。这证明了存在着比半可[判定问题](@entry_id:636780)更“难”的问题。 [@problem_id:3038774]

### 高级工具与定理

掌握了函数和集合的基本分类后，我们可以引入一些更强大的理论工具来分析问题的相对难度和普遍性质。

#### 归约：比较问题的难度

归约（reduction）是比较两个问题难度的一种核心方法。其思想是，如果问题 $A$ 可以被“有效”地转化为问题 $B$，那么 $A$ 的难度不会超过 $B$。

*   **多一归约 (Many-one Reducibility, $\le_m$)**
    我们说集合 $A$ **多一归约**到集合 $B$，记为 $A \le_m B$，如果存在一个**全[可计算函数](@entry_id:152169)** $f$，使得对于所有的自然数 $x$，都满足：
    $$ x \in A \iff f(x) \in B $$
    这个函数 $f$ 就像一个翻译器，它将关于 $A$ 的问题实例 $x$ 转化为关于 $B$ 的问题实例 $f(x)$，并且保持答案不变。 [@problem_id:3038761] 多一归约是证明问题困难度的主要工具。它有两个关键属性：
    1.  如果 $A \le_m B$ 且 $B$ 是可判定的，那么 $A$ 也是可判定的。
    2.  其[逆否命题](@entry_id:265332)是：如果 $A \le_m B$ 且 $A$ 是不可判定的，那么 $B$ 也一定是不可判定的。 [@problem_id:3038761]

*   **[图灵归约](@entry_id:275812) (Turing Reducibility, $\le_T$)**
    [图灵归约](@entry_id:275812)是一个更宽泛、更强大的归约概念。我们说 $A$ **[图灵归约](@entry_id:275812)**到 $B$，记为 $A \le_T B$，如果存在一台**[谕示图灵机](@entry_id:264773)**（oracle Turing machine），它可以在计算过程中随时向一个能即时回答“$y$ 是否在 $B$ 中？”的“神谕”（oracle）提问，并利用这些答案来判定任何输入 $x$ 是否在 $A$ 中。直观地说，这意味着如果我们有一个能解决问题 $B$ 的“黑盒子”，我们就能用它来解决问题 $A$。 [@problem_id:3038763]

多一归约是[图灵归约](@entry_id:275812)的一种特例。如果 $A \le_m B$，那么 $A \le_T B$ 必然成立。但反之不然。一个经典的例子是停机问题集合 $K$ 与其补集 $\overline{K}$。我们有 $\overline{K} \le_T K$，因为拥有一个 $K$ 的神谕，我们可以通过询问“$x$ 是否在 $K$ 中？”并取反其答案来判定 $x$ 是否在 $\overline{K}$ 中。然而，$\overline{K} \not\le_m K$。这是因为如果 $\overline{K} \le_m K$，由于 $K$ 是半可判定的，这将意味着 $\overline{K}$ 也是半可判定的，从而导致 $K$ 是可判定的，这与事实相悖。[图灵归约](@entry_id:275812)的强大之处在于它允许算法进行多次、自适应的查询，并能对神谕的答案进行任意的逻辑处理（如取反），而多一归约则限制为一次性的、非自适应的转换。 [@problem_id:3038763]

#### s-m-n 定理（[参数化](@entry_id:272587)定理）

**[s-m-n定理](@entry_id:153345)**，或称[参数化](@entry_id:272587)定理，是[可计算性理论](@entry_id:149179)中一个极其重要的技术性定理。它揭示了程序（或其索引）可以被算法化地操作。通俗地讲，该定理说明，对于一个接受多个参数的程序，我们可以通过一个算法来“硬编码”或“固定”其中的一部分参数，从而生成一个只接受剩余参数的新程序。

形式上，对于任意正整数 $m, n$，存在一个**全[可计算函数](@entry_id:152169)** $s_m^n$，使得对于任何程序索引 $e$ 和任意参数 $a_1, \dots, a_m$，下面的[等价关系](@entry_id:138275)成立：
$$
\varphi_{s_m^n(e, a_1, \dots, a_m)}(x_1, \dots, x_n) \simeq \varphi_e(a_1, \dots, a_m, x_1, \dots, x_n)
$$
这里，$\simeq$ 表示部分函数等价（即在相同的输入上，要么都无定义，要么都有定义且值相等）。函数 $s_m^n$ 接收一个旧程序的索引 $e$ 和 $m$ 个要固定的参数，然后输出一个新程序的索引。重要的是，**$s_m^n$ 本身是一个总是停机的算法**，它操作的是程序的代码（索引），而不是执行它。 [@problem_id:3038786] 这个定理是许多高级证明（如递归定理）的关键构件。

#### 克林尼递归定理（[不动点定理](@entry_id:143811)）

**克林尼递归定理**（Kleene's Recursion Theorem）是[可计算性理论](@entry_id:149179)中最深刻、最违反直觉的结果之一。它揭示了程序具有一种惊人的“自我引用”（self-reference）能力。

其最常见的形式是**[不动点](@entry_id:156394)形式**：
**对于任何全[可计算函数](@entry_id:152169) $f: \mathbb{N} \to \mathbb{N}$，都存在一个程序索引 $e$，使得程序 $e$ 和程序 $f(e)$ 所计算的函数完全相同，即 $\varphi_e = \varphi_{f(e)}$。** [@problem_id:3038776]

这里的 $f$ 可以被看作是一个对程序索引进行转换的算法。该定理表明，任何这样的算法转换，总会有一个程序索引（一个“[不动点](@entry_id:156394)”）在转换前后其计算行为保持不变。

这个定理的直观内涵是，程序可以“获取自己的代码（索引）”并将其作为计算的一部分。一个具有这种能力的程序 $e$ 可以这样工作：“在输入 $x$ 上，首先获取我自己的索引 $e$，然后计算 $f(e)$ 得到一个新的索引 $e'$，最后模拟执行程序 $e'$ 在输入 $x$ 上的行为。”递归定理保证了这样的自引用程序可以被构造出来。 [@problem_id:3038776]

需要注意的是，这与数值上的[不动点](@entry_id:156394)（即 $e = f(e)$）是完全不同的概念。例如，后继函数 $f(x)=x+1$ 是全可计算的，但它没有任何数值[不动点](@entry_id:156394)。然而，递归定理仍然保证存在一个 $e$ 使得 $\varphi_e = \varphi_{e+1}$。 [@problem_id:3038776] 递归定理是证明许多[不可判定性](@entry_id:145973)问题的强大武器，例如，它可以用来简洁地证明停机问题的[不可判定性](@entry_id:145973)。

#### [莱斯定理](@entry_id:149389)：[不可判定性](@entry_id:145973)的通用判据

**[莱斯定理](@entry_id:149389)**（Rice's Theorem）是一个关于[可计算函数](@entry_id:152169)性质的“元定理”，它提供了一个极其强大的、用于证明大量问题不可判定的统一方法。

[莱斯定理](@entry_id:149389)断言：
**任何关于部分[可计算函数](@entry_id:152169)的“非平凡的”、“[外延](@entry_id:161930)的”性质都是不可判定的。**

这里的术语有精确的含义：
*   一个性质是**外延的**（extensional），意味着它只与函数的**行为**（即其输入-输出映射）有关，而与计算该函数的具体**程序代码**（索引）无关。如果两个不同的程序 $\varphi_e$ 和 $\varphi_{e'}$ 计算的是同一个部分函数（$\varphi_e = \varphi_{e'}$），那么它们必须同时具有或同时不具有该性质。
*   一个性质是**非平凡的**（nontrivial），意味着至少存在一个部分[可计算函数](@entry_id:152169)具有该性质，且至少存在一个部分[可计算函数](@entry_id:152169)不具有该性质。

[莱斯定理](@entry_id:149389)告诉我们，我们无法通过一个通用的算法来判定一个程序所计算的函数是否具有任何特定的、非平凡的行为属性。例如，以下问题都是不可判定的，因为它们都对应于一个非平凡的[外延](@entry_id:161930)性质：
*   “程序 $e$ 所计算的函数是否在输入 $0$ 上停机？”
*   “程序 $e$ 所计算的函数是否是一个全函数？”
*   “程序 $e$ 所计算的函数是否恒等于 $0$？”
*   “程序 $e$ 所计算的[函数的定义域](@entry_id:162002)是否是无限的？”

[莱斯定理](@entry_id:149389)极大地简化了[不可判定性](@entry_id:145973)的证明，将无数个看似独立的问题统一在一个深刻的原理之下，彰显了[可计算性理论](@entry_id:149179)的内在结构与力量。 [@problem_id:3038764]