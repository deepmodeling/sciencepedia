{"hands_on_practices": [{"introduction": "这个练习将为你提供一次计算理论的基础性动手体验。你将从一组最小的初始函数和运算出发，一步步构建出我们熟悉的算术函数，例如加法和乘法。通过这个过程，你将深刻体会到复杂的计算行为如何从简单的、定义良好的规则中涌现，并巩固对原始递归这一可计算函数基石的理解。", "problem": "本文将全程使用标准自然数集 $\\mathbb{N}=\\{0,1,2,\\ldots\\}$ 以及原始递归函数类。原始递归函数类是 $\\mathbb{N}$ 上全函数的最小类，它包含以下初始函数，并对以下运算封闭：\n- 初始函数：\n  - 零函数 $Z:\\mathbb{N}\\to\\mathbb{N}$，定义为 $Z(x)=0$。\n  - 后继函数 $S:\\mathbb{N}\\to\\mathbb{N}$，定义为 $S(x)=x+1$。\n  - 投影函数 $U_i^n:\\mathbb{N}^n\\to\\mathbb{N}$，对每个 $n\\in\\mathbb{N}$ 和 $1\\leq i\\leq n$ 定义为 $U_i^n(x_1,\\ldots,x_n)=x_i$。\n- 复合封闭性：如果 $g:\\mathbb{N}^m\\to\\mathbb{N}$ 和 $h_1,\\ldots,h_m:\\mathbb{N}^n\\to\\mathbb{N}$ 属于该函数类，那么由 $f(\\vec{x})=g(h_1(\\vec{x}),\\ldots,h_m(\\vec{x}))$ 给出的复合函数 $f:\\mathbb{N}^n\\to\\mathbb{N}$ 也属于该函数类。\n- 原始递归封闭性：如果 $g:\\mathbb{N}^k\\to\\mathbb{N}$ 和 $h:\\mathbb{N}^{k+2}\\to\\mathbb{N}$ 属于该函数类，那么通过对最后一个参数进行原始递归得到的函数 $f:\\mathbb{N}^{k+1}\\to\\mathbb{N}$ 也属于该函数类，该函数由以下方程唯一确定：\n$$\nf(\\vec{x},0)=g(\\vec{x}),\\qquad f(\\vec{x},y+1)=h(\\vec{x},y,f(\\vec{x},y)),\n$$\n也属于该函数类。\n\n仅使用这些初始函数和封闭运算，从第一性原理出发完成以下任务：\n- 精确说明上述在 $\\mathbb{N}$ 上使用的原始递归模式，包括所涉及函数的作用和元数，并论证为何对于每一种 $g$ 和 $h$ 的选择，它都能生成一个唯一的全函数。\n- 在原始递归函数类中定义加法函数 $add:\\mathbb{N}^2\\to\\mathbb{N}$、乘法函数 $mul:\\mathbb{N}^2\\to\\mathbb{N}$ 和指数函数 $exp:\\mathbb{N}^2\\to\\mathbb{N}$，展示如何仅使用 $Z$、$S$、$U_i^n$、复合和原始递归来构造它们。你的定义不能先验地假设任何这些函数。\n- 使用你的构造，计算表达式\n$$\nE \\;=\\; exp(2,3)\\;+\\; mul(3,\\, add(2,2)).\n$$\n给出你的最终答案，为一个精确整数，无需四舍五入。", "solution": "所述问题是有效的。这是可计算性理论（数理逻辑的一个分支学科）领域中的一个适定问题。所提供的原始递归函数类的定义是标准且正确的。任务规定明确，逻辑上一致，并要求严格应用所给定义。该问题是自洽的，没有科学或事实上的不健全、模糊或主观因素。因此，我们可以着手解决。\n\n问题要求基于所提供的原始递归函数定义，从第一性原理出发完成三项任务。\n\n### 第一部分：原始递归模式\n\n原始递归模式是一种运算，它从两个已定义的函数 $g$ 和 $h$ 来定义一个新函数 $f$。\n\n**模式说明：**\n设 $k \\in \\mathbb{N}$ 是一个自然数，表示参数的数量。\n1.  **输入函数**：该模式需要两个函数 $g$ 和 $h$，假设它们属于原始递归函数类（因此是其定义域上的全函数）。\n    -   $g: \\mathbb{N}^k \\to \\mathbb{N}$ 是一个 $k$ 元函数。它为递归提供基本情况。如果 $k=0$，$g$ 是一个常数，即 $\\mathbb{N}$ 中的一个元素。\n    -   $h: \\mathbb{N}^{k+2} \\to \\mathbb{N}$ 是一个 $k+2$ 元函数。它提供递归步骤。\n\n2.  **输出函数**：该模式生成一个新函数 $f: \\mathbb{N}^{k+1} \\to \\mathbb{N}$。$f$ 的参数是一个包含 $k$ 个参数的向量，记为 $\\vec{x} = (x_1, \\ldots, x_k)$，以及一个递归变量 $y$。\n\n3.  **定义方程**：函数 $f$ 由以下两个方程对所有 $\\vec{x} \\in \\mathbb{N}^k$ 和 $y \\in \\mathbb{N}$ 唯一确定：\n    $$\n    f(\\vec{x}, 0) = g(\\vec{x}) \\quad (\\text{基本情况})\n    $$\n    $$\n    f(\\vec{x}, y+1) = h(\\vec{x}, y, f(\\vec{x}, y)) \\quad (\\text{递归步骤})\n    $$\n    $h$ 的参数是参数向量 $\\vec{x}$、递归变量 $y$ 的当前值，以及函数 $f$ 在步骤 $y$ 的值，即 $f(\\vec{x},y)$。\n\n**$f$ 的唯一性和全函数性论证**：\n我们必须论证，对于任何原始递归（因此是全函数）的 $g$ 和 $h$，函数 $f$ 在其定义域 $\\mathbb{N}^{k+1}$ 上是一个唯一的全函数。该论证通过对递归变量 $y$ 进行数学归纳来进行。\n\n设 $\\vec{x} \\in \\mathbb{N}^k$ 是任意固定的参数向量。我们将证明对于所有 $y \\in \\mathbb{N}$，$f(\\vec{x}, y)$ 都是唯一定义的。\n\n-   **基本情况（$y=0$）**：$f(\\vec{x}, 0)$ 的值由方程 $f(\\vec{x}, 0) = g(\\vec{x})$ 给出。根据假设，$g$ 是一个全函数，因此对于任何给定的 $\\vec{x}$，$g(\\vec{x})$ 都会计算出一个唯一的自然数。所以，$f(\\vec{x}, 0)$ 是唯一定义的。\n\n-   **归纳步骤**：假设对于某个 $y \\in \\mathbb{N}$，$f(\\vec{x}, y)$ 的值是唯一定义的。我们必须证明 $f(\\vec{x}, y+1)$ 也是唯一定义的。递归步骤的方程是 $f(\\vec{x}, y+1) = h(\\vec{x}, y, f(\\vec{x}, y))$。函数 $h$ 的参数是三元组 $(\\vec{x}, y, f(\\vec{x}, y))$。\n    -   $\\vec{x}$ 是我们固定的参数向量。\n    -   $y$ 是一个自然数。\n    -   根据归纳假设，$f(\\vec{x}, y)$ 是一个唯一的自然数。\n    根据假设，$h$ 是一个全函数，对于任何有效的输入元组，它都会产生一个唯一的自然数作为输出。因此，$h(\\vec{x}, y, f(\\vec{x}, y))$ 是唯一定义的。这意味着 $f(\\vec{x}, y+1)$ 是唯一定义的。\n\n-   **结论**：根据对 $y$ 的数学归纳法原理，$f(\\vec{x}, y)$ 对所有 $y \\in \\mathbb{N}$ 和所有 $\\vec{x} \\in \\mathbb{N}^k$ 都是唯一定义的。这证实了 $f$ 是 $\\mathbb{N}^{k+1}$ 上的一个全函数，并且其定义是明确的。\n\n### 第二部分：`add`、`mul` 和 `exp` 的构造\n\n我们仅使用初始函数（$Z$、$S$、$U_i^n$）以及复合和原始递归运算来构造这些函数。\n\n**1. 加法：$add(x,y) = x+y$**\n加法通过对 $y$ 进行原始递归来定义。参数是 $x$（$k=1$）。\n-   基本情况：$add(x, 0) = x$。\n-   递归步骤：$add(x, y+1) = S(add(x, y))$。\n\n为了将其形式化：\n-   基本情况函数是 $g(x) = x$。这是投影函数 $U_1^1$。所以，$g = U_1^1$。\n-   递归步骤函数是 $h(x, y, z) = S(z)$，其中 $z = add(x,y)$。函数 $h$ 必须形式上是三元函数。我们通过复合来实现这一点：$h(x,y,z) = S(U_3^3(x,y,z))$。由于 $S$ 和 $U_3^3$ 是初始函数，根据复合，$h$ 是原始递归的。\n-   因此，$add: \\mathbb{N}^2 \\to \\mathbb{N}$ 定义如下：\n    $$add(x,0) = U_1^1(x)$$\n    $$add(x,y+1) = S(U_3^3(x,y,add(x,y)))$$\n\n**2. 乘法：$mul(x,y) = x \\cdot y$**\n乘法通过使用加法，对 $y$ 进行原始递归来定义。参数是 $x$（$k=1$）。\n-   基本情况：$mul(x, 0) = 0$。\n-   递归步骤：$mul(x, y+1) = mul(x,y) + x = add(mul(x,y), x)$。\n\n为了将其形式化：\n-   基本情况函数是 $g(x) = 0$。这是零函数 $Z(x)$。为了完全形式化，我们可以写作 $g(x) = Z(U_1^1(x))$。\n-   递归步骤函数是 $h(x,y,z) = add(z,x)$，其中 $z = mul(x,y)$。我们使用与投影函数的复合来构造 $h$：$h(x,y,z) = add(U_3^3(x,y,z), U_1^3(x,y,z))$。由于 $add$、$U_1^3$ 和 $U_3^3$ 是原始递归的，所以 $h$ 是原始递归的。\n-   因此，$mul: \\mathbb{N}^2 \\to \\mathbb{N}$ 定义如下：\n    $$mul(x,0) = Z(U_1^1(x))$$\n    $$mul(x,y+1) = add(U_3^3(x,y,mul(x,y)), U_1^3(x,y,mul(x,y)))$$\n\n**3. 指数运算：$exp(x,y) = x^y$**\n在此上下文中，约定 $0^0=1$。指数运算通过使用乘法，对 $y$ 进行原始递归来定义。参数是 $x$（$k=1$）。\n-   基本情况：$exp(x, 0) = 1$。\n-   递归步骤：$exp(x, y+1) = exp(x,y) \\cdot x = mul(exp(x,y), x)$。\n\n为了将其形式化：\n-   基本情况函数是 $g(x) = 1$。这个常数函数可以构造为 $S(Z(x))$，或者更形式化地，$g(x) = S(Z(U_1^1(x)))$。\n-   递归步骤函数是 $h(x,y,z) = mul(z,x)$，其中 $z = exp(x,y)$。这可以构造为 $h(x,y,z) = mul(U_3^3(x,y,z), U_1^3(x,y,z))$。由于 $mul$、$U_1^3$ 和 $U_3^3$ 是原始递归的，所以 $h$ 是原始递归的。\n-   因此，$exp: \\mathbb{N}^2 \\to \\mathbb{N}$ 定义如下：\n    $$exp(x,0) = S(Z(U_1^1(x)))$$\n    $$exp(x,y+1) = mul(U_3^3(x,y,exp(x,y)), U_1^3(x,y,exp(x,y)))$$\n\n### 第三部分：表达式求值\n\n我们使用上面推导出的定义来计算 $E = exp(2,3) + mul(3, add(2,2))$，这可以转换为 $add(exp(2,3), mul(3, add(2,2)))$。我们从最内层的表达式开始向外计算。\n\n**1. 计算 $add(2,2)$：**\n$add(x,y+1) = S(add(x,y))$\n-   $add(2,0) = 2$\n-   $add(2,1) = add(2,0+1) = S(add(2,0)) = S(2) = 3$\n-   $add(2,2) = add(2,1+1) = S(add(2,1)) = S(3) = 4$\n所以，$add(2,2) = 4$。\n\n**2. 计算 $mul(3, add(2,2)) = mul(3,4)$：**\n$mul(x,y+1) = add(mul(x,y), x)$\n-   $mul(3,0) = 0$\n-   $mul(3,1) = mul(3,0+1) = add(mul(3,0), 3) = add(0,3) = S(S(S(add(0,0)))) = S(S(S(0))) = 3$\n-   $mul(3,2) = mul(3,1+1) = add(mul(3,1), 3) = add(3,3) = S(S(S(add(3,0)))) = S(S(S(3))) = 6$\n-   $mul(3,3) = mul(3,2+1) = add(mul(3,2), 3) = add(6,3) = S(S(S(add(6,0)))) = S(S(S(6))) = 9$\n-   $mul(3,4) = mul(3,3+1) = add(mul(3,3), 3) = add(9,3) = S(S(S(add(9,0)))) = S(S(S(9))) = 12$\n所以，$mul(3,4) = 12$。\n\n**3. 计算 $exp(2,3)$：**\n$exp(x,y+1) = mul(exp(x,y), x)$\n-   $exp(2,0) = S(Z(2)) = S(0) = 1$\n-   $exp(2,1) = exp(2,0+1) = mul(exp(2,0), 2) = mul(1,2)$.\n    -   $mul(1,0) = 0$\n    -   $mul(1,1) = add(mul(1,0), 1) = add(0,1) = 1$\n    -   $mul(1,2) = add(mul(1,1), 1) = add(1,1) = S(add(1,0)) = S(1) = 2$.\n    所以 $exp(2,1) = 2$。\n-   $exp(2,2) = exp(2,1+1) = mul(exp(2,1), 2) = mul(2,2)$.\n    -   我们已经计算出 $add(2,2)=4$。根据乘法的定义，$mul(2,2)=add(mul(2,1),2)=add(add(mul(2,0),2),2)=add(add(0,2),2)=add(2,2)=4$。\n    所以 $exp(2,2) = 4$。\n-   $exp(2,3) = exp(2,2+1) = mul(exp(2,2), 2) = mul(4,2)$.\n    -   $mul(4,0) = 0$\n    -   $mul(4,1) = add(mul(4,0),4) = add(0,4)=4$\n    -   $mul(4,2) = add(mul(4,1),4) = add(4,4) = S(S(S(S(add(4,0))))) = S(S(S(S(4)))) = 8$。\n所以，$exp(2,3) = 8$。\n\n**4. 最终计算：$add(exp(2,3), mul(3,4)) = add(8,12)$：**\n-   $add(8,0) = 8$\n-   $add(8,1) = S(8) = 9$\n-   ...\n-   $add(8,12) = S^{12}(add(8,0)) = S^{12}(8)$\n对 $8$ 应用 $12$ 次后继函数得到 $8+12 = 20$。\n所以，$add(8,12) = 20$。\n\n表达式 $E$ 的值为 $20$。", "answer": "$$\n\\boxed{20}\n$$", "id": "3048525"}, {"introduction": "莱斯定理是一个强大的工具，但它只适用于一类特定的性质：函数的语义（或外延）性质。本练习旨在挑战你区分这类性质与程序代码本身的句法（或内涵）性质。通过识别程序代码的那些可判定性质，你将理解为何莱斯定理并不禁止它们的可判定性，并掌握程序“是什么”（其代码）与它“做什么”（其功能）之间的关键区别。", "problem": "固定一个所有从 $\\mathbb{N}$ 到 $\\mathbb{N}$ 的部分递归（部分可计算）函数的标准有效枚举 $e \\mapsto \\varphi_{e}$，其中每个自然数 $e \\in \\mathbb{N}$ 编码了一台计算该部分函数 $\\varphi_{e}$ 的图灵机（TM）。程序代码的性质是 $\\mathbb{N}$ 的任意子集 $S \\subseteq \\mathbb{N}$。如果对于所有的 $e, e' \\in \\mathbb{N}$，等式 $\\varphi_{e} = \\varphi_{e'}$ 蕴含着 $e \\in S$ 当且仅当 $e' \\in S$，那么这样的性质被称为外延的。否则，它是内涵的。如果存在一个全递归（一般递归）特征函数 $\\chi_{S} \\colon \\mathbb{N} \\to \\{0,1\\}$，满足 $\\chi_{S}(e) = 1$ 当且仅当 $e \\in S$，否则 $\\chi_{S}(e) = 0$，则性质 $S \\subseteq \\mathbb{N}$ 是可判定的。莱斯定理指出，部分可计算函数的任何非平凡外延性质都有一个不可判定的指标集。\n\n从以下选项中选出所有描述程序代码的可判定内涵性质的选项，并为你所选的选项解释为什么莱斯定理不禁止它们的可判定性。\n\nA. $E_{\\mathrm{even}} = \\{e \\in \\mathbb{N} : e \\text{ 是偶数}\\}$。\n\nB. $T = \\{e \\in \\mathbb{N} : \\varphi_{e} \\text{ 是全函数}\\}$。\n\nC. $H_{10} = \\{e \\in \\mathbb{N} : \\text{代码为 } e \\text{ 的图灵机在输入为 } 0 \\text{ 时至多在 } 10 \\text{ 步内停机}\\}$。\n\nD. $Z = \\{e \\in \\mathbb{N} : \\exists x \\in \\mathbb{N} \\text{ with } \\varphi_{e}(x) = 0\\}$。\n\nE. $S_{01} = \\{e \\in \\mathbb{N} : e \\text{ 的二进制编码包含子串 } 01\\}$。", "solution": "问题陈述是可计算性理论中的一个有效练习。所提供的所有定义——部分递归函数、有效枚举、外延和内涵性质、可判定性以及莱斯定理——都是标准的且陈述正确。该问题是自洽的，在数理逻辑中有科学依据，并且是良定的。我们可以开始解题。\n\n任务是确定给定的性质 $S \\subseteq \\mathbb{N}$ 中哪些既是可判定的又是内涵的。让我们回顾一下定义。\n如果一个性质 $S$ 的特征函数 $\\chi_S$ 是一个全可计算函数，则该性质是**可判定的**。这意味着存在一个算法，对于任何输入 $e \\in \\mathbb{N}$，如果 $e \\in S$ 则停机并输出 $1$，如果 $e \\notin S$ 则停机并输出 $0$。\n如果一个性质 $S$ 是关于所计算的函数的性质，而不是关于程序代码本身的性质，则该性质是**外延的**。形式上，对于任意两个代码 $e, e' \\in \\mathbb{N}$，如果它们计算相同的函数（即 $\\varphi_e = \\varphi_{e'}$），那么必须满足 $e \\in S$ 当且仅当 $e' \\in S$。\n如果一个性质 $S$ 不是外延的，则它是**内涵的**。这意味着至少存在两个代码 $e, e' \\in \\mathbb{N}$，使得 $\\varphi_e = \\varphi_{e'}$，但一个代码在 $S$ 中而另一个不在。\n**莱斯定理**指出，任何非平凡（即非 $\\emptyset$ 且非 $\\mathbb{N}$）的外延性质都是不可判定的。一个直接的推论是，任何可判定的非平凡性质必须是内涵的。\n\n我们现在分析每个选项。\n\n**A. $E_{\\mathrm{even}} = \\{e \\in \\mathbb{N} : e \\text{ 是偶数}\\}$**\n\n*   **可判定性**：该性质是可判定的。要确定一个给定的自然数 $e$ 是否在 $E_{\\mathrm{even}}$ 中，我们只需计算 $e \\pmod 2$。如果结果是 $0$，则 $e \\in E_{\\mathrm{even}}$；否则，$e \\notin E_{\\mathrm{even}}$。这是一个简单的、会终止的算法。因此，特征函数 $\\chi_{E_{\\mathrm{even}}}$ 是全可计算的。该性质是**可判定的**。\n*   **内涵性**：要检查该性质是否是内涵的，我们必须确定是否存在两个代码 $e_1, e_2$，使得 $\\varphi_{e_1} = \\varphi_{e_2}$，但一个是偶数而另一个是奇数。根据填充引理（或者更通俗地说，由于可以向图灵机添加冗余指令），任何部分可计算函数都有无穷多个不同的代码（指标）。这个对于任何给定函数的无限代码集不可能只包含偶数或只包含奇数。因此，对于任何部分可计算函数 $f$，我们可以找到一个偶数指标 $e_1$ 和一个奇数指标 $e_2$，使得 $\\varphi_{e_1} = f$ 且 $\\varphi_{e_2} = f$。在这种情况下，$\\varphi_{e_1} = \\varphi_{e_2}$，但 $e_1 \\in E_{\\mathrm{even}}$ 且 $e_2 \\notin E_{\\mathrm{even}}$。这违反了外延性的条件。因此，该性质是**内涵的**。\n*   **结论**：该性质既是可判定的又是内涵的。莱斯定理不禁止其可判定性，因为该定理仅适用于外延性质，而 $E_{\\mathrm{even}}$ 是一个内涵性质。它描述的是代码 $e$ 本身的语法特征，而不是函数 $\\varphi_e$ 的语义特征。\n*   **判定**：**正确**。\n\n**B. $T = \\{e \\in \\mathbb{N} : \\varphi_{e} \\text{ 是全函数}\\}$**\n\n*   **可判定性**：一个函数是全函数的性质是一个经典的不可判定问题。为了用莱斯定理证明这一点，我们首先检查其条件。\n*   **内涵性**：该性质是**外延的**。如果 $\\varphi_e = \\varphi_{e'}$，那么这两个函数是相同的。它们必须有相同的定义域。因此，$\\varphi_e$ 是全函数当且仅当 $\\varphi_{e'}$ 是全函数。\n*   **平凡性**：该性质是非平凡的。存在全函数（例如，常数零函数，$f(x)=0$），所以 $T \\neq \\emptyset$。也存在不是全函数的函数（例如，处处无定义的函数），所以 $T \\neq \\mathbb{N}$。\n*   **结论**：由于 $T$ 是一个非平凡的外延性质，根据莱斯定理，它是**不可判定的**。\n*   **判定**：**不正确**。\n\n**C. $H_{10} = \\{e \\in \\mathbb{N} : \\text{代码为 } e \\text{ 的图灵机在输入为 } 0 \\text{ 时至多在 } 10 \\text{ 步内停机}\\}$**\n\n*   **可判定性**：该性质是可判定的。给定一个指标 $e$，我们可以模拟它所编码的图灵机在输入为 $0$ 上的运行。我们最多运行模拟 $10+1$ 步。如果机器在 $10$ 步内停机，我们接受 $e$（输出 $1$）。如果在 $10$ 步后机器仍未停机，我们停止模拟并拒绝 $e$（输出 $0$）。由于模拟是有时间限制的，这个过程对于任何输入 $e$ 总是会终止。因此，该性质是**可判定的**。\n*   **内涵性**：该性质是**内涵的**。它取决于机器 $e$ 的特定操作行为（步数），而不仅仅是它所计算的函数 $\\varphi_e$。为了证明这一点，考虑常数函数 $f(x) = 0$。我们可以构造一个非常高效的图灵机 $M_1$，其代码为 $e_1$，它计算这个函数并在输入 $0$ 上于（比如说）$5$ 步内停机。因此，$e_1 \\in H_{10}$。我们也可以构造另一个图灵机 $M_2$，其代码为 $e_2$，它计算相同的函数 $f(x)=0$，但首先执行 $20$ 次无用的、浪费时间的操作（比如来回移动磁头），然后再进行主要计算。这个机器 $M_2$ 在输入 $0$ 上停机将需要超过 $10$ 步，所以 $e_2 \\notin H_{10}$。由于 $\\varphi_{e_1} = \\varphi_{e_2}$ 但 $e_1 \\in H_{10}$ 且 $e_2 \\notin H_{10}$，该性质不是外延的。\n*   **结论**：该性质既是可判定的又是内涵的。莱斯定理不适用，因为该性质是内涵的。它关系到特定程序的性能，而不是它所计算的数学函数的性质。\n*   **判定**：**正确**。\n\n**D. $Z = \\{e \\in \\mathbb{N} : \\exists x \\in \\mathbb{N} \\text{ with } \\varphi_{e}(x) = 0\\}$**\n\n*   **可判定性**：该性质询问数字 $0$ 是否在函数 $\\varphi_e$ 的值域中。\n*   **内涵性**：该性质是**外延的**。如果 $\\varphi_e = \\varphi_{e'}$，它们是相同的函数，因此具有相同的值域。如果存在一个 $x$ 使得 $\\varphi_e(x)=0$，那么 $\\varphi_{e'}(x)=0$ 也为真。所以，$e \\in Z$ 当且仅当 $e' \\in Z$。\n*   **平凡性**：该性质是非平凡的。常数零函数的值域中有 $0$，所以 $Z \\neq \\emptyset$。常数一函数（$f(x)=1$）的值域中没有 $0$，所以 $Z \\neq \\mathbb{N}$。\n*   **结论**：由于 $Z$ 是一个非平凡的外延性质，根据莱斯定理，它是**不可判定的**。\n*   **判定**：**不正确**。\n\n**E. $S_{01} = \\{e \\in \\mathbb{N} : e \\text{ 的二进制编码包含子串 } 01\\}$**\n\n*   **可判定性**：该性质是可判定的。给定一个数 $e$，我们可以将其转换为其二进制字符串表示，然后对子串`01`进行简单的字符串搜索。这个算法总是会终止。因此，该性质是**可判定的**。\n*   **内涵性**：该性质是**内涵的**。它纯粹是语法的，仅取决于整数 $e$ 的表示。如选项 A 的解释所述，任何部分可计算函数都有无穷多个指标。我们总能为同一个函数找到两个指标 $e_1$ 和 $e_2$，使得 $e_1$ 的二进制表示包含子串`01`，而 $e_2$ 的二进制表示不包含。例如，其二进制形式*不*包含`01`的数字集合是由形如 $2^k-1$ 的数后跟任意数量的零组成的数的集合（即，二进制形式为 $\\underbrace{11\\dots1}_{k}\\underbrace{00\\dots0}_{j}$ 的数，形式上为 $(2^k-1) \\cdot 2^j$）。这个集合是无穷的。任何函数的指标集也是无穷的。一个函数的无限指标集不可能是一个其二进制形式缺少`01`的数字集的子集。因此，必然存在一个在 $S_{01}$ 中的指标 $e_1$ 和一个不在 $S_{01}$ 中的指标 $e_2$ 计算相同的函数。\n*   **结论**：该性质既是可判定的又是内涵的。莱斯定理不适用，因为该性质是内涵的，仅涉及指标的语法，而非函数的语义。\n*   **判定**：**正确**。", "answer": "$$\\boxed{ACE}$$", "id": "3048534"}, {"introduction": "这项练习将不同形式的计算与不可判定性的深刻后果联系起来。你将首先探索保证产生全可计算函数的有界极小化，然后将其与无界极小化进行对比，后者可能产生定义域不可判定的部分函数。这项练习最终会引导你应用莱斯定理 [@problem_id:3048534]，证明停机问题的不可判定性，这是计算机科学的一个核心结论。", "problem": "令 $\\{\\varphi_{e}\\}_{e \\in \\mathbb{N}}$ 为一个固定的标准枚举，它包含了所有由图灵机（Turing machine, TM）的哥德尔编号（Gödel numbering）所导出的部分可计算函数 $\\varphi_{e} : \\mathbb{N} \\to \\mathbb{N}$。对于 $e, x, t \\in \\mathbb{N}$，令 $H(e,x,t)$ 为一个原始递归谓词，该谓词成立当且仅当第 $e$ 个图灵机在输入为 $x$ 时于 $t$ 个计算步骤内停机（等价地，存在某个 $y$，使得第 $e$ 个图灵机在输入为 $x$ 时于 $t$ 个步骤内停机并输出 $y$）。仅使用部分递归函数与一般递归函数理论的基本定义以及莱斯定理（Rice’s theorem），解答下列问题。\n\n1. 通过有界极小化定义函数 $f : \\mathbb{N} \\to \\mathbb{N}$\n$$\nf(n) \\;=\\; \\mu y \\leq n \\;\\big[y^{2} \\geq n\\big],\n$$\n即，$f(n)$ 是满足 $y \\leq n$ 和 $y^{2} \\geq n$ 的最小自然数 $y \\in \\mathbb{N}$（如果在此界限内不存在这样的 $y$，则函数无定义）。从核心定义出发，论证为何在此情况下有界极小化会产生一个全可计算函数。通过从序和平方的第一性原理推导一个闭式刻画，用更熟悉的解析术语来识别 $f(n)$。\n\n2. 通过无界极小化定义函数 $g : \\mathbb{N} \\rightharpoonup \\mathbb{N}$\n$$\ng(e) \\;=\\; \\mu t \\;\\big[ H(e,0,t) \\big],\n$$\n即，$g(e)$ 是使得第 $e$ 个图灵机在输入为 $0$ 时于 $t$ 步内停机的最小计算时间 $t$（如果这样的 $t$ 存在）；否则 $g(e)$ 无定义。仅使用无界极小化和部分可计算性的基本定义，解释 $g$ 为何可能不是全函数。给出一个具体的机器描述，其指标 $e_{\\mathrm{loop}}$ 导致 $g(e_{\\mathrm{loop}})$ 无定义，并证明这一论断。\n\n3. 使用莱斯定理（Rice’s theorem），严格论证为何指标集\n$$\nD \\;=\\; \\{\\, e \\in \\mathbb{N} : g(e) \\text{ is defined} \\,\\}\n$$\n是不可判定的。你的论证应从莱斯定理的陈述开始，并解释为何所讨论的性质是语义性的（semantic）和非平凡的（nontrivial）。\n\n作为你的最终答案，给出 $f(2024)$ 的精确整数值，无需四舍五入，也无需单位。你的最终答案必须是单个数字。不要在最终答案中包含任何解释。", "solution": "这个问题包含三个与可计算函数理论相关的部分。我们根据所提供的定义依次解答每个部分。\n\n1. 函数 $f(n) = \\mu y \\leq n \\;[y^{2} \\geq n]$ 的分析。\n\n首先，我们论证为何这个函数是全可计算的。函数 $f$ 是通过有界极小化定义的。可计算性理论的一个基本定理指出，如果谓词 $P$ 是全可计算的，那么由 $h(\\vec{x}) = \\mu y \\leq z \\; [P(\\vec{x}, y)]$ 定义的函数 $h$ 也是全可计算的，前提是对于每个输入 $\\vec{x}$，在搜索范围 $[0, z]$ 内至少存在一个 $y$ 使得谓词 $P(\\vec{x}, y)$ 为真。\n\n在我们的例子中，函数是 $f(n)$，谓词是 $P(n, y) \\equiv (y^2 \\geq n)$，界限是 $z=n$。谓词 $P(n,y)$ 是原始递归的，因此是全可计算的，因为它只涉及对一个整数求平方并将其与另一个整数进行比较，这两者都是原始递归操作。\n\n为了证明 $f(n)$ 是全函数，我们必须表明对于任意给定的 $n \\in \\mathbb{N}$，至少存在一个整数 $y$ 满足 $0 \\leq y \\leq n$ 和 $y^2 \\geq n$。\n我们考虑两种关于 $n$ 的情况：\n情况 1：$n=0$。定义变为 $f(0) = \\mu y \\leq 0 \\; [y^{2} \\geq 0]$。搜索仅限于 $y=0$。对于 $y=0$，谓词为 $0^2 \\geq 0$，这是成立的。因此，极小化过程找到 $y=0$ 并终止。所以，$f(0) = 0$。\n情况 2：$n > 0$。我们需要在范围 $\\{0, 1, \\dots, n\\}$ 中找到一个满足 $y^2 \\geq n$ 的 $y$。让我们测试 $y=n$ 这个值。因为 $n \\in \\mathbb{N}$ 且 $n > 0$，所以有 $n \\geq 1$。两边同乘以 $n$（为正数），得到 $n^2 \\geq n$。因此，选择 $y=n$ 总是满足谓词 $y^2 \\geq n$。由于这个选择在搜索范围 $\\{0, 1, \\dots, n\\}$ 内，有界极小化过程保证能找到一个值（它会找到*最小的*这样的 $y$，该值小于或等于 $n$）并停机。\n\n由于对于每个 $n \\in \\mathbb{N}$，在界限内都存在一个合适的 $y$，并且谓词是全可计算的，所以函数 $f(n)$ 是一个全可计算函数。\n\n接下来，我们推导 $f(n)$ 的闭式刻画。定义指出，$f(n)$ 是满足 $y^2 \\geq n$ 的最小非负整数 $y$。（约束 $y \\leq n$ 是多余的，因为可以证明对于 $y_{min} = \\lceil\\sqrt{n}\\rceil$，当 $n \\geq 1$ 时有 $y_{min} \\leq n$，而当 $n=0$ 时它显然成立）。对不等式 $y^2 \\geq n$ 两边取平方根，得到 $|y| \\geq \\sqrt{n}$。由于我们考虑的是 $y \\in \\mathbb{N}$，y是非负的，所以条件简化为 $y \\geq \\sqrt{n}$。\n因此，$f(n)$ 是大于或等于实数 $\\sqrt{n}$ 的最小整数。这是天花板函数（ceiling function）的定义。\n所以，$f(n)$ 的闭式刻画是\n$$\nf(n) = \\lceil \\sqrt{n} \\rceil.\n$$\n\n2. 函数 $g(e) = \\mu t \\;[ H(e,0,t) ]$ 的分析。\n\n首先，我们解释为何 $g$ 可能不是全函数。函数 $g(e)$ 是通过无界极小化定义的。表达式 $g(e) = \\mu t \\;[P(e,t)]$，其中 $P(e,t) \\equiv H(e,0,t)$，给出使谓词 $P(e,t)$ 为真的最小 $t \\in \\mathbb{N}$。如果不存在这样的 $t$，则函数对于该输入 $e$ 是无定义的。\n谓词 $H(e,0,t)$ 为真当且仅当第 $e$ 个图灵机在输入为 $0$ 时于 $t$ 步内停机。因此，函数 $g(e)$ 有定义当且仅当存在某个有限时间 $t$，使得第 $e$ 个图灵机在输入 $0$ 时停机。这等价于说计算 $\\varphi_e(0)$ 停机，或记为 $\\varphi_e(0) \\downarrow$。\n停机问题（Halting Problem）是可计算性理论的一个基石性结果，它指出判定一个任意图灵机在任意输入上是否停机是不可判定的。一个直接的推论是，必然存在在某些输入上不停机的图灵机。特别地，存在在输入 $0$ 上不停机的图灵机。\n令 $e_{\\mathrm{loop}}$ 是一个被设计为在输入 $0$ 上永不停机的图灵机的哥德尔数。对于这个指标 $e_{\\mathrm{loop}}$，“该图灵机在输入 $0$ 上停机”这一陈述是假的。这意味着不存在任何步数 $t$ 使得谓词 $H(e_{\\mathrm{loop}},0,t)$ 为真。无界极小化过程 $\\mu t \\;[H(e_{\\mathrm{loop}},0,t)]$ 将从 $t=0, 1, 2, \\dots$ 开始无限地搜索这样的 $t$，并且永远也找不到。根据无界极小化的定义，$g(e_{\\mathrm{loop}})$ 是无定义的。\n由于至少存在一个输入 $e_{\\mathrm{loop}}$ 使得 $g(e_{\\mathrm{loop}})$ 无定义，所以函数 $g$ 是一个部分函数，而不是全函数。\n\n作为一个具体的例子，考虑一个图灵机 $M$，它只有一个状态 $q_0$（即起始状态），其转移函数 $\\delta$ 定义如下：对于纸带上的任何符号 $a$，$\\delta(q_0, a) = (q_0, a, R)$。这个规则表示，当处于状态 $q_0$ 时，机器读取符号 $a$，写回相同的符号 $a$，将其读写头向右移动一个位置（R），并保持在状态 $q_0$。这个机器没有停机状态。当它在任何输入（包括输入 $0$）上启动时，它将无休止地将其读写头向右移动，永不停机。令 $e_{\\mathrm{loop}}$ 为这台机器 $M$ 的指标（哥德尔数）。那么，根据其构造，$\\varphi_{e_{\\mathrm{loop}}}(0)$ 是无定义的。这意味着对于所有的 $t \\in \\mathbb{N}$，谓词 $H(e_{\\mathrm{loop}}, 0, t)$ 都是假的。因此，$g(e_{\\mathrm{loop}})$ 是无定义的。\n\n3. 集合 $D = \\{\\, e \\in \\mathbb{N} : g(e) \\text{ is defined} \\,\\}$ 的不可判定性。\n\n我们使用莱斯定理（Rice's theorem）来证明 $D$ 是不可判定的。莱斯定理指出，对于部分可计算函数的任何非平凡的语义性质 $\\mathcal{P}$，其指标集 $I_{\\mathcal{P}} = \\{ e \\in \\mathbb{N} \\mid \\varphi_e \\in \\mathcal{P} \\}$ 是不可判定的。要应用该定理，我们必须证明 $D$ 是某个性质的指标集，且该性质既是语义性的也是非平凡的。\n\n步骤 1：识别性质。\n集合 $D$ 被定义为 $\\{ e \\in \\mathbb{N} \\mid g(e) \\text{ is defined}\\}$。如第 2 部分所述，$g(e)$ 有定义当且仅当计算 $\\varphi_e(0)$ 停机。因此，$D$ 是“部分可计算函数在输入 $0$ 上有定义”这一性质的指标集。令这个性质为 $\\mathcal{P}$。\n$$\n\\mathcal{P} = \\{ h : \\mathbb{N} \\rightharpoonup \\mathbb{N} \\mid h \\text{ 是部分可计算函数且 } h(0) \\text{ 有定义} \\}\n$$\n集合 $D$ 正是指标集 $I_{\\mathcal{P}}$，因为 $e \\in D \\iff \\varphi_e \\in \\mathcal{P}$。\n\n步骤 2：证明性质是语义性的。\n如果一个性质仅依赖于函数的行为（即其图），而不依赖于其具体实现（即其指标），那么该性质是语义性的。这意味着，如果两个指标 $e_1$ 和 $e_2$ 计算的是同一个函数（$\\varphi_{e_1} = \\varphi_{e_2}$），那么它们必须要么都具有该性质，要么都不具有。\n假设 $\\varphi_{e_1} = \\varphi_{e_2}$。这个等式意味着它们有相同的定义域，并且对于该定义域中的每个输入都产生相同的输出。性质 $\\mathcal{P}$ 是指函数在输入 $0$ 上有定义。如果 $\\varphi_{e_1} \\in \\mathcal{P}$，那么 $\\varphi_{e_1}(0)$ 有定义。因为 $\\varphi_{e_1} = \\varphi_{e_2}$，所以 $\\varphi_{e_2}(0)$ 也必定有定义，这意味着 $\\varphi_{e_2} \\in \\mathcal{P}$。反之，如果 $\\varphi_{e_1} \\notin \\mathcal{P}$，那么 $\\varphi_{e_1}(0)$ 无定义，这意味着 $\\varphi_{e_2}(0)$ 也无定义，所以 $\\varphi_{e_2} \\notin \\mathcal{P}$。“在输入 $0$ 上有定义”这个性质仅取决于函数本身，所以该性质是语义性的。\n\n步骤 3：证明性质是非平凡的。\n如果一个性质既不是普适的（即并非所有函数都具备）也不是空的（即至少有一个函数具备），那么该性质是非平凡的。也就是说，必须至少存在一个具有该性质的部分可计算函数，以及至少一个不具有该性质的部分可计算函数。\n为了证明 $\\mathcal{P}$ 不是空的，我们必须展示一个属于 $\\mathcal{P}$ 的函数。考虑全可计算函数 $c(x) = 0$（对于所有 $x \\in \\mathbb{N}$）。这个函数对所有输入都有定义，包括 $x=0$。因此，$c \\in \\mathcal{P}$。\n为了证明 $\\mathcal{P}$ 不是所有部分可计算函数的集合，我们必须展示一个不属于 $\\mathcal{P}$ 的函数。这在第 2 部分已经做过了。对应于那个总是向右移动的图灵机的函数 $\\varphi_{e_{\\mathrm{loop}}}$ 在所有输入上都无定义，包括 $x=0$。因此，$\\varphi_{e_{\\mathrm{loop}}} \\notin \\mathcal{P}$。\n由于 $\\mathcal{P}$ 既不是空的也不是普适的，所以它是一个非平凡的性质。\n\n步骤 4：结论。\n集合 $D$ 是部分可计算函数的一个语义性的、非平凡性质的指标集。根据莱斯定理，$D$ 是一个不可判定的集合。\n\n最后，我们计算所要求的 $f(2024)$ 的值。\n根据推导出的闭式表达式，我们需要计算 $f(2024) = \\lceil \\sqrt{2024} \\rceil$。\n我们可以找到其平方能够框定 $2024$ 的整数。\n我们知道 $40^2 = 1600$ 且 $50^2 = 2500$。\n让我们试试 $45^2$：$45^2 = 2025$。\n让我们试试 $44^2$：$44^2 = (45 - 1)^2 = 45^2 - 2 \\cdot 45 + 1 = 2025 - 90 + 1 = 1936$。\n我们有不等式 $1936  2024  2025$，这等价于 $44^2  2024  45^2$。\n对所有部分取平方根，得到 $44  \\sqrt{2024}  45$。\n天花板函数 $\\lceil x \\rceil$ 给出大于或等于 $x$ 的最小整数。对于一个严格介于两个连续整数 $k$ 和 $k+1$ 之间的值 $x$，$\\lceil x \\rceil = k+1$。\n由于 $44  \\sqrt{2024}  45$，我们有 $\\lceil \\sqrt{2024} \\rceil = 45$。\n因此，$f(2024)=45$。", "answer": "$$\n\\boxed{45}\n$$", "id": "3048531"}]}