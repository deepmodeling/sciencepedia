{"hands_on_practices": [{"introduction": "要理解等谱流形，一个绝佳的起点是亲手计算一个简单几何形状的谱。这个练习将引导你推导矩形的狄利克雷-拉普拉斯算子的完整谱，这是一个基础但至关重要的计算。通过这个过程，你将掌握分离变量法等核心技巧，并直观地验证一个基本原则：等距同构的流形（如此处的矩形与其旋转版本）是等谱的 [@problem_id:3054031]。", "problem": "考虑矩形 $\\Omega=(0,a)\\times(0,b)$ 上的狄利克雷拉普拉斯算子，其中 $a>0$ 且 $b>0$。狄利克雷拉普拉斯算子是算子 $-\\Delta$，其中 $\\Delta=\\frac{\\partial^{2}}{\\partial x^{2}}+\\frac{\\partial^{2}}{\\partial y^{2}}$，作用于满足狄利克雷边界条件 $u|_{\\partial\\Omega}=0$ 的函数 $u:\\Omega\\to\\mathbb{R}$。狄利克雷特征值是这样的 $\\lambda>0$：存在一个非平凡解 $u$ 满足在 $\\Omega$ 内的偏微分方程 (PDE) $-\\Delta u=\\lambda u$ 以及边界条件 $u|_{\\partial\\Omega}=0$。使用分离变量法，并仅利用二阶线性常微分方程理论、正弦函数的正交性、以及在具有狄利克雷边界条件的区间上傅里叶正弦级数的完备性等基础工具，推导出 $\\Omega$ 的完整狄利克雷谱，并描述其如何依赖于 $a$ 和 $b$。然后，对于固定的 $t>0$，定义热迹\n$$\nH_{\\Omega}(t)=\\sum_{j=1}^{\\infty}\\exp(-t\\lambda_{j}),\n$$\n其中 $(\\lambda_{j})_{j\\in\\mathbb{N}}$ 是 $-\\Delta$ 在 $\\Omega$ 上的狄利克雷特征值的非递减序列（计入重数）。分析交换 $a$ 和 $b$（即考虑矩形 $(0,b)\\times(0,a)$）如何影响谱和热迹。计算\n$$\n\\Delta(t)=H_{(0,a)\\times(0,b)}(t)-H_{(0,b)\\times(0,a)}(t)\n$$\n的精确值，将其表示为 $t$, $a$ 和 $b$ 的函数。请用最简精确形式表示你的最终答案。无需四舍五入。", "solution": "该问题被验证为具有科学依据、适定且客观。它是偏微分方程谱理论中的一个标准问题，该理论是几何分析的一个子领域。所有必要的数据和条件均已提供，不存在矛盾或歧义。\n\n我们首先推导矩形 $\\Omega = (0,a) \\times (0,b)$ 上狄利克雷拉普拉斯算子的谱。特征值问题由在 $\\Omega$ 内的偏微分方程 (PDE)\n$$\n-\\Delta u = \\lambda u\n$$\n给出，其中 $\\Delta = \\frac{\\partial^2}{\\partial x^2} + \\frac{\\partial^2}{\\partial y^2}$，并带有狄利克雷边界条件 $u|_{\\partial\\Omega}=0$。这意味着在矩形边界上 $u(x,y)=0$。具体而言，$u(0,y)=u(a,y)=0$ 对所有 $y \\in [0,b]$ 成立，以及 $u(x,0)=u(x,b)=0$ 对所有 $x \\in [0,a]$ 成立。\n\n我们采用分离变量法，假设存在一个形式为 $u(x,y) = X(x)Y(y)$ 的非平凡解。将此代入偏微分方程，我们得到\n$$\n- \\left( \\frac{\\partial^2}{\\partial x^2} + \\frac{\\partial^2}{\\partial y^2} \\right) (X(x)Y(y)) = \\lambda X(x)Y(y)\n$$\n$$\n- \\left( X''(x)Y(y) + X(x)Y''(y) \\right) = \\lambda X(x)Y(y)\n$$\n两边同除以 $X(x)Y(y)$（这是允许的，因为我们在 $\\Omega$ 的内部寻找非平凡解），我们得到\n$$\n- \\frac{X''(x)}{X(x)} - \\frac{Y''(y)}{Y(y)} = \\lambda\n$$\n这个方程可以整理为\n$$\n- \\frac{X''(x)}{X(x)} = \\lambda + \\frac{Y''(y)}{Y(y)}\n$$\n左边只依赖于 $x$，而右边只依赖于 $y$。为了使这个等式对所有的 $(x,y) \\in \\Omega$ 都成立，两边都必须等于同一个常数，记为 $\\mu_1$。这得到了两个独立的常微分方程 (ODE)：\n$$\n1. \\quad - \\frac{X''(x)}{X(x)} = \\mu_1 \\implies X''(x) + \\mu_1 X(x) = 0\n$$\n$$\n2. \\quad \\lambda + \\frac{Y''(y)}{Y(y)} = \\mu_1 \\implies Y''(y) + (\\lambda - \\mu_1) Y(y) = 0\n$$\n我们记 $\\mu_2 = \\lambda - \\mu_1$。因此，拉普拉斯算子的特征值为 $\\lambda = \\mu_1 + \\mu_2$。\n\n现在我们应用边界条件。\n条件 $u(0,y) = X(0)Y(y) = 0$ 对所有 $y \\in (0,b)$ 成立，意味着 $X(0)=0$，因为对于一个非平凡解，$Y(y)$ 不会恒为零。\n类似地，$u(a,y)=X(a)Y(y)=0 \\implies X(a)=0$。\n条件 $u(x,0) = X(x)Y(0) = 0$ 对所有 $x \\in (0,a)$ 成立，意味着 $Y(0)=0$。\n类似地，$u(x,b)=X(x)Y(b)=0 \\implies Y(b)=0$。\n\n我们求解关于 $X(x)$ 的第一个ODE，其边界条件为 $X(0)=0$ 和 $X(a)=0$。\n$$\nX''(x) + \\mu_1 X(x) = 0\n$$\n如果 $\\mu_1 \\le 0$，唯一满足边界条件的解是平凡解 $X(x)=0$。因此，我们必须有 $\\mu_1 > 0$。令 $\\mu_1 = k^2$，其中某个 $k>0$。通解为 $X(x) = C_1 \\cos(kx) + C_2 \\sin(kx)$。\n应用边界条件：\n$X(0) = C_1 \\cos(0) + C_2 \\sin(0) = C_1 = 0$。\n$X(a) = C_2 \\sin(ka) = 0$。\n为了得到非平凡解，我们需要 $C_2 \\neq 0$，这意味着 $\\sin(ka)=0$。这在 $ka = m\\pi$ 时发生，其中 $m$ 是任意正整数 $m \\in \\mathbb{N}^+ = \\{1, 2, 3, \\dots\\}$。\n因此，$k$ 的可能值为 $k_m = \\frac{m\\pi}{a}$，对应的特征值 $\\mu_1$ 是\n$$\n\\mu_{1,m} = \\left(\\frac{m\\pi}{a}\\right)^2, \\quad m \\in \\mathbb{N}^+\n$$\n对应的特征函数为 $X_m(x) = \\sin\\left(\\frac{m\\pi x}{a}\\right)$（不计常数因子）。\n\n类似地，我们求解关于 $Y(y)$ 的第二个ODE，其边界条件为 $Y(0)=0$ 和 $Y(b)=0$。\n$$\nY''(y) + \\mu_2 Y(y) = 0\n$$\n如前所述，我们必须有 $\\mu_2 > 0$。令 $\\mu_2 = q^2$，其中某个 $q>0$。通解为 $Y(y) = D_1 \\cos(qy) + D_2 \\sin(qy)$。\n应用边界条件：\n$Y(0) = D_1 = 0$。\n$Y(b) = D_2 \\sin(qb) = 0$。\n为了得到非平凡解，我们需要 $\\sin(qb)=0$，这意味着 $qb=n\\pi$，其中 $n$ 是任意正整数 $n \\in \\mathbb{N}^+$。\n因此，$q$ 的可能值为 $q_n=\\frac{n\\pi}{b}$，特征值 $\\mu_2$ 是\n$$\n\\mu_{2,n} = \\left(\\frac{n\\pi}{b}\\right)^2, \\quad n \\in \\mathbb{N}^+\n$$\n对应的特征函数是 $Y_n(y) = \\sin\\left(\\frac{n\\pi y}{b}\\right)$。\n\n矩形 $\\Omega = (0,a)\\times(0,b)$ 上狄利克雷拉普拉斯算子的特征值 $\\lambda$ 是所有可能的正整数对 $(m,n)$ 对应的 $\\mu_{1,m}$ 和 $\\mu_{2,n}$ 的和，即 $\\lambda = \\mu_{1,m} + \\mu_{2,n}$。完整的狄利克雷谱是这些特征值的集合：\n$$\n\\left\\{ \\lambda_{m,n} = \\pi^2\\left(\\frac{m^2}{a^2} + \\frac{n^2}{b^2}\\right) \\mid m,n \\in \\mathbb{N}^+ \\right\\}\n$$\n对应的特征函数是 $u_{m,n}(x,y) = \\sin\\left(\\frac{m\\pi x}{a}\\right)\\sin\\left(\\frac{n\\pi y}{b}\\right)$。正弦级数的完备性确保我们找到了所有特征值。\n\n现在，我们分析交换 $a$ 和 $b$ 如何影响谱和热迹。令 $\\Omega_1 = (0,a) \\times (0,b)$ 和 $\\Omega_2 = (0,b) \\times (0,a)$。\n$\\Omega_1$ 的谱是集合 $S_1 = \\left\\{ \\pi^2\\left(\\frac{m^2}{a^2} + \\frac{n^2}{b^2}\\right) \\mid m,n \\in \\mathbb{N}^+ \\right\\}$。\n通过在推导中交换 $a$ 和 $b$ 的角色，立即可得 $\\Omega_2$ 的谱为\n$S_2 = \\left\\{ \\pi^2\\left(\\frac{m^2}{b^2} + \\frac{n^2}{a^2}\\right) \\mid m,n \\in \\mathbb{N}^+ \\right\\}$。\n\n让我们比较集合 $S_1$ 和 $S_2$。对于 $S_1$ 中的任意元素 $\\lambda_{m,n} = \\pi^2(\\frac{m^2}{a^2} + \\frac{n^2}{b^2})$，我们可以为 $S_2$ 中的一个元素选择整数下标 $m'=n$ 和 $n'=m$。这得到 $\\pi^2(\\frac{(m')^2}{b^2} + \\frac{(n')^2}{a^2}) = \\pi^2(\\frac{n^2}{b^2} + \\frac{m^2}{a^2})$，它与 $\\lambda_{m,n}$ 相同。因此，$S_1$ 中的每个特征值也都在 $S_2$ 中。\n反之，对于 $S_2$ 中的任意元素 $\\lambda'_{m',n'} = \\pi^2(\\frac{(m')^2}{b^2} + \\frac{(n')^2}{a^2})$，我们可以选择 $m=n'$ 和 $n=m'$ 在 $S_1$ 中找到完全相同的值。\n这在两组特征值之间建立了一一对应关系。此外，任何特征值 $\\lambda$ 的重数是产生 $\\lambda$ 的不同正整数对 $(m,n)$ 的数量。由于映射 $(m,n) \\leftrightarrow (n,m)$ 是 $\\mathbb{N}^+ \\times \\mathbb{N}^+$ 上的一个双射，所以这种对的数量对于两个矩形是相同的。因此，$\\Omega_1$ 和 $\\Omega_2$ 的谱，包括重数在内，是完全相同的。这两个矩形是等谱的。这是预料之中的，因为它们通过映射 $(x,y) \\mapsto (y,x)$ 是等距的。\n\n热迹 $H_{\\Omega}(t)$ 定义为对整个谱求和：\n$$\nH_{\\Omega}(t) = \\sum_{j=1}^{\\infty} \\exp(-t\\lambda_j)\n$$\n其中 $(\\lambda_j)$ 是所有特征值（计入重数）的列表。对于矩形 $\\Omega_1=(0,a)\\times(0,b)$，这可以写成关于下标 $(m,n)$ 的双重求和：\n$$\nH_{(0,a)\\times(0,b)}(t) = \\sum_{m=1}^{\\infty} \\sum_{n=1}^{\\infty} \\exp\\left[-t\\pi^2\\left(\\frac{m^2}{a^2} + \\frac{n^2}{b^2}\\right)\\right]\n$$\n对于矩形 $\\Omega_2=(0,b)\\times(0,a)$，热迹为：\n$$\nH_{(0,b)\\times(0,a)}(t) = \\sum_{m'=1}^{\\infty} \\sum_{n'=1}^{\\infty} \\exp\\left[-t\\pi^2\\left(\\frac{(m')^2}{b^2} + \\frac{(n')^2}{a^2}\\right)\\right]\n$$\n由于求和是对所有正整数对进行的，求和下标的名称是任意的。让我们在第二个表达式中将 $m'$ 重新标记为 $n$，将 $n'$ 重新标记为 $m$：\n$$\nH_{(0,b)\\times(0,a)}(t) = \\sum_{n=1}^{\\infty} \\sum_{m=1}^{\\infty} \\exp\\left[-t\\pi^2\\left(\\frac{n^2}{b^2} + \\frac{m^2}{a^2}\\right)\\right]\n$$\n由于级数的各项均为正，求和的顺序可以交换（Fubini-Tonelli 定理）：\n$$\nH_{(0,b)\\times(0,a)}(t) = \\sum_{m=1}^{\\infty} \\sum_{n=1}^{\\infty} \\exp\\left[-t\\pi^2\\left(\\frac{m^2}{a^2} + \\frac{n^2}{b^2}\\right)\\right]\n$$\n这个表达式与 $H_{(0,a)\\times(0,b)}(t)$ 的表达式完全相同。因此，\n$$\nH_{(0,a)\\times(0,b)}(t) = H_{(0,b)\\times(0,a)}(t)\n$$\n对所有 $t>0$, $a>0$ 和 $b>0$ 成立。\n\n最后，我们计算所求的差值：\n$$\n\\Delta(t) = H_{(0,a)\\times(0,b)}(t) - H_{(0,b)\\times(0,a)}(t)\n$$\n根据我们发现热迹是相同的这一结论，该差值为\n$$\n\\Delta(t) = 0\n$$", "answer": "$$\n\\boxed{0}\n$$", "id": "3054031"}, {"introduction": "在确认了等距同构意味着等谱之后，一个更深刻的问题自然而然地出现了：是否存在不等距但等谱的流形？这个问题，即马克·卡兹著名的“能听出鼓的形状吗？”，是谱几何学的核心。这个练习将引导你通过具体的群论计算，构造一个Sunada三元组，这是构建非等距等谱流形的强大代数方法 [@problem_id:3054467]。", "problem": "设 $M$ 是一个紧黎曼流形，$\\pi:\\widetilde{M}\\to M$ 是一个有限正规覆盖，其覆盖变换群为 $G\\cong S_4$。回顾一下，一个三元组 $(G,H,K)$ 被称为 Sunada 三元组，如果对于 $G$ 中的每个共轭类 $C\\subset G$，都有 $\\lvert H\\cap C\\rvert=\\lvert K\\cap C\\rvert$。该条件等价于置换表示作为 $G$-模的等式 $\\mathbb{C}[G/H]\\cong \\mathbb{C}[G/K]$，并且它意味着商空间 $\\widetilde{M}/H$ 和 $\\widetilde{M}/K$ 相对于 Laplace–Beltrami 算子是等谱的。\n\n在 $G=S_4$ 中进行计算。定义子群\n$$\nH=\\langle (1234),(13)\\rangle,\\qquad K=(12)\\,H\\,(12)^{-1}.\n$$\n仅使用群论的基本事实和 $S_4$ 中共轭类按轮换型的分类，通过对 $S_4$ 的每个共轭类 $C$ 计算数值 $\\lvert H\\cap C\\rvert$ 和 $\\lvert K\\cap C\\rvert$，来手工验证 $(G,H,K)$ 是一个 Sunada 三元组。特别地，列出共同的5元组值\n$$\n\\big(\\lvert H\\cap C_{\\text{id}}\\rvert,\\ \\lvert H\\cap C_{(2)}\\rvert,\\ \\lvert H\\cap C_{(3)}\\rvert,\\ \\lvert H\\cap C_{(2,2)}\\rvert,\\ \\lvert H\\cap C_{(4)}\\rvert\\big),\n$$\n其中 $C_{\\text{id}}$ 是单位元类，$C_{(2)}$ 是对换类，$C_{(3)}$ 是3-轮换类，$C_{(2,2)}$ 是双对换类，$C_{(4)}$ 是4-轮换类。将此5元组作为您的最终答案。\n\n你的最终答案必须是包含这五个整数的单行矩阵，按上述顺序排列。无需四舍五入。", "solution": "我们从对称群 $S_4$ 中共轭类的基本定义开始。$S_4$ 中的共轭类由轮换型决定，恰好有五个类：\n- $C_{\\text{id}}=\\{e\\}$，\n- $C_{(2)}=$ 所有对换，共 $6$ 个，\n- $C_{(3)}=$ 所有3-轮换，共 $8$ 个，\n- $C_{(2,2)}=$ 所有双对换，共 $3$ 个，\n- $C_{(4)}=$ 所有4-轮换，共 $6$ 个。\n\n根据构造，$K=(12)\\,H\\,(12)^{-1}$ 在 $S_4$ 中与 $H$ 共轭。因此，对于每个共轭类 $C\\subset S_4$，都有 $\\lvert H\\cap C\\rvert=\\lvert K\\cap C\\rvert$，因为共轭运算保持轮换型，并导出双射 $H\\to K$。因此，只需计算 $H$ 的计数即可。\n\n我们计算 $H=\\langle r,s\\rangle$ 的元素，其中 $r=(1234)$，$s=(13)$。由 $r$ 和 $s$ 生成的子群是一个8阶二面体群，因为 $srs^{-1}=r^{-1}$。$H$ 的元素为\n$$\ne,\\ r,\\ r^2,\\ r^3,\\ s,\\ rs,\\ r^2s,\\ r^3s.\n$$\n我们现在确定它们的轮换型：\n- $e$ 是单位元，所以 $e\\in C_{\\text{id}}$。\n- $r=(1234)$ 是一个4-轮换，所以 $r\\in C_{(4)}$。\n- $r^2=(1234)^2=(13)(24)$ 是一个双对换，所以 $r^2\\in C_{(2,2)}$。\n- $r^3=(1234)^3=(1432)$ 是一个4-轮换，所以 $r^3\\in C_{(4)}$。\n- $s=(13)$ 是一个对换，所以 $s\\in C_{(2)}$。\n- $rs=(1234)(13)$ 通过复合计算（先应用 $(13)$，再应用 $(1234)$）。作用于 $1$，$1\\mapsto 3\\mapsto 4$；作用于 $4$，$4\\mapsto 4\\mapsto 1$；作用于 $2$，$2\\mapsto 2\\mapsto 3$；作用于 $3$，$3\\mapsto 1\\mapsto 2$。因此 $rs=(14)(23)$，是一个双对换，所以 $rs\\in C_{(2,2)}$。\n- $r^2s=(13)(24)\\,(13)$ 的计算类似（先应用 $(13)$，再应用 $(13)(24)$）。作用于 $2$，$2\\mapsto 2\\mapsto 4$；作用于 $4$，$4\\mapsto 4\\mapsto 2$；作用于 $1$，$1\\mapsto 3\\mapsto 1$；作用于 $3$，$3\\mapsto 1\\mapsto 3$。因此 $r^2s=(24)$，是一个对换，所以 $r^2s\\in C_{(2)}$。\n- $r^3s=(1432)(13)$，通过类似的计算，可以得到 $r^3s=(12)(34)$，是一个双对换，所以 $r^3s\\in C_{(2,2)}$。\n\n按共轭类对 $H$ 的元素进行汇总计数：\n- $C_{\\text{id}}$：恰好 $1$ 个元素 ($e$)。\n- $C_{(2)}$：恰好 $2$ 个元素 ($(13)$ 和 $(24)$)。\n- $C_{(3)}$：$H$ 中没有元素是3-轮换，所以为 $0$。\n- $C_{(2,2)}$：恰好 $3$ 个元素 ($(13)(24)$、$(14)(23)$、$(12)(34)$)。\n- $C_{(4)}$：恰好 $2$ 个元素 ($(1234)$ 和 $(1432)$)。\n\n因此，$H$ 的5元组是 $(1,2,0,3,2)$。由于 $K$ 与 $H$ 共轭，因此对 $K$ 也成立相同的计数。因此，对于 $S_4$ 中的每个共轭类 $C$，都有 $\\lvert H\\cap C\\rvert=\\lvert K\\cap C\\rvert$，所以 $(G,H,K)$ 是一个 Sunada 三元组。\n\n所要求的行矩阵，按顺序 $(C_{\\text{id}}, C_{(2)}, C_{(3)}, C_{(2,2)}, C_{(4)})$ 排列，是 $(1,2,0,3,2)$。", "answer": "$$\\boxed{\\begin{pmatrix}1  2  0  3  2\\end{pmatrix}}$$", "id": "3054467"}, {"introduction": "理论推导是理解概念的基础，但对于复杂形状，解析解往往难以获得。此时，数值方法成为连接理论与实践的桥梁。这个动手实践将要求你编写一段程序，使用有限差分法来近似计算多边形区域的拉普拉斯算子特征值 [@problem_id:3054056]。通过这个计算练习，你不仅能将抽象的谱理论应用于具体问题，还能亲手验证关于等谱性的理论猜想，从而加深理解。", "problem": "你需要编写一个完整、可运行的程序，用于数值逼近平坦多边形域上拉普拉斯算子的低频狄利克雷特征值，并使用这些近似值来评估两个候选“鼓”的基于移植的等谱性论断。整个工作应在纯数学环境中进行：拉普拉斯算子、狄利克雷边界条件和有限差分方法离散化。不涉及任何物理单位。\n\n背景与基础：对于一个有界域 $D \\subset \\mathbb{R}^2$，其边界足够正则，拉普拉斯算子的狄利克雷特征值问题旨在寻找非平凡函数 $u \\in H_0^1(D)$ 和标量 $\\lambda \\in \\mathbb{R}$，使得\n$$\n-\\Delta u = \\lambda u \\quad \\text{in } D, \\qquad u|_{\\partial D} = 0.\n$$\n其谱由一个离散、无界、正的序列 $0 < \\lambda_1 \\le \\lambda_2 \\le \\cdots \\to \\infty$ 构成，且仅在无穷远处累积。如果两个域 $D_1$ 和 $D_2$ 的谱（计入重数）重合，则称它们是等谱的。“移植”构造法为不同域等谱的情况提供了非平凡的例子。\n\n待使用的数值方法：你必须使用标准的五点有限差分格式，在网格尺寸为 $h > 0$ 的均匀笛卡尔网格上，对带有狄利克雷边界条件的算子 $-\\Delta$ 进行近似。令 $\\mathcal{G}_h$ 为多边形包围盒中的网格点集，令 $I_h \\subset \\mathcal{G}_h$ 为严格位于多边形域 $D$ 内部的网格点集。离散狄利克雷拉普拉斯算子 $L_h$ 作用于函数 $u_h : I_h \\to \\mathbb{R}$ 的方式为\n$$\n(L_h u_h)(x) = \\frac{1}{h^2}\\left(4 u_h(x) - \\sum_{y \\in N(x) \\cap I_h} u_h(y)\\right),\n$$\n其中 $N(x)$ 是 $x$ 在 $\\mathcal{G}_h$ 中的四个沿坐标轴相邻的邻点，$I_h$ 之外的邻点被视为值为 0 的边界点。离散特征值问题是\n$$\nL_h u_h = \\lambda_h u_h,\n$$\n当 $h \\to 0$ 时，其最小的正特征值 $\\lambda_h$ 逼近连续特征值 $\\lambda$。\n\n算法要求：\n- 实现一个点在多边形内测试，对于一个由其顶点按逆时针顺序指定的简单多边形，判断哪些网格点属于 $I_h$。\n- 使用五点差分格式，在 $I_h$ 上构建 $L_h$ 的稀疏矩阵。\n- 使用一个可靠的、配合位移求逆方法的稀疏对称特征值求解器，为给定的多边形域计算 $k$ 个最小的正特征值 $\\lambda_{h,1} \\le \\cdots \\le \\lambda_{h,k}$。\n- 给定两个域 $D_1, D_2$，如果在容差 $\\tau$ 下满足以下条件，则声明它们在数值上是等谱的：\n$$\n\\max_{1 \\le i \\le k} \\frac{\\lvert \\lambda^{(1)}_{h,i} - \\lambda^{(2)}_{h,i} \\rvert}{\\max\\{ \\lambda^{(1)}_{h,i}, \\lambda^{(2)}_{h,i} \\}} \\le \\tau.\n$$\n\n测试套件：使用网格尺寸 $h = 0.05$ 并为每个域计算前 $k = 6$ 个特征值。以容差 $\\tau = 10^{-3}$ 评估以下四种情况：\n\n- 情况 A（通过等距变换进行的健全性检查）：$D_1$ 是具有以下顶点的 L 形多边形\n  $$\n  (0,0),\\ (2,0),\\ (2,1),\\ (1,1),\\ (1,2),\\ (0,2),\n  $$\n  而 $D_2$ 是通过将 $D_1$ 绕点 $(1,1)$ 逆时针旋转 $90^\\circ$ 得到的。在指定的 $h$ 下，这对域应在数值上是等谱的。\n- 情况 B（候选移植对，预期会失败）：$D_1$ 与情况 A 中的 L 形多边形相同，而 $D_2$ 是具有以下顶点的 T 形多边形\n  $$\n  (0,0),\\ (2,0),\\ (2,0.5),\\ (1.25,0.5),\\ (1.25,2),\\ (0.75,2),\\ (0.75,0.5),\\ (0,0.5).\n  $$\n  这是一对非平凡的候选域；你必须测试其数值谱是否在容差范围内匹配。\n- 情况 C（面积相等控制组，预期为非等谱）：$D_1$ 是具有以下顶点的单位正方形\n  $$\n  (0,0),\\ (1,0),\\ (1,1),\\ (0,1),\n  $$\n  而 $D_2$ 是具有以下顶点的矩形\n  $$\n  (0,0),\\ (2,0),\\ (2,0.5),\\ (0,0.5),\n  $$\n  其面积与单位正方形相同。这对域不应在数值上是等谱的。\n- 情况 D（恒等性检查）：$D_1$ 和 $D_2$ 都是单位正方形。这对域必须在数值上是等谱的。\n\n最终输出格式：你的程序应生成一行输出，其中包含一个由四个布尔值组成的列表，分别对应情况 A、B、C 和 D，指示每对域在使用前 $k$ 个特征值和容差 $\\tau$ 的条件下是否数值等谱。输出必须是格式完全为\n[bool_A,bool_B,bool_C,bool_D]\n的单行文本，其中布尔字面量写作 True 或 False。", "solution": "用户提供的问题是数值谱几何中一个明确定义的任务。它要求对几对平面多边形域的等谱性进行数值验证。方法论是预先指定的：使用五点有限差分格式对连续的拉普拉斯-狄利克雷特征值问题进行离散化，随后求解所得的矩阵特征值问题。该问题在科学上是合理的，内容是自洽的，算法上是明确的。因此，它是有效的，下面提供了解决方案。\n\n该解决方案通过开发一个数值程序来实现，该程序为给定的多边形域 $D$ 计算狄利克雷拉普拉斯算子的前 $k$ 个最小特征值。然后将此程序应用于四个指定测试用例中的每个域，并对所得的谱进行比较。\n\n整体算法包括四个主要阶段：\n1.  **域离散化**：在域上叠加一个均匀的笛卡尔网格。识别严格位于多边形内部的网格点。\n2.  **矩阵构建**：基于内部网格点的连通性，将离散拉普拉斯算子 $L_h$ 构建为一个稀疏矩阵。\n3.  **特征值计算**：使用专门的数值求解器计算所得矩阵的特征值。\n4.  **等谱性测试**：使用指定的相对误差度量，比较成对域的计算出的特征值。\n\n每个步骤详述如下。\n\n**1. 域离散化与内部点识别**\n\n给定一个由其顶点定义的多边形，我们首先确定一个包围盒。然后用间距为 $h$ 的均匀笛卡尔网格点填充此盒。令这些网格点的集合为 $\\mathcal{G}_h$。核心任务是识别出严格位于域 $D$ 内部的点集子集 $I_h \\subset \\mathcal{G}_h$。\n\n这一识别过程通过对每个网格点 $p \\in \\mathcal{G}_h$ 进行两步式的“点在多边形内”测试来完成：\n- **边界检查**：首先，我们判断 $p$ 是否位于边界 $\\partial D$ 上。如果一个点与多边形的一条边共线且位于该边端点之间，则该点在边界上。由于浮点数运算，此检查在一个小的容差 $\\epsilon$ 下进行。如果 $p$ 在边界上，则它不属于严格内部，并从 $I_h$ 中排除。\n- **内部检查**：如果 $p$ 不在边界上，我们使用环绕数算法来判断它是否在内部。该算法计算多边形围绕点 $p$ 的环绕数。对于顶点按逆时针顺序排列的简单多边形，内部点的环绕数为 $1$，外部点的环绕数为 $0$。因此，如果一个点 $p$ 的环绕数非零，它就被添加到 $I_h$ 中。\n\n这个稳健的两阶段过程能正确地识别出 $N = |I_h|$ 个内部网格点的集合。然后将这些点映射到从 $0$ 到 $N-1$ 的整数索引，以方便矩阵的构建。\n\n**2. 离散拉普拉斯算子的矩阵构建**\n\n连续算子 $-\\Delta$ 由离散拉普拉斯算子 $L_h$ 逼近。$L_h$ 作用于在内部网格点 $I_h$ 上定义的函数 $u_h$ 的方式由五点差分格式给出：\n$$\n(L_h u_h)(x) = \\frac{1}{h^2}\\left(4 u_h(x) - \\sum_{y \\in N(x) \\cap I_h} u_h(y)\\right)\n$$\n其中 $N(x)$ 是 $x$ 的四个沿坐标轴相邻的邻点。狄利克雷边界条件 $u|_{\\partial D} = 0$ 通过只对同在 $I_h$ 中的邻点求和而被隐式地强制执行。\n\n这个线性系统可以表示为一个矩阵方程。将 $u_h$ 在 $N$ 个内部点上的值排列成一个向量 $\\mathbf{u} \\in \\mathbb{R}^N$。离散特征值问题 $L_h u_h = \\lambda_h u_h$ 变为矩阵特征值问题 $A \\mathbf{u} = (h^2 \\lambda_h) \\mathbf{u}$，其中 $A$ 是一个 $N \\times N$ 的稀疏矩阵。\n\n矩阵 $A$ 的构建如下：\n- 对于每个索引为 $i \\in \\{0, \\dots, N-1\\}$ 的内部点 $p_i$，对角线元素为 $A_{ii} = 4$。\n- 对于 $p_i$ 的每个邻点 $p_j$，如果它也是一个内部点（索引为 $j$），则非对角线元素为 $A_{ij} = -1$。\n- 所有其他元素均为零。\n\n所得的矩阵 $A$ 是稀疏、对称且正定的。\n\n**3. 特征值计算**\n\n任务简化为寻找矩阵问题 $A \\mathbf{u} = \\mu \\mathbf{u}$ 的最小特征值，其中 $\\mu = h^2 \\lambda_h$。由于 $A$ 是一个大型稀疏对称矩阵，可以使用像 Lanczos 算法这样的迭代方法来高效求解。`scipy.sparse.linalg.eigsh` 函数非常适合此目的。\n\n为了找到原始问题的 $k$ 个最小特征值，我们寻求 $A$ 的 $k$ 个最小特征值 $\\mu$。这可以通过调用 `eigsh` 并设置参数 `which='SM'` 来完成，该参数指示求解器寻找模最小的特征值。对于正定矩阵 $A$，这些就是最小的正特征值。在获得 $A$ 的特征值 $\\mu_1, \\dots, \\mu_k$ 后，离散拉普拉斯算子 $L_h$ 的相应特征值可通过关系式 $\\lambda_{h,i} = \\mu_i / h^2$ 恢复。\n\n**4. 等谱性评估**\n\n对于测试套件中的每对域 $(D_1, D_2)$，我们计算它们各自的前 $k$ 个特征值集合 $\\{\\lambda_{h,i}^{(1)}\\}_{i=1}^k$ 和 $\\{\\lambda_{h,i}^{(2)}\\}_{i=1}^k$。如果对应特征值之间的最大相对差异在给定的容差 $\\tau$ 之内，则声明这两个域在数值上是等谱的。条件是：\n$$\n\\max_{1 \\le i \\le k} \\frac{\\lvert \\lambda^{(1)}_{h,i} - \\lambda^{(2)}_{h,i} \\rvert}{\\max\\{ \\lambda^{(1)}_{h,i}, \\lambda^{(2)}_{h,i} \\}} \\le \\tau\n$$\n对四种情况中的每一种都执行此过程，并将布尔结果收集到一个列表中作为最终输出。使用的参数是 $h = 0.05$，$k=6$ 和 $\\tau=10^{-3}$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import sparse\nfrom scipy.sparse.linalg import eigsh\n\ndef solve():\n    \"\"\"\n    Main function to run the isospectrality tests for all four cases.\n    \"\"\"\n    \n    # --- Problem Parameters ---\n    h = 0.05\n    k = 6\n    tau = 1e-3\n\n    # --- Test Case Definitions ---\n\n    # Case A: L-shape vs. Rotated L-shape\n    l_shape_vertices = np.array([\n        (0.0, 0.0), (2.0, 0.0), (2.0, 1.0), (1.0, 1.0), (1.0, 2.0), (0.0, 2.0)\n    ])\n    # Rotation by 90 deg CCW about (1,1): (x,y) -> (1-(y-1), 1+(x-1)) = (2-y, x)\n    rotation_center = np.array([1.0, 1.0])\n    rotated_l_shape_vertices = np.array([\n        (rotation_center[0] - (v[1] - rotation_center[1]), rotation_center[1] + (v[0] - rotation_center[0]))\n        for v in l_shape_vertices\n    ])\n    \n    # Case B: L-shape vs. T-shape\n    t_shape_vertices = np.array([\n        (0.0, 0.0), (2.0, 0.0), (2.0, 0.5), (1.25, 0.5), (1.25, 2.0),\n        (0.75, 2.0), (0.75, 0.5), (0.0, 0.5)\n    ])\n\n    # Case C: Unit square vs. Rectangle of same area\n    unit_square_vertices = np.array([\n        (0.0, 0.0), (1.0, 0.0), (1.0, 1.0), (0.0, 1.0)\n    ])\n    rectangle_vertices = np.array([\n        (0.0, 0.0), (2.0, 0.0), (2.0, 0.5), (0.0, 0.5)\n    ])\n\n    # Case D: Unit square vs. itself\n    # Uses unit_square_vertices from Case C\n\n    test_cases = [\n        {\"D1\": l_shape_vertices, \"D2\": rotated_l_shape_vertices},\n        {\"D1\": l_shape_vertices, \"D2\": t_shape_vertices},\n        {\"D1\": unit_square_vertices, \"D2\": rectangle_vertices},\n        {\"D1\": unit_square_vertices, \"D2\": unit_square_vertices}\n    ]\n\n    all_results = []\n\n    # Memoization to avoid recomputing eigenvalues for the same shape\n    memo = {}\n\n    for case in test_cases:\n        D1_key = tuple(map(tuple, case[\"D1\"]))\n        D2_key = tuple(map(tuple, case[\"D2\"]))\n        \n        if D1_key not in memo:\n            memo[D1_key] = compute_eigenvalues(case[\"D1\"], h, k)\n        if D2_key not in memo:\n            memo[D2_key] = compute_eigenvalues(case[\"D2\"], h, k)\n            \n        eigs1 = memo[D1_key]\n        eigs2 = memo[D2_key]\n        \n        if len(eigs1)  k or len(eigs2)  k:\n            # Handle cases where not enough eigenvalues are found (e.g., small domains)\n            # Declaring non-isospectral is a safe action.\n            is_isospectral = False\n        else:\n            max_rel_diff = np.max(\n                np.abs(eigs1 - eigs2) / np.maximum(eigs1, eigs2)\n            )\n            is_isospectral = max_rel_diff = tau\n        \n        all_results.append(is_isospectral)\n\n    print(f\"[{','.join(map(str, all_results))}]\")\n\n\ndef compute_eigenvalues(polygon_vertices, h, k):\n    \"\"\"\n    Computes the k smallest Dirichlet eigenvalues for a polygonal domain.\n    \"\"\"\n    # Floating point tolerance for geometric checks\n    epsilon = 1e-9\n\n    def is_on_boundary(p, vertices):\n        \"\"\"Check if a point p is on the boundary of the polygon.\"\"\"\n        for i in range(len(vertices)):\n            p1 = vertices[i]\n            p2 = vertices[(i + 1) % len(vertices)]\n            # Check for collinearity using cross product\n            cross_product = (p[1] - p1[1]) * (p2[0] - p1[0]) - \\\n                            (p[0] - p1[0]) * (p2[1] - p1[1])\n            if abs(cross_product)  epsilon:\n                # Check if point is between segment endpoints\n                dot_product = (p[0] - p1[0]) * (p2[0] - p1[0]) + \\\n                              (p[1] - p1[1]) * (p2[1] - p1[1])\n                squared_length = (p2[0] - p1[0])**2 + (p2[1] - p1[1])**2\n                if 0 = dot_product = squared_length:\n                    return True\n        return False\n\n    def is_inside(p, vertices):\n        \"\"\"\n        Check if a point p is strictly inside a polygon using the winding number algorithm.\n        This assumes the point is NOT on the boundary.\n        \"\"\"\n        wn = 0  # Winding number\n        for i in range(len(vertices)):\n            p1 = vertices[i]\n            p2 = vertices[(i + 1) % len(vertices)]\n            if p1[1] = p[1]:\n                if p2[1] > p[1]:  # An upward crossing\n                    # is_left > 0 for p left of edge\n                    is_left = (p2[0] - p1[0]) * (p[1] - p1[1]) - \\\n                              (p[0] - p1[0]) * (p2[1] - p1[1])\n                    if is_left > 0:\n                        wn += 1\n            elif p2[1] = p[1]:  # A downward crossing\n                is_left = (p2[0] - p1[0]) * (p[1] - p1[1]) - \\\n                          (p[0] - p1[0]) * (p2[1] - p1[1])\n                if is_left  0:\n                    wn -= 1\n        return wn != 0\n\n    # 1. Grid generation and interior point identification\n    xmin, ymin = np.min(polygon_vertices, axis=0) - 2 * h\n    xmax, ymax = np.max(polygon_vertices, axis=0) + 2 * h\n\n    # Use indices for grid points to avoid float precision issues\n    x_indices = np.arange(round(xmin / h), round(xmax / h) + 1)\n    y_indices = np.arange(round(ymin / h), round(ymax / h) + 1)\n    \n    interior_grid_indices = []\n    for i in x_indices:\n        for j in y_indices:\n            px, py = i * h, j * h\n            point = np.array([px, py])\n            if not is_on_boundary(point, polygon_vertices) and is_inside(point, polygon_vertices):\n                interior_grid_indices.append((i, j))\n\n    if len(interior_grid_indices) = k:\n        return np.array([]) # Not enough interior points\n\n    grid_idx_to_matrix_idx = {idx: i for i, idx in enumerate(interior_grid_indices)}\n    N = len(interior_grid_indices)\n\n    # 2. Matrix assembly\n    A = sparse.lil_matrix((N, N))\n    for matrix_idx, grid_idx in enumerate(interior_grid_indices):\n        i, j = grid_idx\n        A[matrix_idx, matrix_idx] = 4.0\n        \n        neighbors = [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]\n        for neighbor_idx in neighbors:\n            if neighbor_idx in grid_idx_to_matrix_idx:\n                neighbor_matrix_idx = grid_idx_to_matrix_idx[neighbor_idx]\n                A[matrix_idx, neighbor_matrix_idx] = -1.0\n    \n    A = A.tocsc()\n    \n    # 3. Eigenvalue computation\n    # Find eigenvalues of A, which are mu = lambda * h^2\n    # eigsh(which='SM') finds eigenvalues with smallest magnitude.\n    # Sigma is implicitly 0.\n    try:\n        # Use A.shape[0] - 1 for k if k is too large for matrix dimension\n        num_eigs_to_find = min(k, N - 1)\n        mu, _ = eigsh(A, k=num_eigs_to_find, which='SM')\n    except Exception:\n        # Failsafe for convergence issues\n        return np.array([])\n    \n    # Sort eigenvalues by magnitude and get the smallest ones\n    mu = np.sort(mu)\n    \n    # 4. Convert to eigenvalues of the Laplacian\n    lambdas = mu / (h**2)\n    \n    return lambdas\n\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3054056"}]}