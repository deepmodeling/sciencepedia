{"hands_on_practices": [{"introduction": "证明一个集合是可数的，等价于能够将其元素一一列出。这个练习让你亲手实践一种经典的枚举方法，即对角线法，来具体计算一个元素在可数集 $\\mathbb{N} \\times \\mathbb{N}$ 列表中的确切位置，从而将抽象的基数概念转化为具体的计算问题 [@problem_id:2289788]。", "problem": "考虑一种系统地枚举所有正整数有序对 $(m, n)$ 的方法，其中 $m, n \\in \\mathbb{N} = \\{1, 2, 3, \\dots\\}$。该枚举过程按数对的和 $s = m+n$ 的值进行分组。数对首先按其和 $s$ 的递增值排序。在和相同的每一组数对中，数对按其第一个分量 $m$ 的递增值排序。\n\n这个过程定义了一个双射 $f: \\mathbb{N} \\to \\mathbb{N} \\times \\mathbb{N}$，其中 $f(k)$ 是此枚举中的第 $k$ 个数对。例如：\n- 和为 $s=2$ 的组仅包含 $(1, 1)$。\n- 和为 $s=3$ 的组按顺序包含 $(1, 2)$ 和 $(2, 1)$。\n- 和为 $s=4$ 的组按顺序包含 $(1, 3)$、$(2, 2)$ 和 $(3, 1)$。\n\n因此，数对序列以 $f(1) = (1, 1)$、$f(2) = (1, 2)$、$f(3) = (2, 1)$、$f(4) = (1, 3)$、$f(5) = (2, 2)$ 等开始。\n\n你的任务是确定在此枚举中对应于第 100 个位置的特定有序对 $(m, n)$。也就是说，求出数对 $(m, n)$ 使得 $f(100) = (m, n)$。", "solution": "我们按和 $s=m+n$ 的递增顺序枚举数对，在每个固定的 $s$ 值内，我们列出 $(m,n)$，其中 $m=1,2,\\dots,s-1$ 且 $n=s-m$。对于一个给定的 $s$，恰好有 $s-1$ 个数对。令 $T(S)$ 表示和至多为 $S$ 的数对总数。那么\n$$\nT(S)=\\sum_{s=2}^{S}(s-1)=\\sum_{t=1}^{S-1}t=\\frac{(S-1)S}{2}.\n$$\n我们需要求得最小的整数 $S$ 使得 $T(S)\\geq 100$，即\n$$\n\\frac{(S-1)S}{2}\\geq 100 \\quad\\Longleftrightarrow\\quad S^{2}-S-200\\geq 0.\n$$\n方程 $S^{2}-S-200=0$ 的根是\n$$\nS=\\frac{1\\pm \\sqrt{1+800}}{2}=\\frac{1\\pm \\sqrt{801}}{2}.\n$$\n由于 $\\sqrt{801}$ 略大于 $\\sqrt{784}=28$，我们有 $S \\approx \\frac{1 \\pm 28.3}{2}$。我们需要 $S \\ge \\frac{1+28.3}{2} \\approx 14.65$。因此，满足不等式的最小整数 $S$ 是 $15$。所以 $f(100)$ 位于和为 $s=15$ 的组中。在此组之前的数对数量为\n$$\nT(14)=\\frac{14\\cdot 13}{2}=91,\n$$\n所以在和为 $s=15$ 的组中，$f(100)$ 是第 $(100-91)=9$ 个数对。由于组内是按 $m$ 从 $m=1$ 开始递增排序的，第 $r$ 个数对有 $m=r$ 和 $n=S-r$。因此对于 $r=9$ 和 $S=15$，\n$$\nm=9,\\quad n=15-9=6.\n$$\n因此，$f(100)=(9,6)$。", "answer": "$$\\boxed{(9, 6)}$$", "id": "2289788"}, {"introduction": "无限集的一些性质常常与我们的直觉相悖，例如，从一个无限集中移除一个点，它的大小（基数）会改变吗？这个问题 [@problem_id:1285592] 引导你构造一个在闭区间 $[0,1]$ 和半开区间 $[0,1)$ 之间的显式双射。这个巧妙的构造类似于著名的“希尔伯特旅馆”悖论，它直观地展示了如何通过“腾挪”一个可数子集来容纳或移除元素，而不改变集合的基数。", "problem": "在集合论中，如果两个集合之间存在一个双射，则称它们具有相同的基数。双射是一个既是一对一（单射）又是满射的函数。\n\n考虑闭区间 $S = [0,1]$ 和半开区间 $T = [0,1)$。这两个集合看起来非常相似，仅相差一个点 $\\{1\\}$。\n\n以下哪个函数定义描述了一个从 $S$ 到 $T$ 的双射 $f: S \\to T$？\n\nA. $f(x) = x$\n\nB. $f(x) = \\begin{cases} x  \\text{若 } x \\in [0,1) \\\\ 0  \\text{若 } x = 1 \\end{cases}$\n\nC. $f(x) = \\frac{x}{2}$\n\nD. 设集合 $A$ 定义为 $A = \\{ \\frac{1}{n} \\mid n \\in \\mathbb{N}, n \\ge 1 \\}$。函数定义如下：\n$$ f(x) = \\begin{cases} \\frac{1}{n+1}  \\text{若 } x = \\frac{1}{n} \\text{ 对于某个 } n \\in \\mathbb{N}, n \\ge 1 \\\\ x  \\text{若 } x \\in S \\setminus A \\end{cases} $$", "solution": "要确定哪个函数是从集合 $S=[0,1]$ 到集合 $T=[0,1)$ 的双射，我们必须分析每个选项，看它是否满足从 $S$ 映射到 $T$ 的函数的性质，以及它是否既是单射又是满射。\n\n选项 A: $f(x) = x$。\n一个函数 $f: S \\to T$ 必须将定义域 $S$ 中的每个元素映射到陪域 $T$ 中的一个元素。我们考虑点 $x=1$，它在定义域 $S$ 中。该函数给出 $f(1)=1$。然而，陪域是 $T=[0,1)$，它不包含值 $1$。因此，这个定义没有描述一个从 $S$ 到 $T$ 的函数。\n\n选项 B: $f(x) = \\begin{cases} x  \\text{若 } x \\in [0,1) \\\\ 0  \\text{若 } x = 1 \\end{cases}$。\n这个函数将 $S$ 中的每个元素映射到 $T$ 中的一个元素。对于 $x \\in [0,1)$，$f(x)=x \\in [0,1) = T$。对于 $x=1$，$f(1)=0 \\in T$。所以这是一个从 $S$ 到 $T$ 的有效函数。\n现在，我们来检查单射性。如果不同的输入产生不同的输出，则函数是单射的。考虑输入 $x_1=0$ 和 $x_2=1$。它们是 $S$ 中不同的元素。\n$f(x_1) = f(0) = 0$。\n$f(x_2) = f(1) = 0$。\n由于 $x_1 \\ne x_2$ 但 $f(x_1) = f(x_2)$，该函数不是单射。因此，它不是一个双射。\n\n选项 C: $f(x) = \\frac{x}{2}$。\n这个函数将 $S=[0,1]$ 中的每个元素映射到 $T=[0,1)$ 中的一个元素。如果 $x \\in [0,1]$，那么 $f(x) = x/2 \\in [0, 1/2]$。因为 $[0, 1/2]$ 是 $[0,1)$ 的一个子集，所以这是一个从 $S$ 到 $T$ 的有效函数。\n我们来检查满射性。如果陪域 $T$ 中的每个元素都是定义域 $S$ 中至少一个元素的像，则函数是满射的。该函数的值域是所有可能输出的集合，即 $[0, 1/2]$。\n考虑元素 $y = 0.75$，它在陪域 $T=[0,1)$ 中。要使 $f$ 是满射的，必须存在一个 $x \\in S$ 使得 $f(x) = 0.75$。这意味着 $x/2 = 0.75$，解得 $x=1.5$。然而，$x=1.5$ 不在定义域 $S=[0,1]$ 中。因此，定义域中没有元素映射到 $0.75$。该函数不是满射的。因此，它不是一个双射。\n\n选项 D: 设 $A = \\{1, 1/2, 1/3, \\ldots \\}$。$f(x) = \\begin{cases} \\frac{1}{n+1}  \\text{若 } x = \\frac{1}{n} \\in A \\\\ x  \\text{若 } x \\in S \\setminus A \\end{cases}$。\n这个构造是处理单个“多余”点的经典例子，常被比作 Hilbert 旅馆悖论。\n\n首先，我们检查它是否是一个从 $S$ 到 $T$ 的有效函数。\n如果 $x\\in A$，则对某个正整数 $n$ 有 $x=1/n$。输出为 $f(x)=1/(n+1)$。由于 $n\\ge1$，我们有 $n+1 \\ge 2$，所以 $0  1/(n+1) \\le 1/2$。这个输出在 $T=[0,1)$ 中。\n如果 $x \\in S \\setminus A$，那么 $x \\in [0,1]$ 但 $x$ 不是 $1/n$ 的形式。这意味着 $x \\in [0,1)$。对于这些值，$f(x)=x$，并且由于 $x \\in [0,1)$，输出在 $T$ 中。\n所以，该函数正确地将 $S$ 的所有元素映射到 $T$ 的元素。\n\n其次，我们来检查单射性。设 $x_1, x_2 \\in S$ 且 $f(x_1) = f(x_2)$。\n情况1：$x_1, x_2 \\in A$。那么 $x_1=1/n_1$ 且 $x_2=1/n_2$。$f(x_1)=1/(n_1+1)$ 且 $f(x_2)=1/(n_2+1)$。如果 $f(x_1)=f(x_2)$，则 $1/(n_1+1)=1/(n_2+1)$，这意味着 $n_1=n_2$，所以 $x_1=x_2$。\n情况2：$x_1, x_2 \\in S \\setminus A$。那么 $f(x_1)=x_1$ 且 $f(x_2)=x_2$。如果 $f(x_1)=f(x_2)$，则 $x_1=x_2$。\n情况3：$x_1 \\in A$ 且 $x_2 \\in S \\setminus A$。那么对某个 $n_1 \\ge 1$ 有 $f(x_1)=1/(n_1+1)$。这意味着 $f(x_1)$ 在集合 $\\{1/2, 1/3, 1/4, \\ldots \\}$ 中。另一方面，$f(x_2)=x_2$。由于 $x_2 \\in S \\setminus A$，$x_2$ 不可能在集合 $\\{1/2, 1/3, 1/4, \\ldots \\}$ 中。因此，$f(x_1)$ 不可能等于 $f(x_2)$。\n在所有 $f(x_1) = f(x_2)$ 的情况下，我们必然有 $x_1 = x_2$。该函数是单射的。\n\n第三，我们来检查满射性。设 $y \\in T=[0,1)$。我们需要找到一个 $x \\in S$ 使得 $f(x)=y$。\n情况1：$y$ 在集合 $\\{1/2, 1/3, 1/4, \\ldots \\}$ 中。那么对某个整数 $k \\ge 2$ 有 $y=1/k$。我们可以写成 $k=m+1$，其中 $m=k-1 \\ge 1$。要得到输出 $y=1/(m+1)$，我们需要找到一个映射到它的输入 $x$。函数法则规定，对于输入 $x=1/m$，输出是 $f(1/m)=1/(m+1)=y$。由于 $m \\ge 1$，这个 $x=1/m$ 在集合 $A$ 中，因此在定义域 $S$ 中。所以我们找到了一个原像。\n情况2：$y \\in [0,1)$ 且 $y$ 不在集合 $\\{1/2, 1/3, 1/4, \\ldots \\}$ 中。我们尝试原像 $x=y$。由于 $y \\in [0,1)$，$x=y$ 在定义域 $S=[0,1]$ 中。$x=y$ 是否属于集合 $A=\\{1, 1/2, 1/3, \\ldots\\}$？不属于，因为 $y$ 不是 $1/k$ (对于 $k \\ge 2$) 的形式，且 $y \\ne 1$。所以 $x=y$ 在 $S \\setminus A$ 中。根据这种情况的函数定义，$f(x)=x$。因此，$f(y)=y$。我们找到了一个原像。\n由于陪域 $T$ 中的每个元素 $y$ 在定义域 $S$ 中都有一个原像，该函数是满射的。\n\n由于该函数既是单射又是满射，所以它是一个双射。", "answer": "$$\\boxed{D}$$", "id": "1285592"}, {"introduction": "基数算术是处理和比较不同大小的无穷集合的强大工具。通过分析两个假想的计算系统 [@problem_id:1285609]，你将应用基数运算法则来确定它们所有可能状态的集合的大小。这个练习将帮助你区分可数无穷（如 $\\aleph_0^k = \\aleph_0$）和不可数无穷（如 $k^{\\aleph_0} = \\mathfrak{c}$），并理解有限次笛卡尔积与无限次笛卡尔积在基数上的巨大差异。", "problem": "考虑两个抽象的计算系统。为便于解决本问题，令 $\\mathbb{Z}$ 表示所有整数的集合。我们使用基数的标准记法：$\\aleph_0$ (aleph-naught) 表示任意可数无限集（例如 $\\mathbb{Z}$）的基数，而 $\\mathfrak{c}$ 表示连续统的基数（实数集 $\\mathbb{R}$ 的基数）。\n\n系统1是一个简单的存储模块，由 $k$ 个不同的寄存器组成，其中 $k$ 是一个大于1的整数。每个寄存器能够精确存储 $\\mathbb{Z}$ 中的一个整数。该系统的一个“状态”定义为对 $k$ 个寄存器中的每一个都赋一个整数值。令 $\\mathcal{S}_1$ 为系统1所有可能状态的集合。\n\n系统2是一个一维元胞自动机。它由一条无限长的元胞链组成，其中每个元胞由 $\\mathbb{Z}$ 中的一个唯一整数索引。每个元胞可以处于 $k$ 个可能的离散状态之一，标记为 $\\{s_1, s_2, \\dots, s_k\\}$，其中 $k$ 同样是那个大于1的整数。该自动机的一个“构型”定义为对无限链中的每个元胞都赋一个状态。令 $\\mathcal{S}_2$ 为系统2所有可能构型的集合。\n\n令 $\\kappa_1 = |\\mathcal{S}_1|$ 为系统1的状态集基数，$\\kappa_2 = |\\mathcal{S}_2|$ 为系统2的构型集基数。下列哪个陈述正确地指出了这两个基数？\n\nA. $\\kappa_1 = k$ 且 $\\kappa_2 = \\aleph_0$\n\nB. $\\kappa_1 = \\aleph_0$ 且 $\\kappa_2 = \\mathfrak{c}$\n\nC. $\\kappa_1 = \\mathfrak{c}$ 且 $\\kappa_2 = \\aleph_0$\n\nD. $\\kappa_1 = \\aleph_0$ 且 $\\kappa_2 = \\aleph_0$\n\nE. $\\kappa_1 = \\mathfrak{c}$ 且 $\\kappa_2 = \\mathfrak{c}$", "solution": "系统1有 $k$ 个不同的寄存器，每个寄存器存储 $\\mathbb{Z}$ 中的一个元素。一个状态是来自 $\\mathbb{Z}^{k}$ 的一个 $k$-元组。因此，\n$$\n\\kappa_{1}=\\left|\\mathbb{Z}^{k}\\right|=\\left|\\mathbb{Z}\\right|^{k}.\n$$\n因为 $\\left|\\mathbb{Z}\\right|=\\aleph_{0}$ 且可数集的有限笛卡尔积是可数的，我们有\n$$\n\\kappa_{1}=(\\aleph_{0})^{k}=\\aleph_{0}.\n$$\n\n系统2的一个构型由一个函数 $f:\\mathbb{Z}\\to\\{s_{1},\\dots,s_{k}\\}$ 给出。因此，\n$$\n\\kappa_{2}=\\left|\\{s_{1},\\dots,s_{k}\\}^{\\mathbb{Z}}\\right|=k^{\\left|\\mathbb{Z}\\right|}=k^{\\aleph_{0}}.\n$$\n对于任意有限的 $k\\ge 2$，有 $k^{\\aleph_{0}}=2^{\\aleph_{0}}$。要证明这一点，首先注意到通过单射 $\\{0,1\\}^{\\mathbb{Z}}\\hookrightarrow\\{1,\\dots,k\\}^{\\mathbb{Z}}$（逐点定义为 $0\\mapsto 1$ 和 $1\\mapsto 2$），我们有 $2^{\\aleph_{0}}\\le k^{\\aleph_{0}}$。反之，选择 $m\\in\\mathbb{N}$ 使得 $2^{m}\\ge k$，并将 $\\{1,\\dots,k\\}$ 中的每个符号编码为一个不同的 $m$-位块；利用双射 $\\mathbb{Z}\\cong \\mathbb{Z}\\times\\{0,\\dots,m-1\\}$，将这些块连接起来，得到一个单射 $\\{1,\\dots,k\\}^{\\mathbb{Z}}\\hookrightarrow\\{0,1\\}^{\\mathbb{Z}}$，因此 $k^{\\aleph_{0}}\\le 2^{\\aleph_{0}}$。因此 $k^{\\aleph_{0}}=2^{\\aleph_{0}}$。\n\n最后， $2^{\\aleph_{0}}=\\mathfrak{c}$ （连续统的基数），所以\n$$\n\\kappa_{2}=\\mathfrak{c}.\n$$\n\n因此，$\\kappa_{1}=\\aleph_{0}$ 且 $\\kappa_{2}=\\mathfrak{c}$，这对应于选项B。", "answer": "$$\\boxed{B}$$", "id": "1285609"}]}