{"hands_on_practices": [{"introduction": "重复平方法的主要优势在于其计算效率，远胜于朴素的乘法。这个练习将引导你超越简单地计算出最终答案，转而分析算法本身的计算成本——这是计算机科学和密码学中的一个基本问题。通过为一个巨大的指数精确计算所需的模乘法次数，你将具体地体会到该算法的效率。[@problem_id:3087339]", "problem": "在模幂问题 $a^{e} \\pmod n$ 中，设指数 $e = 10^{6}$，其中 $a$ 和 $n$ 是固定的整数，满足 $n \\geq 2$ 和 $a \\geq 1$。\n\n首先，计算 $e$ 的二进制展开，即，将 $e$ 唯一地写成 $e = \\sum_{i=0}^{t-1} b_{i} 2^{i}$ 的形式，其中 $b_{i} \\in \\{0,1\\}$ 且 $b_{t-1} = 1$。然后，考虑标准的从左到右平方-乘模幂算法，其定义如下：初始化 $r \\leftarrow a$，然后从次高有效位到最低有效位扫描 $e$ 的其余比特位；在每一步中，将 $r$ 替换为 $r^2 \\pmod n$，如果当前比特位为 $1$，则额外将 $r$ 替换为 $r \\cdot a \\pmod n$。\n\n假设成本模型中，每次模平方运算和每次与 $a$ 的模乘运算都计为一次模乘运算。使用 $e$ 的二进制展开，确定该方法计算 $a^e \\pmod n$ 所需的模乘总次数。将你的最终答案表示为单个整数。不要计算 $a^e \\pmod n$ 本身的值。", "solution": "该问题是有效的，因为它在计算数论中有科学依据，有清晰的算法描述和成本模型，提法恰当，并且是客观陈述的。\n\n该问题要求我们对于指数 $e = 10^{6}$，使用一个特定版本的从左到右平方-乘算法来计算 $a^e \\pmod n$ 所需的模乘总次数。成本模型将每次模平方运算和每次与 $a$ 的模乘运算都计为一次模乘运算。\n\n首先，我们来分析给定的算法及其相关成本。指数 $e$ 有一个唯一的二进制展开 $e = \\sum_{i=0}^{t-1} b_{i} 2^{i}$，其中 $b_{i} \\in \\{0,1\\}$ 且最高有效位为 $b_{t-1} = 1$。此表示中的比特数是 $t$。该数由 $t = \\lfloor \\log_{2}(e) \\rfloor + 1$ 给出。\n\n该算法定义如下：\n1. 初始化 $r \\leftarrow a$。此步骤对应于最高有效位 $b_{t-1}=1$，根据问题描述，这是一个不产生开销的初始化操作。\n2. 从次高有效位到最低有效位扫描 $e$ 的其余比特位。这些比特位是 $b_{t-2}, b_{t-3}, \\dots, b_0$。这样的比特位数量为 $(t-2) - 0 + 1 = t-1$。\n3. 在每一步中，执行一次模平方运算：$r$ 被替换为 $r^{2} \\pmod n$。因为循环中有 $t-1$ 步（从 $b_{t-2}$ 到 $b_0$ 的每个比特位一步），所以模平方运算的总次数是 $t-1$。\n4. 在每一步中，如果当前比特位为 $1$，则执行一次额外的模乘运算：$r$ 被替换为 $r \\cdot a \\pmod n$。这些额外乘法的次数等于 $b_{t-2}, b_{t-3}, \\dots, b_0$ 中置位（等于 $1$ 的比特位）的数量。\n\n设 $H(e)$ 表示 $e$ 的汉明权重，即其二进制展开中等于 $1$ 的比特位总数。因为我们知道 $b_{t-1}=1$，所以在展开的其余部分（$b_{t-2}, \\dots, b_0$）中置位的数量是 $H(e)-1$。\n\n模乘的总次数，记为 $C$，是平方运算的次数和与 $a$ 的额外乘法次数之和。\n平方运算次数 = $t-1 = (\\lfloor \\log_{2}(e) \\rfloor + 1) - 1 = \\lfloor \\log_{2}(e) \\rfloor$。\n与 $a$ 的乘法次数 = $H(e)-1$。\n因此，总成本为 $C = \\lfloor \\log_{2}(e) \\rfloor + (H(e)-1)$。\n\n给定指数 $e = 10^{6}$。为了求出成本 $C$，我们需要计算 $\\lfloor \\log_{2}(10^{6}) \\rfloor$ 和 $H(10^{6})$。\n\n首先，我们计算 $\\lfloor \\log_{2}(10^{6}) \\rfloor$:\n$\\log_{2}(10^{6}) = 6 \\log_{2}(10)$。我们知道 $2^{3} = 8$ 且 $2^{4} = 16$，所以 $3  \\log_{2}(10)  4$。\n因此，$6 \\times 3  6 \\log_{2}(10)  6 \\times 4$，这意味着 $18  \\log_{2}(10^{6})  24$。\n更精确的计算如下：\n$2^{19} = 524288$\n$2^{20} = 1048576$\n因为 $2^{19}  10^{6}  2^{20}$，所以 $19  \\log_{2}(10^{6})  20$。\n因此，向下取整的结果是 $\\lfloor \\log_{2}(10^{6}) \\rfloor = 19$。\n这意味着 $e=10^6$ 的二进制表示有 $t = 19+1 = 20$ 个比特位。平方运算的次数是 $t-1 = 19$。\n\n接下来，我们需要找到 $e=10^{6}$ 的二进制表示来确定其汉明权重 $H(10^{6})$。我们可以通过反复除以 $2$ 来做到这一点：\n$1000000 = 2 \\times 500000 + 0$\n$500000 = 2 \\times 250000 + 0$\n$250000 = 2 \\times 125000 + 0$\n$125000 = 2 \\times 62500 + 0$\n$62500 = 2 \\times 31250 + 0$\n$31250 = 2 \\times 15625 + 0$\n$15625 = 2 \\times 7812 + 1$\n$7812 = 2 \\times 3906 + 0$\n$3906 = 2 \\times 1953 + 0$\n$1953 = 2 \\times 976 + 1$\n$976 = 2 \\times 488 + 0$\n$488 = 2 \\times 244 + 0$\n$244 = 2 \\times 122 + 0$\n$122 = 2 \\times 61 + 0$\n$61 = 2 \\times 30 + 1$\n$30 = 2 \\times 15 + 0$\n$15 = 2 \\times 7 + 1$\n$7 = 2 \\times 3 + 1$\n$3 = 2 \\times 1 + 1$\n$1 = 2 \\times 0 + 1$\n从下往上读取余数，得到 $10^{6}$ 的二进制表示为：\n$e = (11110100001001000000)_2$。\n这是一个 $20$ 位的数，这与我们计算出的 $t=20$ 是一致的。\n汉明权重 $H(10^{6})$ 是此表示中 $1$ 的数量：\n$H(10^{6}) = 1+1+1+1+1+1+1 = 7$。\n\n现在我们可以用我们的公式计算模乘的总次数：\n$C = \\lfloor \\log_{2}(10^{6}) \\rfloor + (H(10^{6})-1)$。\n$C = 19 + (7 - 1) = 19 + 6 = 25$。\n\n所需的模乘总次数是 $19$ 次平方运算和 $6$ 次与 $a$ 的乘法运算之和。这总共是 $25$ 次运算。", "answer": "$$\n\\boxed{25}\n$$", "id": "3087339"}, {"introduction": "直接的蛮力计算并非总是最明智的方法。这个练习将向你展示，如何通过识别问题中的特殊结构特性，从而找到一个优雅且快捷的解决方案。你将探索当底数模 $n$ 同余于 $1$ 或 $-1$ 时出现的特定模式，这是一种能够简化看似棘手的计算的强大技巧。[@problem_id:3087411]", "problem": "考虑整数 $a$，$e$ 和 $n$，其中 $n \\geq 2$。从模 $n$ 同余的定义和快速幂算法（重复平方）出发，分析在 $a \\equiv 1 \\pmod{n}$ 和 $a \\equiv -1 \\pmod{n}$ 这两种特殊情况下 $a^{e} \\bmod n$ 的结构。在每种情况下，使用重复平方作为计算框架，而不是任何特定的捷径，推导出能够区分偶数和奇数指数 $e$ 结果的闭式模式。\n\n然后，应用你的结论，当 $n = 2026$ 时，计算以下大型模表达式的值：\n$$\n(n - 1)^{\\,3^{100} + 2^{300} + 7} \\cdot (n + 1)^{\\,5^{120} - 1} \\bmod n.\n$$\n将最终答案表示为模 $n$ 的最小非负余数。无需四舍五入。", "solution": "基本依据是同余的定义和快速幂算法（重复平方）的结构。我们将使用两个经过充分检验的事实：\n1. 如果 $x \\equiv y \\pmod{n}$，那么对于任何整数 $k \\geq 1$，都有 $x^{k} \\equiv y^{k} \\pmod{n}$。\n2. 快速幂算法通过将 $e$ 写成二进制形式 $e = \\sum_{j=0}^{m} b_{j} 2^{j}$（其中 $b_{j} \\in \\{0,1\\}$）来计算 $a^{e} \\bmod n$，然后构成\n$$\na^{e} \\equiv \\prod_{j=0}^{m} \\left(a^{2^{j}}\\right)^{b_{j}} \\pmod{n},\n$$\n其中每个 $a^{2^{j}} \\bmod n$ 是通过模 $n$ 的逐次平方得到的。\n\n我们首先分析特殊底数 $a \\equiv 1 \\pmod{n}$ 和 $a \\equiv -1 \\pmod{n}$ 的情况。\n\n情况1：$a \\equiv 1 \\pmod{n}$。根据第一个事实，\n$$\na^{e} \\equiv 1^{e} \\equiv 1 \\pmod{n}\n$$\n对于每个整数 $e \\geq 1$。在重复平方算法下，对所有的 $j$ 都有 $a^{2^{j}} \\equiv 1$，因此所选因子的乘积为 $1$，与 $e$ 的二进制位 $b_{j}$ 无关。因此，闭式模式为对所有 $e$ 都有 $a^{e} \\equiv 1 \\pmod{n}$。\n\n情况2：$a \\equiv -1 \\pmod{n}$。使用重复平方结构，计算\n$$\na^{2} \\equiv (-1)^{2} \\equiv 1 \\pmod{n}, \\quad a^{4} \\equiv \\left(a^{2}\\right)^{2} \\equiv 1^{2} \\equiv 1 \\pmod{n},\n$$\n通过归纳法可知，对于所有 $j \\geq 1$，有 $a^{2^{j}} \\equiv 1 \\pmod{n}$，而 $a^{2^{0}} = a \\equiv -1 \\pmod{n}$。因此，对于 $e = \\sum_{j=0}^{m} b_{j} 2^{j}$，\n$$\na^{e} \\equiv \\prod_{j=0}^{m} \\left(a^{2^{j}}\\right)^{b_{j}} \\equiv \\left((-1)^{1}\\right)^{b_{0}} \\cdot \\prod_{j=1}^{m} 1^{b_{j}} \\equiv (-1)^{b_{0}} \\pmod{n}.\n$$\n由于 $b_{0}$ 是 $e$ 的最低有效位，它编码了 $e$ 的奇偶性：如果 $e$ 是偶数，$b_{0} = 0$；如果 $e$ 是奇数，$b_{0} = 1$。因此，闭式模式为\n$$\na^{e} \\equiv \\begin{cases}\n1 \\pmod{n},  \\text{如果 $e$ 是偶数},\\\\\n-1 \\pmod{n},  \\text{如果 $e$ 是奇数}.\n\\end{cases}\n$$\n等价地，$a^{e} \\equiv (-1)^{e} \\pmod{n}$。\n\n现在我们将这些结论应用于 $n = 2026$ 的具体表达式：\n$$\n(n - 1)^{\\,3^{100} + 2^{300} + 7} \\cdot (n + 1)^{\\,5^{120} - 1} \\bmod n \\quad \\text{其中} \\quad n = 2026.\n$$\n注意到 $n - 1 = 2025 \\equiv -1 \\pmod{2026}$ 且 $n + 1 = 2027 \\equiv 1 \\pmod{2026}$。\n\n第一个因子：$(n - 1)^{\\,3^{100} + 2^{300} + 7} \\bmod n$，其底数与 $-1$ 同余。根据该模式，其值仅取决于指数 $E_{1} = 3^{100} + 2^{300} + 7$ 的奇偶性。确定 $E_{1} \\pmod 2$：\n- $3$ 是奇数，所以 $3^{100}$ 是奇数；因此 $3^{100} \\equiv 1 \\pmod{2}$。\n- $2$ 是偶数，所以 $2^{300}$ 是偶数；因此 $2^{300} \\equiv 0 \\pmod{2}$。\n- $7$ 是奇数；因此 $7 \\equiv 1 \\pmod{2}$。\n因此，\n$$\nE_{1} \\equiv 1 + 0 + 1 \\equiv 0 \\pmod{2},\n$$\n所以 $E_{1}$ 是偶数，且 $(n - 1)^{E_{1}} \\equiv 1 \\pmod{n}$。\n\n第二个因子：$(n + 1)^{\\,5^{120} - 1} \\bmod n$，其底数与 $1$ 同余。根据 $a \\equiv 1 \\pmod{n}$ 的模式，对于任何指数，该表达式都模 $n$ 等于 $1$。具体来说，\n$$\n(n + 1)^{\\,5^{120} - 1} \\equiv 1 \\pmod{n}.\n$$\n\n结合两个因子，\n$$\n\\left[(n - 1)^{\\,3^{100} + 2^{300} + 7}\\right] \\cdot \\left[(n + 1)^{\\,5^{120} - 1}\\right] \\equiv 1 \\cdot 1 \\equiv 1 \\pmod{n}.\n$$\n因此，模 $n = 2026$ 的最小非负余数是 $1$。", "answer": "$$\\boxed{1}$$", "id": "3087411"}, {"introduction": "功能强大的定理通常有其特定的应用前提。这个练习旨在检验你对欧拉定理的理解，这是一个与模幂运算紧密相关的常用工具。通过一个精心设计的、其中 $\\gcd(a,n) \\neq 1$ 的反例，你将亲眼见证为何盲目地对指数进行约减会导致错误答案，从而巩固你对该定理应用条件的掌握。[@problem_id:3087438]", "problem": "设合数模为 $n=45$，底为 $a=9$ 且 $\\gcd(a,n)\\neq 1$，指数为 $e=120$。使用重复平方求幂的模幂运算，计算余数 $r \\equiv a^e \\pmod n$，不要引用任何假定 $a$ 是模 $n$ 的单位元的定理。另外，计算 $\\varphi(n)$ 并构造约化指数 $e' \\equiv e \\pmod{\\varphi(n)}$，然后计算 $r' \\equiv a^{e'} \\pmod n$（同样使用重复平方求幂）。将整数差 $\\Delta=r-r'$ 作为你的最终答案。在你的解释中，从同余、欧拉函数 $\\varphi(n)$ 和模 $n$ 的乘法单位群的基本定义出发，论证为什么将指数 $e$ 模 $\\varphi(n)$ 进行约化的做法，其所依赖的假设在 $\\gcd(a,n)\\neq 1$ 的情况下不成立。", "solution": "该问题被认为是有效的，因为它是自洽的，具有数论的科学基础，并且问题陈述清晰。我们开始解题。\n\n问题要求进行几项计算，并就模幂运算提供一个理论论证。我们系统地处理每个部分。\n\n首先，我们使用重复平方求幂法计算当 $a=9$、$e=120$ 和 $n=45$ 时的 $r \\equiv a^e \\pmod n$。指数 $e=120$ 的二进制表示是 $120_{10} = 64 + 32 + 16 + 8 = 2^6 + 2^5 + 2^4 + 2^3$，即 $1111000_2$。我们需要计算 $a^{120} = a^{64} a^{32} a^{16} a^8 \\pmod n$。\n\n我们计算 $a=9$ 的各次幂模 $n=45$ 的值：\n$$9^1 \\equiv 9 \\pmod{45}$$\n$$9^2 = 81 \\equiv 36 \\pmod{45}$$\n$$9^4 = (9^2)^2 \\equiv 36^2 = 1296 \\pmod{45}$$\n为了计算 $1296 \\pmod{45}$，我们将 $1296$ 除以 $45$。$1296 = 28 \\times 45 + 36$。因此，\n$$9^4 \\equiv 36 \\pmod{45}$$\n我们观察到，一旦得到数值 $36$，重复对其进行平方运算，模 $45$ 的结果将一直是 $36$：\n$$36^2 \\equiv 36 \\pmod{45}$$\n因此，对于任何整数 $k \\ge 1$：\n$$9^{2^k} \\equiv 36 \\pmod{45}$$\n这适用于 $9^4, 9^8, 9^{16}, 9^{32}, 9^{64}$。\n$$9^8 \\equiv (9^4)^2 \\equiv 36^2 \\equiv 36 \\pmod{45}$$\n$$9^{16} \\equiv (9^8)^2 \\equiv 36^2 \\equiv 36 \\pmod{45}$$\n$$9^{32} \\equiv (9^{16})^2 \\equiv 36^2 \\equiv 36 \\pmod{45}$$\n$$9^{64} \\equiv (9^{32})^2 \\equiv 36^2 \\equiv 36 \\pmod{45}$$\n\n现在我们可以计算 $r$：\n$$r \\equiv 9^{120} \\pmod{45}$$\n$$r \\equiv 9^{64+32+16+8} \\pmod{45}$$\n$$r \\equiv 9^{64} \\cdot 9^{32} \\cdot 9^{16} \\cdot 9^8 \\pmod{45}$$\n$$r \\equiv 36 \\cdot 36 \\cdot 36 \\cdot 36 \\pmod{45}$$\n由于 $36 \\cdot 36 \\equiv 36 \\pmod{45}$，这可以简化为：\n$$r \\equiv (36 \\cdot 36) \\cdot (36 \\cdot 36) \\equiv 36 \\cdot 36 \\equiv 36 \\pmod{45}$$\n所以，正确的余数是 $r=36$。\n\n第二，我们计算 $n=45$ 的欧拉函数 $\\varphi(n)$。$n$ 的素数分解是 $45 = 3^2 \\cdot 5^1$。欧拉函数对于互质的参数是积性的，所以：\n$$\\varphi(45) = \\varphi(3^2) \\cdot \\varphi(5)$$\n使用公式 $\\varphi(p^k) = p^k - p^{k-1}$：\n$$\\varphi(3^2) = 3^2 - 3^1 = 9 - 3 = 6$$\n$$\\varphi(5) = 5^1 - 5^0 = 5 - 1 = 4$$\n因此：\n$$\\varphi(45) = 6 \\cdot 4 = 24$$\n\n第三，我们计算约化指数 $e' \\equiv e \\pmod{\\varphi(n)}$。\n$$e' \\equiv 120 \\pmod{24}$$\n因为 $120 = 5 \\times 24 + 0$，我们得到 $e' \\equiv 0 \\pmod{24}$。我们选择代表元 $e'=0$。\n\n第四，我们计算 $r' \\equiv a^{e'} \\pmod n$。\n$$r' \\equiv 9^0 \\pmod{45}$$\n根据定义，对于任何非零底数，$x^0=1$。因此：\n$$r' = 1$$\n\n第五，我们计算差值 $\\Delta = r - r'$。\n$$\\Delta = 36 - 1 = 35$$\n\n最后，我们从基本定义出发，论证为什么在这种情况下将指数 $e$ 模 $\\varphi(n)$ 进行约化是无效的。\n\n模 $n$ 同余关系，记作 $a \\equiv b \\pmod{n}$，表示 $n$ 整除差值 $a-b$。该关系将整数集 $\\mathbb{Z}$ 划分为 $n$ 个等价类，构成模 $n$ 整数环，记作 $\\mathbb{Z}_n$ 或 $\\mathbb{Z}/n\\mathbb{Z}$。\n\n欧拉函数 $\\varphi(n)$ 计算小于或等于 $n$ 且与 $n$ 互质的正整数的个数。这些整数对应于 $\\mathbb{Z}_n$ 中满足 $\\gcd(a,n)=1$ 的等价类 $[a]_n$。\n\n这些特定的等价类集合构成了模 $n$ 的乘法单位群，记作 $(\\mathbb{Z}/n\\mathbb{Z})^\\times$。一个元素 $[a]_n$ 之所以是“单位元”，是因为它存在模 $n$ 的乘法逆元，这个性质当且仅当 $\\gcd(a,n)=1$ 时得到保证。这个群的阶（其元素数量）恰好是 $|\\left(\\mathbb{Z}/n\\mathbb{Z}\\right)^\\times| = \\varphi(n)$。\n\n欧拉定理是关于这个群的一个论断。它断言，对于任何满足 $\\gcd(a,n)=1$ 的整数 $a$，以下等式成立：\n$$a^{\\varphi(n)} \\equiv 1 \\pmod{n}$$\n这是群论中 Lagrange 定理的直接推论，该定理指出有限群中任何元素的阶都整除群的阶。对于一个元素 $[a]_n \\in (\\mathbb{Z}/n\\mathbb{Z})^\\times$，它的阶必须整除 $\\varphi(n)$，这意味着 $a^{\\varphi(n)} \\equiv 1 \\pmod n$。\n\n将指数 $e$ 模 $\\varphi(n)$ 进行约化的过程完全基于欧拉定理。如果我们希望计算 $a^e \\pmod n$，我们可以将 $e$ 写成 $e = q\\varphi(n) + e'$，其中 $e' = e \\pmod{\\varphi(n)}$ 且 $q$ 是一个整数。计算过程如下：\n$$a^e = a^{q\\varphi(n) + e'} = (a^{\\varphi(n)})^q \\cdot a^{e'}$$\n如果 $\\gcd(a,n)=1$，则 $a^{\\varphi(n)} \\equiv 1 \\pmod{n}$，我们可以将其代入方程中：\n$$a^e \\equiv 1^q \\cdot a^{e'} \\equiv a^{e'} \\pmod{n}$$\n这一代换是证明约化指数合理性的关键步骤。\n\n在给定的问题中，$a=9$，$n=45$。我们计算最大公约数：\n$$\\gcd(9, 45) = 9$$\n由于 $\\gcd(9, 45) = 9 \\neq 1$，整数 $a=9$ 与模 $n=45$ 不互质。因此，同余类 $[9]_{45}$ 不是乘法单位群 $(\\mathbb{Z}/45\\mathbb{Z})^\\times$ 的元素。欧拉定理不适用于这个底 $a$。\n\n指数约化的前提条件 $a^{\\varphi(n)} \\equiv 1 \\pmod{n}$ 不一定成立。事实上，我们可以证明它是错误的。我们计算出 $\\varphi(45)=24$。让我们计算 $9^{24} \\pmod{45}$：\n$$9^{24} = 9^{16+8} = 9^{16} \\cdot 9^8 \\pmod{45}$$\n根据我们之前的计算，$9^{16} \\equiv 36 \\pmod{45}$ 且 $9^8 \\equiv 36 \\pmod{45}$。\n$$9^{24} \\equiv 36 \\cdot 36 \\equiv 36 \\pmod{45}$$\n显然，$9^{24} \\not\\equiv 1 \\pmod{45}$。进行简化所需的基本假设不成立。因此，将指数 $e=120$ 约化为 $e'=0$ (模 $\\varphi(45)=24$) 的过程在数学上是无效的。这就解释了为什么通过这种错误方法得到的结果 $r'=1$ 与通过直接计算得到的正确结果 $r=36$ 不同。", "answer": "$$\\boxed{35}$$", "id": "3087438"}]}