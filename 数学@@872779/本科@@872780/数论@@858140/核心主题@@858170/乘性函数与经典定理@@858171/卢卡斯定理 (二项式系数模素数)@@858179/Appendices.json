{"hands_on_practices": [{"introduction": "理论的最佳学习方式是通过实践。这个练习将引导我们从第一性原理出发，而不是简单地套用卢卡斯定理的公式。通过处理一个具体的例子，我们将利用二项式定理和模算术的基本性质，亲手推导出结果，从而深刻理解卢卡斯定理背后的核心逻辑。[@problem_id:3087050]", "problem": "在素数模整数环中，可以通过素数基底展开来分析二项式系数的同余问题。完全在素数 $p$ 的模下进行运算，仅从二项式定理和对于素数 $p$ 及 $0  r  p$ 的整数 $r$，$\\binom{p}{r}$ 都能被 $p$ 整除这一事实出发，计算 $\\binom{83}{27}$ 模 $5$ 的最小非负余数。您的最终答案应仅为一个整数，无需任何额外文本。", "solution": "目标是求二项式系数 $\\binom{83}{27}$ 模素数 $p=5$ 的最小非负余数。我们的方法仅限于使用二项式定理以及对于素数 $p$ 和所有满足 $0  r  p$ 的整数 $r$，$\\binom{p}{r}$ 都能被 $p$ 整除这一事实。\n\n让我们首先在以 $p$ 为模的整系数多项式环（记作 $\\mathbb{Z}_p[x]$）中分析多项式 $(1+x)^p$。二项式定理指出 $(1+x)^p = \\sum_{r=0}^{p} \\binom{p}{r} x^r$。\n展开此和式得到：\n$$(1+x)^p = \\binom{p}{0}x^0 + \\binom{p}{1}x^1 + \\dots + \\binom{p}{p-1}x^{p-1} + \\binom{p}{p}x^p$$\n我们知道 $\\binom{p}{0} = 1$ 和 $\\binom{p}{p} = 1$。题目条件给出，对于 $0  r  p$，系数 $\\binom{p}{r}$ 能被 $p$ 整除，这意味着 $\\binom{p}{r} \\equiv 0 \\pmod{p}$。\n因此，当考虑多项式模 $p=5$ 时，所有中间项都消失了：\n$$(1+x)^5 \\equiv 1 \\cdot x^0 + 0 \\cdot x^1 + \\dots + 0 \\cdot x^4 + 1 \\cdot x^5 \\pmod{5}$$\n$$(1+x)^5 \\equiv 1 + x^5 \\pmod{5}$$\n这个结果有时被称为“新生的梦想”。我们可以将此性质推广到素数 $p$ 的更高次幂。例如，对于 $p^2$：\n$$(1+x)^{p^2} = ((1+x)^p)^p \\equiv (1+x^p)^p \\pmod{p}$$\n将同样的性质应用于变量为 $y=x^p$ 的多项式，我们得到 $(1+y)^p \\equiv 1+y^p \\pmod{p}$。将 $y=x^p$ 代回：\n$$(1+x^p)^p \\equiv 1 + (x^p)^p = 1 + x^{p^2} \\pmod{p}$$\n通过归纳法，这可以推广到对任意非负整数 $j$ 都有 $(1+x)^{p^j} \\equiv 1+x^{p^j} \\pmod{p}$。当 $p=5$ 时，我们有 $(1+x)^{5^j} \\equiv 1+x^{5^j} \\pmod{5}$。\n\n下一步是将整数 $n=83$ 和 $k=27$ 表示为 $p=5$ 进制。\n对于 $n=83$：\n$83 = 3 \\times 25 + 8 = 3 \\times 5^2 + 8$\n$8 = 1 \\times 5 + 3 = 1 \\times 5^1 + 3$\n$3 = 3 \\times 1 = 3 \\times 5^0$\n所以，$n=83$ 的 $5$ 进制展开式为 $n = 3 \\cdot 5^2 + 1 \\cdot 5^1 + 3 \\cdot 5^0$。我们可以将其写作 $n=(313)_5$。令其各位数字为 $n_2=3$，$n_1=1$ 和 $n_0=3$。\n\n对于 $k=27$：\n$27 = 1 \\times 25 + 2 = 1 \\times 5^2 + 2$\n$2 = 0 \\times 5 + 2 = 0 \\times 5^1 + 2$\n$2 = 2 \\times 1 = 2 \\times 5^0$\n所以，$k=27$ 的 $5$ 进制展开式为 $k = 1 \\cdot 5^2 + 0 \\cdot 5^1 + 2 \\cdot 5^0$。我们可以将其写作 $k=(102)_5$。令其各位数字为 $k_2=1$，$k_1=0$ 和 $k_0=2$。\n\n根据定义，二项式系数 $\\binom{n}{k} = \\binom{83}{27}$ 是 $(1+x)^n = (1+x)^{83}$ 展开式中 $x^k=x^{27}$ 项的系数。我们将通过模 $5$ 运算来找到这个系数。\n我们使用 $n=83$ 的 $5$ 进制展开式来分解多项式：\n$$(1+x)^{83} = (1+x)^{3 \\cdot 5^2 + 1 \\cdot 5^1 + 3 \\cdot 5^0} = (1+x)^{3 \\cdot 25} (1+x)^{1 \\cdot 5} (1+x)^{3}$$\n$$(1+x)^{83} = \\left((1+x)^{25}\\right)^3 \\left((1+x)^5\\right)^1 (1+x)^3$$\n使用同余式 $(1+x)^{5^j} \\equiv 1+x^{5^j} \\pmod{5}$，我们可以将此表达式模 $5$ 进行简化：\n$$(1+x)^{83} \\equiv (1+x^{25})^3 (1+x^5)^1 (1+x)^3 \\pmod{5}$$\n我们现在需要找到右侧展开式中 $x^{27}$ 的系数。让我们用二项式定理展开每个因子：\n\\begin{itemize}\n    \\item $(1+x^{25})^3 = \\sum_{i_2=0}^{3} \\binom{3}{i_2} (x^{25})^{i_2} = \\binom{3}{0} + \\binom{3}{1}x^{25} + \\binom{3}{2}x^{50} + \\binom{3}{3}x^{75}$\n    \\item $(1+x^5)^1 = \\sum_{i_1=0}^{1} \\binom{1}{i_1} (x^5)^{i_1} = \\binom{1}{0} + \\binom{1}{1}x^5$\n    \\item $(1+x)^3 = \\sum_{i_0=0}^{3} \\binom{3}{i_0} x^{i_0} = \\binom{3}{0} + \\binom{3}{1}x + \\binom{3}{2}x^2 + \\binom{3}{3}x^3$\n\\end{itemize}\n这三个多项式展开式乘积中的一个通项，是由从每个展开式中选取一项构成的。这样的项具有以下形式：\n$$\\left( \\binom{3}{i_2} x^{25 i_2} \\right) \\left( \\binom{1}{i_1} x^{5 i_1} \\right) \\left( \\binom{3}{i_0} x^{i_0} \\right) = \\binom{3}{i_2} \\binom{1}{i_1} \\binom{3}{i_0} x^{25 i_2 + 5 i_1 + i_0}$$\n其中，指数必须在 $0 \\le i_2 \\le 3$，$0 \\le i_1 \\le 1$ 和 $0 \\le i_0 \\le 3$ 的范围内。\n\n我们在寻找 $x^{27}$ 的系数。这要求指数为 $27$：\n$$25 i_2 + 5 i_1 + i_0 = 27$$\n这个方程是数 $27$ 在 $5$ 进制系统中的一种表示。由于一个整数在给定基底下的表示是唯一的，并且我们知道 $27 = 1 \\cdot 25 + 0 \\cdot 5 + 2$，因此满足 $0 \\le i_j  5$ 的唯一整数解是 $i_2=1$, $i_1=0$ 和 $i_0=2$。\n我们必须验证这个唯一解在二项式展开的指数约束下是有效的：\n\\begin{itemize}\n    \\item $i_2 = 1$ 在 $0 \\le i_2 \\le 3$ 范围内。\n    \\item $i_1 = 0$ 在 $0 \\le i_1 \\le 1$ 范围内。\n    \\item $i_0 = 2$ 在 $0 \\le i_0 \\le 3$ 范围内。\n\\end{itemize}\n所有约束都得到满足。因此，乘积中只有一种项的组合能产生 $x^{27}$。$x^{27}$ 的系数是这些特定项系数的乘积。这对应于与 $n=(n_2 n_1 n_0)_5$ 和 $k=(k_2 k_1 k_0)_5$ 的 $5$ 进制数字相关的二项式系数 $\\binom{n_j}{k_j}$ 的乘积。\n该系数为：\n$$C = \\binom{3}{1} \\binom{1}{0} \\binom{3}{2}$$\n我们计算每个二项式系数：\n$$\\binom{3}{1} = \\frac{3!}{1!(3-1)!} = 3$$\n$$\\binom{1}{0} = \\frac{1!}{0!(1-0)!} = 1$$\n$$\\binom{3}{2} = \\frac{3!}{2!(3-2)!} = \\frac{3 \\times 2}{2 \\times 1} = 3$$\n乘积为 $C = 3 \\times 1 \\times 3 = 9$。\n我们已经证明了 $\\binom{83}{27} \\equiv C \\pmod{5}$。现在我们求 $9$ 模 $5$ 的最小非负余数：\n$$9 = 1 \\times 5 + 4$$\n因此，$9 \\equiv 4 \\pmod{5}$。\n\n最终结果是 $\\binom{83}{27}$ 模 $5$ 的最小非负余数是 $4$。", "answer": "$$\\boxed{4}$$", "id": "3087050"}, {"introduction": "掌握一个定理的关键在于了解其适用范围和局限性。这个练习将挑战一个常见的假设：卢卡斯定理是否可以推广到合数模？通过为一个合数模构造一个反例，我们将揭示为何“素数”这一条件是不可或缺的，并精确定位标准证明中失效的环节。[@problem_id:3087039]", "problem": "设 $p$ 是一个素数。一个关于模 $p$ 的二项式系数的经典结果，是通过利用特征为 $p$ 的代数以及整数的 $p$ 进制展开的结构来证明的。考虑一个问题，即一种类似的按位分解现象能否推广到合数模，特别是模 $6$。从二项式系数和模算术的定义出发，并仅使用对素数模成立的性质，通过检验 $\\binom{6}{3}$ 来构造一个对于模 6 的任何朴素按位法则的反例，然后精确分析当模为 6 时，标准的素数模证明中的哪一步会失效。你的最终答案应该是 $\\binom{6}{3}$ 模 $6$ 的最小非负余数。无需四舍五入，也不涉及单位。请在你的推理过程中提供所要求的反例和分析，但最终数值答案仅报告最小非负余数。", "solution": "该问题要求研究一个类似于针对素数模的 Lucas 定理的二项式系数按位分解法则，是否可以应用于合数模 $m=6$。我们必须使用 $\\binom{6}{3}$ 构造一个反例，并分析其背后证明结构的失效之处。最终答案是 $\\binom{6}{3} \\pmod{6}$ 的值。\n\n首先，我们陈述针对素数模的一个结果，即 Lucas 定理。对于一个素数 $p$ 和非负整数 $n$ 和 $k$，设其 $p$ 进制展开式为 $n = n_d p^d + \\dots + n_1 p + n_0$ 和 $k = k_d p^d + \\dots + k_1 p + k_0$，该定理陈述如下：\n$$\n\\binom{n}{k} \\equiv \\prod_{i=0}^{d} \\binom{n_i}{k_i} \\pmod{p}\n$$\n对于合数模 $m=6$ 的一个“朴素按位法则”将是该定理的直接类比，使用 6 进制展开。\n\n现在我们用 $\\binom{6}{3} \\pmod{6}$ 这个具体例子来检验这个朴素法则。\n\n首先，我们计算 $\\binom{6}{3}$ 的精确值及其模 6 的余数。二项式系数定义为：\n$$\n\\binom{n}{k} = \\frac{n!}{k!(n-k)!}\n$$\n对于 $n=6$ 和 $k=3$，我们有：\n$$\n\\binom{6}{3} = \\frac{6!}{3!(6-3)!} = \\frac{6!}{3!3!} = \\frac{6 \\times 5 \\times 4 \\times 3 \\times 2 \\times 1}{(3 \\times 2 \\times 1)(3 \\times 2 \\times 1)} = \\frac{720}{36} = 20\n$$\n为了求 20 模 6 的最小非负余数，我们做除法：\n$$\n20 = 3 \\times 6 + 2\n$$\n因此，真实值为：\n$$\n\\binom{6}{3} \\equiv 2 \\pmod{6}\n$$\n\n接下来，我们将假设的模 6 朴素按位法则应用于 $\\binom{6}{3}$。这需要将 $n=6$ 和 $k=3$ 表示成 6 进制。\n$n=6$ 的 6 进制展开式是：\n$$\n6 = 1 \\cdot 6^1 + 0 \\cdot 6^0\n$$\n所以，数字是 $n_1=1$ 和 $n_0=0$。\n$k=3$ 的 6 进制展开式是：\n$$\n3 = 0 \\cdot 6^1 + 3 \\cdot 6^0\n$$\n所以，数字是 $k_1=0$ 和 $k_0=3$。\n\n朴素按位法则会预测 $\\binom{6}{3}$ 与对应数字的二项式系数的乘积同余：\n$$\n\\binom{6}{3} \\equiv \\binom{n_1}{k_1} \\binom{n_0}{k_0} \\pmod{6}\n$$\n代入数字的值：\n$$\n\\binom{6}{3} \\equiv \\binom{1}{0} \\binom{0}{3} \\pmod{6}\n$$\n我们计算右边的项。根据定义，如果 $ba$，则 $\\binom{a}{b}=0$。\n$$\n\\binom{1}{0} = \\frac{1!}{0!(1-0)!} = 1\n$$\n$$\n\\binom{0}{3} = 0\n$$\n因此，乘积为：\n$$\n\\binom{1}{0} \\binom{0}{3} = 1 \\times 0 = 0\n$$\n朴素法则预测 $\\binom{6}{3} \\equiv 0 \\pmod{6}$。\n\n我们找到了一个矛盾。实际值是 $\\binom{6}{3} \\equiv 2 \\pmod{6}$，而朴素按位法则预测的值是 $0 \\pmod{6}$。因为 $2 \\not\\equiv 0 \\pmod{6}$，我们成功地构造了一个反例。\n\n现在，我们必须精确分析当模为 6 时，针对素数模的标准证明中的哪一步失效了。Lucas 定理的证明依赖于多项式环 $(\\mathbb{Z}/p\\mathbb{Z})[x]$ 的一个性质，通常称为“新生的梦想”恒等式：\n$$\n(1+X)^p \\equiv 1+X^p \\pmod{p}\n$$\n这个恒等式源于 $(1+X)^p$ 的二项式展开：\n$$\n(1+X)^p = \\sum_{j=0}^{p} \\binom{p}{j} X^j = \\binom{p}{0} + \\binom{p}{1}X + \\dots + \\binom{p}{p-1}X^{p-1} + \\binom{p}{p}X^p\n$$\n对于一个素数 $p$ 和任意满足 $1 \\le j \\le p-1$ 的整数 $j$，二项式系数 $\\binom{p}{j} = \\frac{p!}{j!(p-j)!}$ 是一个整数。在这个分数中，素因子 $p$ 出现在分子中，但没有出现在分母中，因为 $j  p$ 且 $p-j  p$。因此，对于所有 $1 \\le j \\le p-1$，$\\binom{p}{j} \\equiv 0 \\pmod{p}$。这导致所有中间项消失。\n\n让我们检验当模是合数 $m=6$ 时，这一关键步骤是否成立。我们需要检验对于 $1 \\le j \\le 5$，是否总有 $\\binom{6}{j} \\equiv 0 \\pmod{6}$。\n我们来计算 $\\binom{6}{3}$，我们已经知道其值为 20。\n$$\n\\binom{6}{3} = 20 \\equiv 2 \\pmod{6}\n$$\n因为 $2 \\not\\equiv 0 \\pmod{6}$，所以 $\\binom{6}{3}$ 不能被 6 整除。\n因此，关键的代数恒等式 $(1+X)^6 \\equiv 1+X^6 \\pmod{6}$ 不成立。事实上，\n$$\n(1+X)^6 = \\binom{6}{0} + \\binom{6}{1}X + \\binom{6}{2}X^2 + \\binom{6}{3}X^3 + \\binom{6}{4}X^4 + \\binom{6}{5}X^5 + \\binom{6}{6}X^6\n$$\n$$\n(1+X)^6 \\equiv 1 + 6X + 15X^2 + 20X^3 + 15X^4 + 6X^5 + X^6 \\pmod{6}\n$$\n$$\n(1+X)^6 \\equiv 1 + 0X + 3X^2 + 2X^3 + 3X^4 + 0X^5 + X^6 \\pmod{6}\n$$\n$$\n(1+X)^6 \\equiv 1 + 3X^2 + 2X^3 + 3X^4 + X^6 \\pmod{6}\n$$\n这远比 $1+X^6$ 复杂。\n失效的根本原因在于，当 $m$ 是合数时，对于 $1  j  m-1$ 的某些 $j$ 来说，$\\binom{m}{j}$ 不一定能被 $m$ 整除。在我们的例子中，$m=6=2 \\times 3$。$\\binom{6}{3}=20$ 的分母是 $3! (3!) = 36 = 6^2$。分子是 $6! = 720$。$v_2(6!)=4, v_3(6!)=2$。$v_2(3!)=1, v_3(3!)=1$。$v_2(\\binom{6}{3}) = v_2(6!) - 2v_2(3!) = 4 - 2(1) = 2$。$v_3(\\binom{6}{3}) = v_3(6!) - 2v_3(3!) = 2 - 2(1) = 0$。由于 $v_3(\\binom{6}{3}) = 0$，所以 $\\binom{6}{3}$ 不能被 3 整除，因此也不能被 6 整除。\n\n因此，证明结构在最基础的步骤就失败了，即无法将在 $\\mathbb{Z}_m[x]$ 中计算 $(1+X)^m$ 的操作简化为 $1+X^m$。\n\n问题的最终答案是 $\\binom{6}{3}$ 模 6 的值，即 2。", "answer": "$$\\boxed{2}$$", "id": "3087039"}, {"introduction": "一个数学定理的真正威力，往往在它被转化为算法时才能完全展现。这个最终练习要求我们将卢卡斯定理的理论转化为一个高效的计算工具。通过设计一个计算模素数下二项式系数的程序，我们将把理论的优雅与计算的实用性结合起来。[@problem_id:3087055]", "problem": "设计并实现一个程序，在给定整数 $n$、$k$ 和一个素数 $p$ 的情况下，通过将 $n$ 和 $k$ 分解为其 p 进制数字并组合相应数字的贡献，来计算二项式系数 $ \\binom{n}{k} $ 模 $p$ 的余数。您的解法应从基本原理推导得出，从模算术和二项式系数的定义以及整数的 p 进制展开开始。您的推导不得假设任何超出广泛接受的数论事实（如模算术和素性的性质）之外的专门定理。\n\n您的算法设计应：\n- 从 p 进制表示 $ n = \\sum_{i \\ge 0} n_i p^i $ 和 $ k = \\sum_{i \\ge 0} k_i p^i $（其中数字 $ 0 \\le n_i, k_i  p $）开始。\n- 仅使用从二项式系数的定义、素数模的模算术性质以及二项式展开中得出的性质，来证明一种按位分解的合理性，该分解将 $ \\binom{n}{k} \\bmod p $ 的计算简化为仅依赖于数对 $(n_i,k_i)$ 的项的乘积。\n- 描述如何利用模 p 的乘法逆元高效地计算每个数字级别的二项式系数 $ \\binom{a}{b} \\bmod p $（其中 $ 0 \\le a, b  p $），并通过一个在 p 是素数时成立的性质来证明其合理性。清晰地说明如何处理 $ b  a $ 的情况。\n\n实现要求：\n- 根据您的推导，实现一个计算 $ \\binom{n}{k} \\bmod p $ 的函数。\n- 程序必须是自包含的，且不得读取任何输入；它应执行一个固定的测试套件并打印结果。\n- 所有答案均为整数。\n\n测试套件：\n在以下参数三元组 $(n,k,p)$ 上评估您的程序：\n- $(123,58,7)$\n- $(100,35,13)$\n- $(12345,0,101)$\n- $(50,60,5)$\n- $(10,6,3)$\n- $(29,13,2)$\n- $(10,3,101)$\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表，顺序与测试套件相同（例如 $[r_1,r_2,\\dots]$）。不应打印任何额外的文本。", "solution": "问题是计算二项式系数 $\\binom{n}{k}$ 模一个素数 $p$ 的值。推导将从基本原理出发，特别是有限域 $\\mathbb{Z}_p$ 上多项式的性质，以建立一个按位计算的公式。这个结果被称为卢卡斯定理 (Lucas's theorem)。\n\n我们的出发点是二项式定理，该定理指出 $\\binom{n}{k}$ 是 $(1+x)^n$ 多项式展开式中 $x^k$ 项的系数：\n$$ (1+x)^n = \\sum_{i=0}^{n} \\binom{n}{i} x^i $$\n我们希望找到这个系数模 $p$ 的值。这等价于在多项式 $(1+x)^n$ 中找到 $x^k$ 的系数，其中系数被视为有限域 $\\mathbb{Z}_p$ 中的元素。\n\n首先，我们建立 $\\mathbb{Z}_p[x]$ 中多项式的一个基本性质。对于一个素数 $p$，我们有以下同余式：\n$$ (a+b)^p \\equiv a^p + b^p \\pmod{p} $$\n这可以从 $(a+b)^p$ 的二项式展开中看出：\n$$ (a+b)^p = \\sum_{i=0}^{p} \\binom{p}{i} a^{p-i} b^i = \\binom{p}{0}a^p + \\binom{p}{1}a^{p-1}b + \\dots + \\binom{p}{p-1}ab^{p-1} + \\binom{p}{p}b^p $$\n首末两项的系数是 $\\binom{p}{0}=1$ 和 $\\binom{p}{p}=1$。对于任何满足 $1 \\le i \\le p-1$ 的中间整数 $i$，二项式系数由 $\\binom{p}{i} = \\frac{p!}{i!(p-i)!}$ 给出。由于 $p$ 是素数，分子 $p!$ 可以被 $p$ 整除。分母 $i!(p-i)!$ 不能被 $p$ 整除，因为它的所有素因子都小于 $p$。因此，对于 $1 \\le i \\le p-1$，$\\binom{p}{i}$ 是 $p$ 的整数倍。这意味着：\n$$ \\binom{p}{i} \\equiv 0 \\pmod{p} \\quad \\text{for } 1 \\le i \\le p-1 $$\n因此，展开式中的所有中间项在模 $p$ 意义下都为零，剩下 $(a+b)^p \\equiv a^p + b^p \\pmod{p}$。\n通过重复应用此性质，可以将其推广到 $p$ 的幂。对于任何整数 $j \\ge 1$：\n$$ (a+b)^{p^j} \\equiv (a^{p^{j-1}} + b^{p^{j-1}})^p \\equiv (a^{p^{j-1}})^p + (b^{p^{j-1}})^p \\equiv a^{p^j} + b^{p^j} \\pmod{p} $$\n令 $a=1$ 和 $b=x$，我们为多项式 $(1+x)^n$ 得到一个关键的恒等式：\n$$ (1+x)^{p^j} \\equiv 1 + x^{p^j} \\pmod{p} $$\n\n现在，我们将整数 $n$ 表示为其 p 进制形式：\n$$ n = \\sum_{i=0}^{m} n_i p^i = n_m p^m + \\dots + n_1 p + n_0 $$\n其中 $0 \\le n_i  p$ 是 $n$ 在 p 进制下的数字。\n我们现在可以将多项式 $(1+x)^n$ 模 $p$ 分解如下：\n$$ (1+x)^n = (1+x)^{\\sum_{i=0}^{m} n_i p^i} = \\prod_{i=0}^{m} (1+x)^{n_i p^i} = \\prod_{i=0}^{m} \\left((1+x)^{p^i}\\right)^{n_i} $$\n应用我们推导出的同余关系：\n$$ (1+x)^n \\equiv \\prod_{i=0}^{m} (1+x^{p^i})^{n_i} \\pmod{p} $$\n根据二项式定理，乘积中的每一项都可以展开：\n$$ (1+x^{p^i})^{n_i} = \\sum_{j=0}^{n_i} \\binom{n_i}{j} (x^{p^i})^j = \\sum_{j=0}^{n_i} \\binom{n_i}{j} x^{j \\cdot p^i} $$\n由于 $0 \\le n_i  p$，系数 $\\binom{n_i}{j}$ 是先验的整数。我们关心的是它们模 $p$ 的值。\n$(1+x)^n$ 模 $p$ 的完整表达式是：\n$$ (1+x)^n \\equiv \\prod_{i=0}^{m} \\left( \\sum_{k_i=0}^{n_i} \\binom{n_i}{k_i} x^{k_i p^i} \\right) \\pmod{p} $$\n我们正在寻找 $x^k$ 的系数。我们也把 $k$ 表示为其 p 进制形式，位数与 $n$ 相同（如有必要，用前导零填充）：\n$$ k = \\sum_{i=0}^{m} k_i p^i = k_m p^m + \\dots + k_1 p + k_0 $$\n其中 $0 \\le k_i  p$。\n当我们展开这个和的乘积时，一个通用项是通过从乘积中的每个和式中选择一项而形成的：\n$$ \\left( \\binom{n_0}{k_0} x^{k_0 p^0} \\right) \\left( \\binom{n_1}{k_1} x^{k_1 p^1} \\right) \\dots \\left( \\binom{n_m}{k_m} x^{k_m p^m} \\right) = \\left( \\prod_{i=0}^{m} \\binom{n_i}{k_i} \\right) x^{\\sum_{i=0}^{m} k_i p^i} $$\n这个通用项中 $x$ 的指数是 $\\sum_{i=0}^{m} k_i p^i$。由于 $0 \\le k_i  p$，这是某个整数唯一的 p 进制表示。为了使这个指数等于 $k$，我们必须匹配这些数字，即和式中每一项的索引 $k_i$ 必须等于 $k$ 的第 $i$ 位数字。\n因此，$(1+x)^n$ 模 $p$ 展开式中 $x^k$ 的系数是来自每个部分的系数的乘积，其中项的选择对应于 $k$ 的各位数字。这就得出了最终结果：\n$$ \\binom{n}{k} \\equiv \\prod_{i=0}^{m} \\binom{n_i}{k_i} \\pmod{p} $$\n\n算法方法是遍历 $n$ 和 $k$ 的 p 进制数字，为每对数字 $(n_i, k_i)$ 计算 $\\binom{n_i}{k_i} \\pmod{p}$，然后将这些结果在模 $p$ 意义下相乘。\n\n对于数字 $0 \\le a,b  p$，计算 $\\binom{a}{b} \\pmod{p}$ 的方法如下：\n1.  如果 $b > a$，二项式系数 $\\binom{a}{b}$ 定义为 $0$。这是合理的，因为不可能从一个包含 $a$ 个元素的集合中选择 $b$ 个元素。\n2.  如果 $b \\le a$，我们有 $\\binom{a}{b} = \\frac{a!}{b!(a-b)!}$。为了计算这个值模 $p$ 的结果，我们不能直接进行除法。相反，我们使用模乘法逆元。\n    $$ \\binom{a}{b} \\equiv a! \\cdot (b!)^{-1} \\cdot ((a-b)! )^{-1} \\pmod{p} $$\n    一个整数 $x$ 模素数 $p$ 的模乘法逆元存在的充分必要条件是 $x$ 不是 $p$ 的倍数。由于 $b \\le a  p$， $b!$ 和 $(a-b)!$ 中的所有因子都小于 $p$，因此不能被 $p$ 整除。所以，阶乘本身也不能被 $p$ 整除，它们的逆元存在。\n    根据费马小定理 (Fermat's Little Theorem)，对于任何不能被素数 $p$ 整除的整数 $x$，我们有 $x^{p-1} \\equiv 1 \\pmod{p}$。这意味着模逆元是 $x^{-1} \\equiv x^{p-2} \\pmod{p}$。这可以使用模幂运算（或称二进制幂）高效地计算。\n    一个更直接的计算方法是：\n    $$ \\binom{a}{b} = \\frac{a \\cdot (a-1) \\cdots (a-b+1)}{b \\cdot (b-1) \\cdots 1} \\equiv \\left( \\prod_{i=0}^{b-1} (a-i) \\right) \\cdot \\left( \\left( \\prod_{i=1}^{b} i \\right)^{-1} \\right) \\pmod{p} $$\n    这样可以避免计算大的阶乘。\n\n整体算法如下：\n1.  初始化一个结果变量为 $1$。\n2.  如果 $k > n$，返回 $0$。\n3.  当 $n > 0$ 时循环：\n    a. 提取 $n$ 和 $k$ 在 p 进制下的最低位数字：$n_i = n \\pmod p$ 和 $k_i = k \\pmod p$。\n    b. 计算 $c = \\binom{n_i}{k_i} \\pmod p$。如果 $k_i > n_i$，则 $c=0$，最终的乘积将为 $0$。\n    c. 更新结果：`result = (result * c) % p`。\n    d. 通过整除移除最低位数字：$n = n // p$ 和 $k = k // p$。\n4.  返回最终结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Computes binomial coefficients modulo a prime for a suite of test cases\n    based on a first-principles derivation of Lucas's theorem.\n    \"\"\"\n\n    # === Helper Functions ===\n\n    def mod_inverse(n, modulus):\n        \"\"\"\n        Computes the modular multiplicative inverse of n modulo modulus.\n        It is assumed that modulus is a prime number.\n        The inverse is computed using Fermat's Little Theorem: n^(p-2) mod p.\n        \"\"\"\n        return pow(n, modulus - 2, modulus)\n\n    def small_binom_mod_p(n, k, p):\n        \"\"\"\n        Computes C(n, k) mod p for $0 \\le n, k  p$.\n        p is assumed to be a prime number.\n        \"\"\"\n        # C(n, k) = 0 if k  n\n        if k  0 or k  n:\n            return 0\n        \n        # C(n, 0) = 1, C(n, n) = 1\n        if k == 0 or k == n:\n            return 1\n        \n        # Use symmetry C(n, k) = C(n, n-k) to minimize calculations\n        if k  n // 2:\n            k = n - k\n\n        # Calculate numerator: n * (n-1) * ... * (n-k+1) mod p\n        numerator = 1\n        for i in range(k):\n            numerator = (numerator * (n - i)) % p\n\n        # Calculate denominator: k! mod p\n        denominator = 1\n        for i in range(1, k + 1):\n            denominator = (denominator * i) % p\n\n        # Result is numerator * (denominator)^(-1) mod p\n        return (numerator * mod_inverse(denominator, p)) % p\n\n    def lucas_theorem_binom(n, k, p):\n        \"\"\"\n        Computes C(n, k) mod p using Lucas's theorem.\n        n, k are non-negative integers, p is a prime number.\n        \"\"\"\n        # Base case: if k is negative or larger than n, C(n, k) is 0.\n        if k  0 or k  n:\n            return 0\n        \n        # If p is not a prime, or n, k are small, this might not be the best method,\n        # but problem statement guarantees p is prime.\n\n        result = 1\n        # Loop until both n and k are 0\n        while n  0 or k  0:\n            ni = n % p\n            ki = k % p\n\n            # Compute C(ni, ki) mod p\n            term = small_binom_mod_p(ni, ki, p)\n            \n            # If any term is 0, the whole product is 0.\n            if term == 0:\n                return 0\n\n            result = (result * term) % p\n            \n            # Move to the next digits\n            n //= p\n            k //= p\n            \n        return result\n\n    # === Test Suite Execution ===\n\n    test_cases = [\n        (123, 58, 7),\n        (100, 35, 13),\n        (12345, 0, 101),\n        (50, 60, 5),\n        (10, 6, 3),\n        (29, 13, 2),\n        (10, 3, 101),\n    ]\n\n    results = []\n    for n, k, p in test_cases:\n        res = lucas_theorem_binom(n, k, p)\n        results.append(res)\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3087055"}]}