{"hands_on_practices": [{"introduction": "要有效地计算一个数的亲和数，我们首先需要理解最简单的合数——素数幂。这个练习将通过推导素数幂 $p^k$ 的亲和数 $s(p^k)$ 的公式，为后续更复杂的计算奠定基础。这个推导过程本身就是一个很好的练习，它巧妙地运用了等比数列求和公式，这是数论研究中的一个基本工具。", "problem": "在aliquot序列和aliquot类型的研究中，真因子和函数 $s(n)$ 对一个正整数 $n$ 赋予其所有真因子（所有小于 $n$ 的正因子）之和。令 $\\sigma(n)$ 表示 $n$ 的所有正因子之和。根据定义，这些函数满足 $s(n)=\\sigma(n)-n$。从这些核心定义和素数幂的因子的基本性质出发，考虑一个通用素数 $p$ 和一个整数 $k\\geq 1$。仅基于关于 $p^k$ 的因子的基本原理和关于有限等比级数的标准事实，推导真因子和 $s(p^{k})$ 的一个闭式表达式。将你的最终结果表示为一个关于 $p$ 和 $k$ 的单一解析表达式，并以通过关系式 $s(p^{k})=\\sigma(p^{k})-p^{k}$ 明确使用 $\\sigma(p^{k})$ 的形式给出。无需四舍五入。", "solution": "该问题要求推导素数幂的真因子和 $s(p^k)$ 的闭式表达式，其中 $p$ 是一个素数，$k$ 是一个大于或等于 $1$ 的整数。推导过程必须基于基本原理和等比级数的性质。\n\n根据定义，一个正整数 $n$ 的真因子和 $s(n)$ 是其所有真因子之和，即 $n$ 的所有严格小于 $n$ 的正因子之和。$n$ 的所有正因子（包括 $n$ 本身）之和用函数 $\\sigma(n)$ 表示。这两个函数之间的关系如下：\n$$s(n) = \\sigma(n) - n$$\n我们需要求出 $s(p^k)$ 的表达式。为此，我们首先推导 $\\sigma(p^k)$ 的闭式表达式。\n\n根据算术基本定理，任何大于1的整数都有唯一的素数分解。对于一个形如 $p^k$ 的数，其中 $p$ 是一个素数，其因子的结构很简单。$p^k$ 的正因子恰好是 $p$ 从 $p^0$ 到 $p^k$ 的幂。\n$p^k$ 的因子集合是 $\\{p^0, p^1, p^2, \\dots, p^k\\}$。\n\n函数 $\\sigma(p^k)$ 是所有这些因子之和：\n$$\\sigma(p^k) = p^0 + p^1 + p^2 + \\dots + p^k$$\n这个和是一个有限等比级数，其首项 $a = p^0 = 1$，公比 $r = p$，共有 $k+1$ 项。有限等比级数的求和公式为 $S_N = a \\frac{r^N - 1}{r - 1}$，其中 $N$ 是项数。\n将此公式应用于我们的 $\\sigma(p^k)$ 求和，其中 $a=1$，$r=p$，$N=k+1$，我们得到：\n$$\\sigma(p^k) = 1 \\cdot \\frac{p^{k+1} - 1}{p - 1} = \\frac{p^{k+1} - 1}{p-1}$$\n这就是 $p^k$ 的所有因子之和的闭式表达式。\n\n现在，我们对 $n=p^k$ 的特定情况使用给定的关系式 $s(n) = \\sigma(n) - n$：\n$$s(p^k) = \\sigma(p^k) - p^k$$\n代入我们推导出的 $\\sigma(p^k)$ 的表达式，我们得到真因子和 $s(p^k)$ 的闭式表达式：\n$$s(p^k) = \\frac{p^{k+1} - 1}{p - 1} - p^k$$\n这个表达式是关于 $p$ 和 $k$ 的单一解析函数，并且它以明确使用 $\\sigma(p^k)$ 推导公式的形式呈现，符合问题陈述的要求。\n\n为了完整性和一致性检验，我们也可以通过直接对 $p^k$ 的真因子求和来推导 $s(p^k)$。真因子是 $\\{p^0, p^1, p^2, \\dots, p^{k-1}\\}$。它们的和是：\n$$s(p^k) = p^0 + p^1 + p^2 + \\dots + p^{k-1}$$\n这又是一个有限等比级数，这次有 $k$ 项，首项 $a=1$，公比 $r=p$。其和为：\n$$s(p^k) = 1 \\cdot \\frac{p^k - 1}{p - 1} = \\frac{p^k - 1}{p-1}$$\n让我们验证我们的主要结果可以简化为此形式：\n$$s(p^k) = \\frac{p^{k+1} - 1}{p - 1} - p^k = \\frac{p^{k+1} - 1 - p^k(p-1)}{p-1} = \\frac{p^{k+1} - 1 - (p^{k+1} - p^k)}{p-1} = \\frac{p^{k+1} - 1 - p^{k+1} + p^k}{p-1} = \\frac{p^k - 1}{p-1}$$\n两种推导得出了相同的结果，证实了我们方法的正确性。然而，问题明确指出最终结果应以明确表达与 $\\sigma(p^k)$ 关系的形式给出。因此，未简化的形式是所要求的最终答案。", "answer": "$$\\boxed{\\frac{p^{k+1} - 1}{p - 1} - p^k}$$", "id": "3080650"}, {"introduction": "在掌握了如何处理素数幂之后（[@problem_id:3080650]），我们可以将这一知识与算术基本定理结合起来，设计一个通用的算法来计算任何整数 $n$ 的亲和数 $s(n)$。这个实践任务要求你将理论转化为代码，不仅计算出亲和数，还要根据结果将数字分类为亏数、完全数或盈数。这能加深你对亲和数性质的理解，并锻炼你的算法实现能力。", "problem": "您需要设计并实现一个算法来计算真因子和函数 $s(n)$。对于一个正整数 $n$，$s(n)$ 定义为所有严格小于 $n$ 的 $n$ 的正因子之和。该算法必须基于 $n$ 的质因数分解，并从基本原理推导得出：从因子的定义、质因数分解的概念以及除数函数的积性出发。您不得假定任何特殊情况的捷径或使用预计算表。您的实现对于给定测试集中的任何正整数输入都应是通用的且正确的。\n\n您的程序必须：\n- 给定一个正整数 $n$，使用其质因数分解和除数函数的积性结构来计算 $s(n)$。\n- 对每个 $n$，还需计算其分类码 $t(n)$，定义如下：\n  - $t(n)=-1$ 如果 $s(n) < n$ (亏数)，\n  - $t(n)=0$ 如果 $s(n)=n$ (完全数)，\n  - $t(n)=1$ 如果 $s(n) > n$ (盈数)。\n- 根据定义 $s(1)=0$ 处理边界情况 $n=1$。\n\n您可以使用的基础理论包括：\n- $n$ 的因子和真因子的定义。\n- 算术基本定理，该定理保证了每个 $n\\ge 2$ 都能唯一地分解为素数幂的乘积。\n- 除数函数的积性，可从互质整数的因子结构中推导得出。\n- 用于计算单个素数幂因子中素数幂次和的有限几何级数恒等式。\n\n您还必须根据对 $n$ 进行因数分解的复杂度来分析并说明算法的时间复杂度。具体来说，假设对 $n$ 进行因数分解的时间为 $T_{\\mathrm{fact}}(n)$。您必须使用 $T_{\\mathrm{fact}}(n)$ 以及从分解过程中自然产生的其他与 $n$ 相关的算术参数来表示总时间复杂度，并基于上述基础理论给出明确的理由。推理过程应包含在您的解答文本中；程序只应执行计算。\n\n测试集：\n- 待评估的输入 $n$：$[1,2,28,12,25,220,360,9973]$。\n- 对于给定顺序中的每个 $n$，输出数对 $[s(n),t(n)]$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个由方括号括起来的、以逗号分隔的方括号数对列表，且不含多余的空格。例如，输出必须形如 $[[a\\_1,b\\_1],[a\\_2,b\\_2],...]$，其中每个 $a\\_i$ 和 $b\\_i$ 是对应于第 $i$ 个测试输入的 $s(n)$ 和 $t(n)$ 的整数值。\n- 输出必须是严格符合此格式的单行文本：一个顶级列表，按与测试集相同的顺序列出这 8 个有序数对。\n\n您的程序必须是确定性的，且不要求任何输入。不涉及任何物理单位或角度单位；所有输出均为纯整数。测试集的最终答案必须是指定的整数和整数列表，并按所述方式汇总到单行中。", "solution": "该问题要求计算正整数 $n$ 的真因子和 $s(n)$。真因子和定义为所有严格小于 $n$ 的 $n$ 的正因子之和。这些因子也称为 $n$ 的真因子。$n$ 的所有正因子（包括 $n$ 本身）之和用除数函数 $\\sigma(n)$ 表示。根据这些定义，真因子和由关系式 $s(n) = \\sigma(n) - n$ 给出。\n\n该问题还要求根据 $n$ 的真因子和对其进行分类。如果 $s(n) < n$，整数 $n$ 被归类为亏数；如果 $s(n) = n$，则为完全数；如果 $s(n) > n$，则为盈数。这些分类分别对应分类码 $t(n) = -1$，$t(n) = 0$ 和 $t(n) = 1$。\n\n算法的推导必须基于基本原理，特别是使用 $n$ 的质因数分解。\n\n对于边界情况 $n=1$，唯一的正因子是 $1$。其真因子集合为空。因此，真因子之和为 $s(1) = 0$。由于 $s(1) < 1$，数字 $1$ 是亏数，其分类码为 $t(1)=-1$。\n\n对于任何整数 $n \\ge 2$，算术基本定理指出，$n$ 有一个唯一的质因数分解形式：\n$$n = p_1^{a_1} p_2^{a_2} \\cdots p_k^{a_k} = \\prod_{i=1}^{k} p_i^{a_i}$$\n其中 $p_1, p_2, \\dots, p_k$ 是不同的素数，$a_1, a_2, \\dots, a_k$ 是正整数。\n\n$n$ 的任何因子 $d$ 必具有以下形式：\n$$d = p_1^{b_1} p_2^{b_2} \\cdots p_k^{b_k} = \\prod_{i=1}^{k} p_i^{b_i}$$\n其中对于每个 $i \\in \\{1, 2, \\dots, k\\}$，指数 $b_i$ 是满足 $0 \\le b_i \\le a_i$ 的整数。\n\n除数函数 $\\sigma(n)$ 是所有此类因子 $d$ 的和。这可以表示为对所有可能的指数 $b_i$ 值的嵌套求和：\n$$\\sigma(n) = \\sum_{b_1=0}^{a_1} \\sum_{b_2=0}^{a_2} \\cdots \\sum_{b_k=0}^{a_k} \\left( p_1^{b_1} p_2^{b_2} \\cdots p_k^{b_k} \\right)$$\n由于乘法对加法具有分配律，这个多维和可以分解为一维和的乘积：\n$$\\sigma(n) = \\left( \\sum_{b_1=0}^{a_1} p_1^{b_1} \\right) \\left( \\sum_{b_2=0}^{a_2} p_2^{b_2} \\right) \\cdots \\left( \\sum_{b_k=0}^{a_k} p_k^{b_k} \\right) = \\prod_{i=1}^{k} \\left( \\sum_{b_i=0}^{a_i} p_i^{b_i} \\right)$$\n这个表达式揭示了 $\\sigma$ 函数的积性。对于每个素数因子 $p_i^{a_i}$，其对应的项是 $\\sigma(p_i^{a_i}) = \\sum_{b_i=0}^{a_i} p_i^{b_i}$。因此，$\\sigma(n) = \\prod_{i=1}^{k} \\sigma(p_i^{a_i})$。\n\n每个和 $\\sum_{b=0}^{a} p^b = 1 + p + p^2 + \\dots + p^a$ 都是一个有限几何级数。几何级数的求和公式为 $\\sum_{j=0}^{m} r^j = \\frac{r^{m+1}-1}{r-1}$。将此公式应用于 $r=p$ 和 $m=a$ 的情况，我们得到：\n$$\\sigma(p^a) = \\frac{p^{a+1}-1}{p-1}$$\n将其代回 $\\sigma(n)$ 的乘积表达式中，我们得到基于质因数分解的完整公式：\n$$\\sigma(n) = \\prod_{i=1}^{k} \\frac{p_i^{a_i+1}-1}{p_i-1}$$\n\n计算 $s(n)$ 和 $t(n)$ 的算法可以总结如下：\n1. 处理边界情况：如果 $n=1$，返回 $s(1)=0$ 和 $t(1)=-1$。\n2. 对于 $n \\ge 2$，找出其质因数分解 $n = \\prod_{i=1}^{k} p_i^{a_i}$。这将得到一组数对 $(p_i, a_i)$。\n3. 将除数之和 $\\sigma_{val}$ 初始化为 $1$。\n4. 对于分解中的每个数对 $(p_i, a_i)$，计算项 $\\sigma(p_i^{a_i}) = \\frac{p_i^{a_i+1}-1}{p_i-1}$。\n5. 将此项乘入累积乘积中：$\\sigma_{val} = \\sigma_{val} \\times \\sigma(p_i^{a_i})$。\n6. 遍历所有素数因子后，最终值为 $\\sigma(n) = \\sigma_{val}$。\n7. 计算真因子和：$s(n) = \\sigma(n) - n$。\n8. 通过比较 $s(n)$ 与 $n$ 来确定分类码 $t(n)$：\n   - 如果 $s(n) < n$，$t(n) = -1$。\n   - 如果 $s(n) = n$，$t(n) = 0$。\n   - 如果 $s(n) > n$，$t(n) = 1$。\n\n该算法的时间复杂度主要由质因数分解步骤决定。设 $T_{\\mathrm{fact}}(n)$ 为找出 $n$ 的质因数分解所需的时间。分解后的步骤涉及遍历 $n$ 的 $k$ 个不同素数因子。对于每个因子 $p_i^{a_i}$，我们执行常数次算术运算（求幂、减法、除法）。不同素数因子的数量 $k$ 最多为 $O(\\log n)$。中间和最终数值的大小在 $n$ 的多项式范围内。具体来说，对这些数进行算术运算的时间是其位长度（即 $O(\\log n)$）的多项式。因此，分解后计算的总时间为 $O(\\text{poly}(\\log n))$。由于整数分解是一个计算困难问题，目前已知的最佳算法在 $\\log n$ 上具有超多项式复杂度，因此 $T_{\\mathrm{fact}}(n)$ 是主导项。所以，该算法的总时间复杂度为 $O(T_{\\mathrm{fact}}(n))$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the aliquot sum and aliquot type for a given list of integers,\n    as per the problem statement.\n    \"\"\"\n\n    def get_prime_factorization(n):\n        \"\"\"\n        Computes the prime factorization of a positive integer n.\n        Returns a dictionary mapping each prime factor to its exponent.\n        Uses trial division, which is efficient for the given test cases.\n        \"\"\"\n        if n  1:\n            return {}\n        \n        factors = {}\n        # Handle factor 2\n        while n % 2 == 0:\n            factors[2] = factors.get(2, 0) + 1\n            n //= 2\n        \n        # Handle odd factors\n        d = 3\n        while d * d = n:\n            while n % d == 0:\n                factors[d] = factors.get(d, 0) + 1\n                n //= d\n            d += 2\n            \n        # If n is still greater than 1, it must be a prime factor itself.\n        if n > 1:\n            factors[n] = factors.get(n, 0) + 1\n            \n        return factors\n\n    def compute_s_and_t(n):\n        \"\"\"\n        Computes the aliquot sum s(n) and aliquot type code t(n).\n        \"\"\"\n        if n == 1:\n            s_n = 0\n            t_n = -1  # Deficient\n            return [s_n, t_n]\n\n        factors = get_prime_factorization(n)\n        \n        sigma_n = 1\n        for p, a in factors.items():\n            # Using the geometric series sum formula: (p^(a+1) - 1) / (p - 1)\n            sigma_p_a = (p**(a + 1) - 1) // (p - 1)\n            sigma_n *= sigma_p_a\n            \n        s_n = sigma_n - n\n        \n        if s_n  n:\n            t_n = -1  # Deficient\n        elif s_n == n:\n            t_n = 0   # Perfect\n        else:\n            t_n = 1   # Abundant\n            \n        return [s_n, t_n]\n\n    test_cases = [1, 2, 28, 12, 25, 220, 360, 9973]\n    \n    results = []\n    for n in test_cases:\n        result = compute_s_and_t(n)\n        results.append(result)\n\n    # Format the output string exactly as specified, with no extra whitespace.\n    pair_strings = [f\"[{s},{t}]\" for s, t in results]\n    final_output = f\"[{','.join(pair_strings)}]\"\n    \n    # Final print statement in the exact required format.\n    print(final_output)\n\nsolve()\n```", "id": "3080697"}, {"introduction": "亲和数的真正魅力在于它们通过迭代所产生的序列。这个高级实践将带领你从静态的单次计算（[@problem_id:3080697]）转向动态的序列分析。你的任务是跟踪亲和序列的演变，并运用经典的算法技巧（如哈希表或Floyd判圈算法）来判断序列是终止还是进入循环。通过这个练习，你将学会量化序列的行为，例如计算尾长和循环长度，从而深入探索这一迷人的数论问题。", "problem": "你需要实现一个完整的、可运行的程序，该程序为给定的起始整数计算真因子序列，直到检测到序列终止或进入循环为止。从第一性原理出发，使用真因子和函数的定义以及其导出的序列。推导并实现基于哈希的检测和 Floyd 判环算法，以确保程序的稳健性。该程序必须计算指定的数值不变量，用以量化每个真因子序列的行为。\n\n定义与基本原理：\n- 对于任意整数 $n \\geq 0$，定义 $n$ 的真因子集合为所有满足 $d \\mid n$ 且 $0  d  n$ 的正整数 $d$。定义真因子和函数 $s(n)$ 为 $s(n) = \\sum_{d \\mid n, \\; 0  d  n} d$，并约定 $s(0) = 0$ 和 $s(1) = 0$。\n- 从 $a_0 = n$ 开始的真因子序列 $\\{a_k\\}_{k \\geq 0}$ 通过递推关系 $a_{k+1} = s(a_k)$ (对所有 $k \\geq 0$) 定义。\n- 如果序列在某个有限索引处达到 $0$，则称该序列终止。如果存在整数 $\\mu \\geq 0$ 和 $\\lambda \\geq 1$ 使得 $a_{\\mu} = a_{\\mu+\\lambda}$，并且此后对所有 $t \\geq \\mu$ 都有 $a_{t+\\lambda} = a_t$，则称该序列是循环的。整数 $\\mu$ 是前导期（也称为尾部长度），$\\lambda$ 是循环长度。\n- 为了规范化报告循环，定义循环代表元 $c$：在终止情况下为 $0$，在循环情况下为集合 $\\{a_{\\mu}, a_{\\mu+1}, \\ldots, a_{\\mu+\\lambda-1}\\}$ 中（按整数的常规顺序）的最小元素。\n\n任务要求：\n- 根据 $s(n)$ 的定义实现一个函数来计算它，仅使用基本的因子性质（例如，如果 $d \\mid n$ 且 $1  d \\leq \\sqrt{n}$，那么 $d$ 和 $n/d$ 都是因子）。\n- 为由 $s(n)$ 生成的序列实现两种独立的循环检测策略：\n  1. 一种基于哈希的方法，记录访问过的值及其首次出现的索引，以检测首次重复并确定 $\\mu$ 和 $\\lambda$。\n  2. Floyd 判环算法（也称为龟兔赛跑法），经过调整以在遇到 $0$ 时检测终止，否则用于恢复 $\\mu$ 和 $\\lambda$。\n- 将起始值 $n$ 的输出不变量定义为三元组 $[\\mu, \\lambda, c]$，其中当且仅当序列终止时 $c=0$，否则 $c$ 是最终循环中的最小元素。\n\n测试套件：\n- 你的程序必须评估起始值 $n \\in \\{1, 6, 10, 13, 220, 12496\\}$，并为每个值计算对应的三元组 $[\\mu, \\lambda, c]$。\n- 这些值涵盖了一个边界情况（$n = 1$）、一个作为不动点的完全数（$n = 6$）、一个普通的终止情况（$n = 10$）、一个通过 $1$ 终止的素数（$n = 13$）、一个导致 2-循环的亲和数对（$n = 220$），以及一个长度为 5 的社交环（$n = 12496$）。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，列表中的每个条目本身也是一个用方括号括起来的三元组。对于指定的测试套件，输出必须采用以下格式： $[[\\mu_1,\\lambda_1,c_1],[\\mu_2,\\lambda_2,c_2],...,[\\mu_6,\\lambda_6,c_6]]$，且不含空格。", "solution": "解决方案分三个阶段进行。首先，我们构建真因子和函数 $s(n)$，它是序列的生成器。其次，我们形式化真因子序列的生成过程以及所需数值不变量的定义：前导期长度 $\\mu$、循环长度 $\\lambda$ 和循环代表元 $c$。最后，我们详细说明用于检测循环和终止的两种不同算法的实现——基于哈希的方法和 Floyd 判环算法——以便为任何给定的起始整数 $n$ 计算这些不变量。\n\n### 1. 真因子和函数 $s(n)$\n\n问题的核心是函数 $s(n)$，其定义为整数 $n$ 的所有正因子（不包括 $n$ 本身）之和。其定义为 $s(n) = \\sum_{d|n, 0  d  n} d$。约定 $s(0) = 0$ 和 $s(1) = 0$。\n\n对于 $n  1$，我们可以高效地计算 $s(n)$。整数 $1$ 始终是一个真因子，所以我们可以用 $1$ 初始化一个和。然后我们搜索其他因子。因子的一个关键性质是它们成对出现。如果 $d$ 是 $n$ 的一个因子，那么 $n/d$ 也是一个因子。我们可以利用这一点，通过从 $2$ 迭代测试因子 $d$ 直到 $n$ 的平方根的整数部分 $\\lfloor\\sqrt{n}\\rfloor$。\n\n算法如下：\n1.  根据定义处理基本情况：如果 $n \\le 1$，返回 $0$。\n2.  对于 $n  1$，初始化变量 `total_sum` 为 $1$，计入因子 $d=1$。\n3.  用整数 $d$ 从 $2$ 迭代至（并包括）$\\lfloor\\sqrt{n}\\rfloor$。\n4.  在每次迭代中，如果 $d$ 整除 $n$（即 $n \\pmod d = 0$），那么 $d$ 是一个真因子，我们将其加到 `total_sum` 中。其对应的成对因子是 $q = n/d$。\n5.  如果 $d$ 不等于其配对因子 $q$（当 $n$ 不是完全平方数时发生），则 $q$ 是另一个不同的因子。我们也把 $q$ 加到 `total_sum` 中。如果 $d=q$（即 $n=d^2$），我们已经计入了这一个因子 $d$，因此无需对这对因子做进一步操作。\n6.  `total_sum` 的最终值就是 $s(n)$。\n\n例如，计算 $s(220)$：$\\sqrt{220} \\approx 14.8$。\n- 初始化和 = $1$。\n- 直到 $14$ 的因子有：$2, 4, 5, 10, 11$。\n- 配对因子：$220/2=110$, $220/4=55$, $220/5=44$, $220/10=22$, $220/11=20$。\n- $s(220) = 1 + 2 + 4 + 5 + 10 + 11 + 20 + 22 + 44 + 55 + 110 = 284$。\n\n### 2. 真因子序列不变量：$[\\mu, \\lambda, c]$\n\n真因子序列是通过从初始整数 $a_0=n$ 开始迭代 $s(n)$ 函数生成的：\n$$ a_{k+1} = s(a_k) \\quad \\text{for } k \\geq 0 $$\n这个序列 $\\{a_k\\}_{k \\geq 0}$ 要么通过达到 $0$ 而终止，要么最终重复，进入一个循环。我们的任务是使用三个不变量来量化这种行为：\n-   **前导期长度 ($\\mu$)**：序列在进入周期性或终止之前的项数。这是“尾部”的长度。\n-   **循环长度 ($\\lambda$)**：重复循环中唯一项的数目。对于终止序列，不存在循环，因此我们约定 $\\lambda = 0$。\n-   **循环代表元 ($c$)**：对于循环序列，这是循环 $\\{a_\\mu, a_{\\mu+1}, \\ldots, a_{\\mu+\\lambda-1}\\}$ 内的最小整数值。对于终止序列，我们设定 $c = 0$。\n\n### 3. 循环与终止检测算法\n\n我们实现两种独立的算法来寻找不变量 $[\\mu, \\lambda, c]$。\n\n#### 方法一：基于哈希的检测\n\n该方法依赖内存来跟踪序列中生成的每一项。使用哈希映射（或字典）来存储遇到的每个唯一项及其首次出现的索引。\n1.  初始化一个空序列列表 `seq`，并添加起始值 $n$，即 `seq = [n]`。\n2.  初始化一个哈希映射 `visited`，将值 $n$ 映射到其索引 $0$：`visited = {n: 0}`。\n3.  开始一个循环以生成后续项：\n    a.  令 `current_val` 为 `seq` 中的最后一项。计算 `next_val = s(current_val)`。\n    b.  **终止检查**：如果 `next_val` 是 $0$，序列终止。前导期长度是 $0$ 之前所有项的计数，因此 $\\mu = \\text{len(seq)}$。根据约定，我们设置 $\\lambda = 0$ 和 $c = 0$。对此起始值的处理完成。\n    c.  **循环检查**：如果 `next_val` 已经是 `visited` 映射中的一个键，则检测到循环。我们第一次看到这个值是在索引 $\\mu = \\text{visited[next_val]}$ 处。当前生成的项数为 $\\text{len(seq)}$。因此，循环长度为 $\\lambda = \\text{len(seq)} - \\mu$。循环的元素由子序列 `seq[μ:]` 给出。循环代表元是 $c = \\min(\\text{seq[μ:]})$。处理完成。\n    d.  **继续**：如果 `next_val` 不是 $0$ 且尚未被访问过，则记录它：将 `next_val` 及其索引添加到 `visited` 映射中，`visited[next_val] = len(seq)`，并将其附加到 `seq` 列表中。然后，继续循环。\n\n此方法简单直接，能直接得出所有三个不变量 $\\mu$、$\\lambda$ 和 $c$。\n\n#### 方法二：Floyd 判环算法（龟兔赛跑法）\n\n该算法使用两个指针，一个“乌龟”和一个“兔子”，以不同速度在序列中移动。它能以常数空间复杂度检测到循环，但需要额外的步骤来找到不变量。\n\n1.  **阶段一：检测循环或终止**\n    a.  初始化 `tortoise = s(n)` 和 `hare = s(s(n))`。处理这些初始值可能为 $0$ 的边缘情况，这表示立即终止。\n    b.  在循环中推进指针：`tortoise = s(tortoise)` 和 `hare = s(s(hare))`。\n    c.  如果 `tortoise == hare`（检测到循环）或 `tortoise` 或 `hare` 变为 $0$（检测到终止），则循环终止。\n\n2.  **阶段二：确定不变量**\n    a.  **如果检测到终止**：序列以 $0$ 结束。要找到 $\\mu$，我们必须从头重新追踪序列：初始化 `current_val = n` 和一个计数器 `mu_val = 0`。逐步遍历序列（`current_val = s(current_val)`）直到 `current_val` 变为 $0$，每一步都增加 `mu_val`。最终的计数就是 $\\mu$。其他不变量为 $\\lambda=0$ 和 $c=0$。\n    b.  **如果检测到循环**：两个指针在值 `tortoise` 处相遇，该值是循环内的一个元素。\n        i.  **寻找前导期长度 ($\\mu$)**：将一个指针 `ptr1` 初始化为起点 $n$，另一个指针 `ptr2` 初始化为相遇点 `tortoise`。两个指针每次都前进一步（`ptr1 = s(ptr1)`, `ptr2 = s(ptr2)`）。它们首次相等的点就是循环的第一个元素 $a_\\mu$。所走的步数就是前导期长度 $\\mu$。\n        ii. **寻找循环长度 ($\\lambda$)**：从循环的第一个元素 $a_\\mu$ 开始，每次将指针前进一步（`ptr = s(ptr)`），直到它返回到 $a_\\mu$。所走的步数就是循环长度 $\\lambda$。\n        iii. **寻找循环代表元 ($c$)**：从 $a_\\mu$ 开始，遍历循环中的 $\\lambda$ 个元素，并找到它们的最小值。这个最小值就是 $c$。\n\n两种方法都在最终程序中实现。由于基于哈希的方法能更直接地计算所有三个所需的不变量，因此用它来生成最终输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# from scipy import ... is not needed for this problem.\n\ndef s(n: int) -> int:\n    \"\"\"\n    Computes the sum of proper divisors of an integer n, s(n).\n    s(n) is the sum of all positive integers d such that d | n and 0  d  n.\n    By convention, s(0) = 0 and s(1) = 0.\n    \"\"\"\n    if n = 1:\n        return 0\n    \n    # Initialize sum with 1, as 1 is a proper divisor for all n > 1.\n    total = 1\n    \n    # Iterate from 2 up to the square root of n.\n    # np.sqrt is used as per the allowed library set.\n    limit = int(np.sqrt(n))\n    for d in range(2, limit + 1):\n        if n % d == 0:\n            total += d\n            quotient = n // d\n            # Add the paired divisor if it's not the same as d (for non-perfect squares).\n            if d != quotient:\n                total += quotient\n                \n    return total\n\ndef analyze_sequence_hash(n: int) -> list[int]:\n    \"\"\"\n    Analyzes the aliquot sequence starting at n using a hashing-based method.\n    \n    Returns:\n        A list [mu, lambda, c] representing the preperiod, cycle length,\n        and cycle representative.\n    \"\"\"\n    if n == 0:\n        return [0, 1, 0] # A fixed point, but often treated as termination.\n                         # The prompt definition s(0)=0 leads to [0, 1, 0].\n                         # Let's align with the termination definition.\n                         # Sequence 0 -> 0. Preperiod 0. Cycle length 1. rep 0.\n                         # But test cases imply 0 means termination. So we just need to handle s(a_k)=0.\n    \n    sequence = [n]\n    visited = {n: 0} # Maps value to its first index\n    k = 0\n    while True:\n        # We add a practical limit to prevent potential infinite loops on\n        # sequences whose behavior is unknown (e.g., Lehmer five), though not\n        # strictly needed for the given test cases.\n        if k > 2000:\n            # This case should not be reached for the provided inputs\n            raise RuntimeError(f\"Sequence starting at {n} did not resolve within the iteration limit.\")\n\n        current_val = sequence[-1]\n        next_val = s(current_val)\n        \n        # Termination check\n        if next_val == 0:\n            mu = len(sequence)\n            lam = 0\n            c = 0\n            return [mu, lam, c]\n        \n        # Cycle detection check\n        if next_val in visited:\n            mu = visited[next_val]\n            lam = len(sequence) - mu\n            cycle = sequence[mu:]\n            c = min(cycle)\n            return [mu, lam, c]\n            \n        # Continue sequence generation\n        visited[next_val] = len(sequence)\n        sequence.append(next_val)\n        k += 1\n\ndef analyze_sequence_floyd(n: int) -> list[int]:\n    \"\"\"\n    Analyzes the aliquot sequence starting at n using Floyd's cycle-finding algorithm.\n    This function is implemented to satisfy the problem requirement but is not\n    used to generate the final output. The hash-based method is more direct.\n    \n    Returns:\n        A list [mu, lambda, c].\n    \"\"\"\n    # Handle simple termination cases first\n    if n == 0:\n        return [0, 0, 0] # Terminating\n    val_s = s(n)\n    if val_s == 0:\n        return [1, 0, 0] # n -> 0\n    val_ss = s(val_s)\n    if val_ss == 0:\n        return [2, 0, 0] # n -> s(n) -> 0\n\n    tortoise = val_s\n    hare = val_ss\n    \n    # Phase 1: Find a meeting point or termination\n    while tortoise != hare:\n        tortoise = s(tortoise)\n        hare = s(s(hare))\n        if tortoise == 0 or hare == 0:\n            # Termination found\n            mu = 0\n            curr = n\n            while curr != 0:\n                curr = s(curr)\n                mu += 1\n            return [mu, 0, 0]\n\n    # Phase 2: Cycle found, now find invariants\n    # Find preperiod length (mu)\n    mu = 0\n    ptr1 = n\n    ptr2 = tortoise\n    while ptr1 != ptr2:\n        ptr1 = s(ptr1)\n        ptr2 = s(ptr2)\n        mu += 1\n    \n    # Find cycle length (lambda)\n    lam = 1\n    ptr2 = s(ptr1)\n    cycle_min = ptr1\n    while ptr1 != ptr2:\n        cycle_min = min(cycle_min, ptr2)\n        ptr2 = s(ptr2)\n        lam += 1\n        \n    c = cycle_min\n    \n    return [mu, lam, c]\n\ndef solve():\n    \"\"\"\n    Main function to run the analysis on the test suite and print the output.\n    \"\"\"\n    test_cases = [1, 6, 10, 13, 220, 12496]\n\n    results = []\n    # We use the hash-based method as it's more direct for finding all invariants.\n    # The problem requires implementing both methods; `analyze_sequence_floyd` is also provided.\n    for n in test_cases:\n        mu, lam, c = analyze_sequence_hash(n)\n        results.append(f\"[{mu},{lam},{c}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3080656"}]}