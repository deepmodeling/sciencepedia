{"hands_on_practices": [{"introduction": "在直接解决卡塔兰猜想之前，理解完美幂的整体分布至关重要。第一个练习 [@problem_id:3082991] 将引导你编写一个程序，生成给定上限内的所有完美幂，并分析它们的分布，特别是它们之间的间隔。这种计算性探索将让你对为何连续的完美幂如此罕见有一个直观的感受。", "problem": "设 $x$、$y$、$a$ 和 $b$ 为整数，满足 $x \\ge 2$、$y \\ge 2$、$a \\ge 2$ 和 $b \\ge 2$。如果存在整数 $u \\ge 2$ 和 $v \\ge 2$ 使得 $n = u^v$，则正整数 $n$ 被称为一个完全幂。Catalan 猜想（已由 Mihăilescu 定理证明）指出，对于满足 $x \\ge 2$、$y \\ge 2$、$a \\ge 2$ 和 $b \\ge 2$ 的指数丢番图方程 $x^a - y^b = 1$，其在正整数中的唯一解是 $3^2 - 2^3 = 1$，等价地说，唯一一对连续的完全幂是 $\\{8,9\\}$。\n\n请仅使用基本定义和经过充分检验的事实，实现一个程序，对以给定整数 $B$ 为上界的完全幂进行小规模的计算搜索和情况检查。对于每个测试用例，将给定一个序对 $(B,m)$，其中 $B$ 是搜索的包含性上界，$m$ 指示计算模式。对于给定的界 $B$，定义集合\n$$\nS_B = \\{\\,u^v \\mid u \\in \\mathbb{Z},\\ v \\in \\mathbb{Z},\\ u \\ge 2,\\ v \\ge 2,\\ u^v \\le B \\,\\}.\n$$\n你的程序必须构建 $S_B$，然后根据模式 $m$ 计算以下其中一项：\n\n- 模式 $m = 0$（非 Catalan 连续完全幂的存在性）：判断是否存在一对不同的元素 $p, q \\in S_B$ 使得 $|p - q| = 1$ 且 $\\{p,q\\} \\ne \\{8,9\\}$。如果存在这样的序对，则返回布尔值 $\\,\\text{True}\\,$，否则返回 $\\,\\text{False}\\,$。\n\n- 模式 $m = 1$（完全幂之间的最小间距）：计算 $S_B$ 中不同元素 $p, q$ 之间的最小绝对差 $|p - q|$。如果 $S_B$ 的元素少于两个，则返回 $-1$。否则，返回所有不同序对的 $|p - q|$ 的最小可能整数值。\n\n- 模式 $m = 2$（连续完全幂对的数量）：计算 $S_B$ 中满足 $p  q$ 且 $q - p = 1$ 的不同元素有序对 $(p,q)$ 的数量。以整数形式返回此计数。注意，这只计算每个有序对一次；例如，当 8 和 9 都在 $S_B$ 中时，序对 $\\{8,9\\}$ 对计数的贡献恰好为 1。\n\n为确保科学真实性和清晰性，请将你的解决方案建立在以下基本组成部分之上：\n- 如上所述的完全幂的定义。\n- 整数和顺序的基本性质：如果一个有限整数集按升序排列，则不同元素之间的最小绝对差出现在排序后列表中的相邻元素之间。\n- 指数的对数界限：由于对于 $S_B$ 中存在的任何指数 $v$，都有 $2^v \\le B$，因此可以得出 $v \\le \\lfloor \\log_2(B) \\rfloor$。\n\n实现你的程序以处理以下 $(B,m)$ 序对的测试套件：\n- 测试用例 1：$(B,m) = (3,0)$。\n- 测试用例 2：$(B,m) = (10,2)$。\n- 测试用例 3：$(B,m) = (100,1)$。\n- 测试用例 4：$(B,m) = (15,0)$。\n- 测试用例 5：$(B,m) = (7,1)$。\n\n你的程序应生成单行输出，其中包含这些测试用例的结果，结果为逗号分隔的列表，并用方括号括起来，顺序与测试套件相同（例如，$[result_1,result_2,result_3,result_4,result_5]$）。所有输出必须是指定的基本类型：模式 $m=0$ 为布尔型，模式 $m=1$ 和 $m=2$ 为整型。此问题不涉及物理单位，也无需报告角度或百分比。", "solution": "该问题已经过验证，并被确定为一个有效、良构的数论计算问题。它在科学上基于完全幂的定义和 Catalan 猜想，其组成部分定义清晰，没有矛盾或歧义。\n\n核心任务是实现一个算法，对于给定的整数界 $B$，构建完全幂集合 $S_B$，然后基于模式参数 $m$ 执行三种计算之一。该集合定义为：\n$$\nS_B = \\{\\,u^v \\mid u \\in \\mathbb{Z},\\ v \\in \\mathbb{Z},\\ u \\ge 2,\\ v \\ge 2,\\ u^v \\le B \\,\\}\n$$\n解决方案包括两个主要阶段：首先，高效地生成集合 $S_B$；其次，为每个指定模式 $m \\in \\{0, 1, 2\\}$ 实现相应逻辑。\n\n**阶段 1：生成集合 $S_B$**\n\n为构建给定界 $B$ 的集合 $S_B$，我们必须找到所有形如 $u^v$ 且小于或等于 $B$ 的整数，并满足约束条件 $u \\ge 2$ 和 $v \\ge 2$。对所有不大于 $B$ 的整数进行直接搜索以检查它们是否为完全幂，这种方法效率低下。一种更系统的方法是通过遍历可能的底数 $u$ 和指数 $v$ 来生成这些幂。\n\n底数 $u$ 和指数 $v$ 的搜索空间可以被约束。\n1.  对于底数 $u$：由于 $v \\ge 2$，任何底数 $u$ 的最小幂是 $u^2$。条件 $u^2 \\le B$ 必须成立，这意味着 $u \\le \\sqrt{B}$。因此，底数 $u$ 只需在 $2 \\le u \\le \\lfloor \\sqrt{B} \\rfloor$ 的范围内检查。\n2.  对于指数 $v$：对于给定的底数 $u$，我们必须找到所有满足 $u^v \\le B$ 的指数 $v \\ge 2$。\n\n算法按以下步骤进行：\n- 初始化一个空的集合数据结构来存储完全幂。使用集合是为了自动处理重复项，例如 $64 = 8^2 = 4^3 = 2^6$。\n- 遍历从 $2$ 到 $\\lfloor \\sqrt{B} \\rfloor$ 的每个可能的底数 $u$。\n- 对每个底数 $u$，从 $v=2$ 开始计算其幂 $u^v$。我们从值 $p = u^2$ 开始。\n- 只要 $p \\le B$，我们就将 $p$ 添加到我们的集合中。然后，我们将 $p$ 更新到下一个幂，即 $p \\leftarrow p \\cdot u$，并重复检查。\n- 如果在任何时候 $p  B$，那么该底数 $u$ 的所有后续幂也都将超过 $B$，因此我们可以终止内层循环，并继续处理下一个底数 $u+1$。\n- 在处理完所有有效的底数后，得到的集合包含 $S_B$ 的所有唯一元素。为了进行后续处理，将此集合转换为一个排序后的列表（我们称之为 $L_B$）是非常有利的。\n\n**阶段 2：特定模式的计算**\n\n一旦完全幂的排序列表 $L_B$ 可用，我们就可以为每种模式执行所需的计算。\n\n- **模式 $m = 0$（非 Catalan 连续完全幂的存在性）：**\n目标是判断是否存在一对不同的元素 $p, q \\in S_B$ 使得 $|p - q| = 1$ 且 $\\{p,q\\} \\ne \\{8,9\\}$。由于 $L_B$ 是排序的，任何差为 1 的此类序对在列表中必须是相邻的。算法遍历 $L_B$ 并检查每对相邻元素 $(L_B[i], L_B[i+1])$。对于每对元素，它检查是否 $L_B[i+1] - L_B[i] = 1$。如果满足此条件，它会进一步检查该序对是否为 $\\{8, 9\\}$。如果找到了一个不是 $\\{8, 9\\}$ 的连续序对，函数返回 $\\text{True}$。如果遍历整个列表都没有找到这样的序对，函数返回 $\\text{False}$。\n\n- **模式 $m = 1$（完全幂之间的最小间距）：**\n任务是找到 $S_B$ 中任意两个不同元素 $p, q$ 之间的最小绝对差 $|p-q|$。问题正确地指出，对于一个排序的数字列表，这个最小差值总是出现在两个相邻元素之间。首先，我们处理边界情况：如果 $S_B$ 包含的元素少于两个（即 $L_B$ 的长度小于 2），则无法计算差值，必须返回 $-1$。否则，我们初始化一个变量 `min_gap` 为一个很大的值（或设为前两个元素之差 $L_B[1] - L_B[0]$）。然后我们遍历 $L_B$ 中的相邻序对，从 $(L_B[0], L_B[1])$ 到 $(L_B[k-2], L_B[k-1])$，其中 $k$ 是列表的大小。在每一步中，我们计算差值 $L_B[i+1] - L_B[i]$，如果这个新差值更小，就更新 `min_gap`。`min_gap` 的最终值就是结果。\n\n- **模式 $m = 2$（连续完全幂对的数量）：**\n此模式要求计算 $S_B$ 中满足 $p  q$ 且 $q - p = 1$ 的不同元素有序对 $(p,q)$ 的数量。同样，使用排序列表 $L_B$ 是最优的。任何这样的序对在 $L_B$ 中必须是相邻的。我们初始化一个计数器为 $0$。我们从头开始遍历 $L_B$ 的相邻元素。对于每对 $(L_B[i], L_B[i+1])$，我们检查是否 $L_B[i+1] - L_B[i] = 1$。如果是，我们就增加计数器。计数器的最终值即为返回结果。如果 8 和 9 都存在于 $S_B$ 中，这种方法可以正确地将序对 $\\{8,9\\}$ 计数一次。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# No other non-standard libraries are used.\n\ndef calculate_result(B, m):\n    \"\"\"\n    Calculates the result for a given test case (B, m).\n    \n    This function first generates the set S_B of perfect powers up to B,\n    then performs a computation based on the mode m.\n    \"\"\"\n\n    # Stage 1: Generate the set S_B of perfect powers\n    # A perfect power n = u^v with u=2, v=2.\n    # The smallest power is 2^2 = 4, so if B  4, the set is empty.\n    if B  4:\n        sorted_powers = []\n    else:\n        perfect_powers = set()\n        # The base u must satisfy u^2 = B, so u = sqrt(B).\n        u_limit = int(np.sqrt(B))\n        for u in range(2, u_limit + 1):\n            # Calculate powers of u starting from u^2.\n            power = u * u\n            while power = B:\n                perfect_powers.add(power)\n                # To prevent potential overflow on large numbers and for efficiency,\n                # check if the next multiplication would exceed B.\n                if B // u  power:\n                    break\n                power *= u\n        \n        sorted_powers = sorted(list(perfect_powers))\n\n    # Stage 2: Mode-specific computations\n    if m == 0:\n        # Mode 0: Check for existence of a non-Catalan consecutive pair.\n        for i in range(len(sorted_powers) - 1):\n            p = sorted_powers[i]\n            q = sorted_powers[i+1]\n            if q - p == 1:\n                # Catalan's pair is {8, 9}. We are looking for others.\n                if not (p == 8 and q == 9):\n                    return True\n        return False\n\n    elif m == 1:\n        # Mode 1: Find the minimal gap between distinct perfect powers.\n        if len(sorted_powers)  2:\n            return -1\n        \n        min_gap = np.inf\n        for i in range(len(sorted_powers) - 1):\n            gap = sorted_powers[i+1] - sorted_powers[i]\n            if gap  min_gap:\n                min_gap = gap\n        return int(min_gap)\n\n    elif m == 2:\n        # Mode 2: Count the number of consecutive perfect power pairs.\n        count = 0\n        for i in range(len(sorted_powers) - 1):\n            p = sorted_powers[i]\n            q = sorted_powers[i+1]\n            if q - p == 1:\n                count += 1\n        return count\n    \n    # Should not be reached with valid mode values.\n    return None\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (3, 0),\n        (10, 2),\n        (100, 1),\n        (15, 0),\n        (7, 1),\n    ]\n\n    results = []\n    for case in test_cases:\n        B, m = case\n        result = calculate_result(B, m)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3082991"}, {"introduction": "在掌握了完美幂的分布规律后，我们现在将注意力集中在卡塔兰猜想的核心：寻找连续的完美幂。这个练习 [@problem_id:3082993] 要求你设计一个高效的算法，以在给定范围内找出方程 $x^a - y^b = 1$ 的所有解。完成这项任务需要运用算法设计的关键原则，如有效枚举和剪枝，来解决一个经典的数论问题。", "problem": "考虑由整数 $x^a$ 定义的完全幂集合，其中 $x \\in \\mathbb{Z}$，$x \\ge 2$ 且 $a \\in \\mathbb{Z}$，$a \\ge 2$。被称为 Catalan 猜想（已由 Mihăilescu 定理证明）的经典论断，断言了整数中连续完全幂的唯一性。在本问题中，您将设计并实现一种系统性的枚举和搜索策略，以在给定边界内找出所有满足以下条件的整数四元组 $(x,a,y,b)$：$x \\ge 2$，$y \\ge 2$，$a \\ge 2$，$b \\ge 2$ 且\n$$\nx^a - y^b = 1,\n$$\n同时受限于给定上限 $N \\in \\mathbb{Z}$，$N \\ge 1$ 的约束条件 $x^a \\le N$ 和 $y^b \\le N$。\n\n您的算法必须基于以下基本原理从头推导：\n\n- 完全幂的定义：若存在整数 $x \\ge 2$ 和 $a \\ge 2$ 使得 $n = x^a$，则整数 $n$ 是一个完全幂。\n- 整数幂运算的单调性：对于固定的 $a \\ge 2$，函数 $f(x) = x^a$ 在 $x \\ge 2$ 上严格递增；对于固定的 $x \\ge 2$，函数 $g(a) = x^a$ 在 $a \\ge 2$ 上严格递增。\n- 基本不等式与界定：对于任意固定的指数 $e \\ge 2$，满足 $x^e \\le N$ 的最大底数为 $x \\le \\lfloor N^{1/e} \\rfloor$。\n- 基本的奇偶性与因式分解事实：\n  - 若 $u$ 和 $v$ 是整数，则 $u^2 - v^2 = (u - v)(u + v)$。\n  - 模 $4$ 的平方数同余于 $0$ 或 $1$。\n  - 若指数 $a$ 和 $b$ 均为偶数，则 $x^a$ 和 $y^b$ 均为平方数。当 $x \\ge 2, y \\ge 2$ 时，两个平方数之差等于 $1$ 是不可能的，因为形如 $(u-v)(u+v)=1$ 的方程在 $u+v1$ 的情况下没有整数解。\n\n基于这些原理，推导出一个枚举和搜索策略，该策略：\n\n1. 通过循环遍历由不等式 $x \\le \\lfloor N^{1/a} \\rfloor$ 决定的可行指数和底数，生成所有不超过给定边界 $N$ 的完全幂 $x^a$（其中 $x \\ge 2, a \\ge 2$）。\n2. 将生成的完全幂组织到一个数据结构中，该结构能够高效地检测连续整数，特别是形如 $(v+1, v)$ 且两个成员都是完全幂的数对。\n3. 对于每个检测到的连续数对，生成所有满足 $x^a = v+1$ 和 $y^b = v$ 的四元组 $(x,a,y,b)$，同时严格应用奇偶性过滤器，排除 $a$ 和 $b$ 均为偶数的候选者。\n4. 对四元组进行去重，并以确定的、排序后的方式输出。\n\n设计考量：\n\n- 您的枚举必须利用单调性和界定原则来限制循环，以避免不必要的工作。\n- 您的搜索应依赖于连续配对思想：若 $x^a - y^b = 1$ 且二者均至多为 $N$，则存在一个完全幂 $v$ 及其后继数 $v+1$，使得 $y^b = v$ 且 $x^a = v+1$。\n- 同一个完全幂的多种表示形式（例如，$16 = 2^4 = 4^2$）必须保留，因为不同的表示形式可能构成不同的四元组。\n\n输入和输出：\n\n- 没有输入。您的程序应在内部执行一个固定的测试套件。\n- 对于测试套件中的每个 $N$，计算满足上述所有条件的四元组 $(x,a,y,b)$ 列表。将每个四元组表示为一个列表 $[x,a,y,b]$。\n- 您的程序应生成单行输出，其中包含所有测试用例的结果，该结果是一个逗号分隔的列表，并用方括号括起，其中每个测试用例的结果是形如 $[x,a,y,b]$ 的四元组列表。\n\n测试套件：\n\n- 使用以下四个 $N$ 值：\n  - $N = 10$（包含已知连续完全幂对的通用“理想路径”案例），\n  - $N = 8$（边界条件，上限仅包含较小的成员 $y^b$ 而不包含 $x^a$），\n  - $N = 1$（没有满足 $x \\ge 2, a \\ge 2$ 的完全幂的边缘案例），\n  - $N = 100000$（一个更大的边界，用于测试剪枝和枚举的效率与正确性）。\n\n答案规格：\n\n- 对于每个 $N$，答案必须是形如 $[x,a,y,b]$ 的四元组列表，可能为空。\n- 最终输出必须将所有测试用例的结果聚合到单行中，格式严格如下：\n$$\n[\\text{Case}_1,\\text{Case}_2,\\text{Case}_3,\\text{Case}_4],\n$$\n其中每个 $\\text{Case}_i$ 本身是一个类似 $[[x,a,y,b],\\dots]$ 的四元组列表。\n\n本问题不涉及物理单位、角度单位或百分比。", "solution": "我们从完全幂的定义开始：若存在整数 $x \\ge 2$ 和 $a \\ge 2$ 使得 $n = x^a$，则整数 $n$ 是一个完全幂。我们的目标是找出所有满足 $x^a - y^b = 1$ 的四元组 $(x,a,y,b)$，其中 $x \\ge 2, y \\ge 2, a \\ge 2, b \\ge 2$，并受限于边界条件 $x^a \\le N$ 和 $y^b \\le N$。\n\n指导枚举的原则：\n\n1. 对于固定的指数 $e \\ge 2$，函数 $f(x) = x^e$ 在 $x \\ge 2$ 上严格递增。因此，对于给定的边界 $N$，可行的底数 $x$ 满足 $x \\in \\{2,3,\\dots,\\lfloor N^{1/e} \\rfloor\\}$。通过在 $e \\in \\{2,3,\\dots,\\lfloor \\log_2 N \\rfloor\\}$ 范围内循环，并对 $x$ 循环至 $\\lfloor N^{1/e} \\rfloor$，可以完整地枚举出所有不大于 $N$ 的完全幂。\n2. 对于每个枚举出的数对 $(x,e)$，计算 $v = x^e$ 并将表示 $(x,e)$ 存储在一个以 $v$ 为键的关联结构中。该结构是一个从值到表示列表的映射 $M$：\n   $$\n   M[v] = \\{(x,e) : x^e = v,\\ x \\ge 2,\\ e \\ge 2,\\ v \\le N\\}。\n   $$\n   这样可以容纳多种表示形式，如 $16 = 2^4 = 4^2$。\n3. 若 $x^a - y^b = 1$ 且两项均不大于 $N$，则对于某个整数 $v$，必有 $y^b = v$ 和 $x^a = v+1$。因此，解完全对应于连续数对 $(v, v+1)$，其中 $v \\in \\operatorname{keys}(M)$ 且 $v+1 \\in \\operatorname{keys}(M)$。所以，我们扫描 $M$ 的排序键，对于每个满足 $v+1$ 也是键的 $v$，构建所有来自 $M[v+1]$ 的 $(x,a)$ 和来自 $M[v]$ 的 $(y,b)$ 的组合。\n4. 基于奇偶性的剪枝：若指数 $a$ 和 $b$ 均为偶数，则 $x^a$ 和 $y^b$ 均为平方数，设 $x^a = u^2$ 且 $y^b = v^2$。恒等式\n   $$\n   u^2 - v^2 = (u - v)(u + v)\n   $$\n   表明，若 $u^2 - v^2 = 1$ 且 $u \\ge 2, v \\ge 2$，则 $(u-v)(u+v)=1$，这是不可能的，因为 $u+v \\ge 4$。因此，任何指数均为偶数的数对都不可能满足 $x^a - y^b = 1$。预先应用此过滤器可以移除此类数对，从而在不牺牲正确性的前提下提高效率。\n5. 去重与排序：由于允许同一个完全幂有多种表示，可能会产生不同的组合。将四元组 $(x,a,y,b)$ 存储在一个集合中以确保唯一性，然后生成一个确定性排序的列表（例如，按字典序排序）。\n\n正确性论证：\n\n- 完备性：对于每个可行的指数 $e$ 和底数 $x$，所有完全幂 $x^e \\le N$ 都被枚举，因为底数范围恰好是 $2 \\le x \\le \\lfloor N^{1/e} \\rfloor$，指数范围是 $2 \\le e \\le \\lfloor \\log_2 N \\rfloor$，这已足够，因为任何更高的指数在 $x \\ge 2$ 的情况下都会使 $x^e$ 超过 $N$。\n- 连续扫描的必要性：若 $x^a - y^b = 1$ 且 $x^a \\le N, y^b \\le N$，则对于某个整数 $v$，必有 $y^b = v$ 和 $x^a = v+1$，因此 $v$ 和 $v+1$ 都必须是枚举集合内的完全幂。因此，遍历映射键中的 $(v, v+1)$ 数对可以捕获所有可能性。\n- 剪枝有效性：排除偶-偶指数对的奇偶性规则源于因式分解，是严格有效的。它不会丢弃任何有效解，因此保持了完备性。\n\n复杂度分析：\n\n令 $E = \\lfloor \\log_2 N \\rfloor$。对于每个 $e \\in \\{2,\\dots,E\\}$，底数的数量为 $\\lfloor N^{1/e} \\rfloor$。枚举的总次数为\n$$\n\\sum_{e=2}^{E} \\lfloor N^{1/e} \\rfloor.\n$$\n这个和主要由 $e=2$ 的项决定，约等于 $\\sqrt{N}$，并随着 $e$ 的增加而迅速减小。因此，枚举的运行时间大致为 $O(\\sqrt{N})$，对于给定的测试套件（包括 $N=100000$）是高效的。\n\n测试套件行为：\n\n- 对于 $N = 10$，枚举包含 $8 = 2^3$ 和 $9 = 3^2$，经过奇偶性过滤和邻接检测后，得到四元组 $[3,2,2,3]$。\n- 对于 $N = 8$，包含 $8$ 但不包含 $9$，因此不存在连续的完全幂；结果为空列表。\n- 对于 $N = 1$，没有满足 $x \\ge 2$ 和 $a \\ge 2$ 的完全幂 $x^a$ 满足 $x^a \\le 1$；结果为空列表。\n- 对于 $N = 100000$，尽管边界很大，唯一连续的完全幂仍然是 $8$ 和 $9$，产生相同的四元组 $[3,2,2,3]$（其他地方的多种表示形式不会产生连续数对）。如果在邻接检查中出现偶-偶指数组合，奇偶性过滤器会将其排除。\n\n输出格式：\n\n程序将构建并打印单行，格式为\n$$\n[\\text{Case}_1,\\text{Case}_2,\\text{Case}_3,\\text{Case}_4],\n$$\n其中每个 $\\text{Case}_i$ 是为相应 $N$ 找到的四元组 $[x,a,y,b]$ 的列表。对于指定的测试套件，这将是一个包含四个列表的列表。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\nfrom typing import Dict, List, Tuple\n\ndef enumerate_perfect_powers(N: int) - Dict[int, List[Tuple[int, int]]]:\n    \"\"\"\n    Enumerate all perfect powers x^e = N with x >= 2 and e >= 2.\n    Returns a dictionary mapping value - list of (base, exponent) representations.\n    \"\"\"\n    value_map: Dict[int, List[Tuple[int, int]]] = {}\n    if N  4:\n        return value_map  # Small N has no perfect powers with base=2 and exponent=2 (2^2=4 is minimal)\n\n    # Max exponent is floor(log2(N)), since 2^e = N = e = log2(N)\n    max_exp = int(math.log2(N))\n    for e in range(2, max_exp + 1):\n        # Compute the maximal base such that base**e = N using floating root, then correct by adjustment\n        # Use float power as initial estimate\n        max_base = int(N ** (1.0 / e))\n        # Adjust upwards if rounding down too much\n        while (max_base + 1) ** e = N:\n            max_base += 1\n        # Adjust downwards if rounding up too much\n        while max_base >= 2 and (max_base) ** e > N:\n            max_base -= 1\n\n        for x in range(2, max_base + 1):\n            val = x ** e\n            # Store representation (x, e)\n            value_map.setdefault(val, []).append((x, e))\n    return value_map\n\ndef find_consecutive_power_quads(value_map: Dict[int, List[Tuple[int, int]]]) - List[Tuple[int, int, int, int]]:\n    \"\"\"\n    Given a map of perfect power values to representations, find all quadruples (x,a,y,b)\n    such that x^a - y^b = 1. Apply parity filter: skip cases where both a and b are even.\n    Return a sorted list of unique quadruples.\n    \"\"\"\n    quads_set = set()\n    keys = sorted(value_map.keys())\n    keys_set = set(keys)\n\n    for v in keys:\n        u = v + 1\n        if u in keys_set:\n            reps_u = value_map[u]  # (x, a) such that x^a = u\n            reps_v = value_map[v]  # (y, b) such that y^b = v\n            for (x, a) in reps_u:\n                for (y, b) in reps_v:\n                    # Parity filter: if both exponents are even, difference of squares cannot be 1\n                    if (a % 2 == 0) and (b % 2 == 0):\n                        continue\n                    quads_set.add((x, a, y, b))\n\n    # Sort lexicographically for deterministic output\n    quads = sorted(list(quads_set))\n    return quads\n\ndef solve():\n    # Define the test cases from the problem statement: values of N\n    test_cases = [10, 8, 1, 100000]\n\n    results: List[List[Tuple[int, int, int, int]]] = []\n    for N in test_cases:\n        value_map = enumerate_perfect_powers(N)\n        quads = find_consecutive_power_quads(value_map)\n        results.append(quads)\n\n    # Format output exactly: a single line with a comma-separated list enclosed in square brackets.\n    # Each test case's result is a list of quadruples, each quadruple formatted as [x,a,y,b].\n    def format_quad(quad: Tuple[int, int, int, int]) - str:\n        x, a, y, b = quad\n        return f\"[{x},{a},{y},{b}]\"\n\n    def format_case(case: List[Tuple[int, int, int, int]]) - str:\n        return f\"[{','.join(format_quad(q) for q in case)}]\"\n\n    output = f\"[{','.join(format_case(case) for case in results)}]\"\n    print(output)\n\nsolve()\n```", "id": "3082993"}, {"introduction": "用于求解卡塔兰方程的原理可以推广到更广泛的丢番图问题。最后一个练习 [@problem_id:3082995] 介绍了皮莱方程 $m^a - n^b = k$，它是对卡塔兰方程中整数差 $k=1$ 情况的推广。通过编程寻找其解，你将学习如何调整计算策略来探索相关的数学问题，从而体会到这些技术的强大功能和灵活性。", "problem": "设 $m$、$n$、$a$、$b$ 和 $k$ 为整数，满足 $m \\ge 2$、$n \\ge 2$、$a \\ge 2$、$b \\ge 2$ 和 $k \\ge 1$。Pillai 方程是丢番图关系式 $m^a - n^b = k$。完全幂是指形如 $x^y$ 的任意整数，其中整数 $x \\ge 2$ 且 $y \\ge 2$。Catalan 猜想（已由 Mihăilescu 定理证明）指出，唯一相差为 $1$ 的连续完全幂是 $3^2$ 和 $2^3$。在本问题中，您将通过在有限边界内枚举解并按测试用例进行汇总，来探索 Pillai 方程的计算方面及其与 Catalan 猜想的关系。\n\n允许使用的基本定义和事实：\n- 整数幂运算：对于整数 $u \\ge 2$ 和 $v \\ge 2$，完全幂 $u^v$ 通过在整数环中进行重复乘法来计算。\n- 不等式和正性的基本性质：$m^a - n^b = k$ 且 $k \\ge 1$ 意味着 $m^a  n^b$。\n\n您的任务是实现一个程序，对于每个给定的测试用例，枚举所有满足 $m^a - n^b = k$ 的整数四元组 $[m,a,n,b]$，其中 $2 \\le m \\le M$、$2 \\le n \\le N$、$2 \\le a \\le A_{\\max}$、$2 \\le b \\le B_{\\max}$ 且 $k \\ge 1$。枚举必须在给定边界内是详尽的。每个解必须表示为列表 $[m,a,n,b]$。对于每个测试用例，将所有解收集到一个列表中，然后将所有测试用例的列表汇总到一个外部列表中。\n\n测试套件（每个测试用例是一个元组 $(k,M,N,A_{\\max},B_{\\max})$）：\n- 用例 $1$：$(1,20,20,10,10)$。\n- 用例 $2$：$(2,200,200,10,10)$。\n- 用例 $3$：$(5,50,50,10,10)$。\n- 用例 $4$：$(7,100,100,10,10)$。\n- 用例 $5$：$(15,100,100,10,10)$。\n- 用例 $6$：$(6,100,100,10,10)$。\n- 用例 $7$：$(32,100,100,10,10)$。\n- 用例 $8$：$(17,100,100,10,10)$。\n- 用例 $9$：$(65,100,100,10,10)$。\n\n最终输出规范：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。此外层列表的每个元素对应一个测试用例，其本身是一个由 $[m,a,n,b]$ 解组成的列表，并为了可复现性按 $(m,a,n,b)$ 的字典序排序。例如，输出的形式应为 $[[\\dots],[\\dots],\\dots]$，其中每个内层列表按上文列出的顺序包含相应测试用例的解。", "solution": "该问题要求在一个有界域内系统地搜索皮莱方程 $m^a - n^b = k$ 的所有整数解。\n\n**算法设计**\n\n对所有四个变量 $(m, a, n, b)$ 进行直接的暴力枚举，其计算复杂度约为 $O(M \\cdot A_{\\max} \\cdot N \\cdot B_{\\max})$，对于较大的边界来说效率低下。一个更优化的策略是将方程重排为 $m^a - k = n^b$，这有效地将变量分离。\n\n该改进算法包含两个主要阶段：\n\n1.  **预计算阶段**：我们首先生成并存储所有在给定边界内的完全幂 $n^b$。我们创建一个哈希表（在Python中为字典），其中键是完全幂的值 $v = n^b$，值是产生该值的所有表示形式 $[n, b]$ 的列表。这允许对一个值（如 $64$）有多种表示（如 $[2, 6], [4, 3], [8, 2]$）。遍历所有 $n \\in [2, N]$ 和 $b \\in [2, B_{\\max}]$ 来构建这个哈希表。为了确保最终输出的确定性，每个值的表示列表都应按底数 $n$ 排序。\n\n2.  **搜索与查找阶段**：在预计算了所有可能的 $n^b$ 值之后，我们遍历所有可能的 $(m, a)$ 对，其中 $m \\in [2, M]$ 且 $a \\in [2, A_{\\max}]$。对于每一对，我们计算目标值 $T = m^a - k$。如果 $T > 0$，我们就在预计算的哈希表中查找 $T$。\n\n如果 $T$ 存在于哈希表中，则意味着我们找到了一个或多个解。对于存储在 $T$ 键下的每个 $[n, b]$ 对，我们都构成一个解四元组 $[m, a, n, b]$。\n\n**正确性与效率**\n\n这种方法是完备的，因为它系统地检查了所有可能的 $(m, a)$ 对，并将其与所有可能的 $n^b$ 值进行匹配。由于我们在外层循环中按递增顺序遍历 $m$ 和 $a$，并且预计算的 $[n, b]$ 列表也已排序，因此解会以自然的字典序生成，无需在最后进行昂贵的全局排序。\n\n该算法的计算复杂度大致为 $O(N \\cdot B_{\\max} + M \\cdot A_{\\max})$，这比暴力搜索要高效得多，并且对于问题中给出的约束是可行的。Python的原生任意精度整数可以无缝处理计算中可能出现的大数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport scipy\n\ndef solve():\n    \"\"\"\n    Main function to solve all test cases and print the final result.\n    \"\"\"\n    test_cases = [\n        # (k, M, N, A_max, B_max)\n        (1, 20, 20, 10, 10),\n        (2, 200, 200, 10, 10),\n        (5, 50, 50, 10, 10),\n        (7, 100, 100, 10, 10),\n        (15, 100, 100, 10, 10),\n        (6, 100, 100, 10, 10),\n        (32, 100, 100, 10, 10),\n        (17, 100, 100, 10, 10),\n        (65, 100, 100, 10, 10),\n    ]\n\n    all_results = []\n    for case in test_cases:\n        k, M, N, A_max, B_max = case\n        result_for_case = solve_one_case(k, M, N, A_max, B_max)\n        all_results.append(result_for_case)\n\n    # The output format requires a compact string representation of the list of lists.\n    # Python's str() function includes spaces, which we remove.\n    # e.g., str([[1, 2]]) - '[[1, 2]]' - '[[1,2]]'\n    final_output_str = str(all_results).replace(\" \", \"\")\n    print(final_output_str)\n\ndef solve_one_case(k, M, N, A_max, B_max):\n    \"\"\"\n    Enumerates solutions for a single test case using a pre-computation approach.\n    \n    The method rearranges m^a - n^b = k to m^a - k = n^b. It pre-computes\n    all possible n^b values and stores them in a hash map for efficient lookup.\n    \n    Args:\n        k (int): The constant difference in Pillai's equation.\n        M (int): The upper bound for the base m.\n        N (int): The upper bound for the base n.\n        A_max (int): The upper bound for the exponent a.\n        B_max (int): The upper bound for the exponent b.\n        \n    Returns:\n        list: A list of all solution quadruples [m, a, n, b], sorted lexicographically.\n    \"\"\"\n    \n    # 1. Pre-computation phase: Store all n^b powers in a dictionary.\n    # The keys are the perfect power values, and the values are lists of [n, b] pairs.\n    nb_powers = {}\n    for n in range(2, N + 1):\n        # Using pow(n, b) is clean and efficient in Python for large integers.\n        # An alternative is to multiply iteratively, which can avoid repeated large calculations.\n        # For the given constraints, pow is fine.\n        for b in range(2, B_max + 1):\n            try:\n                val = pow(n, b)\n            except OverflowError:\n                # If a power exceeds system limits (unlikely in Python's arbitrary precision),\n                # we stop for this base n as further powers will also be too large.\n                break\n            \n            if val not in nb_powers:\n                nb_powers[val] = []\n            nb_powers[val].append([n, b])\n\n    # To ensure lexicographical output, sort the lists of [n, b] pairs by n.\n    # This matters when a single value has multiple representations (e.g., 64 = 8^2 = 4^3 = 2^6).\n    # The sorted list will be [[2, 6], [4, 3], [8, 2]].\n    for val in nb_powers:\n        nb_powers[val].sort()\n        \n    # 2. Search and Lookup phase\n    solutions = []\n    for m in range(2, M + 1):\n        for a in range(2, A_max + 1):\n            # Calculate the target value m^a - k\n            try:\n                val_ma = pow(m, a)\n            except OverflowError:\n                break\n            \n            target = val_ma - k\n            \n            # Perform a fast lookup in the pre-computed dictionary.\n            if target in nb_powers:\n                # If the target is a known perfect power, we have found solutions.\n                for n_b_pair in nb_powers[target]:\n                    solutions.append([m, a] + n_b_pair)\n\n    # The solutions are naturally generated in lexicographical order due to:\n    # a) The loops for m and a being in increasing order.\n    # b) The lists in nb_powers being sorted by n.\n    # No final sort of `solutions` is needed.\n    return solutions\n\nsolve()\n```", "id": "3082995"}]}