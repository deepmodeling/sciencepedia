{"hands_on_practices": [{"introduction": "在深入探讨关于代数数的深刻定理之前，我们需要一种衡量它们“复杂度”的方法。绝对对数Weil高度正是为此而设的度量。本练习提供了一个具体的机会，让你直接根据其定义计算一些简单代数数的高度，从而巩固你对丢番图逼近中这一基本工具的理解。[@problem_id:3093643]", "problem": "设 $K=\\mathbb{Q}(\\sqrt{2})$，$M_{K}$ 表示 $K$ 的所有位（绝对值的等价类）的集合，包括阿基米德位和非阿基米德位，每个位都赋有标准赋范以使乘积公式成立。代数数上的绝对对数 Weil 高度 $h$ 是丢番图逼近中使用的基本复杂度度量，它出现在 Roth 定理和 Baker 定理中。从其通过标准绝对值和乘积公式的定义出发，通过对 $K$ 的所有位求和，显式计算 $h(2)$、$h(3)$ 和 $h(\\sqrt{2})$ 的值。然后，通过将 $2$ 和 $3$ 视为 $\\mathbb{Q}$ 的元素、将 $\\sqrt{2}$ 视为其极小多项式的根来验证这些值与计算结果一致，从而证明高度与数域的选择无关，并且在不同嵌入下是一致的。请以精确解析表达式的形式提供最终答案。不需要四舍五入。", "solution": "这个问题是有效的，因为它在代数数论中有科学依据，问题提出得很好，并且是客观的。它基于既定的数学定义提供了一个明确的任务。\n\n属于数域 $K$ 的代数数 $\\alpha$ 的绝对对数 Weil 高度 $h(\\alpha)$ 是通过 $K$ 的位来定义的。设 $[K:\\mathbb{Q}] = d$ 是域扩张的次数。设 $M_K$ 是 $K$ 的位的集合。对于每个位 $v \\in M_K$，我们关联一个标准绝对值 $\\|\\cdot\\|_v$ 和一个局部次数 $d_v$。位的集合由阿基米德位（无限位）和非阿基米德位（有限位）组成。\n\n标准赋范如下：\n- 对于对应于实嵌入 $\\sigma_i: K \\hookrightarrow \\mathbb{R}$ 的阿基米德位 $v$，我们有 $\\|\\alpha\\|_v = |\\sigma_i(\\alpha)|$，局部次数为 $d_v = [K_v:\\mathbb{Q}_\\infty] = [\\mathbb{R}:\\mathbb{R}] = 1$。\n- 对于对应于一对复共轭嵌入 $\\sigma_i, \\bar{\\sigma}_i: K \\hookrightarrow \\mathbb{C}$ 的阿基米德位 $v$，我们有 $\\|\\alpha\\|_v = |\\sigma_i(\\alpha)|$，局部次数为 $d_v = [K_v:\\mathbb{Q}_\\infty] = [\\mathbb{C}:\\mathbb{R}] = 2$。\n- 对于对应于有理素数 $p$ 上的整数环 $\\mathcal{O}_K$ 的素理想 $\\mathfrak{p}$ 的非阿基米德位 $v$，我们有 $\\|\\alpha\\|_v = (N(\\mathfrak{p}))^{-\\text{ord}_\\mathfrak{p}(\\alpha)}$，其中 $N(\\mathfrak{p})$ 是理想 $\\mathfrak{p}$ 的范数，$\\text{ord}_\\mathfrak{p}(\\alpha)$ 是分数理想 $(\\alpha)$ 的素理想分解中 $\\mathfrak{p}$ 的指数。局部次数为 $d_v = [K_v: \\mathbb{Q}_p] = e_\\mathfrak{p}f_\\mathfrak{p}$，其中 $e_\\mathfrak{p}$ 是分歧指数，$f_\\mathfrak{p}$ 是 $\\mathfrak{p}$ 在 $p$ 上的剩余域次数。\n\n于是，绝对对数 Weil 高度由以下公式给出：\n$$h(\\alpha) = \\frac{1}{d} \\sum_{v \\in M_K} d_v \\log\\max(1, \\|\\alpha\\|_v)$$\n此定义的一个关键属性是 $h(\\alpha)$ 的值与包含 $\\alpha$ 的数域 $K$ 的选择无关。我们将证明这一点。\n\n首先，我们分析指定的数域 $K = \\mathbb{Q}(\\sqrt{2})$。\n扩张次数为 $d = [K:\\mathbb{Q}] = 2$。整数环为 $\\mathcal{O}_K = \\mathbb{Z}[\\sqrt{2}]$。\n$K$ 的位是：\n1.  **阿基米德位**：有两个实嵌入，没有复嵌入。\n    - $\\sigma_1: a+b\\sqrt{2} \\mapsto a+b\\sqrt{2}$。这定义了一个局部次数为 $d_{v_{\\infty,1}} = 1$ 的位 $v_{\\infty,1}$。\n    - $\\sigma_2: a+b\\sqrt{2} \\mapsto a-b\\sqrt{2}$。这定义了一个局部次数为 $d_{v_{\\infty,2}} = 1$ 的位 $v_{\\infty,2}$。\n    $\\mathbb{Q}$ 的无限位上的局部次数之和为 $1+1=2$，等于 $[K:\\mathbb{Q}]$。\n2.  **非阿基米德位**：这些对应于 $\\mathcal{O}_K$ 的素理想。我们必须计算的数 $2$、$3$ 和 $\\sqrt{2}$ 都是代数整数。对于任何代数整数 $\\alpha$ 和任何对应于素理想 $\\mathfrak{p}$ 的非阿基米德位 $v$，我们有 $\\text{ord}_\\mathfrak{p}(\\alpha) \\ge 0$。这意味着 $\\|\\alpha\\|_v = (N(\\mathfrak{p}))^{-\\text{ord}_\\mathfrak{p}(\\alpha)} \\le 1$。因此，$\\log\\max(1, \\|\\alpha\\|_v) = \\log(1) = 0$。因此，对于代数整数，只有阿基米德位对高度计算有贡献。为了完整性，我们仍然会展示分析过程。\n\n我们现在计算给定数的高度。\n\n**1. 计算 $h(2)$**\n数 $\\alpha = 2$ 在 $K$ 中。\n- **阿基米德贡献**：\n    - 对于 $v_{\\infty,1}$：$\\|\\alpha\\|_{v_{\\infty,1}} = |\\sigma_1(2)| = |2| = 2$。该项为 $d_{v_{\\infty,1}} \\log\\max(1, 2) = 1 \\cdot \\ln(2) = \\ln(2)$。\n    - 对于 $v_{\\infty,2}$：$\\|\\alpha\\|_{v_{\\infty,2}} = |\\sigma_2(2)| = |2| = 2$。该项为 $d_{v_{\\infty,2}} \\log\\max(1, 2) = 1 \\cdot \\ln(2) = \\ln(2)$。\n    - 阿基米德总贡献为 $\\ln(2) + \\ln(2) = 2\\ln(2)$。\n- **非阿基米德贡献**：\n    我们只需要考虑位于素数 $p=2$ 之上的位。素数 $2$ 在 $\\mathcal{O}_K$ 中分歧：$(2) = (\\sqrt{2})^2$。设 $\\mathfrak{p}_2 = (\\sqrt{2})$。则 $N(\\mathfrak{p}_2)=2$。$2$ 在 $\\mathfrak{p}_2$ 处的赋值为 $\\text{ord}_{\\mathfrak{p}_2}(2) = 2$。相应的绝对值为 $\\|2\\|_{\\mathfrak{p}_2} = (N(\\mathfrak{p}_2))^{-\\text{ord}_{\\mathfrak{p}_2}(2)} = 2^{-2} = \\frac{1}{4}$。由于 $\\|2\\|_{\\mathfrak{p}_2}  1$，所以 $\\log\\max(1, \\|2\\|_{\\mathfrak{p}_2}) = 0$ 这一项为 $0$。对于所有其他有限位 $v$，$\\|2\\|_v = 1$，所以它们的贡献也为 $0$。非阿基米德总贡献为 $0$。\n- **总高度**：\n    $$h(2) = \\frac{1}{2} (2\\ln(2) + 0) = \\ln(2)$$\n\n**2. 计算 $h(3)$**\n数 $\\alpha = 3$ 在 $K$ 中。\n- **阿基米德贡献**：\n    - 对于 $v_{\\infty,1}$：$\\|\\alpha\\|_{v_{\\infty,1}} = |\\sigma_1(3)| = |3| = 3$。该项为 $1 \\cdot \\ln(3) = \\ln(3)$。\n    - 对于 $v_{\\infty,2}$：$\\|\\alpha\\|_{v_{\\infty,2}} = |\\sigma_2(3)| = |3| = 3$。该项为 $1 \\cdot \\ln(3) = \\ln(3)$。\n    - 阿基米德总贡献为 $\\ln(3) + \\ln(3) = 2\\ln(3)$。\n- **非阿基米德贡献**：\n    我们考虑位于 $p=3$ 之上的位。在 $\\mathbb{Q}(\\sqrt{2})$ 中，素数 $3$ 是惰性的，因为勒让德符号 $(\\frac{2}{3}) = -1$。理想 $(3)$ 在 $\\mathcal{O}_K$ 中是素理想，我们称之为 $\\mathfrak{p}_3$。$N(\\mathfrak{p}_3) = 3^2 = 9$。我们有 $\\text{ord}_{\\mathfrak{p}_3}(3) = 1$。绝对值为 $\\|3\\|_{\\mathfrak{p}_3} = 9^{-1} = \\frac{1}{9}$。由于该值小于 $1$，其对高度的贡献为 $0$。所有其他有限位贡献为 $0$。\n- **总高度**：\n    $$h(3) = \\frac{1}{2} (2\\ln(3) + 0) = \\ln(3)$$\n\n**3. 计算 $h(\\sqrt{2})$**\n数 $\\alpha = \\sqrt{2}$ 在 $K$ 中。\n- **阿基米德贡献**：\n    - 对于 $v_{\\infty,1}$：$\\|\\alpha\\|_{v_{\\infty,1}} = |\\sigma_1(\\sqrt{2})| = |\\sqrt{2}| = \\sqrt{2}$。该项为 $1 \\cdot \\ln(\\sqrt{2}) = \\frac{1}{2}\\ln(2)$。\n    - 对于 $v_{\\infty,2}$：$\\|\\alpha\\|_{v_{\\infty,2}} = |\\sigma_2(\\sqrt{2})| = |-\\sqrt{2}| = \\sqrt{2}$。该项为 $1 \\cdot \\ln(\\sqrt{2}) = \\frac{1}{2}\\ln(2)$。\n    - 阿基米德总贡献为 $\\frac{1}{2}\\ln(2) + \\frac{1}{2}\\ln(2) = \\ln(2)$。\n- **非阿基米德贡献**：\n    唯一非零的赋值是在 $p=2$ 之上的位，即 $\\mathfrak{p}_2 = (\\sqrt{2})$。我们有 $\\text{ord}_{\\mathfrak{p}_2}(\\sqrt{2}) = 1$。绝对值为 $\\|\\sqrt{2}\\|_{\\mathfrak{p}_2} = (N(\\mathfrak{p}_2))^{-1} = 2^{-1} = \\frac{1}{2}$。由于该值小于 $1$，其贡献为 $0$。\n- **总高度**：\n    $$h(\\sqrt{2}) = \\frac{1}{2} (\\ln(2) + 0) = \\frac{1}{2}\\ln(2)$$\n\n**一致性验证**\n我们使用通过极小多项式的高度替代定义来验证这些结果。对于一个代数数 $\\alpha$，其极小多项式为 $P(x) = a_d x^d + \\dots + a_0 \\in \\mathbb{Z}[x]$（其中 $\\text{gcd}(a_0, \\dots, a_d)=1$ 且 $a_d>0$），其高度由下式给出\n$$h(\\alpha) = \\frac{1}{d} \\log M(P)$$\n其中 $M(P)$ 是 $P$ 的马勒测度，定义为 $M(P) = |a_d| \\prod_{i=1}^d \\max(1, |\\alpha_i|)$，而 $\\alpha_i$ 是 $P(x)$ 的根。\n\n- 对于 $\\alpha = 2$：该数为有理数，因此我们可以在 $K=\\mathbb{Q}$ 中看待它。在 $\\mathbb{Z}$ 上的极小多项式是 $P(x) = x-2$。这里 $d=1$，$a_1=1$，根是 $\\alpha_1=2$。\n$M(P) = |1| \\cdot \\max(1, |2|) = 2$。\n$h(2) = \\frac{1}{1}\\ln(2) = \\ln(2)$。这与我们的结果相符。\n\n- 对于 $\\alpha = 3$：在 $\\mathbb{Z}$ 上的极小多项式是 $P(x) = x-3$。这里 $d=1$，$a_1=1$，根是 $\\alpha_1=3$。\n$M(P) = |1| \\cdot \\max(1, |3|) = 3$。\n$h(3) = \\frac{1}{1}\\ln(3) = \\ln(3)$。这也相符。\n\n- 对于 $\\alpha = \\sqrt{2}$：在 $\\mathbb{Z}$ 上的极小多项式是 $P(x) = x^2-2$。这里 $d=2$，$a_2=1$。根是 $\\alpha_1 = \\sqrt{2}$ 和 $\\alpha_2 = -\\sqrt{2}$。\n$M(P) = |1| \\cdot \\max(1, |\\sqrt{2}|) \\cdot \\max(1, |-\\sqrt{2}|) = 1 \\cdot \\sqrt{2} \\cdot \\sqrt{2} = 2$。\n$h(\\sqrt{2}) = \\frac{1}{2}\\ln(M(P)) = \\frac{1}{2}\\ln(2)$。这也相符。\n\n计算证实了绝对对数 Weil 高度是代数数的内在属性，与计算它时所处的数域无关。其值为 $h(2) = \\ln(2)$，$h(3)=\\ln(3)$ 和 $h(\\sqrt{2}) = \\frac{1}{2}\\ln(2)$。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\ln(2)  \\ln(3)  \\frac{1}{2}\\ln(2)\n\\end{pmatrix}\n}\n$$", "id": "3093643"}, {"introduction": "Roth定理和Baker定理是超越数论的两大支柱，但它们解决的问题类型不同。Roth定理提供了关于代数数能被有理数多好地逼近的界限，而Baker定理则给出了代数数对数的线性组合的下界。本练习将通过具体的例子，让你辨析哪个定理适用于何种情境，从而磨练你区分它们各自应用范围的能力。[@problem_id:3093660]", "problem": "设 $K$ 为实数域，代数数是某个非零整系数多项式的根的复数，而超越数是不满足任何此类多项式的复数。实数 $\\alpha$ 的一个有理逼近是一个表达式 $\\left| \\alpha - \\frac{p}{q} \\right|$，其中 $p$ 和 $q \\ge 1$ 是整数。代数数对数的线性形式是形如 $\\Lambda = b_{1} \\log \\alpha_{1} + \\cdots + b_{n} \\log \\alpha_{n}$ 的表达式，其中 $b_{i}$ 是整数，$\\alpha_{i} \\in K$ 是满足 $\\alpha_{i} \\ne 0,1$ 的代数数。超越数理论中两个深刻结果的定性范围如下：一个 (Roth) 关注代数无理数能被有理数逼近的程度；另一个 (Baker) 关注非零的代数数对数的线性形式及其相对于整数系数的大小。\n\n选择唯一正确提供以下内容的选项：\n- 一个 Roth 定理适用但 Baker 定理不直接适用的明确实例，以及\n- 另一个 Baker 定理适用但 Roth 定理不适用的明确实例。\n\nA. 第一个实例：对于整数 $p,q$ 且 $q \\ge 1$，当 $q$ 增大时，考虑 $\\left| \\sqrt{2} - \\frac{p}{q} \\right|$。Roth 定理适用，因为 $\\sqrt{2}$ 是一个代数无理数，而 Baker 定理不直接适用，因为没有出现代数数的对数。第二个实例：对于整数 $x,y$，考虑非零量 $\\left| x \\log 2 - y \\log 3 \\right|$。Baker 定理适用，因为这是一个代数数对数的线性形式，而 Roth 定理不适用，因为这不是对一个代数数的有理逼近。\n\nB. 第一个实例：对于整数 $p,q$ 且 $q \\ge 1$，考虑 $\\left| \\log 2 - \\frac{p}{q} \\right|$。Roth 定理适用，因为 $\\log 2$ 是无理数，而 Baker 定理不适用。第二个实例：对于整数 $x,y$，考虑 $\\left| x \\log 2 - y \\log 4 \\right|$。Baker 定理保证了对于所有非零整数对 $(x,y)$ 存在一个统一的正下界。\n\nC. 第一个实例：对于整数 $p,q$ 且 $q \\ge 1$，考虑 $\\left| \\sqrt{2} - \\frac{p}{q} \\right|$。Roth 定理和 Baker 定理都直接适用于此，因为 $\\sqrt{2} = e^{\\log \\sqrt{2}}$。第二个实例：对于整数 $x,y$，考虑 $\\left| x \\log 2 - y \\log 3 \\right|$。Roth 定理适用，因为 $\\frac{\\log 2}{\\log 3}$ 可以被视为一个代数无理数。\n\nD. 第一个实例：对于整数 $p,q$ 且 $q \\ge 1$，考虑 $\\left| \\sqrt{2} - \\frac{p}{q} \\right|$。如果没有关于连分数的额外假设，Roth 定理不适用。第二个实例：对于整数 $x,y$，考虑 $\\left| x \\log 2 - y \\log e \\right|$。Baker 定理适用，因为 $e$ 是一个众所周知的常数并且存在对数。", "solution": "用户要求评估一个关于超越数理论中 Roth 定理和 Baker 定理适用范围的问题。\n\n### 问题验证\n\n**步骤 1：提取已知条件**\n\n-   域 $K$ 是实数域 $\\mathbb{R}$。\n-   代数数是某个非零整系数多项式的根的复数。\n-   超越数是不是代数数的复数。\n-   实数 $\\alpha$ 的一个有理逼近是形如 $\\left| \\alpha - \\frac{p}{q} \\right|$ 的表达式，其中 $p$ 和 $q \\ge 1$ 是整数。\n-   代数数对数的线性形式是形如 $\\Lambda = b_{1} \\log \\alpha_{1} + \\cdots + b_{n} \\log \\alpha_{n}$ 的表达式，其中 $b_{i}$ 是整数，$\\alpha_{i} \\in K$ 是满足 $\\alpha_{i} \\ne 0,1$ 的代数数。\n-   Roth 定理的定性范围是代数无理数能被有理数逼近的程度。\n-   Baker 定理的定性范围是为非零的代数数对数的线性形式的绝对值提供一个下界。\n-   任务是选择一个选项，该选项提供一个 Roth 定理适用但 Baker 定理不直接适用的实例，以及另一个 Baker 定理适用但 Roth 定理不适用的实例。\n\n**步骤 2：使用提取的已知条件进行验证**\n\n-   **科学性：** 代数数和超越数的定义是数论中的标准定义。对 Roth 定理和 Baker 定理的定性描述是准确的。Roth 定理 (1955) 指出，对于任何代数无理数 $\\alpha$ 和任何 $\\epsilon > 0$，不等式 $\\left| \\alpha - \\frac{p}{q} \\right|  \\frac{1}{q^{2+\\epsilon}}$ 在整数 $p$ 和 $q$ ($q \\ge 1$) 中只有有限多个解。这确实关系到对代数无理数的有理逼近的质量。Baker 理论 (1960年代) 为非零的代数数对数的线性形式提供了明确的正下界，即，如果 $\\Lambda \\ne 0$，那么 $|\\Lambda| > C$，其中 $C$ 是一个可计算的常数，依赖于 $\\alpha_i$ 和 $|b_i|$ 的最大值。该问题建立在正确的数学原理之上。\n-   **良构性：** 这个问题是一个选择题，要求对两个主要定理的适用范围有概念性的理解。它的结构保证了只有一个正确答案。\n-   **客观性：** 问题陈述没有主观性语言，并使用了标准的数学术语。\n\n**步骤 3：结论与行动**\n\n问题陈述是有效的。它在科学上是合理的，是良构的，并且是客观的。我将继续进行推导和选项评估。\n\n### 解题推导\n\n核心任务是区分 Roth 定理和 Baker 定理的应用领域。\n-   **Roth 定理**：适用于形如 $\\left| \\alpha - \\frac{p}{q} \\right|$ 的表达式，其中 $\\alpha$ 是一个**代数无理数**。\n-   **Baker 定理**：适用于形如 $|\\Lambda| = |b_1 \\log \\alpha_1 + \\cdots + b_n \\log \\alpha_n|$ 的表达式，其中 $b_i$ 是整数，$\\alpha_i$ 是**代数数**。\n\n我们需要找到一个包含两个实例的选项：\n1.  一个形如 $\\left| \\alpha - \\frac{p}{q} \\right|$ 的表达式，其中 $\\alpha$ 是一个代数无理数，但它不是一个对数的线性形式。\n2.  一个形如上面定义的 $|\\Lambda|$ 的表达式，它与代数数的有理逼近无关。\n\n### 逐项分析\n\n**A. 第一个实例：对于整数 $p,q$ 且 $q \\ge 1$，当 $q$ 增大时，考虑 $\\left| \\sqrt{2} - \\frac{p}{q} \\right|$。Roth 定理适用，因为 $\\sqrt{2}$ 是一个代数无理数，而 Baker 定理不直接适用，因为没有出现代数数的对数。第二个实例：对于整数 $x,y$，考虑非零量 $\\left| x \\log 2 - y \\log 3 \\right|$。Baker 定理适用，因为这是一个代数数对数的线性形式，而 Roth 定理不适用，因为这不是对一个代数数的有理逼近。**\n\n-   **第一个实例分析**：表达式为 $\\left| \\sqrt{2} - \\frac{p}{q} \\right|$。被逼近的数是 $\\alpha = \\sqrt{2}$。由于 $\\sqrt{2}$ 是多项式 $x^2 - 2 = 0$ 的根，所以它是一个代数数。它也是无理数。因此，$\\sqrt{2}$ 是一个代数无理数。Roth 定理直接关系到不等式 $\\left| \\sqrt{2} - \\frac{p}{q} \\right|  q^{-(2+\\epsilon)}$，并在此适用。表达式 $\\left| \\sqrt{2} - \\frac{p}{q} \\right|$ 不是代数数对数的线性形式，因此 Baker 定理不直接适用。这部分选项是正确的。\n\n-   **第二个实例分析**：表达式是 $\\left| x \\log 2 - y \\log 3 \\right|$，其中 $x,y$ 是整数。这可以写成 $\\Lambda = x \\log 2 + (-y) \\log 3$。这是一个整数系数 $b_1=x, b_2=-y$ 的对数线性形式。涉及的数是 $\\alpha_1=2$ 和 $\\alpha_2=3$。$2$（$z-2=0$ 的根）和 $3$（$z-3=0$ 的根）都是代数数。作为 Baker 定理的一个推论，$\\log 2$ 和 $\\log 3$ 在有理数域 $\\mathbb{Q}$ 上是线性无关的，所以对于任何非零整数对 $(x,y)$，该形式都是非零的。Baker 定理为这个值提供了一个正下界。因此，Baker 定理适用。要看 Roth 定理是否适用，我们可以将表达式重写为 $|\\log 2| \\cdot \\left| x - y \\frac{\\log 3}{\\log 2} \\right|$ 或 $|y| \\cdot \\left| \\frac{x}{y}\\log 2 - \\log 3 \\right|$。与 Roth 定理相关的最直接的解释是考虑用有理数 $\\frac{x}{y}$ 来逼近数 $\\frac{\\log 3}{\\log 2}$。Roth 定理仅当被逼近的数是代数数时才适用。然而，Baker 理论本身的一个结果是，任何具有代数系数的非平凡的代数数对数的线性形式都是超越数。一个特殊情况表明 $\\frac{\\log 3}{\\log 2}$ 是一个超越数。由于它不是代数数，Roth 定理不适用于它的有理逼近。该问题不涉及对*代数*数的有理逼近的理由是正确的。\n\n-   **结论**：两个实例及其理由都是正确的。所以，选项 A 是**正确的**。\n\n**B. 第一个实例：对于整数 $p,q$ 且 $q \\ge 1$，考虑 $\\left| \\log 2 - \\frac{p}{q} \\right|$。Roth 定理适用，因为 $\\log 2$ 是无理数，而 Baker 定理不适用。第二个实例：对于整数 $x,y$，考虑 $\\left| x \\log 2 - y \\log 4 \\right|$。Baker 定理保证了对于所有非零整数对 $(x,y)$ 存在一个统一的正下界。**\n\n-   **第一个实例分析**：表达式为 $\\left| \\log 2 - \\frac{p}{q} \\right|$。Roth 定理适用于**代数**无理数的有理逼近。根据 Lindemann-Weierstrass 定理，对于任何非零代数数 $r$，$e^r$ 是超越数。如果 $\\log 2$ 是代数数，那么 $e^{\\log 2} = 2$ 就必须是超越数，但这是错误的。因此，$\\log 2$ 是一个超越数。声称 Roth 定理适用是错误的。\n\n-   **第二个实例分析**：表达式为 $\\left| x \\log 2 - y \\log 4 \\right|$。由于 $\\log 4 = \\log(2^2) = 2 \\log 2$，表达式简化为 $\\left| x \\log 2 - y (2 \\log 2) \\right| = \\left| (x - 2y) \\log 2 \\right|$。Baker 定理适用于*非零*的线性形式。如果我们选择一个非零整数对，例如 $(x,y) = (2,1)$，该形式变为 $|(2 - 2(1))\\log 2| = 0$。该陈述声称 Baker 定理为“所有非零整数对 $(x,y)$”提供了一个“统一的正下界”，这是错误的，因为该形式可以为零。\n\n-   **结论**：该选项的两个部分都基于错误的假设。所以，选项 B 是**不正确的**。\n\n**C. 第一个实例：对于整数 $p,q$ 且 $q \\ge 1$，考虑 $\\left| \\sqrt{2} - \\frac{p}{q} \\right|$。Roth 定理和 Baker 定理都直接适用于此，因为 $\\sqrt{2} = e^{\\log \\sqrt{2}}$。第二个实例：对于整数 $x,y$，考虑 $\\left| x \\log 2 - y \\log 3 \\right|$。Roth 定理适用，因为 $\\frac{\\log 2}{\\log 3}$ 可以被视为一个代数无理数。**\n\n-   **第一个实例分析**：声称 Baker 定理“直接”适用于 $\\left| \\sqrt{2} - \\frac{p}{q} \\right|$ 是不正确的。该表达式不是对数的线性形式。理由“因为 $\\sqrt{2} = e^{\\log \\sqrt{2}}$”是一个不合逻辑的推论；不能简单地重写一个表达式来强行将一个定理应用于不同的结构。\n\n-   **第二个实例分析**：声称 Roth 定理适用因为“$\\frac{\\log 2}{\\log 3}$ 可以被视为一个代数无理数”是错误的。如选项 A 的分析所确立的，数 $\\frac{\\log 2}{\\log 3}$ 是超越数。\n\n-   **结论**：该选项的两个部分都基于错误的论断。所以，选项 C 是**不正确的**。\n\n**D. 第一个实例：对于整数 $p,q$ 且 $q \\ge 1$，考虑 $\\left| \\sqrt{2} - \\frac{p}{q} \\right|$。如果没有关于连分数的额外假设，Roth 定理不适用。第二个实例：对于整数 $x,y$，考虑 $\\left| x \\log 2 - y \\log e \\right|$。Baker 定理适用，因为 $e$ 是一个众所周知的常数并且存在对数。**\n\n-   **第一个实例分析**：陈述 Roth 定理“如果没有关于连分数的额外假设就不适用”是错误的。Roth 定理是关于代数无理数的丢番图逼近的一个普遍结果，其应用不需要与连分数相关的特定条件。它直接适用于 $\\left| \\sqrt{2} - \\frac{p}{q} \\right|$。\n\n-   **第二个实例分析**：表达式为 $\\left| x \\log 2 - y \\log e \\right|$。如问题中所定义的，Baker 定理适用于**代数**数对数的线性形式。这里，形式涉及到 $\\log 2$ 和 $\\log e$。虽然 $2$ 是一个代数数，但 $e$ 是一个超越数（由 Hermite 在 1873 年证明）。因此，Baker 定理（关于代数数对数的线性形式）不适用于此表达式。给出的理由含糊不清且在数学上不成立。注：Baker 定理可以被推广，但按其所述的标准形式，它在这里不适用。\n\n-   **结论**：该选项的两个部分都基于错误的论断。所以，选项 D 是**不正确的**。\n\n### 结论\n\n只有选项 A 正确地指出了一个 Roth 定理适用但 Baker 定理不适用的实例，以及一个 Baker 定理适用但 Roth 定理不适用的实例，并为每个实例提供了正确的理由。", "answer": "$$\\boxed{A}$$", "id": "3093660"}, {"introduction": "Roth定理有一个著名的论断：对于任何代数无理数，特别好的有理逼近，即满足不等式 $|\\alpha - p/q|  q^{-2-\\varepsilon}$ (其中 $\\varepsilon \\gt 0$) 的有理数 $p/q$，只有有限个。这个强大的论断可能感觉有些抽象。本计算练习将此定理付诸实践，指导你编写一个程序来主动搜寻这些罕见的逼近，让你亲眼见证它们的稀有性。[@problem_id:3093613]", "problem": "设 $\\alpha$ 是一个固定的代数无理数，$\\varepsilon  0$ 是一个固定的实数参数。回顾定义：如果一个实数 $\\alpha$ 是一个非零整系数多项式的根且不是有理数，则称其为代数无理数。一个有理逼近是一个分数 $p/q$，其中 $p$ 和 $q \\ge 1$ 是整数，其绝对误差为 $|\\alpha - p/q|$。我们使用的基本原则如下：对于每个固定的分母 $q \\in \\mathbb{Z}_{\\ge 1}$，通过选择 $p$ 为与 $\\alpha q$ 最接近的整数（即，使 $|\\alpha q - p|$ 最小化的 $p$），可以在所有整数 $p$ 中最小化 $|\\alpha - p/q|$ 的值。这可以从最近整数的定义以及四舍五入和绝对值的基本性质中得出。\n\n罗斯定理（Roth's theorem，丢番图逼近中的一个核心结果）断言，对于一个代数无理数 $\\alpha$ 和任意 $\\varepsilon  0$，不等式 $|\\alpha - p/q|  q^{-2-\\varepsilon}$ 在整数 $p$ 和 $q \\ge 1$ 中只有有限个解。本问题要求您设计并实现一个计算测试，对于具体的 $\\alpha$、$\\varepsilon$ 和搜索上界 $Q \\in \\mathbb{Z}_{\\ge 1}$，扫描所有满足 $1 \\le q \\le Q$ 的分母 $q$，并计算有多少个分母存在有理逼近 $p/q$ 违反不等式 $|\\alpha - p/q| \\ge q^{-2-\\varepsilon}$（等价地，满足 $|\\alpha - p/q|  q^{-2-\\varepsilon}$）。对于每个 $q$，使用四舍五入（round-half-up）约定选择 $p$ 为与 $\\alpha q$ 最接近的整数：$p = \\lfloor \\alpha q + 1/2 \\rfloor$。\n\n您的任务：\n- 对于下方的每个测试用例 $(\\alpha, \\varepsilon, Q)$，计算整数\n$$\nN(\\alpha,\\varepsilon,Q) = \\#\\{ q \\in \\mathbb{Z} \\mid 1 \\le q \\le Q,\\ \\text{with}\\ p = \\lfloor \\alpha q + 1/2 \\rfloor\\ \\text{satisfying}\\ |\\alpha - p/q|  q^{-2-\\varepsilon} \\}\n$$\n- 注意，对于固定的 $q$，在所有 $p$ 中最小化 $|\\alpha - p/q|$ 等价于最小化 $|\\alpha q - p|$，因此您可以比较等价的不等式 $|\\alpha q - p|  q^{-1-\\varepsilon}$ 以避免除以 $q$。\n\n使用以下参数测试套件，其中每个 $\\alpha$ 都是以闭合形式给出的特定代数无理数：\n1. $\\alpha = \\sqrt{2}$，$\\varepsilon = 0.1$，$Q = 100000$。\n2. $\\alpha = \\dfrac{1+\\sqrt{5}}{2}$，$\\varepsilon = 0.05$，$Q = 100000$。\n3. $\\alpha = \\sqrt[3]{2}$（$x^3 - 2 = 0$ 的唯一实根），$\\varepsilon = 0.2$，$Q = 100000$。\n4. $\\alpha = \\sqrt{3}$，$\\varepsilon = 0.001$，$Q = 20000$。\n5. $\\alpha = \\sqrt{2}$，$\\varepsilon = 0.4$，$Q = 1$。\n\n您的程序必须输出一行，其中包含五个整数的列表 $[N_1,N_2,N_3,N_4,N_5]$，顺序必须完全一致，其中 $N_i = N(\\alpha_i,\\varepsilon_i,Q_i)$ 是第 $i$ 个测试用例的结果。输出必须是形如 $[n_1,n_2,n_3,n_4,n_5]$ 的单行文本，不含空格。\n\n不涉及物理单位。不涉及角度。所有数值比较和最终计数必须严格符合规定的不等式和规则。最终输出格式必须是单行文本，包含一个用方括号括起来的逗号分隔列表（例如，$[17,5,0,2,1]$）。", "solution": "该问题要求我们基于丢番图逼近中的罗斯定理（Roth's theorem）进行一项计算测试。具体来说，对于给定的代数无理数 $\\alpha$、正实数 $\\varepsilon$ 和整数搜索上界 $Q$，我们必须计算在 $1 \\le q \\le Q$ 范围内的整数分母 $q$ 的数量，这些分母满足不等式 $|\\alpha - p/q|  q^{-2-\\varepsilon}$。对于每个 $q$，整数 $p$ 被唯一确定为与乘积 $\\alpha q$ 最接近的整数。\n\n待计算的量形式化定义为：\n$$\nN(\\alpha,\\varepsilon,Q) = \\#\\{ q \\in \\mathbb{Z} \\mid 1 \\le q \\le Q,\\ \\text{with}\\ p = \\lfloor \\alpha q + 1/2 \\rfloor\\ \\text{satisfying}\\ |\\alpha - p/q|  q^{-2-\\varepsilon} \\}\n$$\n规则 $p = \\lfloor \\alpha q + 1/2 \\rfloor$ 对应于用于寻找最近整数的标准四舍五入（round-half-up）约定。\n\n出于计算目的，最好对不等式进行变换，以避免除法运算和潜在的浮点数不精确问题。将不等式两边乘以 $q$（为正数），得到等价形式：\n$$\n|\\alpha q - p|  q^{-1-\\varepsilon}\n$$\n这种形式在数值上更稳定，因为它在计算误差时避免了除以 $q$，也避免了计算 $q$ 的接近 -2 的负次幂，这个值可能非常小。\n\n为给定测试用例计算 $N(\\alpha, \\varepsilon, Q)$ 的算法如下：\n\n1.  初始化一个解的计数器，例如 `count`，其值为 $0$。\n2.  遍历从 $1$ 到 $Q$ 的所有整数分母 $q$。\n3.  对于每个 $q$ 值：\n    a. 使用指定的四舍五入规则计算相应的分子 $p$：$p = \\lfloor \\alpha q + 0.5 \\rfloor$。\n    b. 计算变换后不等式的左侧 (LHS)：$\\text{LHS} = |\\alpha q - p|$。\n    c. 计算变换后不等式的右侧 (RHS)：$\\text{RHS} = q^{-(1+\\varepsilon)}$。\n    d. 比较两侧。如果 $\\text{LHS}  \\text{RHS}$，则表示当前 $q$ 满足条件。在这种情况下，将 `count` 加一。\n4.  循环完成后，`count` 的最终值即为结果 $N(\\alpha, \\varepsilon, Q)$。\n\n这个过程可以使用矢量化操作高效实现，例如使用 NumPy 库。可以创建一个包含从 $1$ 到 $Q$ 所有整数 $q$ 的数组。然后，可以在单个矢量化步骤中计算出对应的 $p$、LHS 和 RHS 数组。最后，通过矢量化比较和求和可以得出总数。\n\n实现的一个关键方面是数值精度。对于某些测试用例，特别是涉及像黄金分割 $\\phi = \\frac{1+\\sqrt{5}}{2}$ 这样“非常无理”的数，对于大的 $q$ 值， $|\\alpha q - p|$ 的值可能会变得极小。标准双精度浮点数（`float64`）可能没有足够的精度来准确表示乘积 $\\alpha q$，在减去 $p$ 时会导致灾难性抵消（catastrophic cancellation）。这可能导致 LHS 的值不正确，并对不等式做出错误评估。为确保正确性，对于这些敏感计算，有必要使用更高精度的浮点类型，例如 `numpy.longdouble`。\n\n该算法应用于以下五个测试用例：\n1.  $\\alpha = \\sqrt{2}$，$\\varepsilon = 0.1$，$Q = 100000$。\n2.  $\\alpha = \\frac{1+\\sqrt{5}}{2}$，$\\varepsilon = 0.05$，$Q = 100000$。\n3.  $\\alpha = \\sqrt[3]{2}$，$\\varepsilon = 0.2$，$Q = 100000$。\n4.  $\\alpha = \\sqrt{3}$，$\\varepsilon = 0.001$，$Q = 20000$。\n5.  $\\alpha = \\sqrt{2}$，$\\varepsilon = 0.4$，$Q = 1$。\n\n最终输出是五个整数计数的列表 $[N_1, N_2, N_3, N_4, N_5]$。", "answer": "```python\nimport numpy as np\n\ndef count_violations(alpha, epsilon, Q):\n    \"\"\"\n    Counts the number of denominators q in [1, Q] for which the inequality\n    |alpha - p/q|  q**(-2-epsilon) holds, where p is the nearest integer to alpha*q.\n    This is equivalent to |alpha*q - p|  q**(-1-epsilon).\n\n    Args:\n        alpha (float): The algebraic irrational number.\n        epsilon (float): The epsilon parameter from Roth's theorem.\n        Q (int): The upper bound for the denominator q.\n\n    Returns:\n        int: The number of denominators q that satisfy the condition.\n    \"\"\"\n    \n    # Use extended precision (long double) for calculations to avoid catastrophic\n    # cancellation and precision loss, which can occur with standard float64 for\n    # certain alpha values (like the golden ratio) and large q.\n    alpha_ld = np.longdouble(alpha)\n    epsilon_ld = np.longdouble(epsilon)\n    \n    # Create an array of all denominators q from 1 to Q.\n    # We use int64 for q to be safe, then cast to longdouble for calculations.\n    q_vals = np.arange(1, Q + 1, dtype=np.int64)\n    q_vals_ld = q_vals.astype(np.longdouble)\n\n    # For each q, find the nearest integer p to alpha*q using the round-half-up rule:\n    # p = floor(alpha*q + 0.5)\n    # The calculation is vectorized for efficiency.\n    p_vals = np.floor(alpha_ld * q_vals_ld + np.longdouble(0.5))\n\n    # Calculate the left-hand side of the inequality |alpha*q - p|.\n    lhs = np.abs(alpha_ld * q_vals_ld - p_vals)\n    \n    # Calculate the right-hand side of the inequality q**(-1-epsilon).\n    rhs = q_vals_ld**(-np.longdouble(1.0) - epsilon_ld)\n    \n    # Count how many q values satisfy the inequality lhs  rhs.\n    count = np.sum(lhs  rhs)\n    \n    # The result is an integer count.\n    return int(count)\n\ndef solve():\n    \"\"\"\n    Solves the problem for the given test suite of parameters.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each tuple is (alpha, epsilon, Q).\n    test_cases = [\n        (np.sqrt(2), 0.1, 100000),                      # Case 1\n        ((1 + np.sqrt(5)) / 2.0, 0.05, 100000),      # Case 2\n        (np.cbrt(2), 0.2, 100000),                      # Case 3\n        (np.sqrt(3), 0.001, 20000),                     # Case 4\n        (np.sqrt(2), 0.4, 1)                           # Case 5\n    ]\n\n    results = []\n    for alpha, epsilon, Q in test_cases:\n        # Calculate the number of violations for the current test case.\n        result = count_violations(alpha, epsilon, Q)\n        results.append(result)\n\n    # Format the final output as a single-line comma-separated list in brackets,\n    # with no spaces, as required by the problem statement.\n    print(f\"[{','.join(map(str, results))}]\")\n\n# Execute the solution.\nsolve()\n\n```", "id": "3093613"}]}