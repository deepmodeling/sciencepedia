{"hands_on_practices": [{"introduction": "理解孪生素数猜想的第一步是掌握孪生素数对的基本性质。这个练习将引导你通过直接验证几个例子，并利用模算术来揭示一个深刻的结构性事实：除了最小的一对孪生素数外，所有孪生素数对都必须紧邻6的倍数。这个看似简单的性质是研究孪生素数分布的基石。[@problem_id:3083268]", "problem": "请根据以下基本定义进行操作。一个整数 $p \\geq 2$ 被称为素数，如果其唯一的正因数是 $1$ 和 $p$。一对素数 $\\left(p,q\\right)$ 是一个孪生素数对，如果 $q-p=2$。对于一个正整数 $m$，整数 $n$ 模 $m$ 的余数是唯一的整数 $r$，满足 $0 \\leq r \\leq m-1$ 且 $n \\equiv r \\pmod{m}$。\n\n仅使用这些定义和基本的整除性，按以下步骤进行。首先，从模 $6$ 的余数情况推断出，任何大于 $3$ 的素数 $p$ 必须满足 $p \\equiv 1 \\pmod{6}$ 或 $p \\equiv 5 \\pmod{6}$。接下来，使用试除法，通过除以不超过 $\\sqrt{n}$ 的素数，明确验证 $\\left(3,5\\right)$、$\\left(5,7\\right)$、$\\left(11,13\\right)$ 和 $\\left(17,19\\right)$ 是孪生素数对。最后，将这四对中的每个素数按其模 $6$ 的最小非负余数进行分类，并将这八个余数按 $3,5,5,7,11,13,17,19$ 的顺序记录为单行矩阵 $R$ 的元素。\n\n你的最终答案必须是由这八个模 $6$ 的余数（使用最小非负代表元）组成的行矩阵 $R$。无需四舍五入。", "solution": "该问题是有效的，因为它具有科学依据、提法明确、客观且自洽。解题过程按规定分为三部分进行。\n\n首先，我们推断出任何大于 $3$ 的素数 $p$ 模 $6$ 的余数必须是 $1$ 或 $5$。\n设 $p$ 是一个大于 $3$ 的整数。根据带余除法，$p$ 可以写成 $p = 6k + r$ 的形式，其中 $k$ 是某个整数且 $k \\ge 1$，$r$ 是唯一的余数且 $0 \\le r \\le 5$。我们检查 $r$ 的每个可能值：\n- 如果 $r=0$，那么 $p = 6k = 2(3k)$。因为 $p  3$，我们有 $k \\ge 1$，这意味着 $3k  1$。因此，$p$ 能被 $2$ 和 $3$ 整除。由于其因数不只有 $1$ 和 $p$，所以它不是一个素数。\n- 如果 $r=2$，那么 $p = 6k+2 = 2(3k+1)$。因为 $p  3$，我们有 $k \\ge 1$，这意味着 $3k+1  1$。因此，$p$ 能被 $2$ 整除。由于其因数不只有 $1$ 和 $p$，所以它不是一个素数。\n- 如果 $r=3$，那么 $p = 6k+3 = 3(2k+1)$。因为 $p  3$，我们有 $k \\ge 1$，这意味着 $2k+1  1$。因此，$p$ 能被 $3$ 整除。由于其因数不只有 $1$ 和 $p$，所以它不是一个素数。\n- 如果 $r=4$，那么 $p = 6k+4 = 2(3k+2)$。因为 $p  3$，我们有 $k \\ge 1$，这意味着 $3k+2  1$。因此，$p$ 能被 $2$ 整除。由于其因数不只有 $1$ 和 $p$，所以它不是一个素数。\n因此，余数 $r$ 仅剩的可能性是 $r=1$ 和 $r=5$。所以，如果 $p$ 是一个大于 $3$ 的素数，它必须满足 $p \\equiv 1 \\pmod{6}$ 或 $p \\equiv 5 \\pmod{6}$。\n\n第二，我们使用素数的定义和试除法（通过除以不超过 $\\sqrt{n}$ 的素数）来验证给定的数对是孪生素数对。\n- 对于数对 $(3,5)$：\n  - $p=3$：唯一的正因数是 $1$ 和 $3$，所以 $3$ 是素数。\n  - $q=5$：为了检验其素性，我们检查不超过 $\\sqrt{5} \\approx 2.23$ 的素因数。唯一需要测试的素数是 $2$。因为 $5$ 不能被 $2$ 整除，所以 $5$ 是素数。\n  - 它们的差是 $5-3=2$，所以 $(3,5)$ 是一个孪生素数对。\n- 对于数对 $(5,7)$：\n  - $p=5$：已验证为素数。\n  - $q=7$：我们检查不超过 $\\sqrt{7} \\approx 2.64$ 的素因数。我们测试素数 $2$。因为 $7$ 不能被 $2$ 整除，所以 $7$ 是素数。\n  - 它们的差是 $7-5=2$，所以 $(5,7)$ 是一个孪生素数对。\n- 对于数对 $(11,13)$：\n  - $p=11$：我们检查不超过 $\\sqrt{11} \\approx 3.31$ 的素因数。我们测试素数 $2$ 和 $3$。因为 $11$ 不能被 $2$ 或 $3$ 整除，所以 $11$ 是素数。\n  - $q=13$：我们检查不超过 $\\sqrt{13} \\approx 3.60$ 的素因数。我们测试素数 $2$ 和 $3$。因为 $13$ 不能被 $2$ 或 $3$ 整除，所以 $13$ 是素数。\n  - 它们的差是 $13-11=2$，所以 $(11,13)$ 是一个孪生素数对。\n- 对于数对 $(17,19)$：\n  - $p=17$：我们检查不超过 $\\sqrt{17} \\approx 4.12$ 的素因数。我们测试素数 $2$ 和 $3$。因为 $17$ 不能被 $2$ 或 $3$ 整除，所以 $17$ 是素数。\n  - $q=19$：我们检查不超过 $\\sqrt{19} \\approx 4.35$ 的素因数。我们测试素数 $2$ 和 $3$。因为 $19$ 不能被 $2$ 或 $3$ 整除，所以 $19$ 是素数。\n  - 它们的差是 $19-17=2$，所以 $(17,19)$ 是一个孪生素数对。\n\n第三，我们将有序列表 $3, 5, 5, 7, 11, 13, 17, 19$ 中的每个素数按其模 $6$ 的最小非负余数进行分类，并构造矩阵 $R$。\n- 对于 $3$：$3 = 0 \\cdot 6 + 3 \\implies 3 \\equiv 3 \\pmod{6}$。余数是 $3$。\n- 对于 $5$：$5 = 0 \\cdot 6 + 5 \\implies 5 \\equiv 5 \\pmod{6}$。余数是 $5$。\n- 对于 $5$：$5 = 0 \\cdot 6 + 5 \\implies 5 \\equiv 5 \\pmod{6}$。余数是 $5$。\n- 对于 $7$：$7 = 1 \\cdot 6 + 1 \\implies 7 \\equiv 1 \\pmod{6}$。余数是 $1$。\n- 对于 $11$：$11 = 1 \\cdot 6 + 5 \\implies 11 \\equiv 5 \\pmod{6}$。余数是 $5$。\n- 对于 $13$：$13 = 2 \\cdot 6 + 1 \\implies 13 \\equiv 1 \\pmod{6}$。余数是 $1$。\n- 对于 $17$：$17 = 2 \\cdot 6 + 5 \\implies 17 \\equiv 5 \\pmod{6}$。余数是 $5$。\n- 对于 $19$：$19 = 3 \\cdot 6 + 1 \\implies 19 \\equiv 1 \\pmod{6}$。余数是 $1$。\n余数序列是 $(3, 5, 5, 1, 5, 1, 5, 1)$。行矩阵 $R$ 由这些元素构成。", "answer": "$$\n\\boxed{\\begin{pmatrix} 3  5  5  1  5  1  5  1 \\end{pmatrix}}\n$$", "id": "3083268"}, {"introduction": "弱哥德巴赫猜想断言，每个大于5的奇数都可以表示为三个素数之和。为了将这个抽象的陈述具体化，本练习要求你对一个具体的数字（33）计算其表示方法的数量，即所谓的“表示函数”$r_3(n)$。通过系统地枚举所有可能性，你将亲身体验组合方法在数论问题中的应用，并加深对这类加性问题复杂性的理解。[@problem_id:3083280]", "problem": "仿照弱哥德巴赫问题和维诺格拉多夫关于将奇数表示为三个素数之和的定理，定义表示函数 $r_3(n)$ 为满足 $p_1+p_2+p_3=n$ 的奇素数有序三元组 $(p_1,p_2,p_3)$ 的数量。仅使用素数和奇素数的基本定义，以及多重集排列的基本计数原理，通过首先列出所有满足 $p \\leq q \\leq r$ 和 $p+q+r=33$ 的奇素数无序三元组 $\\{p,q,r\\}$，然后考虑排列下的多重性以获得有序表示的总数，来计算 $r_3(33)$。请以单个整数形式提供最终答案。", "solution": "问题要求计算 $r_3(33)$，它被定义为和为 $33$ 的奇素数有序三元组 $(p_1, p_2, p_3)$ 的数量，即 $p_1 + p_2 + p_3 = 33$。指定的方法是，首先找到所有和为 $33$ 的奇素数无序三元组 $\\{p, q, r\\}$，然后计算从每个无序三元组可以形成的不同的有序三元组的数量。\n\n奇素数是大于2的素数。奇素数序列以 $3, 5, 7, 11, 13, \\dots$ 开始。设 $\\{p, q, r\\}$ 是一个满足 $p+q+r=33$ 的奇素数无序三元组。不失一般性，我们可以设定一个顺序 $p \\le q \\le r$ 以系统地枚举所有可能性。\n\n由于 $p, q, r$ 是奇素数，它们的最小可能值都是 $3$。约束条件 $p \\le q \\le r$ 意味着 $3p \\le p+q+r = 33$，这给出了最小素数 $p$ 的一个上界：$p \\le 11$。因此，我们只需要考虑 $p$ 是奇素数 $3, 5, 7,$ 或 $11$ 的情况。\n\n此外，由于 $p_1, p_2, p_3 \\ge 3$，任何三元组中可能的最大素数都以 $33 - 3 - 3 = 27$ 为界。因此，需要考虑的相关奇素数集合是 $\\{3, 5, 7, 11, 13, 17, 19, 23\\}$。\n\n我们系统地搜索无序三元组 $\\{p, q, r\\}$：\n\n1.  设 $p=3$。条件变为 $q+r = 33-3=30$，约束条件为 $3 \\le q \\le r$。条件 $2q \\le q+r = 30$ 意味着 $q \\le 15$。我们在范围 $[3, 15]$ 内测试 $q$ 的奇素数值：\n    -   若 $q=3$，则 $r=27$，不是素数。\n    -   若 $q=5$，则 $r=25$，不是素数。\n    -   若 $q=7$，则 $r=23$，是一个素数。这给出了三元组 $\\{3, 7, 23\\}$。\n    -   若 $q=11$，则 $r=19$，是一个素数。这给出了三元组 $\\{3, 11, 19\\}$。\n    -   若 $q=13$，则 $r=17$，是一个素数。这给出了三元组 $\\{3, 13, 17\\}$。\n\n2.  设 $p=5$。条件变为 $q+r = 33-5=28$，约束条件为 $5 \\le q \\le r$。条件 $2q \\le 28$ 意味着 $q \\le 14$。我们在范围 $[5, 13]$ 内测试 $q$ 的奇素数值：\n    -   若 $q=5$，则 $r=23$，是一个素数。这给出了三元组 $\\{5, 5, 23\\}$。\n    -   若 $q=7$，则 $r=21$，不是素数。\n    -   若 $q=11$，则 $r=17$，是一个素数。这给出了三元组 $\\{5, 11, 17\\}$。\n    -   若 $q=13$，则 $r=15$，不是素数。\n\n3.  设 $p=7$。条件变为 $q+r = 33-7=26$，约束条件为 $7 \\le q \\le r$。条件 $2q \\le 26$ 意味着 $q \\le 13$。我们在范围 $[7, 13]$ 内测试 $q$ 的奇素数值：\n    -   若 $q=7$，则 $r=19$，是一个素数。这给出了三元组 $\\{7, 7, 19\\}$。\n    -   若 $q=11$，则 $r=15$，不是素数。\n    -   若 $q=13$，则 $r=13$，是一个素数。这给出了三元组 $\\{7, 13, 13\\}$。\n\n4.  设 $p=11$。条件变为 $q+r = 33-11=22$，约束条件为 $11 \\le q \\le r$。条件 $2q \\le 22$ 意味着 $q \\le 11$。这迫使 $q=11$。\n    -   若 $q=11$，则 $r=11$，是一个素数。这给出了三元组 $\\{11, 11, 11\\}$。\n\n穷举搜索得到以下 $8$ 个唯一的无序三元组：\n-   $\\{3, 7, 23\\}$\n-   $\\{3, 11, 19\\}$\n-   $\\{3, 13, 17\\}$\n-   $\\{5, 11, 17\\}$\n-   $\\{5, 5, 23\\}$\n-   $\\{7, 7, 19\\}$\n-   $\\{7, 13, 13\\}$\n-   $\\{11, 11, 11\\}$\n\n接下来，我们通过应用多重集排列的公式，为每个无序三元组计算有序三元组 $(p_1, p_2, p_3)$ 的数量。\n\n-   **情况 A：包含三个不同素数的三元组。**\n    形式为 $\\{p, q, r\\}$，其中 $p  q  r$。有序排列的数量为 $3! = 6$。\n    这些三元组是：$\\{3, 7, 23\\}$、$\\{3, 11, 19\\}$、$\\{3, 13, 17\\}$ 和 $\\{5, 11, 17\\}$。\n    共有 $4$ 个这样的三元组。来自这一组的有序表示总数为 $4 \\times 6 = 24$。\n\n-   **情况 B：包含两个相同素数的三元组。**\n    形式为 $\\{p, p, r\\}$，其中 $p \\neq r$。有序排列的数量为 $\\frac{3!}{2!1!} = 3$。\n    这些三元组是：$\\{5, 5, 23\\}$、$\\{7, 7, 19\\}$ 和 $\\{7, 13, 13\\}$。\n    共有 $3$ 个这样的三元组。来自这一组的有序表示总数为 $3 \\times 3 = 9$。\n\n-   **情况 C：包含三个相同素数的三元组。**\n    形式为 $\\{p, p, p\\}$。有序排列的数量为 $\\frac{3!}{3!} = 1$。\n    这个三元组是：$\\{11, 11, 11\\}$。\n    有 $1$ 个这样的三元组。来自这一组的有序表示总数为 $1 \\times 1 = 1$。\n\n最后，有序表示的总数 $r_3(33)$ 是所有情况计数之和：\n$$r_3(33) = 24 + 9 + 1 = 34$$", "answer": "$$\\boxed{34}$$", "id": "3083280"}, {"introduction": "虽然强哥德巴赫猜想的证明仍然遥不可及，但我们可以通过计算机在极大的范围内验证其正确性。这个实践练习将理论与计算相结合，指导你实现一个经典的素数筛选算法——埃拉托斯特尼筛法，并用它来系统地检验一百万以内的所有偶数。这不仅让你感受到支持该猜想的强大经验证据，还让你掌握了实验数学中的一个基本工具。[@problem_id:3083305]", "problem": "令 $G$ 表示强哥德巴赫猜想，该猜想断言每个偶数 $N \\ge 4$ 都可以写成两个素数之和。从素数是 $p \\ge 2$ 且其正因数仅为 $1$ 和 $p$ 的整数这一定义出发，并使用 Sieve of Eratosthenes 计算有限界限内的素性，你的任务是设计并实现一个完整的程序，该程序对所有偶数 $N \\le 10^6$ 进行计算验证 $G$，并且如下文所述，提取哥德巴赫表示中所需较小素数大小的显式数值界限。\n\n定义和要求：\n- 对于一个偶数 $N \\ge 4$，定义 $p_{\\min}(N)$ 为满足存在素数 $q$ 使得 $p+q=N$ 的最小素数 $p$。\n- 对于一个界限 $B \\ge 4$，定义验证标志 $V(B)$ 为真，当且仅当对于每个满足 $4 \\le N \\le B$ 的偶数 $N$，都存在至少一个表示形式 $N=p+q$，其中 $p$ 和 $q$ 均为素数。\n- 将截至 $B$ 的较小素数的极值界限定义为\n$$\nM(B) := \\max_{\\substack{N \\text{ even}\\\\ 4 \\le N \\le B}} p_{\\min}(N),\n$$\n并定义相应的见证数\n$$\nN^{*}(B) := \\min\\left\\{ N \\in \\{4,6,\\dots,B\\} : p_{\\min}(N) = M(B) \\right\\}.\n$$\n- 为计算素数，你必须实现 Sieve of Eratosthenes 直到 $U=10^6$，并使用生成的素性表在验证过程中测试 $N-p$ 是否为素数。\n- 搜索策略参数：对于每个偶数 $N$，你将通过检查候选素数 $p \\le N/2$ 并测试 $N-p$ 是否为素数来定位 $p_{\\min}(N)$。实现两种搜索顺序，由模式参数 $m$ 控制：\n  - $m=0$：按升序扫描候选素数 $p$，并在第一次命中时停止（这直接得到 $p_{\\min}(N)$）。\n  - $m=1$：按降序从 $\\lfloor N/2 \\rfloor$ 向下扫描至 $2$ 的候选素数 $p$，并通过完成完整扫描并选择遇到的满足素数配对条件的最小 $p$ 来计算 $p_{\\min}(N)$。\n两种模式都必须计算出完全相同的 $p_{\\min}(N)$，但它们体现了不同的算法行为。\n\n验证失败时的行为：如果 $V(B)$ 为假（即，如果至少有一个偶数 $N \\le B$ 没有哥德巴赫表示），则对于该测试用例，设置 $M(B)=-1$ 和 $N^{*}(B)=-1$。\n\n测试套件：\n- 使用以下三个测试用例，每个由一对 $(B,m)$ 指定：\n  - $(4,0)$,\n  - $(1000,1)$,\n  - $(10^6,0)$.\n这些测试用例共同覆盖了一个边界情况、一个使用较慢扫描顺序的小界限，以及一个使用优化扫描顺序的完整要求验证。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，顺序与测试套件相对应如下：\n$$\n\\big[\\,V(4),\\, M(4),\\, N^{*}(4),\\, V(1000),\\, M(1000),\\, N^{*}(1000),\\, V(10^6),\\, M(10^6),\\, N^{*}(10^6)\\,\\big].\n$$\n所有布尔值和整数都应以其本地编程语言的字面量格式打印，不含额外文本。此任务不需要用户输入，也不适用任何物理单位。", "solution": "用户提供的问题陈述已经过仔细分析，并被确定为 **有效**。这是一个在数论领域内定义明确、有科学依据且计算上可行的问题。所有定义、约束和目标都足够清晰和精确，足以得出一个唯一且可验证的解决方案。\n\n问题的核心是计算上验证强哥德巴赫猜想至界限 $B=10^6$，并计算与哥德巴赫分割相关的特定极值属性。解决方案将使用 Python 实现，并遵循指定的环境约束。\n\n算法方法基于以下原则设计：\n\n**1. 素性测试：Sieve of Eratosthenes**\n为了高效地检查素性（这是此问题中的一个基本操作），我们将预先计算所有直至所需最大界限 $B_{max}=10^6$ 的整数的素性表。Sieve of Eratosthenes 是为此任务指定的、最合适的算法。其工作原理是从 $2$ 开始，迭代地将每个素数的倍数标记为合数。\n\n该算法使用一个大小为 $B_{max}+1$ 的布尔数组 `is_prime` 进行初始化，所有条目均设置为 `True`。我们将 $0$ 和 $1$ 标记为非素数。然后，对于从 $2$ 到 $\\sqrt{B_{max}}$ 的每个整数 $p$，如果 $p$ 仍被标记为素数，我们就遍历其倍数（$p^2, p^2+p, \\dots$）并将它们标记为非素数。此过程最终只留下被标记为 `True` 的素数。此预计算为我们在验证猜想的循环中提供了 $O(1)$ 的素性测试查找时间。我们还生成一个截至 $B_{max}$ 的所有素数的排序列表，以方便高效搜索。\n\n**2. 哥德巴赫分割搜索：$p_{\\min}(N)$ 计算**\n对于范围 $[4, B]$ 内的每个偶数 $N$，我们必须找到 $p_{\\min}(N)$，即满足 $q=N-p$ 也是素数的最小素数 $p$。该问题要求为此任务实现两种不同的搜索策略，由模式参数 $m$ 控制。在两种模式下，对素数 $p$ 的搜索都可以限制在范围 $p \\le N/2$ 内，因为如果 $N=p+q$ 且 $p>N/2$，那么 $q=N-p  N/2$。如果 $q$ 是素数，这对组合在循环遇到 $q$ 时就会被找到。所以我们可以停止。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom bisect import bisect_right\n\ndef sieve(limit: int) - np.ndarray:\n    \"\"\"\n    Implements the Sieve of Eratosthenes to find all primes up to a given limit.\n    Returns a boolean NumPy array where is_prime[i] is True if i is prime.\n    \"\"\"\n    is_prime = np.ones(limit + 1, dtype=bool)\n    is_prime[0] = is_prime[1] = False\n    for p in range(2, int(np.sqrt(limit)) + 1):\n        if is_prime[p]:\n            is_prime[p*p::p] = False\n    return is_prime\n\ndef find_p_min(N: int, m: int, is_prime: np.ndarray, primes_list: np.ndarray) - int:\n    \"\"\"\n    Finds the smallest prime p such that N-p is also prime, for an even N = 4.\n    The search strategy is determined by the mode parameter m.\n    \n    m=0: Scan candidate primes p in increasing order.\n    m=1: Scan candidate primes p in decreasing order from floor(N/2).\n    \n    Returns p_min(N) or -1 if no such prime exists.\n    \"\"\"\n    if m == 0:\n        # Increasing search: first hit is the minimum.\n        for p in primes_list:\n            if p  N // 2:\n                # If p  N/2, then q = N-p  N/2. If q is prime, this pair would have\n                # been found when the loop encountered q. So we can stop.\n                break\n            if is_prime[N - p]:\n                return p\n        return -1\n    \n    elif m == 1:\n        # Decreasing search: must complete the full scan.\n        p_min_found = -1\n        # Get index of the largest prime = N//2\n        idx = bisect_right(primes_list, N // 2)\n        \n        # Iterate primes in decreasing order from floor(N/2) down to 2\n        for i in range(idx - 1, -1, -1):\n            p = primes_list[i]\n            if is_prime[N - p]:\n                # Since we iterate p downwards, the last p found will be the smallest one.\n                p_min_found = p\n        \n        return p_min_found\n\n    return -1 # Should not be reached\n\ndef solve():\n    \"\"\"\n    Main function to run the Goldbach verification for the specified test suite.\n    \"\"\"\n    test_cases = [\n        (4, 0),\n        (1000, 1),\n        (1000000, 0)\n    ]\n\n    max_B = max(b for b, m in test_cases)\n    is_prime = sieve(max_B)\n    primes_list = np.where(is_prime)[0]\n    \n    final_results = []\n\n    for B, m in test_cases:\n        V_B = True\n        M_B = 0\n        N_star_B = 0\n\n        # Loop through even numbers from 4 to B\n        for N in range(4, B + 1, 2):\n            p_min_N = find_p_min(N, m, is_prime, primes_list)\n\n            if p_min_N == -1:\n                # Goldbach conjecture failed for N\n                V_B = False\n                M_B = -1\n                N_star_B = -1\n                break  # Stop processing this test case\n            \n            # Update the extremal bound M(B) and its witness N*(B)\n            if p_min_N  M_B:\n                M_B = p_min_N\n                N_star_B = N\n        \n        final_results.extend([V_B, M_B, N_star_B])\n\n    # Convert boolean True to string 'True' for output formatting\n    output_str = ','.join(map(str, final_results))\n    print(f\"[{output_str}]\")\n\nsolve()\n```", "id": "3083305"}]}