{"hands_on_practices": [{"introduction": "要真正掌握狄利克雷双曲线法，没有什么比动手计算更有效。第一个练习将引导你对一个特定的 $x$ 值，明确地划分求和区域。通过计算三个不同区域上的和，并验证它们的总和是否正确[@problem_id:3090772]，你将对该方法的几何和代数基础有一个具体的理解。", "problem": "设 $f$ 和 $g$ 为正整数上的数论函数，它们的狄利克雷卷积 $(f * g)$ 定义为 $(f * g)(n) = \\sum_{ab = n} f(a) g(b)$。从此定义出发，并利用不等式 $ab \\leq x$ 作为双曲线 $ab = x$ 下方整格点区域的计数解释，推导狄利克雷双曲线法分解，该方法通过在双曲线顶点处分割，将和式 $\\sum_{n \\leq x} (f * g)(n)$ 分成三个部分。然后，将此方法应用于 $f = g = 1$ 且 $x = 100$ 的特殊情况，其中 $1$ 表示对所有正整数 $n$ 都有 $1(n) = 1$ 的常数函数。\n\n执行以下步骤：\n- 通过以 $a = \\sqrt{100}$ 和 $b = \\sqrt{100}$ 为分割线，用关于 $a$ 和 $b$ 的不等式描述三个区域，为 $x = 100$ 显式地构造双曲线分割。在需要时使用最大整数函数（向下取整函数）$\\lfloor \\cdot \\rfloor$。\n- 当 $f = g = 1$ 时，计算由该分解产生的三个和。\n- 数值上验证该分解与原和式 $\\sum_{n \\leq 100} \\tau(n)$ 精确相等，其中 $\\tau(n)$ 是 $n$ 的正因数个数。\n\n将 $\\sum_{n \\leq 100} \\tau(n)$ 的最终值以单个整数形式给出。无需四舍五入。", "solution": "问题要求使用狄利克雷双曲线法推导和式 $\\sum_{n \\leq x} (f * g)(n)$，然后将此方法应用于 $x = 100$ 且 $f$ 和 $g$ 是对所有正整数 $n$ 恒为 $1(n)=1$ 的常数函数的特殊情况。\n\n首先，我们推导一般性的分解。所讨论的和式由下式给出：\n$$ S(x) = \\sum_{n=1}^{\\lfloor x \\rfloor} (f * g)(n) $$\n使用狄利克雷卷积的定义 $(f * g)(n) = \\sum_{ab=n} f(a)g(b)$，我们可以将和式改写为：\n$$ S(x) = \\sum_{n=1}^{\\lfloor x \\rfloor} \\sum_{ab=n} f(a)g(b) $$\n这等价于对所有满足其乘积 $ab \\leq x$ 的正整数对 $(a, b)$ 求和：\n$$ S(x) = \\sum_{ab \\leq x} f(a)g(b) $$\n对于正整数 $a$ 和 $b$，条件 $ab \\leq x$ 定义了整格点第一象限中，双曲线 $ab=x$ 上或其下方的一个区域。狄利克雷双曲线法提供了一种通过分割该区域来计算其中格点数的方法。\n\n设 $u$ 是一个正实数参数，我们将其设为 $u = \\sqrt{x}$。求和区域 $R = \\{(a, b) \\in \\mathbb{Z}^+ \\times \\mathbb{Z}^+ \\mid ab \\leq x\\}$ 可以通过在 $a = u$ 和 $b = u$ 处分割，划分为三个不相交的子区域：\n1.  $R_1 = \\{(a, b) \\in R \\mid a \\leq u, b \\leq u\\}$\n2.  $R_2 = \\{(a, b) \\in R \\mid a \\leq u, b > u\\}$\n3.  $R_3 = \\{(a, b) \\in R \\mid a > u, b \\leq u\\}$\n注意，如果 $a > u$ 且 $b > u$，那么 $ab > u^2=x$，因此在分割的这第四个象限中没有满足 $ab \\leq x$ 的点。并集 $R_1 \\cup R_2 \\cup R_3$ 是整个区域 $R$。\n\n总和 $S(x)$ 是这三个不相交区域贡献之和：\n$$ S(x) = \\sum_{(a,b) \\in R_1} f(a)g(b) + \\sum_{(a,b) \\in R_2} f(a)g(b) + \\sum_{(a,b) \\in R_3} f(a)g(b) $$\n令 $F(y) = \\sum_{k=1}^{\\lfloor y \\rfloor} f(k)$ 和 $G(y) = \\sum_{k=1}^{\\lfloor y \\rfloor} g(k)$ 为 $f$ 和 $g$ 的求和函数。每个区域上的和可以表示为：\n- 在 $R_1$ 上的和： $\\sum_{a=1}^{\\lfloor u \\rfloor} \\sum_{b=1}^{\\lfloor u \\rfloor} f(a)g(b) = \\left(\\sum_{a=1}^{\\lfloor u \\rfloor} f(a)\\right) \\left(\\sum_{b=1}^{\\lfloor u \\rfloor} g(b)\\right) = F(\\lfloor u \\rfloor)G(\\lfloor u \\rfloor)$。\n- 在 $R_2$ 上的和： $\\sum_{a=1}^{\\lfloor u \\rfloor} f(a) \\sum_{b=\\lfloor u \\rfloor+1}^{\\lfloor x/a \\rfloor} g(b) = \\sum_{a=1}^{\\lfloor u \\rfloor} f(a) \\left( G(\\lfloor x/a \\rfloor) - G(\\lfloor u \\rfloor) \\right)$。\n- 在 $R_3$ 上的和： $\\sum_{b=1}^{\\lfloor u \\rfloor} g(b) \\sum_{a=\\lfloor u \\rfloor+1}^{\\lfloor x/b \\rfloor} f(a) = \\sum_{b=1}^{\\lfloor u \\rfloor} g(b) \\left( F(\\lfloor x/b \\rfloor) - F(\\lfloor u \\rfloor) \\right)$。\n\n现在，我们来处理问题中给出的特殊情况：对所有 $n \\in \\mathbb{Z}^+$，有 $f(n) = g(n) = 1$，且 $x = 100$。\n在这种情况下，卷积是除数函数，$\\tau(n) = (1 * 1)(n) = \\sum_{d|n} 1$。我们希望计算的和是 $\\sum_{n=1}^{100} \\tau(n)$。\n求和函数为 $F(y) = G(y) = \\sum_{k=1}^{\\lfloor y \\rfloor} 1 = \\lfloor y \\rfloor$。\n分割参数为 $u = \\sqrt{x} = \\sqrt{100} = 10$。因此，$\\lfloor u \\rfloor = 10$。\n\n区域 $ab \\leq 100$ 的分割如下：\n- 区域 1：$R_1 = \\{(a,b) \\in \\mathbb{Z}^+ \\times \\mathbb{Z}^+ \\mid 1 \\le a \\le 10, 1 \\le b \\le 10\\}$。\n- 区域 2：$R_2 = \\{(a,b) \\in \\mathbb{Z}^+ \\times \\mathbb{Z}^+ \\mid 1 \\le a \\le 10, 10  b \\le \\lfloor 100/a \\rfloor\\}$。\n- 区域 3：$R_3 = \\{(a,b) \\in \\mathbb{Z}^+ \\times \\mathbb{Z}^+ \\mid 10  a \\le \\lfloor 100/b \\rfloor, 1 \\le b \\le 10\\}$。\n\n我们现在计算由该分解产生的三个和。由于对所有 $a,b$ 都有 $f(a)=g(b)=1$，因此一个区域上的和就是该区域内的整格点数。\n\n区域 1 的和：\n$R_1$ 中的点数是 $10 \\times 10$ 正方形的大小：\n$$ \\text{Sum}_1 = \\sum_{a=1}^{10} \\sum_{b=1}^{10} 1 = 10 \\times 10 = 100 $$\n\n区域 2 的和：\n$R_2$ 中的点数为：\n$$ \\text{Sum}_2 = \\sum_{a=1}^{10} \\sum_{b=11}^{\\lfloor 100/a \\rfloor} 1 = \\sum_{a=1}^{10} \\max(0, \\lfloor 100/a \\rfloor - 10) $$\n仅当 $a  10$ 时，该项非零。\n$a=1: \\lfloor 100/1 \\rfloor - 10 = 100 - 10 = 90$\n$a=2: \\lfloor 100/2 \\rfloor - 10 = 50 - 10 = 40$\n$a=3: \\lfloor 100/3 \\rfloor - 10 = 33 - 10 = 23$\n$a=4: \\lfloor 100/4 \\rfloor - 10 = 25 - 10 = 15$\n$a=5: \\lfloor 100/5 \\rfloor - 10 = 20 - 10 = 10$\n$a=6: \\lfloor 100/6 \\rfloor - 10 = 16 - 10 = 6$\n$a=7: \\lfloor 100/7 \\rfloor - 10 = 14 - 10 = 4$\n$a=8: \\lfloor 100/8 \\rfloor - 10 = 12 - 10 = 2$\n$a=9: \\lfloor 100/9 \\rfloor - 10 = 11 - 10 = 1$\n$a=10: \\lfloor 100/10 \\rfloor - 10 = 10 - 10 = 0$\n$$ \\text{Sum}_2 = 90 + 40 + 23 + 15 + 10 + 6 + 4 + 2 + 1 + 0 = 191 $$\n\n区域 3 的和：\n$R_3$ 中的点数为：\n$$ \\text{Sum}_3 = \\sum_{b=1}^{10} \\sum_{a=11}^{\\lfloor 100/b \\rfloor} 1 = \\sum_{b=1}^{10} \\max(0, \\lfloor 100/b \\rfloor - 10) $$\n根据与 $\\text{Sum}_2$ 计算的对称性，我们有：\n$$ \\text{Sum}_3 = 191 $$\n\n最后，我们数值上验证该分解得出了原和式的精确值。总和是三个不相交区域的计数之和：\n$$ \\sum_{n=1}^{100} \\tau(n) = \\text{Sum}_1 + \\text{Sum}_2 + \\text{Sum}_3 = 100 + 191 + 191 = 482 $$\n分割求和区域的方法是一个精确的计数过程。因此，数值计算证实了这三部分的值之和正确地给出了总和。最终值是这个精确计算的结果。", "answer": "$$\\boxed{482}$$", "id": "3090772"}, {"introduction": "双曲线法的巧妙之处在于它使用容斥原理来避免重复计数。本练习聚焦于一个关键的边界情况：当 $x$ 是一个完全平方数时，位于对角线 $a=b$ 上的单个格点。通过仔细追踪这个单点是如何被计数然后被修正的[@problem_id:3090733]，你将更深刻地体会到重叠校正项的精确性。", "problem": "设 $d(n)$ 表示正整数 $n$ 的正因数个数。对于一个实参数 $x \\geq 1$，考虑除数求和函数 $\\sum_{n \\leq x} d(n)$，并回顾其基于格点计数的重新解释：$\\sum_{n \\leq x} d(n)$ 等于满足 $ab \\leq x$ 的数对 $(a,b) \\in \\mathbb{N}^{2}$ 的个数。假设 $x$ 是一个完全平方数，因此 $\\sqrt{x} \\in \\mathbb{N}$。\n\n仅使用 $d(n)$ 的基本定义和上述计数解释，将满足 $ab \\leq x$ 的数对 $(a,b)$ 集合相对于对角线 $a=b$ 划分为两个对称部分，方法是首先计算满足 $a \\leq \\sqrt{x}$ 的数对，然后计算满足 $b \\leq \\sqrt{x}$ 的数对，并修正任何重叠以避免重复计数。关注可行区域角上的唯一对角线点，即 $(a,b) = (\\sqrt{x}, \\sqrt{x})$。\n\n在进行对称划分和重叠修正后，确定仅由对角线角点 $(\\sqrt{x}, \\sqrt{x})$ 对 $\\sum_{n \\leq x} d(n)$ 产生的精确净贡献。你的答案应为一个数字。", "solution": "问题要求，在 $x$ 是一个完全平方数的条件下，使用一种特定的计数方法计算除数求和函数 $\\sum_{n \\leq x} d(n)$ 时，特定格点 $(\\sqrt{x}, \\sqrt{x})$ 的净贡献。\n\n设除数求和函数表示为 $S(x) = \\sum_{n \\leq x} d(n)$。函数 $d(n)$ 是 $n$ 的正因数个数。一个基本性质是 $d(n) = \\sum_{ab=n, a,b \\in \\mathbb{N}} 1$。因此，该求和函数可以表示为平面内格点的计数：\n$$ S(x) = \\sum_{n=1}^{\\lfloor x \\rfloor} \\sum_{ab=n} 1 = \\sum_{\\substack{a,b \\in \\mathbb{N} \\\\ ab \\leq x}} 1 $$\n这意味着 $S(x)$ 是乘积小于或等于 $x$ 的正整数对 $(a,b)$ 的个数。这些数对对应于第一象限中位于双曲线 $ab=x$ 上或其下方的格点。\n\n问题指定了一种计算这些点的特定方法，这是容斥原理的一个典型应用，通常被称为 Dirichlet 双曲线法。设 $y = \\sqrt{x}$。因为 $x$ 是一个完全平方数，所以 $y$ 是一个正整数。\n所有待计数的点的集合是 $P = \\{(a,b) \\in \\mathbb{N}^2 \\mid ab \\leq x\\}$。对于 $P$ 中的任意一点 $(a,b)$，不可能同时有 $a  y$ 和 $b  y$，因为这将意味着 $ab  y \\cdot y = x$，与条件 $ab \\leq x$ 矛盾。因此，对于 $P$ 中的任意一点，必须有 $a \\leq y$ 或 $b \\leq y$（或两者都成立）。\n\n遵循问题的指示，我们定义两个集合：\n1. 满足 $a \\leq y$ 的数对集合：设其为 $P_1 = \\{(a,b) \\in \\mathbb{N}^2 \\mid ab \\leq x \\text{ and } a \\leq y\\}$。\n2. 满足 $b \\leq y$ 的数对集合：设其为 $P_2 = \\{(a,b) \\in \\mathbb{N}^2 \\mid ab \\leq x \\text{ and } b \\leq y\\}$。\n\n总的点集是这两个集合的并集，$P = P_1 \\cup P_2$。所述的计数方法是先将 $P_1$ 和 $P_2$ 的大小相加，然后减去它们交集的大小，以修正重复计数。\n$$ S(x) = |P| = |P_1 \\cup P_2| = |P_1| + |P_2| - |P_1 \\cap P_2| $$\n问题要求的是特定点 $p_0 = (y,y) = (\\sqrt{x}, \\sqrt{x})$ 对此计算的“净贡献”。净贡献取决于这个特定点在公式的每一项中被计数的次数。这可以用指示函数 $\\chi_{p_0}(A)$ 来形式化，如果 $p_0 \\in A$，则其值为 $1$，否则为 $0$。净贡献为 $\\chi_{p_0}(P_1) + \\chi_{p_0}(P_2) - \\chi_{p_0}(P_1 \\cap P_2)$。\n\n我们现在检查点 $p_0 = (y,y)$ 是否属于这些集合中的每一个。\n1.  **对 $|P_1|$ 的贡献**：\n    如果点 $p_0$ 满足条件 $ab \\leq x$ 和 $a \\leq y$，则它在 $P_1$ 中。对于 $p_0=(y,y)$，我们有 $a=y$ 和 $b=y$。\n    - 第一个条件是 $ab = y \\cdot y = y^2 = x$。因此，$ab \\leq x$ 得到满足。\n    - 第二个条件是 $a=y$。因此，$a \\leq y$ 得到满足。\n    由于两个条件都满足，点 $p_0$ 在集合 $P_1$ 中。它对计数 $|P_1|$ 的贡献是 $1$。因此，$\\chi_{p_0}(P_1) = 1$。\n\n2.  **对 $|P_2|$ 的贡献**：\n    如果点 $p_0$ 满足条件 $ab \\leq x$ 和 $b \\leq y$，则它在 $P_2$ 中。对于 $p_0=(y,y)$，我们有 $a=y$ 和 $b=y$。\n    - 第一个条件 $ab \\leq x$ 如上所示得到满足。\n    - 第二个条件是 $b=y$。因此，$b \\leq y$ 得到满足。\n    由于两个条件都满足，点 $p_0$ 在集合 $P_2$ 中。它对计数 $|P_2|$ 的贡献是 $1$。因此，$\\chi_{p_0}(P_2) = 1$。\n\n3.  **对 $|P_1 \\cap P_2|$ 的贡献（重叠修正）**：\n    集合 $P_1 \\cap P_2$ 由满足所有三个条件：$ab \\leq x$，$a \\leq y$ 和 $b \\leq y$ 的点 $(a,b)$ 组成。减去 $|P_1 \\cap P_2|$ 的目的是移除在 $|P_1|$ 和 $|P_2|$ 中都被计数的点。\n    我们检查 $p_0=(y,y)$ 是否属于这个交集。\n    - 如上所述，$p_0$ 满足 $ab \\leq x$。\n    - 如上所述，$p_0$ 满足 $a \\leq y$。\n    - 如上所述，$p_0$ 满足 $b \\leq y$。\n    由于 $p_0$ 同时在 $P_1$ 和 $P_2$ 中，根据定义，它也在它们的交集 $P_1 \\cap P_2$ 中。它对计数 $|P_1 \\cap P_2|$ 的贡献是 $1$。因此，$\\chi_{p_0}(P_1 \\cap P_2) = 1$。\n\n最后，在划分和重叠修正之后，点 $p_0 = (\\sqrt{x}, \\sqrt{x})$ 对总和 $S(x)$ 的净贡献是其各项贡献的代数和，符号如下：\n$$ \\text{净贡献} = \\chi_{p_0}(P_1) + \\chi_{p_0}(P_2) - \\chi_{p_0}(P_1 \\cap P_2) = 1 + 1 - 1 = 1 $$\n这个结果与该方法的目标一致，即每个有效格点都只被计数一次。点 $(\\sqrt{x}, \\sqrt{x})$ 对应于整数 $x$ 的唯一一个因子相等的因数对。容斥过程在最终的总和中正确地将此点计数了一次。", "answer": "$$\n\\boxed{1}\n$$", "id": "3090733"}, {"introduction": "数论不仅为抽象证明提供了强大的工具，也为创建高效算法提供了基础。最后的练习将挑战你将双曲线法背后的洞察力转化为一种实用的计算策略。通过发现在和式 $\\sum \\lfloor x/k \\rfloor$ 中如何对项进行分组，你将实现一个以 $O(\\sqrt{x})$ 时间计算除数函数求和的算法[@problem_id:3090756]，这比朴素的 $O(x)$ 方法有了显著的改进。", "problem": "您需要推导、实现并分析一种基于狄利克雷双曲线法的算法，用以计算除数函数求和。设 $d(n)$ 表示整数 $n$ 的正因数个数。对于任意整数 $x \\ge 0$，定义求和函数 $D(x)$ 如下：\n$$\nD(x) = \\sum_{n \\le x} d(n),\n$$\n仅从 $d(n)$ 计算 $n$ 的正因数个数这一定义，以及计算因数对等价于计算满足 $ab \\le x$ 的格点 $(a,b)$ 个数这一恒等式出发，推导出一个通过对具有相同底函数 $\\left\\lfloor \\frac{x}{n} \\right\\rfloor$ 值的索引 $n$ 进行分组，从而在 $O(\\sqrt{x})$ 时间内计算 $D(x)$ 的算法。应使用分组策略来避免遍历所有 $n \\le x$，并应利用 $\\left\\lfloor \\frac{x}{n} \\right\\rfloor$ 在 $n$ 的连续区间内取值相同的特性。\n\n您的程序必须为固定的测试套件实现此算法，并以指定格式输出结果。测试套件包含以下 $x$ 的整数值：\n- $x = 0$ (边界情况),\n- $x = 1$ (最小非平凡情况),\n- $x = 2$ (非常小的情况),\n- $x = 10$ (小情况),\n- $x = 100$ (中等情况),\n- $x = 999999$ (接近某个整数阈值的大情况),\n- $x = 1000000$ (位于某个整数阈值的大情况)。\n\n对于测试套件中的每个 $x$，您的程序必须计算 $D(x)$ 的整数值。您的程序应生成单行输出，其中包含一个逗号分隔的列表，用方括号括起，顺序与测试套件相同（例如，如果结果为 $r_1, r_2, \\ldots, r_7$，则输出必须为精确格式 $[r_1,r_2,r_3,r_4,r_5,r_6,r_7]$）。\n\n本问题不涉及物理单位或角度。所有量均为纯整数。请确保您的算法通过对具有相同 $\\left\\lfloor \\frac{x}{n} \\right\\rfloor$ 值的索引进行分组，达到 $O(\\sqrt{x})$ 的时间复杂度。", "solution": "目标是推导并实现一个在 $O(\\sqrt{x})$ 时间内计算除数函数求和 $D(x) = \\sum_{n \\le x} d(n)$ 的算法，其中 $d(n)$ 是 $n$ 的正因数个数。推导将遵循狄利克雷双曲线法的原理，并利用指定的分组索引优化方法。\n\n首先，我们将 $D(x)$ 表示为一种更易于处理的形式。除数函数的定义是 $d(n) = \\sum_{k|n, k0} 1$。将此定义代入整数 $x \\ge 0$ 的 $D(x)$ 定义中，得到：\n$$\nD(x) = \\sum_{n=1}^{\\lfloor x \\rfloor} d(n) = \\sum_{n=1}^{\\lfloor x \\rfloor} \\sum_{k|n} 1\n$$\n这个双重求和计算的是满足 $k$ 整除 $n$ 且 $n \\le x$ 的正整数对 $(n, k)$ 的数量。条件 $k|n$ 意味着对于某个正整数 $m$，有 $n = km$。因此，条件 $n \\le x$ 变为 $km \\le x$。这使我们可以对乘积 $km \\le x$ 的正整数对 $(k,m)$ 进行重新索引求和：\n$$\nD(x) = \\sum_{k,m \\in \\mathbb{Z}^+; km \\le x} 1\n$$\n在几何上，这个和表示第一象限中位于双曲线 $km = x$ 上或其下方的整格点 $(k,m)$ 的数量。\n\n为了计算这个和，我们可以遍历一个变量，例如 $k$，对于每个 $k$，累加 $m$ 的有效计数值。变量 $k$ 的取值范围可以从 $1$ 到 $\\lfloor x \\rfloor$。对于一个固定的 $k$，条件 $km \\le x$ 等价于 $m \\le \\frac{x}{k}$。由于 $m$ 必须是整数，所以 $m$ 的可能取值个数为 $\\lfloor \\frac{x}{k} \\rfloor$。这导出了以下关于 $D(x)$ 的恒等式：\n$$\nD(x) = \\sum_{k=1}^{\\lfloor x \\rfloor} \\left\\lfloor \\frac{x}{k} \\right\\rfloor\n$$\n计算这个和的朴素算法将从 $1$ 迭代 $k$ 到 $\\lfloor x \\rfloor$，其时间复杂度为 $O(x)$。对于大的 $x$，这是低效的。\n\n问题要求一个通过分组索引实现的 $O(\\sqrt{x})$ 算法。我们观察到 $\\lfloor \\frac{x}{k} \\rfloor$ 这一项是关于 $k$ 的一个非递增阶梯函数。对于许多连续的 $k$ 值，它都取相同的值。我们可以利用这一点，将具有相同 $\\lfloor \\frac{x}{k} \\rfloor$ 值的项分组，并一步计算它们对总和的贡献。\n\n让我们将此分组策略形式化。我们遍历索引块。假设一个块从索引 $k$ 开始。此块的底函数值为 $v = \\lfloor \\frac{x}{k} \\rfloor$。我们需要找到最大的索引 $k_{end}$，使得对于所有满足 $k \\le i \\le k_{end}$ 的整数 $i$，都有 $\\lfloor \\frac{x}{i} \\rfloor = v$。\n\n条件 $\\lfloor \\frac{x}{i} \\rfloor = v$ 等价于不等式 $v \\le \\frac{x}{i}  v+1$。\n不等式的左半部分，$v \\le \\frac{x}{i}$，意味着 $i \\le \\frac{x}{v}$。由于 $i$ 必须是整数，所以 $i \\le \\lfloor \\frac{x}{v} \\rfloor$。\n右半部分，$\\frac{x}{i}  v+1$，意味着 $i > \\frac{x}{v+1}$。\n对于任何 $i \\ge k$，我们有 $\\frac{x}{i} \\le \\frac{x}{k}$，所以 $\\lfloor \\frac{x}{i} \\rfloor \\le \\lfloor \\frac{x}{k} \\rfloor = v$。因此，我们只需要找到满足 $v \\le \\lfloor \\frac{x}{i} \\rfloor$ 的最大 $i$。这发生在 $i = \\lfloor \\frac{x}{v} \\rfloor$ 时。\n因此，对于一个起始索引 $k$，使得 $\\lfloor \\frac{x}{i} \\rfloor$ 保持在常数 $v = \\lfloor \\frac{x}{k} \\rfloor$ 的索引块是 $[k, k_{end}]$，其中 $k_{end} = \\lfloor \\frac{x}{v} \\rfloor = \\lfloor \\frac{x}{\\lfloor x/k \\rfloor} \\rfloor$。\n\n这个块中的项数为 $(k_{end} - k + 1)$。整个块对总和的贡献是 $(k_{end} - k + 1) \\times v$。处理完这个块后，下一个要考虑的索引是 $k_{end} + 1$。\n\n算法如下：\n1. 初始化总和 $S = 0$ 和起始索引 $k = 1$。\n2. 当 $k \\le x$ 时：\n   a. 如果 $k > x$，则终止。对于整数 $x$，这等价于 $k > \\lfloor x \\rfloor$。\n   b. 计算值 $v = \\lfloor \\frac{x}{k} \\rfloor$。如果 $v=0$，则所有后续项都为 $0$，因此可以终止。\n   c. 确定当前块的结束位置，$k_{end} = \\lfloor \\frac{x}{v} \\rfloor$。\n   d. 将此块的贡献加到总和中：$S \\leftarrow S + (k_{end} - k + 1) \\times v$。\n   e. 将索引更新到下一个块的开始：$k \\leftarrow k_{end} + 1$。\n3. 最终结果是 $D(x) = S$。\n\n为了分析复杂度，我们计算迭代次数。循环以跳跃的方式推进 $k$。对于 $k=1, \\dots, \\lfloor x \\rfloor$，$\\lfloor \\frac{x}{k} \\rfloor$ 的唯一值的数量决定了迭代次数。\n- 对于 $k \\in [1, \\lfloor\\sqrt{x}\\rfloor]$，最多有 $\\lfloor\\sqrt{x}\\rfloor$ 个不同的 $k$ 值，因此最多有 $\\lfloor\\sqrt{x}\\rfloor$ 个不同的 $\\lfloor\\frac{x}{k}\\rfloor$ 值。\n- 对于 $k \\in (\\lfloor\\sqrt{x}\\rfloor, \\lfloor x \\rfloor]$，我们有 $k > \\sqrt{x}$，这意味着 $\\frac{x}{k}  \\sqrt{x}$。所以，值 $v = \\lfloor \\frac{x}{k} \\rfloor$ 是在 $[1, \\lfloor\\sqrt{x}\\rfloor - 1]$ 范围内的整数。在此范围内最多有 $\\lfloor\\sqrt{x}\\rfloor - 1$ 个不同的值。\n$\\lfloor \\frac{x}{k} \\rfloor$ 的不同值的总数，也就是循环迭代的次数，其上界为 $2\\lfloor\\sqrt{x}\\rfloor$。每次迭代涉及几次算术运算，耗时为常数时间。因此，该算法的总体时间复杂度为 $O(\\sqrt{x})$。这满足了问题的要求。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef divisor_summatory_function(x: int) - int:\n    \"\"\"\n    Computes the summatory divisor function D(x) = sum_{n = x} d(n)\n    using the Dirichlet hyperbola method optimized with index grouping.\n\n    The identity D(x) = sum_{k=1}^{x} floor(x/k) is used. The sum is\n    computed in O(sqrt(x)) time by grouping terms where floor(x/k)\n    is constant.\n\n    Args:\n        x: A non-negative integer.\n\n    Returns:\n        The integer value of D(x).\n    \"\"\"\n    if x  1:\n        return 0\n\n    # According to the problem statement, all quantities are integers.\n    # Python's integers support arbitrary precision, so overflow is not a concern\n    # for the given test cases.\n    x = int(x)\n\n    total_sum = 0\n    k = 1\n    while k = x:\n        # v is the value of floor(x/k) for the current block of indices.\n        v = x // k\n\n        # k_end is the last index for which floor(x/i) has the value v.\n        # k_end = floor(x / v)\n        k_end = x // v\n\n        # The number of indices in the block [k, k_end] is (k_end - k + 1).\n        # Add the contribution of this block to the total sum.\n        num_terms = k_end - k + 1\n        total_sum += num_terms * v\n\n        # Jump to the start of the next block.\n        k = k_end + 1\n\n    return total_sum\n\ndef solve():\n    \"\"\"\n    Runs the calculation for the test suite specified in the problem statement\n    and prints the results in the required format.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        0,          # boundary case\n        1,          # smallest nontrivial case\n        2,          # very small case\n        10,         # small case\n        100,        # moderate case\n        999999,     # large case just below a round threshold\n        1000000     # large case at a round threshold\n    ]\n\n    results = []\n    for x_val in test_cases:\n        result = divisor_summatory_function(x_val)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3090756"}]}