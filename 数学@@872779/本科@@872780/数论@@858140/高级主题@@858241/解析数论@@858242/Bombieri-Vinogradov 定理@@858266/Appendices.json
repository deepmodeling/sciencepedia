{"hands_on_practices": [{"introduction": "邦别里-维诺格拉多夫定理的核心是关于切比雪夫函数 $\\psi(x;q,a)$ 在算术级数中的分布。在我们深入探讨这个深刻的定理之前，通过亲手计算来建立对这个函数具体构成的直观理解是至关重要的。这项练习 [@problem_id:3090386] 提供了一个绝佳的机会，让您为一个具体的模数直接计算 $\\psi(x;q,a)$ 的值，从而揭示其如何由质数及其高次幂的对数贡献构成，为理解更抽象的结论打下坚实的基础。", "problem": "设 $\\Lambda(n)$ 表示 von Mangoldt 函数，对于整数 $q \\geq 1$ 和 $(a,q)=1$，定义等差数列 Chebyshev 函数\n$$\n\\psi(x;q,a) \\;=\\; \\sum_{\\substack{n \\leq x \\\\ n \\equiv a \\,(\\mathrm{mod}\\, q)}} \\Lambda(n).\n$$\n设 $\\chi$ 是一个模4的 Dirichlet 特征，定义\n$$\n\\psi(x,\\chi) \\;=\\; \\sum_{n \\leq x} \\Lambda(n)\\,\\chi(n).\n$$\n你可以使用模4的 Dirichlet 特征的正交性，将 $\\psi(x;4,a)$ 写成关于模4的特征 $\\chi$ 的 $\\psi(x,\\chi)$ 的线性组合。处理模4的两个特征：主特征 $\\chi_{0}$ 和非主特征 $\\chi_{4}$，其中对于偶数 $n$，$\\chi_{4}(n)=0$，$\\chi_{4}(1)=1$，以及 $\\chi_{4}(3)=-1$。\n\n从这些定义和根据模4的余数对素数幂进行分类出发，推导 $\\psi(1000;4,1)$ 和 $\\psi(1000;4,3)$ 的显式闭式表达式。表达式应以素数自然对数的有限和形式给出，并通过计算所有来自素数幂 $p^{k} \\leq 1000$ 的重数来进行最大程度的简化。特别地，定义\n$$\n\\vartheta(x;4,a) \\;=\\; \\sum_{\\substack{p \\leq x \\\\ p \\equiv a \\,(\\mathrm{mod}\\, 4)}} \\ln p\n$$\n来表示一次幂（素数）的贡献，并在你的最终答案中分离出 $\\vartheta(1000;4,1)$ 和 $\\vartheta(1000;4,3)$，再加上来自更高次素数幂的显式有限修正项。\n\n然后，简要解释你的结果如何阐释 Bombieri-Vinogradov 定理（B-V）所启示的直观思想，即对于 $a \\in \\{1,3\\}$，$\\psi(x;4,a)$ 应该接近 $x/\\varphi(4)$，其中 $\\varphi$ 表示欧拉总计函数。无需数值近似。以 $\\big[\\psi(1000;4,1)\\;\\;\\psi(1000;4,3)\\big]$ 两个条目的形式返回你的最终结果。你的最终答案必须是一个没有单位的单一闭式解析表达式。", "solution": "问题要求给出 $\\psi(1000;4,1)$ 和 $\\psi(1000;4,3)$ 的显式闭式表达式，并定性解释这些结果如何与 Bombieri-Vinogradov 定理相关。\n\n首先，我们验证问题的有效性。\n\n### 步骤 1：提取已知条件\n- $\\Lambda(n)$: von Mangoldt 函数。\n- $\\psi(x;q,a) = \\sum_{n \\leq x, n \\equiv a \\,(\\mathrm{mod}\\, q)} \\Lambda(n)$，其中 $q \\geq 1$ 为整数且 $(a,q)=1$。\n- $\\psi(x,\\chi) = \\sum_{n \\leq x} \\Lambda(n)\\,\\chi(n)$，其中 $\\chi$ 为 Dirichlet 特征。\n- 问题涉及模 $q=4$ 以及特征 $\\chi_0$（主特征）和 $\\chi_4$（非主特征，$\\chi_4(1)=1$，$\\chi_4(3)=-1$）。\n- 建议使用特征正交性将 $\\psi(x;4,a)$ 表示为 $\\psi(x,\\chi)$ 的线性组合。\n- 任务是推导 $\\psi(1000;4,1)$ 和 $\\psi(1000;4,3)$ 的显式表达式。\n- $\\vartheta(x;4,a) = \\sum_{p \\leq x, p \\equiv a \\,(\\mathrm{mod}\\, 4)} \\ln p$。$\\psi$ 的最终表达式应分离出这些 $\\vartheta$ 项。\n- 任务还包括简要解释结果与 Bombieri-Vinogradov 定理的启发式思想（即 $\\psi(x;4,a) \\approx x/\\varphi(4)$）的联系。\n\n### 步骤 2：使用提取的已知条件进行验证\n该问题在标准解析数论中有坚实的科学基础。所有定义（$\\Lambda(n)$、$\\psi(x;q,a)$、Dirichlet 特征）都是标准的。任务设定清晰、客观且自洽，要求推导特定的数学表达式。它没有违反任何基本原则，没有歧义，是该领域一个标准的、不平凡的计算。\n\n### 步骤 3：结论与行动\n问题是有效的。我们开始解题。\n\n函数 $\\psi(x;q,a)$ 定义为 von Mangoldt 函数 $\\Lambda(n)$ 在一个等差数列上的和。von Mangoldt 函数定义为：如果 $n = p^k$（其中 $p$ 是素数，整数 $k \\geq 1$），则 $\\Lambda(n) = \\ln p$；否则 $\\Lambda(n) = 0$。\n我们关心 $q=4$ 和 $a \\in \\{1, 3\\}$ 的情况。我们需要计算：\n$$\n\\psi(x;4,a) = \\sum_{\\substack{p^k \\leq x \\\\ p^k \\equiv a \\,(\\mathrm{mod}\\, 4)}} \\ln p\n$$\n对于 $x=1000$。问题要求将来自素数（$k=1$）的贡献与来自更高次素数幂（$k \\ge 2$）的贡献分开。素数的贡献由函数 $\\vartheta(x;4,a)$ 给出。因此我们写出：\n$$\n\\psi(x;4,a) = \\vartheta(x;4,a) + \\sum_{\\substack{p^k \\leq x, k \\geq 2 \\\\ p^k \\equiv a \\,(\\mathrm{mod}\\, 4)}} \\ln p\n$$\n\n我们必须根据素数幂 $p^k$ 模4的余数对其进行分类。素数 $p=2$ 的幂为 $2^1=2$，$2^2=4 \\equiv 0$，且对于 $k \\ge 2$，$2^k \\equiv 0 \\pmod 4$。由于 $a \\in \\{1, 3\\}$，2的幂对求和没有贡献。我们只需要考虑奇素数 $p$。\n- 如果 $p \\equiv 1 \\pmod 4$，那么对于所有 $k \\geq 1$，$p^k \\equiv 1^k \\equiv 1 \\pmod 4$。\n- 如果 $p \\equiv 3 \\pmod 4$，那么 $p^k \\equiv (-1)^k \\pmod 4$。因此，如果 $k$ 是偶数，$p^k \\equiv 1 \\pmod 4$；如果 $k$ 是奇数，$p^k \\equiv 3 \\pmod 4$。\n\n#### $\\psi(1000;4,1)$ 的计算\n我们需要对所有满足 $p^k \\leq 1000$ 且 $p^k \\equiv 1 \\pmod 4$ 的 $p$ 求和 $\\ln p$。\n$$\n\\psi(1000;4,1) = \\sum_{\\substack{p \\leq 1000 \\\\ p \\equiv 1 \\,(\\mathrm{mod}\\, 4)}} \\ln p + \\sum_{\\substack{p^k \\leq 1000, k \\geq 2 \\\\ p^k \\equiv 1 \\,(\\mathrm{mod}\\, 4)}} \\ln p\n$$\n第一项是 $\\vartheta(1000;4,1)$。第二项是来自更高次幂的修正。我们通过对素数 $p$ 求和来计算这个修正。我们只需要检查满足 $p^2 \\leq 1000$ 的素数 $p$，即 $p \\leq \\sqrt{1000} \\approx 31.6$。\n\n1. 对于素数 $p \\equiv 1 \\pmod 4$（例如 $5, 13, 17, 29, \\dots$）：对于所有 $k \\geq 2$，$p^k \\equiv 1 \\pmod 4$。\n    -   $p=5$：$5^2=25$, $5^3=125$, $5^4=625$。$5^5=3125  1000$。幂次 $k=2,3,4$ 有贡献。总计：$3\\ln 5$。\n    -   $p=13$：$13^2=169$。$13^3=2197  1000$。幂次 $k=2$ 有贡献。总计：$\\ln 13$。\n    -   $p=17$：$17^2=289$。$17^3=4913  1000$。幂次 $k=2$ 有贡献。总计：$\\ln 17$。\n    -   $p=29$：$29^2=841$。$29^3  1000$。幂次 $k=2$ 有贡献。总计：$\\ln 29$。\n    -   下一个满足 $p \\equiv 1 \\pmod 4$ 的素数是 $37$，而 $37^2  1000$。\n\n2. 对于素数 $p \\equiv 3 \\pmod 4$（例如 $3, 7, 11, 19, \\dots$）：仅当 $k \\geq 2$ 为偶数时，$p^k \\equiv 1 \\pmod 4$。\n    -   $p=3$：我们需要偶数幂。$3^2=9$, $3^4=81$, $3^6=729$。$3^8  1000$。幂次 $k=2,4,6$ 有贡献。总计：$3\\ln 3$。\n    -   $p=7$：$7^2=49$。$7^4=2401  1000$。幂次 $k=2$ 有贡献。总计：$\\ln 7$。\n    -   $p=11$：$11^2=121$。$11^4  1000$。幂次 $k=2$ 有贡献。总计：$\\ln 11$。\n    -   $p=19$：$19^2=361$。$19^4  1000$。幂次 $k=2$ 有贡献。总计：$\\ln 19$。\n    -   $p=23$：$23^2=529$。$23^4  1000$。幂次 $k=2$ 有贡献。总计：$\\ln 23$。\n    -   $p=31$：$31^2=961$。$31^4  1000$。幂次 $k=2$ 有贡献。总计：$\\ln 31$。\n    -   下一个满足 $p \\equiv 3 \\pmod 4$ 的素数是43，而 $43^21000$。\n\n总结所有这些来自更高次幂的贡献：\n$C_1 = 3\\ln 3 + 3\\ln 5 + \\ln 7 + \\ln 11 + \\ln 13 + \\ln 17 + \\ln 19 + \\ln 23 + \\ln 29 + \\ln 31$。\n因此，$\\psi(1000;4,1)$ 的表达式为：\n$$\n\\psi(1000;4,1) = \\vartheta(1000;4,1) + 3\\ln 3 + 3\\ln 5 + \\ln 7 + \\ln 11 + \\ln 13 + \\ln 17 + \\ln 19 + \\ln 23 + \\ln 29 + \\ln 31\n$$\n\n#### $\\psi(1000;4,3)$ 的计算\n我们需要对所有满足 $p^k \\leq 1000$ 且 $p^k \\equiv 3 \\pmod 4$ 的 $p$ 求和 $\\ln p$。这要求 $p \\equiv 3 \\pmod 4$ 且 $k$ 为奇数。\n$$\n\\psi(1000;4,3) = \\sum_{\\substack{p^k \\leq 1000 \\\\ p \\equiv 3 \\,(\\mathrm{mod}\\, 4) \\\\ k \\text{ is odd}}} \\ln p = \\vartheta(1000;4,3) + \\sum_{\\substack{p^k \\leq 1000, k \\geq 3, k \\text{ odd} \\\\ p \\equiv 3 \\,(\\mathrm{mod}\\, 4)}} \\ln p\n$$\n第一项是 $k=1$ 的情况。我们计算来自更高奇次幂（$k=3, 5, \\dots$）的修正。\n-   $k=3$：要求 $p^3 \\leq 1000$ 且 $p \\equiv 3 \\pmod 4$。这意味着 $p \\leq \\sqrt[3]{1000}=10$。满足条件的素数是 $p=3$ 和 $p=7$。贡献为：$\\ln 3 + \\ln 7$。\n-   $k=5$：要求 $p^5 \\leq 1000$ 且 $p \\equiv 3 \\pmod 4$。这意味着 $p \\leq \\sqrt[5]{1000} \\approx 3.98$。唯一的素数是 $p=3$。贡献为：$\\ln 3$。\n-   $k=7$：要求 $p^7 \\leq 1000$ 且 $p \\equiv 3 \\pmod 4$。这意味着 $p \\leq \\sqrt[7]{1000} \\approx 2.8$。没有奇素数满足此条件。\n\n来自更高次幂的总修正是 $C_3 = (\\ln 3 + \\ln 7) + \\ln 3 = 2\\ln 3 + \\ln 7$。\n因此，$\\psi(1000;4,3)$ 的表达式为：\n$$\n\\psi(1000;4,3) = \\vartheta(1000;4,3) + 2\\ln 3 + \\ln 7\n$$\n\n#### 与 Bombieri-Vinogradov 定理的联系\nBombieri-Vinogradov 定理给出了关于等差数列素数定理中误差项平均大小的一个强有力的陈述。相关的直观思想是，对于固定的模 $q$ 和 $(a,q)=1$，$\\psi(x;q,a)$ 可以很好地被其期望值 $x/\\varphi(q)$ 近似。在我们的例子中，$x=1000$，$q=4$，因此 $\\varphi(4)=2$。该直观思想表明 $\\psi(1000;4,1) \\approx 1000/2 = 500$ 和 $\\psi(1000;4,3) \\approx 1000/2 = 500$。\n\n我们推导出的表达式通过 Dirichlet 特征理论阐释了这一点。利用特征的正交性，可以证明：\n$$\n\\psi(x;4,1) = \\frac{1}{2}\\left(\\psi(x,\\chi_0) + \\psi(x,\\chi_4)\\right)\n$$\n$$\n\\psi(x;4,3) = \\frac{1}{2}\\left(\\psi(x,\\chi_0) - \\psi(x,\\chi_4)\\right)\n$$\n此处，$\\psi(x,\\chi_0) = \\sum_{n \\leq x, (n,4)=1} \\Lambda(n) = \\psi(x) - \\sum_{k \\geq 1, 2^k \\leq x} \\ln 2$。素数定理意味着 $\\psi(x) \\sim x$，因此 $\\psi(x,\\chi_0) \\sim x$。这是主导项。\n项 $\\psi(x,\\chi_4) = \\sum_{n \\leq x} \\Lambda(n)\\chi_4(n)$ 涉及到非主特征 $\\chi_4$。解析数论的一个基石性结果是，对于任何非主特征 $\\chi$，都有 $\\psi(x,\\chi) = o(x)$。这意味着 $\\psi(x,\\chi_4)$ 的增长速度慢于 $x$。\n\n将这些渐近行为代入 $\\psi(x;4,a)$ 的表达式中：\n$$\n\\psi(x;4,1) \\approx \\frac{1}{2}(x + o(x)) \\approx \\frac{x}{2}\n$$\n$$\n\\psi(x;4,3) \\approx \\frac{1}{2}(x - o(x)) \\approx \\frac{x}{2}\n$$\n这两个量渐近地等于 $x/2 = x/\\varphi(4)$，这正是 Bombieri-Vinogradov 定理所启示的直观思想。我们的详细计算显示了当 $x=1000$ 时这些函数的精确构成，其中主项 $\\vartheta(x;q,a)$ 预期具有相似的量级，而修正项则相对较小。", "answer": "$$\n\\boxed{\\begin{pmatrix} \\vartheta(1000;4,1) + 3\\ln 3 + 3\\ln 5 + \\ln 7 + \\ln 11 + \\ln 13 + \\ln 17 + \\ln 19 + \\ln 23 + \\ln 29 + \\ln 31  \\vartheta(1000;4,3) + 2\\ln 3 + \\ln 7 \\end{pmatrix}}\n$$", "id": "3090386"}, {"introduction": "虽然邦别里-维诺格拉多夫定理通常是针对加权的质数计数函数 $\\psi(x;q,a)$ 来表述的，但在数论中，我们最终往往更关心质数本身的计数函数 $\\pi(x;q,a)$。解析数论为我们提供了在这两个函数之间架设桥梁的强大工具——分部求和法（或称阿贝尔求和法）。这项练习 [@problem_id:3090431] 将引导您完成这一关键的推导过程，通过将关于 $\\psi$ 的界限成功转化为关于 $\\pi$ 的界限，您将掌握一项核心的理论技巧，并体会到邦别里-维诺格拉多夫定理的威力是如何被扩展以直接解决关于质数计数问题的。", "problem": "设 $q \\in \\mathbb{Z}_{\\ge 1}$，$a \\in \\mathbb{Z}$ 且 $(a,q)=1$，并定义等差数列计数函数\n- $\\pi(x;q,a)$ 为素数 $p \\le x$ 且 $p \\equiv a \\pmod{q}$ 的个数，\n- $\\psi(x;q,a) := \\sum_{\\substack{n \\le x \\\\ n \\equiv a \\!\\!\\!\\pmod{q}}} \\Lambda(n)$，其中 $\\Lambda(n)$ 是冯·曼戈尔特函数 (von Mangoldt function)，\n- $\\theta(x;q,a) := \\sum_{\\substack{p \\le x \\\\ p \\equiv a \\!\\!\\!\\pmod{q}}} \\ln p$，\n以及主项\n- $\\varphi(q)$ 是欧拉函数 (Euler’s totient function)，\n- $\\operatorname{li}(x) := \\int_{2}^{x} \\frac{dt}{\\ln t}$ 是对数积分 (logarithmic integral)。\n\n假设以下平均形式的邦别里-维诺格拉多夫型假设成立：对于任意固定的 $A0$，存在常数 $B=B(A)0$，$C=C(A)0$ 和 $x_{0}=x_{0}(A)$，使得对于所有 $x \\ge x_{0}$，所有满足 $Q \\le x^{1/2}/(\\ln x)^{B}$ 的 $Q$，以及所有满足 $2 \\le t \\le x$ 的 $t$，都有\n$$\n\\sum_{q \\le Q} \\max_{\\substack{(a,q)=1}} \\left| \\psi(t;q,a) - \\frac{t}{\\varphi(q)} \\right| \\le C \\,\\frac{t}{(\\ln t)^{A}}.\n$$\n\n仅从上述假设、$\\pi(x;q,a)$、$\\psi(x;q,a)$ 和 $\\theta(x;q,a)$ 的定义以及阿贝尔（分部）求和原理 (Abel summation principle) 出发，推导一个形如下式的平均界\n$$\n\\sum_{q \\le Q} \\max_{\\substack{(a,q)=1}} \\left| \\pi(x;q,a) - \\frac{\\operatorname{li}(x)}{\\varphi(q)} \\right| \\ll \\frac{x}{(\\ln x)^{\\alpha}},\n$$\n该界对于所有 $x \\ge x_{0}(A)$ 和所有满足 $Q \\le x^{1/2}/(\\ln x)^{B'(A)}$ （对于某个 $B'(A)0$）的 $Q$ 都成立，其中隐含常数可依赖于 $A$。请以最简闭式形式，确定所得指数 $\\alpha$ 关于 $A$ 的表达式。\n\n你的最终答案必须只包含 $\\alpha$ 关于 $A$ 的表达式。不需要数值舍入，也不涉及单位。仅需将 $\\alpha$ 的值表示为关于 $A$ 的简化解析表达式。", "solution": "用户希望从关于切比雪夫函数 (Chebyshev function) $\\psi(x;q,a)$ 的平均误差的给定假设出发，为等差数列中的素数计数函数 $\\pi(x;q,a)$ 推导一个平均误差界。\n\n该问题将通过以下三个主要步骤解决：\n1.  **问题验证**：确认问题陈述是自洽的、数学上合理的且适定的。\n2.  **关联 $\\psi$ 与 $\\theta$**：证明 $\\psi(x;q,a)$ 的误差界可以转移到 $\\theta(x;q,a)$，同时考虑素数幂的贡献。\n3.  **关联 $\\theta$ 与 $\\pi$**：使用阿贝尔求和原理 (Abel's summation principle) 从为 $\\theta(x;q,a)$ 建立的误差界推导出 $\\pi(x;q,a)$ 的误差界。\n\n### 步骤 1：问题验证\n\n这是一个解析数论领域的理论推导问题。\n-   **已知条件**：$\\pi(x;q,a)$、$\\psi(x;q,a)$、$\\theta(x;q,a)$、$\\varphi(q)$ 和 $\\operatorname{li}(x)$ 的所有定义都是标准的。该假设是邦别里-维诺格拉多夫定理 (Bombieri-Vinogradov theorem) 的一个明确定义的强形式，并声明对 $t \\in [2,x]$ 一致成立。所用工具仅限于该假设、相关定义和阿贝尔求和。\n-   **科学依据**：该问题完全属于纯数学范畴，处理的是数论中的标准对象和定理。它在科学上和事实上都是合理的。\n-   **适定性**：目标是确定指数 $\\alpha$ 关于 $A$ 的表达式。从 $\\psi$ 到 $\\theta$ 再到 $\\pi$ 的推导路径是标准程序，这表明可以得到一个唯一且有意义的解。\n-   **客观性**：该问题以精确的数学语言陈述，没有歧义或主观论断。\n\n该问题被认为是**有效的**。我们可以继续求解。\n\n### 步骤 2：$\\psi(x;q,a)$ 与 $\\theta(x;q,a)$ 之间的关系\n\n切比雪夫函数 $\\psi(x;q,a)$ 定义为 $\\sum_{n \\le x, n \\equiv a \\pmod{q}} \\Lambda(n)$，其中 $\\Lambda(n)$ 是冯·曼戈尔特函数 (von Mangoldt function)。如果 $n=p^k$（其中 $p$ 是素数，$k \\ge 1$ 是整数），则函数 $\\Lambda(n) = \\ln p$，否则为 0。\n我们可以根据幂次 $k$ 将定义 $\\psi(x;q,a)$ 的和式拆分：\n$$\n\\psi(x;q,a) = \\sum_{\\substack{p \\le x \\\\ p \\equiv a \\pmod{q}}} \\ln p + \\sum_{k=2}^{\\infty} \\sum_{\\substack{p^k \\le x \\\\ p^k \\equiv a \\pmod{q}}} \\ln p\n$$\n根据定义，第一项是 $\\theta(x;q,a)$。因此，我们有以下关系：\n$$\n\\psi(x;q,a) - \\theta(x;q,a) = \\sum_{k=2}^{\\lfloor \\log_2 x \\rfloor} \\sum_{\\substack{p \\le x^{1/k} \\\\ p^k \\equiv a \\pmod{q}}} \\ln p\n$$\n我们可以通过移除同余条件来界定这个差的绝对值：\n$$\n|\\psi(x;q,a) - \\theta(x;q,a)| \\le \\sum_{k=2}^{\\lfloor \\log_2 x \\rfloor} \\sum_{p \\le x^{1/k}} \\ln p = \\sum_{k=2}^{\\lfloor \\log_2 x \\rfloor} \\theta(x^{1/k})\n$$\n使用标准界 $\\theta(y) = O(y)$，该和由 $k=2$ 项主导：\n$$\n|\\psi(x;q,a) - \\theta(x;q,a)| = \\theta(x^{1/2}) + \\theta(x^{1/3}) + \\dots = O(x^{1/2})\n$$\n设 $E_\\psi(t;q,a) = \\psi(t;q,a) - \\frac{t}{\\varphi(q)}$ 和 $E_\\theta(t;q,a) = \\theta(t;q,a) - \\frac{t}{\\varphi(q)}$。\n那么 $E_\\theta(t;q,a) = E_\\psi(t;q,a) - (\\psi(t;q,a) - \\theta(t;q,a))$。\n设 $S_\\psi(t, Q) = \\sum_{q \\le Q} \\max_{(a,q)=1} |E_\\psi(t;q,a)|$ 和 $S_\\theta(t,Q) = \\sum_{q \\le Q} \\max_{(a,q)=1} |E_\\theta(t;q,a)|$。\n使用三角不等式：\n$$\nS_\\theta(t,Q) \\le S_\\psi(t,Q) + \\sum_{q \\le Q} \\max_{(a,q)=1} |\\psi(t;q,a) - \\theta(t;q,a)|\n$$\n使用我们的逐点界 $|\\psi(t;q,a) - \\theta(t;q,a)| = O(t^{1/2})$，第二项的界为 $\\sum_{q \\le Q} O(t^{1/2}) = O(Q t^{1/2})$。\n给定假设表明，对于固定的 $A0$，存在 $B=B(A)0$，使得对于 $Q \\le x^{1/2}/(\\ln x)^B$ 和所有 $t \\in [2,x]$，$S_\\psi(t,Q) \\ll t/(\\ln t)^A$。此处及全文中，隐含常数可依赖于 $A$。\n因此，对于 $t \\in [2,x]$ 和在指定范围内的 $Q$，我们有：\n$$\nS_\\theta(t,Q) \\ll \\frac{t}{(\\ln t)^A} + Q t^{1/2}\n$$\n\n### 步骤 3：$\\theta(x;q,a)$ 与 $\\pi(x;q,a)$ 之间的关系\n\n我们使用阿贝尔求和原理 (Abel's summation principle) 来关联 $\\pi(x;q,a) = \\sum_{p\\le x, p \\equiv a} 1$ 和 $\\theta(x;q,a) = \\sum_{p\\le x, p \\equiv a} \\ln p$。\n我们可以将 $\\pi(x;q,a)$ 写作 $\\sum_{n \\le x, n \\text{ is prime}, n\\equiv a} \\frac{\\ln n}{\\ln n}$。\n对序列（项为 $\\ln n$（对于等差数列中的素数）否则为 0）和函数 $f(t)=1/\\ln t$ 应用阿贝尔求和：\n$$\n\\pi(x;q,a) = \\frac{\\theta(x;q,a)}{\\ln x} - \\int_2^x \\theta(t;q,a) \\left(\\frac{d}{dt} \\frac{1}{\\ln t}\\right) dt = \\frac{\\theta(x;q,a)}{\\ln x} + \\int_2^x \\frac{\\theta(t;q,a)}{t(\\ln t)^2} dt\n$$\n我们关心的是 $\\pi(x;q,a)$ 相对于其主项 $\\frac{\\operatorname{li}(x)}{\\varphi(q)}$ 的误差项。\n$$\n\\pi(x;q,a) - \\frac{\\operatorname{li}(x)}{\\varphi(q)} = \\frac{1}{\\ln x}\\left(\\frac{x}{\\varphi(q)} + E_\\theta(x;q,a)\\right) + \\int_2^x \\frac{t/\\varphi(q) + E_\\theta(t;q,a)}{t(\\ln t)^2} dt - \\frac{\\operatorname{li}(x)}{\\varphi(q)}\n$$\n将主项组合在一起：\n$$\n\\frac{1}{\\varphi(q)} \\left( \\frac{x}{\\ln x} + \\int_2^x \\frac{dt}{(\\ln t)^2} \\right) - \\frac{\\operatorname{li}(x)}{\\varphi(q)}\n$$\n对 $\\operatorname{li}(x)=\\int_2^x \\frac{dt}{\\ln t}$ 使用分部积分 (integration by parts) 得到 $\\operatorname{li}(x) = \\frac{x}{\\ln x} - \\frac{2}{\\ln 2} + \\int_2^x \\frac{dt}{(\\ln t)^2}$。\n因此，主项合并为 $-\\frac{2}{\\varphi(q)\\ln 2}$，这是一个 $O(1/\\varphi(q))$ 阶的项。\n因此，误差由下式给出：\n$$\n\\pi(x;q,a) - \\frac{\\operatorname{li}(x)}{\\varphi(q)} = \\frac{E_\\theta(x;q,a)}{\\ln x} + \\int_2^x \\frac{E_\\theta(t;q,a)}{t(\\ln t)^2} dt + O\\left(\\frac{1}{\\varphi(q)}\\right)\n$$\n现在，我们对 $q \\le Q$ 求和，并取关于 $a$ 的最大值：\n$$\n\\sum_{q \\le Q} \\max_{(a,q)=1} \\left| \\pi(x;q,a) - \\frac{\\operatorname{li}(x)}{\\varphi(q)} \\right| \\le \\frac{S_\\theta(x,Q)}{\\ln x} + \\int_2^x \\frac{S_\\theta(t,Q)}{t(\\ln t)^2} dt + \\sum_{q \\le Q} O\\left(\\frac{1}{q^{1-\\epsilon}}\\right)\n$$\n最后一项是 $O(Q^\\epsilon \\ln Q)$，可以忽略。我们来分析前两项。我们需要推导一个形如 $\\ll x/(\\ln x)^\\alpha$ 的界，它对 $Q \\le x^{1/2}/(\\ln x)^{B'(A)}$ 成立。为了使用假设，我们选择的 $B'$ 必须满足 $B' \\ge B(A)$。\n\n1.  **项 $\\frac{S_\\theta(x,Q)}{\\ln x}$**：\n    使用我们对 $S_\\theta(x,Q)$ 的界：\n    $$\n    \\frac{S_\\theta(x,Q)}{\\ln x} \\ll \\frac{1}{\\ln x} \\left(\\frac{x}{(\\ln x)^A} + Q x^{1/2}\\right) = \\frac{x}{(\\ln x)^{A+1}} + \\frac{Q x^{1/2}}{\\ln x}\n    $$\n2.  **积分项 $\\int_2^x \\frac{S_\\theta(t,Q)}{t(\\ln t)^2} dt$**：\n    我们拆分积分并代入 $S_\\theta(t,Q)$ 的界。\n    $$\n    \\int_2^x \\frac{S_\\theta(t,Q)}{t(\\ln t)^2} dt \\ll \\int_2^x \\frac{t/(\\ln t)^A + Q t^{1/2}}{t(\\ln t)^2} dt = \\int_2^x \\frac{dt}{(\\ln t)^{A+2}} + Q \\int_2^x \\frac{dt}{t^{1/2}(\\ln t)^2}\n    $$\n    第一个积分是 $O(x/(\\ln x)^{A+2})$。第二个是 $O(x^{1/2}/(\\ln x)^2)$。所以，这部分贡献了 $O(x/(\\ln x)^{A+2} + Q x^{1/2}/(\\ln x)^2)$。\n\n结合所有项，总误差由以下各项主导：\n$$\n\\sum_{q \\le Q} \\max_a |\\dots| \\ll \\frac{x}{(\\ln x)^{A+1}} + \\frac{Q x^{1/2}}{\\ln x}\n$$\n现在我们使用关于 $Q$ 的条件。我们正在为 $\\pi$ 推导一个新定理，它对范围 $Q \\le x^{1/2}/(\\ln x)^{B'}$ 成立。如前所述，为使推导有效，我们必须选择 $B' \\ge B(A)$。让我们做出这样的选择。第二项变为：\n$$\n\\frac{Q x^{1/2}}{\\ln x} \\le \\frac{x^{1/2}}{(\\ln x)^{B'}} \\frac{x^{1/2}}{\\ln x} = \\frac{x}{(\\ln x)^{B'+1}}\n$$\n所以总误差的界为：\n$$\n\\ll \\frac{x}{(\\ln x)^{A+1}} + \\frac{x}{(\\ln x)^{B'+1}} \\ll \\frac{x}{(\\ln x)^{\\min(A+1, B'+1)}}\n$$\n所得指数为 $\\alpha = \\min(A+1, B'+1)$。问题要求 $\\alpha$ 仅用 $A$ 表示。我们可以为我们的新定理自由选择参数 $B'$，但需满足约束 $B' \\ge B(A)$。我们选择 $B'(A) = \\max(A, B(A))$。这个选择满足 $B' \\ge B(A)$。通过此选择，指数变为：\n$$\n\\alpha = \\min(A+1, \\max(A, B(A))+1)\n$$\n我们考虑两种情况：\n-   情况 1：$B(A) \\le A$。那么 $\\max(A, B(A)) = A$，并且 $\\alpha = \\min(A+1, A+1) = A+1$。\n-   情况 2：$B(A)  A$。那么 $\\max(A, B(A)) = B(A)$，并且 $\\alpha = \\min(A+1, B(A)+1) = A+1$。\n\n在两种情况下，我们都发现所得指数为 $\\alpha = A+1$。这个结果对于 $Q \\le x^{1/2}/(\\ln x)^{B'(A)}$ 成立，其中 $B'(A) = \\max(A, B(A))$。\n因此，该指数仅由 $A$ 决定。", "answer": "$$\\boxed{A+1}$$", "id": "3090431"}, {"introduction": "邦别里-维诺格拉多夫定理为质数分布的平均误差提供了一个强大的理论上界，但这些误差在数值上究竟是怎样的呢？计算数学使我们能够通过直接计算来探索这些理论概念。这项编程挑战 [@problem_id:3025116] 邀请您连接理论与实践，通过编写程序来计算邦别里-维诺格拉多夫定理所约束的误差总和，您将对该定理的陈述获得一种具体、数值化的感知，并能更好地领会其所保证的均等分布的规模。", "problem": "设 $x$ 为一个大的实数参数，$q$ 为一个正整数模。对于每个满足 $\\gcd(a,q)=1$ 的模 $q$ 的既约剩余类 $a$，定义约束于等差级数的切比雪夫函数为\n$$\n\\theta(x;q,a) \\;=\\; \\sum_{\\substack{p \\le x \\\\ p \\equiv a \\,(\\bmod q)}} \\log p,\n$$\n并回顾欧拉总计函数 $\\varphi(q)$。考虑总偏差\n$$\nS_{\\theta}(x,Q) \\;=\\; \\sum_{1 \\le q \\le Q} \\; \\max_{\\substack{0 \\le a  q \\\\ \\gcd(a,q)=1}} \\left| \\theta(x;q,a) \\;-\\; \\frac{x}{\\varphi(q)} \\right|.\n$$\nBombieri–Vinogradov 定理 (BV) 指出，在模 $q$ 的平均意义下，当 $q$ 的尺度达到 $x^{1/2}$ 时，素数在等差级数中的分布行为就如同素数在既约剩余类中是均匀分布的一样。不借助任何未经证实的假设，可以通过检验 $S_{\\theta}(x,Q)$ 如何随着 $Q$ 与 $x$ 的变化而随 $x$ 和 $\\log x$ 变化，来设计一个对此均匀分布性的计算检验。\n\n您的任务是实现一个程序，对于给定的三元组 $(x,\\alpha,A)$，仅根据上述定义计算以下归一化诊断量：\n$$\nM_A(x,Q) \\;=\\; \\frac{(\\log x)^A}{x} \\, S_{\\theta}(x,Q),\n$$\n其中 $Q$ 由 $(x,\\alpha)$ 决定，具体为\n$$\nQ \\;=\\; \\left\\lfloor \\frac{x^{1/2}}{(\\log x)^{\\alpha}} \\right\\rfloor,\n$$\n并约定如果右侧表达式小于 $1$，则 $Q$ 设为 $1$。所有对数均为自然对数。\n\n该诊断量 $M_A(x,Q)$ 将总偏差 $S_{\\theta}(x,Q)$ 按 $x$ 和 $(\\log x)^A$ 进行缩放，以反映 Bombieri–Vinogradov 定理 (BV) 定性内容所建议的平均误差归一化，而不在计算中使用该定理的任何显式不等式。您的程序必须对每个测试用例，仅使用 $\\theta(x;q,a)$ 和 $\\varphi(q)$ 的定义来精确计算 $M_A(x,Q)$。\n\n请从基本定义出发设计您的实现：\n- 仅使用 $\\theta(x;q,a)$、$\\varphi(q)$ 的定义和基本的素数生成来精确计算定义的和与最大值。\n- 确保对所有 $q \\le Q$ 的计算足够高效，以处理接近 $x^{1/2}$ 的 $Q$。\n- 所有出现的 $\\log$ 均使用自然对数。\n\n测试套件：\n为以下四个参数三元组 $(x,\\alpha,A)$ 计算 $M_A(x,Q)$：\n1. $(x,\\alpha,A) = (10^6, 1.0, 1.0)$。\n2. $(x,\\alpha,A) = (3 \\cdot 10^5, 0.0, 1.0)$。\n3. $(x,\\alpha,A) = (5 \\cdot 10^4, 0.0, 2.0)$。\n4. $(x,\\alpha,A) = (2 \\cdot 10^3, 3.0, 1.0)$。\n\n输入和输出：\n- 无输入。您的程序必须硬编码上述测试套件。\n- 您的程序必须生成单行输出，其中包含四个测试用例的结果，形式为逗号分隔的浮点值列表，按所列顺序排列，并用方括号括起来。例如，格式必须严格如下：\n$[m_1,m_2,m_3,m_4]$\n其中每个 $m_i$ 是对应测试用例计算出的 $M_A(x,Q)$ 值。将每个 $m_i$ 表示为小数点后有六位数字的小数。\n\n注意：\n- 实现必须是通用的、纯数学的，不依赖于任何物理单位。\n- 确保数值稳定性，并在适用的情况下跨测试用例重用素数数据，以避免冗余的重复计算。\n- 您的设计应包括对边界情况 $Q=1$ 的仔细处理。", "solution": "所述问题需进行验证。\n\n### 步骤 1：提取已知条件\n- **切比雪夫函数 `$\\theta(x;q,a)$`**：为实数参数 `$x$`、正整数模 `$q$` 以及模 `$q$` 的既约剩余类 `$a$`（`$\\gcd(a,q)=1$`）定义为 `$\\theta(x;q,a) = \\sum_{\\substack{p \\le x \\\\ p \\equiv a \\,(\\bmod q)}} \\log p$`，其中求和遍及所有素数 `$p$`。\n- **欧拉总计函数 `$\\varphi(q)$`**：小于或等于给定整数 `$q$` 且与 `$q$` 互质的正整数的个数。\n- **总偏差 `$S_{\\theta}(x,Q)$`**：定义为 `$S_{\\theta}(x,Q) = \\sum_{1 \\le q \\le Q} \\; \\max_{\\substack{0 \\le a  q \\\\ \\gcd(a,q)=1}} \\left| \\theta(x;q,a) - \\frac{x}{\\varphi(q)} \\right|$`。\n- **尺度参数 `$Q$`**：由一对 `$(x,\\alpha)$` 决定，`$Q = \\left\\lfloor \\frac{x^{1/2}}{(\\log x)^{\\alpha}} \\right\\rfloor$`。如果 `$\\frac{x^{1/2}}{(\\log x)^{\\alpha}}  1$`，则 `$Q$` 设为 `$1$`。\n- **归一化诊断量 `$M_A(x,Q)$`**：为三元组 `$(x,\\alpha,A)$` 定义为 `$M_A(x,Q) = \\frac{(\\log x)^A}{x} \\, S_{\\theta}(x,Q)$`。\n- **对数**：所有出现的 `$\\log$` 均表示自然对数。\n- **任务**：实现一个程序，为给定的测试套件计算 `$M_A(x,Q)$`。\n- **测试套件**：四个参数三元组 `$(x,\\alpha,A)$`：\n    1. `$(10^6, 1.0, 1.0)$`\n    2. `$(3 \\cdot 10^5, 0.0, 1.0)$`\n    3. `$(5 \\cdot 10^4, 0.0, 2.0)$`\n    4. `$(2 \\cdot 10^3, 3.0, 1.0)$`\n\n### 步骤 2：使用提取的已知条件进行验证\n根据验证标准对问题进行评估。\n\n- **科学性**：问题基于解析数论中基础且完善的概念。函数 `$\\theta(x;q,a)$` 和 `$\\varphi(q)$` 以及 Bombieri-Vinogradov 定理的背景都是该领域的标准内容。该任务是已定义数学对象的直接计算实现。问题是合理的。\n- **适定性**：所有函数（`$\\theta, \\varphi, S_{\\theta}, M_A$`）和参数（`$x, \\alpha, A, Q$`）都用数学精度进行了定义。对于任何给定的输入三元组，计算都是确定性的，确保存在唯一且有意义的解。问题是适定的。\n- **客观性**：问题使用客观的数学语言表述，没有任何主观性或歧义。\n- **完整性与一致性**：问题陈述是自洽的。它提供了所有必要的定义、公式和条件，包括 `$Q$` 的边界条件。没有内部矛盾。\n- **可行性**：`$x$` 的最大值为 `$10^6$`。相应的 `$Q$` 值大约在几百的量级。计算高达 `$10^6$` 的素数并执行指定的求和虽然计算密集，但使用现代硬件和高效算法是完全可行的。\n\n### 步骤 3：结论与行动\n问题是**有效的**。这是一个在数论领域定义明确的计算任务。将根据所提供的定义构建解决方案。\n\n### 解决方案设计\n对每个测试用例 `$(x, \\alpha, A)$` 计算 `$M_A(x,Q)$` 的过程将遵循一个直接实现给定数学定义的、符合原则的分步算法。\n\n1.  **目标公式化**：主要目标是计算量 `$M_A(x,Q) = \\frac{(\\log x)^A}{x} S_{\\theta}(x,Q)$`。这需要预先计算总偏差 `$S_{\\theta}(x,Q)$`，其定义为 `$S_{\\theta}(x,Q) = \\sum_{1 \\le q \\le Q} \\max_{\\substack{0 \\le a  q \\\\ \\gcd(a,q)=1}} \\left| \\theta(x;q,a) - \\frac{x}{\\varphi(q)} \\right|$`。`$\\theta(x;q,a)` 项本身是素数的和，即 `$\\theta(x;q,a) = \\sum_{p \\le x, p \\equiv a \\,(\\bmod q)} \\log p$`。\n\n2.  **预计算策略**：为确保计算效率，跨测试用例共享的数据将被预先计算。\n    - **素数及其对数**：测试套件中 `$x$` 的最大值是 `$10^6$`。所有小于等于 `$10^6$` 的素数 `$p$` 将使用埃拉托斯特尼筛法一次性生成。每个素数的自然对数 `$\\log p$` 也将被预计算并存储。\n    - **欧拉总计函数 `$\\varphi(q)$`**：确定所有测试用例中 `$Q$` 的最大值。使用基于筛法的算法高效地预计算所有小于等于该最大 `$Q$` 的整数 `$q$` 的 `$\\varphi(q)$` 值。\n\n3.  **主计算循环**：程序将遍历四个测试用例 `$(x, \\alpha, A)$` 中的每一个。对每个用例，执行以下计算序列。\n\n4.  **参数 `$Q$` 的计算**：使用公式 `$Q = \\lfloor x^{1/2} (\\log x)^{-\\alpha} \\rfloor$` 确定尺度参数 `$Q$`。严格遵守当表达式小于 `$1$` 时 `$Q=1$` 的要求。\n\n5.  **`$\\theta(x;q,a)$` 求和的计算**：求和 `$\\theta(x;q,a)` 是计算中最密集的部分。一种直接而高效的方法是遍历一次预计算的素数列表 `$p \\le x$`。对于每个素数 `$p$`，我们遍历从 `$1$` 到 `$Q$` 的所有相关模 `$q$`。然后将 `$\\log p$` 的值加到 `$a = p \\pmod q$` 对应的 `$\\theta(x;q,a)$` 的累加器中。这种方法避免了对素数列表的冗余迭代。这些和值存储在一个将 `$(q,a)` 映射到相应和值的数据结构中。\n\n6.  **总偏差 `$S_{\\theta}(x,Q)$` 的计算**：在计算完给定 `$x$` 和 `$Q$` 的所有 `$\\theta(x;q,a)$` 和之后，计算 `$S_{\\theta}(x,Q)$`。这通过从 `$1$` 到 `$Q$` 迭代 `$q$` 来完成。对于每个 `$q$`，计算项 `$\\frac{x}{\\varphi(q)}$`。然后，通过检查所有模 `$q$` 的既约剩余类 `$a$`，找到绝对偏差 `$|\\theta(x;q,a) - \\frac{x}{\\varphi(q)}|` 的最大值。将这些最大偏差对 `$q$`求和，得到 `$S_{\\theta}(x,Q)$`。对于给定的 `$q$`，如果一个既约剩余类 `$a$` 从未作为 `$p \\pmod q$` 出现，则其对应的 `$\\theta(x;q,a)` 正确地取为 `$0$`。\n\n7.  **最终诊断量 `$M_A(x,Q)$`**：通过组合先前计算的值来计算测试用例的最终结果：`$M_A(x,Q) = S_{\\theta}(x,Q) \\cdot (\\log x)^A \\cdot x^{-1}$`。\n\n8.  **输出格式化**：将所有四个测试用例的结果收集起来，并按规定格式化为单个字符串：一个用方括号括起来的、以逗号分隔的、小数点后保留六位精度的浮点数列表。此过程保证解决方案既符合问题定义，又在计算上是可行的。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef precompute_primes_and_logs(limit):\n    \"\"\"\n    Generates primes up to a limit using the Sieve of Eratosthenes\n    and computes their natural logarithms.\n    \"\"\"\n    is_prime = np.ones(limit + 1, dtype=bool)\n    is_prime[0:2] = False\n    for i in range(2, int(np.sqrt(limit)) + 1):\n        if is_prime[i]:\n            is_prime[i*i::i] = False\n    primes = np.where(is_prime)[0]\n    log_primes_map = {p: np.log(p) for p in primes}\n    return primes, log_primes_map\n\ndef precompute_phi(limit):\n    \"\"\"\n    Computes Euler's totient function phi(n) for all n = limit\n    using a sieve-based method.\n    \"\"\"\n    if limit  0:\n        return np.array([], dtype=int)\n    phi = np.arange(limit + 1, dtype=int)\n    if limit >= 1:\n        phi[1] = 1\n    for i in range(2, limit + 1):\n        if phi[i] == i:  # i is prime\n            for j in range(i, limit + 1, i):\n                phi[j] -= phi[j] // i\n    return phi\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test suite.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (10**6, 1.0, 1.0),\n        (3 * 10**5, 0.0, 1.0),\n        (5 * 10**4, 0.0, 2.0),\n        (2 * 10**3, 3.0, 1.0),\n    ]\n\n    # Pre-computation based on the maximum values in test cases.\n    max_x = int(max(tc[0] for tc in test_cases))\n    \n    # Pre-compute primes and their logs up to max_x.\n    primes, log_primes_map = precompute_primes_and_logs(max_x)\n    \n    # Determine the maximum Q across all test cases to size the phi-sieve.\n    max_q_candidate = 0\n    for x_val, alpha_val, _ in test_cases:\n        log_x_val = np.log(x_val)\n        # alpha_val >= 0 checks prevent division by zero for x=1, though not in these cases.\n        q_expr = x_val**0.5 / (log_x_val**alpha_val) if log_x_val > 0 or alpha_val = 0 else 0\n        max_q_candidate = max(max_q_candidate, int(q_expr))\n    \n    # Q must be at least 1, so phi table must accommodate at least phi(1).\n    max_q = max(1, max_q_candidate)\n    phi_values = precompute_phi(max_q)\n\n    results = []\n    for x, alpha, A in test_cases:\n        log_x = np.log(x)\n\n        # 1. Calculate Q for the current test case.\n        q_pre = x**0.5 / (log_x**alpha) if log_x > 0 or alpha = 0 else 0\n        Q = int(q_pre) if q_pre >= 1 else 1\n\n        # 2. Compute theta(x; q, a) for p = x, q = Q.\n        theta_sums = [{} for _ in range(Q + 1)]\n\n        # Efficiently select primes = x using binary search on the sorted prime array.\n        end_idx = np.searchsorted(primes, x, side='right')\n        current_primes = primes[:end_idx]\n\n        for p in current_primes:\n            log_p = log_primes_map[p]\n            for q in range(1, Q + 1):\n                a = p % q\n                theta_sums[q][a] = theta_sums[q].get(a, 0.0) + log_p\n\n        # 3. Compute S_theta(x, Q).\n        s_theta = 0.0\n        for q in range(1, Q + 1):\n            phi_q = phi_values[q]\n            expected_val = x / phi_q\n            max_dev = 0.0\n            \n            # Iterate through all reduced residue classes a mod q.\n            for a in range(q):\n                if math.gcd(a, q) == 1:\n                    theta_val = theta_sums[q].get(a, 0.0)\n                    dev = abs(theta_val - expected_val)\n                    if dev > max_dev:\n                        max_dev = dev\n            \n            s_theta += max_dev\n\n        # 4. Compute M_A(x, Q).\n        m_a = (log_x**A / x) * s_theta\n        results.append(m_a)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\nsolve()\n```", "id": "3025116"}]}