{"hands_on_practices": [{"introduction": "素数定理为我们描绘了一幅优美的素数分布渐近图景，但对于一个具体的大数 $x$，我们如何才能对 $\\pi(x)$ 做出精确且有保证的论断呢？本次练习将带领你从渐近理论走向显式界。通过应用经典的 Rosser-Schoenfeld 不等式 [@problem_id:3084502]，你将亲自计算出一亿以内素数数量的严格上下限，并由此体会数论学家们用以获得具体确定性的工具之精妙。", "problem": "设 $\\pi(x)$ 表示素数计数函数，其定义为 $\\pi(x)=|\\{p \\text{ prime} : p \\leq x\\}|$，并设 $\\ln(x)$ 表示自然对数。一个经过充分检验的事实是，素数定理 (PNT) 断言，当 $x\\to\\infty$ 时，$\\pi(x)\\sim x/\\ln(x)$，但对于具体的数值证明，需要使用显式不等式。Rosser–Schoenfeld 显式界 (1962) 指出，对于所有实数 $x \\geq 55$，\n$$\\frac{x}{\\ln x - 1} \\le \\pi(x) \\le \\frac{x}{\\ln x - 1.08366}.$$\n仅使用这些显式界，为 $\\pi(10^{8})$ 给出一个经证明的上限和下限，并构建比率\n$$R=\\frac{\\text{upper bound} - \\text{lower bound}}{10^{8}/\\ln(10^{8})}.$$\n计算 $R$ 并将最终答案四舍五入到四位有效数字。将您的答案表示为一个不带单位的纯数。", "solution": "我们从素数计数函数 $\\pi(x)$ 和自然对数 $\\ln(x)$ 的定义开始。素数定理提供了启发式尺度 $\\pi(x)\\sim x/\\ln(x)$，但为了获得经证明的界，我们依赖于 Rosser–Schoenfeld 不等式，这些是经过充分检验的显式公式。\n\n对于 $x=10^{8}$，Rosser–Schoenfeld 界给出\n$$\\frac{10^{8}}{\\ln(10^{8})-1} \\le \\pi(10^{8}) \\le \\frac{10^{8}}{\\ln(10^{8})-1.08366}.$$\n设 $L=\\ln(10^{8})$。则下限和上限分别为\n$$\\text{LB}=\\frac{10^{8}}{L-1},\\qquad \\text{UB}=\\frac{10^{8}}{L-1.08366}.$$\n该经证明的区间的宽度是\n$$\\text{width}=\\text{UB}-\\text{LB}=\\frac{10^{8}}{L-1.08366}-\\frac{10^{8}}{L-1}.$$\n在代数上，这个差可以简化为\n\\begin{align*}\n\\text{width}\n=10^{8}\\left(\\frac{1}{L-1.08366}-\\frac{1}{L-1}\\right)\n=10^{8}\\cdot\\frac{(L-1)-(L-1.08366)}{(L-1.08366)(L-1)}\\\\\n=10^{8}\\cdot\\frac{0.08366}{(L-1.08366)(L-1)}.\n\\end{align*}\n题目要求我们将此宽度与基准尺度 $10^{8}/L$ 进行比较，方法是构建比率\n$$R=\\frac{\\text{width}}{10^{8}/L}=\\frac{10^{8}\\cdot\\frac{0.08366}{(L-1.08366)(L-1)}}{10^{8}/L}=\\frac{0.08366\\,L}{(L-1.08366)(L-1)}.$$\n因此，该比率的精确表达式为\n$$R=\\frac{0.08366\\,\\ln(10^{8})}{\\big(\\ln(10^{8})-1.08366\\big)\\big(\\ln(10^{8})-1\\big)}.$$\n为了对 $R$ 进行数值计算，我们使用 $\\ln(10)=2.302585093$，因此\n$$L=\\ln(10^{8})=8\\ln(10)=8\\times 2.302585093=18.420680744.$$\n接下来，计算各个因子：\n\\begin{align*}\nL-1 = 18.420680744 - 1 = 17.420680744,\\\\\nL-1.08366 = 18.420680744 - 1.08366 = 17.337020744,\\\\\n(L-1.08366)(L-1) \\approx 17.337020744 \\times 17.420680744 \\approx 302.022676,\\\\\n0.08366\\,L \\approx 0.08366 \\times 18.420680744 \\approx 1.541074088.\n\\end{align*}\n因此，\n$$R \\approx \\frac{1.541074088}{302.022676} \\approx 0.005102512\\ldots.$$\n四舍五入到四位有效数字，得到\n$$R \\approx 0.005103.$$\n\n为完整起见，我们也可以观察数值下限和上限本身：\n\\begin{align*}\n\\text{LB}=\\frac{10^{8}}{17.420680744}\\approx 5{,}740{,}304,\\\\\n\\text{UB}=\\frac{10^{8}}{17.337020744}\\approx 5{,}768{,}004,\n\\end{align*}\n所以区间宽度约为 $27{,}700$，并且 $10^{8}/L\\approx 5{,}428{,}682$，这与比率 $R\\approx 27{,}700/5{,}428{,}682\\approx 0.005103$ 一致。\n\n此计算仅使用 Rosser–Schoenfeld 显式界作为经过充分检验的出发点，并将其经证明的区间宽度与素数定理所建议的自然尺度 $10^{8}/\\ln(10^{8})$ 进行比较。", "answer": "$$\\boxed{0.005103}$$", "id": "3084502"}, {"introduction": "理解了素数的总体密度后，我们很自然地会对它们之间的“间隙”产生疑问。本次动手编程练习 [@problem_id:3084537] 邀请你扮演一位实验数论学家。你将生成一个庞大的素数列表，并分析它们之间间隙的统计行为，将你的发现与素数定理预测的平均间隙大小以及 Cramér 模型所启发的最大间隙尺寸进行比较。", "problem": "您需要通过计算来研究素数间隙的经验行为。令 $p_n$ 表示第 $n$ 个素数，并定义素数间隙序列 $g(p_n) = p_{n+1} - p_n$（对于 $n \\geq 1$）。令 $\\pi(x)$ 表示素数计数函数，即小于或等于 $x$ 的素数个数。令 $\\log x$ 表示 $x$ 的自然对数。本研究的基础是素数定理 (PNT)，该定理指出当 $x \\to \\infty$ 时，$\\pi(x) \\sim \\dfrac{x}{\\log x}$。这意味着在 $x$ 附近，连续素数之间的平均间距在启发式上为 $\\log x$ 的量级。另一个被广泛讨论的启发式方法，通常归功于 Cramér，表明最大间隙的增长规模可能在 $(\\log x)^2$ 的量级。\n\n您的任务是编写一个完整、可运行的程序，该程序：\n\n- 使用基于基本数论原理的算法（例如，Sieve of Eratosthenes）生成所有小于等于 $X = 10^7$ 的素数。\n- 对于给定的 $x$，定义：\n  - 截至 $x$ 观察到的最大间隙，\n    $$ G_{\\max}(x) = \\max\\{ g(p_n) : p_{n+1} \\leq x \\}. $$\n  - 截至 $x$ 的经验平均间隙，\n    $$ \\overline{g}(x) = \\frac{p_k - 2}{k - 1}, \\quad \\text{其中 } p_k = \\max\\{p_n \\leq x\\} \\text{ 且 } k = \\pi(x). $$\n    通过裂项求和，该量等于 $p_{n+1} \\leq x$ 的连续素数差 $g(p_n)$ 的平均值，并且是一个可以直接与素数定理所建议的 $\\log x$ 尺度进行比较的直接计算。\n  - 截至 $x$ 且两个连续素数均不小于 $5$ 的最小间隙（以排除 $2$ 和 $3$ 之间的特殊初始间隙），\n    $$ G_{\\min}^{\\geq 5}(x) = \\min\\{ g(p_n) : p_n \\geq 5 \\text{ and } p_{n+1} \\leq x \\}. $$\n  - 观察到的最大间隙与自然对数之比，\n    $$ R_1(x) = \\frac{G_{\\max}(x)}{\\log x}, $$\n    以及观察到的最大间隙与自然对数平方之比，\n    $$ R_2(x) = \\frac{G_{\\max}(x)}{(\\log x)^2}. $$\n- 通过比率 $R_1(x)$ 和 $R_2(x)$，将 $G_{\\max}(x)$ 与基准 $\\log x$ 和 $(\\log x)^2$ 进行经验性比较。\n\n使用以下 $x$ 值的测试套件：\n- $x = 30$（小规模行为和边界效应），\n- $x = 10^5$，\n- $x = 10^6$，\n- $x = 3 \\cdot 10^6$，\n- $x = 10^7$（上限）。\n\n对于测试套件中的每个 $x$，计算并报告列表\n$$ [\\, x,\\; G_{\\max}(x),\\; \\overline{g}(x),\\; G_{\\min}^{\\geq 5}(x),\\; R_1(x),\\; R_2(x) \\,]. $$\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，其中每个元素是对应测试用例的上述子列表，顺序与给定顺序相同。所有浮点值都应打印到小数点后六位。例如，外部结构应如下所示\n$$ [\\,[\\cdots],\\,[\\cdots],\\,[\\cdots],\\,[\\cdots],\\,[\\cdots]\\,] $$\n逗号后没有空格。\n\n所有答案都是没有物理单位的纯数字。不涉及角度。不涉及百分比；比率应表示为小数。程序必须是自包含的，不需要用户输入，不得访问外部文件或网络，并且必须确定性地运行。", "solution": "所提出的问题是计算数论中一个明确定义的练习，要求对素数的分布及其间隙进行经验性研究。该问题在科学上是合理的，数学上是一致的，并且在计算上是可行的。它基于已建立的数论概念，如素数定理和素数间隙的启发式模型。因此，我将提供一个完整的解决方案。\n\n解决方案的方法分为两个主要阶段：首先，高效生成截至指定上限 $X = 10^7$ 的素数列表；其次，为提供的测试套件中的每个 $x$ 值计算所需的统计量度。\n\n**1. 素数生成：Sieve of Eratosthenes**\n\n要对素数进行任何分析，我们必须首先生成它们。对于高达 $X = 10^7$ 的给定范围，最合适的算法是 Sieve of Eratosthenes。这个经典算法以其效率和概念上的优雅而闻名。\n\n筛法的原理基于合数的一个基本性质：任何合数 $n$ 至少有一个素因子 $p$ 满足 $p \\le \\sqrt{n}$。该算法的工作方式如下：\n- 我们创建一个大小为 $X+1$ 的布尔数组，我们称之为 `is_prime`，将从 $2$ 到 $X$ 的所有条目初始化为 true。根据定义，数字 $0$ 和 $1$ 被标记为非素数。\n- 我们从第一个素数 $p=2$ 开始。我们遍历它的倍数（$2p, 3p, \\dots$）并在数组中将它们标记为非素数。\n- 然后我们找到数组中下一个仍标记为素数的数字；这必须是下一个素数，即 $3$。我们重复这个过程，将所有 $3$ 的倍数标记为非素数。\n- 这个过程对所有小于等于 $\\sqrt{X}$ 的素数 $p$ 继续进行。一个优化是从 $p^2$ 开始标记 $p$ 的倍数，因为任何更小的倍数 $k \\cdot p$（其中 $k  p$）都已经被 $k$ 的某个素因子（该因子小于 $p$）标记为合数。\n\n该算法的时间复杂度约为 $O(X \\log \\log X)$，效率非常高，可以在标准计算机上几秒钟内生成高达 $10^7$ 的素数。筛法运行后，`is_prime` 数组允许提取一个截至 $X$ 的所有素数的有序列表。\n\n**2. 素数间隙统计的计算**\n\n有了表示为数组 `primes` 的有序素数列表，我们就可以为每个测试值 $x \\in \\{30, 10^5, 10^6, 3 \\cdot 10^6, 10^7\\}$ 计算所需的量。\n\n对于每个 $x$ 值：\n\n首先，我们必须确定小于或等于 $x$ 的素数集合。令其为 $\\{p_1, p_2, \\dots, p_k\\}$，其中 $p_k$ 是不超过 $x$ 的最大素数。这些素数的数量是 $k = \\pi(x)$。使用一个预先计算好的、包含高达 $10^7$ 的所有素数的排序数组，我们可以通过对 $x$ 执行二分搜索来高效地找到 $k$。子数组 `primes[0:k]` 则精确地包含了我们需要的素数。\n\n所需的统计数据计算如下：\n\n-   **最大观测间隙, $G_{\\max}(x)$**：其定义为 $G_{\\max}(x) = \\max\\{ g(p_n) : p_{n+1} \\leq x \\}$。这个条件意味着我们考虑所有连续的素数对 $(p_n, p_{n+1})$，其中两个素数都小于或等于 $p_k$。这对应于 $n$ 从 $1$ 到 $k-1$ 时差值 $p_{n+1} - p_n$ 的最大值。在编程中，这通过取从素数子集计算出的差值数组的最大值来找到。\n\n-   **经验平均间隙, $\\overline{g}(x)$**：这由公式 $\\overline{g}(x) = \\frac{p_k - 2}{k - 1}$ 定义。该公式的有效性基于间隙的裂项求和：$\\sum_{n=1}^{k-1} g(p_n) = \\sum_{n=1}^{k-1} (p_{n+1} - p_n) = p_k - p_1$。由于 $p_1 = 2$，所以和为 $p_k - 2$。间隙的数量是 $k-1$。计算是直接应用此公式，使用已确定的 $p_k$ 和 $k$ 的值。这个经验平均值可以与素数定理得出的启发式 $\\log x$ 进行比较。\n\n-   **最小间隙, $G_{\\min}^{\\geq 5}(x)$**：其定义为 $G_{\\min}^{\\geq 5}(x) = \\min\\{ g(p_n) : p_n \\geq 5 \\text{ and } p_{n+1} \\leq x \\}$。条件 $p_n \\geq 5$ 意味着我们从素数对 $(p_3, p_4) = (5, 7)$ 开始搜索间隙。只要 $p_{n+1} \\leq x$，我们就考虑所有后续的间隙 $g(p_n)$。孪生素数猜想假设存在无限多对素数 $(p, p+2)$，这意味着对于足够大的 $x$，$G_{\\min}^{\\geq 5}(x)$ 应该为 $2$。对于测试套件中的所有 $x$ 值，都存在至少一对孪生素数 $(p, p+2)$，其中 $p \\geq 5$ 且 $p+2 \\leq x$，因此我们期望找到 $G_{\\min}^{\\geq 5}(x) = 2$。\n\n-   **比率 $R_1(x)$ 和 $R_2(x)$**：它们定义为 $R_1(x) = \\frac{G_{\\max}(x)}{\\log x}$ 和 $R_2(x) = \\frac{G_{\\max}(x)}{(\\log x)^2}$。这些比率使用自然对数函数 `numpy.log` 和先前计算的 $G_{\\max}(x)$ 直接计算。$R_1(x)$ 以平均间隙大小为单位来衡量最大间隙。$R_2(x)$ 针对 Cramér 提出的启发式模型测试最大间隙的尺度。虽然 Cramér 的原始概率模型表明 $\\limsup_{n \\to \\infty} \\frac{g(p_n)}{(\\log p_n)^2} = 1$，但更精确的启发式模型表明该常数可能不同。这些经验比率提供了对这些想法的简单数值检验。\n\n该实现将把这些步骤合成为一个单一的程序，该程序首先构建素数列表，然后遍历测试用例以计算并按规定格式化结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes empirical statistics of prime gaps up to a specified limit.\n    \"\"\"\n\n    # Define the upper bound for prime generation.\n    # The largest test case is 10^7, so we generate primes up to this limit.\n    limit = 10**7\n\n    # Step 1: Generate all primes up to the limit using the Sieve of Eratosthenes.\n    # This function returns a sorted numpy array of prime numbers.\n    def sieve_of_eratosthenes(n):\n        \"\"\"Generates primes up to n using the Sieve of Eratosthenes.\"\"\"\n        # Create a boolean array `is_prime` of size n + 1.\n        is_prime = np.ones(n + 1, dtype=bool)\n        is_prime[0] = is_prime[1] = False  # 0 and 1 are not prime.\n\n        # Iterate from p = 2 up to sqrt(n).\n        for p in range(2, int(np.sqrt(n)) + 1):\n            if is_prime[p]:\n                # Mark all multiples of p as not prime, starting from p*p.\n                is_prime[p*p::p] = False\n        \n        # Extract prime numbers from the boolean array.\n        primes = np.where(is_prime)[0]\n        return primes\n\n    primes = sieve_of_eratosthenes(limit)\n\n    # Step 2: Define the test cases from the problem statement.\n    test_cases = [\n        30,\n        100000,\n        1000000,\n        3000000,\n        10000000,\n    ]\n\n    all_results = []\n    # Step 3: Process each test case.\n    for x in test_cases:\n        # Find all primes less than or equal to x.\n        # np.searchsorted gives the index where x would be inserted to maintain order.\n        # 'right' side ensures that if x is prime, it's included.\n        k = np.searchsorted(primes, x, side='right')\n        primes_subset = primes[:k]\n        \n        # Ensure there are at least two primes to form a gap.\n        if k  2:\n            # This case is not reached with the given test suite.\n            continue\n            \n        p_k = primes_subset[-1]\n\n        # Calculate all gaps between consecutive primes up to x.\n        gaps = primes_subset[1:] - primes_subset[:-1]\n        \n        # a) Maximal observed gap up to x, G_max(x)\n        g_max = np.max(gaps) if gaps.size > 0 else 0\n\n        # b) Empirical average gap up to x, g_bar(x)\n        # Note: k is the count of primes, p_1=2, so k-1 is the number of gaps.\n        g_bar = (p_k - 2) / (k - 1)\n        \n        # c) Minimal gap for primes = 5, G_min_geq_5(x)\n        # Find the index of the first prime = 5.\n        # For all test cases, this will be index 2 (prime 5).\n        start_idx = np.searchsorted(primes_subset, 5)\n        \n        # Check if there are any gaps to consider.\n        if start_idx  len(gaps):\n            g_min_geq_5 = np.min(gaps[start_idx:])\n        else:\n            # No primes = 5, so no such gaps. Not possible with given tests.\n            g_min_geq_5 = float('inf')\n\n        # d) Ratios R1(x) and R2(x)\n        ln_x = np.log(x)\n        r1 = g_max / ln_x\n        r2 = g_max / (ln_x**2)\n        \n        # Store results for this case. x, g_max, g_min are integers.\n        # g_bar, r1, r2 are floating-point values.\n        result_list = [int(x), int(g_max), g_bar, int(g_min_geq_5), r1, r2]\n        all_results.append(result_list)\n\n    # Step 4: Format and print the final output exactly as required.\n    formatted_sublists = []\n    for res in all_results:\n        x_val, gmax_val, gbar_val, gmin_val, r1_val, r2_val = res\n        s = f\"[{x_val},{gmax_val},{gbar_val:.6f},{gmin_val},{r1_val:.6f},{r2_val:.6f}]\"\n        formatted_sublists.append(s)\n\n    # The final print statement must produce a single line in the specified format.\n    print(f\"[{','.join(formatted_sublists)}]\")\n\nsolve()\n```", "id": "3084537"}, {"introduction": "素数的分布能否用一个简单的概率游戏来建模？本次练习 [@problem_id:3084527] 将通过强大的启发式工具——Cramér 随机模型，来深入探讨这个问题。你将推导短区间内素数数量的期望值和方差，然后将这些基于概率的预测与 Maier 定理所揭示的深刻而令人惊讶的真实行为进行对比，从而揭示简单随机性在描述素数精细结构时的局限性。", "problem": "设 $x$ 为一个大的实数参数，$\\pi(x)$ 表示素数计数函数。考虑短区间 $[x, x+y]$，其中 $y=\\lambda \\ln x$，$\\lambda>0$ 是一个不依赖于 $x$ 的固定常数。在 Cramér 的素数随机模型中，每个整数 $n\\geq 2$ 以 $1/\\ln n$ 的概率被独立地判定为“素数”。仅使用此模型假设和概率论的基本原理，推导随机变量 $\\pi(x+y)-\\pi(x)$ 的期望值和方差的主阶表达式（当 $x\\to\\infty$ 且 $\\lambda$ 固定时）。\n\n你必须证明用于将求和替换为积分或在 $y=\\lambda \\ln x$ 尺度上进行泰勒展开的近似的合理性。然后，定性地解释这些 Cramér 模型的预测与 Maier 现象所确立的、长度与 $\\ln x$ 相当的短区间中素数的实际行为相比有何不同。\n\n请以行矩阵的形式，提供由主阶均值和方差组成的有序对（用 $\\lambda$ 表示）。不要提供数值近似。[@problem_id:159]", "solution": "问题要求在短区间 $[x, x+y]$ 内素数数量的期望值和方差的主阶表达式，其中 $y = \\lambda \\ln x$，$x$ 是一个大参数，$\\lambda>0$ 是一个固定常数。这需要在 Cramér 随机模型的框架内完成，然后与 Maier 定理描述的现象进行比较。\n\n首先，我们使用 Cramér 模型将问题形式化。在此模型中，对于每个整数 $n \\ge 2$，我们关联一个独立的伯努利随机变量 $I_n$，使得：\n$$\nI_n = \\begin{cases} 1  \\text{若 } n \\text{ 是“素数”} \\\\ 0  \\text{若 } n \\text{ 是“合数”} \\end{cases}\n$$\n成功（即 $n$ 是“素数”）的概率为 $p_n = P(I_n=1) = \\frac{1}{\\ln n}$。假设对于所有 $n \\ge 2$，事件 $\\{I_n=1\\}$ 都是独立的。\n\n区间 $[x, x+y]$ 内的素数数量是随机变量 $N$，定义为该区间内整数的这些指示变量之和。对于大的 $x$，我们可以考虑满足 $x  n \\le x+y$ 的整数 $n$。\n$$\nN = \\sum_{n=\\lfloor x \\rfloor+1}^{\\lfloor x+y \\rfloor} I_n\n$$\n\n**1. 期望值**\n\n$N$ 的期望值，记为 $E[N]$，通过期望的线性性质求得：\n$$\nE[N] = E\\left[ \\sum_{n=\\lfloor x \\rfloor+1}^{\\lfloor x+y \\rfloor} I_n \\right] = \\sum_{n=\\lfloor x \\rfloor+1}^{\\lfloor x+y \\rfloor} E[I_n]\n$$\n单个伯努利变量 $I_n$ 的期望是其成功概率，即 $E[I_n] = p_n = \\frac{1}{\\ln n}$。因此，\n$$\nE[N] = \\sum_{n=\\lfloor x \\rfloor+1}^{\\lfloor x+y \\rfloor} \\frac{1}{\\ln n}\n$$\n为了找到当 $x \\to \\infty$ 时的主阶行为，我们必须近似这个和。求和区间是 $[x, x+y]$，其长度为 $y = \\lambda \\ln x$。和中的整数项数为 $\\lfloor x+y \\rfloor - \\lfloor x \\rfloor \\approx y = \\lambda \\ln x$。\n\n对于求和范围内的任何整数 $n$，$x  n \\le x+y$。对于这样的 $n$，$\\ln n$ 的值接近于 $\\ln x$。我们可以使这一点更精确。由于 $x  n \\le x + \\lambda \\ln x$，我们有：\n$$\n\\ln x  \\ln n \\le \\ln(x + \\lambda \\ln x) = \\ln\\left(x\\left(1 + \\frac{\\lambda \\ln x}{x}\\right)\\right) = \\ln x + \\ln\\left(1 + \\frac{\\lambda \\ln x}{x}\\right)\n$$\n当 $x \\to \\infty$时，项 $\\frac{\\lambda \\ln x}{x} \\to 0$。对小的 $u$ 使用泰勒展开 $\\ln(1+u) = u + O(u^2)$，我们得到：\n$$\n\\ln n = \\ln x + O\\left(\\frac{\\ln x}{x}\\right)\n$$\n这意味着对于区间内所有的 $n$，$\\ln n$ 都非常接近 $\\ln x$。项 $\\frac{1}{\\ln n}$ 可以用 $\\frac{1}{\\ln x}$ 来近似。\n$$\n\\frac{1}{\\ln n} = \\frac{1}{\\ln x + O\\left(\\frac{\\ln x}{x}\\right)} = \\frac{1}{\\ln x} \\left(1 + O\\left(\\frac{1}{x}\\right)\\right)^{-1} = \\frac{1}{\\ln x} \\left(1 - O\\left(\\frac{1}{x}\\right)\\right) = \\frac{1}{\\ln x} + O\\left(\\frac{1}{x \\ln x}\\right)\n$$\n主导项，或称主阶项，是 $\\frac{1}{\\ln x}$。用这个高精度近似替换和中的每一项：\n$$\nE[N] = \\sum_{n=\\lfloor x \\rfloor+1}^{\\lfloor x+y \\rfloor} \\left(\\frac{1}{\\ln x} + O\\left(\\frac{1}{x \\ln x}\\right)\\right)\n$$\n和中的项数是 $y$（最多相差一个可忽略的加法常数 $1$）。所以，大约有 $y = \\lambda \\ln x$ 项。\n$$\nE[N] \\approx (\\lambda \\ln x) \\cdot \\frac{1}{\\ln x} = \\lambda\n$$\n误差项的阶为 $y \\cdot O\\left(\\frac{1}{x \\ln x}\\right) = (\\lambda \\ln x) \\cdot O\\left(\\frac{1}{x \\ln x}\\right) = O\\left(\\frac{\\lambda}{x}\\right)$，当 $x \\to \\infty$ 时趋于零。因此，期望值的主阶表达式为：\n$$\nE[N] \\approx \\lambda\n$$\n这可以通过用积分近似求和来证实：\n$$\nE[N] \\approx \\int_x^{x+y} \\frac{dt}{\\ln t}\n$$\n根据积分中值定理，对于某个 $c \\in (x, x+y)$，该积分等于 $(x+y-x) \\frac{1}{\\ln c} = \\frac{y}{\\ln c}$。由于当 $x \\to \\infty$ 时 $c \\sim x$，所以 $\\ln c \\sim \\ln x$。该积分渐近于 $\\frac{y}{\\ln x} = \\frac{\\lambda \\ln x}{\\ln x} = \\lambda$。\n\n**2. 方差**\n\n接下来计算 $N$ 的方差，记为 $V[N]$。根据模型的假设，$I_n$ 是独立的随机变量，因此和的方差是方差的和：\n$$\nV[N] = V\\left[ \\sum_{n=\\lfloor x \\rfloor+1}^{\\lfloor x+y \\rfloor} I_n \\right] = \\sum_{n=\\lfloor x \\rfloor+1}^{\\lfloor x+y \\rfloor} V[I_n]\n$$\n参数为 $p_n$ 的伯努利变量的方差是 $V[I_n] = p_n(1-p_n)$。所以，\n$$\nV[N] = \\sum_{n=\\lfloor x \\rfloor+1}^{\\lfloor x+y \\rfloor} \\frac{1}{\\ln n}\\left(1 - \\frac{1}{\\ln n}\\right) = \\sum_{n=\\lfloor x \\rfloor+1}^{\\lfloor x+y \\rfloor} \\frac{1}{\\ln n} - \\sum_{n=\\lfloor x \\rfloor+1}^{\\lfloor x+y \\rfloor} \\frac{1}{(\\ln n)^2}\n$$\n第一项正是期望值 $E[N]$，我们已经确定其主阶行为是 $\\lambda$。\n$$\n\\sum_{n=\\lfloor x \\rfloor+1}^{\\lfloor x+y \\rfloor} \\frac{1}{\\ln n} = \\lambda + O\\left(\\frac{1}{x}\\right)\n$$\n对于第二项，我们使用和之前相同的近似：对于区间内的 $n$，$\\ln n \\approx \\ln x$。\n$$\n\\sum_{n=\\lfloor x \\rfloor+1}^{\\lfloor x+y \\rfloor} \\frac{1}{(\\ln n)^2} \\approx (\\text{项数}) \\times \\frac{1}{(\\ln x)^2} \\approx y \\cdot \\frac{1}{(\\ln x)^2}\n$$\n代入 $y = \\lambda \\ln x$，我们得到：\n$$\n\\sum_{n=\\lfloor x \\rfloor+1}^{\\lfloor x+y \\rfloor} \\frac{1}{(\\ln n)^2} \\approx (\\lambda \\ln x) \\cdot \\frac{1}{(\\ln x)^2} = \\frac{\\lambda}{\\ln x}\n$$\n当 $x \\to \\infty$ 时，这一项趋于 $0$。这是一个低阶修正项。\n合并方差的各项：\n$$\nV[N] \\approx \\lambda - \\frac{\\lambda}{\\ln x}\n$$\n当 $x \\to \\infty$ 时，项 $\\frac{\\lambda}{\\ln x}$ 消失，所以方差的主阶表达式为：\n$$\nV[N] \\approx \\lambda\n$$\n因此，在 Cramér 模型中，对于大的 $x$，区间 $[x, x+\\lambda \\ln x]$ 内素数数量的均值和方差都近似为 $\\lambda$。这表明在此类区间中素数的分布可以很好地用参数为 $\\lambda$ 的泊松分布来近似。\n\n**3. 与 Maier 现象的比较**\n\nCramér 模型的预测可以与数论中关于短区间内素数分布的严格结果进行比较。\n\n*   **Cramér 模型预测**：在 $[x, x+\\lambda \\ln x]$ 区间内的素数数量 $N$ 是一个随机变量，其 $E[N] \\approx \\lambda$ 且 $V[N] \\approx \\lambda$。$N$ 的分布近似为泊松分布($\\lambda$)。与均值的标准偏差在 $\\sqrt{\\lambda}$ 的量级，并且大的偏差是指数级稀少的。例如，当期望有 $\\lambda$ 个素数时，观测到 $2\\lambda$ 个素数的概率非常小。\n\n*   **Maier 现象（实际行为）**：1985年，Helmut Maier 证明了一个令人惊讶的结果，它与简单的泊松分布图像相矛盾。素数定理表明，$[x, x+y]$ 区间内的素数数量应近似为 $\\text{li}(x+y) - \\text{li}(x) \\approx \\frac{y}{\\ln x}$。对于 $y=\\lambda \\ln x$，这个期望数量是 $\\lambda$，与 Cramér 模型的均值相符。然而，Maier 证明了存在对这种平均行为的系统性、大规模的偏离。\n\nMaier 的定理表明，对于任何大的常数 $M > 1$，存在 $x \\to \\infty$ 的序列，使得在更长的区间 $[x, x+(\\ln x)^M]$ 内的素数数量持续地比期望数量大一个因子，也存在其他序列使其持续地小一个因子。虽然原始定理是针对长度为 $(\\ln x)^M$ 的区间陈述的，但其基本原理也适用于长度为 $\\lambda \\ln x$ 的区间。素数数量 $\\pi(x+\\lambda\\ln x) - \\pi(x)$ 可以表现出远大于泊松模型预测的 $\\sqrt{\\lambda}$ 波动的振荡。对于某些 $x$ 的序列，计数值可以显著且持续地不同于 $\\lambda$。\n\nCramér 模型失败的根本原因是其**独立性假设**。一个整数 $n$ 是否为素数的性质与其邻近整数的素性并非独立。素数的分布与整数的算术结构密切相关。例如，素性与能否被小素数整除有关。一个整数是素数，当且仅当它不能被任何 $p \\le \\sqrt{n}$ 的素数整除。Maier 的证明巧妙地利用了缺少小素数因子的整数的非均匀分布。通过在长的算术级数中恰当地选择 $x$，可以落入整数的某些区域，这些区域对于成为素数是异常“有利”（比平均情况拥有更少的小素数因子）或“不利”的，从而导致素数“成群”（比预期多）或“空洞”（比预期少）。\n\n总而言之，Cramér 模型提供了一个有用的、给出平均计数为 $\\lambda$ 的一阶启发式方法，但它未能捕捉到素数序列中微妙的相关性。Maier 的定理表明，短区间内素数计数的真实方差显著大于 Cramér 模型预测的方差 $\\lambda$，这反映了素数底层的算术性、非随机的结构。", "answer": "$$\n\\boxed{\\begin{pmatrix} \\lambda  \\lambda \\end{pmatrix}}\n$$", "id": "3084527"}]}