{"hands_on_practices": [{"introduction": "理论结果，例如形如 $4k+3$ 的素数有无穷多个，是强大的。然而，眼见为实。此练习 ([@problem_id:3088516]) 提供了一个动手实践的机会，通过实现一个素性测试并系统地在该著名的算术级数中搜索素数，来从计算上验证这一现象。", "problem": "给定一个由规则 $t_n = a + n d$ 定义的等差数列，其中 $n \\in \\{0,1,2,\\dots\\}$，固定参数 $a=3$ 和 $d=4$。该数列枚举了所有形式为 $4k+3$ 的整数。素数是一个大于等于2的整数 $p$，除了1和它本身以外没有其他正因数。你的任务是基于第一性原理实现一个素性测试，并将其应用于该数列的初始片段。具体来说，对于给定的截止值 $N$，检查前 $N$ 项 $\\{t_0, t_1, \\dots, t_{N-1}\\}$，并返回一个仅由其中是素数的项组成的子列表。程序必须是自包含的，并且不得读取任何输入。所使用的算术、数论和算法概念应基于可除性、素数和等差数列结构等基本定义进行论证。\n\n测试套件：\n- 情况1：$N=0$（没有项的边界情况）。\n- 情况2：$N=1$（单项 $t_0=3$）。\n- 情况3：$N=5$（一个包含素数和合数的小集合）。\n- 情况4：$N=200$（前200项，代表对数列 $4k+3$ 的一次全面运行）。\n\n对于每个测试用例 $N$，所要求的答案是在该数列前 $N$ 项中的素数项列表。总输出必须是单行，包含四个测试用例的结果，按顺序排列，形式为一个用方括号括起来的逗号分隔列表。此外层列表的每个元素本身也必须是一个用方括号括起来的逗号分隔的整数列表，表示为该测试用例找到的素数。因此，最终输出的形式为 $[L_0,L_1,L_2,L_3]$，其中 $L_i$ 是情况 $i$ 的素数列表。你的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如 $[result_1,result_2,result_3,result_4]$）。", "solution": "该问题是有效的，因为它在科学上以数论为基础，问题陈述清晰，并且其所有组成部分都得到了正式且无歧义的定义。我们将基于第一性原理着手解决。\n\n任务是在一个特定等差数列的初始片段中识别素数。这需要两个主要组成部分：一种生成数列项的方法和一种测试每项素性的方法。\n\n首先，我们来处理等差数列。等差数列是一个数列，其中任意两个连续项之间的差是恒定的。这个恒定的差被称为公差，用 $d$ 表示。数列中的项 $t_n$ 由公式 $t_n = a + n d$ 定义，其中 $a$ 是首项（对应于 $n=0$），$n$ 是一个非负整数，$n \\in \\{0, 1, 2, \\dots\\}$。问题指定了参数 $a=3$ 和 $d=4$。因此，我们所考虑的数列由下式给出：\n$$t_n = 3 + 4n$$\n这是一个无限整数序列：$3, 7, 11, 15, 19, \\dots$。对于每个测试用例，我们给定一个截止值 $N$，我们的分析仅限于前 $N$ 项：$\\{t_0, t_1, \\dots, t_{N-1}\\}$。\n\n其次，我们必须建立一个严谨的素性测试程序。素数被正式定义为一个大于等于2的整数 $p$，其唯一的正因数是1和 $p$ 本身。大于1且不是素数的整数称为合数。要确定一个给定的项 $t_n$ 是否是素数，我们必须验证它是否满足这个定义。\n\n最基本的素性测试方法是直接从定义推导出来的试除法。要测试一个整数 $m > 1$ 是否为素数，我们可以检查它是否能被 $2 \\le k  m$ 范围内的每个整数 $k$ 整除。如果任何这样的 $k$ 能整除 $m$（即 $m/k$ 的余数为0），那么 $m$ 就有除1和自身以外的因数，因此是合数。如果检查了整个范围都没有找到因数，那么 $m$ 必定是素数。\n\n这种朴素的试除法算法可以被显著优化。一个关键的数学见解是，如果一个整数 $m$ 是合数，它可以写成两个因子的乘积，$m = k_1 \\cdot k_2$。如果两个因子都大于 $\\sqrt{m}$，那么它们的乘积 $k_1 \\cdot k_2$ 将会大于 $\\sqrt{m} \\cdot \\sqrt{m} = m$，这是一个矛盾。因此，如果 $m$ 是合数，它的至少一个因数必须小于或等于 $\\sqrt{m}$。这个原理允许我们缩小潜在因数的搜索空间。我们只需要对 $2 \\le k \\le \\lfloor\\sqrt{m}\\rfloor$ 范围内的整数 $k$ 进行试除，其中 $\\lfloor \\cdot \\rfloor$ 表示向下取整函数。\n\n可以进行进一步的优化。任何大于2的偶数都是合数，因为它可以被2整除。我们的数列 $t_n = 4n+3$ 的所有项都是奇数。一个奇数不可能有任何偶数因数。因此，我们只需要测试奇数因数。数字2可以作为特殊情况处理；它是素数。对于任何大于2的整数 $m$，我们可以首先检查它是否为偶数。如果是，它就是合数。如果不是，我们只需要测试直到 $\\lfloor\\sqrt{m}\\rfloor$ 的奇数因数 $k \\in \\{3, 5, 7, \\dots\\}$。\n\n结合这些原理，我们为函数 `is_prime(m)` 制定了以下算法：\n1. 如果 $m  2$，它不是素数。返回 false。\n2. 如果 $m = 2$，它是素数。返回 true。\n3. 如果 $m > 2$ 且 $m$ 能被 2 整除，它是合数。返回 false。\n4. 对于从 3 开始到 $\\lfloor\\sqrt{m}\\rfloor$（含）的所有奇数 $k$：\n   a. 如果 $m$ 能被 $k$ 整除，那么 $m$ 是合数。返回 false。\n5. 如果循环完成而没有找到任何因数，那么 $m$ 是素数。返回 true。\n\n这个稳健的算法将用于测试数列的每一项。\n\n解决给定截止值 $N$ 的问题的总体步骤如下：\n1. 初始化一个空列表 `prime_terms` 来存储结果。\n2. 如果 $N = 0$，项的集合为空，所以我们返回空列表。\n3. 如果 $N > 0$，用索引 $n$ 从 $0$ 迭代到 $N-1$。\n4. 在每次迭代中，计算项 $t_n = 3 + 4n$。\n5. 将 `is_prime` 函数应用于 $t_n$。\n6. 如果 `is_prime(t_n)` 返回 true，则将 $t_n$ 追加到 `prime_terms` 列表中。\n7. 循环完成后，`prime_terms` 包含了数列前 $N$ 项中的所有素数。\n\n此过程将对测试套件中指定的每个 $N$ 值执行：$N=0$，$N=1$，$N=5$ 和 $N=200$。最终输出将是为每种情况生成的列表的聚合，并按指定格式化。例如，对于 $N=5$，项为 $t_0=3$，$t_1=7$，$t_2=11$，$t_3=15$ 和 $t_4=19$。应用素性测试：\n- $3$：素数。\n- $7$：素数。\n- $11$：素数。\n- $15 = 3 \\times 5$：合数。\n- $19$：素数。\n对于 $N=5$ 的结果列表是 $[3, 7, 11, 19]$。此过程将对所有测试用例重复。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef is_prime(m):\n    \"\"\"\n    Tests if an integer m is prime using an optimized trial division method.\n\n    This function is implemented from first principles as required.\n    1. A number less than 2 is not prime.\n    2. The number 2 is the only even prime.\n    3. Any other even number is composite.\n    4. For an odd number m, we only need to check for odd divisors k\n       up to sqrt(m). If a divisor > sqrt(m) exists, a corresponding\n       divisor = sqrt(m) must also exist.\n    \"\"\"\n    if m  2:\n        return False\n    if m == 2:\n        return True\n    if m % 2 == 0:\n        return False\n    \n    # Check for odd divisors from 3 up to the square root of m.\n    limit = int(np.sqrt(m))\n    for i in range(3, limit + 1, 2):\n        if m % i == 0:\n            return False\n            \n    return True\n\ndef find_primes_in_progression(N, a, d):\n    \"\"\"\n    Generates the first N terms of an arithmetic progression and returns the\n    subset of terms that are prime.\n\n    Args:\n        N (int): The number of terms to examine, from t_0 to t_{N-1}.\n        a (int): The first term of the progression (t_0).\n        d (int): The common difference of the progression.\n\n    Returns:\n        list: A list of prime numbers found among the first N terms.\n    \"\"\"\n    prime_terms = []\n    if N == 0:\n        return []\n        \n    for n in range(N):\n        term = a + n * d\n        if is_prime(term):\n            prime_terms.append(term)\n            \n    return prime_terms\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the final result.\n    \"\"\"\n    # Define the fixed parameters for the arithmetic progression t_n = a + nd.\n    a = 3\n    d = 4\n\n    # Define the test cases from the problem statement.\n    test_cases = [0, 1, 5, 200]\n\n    results = []\n    for N in test_cases:\n        # Find the list of prime terms for the current test case.\n        result_list = find_primes_in_progression(N, a, d)\n        results.append(result_list)\n\n    # Format the final output according to the problem specification.\n    # The output must be a single line string, e.g., [[3],[7,11],[13]].\n    # Python's default string representation of a list is \"[...]\", which\n    # matches the required format for the inner lists.\n    # We join these string representations with a comma and enclose them in\n    # the outer brackets.\n    output_str = f\"[{','.join(map(str, results))}]\"\n    print(output_str)\n\nsolve()\n```", "id": "3088516"}, {"introduction": "在探索了 $4k+3$ 这一具体案例之后，我们可以将方法推广。此练习 ([@problem_id:3088480]) 要求你创建一个通用工具，用于寻找任何满足 $\\gcd(a,m)=1$ 条件的算术级数 $a+mk$ 中的最小素数。这项练习不仅能磨练你的算法思维，还能加深你对狄利克雷定理广泛适用性的理解。", "problem": "给定整数 $m$ 和 $a$，满足 $\\gcd(a,m)=1$，考虑等差数列 $\\{a+tm : t \\in \\mathbb{Z}_{\\ge 0}\\}$。目标是对于每个给定的数对 $(m,a)$，计算满足 $p \\equiv a \\bmod m$ 的最小素数 $p$。仅使用定义和经过充分检验的事实作为基础：素数的定义、模 $m$ 同余的定义，以及若 $\\gcd(a,m)=1$，则剩余类 $a \\bmod m$ 与 $m$ 互素的性质。您的程序必须实现一个逻辑上合理的搜索方法，通过扫描等差数列并测试候选数的素性来找到 $p$。您还必须根据这些基本概念来解释该搜索方法。\n\n使用的定义：\n- 素数是一个大于等于 $2$ 的整数 $p$，其正因数只有 $1$ 和 $p$ 本身。\n- 对于整数 $x,y,m$ 且 $m \\ge 1$，$x \\equiv y \\bmod m$ 意味着 $m$ 整除 $x-y$。\n- 整数 $u$ 和 $v$ 的最大公约数（gcd），记作 $\\gcd(u,v)$，是指能同时整除 $u$ 和 $v$ 的最大整数 $d$。\n\n设计一个程序，对于每个测试用例 $(m,a)$，输出满足 $p \\equiv a \\bmod m$ 的最小素数 $p$。\n\n测试套件：\n- 用例 $1$：$(m,a)=(4,3)$。\n- 用例 $2$：$(m,a)=(5,2)$。\n- 用例 $3$：$(m,a)=(8,1)$。\n- 用例 $4$：$(m,a)=(7,-1)$。\n- 用例 $5$：$(m,a)=(9,2)$。\n- 用例 $6$：$(m,a)=(11,10)$。\n- 用例 $7$：$(m,a)=(4,1)$。\n- 用例 $8$：$(m,a)=(100,1)$。\n\n关于覆盖范围的说明：\n- 用例 $1$ 和 $7$ 测试了模 $4$ 的等差数列，包括经典的 $4k+3$ 数列。\n- 用例 $4$ 包含一个负余数，以测试到最小非负余数的归一化。\n- 用例 $2$ 和 $5$ 展示了最小素数等于余数本身的情况。\n- 用例 $3$ 需要在数列中进行多次迭代才能找到第一个素数。\n- 用例 $6$ 测试了一个奇数模数下接近 $m-1$ 的余数。\n- 用例 $8$ 使用了一个较大的模数。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[r_1,r_2,r_3]$）。对于给定的测试套件，输出必须是按所列顺序为每个 $(m,a)$ 找到的最小素数的列表。", "solution": "该问题被验证为具有科学依据、问题明确且客观。其前提与数论的既定原则一致。所有提供的测试用例都满足条件 $\\gcd(a,m)=1$。该问题如陈述所述是可解的。\n\n该问题要求对于给定的整数 $m$ 和 $a$（满足 $\\gcd(a,m)=1$），找到属于等差数列 $\\{a+tm : t \\in \\mathbb{Z}_{\\ge 0}\\}$ 的最小素数 $p$。解决方案涉及直接实现一个搜索算法并结合一个素性测试，两者都基于所提供的定义。\n\n该方法的核心是系统性搜索。算法通过从整数 $t=0$ 开始并在后续每一步中将其加 1，来遍历等差数列的元素。对于每个 $t$ 值，使用公式 $c_t = a + t \\cdot m$ 生成一个候选数 $c_t$。\n\n然后对每个候选数 $c_t$ 进行素性测试，以确定它是否为素数。由于搜索是按 $t$ 的递增顺序进行的，因此找到的第一个被证实为素数的候选数保证是指定等差数列中的最小素数。此搜索过程保证能够成功终止。数论中的一个基本结果，即狄利克雷等差数列定理（Dirichlet's theorem on arithmetic progressions），指出对于任意两个互素的整数 $a$ 和 $m$，等差数列 $a+tm$ 中包含无穷多个素数。因此，最小素数必然存在。\n\n素性测试直接源于素数的定义：一个大于等于 $2$ 的整数 $p$，其正因数只有 $1$ 和 $p$ 本身。测试整数 $n$ 是否为素数的算法如下：\n$1$. 根据定义，任何小于 $2$ 的整数都不是素数。因此，如果 $n  2$，则它是合数。\n$2$. 数字 $2$ 是最小的素数。\n$3$. 任何大于 $2$ 的偶数都能被 $2$ 整除，因此不是素数。\n$4$. 对于任何大于 $2$ 的奇数 $n$，我们必须检查其因数。一个关键性质是，如果 $n$ 是合数，它必定有一个素因数 $d$ 满足 $d \\le \\sqrt{n}$。这意味着我们只需要检查 $n$ 是否能被直到 $\\sqrt{n}$ 的奇数整除。试除法过程会检查 $n$ 是否能被 $3 \\le d \\le \\sqrt{n}$ 范围内的任何奇数 $d$ 整除。如果找到这样的因数，$n$ 就是合数。如果循环完成而没有找到任何此类因数，$n$ 就是素数。\n\n对于每个给定的数对 $(m,a)$，整体算法如下：\n$1$. 初始化计数器 $t=0$。\n$2$. 开始一个无限循环。在循环内部，计算候选数 $c = a + t \\cdot m$。\n$3$. 对候选数 $c$ 应用素性测试。\n$4$. 如果确定 $c$ 是素数，那么它就是数列中的最小素数。值 $c$ 是数对 $(m,a)$ 的结果，对此数对的搜索终止。\n$5$. 如果 $c$ 不是素数，将计数器 $t$ 增加到 $t+1$，并用下一个候选数继续循环。\n\n该过程能正确处理所有情况，包括 $a$ 为负数或小于 $2$ 的情况，例如测试用例 $(m,a)=(7,-1)$。对于 $t=0$，第一个候选数是 $c_0 = -1$，它被正确地识别为非素数。循环继续对 $t=1, 2, \\dots$ 进行，生成候选数 $6, 13, \\dots$，直到找到第一个素数 $13$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef is_prime(n):\n    \"\"\"\n    Tests if an integer n is a prime number using trial division.\n    \n    A prime number is an integer p >= 2 that has no positive divisors\n    other than 1 and p.\n    \"\"\"\n    # Primes must be >= 2.\n    if n  2:\n        return False\n    # 2 is the only even prime.\n    if n == 2:\n        return True\n    # All other even numbers are not prime.\n    if n % 2 == 0:\n        return False\n    # Check for odd divisors from 3 up to sqrt(n).\n    # We only need to check up to the square root of n because if n has a\n    # divisor larger than its square root, it must also have a divisor\n    # smaller than it.\n    # The loop increments by 2 to check only odd numbers.\n    limit = int(np.sqrt(n))\n    for i in range(3, limit + 1, 2):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_smallest_prime_in_progression(m, a):\n    \"\"\"\n    Finds the smallest prime p such that p = a (mod m).\n    \n    This is achieved by iterating through the arithmetic progression\n    {a + t*m for t >= 0} and testing each number for primality.\n    \"\"\"\n    # The condition gcd(a,m)=1 guarantees a prime exists in this progression.\n    # We search by incrementing t from 0 upwards.\n    t = 0\n    while True:\n        candidate = a + t * m\n        if is_prime(candidate):\n            return candidate\n        t += 1\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (4, 3),    # Case 1\n        (5, 2),    # Case 2\n        (8, 1),    # Case 3\n        (7, -1),   # Case 4\n        (9, 2),    # Case 5\n        (11, 10),  # Case 6\n        (4, 1),    # Case 7\n        (100, 1),  # Case 8\n    ]\n\n    results = []\n    for m, a in test_cases:\n        # For each test case, find the smallest prime in the progression.\n        smallest_prime = find_smallest_prime_in_progression(m, a)\n        results.append(smallest_prime)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3088480"}, {"introduction": "算术级数并不总是以最明显的形式出现。这个问题 ([@problem_id:3088517]) 展示了它们是如何作为数论中其他基本问题的解而产生的，如同余方程组。通过首先使用中国剩余定理求解一个整数，你将定义出一个算术级数，然后应用你的素性测试技能来找到其最小的素数成员。", "problem": "设 $x$ 是一个整数，满足同余方程组 $x \\equiv 3 \\pmod{4}$，$x \\equiv 1 \\pmod{5}$ 和 $x \\equiv 2 \\pmod{7}$。从同余的定义（即 $a \\equiv b \\pmod{m}$ 意味着 $m \\mid a-b$）和中国剩余定理（CRT）的陈述（对于两两互质的模，在模它们的乘积下有唯一解）出发，推导出所有此类 $x$ 模 $140$ 的唯一剩余类，并计算其最小非负解。然后，将此剩余类解释为一个等差数列，并确定该数列中的最小素数项，通过仅检验其是否能被不大于其平方根的素数整除来证明其素性。请以精确整数形式给出你的最终答案，即该数列中的最小素数，无需四舍五入。", "solution": "用户提供了一个问题，要求解一个线性同余方程组，然后找出结果等差数列中的最小素数。\n\n**问题验证**\n\n**步骤1：提取已知条件**\n-   $x$ 是一个整数。\n-   $x \\equiv 3 \\pmod{4}$\n-   $x \\equiv 1 \\pmod{5}$\n-   $x \\equiv 2 \\pmod{7}$\n-   同余的定义：$a \\equiv b \\pmod{m}$ 意味着 $m \\mid a-b$。\n-   中国剩余定理（CRT）陈述：对于两两互质的模，在模它们的乘积下存在唯一解。\n-   任务1：推导 $x$ 模 $140$ 的唯一剩余类。\n-   任务2：计算 $x$ 的最小非负解。\n-   任务3：将解解释为等差数列。\n-   任务4：找出该数列中的最小素数项。\n-   任务5：通过检验其是否能被不大于其平方根的素数整除来证明该项的素性。\n\n**步骤2：使用提取的已知条件进行验证**\n-   **科学依据：** 该问题是初等数论中的一个标准练习，基于公认的中国剩余定理和素数的定义。\n-   **适定性：** 模 $4$、$5$ 和 $7$ 两两互质（$gcd(4,5)=1$，$gcd(4,7)=1$，$gcd(5,7)=1$）。中国剩余定理保证了在模它们的乘积 $4 \\times 5 \\times 7 = 140$ 下存在唯一解。各项任务具体明确，导向一个单一、可验证的答案。\n-   **客观性：** 问题使用精确的数学语言陈述，没有歧义或主观论断。\n\n该问题未表现出验证标准中列出的任何缺陷。它是科学合理的、适定的、客观的且完整的。\n\n**步骤3：结论与行动**\n该问题是**有效的**。将提供解答。\n\n**解题推导**\n\n我们得到以下线性同余方程组：\n$$x \\equiv 3 \\pmod{4}$$\n$$x \\equiv 1 \\pmod{5}$$\n$$x \\equiv 2 \\pmod{7}$$\n\n由第一个同余式 $x \\equiv 3 \\pmod{4}$，我们可以将 $x$ 表示为 $x = 4k_1 + 3$，其中 $k_1$ 是某个整数。\n\n我们将此表达式代入第二个同余式 $x \\equiv 1 \\pmod{5}$ 中：\n$$4k_1 + 3 \\equiv 1 \\pmod{5}$$\n两边减去 $3$ 得：\n$$4k_1 \\equiv -2 \\pmod{5}$$\n因为 $-2 \\equiv 3 \\pmod{5}$，同余式变为：\n$$4k_1 \\equiv 3 \\pmod{5}$$\n为了解出 $k_1$，我们需要求 $4$ 模 $5$ 的乘法逆元。我们可以通过检验找到它：$4 \\times 1 \\equiv 4 \\pmod{5}$，$4 \\times 2 \\equiv 8 \\equiv 3 \\pmod{5}$，$4 \\times 3 \\equiv 12 \\equiv 2 \\pmod{5}$，$4 \\times 4 \\equiv 16 \\equiv 1 \\pmod{5}$。$4$ 模 $5$ 的逆元是 $4$。将同余式两边同乘以 $4$：\n$$4(4k_1) \\equiv 4(3) \\pmod{5}$$\n$$16k_1 \\equiv 12 \\pmod{5}$$\n$$k_1 \\equiv 2 \\pmod{5}$$\n这意味着 $k_1$ 必须形如 $k_1 = 5k_2 + 2$，其中 $k_2$ 是某个整数。\n\n现在，我们将 $k_1$ 的这个表达式代回 $x$ 的方程中：\n$$x = 4(5k_2 + 2) + 3$$\n$$x = 20k_2 + 8 + 3$$\n$$x = 20k_2 + 11$$\n这个关系式 $x \\equiv 11 \\pmod{20}$ 整合了前两个同余式。\n\n接下来，我们使用第三个同余式 $x \\equiv 2 \\pmod{7}$。代入我们新的 $x$ 的表达式：\n$$20k_2 + 11 \\equiv 2 \\pmod{7}$$\n我们将系数模 $7$ 进行化简。因为 $20 = (2 \\times 7) + 6$，所以有 $20 \\equiv 6 \\pmod{7}$，或者更方便地 $20 \\equiv -1 \\pmod{7}$。因为 $11 = (1 \\times 7) + 4$，所以有 $11 \\equiv 4 \\pmod{7}$。同余式变为：\n$$-k_2 + 4 \\equiv 2 \\pmod{7}$$\n两边减去 $4$：\n$$-k_2 \\equiv -2 \\pmod{7}$$\n两边乘以 $-1$：\n$$k_2 \\equiv 2 \\pmod{7}$$\n这意味着 $k_2$ 可以写成 $k_2 = 7k_3 + 2$，其中 $k_3$ 是某个整数。\n\n最后，我们将其代回表达式 $x = 20k_2 + 11$ 中：\n$$x = 20(7k_3 + 2) + 11$$\n$$x = 140k_3 + 40 + 11$$\n$$x = 140k_3 + 51$$\n这是满足该方程组的所有整数 $x$ 的通式。因此，模 $140$ 的唯一剩余类是 $x \\equiv 51 \\pmod{140}$。\n\n最小非负解可以通过令 $k_3 = 0$ 得到，即 $x = 51$。\n\n非负解的集合构成一个等差数列：$a_n = 51 + 140n$，其中 $n = 0, 1, 2, \\dots$。我们需要找出这个数列中的最小素数项。\n\n我们来测试前几项：\n当 $n=0$ 时：$a_0 = 51 + 140(0) = 51$。为了检查其素性，我们看到其数字之和为 $5+1=6$，可以被 $3$ 整除。实际上，$51 = 3 \\times 17$。所以，$51$ 不是素数。\n\n当 $n=1$ 时：$a_1 = 51 + 140(1) = 191$。为了检查 $191$ 是否为素数，我们必须测试它是否能被不大于 $\\sqrt{191}$ 的素数整除。我们知道 $13^2 = 169$ 且 $14^2 = 196$，所以 $\\sqrt{191}$ 介于 $13$ 和 $14$ 之间。我们只需要测试不大于 $13$ 的素数：$2, 3, 5, 7, 11, 13$。\n-   被 $2$ 整除性：$191$ 是奇数，所以不能被 $2$ 整除。\n-   被 $3$ 整除性：数字之和为 $1+9+1=11$，不能被 $3$ 整除。所以 $191$ 不能被 $3$ 整除。\n-   被 $5$ 整除性：末位是 $1$，不是 $0$ 或 $5$。所以 $191$ 不能被 $5$ 整除。\n-   被 $7$ 整除性：$191 = 7 \\times 27 + 2$。余数为 $2$，所以不能被 $7$ 整除。\n-   被 $11$ 整除性：$191 = 11 \\times 17 + 4$。余数为 $4$，所以不能被 $11$ 整除。\n-   被 $13$ 整除性：$191 = 13 \\times 14 + 9$。余数为 $9$，所以不能被 $13$ 整除。\n\n由于 $191$ 不能被任何不大于其平方根的素数整除，所以 $191$ 是一个素数。由于这是在该数列中找到的第一个素数（在检查了 $n=0$ 时的非素数项后，于 $n=1$ 时找到），因此它是该数列中的最小素数项。", "answer": "$$\\boxed{191}$$", "id": "3088517"}]}