{"hands_on_practices": [{"introduction": "许多排列问题都涉及到处理并非所有成员都唯一的物品集合，例如字母、数字或任何类型的可重复对象。这个练习将引导你应用处理这类情况的基础方法——多重集排列。通过解决这个问题 [@problem_id:1378986]，你将学会如何计算包含重复元素的序列的独特排列数量，这是解决更复杂组合问题的关键第一步。", "problem": "一所大学的计算机科学系正在为实验室访问设计一种新的安全协议。该协议通过获取YYYYMMDD格式的当前日期，并通过重新排列其数字来创建所有可能的唯一序列，从而生成每日访问代码。例如，在2024年2月24日，基础数字序列是20240224。从这个特定的数字序列中可以生成多少个不同的访问代码？", "solution": "我们被要求计算通过重新排列字符串“20240224”的数字可以获得的唯一序列的数量。这是一个多重集排列问题。\n\n首先，确定每个数字的重复次数：\n- 总长度为 $8$。\n- 数字 $2$ 出现了 $4$ 次。\n- 数字 $0$ 出现了 $2$ 次。\n- 数字 $4$ 出现了 $2$ 次。\n\n对于一个总大小为 $n$ 且各元素重复次数为 $n_{1}, n_{2}, \\dots$ 的多重集，其不同排列的数量由多项式系数给出：\n$$\n\\frac{n!}{n_{1}!\\,n_{2}!\\,\\cdots}.\n$$\n\n在这里，$n=8$，重复次数分别为 $4,2,2$，所以总数为\n$$\n\\frac{8!}{4!\\,2!\\,2!}.\n$$\n通过约分计算：\n$$\n\\frac{8!}{4!\\,2!\\,2!}=\\frac{8\\cdot 7\\cdot 6\\cdot 5\\cdot 4!}{4!\\cdot 2\\cdot 2}=\\frac{8\\cdot 7\\cdot 6\\cdot 5}{4}=\\frac{1680}{4}=420.\n$$\n因此，有 $420$ 个不同的访问代码。", "answer": "$$\\boxed{420}$$", "id": "1378986"}, {"introduction": "在掌握了基础排列之后，我们常常需要处理带有特定限制条件的排列问题。这个练习将挑战你处理一个更复杂的场景，其中不仅要满足一种结构性约束（交替排列），还需要满足一个否定性约束（特定成员不能相邻）。解决这个问题 [@problem_id:1379008] 将锻炼你使用容斥原理来系统地处理这类“禁止”条件的能力，这是组合分析中一种强大而常见的技巧。", "problem": "一家科技公司正在为一个关键项目组建一个新的跨学科团队。该团队由5名数据科学家和5名软件工程师组成。为了拍摄一张宣传照片，所有10名团队成员将坐在一排10张椅子上。为了直观地展示团队的协作性，座位安排必须满足同一部门的员工不能相邻而坐（即任意两名数据科学家或任意两名软件工程师都不能相邻）。此外，由于众所周知的一名特定的数据科学家Alice和一名特定的软件工程师Bob之间存在职业竞争关系，他们不得坐在相邻的椅子上。\n\n确定满足这两个条件的所有可能的座位安排总数。", "solution": "设 D 表示一名数据科学家，S 表示一名软件工程师。问题要求计算一行中5个D和5个S的排列数量，这些排列需满足两个条件：\n1. 排列必须是交替的（没有两个D或两个S是相邻的）。\n2. 特定的数据科学家Alice (A)和特定的软件工程师Bob (B)不相邻。\n\n我们将使用容斥原理来解决这个问题。设 $N_{total}$ 为对Alice和Bob没有任何限制的总交替排列数。设 $N_{forbidden}$ 为Alice和Bob *是* 相邻的交替排列数。所求的排列数即为 $N_{total} - N_{forbidden}$。\n\n步骤 1：计算总交替排列数 $N_{total}$。\n对于5个D和5个S的交替排列，有两种可能的模式：\n情况 1：该行以数据科学家开头。模式为 D S D S D S D S D S。\n- 5个数据科学家的位置可以由5位特定的数据科学家以 $5!$ 种方式填充。\n- 5个软件工程师的位置可以由5位特定的软件工程师以 $5!$ 种方式填充。\n- 因此，这种情况下的总排列数为 $5! \\times 5!$。\n\n情况 2：该行以软件工程师开头。模式为 S D S D S D S D S D。\n- 类似地，5名软件工程师可以有 $5!$ 种排列方式，5名数据科学家也可以有 $5!$ 种排列方式。\n- 因此，这种情况下的总排列数为 $5! \\times 5!$。\n\n因此，总的交替排列数是两种情况的总和：\n$N_{total} = (5! \\times 5!) + (5! \\times 5!) = 2 \\times (5!)^2$。\n$5! = 120$。所以，$N_{total} = 2 \\times (120)^2 = 2 \\times 14400 = 28800$。\n\n步骤 2：计算禁止的排列数 $N_{forbidden}$，即排列是交替的且Alice和Bob相邻。\n我们必须再次考虑两种交替模式。\n\n情况 A：模式为 D S D S D S D S D S。\nAlice (A) 是一名数据科学家 (D)，所以她必须坐在奇数编号的位置（1, 3, 5, 7, 9）。Bob (B) 是一名软件工程师 (S)，所以他必须坐在偶数编号的位置（2, 4, 6, 8, 10）。要使他们相邻，他们的位置编号必须相差1。让我们计算一下可能的相邻位置对的数量。\n相邻的座位对是 (1,2), (2,3), (3,4), ..., (9,10)。\n- 如果 A 在位置 1 (D)，B 可以在位置 2 (S)。\n- 如果 A 在位置 3 (D)，B 可以在位置 2 (S) 或 4 (S)。\n- 如果 A 在位置 5 (D)，B 可以在位置 4 (S) 或 6 (S)。\n- 如果 A 在位置 7 (D)，B 可以在位置 6 (S) 或 8 (S)。\n- 如果 A 在位置 9 (D)，B 可以在位置 8 (S) 或 10 (S)。\n将Alice和Bob安排在相邻位置的总方式数为 $1 + 2 + 2 + 2 + 2 = 9$。\n对于Alice和Bob的这9种放置方式中的每一种，剩下的4名数据科学家可以在剩下的4个 'D' 位置上以 $4!$ 种方式排列，剩下的4名软件工程师可以在剩下的4个 'S' 位置上以 $4!$ 种方式排列。\n所以，这种情况下的禁止排列数为 $9 \\times 4! \\times 4!$。\n\n情况 B：模式为 S D S D S D S D S D。\nAlice (A) 必须坐在偶数编号的位置（2, 4, 6, 8, 10）。Bob (B) 必须坐在奇数编号的位置（1, 3, 5, 7, 9）。\n根据与情况 A 的对称性，同样有9种方式将Alice和Bob安排在相邻位置。\n- 如果 B 在位置 1 (S)，A 可以在位置 2 (D)。\n- 如果 B 在位置 3 (S)，A 可以在位置 2 (D) 或 4 (D)。\n- ...以此类推。逻辑是相同的，为(A,B)对提供了9种可能的相邻放置方式。\n对于这9种放置方式中的每一种，剩下的4名数据科学家和4名软件工程师可以以 $4! \\times 4!$ 种方式排列。\n所以，这种情况下的禁止排列数也是 $9 \\times 4! \\times 4!$。\n\n禁止排列的总数是两种情况的总和：\n$N_{forbidden} = (9 \\times 4! \\times 4!) + (9 \\times 4! \\times 4!) = 18 \\times (4!)^2$。\n$4! = 24$。所以，$N_{forbidden} = 18 \\times (24)^2 = 18 \\times 576 = 10368$。\n\n步骤 3：计算最终答案。\n有效的排列数为 $N_{total} - N_{forbidden}$。\n方式数 = $(2 \\times (5!)^2) - (18 \\times (4!)^2)$\n我们可以在计算之前简化这个表达式：\n方式数 = $2 \\times (5 \\times 4!)^2 - 18 \\times (4!)^2$\n$= 2 \\times 25 \\times (4!)^2 - 18 \\times (4!)^2$\n$= (50 - 18) \\times (4!)^2$\n$= 32 \\times (4!)^2$\n$= 32 \\times (24)^2$\n$= 32 \\times 576$\n$= 18432$。\n\n或者，使用预先计算的值：\n方式数 = $28800 - 10368 = 18432$。", "answer": "$$\\boxed{18432}$$", "id": "1379008"}, {"introduction": "排列的概念不仅用于计数，它在计算机科学中也扮演着核心角色，尤其是在排序和数据处理算法中。这个练习将带你从纯粹的计数问题转向算法思维。它要求你通过严谨的逻辑推导来判断一个给定的排列是否能通过一个带有特定约束（容量有限的堆栈）的过程被成功排序。通过解决这个问题 [@problem_id:1379029]，你将体会到排列的性质如何决定一个计算过程的可行性，从而连接起抽象组合学与实际应用之间的桥梁。", "problem": "一个数据处理单元接收一个由四个数据包组成的序列，这些数据包的编号唯一，从1到4。为了正常工作，该单元必须在转发数据包之前，将它们重新排序为升序序列 (1, 2, 3, 4)。该单元有一个临时缓冲区，其工作方式为后进先出（LIFO）栈。这个缓冲区的容量有限，任何时候最多只能容纳两个数据包。\n\n排序过程遵循一个确定性算法。在每一步，该单元根据栈的状态和输入序列做出决策：\n\n1.  如果栈不为空，且栈顶数据包的编号是已排序输出序列中下一个位置所需要的数字，则该数据包从栈中弹出并被转发。此弹出操作总是优先于推入操作。\n2.  否则，如果输入序列不为空且栈未满（即，其中包含的数据包少于两个），则将输入序列中的下一个数据包推入栈中。\n3.  如果以上两种操作都不可行，则排序过程陷入死锁，并对该特定输入序列排序失败。\n\n如果此过程能够成功地产生完整的排序序列 (1, 2, 3, 4)，则认为该数据包的输入排列是“可排序的”。在这四个数据包所有可能的初始排列中，有多少种是可排序的？", "solution": "设期望的下一个输出为 $k$，初始时 $k=1$。在每一步，算法首先检查栈顶是否等于 $k$，如果是则弹出；否则，如果栈中元素少于 $2$ 个，则推入下一个输入；如果两种操作都不可行，则陷入死锁。\n\n首先，我们来限制 $1$ 的位置。假设 $1$ 出现在输入的第 $3$ 或第 $4$ 个位置。在遇到 $1$ 之前，算法必须推入每一个非 $1$ 的输入（因为它无法在栈顶不是 $1$ 的情况下弹出）。在推入两个这样的元素后，栈已满，而此时 $k=1$ 且栈顶不是 $1$，所以算法无法弹出。当下一个输入（另一个非 $1$ 的数或 $1$ 本身）到达时，由于容量限制它无法被推入，从而发生死锁。因此，$1$ 必须位于第 $1$ 或第 $2$ 个位置。这将候选排列从 $4!=24$ 种减少到 $12$ 种。\n\n情况 1：$1$ 在第 1 个位置。算法推入并立即弹出 $1$，因此 $k=2$，剩下三个输入。为避免死锁，$2$ 必须出现在接下来的两个输入之内。如果 $2$ 是这三个数中的最后一个，那么剩下的前两个数（都不是 $2$）会被推入栈中，使栈满且栈顶不等于 $2$，随后的 $2$ 就无法被推入，导致死锁。如果 $2$ 在这三个数的前两个位置中的任意一个，它就可以被推入（此时栈大小最多为 $2$）并立即弹出，之后剩下的两个元素是 $3$ 和 $4$，它们无论以何种顺序都总是可以处理的。因此，当 $1$ 在首位时，$2$ 有 $2$ 种位置选择（总序列的第 $2$ 或第 $3$ 位），剩下的两个元素可以有 $2$ 种排列方式，从而产生 $2 \\times 2=4$ 种可排序的排列。\n\n情况 2：$1$ 在第 2 个位置。将输入写为 $x,1,y,z$ 的形式，其中 $x \\in \\{2,3,4\\}$。算法先推入 $x$，然后推入并弹出 $1$，此时 $k=2$ 且栈中只含有 $x$。\n- 如果 $x=2$，栈顶恰好等于 $k$，$2$ 会被立即弹出；剩下的输入是 $3$ 和 $4$，无论顺序如何，这两种情况都是可以处理的，这提供了 $2$ 种可排序的排列。\n- 如果 $x \\in \\{3,4\\}$，那么下一个输入必须是 $2$。如果下一个输入是另一个非 $2$ 的数，推入它会使栈满且栈顶不等于 $2$，随后的 $2$ 就无法被推入，导致死锁。当下一个输入是 $2$ 时，它被推入并弹出，然后存储在栈中的 $x$（现在与下一个 $k$ 匹配）被弹出，最后处理最后一个元素。对于每个 $x \\in \\{3,4\\}$，在剩下的 $\\{2, \\text{另一个数}\\}$ 中只有一种顺序是有效的，这贡献了 $2$ 种可排序的排列。\n\n因此，当 $1$ 在第二个位置时，总共有 $2+2=4$ 种可排序的排列。\n\n将两种情况加总，总共有 $4+4=8$ 种可排序的排列。", "answer": "$$\\boxed{8}$$", "id": "1379029"}]}