{"hands_on_practices": [{"introduction": "原始递归 (Primitive Recursive, PR) 函数类是通过从一组初始函数开始，并应用组合和原始递归方案来构造性地建立的。本练习将引导您亲身实践这一过程，从最基本的元素出发，构建我们熟悉的算术函数，如 $\\max(x,y)$ 和 $\\min(x,y)$。通过这项实践，您将巩固对原始递归定义的理解，并掌握如何严格证明一个函数是原始递归的技能。[@problem_id:2979433]", "problem": "在标准自然数 $\\,\\mathbb{N}=\\{0,1,2,\\dots\\}\\,$ 上研究由初始函数生成、并在复合和原始递归下封闭的原始递归 (PR) 函数类。初始函数包括零函数 $Z(x)=0$、后继函数 $S(x)=x+1$ 以及投影函数 $U_{i}^{n}(x_{1},\\dots,x_{n})=x_{i}$。封闭性质为：如果 $g$ 和 $h$ 是 PR 函数，则 PR 函数的任何复合仍是 PR 函数；如果 $g$ 和 $h$ 是 PR 函数，则通过原始递归定义的函数 $f$\n$$\nf(\\vec{x},0)=g(\\vec{x}),\\qquad f(\\vec{x},S(y))=h(\\vec{x},y,f(\\vec{x},y))\n$$\n也是 PR 函数。PR 函数类是 $\\mu$-递归 (最小化) 函数类的一个子类；在此您必须避免使用最小化 (记为 $\\mu$) 算子，而只使用 PR 模式。\n\n仅使用初始函数和原始递归模式，定义前驱函数 $\\mathrm{pred}(x)$ 和截断减法 $x\\dot{-}y$。然后，仅使用 $x\\dot{-}y$ 来定义 $\\max(x,y)$ 和 $\\min(x,y)$，并从第一性原理出发（仅使用 PR 封闭性质、对序关系进行情况分析以及 $\\mathbb{N}$ 中的基本算术）证明 $\\max$ 和 $\\min$ 都是 PR 函数。最后，建立 $\\max$ 和 $\\min$ 在 $\\mathbb{N}$ 上的常规代数定律：交换律、幂等律、结合律、吸收律、单调性以及分解恒等式\n$$\n\\max(x,y)+\\min(x,y)=x+y.\n$$\n您的最终答案必须是您得到的 $\\max(x,y)$ 和 $\\min(x,y)$ 的闭式解析表达式，且仅用 $x$、$y$、加法和 $\\,\\dot{-}\\,$ 表示。无需舍入。", "solution": "该问题要求在原始递归 (PR) 函数的框架内构造前驱函数、截断减法函数、最大值函数和最小值函数，然后证明它们的代数性质。所有构造都必须从第一性原理出发，仅使用初始函数以及复合和原始递归模式进行证明。\n\n首先，我们证明加法函数 $A(x,y) = x+y$ 是原始递归的。它可以对 $y$ 进行递归定义如下：\n$$\nA(x,0) = x\n$$\n$$\nA(x, S(y)) = S(A(x,y))\n$$\n这符合原始递归模式 $f(\\vec{x}, 0) = g(\\vec{x})$ 和 $f(\\vec{x}, S(y)) = h(\\vec{x}, y, f(\\vec{x}, y))$，其中 $\\vec{x}$ 是单个变量 $x$。我们确定 $g(x) = U_1^1(x)$ 和 $h(x, y, z) = S(U_3^3(x,y,z))$。由于 $U_1^1$、$U_3^3$ 和 $S$ 是初始函数，且该定义使用了复合和原始递归，因此 $A(x,y)$ 是一个 PR 函数。\n\n现在我们继续完成问题中概述的任务。\n\n步骤 1：前驱函数 $\\mathrm{pred}(x)$\n前驱函数定义为：当 $x > 0$ 时 $\\mathrm{pred}(x) = x-1$，且 $\\mathrm{pred}(0) = 0$。我们使用对单个变量 $x$ 的原始递归模式来定义它：\n$$\n\\mathrm{pred}(0) = 0\n$$\n$$\n\\mathrm{pred}(S(x)) = x\n$$\n这个定义对应于一元原始递归模式 $f(0) = c$ 和 $f(S(x)) = h(x, f(x))$。\n基本情况是一个常数，可以用零函数 $Z(x)$ 表示。因此，我们将基值设为 $0$。\n递归步骤可以写为 $h(x, \\mathrm{pred}(x)) = x$。函数 $h(u,v) = U_1^2(u,v) = u$ 满足此条件。\n由于基值源自一个初始函数 ($Z$)，且递归步骤中的函数 $h$ 也是一个初始函数 ($U_1^2$)，因此函数 $\\mathrm{pred}(x)$ 是原始递归的。\n\n步骤 2：截断减法 $x \\dot{-} y$\n截断减法（或 monus）定义为 $x \\dot{-} y = \\max(0, x-y)$。我们使用对变量 $y$ 的原始递归来定义它：\n$$\nx \\dot{-} 0 = x\n$$\n$$\nx \\dot{-} S(y) = \\mathrm{pred}(x \\dot{-} y)\n$$\n这个定义符合通用原始递归模式 $f(x,0) = g(x)$ 和 $f(x, S(y)) = h(x, y, f(x,y))$。\n对于基本情况 $f(x,0) = x \\dot{-} 0 = x$，我们取 $g(x) = U_1^1(x)$，这是一个初始函数。\n对于递归步骤 $f(x, S(y)) = \\mathrm{pred}(f(x,y))$，我们取 $h(x,y,z) = \\mathrm{pred}(z)$。这个函数可以写成 PR 函数的复合：$h(x,y,z) = \\mathrm{pred}(U_3^3(x,y,z))$。由于我们已经证明 $\\mathrm{pred}$ 是 PR 函数，且 $U_3^3$ 是一个初始函数，根据复合的封闭性质，$h$ 也是 PR 函数。\n因此，截断减法函数 $x \\dot{-} y$ 是原始递归的。\n\n步骤 3：最大值函数和最小值函数 $\\max(x,y)$ 和 $\\min(x,y)$\n使用截断减法函数，我们可以如下定义 $\\max(x,y)$ 和 $\\min(x,y)$：\n$$\n\\max(x,y) = x + (y \\dot{-} x)\n$$\n$$\n\\min(x,y) = x \\dot{-} (x \\dot{-} y)\n$$\n为了验证这些定义，我们根据 $x$ 和 $y$ 的顺序考虑两种情况。\n情况 1：$x \\le y$。在这种情况下，$y \\dot{-} x = y-x$ 且 $x \\dot{-} y = 0$。\n$\\max(x,y) = x + (y-x) = y$。\n$\\min(x,y) = x \\dot{-} (0) = x$。\n情况 2：$x > y$。在这种情况下，$y \\dot{-} x = 0$ 且 $x \\dot{-} y = x-y$。\n$\\max(x,y) = x + 0 = x$。\n$\\min(x,y) = x \\dot{-} (x-y) = x-(x-y) = y$。\n在这两种情况下，公式都正确地得出了 $x$ 和 $y$ 的最大值和最小值。\n\n步骤 4：证明 $\\max$ 和 $\\min$ 是原始递归的\n函数 $\\max(x,y)$ 和 $\\min(x,y)$ 是通过复合那些已被证明是原始递归的函数来定义的。\n- 函数 $\\max(x,y) = x + (y \\dot{-} x)$ 是加法函数 $A(u,v)$、截断减法函数 $M(u,v)$ 和投影函数 $U_1^2(x,y)=x$ 与 $U_2^2(x,y)=y$ 的复合。具体来说，$\\max(x,y) = A(U_1^2(x,y), M(U_2^2(x,y), U_1^2(x,y)))$。由于 $A$、$M$ 和投影函数都是 PR 函数，根据复合封闭性，$\\max(x,y)$ 也是 PR 函数。\n- 函数 $\\min(x,y) = x \\dot{-} (x \\dot{-} y)$ 也是 PR 函数的复合。具体来说，$\\min(x,y) = M(U_1^2(x,y), M(U_1^2(x,y), U_2^2(x,y)))$。由于 $M$ 和投影函数是 PR 函数，根据复合封闭性，$\\min(x,y)$ 也是 PR 函数。\n\n步骤 5：$\\max$ 和 $\\min$ 的代数定律\n我们现在来建立标准的代数性质。证明依赖于对 $x$ 和 $y$ 之间序关系的情况分析。\n\n- 交换律：$\\max(x,y) = \\max(y,x)$ 和 $\\min(x,y) = \\min(y,x)$。\n  如果 $x \\le y$，则 $\\max(x,y)=y$ 且 $\\max(y,x)=y$。如果 $x > y$，则 $\\max(x,y)=x$ 且 $\\max(y,x)=x$。\n  如果 $x \\le y$，则 $\\min(x,y)=x$ 且 $\\min(y,x)=x$。如果 $x > y$，则 $\\min(x,y)=y$ 且 $\\min(y,x)=y$。\n  这两个性质都成立。\n\n- 幂等律：$\\max(x,x) = x$ 和 $\\min(x,x) = x$。\n  使用 $x \\le x$ 的情况，我们有 $\\max(x,x)=x$ 和 $\\min(x,x)=x$。\n\n- 结合律：$\\max(x,\\max(y,z)) = \\max(\\max(x,y),z)$ 和 $\\min(x,\\min(y,z)) = \\min(\\min(x,y),z)$。\n  这两个表达式都对应于求集合 $\\{x,y,z\\}$ 的最大值（或最小值）。结果与运算顺序无关。对于 $x, y, z$ 的任何排序排列，等式都成立。例如，如果 $x \\le y \\le z$：\n  $\\max(x,\\max(y,z)) = \\max(x,z) = z$。$\\max(\\max(x,y),z) = \\max(y,z) = z$。\n  $\\min(x,\\min(y,z)) = \\min(x,y) = x$。$\\min(\\min(x,y),z) = \\min(x,z) = x$。\n\n- 吸收律：$\\max(x,\\min(x,y)) = x$ 和 $\\min(x,\\max(x,y)) = x$。\n  如果 $x \\le y$，$\\min(x,y)=x$。那么 $\\max(x,\\min(x,y)) = \\max(x,x) = x$。\n  如果 $x > y$，$\\min(x,y)=y$。那么 $\\max(x,\\min(x,y)) = \\max(x,y) = x$。\n  如果 $x \\le y$，$\\max(x,y)=y$。那么 $\\min(x,\\max(x,y)) = \\min(x,y) = x$。\n  如果 $x > y$，$\\max(x,y)=x$。那么 $\\min(x,\\max(x,y)) = \\min(x,x) = x$。\n\n- 单调性：如果 $x \\le y$，那么对于任何 $z$，都有 $\\max(x,z) \\le \\max(y,z)$ 和 $\\min(x,z) \\le \\min(y,z)$。\n  我们通过对 $z$ 进行情况讨论来证明这一点。\n  对于 $\\max$：令 $x \\le y$。\n  情况 1：$z \\le x$。则 $z \\le x \\le y$。$\\max(x,z)=x$ 且 $\\max(y,z)=y$。由于 $x \\le y$，该性质成立。\n  情况 2：$x  z \\le y$。$\\max(x,z)=z$ 且 $\\max(y,z)=y$。由于 $z \\le y$，该性质成立。\n  情况 3：$z > y$。则 $x \\le y  z$。$\\max(x,z)=z$ 且 $\\max(y,z)=z$。该性质成立。\n  对于 $\\min$：令 $x \\le y$。\n  情况 1：$z \\le x$。则 $z \\le x \\le y$。$\\min(x,z)=z$ 且 $\\min(y,z)=z$。该性质成立。\n  情况 2：$x  z \\le y$。$\\min(x,z)=x$ 且 $\\min(y,z)=z$。由于 $x  z$，该性质成立。\n  情况 3：$z > y$。则 $x \\le y  z$。$\\min(x,z)=x$ 且 $\\min(y,z)=y$。由于 $x \\le y$，该性质成立。\n\n- 分解恒等式：$\\max(x,y)+\\min(x,y)=x+y$。\n  通过情况分析证明：\n  情况 1：$x \\le y$。则 $\\max(x,y) = y$ 且 $\\min(x,y) = x$。恒等式变为 $y+x=x+y$，这是成立的。\n  情况 2：$x > y$。则 $\\max(x,y) = x$ 且 $\\min(x,y) = y$。恒等式变为 $x+y=x+y$，这是成立的。\n  该恒等式在所有情况下都成立。\n\n  另外，我们也可以用代数方法证明这个恒等式。首先，我们建立引理 $(a \\dot{-} b) + b = \\max(a,b)$。\n  引理证明：如果 $a \\ge b$，则 $(a \\dot{-} b) + b = (a-b)+b = a = \\max(a,b)$。如果 $a  b$，则 $(a \\dot{-} b) + b = 0+b = b = \\max(a,b)$。引理得证。\n  现在，使用定义：\n  $\\max(x,y)+\\min(x,y) = \\max(x,y) + (x \\dot{-} (x \\dot{-} y))$。\n  我们也知道 $(x \\dot{-} y)+y = \\max(x,y)$。\n  从 $\\min(x,y) = x \\dot{-} (x \\dot{-} y)$ 出发，我们在两边同时加上 $(x \\dot{-} y)$：\n  $\\min(x,y) + (x \\dot{-} y) = (x \\dot{-} (x \\dot{-} y)) + (x \\dot{-} y)$。\n  将引理应用于右侧，令 $a=x$ 和 $b=x \\dot{-} y$，我们得到 $\\max(x, x \\dot{-} y)$。由于 $x \\ge x \\dot{-} y$，这可以简化为 $x$。\n  所以，$\\min(x,y) + (x \\dot{-} y) = x$。\n  在两边同时加上 $y$：$\\min(x,y) + (x \\dot{-} y) + y = x+y$。\n  再次使用引理，$(x \\dot{-} y) + y = \\max(x,y)$。\n  将此代入得到 $\\min(x,y) + \\max(x,y) = x+y$，证明完毕。\n\n所要求的任务已经完成。最终答案需要给出 $\\max(x,y)$ 和 $\\min(x,y)$ 的表达式。\n$\\max(x,y) = x + (y \\dot{-} x)$\n$\\min(x,y) = x \\dot{-} (x \\dot{-} y)$\n尽管存在其他等价形式，例如 $\\min(x,y)=y \\dot{-} (y \\dot{-} x)$，但推导出的表达式满足问题的要求。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\nx + (y \\dot{-} x)  x \\dot{-} (x \\dot{-} y)\n\\end{pmatrix}\n}\n$$", "id": "2979433"}, {"introduction": "原始递归函数的能力远不止于定义简单的算术运算；它们还能用于处理更复杂的数据结构，例如有限序列。通过哥德尔编码 (Gödel coding)，我们可以将这些结构表示为单个自然数，从而使其能被算术函数处理。这个练习要求您构建一个函数，它能在一个编码序列中进行搜索，这需要您利用有界$\\mu$算子 (bounded μ-operator)，它是一个功能强大且本身是原始递归的工具。[@problem_id:2979414]", "problem": "令 $\\mathbb{N}$ 表示自然数集合（包括 $0$）。在原始递归（PR）函数类中进行研究，仅从标准的原始递归基函数（零函数 $Z(n)=0$、后继函数 $S(n)=n+1$ 和投影函数 $U^{k}_{i}(n_{0},\\dots,n_{k-1})=n_{i}$）出发，以及在复合和原始递归下的闭包。你可以使用的基础事实包括：加法、乘法、有界和、有界积、截断减法和序/等式谓词的原始递归可定义性，以及被称为伯特兰-切比雪夫定理的经典数论事实（对于每个 $m \\geq 1$，都存在一个严格介于 $m$ 和 $2m$ 之间的素数）。\n\n考虑有限序列的规范素数幂编码：对于一个有限序列 $\\langle a_{0},a_{1},\\dots,a_{\\ell-1} \\rangle$ 且 $a_{i} \\in \\mathbb{N}$，其编码是自然数\n$$\n\\mathrm{code}(\\langle a_{0},\\dots,a_{\\ell-1} \\rangle)\\;=\\;\\prod_{i=0}^{\\ell-1} p_{i}^{\\,a_{i}+1},\n$$\n其中 $p_{i}$ 是第 $i$ 个素数，索引从 $p_{0}=2,p_{1}=3,p_{2}=5,\\dots$ 开始。\n\n定义一个原始递归函数 $F(c,b)$，给定一个编码 $c \\in \\mathbb{N}$ 和一个界 $b \\in \\mathbb{N}$，它扫描编码序列以寻找界内的第一个零，并返回其位置。具体来说，$F(c,b)$ 必须返回满足编码序列的第 $i$ 个分量为 $0$ 的最小的 $i  b$。如果不存在这样的 $i$，则返回 $b$。", "solution": "题目要求定义一个原始递归（PR）函数 $F(c,b)$ 来找到一个编码序列中第一个零的位置，并计算它在一个特定输入下的值。解答过程分为两个主要部分：首先，从头开始形式化地构造 $F(c,b)$ 以证明它是原始递归的；其次，计算 $F(525000, 4)$ 的值。\n\n一个函数是原始递归的，如果它是基函数之一（零函数 $Z$、后继函数 $S$、投影函数 $U^k_i$），或者可以通过有限次应用复合和原始递归从它们得到。我们已知加法、乘法、截断减法（$x \\dot{-} y = \\max(0, x-y)$）、有界和、有界积以及序/等式谓词是原始递归的。\n\n一个重要的工具是有界 $\\mu$-算子。如果 $P(i, \\vec{x})$ 是一个原始递归谓词（即，其特征函数 $\\chi_P(i, \\vec{x})$ 在 $P$ 为真时为 $1$，为假时为 $0$，是原始递归的），那么函数 $f(y, \\vec{x}) = (\\mu i  y)[P(i, \\vec{x})]$ 也是原始递归的。该函数返回使 $P(i, \\vec{x})$ 成立的最小 $i  y$；如果不存在这样的 $i$，则返回 $y$。\n\n我们的目标是使用有界 $\\mu$-算子来定义 $F(c,b)$：\n$$F(c,b) = (\\mu i  b)[\\mathrm{comp}(c,i) = 0]$$\n为此，我们需要证明谓词 $\\mathrm{comp}(c,i)=0$ 是原始递归的。$\\mathrm{comp}(c,i)$ 函数返回编码在 $c$ 中的序列的第 $i$ 个分量。\n\n1.  **素数函数 $p_i$ 的原始递归性：**\n    我们可以定义一个谓词 $\\mathrm{isPrime}(n)$，当 $n$ 是素数时为真。$n$ 是素数当且仅当 $n > 1$ 且它没有 $1  d  n$ 的除数。这可以用有界量词表示，因此 $\\mathrm{isPrime}$ 是原始递归的。\n    第 $i$ 个素数函数 $p_i$ 可以通过原始递归定义：\n    -   $p_0 = 2$\n    -   $p_{i+1} = (\\mu n \\le p_i! + 1) [n > p_i \\land \\mathrm{isPrime}(n)]$\n    这里的搜索界 $p_i! + 1$ 源自欧几里得对素数无限性的证明。伯特兰-切比雪夫定理给出了一个更紧的界 $2p_i$。由于有界最小化是原始递归的，所以 $p_i$ 是原始递归函数。\n\n2.  **分量提取函数 $\\mathrm{comp}(c,i)$ 的原始递归性：**\n    序列的第 $i$ 个分量 $a_i$ 由 $p_i$ 在 $c$ 的素数分解中的指数决定。具体来说，$a_i = (\\text{exponent of } p_i \\text{ in } c) - 1$。\n    $p_i$ 在 $c$ 中的指数可以定义为 $exp(c,i) = (\\mu k  c)[p_i^{k+1} \\nmid c]$，即 $p_i$ 整除 $c$ 的最大次数。\n    谓词 $a \\nmid b$（$a$ 不整除 $b$）等价于 $\\mathrm{mod}(b,a) \\neq 0$，其中取模函数 $\\mathrm{mod}(b,a)$ 是原始递归的。因此，指数函数 $exp(c,i)$ 是原始递归的。\n    那么，第 $i$ 个分量由 $\\mathrm{comp}(c,i) = exp(c,i) \\dot{-} 1$ 给出。\n    由于 $exp$ 和截断减法都是原始递归的，所以 $\\mathrm{comp}(c,i)$ 是一个原始递归函数。\n\n3.  **构造 $F(c,b)$：**\n    谓词 $\\mathrm{comp}(c,i) = 0$ 的特征函数 $\\chi_{=0}(\\mathrm{comp}(c,i))$ 是原始递归的。\n    因此，函数 $F(c,b) = (\\mu i  b)[\\mathrm{comp}(c,i) = 0]$ 是通过在原始递归谓词上应用有界 $\\mu$-算子定义的，所以 $F(c,b)$ 是原始递归函数。\n\n现在，我们计算 $F(525000, 4)$ 的值。\n$c = 525000$，$b = 4$。\n我们需要找到满足 $\\mathrm{comp}(525000, i) = 0$ 的最小 $i  4$。\n\n首先，我们对 $c=525000$ 进行素数分解：\n$525000 = 525 \\times 1000 = (5^2 \\times 21) \\times 10^3 = (5^2 \\times 3 \\times 7) \\times (2 \\times 5)^3 = 5^2 \\times 3 \\times 7 \\times 2^3 \\times 5^3 = 2^3 \\times 3^1 \\times 5^5 \\times 7^1$。\n\n编码使用 $c = \\prod p_i^{a_i+1}$。素数序列是 $p_0=2, p_1=3, p_2=5, p_3=7, \\dots$。\n-   对于 $i=0$（素数 $p_0=2$）：$a_0+1 = 3 \\implies a_0 = 2$。\n-   对于 $i=1$（素数 $p_1=3$）：$a_1+1 = 1 \\implies a_1 = 0$。\n-   对于 $i=2$（素数 $p_2=5$）：$a_2+1 = 5 \\implies a_2 = 4$。\n-   对于 $i=3$（素数 $p_3=7$）：$a_3+1 = 1 \\implies a_3 = 0$。\n\n编码的序列的前几个分量是 $\\langle a_0, a_1, a_2, a_3, \\dots \\rangle = \\langle 2, 0, 4, 0, \\dots \\rangle$。\n\n我们寻找满足 $a_i = 0$ 的最小 $i  4$。\n-   测试 $i=0$：$a_0 = 2 \\neq 0$。\n-   测试 $i=1$：$a_1 = 0$。条件满足。\n\n由于 $i=1$ 是满足条件的最小 $i  4$，因此 $F(525000, 4) = 1$。", "answer": "$$\\boxed{1}$$", "id": "2979414"}, {"introduction": "现在，我们将超越原始递归函数的范畴，探索更广泛的$\\mu$-递归函数。本练习的核心是无界最小化 (unbounded minimization) 或 $\\mu$ 算子，它可以定义出不一定是全函数的偏函数 (partial functions)。您将通过证明一个由无界搜索定义的特定函数实际上是全函数，并进一步找到一个原始递归的搜索上界来证明其本身也是原始递归的，从而深入理解偏函数、全函数与原始递归函数之间的精妙关系。[@problem_id:2979409]", "problem": "设 $\\mathbb{N}=\\{0,1,2,\\dots\\}$。在 $\\mathbb{N}$ 上的可计算性和可定义性的标准框架内进行研究，使用初始函数（零函数、后继函数、投影函数）、复合闭包和原始递归，以及（无界）最小化算子 $\\mu$ 作为基本构造规则。阶乘函数采用其标准形式，由原始递归从第一性原理定义：对于所有 $y\\in\\mathbb{N}$，$!\\,(0)=1$ 且 $!\\,(y+1)=(y+1)\\cdot !\\,(y)$。考虑 $\\mathbb{N}^{2}$ 上的全关系 $R(x,y)$，当且仅当 $!\\,(y)\\ge x$ 时成立。\n\n构造通过对 $R$ 进行无界最小化得到的偏递归函数 $f$：\n$$\nf(x)=\\mu y\\,\\big(R(x,y)\\big)=\\mu y\\,\\big(!\\,(y)\\ge x\\big).\n$$\n仅从刚刚陈述的基本闭包性质和定义（初始函数、复合、原始递归和最小化）出发，完成以下任务：\n\n- 严谨地构造证明 $R(x,y)$ 是一个通过原始递归和复合得到的全可计算谓词。\n- 通过对 $R$ 应用最小化来证明 $f$ 是偏递归的。\n- 通过从阶乘函数的第一性原理出发，证明对于每个输入 $x\\in\\mathbb{N}$ 都存在一个见证 $y\\in\\mathbb{N}$ 使得 $!\\,(y)\\ge x$，从而证明 $f$ 实际上是全函数。然后将其精化为一个原始递归界限 $b(x)$，使得只要 $R(x,y)$ 对某个 $y$ 成立，它也对某个 $y\\le b(x)$ 成立。使用这个界限，通过有界搜索构造，得出 $f$ 是原始递归的结论。\n- 精确地刻画 $f$ 的定义域及其发散行为。\n\n最后，计算 $f(10)$ 的精确值。以单个精确整数形式给出最终答案。不需要四舍五入，也没有单位。", "solution": "首先，我们将构造谓词 $R(x,y)$ 并证明它是原始递归的。如果一个谓词的特征函数是原始递归函数，则该谓词是原始递归的。我们将使用惯例，对于一个谓词 $P$，如果 $P$ 为真，其特征函数 $\\chi_P$ 的值为 $1$，如果 $P$ 为假，则值为 $0$。\n\n基本的（初始）原始递归函数是零函数 $Z(x)=0$、后继函数 $S(x)=x+1$ 和投影函数 $P_i^n(x_1, \\dots, x_n) = x_i$。新的原始递归函数是通过复合和原始递归模式从这些函数构建的。\n\n1.  **加法和乘法是原始递归的：**\n    加法，$add(a,b)=a+b$，由原始递归定义：\n    $add(a, 0) = a = P_1^1(a)$\n    $add(a, b+1) = S(add(a,b)) = (S \\circ P_3^3)(a, b, add(a,b))$\n    乘法，$mul(a,b)=a \\cdot b$，也使用加法通过原始递归定义：\n    $mul(a, 0) = 0 = Z(a)$\n    $mul(a, b+1) = add(a, mul(a,b)) = (add \\circ (P_1^3, P_3^3))(a, b, mul(a,b))$\n    由于加法是原始递归的，所以乘法也是原始递归的。\n\n2.  **阶乘函数是原始递归的：**\n    阶乘函数 $!\\,(y)$ 定义如下：\n    $$!\\,(0) = 1$$\n    $$!\\,(y+1) = (y+1) \\cdot !\\,(y)$$\n    这符合单变量函数的原始递归模式，$f(0)=k$ 和 $f(y+1)=h(y, f(y))$。\n    基本情况是 $!\\,(0)=1$。常数 $1$ 可以从初始函数获得，例如，作为在 $y=0$ 处求值的 $S(Z(y))$。\n    递归步骤由函数 $h(y,z) = (y+1) \\cdot z = mul(S(y), z)$ 定义。由于 $S$ 是一个初始函数且 $mul$ 是原始递归的，因此通过复合，$h(y,z) = (mul \\circ (S \\circ P_1^2, P_2^2))(y,z)$ 是原始递归的。\n    因此，阶乘函数 $!\\,(y)$ 是原始递归的。\n\n3.  **谓词 $a \\ge b$ 是原始递归的：**\n    为了证明这一点，我们首先定义“monus”或“有限减法”函数，$a \\dot{-} b = \\max(0, a-b)$。这可以通过对 $b$ 进行原始递归来定义。首先，前驱函数 $pred(y)$ 是原始递归的：$pred(0)=0$ 且 $pred(y+1)=y=P_1^2(y, pred(y))$。\n    然后，monus 定义为：\n    $a \\dot{-} 0 = a = P_1^1(a)$\n    $a \\dot{-} (b+1) = pred(a \\dot{-} b)$\n    因此 $a \\dot{-} b$ 是原始递归的。\n    谓词 $a \\le b$ 的特征函数，记为 $\\chi_{\\le}(a,b)$，可以用 monus 表示：$\\chi_{\\le}(a,b) = 1 \\dot{-} (a \\dot{-} b)$。如果 $a \\le b$，则 $a \\dot{-} b=0$ 且 $\\chi_{\\le}(a,b)=1$。如果 $a > b$，则 $a \\dot{-} b > 0$ 且 $1 \\dot{-} (a \\dot{-} b) = 0$。由于 monus 是原始递归的，所以 $\\chi_{\\le}$ 是原始递归的。\n    谓词 $R(x,y)$ 是 $!\\,(y) \\ge x$，等价于 $x \\le !\\,(y)$。它的特征函数是 $\\chi_R(x,y) = \\chi_{\\le}(x, !\\,(y))$。\n    这是原始递归函数的复合：$\\chi_R(x,y) = (\\chi_{\\le} \\circ (P_1^2, ! \\circ P_2^2))(x,y)$。\n    因此，$R(x,y)$ 是一个原始递归谓词。由于所有原始递归函数都是全函数且可计算的，所以 $R(x,y)$ 是一个全可计算谓词。\n\n接下来，我们证明 $f(x)=\\mu y\\,\\big(R(x,y)\\big)$ 是偏递归的。\n偏递归函数类是包含初始函数并对复合、原始递归和无界最小化算子 $\\mu$ 封闭的最小类。算子 $\\mu$ 通常应用于函数 $g(\\vec{z}, y)$，并产生使 $g(\\vec{z}, y)=0$ 的最小 $y$。\n为了与此定义保持一致，我们考虑 $R(x,y)$ 的补的特征函数，我们将其记为 $g(x,y)$。\n设 $g(x,y) = 1 \\dot{-} \\chi_R(x,y)$。\n由于 $\\chi_R$ 是原始递归的，并且 monus 是原始递归的，所以 $g(x,y)$ 是一个原始递归函数。\n根据构造，$g(x,y)=0$ 当且仅当 $\\chi_R(x,y)=1$，这又当且仅当 $R(x,y)$ 成立（即 $!\\,(y) \\ge x$）。\n函数 $f(x)$ 被定义为使 $R(x,y)$ 成立的最小 $y$。这恰好是 $f(x) = \\mu y \\, [g(x,y)=0]$。\n由于 $g(x,y)$ 是一个原始递归（因此是全递归）函数，通过应用 $\\mu$-算子得到的函数 $f(x)$ 根据定义是一个偏递归函数。\n\n现在，我们证明 $f$ 是一个全函数，并随后证明它是原始递归的。\n为了证明 $f$ 是全函数，我们必须证明对于每个 $x \\in \\mathbb{N}$，寻找满足 $!\\,(y) \\ge x$ 的 $y$ 的过程会终止。这需要证明对于每个 $x \\in \\mathbb{N}$，至少存在一个 $y \\in \\mathbb{N}$ 满足关系 $R(x,y)$。\n让我们考虑一个任意的 $x \\in \\mathbb{N}$。\n- 如果 $x=0$，我们可以选择 $y=0$。那么 $!\\,(0)=1$，并且 $1 \\ge 0$。所以存在一个见证。\n- 如果 $x > 0$，我们可以选择 $y=x$。我们必须检查对于 $x > 0$ 是否有 $!\\,(x) \\ge x$。\n  - 对于 $x=1$，$!\\,(1)=1 \\ge 1$。\n  - 对于 $x \\ge 2$，阶乘 $!\\,(x)$ 是一个乘积 $x \\cdot (x-1) \\cdot \\dots \\cdot 2 \\cdot 1$。我们可以写成 $!\\,(x) = x \\cdot (!(x-1))$。由于 $x \\ge 2$，我们有 $x-1 \\ge 1$，所以 $!(x-1) \\ge 1$。因此，$!\\,(x) = x \\cdot (!(x-1)) \\ge x \\cdot 1 = x$。\n所以，对于任何 $x \\in \\mathbb{N}$（如果我们把 $!\\,(-1)!$ 看作未定义，那么当 $x \\ge 1$ 时取 $y=x$ 且当 $x=0$ 时取 $y=0$ 的论证是成立的），都存在一个见证 $y$。对于 $x \\ge 1$，$y=x$ 是一个见证。\n因为对于每个输入 $x$ 都存在一个见证 $y$，搜索 $\\mu y \\, [!\\,(y) \\ge x]$ 总是会终止。因此，$f(x)$ 是一个全函数。\n\n为了证明 $f$ 是原始递归的，我们使用这样一个事实：如果搜索可以被一个原始递归函数所界定，那么由最小化算子定义的总函数是原始递归的。\n如上所示，对于任何 $x \\in \\mathbb{N}$，都可以找到一个见证 $y$ 使得 $y \\le x$。\n- 对于 $x=0$，$f(0)=0$，且 $0 \\le 0$。\n- 对于 $x=1$，$f(1) = \\mu y [!\\,(y) \\ge 1]$。对于 $y=0$，$!\\,(0)=1 \\ge 1$，所以 $f(1)=0$。我们有 $0 \\le 1$。\n- 对于 $x \\ge 2$，我们证明了 $!\\,(x) \\ge x$。这意味着在寻找最小 $y$ 的过程中，保证在 $y=x$ 或之前找到一个解。因此，$f(x) \\le x$。\n在所有情况下，对于任何 $x \\in \\mathbb{N}$，我们都有 $f(x) \\le x$。\n这意味着无界搜索可以被有界搜索替代：\n$$f(x) = \\mu y_{\\le x} \\, [!\\,(y) \\ge x]$$\n搜索界限由函数 $b(x)=x$ 给出，这是恒等函数 $P_1^1(x)$，是一个初始函数，因此是原始递归的。\n在原始递归谓词上通过有界最小化定义的函数本身就是原始递归的。我们可以通过构造来证明这一点。如前所述，设 $g(x,y)=1 \\dot{-} \\chi_R(x,y)$。\n那么 $f(x)$ 可以写成：\n$$f(x) = \\sum_{k=0}^{x} \\left( \\prod_{i=0}^{k} g(x,i) \\right)$$\n这个公式之所以有效，是因为乘积项 $\\prod_{i=0}^{k} g(x,i)$ 在所有 $i \\le k$ 的 $g(x,i)$ 都为 $1$ 时为 $1$，否则为 $0$。这个和计算了有多少个初始连续的 $y$ 值不满足条件。对于第一个满足条件的 $y$，比如说 $y_0$，有 $g(x, y_0)=0$，并且对于 $k \\ge y_0$ 的乘积项变为 $0$。这个和将是 $\\sum_{k=0}^{y_0-1} 1 = y_0$。\n由于 $g(x,y)$ 是原始递归的，并且原始递归函数在有界和与有界积下是封闭的，这个构造表明 $f(x)$ 是原始递归的。\n\n定义域和发散行为的刻画：\n我们已经证明，对于每个 $x \\in \\mathbb{N}$，都存在一个 $y \\in \\mathbb{N}$ 使得 $!\\,(y) \\ge x$。这意味着最小化过程总是终止的。\n- $f$ 的定义域是所有自然数的集合，即 $\\mathbb{N}$。\n- 函数 $f(x)$ 是全函数，这意味着它对每个输入 $x \\in \\mathbb{N}$ 都有定义。因此，不存在使 $f(x)$ 发散的 $x$ 值。$f$ 发散的点集是空集 $\\emptyset$。\n\n最后，我们计算 $f(10)$ 的精确值。\n函数是 $f(x) = \\mu y \\, [!\\,(y) \\ge x]$。对于 $x=10$，我们需要找到满足 $!\\,(y) \\ge 10$ 的最小自然数 $y$。\n我们从 $y=0$ 开始测试 $y$ 的值：\n- 对于 $y=0$：$!\\,(0) = 1$。条件 $1 \\ge 10$ 为假。\n- 对于 $y=1$：$!\\,(1) = 1$。条件 $1 \\ge 10$ 为假。\n- 对于 $y=2$：$!\\,(2) = 2$。条件 $2 \\ge 10$ 为假。\n- 对于 $y=3$：$!\\,(3) = 6$。条件 $6 \\ge 10$ 为假。\n- 对于 $y=4$：$!\\,(4) = 24$。条件 $24 \\ge 10$ 为真。\n由于 $y=4$ 是使该条件成立的最小自然数，我们有 $f(10)=4$。", "answer": "$$\\boxed{4}$$", "id": "2979409"}]}