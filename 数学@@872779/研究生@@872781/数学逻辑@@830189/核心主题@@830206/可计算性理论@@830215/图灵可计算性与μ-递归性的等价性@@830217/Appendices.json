{"hands_on_practices": [{"introduction": "图灵机和μ-递归函数理论中的许多核心定义，例如通用图灵机（UTM）或克林范式（Kleene's Normal Form），通常是围绕单参数函数建立的。然而，我们研究的大多数函数都接受多个参数。这个练习探讨了如何通过编码技术弥合这一差距，特别是如何使用原始递归配对函数将多个自变量压缩成一个单一的自然数，从而使单输入计算模型能够统一处理任意元数的函数。[@problem_id:2972625]", "problem": "考虑一个部分函数 $f \\colon \\mathbb{N}^k \\rightharpoonup \\mathbb{N}$，其中 $\\mathbb{N}$ 表示自然数集。为了证明图灵可计算性与$\\mu$-递归性之间的等价性，一个标准步骤是将任意元数的输入归约为通用图灵机（UTM）的固定一元输入。此处的通用图灵机定义为：给定一个程序索引和一个输入的二进制编码，它能模拟该程序在此输入上的运行。从以下基本基础开始：\n\n- 一个部分$\\mu$-递归函数是包含初始函数（零函数、后继函数和投影函数）并对复合、原始递归和最小化（$\\mu$-算子）运算封闭的最小函数类中的任意函数。\n- 如果存在一个图灵机，当输入为参数的二进制编码时，在其函数有定义的情况下停机并输出结果的二进制编码，否则发散，则该函数是图灵可计算的。\n- 配对函数是一个双射 $\\langle \\cdot, \\cdot \\rangle \\colon \\mathbb{N} \\times \\mathbb{N} \\to \\mathbb{N}$，配备有投影 $\\pi_1, \\pi_2 \\colon \\mathbb{N} \\to \\mathbb{N}$，使得对于所有 $x,y \\in \\mathbb{N}$，都有 $\\pi_1(\\langle x,y\\rangle)=x$ 和 $\\pi_2(\\langle x,y\\rangle)=y$。\n- 数码编码 $\\mathrm{bin} \\colon \\mathbb{N} \\to \\{0,1\\}^\\star$ 将 $n \\in \\mathbb{N}$ 映射到一个表示 $n$ 的二进制字符串，其编码器和解码器在需要时是原始递归的，以保证组合编码保持在$\\mu$-递归框架内。\n\n选择所有正确描述了一种机制的选项，该机制确保具有单一自然数固定二进制输入表示的UTM，能够通过柯里化和配对将多参数输入归约为一元输入，从而统一处理任意元数，且此方式与图灵可计算性和$\\mu$-递归性均兼容。\n\nA. 选择一个原始递归的双射配对 $\\langle x,y\\rangle$，其具有原始递归的全投影 $\\pi_1$ 和 $\\pi_2$，通过迭代配对定义 $k$-元组编码，并固定一个原始递归的二进制数码编码 $\\mathrm{bin}$ 及其解码器；\n然后使用替换定理（通常表示为$s$-$m$-$n$定理）来柯里化程序索引并减少元数，以便UTM接收一个表示配对后输入的单一二进制字符串。\n\nB. 任何单射配对 $\\langle x,y\\rangle$ （即使是不可计算的）都足够了，因为UTM只需要接收单一的二进制编码，而不依赖于解码映射 $\\pi_1$ 和 $\\pi_2$ 的可计算性。\n\nC. 向前配对 $\\langle x,y\\rangle$ 是原始递归的，而其逆投影 $\\pi_1$ 和 $\\pi_2$ 仅通过无界最小化（$\\mu$-算子）成为部分函数，这是可以接受的，因为解码只应用于 $\\langle x,y\\rangle$ 值域中的元素。\n\nD. 仅凭柯里化就足够了，无需任何配对，因为替换定理（通常表示为$s$-$m$-$n$定理）可以减少元数；\nUTM可以顺序接受参数，而无需将它们转换为单一的一元输入，因此不需要一个自然数的固定二进制输入表示。\n\nE. 使用Cantor配对函数 $\\langle x,y\\rangle = \\frac{1}{2}(x+y)(x+y+1)+y$，其正向映射和逆投影都是原始递归的，迭代它来编码 $k$-元组，并采用一个无前缀的二进制数码编码（例如，一元表示的长度后跟二进制数字），其编码/解码是原始递归的；\n然后应用替换定理（通常表示为$s$-$m$-$n$定理）来柯里化程序索引，以便UTM处理任意元数的单一二进制输入。", "solution": "首先将对问题陈述的科学合理性、自洽性和清晰度进行验证。\n\n### 步骤1：提取已知条件\n\n- 考虑一个部分函数 $f \\colon \\mathbb{N}^k \\rightharpoonup \\mathbb{N}$，其中 $\\mathbb{N}$ 是自然数集。\n- 上下文是证明图灵可计算性与$\\mu$-递归性之间的等价性。\n- 具体任务是将任意元数的输入归约为通用图灵机（UTM）的固定一元输入。\n- UTM被定义为一个图灵机，它在给定程序索引和输入的二进制编码后，模拟该程序在该输入上的运行。\n- 一个部分$\\mu$-递归函数属于包含初始函数（零、后继、投影）并对复合、原始递归和最小化（$\\mu$-算子）封闭的最小函数类。\n- 如果一个图灵机在二进制编码的输入上当且仅当函数有定义时停机并输出二进制编码的结果，则该函数是图灵可计算的。\n- 配对函数是一个双射 $\\langle \\cdot, \\cdot \\rangle \\colon \\mathbb{N} \\times \\mathbb{N} \\to \\mathbb{N}$，带有投影 $\\pi_1, \\pi_2$，使得 $\\pi_1(\\langle x,y\\rangle)=x$ 和 $\\pi_2(\\langle x,y\\rangle)=y$。\n- 数码编码 $\\mathrm{bin} \\colon \\mathbb{N} \\to \\{0,1\\}^\\star$ 将一个自然数 $n$ 映射到一个二进制字符串，并要求编码器和解码器是原始递归的。\n- 问题要求识别出正确的机制，使得一个接收单一二进制编码自然数的UTM能够处理任意元数的函数。这种归约涉及柯里化和配对，并且必须与两种计算模型兼容。\n\n### 步骤2：使用提取的已知条件进行验证\n\n根据既定标准对问题陈述进行评估。\n\n- **科学依据充分：** 该问题植根于可计算性理论，这是数理逻辑和理论计算机科学的一个基础领域。所提供的所有定义——图灵机、UTM、$\\mu$-递归函数、配对函数、$s$-$m$-$n$定理——都是该领域的标准和核心概念。证明图灵可计算性和$\\mu$-递归性的等价性是一个经典的基础性成果。\n- **问题定义良好：** 问题结构清晰。它要求评估在一个更大证明中一个标准技术步骤（元数归约）的几种提议机制。问题具体，可以从可计算性理论的原理中推导出确切的答案。\n- **客观性：** 语言形式化且无歧义，使用了既定的术语。没有主观或基于意见的断言。\n\n该问题没有表现出任何无效性缺陷：\n1.  它在科学上和事实上是合理的。\n2.  它与*图灵可计算性与μ-递归性的等价性*这一主题直接相关。\n3.  其设定是自洽且一致的。\n4.  这是一个理论问题，因此物理现实性不适用。\n5.  它定义良好，允许一个稳定且有意义的解。\n6.  该问题并非微不足道；它涉及了等价性证明中一个关键且概念上详细的方面。\n7.  其主张在数理逻辑的框架内是可验证的。\n\n### 步骤3：结论与行动\n\n问题陈述是**有效的**。将推导一个完整的解法。\n\n### 解法推导与选项分析\n\n问题的核心在于，在函数 $f(x_1, \\dots, x_k)$（一个具有 $k$ 个参数的函数）与一个可由通用图灵机（UTM）处理的单参数函数之间，建立一个可计算的对应关系。一个标准的UTM模型被定义为计算一个函数 $\\varphi_e(z)$，其中 $e$ 是程序的索引，$z$ 是一个表示输入的单一自然数。\n\n为了弥合 $k$ 个参数 $(x_1, \\dots, x_k)$ 和单一输入 $z$ 之间的差距，我们必须将该元组编码为一个单一的数字。这通过迭代一个配对函数来实现。如果 $\\langle \\cdot, \\cdot \\rangle \\colon \\mathbb{N} \\times \\mathbb{N} \\to \\mathbb{N}$ 是一个配对函数，我们可以递归地定义一个 $k$-元组编码，例如：\n$$ \\langle x_1, \\dots, x_k \\rangle_k = \\langle x_1, \\langle x_2, \\dots, x_k \\rangle_{k-1} \\rangle $$\n其中 $\\langle x \\rangle_1 = x$。\n\n为了使整个构造在证明图灵可计算性和$\\mu$-递归性等价性的过程中有效，那些“胶水”操作——将元组编码为数字以及将数字编码为二进制字符串——本身必须在一种简单、基础的意义上是可计算的。标准要求是这些操作是**原始递归的**。原始递归函数类是全$\\mu$-递归函数的一个子集，并且已知也是图灵可计算的。使用原始递归函数作为这种“胶水”，可以确保编码方案本身不会增加额外的计算能力，否则会破坏等价性证明。\n\n计算 $f$ 的程序必须能够将单一输入 $z$ 解码回原始参数 $x_1, \\dots, x_k$。这要求与配对函数相关联的投影函数也必须是可计算的，并且同样最好是原始递归的。\n\n替换定理，或称$s$-$m$-$n$定理，是可计算性理论中的一个关键结果，它形式化了部分求值或柯里化的概念。它指出，对于一个双变量的可计算函数 $\\varphi_e(x, y)$，存在一个原始递归函数 $s(e, x)$，它产生一个新的程序索引 $s(e, x)$，使得对于所有的 $y$，都有 $\\varphi_{s(e,x)}(y) = \\varphi_e(x, y)$。这个定理支撑了通用机的能力及其被编程的灵活性。\n\n基于这些背景，我们来评估每个选项。\n\n**A. 选择一个原始递归的双射配对 $\\langle x,y\\rangle$，其具有原始递归的全投影 $\\pi_1$ 和 $\\pi_2$，通过迭代配对定义 $k$-元组编码，并固定一个原始递归的二进制数码编码 $\\mathrm{bin}$ 及其解码器；然后使用替换定理（通常表示为$s$-$m$-$n$定理）来柯里化程序索引并减少元数，以便UTM接收一个表示配对后输入的单一二进制字符串。**\n\n这个选项正确地指出了一个标准的、有效机制所需的所有组成部分。\n- **具有原始递归全投影的原始递归双射配对：** 这是正确且标准的要求。双射性确保了每个数对都有唯一的编码。配对函数及其投影的原始递归性确保了元组的编码和解码在计算上是“简单的”，并且不会增加超出基础计算模型的能力。\n- **迭代配对以编码$k$-元组：** 这是将配对推广到任意元组的标准方法。\n- **原始递归的数码编码/解码：** 这对于在$\\mu$-递归的抽象自然数和图灵机磁带上的二进制字符串之间进行转换至关重要，且不会引入不可计算的步骤。\n- **使用$s$-$m$-$n$定理：** 这个定理是可计算性理论的基石，它形式化了程序如何被特化，这在概念上与UTM如何通过编码方案处理为不同元数设计的程序相关联。数据配对与$s$-$m$-$n$定理的形式化能力相结合，提供了完整的图景。\n\n这个选项描述了通用、抽象且正确的框架。\n**结论：正确。**\n\n**B. 任何单射配对 $\\langle x,y\\rangle$ （即使是不可计算的）都足够了，因为UTM只需要接收单一的二进制编码，而不依赖于解码映射 $\\pi_1$ 和 $\\pi_2$ 的可计算性。**\n\n这个选项有根本性错误。被UTM模拟的机器或程序*必须*能够访问各个参数 $x_1, \\dots, x_k$。为此，它必须解码单一输入 $z = \\langle x_1, \\dots, x_k \\rangle_k$。这个解码过程需要应用投影函数。如果投影 $\\pi_1$ 和 $\\pi_2$ 是不可计算的，那么就没有算法可以从编码后的输入中恢复原始参数。计算将无法进行。声称UTM（或它模拟的程序）不依赖于解码映射的可计算性是错误的。\n**结论：不正确。**\n\n**C. 向前配对 $\\langle x,y\\rangle$ 是原始递归的，而其逆投影 $\\pi_1$ 和 $\\pi_2$ 仅通过无界最小化（$\\mu$-算子）成为部分函数，这是可以接受的，因为解码只应用于 $\\langle x,y\\rangle$ 值域中的元素。**\n\n这个选项因几个原因而不正确。\n- 前提声明配对函数是双射 $\\langle \\cdot, \\cdot \\rangle \\colon \\mathbb{N} \\times \\mathbb{N} \\to \\mathbb{N}$。对于双射而言，其逆函数定义在整个陪域 $\\mathbb{N}$ 上，因此投影 $\\pi_1(z)$ 和 $\\pi_2(z)$ 必须是全函数，而不是部分函数。\n- 即使我们放宽条件为单射（非满射），这会使投影在 $\\mathbb{N}$ 上成为部分函数，但对于这些基础的投影函数依赖于$\\mu$-算子（无界最小化）的全部能力，也是非标准且有问题的。目标是使用最简单的工具来构建框架的“胶水”。原始递归是此处的标准，因为它保证终止，并且是比一般$\\mu$-递归更弱的计算类。\n- 可以证明，如果一个配对函数是原始递归的，它的投影也可以被构造成原始递归的（通常使用有界最小化，这是一种原始递归操作）。没有必要求助于更强大且可能不终止的无界$\\mu$-算子。使用它会不必要地使证明结构复杂化。\n**结论：不正确。**\n\n**D. 仅凭柯里化就足够了，无需任何配对，因为替换定理（通常表示为$s$-$m$-$n$定理）可以减少元数；UTM可以顺序接受参数，而无需将它们转换为单一的一元输入，因此不需要一个自然数的固定二进制输入表示。**\n\n这个选项与问题的前提相矛盾。问题明确规定了UTM“具有单一自然数固定二进制输入表示”的约束。而这个选项声称这样的表示是不必要的。图灵机和UTM的标准定义都是从单个磁带上的单个输入字符串开始的。“顺序接受参数”意味着一种不同的计算模型（例如，预言机，或带有独立输入流的机器），而不是证明此等价性时所用的标准模型。虽然$s$-$m$-$n$定理确实通过柯里化形式化了元数归约，但它是通过创建新程序来实现的。配对机制才是让一个固定的UTM程序能够模拟任何其他程序处理多参数输入的方法，这些多参数输入已被打包成UTM期望的单输入格式。\n**结论：不正确。**\n\n**E. 使用Cantor配对函数 $\\langle x,y\\rangle = \\frac{1}{2}(x+y)(x+y+1)+y$，其正向映射和逆投影都是原始递归的，迭代它来编码 $k$-元组，并采用一个无前缀的二进制数码编码（例如，一元表示的长度后跟二进制数字），其编码/解码是原始递归的；然后应用替换定理（通常表示为$s$-$m$-$n$定理）来柯里化程序索引，以便UTM处理任意元数的单一二进制输入。**\n\n这个选项提出了一个具体且正确的实现，体现了选项A中概述的抽象原则。\n- **Cantor配对函数：** 这是配对函数的一个经典例子。它是从 $\\mathbb{N} \\times \\mathbb{N}$ 到 $\\mathbb{N}$ 的双射，其正向函数及其投影都是众所周知的原始递归函数。\n- **无前缀二进制编码：** 这是数码编码的一种方法论上合理的选择。标准二进制不是无前缀的（例如，表示2的字符串`10`是表示5的`101`的前缀），这在连接编码时可能导致歧义。使用无前缀方案（其中没有编码是另一个编码的前缀）确保了序列的唯一可解码性。要求编码和解码函数是原始递归的也是正确的。\n- **迭代和使用$s$-$m$-$n$定理：** 如同选项A，这些是整个机制中正确和标准的部分。\n\n这个选项提供了所需机制的一个具体、有效且稳健的例子。它满足了所有必要标准。\n**结论：正确。**", "answer": "$$\\boxed{AE}$$", "id": "2972625"}, {"introduction": "μ-算子（无界极小化）是μ-递归函数论中获得图灵完备计算能力的关键，但它也引入了部分性（partiality）的可能。当μ-算子所作用的谓词本身是一个可能永不终止的部分计算时，一个简单的顺序搜索策略会失败。本练习深入探讨了“交错计算”（dovetailing）这一精妙的模拟技术，它能确保在所有必要的子计算中公平地分配计算资源，从而在图灵机上正确地实现μ-算子的复杂语义。[@problem_id:2972630]", "problem": "设 $R \\colon \\mathbb{N}^2 \\rightharpoonup \\mathbb{N}$ 是一个部分可计算函数，并假设 $R$ 由一台固定的图灵机 $M_R$ 计算，该图灵机在输入 $(x,y)$ 时，要么停机并给出一个在 $\\mathbb{N}$ 中的输出，要么发散。考虑将无界最小化算子 $\\mu$ 应用于 $R$ 来定义一个部分函数 $f \\colon \\mathbb{N} \\rightharpoonup \\mathbb{N}$，其定义如下：\n$$\nf(x) = \\mu y \\, [ R(x,y) = 0 ],\n$$\n其语义如下：$f(x)$ 定义为使得 $R(x,y)$ 停机并输出 $0$ 的最小的 $y$，前提是对于所有的 $z  y$，计算 $R(x,z)$ 都停机（且输出必然不等于 $0$）；\n否则 $f(x)$ 未定义。这是在定义部分$\\mu$-递归函数时使用的标准无界$\\mu$-最小化模式。\n\n在证明图灵可计算性与$\\mu$-递归性等价时，必须展示如何在图灵机上模拟$\\mu$-算子，即使 $R$ 本身是由一个部分计算给出的。一个正确的模拟必须满足两个约束条件：\n- 它必须在外延上与上述$\\mu$-语义一致，即，只有当所有更小的索引都已停机并给出非零输出时，它才返回使得 $R(x,y)=0$ 的最小的 $y$，并且在定义所规定的情况下发散。\n- 它必须确保在搜索空间 $y \\in \\mathbb{N}$ 和进行中的 $M_R(x,y)$ 计算中都有公平的进展，以至于没有单个索引 $y$ 或 $M_R(x,y)$ 的模拟会因分配不到计算步骤而“饿死”。\n\n下列哪种策略描述了一个正确的、用于从 $M_R$ 计算 $f(x)$ 的燕尾模拟？\n\nA. 对于输入 $x$，为所有 $y \\in \\mathbb{N}$ 初始化一个模拟状态数组 $\\sigma_y$，每个状态都设置为 $M_R$ 在输入 $(x,y)$ 上的起始配置。分阶段 $s = 0,1,2,\\dots$ 进行。在阶段 $s$，对每个 $y \\le s$，将模拟 $\\sigma_y$ 精确地推进 $M_R$ 的一步。维护一个结果表，记录对每个 $y$，$M_R(x,y)$ 是否已停机，如果停机，输出了什么。每个阶段结束后，检查是否存在某个 $y$ 使得：\n- $M_R(x,y)$ 已停机并输出 $0$，并且\n- 对于所有 $z  y$，$M_R(x,z)$ 已停机并输出不等于 $0$ 的值。\n如果存在这样的 $y$，则输出最小的那个 $y$ 并停机；\n否则继续下一阶段。如果永远没有这样的 $y$ 满足这些条件，则模拟永不停机。\n\nB. 对于输入 $x$，按顺序测试索引。对于 $y = 0,1,2,\\dots$，运行 $M_R(x,y)$ 直至完成。如果它停机并输出 $0$，则输出 $y$ 并停机；\n如果它停机但输出非零，则增加 $y$ 并重复；\n如果它发散，则永远循环，不再考虑更大的 $y$。\n\nC. 对于输入 $x$，分阶段 $s = 0,1,2,\\dots$ 对模拟进行燕尾操作；\n在阶段 $s$，对所有 $y \\le s$，执行 $M_R(x,y)$ 模拟的一步。一旦任何一个 $M_R(x,y)$ 停机并输出 $0$，立即输出 $y$ 并停机，而不检查更小索引的状态。\n\nD. 对于输入 $x$，分阶段 $s = 0,1,2,\\dots$ 对模拟进行燕尾操作。在阶段 $s$，对所有 $y \\le s$，执行 $M_R(x,y)$ 模拟的一步。当某个 $M_R(x,y)$ 停机并输出 $0$ 时，如果对于每个 $z  y$，$M_R(x,z)$ 要么已经停机并输出了一个非零值，要么已经被模拟了超过 $y$ 步，则输出 $y$ 并停机；\n否则继续。\n\n选择所有同时满足公平进展约束和上述$\\mu$-语义的选项。", "solution": "问题要求为应用于部分可计算函数 $R(x,y)$ 的无界最小化算子 $\\mu$ 提供一个正确的模拟策略，以计算 $f(x) = \\mu y \\, [ R(x,y) = 0 ]$。这个操作提供的语义至关重要：$f(x)$ 有定义且等于 $y$ 的充要条件是 $R(x,y)=0$ 并且对于所有的 $z  y$，$R(x,z)$ 有定义且非零。否则，$f(x)$ 未定义。一个正确的模拟（将由图灵机执行）必须满足两个约束：公平进展和外延正确性。\n\n让我们为正确的模拟建立核心原则。\n$R \\colon \\mathbb{N}^2 \\rightharpoonup \\mathbb{N}$ 是一个部分可计算函数，意味着对于任何给定的输入 $(x,y)$，其图灵机 $M_R$ 对 $R(x,y)$ 的计算可能不会停机。为了计算 $f(x)$，我们可能需要对无限多个 $y \\in \\{0, 1, 2, \\dots\\}$ 的值计算 $R(x,y)$。\n\n1.  **公平进展**：由于任何单个计算 $M_R(x,y)$ 都可能发散，顺序搜索（测试 $y=0$，然后 $y=1$，等等，每个都运行到完成）是不可行的。如果 $M_R(x,0)$ 发散，模拟就会卡住，永远不会测试 $y=1, 2, \\dots$。因此，必须有一种交错执行不同 $y$ 值计算的方法。这种技术被称为**燕尾模拟 (dovetailing)**。一种常见的方法是分阶段进行，$s=0, 1, 2, \\dots$。在每个阶段 $s$，对一个不断增长但有限的计算集（例如，对所有 $y \\le s$ 的 $M_R(x,y)$）执行有限量的工作。这确保了对于任何 $y$ 和任何步数 $k$，总会有一个阶段 $s$，到那时 $M_R(x,y)$ 的模拟已经执行了至少 $k$ 步。这可以防止饿死现象。\n\n2.  **外延正确性**：模拟必须严格遵守给定的 $\\mu$ 语义。在任何时候，如果模拟停机并输出一个值 $y$，它必须已经验证了以下条件：\n    a. $M_R(x,y)$ 的计算已停机并输出 $0$。\n    b. 对于所有自然数 $z  y$，$M_R(x,z)$ 的计算已停机并输出不等于 $0$ 的值。\n    c. 该值 $y$ 是满足条件 (a) 的最小自然数。\n\n如果对于给定的 $x$，不存在这样的 $y$，模拟必须永不停机，从而正确地反映 $f(x)$ 是未定义的。例如，如果最小的使得 $R(x,y)=0$ 的 $y$ 存在，但对于某个 $z  y$，$R(x,z)$ 是未定义的，就会发生这种情况。\n\n现在，我们根据这些原则来评估每种提出的策略。\n\n**选项 A：**\n\n该策略提出了一种按阶段 $s = 0, 1, 2, \\dots$ 组织的燕尾模拟。在阶段 $s$，它将所有 $y \\le s$ 的 $M_R(x,y)$ 模拟推进一个步骤。这是一个有效的燕尾方案，确保了对 $y$ 的搜索和每个独立计算 $M_R(x,y)$ 的执行都具有公平进展。\n\n对于外延正确性，在每个阶段之后，该策略检查是否存在一个满足$\\mu$-算子精确条件的 $y$：\n1.  $M_R(x,y)$ 已停机并输出 $0$。\n2.  对于所有 $z  y$，$M_R(x,z)$ 已停机并输出一个非 $0$ 的值。\n\n如果找到这样一个 $y$，策略会输出*最小*的那个 $y$。这个检查是 $f(x)$ 定义的直接实现。如果 $f(x)=y$ 的条件得到满足，那么所有相关的计算（对于 $z \\le y$）最终都会停机。基于阶段的模拟保证了会存在一个阶段 $s$，到该阶段时所有这些计算都已完成。在那个阶段或此后不久，检查将成功，算法将找到满足标准的最小 $y$ 并以正确的输出停机。如果不存在这样的 $y$，条件将永远不会被满足，模拟将正确地永远运行下去。该策略同时满足了公平进展和外延正确性。\n\n结论：**正确**。\n\n**选项 B：**\n\n该策略提出了一种顺序搜索：测试 $y=0$，然后 $y=1$，依此类推，将每个计算 $M_R(x,y)$ 运行到完成。这种方法从根本上违反了公平进展约束。例如，如果 $R(x,0)$ 未定义，对 $M_R(x,0)$ 的模拟将永远运行。算法将永久地卡在 $y=0$ 的情况上，永远不会继续测试 $y=1, 2, \\dots$，即使 $f(x)$ 本应被定义为大于 $0$ 的某个值（或者，根据规则，由于其他原因而未定义）。这是燕尾模拟旨在避免的经典陷阱。\n\n结论：**不正确**。\n\n**选项 C：**\n\n该策略使用了与选项A相同的正确燕尾方法来实现公平进展。然而，它在外延正确性上失败了。停机条件是“一旦*任何* $M_R(x,y)$ 停机并输出 $0$，立即输出 $y$ 并停机”。这有两方面的缺陷：\n1.  它不保证最小性。对于一个较大的 $y_1$ 的计算 $M_R(x,y_1)$ 可能比一个较小的 $y_0$ 的计算 $M_R(x,y_0)$ 短得多，而两者都得到 $0$。该策略可能过早地以 $y_1$ 停机，违反了$\\mu$-算子的“最小 $y$”要求。\n2.  它完全忽略了一个关键条件，即要使 $f(x)$ 为 $y$，所有对于 $z  y$ 的计算 $M_R(x,z)$ 必须已经停机并输出非零值。即使其中一个必需的先验计算，比如说 $M_R(x,0)$，仍在运行或已发散，该策略也会错误地产生一个输出。\n\n结论：**不正确**。\n\n**选项 D：**\n\n该策略也使用了正确的燕尾方法，确保了公平进展。然而，它的停机条件是对选项 C 中问题的有缺陷的修正尝试。它建议，如果 $M_R(x,y)$ 产生 $0$，并且对于每个 $z  y$，$M_R(x,z)$ 要么已经以非零输出停机，要么已经被模拟了“超过 $y$ 步”，则停机并输出 $y$。 “或已经被模拟了超过 $y$ 步”这一条款是不合理的。在可计算性理论中，没有定理表明，如果一个计算在一定步数（与另一个计算的输出值相关）后没有停机，就可以假定它要么发散，要么产生一个不干扰的结果。一个计算 $M_R(x,z)$ 可能运行 $y+100$ 步然后以输出 $0$ 停机，这意味着 $y$ 不是最小值。或者它可能运行 $y+100$ 步然后发散，这意味着 $f(x)$ 应该是未定义的。条件要求这些计算*实际停机*。该策略做出了一个未经证实的猜测，因此未能做到外延正确。\n\n结论：**不正确**。", "answer": "$$\\boxed{A}$$", "id": "2972630"}, {"introduction": "我们关于“可计算”的强大概念是否依赖于我们记录数字的具体方式（例如，二进制或十进制）？本练习探讨了这个根本性问题，旨在检验可计算性定义的稳健性。通过分析，我们将看到，只要编码和解码过程本身是可计算的，可计算函数类在任何数字的重新编码下都是不变的，这突显了丘奇-图灵论题（Church-Turing thesis）所揭示的可计算性概念的深刻普适性。[@problem_id:2972645]", "problem": "令 $\\mathbb{N}$ 表示自然数集。考虑部分μ-递归函数 $f:\\mathbb{N}^k\\rightharpoonup\\mathbb{N}$，它们由初始函数（零函数、后继函数、投影函数）通过在复合、原始递归和无界极小化下封闭而得到。一个函数是图灵可计算的，如果它能被图灵机 (TM) 在从 $\\mathbb{N}^k$ 到 $\\mathbb{N}$ 的输入的标准编码上计算出来。一个经过充分检验的事实是，部分μ-递归函数类与图灵可计算的部分函数类是重合的。\n\n固定元数 $k\\geq 1$。假设我们通过一个双射 $e:\\mathbb{N}\\to\\mathbb{N}$ 来改变输入和输出的编码。定义逐分量提升 $e^{(k)}:\\mathbb{N}^k\\to\\mathbb{N}^k$ 为 $e^{(k)}(x_1,\\dots,x_k)=(e(x_1),\\dots,e(x_k))$，以及其逆的逐分量提升 $\\left(e^{-1}\\right)^{(k)}$。给定一个部分函数 $f:\\mathbb{N}^k\\rightharpoonup\\mathbb{N}$，定义转换后的函数 $g:\\mathbb{N}^k\\rightharpoonup\\mathbb{N}$ 为\n$$\ng \\;=\\; e^{-1}\\circ f\\circ e^{(k)}.\n$$\n在下面的选项中，每个陈述描述了在这种编码改变下，可计算函数类（在图灵可计算性和μ-递归性的意义上）被保持、反映或未能保持的条件。选择所有正确的陈述。\n\nA. 如果 $e$ 和 $e^{-1}$ 是原始递归全函数，那么对于每一个 $k\\geq 1$ 和每一个部分函数 $f:\\mathbb{N}^k\\rightharpoonup\\mathbb{N}$，$f$ 是图灵可计算的（等价于部分μ-递归的）当且仅当 $g=e^{-1}\\circ f\\circ e^{(k)}$ 是图灵可计算的（等价于部分μ-递归的）。\n\nB. $e$ 是一个双射就足够了；在转换 $g=e^{-1}\\circ f\\circ e^{(k)}$ 下，对于可计算性的保持和反映，不需要对 $e$ 或 $e^{-1}$ 有任何可计算性条件。\n\nC. 在 $g=e^{-1}\\circ f\\circ e^{(k)}$ 下的保持性仅对全函数 $f:\\mathbb{N}^k\\to\\mathbb{N}$ 成立；对于部分函数 $f:\\mathbb{N}^k\\rightharpoonup\\mathbb{N}$，即使当 $e$ 和 $e^{-1}$ 是原始递归时，该性质也可能不成立。\n\nD. 在 $g=e^{-1}\\circ f\\circ e^{(k)}$ 下的保持性要求 $e$ 和 $e^{-1}$ 在固定的时间界限内（例如，多项式时间）是可计算的；否则μ-递归性定义中的无界极小化无法被模拟，因此可计算性可能会丢失。\n\nE. 即使 $e$ 和 $e^{-1}$ 是原始递归的，保持性也可能不成立，除非同时假设存在一个原始递归的元组编码/解码来将 $\\mathbb{N}^k$ 表示为 $\\mathbb{N}$；没有这个额外假设，通过 $e$ 和 $e^{-1}$ 的前复合和后复合可能无法被μ-递归性的封闭性质所吸收。", "solution": "问题要求找出双射 $e:\\mathbb{N}\\to\\mathbb{N}$ 满足何种条件时，将函数 $f:\\mathbb{N}^k\\rightharpoonup\\mathbb{N}$ 转换为 $g = e^{-1}\\circ f\\circ e^{(k)}$ 的操作会保持图灵可计算（等价于部分μ-递归）的性质。\n\n令元数为 $k$ 的部分可计算函数类表示为 $\\mathcal{C}_k$。问题是，在 $e$ 满足什么条件下，对于任何 $f:\\mathbb{N}^k\\rightharpoonup\\mathbb{N}$，都有 $f \\in \\mathcal{C}_k$ 当且仅当 $g = e^{-1}\\circ f\\circ e^{(k)} \\in \\mathcal{C}_k$？\n\n这是一个“当且仅当”的陈述，所以我们必须分析两个方向。\n\n方向1：如果 $f \\in \\mathcal{C}_k$，何时 $g \\in \\mathcal{C}_k$？\n函数 $g$ 由复合 $g(\\vec{x}) = e^{-1}(f(e(x_1), \\dots, e(x_k)))$ 定义。$g(\\vec{x})$ 的计算涉及三个阶段：\n1.  计算元组 $(e(x_1), \\dots, e(x_k))$。这需要对输入向量 $\\vec{x}$ 的每个分量计算函数 $e$。为了使这个阶段在算法上是可执行的，函数 $e$ 必须是可计算的。由于 $e$ 是 $\\mathbb{N}$ 上的双射，它是一个全函数。所以，我们要求 $e$ 是一个全可计算函数。如果 $e$ 是可计算的，那么由 $e^{(k)}(\\vec{x}) = (e(x_1), \\dots, e(x_k))$ 定义的函数 $e^{(k)}: \\mathbb{N}^k \\to \\mathbb{N}^k$ 也是可计算的。这是因为可以构造一个图灵机，它对每个输入分量顺序地运行用于 $e$ 的图灵机。\n2.  在第一阶段的结果上计算 $f$。我们假设 $f$ 是可计算的，所以根据定义，这个阶段在算法上是可执行的。\n3.  在第二阶段的结果上计算 $e^{-1}$。为了使这是算法性的，函数 $e^{-1}$ 必须是可计算的。由于 $e^{-1}$ 也是 $\\mathbb{N}$ 上的双射，我们要求它是一个全可计算函数。\n\n部分可计算函数类在复合下是封闭的。函数 $g$ 是 $e^{-1}$、$f$ 以及涉及 $e$ 和投影的函数的复合。如果 $e$、$e^{-1}$ 和 $f$ 都是可计算的，它们的复合 $g$ 也将是可计算的。因此，为了使“如果”部分对所有可计算的 $f$ 都成立，我们需要 $e$ 和 $e^{-1}$ 是可计算的。\n\n方向2：如果 $g \\in \\mathcal{C}_k$，何时 $f \\in \\mathcal{C}_k$？\n我们可以通过重新排列定义来用 $g$ 表示 $f$：\n$g = e^{-1}\\circ f\\circ e^{(k)}$\n$e \\circ g = e \\circ e^{-1}\\circ f\\circ e^{(k)}$\n$e \\circ g = f\\circ e^{(k)}$\n$e \\circ g \\circ (e^{(k)})^{-1} = f\\circ e^{(k)} \\circ (e^{(k)})^{-1}$\n$f = e \\circ g \\circ (e^{-1})^{(k)}$\n这里，$(e^{-1})^{(k)}$ 是 $e^{-1}$ 的逐分量应用。\n这个论证是完全对称的。$f(\\vec{y})$ 的计算涉及计算 $(e^{-1})^{(k)}(\\vec{y})$，然后在其结果上计算 $g$，再对那个结果计算 $e$。为了使 $f$ 对于任何可计算的 $g$ 都是可计算的，我们要求 $e^{-1}$ 和 $e$ 是全可计算函数。\n\n结合两个方向，当且仅当 $e$ 及其逆 $e^{-1}$ 都是全可计算函数时，可计算性的性质才被保持和反映。一个双射 $e:\\mathbb{N}\\to\\mathbb{N}$，如果 $e$ 和 $e^{-1}$ 都是可计算的，则称之为可计算置换或递归置换。结论是，当且仅当重编码映射是一个可计算置换时，可计算函数类在自然数的重编码下是不变的。\n\n现在我们评估每个选项。\n\n**A. 如果 $e$ 和 $e^{-1}$ 是原始递归全函数，那么对于每一个 $k\\geq 1$ 和每一个部分函数 $f:\\mathbb{N}^k\\rightharpoonup\\mathbb{N}$，$f$ 是图灵可计算的（等价于部分μ-递归的）当且仅当 $g=e^{-1}\\circ f\\circ e^{(k)}$ 是图灵可计算的（等价于部分μ-递归的）。**\n\n原始递归函数类是全可计算（全μ-递归）函数类的一个子集。这个选项中陈述的条件，即 $e$ 和 $e^{-1}$ 是原始递归的，是一个比所需条件更强的条件（可计算就足够了），但它当然是充分的。如果 $e$ 和 $e^{-1}$ 是原始递归的，它们就是全的和可计算的。如上所述，这是保持和反映可计算性的充分条件。部分μ-递归函数类在与全可计算函数复合下是封闭的。由于 $e$ 和 $e^{-1}$ 是可计算的，从 $f$ 到 $g$ 以及从 $g$ 到 $f$ 的转换是与可计算函数的复合，这保持了部分μ-递归函数类的成员资格。\n\n结论：**正确**。\n\n**B. $e$ 是一个双射就足够了；在转换 $g=e^{-1}\\circ f\\circ e^{(k)}$ 下，对于可计算性的保持和反映，不需要对 $e$ 或 $e^{-1}$ 有任何可计算性条件。**\n\n这个陈述是错误的。如果 $e$ 不是可计算的，它可以将可计算的结构映射到不可计算的结构。举一个反例，令 $H \\subset \\mathbb{N}$ 是一个不可计算（但可计算可枚举）的集合，例如停机集。令 $f:\\mathbb{N} \\to \\mathbb{N}$ 是常数函数 $f(x) = 0$。函数 $f$ 是原始递归的，因而是可计算的。让我们构造一个双射 $e:\\mathbb{N} \\to \\mathbb{N}$ 使得 $g = e^{-1} \\circ f \\circ e$ 是不可计算的。考虑 $g(x) = e^{-1}(f(e(x))) = e^{-1}(0)$。为了让 $g$ 不可计算，值为 $e^{-1}(0)$ 的常数函数 $g(x)$ 必须以某种方式编码不可计算的信息。这是不可能的，因为常数函数总是可计算的。让我们换一种方式构造反例。令 $g(x)=0$ 是可计算的。我们寻找一个不可计算的 $f$ 和一个双射 $e$ 使得 $f = e \\circ g \\circ e^{-1}$。这得到 $f(y) = e(g(e^{-1}(y))) = e(0)$。所以 $f$ 是一个常数函数，它是可计算的。这条路也很困难。\n\n一个更好的方法是使用一个不可计算的函数，并证明它可以被转换成一个可计算的函数。令 $f = \\chi_H$ 是停机集 $H$ 的特征函数。$f$ 不是可计算的。我们想找到一个双射 $e$ 使得 $g = e^{-1} \\circ \\chi_H \\circ e$ 是可计算的。由于 $H$ 是不可判定的， $H$ 和它的补集 $\\mathbb{N}\\setminus H$ 都是无限的。令 $e$ 是一个将 $H$ 映射到偶数集 $E$ 并将 $\\mathbb{N}\\setminus H$ 映射到奇数集 $O$ 的双射。这样的双射是存在的。然而，$e$ 本身是不可计算的，因为计算 $e(x)$ 需要判定 $x \\in H$。现在，让我们分析 $g(y) = e^{-1}(\\chi_H(e(y)))$。\n- 如果 $y \\in E$，那么 $e(y) \\in H$，所以 $\\chi_H(e(y))=1$。那么 $g(y) = e^{-1}(1)$。因为 $1 \\in O$，所以 $e^{-1}(1) \\in \\mathbb{N}\\setminus H$。\n- 如果 $y \\in O$，那么 $e(y) \\in \\mathbb{N}\\setminus H$，所以 $\\chi_H(e(y))=0$。那么 $g(y) = e^{-1}(0)$。因为 $0 \\in E$，所以 $e^{-1}(0) \\in H$。\n这个构造没有立即产生一个简单的可计算函数。一个更清晰的构造如下：令 $f$ 为不可计算函数 $\\chi_H$。令 $g$ 为可计算函数 $g(x) = x \\pmod 2$。我们寻找 $e$ 使得 $e \\circ g = f \\circ e$。这要求 $e(x \\pmod 2) = f(e(x))$。对于偶数 $x$，$e(0)=f(e(x))$；对于奇数 $x$，$e(1)=f(e(x))$。令 $e$ 将偶数映射到 $\\mathbb{N}\\setminus H$，将奇数映射到 $H$。如果我们可以安排 $e(0) \\in \\mathbb{N}\\setminus H$ 和 $e(1) \\in H$ 并且 $f$ 在这些像集上是常数，这是可能的。具体来说，我们需要对于所有 $y \\in e(E)$ 有 $f(y)=e(0)$，对于所有 $y \\in e(O)$ 有 $f(y)=e(1)$。对于 $f=\\chi_H$，这意味着要么 $e(0)=0$ 且 $e(1)=1$（并且 $e(E) \\subseteq \\mathbb{N}\\setminus H$, $e(O) \\subseteq H$），要么 $e(0)=1$ 且 $e(1)=0$（并且 $e(E) \\subseteq H$, $e(O) \\subseteq \\mathbb{N}\\setminus H$）。无论哪种方式，这样的双射 $e$ 都可以被构造出来，但它将不是可计算的。我们找到了一个不可计算函数 $f$ 和一个可计算函数 $g$，它们通过一个不可计算的 $e$ 满足关系 $g = e^{-1} \\circ f \\circ e$。因此，可计算性没有被保持。\n\n结论：**不正确**。\n\n**C. 在 $g=e^{-1}\\circ f\\circ e^{(k)}$ 下的保持性仅对全函数 $f:\\mathbb{N}^k\\to\\mathbb{N}$ 成立；对于部分函数 $f:\\mathbb{N}^k\\rightharpoonup\\mathbb{N}$，即使当 $e$ 和 $e^{-1}$ 是原始递归时，该性质也可能不成立。**\n\n这个陈述是错误的。基于复合封闭性的保持性论证同样适用于部分函数。让我们在图灵机的层面上看这个问题。给定一个用于部分函数 $f$ 的图灵机 $M_f$，以及用于全函数 $e$ 和 $e^{-1}$ 的图灵机 $M_e$ 和 $M_{e^{-1}}$，我们可以为 $g$ 构造一个图灵机 $M_g$。$M_g$ 在输入 $\\vec{x}$ 上首先在 $\\vec{x}$ 的每个分量上模拟 $M_e$ 以得到 $\\vec{y}=e^{(k)}(\\vec{x})$。由于 $e$ 是全函数，这一步总是会停机。然后，$M_g$ 在 $\\vec{y}$ 上模拟 $M_f$。如果这个模拟停机并输出 $z$，$M_g$ 就在 $z$ 上模拟 $M_{e^{-1}}$ 以得到 $w$，并输出 $w$。如果 $M_f$ 在 $\\vec{y}$ 上的模拟不停机，那么 $M_g$ 在 $\\vec{x}$ 上也不停机。这完全对应于 $g = e^{-1}\\circ f\\circ e^{(k)}$ 的定义。$g$ 的定义域正是使得 $e^{(k)}(\\vec{x})$ 位于 $f$ 定义域内的 $\\vec{x}$ 的集合。这个过程为部分函数 $g$ 定义了一个有效的图灵机。用 $g$ 表示 $f$ 的论证是对称的。因此，该性质对部分函数也成立。\n\n结论：**不正确**。\n\n**D. 在 $g=e^{-1}\\circ f\\circ e^{(k)}$ 下的保持性要求 $e$ 和 $e^{-1}$ 在固定的时间界限内（例如，多项式时间）是可计算的；否则μ-递归性定义中的无界极小化无法被模拟，因此可计算性可能会丢失。**\n\n这个陈述混淆了可计算性与计算复杂性。一个可计算函数（无论是通过图灵机还是μ-递归定义）的定义没有对计算所需的时间或空间资源施加任何限制，只要它对于函数定义域内的输入能够终止。无界极小化（μ-算子）正是允许μ-递归函数模拟所有可能算法的特性，包括那些具有非原始递归运行时复杂性的算法（如 Ackermann 函数）。只要 $e$ 和 $e^{-1}$ 是可计算的（即存在算法能在有限时间内为任何输入计算它们），复合论证就成立。$e$ 和 $e^{-1}$ 的复杂性影响 $g$ 的复杂性，但不影响其可计算性。例如，如果 $f$、$e$ 和 $e^{-1}$ 都是可计算的，那么 $g$ 也是可计算的，即使 $e$ 的计算需要极长的时间。\n\n结论：**不正确**。\n\n**E. 即使 $e$ 和 $e^{-1}$ 是原始递归的，保持性也可能不成立，除非同时假设存在一个原始递归的元组编码/解码来将 $\\mathbb{N}^k$ 表示为 $\\mathbb{N}$；没有这个额外假设，通过 $e$ 和 $e^{-1}$ 的前复合和后复合可能无法被μ-递归性的封闭性质所吸收。**\n\n这个陈述反映了对部分μ-递归函数标准定义的误解。该理论是为任意元数 $k \\geq 1$ 的函数 $f:\\mathbb{N}^k \\to \\mathbb{N}$ 建立的。封闭性质是直接在这些多元函数上定义的。例如，复合定义为 $h(g_1(\\vec{x}), \\dots, g_m(\\vec{x}))$。函数 $f \\circ e^{(k)}$ 是函数 $F(\\vec{x}) = f(e(x_1), \\dots, e(x_k))$ 的记法，它是 $f$ 与函数 $g_i(\\vec{x}) = e(\\pi_i^k(\\vec{x}))$ 的复合，其中 $\\pi_i^k$ 是初始投影函数。如果 $e$ 是原始递归的，那么 $g_i$ 也是。一个部分μ-递归函数 $f$ 与原始递归函数复合的结果是一个部分μ-递归函数。与 $e^{-1}$ 的最终复合，$g(\\vec{x}) = e^{-1}(F(\\vec{x}))$，也是一个保持μ-递归性的有效复合。整个论证都可以在多元μ-递归函数的标准演算中形式化，而无需显式地将元组编码为单个自然数。这种编码是用于证明等价性（例如与单带图灵机的等价性）的工具，但它不是理论本身的先决条件。\n\n结论：**不正确**。", "answer": "$$\\boxed{A}$$", "id": "2972645"}]}