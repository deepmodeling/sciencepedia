{"hands_on_practices": [{"introduction": "在使用可归约性来描绘计算问题的复杂性版图之前，我们必须掌握其基本属性。本练习全面检验了多一归约 ($\\le_m$)、一一归约 ($\\le_1$) 和图灵归约 ($\\le_T$) 之间的核心关系，以及它们如何与递归集和递归可枚举集等类别相互作用。掌握这些法则是建立更深刻直觉的第一步。[@problem_id:2981118]", "problem": "设 $A,B \\subseteq \\mathbb{N}$。回顾可计算性理论中的以下基本定义：\n- 如果一个集合 $S \\subseteq \\mathbb{N}$ 的特征函数是全可计算函数，则该集合是递归的（可判定的）。\n- 如果存在一个图灵机能够精确地枚举出集合 $S$ 的所有元素，或者等价地说，存在一个图灵机当且仅当输入 $x \\in S$ 时停机，则该集合 $S \\subseteq \\mathbb{N}$ 是递归可枚举的（r.e.）。\n- 多一归约（也称作映射归约）定义为：$A \\leq_{m} B$ 当且仅当存在一个全可计算函数 $f:\\mathbb{N} \\to \\mathbb{N}$，使得对于所有 $x \\in \\mathbb{N}$，都有\n$$\nx \\in A \\iff f(x) \\in B.\n$$\n- 一一归约定义为：$A \\leq_{1} B$ 当且仅当存在一个全可计算单射函数 $f:\\mathbb{N} \\to \\mathbb{N}$，使得对于所有 $x \\in \\mathbb{N}$，都有\n$$\nx \\in A \\iff f(x) \\in B.\n$$\n- 图灵归约定义为：$A \\leq_{T} B$ 当且仅当存在一个以 $B$ 为预言机的预言图灵机，可以判定 $A$ 中的成员关系。\n\n设 $K = \\{ e \\in \\mathbb{N} : \\varphi_{e}(e) \\downarrow \\}$ 是经典的自输入停机集，其中 $(\\varphi_{e})_{e \\in \\mathbb{N}}$ 是部分可计算函数的一个标准编号。\n\n选择所有为真的陈述。每个选择都应根据这些核心定义和可计算性理论的一般事实来证明。\n\nA. 若 $A \\leq_{1} B$，则 $A \\leq_{m} B$；且若 $A \\leq_{m} B$，则 $A \\leq_{T} B$。\n\nB. 若 $A \\leq_{m} B$ 且 $B$ 是递归的，则 $A$ 也是递归的。\n\nC. 若 $A \\leq_{T} B$ 且 $B$ 是递归的，则 $A$ 也是递归的。\n\nD. 对于每个递归可枚举集 $A$，都存在一个全可计算单射函数 $f$，使得对于所有 $x \\in \\mathbb{N}$，有 $x \\in A \\iff f(x) \\in K$。等价地，每个递归可枚举集 $A$ 都满足 $A \\leq_{1} K$。\n\nE. 存在递归可枚举集 $A,B$，使得 $A \\leq_{m} B$ 但 $A \\not\\leq_{1} B$。\n\nF. 若 $A \\leq_{m} B$ 且 $B$ 是余递归可枚举的，则 $A$ 也是余递归可枚举的。\n\nG. 若 $A \\leq_{m} B$ 且 $B$ 是递归可枚举且多一完全的（即，对于每个 r.e. 集 $C$，都有 $C \\leq_{m} B$），则 $A$ 是递归可枚举且多一完全的。\n\nH. 若 $A \\leq_{T} B$ 且 $B \\leq_{T} A$，则 $A$ 和 $B$ 是多一等价的（即，$A \\leq_{m} B$ 且 $B \\leq_{m} A$）。", "solution": "问题陈述提供了可计算性理论中的标准定义，并要求基于这些定义评估八个陈述的真伪。该问题定义明确、科学上合理且内部一致。\n\nA. **若 $A \\leq_{1} B$，则 $A \\leq_{m} B$；且若 $A \\leq_{m} B$，则 $A \\leq_{T} B$。**\n\n该陈述包含两个论断。\n\n1.  若 $A \\leq_{1} B$，则 $A \\leq_{m} B$。\n    根据定义，$A \\leq_{1} B$ 意味着存在一个全可计算单射函数 $f: \\mathbb{N} \\to \\mathbb{N}$，使得对于所有 $x \\in \\mathbb{N}$，有 $x \\in A \\iff f(x) \\in B$。\n    根据定义，$A \\leq_{m} B$ 意味着存在一个全可计算函数 $g: \\mathbb{N} \\to \\mathbb{N}$，使得对于所有 $x \\in \\mathbb{N}$，有 $x \\in A \\iff g(x) \\in B$。\n    因为根据定义，任何单射函数本身就是一个函数，所以用于 1-归约的全可计算单射函数 $f$ 的存在，直接蕴含了用于 m-归约的全可计算函数的存在（我们只需令 $g=f$）。因此，这个蕴含关系为真。\n\n2.  若 $A \\leq_{m} B$，则 $A \\leq_{T} B$。\n    根据定义，$A \\leq_{m} B$ 意味着存在一个全可计算函数 $f$，使得 $x \\in A \\iff f(x) \\in B$。\n    根据定义，$A \\leq_{T} B$ 意味着存在一个以 $B$ 为预言机的预言图灵机，可以判定 $A$ 中的成员关系。\n    我们可以构造这样一个预言机 $M^B$ 来判定 $A$。对于任何输入 $x \\in \\mathbb{N}$：\n    a. 计算 $y = f(x)$。由于 $f$ 是一个全可计算函数，这一步总会停机。\n    b. 对输入 $y$ 查询 $B$ 的预言机。根据定义，如果 $y \\in B$，预言机将停机并返回`真`；如果 $y \\notin B$，则返回`假`。\n    c. 如果预言机返回`真`，则 $y \\in B$，这意味着 $x \\in A$。机器 $M^B$ 停机并接受。\n    d. 如果预言机返回`假`，则 $y \\notin B$，这意味着 $x \\notin A$。机器 $M^B$ 停机并拒绝。\n    这个过程是一个使用预言机 $B$ 来判定 $A$ 的成员关系的全算法。因此，$A \\leq_{T} B$。这个蕴含关系也为真。\n\n由于两个论断都为真，该陈述是**正确的**。\n\nB. **若 $A \\leq_{m} B$ 且 $B$ 是递归的，则 $A$ 也是递归的。**\n\n给定 $A \\leq_{m} B$，存在一个全可计算函数 $f$，使得 $x \\in A \\iff f(x) \\in B$。\n给定 $B$ 是递归的，其特征函数 $\\chi_B(y)$ 是一个全可计算函数，其中当 $y \\in B$ 时 $\\chi_B(y) = 1$，当 $y \\notin B$ 时 $\\chi_B(y) = 0$。\n要证明 $A$ 是递归的，我们必须证明其特征函数 $\\chi_A(x)$ 是全可计算的。\n从归约关系可知，条件 $x \\in A$ 等价于 $f(x) \\in B$。这意味着 $\\chi_A(x) = 1$ 当且仅当 $\\chi_B(f(x)) = 1$。类似地，$\\chi_A(x) = 0$ 当且仅当 $\\chi_B(f(x)) = 0$。\n因此，对于所有 $x \\in \\mathbb{N}$，有 $\\chi_A(x) = \\chi_B(f(x))$。\n函数 $\\chi_A$ 被定义为两个全可计算函数 $f$ 和 $\\chi_B$ 的复合。全可计算函数类在复合运算下是封闭的。因此，$\\chi_A$ 是一个全可计算函数。\n这证明了 $A$ 是一个递归集。\n该陈述是**正确的**。\n\nC. **若 $A \\leq_{T} B$ 且 $B$ 是递归的，则 $A$ 也是递归的。**\n\n给定 $A \\leq_{T} B$，存在一个预言图灵机 $M^B$ 可以判定 $A$ 中的成员关系。这意味着 $M^B$ 在所有输入 $x \\in \\mathbb{N}$ 上都会停机，如果 $x \\in A$ 则接受，如果 $x \\notin A$ 则拒绝。\n给定 $B$ 是递归的，存在一个标准的（非预言机）图灵机 $M_B$ 可以判定 $B$ 中的成员关系。也就是说，对于任何输入 $y$，$M_B$ 会停机并接受（如果 $y \\in B$）或停机并拒绝（如果 $y \\notin B$）。\n我们可以构造一个标准的图灵机 $M_A$ 来判定 $A$。$M_A$ 将模拟 $M^B$ 的执行。每当 $M^B$ 发出一个预言机查询“$y \\in B$ 是否成立？”时，模拟暂停。然后 $M_A$ 在输入 $y$ 上运行判定器 $M_B$。由于 $M_B$ 是一个判定器，它保证会停机。$M_A$ 使用 $M_B$ 的计算结果来为 $M^B$ 的预言机查询提供答案，然后继续模拟。\n由于 $M^B$ 保证在所有输入上都会停机，并且其计算中的每个预言机调用都被一个同样保证会停机的计算（即 $M_B$ 的执行）所替代，因此整个机器 $M_A$ 将在所有输入上停机。它正确地判定了 $A$ 中的成员关系。\n因此，$A$ 是一个递归集。\n该陈述是**正确的**。\n\nD. **对于每个递归可枚举集 $A$，都存在一个全可计算单射函数 $f$，使得对于所有 $x \\in \\mathbb{N}$，有 $x \\in A \\iff f(x) \\in K$。等价地，每个递归可枚举集 $A$ 都满足 $A \\leq_{1} K$。**\n\n该陈述声称停机集 $K$ 对于递归可枚举（r.e.）集类是 1-完全的。\n令 $A$ 为任意一个 r.e. 集。根据定义，$A$ 是某个部分可计算函数的定义域。设此函数为 $\\varphi_a$（对于某个索引 $a$），因此 $A = \\text{dom}(\\varphi_a) = \\{x \\in \\mathbb{N} \\mid \\varphi_a(x) \\downarrow\\}$。\n我们要证明 $A \\leq_{1} K$。为此，我们必须构造一个全可计算单射函数 $f$，使得 $x \\in A \\iff f(x) \\in K$。\n考虑函数 $\\psi(x, y)$，它在任何输入 $y$ 上模拟 $\\varphi_a(x)$ 的计算。如果 $\\varphi_a(x)$ 的模拟停机，则 $\\psi(x, y)$ 停机。如果不停机，$\\psi(x, y)$ 也不停机。注意 $\\psi(x,y)$ 的行为不依赖于 $y$。\n所以，如果 $x \\in A$，则 $\\text{dom}(\\psi(x, \\cdot)) = \\mathbb{N}$；如果 $x \\notin A$，则 $\\text{dom}(\\psi(x, \\cdot)) = \\emptyset$。\nS-m-n 定理（在其有效版本中，也与填充引理有关）指出，存在一个全可计算的*单射*函数 $f(x)$，使得对于所有的 $x$ 和 $y$，有 $\\varphi_{f(x)}(y) \\simeq \\psi(x, y)$。单射性质是关键；它确保不同的输入 $x$ 产生不同的程序索引 $f(x)$，这通常通过向程序代码中添加无用指令（“填充”）来实现。\n有了这个函数 $f$，我们有：\n$x \\in A \\iff \\varphi_a(x) \\downarrow \\iff$ 对所有 $y$，$\\psi(x,y) \\downarrow \\iff$ 对所有 $y$，$\\varphi_{f(x)}(y) \\downarrow$。\n停机集定义为 $K = \\{e \\mid \\varphi_e(e) \\downarrow\\}$。我们需要将我们的条件与自应用联系起来。\n一个稍微不同但更直接的构造方法如下。对于每个 $x$，定义一个程序 $P_x$，它在任何输入 $z$ 上执行以下操作：首先运行 $\\varphi_a(x)$ 的计算，如果该计算停机，则 $P_x$ 也停机。填充引理保证这个程序的索引（我们称之为 $f(x)$）可以由一个关于 $x$ 的全可计算单射函数给出。\n因此，对于任何 $z$，$\\varphi_{f(x)}(z)$ 停机当且仅当 $\\varphi_a(x)$ 停机。\n特别地，我们可以选择 $z = f(x)$。所以，$\\varphi_{f(x)}(f(x))$ 停机当且仅当 $\\varphi_a(x)$ 停机。\n这就给出了等价关系：$x \\in A \\iff \\varphi_a(x) \\downarrow \\iff \\varphi_{f(x)}(f(x)) \\downarrow \\iff f(x) \\in K$。\n由于 $f$ 是一个全可计算单射函数，我们证明了 $A \\leq_{1} K$。因为 $A$ 是任意一个 r.e. 集，所以该陈述成立。\n该陈述是**正确的**。\n\nE. **存在递归可枚举集 $A,B$，使得 $A \\leq_{m} B$ 但 $A \\not\\leq_{1} B$。**\n\n该陈述声称多一归约严格弱于一一归约。让我们找一个 $A \\leq_{m} B \\implies A \\leq_{1} B$ 的反例。\n令 $A = \\mathbb{N} = \\{0, 1, 2, \\dots\\}$ 且 $B = \\{0\\}$。\n$A$ 和 $B$ 都是递归的（它们的特征函数是平凡可计算的），因此它们也是递归可枚举的。\n1.  证明 $A \\leq_{m} B$。我们需要一个全可计算函数 $f$，使得 $x \\in A \\iff f(x) \\in B$。\n    因为 $A = \\mathbb{N}$，条件 $x \\in A$ 总是为真。因此，我们需要 $f(x) \\in B$ 也总是为真。这意味着 $f(x)$ 必须总是为 $0$。\n    令对所有 $x \\in \\mathbb{N}$，$f(x) = 0$。这是一个常数函数，是全可计算的。等价关系`真 \\iff 真`对所有 $x$ 均成立。因此，$\\mathbb{N} \\leq_{m} \\{0\\}$。\n2.  证明 $A \\not\\leq_{1} B$。我们需要证明不存在全可计算*单射*函数 $g$，使得 $x \\in A \\iff g(x) \\in B$。\n    假设存在这样的函数 $g$。和之前一样，$x \\in A$ 总是为真，所以对于所有 $x \\in \\mathbb{N}$，我们必须有 $g(x) \\in B$。这意味着对于所有 $x$，$g(x) = 0$。\n    然而，为了使 $g$ 是单射的，我们必须有当 $x_1 \\neq x_2$ 时，$g(x_1) \\neq g(x_2)$。\n    令 $x_1 = 0$ 且 $x_2 = 1$。那么 $g(0)=0$ 且 $g(1)=0$，这违反了单射性。\n    因此，不存在这样的单射函数 $g$。所以 $A \\not\\leq_{1} B$。\n我们找到了满足条件的 r.e. 集 $A$ 和 $B$。\n该陈述是**正确的**。\n\nF. **若 $A \\leq_{m} B$ 且 $B$ 是余递归可枚举的，则 $A$ 也是余递归可枚举的。**\n\n给定 $A \\leq_{m} B$，存在一个全可计算函数 $f$，其中 $x \\in A \\iff f(x) \\in B$。\n对两边取非，我们得到 $x \\notin A \\iff f(x) \\notin B$。\n令 $\\bar{A} = \\mathbb{N} \\setminus A$ 和 $\\bar{B} = \\mathbb{N} \\setminus B$ 分别是 $A$ 和 $B$ 的补集。该等价关系可以写成 $x \\in \\bar{A} \\iff f(x) \\in \\bar{B}$。\n这表明通过同一个全可计算函数 $f$，有 $\\bar{A} \\leq_{m} \\bar{B}$。\n我们已知 $B$ 是余递归可枚举的（co-r.e.）。根据定义，这意味着它的补集 $\\bar{B}$ 是递归可枚举的（r.e.）。\n现在我们有 $\\bar{A} \\leq_{m} \\bar{B}$ 且 $\\bar{B}$ 是 r.e. 的。我们需要证明这蕴含了 $\\bar{A}$ 是 r.e. 的。\n因为 $\\bar{B}$ 是 r.e. 的，存在一个图灵机 $M_{\\bar{B}}$，当且仅当输入 $y \\in \\bar{B}$ 时停机。\n我们可以构造一个图灵机 $M_{\\bar{A}}$ 来识别 $\\bar{A}$：\n对于输入 $x$：\n1. 计算 $y = f(x)$。因为 $f$ 是全可计算的，所以这一步会停机。\n2. 在输入 $y$ 上运行 $M_{\\bar{B}}$。\n$M_{\\bar{A}}$ 停机当且仅当 $M_{\\bar{B}}$ 在 $y=f(x)$ 上停机。这为真当且仅当 $f(x) \\in \\bar{B}$，而这又为真当且仅当 $x \\in \\bar{A}$。\n因此，$M_{\\bar{A}}$ 是 $\\bar{A}$ 的一个识别器，这意味着 $\\bar{A}$ 是 r.e. 的。\n如果 $\\bar{A}$ 是 r.e. 的，那么根据定义，$A$ 是 co-r.e. 的。\n该陈述是**正确的**。\n\nG. **若 $A \\leq_{m} B$ 且 $B$ 是递归可枚举且多一完全的（即，对于每个 r.e. 集 $C$，都有 $C \\leq_{m} B$），则 $A$ 是递归可枚举且多一完全的。**\n\n该陈述声称 m-完全性会被归约到 m-完全集的集合所继承。这是错误的。归约 $A \\leq_m B$ 意味着 $A$“不比”$B$“更难”。它并不意味着 $A$ 和 $B$“一样难”。\n让我们构造一个反例。\n令 $B = K$，即停机集。$K$ 是 r.e. 且 m-完全的。\n令 $A = \\emptyset$。空集是递归的，因此它也是 r.e. 的。\n$A \\leq_{m} B$ 是否成立？也就是说，$\\emptyset \\leq_{m} K$ 是否成立？我们需要一个全可计算函数 $f$，使得 $x \\in \\emptyset \\iff f(x) \\in K$。\n左边 $x \\in \\emptyset$ 总是为假。所以我们需要右边 $f(x) \\in K$ 也总是为假。这意味着 $f$ 的值域必须是 $\\bar{K}$ 的一个子集。\n集合 $\\bar{K}$ 不是 r.e. 的，但它是非空的（实际上是无限的）。令 $k_0$ 为 $\\bar{K}$ 中的任意元素（例如，一个无限循环程序的索引）。\n定义对所有 $x \\in \\mathbb{N}$，$f(x) = k_0$。这是一个全可计算函数。\n归约条件变为`假 \\iff 假`，这对所有 $x$ 都为真。因此，$\\emptyset \\leq_{m} K$。\n所以我们有 $A = \\emptyset$，$B = K$。前提条件满足：$A \\leq_m B$ 且 $B$ 是 m-完全的。\n结论是否为真？$A = \\emptyset$ 是否是 r.e. 且 m-完全的？\n$A$ 是 r.e. 的。但它是否是 m-完全的？要使 $A$ 是 m-完全的，每个 r.e. 集 $C$ 都必须满足 $C \\leq_m A$。\n让我们选择一个非空的 r.e. 集，例如 $C=\\{0\\}$。\n如果 $\\{0\\} \\leq_m \\emptyset$，那么必须存在一个全可计算函数 $g$，使得对于所有 $x$，$x \\in \\{0\\} \\iff g(x) \\in \\emptyset$。\n右边，$g(x) \\in \\emptyset$，总是为假。\n为了使等价关系成立，左边，$x \\in \\{0\\}$，也必须总是为假。\n但对于 $x=0$，$x \\in \\{0\\}$ 为真。对于 $x=0$，我们得到矛盾 `真 \\iff 假`。\n因此，不存在这样的函数 $g$。所以 $\\{0\\} \\not\\leq_m \\emptyset$。\n因此，$\\emptyset$ 不是 m-完全的。结论是错误的。\n该陈述是**不正确的**。\n\nH. **若 $A \\leq_{T} B$ 且 $B \\leq_{T} A$，则 $A$ 和 $B$ 是多一等价的（即，$A \\leq_{m} B$ 且 $B \\leq_{m} A$）。**\n\n该陈述声称图灵等价（$A \\equiv_T B$）蕴含多一等价（$A \\equiv_m B$）。这已知是错误的；图灵归约是一种比多一归约更粗糙的等价关系。\n让我们找一个反例。考虑 $A = K$（停机集）和 $B = \\bar{K}$（其补集）。\n1.  证明 $A \\leq_T B$ 和 $B \\leq_T A$。\n    要证明 $K \\leq_T \\bar{K}$，我们需要一个以 $\\bar{K}$ 为预言机的预言机来判定 $K$。对于输入 $x$，查询预言机：“$x \\in \\bar{K}$ 是否成立？”。如果预言机回答是，那么 $x \\notin K$，所以拒绝。如果它回答否，那么 $x \\in K$，所以接受。这是一个 $K$ 的判定器。所以 $K \\leq_T \\bar{K}$。\n    对称地，要证明 $\\bar{K} \\leq_T K$，我们使用一个以 $K$ 为预言机。对于输入 $x$，查询：“$x \\in K$ 是否成立？”。如果是，那么 $x \\notin \\bar{K}$，所以拒绝。如果否，那么 $x \\in \\bar{K}$，所以接受。这是一个 $\\bar{K}$ 的判定器。所以 $\\bar{K} \\leq_T K$。\n    因此，$K \\equiv_T \\bar{K}$。\n2.  证明 $A \\equiv_m B$ 不成立。我们将证明 $K \\not\\leq_m \\bar{K}$。\n    为寻求矛盾，假设 $K \\leq_m \\bar{K}$。\n    $K$ 是一个 r.e. 集。根据定义，$\\bar{K}$ 是一个 co-r.e. 集。\n    我们在陈述 F 中证明了，如果 $X \\leq_m Y$ 且 $Y$ 是 co-r.e. 的，那么 $X$ 也是 co-r.e. 的。\n    将此结果应用于 $X=K$ 和 $Y=\\bar{K}$：由于 $K \\leq_m \\bar{K}$（根据假设）且 $\\bar{K}$ 是 co-r.e. 的，因此 $K$ 必定是 co-r.e. 的。\n    所以，$K$ 将既是 r.e. 的（根据其定义）又是 co-r.e. 的。\n    根据波斯特(Post)定理，一个集合是递归的当且仅当它既是 r.e. 的又是 co-r.e. 的。这将意味着 $K$ 是递归的。\n    然而，可计算性理论的一个基本结果是停机集 $K$ 不是递归的。这是一个矛盾。\n    因此，我们的初始假设必定是错误的。所以，$K \\not\\leq_m \\bar{K}$。\n    由于 $K \\not\\leq_m \\bar{K}$，集合 $K$ 和 $\\bar{K}$ 不是多一等价的。\n我们找到了集合 $A, B$ 使得 $A \\equiv_T B$ 但 $A \\not\\equiv_m B$。\n该陈述是**不正确的**。\n\n结果总结：\nA: 正确\nB: 正确\nC: 正确\nD: 正确\nE: 正确\nF: 正确\nG: 不正确\nH: 不正确\n\n正确的陈述是 A、B、C、D、E 和 F。", "answer": "$$\\boxed{ABCDEF}$$", "id": "2981118"}, {"introduction": "多一归约将问题划分为不同的“不可解度”。一个关键的洞见是，处于相同“度”的问题在结构上可能截然不同。本练习将指导你构造两个不同的语言，但它们在多一归约下是等价的，这为了解为何 $\\le_m$ 关系不是反对称的提供了一个具体实例。[@problem_id:1349294]", "problem": "设 $\\Sigma = \\{0, 1\\}$ 是一个字母表。$\\Sigma$ 上的一个语言是指其符号均取自 $\\Sigma$ 的任意有限长度字符串的集合。$\\Sigma$ 上所有有限长度字符串的集合记为 $\\Sigma^*$。一个函数 $f: \\Sigma^* \\to \\Sigma^*$ 被称为全可计算函数，如果存在一个图灵机（Turing Machine），对于任意输入字符串 $w \\in \\Sigma^*$，该图灵机都会停机并产生输出字符串 $f(w)$。\n\n一个语言 $L_1$ 被称为多一归约（many-one reducible）到语言 $L_2$，记为 $L_1 \\le_m L_2$，如果存在一个全可计算函数 $f: \\Sigma^* \\to \\Sigma^*$，使得对于每个字符串 $w \\in \\Sigma^*$，条件（$w \\in L_1$）为真当且仅当条件（$f(w) \\in L_2$）为真。\n\n关系 $\\le_m$ 已知是自反的（对于任意语言 $L$，有 $L \\le_m L$）和传递的（如果 $L_1 \\le_m L_2$ 且 $L_2 \\le_m L_3$，那么 $L_1 \\le_m L_3$）。\n\n现在，对于任意非空语言 $A \\subseteq \\Sigma^*$，定义两个新语言：\n$L_0(A) = \\{ 0s \\mid s \\in A \\}$\n$L_1(A) = \\{ 1s \\mid s \\in A \\}$\n这里，$0s$ 表示将符号 '0' 与字符串 $s$ 连接（concatenate）而成的字符串。\n\n设 $U$ 是一个特定的非空、不可判定语言（一个不存在图灵机能对所有字符串停机并正确判定其成员资格的语言）。设 $L_U^0 = L_0(U)$ 和 $L_U^1 = L_1(U)$ 是由 $U$ 构造的语言。\n\n考虑以下四个陈述：\n(I) $L_U^0 \\le_m L_U^1$。\n(II) $L_U^1 \\le_m L_U^0$。\n(III) $L_U^0 = L_U^1$。\n(IV) 关系 $\\le_m$ 在 $\\Sigma$ 上所有语言的集合上是反对称的。（一个集合 $S$ 上的关系 $R$ 是反对称的，如果对于所有 $x, y \\in S$，若 $x R y$ 且 $y R x$，则 $x=y$）。\n\n以下哪个选项正确地指出了上述列表中的所有真实陈述？\n\nA. 仅 I\nB. 仅 I 和 II\nC. 仅 I, II, 和 III\nD. 仅 IV\nE. 以上陈述均不为真。", "solution": "我们在 $\\Sigma=\\{0,1\\}$ 上进行讨论。对于任意非空语言 $U \\subseteq \\Sigma^{*}$，定义 $L_{U}^{0}=\\{0s \\mid s \\in U\\}$ 和 $L_{U}^{1}=\\{1s \\mid s \\in U\\}$。\n\n为了证明 (I) $L_{U}^{0} \\le_{m} L_{U}^{1}$，定义一个全可计算函数 $f:\\Sigma^{*}\\to\\Sigma^{*}$ 如下：\n$$\nf(w)=\n\\begin{cases}\n1s   \\text{若 } w=0s \\text{ 对于某个 } s \\in \\Sigma^{*},\\\\\n0    \\text{其他情况。}\n\\end{cases}\n$$\n这个函数 $f$ 是可计算的，因为检查 $w$ 是否以 $0$ 开头并修改第一个符号是一个简单有效的过程，且到 $0$ 的常数映射是可计算的。为了验证其正确性，考虑任意 $w \\in \\Sigma^{*}$：\n- 如果 $w=0s$，那么\n$$\nw \\in L_{U}^{0} \\iff s \\in U \\iff 1s \\in L_{U}^{1} \\iff f(w) \\in L_{U}^{1}.\n$$\n- 如果 $w$ 不是 $0s$ 的形式，那么根据定义 $w \\notin L_{U}^{0}$，并且 $f(w)=0 \\notin L_{U}^{1}$，因为 $L_{U}^{1}$ 中的每个字符串都以 $1$ 开头，而 $0$ 以 $0$ 开头。因此\n$$\nw \\in L_{U}^{0} \\iff f(w) \\in L_{U}^{1}\n$$\n仍然成立（两边都为假）。因此 (I) 为真。\n\n为了证明 (II) $L_{U}^{1} \\le_{m} L_{U}^{0}$，定义一个全可计算函数 $g:\\Sigma^{*}\\to\\Sigma^{*}$ 如下：\n$$\ng(w)=\n\\begin{cases}\n0s   \\text{若 } w=1s \\text{ 对于某个 } s \\in \\Sigma^{*},\\\\\n1    \\text{其他情况。}\n\\end{cases}\n$$\n基于同样的理由，这个函数 $g$ 是可计算的。为了验证其正确性，考虑任意 $w \\in \\Sigma^{*}$：\n- 如果 $w=1s$，那么\n$$\nw \\in L_{U}^{1} \\iff s \\in U \\iff 0s \\in L_{U}^{0} \\iff g(w) \\in L_{U}^{0}.\n$$\n- 如果 $w$ 不是 $1s$ 的形式，那么 $w \\notin L_{U}^{1}$，并且 $g(w)=1 \\notin L_{U}^{0}$，因为 $L_{U}^{0}$ 中的每个字符串都以 $0$ 开头，而 $1$ 以 $1$ 开头。因此\n$$\nw \\in L_{U}^{1} \\iff g(w) \\in L_{U}^{0}\n$$\n成立（两边都为假）。因此 (II) 为真。\n\n对于 (III) $L_{U}^{0}=L_{U}^{1}$，观察到 $L_{U}^{0}$ 中的每个字符串都以 $0$ 开头，而 $L_{U}^{1}$ 中的每个字符串都以 $1$ 开头。由于 $U \\neq \\varnothing$，存在 $s \\in U$，因此 $0s \\in L_{U}^{0}$ 但 $0s \\notin L_{U}^{1}$。所以 $L_{U}^{0} \\neq L_{U}^{1}$，故 (III) 为假。\n\n对于 (IV)，反对称性要求对于所有语言 $A,B$，如果 $A \\le_{m} B$ 且 $B \\le_{m} A$，那么 $A=B$。然而，取 $A=L_{U}^{0}$ 和 $B=L_{U}^{1}$，我们已经证明了 $A \\le_{m} B$ 和 $B \\le_{m} A$，但 $A \\neq B$。因此 $\\le_{m}$ 在所有语言的集合上不是反对称的，故 (IV) 为假。\n\n因此，为真的陈述仅有 (I) 和 (II)。", "answer": "$$\\boxed{B}$$", "id": "1349294"}, {"introduction": "尽管多一归约是一个强大的工具，但图灵归约为比较计算难度提供了更通用的框架。本练习通过探究停机问题 ($A_{TM}$) 和图灵机语言空集问题 ($EMPTY_{TM}$)，展示了一个关键区别：两个问题在图灵意义上可能难度相当，但却无法通过多一归约联系起来。这凸显了这两个重要概念在“粒度”上的差异。[@problem_id:1457107]", "problem": "在计算理论中，我们分析算法能解决的问题的极限。其核心是不可判定问题，对于这类问题，不存在任何算法能对所有输入给出正确的“是”或“否”的回答。两个基本的不可判定问题是停机问题和图灵机的空性问题。\n\n设一台图灵机（TM）表示为 $M$，其作为字符串的编码为 $\\langle M \\rangle$。$M$ 接受的语言，记作 $L(M)$，是所有导致 $M$ 在接受状态停机的输入字符串的集合。\n\n停机问题是语言 $A_{TM} = \\{ \\langle M, w \\rangle \\mid M \\text{ is a TM that halts on input string } w \\}$。\n空性问题是语言 $EMPTY_{TM} = \\{ \\langle M \\rangle \\mid M \\text{ is a TM and } L(M) = \\emptyset \\}$。\n\n如果可以使用一个针对语言 $L_2$ 的预言机（黑盒求解器）来判定语言 $L_1$，则称语言 $L_1$ 图灵可归约于语言 $L_2$，记作 $L_1 \\le_T L_2$。\n如果存在一个可计算函数 $f$，使得对于任意字符串 $x$，$x \\in L_1$ 当且仅当 $f(x) \\in L_2$，则称语言 $L_1$ 多一归约于语言 $L_2$，记作 $L_1 \\le_m L_2$。\n\n考虑以下关于这些语言及其补集之间关系的陈述，其中 $\\overline{L}$ 表示语言 $L$ 的补集。如果存在一台图灵机，它对语言中的每个字符串都会停机并接受，而对不在此语言中的字符串则拒绝或无限循环，那么这个语言被称为可识别语言。\n\n下列哪个陈述是正确的？\n\nA. $EMPTY_{TM}$ 图灵可归约于 $A_{TM}$。\nB. $EMPTY_{TM}$ 多一归约于 $A_{TM}$。\nC. 空性问题的补集 $\\overline{EMPTY_{TM}}$ 是一个可识别语言。\nD. 停机问题的补集 $\\overline{A_{TM}}$ 是一个可识别语言。\nE. $A_{TM}$ 图灵可归约于 $EMPTY_{TM}$。", "solution": "我们使用标准的构造和定义来分析每个陈述。\n\n首先，回顾一下定义：\n- $A_{TM} = \\{\\langle M,w\\rangle \\mid M \\text{ halts on input } w\\}$。\n- $EMPTY_{TM} = \\{\\langle M\\rangle \\mid L(M) = \\emptyset\\}$。\n- 如果某个图灵机停机并恰好接受语言中的所有字符串，那么这个语言是可识别的。\n\nA. $EMPTY_{TM} \\le_{T} A_{TM}$。\n对于任意给定的 $\\langle M\\rangle$，构造一个图灵机 $N_{M}$，它忽略其输入 $d$，并按如下方式运行：交叉模拟所有字符串 $x$ 并逐步模拟 $M(x)$；如果任何一个模拟到达了接受状态，那么 $N_{M}$ 就在输入 $d$ 上停机（比如说，接受）。于是\n$$\n\\langle M\\rangle \\in \\overline{EMPTY_{TM}} \\iff \\langle N_{M}, d\\rangle \\in A_{TM},\n$$\n因此\n$$\n\\langle M\\rangle \\in EMPTY_{TM} \\iff \\langle N_{M}, d\\rangle \\notin A_{TM}.\n$$\n通过向 $A_{TM}$ 预言机对 $\\langle N_{M},d\\rangle$ 进行一次查询并对结果取反，我们可以判定 $EMPTY_{TM}$，这证明了 $EMPTY_{TM} \\le_{T} A_{TM}$。因此 A 是正确的。\n\nB. $EMPTY_{TM} \\le_{m} A_{TM}$。\n假设，为了引出矛盾，存在一个可计算函数 $f$ 使得\n$$\n\\langle M\\rangle \\in EMPTY_{TM} \\iff f(\\langle M\\rangle) \\in A_{TM}.\n$$\n由于 $A_{TM}$ 是可识别的，将 $A_{TM}$ 的识别器与 $f$ 复合，将会得到一个 $EMPTY_{TM}$ 的识别器。但是 $EMPTY_{TM}$ 是不可识别的（根据莱斯定理或关于图灵机性质的标准结论），这导致了矛盾。因此 B 是错误的。\n\nC. $\\overline{EMPTY_{TM}}$ 是可识别的。\n我们有\n$$\n\\langle M\\rangle \\in \\overline{EMPTY_{TM}} \\iff \\exists x\\,\\exists t\\ \\big[M \\text{ accepts } x \\text{ within } t \\text{ steps}\\big].\n$$\n一个识别器可以交叉模拟所有的对 $(x,t)$，模拟 $M(x)$ 运行 $t$ 步，如果找到了一个接受的计算过程，就接受。因此 $\\overline{EMPTY_{TM}}$ 是可识别的。因此 C 是正确的。\n\nD. $\\overline{A_{TM}}$ 是可识别的。\n由于 $A_{TM}$ 是可识别的且不可判定的，如果 $\\overline{A_{TM}}$ 也是可识别的，那么通过交叉模拟两个识别器，$A_{TM}$ 将是可判定的，而这是不可能的。因此 $\\overline{A_{TM}}$ 是不可识别的，D 是错误的。\n\nE. $A_{TM} \\le_{T} EMPTY_{TM}$。\n给定 $\\langle M,w\\rangle$，构建一个图灵机 $N_{M,w}$，它对任意输入 $y$ 模拟 $M(w)$；如果 $M(w)$ 停机，则 $N_{M,w}$ 立即接受 $y$；否则它无限循环。于是\n$$\n\\langle M,w\\rangle \\in A_{TM} \\iff L(N_{M,w}) = \\Sigma^{*} \\iff \\langle N_{M,w}\\rangle \\notin EMPTY_{TM}.\n$$\n因此 $A_{TM} \\le_{m} \\overline{EMPTY_{TM}}$，这意味着 $A_{TM} \\le_{T} EMPTY_{TM}$。因此 E 是正确的。\n\n总结所有正确的陈述：A, C, 和 E 是正确的；B 和 D 是错误的。", "answer": "$$\\boxed{ACE}$$", "id": "1457107"}]}