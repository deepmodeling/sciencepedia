{"hands_on_practices": [{"introduction": "将公式转换为前束范式的第一步，往往是消除阻碍量词移动的逻辑联结词，例如蕴含（$→$）。这个练习将带你实践最基础也是最关键的一步：在一个包含量词的公式中，运用 $A → B$ 等价于 $\\neg A \\lor B$ 的规则，为后续的量词提取扫清障碍。通过这个练习 ([@problem_id:1464836])，你将掌握前束范式转换的起点。", "problem": "在计算复杂性理论中，量化布尔公式 (QBF) 是一种命题逻辑公式，其中的变量可以被量化。如果一个 QBF 具有 $Q_1 x_1 Q_2 x_2 \\dots Q_n x_n \\phi$ 的形式，其中每个 $Q_i$ 是全称量词 ($\\forall$) 或存在量词 ($\\exists$)，$x_i$ 是不同的布尔变量，而 $\\phi$ 是一个无量词的布尔公式，那么这个 QBF 就处于前束范式 (PNF) 中。\n\n任何 QBF 都可以被转换成一个等价的前束范式公式。考虑以下 QBF：\n$$ \\psi = (\\forall x_1: (x_1 \\land \\neg x_2)) \\rightarrow (\\exists x_3: (x_3 \\lor x_1)) $$\n将其转换为 PNF 的过程涉及一系列应用逻辑等价式的步骤，以将所有量词移到公式的最前面。第一步通常是消除阻碍量词移动的逻辑联结词，例如蕴含 ($\\rightarrow$)。\n\n下列哪个公式与 $\\psi$ 逻辑等价，并且是应用适当规则消除蕴含联结词后的直接结果？\n\nA. $\\forall x_1 \\exists x_3: ((x_1 \\land \\neg x_2) \\rightarrow (x_3 \\lor x_1))$\n\nB. $(\\exists x_1: \\neg(x_1 \\land \\neg x_2)) \\lor (\\exists x_3: (x_3 \\lor x_1))$\n\nC. $\\neg(\\forall x_1: (x_1 \\land \\neg x_2)) \\lor (\\exists x_3: (x_3 \\lor x_1))$\n\nD. $(\\forall x_1: \\neg(x_1 \\land \\neg x_2)) \\land (\\exists x_3: (x_3 \\lor x_1))$", "solution": "我们使用标准的命题等价式来消除蕴含：对于任意公式 $A$ 和 $B$，等价式 $A \\rightarrow B \\equiv \\neg A \\lor B$ 成立。\n\n将 $\\psi$ 中的前件和后件确定为：\n$$\nA = (\\forall x_{1} : (x_{1} \\land \\neg x_{2})), \\quad B = (\\exists x_{3} : (x_{3} \\lor x_{1})).\n$$\n应用该等价式得到：\n$$\n\\psi \\equiv \\neg(\\forall x_{1} : (x_{1} \\land \\neg x_{2})) \\lor (\\exists x_{3} : (x_{3} \\lor x_{1})).\n$$\n这与选项 C 完全匹配。选项 A 保持了蕴含不变。选项 B 错误地改变了量词和结构。选项 D 用合取替换了蕴含，这不是正确的等价关系。", "answer": "$$\\boxed{C}$$", "id": "1464836"}, {"introduction": "在处理复杂的逻辑公式时，我们常常会遇到同一个变量在不同量词作用域下被重复使用的情况。这个练习 ([@problem_id:1467507]) 旨在让你掌握处理这种情况的关键技巧：通过变量重命名（即α-转换）来避免“变量捕获”的错误。在此基础上，你将进一步练习如何正确地将量词从析取（$\\lor$）联结词中提取出来，这是构建复杂公式前束范式不可或缺的一步。", "problem": "在计算复杂性理论中，真量化布尔公式（True Quantified Boolean Formula, TQBF）是量化布尔逻辑中的一个公式，它要求是前束范式。一个公式如果具有 $\\mathcal{Q}_1 v_1 \\mathcal{Q}_2 v_2 \\dots \\mathcal{Q}_n v_n \\psi$ 的形式，那么它就是前束范式，其中每个 $\\mathcal{Q}_i$ 是一个全称量词 ($\\forall$) 或一个存在量词 ($\\exists$)，$v_i$ 是不同的布尔变量，而 $\\psi$ 是一个不含任何量词的布尔公式，它涉及变量 $v_1, \\dots, v_n$ 以及可能存在的其他自由变量。\n\n考虑以下量化布尔公式 $\\Phi$，其中 $x, y,$ 和 $z$ 是布尔变量：\n$$ \\Phi = (\\forall x (x \\lor y)) \\lor (\\exists x (\\neg x \\land z)) $$\n下列哪个前束范式公式与 $\\Phi$ 逻辑等价？请注意，变量 $a$ 和 $b$ 是为了重命名而引入的新的、不同的布尔变量。\n\nA. $\\forall x \\exists x (((x \\lor y) \\lor (\\neg x \\land z)))$\n\nB. $\\forall a \\exists b (((a \\lor y) \\land (\\neg b \\land z)))$\n\nC. $\\exists b \\forall a (((a \\lor y) \\lor (\\neg b \\land z)))$\n\nD. $\\forall a \\forall b (((a \\lor y) \\lor (\\neg b \\land z)))$\n\nE. $\\exists a \\exists b (((a \\lor y) \\lor (\\neg b \\land z)))$", "solution": "我们从给定的公式开始\n$$\\Phi = (\\forall x\\,(x \\lor y)) \\lor (\\exists x\\,(\\neg x \\land z)).$$\n首先，执行 α-换名（alpha-conversion）以确保不同作用域中的约束变量是不同的。将左边析取项中的约束变量重命名为 $a$，右边析取项中的约束变量重命名为 $b$：\n$$\\Phi \\equiv (\\forall a\\,(a \\lor y)) \\lor (\\exists b\\,(\\neg b \\land z)).$$\n使用析取与存在量词结合的前束范式变换规则：如果 $b$ 在 $\\alpha$ 中不是自由变量，则 $\\alpha \\lor (\\exists b\\,\\gamma) \\equiv \\exists b\\,(\\alpha \\lor \\gamma)$。此处，$\\alpha$ 是 $(\\forall a\\,(a \\lor y))$ 且 $b$ 在其中不是自由变量，所以\n$$(\\forall a\\,(a \\lor y)) \\lor (\\exists b\\,(\\neg b \\land z)) \\equiv \\exists b\\,\\big((\\forall a\\,(a \\lor y)) \\lor (\\neg b \\land z)\\big).$$\n接下来，使用析取与全称量词结合的前束范式变换规则：如果 $a$ 在 $\\beta$ 中不是自由变量，则 $(\\forall a\\,\\varphi) \\lor \\beta \\equiv \\forall a\\,(\\varphi \\lor \\beta)$。此处，$\\beta$ 是 $(\\neg b \\land z)$ 且 $a$ 在其中不是自由变量，因此\n$$\\exists b\\,\\big((\\forall a\\,(a \\lor y)) \\lor (\\neg b \\land z)\\big) \\equiv \\exists b\\,\\forall a\\,\\big((a \\lor y) \\lor (\\neg b \\land z)\\big).$$\n因此，与 $\\Phi$ 等价的一个前束范式是\n$$\\exists b\\,\\forall a\\,\\big((a \\lor y) \\lor (\\neg b \\land z)\\big),$$\n这与选项 C 相符。（选项 A 违反了变量必须不同的要求；选项 B、D 和 E 以与原公式不等价的方式改变了连接词结构或量词类型。）", "answer": "$$\\boxed{C}$$", "id": "1467507"}, {"introduction": "前束范式不仅是一种语法上的标准形式，更是许多逻辑算法（尤其在自动定理证明领域）的重要基础。这个综合性练习 ([@problem_id:2978926]) 将带领你走完从一阶逻辑公式到机器可处理的子句集的完整流程，完美展示了前束范式的实际应用价值。你将把一个给定的公式转换为前束范式，接着进行Skolem化和子句化，并最终通过归结方法证明其不可满足性，从而深刻理解前束范式在整个逻辑推理链条中的核心作用。", "problem": "设 $\\mathcal{L}$ 是一个一阶语言，包含一个一元函数符号 $f$ 和一个一元谓词符号 $P$。固定一个正整数 $n \\in \\mathbb{N}$ 且 $n \\geq 1$。考虑闭合语句\n$$\n\\Phi_{n} \\;:=\\; \\bigl(\\exists x\\, P(x)\\bigr)\\;\\wedge\\;\\bigl(\\forall y\\,(P(y)\\rightarrow P(f(y)))\\bigr)\\;\\wedge\\;\\bigl(\\forall z\\,\\neg P(f^{n}(z))\\bigr),\n$$\n其中 $f^{n}(t)$ 表示将 $f$ 应用于项 $t$ 的 $n$ 次迭代。\n\n你的任务是：\n- 将 $\\Phi_{n}$ 转换为前束范式 (PNF)，仅使用逻辑有效的等价式和变量标准化来证明每个转换步骤的合理性，以避免变量捕获。\n- 对PNF语句进行Skolem化，得到一个等可满足公式，并明确指出所引入的Skolem符号的元数和名称。然后去掉全称量词，并将母式转换为合取范式 (CNF)，即文字析取的合取。陈述最终的子句集。\n- 为Skolem化的子句集定义Herbrand域 $\\mathcal{U}$ 和Herbrand基 $\\mathcal{B}$。对于一个基项 $t$，如果 $t$ 是一个常量符号，则定义其深度 $\\operatorname{depth}(t)=0$，且 $\\operatorname{depth}(f(t'))=1+\\operatorname{depth}(t')$。对于 $d \\in \\mathbb{N}$，令深度为 $d$ 的Herbrand展开为子句的所有基实例的集合，其中每个基项的深度至多为 $d$。确定最小深度 $d_{\\min}(n)$，使得深度为 $d_{\\min}(n)$ 的Herbrand展开是命题上不可满足的。\n- 仅使用项的深度至多为 $d_{\\min}(n)$ 的基实例，给出一个推导出空子句的归结反驳，并解释为何任何更小的深度都无法产生反驳（即，验证其最小性）。\n- 以 $n$ 的闭式表达式形式给出 $d_{\\min}(n)$ 的最终答案。最终答案必须是无单位的单个表达式。\n\n你的推理必须在每个阶段验证其正确性，通过引用变换是保持逻辑等价性还是仅保持等可满足性，并明确证明对于反驳来说是必要且充分的项深度界限。", "solution": "该问题要求对一阶语句 $\\Phi_n$ 进行多步分析。我们将首先验证问题，然后系统地处理每个任务：转换为前束范式，Skolem化并转换为合取范式，进行Herbrand分析以找到最小反驳深度，并提供一个形式化的归结反驳。\n\n给定的语句是：\n$$\n\\Phi_{n} \\;:=\\; \\bigl(\\exists x\\, P(x)\\bigr)\\;\\wedge\\;\\bigl(\\forall y\\,(P(y)\\rightarrow P(f(y)))\\bigr)\\;\\wedge\\;\\bigl(\\forall z\\,\\neg P(f^{n}(z))\\bigr)\n$$\n对于一个正整数 $n \\geq 1$。\n\n**1. 转换为前束范式 (PNF)**\n\n目标是将所有量词移到公式的前面。该语句是三个子公式的合取，其中量化变量（$x$、$y$、$z$）是不同的。我们可以使用标准的逻辑等价式逐个将量词提出。只要 $v$ 在 $B$ 中不是自由变量，量词 $\\mathcal{Q}v$ 就可以从合取 $(\\mathcal{Q}v\\, A(v)) \\wedge B$ 中移出，形成 $\\mathcal{Q}v\\,(A(v) \\wedge B)$。\n\n让我们从 $\\Phi_n$ 开始：\n$$\n\\Phi_{n} = \\bigl(\\exists x\\, P(x)\\bigr)\\;\\wedge\\;\\bigl(\\forall y\\,(P(y)\\rightarrow P(f(y)))\\bigr)\\;\\wedge\\;\\bigl(\\forall z\\,\\neg P(f^{n}(z))\\bigr)\n$$\n首先，我们移动存在量词 $\\exists x$。变量 $x$ 在第二个和第三个合取项中不是自由变量。此变换保持逻辑等价性。\n$$\n\\Phi_{n} \\equiv \\exists x \\left( P(x) \\;\\wedge\\; \\bigl(\\forall y\\,(P(y)\\rightarrow P(f(y)))\\bigr)\\;\\wedge\\;\\bigl(\\forall z\\,\\neg P(f^{n}(z))\\bigr) \\right)\n$$\n接下来，我们移动全称量词 $\\forall y$。变量 $y$ 在 $P(x)$ 或第三个合取项中不是自由变量。此步骤也保持逻辑等价性。\n$$\n\\Phi_{n} \\equiv \\exists x \\forall y \\left( P(x) \\;\\wedge\\; (P(y)\\rightarrow P(f(y)))\\;\\wedge\\;\\bigl(\\forall z\\,\\neg P(f^{n}(z))\\bigr) \\right)\n$$\n最后，我们移动全称量词 $\\forall z$。变量 $z$ 在 $P(x) \\wedge (P(y)\\rightarrow P(f(y)))$ 中不是自由变量。此步骤保持逻辑等价性。\n$$\n\\Phi_{n} \\equiv \\exists x \\forall y \\forall z \\left( P(x) \\;\\wedge\\; (P(y)\\rightarrow P(f(y)))\\;\\wedge\\; \\neg P(f^{n}(z)) \\right)\n$$\n这就是 $\\Phi_n$ 的前束范式。其前束为 $\\exists x \\forall y \\forall z$，母式为 $P(x) \\wedge (P(y)\\rightarrow P(f(y))) \\wedge \\neg P(f^{n}(z))$。\n\n**2. Skolem化与转换为CNF**\n\n我们从PNF开始。Skolem化消除了存在量词。该变换保持等可满足性，但不保持逻辑等价性。\nPNF是 $\\exists x \\forall y \\forall z M(x, y, z)$，其中 $M$ 是母式。\n存在量词 $\\exists x$ 是最外层的。它不在任何全称量词的辖域内。我们用一个新的Skolem常量（一个元数为0的函数），命名为 $c$，来替换变量 $x$。\n得到的公式是：\n$$\n\\forall y \\forall z \\left( P(c) \\;\\wedge\\; (P(y)\\rightarrow P(f(y)))\\;\\wedge\\; \\neg P(f^{n}(z)) \\right)\n$$\n接下来，我们去掉全称量词，并默认变量 $y$ 和 $z$ 是在整个公式上全称量化的。这给出了无量词的母式：\n$$\nP(c) \\;\\wedge\\; (P(y)\\rightarrow P(f(y)))\\;\\wedge\\; \\neg P(f^{n}(z))\n$$\n现在，我们将此母式转换为合取范式 (CNF)，即子句（文字的析取）的合取。\n第一个合取项 $P(c)$ 是一个文字，因此是一个子句。\n第二个合取项 $P(y)\\rightarrow P(f(y))$ 使用等价式 $A \\rightarrow B \\equiv \\neg A \\vee B$ 进行转换。这产生了子句 $\\neg P(y) \\vee P(f(y))$。\n第三个合取项 $\\neg P(f^{n}(z))$ 是一个文字，因此也是一个子句。\n最终的CNF公式是：\n$$\nP(c) \\;\\wedge\\; (\\neg P(y) \\vee P(f(y))) \\;\\wedge\\; \\neg P(f^{n}(z))\n$$\n相应的子句集是归结的标准输入，为：\n$$\nS = \\left\\{ \\{P(c)\\}, \\{\\neg P(y), P(f(y))\\}, \\{\\neg P(f^{n}(z))\\} \\right\\}\n$$\n\n**3. Herbrand域、Herbrand基与最小不可满足深度**\n\n子句集 $S$ 的语言包含一个常量符号 $c$，一个一元函数符号 $f$，以及一个一元谓词符号 $P$。\n\n**Herbrand域** $\\mathcal{U}$ 是由常量和函数符号构造出的所有基项的集合。\n$$\n\\mathcal{U} = \\{c, f(c), f(f(c)), \\dots\\} = \\{ f^k(c) \\mid k \\in \\mathbb{N}_0 \\}\n$$\n其中 $f^0(c)$ 表示 $c$。\n\n**Herbrand基** $\\mathcal{B}$ 是所有基原子的集合。\n$$\n\\mathcal{B} = \\{P(t) \\mid t \\in \\mathcal{U}\\} = \\{ P(f^k(c)) \\mid k \\in \\mathbb{N}_0 \\}\n$$\n基项 $t$ 的深度定义为 $\\operatorname{depth}(c) = 0$ 且 $\\operatorname{depth}(f(t')) = 1 + \\operatorname{depth}(t')$。由此得出 $\\operatorname{depth}(f^k(c)) = k$。\n\n深度为 $d$ 的Herbrand展开，记为 $H_d$，是 $S$ 中子句的所有基实例的集合，其中所涉及的每个项的深度至多为 $d$。\n让我们分析反驳所需的子句。直观的矛盾来自于推导出 $P(f^n(c))$ 并使其与 $\\neg P(f^n(z))$ 的一个实例相矛盾。\n\n- 子句 $\\{P(c)\\}$ 是基子句，项 $c$ 的深度为0。对于任何 $d \\ge 0$，它都在 $H_d$ 中。\n- $\\{\\neg P(y), P(f(y))\\}$ 的基实例是通过将 $y$ 替换为基项 $t=f^k(c) \\in \\mathcal{U}$ 来形成的。这得到 $\\{\\neg P(f^k(c)), P(f^{k+1}(c))\\}$。这些项的深度分别为 $k$ 和 $k+1$。为了使该子句在 $H_d$ 中，我们需要 $\\operatorname{depth}(f^{k+1}(c)) = k+1 \\le d$，这意味着 $k \\le d-1$。\n- $\\{\\neg P(f^{n}(z))\\}$ 的基实例是通过将 $z$ 替换为 $t=f^k(c) \\in \\mathcal{U}$ 来形成的。这得到 $\\{\\neg P(f^n(f^k(c)))\\} = \\{\\neg P(f^{n+k}(c))\\}$。该项的深度是 $n+k$。为了使该子句在 $H_d$ 中，我们需要 $n+k \\le d$，这意味着 $k \\le d-n$。\n\n为了得到矛盾，我们需要推导出空子句。一个归结证明过程如下：\n1. 从 $\\{P(c)\\}$ 和 $\\{\\neg P(c), P(f(c))\\}$，推导出 $\\{P(f(c))\\}$。\n2. 从 $\\{P(f(c))\\}$ 和 $\\{\\neg P(f(c)), P(f^2(c))\\}$，推导出 $\\{P(f^2(c))\\}$。\n...\n$n$. 通过链接这些归结步骤 $n$ 次，从 $\\{P(f^{n-1}(c))\\}$ 和 $\\{\\neg P(f^{n-1}(c)), P(f^n(c))\\}$，我们推导出 $\\{P(f^n(c))\\}$。\n$n+1$. 这个推导出的子句 $\\{P(f^n(c))\\}$ 随后可以与一个负子句如 $\\{\\neg P(f^n(c))\\}$ 进行归结，以产生空子句。\n\n让我们检查这个推导的深度要求。\n- 要通过链式归结推导出 $\\{P(f^n(c))\\}$，我们需要第二个子句的所有基实例，即 $\\{\\neg P(f^k(c)), P(f^{k+1}(c))\\}$，对于 $k=0, 1, \\dots, n-1$。这个链中的最后一个实例，即 $k=n-1$ 的情况，涉及到项 $f^n(c)$，其深度为 $n$。因此，我们需要 $d \\ge n$。\n- 为了得到矛盾的负子句，我们可以用 $z=c$ 来实例化 $\\{\\neg P(f^n(z))\\}$。这产生了 $\\{\\neg P(f^n(c))\\}$。项 $f^n(c)$ 的深度为 $n$。因此，为了让这个子句出现在我们的基集中，我们需要 $d \\ge n$。\n\n反驳的两个基本要素都要求深度至少为 $n$。这表明最小深度是 $d_{\\min}(n) = n$。\n\n让我们验证这一点。\n如果 $d=n$，深度为 $n$ 的展开 $H_n$ 包含：\n- $\\{P(c)\\}$。\n- $\\{\\neg P(f^k(c)), P(f^{k+1}(c))\\}$ 对于 $k=0, 1, \\dots, n-1$。\n- $\\{\\neg P(f^{n+k}(c))\\}$ 对于 $k=0$，即单个子句 $\\{\\neg P(f^n(c))\\}$。\n这个集合是不可满足的，正如将在下一节的反驳中展示的那样。因此，深度 $n$ 是充分的。\n\n现在考虑深度 $d=n-1$。展开 $H_{n-1}$ 包含：\n- $\\{P(c)\\}$。\n- $\\{\\neg P(f^k(c)), P(f^{k+1}(c))\\}$ 对于 $k=0, 1, \\dots, n-2$。\n- 对于第三种类型的子句，我们需要 $n+k \\le n-1$，这意味着 $k \\le -1$。由于 $k$ 必须是一个非负整数，所以在 $H_{n-1}$ 中没有 $\\{\\neg P(f^n(z))\\}$ 的基实例。\n\n得到的子句集是 $H_{n-1} = \\{ \\{P(c)\\} \\} \\cup \\{ \\{\\neg P(f^k(c)), P(f^{k+1}(c))\\} \\mid k=0, \\dots, n-2 \\}$。\n这个集合是可满足的。考虑命题解释 $I$，其中对于所有 $i \\in \\{0, \\dots, n-1\\}$，$P(f^i(c))$ 为真，而对于所有其他基原子为假。\n- 子句 $\\{P(c)\\}$ 被满足，因为 $I(P(c))$ 为真。\n- 子句 $\\{\\neg P(f^k(c)), P(f^{k+1}(c))\\}$ 对于 $k \\in \\{0, \\dots, n-2\\}$ 被满足，因为 $I(P(f^{k+1}(c)))$ 为真（因为 $k+1 \\le n-1$）。\n由于Herbrand展开 $H_{n-1}$ 是可满足的，所以不能从中推导出反驳。\n因此，深度 $d=n-1$ 是不充分的。\n\n最小深度是 $d_{\\min}(n) = n$。\n\n**4. 归结反驳与最小性验证**\n\n使用项的深度至多为 $d_{\\min}(n)=n$ 的基实例，我们可以构造一个归结反驳。令 $R(A, B)$ 表示子句 $A$ 和 $B$ 的归结式。\n令 $C_1 = \\{P(c)\\}$，$C_{2,k} = \\{\\neg P(f^k(c)), P(f^{k+1}(c))\\}$，以及 $C_{3,0} = \\{\\neg P(f^n(c))\\}$。所有这些子句都在 $H_n$ 中。\n\n1. $R_0 = C_1 = \\{P(c)\\}$ (在 $H_n$ 中给定)\n2. $R_1 = R(R_0, C_{2,0}) = R(\\{P(c)\\}, \\{\\neg P(c), P(f(c))\\}) = \\{P(f(c))\\}$\n3. $R_2 = R(R_1, C_{2,1}) = R(\\{P(f(c))\\}, \\{\\neg P(f(c)), P(f^2(c))\\}) = \\{P(f^2(c))\\}$\n...\n$k+1$. $R_k = R(R_{k-1}, C_{2,k-1}) = \\{P(f^k(c))\\}$ 对于 $k=1, \\dots, n$。\n\n这个过程是一个归纳。设 $R_{k-1} = \\{P(f^{k-1}(c))\\}$。我们将其与 $C_{2,k-1} = \\{\\neg P(f^{k-1}(c)), P(f^k(c))\\}$ 进行归结，该子句在 $H_n$ 中，因为 $k-1 \\le n-1$。归结式是 $R_k = \\{P(f^k(c))\\}$。从 $R_0=\\{P(c)\\}$ 开始，经过 $n$ 步归结，我们可以推导出 $R_n=\\{P(f^n(c))\\}$。\n\n反驳的最后一步是：\n$n+1$. $R(R_n, C_{3,0}) = R(\\{P(f^n(c))\\}, \\{\\neg P(f^n(c))\\}) = \\square$ (空子句)。\n\n这就完成了反驳。\n\n深度 $d_{\\min}(n)=n$ 的最小性已在前面确定。任何更小的深度，例如 $n-1$，都会导致一个基子句集 $H_{n-1}$，该集合不包含任何负单元子句（如 $\\{\\neg P(t)\\}$）。如前所示，$H_{n-1}$ 是可满足的。根据归结的可靠性，一个可满足的子句集不能产生反驳（空子句）。因此，$d_{\\min}(n)$ 必须至少为 $n$。由于深度 $n$ 是充分的，所以它是最小的。\n\n最终答案是 $d_{\\min}(n)$ 的闭式表达式。\n根据分析，$d_{\\min}(n) = n$。", "answer": "$$\n\\boxed{n}\n$$", "id": "2978926"}]}