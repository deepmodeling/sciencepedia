## 引言
[命题逻辑](@entry_id:143535)是形式化推理的基石，而其核心在于**证明系统 (proof systems)**——一套用于从前提出发，通过严格的符号操作推导出结论的规则框架。理解这些系统不仅是掌握逻辑学的关键，也是通往计算机科学诸多理论领域的必经之路。然而，不同的[证明系统](@entry_id:156272)（如自然演绎、[相继式演算](@entry_id:154229)）在设计哲学与操作机制上大相径庭，它们之间的等价性、[相对效率](@entry_id:165851)以及深刻的理论联系是什么？这些系统又如何在[自动推理](@entry_id:151826)、算法复杂性分析和编程语言设计中发挥其强大作用？

本文旨在系统地回答这些问题。我们将从第一章 **“原则与机制”** 出发，深入剖析证明系统的抽象定义、可靠性与完全性等基本[元理论](@entry_id:638043)，并详细介绍几种主流证明[范式](@entry_id:161181)。随后，在第二章 **“应用与交叉学科联系”** 中，我们将视野扩展到计算机科学，探讨证明系统如何为[自动定理证明](@entry_id:154648)、[计算复杂性理论](@entry_id:272163)以及通过 [Curry-Howard 同构](@entry_id:633959)建立的编程语言理论提供坚实基础。最后，在第三章 **“动手实践”** 中，您将通过具体问题演练，将理论知识应用于实践。通过本次学习，您将不仅掌握[命题逻辑](@entry_id:143535)证明的构造方法，更能深刻理解其背后的计算意义与哲学内涵。

## 原则与机制

在前一章中，我们介绍了[命题逻辑](@entry_id:143535)作为形式化推理基础的概览。现在，我们将深入探讨其核心——**[证明系统](@entry_id:156272) (proof systems)**。一个证明系统为我们提供了一套严格的句法规则，用于从一组前提中推导出结论。本章的目标是系统地阐述[命题逻辑](@entry_id:143535)中主要证明系统的基本原则与内在机制。我们将从一个普适的、抽象的证明系统定义出发，然后考察几种主要的证明[范式](@entry_id:161181)，并最终探讨这些系统背后深刻的[元理论](@entry_id:638043)属性及其应用。

### 证明系统的抽象框架

在最抽象的层面上，一个[命题逻辑](@entry_id:143535)的证明系统 $P$ 可以被视为一个由**公理 (axioms)** 和**[推理规则](@entry_id:273148) (inference rules)** 构成的形式结构。其目的是生成一个**可导出关系 (derivability relation)**，我们通常用符号 $\vdash_P$ 来表示。这个关系存在于公式的集合（前提）与单个公式（结论）之间。

形式上，一个[证明系统](@entry_id:156272) $P = (\mathrm{Ax}, \mathcal{R})$ 由以下两部分组成 [@problem_id:2979831]：
1.  **公理集** $\mathrm{Ax}$：一个由[合式公式](@entry_id:636348)组成的集合。在许多系统中，这个集合是**模式化 (schematic)** 的，意味着它在**一致替换 (uniform substitution)** 下是封闭的。也就是说，如果 $\varphi \in \mathrm{Ax}$，且 $\sigma$ 是一个将命题变量映射到任意公式的替换函数，那么 $\sigma(\varphi)$ 也必须在 $\mathrm{Ax}$ 中。
2.  **[推理规则](@entry_id:273148)集** $\mathcal{R}$：一个由有限元[推理规则](@entry_id:273148)组成的集合。每条规则 $r \in \mathcal{R}$ 都有一个确定的元数 $k \in \mathbb{N}$，它允许我们从 $k$ 个前提公式 $\varphi_1, \ldots, \varphi_k$ 推断出一个结论公式 $\psi$。我们通常将此写作 $(\varphi_1, \ldots, \varphi_k) / \psi \in r$。如果一条规则在一致替换下保持其形式，我们称之为**结构性规则 (structural rule)**。

基于此，一个从前提集合 $\Gamma$ 到结论 $\varphi$ 的**推导 (derivation)** 或**证明 (proof)** 被定义为一个有限的公式序列 $\langle \psi_1, \ldots, \psi_n \rangle$，其中 $\psi_n = \varphi$。对于序列中的每一个公式 $\psi_i$，它必须满足以下条件之一：
*   $\psi_i$ 是一个**前提**，即 $\psi_i \in \Gamma$。
*   $\psi_i$ 是一条**公理**，即 $\psi_i \in \mathrm{Ax}$。
*   $\psi_i$ 是通过应用 $\mathcal{R}$ 中的某条规则，从序列中早于 $i$ 的某些公式 $\psi_{j_1}, \ldots, \psi_{j_k}$ (其中 $j_m  i$) 推导出来的。

如果存在这样一个推导，我们就说 $\varphi$ 可从 $\Gamma$ 在系统 $P$ 中导出，记作 $\Gamma \vdash_P \varphi$。

这个基于序列的定义可以被等价地刻画为一个归纳定义 [@problem_id:2979831]。可导出关系 $\vdash_P$ 是满足以下条件的**最小关系** $C$：
*   **自反性 (Reflexivity)**：若 $\varphi \in \Gamma$，则 $\Gamma \mathrel{C} \varphi$。
*   **公理应用 (Axiom Application)**：若 $\varphi \in \mathrm{Ax}$，则对任意 $\Gamma$ 都有 $\Gamma \mathrel{C} \varphi$。
*   **规则闭包 (Closure under Rules)**：若 $(\varphi_1, \ldots, \varphi_k) / \psi \in r$，且对所有 $i=1, \ldots, k$ 都有 $\Gamma \mathrel{C} \varphi_i$，则 $\Gamma \mathrel{C} \psi$。
*   **[单调性](@entry_id:143760) (Monotonicity)**：若 $\Gamma \subseteq \Delta$ 且 $\Gamma \mathrel{C} \varphi$，则 $\Delta \mathrel{C} \varphi$。

这个抽象框架揭示了所有标准[证明系统](@entry_id:156272)的两个根本属性。首先是**紧致性 (compactness)**。因为任何推导都是一个有限序列，它最多只能使用有限数量的前提。因此，如果 $\Gamma \vdash_P \varphi$，那么必然存在一个有限的[子集](@entry_id:261956) $\Delta \subseteq \Gamma$，使得 $\Delta \vdash_P \varphi$ 成立 [@problem_id:2979831]。其次，如果一个系统的公理和规则都是**结构性的 (structural)**，那么整个可导出关系也是结构性的。这意味着对于任何一致替换 $\sigma$，只要 $\Gamma \vdash_P \varphi$，就一定有 $\sigma[\Gamma] \vdash_P \sigma(\varphi)$，其中 $\sigma[\Gamma] = \{\sigma(\psi) \mid \psi \in \Gamma\}$ [@problem_id:2979831]。这个属性保证了逻辑的普遍性——一个有效的推论模式不依赖于其中原子命题的具体内容。

### [语法与语义](@entry_id:148153)：可靠性与完全性

证明系统提供的是一种纯粹的**句法 (syntactic)** 概念，即基于符号操作的可导出性 $\Gamma \vdash A$。然而，逻辑的最终目的是为了确保真理的保持。这就引出了**语义 (semantic)** 的概念，即**[逻辑后承](@entry_id:155068) (logical consequence)**，记作 $\Gamma \models A$。在经典的[命题逻辑](@entry_id:143535)中，$\Gamma \models A$ 意味着在每一个使得 $\Gamma$ 中所有公式都为真的**赋值 (valuation)** 下，公式 $A$ 也必须为真 [@problem_id:2979869]。

句法与语义之间的桥梁由两个核心的元定理——可靠性与完全性——构建而成 [@problem_id:2979869]：
*   **可靠性 (Soundness)**：如果 $\Gamma \vdash A$，那么 $\Gamma \models A$。这个性质保证了[证明系统](@entry_id:156272)是“诚实”的：它所能证明的任何结论在语义上都是有效的。一个不可靠的系统是无用的，因为它会从真前提推导出[假结](@entry_id:168307)论。
*   **完全性 (Completeness)**：如果 $\Gamma \models A$，那么 $\Gamma \vdash A$。这个性质保证了证明系统是“足够强大”的：任何在语义上有效的结论都能在系统内被证明。

对于经典的[命题逻辑](@entry_id:143535)，存在着许多著名的[证明系统](@entry_id:156272)，它们都被证明是既可靠又完全的。这意味着对于这些系统，句法上的可导出性 $\vdash$ 和语义上的[逻辑后承](@entry_id:155068) $\models$ 恰好重合。例如，在自然演绎系统中，从前提集合 $\Gamma = \{(p \to q), (q \to r), p\}$ 出发，我们可以轻易地构造一个推导来证明结论 $A = r$。同时，通过真值表分析，我们也可以验证任何使 $\Gamma$ 为真的赋值都必须使 $r$ 为真。因此，我们有 $\Gamma \vdash r$ 和 $\Gamma \models r$ [@problem_id:2979869]。

值得注意的是，经典[命题逻辑](@entry_id:143535)的完全性是**强完全性 (strong completeness)**，即它对任意（可能是无限的）前提集 $\Gamma$ 都成立。这与某些更强的逻辑（如二阶逻辑）形成对比，后者只满足弱完全性（即只对空前提集有效）[@problem_id:2979869]。

### [命题证明系统](@entry_id:274440)的主要[范式](@entry_id:161181)

尽管所有可靠且完全的系统在“能证明什么”这一点上是等价的，但它们在“如何证明”这一点上却大相径庭。不同的证明系统[范式](@entry_id:161181)体现了不同的推理哲学，并在理论研究和实际应用中各有优势。

#### 自然演绎

由 [Gerhard Gentzen](@entry_id:150492) 提出的**自然演绎 (Natural Deduction, ND)** 系统，其设计初衷是为了尽可能地贴近人类的“自然”推理模式。它的核心思想是为每个[逻辑联结词](@entry_id:146395)提供一组**引入规则 (introduction rules)** 和一组**消去规则 (elimination rules)**。引入规则说明了如何构建一个以该联结词为主要联结词的公式，而消去规则则说明了如何使用这样一个公式来推导其他结论。

以下是经典自然演绎系统 (CND) 中主要联结词的规则 [@problem_id:2979851]：
*   **合取 ($\land$)**：
    *   **引入 ($\land$I)**：从 $A$ 和 $B$ 可以推导出 $A \land B$。
    *   **消去 ($\land$E)**：从 $A \land B$ 可以推导出 $A$；也可以推导出 $B$。
*   **析取 ($\lor$)**：
    *   **引入 ($\lor$I)**：从 $A$ 可以推导出 $A \lor B$；从 $B$ 也可以推导出 $A \lor B$。
    *   **消去 ($\lor$E)**：这是一个“按情况推理”的规则。如果你有 $A \lor B$，并且能从一个临时假设 $A$ 推导出 $C$，同时也能从一个临时假设 $B$ 推导出**同一个** $C$，那么你就可以断定 $C$ 成立，并**撤销 (discharge)** 这两个临时假设 $A$ 和 $B$。
*   **蕴含 ($\to$)**：
    *   **引入 ($\to$I)**：如果你能从一个临时假设 $A$ 开始，最终推导出 $B$，那么你就可以断定 $A \to B$ 成立，并撤销假设 $A$。这个结论 $A \to B$ 不再依赖于被撤销的假设 $A$。
    *   **消去 ($\to$E)**：即**[肯定前件式](@entry_id:268205) (Modus Ponens)**。从 $A$ 和 $A \to B$ 可以推导出 $B$。
*   **否定 ($\neg$) 与矛盾 ($\bot$)**：
    *   **引入 ($\neg$I)**：如果从一个临时假设 $A$ 推导出了矛盾 $\bot$（通常由某个公式及其否定共同导出），那么可以断定 $\neg A$ 并撤销假设 $A$。
    *   **消去 ($\neg$E)**：从 $A$ 和 $\neg A$ 可以推导出矛盾 $\bot$。
    *   **经典规则**：为了使系统成为经典的（而非直觉主义的），需要一个额外的规则。最常见的规则是**反证法 (Reductio ad Absurdum, RAA)**：如果从一个临时假设 $\neg A$ 推导出了矛盾 $\bot$，那么可以断定 $A$ 并撤销假设 $\neg A$。

**假设撤销**机制是自然演绎的精髓。它通过明确的**作用域 (scope)** 限制了临时假设的有效范围，使得我们可以进行假设性推理，而不会污染最终的结论。

#### [相继式演算](@entry_id:154229)

同样由 Gentzen 提出的**[相继式演算](@entry_id:154229) (Sequent Calculus)**，与自然演绎不同，它不直接操作公式，而是操作形如 $\Gamma \Rightarrow \Delta$ 的**相继式 (sequent)**。其中 $\Gamma$（前件）和 $\Delta$（后件）是公式的有限多重集。其语义解释是“$\Gamma$ 中所有公式的合取蕴含了 $\Delta$ 中所有公式的析取” [@problem_id:2979861]。一个[相继式演算](@entry_id:154229)的证明是一个树状结构，其叶节点是公理，根节点是待证明的相继式。

[相继式演算](@entry_id:154229)的规则主要分为三类：
1.  **恒等公理 (Identity Axiom)**：$A \Rightarrow A$。这是所有推导的起点，表达了一个命题蕴含其自身的平凡事实。
2.  **结构规则 (Structural Rules)**：这些规则只操作相继式的结构（即公式的位置、数量），而不关心公式的逻辑内容 [@problem_id:2979846]。
    *   **弱化 (Weakening)**：允许在相继式的任意一侧添加任意公式。例如，左弱化规则是从 $\Gamma \Rightarrow \Delta$ 推导出 $\Gamma, A \Rightarrow \Delta$。
    *   **缩并 (Contraction)**：允许将相继式一侧的两个相同公式合并为一个。例如，左缩并规则是从 $\Gamma, A, A \Rightarrow \Delta$ 推导出 $\Gamma, A \Rightarrow \Delta$。
    *   **交换 (Exchange)**：允许改变相继式一侧公式的顺序。例如，右[交换规则](@entry_id:184421)是从 $\Gamma \Rightarrow \Delta, A, B$ 推导出 $\Gamma \Rightarrow \Delta, B, A$。
3.  **逻辑规则 (Logical Rules)**：这些规则在相继式的前件（左侧）或后件（右侧）引入一个[逻辑联结词](@entry_id:146395)。每条规则都精确地反映了联结词的语义。例如 [@problem_id:2979861]：
    *   **($\land$-右)**：若能证明 $\Gamma \Rightarrow \Delta, A$ 和 $\Gamma \Rightarrow \Delta, B$，则可证明 $\Gamma \Rightarrow \Delta, A \land B$。
    *   **($\lor$-左)**：若能证明 $\Gamma, A \Rightarrow \Delta$ 和 $\Gamma, B \Rightarrow \Delta$，则可证明 $\Gamma, A \lor B \Rightarrow \Delta$。
    *   **($\to$-右)**：若能证明 $\Gamma, A \Rightarrow \Delta, B$，则可证明 $\Gamma \Rightarrow \Delta, A \to B$。
4.  **切规则 (Cut Rule)**：
    $$
    \frac{\Gamma \Rightarrow \Delta, A \qquad \Gamma', A \Rightarrow \Delta'}{\Gamma, \Gamma' \Rightarrow \Delta, \Delta'}
    $$
    切规则是[相继式演算](@entry_id:154229)中的一个广义的[肯定前件式](@entry_id:268205)，它允许我们将两个证明“粘贴”在一起，并消去中间的“引理”$A$。

[相继式演算](@entry_id:154229)的对称性和规则的局部性使其成为进行**[证明论](@entry_id:151111) (proof theory)** 分析的理想工具。

#### 分析树

**分析树 (Analytic Tableaux)** 方法是一种基于语义的证明程序，其目标是系统地**[证伪](@entry_id:260896) (refute)** 一个公式。换言之，为了证明一个公式 $A$ 是[重言式](@entry_id:143929)，我们尝试构建一个模型（赋值）使得 $A$ 为假。如果所有尝试都失败并导致矛盾，那么我们就证明了 $A$ 必须为真。

该方法使用**带符号的公式 (signed formulas)**，形如 $T A$（“$A$ 为真”）和 $F A$（“$A$ 为假”）。证明过程是从一个初始的带符号公式集合（例如，为了证明 $A$，我们从 $\{F A\}$ 开始）出发，构建一棵树。树的每个节点都是一个带符号的公式，通过应用**展开规则 (expansion rules)** 不断向下延伸 [@problem_id:2979867]。这些规则直接源于联结词的真值条件：
*   **合取类型（Alpha 规则）**：如果一个分支上有一个需要其两个子部分都为真的公式（如 $T(A \land B)$），我们就在该分支下同时添加这两个子部分（$T A$ 和 $T B$）。
*   **析取类型（Beta 规则）**：如果一个分支上有一个只需要其两个子部分之一为真的公式（如 $T(A \lor B)$），该分支就会**分裂**成两个子分支，一个包含 $T A$，另一个包含 $T B$。

例如，蕴含的规则是 [@problem_id:2979867]：
*   **$T(A \to B)$** (析取类型)：分支分裂为两条，一条包含 $F A$，另一条包含 $T B$。这反映了 $A \to B$ 等价于 $\neg A \lor B$。
*   **$F(A \to B)$** (合取类型)：在同一分支下添加 $T A$ 和 $F B$。这反映了 $A \to B$ 为假当且仅当 $A$ 为真且 $B$ 为假。

如果一个分支上同时出现了 $T C$ 和 $F C$（对于任意公式 $C$），或者直接出现了 $T \bot$ 或 $F \top$，那么这个分支就包含了一个直接的矛盾，我们称该分支**闭合 (closed)**。如果树的所有分支都闭合了，那么初始的带符号公式集合就是不可满足的。这意味着，如果我们从 $\{F A\}$ 出发并得到了一个所有分支都闭合的树，我们就证明了 $A$ 不可能为假，因此 $A$ 是一个重言式。

### 深化理论：结构、意义与同一性

对证明系统的研究不止于其基本机制，更在于其深刻的[元理论](@entry_id:638043)属性，这些属性揭示了逻辑、证明与计算之间令人惊奇的联系。

#### [经典逻辑](@entry_id:264911)与[直觉主义逻辑](@entry_id:152074)的句法分野

[经典逻辑](@entry_id:264911)和[直觉主义逻辑](@entry_id:152074)在哲学基础上有很大差异，这种差异在[相继式演算](@entry_id:154229)中得到了精确的句法体现。[经典逻辑](@entry_id:264911)的[相继式演算](@entry_id:154229)（记作 **LK**）允许后件 $\Delta$ 包含多个公式，这在语义上对应于[排中律](@entry_id:635086) $(\varphi \lor \neg \varphi)$ 的普遍有效性。而[直觉主义逻辑](@entry_id:152074)的[相继式演算](@entry_id:154229)（记作 **LJ**）则严格限制后件只能包含**至多一个**公式 [@problem_id:2979845]。

这个单一后件的限制对逻辑规则产生了深远的影响。例如，在 LJ 中：
*   蕴含的右规则必须是 $\frac{\Gamma, A \vdash B}{\Gamma \vdash A \to B}$。我们不能像在 LK 中那样，允许后件中还有其他“备选”的公式 $\Delta$。
*   析取的右规则 $\frac{\Gamma \vdash A}{\Gamma \vdash A \lor B}$ 明确要求我们必须能**构造性地**证明析取项中的某一项。
*   蕴含的左规则也变得更为复杂，需要两个前提：$\frac{\Gamma \vdash A \quad \Delta, B \vdash C}{\Gamma, \Delta, A \to B \vdash C}$。

这种句法上的限制精确地捕捉了[直觉主义逻辑](@entry_id:152074)的构造性本质，即一个证明必须给出构造一个数学对象的具体方法，而不能依赖于非构造性的反证法。

#### 切规则与[子公式性质](@entry_id:156458)

切规则在[相继式演算](@entry_id:154229)中地位特殊。一方面，它非常强大，使得证明可以模块化。但另一方面，它破坏了证明的“分析性”。一个包含切规则的证明可能引入与最终结论毫无关系的任意复杂公式。

**规则的容许性 (Admissibility)** 是一个关键概念：如果一条规则的结论总能通过不使用该规则的其他方式推导出来（只要其前提是可证的），那么我们就说这条规则是**容许的** [@problem_id:2979846]。Gentzen 的惊人成果——**切消定理 (Cut-Elimination Theorem)**（也称 **Hauptsatz**）——表明，切规则在 LK 和 LJ 中都是容许的。

这意味着任何有切的证明都可以被转化为一个**无切的 (cut-free)** 证明。无切证明具有一个极其重要的性质——**[子公式性质](@entry_id:156458) (subformula property)**：在一个无切证明中出现的任何公式，都必须是其最终结论（根相继式）中某个公式的子公式 [@problem_id:2979839]。这使得证明的搜索空间大大减小，并且使证明本身成为分析其结论的工具。

[子公式性质](@entry_id:156458)的一个深刻应用是**[克雷格插值定理](@entry_id:148559) (Craig's Interpolation Theorem)**。该定理指出，如果 $A \to B$ 是一个[重言式](@entry_id:143929)，那么存在一个“插值公式” $I$，使得 $A \to I$ 和 $I \to B$ 都是[重言式](@entry_id:143929)，并且 $I$ 中出现的命题变量都是 $A$ 和 $B$ 中**共同**出现的变量。证明这个定理的一个标准方法，就是对 $A \Rightarrow B$ 的一个无切证明进行归纳。由于[子公式性质](@entry_id:156458)，证明中的所有公式都由 $A$ 和 $B$ 的子公式构成，这保证了在归纳构造插值公式 $I$ 的过程中，可以始终维持变量限制的要求。如果证明中使用了切规则，引入了与 $A, B$ 无关的变量，这个构造过程就会失败 [@problem_id:2979839]。例如，对于 $q \land r \Rightarrow q \lor s$，可以通过这种方法提取出插值公式 $q$。

#### [证明论](@entry_id:151111)语义学与和谐性

传统的[真值](@entry_id:636547)条件语义学从外部赋予[逻辑联结词](@entry_id:146395)意义。而**[证明论](@entry_id:151111)语义学 (Proof-theoretic Semantics)** 采取了相反的路径：它主张联结词的意义完全由其在证明系统中的**使用规则**所定义。在自然演绎的框架下，一个联结词的意义由其**引入规则**给出，因为它规定了断言该联结词的规范性理由。

那么，消去规则扮演什么角色呢？它们必须与引入规则**和谐 (in harmony)**。这意味着消去规则的“威力”不能超过也不能少于引入规则所赋予的意义。这个由 Michael Dummett 和 Dag Prawitz 形式化的和谐原则，包含两个方面 [@problem_id:2979835]：
1.  **局部可靠性 (Local Soundness)**：确保消去规则不是太强。它要求任何“引入-消去”的连续使用（即一个消去规则直接作用于由相应引入规则得到的主前提）都是一个可以被消除的“弯路 (detour)”。这种消除过程被称为**归约 (reduction)** 或 **$\beta$-归约**。例如，通过 $\land$I 得到 $A \land B$ 后立刻用 $\land$E 得到 $A$，这个推导可以直接简化为原来证明 $A$ 的那部分。
2.  **局部完全性 (Local Completeness)**：确保消去规则不是太弱。它要求消去规则足以“分解”一个公式，以提取出所有用于重新引入它的必要信息。这个过程被称为**展开 (expansion)** 或 **$\eta$-展开**。例如，对于任意一个 $A \land B$ 的证明，我们都可以应用 $\land$E 分别得到 $A$ 和 $B$，然后再用 $\land$I 将它们重新组合成 $A \land B$。

和谐原则确保了逻辑规则的良好定义，并排除了像 `tonk` 这样的病态联结词。

#### 证明的同一性

当两个不同的推[导序列](@entry_id:140607)都证明了同一个定理时，我们应该在何种意义上认为它们是“同一个”证明？**证明的同一性 (Identity of Proofs)** 理论试图回答这个问题。

在自然演绎中，一个主流的观点是通过**正规化 (normalization)** 来定义证明等价。如果一个推导 $\mathcal{D}_1$ 可以通过一系列的归约（和展开）步骤转化为另一个推导 $\mathcal{D}_2$，那么它们就被认为是等价的。更严格地说，两个推导 $\mathcal{D}_1$ 和 $\mathcal{D}_2$ 被认为是等价的（记作 $\mathcal{D}_1 \equiv_N \mathcal{D}_2$），当且仅当它们拥有相同的**正规形式 (normal form)**——即不能再被归约的“最简”形式 [@problem_id:2979866]。

这个概念与计算理论中的 **[Curry-Howard 同构](@entry_id:633959) (Curry-Howard Correspondence)** 紧密相关。在该同构下，自然演绎中的证明对应于**类型[lambda演算](@entry_id:148725) (typed lambda calculus)** 中的程序，而证明的正规化过程则对应于程序的求值（$\beta$-归约）。因此，两个证明等价，当且仅当它们对应的程序在 $\beta\eta$-等价理论下是相等的。这个等价关系也与**[范畴论](@entry_id:137315)语义学 (categorical semantics)** 中的态射等价性相对应：两个证明等价，当且仅当它们在相应的自由范畴（如自由双笛卡尔闭范畴）中表示同一个态射 [@problem_id:2979866]。

### 证明复杂性中的应用

证明系统不仅是逻辑学的基础，也是理论计算机科学中**证明复杂性 (proof complexity)** 领域的核心研究对象。该领域试图根据证明一个[重言式](@entry_id:143929)所需证明的最小“规模”来对[证明系统](@entry_id:156272)进行分类。一个关键的比较工具是**多项式模拟 (polynomial simulation)**：如果系统 $\mathcal{P}$ 能将系统 $\mathcal{Q}$ 中的任意一个证明以至多增加多项式大小的代价进行翻译，我们就说 $\mathcal{P}$ 多项式模拟了 $\mathcal{Q}$。如果两个系统可以相互多项式模拟，则称它们是**多项式等价的 (polynomially equivalent)**。

基本的 Frege 系统或无切的[相继式演算](@entry_id:154229)系统在证明某些重言式时，可能需要指数大小的证明。为了克服这一点，人们研究了更强的系统。**扩展 Frege 系统 (Extended Frege, EF)** 通过增加一个**扩展规则 (extension rule)** 来增强 Frege 系统，该规则允许引入形如 $q \leftrightarrow \psi$ 的新定义，其中 $q$ 是一个新变量。类似地，**带缩写的[相继式演算](@entry_id:154229) (Sequent Calculus with Abbreviations, SCA)** 允许全局地定义 $q := \psi$。

这两种机制的本质都是允许**共享子结构 (sharing sub-structures)**，即一个复杂的公式 $\psi$ 可以用一个大小为 1 的原子 $q$ 来表示，并在证明中多次重复使用，从而可能极大地缩短证明。一个基本且重要的结果是，EF 和 SCA 是多项式等价的 [@problem_id:2979870]。模拟过程的核心在于，一个系统的定义机制（EF 中的扩展公理）可以被另一个系统（SCA 中的全局缩写）有效地模拟，反之亦然。同时，它们底层的证明演算（Frege 系统和带切的[相继式演算](@entry_id:154229)）本身也是多项式等价的。这一结果表明，尽管形式不同，这两种允许高效公式共享的证明系统具有相同的计算能力。