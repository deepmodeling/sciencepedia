{"hands_on_practices": [{"introduction": "要理解塔斯基的真理定义，我们必须从最小的构件——项（terms）——开始。本练习聚焦于语义学的组合性（compositional）本质，即复杂表达式的意义由其各部分的意义构建而成。你将验证项求值和原子公式满足的基本规则，它们构成了整个真理递归定义的基础。[@problem_id:2983810]", "problem": "考虑一个一阶语言 $\\mathcal{L}$，它包含常数符号、各种元数的函数符号和谓词符号。根据一阶逻辑（FOL）的 Tarski 语义，$\\mathcal{L}$ 的一个结构 $\\mathcal{M}$ 由一个非空论域 $M$ 和一个解释组成，该解释为每个常数符号 $c$ 赋予一个元素 $c^{\\mathcal{M}} \\in M$，为每个 $n$ 元函数符号 $f$ 赋予一个函数 $f^{\\mathcal{M}}: M^n \\to M$，为每个 $n$ 元谓词符号 $P$ 赋予一个关系 $P^{\\mathcal{M}} \\subseteq M^n$。变量赋值 $s$ 是一个从变量集合到 $M$ 的映射。在赋值 $s$ 下，$\\mathcal{M}$ 中的项求值是通过对项的结构递归来定义的，而满足关系 $\\mathcal{M}, s \\models \\varphi$ 是从原子公式向上复合定义的。\n\n在标准的 Tarski 语义中，下列哪些陈述是正确的？选择所有适用的选项。\n\nA. 在 $\\mathcal{L}$ 的任何结构 $\\mathcal{M}$ 中，每个 $n$ 元函数符号 $f$ 都被解释为一个全函数 $f^{\\mathcal{M}}: M^n \\to M$。\n\nB. 给定一个变量赋值 $s$，项求值函数 $\\mathrm{val}^{\\mathcal{M}}_{s}$ 被复合地定义为：对于变量 $x$，$\\mathrm{val}^{\\mathcal{M}}_{s}(x) = s(x)$；对于常数符号 $c$，$\\mathrm{val}^{\\mathcal{M}}_{s}(c) = c^{\\mathcal{M}}$；对于复合项 $f(t_1,\\dots,t_n)$，$\\mathrm{val}^{\\mathcal{M}}_{s}(f(t_1,\\dots,t_n)) = f^{\\mathcal{M}}(\\mathrm{val}^{\\mathcal{M}}_{s}(t_1),\\dots,\\mathrm{val}^{\\mathcal{M}}_{s}(t_n))$。\n\nC. 对于任意二元函数符号 $g$ 和项 $t_1,t_2$，有 $\\mathrm{val}^{\\mathcal{M}}_{s}(g(t_1,t_2)) = g^{\\mathcal{M}}(\\mathrm{val}^{\\mathcal{M}}_{s}(t_2),\\mathrm{val}^{\\mathcal{M}}_{s}(t_1))$。\n\nD. 在标准的一阶逻辑语义中，如果一个函数符号在 $\\mathcal{M}$ 中没有被明确赋予一个值表，那么项求值可能是未定义的。\n\nE. 对于任意将变量映射到项的代换 $\\sigma$，定义 $s_{\\sigma}(x) = \\mathrm{val}^{\\mathcal{M}}_{s}(\\sigma(x))$; 那么对于所有项 $t$，有 $\\mathrm{val}^{\\mathcal{M}}_{s}(t[\\sigma]) = \\mathrm{val}^{\\mathcal{M}}_{s_{\\sigma}}(t)$。\n\nF. 对于任意 $n$ 元谓词符号 $P$ 和项 $t_1,\\dots,t_n$，$\\mathcal{M}, s \\models P(t_1,\\dots,t_n)$ 当且仅当 $(\\mathrm{val}^{\\mathcal{M}}_{s}(t_1),\\dots,\\mathrm{val}^{\\mathcal{M}}_{s}(t_n)) \\in P^{\\mathcal{M}}$。\n\nG. 对于等词，$\\mathcal{M}, s \\models t = u$ 当且仅当 $t$ 和 $u$ 是语法上相同的项。\n\nH. 对于任意一元函数符号 $f$、二元函数符号 $g$ 以及项 $t_1, t_2$，复合性质成立：$\\mathrm{val}^{\\mathcal{M}}_{s}\\big(f(g(t_1,t_2))\\big) = f^{\\mathcal{M}}\\!\\big(g^{\\mathcal{M}}(\\mathrm{val}^{\\mathcal{M}}_{s}(t_1),\\mathrm{val}^{\\mathcal{M}}_{s}(t_2))\\big)$。\n\nI. 一组基原子公式的可满足性仅取决于所涉及项的语法形式，而与具体的解释 $c^{\\mathcal{M}}$、$f^{\\mathcal{M}}$ 和 $P^{\\mathcal{M}}$无关。", "solution": "问题陈述根据 Tarski 的模型论语义，为一阶语言 $\\mathcal{L}$ 提供了语法和语义的标准定义。这些定义在数学上是合理的，内部一致的，并且对于评估接下来的命题是完备的。因此，该问题是有效的。我们将逐一分析每个陈述。\n\n所提供的定义如下：\n- 语言 $\\mathcal{L}$ 的一个结构 $\\mathcal{M}$ 包括一个非空论域 $M$ 和一个解释函数。\n- 对于一个常数符号 $c$，其解释是论域中的一个元素 $c^{\\mathcal{M}} \\in M$。\n- 对于一个 $n$ 元函数符号 $f$，其解释是一个函数 $f^{\\mathcal{M}}: M^n \\to M$。\n- 对于一个 $n$ 元谓词符号 $P$，其解释是一个关系 $P^{\\mathcal{M}} \\subseteq M^n$。\n- 一个变量赋值 $s$ 将变量映射到 $M$ 的元素。\n- 满足关系 $\\mathcal{M}, s \\models \\varphi$ 是复合定义的。\n\n我们将根据这些基本定义来评估每个选项。\n\n**A. 在 $\\mathcal{L}$ 的任何结构 $\\mathcal{M}$ 中，每个 $n$ 元函数符号 $f$ 都被解释为一个全函数 $f^{\\mathcal{M}}: M^n \\to M$。**\n问题陈述指出，解释为每个 $n$ 元函数符号 $f$ 赋予一个函数 $f^{\\mathcal{M}}: M^n \\to M$。在标准数学术语中，从集合 $A$ 到集合 $B$ 的函数，记作 $g: A \\to B$，根据定义是其定义域 $A$ 上的一个全函数。这意味着对于每个元素 $a \\in A$，都存在一个唯一的元素 $b \\in B$ 使得 $g(a) = b$。可能在其定义域的某些元素上未定义的偏函数，则需要不同的表示法，如 $g: A \\rightharpoonup B$，以及一个修改过的语义框架。由于问题指定了标准的 Tarski 语义，并使用了标准表示法 $f^{\\mathcal{M}}: M^n \\to M$，因此函数符号的解释必须是一个全函数。\n**结论：正确。**\n\n**B. 给定一个变量赋值 $s$，项求值函数 $\\mathrm{val}^{\\mathcal{M}}_{s}$ 被复合地定义为：对于变量 $x$，$\\mathrm{val}^{\\mathcal{M}}_{s}(x) = s(x)$；对于常数符号 $c$，$\\mathrm{val}^{\\mathcal{M}}_{s}(c) = c^{\\mathcal{M}}$；对于复合项 $f(t_1,\\dots,t_n)$，$\\mathrm{val}^{\\mathcal{M}}_{s}(f(t_1,\\dots,t_n)) = f^{\\mathcal{M}}(\\mathrm{val}^{\\mathcal{M}}_{s}(t_1),\\dots,\\mathrm{val}^{\\mathcal{M}}_{s}(t_n))$。**\n该陈述给出了在一个结构 $\\mathcal{M}$ 中、在变量赋值 $s$ 下一个项的值的标准结构递归定义。\n- **基本情况（变量）：** 变量 $x$ 的值由赋值直接给出，$\\mathrm{val}^{\\mathcal{M}}_{s}(x) = s(x)$。\n- **基本情况（常数）：** 常数符号 $c$ 的值是它在结构中的解释，$\\mathrm{val}^{\\mathcal{M}}_{s}(c) = c^{\\mathcal{M}}$。（注意：一个常数可以被看作是一个 0 元函数）。\n- **递归步骤：** 复合项 $f(t_1,\\dots,t_n)$ 的值是通过首先递归地求出子项 $t_1, \\dots, t_n$ 在论域 $M$ 中的值，然后将函数符号的解释 $f^{\\mathcal{M}}$ 应用于这个值的元组。\n该陈述准确地描述了这整个定义。\n**结论：正确。**\n\n**C. 对于任意二元函数符号 $g$ 和项 $t_1,t_2$，有 $\\mathrm{val}^{\\mathcal{M}}_{s}(g(t_1,t_2)) = g^{\\mathcal{M}}(\\mathrm{val}^{\\mathcal{M}}_{s}(t_2),\\mathrm{val}^{\\mathcal{M}}_{s}(t_1))$。**\n根据 B 中的正确定义，我们有 $\\mathrm{val}^{\\mathcal{M}}_{s}(g(t_1,t_2)) = g^{\\mathcal{M}}(\\mathrm{val}^{\\mathcal{M}}_{s}(t_1),\\mathrm{val}^{\\mathcal{M}}_{s}(t_2))$。选项 C 中的陈述在应用 $g^{\\mathcal{M}}$ 时交换了参数，断言 $g^{\\mathcal{M}}(v_1, v_2) = g^{\\mathcal{M}}(v_2, v_1)$，其中 $v_1 = \\mathrm{val}^{\\mathcal{M}}_{s}(t_1)$ 且 $v_2 = \\mathrm{val}^{\\mathcal{M}}_{s}(t_2)$。这是交换律性质。然而，在一阶逻辑中，并没有普遍要求函数符号的解释必须是可交换的。例如，在自然数结构 $\\mathbb{N}$ 中，表示减法的函数符号将被解释为不可交换的减法运算。因此，该陈述通常是错误的。\n**结论：不正确。**\n\n**D. 在标准的一阶逻辑语义中，如果一个函数符号在 $\\mathcal{M}$ 中没有被明确赋予一个值表，那么项求值可能是未定义的。**\n该陈述不正确，原因有二。首先，语言 $\\mathcal{L}$ 的一个结构 $\\mathcal{M}$ 的定义要求 $\\mathcal{L}$ 中的*每个*函数符号都被赋予一个解释 $f^{\\mathcal{M}}$。在一个给定的语言结构中，不存在没有被赋予解释的函数符号。其次，如 A 中所述，解释 $f^{\\mathcal{M}}$ 必须是一个全函数。这保证了对于论域中的任何参数元组，该函数都会产生一个值。由于项求值是递归定义的，并且所有基本情况和递归步骤都会产生一个确定的值，所以任何项的求值总是被定义的。“值表”的概念也具有误导性；对于无限论域，像 $\\mathbb{R}$ 上的加法这样的函数不能用有限的表格来表示，但它们是定义良好的函数。\n**结论：不正确。**\n\n**E. 对于任意将变量映射到项的代换 $\\sigma$，定义 $s_{\\sigma}(x) = \\mathrm{val}^{\\mathcal{M}}_{s}(\\sigma(x))$; 那么对于所有项 $t$，有 $\\mathrm{val}^{\\mathcal{M}}_{s}(t[\\sigma]) = \\mathrm{val}^{\\mathcal{M}}_{s_{\\sigma}}(t)$。**\n这是模型论中一个标准且至关重要的结果，通常称为（项的）代换引理。它将句法操作（代换，$t[\\sigma]$，即根据 $\\sigma$ 替换 $t$ 中的变量）与语义操作（求值）联系起来。证明过程是对项 $t$ 进行结构归纳。\n- **基本情况（$t=x$ 是一个变量）：** $\\mathrm{val}^{\\mathcal{M}}_{s}(x[\\sigma]) = \\mathrm{val}^{\\mathcal{M}}_{s}(\\sigma(x))$。根据定义，$\\mathrm{val}^{\\mathcal{M}}_{s_{\\sigma}}(x) = s_{\\sigma}(x) = \\mathrm{val}^{\\mathcal{M}}_{s}(\\sigma(x))$。等式成立。\n- **基本情况（$t=c$ 是一个常数）：** $\\mathrm{val}^{\\mathcal{M}}_{s}(c[\\sigma]) = \\mathrm{val}^{\\mathcal{M}}_{s}(c) = c^{\\mathcal{M}}$。同时，$\\mathrm{val}^{\\mathcal{M}}_{s_{\\sigma}}(c) = c^{\\mathcal{M}}$。等式成立。\n- **归纳步骤（$t=f(t_1, \\dots, t_n)$）：** 假设该性质对 $t_1, \\dots, t_n$ 成立。$\\mathrm{val}^{\\mathcal{M}}_{s}(t[\\sigma]) = \\mathrm{val}^{\\mathcal{M}}_{s}(f(t_1[\\sigma], \\dots, t_n[\\sigma])) = f^{\\mathcal{M}}(\\mathrm{val}^{\\mathcal{M}}_{s}(t_1[\\sigma]), \\dots, \\mathrm{val}^{\\mathcal{M}}_{s}(t_n[\\sigma]))$。根据归纳假设，这等于 $f^{\\mathcal{M}}(\\mathrm{val}^{\\mathcal{M}}_{s_{\\sigma}}(t_1), \\dots, \\mathrm{val}^{\\mathcal{M}}_{s_{\\sigma}}(t_n))$。根据项求值的定义，这等于 $\\mathrm{val}^{\\mathcal{M}}_{s_{\\sigma}}(f(t_1, \\dots, t_n)) = \\mathrm{val}^{\\mathcal{M}}_{s_{\\sigma}}(t)$。等式成立。\n因此，该陈述是正确的。\n**结论：正确。**\n\n**F. 对于任意 $n$ 元谓词符号 $P$ 和项 $t_1,\\dots,t_n$，$\\mathcal{M}, s \\models P(t_1,\\dots,t_n)$ 当且仅当 $(\\mathrm{val}^{\\mathcal{M}}_{s}(t_1),\\dots,\\mathrm{val}^{\\mathcal{M}}_{s}(t_n)) \\in P^{\\mathcal{M}}$。**\n这个陈述是在 Tarski 语义中对于原子公式（非等词）的满足性的精确定义。一个形如 $P(t_1, \\dots, t_n)$ 的原子语句在模型 $\\mathcal{M}$ 中（在赋值 $s$ 下）被认为是真的，当且仅当由每个项 $t_i$ 求值形成的元组属于谓词符号 $P$ 的解释关系 $P^{\\mathcal{M}}$。这是原子公式的句法与论域上关系的集合论语义之间的根本桥梁。\n**结论：正确。**\n\n**G. 对于等词，$\\mathcal{M}, s \\models t = u$ 当且仅当 $t$ 和 $u$ 是语法上相同的项。**\n该陈述从根本上误解了等词的语义。等词（$=$）是一个逻辑符号，其含义在所有结构中都是固定的。等式公式的满足条件是语义上的，而非句法上的：$\\mathcal{M}, s \\models t = u$ 当且仅当 $\\mathrm{val}^{\\mathcal{M}}_{s}(t) = \\mathrm{val}^{\\mathcal{M}}_{s}(u)$。这意味着两个项必须求值为论域 $M$ 的*同一个元素*。语法上不同的项很容易求值为同一个元素。例如，在算术结构中，项 $2+2$ 和 $4$ 在语法上是不同的，但它们求值为同一个元素，所以公式 $2+2 = 4$ 是真的。该选项中的陈述描述的是句法同一性，而不是语义相等。\n**结论：不正确。**\n\n**H. 对于任意一元函数符号 $f$、二元函数符号 $g$ 以及项 $t_1, t_2$，复合性质成立：$\\mathrm{val}^{\\mathcal{M}}_{s}\\big(f(g(t_1,t_2))\\big) = f^{\\mathcal{M}}\\!\\big(g^{\\mathcal{M}}(\\mathrm{val}^{\\mathcal{M}}_{s}(t_1),\\mathrm{val}^{\\mathcal{M}}_{s}(t_2))\\big)$。**\n这个性质是 B 中所述的项求值的复合定义的一个直接推论。让我们来追踪求值过程：\n1. 从项 $f(g(t_1,t_2))$ 开始。为了求值，我们应用最外层函数符号 $f$ 的规则：\n   $\\mathrm{val}^{\\mathcal{M}}_{s}\\big(f(g(t_1,t_2))\\big) = f^{\\mathcal{M}}\\big(\\mathrm{val}^{\\mathcal{M}}_{s}(g(t_1,t_2))\\big)$。\n2. 现在，我们求值参数项 $g(t_1,t_2)$：\n   $\\mathrm{val}^{\\mathcal{M}}_{s}(g(t_1,t_2)) = g^{\\mathcal{M}}\\big(\\mathrm{val}^{\\mathcal{M}}_{s}(t_1), \\mathrm{val}^{\\mathcal{M}}_{s}(t_2)\\big)$。\n3. 将第 2 步的结果代入第 1 步，我们得到：\n   $\\mathrm{val}^{\\mathcal{M}}_{s}\\big(f(g(t_1,t_2))\\big) = f^{\\mathcal{M}}\\!\\big(g^{\\mathcal{M}}(\\mathrm{val}^{\\mathcal{M}}_{s}(t_1),\\mathrm{val}^{\\mathcal{M}}_{s}(t_2))\\big)$。\n这与陈述完全匹配。这是项求值递归性质的一个简单例证。\n**结论：正确。**\n\n**I. 一组基原子公式的可满足性仅取决于所涉及项的语法形式，而与具体的解释 $c^{\\mathcal{M}}$、$f^{\\mathcal{M}}$ 和 $P^{\\mathcal{M}}$无关。**\n这个陈述与 Tarski 语义完全相反。可满足性是一个语义概念：一个公式集合是可满足的，如果存在至少一个结构 $\\mathcal{M}$ 使得该集合中的所有公式都为真。一个公式，例如基原子公式 $P(c)$，在给定的结构 $\\mathcal{M}$ 中是否为真，完全取决于该结构中的解释。具体来说，你必须检查是否 $c^{\\mathcal{M}} \\in P^{\\mathcal{M}}$。改变 $c$ 或 $P$ 的解释可以改变公式的真值。例如，公式 `IsEven(3)` 在标准算术模型中是假的，但在另一个结构中可以为真，例如常数符号 `3` 被解释为数字 4，或者谓词 `IsEven` 被解释为奇数集合。因此，可满足性从根本上依赖于解释。\n**结论：不正确。**\n\n综上所述，正确的陈述是 A, B, E, F, 和 H。", "answer": "$$\\boxed{ABEFH}$$", "id": "2983810"}, {"introduction": "在掌握了项之后，下一个挑战是处理变量，尤其是在量词的语境下。变量赋值（variable assignment）是 Tarski 为此引入的关键机制。本练习将深入探讨变量赋值及其更新（如 $s[x \\mapsto a]$）的各种形式化属性，这对于精确定义“对于所有 $x$……”这类公式的意义至关重要。[@problem_id:2983816]", "problem": "考虑一个一阶逻辑（FOL）语言 $L$，一个具有论域 $M$ 和解释函数的 $L$-结构 $\\mathcal{M}$，以及一个变量赋值 $s\\colon \\mathrm{Var}\\to M$。Tarski 满足关系 $\\mathcal{M}\\models \\varphi[s]$ 由结构 $\\mathcal{M}$ 和赋值 $s$ 决定，项的求值写作 $\\llbracket t\\rrbracket^{\\mathcal{M}}_{s}$。选择所有正确描述赋值 $s$ 在 Tarski 语义中的作用，并正确形式化更新符号 $s[x\\mapsto a]$ 及其代数性质的陈述。\n\nA. 对于任意 $s\\colon \\mathrm{Var}\\to M$ 和 $a\\in M$，更新 $s[x\\mapsto a]$ 是一个赋值 $t\\colon \\mathrm{Var}\\to M$，定义为 $t(x)=a$ 并且对于所有 $y\\neq x$ 有 $t(y)=s(y)$。\n\nB. 对于任意 $x,y\\in \\mathrm{Var}$ 且 $x\\neq y$ 以及任意 $a,b\\in M$，更新是可交换的：$s[x\\mapsto a][y\\mapsto b]=s[y\\mapsto b][x\\mapsto a]$。\n\nC. 对于任意公式 $\\varphi$，修改 $s$ 在一个于 $\\varphi$ 中被约束的变量 $x$ 上的值可以改变 $\\mathcal{M}\\models \\varphi[s]$ 的真值。\n\nD. 如果 $s,s'\\colon \\mathrm{Var}\\to M$ 在公式 $\\varphi$ 的自由变量集合上一致，那么 $\\mathcal{M}\\models \\varphi[s]$ 当且仅当 $\\mathcal{M}\\models \\varphi[s']$。\n\nE. 对于任意项 $t$，如果 $x$ 不出现在 $t$ 的变量中，那么对于所有 $a\\in M$ 都有 $\\llbracket t\\rrbracket^{\\mathcal{M}}_{s}=\\llbracket t\\rrbracket^{\\mathcal{M}}_{s[x\\mapsto a]}$。\n\nF. 对于任意公式 $\\varphi$ 和任意 $a\\in M$，有 $\\mathcal{M}\\models \\forall x\\,\\varphi[s]$ 当且仅当存在 $a\\in M$ 使得 $\\mathcal{M}\\models \\varphi[s[x\\mapsto a]]$。", "solution": "问题陈述是一阶逻辑中的一个标准练习，具体涉及 Tarski 的真理（或满足）定义。所呈现的概念——一阶语言 $L$、$L$-结构 $\\mathcal{M}$、论域 $M$、变量赋值 $s$、满足关系 $\\mathcal{M}\\models \\varphi[s]$、项求值 $\\llbracket t\\rrbracket^{\\mathcal{M}}_{s}$ 和赋值更新 $s[x\\mapsto a]$——都是标准且定义明确的。这个问题是对这些概念的形式属性的一个适定探究。\n\n因此，问题陈述是有效的。我们将逐一分析每个选项。\n\nTarski 语义的核心依赖于满足的递归定义。变量赋值 $s\\colon \\mathrm{Var}\\to M$ 将所有变量的集合 $\\mathrm{Var}$ 中的每个变量映射到论域 $M$ 的一个元素。公式 $\\varphi$ 的真值是相对于一个结构 $\\mathcal{M}$ 和这样一个赋值 $s$ 来评估的。\n\n让我们评估每个陈述。\n\n**A. 对于任意 $s\\colon \\mathrm{Var}\\to M$ 和 $a\\in M$，更新 $s[x\\mapsto a]$ 是一个赋值 $t\\colon \\mathrm{Var}\\to M$，定义为 $t(x)=a$ 并且对于所有 $y\\neq x$ 有 $t(y)=s(y)$。**\n\n这个陈述提供了符号 $s[x\\mapsto a]$ 的形式化定义。它代表一个新的赋值，我们称之为 $s'$，它是对原始赋值 $s$ 的一个轻微修改。新的赋值 $s'$ 将变量 $x$ 映射到特定的论域元素 $a$，而对于其他所有变量 $y$（其中 $y$ 是不同于 $x$ 的变量符号），它与原始赋值一致，即 $s'(y) = s(y)$。这是在量化公式语义中使用的、标准的、被普遍接受的赋值修改定义。\n\n结论：**正确**。\n\n**B. 对于任意 $x,y\\in \\mathrm{Var}$ 且 $x\\neq y$ 以及任意 $a,b\\in M$，更新是可交换的：$s[x\\mapsto a][y\\mapsto b]=s[y\\mapsto b][x\\mapsto a]$。**\n\n为了验证这一点，我们必须检查两个结果赋值是否是同一个函数。两个函数相等当且仅当它们有相同的定义域和陪域，并且将定义域中的每个元素映射到陪域中相同的元素。令 $s_1 = s[x\\mapsto a][y\\mapsto b]$ 和 $s_2 = s[y\\mapsto b][x\\mapsto a]$。我们需要证明对于任意变量 $z \\in \\mathrm{Var}$，$s_1(z) = s_2(z)$。\n\n我们来考虑 $z$ 的几种可能情况：\n1.  情况 $z = x$：\n    - $s_1(x) = (s[x\\mapsto a][y\\mapsto b])(x)$。“外部”更新是关于 $y$ 的，由于 $x \\neq y$，在 $x$ 处的值由“内部”赋值 $s[x\\mapsto a]$ 决定。因此，$s_1(x) = (s[x\\mapsto a])(x) = a$。\n    - $s_2(x) = (s[y\\mapsto b][x\\mapsto a])(x)$。外部更新是关于 $x$ 的，根据定义，它将 $x$ 映射到 $a$。因此，$s_2(x) = a$。\n    所以，$s_1(x) = s_2(x)$。\n\n2.  情况 $z = y$：\n    - $s_1(y) = (s[x\\mapsto a][y\\mapsto b])(y)$。外部更新是关于 $y$ 的，根据定义，它将 $y$ 映射到 $b$。因此，$s_1(y) = b$。\n    - $s_2(y) = (s[y\\mapsto b][x\\mapsto a])(y)$。外部更新是关于 $x$ 的，由于 $y \\neq x$，在 $y$ 处的值由内部赋值 $s[y\\mapsto b]$ 决定。因此，$s_2(y) = (s[y\\mapsto b])(y) = b$。\n    所以，$s_1(y) = s_2(y)$。\n\n3.  情况 $z \\neq x$ 且 $z \\neq y$：\n    - $s_1(z) = (s[x\\mapsto a][y\\mapsto b])(z)$。外部更新不影响 $z$，所以值是 $(s[x\\mapsto a])(z)$。内部更新也不影响 $z$，所以值是 $s(z)$。\n    - $s_2(z) = (s[y\\mapsto b][x\\mapsto a])(z)$。外部更新不影响 $z$，所以值是 $(s[y\\mapsto b])(z)$。内部更新也不影响 $z$，所以值是 $s(z)$。\n    所以，$s_1(z) = s_2(z)$。\n\n由于 $s_1$ 和 $s_2$ 在所有变量上都一致，它们是同一个赋值。条件 $x \\neq y$ 至关重要，因为 $s[x\\mapsto a][x\\mapsto b]$ 会将 $x$ 映射到 $b$，而 $s[x\\mapsto b][x\\mapsto a]$ 会将 $x$ 映射到 $a$。\n\n结论：**正确**。\n\n**C. 对于任意公式 $\\varphi$，修改 $s$ 在一个于 $\\varphi$ 中被约束的变量 $x$ 上的值可以改变 $\\mathcal{M}\\models \\varphi[s]$ 的真值。**\n\n一个公式的真值仅取决于赋给其*自由*变量的值。约束变量是量化的占位符。例如，考虑公式 $\\varphi = \\forall x P(x)$。其满足条件是 $\\mathcal{M} \\models \\forall x P(x)[s]$ 当且仅当对于所有 $a \\in M$，我们有 $\\mathcal{M} \\models P(x)[s[x\\mapsto a]]$。原始值 $s(x)$ 在此评估中不起任何作用；评估依赖于对来自论域的所有可能的 $x$ 值来测试子公式 $P(x)$。因此，将 $s(x)$ 更改为某个其他值 $s'(x)$ 对 $\\mathcal{M} \\models \\forall x P(x)[s]$ 的真值没有影响。这个原则可以推广到所有量化公式和任何约束变量。该陈述声称的恰恰相反。\n\n结论：**错误**。\n\n**D. 如果 $s,s'\\colon \\mathrm{Var}\\to M$ 在公式 $\\varphi$ 的自由变量集合上一致，那么 $\\mathcal{M}\\models \\varphi[s]$ 当且仅当 $\\mathcal{M}\\models \\varphi[s']$。**\n\n这是模型论中的一个基本结果，通常称为**符合引理（Coincidence Lemma）**或**相关引理（Relevance Lemma）**。它形式化了这样一种直觉：一个公式的满足性只取决于赋值如何处理那些在该公式中实际自由出现的变量。证明是对公式 $\\varphi$ 的复杂度进行直接的结构归纳。原子公式的基本情况是明确的，因为它们的真值只取决于其项的求值，而项的求值又只取决于其中的变量（所有这些变量都是自由的）。逻辑联结词和量词的归纳步骤保持了这个性质。我们在选项 C 的分析中简要描述了全称量词的证明。这个陈述是 Tarski 语义的一个正确且核心的定理。\n\n结论：**正确**。\n\n**E. 对于任意项 $t$，如果 $x$ 不出现在 $t$ 的变量中，那么对于所有 $a\\in M$ 都有 $\\llbracket t\\rrbracket^{\\mathcal{M}}_{s}=\\llbracket t\\rrbracket^{\\mathcal{M}}_{s[x\\mapsto a]}$。**\n\n这是符合引理（选项 D）在项上的类似物。项 $\\llbracket t \\rrbracket^{\\mathcal{M}}_{s}$ 的值由常数和函数符号的解释，以及由 $s$ 赋给出现在 $t$ 中的变量的值决定。如果一个变量 $x$ 不出现在 $t$ 中，那么通过更新 $s[x\\mapsto a]$ 来改变 $s(x)$ 的值将不会影响 $t$ 的求值。形式化的证明通过对项 $t$ 的结构进行归纳来进行。\n- 基本情况（$t$ 是常数 $c$）：$\\llbracket c\\rrbracket^{\\mathcal{M}}_{s} = c^{\\mathcal{M}} = \\llbracket c\\rrbracket^{\\mathcal{M}}_{s[x\\mapsto a]}$。\n- 基本情况（$t$ 是变量 $y$）：由于 $x$ 不出现在 $t$ 中，所以 $y \\neq x$。那么 $\\llbracket y\\rrbracket^{\\mathcal{M}}_{s} = s(y)$ 并且 $\\llbracket y\\rrbracket^{\\mathcal{M}}_{s[x\\mapsto a]} = (s[x\\mapsto a])(y) = s(y)$。它们相等。\n- 归纳步骤（$t$ 是 $f(t_1, \\ldots, t_k)$）：由于 $x$ 不出现在 $t$ 中，它也不会出现在任何子项 $t_i$ 中。根据归纳假设，对于所有的 $i$，都有 $\\llbracket t_i\\rrbracket^{\\mathcal{M}}_{s} = \\llbracket t_i\\rrbracket^{\\mathcal{M}}_{s[x\\mapsto a]}$。那么 $\\llbracket t\\rrbracket^{\\mathcal{M}}_{s} = f^{\\mathcal{M}}(\\llbracket t_1\\rrbracket^{\\mathcal{M}}_{s}, \\ldots, \\llbracket t_k\\rrbracket^{\\mathcal{M}}_{s}) = f^{\\mathcal{M}}(\\llbracket t_1\\rrbracket^{\\mathcal{M}}_{s[x\\mapsto a]}, \\ldots, \\llbracket t_k\\rrbracket^{\\mathcal{M}}_{s[x\\mapsto a]}) = \\llbracket t\\rrbracket^{\\mathcal{M}}_{s[x\\mapsto a]}$。\n\n该陈述是正确的。\n\n结论：**正确**。\n\n**F. 对于任意公式 $\\varphi$ 和任意 $a\\in M$，有 $\\mathcal{M}\\models \\forall x\\,\\varphi[s]$ 当且仅当存在 $a\\in M$ 使得 $\\mathcal{M}\\models \\varphi[s[x\\mapsto a]]$。**\n\n这个陈述从根本上歪曲了全称量词的语义。全称量化公式的 Tarski 满足定义是：\n$\\mathcal{M}\\models \\forall x\\,\\varphi[s]$ 当且仅当对于**所有**元素 $b\\in M$，$\\mathcal{M}\\models \\varphi[s[x\\mapsto b]]$ 成立。\n\n所给的陈述是：\n$\\mathcal{M}\\models \\forall x\\,\\varphi[s]$ 当且仅当**存在**一个元素 $a\\in M$ 使得 $\\mathcal{M}\\models \\varphi[s[x\\mapsto a]]$。\n\n陈述中等价关系的右侧是*存在量词*的定义：$\\mathcal{M}\\models \\exists x\\,\\varphi[s]$。该陈述错误地将“对于所有”的含义等同于“存在”。这仅在论域 $M$ 只包含一个元素的平凡且无趣的情况下才等价（假设 $M$ 非空）。在一般情况下，这是错误的。例如，在整数中，“对于所有 $x$，$x>0$”是假的，但“存在 $x$ 使得 $x>0$”是真的。命题开头多余的“和任意 $a \\in M$”是不合语法的，增加了混淆，但无法挽救其核心逻辑错误。\n\n结论：**错误**。\n\n正确陈述的总结：A、B、D、E。", "answer": "$$\\boxed{ABDE}$$", "id": "2983816"}, {"introduction": "现在我们可以将所有部件组装起来。Tarski 的“T约定”（Convention T）为任何恰当的真理定义提供了一个标准，要求该定义能推导出连接句子真值与其所描述事态的双条件句。本练习要求你将完整的塔斯基方法应用于算术语言中的一个具体句子，并仔细区分对象语言和元语言，以得出一个正确的“T语句”（T-sentence）。[@problem_id:2983809]", "problem": "固定一个一阶语言 $L$，它包含等号 $=$、一个常数符号 $0$ 和一个二元函数符号 $+$。令 $\\mathcal{N}$ 为标准 $L$-结构，其论域为 $\\mathbb{N}$，并将 $0$ 解释为 $0 \\in \\mathbb{N}$，将 $+$ 解释为 $\\mathbb{N}$ 上的普通加法。考虑 $L$-语句 $\\forall x\\, (x+0=x)$。你的任务是为这个语句实例化约定 T（Tarski 的真理模式），方法是选择正确的元语言双条件句，该双条件句仔细区分了使用与提及，并在元语言中呈现了该对象语言语句关于结构 $\\mathcal{N}$ 所陈述的内容。\n\n对于给定的语句和给定的结构，以下哪项是约定 T 的正确实例？\n\nA. \"$\\forall x\\,(x+0=x)$ 在 $\\mathcal{N}$ 中为真，当且仅当 $\\forall x\\,(x+0=x)$。\"\n\nB. \"‘$\\forall x\\,(x+0=x)$’ 在 $\\mathcal{N}$ 中为真，当且仅当对于每个 $n \\in \\mathbb{N}$，都有 $+^{\\mathcal{N}}(n,0^{\\mathcal{N}})=n$。\"\n\nC. \"‘$\\forall x\\,(x+0=x)$’ 在 $L$ 中为真，当且仅当对于所有 $n \\in \\mathbb{N}$，都有 $n+0=n$。\"\n\nD. \"‘$\\forall x\\,(x+0=x)$’ 为真，当且仅当对于所有赋值 $s$，都有 $\\mathcal{N} \\models x+0=x$。\"\n\nE. \"‘$\\forall x\\,(x+0=x)$’ 在 $\\mathcal{N}$ 中为真，当且仅当 $\\mathcal{N} \\models \\forall x\\,(x+0=x)$。\"", "solution": "问题陈述是数理逻辑中的一个有效练习。它问题明确，在模型论中有科学依据，并且所有术语和条件都以足够的精度指定，以确定唯一的正确答案。\n\n任务是为一个给定结构中的给定语句正确地实例化 Alfred Tarski 的约定 T。约定 T，也称为实质充分性条件，要求任何对语言 $L$ 的令人满意的真理定义都必须允许为 $L$ 中的每个语句 $\\phi$ 推导出一个双条件陈述。这个双条件句的形式是：\n$$ \\text{\"}\\phi\\text{\" is true if and only if } P $$\n其中左侧的 “$\\phi$” 是语句的*名称*（一个被提及的表达式），而右侧的 $P$ 是在元语言中被*使用*的语句本身，或者更确切地说，是 $\\phi$ 在元语言中的一个*翻译*，该翻译描述了 $\\phi$ 所断言的事态。当真理是相对于一个结构（模型论真理）定义的，该模式变为：\n$$ \\text{\"}\\phi\\text{\" is true in } \\mathcal{M} \\text{ if and only if } P_{\\mathcal{M}} $$\n其中 $\\mathcal{M}$ 是结构，而 $P_{\\mathcal{M}}$ 是描述 $\\phi$ 就 $\\mathcal{M}$ 的论域和解释所断言的条件的元语言陈述。\n\n让我们将此应用于给定的问题。\n对象语言是 $L$，包含符号 $=$、$0$ 和 $+$。\n语句是 $\\phi \\equiv \\forall x\\,(x+0=x)$。\n结构是 $\\mathcal{N}$，论域为 $\\mathbb{N}$，其中常数符号 $0$ 被解释为数 $0 \\in \\mathbb{N}$（记为 $0^{\\mathcal{N}}$），函数符号 $+$ 被解释为 $\\mathbb{N}$ 上的标准加法（记为 $+^{\\mathcal{N}}$）。\n\nT-双条件句的左侧必须是一个陈述，它断定语句 $\\phi$ 在结构 $\\mathcal{N}$ 中的真值。这必须正确使用引号来*提及*该语句。正确的形式是：\n`‘$\\forall x\\,(x+0=x)$’ 在 $\\mathcal{N}$ 中为真...`\n\n右侧必须是 $\\phi$ 关于结构 $\\mathcal{N}$ 所断言的内容的元语言翻译。我们通过递归地应用 Tarski 的真理定义来推导它：\n1. 该语句的形式为 $\\forall x \\, \\psi(x)$，其中 $\\psi(x)$ 是公式 $x+0=x$。全称量词的真理定义规定，$\\mathcal{N} \\models \\forall x \\, \\psi(x)$ 当且仅当对于 $\\mathcal{N}$ 论域中的每个元素 $d$，当 $x$ 被赋值为 $d$ 时，公式 $\\psi(x)$ 都得到满足。$\\mathcal{N}$ 的论域是 $\\mathbb{N}$。所以，这可以翻译为：“对于每个 $n \\in \\mathbb{N}$，对应于 $x+0=x$ 的条件对 $n$ 成立。”\n\n2. 现在我们为元素 $n \\in \\mathbb{N}$ 翻译原子公式 $x+0=x$。该公式是两个项之间的等式，$t_1 \\equiv x+0$ 和 $t_2 \\equiv x$。如果这两个项的解释相等，则该公式得到满足。\n    - 项 $t_1 \\equiv x+0$ 的解释涉及将函数符号 $+$ 的解释（即函数 $+^{\\mathcal{N}}$）应用于变量 $x$ 和常数符号 $0$ 的解释。对于元素 $n \\in \\mathbb{N}$，变量 $x$ 的值为 $n$，常数符号 $0$ 的值为其解释 $0^{\\mathcal{N}}$。因此，项 $x+0$ 的值为 $+^{\\mathcal{N}}(n, 0^{\\mathcal{N}})$。\n    - 项 $t_2 \\equiv x$ 的解释就是赋给变量 $x$ 的元素 $n$。\n    - 因此，条件 $x+0=x$ 对 $n$ 成立翻译为元语言等式：$+^{\\mathcal{N}}(n, 0^{\\mathcal{N}}) = n$。\n\n3. 结合这些步骤，完整的元语言翻译 $P_{\\mathcal{N}}$ 是：“对于每个 $n \\in \\mathbb{N}$，都有 $+^{\\mathcal{N}}(n, 0^{\\mathcal{N}}) = n$。”\n\n将两边放在一起，正确的 T-双条件句是：\n`‘$\\forall x\\,(x+0=x)$’ 在 $\\mathcal{N}$ 中为真，当且仅当对于每个 $n \\in \\mathbb{N}$，都有 $+^{\\mathcal{N}}(n,0^{\\mathcal{N}})=n$。`\n\n现在我们来评估给出的选项。\n\n**A. \"$\\forall x\\,(x+0=x)$ 在 $\\mathcal{N}$ 中为真，当且仅当 $\\forall x\\,(x+0=x)$。\"**\n这个选项存在致命的使用-提及混淆。左侧的短语 `$\\forall x\\,(x+0=x)$` 被用作主语，但没有放在引号中，未能正确地为该语句命名。更根本的是，右侧只是重复了对象语言的语句。约定 T 要求的是翻译到描述模型论域条件的元语言中，而不是重复对象语言的语法。这个双条件句没有提供信息。\n**结论：不正确。**\n\n**B. \"‘$\\forall x\\,(x+0=x)$’ 在 $\\mathcal{N}$ 中为真，当且仅当对于每个 $n \\in \\mathbb{N}$，都有 $+^{\\mathcal{N}}(n,0^{\\mathcal{N}})=n$。\"**\n这个选项与我们的推导完全匹配。\n- 左侧正确地提及了语句 `‘$\\forall x\\,(x+0=x)$’`，并断定了它在结构 $\\mathcal{N}$ 中的真值。\n- 右侧提供了对语句含义的精确元语言翻译，描述了论域 $\\mathbb{N}$ 中元素的属性以及符号 $+^{\\mathcal{N}}$ 和 $0^{\\mathcal{N}}$ 的解释。它正确地解析了全称量词和项的解释。\n**结论：正确。**\n\n**C. \"‘$\\forall x\\,(x+0=x)$’ 在 $L$ 中为真，当且仅当对于所有 $n \\in \\mathbb{N}$，都有 $n+0=n$。\"**\n这个选项的左侧包含一个关键错误。真值不是为语言 $L$ 定义的，而是为该语言的某个*结构*（或解释）$\\mathcal{N}$ 中的语句定义的。一个语句在一个结构中可以为真，在另一个结构中可以为假。短语“在 $L$ 中为真”在句法上是一个错误，在模型论中概念上是无意义的。虽然右侧是一个正确但稍欠形式化的元语言翻译，但左侧的错误使整个陈述无效。\n**结论：不正确。**\n\n**D. \"‘$\\forall x\\,(x+0=x)$’ 为真，当且仅当对于所有赋值 $s$，都有 $\\mathcal{N} \\models x+0=x$。\"**\n这个选项因多个原因而存在缺陷。首先，左侧不完整，省略了“在 $\\mathcal{N}$ 中”。其次，更重要的是，右侧没有提供所需的、关于论域对象的陈述的翻译。相反，它通过使用满足关系 `$\\models$` 来用语义术语表达条件。这是循环的。陈述 `$\\mathcal{N} \\models \\forall x \\psi(x)$` 本身就是根据对所有赋值（或者更准确地说，对所有替代 $x$ 的论域元素）的满足来*定义*的。约定 T 要求从右侧消除像 `$\\models$` 这样的语义谓词，并用论域中的实际条件取而代之。\n**结论：不正确。**\n\n**E. \"‘$\\forall x\\,(x+0=x)$’ 在 $\\mathcal{N}$ 中为真，当且仅当 $\\mathcal{N} \\models \\forall x\\,(x+0=x)$。\"**\n这个陈述是一个重言式。英语短语“`‘\\phi’` 在 $\\mathcal{N}$ 中为真”只是形式符号 `$\\mathcal{N} \\models \\phi$` 的自然语言读法。因此，这个选项断言一个陈述为真当且仅当它为真。这没有提供将对象语言语句翻译成关于论域的非语义断言，因此不是约定 T 的正确实例化。\n**结论：不正确。**", "answer": "$$\\boxed{B}$$", "id": "2983809"}]}