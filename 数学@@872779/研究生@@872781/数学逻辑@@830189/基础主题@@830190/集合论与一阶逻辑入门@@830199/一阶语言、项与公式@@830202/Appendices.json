{"hands_on_practices": [{"introduction": "在一阶逻辑中，精确的句法是所有形式推理的基石。每一个合法的表达式，无论是项（term）还是公式（formula），都必须严格遵循其递归的构造规则。本练习将检验你对项的构造规则的理解，特别是函数符号的“元数”（arity）在其中扮演的关键角色。通过辨别一个仅因元数不匹配而导致语法错误的字符串[@problem_id:2972885]，你将学会像编译器一样精准地解析语法结构，从而打下坚实的逻辑基础。", "problem": "考虑一阶逻辑中标识为 $L$ 的项的抽象语法构成规则。一个标识 $L$ 由一个有限的函数符号集合（每个符号都有一个指定的非负整数元数，其中 0 元函数符号是常量）和一个有限的谓词符号集合（每个符号都有一个指定的正整数元数）组成。设变量集合是可数无限的，例如 $\\{x,y,z,u,v,w,\\dots\\}$。项的构成规则如下：(i) 每个变量都是一个项；(ii) 每个常量符号都是一个项；(iii) 如果 $f$ 是 $L$ 中的一个 $n$ 元函数符号，并且 $t_1,\\dots,t_n$ 是项，那么 $f(t_1,\\dots,t_n)$ 是一个项；(iv) 除此之外没有其他项。谓词符号和逻辑联结词构成公式，不允许出现在项的内部。\n\n选择一个选项，该选项指定一个有限标识 $L$ 并展示一个由 $L$ 的符号构成的具体字符串，该字符串不成其为一个 $L$-项的唯一原因是在一个函数应用中存在元数不匹配，且没有其他违反构成规则的情况（也就是说，该字符串仅使用来自 $L$ 的符号，没有在项的位置插入任何谓词应用或逻辑联结词，并使用标准的括号和逗号进行函数应用）。\n\nA. $L$ 有一元函数符号 $f$、三元函数符号 $g$、常量 $c$ 和二元谓词符号 $R$。字符串为 $f(g(x,y),c)$。\n\nB. $L$ 有一元函数符号 $f$、二元函数符号 $g$、常量 $c$ 和一元谓词符号 $R$。字符串为 $f(g(x,R(x)))$。\n\nC. $L$ 有一元函数符号 $f$、二元函数符号 $g$ 和常量 $c$。字符串为 $f(g(x,y,z))$。\n\nD. $L$ 对每个 $n \\in \\mathbb{N}$ 都有函数符号 $f_n$，其中 $f_n$ 是 $n$ 元的，还有一个常量 $c$。字符串为 $f_2(x,y,z)$。\n\nE. $L$ 有二元谓词符号 $p$ 和常量 $c$。字符串为 $p(c,c)$。", "solution": "首先验证问题陈述的正确性和可解性。\n\n### 步骤 1：提取已知条件\n问题为一阶语言中标识为 $L$ 的项提供了以下定义和条件：\n-   一个标识 $L$ 由一个有限的函数符号集合和一个有限的谓词符号集合组成。\n-   每个函数符号都有一个指定的非负整数元数。0 元函数符号是常量。\n-   每个谓词符号都有一个指定的正整数元数。\n-   变量集合是可数无限的，例如 $\\{x,y,z,u,v,w,\\dots\\}$。\n-   项的构成规则是：\n    1.  每个变量都是一个项。\n    2.  每个常量符号都是一个项。\n    3.  如果 $f$ 是 $L$ 中的一个 $n$ 元函数符号，并且 $t_1,\\dots,t_n$ 是项，那么 $f(t_1,\\dots,t_n)$ 是一个项。\n    4.  除此之外没有其他项。\n-   给出了一个约束：谓词符号和逻辑联结词构成公式，不允许出现在项的内部。\n-   任务是选择一个选项，该选项指定一个有限标识 $L$ 并展示一个字符串，该字符串不成其为一个 $L$-项的*唯一*原因是在一个函数应用中存在元数不匹配，且没有其他违反规则的情况。\n-   关于该失败的其他指定条件是，字符串仅使用来自 $L$ 的符号和变量，不在项的位置使用谓词应用或联结词，并使用标准的函数应用语法。\n\n### 步骤 2：使用提取的已知条件进行验证\n该问题在数理逻辑的标准框架内，特别是一阶语言的语法方面，是良定义的。\n-   **科学基础**：关于标识、项、元数和构成规则的定义是一阶逻辑中标准和基础的内容。该问题在科学上是合理的。\n-   **良构性**：问题是精确的。它要求在给定标识下，识别一种特定类型的语法错误——元数不匹配——作为表达式不成其为项的唯一原因。标准很明确，这意味着应该存在一个唯一的正确选项。\n-   **客观性**：问题以形式化、客观的语言陈述，没有歧义或主观因素。\n-   **完整性和一致性**：提供了项的构成规则，并详细说明了所需错误的性质。问题是自包含的。选项 (D) 提出了一个无限标识，这与问题对 $L$ 具有“有限的函数符号集合”的全局定义相矛盾。然而，问题要求“选择一个指定**有限标识** $L$ 的选项”。这使得选项 D 根据问题自身的标准成为无效选择，但这并不使问题陈述本身无效。该问题仍然是应用给定定义的有效练习。\n\n### 步骤 3：结论和行动\n问题陈述是有效的。这是一个应用一阶逻辑语法规则的标准练习。可以继续进行求解过程。\n\n### 求解推导\n任务是找出一个选项，其中一个字符串不成其为项的原因只有一个：在函数应用中存在单个元数不匹配。在达到该特定错误点之前，所有其他语法规则都必须被遵守。我们将根据项的递归定义来分析每个选项。\n\n一个项要么是一个变量、一个常量，要么是一个 $n$ 元函数符号 $f$ 应用于 $n$ 个其他已构成的项 $t_1, \\dots, t_n$。当一个 $n$ 元函数符号被应用于 $k \\neq n$ 个参数时，就会发生元数不匹配。如果参数本身是良构的项，并且没有违反其他规则（例如，在需要项的地方使用了谓词），那么这个错误就是“唯一的”。\n\n**选项 A. $L$ 有一元函数符号 $f$、三元函数符号 $g$、常量 $c$ 和二元谓词符号 $R$。字符串为 $f(g(x,y),c)$。**\n\n让我们解析字符串 $f(g(x,y),c)$。\n1.  最外层是函数符号 $f$ 的应用。$f$ 被定义为一元函数，意味着它只接受 $1$ 个参数。该字符串提供了 $2$ 个参数：$g(x,y)$ 和 $c$。这是一个元数不匹配。\n2.  让我们检查第一个参数 $g(x,y)$。符号 $g$ 是一个三元函数，意味着它需要 $3$ 个参数。这里它被给予了 $2$ 个参数，$x$ 和 $y$（它们是变量，是有效的项）。这也是一个元数不匹配。\n因此，该字符串包含两个不同的元数不匹配。不成其为项的原因不是“一个元数不匹配”（单数），而是至少两个。因此，这个选项不满足“唯一因为一个元数不匹配”的标准，即单一故障点。\n\n选项 A 的结论：**不正确**。\n\n**选项 B. $L$ 有一元函数符号 $f$、二元函数符号 $g$、常量 $c$ 和一元谓词符号 $R$。字符串为 $f(g(x,R(x)))$。**\n\n让我们解析字符串 $f(g(x,R(x)))$。\n1.  最内层是 $R(x)$。符号 $R$ 是一个一元谓词符号。它应用于一个项（变量 $x$）的结果是一个原子公式，而不是一个项。\n2.  构成规则明确指出，项只能是变量、常量或函数应用。问题进一步澄清，“谓词符号……不允许出现在项的内部”。\n3.  表达式 $g(x,R(x))$ 试图将公式 $R(x)$ 作为函数 $g$ 的第二个参数。这违反了项的定义（规则 (iii)），该规则要求函数的所有参数本身都必须是项。\n该字符串不成其为项的原因是在需要项的位置非法使用了谓词应用。这是一种与元数不匹配不同类型的语法违规。\n\n选项 B 的结论：**不正确**。\n\n**选项 C. $L$ 有一元函数符号 $f$、二元函数符号 $g$ 和常量 $c$。字符串为 $f(g(x,y,z))$。**\n\n让我们解析字符串 $f(g(x,y,z))$。\n1.  最外层是函数符号 $f$ 的应用。$f$ 是一元的，并且它被给予了恰好 $1$ 个参数，即表达式 $g(x,y,z)$。在 $f$ 的应用中，元数是正确的（对于一元函数有 $1$ 个参数）。\n2.  要使 $f(g(x,y,z))$ 成为一个项，它的参数 $g(x,y,z)$ 必须是一个项。\n3.  让我们分析 $g(x,y,z)$。函数符号 $g$ 是二元的，意味着它需要 $2$ 个参数。在这里，它被应用于 $3$ 个参数：$x$、 $y$ 和 $z$。\n4.  参数 $x$、 $y$ 和 $z$ 都是变量，是有效的项。没有使用谓词符号。语法在其他方面是标准的。\n5.  将 $g$ 应用于 $3$ 个参数是一个元数不匹配。因此，$g(x,y,z)$ 不是一个良构的项。\n6.  由于 $g(x,y,z)$ 不是一个项，所以整个表达式 $f(g(x,y,z))$ 也不是一个项。阻止该字符串成为项的根本错误是 $g$ 的应用中的单个元数不匹配。在该点之前，字符串构建过程的所有其他方面都是正确的。这完全符合问题的描述。\n\n选项 C 的结论：**正确**。\n\n**选项 D. $L$ 对每个 $n \\in \\mathbb{N}$ 都有函数符号 $f_n$，其中 $f_n$ 是 $n$ 元的，还有一个常量 $c$。字符串为 $f_2(x,y,z)$。**\n\n问题陈述建立了一个全局条件，即“一个标识 $L$ 由一个**有限**的函数符号集合组成……”。此选项中提出的标识包含函数符号集合 $\\{f_n | n \\in \\mathbb{N}\\}$，这是一个可数无限集。因此，此选项指定的标识不是有限的，违反了问题的一个前提。问题要求选择一个“指定一个有限标识 $L$”的选项。此选项未能做到这一点。\n\n即使我们不考虑这个违规，字符串 $f_2(x,y,z)$ 将一个二元函数符号 $f_2$ 应用于 $3$ 个参数，这是一个元数不匹配。选项的这一部分是正确的，但关于标识的初始前提是有缺陷的。\n\n选项 D 的结论：**不正确**。\n\n**选项 E. $L$ 有二元谓词符号 $p$ 和常量 $c$。字符串为 $p(c,c)$。**\n\n让我们分析字符串 $p(c,c)$。\n1.  符号 $p$ 是一个二元谓词符号。\n2.  符号 $c$ 是一个常量，因此是一个有效的项。\n3.  字符串 $p(c,c)$ 是一个二元谓词符号应用于 $2$ 个项。这是一个良构的原子公式的定义。\n4.  问题要求一个*不成其为项*的字符串。字符串 $p(c,c)$ 是一个公式，而不是一个项。所以它确实不成其为项。\n5.  然而，这种失败的原因必须是“唯一因为在函数应用中存在元数不匹配”。符号 $p$ 是一个谓词，而不是一个函数。没有函数应用，因此也没有函数应用中的元数不匹配。该字符串不是一个项，因为它是一个公式。这是一个类别上的差异，而不是一个项的畸形构成。\n\n选项 E 的结论：**不正确**。\n\n**结论**\n只有选项 C 提供了一个有限的标识和一个字符串，该字符串作为一个项是畸形的，原因是函数应用中存在单个、局部的元数不匹配，且没有其他语法错误。", "answer": "$$\\boxed{C}$$", "id": "2972885"}, {"introduction": "从语法构造迈向语义解释，是理解一阶逻辑的关键一步。一个合法的项（term）不仅仅是符号的序列，它在一个具体的数学结构（或模型）中明确地指代一个对象。项的解释（interpretation）是根据其结构递归定义的，从最内层的常量和变量开始，逐层向外计算。这个练习[@problem_id:2972859]将这一抽象过程变得具体可感。你将进入一个给定的有限结构，通过一步步的递归计算，揭示一个复杂嵌套项最终的语义值，亲身体验从符号到意义的映射过程。", "problem": "设 $\\mathcal{L}$ 是一个一阶语言，含有一个常量符号 $c$，一个一元函数符号 $f$，一个二元函数符号 $g$，以及一个三元函数符号 $h$。考虑一个有限 $\\mathcal{L}$-结构 $\\mathcal{M}$，其论域为 $M = \\{0,1,2,3,4,5,6\\}$，所有算术运算均在模 $7$ 的意义下进行，并且符号的解释如下：\n- $c^{\\mathcal{M}} = 5$，\n- $f^{\\mathcal{M}}(u) = 3u^{2} + 1$（在模 $7$ 下计算），\n- $g^{\\mathcal{M}}(u,v) = 2u + 4v + 3$（在模 $7$ 下计算），\n- $h^{\\mathcal{M}}(u,v,w) = u \\cdot v - 2w$（在模 $7$ 下计算）。\n\n设 $\\alpha$ 是一个变量赋值，其中 $\\alpha(x) = 3$ 且 $\\alpha(y) = 6$。考虑 $\\mathcal{L}$-项\n$$t := h\\big(f(g(x, f(c))),\\ g(f(x), h(c, x, y)),\\ f(f(y))\\big).$$\n\n仅使用一阶逻辑（FOL）中项的解释的基本递归子句——即关于常量符号、变量和函数应用的子句——计算 $\\llbracket t \\rrbracket^{\\mathcal{M},\\alpha} \\in M$ 的值，并在推导过程中逐步验证每个子句的应用。将最终答案表示为 $M$ 中的一个确切元素。无需四舍五入，也不涉及单位。", "solution": "该问题陈述是数理逻辑中的一个适定练习，特别是在模型论领域。它提供了一个一阶语言 $\\mathcal{L}$，一个具有明确定义论域和所有非逻辑符号解释的有限 $\\mathcal{L}$-结构 $\\mathcal{M}$，一个合式 $\\mathcal{L}$-项 $t$，以及一个覆盖了 $t$ 中所有自由变量的变量赋值 $\\alpha$。任务是计算项 $t$ 在结构 $\\mathcal{M}$ 中关于赋值 $\\alpha$ 的解释，记作 $\\llbracket t \\rrbracket^{\\mathcal{M},\\alpha}$。所有组成部分都有形式化定义且自洽。该问题具有科学依据、是客观的，并且包含足够的信息以得到唯一解。因此，该问题是有效的。\n\n一个项 $\\tau$ 在结构 $\\mathcal{M}$ 中于变量赋值 $\\alpha$ 下的解释，记作 $\\llbracket \\tau \\rrbracket^{\\mathcal{M},\\alpha}$，由以下一阶逻辑的基本子句递归定义：\n$1$. 如果 $\\tau$ 是一个变量 $v$，则 $\\llbracket v \\rrbracket^{\\mathcal{M},\\alpha} = \\alpha(v)$。\n$2$. 如果 $\\tau$ 是一个常量符号 $c$，则 $\\llbracket c \\rrbracket^{\\mathcal{M},\\alpha} = c^{\\mathcal{M}}$。\n$3$. 如果 $\\tau$ 是形式为 $F(t_1, ..., t_n)$ 的项，其中 $F$ 是一个 $n$-元函数符号，而 $t_1, ..., t_n$ 是项，则 $\\llbracket F(t_1, ..., t_n) \\rrbracket^{\\mathcal{M},\\alpha} = F^{\\mathcal{M}}(\\llbracket t_1 \\rrbracket^{\\mathcal{M},\\alpha}, ..., \\llbracket t_n \\rrbracket^{\\mathcal{M},\\alpha})$。\n\n我们被要求计算项\n$$t := h\\big(f(g(x, f(c))),\\ g(f(x), h(c, x, y)),\\ f(f(y))\\big)$$\n在论域为 $M = \\{0,1,2,3,4,5,6\\}$ 且赋值为 $\\alpha(x) = 3, \\alpha(y) = 6$ 的结构 $\\mathcal{M}$ 中的值。我们将从最内层到最外层递归地对 $t$ 的子项进行求值。所有算术运算都将在模 $7$ 下进行。\n\n设最外层函数 $h$ 的三个主要参数记为：\n- $t_1 := f(g(x, f(c)))$\n- $t_2 := g(f(x), h(c, x, y))$\n- $t_3 := f(f(y))$\n\n我们的目标是计算 $\\llbracket t \\rrbracket^{\\mathcal{M},\\alpha} = h^{\\mathcal{M}}(\\llbracket t_1 \\rrbracket^{\\mathcal{M},\\alpha}, \\llbracket t_2 \\rrbracket^{\\mathcal{M},\\alpha}, \\llbracket t_3 \\rrbracket^{\\mathcal{M},\\alpha})$。\n\n**步骤 1: $\\llbracket t_1 \\rrbracket^{\\mathcal{M},\\alpha}$ 的求值**\n为了求得 $\\llbracket t_1 \\rrbracket^{\\mathcal{M},\\alpha} = \\llbracket f(g(x, f(c))) \\rrbracket^{\\mathcal{M},\\alpha}$，我们必须首先对其参数 $\\llbracket g(x, f(c)) \\rrbracket^{\\mathcal{M},\\alpha}$ 求值。这又需要对 $\\llbracket x \\rrbracket^{\\mathcal{M},\\alpha}$ 和 $\\llbracket f(c) \\rrbracket^{\\mathcal{M},\\alpha}$ 进行求值。\n\n- $\\llbracket f(c) \\rrbracket^{\\mathcal{M},\\alpha}$ 的求值：\n    - 根据子句 2，常量符号 $c$ 的解释是 $\\llbracket c \\rrbracket^{\\mathcal{M},\\alpha} = c^{\\mathcal{M}} = 5$。\n    - 根据子句 3，$\\llbracket f(c) \\rrbracket^{\\mathcal{M},\\alpha} = f^{\\mathcal{M}}(\\llbracket c \\rrbracket^{\\mathcal{M},\\alpha}) = f^{\\mathcal{M}}(5)$。\n    - 使用定义 $f^{\\mathcal{M}}(u) = 3u^2 + 1$，我们计算：\n    $$f^{\\mathcal{M}}(5) = 3 \\cdot 5^2 + 1 = 3 \\cdot 25 + 1 \\pmod{7}$$\n    - 因为 $25 \\equiv 4 \\pmod{7}$，我们有：\n    $$3 \\cdot 4 + 1 = 12 + 1 = 13 \\equiv 6 \\pmod{7}$$\n    - 因此，$\\llbracket f(c) \\rrbracket^{\\mathcal{M},\\alpha} = 6$。\n\n- $\\llbracket g(x, f(c)) \\rrbracket^{\\mathcal{M},\\alpha}$ 的求值：\n    - 根据子句 1，变量 $x$ 的解释是 $\\llbracket x \\rrbracket^{\\mathcal{M},\\alpha} = \\alpha(x) = 3$。\n    - 根据子句 3，使用上述结果：\n    $$\\llbracket g(x, f(c)) \\rrbracket^{\\mathcal{M},\\alpha} = g^{\\mathcal{M}}(\\llbracket x \\rrbracket^{\\mathcal{M},\\alpha}, \\llbracket f(c) \\rrbracket^{\\mathcal{M},\\alpha}) = g^{\\mathcal{M}}(3, 6)$$\n    - 使用定义 $g^{\\mathcal{M}}(u,v) = 2u + 4v + 3$，我们计算：\n    $$g^{\\mathcal{M}}(3, 6) = 2 \\cdot 3 + 4 \\cdot 6 + 3 = 6 + 24 + 3 = 33 \\pmod{7}$$\n    - 因为 $33 = 4 \\cdot 7 + 5$，我们有 $33 \\equiv 5 \\pmod{7}$。\n    - 因此，$\\llbracket g(x, f(c)) \\rrbracket^{\\mathcal{M},\\alpha} = 5$。\n\n- $\\llbracket t_1 \\rrbracket^{\\mathcal{M},\\alpha}$ 的最终求值：\n    - 根据子句 3，$\\llbracket t_1 \\rrbracket^{\\mathcal{M},\\alpha} = f^{\\mathcal{M}}(\\llbracket g(x, f(c)) \\rrbracket^{\\mathcal{M},\\alpha}) = f^{\\mathcal{M}}(5)$。\n    - 我们已经计算出 $f^{\\mathcal{M}}(5) = 6$。\n    - 所以，$\\llbracket t_1 \\rrbracket^{\\mathcal{M},\\alpha} = 6$。\n\n**步骤 2: $\\llbracket t_2 \\rrbracket^{\\mathcal{M},\\alpha}$ 的求值**\n为了求得 $\\llbracket t_2 \\rrbracket^{\\mathcal{M},\\alpha} = \\llbracket g(f(x), h(c, x, y)) \\rrbracket^{\\mathcal{M},\\alpha}$，我们必须对其参数 $\\llbracket f(x) \\rrbracket^{\\mathcal{M},\\alpha}$ 和 $\\llbracket h(c, x, y) \\rrbracket^{\\mathcal{M},\\alpha}$ 求值。\n\n- $\\llbracket f(x) \\rrbracket^{\\mathcal{M},\\alpha}$ 的求值：\n    - 我们有 $\\llbracket x \\rrbracket^{\\mathcal{M},\\alpha} = 3$。\n    - 根据子句 3，$\\llbracket f(x) \\rrbracket^{\\mathcal{M},\\alpha} = f^{\\mathcal{M}}(\\llbracket x \\rrbracket^{\\mathcal{M},\\alpha}) = f^{\\mathcal{M}}(3)$。\n    - 计算：$f^{\\mathcal{M}}(3) = 3 \\cdot 3^2 + 1 = 3 \\cdot 9 + 1 = 27 + 1 = 28 \\pmod{7}$。\n    - 因为 $28 = 4 \\cdot 7 + 0$，我们有 $28 \\equiv 0 \\pmod{7}$。\n    - 因此，$\\llbracket f(x) \\rrbracket^{\\mathcal{M},\\alpha} = 0$。\n\n- $\\llbracket h(c, x, y) \\rrbracket^{\\mathcal{M},\\alpha}$ 的求值：\n    - 我们有 $\\llbracket c \\rrbracket^{\\mathcal{M},\\alpha} = 5$，$\\llbracket x \\rrbracket^{\\mathcal{M},\\alpha} = 3$，以及 $\\llbracket y \\rrbracket^{\\mathcal{M},\\alpha} = \\alpha(y) = 6$。\n    - 根据子句 3：$\\llbracket h(c, x, y) \\rrbracket^{\\mathcal{M},\\alpha} = h^{\\mathcal{M}}(\\llbracket c \\rrbracket^{\\mathcal{M},\\alpha}, \\llbracket x \\rrbracket^{\\mathcal{M},\\alpha}, \\llbracket y \\rrbracket^{\\mathcal{M},\\alpha}) = h^{\\mathcal{M}}(5, 3, 6)$。\n    - 使用定义 $h^{\\mathcal{M}}(u,v,w) = u \\cdot v - 2w$，我们计算：\n    $$h^{\\mathcal{M}}(5, 3, 6) = 5 \\cdot 3 - 2 \\cdot 6 = 15 - 12 = 3 \\pmod{7}$$\n    - 因此，$\\llbracket h(c, x, y) \\rrbracket^{\\mathcal{M},\\alpha} = 3$。\n\n- $\\llbracket t_2 \\rrbracket^{\\mathcal{M},\\alpha}$ 的最终求值：\n    - 根据子句 3，$\\llbracket t_2 \\rrbracket^{\\mathcal{M},\\alpha} = g^{\\mathcal{M}}(\\llbracket f(x) \\rrbracket^{\\mathcal{M},\\alpha}, \\llbracket h(c, x, y) \\rrbracket^{\\mathcal{M},\\alpha}) = g^{\\mathcal{M}}(0, 3)$。\n    - 计算：$g^{\\mathcal{M}}(0, 3) = 2 \\cdot 0 + 4 \\cdot 3 + 3 = 0 + 12 + 3 = 15 \\pmod{7}$。\n    - 因为 $15 = 2 \\cdot 7 + 1$，我们有 $15 \\equiv 1 \\pmod{7}$。\n    - 所以，$\\llbracket t_2 \\rrbracket^{\\mathcal{M},\\alpha} = 1$。\n\n**步骤 3: $\\llbracket t_3 \\rrbracket^{\\mathcal{M},\\alpha}$ 的求值**\n为了求得 $\\llbracket t_3 \\rrbracket^{\\mathcal{M},\\alpha} = \\llbracket f(f(y)) \\rrbracket^{\\mathcal{M},\\alpha}$，我们首先对内层项 $\\llbracket f(y) \\rrbracket^{\\mathcal{M},\\alpha}$ 求值。\n\n- $\\llbracket f(y) \\rrbracket^{\\mathcal{M},\\alpha}$ 的求值：\n    - 我们有 $\\llbracket y \\rrbracket^{\\mathcal{M},\\alpha} = 6$。\n    - 根据子句 3，$\\llbracket f(y) \\rrbracket^{\\mathcal{M},\\alpha} = f^{\\mathcal{M}}(\\llbracket y \\rrbracket^{\\mathcal{M},\\alpha}) = f^{\\mathcal{M}}(6)$。\n    - 计算：$f^{\\mathcal{M}}(6) = 3 \\cdot 6^2 + 1 \\pmod{7}$。\n    - 因为 $6 \\equiv -1 \\pmod{7}$，我们有 $6^2 \\equiv (-1)^2 = 1 \\pmod{7}$。\n    - $f^{\\mathcal{M}}(6) = 3 \\cdot 1 + 1 = 4 \\pmod{7}$。\n    - 因此，$\\llbracket f(y) \\rrbracket^{\\mathcal{M},\\alpha} = 4$。\n\n- $\\llbracket t_3 \\rrbracket^{\\mathcal{M},\\alpha}$ 的最终求值：\n    - 根据子句 3，$\\llbracket t_3 \\rrbracket^{\\mathcal{M},\\alpha} = f^{\\mathcal{M}}(\\llbracket f(y) \\rrbracket^{\\mathcal{M},\\alpha}) = f^{\\mathcal{M}}(4)$。\n    - 计算：$f^{\\mathcal{M}}(4) = 3 \\cdot 4^2 + 1 = 3 \\cdot 16 + 1 \\pmod{7}$。\n    - 因为 $16 \\equiv 2 \\pmod{7}$，我们有：\n    $$f^{\\mathcal{M}}(4) = 3 \\cdot 2 + 1 = 6 + 1 = 7 \\equiv 0 \\pmod{7}$$\n    - 所以，$\\llbracket t_3 \\rrbracket^{\\mathcal{M},\\alpha} = 0$。\n\n**步骤 4: $\\llbracket t \\rrbracket^{\\mathcal{M},\\alpha}$ 的最终计算**\n现在我们得到了主项 $t$ 的三个参数的解释：\n- $\\llbracket t_1 \\rrbracket^{\\mathcal{M},\\alpha} = 6$\n- $\\llbracket t_2 \\rrbracket^{\\mathcal{M},\\alpha} = 1$\n- $\\llbracket t_3 \\rrbracket^{\\mathcal{M},\\alpha} = 0$\n\n最后一次对完整的项 $t$ 使用子句 3：\n$$\\llbracket t \\rrbracket^{\\mathcal{M},\\alpha} = h^{\\mathcal{M}}(\\llbracket t_1 \\rrbracket^{\\mathcal{M},\\alpha}, \\llbracket t_2 \\rrbracket^{\\mathcal{M},\\alpha}, \\llbracket t_3 \\rrbracket^{\\mathcal{M},\\alpha}) = h^{\\mathcal{M}}(6, 1, 0)$$\n- 使用 $h^{\\mathcal{M}}(u,v,w) = u \\cdot v - 2w$ 进行计算：\n$$h^{\\mathcal{M}}(6, 1, 0) = 6 \\cdot 1 - 2 \\cdot 0 = 6 - 0 = 6 \\pmod{7}$$\n\n在结构 $\\mathcal{M}$ 中于赋值 $\\alpha$ 下，项 $t$ 的值为 $6$。", "answer": "$$\\boxed{6}$$", "id": "2972859"}, {"introduction": "当我们从项（term）转向更复杂的公式（formula）时，替换（substitution）操作变得至关重要，但它也伴随着一个微妙的陷阱：变量捕获（variable capture）。简单地进行文本替换，可能会无意中将被代入的自由变量置于一个同名量词的辖域之内，从而彻底改变公式的原意。这个练习[@problem_id:2972882]为你设置了一个经典的变量捕获场景。通过正确执行替换，你将掌握为避免捕获而重命名约束变量（即$\\alpha$-变换）的关键技巧，这是精通逻辑推演和程序语言语义的基石。", "problem": "考虑一阶逻辑（FOL），其语言 $\\mathcal{L}$ 包含一个二元谓词符号 $R$、一个一元谓词符号 $P$、变量 $x, y, z, w$ 以及通常的逻辑联结词和量词。请仅使用自由变量和约束变量、句法替换和约束变量重命名（也称为 $\\alpha$-变换）的核心定义。令\n$$\n\\varphi(x) \\;=\\; \\forall y \\,\\Big( R(x,y) \\;\\rightarrow\\; \\exists y \\,\\big( P(y) \\,\\land\\, R(y,x) \\big) \\Big).\n$$\n我们打算将项 $y$ 替换 $\\varphi$ 中的自由变量 $x$，记作 $\\varphi[x := y]$。根据避免捕获的替换的定义，当一次替换会将替换项中的自由变量置于一个约束同名变量的量词之下时，必须首先对该约束变量进行系统性重命名，将其改为一个对于替换项来说是新鲜的变量。\n\n下列哪个候选公式是 $\\varphi(x)$ 中 $x$ 被 $y$ 进行避免捕获的替换后的正确结果（在 $\\alpha$-等价的意义下）？请选择所有适用的选项。不正确的选项看似合理，但因变量捕获或不正确的重命名而失败。\n\nA. $\\forall y \\,\\Big( R(y,y) \\;\\rightarrow\\; \\exists y \\,\\big( P(y) \\,\\land\\, R(y,y) \\big) \\Big)$\n\nB. $\\forall z \\,\\Big( R(y,z) \\;\\rightarrow\\; \\exists y \\,\\big( P(y) \\,\\land\\, R(y,y) \\big) \\Big)$\n\nC. $\\forall y \\,\\Big( R(y,y) \\;\\rightarrow\\; \\exists w \\,\\big( P(w) \\,\\land\\, R(w,y) \\big) \\Big)$\n\nD. $\\forall z \\,\\Big( R(y,z) \\;\\rightarrow\\; \\exists w \\,\\big( P(w) \\,\\land\\, R(w,y) \\big) \\Big)$\n\nE. $\\forall z \\,\\Big( R(y,z) \\;\\rightarrow\\; \\exists z \\,\\big( P(z) \\,\\land\\, R(z,y) \\big) \\Big)$\n\n你的推理应从形式化定义出发：如果一个变量的出现位于约束它的量词的作用域内，则它是约束的；否则它是自由的。公式 $\\psi$ 的自由变量集合 $FV(\\psi)$ 是对公式进行归纳定义的。替换 $\\psi[x := t]$ 是在 $\\psi$ 的结构上归纳定义的，但有一个附加条件：在将 $t$ 替换到约束了在 $t$ 中自由出现的变量的量词作用域之前，该约束变量必须被重命名为一个在 $t$ 中不自由出现（并且相对于上下文是新鲜的）的变量，以防止变量捕获。不要使用任何临时性的捷径；直接从这些定义来证明每个结论。", "solution": "用户希望找到在一阶逻辑中进行避免捕获的替换的正确结果。\n\n### 步骤1：提取给定信息\n- **语言 $\\mathcal{L}$**：包含一个二元谓词符号 $R$、一个一元谓词符号 $P$ 和变量 $x, y, z, w$。\n- **公式 $\\varphi(x)$**：定义为 $\\varphi(x) \\;=\\; \\forall y \\,\\Big( R(x,y) \\;\\rightarrow\\; \\exists y \\,\\big( P(y) \\,\\land\\, R(y,x) \\big) \\Big)$。\n- **任务**：执行避免捕获的替换，将项 $y$ 替换 $\\varphi(x)$ 中的自由变量 $x$，记作 $\\varphi(x)[x := y]$。\n- **核心定义**：推理必须基于自由变量和约束变量、句法替换以及 $\\alpha$-变换（约束变量重命名）的形式化定义。明确规定了避免捕获的规则：“当一次替换会将替换项中的自由变量置于一个约束同名变量的量词之下时，必须首先对该约束变量进行系统性重命名，将其改为一个对于替换项来说是新鲜的变量。”\n\n### 步骤2：使用提取的给定信息进行验证\n- **科学合理性**：该问题是数理逻辑，特别是一阶谓词逻辑中的一个标准练习。自由/约束变量、替换和变量捕获的概念是 FOL 句法和语义的基础。该问题在科学上是合理的。\n- **良定性**：公式 $\\varphi(x)$ 在句法上是良构的，即使嵌套的量词约束了同名的变量 $y$。在形式逻辑中，内层量词 $\\exists y$ 的作用域嵌套在外层量词 $\\forall y$ 的作用域内，绑定关系由最内层的适用量词决定。任务是根据指定规则执行一个明确定义的操作（$\\varphi(x)[x := y]$）。在 $\\alpha$-等价的意义下，存在唯一的结果。该问题是良定的。\n- **客观性**：问题以逻辑和数学的形式语言陈述，没有任何主观或模棱两可的术语。\n\n### 步骤3：判断与行动\n问题陈述是有效的。它是一个在已建立的形式系统中的良定标准问题。我将进行推导和求解。\n\n### 正确替换的推导\n\n任务是计算 $\\varphi(x)[x := y]$，其中被替换的项是 $t=y$，公式是：\n$$\n\\varphi(x) \\;=\\; \\forall y \\,\\Big( R(x,y) \\;\\rightarrow\\; \\exists y \\,\\big( P(y) \\,\\land\\, R(y,x) \\big) \\Big)\n$$\n\n首先，我们确定公式 $\\varphi(x)$ 和项 $t=y$ 的自由变量。\n- 在 $\\varphi(x)$ 中，变量 $x$ 出现了两次，这两次都是自由的，因为它们不在约束 $x$ 的量词的作用域内。变量 $y$ 的所有出现都被外层的 $\\forall y$ 或内层的 $\\exists y$ 所约束。因此，$\\varphi(x)$ 的自由变量集合是 $FV(\\varphi(x)) = \\{x\\}$。\n- 要替换的项是 $t = y$。这个项中的自由变量集合是 $FV(t) = \\{y\\}$。\n\n替换 $\\psi[v := t]$ 是递归定义的。对于一个形式为 $\\forall u \\, \\chi$ 或 $\\exists u \\, \\chi$ 的量化公式，如果 $v \\neq u$ 且 $u \\in FV(t)$，替换 $(\\forall u \\, \\chi)[v := t]$ 将导致变量捕获。在这种情况下，必须首先将约束变量 $u$ 重命名为一个不在 $FV(\\chi) \\cup FV(t)$ 中的新鲜变量 $u'$。\n\n我们现在逐步执行替换 $\\varphi(x)[x := y]$。\n\n1.  **外层量词 $\\forall y$**：该公式的形式是 $(\\forall y \\, \\psi)[x := y]$，其中 $\\psi$ 是 $\\Big( R(x,y) \\;\\rightarrow\\; \\exists y \\,\\big( P(y) \\,\\land\\, R(y,x) \\big) \\Big)$。被替换的变量是 $x$，约束变量是 $y$。项是 $t=y$。由于约束变量 $y$ 是项 $t=y$ 中的一个自由变量（即 $y \\in FV(y)$），直接替换将导致项的变量 $y$ 被 $\\forall y$ 量词捕获。\n    为避免这种捕获，我们必须将外层量词中的约束变量 $y$ 重命名为一个新鲜变量。可用的变量指定为 $x, y, z, w$。一个变量是新鲜的，如果它不引入新的冲突。我们选择变量 $z$。变量 $z$ 不在 $FV(\\varphi(x)) = \\{x\\}$ 中，也不在 $FV(y) = \\{y\\}$ 中。因此，我们对 $\\varphi(x)$ 进行 $\\alpha$-变换，将外层约束的 $y$ 重命名为 $z$：\n    $$\n    \\varphi(x) \\equiv_\\alpha \\varphi'(x) = \\forall z \\,\\Big( \\big( R(x,y) \\;\\rightarrow\\; \\exists y \\,\\dots \\big)[y := z] \\Big)\n    $$\n    替换 $[y := z]$ 仅适用于在 $\\forall y$ 作用域内 $y$ 的自由出现。在子公式 $\\Big( R(x,y) \\;\\rightarrow\\; \\exists y \\,\\dots \\Big)$ 中，$R(x,y)$ 中的 $y$ 是自由的，但 $\\exists y \\,\\dots$ 中的 $y$ 被内层量词约束，因此不受影响。重命名的结果是：\n    $$\n    \\varphi'(x) = \\forall z \\,\\Big( R(x,z) \\;\\rightarrow\\; \\exists y \\,\\big( P(y) \\,\\land\\, R(y,x) \\big) \\Big)\n    $$\n\n2.  **对重命名后的公式进行替换**：我们现在计算 $\\varphi'(x)[x := y]$。由于新的约束变量 $z$ 不在 $FV(y) = \\{y\\}$ 中，我们可以将替换推入量词内部：\n    $$\n    \\varphi'(x)[x := y] = \\forall z \\,\\left( \\Big( R(x,z) \\;\\rightarrow\\; \\exists y \\,\\big( P(y) \\,\\land\\, R(y,x) \\big) \\Big)[x := y] \\right)\n    $$\n    替换在蕴含符号 $\\rightarrow$ 上分配：\n    $$\n    = \\forall z \\,\\left( R(x,z)[x := y] \\;\\rightarrow\\; \\Big(\\exists y \\,\\big( P(y) \\,\\land\\, R(y,x) \\big)\\Big)[x := y] \\right)\n    $$\n    第一部分很简单：$R(x,z)[x := y] = R(y,z)$。\n\n3.  **内层量词 $\\exists y$**：我们现在关注第二部分：$\\Big(\\exists y \\,\\big( P(y) \\,\\land\\, R(y,x) \\big)\\Big)[x := y]$。这又是一次对量化公式的替换。被替换的变量是 $x$，约束变量是 $y$，项是 $t=y$。由于约束变量 $y$ 在 $FV(t) = \\{y\\}$ 中，这是另一个变量捕获的情况。\n    为避免捕获，我们必须将内层约束变量 $y$ 重命名为一个在此上下文中是新鲜的变量。上下文是替换 $\\big(\\exists y \\, \\chi\\big)[x := y]$，其中 $\\chi = P(y) \\land R(y,x)$。一个新鲜变量不能在 $FV(\\chi) = \\{x\\}$ 或 $FV(t) = \\{y\\}$ 中。所以，新变量不能是 $x$ 或 $y$。我们选择变量 $w$（可用且满足此条件）。我们对子公式进行 $\\alpha$-变换：\n    $$\n    \\exists y \\,\\big( P(y) \\,\\land\\, R(y,x) \\big) \\equiv_\\alpha \\exists w \\,\\Big(\\big( P(y) \\,\\land\\, R(y,x) \\big)[y := w] \\Big) = \\exists w \\,\\big( P(w) \\,\\land\\, R(w,x) \\big)\n    $$\n    现在，我们可以安全地对这个重命名后的子公式执行替换 $[x := y]$：\n    $$\n    \\Big(\\exists w \\,\\big( P(w) \\,\\land\\, R(w,x) \\big)\\Big)[x := y] = \\exists w \\,\\Big(\\big( P(w) \\,\\land\\, R(w,x) \\big)[x := y]\\Big)\n    $$\n    这简化为：\n    $$\n    = \\exists w \\,\\big( P(w) \\,\\land\\, R(w,y) \\big)\n    $$\n\n4.  **最终组合**：结合步骤2和步骤3的结果，我们得到最终的公式：\n    $$\n    \\forall z \\,\\Big( R(y,z) \\;\\rightarrow\\; \\exists w \\,\\big( P(w) \\,\\land\\, R(w,y) \\big) \\Big)\n    $$\n    这个公式对应于选项D。\n\n问题要求找出在 $\\alpha$-等价意义下所有正确的结果。让我们分析一下，选择其他新鲜变量是否会导致其他选项。在重命名内层约束变量 $y$ 时，我们选择了 $w$。如果我们选择了 $z$ 呢？变量 $z$ 不在 $FV(\\chi) \\cup FV(t) = \\{x, y\\}$ 中，所以它也是一个有效的新鲜变量选择。将内层 $y$ 重命名为 $z$ 得到 $\\exists z \\big( P(z) \\land R(z,x) \\big)$。然后进行替换 $[x:=y]$ 得到 $\\exists z \\big( P(z) \\land R(z,y) \\big)$。\n将此结果放回主公式（从步骤2）中，得到：\n$$\n\\forall z \\,\\Big( R(y,z) \\;\\rightarrow\\; \\exists z \\,\\big( P(z) \\,\\land\\, R(z,y) \\big) \\Big)\n$$\n这个公式对应于选项E。尽管重用约束变量名 $z$ 可能会令人困惑，但它在句法上是有效的，并且是替换过程的正确结果。内层量词 $\\exists z$“遮蔽”了外层量词 $\\forall z$，因此它们约束了不同的 $z$ 出现。\n\n最后，我们必须检查选项D和E是否 $\\alpha$-等价。\n令 $F_D = \\forall z \\,\\Big( R(y,z) \\;\\rightarrow\\; \\exists w \\,\\big( P(w) \\,\\land\\, R(w,y) \\big) \\Big)$。\n令 $F_E = \\forall z \\,\\Big( R(y,z) \\;\\rightarrow\\; \\exists z \\,\\big( P(z) \\,\\land\\, R(z,y) \\big) \\Big)$。\n这两个公式仅在存在量词中约束变量的名称上有所不同。$F_E$ 中的子公式 $\\exists z \\,\\big( P(z) \\,\\land\\, R(z,y) \\big)$ 可以通过将 $F_D$ 中的约束变量 $w$ 重命名为 $z$ 来从 $\\exists w \\,\\big( P(w) \\,\\land\\, R(w,y) \\big)$ 得到。这是一个有效的 $\\alpha$-变换，因为 $z$ 不是存在量词作用域 $P(w) \\land R(w,y)$ 中的自由变量，该作用域唯一的自由变量是 $y$。因此，$F_D \\equiv_\\alpha F_E$。\n由于D和E都是替换过程的有效结果（取决于新鲜变量名的选择），并且它们彼此 $\\alpha$-等价，所以它们都是正确的答案。\n\n### 逐项分析\n\n*   **A. $\\forall y \\,\\Big( R(y,y) \\;\\rightarrow\\; \\exists y \\,\\big( P(y) \\,\\land\\, R(y,y) \\big) \\Big)$**\n    这个公式是在没有重命名任何约束变量的情况下，将 $y$ 朴素地替换为 $x$ 的每个自由出现的结果。替换 $R(x,y)$ 中 $x$ 的 $y$ 被外层 $\\forall y$ 捕获。替换 $R(y,x)$ 中 $x$ 的 $y$ 被内层 $\\exists y$ 捕获。这违反了避免捕获的替换的定义。\n    **结论：错误。**\n\n*   **B. $\\forall z \\,\\Big( R(y,z) \\;\\rightarrow\\; \\exists y \\,\\big( P(y) \\,\\land\\, R(y,y) \\big) \\Big)$**\n    这个公式正确地将外层约束变量 $y$ 重命名为 $z$，避免了蕴含第一部分的捕获，得到 $R(y,z)$。然而，它未能重命名内层约束变量 $y$。在子公式 $\\exists y \\, (P(y) \\land R(y,x))$ 中对 $x$ 进行 $y$ 的替换，朴素地产生了 $\\exists y \\, (P(y) \\land R(y,y))$，其中新的 $y$ 被存在量词捕获。这是对替换规则的错误应用。\n    **结论：错误。**\n\n*   **C. $\\forall y \\,\\Big( R(y,y) \\;\\rightarrow\\; \\exists w \\,\\big( P(w) \\,\\land\\, R(w,y) \\big) \\Big)$**\n    这个公式在替换前正确地将内层约束变量 $y$ 重命名为 $w$，得到了正确的后件 $\\exists w \\, (P(w) \\land R(w,y))$。然而，它未能重命名外层约束变量 $y$。在 $R(x,y)$ 中对 $x$ 进行 $y$ 的替换导致了 $R(y,y)$，其中新的 $y$ 被全称量词捕获。这违反了替换规则。\n    **结论：错误。**\n\n*   **D. $\\forall z \\,\\Big( R(y,z) \\;\\rightarrow\\; \\exists w \\,\\big( P(w) \\,\\land\\, R(w,y) \\big) \\Big)$**\n    这个公式是正确应用避免捕获的替换的结果。外层约束变量 $y$ 被重命名为 $z$。内层约束变量 $y$ 被重命名为 $w$。这两个重命名都是防止变量捕获所必需的。如推导所示，这是一个正确的结果。\n    **结论：正确。**\n\n*   **E. $\\forall z \\,\\Big( R(y,z) \\;\\rightarrow\\; \\exists z \\,\\big( P(z) \\,\\land\\, R(z,y) \\big) \\Big)$**\n    这个公式是正确应用避免捕获的替换的另一个可能结果。外层约束变量 $y$ 被重命名为 $z$。内层约束变量 $y$ 也被重命名为 $z$。这对于内层替换的局部上下文来说是一个有效的新鲜变量选择，因为它不是所涉及的自由变量 $\\{x, y\\}$ 之一。得到的公式虽然由于使用相同变量名的嵌套量词而可能令人困惑，但在形式上是正确的。此外，它与选项D中的公式 $\\alpha$-等价。\n    **结论：正确。**", "answer": "$$\\boxed{DE}$$", "id": "2972882"}]}