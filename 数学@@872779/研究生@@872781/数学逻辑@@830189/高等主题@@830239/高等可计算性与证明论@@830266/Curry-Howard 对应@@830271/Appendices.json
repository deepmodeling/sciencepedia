{"hands_on_practices": [{"introduction": "首先，我们来探索柯里-霍华德对应中最基本的核心关联：逻辑蕴含与函数类型之间的关系。这个练习将演示 λ 演算中的 β-归约这一计算步骤，如何直接对应于自然演绎中对一个证明的简化，具体而言，就是移除一个包含了蕴含的引入及其紧随其后的消除的冗余步骤。通过掌握这个简单的案例 [@problem_id:2985657]，你将为后续更复杂的概念建立起关键的直觉。", "problem": "考虑简单类型 lambda 演算（STLC），其中类型由基类型和函数类型构造子 $\\,\\to\\,$ 构建，而项由变量、抽象 $\\lambda x.\\,t$ 和应用 $t\\,s$ 构建。Curry-Howard 对应（CHC）将类型等同于命题，将项等同于证明；特别地，类型为 $A \\to B$ 的项是从命题 $A$ 可以推导出命题 $B$ 的一个证明。蕴含的引入规则对应于在被消除的假设 $x:A$ 下构造一个抽象 $\\lambda x.\\,t$，而消除规则对应于当 $t:A\\to B$ 且 $s:A$ 时的应用 $t\\,s$。其计算内容由 $\\beta$-归约所控制，其中将一个抽象应用于一个参数会通过替换进行归约：$(\\lambda x.\\,t)\\,s \\to_{\\beta} t[x:=s]$。如果一个项没有可应用的 $\\beta$-归约，则称其处于范式。\n\n设 $A$ 和 $B$ 为固定类型。假设变量 $u:A$ 和 $v:B$，并考虑项 $t \\equiv (\\lambda x.\\,\\lambda y.\\,x)\\,u\\,v$。仅使用上述关于类型、抽象、应用和 $\\beta$-归约的基本规则，计算 $t$ 的 $\\beta$-范式。然后，根据 Curry-Howard 对应，从蕴含的引入和消除的第一性原理出发，解释这个消除步骤对应于自然演绎中命题 $A \\to B \\to A$ 的哪一个证明的绕路（proof detour）。\n\n你的最终答案必须是代表 $t$ 的范式的单个封闭形式符号表达式。无需四舍五入，也无单位适用。", "solution": "首先将根据指定标准对问题陈述进行验证。\n\n### 步骤 1：提取已知条件\n- **系统**：简单类型 lambda 演算 (STLC)。\n- **类型构造**：类型由基类型和函数类型构造子 $\\to$ 构建。\n- **项构造**：项由变量、抽象 ($\\lambda x.\\,t$) 和应用 ($t\\,s$) 构建。\n- **Curry-Howard 对应 (CHC)**：\n    - 类型等同于命题。\n    - 项等同于证明。\n    - 类型为 $A \\to B$ 的项是命题 $A$ 蕴含命题 $B$ 的一个证明。\n    - 蕴含引入 ($\\to I$) 对应于抽象 ($\\lambda x.\\,t$)。\n    - 蕴含消除 ($\\to E$) 对应于应用 ($t\\,s$)。\n- **计算规则**：$\\beta$-归约定义为 $(\\lambda x.\\,t)\\,s \\to_{\\beta} t[x:=s]$，其中 $t[x:=s]$ 是将 $t$ 中所有 $x$ 的自由出现替换为 $s$。\n- **范式**：如果一个项不能再进行任何 $\\beta$-归约，则称其处于范式。\n- **给定类型**：$A$ 和 $B$ 是固定类型。\n- **给定变量**：$u$ 是类型为 $A$ 的变量 (即 $u:A$)，$v$ 是类型为 $B$ 的变量 (即 $v:B$)。\n- **待分析的项**：$t \\equiv (\\lambda x.\\,\\lambda y.\\,x)\\,u\\,v$。\n\n### 步骤 2：使用提取的已知条件进行验证\n对问题进行验证：\n- **科学性**：该问题完全位于数理逻辑和理论计算机科学的范畴内，特别涉及简单类型 lambda 演算和 Curry-Howard 对应。这些都是成熟的基础性课题。$\\beta$-归约、范式和自然演绎等概念都有严格的定义。该问题不违反任何科学或数学原理。\n- **良构性**：该问题要求进行一项特定的计算（求给定项的 $\\beta$-范式）和基于所提供框架的特定概念性解释。计算规则（$\\beta$-归约）是明确且确定性的，确保了唯一范式的存在（由于 STLC 的强规范化性质）。结构清晰，可以推导出唯一且有意义的解。\n- **客观性**：语言形式化且精确。“$\\beta$-范式”、“证明的绕路”和“自然演绎”等术语在此上下文中具有明确的含义。没有主观或基于意见的陈述。\n- **完整性**：该问题提供了所有必要的信息：要归约的项、所涉及变量的类型以及系统的基本规则（类型、归约）。它是自洽的。\n- **其他缺陷**：该问题不是隐喻性的、琐碎的、矛盾的或无法验证的。它是其领域内的一个标准练习。\n\n### 步骤 3：结论与行动\n问题是**有效的**。将提供完整的解决方案。\n\n### 解题推导\n该问题要求两部分：首先，计算项 $t \\equiv (\\lambda x.\\,\\lambda y.\\,x)\\,u\\,v$ 的 $\\beta$-范式；其次，根据 Curry-Howard 对应解释相应的逻辑现象。\n\n#### 第一部分：计算 $\\beta$-范式\n待归约的项是 $t \\equiv (\\lambda x.\\,\\lambda y.\\,x)\\,u\\,v$。在 lambda 演算中，应用是左结合的，因此该项被解析为 $((\\lambda x.\\,\\lambda y.\\,x)\\,u)\\,v$。\n\n归约分两步进行，应用规则 $(\\lambda z.\\,M)\\,N \\to_{\\beta} M[z:=N]$。\n\n**步骤 1：** 第一次归约应用于子项 $(\\lambda x.\\,\\lambda y.\\,x)\\,u$。\n这里，抽象是 $\\lambda x.\\,(\\lambda y.\\,x)$，参数是 $u$。根据 $\\beta$-归约规则，我们将抽象体 $\\lambda y.\\,x$ 中变量 $x$ 的所有自由出现都替换为项 $u$。\n$$ (\\lambda x.\\,\\lambda y.\\,x)\\,u \\to_{\\beta} (\\lambda y.\\,x)[x:=u] $$\n替换产生项 $\\lambda y.\\,u$。在这个新项中，$u$ 是类型为 $A$ 的项，而抽象是针对一个在 $u$ 中不自由出现的变量 $y$。\n\n第一次归约后，原项 $t$ 变为：\n$$ t \\to_{\\beta} (\\lambda y.\\,u)\\,v $$\n\n**步骤 2：** 第二次归约应用于结果项 $(\\lambda y.\\,u)\\,v$。\n这里，抽象是 $\\lambda y.\\,u$，参数是 $v$。我们将抽象体 $u$ 中变量 $y$ 的所有自由出现都替换为项 $v$。\n$$ (\\lambda y.\\,u)\\,v \\to_{\\beta} u[y:=v] $$\n根据问题陈述，$u$ 是类型为 $A$ 的变量。变量 $y$ 在项 $u$ 中不自由出现。因此，替换 $u[y:=v]$ 的结果是项 $u$ 本身。\n$$ u[y:=v] \\equiv u $$\n\n结合这些步骤，完整的归约序列是：\n$$ t \\equiv ((\\lambda x.\\,\\lambda y.\\,x)\\,u)\\,v \\to_{\\beta} (\\lambda y.\\,u)\\,v \\to_{\\beta} u $$\n项 $u$ 不包含任何可归约式（即，没有形如 $(\\lambda z.\\,M)\\,N$ 的子项），因此它处于 $\\beta$-范式。\n\n#### 第二部分：通过 Curry-Howard 对应进行解释\nCurry-Howard 对应在直觉主义逻辑中的命题与类型 lambda 演算中的类型之间建立了一种同构关系。证明对应于项。\n\n**项的类型推导**：我们来确定项 $t$ 的类型。\n1.  子项 $\\lambda x.\\,\\lambda y.\\,x$ 是命题 $A \\to (B \\to A)$ 的一个证明。为了说明这一点，我们在自然演绎中构造其证明：\n    - 假设 $x:A$（$A$ 的一个证明）。这是假设 $[A]^1$。\n    - 假设 $y:B$（$B$ 的一个证明）。这是假设 $[B]^2$。\n    - 在这些假设下，我们有 $x$，它是 $A$ 的一个证明。所以我们推导出了 $A$。\n    - 通过蕴含引入 ($\\to I$)，我们消除假设 $[B]^2$ 来得到结论 $B \\to A$。证明项是 $\\lambda y.\\,x$。\n    - 再次通过蕴含引入 ($\\to I$)，我们消除假设 $[A]^1$ 来得到结论 $A \\to (B \\to A)$。证明项是 $\\lambda x.\\,\\lambda y.\\,x$。\n\n2.  项是 $(\\lambda x.\\,\\lambda y.\\,x)\\,u\\,v$。我们有以下证明（项）和命题（类型）：\n    - $(\\lambda x.\\,\\lambda y.\\,x) : A \\to (B \\to A)$\n    - $u : A$\n    - $v : B$\n\n3.  应用 $(\\lambda x.\\,\\lambda y.\\,x)\\,u$ 对应于蕴含消除（$\\to E$，或称分离规则）。我们有一个 $A \\to (B \\to A)$ 的证明和一个 $A$ 的证明，因此可以得出结论 $B \\to A$。得到的证明项是 $(\\lambda x.\\,\\lambda y.\\,x)\\,u$。\n\n4.  最终的应用 $((\\lambda x.\\,\\lambda y.\\,x)\\,u)\\,v$ 是对 $\\to E$ 的另一次使用。我们从上一步得到了一个 $B \\to A$ 的证明，并且有一个 $B$ 的证明（项 $v$），因此我们得出结论 $A$。所以，整个项 $t$ 的类型是 $A$。这与我们的计算结果一致，因为其范式是 $u$，而 $u$ 的类型是 $A$。\n\n**证明的绕路**：在自然演绎中，“证明的绕路”（或称“切”）发生在一个联结词被引入后立即被消除的情况。对证明项进行 $\\beta$-归约的过程，恰好对应于在相关证明中消除这些绕路的过程，这个程序被称为规范化或切消。\n\n1.  **第一个绕路及其消除**：应用 $(\\lambda x.\\,\\lambda y.\\,x)\\,u$ 表示对 $A \\to (B \\to A)$ 中最外层蕴含的消除，而这个蕴含正是通过抽象 $\\lambda x$ 刚刚引入的。\n    - **引入**：我们假设了一个 $A$ 的假设性证明 $x$ 来构造一个 $B \\to A$ 的证明，然后泛化得到 $A \\to (B \\to A)$。\n    - **消除**：我们立即将这个一般性证明应用于一个 $A$ 的具体证明，即 $u$。\n    - **绕路**：这个绕路是这样的路径：假设 $A \\to$ 构造一个函数 $\\to$ 将该函数应用于一个 $A$ 的证明。\n    - **归约**：$\\beta$-归约 $(\\lambda x.\\,\\lambda y.\\,x)\\,u \\to_{\\beta} \\lambda y.\\,u$ 消除了这个绕路。在证明中，这对应于将占位符假设 $x$ 的每个实例替换为实际的证明 $u$。得到的证明对象 $\\lambda y.\\,u$ 是一个由 $u$ 构建的 $B \\to A$ 的直接证明。\n\n2.  **第二个绕路及其消除**：随后的应用 $(\\lambda y.\\,u)\\,v$ 代表了第二个绕路。\n    - **引入**：项 $\\lambda y.\\,u$ 构造了 $B \\to A$ 的一个证明。这是通过假设一个 $B$ 的证明 $y$ 然后证明 $A$ 来完成的。然而，$A$ 的证明（即 $u$）根本不依赖于假设 $y:B$。这被称为空洞消除（vacuous discharge）。\n    - **消除**：然后我们立即将这个构造应用于一个 $B$ 的具体证明，即 $v$。\n    - **绕路**：这个绕路是：空洞地假设 $B \\to$ 构造一个 $B \\to A$ 的证明 $\\to$ 将其应用于一个 $B$ 的证明。\n    - **归约**：$\\beta$-归约 $(\\lambda y.\\,u)\\,v \\to_{\\beta} u$ 消除了这个绕路。从逻辑上讲，如果从假设 $B$ 得出结论 $A$ 的证明实际上从未使用过假设 $B$，那么给定一个 $B$ 的具体证明就是无关紧要的。证明简化为 $A$ 的原始证明，这正是项 $u$ 所代表的。所提供的证明 $v$ 被丢弃了。\n\n总而言之，$\\beta$-归约的序列反映了相应自然演绎证明的简化过程。与 $t$ 对应的初始证明是证明 $A$ 的一种复杂且间接的方式。它涉及到创建一般性规则（$A \\to (B \\to A)$），然后应用它们。规范化过程移除了这些中间的引入-消除步骤，表明在给定初始数据（$u:A$, $v:B$）的情况下，证明 $A$ 的最直接方式就是 $u$ 本身。", "answer": "$$ \\boxed{u} $$", "id": "2985657"}, {"introduction": "在建立了蕴含的对应关系之后，我们现在将理解扩展到逻辑合取（$ \\land $）及其类型论中的对应物——积类型。这个练习 [@problem_id:2985694] 将引导你体验另一次作为计算的证明正规化过程，这次它涉及构建一个序对（pair）并立即投影（project）其组件之一。通过这个练习，你会巩固这样一个观念：每一种逻辑联结词都有其相应的计算行为。", "problem": "在带有二元积的简单类型 lambda 演算（STLC）中进行操作，其中积的引入写作 $\\langle u,v\\rangle$，积的消除分别写作第一投影 $\\pi_{1}$ 和第二投影 $\\pi_{2}$。在 Curry–Howard 对应（CH）下，类型对应于命题，项对应于证明，函数类型 $A \\rightarrow B$ 对应于蕴涵，积类型 $A \\times B$ 对应于合取。令 $A$ 为任意类型，令 $t$ 为类型 $A$ 的一个变量。考虑带类型的项\n$$\n(\\lambda x\\!:\\!A.\\,\\pi_{1}\\langle x, x\\rangle)\\,t.\n$$\n使用 STLC 中带积的标准计算规则计算其 $\\beta$-范式，然后根据 Curry–Howard 对应，解释为何此计算对应于逻辑中合取的一个冗余的引入-消除对的消除。你的最终答案必须是一个单一的封闭形式符号表达式。", "solution": "该问题是有效的，因为它在简单类型 lambda 演算（STLC）和 Curry–Howard 对应的既定形式体系中是良构的。\n\n任务包含两部分：首先，计算给定带类型项的 $\\beta$-范式；其次，根据 Curry–Howard 对应解释此计算的逻辑意义。\n\n首先，我们计算项 $(\\lambda x\\!:\\!A.\\,\\pi_{1}\\langle x, x\\rangle)\\,t$ 的范式。此表达式是一个 lambda 抽象应用于一个项，构成了一个 $\\beta$-可归约式（redex）。$\\beta$-归约的标准规则是 $(\\lambda v\\!:\\!T.\\,M)\\,N \\rightarrow_{\\beta} M[N/v]$，其中 $M[N/v]$ 表示将项 $N$ 以避免捕获的方式替换项 $M$ 中变量 $v$ 的所有自由出现。\n\n将此规则应用于给定的项：\n令 lambda 抽象的主体为 $M = \\pi_{1}\\langle x, x\\rangle$，参数为 $N = t$。\n归约过程如下：\n$$\n(\\lambda x\\!:\\!A.\\,\\pi_{1}\\langle x, x\\rangle)\\,t \\rightarrow_{\\beta} (\\pi_{1}\\langle x, x\\rangle)[t/x]\n$$\n在表达式 $\\pi_{1}\\langle x, x\\rangle$ 中用 $t$ 替换 $x$ 得到：\n$$\n(\\pi_{1}\\langle x, x\\rangle)[t/x] = \\pi_{1}\\langle t, t\\rangle\n$$\n结果项 $\\pi_{1}\\langle t, t\\rangle$ 涉及到一个积的消除（通过投影 $\\pi_{1}$），它作用于一个积的引入（对偶构造 $\\langle \\cdot, \\cdot \\rangle$）。这是一个积归约规则的可归约式。STLC 中投影的计算规则是：\n1. $\\pi_{1}\\langle u, v \\rangle \\rightarrow u$\n2. $\\pi_{2}\\langle u, v \\rangle \\rightarrow v$\n\n将第一条规则应用于我们的项，其中 $u$ 是 $t$，$v$ 也是 $t$：\n$$\n\\pi_{1}\\langle t, t \\rangle \\rightarrow t\n$$\n项 $t$ 是一个变量，不包含任何其他可归约式。因此，它处于范式。完整的归约序列是：\n$$\n(\\lambda x\\!:\\!A.\\,\\pi_{1}\\langle x, x\\rangle)\\,t \\rightarrow_{\\beta} \\pi_{1}\\langle t, t\\rangle \\rightarrow t\n$$\n给定项的 $\\beta$-范式是 $t$。\n\n其次，我们根据 Curry–Howard 对应来解释此计算的逻辑意义。此对应在形式证明系统（如自然演绎法）和计算模型（如 lambda 演算）之间建立了一个直接的同构关系。\n在此对应下：\n- 类型，如 $A$，对应于逻辑命题，也记作 $A$。\n- 给定类型的项，如类型为 $A$ 的变量 $t$，对应于该命题的一个证明。因此，$t:A$ 代表 $A$ 的一个证明。在此上下文中，$t$ 可以被看作是一个公理或一个未被消除的假设，即 $A$ 为真。\n- 积类型 $A \\times B$ 对应于逻辑合取 $A \\wedge B$。\n- 积引入项 $\\langle u, v \\rangle$ 对应于合取引入规则（$\\wedge$-intro）。如果 $u$ 是 $A$ 的一个证明，$v$ 是 $B$ 的一个证明，那么 $\\langle u, v \\rangle$ 就是 $A \\wedge B$ 的一个证明。\n- 积消除项 $\\pi_{1}$ 和 $\\pi_{2}$ 对应于合取消除规则（$\\wedge$-elim）。如果 $w$ 是 $A \\wedge B$ 的一个证明，那么 $\\pi_{1}w$ 是 $A$ 的一个证明，而 $\\pi_{2}w$ 是 $B$ 的一个证明。\n\n让我们在这个逻辑背景下分析局部归约步骤 $\\pi_{1}\\langle t, t \\rangle \\rightarrow t$。\n1. 项 $t$ 代表命题 $A$ 的一个给定证明。\n2. 项 $\\langle t, t \\rangle$ 的类型是 $A \\times A$。在逻辑上，它代表命题 $A \\wedge A$ 的一个证明。这个证明是通过将 $\\wedge$-引入规则应用于 $A$ 的证明 $t$ 的两个副本来构造的。\n3. 项 $\\pi_{1}\\langle t, t \\rangle$ 的类型是 $A$。它对应于将左 $\\wedge$-消除规则应用于 $A \\wedge A$ 的证明 $\\langle t, t \\rangle$，以推导出第一个合取项 $A$ 的证明。\n\n逻辑步骤的序列如下：\n- 我们从 $A$ 的一个证明 $t$ 开始：\n$$ t \\vdash A $$\n- 我们使用 $\\wedge$-引入来构造 $A \\wedge A$ 的一个证明：\n$$ \\frac{t \\vdash A \\quad t \\vdash A}{ \\langle t, t \\rangle \\vdash A \\wedge A } \\quad (\\wedge\\text{-intro}) $$\n- 然后我们立即使用 $\\wedge$-消除再次获得 $A$ 的一个证明：\n$$ \\frac{ \\langle t, t \\rangle \\vdash A \\wedge A }{ \\pi_{1}\\langle t, t \\rangle \\vdash A } \\quad (\\wedge\\text{-elim}) $$\n\n在证明论中，这种一个引入规则紧跟着同一个逻辑联结词的相应消除规则的序列被称为“绕路”（detour）或冗余步骤。证明规范化过程通过移除此类绕路来简化证明。$A$ 的结果证明 $\\pi_{1}\\langle t, t \\rangle$ 是不必要地复杂的，因为原始证明 $t$ 已经可用。\n\n计算归约 $\\pi_{1}\\langle t, t \\rangle \\rightarrow t$ 是此证明规范化步骤的直接类比。它消除了合取的冗余引入-消除对，将复杂的证明 $\\pi_{1}\\langle t, t \\rangle$ 简化为原始的、直接的证明 $t$。完整的计算 $(\\lambda x\\!:\\!A.\\,\\pi_{1}\\langle x, x\\rangle)\\,t \\rightarrow t$ 将这一原则嵌入到一个函数式上下文中，其中 $\\beta$-归约首先将特定的证明 $t$ 代入一个通用的证明模式，之后发生联结词引入/消除的核心简化。", "answer": "$$\n\\boxed{t}\n$$", "id": "2985694"}, {"introduction": "现在，我们从命题逻辑推进到内容更丰富的一阶谓词逻辑。这个问题 [@problem_id:2985606] 引入了全称量化（$ \\forall x $）与依赖函数类型（$ \\Pi $）之间的对应关系，这是现代类型论中最强大的思想之一。你将为一个全称量化的命题构造一个证明，然后通过一个具体的计算模型，将这些抽象概念落到实处，从而加深对逻辑、编程与数学之间深层统一性的理解。", "problem": "在 Curry–Howard 同构的框架下，依赖函数类型 $\\Pi_{x:A}B(x)$ 对应于全称量化 $\\forall x:A.\\,B(x)$，二元积类型 $B \\times C$ 对应于合取 $B \\land C$，而普通函数类型 $B \\to C$ 对应于蕴含 $B \\Rightarrow C$。在一个积和依赖积为基本构造的依赖类型论中，请按如下步骤进行：\n\n1. 仅使用积和依赖积的引入规则与消去规则，显式地构造一个（作为完全类型的 $\\lambda$-项的）典范前向映射，该映射见证了以下类型：\n$$\n\\bigl(\\Pi_{x:A}\\,\\bigl(P(x) \\times Q(x)\\bigr)\\bigr) \\to \\bigl(\\Pi_{x:A}P(x)\\bigr) \\times \\bigl(\\Pi_{x:A}Q(x)\\bigr).\n$$\n你的构造必须从类型规则的第一性原理出发进行论证。\n\n2. 通过 Curry–Howard 同构，解释为什么你构造的项实现了以下逻辑蕴含：\n$$\n\\forall x.\\,\\bigl(P \\land Q\\bigr) \\;\\Rightarrow\\; \\bigl(\\forall x.\\,P\\bigr) \\land \\bigl(\\forall x.\\,Q\\bigr).\n$$\n你的解释应仅引用该同构的基本对应关系以及所涉及类型的形成、引入和消去原则。\n\n3. 现在，在标准的集合论模型中解释这些类型，其中类型是集合，项是元素，$B \\times C$ 是笛卡尔积，而 $\\Pi_{x \\in A}B(x)$ 是所有选择函数 $f$ 的集合，其中对每个 $x \\in A$ 都有 $f(x) \\in B(x)$。设 $A = \\{a_1,a_2,a_3\\}$ 是一个包含三个元素的有限集，并假设各个纤维的基数如下：\n$$\n|P(a_1)| = 2,\\quad |P(a_2)| = 1,\\quad |P(a_3)| = 5,\\qquad |Q(a_1)| = 3,\\quad |Q(a_2)| = 4,\\quad |Q(a_3)| = 2.\n$$\n计算以下依赖函数空间的确切基数：\n$$\n\\Pi_{x \\in A}\\bigl(P(x) \\times Q(x)\\bigr).\n$$\n给出你的最终答案，形式为一个整数。不要四舍五入。", "solution": "该问题是有效的，因为它科学地基于数理逻辑和依赖类型论的既定原则，问题表述清晰、客观且内部一致。\n\n问题分为三个部分。我们将依次解决每个部分。\n\n### 第一部分：$\\lambda$-项的构造\n\n我们被要求构造一个居于以下类型的项：\n$$\n\\bigl(\\Pi_{x:A}\\,\\bigl(P(x) \\times Q(x)\\bigr)\\bigr) \\to \\bigl(\\Pi_{x:A}P(x)\\bigr) \\times \\bigl(\\Pi_{x:A}Q(x)\\bigr).\n$$\n这是一个函数类型，具体来说是一个形如 $B \\to C$ 的非依赖函数类型，其中 $B = \\Pi_{x:A}(P(x) \\times Q(x))$ 且 $C = (\\Pi_{x:A}P(x)) \\times (\\Pi_{x:A}Q(x))$。\n\n函数类型 $B \\to C$ 的引入规则是 $\\lambda$-抽象。要构造此类型的项，我们假设一个变量（比如 $f$），其类型为定义域类型 $B$，然后构造一个余域类型 $C$ 中的项。\n设 $f$ 是一个类型为 $\\Pi_{x:A}\\,(P(x) \\times Q(x))$ 的变量。我们的目标是构造一个类型为 $(\\Pi_{x:A}P(x)) \\times (\\Pi_{x:A}Q(x))$ 的项。\n$$\n\\lambda f : \\Pi_{x:A}\\,(P(x) \\times Q(x)).\\; (\\text{目标项的类型为 } (\\Pi_{x:A}P(x)) \\times (\\Pi_{x:A}Q(x)))\n$$\n目标类型是一个积类型。积类型 $C_1 \\times C_2$ 的引入规则是构造一个对 $\\langle t_1, t_2 \\rangle$，其中 $t_1$ 的类型为 $C_1$，$t_2$ 的类型为 $C_2$。这里，$C_1 = \\Pi_{x:A}P(x)$ 且 $C_2 = \\Pi_{x:A}Q(x)$。\n所以，我们的目标项必须具有形式 $\\langle \\text{项}_1, \\text{项}_2 \\rangle$，其中：\n- $\\text{项}_1$ 的类型为 $\\Pi_{x:A}P(x)$。\n- $\\text{项}_2$ 的类型为 $\\Pi_{x:A}Q(x)$。\n\n让我们来构造 $\\text{项}_1$。类型 $\\Pi_{x:A}P(x)$ 是一个依赖函数类型。此类型的引入规则同样是 $\\lambda$-抽象。我们必须构造一个函数，它接受一个类型为 $A$ 的项 $x$，并返回一个类型为 $P(x)$ 的项。\n设 $x$ 是一个类型为 $A$ 的变量。我们的目标是利用已有的假设 $f : \\Pi_{x:A}\\,(P(x) \\times Q(x))$ 来构造一个类型为 $P(x)$ 的项。\n$$\n\\text{项}_1 = \\lambda x:A.\\; (\\text{目标项的类型为 } P(x))\n$$\n依赖函数类型 $\\Pi$ 的消去规则是函数应用。因为 $f$ 的类型是 $\\Pi_{x:A}\\,(P(x) \\times Q(x))$ 且 $x$ 的类型是 $A$，所以我们可以将 $f$ 应用于 $x$。得到的项，我们记为 $f(x)$ 或 $f\\,x$，其类型为 $P(x) \\times Q(x)$。\n类型 $P(x) \\times Q(x)$ 是一个积类型。积类型的消去规则是投影 $\\pi_1$ 和 $\\pi_2$。\n将第一个投影 $\\pi_1$ 应用于项 $f(x)$，得到一个类型为 $P(x)$ 的项 $\\pi_1(f(x))$。这正是我们内部 lambda 表达式体所需要的。\n因此，$\\text{项}_1 = \\lambda x:A.\\; \\pi_1(f(x))$。\n\n现在，我们来构造 $\\text{项}_2$。过程是对称的。其类型为 $\\Pi_{x:A}Q(x)$。我们再次使用 $\\lambda$-引入。设 $x$ 是一个类型为 $A$ 的变量。我们需要构造一个类型为 $Q(x)$ 的项。\n$$\n\\text{项}_2 = \\lambda x:A.\\; (\\text{目标项的类型为 } Q(x))\n$$\n和之前一样，我们有 $f : \\Pi_{x:A}\\,(P(x) \\times Q(x))$ 和 $x : A$，所以 $f(x)$ 的类型为 $P(x) \\times Q(x)$。将第二个投影 $\\pi_2$ 应用于 $f(x)$，得到一个类型为 $Q(x)$ 的项 $\\pi_2(f(x))$。\n因此，$\\text{项}_2 = \\lambda x:A.\\; \\pi_2(f(x))$。\n\n将这些部分组合起来，最终的 $\\lambda$-项是通过在对 $f$ 的初始 $\\lambda$-抽象内部将 $\\text{项}_1$ 和 $\\text{项}_2$ 配对来构造的。\n完整的项是：\n$$\n\\lambda f : \\Pi_{x:A}\\,(P(x) \\times Q(x)).\\; \\langle \\lambda x:A.\\; \\pi_1(f(x)), \\lambda x:A.\\; \\pi_2(f(x)) \\rangle\n$$\n该项具有所需的类型，并且完全是根据指定的引入和消去规则构造的。\n\n### 第二部分：通过 Curry–Howard 同构的逻辑解释\n\nCurry–Howard 同构在直觉主义逻辑中的命题与合适的类型论中的类型之间建立了一个直接的同构关系。在此对应关系下：\n- 一个类型有居留（即存在该类型的项），当且仅当其对应的命题是可证明的。\n- 居于某个类型中的项是其对应命题的一个证明。\n- 函数类型 $B \\to C$ 对应于逻辑蕴含 $B \\Rightarrow C$。\n- 积类型 $B \\times C$ 对应于逻辑合取 $B \\land C$。\n- 依赖函数类型 $\\Pi_{x:A}B(x)$ 对应于全称量化 $\\forall x:A.\\,B(x)$。\n\n让我们将第一部分中的类型翻译成一个逻辑命题。\n- 参数的类型 $\\Pi_{x:A}\\,(P(x) \\times Q(x))$ 对应于命题 $\\forall x:A.\\,(P(x) \\land Q(x))$。\n- 结果的第一分量的类型 $\\Pi_{x:A}P(x)$ 对应于 $\\forall x:A.\\,P(x)$。\n- 结果的第二分量的类型 $\\Pi_{x:A}Q(x)$ 对应于 $\\forall x:A.\\,Q(x)$。\n- 这两者的积 $(\\Pi_{x:A}P(x)) \\times (\\Pi_{x:A}Q(x))$ 对应于合取 $(\\forall x:A.\\,P(x)) \\land (\\forall x:A.\\,Q(x))$。\n- 最后，第一部分中的完整函数类型对应于蕴含：\n$$\n\\bigl(\\forall x:A.\\,(P(x) \\land Q(x))\\bigr) \\Rightarrow \\bigl((\\forall x:A.\\,P(x)) \\land (\\forall x:A.\\,Q(x))\\bigr).\n$$\n这与所提供的逻辑公式相匹配。第一部分构造的 $\\lambda$-项是此命题的一个证明对象。让我们追踪该项结构所反映的证明步骤。\n\n1.  **蕴含引入($\\Rightarrow_I$)**: 最外层的 `λf : ...` 对应于假设蕴含的前件。我们假设有一个 $\\forall x:A.\\,(P(x) \\land Q(x))$ 的证明 $f$。\n\n2.  **合取引入($\\land_I$)**: 对构造子 $\\langle \\dots, \\dots \\rangle$ 对应于证明一个合取的目标。为了证明主后件，我们必须分别证明它的两个合取项：(i) $\\forall x:A.\\,P(x)$ 和 (ii) $\\forall x:A.\\,Q(x)$。\n\n3.  **证明第一个合取项 $\\forall x:A.\\,P(x)$**：\n    - **全称引入($\\forall_I$)**: 项 $\\lambda x:A.\\; \\dots$ 对应于从论域 $A$ 中引入一个任意元素 $x$，并为它证明 $P(x)$。\n    - **全称消去($\\forall_E$)**: 项 $f(x)$ 对应于将我们的初始假设（即 $\\forall x:A.\\,(P(x) \\land Q(x))$ 的证明 $f$）应用于特定的任意元素 $x$。这给了我们一个 $P(x) \\land Q(x)$ 的证明。\n    - **合取消去($\\land_E$)**: 项 $\\pi_1(f(x))$ 对应于消去合取 $P(x) \\land Q(x)$ 以获得其左侧项 $P(x)$ 的证明。这完成了对任意 $x$ 的证明。\n\n4.  **证明第二个合取项 $\\forall x:A.\\,Q(x)$**：\n    - 推理过程是对称的。项 $\\lambda x:A.\\; \\pi_2(f(x))$ 对应于一个 $\\forall x:A.\\,Q(x)$ 的证明，该证明通过假设一个任意的 $x:A$，实例化全称假设以得到 $P(x) \\land Q(x)$，然后消去合取以得到 $Q(x)$。\n\n这个 $\\lambda$-项的结构是对该逻辑蕴含的自然演绎证明的一个形式化编码。构造该项时使用的每个类型论规则（引入/消去）都精确地对应于一个逻辑推理规则。\n\n### 第三部分：基数计算\n\n在集合论模型中：\n- 类型被解释为集合。\n- 积类型 $B \\times C$ 被解释为集合 $B$ 和 $C$ 的笛卡尔积。其基数为 $|B \\times C| = |B| \\times |C|$。\n- 依赖函数类型 $\\Pi_{x \\in A} B(x)$ 被解释为所有定义域为 $A$ 的函数 $f$ 的集合，使得对每个 $x \\in A$ 都有 $f(x) \\in B(x)$。这是集合族 $\\{B(x)\\}_{x \\in A}$ 的广义笛卡尔积。\n\n这样一个依赖函数空间（或广义笛卡尔积）的基数是该族中各个集合基数的乘积：\n$$\n\\left| \\Pi_{x \\in A} B(x) \\right| = \\prod_{x \\in A} |B(x)|.\n$$\n我们被要求计算类型 $\\Pi_{x \\in A}(P(x) \\times Q(x))$ 的基数。在集合论模型中，这对应于选择函数的集合，其中对于每个 $x \\in A$，其上的纤维是集合 $P(x) \\times Q(x)$。\n\n因此，基数为：\n$$\n\\left| \\Pi_{x \\in A}\\bigl(P(x) \\times Q(x)\\bigr) \\right| = \\prod_{x \\in A} |P(x) \\times Q(x)|.\n$$\n使用笛卡尔积的基数法则，我们有 $|P(x) \\times Q(x)| = |P(x)| \\times |Q(x)|$。所以，总基数为：\n$$\n\\prod_{x \\in A} \\bigl(|P(x)| \\times |Q(x)|\\bigr).\n$$\n给定集合 $A = \\{a_1, a_2, a_3\\}$。乘积在 $A$ 的元素上展开：\n$$\n\\bigl(|P(a_1)| \\times |Q(a_1)|\\bigr) \\times \\bigl(|P(a_2)| \\times |Q(a_2)|\\bigr) \\times \\bigl(|P(a_3)| \\times |Q(a_3)|\\bigr).\n$$\n我们被给予了以下基数：\n- $|P(a_1)| = 2$, $|Q(a_1)| = 3$\n- $|P(a_2)| = 1$, $|Q(a_2)| = 4$\n- $|P(a_3)| = 5$, $|Q(a_3)| = 2$\n\n将这些值代入表达式中：\n- 当 $x = a_1$ 时：$|P(a_1)| \\times |Q(a_1)| = 2 \\times 3 = 6$。\n- 当 $x = a_2$ 时：$|P(a_2)| \\times |Q(a_2)| = 1 \\times 4 = 4$。\n- 当 $x = a_3$ 时：$|P(a_3)| \\times |Q(a_3)| = 5 \\times 2 = 10$。\n\n总基数是这些结果的乘积：\n$$\n6 \\times 4 \\times 10 = 24 \\times 10 = 240.\n$$\n依赖函数空间 $\\Pi_{x \\in A}(P(x) \\times Q(x))$ 的基数是 $240$。", "answer": "$$\\boxed{240}$$", "id": "2985606"}]}