{"hands_on_practices": [{"introduction": "理论的价值在于实践。本节我们将通过一系列动手练习，深化对克雷格内插定理的理解。第一个练习将引导我们使用一种基于证明的经典算法——麦克米兰（McMillan）内插提取算法。我们将从一个命题逻辑公式的归结反驳（resolution refutation）入手，一步步地构造出内插式，这个过程直观地揭示了内插式是如何从蕴含关系的证明中“提取”出来的 [@problem_id:2971043]。", "problem": "设 $\\mathcal{L}$ 是一个命题词汇表，划分为三个不相交的变量集：双方共有的符号集 $S$、左侧局部符号集 $L_{A}$ 和右侧局部符号集 $L_{B}$。考虑以下用于克雷格内插定理 (CIT) 的实例。设 $S=\\{s\\}$，$L_{A}=\\{a,b\\}$，且 $L_{B}=\\varnothing$。定义\n- 左侧公式 $A$ 为子句 $(s\\lor a)$、$(s\\lor b)$ 和 $(\\lnot a\\lor\\lnot b)$ 的合取，\n- 右侧公式 $B$ 为单个文字 $s$。\n您将处理合取式 $A\\land\\lnot B$，并使用归结规则证明其不可满足性，然后对该归结证明执行 McMillan 风格的插值提取。\n\n仅使用命题逻辑和归结规则的基本定律与核心定义，不借助任何快捷公式，请执行以下操作：\n1. 将 $A\\land\\lnot B$ 转换为子句形式，并为 $A\\land\\lnot B$ 构建一个完整的归结反驳（推导出空子句）。\n2. 沿着您的归结证明执行 McMillan 风格的插值提取，并遵循符号划分 $S=\\{s\\}$、$L_{A}=\\{a,b\\}$ 和 $L_{B}=\\varnothing$。在每一步中，明确指出与每个初始子句和每个归结式相关联的内插式，并根据中心变量的类别（公共、$A$-局部或 $B$-局部）来证明您所使用的组合规则的合理性。\n3. 提供最终的内插式，它应是一个仅基于共享词汇表 $S$ 的闭式命题公式，并尽可能简化。\n\n您的最终答案必须是单一的闭式符号表达式（没有等式或不等式）。不需要进行数值舍入。使用标准的 LaTeX 命题连接词来表达最终的内插式。", "solution": "该问题要求通过对 $A \\land \\lnot B$ 进行归结反驳来为给定的蕴含式 $A \\implies B$ 推导克雷格内插式。我们将遵循指定的步骤：首先，构建一个归结证明；其次，应用 McMillan 风格的算法从证明中提取内插式。\n\n问题定义的逻辑上下文如下：\n命题词汇表 $\\mathcal{L}$ 被划分为三个不相交的集合：\n- 共享符号集 $S = \\{s\\}$。\n- 公式 $A$ 的局部符号集 $L_A = \\{a, b\\}$。\n- 公式 $B$ 的局部符号集 $L_B = \\varnothing$。\n\n公式 $A$ 和 $B$ 定义如下：\n- $A \\equiv (s \\lor a) \\land (s \\lor b) \\land (\\lnot a \\lor \\lnot b)$。\n- $B \\equiv s$。\n\n克雷格内插定理指出，如果 $A \\implies B$ 是一个有效的蕴含式，那么存在一个内插式 $I$，使得：\n1. $A \\implies I$ 是有效的。\n2. $I \\implies B$ 是有效的。\n3. $I$ 中的变量是共享词汇表的子集，即 $\\text{Var}(I) \\subseteq \\text{Var}(A) \\cap \\text{Var}(B) = S$。\n\n为了找到这样一个内插式，我们首先证明 $A \\land \\lnot B$ 存在一个归结反驳，这等价于证明 $A \\implies B$ 是一个重言式。\n\n**第 1 部分：$A \\land \\lnot B$ 的归结反驳**\n\n待反驳的公式是 $A \\land \\lnot B$。我们将其转换为子句形式（合取范式）。\n来自 $A$ 的子句是：\n$C_1: \\{s, a\\}$\n$C_2: \\{s, b\\}$\n$C_3: \\{\\lnot a, \\lnot b\\}$\n\n公式 $\\lnot B$ 是 $\\lnot s$。对应的子句是：\n$C_4: \\{\\lnot s\\}$\n\n$A \\land \\lnot B$ 的子句集合是 $\\{C_1, C_2, C_3, C_4\\}$。现在我们使用归结规则 $\\text{Res}(C_i, C_j, p) = (C_i \\setminus \\{p\\}) \\cup (C_j \\setminus \\{\\lnot p\\})$ 来推导空子句（记作 $\\bot$）。我们构建一个首先消去 $L_A$ 中局部变量的证明。\n\n1.  对 $C_1 = \\{s, a\\}$ 和 $C_3 = \\{\\lnot a, \\lnot b\\}$ 以中心变量 $a$ 进行归结：\n    $C_5 = \\text{Res}(C_1, C_3, a) = \\{s, \\lnot b\\}$。\n\n2.  对 $C_2 = \\{s, b\\}$ 和新推导出的子句 $C_5 = \\{s, \\lnot b\\}$ 以中心变量 $b$ 进行归结：\n    $C_6 = \\text{Res}(C_2, C_5, b) = \\{s, s\\} = \\{s\\}$。\n\n3.  对 $C_6 = \\{s\\}$ 和 $C_4 = \\{\\lnot s\\}$ 以中心变量 $s$ 进行归结：\n    $C_7 = \\text{Res}(C_6, C_4, s) = \\{\\} = \\bot$。\n\n空子句 $\\bot$ 的推导构成了一个有效的归结反驳。这证实了 $A \\land \\lnot B$ 是不可满足的，因此内插式存在。\n\n**第 2 部分：McMillan 风格的内插提取**\n\n现在我们将 McMillan 风格的算法应用于上面生成的归结证明。对于证明中的每个子句 $C$（包括初始子句和派生子句），我们计算一个基于共享词汇表 $S = \\{s\\}$ 的部分内插式 $I(C)$。\n\n计算内插式的规则如下：\n\n- **初始化：**\n    1. 对于任何从 $A$ 推导出的初始子句 $C$，其内插式 $I(C)$ 是 $C$ 中所有变量属于共享集 $S$ 的文字的析取。如果不存在这样的文字，则内插式为 $\\bot$（假）。\n    2. 对于任何从 $\\lnot B$ 推导出的初始子句 $C$，其内插式为 $\\top$（真）。\n\n- **归结步骤中的组合：**\n    设 $C = \\text{Res}(C_i, C_j, p)$，其中 $p$ 是中心变量。\n    1. 如果 $p \\in L_A$（中心变量是 $A$-局部的），则新的内插式是 $I(C) = I(C_i) \\lor I(C_j)$。\n    2. 如果 $p \\in L_B$（中心变量是 $B$-局部的），则新的内插式是 $I(C) = I(C_i) \\land I(C_j)$。在本问题中，$L_B = \\varnothing$，所以这种情况不会发生。\n    3. 如果 $p \\in S$（中心变量是共享的），则新的内插式是 $I(C) = I(C_i) \\land I(C_j)$。当一个父子句纯粹从 $A$-子句推导而来，而另一个从 $B$-子句推导而来时，此简化规则适用。\n\n我们现在沿着归结证明追踪内插式：\n\n- **初始子句的内插式：**\n    - $C_1 = \\{s, a\\}$ 来自 $A$。共享文字是 $s$。\n      $I(C_1) = s$。\n    - $C_2 = \\{s, b\\}$ 来自 $A$。共享文字是 $s$。\n      $I(C_2) = s$。\n    - $C_3 = \\{\\lnot a, \\lnot b\\}$ 来自 $A$。它不包含共享文字。\n      $I(C_3) = \\bot$。\n    - $C_4 = \\{\\lnot s\\}$ 来自 $\\lnot B$。\n      $I(C_4) = \\top$。\n\n- **派生子句的内插式：**\n\n    - **步骤 1：** $C_5 = \\text{Res}(C_1, C_3, a)$。\n      - 中心变量是 $a$。由于 $a \\in L_A = \\{a, b\\}$，这是一个 $A$-局部中心变量。\n      - 我们使用规则 $I(C_5) = I(C_1) \\lor I(C_3)$。\n      - $I(C_5) = s \\lor \\bot \\equiv s$。\n\n    - **步骤 2：** $C_6 = \\text{Res}(C_2, C_5, b)$。\n      - 中心变量是 $b$。由于 $b \\in L_A = \\{a, b\\}$，这是一个 $A$-局部中心变量。\n      - 我们使用规则 $I(C_6) = I(C_2) \\lor I(C_5)$。\n      - $I(C_6) = s \\lor s \\equiv s$。\n\n    - **步骤 3：** $C_7 = \\bot = \\text{Res}(C_6, C_4, s)$。\n      - 中心变量是 $s$。由于 $s \\in S = \\{s\\}$，这是一个共享中心变量。\n      - 父子句是 $C_6$（纯粹从 $A$-子句推导而来）和 $C_4$（一个 $\\lnot B$-子句）。\n      - 我们使用规则 $I(C_7) = I(C_6) \\land I(C_4)$。\n      - $I(\\bot) = s \\land \\top \\equiv s$。\n\n**第 3 部分：最终内插式**\n\n蕴含式 $A \\implies B$ 的内插式是为空子句计算出的内插式，即 $I(\\bot)$。\n因此，最终的内插式是 $I = s$。\n\n我们验证 $I=s$ 是一个有效的内插式：\n1.  $\\text{Var}(I) = \\{s\\}$，它是共享词汇表 $S = \\{s\\}$ 的一个子集。此条件成立。\n2.  $A \\implies I$ 必须是有效的。这意味着 $A \\land \\lnot I$ 必须是不可满足的。$A \\land \\lnot s \\equiv ((s \\lor a) \\land (s \\lor b) \\land (\\lnot a \\lor \\lnot b)) \\land \\lnot s$。如果 $s$ 为假，该式简化为 $(a) \\land (b) \\land (\\lnot a \\lor \\lnot b)$，这是一个矛盾。因此，$A \\implies s$ 是有效的。\n3.  $I \\implies B$ 必须是有效的。即 $s \\implies s$，这是一个平凡的重言式。\n\n推导出的公式 $s$ 满足给定实例的克雷格内插的所有性质。它已经处于其最简形式。", "answer": "$$\\boxed{s}$$", "id": "2971043"}, {"introduction": "除了从证明中构造内插式，我们还可以从语义角度出发。这个练习将介绍一种使用存在量词（existential quantification）来构造内插式的强大方法。通过将公式中的局部变量（local variables）存在量化，我们可以将其“投影”到共享词汇表（shared vocabulary）上，从而直接得到一个满足内插条件的公式 [@problem_id:2971064]。这种方法不仅在理论上十分优雅，也为理解内插与可定义性（definability）之间的深刻联系提供了窗口。", "problem": "设 $X$ 和 $Y$ 是独立生成的有限命题变量集合，可能有重叠 $X \\cap Y \\neq \\varnothing$。考虑命题公式 $A$（仅含来自 $X$ 的变量）和 $B$（仅含来自 $Y$ 的变量），并带有语义假设 $A \\Rightarrow B$ 是有效的（即，对于变量并集的所有真值赋值，只要 $A$ 为真， $B$ 也为真）。命题逻辑中的 Craig 内插定理断言，存在一个内插式 $I$，它只包含来自 $X \\cap Y$ 的变量，并且满足 $A \\Rightarrow I$ 和 $I \\Rightarrow B$。仅使用命题逻辑的真值函数语义和命题存在量词的语义定义，证明公式 $I := \\exists(X \\setminus Y)\\, A$ 是一个内插式，并论证 $I$ 只提及 $X \\cap Y$ 中的变量。此处，对于一个命题变量 $v$，存在量化定义为 $\\exists v\\, \\varphi := \\varphi[v:=\\top] \\lor \\varphi[v:=\\bot]$，对于一个变量集合 $V$，$\\exists V\\, \\varphi$ 表示以任意顺序对 $V$ 中所有变量的迭代消去。\n\n然后，对于具体的合取范式 (CNF) 实例（合取范式 (CNF) 是文字析取的合取），其中\n- $X = \\{p, q, r\\}$ 和 $Y = \\{q, s\\}$，所以 $X \\cap Y = \\{q\\}$，\n- $A$ 由 CNF $A := (\\neg p \\lor q) \\land (\\neg r \\lor q) \\land (p \\lor r)$ 给出，\n- $B$ 由 $B := q$ 给出，\n\n执行以下操作：\n- 通过生成 $A \\land \\neg B$ 的归结反驳来验证 $A \\Rightarrow B$。\n- 通过执行存在消去，显式计算内插式 $I := \\exists\\{p,r\\}\\, A$，并将结果公式简化为仅在 $q$ 上的逻辑等价公式。\n\n将您的最终答案表示为仅使用变量 $q$ 的单个封闭形式命题公式。无需四舍五入。您的最终答案必须是计算出的最简逻辑形式的内插式 $I$。", "solution": "问题包含两部分。第一部分是关于使用存在量化构造 Craig 内插式的理论证明。第二部分是此构造在具体实例上的应用。\n\n### 第1部分：理论证明\n\n设 $X$ 和 $Y$ 是命题变量的有限集。设 $A$ 是一个变量来自 $X$ 的公式，记作 $\\text{vars}(A) \\subseteq X$，而 $B$ 是一个变量来自 $Y$ 的公式，记作 $\\text{vars}(B) \\subseteq Y$。我们已知 $A \\Rightarrow B$ 是一个有效的蕴含式，我们写作 $A \\models B$。这意味着对于 $X \\cup Y$ 中变量的任意真值赋值 $\\mathcal{M}$，如果 $\\mathcal{M} \\models A$，那么 $\\mathcal{M} \\models B$。\n\n我们被要求证明公式 $I := \\exists(X \\setminus Y) A$ 是一个 Craig 内插式。这需要证明三个性质：\n$1.$ $I$ 的变量包含在 $X \\cap Y$ 中。\n$2.$ $A \\Rightarrow I$ 是有效的 ($A \\models I$)。\n$3.$ $I \\Rightarrow B$ 是有效的 ($I \\models B$)。\n\n设 $V = X \\setminus Y$。对于变量集合 $V = \\{v_1, v_2, \\dots, v_k\\}$ 的存在量词定义为单变量量词的迭代应用，$\\exists V \\varphi := \\exists v_1 \\exists v_2 \\dots \\exists v_k \\varphi$。单变量量化定义为 $\\exists v \\varphi := \\varphi[v:=\\top] \\lor \\varphi[v:=\\bot]$。\n\n**1. 内插式 $I$ 的变量**\n\n公式 $A$ 的变量在 $X$ 中，即 $\\text{vars}(A) \\subseteq X$。公式 $I$ 是通过对集合 $V = X \\setminus Y$ 中的所有变量进行存在量化消去而构造的。对公式 $\\varphi$ 中的变量 $v$ 进行存在量化，会从结果公式的自由变量集合中移除 $v$。因此，$I$ 的变量是 $\\text{vars}(A) \\setminus V$ 的一个子集。\n$$ \\text{vars}(I) \\subseteq \\text{vars}(A) \\setminus (X \\setminus Y) \\subseteq X \\setminus (X \\setminus Y) $$\n使用集合论，$X \\setminus (X \\setminus Y) = X \\cap (X \\setminus Y)^c = X \\cap (X^c \\cup Y) = (X \\cap X^c) \\cup (X \\cap Y) = \\emptyset \\cup (X \\cap Y) = X \\cap Y$。\n因此，$\\text{vars}(I) \\subseteq X \\cap Y$。第一个性质得到满足。\n\n**2. $A \\models I$ 的证明**\n\n我们需要证明 $A \\Rightarrow \\exists(X \\setminus Y)A$ 是一个有效式。我们可以通过对 $X \\setminus Y$ 中量化变量的数量进行归纳来证明。首先，我们证明单个变量 $v$ 的基本情况：$A \\models \\exists v A$。\n设 $\\mathcal{M}$ 是一个任意的真值赋值。我们必须证明如果 $\\mathcal{M} \\models A$，那么 $\\mathcal{M} \\models \\exists v A$。\n假设 $\\mathcal{M} \\models A$。由 $\\mathcal{M}$ 赋给变量 $v$ 的真值，我们记作 $\\mathcal{M}(v)$，是 $\\top$ 或 $\\bot$。\n情况1：$\\mathcal{M}(v) = \\top$。$\\mathcal{M}$ 满足 $A$ 等价于 $\\mathcal{M}$ 满足 $A[v:=\\top]$（因为 $v$ 已被赋值为 $\\top$）。因此，$\\mathcal{M} \\models A[v:=\\top]$。由此可得，$\\mathcal{M} \\models A[v:=\\top] \\lor A[v:=\\bot]$，这正是 $\\mathcal{M} \\models \\exists v A$ 的定义。\n情况2：$\\mathcal{M}(v) = \\bot$。类似地，$\\mathcal{M}$ 满足 $A$ 意味着 $\\mathcal{M} \\models A[v:=\\bot]$。这同样意味着 $\\mathcal{M} \\models A[v:=\\top] \\lor A[v:=\\bot]$，所以 $\\mathcal{M} \\models \\exists v A$。\n在两种情况下，如果 $\\mathcal{M} \\models A$，那么 $\\mathcal{M} \\models \\exists v A$。因此，$A \\models \\exists v A$。\n\n现在，设 $X \\setminus Y = \\{v_1, v_2, \\dots, v_k\\}$。我们有 $A \\models \\exists v_1 A$。令 $A_1 = \\exists v_1 A$。对 $A_1$ 应用相同的逻辑，我们得到 $A_1 \\models \\exists v_2 A_1$，这意味着 $\\exists v_1 A \\models \\exists v_2 (\\exists v_1 A)$。根据语义蕴含的传递性，$A \\models \\exists v_2 \\exists v_1 A$。对所有变量 $v_1, \\dots, v_k$ 继续此过程，我们得出结论 $A \\models \\exists v_k \\dots \\exists v_1 A$，即 $A \\models I$。第二个性质得到满足。\n\n**3. $I \\models B$ 的证明**\n\n我们已知 $A \\models B$。我们需要证明 $I \\models B$，即 $\\exists(X \\setminus Y)A \\models B$。\n设 $\\mathcal{M}$ 是对 $\\text{vars}(I) \\cup \\text{vars}(B)$ 中变量的任意赋值。由于 $\\text{vars}(I) \\subseteq X \\cap Y$ 且 $\\text{vars}(B) \\subseteq Y$，赋值 $\\mathcal{M}$ 是为 $(X \\cap Y) \\cup Y = Y$ 中的变量定义的。\n假设 $\\mathcal{M} \\models I$。根据定义，$I = \\exists(X \\setminus Y)A$。在语义上，这等价于对 $V = X \\setminus Y$ 中变量所有可能的真值赋值的析取。设 $\\Sigma$ 是所有 $2^{|V|}$ 个真值赋值 $\\sigma: V \\to \\{\\top, \\bot\\}$ 的集合。那么 $I \\equiv \\bigvee_{\\sigma \\in \\Sigma} A[V:=\\sigma]$，其中 $A[V:=\\sigma]$ 是将公式 $A$ 中 $V$ 的变量替换为 $\\sigma$ 所赋真值的公式。\n假设 $\\mathcal{M} \\models I$ 意味着 $\\mathcal{M} \\models \\bigvee_{\\sigma \\in \\Sigma} A[V:=\\sigma]$。这意味着存在至少一个赋值 $\\sigma_0 \\in \\Sigma$，使得 $\\mathcal{M} \\models A[V:=\\sigma_0]$。\n让我们在 $X \\cup Y$ 中的所有变量上定义一个新的赋值 $\\mathcal{M}^*$。令 $\\mathcal{M}^*$ 在 $Y$ 中的所有变量上与 $\\mathcal{M}$ 一致，并在 $V = X \\setminus Y$ 中的所有变量上与 $\\sigma_0$ 一致。由于 $X \\cup Y = Y \\cup (X \\setminus Y)$，$\\mathcal{M}^*$ 是 $A$ 和 $B$ 中所有变量的一个完整赋值。\n$\\mathcal{M} \\models A[V:=\\sigma_0]$ 的满足意味着，当公式 $A$ 在 $Y \\cap X$ 中的变量根据 $\\mathcal{M}$ 赋值，而在 $X \\setminus Y$ 中的变量根据 $\\sigma_0$ 赋值时，该公式为真。这正是 $\\mathcal{M}^* \\models A$ 的条件。\n由于我们已知 $A \\models B$，从 $\\mathcal{M}^* \\models A$ 我们可以得出 $\\mathcal{M}^* \\models B$。\n$B$ 的变量都在 $Y$ 中。赋值 $\\mathcal{M}^*$ 在 $Y$ 中的所有变量上都与 $\\mathcal{M}$ 一致。因此，$B$ 在 $\\mathcal{M}^*$ 下的真值与它在 $\\mathcal{M}$ 下的真值相同。所以，从 $\\mathcal{M}^* \\models B$，我们得出 $\\mathcal{M} \\models B$。\n我们已经证明，对于任何相关的赋值 $\\mathcal{M}$，如果 $\\mathcal{M} \\models I$，那么 $\\mathcal{M} \\models B$。因此，$I \\models B$。第三个性质得到满足。\n\n理论证明到此完成。\n\n### 第2部分：具体示例\n\n我们已知：\n- $X = \\{p, q, r\\}$ 和 $Y = \\{q, s\\}$。这得到 $X \\cap Y = \\{q\\}$ 和 $X \\setminus Y = \\{p, r\\}$。\n- $A := (\\neg p \\lor q) \\land (\\neg r \\lor q) \\land (p \\lor r)$。\n- $B := q$。\n\n**1. 通过归结验证 $A \\Rightarrow B$**\n\n我们需要证明 $A \\land \\neg B$ 是不可满足的。我们将 $A \\land \\neg B$ 转换成一个子句集，并通过归结推导出空子句 ($\\Box$)。\n$A \\land \\neg B \\equiv ((\\neg p \\lor q) \\land (\\neg r \\lor q) \\land (p \\lor r)) \\land (\\neg q)$。\n子句集是 $S = \\{\\{\\neg p, q\\}, \\{\\neg r, q\\}, \\{p, r\\}, \\{\\neg q\\}\\}$。\n归结反驳过程如下：\n$1.$ $\\{\\neg p, q\\}$ (来自 $A$)\n$2.$ $\\{\\neg r, q\\}$ (来自 $A$)\n$3.$ $\\{p, r\\}$ (来自 $A$)\n$4.$ $\\{\\neg q\\}$ (来自 $\\neg B$)\n$5.$ $\\{\\neg p\\}$ (通过对 $1$ 和 $4$ 在 $q$ 上进行归结得到)\n$6.$ $\\{\\neg r\\}$ (通过对 $2$ 和 $4$ 在 $q$ 上进行归结得到)\n$7.$ $\\{r\\}$ (通过对 $3$ 和 $5$ 在 $p$ 上进行归结得到)\n$8.$ $\\Box$ (通过对 $6$ 和 $7$ 在 $r$ 上进行归结得到)\n空子句的推导证明了 $A \\land \\neg B$ 是不可满足的，这证实了 $A \\Rightarrow B$ 是一个有效式。\n\n**2. 内插式 $I$ 的计算**\n\n内插式是 $I := \\exists(X \\setminus Y) A = \\exists\\{p, r\\} A$。我们可以按任意顺序消去变量 $p$ 和 $r$。\n$$ I = \\exists p \\exists r ((\\neg p \\lor q) \\land (\\neg r \\lor q) \\land (p \\lor r)) $$\n首先，我们消去 $r$。令 $\\varphi(p, q, r) = (\\neg p \\lor q) \\land (\\neg r \\lor q) \\land (p \\lor r)$。\n$$ \\exists r \\varphi(p, q, r) = \\varphi(p, q, r:=\\top) \\lor \\varphi(p, q, r:=\\bot) $$\n代入 $r=\\top$:\n$$ \\varphi(p, q, \\top) = (\\neg p \\lor q) \\land (\\neg \\top \\lor q) \\land (p \\lor \\top) = (\\neg p \\lor q) \\land (\\bot \\lor q) \\land \\top = (\\neg p \\lor q) \\land q $$\n根据吸收律 $(X \\lor Y) \\land X \\equiv X$，我们有 $(\\neg p \\lor q) \\land q \\equiv q$。\n代入 $r=\\bot$:\n$$ \\varphi(p, q, \\bot) = (\\neg p \\lor q) \\land (\\neg \\bot \\lor q) \\land (p \\lor \\bot) = (\\neg p \\lor q) \\land (\\top \\lor q) \\land p = (\\neg p \\lor q) \\land p $$\n根据分配律，$(\\neg p \\lor q) \\land p = (\\neg p \\land p) \\lor (q \\land p) = \\bot \\lor (p \\land q) \\equiv p \\land q$。\n所以，$\\exists r \\varphi(p, q, r) \\equiv q \\lor (p \\land q)$。\n根据吸收律 $X \\lor (Y \\land X) \\equiv X$，我们有 $q \\lor (p \\land q) \\equiv q$。\n\n现在我们从结果公式 $q$ 中消去 $p$：\n$$ I = \\exists p (q) $$\n由于公式 $q$ 不包含变量 $p$，量化没有效果：\n$$ \\exists p (q) = q[p:=\\top] \\lor q[p:=\\bot] = q \\lor q \\equiv q $$\n计算出的内插式是 $I=q$。\n\n为了验证，我们检查 $I=q$ 的性质：\n$1.$ $\\text{vars}(I) = \\{q\\}$，这确实是 $X \\cap Y$。\n$2.$ $A \\Rightarrow I$ 即 $A \\Rightarrow q$，我们已经验证过它是有效的。\n$3.$ $I \\Rightarrow B$ 即 $q \\Rightarrow q$，这是平凡有效的。\n结果是一致的。", "answer": "$$\\boxed{q}$$", "id": "2971064"}, {"introduction": "克雷格内插定理的威力远不止于纯命题逻辑，它在自动推理和程序验证等领域扮演着至关重要的角色。最后一个练习将我们带入更复杂的背景：数组理论（theory of arrays）。我们将设计并应用一个算法，为在数组理论中不可满足的公式对构造量词无关的内插式 [@problem_id:2971036]。这个练习不仅能让你掌握处理特定理论（SMT）中内插问题的技巧，也展示了内插思想如何被扩展以解决现实世界中的复杂问题。", "problem": "考虑无量词的数组理论，其意义遵循麦卡锡公理，其中索引类型和元素类型都与整数等同。该理论有两个基本操作：对于任意数组项 $a$、索引项 $i$ 和元素项 $v$，项 $\\mathit{write}(a,i,v)$ 表示一个与 $a$ 相同但索引 $i$ 处的值为 $v$ 的数组；而项 $\\mathit{read}(a,i)$（写作 $a[i]$）表示存储在数组 $a$ 中索引 $i$ 处的元素。该理论由“写后读”法则公理化：\n- $\\mathit{read}(\\mathit{write}(a,i,v),i) = v$。\n- 对于所有索引 $i,j$，如果 $i \\neq j$，则 $\\mathit{read}(\\mathit{write}(a,i,v),j) = \\mathit{read}(a,j)$。\n\nCraig 内插定理指出：当公式 $A$ 和 $B$ 满足 $A \\land B$ 不可满足时，存在一个公式 $I$，其签名域为 $A$ 和 $B$ 共享的签名域，使得 $A \\models I$ 且 $I \\land B$ 不可满足。\n\n设计一个算法，在给定不可满足的无量词数组约束 $A$ 和 $B$ 的情况下，使用索引和元素投影构造一个无量词的 Craig 内插式。你的算法应从上述公理和基本的命题推理开始。它必须：\n- 解释如何形成一个索引投影，该投影记录在应用“写后读”法则时出现在 $A$ 中的索引之间的相等或不相等关系，并且要遵循共享签名域的约束。\n- 解释如何形成一个元素投影，该投影记录在同样应用“写后读”法则时由 $A$ 强制产生的元素项之间的相等关系。\n- 解释如何将这些投影组合成一个无量词的内插式，该内插式仅使用共享符号并由 $A$ 蕴含。\n\n然后，将你的算法应用于以下具体实例。设 $i$ 和 $k$ 是共享的索引变量，$v$ 是一个共享的元素变量，$a$ 和 $b$ 是 $A$ 的局部数组变量。考虑\n- $A \\equiv \\big( b = \\mathit{write}(a,i,1) \\big) \\land \\big( v = \\mathit{read}(b,k) \\big)$，\n- $B \\equiv \\big( i = k \\big) \\land \\big( v \\neq 1 \\big)$。\n\n证明在无量词数组理论中，$A \\land B$ 是不可满足的，仅使用上述公理；对此实例逐步执行你的索引和元素投影算法；并计算出在共享签名域 $\\{i,k,v\\}$ 上的内插式 $I$ 的单个闭式解析表达式。最终答案必须是 $I$ 的 LaTeX 句法表达式。不需要四舍五入，也不涉及物理单位。将最终的内插式表示为单个公式。", "solution": "总体任务是首先描述一个用于在无量词数组理论中构造 Craig 内插式的通用算法，然后将其应用于一个具体实例。\n\n### 数组理论中的内插通用算法\n\n设 $A$ 和 $B$ 是数组理论中的两个无量词公式，使得它们的合取 $A \\land B$ 是不可满足的。设 $\\Sigma_A$ 和 $\\Sigma_B$ 分别是 $A$ 和 $B$ 中的非逻辑符号（变量、常量、函数）集合。共享签名域为 $\\Sigma_{sh} = \\Sigma_A \\cap \\Sigma_B$。一个 Craig 内插式 $I$ 是一个满足以下条件的公式：\n1.  $A \\models I$（$A$ 蕴含 $I$）。\n2.  $I \\land B$ 是不可满足的。\n3.  $I$ 的签名域是 $\\Sigma_{sh}$ 的一个子集。\n\n该算法从一个证明 $A \\land B$ 不可满足的过程中构造 $I$。其核心思想是追踪 $A$ 的推论，但只传播那些可以用共享签名域 $\\Sigma_{sh}$ 表达的信息。\n\n**步骤 1：证明生成与代换**\n首先，我们证明 $A \\land B$ 是不可满足的。对于无量词理论，这通常涉及等量代换和应用理论公理，直到推导出显式矛盾（例如 $\\perp$，或 $x=y \\land x \\neq y$）。在此过程中，我们通过将 $A$ 的局部变量（即在 $\\Sigma_A \\setminus \\Sigma_{sh}$ 中的变量）的定义代入从 $A$ 推导出的其他推理部分来消除它们。这通常会分离出一个形如 $\\mathit{read}(\\mathit{write}(\\dots))$ 的项。\n\n**步骤 2：形成索引和元素投影**\n应用“写后读”公理是在数组理论中推导结论的核心步骤。当我们遇到一个从 $A$ 推导出的形如 $\\mathit{read}(\\mathit{write}(a,i,v),j)$ 的项时，我们根据索引 $i$ 和 $j$ 进行情况划分：\n\n- **情况 1：** $i = j$。该项简化为 $v$。\n- **情况 2：** $i \\neq j$。该项简化为 $\\mathit{read}(a,j)$。\n\n这种情況划分导致了投影的生成：\n\n- **索引投影** 是一个只包含共享签名域 $\\Sigma_{sh}$ 中索引的公式。它表示对这些索引的一个条件。在上述情况划分中，如果 $i$ 和 $j$ 都在 $\\Sigma_{sh}$ 中，那么公式 $i=j$（及其否定式 $i \\neq j$）就是索引投影的候选。这个投影捕捉了 $A$ 在何种情况下会产生特定信息。\n\n- **元素投影** 是一个只包含共享签名域 $\\Sigma_{sh}$ 中元素类型项的公式。它表示在特定索引投影下对这些项成立的推论。例如，如果在索引投影 $i=j$ 下，原始数组项简化为一个共享值 $v$，从而导致一个像 $t=v$ 这样的派生等式（其中 $t$ 也是共享的），那么 $t=v$ 就是元素投影的候选。如果某个情况导致了一个涉及局部变量的推论（例如 $\\mathit{read}(a,j)$，其中 $a$ 是 $A$ 的局部变量），那么该推理分支在构建内插式时将被丢弃，因为它无法在 $\\Sigma_{sh}$ 中表达。\n\n**步骤 3：将投影组合成内插式**\n内插式 $I$ 是作为派生出的投影的逻辑组合来构造的。对于每个能导出一个可在 $\\Sigma_{sh}$ 中表达的相应元素投影 $C_{elem}$ 的索引投影 $C_{idx}$，我们已经证明了 $A \\models (C_{idx} \\Rightarrow C_{elem})$。最终的内插式 $I$ 是从证明中推导出的所有这些蕴含式的合取。这通常可以简化为单个逻辑公式。\n\n### 应用于具体实例\n\n我们已知：\n- $A \\equiv \\big( b = \\mathit{write}(a,i,1) \\big) \\land \\big( v = \\mathit{read}(b,k) \\big)$\n- $B \\equiv \\big( i = k \\big) \\land \\big( v \\neq 1 \\big)$\n- 共享签名域为 $\\Sigma_{sh} = \\{i, k, v\\}$。数组变量 $a$ 和 $b$ 是 $A$ 的局部变量。\n\n**步骤 1：证明 $A \\land B$ 的不可满足性**\n\n1.  假设 $A \\land B$。\n2.  从 $A$ 中，我们有等式 $b = \\mathit{write}(a,i,1)$ 和 $v = \\mathit{read}(b,k)$。\n3.  将第一个等式中 $b$ 的表达式代入第二个等式：$v = \\mathit{read}(\\mathit{write}(a,i,1), k)$。这个推论完全由 $A$ 导出。\n4.  从 $B$ 中，我们有等式 $i = k$。\n5.  将条件 $i=k$ 应用于步骤 3 中导出的表达式。现在 $\\mathit{read}$ 和 $\\mathit{write}$ 操作的索引相等。\n6.  根据数组的第一条公理 $\\mathit{read}(\\mathit{write}(a,i,v'),i) = v'$，由于 $i=k$，我们有 $\\mathit{read}(\\mathit{write}(a,i,1),k) = 1$。\n7.  结合步骤 3 和 6，我们推断出 $v = 1$。\n8.  从 $B$ 中，我们还有不等式 $v \\neq 1$。\n9.  步骤 7 和 8 产生了矛盾 $(v = 1) \\land (v \\neq 1)$。\n10. 因此，$A \\land B$ 是不可满足的。\n\n**步骤 2：执行投影算法**\n\n我们现在重新进行证明，仔细追踪哪些信息可以在 $\\Sigma_{sh} = \\{i, k, v\\}$ 中表达。\n\n1.  **在 $A$ 中代换**：如同证明中一样，我们从 $A$ 开始，代换局部变量 $b$。这得到了 $A$ 的关键推论：\n    $$v = \\mathit{read}(\\mathit{write}(a,i,1), k)$$\n\n2.  **情况划分和投影**：我们使用数组公理来分析项 $\\mathit{read}(\\mathit{write}(a,i,1), k)$。涉及的索引是 $i$ 和 $k$。两者都在共享签名域 $\\Sigma_{sh}$ 中。\n\n    - **情况 (a)：** $i = k$。\n        - 这是关于共享索引的一个条件。这个公式 $i=k$ 就是我们的**索引投影**。\n        - 在这个假设下，应用第一条数组公理：$\\mathit{read}(\\mathit{write}(a,i,1),k) = 1$。\n        - 将此结果代回到步骤 1 的推论中，得到 $v = 1$。\n        - 变量 $v$ 在 $\\Sigma_{sh}$ 中，而 $1$ 是一个常量。因此，公式 $v=1$ 可以在 $\\Sigma_{sh}$ 中表达。这是我们对应于索引投影 $i=k$ 的**元素投影**。\n\n    - **情况 (b)：** $i \\neq k$。\n        - 这个条件 $i \\neq k$ 是另一个潜在的索引投影。\n        - 在这个假设下，应用第二条数组公理：$\\mathit{read}(\\mathit{write}(a,i,1),k) = \\mathit{read}(a,k)$。\n        - 步骤 1 的推论变为 $v = \\mathit{read}(a,k)$。\n        - 项 $\\mathit{read}(a,k)$ 依赖于变量 $a$，它是 $A$ 的局部变量，不在 $\\Sigma_{sh}$ 中。因此，这个等式不能成为内插式的一部分。这条路径没有产生有用的元素投影。\n\n**步骤 3：将投影组合成内插式 $I$**\n\n我们的分析只找到一条能在共享签名域中产生非平凡推论的路径：即 $i=k$ 蕴含 $v=1$ 的情况。这给了我们蕴含式：\n$$ (i=k) \\Rightarrow (v=1) $$\n让我们将内插式 $I$ 定义为这个公式：$I \\equiv (i=k) \\Rightarrow (v=1)$。我们必须验证它是否满足 Craig 内插式的三个条件。\n\n1.  **$A \\models I$**：我们在步骤 2 中的推导表明，从 $A$ 可以导出 $v = \\mathit{read}(\\mathit{write}(a,i,1),k)$。如果我们假设 $I$ 的前件，即 $i=k$，则根据数组公理，该表达式简化为 $v=1$（$I$ 的后件）。这正式地表明了 $A$ 蕴含 $(i=k) \\Rightarrow (v=1)$。\n\n2.  **$I \\land B$ 是不可满足的**：我们检验 $I \\equiv (i=k) \\Rightarrow (v=1)$ 和 $B \\equiv (i=k) \\land (v \\neq 1)$ 的合取：\n    $$ \\big( (i=k) \\Rightarrow (v=1) \\big) \\land \\big( (i=k) \\land (v \\neq 1) \\big) $$\n    从合取项 $(i=k) \\Rightarrow (v=1)$ 和 $i=k$，我们可以通过肯定前件式（modus ponens）推断出 $v=1$。这与另一个合取项 $v \\neq 1$ 矛盾。因此，$I \\land B$ 是不可满足的。\n\n3.  **$I$ 的签名域在 $\\Sigma_{sh}$ 中**：公式 $I \\equiv (i=k) \\Rightarrow (v=1)$ 只包含符号 $i$、$k$、$v$、等号谓词和常量 $1$。所有这些符号都在共享签名域 $\\Sigma_{sh} = \\{i,k,v\\}$ 中（常量和逻辑连接词默认被认为是共享的）。\n\n公式 $I \\equiv (i=k) \\Rightarrow (v=1)$ 满足给定的 $A$ 和 $B$ 的 Craig 内插式的所有性质。这个公式也可以表达为逻辑上等价的形式 $(i \\neq k) \\lor (v=1)$。我们提供蕴含形式作为最终答案，因为它最直接地反映了投影算法的推理过程。", "answer": "$$ \\boxed{(i = k) \\Rightarrow (v = 1)} $$", "id": "2971036"}]}