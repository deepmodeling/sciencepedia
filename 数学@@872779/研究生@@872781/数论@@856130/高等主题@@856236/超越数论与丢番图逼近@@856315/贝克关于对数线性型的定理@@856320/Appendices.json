{"hands_on_practices": [{"introduction": "第一个练习旨在提供应用贝克理论的基础性、分步式体验。通过为一个简单的双对数线性型手动计算一个显式下界，你将对其中涉及的关键参数（如对数高和马特维耶夫定理的结构）获得具体理解。这项动手计算将抽象的公式具体化，为更复杂的应用做好准备。[@problem_id:3008823]", "problem": "设 $K$ 为数域 $\\mathbb{Q}$，并考虑对数线性形式 $\\Lambda = \\ln 2 - 2 \\ln 3$。使用 $\\mathbb{Q}$ 上的绝对对数Weil高度，以及由Matveev定理提供的关于代数数对数线性形式的一般显式下界，按以下步骤进行：\n\n- 确定域次数 $D = [K : \\mathbb{Q}]$。\n- 计算绝对对数高度 $h(2)$ 和 $h(3)$。\n- 确定 $|\\ln 2|$ 和 $|\\ln 3|$ 的值。\n- 设 $B$ 为线性形式中整数系数绝对值的最大值。\n- 据此，根据Matveev界的标准假设选择参数 $A_{1}$ 和 $A_{2}$（即，每个 $A_{i}$ 必须大于等于域次数加权的高度、对数的绝对值以及一个固定的正下阈值）。\n- 使用这些选择，应用Matveev关于 $|\\Lambda|$ 的显式界，并使用适用于两个对数的标准常数。\n\n你的任务是计算 $|\\ln 2 - 2 \\ln 3|$ 的一个具体的显式下界，并将其表示为单个封闭形式的解析表达式。不要简化线性形式本身，也不要使用任何对消恒等式。最终的界使用 $\\ln$ 表示自然对数。无需进行四舍五入。", "solution": "用户提供了一个问题，要求使用Matveev定理计算一个对数线性形式的下界。\n\n### 步骤1：问题验证\n\n问题陈述要求将数论中的一个特定定理（Matveev定理）应用于给定的对数线性形式 $\\Lambda = \\ln 2 - 2 \\ln 3$。\n\n-   **提取已知条件：**\n    -   数域：$K = \\mathbb{Q}$。\n    -   线性形式：$\\Lambda = \\ln 2 - 2 \\ln 3$。\n    -   方法：Matveev关于对数线性形式的定理。\n    -   高度函数：绝对对数Weil高度, $h(\\cdot)$。\n    -   问题提供了一系列需要遵循的步骤：确定次数 $D$，计算高度 $h(\\alpha_i)$，确定 $|\\ln \\alpha_i|$，找到系数界 $B$，选择参数 $A_i$，并应用该界。\n\n-   **使用提取的已知条件进行验证：**\n    1.  **科学依据：** 该问题牢固地植根于超越数论，并涉及一个主要的、已确立的结果（Matveev定理）的直接应用。数域、对数高度和对数线性形式等概念在该领域是标准的。\n    2.  **适定性：** 该问题是适定的。它提供了一个特定的线性形式、一个确定的上下文（数域 $\\mathbb{Q}$）以及应用特定定理的清晰步骤。目标是计算一个单一、具体的值（该界的解析表达式）。条件 $\\Lambda \\neq 0$ 对于界的非平凡性至关重要，并且该条件是满足的，因为 $\\ln 2 - 2 \\ln 3 = \\ln (2/9) \\neq \\ln 1 = 0$。\n    3.  **客观性：** 问题以精确、客观和形式化的数学语言陈述。\n    4.  **完整性：** 问题是自洽的。它指定了所有必要的组成部分：数、系数、域以及要使用的定理。虽然“适用于两个对数的标准常数”这一短语可能略显含糊，但一个合理的解释是将Matveev一般定理中的常数特化到 $n=2$ 的情况，这是一个标准步骤。\n\n-   **结论：**\n    该问题是有效的。它是一个在数论中应用关键定理的明确定义的练习。\n\n### 步骤2：求解\n\n我们按照问题陈述中概述的步骤，计算 $|\\Lambda|$ 的下界，其中 $\\Lambda = \\ln 2 - 2 \\ln 3$。\n\n该线性形式的类型为 $\\Lambda = b_1 \\ln \\alpha_1 + b_2 \\ln \\alpha_2$，其中有 $n=2$ 个对数。\n与给定形式进行比较，我们确定以下组成部分：\n-   代数数：$\\alpha_1 = 2$ 和 $\\alpha_2 = 3$。\n-   整数系数：$b_1 = 1$ 和 $b_2 = -2$。\n\n**域次数 $D$**\n数域 $K$ 被指定为 $\\mathbb{Q}$。代数数 $\\alpha_1 = 2$ 和 $\\alpha_2 = 3$ 都是有理数，因此它们生成的域是 $\\mathbb{Q}(2, 3) = \\mathbb{Q}$。该域在 $\\mathbb{Q}$ 上的次数是：\n$$D = [K : \\mathbb{Q}] = [\\mathbb{Q} : \\mathbb{Q}] = 1$$\n\n**绝对对数高度**\n对于有理数 $\\alpha = p/q$（其中 $p, q$ 是互质整数），其绝对对数Weil高度 $h(\\alpha)$ 由 $h(\\alpha) = \\ln(\\max\\{|p|, |q|\\})$ 给出。\n-   对于 $\\alpha_1 = 2 = 2/1$：整数 $p=2, q=1$ 是互质的。\n    $$h(2) = \\ln(\\max\\{|2|, |1|\\}) = \\ln 2$$\n-   对于 $\\alpha_2 = 3 = 3/1$：整数 $p=3, q=1$ 是互质的。\n    $$h(3) = \\ln(\\max\\{|3|, |1|\\}) = \\ln 3$$\n\n**对数的绝对值**\n由于 $2 > 1$ 且 $3 > 1$，它们的自然对数都是正数。\n-   $|\\ln \\alpha_1| = |\\ln 2| = \\ln 2$。\n-   $|\\ln \\alpha_2| = |\\ln 3| = \\ln 3$。\n\n**系数界 $B$**\n界 $B$ 是整数系数 $b_i$ 绝对值的最大值。\n$$B = \\max\\{|b_1|, |b_2|\\} = \\max\\{|1|, |-2|\\} = 2$$\n\n**参数 $A_1$ 和 $A_2$**\n对于每个 $i \\in \\{1, 2\\}$，我们必须选择 $A_i$ 使得 $A_i \\ge \\max\\{D h(\\alpha_i), |\\ln \\alpha_i|, 0.16\\}$。\n-   对于 $\\alpha_1 = 2$：\n    我们需要 $A_1 \\ge \\max\\{D h(2), |\\ln 2|, 0.16\\} = \\max\\{1 \\cdot \\ln 2, \\ln 2, 0.16\\}$。\n    由于 $\\ln 2 \\approx 0.6931$，大于 $0.16$，所以最大值是 $\\ln 2$。我们选择最小的有效值：\n    $$A_1 = \\ln 2$$\n-   对于 $\\alpha_2 = 3$：\n    我们需要 $A_2 \\ge \\max\\{D h(3), |\\ln 3|, 0.16\\} = \\max\\{1 \\cdot \\ln 3, \\ln 3, 0.16\\}$。\n    由于 $\\ln 3 \\approx 1.0986$，大于 $0.16$，所以最大值是 $\\ln 3$。我们选择最小的有效值：\n    $$A_2 = \\ln 3$$\n\n**应用Matveev定理**\n我们使用Matveev (2000) 工作中的一般显式下界。该结果的一个常用表述是，对于一个非零线性形式 $\\Lambda$，\n$$\\ln|\\Lambda| > -C(n) D^2 (1+\\ln D) (1+\\ln B) A_1 \\cdots A_n$$\n其中常数 $C(n)$ 由 $C(n) = 1.4 \\cdot 30^{n+3} \\cdot n^{4.5}$ 给出。\n我们代入上面确定的参数：\n-   $n = 2$\n-   $D = 1$\n-   $B = 2$\n-   $A_1 = \\ln 2$\n-   $A_2 = \\ln 3$\n\n首先，我们计算乘法常数因子，它依赖于 $n$ 和 $D$。“适用于两个对数的标准常数”这一短语被解释为将一般常数特化到 $n=2$ 的情况。\n项 $(1+\\ln D)$ 变为 $(1+\\ln 1) = 1+0 = 1$。\n界的常数部分是：\n$$C(2) D^2 (1+\\ln D) = (1.4 \\cdot 30^{2+3} \\cdot 2^{4.5}) \\cdot 1^2 \\cdot (1+\\ln 1) = 1.4 \\cdot 30^5 \\cdot 2^{4.5}$$\n注意 $2^{4.5} = 2^{9/2}$。\n\n现在，我们构建关于 $\\ln|\\Lambda|$ 的完整不等式：\n$$\\ln|\\Lambda| > -(1.4 \\cdot 30^5 \\cdot 2^{9/2}) \\cdot (1+\\ln B) \\cdot A_1 \\cdot A_2$$\n代入 $B=2$，$A_1=\\ln 2$ 和 $A_2=\\ln 3$：\n$$\\ln|\\ln 2 - 2 \\ln 3| > -(1.4 \\cdot 30^5 \\cdot 2^{9/2}) \\cdot (1+\\ln 2) \\cdot (\\ln 2) \\cdot (\\ln 3)$$\n\n为了求出 $|\\Lambda|$ 的下界，我们对不等式两边取指数：\n$$|\\ln 2 - 2 \\ln 3| > \\exp\\left( -(1.4 \\cdot 30^5 \\cdot 2^{9/2}) (1+\\ln 2) (\\ln 2) (\\ln 3) \\right)$$\n\n问题要求的是具体的显式下界，即此不等式右侧的值。这就是最终的表达式。", "answer": "$$\\boxed{\\exp\\left(-1.4 \\cdot 30^5 \\cdot 2^{9/2} (1+\\ln 2) (\\ln 2)(\\ln 3)\\right)}$$", "id": "3008823"}, {"introduction": "在手动计算的基础上，这个练习要求你通过设计并实现一个算法来将该过程自动化。你将把应用贝克方法的理论步骤转化为一个功能性程序，该程序可以为一类普遍的双有理数对数线性型计算下界。这个练习强调了使用精确算术处理退化条件的重要性，并展示了超越数理论如何被转化为具体的计算工具。[@problem_id:3029876]", "problem": "设计并实现一个完整、可运行的程序，给定正有理数输入 $\\alpha_1$ 和 $\\alpha_2$ 以及整数 $b_1$ 和 $b_2$，该程序使用超越数论意义下的次数和高度数据，输出对数线性形式 $|b_1 \\log \\alpha_1 + b_2 \\log \\alpha_2|$ 的绝对值的一个明确数值下界。程序必须遵循以下规范。\n\n1. 使用的基本定义：\n   - 一个代数数 $\\alpha$ 的次数 $D$ 等于其在 $\\mathbb{Q}$ 上的最小多项式的次数。对于有理数 $\\alpha \\in \\mathbb{Q}$，次数为 $D=1$。\n   - 对于一个最简形式的有理数 $\\alpha = \\frac{p}{q} \\in \\mathbb{Q}$（其中 $p$ 和 $q$ 为整数且 $q \\neq 0$），其绝对对数高度定义为 $h(\\alpha) = \\log \\max\\{|p|,|q|\\}$，其中 $\\log$ 表示自然对数。\n   - 所有 $\\log$ 计算均使用自然对数。\n   - 对数线性形式为 $b_1 \\log \\alpha_1 + b_2 \\log \\alpha_2$，使用主实数对数，要求 $\\alpha_1 > 0$ 和 $\\alpha_2 > 0$。\n\n2. 构建所依赖的科学基础：\n   - 使用一个经过充分检验的代数数对数线性形式的显式下界（例如 Andrej D. Matveev 的定理），并将其特化到 $n=2$ 和有理数输入的情况，从而用次数 $D$、系数 $b_i$ 的界以及 $\\alpha_i$ 的高度数据来表示该下界。你的算法应首先在 $\\mathbb{Q}$ 中精确验证退化条件 $\\alpha_1^{b_1}\\alpha_2^{b_2} = 1$；当此条件成立时，线性形式等于零，正确的下界为 $0$。\n\n3. 算法要求：\n   - 输入：由整数对 $(p_1,q_1)$ 和 $(p_2,q_2)$ 编码的 $\\alpha_1 = \\frac{p_1}{q_1}$ 和 $\\alpha_2 = \\frac{p_2}{q_2}$（其中 $q_1 \\neq 0$ 和 $q_2 \\neq 0$），以及整数 $b_1,b_2$。假设 $\\alpha_1 > 0$ 和 $\\alpha_2 > 0$，并且每个分数都已化为最简形式。\n   - 对于有理数输入，计算 $D=1$。\n   - 令 $B = \\max\\{3,|b_1|,|b_2|\\}$。\n   - 计算绝对对数高度 $h(\\alpha_i) = \\log \\max\\{|p_i|,|q_i|\\}$。\n   - 构造 $A_i = \\max\\{h(\\alpha_i), |\\log \\alpha_i|, 0.1\\}$。\n   - 应用一个依赖于 $D$、$B$ 和 $A_i$ 的标准显式下界来计算 $|b_1 \\log \\alpha_1 + b_2 \\log \\alpha_2|$，该下界已如上所述特化为两个对数和有理数输入的情况。仅当 $\\alpha_1^{b_1}\\alpha_2^{b_2} \\neq 1$ 时，该下界必须是非平凡的。\n\n4. 输出规范：\n   - 对于每个测试用例，输出一个浮点数，表示由你的算法计算出的 $|b_1 \\log \\alpha_1 + b_2 \\log \\alpha_2|$ 的下界。如果精确的退化条件 $\\alpha_1^{b_1}\\alpha_2^{b_2} = 1$ 在 $\\mathbb{Q}$ 中成立，则对该情况输出 $0$。\n   - 你的程序应生成单行输出，包含一个由方括号括起来的、逗号分隔的结果列表（例如，$[r_1,r_2,r_3]$）。不涉及任何单位。通过使用自然对数，所有角度默认以弧度为单位。\n\n5. 测试套件：\n   - 使用以下输入测试套件来检验正确性的不同方面：\n     - 情况 1（一般非退化）：$\\alpha_1 = 2 = \\frac{2}{1}$，$\\alpha_2 = 3 = \\frac{3}{1}$，$b_1 = 7$，$b_2 = -5$。\n     - 情况 2（接近抵消但非退化）：$\\alpha_1 = \\frac{15}{14}$，$\\alpha_2 = \\frac{9}{10}$，$b_1 = 1$，$b_2 = 1$。\n     - 情况 3（精确退化）：$\\alpha_1 = \\frac{8}{27}$，$\\alpha_2 = \\frac{2}{3}$，$b_1 = 1$，$b_2 = -3$。\n     - 情况 4（中等系数）：$\\alpha_1 = 2 = \\frac{2}{1}$，$\\alpha_2 = \\frac{5}{4}$，$b_1 = 1$，$b_2 = 1$。\n     - 情况 5（混合符号和中等大小的有理数）：$\\alpha_1 = \\frac{7}{5}$，$\\alpha_2 = \\frac{9}{7}$，$b_1 = -2$，$b_2 = 3$。\n   - 你的程序必须编码并准确运行这五个测试用例，并将结果汇总为指定的单行输出格式。", "solution": "问题要求设计并实现一个算法，用于计算两个对数的线性形式 $\\Lambda = b_1 \\log \\alpha_1 + b_2 \\log \\alpha_2$ 的绝对值的显式数值下界，其中 $\\alpha_1, \\alpha_2$ 是正有理数，$b_1, b_2$ 是整数。该计算必须基于超越数论的原理。\n\n### 理论基础\n\n解决方案的核心在于应用一个定理，该定理为 $\\Lambda \\neq 0$ 时的 $|\\Lambda|$ 提供了一个显式下界。这类下界是超越数论中的基本结果，源于 Alan Baker 的工作。我们将使用这些结果的一个现代显式版本，该版本源自 Andrej D. Matveev 的一个定理，因为它是解决此类问题的标准而强大的工具。\n\n具体来说，我们将使用由 Bugeaud、Mignotte 和 Siksek 提出的版本（Annals of Mathematics, 2006），该版本非常适合实际应用。对于一个具有代数数 $\\alpha_i$ 和整数 $b_i$ 的线性形式 $\\Lambda = \\sum_{i=1}^{n} b_i \\log \\alpha_i$，他们的定理提供了一个关于 $|\\Lambda|$ 的下界。我们必须将这个定理特化到本问题的条件下：即 $n=2$ 个有理数 $\\alpha_1, \\alpha_2$ 的对数。\n\n对于有理数，其所在的数域是 $\\mathbb{Q}$，因此次数 $D$ 为 $1$。在这些条件下，一般性定理会大大简化。该定理指出，如果 $\\Lambda \\neq 0$：\n$$\n\\log |\\Lambda| > -C(n, D) \\cdot (1 + \\log B) \\cdot A_1 \\cdots A_n\n$$\n其中参数 $A_i$ 与 $\\alpha_i$ 的高度相关，$B$ 是系数 $|b_i|$ 的一个界，$C(n, D)$ 是一个可计算的常数。\n\n根据问题的规范，我们如下定义参数：\n- 对数的数量为 $n=2$。\n- 次数为 $D=1$，因为 $\\alpha_1, \\alpha_2 \\in \\mathbb{Q}$。\n- 系数为 $b_1, b_2 \\in \\mathbb{Z}$。\n- 有理数为 $\\alpha_1 = p_1/q_1$ 和 $\\alpha_2 = p_2/q_2$，给定为最简形式且为正数。\n- 有理数 $\\alpha = p/q$ 的绝对对数高度为 $h(\\alpha) = \\log \\max\\{|p|,|q|\\}$。\n- 量 $A_i$ 定义为 $A_i = \\max\\{h(\\alpha_i), |\\log \\alpha_i|, 0.1\\}$，其中 $i=1,2$。\n- 系数的界为 $B = \\max\\{3, |b_1|, |b_2|\\}$。\n\n对于 $D=1, n=2$ 的情况，特化的 Matveev 定理中的常数为 $C_0 = 1.4 \\cdot 30^{n+3} \\cdot n^{4.5} \\cdot D^2 (1+\\log D)$。当 $n=2$ 和 $D=1$ 时，项 $(1+\\log D)$ 变为 $(1+\\log 1) = 1$，我们得到：\n$$\nC_0 = 1.4 \\cdot 30^{2+3} \\cdot 2^{4.5} = 1.4 \\cdot 30^5 \\cdot 2^{4.5} \\approx 7.704 \\times 10^8\n$$\n结合这些元素，一个非零 $\\Lambda$ 的下界由以下公式给出：\n$$\n|\\Lambda| > \\exp\\left( -C_0 \\cdot (1 + \\log B) \\cdot A_1 \\cdot A_2 \\right)\n$$\n\n### 退化条件\n\n上述下界仅在 $\\Lambda \\neq 0$ 时有效。$\\Lambda = 0$ 的情况对应于退化条件 $\\alpha_1^{b_1} \\alpha_2^{b_2} = 1$。这种情况当且仅当 $b_1 \\log \\alpha_1 + b_2 \\log \\alpha_2 = \\log(\\alpha_1^{b_1}\\alpha_2^{b_2}) = \\log(1) = 0$ 时发生。\n\n为检查此条件而不因浮点运算产生精度损失，我们必须使用精确整数计算。令 $b_i = b_i^+ - b_i^-$，其中 $b_i^+ = \\max(b_i, 0)$ 和 $b_i^- = \\max(-b_i, 0)$ 是非负整数。条件 $\\alpha_1^{b_1} \\alpha_2^{b_2} = 1$ 等价于：\n$$\n\\left(\\frac{p_1}{q_1}\\right)^{b_1} \\left(\\frac{p_2}{q_2}\\right)^{b_2} = 1 \\iff p_1^{b_1^+} q_1^{b_1^-} p_2^{b_2^+} q_2^{b_2^-} = q_1^{b_1^+} p_1^{b_1^-} q_2^{b_2^+} p_2^{b_2^-}\n$$\n此等式仅涉及整数的整数次幂，可以被精确验证。如果此恒等式成立，则 $|\\Lambda|$ 的下界为 $0$。\n\n### 算法流程\n\n对于每个测试用例 $(\\alpha_1, \\alpha_2, b_1, b_2)$，算法分两个主要阶段进行：\n\n1.  **检查退化性**：\n    - 给定输入 $(p_1, q_1)$、$(p_2, q_2)$、$b_1$ 和 $b_2$。\n    - 使用任意精度整数计算上述推导出的整数恒等式的左侧和右侧。\n    - 如果它们相等，则线性形式 $\\Lambda$ 为零。结果为 $0.0$。\n\n2.  **计算下界**：\n    - 如果形式是非退化的，则计算下界所需的参数：\n        a. $B = \\max\\{3, |b_1|, |b_2|\\}$。\n        b. 对于 $i \\in \\{1, 2\\}$，计算 $\\alpha_i = p_i/q_i$。\n        c. 计算高度 $h(\\alpha_1) = \\log(\\max\\{p_1, q_1\\})$ 和 $h(\\alpha_2) = \\log(\\max\\{p_2, q_2\\})$。注意，因为 $\\alpha_i > 0$ 且为最简形式，所以 $p_i$ 和 $q_i$ 都是正数。\n        d. 计算 $A_1 = \\max\\{h(\\alpha_1), |\\log \\alpha_1|, 0.1\\}$ 和 $A_2 = \\max\\{h(\\alpha_2), |\\log \\alpha_2|, 0.1\\}$。\n        e. 常数为 $C_0 = 1.4 \\cdot 30^5 \\cdot 2^{4.5}$。\n        f. 最终的数值下界计算为 $\\exp(-C_0 \\cdot (1 + \\log B) \\cdot A_1 \\cdot A_2)$。\n\n此流程为 $|\\Lambda|$ 提供了一个严格且显式的下界，遵循了所给定义并利用了超越数论中的一个标准结果。实现将处理给定的测试套件，并按规定格式化输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_bound(p1: int, q1: int, p2: int, q2: int, b1: int, b2: int) -> float:\n    \"\"\"\n    Computes a lower bound for |b1*log(alpha1) + b2*log(alpha2)|.\n    \n    Args:\n        p1, q1: Numerator and denominator of alpha1 = p1/q1.\n        p2, q2: Numerator and denominator of alpha2 = p2/q2.\n        b1, b2: Integer coefficients of the linear form.\n    \n    Returns:\n        A floating-point lower bound for the absolute value of the linear form.\n    \"\"\"\n    # Step 1: Degeneracy check using exact integer arithmetic.\n    # The condition alpha_1^b1 * alpha_2^b2 = 1 must be checked with care.\n    # Let b_i = b_i^+ - b_i^-, where b_i^+ = max(b_i, 0) and b_i^- = max(-b_i, 0).\n    # The condition is equivalent to:\n    # (p1/q1)^b1 * (p2/q2)^b2 = 1\n    # p1^b1 * p2^b2 = q1^b1 * q2^b2\n    # p1^(b1+) * q1^(b1-) * p2^(b2+) * q2^(b2-) = p1^(b1-) * q1^(b1+) * p2^(b2-) * q2^(b2+)\n    b1_pos = max(0, b1)\n    b1_neg = max(0, -b1)\n    b2_pos = max(0, b2)\n    b2_neg = max(0, -b2)\n\n    # Python's integers have arbitrary precision, preventing overflow.\n    lhs = pow(p1, b1_pos) * pow(p2, b2_pos) * pow(q1, b1_neg) * pow(q2, b2_neg)\n    rhs = pow(p1, b1_neg) * pow(p2, b2_neg) * pow(q1, b1_pos) * pow(q2, b2_pos)\n\n    if lhs == rhs:\n        return 0.0\n\n    # Step 2: Compute the lower bound if not degenerate.\n    # We use a specialized version of Matveev's theorem for n=2, D=1 (rationals).\n    \n    # B = max{3, |b1|, |b2|}\n    B = float(max(3, abs(b1), abs(b2)))\n\n    alpha1 = float(p1) / float(q1)\n    alpha2 = float(p2) / float(q2)\n\n    # h(alpha_i) = log(max{|p_i|, |q_i|})\n    # Since alpha_i > 0 and in lowest terms, p_i and q_i are positive.\n    h_alpha1 = np.log(float(max(p1, q1)))\n    h_alpha2 = np.log(float(max(p2, q2)))\n\n    # A_i = max{h(alpha_i), |log alpha_i|, 0.1}\n    A1 = max(h_alpha1, abs(np.log(alpha1)), 0.1)\n    A2 = max(h_alpha2, abs(np.log(alpha2)), 0.1)\n\n    # Matveev's theorem constant C0 for n=2, D=1\n    # C0 = 1.4 * 30^(n+3) * n^4.5 * D^2 * (1+log D) for D>=1\n    # With n=2, D=1, this is C0 = 1.4 * 30^5 * 2^4.5\n    n = 2.0\n    C0 = 1.4 * (30**(n + 3.0)) * (n**4.5)\n\n    # The bound for log|Lambda| is:\n    # log|Lambda| > -C0 * (1 + log B) * A1 * A2\n    log_abs_Lambda_lower_bound = -C0 * (1.0 + np.log(B)) * A1 * A2\n\n    # Return the lower bound for |Lambda|\n    lower_bound = np.exp(log_abs_Lambda_lower_bound)\n\n    return lower_bound\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Format: (p1, q1, p2, q2, b1, b2)\n    test_cases = [\n        (2, 1, 3, 1, 7, -5),      # Case 1\n        (15, 14, 9, 10, 1, 1),    # Case 2\n        (8, 27, 2, 3, 1, -3),     # Case 3\n        (2, 1, 5, 4, 1, 1),       # Case 4\n        (7, 5, 9, 7, -2, 3)      # Case 5\n    ]\n\n    results = []\n    for case in test_cases:\n        p1, q1, p2, q2, b1, b2 = case\n        result = calculate_bound(p1, q1, p2, q2, b1, b2)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3029876"}, {"introduction": "最后一个练习通过将贝克定理应用于求解指数丢番图方程（数论中的一个核心问题）来展示其真正的威力。你将实现一个结合了贝克方法的理论下界与模运算剪枝等计算技术的实用策略。这个练习阐明了一个抽象的、看似非构造性的结果如何为一个潜在解提供一个有效的上界，从而将无限的搜索空间缩减为一个有限的、可管理的空间。[@problem_id:3008764]", "problem": "设 $a$、$b$ 和 $c$ 为固定整数，其中 $a \\geq 2$、$b \\geq 2$ 且 $c \\in \\mathbb{Z}$。考虑指数丢番图方程\n$$\na^{x} - b^{y} = c\n$$\n其中 $x \\geq 1$ 和 $y \\geq 1$ 为整数。目标是实现一个实用策略，该策略利用对数线性型的有效下界，结合模约束和定向枚举，来排除或确认小编指数解的存在。该策略必须基于以下基本且经过充分检验的事实：\n\n- 定义对数线性型\n$$\n\\Lambda(x,y) = x \\log a - y \\log b,\n$$\n其中 $\\log$ 表示自然对数（以 $e$ 为底）。如果 $a$ 和 $b$ 乘性无关（即不存在非零整数 $u$ 和 $v$ 使得 $a^{u} = b^{v}$），那么对于所有整数对 $(x,y)$，$\\Lambda(x,y) \\neq 0$，除非 $a^{x} = b^{y}$。\n- 从方程 $a^{x} - b^{y} = c$ 出发，整理可得 $a^{x} / b^{y} = 1 + c / b^{y}$，因此\n$$\n\\Lambda(x,y) = \\log\\!\\left(1 + \\frac{c}{b^{y}}\\right).\n$$\n- 对于实数 $t$ 满足 $|t| \\leq \\tfrac{1}{2}$，不等式\n$$\n\\left|\\log(1+t)\\right| \\leq 2|t|\n$$\n成立，并为右侧提供了一个经过充分检验的上界。\n- 假设已经通过对数线性型理论（例如，通过 Alan Baker 的工作或 Kurt Mahler 和 Kalin Georgiev Matveev 更强的界）为给定的数对 $(a,b)$ 计算出了一个显式下界。具体来说，假设给定正参数 $U$ 和 $K$，使得对于所有满足 $1 \\leq x,y \\leq U$ 且 $\\Lambda(x,y) \\neq 0$ 的整数 $x,y$，有\n$$\n|\\Lambda(x,y)| \\geq U^{-K}.\n$$\n这是您算法的一个输入，并被视为一个显式可用的界。\n- 结合前两点，只要 $\\left|\\frac{c}{b^{y}}\\right| \\leq \\tfrac{1}{2}$（等价于 $b^{y} \\geq 2|c|$），任何解都必须满足\n$$\nU^{-K} \\leq |\\Lambda(x,y)| = \\left|\\log\\!\\left(1 + \\frac{c}{b^{y}}\\right)\\right| \\leq \\frac{2|c|}{b^{y}},\n$$\n因此\n$$\nb^{y} \\leq \\frac{2|c|}{U^{-K}} = 2|c|\\,U^{K}.\n$$\n这就得到了一个关于 $y$ 的可计算上界，即\n$$\ny \\leq \\left\\lfloor \\log_{b}\\!\\big(2|c|\\,U^{K}\\big) \\right\\rfloor,\n$$\n只要 $b^{y} \\geq 2|c|$。对于剩下的有限多个 $b^{y} < 2|c|$ 的情况，直接枚举即可。\n\n除了下界论证外，模约束通常可以裁剪搜索空间。对于一个固定的模数 $m \\in \\mathbb{Z}_{\\geq 2}$，同余式\n$$\na^{x} \\equiv b^{y} + c \\pmod{m}\n$$\n必须对任何解都成立。对于每个固定的 $y$，可以计算余数 $r_{m}(y) \\equiv b^{y} + c \\pmod{m}$，然后检查 $r_{m}(y)$ 是否位于当 $x$ 遍历正整数时 $a^{x} \\pmod{m}$ 所能达到的 $\\mathbb{Z}/m\\mathbb{Z}$ 的子集中。如果存在一个模数 $m$ 使得 $r_{m}(y)$ 无法达到，那么该 $y$ 值就可以被完全排除。\n\n您的任务是实现以下算法：\n\n1. 对于每个测试用例 $(a,b,c)$，您还会得到枚举界限 $B_{\\mathrm{enum}}$ 和如上所述的显式下界参数 $(U,K)$。计算 $L = U^{-K}$。\n2. 计算阈值\n$$\ny_{\\tfrac{1}{2}} = \\left\\lceil \\log_{b}\\!\\big(2|c|\\big) \\right\\rceil,\n$$\n该阈值保证对于所有 $y \\geq y_{\\tfrac{1}{2}}$，不等式 $\\left|\\frac{c}{b^{y}}\\right| \\leq \\tfrac{1}{2}$ 成立。\n3. 使用下界推断出\n$$\ny \\leq Y_{\\mathrm{Baker}} := \\left\\lfloor \\log_{b}\\!\\big(2|c|/L\\big) \\right\\rfloor = \\left\\lfloor \\log_{b}\\!\\big(2|c|\\,U^{K}\\big) \\right\\rfloor.\n$$\n4. 将要枚举的最大 $y$ 设置为\n$$\ny_{\\max} = \\min\\!\\big(B_{\\mathrm{enum}},\\,\\max(1,\\,\\max(Y_{\\mathrm{Baker}},\\,y_{\\tfrac{1}{2}}-1))\\big).\n$$\n5. 对于 $1 \\leq y \\leq y_{\\max}$ 中的每个 $y$，使用一组小的模数（例如 $m \\in \\{4,5,7,8,9,11,13\\}$）进行模剪枝。如果任何模数排除了 $y$，则跳过它。否则，对 $x$ 进行定向枚举：\n   - 如果 $y < y_{\\tfrac{1}{2}}$，枚举所有满足 $1 \\leq x \\leq B_{\\mathrm{enum}}$ 的 $x$。\n   - 如果 $y \\geq y_{\\tfrac{1}{2}}$，使用不等式\n     $$\n     \\big|x - y \\tfrac{\\log b}{\\log a}\\big| \\leq \\frac{2|c|}{b^{y}\\log a}\n     $$\n     将 $x$ 限制在 $y \\frac{\\log b}{\\log a}$ 周围的一个狭窄区间内，并且只在该区间的一个小的安全边际内枚举整数 $x$（您可以将该区间扩大一个小的固定整数边际以考虑粗略常数）。\n   - 对于缩小区间内的每个候选 $x$，在精确整数运算中检查 $a^{x} - b^{y} = c$ 是否成立。\n6. 如果有任何 $(x,y)$ 对满足该方程，则表示未排除小编指数解；为该测试用例返回布尔值 $\\mathrm{False}$。否则，返回 $\\mathrm{True}$，表示在给定的显式界限和模约束下，已排除了规定范围内的小编指数解。\n\n测试套件和要求的最终输出：\n\n使用以下六个测试用例，每个用例以 $(a,b,c,B_{\\mathrm{enum}},U,K)$ 的形式给出，其中 $\\log$ 为自然对数：\n\n- 案例 1：$(2,3,5,50,1000,6)$。\n- 案例 2：$(3,2,7,50,1000,6)$。\n- 案例 3：$(5,3,2,30,1000,6)$。\n- 案例 4：$(7,2,3,40,1000,6)$。\n- 案例 5：$(2,3,-1,50,1000,6)$。\n- 案例 6：$(2,3,4,50,1000,6)$。\n\n您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表（例如 $[r_{1},r_{2},\\dots,r_{6}]$），其中每个 $r_{i}$ 是一个布尔值，指示所述策略是否已为该情况排除了小编指数解。不涉及物理单位或角度单位；所有对数均为自然对数，且输出必须采用确切指定的列表格式。", "solution": "该问题提供了一个详细的算法，用于寻找或排除指数丢番图方程 $a^x - b^y = c$ 的小编指数整数解 $(x,y)$。该方法将从 Baker 的对数线性型理论中派生出的理论界与实用的计算搜索技术（即模算术和定向枚举）相结合。\n\n### 问题验证\n\n首先，对问题陈述进行严格的验证。\n\n1.  **已知条件提取**：\n    -   方程为 $a^x - b^y = c$，其中整数 $x \\geq 1$，$y \\geq 1$。\n    -   常数为整数 $a \\geq 2$，$b \\geq 2$，且 $c \\in \\mathbb{Z}$。\n    -   算法由一系列计算步骤定义，涉及：\n        -   一个枚举界限 $B_{\\mathrm{enum}}$。\n        -   参数 $U, K$ 用于对数线性型 $\\Lambda(x,y) = x \\log a - y \\log b$ 的显式下界 $|\\Lambda(x,y)| \\geq U^{-K}$。\n        -   一个阈值 $y_{\\tfrac{1}{2}} = \\lceil \\log_{b}(2|c|) \\rceil$。\n        -   一个上界 $Y_{\\mathrm{Baker}} = \\lfloor \\log_{b}(2|c|\\,U^{K}) \\rfloor$。\n        -   一个搜索限制 $y_{\\max} = \\min(B_{\\mathrm{enum}}, \\max(1, \\max(Y_{\\mathrm{Baker}}, y_{\\tfrac{1}{2}}-1)))$。\n        -   使用模数 $m \\in \\{4,5,7,8,9,11,13\\}$ 进行模剪枝。\n        -   对 $x$ 进行定向枚举，其中当 $y \\ge y_{\\tfrac{1}{2}}$ 时，搜索区间由 $|x - y\\frac{\\log b}{\\log a}| \\le \\frac{2|c|}{b^y \\log a}$ 给出。\n    -   测试套件包含六个元组 $(a,b,c,B_{\\mathrm{enum}},U,K)$。\n\n2.  **有效性检查**：\n    -   **科学基础**：该问题在数论中有坚实的基础。使用对数线性型是解决丢番图方程的标准且强大的技术。所呈现的不等式是该理论在数学上正确的推论。\n    -   **适定性**：该问题指定了一个确定性算法，具有清晰的输入和唯一定义的输出格式。计算步骤明确，为每个测试用例导向一个单一、可验证的结果。\n    -   **客观性**：该问题以精确、客观的数学语言陈述，没有任何主观性。\n    -   **完整性与一致性**：所有必需的常数、公式和测试用例均已提供。理论基础与算法步骤一致。“小安全边际”的微小模糊性是一个实现中的实践细节，可以通过选择一个合理的固定整数（如 $2$）来解决。涉及 $\\log|c|$ 的公式中隐含了 $c \\neq 0$ 的假设，并且这对所有测试用例都成立。$(a,b)$ 对的乘性无关性对所有测试用例也均满足，确保了 $\\Lambda(x,y) \\neq 0$。\n\n3.  **结论**：该问题被认为是有效的，因为它是科学合理的、适定的、客观的且自洽的。\n\n### 求解推导\n\n解决方案涉及按描述实现算法。设计一个函数来处理每个测试用例，如果在指定的搜索空间内未找到解（即解被排除），则返回 `True`，如果找到解，则返回 `False`。\n\n对于给定的测试用例 $(a,b,c,B_{\\mathrm{enum}},U,K)$，主要步骤如下：\n\n1.  **初始化与预计算**：\n    -   用于剪枝的模数集为 $M = \\{4,5,7,8,9,11,13\\}$。\n    -   为了高效地应用模约束，对于每个模数 $m \\in M$，我们预先计算余数集 $R_m = \\{a^x \\pmod m \\mid x \\ge 1\\}$。由于幂序列是周期性的，这个集合是有限的。\n\n2.  **计算 $y$ 的搜索界限**：\n    -   计算阈值 $y_{\\tfrac{1}{2}}$。对于 $y \\ge y_{\\tfrac{1}{2}}$，不等式 $|\\log(1 + c/b^y)| \\le 2|c|/b^y$ 成立。\n        $y_{\\tfrac{1}{2}} = \\max(1, \\lceil \\log_b(2|c|) \\rceil)$。\n    -   从 Baker 方法计算出的 $y$ 的理论上界为：\n        $Y_{\\mathrm{Baker}} = \\lfloor \\log_b(2|c|\\,U^K) \\rfloor = \\lfloor \\frac{\\log(2|c|) + K\\log U}{\\log b} \\rfloor$。\n    -   通过将这些与给定的枚举界限 $B_{\\mathrm{enum}}$ 相结合，确定 $y$ 的最终有效搜索限制：\n        $y_{\\max} = \\min(B_{\\mathrm{enum}}, \\max(1, Y_{\\mathrm{Baker}}, y_{\\tfrac{1}{2}}-1))$。\n\n3.  **迭代搜索**：算法从 $1$ 到 $y_{\\max}$ 迭代每个整数 $y$。对于每个 $y$：\n\n    -   **模剪枝**：使用每个模数 $m \\in M$ 来测试存在解的可能性。对于给定的 $y$，我们计算同余式 $a^x \\equiv b^y+c \\pmod m$ 的右侧。如果这个值 $(b^y+c) \\pmod m$ 不在预先计算的余数集 $R_m$ 中，那么就没有任何整数 $x \\ge 1$ 能满足该同余式。因此，这个 $y$ 值被排除，算法继续处理下一个 $y$。\n\n    -   **对 $x$ 的定向枚举**：如果 $y$ 通过了模剪枝，则进行对 $x$ 的搜索。\n        -   如果 $y < y_{\\tfrac{1}{2}}$，则不能保证对数线性型近似的有效性。从 $1$到 $B_{\\mathrm{enum}}$ 对 $x$ 进行直接搜索。\n        -   如果 $y \\ge y_{\\tfrac{1}{2}}$，我们使用不等式 $|x \\log a - y \\log b| \\le \\frac{2|c|}{b^y}$，它将 $x$ 限制在实数 $y \\frac{\\log b}{\\log a}$ 周围一个非常小的区间内。我们枚举这个区间内的整数 $x$，并将其扩大一个小的安全边际（例如，每边扩大 $2$）以考虑近似值。\n\n    -   **解的检验**：对于每个生成的候选对 $(x,y)$，使用精确整数运算来检验方程 $a^x - b^y = c$ 是否成立。Python 的任意精度整数对此非常适用，因为幂可能会变得非常大。如果找到解，函数立即返回 `False`。\n\n4.  **最终结果**：如果从 $1$到 $y_{\\max}$ 对 $y$ 的整个循环完成而没有找到任何解，函数返回 `True`，表示在给定的约束下，小编指数解已被排除。\n\n例如，对于案例 6，$2^x - 3^y = 4$，算法将迅速确定不存在解。使用模数 $m=4$ 的模约束是 $2^x - (-1)^y \\equiv 0 \\pmod 4$。如果 $x=1$，则为 $2 - (-1)^y \\not\\equiv 0$。如果 $x \\ge 2$，则为 $0 - (-1)^y \\not\\equiv 0$。由于对于任何 $x,y \\ge 1$ 的组合这都不成立，模检验将排除所有 $y$，算法将正确返回 `True`。对于其他情况，将会找到小编解，从而导致 `False` 输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Solves the exponential Diophantine equation a^x - b^y = c for small integer solutions\n    using the specified algorithm.\n    \"\"\"\n\n    test_cases = [\n        # (a, b, c, B_enum, U, K)\n        (2, 3, 5, 50, 1000, 6),\n        (3, 2, 7, 50, 1000, 6),\n        (5, 3, 2, 30, 1000, 6),\n        (7, 2, 3, 40, 1000, 6),\n        (2, 3, -1, 50, 1000, 6),\n        (2, 3, 4, 50, 1000, 6),\n    ]\n\n    MODULI = [4, 5, 7, 8, 9, 11, 13]\n    SAFETY_MARGIN = 2\n\n    def get_residues(base, mod):\n        \"\"\"Computes the set of residues {base^x mod mod} for x >= 1.\"\"\"\n        if mod == 1:\n            return {0}\n        residues = set()\n        val = base % mod\n        if val == 0: # a^1 is 0 mod m\n            return {0}\n        while val not in residues:\n            residues.add(val)\n            val = (val * base) % mod\n            if val == 0 and 0 in residues: # Handle cycles that hit 0\n                break\n        return residues\n\n    def check_case(a, b, c, B_enum, U, K):\n        \"\"\"\n        Implements the specified algorithm for a single test case.\n        Returns True if solutions are ruled out, False if a solution is found.\n        \"\"\"\n        # Pre-compute modular residues for a^x for each modulus\n        ax_residues = {m: get_residues(a, m) for m in MODULI}\n\n        # The problem formulation implies c != 0, which is true for all test cases.\n        # If c were 0, log(2*abs(c)) would be undefined.\n        \n        # Calculate bounds on y\n        log_b = np.log(b)\n        \n        # y_1/2: threshold for the validity of the log inequality\n        # This is ceil(log_b(2*|c|))\n        if 2 * abs(c) <= 1:\n            y_one_half = 1\n        else:\n            y_one_half = math.ceil(np.log(2 * abs(c)) / log_b)\n        y_one_half = max(1, y_one_half)\n        \n        # Y_Baker: upper bound on y from Baker's theory\n        # This is floor(log_b(2*|c|*U^K))\n        log_U = np.log(U)\n        y_baker = math.floor((np.log(2 * abs(c)) + K * log_U) / log_b)\n        \n        # y_max: final enumeration bound for y\n        y_max = min(B_enum, max(1, y_baker, y_one_half - 1))\n\n        # Main search loop over y\n        for y in range(1, y_max + 1):\n            # 1. Modular Pruning\n            is_ruled_out = False\n            for m in MODULI:\n                # Use Python's built-in pow for modular exponentiation\n                rhs_mod = (pow(b, y, m) + c) % m\n                if rhs_mod not in ax_residues[m]:\n                    is_ruled_out = True\n                    break\n            if is_ruled_out:\n                continue\n            \n            # 2. Targeted Enumeration of x\n            if y < y_one_half:\n                # For small y, enumerate x up to B_enum\n                for x in range(1, B_enum + 1):\n                    # Use Python's arbitrary-precision integers\n                    if pow(a, x) - pow(b, y) == c:\n                        return False\n            else: # y >= y_one_half\n                # For large y, use inequality to narrow down search for x\n                log_a = np.log(a)\n                x_center = y * log_b / log_a\n                x_delta = (2 * abs(c)) / (pow(b, y) * log_a)\n                \n                x_min = max(1, math.floor(x_center - x_delta) - SAFETY_MARGIN)\n                x_max = math.ceil(x_center + x_delta) + SAFETY_MARGIN\n                \n                for x in range(x_min, x_max + 1):\n                    if pow(a, x) - pow(b, y) == c:\n                        return False\n                        \n        return True\n\n    results = []\n    for case in test_cases:\n        result = check_case(*case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(lambda b: str(b).lower(), results))}]\")\n\nsolve()\n```", "id": "3008764"}]}