{"hands_on_practices": [{"introduction": "在$L$函数的矩理论中，我们通常处理的是由“本原”狄利克雷特征构成的族，因为它们具有良好的函数方程和分析性质。这个练习将通过一个直接的计算，让你亲手分离并量化非本原特征对矩的贡献，从而阐明为何在研究中需要做出这种限制。通过解决这个问题，你将深入理解本原性在定义一个“纯粹”的$L$函数族时的关键作用，并掌握如何将非本原部分的贡献与黎曼$\\zeta$函数联系起来 [@problem_id:3018759]。", "problem": "设 $p$ 是一个固定的素数，且设 $s>1$ 是一个实参数。对每个模 $p$ 的狄利克雷特征 $\\chi$，其狄利克雷 $L$-函数（L-函数）定义为 $L(s,\\chi)=\\sum_{n=1}^{\\infty}\\chi(n)n^{-s}$。考虑模 $p$ 的完整特征族上的二阶矩，\n$$M_{\\mathrm{all}}(p,s)=\\sum_{\\chi \\bmod p} |L(s,\\chi)|^{2},$$\n以及限制在模 $p$ 的本原特征上的二阶矩，\n$$M_{\\mathrm{prim}}(p,s)=\\sum_{\\substack{\\chi \\bmod p\\\\ \\chi \\ \\mathrm{primitive}}} |L(s,\\chi)|^{2}.$$\n从狄利克雷特征和狄利克雷 $L$-函数的定义出发，并仅使用关于黎曼 zeta 函数 $\\zeta(s)$ 和欧拉乘积的标准事实，推导非本原修正项\n$$\\Delta(p,s)=M_{\\mathrm{all}}(p,s)-M_{\\mathrm{prim}}(p,s),$$\n的精确闭式表达式，其方法是识别当限制于本原特征时局部因子如何调整，并量化非本原特征的贡献。将你的最终答案表示为关于 $p$ 和 $s$ 的单个解析表达式。无需四舍五入。", "solution": "问题要求解非本原修正项 $\\Delta(p,s)$，它被定义为模素数 $p$ 的所有狄利克雷 $L$-函数的二阶矩与仅限于模 $p$ 的本原特征的二阶矩之差。参数 $s$ 是一个实数，且 $s>1$。\n\n根据定义，我们有：\n$$M_{\\mathrm{all}}(p,s)=\\sum_{\\chi \\bmod p} |L(s,\\chi)|^{2}$$\n$$M_{\\mathrm{prim}}(p,s)=\\sum_{\\substack{\\chi \\bmod p\\\\ \\chi \\ \\mathrm{primitive}}} |L(s,\\chi)|^{2}$$\n非本原修正项是它们的差：\n$$\\Delta(p,s) = M_{\\mathrm{all}}(p,s) - M_{\\mathrm{prim}}(p,s) = \\sum_{\\substack{\\chi \\bmod p\\\\ \\chi \\ \\mathrm{imprimitive}}} |L(s,\\chi)|^{2}$$\n这意味着我们必须对所有非本原的模 $p$ 特征 $\\chi$ 求 $|L(s,\\chi)|^{2}$ 的和。\n\n首先，我们识别模素数 $p$ 的非本原特征。一个模 $p$ 的特征 $\\chi$ 是非本原的，如果它是由模 $p$ 的一个真因子 $d$ 的特征 $\\chi^*$ 诱导的。因为 $p$ 是一个素数，它的因子只有 $1$ 和 $p$。$p$ 唯一的真因子是 $d=1$。\n因此，一个模 $p$ 的特征 $\\chi$ 是非本原的，当且仅当它是由一个模 $1$ 的特征诱导的。\n\n模 $1$ 的特征只有一个，即对所有整数 $n$ 定义为 $\\chi_{0}^{(1)}(n) = 1$ 的平凡特征 $\\chi_{0}^{(1)}$。由 $\\chi_{0}^{(1)}$ 诱导的模 $p$ 特征是模 $p$ 的主特征，记作 $\\chi_0$。诱导特征的定义给出：\n$$\\chi_0(n) = \\begin{cases} \\chi_{0}^{(1)}(n)  \\text{if } \\gcd(n, p) = 1 \\\\ 0  \\text{if } \\gcd(n, p) > 1 \\end{cases}$$\n由于对所有 $n$ 都有 $\\chi_{0}^{(1)}(n)=1$，这可以简化为：\n$$\\chi_0(n) = \\begin{cases} 1  \\text{if } p \\nmid n \\\\ 0  \\text{if } p \\mid n \\end{cases}$$\n因此，模素数 $p$ 恰好有一个非本原特征：主特征 $\\chi_0$。所有其他 $\\phi(p)-1 = p-2$ 个模 $p$ 的非主特征都是本原的，因为它们的导子必须是 $p$。\n\n因此，非本原修正项 $\\Delta(p,s)$ 是来自这个单一特征的贡献：\n$$\\Delta(p,s) = |L(s, \\chi_0)|^2$$\n\n接下来，我们推导 $L$-函数 $L(s, \\chi_0)$ 的表达式。狄利克雷 $L$-级数定义为 $L(s, \\chi_0) = \\sum_{n=1}^{\\infty} \\frac{\\chi_0(n)}{n^s}$。使用 $\\chi_0$ 的定义，我们得到：\n$$L(s, \\chi_0) = \\sum_{\\substack{n=1 \\\\ p \\nmid n}}^{\\infty} \\frac{1}{n^s}$$\n这是对所有不能被 $p$ 整除的正整数 $n$ 的 $n^{-s}$ 求和。我们可以将其与黎曼 zeta 函数 $\\zeta(s) = \\sum_{n=1}^{\\infty} \\frac{1}{n^s}$ 联系起来，该函数在 $s>1$ 时收敛。\n\n我们可以将定义 $\\zeta(s)$ 的和分成两部分：一部分是对不能被 $p$ 整除的整数求和，另一部分是对能被 $p$ 整除的整数求和。\n$$\\zeta(s) = \\sum_{n=1}^{\\infty} \\frac{1}{n^s} = \\sum_{\\substack{n=1 \\\\ p \\nmid n}}^{\\infty} \\frac{1}{n^s} + \\sum_{\\substack{n=1 \\\\ p \\mid n}}^{\\infty} \\frac{1}{n^s}$$\n第一项正是 $L(s, \\chi_0)$。第二项是对 $p$ 的所有倍数求和。设 $n=kp$，$k=1, 2, 3, \\dots$。\n$$\\sum_{\\substack{n=1 \\\\ p \\mid n}}^{\\infty} \\frac{1}{n^s} = \\sum_{k=1}^{\\infty} \\frac{1}{(kp)^s} = \\frac{1}{p^s} \\sum_{k=1}^{\\infty} \\frac{1}{k^s} = p^{-s}\\zeta(s)$$\n将此代回 $\\zeta(s)$ 的表达式中：\n$$\\zeta(s) = L(s, \\chi_0) + p^{-s}\\zeta(s)$$\n解出 $L(s, \\chi_0)$，我们发现：\n$$L(s, \\chi_0) = \\zeta(s) - p^{-s}\\zeta(s) = \\zeta(s)(1 - p^{-s})$$\n这个关系也可以从欧拉乘积表示中推导出来。$\\zeta(s)$ 的欧拉乘积是 $\\zeta(s) = \\prod_{q \\text{ prime}}(1 - q^{-s})^{-1}$。$L(s, \\chi_0)$ 的欧拉乘积是 $L(s, \\chi_0) = \\prod_{q \\text{ prime}}(1 - \\chi_0(q)q^{-s})^{-1}$。由于对素数 $q \\neq p$ 有 $\\chi_0(q)=1$，而 $\\chi_0(p)=0$，所以 $L(s, \\chi_0)$ 的乘积与 $\\zeta(s)$ 的相同，但移除了对应素数 $p$ 的因子。这直接给出 $L(s,\\chi_0) = \\zeta(s)(1-p^{-s})$。\n\n最后，我们计算 $\\Delta(p,s)$：\n$$\\Delta(p,s) = |L(s, \\chi_0)|^2 = |\\zeta(s)(1 - p^{-s})|^2$$\n问题陈述 $s > 1$ 是一个实参数。对于实数 $s>1$，黎曼 zeta 函数 $\\zeta(s) = \\sum_{n=1}^{\\infty} n^{-s}$ 是正实数项的和，因此 $\\zeta(s)$ 是一个正实数。\n另外，因为 $p$ 是素数，所以 $p \\geq 2$。对于 $s>1$，我们有 $p^s > p \\ge 2$，这意味着 $0  p^{-s}  1$。因此，项 $(1 - p^{-s})$ 也是一个正实数。\n因此，乘积 $\\zeta(s)(1 - p^{-s})$ 是一个正实数，绝对值是多余的。\n$$\\Delta(p,s) = (\\zeta(s)(1 - p^{-s}))^2$$\n这可以写成：\n$$\\Delta(p,s) = \\zeta(s)^2 (1 - p^{-s})^2$$\n这就是非本原修正项关于 $p$ 和 $s$ 的精确闭式表达式。", "answer": "$$\n\\boxed{\\zeta(s)^2 (1 - p^{-s})^2}\n$$", "id": "3018759"}, {"introduction": "矩的渐近主项是如何产生的？这个练习通过一个黎曼$\\zeta$函数的简化模型，引导你使用“对角线方法”这一核心分析工具。你将学习如何将矩的积分展开为一个双重求和，并将其分解为“对角项”和“非对角项”，其中渐近主项恰恰来自于结构相对简单的对角贡献 [@problem_id:3018839]。这个思想是解析数论中许多更复杂矩计算的基石。", "problem": "设 $\\zeta(s)$ 表示黎曼ζ函数，并设 $T \\geq 2$ 是一个大参数。考虑临界线上的狄利克雷多项式近似，由下式给出\n$$\nS(t) \\coloneqq \\sum_{n \\leq T^{1/2}} n^{-1/2 - i t},\n$$\n作为 $\\zeta(\\tfrac{1}{2} + i t)$ 在 $t \\in [0,T]$ 上的一个模型。定义模型二阶矩\n$$\nM_{\\mathrm{model}}(T) \\coloneqq \\int_{0}^{T} \\left| S(t) \\right|^{2} \\, dt.\n$$\n从第一性原理出发，计算当 $T \\to \\infty$ 时 $M_{\\mathrm{model}}(T)$ 的主阶渐近式，直到并包括 $T \\ln T$ 项的系数。你可以使用一个经过充分验证的事实，即调和级数满足\n$$\n\\sum_{n \\leq x} \\frac{1}{n} = \\ln x + \\gamma + o(1),\n$$\n其中 $\\gamma$ 是欧拉-马斯刻若尼常数。作为对比，一个经典事实是，真实的二阶矩满足\n$$\nM_{\\mathrm{true}}(T) \\coloneqq \\int_{0}^{T} \\left| \\zeta(\\tfrac{1}{2} + i t) \\right|^{2} dt = T \\ln T + (2 \\gamma - 1) T + o(T).\n$$\n求 $M_{\\mathrm{model}}(T)$ 和 $M_{\\mathrm{true}}(T)$ 中首项 $T \\ln T$ 的系数之比。将你的最终答案表示为一个简化的有理数。", "solution": "问题要求计算黎曼ζ函数的一个模型二阶矩的主阶渐近式，以及其主项系数与真实二阶矩主项系数的比值。\n\n模型二阶矩定义为 $M_{\\mathrm{model}}(T) \\coloneqq \\int_{0}^{T} | S(t) |^{2} \\, dt$，其中 $S(t) \\coloneqq \\sum_{n \\leq T^{1/2}} n^{-1/2 - i t}$。我们关心的是当 $T \\to \\infty$ 时的行为。\n\n首先，我们展开被积函数 $|S(t)|^2$。回顾对于任意复数 $z$，有 $|z|^2 = z \\overline{z}$，因此：\n$$\n|S(t)|^2 = S(t) \\overline{S(t)} = \\left(\\sum_{m \\leq T^{1/2}} m^{-1/2 - i t}\\right) \\left(\\overline{\\sum_{n \\leq T^{1/2}} n^{-1/2 - i t}}\\right)\n$$\n和的共轭是共轭的和。$n^{-1/2 - it} = n^{-1/2} n^{-it} = n^{-1/2} \\exp(-it \\ln n)$ 的共轭是 $n^{-1/2} \\exp(it \\ln n) = n^{-1/2+it}$。因此，\n$$\n|S(t)|^2 = \\left(\\sum_{m \\leq T^{1/2}} m^{-1/2 - i t}\\right) \\left(\\sum_{n \\leq T^{1/2}} n^{-1/2 + i t}\\right)\n$$\n我们可以将其表示为一个双重求和：\n$$\n|S(t)|^2 = \\sum_{m \\leq T^{1/2}} \\sum_{n \\leq T^{1/2}} m^{-1/2} n^{-1/2} m^{-it} n^{it} = \\sum_{m,n \\leq T^{1/2}} (mn)^{-1/2} \\left(\\frac{n}{m}\\right)^{it}\n$$\n现在，我们将其代回到 $M_{\\mathrm{model}}(T)$ 的积分中：\n$$\nM_{\\mathrm{model}}(T) = \\int_{0}^{T} \\left( \\sum_{m,n \\leq T^{1/2}} (mn)^{-1/2} \\left(\\frac{n}{m}\\right)^{it} \\right) \\, dt\n$$\n由于求和是有限的，我们可以交换积分和求和的顺序：\n$$\nM_{\\mathrm{model}}(T) = \\sum_{m,n \\leq T^{1/2}} (mn)^{-1/2} \\int_{0}^{T} \\left(\\frac{n}{m}\\right)^{it} \\, dt\n$$\n积分 $\\int_{0}^{T} (n/m)^{it} dt = \\int_{0}^{T} \\exp(it \\ln(n/m)) dt$ 的行为取决于 $m=n$ 还是 $m \\neq n$。我们将和分为两部分：$m=n$ 时的对角项，和 $m \\neq n$ 时的非对角项。\n\n情况1：对角项 ($m=n$)。\n当 $m=n$ 时，我们有 $n/m = 1$，所以 $\\ln(n/m) = 0$。被积函数变为 $\\exp(0)=1$。积分为：\n$$\n\\int_{0}^{T} 1 \\, dt = T\n$$\n对角项对 $M_{\\mathrm{model}}(T)$ 的贡献，我们称之为 $D(T)$，是：\n$$\nD(T) = \\sum_{n \\leq T^{1/2}} (n \\cdot n)^{-1/2} \\cdot T = \\sum_{n \\leq T^{1/2}} (n^2)^{-1/2} T = T \\sum_{n \\leq T^{1/2}} \\frac{1}{n}\n$$\n问题提供了调和级数的渐近展开式：$\\sum_{n \\leq x} \\frac{1}{n} = \\ln x + \\gamma + o(1)$。我们将此应用于 $x = T^{1/2}$：\n$$\n\\sum_{n \\leq T^{1/2}} \\frac{1}{n} = \\ln(T^{1/2}) + \\gamma + o(1) = \\frac{1}{2} \\ln T + \\gamma + o(1)\n$$\n将此代入我们关于 $D(T)$ 的表达式中：\n$$\nD(T) = T \\left( \\frac{1}{2} \\ln T + \\gamma + o(1) \\right) = \\frac{1}{2} T \\ln T + \\gamma T + o(T)\n$$\n这给出了主阶行为。\n\n情况2：非对角项 ($m \\neq n$)。\n当 $m \\neq n$ 时，$\\ln(n/m)$ 是一个非零实数。积分为：\n$$\n\\int_{0}^{T} \\exp(it \\ln(n/m)) \\, dt = \\left[ \\frac{\\exp(it \\ln(n/m))}{i \\ln(n/m)} \\right]_{0}^{T} = \\frac{\\exp(iT \\ln(n/m)) - 1}{i \\ln(n/m)}\n$$\n该项的模是有界的：\n$$\n\\left| \\frac{\\exp(iT \\ln(n/m)) - 1}{i \\ln(n/m)} \\right| \\leq \\frac{|\\exp(iT \\ln(n/m))| + |1|}{|i \\ln(n/m)|} = \\frac{2}{|\\ln(n/m)|}\n$$\n来自非对角项的总贡献，我们称之为 $O(T)$，是：\n$$\nO(T) = \\sum_{\\substack{m,n \\leq T^{1/2} \\\\ m \\neq n}} (mn)^{-1/2} \\frac{\\exp(iT \\ln(n/m)) - 1}{i \\ln(n/m)}\n$$\n$O(T)$ 的模有界，其界为：\n$$\n|O(T)| \\leq \\sum_{\\substack{m,n \\leq T^{1/2} \\\\ m \\neq n}} \\frac{2(mn)^{-1/2}}{|\\ln(n/m)|}\n$$\n仔细分析表明，这个和的量级是 $O(T^{1/2} \\ln T)$。由于 $\\lim_{T \\to \\infty} \\frac{T^{1/2} \\ln T}{T \\ln T} = \\lim_{T \\to \\infty} \\frac{1}{T^{1/2}} = 0$，非对角项的贡献是一个低阶项，即 $O(T) = o(T \\ln T)$。\n\n结合这两部分的贡献，我们得到 $M_{\\mathrm{model}}(T)$ 的渐近式：\n$$\nM_{\\mathrm{model}}(T) = D(T) + O(T) = \\frac{1}{2} T \\ln T + \\gamma T + o(T) + o(T \\ln T)\n$$\n因此，主阶渐近式为：\n$$\nM_{\\mathrm{model}}(T) = \\frac{1}{2} T \\ln T + O(T)\n$$\n$M_{\\mathrm{model}}(T)$ 中 $T \\ln T$ 项的系数是 $C_{\\mathrm{model}} = \\frac{1}{2}$。\n\n作为对比，问题给出了真实的二阶矩渐近式：\n$$\nM_{\\mathrm{true}}(T) = \\int_{0}^{T} \\left| \\zeta(\\tfrac{1}{2} + i t) \\right|^{2} dt = T \\ln T + (2 \\gamma - 1) T + o(T)\n$$\n$M_{\\mathrm{true}}(T)$ 中 $T \\ln T$ 项的系数是 $C_{\\mathrm{true}} = 1$。\n\n问题要求计算这些系数的比值：\n$$\n\\text{比值} = \\frac{C_{\\mathrm{model}}}{C_{\\mathrm{true}}} = \\frac{1/2}{1} = \\frac{1}{2}\n$$\n这个结果表明，这个简单的狄利克雷多项式模型只捕捉到了黎曼ζ函数真实二阶矩主项的一半。另一半来自于 $\\zeta(s)$ 更完整的近似函数方程中的第二个和。", "answer": "$$\\boxed{\\frac{1}{2}}$$", "id": "3018839"}, {"introduction": "理论概念最终需要在实践中得到检验与应用。这个计算练习要求你设计并实现一个数值实验，使用近似函数方程 (AFE) 来估算狄利克雷L函数的二阶矩。这个过程将迫使你将诸如高斯和、根数、光滑权重函数等抽象概念转化为具体的代码，从而加深对L函数数值分析的理解 [@problem_id:3018766]。这不仅是一个编程任务，更是一个将深刻理论转化为可计算结果的综合性实践。", "problem": "设 $q$ 是一个奇素数，并考虑模 $q$ 的 Dirichlet 特征。对于一个固定的模 $q$ 原根 $g$，每个剩余 $a \\in \\{1,2,\\dots,q-1\\}$ 都可以唯一地写成 $a \\equiv g^t \\pmod{q}$，其中 $t \\in \\{0,1,\\dots,q-2\\}$。乘法特征可以通过规则 $\\chi_k(a) = \\exp(\\frac{2\\pi i k t}{q-1})$ 和 $\\chi_k(0)=0$ 由 $k \\in \\{0,1,\\dots,q-2\\}$ 索引。对于素数 $q$，当 $k=0$ 时的特征是主特征（非本原的）；所有其他特征都是本原的。Dirichlet $L$-函数定义为 $L(s,\\chi) = \\sum_{n \\ge 1} \\chi(n) n^{-s}$（对于 $\\operatorname{Re}(s) > 1$），它允许解析延拓，并有一个函数方程，通过一个依赖于 $\\chi$ 的根数将 $s$ 和 $1-s$ 联系起来。近似函数方程 (AFE) 是一个广泛使用的数值工具，用于在中心点 $s=\\tfrac{1}{2}$ 附近计算 $L(s,\\chi)$ 的值。它通过将 $L(s,\\chi)$ 表示为两个互补的 Dirichlet 型和来实现，这些和带有光滑权重，其有效长度的尺度与 $\\sqrt{q}$ 相当。\n\n从模 $q$ 的 Dirichlet 特征、Gauss 和以及 Dirichlet $L$-函数的函数方程的定义出发，设计并实现一个数值实验来近似中心点处的二阶矩，\n$$\nM_2(q) \\coloneqq \\frac{1}{q-2} \\sum_{\\substack{\\chi \\bmod q \\\\ \\chi \\text{ primitive}}} \\left|L(\\tfrac{1}{2},\\chi)\\right|^2,\n$$\n通过将 $L(\\tfrac{1}{2},\\chi)$ 替换为一个对称的、受 AFE 启发的数值代理，该代理由以下基本部分构成：\n\n- 使用 Gauss 和 $\\tau(\\chi) = \\sum_{a=1}^{q-1} \\chi(a) \\exp(\\frac{2\\pi i a}{q})$ 与由 $\\chi(-1) = (-1)^a$ 决定的奇偶参数 $a \\in \\{0,1\\}$ 来定义根数 $\\varepsilon(\\chi) = i^{-a} \\,\\tau(\\chi)/\\sqrt{q}$。\n\n- 构建一个光滑、快速衰减的权重 $W(n,q)$，它反映了 AFE 在 $s=\\tfrac{1}{2}$ 处的有效长度，并作出明确的数值选择 $W(n,q) = \\exp(-\\pi \\frac{n^2}{q})$ 以确保在 $n \\asymp \\sqrt{q}$ 的尺度上衰减。\n\n- 构建对称代理\n$$\nL_{\\mathrm{num}}(\\tfrac{1}{2},\\chi) \\coloneqq \\sum_{n \\ge 1} \\frac{\\chi(n)}{\\sqrt{n}}\\, W(n,q)\\;+\\;\\varepsilon(\\chi)\\, \\sum_{n \\ge 1} \\frac{\\overline{\\chi(n)}}{\\sqrt{n}}\\, W(n,q),\n$$\n并使用为控制 $W(n,q)$ 衰减而选择的有限截断来计算这两个和。\n\n通过对所有模 $q$ 的本原特征（即除主特征外的所有特征）上的 $|L_{\\mathrm{num}}(\\tfrac{1}{2},\\chi)|^2$ 进行平均来计算 $M_2(q)$。您的实现必须：\n- 使用模 $q$ 的原根 $g$ 以及关于 $g$ 的离散对数来构建特征 $\\chi_k$。\n- 为每个本原特征计算 $\\tau(\\chi)$ 和 $\\varepsilon(\\chi)$。\n- 使用指定的权重 $W(n,q)$ 和一个依赖于 $\\sqrt{q}$ 的截断来近似对称的 AFE 和。\n- 聚合平方模长以近似 $M_2(q)$。\n\n在您的算法设计和实现注释中，讨论预期的数值精度如何作为导子（对于本原特征，这里基本上是 $q$）的函数而变化。特别是，将截断长度的选择和 $W(n,q)$ 的衰减与误差以及二阶矩的启发式主项行为联系起来，已知后者会像一个 $q$ 的缓变函数（例如，对数）一样增长。\n\n测试套件：\n- 为以下素数评估该实验，这些素数分别探究了一个小规模的边缘情况、一个中等规模的情况以及一个更大但计算上仍可处理的情况：$q=3$、$q=17$ 和 $q=53$。\n- 对于每个 $q$，返回如上计算的单个浮点数 $M_2(q)$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含三个结果，以逗号分隔的列表形式，并用方括号括起来，顺序为 $[M_2(3), M_2(17), M_2(53)]$。\n- 每个条目必须是标准的浮点数。此问题不涉及物理单位或角度。", "solution": "该问题要求设计并实现一个数值实验，以近似奇素数模 $q$ 的本原特征的 Dirichlet $L$-函数在中心点 $s=\\tfrac{1}{2}$ 处的二阶矩。需要计算的量是\n$$\nM_2(q) \\coloneqq \\frac{1}{q-2} \\sum_{\\substack{\\chi \\bmod q \\\\ \\chi \\text{ primitive}}} \\left|L(\\tfrac{1}{2},\\chi)\\right|^2.\n$$\n任务的核心是用一个定义明确的、受近似函数方程 (AFE) 启发的数值代理 $L_{\\mathrm{num}}(\\tfrac{1}{2},\\chi)$ 来替换真实值 $L(\\tfrac{1}{2},\\chi)$。以下步骤概述了此计算的理论基础和算法设计。\n\n### 1. Dirichlet 特征的生成\n模素数 $q$ 的 Dirichlet 特征 $\\chi$ 是一个从模 $q$ 整数乘法群 $(\\mathbb{Z}/q\\mathbb{Z})^\\times$ 到单位模长复数的同态。对于素数 $q$，存在 $q-1$ 个这样的特征。它们可以使用模 $q$ 的一个原根 $g$ 来系统地构造。每个剩余 $a \\in \\{1, 2, \\dots, q-1\\}$ 都可唯一地表示为 $g$ 的幂，即 $a \\equiv g^t \\pmod{q}$，其中指数 $t \\in \\{0, 1, \\dots, q-2\\}$ 是唯一的。指数 $t$ 是 $a$ 以 $g$ 为底的离散对数，记作 $t = \\operatorname{ind}_g(a)$。\n\n$q-1$ 个特征由整数 $k \\in \\{0, 1, \\dots, q-2\\}$ 索引。特征 $\\chi_k$ 通过其对 $a \\equiv g^t \\pmod q$ 的作用定义为：\n$$\n\\chi_k(a) = \\exp(\\frac{2\\pi i k t}{q-1}) = \\exp(\\frac{2\\pi i k \\,\\operatorname{ind}_g(a)}{q-1}).\n$$\n按照惯例，如果 $q$ 整除 $n$，则 $\\chi_k(n) = 0$。对于素数模 $q$，特征 $\\chi_0$（$k=0$）是主特征，它是非本原的。所有其他 $k \\in \\{1, 2, \\dots, q-2\\}$ 的特征 $\\chi_k$ 都是本原的。因此，$M_2(q)$ 中的求和遍及这 $q-2$ 个特征。\n\n该算法首先为每个素数 $q$ 找到一个原根 $g$，并预计算所有 $a \\in \\{1, \\dots, q-1\\}$ 的离散对数 $\\operatorname{ind}_g(a)$ 表。\n\n### 2. 数值代理 $L_{\\mathrm{num}}(\\tfrac{1}{2},\\chi)$ 的构造\n问题为 $L(\\tfrac{1}{2},\\chi)$ 定义了一个基于其函数方程的特定代理。该代理是：\n$$\nL_{\\mathrm{num}}(\\tfrac{1}{2},\\chi) \\coloneqq \\sum_{n \\ge 1} \\frac{\\chi(n)}{\\sqrt{n}}\\, W(n,q)\\;+\\;\\varepsilon(\\chi)\\, \\sum_{n \\ge 1} \\frac{\\overline{\\chi(n)}}{\\sqrt{n}}\\, W(n,q),\n$$\n其中 $W(n,q)$ 是一个光滑权重函数，$\\varepsilon(\\chi)$ 是根数。我们定义和 $S(\\chi) = \\sum_{n \\ge 1} \\frac{\\chi(n)}{\\sqrt{n}} W(n,q)$。由于权重函数 $W(n,q) = \\exp(-\\pi n^2/q)$ 是实值的，第二个和是第一个和的复共轭，即 $\\sum_{n \\ge 1} \\frac{\\overline{\\chi(n)}}{\\sqrt{n}} W(n,q) = \\overline{S(\\chi)}$。该代理可简化为：\n$$\nL_{\\mathrm{num}}(\\tfrac{1}{2},\\chi) = S(\\chi) + \\varepsilon(\\chi) \\overline{S(\\chi)}.\n$$\n计算涉及两个主要部分：根数 $\\varepsilon(\\chi)$ 和截断和 $S(\\chi)$。\n\n#### 2.1. 根数 $\\varepsilon(\\chi)$\n根数 $\\varepsilon(\\chi)$ 由 Gauss 和 $\\tau(\\chi)$ 和特征的奇偶性构造。\n模 $q$ 的特征 $\\chi$ 的 Gauss 和定义为：\n$$\n\\tau(\\chi) = \\sum_{a=1}^{q-1} \\chi(a) \\exp(\\frac{2\\pi i a}{q}).\n$$\n$\\chi$ 的奇偶性由其在 $-1$ 处的值确定。定义参数 $a \\in \\{0,1\\}$ 使得 $\\chi(-1) = (-1)^a$。对于我们的构造 $\\chi=\\chi_k$，我们可以找到 $\\operatorname{ind}_g(-1) = \\operatorname{ind}_g(q-1) = (q-1)/2$。因此，\n$$\n\\chi_k(-1) = \\exp\\left(\\frac{2\\pi i k (q-1)/2}{q-1}\\right) = \\exp(\\pi i k) = (-1)^k.\n$$\n这意味着奇偶参数就是 $a_k = k \\pmod 2$。\n根数由下式给出：\n$$\n\\varepsilon(\\chi_k) = i^{-a_k} \\frac{\\tau(\\chi_k)}{\\sqrt{q}}.\n$$\n对于本原特征，一个已知的结果是 $|\\tau(\\chi)| = \\sqrt{q}$，这确保了根数的模长为单位 1，即 $|\\varepsilon(\\chi)|=1$。\n\n#### 2.2. 截断和 $S(\\chi)$\n$L_{\\mathrm{num}}$ 定义中的和是无穷的。对于数值计算，必须将其截断。选择权重函数 $W(n,q) = \\exp(-\\pi n^2/q)$ 是因为它在 $n \\gg \\sqrt{q}$ 时衰减得非常快。这允许进行有效的截断。我们计算一个截至极限 $N_{\\text{trunc}}$ 的有限和：\n$$\nS(\\chi) \\approx \\sum_{n=1}^{N_{\\text{trunc}}} \\frac{\\chi(n)}{\\sqrt{n}} \\exp\\left(-\\pi \\frac{n^2}{q}\\right).\n$$\n必须选择截断长度 $N_{\\text{trunc}}$ 以平衡精度和计算成本。一个合适的选择应确保第一个被忽略的项（在 $n=N_{\\text{trunc}}+1$ 处）小于期望的精度（例如，对于双精度浮点数，机器精度约为 $10^{-16}$）。该项的量级约为 $\\frac{1}{\\sqrt{N_{\\text{trunc}}}} \\exp(-\\pi N_{\\text{trunc}}^2/q)$。设 $N_{\\text{trunc}} = C \\sqrt{q}$（对于某个常数 $C$），指数因子变为 $\\exp(-\\pi C^2)$，通过选择足够大的 $C$ 可以使其任意小。选择 $C=4$ 可得 $\\exp(-16\\pi) \\approx 10^{-22}$，这对于高精度来说已经足够。因此，我们设定 $N_{\\text{trunc}} = \\lceil 4\\sqrt{q} \\rceil$。\n\n### 3. 聚合与最终结果\n算法通过遍历所有本原特征（即 $k$ 从 $1$ 到 $q-2$）来进行。对于每个 $\\chi_k$：\n1.  计算 Gauss 和 $\\tau(\\chi_k)$。\n2.  确定奇偶性 $a_k=k \\pmod 2$ 并计算根数 $\\varepsilon(\\chi_k)$。\n3.  计算截断和 $S(\\chi_k)$。\n4.  组装代理 $L_{\\mathrm{num}}(\\tfrac{1}{2}, \\chi_k) = S(\\chi_k) + \\varepsilon(\\chi_k) \\overline{S(\\chi_k)}$。\n5.  计算其平方模长 $|L_{\\mathrm{num}}(\\tfrac{1}{2}, \\chi_k)|^2$ 并将其加到一个运行总和中。\n\n在对所有 $q-2$ 个本原特征求和后，将总和除以 $q-2$ 以获得最终的平均值 $M_2(q)$。对测试套件中的每个素数 $q$ 重复此过程。计算复杂度主要由遍历 $q-2$ 个特征决定，并且对每个特征计算一个长度为 $N_{\\text{trunc}} \\propto \\sqrt{q}$ 的和，导致总复杂度大约为 $O(q^{3/2})$。在 `numpy` 中使用向量化操作使得这对于指定的 $q$ 值是可行的。\n\n对于大的 $q$，$M_2(q)$ 的预期行为由随机矩阵理论和数论中的猜想所支配，这些猜想预测 $M_2(q) \\sim c \\log q$（对于某个常数 $c$）。该数值实验提供了可以与此预测的缓慢增长进行比较的数据点。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom math import gcd\n\ndef _get_prime_factors(num):\n    \"\"\"Computes the set of prime factors of a given integer.\"\"\"\n    factors = set()\n    d = 2\n    temp = num\n    while d * d = temp:\n        if temp % d == 0:\n            factors.add(d)\n            while temp % d == 0:\n                temp //= d\n        d += 1\n    if temp > 1:\n        factors.add(temp)\n    return list(factors)\n\ndef _find_primitive_root(p):\n    \"\"\"Finds a primitive root modulo a prime p.\"\"\"\n    if p == 2:\n        return 1\n    if p == 3:\n        return 2\n\n    phi = p - 1\n    prime_factors_phi = _get_prime_factors(phi)\n    \n    for g in range(2, p):\n        is_primitive = True\n        for factor in prime_factors_phi:\n            # Check if order of g is a proper divisor of phi\n            if pow(g, phi // factor, p) == 1:\n                is_primitive = False\n                break\n        if is_primitive:\n            return g\n    return -1  # Should not be reached for a prime p\n\ndef _compute_discrete_logs(g, p):\n    \"\"\"Computes a mapping from residue to discrete logarithm base g mod p.\"\"\"\n    log_map = {1: 0}\n    val = 1\n    for i in range(1, p - 1):\n        val = (val * g) % p\n        log_map[val] = i\n    return log_map\n\ndef solve():\n    \"\"\"\n    Computes an approximation of the second moment of Dirichlet L-functions\n    at the central point for primitive characters modulo q.\n    \"\"\"\n    test_cases = [3, 17, 53]\n    results = []\n\n    # --- Discussion on Accuracy and Truncation ---\n    # The accuracy of the approximation depends on the truncation of the series.\n    # The weight W(n,q) = exp(-pi*n^2/q) decays rapidly. We truncate the sum\n    # at N_trunc such that the terms for n > N_trunc are negligible.\n    # W(N_trunc, q)  10^-16 => exp(-pi*N_trunc^2/q)  10^-16\n    # => -pi*N_trunc^2/q  -16*ln(10) ~= -36.8\n    # => N_trunc^2 > (36.8/pi)*q ~= 11.7*q\n    # => N_trunc > sqrt(11.7*q) ~= 3.42 * sqrt(q).\n    # We choose a constant C=4 for safety, setting N_trunc = ceil(4*sqrt(q)).\n    # The error in the sum S(chi) is dominated by the first omitted term, whose\n    # magnitude is ~ 1/sqrt(N_trunc) * W(N_trunc, q). For N_trunc ~ C*sqrt(q),\n    # this error scales roughly as q^(-1/4) * exp(-pi*C^2). The exponential\n    # factor ensures high accuracy, though the q^(-1/4) prefactor indicates a\n    # slow degradation of accuracy with increasing q for a fixed C.\n    # The moment itself is conjectured to grow as log(q), a very slow growth.\n    # Our numerical experiment provides data points to observe this trend at small q.\n    TRUNCATION_C = 4\n\n    for q in test_cases:\n        # Step 1: Find a primitive root and pre-compute discrete logarithms\n        g = _find_primitive_root(q)\n        log_g_map = _compute_discrete_logs(g, q)\n        # Convert dict to numpy array for fast vectorized lookup\n        log_g_array = np.zeros(q, dtype=int)\n        for val, log in log_g_map.items():\n            log_g_array[val] = log\n\n        # Step 2: Set numerical parameters\n        N_trunc = int(np.ceil(TRUNCATION_C * np.sqrt(q)))\n        \n        # Step 3: Pre-compute values for efficiency\n        # For the surrogate L_num sum S(chi)\n        n_vals = np.arange(1, N_trunc + 1)\n        weights = np.exp(-np.pi * n_vals**2 / q)\n        sqrt_n_inv = 1.0 / np.sqrt(n_vals)\n        n_mod_q = n_vals % q\n        \n        # For the Gauss sum\n        exp_vals_gauss = np.exp(2j * np.pi * np.arange(q) / q)\n        a_gauss_sum = np.arange(1, q)\n        t_gauss = log_g_array[a_gauss_sum]\n\n        total_sq_mag = 0.0\n        \n        # Step 4: Iterate over all primitive characters (k=1 to q-2)\n        for k in range(1, q - 1):\n            # A. Compute the character values chi_k(n) for n = 1..N_trunc\n            t_vals = log_g_array[n_mod_q]\n            chi_vals_s = np.exp(2j * np.pi * k * t_vals / (q - 1))\n            chi_vals_s[n_mod_q == 0] = 0.0  # chi(n)=0 if q|n\n\n            # B. Compute the sum S(chi_k)\n            S_k = np.sum(chi_vals_s * sqrt_n_inv * weights)\n            \n            # C. Compute the Gauss sum tau(chi_k)\n            chi_vals_gauss = np.exp(2j * np.pi * k * t_gauss / (q - 1))\n            tau_k = np.sum(chi_vals_gauss * exp_vals_gauss[1:])\n\n            # D. Compute the parity and root number epsilon(chi_k)\n            # Parity a_k is determined by chi_k(-1) = (-1)^a_k.\n            # Since log_g(-1) = (q-1)/2, chi_k(-1) = exp(pi*i*k) = (-1)^k.\n            # Thus, the parity parameter a_k is k mod 2.\n            a_k = k % 2\n            epsilon_k = (1j)**(-a_k) * tau_k / np.sqrt(q)\n\n            # E. Compute the numerical surrogate L_num and its squared magnitude\n            # L_num = S(chi) + epsilon(chi) * S(bar(chi))\n            # S(bar(chi)) is sum over bar(chi(n)), which is conj(S(chi)) as W,n are real.\n            L_num_k = S_k + epsilon_k * np.conj(S_k)\n            total_sq_mag += np.abs(L_num_k)**2\n\n        # Step 5: Calculate the final average M_2(q)\n        if q > 2:\n            M2_q = total_sq_mag / (q - 2)\n        else: # For q=3, q-2=1. Handles this case correctly.\n            M2_q = total_sq_mag\n            \n        results.append(M2_q)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3018766"}]}