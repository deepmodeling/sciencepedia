{"hands_on_practices": [{"introduction": "泰特-沙法列维奇群的研究在代数上主要依赖于下降法。此方法将椭圆曲线的有理点群 $E(\\mathbb{Q})$ 的计算问题，转化为研究一个更容易计算的塞尔默群 $\\mathrm{Sel}^{(n)}(E/\\mathbb{Q})$。这个练习将引导你运用下降法中的基本短正合列，它揭示了塞尔默群、莫德尔-韦伊群以及泰特-沙法列维奇群之间的深刻联系 [@problem_id:3029567]。通过一个假设的下降计算结果，你将能够精确确定$Ш(E/\\mathbb{Q})$的 $n$-挠部分的大小，从而亲身体会这一核心代数工具的威力。", "problem": "设 $E/\\mathbb{Q}$ 是一条椭圆曲线，并令 $Ш(E/\\mathbb{Q})$ 表示其泰特-沙法列维奇群（Tate–Shafarevich group）。对于一个正整数 $n$，$n$-塞尔默群 $\\mathrm{Sel}^{(n)}(E/\\mathbb{Q})$ 被定义为伽罗瓦上同调群 $H^{1}(\\mathbb{Q},E[n])$ 的子群，该子群由对于 $\\mathbb{Q}$ 的所有位 $v$ 都局部地落在库默映射 $E(\\mathbb{Q}_{v})/nE(\\mathbb{Q}_{v}) \\to H^{1}(\\mathbb{Q}_{v},E[n])$ 的像中的类组成。从 $\\mathbb{Q}$ 上的群概形的库默正合序列出发，\n$$\n0 \\longrightarrow E[n] \\longrightarrow E \\xrightarrow{[n]} E \\longrightarrow 0,\n$$\n应用伽罗瓦上同调以及整体到局部的比较，我们得到以下正合序列\n$$\n0 \\longrightarrow E(\\mathbb{Q})/nE(\\mathbb{Q}) \\longrightarrow \\mathrm{Sel}^{(n)}(E/\\mathbb{Q}) \\longrightarrow Ш(E/\\mathbb{Q})[n] \\longrightarrow 0,\n$$\n其中 $Ш(E/\\mathbb{Q})[n]$ 表示 $Ш(E/\\mathbb{Q})$ 的 $n$-挠子群。\n\n假设 $E/\\mathbb{Q}$ 的以下算术不变量已通过显式下降计算确定：\n- 莫德尔-韦伊群 $E(\\mathbb{Q})$ 的秩为 $r=0$，其挠子群为 $E(\\mathbb{Q})_{\\mathrm{tors}} \\simeq (\\mathbb{Z}/2\\mathbb{Z})^{2}$，因此 $|E(\\mathbb{Q})_{\\mathrm{tors}}|=4$，并且挠子群被乘以 $2$ 湮灭。\n- 一次完全二次下降得到 $|\\mathrm{Sel}^{(2)}(E/\\mathbb{Q})|=2^{5}$。\n- 一次完全四次下降得到 $|\\mathrm{Sel}^{(4)}(E/\\mathbb{Q})|=2^{7}$。\n\n仅使用上述基本定义及其推论，确定 $2$-挠子群 $Ш(E/\\mathbb{Q})[2]$ 的确切基数。将最终结果表示为一个精确整数（不需要也不允许四舍五入）。", "solution": "该问题要求计算给定椭圆曲线 $E/\\mathbb{Q}$ 的泰特-沙法列维奇群的 $2$-挠子群 $Ш(E/\\mathbb{Q})[2]$ 的基数。解答过程通过分析连接莫德尔-韦伊群、塞尔默群和泰特-沙法列维奇群的基本短正合序列来进行。\n\n问题提供了以下从伽罗瓦上同调导出的短正合序列：\n$$\n0 \\longrightarrow E(\\mathbb{Q})/nE(\\mathbb{Q}) \\longrightarrow \\mathrm{Sel}^{(n)}(E/\\mathbb{Q}) \\longrightarrow Ш(E/\\mathbb{Q})[n] \\longrightarrow 0\n$$\n该序列对任何正整数 $n$ 都成立。由于此序列中的所有群都是有限阿贝尔群，我们可以关联它们的阶。正合性意味着中间群的阶是两端群的阶的乘积：\n$$\n|\\mathrm{Sel}^{(n)}(E/\\mathbb{Q})| = |E(\\mathbb{Q})/nE(\\mathbb{Q})| \\cdot |Ш(E/\\mathbb{Q})[n]|\n$$\n我们关心的是 $n=2$ 的情况。方程变为：\n$$\n|\\mathrm{Sel}^{(2)}(E/\\mathbb{Q})| = |E(\\mathbb{Q})/2E(\\mathbb{Q})| \\cdot |Ш(E/\\mathbb{Q})[2]|\n$$\n我们可以重新整理这个方程来求解所求量 $|Ш(E/\\mathbb{Q})[2]|$：\n$$\n|Ш(E/\\mathbb{Q})[2]| = \\frac{|\\mathrm{Sel}^{(2)}(E/\\mathbb{Q})|}{|E(\\mathbb{Q})/2E(\\mathbb{Q})|}\n$$\n问题给出了 $2$-塞尔默群的大小：$|\\mathrm{Sel}^{(2)}(E/\\mathbb{Q})| = 2^5 = 32$。\n\n下一步是确定群 $E(\\mathbb{Q})/2E(\\mathbb{Q})$ 的阶。我们已知莫德尔-韦伊群 $E(\\mathbb{Q})$ 的结构。其秩为 $r=0$，其挠子群为 $E(\\mathbb{Q})_{\\mathrm{tors}} \\simeq (\\mathbb{Z}/2\\mathbb{Z})^2$。\n莫德尔-韦伊群的一般结构是 $E(\\mathbb{Q}) \\simeq \\mathbb{Z}^r \\oplus E(\\mathbb{Q})_{\\mathrm{tors}}$。由于秩 $r=0$，该群仅由其挠点组成：\n$$\nE(\\mathbb{Q}) = E(\\mathbb{Q})_{\\mathrm{tors}} \\simeq (\\mathbb{Z}/2\\mathbb{Z})^2\n$$\n这是一个阶为 $|(\\mathbb{Z}/2\\mathbb{Z})^2| = 4$ 的有限群。\n为了求商群 $E(\\mathbb{Q})/2E(\\mathbb{Q})$ 的阶，我们首先确定子群 $2E(\\mathbb{Q})$，它是 $E(\\mathbb{Q})$ 在乘以 $2$ 映射下的像。由于每个元素 $P \\in E(\\mathbb{Q})$ 的阶都整除 $2$，对于所有 $P \\in E(\\mathbb{Q})$，我们有 $2P=O$，其中 $O$ 是单位元（无穷远点）。因此，该映射的像是平凡群：\n$$\n2E(\\mathbb{Q}) = \\{O\\}\n$$\n于是商群为：\n$$\nE(\\mathbb{Q})/2E(\\mathbb{Q}) = E(\\mathbb{Q})/\\{O\\} \\simeq E(\\mathbb{Q})\n$$\n因此，该群的阶为：\n$$\n|E(\\mathbb{Q})/2E(\\mathbb{Q})| = |E(\\mathbb{Q})| = |(\\mathbb{Z}/2\\mathbb{Z})^2| = 4 = 2^2\n$$\n现在我们有了计算 $Ш(E/\\mathbb{Q})[2]$ 的阶所需的所有要素：\n$$\n|Ш(E/\\mathbb{Q})[2]| = \\frac{|\\mathrm{Sel}^{(2)}(E/\\mathbb{Q})|}{|E(\\mathbb{Q})/2E(\\mathbb{Q})|} = \\frac{2^5}{2^2} = 2^{5-2} = 2^3 = 8\n$$\n问题还提供了 $4$-塞尔默群的大小，$|\\mathrm{Sel}^{(4)}(E/\\mathbb{Q})|=2^7$。虽然这对上述计算并非严格必需，但此信息可用于验证算术数据的一致性。对 $n=4$ 使用相同的逻辑：\n$$\n|Ш(E/\\mathbb{Q})[4]| = \\frac{|\\mathrm{Sel}^{(4)}(E/\\mathbb{Q})|}{|E(\\mathbb{Q})/4E(\\mathbb{Q})|}\n$$\n群 $4E(\\mathbb{Q})$ 是 $E(\\mathbb{Q})$ 在乘以 $4$ 映射下的像。由于对所有 $P \\in E(\\mathbb{Q})$ 都有 $2P=O$，因此 $4P=2(2P)=2(O)=O$。于是 $4E(\\mathbb{Q}) = \\{O\\}$，所以 $|E(\\mathbb{Q})/4E(\\mathbb{Q})|=|E(\\mathbb{Q})|=4=2^2$。\n这就得到了泰特-沙法列维奇群的 $4$-挠子群的大小：\n$$\n|Ш(E/\\mathbb{Q})[4]| = \\frac{2^7}{2^2} = 2^5 = 32\n$$\n对于任意有限阿贝尔群 $A$，其 $4$-挠子群 $A[4]$ 和 $2$-挠子群 $A[2]$ 是相关的。如果 $A[4]$ 的结构为 $(\\mathbb{Z}/4\\mathbb{Z})^a \\oplus (\\mathbb{Z}/2\\mathbb{Z})^b$，则其阶为 $4^a 2^b = 2^{2a+b}$。其 $2$-挠子群 $A[2]$ 同构于 $(\\mathbb{Z}/2\\mathbb{Z})^{a+b}$，阶为 $2^{a+b}$。\n将此应用于 $A=Ш(E/\\mathbb{Q})$，我们有：\n$|Ш(E/\\mathbb{Q})[4]| = 2^{2a+b} = 32 = 2^5$，所以 $2a+b=5$。\n$|Ш(E/\\mathbb{Q})[2]| = 2^{a+b} = 8 = 2^3$，所以 $a+b=3$。\n解这个线性方程组得到 $a=2$ 和 $b=1$。这意味着 $4$-挠子群的结构是 $Ш(E/\\mathbb{Q})[4] \\simeq (\\mathbb{Z}/4\\mathbb{Z})^2 \\oplus \\mathbb{Z}/2\\mathbb{Z}$。这是一个一致的结果，进一步增强了计算的可信度。然而，主要的计算只需要 $n=2$ 的数据。\n\n确定的 $2$-挠子群的基数为 $8$。", "answer": "$$\\boxed{8}$$", "id": "3029567"}, {"introduction": "从代数方法转向分析领域，伯奇和斯温纳顿-戴尔 (Birch and Swinnerton-Dyer, BSD) 猜想为我们提供了研究泰特-沙法列维奇群的另一强大视角。BSD 猜想断言，椭圆曲线的 $L$-函数在 $s=1$ 点的性质与曲线的若干个关键代数不变量（包括 $Ш$ 群的阶）之间存在着精确的等式关系。这个练习提供了一个应用 BSD 猜想的经典案例，你将在一个秩为零的具体情形下，利用已知的 $L$-函数值和其他代数信息来直接计算出 $Ш$ 群的阶 [@problem_id:3029564]。这清晰地展示了分析工具如何能够解决纯代数方法难以企及的问题。", "problem": "设 $E/\\mathbb{Q}$ 是由短 Weierstrass 方程 $y^{2}=x^{3}-x$ 给出的椭圆曲线。曲线 $E$ 具有被高斯整数 $\\mathbb{Z}[i]$ 的复乘 (CM)，并且在素数 $p=2$ 之外有好处约化；特别地，对于素数 $p \\equiv 3 \\pmod{4}$，它有超奇异约化。记 $Ш(E/\\mathbb{Q})$ 为 $E$ 在 $\\mathbb{Q}$ 上的泰特-沙法列维奇群，其定义为从第一伽罗瓦上同调群 $H^{1}(\\mathbb{Q},E)$ 到对 $\\mathbb{Q}$ 的所有位 $v$ 的乘积 $\\prod_{v} H^{1}(\\mathbb{Q}_{v},E)$ 的局部化映射的核。设 $\\Omega_{E}$ 为实内龙周期，$\\prod_{p} c_{p}$ 为对所有有限素数的玉河数的乘积，并用 $E(\\mathbb{Q})_{\\mathrm{tors}}$ 表示 $E(\\mathbb{Q})$ 的挠子群。\n\n给定以下事实，对于此 CM 曲线，这些事实都是标准的，并且可以根据定义以及极小模型和约化理论独立验证：\n- $E(\\mathbb{Q})$ 的莫德尔-韦伊秩为 $0$，因此其正则子为 $1$。\n- 挠子群的阶为 $|E(\\mathbb{Q})_{\\mathrm{tors}}|=4$。\n- 唯一的坏素数是 $p=2$，并且玉河数的乘积满足 $\\prod_{p} c_{p}=2$。\n- 解析 $L$-函数满足 $L(E,1)=\\dfrac{\\Omega_{E}}{8}$。\n\n假设对于 $\\mathbb{Q}$ 上的 CM 椭圆曲线的伯奇-斯温纳顿-戴尔 (BSD) 定理的秩为零情形成立（这在此背景下是已知的），因此首项 $L(E,1)$ 与包含 $\\Omega_{E}$、$\\prod_{p}c_{p}$、$|E(\\mathbb{Q})_{\\mathrm{tors}}|$ 和 $|Ш(E/\\mathbb{Q})|$ 的代数表达式一致。\n\n计算 $|Ш(E/\\mathbb{Q})|$ 的精确值。以单个整数形式给出答案（无单位，不四舍五入）。", "solution": "该问题要求计算由方程 $y^2 = x^3 - x$ 给出的椭圆曲线 $E$ 的泰特-沙法列维奇群的阶，记作 $|Ш(E/\\mathbb{Q})|$。解答依赖于应用伯奇-斯温纳顿-戴尔 (BSD) 猜想，对于此特定曲线，该猜想已被证实为一个定理。\n\nBSD 猜想的一般形式将哈斯-韦伊 $L$-函数 $L(E,s)$ 在点 $s=1$ 处的首项与曲线的几个代数不变量联系起来。其完整陈述为：\n$$ \\lim_{s \\to 1} \\frac{L(E,s)}{(s-1)^{r}} = \\frac{\\Omega_{E} \\cdot \\mathrm{Reg}_{E/\\mathbb{Q}} \\cdot \\prod_{p} c_{p} \\cdot |Ш(E/\\mathbb{Q})|}{|E(\\mathbb{Q})_{\\mathrm{tors}}|^{2}} $$\n其中：\n- $r$ 是莫德尔-韦伊群 $E(\\mathbb{Q})$ 的秩。\n- $L(E,s)$ 是 $E$ 的哈斯-韦伊 $L$-函数。\n- $\\Omega_{E}$ 是 $E$ 的实内龙周期。\n- $\\mathrm{Reg}_{E/\\mathbb{Q}}$ 是 $E(\\mathbb{Q})$ 的正则子。\n- $\\prod_{p} c_{p}$ 是对所有有限素数 $p$ 的玉河数 $c_p$ 的乘积。\n- $|Ш(E/\\mathbb{Q})|$ 是 $E$ 在 $\\mathbb{Q}$ 上的泰特-沙法列维奇群的阶。\n- $|E(\\mathbb{Q})_{\\mathrm{tors}}|$ 是 $E(\\mathbb{Q})$ 的挠子群的阶。\n\n问题为曲线 $y^2 = x^3 - x$ 提供了这些量中的每一个的具体值。我们已知 $E(\\mathbb{Q})$ 的秩 $r=0$。当秩为零时，莫德尔-韦伊群 $E(\\mathbb{Q})$ 是有限的，仅由挠点组成。在这种情况下，BSD 公式大大简化。\n\n对于 $r=0$，左侧的极限变为 $L$-函数在 $s=1$ 处的值：\n$$ \\lim_{s \\to 1} \\frac{L(E,s)}{(s-1)^{0}} = L(E,1) $$\n同样，对于秩 $r=0$ 的群，正则子定义为 $\\mathrm{Reg}_{E/\\mathbb{Q}} = 1$。\n\n将这些代入一般的 BSD 公式，我们得到秩为零曲线的特殊形式：\n$$ L(E,1) = \\frac{\\Omega_{E} \\cdot 1 \\cdot \\prod_{p} c_{p} \\cdot |Ш(E/\\mathbb{Q})|}{|E(\\mathbb{Q})_{\\mathrm{tors}}|^{2}} $$\n\n我们在问题陈述中得到了以下值：\n- 莫德尔-韦伊秩为 $r=0$。\n- 挠子群的阶为 $|E(\\mathbb{Q})_{\\mathrm{tors}}| = 4$。\n- 玉河数的乘积为 $\\prod_{p} c_{p} = 2$。\n- 解析 $L$-函数的值为 $L(E,1) = \\frac{\\Omega_{E}}{8}$。\n\n我们现在可以将这些已知值代入秩为零的 BSD 公式中，以求解 $|Ш(E/\\mathbb{Q})|$：\n$$ \\frac{\\Omega_{E}}{8} = \\frac{\\Omega_{E} \\cdot 2 \\cdot |Ш(E/\\mathbb{Q})|}{4^{2}} $$\n\n实周期 $\\Omega_{E}$ 是一个正实数，具体为 $\\Omega_E = \\int_1^\\infty \\frac{dx}{\\sqrt{x^3-x}}$，所以可以从等式两边消去。\n$$ \\frac{1}{8} = \\frac{2 \\cdot |Ш(E/\\mathbb{Q})|}{16} $$\n\n化简右侧的分数：\n$$ \\frac{1}{8} = \\frac{|Ш(E/\\mathbb{Q})|}{8} $$\n\n两边同乘以 $8$ 得到泰特-沙法列维奇群的阶：\n$$ |Ш(E/\\mathbb{Q})| = 1 $$\n\n因此，该椭圆曲线的泰特-沙法列维奇群是平凡的。", "answer": "$$\\boxed{1}$$", "id": "3029564"}, {"introduction": "泰特-沙法列维奇群的几何本质在于它衡量了哈斯原则（Hasse principle）的失效程度。$Ш$群中的每一个非平凡元素都对应着一个没有有理点、但在所有局部域（即实数域 $\\mathbb{R}$ 和所有 $p$-进数域 $\\mathbb{Q}_p$）上都有点的亏格为 1 的曲线。这个实践练习将理论付诸于代码，指导你实现一套算法来检验给定曲线的局部可解性和全局可解性 [@problem_id:3029554]。通过亲手编写程序来寻找哈斯原则的反例，你将对“什么是$Ш$群的元素”以及局部-全局原则的微妙之处获得具体而深入的理解。", "problem": "设 $E/\\mathbb{Q}$ 为一条椭圆曲线，泰特-沙法列维奇群（Tate-Shafarevich group，常记作西里尔字母 $Ш$）是 $E$ 上的主齐性空间的同构类群，这些主齐性空间在 $\\mathbb{Q}$ 的所有完备化上都是局部平凡的。$E$ 的一个主齐性空间 $C$ 是定义在 $\\mathbb{Q}$ 上的光滑、射影、几何整曲线，其上有一个定义在 $\\mathbb{Q}$ 上的 $E$ 的单纯传递作用。根据定义，$Ш(E/\\mathbb{Q})$ 中的一个元素 $[C]$ 由一条曲线 $C$ 表示，该曲线在 $\\mathbb{Q}$ 的每个完备化 $\\mathbb{Q}_v$ 上都有点（即对所有位 $v$，都有 $C(\\mathbb{Q}_v) \\neq \\emptyset$），但在 $\\mathbb{Q}$ 上没有有理点。\n\n本问题要求您对一小族在下降计算中自然出现的亏格为一的曲线，进行局部可解性和有理可解性的实验性和数值性研究：\n- 形如 $a x^3 + b y^3 + c z^3 = 0$ 的对角三次挠子（torsor），当 $a,b,c \\in \\mathbb{Z}$ 为非零且适当选择时，它们是光滑平面三次曲线，以及\n- 形如 $u^2 = d x^4 + e x^2 + f$ 的二元四次挠子，当右侧的四次式在 $\\overline{\\mathbb{Q}}$ 上有不同根时，它们是光滑射影亏格一曲线。\n\n您的程序必须实现以下基于原理的实验流程：\n1. 基本定义和准则：\n   - 局部域和局部点：对于 $\\mathbb{Q}$ 的一个位 $v$，如果 $C(\\mathbb{Q}_v) \\neq \\emptyset$，则称曲线 $C$ 在 $v$ 处是局部可解的，其中 $\\mathbb{Q}_\\infty = \\mathbb{R}$，对于素数 $p$，$\\mathbb{Q}_p$ 是 $p$-进数域。\n   - 通过同余判断局部可解性：$C(\\mathbb{Q}_p) \\neq \\emptyset$ 的一个必要条件是对于所有 $n$，都存在模 $p^n$ 的解；一个充分条件是存在一个模 $p$ 的非奇异解，根据亨泽尔引理（Hensel’s lemma），该解可以提升为 $\\mathbb{Q}_p$ 上的解。在数值实验中，在有限个素数集上测试模 $p$ 和 $p^2$ 的解，可为局部可解性提供强有力的证据。\n   - 实数可解性：对于对角三次曲线 $a x^3 + b y^3 + c z^3 = 0$，当至少有两个系数非零时，利用三次方的奇次幂性质通过符号抵消来展示实数解的存在。对于二元四次曲线 $u^2 = d x^4 + e x^2 + f$，分析实多项式 $g(x) = d x^4 + e x^2 + f$。如果 $d > 0$，则当 $|x| \\to \\infty$ 时 $g(x) \\to +\\infty$，因此 $g$ 可以取到任意大的正值，从而 $C(\\mathbb{R}) \\neq \\emptyset$。如果 $d  0$，则 $g$ 达到一个有限的上确界；通过 $g'(x) = 4 d x^3 + 2 e x$ 计算 $g(x)$ 的临界点来求得上确界。如果 $\\sup_{x \\in \\mathbb{R}} g(x)  0$，则 $C(\\mathbb{R}) = \\emptyset$。\n   - 有理可解性：$a x^3 + b y^3 + c z^3 = 0$ 上的一个有理点对应于一个非平凡整数解 $(x,y,z) \\in \\mathbb{Z}^3 \\setminus \\{(0,0,0)\\}$（在缩放意义下），而 $u^2 = d x^4 + e x^2 + f$ 上的有理点则对应于满足 $u^2 = d x^4 + e x^2 + f$ 的整数对 $(x,u)$。\n\n2. 对每个输入曲线 $C$ 的算法任务：\n   - 实数位测试：实现上述判断 $C(\\mathbb{R}) \\neq \\emptyset$ 的准则。如果 $C(\\mathbb{R}) = \\emptyset$，则 $C$ 不是处处局部可解的；立即将此情况分类为不在 $Ш$ 中。\n   - 有限位测试：对于指定有限集合中的每个素数 $p$，测试是否存在模 $p$ 和模 $p^2$ 的解。\n     - 对于 $a x^3 + b y^3 + c z^3 = 0 \\pmod{p^n}$，通过枚举 $x,y$ 形成留数集合 $a x^3 + b y^3 \\pmod{p^n}$，并检查对于某个 $z$，$-c z^3$ 是否在该集合中，以此来搜索解。记录任何找到的解，并通过验证梯度 $$(3 a x^2, 3 b y^2, 3 c z^2) \\not\\equiv (0,0,0) \\pmod{p}$$ 来检查模 $p$ 的非奇异性。如果存在模 $p$ 的非奇异解，则在 $\\mathbb{Q}_p$ 上的局部可解性成立；否则，在实践中，也接受模 $p^2$ 解的存在作为支持局部可解性的证据。\n     - 对于 $u^2 = d x^4 + e x^2 + f \\pmod{p^n}$，枚举 $x$ 并检查 $d x^4 + e x^2 + f$ 是否是模 $p^n$ 的平方数。对于模 $p$ 的非奇异性，验证 $$(2 u, - (4 d x^3 + 2 e x)) \\not\\equiv (0,0) \\pmod{p}$$。同上，接受模 $p^2$ 的解作为局部可解性的实验证据。\n   - 有理点搜索：对小的整数解进行有界穷举搜索：\n     - 对于对角三次曲线，在 $|x|,|y|,|z| \\leq B$ 的范围内搜索 $(x,y,z)$（排除 $(0,0,0)$），并检查 $a x^3 + b y^3 + c z^3 = 0$。\n     - 对于四次曲线，在 $|x|,|u| \\leq B$ 的范围内搜索 $(x,u)$，并检查 $u^2 = d x^4 + e x^2 + f$。\n     - 如果找到这样的解，则记录为有理可解。\n\n3. 分类规则：\n   - 如果局部可解性在任何测试的位（包括实数位）上失败，则输出 $0$。\n   - 如果（在给定界限内）找到有理点，证明其全局可解，则输出 $1$。\n   - 如果曲线在所有测试的位上都局部可解，但在给定界限内未找到有理点，则输出 $2$。这个结果将曲线标识为$Ш$的一个实验性“候选”元素，并认识到这只是数值证据而非证明。\n\n您必须为以下旨在检验不同行为的测试套件实现此算法：\n- 测试用例1（对角三次曲线，易于找到有理点）：$a=1$, $b=1$, $c=-1$；搜索界限 $B=60$；素数 $\\{2,3,5,7,11\\}$。\n- 测试用例2（对角三次曲线，经典的局部可解挠子）：$a=3$, $b=4$, $c=5$ (Selmer三次曲线)；搜索界限 $B=120$；素数 $\\{2,3,5,7,11\\}$。\n- 测试用例3（二元四次曲线，实数解障碍）：$d=-1$, $e=0$, $f=-1$；搜索界限 $B=80$；素数 $\\{2,3,5,7,11\\}$。\n- 测试用例4（二元四次曲线，明显的有理点）：$d=1$, $e=-5$, $f=4$；搜索界限 $B=80$；素数 $\\{2,3,5,7,11\\}$。\n\n最终输出规格：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，\"[result1,result2,result3,result4]\"）。每个结果必须是遵循上述分类规则的 $\\{0,1,2\\}$ 中的一个整数。不适用任何物理单位或角度单位，所有数值均为无量纲值。", "solution": "该问题要求一个实验性流程，根据两种特定形式——对角三次曲线和二元四次曲线——在实数、p-进数和有理数上的可解性性质对其进行分类。该分类可作为一种数值模拟，用于确定一条曲线是代表泰特-沙法列维奇群（$Ш$）中的平凡元素、非平凡元素，还是因局部不可解而无法成为$Ш$的元素。\n\n如果一条曲线 $C$ 在每个完备化 $\\mathbb{Q}_v$ 上都有点（即*局部可解*），但在 $\\mathbb{Q}$ 上没有点（即非*全局可解*），则它代表 $Ш(E/\\mathbb{Q})$ 中的一个元素。我们的任务是实现一个算法，对给定的一组曲线测试这些性质，并返回一个分类：\n- $0$：曲线在某个测试的位（实数或p-进数）上不局部可解。\n- $1$：曲线是全局可解的（找到了一个有理点）。\n- $2$：曲线在所有测试的位上似乎都是局部可解的，但在指定的搜索界限内未找到有理点。这标识了$Ш$中非平凡元素的实验性候选者。\n\n该算法通过为所提供的两种曲线类型创建不同的过程来实现。\n\n### 对角三次曲线：$ax^3 + by^3 + cz^3 = 0$\n\n1.  **实数可解性测试 ($C(\\mathbb{R}) \\neq \\emptyset$)**：对于非零整数系数 $a$、$b$ 和 $c$，方程 $ax^3 + by^3 + cz^3 = 0$ 总是拥有一个非平凡实数解。这是因为函数 $f(t) = t^3$ 是从 $\\mathbb{R}$ 到 $\\mathbb{R}$ 的满射。例如，可以为 $y$ 和 $z$ 固定非零实数值，比如 $y_0$ 和 $z_0$，然后通过 $x = \\sqrt[3]{(-by_0^3 - cz_0^3)/a}$ 来求解 $x$，这总是一个定义明确的实数。因此，这些曲线在 $\\mathbb{R}$ 上总是可解的。\n\n2.  **p-进数可解性测试 ($C(\\mathbb{Q}_p) \\neq \\emptyset$)**：对于给定集合中的每个素数 $p$，我们测试局部可解性。根据Hensel引理，一个模 $p$ 的*非奇异*解的存在保证了在 $\\mathbb{Q}_p$ 中存在解。如果梯度向量 $(\\frac{\\partial F}{\\partial x}, \\frac{\\partial F}{\\partial y}, \\frac{\\partial F}{\\partial z}) = (3ax^2, 3by^2, 3cz^2)$ 在点 $(x_0, y_0, z_0)$ 处与 $(0,0,0) \\pmod{p}$ 不同余，则该点是模 $p$ 非奇异的。如果所有模 $p$ 的解都是奇异的（这在素数 $p$ 整除 $3abc$ 时会系统性地发生），我们便将任何非平凡的模 $p^2$ 解的存在作为在 $\\mathbb{Q}_p$ 中可解的强数值证据。对模解的搜索通过迭代 $x$ 和 $y$ 并使用哈希映射来寻找相应的 $z$ 得到优化。\n\n3.  **有理可解性测试 ($C(\\mathbb{Q}) \\neq \\emptyset$)**：我们在 $|x|, |y|, |z| \\leq B$ 的界限内，对满足 $ax^3 + by^3 + cz^3 = 0$ 的非平凡整数解 $(x,y,z) \\in \\mathbb{Z}^3 \\setminus \\{(0,0,0)\\}$ 进行有界搜索。该搜索通过在界限 $[-B, B]$ 内迭代 $x$ 和 $y$ 的整数值来实现，然后计算所需值 $cz^3 = -(ax^3+by^3)$。如果该值能被 $c$ 整除，且结果是一个完全立方数 $z^3$，其中 $|z| \\leq B$，则找到了一个有理点。\n\n### 二元四次曲线：$u^2 = dx^4 + ex^2 + f$\n\n1.  **实数可解性测试 ($C(\\mathbb{R}) \\neq \\emptyset$)**：当且仅当对于某个 $x \\in \\mathbb{R}$，多项式 $g(x) = dx^4 + ex^2 + f$ 非负时，存在实数解。\n    - 如果 $d > 0$，当 $|x| \\to \\infty$ 时 $g(x) \\to +\\infty$，这保证了 $g(x)$ 会取到非负值。曲线在 $\\mathbb{R}$ 上是可解的。\n    - 如果 $d  0$，当 $|x| \\to \\infty$ 时 $g(x) \\to -\\infty$。仅当 $g(x)$ 的全局最大值非负时，才存在实数解。我们通过检查 $g'(x) = 4dx^3 + 2ex = 0$ 的临界点来找到最大值。这发生在 $x=0$ 处，以及当 $-e/(2d) > 0$ 时可能发生在 $x = \\pm\\sqrt{-e/(2d)}$ 处。如果 $\\sup_{x \\in \\mathbb{R}} g(x)  0$，则曲线在 $\\mathbb{R}$ 上不可解。\n\n2.  **p-进数可解性测试 ($C(\\mathbb{Q}_p) \\neq \\emptyset$)**：原理与三次曲线相同。如果梯度向量 $(\\frac{\\partial F}{\\partial u}, \\frac{\\partial F}{\\partial x}) = (2u, -(4dx^3 + 2ex))$ 在点 $(u_0, x_0)$ 处与 $(0,0) \\pmod{p}$ 不同余，则该解是模 $p$ 非奇异的。我们搜索这样的点。如果只找到奇异解，则检查是否存在任何模 $p^2$ 的解。搜索过程包括迭代 $x \\pmod{p^n}$，并检查 $dx^4+ex^2+f$ 是否是模 $p^n$ 的二次剩余。\n\n3.  **有理可解性测试 ($C(\\mathbb{Q}) \\neq \\emptyset$)**：我们在界限 $B$ 内搜索整数解 $(x, u)$。由于 $x$ 以偶数次幂出现，我们只需搜索 $x \\in [0, B]$。对于每个 $x$，我们计算 $v = dx^4 + ex^2 + f$。如果 $v \\geq 0$ 且是一个完全平方数，比如 $v=u^2$，并且 $|u| \\leq B$，那么就找到了一个有理点。\n\n通过根据指定的分类规则组合这些测试，我们可以分析测试套件中的每条曲线。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef get_cbrt_if_int(n):\n    \"\"\"\n    Returns the integer cube root of n if it exists, otherwise None.\n    \"\"\"\n    if n == 0:\n        return 0\n    # np.cbrt handles signs correctly.\n    root = np.cbrt(n)\n    # Check if the root is an integer within a small tolerance for float inaccuracies.\n    i_root = int(round(root))\n    if i_root**3 == n:\n        return i_root\n    return None\n\ndef classify_cubic(a, b, c, B, primes):\n    \"\"\"\n    Classifies a diagonal cubic curve.\n    Returns 0 (local obstruction), 1 (rational point found), or 2 (candidate).\n    \"\"\"\n    # Step 1: Real Place Test\n    # For a*x^3 + b*y^3 + c*z^3 = 0, with a,b,c non-zero, a non-trivial\n    # real solution always exists. So, this test always passes.\n\n    # Step 2: Finite Place (p-adic) Tests\n    for p in primes:\n        is_locally_soluble_at_p = False\n        \n        # Test for a non-singular solution modulo p\n        cz3_map = { (c * pow(z, 3, p)) % p: z for z in range(p - 1, -1, -1) }\n        found_nonsingular_sol = False\n        for x in range(p):\n            for y in range(p):\n                target = (-a * pow(x, 3, p) - b * pow(y, 3, p)) % p\n                if target in cz3_map:\n                    z = cz3_map[target]\n                    if x != 0 or y != 0 or z != 0:\n                        # Gradient is (3ax^2, 3by^2, 3cz^2)\n                        grad_x = (3 * a * pow(x, 2, p)) % p\n                        grad_y = (3 * b * pow(y, 2, p)) % p\n                        grad_z = (3 * c * pow(z, 2, p)) % p\n                        if grad_x != 0 or grad_y != 0 or grad_z != 0:\n                            is_locally_soluble_at_p = True\n                            found_nonsingular_sol = True\n                            break\n            if found_nonsingular_sol:\n                break\n        \n        if not is_locally_soluble_at_p:\n            # If no non-singular solution mod p, test for any non-trivial solution mod p^2\n            M = p * p\n            cz3_map_p2 = { (c * pow(z, 3, M)) % M: z for z in range(M - 1, -1, -1) }\n            found_p2_sol = False\n            for x in range(M):\n                for y in range(M):\n                    target = (-a * pow(x, 3, M) - b * pow(y, 3, M)) % M\n                    if target in cz3_map_p2:\n                        z = cz3_map_p2[target]\n                        if x != 0 or y != 0 or z != 0:\n                            is_locally_soluble_at_p = True\n                            found_p2_sol = True\n                            break\n                if found_p2_sol:\n                    break\n\n        if not is_locally_soluble_at_p:\n            return 0 # Fails local solubility test at p\n\n    # Step 3: Rational Point Search\n    for x in range(-B, B + 1):\n        for y in range(-B, B + 1):\n            target_val = -a * x**3 - b * y**3\n            if c != 0 and target_val % c == 0:\n                z3_cand = target_val // c\n                z = get_cbrt_if_int(z3_cand)\n                if z is not None and abs(z) = B:\n                    if x != 0 or y != 0 or z != 0:\n                        return 1 # Found a rational point\n\n    return 2 # Locally soluble, no rational point found\n\ndef classify_quartic(d, e, f, B, primes):\n    \"\"\"\n    Classifies a binary quartic curve.\n    Returns 0 (local obstruction), 1 (rational point found), or 2 (candidate).\n    \"\"\"\n    # Step 1: Real Place Test\n    # Let g(x) = d*x^4 + e*x^2 + f.\n    if d > 0:\n        pass # g(x) -> +inf as |x| -> inf, so real solution exists.\n    else: # d = 0\n        if d == 0: # Not in test suite but handle for completeness\n            if e >= 0 and f  0:\n                pass # Has real solutions, e.g. u^2=x^2-1\n            elif e  0:\n                return 0 # u^2 = negative constant or decays to -inf\n            elif f  0: # e=0, f0\n                return 0\n        else: # d  0\n            # g(x) -> -inf. Check supremum. g'(x) = 2x(2dx^2 + e).\n            max_g = float(f) # Value at x=0\n            if -e / (2 * d) > 0:\n                x_sq_crit = -e / (2 * d)\n                g_crit = d * x_sq_crit**2 + e * x_sq_crit + f\n                max_g = max(max_g, g_crit)\n            if max_g  0:\n                return 0 # No real solution\n    \n    # Step 2: Finite Place (p-adic) Tests\n    for p in primes:\n        is_locally_soluble_at_p = False\n\n        # Test for a non-singular solution modulo p\n        mod_sqrt_map = {pow(u, 2, p): u for u in range(p)}\n        found_nonsingular_sol = False\n        for x in range(p):\n            rhs = (d * pow(x, 4, p) + e * pow(x, 2, p) + f) % p\n            if rhs in mod_sqrt_map:\n                u = mod_sqrt_map[rhs]\n                # Gradient is (2u, -(4dx^3+2ex))\n                grad_x = (- (4 * d * pow(x, 3, p) + 2 * e * x)) % p\n                if (2 * u) % p != 0 or grad_x != 0:\n                    is_locally_soluble_at_p = True\n                    found_nonsingular_sol = True\n                    break\n\n        if not found_nonsingular_sol:\n            # Test for any solution mod p^2\n            M = p * p\n            squares_p2 = {pow(i, 2, M) for i in range(M)}\n            for x in range(M):\n                rhs = (d * pow(x, 4, M) + e * pow(x, 2, M) + f) % M\n                if rhs in squares_p2:\n                    is_locally_soluble_at_p = True\n                    break\n        \n        if not is_locally_soluble_at_p:\n            return 0 # Fails local solubility test at p\n\n    # Step 3: Rational Point Search\n    for x in range(B + 1):\n        val = d * x**4 + e * x**2 + f\n        if val >= 0:\n            u_cand = np.sqrt(val)\n            if u_cand == int(u_cand):\n                u = int(u_cand)\n                if u = B:\n                    return 1 # Found a rational point\n\n    return 2 # Locally soluble, no rational point found\n\ndef solve():\n    \"\"\"\n    Main function to run the analysis on the test suite.\n    \"\"\"\n    test_cases = [\n        {'type': 'cubic', 'a': 1, 'b': 1, 'c': -1, 'B': 60, 'primes': [2, 3, 5, 7, 11]},\n        {'type': 'cubic', 'a': 3, 'b': 4, 'c': 5, 'B': 120, 'primes': [2, 3, 5, 7, 11]},\n        {'type': 'quartic', 'd': -1, 'e': 0, 'f': -1, 'B': 80, 'primes': [2, 3, 5, 7, 11]},\n        {'type': 'quartic', 'd': 1, 'e': -5, 'f': 4, 'B': 80, 'primes': [2, 3, 5, 7, 11]},\n    ]\n\n    results = []\n    for case in test_cases:\n        if case['type'] == 'cubic':\n            result = classify_cubic(case['a'], case['b'], case['c'], case['B'], case['primes'])\n        else: # quartic\n            result = classify_quartic(case['d'], case['e'], case['f'], case['B'], case['primes'])\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3029554"}]}