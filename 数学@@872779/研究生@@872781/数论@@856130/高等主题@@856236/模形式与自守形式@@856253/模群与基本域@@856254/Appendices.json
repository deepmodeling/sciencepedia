{"hands_on_practices": [{"introduction": "要真正掌握模群的结构，最好的方法莫过于亲自动手计算。这个练习将指导你探索上半平面 $\\mathbb{H}$ 中的一个特殊点：$z=i$。通过求解不动点方程并施加行列式为1的整数矩阵约束，你将揭示出在模群 $\\mathrm{PSL}(2,\\mathbb{Z})$ 中保持点 $i$ 不变的子群（即稳定子群）的完整结构。[@problem_id:3028047]", "problem": "设 $PSL(2,\\mathbb{Z})$ 表示整数上的2阶射影特殊线性群，即特殊线性群 $SL(2,\\mathbb{Z})$ 对其中心 $\\{\\pm I\\}$ 的商群，其中 $I$ 是单位矩阵。考虑 $PSL(2,\\mathbb{Z})$ 通过由矩阵 $M=\\begin{pmatrix} a & b \\\\ c & d \\end{pmatrix}\\in SL(2,\\mathbb{Z})$ 诱导的莫比乌斯变换在复上半平面 $\\mathbb{H}=\\{z\\in\\mathbb{C}:\\operatorname{Im}(z)>0\\}$ 上的作用，其作用方式为 $z\\mapsto \\dfrac{az+b}{cz+d}$。点 $z\\in\\mathbb{H}$ 的稳定子群定义为 $\\mathrm{Stab}_{PSL(2,\\mathbb{Z})}(z)=\\{[M]\\in PSL(2,\\mathbb{Z}) : \\dfrac{az+b}{cz+d}=z\\}$，其中 $[M]$ 表示 $M$ 在 $PSL(2,\\mathbb{Z})$ 中的等价类。\n\n仅从这些定义和对 $M\\in SL(2,\\mathbb{Z})$ 的条件 $\\det M = ad - bc = 1$ 出发，通过求解不动点方程 $i=\\dfrac{ai+b}{ci+d}$（其中 $a,b,c,d\\in\\mathbb{Z}$）并强制行列式条件，来确定点 $i\\in\\mathbb{H}$ 的稳定子群。然后推断出 $\\mathrm{Stab}_{PSL(2,\\mathbb{Z})}(i)$ 在 $PSL(2,\\mathbb{Z})$ 中的阶。请以单个精确整数形式提供你的最终答案。", "solution": "该问题是有效的，因为它在数学上是适定的、有科学依据的且客观的。它提出了一个模群理论中的标准任务。我们从给定的定义开始着手解决它。\n\n设 $[M] \\in \\mathrm{Stab}_{PSL(2,\\mathbb{Z})}(i)$ 是点 $i \\in \\mathbb{H}$ 的稳定子群中的一个元素。这个元素是 $SL(2,\\mathbb{Z})$ 中矩阵的一个等价类。设 $M = \\begin{pmatrix} a & b \\\\ c & d \\end{pmatrix}$ 是这个等价类的一个代表，其中 $a, b, c, d \\in \\mathbb{Z}$ 且行列式为 $\\det(M) = ad - bc = 1$。\n\n$i$ 的稳定子群中元素的定义条件是 $M$ 在 $i$ 上的作用使 $i$ 保持不变：\n$$ \\frac{ai+b}{ci+d} = i $$\n为了求解整数系数 $a,b,c,d$，我们对这个方程进行变换。两边同时乘以 $ci+d$ 得：\n$$ ai+b = i(ci+d) $$\n$$ ai+b = ci^2 + di $$\n由于 $i^2 = -1$，这可以简化为：\n$$ ai+b = -c + di $$\n这是一个复数方程。由于 $a, b, c, d$ 是整数（因此是实数），我们可以令方程两边的实部和虚部分别相等。\n\n令实部相等：\n$$ b = -c $$\n令虚部相等：\n$$ a = d $$\n对于任何固定点 $i$ 的矩阵 $M \\in SL(2,\\mathbb{Z})$，这两个条件都必须成立。将这些条件代入矩阵 $M$ 的一般形式，我们发现它必须具有以下结构：\n$$ M = \\begin{pmatrix} a & b \\\\ -b & a \\end{pmatrix} $$\n对于某些整数 $a$ 和 $b$。\n\n接下来，我们强制要求 $M \\in SL(2,\\mathbb{Z})$，这意味着它的行列式必须为 $1$。\n$$ \\det(M) = ad - bc = a(a) - b(-b) = a^2 + b^2=1 $$\n我们必须找到丢番图方程 $a^2 + b^2 = 1$ 的所有整数解 $(a,b)$。由于 $a$ 和 $b$ 是整数，$a^2$ 和 $b^2$ 必须是非负整数。两个非负整数之和为 $1$ 的唯一可能是其中一个为 $1$ 而另一个为 $0$。这导致 $(a, b)$ 有四种可能的组合：\n1. $a = 1, b = 0$\n2. $a = -1, b = 0$\n3. $a = 0, b = 1$\n4. $a = 0, b = -1$\n\n这四个解对应于 $SL(2,\\mathbb{Z})$ 中固定点 $i$ 的四个不同矩阵：\n1. 对于 $(a,b)=(1,0)$，我们得到 $M_1 = \\begin{pmatrix} 1 & 0 \\\\ 0 & 1 \\end{pmatrix} = I$。\n2. 对于 $(a,b)=(-1,0)$，我们得到 $M_2 = \\begin{pmatrix} -1 & 0 \\\\ 0 & -1 \\end{pmatrix} = -I$。\n3. 对于 $(a,b)=(0,1)$，我们得到 $M_3 = \\begin{pmatrix} 0 & 1 \\\\ -1 & 0 \\end{pmatrix}$。\n4. 对于 $(a,b)=(0,-1)$，我们得到 $M_4 = \\begin{pmatrix} 0 & -1 \\\\ 1 & 0 \\end{pmatrix}$。\n\n这四个矩阵的集合 $\\{I, -I, M_3, M_4\\}$ 构成了群 $SL(2,\\mathbb{Z})$ 中 $i$ 的稳定子群，记为 $\\mathrm{Stab}_{SL(2,\\mathbb{Z})}(i)$。\n\n问题要求的是 $PSL(2,\\mathbb{Z})$ 中的稳定子群，这是一个商群 $PSL(2,\\mathbb{Z}) = SL(2,\\mathbb{Z})/\\{\\pm I\\}$。在这个群中，一个元素是一个等价类 $[M] = \\{M, -M\\}$。因此，我们必须找到我们找到的四个矩阵所对应的不同等价类。\n\n- 矩阵 $M_1 = I$ 和 $M_2 = -I$ 互为负矩阵。它们形成一个单一的等价类 $[I] = \\{I, -I\\}$。这是群 $PSL(2,\\mathbb{Z})$ 的单位元。\n\n- 矩阵 $M_3 = \\begin{pmatrix} 0 & 1 \\\\ -1 & 0 \\end{pmatrix}$ 和 $M_4 = \\begin{pmatrix} 0 & -1 \\\\ 1 & 0 \\end{pmatrix}$ 也互为负矩阵，因为 $-M_3 = -\\begin{pmatrix} 0 & 1 \\\\ -1 & 0 \\end{pmatrix} = \\begin{pmatrix} 0 & -1 \\\\ 1 & 0 \\end{pmatrix} = M_4$。因此，它们形成另一个单一的等价类 $[M_3] = \\{M_3, M_4\\}$。\n\n因此，稳定子群 $\\mathrm{Stab}_{PSL(2,\\mathbb{Z})}(i)$ 由两个完全不同的元素组成：等价类 $[I]$ 和等价类 $[M_3]$。\n\n群的阶定义为它所包含的元素数量。子群 $\\mathrm{Stab}_{PSL(2,\\mathbb{Z})}(i)$ 有两个元素。因此，$\\mathrm{Stab}_{PSL(2,\\mathbb{Z})}(i)$ 的阶是 $2$。", "answer": "$$\\boxed{2}$$", "id": "3028047"}, {"introduction": "并非所有的模变换都在上半平面 $\\mathbb{H}$ 内拥有不动点。双曲变换是另一类重要的等距变换，它的作用是在一条不变的测地线上“滑动”整个上半平面。此练习将带你学习如何通过矩阵的迹来识别双曲元，并计算其位于实轴上的两个不动点，从而确定这条不变测地线的精确几何形态。[@problem_id:3028062]", "problem": "令 $SL(2,\\mathbb{Z})$ 表示行列式为 $1$ 的 $2\\times 2$ 整数矩阵构成的特殊线性群，它通过线性分式变换 $z\\mapsto \\dfrac{az+b}{cz+d}$（其中 $A=\\begin{pmatrix}a & b \\\\ c & d\\end{pmatrix}$）作用于上半平面 $\\mathbb{H}=\\{z\\in\\mathbb{C}:\\operatorname{Im}(z)>0\\}$。如果一个元素 $A\\in SL(2,\\mathbb{Z})$ 的迹满足 $|\\operatorname{tr}(A)|>2$，则称其为双曲元。在庞加莱上半平面模型中（即赋予了双曲度量的 $\\mathbb{H}$），一条双曲测地线是与实轴正交的欧几里得半圆或一条垂直线。\n\n从这些定义以及 $\\mathbb{H}$ 中线性分式变换和双曲测地线的基本性质出发，按以下步骤进行：\n\n1. 构造一个具体的双曲元 $A\\in SL(2,\\mathbb{Z})$，并从基本原理出发证明其为双曲元。\n2. 对于具体矩阵\n$$A=\\begin{pmatrix}4 & 1 \\\\ 3 & 1\\end{pmatrix},$$\n验证 $A\\in SL(2,\\mathbb{Z})$ 且 $|\\operatorname{tr}(A)|>2$。\n3. 推导并求解由变换 $z\\mapsto \\dfrac{4z+1}{3z+1}$ 在 $\\mathbb{H}\\cup\\mathbb{R}$ 上诱导的不动点所满足的二次方程，并以精确形式求出两个不同的实不动点 $x_{-} < x_{+}$，并确定连接它们的双曲测地线（一个半圆）的欧几里得中心 $m$ 和半径 $r$。", "solution": "该问题被验证为是自洽的，其科学基础在于模群理论和双曲几何，并且是适定的。我们按顺序处理每个部分来给出解答。\n\n$SL(2, \\mathbb{Z})$ 中的一个元素 $A = \\begin{pmatrix} a & b \\\\ c & d \\end{pmatrix}$ 是一个 $2 \\times 2$ 矩阵，其元素 $a, b, c, d \\in \\mathbb{Z}$ 为整数，且行列式为 $\\det(A) = ad-bc = 1$。如果其迹 $\\operatorname{tr}(A) = a+d$ 满足条件 $|\\operatorname{tr}(A)| > 2$，则称该元素为双曲元。\n\n第1部分：构造一个双曲元\n我们需要找到一个矩阵 $A$，其系数为整数，行列式为 $1$，且迹的绝对值大于 $2$。我们选择一些简单的整数值。\n令 $A = \\begin{pmatrix} 2 & 1 \\\\ 1 & 1 \\end{pmatrix}$。其元素均为整数。\n行列式为 $\\det(A) = (2)(1) - (1)(1) = 2 - 1 = 1$。所以 $A \\in SL(2, \\mathbb{Z})$。\n迹为 $\\operatorname{tr}(A) = 2 + 1 = 3$。\n我们检查其是否为双曲元的条件：$|\\operatorname{tr}(A)| = |3| = 3$。因为 $3 > 2$，条件满足。\n因此，$A = \\begin{pmatrix} 2 & 1 \\\\ 1 & 1 \\end{pmatrix}$ 是 $SL(2, \\mathbb{Z})$ 中双曲元的一个具体例子。\n\n第2部分：对给定矩阵进行验证\n给定矩阵 $A = \\begin{pmatrix} 4 & 1 \\\\ 3 & 1 \\end{pmatrix}$。\n首先，我们验证 $A \\in SL(2, \\mathbb{Z})$。元素 $4, 1, 3, 1$ 均为整数。我们计算行列式：\n$$ \\det(A) = (4)(1) - (1)(3) = 4 - 3 = 1 $$\n因为行列式为 $1$，所以 $A$ 确实是 $SL(2, \\mathbb{Z})$ 的一个元素。\n接下来，我们验证 $A$ 是双曲元。我们计算迹：\n$$ \\operatorname{tr}(A) = 4 + 1 = 5 $$\n我们检查条件 $|\\operatorname{tr}(A)| > 2$：\n$$ |\\operatorname{tr}(A)| = |5| = 5 > 2 $$\n条件满足，所以矩阵 $A$ 是一个双曲元。\n\n第3部分：不动点的推导与求解\n$A$ 诱导的线性分式变换为 $g(z) = \\frac{4z+1}{3z+1}$。该变换的不动点是满足 $g(z) = z$ 的值 $z$。\n$$ z = \\frac{4z+1}{3z+1} $$\n假设 $3z+1 \\neq 0$，我们可以将两边同乘以 $(3z+1)$：\n$$ z(3z+1) = 4z+1 $$\n$$ 3z^2 + z = 4z+1 $$\n整理各项，得到不动点满足的二次方程：\n$$ 3z^2 - 3z - 1 = 0 $$\n我们使用二次公式 $z = \\frac{-b \\pm \\sqrt{b^2-4ac}}{2a}$ 求解该方程，其中 $a=3$，$b=-3$，$c=-1$。\n$$ z = \\frac{-(-3) \\pm \\sqrt{(-3)^2 - 4(3)(-1)}}{2(3)} $$\n$$ z = \\frac{3 \\pm \\sqrt{9 + 12}}{6} $$\n$$ z = \\frac{3 \\pm \\sqrt{21}}{6} $$\n判别式 $21 > 0$，因此有两个不同的实不动点。根据题目要求，我们将它们标记为 $x_{-} < x_{+}$。\n$$ x_{-} = \\frac{3 - \\sqrt{21}}{6} $$\n$$ x_{+} = \\frac{3 + \\sqrt{21}}{6} $$\n由于 $\\sqrt{21} > 0$，显然有 $x_{-} < x_{+}$。\n\n第4部分：不变测地线的确定\n一个具有实系数的线性分式变换，例如 $g(z) = \\frac{4z+1}{3z+1}$，将实轴 $\\mathbb{R}$（更准确地说是扩展实直线 $\\mathbb{R} \\cup \\{\\infty\\}$）映射到自身。因此，它也将上半平面 $\\mathbb{H}$ 映射到自身。\n$\\mathbb{H}$ 中的一条双曲测地线由其在边界 $\\partial\\mathbb{H} = \\mathbb{R} \\cup \\{\\infty\\}$ 上的两个端点唯一确定。\n令 $\\gamma$ 为端点是两个不动点 $x_{-}$ 和 $x_{+}$ 的双曲测地线。\n变换 $g$ 将测地线映射到测地线。$\\gamma$ 在 $g$ 下的像，记为 $g(\\gamma)$，是端点为 $g(x_{-})$ 和 $g(x_{+})$ 的测地线。\n根据定义，$x_{-}$ 和 $x_{+}$ 是 $g$ 的不动点，因此 $g(x_{-}) = x_{-}$ 且 $g(x_{+}) = x_{+}$。\n这意味着 $g(\\gamma)$ 的端点与 $\\gamma$ 的端点相同。由于一条测地线由其端点唯一确定，我们必有 $g(\\gamma) = \\gamma$。因此，以 $x_{-}$ 和 $x_{+}$ 为端点的测地线在 $A$ 的作用下是不变的。\n问题陈述双曲测地线是与实轴正交的欧几里得半圆或垂直线。垂直线的一个端点在 $\\infty$。由于我们的不动点 $x_{-}$ 和 $x_{+}$ 都是有限的实数，不变测地线必定是一个欧几里得半圆。要使一个半圆与实轴正交，其直径必须位于实轴上。该直径的端点即为 $x_{-}$ 和 $x_{+}$。\n这个半圆的欧几里得中心 $m$ 必定是连接 $x_{-}$ 和 $x_{+}$ 的线段的中点。\n$$ m = \\frac{x_{-} + x_{+}}{2} = \\frac{1}{2} \\left( \\frac{3 - \\sqrt{21}}{6} + \\frac{3 + \\sqrt{21}}{6} \\right) = \\frac{1}{2} \\left( \\frac{3 - \\sqrt{21} + 3 + \\sqrt{21}}{6} \\right) = \\frac{1}{2} \\left( \\frac{6}{6} \\right) = \\frac{1}{2} $$\n半圆的欧几里得半径 $r$ 是两个端点之间距离的一半。\n$$ r = \\frac{x_{+} - x_{-}}{2} = \\frac{1}{2} \\left( \\frac{3 + \\sqrt{21}}{6} - \\frac{3 - \\sqrt{21}}{6} \\right) = \\frac{1}{2} \\left( \\frac{3 + \\sqrt{21} - 3 + \\sqrt{21}}{6} \\right) = \\frac{1}{2} \\left( \\frac{2\\sqrt{21}}{6} \\right) = \\frac{\\sqrt{21}}{6} $$\n所求的四个量是 $x_{-}$、$x_{+}$、$m$ 和 $r$。", "answer": "$$\\boxed{\\begin{pmatrix} \\frac{3 - \\sqrt{21}}{6} & \\frac{3 + \\sqrt{21}}{6} & \\frac{1}{2} & \\frac{\\sqrt{21}}{6} \\end{pmatrix}}$$", "id": "3028062"}, {"introduction": "基本区域 $F$ 的核心特性是它几乎包含了每个轨道上的唯一代表点。这个计算练习将这一抽象概念变得具体：你将实现一个经典算法，通过迭代应用模群的生成元 $T$（平移）和 $S$（反演），可以将上半平面中的任意一点“约化”到基本区域内。这个过程不仅让你找到了点所在轨道的代表，也让你构造出了实现这一映射的具体群元素，从而生动地展示了整个上半平面是如何由基本区域的像铺砌而成的。[@problem_id:3028074]", "problem": "令 $\\mathbb{H} = \\{ z \\in \\mathbb{C} \\mid \\operatorname{Im}(z) > 0 \\}$ 表示上半平面。模群 $\\mathrm{PSL}(2,\\mathbb{Z})$ 是特殊线性群 $\\mathrm{SL}(2,\\mathbb{Z}) = \\{ \\begin{pmatrix} a & b \\\\ c & d \\end{pmatrix} \\mid a,b,c,d \\in \\mathbb{Z},\\, ad - bc = 1 \\}$ 对正规子群 $\\{ \\pm I \\}$ 的商群，它通过分式线性变换作用于 $\\mathbb{H}$：\n$$\n\\begin{pmatrix} a & b \\\\ c & d \\end{pmatrix} \\cdot z = \\frac{a z + b}{c z + d}.\n$$\n此作用的一个标准基本域 $F$ 为\n$$\nF = \\{ z \\in \\mathbb{H} \\mid -\\tfrac{1}{2} \\le \\operatorname{Re}(z) \\le \\tfrac{1}{2},\\; |z| \\ge 1 \\},\n$$\n通常约定，边界上的点在 $\\mathrm{PSL}(2,\\mathbb{Z})$ 的作用下被等同，以便在采用确定性的打破平局规则后，每个轨道在 $F$ 中都有唯一的代表元。\n\n在 $\\mathrm{SL}(2,\\mathbb{Z})$ 中定义生成元 $T = \\begin{pmatrix} 1 & 1 \\\\ 0 & 1 \\end{pmatrix}$ 和 $S = \\begin{pmatrix} 0 & -1 \\\\ 1 & 0 \\end{pmatrix}$，它们代表了 $\\mathrm{PSL}(2,\\mathbb{Z})$ 的元素。元素 $T$ 的作用是 $z \\mapsto z + 1$，元素 $S$ 的作用是 $z \\mapsto -1/z$。\n\n仅从上述定义出发，设计并实现一个算法，该算法对于给定的 $z \\in \\mathbb{H}$，构造一个元素 $g \\in \\mathrm{PSL}(2,\\mathbb{Z})$ 作为生成元 $S$ 和 $T$ 的乘积，使得 $g \\cdot z \\in F$。该算法应迭代地：\n- 应用 $T^{-\\operatorname{nint}(\\operatorname{Re}(z))}$，其中 $\\operatorname{nint}(x) = \\lfloor x + \\tfrac{1}{2} \\rfloor$ 是最近整数函数，以确保 $\\operatorname{Re}(z)$ 位于区间 $[-\\tfrac{1}{2}, \\tfrac{1}{2})$ 内。\n- 如果 $|z| < 1$，则应用 $S$ 将 $z$ 变换到单位圆外，注意这会增加虚部并保持其在 $\\mathbb{H}$ 中的成员资格。\n\n重复此过程，直到 $z$ 位于 $F$ 内，使用确定性的打破平局规则（选择 $\\operatorname{nint}(x) = \\lfloor x + \\tfrac{1}{2} \\rfloor$ 可确保右边界 $\\operatorname{Re}(z) = \\tfrac{1}{2}$ 映射到左边界 $\\operatorname{Re}(z) = -\\tfrac{1}{2}$）。\n\n您的程序必须：\n- 根据所述算法，将 $g$ 表示为 $\\mathrm{SL}(2,\\mathbb{Z})$ 中的矩阵 $\\begin{pmatrix} a & b \\\\ c & d \\end{pmatrix}$，满足 $ad - bc = 1$，该矩阵由 $T^{-\\operatorname{nint}(\\operatorname{Re}(z))}$ 和 $S$ 的乘积构成。\n- 对于每个输入 $z$，返回矩阵元素 $(a,b,c,d)$（作为整数），$g \\cdot z$ 的实部和虚部（作为四舍五入到12位小数的浮点数），以及生成元应用的总次数（作为整数，每次非平凡的平移 $T^{-\\operatorname{nint}(\\operatorname{Re}(z))}$ 计为一次应用，每次应用 $S$ 计为一次）。\n\n角度单位不适用。不涉及物理单位。\n\n测试套件：\n使用以下输入 $z \\in \\mathbb{H}$，表示为有序对 $(\\operatorname{Re}(z), \\operatorname{Im}(z))$：\n1. $(0.3, 0.4)$，一个严格在单位圆内的点。\n2. $(10.2, 1.2)$，一个需要大范围平移的点。\n3. $(-3.7, 0.8)$，一个具有较大负实部的点。\n4. $(0.5, 0.9)$，一个位于右边界线 $\\operatorname{Re}(z) = \\tfrac{1}{2}$ 上的点。\n5. $(-0.49, 0.1)$，一个靠近左侧带状边界且在单位圆内的点。\n6. $(0.001, 0.001)$，一个在 $\\mathbb{H}$ 中且在单位圆内、模极小的点。\n7. $(0.0, 5.0)$，一个已在基本域中的对称点。\n8. $(2.5, 0.3)$，一个实部为半整数、需要仔细舍入的点。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。每个测试用例的结果本身必须是一个 $[a,b,c,d,r,i,s]$ 形式的列表，其中 $a,b,c,d$ 是矩阵 $g$ 的整数元素，$r,i$ 是 $g \\cdot z$ 的实部和虚部（四舍五入到12位小数），$s$ 是生成元应用次数的整数计数。例如，最终输出必须如下所示：\n$[[a_1,b_1,c_1,d_1,r_1,i_1,s_1],[a_2,b_2,c_2,d_2,r_2,i_2,s_2],\\dots]$。", "solution": "问题陈述已经过验证，被认为是有效的。这是一个计算数论中的适定问题，基于模群理论的标准定义。所有必要的组成部分——定义域、群、群作用、基本域、生成元、确定性算法和精确的输出格式——都已提供且在数学上是合理的。\n\n任务是实现一个给定的算法，该算法对于 $\\mathbb{H}$（复上半平面）中的任意点 $z$，找到模群 $\\mathrm{PSL}(2,\\mathbb{Z})$ 的一个元素 $g$，使得 $g \\cdot z$ 位于标准基本域 $F$ 内。元素 $g$ 将被构造成群生成元 $S$ 和 $T$ 的乘积，并表示为 $\\mathrm{SL}(2,\\mathbb{Z})$ 中的一个矩阵。\n\n该算法以迭代方式运行。一个点 $z$ 被不断变换，直到它满足进入基本域的条件，$F = \\{ z \\in \\mathbb{H} \\mid -\\tfrac{1}{2} \\le \\operatorname{Re}(z) \\le \\tfrac{1}{2},\\; |z| \\ge 1 \\}$。该过程保证会终止，因为点 $z$ 的虚部在算法的特定步骤中会增加，并且对于任何给定的轨道，它都有上界。\n\n实现将按以下步骤进行：\n\n1.  **表示**：\n    -   复数 $z = x + iy$ 将使用 Python 的原生 `complex` 数据类型表示。\n    -   变换矩阵 $g \\in \\mathrm{SL}(2,\\mathbb{Z})$ 是一个具有整数项的 $2 \\times 2$ 矩阵。它将由一个 `numpy` 数组表示，数据类型为64位整数，以防止在矩阵乘法过程中发生溢出。该过程以 $g$ 作为单位矩阵 $I = \\begin{pmatrix} 1 & 0 \\\\ 0 & 1 \\end{pmatrix}$ 开始。\n    -   步数计数器 $s$ 初始化为 $0$。\n\n2.  **迭代算法**：执行一个循环，直到点 $z$ 在指定的变换下变得稳定。当 $z$ 位于基本域内（特定边界条件由算法的确定性性质处理）时，就达到了这种稳定性。\n\n3.  **变换步骤**：在循环内部，按顺序考虑两个变换：\n\n    a.  **平移**：使用平移生成元 $T = \\begin{pmatrix} 1 & 1 \\\\ 0 & 1 \\end{pmatrix}$ 的幂，将当前点 $z$ 的实部移入区间 $[-\\tfrac{1}{2}, \\tfrac{1}{2})$。具体的幂由最近整数函数确定，$n = \\operatorname{nint}(\\operatorname{Re}(z)) = \\lfloor \\operatorname{Re}(z) + \\tfrac{1}{2} \\rfloor$。应用于该点的变换是 $z \\mapsto z - n$，这对应于矩阵 $T^{-n} = \\begin{pmatrix} 1 & -n \\\\ 0 & 1 \\end{pmatrix}$ 的作用。如果 $n \\ne 0$，则通过左乘更新总变换矩阵 $g \\mapsto T^{-n} g$，并且步数计数器 $s$ 增加 1。此步骤确保任何具有 $\\operatorname{Re}(z) = \\tfrac{1}{2}$ 的点都映射到 $\\operatorname{Re}(z) = -\\tfrac{1}{2}$，从而遵守问题的打破平局规则。\n\n    b.  **反演**：如果点 $z$（在可能的平移之后）位于单位圆盘内部，即 $|z| < 1$，则应用反演变换 $S = \\begin{pmatrix} 0 & -1 \\\\ 1 & 0 \\end{pmatrix}$。该点通过 $z \\mapsto -1/z$ 进行更新。此变换将单位圆盘的内部映射到其外部，从而增加其模。通过左乘更新总变换矩阵 $g \\mapsto S g$，并且步数计数器 $s$ 增加 1。\n\n4.  **终止**：当整个迭代完成而没有应用平移（$n=0$）或反演时，循环终止。此时，条件 $-\\tfrac{1}{2} \\le \\operatorname{Re}(z) < \\tfrac{1}{2}$ 和 $|z| \\ge 1$ 被满足，这意味着最终点 $z$ 位于基本域 $F$ 中（遵循边界约定）。\n\n5.  **输出**：终止时，收集最终矩阵 $g$ 的整数项 $(a,b,c,d)$，最终点 $g \\cdot z$ 的实部和虚部（四舍五入到12位小数）以及总步数 $s$，并按要求格式化。", "answer": "```python\n# 完整的、可运行的 Python 3 代码在此处。\n# 导入必须遵守指定的执行环境。\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    主函数，用于运行测试套件并打印结果。\n    \"\"\"\n    \n    def solve_single_case(z_real, z_imag):\n        \"\"\"\n        应用指定的算法，将上半平面中的点 z 映射到标准基本域 F 中。\n\n        Args:\n            z_real (float): 初始点 z 的实部。\n            z_imag (float): 初始点 z 的虚部。\n\n        Returns:\n            list: 包含 [a, b, c, d, r, i, s] 的列表，其中 (a,b,c,d) 是最终变换矩阵 g 的整数项，\n                  (r,i) 是最终点 g*z 的实部和虚部，s 是生成元应用的总次数。\n        \"\"\"\n        current_z = complex(z_real, z_imag)\n        \n        # g 代表变换矩阵，初始为单位矩阵。\n        # 使用64位整数以确保矩阵乘法安全。\n        g = np.identity(2, dtype=np.int64)\n        \n        # s 是生成元应用的次数。\n        s = 0\n\n        # 算法保证会终止。设置循环上限是一种很好的预防措施。\n        max_iter = 100\n        for _ in range(max_iter):\n            transformed_in_iteration = False\n\n            # 步骤 1：平移。\n            # 应用 T^(-n)，其中 n = nint(Re(z))，以将 Re(z) 移入 [-0.5, 0.5)。\n            # 问题定义 nint(x) = floor(x + 0.5)。\n            n = int(np.floor(current_z.real + 0.5))\n            \n            if n != 0:\n                current_z -= n\n                T_inv_n = np.array([[1, -n], [0, 1]], dtype=np.int64)\n                g = T_inv_n @ g\n                s += 1\n                transformed_in_iteration = True\n\n            # 步骤 2：反演。\n            # 如果 |z|  1，则应用 S 变换。\n            if abs(current_z)  1.0:\n                # 点 z 不可能为 0，因为 Im(z) > 0 是一个不变量。\n                current_z = -1.0 / current_z\n                S_mat = np.array([[0, -1], [1, 0]], dtype=np.int64)\n                g = S_mat @ g\n                s += 1\n                transformed_in_iteration = True\n            \n            # 如果没有发生变换，则该点是稳定的，并且位于基本域中。\n            if not transformed_in_iteration:\n                break\n        else:\n            # 如果 for 循环完成而没有中断，则执行此块。\n            raise RuntimeError(f\"Algorithm did not converge for z = {complex(z_real, z_imag)}\")\n\n        # 为输出解包矩阵 g。\n        a, b = g[0]\n        c, d = g[1]\n        \n        # 以列表形式返回所需的值。\n        return [int(a), int(b), int(c), int(d), current_z.real, current_z.imag, s]\n\n    # 问题陈述中提供的测试套件。\n    test_cases = [\n        (0.3, 0.4),\n        (10.2, 1.2),\n        (-3.7, 0.8),\n        (0.5, 0.9),\n        (-0.49, 0.1),\n        (0.001, 0.001),\n        (0.0, 5.0),\n        (2.5, 0.3),\n    ]\n\n    all_results = []\n    for case in test_cases:\n        result = solve_single_case(case[0], case[1])\n        all_results.append(result)\n\n    # 完全按照问题中的指定格式化最终输出字符串。\n    result_strings = []\n    for res in all_results:\n        a, b, c, d, r, i, s_count = res\n        r_rounded = round(r, 12)\n        i_rounded = round(i, 12)\n        \n        # 将 -0.0 规范化为 0.0 以获得更清晰的输出。\n        if r_rounded == -0.0: r_rounded = 0.0\n        if i_rounded == -0.0: i_rounded = 0.0\n        \n        result_strings.append(f\"[{a},{b},{c},{d},{r_rounded},{i_rounded},{s_count}]\")\n    \n    print(f\"[{','.join(result_strings)}]\")\n\nsolve()\n```", "id": "3028074"}]}