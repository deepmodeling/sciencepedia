{"hands_on_practices": [{"introduction": "理论的学习需要通过实践来巩固，而这个练习正是连接解析理论与具体计算的第一步。我们将从欧拉乘积公式和五边形数定理出发，推导出计算分拆函数 $p(n)$ 的高效递归关系。您将通过编程实现这一算法，用它来验证拉马努金发现的著名分拆同余式 [@problem_id:3015946]，从而亲身体验这一强大数学工具的威力。", "problem": "您需要编写一个完整、可运行的程序，通过从形式幂级数环中的基本恒等式推导并实现一个有原则的递推关系，来计算分区函数对一个固定模数的取模值。您的实现必须基于一个推导，该推导从整数分区函数的生成函数定义和关于形式幂级数的标准事实出发，且不假设任何预先计算好的分区函数值。具体来说，从形式幂级数环中的基本恒等式开始\n$$\n\\sum_{n\\ge 0} p(n)\\,x^n \\;=\\; \\prod_{k\\ge 1}\\frac{1}{1-x^k},\n$$\n其中 $p(n)$ 表示整数 $n$ 的分区数，并由此推导出一个有效的、有限的递推关系，使您能够计算给定界限内所有 $n$ 的 $p(n)\\bmod m$。您可以使用任何可在此框架内从生成函数严格推导出的经典结论，以及可以在系数为模 $m$ 整数的形式幂级数环内进行模 $m$ 计算这一事实。\n\n您的程序必须执行以下任务：\n- 计算所有满足 $0\\le n\\le 34$ 的整数 $n$ 的 $p(n)\\bmod 5$。\n- 提取所有满足 $0\\le k\\le 6$ 的整数 $k$ 的子序列 $p(5k+4)\\bmod 5$。\n- 计算验证同余式 $p(5n+4)\\equiv 0 \\pmod{5}$ 是否对所有满足 $0\\le n\\le 6$ 的整数 $n$ 成立。\n\n测试套件和要求的输出：\n- 使用参数 $n_{\\max}=34$ 和 $m=5$。\n- 您的程序必须产生三个结果，这些结果共同检验了正确性和边界行为：\n    1. 所有满足 $0\\le n\\le 34$ 的整数 $n$ 的余数 $[p(n)\\bmod 5]$ 的完整列表（该列表长度为 $35$，并包括边界情况 $n=0$）。\n    2. 所有满足 $0\\le k\\le 6$ 的整数 $k$ 的余数 $[p(5k+4)\\bmod 5]$ 的提取列表（对应于索引 $4,9,14,19,24,29,34$）。\n    3. 一个布尔值，指示第二个列表中的所有条目在 $\\mathbb{Z}/5\\mathbb{Z}$ 中是否等于 $0$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表。第一个元素必须是项目 $1$ 的列表，第二个元素必须是项目 $2$ 的列表，第三个元素必须是项目 $3$ 的布尔值。例如，您的输出应具有以下形式\n$$\n[\\,[\\dots 35\\ \\text{integers}\\dots],\\,[\\dots 7\\ \\text{integers}\\dots],\\,\\text{True or False}\\,].\n$$\n程序不应从标准输入读取任何输入，也不得使用任何外部文件。所有整数都应报告为不带任何单位的纯整数。布尔值必须是字面布尔值。", "solution": "该问题要求计算整数分区函数 $p(n)$ 对一个素数 $m=5$ 取模的值，上限为 $n_{\\max}=34$。我们需要从 $p(n)$ 在形式幂级数环 $\\mathbb{Z}[[x]]$ 中的生成函数推导出一个有效的计算递推关系。\n\n整数 $n$ 的分区数（记为 $p(n)$）的生成函数由以下恒等式给出：\n$$P(x) = \\sum_{n=0}^{\\infty} p(n)x^n = \\prod_{k=1}^{\\infty} \\frac{1}{1-x^k}$$\n按照惯例，$p(0)=1$，对应于 $0$ 的唯一分区（空分区）。对于 $n0$，我们定义 $p(n)=0$。\n\n该恒等式在形式幂级数环 $\\mathbb{Z}[[x]]$ 中成立。因此，$P(x)$ 的乘法逆元是：\n$$\\Phi(x) = P(x)^{-1} = \\prod_{k=1}^{\\infty} (1-x^k)$$\n分区理论中的一个基本结果，即 Euler 的五边形数定理，提供了 $\\Phi(x)$ 的一个级数展开：\n$$\\Phi(x) = \\sum_{j=-\\infty}^{\\infty} (-1)^j x^{\\omega_j} = 1 - x - x^2 + x^5 + x^7 - x^{12} - x^{15} + \\dots$$\n其中指数 $\\omega_j = \\frac{j(3j-1)}{2}$ 是对于 $j \\in \\mathbb{Z}$ 的广义五边形数。\n\n$P(x)$ 与其逆元 $\\Phi(x)$ 的乘积是 $\\mathbb{Z}[[x]]$ 中的乘法单位元，即形式幂级数 $1$：\n$$P(x) \\Phi(x) = \\left(\\sum_{n=0}^{\\infty} p(n)x^n\\right) \\left(\\sum_{j=-\\infty}^{\\infty} (-1)^j x^{\\omega_j}\\right) = 1$$\n对于任何 $n0$，乘积级数中 $x^n$ 的系数必须为 $0$。使用 Cauchy 乘积公式计算 $x^n$ 的系数（我们记为 $[x^n]$），我们得到：\n$$[x^n](P(x)\\Phi(x)) = \\sum_{j=-\\infty}^{\\infty} \\left( [x^{\\omega_j}]\\Phi(x) \\right) \\cdot \\left( [x^{n-\\omega_j}]P(x) \\right) = \\sum_{j=-\\infty}^{\\infty} (-1)^j p(n-\\omega_j) = 0$$\n这对所有 $n0$ 都成立。$j=0$ 的项对应于 $\\omega_0=0$，得到 $(-1)^0 p(n-0) = p(n)$。因此我们可以从和式中分离出 $p(n)$：\n$$p(n) + \\sum_{j \\in \\mathbb{Z}, j \\neq 0} (-1)^j p(n-\\omega_j) = 0$$\n这就得出了我们期望的 $p(n)$ 的递推关系：\n$$p(n) = -\\sum_{j \\in \\mathbb{Z}, j \\neq 0} (-1)^j p(n-\\omega_j) = \\sum_{j \\in \\mathbb{Z}, j \\neq 0} (-1)^{j-1} p(n-\\omega_j)$$\n为了计算方便，可以将 $j=k$ 和 $j=-k$ ($k \\in \\mathbb{Z}, k \\ge 1$) 的项组合在一起。对应的五边形数是 $\\omega_k = \\frac{k(3k-1)}{2}$ 和 $\\omega_{-k} = \\frac{k(3k+1)}{2}$。递推关系变为：\n$$p(n) = \\sum_{k=1}^{\\infty} (-1)^{k-1} \\left( p\\left(n - \\frac{k(3k-1)}{2}\\right) + p\\left(n - \\frac{k(3k+1)}{2}\\right) \\right)$$\n可以更明确地写为：\n$$p(n) = [p(n-1)+p(n-2)] - [p(n-5)+p(n-7)] + [p(n-12)+p(n-15)] - \\dots$$\n其中求和是有限的，因为对于 $k0$ 有 $p(k)=0$。\n\n这个递推关系只涉及整数加法和减法。因此，所有计算都可以在模整数 $m$ 的意义下进行。具体来说，我们计算 $p(n) \\pmod 5$：\n$$p(n) \\equiv \\sum_{k=1}^{\\infty} (-1)^{k-1} \\left( p\\left(n - \\frac{k(3k-1)}{2}\\right) + p\\left(n - \\frac{k(3k+1)}{2}\\right) \\right) \\pmod 5$$\n\n算法流程如下：\n1.  初始化一个大小为 $n_{\\max}+1=35$ 的数组，例如 `p_mod_m`，用于存储 $p(n) \\bmod 5$ 的值。\n2.  设置基本情况：`p_mod_m[0] = 1`。\n3.  对 $n$ 从 $1$ 到 $34$ 进行迭代。在每次迭代中，使用递推关系计算 `p_mod_m[n]`。每个 $p(n)$ 的计算都使用先前计算出的 $k  n$ 的 $p(k)$ 值。\n4.  计算出所有直到 $p(34) \\pmod 5$ 的值后，形成一个包含这 $35$ 个余数的列表。\n5.  提取第二个列表，其中包含 $k \\in \\{0, 1, \\dots, 6\\}$ 时 $p(5k+4) \\pmod 5$ 的值。这些值对应主列表中的索引 $4, 9, 14, 19, 24, 29, 34$。\n6.  最后，通过检查第二个列表中的所有元素是否都同余于 $0 \\pmod 5$ 来确定一个布尔值。这在计算上验证了 Ramanujan 同余式 $p(5k+4) \\equiv 0 \\pmod 5$ 的一个具体实例。\n然后将这三个结果对象——完整的余数列表、提取的子列表和布尔验证结果——格式化为所需的最终输出字符串。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes partition function values p(n) modulo 5 based on a recurrence\n    derived from the generating function, then verifies a Ramanujan congruence.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    n_max = 34\n    m = 5\n\n    # 1. Compute p(n) mod m for 0 = n = n_max.\n    \n    # Initialize an array to store p(n) mod m.\n    # We use a numpy array for efficient integer operations.\n    p = np.zeros(n_max + 1, dtype=int)\n    \n    # Base case: p(0) = 1 (the empty partition).\n    p[0] = 1\n\n    # Apply the recurrence relation derived from Euler's Pentagonal Number Theorem.\n    # p(n) = sum_{k=1 to inf} (-1)^(k-1) * [p(n - k(3k-1)/2) + p(n - k(3k+1)/2)]\n    for n in range(1, n_max + 1):\n        val = 0\n        sign = 1\n        k = 1\n        while True:\n            # Generalized pentagonal numbers for k and -k.\n            pent_k = k * (3 * k - 1) // 2\n            pent_minus_k = k * (3 * k + 1) // 2\n            \n            # Add p(n - pent_k) term.\n            if n - pent_k = 0:\n                val += sign * p[n - pent_k]\n            else:\n                # Since pentagonal numbers are strictly increasing with k,\n                # we can break if n - pent_k is negative.\n                break\n\n            # Add p(n - pent_minus_k) term.\n            if n - pent_minus_k = 0:\n                val += sign * p[n - pent_minus_k]\n\n            # Alternate the sign for the next pair of terms.\n            sign *= -1\n            k += 1\n        \n        # Store the result modulo m. Python's % operator handles negative\n        # results correctly for modular arithmetic (e.g., -1 % 5 == 4).\n        p[n] = val % m\n\n    # Convert the numpy array of all results to a standard Python list.\n    full_residue_list = p.tolist()\n\n    # 2. Extract the subsequence p(5k+4) mod 5.\n    subsequence_indices = [5 * k + 4 for k in range(7)] # k from 0 to 6\n    extracted_subsequence = [p[i] for i in subsequence_indices]\n\n    # 3. Verify the congruence p(5n+4) = 0 (mod 5).\n    is_congruence_verified = all(x == 0 for x in extracted_subsequence)\n    \n    # Final print statement in the exact required format.\n    # Python's str() for lists and booleans matches the required format.\n    print(f\"[{full_residue_list},{extracted_subsequence},{is_congruence_verified}]\")\n\nsolve()\n\n```", "id": "3015946"}, {"introduction": "拉马努金同余式暗示了整数分拆集合内部存在着深刻的代数结构。为了从组合学的角度解释这些规律，数学家引入了“秩” (rank) 和“曲柄” (crank) 的概念。通过亲手枚举一个整数的所有分拆并计算其对应的统计量 [@problem_id:3015948]，您将对这些概念如何揭示分拆的内在对称性获得一个直观且具体的理解。", "problem": "设 $n$ 是一个正整数，一个 $n$ 的划分 $\\pi$ 是一个和为 $n$ 的有限非增正整数序列。用 $p(n)$ 表示 $n$ 的划分数。对于一个划分 $\\pi$，定义其秩 $\\mathrm{rank}(\\pi)$ 为 $\\pi$ 的最大部分减去 $\\pi$ 的部分数。定义其曲秩 $\\mathrm{crank}(\\pi)$ 如下：记 $\\lambda(\\pi)$ 为 $\\pi$ 的最大部分，$\\mu(\\pi)$ 为 $\\pi$ 中 $1$ 的个数，$\\nu(\\pi)$ 为严格大于 $\\mu(\\pi)$ 的部分数。则\n- 如果 $\\mu(\\pi)=0$，设 $\\mathrm{crank}(\\pi)=\\lambda(\\pi)$，\n- 如果 $\\mu(\\pi)0$，设 $\\mathrm{crank}(\\pi)=\\nu(\\pi)-\\mu(\\pi)$。\n\n对于一个固定的 $n$，定义秩分布多项式和曲秩分布多项式\n$$R_{n}(z)=\\sum_{\\pi\\vdash n} z^{\\mathrm{rank}(\\pi)}\\quad\\text{和}\\quad C_{n}(z)=\\sum_{\\pi\\vdash n} z^{\\mathrm{crank}(\\pi)},$$\n其中求和遍及 $n$ 的所有划分 $\\pi$，$z$ 是一个形式变量。\n\n从上述定义和费勒斯图共轭的基本性质出发，通过枚举 $9$ 的所有划分，确定每个划分的 $\\mathrm{rank}(\\pi)$ 和 $\\mathrm{crank}(\\pi)$，并对它们的贡献求和，从而显式计算 $R_{9}(z)$ 和 $C_{9}(z)$。然后，通过找出相应的组合对合，并确认系数序列是对称的，来验证当 $n=9$ 时这些分布在 $z\\mapsto z^{-1}$ 变换下的对称性。将您的最终答案表示为关于 $z$ 的 $R_{9}(z)$ 和 $C_{9}(z)$ 的闭式多项式。", "solution": "问题是计算整数 $n=9$ 的划分的秩分布多项式 $R_{9}(z)$ 和曲秩分布多项式 $C_{9}(z)$。这项任务需要显式地枚举出 $9$ 的所有划分，然后计算每个划分的秩和曲秩。\n\n$n=9$ 的划分数，记为 $p(9)$，是 $30$。$9$ 的划分为：\n$1$. $\\pi_1 = (9)$\n$2$. $\\pi_2 = (8,1)$\n$3$. $\\pi_3 = (7,2)$\n$4$. $\\pi_4 = (7,1,1)$\n$5$. $\\pi_5 = (6,3)$\n$6$. $\\pi_6 = (6,2,1)$\n$7$. $\\pi_7 = (6,1,1,1)$\n$8$. $\\pi_8 = (5,4)$\n$9$. $\\pi_9 = (5,3,1)$\n$10$. $\\pi_{10} = (5,2,2)$\n$11$. $\\pi_{11} = (5,2,1,1)$\n$12$. $\\pi_{12} = (5,1,1,1,1)$\n$13$. $\\pi_{13} = (4,4,1)$\n$14$. $\\pi_{14} = (4,3,2)$\n$15$. $\\pi_{15} = (4,3,1,1)$\n$16$. $\\pi_{16} = (4,2,2,1)$\n$17$. $\\pi_{17} = (4,2,1,1,1)$\n$18$. $\\pi_{18} = (4,1,1,1,1,1)$\n$19$. $\\pi_{19} = (3,3,3)$\n$20$. $\\pi_{20} = (3,3,2,1)$\n$21$. $\\pi_{21} = (3,3,1,1,1)$\n$22$. $\\pi_{22} = (3,2,2,2)$\n$23$. $\\pi_{23} = (3,2,2,1,1)$\n$24$. $\\pi_{24} = (3,2,1,1,1,1)$\n$25$. $\\pi_{25} = (3,1,1,1,1,1,1)$\n$26$. $\\pi_{26} = (2,2,2,2,1)$\n$27$. $\\pi_{27} = (2,2,2,1,1,1)$\n$28$. $\\pi_{28} = (2,2,1,1,1,1,1)$\n$29$. $\\pi_{29} = (2,1,1,1,1,1,1,1)$\n$30$. $\\pi_{30} = (1,1,1,1,1,1,1,1,1)$\n\n首先，我们计算秩分布多项式 $R_{9}(z)$。一个划分 $\\pi$ 的秩定义为 $\\mathrm{rank}(\\pi) = \\lambda(\\pi) - k(\\pi)$，其中 $\\lambda(\\pi)$ 是最大部分，$k(\\pi)$ 是部分数。我们计算 $9$ 的每个划分的秩：\n$\\mathrm{rank}(\\pi_1) = 9-1=8$\n$\\mathrm{rank}(\\pi_2) = 8-2=6$\n$\\mathrm{rank}(\\pi_3) = 7-2=5$\n$\\mathrm{rank}(\\pi_4) = 7-3=4$\n$\\mathrm{rank}(\\pi_5) = 6-2=4$\n$\\mathrm{rank}(\\pi_6) = 6-3=3$\n$\\mathrm{rank}(\\pi_7) = 6-4=2$\n$\\mathrm{rank}(\\pi_8) = 5-2=3$\n$\\mathrm{rank}(\\pi_9) = 5-3=2$\n$\\mathrm{rank}(\\pi_{10}) = 5-3=2$\n$\\mathrm{rank}(\\pi_{11}) = 5-4=1$\n$\\mathrm{rank}(\\pi_{12}) = 5-5=0$\n$\\mathrm{rank}(\\pi_{13}) = 4-3=1$\n$\\mathrm{rank}(\\pi_{14}) = 4-3=1$\n$\\mathrm{rank}(\\pi_{15}) = 4-4=0$\n$\\mathrm{rank}(\\pi_{16}) = 4-4=0$\n$\\mathrm{rank}(\\pi_{17}) = 4-5=-1$\n$\\mathrm{rank}(\\pi_{18}) = 4-6=-2$\n$\\mathrm{rank}(\\pi_{19}) = 3-3=0$\n$\\mathrm{rank}(\\pi_{20}) = 3-4=-1$\n$\\mathrm{rank}(\\pi_{21}) = 3-5=-2$\n$\\mathrm{rank}(\\pi_{22}) = 3-4=-1$\n$\\mathrm{rank}(\\pi_{23}) = 3-5=-2$\n$\\mathrm{rank}(\\pi_{24}) = 3-6=-3$\n$\\mathrm{rank}(\\pi_{25}) = 3-7=-4$\n$\\mathrm{rank}(\\pi_{26}) = 2-5=-3$\n$\\mathrm{rank}(\\pi_{27}) = 2-6=-4$\n$\\mathrm{rank}(\\pi_{28}) = 2-7=-5$\n$\\mathrm{rank}(\\pi_{29}) = 2-8=-6$\n$\\mathrm{rank}(\\pi_{30}) = 1-9=-8$\n\n秩分布多项式是 $R_{9}(z)=\\sum_{i=1}^{30} z^{\\mathrm{rank}(\\pi_i)}$。我们合并具有相同指数的项：\n- $z^8$ 的系数：$1$\n- $z^6$ 的系数：$1$\n- $z^5$ 的系数：$1$\n- $z^4$ 的系数：$2$\n- $z^3$ 的系数：$2$\n- $z^2$ 的系数：$3$\n- $z^1$ 的系数：$3$\n- $z^0$ 的系数：$4$\n- $z^{-1}$ 的系数：$3$\n- $z^{-2}$ 的系数：$3$\n- $z^{-3}$ 的系数：$2$\n- $z^{-4}$ 的系数：$2$\n- $z^{-5}$ 的系数：$1$\n- $z^{-6}$ 的系数：$1$\n- $z^{-8}$ 的系数：$1$\n所有其他系数均为 $0$。\n因此，多项式为：\n$R_{9}(z) = z^{8} + z^{6} + z^{5} + 2z^{4} + 2z^{3} + 3z^{2} + 3z + 4 + 3z^{-1} + 3z^{-2} + 2z^{-3} + 2z^{-4} + z^{-5} + z^{-6} + z^{-8}$.\n\n$z^k$ 的系数等于 $z^{-k}$ 的系数，这种系数的对称性从显式计算中是显而易见的。这种对称性由费勒斯图共轭的组合对合所保证。对于任何划分 $\\pi$，其共轭划分 $\\pi'$ 的最大部分等于 $\\pi$ 的部分数，其部分数等于 $\\pi$ 的最大部分。即 $\\lambda(\\pi')=k(\\pi)$ 和 $k(\\pi')=\\lambda(\\pi)$。因此，$\\mathrm{rank}(\\pi') = \\lambda(\\pi') - k(\\pi') = k(\\pi) - \\lambda(\\pi) = -\\mathrm{rank}(\\pi)$。这个对合将秩为 $k$ 的划分与秩为 $-k$ 的划分配对。秩为 $0$ 的划分要么是自共轭的（在此对合下不动），要么以秩为 $0$ 的共轭对形式出现。\n\n接下来，我们计算曲秩分布多项式 $C_{9}(z)$。曲秩是使用 $\\lambda(\\pi)$（最大部分）、$\\mu(\\pi)$（1 的个数）和 $\\nu(\\pi)$（大于 $\\mu(\\pi)$ 的部分数）来定义的。如果 $\\mu(\\pi)=0$，$\\mathrm{crank}(\\pi) = \\lambda(\\pi)$。如果 $\\mu(\\pi)0$，$\\mathrm{crank}(\\pi) = \\nu(\\pi) - \\mu(\\pi)$。\n$\\mathrm{crank}(\\pi_1)$: $\\mu(\\pi_1)=0$，所以 $\\mathrm{crank}(\\pi_1)=9$。\n$\\mathrm{crank}(\\pi_2)$: $\\mu(\\pi_2)=1$，部分为 $(8,1)$。$\\nu(\\pi_2)$=大于 $1$ 的部分数，为 $1$。$\\mathrm{crank}(\\pi_2)=1-1=0$。\n$\\mathrm{crank}(\\pi_3)$: $\\mu(\\pi_3)=0$，所以 $\\mathrm{crank}(\\pi_3)=7$。\n$\\mathrm{crank}(\\pi_4)$: $\\mu(\\pi_4)=2$，部分为 $(7,1,1)$。$\\nu(\\pi_4)$=大于 $2$ 的部分数，为 $1$。$\\mathrm{crank}(\\pi_4)=1-2=-1$。\n$\\mathrm{crank}(\\pi_5)$: $\\mu(\\pi_5)=0$，所以 $\\mathrm{crank}(\\pi_5)=6$。\n$\\mathrm{crank}(\\pi_6)$: $\\mu(\\pi_6)=1$，部分为 $(6,2,1)$。$\\nu(\\pi_6)$=大于 $1$ 的部分数，为 $2$。$\\mathrm{crank}(\\pi_6)=2-1=1$。\n$\\mathrm{crank}(\\pi_7)$: $\\mu(\\pi_7)=3$，部分为 $(6,1,1,1)$。$\\nu(\\pi_7)$=大于 $3$ 的部分数，为 $1$。$\\mathrm{crank}(\\pi_7)=1-3=-2$。\n$\\mathrm{crank}(\\pi_8)$: $\\mu(\\pi_8)=0$，所以 $\\mathrm{crank}(\\pi_8)=5$。\n$\\mathrm{crank}(\\pi_9)$: $\\mu(\\pi_9)=1$，部分为 $(5,3,1)$。$\\nu(\\pi_9)$=大于 $1$ 的部分数，为 $2$。$\\mathrm{crank}(\\pi_9)=2-1=1$。\n$\\mathrm{crank}(\\pi_{10})$: $\\mu(\\pi_{10})=0$，所以 $\\mathrm{crank}(\\pi_{10})=5$。\n$\\mathrm{crank}(\\pi_{11})$: $\\mu(\\pi_{11})=2$，部分为 $(5,2,1,1)$。$\\nu(\\pi_{11})$=大于 $2$ 的部分数，为 $1$。$\\mathrm{crank}(\\pi_{11})=1-2=-1$。\n$\\mathrm{crank}(\\pi_{12})$: $\\mu(\\pi_{12})=4$，部分为 $(5,1,1,1,1)$。$\\nu(\\pi_{12})$=大于 $4$ 的部分数，为 $1$。$\\mathrm{crank}(\\pi_{12})=1-4=-3$。\n$\\mathrm{crank}(\\pi_{13})$: $\\mu(\\pi_{13})=1$，部分为 $(4,4,1)$。$\\nu(\\pi_{13})$=大于 $1$ 的部分数，为 $2$。$\\mathrm{crank}(\\pi_{13})=2-1=1$。\n$\\mathrm{crank}(\\pi_{14})$: $\\mu(\\pi_{14})=0$，所以 $\\mathrm{crank}(\\pi_{14})=4$。\n$\\mathrm{crank}(\\pi_{15})$: $\\mu(\\pi_{15})=2$，部分为 $(4,3,1,1)$。$\\nu(\\pi_{15})$=大于 $2$ 的部分数，为 $2$。$\\mathrm{crank}(\\pi_{15})=2-2=0$。\n$\\mathrm{crank}(\\pi_{16})$: $\\mu(\\pi_{16})=1$，部分为 $(4,2,2,1)$。$\\nu(\\pi_{16})$=大于 $1$ 的部分数，为 $3$。$\\mathrm{crank}(\\pi_{16})=3-1=2$。\n$\\mathrm{crank}(\\pi_{17})$: $\\mu(\\pi_{17})=3$，部分为 $(4,2,1,1,1)$。$\\nu(\\pi_{17})$=大于 $3$ 的部分数，为 $1$。$\\mathrm{crank}(\\pi_{17})=1-3=-2$。\n$\\mathrm{crank}(\\pi_{18})$: $\\mu(\\pi_{18})=5$，部分为 $(4,1^5)$。$\\nu(\\pi_{18})$=大于 $5$ 的部分数，为 $0$。$\\mathrm{crank}(\\pi_{18})=0-5=-5$。\n$\\mathrm{crank}(\\pi_{19})$: $\\mu(\\pi_{19})=0$，所以 $\\mathrm{crank}(\\pi_{19})=3$。\n$\\mathrm{crank}(\\pi_{20})$: $\\mu(\\pi_{20})=1$，部分为 $(3,3,2,1)$。$\\nu(\\pi_{20})$=大于 $1$ 的部分数，为 $3$。$\\mathrm{crank}(\\pi_{20})=3-1=2$。\n$\\mathrm{crank}(\\pi_{21})$: $\\mu(\\pi_{21})=3$，部分为 $(3,3,1^3)$。$\\nu(\\pi_{21})$=大于 $3$ 的部分数，为 $0$。$\\mathrm{crank}(\\pi_{21})=0-3=-3$。\n$\\mathrm{crank}(\\pi_{22})$: $\\mu(\\pi_{22})=0$，所以 $\\mathrm{crank}(\\pi_{22})=3$。\n$\\mathrm{crank}(\\pi_{23})$: $\\mu(\\pi_{23})=2$，部分为 $(3,2,2,1,1)$。$\\nu(\\pi_{23})$=大于 $2$ 的部分数，为 $1$。$\\mathrm{crank}(\\pi_{23})=1-2=-1$。\n$\\mathrm{crank}(\\pi_{24})$: $\\mu(\\pi_{24})=4$，部分为 $(3,2,1^4)$。$\\nu(\\pi_{24})$=大于 $4$ 的部分数，为 $0$。$\\mathrm{crank}(\\pi_{24})=0-4=-4$。\n$\\mathrm{crank}(\\pi_{25})$: $\\mu(\\pi_{25})=6$，部分为 $(3,1^6)$。$\\nu(\\pi_{25})$=大于 $6$ 的部分数，为 $0$。$\\mathrm{crank}(\\pi_{25})=0-6=-6$。\n$\\mathrm{crank}(\\pi_{26})$: $\\mu(\\pi_{26})=1$，部分为 $(2^4,1)$。$\\nu(\\pi_{26})$=大于 $1$ 的部分数，为 $4$。$\\mathrm{crank}(\\pi_{26})=4-1=3$。\n$\\mathrm{crank}(\\pi_{27})$: $\\mu(\\pi_{27})=3$，部分为 $(2^3,1^3)$。$\\nu(\\pi_{27})$=大于 $3$ 的部分数，为 $0$。$\\mathrm{crank}(\\pi_{27})=0-3=-3$。\n$\\mathrm{crank}(\\pi_{28})$: $\\mu(\\pi_{28})=5$，部分为 $(2^2,1^5)$。$\\nu(\\pi_{28})$=大于 $5$ 的部分数，为 $0$。$\\mathrm{crank}(\\pi_{28})=0-5=-5$。\n$\\mathrm{crank}(\\pi_{29})$: $\\mu(\\pi_{29})=7$，部分为 $(2,1^7)$。$\\nu(\\pi_{29})$=大于 $7$ 的部分数，为 $0$。$\\mathrm{crank}(\\pi_{29})=0-7=-7$。\n$\\mathrm{crank}(\\pi_{30})$: $\\mu(\\pi_{30})=9$，部分为 $(1^9)$。$\\nu(\\pi_{30})$=大于 $9$ 的部分数，为 $0$。$\\mathrm{crank}(\\pi_{30})=0-9=-9$。\n\n曲秩分布多项式是 $C_{9}(z)=\\sum_{i=1}^{30} z^{\\mathrm{crank}(\\pi_i)}$。我们合并各项：\n- $z^9, z^7, z^6, z^4, z^{-4}, z^{-6}, z^{-7}, z^{-9}$ 的系数：各为 $1$\n- $z^5, z^2, z^{-2}, z^{-5}$ 的系数：各为 $2$\n- $z^3, z, z^{-1}, z^{-3}$ 的系数：各为 $3$\n- $z^0$ 的系数：$2$\n因此，多项式为：\n$C_{9}(z) = z^{9} + z^{7} + z^{6} + 2z^{5} + z^{4} + 3z^{3} + 2z^{2} + 3z + 2 + 3z^{-1} + 2z^{-2} + 3z^{-3} + z^{-4} + 2z^{-5} + z^{-6} + z^{-7} + z^{-9}$.\n\n同样，通过直接计算证实了系数的对称性。这是曲秩分布多项式的一个普遍性质。其组合证明依赖于一个由 Andrews 和 Garvan 构建的划分集合上的双射，该双射将一个曲秩为 $k$ 的划分映射到一个曲秩为 $-k$ 的划分。这个对合的存在证明了曲秩为 $k$ 的 $n$ 的划分数等于曲秩为 $-k$ 的划分数，从而保证了 $C_n(z)$ 系数的对称性。\n\n最终导出的多项式是：\n$R_{9}(z) = z^{8} + z^{6} + z^{5} + 2z^{4} + 2z^{3} + 3z^{2} + 3z + 4 + 3z^{-1} + 3z^{-2} + 2z^{-3} + 2z^{-4} + z^{-5} + z^{-6} + z^{-8}$\n$C_{9}(z) = z^{9} + z^{7} + z^{6} + 2z^{5} + z^{4} + 3z^{3} + 2z^{2} + 3z + 2 + 3z^{-1} + 2z^{-2} + 3z^{-3} + z^{-4} + 2z^{-5} + z^{-6} + z^{-7} + z^{-9}$", "answer": "$$R_{9}(z) = z^{8} + z^{6} + z^{5} + 2z^{4} + 2z^{3} + 3z^{2} + 3z + 4 + 3z^{-1} + 3z^{-2} + 2z^{-3} + 2z^{-4} + z^{-5} + z^{-6} + z^{-8}$$\n$$C_{9}(z) = z^{9} + z^{7} + z^{6} + 2z^{5} + z^{4} + 3z^{3} + 2z^{2} + 3z + 2 + 3z^{-1} + 2z^{-2} + 3z^{-3} + z^{-4} + 2z^{-5} + z^{-6} + z^{-7} + z^{-9}$$", "id": "3015948"}, {"introduction": "尽管基于五边形数定理的递归极为高效，但它并非计算分拆函数的唯一途径。本练习将引导您设计并分析一种基于分拆“部分大小”的动态规划算法 [@problem_id:3015950]。这种方法源于一个更直接的组合论证，它不仅为计算 $p(n)$ 提供了不同的视角，也是一次关于算法设计和复杂度分析的宝贵实践。", "problem": "给定分割函数 $p(n)$，它计算将一个非负整数 $n$ 写成一个或多个正整数之和的方法数量（不考虑顺序），请设计并实现一个动态规划 (DP) 算法，通过遍历划分块的大小来计算所有 $n \\leq N$ 的 $p(n)$。具体来说，使用以下结构：维护一个一维数组 $d[0, \\dots, N]$，其中 $d[0]=1$，并且对于从 $1$ 到 $N$ 的每个划分块大小 $k$，使用递推关系 $d[n] \\leftarrow d[n] + d[n-k]$ 更新从 $k$ 到 $N$ 的所有 $n$ 对应的 $d[n]$。此递推关系必须严格按照规定的循环顺序使用：外层循环遍历 $k$，内层循环从 $k$ 到 $N$ 递增地遍历 $n$。\n\n从 $p(n)$ 的基本组合定义出发，纯粹从对划分块取自有界集合的划分进行计数的角度来证明该算法的正确性。然后，根据以下约定，精确分析该算法的时间和空间复杂度：\n\n- 时间以对 DP 数组条目 $d[n]$ 执行的基本加法更新的确切次数来衡量，即在给定 $N$ 的整个执行过程中，形式为 $d[n] \\leftarrow d[n] + d[n-k]$ 的操作计数。\n- 空间以存储 DP 状态所需的数组单元的确切数量来衡量，不包括常数大小的标量和循环索引。\n- 为捕捉数值增长，还需计算所有计算出的值 $d[n]$（其中 $0 \\leq n \\leq N$）中的最大位长，其中正整数 $m$ 的位长定义为 $\\lfloor \\log_2(m) \\rfloor + 1$，而 $0$ 的位长定义为 $1$。\n\n您的程序必须实现上述 DP 算法，并为每个指定的测试用例 $N$ 生成以下输出：\n\n- 执行的基本加法确切次数，记为 $T_{\\text{add}}(N)$。\n- 使用的 DP 数组单元的确切数量，记为 $S_{\\text{cells}}(N)$。\n- 计算出的计数中的最大位长，记为 $B_{\\max}(N)$。\n- 划分数列表 $\\left[p(0), p(1), \\dots, p(N)\\right]$。\n\n测试套件：\n- $N = 0$ (边界情况，最小输入)，\n- $N = 1$ (小规模情况)，\n- $N = 5$ (中等规模的小情况)，\n- $N = 30$ (较大规模情况，以检验增长和复杂度)。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。此列表中的每个元素对应一个测试用例 $N$，并且本身必须是一个严格按照 $[T_{\\text{add}}(N), S_{\\text{cells}}(N), B_{\\max}(N), [p(0), p(1), \\dots, p(N)]]$ 顺序排列的列表。例如，包含两个测试用例的输出将如下所示：$[[t_1,s_1,b_1,[\\dots]], [t_2,s_2,b_2,[\\dots]]]$。", "solution": "本任务要求为一种计算整数划分函数 $p(n)$（适用于所有非负整数 $n \\leq N$）的特定动态规划 (DP) 算法提供全面的正确性证明和复杂度分析。算法的实现和输出必须符合一组精确的要求。\n\n### 第一步：问题验证\n\n问题陈述已根据指定标准进行评估，并被确定为**有效**。这是一个来自数论和算法领域的适定、有科学依据的问题。它为任务提供了清晰、完整且一致的描述，包括要使用的确切算法、要计算的分析指标以及所需的输出格式。所有术语都是标准且定义明确的。\n\n### 第二步：基于原理的设计与分析\n\n**组合学基础**\n\n分割函数 $p(n)$ 计算将一个整数 $n$ 写成正整数之和的方法数，其中加数（或“划分块”）的顺序无关紧要。例如，$p(4) = 5$，因为 $4$ 可以写成：$4$、$3+1$、$2+2$、$2+1+1$ 和 $1+1+1+1$。按照惯例，$p(0)=1$，对应于空和。\n\n为了构建 DP 解法，我们引入一个更具约束性的函数。设 $p_k(n)$ 为 $n$ 的划分中所有划分块都小于或等于给定正整数 $k$ 的划分数量。我们的最终目标是计算所有 $n \\le N$ 的 $p(n)$。对于任何这样的 $n$，其任何划分都只能包含小于或等于 $n$ 的划分块，因此也小于或等于 $N$。这意味着对于所有 $n \\le N$，都有 $p_N(n) = p(n)$。\n\n我们可以为 $p_k(n)$ 建立一个递推关系。任何使用来自集合 $\\{1, 2, \\dots, k\\}$ 中元素的 $n$ 的划分都可以分为两个不相交的类别：\n1.  **不**包含划分块 $k$ 的划分。这些是 $n$ 的划分，其所有划分块都来自集合 $\\{1, 2, \\dots, k-1\\}$。根据定义，这类划分的数量为 $p_{k-1}(n)$。\n2.  至少包含一个划分块 $k$ 的划分。如果我们从这样的划分中移除一个划分块 $k$，剩下的部分是整数 $n-k$ 的一个划分。这个剩余划分的划分块也必须小于或等于 $k$。这类划分的数量为 $p_k(n-k)$。\n\n结合这两种情况，我们得到递推关系：\n$$ p_k(n) = p_{k-1}(n) + p_k(n-k) $$\n其基础情况为：对于所有 $k \\ge 0$，$p_k(0) = 1$；对于 $n  0$，$p_0(n) = 0$。\n\n**算法正确性证明**\n\n问题指定了一个使用大小为 $N+1$ 的一维数组（我们称之为 $d$）的 DP 算法。该算法规定如下：\n1.  初始化 $d[0] = 1$ 和 $d[n] = 0$（对于 $n \\in \\{1, \\dots, N\\}$）。\n2.  使用嵌套循环：$k$ 从 $1$ 到 $N$，$n$ 从 $k$ 到 $N$。\n3.  执行更新：$d[n] \\leftarrow d[n] + d[n-k]$。\n\n我们现在证明此过程能正确计算出所有 $n \\le N$ 的 $d[n] = p(n)$。设 $d_k[n]$ 表示在针对划分块大小 $k$ 的外层循环完成后，数组单元 $d[n]$ 中的值。\n初始化对应于 $k=0$ 的基础情况：$d_0[0]=1$（表示 $p_0(0)=1$）和 $d_0[n]=0$（对于 $n0$，表示 $p_0(n)=0$）。\n\n我们采用归纳法证明。假设在 $k-1$ 的外层循环完成后，数组中保存了划分块最大为 $k-1$ 的划分值，即对于所有 $n \\le N$，有 $d_{k-1}[n] = p_{k-1}(n)$。\n\n现在，考虑针对划分块大小 $k$ 的外层循环的执行。内层循环从 $n=k$ 遍历到 $N$。更新操作为：\n$$ d[n] \\leftarrow d[n] + d[n-k] $$\n当对特定的 $n$ 执行此语句时，右侧的 $d[n]$ 是本次更新前的值，即 $d_{k-1}[n]$（因为它最后一次是在 $k-1$ 的循环中更新的）。关键的观察在于项 $d[n-k]$。由于内层循环对 $n$ 是递增的（即我们按 $n=k, k+1, \\dots$ 的顺序计算），$d[n-k]$ 的值在当前对 $k$ 的外层循环中*已经*被更新了。因此，右侧的 $d[n-k]$ 代表的是新值 $d_k[n-k]$。\n因此，该更新规则有效地实现了：\n$$ d_k[n] = d_{k-1}[n] + d_k[n-k] $$\n这正是我们为 $p_k(n)$ 推导出的递推关系。因此，根据归纳法，在 $k$ 的外层循环完成后，我们有 $d_k[n] = p_k(n)$，适用于所有 $n \\in \\{0, \\dots, N\\}$。\n\n在外层循环的最后一次迭代（$k=N$）之后，数组将包含 $d[n] = d_N[n] = p_N(n)$。如前所述，对于 $n \\le N$，$p_N(n) = p(n)$。因此，该算法是正确的。\n\n**复杂度分析**\n\n*   **时间复杂度 ($T_{\\text{add}}(N)$)**：问题将时间复杂度定义为形式为 $d[n] \\leftarrow d[n] + d[n-k]$ 的基本加法更新的确切次数。此操作在嵌套循环内部恰好执行一次。加法次数即为总迭代次数。\n    $$ T_{\\text{add}}(N) = \\sum_{k=1}^{N} \\sum_{n=k}^{N} 1 $$\n    内层求和计算了从 $n=k$ 到 $n=N$ 的值的数量，即 $N - k + 1$。\n    $$ T_{\\text{add}}(N) = \\sum_{k=1}^{N} (N - k + 1) $$\n    这是一个等差数列求和。令 $j = N - k + 1$，当 $k$ 从 $1$ 变为 $N$ 时，$j$ 从 $N$ 变为 $1$。该和等价于：\n    $$ T_{\\text{add}}(N) = \\sum_{j=1}^{N} j = \\frac{N(N+1)}{2} $$\n\n*   **空间复杂度 ($S_{\\text{cells}}(N)$)**：这被定义为 DP 状态所需的数组单元数量。该算法使用一个从 $0$ 到 $N$ 索引的单一数组 $d$。\n    $$ S_{\\text{cells}}(N) = N + 1 $$\n\n*   **最大位长 ($B_{\\max}(N)$)**：这是在所有计算出的划分数 $\\{p(0), p(1), \\dots, p(N)\\}$ 中的最大位长。正整数 $m$ 的位长是 $\\lfloor \\log_2(m) \\rfloor + 1$。由于对于所有 $n \\ge 0$，$p(n)  0$，这个公式适用于 DP 数组中所有的最终值。$B_{\\max}(N)$ 是在 DP 表完全计算完毕后由程序经验性地计算出来的。\n    $$ B_{\\max}(N) = \\max_{0 \\le n \\le N} \\left( \\lfloor \\log_2(p(n)) \\rfloor + 1 \\right) $$", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport sys\n\n# Per problem specification, no other libraries outside the standard library are permitted.\n# numpy is listed as available but is not used, as Python's native arbitrary-precision\n# integers are better suited for the partition function, which grows very rapidly.\n\ndef solve():\n    \"\"\"\n    Solves the integer partition problem for a suite of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        0,  # boundary case with minimal input\n        1,  # small case\n        5,  # moderate small case\n        30, # larger case to exercise growth and complexity\n    ]\n\n    # Increase recursion limit for potentially deep calculations in other contexts,\n    # though not strictly necessary for this iterative DP approach.\n    # sys.setrecursionlimit(2000)\n\n    final_results = []\n    for N in test_cases:\n        # Calculate T_add(N): the exact number of primitive additions.\n        # This is the sum of an arithmetic series: sum_{j=1 to N} j = N * (N + 1) / 2.\n        T_add = (N * (N + 1)) // 2\n\n        # Calculate S_cells(N): the number of DP array cells.\n        # The array is indexed from 0 to N, so it has N+1 cells.\n        S_cells = N + 1\n\n        # DP algorithm to compute partition numbers p(n) for n = N.\n        # The array `dp` will store p(n).\n        dp = [0] * S_cells\n        \n        # Base case: p(0) = 1 (the empty partition).\n        if S_cells  0:\n            dp[0] = 1\n\n        # The outer loop iterates over the part size 'k'.\n        for k in range(1, N + 1):\n            # The inner loop iterates over the integer 'n' to be partitioned.\n            # The loop for 'n' must be increasing for the space optimization to work correctly.\n            for n in range(k, N + 1):\n                dp[n] += dp[n - k]\n\n        # Calculate B_max(N): the maximum bit-length among the computed counts.\n        # The problem defines the bit-length of a positive integer m as\n        # floor(log2(m)) + 1. Python's int.bit_length() method matches this\n        # for positive integers. Since p(n)  0 for all n = 0, this is sufficient.\n        # The bit-length of 0 is defined as 1, but p(n) is never 0 for n = 0.\n        B_max = 0\n        if dp:\n            B_max = max(val.bit_length() for val in dp)\n\n        # Collate results for the current test case N.\n        result_for_N = [T_add, S_cells, B_max, dp]\n        final_results.append(result_for_N)\n\n    # Format and print the final output as a single-line string.\n    # The output is a list of lists, where each inner list corresponds to a test case.\n    # To avoid extra spaces and ensure exact format, we construct the string manually.\n    output_str_parts = []\n    for res in final_results:\n        # res[3] is the list of partition numbers, which needs its own string representation.\n        p_list_str = f\"[{','.join(map(str, res[3]))}]\"\n        # Combine all parts for one test case.\n        case_str = f\"[{res[0]},{res[1]},{res[2]},{p_list_str}]\"\n        output_str_parts.append(case_str)\n    \n    print(f\"[{','.join(output_str_parts)}]\")\n\nsolve()\n```", "id": "3015950"}]}