{"hands_on_practices": [{"introduction": "在数论中，判定一个整数是否为模素数 $p$ 的原根是一项核心技能。虽然根据定义，我们可以逐一计算一个元素的幂来确定其阶，但当 $p$ 很大时，这种方法并不可行。本练习旨在引导你推导并应用一个更高效的判别准则，该准则利用 $p-1$ 的素因子分解，让你掌握在实践中寻找原根的标准方法。[@problem_id:3013938]", "problem": "设 $p=97$ 是一个奇素数。在模 $p$ 的乘法单位群 $(\\mathbb{Z}/p\\mathbb{Z})^{\\times}$ 中进行运算。使用以下标准基础事实作为出发点：\n\n- 根据费马小定理 (FLT)，对于任何满足 $\\gcd(a,p)=1$ 的整数 $a$，有 $a^{p-1} \\equiv 1 \\pmod{p}$，因此 $a$ 在 $(\\mathbb{Z}/p\\mathbb{Z})^{\\times}$ 中的阶整除 $p-1$。\n- 根据有限群的拉格朗日定理，元素的阶整除群的阶。\n\n基于这些事实和关于有限群中阶的第一性原理，推导并证明一个元素 $g \\in (\\mathbb{Z}/p\\mathbb{Z})^{\\times}$ 的阶恰好为 $p-1$ 的一个充要条件，该条件用 $p-1$ 的素因子来表示。然后，通过分解 $p-1=96$，将此判据具体应用于 $p=97$ 的情况，并使用该判据测试小的候选数来计算模 $97$ 的一个原根。一旦找到一个原根 $g$，用 $g$ 的幂和指数中出现的整数 $k$ 来刻画并枚举模 $97$ 的所有原根。\n\n最后，将模 $97$ 的最小原根报告为一个介于 $2$ 和 $96$ 之间的整数。无需四舍五入，也无需单位。", "solution": "该问题陈述清晰，科学上基于已建立的数论，并包含唯一解所需的所有信息。因此，我们可以进行推导和计算。\n\n问题要求一个判据，用以在模素数 $p$ 的乘法单位群 $(\\mathbb{Z}/p\\mathbb{Z})^{\\times}$ 中识别原根。一个元素 $g \\in (\\mathbb{Z}/p\\mathbb{Z})^{\\times}$ 是一个原根，如果它的阶等于群的阶，即 $|\\left(\\mathbb{Z}/p\\mathbb{Z}\\right)^{\\times}| = \\phi(p) = p-1$。\n\n设 $G = (\\mathbb{Z}/p\\mathbb{Z})^{\\times}$ 且 $n = |G| = p-1$。根据费马小定理或拉格朗日定理，对于任何元素 $a \\in G$，$a$ 的阶，记作 $\\text{ord}_p(a)$，必须整除 $n$。原根 $g$ 是一个满足 $\\text{ord}_p(g) = n$ 的元素。\n\n为了推导一个元素 $g$ 是原根的判据，我们考虑其反面：$g$ *不是* 原根意味着什么？如果 $g$ 不是原根，它的阶 $d = \\text{ord}_p(g)$ 必须是 $n=p-1$ 的一个真因子。也就是说，$d  n$ 且 $d|n$。\n\n设 $n=p-1$ 的素因子分解为 $n = q_1^{e_1} q_2^{e_2} \\cdots q_k^{e_k}$，其中 $q_1, q_2, \\dots, q_k$ 是 $n$ 的不同素因子。如果 $d$ 是 $n$ 的一个真因子，那么必定存在 $n$ 的某个素因子 $q_i$，使得整除 $d$ 的 $q_i$ 的幂次小于整除 $n$ 的 $q_i$ 的幂次。这意味着 $d$ 必须整除整数 $\\frac{n}{q_i}$，对于至少一个 $i \\in \\{1, 2, \\dots, k\\}$。\n\n陈述“$\\text{ord}_p(g)$ 整除 $m$”等价于条件 $g^m \\equiv 1 \\pmod{p}$。\n因此，$g$ 不是原根当且仅当它的阶 $\\text{ord}_p(g)$ 整除 $\\frac{p-1}{q_i}$，对于 $p-1$ 的至少一个不同素因子 $q_i$。这等价于陈述 $g^{(p-1)/q_i} \\equiv 1 \\pmod{p}$，对于至少一个 $i \\in \\{1, 2, \\dots, k\\}$。\n\n通过取该陈述的逻辑逆否命题，我们得到 $g$ 是原根的充要条件：\n一个元素 $g \\in (\\mathbb{Z}/p\\mathbb{Z})^{\\times}$ 是模 $p$ 的原根，当且仅当对于 $p-1$ 的每一个不同素因子 $q$，都有 $g^{(p-1)/q} \\not\\equiv 1 \\pmod{p}$。\n\n我们现在将此判据应用于 $p=97$ 的具体情况。首先，我们必须分解 $p-1$：\n$p-1 = 97-1 = 96$。\n$96$ 的素因子分解是 $96 = 32 \\times 3 = 2^5 \\times 3^1$。\n$96$ 的不同素因子是 $q_1 = 2$ 和 $q_2 = 3$。\n\n根据我们推导的判据，一个整数 $g$ 是模 $97$ 的原根，当且仅当它满足以下两个条件：\n1. $g^{96/2} \\not\\equiv 1 \\pmod{97} \\implies g^{48} \\not\\equiv 1 \\pmod{97}$\n2. $g^{96/3} \\not\\equiv 1 \\pmod{97} \\implies g^{32} \\not\\equiv 1 \\pmod{97}$\n\n我们测试小的整数候选 $g$，从 $g=2$ 开始。所有计算都在模 $97$ 下进行。\n\n测试 $g=2$：\n我们需要计算 $2^{32} \\pmod{97}$ 和 $2^{48} \\pmod{97}$。\n$2^5 = 32$\n$2^6 = 64$\n$2^7 = 128 \\equiv 31 \\pmod{97}$\n$2^8 = 256 \\equiv 62 \\pmod{97}$\n$2^{16} \\equiv 62^2 = 3844 = 39 \\times 97 + 61 \\equiv 61 \\pmod{97}$\n$2^{32} \\equiv 61^2 = 3721 = 38 \\times 97 + 35 \\equiv 35 \\pmod{97}$。\n由于 $35 \\not\\equiv 1 \\pmod{97}$，第二个条件满足。\n现在我们检查第一个条件：\n$2^{48} = 2^{32} \\times 2^{16} \\equiv 35 \\times 61 = 2135 = 22 \\times 97 + 1 \\equiv 1 \\pmod{97}$。\n第一个条件 $g^{48} \\not\\equiv 1 \\pmod{97}$ 不成立。因此，$2$ 不是模 $97$ 的原根。它的阶是 $48$。\n\n测试 $g=3$：\n我们计算 $3^{32} \\pmod{97}$ 和 $3^{48} \\pmod{97}$。\n$3^4 = 81 \\equiv -16 \\pmod{97}$\n$3^8 \\equiv (-16)^2 = 256 \\equiv 62 \\pmod{97}$\n$3^{16} \\equiv 62^2 = 3844 \\equiv 61 \\pmod{97}$\n$3^{32} \\equiv 61^2 = 3721 \\equiv 35 \\pmod{97}$。\n由于 $35 \\not\\equiv 1 \\pmod{97}$，第二个条件满足。\n现在我们检查第一个条件：\n$3^{48} = 3^{32} \\times 3^{16} \\equiv 35 \\times 61 = 2135 \\equiv 1 \\pmod{97}$。\n第一个条件不成立。因此，$3$ 不是模 $97$ 的原根。它的阶是 $48$。\n\n测试 $g=5$：\n我们计算 $5^{32} \\pmod{97}$ 和 $5^{48} \\pmod{97}$。\n$5^2 = 25$\n$5^4 = 625 = 6 \\times 97 + 43 \\equiv 43 \\pmod{97}$\n$5^8 \\equiv 43^2 = 1849 = 19 \\times 97 + 6 \\equiv 6 \\pmod{97}$\n$5^{16} \\equiv 6^2 = 36 \\pmod{97}$\n$5^{32} \\equiv 36^2 = 1296 = 13 \\times 97 + 35 \\equiv 35 \\pmod{97}$。\n由于 $35 \\not\\equiv 1 \\pmod{97}$，第二个条件满足。\n现在我们检查第一个条件：\n$5^{48} = 5^{32} \\times 5^{16} \\equiv 35 \\times 36 = 1260 = 12 \\times 97 + 96 \\equiv 96 \\equiv -1 \\pmod{97}$。\n由于 $-1 \\not\\equiv 1 \\pmod{97}$，第一个条件也满足。\n$g=5$ 两个条件都成立，所以 $5$ 是模 $97$ 的原根。由于这是我们按递增顺序测试找到的第一个，所以 $5$ 是模 $97$ 的最小原根。\n\n最后，我们刻画并枚举模 $97$ 的所有原根。由于 $g=5$ 是一个原根，群 $(\\mathbb{Z}/97\\mathbb{Z})^{\\times}$ 是循环的，由 $5$ 生成。其元素为 $\\{5^1, 5^2, \\dots, 5^{96}\\}$。元素 $g^k$ 的阶由 $\\text{ord}(g^k) = \\frac{\\text{ord}(g)}{\\gcd(k, \\text{ord}(g))}$ 给出。\n在我们的例子中，$\\text{ord}(5) = 96$。为了使 $5^k$ 成为原根，它的阶也必须是 $96$。这要求：\n$\\frac{96}{\\gcd(k, 96)} = 96 \\implies \\gcd(k, 96) = 1$。\n整数 $k$ 必须在 $1 \\leq k \\leq 96$ 的范围内。因此，原根是所有形如 $5^k \\pmod{97}$ 的元素，其中 $k$ 是与 $96$ 互素的整数。\n这样的整数 $k$ 的数量由欧拉总计函数 $\\phi(96)$ 给出。\n$\\phi(96) = \\phi(2^5 \\times 3) = \\phi(2^5) \\phi(3) = (2^5 - 2^4)(3-1) = (32 - 16)(2) = 16 \\times 2 = 32$。\n模 $97$ 共有 $32$ 个原根。它们是元素 $5^k \\pmod{97}$，其中所有 $k \\in \\{1, 5, 7, 11, 13, 17, 19, 23, \\dots, 95\\}$ 满足 $\\gcd(k, 96)=1$。\n\n问题要求模 $97$ 的最小原根，我们已计算出其为 $5$。", "answer": "$$\\boxed{5}$$", "id": "3013938"}, {"introduction": "掌握了素数模 $p$ 的原根后，一个自然的问题是：原根是否存在于素数幂 $p^k$ 的模下？乘法群 $(\\mathbb{Z}/p^k\\mathbb{Z})^\\times$ 的结构比 $(\\mathbb{Z}/p\\mathbb{Z})^\\times$ 更为复杂，其性质不能直接照搬。本练习将带领你探索从模 $p$ 到模 $p^2$ 的过渡，通过具体计算来验证一个元素成为模 $p^2$ 原根的关键条件，这是理解更一般情况 $p^k$ 的重要一步。[@problem_id:3013911]", "problem": "设 $p$ 是一个奇素数，并考虑模 $p^{2}$ 的乘法单位群，记作 $(\\mathbb{Z}/p^{2}\\mathbb{Z})^{\\times}$。回顾以下基本事实：$(\\mathbb{Z}/p\\mathbb{Z})^{\\times}$ 是一个阶为 $p-1$ 的循环群，$(\\mathbb{Z}/p^{2}\\mathbb{Z})^{\\times}$ 是一个阶为 $p(p-1)$ 的循环群，并且元素 $a$ 模 $m$ 的阶是满足 $a^{t} \\equiv 1 \\pmod{m}$ 的最小正整数 $t$。如果一个元素 $g$ 的阶等于 $\\varphi(m)$（其中 $\\varphi$ 是欧拉函数），则称 $g$ 为模 $m$ 的原根。仅使用这些基本定义和事实，按如下方式分析 $p=19$ 和 $a=2$ 的情况：\n\n1. 通过检验 $18$ 的所有真因子，确定 $2$ 在 $(\\mathbb{Z}/19\\mathbb{Z})^{\\times}$ 中的阶。\n2. 使用一个基于上述事实的独立论证，通过不假定除循环性陈述之外任何专门定理的显式计算，来验证同余式 $2^{18} \\not\\equiv 1 \\pmod{19^{2}}$。\n3. 根据你的分析，得出 $2$ 在 $(\\mathbb{Z}/19^{2}\\mathbb{Z})^{\\times}$ 中的确切阶数。\n\n将你的最终答案表示为单个整数，即 $2$ 模 $19^{2}$ 的阶。无需四舍五入。", "solution": "问题要求确定元素 $2$ 在整数模 $19^2$ 的乘法群 $(\\mathbb{Z}/19^2\\mathbb{Z})^{\\times}$ 中的阶。分析将按指定的三个步骤进行。素数为 $p=19$，元素为 $a=2$。\n\n首先，我们确定 $2$ 在群 $(\\mathbb{Z}/19\\mathbb{Z})^{\\times}$ 中的阶。问题指出，对于素数 $p$，该群是阶为 $p-1$ 的循环群。对于素数 $p=19$，群 $(\\mathbb{Z}/19\\mathbb{Z})^{\\times}$ 的阶是 $\\varphi(19) = 19-1 = 18$。根据拉格朗日定理，该群中任何元素的阶都必须是群阶的因子。$18$ 的因子是 $1, 2, 3, 6, 9$ 和 $18$。为了找到 $2$ 的阶，我们必须从这个集合中找到满足 $2^t \\equiv 1 \\pmod{19}$ 的最小正整数 $t$。我们检验 $18$ 的真因子：\n- $2^1 \\equiv 2 \\pmod{19}$\n- $2^2 \\equiv 4 \\pmod{19}$\n- $2^3 \\equiv 8 \\pmod{19}$\n- $2^6 = (2^3)^2 \\equiv 8^2 = 64 \\equiv 64 - 3 \\times 19 = 57 \\equiv 7 \\pmod{19}$\n- $2^9 = 2^3 \\times 2^6 \\equiv 8 \\times 7 = 56 \\equiv 56 - 2 \\times 19 = 38 \\equiv 18 \\equiv -1 \\pmod{19}$\n\n由于对于 $18$ 的任何真因子 $k$，$2^k \\not\\equiv 1 \\pmod{19}$，因此 $2$ 模 $19$ 的阶必为 $18$。这证明了 $2$ 是模 $19$ 的一个原根。\n\n其次，我们需要通过显式计算验证 $2^{18} \\not\\equiv 1 \\pmod{19^2}$。模为 $m = 19^2 = 361$。我们使用平方求幂法计算 $2^{18} \\pmod{361}$。\n- $2^1 \\equiv 2 \\pmod{361}$\n- $2^2 \\equiv 4 \\pmod{361}$\n- $2^4 = (2^2)^2 \\equiv 4^2 = 16 \\pmod{361}$\n- $2^8 = (2^4)^2 \\equiv 16^2 = 256 \\pmod{361}$\n- $2^{16} = (2^8)^2 \\equiv 256^2 = 65536 \\pmod{361}$。为了化简，我们作带余除法：$65536 = 181 \\times 361 + 195$。因此，$2^{16} \\equiv 195 \\pmod{361}$。\n指数 $18$ 可以写成 $18 = 16+2$。因此，我们可以将 $2^{18}$ 计算为 $2^{16} \\times 2^2$。\n- $2^{18} = 2^{16} \\times 2^2 \\equiv 195 \\times 4 \\pmod{361}$\n- $195 \\times 4 = 780$。为了化简，我们再次作带余除法：$780 = 2 \\times 361 + 58$。\n- 所以，$2^{18} \\equiv 58 \\pmod{361}$。\n由于 $58 \\not\\equiv 1 \\pmod{361}$，所需验证完成。\n\n第三，我们得出 $2$ 在 $(\\mathbb{Z}/19^2\\mathbb{Z})^{\\times}$ 中的确切阶数。设此阶为 $t$。问题指出，对于奇素数 $p$，群 $(\\mathbb{Z}/p^2\\mathbb{Z})^{\\times}$ 是阶为 $\\varphi(p^2)$ 的循环群。对于 $p=19$，这个阶是 $\\varphi(19^2) = 19^2 - 19^1 = 19(19-1) = 19 \\times 18 = 342$。\n根据拉格朗日定理，元素 $2$ 的阶 $t$ 必须整除群的阶，所以 $t$ 必须是 $342$ 的因子。\n根据阶的定义，我们有 $2^t \\equiv 1 \\pmod{19^2}$。这个同余式蕴含了较弱的同余式 $2^t \\equiv 1 \\pmod{19}$。\n从我们分析的第一部分可知，$2$ 模 $19$ 的阶是 $18$。阶的一个基本性质指出，如果 $a^n \\equiv 1 \\pmod{m}$，那么 $a$ 模 $m$ 的阶必须整除 $n$。将此应用于我们的情况，$18$ 必须整除 $t$。\n所以，$t$ 必须是 $18$ 的倍数，并且是 $342$ 的因子。我们来考察 $342 = 18 \\times 19$ 的因子。满足这两个条件的整数是 $18$ 和 $18 \\times 19 = 342$。\n在第二部分，我们明确证明了 $2^{18} \\not\\equiv 1 \\pmod{19^2}$。因此，阶 $t$ 不可能是 $18$。\n唯一剩下的可能性是 $t=342$。\n因此，$2$ 在群 $(\\mathbb{Z}/19^2\\mathbb{Z})^{\\times}$ 中的阶是 $342$。这也意味着 $2$ 是模 $19^2$ 的一个原根。", "answer": "$$\\boxed{342}$$", "id": "3013911"}, {"introduction": "理论知识的最终检验在于其应用。本练习将理论与实践相结合，要求你将寻找原根的判别准则转化为一个具体的计算机算法。通过这个过程，你不仅需要正确实现数学逻辑，还需分析算法的效率，并将其应用于处理大素数，这正是现代数论在密码学等领域应用的核心技能。[@problem_id:3013928]", "problem": "设计并实现一个程序，该程序对于每个给定的素数 $p$ 以及 $p-1$ 的不同素因子列表，计算一个模 $p$ 的原根，并以指定格式输出结果集合。你的算法及其理由必须从以下基础推导得出：\n\n- 模素数 $p$ 的乘法群，记为 $(\\mathbb{Z}/p\\mathbb{Z})^\\times$，其阶为 $p-1$。\n- 有限群中一个元素 $g$ 的阶是使 $g^d \\equiv 1 \\pmod{p}$ 成立的最小正整数 $d$。\n- Lagrange 定理：有限群中任何元素的阶都整除群的阶。\n- 素因子分解和整除性的基本性质。\n\n在此基础上，推导出一个准则，该准则允许你判断候选的 $g$ 是否生成 $(\\mathbb{Z}/p\\mathbb{Z})^\\times$。然后，设计一个算法，利用所提供的 $p-1$ 的素因子来搜索这样一个 $g$，并论证该算法的正确性和复杂性。\n\n实现要求：\n\n- 输入模型：无外部输入。在程序内部硬编码下述测试套件。\n- 算法输出：对于每个测试用例，返回一个整数 $g$，该整数是模 $p$ 的原根。若 $p=2$，返回 $g=1$（因为 $(\\mathbb{Z}/2\\mathbb{Z})^\\times$ 只有一个元素，该元素平凡地生成该群）。\n- 正确性论证：在你的解决方案中，解释为什么对于所有整除 $p-1$ 的素数 $q$，测试 $g^{(p-1)/q} \\not\\equiv 1 \\pmod{p}$ 就足以断定 $g$ 的阶为 $p-1$。\n- 复杂性论证：在你的解决方案中，分析算法的时间复杂度，将其表示为 $p$ 和 $p-1$ 的不同素因子数量的函数，并将期望检查的候选者数量与比率 $\\dfrac{p-1}{\\varphi(p-1)}$ 联系起来，其中 $\\varphi$ 是 Euler 欧拉函数。\n\n测试套件：\n\n- 情况 1：$p=2$，$p-1=1$ 没有素因子。\n- 情况 2：$p=3$，$p-1=2$，不同素因子为 $2$。\n- 情况 3：$p=5$，$p-1=4$，不同素因子为 $2$。\n- 情况 4：$p=7$，$p-1=6$，不同素因子为 $2$ 和 $3$。\n- 情况 5：$p=17$，$p-1=16$，不同素因子为 $2$。\n- 情况 6：$p=19$，$p-1=18$，不同素因子为 $2$ 和 $3$。\n- 情况 7：$p=41$，$p-1=40$，不同素因子为 $2$ 和 $5$。\n- 情况 8：$p=97$，$p-1=96$，不同素因子为 $2$ 和 $3$。\n- 情况 9：$p=998244353$，$p-1=998244352$，不同素因子为 $2$、$7$ 和 $17$。\n\n最终输出格式：\n\n- 你的程序应产生单行输出，包含一个用方括号括起来的逗号分隔列表，结果按上述情况的顺序排列。例如，输出必须形如 $[g_1,g_2,\\dots,g_9]$，其中每个 $g_i$ 是为情况 $i$ 找到的原根。", "solution": "该问题要求设计并实现一个算法，以找到给定素数 $p$ 的一个模 $p$ 原根。原根是模 $p$ 整数乘法群（记为 $(\\mathbb{Z}/p\\mathbb{Z})^\\times$）的一个生成元。该群由集合 $\\{1, 2, \\dots, p-1\\}$ 在模 $p$ 乘法下构成。该群的阶为 $\\varphi(p) = p-1$，其中 $\\varphi$ 是 Euler 欧拉函数。一个元素 $g \\in (\\mathbb{Z}/p\\mathbb{Z})^\\times$ 是原根，当且仅当它的阶（记为 $\\text{ord}_p(g)$）等于群的阶，即 $\\text{ord}_p(g) = p-1$。\n\n首先，我们必须推导出一个准则，利用所提供的 $p-1$ 的不同素因子列表，来高效地测试一个候选元素 $g$ 是否为原根。\n\n**准则的推导**\n设 $p$ 为一个素数。乘法群 $(\\mathbb{Z}/p\\mathbb{Z})^\\times$ 是一个阶为 $p-1$ 的循环群。设 $g$ 是该群中的一个元素。根据 Lagrange 定理，有限群中任何元素的阶都必须整除群的阶。因此，$\\text{ord}_p(g)$ 必须是 $p-1$ 的一个因子。\n\n要证明 $g$ 是一个原根，我们必须证明它的阶恰好是 $p-1$。这等价于证明它的阶不是 $p-1$ 的任何真因子。$p-1$ 的真因子是指任何小于 $p-1$ 的因子。\n\n设 $p-1$ 的素因子分解为 $p-1 = q_1^{a_1} q_2^{a_2} \\cdots q_k^{a_k}$，其中 $q_1, q_2, \\dots, q_k$ 是不同的素因子，而 $a_i \\ge 1$ 是它们各自的重数。\n\n现在，考虑 $g$ 的阶 $\\text{ord}_p(g)$。如果 $\\text{ord}_p(g)$ 是 $p-1$ 的一个真因子，那么必定存在 $p-1$ 的某个素因子 $q_i$，使得 $\\text{ord}_p(g)$ 整除整数 $(p-1)/q_i$。这是因为与 $p-1$ 相比，$p-1$ 的任何真因子 $d$ 都必然缺少至少一个素因子（或某个素因子的幂次较低），因此对于某个 $q_i$，$d$ 必定整除 $(p-1)/q_i$。\n\n如果 $\\text{ord}_p(g)$ 整除 $(p-1)/q_i$，那么我们可以写成 $(p-1)/q_i = m \\cdot \\text{ord}_p(g)$，其中整数 $m \\ge 1$。根据阶的定义，$g^{\\text{ord}_p(g)} \\equiv 1 \\pmod{p}$。将两边取 $m$ 次幂，我们得到：\n$$g^{(p-1)/q_i} = g^{m \\cdot \\text{ord}_p(g)} = \\left(g^{\\text{ord}_p(g)}\\right)^m \\equiv 1^m \\equiv 1 \\pmod{p}$$\n这给了我们一个关键的洞见：如果 $g$ 的阶是 $p-1$ 的一个真因子，那么对于 $p-1$ 的至少一个不同素因子 $q_i$，$g^{(p-1)/q_i} \\equiv 1 \\pmod{p}$ 必定成立。\n\n该陈述的逆否命题为我们提供了所寻求的充分必要准则：\n一个元素 $g \\in (\\mathbb{Z}/p\\mathbb{Z})^\\times$ 的阶为 $p-1$（即，是一个原根），当且仅当对于 $p-1$ 的每一个不同素因子 $q$，以下条件成立：\n$$g^{(p-1)/q} \\not\\equiv 1 \\pmod{p}$$\n如果这个条件对 $p-1$ 的所有不同素因子 $q$ 都成立，就保证了 $g$ 的阶不可能是 $p-1$ 的任何最大真因子的因子，因此不可能是任何真因子。由于阶必须整除 $p-1$，唯一剩下的可能性就是阶恰好为 $p-1$。\n\n**算法设计**\n基于推导出的准则，我们可以构建一个算法来寻找模 $p$ 的原根。\n1.  处理基本情况：如果 $p=2$，群是 $(\\mathbb{Z}/2\\mathbb{Z})^\\times = \\{1\\}$，阶为 $1$。元素 $1$ 是生成元。因此，对于 $p=2$，原根是 $1$。\n2.  对于 $p > 2$，获取 $p-1$ 的不同素因子列表，我们称这个集合为 $Q = \\{q_1, q_2, \\dots, q_k\\}$。\n3.  从 $g=2, 3, 4, \\dots, p-1$ 开始，遍历候选整数 $g$。\n4.  对每个候选 $g$，使用该准则检查它是否为原根：\n    a. 对每个不同的素因子 $q_i \\in Q$，计算 $g^{(p-1)/q_i} \\pmod{p}$。这个计算应该使用模幂运算（也称为快速幂）来高效地执行。\n    b. 如果对于任何一个 $q_i$，$g^{(p-1)/q_i} \\equiv 1 \\pmod{p}$，那么 $g$ 不是原根。丢弃此候选并继续处理下一个 $g$ 值。\n    c. 如果对于所有 $q_i \\in Q$，$g^{(p-1)/q_i} \\not\\equiv 1 \\pmod{p}$，那么 $g$ 是一个原根。\n5.  第一个满足该准则的整数 $g$ 就是一个有效的原根。返回这个 $g$ 并终止搜索。对于任何素数模，至少存在一个原根，这保证了搜索总会终止。\n\n**复杂度分析**\n设 $p$ 为素数模， $k$ 为 $p-1$ 的不同素因子的数量。\n- **测试单个候选 $g$**：测试涉及 $k$ 次模幂运算。每次幂运算的形式是 $g^E \\pmod{p}$，其中 $E = (p-1)/q_i  p$。使用快速幂，这需要 $O(\\log E)$ 或 $O(\\log p)$ 次模乘法。因此，检查单个候选 $g$ 需要 $O(k \\log p)$ 的时间。\n\n- **需要测试的候选数量**：模 $p$ 的原根数量由 $\\varphi(p-1)$ 给出。群中候选总数为 $p-1$。假设原根是近似随机分布的，从 $(\\mathbb{Z}/p\\mathbb{Z})^\\times$ 中随机选择一个元素是原根的概率是 $\\frac{\\varphi(p-1)}{p-1}$。找到第一个原根的期望试验次数是这个概率的倒数，即 $\\frac{p-1}{\\varphi(p-1)}$。\n\n该比率的值由乘积 $\\prod_{q | (p-1)} \\frac{q}{q-1}$ 给出。这个值随 $p-1$ 增长非常缓慢。已知 $\\frac{n}{\\varphi(n)} = O(\\log \\log n)$。因此，需要检查的候选者的期望数量很小，约为 $O(\\log \\log p)$ 级别。\n\n- **总期望复杂度**：总的期望时间复杂度是期望候选者数量与测试每个候选者时间的乘积。\n$$ \\text{期望时间} = O\\left(\\frac{p-1}{\\varphi(p-1)} \\cdot k \\cdot \\log p\\right) $$\n鉴于 $k = \\omega(p-1)$（不同素因子的数量）被 $O(\\frac{\\log p}{\\log \\log p})$ 界定，且 $\\frac{p-1}{\\varphi(p-1)}$ 被 $O(\\log \\log p)$ 界定，总的期望复杂度非常高效，大约在 $O((\\log p)^2)$ 级别。这使得该算法即使对于像测试套件中的大素数也十分实用。", "answer": "```python\n# The final answer must be a single, complete, standalone program.\n# This program finds a primitive root for a given prime p,\n# provided with the distinct prime factors of p-1.\n\ndef find_primitive_root(p, prime_factors_of_p_minus_1):\n    \"\"\"\n    Finds the smallest positive integer that is a primitive root modulo p.\n\n    Args:\n        p (int): A prime number.\n        prime_factors_of_p_minus_1 (list[int]): A list of distinct prime factors of p-1.\n    \n    Returns:\n        int: The smallest primitive root modulo p.\n    \"\"\"\n    # Per the problem statement, for p=2, the group has one element {1},\n    # which is trivially a generator.\n    if p == 2:\n        return 1\n\n    phi = p - 1\n\n    # Iterate through candidates for the primitive root, starting from g=2.\n    g = 2\n    while g  p:\n        is_primitive = True\n        \n        # A number g is a primitive root modulo p if for all distinct prime\n        # factors q of p-1, g^((p-1)/q) is not congruent to 1 mod p.\n        for q in prime_factors_of_p_minus_1:\n            exponent = phi // q\n            \n            # Use pow(base, exp, mod) for efficient modular exponentiation.\n            if pow(g, exponent, p) == 1:\n                is_primitive = False\n                break  # This g is not a primitive root, try the next one.\n        \n        if is_primitive:\n            # We found the smallest primitive root.\n            return g\n        \n        g += 1\n    \n    # This part of the code should be unreachable if p is a prime number,\n    # as a primitive root is guaranteed to exist.\n    return -1 # Should not happen for a prime p.\n\n\ndef solve():\n    \"\"\"\n    Runs the specified test suite and prints the results in the required format.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each tuple contains (p, [distinct prime factors of p-1]).\n    test_cases = [\n        (2, []),\n        (3, [2]),\n        (5, [2]),\n        (7, [2, 3]),\n        (17, [2]),\n        (19, [2, 3]),\n        (41, [2, 5]),\n        (97, [2, 3]),\n        (998244353, [2, 7, 17]),\n    ]\n\n    results = []\n    for p, factors in test_cases:\n        root = find_primitive_root(p, factors)\n        results.append(root)\n\n    # The final print statement must produce only the specified single-line format.\n    print(f\"[{','.join(map(str, results))}]\")\n\n# Execute the solver.\nsolve()\n\n```", "id": "3013928"}]}