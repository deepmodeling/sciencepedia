{"hands_on_practices": [{"introduction": "掌握一个定理的最好方式是从一个直接的应用开始。这个练习旨在帮助你熟悉威尔逊定理的基本形式，并通过一个具体的计算来巩固你的理解。你需要运用威尔逊定理来处理一个包含阶乘的模算术表达式 [@problem_id:1414794]。", "problem": "在数论研究中，阶乘在模算术下的行为是一个经典课题。设整数 $N$ 由表达式 $N = 3 \\cdot (35!) + 95$ 定义。你的任务是求 $N$ 除以素数 $37$ 的余数。", "solution": "我们要求 $N \\pmod{37}$，其中 $N = 3 \\cdot (35!) + 95$ 且 $37$ 是一个素数。根据威尔逊定理，对于一个素数 $p$，有 $(p-1)! \\equiv -1 \\pmod{p}$。取 $p=37$，我们得到\n$$\n36! \\equiv -1 \\pmod{37}.\n$$\n因为 $36! = 36 \\cdot 35!$ 且 $36 \\equiv -1 \\pmod{37}$，我们有\n$$\n36 \\cdot 35! \\equiv -1 \\pmod{37} \\quad \\Longrightarrow \\quad (-1)\\cdot 35! \\equiv -1 \\pmod{37}.\n$$\n两边同乘以 $-1$ 可得\n$$\n35! \\equiv 1 \\pmod{37}.\n$$\n因此，\n$$\nN \\equiv 3 \\cdot 35! + 95 \\equiv 3 \\cdot 1 + 95 \\equiv 98 \\pmod{37}.\n$$\n将 $98$ 对 $37$ 取模，注意到 $37 \\cdot 2 = 74$，因此 $98 - 74 = 24$，所以\n$$\n98 \\equiv 24 \\pmod{37}.\n$$\n因此 $N$ 除以 $37$ 的余数是 $24$。", "answer": "$$\\boxed{24}$$", "id": "1414794"}, {"introduction": "威尔逊定理为素数提供了一个精确的刻画，但这自然引出了一个问题：对于合数 $n$，$ (n-1)! \\pmod n $ 的行为是怎样的？这个练习挑战了一个关于此表达式的常见但过于简化的猜想 [@problem_id:1414833]。通过寻找一个反例，你将更深入地理解该定理为何是一个有效的素性检验，并探索其适用性的边界。", "problem": "在数论中，威尔逊定理给出了一个关于素数的著名性质。该定理指出，一个大于 $p > 1$ 的整数 $p$ 是素数，当且仅当 $(p-1)! \\equiv -1 \\pmod p$。\n\n一名学生提出了一个相关但更广泛的关于阶乘在模运算下行为的断言：\n“对于任何整数 $n > 2$，表达式 $(n-1)! \\pmod n$ 的值总是两个值之一：$0$ 或 $n-1$。”\n\n研究这个断言的有效性。如果该断言是错误的，请找出作为反例的最小整数 $n > 2$。", "solution": "该断言声称，对于每个整数 $n>2$，$(n-1)!$ 模 $n$ 的余数要么是 $0$ 要么是 $n-1$。我们分情况进行分析。\n\n首先，如果 $n$ 是素数，根据威尔逊定理\n$$\n(n-1)! \\equiv -1 \\pmod n,\n$$\n即 $(n-1)! \\equiv n-1 \\pmod n$。因此，所有大于 2 的素数 $n$ 都满足该断言。\n\n其次，假设 $n$ 是合数。如果 $n$ 至少有两个不同的素因子，令 $p$ 是 $n$ 的任意一个素因子，并设 $s = n/p$。那么 $2 \\leq p \\leq n-1$ 且 $2 \\leq s \\leq n-1$，所以 $p$ 和 $s$ 都出现在因子 $1,2,\\dots,n-1$ 中。它们的乘积是 $ps=n$，因此 $n$ 整除 $(n-1)!$，所以\n$$\n(n-1)! \\equiv 0 \\pmod n.\n$$\n所以该断言在这种子情况下成立。\n\n剩下的情况是考虑 $n$ 为素数幂，即 $n=p^{a}$，其中 $a \\ge 2$。使用勒让德公式计算 $p$-adic 赋值，$(p^{a}-1)!$ 中 $p$ 的指数是\n$$\nv_{p}\\big((p^{a}-1)!\\big) \\;=\\; \\sum_{k=1}^{\\infty} \\left\\lfloor \\frac{p^{a}-1}{p^{k}} \\right\\rfloor \\;=\\; \\sum_{k=1}^{a-1} \\left(p^{a-k}-1\\right) \\;\\geq\\; \\left\\lfloor \\frac{p^{a}-1}{p} \\right\\rfloor \\;=\\; p^{a-1}-1.\n$$\n我们需要 $v_{p}\\big((p^{a}-1)!\\big) \\geq a$ 来确保 $p^{a} \\mid (p^{a}-1)!$，这将得到 $(n-1)! \\equiv 0 \\pmod n$。不等式 $p^{a-1}-1 \\geq a$ 对所有 $a \\ge 3$ 和所有素数 $p$ 成立，并且当 $a=2$ 且 $p \\ge 3$ 时也成立（因为 $p^{1}-1=p-1 \\ge 2$）。唯一不成立的情况是当 $p=2$ 和 $a=2$ 时，即 $n=4$ 的情况，此时\n$$\nv_{2}(3!) \\;=\\; \\left\\lfloor \\frac{3}{2} \\right\\rfloor \\;=\\; 1  2,\n$$\n所以 $4 \\nmid 3!$。\n\n直接计算这个特殊情况，\n$$\n(4-1)! \\;=\\; 6 \\;\\equiv\\; 2 \\pmod 4,\n$$\n这个结果既不是 $0$ 也不是 $4-1=3$。因此，该断言是错误的，而 $n=4$ 是一个反例。\n\n为了确认其最小性，我们注意到 $n=3$（素数）时有 $(3-1)! = 2 \\equiv 2 = 3-1 \\pmod 3$，所以它不是反例。因此，违反该断言的最小整数 $n>2$ 是 $n=4$。", "answer": "$$\\boxed{4}$$", "id": "1414833"}, {"introduction": "在现代数论中，理论见解与计算方法紧密相连。这个练习将我们从纯理论计算推向算法设计的领域，这是一个研究生阶段的关键技能 [@problem_id:3031237]。你的任务是为计算威尔逊定理核心表达式 $(n-1)! \\pmod n$ 设计一个高效的算法，并对其计算复杂性进行严谨的分析。", "problem": "设计并论证一个算法，该算法使用整数 $1,2,\\dots,n-1$ 的平衡乘积树来计算阶乘的余数 $(n-1)! \\pmod n$，并根据标准位运算模型对其位复杂度进行严格分析。该算法必须从第一性原理推导，即模运算的定义和定律、整数乘法的结合律以及公认的多精度整数乘法渐近成本。不得援引任何为特殊类别 $n$ 给出 $(n-1)! \\pmod n$ 最终值的预先陈述的定理；相反，应直接从计算的定义和结构属性推导算法步骤和复杂度界限。\n\n使用的基本原理：\n- 模约减的定义：对于整数 $a$ 和 $n \\ge 1$，$a \\pmod n$ 是唯一的整数 $r \\in \\{0,1,\\dots,n-1\\}$，使得对于某个整数 $q$，有 $a = q n + r$。\n- 整数乘法的结合律和交换律：对于整数 $x,y,z$，有 $(xy)z = x(yz)$ 和 $xy = yx$。\n- 随机存取机（RAM）上多精度算术的标准位复杂度模型：令 $M(k)$ 表示两个 $k$ 位整数相乘的位复杂度；特别地，使用快速傅里叶变换（FFT），有 $M(k) = O\\big(k \\log k \\log \\log k\\big)$，并且对一个 $k$ 位模数进行模约减的成本为 $O\\big(M(k)\\big)$。\n\n算法设计和分析的要求：\n1. 将乘积构造为一棵平衡二叉树：在叶子层，放置 $1,2,\\dots,n-1$；在每个内部节点，将两个子节点的余数相乘并对 $n$ 取模，即计算 $((a \\cdot b) \\pmod n)$。如果某一层有奇数个节点，则将最后一个节点不做改变地带到上一层。\n2. 从第一性原理证明正确性：仅使用乘法结合律和模约减的定义，论证为什么最终的根节点值等于 $(n-1)! \\pmod n$。\n3. 当每个内部节点执行一次模乘法，且操作数最多为 $\\lceil \\log_2 n \\rceil$ 位时，推导平衡乘积树算法位复杂度的紧渐近上界。用 $n$ 和 $M(k)$ 表示该界限，其中 $k = \\lceil \\log_2 n \\rceil$。此外，与朴素的非平衡顺序算法以及一个假设的不取模乘积树（即，将所有约减推迟到每一层的末尾）进行比较，解释为什么平衡的“节点处取模”设计能避免操作数的超线性增长。\n4. 讨论一种基于检测零余数的有原则的提前终止条件：如果任何内部节点的计算结果为 $0 \\pmod n$，解释为什么最终结果必须是 $0$，以及这在合数情况下如何影响操作计数。\n\n编程任务：\n- 实现上述平衡乘积树算法，以计算 $(n-1)! \\pmod n$。\n- 使用以下固定的输入测试套件：$[1,2,4,5,6,7,8,11,25,97,100]$。\n- 对于测试套件中的每个 $n$，计算单个整数 $(n-1)! \\pmod n$。\n- 最终输出格式：你的程序应生成单行输出，其中包含用逗号分隔并用方括号括起来的结果列表，顺序与测试套件输入相同。例如，对于假设的结果 $r_1,r_2,\\dots,r_m$，打印 $[r_1,r_2,\\dots,r_m]$。", "solution": "我们根据所列出的基本原理，构建并分析一个用于计算 $(n-1)! \\pmod n$ 的平衡乘积树算法。\n\n算法构建：\n- 给定 $n \\ge 1$。考虑叶子余数列表 $L_0 = [1,2,\\dots,n-1]$。如果 $n=1$，按照约定，空积的值为 $1$，因此 $(0)! \\pmod 1 = 1 \\pmod 1 = 0$。\n- 递归定义层级 $L_0, L_1, L_2, \\dots$。给定一个层级 $L_i$，通过成对扫描 $L_i$ 来构建 $L_{i+1}$：对于 $L_i$ 中的每个连续对 $a,b$，将 $c = (a \\cdot b) \\pmod n$ 附加到 $L_{i+1}$。如果 $L_i$ 的长度为奇数，则将最后一个未配对的元素原封不动地附加到 $L_{i+1}$。持续此过程，直到某个层级 $L_t$ 的长度为 $1$，并返回其唯一元素 $r$。\n\n正确性：\n- 根据乘法结合律，所有叶子的乘积等于在任何括号化方案下累积的乘积，特别是二叉树所引导的括号化方案。由于每个内部节点计算 $((a \\cdot b) \\pmod n)$，且模约减保留余数，因此在每个节点向上传播的值与以 $n$ 为模的其子树叶子的乘积同余。通过归纳法，根值 $r$ 与以 $n$ 为模的所有叶子的乘积同余，即\n$$\nr \\equiv \\prod_{j=1}^{n-1} j \\pmod n,\n$$\n因此，在规范余数系统 $\\{0,1,\\dots,n-1\\}$ 中，$r = (n-1)! \\pmod n$。\n\n位复杂度分析：\n- 令 $k = \\lceil \\log_2 n \\rceil$ 为 $n$ 的位长。因为在每个内部节点我们都执行 $((a \\cdot b) \\pmod n)$，所以操作数总是对 $n$ 进行模约减；因此它们最多为 $k$ 位。在标准位模型中，一次模乘法（先乘后约减）的成本是 $O\\big(M(k)\\big)$。\n- 对于一个具有 $|L_0| = n-1$ 个叶子的完整乘积树，其内部节点的总数为 $|L_0| - 1 = n-2$（对于 $n \\ge 2$）：每个内部节点合并两个子节点，每次合并使节点数量减少一个，直到只剩下一个根节点。因此，模乘法的总次数是 $n-2$。对于 $n=1$，没有内部节点，成本为零；对于 $n=2$，只有一个叶子，成本也为零。\n- 因此，平衡的、在节点处取模的乘积树的总位复杂度为\n$$\nT(n) = \\Theta\\big((n-2) \\cdot M(k)\\big) = \\Theta\\big(n \\cdot M(\\lceil \\log_2 n \\rceil)\\big).\n$$\n使用快速傅里叶变换（FFT）的乘法界限 $M(k) = O\\big(k \\log k \\log \\log k\\big)$，我们得到\n$$\nT(n) = O\\Big(n \\cdot \\lceil \\log_2 n \\rceil \\cdot \\log \\lceil \\log_2 n \\rceil \\cdot \\log \\log \\lceil \\log_2 n \\rceil\\Big).\n$$\n- 与朴素的非平衡顺序算法的比较：迭代更新 $r \\leftarrow (r \\cdot j) \\pmod n$（其中 $j=1,2,\\dots,n-1$）的顺序算法也对 $k$ 位操作数执行 $n-2$ 次模乘法，所以其渐近位复杂度是相同的，即 $\\Theta\\big(n \\cdot M(k)\\big)$。平衡树提供了结构上的优势（并行化潜力和可预测的深度），但在单模数情况下不改变模运算的渐近计数。\n- 避免操作数增长：考虑一个假设的乘积树，它在层级内部推迟模约减，在约减前乘以原始整数。在高度为 $h$ 的节点，其值是 $2^h$ 个叶子整数的乘积，每个整数最多为 $n$，因此位长可以增长到 $O\\big(2^h \\cdot \\log n\\big)$。在靠近根部时，这会产生大小为 $\\Theta\\big(n \\log n\\big)$ 位的操作数，使得每次乘法的成本达到 $M\\big(\\Theta(n \\log n)\\big)$，并急剧增加总复杂度。“节点处取模”的设计将每个操作数保持在 $k$ 位以内，保证了所陈述的 $\\Theta\\big(n \\cdot M(k)\\big)$ 界限。\n\n通过零检测提前终止：\n- 在任何内部节点，如果 $c = (a \\cdot b) \\pmod n = 0$，则 $a \\cdot b \\equiv 0 \\pmod n$，这意味着该节点下的叶子乘积可以被 $n$ 整除。因为后续的乘法只是左乘整数，并且模约减保持同余关系，所以根值必须保持为 $0 \\pmod n$。因此，在任何点检测到零余数都允许立即终止并得到正确的最终结果。在操作计数方面，对于零余数出现较早的情况（对于许多合数 $n$），执行的模乘法次数少于 $n-2$ 次，尽管最坏情况下的界限仍然是 $\\Theta\\big(n \\cdot M(k)\\big)$。\n\n实现细节：\n- 程序如上所述构建层级 $L_i$，在每个内部节点执行 $((a \\cdot b) \\pmod n)$，如果任何节点等于 $0$，则提前终止。对于 $n=1$，它返回 $0$，对于 $n=2$，它返回 $1$。\n\n测试套件和输出：\n- 我们在固定的输入 $[1,2,4,5,6,7,8,11,25,97,100]$ 上评估该算法。\n- 对于每个 $n$，我们输出整数 $(n-1)! \\pmod n$。\n- 程序以 $[r_1,r_2,\\dots,r_{11}]$ 的格式打印单行，对应于测试套件的顺序。\n\n该设计严格遵循模算术和位复杂度模型，通过结合律和余数性质建立了正确性，在实际的乘法成本 $M(k)$ 下提供了紧密的渐近界限，并支持在零余数情况下的有原则的提前终止。", "answer": "```python\n# Python 3.12 program to compute ((n-1)!) mod n using a balanced product tree,\n# and print results for a fixed test suite in the required single-line format.\n\ndef factorial_mod_via_product_tree(n: int) - int:\n    \"\"\"\n    Compute ((n-1)!) mod n using a balanced product tree.\n    Early-terminate if any internal node becomes 0 mod n.\n    \"\"\"\n    if n == 0:\n        # By convention in this context, treat n = 0 as undefined; return 0 for robustness.\n        return 0\n    if n == 1:\n        # Empty product equals 1; 1 mod 1 = 0.\n        return 0\n    if n == 2:\n        # (1!) mod 2 = 1\n        return 1\n\n    # Initialize leaves: 1..n-1\n    level = list(range(1, n))\n    # Build product tree levels until a single value remains.\n    while True:\n        if len(level) == 1:\n            return level[0] % n\n        next_level = []\n        # Combine pairs with modular multiplication.\n        it = iter(level)\n        for a in it:\n            try:\n                b = next(it)\n                c = (a * b) % n\n                # Early termination if zero residue encountered.\n                if c == 0:\n                    return 0\n                next_level.append(c)\n            except StopIteration:\n                # Odd count: carry last element upward unchanged.\n                next_level.append(a % n)\n        level = next_level\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [1, 2, 4, 5, 6, 7, 8, 11, 25, 97, 100]\n\n    results = []\n    for n in test_cases:\n        result = factorial_mod_via_product_tree(n)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3031237"}]}