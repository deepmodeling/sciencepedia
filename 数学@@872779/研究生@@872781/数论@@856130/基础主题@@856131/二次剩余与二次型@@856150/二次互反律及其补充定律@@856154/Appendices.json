{"hands_on_practices": [{"introduction": "雅可比符号 $(\\frac{a}{n}) = 1$ 并不保证二次同余式 $x^2 \\equiv a \\pmod{n}$ 有解，这是一个常见的概念陷阱。本练习旨在通过一个具体的反例，帮助您深入理解雅可比符号的真实含义及其与勒让德符号的区别，从而巩固您对二次互反律基本工具的精确掌握。通过这个实践，您将看到理论定义如何在实际问题中产生深刻而重要的区别 [@problem_id:3021694]。", "problem": "设 $n=15$，并用 $\\left(\\frac{a}{n}\\right)$ 表示雅可比符号 (Jacobi symbol)。找出满足 $\\gcd(a,15)=1$ 的最小正整数 $a$，使得 $\\left(\\frac{a}{15}\\right)=1$ 但同余式 $x^{2}\\equiv a \\pmod{15}$ 无解。你的证明必须基于奇素数 $p$ 的勒让德符号 (Legendre symbol) $\\left(\\frac{a}{p}\\right)$、奇合数 $n$ 的雅可比符号 $\\left(\\frac{a}{n}\\right)$ 的基本定义，以及二次互反律 (law of quadratic reciprocity) 及其补充定律，并且必须包含一个论证，说明尽管 $\\left(\\frac{a}{15}\\right)=1$，同余式 $x^{2}\\equiv a \\pmod{15}$ 仍然无解。只需报告 $a$ 的值。无需四舍五入。", "solution": "该问题已被验证，并被确定为数论中一个定义良好、有科学依据的问题。\n\n目标是找到满足 $\\gcd(a, 15) = 1$、雅可比符号 $\\left(\\frac{a}{15}\\right) = 1$ 且同余式 $x^2 \\equiv a \\pmod{15}$ 无解的最小正整数 $a$。\n\n给定整数 $n=15$。$n$ 的素数分解为 $15 = 3 \\times 5$。\n\n根据定义，对于一个奇合数 $n = p_1 p_2 \\cdots p_k$，雅可比符号 $\\left(\\frac{a}{n}\\right)$ 定义为对其每个素数因子的勒让德符号的乘积：\n$$\n\\left(\\frac{a}{n}\\right) = \\left(\\frac{a}{p_1}\\right) \\left(\\frac{a}{p_2}\\right) \\cdots \\left(\\frac{a}{p_k}\\right)\n$$\n对于 $n=15$，这变为：\n$$\n\\left(\\frac{a}{15}\\right) = \\left(\\frac{a}{3}\\right) \\left(\\frac{a}{5}\\right)\n$$\n我们已知条件 $\\left(\\frac{a}{15}\\right) = 1$。这意味着勒让德符号的乘积 $\\left(\\frac{a}{3}\\right)\\left(\\frac{a}{5}\\right)$ 必须等于 $1$。这可以通过两种方式实现：\n1. $\\left(\\frac{a}{3}\\right) = 1$ 且 $\\left(\\frac{a}{5}\\right) = 1$。\n2. $\\left(\\frac{a}{3}\\right) = -1$ 且 $\\left(\\frac{a}{5}\\right) = -1$。\n\n接下来，我们考虑二次同余式 $x^2 \\equiv a \\pmod{15}$ 的可解性。根据中国剩余定理 (Chinese Remainder Theorem)，该同余式有解当且仅当以下同余方程组\n\\begin{align*}\nx^2 \\equiv a \\pmod{3} \\\\\nx^2 \\equiv a \\pmod{5}\n\\end{align*}\n同时有解。\n\n对于一个奇素数 $p$，同余式 $x^2 \\equiv a \\pmod{p}$ 有解当且仅当 $a$ 是模 $p$ 的二次剩余 (quadratic residue)（假设 $\\gcd(a,p)=1$），这等价于勒让德符号 $\\left(\\frac{a}{p}\\right) = 1$。\n\n问题陈述 $x^2 \\equiv a \\pmod{15}$ 无解。这意味着同余式 $x^2 \\equiv a \\pmod{3}$ 或 $x^2 \\equiv a \\pmod{5}$ 至少有一个无解。用勒让德符号表示，这等价于条件 $\\left(\\frac{a}{3}\\right) = -1$ 或 $\\left(\\frac{a}{5}\\right) = -1$。\n\n现在我们必须结合关于 $a$ 的两个主要条件：\n1. $\\left(\\frac{a}{3}\\right)\\left(\\frac{a}{5}\\right) = 1$\n2. $\\left(\\frac{a}{3}\\right) = -1$ 或 $\\left(\\frac{a}{5}\\right) = -1$\n\n如果我们有 $\\left(\\frac{a}{3}\\right) = 1$ 且 $\\left(\\frac{a}{5}\\right) = 1$，则第一个条件会满足，但第二个条件会被违反。此外，这种情况对应于 $x^2 \\equiv a \\pmod{15}$ 有解，这与问题陈述相矛盾。\n因此，同时满足这两个条件的唯一方法是两个勒让德符号都为 $-1$：\n$$\n\\left(\\frac{a}{3}\\right) = -1 \\quad \\text{and} \\quad \\left(\\frac{a}{5}\\right) = -1\n$$\n这种安排满足 $\\left(\\frac{a}{3}\\right)\\left(\\frac{a}{5}\\right) = (-1)(-1) = 1$，并且也满足至少有一个符号为 $-1$ 的条件，从而确保 $x^2 \\equiv a \\pmod{15}$ 无解。\n\n问题现在简化为找到满足 $\\gcd(a, 15)=1$ 并且既是模 $3$ 的二次非剩余 (quadratic non-residue) 又是模 $5$ 的二次非剩余的最小正整数 $a$。\n\n首先，我们确定模 $3$ 的二次非剩余。与 $3$ 互素的整数模 $3$ 同余于 $1$ 或 $2$。\n$1^2 \\equiv 1 \\pmod{3}$，所以 $\\left(\\frac{1}{3}\\right)=1$。\n$2^2 \\equiv 4 \\equiv 1 \\pmod{3}$。非剩余是指不同余于任何平方数的整数。模 $3$ 的唯一非剩余是 $2$。\n所以，$\\left(\\frac{2}{3}\\right)=-1$。这要求 $a \\equiv 2 \\pmod{3}$。\n\n第二，我们确定模 $5$ 的二次非剩余。与 $5$ 互素的整数模 $5$ 同余于 $1, 2, 3,$ 或 $4$。\n$1^2 \\equiv 1 \\pmod{5}$\n$2^2 \\equiv 4 \\pmod{5}$\n$3^2 \\equiv 9 \\equiv 4 \\pmod{5}$\n$4^2 \\equiv 16 \\equiv 1 \\pmod{5}$\n模 $5$ 的二次剩余是 $1$ 和 $4$。二次非剩余是 $2$ 和 $3$。\n所以，$\\left(\\frac{2}{5}\\right)=-1$ 且 $\\left(\\frac{3}{5}\\right)=-1$。这要求 $a \\equiv 2 \\pmod{5}$ 或 $a \\equiv 3 \\pmod{5}$。\n\n我们寻求满足 $\\gcd(a,15)=1$ 并且满足由我们的条件产生的同余方程组的最小正整数 $a$：\n$$\na \\equiv 2 \\pmod{3} \\quad \\text{and} \\quad (a \\equiv 2 \\pmod{5} \\text{ or } a \\equiv 3 \\pmod{5})\n$$\n我们现在可以从 $1$ 开始测试与 $15$ 互素的正整数 $a$。\n这些整数是 $1, 2, 4, 7, 8, 11, 13, 14, \\dots$\n\n- 设 $a=1$。$\\gcd(1,15)=1$。但 $1 \\equiv 1 \\pmod{3}$，这违反了 $a \\equiv 2 \\pmod{3}$。所以 $a=1$ 不是解。\n\n- 设 $a=2$。$\\gcd(2,15)=1$。\n  - 我们检查条件 $a \\equiv 2 \\pmod{3}$：$2 \\equiv 2 \\pmod{3}$。此条件满足。\n  - 我们检查条件 $a \\equiv 2 \\pmod{5}$ 或 $a \\equiv 3 \\pmod{5}$：$2 \\equiv 2 \\pmod{5}$。此条件满足。\n\n因为 $a=2$ 是继 $a=1$ 之后第一个满足必要条件的整数，所以它是最小的正整数。\n\n为了根据问题陈述进行确认，我们使用二次互反律的第二补充定律，该定律指出 $\\left(\\frac{2}{p}\\right) = (-1)^{(p^2-1)/8}$。\n对于 $p=3$：$\\left(\\frac{2}{3}\\right) = (-1)^{(3^2-1)/8} = (-1)^1 = -1$。\n对于 $p=5$：$\\left(\\frac{2}{5}\\right) = (-1)^{(5^2-1)/8} = (-1)^3 = -1$。\n对于 $a=2$，这两个条件都满足。\n\n让我们验证 $a=2$ 满足原问题的所有要求：\n- 它是找到的最小正整数。\n- $\\gcd(2, 15)=1$。\n- $\\left(\\frac{2}{15}\\right) = \\left(\\frac{2}{3}\\right)\\left(\\frac{2}{5}\\right) = (-1)(-1) = 1$。\n- 同余式 $x^2 \\equiv 2 \\pmod{15}$ 无解，因为 $x^2 \\equiv 2 \\pmod{3}$ 无解，因为 $\\left(\\frac{2}{3}\\right)=-1$。\n\n因此，满足所有给定条件的最小正整数 $a$ 是 $2$。", "answer": "$$\\boxed{2}$$", "id": "3021694"}, {"introduction": "掌握了雅可比符号的概念后，下一个关键步骤是熟练运用二次互反律及其补充定律来高效计算勒让德符号的值。本练习提供了一个绝佳的演练机会，要求您将一个复合的勒让德符号 $(\\frac{-10}{p})$ 分解，并系统地应用乘法性质、第一补充定律 $(\\frac{-1}{p})$、第二补充定律 $(\\frac{2}{p})$ 以及二次互反主定律。这个过程是数论研究中一项基础且核心的计算技能 [@problem_id:3013383]。", "problem": "设 $p = 2029$ 是一个奇素数。考虑同余方程 $x^{2} \\equiv -10 \\pmod{p}$ 在模p整数环中的可解性。仅使用关于乘法群 $(\\mathbb{Z}/p\\mathbb{Z})^{\\times}$ 中二次剩余的基本原理，结合基于高斯引理的方法以及欧拉判别法提供的联系，精确计算勒让德符号 $\\left(\\frac{-10}{p}\\right)$ 的值。你的最终答案必须是一个单独的数字。不需要四舍五入。", "solution": "我们从与二次剩余及其勒让德符号相关的核心定义和事实开始。对于一个奇素数 $p$ 和一个整数 $a$ 且 $p \\nmid a$，勒让德符号 $\\left(\\frac{a}{p}\\right)$ 定义为\n$$\n\\left(\\frac{a}{p}\\right) =\n\\begin{cases}\n1  \\text{如果存在 } x \\in \\mathbb{Z} \\text{ 使得 } x^{2} \\equiv a \\pmod{p}, \\\\\n-1  \\text{否则。}\n\\end{cases}\n$$\n欧拉判别法断言\n$$\n\\left(\\frac{a}{p}\\right) \\equiv a^{\\frac{p-1}{2}} \\pmod{p},\n$$\n特别地，当 $p \\nmid a$ 时，$\\left(\\frac{a}{p}\\right) \\in \\{-1,1\\}$。勒让德符号具有乘法性：\n$$\n\\left(\\frac{ab}{p}\\right) = \\left(\\frac{a}{p}\\right)\\left(\\frac{b}{p}\\right),\n$$\n这可以由欧拉判别法通过以下方式得出\n$$\n(ab)^{\\frac{p-1}{2}} \\equiv a^{\\frac{p-1}{2}} b^{\\frac{p-1}{2}} \\pmod{p}.\n$$\n\n我们的任务是计算当 $p = 2029$ 时 $\\left(\\frac{-10}{p}\\right)$ 的值。利用乘法性以及 $-1$, $2$, $5$ 与 $p$ 互素，我们分解\n$$\n\\left(\\frac{-10}{p}\\right) = \\left(\\frac{-1}{p}\\right)\\left(\\frac{2}{p}\\right)\\left(\\frac{5}{p}\\right).\n$$\n我们将使用高斯引理计算每个因子，并在适当的地方使用二次互反律，而二次互反律本身也可以由高斯引理建立。\n\n高斯引理陈述：对于奇素数 $p$ 和整数 $a$ 且 $p \\nmid a$，考虑集合 $a,2a,3a,\\dots,\\frac{p-1}{2}a$ 模 $p$ 的最小绝对剩余。设 $N(a)$ 是这些剩余中严格位于负半区间的数量，这等价于其最小正剩余超过 $\\frac{p}{2}$ 的数量。那么\n$$\n\\left(\\frac{a}{p}\\right) = (-1)^{N(a)}.\n$$\n\n1. 通过高斯引理计算 $\\left(\\frac{-1}{p}\\right)$。取 $a = -1$。集合 $\\{-1,-2,\\dots,-\\frac{p-1}{2}\\}$ 的最小正剩余为 $\\{p-1,p-2,\\dots,p - \\frac{p-1}{2}\\}$，它们都超过了 $\\frac{p}{2}$。因此 $N(-1) = \\frac{p-1}{2}$，于是\n$$\n\\left(\\frac{-1}{p}\\right) = (-1)^{\\frac{p-1}{2}}.\n$$\n对于 $p = 2029$，我们有 $\\frac{p-1}{2} = \\frac{2028}{2} = 1014$，这是一个偶数，所以\n$$\n\\left(\\frac{-1}{2029}\\right) = 1.\n$$\n\n2. 通过高斯引理计算 $\\left(\\frac{2}{p}\\right)$。取 $a = 2$。考虑序列 $2,4,6,\\dots,2\\cdot\\frac{p-1}{2}$。如果 $2j \\leq \\frac{p}{2}$，则项 $2j$ 的最小绝对剩余为 $2j$（因此被计为正）；如果 $2j  \\frac{p}{2}$，则其最小绝对剩余为 $2j - p$（因此被计为负）。因此，数 $N(2)$ 等于满足 $1 \\leq j \\leq \\frac{p-1}{2}$ 且 $2j  \\frac{p}{2}$ (即 $j  \\frac{p}{4}$) 的下标 $j$ 的数量。所以\n$$\nN(2) = \\frac{p-1}{2} - \\left\\lfloor \\frac{p}{4} \\right\\rfloor.\n$$\n因此，\n$$\n\\left(\\frac{2}{p}\\right) = (-1)^{\\frac{p-1}{2} - \\left\\lfloor \\frac{p}{4} \\right\\rfloor}.\n$$\n为了计算 $N(2)$ 的奇偶性，将 $p$ 写成 $p = 8m + r$ 的形式，其中 $r \\in \\{1,3,5,7\\}$。那么\n$$\n\\frac{p-1}{2} = 4m + \\frac{r-1}{2}, \\quad \\left\\lfloor \\frac{p}{4} \\right\\rfloor = \\left\\lfloor 2m + \\frac{r}{4} \\right\\rfloor = 2m + \\left\\lfloor \\frac{r}{4} \\right\\rfloor.\n$$\n因此\n$$\nN(2) = (4m + \\tfrac{r-1}{2}) - \\left(2m + \\left\\lfloor \\tfrac{r}{4} \\right\\rfloor \\right) = 2m + \\left(\\tfrac{r-1}{2} - \\left\\lfloor \\tfrac{r}{4} \\right\\rfloor\\right).\n$$\n我们检查这四种剩余情况的奇偶性：\n- 如果 $r = 1$，则 $N(2) = 2m + 0$ 是偶数，所以 $\\left(\\frac{2}{p}\\right) = 1$。\n- 如果 $r = 3$，则 $N(2) = 2m + 1$ 是奇数，所以 $\\left(\\frac{2}{p}\\right) = -1$。\n- 如果 $r = 5$，则 $N(2) = 2m + 2 - 1 = 2m + 1$ 是奇数，所以 $\\left(\\frac{2}{p}\\right) = -1$。\n- 如果 $r = 7$，我们有 $\\tfrac{r-1}{2} = 3$ 和 $\\left\\lfloor \\tfrac{r}{4} \\right\\rfloor = 1$，所以 $N(2) = 2m + (3 - 1) = 2m + 2$，这是偶数，因此 $\\left(\\frac{2}{p}\\right) = 1$。总结一下，\n$$\n\\left(\\frac{2}{p}\\right) =\n\\begin{cases}\n1  \\text{如果 } p \\equiv 1 \\text{ 或 } 7 \\pmod{8}, \\\\\n-1  \\text{如果 } p \\equiv 3 \\text{ 或 } 5 \\pmod{8}.\n\\end{cases}\n$$\n等价地，\n$$\n\\left(\\frac{2}{p}\\right) = (-1)^{\\frac{p^{2}-1}{8}}.\n$$\n对于 $p = 2029$，我们有 $2029 \\equiv 5 \\pmod{8}$，因此\n$$\n\\left(\\frac{2}{2029}\\right) = -1.\n$$\n\n3. 使用二次互反律计算 $\\left(\\frac{5}{p}\\right)$。二次互反律可由高斯引理推导得出，它陈述：对于不同的奇素数 $p$ 和 $q$，\n$$\n\\left(\\frac{p}{q}\\right)\\left(\\frac{q}{p}\\right) = (-1)^{\\frac{p-1}{2}\\cdot \\frac{q-1}{2}}.\n$$\n特别地，当 $q \\equiv 1 \\pmod{4}$ 时，符号为 $+1$，所以 $\\left(\\frac{p}{q}\\right) = \\left(\\frac{q}{p}\\right)$。因为 $5 \\equiv 1 \\pmod{4}$，我们得到\n$$\n\\left(\\frac{5}{p}\\right) = \\left(\\frac{p}{5}\\right).\n$$\n为了计算 $\\left(\\frac{p}{5}\\right)$，我们将 $p$ 模 $5$ 并与模 $5$ 的二次剩余（即 $1$ 和 $4$）进行比较。计算 $p \\bmod 5$：$2025$ 能被 $5$ 整除，所以 $2029 \\equiv 4 \\pmod{5}$。因此\n$$\n\\left(\\frac{p}{5}\\right) = \\left(\\frac{2029}{5}\\right) = \\left(\\frac{4}{5}\\right) = 1,\n$$\n从而\n$$\n\\left(\\frac{5}{2029}\\right) = 1.\n$$\n\n结合这三个因子，\n$$\n\\left(\\frac{-10}{2029}\\right) = \\left(\\frac{-1}{2029}\\right)\\left(\\frac{2}{2029}\\right)\\left(\\frac{5}{2029}\\right) = 1 \\cdot (-1) \\cdot 1 = -1.\n$$\n根据定义解释，同余方程 $x^{2} \\equiv -10 \\pmod{2029}$ 在 $\\mathbb{Z}/2029\\mathbb{Z}$ 中无解，勒让德符号的值为 $-1$，符合要求。", "answer": "$$\\boxed{-1}$$", "id": "3013383"}, {"introduction": "从手动计算单个符号值，到设计一个通用的计算算法，是理解二次互反律的更高层次。本练习要求您将二次互反律及其补充定律整合为一个类似于欧几里得算法的规约过程，从而实现勒让德符号的自动化计算。这项实践不仅能加深您对这些定律如何协同工作的理解，还将理论知识与计算数论的实践联系起来 [@problem_id:3021663]。", "problem": "设计并实现一个程序，使用一种仅基于二次互反律及其补充定律的迭代算法，来计算一个整数 $a$ 和一个奇素数 $p$ 的勒让德符号 $\\left(\\frac{a}{p}\\right)$。你的算法必须迭代地将数对 $(a,p)$ 转换为一个新的数对 $(a',p')$，从而将 $\\left(\\frac{a}{p}\\right)$ 的求值简化为 $\\left(\\frac{a'}{p'}\\right)$ 的求值，并乘以一个完全由二次互反律及其补充定律所规定的奇偶性条件决定的符号。该算法必须包含以下特性：\n\n- 在每个阶段，将 $a$ 对 $p$ 取模，以确保 $0 \\le a  p$。\n- 通过从关于 $-1$ 的补充定律导出的适当符号因子来处理负数输入 $a$。\n- 在每个阶段，从 $a$ 中除去 $2$ 的幂，并使用关于 $2$ 的补充定律累积每个提取出的因子 $2$ 所贡献的符号因子。\n- 除去因子 $2$ 后，调用互反步骤来交换 $a$ 和 $p$ 的角色（受它们模 $4$ 的同余类决定的互反符号的约束），然后通过计算 $p \\bmod a$ 来化简新的分子。\n\n你的任务分为三个部分：\n\n$1.$ 用文字精确地描述算法并用代码实现它。你可以将二次互反律以及关于 $-1$ 和 $2$ 的补充定律作为基本已知条件，但你不能假定或调用任何其他直接计算 $\\left(\\frac{a}{p}\\right)$ 的结果。\n\n$2.$ 证明对于所有整数输入 $a$ 和所有奇素数 $p$，你的算法都会终止。\n\n$3.$ 证明该算法是正确的，即累积的符号和化简步骤保持了勒让德符号的值，因此返回的输出恰好是 $\\left(\\frac{a}{p}\\right) \\in \\{-1,0,1\\}$。\n\n你的程序必须为以下每个测试用例生成勒让德符号：\n- $(a,p) = (0,3)$\n- $(a,p) = (1,5)$\n- $(a,p) = (2,7)$\n- $(a,p) = (10,11)$\n- $(a,p) = (-3,11)$\n- $(a,p) = (22,11)$\n- $(a,p) = (1024,17)$\n- $(a,p) = (123456789,31)$\n- $(a,p) = (97,13)$\n- $(a,p) = (45,23)$\n- $(a,p) = (2,3)$\n- $(a,p) = (8,5)$\n- $(a,p) = (4,29)$\n\n你的程序应该生成一行输出，其中包含用逗号分隔并用方括号括起来的结果。例如，输出格式必须严格遵循以下形式\n$[r_1,r_2,\\dots,r_{13}]$\n其中每个 $r_i \\in \\{-1,0,1\\}$ 是按上述顺序列出的对应测试用例的 $\\left(\\frac{a}{p}\\right)$ 的值。不应打印任何额外的文本或格式。", "solution": "题目要求设计、实现并分析一个用于计算整数 $a$ 和奇素数 $p$ 的勒让德符号 $\\left(\\frac{a}{p}\\right)$ 的迭代算法。该算法必须仅基于勒让德符号的性质，即二次互反律及其两个补充定律。\n\n勒让德符号 $\\left(\\frac{a}{p}\\right)$ 是为整数 $a$ 和奇素数 $p$ 定义的。如果 $a$ 是模 $p$ 的二次剩余且 $a \\not\\equiv 0 \\pmod p$，其值为 $1$；如果 $a$ 是模 $p$ 的二次非剩余，其值为 $-1$；如果 $a \\equiv 0 \\pmod p$，其值为 $0$。\n\n该算法依赖于以下基本性质：\n$1.$ 如果 $a \\equiv b \\pmod p$，则 $\\left(\\frac{a}{p}\\right) = \\left(\\frac{b}{p}\\right)$。\n$2.$ $\\left(\\frac{ab}{p}\\right) = \\left(\\frac{a}{p}\\right)\\left(\\frac{b}{p}\\right)$ (乘法性)。\n$3.$ 第一补充定律：$\\left(\\frac{-1}{p}\\right) = (-1)^{\\frac{p-1}{2}}$。如果 $p \\equiv 1 \\pmod 4$，其值为 $1$；如果 $p \\equiv 3 \\pmod 4$，其值为 $-1$。\n$4.$ 第二补充定律：$\\left(\\frac{2}{p}\\right) = (-1)^{\\frac{p^2-1}{8}}$。如果 $p \\equiv 1, 7 \\pmod 8$，其值为 $1$；如果 $p \\equiv 3, 5 \\pmod 8$，其值为 $-1$。\n$5.$ 二次互反律：对于不同的奇素数 $p$ 和 $q$，$\\left(\\frac{p}{q}\\right) = \\left(\\frac{q}{p}\\right)(-1)^{\\frac{p-1}{2}\\frac{q-1}{2}}$。当且仅当 $p$ 和 $q$ 都与 $3$ 模 $4$ 同余时，符号因子为 $-1$。通过雅可比符号，该定律可以推广到适用于任何奇数对 $p, q  1$。\n\n### $1.$ 算法说明\n\n该算法通过迭代地将数对 $(a, p)$ 简化为一个更简单的数对，同时跟踪一个符号乘数，来计算 $\\left(\\frac{a}{p}\\right)$。设计算状态由三元组 $(k, n, d)$ 表示，我们旨在计算 $k \\cdot \\left(\\frac{n}{d}\\right)$ 的值。初始时，此状态为 $(1, a, p)$。当 $n$ 变为 $0$ 或 $1$ 时，算法终止。\n\n**初始化：**\n$1.$ 设置初始累积符号 $k = 1$。\n$2.$ 初始分子是输入整数 $a$。初始分母是奇素数 $p$。\n$3.$ 应用性质 $\\left(\\frac{a}{p}\\right) = \\left(\\frac{a \\pmod p}{p}\\right)$。用 $a \\pmod p$ 替换 $a$。此步骤后，我们有 $0 \\le a  p$。\n\n**迭代：**\n算法的核心是一个循环，只要 $a \\neq 0$ 就继续。\n\n**步骤1：基本情况。**\n- 如果 $a = 0$，勒让德符号为 $0$。算法终止并返回 $0$。\n- 如果 $a = 1$，符号为 $1$。该值由累积符号 $k$ 决定。算法终止并返回 $k$。\n\n**步骤2：分解出 $2$ 的幂。**\n分子 $a$ 被分解为 $a = 2^s \\cdot m$，其中 $m$ 是奇数。利用乘法性，我们有 $\\left(\\frac{a}{p}\\right) = \\left(\\frac{2^s m}{p}\\right) = \\left(\\frac{2}{p}\\right)^s \\left(\\frac{m}{p}\\right)$。\n- 找出 $a$ 中因子 $2$ 的数量。设其为 $s$。\n- 如果 $s$ 是奇数，累积符号 $k$ 必须乘以 $\\left(\\frac{2}{p}\\right) = (-1)^{\\frac{p^2-1}{8}}$。这等价于当 $p \\equiv 3 \\pmod 8$ 或 $p \\equiv 5 \\pmod 8$ 时翻转 $k$ 的符号。\n- 在考虑了符号变化后，用 $a$ 的奇数部分 $m$ 替换 $a$。\n- 此步骤后，$a$ 是奇数。我们必须重新检查基本情况 $a=1$，因为原始的 $a$ 可能是一个 $2$ 的幂。如果 $a=1$，则终止并返回当前的符号 $k$。\n\n**步骤3：应用二次互反律。**\n此时，$a$ 是一个奇数，满足 $1  a  p$。\n- 我们有 $\\left(\\frac{a}{p}\\right) = \\left(\\frac{p}{a}\\right) (-1)^{\\frac{a-1}{2}\\frac{p-1}{2}}$。\n- 符号 $k$ 通过乘以互反因子 $(-1)^{\\frac{a-1}{2}\\frac{p-1}{2}}$ 来更新。这等价于当且仅当 $a \\equiv 3 \\pmod 4$ 且 $p \\equiv 3 \\pmod 4$ 时翻转 $k$ 的符号。\n- 计算 $\\left(\\frac{a}{p}\\right)$ 的问题被交换为计算 $\\left(\\frac{p}{a}\\right)$。分子和分母的角色互换。\n- 新的数对变为 $(p, a)$。为了以确保终止的方式继续迭代，我们将新的分子对新的分母取模。下一次迭代的新状态由数对 $(p \\pmod a, a)$ 定义。所以我们将新的 $a$ 设为 $p \\pmod a$，新的 $p$ 设为旧的 $a$。然后循环从步骤1继续。\n\n### $2.$ 终止性证明\n\n算法的终止性由这样一个事实保证：在每个互反步骤中，其中一个整数参数严格递减。\n\n设在主循环的某次迭代开始时处理的整数对为 $(a_i, p_i)$。\n$1.$ 初始步骤将输入 $a_{in}$ 化简为 $a_0 = a_{in} \\pmod p$，所以 $0 \\le a_0  p$。初始分母为 $p_0=p$。\n$2.$ 在循环内部，$a_i$ 首先被处理以提取 $2$ 的因子，得到一个奇数 $a'_i \\le a_i$。分母 $p_i$ 不变。\n$3.$ 互反步骤将数对 $(a'_i, p_i)$ 转换为下一次迭代的新数对 $(a_{i+1}, p_{i+1})$，其中 $a_{i+1} = p_i \\pmod{a'_i}$ 且 $p_{i+1} = a'_i$。\n$4.$ 由于 $a'_i$ 是奇数且 $1  a'_i  p_i$ (如果 $a'_i  1$)，我们有 $0 \\le p_i \\pmod{a'_i}  a'_i$。\n$5.$ 分母序列为 $p_0, p_1, p_2, \\ldots$。根据更新规则，$p_{i+1} = a'_i$。因为 $a'_i \\le a_i  p_i$，我们有 $p_{i+1}  p_i$。\n$6.$ 分母序列 $\\{p_i\\}$ 是一个严格递减的正整数序列。\n$7.$ 任何严格递减的正整数序列都必须是有限的。它最终必然达到一个使循环终止的状态。如果 $a_i$ 变为 $0$ 或 $1$，循环就会终止。\n\n这个论证结构与欧几里得算法 (Euclidean algorithm) 的终止性证明类似。分母的值构成一个严格递减的正整数序列，这保证了过程必将结束。\n\n### $3.$ 正确性证明\n\n算法的正确性通过证明值 $V = k \\cdot \\left(\\frac{a}{p}\\right)$ 在整个循环执行过程中是一个不变量来建立，其中 $k$ 是累积的符号，$(a, p)$ 是当前的分子和分母对。\n\n**初始状态：**\n最初，$k=1$，数对为 $(a_{in}, p_{in})$。第一步计算 $a_0 = a_{in} \\pmod{p_{in}}$。此时的不变量是 $V_0 = 1 \\cdot \\left(\\frac{a_0}{p_{in}}\\right)$。根据勒让德符号的性质，$\\left(\\frac{a_{in}}{p_{in}}\\right) = \\left(\\frac{a_{in} \\pmod{p_{in}}}{p_{in}}\\right) = \\left(\\frac{a_0}{p_{in}}\\right)$。所以不变量成立。注意，由于取模运算符的定义，这个初始的化简步骤能正确处理负数 $a_{in}$。\n\n**循环不变量：**\n设一次迭代开始时的状态为 $(k_i, a_i, p_i)$，不变量值为 $V_i = k_i \\left(\\frac{a_i}{p_i}\\right)$。\n\n$1.$ **分解出 $2$：**设 $a_i = 2^s \\cdot m$，其中 $m$ 是奇数。算法更新 $k_{i+1} = k_i \\cdot \\left(\\frac{2}{p_i}\\right)^s$ 和 $a_{i+1} = m$。在这一步中，分母 $p_{i+1} = p_i$ 不变。\n新的不变量值为 $V_{i+1} = k_{i+1} \\left(\\frac{a_{i+1}}{p_{i+1}}\\right) = \\left(k_i \\cdot \\left(\\frac{2}{p_i}\\right)^s\\right) \\left(\\frac{m}{p_i}\\right) = k_i \\left(\\frac{2^s m}{p_i}\\right) = k_i \\left(\\frac{a_i}{p_i}\\right) = V_i$。该值被保持。\n\n$2.$ **互反步骤：**分解出 $2$ 后，我们得到状态 $(k_j, a_j, p_j)$，其中 $a_j$ 是奇数。算法将符号更新为 $k_{j+1} = k_j \\cdot (-1)^{\\frac{a_j-1}{2}\\frac{p_j-1}{2}}$。然后它将下一次循环迭代的新数对设置为 $(a_{j+1}, p_{j+1}) = (p_j \\pmod{a_j}, a_j)$。我们想要保持的值是 $V_j = k_j \\left(\\frac{a_j}{p_j}\\right)$。\n根据二次互反律，$\\left(\\frac{a_j}{p_j}\\right) = \\left(\\frac{p_j}{a_j}\\right) (-1)^{\\frac{a_j-1}{2}\\frac{p_j-1}{2}}$。\n因此，$V_j = k_j \\left(\\frac{p_j}{a_j}\\right) (-1)^{\\frac{a_j-1}{2}\\frac{p_j-1}{2}}$。\n下一个状态表示的值是 $V_{next} = k_{j+1} \\left(\\frac{a_{j+1}}{p_{j+1}}\\right) = \\left( k_j (-1)^{\\frac{a_j-1}{2}\\frac{p_j-1}{2}} \\right) \\left(\\frac{p_j \\pmod{a_j}}{a_j}\\right)$。\n使用性质 $\\left(\\frac{p_j \\pmod{a_j}}{a_j}\\right) = \\left(\\frac{p_j}{a_j}\\right)$，我们有 $V_{next} = k_j (-1)^{\\frac{a_j-1}{2}\\frac{p_j-1}{2}} \\left(\\frac{p_j}{a_j}\\right)$。\n这恰好等于 $V_j$。不变量在互反步骤中得以保持。\n\n**终止：**\n当 $a$ 变为 $0$ 或 $1$ 时算法终止。\n- 如果 $a=0$，算法返回 $0$。此时的不变量值应为 $k \\cdot \\left(\\frac{0}{p}\\right) = k \\cdot 0 = 0$。这是正确的。\n- 如果 $a=1$，算法返回累积的符号 $k$。不变量值为 $k \\cdot \\left(\\frac{1}{p}\\right) = k \\cdot 1 = k$。这也是正确的。\n\n由于不变量 $V$ 在算法的每一步都得以保持，并且在终止时计算的最终值是正确的，因此初始值 $\\left(\\frac{a}{p}\\right)$ 被正确计算。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem by computing the Legendre symbol for a list of test cases.\n    \"\"\"\n\n    def legendre_symbol(a: int, p: int) - int:\n        \"\"\"\n        Computes the Legendre symbol (a/p) using an iterative algorithm based\n        on quadratic reciprocity and supplementary laws.\n\n        Args:\n            a: An integer.\n            p: An odd prime number.\n\n        Returns:\n            The value of the Legendre symbol, which is -1, 0, or 1.\n        \"\"\"\n        if p = 2 or p % 2 == 0:\n            raise ValueError(\"p must be an odd prime.\")\n            \n        # Step 1: Reduce a modulo p. This also handles negative a correctly,\n        # as a % p in Python for a  0 results in a number with the same sign as p.\n        # Since p is positive, the result is in [0, p-1].\n        # For example, -3 % 11 = 8. (a/p) = (a mod p / p).\n        a = a % p\n\n        # Initialize the accumulated sign.\n        sign = 1\n\n        # Main loop: continues until a is 0 or 1.\n        while a != 0:\n            # Base case: if a is 1, the result is the accumulated sign.\n            if a == 1:\n                return sign\n\n            # Step 2: Factor out powers of 2 from a.\n            # Let a = 2^k * m, where m is odd.\n            # (a/p) = (2^k * m / p) = (2/p)^k * (m/p).\n            k = 0\n            while a % 2 == 0:\n                a //= 2\n                k += 1\n\n            # Update sign based on the supplementary law for 2: (2/p) = (-1)^((p^2-1)/8).\n            # We multiply the sign by (2/p) for each factor of 2. An even number of\n            # factors has no effect. An odd number of factors contributes a (2/p) term.\n            if k % 2 == 1:\n                # (2/p) is -1 if p = 3 or 5 (mod 8).\n                p_mod_8 = p % 8\n                if p_mod_8 == 3 or p_mod_8 == 5:\n                    sign = -sign\n\n            # After removing factors of 2, a might be 1.\n            # E.g., if original a was 4, it becomes 1 here.\n            if a == 1:\n                return sign\n\n            # Step 3: Apply the Law of Quadratic Reciprocity.\n            # At this point, a is odd, and 1  a  p.\n            # (a/p) = (p/a) * (-1)^(((a-1)/2)*((p-1)/2)).\n            # The sign factor is -1 iff both a and p are 3 (mod 4).\n            if (a % 4 == 3) and (p % 4 == 3):\n                sign = -sign\n\n            # Swap roles and reduce. The task to compute (a/p) is replaced\n            # by computing (p/a), which is equivalent to (p mod a / a).\n            # This is the core of the reduction, similar to the Euclidean algorithm.\n            old_a = a\n            a = p % old_a\n            p = old_a\n        \n        # If the loop terminates because a is 0, then the original a was a multiple of p.\n        return 0\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (0, 3),\n        (1, 5),\n        (2, 7),\n        (10, 11),\n        (-3, 11),\n        (22, 11),\n        (1024, 17),\n        (123456789, 31),\n        (97, 13),\n        (45, 23),\n        (2, 3),\n        (8, 5),\n        (4, 29),\n    ]\n\n    results = []\n    for a, p in test_cases:\n        result = legendre_symbol(a, p)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3021663"}]}