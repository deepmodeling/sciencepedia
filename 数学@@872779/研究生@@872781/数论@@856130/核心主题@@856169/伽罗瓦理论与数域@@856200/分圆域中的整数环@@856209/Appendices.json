{"hands_on_practices": [{"introduction": "代数数论的一个基本任务是确定一个数域的整数环。本练习将引导您完成一个经典案例——第八分圆域 $\\mathbb{Q}(\\zeta_8)$ 的整数环的确定过程。通过从头计算一个候选基的判别式，并将其与已知的域判别式进行比较，您将亲手验证 $\\mathbb{Z}[\\zeta_8]$ 是否为该域的整数环，从而加深对迹、判别式和整基等核心概念的理解。", "problem": "设 $\\zeta_{8} := \\exp(2\\pi i/8)$ 且令 $K = \\mathbb{Q}(\\zeta_{8})$。记 $\\mathcal{O}_{K}$ 为 $K$ 的整数环。从数域的迹和判别式的核心定义出发，并利用 $\\mathbb{Z}[x]$ 中首一多项式的根是代数整数这一事实。按以下步骤进行：\n\n- 通过确定 $\\zeta_{8}$ 在 $\\mathbb{Q}$ 上的极小多项式，证明 $\\zeta_{8}$ 是一个代数整数，并得出结论：$\\mathbb{Z}[\\zeta_{8}]$ 是 $\\mathcal{O}_{K}$ 中的一个整环，其 $\\mathbb{Z}$-基为 $\\{1,\\zeta_{8},\\zeta_{8}^{2},\\zeta_{8}^{3}\\}$。\n- 使用迹 $\\operatorname{Tr}_{K/\\mathbb{Q}}$ 的定义和嵌入 $\\sigma_{a}: \\zeta_{8} \\mapsto \\zeta_{8}^{a}$（其中 $a \\in \\{1,3,5,7\\}$），计算与基 $\\{1,\\zeta_{8},\\zeta_{8}^{2},\\zeta_{8}^{3}\\}$ 相关联的格拉姆矩阵 $G = \\big(\\operatorname{Tr}_{K/\\mathbb{Q}}(\\zeta_{8}^{i+j})\\big)_{0 \\leq i,j \\leq 3}$。\n- 显式计算判别式 $\\Delta(\\{1,\\zeta_{8},\\zeta_{8}^{2},\\zeta_{8}^{3}\\}) := \\det G$。\n- 使用关于分圆域的熟知事实（特别是，只有整除导子的素数才会分歧，以及分圆域的标准判别式公式），证明域判别式 $D_{K}$ 等于 $\\Delta(\\{1,\\zeta_{8},\\zeta_{8}^{2},\\zeta_{8}^{3}\\})$，并由此得出 $\\{1,\\zeta_{8},\\zeta_{8}^{2},\\zeta_{8}^{3}\\}$ 是 $\\mathcal{O}_{K}$ 的一个整基。\n\n给出判别式 $D_{K}$ 的精确值作为最终答案（不要近似或四舍五入）。", "solution": "本题要求通过一系列指定的计算和论证，确定分圆域 $K = \\mathbb{Q}(\\zeta_8)$（其中 $\\zeta_8 := \\exp(2\\pi i/8)$）的整数环 $\\mathcal{O}_K$。\n\n首先，我们证明 $\\zeta_8$ 是一个代数整数，且 $\\mathbb{Z}[\\zeta_8]$ 是 $\\mathcal{O}_K$ 中的一个整环。\n8次单位根是多项式 $x^8 - 1$ 的根。该多项式在整数上分解为 $x^8 - 1 = (x^4 - 1)(x^4 + 1) = (x^2-1)(x^2+1)(x^4+1) = (x-1)(x+1)(x^2+1)(x^4+1)$。\n本原8次单位根是那些满足 $\\gcd(k,8)=1$ 的 $\\zeta_8^k$，即 $k \\in \\{1, 3, 5, 7\\}$。它们是第8个分圆多项式 $\\Phi_8(x)$ 的根。$x^8-1$ 的其他根是 $\\Phi_d(x)$ 的根，其中 $d$ 是8的除8以外的因子（即 $d=1, 2, 4$）。因此，$\\Phi_8(x) = x^4+1$。\n要证明 $\\Phi_8(x)$ 是 $\\zeta_8$ 在 $\\mathbb{Q}$ 上的极小多项式，我们必须证明它是不可约的。我们对多项式 $\\Phi_8(x+1)$ 应用 Eisenstein 判别法：\n$$ \\Phi_8(x+1) = (x+1)^4 + 1 = (x^4 + 4x^3 + 6x^2 + 4x + 1) + 1 = x^4 + 4x^3 + 6x^2 + 4x + 2 $$\n对于素数 $p=2$，我们观察到 2 整除除首项系数（1）外的所有系数，而 $p^2=4$ 不整除常数项（2）。因此，$\\Phi_8(x+1)$ 在 $\\mathbb{Q}$ 上是不可约的，这意味着 $\\Phi_8(x) = x^4+1$ 在 $\\mathbb{Q}$ 上也是不可约的。\n由于 $\\zeta_8$ 是首一多项式 $x^4+1 \\in \\mathbb{Z}[x]$ 的根，所以 $\\zeta_8$ 是一个代数整数。\n域扩张的次数为 $[K:\\mathbb{Q}] = \\deg(\\Phi_8(x)) = 4$。$K$ 作为 $\\mathbb{Q}$-向量空间的一个基是 $\\{1, \\zeta_8, \\zeta_8^2, \\zeta_8^3\\}$。由于 $\\zeta_8$ 是一个代数整数，环 $\\mathbb{Z}[\\zeta_8]$ 是 $\\mathcal{O}_K$ 的一个子环。作为一个 $\\mathbb{Z}$-模，$\\mathbb{Z}[\\zeta_8]$ 是秩为4的自由模，其基为 $\\{1, \\zeta_8, \\zeta_8^2, \\zeta_8^3\\}$。由于其秩等于域扩张的次数，所以 $\\mathbb{Z}[\\zeta_8]$ 是 $\\mathcal{O}_K$ 中的一个整环。\n\n接下来，我们计算与基 $\\{1, \\zeta_8, \\zeta_8^2, \\zeta_8^3\\}$ 相关联的格拉姆矩阵。$K/\\mathbb{Q}$ 的伽罗瓦群是 $G \\cong (\\mathbb{Z}/8\\mathbb{Z})^\\times = \\{1, 3, 5, 7\\}$。嵌入 $\\sigma_a: K \\to \\mathbb{C}$ 由 $\\sigma_a(\\zeta_8) = \\zeta_8^a$ 定义，其中 $a \\in \\{1, 3, 5, 7\\}$。一个元素 $\\alpha \\in K$ 的迹由 $\\operatorname{Tr}_{K/\\mathbb{Q}}(\\alpha) = \\sum_{a \\in \\{1,3,5,7\\}} \\sigma_a(\\alpha)$ 给出。我们需要为不同的整数 $k$ 计算 $\\operatorname{Tr}_{K/\\mathbb{Q}}(\\zeta_8^k)$。\n\n对于 $k=0$：$\\operatorname{Tr}_{K/\\mathbb{Q}}(\\zeta_8^0) = \\operatorname{Tr}_{K/\\mathbb{Q}}(1) = \\sum_{a \\in \\{1,3,5,7\\}} \\sigma_a(1) = 1+1+1+1 = 4$。\n对于 $k \\in \\{1,2,3,5,6\\}$：迹 $\\operatorname{Tr}_{K/\\mathbb{Q}}(\\zeta_8^k)$ 是 $\\zeta_8^k$ 的伽罗瓦共轭之和。\n$\\operatorname{Tr}_{K/\\mathbb{Q}}(\\zeta_8^1) = \\zeta_8^1 + \\zeta_8^3 + \\zeta_8^5 + \\zeta_8^7$。这是极小多项式 $\\Phi_8(x)=x^4+1$ 的根之和。根据韦达定理，这个和是 $x^3$ 系数的相反数，即 $0$。所以，$\\operatorname{Tr}_{K/\\mathbb{Q}}(\\zeta_8) = 0$。\n$\\operatorname{Tr}_{K/\\mathbb{Q}}(\\zeta_8^2) = \\sigma_1(\\zeta_8^2) + \\sigma_3(\\zeta_8^2) + \\sigma_5(\\zeta_8^2) + \\sigma_7(\\zeta_8^2) = \\zeta_8^2 + \\zeta_8^6 + \\zeta_8^{10} + \\zeta_8^{14} = \\zeta_8^2 + \\zeta_8^6 + \\zeta_8^2 + \\zeta_8^6 = 2(\\zeta_8^2 + \\zeta_8^6) = 2(i + (-i)) = 0$。\n$\\operatorname{Tr}_{K/\\mathbb{Q}}(\\zeta_8^3) = \\zeta_8^3 + \\zeta_8^9 + \\zeta_8^{15} + \\zeta_8^{21} = \\zeta_8^3 + \\zeta_8^1 + \\zeta_8^7 + \\zeta_8^5 = \\operatorname{Tr}_{K/\\mathbb{Q}}(\\zeta_8) = 0$。\n对于 $k=4$：$\\operatorname{Tr}_{K/\\mathbb{Q}}(\\zeta_8^4) = \\operatorname{Tr}_{K/\\mathbb{Q}}(-1) = \\sum_{a \\in \\{1,3,5,7\\}} \\sigma_a(-1) = -1-1-1-1 = -4$。\n$\\operatorname{Tr}_{K/\\mathbb{Q}}(\\zeta_8^5) = \\zeta_8^5 + \\zeta_8^{15} + \\zeta_8^{25} + \\zeta_8^{35} = \\zeta_8^5 + \\zeta_8^7 + \\zeta_8^1 + \\zeta_8^3 = \\operatorname{Tr}_{K/\\mathbb{Q}}(\\zeta_8) = 0$。\n$\\operatorname{Tr}_{K/\\mathbb{Q}}(\\zeta_8^6) = \\zeta_8^6 + \\zeta_8^{18} + \\zeta_8^{30} + \\zeta_8^{42} = \\zeta_8^6 + \\zeta_8^2 + \\zeta_8^6 + \\zeta_8^2 = 2(\\zeta_8^2+\\zeta_8^6) = 0$。\n格拉姆矩阵是 $G = \\big(\\operatorname{Tr}_{K/\\mathbb{Q}}(\\zeta_8^{i+j})\\big)_{0 \\leq i,j \\leq 3}$。\n$$ G = \\begin{pmatrix}\n\\operatorname{Tr}(\\zeta_8^0)  \\operatorname{Tr}(\\zeta_8^1)  \\operatorname{Tr}(\\zeta_8^2)  \\operatorname{Tr}(\\zeta_8^3) \\\\\n\\operatorname{Tr}(\\zeta_8^1)  \\operatorname{Tr}(\\zeta_8^2)  \\operatorname{Tr}(\\zeta_8^3)  \\operatorname{Tr}(\\zeta_8^4) \\\\\n\\operatorname{Tr}(\\zeta_8^2)  \\operatorname{Tr}(\\zeta_8^3)  \\operatorname{Tr}(\\zeta_8^4)  \\operatorname{Tr}(\\zeta_8^5) \\\\\n\\operatorname{Tr}(\\zeta_8^3)  \\operatorname{Tr}(\\zeta_8^4)  \\operatorname{Tr}(\\zeta_8^5)  \\operatorname{Tr}(\\zeta_8^6)\n\\end{pmatrix} = \\begin{pmatrix}\n4  0  0  0 \\\\\n0  0  0  -4 \\\\\n0  0  -4  0 \\\\\n0  -4  0  0\n\\end{pmatrix} $$\n\n第三，我们计算基的判别式，也就是格拉姆矩阵的行列式。\n$$ \\Delta(\\{1,\\zeta_8,\\zeta_8^2,\\zeta_8^3\\}) = \\det G = \\det \\begin{pmatrix}\n4  0  0  0 \\\\\n0  0  0  -4 \\\\\n0  0  -4  0 \\\\\n0  -4  0  0\n\\end{pmatrix} $$\n沿第一行展开，我们得到：\n$$ \\det G = 4 \\cdot \\det \\begin{pmatrix}\n0  0  -4 \\\\\n0  -4  0 \\\\\n-4  0  0\n\\end{pmatrix} = 4 \\left( -4 \\det \\begin{pmatrix} 0  -4 \\\\ -4  0 \\end{pmatrix} \\right) = 4(-4(0 - 16)) = 4(64) = 256 $$\n\n最后，我们证明域判别式 $D_K$ 等于这个值。一个整环 $\\mathcal{A}$ 的任意 $\\mathbb{Z}$-基 $\\{\\alpha_0, \\dots, \\alpha_3\\}$ 的判别式与域判别式 $D_K$ 通过公式 $\\Delta(\\{\\alpha_i\\}) = [\\mathcal{O}_K : \\mathcal{A}]^2 D_K$ 相关联。在我们的例子中，整环为 $\\mathcal{A} = \\mathbb{Z}[\\zeta_8]$，公式变为：\n$$ \\Delta(\\{1,\\zeta_8,\\zeta_8^2,\\zeta_8^3\\}) = [\\mathcal{O}_K : \\mathbb{Z}[\\zeta_8]]^2 D_K $$\n$$ 256 = [\\mathcal{O}_K : \\mathbb{Z}[\\zeta_8]]^2 D_K $$\n我们现在使用分圆域 $\\mathbb{Q}(\\zeta_n)$ 判别式的标准公式：\n$$ D_{\\mathbb{Q}(\\zeta_n)} = (-1)^{\\phi(n)/2} \\frac{n^{\\phi(n)}}{\\prod_{p|n} p^{\\phi(n)/(p-1)}} $$\n对于 $n=8$，我们有 $\\phi(8) = 8(1 - 1/2) = 4$，并且唯一整除8的素数是 $p=2$。\n$$ D_K = D_{\\mathbb{Q}(\\zeta_8)} = (-1)^{4/2} \\frac{8^4}{2^{4/(2-1)}} = (-1)^2 \\frac{(2^3)^4}{2^4} = 1 \\cdot \\frac{2^{12}}{2^4} = 2^8 = 256 $$\n这个结果与以下事实一致：在 $\\mathbb{Q}(\\zeta_8)$ 中唯一分歧的素数是 $p=2$，因此域判别式 $D_K$ 必须是2的幂。\n将 $D_K=256$ 代入指标关系式：\n$$ 256 = [\\mathcal{O}_K : \\mathbb{Z}[\\zeta_8]]^2 \\cdot 256 $$\n这意味着 $[\\mathcal{O}_K : \\mathbb{Z}[\\zeta_8]]^2 = 1$。由于指标是一个正整数，我们必有 $[\\mathcal{O}_K : \\mathbb{Z}[\\zeta_8]] = 1$。\n这意味着整环 $\\mathbb{Z}[\\zeta_8]$ 等于极大整环 $\\mathcal{O}_K$。因此，$\\mathbb{Z}[\\zeta_8]$ 的 $\\mathbb{Z}$-基 $\\{1, \\zeta_8, \\zeta_8^2, \\zeta_8^3\\}$ 是 $\\mathcal{O}_K$ 的一个整基。域判别式为 $D_K = 256$。", "answer": "$$\\boxed{256}$$", "id": "3023010"}, {"introduction": "在整数环的结构被确定后，我们便可以研究其中元素的算术性质。迹和范数是将数域中的元素映射回有理数的两个基本工具，对研究这些性质至关重要。本练习将聚焦于计算一个非常重要的元素 $1-\\zeta_p$ 的迹和范数，展示其性质如何与分圆多项式本身紧密相连。", "problem": "设 $n\\geq 3$ 为一个整数，$\\zeta_{n}$ 是一个固定的 n次本原单位根，并设 $K=\\mathbb{Q}(\\zeta_{n})$。$K$ 的整数环是 $\\mathbb{Z}[\\zeta_{n}]$，因此 $K$ 中的每个代数整数都可以写成 $\\alpha=\\sum_{j=0}^{\\varphi(n)-1} a_{j}\\zeta_{n}^{j}$ 的形式，其中 $a_{j}\\in\\mathbb{Z}$，$\\varphi$ 表示欧拉函数。仅使用从 $K$ 到 $\\mathbb{Q}$ 的域迹和域范数的定义，以及关于分圆域和对称多项式的标准基础知识，推导 $\\mathrm{Tr}_{K/\\mathbb{Q}}(\\alpha)$ 和 $N_{K/\\mathbb{Q}}(\\alpha)$ 关于 $\\zeta_{n}$ 的共轭的对称函数的表达式。然后，将问题特殊化到 $n=7$ 和元素 $\\alpha=1-\\zeta_{7}$ 的情况，并明确计算由 $\\alpha$ 的迹和范数组成的有序对。请以精确形式提供最终的有序对。如果进行任何数值计算，请不要四舍五入。您的最终答案必须是单个解析表达式。", "solution": "设 $K = \\mathbb{Q}(\\zeta_n)$，其中 $\\zeta_n$ 是一个 n次本原单位根。此域扩张的次数为 $[K:\\mathbb{Q}] = \\varphi(n)$，其中 $\\varphi$ 是欧拉函数。$\\zeta_n$ 在 $\\mathbb{Q}$ 上的最小多项式是 n次分圆多项式 $\\Phi_n(x)$。$\\Phi_n(x)$ 的根是 n次本原单位根，这正是 $\\zeta_n$ 的伽罗瓦共轭。设这些共轭的集合为 $\\mathcal{C} = \\{\\zeta_n^k \\mid 1 \\le k  n, \\gcd(k,n)=1\\}$。伽罗瓦群 $\\mathrm{Gal}(K/\\mathbb{Q})$ 由自同构 $\\sigma_k: \\zeta_n \\mapsto \\zeta_n^k$ 组成，对于此集合中的每个 $k$。\n\n设 $\\alpha$ 是 $K$ 中的一个代数整数。根据题意，$\\alpha \\in \\mathbb{Z}[\\zeta_n]$，所以我们可以将 $\\alpha$ 写成一个以 $\\zeta_n$ 为变量、整系数的多项式：\n$$ \\alpha = p(\\zeta_n) = \\sum_{j=0}^{\\varphi(n)-1} a_{j}\\zeta_{n}^{j}, \\quad a_j \\in \\mathbb{Z} $$\n$\\alpha$ 的共轭集由 $\\{\\sigma_k(\\alpha) \\mid \\sigma_k \\in \\mathrm{Gal}(K/\\mathbb{Q})\\}$ 给出。将自同构 $\\sigma_k$ 应用于 $\\alpha$ 可得：\n$$ \\sigma_k(\\alpha) = \\sigma_k\\left(\\sum_{j=0}^{\\varphi(n)-1} a_{j}\\zeta_{n}^{j}\\right) = \\sum_{j=0}^{\\varphi(n)-1} a_{j}\\sigma_k(\\zeta_{n}^j) = \\sum_{j=0}^{\\varphi(n)-1} a_{j}(\\sigma_k(\\zeta_n))^j = \\sum_{j=0}^{\\varphi(n)-1} a_{j}(\\zeta_{n}^k)^j = p(\\zeta_n^k) $$\n\n**迹和范数的一般表达式**\n\n从 $K$ 到 $\\mathbb{Q}$ 的 $\\alpha$ 的迹定义为其共轭之和：\n$$ \\mathrm{Tr}_{K/\\mathbb{Q}}(\\alpha) = \\sum_{\\substack{1 \\le k  n \\\\ \\gcd(k,n)=1}} \\sigma_k(\\alpha) = \\sum_{\\substack{1 \\le k  n \\\\ \\gcd(k,n)=1}} p(\\zeta_n^k) $$\n代入 $p$ 的多项式表达式并交换求和顺序：\n$$ \\mathrm{Tr}_{K/\\mathbb{Q}}(\\alpha) = \\sum_{\\substack{1 \\le k  n \\\\ \\gcd(k,n)=1}} \\sum_{j=0}^{\\varphi(n)-1} a_j (\\zeta_n^k)^j = \\sum_{j=0}^{\\varphi(n)-1} a_j \\left( \\sum_{\\substack{1 \\le k  n \\\\ \\gcd(k,n)=1}} (\\zeta_n^k)^j \\right) $$\n内层和是 $\\zeta_n$ 的共轭的 j次幂之和。这是 j次幂和对称多项式 $P_j$ 在共轭集 $\\mathcal{C}$ 上的取值。因此，迹是这些对称函数的线性组合：\n$$ \\mathrm{Tr}_{K/\\mathbb{Q}}(\\alpha) = \\sum_{j=0}^{\\varphi(n)-1} a_j P_j(\\mathcal{C}) $$\n\n从 $K$ 到 $\\mathbb{Q}$ 的 $\\alpha$ 的范数定义为其共轭之积：\n$$ N_{K/\\mathbb{Q}}(\\alpha) = \\prod_{\\substack{1 \\le k  n \\\\ \\gcd(k,n)=1}} \\sigma_k(\\alpha) = \\prod_{\\substack{1 \\le k  n \\\\ \\gcd(k,n)=1}} p(\\zeta_n^k) $$\n这个表达式是关于 $\\zeta_n$ 的共轭的对称多项式。根据对称多项式基本定理，这可以表示为关于 $\\zeta_n$ 的共轭的初等对称多项式的多项式，这些初等对称多项式（不计符号）是最小多项式 $\\Phi_n(x)$ 的系数。这个乘积也称为多项式 $p(x)$ 和 $\\Phi_n(x)$ 的结式，记为 $\\mathrm{Res}(p, \\Phi_n)$。\n\n**特殊化到 $n=7$ 和 $\\alpha=1-\\zeta_7$**\n\n对于 $n=7$（一个素数），$\\varphi(7) = 7-1 = 6$。该域为 $K = \\mathbb{Q}(\\zeta_7)$，是 $\\mathbb{Q}$ 的一个 6次扩张。$\\zeta_7$ 的最小多项式是 7次分圆多项式：\n$$ \\Phi_7(x) = \\frac{x^7-1}{x-1} = x^6 + x^5 + x^4 + x^3 + x^2 + x + 1 $$\n$\\zeta_7$ 的共轭是 $\\{\\zeta_7^k \\mid k=1, 2, 3, 4, 5, 6\\}$。\n所考虑的元素是 $\\alpha = 1-\\zeta_7$。这里，$\\alpha = p(\\zeta_7)$，其中 $p(x) = 1-x$。\n\n**迹的计算**\n$\\alpha = 1-\\zeta_7$ 的共轭是 $\\sigma_k(1-\\zeta_7) = 1-\\sigma_k(\\zeta_7) = 1-\\zeta_7^k$，其中 $k \\in \\{1, 2, 3, 4, 5, 6\\}$。\n迹是这些共轭之和：\n$$ \\mathrm{Tr}_{K/\\mathbb{Q}}(1-\\zeta_7) = \\sum_{k=1}^6 (1-\\zeta_7^k) = \\sum_{k=1}^6 1 - \\sum_{k=1}^6 \\zeta_7^k $$\n第一个和是 $6$。第二个和是 $\\Phi_7(x)$ 的根之和。根据韦达定理，$\\Phi_7(x)$ 的根之和是 $x^5$ 系数的相反数。$\\Phi_7(x)$ 中 $x^5$ 的系数是 $1$。\n因此，$\\sum_{k=1}^6 \\zeta_7^k = -1$。\n将此代入迹的表达式中：\n$$ \\mathrm{Tr}_{K/\\mathbb{Q}}(1-\\zeta_7) = 6 - (-1) = 7 $$\n\n或者，利用迹算子的线性性：\n$$ \\mathrm{Tr}_{K/\\mathbb{Q}}(1-\\zeta_7) = \\mathrm{Tr}_{K/\\mathbb{Q}}(1) - \\mathrm{Tr}_{K/\\mathbb{Q}}(\\zeta_7) $$\n$$ \\mathrm{Tr}_{K/\\mathbb{Q}}(1) = \\sum_{k=1}^6 \\sigma_k(1) = \\sum_{k=1}^6 1 = 6 $$\n$$ \\mathrm{Tr}_{K/\\mathbb{Q}}(\\zeta_7) = \\sum_{k=1}^6 \\sigma_k(\\zeta_7) = \\sum_{k=1}^6 \\zeta_7^k = -1 $$\n因此，$\\mathrm{Tr}_{K/\\mathbb{Q}}(1-\\zeta_7) = 6 - (-1) = 7$。\n\n**范数的计算**\n范数是共轭之积：\n$$ N_{K/\\mathbb{Q}}(1-\\zeta_7) = \\prod_{k=1}^6 (1-\\zeta_7^k) $$\n分圆多项式 $\\Phi_7(x)$ 可以写成因式分解形式：\n$$ \\Phi_7(x) = \\prod_{k=1}^6 (x - \\zeta_7^k) $$\n在 $x=1$ 处对该多项式求值可得：\n$$ \\Phi_7(1) = \\prod_{k=1}^6 (1 - \\zeta_7^k) $$\n这正是 $1-\\zeta_7$ 的范数的表达式。我们可以通过将 $x=1$ 代入其多项式形式来求 $\\Phi_7(1)$ 的值：\n$$ \\Phi_7(1) = 1^6 + 1^5 + 1^4 + 1^3 + 1^2 + 1^1 + 1 = 1+1+1+1+1+1+1=7 $$\n因此，范数为：\n$$ N_{K/\\mathbb{Q}}(1-\\zeta_7) = 7 $$\n\n由 $\\alpha=1-\\zeta_7$ 的迹和范数组成的有序对是 $(7, 7)$。", "answer": "$$ \\boxed{(7, 7)} $$", "id": "3022983"}, {"introduction": "整数环的性质可能非常微妙，例如唯一因子分解的失效，其程度由类数来衡量。本练习将引导您从单个元素的计算，转向探索一个深刻的全局不变量——类数，并引入计算方法。您将通过编程实现一个算法来检验 Kummer 判别法，该判别法将分圆域的类数这一深刻的算术问题，与伯努利数的计算联系起来，展示了计算在现代数论研究中的强大威力。", "problem": "设 $p$ 是一个奇素数，并令 $\\zeta_{p}$ 表示一个 $p$ 次本原单位根。考虑分圆域 $\\mathbb{Q}(\\zeta_{p})$ 及其整数环 $\\mathcal{O}_{\\mathbb{Q}(\\zeta_{p})}$。如果一个素数 $p$ 不能整除任何伯努利数 $B_k$ (当 $k$ 为 $2 \\leq k \\leq p - 3$ 范围内的偶数时) 的分子（最简分数形式），则称 $p$ 为正则素数。伯努利数 $\\{B_{n}\\}_{n \\geq 0}$ 由指数生成函数定义：\n$$\n\\frac{t}{e^{t} - 1} = \\sum_{n=0}^{\\infty} \\frac{B_{n}}{n!} t^{n},\n$$\n该式与形式幂级数的标准操作相结合，得出以下经过充分检验的递推关系：\n$$\nB_{m} = -\\frac{1}{m+1} \\sum_{k=0}^{m-1} \\binom{m+1}{k} B_{k}, \\quad \\text{for } m \\geq 1, \\quad \\text{with } B_{0} = 1.\n$$\n使用这些基本定义，设计并实现一个算法，该算法能够：\n- 将所有直到 $p-3$ 的 $B_n$ 计算为最简有理数。\n- 对于 $2 \\leq k \\leq p-3$ 范围内的偶数 $k$，通过检查 $p$ 是否整除 $B_k$ 的分子来判断 $p$ 是否为正则素数。\n- 通过 Kummer 判别法，利用你的结果推断其对整数环 $\\mathcal{O}_{\\mathbb{Q}(\\zeta_{p})}$ 的算术性质的影响：$p$ 整除 $\\mathbb{Q}(\\zeta_{p})$ 的类数，当且仅当 $p$ 整除某个伯努利数 $B_k$ 的分子，其中 $k$ 是 $2 \\leq k \\leq p-3$ 范围内的偶数。特别地，这可以确定 $\\mathcal{O}_{\\mathbb{Q}(\\zeta_{p})}$ 的理想类群的 $p$-准素部分是否非平凡。\n\n你的程序必须评估以下素数测试集：\n- $p = 3$（边界情况，在 $2 \\leq k \\leq p-3$ 范围内没有偶数 $k$），\n- $p = 5$（小的正则素数），\n- $p = 23$（中等大小的素数），\n- $p = 37$（要求的主要情况），\n- $p = 59$（较大的素数，以测试计算压力）。\n\n对于每个测试用例素数 $p$，生成以下由基本类型组成的列表作为输出：\n- 一个布尔值，表示 $p$ 是否是正则素数。\n- 一个整数，给出在 $[2, p-3]$ 范围内的偶数索引 $k$ 的数量，其中 $p$ 整除 $B_k$ 的分子。\n- 一个布尔值，表示 $p$ 是否整除 $\\mathbb{Q}(\\zeta_{p})$ 的类数（根据 Kummer 判别法，这在逻辑上等同于正则性的否定，但你必须按规定应用该判别法来计算）。\n- 一个整数，给出在 $[2, p-3]$ 范围内使得 $p$ 整除 $B_k$ 分子的最小偶数 $k$，如果不存在这样的 $k$，则为 $0$。\n\n你的程序应生成单行输出，其中包含五个测试用例的结果，这些结果汇总为一个逗号分隔的列表，每个素数的结果列表都包含在内，且所有内容都封装在一对方括号中。例如，输出格式必须是\n$$\n[\\,[\\text{boolean},\\text{integer},\\text{boolean},\\text{integer}],\\ldots,[\\text{boolean},\\text{integer},\\text{boolean},\\text{integer}]\\,].\n$$\n此问题不涉及物理单位或角度。所有答案必须是指定的精确布尔值和整数。最终代码必须是自包含的，并且不需要任何输入。", "solution": "该问题要求基于伯努利数 $B_k$ 的性质，分析几个奇素数 $p$ 的正则性。一个素数 $p$ 被定义为正则的，如果它不能整除任何伯努利数 $B_k$ 的分子，其中 $k$ 是 $2 \\leq k \\leq p-3$ 范围内的所有偶数索引。问题给出了伯努利数的标准指数生成函数：\n$$\n\\frac{t}{e^{t} - 1} = \\sum_{n=0}^{\\infty} \\frac{B_{n}}{n!} t^{n},\n$$\n以及一个用于计算它们的相应递推关系：\n$$\nB_{m} = -\\frac{1}{m+1} \\sum_{k=0}^{m-1} \\binom{m+1}{k} B_{k}, \\quad \\text{for } m \\geq 1,\n$$\n初始条件为 $B_0 = 1$。任务是实现一个算法，以确定给定素数集 $\\{3, 5, 23, 37, 59\\}$ 的正则性，并利用 Kummer 判别法推断分圆域 $\\mathbb{Q}(\\zeta_p)$ 的整数环 $\\mathcal{O}_{\\mathbb{Q}(\\zeta_{p})}$ 的一个关键性质，即其类数是否能被 $p$ 整除。\n\n该解决方案基于以下原则和步骤设计与实现：\n\n1.  **有理数算术**：伯努利数 $B_n$ 是有理数。标准的浮点数算术不足以解决此问题，因为它会引入精度误差，导致对整除性的错误判断。为确保数学上的精确性，所有涉及伯努利数的计算都使用有理数算术来执行。为此，我们采用了 Python 的 `fractions.Fraction` 类，因为它将数字存储为一对任意精度整数（分子和分母），并自动将分数化简为最简形式，这是检查分子整除性的一个要求。\n\n2.  **伯努利数的计算**：需要一种高效的方法来计算伯努利数序列。我们直接实现了所提供的递推关系。为了避免朴素递归方法中固有的重复计算，我们采用迭代方式计算伯努利数并将其存储（记忆化）在一个列表中。该算法首先确定所有测试用例所需的最大索引 $N = \\max(p-3)$。然后，它构建一个伯努利数列表 $B_0, B_1, \\ldots, B_N$。计算过程如下：\n    - 初始化 $B_0 = 1$。\n    - 对于从 $1$ 到 $N$ 的每个 $m$，使用递推关系计算 $B_m$。此计算涉及二项式系数 $\\binom{m+1}{k}$（使用 `math.comb` 计算）和对 `Fraction` 对象的算术运算。\n    - 利用伯努利数的一个已知性质，$B_m=0$ 对于所有奇数 $m > 1$，作为一种优化，以跳过对这些索引的求和计算。\n\n3.  **正则性验证和数据收集**：对于测试集中的每个素数 $p$，算法确定其正则性并收集指定的数据点。\n    - 对于给定的素数 $p$，算法遍历指定范围 $2 \\leq k \\leq p-3$ 内的所有偶数 $k$。注意，对于 $p=3$，此范围为空，因此 $p=3$ 是平凡正则的。\n    - 在每次迭代中，算法访问预先计算的伯努利数 $B_k$。由于 `fractions.Fraction` 保持数值为最简分数，分子可以通过 `.numerator` 属性直接访问。\n    - 执行整除性测试 `B_k.numerator % p == 0`。\n    - 如果对于任何 $k$ 该测试为真，则素数 $p$ 被标记为非正则。算法会维护满足条件的 $k$ 值的计数，并记录使条件成立的最小 $k$ 值。\n    - 指示 $p$ 是否整除 $\\mathbb{Q}(\\zeta_p)$ 类数的布尔值是通过应用 Kummer 判别法确定的，该判别法指出此性质等价于 $p$ 是非正则的。因此，这个布尔值是 $p$ 的正则性状态的逻辑否定。\n\n4.  **输出格式化**：每个素数 $p$ 的结果——一个包含正则性状态（布尔值）、“非正则”索引的数量（整数）、类数整除性（布尔值）和最小的此类索引（整数，或 $0$）的列表——被汇总起来。最终的结果集合被格式化为表示列表的列表的单个字符串，如问题所规定。\n\n这种系统性的方法确保了所有计算在数学上都是可靠的，并且最终的素数分类根据给定的定义是正确的。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\nfrom fractions import Fraction\n\ndef solve():\n    \"\"\"\n    Solves the problem of determining the regularity of primes based on Bernoulli numbers.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [3, 5, 23, 37, 59]\n\n    # Determine the maximum Bernoulli number index needed.\n    # The check for a prime p goes up to k = p-3. The largest p is 59.\n    max_k_needed = max([p - 3 for p in test_cases if p - 3 = 0] or [0])\n\n    # Pre-compute all required Bernoulli numbers up to max_k_needed.\n    # This avoids re-computation for each prime and is more efficient.\n    bernoulli_numbers = [Fraction(0)] * (max_k_needed + 1)\n    if max_k_needed = 0:\n        bernoulli_numbers[0] = Fraction(1)  # B_0 = 1\n\n    for m in range(1, max_k_needed + 1):\n        # Optimization: B_m = 0 for all odd m  1.\n        if m  1 and m % 2 != 0:\n            bernoulli_numbers[m] = Fraction(0)\n            continue\n        \n        # Use the provided recurrence relation:\n        # B_m = -1/(m+1) * sum_{k=0}^{m-1} (m+1 choose k) * B_k\n        current_sum = Fraction(0)\n        for k in range(m):\n            # math.comb(n, k) computes the binomial coefficient \"n choose k\".\n            term = math.comb(m + 1, k) * bernoulli_numbers[k]\n            current_sum += term\n        \n        bernoulli_numbers[m] = -current_sum / (m + 1)\n\n    all_results = []\n    for p in test_cases:\n        # Initialize results for the current prime p.\n        is_regular = True\n        irregular_indices_count = 0\n        smallest_irregular_k = 0\n        \n        # A prime p is irregular if it divides the numerator of B_k for some\n        # even k in the range 2 = k = p-3.\n        # This range is empty for p=3, so p=3 is vacuously regular.\n        if p  3:\n            # Iterate through even k in the specified range.\n            # The upper bound of range() is exclusive, so use p-2.\n            for k in range(2, p - 2, 2):\n                # The Fraction object is always in lowest terms.\n                B_k = bernoulli_numbers[k]\n                if B_k.numerator % p == 0:\n                    is_regular = False\n                    irregular_indices_count += 1\n                    # Record the first k that causes irregularity.\n                    if smallest_irregular_k == 0:\n                        smallest_irregular_k = k\n        \n        # According to Kummer's criterion, p divides the class number of Q(zeta_p)\n        # if and only if p is an irregular prime.\n        divides_class_number = not is_regular\n\n        result = [is_regular, irregular_indices_count, divides_class_number, smallest_irregular_k]\n        all_results.append(result)\n\n    # Final print statement in the exact required format.\n    # The format is a list of lists, with no spaces following internal commas.\n    # e.g., [[True,0,False,0],[True,0,False,0],...]\n    inner_results_str = [f\"[{','.join(map(str, r)).replace('True', 'True').replace('False', 'False')}]\" for r in all_results]\n    print(f\"[{','.join(inner_results_str)}]\")\n\nsolve()\n```", "id": "3023012"}]}