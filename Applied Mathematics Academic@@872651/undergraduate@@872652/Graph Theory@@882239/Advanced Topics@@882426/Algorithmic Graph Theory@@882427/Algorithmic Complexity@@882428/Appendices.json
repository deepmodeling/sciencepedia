{"hands_on_practices": [{"introduction": "The first step in analyzing any graph algorithm is understanding how the graph is represented. This initial choice can dramatically affect performance. This problem explores the implications of using an adjacency matrix, a common representation where we store connectivity information for all possible pairs of vertices. By analyzing the simple task of finding the most connected vertex, you will discover the inherent computational cost associated with this data structure, a foundational concept in algorithmic design [@problem_id:1480504].", "problem": "A computer scientist is analyzing a social network to identify the most influential user. The network is modeled as a simple, undirected graph where each user is a vertex and a mutual connection between two users is an edge. The entire network structure, consisting of $V$ users, is provided in the form of an adjacency matrix, $A$. This matrix is a $V \\times V$ grid where the entry $A_{ij}$ is $1$ if there is a connection between user $i$ and user $j$, and $0$ otherwise. Since the connections are mutual, the matrix is symmetric ($A_{ij} = A_{ji}$). The number of connections a user has is called their degree. The goal is to design an algorithm to find the user with the highest degree.\n\nLet $V$ be the number of vertices (users) and $E$ be the number of edges (connections) in the graph. What is the tightest Big-O time complexity for a deterministic algorithm to find the vertex with the highest degree, given the adjacency matrix representation?\n\nA. $O(V)$\n\nB. $O(E)$\n\nC. $O(V+E)$\n\nD. $O(V \\log E)$\n\nE. $O(V^2)$\n\nF. $O(V \\cdot E)$", "solution": "We are given an undirected simple graph on $V$ vertices by its adjacency matrix $A \\in \\{0,1\\}^{V \\times V}$ with $A_{ij} = A_{ji}$. The degree of vertex $i$ is defined as $\\deg(i) = \\sum_{j=1}^{V} A_{ij}$. To find the vertex with maximum degree deterministically, we must compute $\\deg(i)$ for each $i \\in \\{1,\\dots,V\\}$ and track the maximum.\n\nA direct algorithm scans each row $i$ of $A$ and computes $\\deg(i)$ by summing $V$ entries. This requires $V$ additions per row and there are $V$ rows, so the total work is $V \\cdot V = V^{2}$ entry inspections and additions, i.e., $O(V^{2})$.\n\nWe can exploit symmetry to avoid double-counting by scanning only the strict upper triangle entries $(i,j)$ with $1 \\leq i < j \\leq V$. For each such entry, if $A_{ij} = 1$, we increment both counters for $\\deg(i)$ and $\\deg(j)$. The number of inspected entries is $\\binom{V}{2} = \\frac{V(V-1)}{2}$, which is $\\Theta(V^{2})$. Thus there exists an algorithm with time $O(V^{2})$.\n\nTo argue tightness, consider any deterministic algorithm that does not inspect an entry $A_{ij}$ in the worst case. An adversary can modify that uninspected entry, changing $\\deg(i)$ and $\\deg(j)$ by $1$, which can alter which vertex has the maximum degree. Therefore, to guarantee correctness in the worst case, the algorithm must inspect a number of entries that is $\\Omega(V^{2})$. Since we have both an upper bound $O(V^{2})$ and a matching lower bound $\\Omega(V^{2})$, the tight bound is $\\Theta(V^{2})$.\n\nAmong the given options, this corresponds to $O(V^{2})$, which is option E.", "answer": "$$\\boxed{E}$$", "id": "1480504"}, {"introduction": "In contrast to the dense representation of an adjacency matrix, an adjacency list stores only the connections that actually exist, making it ideal for sparse graphs. This exercise challenges you to find \"stand-alone\" services, which corresponds to finding vertices with a total degree of zero in a directed graph. Solving this problem will highlight the efficiency of the adjacency list representation for certain tasks and deepen your understanding of the trade-offs between different data structures [@problem_id:1480481].", "problem": "A system architect is analyzing a large-scale network of microservices. The network consists of $N$ distinct microservices, identified by integers from $0$ to $N-1$. Communication between these services is facilitated by $M$ one-way, directed communication channels. A channel from service $u$ to service $v$ allows $u$ to send data to $v$, but not vice versa.\n\nThe entire network topology is provided to you in an adjacency list format. This consists of an array of $N$ lists, where the $i$-th list contains the identifiers of all services that service $i$ can directly send data to. The sum of the lengths of all these lists is equal to $M$.\n\nYour task is to identify all \"stand-alone\" microservices. A microservice is defined as stand-alone if and only if it has a total degree of zero, meaning it neither sends data to any other service nor receives data from any other service.\n\nWhat is the tightest worst-case time complexity of the most efficient algorithm to find all stand-alone services, as a function of $N$ and $M$?\n\nA) $O(N)$\n\nB) $O(M)$\n\nC) $O(N+M)$\n\nD) $O(N \\cdot M)$\n\nE) $O(N \\log N + M)$\n\nF) $O(N^2)$", "solution": "We are given a directed graph on $N$ vertices with $M$ edges in adjacency list form. A vertex is stand-alone if it has total degree zero, i.e., both in-degree and out-degree are zero. To find all such vertices efficiently, proceed as follows.\n\nInitialize two arrays for degrees: for each vertex $i \\in \\{0,\\dots,N-1\\}$, set $\\text{indeg}[i]=0$ and compute $\\text{outdeg}[i]=|\\text{Adj}[i]|$ by reading the list for $i$. For each edge encountered while scanning the adjacency lists, say $(i \\rightarrow v)$ where $v$ appears in $\\text{Adj}[i]$, increment $\\text{indeg}[v]$ by $1$. After completing the scan, declare $i$ stand-alone if and only if $\\text{indeg}[i]=0$ and $\\text{outdeg}[i]=0$; this requires a final pass over all $N$ vertices.\n\nCorrectness follows from the definitions: the out-degree is equal to the length of the adjacency list, and the in-degree is the count of incoming edges, which we compute by visiting each edge exactly once and incrementing the destination’s in-degree.\n\nLet $T(N,M)$ denote the running time. Scanning all $N$ adjacency lists to obtain out-degrees takes time proportional to the total number of list headers plus their elements, which is $O(N+M)$. While scanning, we process each of the $M$ edges once to accumulate in-degrees, which is $O(M)$. The final pass over all $N$ vertices to collect stand-alone vertices is $O(N)$. Therefore,\n$$\nT(N,M)=O(N)+O(M)+O(N)=O(N+M).\n$$\n\nThis is tight in the worst case. Any algorithm must at least inspect each adjacency list to determine whether it is empty, which is $\\Omega(N)$, and must also account for all $M$ edges to determine in-degrees, which is $\\Omega(M)$. Hence there is a lower bound\n$$\nT(N,M)=\\Omega(N+M),\n$$\nand combined with the upper bound, the optimal worst-case complexity is\n$$\nT(N,M)=\\Theta(N+M).\n$$\n\nAmong the given choices, this corresponds to $O(N+M)$.", "answer": "$$\\boxed{C}$$", "id": "1480481"}, {"introduction": "Beyond analyzing data structures, algorithmic complexity involves leveraging classic algorithms to solve new problems efficiently. This practice introduces a clever, two-step procedure using Breadth-First Search (BFS) to find the diameter of a tree. This exercise not only reinforces the mechanics of BFS but also demonstrates how exploiting specific properties of a graph—in this case, that a tree with $V$ vertices has $V-1$ edges—is crucial for deriving a tight complexity bound [@problem_id:1480548].", "problem": "In the design of a fault-tolerant, decentralized computing network, the nodes are connected to form a tree structure. This topology ensures connectivity with no redundant links. A critical performance metric for this network is its \"communication diameter,\" defined as the maximum number of hops (edges) in the shortest path between any two nodes.\n\nTo determine this diameter, the following two-step procedure is implemented:\n1.  An arbitrary starting node, `s`, performs a network-wide query to identify the node `u` that is farthest from it. This query is implemented using a Breadth-First Search (BFS), where \"farthest\" is defined by the greatest number of hops.\n2.  The identified node `u` then initiates its own BFS to find the node `v` that is, in turn, farthest from it. The distance between `u` and `v` is declared as the network's communication diameter.\n\nThe network is modeled as a connected, unweighted graph with $V$ nodes and $E$ edges. Given that this graph is a tree, determine the tightest possible worst-case time complexity for this entire two-step procedure. Express your answer in Big-O notation as a function of $V$ and/or $E$.", "solution": "We model the network as a connected, unweighted tree with $V$ nodes and $E$ edges. For any tree, the structural identity $E=V-1$ holds by definition (connected and acyclic).\n\nBreadth-First Search (BFS), implemented with adjacency lists, visits each vertex and each edge at most once. Therefore, the time complexity of a single BFS is\n$$\nT_{\\text{BFS}}(V,E)=\\Theta(V+E)=O(V+E).\n$$\nStep 1 performs one BFS from $s$ to find the farthest node $u$, costing $O(V+E)$. Step 2 performs another BFS from $u$ to find the farthest node $v$, again costing $O(V+E)$. Thus, the total time is\n$$\nT_{\\text{total}}(V,E)=T_{\\text{BFS}}(V,E)+T_{\\text{BFS}}(V,E)=O\\big((V+E)+(V+E)\\big)=O(V+E).\n$$\nBecause the graph is a tree, we substitute $E=V-1$ to obtain\n$$\nT_{\\text{total}}(V,E)=O\\big(V+(V-1)\\big)=O(2V-1)=O(V).\n$$\nThis $O(V)$ bound is the tightest possible worst-case complexity for the given two-step procedure on a tree.", "answer": "$$\\boxed{O(V)}$$", "id": "1480548"}]}