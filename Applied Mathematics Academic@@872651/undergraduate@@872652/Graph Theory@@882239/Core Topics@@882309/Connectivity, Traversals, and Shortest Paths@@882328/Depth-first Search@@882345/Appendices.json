{"hands_on_practices": [{"introduction": "To truly master Depth-First Search (DFS), we begin by manually tracing its execution. This foundational practice focuses on the recursive nature of DFS and the assignment of discovery and finish times to each vertex. By meticulously following the algorithm's steps as described in [@problem_id:1362166], you will develop a concrete intuition for how DFS plunges deep into the graph before backtracking, and see how the resulting timestamps capture the traversal's history.", "problem": "A software build system uses a \"dependency resolution protocol\" to determine the correct order for compiling a set of interconnected code modules. The protocol operates on a graph of modules and their dependencies. This process involves assigning two timestamps to each module: a \"discovery time\" and a \"finish time\".\n\nThe protocol is as follows:\n1.  A global timestamp counter is initialized to 1.\n2.  The process begins at a starting module. If no start is specified, it begins with the module that comes first in alphabetical order.\n3.  When a module is visited for the first time, it is marked \"discovered,\" its discovery time is set to the current value of the global timestamp, and the timestamp is incremented by 1.\n4.  The system then examines the neighbors of the just-discovered module. It recursively calls the protocol on the first unvisited neighbor found, according to alphabetical order.\n5.  After the recursive calls for all of a module's neighbors have returned, the module is marked \"finished,\" its finish time is set to the current value of the global timestamp, and the timestamp is incremented by 1. The process then returns to where it was called from.\n6.  If the initial traversal completes and there are still unvisited modules, the process is repeated starting from the unvisited module that comes first in alphabetical order.\n\nConsider a project with eight modules: A, B, C, D, E, F, G, H. The dependency relationships are symmetric (i.e., if X depends on Y, then Y depends on X) and are defined as follows:\n-   Module A is connected to B, D, and E.\n-   Module B is connected to A and C.\n-   Module C is connected to B, G, and H.\n-   Module D is connected to A and F.\n-   Module E is connected to A and F.\n-   Module F is connected to D, E, and G.\n-   Module G is connected to C and F.\n-   Module H is connected to C.\n\nStarting the protocol from module A, determine the discovery and finish times for all eight modules. Which of the following options correctly lists the `(discovery_time, finish_time)` pairs for all modules, ordered alphabetically from A to H?\n\nA. A:(1,16), B:(8,9), C:(7,12), D:(2,15), E:(4,5), F:(3,14), G:(6,13), H:(10,11)\n\nB. A:(1, 16), B:(2, 15), C:(3, 14), D:(8, 9), E:(6, 7), F:(5, 10), G:(4, 11), H:(12, 13)\n\nC. A:(1, 16), B:(2, 15), C:(3, 14), D:(6, 7), E:(8, 9), F:(5, 10), G:(4, 11), H:(12, 13)\n\nD. A:(1, 16), B:(2, 15), C:(3, 12), D:(6, 7), E:(8, 9), F:(5, 10), G:(4, 11), H:(13, 14)", "solution": "We perform a depth-first traversal with a global timestamp $t$ initialized to $1$, starting at $A$, and exploring neighbors in alphabetical order. On first visit to a node $v$, set its discovery time $d(v)=t$ and increment $t$ by $1$. After all recursive calls for $v$’s neighbors return, set its finish time $f(v)=t$ and increment $t$ by $1$.\n\nInitialize $t=1$.\n\nStart at $A$ with neighbors in order $B,D,E$.\n$d(A)=1, t=2$\nGo to $B$ (first unvisited neighbor of $A$). Neighbors of $B$ in order $A,C$.\n$d(B)=2, t=3$\n$A$ is already visited; go to $C$. Neighbors of $C$ in order $B,G,H$.\n$d(C)=3, t=4$\n$B$ is visited; go to $G$. Neighbors of $G$ in order $C,F$.\n$d(G)=4, t=5$\n$C$ is visited; go to $F$. Neighbors of $F$ in order $D,E,G$.\n$d(F)=5, t=6$\nGo to $D$ (first unvisited). Neighbors of $D$ in order $A,F$.\n$d(D)=6, t=7$\nBoth $A$ and $F$ are visited; finish $D$:\n$f(D)=7, t=8$\nReturn to $F$; next neighbor is $E$ (unvisited).\n$d(E)=8, t=9$\nNeighbors of $E$ are $A,F$, both visited; finish $E$:\n$f(E)=9, t=10$\nBack to $F$; next neighbor $G$ is visited; finish $F$:\n$f(F)=10, t=11$\nBack to $G$; no more neighbors; finish $G$:\n$f(G)=11, t=12$\nBack to $C$; next neighbor is $H$ (unvisited).\n$d(H)=12, t=13$\n$H$’s neighbor $C$ is visited; finish $H$:\n$f(H)=13, t=14$\nBack to $C$; no more neighbors; finish $C$:\n$f(C)=14, t=15$\nBack to $B$; no more neighbors; finish $B$:\n$f(B)=15, t=16$\nBack to $A$; remaining neighbors $D,E$ are already visited; finish $A$:\n$f(A)=16, t=17$\n\nThus the discovery/finish times are:\n- $A:(1,16)$\n- $B:(2,15)$\n- $C:(3,14)$\n- $D:(6,7)$\n- $E:(8,9)$\n- $F:(5,10)$\n- $G:(4,11)$\n- $H:(12,13)$\n\nThis matches option C.", "answer": "$$\\boxed{C}$$", "id": "1362166"}, {"introduction": "While the recursive formulation of DFS is elegant, its iterative counterpart using an explicit stack reveals the underlying mechanics of the traversal. This exercise, [@problem_id:1496233], challenges you to track the contents of a stack to simulate the search, demystifying how the algorithm keeps track of where to explore next and where to return to. Understanding this iterative process is crucial for implementing DFS in environments where recursion is limited and for appreciating its \"Last-In, First-Out\" exploration strategy.", "problem": "Consider an undirected graph $G = (V, E)$ defined by the vertex set $V = \\{0, 1, 2, 3, 4\\}$ and a set of edges $E$ that form a wheel graph $W_5$. In this graph, vertex 0 is the central hub connected to all other vertices. The remaining vertices $\\{1, 2, 3, 4\\}$ form a cycle, with edges connecting 1 to 2, 2 to 3, 3 to 4, and 4 back to 1.\n\nThe adjacency lists for the graph are defined as follows, with neighbors for each vertex listed in ascending numerical order:\n- `Adj(0): [1, 2, 3, 4]`\n- `Adj(1): [0, 2, 4]`\n- `Adj(2): [0, 1, 3]`\n- `Adj(3): [0, 2, 4]`\n- `Adj(4): [0, 1, 3]`\n\nYou are to perform an iterative Depth-First Search (DFS) on this graph. The algorithm proceeds as follows:\n1. Initialize an empty stack and an empty set of visited vertices.\n2. Push the starting vertex onto the stack.\n3. While the stack is not empty, pop a vertex `u`.\n4. If `u` has already been visited, do nothing and continue to the next iteration.\n5. If `u` has not been visited, mark it as visited. Then, for each of `u`'s neighbors `v` (retrieved from the adjacency list), if `v` has not been visited, push `v` onto the stack.\n6. The neighbors of `u` are pushed onto the stack in **descending order** of their vertex labels.\n\nThe DFS traversal starts at vertex 0. Your task is to determine the contents of the stack, from top to bottom, immediately after vertex 2 is popped from the stack.\n\nWhich of the following lists represents the contents of the stack at that moment?\n\nA. `[4, 2, 3, 4]`\n\nB. `[3, 4]`\n\nC. `[2, 4, 2, 3, 4]`\n\nD. `[1, 3, 2, 1]`\n\nE. `[2, 3, 4]`", "solution": "Let's trace the state of the stack and the visited set according to the algorithm specified in the problem. The stack is represented as `[TOP, ..., BOTTOM]`.\n\n1.  **Initial state:** `stack = []`, `visited = {}`. Push the start vertex 0.\n    - `stack = [0]`\n\n2.  **Iteration 1:** Pop 0. Vertex 0 is not visited.\n    - Mark 0 as visited: `visited = {0}`.\n    - Neighbors of 0 are `[1, 2, 3, 4]`. In descending order: 4, 3, 2, 1. All are unvisited.\n    - Push 4, then 3, then 2, then 1.\n    - `stack = [1, 2, 3, 4]`\n\n3.  **Iteration 2:** Pop 1. Vertex 1 is not visited.\n    - Mark 1 as visited: `visited = {0, 1}`.\n    - Neighbors of 1 are `[0, 2, 4]`. In descending order: 4, 2, 0.\n    - Neighbor 4 is not visited. Push 4. `stack = [4, 2, 3, 4]`.\n    - Neighbor 2 is not visited. Push 2. `stack = [2, 4, 2, 3, 4]`.\n    - Neighbor 0 is visited. Do nothing.\n    - `stack = [2, 4, 2, 3, 4]`\n\n4.  **Iteration 3:** Pop 2.\n    - The question asks for the state of the stack immediately *after* this pop.\n    - The stack is now `[4, 2, 3, 4]`.\n\nThis matches the contents listed in option A.", "answer": "$$\\boxed{A}$$", "id": "1496233"}, {"introduction": "A DFS traversal does more than just visit vertices; it implicitly defines a tree (or a forest) that represents the path of exploration. In this practice problem, [@problem_id:1496226], you will analyze how the structure of this DFS tree is influenced by the starting vertex and the rules for breaking ties. By predicting a key property of the tree—its height—you will move from simply executing the algorithm to understanding and analyzing its structural consequences on a given graph.", "problem": "Consider an undirected cycle graph, denoted as $C_{10}$, with a set of vertices $V = \\{v_1, v_2, \\dots, v_{10}\\}$. The edges of this graph connect vertices cyclically, meaning the edge set is $E = \\{(v_i, v_{i+1}) \\mid i = 1, \\dots, 9\\} \\cup \\{(v_{10}, v_1)\\}$.\n\nA Depth-First Search (DFS) is to be performed on this graph. During the search, whenever a vertex has multiple unvisited neighbors, the neighbors are to be visited in increasing order of their vertex index. For example, if exploring from a vertex with unvisited neighbors $v_2$ and $v_8$, the DFS will proceed to $v_2$ first.\n\nThe height of a rooted tree is defined as the number of edges on the longest downward path from the root to a leaf node.\n\nWe will consider two separate cases for the DFS traversal:\n1.  The DFS starts at vertex $v_1$. Let the height of the resulting DFS tree be $H_1$.\n2.  The DFS starts at vertex $v_2$. Let the height of the resulting DFS tree be $H_2$.\n\nDetermine the values of $H_1$ and $H_2$. Report your answer as the ordered pair $(H_1, H_2)$.", "solution": "Let the undirected cycle be $C_{10}$ with vertices $V=\\{v_{1},v_{2},\\dots,v_{10}\\}$ and edges $E=\\{(v_{i},v_{i+1})\\mid i=1,\\dots,9\\}\\cup\\{(v_{10},v_{1})\\}$. For each $v_{i}$, its neighbors are $N(v_{i})=\\{v_{i-1},v_{i+1}\\}$ with indices interpreted modulo $10$ so that $v_{0}=v_{10}$ and $v_{11}=v_{1}$. The DFS rule is: at any step, among the unvisited neighbors of the current vertex, visit the one(s) in increasing index order.\n\nCase 1: start at $v_{1}$. At $v_{1}$, the unvisited neighbors are $\\{v_{2},v_{10}\\}$, so DFS chooses $v_{2}$ first. For $k=2,\\dots,9$, at $v_{k}$ the neighbors are $\\{v_{k-1},v_{k+1}\\}$; the parent $v_{k-1}$ is already visited, so the only unvisited neighbor is $v_{k+1}$, which is then visited. Upon reaching $v_{10}$, both neighbors $v_{9}$ and $v_{1}$ are visited, so DFS backtracks without adding new tree edges. Therefore, the DFS tree consists of the path\n$$v_{1}-v_{2}-v_{3}-\\cdots -v_{10},$$\nwhich has $9$ edges from the root $v_{1}$ to the leaf $v_{10}$. Hence $H_{1}=9$.\n\nCase 2: start at $v_{2}$. At $v_{2}$, the unvisited neighbors are $\\{v_{1},v_{3}\\}$, so DFS chooses $v_{1}$ first. At $v_{1}$, the unvisited neighbor with smallest index is $v_{10}$ (since $v_{2}$ is already visited), so DFS proceeds to $v_{10}$. Continuing, at each step from $v_{10}$ down to $v_{4}$, the only unvisited neighbor is the next lower-index neighbor, yielding the sequence\n$$v_{2}-v_{1}-v_{10}-v_{9}-v_{8}-v_{7}-v_{6}-v_{5}-v_{4}-v_{3}.$$\nAt $v_{3}$, both neighbors are visited, so DFS backtracks, and when it returns to $v_{2}$, the other neighbor $v_{3}$ is already visited. Thus the DFS tree is again a single path on all $10$ vertices rooted at $v_{2}$, whose longest root-to-leaf path (from $v_{2}$ to $v_{3}$) has $9$ edges. Hence $H_{2}=9$.\n\nTherefore, $(H_{1},H_{2})=(9,9)$.", "answer": "$$\\boxed{\\begin{pmatrix} 9  9 \\end{pmatrix}}$$", "id": "1496226"}]}