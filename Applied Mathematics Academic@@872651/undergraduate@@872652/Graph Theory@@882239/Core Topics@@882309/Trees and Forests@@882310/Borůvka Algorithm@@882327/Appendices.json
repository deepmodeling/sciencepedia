{"hands_on_practices": [{"introduction": "To truly grasp the distinct nature of Borůvka's algorithm, it is helpful to compare it directly with other classic Minimum Spanning Tree (MST) methods like Prim's algorithm. This first exercise challenges you to find a scenario where these two algorithms make different initial choices, highlighting their fundamentally different strategies. By carefully applying the specified tie-breaking rules, you will see how Prim's algorithm expands a single tree, while Borůvka's algorithm initiates a forest of components in parallel, demonstrating its unique operational logic from the very first step [@problem_id:1484821].", "problem": "Consider the task of finding a Minimum Spanning Tree (MST) for a connected, weighted, undirected graph. Two well-known algorithms for this are Prim's algorithm and Borůvka's algorithm. When multiple edges share the same minimum weight, the behavior of these algorithms depends on specific tie-breaking rules.\n\nLet's define the following tie-breaking rules for implementations of these algorithms:\n1.  **Prim's Algorithm Tie-Breaking:** The algorithm grows a single tree. When selecting the next edge to add, if there is a tie for the minimum weight among edges connecting a vertex inside the tree to a vertex outside, the algorithm chooses the edge whose endpoint outside the tree comes lexicographically **last**.\n2.  **Borůvka's Algorithm Tie-Breaking:** In its first iteration, each vertex (as an initial component) must select its cheapest incident edge. If a vertex has multiple cheapest incident edges, it selects the one whose other endpoint comes lexicographically **first**. After all vertices have made a selection, the set of unique selected edges is added to the MST forest.\n\nYour task is to identify which of the following graph specifications (defined by a set of vertices V, a set of edges E with weights, and a starting vertex for Prim's algorithm) presents a scenario where the first edge selected by Prim's algorithm is **not** part of the set of unique edges selected by Borůvka's algorithm in its first iteration.\n\nAll graphs share the same set of vertices, V = {A, B, C, D}. Edges are represented as (Vertex1, Vertex2, Weight).\n\nA. Edges E = { (A, B, 10), (A, C, 10), (B, D, 12), (C, D, 5) }. Prim's starting vertex: A.\n\nB. Edges E = { (A, B, 2), (A, C, 3), (B, C, 4), (C, D, 1) }. Prim's starting vertex: A.\n\nC. Edges E = { (A, B, 10), (A, C, 10), (B, D, 12), (C, D, 12) }. Prim's starting vertex: A.\n\nD. Edges E = { (A, B, 10), (A, C, 10), (B, D, 12), (C, D, 5) }. Prim's starting vertex: C.", "solution": "We assume the lexicographic order on vertices is $A<B<C<D$. The rules are:\n- Prim’s algorithm: from the current tree, select a minimum-weight edge crossing the cut; if tied, choose the edge whose outside endpoint is lexicographically last.\n- Borůvka’s algorithm (first iteration): each vertex selects its cheapest incident edge; if tied, it selects the one whose other endpoint is lexicographically first. After all selections, the set of unique selected edges is formed.\n\nOption A: $E=\\{(A,B,10),(A,C,10),(B,D,12),(C,D,5)\\}$, Prim starts at $A$.\n- Prim’s first edge from $\\{A\\}$: candidates $(A,B,10)$ and $(A,C,10)$; tie on weight $10$, outside endpoints are $B$ and $C$, lexicographically last is $C$, so Prim selects $(A,C,10)$.\n- Borůvka selections:\n  - $A$: cheapest among $(A,B,10),(A,C,10)$ is weight $10$; tie broken toward lexicographically first other endpoint $B$, so selects $(A,B,10)$.\n  - $B$: cheapest among $(A,B,10),(B,D,12)$ is $(A,B,10)$.\n  - $C$: cheapest among $(A,C,10),(C,D,5)$ is $(C,D,5)$.\n  - $D$: cheapest among $(B,D,12),(C,D,5)$ is $(C,D,5)$.\n  - Unique set $S=\\{(A,B,10),(C,D,5)\\}$.\n  - Prim’s first edge $(A,C,10)\\notin S$. Hence A satisfies the condition.\n\nOption B: $E=\\{(A,B,2),(A,C,3),(B,C,4),(C,D,1)\\}$, Prim starts at $A$.\n- Prim’s first edge from $\\{A\\}$: minimum is $(A,B,2)$.\n- Borůvka selections:\n  - $A$: $(A,B,2)$.\n  - $B$: $(A,B,2)$.\n  - $C$: $(C,D,1)$.\n  - $D$: $(C,D,1)$.\n  - Unique set $S=\\{(A,B,2),(C,D,1)\\}$ includes $(A,B,2)$. Hence B does not satisfy.\n\nOption C: $E=\\{(A,B,10),(A,C,10),(B,D,12),(C,D,12)\\}$, Prim starts at $A$.\n- Prim’s first edge from $\\{A\\}$: tie on $(A,B,10)$ and $(A,C,10)$; outside endpoints $B,C$, lexicographically last is $C$, so $(A,C,10)$.\n- Borůvka selections:\n  - $A$: tie on $(A,B,10)$ and $(A,C,10)$; choose lexicographically first other endpoint $B$, so $(A,B,10)$.\n  - $B$: $(A,B,10)$.\n  - $C$: $(A,C,10)$.\n  - $D$: tie on $(B,D,12)$ and $(C,D,12)$; choose lexicographically first other endpoint $B$, so $(B,D,12)$.\n  - Unique set $S=\\{(A,B,10),(A,C,10),(B,D,12)\\}$ includes $(A,C,10)$. Hence C does not satisfy.\n\nOption D: $E=\\{(A,B,10),(A,C,10),(B,D,12),(C,D,5)\\}$, Prim starts at $C$.\n- Prim’s first edge from $\\{C\\}$: minimum is $(C,D,5)$.\n- Borůvka selections are as in Option A, giving unique set $S=\\{(A,B,10),(C,D,5)\\}$, which includes $(C,D,5)$. Hence D does not satisfy.\n\nOnly Option A meets the requirement.", "answer": "$$\\boxed{A}$$", "id": "1484821"}, {"introduction": "Having contrasted Borůvka's algorithm with others, let's now dive into its mechanics by tracing its execution over multiple iterations. This problem presents a specially constructed \"Hierarchically Connected Star Graph\" designed to illustrate the algorithm's core process of merging components step-by-step. By tracking how components combine in successive rounds, you will gain a concrete understanding of how the algorithm builds the MST and develop an intuition for its logarithmic efficiency [@problem_id:1484797].", "problem": "Consider a specialized undirected weighted graph, which we will call a \"Hierarchically Connected Star Graph\". This graph is defined by a parameter $n$, where $n = 2^k + 1$ for some positive integer $k$. The graph has $n$ vertices, labeled $v_0, v_1, \\ldots, v_{n-1}$.\n\nThe edges and their corresponding weights are defined as follows:\n\n1.  **Hub Connections:** For each $i \\in \\{1, 2, \\ldots, n-1\\}$, there is an edge connecting the central vertex $v_0$ to the peripheral vertex $v_i$. The weight of each of these edges is $W = n-1$.\n\n2.  **Peripheral Connections:** For each $i \\in \\{1, 2, \\ldots, n-2\\}$, there is an edge connecting the vertex $v_i$ to $v_{i+1}$. The weight of the edge $(v_i, v_{i+1})$ is given by the formula $w(v_i, v_{i+1}) = 2^p$, where $p$ is the largest non-negative integer such that $i$ is divisible by $2^p$.\n\nSuppose Borůvka's algorithm is executed on this graph to find a Minimum Spanning Tree (MST). In cases where multiple edges have the same minimum weight, the algorithm breaks ties by choosing the edge connected to the vertex with the smallest index.\n\nDetermine the total weight of the resulting MST. Express your answer as a closed-form analytic expression in terms of $n$.", "solution": "The problem asks for the total weight of the Minimum Spanning Tree (MST) found by Borůvka's algorithm on a specific graph. The graph has $n$ vertices, $v_0, v_1, \\ldots, v_{n-1}$, where $n = 2^k + 1$ for some integer $k \\ge 1$. Let $N = n-1 = 2^k$.\n\nThe weights are:\n-   $w(v_0, v_i) = N$ for $i=1, \\ldots, N$.\n-   $w(v_i, v_{i+1}) = 2^p$ for $i=1, \\ldots, N-1$, where $p$ is the largest integer such that $2^p$ divides $i$.\n\nBorůvka's algorithm works in iterations. In each iteration, every component finds its minimum-weight outgoing edge, and all such edges are added to the MST forest.\n\n**Initial State:**\nThe algorithm starts with $n$ components, where each vertex is its own component: $C_0=\\{v_0\\}, C_1=\\{v_1\\}, \\ldots, C_{N}=\\{v_{n-1}\\}$.\n\n**Iteration 1:**\nWe find the minimum-weight outgoing edge for each component.\n-   For component $C_0=\\{v_0\\}$: The outgoing edges are $(v_0, v_i)$ for $i=1, \\ldots, N$, all with weight $N=2^k$. The tie-breaking rule selects $(v_0, v_1)$.\n-   For any peripheral component $C_i=\\{v_i\\}$ where $i \\in \\{1, \\ldots, N\\}$: The outgoing edges are $(v_i, v_0)$ (weight $N$) and possibly $(v_i, v_{i-1})$ and $(v_i, v_{i+1})$. The weights of these peripheral connection edges are $w(v_{i-1},v_i) = 2^{p(i-1)}$ and $w(v_i,v_{i+1}) = 2^{p(i)}$. The smallest possible weight for a peripheral edge corresponds to $p=0$, which gives a weight of $2^0=1$. This occurs when the index $i$ or $i-1$ is odd. Since $k \\ge 1$, $N=2^k \\ge 2$, so any peripheral edge with weight 1 is cheaper than any hub connection.\n-   Let's analyze the peripheral edges with weight 1. These are $(v_i, v_{i+1})$ where $p(i)=0$, i.e., $i$ is odd. So, edges $(v_1, v_2), (v_3, v_4), \\ldots, (v_{N-1}, v_N)$ all have weight 1.\n-   For an odd-indexed component $C_i$: its cheapest edge is $(v_i, v_{i+1})$ with weight 1.\n-   For an even-indexed component $C_i$: its cheapest edge is $(v_i, v_{i-1})$ with weight 1.\n-   As a result, components $\\{v_1, v_2\\}$, $\\{v_3, v_4\\}$, ..., $\\{v_{N-1}, v_N\\}$ are formed by adding edges of weight 1. There are $N/2$ such edges. The central component $C_0$ remains separate because its chosen edge $(v_0,v_1)$ has weight $N$, which is not added yet because $C_1$ found a cheaper edge.\n-   After iteration 1, we have $N/2$ components of size 2, plus the isolated component $C_0$. Total components: $N/2+1$.\n-   Weight added in Iteration 1: $\\frac{N}{2} \\times 1 = \\frac{N}{2}$.\n\n**Iteration 2:**\n-   The components are now of the form $C'_{j} = \\{v_{2j-1}, v_{2j}\\}$ for $j=1, \\ldots, N/2$.\n-   The cheapest outgoing edge for such a component will connect it to a neighboring component $C'_{j-1}$ or $C'_{j+1}$. The connecting edges are $(v_{2j-2}, v_{2j-1})$ and $(v_{2j}, v_{2j+1})$.\n-   The weight of $(v_{2j}, v_{2j+1})$ has index $i=2j$, for which $p(2j) \\ge 1$. The smallest non-zero $p(i)$ is 1, so the next level of edge weights is $2^1=2$. This occurs for edges $(v_2, v_3), (v_6, v_7), \\ldots$. However, the edge connecting two of our new components is, for example, $(v_2, v_3)$, which links $\\{v_1,v_2\\}$ and $\\{v_3,v_4\\}$. The index is $i=2$, so $p(2)=1$ and the weight is $2^1=2$.\n-   In general, the cheapest edge leaving a component $\\{v_{2j-1}, v_{2j}\\}$ will be either $(v_{2j-2}, v_{2j-1})$ or $(v_{2j}, v_{2j+1})$. The indices $2j-2$ and $2j$ are even. The one with the lowest weight will be chosen. The weights are $w(v_{2j-2}, v_{2j-1}) = 2^{p(2j-2)}$ and $w(v_{2j}, v_{2j+1}) = 2^{p(2j)}$. One of these will have $p=1$, giving weight 2. This is cheaper than any hub connection (weight $N=2^k$) as long as $k \\ge 2$.\n-   The components of size 2 merge into components of size 4. For example, $\\{v_1, v_2\\}$ and $\\{v_3, v_4\\}$ merge via edge $(v_2, v_3)$ of weight $2^{p(2)}=2$. There are $N/4$ such merging edges.\n-   After iteration 2, we have $N/4$ components of size 4, plus $C_0$. Total components: $N/4+1$.\n-   Weight added in Iteration 2: $\\frac{N}{4} \\times 2 = \\frac{N}{2}$.\n\n**Iteration $m$ (for $1 \\le m \\le k$):**\n-   At the beginning of iteration $m$, we have $N/2^{m-1}$ components of size $2^{m-1}$ (plus $C_0$).\n-   The cheapest edge connecting two such components, like $\\{v_1, \\ldots, v_{2^{m-1}}\\}$ and $\\{v_{2^{m-1}+1}, \\ldots, v_{2^m}\\}$, is the edge $(v_{2^{m-1}}, v_{2^{m-1}+1})$.\n-   The index is $i=2^{m-1}$, so $p(i) = m-1$. The weight of this edge is $2^{m-1}$.\n-   This weight is smaller than the hub connection weight $N=2^k$ for $m-1 < k$, which is true for $m \\le k$.\n-   The components of size $2^{m-1}$ merge into components of size $2^m$. There are $\\frac{N/2^{m-1}}{2} = N/2^m$ such merges.\n-   Weight added in Iteration $m$: $\\frac{N}{2^m} \\times 2^{m-1} = \\frac{N}{2}$.\n\n**After Iteration $k$:**\n-   All the peripheral vertices $v_1, \\ldots, v_N$ have merged into a single large component $C_{path} = \\{v_1, \\ldots, v_N\\}$.\n-   The total number of components is now 2: $C_0$ and $C_{path}$.\n-   The total weight added so far from iterations 1 to $k$ is $\\sum_{m=1}^{k} \\frac{N}{2} = k \\times \\frac{N}{2}$.\n\n**Final Iteration ($k+1$):**\n-   The two remaining components, $C_0=\\{v_0\\}$ and $C_{path}=\\{v_1, \\ldots, v_N\\}$, must now connect.\n-   The cheapest outgoing edge from $C_{path}$ is one of the hub connections $(v_i, v_0)$, all of which have weight $N$.\n-   Similarly, the cheapest outgoing edge from $C_0$ is one of the hub connections, with weight $N$.\n-   The algorithm adds one of these edges (e.g., $(v_0, v_1)$ by the tie-breaking rule) to connect the two components.\n-   Weight added in Iteration $k+1$: $N$.\n-   The algorithm terminates as there is only one component left.\n\n**Total Weight Calculation:**\nThe total weight of the MST is the sum of weights added in all iterations.\nTotal Weight = (Weight from iterations 1 to k) + (Weight from iteration k+1)\nTotal Weight = $\\left(k \\times \\frac{N}{2}\\right) + N$\n\nNow, we substitute $N = n-1$ and $k = \\log_2(N) = \\log_2(n-1)$.\nTotal Weight = $\\log_2(n-1) \\times \\frac{n-1}{2} + (n-1)$\n\nThis can be factored:\nTotal Weight = $(n-1) \\left(\\frac{\\log_2(n-1)}{2} + 1\\right)$", "answer": "$$\\boxed{(n-1) \\left(\\frac{\\log_{2}(n-1)}{2} + 1\\right)}$$", "id": "1484797"}, {"introduction": "Now, let's shift our focus from executing the algorithm to analyzing its performance. This final practice is a thought experiment that explores the worst-case behavior of Borůvka's algorithm on a wheel graph $W_n$. Your task is to devise a weighting scheme that maximizes the number of iterations, which paradoxically reveals the algorithm's greatest strength: even in the worst case, the number of components shrinks rapidly. This exercise provides deep insight into why Borůvka's algorithm is inherently efficient and has a logarithmic number of rounds, a key feature for parallel computing [@problem_id:1484805].", "problem": "Borůvka's algorithm is a method for finding a Minimum Spanning Tree (MST) in a connected, undirected graph with distinct edge weights. The algorithm proceeds in iterations. It begins with each vertex of the graph considered as a separate component, forming a forest of components. In each iteration, every component identifies the edge with the minimum weight connecting one of its vertices to a vertex in a *different* component. All such minimum-weight edges are then added to the MST forest. As edges are added, components merge. The algorithm terminates when only one component, the MST itself, remains.\n\nConsider a wheel graph, denoted as $W_n$, for $n \\ge 3$. This graph consists of a central \"hub\" vertex, let's call it $v_0$, and a set of $n-1$ \"rim\" vertices, $v_1, v_2, \\ldots, v_{n-1}$. The rim vertices are connected to form a cycle graph $C_{n-1}$, meaning edges exist between $v_i$ and $v_{i+1}$ for $i=1, \\ldots, n-2$, and also between $v_{n-1}$ and $v_1$. Additionally, the hub vertex $v_0$ is connected by a \"spoke\" edge to every rim vertex $v_i$ for $i=1, \\ldots, n-1$.\n\nYour task is to analyze the worst-case performance of Borůvka's algorithm on such a graph. Devise a general strategy for assigning unique positive integer weights to the edges of $W_n$ that maximizes the number of iterations Borůvka's algorithm must perform.\n\nWhat is the maximum possible number of iterations required by Borůvka's algorithm to find the MST of a wheel graph $W_n$, expressed as a function of $n$?", "solution": "Let $W_{n}$ have hub $v_{0}$ and rim vertices $v_{1},\\ldots,v_{n-1}$ connected in a cycle. Borůvka’s algorithm proceeds in phases; at the start of a phase with $c$ components, each component chooses its lightest outgoing edge, all these edges are added, and the resulting connected pieces are contracted.\n\nKey general fact (used for the upper bound): In any phase, if the current number of components is $c$, then the number after the phase is at most\n$$\n\\left\\lfloor \\frac{c}{2} \\right\\rfloor.\n$$\nReason: Direct each component’s chosen edge outward. Each weakly connected component of the directed graph contains at least two original components (because every node has outdegree $1$ and no chosen edge is a self-loop), so the number of resulting components is at most $\\lfloor c/2 \\rfloor$.\n\nTherefore, after $t$ phases,\n$$\nc_{t} \\le \\left\\lfloor \\frac{n}{2^{t}} \\right\\rfloor.\n$$\nTo force the maximum possible number of phases before reaching a single component, we want equality at each step, namely $c_{i+1}=\\left\\lfloor c_{i}/2 \\right\\rfloor$. If this can be achieved for all phases starting from $c_{0}=n$, then the algorithm terminates when\n$$\n\\left\\lfloor \\frac{n}{2^{t}} \\right\\rfloor = 1,\n$$\nwhich is equivalent to $1 \\le \\frac{n}{2^{t}} < 2$, i.e., $2^{t} \\le n < 2^{t+1}$. Thus the maximum possible number of phases is\n$$\nt = \\left\\lfloor \\log_{2} n \\right\\rfloor.\n$$\n\nWe now give a weight assignment strategy for $W_{n}$ that achieves $c_{i+1}=\\left\\lfloor c_{i}/2 \\right\\rfloor$ in every phase.\n\nWeight-assignment strategy (unique positive integers, with strict separation into “bands” per phase):\n1) Partition the rim edges of the initial cycle into two alternating sets around the cycle. Assign to one of these sets (call them “level-1 edges”) strictly increasing small integer weights, all smaller than any other edge weight. Assign to all spokes and to the other rim edges strictly larger integer weights so that, for every rim vertex, its minimum incident edge is its designated level-1 rim edge (not a spoke). Also choose the hub’s lightest spoke to be larger than all level-1 edges (so it does not disturb rim choices) but lighter than the other spokes, so the hub chooses exactly one spoke.\n\nConsequence of step 1: Along the rim, every chosen level-1 rim edge is selected by both its endpoints, forming disjoint pairs of rim vertices; if the rim has odd length, exactly one rim vertex remains unmatched. The hub chooses one spoke. Counting components after this phase:\n- If the number of current components $c$ is even (rim count odd), the hub’s single chosen spoke attaches to the unique unmatched rim component, so $c$ is halved: $c_{1} = c/2$.\n- If $c$ is odd (rim count even), the hub’s spoke attaches to one of the newly formed rim pairs, making a size-3 component, and the remaining rim pairs are separate; again $c_{1} = (c-1)/2 = \\lfloor c/2 \\rfloor$.\n\nThus in either case $c_{1}=\\left\\lfloor \\frac{n}{2} \\right\\rfloor$.\n\n2) Inductive continuation: After contracting, the component graph is again a wheel: one hub component and a rim cycle of $c_{1}-1$ components. Preassign the remaining (not-yet-chosen) rim edges so that at “level-2” an alternating subset of rim edges has weights strictly larger than all level-1 weights but strictly smaller than any other remaining edges incident to rim components. Ensure every rim component’s two spokes (to the hub component) are heavier than its designated level-2 rim edge, while among the hub’s spokes one is the smallest in this band so the hub chooses exactly one spoke. This forces the same pairing behavior on the rim components at level 2, yielding\n$$\nc_{2}=\\left\\lfloor \\frac{c_{1}}{2} \\right\\rfloor.\n$$\n\n3) Repeat this hierarchical assignment for levels $3,4,\\ldots$ so that at level $j$ the designated rim edges all lie in a weight band strictly above all prior levels and strictly below any edges that must be avoided at that level. Uniqueness of weights is guaranteed by choosing distinct integers within each band. This ensures that at every phase $i$ the choice pattern is exactly the same: rim components pair along the cycle; the hub component picks exactly one spoke; and the component count satisfies the equality\n$$\nc_{i+1}=\\left\\lfloor \\frac{c_{i}}{2} \\right\\rfloor.\n$$\n\nBy induction, after $t$ phases we have $c_{t}=\\left\\lfloor \\frac{n}{2^{t}} \\right\\rfloor$, so the maximum possible number of Borůvka iterations until a single component remains is the unique integer $t$ with $2^{t} \\le n < 2^{t+1}$, namely\n$$\n\\left\\lfloor \\log_{2} n \\right\\rfloor.\n$$\n\nHence the worst-case (maximized over all distinct positive integer weight assignments) number of Borůvka iterations on the wheel $W_{n}$ is exactly $\\left\\lfloor \\log_{2} n \\right\\rfloor$.", "answer": "$$\\boxed{\\left\\lfloor \\log_{2} n \\right\\rfloor}$$", "id": "1484805"}]}