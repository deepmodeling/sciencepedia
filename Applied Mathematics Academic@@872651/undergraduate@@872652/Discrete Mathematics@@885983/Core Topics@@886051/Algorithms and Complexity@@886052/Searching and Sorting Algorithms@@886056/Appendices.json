{"hands_on_practices": [{"introduction": "Binary search is a cornerstone of efficient data retrieval, but its performance hinges on flawless implementation. Understanding an algorithm involves more than memorizing its steps; it requires the ability to trace its execution and identify errors. This exercise will sharpen your debugging skills by asking you to follow the logic of a binary search algorithm containing a subtle but critical bug, demonstrating how a small mistake can lead to incorrect behavior. [@problem_id:1398583]", "problem": "A programmer is implementing a binary search routine to find a target value `T` in a sorted, 0-indexed array `A`. However, the implementation contains a subtle bug.\n\nThe algorithm is defined as follows:\n1. Initialize the search boundaries: `low = 0` and `high = n-1`, where `n` is the number of elements in the array.\n2. While `low = high`, perform the following steps:\n   a. Calculate the middle index: $mid = \\lfloor \\frac{low + high}{2} \\rfloor$.\n   b. Compare the target `T` with the element `A[mid]`.\n   c. If `T == A[mid]`, the search terminates successfully.\n   d. If `T  A[mid]`, the upper boundary is updated correctly: `high = mid - 1`.\n   e. If `T  A[mid]`, the lower boundary is updated incorrectly due to a bug: `low = mid`. (A correct implementation would use `low = mid + 1`).\n\nYour task is to trace this buggy algorithm's execution on the sorted array `A = [2, 5, 8, 12, 16, 23, 38, 56, 72, 91]` when searching for the target value `T = 25`.\n\nCalculate the sum of the first three array elements that are compared with the target `T` during the execution of this search.", "solution": "We have a sorted, 0-indexed array $A = [2, 5, 8, 12, 16, 23, 38, 56, 72, 91]$ with $n = 10$ and a target $T = 25$. The algorithm initializes $low = 0$ and $high = n - 1 = 9$, and in each iteration computes $mid = \\left\\lfloor \\frac{low + high}{2} \\right\\rfloor$. Due to the bug, when $T  A[mid]$, it updates $low \\leftarrow mid$ instead of $low \\leftarrow mid + 1$.\n\nIteration 1:\n- Initial bounds: $low = 0$, $high = 9$.\n- Middle index: $mid_{1} = \\left\\lfloor \\frac{0 + 9}{2} \\right\\rfloor = \\left\\lfloor \\frac{9}{2} \\right\\rfloor = 4$.\n- Compared element: $A[mid_{1}] = A[4] = 16$.\n- Comparison: $T = 25  16 = A[4]$.\n- Buggy update: $low \\leftarrow mid = 4$; $high$ remains $9$.\n\nIteration 2:\n- Bounds: $low = 4$, $high = 9$.\n- Middle index: $mid_{2} = \\left\\lfloor \\frac{4 + 9}{2} \\right\\rfloor = \\left\\lfloor \\frac{13}{2} \\right\\rfloor = 6$.\n- Compared element: $A[mid_{2}] = A[6] = 38$.\n- Comparison: $T = 25  38 = A[6]$.\n- Correct upper update: $high \\leftarrow mid - 1 = 5$; $low$ remains $4$.\n\nIteration 3:\n- Bounds: $low = 4$, $high = 5$.\n- Middle index: $mid_{3} = \\left\\lfloor \\frac{4 + 5}{2} \\right\\rfloor = \\left\\lfloor \\frac{9}{2} \\right\\rfloor = 4$.\n- Compared element: $A[mid_{3}] = A[4] = 16$.\n- Comparison: $T = 25  16 = A[4]$.\n- Buggy update: $low \\leftarrow mid = 4$ (this would cause the search to get stuck, but only the first three comparisons are required).\n\nThe first three compared elements are $16$, $38$, and $16$. Therefore, the required sum is\n$$S = 16 + 38 + 16 = 70.$$", "answer": "$$\\boxed{70}$$", "id": "1398583"}, {"introduction": "The Quicksort algorithm is a classic example of the powerful \"divide and conquer\" strategy. Its efficiency stems from a clever core operation known as partitioning, which rearranges an array around a chosen pivot element. By manually stepping through a single partition process, you will gain a foundational, hands-on understanding of the mechanism that makes Quicksort one of the most widely used sorting algorithms in practice. [@problem_id:1398611]", "problem": "In a distributed computing environment, a load balancer needs to quickly rearrange a list of incoming tasks based on their assigned priority values. The goal is to perform a single partitioning pass to group tasks with lower priority values before tasks with higher priority values, relative to a chosen pivot task. This helps in delegating tasks more efficiently.\n\nYou are given a list of priority values for five tasks: $[7, 2, 9, 1, 5]$.\n\nThe partitioning algorithm to be used is as follows:\n1. The last element in the list is selected as the pivot value.\n2. A boundary index, `i`, is initialized to a position that is one place before the first element of the list.\n3. A second index, `j`, iterates through the list from the first element up to, but not including, the pivot element.\n4. During the iteration, if the element at index `j` is less than or equal to the pivot's value, the boundary index `i` is first incremented, and then the element at index `i` is swapped with the element at index `j`.\n5. After the iteration is complete, the pivot element is swapped with the element at index `i+1`.\n\nWhich of the following lists represents the state of the task list after this one-time partitioning process is complete?\n\nA. $[2, 1, 5, 7, 9]$\n\nB. $[1, 2, 5, 7, 9]$\n\nC. $[2, 1, 9, 7, 5]$\n\nD. $[5, 2, 7, 1, 9]$\n\nE. $[2, 1, 7, 5, 9]$", "solution": "We apply the described Lomuto-style partition to the list $A = [7,2,9,1,5]$ using the last element as pivot.\n\nSet the pivot $p = A[4] = 5$ and initialize the boundary index $i = -1$. Iterate $j$ from $0$ to $3$ and perform the conditional swap when $A[j] \\leq p$.\n\nFor $j=0$: $A[0] = 7$. Since $7 \\leq 5$ is false, do nothing; $i=-1$, $A=[7,2,9,1,5]$.\n\nFor $j=1$: $A[1] = 2$. Since $2 \\leq 5$ is true, increment $i$ to $0$ and swap $A[0]$ with $A[1]$, giving $A=[2,7,9,1,5]$.\n\nFor $j=2$: $A[2] = 9$. Since $9 \\leq 5$ is false, do nothing; $i=0$, $A=[2,7,9,1,5]$.\n\nFor $j=3$: $A[3] = 1$. Since $1 \\leq 5$ is true, increment $i$ to $1$ and swap $A[1]$ with $A[3]$, giving $A=[2,1,9,7,5]$.\n\nAfter the loop, swap the pivot with $A[i+1]$, i.e., swap $A[2]$ with $A[4]$, resulting in $A=[2,1,5,7,9]$.\n\nThus, the state of the list after one partition pass is $[2,1,5,7,9]$, which corresponds to option A.", "answer": "$$\\boxed{A}$$", "id": "1398611"}, {"introduction": "Choosing the most efficient algorithm often involves analyzing a trade-off between upfront preparation costs and long-term operational benefits. A common dilemma is whether to sort a dataset once to enable fast binary searches, or to perform slower linear searches on the unsorted data as needed. This practice challenges you to move from implementing algorithms to analyzing them, using mathematical modeling to determine the precise point at which the initial cost of sorting becomes a worthwhile investment. [@problem_id:1398631]", "problem": "A data processing system must perform $k$ independent search queries on a static dataset stored as an array of $n$ unique items. Two strategies are being considered to handle these queries. The efficiency of each strategy is measured by its total computational time, which is determined by the number of two fundamental operations: key comparisons and data moves. The time required for a single key comparison is $T_c$, and the time for a single data move is $T_m$. You can assume that $n \\ge 3$.\n\n**Strategy 1: Repeated Linear Search**\nFor each of the $k$ queries, perform a linear search on the original, unsorted array. In the worst-case scenario, a single linear search requires $n$ key comparisons.\n\n**Strategy 2: Sort-then-Search**\nFirst, sort the array once using a specific implementation of a comparison-based sorting algorithm. In the worst case, this algorithm performs exactly $A \\cdot n \\log_2(n)$ key comparisons and $B \\cdot n \\log_2(n)$ data moves, where $A$ and $B$ are constants characteristic of the algorithm. After sorting, perform a binary search for each of the $k$ queries. In the worst case, a binary search on a sorted array of size $n$ requires $\\lfloor \\log_2(n) \\rfloor + 1$ key comparisons. Data moves are not a factor during the search phase.\n\nDetermine the smallest integer value of $k$ for which the total worst-case time cost of Strategy 2 is strictly less than the total worst-case time cost of Strategy 1. Your answer should be a formula in terms of $n, T_c, T_m, A$, and $B$.", "solution": "Let $L=\\lfloor \\log_{2}(n) \\rfloor + 1$ denote the worst-case number of key comparisons for a binary search on size $n$.\n\nWorst-case total time for Strategy 1 (repeated linear search):\nEach query costs $n$ comparisons, so\n$$\nT_{1}=k \\cdot n \\cdot T_{c}.\n$$\n\nWorst-case total time for Strategy 2 (sort-then-search):\nSorting costs $A \\cdot n \\log_{2}(n)$ comparisons and $B \\cdot n \\log_{2}(n)$ moves, giving time\n$$\nn \\log_{2}(n)\\left(A T_{c}+B T_{m}\\right).\n$$\nEach of the $k$ binary searches costs $L$ comparisons, so the search phase costs\n$$\nk \\cdot L \\cdot T_{c}.\n$$\nHence,\n$$\nT_{2}=n \\log_{2}(n)\\left(A T_{c}+B T_{m}\\right)+k L T_{c}.\n$$\n\nWe require $T_{2}T_{1}$:\n$$\nn \\log_{2}(n)\\left(A T_{c}+B T_{m}\\right)+k L T_{c}k n T_{c}.\n$$\nRearranging,\n$$\nk T_{c}(n-L)n \\log_{2}(n)\\left(A T_{c}+B T_{m}\\right).\n$$\nFor $n \\ge 3$, we have $n-L0$, and $T_{c}0$, so dividing yields\n$$\nk\\frac{n \\log_{2}(n)\\left(A T_{c}+B T_{m}\\right)}{T_{c}(n-L)}\n=\\frac{n \\log_{2}(n)}{n-L}\\left(A+B \\frac{T_{m}}{T_{c}}\\right).\n$$\nTherefore, the smallest integer $k$ satisfying the strict inequality is\n$$\nk_{\\min}=\\left\\lfloor \\frac{n \\log_{2}(n)}{n-\\left(\\lfloor \\log_{2}(n) \\rfloor +1\\right)}\\left(A+B \\frac{T_{m}}{T_{c}}\\right)\\right\\rfloor +1.\n$$", "answer": "$$\\boxed{\\left\\lfloor \\frac{n \\log_{2}(n)}{\\,n-\\left(\\lfloor \\log_{2}(n) \\rfloor +1\\right)\\,}\\left(A+B \\frac{T_{m}}{T_{c}}\\right)\\right\\rfloor +1}$$", "id": "1398631"}]}