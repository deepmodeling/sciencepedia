{"hands_on_practices": [{"introduction": "To truly grasp why the Halting Problem is undecidable, it is incredibly insightful to first examine a scenario where it becomes solvable. This exercise challenges you to consider a Turing Machine with a strictly finite tape, effectively limiting its memory. By determining the total number of unique configurations this machine can possibly be in, you will discover a hard upper bound on its runtime, providing a clear method for deciding whether it halts or enters an infinite loop [@problem_id:1408272]. This practice builds a foundational understanding of how a machine's potential for infinite states is central to the problem of undecidability.", "problem": "Consider a theoretical computing model called a Finite-Tape Turing Machine (FTTM). An FTTM is defined by a finite set of internal states, $Q$, with a size of $|Q| = s$; a finite tape alphabet, $\\Gamma$, with a size of $|\\Gamma| = k$ symbols; and a tape that is strictly finite, consisting of a fixed number of cells, $n$. The machine has a single tape head that can read or write one symbol at a time and move left or right, but it cannot move off the tape. The machine's behavior is governed by a deterministic transition function.\n\nA complete \"configuration\" of the FTTM at any moment is defined by its current internal state, the position of its tape head, and the entire sequence of symbols written on its tape. Since the number of possible configurations is finite, any FTTM that does not halt must eventually repeat a configuration, entering an infinite loop. This implies that the halting problem for any FTTM is decidable.\n\nGiven an FTTM with $s$ states, a tape of length $n$, and an alphabet of $k$ symbols, what is the maximum number of distinct configurations possible? This value also represents the maximum number of computational steps after which we can definitively decide whether the machine halts or loops, by simply simulating it and checking if it has halted yet.\n\nSelect the correct expression for this maximum number of steps.\n\nA. $s \\cdot n \\cdot k^{n}$\n\nB. $s + n + k$\n\nC. $k^{s \\cdot n}$\n\nD. $s \\cdot k \\cdot n$\n\nE. $n \\cdot s^{k}$\n\nF. $(s \\cdot k)^{n}$", "solution": "A complete configuration is specified by:\n- the internal state $q \\in Q$ with $|Q|=s$,\n- the head position $i$ on a tape of length $n$ (so $n$ possible positions),\n- the full tape contents, which is a word of length $n$ over the alphabet $\\Gamma$ with $|\\Gamma|=k$, hence $k^{n}$ possibilities.\n\nBy the product rule of counting, the total number of distinct configurations is\n$$\nN=\\underbrace{s}_{\\text{state}}\\cdot\\underbrace{n}_{\\text{head position}}\\cdot\\underbrace{k^{n}}_{\\text{tape contents}}=s\\cdot n\\cdot k^{n}.\n$$\n\nBecause the transition function is deterministic and there are only $N$ configurations, by the pigeonhole principle, after $N$ steps a configuration must repeat unless the machine has halted earlier. Therefore, simulating for at most $N$ steps suffices to decide halting versus looping. Among the given options, this matches option A: $s \\cdot n \\cdot k^{n}$.", "answer": "$$\\boxed{A}$$", "id": "1408272"}, {"introduction": "Continuing our exploration of limits, this next problem shifts the focus from constrained space to constrained time. Instead of asking if a Turing Machine will *ever* halt, we pose a more bounded question: does it halt within a specific number of steps, $k$? This scenario invites you to devise a straightforward simulation algorithm that can always provide a definite \"yes\" or \"no\" answer in a finite amount of time [@problem_id:1457071]. This practice reinforces the idea that the undecidability of the Halting Problem stems directly from the unbounded nature of computation.", "problem": "In the study of computability theory, a central concept is the Turing Machine (TM), a mathematical model of computation. A standard one-tape deterministic Turing Machine is formally defined by its set of states, its input and tape alphabets, a transition function, a start state, an accept state, and a reject state. A TM \"halts\" on a given input string if its computation eventually enters either the accept state or the reject state.\n\nThe famous halting problem asks whether a given TM $M$ will halt on a given input string $w$. The language corresponding to this problem, often denoted $A_{TM} = \\{\\langle M, w \\rangle \\mid M \\text{ is a TM and } M \\text{ halts on input } w \\}$, is known to be undecidable.\n\nConsider a modified version of this problem. Let's define a new language, $HALT_{\\text{bounded}}$, as the set of all triples $\\langle M, w, k \\rangle$ such that $M$ is a TM, $w$ is an input string, and $M$ halts on input $w$ in at most $k$ steps of computation. Here, $k$ is a non-negative integer represented in unary (e.g., the number 3 is represented as the string '111').\n\nWhich of the following statements correctly classifies the language $HALT_{\\text{bounded}}$?\n\nA. $HALT_{\\text{bounded}}$ is decidable.\n\nB. $HALT_{\\text{bounded}}$ is undecidable, but it is Turing-recognizable.\n\nC. $HALT_{\\text{bounded}}$ is not Turing-recognizable.\n\nD. The decidability of $HALT_{\\text{bounded}}$ is an open problem in theoretical computer science.\n\nE. $HALT_{\\text{bounded}}$ is decidable if and only if the Turing Machine $M$ has only a single state besides the halt states.", "solution": "We are given the language $HALT_{\\text{bounded}} = \\{\\langle M, w, k \\rangle \\mid \\text{$M$ halts on input $w$ in at most $k$ steps}\\}$ where $k$ is encoded in unary. We need to classify its decidability status.\n\nKey principle: A Turing machine can be simulated step-by-step by a universal Turing machine. For any Turing machine $M$, input $w$, and integer $k \\geq 0$, one can explicitly simulate the first $k$ steps of $M$ on $w$. This simulation is effective because the transition function of $M$ is finite and computable, so each simulated step is a mechanical application of the transition rule to the current configuration.\n\nAlgorithm (decider) construction:\n- On input $\\langle M, w, k \\rangle$, parse $k$ from its unary representation to obtain the integer value, which we denote by $|k|$ (the number of $1$ symbols).\n- Initialize a simulated configuration $C_{0}$ as the start configuration of $M$ on input $w$.\n- For $t$ from $1$ to $|k|$ do:\n  - If the current configuration $C_{t-1}$ is in an accept or reject state of $M$, then halt and accept (since $M$ halts within at most $t-1 \\leq |k|$ steps).\n  - Otherwise, compute the next configuration $C_{t}$ by applying the transition function of $M$ to $C_{t-1}$.\n- After completing the loop (i.e., after simulating exactly $|k|$ steps without entering a halting state), if no accept or reject state has been reached, halt and reject.\n\nTermination: The above machine always halts because it executes a loop of exactly $|k|$ iterations and performs a finite, effective computation in each iteration. Therefore, it is a decider.\n\nCorrectness:\n- Soundness: If the algorithm accepts, then at some iteration $t \\leq |k|$ it observed that $M$ had entered an accept or reject state on $w$, which means $M$ halts on $w$ within at most $k$ steps. Thus, $\\langle M, w, k \\rangle \\in HALT_{\\text{bounded}}$.\n- Completeness: If $\\langle M, w, k \\rangle \\in HALT_{\\text{bounded}}$, then there exists $t \\leq k$ such that $M$ halts on $w$ in exactly $t$ steps. The simulation will detect this at or before the $t$-th iteration and accept.\n\nTherefore, $HALT_{\\text{bounded}}$ is decidable. The unary encoding of $k$ ensures that this decider runs in time at most polynomial in the input length, but even if $k$ were encoded in binary, the above decider would still terminate (albeit possibly requiring time exponential in the length of $k$), so decidability holds regardless of the encoding. Consequently, the correct classification is that the language is decidable, making options stating undecidability or non-recognizability false, and it is not an open problem. The additional condition in option E is unnecessary for decidability.\n\nHence the correct choice is A.", "answer": "$$\\boxed{A}$$", "id": "1457071"}, {"introduction": "After establishing that the general Halting Problem is undecidable, we can leverage this fundamental truth as a powerful analytical tool. This exercise demonstrates how to classify a new, but related, computational problem: deciding whether a given machine halts on two distinct inputs, '0' and '1'. The key skill you will practice here is logical reduction, a cornerstone of complexity theory, where you prove a new problem is undecidable by showing that a solution for it would imply a solution for the original Halting Problemâ€”a known impossibility [@problem_id:1457099].", "problem": "In the theory of computation, we study the fundamental capabilities and limitations of abstract computing machines. A Turing Machine (TM) is a primary model of such a machine, which manipulates symbols on a strip of tape according to a table of rules. For any given TM and an input string, the machine will either eventually halt (by entering an accepting or rejecting state) or loop forever.\n\nA language is a set of strings. A language $L$ is said to be **decidable** (or recursive) if there exists a TM, called a decider, that for any given input string, will always halt and correctly determine whether the string belongs to $L$. A language $L$ is **recognizable** (or recursively enumerable) if there exists a TM that will halt and accept any string that is in $L$, but for strings not in $L$, it might halt and reject, or it might loop forever.\n\nConsider the following language, which we will call $L_{DH}$ (for Dual Halting):\n$$L_{DH} = \\{ \\langle M \\rangle \\mid M \\text{ is a Turing Machine that halts on input '0' and also halts on input '1'} \\}$$\nHere, $\\langle M \\rangle$ denotes the string encoding of a Turing Machine $M$.\n\nWhich of the following statements correctly classifies the language $L_{DH}$?\n\nA. $L_{DH}$ is decidable.\n\nB. $L_{DH}$ is recognizable, but not decidable.\n\nC. $L_{DH}$ is not recognizable, but its complement $\\overline{L_{DH}}$ is recognizable (i.e., $L_{DH}$ is co-recognizable but not decidable).\n\nD. $L_{DH}$ is neither recognizable nor co-recognizable.", "solution": "We analyze $L_{DH}$ via standard halting-problem constructions.\n\nFirst, define for each fixed input symbol $x \\in \\{0,1\\}$ the language\n$$\nH_{x}=\\{\\langle M \\rangle \\mid M \\text{ halts on input } x\\}.\n$$\nIt is well known that $H_{x}$ is recognizable: a recognizer simulates $M$ on input $x$ step by step and accepts exactly if the simulation halts. Formally, let $R_{x}$ be the Turing machine that, on input $\\langle M \\rangle$, simulates $M(x)$; if $M(x)$ halts, $R_{x}$ accepts; otherwise it runs forever. Therefore $H_{x}$ is recognizable.\n\nObserve that\n$$\nL_{DH}=H_{0} \\cap H_{1}.\n$$\nRecognizable languages are closed under intersection. To see this explicitly, given recognizers $R_{0}$ for $H_{0}$ and $R_{1}$ for $H_{1}$, build a recognizer $R$ for $L_{DH}$ that on input $\\langle M \\rangle$ dovetails the simulations of $R_{0}$ on $\\langle M \\rangle$ and $R_{1}$ on $\\langle M \\rangle$ (for example, at stage $t$ simulate $t$ steps of each). If both simulations accept, then $R$ accepts. If either never accepts, $R$ may run forever. Hence $L_{DH}$ is recognizable.\n\nNext, we show $L_{DH}$ is not decidable. We reduce the fixed-input halting problem $H_{0}$ to $L_{DH}$. Define a computable mapping $f$ on encodings of Turing machines as follows: on input $\\langle M \\rangle$, construct a machine $M'$ that\n- on input $0$, simulates $M$ on input $0$ and halts iff $M$ halts on $0$;\n- on input $1$, immediately halts (for instance, accepts in one step).\nThis construction is effective, so $f$ is a mapping reduction. By construction,\n$$\n\\langle M \\rangle \\in H_{0} \\iff \\langle M' \\rangle \\in L_{DH}.\n$$\nTherefore $H_{0} \\leq_{m} L_{DH}$. Since $H_{0}$ is undecidable (this follows from the undecidability of the general halting problem by the standard encoding: given $\\langle N,w \\rangle$, construct $M_{N,w}$ that ignores its input and simulates $N$ on $w$, yielding $\\langle N,w \\rangle \\in H \\iff \\langle M_{N,w} \\rangle \\in H_{0}$), it follows that $L_{DH}$ cannot be decidable.\n\nFinally, we show that $\\overline{L_{DH}}$ is not recognizable. Using the same mapping $f$ as above, note that\n$$\n\\langle M \\rangle \\in \\overline{H_{0}} \\iff \\langle M' \\rangle \\in \\overline{L_{DH}}.\n$$\nThus $\\overline{H_{0}} \\leq_{m} \\overline{L_{DH}}$. Since $\\overline{H_{0}}$ is not recognizable (the complement of the halting problem on a fixed input is not recognizable), it follows that $\\overline{L_{DH}}$ is not recognizable. Hence $L_{DH}$ is not co-recognizable.\n\nCombining these facts, $L_{DH}$ is recognizable but not decidable, and its complement is not recognizable. Among the options, this is exactly option B.", "answer": "$$\\boxed{B}$$", "id": "1457099"}]}