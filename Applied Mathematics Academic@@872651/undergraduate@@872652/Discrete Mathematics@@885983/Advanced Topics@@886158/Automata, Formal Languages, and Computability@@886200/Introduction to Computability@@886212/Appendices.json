{"hands_on_practices": [{"introduction": "The Turing Machine is the bedrock of computability theory, yet its abstract definition can feel distant. To truly grasp concepts like decidability, we must first understand how these machines operate at a fundamental level. This practice problem [@problem_id:1377268] invites you to perform a hands-on simulation, tracing the step-by-step execution of a specific Turing Machine to see how its simple rules lead to complex computational behavior.", "problem": "A Turing Machine (TM) is a theoretical model of computation that operates on an infinite tape divided into cells. It is formally defined by a set of states, an alphabet of symbols, and a transition function. The transition function, $\\delta(q, \\gamma)$, dictates the machine's next action based on its current state $q$ and the symbol $\\gamma$ it reads from the tape. The action consists of transitioning to a new state $q'$, writing a new symbol $\\gamma'$ on the tape, and moving the tape head one position to the Left (L) or Right (R).\n\nConsider a specific Turing Machine defined as follows:\n- State set $Q = \\{q_s, q_{f0}, q_{f1}, q_r, q_a, q_{rej}\\}$\n- Start state: $q_s$\n- Halting (accepting) state: $q_a$\n- Halting (rejecting) state: $q_{rej}$\n- Input alphabet $\\Sigma = \\{0, 1\\}$\n- Tape alphabet $\\Gamma = \\{0, 1, X, \\sqcup\\}$, where $\\sqcup$ is the blank symbol.\n- The transition function $\\delta: Q \\times \\Gamma \\to Q \\times \\Gamma \\times \\{L, R\\}$ is defined by the following rules:\n    1.  $\\delta(q_s, 0) = (q_{f0}, X, R)$\n    2.  $\\delta(q_s, 1) = (q_{f1}, X, R)$\n    3.  $\\delta(q_s, X) = (q_s, X, R)$\n    4.  $\\delta(q_s, \\sqcup) = (q_a, \\sqcup, R)$\n    5.  $\\delta(q_{f0}, 0) = (q_{f0}, 0, R)$\n    6.  $\\delta(q_{f0}, 1) = (q_r, X, L)$\n    7.  $\\delta(q_{f0}, X) = (q_{f0}, X, R)$\n    8.  $\\delta(q_{f0}, \\sqcup) = (q_{rej}, \\sqcup, R)$\n    9.  $\\delta(q_{f1}, 0) = (q_r, X, L)$\n    10. $\\delta(q_{f1}, 1) = (q_{f1}, 1, R)$\n    11. $\\delta(q_{f1}, X) = (q_{f1}, X, R)$\n    12. $\\delta(q_{f1}, \\sqcup) = (q_{rej}, \\sqcup, R)$\n    13. $\\delta(q_r, 0) = (q_r, 0, L)$\n    14. $\\delta(q_r, 1) = (q_r, 1, L)$\n    15. $\\delta(q_r, X) = (q_r, X, L)$\n    16. $\\delta(q_r, \\sqcup) = (q_s, \\sqcup, R)$\n\nA machine configuration can be described by its current state, the contents of the tape, and the position of the head. Initially, the tape contains the input string `1010` starting at cell 1, and all other cells (to the left at index $\\leq 0$ and to the right at index $\\geq 5$) contain the blank symbol $\\sqcup$. The machine starts in state $q_s$ with its head positioned on cell 1.\n\nThe machine halts when it enters either the state $q_a$ or $q_{rej}$. Calculate the total number of steps (i.e., applications of the transition function) the machine takes before it halts.", "solution": "We simulate the Turing Machine step by step, counting each application of the transition function as one step. We label tape cells by integers, with the input occupying cells $1$ through $4$ and blanks elsewhere. Initially, the tape has $\\sqcup$ at cell $0$, then $1,0,1,0$ at cells $1,2,3,4$, and $\\sqcup$ at cell $5$. The head starts at cell $1$ in state $q_{s}$.\n\nStep 1: State $q_{s}$, head at cell $1$, reads $1$. Apply rule $2$: $\\delta(q_{s},1)=(q_{f1},X,R)$. Write $X$ at cell $1$, move to cell $2$, state $q_{f1}$.\n\nStep 2: State $q_{f1}$, head at cell $2$, reads $0$. Apply rule $9$: $\\delta(q_{f1},0)=(q_{r},X,L)$. Write $X$ at cell $2$, move to cell $1$, state $q_{r}$.\n\nStep 3: State $q_{r}$, head at cell $1$, reads $X$. Apply rule $15$: $\\delta(q_{r},X)=(q_{r},X,L)$. Move to cell $0$, state $q_{r}$.\n\nStep 4: State $q_{r}$, head at cell $0$, reads $\\sqcup$. Apply rule $16$: $\\delta(q_{r},\\sqcup)=(q_{s},\\sqcup,R)$. Move to cell $1$, state $q_{s}$.\n\nStep 5: State $q_{s}$, head at cell $1$, reads $X$. Apply rule $3$: $\\delta(q_{s},X)=(q_{s},X,R)$. Move to cell $2$, state $q_{s}$.\n\nStep 6: State $q_{s}$, head at cell $2$, reads $X$. Apply rule $3$: move to cell $3$, state $q_{s}$.\n\nStep 7: State $q_{s}$, head at cell $3$, reads $1$. Apply rule $2$: $\\delta(q_{s},1)=(q_{f1},X,R)$. Write $X$ at cell $3$, move to cell $4$, state $q_{f1}$.\n\nStep 8: State $q_{f1}$, head at cell $4$, reads $0$. Apply rule $9$: $\\delta(q_{f1},0)=(q_{r},X,L)$. Write $X$ at cell $4$, move to cell $3$, state $q_{r}$.\n\nStep 9: State $q_{r}$, head at cell $3$, reads $X$. Apply rule $15$: move to cell $2$, state $q_{r}$.\n\nStep 10: State $q_{r}$, head at cell $2$, reads $X$. Apply rule $15$: move to cell $1$, state $q_{r}$.\n\nStep 11: State $q_{r}$, head at cell $1$, reads $X$. Apply rule $15$: move to cell $0$, state $q_{r}$.\n\nStep 12: State $q_{r}$, head at cell $0$, reads $\\sqcup$. Apply rule $16$: move to cell $1$, state $q_{s}$.\n\nStep 13: State $q_{s}$, head at cell $1$, reads $X$. Apply rule $3$: move to cell $2$, state $q_{s}$.\n\nStep 14: State $q_{s}$, head at cell $2$, reads $X$. Apply rule $3$: move to cell $3$, state $q_{s}$.\n\nStep 15: State $q_{s}$, head at cell $3$, reads $X$. Apply rule $3$: move to cell $4$, state $q_{s}$.\n\nStep 16: State $q_{s}$, head at cell $4$, reads $X$. Apply rule $3$: move to cell $5$, state $q_{s}$.\n\nStep 17: State $q_{s}$, head at cell $5$, reads $\\sqcup$. Apply rule $4$: $\\delta(q_{s},\\sqcup)=(q_{a},\\sqcup,R)$. Enter halting state $q_{a}$.\n\nThe machine halts after exactly $17$ steps.", "answer": "$$\\boxed{17}$$", "id": "1377268"}, {"introduction": "One of the most profound results in computer science is the undecidability of the Halting Problem, which states that no single algorithm can determine if *any* given program will finish or run forever. This exercise [@problem_id:1377286] explores a critical boundary to that rule by asking: what happens if we only care about halting within a fixed number of steps? By analyzing this bounded version of the problem, you will develop a key insight into the source of undecidability itself.", "problem": "In the theory of computation, we study the fundamental capabilities and limitations of machines. A Turing Machine (TM) is a mathematical model of a hypothetical computing device that manipulates symbols on a strip of tape according to a table of rules. The description of a Turing Machine, denoted as $\\langle M \\rangle$, is a finite string that encodes its states, alphabet, and transition function.\n\nA language is a set of strings. We say a language $L$ is **decidable** if there exists a special Turing Machine, called a decider, which for any given input string $w$, will always halt and correctly determine whether or not $w$ is in $L$. If a TM halts and enters a designated `accept` state, we say it accepts the input.\n\nConsider the following language, which we will call $L_{CyberGuard}$:\n$L_{CyberGuard} = \\{ \\langle M \\rangle \\mid M \\text{ is a TM that accepts its own description } \\langle M \\rangle \\text{ as input in at most 4096 steps} \\}$\n\nWhich of the following statements about the language $L_{CyberGuard}$ is correct?\n\nA. $L_{CyberGuard}$ is decidable.\n\nB. $L_{CyberGuard}$ is not decidable because it is equivalent to the Halting Problem, which is known to be undecidable.\n\nC. $L_{CyberGuard}$ is not decidable, but it is Turing-recognizable (also known as recursively enumerable).\n\nD. The decidability of $L_{CyberGuard}$ cannot be determined without knowing the specific encoding scheme used for $\\langle M \\rangle$.\n\nE. $L_{CyberGuard}$ is an empty language, because no Turing Machine can analyze its own code.", "solution": "We seek to determine the decidability of the language $L_{CyberGuard} = \\{ \\langle M \\rangle \\mid M \\text{ accepts } \\langle M \\rangle \\text{ in at most } 4096 \\text{ steps} \\}$.\n\nKey principle: For any fixed time bound $t \\in \\mathbb{N}$, the property “$M$ accepts $w$ within at most $t$ steps” is decidable. This follows because a universal simulator can emulate $M$ on $w$ for at most $t$ steps, which is a finite, effectively bounded computation. Therefore, the machine that performs this simulation and checks acceptance within the bound is a decider.\n\nConstruction of a decider $D$ for $L_{CyberGuard}$:\n- On input string $x$:\n  1. Check if $x$ is a valid encoding of some TM. If not, reject. This parsing check is decidable for any fixed effective encoding of TMs.\n  2. Let $x = \\langle M \\rangle$. Simulate $M$ on input $\\langle M \\rangle$ for at most $4096$ steps using a standard universal Turing Machine procedure. Maintain a counter $c$ initialized to $0$.\n  3. While $c < 4096$ and $M$ has not halted, perform one simulated transition and set $c := c + 1$.\n  4. If during this simulation $M$ enters the accept state before $c$ reaches $4096$, then accept; otherwise reject.\n\nTermination: The loop performs at most $4096$ iterations, and each simulated step is computable. Thus $D$ halts on all inputs, so $D$ is a decider.\n\nCorrectness: By construction, $D$ accepts exactly those encodings $\\langle M \\rangle$ such that $M$ accepts $\\langle M \\rangle$ within at most $4096$ steps, which is precisely $L_{CyberGuard}$.\n\nConsequences for the options:\n- A is correct: $L_{CyberGuard}$ is decidable by the decider $D$ above.\n- B is false: Unlike the Halting Problem (which is unbounded), here the time is bounded by a fixed constant, making the property decidable.\n- C is false: The language is not merely Turing-recognizable; it is decidable.\n- D is false: Decidability does not depend on the specific standard encoding beyond being an effective encoding; for any fixed effective encoding, the above decider works.\n- E is false: The language is not empty; for example, a TM that immediately accepts any input will accept its own description in fewer than $4096$ steps.\n\nTherefore, the correct statement is A.", "answer": "$$\\boxed{A}$$", "id": "1377286"}, {"introduction": "Computational problems are not monolithic; they fall into different classes based on their difficulty, such as \"decidable\" and \"Turing-recognizable\". This exercise [@problem_id:1377273] asks you to think like a systems architect, combining solutions for problems from different computability classes. By determining the properties of the intersection of a decidable and a Turing-recognizable language, you will practice constructing algorithms from smaller components and solidify your understanding of this crucial hierarchy.", "problem": "In the field of theoretical computer science, we classify problems based on the computational power required to solve them. A \"language\" is formally defined as a set of strings. We use Turing Machines as our model of computation.\n\nLet's define two important classes of languages:\n1.  A language $L$ is **decidable** if there exists a Turing Machine that, for any given input string $w$, will always halt and correctly determine whether $w$ is in $L$ or not. This type of Turing Machine is called a \"decider.\"\n2.  A language $L$ is **Turing-recognizable** if there exists a Turing Machine that, for any given input string $w$, will halt and accept if $w$ is in $L$. However, if $w$ is not in $L$, the machine might halt and reject, or it might loop forever. This type of Turing Machine is called a \"recognizer.\" Note that every decidable language is also Turing-recognizable, but the reverse is not always true.\n\nConsider a scenario at a cybersecurity firm that is developing an automated verification system for software drivers. The system checks each driver (represented as a string) against two distinct criteria:\n\n*   **Criterion A (Syntax and Type Safety):** A driver passes this check if it adheres to a strict set of syntactical and type-safety rules. A Turing Machine, $M_A$, has been built that can process any driver and is guaranteed to halt and report whether it passes this check or not. Let $L_A$ be the language of all drivers that satisfy Criterion A.\n\n*   **Criterion B (Security Vulnerability):** A driver passes this check if it can be proven to be free from a specific, complex type of zero-day vulnerability. A second Turing Machine, $M_B$, is used for this. If a driver is free from the vulnerability, $M_B$ will eventually halt and confirm it. However, if the driver *does* contain the vulnerability, the analysis is so complex that $M_B$ might run forever without providing a definitive answer. Let $L_B$ be the language of all drivers that satisfy Criterion B.\n\nThe firm is interested in the set of drivers that meet *both* criteria. Let this set be the language $L_{AB} = L_A \\cap L_B$. Based on the properties of the Turing Machines $M_A$ and $M_B$, what is the strongest correct statement that can be made about the language $L_{AB}$ for *any* such languages $L_A$ and $L_B$ that fit the descriptions?\n\nA. $L_{AB}$ is always decidable.\n\nB. $L_{AB}$ is always Turing-recognizable.\n\nC. $L_{AB}$ is not guaranteed to be Turing-recognizable.\n\nD. $L_{AB}$ is always co-Turing-recognizable (meaning its complement, $\\overline{L_{AB}}$, is Turing-recognizable).\n\nE. The computability of $L_{AB}$ cannot be determined without more specific information about the criteria.", "solution": "We are given that $L_A$ is decidable, so there exists a decider $M_A$ that halts on all inputs and accepts exactly the strings in $L_A$. Therefore $L_A$ is also Turing-recognizable. We are also given that $L_B$ is Turing-recognizable, witnessed by a recognizer $M_B$ that halts and accepts exactly the strings in $L_B$, and on strings not in $L_B$ may either reject or loop forever.\n\nWe analyze $L_{AB} = L_A \\cap L_B$ as follows.\n\nTo show that $L_{AB}$ is always Turing-recognizable, we construct a recognizer $M_{AB}$ for $L_{AB}$ using $M_A$ and $M_B$:\n- On input $w$, run $M_A$ on $w$. Since $M_A$ is a decider for $L_A$, it halts and either accepts or rejects.\n- If $M_A$ rejects, then reject $w$.\n- If $M_A$ accepts, simulate $M_B$ on $w$ and accept if and when $M_B$ accepts. If $M_B$ never accepts, do not halt.\n\nCorrectness of $M_{AB}$:\n- If $w \\in L_A \\cap L_B$, then $M_A$ accepts $w$, and $M_B$ accepts $w$, so $M_{AB}$ accepts $w$.\n- If $w \\notin L_A \\cap L_B$, then either $w \\notin L_A$, in which case $M_A$ rejects and $M_{AB}$ rejects, or $w \\in L_A$ but $w \\notin L_B$, in which case $M_B$ never accepts and $M_{AB}$ need not halt. This behavior satisfies the definition of a Turing recognizer for $L_{AB}$.\n\nTherefore, $L_{AB}$ is always Turing-recognizable.\n\nNext, we show that $L_{AB}$ need not be decidable, nor co-Turing-recognizable. Let $\\Sigma$ be any fixed finite alphabet and take $L_A = \\Sigma^{*}$, which is decidable by a machine that accepts all inputs. Let $L_B = A_{TM}$, the acceptance language from the main text, which is known to be Turing-recognizable but not decidable. Its complement, $\\overline{A_{TM}}$, is not Turing-recognizable. Then\n$$\nL_{AB} \\;=\\; L_A \\cap L_B \\;=\\; \\Sigma^{*} \\cap A_{TM} \\;=\\; A_{TM},\n$$\nso $L_{AB}$ is not decidable and not co-Turing-recognizable in this example. Hence statements asserting decidability or co-Turing-recognizability in general are false, and it is not the case that recognizability cannot be determined, since we have shown it always holds.\n\nThus, the strongest correct general statement is that $L_{AB}$ is always Turing-recognizable.", "answer": "$$\\boxed{B}$$", "id": "1377273"}]}