{"hands_on_practices": [{"introduction": "Before diving into the complexities of proving a problem is NP-complete, it is essential to have a firm grasp of the canonical NP-complete problem: 3-Satisfiability (3-SAT). This exercise focuses on the fundamental mechanics of evaluating a formula in 3-Conjunctive Normal Form (3-CNF). By manually checking which clauses are satisfied by a given truth assignment, you will build a concrete intuition for the problem that algorithms for 3-SAT must solve [@problem_id:1410968].", "problem": "In computational complexity theory, the Boolean Satisfiability Problem (SAT) is a foundational problem. A common variant is 3-Satisfiability (3-SAT). A boolean formula is in 3-Conjunctive Normal Form (3-CNF) if it is a conjunction of clauses, where each clause is a disjunction of exactly three literals. A literal is a boolean variable or its negation. We use the symbol $\\land$ to denote logical AND (conjunction), $\\lor$ to denote logical OR (disjunction), and $\\neg$ to denote logical NOT (negation).\n\nConsider a 3-CNF formula $\\phi$ defined over a set of four boolean variables $\\{x_1, x_2, x_3, x_4\\}$. The formula $\\phi$ is given by the conjunction of the following five clauses:\n$C_1 = (\\neg x_1 \\lor x_2 \\lor \\neg x_3)$\n$C_2 = (\\neg x_1 \\lor x_2 \\lor x_4)$\n$C_3 = (x_1 \\lor x_2 \\lor x_3)$\n$C_4 = (\\neg x_2 \\lor \\neg x_3 \\lor x_4)$\n$C_5 = (x_3 \\lor \\neg x_4 \\lor x_2)$\n\nSo, the full formula is $\\phi = C_1 \\land C_2 \\land C_3 \\land C_4 \\land C_5$.\n\nA clause is said to be satisfied by a truth assignment if at least one of its literals evaluates to True under that assignment. The entire formula $\\phi$ is satisfied only if all its clauses are satisfied.\n\nYou are given the following truth assignment $A$:\n$x_1 = \\text{True}$\n$x_2 = \\text{False}$\n$x_3 = \\text{True}$\n$x_4 = \\text{False}$\n\nDetermine the total number of clauses in the formula $\\phi$ that are satisfied by the truth assignment $A$.", "solution": "A clause in a 3-CNF formula is satisfied if at least one of its literals evaluates to $\\text{True}$. The logical disjunction $\\lor$ evaluates to $\\text{True}$ if at least one operand is $\\text{True}$, and the negation satisfies $\\neg \\text{True} = \\text{False}$ and $\\neg \\text{False} = \\text{True}$. Under the assignment $A$ with $x_1 = \\text{True}$, $x_2 = \\text{False}$, $x_3 = \\text{True}$, and $x_4 = \\text{False}$, we first compute the needed negations: $\\neg x_1 = \\text{False}$, $\\neg x_2 = \\text{True}$, $\\neg x_3 = \\text{False}$, $\\neg x_4 = \\text{True}$.\n\nEvaluate each clause:\n$$C_1 = (\\neg x_1 \\lor x_2 \\lor \\neg x_3) = (\\text{False} \\lor \\text{False} \\lor \\text{False}) = \\text{False},$$\n$$C_2 = (\\neg x_1 \\lor x_2 \\lor x_4) = (\\text{False} \\lor \\text{False} \\lor \\text{False}) = \\text{False},$$\n$$C_3 = (x_1 \\lor x_2 \\lor x_3) = (\\text{True} \\lor \\text{False} \\lor \\text{True}) = \\text{True},$$\n$$C_4 = (\\neg x_2 \\lor \\neg x_3 \\lor x_4) = (\\text{True} \\lor \\text{False} \\lor \\text{False}) = \\text{True},$$\n$$C_5 = (x_3 \\lor \\neg x_4 \\lor x_2) = (\\text{True} \\lor \\text{True} \\lor \\text{False}) = \\text{True}.$$\n\nThus, exactly three clauses, $C_3$, $C_4$, and $C_5$, are satisfied by $A$.", "answer": "$$\\boxed{3}$$", "id": "1410968"}, {"introduction": "Proving a problem is NP-complete involves showing it is both in NP and is NP-hard. The NP-hard property is typically established via a polynomial-time reduction from a known NP-complete problem. This thought experiment [@problem_id:1388452] challenges you to critically analyze a proposed proof and identify a subtle but fatal flaw in its logic. Mastering this concept is crucial, as the direction of a reduction determines what you can conclude about a problem's complexity.", "problem": "A political consulting firm is analyzing the computational complexity of two key strategic planning problems: Campaign Staffing (CS) and Message Control (MC).\n\nThe **Campaign Staffing (CS)** problem is defined as follows:\n- Given a set $P$ of $n$ potential campaign projects, a list $C$ of pairs of projects that are incompatible with each other, and an integer $k$.\n- Question: Is it possible to select a subset of projects $P' \\subseteq P$ of size at least $k$ such that no two projects in $P'$ are incompatible?\n\nThe **Message Control (MC)** problem is defined as follows:\n- Given a set $T$ of topics for a political debate, a list $L$ of \"risky pairs\" of topics, and an integer $j$.\n- Question: Is it possible to select a subset of topics $T' \\subseteq T$ of size at most $j$ such that for every risky pair in $L$, at least one of the topics in the pair is a member of $T'$?\n\nThe firm's lead theoretician has already established that the Message Control (MC) problem is NP-complete.\n\nA junior analyst is tasked with determining the complexity of the Campaign Staffing (CS) problem. The analyst claims that CS is also NP-complete. To justify this, they propose the following polynomial-time transformation from an arbitrary instance of CS to an instance of MC:\n\n1.  Given a CS instance with $n$ projects $P$, incompatibilities $C$, and an integer $k$.\n2.  Create an MC instance where the set of topics $T$ is identical to the set of projects $P$.\n3.  The list of risky pairs $L$ is identical to the list of incompatibilities $C$.\n4.  The integer for the MC instance is set to $j = n - k$.\n\nThe analyst correctly argues that the original CS instance has a \"yes\" answer if and only if this newly constructed MC instance also has a \"yes\" answer. Based on this transformation, the analyst concludes their proof is complete.\n\nAssuming the analyst's argument for the equivalence of the solutions is correct, which of the following statements accurately describes the analyst's contribution?\n\nA. The analyst has correctly proven that CS is NP-complete.\n\nB. The analyst has proven that CS is in NP, but not that it is NP-hard.\n\nC. The analyst has proven that if CS is in NP, then CS is NP-complete.\n\nD. The analyst has shown a reduction in the wrong direction; this transformation does not help prove that CS is NP-complete.\n\nE. The analyst has proven that CS can be solved in polynomial time.", "solution": "To determine the validity of the analyst's conclusion, we must understand the requirements for proving a problem is NP-complete. A problem $X$ is NP-complete if it satisfies two conditions:\n1.  $X$ is in the complexity class NP (Nondeterministic Polynomial time). This means that a proposed solution to an instance of $X$ can be verified for correctness in polynomial time.\n2.  $X$ is NP-hard. This means that every problem in NP can be reduced to $X$ in polynomial time.\n\nIn practice, to prove a problem $X$ is NP-hard, we don't reduce every problem in NP to it. Instead, we take a single, known NP-complete problem, let's call it $Y$, and show that $Y$ can be reduced to $X$ in polynomial time. This is denoted as $Y \\le_p X$. A polynomial-time reduction from $Y$ to $X$ is an algorithm that transforms any instance of $Y$ into an instance of $X$ in polynomial time, such that the original $Y$ instance is a \"yes\" instance if and only if the transformed $X$ instance is a \"yes\" instance. This shows that $X$ is at least as hard as $Y$. Since $Y$ is NP-hard (hard for all of NP), $X$ must also be NP-hard.\n\nIn this problem, the two problems are Campaign Staffing (CS) and Message Control (MC). We are given that MC is NP-complete. The analyst wants to prove that CS is NP-complete. To do this, they would need to show that:\n1.  CS is in NP.\n2.  CS is NP-hard.\n\nTo prove CS is NP-hard, the analyst should have taken the known NP-complete problem, MC, and shown a reduction MC $\\le_p$ CS.\n\nHowever, the analyst did the opposite. They created a reduction from CS to MC, which is written as CS $\\le_p$ MC. The analyst showed that any instance of CS can be transformed into an instance of MC in polynomial time.\n\nWhat does the reduction CS $\\le_p$ MC tell us? It means that if we had a polynomial-time algorithm to solve MC, we could use it to solve CS in polynomial time. Since MC is NP-complete, it is believed that no such polynomial-time algorithm exists. This reduction places an upper bound on the difficulty of CS relative to MC; it shows that CS is \"no harder than\" MC. It does not provide a lower bound on the difficulty of CS. Proving NP-hardness requires showing that a problem is at least as hard as a known NP-hard problem.\n\nTherefore, the analyst's reduction is in the \"wrong direction\" for the purpose of proving that CS is NP-hard. The transformation they constructed does not contribute to a proof of the NP-completeness of CS.\n\nLet's evaluate the given options:\nA. The analyst has correctly proven that CS is NP-complete. This is false. The reduction is in the wrong direction to prove NP-hardness.\nB. The analyst has proven that CS is in NP, but not that it is NP-hard. The analyst's transformation does not address whether CS is in NP. (Note: CS *is* in NP because one can easily check if a given set of $k$ projects has any incompatibilities, but the analyst's work did not demonstrate this fact). The work also fails to prove NP-hardness.\nC. The analyst has proven that if CS is in NP, then CS is NP-complete. This is false. To be NP-complete, CS must also be proven NP-hard, which the analyst has not done.\nD. The analyst has shown a reduction in the wrong direction; this transformation does not help prove that CS is NP-complete. This is the correct statement. To prove CS is NP-complete, the analyst needed to reduce a known NP-complete problem *to* CS (e.g., MC $\\le_p$ CS), not the other way around.\nE. The analyst has proven that CS can be solved in polynomial time. This is false. The reduction only implies that CS is solvable in polynomial time *if* MC is, which is strongly believed to be false.\n\nThe analyst's fundamental error is misunderstanding the directionality of reductions required for NP-hardness proofs.", "answer": "$$\\boxed{D}$$", "id": "1388452"}, {"introduction": "A cornerstone of many NP-completeness proofs is the ability to transform an instance of one problem into an instance of another. A classic example is reducing the general Circuit-SAT or k-SAT problem to 3-SAT, which requires converting logical constraints into equivalent sets of 3-literal clauses. This practice [@problem_id:1410930] lets you apply the standard technique for this conversion, using auxiliary variables to preserve satisfiability while enforcing the required structure of a 3-CNF formula.", "problem": "In a computational complexity theory course, a student named Alex is studying the proof that 3-Satisfiability (3-SAT) is NP-complete. A key step in many related proofs is the reduction of a general k-Satisfiability problem to 3-SAT. This involves converting any clause with more than 3 literals into a set of clauses each having at most 3 literals, while preserving satisfiability.\n\nAlex considers a specific clause of size 4, $C = (x_1 \\lor x_2 \\lor x_3 \\lor \\neg x_4)$, where $x_1, x_2, x_3, x_4$ are Boolean variables. A literal is a variable or its negation. A clause is a disjunction (OR) of literals. A formula in Conjunctive Normal Form (CNF) is a conjunction (AND) of clauses. A formula is in 3-CNF if it is in CNF and every clause has exactly 3 literals.\n\nThe task is to find a new formula, $C'$, which is a conjunction of 3-literal clauses, such that $C'$ is satisfiable if and only if the original clause $C$ is satisfiable. This transformation can be achieved by introducing a new auxiliary Boolean variable, let's call it $z_1$.\n\nWhich of the following formulas is a correct transformation of $C$ into an equisatisfiable formula in CNF where each clause has 3 literals? Select all that apply.\n\nA. $(x_1 \\lor x_2 \\lor z_1) \\land (\\neg z_1 \\lor x_3 \\lor \\neg x_4)$\n\nB. $(x_1 \\lor x_2 \\lor z_1) \\land (\\neg z_1 \\lor x_3 \\lor x_4)$\n\nC. $(x_1 \\lor x_2 \\lor \\neg z_1) \\land (z_1 \\lor x_3 \\lor \\neg x_4)$\n\nD. $(x_1 \\lor z_1 \\lor \\neg z_1) \\land (x_2 \\lor x_3 \\lor \\neg x_4)$", "solution": "We need a 3-CNF formula $C'$ using a fresh variable $z_1$ such that, for every fixed assignment to the original variables $(x_1, x_2, x_3, x_4)$, the original clause $C = (x_1 \\lor x_2 \\lor x_3 \\lor \\neg x_4)$ is true if and only if there exists an assignment to $z_1$ making $C'$ true. This is the equisatisfiability condition required in standard reductions from $k$-SAT to $3$-SAT.\n\nWe verify each option.\n\nOption A: $C' = (x_1 \\lor x_2 \\lor z_1) \\land (\\neg z_1 \\lor x_3 \\lor \\neg x_4)$.\n- If $C$ is true:\n  - If $(x_1 \\lor x_2)$ is true, set $z_1 = \\text{False}$. Then the first clause becomes $(x_1 \\lor x_2 \\lor \\text{False}) = (x_1 \\lor x_2)$, which is true, and the second clause becomes $(\\text{True} \\lor x_3 \\lor \\neg x_4)$, which is true.\n  - If $(x_1 \\lor x_2)$ is false, then $(x_3 \\lor \\neg x_4)$ must be true. Set $z_1 = \\text{True}$. Then the first clause becomes $(x_1 \\lor x_2 \\lor \\text{True})$, which is true, and the second clause becomes $(\\text{False} \\lor x_3 \\lor \\neg x_4) = (x_3 \\lor \\neg x_4)$, which is true.\n  Hence if $C$ is true, there exists $z_1$ such that $C'$ is true.\n- Conversely, if $C'$ is true for some $z_1$:\n  - If $z_1 = \\text{False}$, then the first clause is $(x_1 \\lor x_2)$, so $(x_1 \\lor x_2)$ is true and $C$ is true.\n  - If $z_1 = \\text{True}$, then the second clause is $(x_3 \\lor \\neg x_4)$, so $(x_3 \\lor \\neg x_4)$ is true and $C$ is true.\nThus A is a correct equisatisfiable transformation.\n\nOption B: $C' = (x_1 \\lor x_2 \\lor z_1) \\land (\\neg z_1 \\lor x_3 \\lor x_4)$.\nConsider the assignment $x_1 = \\text{False}$, $x_2 = \\text{False}$, $x_3 = \\text{False}$, $x_4 = \\text{True}$. Then $C = (\\text{False} \\lor \\text{False} \\lor \\text{False} \\lor \\text{False}) = \\text{False}$. But $C'$ becomes $(\\text{False} \\lor \\text{False} \\lor z_1) \\land (\\neg z_1 \\lor \\text{False} \\lor \\text{True}) = z_1 \\land \\text{True}$, which is true by choosing $z_1 = \\text{True}$. Hence $C$ is false while $C'$ is satisfiable, so B is not equisatisfiable with $C$.\n\nOption C: $C' = (x_1 \\lor x_2 \\lor \\neg z_1) \\land (z_1 \\lor x_3 \\lor \\neg x_4)$.\n- If $C$ is true:\n  - If $(x_1 \\lor x_2)$ is true, set $z_1 = \\text{True}$. Then the first clause is $(x_1 \\lor x_2 \\lor \\text{False}) = (x_1 \\lor x_2)$, true, and the second clause is $(\\text{True} \\lor x_3 \\lor \\neg x_4)$, true.\n  - If $(x_1 \\lor x_2)$ is false, then $(x_3 \\lor \\neg x_4)$ must be true. Set $z_1 = \\text{False}$. Then the first clause is $(x_1 \\lor x_2 \\lor \\text{True})$, true, and the second clause is $(\\text{False} \\lor x_3 \\lor \\neg x_4) = (x_3 \\lor \\neg x_4)$, true.\n  Hence if $C$ is true, there exists $z_1$ such that $C'$ is true.\n- Conversely, if $C'$ is true for some $z_1$:\n  - If $z_1 = \\text{True}$, then the first clause reduces to $(x_1 \\lor x_2)$, so $C$ is true.\n  - If $z_1 = \\text{False}$, then the second clause reduces to $(x_3 \\lor \\neg x_4)$, so $C$ is true.\nThus C is a correct equisatisfiable transformation.\n\nOption D: $C' = (x_1 \\lor z_1 \\lor \\neg z_1) \\land (x_2 \\lor x_3 \\lor \\neg x_4)$.\nThe first clause is a tautology since $(z_1 \\lor \\neg z_1)$ is always true, so $C'$ is equivalent to $(x_2 \\lor x_3 \\lor \\neg x_4)$. Take $x_1 = \\text{True}$, $x_2 = \\text{False}$, $x_3 = \\text{False}$, $x_4 = \\text{True}$. Then $C = (\\text{True} \\lor \\text{False} \\lor \\text{False} \\lor \\text{False}) = \\text{True}$, but $C' = (\\text{False} \\lor \\text{False} \\lor \\text{False}) = \\text{False}$, regardless of $z_1$. Hence D is not equisatisfiable with $C$.\n\nTherefore, exactly options A and C are correct.", "answer": "$$\\boxed{AC}$$", "id": "1410930"}]}