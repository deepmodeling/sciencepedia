{
    "hands_on_practices": [
        {
            "introduction": "在解决任何反演问题之前，首要步骤是深入理解其正向模型。奇异值分解（Singular Value Decomposition, SVD）是一个强大的数学工具，它能够揭示将行星亮度分布映射到观测光变曲线的线性算符的内在结构和信息含量。通过这个练习，你将亲手构建一个简化的日食掩食映射场景下的一维正向算符，并利用SVD来评估问题的“有效秩”，从而理解我们能从数据中实际分辨出多少独立的亮度分量。",
            "id": "4159111",
            "problem": "考虑在次食期间观测到的热辐射系外行星的掩食测绘正演问题。假设行星各向同性地发光（无成束效应），并且在时间 $t$ 测得的通量是亮度分布 $g(x)$ 在投影行星盘面可见、未被遮挡部分上的视线积分。将行星的投影盘面建模为单位圆，并将亮度分布简化为沿凌日弦坐标 $x \\in [-1,1]$ 的一维函数。位于位置 $x$ 的纵向切片对观测通量的瞬时贡献由投影弦长加权，该弦长与 $\\sqrt{1-x^2}$ 成正比。\n\n对于入食，将掩食边界定义为 $x_{b}(t) = 1 - 2t$，其中无量纲时间 $t \\in [0,1]$，因此在时间 $t$ 的未被遮挡区域为 $\\{x \\in [-1,1] : x \\le x_{b}(t)\\}$。对于出食，定义 $x_{b}(t) = -1 + 2t$，其中 $t \\in [0,1]$，未被遮挡区域为 $\\{x \\in [-1,1] : x \\ge x_{b}(t)\\}$。将 $x$ 离散化为 $[-1,1]$ 上的 $N$ 个均匀间隔点 $x_i$，将时间 $t$ 离散化为 $T$ 个均匀间隔的中点 $t_j = \\frac{j+1/2}{T}$，其中 $j = 0,\\dots,T-1$。通过\n$$\nA_{j,i} = \\sqrt{1 - x_i^2}\\,\\mathbb{I}\\{x_i \\le x_b(t_j)\\}\\,\\Delta x,\n$$\n构建用于入食的线性正演算子 $A \\in \\mathbb{R}^{T \\times N}$，并通过\n$$\nA_{j,i} = \\sqrt{1 - x_i^2}\\,\\mathbb{I}\\{x_i \\ge x_b(t_j)\\}\\,\\Delta x,\n$$\n构建用于出食的算子，其中 $\\Delta x$ 是网格间距，$\\mathbb{I}\\{\\cdot\\}$ 是指示函数。对于入食+出食的组合情况，将入食和出食算子垂直堆叠以形成 $A \\in \\mathbb{R}^{(2T) \\times N}$。\n\n基于此构造，使用奇异值分解 (SVD) 来分析掩食测绘的实际分辨能力。对于给定的算子 $A$，计算其奇异值 $\\{s_k\\}_{k=1}^{r}$，其中对于单独的入食或出食情况，$r = \\min(T,N)$，对于组合情况，$r = \\min(2T,N)$。定义前 $K$ 个奇异模态捕获的累积能量分数为\n$$\nE(K) = \\frac{\\sum_{k=1}^{K} s_k^2}{\\sum_{k=1}^{r} s_k^2},\n$$\n该值等于 $A$ 的弗罗贝尼乌斯范数的平方中由其前 $K$ 个奇异值解释的部分。将 $E(K)$ 解释为模态指数 $K$ 的函数，以评估在收益递减出现之前，实际上有多少模态是可分辨的。\n\n您的程序必须根据上述规则构建 $A$（无用户输入），并为每个测试用例计算满足 $E(K_{0.9}) \\ge 0.9$ 的最小模态指数 $K_{0.9}$ 和满足 $E(K_{0.99}) \\ge 0.99$ 的最小模态指数 $K_{0.99}$。此问题中没有物理单位；所有量在构造上都是无量纲的。\n\n测试套件：\n- 用例 1（理想情况，入食）：$N=64, T=64$。\n- 用例 2（欠采样入食）：$N=64, T=8$。\n- 用例 3（出食对称性检验）：$N=64, T=64$。\n- 用例 4（组合入食+出食）：$N=64, T=64$（每个阶段），堆叠后产生 $A \\in \\mathbb{R}^{128 \\times 64}$。\n\n对于每个用例，计算 $K_{0.9}$ 和 $K_{0.99}$ 作为整数。您的程序应生成一行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，顺序为\n$$\n[K_{0.9}^{(1)},K_{0.99}^{(1)},K_{0.9}^{(2)},K_{0.99}^{(2)},K_{0.9}^{(3)},K_{0.99}^{(3)},K_{0.9}^{(4)},K_{0.99}^{(4)}],\n$$\n其中上标表示用例索引。所有中间计算必须遵循上述定义；最终输出是无单位的整数。",
            "solution": "用户提供了一个来自行星科学领域的问题，具体涉及使用掩食测绘分析系外行星的热亮度分布。任务是构建一个线性正演模型，将行星的一维亮度剖面映射到次食期间观测到的光变曲线，然后使用奇异值分解（SVD）分析该模型的分辨能力。\n\n### 问题验证\n\n**步骤 1：提取给定信息**\n\n*   **物理模型**：行星是一个热辐射、各向同性的源。观测到的通量是亮度分布 $g(x)$ 在投影盘面可见、未被遮挡部分上的视线积分。\n*   **几何模型**：投影的行星盘面是单位圆。亮度分布被简化为沿凌日弦坐标 $x \\in [-1,1]$ 的一维函数 $g(x)$。\n*   **通量加权**：位置 $x$ 处的切片对通量的贡献权重与投影弦长 $\\sqrt{1-x^2}$ 成正比。\n*   **时间与掩食动态**：\n    *   无量纲时间 $t \\in [0,1]$。\n    *   入食掩食边界：$x_{b}(t) = 1 - 2t$。未被遮挡区域：$\\{x \\in [-1,1] : x \\le x_{b}(t)\\}$。\n    *   出食掩食边界：$x_{b}(t) = -1 + 2t$。未被遮挡区域：$\\{x \\in [-1,1] : x \\ge x_{b}(t)\\}$。\n*   **离散化**：\n    *   空间坐标 $x$ 被离散化为 $[-1,1]$ 上的 $N$ 个均匀间隔点 $x_i$。\n    *   时间坐标 $t$ 被离散化为 $T$ 个均匀间隔的中点 $t_j = \\frac{j+1/2}{T}$，其中 $j = 0, \\dots, T-1$。\n*   **正演算子定义**：\n    *   $x$ 的网格间距为 $\\Delta x$。\n    *   指示函数为 $\\mathbb{I}\\{\\cdot\\}$。\n    *   入食算子 $A \\in \\mathbb{R}^{T \\times N}$: $A_{j,i} = \\sqrt{1 - x_i^2}\\,\\mathbb{I}\\{x_i \\le x_b(t_j)\\}\\,\\Delta x$。\n    *   出食算子 $A \\in \\mathbb{R}^{T \\times N}$: $A_{j,i} = \\sqrt{1 - x_i^2}\\,\\mathbb{I}\\{x_i \\ge x_b(t_j)\\}\\,\\Delta x$。\n    *   组合算子 $A \\in \\mathbb{R}^{(2T) \\times N}$：通过垂直堆叠入食和出食算子形成。\n*   **SVD 分析**：\n    *   $A$ 的奇异值：$\\{s_k\\}_{k=1}^{r}$，其中 $r = \\min(\\text{$A$ 的行数}, \\text{$A$ 的列数})$。\n    *   累积能量分数：$E(K) = \\frac{\\sum_{k=1}^{K} s_k^2}{\\sum_{k=1}^{r} s_k^2}$。\n*   **目标**：\n    *   找到满足 $E(K_{0.9}) \\ge 0.9$ 的最小整数模态指数 $K_{0.9}$。\n    *   找到满足 $E(K_{0.99}) \\ge 0.99$ 的最小整数模态指数 $K_{0.99}$。\n*   **测试套件**：\n    *   用例 1：入食，$N=64, T=64$。\n    *   用例 2：入食，$N=64, T=8$。\n    *   用例 3：出食，$N=64, T=64$。\n    *   用例 4：组合入食+出食，$N=64, T=64$（每个阶段）。\n\n**步骤 2：使用提取的给定信息进行验证**\n\n1.  **科学依据**：该问题是系外行星科学中一个公认且标准化的简化模型，用于介绍掩食测绘和相关反演问题的概念。将正演算子表述为加权积分，对于给定的假设在物理上是正确的。SVD 的使用是反演理论中分析此类问题信息含量和条件状况的基础技术。\n\n2.  **适定性**：该计算任务是适定的。所有参数、定义和离散化方案都已明确指定，从而为每个测试用例得出一个唯一的、可计算的数值结果。虽然底层的物理反演问题（从通量数据中恢复 $g(x)$）是不适定的，但这里的任务是分析正演算子本身，这是一个明确定义的数学过程。\n\n3.  **客观性**：问题以精确、客观的数学语言陈述。没有主观因素。\n\n4.  **未发现缺陷**：问题没有违反任何无效性标准。它在科学上是合理的（作为一个模型）、完整的、一致的，并且在计算上是可行的。该任务具有实质性，直接涉及不适定反演问题分析中的一个核心概念。\n\n**步骤 3：结论与行动**\n\n问题是**有效的**。将提供解决方案。\n\n### 解法\n\n该问题要求我们构建一个线性正演算子，表示为矩阵 $A$，该算子模拟在次食期间测量系外行星热通量的过程。然后，我们将使用奇异值分解（SVD）来评估可以从数据中可靠提取的独立信息量（或“模态”），这是衡量系统实际分辨能力的指标。\n\n**1. 域的离散化**\n行星亮度沿一维坐标 $x \\in [-1, 1]$ 建模。我们将此区间离散化为 $N$ 个均匀间隔的点 $\\{x_i\\}_{i=0}^{N-1}$。这些点可以通过 $x_i = -1 + i\\Delta x$ 生成，其中网格间距为 $\\Delta x = \\frac{2}{N-1}$。相应的空间坐标向量为 $\\mathbf{x} = [x_0, x_1, \\dots, x_{N-1}]$。\n\n观测时间 $t \\in [0, 1]$ 被离散化为 $T$ 个时间点，这些点取为 $T$ 个均匀间隔的中点。第 $j$ 个时间点是 $t_j = \\frac{j+1/2}{T}$，其中 $j=0, \\dots, T-1$。相应的观测时间向量为 $\\mathbf{t} = [t_0, t_1, \\dots, t_{T-1}]$。\n\n**2. 正演算子 A 的构造**\n将离散化的亮度分布向量 $\\mathbf{g} \\in \\mathbb{R}^{N}$ 与测得的通量向量 $\\mathbf{f} \\in \\mathbb{R}^{T}$ 关联起来的正演模型由线性方程 $\\mathbf{f} = A\\mathbf{g}$ 给出。矩阵 $A$ 包含了掩食的几何信息。元素 $A_{j,i}$ 表示空间位置 $x_i$ 处的亮度对时间 $t_j$ 测得的总通量的贡献。\n\n根据定义，元素 $A_{j,i}$ 是弦长加权因子 $\\sqrt{1 - x_i^2}$ 与一个指示函数的乘积，如果点 $x_i$ 在时间 $t_j$ 可见，则指示函数为 1，否则为 0，所有这些都由网格间距 $\\Delta x$ 进行缩放。\n\n对于**入食**事件，遮挡体从右向左移动。掩食边界位于 $x_b(t_j) = 1 - 2t_j$。如果一个点 $x_i$ 在边界的左侧，即 $x_i \\le x_b(t_j)$，则该点可见。矩阵元素为：\n$$\nA_{j,i}^{\\text{ingress}} = \\sqrt{1 - x_i^2} \\cdot \\mathbb{I}\\{x_i \\le 1 - 2t_j\\} \\cdot \\Delta x\n$$\n\n对于**出食**事件，遮挡体从左向右移动。边界位于 $x_b(t_j) = -1 + 2t_j$。如果一个点 $x_i$ 在边界的右侧，即 $x_i \\ge x_b(t_j)$，则该点可见。矩阵元素为：\n$$\nA_{j,i}^{\\text{egress}} = \\sqrt{1 - x_i^2} \\cdot \\mathbb{I}\\{x_i \\ge -1 + 2t_j\\} \\cdot \\Delta x\n$$\n\n对于**组合入食和出食**的情况，我们假设我们有来自两个阶段的测量数据。这会产生更多的信息。正演算子通过垂直堆叠入食和出食矩阵来构建。如果 $A_{\\text{ingress}}$ 和 $A_{\\text{egress}}$ 的大小都是 $T \\times N$，则组合算子 $A_{\\text{comb}}$ 的大小将是 $(2T) \\times N$：\n$$\nA_{\\text{comb}} = \\begin{pmatrix} A_{\\text{ingress}} \\\\ A_{\\text{egress}} \\end{pmatrix}\n$$\n\n**3. 通过奇异值分解（SVD）进行分析**\n矩阵 $A$ 的 SVD 是一种分解 $A = U S V^T$，其中 $U$ 和 $V$ 是正交矩阵，其列分别是左奇异向量和右奇异向量，而 $S$ 是一个包含按降序排列的奇异值 $\\{s_k\\}$ 的对角矩阵。非零奇异值的数量是矩阵的秩 $r$。\n\n奇异值量化了从输入空间（亮度图）到输出空间（光变曲线）相应模态的“放大”程度。奇异值的急剧下降表明问题是病态的；亮度图中的高频分量被高度衰减，因此很难从带噪声的数据中恢复。\n\n$A$ 的弗罗贝尼乌斯范数的平方，$\\|A\\|_F^2 = \\sum_{j,i} A_{j,i}^2$，表示线性算子的总“能量”。它也等于奇异值平方和：$\\|A\\|_F^2 = \\sum_{k=1}^{r} s_k^2$。\n\n我们将累积能量分数 $E(K)$ 定义为前 $K$ 个奇异模态捕获的总能量的分数：\n$$\nE(K) = \\frac{\\sum_{k=1}^{K} s_k^2}{\\sum_{k=1}^{r} s_k^2}\n$$\n这个量表明算子 $A$ 可以被一个秩为 $K$ 的矩阵近似得有多好。一个使 $E(K)$ 接近 1（例如，0.9 或 0.99）的 $K$ 值，给了我们系统“有效秩”的估计，或者说可以被数据稳健约束的亮度图独立参数的数量。\n\n**4. $K_{0.9}$ 和 $K_{0.99}$ 的计算**\n对于每个测试用例，流程如下：\n1.  设置参数 $N$ 和 $T$。\n2.  构建相应的矩阵 $A$（入食、出食或组合）。\n3.  计算 $A$ 的奇异值 $s_k$。\n4.  计算奇异值的平方 $s_k^2$。\n5.  计算 $s_k^2$ 的累积和。\n6.  将累积和除以 $s_k^2$ 的总和进行归一化，以获得累积能量分数数组 $E(K)$。\n7.  找到满足 $E(K_{0.9}) \\ge 0.9$ 的最小整数 $K_{0.9}$。这是累积能量分数数组首次超过或等于 0.9 的索引（加一，因为是基于 1 的计数）。\n8.  同样，找到满足 $E(K_{0.99}) \\ge 0.99$ 的最小整数 $K_{0.99}$。\n\n该程序将应用于四个指定的测试用例。结果将量化采样（$T$）和包含更多数据（组合入食/出食）如何影响行星亮度图可分辨分量的数量。我们预期纯出食情况与纯入食情况对称，产生相同的结果。欠采样情况（$T",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the eclipse mapping SVD analysis problem for the given test cases.\n    \"\"\"\n\n    test_cases = [\n        # Case 1 (happy path, ingress)\n        {'N': 64, 'T': 64, 'type': 'ingress'},\n        # Case 2 (undersampled ingress)\n        {'N': 64, 'T': 8, 'type': 'ingress'},\n        # Case 3 (egress symmetry check)\n        {'N': 64, 'T': 64, 'type': 'egress'},\n        # Case 4 (combined ingress+egress)\n        {'N': 64, 'T': 64, 'type': 'combined'},\n    ]\n\n    results = []\n\n    for case in test_cases:\n        N = case['N']\n        T = case['T']\n        case_type = case['type']\n\n        # 1. Discretization\n        x_i = np.linspace(-1.0, 1.0, N)\n        delta_x = 2.0 / (N - 1)\n        t_j = (np.arange(T) + 0.5) / T\n\n        # 2. Construct the Forward Operator A\n        A = None\n        # Pre-compute chord-length weights\n        # Use np.maximum to avoid floating point issues at the boundaries\n        weights = np.sqrt(np.maximum(0, 1 - x_i**2))\n\n        if case_type == 'ingress':\n            # Ingress boundary: x_b(t) = 1 - 2t\n            x_b = 1 - 2 * t_j\n            # Create a T x N boolean matrix for the indicator function\n            # x_i is broadcasted across rows, x_b is broadcasted across columns\n            indicator = x_i[np.newaxis, :] = x_b[:, np.newaxis]\n            # Construct A\n            A = np.sqrt(1 - x_i**2)[np.newaxis, :] * indicator * delta_x\n\n        elif case_type == 'egress':\n            # Egress boundary: x_b(t) = -1 + 2t\n            x_b = -1 + 2 * t_j\n            # Indicator function: x_i >= x_b\n            indicator = x_i[np.newaxis, :] >= x_b[:, np.newaxis]\n            # Construct A\n            A = np.sqrt(1 - x_i**2)[np.newaxis, :] * indicator * delta_x\n\n        elif case_type == 'combined':\n            # Ingress part\n            x_b_ing = 1 - 2 * t_j\n            indicator_ing = x_i[np.newaxis, :] = x_b_ing[:, np.newaxis]\n            A_ing = np.sqrt(1 - x_i**2)[np.newaxis, :] * indicator_ing * delta_x\n            \n            # Egress part\n            x_b_egr = -1 + 2 * t_j\n            indicator_egr = x_i[np.newaxis, :] >= x_b_egr[:, np.newaxis]\n            A_egr = np.sqrt(1 - x_i**2)[np.newaxis, :] * indicator_egr * delta_x\n            \n            # Stack vertically\n            A = np.vstack((A_ing, A_egr))\n\n        # 3. Analysis via Singular Value Decomposition\n        # We only need the singular values, so compute_uv=False is efficient\n        s = np.linalg.svd(A, compute_uv=False)\n\n        # 4. Cumulative Energy Analysis\n        s_squared = s**2\n        \n        # Handle cases where A is all zeros (s will be all zeros)\n        total_energy = np.sum(s_squared)\n        if total_energy == 0:\n            cumulative_energy = np.zeros_like(s_squared)\n        else:\n            cumulative_energy = np.cumsum(s_squared) / total_energy\n\n        # 5. Find K_0.9 and K_0.99\n        # np.searchsorted finds the index where an element would be inserted to\n        # maintain order. This gives the count of elements smaller than the target.\n        # Adding 1 gives the rank K needed to exceed the threshold.\n        # This is equivalent to finding the first index i where cumulative_energy[i] >= threshold\n        # and reporting i+1.\n        \n        # In the edge case of all singular values being 0, searchsorted would\n        # return len(cumulative_energy). Handle this by setting K to 0.\n        if total_energy == 0:\n            k_90 = 0\n            k_99 = 0\n        else:\n            k_90 = np.searchsorted(cumulative_energy, 0.9) + 1\n            k_99 = np.searchsorted(cumulative_energy, 0.99) + 1\n        \n        results.extend([k_90, k_99])\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "从带有噪声的数据中求解一个不适定问题通常需要引入正则化，但这会给解带来一定的偏差。因此，理解数据中的噪声和正则化的选择如何传播到最终亮度图的不确定性中，是至关重要的。这个练习通过一个简化的双像素模型，让你推导并计算估计像素亮度的协方差矩阵，从而具体地掌握在正则化反演中如何为每个像素计算误差棒。",
            "id": "4159145",
            "problem": "考虑对一颗潮汐锁定的系外行星进行次食光变反演，其中行星的昼侧亮度分布由一个具有未知强度 $x \\in \\mathbb{R}^{2}$ 的双像素经度图参数化。在凌入/凌出期间观测到的归一化通量时间序列 $y \\in \\mathbb{R}^{3}$ 被建模为一个线性正演问题 $y = A x + n$，其中 $A \\in \\mathbb{R}^{3 \\times 2}$ 编码了每次观测时每个像素的可见比例，而 $n$ 是均值为零、协方差为 $C_{n} \\in \\mathbb{R}^{3 \\times 3}$ 的高斯噪声。为了稳定反演过程，施加了一个二次蒂霍诺夫正则化，其中 $R = \\lambda I$，$I$ 是单位矩阵且 $\\lambda > 0$。\n\n从线性模型和高斯噪声的定义出发，并仅使用多元高斯分布和线性估计量的标准性质，推导使带二次正则化的加权最小二乘目标函数最小化的线性估计量 $\\hat{x}$ 的协方差。然后，对于下面给出的特定凌食几何形状和噪声模型，计算像素级标准差（不确定度），即 $\\hat{x}$ 的协方差矩阵对角线元素的平方根。\n\n使用以下矩阵和参数值：\n- 正演模型\n$$\nA \\;=\\; \\begin{pmatrix}\n1  1 \\\\\n1  0 \\\\\n0  1\n\\end{pmatrix}.\n$$\n这代表了 $3$ 个通量样本：第一个是两个像素都完全可见，第二个是只有西侧像素可见，第三个是只有东侧像素可见。\n- 噪声协方差（独立同分布样本）\n$$\nC_{n} \\;=\\; \\begin{pmatrix}\n1  0  0 \\\\\n0  1  0 \\\\\n0  0  1\n\\end{pmatrix}.\n$$\n- 正则化参数\n$$\n\\lambda \\;=\\; 1.\n$$\n\n将两个像素级不确定度以单个行向量的形式报告。将最终数值四舍五入到四位有效数字。不确定度以与 $x$ 相同的任意强度单位表示（最终的方框答案中不包含单位）。",
            "solution": "该问题是有效的，因为它代表了基于线性代数和统计学既定原理的系外行星科学中一个标准的、适定的反演问题。所有必要的数据和参数都已提供，没有矛盾或歧义。\n\n该问题要求计算像素强度 $x$ 的线性估计量的协方差以及相应的不确定度。估计量 $\\hat{x}$ 被定义为正则化加权最小二乘目标函数 $J(x)$ 的最小化子。\n\n目标函数由两部分组成：数据保真项和正则化项。数据保真项是观测数据 $y$ 与模型预测 $Ax$ 之间马氏距离的平方，在假定高斯噪声的情况下，这对应于给定参数下数据的负对数似然。正则化项是对解向量 $x$ 大小的二次惩罚。\n\n需要最小化的目标函数是：\n$$\nJ(x) = (y - Ax)^T C_{n}^{-1} (y - Ax) + x^T R x\n$$\n给定正则化矩阵 $R = \\lambda I$，表达式变为：\n$$\nJ(x) = (y - Ax)^T C_{n}^{-1} (y - Ax) + \\lambda x^T x\n$$\n为了找到使 $J(x)$ 最小化的估计量 $\\hat{x}$，我们计算 $J(x)$ 关于 $x$ 的梯度并将其设为零。首先，展开 $J(x)$ 的表达式：\n$$\nJ(x) = y^T C_{n}^{-1} y - y^T C_{n}^{-1} Ax - x^T A^T C_{n}^{-1} y + x^T A^T C_{n}^{-1} Ax + \\lambda x^T x\n$$\n由于 $y^T C_{n}^{-1} Ax$ 是一个标量，它等于其转置，即 $(y^T C_{n}^{-1} Ax)^T = x^T A^T (C_{n}^{-1})^T y$。协方差矩阵及其逆矩阵都是对称的，所以 $(C_{n}^{-1})^T = C_{n}^{-1}$。因此，两个交叉项是相同的。\n$$\nJ(x) = y^T C_{n}^{-1} y - 2 x^T A^T C_{n}^{-1} y + x^T (A^T C_{n}^{-1} A + \\lambda I) x\n$$\n$J(x)$ 关于 $x$ 的梯度是：\n$$\n\\frac{\\partial J(x)}{\\partial x} = -2 A^T C_{n}^{-1} y + 2 (A^T C_{n}^{-1} A + \\lambda I) x\n$$\n将梯度设为零以找到最优的 $\\hat{x}$：\n$$\n-2 A^T C_{n}^{-1} y + 2 (A^T C_{n}^{-1} A + \\lambda I) \\hat{x} = 0\n$$\n$$\n(A^T C_{n}^{-1} A + \\lambda I) \\hat{x} = A^T C_{n}^{-1} y\n$$\n解出估计量 $\\hat{x}$：\n$$\n\\hat{x} = (A^T C_{n}^{-1} A + \\lambda I)^{-1} A^T C_{n}^{-1} y\n$$\n这表明 $\\hat{x}$ 是一个形式为 $\\hat{x} = M y$ 的线性估计量，其中 $M = (A^T C_{n}^{-1} A + \\lambda I)^{-1} A^T C_{n}^{-1}$。\n\n估计量的协方差 $C_{\\hat{x}} = \\text{Cov}(\\hat{x})$ 是通过传播数据 $y$ 的协方差得到的。模型是 $y = Ax + n$，其中 $x$ 是一个固定（但未知）的参数向量。$y$ 的随机性完全来自噪声 $n$。因此，$\\text{Cov}(y) = \\text{Cov}(n) = C_n$。\n线性变换 $My$ 的协方差由 $M \\text{Cov}(y) M^T$ 给出。\n$$\nC_{\\hat{x}} = \\text{Cov}(My) = M C_n M^T\n$$\n代入 $M$ 的表达式：\n$$\nC_{\\hat{x}} = \\left[(A^T C_{n}^{-1} A + \\lambda I)^{-1} A^T C_{n}^{-1}\\right] C_n \\left[(A^T C_{n}^{-1} A + \\lambda I)^{-1} A^T C_{n}^{-1}\\right]^T\n$$\n第二个方括号的转置是 $M^T = (C_{n}^{-1})^T (A^T)^T ((A^T C_{n}^{-1} A + \\lambda I)^{-1})^T$。由于 $C_{n}^{-1}$ 是对称的，并且 $(A^T C_{n}^{-1} A + \\lambda I)$ 也是对称的，这简化为 $M^T = C_{n}^{-1} A (A^T C_{n}^{-1} A + \\lambda I)^{-1}$。\n$$\nC_{\\hat{x}} = (A^T C_{n}^{-1} A + \\lambda I)^{-1} A^T C_{n}^{-1} C_n C_{n}^{-1} A (A^T C_{n}^{-1} A + \\lambda I)^{-1}\n$$\n由于 $C_{n}^{-1} C_n = I$，这简化为：\n$$\nC_{\\hat{x}} = (A^T C_{n}^{-1} A + \\lambda I)^{-1} (A^T C_{n}^{-1} A) (A^T C_{n}^{-1} A + \\lambda I)^{-1}\n$$\n现在，我们代入给定的值：\n$A = \\begin{pmatrix} 1  1 \\\\ 1  0 \\\\ 0  1 \\end{pmatrix}$，$C_n = I_3$（$3 \\times 3$ 单位矩阵），以及 $\\lambda = 1$。\n由于 $C_n = I_3$，其逆矩阵也是 $C_{n}^{-1} = I_3$。我们来计算矩阵 $H = A^T C_{n}^{-1} A = A^T I A = A^T A$。\n$$\nA^T = \\begin{pmatrix} 1  1  0 \\\\ 1  0  1 \\end{pmatrix}\n$$\n$$\nH = A^T A = \\begin{pmatrix} 1  1  0 \\\\ 1  0  1 \\end{pmatrix} \\begin{pmatrix} 1  1 \\\\ 1  0 \\\\ 0  1 \\end{pmatrix} = \\begin{pmatrix} 1 \\cdot 1 + 1 \\cdot 1  1 \\cdot 1 + 1 \\cdot 0 \\\\ 1 \\cdot 1 + 0 \\cdot 1  1 \\cdot 1 + 1 \\cdot 1 \\end{pmatrix} = \\begin{pmatrix} 2  1 \\\\ 1  2 \\end{pmatrix}\n$$\n接下来，我们计算需要求逆的矩阵 $H + \\lambda I_2$：\n$$\nH + \\lambda I_2 = \\begin{pmatrix} 2  1 \\\\ 1  2 \\end{pmatrix} + 1 \\cdot \\begin{pmatrix} 1  0 \\\\ 0  1 \\end{pmatrix} = \\begin{pmatrix} 3  1 \\\\ 1  3 \\end{pmatrix}\n$$\n这个 $2 \\times 2$ 矩阵的逆是：\n$$\n(H + \\lambda I_2)^{-1} = \\frac{1}{3 \\cdot 3 - 1 \\cdot 1} \\begin{pmatrix} 3  -1 \\\\ -1  3 \\end{pmatrix} = \\frac{1}{8} \\begin{pmatrix} 3  -1 \\\\ -1  3 \\end{pmatrix}\n$$\n现在我们可以计算完整的协方差矩阵 $C_{\\hat{x}}$：\n$$\nC_{\\hat{x}} = \\left(\\frac{1}{8} \\begin{pmatrix} 3  -1 \\\\ -1  3 \\end{pmatrix}\\right) \\begin{pmatrix} 2  1 \\\\ 1  2 \\end{pmatrix} \\left(\\frac{1}{8} \\begin{pmatrix} 3  -1 \\\\ -1  3 \\end{pmatrix}\\right)\n$$\n$$\nC_{\\hat{x}} = \\frac{1}{64} \\begin{pmatrix} 3  -1 \\\\ -1  3 \\end{pmatrix} \\begin{pmatrix} 2  1 \\\\ 1  2 \\end{pmatrix} \\begin{pmatrix} 3  -1 \\\\ -1  3 \\end{pmatrix}\n$$\n首先，将前两个矩阵相乘：\n$$\n\\begin{pmatrix} 3  -1 \\\\ -1  3 \\end{pmatrix} \\begin{pmatrix} 2  1 \\\\ 1  2 \\end{pmatrix} = \\begin{pmatrix} 3 \\cdot 2 - 1 \\cdot 1  3 \\cdot 1 - 1 \\cdot 2 \\\\ -1 \\cdot 2 + 3 \\cdot 1  -1 \\cdot 1 + 3 \\cdot 2 \\end{pmatrix} = \\begin{pmatrix} 5  1 \\\\ 1  5 \\end{pmatrix}\n$$\n现在，完成乘法：\n$$\nC_{\\hat{x}} = \\frac{1}{64} \\begin{pmatrix} 5  1 \\\\ 1  5 \\end{pmatrix} \\begin{pmatrix} 3  -1 \\\\ -1  3 \\end{pmatrix} = \\frac{1}{64} \\begin{pmatrix} 5 \\cdot 3 + 1 \\cdot (-1)  5 \\cdot (-1) + 1 \\cdot 3 \\\\ 1 \\cdot 3 + 5 \\cdot (-1)  1 \\cdot (-1) + 5 \\cdot 3 \\end{pmatrix}\n$$\n$$\nC_{\\hat{x}} = \\frac{1}{64} \\begin{pmatrix} 14  -2 \\\\ -2  14 \\end{pmatrix} = \\begin{pmatrix} \\frac{14}{64}  -\\frac{2}{64} \\\\ -\\frac{2}{64}  \\frac{14}{64} \\end{pmatrix} = \\begin{pmatrix} \\frac{7}{32}  -\\frac{1}{32} \\\\ -\\frac{1}{32}  \\frac{7}{32} \\end{pmatrix}\n$$\n像素级不确定度（标准差）是协方差矩阵 $C_{\\hat{x}}$ 对角线元素的平方根。设 $\\sigma_1$ 和 $\\sigma_2$ 分别为第一个和第二个像素的不确定度。\n方差为 $\\sigma_1^2 = \\frac{7}{32}$ 和 $\\sigma_2^2 = \\frac{7}{32}$。\n标准差为：\n$$\n\\sigma_1 = \\sqrt{\\frac{7}{32}} \\quad \\text{和} \\quad \\sigma_2 = \\sqrt{\\frac{7}{32}}\n$$\n数值上，$\\frac{7}{32} = 0.21875$。\n$$\n\\sigma_1 = \\sigma_2 = \\sqrt{0.21875} \\approx 0.46770717...\n$$\n四舍五入到四位有效数字，不确定度均为 $0.4677$。最终答案要求以行向量形式表示。",
            "answer": "$$\\boxed{\\begin{pmatrix} 0.4677  0.4677 \\end{pmatrix}}$$"
        },
        {
            "introduction": "任何反演过程都依赖于一个包含简化假设的模型（例如，关于临边昏暗等大气属性的假设）。一个关键的最后步骤是检验我们所选择的模型与观测数据是否在统计上一致。后验预测检验（Posterior Predictive Checks, PPCs）为此类模型验证提供了一个严谨的框架。这个高级练习将向你展示如何执行PPC，通过生成包含已知“真实”模型的合成数据，并用一个可能“错误”的模型去拟合它，最终运用统计检验来判断模型的不足之处是否能够被成功探测。",
            "id": "4159172",
            "problem": "考虑一个系外行星的次食成像场景，其中行星的昼侧亮度分布沿着投影天平面上的经度坐标被离散化。设该行星被建模为一个单位半径的圆盘，其投影天平面上的经度坐标为 $u \\in [-1,1]$。昼侧亮度分布由一个向量 $x \\in \\mathbb{R}^M$ 表示，其元素 $x_j$ 对应于 $M$ 个中心位于 $u_j$ 的等宽列，这些列在区间 $[-1,1]$ 上均匀分布，其中对于 $j \\in \\{1,\\dots,M\\}$，$u_j = -1 + (j - 0.5)\\Delta u$ 且 $\\Delta u = 2/M$。对于坐标为 $u$ 的一个列，其在正交方向上的可见横截面跨度与 $2\\sqrt{1-u^2}$ 成正比，代表了在该坐标处穿过单位圆盘的弦的长度。\n\n假设在入食/出食期间，掩食的恒星边缘可以很好地近似为一条直线（恒星边缘局部平面近似）。设掩食体边界是位于位置 $c(t)$ 的垂直弦，因此在时间 $t$，行星盘上 $u  c(t)$ 的部分被完全掩食，而 $u \\ge c(t)$ 的部分则完全可见。在时间 $t$，列 $u$ 的掩模为\n$$\nM(u,t) = \\begin{cases}\n0,  u  c(t),\\\\\n1,  u \\ge c(t).\n\\end{cases}\n$$\n设建模的列权重为 $w_{\\mathrm{model}}(u) = 2\\sqrt{1-u^2}\\Delta u$，这对应于在整个可见圆盘上各向同性的、均匀的比强度。由此产生的正向模型是线性的：\n$$\ny_t = \\sum_{j=1}^M A_{t j} x_j + \\epsilon_t, \\quad A_{t j} = w_{\\mathrm{model}}(u_j) M(u_j,t),\n$$\n其中 $y_t$ 是在时间 $t$ 测得的行星流量（以任意无量纲单位计），$\\epsilon_t \\sim \\mathcal{N}(0,\\sigma^2)$ 是标准差为常数 $\\sigma$ 的独立高斯噪声。\n\n设真实数据生成过程可能通过一个发射各向异性因子偏离模型，该因子将列权重修改为\n$$\nw_{\\mathrm{true}}(u) = 2\\sqrt{1-u^2} \\left(1 - d + d \\sqrt{1-u^2}\\right)\\Delta u,\n$$\n其中 $d \\in [0,1)$ 控制一种中心增亮效应，当 $d = 0$ 时恢复到建模的各向同性情况。观测到的流量时间序列由下式生成：\n$$\ny_t^{\\mathrm{obs}} = \\sum_{j=1}^M w_{\\mathrm{true}}(u_j) M(u_j,t) x_j^{\\mathrm{true}} + \\epsilon_t,\n$$\n其中 $x^{\\mathrm{true}}$ 是真实亮度图。\n\n掩食体边界穿过行星盘的运动由下式参数化：\n$$\nc(t) = c_{\\min} + \\frac{c_{\\max} - c_{\\min}}{\\tau}\\left(t + \\frac{\\tau}{2}\\right),\n$$\n对于时间网格 $t \\in \\{-\\tau/2, -\\tau/2 + \\Delta t, \\dots, +\\tau/2\\}$，其中 $\\tau$ 是以秒为单位的食窗长度，$\\Delta t$ 是以秒为单位的采样间隔。常数 $c_{\\min}$ 和 $c_{\\max}$ 满足 $c_{\\min}  -1$ 和 $c_{\\max} > +1$，以确保弦完全扫过圆盘，并且数据集包含食外、偏食（入食/出食）和全食的测量值。在此公式中不需要明确使用角度，所有时间量必须以秒为单位处理，而流量必须视为无量纲。\n\n给定观测流量 $y^{\\mathrm{obs}}$ 和一个在各向同性模型权重 $w_{\\mathrm{model}}$ 下构建的正向算子 $A$，使用Tikhonov正则化最小二乘法反演亮度图 $x$。将正则化估计量定义为下式的最小化子：\n$$\n\\mathcal{J}(x) = \\frac{1}{\\sigma^2}\\|A x - y\\|_2^2 + \\lambda \\|L x\\|_2^2,\n$$\n其中 $L$ 是一阶差分算子 $(L x)_i = x_{i+1} - x_i$（对于 $i=1,\\dots,M-1$，其中 $L \\in \\mathbb{R}^{(M-1)\\times M}$），而 $\\lambda > 0$ 控制平滑度惩罚项。解 $x^{\\mathrm{hat}}$ 满足正规方程：\n$$\n\\left(\\frac{1}{\\sigma^2} A^\\top A + \\lambda L^\\top L\\right) x^{\\mathrm{hat}} = \\frac{1}{\\sigma^2} A^\\top y.\n$$\n\n设计后验预测检验（PPC; Posterior Predictive Checks）以评估潜在的模型设定错误，方法是从推断出的 $x^{\\mathrm{hat}}$ 模拟光变曲线，并将其与观测数据进行比较。使用高斯似然为入食/出食期间（$-1  c(t)  1$）的流量子集生成后验预测复制样本。抽取 $K$ 个独立的复制样本\n$$\ny^{\\mathrm{rep},(k)} \\sim \\mathcal{N}\\left(A x^{\\mathrm{hat}}, \\sigma^2 I\\right), \\quad k = 1,\\dots,K.\n$$\n形式化一个差异度量，该度量强调入食/出食期间残差的形状和幅度。定义\n$$\nT(y) = \\sum_{t: \\, -1  c(t)  1} \\left(\\frac{y_t - (A x^{\\mathrm{hat}})_t}{\\sigma}\\right)^2,\n$$\n计算数据的 $T\\left(y^{\\mathrm{obs}}\\right)$，并为每个复制样本计算 $T\\left(y^{\\mathrm{rep},(k)}\\right)$。定义双边贝叶斯 $p$ 值为\n$$\np_B = 2 \\min\\left\\{ \\frac{1}{K} \\sum_{k=1}^K \\mathbb{I}\\left[T\\left(y^{\\mathrm{rep},(k)}\\right) \\ge T\\left(y^{\\mathrm{obs}}\\right)\\right], \\, \\frac{1}{K} \\sum_{k=1}^K \\mathbb{I}\\left[T\\left(y^{\\mathrm{rep},(k)}\\right) \\le T\\left(y^{\\mathrm{obs}}\\right)\\right] \\right\\}.\n$$\n较小的 $p_B$ 值（例如低于常规阈值 $0.05$）表明可能存在模型设定错误。\n\n实现以下完整流程：\n- 构建真实亮度图为 $x_j^{\\mathrm{true}} = 1 + \\alpha \\cos(\\pi u_j)$（对于 $j \\in \\{1,\\dots,M\\}$），其中选择 $\\alpha \\in (0,1)$ 以避免负值。\n- 使用指定的 $d$ 和标准差为 $\\sigma$ 的独立高斯噪声，在完整的时间网格上利用 $w_{\\mathrm{true}}$ 生成合成的观测流量 $y^{\\mathrm{obs}}$。\n- 使用 $w_{\\mathrm{model}}$ 构建模型化的正向算子 $A$，并将其限制在入食/出食时间（$-1  c(t)  1$），以用于反演和差异度量。\n- 使用给定的 $\\lambda$ 和一阶差分算子 $L$，通过Tikhonov正则化的正规方程求解 $x^{\\mathrm{hat}}$。\n- 在高斯模型下生成 $K$ 个后验预测复制样本，并计算贝叶斯 $p$ 值 $p_B$。\n\n您必须使用Python语言（版本 $3.12$）实现该程序，且仅能使用允许的库。您的程序不得读取任何输入，并且必须为下面的测试套件生成结果。\n\n测试套件：\n- 案例1（模型设定良好，中等噪声）：$M=128$，$\\tau=7200$ 秒，$\\Delta t=60$ 秒，$c_{\\min}=-1.2$，$c_{\\max}=+1.2$，$\\alpha=0.3$，$d=0.0$，$\\sigma=5\\times 10^{-4}$，$\\lambda=0.01$，$K=300$。\n- 案例2（各向异性设定错误，中等噪声）：$M=128$，$\\tau=7200$ 秒，$\\Delta t=60$ 秒，$c_{\\min}=-1.2$，$c_{\\max}=+1.2$，$\\alpha=0.3$，$d=0.6$，$\\sigma=5\\times 10^{-4}$，$\\lambda=0.01$，$K=300$。\n- 案例3（各向异性设定错误，近零噪声）：$M=128$，$\\tau=7200$ 秒，$\\Delta t=60$ 秒，$c_{\\min}=-1.2$，$c_{\\max}=+1.2$，$\\alpha=0.3$，$d=0.6$，$\\sigma=10^{-6}$，$\\lambda=0.01$，$K=300$。\n\n答案规格：\n- 对每个案例，计算贝叶斯 $p$ 值 $p_B$（浮点数类型）。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表内容按上述案例顺序排列，例如 $[p_1,p_2,p_3]$，其中每个 $p_i$ 是案例 $i$ 的贝叶斯 $p$ 值。\n\n所有流量均为无量纲单位，所有时间必须以秒为单位处理，角度（如果使用）必须以弧度为单位。最终输出必须是浮点数（无量纲），并完全按照指定方式聚合。",
            "solution": "该问题要求在系外行星次食成像的背景下，实现一个称为后验预测检验（PPC）的统计程序，以评估模型的设定错误。其核心任务是使用一个“真实”的数据生成过程来模拟一条观测到的食光变曲线，然后尝试用一个简化的、可能不正确的“建模”过程来拟合这些数据。拟合的质量以及数据在拟合模型下的合理性，通过一个差异统计量和相应的贝叶斯 $p$ 值 $p_B$ 来量化。\n\n该过程可以分解为以下几个步骤：\n\n**1. 离散化与网格设置**\n\n系外行星的盘面在投影天平面上被建模为一个单位圆。我们将其昼侧亮度分布离散化为 $M$ 个垂直的列。经度坐标为 $u \\in [-1, 1]$。\n- 列的数量为 $M$。\n- 每个列的宽度为 $\\Delta u = 2/M$。\n- 第 $j$ 个列的中心是 $u_j = -1 + (j - 0.5)\\Delta u$，其中 $j \\in \\{1, \\dots, M\\}$。\n\n掩食的恒星边缘穿过行星。其在时间 $t$ 的位置由一个线性函数给出：\n$$\nc(t) = c_{\\min} + \\frac{c_{\\max} - c_{\\min}}{\\tau}\\left(t + \\frac{\\tau}{2}\\right)\n$$\n时间网格在区间 $[-\\tau/2, +\\tau/2]$ 上以采样间隔 $\\Delta t$ 均匀采样。参数 $c_{\\min}  -1$ 和 $c_{\\max} > +1$ 确保时间序列能捕捉到完整的食事件，包括食外阶段。\n\n每个列 $j$ 在时间 $t$ 的可见性由一个掩模函数描述：\n$$\nM(u_j,t) = \\begin{cases}\n0,  u_j  c(t) \\quad (\\text{被掩食})\\\\\n1,  u_j \\ge c(t) \\quad (\\text{可见})\n\\end{cases}\n$$\n\n**2. 真实数据生成**\n\n首先，我们使用一个真实的底层物理模型生成一条合成的“观测”光变曲线 $y^{\\mathrm{obs}}$。\n- 真实亮度图 $x^{\\mathrm{true}}$ 定义为 $x_j^{\\mathrm{true}} = 1 + \\alpha \\cos(\\pi u_j)$。参数 $\\alpha \\in (0,1)$ 确保亮度为正。\n- 每个列的真实权重 $w_{\\mathrm{true}}$ 考虑了几何投影和由参数 $d \\in [0,1)$ 控制的潜在发射各向异性（中心增亮）：\n$$\nw_{\\mathrm{true}}(u_j) = 2\\sqrt{1-u_j^2} \\left(1 - d + d \\sqrt{1-u_j^2}\\right)\\Delta u\n$$\n- 真实正向算子 $A_{\\mathrm{true}}$ 是一个矩阵，其元素为 $(A_{\\mathrm{true}})_{tj} = w_{\\mathrm{true}}(u_j) M(u_j,t)$。\n- 在每个时间点 $t$ 的观测流量由下式生成：\n$$\ny_t^{\\mathrm{obs}} = \\sum_{j=1}^M (A_{\\mathrm{true}})_{tj} x_j^{\\mathrm{true}} + \\epsilon_t, \\quad \\text{其中} \\quad \\epsilon_t \\sim \\mathcal{N}(0,\\sigma^2)\n$$\n该过程在完整的时间网格上执行。\n\n**3. 基于模型的反演**\n\n接下来，我们尝试从生成的数据 $y^{\\mathrm{obs}}$ 中恢复亮度图 $x$，但使用的是一个假设各向同性发射（$d=0$）的简化模型。\n- 建模的列权重 $w_{\\mathrm{model}}$ 为：\n$$\nw_{\\mathrm{model}}(u_j) = 2\\sqrt{1-u_j^2}\\Delta u\n$$\n这对应于真实权重函数中 $d=0$ 的情况。\n- 建模的正向算子 $A$ 的元素为 $A_{tj} = w_{\\mathrm{model}}(u_j) M(u_j,t)$。\n- 为了反演，我们仅使用对应于入食/出食阶段（$-1  c(t)  1$）的数据子集。我们将受限的算子记为 $A_{\\mathrm{ie}}$，相应的观测流量向量记为 $y^{\\mathrm{obs}}_{\\mathrm{ie}}$。\n\n我们通过最小化一个Tikhonov正则化最小二乘目标函数来寻求亮度图的估计值 $x^{\\mathrm{hat}}$：\n$$\n\\mathcal{J}(x) = \\frac{1}{\\sigma^2}\\|A_{\\mathrm{ie}} x - y^{\\mathrm{obs}}_{\\mathrm{ie}}\\|_2^2 + \\lambda \\|L x\\|_2^2\n$$\n此处，$L$ 是一阶差分算子，它能促进解的平滑性。其元素定义为 $(L x)_i = x_{i+1} - x_i$。最小化子 $x^{\\mathrm{hat}}$ 通过求解正规方程得到，这些方程构成一个线性方程组：\n$$\n\\left(\\frac{1}{\\sigma^2} A_{\\mathrm{ie}}^\\top A_{\\mathrm{ie}} + \\lambda L^\\top L\\right) x^{\\mathrm{hat}} = \\frac{1}{\\sigma^2} A_{\\mathrm{ie}}^\\top y^{\\mathrm{obs}}_{\\mathrm{ie}}\n$$\n这个方程组可以使用标准的数值线性代数库求解 $x^{\\mathrm{hat}}$。\n\n**4. 后验预测检验 (PPC)**\n\nPPC评估观测数据在拟合模型下是否合理。如果模型对现实的表述很差（例如，因为 $d>0$ 但模型假设 $d=0$），观测数据可能会表现为离群值。\n- 拟合模型蕴含了流量数据的后验预测分布：$y^{\\mathrm{rep}} \\sim \\mathcal{N}(A_{\\mathrm{ie}} x^{\\mathrm{hat}}, \\sigma^2 I)$。我们从这个分布中抽取 $K$ 个复制数据集 $y^{\\mathrm{rep},(k)}$。\n- 我们定义一个差异度量 $T(y)$，它量化了数据集 $y$ 与模型预测值之间的不匹配程度。所选的统计量是归一化残差的平方和：\n$$\nT(y) = \\sum_{t: \\, -1  c(t)  1} \\left(\\frac{y_t - (A_{\\mathrm{ie}} x^{\\mathrm{hat}})_t}{\\sigma}\\right)^2\n$$\n- 我们为实际观测数据计算该统计量 $T(y^{\\mathrm{obs}}_{\\mathrm{ie}})$，并为 $K$ 个复制数据集中的每一个计算 $T(y^{\\mathrm{rep},(k)})$。对于一个复制样本 $y^{\\mathrm{rep},(k)}$，根据其构造，项 $(y^{\\mathrm{rep},(k)}_t - (A_{\\mathrm{ie}} x^{\\mathrm{hat}})_t)/\\sigma$ 是一个标准正态变量。因此，$T(y^{\\mathrm{rep},(k)})$ 是这些变量的平方和，服从卡方分布 $T(y^{\\mathrm{rep},(k)}) \\sim \\chi^2_{N_{\\mathrm{ie}}}$，其中 $N_{\\mathrm{ie}}$ 是入食/出食期间的数据点数量。\n\n**5. 贝叶斯 $p$ 值计算**\n\n最后，我们将观测到的差异统计量与复制的差异统计量的分布进行比较，以计算贝叶斯 $p$ 值 $p_B$。\n$$\np_B = 2 \\min\\left\\{ \\frac{1}{K} \\sum_{k=1}^K \\mathbb{I}\\left[T\\left(y^{\\mathrm{rep},(k)}\\right) \\ge T\\left(y^{\\mathrm{obs}}_{\\mathrm{ie}}\\right)\\right], \\, \\frac{1}{K} \\sum_{k=1}^K \\mathbb{I}\\left[T\\left(y^{\\mathrm{rep},(k)}\\right) \\le T\\left(y^{\\mathrm{obs}}_{\\mathrm{ie}}\\right)\\right] \\right\\}\n$$\n其中 $\\mathbb{I}[\\cdot]$ 是指示函数。一个非常小的 $p_B$ 值（例如 0.05）表明观测数据位于后验预测分布的尾部，这指示了模型与数据之间的显著不匹配，从而可能存在模型设定错误。\n\n对于案例1，其中真实模型与拟合模型相匹配（$d=0$），我们预期 $p_B$ 会从 $[0,1]$ 上的均匀分布中抽取，因此不会系统性地偏小。对于案例2和3，模型设定错误（$d=0.6$），这应该会导致系统性残差、一个较大的 $T(y^{\\mathrm{obs}}_{\\mathrm{ie}})$ 值，并因此得到一个非常小的 $p_B$。由于案例3的噪声水平 $\\sigma$ 要低得多，这种效应应该会更为显著。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for the eclipse mapping problem.\n    \"\"\"\n    \n    test_cases = [\n        # Case 1 (well-specified model, moderate noise)\n        {'M': 128, 'tau': 7200, 'dt': 60, 'c_min': -1.2, 'c_max': 1.2, \n         'alpha': 0.3, 'd': 0.0, 'sigma': 5e-4, 'lambda_reg': 0.01, 'K': 300},\n        # Case 2 (misspecified anisotropy, moderate noise)\n        {'M': 128, 'tau': 7200, 'dt': 60, 'c_min': -1.2, 'c_max': 1.2, \n         'alpha': 0.3, 'd': 0.6, 'sigma': 5e-4, 'lambda_reg': 0.01, 'K': 300},\n        # Case 3 (misspecified anisotropy, near-zero noise)\n        {'M': 128, 'tau': 7200, 'dt': 60, 'c_min': -1.2, 'c_max': 1.2, \n         'alpha': 0.3, 'd': 0.6, 'sigma': 1e-6, 'lambda_reg': 0.01, 'K': 300},\n    ]\n\n    results = []\n    # Use a fixed seed for reproducibility of random noise generation\n    rng = np.random.default_rng(seed=42)\n\n    for params in test_cases:\n        p_value = compute_p_value(params, rng)\n        results.append(p_value)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef compute_p_value(params, rng):\n    \"\"\"\n    Computes the Bayesian p-value for a single test case.\n    \"\"\"\n    # Unpack parameters\n    M = params['M']\n    tau = params['tau']\n    dt = params['dt']\n    c_min = params['c_min']\n    c_max = params['c_max']\n    alpha = params['alpha']\n    d = params['d']\n    sigma = params['sigma']\n    lambda_reg = params['lambda_reg']\n    K = params['K']\n\n    # 1. Setup and Discretization\n    delta_u = 2.0 / M\n    u_j = -1.0 + (np.arange(1, M + 1) - 0.5) * delta_u\n\n    t = np.arange(-tau / 2, tau / 2 + dt, dt)\n    c_t = c_min + ((c_max - c_min) / tau) * (t + tau / 2)\n    \n    # Mask function M(u, t)\n    # M_full[i, j] is 1 if u_j >= c_t[i], 0 otherwise\n    M_full = (u_j[np.newaxis, :] >= c_t[:, np.newaxis]).astype(float)\n    \n    # 2. True Data Generation\n    # True brightness map\n    x_true = 1.0 + alpha * np.cos(np.pi * u_j)\n\n    # True column weights\n    geom_factor = 2 * np.sqrt(np.maximum(0, 1 - u_j**2))\n    anisotropy = 1 - d + d * np.sqrt(np.maximum(0, 1 - u_j**2))\n    w_true = geom_factor * anisotropy * delta_u\n    \n    # True forward operator\n    A_true = w_true[np.newaxis, :] * M_full\n    \n    # Generate observed flux\n    y_true = A_true @ x_true\n    noise = rng.normal(0, sigma, size=y_true.shape)\n    y_obs_full = y_true + noise\n\n    # 3. Model-Based Inversion\n    # Restrict to ingress/egress times\n    ie_mask = (c_t > -1)  (c_t  1)\n    y_obs_ie = y_obs_full[ie_mask]\n    \n    # Modeled column weights (assumes d=0)\n    w_model = geom_factor * delta_u\n    \n    # Modeled forward operator for ingress/egress\n    A_model = w_model[np.newaxis, :] * M_full[ie_mask, :]\n    \n    # First-difference operator L\n    L = -np.eye(M - 1, M, k=0) + np.eye(M - 1, M, k=1)\n    \n    # Set up and solve the normal equations\n    # Q * x_hat = b\n    Q = (1 / sigma**2) * (A_model.T @ A_model) + lambda_reg * (L.T @ L)\n    b = (1 / sigma**2) * (A_model.T @ y_obs_ie)\n    x_hat = np.linalg.solve(Q, b)\n\n    # 4. Posterior Predictive Check (PPC)\n    # Model predictions for ingress/egress\n    y_pred_ie = A_model @ x_hat\n    \n    # Discrepancy for observed data\n    T_obs = np.sum(((y_obs_ie - y_pred_ie) / sigma)**2)\n    \n    # Generate K posterior predictive replicates\n    N_ie = A_model.shape[0]\n    rep_noise = rng.normal(0, 1, size=(K, N_ie))\n    \n    # Discrepancy for replicates\n    # T_rep = sum of N_ie squared standard normal variables for each replicate\n    T_rep = np.sum(rep_noise**2, axis=1)\n\n    # 5. Bayesian p-value Calculation\n    p_ge = np.mean(T_rep >= T_obs)\n    p_le = np.mean(T_rep = T_obs)\n    \n    p_B = 2 * min(p_ge, p_le)\n    \n    return p_B\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}