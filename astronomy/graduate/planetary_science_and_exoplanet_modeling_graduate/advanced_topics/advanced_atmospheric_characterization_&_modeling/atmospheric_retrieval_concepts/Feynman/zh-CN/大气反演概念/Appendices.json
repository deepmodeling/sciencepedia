{
    "hands_on_practices": [
        {
            "introduction": "一个快速而精确的正向模型是任何大气反演的基石。本练习聚焦于相关-$k$方法，这是一种加速辐射传输计算的强大技术。通过实现并比较两种用于混合多种吸收气体的不同策略，您将获得关于构建现代大规模反演分析中所需近似方法的实践经验 。",
            "id": "4153639",
            "problem": "实现一个程序，该程序使用相关$k$分布方法和两种$k$混合策略来计算吸收性气体的带均透过率。推导必须从比尔-朗伯定律和$k$分布的定义开始。数值任务是在规定的离散求积上实现这些思想，计算一组测试用例的带均透过率，并以机器可检查的格式输出结果。\n\n您唯一可以使用的物理原理是沿路径的单色透过率的比尔-朗伯定律，以及带均相关$k$分布公式的定义。比尔-朗伯定律指出，通过总光学厚度为 $\\tau(\\nu) = \\sum_{s} k_{s}(\\nu)\\,u_{s}$ 的路径的单色透过率为\n$$\nT(\\nu) = \\exp(-\\tau(\\nu)) = \\exp\\!\\left(-\\sum_{s} k_{s}(\\nu)\\,u_{s}\\right),\n$$\n其中 $k_{s}(\\nu)$ 是物种 $s$ 在波数 $\\nu$ 处的质量吸收系数，单位为 $\\mathrm{m^{2}\\,kg^{-1}}$，$u_{s}$ 是物种 $s$ 的质量路径，单位为 $\\mathrm{kg\\,m^{-2}}$。相关$k$分布方法将对 $\\nu$ 的光谱平均替换为对已排序吸收系数的累积概率变量 $g$ 的平均。对于单一物种，在离散求积 $\\{(w_{i},k_{i})\\}_{i=1}^{N}$ 上，该物种在质量路径 $u$ 处的带均透过率近似为\n$$\n\\langle T \\rangle \\approx \\sum_{i=1}^{N} w_{i}\\,\\exp(-k_{i}\\,u),\n$$\n其中 $\\sum_{i=1}^{N} w_{i} = 1$。\n\n您将为多种吸收性物种实现并比较两种混合策略：\n\n- 随机重叠 (RO)：假设不同物种的光谱$k$分布是独立的。在此假设下，乘积的带均值等于带均值的乘积，得到\n$$\n\\langle T \\rangle_{\\mathrm{RO}} = \\prod_{s} \\left(\\sum_{i=1}^{N_{s}} w_{s,i}\\,\\exp(-k_{s,i}\\,u_{s})\\right).\n$$\n\n- 重排序-重分箱 (RnR)：通过光学厚度的离散卷积，然后进行排序和重分箱，来构建混合$k$分布：\n  1. 形成所有物种的指数组合。对于每种组合，计算组合光学厚度 $\\tau = \\sum_{s} k_{s,i_{s}}\\,u_{s}$ 和组合权重 $w = \\prod_{s} w_{s,i_{s}}$。如果总质量路径 $u_{\\mathrm{tot}} = \\sum_{s} u_{s}$ 不为零，则定义组合质量吸收系数 $k_{\\mathrm{comb}} = \\tau / u_{\\mathrm{tot}}$；如果 $u_{\\mathrm{tot}} = 0$，则按惯例将透过率定义为 $1$。\n  2. 按 $k_{\\mathrm{comb}}$ 升序对列表 $\\{(w,k_{\\mathrm{comb}})\\}$ 进行排序。\n  3. 在 $g$ 空间中，将已排序的列表重分箱到 $N_{\\mathrm{out}}$ 个等权重分箱中。在每个分箱 $b$ 内，计算加权算术平均值\n     $$\n     \\bar{k}_{b} = \\frac{1}{W_{b}}\\sum_{j \\in b} w_{j}\\,k_{\\mathrm{comb},j},\n     $$\n     其中 $W_{b}$ 是分箱 $b$ 中的总权重（如果初始权重总和为 $1$，则等于 $1/N_{\\mathrm{out}}$）。如果一个条目被分箱边界切割，则对其进行线性分割。\n  4. 将带均透过率近似为\n     $$ \n     \\langle T \\rangle_{\\mathrm{RnR}} \\approx \\sum_{b=1}^{N_{\\mathrm{out}}} W_{b}\\,\\exp(-\\bar{k}_{b}\\,u_{\\mathrm{tot}}).\n     $$\n\n所有量必须使用指定的单位处理：$k$ 的单位是 $\\mathrm{m^{2}\\,kg^{-1}}$，$u$ 的单位是 $\\mathrm{kg\\,m^{-2}}$，因此光学厚度 $\\tau$ 是无量纲的，透过率也是无量纲的。不使用角度。不使用百分比；所有比率必须是小数。\n\n实现一个程序，该程序：\n\n- 定义在单一波段和热力学状态下具有固定相关$k$分布求积的三个物种：\n  - 物种 A：$k_{\\mathrm{A}} = [\\,10^{-2},\\,5\\times 10^{-2},\\,2\\times 10^{-1},\\,1.0\\,]$，权重 $w_{\\mathrm{A}} = [\\,0.1,\\,0.2,\\,0.3,\\,0.4\\,]$。\n  - 物种 B：$k_{\\mathrm{B}} = [\\,5\\times 10^{-3},\\,2\\times 10^{-2},\\,8\\times 10^{-2},\\,3\\times 10^{-1}\\,]$，权重 $w_{\\mathrm{B}} = [\\,0.25,\\,0.25,\\,0.25,\\,0.25\\,]$。\n  - 物种 C：$k_{\\mathrm{C}} = [\\,10^{-4},\\,2\\times 10^{-3},\\,10^{-2},\\,5\\times 10^{-2}\\,]$，权重 $w_{\\mathrm{C}} = [\\,0.2,\\,0.3,\\,0.3,\\,0.2\\,]$。\n  所有 $k$ 的单位均为 $\\mathrm{m^{2}\\,kg^{-1}}$，所有权重均为无量纲，且每个物种的权重总和为 $1$。\n\n- 实现用于计算以下内容的函数：\n  1. 单一物种的带均透过率 $\\sum_{i} w_{i}\\exp(-k_{i}u)$，\n  2. 一组物种在给定质量路径下的随机重叠 (RO) 透过率，\n  3. 一组物种在给定质量路径和给定整数 $N_{\\mathrm{out}} \\ge 1$ 下的重排序-重分箱 (RnR) 透过率。\n\n- 评估以下包含 $5$ 个案例的测试套件。对于每个案例，计算两个浮点数：RO 透过率和 RnR 相对于 RO 的绝对误差，两者均为无量纲：\n  1. 案例 $1$（单物种基线）：仅物种 A，其中 $u_{\\mathrm{A}} = 1.0$，$N_{\\mathrm{out}} = 3$。\n  2. 案例 $2$（双物种中等路径）：物种 A 和 B，其中 $u_{\\mathrm{A}} = 1.0$，$u_{\\mathrm{B}} = 0.5$，$N_{\\mathrm{out}} = 4$。\n  3. 案例 $3$（一个物种路径为零的边界情况）：物种 A 和 B，其中 $u_{\\mathrm{A}} = 0.8$，$u_{\\mathrm{B}} = 0.0$，$N_{\\mathrm{out}} = 4$。\n  4. 案例 $4$（光学厚）：物种 A 和 B，其中 $u_{\\mathrm{A}} = 4.0$，$u_{\\mathrm{B}} = 3.0$，$N_{\\mathrm{out}} = 6$。\n  5. 案例 $5$（三物种混合）：物种 A、B 和 C，其中 $u_{\\mathrm{A}} = 1.5$，$u_{\\mathrm{B}} = 0.7$，$u_{\\mathrm{C}} = 0.2$，$N_{\\mathrm{out}} = 6$。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。该列表必须按以下顺序包含 $10$ 个浮点数：\n$$\n[\\;T_{\\mathrm{RO},1},\\;|T_{\\mathrm{RnR},1}-T_{\\mathrm{RO},1}|\\;,\\;T_{\\mathrm{RO},2},\\;|T_{\\mathrm{RnR},2}-T_{\\mathrm{RO},2}|\\;,\\;\\dots\\;,\\;T_{\\mathrm{RO},5},\\;|T_{\\mathrm{RnR},5}-T_{\\mathrm{RO},5}|\\;],\n$$\n保留 $8$ 位小数。透过率是无量纲的。程序不得读取任何输入，且必须按原样运行。",
            "solution": "目标是使用两种不同的$k$混合策略——随机重叠 (RO) 和重排序-重分箱 (RnR)——来计算吸收性气体混合物的带均透过率。实现将通过一组指定的测试用例进行验证。推导和实现完全基于所提供的物理定律和定义。\n\n### 原理与推导\n\n#### 比尔-朗伯定律与相关$k$分布方法\n\n基本原理是比尔-朗伯定律，它描述了在特定波数 $\\nu$ 下穿过介质的单色透过率 $T(\\nu)$。对于吸收性物种的混合物，总光学厚度是每种物种光学厚度的总和。透过率由下式给出：\n$$\nT(\\nu) = \\exp(-\\tau(\\nu)) = \\exp\\!\\left(-\\sum_{s} k_{s}(\\nu)\\,u_{s}\\right)\n$$\n此处，$k_s(\\nu)$ 是物种 $s$ 的质量吸收系数，$u_s$ 是其质量路径（柱密度）。\n\n由于 $k_s(\\nu)$ 的高度波动性，直接在光谱带上对 $T(\\nu)$ 进行积分可能计算量很大。相关$k$分布方法通过对吸收光谱进行重排序来简化此过程。我们不再对波数 $\\nu$ 进行积分，而是对吸收系数 $k$ 的累积分布函数 $g$ 进行积分。对于单个物种，带均透过率 $\\langle T \\rangle$ 使用 $g$ 空间上的离散求积进行近似。该求积由 $N$ 对权重 $w_i$ 和相应的吸收系数 $k_i$ 组成，满足 $\\sum_{i=1}^{N} w_i = 1$。带均透过率则为：\n$$\n\\langle T \\rangle \\approx \\sum_{i=1}^{N} w_{i}\\,\\exp(-k_{i}\\,u)\n$$\n该公式为计算单物种透过率的函数提供了基础。\n\n#### 多物种混合策略\n\n当存在多种吸收性气体时，必须计算它们的综合效应。我们实现了两种常用策略。\n\n**1. 随机重叠 (RO) 策略**\n\n随机重叠模型假设不同物种的吸收谱线在光谱带内相对于彼此是随机且独立分布的。这种统计独立性使得混合物的带均透过率可以计算为每个物种各自带均透过率的乘积：\n$$\n\\langle T \\rangle_{\\mathrm{RO}} = \\left\\langle \\prod_{s} \\exp(-k_s(\\nu) u_s) \\right\\rangle\n$$\n在独立性假设下，乘积的平均值等于平均值的乘积：\n$$\n\\langle T \\rangle_{\\mathrm{RO}} = \\prod_{s} \\langle \\exp(-k_s(\\nu) u_s) \\rangle = \\prod_{s} \\langle T_s \\rangle\n$$\n对每个物种 $s$ 使用其自身的求积集 $\\{ (w_{s,i}, k_{s,i}) \\}_{i=1}^{N_s}$ 进行离散相关$k$分布近似，公式变为：\n$$\n\\langle T \\rangle_{\\mathrm{RO}} = \\prod_{s} \\left(\\sum_{i=1}^{N_{s}} w_{s,i}\\,\\exp(-k_{s,i}\\,u_{s})\\right)\n$$\n此方法计算效率高，因为它只需要独立计算每个物种的透过率，然后将结果相乘。\n\n**2. 重排序-重分箱 (RnR) 策略**\n\n重排序-重分箱方法为重叠提供了更具物理相关性的处理。它涉及为气体混合物创建一个新的、组合的$k$分布，然后用该分布来计算总透过率。该过程包括四个步骤：\n\n**步骤1：构建组合的高分辨率$k$分布**\n假设单个物种的 $g$ 空间在统计上是独立的，我们可以形成其求积点的所有可能组合。对于一组物种 $\\{s\\}$，每个物种的求积点由 $i_s$ 索引，一个特定的组合对应于一个组合权重 $w$ 和一个组合光学厚度 $\\tau$：\n$$\nw = \\prod_{s} w_{s,i_{s}} \\quad \\text{and} \\quad \\tau = \\sum_{s} k_{s,i_{s}}\\,u_{s}\n$$\n权重的乘积给出了此组合发生的联合概率。如果总质量路径 $u_{\\mathrm{tot}} = \\sum_{s} u_s$ 不为零，则该组合的有效质量吸收系数定义为 $k_{\\mathrm{comb}} = \\tau / u_{\\mathrm{tot}}$。该过程会生成一个高分辨率$k$分布，通常包含 $\\prod_s N_s$ 个点。如果 $u_{\\mathrm{tot}} = 0$，根据定义，透过率为 $1$，因为没有吸收介质。\n\n**步骤2：对组合分布进行排序**\n生成的配对列表 $(w, k_{\\mathrm{comb}})$ 按 $k_{\\mathrm{comb}}$ 的升序排序。这重新建立了吸收系数与其累积概率 $g$ 之间的单调关系，从而为混合物创建了一个定义明确但分辨率较高的$k$分布。\n\n**步骤3：重分箱到更粗的求积**\n为保持计算效率，将已排序的高分辨率分布重分箱到具有期望点数 $N_{\\mathrm{out}}$ 的更粗的求积上。$g$ 空间（累积权重，从 $0$ 到 $1$）被划分为 $N_{\\mathrm{out}}$ 个等宽度的分箱，每个分箱的宽度为 $W_b = 1/N_{\\mathrm{out}}$。对于每个新分箱 $b$，代表性吸收系数 $\\bar{k}_b$ 计算为所有落入该分箱的 $k_{\\mathrm{comb}, j}$ 值（或其一部分）的加权算术平均值：\n$$\n\\bar{k}_{b} = \\frac{1}{W_{b}}\\sum_{j \\in b} w_{j}\\,k_{\\mathrm{comb},j}\n$$\n如果一个原始的已排序条目 $(w_j, k_{\\mathrm{comb},j})$ 横跨一个分箱边界，其权重 $w_j$ 将根据其 $g$ 空间区间落入每个分箱的比例，在线性上分割到相邻的分箱中。\n\n**步骤4：计算最终透过率**\n然后，使用新的、重分箱后的求积 $\\{ (W_b, \\bar{k}_b) \\}_{b=1}^{N_{\\mathrm{out}}}$ 和总质量路径 $u_{\\mathrm{tot}}$ 来计算带均透过率：\n$$\n\\langle T \\rangle_{\\mathrm{RnR}} \\approx \\sum_{b=1}^{N_{\\mathrm{out}}} W_{b}\\,\\exp(-\\bar{k}_{b}\\,u_{\\mathrm{tot}})\n$$\n由于每个分箱具有相等的权重 $W_b = 1/N_{\\mathrm{out}}$，这可以简化为：\n$$\n\\langle T \\rangle_{\\mathrm{RnR}} \\approx \\frac{1}{N_{\\mathrm{out}}} \\sum_{b=1}^{N_{\\mathrm{out}}} \\exp(-\\bar{k}_{b}\\,u_{\\mathrm{tot}})\n$$\n这种方法虽然比 RO 计算上更复杂，但通常能更准确地表示重叠的吸收特征。绝对误差 $|T_{\\mathrm{RnR}} - T_{\\mathrm{RO}}|$ 可用作量化在给定场景下这两种物理假设之间差异的度量。",
            "answer": "```python\nimport numpy as np\nfrom itertools import product\nfrom typing import List, Dict, Tuple, Union\n\n# Meticulously and exactly implement the validation and solution as required.\n\ndef solve():\n    \"\"\"\n    Main function to define species, test cases, and compute results.\n    \"\"\"\n\n    # Define the fixed correlated-k quadratures for the three species.\n    # k-values are in m^2/kg, weights are dimensionless.\n    species_db = {\n        'A': {\n            'k': np.array([1.0e-2, 5.0e-2, 2.0e-1, 1.0]),\n            'w': np.array([0.1, 0.2, 0.3, 0.4])\n        },\n        'B': {\n            'k': np.array([5.0e-3, 2.0e-2, 8.0e-2, 3.0e-1]),\n            'w': np.array([0.25, 0.25, 0.25, 0.25])\n        },\n        'C': {\n            'k': np.array([1.0e-4, 2.0e-3, 1.0e-2, 5.0e-2]),\n            'w': np.array([0.2, 0.3, 0.3, 0.2])\n        }\n    }\n\n    # Define the 5 test cases from the problem statement.\n    test_cases = [\n        {'species_ids': ['A'], 'mass_paths': [1.0], 'n_out': 3},\n        {'species_ids': ['A', 'B'], 'mass_paths': [1.0, 0.5], 'n_out': 4},\n        {'species_ids': ['A', 'B'], 'mass_paths': [0.8, 0.0], 'n_out': 4},\n        {'species_ids': ['A', 'B'], 'mass_paths': [4.0, 3.0], 'n_out': 6},\n        {'species_ids': ['A', 'B', 'C'], 'mass_paths': [1.5, 0.7, 0.2], 'n_out': 6},\n    ]\n\n    results = []\n\n    for case in test_cases:\n        species_info = [(sid, species_db[sid], u) for sid, u in zip(case['species_ids'], case['mass_paths'])]\n        \n        # Compute Random Overlap (RO) transmittance\n        t_ro = compute_ro_transmittance(species_info)\n        \n        # Compute Resort-and-Rebin (RnR) transmittance\n        t_rnr = compute_rnr_transmittance(species_info, case['n_out'])\n\n        # Calculate absolute error\n        error = abs(t_rnr - t_ro)\n\n        results.extend([t_ro, error])\n\n    # Format the final output string as specified\n    formatted_results = [f\"{val:.8f}\" for val in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\n\ndef compute_single_species_transmittance(k: np.ndarray, w: np.ndarray, u: float) -> float:\n    \"\"\"\n    Computes band-mean transmittance for a single species.\n    T = sum(w_i * exp(-k_i * u))\n    \"\"\"\n    if u == 0.0:\n        return 1.0\n    return np.sum(w * np.exp(-k * u))\n\ndef compute_ro_transmittance(species_info: List[Tuple[str, Dict[str, np.ndarray], float]]) -> float:\n    \"\"\"\n    Computes band-mean transmittance using the Random Overlap (RO) method.\n    T_ro = product(T_s for s in species)\n    \"\"\"\n    total_transmittance = 1.0\n    for _, spec_data, u in species_info:\n        total_transmittance *= compute_single_species_transmittance(spec_data['k'], spec_data['w'], u)\n    return total_transmittance\n\ndef compute_rnr_transmittance(species_info: List[Tuple[str, Dict[str, np.ndarray], float]], n_out: int) -> float:\n    \"\"\"\n    Computes band-mean transmittance using the Resort-and-Rebin (RnR) method.\n    \"\"\"\n    mass_paths = np.array([info[2] for info in species_info])\n    u_total = np.sum(mass_paths)\n\n    if u_total == 0.0:\n        return 1.0\n\n    # Step 1: Construct the combined high-resolution k-distribution\n    # List of (k_array, w_array) for each species\n    k_sets = [info[1]['k'] for info in species_info]\n    w_sets = [info[1]['w'] for info in species_info]\n    \n    # Generate all index combinations using itertools.product\n    index_ranges = [range(len(k_set)) for k_set in k_sets]\n    index_combinations = product(*index_ranges)\n\n    combined_dist = []\n    for indices in index_combinations:\n        # Combined weight is the product of individual weights\n        w_comb = np.prod([w_sets[s][indices[s]] for s in range(len(species_info))])\n        \n        # Combined optical depth is the sum of individual optical depths\n        tau_comb = np.sum([k_sets[s][indices[s]] * mass_paths[s] for s in range(len(species_info))])\n        \n        k_comb = tau_comb / u_total\n        combined_dist.append((k_comb, w_comb))\n\n    # Step 2: Sort the combined distribution by k_comb\n    combined_dist.sort(key=lambda x: x[0])\n    \n    # Step 3: Rebin to a coarser quadrature\n    sorted_k, sorted_w = zip(*combined_dist)\n    \n    k_out_binned = rebin_k_distribution(np.array(sorted_k), np.array(sorted_w), n_out)\n    \n    # Step 4: Compute final transmittance\n    w_b = 1.0 / n_out\n    t_rnr = np.sum(w_b * np.exp(-k_out_binned * u_total))\n    \n    return t_rnr\n\ndef rebin_k_distribution(sorted_k: np.ndarray, sorted_w: np.ndarray, n_out: int) -> np.ndarray:\n    \"\"\"\n    Rebins a sorted k-distribution into n_out equal-weight bins with linear splitting.\n    \"\"\"\n    k_out_weighted_sum = np.zeros(n_out)\n    bin_width = 1.0 / n_out\n    \n    g_cursor = 0.0          # Tracks the cumulative weight (g-space)\n    bin_idx = 0             # Current output bin index\n    \n    # Epsilon for robust floating-point comparisons\n    epsilon = 1e-12\n\n    for k_entry, w_entry in zip(sorted_k, sorted_w):\n        # Ignore entries with negligible weight\n        if w_entry  epsilon:\n            continue\n            \n        # g-space interval for the current entry\n        g_entry_start = g_cursor\n        g_entry_end = g_cursor + w_entry\n        \n        # This loop distributes the weight of the current entry across one or more bins\n        g_rem_start = g_entry_start # Start of remaining weight from this entry\n        while g_rem_start  g_entry_end - epsilon:\n            # g-space end of the current bin\n            g_bin_end = (bin_idx + 1) * bin_width\n            \n            # Weight from this entry that falls into the current bin\n            dw = min(g_entry_end, g_bin_end) - g_rem_start\n\n            if dw > 0:\n                k_out_weighted_sum[bin_idx] += dw * k_entry\n            \n            g_rem_start += dw\n            \n            # If we've processed up to the bin boundary, move to the next bin\n            if g_rem_start >= g_bin_end - epsilon:\n                bin_idx += 1\n                if bin_idx >= n_out : # Clamp to last bin to handle potential float issues at g=1.0\n                    bin_idx = n_out - 1\n\n        g_cursor = g_entry_end\n        \n    # Normalize to get the average k for each bin\n    k_b_averaged = k_out_weighted_sum / bin_width\n    \n    return k_b_averaged\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "稳健的大气表征要求对所有不确定性来源有透彻的理解。本练习超越了简单的测量噪声，旨在探索正向模型参数不确定性对反演结果的影响。通过推导压力展宽的不确定性如何传播到最终反演的丰度中，您将掌握构建完整且真实误差预算的关键技能 。",
            "id": "4153605",
            "problem": "考虑一个简化的光谱反演问题，该问题针对透射或发射光谱中单个孤立的分子吸收线。正向模型在光学薄极限下遵循比尔-朗伯定律（Beer–Lambert law），因此在由 $i$ 索引的光谱样本处，离散化的光谱可以用线性模型表示\n$$\ny_i = x_{\\text{true}}\\, s_i(\\gamma_{\\mathrm{true}}) + \\varepsilon_i,\n$$\n其中 $y_i$ 是测量信号，$x_{\\text{true}}$ 是待反演的无量纲气体丰度比例因子，$\\gamma_{\\mathrm{true}}$ 是压力展宽半宽参数，$s_i(\\gamma)$ 是在给定展宽参数 $\\gamma$ 时样本 $i$ 处的已知光谱模板，$\\varepsilon_i$ 是独立同分布的高斯噪声，其均值为零，方差为 $\\sigma_\\varepsilon^2$。假设谱线形状为洛伦兹形（Lorentzian），谱线中心频率为 $\\nu_0$，光谱模板为\n$$\ns_i(\\gamma) = S \\, L(\\nu_i;\\gamma), \\quad L(\\nu;\\gamma) = \\frac{1}{\\pi}\\,\\frac{\\gamma}{(\\nu-\\nu_0)^2+\\gamma^2},\n$$\n其中 $S$ 是已知的谱线强度（在此问题中为无量纲），$\\{\\nu_i\\}$ 是一个均匀采样的频率网格。压力展宽半宽依赖于压力 $P$ 和温度 $T$，其关系式通常为\n$$\n\\gamma(P,T) = \\gamma_{\\mathrm{ref}}\\,\\left(\\frac{P}{P_{\\mathrm{ref}}}\\right)\\,\\left(\\frac{T_{\\mathrm{ref}}}{T}\\right)^{n},\n$$\n其中 $\\gamma_{\\mathrm{ref}}$、$P_{\\mathrm{ref}}$、$T_{\\mathrm{ref}}$ 和温度指数 $n$ 为已知参考值。在实践中，反演算法将展宽参数固定为根据上述关系计算出的标称值 $\\gamma_0=\\gamma(P,T)$，然后使用这个固定的模板通过最小二乘法估计 $x$：\n$$\n\\widehat{x} = \\frac{\\sum_{i} s_i(\\gamma_0)\\,y_i}{\\sum_{i} s_i(\\gamma_0)^2}.\n$$\n然而，真实的展宽参数 $\\gamma_{\\mathrm{true}}$ 是不确定的。将此不确定性建模为围绕 $\\gamma_0$ 的零均值高斯扰动 $\\delta\\gamma$，即 $\\gamma_{\\mathrm{true}}=\\gamma_0+\\delta\\gamma$，其中 $\\delta\\gamma\\sim\\mathcal{N}(0,\\sigma_\\gamma^2)$，且与测量噪声无关。假设 $\\sigma_\\gamma$ 被指定为 $\\gamma_0$ 的一个固定分数 $r$，即 $\\sigma_\\gamma=r\\,\\gamma_0$。在 $s_i(\\gamma)$ 关于 $\\gamma_0$ 的一阶泰勒展开有效的区域内进行分析。\n\n任务：\n- 从上述定义出发，不使用其他快捷公式，推导 $\\widehat{x}$ 的方差的一阶表达式，该表达式需要同时考虑测量噪声和压力展宽参数的不确定性。推导必须从线性模型定义、最小二乘估计量表达式以及 $s_i(\\gamma)$ 关于 $\\gamma_0$ 的一阶泰勒展开开始。\n- 使用您推导出的表达式，实现一个程序，为下面的每个测试用例计算 $\\widehat{x}$ 的总标准差，总标准差定义为总方差的平方根。\n\n重要的实现细节和约定：\n- 使用给定的洛伦兹谱线形状解析式。为了计算方便，此问题中的所有量均视为无量纲，不需要进行物理单位转换。\n- 频率网格是均匀的：$\\nu_i = \\nu_0 + (i - (N-1)/2)\\,\\Delta\\nu$，其中 $i=0,1,\\dots,N-1$，$N$ 是样本数，$\\Delta\\nu$ 是网格间距。\n- 您必须从给定的洛伦兹定义解析地计算导数 $\\partial s_i/\\partial \\gamma$，以评估一阶传播项。\n- 此问题不涉及角度。\n- 您的程序必须为每个测试用例输出 $\\widehat{x}$ 的总标准差，并以科学记数法格式化，保留恰好 $6$ 位有效数字。\n\n测试套件：\n- 用例 A (一般良态情况):\n  - $\\nu_0 = 0$\n  - $N = 1001$\n  - $\\Delta\\nu = 0.01$\n  - $S = 1$\n  - $\\gamma_{\\mathrm{ref}} = 0.05$, $P = 1$, $P_{\\mathrm{ref}} = 1$, $T = 296$, $T_{\\mathrm{ref}} = 296$, $n=0.7$\n  - $r = 0.05$\n  - $\\sigma_\\varepsilon = 1\\times 10^{-4}$\n  - $x_{\\text{true}} = 1$\n- 用例 B (测量噪声主导，展宽不确定性非常小):\n  - $\\nu_0 = 0$\n  - $N = 1001$\n  - $\\Delta\\nu = 0.01$\n  - $S = 1$\n  - $\\gamma_{\\mathrm{ref}} = 0.05$, $P = 1$, $P_{\\mathrm{ref}} = 1$, $T = 296$, $T_{\\mathrm{ref}} = 296$, $n=0.7$\n  - $r = 0.001$\n  - $\\sigma_\\varepsilon = 1\\times 10^{-3}$\n  - $x_{\\text{true}} = 1$\n- 用例 C (展宽不确定性主导，信噪比非常高):\n  - $\\nu_0 = 0$\n  - $N = 2001$\n  - $\\Delta\\nu = 0.005$\n  - $S = 1$\n  - $\\gamma_{\\mathrm{ref}} = 0.05$, $P = 1$, $P_{\\mathrm{ref}} = 1$, $T = 296$, $T_{\\mathrm{ref}} = 296$, $n=0.7$\n  - $r = 0.2$\n  - $\\sigma_\\varepsilon = 1\\times 10^{-6}$\n  - $x_{\\text{true}} = 1$\n- 用例 D (低压下的窄谱线，精细采样):\n  - $\\nu_0 = 0$\n  - $N = 4001$\n  - $\\Delta\\nu = 0.0005$\n  - $S = 1$\n  - $\\gamma_{\\mathrm{ref}} = 0.05$, $P = 0.1$, $P_{\\mathrm{ref}} = 1$, $T = 296$, $T_{\\mathrm{ref}} = 296$, $n=0.7$\n  - $r = 0.05$\n  - $\\sigma_\\varepsilon = 1\\times 10^{-6}$\n  - $x_{\\text{true}} = 1$\n\n最终输出格式：\n- 您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序为 [用例 A, 用例 B, 用例 C, 用例 D]，其中每个值是对应情况下 $\\widehat{x}$ 的总标准差，格式化为具有恰好 $6$ 位有效数字的科学记数法（例如，`[1.234560e-03,...]`）。",
            "solution": "该问题是有效的，因为它科学地基于大气光谱学和误差分析的原理，问题陈述清晰且提供了所有必要信息，并以客观、正式的语言表达。我们可以着手解决。\n\n任务是推导最小二乘估计量 $\\widehat{x}$ 的方差表达式，该估计量存在两种独立的不确定性来源：测量噪声和模型参数误差。然后，我们将实现此表达式，以计算几个测试用例中 $\\widehat{x}$ 的总标准差。\n\n在光谱样本 $i$ 处的测量信号由以下线性模型给出：\n$$\ny_i = x_{\\text{true}}\\, s_i(\\gamma_{\\text{true}}) + \\varepsilon_i\n$$\n其中 $x_{\\text{true}}$ 是真实的丰度比例因子，$s_i(\\gamma_{\\text{true}})$ 是使用真实展宽参数 $\\gamma_{\\text{true}}$ 评估的光谱模板，$\\varepsilon_i \\sim \\mathcal{N}(0, \\sigma_\\varepsilon^2)$ 是测量噪声。\n\n然而，反演算法使用标称展宽参数 $\\gamma_0$并通过最小二乘法计算估计值 $\\widehat{x}$：\n$$\n\\widehat{x} = \\frac{\\sum_{i} s_i(\\gamma_0)\\,y_i}{\\sum_{j} s_j(\\gamma_0)^2}\n$$\n\n让我们将 $y_i$ 的模型代入 $\\widehat{x}$ 的表达式中：\n$$\n\\widehat{x} = \\frac{\\sum_{i} s_i(\\gamma_0)\\,\\left(x_{\\text{true}}\\, s_i(\\gamma_{\\text{true}}) + \\varepsilon_i\\right)}{\\sum_{j} s_j(\\gamma_0)^2}\n$$\n为清楚起见，分母中的索引已更改为 $j$。我们可以将其分成两项：\n$$\n\\widehat{x} = \\frac{x_{\\text{true}} \\sum_{i} s_i(\\gamma_0) s_i(\\gamma_{\\text{true}})}{\\sum_{j} s_j(\\gamma_0)^2} + \\frac{\\sum_{i} s_i(\\gamma_0) \\varepsilon_i}{\\sum_{j} s_j(\\gamma_0)^2}\n$$\n\n真实展宽参数 $\\gamma_{\\text{true}}$ 通过一个小的、零均值的随机扰动 $\\delta\\gamma$ 与标称参数 $\\gamma_0$ 相关联：\n$$\n\\gamma_{\\text{true}} = \\gamma_0 + \\delta\\gamma, \\quad \\text{其中} \\quad \\delta\\gamma \\sim \\mathcal{N}(0, \\sigma_\\gamma^2)\n$$\n我们已知 $s_i(\\gamma)$ 关于 $\\gamma_0$ 的一阶泰勒展开是一个有效的近似。因此，我们写出：\n$$\ns_i(\\gamma_{\\text{true}}) \\approx s_i(\\gamma_0) + \\frac{\\partial s_i}{\\partial \\gamma}\\bigg|_{\\gamma_0} (\\gamma_{\\text{true}} - \\gamma_0) = s_i(\\gamma_0) + s_i'(\\gamma_0) \\delta\\gamma\n$$\n其中 $s_i'(\\gamma_0)$ 表示 $s_i$ 相对于 $\\gamma$ 在 $\\gamma_0$ 处的导数。\n\n将此展开式代入 $\\widehat{x}$ 的表达式中：\n$$\n\\widehat{x} \\approx \\frac{x_{\\text{true}} \\sum_{i} s_i(\\gamma_0) \\left(s_i(\\gamma_0) + s_i'(\\gamma_0) \\delta\\gamma\\right)}{\\sum_{j} s_j(\\gamma_0)^2} + \\frac{\\sum_{i} s_i(\\gamma_0) \\varepsilon_i}{\\sum_{j} s_j(\\gamma_0)^2}\n$$\n$$\n\\widehat{x} \\approx \\frac{x_{\\text{true}} \\sum_{i} s_i(\\gamma_0)^2}{\\sum_{j} s_j(\\gamma_0)^2} + \\frac{x_{\\text{true}} \\sum_{i} s_i(\\gamma_0) s_i'(\\gamma_0)}{\\sum_{j} s_j(\\gamma_0)^2} \\delta\\gamma + \\frac{\\sum_{i} s_i(\\gamma_0) \\varepsilon_i}{\\sum_{j} s_j(\\gamma_0)^2}\n$$\n第一项简化为 $x_{\\text{true}}$。估计参数的表达式变为：\n$$\n\\widehat{x} \\approx x_{\\text{true}} + \\left(x_{\\text{true}} \\frac{\\sum_{i} s_i(\\gamma_0) s_i'(\\gamma_0)}{\\sum_{j} s_j(\\gamma_0)^2}\\right) \\delta\\gamma + \\left(\\frac{\\sum_{i} s_i(\\gamma_0) \\varepsilon_i}{\\sum_{j} s_j(\\gamma_0)^2}\\right)\n$$\n\n为了求方差 $\\text{Var}(\\widehat{x})$，我们首先求期望 $E[\\widehat{x}]$。鉴于 $E[\\varepsilon_i]=0$ 和 $E[\\delta\\gamma]=0$，后两项的期望为零。因此，在一阶近似下，估计量是无偏的：\n$$\nE[\\widehat{x}] \\approx x_{\\text{true}}\n$$\n方差是与均值偏差的平方的期望值，$\\text{Var}(\\widehat{x}) = E[(\\widehat{x} - E[\\widehat{x}])^2] \\approx E[(\\widehat{x} - x_{\\text{true}})^2]$。\n$$\n\\widehat{x} - x_{\\text{true}} \\approx \\underbrace{\\left(x_{\\text{true}} \\frac{\\sum_{i} s_i(\\gamma_0) s_i'(\\gamma_0)}{\\sum_{j} s_j(\\gamma_0)^2}\\right) \\delta\\gamma}_{\\text{项 A}} + \\underbrace{\\left(\\frac{\\sum_{i} s_i(\\gamma_0) \\varepsilon_i}{\\sum_{j} s_j(\\gamma_0)^2}\\right)}_{\\text{项 B}}\n$$\n总方差为 $\\text{Var}(\\widehat{x}) \\approx E[(A+B)^2] = E[A^2] + E[B^2] + 2E[AB]$。已知随机变量 $\\delta\\gamma$ 和 $\\varepsilon_i$ 是独立的。由于两者都是零均值，它们的乘积的期望为零，$E[\\delta\\gamma \\varepsilon_i] = E[\\delta\\gamma]E[\\varepsilon_i] = 0$。因此，交叉项 $E[AB]$ 为零。\n\n总方差是来自两个独立误差源的方差之和：\n$$\n\\text{Var}(\\widehat{x}) \\approx E[A^2] + E[B^2] = \\text{Var}(A) + \\text{Var}(B)\n$$\n\n第一部分，由测量噪声引起，是：\n$$\n\\text{Var}_{\\varepsilon}(\\widehat{x}) = E[B^2] = E\\left[ \\left(\\frac{\\sum_{i} s_i(\\gamma_0) \\varepsilon_i}{\\sum_{j} s_j(\\gamma_0)^2}\\right)^2 \\right] = \\frac{1}{(\\sum_{j} s_j(\\gamma_0)^2)^2} \\sum_{i,k} s_i(\\gamma_0) s_k(\\gamma_0) E[\\varepsilon_i \\varepsilon_k]\n$$\n由于 $\\varepsilon_i$ 是独立同分布的，方差为 $\\sigma_\\varepsilon^2$，我们有 $E[\\varepsilon_i \\varepsilon_k] = \\sigma_\\varepsilon^2 \\delta_{ik}$，其中 $\\delta_{ik}$ 是克罗内克（Kronecker）δ函数。双重求和简化为单个求和：\n$$\n\\text{Var}_{\\varepsilon}(\\widehat{x}) = \\frac{\\sum_{i} s_i(\\gamma_0)^2 \\sigma_\\varepsilon^2}{(\\sum_{j} s_j(\\gamma_0)^2)^2} = \\frac{\\sigma_\\varepsilon^2}{\\sum_{i} s_i(\\gamma_0)^2}\n$$\n\n第二部分，由展宽参数不确定性引起，是：\n$$\n\\text{Var}_{\\gamma}(\\widehat{x}) = E[A^2] = E\\left[ \\left(x_{\\text{true}} \\frac{\\sum_{i} s_i(\\gamma_0) s_i'(\\gamma_0)}{\\sum_{j} s_j(\\gamma_0)^2} \\delta\\gamma \\right)^2 \\right]\n$$\n$$\n\\text{Var}_{\\gamma}(\\widehat{x}) = \\left(x_{\\text{true}} \\frac{\\sum_{i} s_i(\\gamma_0) s_i'(\\gamma_0)}{\\sum_{j} s_j(\\gamma_0)^2}\\right)^2 E[\\delta\\gamma^2]\n$$\n由于 $E[\\delta\\gamma]=0$，所以 $E[\\delta\\gamma^2] = \\text{Var}(\\delta\\gamma) = \\sigma_\\gamma^2$。\n$$\n\\text{Var}_{\\gamma}(\\widehat{x}) = \\left(x_{\\text{true}} \\frac{\\sum_{i} s_i(\\gamma_0) s_i'(\\gamma_0)}{\\sum_{j} s_j(\\gamma_0)^2}\\right)^2 \\sigma_\\gamma^2\n$$\n\n估计量 $\\widehat{x}$ 的总方差是这两个分量的和：\n$$\n\\text{Var}(\\widehat{x}) \\approx \\frac{\\sigma_\\varepsilon^2}{\\sum_i s_i(\\gamma_0)^2} + \\left(x_{\\text{true}} \\frac{\\sum_i s_i(\\gamma_0) s_i'(\\gamma_0)}{\\sum_j s_j(\\gamma_0)^2}\\right)^2 \\sigma_\\gamma^2\n$$\n总标准差是 $\\sigma_{\\widehat{x}} = \\sqrt{\\text{Var}(\\widehat{x})}$。\n\n为了实现这一点，我们需要光谱模板 $s_i(\\gamma) = S L(\\nu_i; \\gamma) = \\frac{S}{\\pi} \\frac{\\gamma}{(\\nu_i-\\nu_0)^2 + \\gamma^2}$ 的解析导数。\n使用商法则，我们得到：\n$$\n\\frac{\\partial s_i}{\\partial \\gamma} = \\frac{S}{\\pi} \\frac{\\partial}{\\partial \\gamma} \\left(\\frac{\\gamma}{(\\nu_i-\\nu_0)^2 + \\gamma^2}\\right) = \\frac{S}{\\pi} \\frac{1 \\cdot ((\\nu_i-\\nu_0)^2 + \\gamma^2) - \\gamma \\cdot (2\\gamma)}{((\\nu_i-\\nu_0)^2 + \\gamma^2)^2}\n$$\n$$\ns_i'(\\gamma) = \\frac{\\partial s_i}{\\partial \\gamma} = \\frac{S}{\\pi} \\frac{(\\nu_i-\\nu_0)^2 - \\gamma^2}{((\\nu_i-\\nu_0)^2 + \\gamma^2)^2}\n$$\n此导数将在 $\\gamma = \\gamma_0$ 处求值，用于方差表达式。\n$\\gamma_0$ 的值由给定的（P, T）大气状态计算得出：\n$$\n\\gamma_0 = \\gamma(P,T)\\;=\\;\\gamma_{\\mathrm{ref}}\\,\\left(\\frac{P}{P_{\\mathrm{ref}}}\\right)\\,\\left(\\frac{T_{\\mathrm{ref}}}{T}\\right)^{n}\n$$\n展宽不确定性标准差由 $\\sigma_\\gamma = r \\gamma_0$ 给出。\n以下 Python 代码实现了此推导，用于计算指定测试用例中 $\\widehat{x}$ 的总标准差。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_std_dev(params: dict) -> float:\n    \"\"\"\n    Calculates the total standard deviation of the retrieved abundance parameter.\n\n    Args:\n        params: A dictionary containing all the necessary parameters for the calculation.\n\n    Returns:\n        The total standard deviation of x_hat.\n    \"\"\"\n    # Unpack parameters from the dictionary\n    nu0 = params[\"nu0\"]\n    N = params[\"N\"]\n    delta_nu = params[\"delta_nu\"]\n    S = params[\"S\"]\n    gamma_ref = params[\"gamma_ref\"]\n    P = params[\"P\"]\n    P_ref = params[\"P_ref\"]\n    T = params[\"T\"]\n    T_ref = params[\"T_ref\"]\n    n = params[\"n\"]\n    r = params[\"r\"]\n    sigma_eps = params[\"sigma_eps\"]\n    x_true = params[\"x_true\"]\n\n    # Step 1: Calculate the nominal broadening parameter gamma_0.\n    gamma0 = gamma_ref * (P / P_ref) * (T_ref / T)**n\n    \n    # Step 2: Calculate the standard deviation of the broadening parameter, sigma_gamma.\n    sigma_gamma = r * gamma0\n\n    # Step 3: Generate the frequency grid.\n    i_indices = np.arange(N)\n    nu_grid = nu0 + (i_indices - (N - 1) / 2.0) * delta_nu\n\n    # Step 4: Calculate the spectral template s(gamma_0) and its derivative s'(gamma_0).\n    nu_minus_nu0_sq = (nu_grid - nu0)**2\n    lorentz_denominator = nu_minus_nu0_sq + gamma0**2\n    \n    # Spectral template s_i(gamma_0)\n    s_gamma0 = (S / np.pi) * (gamma0 / lorentz_denominator)\n    \n    # Derivative of the spectral template, s'_i(gamma_0)\n    s_prime_gamma0 = (S / np.pi) * (nu_minus_nu0_sq - gamma0**2) / (lorentz_denominator**2)\n\n    # Step 5: Compute the required sums over the spectral grid.\n    sum_s_sq = np.sum(s_gamma0**2)\n    sum_s_s_prime = np.sum(s_gamma0 * s_prime_gamma0)\n\n    # Step 6: Calculate the two variance components.\n    # Variance due to measurement noise\n    var_noise = sigma_eps**2 / sum_s_sq\n    \n    # Variance due to broadening parameter uncertainty\n    var_broadening = (x_true * sum_s_s_prime / sum_s_sq)**2 * sigma_gamma**2\n    \n    # Step 7: Sum the variances to get the total variance and then the standard deviation.\n    total_var = var_noise + var_broadening\n    total_std_dev = np.sqrt(total_var)\n    \n    return total_std_dev\n\n\ndef solve():\n    \"\"\"\n    Executes the calculation for all test cases and prints the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A\n        {\"nu0\": 0.0, \"N\": 1001, \"delta_nu\": 0.01, \"S\": 1.0, \n         \"gamma_ref\": 0.05, \"P\": 1.0, \"P_ref\": 1.0, \"T\": 296.0, \"T_ref\": 296.0, \"n\": 0.7, \n         \"r\": 0.05, \"sigma_eps\": 1e-4, \"x_true\": 1.0},\n        # Case B\n        {\"nu0\": 0.0, \"N\": 1001, \"delta_nu\": 0.01, \"S\": 1.0, \n         \"gamma_ref\": 0.05, \"P\": 1.0, \"P_ref\": 1.0, \"T\": 296.0, \"T_ref\": 296.0, \"n\": 0.7, \n         \"r\": 0.001, \"sigma_eps\": 1e-3, \"x_true\": 1.0},\n        # Case C\n        {\"nu0\": 0.0, \"N\": 2001, \"delta_nu\": 0.005, \"S\": 1.0, \n         \"gamma_ref\": 0.05, \"P\": 1.0, \"P_ref\": 1.0, \"T\": 296.0, \"T_ref\": 296.0, \"n\": 0.7, \n         \"r\": 0.2, \"sigma_eps\": 1e-6, \"x_true\": 1.0},\n        # Case D\n        {\"nu0\": 0.0, \"N\": 4001, \"delta_nu\": 0.0005, \"S\": 1.0, \n         \"gamma_ref\": 0.05, \"P\": 0.1, \"P_ref\": 1.0, \"T\": 296.0, \"T_ref\": 296.0, \"n\": 0.7, \n         \"r\": 0.05, \"sigma_eps\": 1e-6, \"x_true\": 1.0}\n    ]\n\n    results = []\n    for case in test_cases:\n        std_dev = calculate_std_dev(case)\n        # Format the result in scientific notation with 6 digits after the decimal.\n        results.append(f\"{std_dev:.6e}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "高维贝叶斯反演的实际成功通常取决于计算效率。本练习解决了一个常见的障碍：由于后验参数相关性导致的采样性能不佳。您将实现一种先验白化变换，并使用矩阵条件数来定量证明这种重参数化如何能够产生一个条件更好的后验分布，从而为更高效的马尔可夫链蒙特卡罗（MCMC）采样铺平道路 。",
            "id": "4153635",
            "problem": "考虑一个围绕参考状态的系外行星透射光谱的线性化大气反演。测量模型由一个从状态到数据的线性映射给出，并带有加性高斯噪声。设 $x \\in \\mathbb{R}^n$ 是包含 $n$ 个大气参数的向量（例如，气体混合比的对数和一个温度参数，为了一般性在此视为无量纲），设 $y \\in \\mathbb{R}^m$ 是包含 $m$ 个光谱数据点的向量。正向模型线性化为\n$$\ny = K x + \\varepsilon,\n$$\n其中 $K \\in \\mathbb{R}^{m \\times n}$ 是在参考状态下求值的正向模型的雅可比矩阵，$\\varepsilon \\sim \\mathcal{N}(0, N)$ 是零均值高斯噪声，其协方差 $N \\in \\mathbb{R}^{m \\times m}$ 是对称正定矩阵。$x$ 的先验是高斯分布，\n$$\nx \\sim \\mathcal{N}(\\mu, S),\n$$\n其均值为 $\\mu \\in \\mathbb{R}^n$，协方差为 $S \\in \\mathbb{R}^{n \\times n}$，该协方差矩阵是对称正定的。\n\n在高维大气反演中，当参数强相关或尺度分离时，马尔可夫链蒙特卡洛（MCMC）的采样效率可能会降低。一个经典的解决方法是使用先验白化变换对状态向量进行重参数化。设 $L \\in \\mathbb{R}^{n \\times n}$ 是 $S$ 的下三角 Cholesky 因子，使得 $S = L L^\\top$。定义重参数化变量 $z \\in \\mathbb{R}^n$ 为\n$$\nx = \\mu + L z,\n$$\n这意味着 $z$ 服从标准正态先验 $z \\sim \\mathcal{N}(0, I)$，其中 $I \\in \\mathbb{R}^{n \\times n}$ 是单位矩阵。用 $z$ 表示，测量模型变为\n$$\ny = K \\mu + K L z + \\varepsilon.\n$$\n\n从贝叶斯定理以及给定的高斯先验和似然出发，从第一性原理推导原始参数化和先验白化参数化中的后验分布。您的推导必须从上述定义开始，并使用多元高斯分布的标准规则（配方法），不得引用任何未由基本设置证明的快捷公式。\n\n定义对称正定协方差矩阵的数值条件的概念。具体来说，对于一个对称正定矩阵 $A$，其 2-范数条件数定义为\n$$\n\\kappa_2(A) = \\frac{\\lambda_{\\max}(A)}{\\lambda_{\\min}(A)},\n$$\n其中 $\\lambda_{\\max}(A)$ 和 $\\lambda_{\\min}(A)$ 分别是 $A$ 的最大和最小特征值。\n\n实现一个程序，对于每个提供的测试用例，计算原始参数化和先验白化参数化中的后验协方差，然后输出它们的条件数的比率，即\n$$\nr = \\frac{\\kappa_2(\\Sigma_x)}{\\kappa_2(\\Sigma_z)},\n$$\n其中 $\\Sigma_x$ 是 $x$ 的后验协方差，$\\Sigma_z$ 是 $z$ 的后验协方差。$r  1$ 的值表示先验白化参数化比原始参数化产生条件更好的后验。\n\n本问题中的所有量都是无量纲的。将每个比率 $r$ 表示为一个四舍五入到六位小数的十进制数。\n\n测试套件：\n- 案例1（相关的敏感度和先验相关性）：设 $n = 3, m = 3$，且\n$$\nK_1 = \\begin{pmatrix}\n1.0  0.9  0.1 \\\\\n0.9  1.0  0.2 \\\\\n0.1  0.2  0.5\n\\end{pmatrix},\\quad\nN_1 = \\operatorname{diag}(0.01,\\,0.02,\\,0.015),\\quad\nS_1 = \\begin{pmatrix}\n0.5  0.45  0.05 \\\\\n0.45  0.5  0.05 \\\\\n0.05  0.05  0.2\n\\end{pmatrix}.\n$$\n取 $\\mu_1 = \\begin{pmatrix}0 \\\\ 0 \\\\ 0\\end{pmatrix}$。\n- 案例2（$K$ 中几乎共线的列和宽相关的先验）：设 $n = 3, m = 3$，且\n$$\nK_2 = \\begin{pmatrix}\n1.0  1.0  0.0 \\\\\n0.99  1.0  0.01 \\\\\n0.0  0.01  0.0\n\\end{pmatrix},\\quad\nN_2 = \\operatorname{diag}(1.0,\\,1.0,\\,1.0),\\quad\nS_2 = \\begin{pmatrix}\n2.0  1.8  0.0 \\\\\n1.8  2.0  0.0 \\\\\n0.0  0.0  0.5\n\\end{pmatrix}.\n$$\n取 $\\mu_2 = \\begin{pmatrix}0 \\\\ 0 \\\\ 0\\end{pmatrix}$。\n- 案例3（正交的敏感度和低噪声）：设 $n = 3, m = 3$，且\n$$\nK_3 = I = \\begin{pmatrix}\n1  0  0 \\\\\n0  1  0 \\\\\n0  0  1\n\\end{pmatrix},\\quad\nN_3 = \\operatorname{diag}(10^{-4},\\,10^{-4},\\,10^{-4}),\\quad\nS_3 = \\operatorname{diag}(1.0,\\,1.0,\\,1.0).\n$$\n取 $\\mu_3 = \\begin{pmatrix}0 \\\\ 0 \\\\ 0\\end{pmatrix}$。\n\n您的程序应产生单行输出，其中包含三个计算出的比率，形式为用方括号括起来的逗号分隔列表，例如 $[r_1,r_2,r_3]$，每个 $r_i$ 四舍五入到六位小数。不应打印其他任何文本。",
            "solution": "用户要求对一个线性化的贝叶斯大气反演问题，在原始参数化和先验白化参数化两种情况下，推导其后验分布，然后通过数值实现来比较这些后验的条件数。\n\n### 1. 后验分布的推导\n\n该问题由高斯似然和高斯先验定义。后验分布通过贝叶斯定理求得，该定理指出后验概率密度函数（PDF）与似然 PDF 和先验 PDF 的乘积成正比。对于多元高斯分布 $\\mathcal{N}(v | \\bar{v}, \\Sigma_v)$，其 PDF 由 $p(v) \\propto \\exp\\left(-\\frac{1}{2} (v - \\bar{v})^\\top \\Sigma_v^{-1} (v - \\bar{v})\\right)$ 给出。\n\n#### 1.1 原始参数（$x$）的后验\n\n原始参数 $x \\in \\mathbb{R}^n$ 的模型是：\n-   似然：$p(y|x) = \\mathcal{N}(y | Kx, N)$，其中 $y \\in \\mathbb{R}^m$，$K \\in \\mathbb{R}^{m \\times n}$，$N$ 是噪声协方差矩阵。\n-   先验：$p(x) = \\mathcal{N}(x | \\mu, S)$，其中 $\\mu \\in \\mathbb{R}^n$，$S$ 是先验协方差矩阵。\n\n根据贝叶斯定理，后验 PDF $p(x|y)$ 为：\n$$\np(x|y) \\propto p(y|x)p(x)\n$$\n代入高斯形式：\n$$\np(x|y) \\propto \\exp\\left( -\\frac{1}{2} (y - Kx)^\\top N^{-1} (y - Kx) \\right) \\cdot \\exp\\left( -\\frac{1}{2} (x - \\mu)^\\top S^{-1} (x - \\mu) \\right)\n$$\n$$\np(x|y) \\propto \\exp\\left( -\\frac{1}{2} \\left[ (y - Kx)^\\top N^{-1} (y - Kx) + (x - \\mu)^\\top S^{-1} (x - \\mu) \\right] \\right)\n$$\n为了确定后验分布的形式，我们展开指数中的二次表达式，记为 $J(x)$：\n$$\nJ(x) = (y^\\top - x^\\top K^\\top) N^{-1} (y - Kx) + (x^\\top - \\mu^\\top) S^{-1} (x - \\mu)\n$$\n$$\nJ(x) = (y^\\top N^{-1} y - y^\\top N^{-1} Kx - x^\\top K^\\top N^{-1} y + x^\\top K^\\top N^{-1} Kx) + (x^\\top S^{-1} x - x^\\top S^{-1} \\mu - \\mu^\\top S^{-1} x + \\mu^\\top S^{-1} \\mu)\n$$\n认识到标量的转置是其自身（例如，$x^\\top K^\\top N^{-1} y = y^\\top N^{-1} Kx$），我们合并 $x$ 的线性项：\n$$\nJ(x) = y^\\top N^{-1} y - 2x^\\top K^\\top N^{-1} y + x^\\top K^\\top N^{-1} Kx + x^\\top S^{-1} x - 2x^\\top S^{-1} \\mu + \\mu^\\top S^{-1} \\mu\n$$\n按 $x$ 的幂次分组：\n$$\nJ(x) = x^\\top (K^\\top N^{-1} K + S^{-1}) x - 2x^\\top (K^\\top N^{-1} y + S^{-1}\\mu) + \\text{const}\n$$\n其中 `const` 包括所有不依赖于 $x$ 的项。这是 $x$ 的一个二次型，这意味着后验分布也是高斯分布，记为 $p(x|y) = \\mathcal{N}(x | \\mu_x, \\Sigma_x)$。其 PDF 的指数为 $-\\frac{1}{2}(x - \\mu_x)^\\top \\Sigma_x^{-1} (x - \\mu_x)$，展开为：\n$$\n-\\frac{1}{2} (x^\\top \\Sigma_x^{-1} x - 2x^\\top \\Sigma_x^{-1}\\mu_x + \\mu_x^\\top \\Sigma_x^{-1} \\mu_x)\n$$\n通过将 $J(x)$ 中关于 $x$ 的二次项与此形式进行比较，我们确定了逆后验协方差（也称为精度矩阵）：\n$$\n\\Sigma_x^{-1} = K^\\top N^{-1} K + S^{-1}\n$$\n因此，原始参数化 $x$ 的后验协方差为：\n$$\n\\Sigma_x = (K^\\top N^{-1} K + S^{-1})^{-1}\n$$\n注意，后验协方差 $\\Sigma_x$ 与测量数据 $y$ 无关。\n\n#### 1.2 先验白化参数（$z$）的后验\n\n先验白化参数 $z \\in \\mathbb{R}^n$ 通过变换 $x = \\mu + Lz$ 与 $x$ 相关，其中 $S = LL^\\top$ 是先验协方差 $S$ 的 Cholesky 分解。此变换意味着 $z$ 服从标准高斯先验：$p(z) = \\mathcal{N}(z | 0, I)$，其中 $I$ 是单位矩阵。\n\n我们用 $z$ 重写测量模型：\n$$\ny = K(\\mu + Lz) + \\varepsilon = K\\mu + KLz + \\varepsilon\n$$\n让我们定义一个平移后的数据向量 $y' = y - K\\mu$。模型变为 $y' = (KL)z + \\varepsilon$。\n-   似然：$p(y|z) = p(y'|z) = \\mathcal{N}(y' | KLz, N)$。\n-   先验：$p(z) = \\mathcal{N}(z | 0, I)$。\n\n对 $z$ 应用贝叶斯定理：\n$$\np(z|y) \\propto p(y|z)p(z)\n$$\n$$\np(z|y) \\propto \\exp\\left( -\\frac{1}{2} (y' - KLz)^\\top N^{-1} (y' - KLz) \\right) \\cdot \\exp\\left( -\\frac{1}{2} z^\\top I^{-1} z \\right)\n$$\n$$\np(z|y) \\propto \\exp\\left( -\\frac{1}{2} \\left[ (y - K\\mu - KLz)^\\top N^{-1} (y - K\\mu - KLz) + z^\\top z \\right] \\right)\n$$\n设指数中的项为 $-J(z)/2$。我们展开 $J(z)$：\n$$\nJ(z) = (y' - KLz)^\\top N^{-1} (y' - KLz) + z^\\top z\n$$\n$$\nJ(z) = z^\\top (KL)^\\top N^{-1} (KL)z - 2z^\\top (KL)^\\top N^{-1} y' + (y')^\\top N^{-1} y' + z^\\top z\n$$\n按 $z$ 的幂次分组：\n$$\nJ(z) = z^\\top (L^\\top K^\\top N^{-1} K L + I) z - 2z^\\top L^\\top K^\\top N^{-1} y' + \\text{const}\n$$\n这个二次型意味着 $z$ 的后验是高斯分布，$p(z|y) = \\mathcal{N}(z | \\mu_z, \\Sigma_z)$。通过将二次项与一般高斯 PDF 的二次项进行比较，我们确定了 $z$ 的逆后验协方差：\n$$\n\\Sigma_z^{-1} = L^\\top K^\\top N^{-1} K L + I\n$$\n先验白化参数化 $z$ 的后验协方差为：\n$$\n\\Sigma_z = (L^\\top K^\\top N^{-1} K L + I)^{-1}\n$$\n\n### 2. 数值条件和计算过程\n\n对称正定（SPD）协方差矩阵 $A$ 的数值条件由其 2-范数条件数给出：\n$$\n\\kappa_2(A) = \\frac{\\lambda_{\\max}(A)}{\\lambda_{\\min}(A)}\n$$\n其中 $\\lambda_{\\max}(A)$ 和 $\\lambda_{\\min}(A)$ 分别是 $A$ 的最大和最小特征值。较小的条件数（越接近1）表示矩阵的条件越好。\n\n程序将为每个测试用例计算比率 $r = \\kappa_2(\\Sigma_x) / \\kappa_2(\\Sigma_z)$。执行以下步骤：\n1.  给定矩阵 $K$、$S$ 和 $N$ 的对角线，构造完整的矩阵。\n2.  对先验协方差 $S$ 进行 Cholesky 分解以找到下三角矩阵 $L$。\n3.  计算逆矩阵 $N^{-1}$ 和 $S^{-1}$。\n4.  计算后验协方差 $\\Sigma_x = (K^\\top N^{-1} K + S^{-1})^{-1}$。\n5.  计算后验协方差 $\\Sigma_z = (L^\\top K^\\top N^{-1} K L + I)^{-1}$。\n6.  对于 $\\Sigma_x$ 和 $\\Sigma_z$，计算它们的特征值，并求出最大与最小特征值的比率，以获得它们各自的条件数。\n7.  计算最终比率 $r$ 并将其四舍五入到指定的精度。\n\n将此过程应用于提供的三个测试用例中的每一个。",
            "answer": "```python\nimport numpy as np\nfrom scipy.linalg import cholesky\n\ndef solve():\n    \"\"\"\n    Solves the atmospheric retrieval conditioning problem for the given test cases.\n    \"\"\"\n\n    test_cases = [\n        # Case 1: Correlated sensitivities and prior\n        {\n            \"K\": np.array([\n                [1.0, 0.9, 0.1],\n                [0.9, 1.0, 0.2],\n                [0.1, 0.2, 0.5]\n            ]),\n            \"N_diag\": np.array([0.01, 0.02, 0.015]),\n            \"S\": np.array([\n                [0.5, 0.45, 0.05],\n                [0.45, 0.5, 0.05],\n                [0.05, 0.05, 0.2]\n            ]),\n        },\n        # Case 2: Nearly collinear columns in K and broad correlated prior\n        {\n            \"K\": np.array([\n                [1.0, 1.0, 0.0],\n                [0.99, 1.0, 0.01],\n                [0.0, 0.01, 0.0]\n            ]),\n            \"N_diag\": np.array([1.0, 1.0, 1.0]),\n            \"S\": np.array([\n                [2.0, 1.8, 0.0],\n                [1.8, 2.0, 0.0],\n                [0.0, 0.0, 0.5]\n            ]),\n        },\n        # Case 3: Orthogonal sensitivities and low noise\n        {\n            \"K\": np.array([\n                [1.0, 0.0, 0.0],\n                [0.0, 1.0, 0.0],\n                [0.0, 0.0, 1.0]\n            ]),\n            \"N_diag\": np.array([1e-4, 1e-4, 1e-4]),\n            \"S\": np.array([\n                [1.0, 0.0, 0.0],\n                [0.0, 1.0, 0.0],\n                [0.0, 0.0, 1.0]\n            ]),\n        }\n    ]\n\n    results = []\n\n    for case in test_cases:\n        K = case[\"K\"]\n        S = case[\"S\"]\n        N = np.diag(case[\"N_diag\"])\n        \n        n = K.shape[1]\n        I = np.identity(n)\n\n        # Inverses needed for the formulas.\n        N_inv = np.linalg.inv(N)\n        S_inv = np.linalg.inv(S)\n        \n        # Cholesky factor of the prior covariance S such that S = L L^T\n        # We use scipy.linalg.cholesky to ensure we get the lower triangular factor.\n        L = cholesky(S, lower=True)\n\n        # 1. Posterior covariance for original parameters x\n        # Sigma_x = (K^T N^-1 K + S^-1)^-1\n        precision_x = K.T @ N_inv @ K + S_inv\n        Sigma_x = np.linalg.inv(precision_x)\n\n        # 2. Posterior covariance for whitened parameters z\n        # Sigma_z = (L^T K^T N^-1 K L + I)^-1\n        precision_z = L.T @ K.T @ N_inv @ K @ L + I\n        Sigma_z = np.linalg.inv(precision_z)\n        \n        def condition_number_2(A):\n            \"\"\"\n            Calculates the 2-norm condition number for a symmetric positive definite matrix.\n            kappa_2(A) = lambda_max(A) / lambda_min(A)\n            \"\"\"\n            # eigvalsh is for hermitian (or real symmetric) matrices.\n            # It returns eigenvalues in ascending order.\n            eigenvalues = np.linalg.eigvalsh(A)\n            return eigenvalues[-1] / eigenvalues[0]\n\n        kappa_Sigma_x = condition_number_2(Sigma_x)\n        kappa_Sigma_z = condition_number_2(Sigma_z)\n\n        # Compute the ratio of condition numbers\n        ratio = kappa_Sigma_x / kappa_Sigma_z\n        results.append(f\"{ratio:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}