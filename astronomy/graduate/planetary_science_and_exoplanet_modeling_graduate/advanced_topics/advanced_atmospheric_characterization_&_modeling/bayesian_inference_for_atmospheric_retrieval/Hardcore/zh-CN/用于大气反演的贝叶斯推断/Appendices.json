{
    "hands_on_practices": [
        {
            "introduction": "在大气检索中，任何贝叶斯推断的第一步都是建立一个“正向模型”，它将大气物理参数（如温度、压力、化学成分）与可观测信号（如透射光谱）联系起来。这项实践练习  是一个基础性任务，要求你从第一性原理出发，推导出一个简化的、解析的透射光谱表达式。通过这个过程，你将深入理解行星大气结构如何塑造其光谱特征，并为更复杂的数值模型建立起至关重要的物理直觉。",
            "id": "4154218",
            "problem": "在一个贝叶斯推断框架内，为透射光谱学建立了一个系外行星大气模型，其中正向模型将成分和热力学参数映射到与波长相关的凌星半径。考虑一个球对称大气层，该大气层是等温的，并在恒定重力加速度 $g$ 下处于静流体平衡状态。设参考半径 $R_{0}$ 定义在参考压强 $P_{0}$ 处，在该压强下，更低海拔的大气层变得不透明。假设理想气体定律成立，其中玻尔兹曼常数为 $k_{B}$，平均粒子质量为 $\\mu$ 且均匀，并且存在单一吸收物种，其体积混合比 $\\xi$ 和吸收截面 $\\sigma_{\\lambda}$ 均为常数，且不依赖于温度和压强。设恒星半径为 $R_{\\star}$，并假设薄大气层极限 $H \\ll R_{0}$，其中 $H$ 是等温静流体条件下的压强标高。\n\n仅从静流体平衡 $dP/dr = -\\rho g$、理想气体定律 $P = n k_{B} T$ 以及沿碰撞参数为 $b$ 的射线穿过临边的弦光学深度积分的定义出发：\n$$\n\\tau_{\\lambda}(b) = \\int_{-\\infty}^{+\\infty} \\xi \\, \\sigma_{\\lambda} \\, n\\!\\left(\\sqrt{b^{2}+x^{2}}\\right) \\, dx,\n$$\n推导出行星波长相关的有效凌星半径 $R(\\lambda)$ 的解析表达式，该表达式在 $H/R_{0}$ 的领头阶上有效，该半径由掩食面积条件定义：\n$$\n\\pi R^{2}(\\lambda) = \\pi R_{0}^{2} + 2 \\pi \\int_{0}^{\\infty} \\left[1 - \\exp\\!\\left(-\\tau_{\\lambda}(R_{0}+z)\\right)\\right] (R_{0}+z) \\, dz.\n$$\n将 $R(\\lambda)$ 的最终闭式解用 $R_{0}$、$P_{0}$、$T$、$\\mu$、$g$、$\\xi$、$\\sigma_{\\lambda}$ 和基本常数表示，并使用参考高度处的数密度 $n_{0} = P_{0}/(k_{B} T)$。你可以假设并使用薄临边近似，即在切点附近，当 $|x| \\ll b$ 时，半径满足 $r \\approx b + x^{2}/(2b)$，其中 $b \\approx R_{0}+z$。该表达式应包括 $H/R_{0}$ 的所有领头阶项，包括临边积分产生的任何常数。\n\n最后，列举至少四个当该等温、静流体、单物种弦光学深度近似用于大气反演时科学上合理的局限性，并讨论在哪些情况下，所推导的正向模型会引入有偏推断。\n\n仅提供 $R(\\lambda)$ 的单一闭式解析表达式作为最终答案。最终答案中不包含任何单位。无需四舍五入。",
            "solution": "该问题是有效的，因为它具有科学依据、提法明确、客观，并为系外行星大气科学领域的标准推导提供了一个完整且一致的设置。\n\n推导过程主要分为三个阶段：首先，在给定假设下确定大气数密度剖面 $n(r)$；其次，计算弦光学深度 $\\tau_{\\lambda}(b)$；第三，将其代入有效凌星半径 $R(\\lambda)$ 的定义中，并计算积分至领头阶。\n\n**1. 大气密度剖面**\n\n我们从球对称大气在恒定重力加速度 $g$ 下的静流体平衡方程开始：\n$$\n\\frac{dP}{dr} = -\\rho g\n$$\n其中 $P$ 是压强，$r$ 是距行星中心的径向距离，$\\rho$ 是质量密度。密度通过 $\\rho = n\\mu$ 与数密度 $n$ 和平均粒子质量 $\\mu$ 相关联。代入此关系式得：\n$$\n\\frac{dP}{dr} = -n\\mu g\n$$\n假设大气遵循理想气体定律 $P = n k_B T$，其中 $k_B$ 是玻尔兹曼常数，$T$ 是恒定温度。我们可以将数密度表示为 $n = P/(k_B T)$。将其代入静流体平衡方程得到：\n$$\n\\frac{dP}{dr} = -\\frac{P}{k_B T}\\mu g\n$$\n这是一个关于 $P(r)$ 的一阶线性常微分方程。我们可以重新整理它以分离变量：\n$$\n\\frac{dP}{P} = -\\frac{\\mu g}{k_B T} dr\n$$\n我们定义压强标高 $H$ 为压强变化一个因子 $e$ 的特征垂直长度尺度。对于等温大气，它是一个常数：\n$$\nH = \\frac{k_B T}{\\mu g}\n$$\n将 $H$ 代入微分方程得到：\n$$\n\\frac{dP}{P} = -\\frac{1}{H} dr\n$$\n我们从参考层 $(R_0, P_0)$ 到任意层 $(r, P(r))$ 对此方程进行积分：\n$$\n\\int_{P_0}^{P(r)} \\frac{dP'}{P'} = \\int_{R_0}^{r} -\\frac{1}{H} dr'\n$$\n$$\n\\ln\\left(\\frac{P(r)}{P_0}\\right) = -\\frac{r-R_0}{H}\n$$\n解出 $P(r)$，我们得到压强剖面：\n$$\nP(r) = P_0 \\exp\\left(-\\frac{r-R_0}{H}\\right)\n$$\n由于 $n = P/(k_B T)$ 且 $T$ 是常数，数密度剖面遵循相同的指数形式：\n$$\nn(r) = \\frac{P_0}{k_B T} \\exp\\left(-\\frac{r-R_0}{H}\\right) = n_0 \\exp\\left(-\\frac{r-R_0}{H}\\right)\n$$\n其中 $n_0 = P_0/(k_B T)$ 是参考半径 $R_0$ 处的数密度。\n\n**2. 弦光学深度**\n\n沿碰撞参数为 $b$ 的射线穿过大气临边的弦光学深度 $\\tau_{\\lambda}(b)$ 由以下积分给出：\n$$\n\\tau_{\\lambda}(b) = \\int_{-\\infty}^{+\\infty} \\xi \\, \\sigma_{\\lambda} \\, n(r) \\, dx\n$$\n这里，$x$ 是沿射线的坐标，在最近点处 $x=0$。径向距离 $r$ 与 $b$ 和 $x$ 的关系为 $r = \\sqrt{b^2 + x^2}$。将密度剖面代入积分中：\n$$\n\\tau_{\\lambda}(b) = \\int_{-\\infty}^{+\\infty} \\xi \\, \\sigma_{\\lambda} \\, n_0 \\exp\\left(-\\frac{\\sqrt{b^2 + x^2} - R_0}{H}\\right) \\, dx\n$$\n问题指定在切点附近使用薄临边近似来处理径向距离，该近似对 $|x| \\ll b$ 有效：\n$$\nr = \\sqrt{b^2 + x^2} = b\\sqrt{1 + (x/b)^2} \\approx b\\left(1 + \\frac{x^2}{2b^2}\\right) = b + \\frac{x^2}{2b}\n$$\n这个近似是有效的，因为由于标高 $H$ 很小，被积函数中的指数项在远离 $x=0$ 处迅速减小，所以积分的主要贡献来自 $|x|$ 很小的区域。将这个 $r$ 的近似代入：\n$$\n\\tau_{\\lambda}(b) \\approx \\int_{-\\infty}^{+\\infty} \\xi \\, \\sigma_{\\lambda} \\, n_0 \\exp\\left(-\\frac{b + x^2/(2b) - R_0}{H}\\right) \\, dx\n$$\n我们可以将指数中不依赖于 $x$ 的项分离出来：\n$$\n\\tau_{\\lambda}(b) \\approx \\xi \\, \\sigma_{\\lambda} \\, n_0 \\exp\\left(-\\frac{b - R_0}{H}\\right) \\int_{-\\infty}^{+\\infty} \\exp\\left(-\\frac{x^2}{2bH}\\right) \\, dx\n$$\n剩下的积分是标准的高斯积分，形式为 $\\int_{-\\infty}^{+\\infty} \\exp(-ax^2)dx = \\sqrt{\\pi/a}$。在我们的例子中，$a = 1/(2bH)$，所以积分结果为 $\\sqrt{2\\pi bH}$。这给出了弦光学深度为：\n$$\n\\tau_{\\lambda}(b) \\approx \\xi \\, \\sigma_{\\lambda} \\, n_0 \\sqrt{2\\pi bH} \\exp\\left(-\\frac{b - R_0}{H}\\right)\n$$\n\n**3. 有效凌星半径**\n\n有效凌星半径 $R(\\lambda)$ 由总掩食面积定义：\n$$\n\\pi R^{2}(\\lambda) = \\pi R_{0}^{2} + 2 \\pi \\int_{0}^{\\infty} \\left[1 - \\exp(-\\tau_{\\lambda}(R_{0}+z))\\right] (R_{0}+z) \\, dz\n$$\n这里，积分变量是参考不透明层 $R_0$ 以上的高度 $z$，碰撞参数是 $b = R_0 + z$。我们首先用 $b=R_0+z$ 代入我们的 $\\tau_{\\lambda}(b)$ 表达式：\n$$\n\\tau_{\\lambda}(R_0+z) \\approx \\xi \\sigma_{\\lambda} n_0 \\sqrt{2\\pi (R_0+z)H} \\exp\\left(-\\frac{(R_0+z)-R_0}{H}\\right) = \\xi \\sigma_{\\lambda} n_0 \\sqrt{2\\pi (R_0+z)H} \\exp\\left(-\\frac{z}{H}\\right)\n$$\n在薄大气层极限（$H \\ll R_0$）下，只有当 $z/R_0$ 的值很小时，被积函数才显著。因此，我们可以做领头阶近似，即在随 $z$ 缓慢变化的项中，$(R_0+z) \\approx R_0$。这适用于积分中的因子 $(R_0+z)$ 和光学深度表达式中的 $\\sqrt{R_0+z}$ 项。这得到：\n$$\n\\pi (R^2(\\lambda) - R_0^2) \\approx 2\\pi R_0 \\int_{0}^{\\infty} \\left[1 - \\exp\\left(-\\left(\\xi \\sigma_{\\lambda} n_0 \\sqrt{2\\pi R_0 H}\\right) \\exp(-z/H)\\right)\\right] dz\n$$\n我们将参考高度层 $z=0$（掠过 $R_0$）处的光学深度定义为 $\\tau_0(\\lambda)$：\n$$\n\\tau_0(\\lambda) = \\xi \\sigma_{\\lambda} n_0 \\sqrt{2\\pi R_0 H}\n$$\n积分变为：\n$$\nR^2(\\lambda) - R_0^2 \\approx 2R_0 \\int_{0}^{\\infty} \\left[1 - \\exp\\left(-\\tau_0(\\lambda) \\exp(-z/H)\\right)\\right] dz\n$$\n为了求解这个积分，我们进行换元。令 $u = \\tau_0(\\lambda) \\exp(-z/H)$。则 $du = -\\frac{1}{H} \\tau_0(\\lambda) \\exp(-z/H) dz = -\\frac{u}{H} dz$，这意味着 $dz = -\\frac{H}{u} du$。积分上下限从 $z \\in [0, \\infty)$ 变为 $u \\in [\\tau_0(\\lambda), 0]$。\n$$\n\\int_{0}^{\\infty} \\dots dz = \\int_{\\tau_0(\\lambda)}^{0} [1 - \\exp(-u)] \\left(-\\frac{H}{u}\\right) du = H \\int_{0}^{\\tau_0(\\lambda)} \\frac{1-\\exp(-u)}{u} du\n$$\n这个积分定义了指数积分函数 $\\text{Ein}(x) = \\int_0^x \\frac{1-e^{-t}}{t} dt$。对于大的自变量（这对于定义凌星半径的光学深度来说是一个合理的假设），该函数具有渐近展开 $\\text{Ein}(x) \\approx \\gamma + \\ln(x)$，其中 $\\gamma \\approx 0.5772$ 是欧拉-马歇罗尼常数。这个常数来自积分，必须包含在内。\n因此，积分的计算结果为 $H(\\gamma + \\ln(\\tau_0(\\lambda)))$。\n将此结果代回 $R^2(\\lambda)$ 的表达式中：\n$$\nR^2(\\lambda) - R_0^2 \\approx 2R_0 H (\\gamma + \\ln(\\tau_0(\\lambda)))\n$$\n$$\nR^2(\\lambda) \\approx R_0^2 \\left[1 + \\frac{2H}{R_0}(\\gamma + \\ln(\\tau_0(\\lambda)))\\right]\n$$\n取平方根并使用一阶二项式近似 $(1+x)^{1/2} \\approx 1 + x/2$（对于小的 $x = \\frac{2H}{R_0}(\\dots)$），这在薄大气层极限 $H \\ll R_0$ 下是有效的：\n$$\nR(\\lambda) \\approx R_0 \\left[1 + \\frac{1}{2} \\frac{2H}{R_0}(\\gamma + \\ln(\\tau_0(\\lambda)))\\right] = R_0 + H(\\gamma + \\ln(\\tau_0(\\lambda)))\n$$\n最后，我们代入 $H$、$n_0$ 和 $\\tau_0(\\lambda)$ 的表达式，得到 $R(\\lambda)$ 的最终闭式解：\n$$\nR(\\lambda) = R_0 + H \\left(\\gamma + \\ln\\left(\\xi \\sigma_{\\lambda} n_0 \\sqrt{2\\pi R_0 H}\\right)\\right)\n$$\n$$\nR(\\lambda) = R_0 + \\frac{k_B T}{\\mu g} \\left(\\gamma + \\ln\\left(\\xi \\sigma_{\\lambda} \\frac{P_0}{k_B T} \\sqrt{2\\pi R_0 \\frac{k_B T}{\\mu g}}\\right)\\right)\n$$\n该表达式以指定的物理参数和基本常数给出了与波长相关的有效凌星半径。\n\n**模型的局限性**\n\n所推导的正向模型虽然在解析上很方便，但依赖于几个强的简化假设。如果真实行星大气不满足这些假设，可能会在从观测数据中反演参数时引入显著的偏差。四个突出的局限性是：\n\n1.  **等温假设：** 真实的行星大气具有随高度变化的温度-压强剖面，这是由辐射加热/冷却和动力学过程引起的。等温模型为整个大气指定一个单一的温度 $T$，导致标高 $H$ 是恒定的。实际上，$H$ 是高度的函数，$H(r)$。例如，具有逆温的平流层会使大气在高海拔处的膨胀程度超过等温模型的预测。用等温模型拟合来自这样大气的数据将导致有偏的反演结果，可能高估吸收物丰度或错误地描述参考压强水平。\n\n2.  **恒定体积混合比（$\\xi$）：** 该模型假设吸收物种在整个大气中均匀混合。实际上，由于光化学过程（例如，高空分子被恒星紫外线辐射离解）、凝结（例如，在冷阱处形成水冰云）和扩散分离（较轻的物种在大气顶部富集）等过程，混合比会随高度变化。对具有垂直变化成分的大气使用恒定$\\xi$模型，将得到一个反演丰度，该丰度是一个复杂的、按高度加权的平均值，可能不代表任何特定大气层，从而使我们对行星大气化学的理解产生偏差。\n\n3.  **与压强和温度无关的截面（$\\sigma_{\\lambda}$）：** 分子的吸收截面不是恒定的；它取决于当地的温度和压强。这些效应会使谱线展宽，改变其形状。压强（或碰撞）展宽在较低、较密的大气区域占主导地位，而热（多普勒）展宽在较高、较热、较稀薄的区域更为显著。通过忽略谱线展宽，该模型错误地表示了光谱特征的形状。这可能导致反演的温度剖面和丰度出现显著错误，因为模型无法正确解释强吸收线翼部包含的信息。\n\n4.  **忽略云和霾：** 该模型仅考虑了气体吸收。真实的系外行星大气经常含有气溶胶，例如云（凝结物）或光化学霾。这些粒子提供了一个重要的不透明度来源，其通常是波长的平滑函数，并且可以掩盖某一高度以下的气体吸收特征。当存在气溶胶时忽略它们，会迫使反演模型错误地解释被减弱的光谱特征，通常导致严重低估气体丰度，并得到一个被错误地平坦化（更接近等温）的温度剖面。这是大气反演中一个众所周知的简并性问题。",
            "answer": "$$\\boxed{R_0 + \\frac{k_B T}{\\mu g} \\left(\\gamma + \\ln\\left(\\xi \\sigma_{\\lambda} \\frac{P_0}{k_B T} \\sqrt{2\\pi R_0 \\frac{k_B T}{\\mu g}}\\right)\\right)}$$"
        },
        {
            "introduction": "在建立了物理模型之后，下一步就是用它来分析真实的观测数据。在实践中，我们常常需要融合来自不同仪器的数据，每种仪器都有其独特的噪声特性和系统效应。这项实践  模拟了一个真实的研究场景：你将联合分析来自两台仪器的两个独立数据集，以约束一组共享的大气参数，同时处理仪器特定的“讨厌参数”。通过这项练习，你将掌握如何利用贝叶斯框架自然地整合多源信息，并稳健地从数据中提取科学结论。",
            "id": "4154226",
            "problem": "考虑一个简化的系外行星透射光谱学大气反演问题，其中观测者从两个具有不同噪声协方差的仪器收集了两个独立的数据集。每个数据集中的信号都通过围绕参考大气状态的线性化正向模型进行建模，这与辐射传输中的标准一阶灵敏度分析一致。设共享的大气状态向量为 $\\mathbf{x} \\in \\mathbb{R}^2$，其分量为 $\\mathbf{x} = [T,\\ \\ln q]^\\top$，其中 $T$ 是温度（单位为开尔文），$\\ln q$ 是体积混合比的自然对数（无量纲）。每个仪器 $i \\in \\{1,2\\}$ 都有一个特定于仪器的讨厌参数 $w_i \\in \\mathbb{R}$，表示一个在其所有光谱通道上都保持恒定的标量基线偏移（无量纲）。对于数据集 $i$，假设观测向量 $\\mathbf{y}_i \\in \\mathbb{R}^{m_i}$ 与参数的关系如下：\n$$\n\\mathbf{y}_i = \\mathbf{J}_i \\mathbf{x} + \\mathbf{L}_i w_i + \\boldsymbol{\\epsilon}_i,\n$$\n其中 $\\mathbf{J}_i \\in \\mathbb{R}^{m_i \\times 2}$ 是凌星深度相对于大气参数 $(T,\\ \\ln q)$ 的线性化雅可比矩阵，$\\mathbf{L}_i \\in \\mathbb{R}^{m_i \\times 1}$ 将标量偏移映射到所有通道（一个由1组成的列向量），$\\boldsymbol{\\epsilon}_i \\sim \\mathcal{N}(\\mathbf{0}, \\boldsymbol{\\Sigma}_i)$ 是已知协方差为 $\\boldsymbol{\\Sigma}_i$ 的高斯噪声。假设在给定参数的情况下，数据集是条件独立的，因此联合似然可以分解。\n\n对所有参数采用高斯先验，\n$$\n\\mathbf{x} \\sim \\mathcal{N}(\\boldsymbol{\\mu}_x,\\ \\boldsymbol{\\Sigma}_x), \\quad w_1 \\sim \\mathcal{N}(\\mu_{w_1},\\ \\sigma_{w_1}^2), \\quad w_2 \\sim \\mathcal{N}(\\mu_{w_2},\\ \\sigma_{w_2}^2),\n$$\n参数向量 $\\boldsymbol{\\theta} = [T,\\ \\ln q,\\ w_1,\\ w_2]^\\top \\in \\mathbb{R}^4$ 的联合先验协方差为块对角形式，其级联先验均值由下式给出：\n$$\n\\boldsymbol{\\mu}_0 = \\begin{bmatrix}\\boldsymbol{\\mu}_x \\\\ \\mu_{w_1} \\\\ \\mu_{w_2}\\end{bmatrix}, \\quad \\mathbf{S}_0 = \\mathrm{diag}(\\boldsymbol{\\Sigma}_x,\\ \\sigma_{w_1}^2,\\ \\sigma_{w_2}^2).\n$$\n设级联观测向量为 $\\mathbf{y} = [\\mathbf{y}_1^\\top,\\ \\mathbf{y}_2^\\top]^\\top \\in \\mathbb{R}^{m_1+m_2}$。将 $\\boldsymbol{\\theta}$ 映射到 $\\mathbf{y}$ 的全局设计矩阵是\n$$\n\\mathbf{H} \\in \\mathbb{R}^{(m_1+m_2)\\times 4}, \\quad\n\\mathbf{H} = \\begin{bmatrix}\n\\mathbf{J}_1 & \\mathbf{L}_1 & \\mathbf{0}_{m_1\\times 1} \\\\\n\\mathbf{J}_2 & \\mathbf{0}_{m_2\\times 1} & \\mathbf{L}_2\n\\end{bmatrix}.\n$$\n联合噪声协方差是块对角的，\n$$\n\\boldsymbol{\\Sigma} = \\begin{bmatrix}\n\\boldsymbol{\\Sigma}_1 & \\mathbf{0} \\\\\n\\mathbf{0} & \\boldsymbol{\\Sigma}_2\n\\end{bmatrix}.\n$$\n在这些假设下，$\\boldsymbol{\\theta}$ 的联合后验分布是高斯分布。你的任务是计算联合后验均值和协方差，然后报告 $\\boldsymbol{\\theta}$ 各个分量的边缘约束（后验均值和标准差）。\n\n使用的基本原理：\n- 贝叶斯法则，结合高斯先验和高斯似然，为线性模型生成高斯后验。\n- 多元正态分布的性质，特别是信息形式和共轭性。\n\n数学目标：\n- 推导并实现线性高斯模型的后验精度和均值，\n$$\n\\mathbf{J}_{\\text{post}} = \\mathbf{S}_0^{-1} + \\mathbf{H}^\\top \\boldsymbol{\\Sigma}^{-1} \\mathbf{H}, \\quad\n\\boldsymbol{\\mu}_{\\text{post}} = \\mathbf{J}_{\\text{post}}^{-1}\\left(\\mathbf{S}_0^{-1}\\boldsymbol{\\mu}_0 + \\mathbf{H}^\\top \\boldsymbol{\\Sigma}^{-1}\\mathbf{y}\\right),\n$$\n并从 $\\mathbf{J}_{\\text{post}}^{-1}$ 中提取边缘方差。\n\n单位和报告要求：\n- 报告 $T$ 的后验均值和标准差，单位为开尔文。\n- 报告 $\\ln q$ 的后验均值和标准差，为无量纲值。\n- 报告 $w_1$ 和 $w_2$ 的后验均值和标准差，为无量纲值。\n- 所有报告的量都必须是浮点数。不涉及角度单位。不涉及百分比。\n\n测试套件和参数规范：\n使用以下三个测试用例，每个用例中数据集1有 $m_1 = 3$ 个通道，数据集2有 $m_2 = 4$ 个通道。在所有情况下，$\\mathbf{L}_1$ 和 $\\mathbf{L}_2$ 分别是长度为 $m_1$ 和 $m_2$ 的全1列向量。\n\n所有用例的共享先验：\n- $\\boldsymbol{\\mu}_x = [1000,\\ -5]^\\top$，单位为 $[\\,\\mathrm{K},\\ \\text{无量纲}\\,]$。\n- $\\boldsymbol{\\Sigma}_x = \\mathrm{diag}([100^2,\\ 1^2])$。\n- $\\mu_{w_1} = 0$，$\\sigma_{w_1} = 0.01$。\n- $\\mu_{w_2} = 0$，$\\sigma_{w_2} = 0.02$。\n\n用例 1（噪声均衡，数据集2中度相关）：\n- $\\mathbf{y}_1 = [0.01225,\\ 0.01080,\\ 0.00950]^\\top$。\n- $\\mathbf{y}_2 = [0.01360,\\ 0.01310,\\ 0.00990,\\ 0.00920]^\\top$。\n- $\\mathbf{J}_1 = \\begin{bmatrix}\n1.2\\times 10^{-5} & 6.0\\times 10^{-4} \\\\\n1.0\\times 10^{-5} & 5.0\\times 10^{-4} \\\\\n0.8\\times 10^{-5} & 4.0\\times 10^{-4}\n\\end{bmatrix}$。\n- $\\mathbf{J}_2 = \\begin{bmatrix}\n1.5\\times 10^{-5} & 7.0\\times 10^{-4} \\\\\n1.4\\times 10^{-5} & 6.0\\times 10^{-4} \\\\\n1.0\\times 10^{-5} & 5.0\\times 10^{-4} \\\\\n0.9\\times 10^{-5} & 4.5\\times 10^{-4}\n\\end{bmatrix}$。\n- $\\boldsymbol{\\Sigma}_1 = \\mathrm{diag}([1.0\\times 10^{-6},\\ 2.0\\times 10^{-6},\\ 1.5\\times 10^{-6}])$。\n- $\\boldsymbol{\\Sigma}_2$ 由方差 $[1.2\\times 10^{-6},\\ 1.2\\times 10^{-6},\\ 1.5\\times 10^{-6},\\ 1.5\\times 10^{-6}]$ 和相关系数 $\\rho = 0.6$ 通过以下公式构建：\n$$\n(\\boldsymbol{\\Sigma}_2)_{ij} = \\rho^{|i-j|}\\,\\sqrt{v_i v_j}, \\quad \\text{其中 } v_i \\text{ 为指定的方差}。\n$$\n\n用例 2（数据集2高噪声、弱相关）：\n- $\\mathbf{y}_1 = [0.01200,\\ 0.01070,\\ 0.00940]^\\top$。\n- $\\mathbf{y}_2 = [0.01380,\\ 0.01300,\\ 0.00970,\\ 0.00910]^\\top$。\n- $\\mathbf{J}_1$ 和 $\\mathbf{J}_2$ 与用例 1 相同。\n- $\\boldsymbol{\\Sigma}_1 = \\mathrm{diag}([1.0\\times 10^{-6},\\ 2.0\\times 10^{-6},\\ 1.5\\times 10^{-6}])$。\n- $\\boldsymbol{\\Sigma}_2$ 由方差 $[4.0\\times 10^{-6},\\ 4.0\\times 10^{-6},\\ 3.5\\times 10^{-6},\\ 3.5\\times 10^{-6}]$ 和相关系数 $\\rho = 0.3$ 通过相同公式构建。\n\n用例 3（数据集2强相关且低噪声；数据集1低噪声）：\n- $\\mathbf{y}_1 = [0.01230,\\ 0.01060,\\ 0.00960]^\\top$。\n- $\\mathbf{y}_2 = [0.01350,\\ 0.01320,\\ 0.00980,\\ 0.00930]^\\top$。\n- $\\mathbf{J}_1$ 和 $\\mathbf{J}_2$ 与用例 1 相同。\n- $\\boldsymbol{\\Sigma}_1 = \\mathrm{diag}([1.0\\times 10^{-6},\\ 1.0\\times 10^{-6},\\ 1.0\\times 10^{-6}])$。\n- $\\boldsymbol{\\Sigma}_2$ 由方差 $[1.0\\times 10^{-6},\\ 1.0\\times 10^{-6},\\ 1.0\\times 10^{-6},\\ 1.0\\times 10^{-6}]$ 和相关系数 $\\rho = 0.95$ 通过相同公式构建。\n\n实现说明：\n- 为每个用例精确地按照规定构建 $\\mathbf{H}$ 和 $\\boldsymbol{\\Sigma}$。\n- 使用信息形式计算 $\\mathbf{J}_{\\text{post}}$ 和 $\\boldsymbol{\\mu}_{\\text{post}}$。计算后验协方差 $\\mathbf{C}_{\\text{post}} = \\mathbf{J}_{\\text{post}}^{-1}$。\n- 按顺序 $[T,\\ \\ln q,\\ w_1,\\ w_2]$ 提取每个参数的边缘后验均值和标准差。\n\n要求的最终输出格式：\n- 你的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表。\n- 每个测试用例的结果必须是一个包含四个参数摘要的列表，按 $[T,\\ \\ln q,\\ w_1,\\ w_2]$ 排序，每个参数摘要本身必须是一个双元素列表 $[\\text{均值},\\ \\text{标准差}]$。\n- 因此，最终输出必须如下所示：\n$$\n[[\\mu_T,\\ \\sigma_T,\\ \\mu_{\\ln q},\\ \\sigma_{\\ln q},\\ \\mu_{w_1},\\ \\sigma_{w_1},\\ \\mu_{w_2},\\ \\sigma_{w_2}],\\ \\ldots]\n$$\n聚合三个用例的结果，所有值均为浮点数。$T$ 以 $\\mathrm{K}$ 表示，所有其他量均为无量纲数。不应打印任何额外文本。",
            "solution": "该问题要求在一个简化的大气反演模型中，计算一组参数的后验分布。该模型是线性的，噪声被假设为高斯分布，并且参数的先验分布也是高斯分布。这种设置是贝叶斯线性回归的经典范例，其后验分布也是高斯分布，并且可以解析地推导出来。\n\n整体模型结合了两个数据集，并可以用一种紧凑的全局形式表示。设完整参数向量为 $\\boldsymbol{\\theta} = [T, \\ln q, w_1, w_2]^\\top \\in \\mathbb{R}^4$。级联观测向量 $\\mathbf{y} = [\\mathbf{y}_1^\\top, \\mathbf{y}_2^\\top]^\\top \\in \\mathbb{R}^{m_1+m_2}$ 通过以下线性模型与参数相关联：\n$$\n\\mathbf{y} = \\mathbf{H}\\boldsymbol{\\theta} + \\boldsymbol{\\epsilon}\n$$\n其中 $\\mathbf{H}$ 是将参数映射到观测值的全局设计矩阵，而 $\\boldsymbol{\\epsilon} \\sim \\mathcal{N}(\\mathbf{0}, \\boldsymbol{\\Sigma})$ 表示具有块对角协方差矩阵 $\\boldsymbol{\\Sigma}$ 的级联高斯噪声。\n\n贝叶斯法则指出，后验概率密度与似然和先验的乘积成正比：\n$$\np(\\boldsymbol{\\theta} | \\mathbf{y}) \\propto p(\\mathbf{y} | \\boldsymbol{\\theta}) p(\\boldsymbol{\\theta})\n$$\n在此问题中，从带有高斯噪声的线性模型推导出的似然，以及先验，都是多元正态分布。\n似然为 $p(\\mathbf{y} | \\boldsymbol{\\theta}) = \\mathcal{N}(\\mathbf{y}; \\mathbf{H}\\boldsymbol{\\theta}, \\boldsymbol{\\Sigma})$，其概率密度函数正比于：\n$$\n\\exp\\left(-\\frac{1}{2}(\\mathbf{y} - \\mathbf{H}\\boldsymbol{\\theta})^\\top \\boldsymbol{\\Sigma}^{-1} (\\mathbf{y} - \\mathbf{H}\\boldsymbol{\\theta})\\right)\n$$\n先验为 $p(\\boldsymbol{\\theta}) = \\mathcal{N}(\\boldsymbol{\\theta}; \\boldsymbol{\\mu}_0, \\mathbf{S}_0)$，其概率密度函数正比于：\n$$\n\\exp\\left(-\\frac{1}{2}(\\boldsymbol{\\theta} - \\boldsymbol{\\mu}_0)^\\top \\mathbf{S}_0^{-1} (\\boldsymbol{\\theta} - \\boldsymbol{\\mu}_0)\\right)\n$$\n这两个函数的乘积得到后验分布，它也将是一个高斯分布 $\\mathcal{N}(\\boldsymbol{\\theta}; \\boldsymbol{\\mu}_{\\text{post}}, \\mathbf{C}_{\\text{post}})$。后验分布的指数项是似然和先验分布的指数项之和。通过展开这些二次型并合并各项，可以确定后验精度矩阵 $\\mathbf{J}_{\\text{post}} = \\mathbf{C}_{\\text{post}}^{-1}$ 和后验均值 $\\boldsymbol{\\mu}_{\\text{post}}$。这个著名推导的结果是：\n$$\n\\mathbf{J}_{\\text{post}} = \\mathbf{S}_0^{-1} + \\mathbf{H}^\\top \\boldsymbol{\\Sigma}^{-1} \\mathbf{H}\n$$\n$$\n\\boldsymbol{\\mu}_{\\text{post}} = \\mathbf{J}_{\\text{post}}^{-1} \\left( \\mathbf{S}_0^{-1}\\boldsymbol{\\mu}_0 + \\mathbf{H}^\\top \\boldsymbol{\\Sigma}^{-1}\\mathbf{y} \\right)\n$$\n这些是问题陈述中提供的公式，我们将予以实现。$\\mathbf{S}_0^{-1}$ 是先验精度矩阵，而 $\\mathbf{H}^\\top \\boldsymbol{\\Sigma}^{-1} \\mathbf{H}$ 是数据贡献的精度（或费雪信息）。后验精度就是先验精度与数据精度的和。\n\n每个测试用例的计算过程如下：\n$1$. 构建先验均值向量 $\\boldsymbol{\\mu}_0 \\in \\mathbb{R}^4$ 和先验协方差矩阵 $\\mathbf{S}_0 \\in \\mathbb{R}^{4 \\times 4}$。先验协方差 $\\mathbf{S}_0$ 是对角矩阵，因此其逆矩阵，即先验精度 $\\mathbf{S}_0^{-1}$，可以通过对其对角元素取倒数轻易求得。\n$2$. 通过级联观测向量 $\\mathbf{y}_1 \\in \\mathbb{R}^3$ 和 $\\mathbf{y}_2 \\in \\mathbb{R}^4$ 来构建全局观测向量 $\\mathbf{y} \\in \\mathbb{R}^{7}$。\n$3$. 通过将雅可比矩阵 $\\mathbf{J}_1$ 和 $\\mathbf{J}_2$ 以及偏移映射向量 $\\mathbf{L}_1$ 和 $\\mathbf{L}_2$ 组装成指定的块结构来构建全局设计矩阵 $\\mathbf{H} \\in \\mathbb{R}^{7 \\times 4}$。\n$4$. 构建全局噪声协方差矩阵 $\\boldsymbol{\\Sigma} \\in \\mathbb{R}^{7 \\times 7}$。这是一个由 $\\boldsymbol{\\Sigma}_1 \\in \\mathbb{R}^{3 \\times 3}$ 和 $\\boldsymbol{\\Sigma}_2 \\in \\mathbb{R}^{4 \\times 4}$ 组成的块对角矩阵。对于每个用例，$\\boldsymbol{\\Sigma}_1$ 都以对角矩阵的形式给出。矩阵 $\\boldsymbol{\\Sigma}_2$ 必须使用公式 $(\\boldsymbol{\\Sigma}_2)_{ij} = \\rho^{|i-j|}\\sqrt{v_i v_j}$ 从给定的通道方差 $v_i$ 和相关系数 $\\rho$ 构建。\n$5$. 计算噪声协方差矩阵的逆矩阵 $\\boldsymbol{\\Sigma}^{-1}$。由于 $\\boldsymbol{\\Sigma}$ 是块对角的，其逆矩阵也是块对角的，其块为 $\\boldsymbol{\\Sigma}_1^{-1}$ 和 $\\boldsymbol{\\Sigma}_2^{-1}$。\n$6$. 计算后验精度矩阵 $\\mathbf{J}_{\\text{post}}$ 和后验协方差矩阵 $\\mathbf{C}_{\\text{post}} = \\mathbf{J}_{\\text{post}}^{-1}$。\n$7$. 计算后验均值向量 $\\boldsymbol{\\mu}_{\\text{post}}$。\n$8$. 提取边缘后验均值和标准差。均值是 $\\boldsymbol{\\mu}_{\\text{post}}$ 的元素。方差是 $\\mathbf{C}_{\\text{post}}$ 的对角元素，标准差是它们的平方根。\n\n此过程应用于三个测试用例中的每一个，并以指定格式报告结果。所有矩阵运算都使用数值线性代数程序执行。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Bayesian atmospheric retrieval problem for the three specified test cases.\n    \"\"\"\n    # Shared prior parameters for all cases\n    mu_x = np.array([1000.0, -5.0])\n    Sigma_x = np.diag([100.0**2, 1.0**2])\n    mu_w1, sigma_w1 = 0.0, 0.01\n    mu_w2, sigma_w2 = 0.0, 0.02\n    \n    mu0 = np.array([mu_x[0], mu_x[1], mu_w1, mu_w2])\n    S0 = np.block([\n        [Sigma_x, np.zeros((2, 2))],\n        [np.zeros((2, 2)), np.diag([sigma_w1**2, sigma_w2**2])]\n    ])\n    \n    # Test cases definition\n    J1 = np.array([\n        [1.2e-5, 6.0e-4],\n        [1.0e-5, 5.0e-4],\n        [0.8e-5, 4.0e-4]\n    ])\n    \n    J2 = np.array([\n        [1.5e-5, 7.0e-4],\n        [1.4e-5, 6.0e-4],\n        [1.0e-5, 5.0e-4],\n        [0.9e-5, 4.5e-4]\n    ])\n\n    test_cases = [\n        {\n            \"y1\": np.array([0.01225, 0.01080, 0.00950]),\n            \"y2\": np.array([0.01360, 0.01310, 0.00990, 0.00920]),\n            \"Sigma1_vars\": np.array([1.0e-6, 2.0e-6, 1.5e-6]),\n            \"Sigma2_vars\": np.array([1.2e-6, 1.2e-6, 1.5e-6, 1.5e-6]),\n            \"Sigma2_rho\": 0.6\n        },\n        {\n            \"y1\": np.array([0.01200, 0.01070, 0.00940]),\n            \"y2\": np.array([0.01380, 0.01300, 0.00970, 0.00910]),\n            \"Sigma1_vars\": np.array([1.0e-6, 2.0e-6, 1.5e-6]),\n            \"Sigma2_vars\": np.array([4.0e-6, 4.0e-6, 3.5e-6, 3.5e-6]),\n            \"Sigma2_rho\": 0.3\n        },\n        {\n            \"y1\": np.array([0.01230, 0.01060, 0.00960]),\n            \"y2\": np.array([0.01350, 0.01320, 0.00980, 0.00930]),\n            \"Sigma1_vars\": np.array([1.0e-6, 1.0e-6, 1.0e-6]),\n            \"Sigma2_vars\": np.array([1.0e-6, 1.0e-6, 1.0e-6, 1.0e-6]),\n            \"Sigma2_rho\": 0.95\n        }\n    ]\n\n    def construct_sigma2(variances, rho):\n        \"\"\"Constructs the correlated covariance matrix Sigma_2.\"\"\"\n        n = len(variances)\n        stds = np.sqrt(variances)\n        sigma2 = np.zeros((n, n))\n        for i in range(n):\n            for j in range(n):\n                sigma2[i, j] = (rho**abs(i - j)) * stds[i] * stds[j]\n        return sigma2\n\n    def calculate_posterior(case_data):\n        \"\"\"\n        Calculates the posterior mean and standard deviation for a given case.\n        \"\"\"\n        m1, m2 = 3, 4\n        \n        # 1. Construct prior-related terms\n        S0_inv = np.linalg.inv(S0)\n        S0_inv_mu0 = S0_inv @ mu0\n        \n        # 2. Construct global vectors and matrices\n        y = np.concatenate((case_data[\"y1\"], case_data[\"y2\"]))\n        \n        L1 = np.ones((m1, 1))\n        L2 = np.ones((m2, 1))\n        H = np.block([\n            [J1, L1, np.zeros((m1, 1))],\n            [J2, np.zeros((m2, 1)), L2]\n        ])\n        \n        Sigma1 = np.diag(case_data[\"Sigma1_vars\"])\n        Sigma2 = construct_sigma2(case_data[\"Sigma2_vars\"], case_data[\"Sigma2_rho\"])\n        \n        Sigma = np.zeros((m1 + m2, m1 + m2))\n        Sigma[:m1, :m1] = Sigma1\n        Sigma[m1:, m1:] = Sigma2\n        \n        # 3. Perform Bayesian update\n        Sigma_inv = np.linalg.inv(Sigma)\n        H_T_Sigma_inv = H.T @ Sigma_inv\n        \n        J_post = S0_inv + H_T_Sigma_inv @ H\n        C_post = np.linalg.inv(J_post)\n        \n        mu_post = C_post @ (S0_inv_mu0 + H_T_Sigma_inv @ y)\n        \n        # 4. Extract marginals\n        posterior_stds = np.sqrt(np.diag(C_post))\n        \n        return mu_post, posterior_stds\n\n    results_strings = []\n    for case in test_cases:\n        means, stds = calculate_posterior(case)\n        case_result_values = []\n        for i in range(len(means)):\n            case_result_values.append(means[i])\n            case_result_values.append(stds[i])\n        \n        # Format the result for this case into a string \"[v1,v2,...]\"\n        case_string = f\"[{','.join(str(v) for v in case_result_values)}]\"\n        results_strings.append(case_string)\n\n    # Format the final output as a single string \"[[...],[...],[...]]\"\n    print(f\"[{','.join(results_strings)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "贝叶斯推断的强大之处不仅在于分析现有数据，更在于它为规划未来的观测提供了严谨的数学框架。这项实践练习  将引导你进入贝叶斯实验设计的核心，通过计算“预期信息增益”（Expected Information Gain, EIG）来量化不同观测策略的价值。你将学会如何定量地评估哪种仪器配置能够最有效地约束我们感兴趣的大气参数，从而最大限度地利用宝贵的望远镜时间，提升科学研究的效率。",
            "id": "4154230",
            "problem": "您的任务是基于大气检索的贝叶斯推断，为系外行星透射光谱设计一种仪器模式的算法推荐器。考虑一个等温、静力平衡的大气层，其中波段平均的凌星深度是根据名义状态下Beer–Lambert吸收和路径几何的线性化来建模的。检索参数为云顶气压和分子混合比。具体来说，将参数向量定义为$\\boldsymbol{\\theta} \\in \\mathbb{R}^3$，其分量为$\\boldsymbol{\\theta} = [\\log_{10} P_c,\\ \\log_{10} X_{\\mathrm{H_2O}},\\ \\log_{10} X_{\\mathrm{CH_4}}]$，这些分量是无量纲的。仪器模式$m$的测量模型是正向模型的线性高斯近似：$\\mathbf{y}_m = \\mathbf{A}_m \\boldsymbol{\\theta} + \\boldsymbol{\\varepsilon}_m$，其中$\\mathbf{A}_m$是从辐射传输在名义检索点周围的一阶泰勒展开推导出的灵敏度矩阵，而$\\boldsymbol{\\varepsilon}_m \\sim \\mathcal{N}(\\mathbf{0}, \\boldsymbol{\\Sigma}_{\\mathrm{n},m})$是协方差为$\\boldsymbol{\\Sigma}_{\\mathrm{n},m}$的零均值高斯测量噪声。假设一个高斯先验$\\boldsymbol{\\theta} \\sim \\mathcal{N}(\\boldsymbol{\\mu}, \\boldsymbol{\\Sigma}_{\\mathrm{p}})$。\n\n从Bayes定理和微分熵的定义出发，在线性高斯假设下，计算每种仪器模式的期望信息增益（EIG），即观测到$\\mathbf{y}_m$后$\\boldsymbol{\\theta}$熵的期望减少量。使用自然对数，因此EIG以nats为单位表示。然后为每个测试用例推荐具有最大EIG的模式。\n\n您的程序必须以数值稳定的方式实现计算，并尽可能避免显式矩阵求逆。请使用Cholesky分解和线性求解。最终程序必须输出一行，其中包含所有测试用例的所有结果，格式为方括号括起来的逗号分隔列表，具体如下所述。\n\n测试套件：\n\n测试用例$1$（理想路径，多个通道带对角噪声）：\n- 先验均值 $\\boldsymbol{\\mu}_1 = [-2.0,\\ -4.0,\\ -5.0]$。\n- 先验协方差 $\\boldsymbol{\\Sigma}_{\\mathrm{p},1} = \\begin{bmatrix} 0.30  & 0.08 & 0.02 \\\\ 0.08 & 0.50 & 0.10 \\\\ 0.02 & 0.10 & 0.40 \\end{bmatrix}$。\n- 模式 $0$:\n  - $\\mathbf{A}_{0} = \\begin{bmatrix} -0.8 & 1.2 & 0.1 \\\\ -0.5 & 0.9 & 0.5 \\end{bmatrix}$。\n  - $\\boldsymbol{\\Sigma}_{\\mathrm{n},0} = \\operatorname{diag}([400,\\ 625])$。\n- 模式 $1$:\n  - $\\mathbf{A}_{1} = \\begin{bmatrix} -0.7 & 1.0 & 0.2 \\\\ -0.6 & 0.4 & 1.1 \\\\ -0.2 & 0.7 & 0.3 \\end{bmatrix}$。\n  - $\\boldsymbol{\\Sigma}_{\\mathrm{n},1} = \\operatorname{diag}([225,\\ 225,\\ 225])$。\n- 模式 $2$:\n  - $\\mathbf{A}_{2} = \\begin{bmatrix} -0.9 & 1.1 & 0.3 \\\\ -0.4 & 0.8 & 0.6 \\\\ -0.3 & 0.5 & 0.4 \\\\ -0.1 & 0.2 & 0.1 \\end{bmatrix}$。\n  - $\\boldsymbol{\\Sigma}_{\\mathrm{n},2} = \\operatorname{diag}([625,\\ 625,\\ 625,\\ 625])$。\n\n测试用例$2$（边界情况，包含一个极高噪声的模式）：\n- 先验均值 $\\boldsymbol{\\mu}_2 = [-1.5,\\ -3.8,\\ -5.2]$。\n- 先验协方差 $\\boldsymbol{\\Sigma}_{\\mathrm{p},2} = \\begin{bmatrix} 1.0 & 0.2 & 0.0 \\\\ 0.2 & 1.2 & 0.1 \\\\ 0.0 & 0.1 & 0.8 \\end{bmatrix}$。\n- 模式 $0$（极高噪声）：\n  - $\\mathbf{A}_{0} = \\begin{bmatrix} -0.5 & 0.9 & 0.4 \\\\ -0.4 & 0.7 & 0.3 \\\\ -0.3 & 0.6 & 0.2 \\end{bmatrix}$。\n  - $\\boldsymbol{\\Sigma}_{\\mathrm{n},0} = \\operatorname{diag}([10000,\\ 10000,\\ 10000])$。\n- 模式 $1$（更高精度，更少通道）：\n  - $\\mathbf{A}_{1} = \\begin{bmatrix} -0.6 & 1.1 & 0.0 \\\\ -0.2 & 0.4 & 1.2 \\end{bmatrix}$。\n  - $\\boldsymbol{\\Sigma}_{\\mathrm{n},1} = \\operatorname{diag}([100,\\ 144])$。\n\n测试用例$3$（跨通道相关噪声）：\n- 先验均值 $\\boldsymbol{\\mu}_3 = [-2.2,\\ -4.1,\\ -5.1]$。\n- 先验协方差 $\\boldsymbol{\\Sigma}_{\\mathrm{p},3} = \\begin{bmatrix} 0.4 & 0.05 & 0.05 \\\\ 0.05 & 0.6 & 0.0 \\\\ 0.05 & 0.0 & 0.5 \\end{bmatrix}$。\n- 模式 $0$:\n  - $\\mathbf{A}_{0} = \\begin{bmatrix} -0.6 & 0.8 & 0.6 \\\\ -0.1 & 0.2 & 1.0 \\\\ -0.4 & 0.7 & 0.1 \\end{bmatrix}$。\n  - $\\boldsymbol{\\Sigma}_{\\mathrm{n},0} = \\begin{bmatrix} 400 & 120 & 150 \\\\ 120 & 900 & 75 \\\\ 150 & 75 & 625 \\end{bmatrix}$。\n- 模式 $1$:\n  - $\\mathbf{A}_{1} = \\begin{bmatrix} -0.8 & 0.9 & 0.3 \\\\ -0.3 & 0.5 & 0.9 \\\\ -0.2 & 0.4 & 0.2 \\end{bmatrix}$。\n  - $\\boldsymbol{\\Sigma}_{\\mathrm{n},1} = \\begin{bmatrix} 225 & 75 & 0 \\\\ 75 & 400 & 0 \\\\ 0 & 0 & 225 \\end{bmatrix}$。\n\n您的任务：\n- 对于每个测试用例，在线性高斯检索近似下，使用自然对数计算每个候选仪器模式的EIG（以nats为单位）。\n- 推荐该测试用例中具有最大EIG的模式为最优模式。\n- 最终输出必须是单行，包含一个方括号括起来的逗号分隔列表。对于测试用例$1$，列出模式$0$、模式$1$和模式$2$的EIG值，后跟最优模式的整数索引（使用从$0$开始的索引）。对于测试用例$2$，列出模式$0$和模式$1$的EIG值，后跟最优索引。对于测试用例$3$，列出模式$0$和模式$1$的EIG值，后跟最优索引。总输出按顺序连接这些部分，得到$[EIG_{1,0},EIG_{1,1},EIG_{1,2},i_1,EIG_{2,0},EIG_{2,1},i_2,EIG_{3,0},EIG_{3,1},i_3]$其中$EIG_{t,m}$是测试用例$t$和模式$m$的EIG，$$i_t$$是测试用例$t$$的推荐模式索引。\n\n所有EIG值都是无量纲的，并且必须以nats表示。不需要进行物理单位转换。不涉及角度。不涉及百分比。",
            "solution": "所述问题是为系外行星透射光谱设计一种仪器模式的推荐器。推荐标准是期望信息增益（EIG），它是在大气检索问题的线性高斯近似下，在一个贝叶斯框架内计算得出的。\n\n### 问题验证\n\n**步骤1：提取已知条件**\n\n- **参数向量**: $\\boldsymbol{\\theta} \\in \\mathbb{R}^3$ 表示 $[\\log_{10} P_c,\\ \\log_{10} X_{\\mathrm{H_2O}},\\ \\log_{10} X_{\\mathrm{CH_4}}]$。\n- **先验分布**: 假设参数遵循高斯先验，$\\boldsymbol{\\theta} \\sim \\mathcal{N}(\\boldsymbol{\\mu}, \\boldsymbol{\\Sigma}_{\\mathrm{p}})$。\n- **测量模型（似然）**: 对于每个仪器模式$m$，测量向量$\\mathbf{y}_m$被建模为参数的线性函数加上加性高斯噪声：$\\mathbf{y}_m = \\mathbf{A}_m \\boldsymbol{\\theta} + \\boldsymbol{\\varepsilon}_m$，其中$\\boldsymbol{\\varepsilon}_m \\sim \\mathcal{N}(\\mathbf{0}, \\boldsymbol{\\Sigma}_{\\mathrm{n},m})$。这定义了似然为$p(\\mathbf{y}_m | \\boldsymbol{\\theta}) = \\mathcal{N}(\\mathbf{y}_m; \\mathbf{A}_m \\boldsymbol{\\theta}, \\boldsymbol{\\Sigma}_{\\mathrm{n},m})$。\n- **目标**: 计算每个模式的期望信息增益（EIG），定义为观测到$\\mathbf{y}_m$后$\\boldsymbol{\\theta}$熵的期望减少量。结果应以nats为单位（使用自然对数）。推荐具有最大EIG的模式。\n- **数值约束**: 实现应避免显式矩阵求逆，并使用Cholesky分解以保证数值稳定性。\n\n- **测试用例 1**:\n    - $\\boldsymbol{\\mu}_1 = [-2.0,\\ -4.0,\\ -5.0]$。\n    - $\\boldsymbol{\\Sigma}_{\\mathrm{p},1} = \\begin{bmatrix} 0.30 & 0.08 & 0.02 \\\\ 0.08 & 0.50 & 0.10 \\\\ 0.02 & 0.10 & 0.40 \\end{bmatrix}$。\n    - 模式 $0$: $\\mathbf{A}_{0} = \\begin{bmatrix} -0.8 & 1.2 & 0.1 \\\\ -0.5 & 0.9 & 0.5 \\end{bmatrix}$, $\\boldsymbol{\\Sigma}_{\\mathrm{n},0} = \\operatorname{diag}([400,\\ 625])$。\n    - 模式 $1$: $\\mathbf{A}_{1} = \\begin{bmatrix} -0.7 & 1.0 & 0.2 \\\\ -0.6 & 0.4 & 1.1 \\\\ -0.2 & 0.7 & 0.3 \\end{bmatrix}$, $\\boldsymbol{\\Sigma}_{\\mathrm{n},1} = \\operatorname{diag}([225,\\ 225,\\ 225])$。\n    - 模式 $2$: $\\mathbf{A}_{2} = \\begin{bmatrix} -0.9 & 1.1 & 0.3 \\\\ -0.4 & 0.8 & 0.6 \\\\ -0.3 & 0.5 & 0.4 \\\\ -0.1 & 0.2 & 0.1 \\end{bmatrix}$, $\\boldsymbol{\\Sigma}_{\\mathrm{n},2} = \\operatorname{diag}([625,\\ 625,\\ 625,\\ 625])$。\n\n- **测试用例 2**:\n    - $\\boldsymbol{\\mu}_2 = [-1.5,\\ -3.8,\\ -5.2]$。\n    - $\\boldsymbol{\\Sigma}_{\\mathrm{p},2} = \\begin{bmatrix} 1.0 & 0.2 & 0.0 \\\\ 0.2 & 1.2 & 0.1 \\\\ 0.0 & 0.1 & 0.8 \\end{bmatrix}$。\n    - 模式 $0$: $\\mathbf{A}_{0} = \\begin{bmatrix} -0.5 & 0.9 & 0.4 \\\\ -0.4 & 0.7 & 0.3 \\\\ -0.3 & 0.6 & 0.2 \\end{bmatrix}$, $\\boldsymbol{\\Sigma}_{\\mathrm{n},0} = \\operatorname{diag}([10000,\\ 10000,\\ 10000])$。\n    - 模式 $1$: $\\mathbf{A}_{1} = \\begin{bmatrix} -0.6 & 1.1 & 0.0 \\\\ -0.2 & 0.4 & 1.2 \\end{bmatrix}$, $\\boldsymbol{\\Sigma}_{\\mathrm{n},1} = \\operatorname{diag}([100,\\ 144])$。\n\n- **测试用例 3**:\n    - $\\boldsymbol{\\mu}_3 = [-2.2,\\ -4.1,\\ -5.1]$。\n    - $\\boldsymbol{\\Sigma}_{\\mathrm{p},3} = \\begin{bmatrix} 0.4 & 0.05 & 0.05 \\\\ 0.05 & 0.6 & 0.0 \\\\ 0.05 & 0.0 & 0.5 \\end{bmatrix}$。\n    - 模式 $0$: $\\mathbf{A}_{0} = \\begin{bmatrix} -0.6 & 0.8 & 0.6 \\\\ -0.1 & 0.2 & 1.0 \\\\ -0.4 & 0.7 & 0.1 \\end{bmatrix}$, $\\boldsymbol{\\Sigma}_{\\mathrm{n},0} = \\begin{bmatrix} 400 & 120 & 150 \\\\ 120 & 900 & 75 \\\\ 150 & 75 & 625 \\end{bmatrix}$。\n    - 模式 $1$: $\\mathbf{A}_{1} = \\begin{bmatrix} -0.8 & 0.9 & 0.3 \\\\ -0.3 & 0.5 & 0.9 \\\\ -0.2 & 0.4 & 0.2 \\end{bmatrix}$, $\\boldsymbol{\\Sigma}_{\\mathrm{n},1} = \\begin{bmatrix} 225 & 75 & 0 \\\\ 75 & 400 & 0 \\\\ 0 & 0 & 225 \\end{bmatrix}$。\n\n**步骤2：使用提取的已知条件进行验证**\n\n该问题在贝叶斯统计和大气科学领域具有科学依据。使用线性高斯模型是用于不确定性量化和实验设计的标准且有效近似方法。期望信息增益（互信息）的概念是贝叶斯实验设计的基石。该问题是适定的，所有必要的数学对象（矩阵、向量）都有定义，并且它们的维度对于所需的矩阵运算是一致的。测试用例中提供的数据，包括协方差矩阵，在物理和数学上都是合理的（例如，对称，并且经检查为正定）。该问题是客观的，没有歧义。它要求计算一个特定的、可推导的量。它没有违反任何无效性标准。\n\n**步骤3：结论与行动**\n\n问题有效。将提供完整解决方案。\n\n### 解法推导\n\n仪器模式$m$的期望信息增益（EIG）是参数向量$\\boldsymbol{\\theta}$和数据向量$\\mathbf{y}_m$之间的互信息，记为$I(\\boldsymbol{\\theta}; \\mathbf{y}_m)$。它衡量了由于一次观测导致的参数熵的期望减少量。一个方便的互信息恒等式是：\n$$\nI(\\boldsymbol{\\theta}; \\mathbf{y}_m) = H(\\mathbf{y}_m) - H(\\mathbf{y}_m | \\boldsymbol{\\theta})\n$$\n其中$H(\\cdot)$表示微分熵。我们将计算右侧的每一项。\n\n**1. 条件熵 $H(\\mathbf{y}_m | \\boldsymbol{\\theta})$**\n\n给定参数的数据的条件分布由测量模型指定：$p(\\mathbf{y}_m | \\boldsymbol{\\theta}) = \\mathcal{N}(\\mathbf{y}_m; \\mathbf{A}_m \\boldsymbol{\\theta}, \\boldsymbol{\\Sigma}_{\\mathrm{n},m})$。\n一个协方差为$\\boldsymbol{\\Sigma}$的$d$维多元高斯分布的微分熵由$\\frac{1}{2} \\ln \\det(2 \\pi e \\boldsymbol{\\Sigma})$给出。该表达式仅取决于协方差，而不取决于均值。对于$p(\\mathbf{y}_m|\\boldsymbol{\\theta})$，协方差是$\\boldsymbol{\\Sigma}_{\\mathrm{n},m}$。因此，这个条件分布的熵相对于$\\boldsymbol{\\theta}$是恒定的。因此，对$p(\\boldsymbol{\\theta})$的期望是平凡的。设$d_m$是$\\mathbf{y}_m$的维度。\n$$\nH(\\mathbf{y}_m | \\boldsymbol{\\theta}) = \\mathbb{E}_{p(\\boldsymbol{\\theta})} \\left[ H(p(\\mathbf{y}_m|\\boldsymbol{\\theta})) \\right] = H(p(\\mathbf{y}_m|\\boldsymbol{\\theta})) = \\frac{d_m}{2} \\ln(2 \\pi e) + \\frac{1}{2} \\ln \\det(\\boldsymbol{\\Sigma}_{\\mathrm{n},m})\n$$\n\n**2. 边缘熵 $H(\\mathbf{y}_m)$**\n\n为了找到数据边缘分布$p(\\mathbf{y}_m)$的熵，我们必须首先推导出这个分布。它是通过对联合分布在参数上积分得到的：$p(\\mathbf{y}_m) = \\int p(\\mathbf{y}_m | \\boldsymbol{\\theta}) p(\\boldsymbol{\\theta}) d\\boldsymbol{\\theta}$。\n鉴于先验$p(\\boldsymbol{\\theta}) = \\mathcal{N}(\\boldsymbol{\\mu}, \\boldsymbol{\\Sigma}_{\\mathrm{p}})$和似然$p(\\mathbf{y}_m | \\boldsymbol{\\theta})$都是高斯分布，边缘分布$p(\\mathbf{y}_m)$也是高斯分布。其均值和协方差如下求得：\n- **均值**: $\\mathbb{E}[\\mathbf{y}_m] = \\mathbb{E}[\\mathbf{A}_m \\boldsymbol{\\theta} + \\boldsymbol{\\varepsilon}_m] = \\mathbf{A}_m \\mathbb{E}[\\boldsymbol{\\theta}] + \\mathbb{E}[\\boldsymbol{\\varepsilon}_m] = \\mathbf{A}_m \\boldsymbol{\\mu} + \\mathbf{0} = \\mathbf{A}_m \\boldsymbol{\\mu}$。\n- **协方差**: 使用全协方差定律，并注意到$\\boldsymbol{\\theta}$和$\\boldsymbol{\\varepsilon}_m$的独立性：\n$$\n\\operatorname{Cov}(\\mathbf{y}_m) = \\mathbb{E}[\\operatorname{Cov}(\\mathbf{y}_m|\\boldsymbol{\\theta})] + \\operatorname{Cov}(\\mathbb{E}[\\mathbf{y}_m|\\boldsymbol{\\theta}]) = \\mathbb{E}[\\boldsymbol{\\Sigma}_{\\mathrm{n},m}] + \\operatorname{Cov}(\\mathbf{A}_m \\boldsymbol{\\theta}) = \\boldsymbol{\\Sigma}_{\\mathrm{n},m} + \\mathbf{A}_m \\operatorname{Cov}(\\boldsymbol{\\theta}) \\mathbf{A}_m^T = \\boldsymbol{\\Sigma}_{\\mathrm{n},m} + \\mathbf{A}_m \\boldsymbol{\\Sigma}_{\\mathrm{p}} \\mathbf{A}_m^T\n$$\n因此，$p(\\mathbf{y}_m) = \\mathcal{N}(\\mathbf{y}_m; \\mathbf{A}_m \\boldsymbol{\\mu}, \\mathbf{A}_m \\boldsymbol{\\Sigma}_{\\mathrm{p}} \\mathbf{A}_m^T + \\boldsymbol{\\Sigma}_{\\mathrm{n},m})$。\n这个边缘分布的熵是：\n$$\nH(\\mathbf{y}_m) = \\frac{d_m}{2} \\ln(2 \\pi e) + \\frac{1}{2} \\ln \\det(\\mathbf{A}_m \\boldsymbol{\\Sigma}_{\\mathrm{p}} \\mathbf{A}_m^T + \\boldsymbol{\\Sigma}_{\\mathrm{n},m})\n$$\n\n**3. 期望信息增益 (EIG)**\n\n将$H(\\mathbf{y}_m)$和$H(\\mathbf{y}_m | \\boldsymbol{\\theta})$的表达式代入互信息恒等式中，常数项$\\frac{d_m}{2} \\ln(2 \\pi e)$被消掉了：\n$$\n\\text{EIG}_m = I(\\boldsymbol{\\theta}; \\mathbf{y}_m) = H(\\mathbf{y}_m) - H(\\mathbf{y}_m | \\boldsymbol{\\theta}) = \\frac{1}{2} \\left[ \\ln \\det(\\mathbf{A}_m \\boldsymbol{\\Sigma}_{\\mathrm{p}} \\mathbf{A}_m^T + \\boldsymbol{\\Sigma}_{\\mathrm{n},m}) - \\ln \\det(\\boldsymbol{\\Sigma}_{\\mathrm{n},m}) \\right]\n$$\n这就是EIG的最终公式，按要求以nats为单位表示。值得注意的是，它与先验均值$\\boldsymbol{\\mu}$无关。\n\n### 数值实现\n\n为了以数值稳定的方式计算EIG并按要求避免显式矩阵求逆，我们利用Cholesky分解的性质。对于一个对称正定矩阵$\\mathbf{S}$，其Cholesky分解为$\\mathbf{S} = \\mathbf{L}\\mathbf{L}^T$，其中$\\mathbf{L}$是一个下三角矩阵。$\\mathbf{S}$的行列式是$\\det(\\mathbf{S}) = (\\det(\\mathbf{L}))^2 = (\\prod_i L_{ii})^2$。因此，对数行列式为：\n$$\n\\ln \\det(\\mathbf{S}) = 2 \\sum_i \\ln(L_{ii})\n$$\n这种方法避免了在乘以许多小或大数时可能发生的数值下溢或上溢。\n\n计算每个模式$m$的EIG的算法如下：\n1.  构建边缘数据协方差矩阵 $\\mathbf{M}_m = \\mathbf{A}_m \\boldsymbol{\\Sigma}_{\\mathrm{p}} \\mathbf{A}_m^T + \\boldsymbol{\\Sigma}_{\\mathrm{n},m}$。\n2.  计算$\\mathbf{M}_m$的Cholesky分解$\\mathbf{M}_m = \\mathbf{L}_{\\mathbf{M}} \\mathbf{L}_{\\mathbf{M}}^T$。\n3.  计算噪声协方差矩阵$\\boldsymbol{\\Sigma}_{\\mathrm{n},m}$的Cholesky分解$\\boldsymbol{\\Sigma}_{\\mathrm{n},m} = \\mathbf{L}_{\\mathbf{n}} \\mathbf{L}_{\\mathbf{n}}^T$。\n4.  计算对数行列式：\n    - $\\ln \\det(\\mathbf{M}_m) = 2 \\sum_i \\ln(\\text{diag}(\\mathbf{L}_{\\mathbf{M}}))$\n    - $\\ln \\det(\\boldsymbol{\\Sigma}_{\\mathrm{n},m}) = 2 \\sum_i \\ln(\\text{diag}(\\mathbf{L}_{\\mathbf{n}}))$\n5.  计算EIG：\n    $$\n    \\text{EIG}_m = \\frac{1}{2} (\\ln \\det(\\mathbf{M}_m) - \\ln \\det(\\boldsymbol{\\Sigma}_{\\mathrm{n},m})) = \\left( \\sum_i \\ln(\\text{diag}(\\mathbf{L}_{\\mathbf{M}})) \\right) - \\left( \\sum_i \\ln(\\text{diag}(\\mathbf{L}_{\\mathbf{n}})) \\right)\n    $$\n此过程应用于每个测试用例中的每个模式。选择具有最大EIG的模式作为最优选择。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the instrument mode recommendation problem by calculating\n    Expected Information Gain (EIG) for each mode in each test case.\n    \"\"\"\n\n    test_cases = [\n        # Test Case 1\n        {\n            \"Sigma_p\": np.array([\n                [0.30, 0.08, 0.02],\n                [0.08, 0.50, 0.10],\n                [0.02, 0.10, 0.40]\n            ]),\n            \"modes\": [\n                { # Mode 0\n                    \"A\": np.array([\n                        [-0.8, 1.2, 0.1],\n                        [-0.5, 0.9, 0.5]\n                    ]),\n                    \"Sigma_n\": np.diag([400., 625.])\n                },\n                { # Mode 1\n                    \"A\": np.array([\n                        [-0.7, 1.0, 0.2],\n                        [-0.6, 0.4, 1.1],\n                        [-0.2, 0.7, 0.3]\n                    ]),\n                    \"Sigma_n\": np.diag([225., 225., 225.])\n                },\n                { # Mode 2\n                    \"A\": np.array([\n                        [-0.9, 1.1, 0.3],\n                        [-0.4, 0.8, 0.6],\n                        [-0.3, 0.5, 0.4],\n                        [-0.1, 0.2, 0.1]\n                    ]),\n                    \"Sigma_n\": np.diag([625., 625., 625., 625.])\n                }\n            ]\n        },\n        # Test Case 2\n        {\n            \"Sigma_p\": np.array([\n                [1.0, 0.2, 0.0],\n                [0.2, 1.2, 0.1],\n                [0.0, 0.1, 0.8]\n            ]),\n            \"modes\": [\n                { # Mode 0\n                    \"A\": np.array([\n                        [-0.5, 0.9, 0.4],\n                        [-0.4, 0.7, 0.3],\n                        [-0.3, 0.6, 0.2]\n                    ]),\n                    \"Sigma_n\": np.diag([10000., 10000., 10000.])\n                },\n                { # Mode 1\n                    \"A\": np.array([\n                        [-0.6, 1.1, 0.0],\n                        [-0.2, 0.4, 1.2]\n                    ]),\n                    \"Sigma_n\": np.diag([100., 144.])\n                }\n            ]\n        },\n        # Test Case 3\n        {\n            \"Sigma_p\": np.array([\n                [0.4, 0.05, 0.05],\n                [0.05, 0.6, 0.0],\n                [0.05, 0.0, 0.5]\n            ]),\n            \"modes\": [\n                { # Mode 0\n                    \"A\": np.array([\n                        [-0.6, 0.8, 0.6],\n                        [-0.1, 0.2, 1.0],\n                        [-0.4, 0.7, 0.1]\n                    ]),\n                    \"Sigma_n\": np.array([\n                        [400., 120., 150.],\n                        [120., 900., 75.],\n                        [150., 75., 625.]\n                    ])\n                },\n                { # Mode 1\n                    \"A\": np.array([\n                        [-0.8, 0.9, 0.3],\n                        [-0.3, 0.5, 0.9],\n                        [-0.2, 0.4, 0.2]\n                    ]),\n                    \"Sigma_n\": np.array([\n                        [225., 75., 0.],\n                        [75., 400., 0.],\n                        [0., 0., 225.]\n                    ])\n                }\n            ]\n        }\n    ]\n\n    def calculate_eig(Sigma_p, A_m, Sigma_n_m):\n        \"\"\"\n        Calculates the Expected Information Gain (EIG) for a given mode.\n        \n        Args:\n            Sigma_p (np.ndarray): Prior covariance matrix.\n            A_m (np.ndarray): Sensitivity matrix for the mode.\n            Sigma_n_m (np.ndarray): Noise covariance matrix for the mode.\n            \n        Returns:\n            float: The EIG in nats.\n        \"\"\"\n        # Form the marginal data covariance matrix: M = A * Sigma_p * A.T + Sigma_n\n        M_m = A_m @ Sigma_p @ A_m.T + Sigma_n_m\n        \n        # Calculate log-determinants using Cholesky factorization for stability\n        try:\n            L_M = np.linalg.cholesky(M_m)\n            L_n = np.linalg.cholesky(Sigma_n_m)\n        except np.linalg.LinAlgError:\n            # This case should not be reached with the given valid problem data.\n            return -np.inf\n\n        # log(det(S)) = 2 * sum(log(diag(L))) where S = L*L.T\n        log_det_M = 2 * np.sum(np.log(np.diag(L_M)))\n        log_det_n = 2 * np.sum(np.log(np.diag(L_n)))\n        \n        # EIG = 0.5 * (log_det_M - log_det_n)\n        eig = 0.5 * (log_det_M - log_det_n)\n        \n        return eig\n\n    final_results = []\n    for case in test_cases:\n        Sigma_p = case[\"Sigma_p\"]\n        modes = case[\"modes\"]\n        \n        eigs_for_case = []\n        for mode in modes:\n            A_m = mode[\"A\"]\n            Sigma_n_m = mode[\"Sigma_n\"]\n            eig = calculate_eig(Sigma_p, A_m, Sigma_n_m)\n            eigs_for_case.append(eig)\n            \n        optimal_mode_index = np.argmax(eigs_for_case)\n        \n        final_results.extend(eigs_for_case)\n        final_results.append(optimal_mode_index)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, final_results))}]\")\n\nsolve()\n```"
        }
    ]
}