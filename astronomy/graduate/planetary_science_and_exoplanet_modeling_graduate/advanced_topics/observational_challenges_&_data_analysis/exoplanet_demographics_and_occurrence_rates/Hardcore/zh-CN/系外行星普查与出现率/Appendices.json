{
    "hands_on_practices": [
        {
            "introduction": "我们如何定义用于行星计数的“箱” (bin)——例如，是采用线性还是对数间隔——从根本上影响了我们人口统计模型的形式和参数。这项练习提供了在这些常用参数化之间进行转换的关键实践，这对于比较不同研究的结果至关重要。通过这个练习，您将掌握在不同坐标系下变换发生率密度的数学方法，确保您能够准确地解释和统一文献中看似不同的结果。",
            "id": "4160221",
            "problem": "考虑一个围绕类日恒星的系外行星的族群级发生率密度，该密度用行星半径 $R$ 和轨道周期 $P$ 来描述。设该发生率在每个线性分箱中由一个可分离的幂律模型描述\n$$\\frac{d^{2}N}{dR\\,dP} = \\lambda \\left(\\frac{R}{R_{0}}\\right)^{\\alpha} \\left(\\frac{P}{P_{0}}\\right)^{\\beta},$$\n其中 $N$ 是在一定 $R$ 和 $P$ 范围内的每颗恒星的行星期望数，$\\lambda$ 是一个归一化常数，单位为“行星数/每颗恒星/每$R_{\\oplus}$/天”，$(\\alpha,\\beta)$ 是参考基准点 $R_{0}$ 和 $P_{0}$ 的无量纲斜率。观测星表通常对这些变量的对数进行分箱。定义对数分箱发生率密度为\n$$\\frac{d^{2}N}{d\\ln R\\,d\\ln P}.$$\n仅从变量变换下的微分定义和重新参数化下期望计数 $d^{2}N$ 的守恒性出发，推导这两种密度之间的映射关系，并得到在对数分箱参数化中，参数三元组 $(\\lambda,\\alpha,\\beta)$ 到 $(\\tilde{\\lambda},\\tilde{\\alpha},\\tilde{\\beta})$ 的相应变换\n$$\\frac{d^{2}N}{d\\ln R\\,d\\ln P} = \\tilde{\\lambda} \\left(\\frac{R}{R_{0}}\\right)^{\\tilde{\\alpha}} \\left(\\frac{P}{P_{0}}\\right)^{\\tilde{\\beta}}.$$\n假设一个对 $\\ln R$ 和 $\\ln P$ 中分箱计数的最大后验概率 (MAP) 拟合，被错误地使用线性分箱参数化报告，其参数值如下：$R_{0} = 2\\,R_{\\oplus}$, $P_{0} = 10\\,\\text{天}$, $\\lambda = 4.00 \\times 10^{-4}$ 行星数/每颗恒星/每$R_{\\oplus}$/天, $\\alpha = -1.30$, 以及 $\\beta = 0.70$。使用您推导出的映射关系，计算与对数分箱一致的修正后的 $(\\tilde{\\lambda},\\tilde{\\alpha},\\tilde{\\beta})$。将 $\\tilde{\\lambda}$ 以“每颗恒星的行星数”为单位表示。将您的 $\\tilde{\\lambda}$ 值四舍五入到四位有效数字。最终答案必须以 $\\left(\\tilde{\\lambda},\\,\\tilde{\\alpha},\\,\\tilde{\\beta}\\right)$ 形式的单行矩阵提供。",
            "solution": "该问题要求推导系外行星发生率密度的两种不同参数化之间的变换关系，然后利用该变换进行数值计算。\n\n首先，对问题陈述进行验证。\n\n**步骤1：提取已知条件**\n- 线性分箱发生率密度：$\\frac{d^{2}N}{dR\\,dP} = \\lambda \\left(\\frac{R}{R_{0}}\\right)^{\\alpha} \\left(\\frac{P}{P_{0}}\\right)^{\\beta}$。\n- $N$：每颗恒星的行星期望数。\n- $R$：行星半径。\n- $P$：轨道周期。\n- $\\lambda$：归一化常数。\n- $\\alpha, \\beta$：无量纲斜率。\n- $R_{0}, P_{0}$：参考基准点。\n- 对数分箱发生率密度：$\\frac{d^{2}N}{d\\ln R\\,d\\ln P}$。\n- 对数分箱参数化：$\\frac{d^{2}N}{d\\ln R\\,d\\ln P} = \\tilde{\\lambda} \\left(\\frac{R}{R_{0}}\\right)^{\\tilde{\\alpha}} \\left(\\frac{P}{P_{0}}\\right)^{\\tilde{\\beta}}$。\n- 来自错误拟合的参数值：$R_{0} = 2\\,R_{\\oplus}$，$P_{0} = 10\\,\\text{天}$，$\\lambda = 4.00 \\times 10^{-4}$ 行星数/每颗恒星/每$R_{\\oplus}$/天，$\\alpha = -1.30$，以及 $\\beta = 0.70$。\n- 任务是推导从 $(\\lambda,\\alpha,\\beta)$ 到 $(\\tilde{\\lambda},\\tilde{\\alpha},\\tilde{\\beta})$ 的映射关系并计算修正后的值。\n\n**步骤2：使用提取的已知条件进行验证**\n- 该问题是**有科学依据的**。使用幂律模型来描述系外行星发生率是行星科学中的标准做法，尤其是在分析像开普勒（Kepler）这样的凌星巡天数据时。\n- 该问题是**良构的**。在变量变换下，微分概率密度之间的转换是一个标准的数学过程，由变换的雅可比行列式决定。执行此推导和后续计算所需的所有信息都已提供。\n- 该问题是**客观的**。它是用精确的数学和物理术语陈述的，没有任何主观或模棱两可的语言。\n- 该问题没有表现出任何缺陷，如科学上的不合理、不完整性、矛盾或不可行性。其模型和参数值与科学文献中的发现一致。\n\n**步骤3：结论与行动**\n问题有效。将提供完整解答。\n\n关联这两个密度函数的核心原则是，无论使用何种坐标系，参数空间无穷小区域内的行星数量 $d^{2}N$ 是守恒的。这意味着在元 $dR\\,dP$ 中的行星数量必须与在相应元 $d\\ln R\\,d\\ln P$ 中的行星数量相同。\n在数学上，这种不变性表示为：\n$$d^{2}N = \\frac{d^{2}N}{dR\\,dP} dR\\,dP = \\frac{d^{2}N}{d\\ln R\\,d\\ln P} d\\ln R\\,d\\ln P$$\n为了找到两种密度之间的关系，我们必须关联微分面积元 $dR\\,dP$ 和 $d\\ln R\\,d\\ln P$。\n让我们定义对数变量 $u = \\ln R$ 和 $v = \\ln P$。其微分为：\n$$du = d(\\ln R) = \\frac{1}{R} dR \\implies dR = R\\,du = R\\,d\\ln R$$\n$$dv = d(\\ln P) = \\frac{1}{P} dP \\implies dP = P\\,dv = P\\,d\\ln P$$\n因此，线性坐标中的微分面积元可以用对数坐标表示：\n$$dR\\,dP = (R\\,d\\ln R)(P\\,d\\ln P) = RP\\,d\\ln R\\,d\\ln P$$\n项 $RP$ 是从 $(\\ln R, \\ln P)$ 到 $(R, P)$ 的变换的雅可比行列式。\n现在，我们将其代入不变性方程中：\n$$\\frac{d^{2}N}{dR\\,dP} (RP\\,d\\ln R\\,d\\ln P) = \\frac{d^{2}N}{d\\ln R\\,d\\ln P} (d\\ln R\\,d\\ln P)$$\n两边同除以非零的微分元 $d\\ln R\\,d\\ln P$，我们得到密度的变换规则：\n$$\\frac{d^{2}N}{d\\ln R\\,d\\ln P} = \\left(\\frac{d^{2}N}{dR\\,dP}\\right) R P$$\n现在我们将每种密度的给定幂律形式代入此方程。\n左边是：\n$$\\tilde{\\lambda} \\left(\\frac{R}{R_{0}}\\right)^{\\tilde{\\alpha}} \\left(\\frac{P}{P_{0}}\\right)^{\\tilde{\\beta}}$$\n右边是：\n$$\\left( \\lambda \\left(\\frac{R}{R_{0}}\\right)^{\\alpha} \\left(\\frac{P}{P_{0}}\\right)^{\\beta} \\right) R P$$\n为了比较这两种形式，我们必须用基准值 $R_{0}$ 和 $P_{0}$ 来表示右侧的因子 $R$ 和 $P$：\n$$R = R_{0} \\left(\\frac{R}{R_{0}}\\right)^{1}$$\n$$P = P_{0} \\left(\\frac{P}{P_{0}}\\right)^{1}$$\n将这些代入右侧表达式得到：\n$$RHS = \\lambda \\left(\\frac{R}{R_{0}}\\right)^{\\alpha} \\left(\\frac{P}{P_{0}}\\right)^{\\beta} \\left(R_{0} \\left(\\frac{R}{R_{0}}\\right)^{1}\\right) \\left(P_{0} \\left(\\frac{P}{P_{0}}\\right)^{1}\\right)$$\n我们可以将常数项和幂律项组合在一起：\n$$RHS = (\\lambda R_{0} P_{0}) \\left(\\frac{R}{R_{0}}\\right)^{\\alpha} \\left(\\frac{R}{R_{0}}\\right)^{1} \\left(\\frac{P}{P_{0}}\\right)^{\\beta} \\left(\\frac{P}{P_{0}}\\right)^{1}$$\n$$RHS = (\\lambda R_{0} P_{0}) \\left(\\frac{R}{R_{0}}\\right)^{\\alpha+1} \\left(\\frac{P}{P_{0}}\\right)^{\\beta+1}$$\n通过将变换后的右侧与左侧相等，\n$$\\tilde{\\lambda} \\left(\\frac{R}{R_{0}}\\right)^{\\tilde{\\alpha}} \\left(\\frac{P}{P_{0}}\\right)^{\\tilde{\\beta}} = (\\lambda R_{0} P_{0}) \\left(\\frac{R}{R_{0}}\\right)^{\\alpha+1} \\left(\\frac{P}{P_{0}}\\right)^{\\beta+1}$$\n我们可以通过比较相应项的系数和指数来确定参数的变换。这得出了以下映射关系：\n$$\\tilde{\\lambda} = \\lambda R_{0} P_{0}$$\n$$\\tilde{\\alpha} = \\alpha + 1$$\n$$\\tilde{\\beta} = \\beta + 1$$\n这就完成了变换的推导。\n\n接下来，我们使用错误拟合中提供的参数计算 $(\\tilde{\\lambda}, \\tilde{\\alpha}, \\tilde{\\beta})$ 的修正数值：\n$R_{0} = 2\\,R_{\\oplus}$\n$P_{0} = 10\\,\\text{天}$\n$\\lambda = 4.00 \\times 10^{-4}$ 行星数/每颗恒星/每$R_{\\oplus}$/天\n$\\alpha = -1.30$\n$\\beta = 0.70$\n\n我们计算新的斜率 $\\tilde{\\alpha}$ 和 $\\tilde{\\beta}$：\n$$\\tilde{\\alpha} = \\alpha + 1 = -1.30 + 1.00 = -0.30$$\n$$\\tilde{\\beta} = \\beta + 1 = 0.70 + 1.00 = 1.70$$\n\n接下来，我们计算新的归一化常数 $\\tilde{\\lambda}$。我们必须注意单位。\n$$\\tilde{\\lambda} = \\lambda R_{0} P_{0} = (4.00 \\times 10^{-4} \\text{ 恒星}^{-1} R_{\\oplus}^{-1} \\text{天}^{-1}) \\times (2 \\, R_{\\oplus}) \\times (10 \\, \\text{天})$$\n$$\\tilde{\\lambda} = (4.00 \\times 10^{-4}) \\times 2 \\times 10 \\text{ 恒星}^{-1}$$\n$$\\tilde{\\lambda} = 8.00 \\times 10^{-3} \\text{ 行星数/每颗恒星}$$\n问题要求将 $\\tilde{\\lambda}$ 的值四舍五入到四位有效数字。\n$$\\tilde{\\lambda} = 0.008000$$\n或用科学记数法表示为 $8.000 \\times 10^{-3}$。\n\n与对数分箱一致的修正后参数三元组 $(\\tilde{\\lambda}, \\tilde{\\alpha}, \\tilde{\\beta})$ 是 $(8.000 \\times 10^{-3}, -0.30, 1.70)$。$\\tilde{\\lambda}$ 的单位是“每颗恒星的行星数”，这与作用于无量纲对数变量的密度函数的归一化常数所期望的单位一致。\n\n最终答案以行矩阵格式呈现。",
            "answer": "$$\\boxed{\\begin{pmatrix} 8.000 \\times 10^{-3}  -0.30  1.70 \\end{pmatrix}}$$"
        },
        {
            "introduction": "在确定了如何参数化我们的模型之后，下一步就是进行统计推断。这个问题解决了一个常见且重要的情景：当一次巡天在某个特定区域内*没有*发现行星时，我们能得出什么结论？通过这项练习，您将亲手实践贝叶斯推断和底层的泊松 (Poisson) 统计模型，从而为行星发生率$f$设定稳健的上限，这是处理稀疏数据时的核心技能。",
            "id": "4160194",
            "problem": "一项对 $N=500$ 颗类日恒星的凌日巡天报告称，在行星半径 $R_{\\mathrm{p}} \\in [1.0,1.5]\\,R_{\\oplus}$ 和轨道周期 $P \\in [30,70]\\,\\mathrm{days}$ 定义的区间内，没有已验证的行星探测结果。对于每颗目标恒星 $i$，巡天团队通过注入-恢复实验计算了该区间的综合探测完备性 $C_{i}$。$C_{i}$ 是指如果恒星 $i$ 周围存在一颗行星，那么从该区间内随机抽取的一颗行星被探测到并得到验证的概率，此概率已对该区间的周期-半径分布进行了边际化。团队报告的总探测完备性之和为 $S=\\sum_{i=1}^{N} C_{i}=100$。\n\n假设该区间内行星的潜在总体在恒星间的分布遵循泊松点过程，并且探测流程以每个目标的探测概率 $C_{i}$ 对此过程进行独立稀疏化（泊松稀疏化）。令 $f$ 表示发生率，定义为该区间内每颗恒星的平均行星数（因此 $f$ 可以超过 $1$）。采用 $f \\ge 0$ 的均匀先验，利用泊松过程的性质和各目标之间的独立性，推导在未探测到行星的情况下 $f$ 的后验分布，并由此计算 $f$ 的等尾95%置信上限。将最终答案表示为小数，并四舍五入到四位有效数字。",
            "solution": "问题要求在凌日巡天没有探测到任何结果的情况下，计算系外行星发生率 $f$ 的95%置信上限。我们将使用贝叶斯推断来解决这个问题。\n\n首先，我们建立观测到的行星数量的统计模型。令 $f$ 为在指定的行星半径和轨道周期区间内，每颗恒星的平均行星数。问题指出，行星的潜在总体遵循泊松点过程。因此，对于单颗恒星 $i$，该区间内的行星数 $n_i$ 是一个从均值为 $f$ 的泊松分布中抽取的随机变量：\n$$ n_i \\sim \\mathrm{Poisson}(f) $$\n对给定行星的探测是概率性的。对于恒星 $i$ 的综合探测完备性 $C_i$ 代表了如果存在行星，它被探测到的概率。在恒星 $i$ 周围有 $n_i$ 颗行星的情况下，探测到的行星数 $k_i$ 遵循二项分布：\n$$ k_i | n_i \\sim \\mathrm{Binomial}(n_i, C_i) $$\n在这种情况下，一个服从泊松分布的量经过一个二项选择过程（稀疏化），其结果是一个新的服从泊松分布的量。恒星 $i$ 周围探测到的行星数 $k_i$ 的边际分布是一个均值为 $f C_i$ 的泊松分布：\n$$ k_i \\sim \\mathrm{Poisson}(f C_i) $$\n在整个 $N$ 颗恒星的巡天中，探测到的总行星数 $K$ 是独立随机变量 $k_i$ 的和：\n$$ K = \\sum_{i=1}^{N} k_i $$\n独立泊松随机变量的和也是一个泊松随机变量，其均值等于各个均值之和。因此，$K$ 的分布为：\n$$ K \\sim \\mathrm{Poisson}\\left(\\sum_{i=1}^{N} f C_i\\right) $$\n我们可以将常数发生率 $f$ 提取出来：\n$$ K \\sim \\mathrm{Poisson}\\left(f \\sum_{i=1}^{N} C_i\\right) $$\n令 $S = \\sum_{i=1}^{N} C_i$ 为总探测完备性之和。问题给出 $S=100$。那么，总探测数量的模型为：\n$$ K \\sim \\mathrm{Poisson}(fS) $$\n提供的数据是没有任何已验证的行星探测，因此我们的观测值为 $K=0$。\n\n我们应用贝叶斯定理来找到给定数据 $K=0$ 和模型参数 $S$ 时 $f$ 的后验概率分布。后验分布 $p(f | K, S)$ 正比于似然函数 $\\mathcal{L}(K | f, S)$ 乘以先验分布 $p(f)$：\n$$ p(f | K=0, S) \\propto \\mathcal{L}(K=0 | f, S) \\cdot p(f) $$\n似然函数是从均值为 $\\lambda = fS$ 的泊松分布中观测到 $K=0$ 的概率：\n$$ \\mathcal{L}(K=0 | f, S) = P(K=0 | \\lambda=fS) = \\frac{(fS)^0 \\exp(-fS)}{0!} = \\exp(-fS) $$\n问题指定了 $f \\ge 0$ 的均匀先验，可以写成：\n$$ p(f) \\propto 1, \\quad \\text{for } f \\ge 0 $$\n结合似然函数和先验分布，我们得到 $f$ 的未归一化的后验分布：\n$$ p(f | K=0, S) \\propto \\exp(-fS), \\quad \\text{for } f \\ge 0 $$\n这是指数分布的函数形式。为了找到归一化常数，我们需要其概率密度函数（PDF）在其定义域上的积分为 $1$：\n$$ \\int_{0}^{\\infty} A \\exp(-fS) \\, df = 1 $$\n其中 $A$ 是归一化常数。\n$$ A \\left[ -\\frac{1}{S} \\exp(-fS) \\right]_{0}^{\\infty} = A \\left( 0 - \\left(-\\frac{\\exp(0)}{S}\\right) \\right) = \\frac{A}{S} = 1 $$\n这意味着 $A=S$。因此，归一化后的后验概率密度函数为：\n$$ p(f | K=0, S) = S \\exp(-fS), \\quad \\text{for } f \\ge 0 $$\n这是一个率参数为 $S$ 的指数分布的概率密度函数。\n\n$f$ 的95%置信上限，记为 $f_{95}$，是使得累积概率达到 $0.95$ 的值。这可以通过将后验概率密度函数从 $0$ 积分到 $f_{95}$ 来找到：\n$$ P(f \\le f_{95} | K=0, S) = \\int_{0}^{f_{95}} S \\exp(-f'S) \\, df' = 0.95 $$\n该积分对应于指数分布的累积分布函数（CDF）：\n$$ \\left[ -\\exp(-f'S) \\right]_{0}^{f_{95}} = 1 - \\exp(-f_{95}S) $$\n令其等于 $0.95$：\n$$ 1 - \\exp(-f_{95}S) = 0.95 $$\n求解 $f_{95}$：\n$$ \\exp(-f_{95}S) = 1 - 0.95 = 0.05 $$\n$$ -f_{95}S = \\ln(0.05) $$\n$$ f_{95} = -\\frac{\\ln(0.05)}{S} $$\n问题给出了值 $S=100$。将这个值代入 $f_{95}$ 的表达式中：\n$$ f_{95} = -\\frac{\\ln(0.05)}{100} $$\n我们可以计算其数值：\n$$ \\ln(0.05) \\approx -2.99573227 $$\n$$ f_{95} \\approx -\\frac{-2.99573227}{100} \\approx 0.0299573227 $$\n问题要求将最终答案四舍五入到四位有效数字。$0.0299573227$ 的前四位有效数字是 $2, 9, 9, 5$。随后的数字是 $7$，这意味着我们必须对最后一位有效数字进行向上取整：\n$$ f_{95} \\approx 0.02996 $$",
            "answer": "$$\\boxed{0.02996}$$"
        },
        {
            "introduction": "理论模型需要通过实践来检验，而计算验证是现代天体物理学研究的一项关键技能。这项练习将带领您从分析推导走向计算验证。通过模拟一次巡天并比较不同估计量的表现，您将对哪些统计方法是稳健和无偏的，以及为何校正探测完备性的偏差至关重要，获得深刻的直觉。",
            "id": "4160273",
            "problem": "一项对 $N$ 颗目标恒星的巡天调查旨在测量一个特定周期-半径区间内每颗恒星的平均行星数，该值记为 $f$。对于每颗恒星 $i \\in \\{1,\\dots,N\\}$，其在该区间内的行星数 $K_i$ 被建模为均值为 $f$ 的泊松随机变量的独立实现。系外行星探测流程对该区间具有恒星相关的探测完备性，记为 $C_i \\in [0,1]$，它表示环绕恒星 $i$ 且位于该区间内的任意单个行星被探测到的概率。在给定 $K_i$ 的条件下，每颗行星以概率 $C_i$ 被独立地探测到。在整个巡天调查中，令 $D_i$ 为在恒星 $i$ 上探测到的行星数，令 $D=\\sum_{i=1}^{N} D_i$ 为探测到的行星总数。\n\n您的任务是在上述数据生成过程下，通过模拟比较 $f$ 的三个估计量。使用以下基于原理的估计量：\n- 一种基于探测分数法的估计量，仅使用探测到的行星总数和恒星数量。\n- 一种基于似然法的估计量，在泊松稀疏化和 $C_i$ 已知的假设下推导得出。\n- 一种探测效率加权估计量，通过其对应的 $C_i$ 值对探测到的行星进行反向加权。\n\n从上述基本框架（每颗恒星的行星数服从泊松分布，并由探测完备性进行独立稀疏化）出发，推导出每个估计量，然后实现一个模拟，以量化其在给定巡天配置下的偏差和均方误差。偏差定义为估计量的期望与真实值 $f$ 之差，均方误差定义为估计量与真实值 $f$ 偏差的平方的期望；在模拟中，通过多次蒙特卡洛实现的经验平均值来近似这些量。在本问题中，$f$ 是无量纲的，您的程序必须以十进制浮点数形式报告偏差和均方误差。\n\n模拟协议：\n1. 对每个测试用例，固定真实值 $f$、恒星数量 $N$ 以及探测完备性值 $\\{C_i\\}_{i=1}^N$ 的分布。\n2. 对每次蒙特卡洛复制，使用由基本框架和指定的 $C_i$ 所蕴含的泊松稀疏化模型为每颗恒星生成 $D_i$；从生成的探测数据中计算 $f$ 的三个估计量。\n3. 重复指定次数的复制，以近似每个估计量的偏差和均方误差。\n\n对所有随机抽样（包括 $\\{C_i\\}_{i=1}^N$ 和探测数据的生成），使用以种子 $12345$ 初始化的伪随机数生成器。每个测试用例使用 $R=10000$ 次蒙特卡洛复制。\n\n测试套件：\n- 用例 A（通用，异构完备性）：$N=500$，$f=0.8$，$C_i$ 独立地从形状参数为 $(2,5)$ 的贝塔分布中抽取。\n- 用例 B（边界，完美完备性）：$N=300$，$f=0.5$，对所有恒星 $C_i=1$。\n- 用例 C（边缘，包含零和高完备性的混合分布）：$N=400$，$f=0.3$，$C_i$ 独立地从一个混合分布中抽取：以概率 $0.2$，$C_i=0$；以概率 $0.3$，$C_i=0.9$；以概率 $0.5$，$C_i$ 从形状参数为 $(1,3)$ 的贝塔分布中抽取。\n- 用例 D（低发生率）：$N=200$，$f=0.05$，$C_i$ 独立地从形状参数为 $(2,2)$ 的贝塔分布中抽取。\n\n输出规格：\n- 对于每个测试用例，您的程序必须计算六个量：三个估计量各自的偏差和均方误差，顺序如下：基于探测分数法的偏差，基于探测分数法的均方误差，基于似然法的偏差，基于似然法的均方误差，探测效率加权偏差，探测效率加权均方误差。\n- 您的程序应生成单行输出，其中包含所有测试用例的结果，格式为一个由方括号括起来的逗号分隔列表，其中每个测试用例贡献一个按指定顺序包含六个浮点数的列表。例如：\"[[b1,m1,b2,m2,b3,m3],[...],[...],[...]]\"。",
            "solution": "用户希望我扮演一名STEM教授，解决一个关于估计系外行星发生率的问题。\n\n计划如下：\n1.  **验证问题陈述。**\n    *   逐字提取所有给定信息。\n    *   检查科学合理性、适定性、客观性及其他有效性标准。\n    *   这个问题似乎是一个设置在天体物理学背景（系外行星巡天）下的标准统计估计问题。它涉及建模、推导估计量和执行蒙特卡洛模拟。这是一个合理且明确定义的任务。\n\n2.  **推导估计量。**\n    *   **模型设置：**\n        *   $K_i \\sim \\text{Poisson}(f)$ 是恒星 $i$ 的真实行星数。\n        *   $C_i$ 是恒星 $i$ 的探测完备性。\n        *   $D_i | K_i \\sim \\text{Binomial}(K_i, C_i)$ 是在恒星 $i$ 上探测到的行星数。\n        *   我需要 $D_i$ 的边际分布。这是一个“泊松稀疏化”的经典结果。如果 $K \\sim \\text{Poisson}(\\lambda)$，并且我们以概率 $p$ 对 $K$ 个项目中的每一个进行抽样，则抽样项目的数量 $D$ 服从 $D \\sim \\text{Poisson}(\\lambda p)$。\n        *   因此，$D_i \\sim \\text{Poisson}(f C_i)$。\n        *   探测总数 $D = \\sum_{i=1}^N D_i$。独立泊松变量的和也是一个泊松变量。所以，$D \\sim \\text{Poisson}(\\sum_{i=1}^N f C_i) = \\text{Poisson}(f \\sum_{i=1}^N C_i)$。\n\n    *   **估计量1：基于探测分数法的估计量 ($\\hat{f}_{DF}$)**\n        *   这个估计量“仅使用探测到的行星总数和恒星数量”。\n        *   这似乎意味着一种朴素的方法。一个简单的分数就是探测总数除以恒星数：$\\hat{f}_{DF} = \\frac{D}{N} = \\frac{\\sum D_i}{N}$。\n        *   我们来检查它的期望。\n            *   $E[\\hat{f}_{DF}] = E[\\frac{\\sum D_i}{N}] = \\frac{1}{N} \\sum E[D_i]$。\n            *   $E[D_i] = f C_i$。\n            *   $E[\\hat{f}_{DF}] = \\frac{1}{N} \\sum (f C_i) = f \\left(\\frac{1}{N} \\sum C_i\\right) = f \\bar{C}$。\n        *   除非 $\\bar{C} = 1$，否则这个估计量是有偏的。偏差为 $E[\\hat{f}_{DF}] - f = f(\\bar{C} - 1)$。由于 $C_i \\in [0, 1]$，所以 $\\bar{C} \\le 1$，因此偏差是非正的。这个估计量系统性地低估了 $f$。这是合理的，因为它忽略了有些行星未被探测到。\n\n    *   **估计量2：基于似然法的估计量 ($\\hat{f}_{LKL}$)**\n        *   “在泊松稀疏化和 $C_i$ 已知的假设下推导得出”。\n        *   数据为 $\\{D_i\\}_{i=1}^N$。我们知道 $D_i \\sim \\text{Poisson}(f C_i)$。\n        *   给定数据 $\\{D_i\\}$， $f$ 的似然函数是：\n            *   $L(f | \\{D_i\\}) = P(\\{D_i\\} | f) = \\prod_{i=1}^N P(D_i | f)$。\n            *   $L(f) = \\prod_{i=1}^N \\frac{(f C_i)^{D_i} e^{-f C_i}}{D_i!}$。\n        *   对数似然函数是：\n            *   $\\ln L(f) = \\sum_{i=1}^N \\left( D_i \\ln(f C_i) - f C_i - \\ln(D_i!) \\right)$。\n            *   $\\ln L(f) = \\sum_{i=1}^N \\left( D_i \\ln f + D_i \\ln C_i - f C_i - \\ln(D_i!) \\right)$。\n            *   $\\ln L(f) = (\\ln f) \\sum D_i + \\sum (D_i \\ln C_i) - f \\sum C_i - \\sum \\ln(D_i!)$。\n        *   为了找到最大似然估计量 (MLE)，我们对 $f$ 求导并令其为零。\n            *   $\\frac{d}{df} \\ln L(f) = \\frac{1}{f} \\sum D_i - \\sum C_i = 0$。\n            *   $\\frac{1}{f} \\sum D_i = \\sum C_i$。\n            *   $\\hat{f}_{LKL} = \\frac{\\sum D_i}{\\sum C_i}$。\n        *   我们来检查它的期望。\n            *   $E[\\hat{f}_{LKL}] = E\\left[\\frac{\\sum D_i}{\\sum C_i}\\right] = \\frac{1}{\\sum C_i} E\\left[\\sum D_i\\right]$。\n            *   $E[\\sum D_i] = \\sum E[D_i] = \\sum (f C_i) = f \\sum C_i$。\n            *   $E[\\hat{f}_{LKL}] = \\frac{1}{\\sum C_i} (f \\sum C_i) = f$。\n        *   这个估计量是无偏的。注意：这在 $\\sum C_i \\neq 0$ 时成立。如果所有 $C_i = 0$，则估计量是未定义的。问题陈述 $C_i \\in [0,1]$，所以 $\\sum C_i = 0$ 是可能的，例如在用例 C 中，每个恒星的 $C_i=0$ 都是一种可能性。如果所有抽样得到的 $C_i$ 都为 0，那么 $\\sum D_i$ 也将为 0，我们会得到 $0/0$。在模拟中，如果 $\\sum C_i = 0$，我们必须处理这种情况。在这种情况下，没有行星可以被探测到，所以所有 $i$ 的 $D_i=0$。我们得到 $\\hat{f}_{LKL} = 0/0$。正确的做法是什么？从似然的角度来看，如果所有 $C_i=0$，似然函数是 $\\prod e^0 = 1$，对所有 $f$ 值都成立。任何 $f$ 都是等可能的，所以最大似然估计量不是唯一确定的。然而，对于 $N=400$ 而言，这种情况发生的概率是 $(0.2)^{400}$，这是一个天文数字般的小概率。所以我们在模拟中可以忽略这个边缘情况。我们假设 $\\sum C_i > 0$。\n\n    *   **估计量3：探测效率加权估计量 ($\\hat{f}_{DW}$)**\n        *   “通过其对应的 $C_i$ 值对探测到的行星进行反向加权”。\n        *   这听起来像一个霍维茨-汤普森型估计量。对于每颗恒星 $i$，我们探测到了 $D_i$ 颗行星。每次探测代表一个以概率 $C_i$ 被成功探测到的潜在行星。所以，我们可以将每次探测看作是 $1/C_i$ 颗真实行星的“代表”。\n        *   估计的真实行星总数将是 $\\sum_{i=1}^N \\frac{D_i}{C_i}$。\n        *   然后，每颗恒星的平均行星数将是这个总和除以 $N$。\n        *   $\\hat{f}_{DW} = \\frac{1}{N} \\sum_{i=1}^N \\frac{D_i}{C_i}$。\n        *   我们来检查它的期望。\n            *   $E[\\hat{f}_{DW}] = E\\left[\\frac{1}{N} \\sum \\frac{D_i}{C_i}\\right] = \\frac{1}{N} \\sum \\frac{E[D_i]}{C_i}$。\n            *   $E[D_i] = f C_i$。\n            *   $E[\\hat{f}_{DW}] = \\frac{1}{N} \\sum \\frac{f C_i}{C_i} = \\frac{1}{N} \\sum f = \\frac{1}{N} (N f) = f$。\n        *   这个估计量也是无偏的。\n        *   如果某些 $C_i=0$ 会发生什么？公式涉及 $1/C_i$。如果 $C_i=0$，那么 $D_i$ 必须是 0。所以我们得到一个 $0/0$ 项。我们应该定义当 $C_i=0$ 时 $D_i/C_i = 0$。在这类估计量中，这是一个标准约定，因为没有探测到行星（$D_i=0$）就无法提供关于该恒星上行星的信息，所以它对总和的贡献为 0。项 $D_i/C_i$ 是恒星 $i$ 上估计的行星数，如果 $C_i=0$，我们什么也探测不到，所以探测数 $D_i$ 保证为 0，我们从该恒星的*探测*中得到的*真实*行星数的估计值应为 0。这似乎是一个合理的约定。\n\n    *   **估计量总结：**\n        1.  $\\hat{f}_{DF} = \\frac{\\sum D_i}{N}$ (有偏)\n        2.  $\\hat{f}_{LKL} = \\frac{\\sum D_i}{\\sum C_i}$ (无偏, 最大似然估计量)\n        3.  $\\hat{f}_{DW} = \\frac{1}{N} \\sum \\frac{D_i}{C_i}$ (无偏)\n\n3.  **规划模拟。**\n    *   **目标：** 为每个测试用例计算每个估计量的偏差和均方误差。\n        *   偏差($\\hat{f}$) = $E[\\hat{f}] - f \\approx \\frac{1}{R} \\sum_{r=1}^R \\hat{f}^{(r)} - f$\n        *   均方误差($\\hat{f}$) = $E[(\\hat{f} - f)^2] \\approx \\frac{1}{R} \\sum_{r=1}^R (\\hat{f}^{(r)} - f)^2$\n        其中 $\\hat{f}^{(r)}$ 是第 $r$ 次蒙特卡洛复制的估计值。\n\n    *   **一个测试用例的通用结构：**\n        *   输入：$N$, $f$, $C_i$ 分布, $R=10000$, seed=12345。\n        *   用种子初始化随机数生成器。\n        *   为测试用例生成一次完整的 $N$ 个完备性值 $\\{C_i\\}_{i=1}^N$。这是一个巡天的固定属性。\n        *   初始化估计值存储：`estimates_df`, `estimates_lkl`, `estimates_dw` 作为列表。\n        *   循环 $R$ 次（每次复制）：\n            *   生成探测到的行星数 $\\{D_i\\}_{i=1}^N$。对每颗恒星 $i=1, \\dots, N$：\n                *   模型是 $D_i \\sim \\text{Poisson}(f C_i)$。\n                *   所以，对每颗恒星 $i$ 调用一次 `rng.poisson(f * C_i)` 将生成 $D_i$。\n                *   一个向量化的方法：`D = rng.poisson(f * C)`，其中 `C` 是完备性值的数组。\n            *   从这组 $\\{D_i\\}$ 和预先生成的 $\\{C_i\\}$ 计算三个估计量。\n                *   `sum_D = np.sum(D)`\n                *   `sum_C = np.sum(C)`\n                *   处理除以零的情况。\n                *   $\\hat{f}_{DF} = \\text{sum_D} / N$\n                *   $\\hat{f}_{LKL} = \\text{sum_D} / \\text{sum_C}$ (如果 `sum_C` 为 0，怎么办？让我们检查一下可能发生这种情况的用例。用例 C：$C_i=0$ 的概率为 $0.2$。所有 $N=400$ 颗恒星都具有 $C_i=0$ 的概率是 $(0.2)^{400}$，可以忽略不计。我会添加一个 `if sum_C == 0` 的检查，但它应该不会被触发。)\n                *   $\\hat{f}_{DW}$: $\\frac{1}{N} \\sum \\frac{D_i}{C_i}$。这里我们需要处理 $C_i=0$。\n                    *   创建一个掩码数组或使用 `np.where`。\n                    *   `terms = np.where(C > 0, D / C, 0)`\n                    *   `f_hat_dw = np.mean(terms)`\n            *   存储三个估计值：`estimates_df.append(...)` 等。\n        *   循环结束后，将估计值列表转换为 numpy 数组。\n        *   计算每个估计量的偏差和均方误差。\n            *   `bias_df = np.mean(estimates_df) - f`\n            *   `mse_df = np.mean((estimates_df - f)**2)`\n            *   ...对 LKL 和 DW 也做同样的操作。\n        *   返回 6 个值 `[bias_df, mse_df, bias_lkl, mse_lkl, bias_dw, mse_dw]`。\n\n4.  **实现特定用例的细节。**\n    *   **RNG:** `rng = np.random.default_rng(seed=12345)`\n    *   **用例 A:** $N=500, f=0.8$。$C_i \\sim \\text{Beta}(2,5)$。\n        *   `C = rng.beta(2, 5, size=N)`\n    *   **用例 B:** $N=300, f=0.5$。对所有 $i$，$C_i=1$。\n        *   `C = np.ones(N)`\n        *   在这种情况下，$\\sum C_i = N$。所以 $\\hat{f}_{LKL} = \\frac{\\sum D_i}{N}$。\n        *   并且 $\\hat{f}_{DW} = \\frac{1}{N} \\sum \\frac{D_i}{1} = \\frac{\\sum D_i}{N}$。\n        *   所有三个估计量都变得相同：$\\hat{f}_{DF} = \\hat{f}_{LKL} = \\hat{f}_{DW} = \\frac{\\sum D_i}{N}$。\n        *   由于 $C_i=1$, $D_i \\sim \\text{Poisson}(f)$。\n        *   $E[\\hat{f}] = E[\\frac{\\sum D_i}{N}] = \\frac{1}{N} \\sum E[D_i] = \\frac{1}{N} \\sum f = f$。所有估计量都是无偏的。\n        *   它们的偏差应该接近于 0（在模拟误差范围内），它们的均方误差应该相同。这是一个很好的健全性检查。\n    *   **用例 C:** $N=400, f=0.3$。$C_i$ 的混合分布。\n        *   概率 $0.2 \\implies C_i=0$。\n        *   概率 $0.3 \\implies C_i=0.9$。\n        *   概率 $0.5 \\implies C_i \\sim \\text{Beta}(1,3)$。\n        *   生成这个分布：\n            *   生成 $N$ 个均匀随机数 `u = rng.random(size=N)`。\n            *   初始化 `C = np.zeros(N)`。\n            *   `mask1 = u  0.2` (这些得到 $C_i=0$，已经设置好了)。\n            *   `mask2 = (u >= 0.2)  (u  0.5)`。设置 `C[mask2] = 0.9`。\n            *   `mask3 = u >= 0.5`。对于这些，从 Beta 分布中抽取：`C[mask3] = rng.beta(1, 3, size=np.sum(mask3))`。\n    *   **用例 D:** $N=200, f=0.05$。$C_i \\sim \\text{Beta}(2,2)$。\n        *   `C = rng.beta(2, 2, size=N)`\n\n5.  **代码结构。**\n    *   `solve()` 函数。\n    *   将测试用例定义为元组/字典列表。`test_cases = [{'name': 'A', 'N': 500, ...}, ...]`。\n    *   `rng = np.random.default_rng(12345)`。这很重要。问题说“对所有随机抽样（包括 $\\{C_i\\}_{i=1}^N$ 和探测数据的生成），使用以种子 $12345$ 初始化的伪随机数生成器”。这意味着我应该在开始时初始化一次，然后让它运行。这样随机数序列就是确定性的。\n    *   遍历测试用例。\n    *   在循环内部，调用一个辅助函数 `run_simulation(case, rng)`，该函数执行第 3 点中概述的步骤。\n    *   收集结果并格式化最终的打印语句。\n\n6.  **预计算检查与精炼。**\n    *   **估计量的方差（解析）：**\n        *   对于无偏估计量，均方误差就是方差。\n        *   $\\text{Var}(\\hat{f}_{LKL}) = \\text{Var}\\left(\\frac{\\sum D_i}{\\sum C_i}\\right) = \\frac{1}{(\\sum C_i)^2} \\text{Var}(\\sum D_i)$。\n        *   $\\text{Var}(\\sum D_i) = \\sum \\text{Var}(D_i)$ 因为 $D_i$ 是独立的。\n        *   $D_i \\sim \\text{Poisson}(f C_i)$，所以 $\\text{Var}(D_i) = f C_i$。\n        *   $\\text{Var}(\\sum D_i) = \\sum (f C_i) = f \\sum C_i$。\n        *   $\\text{Var}(\\hat{f}_{LKL}) = \\frac{f \\sum C_i}{(\\sum C_i)^2} = \\frac{f}{\\sum C_i}$。\n        *   $\\text{Var}(\\hat{f}_{DW}) = \\text{Var}\\left(\\frac{1}{N} \\sum \\frac{D_i}{C_i}\\right) = \\frac{1}{N^2} \\sum \\text{Var}\\left(\\frac{D_i}{C_i}\\right)$。这假设 $C_i > 0$。如果 $C_i$ 可以为 0，我们需要更小心。让我们使用约定，如果 $C_i=0$，则 $D_i/C_i=0$。\n        *   设 $Y_i = D_i/C_i$ 如果 $C_i>0$，$Y_i=0$ 如果 $C_i=0$。\n        *   $\\text{Var}(Y_i) = E[Y_i^2] - (E[Y_i])^2$。\n        *   $E[Y_i] = E[D_i/C_i] = (1/C_i)E[D_i] = (1/C_i)fC_i = f$ (如果 $C_i>0$)。如果 $C_i=0$，$E[Y_i]=0$。这是错误的。期望是在 $D_i$ 的随机性上取的，将 $C_i$ 视为固定的。$E[Y_i | C_i] = f$ 如果 $C_i > 0$，$0$ 如果 $C_i=0$。让我们重新计算 $E[\\hat{f}_{DW}]$。\n        *   $E[\\hat{f}_{DW}] = E[\\frac{1}{N} \\sum Y_i] = \\frac{1}{N} \\sum E[Y_i]$。\n        *   $E[Y_i] = E[E[Y_i|C_i]]$。这是如果我们也对 $C_i$ 的分布取平均。但是问题陈述说对于给定的巡天配置，$\\{C_i\\}$ 是固定的。所以我们坚持这一点。所以对于*给定*的 $\\{C_i\\}$ 集合，我们有：\n        *   $E[\\hat{f}_{DW}] = \\frac{1}{N} \\sum_{i:C_i>0} E[\\frac{D_i}{C_i}] = \\frac{1}{N} \\sum_{i:C_i>0} \\frac{f C_i}{C_i} = \\frac{1}{N} \\sum_{i:C_i>0} f = f \\frac{N_{C>0}}{N}$，其中 $N_{C>0}$ 是 $C_i>0$ 的恒星数量。\n        *   所以，除非所有 $C_i>0$，否则 $\\hat{f}_{DW}$ 是有偏的。其偏差为 $f(\\frac{N_{C>0}}{N} - 1)$。这是一个重要的认识。让我重新阅读问题描述。\n        *   “探测效率加权估计量，通过其对应的 $C_i$ 值对探测到的行星进行反向加权”\n        *   我的解释 $\\frac{1}{N} \\sum \\frac{D_i}{C_i}$ 是否正确？或者它应该以不同的方式归一化？\n        *   Horvitz-Thompson 的一个常见变体是 Hansen-Hurwitz 估计量，或比率估计量。让我们重新考虑。\n        *   也许“估计的总行星数”不应该除以 $N$，而应该除以*可能*产生探测的恒星数量，即 $N_{C>0}$。所以 $\\hat{f}_{DW}' = (\\sum_{i:C_i>0} D_i/C_i) / N_{C>0}$。\n            *   $E[\\hat{f}_{DW}'] = \\frac{1}{N_{C>0}} \\sum_{i:C_i>0} E[D_i/C_i] = \\frac{1}{N_{C>0}} \\sum_{i:C_i>0} \\frac{f C_i}{C_i} = \\frac{1}{N_{C>0}} (N_{C>0} \\cdot f) = f$。这是无偏的。\n        *   另一种可能性是对所有 $i$ 求和：$\\hat{f} = \\frac{\\sum_{i} w_i D_i}{\\sum_{i} w'_i}$，使用某些权重。如果是每*有效*恒星的平均行星数呢？例如 $\\frac{\\sum D_i/C_i}{\\sum 1}$ -> 这就是我最初的 $\\hat{f}_{DW}$。\n        *   如果估计量是 $(\\sum w_i D_i) / (\\sum w_i C_i)$ 呢？对于 $w_i=1/C_i$，这将是 $(\\sum D_i/C_i)/(\\sum 1) = \\hat{f}_{DW}$。\n        *   如果意图是 $\\frac{\\sum D_i/C_i^2}{\\sum 1/C_i}$ 呢？（在某些模型下用于方差最小化的最优加权）。\n        *   让我们坚持我最初对 $\\hat{f}_{DW} = \\frac{1}{N} \\sum_{i=1}^N \\frac{D_i}{C_i}$ 的解释，并使用当 $C_i=0$ 时 $D_i/C_i = 0$ 的约定。问题措辞“对探测到的行星进行反向加权”指向对 $D_i/C_i$ 这样的项求和。“每颗恒星的平均行星数”建议除以 $N$。\n        *   让我们仔细重新评估用例 C 的偏差。\n            *   在用例 C 中，大约 20% 的恒星将具有 $C_i=0$。所以 $N_{C>0} \\approx 0.8 N$。\n            *   $E[\\hat{f}_{DW}] \\approx f \\frac{0.8N}{N} = 0.8 f$。\n            *   偏差将是 $0.8f - f = -0.2f$。对于 $f=0.3$，偏差约为 $-0.06$。\n            *   这似乎是一个可信的测试场景。它突出了这种估计量的朴素实现的一个潜在失败模式。我对 $\\hat{f}_{DW} = \\frac{1}{N} \\sum \\frac{D_i}{C_i}$（使用 $0/0$ 约定）的解释揭示了当某些 $C_i=0$ 时存在偏差。这与最大似然估计量形成了有趣的对比。\n        *   让我们重新计算 $\\hat{f}_{DW}$ 的方差。\n        *   $\\text{Var}(\\hat{f}_{DW}) = \\text{Var}\\left(\\frac{1}{N} \\sum_{i} \\frac{D_i}{C_i}\\right) = \\frac{1}{N^2} \\sum_{i} \\text{Var}\\left(\\frac{D_i}{C_i}\\right)$。（求和遍及所有 $i$，使用 $0/0$ 约定）。\n        *   项 $\\text{Var}(D_i/C_i)$ 是在 $C_i$ 固定的情况下计算的。\n        *   如果 $C_i > 0$，$\\text{Var}(D_i/C_i) = \\frac{1}{C_i^2}\\text{Var}(D_i) = \\frac{fC_i}{C_i^2} = \\frac{f}{C_i}$。\n        *   如果 $C_i=0$，那么 $D_i$ 总是 0，所以 $D_i/C_i$ 总是 0，其方差为 0。\n        *   所以，$\\text{Var}(\\hat{f}_{DW}) = \\frac{1}{N^2} \\sum_{i: C_i>0} \\frac{f}{C_i} = \\frac{f}{N^2} \\sum_{i: C_i>0} \\frac{1}{C_i}$。\n        *   所以我们得到了两个无偏估计量（当所有 $C_i > 0$ 时）的方差：\n            *   $\\text{Var}(\\hat{f}_{LKL}) = \\frac{f}{\\sum C_i}$。\n            *   $\\text{Var}(\\hat{f}_{DW}) = \\frac{f}{N^2} \\sum \\frac{1}{C_i}$。\n        *   根据柯西-施瓦茨不等式，$(\\sum a_i b_i)^2 \\leq (\\sum a_i^2)(\\sum b_i^2)$。\n        *   设 $a_i = \\sqrt{C_i}$ 和 $b_i = 1/\\sqrt{C_i}$。\n        *   $(\\sum 1)^2 \\leq (\\sum C_i)(\\sum 1/C_i) \\implies N^2 \\leq (\\sum C_i)(\\sum 1/C_i)$。\n        *   $\\frac{1}{\\sum C_i} \\leq \\frac{1}{N^2} \\sum \\frac{1}{C_i}$。\n        *   乘以 $f$: $\\frac{f}{\\sum C_i} \\leq \\frac{f}{N^2} \\sum \\frac{1}{C_i}$。\n        *   这意味着 $\\text{Var}(\\hat{f}_{LKL}) \\leq \\text{Var}(\\hat{f}_{DW})$。这是符合预期的，因为最大似然估计量应该是渐进有效的。模拟应该证实这一点：当所有 $C_i > 0$ 时，LKL 的均方误差应小于或等于 DW 的均方误差（因为此时它们都是无偏的）。\n        *   这个理论检查让我对推导出的估计量和预期的模拟结果充满信心。我对 $\\hat{f}_{DW}$ 的解释似乎是合理的，并创造了一个有趣的比较。\n\n    *   **步骤 3: 结论和行动**\n        -   问题是**有效的**。\n        -   行动：继续解决问题。\n\n    解决方案部分将首先介绍基于泊松稀疏化模型的三个估计量的推导。然后它将描述用于计算偏差和均方误差的模拟设置。最终答案将是实现这一过程的 Python 代码。逻辑现在看来完全可靠。我将仔细编写解决方案文本，确保所有数学实体都使用 LaTeX 格式。",
            "answer": "```python\nimport numpy as np\n\ndef run_simulation(N, f_true, c_dist_func, R, rng):\n    \"\"\"\n    为单个测试用例运行蒙特卡洛模拟。\n\n    Args:\n        N (int): 恒星数量。\n        f_true (float): 每颗恒星的行星真实平均数。\n        c_dist_func (callable): 用于生成完备性值 C_i 的函数。\n        R (int): 蒙特卡洛复制的次数。\n        rng (np.random.Generator): 随机数生成器实例。\n\n    Returns:\n        list: 一个包含6个浮点数的列表: [bias_df, mse_df, bias_lkl, mse_lkl, bias_dw, mse_dw]。\n    \"\"\"\n    # 1. 为该用例生成固定的巡天完备性值 {C_i}。\n    # 每次模拟只执行一次，因为这是巡天的固定属性。\n    C = c_dist_func(N, rng)\n\n    # 2. 初始化数组以存储每次复制的结果。\n    estimates_df = np.zeros(R)\n    estimates_lkl = np.zeros(R)\n    estimates_dw = np.zeros(R)\n\n    # 3. 为提高效率，预先计算基于 C 的项。\n    sum_C = np.sum(C)\n    \n    # 创建一个 1/C_i 的数组，安全地处理 C_i=0 的情况。\n    # 当 C_i 为 0 时，其倒数为 0。这是安全的，因为 D_i 也将为 0。\n    inv_C = np.zeros_like(C, dtype=float)\n    nonzero_mask = C > 0\n    inv_C[nonzero_mask] = 1.0 / C[nonzero_mask]\n\n    # 4. 运行 R 次蒙特卡洛复制。\n    for r in range(R):\n        # 为每颗恒星 i 生成探测到的行星数 D_i。\n        # 这源于泊松稀疏化模型：D_i ~ Poisson(f_true * C_i)。\n        D = rng.poisson(f_true * C)\n        sum_D = np.sum(D)\n\n        # 估计量 1：基于探测分数法 (DF)\n        # 这个朴素的估计量忽略了探测效率。\n        f_hat_df = sum_D / N\n        estimates_df[r] = f_hat_df\n\n        # 估计量 2：基于似然法 (LKL)\n        # 这是 f 的最大似然估计量。\n        # 处理 sum_C 为零的情况以避免除以零。\n        # 在给定的测试场景中，这种情况发生的概率可以忽略不计。\n        if sum_C > 0:\n            f_hat_lkl = sum_D / sum_C\n        else:\n            # 如果 sum_C 为 0，则不可能有任何探测，所以 sum_D 必须为 0。\n            # 似然函数是平坦的，但估计值为 0 是合理的。\n            f_hat_lkl = 0.0\n        estimates_lkl[r] = f_hat_lkl\n\n        # 估计量 3：探测效率加权 (DW)\n        # 每个探测到的 D_i 都由 1/C_i 加权。\n        # 对于 C_i=0 的索引，乘积 D * inv_C 为 0，因为 D_i 也为 0。\n        f_hat_dw = np.sum(D * inv_C) / N\n        estimates_dw[r] = f_hat_dw\n\n    # 5. 计算每个估计量的偏差和均方误差 (MSE)。\n    # 偏差 = E[f_hat] - f_true\n    bias_df = np.mean(estimates_df) - f_true\n    bias_lkl = np.mean(estimates_lkl) - f_true\n    bias_dw = np.mean(estimates_dw) - f_true\n\n    # 均方误差 = E[(f_hat - f_true)^2]\n    mse_df = np.mean((estimates_df - f_true)**2)\n    mse_lkl = np.mean((estimates_lkl - f_true)**2)\n    mse_dw = np.mean((estimates_dw - f_true)**2)\n\n    return [bias_df, mse_df, bias_lkl, mse_lkl, bias_dw, mse_dw]\n\ndef solve():\n    \"\"\"\n    主函数，用于运行所有测试用例并打印最终输出。\n    \"\"\"\n    # 全局模拟参数\n    R = 10000\n    SEED = 12345\n    rng = np.random.default_rng(SEED)\n\n    # 为每个用例定义 C_i 分布的生成器函数。\n    def c_dist_A(n, r): return r.beta(2, 5, size=n)\n    def c_dist_B(n, r): return np.ones(n)\n    def c_dist_C(n, r):\n        C = np.zeros(n)\n        u = r.random(size=n)\n        mask_90 = (u >= 0.2)  (u  0.5)\n        mask_beta = u >= 0.5\n        C[mask_90] = 0.9\n        num_beta = np.sum(mask_beta)\n        if num_beta > 0:\n            C[mask_beta] = r.beta(1, 3, size=num_beta)\n        return C\n    def c_dist_D(n, r): return r.beta(2, 2, size=n)\n\n    # 定义测试套件\n    test_cases = [\n        {'N': 500, 'f': 0.8, 'c_dist': c_dist_A},\n        {'N': 300, 'f': 0.5, 'c_dist': c_dist_B},\n        {'N': 400, 'f': 0.3, 'c_dist': c_dist_C},\n        {'N': 200, 'f': 0.05, 'c_dist': c_dist_D},\n    ]\n\n    # 运行模拟并收集结果\n    all_results = []\n    for case in test_cases:\n        results = run_simulation(\n            case['N'], case['f'], case['c_dist'], R, rng\n        )\n        all_results.append(results)\n\n    # 完全按照指定格式化输出字符串。\n    # 例如：\"[[b1,m1,b2,m2,b3,m3],[...],...]\"\n    case_strings = []\n    for res_list in all_results:\n        case_strings.append(f\"[{','.join(map(str, res_list))}]\")\n    \n    final_output = f\"[{','.join(case_strings)}]\"\n    print(final_output)\n\nsolve()\n```"
        }
    ]
}