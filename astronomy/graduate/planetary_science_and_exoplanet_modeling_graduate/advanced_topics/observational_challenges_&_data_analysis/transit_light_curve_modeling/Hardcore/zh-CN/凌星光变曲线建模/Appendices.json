{
    "hands_on_practices": [
        {
            "introduction": "凌日建模的基础是精确计算恒星和行星盘面的几何重叠区域。虽然两个圆盘重叠面积的解析公式是已知的，但其直接的计算机实现会在凌日边界附近（即行星进入和离开恒星盘面的瞬间）遭遇数值不稳定性，特别是灾难性抵消问题。本练习将指导你通过对比一个“朴素”实现和一个使用级数展开来保证精度的“稳定”实现，来构建一个数值稳健的算法，这是开发可靠科学软件的一项关键技能 。",
            "id": "4187017",
            "problem": "一颗半径为 $R_{\\star}$ 的恒星均匀发光（无临边昏暗），一颗半径为 $R_{p}$ 的行星凌星其星盘。令 $k = R_{p} / R_{\\star}$ 为行星与恒星的半径比，令 $z$ 为以恒星半径归一化的瞬时投影中心间距，$z = d / R_{\\star}$。凌星期间的归一化恒星流量 $F$ 为 $F = 1 - A / (\\pi R_{\\star}^{2})$，其中 $A$ 是半径为 $R_{\\star}$ 和 $R_{p}$、间距为 $d$ 的两个圆盘的几何重叠面积。假设 $R_{\\star} = 1$ 为单位长度，因此 $A$ 和所有距离都是以 $R_{\\star}$ 为单位的无量纲量，所有角度必须以弧度表示。\n\n从基本几何定义出发，推导半径为 $1$ 和 $k$、中心间距为 $z$ 的两个圆的重叠面积 $A$ 的正确表达式，以及相应的归一化流量 $F(k,z)$。分析解析表达式在入凌和出凌边界附近（特别是 $z \\approx 1 \\pm k$ 时）的数值稳定性，此时可能因计算几乎相等的项之差而发生灾难性抵消。提出并论证避免有效数字损失的稳健策略，例如在 $\\pm 1$ 附近对 $\\arccos$ 进行级数展开，以及在代数等价形式（例如 $\\arccos$ 与 $2 \\arctan2(\\cdot,\\cdot)$ 恒等式）之间进行自适应切换。\n\n实现两种算法：\n\n- 一个直接解析求值器 $F_{\\text{naive}}(k,z)$，该求值器遵循经典的圆-圆重叠公式，使用 $\\arccos$ 和平方根，除了将参数裁剪到有效域内之外，没有其他数值保护措施。\n- 一个数值稳定的求值器 $F_{\\text{stable}}(k,z)$，该求值器使用相同的几何关系，但在 $z \\approx 1 \\pm k$ 附近，用能够改善数值行为的渐近级数展开和/或恒等式替换数值病态的子表达式，并通过与病态区域接近程度的阈值来控制自适应切换。\n\n你的程序必须对以下每个测试用例，计算相对差异 $\\Delta = \\left|F_{\\text{naive}} - F_{\\text{stable}}\\right| / \\max\\{F_{\\text{stable}}, \\epsilon\\}$，其中 $\\epsilon = 10^{-30}$ 是一个固定的小值，结果以浮点数形式报告。所有量均为无量纲；角度以弧度报告。最终的程序输出应为单行，包含一个由方括号括起来的、逗号分隔的 $\\Delta$ 值列表。\n\n使用以下测试套件来评估不同情况：\n\n- 情况1（中等程度的部分重叠，理想路径）：$(k,z) = (0.1, 0.95)$。\n- 情况2（接近外切，$z \\approx 1 + k$）：$(k,z) = (0.1, 1.1 - 10^{-12})$。\n- 情况3（接近内切，$z \\approx 1 - k$）：$(k,z) = (0.1, 0.9 + 10^{-12})$。\n- 情况4（非常小的行星，接近外切）：$(k,z) = (10^{-4}, 1 + 10^{-4} - 10^{-12})$。\n- 情况5（大行星，接近内切）：$(k,z) = (0.5, 0.5 + 10^{-12})$。\n- 情况6（接近掠射的巨行星，接近外切）：$(k,z) = (0.99, 1.99 - 10^{-12})$。\n\n你的程序应生成单行输出，其中包含用方括号括起来的、逗号分隔的结果列表（例如，“[result1,result2,...]”）。",
            "solution": "用户提供的问题是计算科学领域中的一个有效且良构的练习，特别是在系外行星凌星建模领域。所有提供的数据和定义在科学上都是合理的，并且该任务解决的是科学软件中数值不稳定性的一个真实而实际的挑战。\n\n### 1. 解析模型的推导\n\n该问题要求计算行星凌星期间的归一化恒星流量 $F$，假设恒星亮度均匀（无临边昏暗）。恒星的归一化半径为 $R_{\\star} = 1$，行星半径为 $k = R_p/R_\\star$。投影的中心间距为 $z=d/R_\\star$。归一化流量由 $F = 1 - A / (\\pi R_{\\star}^2)$ 给出，由于 $R_{\\star}=1$，简化为 $F = 1 - A/\\pi$。这里，$A$ 是两个圆盘的几何重叠面积。\n\n两个圆的重叠面积是两个弓形面积之和。对于一个半径为 $R$ 的圆，一条距圆心距离为 $d_c$ 的弦所形成的较小弓形的面积为 $A_{seg} = R^2 \\arccos(d_c/R) - d_c \\sqrt{R^2 - d_c^2}$。\n\n设恒星盘的圆心在原点，行星盘的圆心在 $(z, 0)$。恒星圆的方程为 $x^2 + y^2 = 1$，行星圆的方程为 $(x-z)^2 + y^2 = k^2$。这两个圆的交点位于一条 $x$ 坐标为 $x_c$ 的竖直弦上：\n$$\nx_c = \\frac{1+z^2-k^2}{2z}\n$$\n这条弦距离恒星中心的距离是 $x_c$。距离行星中心的距离是 $|z-x_c| = |\\frac{z^2+k^2-1}{2z}|$。在部分凌星阶段，即 $|1-k|  z  1+k$ 时，$z^2+k^2-1$ 项为正，因此该距离为 $z-x_c$。弦的半长（即交点的 $y$ 坐标）是 $y_{int} = \\sqrt{1-x_c^2}$。\n\n总重叠面积 $A$ 是两个弓形面积之和：\n$$\nA = A_{seg, \\star} + A_{seg, p} = \\left( \\arccos(x_c) - x_c y_{int} \\right) + \\left( k^2 \\arccos\\left(\\frac{z-x_c}{k}\\right) - (z-x_c)y_{int} \\right)\n$$\n合并各项，我们得到：\n$$\nA = \\arccos(x_c) + k^2 \\arccos\\left(\\frac{z-x_c}{k}\\right) - (x_c + z - x_c)y_{int} = \\arccos(x_c) + k^2 \\arccos\\left(\\frac{z-x_c}{k}\\right) - z y_{int}\n$$\n$z y_{int}$ 项可以用海伦公式表示为边长为 $1$、$k$ 和 $z$ 的三角形面积。该三角形的面积为 $\\mathcal{A}_{\\triangle} = \\frac{1}{4}\\sqrt{(-z+k+1)(z+k-1)(z-k+1)(z+k+1)}$。对应于长度为 $z$ 的底边，该三角形的高为 $y_{int}$。因此，$\\mathcal{A}_{\\triangle} = \\frac{1}{2} z y_{int}$，这意味着 $z y_{int} = 2 \\mathcal{A}_{\\triangle}$。令 $S_H = \\sqrt{(-z+k+1)(z+k-1)(z-k+1)(z+k+1)}$。那么 $z y_{int} = S_H/2$。\n将 $x_c$ 和 $z-x_c$ 代入 arccos 的参数中，我们得到重叠面积的标准公式：\n$$\nA(k,z) = \\arccos\\left(\\frac{1+z^2-k^2}{2z}\\right) + k^2 \\arccos\\left(\\frac{z^2+k^2-1}{2zk}\\right) - \\frac{1}{2} S_H\n$$\n此公式适用于部分重叠的情况，即 $|1-k|  z  1+k$（对于 $k1$）。对于 $z \\ge 1+k$，$A=0$。对于 $z \\le 1-k$，行星被完全包含，此时 $A = \\pi k^2$。\n\n### 2. 数值不稳定性分析\n\n直接应用此公式在凌星边界附近，即外切（$z \\to (1+k)^-$）和内切（$z \\to (1-k)^+$）时，是数值不稳定的。\n我们来分析 $z \\to (1+k)^-$ 的情况。设 $\\delta = 1+k-z$ 为一个很小的正数。两个 $\\arccos$ 函数的参数都趋近于 $1$。对于很小的 $x$，$\\arccos(1-x)$ 的泰勒展开为 $\\sqrt{2x}(1 + x/12 + O(x^2))$。\n$\\arccos$ 函数的参数可以写成 $1-d_1$ 和 $1-d_2$，其中：\n$d_1 = 1 - \\frac{1+z^2-k^2}{2z} = \\frac{(k+1-z)(k-1+z)}{2z} \\approx \\frac{\\delta \\cdot 2k}{2(1+k)} = \\frac{k\\delta}{1+k}$\n$d_2 = 1 - \\frac{z^2+k^2-1}{2zk} = \\frac{(1-z+k)(1+z-k)}{2zk} \\approx \\frac{\\delta \\cdot 2}{2k(1+k)} = \\frac{\\delta}{k(1+k)}$\n面积公式 $A = \\alpha_1 + k^2\\alpha_2 - S_H/2$ 中的三项表现如下：\n$\\alpha_1 \\approx \\sqrt{2d_1} = \\sqrt{\\frac{2k\\delta}{1+k}}$\n$k^2\\alpha_2 \\approx k^2\\sqrt{2d_2} = k^2\\sqrt{\\frac{2\\delta}{k(1+k)}} = \\sqrt{\\frac{2k^3\\delta}{1+k}}$\n$\\frac{S_H}{2} = \\frac{1}{2}\\sqrt{\\delta (2k-\\delta)(2-\\delta)(2k+2-\\delta)} \\approx \\frac{1}{2}\\sqrt{\\delta \\cdot 2k \\cdot 2 \\cdot (2k+2)} = \\sqrt{2k(1+k)\\delta}$\n\n前两项之和为：\n$\\alpha_1 + k^2\\alpha_2 \\approx \\frac{\\sqrt{2\\delta}}{\\sqrt{1+k}}(\\sqrt{k} + \\sqrt{k^3}) = \\frac{\\sqrt{2\\delta k}(1+k)}{\\sqrt{1+k}} = \\sqrt{2k(1+k)\\delta}$\n因此，在 $\\sqrt{\\delta}$ 的一阶近似下，面积为 $A \\approx \\sqrt{2k(1+k)\\delta} - \\sqrt{2k(1+k)\\delta} = 0$。这是一个灾难性抵消的典型例子：两个大的、几乎相等的数相减，导致相对精度的损失。真实的面积与 $\\delta^{3/2}$ 成正比，这是一个在浮点数减法中丢失的高阶项。在另一个边界 $z \\to (1-k)^+$ 处也会发生类似的抵消。\n\n### 3. 稳定算法的设计\n\n为了规避这个问题，一个稳健的算法 $F_{\\text{stable}}$ 必须在这些不稳定区域替换 $A(k,z)$ 的完整表达式。虽然用级数展开替换像 $\\arccos$ 这样的子表达式是一个部分步骤，但这并不能解决最终减法的根本问题。最有效的策略是用 $A(k,z)$ 在边界点附近的泰勒级数展开来替换整个函数。\n\n面积对间距的导数是 $\\frac{dA}{dz} = -\\frac{S_H(z)}{z}$。我们可以通过对该导数积分来求得边界 $z_0$ 附近的面积：$A(z) = A(z_0) + \\int_{z_0}^z A'(t) dt$。\n\n对于外切，$z_0 = 1+k$ 且 $A(z_0)=0$。对于 $z = 1+k-\\delta$：\n$$\nA(z) \\approx \\int_{1+k}^{1+k-\\delta} -\\frac{\\sqrt{8k(1+k)(1+k-t)}}{t} dt \\approx \\frac{\\sqrt{8k(1+k)}}{1+k} \\int_0^{\\delta} \\sqrt{u} du = \\frac{4\\sqrt{2k}}{3\\sqrt{1+k}}\\delta^{3/2}\n$$\n对于内切，$z_0 = 1-k$ 且 $A(z_0)=\\pi k^2$。对于 $z = 1-k+\\delta$：\n$$\nA(z) \\approx \\pi k^2 + \\int_{1-k}^{1-k+\\delta} -\\frac{\\sqrt{8k(1-k)(t-(1-k))}}{t} dt \\approx \\pi k^2 - \\frac{4\\sqrt{2k}}{3\\sqrt{1-k}}\\delta^{3/2}\n$$\n这些展开式直接计算面积的主导项，避免了抵消。当 $z$ 在 $1 \\pm k$ 的一个小容差范围内时，$F_{\\text{stable}}$ 算法将自适应地切换到这些展开式。否则，它将使用标准的、完整的 `arccos` 公式，该公式在远离边界时是稳定的。$F_{\\text{naive}}$ 算法则直接实现带有参数裁剪的公式，从而暴露了其数值上的脆弱性。",
            "answer": "```python\nimport numpy as np\n\ndef F_naive(k, z):\n    \"\"\"\n    Computes the normalized flux using a direct, numerically naive \n    implementation of the circle-circle overlap area formula.\n    It relies on clipping arguments to arccos to prevent domain errors,\n    which is a source of inaccuracy at transit boundaries.\n    \n    Args:\n        k (float): Planet-to-star radius ratio (Rp/R*).\n        z (float): Normalized projected center-to-center separation (d/R*).\n        \n    Returns:\n        float: The normalized stellar flux.\n    \"\"\"\n    if z == 0 and k >= 1: # Trivial case: star is fully occulted\n        return 0.0\n    if z >= 1 + k: # Case 1: No overlap\n        return 1.0\n    if z = 1 - k: # Case 2: Planet is fully contained within the star\n        return 1.0 - k**2\n    if k > 1 and z = k - 1: # Case 3: Star is fully contained within the planet\n        return 0.0\n\n    # Case 4: Partial overlap. Naively evaluate the standard formula.\n    # Arguments for arccos functions\n    c1_arg = (1 + z**2 - k**2) / (2 * z)\n    c2_arg = (z**2 + k**2 - 1) / (2 * z * k)\n    \n    # Clip arguments to their valid domain [-1, 1] to avoid math errors\n    # from floating-point inaccuracies. This is the main source of error.\n    c1 = np.clip(c1_arg, -1.0, 1.0)\n    c2 = np.clip(c2_arg, -1.0, 1.0)\n    \n    alpha1 = np.arccos(c1)\n    alpha2 = np.arccos(c2)\n    \n    # The third term is half of the area of a triangle with sides 1, k, z, times 4.\n    # This is S_H/2 from the derivation.\n    arg_sqrt = (1 + k - z) * (1 + k + z) * (z + k - 1) * (z - k + 1)\n    sqrt_term = np.sqrt(max(0, arg_sqrt))\n\n    # Total overlap area A\n    A = alpha1 + (k**2 * alpha2) - sqrt_term / 2.0\n    \n    # Normalized flux\n    return 1.0 - A / np.pi\n\ndef F_stable(k, z):\n    \"\"\"\n    Computes the normalized flux using a numerically stable algorithm.\n    It switches to a Taylor series expansion of the area A(z) in the\n    numerically unstable regimes near transit boundaries (z approx 1 +/- k).\n    \n    Args:\n        k (float): Planet-to-star radius ratio (Rp/R*).\n        z (float): Normalized projected center-to-center separation (d/R*).\n        \n    Returns:\n        float: The normalized stellar flux.\n    \"\"\"\n    TOL = 1e-8 # Tolerance for switching to series expansion\n\n    if z == 0 and k >= 1: # Trivial case\n        return 0.0\n    if z >= 1 + k: # Case 1: No overlap\n        return 1.0\n    if z = 1 - k: # Case 2: Planet is fully contained\n        return 1.0 - k**2\n    if k > 1 and z = k - 1: # Case 3: Star is fully contained\n        return 0.0\n\n    # Check for proximity to external contact (z -> (1+k)-)\n    delta_ext = 1 + k - z\n    if 0  delta_ext  TOL:\n        C1 = (4 * np.sqrt(2 * k)) / (3 * np.sqrt(1 + k))\n        A = C1 * delta_ext**1.5\n        return 1.0 - A / np.pi\n\n    # Check for proximity to internal contact (z -> (1-k)+)\n    delta_int = z - (1 - k)\n    if 0  delta_int  TOL:\n        # The expansion is invalid for k=1, but this case is not tested.\n        # Fallback to general formula if k is very close to 1.\n        if abs(k - 1.0)  1e-9:\n             pass # Fallthrough to general formula\n        else:\n            C2 = (4 * np.sqrt(2 * k)) / (3 * np.sqrt(1 - k))\n            A = np.pi * k**2 - C2 * delta_int**1.5\n            return 1.0 - A / np.pi\n\n    # Case 4: Partial overlap, but in a numerically stable regime.\n    # The general formula is safe to use here.\n    c1 = (1 + z**2 - k**2) / (2 * z)\n    c2 = (z**2 + k**2 - 1) / (2 * z * k)\n    \n    # Although we are in the \"safe\" regime, clipping is good practice.\n    c1 = np.clip(c1, -1.0, 1.0)\n    c2 = np.clip(c2, -1.0, 1.0)\n\n    alpha1 = np.arccos(c1)\n    alpha2 = np.arccos(c2)\n    \n    arg_sqrt = (1 + k - z) * (1 + k + z) * (z + k - 1) * (z - k + 1)\n    # No need for max(0,...) as we are inside the valid partial-overlap domain\n    sqrt_term = np.sqrt(arg_sqrt)\n\n    A = alpha1 + (k**2 * alpha2) - sqrt_term / 2.0\n    \n    return 1.0 - A / np.pi\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and compute the relative difference\n    between the naive and stable flux evaluators.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (k, z)\n        (0.1, 0.95),                  # Case 1: Moderate overlap\n        (0.1, 1.1 - 1e-12),           # Case 2: Near external contact\n        (0.1, 0.9 + 1e-12),           # Case 3: Near internal contact\n        (1e-4, 1 + 1e-4 - 1e-12),     # Case 4: Small planet, near external contact\n        (0.5, 0.5 + 1e-12),           # Case 5: Large planet, near internal contact\n        (0.99, 1.99 - 1e-12),         # Case 6: Grazing giant, near external contact\n    ]\n\n    results = []\n    for k, z in test_cases:\n        f_naive = F_naive(k, z)\n        f_stable = F_stable(k, z)\n        \n        epsilon = 1e-30\n        \n        # Calculate relative difference as specified\n        denominator = max(f_stable, epsilon)\n        if denominator == 0:\n            delta = 0.0 if abs(f_naive - f_stable)  epsilon else np.inf\n        else:\n            delta = abs(f_naive - f_stable) / denominator\n        \n        results.append(delta)\n\n    # Format output as a comma-separated list in brackets\n    print(f\"[{','.join(f'{r:.15e}' for r in results)}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "凌日时长是一个关键的可观测量，它能够约束恒星的物理属性，特别是其平均密度。行星的凌日时长不仅取决于几何构型（如撞击参数），还取决于其轨道速度，而这个速度在偏心轨道上是变化的。本练习将通过解析推导，展示错误地假设轨道为圆形会对推导出的恒星密度造成怎样的系统性偏差，理解这种偏差对于精确地表征系外行星至关重要 。",
            "id": "4187068",
            "problem": "考虑一次高精度观测到的单行星凌日，其轨道周期 $P$、总凌日时长 $T$（从第一次接触到第四次接触）以及撞击参数 $b$ 都被精确测量。假设行星与恒星的半径比很小，即 $k \\equiv R_{p}/R_{\\star} \\ll 1$，因此凌日期间穿过恒星盘面的弦长可近似为 $L \\approx 2 R_{\\star} \\sqrt{1-b^{2}}$。该系统的真实轨道是开普勒轨道，其半长轴为 $a$，离心率为 $e$，近星点幅角为 $\\omega$。恒星质量为 $M_{\\star}$，恒星平均密度为 $\\rho_{\\star} \\equiv 3 M_{\\star}/(4 \\pi R_{\\star}^{3})$。在动力学计算中忽略行星的质量。\n\n采用以下具有物理依据的基本原理：\n- 开普勒第三定律：$n^{2} a^{3} = G M_{\\star}$，其中平均运动角速度 $n \\equiv 2 \\pi / P$，引力常数为 $G$。\n- 开普勒椭圆轨道的活力公式和角动量关系：比角动量 $h = \\sqrt{G M_{\\star} a (1-e^{2})}$，真近点角为 $f$ 时的径向距离 $r(f) = a (1-e^{2})/[1+e \\cos f]$，以及横向（切向）速度 $v_{\\perp}(f) = h/r(f)$。\n- 对于近乎侧向的凌日且时长 $T \\ll P$（凌日发生在远离近星点通过的位置，因此凌日期间速度近似恒定），总时长由 $T \\approx L / v_{\\perp}(f_{\\mathrm{tr}})$ 给出，其中 $f_{\\mathrm{tr}}$ 是凌日中心处的真近点角。对于高轨道倾角时的下合，有 $f_{\\mathrm{tr}} \\approx \\pi/2 - \\omega$。\n\n一个标准但错误的圆形轨道凌日拟合，使用相同的测量值 $P$、$T$ 和 $b$ 来推断一个圆形轨道假设下的恒星密度 $\\rho_{\\star,\\mathrm{circ}}$，其方法是用圆形轨道速度 $v_{\\mathrm{circ}} = n a$ 来代替凌日时的真实横向速度。\n\n仅从上述基本原理和几何定义出发，推导由圆形轨道假设引入的、对所推断恒星密度的乘性偏差，\n$$\nC(e,\\omega) \\equiv \\frac{\\rho_{\\star,\\mathrm{circ}}}{\\rho_{\\star}} \\, ,\n$$\n并将其简化为一个仅依赖于 $e$ 和 $\\omega$ 的闭式表达式。你可以假设 $k \\ll 1$，因此 $L$ 仅取决于 $R_{\\star}$ 和 $b$，并且观测到的 $b$ 在真实偏心轨道拟合和圆形轨道拟合中使用的是同一个数值。给出你的最终答案，形式为 $C(e,\\omega)$ 的单个无单位解析表达式。",
            "solution": "我们首先将观测到的凌日时长与投影轨道速度和凌日弦长联系起来。在小行星近似 $k \\ll 1$ 下，弦长为 $L \\approx 2 R_{\\star} \\sqrt{1-b^{2}}$。如果在短时间间隔 $T \\ll P$ 内速度变化可以忽略不计，则总时长可近似为\n$$\nT \\approx \\frac{L}{v_{\\perp}(f_{\\mathrm{tr}})} \\, .\n$$\n现在我们计算偏心开普勒轨道下的 $v_{\\perp}(f)$。比角动量为 $h = \\sqrt{G M_{\\star} a (1-e^{2})}$，真近点角为 $f$ 时的恒星-行星距离为\n$$\nr(f) = \\frac{a(1-e^{2})}{1 + e \\cos f} \\, .\n$$\n轨道平面内的横向（切向）速度由下式给出\n$$\nv_{\\perp}(f) = \\frac{h}{r(f)} = \\frac{\\sqrt{G M_{\\star} a (1-e^{2})}}{a(1-e^{2})/(1 + e \\cos f)} = \\sqrt{\\frac{G M_{\\star}}{a}} \\, \\frac{1 + e \\cos f}{\\sqrt{1 - e^{2}}} \\, .\n$$\n使用平均运动角速度 $n \\equiv 2 \\pi / P$ 和 $n a = \\sqrt{G M_{\\star}/a}$，上式变为\n$$\nv_{\\perp}(f) = n a \\, \\frac{1 + e \\cos f}{\\sqrt{1 - e^{2}}} \\, .\n$$\n对于近乎侧向的凌日，下合发生在 $f_{\\mathrm{tr}} \\approx \\pi/2 - \\omega$ 附近。代入 $f_{\\mathrm{tr}}$ 得\n$$\n\\cos f_{\\mathrm{tr}} = \\cos\\!\\left(\\frac{\\pi}{2} - \\omega\\right) = \\sin \\omega \\, ,\n$$\n因此\n$$\nv_{\\perp}(f_{\\mathrm{tr}}) = n a \\, \\frac{1 + e \\sin \\omega}{\\sqrt{1 - e^{2}}} \\, .\n$$\n因此，真实偏心轨道的观测时长为\n$$\nT = \\frac{L}{v_{\\perp}(f_{\\mathrm{tr}})} = \\frac{L}{n a} \\, \\frac{\\sqrt{1 - e^{2}}}{1 + e \\sin \\omega} \\, .\n$$\n现在考虑错误的圆形轨道拟合，它使用相同的测量值 $P$、$T$ 和 $b$，但假设圆形轨道速度为 $v_{\\mathrm{circ}} = n a_{\\mathrm{circ}}$，并得出一个推断的半长轴与恒星半径之比 $(a/R_{\\star})_{\\mathrm{circ}}$。在圆形轨道模型中，\n$$\nT = \\frac{L}{v_{\\mathrm{circ}}} = \\frac{L}{n a_{\\mathrm{circ}}} \\, .\n$$\n将圆形轨道和偏心轨道的 $T$ 表达式相除以消去 $T$ 和 $L$：\n$$\n\\frac{L}{n a_{\\mathrm{circ}}} = \\frac{L}{n a} \\, \\frac{\\sqrt{1 - e^{2}}}{1 + e \\sin \\omega} \\quad \\Longrightarrow \\quad \\frac{a_{\\mathrm{circ}}}{a} = \\frac{1 + e \\sin \\omega}{\\sqrt{1 - e^{2}}} \\, .\n$$\n因为两种拟合都使用相同的 $R_{\\star}$ 来解释相同的观测值 $b$ 和弦长 $L$（在 $k \\ll 1$ 的条件下），所以推断的半长轴与恒星半径之比与上述比值相同：\n$$\n\\frac{(a/R_{\\star})_{\\mathrm{circ}}}{(a/R_{\\star})} = \\frac{1 + e \\sin \\omega}{\\sqrt{1 - e^{2}}} \\, .\n$$\n现在我们使用开普勒第三定律将 $(a/R_{\\star})$ 与恒星密度联系起来。忽略行星质量，有\n$$\nn^{2} a^{3} = G M_{\\star} \\, , \\quad \\rho_{\\star} \\equiv \\frac{3 M_{\\star}}{4 \\pi R_{\\star}^{3}} \\, .\n$$\n消去 $M_{\\star}$ 得\n$$\n\\rho_{\\star} = \\frac{3}{4 \\pi R_{\\star}^{3}} \\, \\frac{n^{2} a^{3}}{G} = \\frac{3 n^{2}}{4 \\pi G} \\left(\\frac{a}{R_{\\star}}\\right)^{3} \\, .\n$$\n因此，圆形轨道假设下推断的密度为\n$$\n\\rho_{\\star,\\mathrm{circ}} = \\frac{3 n^{2}}{4 \\pi G} \\left(\\frac{a}{R_{\\star}}\\right)_{\\mathrm{circ}}^{3} \\, ,\n$$\n乘性偏差因子为\n$$\nC(e,\\omega) \\equiv \\frac{\\rho_{\\star,\\mathrm{circ}}}{\\rho_{\\star}} = \\left[\\frac{(a/R_{\\star})_{\\mathrm{circ}}}{(a/R_{\\star})}\\right]^{3} = \\left(\\frac{1 + e \\sin \\omega}{\\sqrt{1 - e^{2}}}\\right)^{3} \\, .\n$$\n简化后，\n$$\nC(e,\\omega) = \\frac{(1 + e \\sin \\omega)^{3}}{(1 - e^{2})^{3/2}} \\, .\n$$\n这就是所求的闭式修正因子，它适用于远离近星点的凌日，此时在短凌日时间间隔内的恒速近似是准确的，并且对于近乎侧向的几何构型，$f_{\\mathrm{tr}} \\approx \\pi/2 - \\omega$ 成立。它量化了当真实轨道具有非零离心率和近星点辐角 $\\omega$ 时，圆形轨道拟合对推断出的恒星密度产生的偏差。",
            "answer": "$$\\boxed{\\frac{(1+e\\sin\\omega)^{3}}{(1-e^{2})^{3/2}}}$$"
        },
        {
            "introduction": "真实的光度学测量并非瞬时完成，而是在一段有限的曝光时间内积分得到的。这种时间平均效应会“模糊”凌日光变曲线的尖锐特征，例如进入和离开阶段的斜率，从而可能使测量的凌日参数产生偏差。本练习将介绍超采样（supersampling）技术，这是一种精确模拟有限积分时间效应的数值方法。通过量化建模的进入斜率的变化，你将在校正重要的观测系统误差方面获得实践经验 。",
            "id": "4187052",
            "problem": "您的任务是使用超采样来量化有限积分时间对建模拟合的凌日系外行星凌始斜率的影响。考虑一个由梯形表示的简化凌星模型，该模型将瞬时恒星光通量近似为随时间变化的分段线性函数。设凌星外光通量为 $1$，凌星深度为 $\\delta$，总凌星时长为 $T_{14}$，全凌食（平底）时长为 $T_{23}$。凌始时长为 $T_{12} = (T_{14} - T_{23})/2$。采用以凌星中心为原点的时间坐标系，因此一次接触发生在 $t_1 = -T_{14}/2$，二次接触发生在 $t_2 = t_1 + T_{12}$。所有时间必须以秒（$\\mathrm{s}$）为单位表示，光通量是无量纲的。\n\n将瞬时梯形光通量模型 $f(t)$ 定义为\n- 当 $t  t_1$ 和 $t > t_4$ 时，$f(t) = 1$，其中 $t_4 = +T_{14}/2$，\n- 当 $t_1 \\le t  t_2$ 时（凌始），$f(t) = 1 - \\delta\\,[(t - t_1)/T_{12}]$，\n- 当 $t_2 \\le t \\le t_3$ 时（全凌食），$f(t) = 1 - \\delta$，其中 $t_3 = t_2 + T_{23}$，\n- 当 $t_3  t \\le t_4$ 时（凌终），$f(t) = 1 - \\delta\\,[1 - (t - t_3)/T_{12}]$。\n\n有限积分时间被建模为一个宽度为 $\\Delta t$ 的矩形平均核。给定采样周期 $\\Delta t = 30\\,\\mathrm{min} = 1800\\,\\mathrm{s}$，将在采样周期区间中心 $t_c$ 处求值的超采样、时间平均模型定义为\n$$\ng(t_c; N_{\\rm sub}) = \\frac{1}{N_{\\rm sub}} \\sum_{j=1}^{N_{\\rm sub}} f\\!\\left(t_c + u_j\\right),\n$$\n其中，偏移量 $u_j$ 将积分窗口 $[-\\Delta t/2, +\\Delta t/2]$ 在各子区间中点处均匀细分：\n$$\nu_j = -\\frac{\\Delta t}{2} + \\left(j - \\frac{1}{2}\\right)\\frac{\\Delta t}{N_{\\rm sub}}, \\quad j = 1,2,\\dots,N_{\\rm sub}.\n$$\n\n将建模拟合的凌始斜率 $S(N_{\\rm sub})$ 定义为 $g(t_c; N_{\\rm sub})$ 相对于 $t_c$ 的普通最小二乘法（OLS）线性回归的斜率系数，其中使用所有中心时间满足 $t_1 \\le t_c \\le t_2$ 的区间。“朴素”的非超采样情况对应于 $N_{\\rm sub} = 1$，这简化为在区间中心处对瞬时模型求值。\n\n对于每个指定的参数集，计算由超采样引起的建模拟合凌始斜率的相对变化：\n$$\nR = \\frac{S(N_{\\rm sub}) - S(1)}{|S(1)|},\n$$\n这是一个无量纲标量，必须以小数形式报告（不带任何百分号）。时间单位必须是 $\\mathrm{s}$，光通量是无量纲的。不使用角度。\n\n实现一个程序，该程序：\n1. 给定 $\\delta$、$T_{14}$ 和 $T_{23}$，构建瞬时梯形模型 $f(t)$。\n2. 在采样周期区间中心 $t_c = k\\,\\Delta t$（其中 $k$ 为整数）处计算超采样、时间平均模型 $g(t_c; N_{\\rm sub})$，并选择那些满足 $t_1 \\le t_c \\le t_2$ 的中心。\n3. 通过对选定的凌始区间进行 OLS 来估计 $S(N_{\\rm sub})$。\n4. 对下面的每个测试用例返回 $R$。\n\n使用固定的采样周期 $\\Delta t = 1800\\,\\mathrm{s}$。使用以下测试套件（每个元组为 $(\\delta, T_{14}, T_{23}, N_{\\rm sub})$）：\n- 测试 $1$：$(0.01, 10800, 7200, 1)$。\n- 测试 $2$：$(0.01, 10800, 7200, 5)$。\n- 测试 $3$：$(0.01, 18000, 10800, 15)$。\n- 测试 $4$：$(0.01, 32400, 18000, 60)$。\n\n您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表（例如，\"[r1,r2,r3,r4]\"），其中每个 $r_i$ 是相应测试用例的 $R$ 值，格式化为四舍五入到六位小数的浮点数。输出必须按上面列出的顺序使用测试用例，并且不得包含任何额外的文本或行。",
            "solution": "该问题要求我们量化有限积分时间对简化系外行星凌星光变曲线测量的凌始斜率的影响。这是通过比较一个“朴素”模型和一个更真实的超采样模型来实现的。前者在时间区间的中心瞬时采样光通量，后者则在每个时间区间的持续时间内对光通量进行平均。从这两个模型得出的凌始斜率的相对差异，可作为衡量这种效应的指标。\n\n解决方案基于以下原则制定：\n\n1.  **瞬时凌星模型**：恒星光通量的物理模型是一个梯形，这是对凌星光变曲线的一种常见且有效的简化。瞬时光通量（表示为 $f(t)$）是时间 $t$ 的分段线性函数。时间坐标以凌星中心为原点。关键时间点是一次、二次、三次和四次接触：$t_1$, $t_2$, $t_3$ 和 $t_4$。\n    -   凌星外光通量归一化为 $1$。\n    -   凌星具有均匀的深度 $\\delta$。\n    -   总时长为 $T_{14}$，因此 $t_1 = -T_{14}/2$ 且 $t_4 = +T_{14}/2$。\n    -   全凌食（平底）时长为 $T_{23}$。\n    -   凌始和凌终阶段具有相等的时长 $T_{12} = (T_{14} - T_{23})/2$。\n    -   因此，接触时间为 $t_1$、$t_2 = t_1 + T_{12}$、$t_3 = t_2 + T_{23}$ 和 $t_4 = t_3 + T_{12}$。\n\n    瞬时光通量 $f(t)$ 定义如下：\n    $$\n    f(t) = \\begin{cases}\n        1  \\text{当 } t  t_1 \\text{ 或 } t > t_4 \\\\\n        1 - \\delta \\frac{t - t_1}{T_{12}}  \\text{当 } t_1 \\le t  t_2 \\\\\n        1 - \\delta  \\text{当 } t_2 \\le t \\le t_3 \\\\\n        1 - \\delta \\left(1 - \\frac{t - t_3}{T_{12}}\\right)  \\text{当 } t_3  t \\le t_4\n    \\end{cases}\n    $$\n    凌始期间的“真实”瞬时斜率是 $f(t)$ 在区间 $[t_1, t_2)$ 内的导数，它是一个常数：$S_{\\text{true}} = - \\delta / T_{12}$。\n\n2.  **时间平均（分箱）模型**：真实的测量无法捕捉到瞬时光通量 $f(t)$，而是捕捉到在有限曝光时间 $\\Delta t$ 内积分的光通量。问题指定了 $\\Delta t = 1800\\,\\mathrm{s}$（$30\\,\\mathrm{min}$）的采样周期。对于以时间 $t_c$ 为中心的区间，其测量光通量是 $f(t)$ 在区间 $[t_c - \\Delta t/2, t_c + \\Delta t/2]$ 上的平均值。问题规定了一种数值方法，即超采样，来近似这个平均值。积分区间被分成 $N_{\\rm sub}$ 个子区间，并在每个子区间的中点处对 $f(t)$ 求值。超采样光通量 $g(t_c; N_{\\rm sub})$ 是这 $N_{\\rm sub}$ 个样本的平均值：\n    $$\n    g(t_c; N_{\\rm sub}) = \\frac{1}{N_{\\rm sub}} \\sum_{j=1}^{N_{\\rm sub}} f(t_c + u_j)\n    $$\n    其中，偏移量 $u_j$ 在 $[-\\Delta t/2, +\\Delta t/2]$ 内均匀分布：\n    $$\n    u_j = -\\frac{\\Delta t}{2} + \\left(j - \\frac{1}{2}\\right)\\frac{\\Delta t}{N_{\\rm sub}}\n    $$\n    “朴素”模型对应于 $N_{\\rm sub} = 1$。在这种情况下，$u_1 = -\\Delta t/2 + (1/2)\\Delta t = 0$，所以 $g(t_c; 1) = f(t_c)$。它只是在区间中心采样瞬时光通量。\n\n3.  **建模拟合凌始斜率估计**：时间平均效应会“抹平”梯形的锐角，使得凌始和凌终的过渡显得更平缓。为了量化这一点，我们通过执行普通最小二乘法（OLS）线性回归来估计建模拟合的凌始斜率 $S(N_{\\rm sub})$。回归的数据由数对 $(t_c, g(t_c; N_{\\rm sub}))$ 组成，涵盖了所有中心时间 $t_c$ 落在瞬时凌始阶段内（即 $t_1 \\le t_c \\le t_2$）的观测区间。区间中心定义为 $t_c = k \\cdot \\Delta t$，其中 $k$ 为整数。\n\n4.  **算法实现**：最终要计算的量是超采样模型和朴素模型之间建模拟合斜率的相对变化 $R$：\n    $$\n    R = \\frac{S(N_{\\rm sub}) - S(1)}{|S(1)|}\n    $$\n    对于每个测试用例 $(\\delta, T_{14}, T_{23}, N_{\\rm sub})$，算法如下：\n    a. 如果 $N_{\\rm sub} = 1$，则分子为 $S(1) - S(1) = 0$，因此根据定义 $R=0$。这处理了测试用例1。\n    b. 对于 $N_{\\rm sub} > 1$ 的情况，我们必须同时计算 $S(N_{\\rm sub})$ 和 $S(1)$。\n    c. 要为给定的 $N_{\\text{val}}$（$N_{\\rm sub}$ 或 1）计算 $S(N_{\\text{val}})$：\n        i. 计算凌星事件的时间点：$T_{12} = (T_{14} - T_{23})/2$，$t_1 = -T_{14}/2$ 和 $t_2 = t_1 + T_{12}$。\n        ii. 确定整数索引 $k$ 的范围，使得 $t_c = k \\cdot \\Delta t$ 满足 $t_1 \\le t_c \\le t_2$。这给出了用于 OLS 拟合的时间坐标集合 $\\{t_c\\}$。\n        iii. 对于此集合中的每个 $t_c$，计算相应的超采样光通量 $g(t_c; N_{\\text{val}})$。这包括生成 $N_{\\text{val}}$ 个采样时间 $t_c + u_j$，在这些时间点上评估 $f(t)$，并对结果进行平均。\n        iv. 对点集 $\\{(t_c, g(t_c; N_{\\text{val}}))\\}$ 执行线性回归以找到斜率，即 $S(N_{\\text{val}})$。\n    d. 将计算出的斜率 $S(N_{\\rm sub})$ 和 $S(1)$ 代入 $R$ 的公式。由于凌始斜率为负，因此 $|S(1)| = -S(1)$。\n\n对提供的四个测试用例中的每一个都实施此程序。计算使用浮点算术执行，最终结果按要求格式化。",
            "answer": "```python\nimport numpy as np\nfrom scipy.stats import linregress\n\ndef solve():\n    \"\"\"\n    Main solver function to process test cases and print results.\n    \"\"\"\n    test_cases = [\n        (0.01, 10800, 7200, 1),\n        (0.01, 10800, 7200, 5),\n        (0.01, 18000, 10800, 15),\n        (0.01, 32400, 18000, 60),\n    ]\n\n    results = []\n    for case in test_cases:\n        delta, T14, T23, N_sub = case\n        \n        # Per the problem definition, R is the relative change from S(1).\n        # If N_sub is 1, the change is zero.\n        if N_sub == 1:\n            results.append(0.0)\n            continue\n            \n        S_N = _calculate_slope(delta, T14, T23, N_sub)\n        S_1 = _calculate_slope(delta, T14, T23, 1)\n\n        # The ingress slope S(1) will be negative. abs(S(1)) is used.\n        # Avoid division by zero, though unlikely in this problem.\n        if abs(S_1)  1e-15:\n            R = 0.0\n        else:\n            R = (S_N - S_1) / abs(S_1)\n        \n        results.append(R)\n\n    # Format output as specified.\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\n\ndef _calculate_slope(delta, T14, T23, N_sub, dt=1800.0):\n    \"\"\"\n    Calculates the modeled ingress slope S(N_sub) for a given parameter set.\n    \"\"\"\n    # 1. Define model parameters and timings.\n    T12 = (T14 - T23) / 2.0\n    t1 = -T14 / 2.0\n    t2 = t1 + T12\n    t3 = t2 + T23\n    t4 = T14 / 2.0\n    \n    # 2. Define the instantaneous flux model f(t).\n    def f_model(t):\n        t = np.asarray(t)\n        flux = np.ones_like(t, dtype=float)\n        \n        # Ingress: t1 = t  t2\n        mask_ingress = (t >= t1)  (t  t2)\n        if T12 > 0:\n            flux[mask_ingress] = 1.0 - delta * (t[mask_ingress] - t1) / T12\n        \n        # Full transit: t2 = t = t3\n        mask_full = (t >= t2)  (t = t3)\n        flux[mask_full] = 1.0 - delta\n        \n        # Egress: t3  t = t4\n        mask_egress = (t > t3)  (t = t4)\n        if T12 > 0:\n            flux[mask_egress] = 1.0 - delta * (1.0 - (t[mask_egress] - t3) / T12)\n        \n        return flux\n\n    # 3. Determine the cadence bin centers t_c for the regression.\n    k_min = int(np.ceil(t1 / dt))\n    k_max = int(np.floor(t2 / dt))\n    k_values = np.arange(k_min, k_max + 1)\n    tc_values = k_values * dt\n\n    # 4. Calculate the supersampled, time-averaged flux g(t_c).\n    if N_sub == 1:\n        # The naive case: g(t_c; 1) = f(t_c)\n        g_values = f_model(tc_values)\n    else:\n        # The supersampled case\n        j = np.arange(1, N_sub + 1)\n        u_offsets = -dt / 2.0 + (j - 0.5) * (dt / N_sub)\n        \n        g_values = np.zeros_like(tc_values, dtype=float)\n        for i, tc in enumerate(tc_values):\n            sample_times = tc + u_offsets\n            flux_samples = f_model(sample_times)\n            g_values[i] = np.mean(flux_samples)\n\n    # 5. Perform OLS linear regression to find the slope.\n    # linregress is used as it's a standard and robust OLS implementation.\n    # At least 2 points are guaranteed by the problem's test cases.\n    if len(tc_values)  2:\n        return 0.0 # Slope is undefined for fewer than 2 points.\n        \n    slope, _, _, _, _ = linregress(tc_values, g_values)\n    \n    return slope\n\n# Execute the main function when the script is run.\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}