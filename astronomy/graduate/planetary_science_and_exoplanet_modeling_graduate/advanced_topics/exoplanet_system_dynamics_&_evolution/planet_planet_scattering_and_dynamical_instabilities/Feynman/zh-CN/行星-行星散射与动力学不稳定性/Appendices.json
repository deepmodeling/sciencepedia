{
    "hands_on_practices": [
        {
            "introduction": "行星间的引力散射本质上是一个数值问题，因为多体系统通常无法解析求解。本练习将指导您构建该研究领域的一个关键工具：一个自适应步长的N体积分器。您将学习如何实现时间步长判据，以确保在相互作用最剧烈的阶段（如近距离相遇和近心点通过）能量守恒，这对于获得有物理意义的模拟结果至关重要 。",
            "id": "4169745",
            "problem": "您的任务是为由一颗中心恒星和两颗相互引力作用的行星组成的平面三体系统，构建并评估一个自适应时间步长方案。其科学目标是避免在行星间近距离相遇和近心点通过期间出现人为的能量漂移，这是研究行星-行星散射和动力学不稳定性时的一个常见挑战。您的程序必须实现一个算法，该算法根据近心点通过和相遇尺度评估时间步长准则，并使用子步进以确保数值鲁棒性。\n\n允许用于推导和算法设计的基础包括 Newton 运动定律、牛顿引力、运动学，以及在中心势下经过充分检验的二体运动轨道根数关系。\n\n使用以下定义和约束：\n\n- 单位：长度单位为天文单位 (AU)，质量单位为太阳质量，时间单位为年，速度单位为 AU/年，角度单位为弧度。在这些单位中，引力常数 $G = 4\\pi^2$。\n- 质量为 $M_\\star$ 的中心恒星固定在原点不动。两颗行星质量分别为 $m_1$ 和 $m_2$，在恒星的引力势以及它们之间的相互引力作用下运动。\n- 令 $\\mathbf{r}_i$ 和 $\\mathbf{v}_i$ 表示行星 $i$ 相对于恒星的位置和速度，其中 $i \\in \\{1,2\\}$。两两之间的距离为 $r_{12} = \\|\\mathbf{r}_2 - \\mathbf{r}_1\\|$，相对速度为 $v_{\\mathrm{rel}} = \\|\\mathbf{v}_2 - \\mathbf{v}_1\\|$。\n- 使用速度 Verlet 方案进行积分。在一个大小为 $\\Delta t_{\\max}$ 的基本区间上，设计一个自适应子步进方案如下：\n  1. 对于每颗行星 $i$，使用瞬时状态 $(\\mathbf{r}_i,\\mathbf{v}_i)$，假设恒星为点质量势，计算其与恒星的吻切二体根数。比轨道能为 $\\varepsilon_i = \\frac{1}{2}\\|\\mathbf{v}_i\\|^2 - \\frac{G M_\\star}{\\|\\mathbf{r}_i\\|}$，比角动量大小为 $L_i = \\|\\mathbf{r}_i \\times \\mathbf{v}_i\\|$，偏心率为 $e_i = \\sqrt{1 + \\frac{2 \\varepsilon_i L_i^2}{(G M_\\star)^2}}$，对于 $\\varepsilon_i  0$ 的束缚运动，半长轴为 $a_i = -\\frac{G M_\\star}{2\\varepsilon_i}$。定义近心点距离 $q_i = a_i(1-e_i)$ 和近心点速度 $v_{\\mathrm{peri},i} = \\sqrt{G M_\\star \\left(\\frac{2}{q_i} - \\frac{1}{a_i}\\right)}$。近心点通过时间尺度为 $t_{\\mathrm{peri},i} = \\frac{q_i}{v_{\\mathrm{peri},i}}$。如果 $\\varepsilon_i \\ge 0$ 或 $e_i \\ge 1$（非束缚或抛物线/双曲线轨道），则用局域动力学时间尺度 $t_{\\mathrm{dyn},i} = \\sqrt{\\frac{\\|\\mathbf{r}_i\\|^3}{G M_\\star}}$ 替换 $t_{\\mathrm{peri},i}$。\n  2. 定义相遇时间尺度 $t_{\\mathrm{enc}} = \\frac{r_{12}}{\\max(v_{\\mathrm{rel}}, \\delta_v)}$，其中 $\\delta_v$ 是一个小的下限值，以避免除以零。\n  3. 为每颗行星定义一个加速度时间尺度 $t_{\\mathrm{acc},i} = \\frac{\\|\\mathbf{v}_i\\|}{\\|\\mathbf{a}_i\\|}$，其中 $\\mathbf{a}_i$ 是来自恒星和另一颗行星的总加速度。\n  4. 目标子步长为\n     $$\\Delta t_{\\mathrm{target}} = \\min\\left(\\eta_{\\mathrm{peri}} \\min_i t_{\\mathrm{peri},i},\\ \\eta_{\\mathrm{enc}} t_{\\mathrm{enc}},\\ \\eta_{\\mathrm{acc}} \\min_i t_{\\mathrm{acc},i},\\ \\Delta t_{\\mathrm{step}}\\right),$$\n     其中 $\\Delta t_{\\mathrm{step}}$ 是当前的基本步长（等于 $\\Delta t_{\\max}$，除非可能是最后一个部分步长），而 $\\eta_{\\mathrm{peri}}, \\eta_{\\mathrm{enc}}, \\eta_{\\mathrm{acc}}$ 是严格介于 $0$ 和 $1$ 之间的无量纲安全因子。\n  5. 如果 $\\Delta t_{\\mathrm{target}}  \\Delta t_{\\mathrm{step}}$，则执行 $N_{\\mathrm{sub}} = \\left\\lceil \\frac{\\Delta t_{\\mathrm{step}}}{\\Delta t_{\\mathrm{target}}} \\right\\rceil$ 个大小为 $\\Delta t_{\\mathrm{sub}} = \\frac{\\Delta t_{\\mathrm{step}}}{N_{\\mathrm{sub}}}$ 的子步。否则，执行一个大小为 $\\Delta t_{\\mathrm{step}}$ 的单步。\n\n行星 $i$ 的引力加速度为\n$$\n\\mathbf{a}_i = -\\frac{G M_\\star}{\\|\\mathbf{r}_i\\|^3}\\mathbf{r}_i + \\sum_{j\\ne i} G m_j \\frac{\\mathbf{r}_j - \\mathbf{r}_i}{\\|\\mathbf{r}_j - \\mathbf{r}_i\\|^3}.\n$$\n\n将双行星系统的总能量定义为\n$$\nE = \\sum_{i=1}^{2} \\frac{1}{2} m_i \\|\\mathbf{v}_i\\|^2 - \\sum_{i=1}^{2} \\frac{G M_\\star m_i}{\\|\\mathbf{r}_i\\|} - \\frac{G m_1 m_2}{\\|\\mathbf{r}_2 - \\mathbf{r}_1\\|}.\n$$\n计算能量的相对漂移 $\\delta = \\frac{|E(T) - E(0)|}{|E(0)|}$，这是一个无量纲量。\n\n实现两种积分模式：\n- 使用固定的 $\\Delta t_{\\max}$ 且不进行子步进的恒定时间步长模式。\n- 上述的自适应子步进模式。\n\n对下面的每个测试案例模拟两次（恒定步长和自适应步长），并为每个案例输出一个列表 $[\\delta_{\\mathrm{const}}, \\delta_{\\mathrm{adapt}}, b]$，其中 $b$ 是一个布尔值，指示自适应模式是否同时满足：能量漂移相对于恒定步长模式至少减少10倍，且绝对漂移达到或低于指定的阈值。所有案例的结果必须汇总到单行打印，形式为一个以逗号分隔并用方括号括起来的列表，其中每个案例的结果本身也用方括号括起来，例如 $[[x_1,y_1,z_1],[x_2,y_2,z_2],[x_3,y_3,z_3]]$。\n\n角度单位要求：如果出现角度，使用弧度进行度量。\n\n任何磁学或物理量必须严格使用上述指定的单位表示。所有输出均为定义的无量纲浮点数或布尔值。\n\n测试套件和参数，以覆盖理想路径、相遇驱动的自适应性以及近心点驱动的自适应性：\n\n- 案例 A（间距大、近圆轨道）：\n  - $M_\\star = 1$。\n  - $m_1 = 1\\times 10^{-3}$，$m_2 = 3\\times 10^{-4}$。\n  - 初始位置和速度：$\\mathbf{r}_1(0) = (1, 0)$，$\\mathbf{v}_1(0) = (0, 2\\pi)$；$\\mathbf{r}_2(0) = (1.8, 0)$，$\\mathbf{v}_2(0) = \\left(0, \\frac{2\\pi}{\\sqrt{1.8}}\\right)$。\n  - 总模拟时间 $T = 5$。\n  - 基本步长 $\\Delta t_{\\max} = 0.01$。\n  - 安全因子 $\\eta_{\\mathrm{peri}} = 0.05$，$\\eta_{\\mathrm{enc}} = 0.05$，$\\eta_{\\mathrm{acc}} = 0.2$。\n  - 布尔决策阈值 $= 1\\times 10^{-6}$。\n\n- 案例 B（近距离共轨分离以触发相遇细化）：\n  - $M_\\star = 1$。\n  - $m_1 = 1\\times 10^{-3}$，$m_2 = 1\\times 10^{-3}$。\n  - 初始位置和速度：$\\mathbf{r}_1(0) = (1.00, 0)$，$\\mathbf{v}_1(0) = (0, 2\\pi)$；$\\mathbf{r}_2(0) = (1.05, 0)$，$\\mathbf{v}_2(0) = \\left(0, \\frac{2\\pi}{\\sqrt{1.05}}\\right)$。\n  - 总模拟时间 $T = 0.5$。\n  - 基本步长 $\\Delta t_{\\max} = 0.01$。\n  - 安全因子 $\\eta_{\\mathrm{peri}} = 0.05$，$\\eta_{\\mathrm{enc}} = 0.05$，$\\eta_{\\mathrm{acc}} = 0.2$。\n  - 布尔决策阈值 $= 1\\times 10^{-6}$。\n\n- 案例 C（高偏心率近心点通过细化）：\n  - $M_\\star = 1$。\n  - $m_1 = 3\\times 10^{-6}$，$m_2 = 1\\times 10^{-3}$。\n  - 对于行星 1，目标吻切值为 $a_1 = 0.5$，$e_1 = 0.8$，因此 $q_1 = 0.1$。在近心点初始化：$\\mathbf{r}_1(0) = (0.1, 0)$ 且 $\\mathbf{v}_1(0) = (0, v_{\\mathrm{peri},1})$，其中 $v_{\\mathrm{peri},1} = \\sqrt{G M_\\star \\left(\\frac{2}{q_1} - \\frac{1}{a_1}\\right)}$。\n  - 对于行星 2，在远处初始化为圆形轨道：$\\mathbf{r}_2(0) = (5, 0)$，$\\mathbf{v}_2(0) = \\left(0, \\frac{2\\pi}{\\sqrt{5}}\\right)$。\n  - 总模拟时间 $T = 1$。\n  - 基本步长 $\\Delta t_{\\max} = 0.01$。\n  - 安全因子 $\\eta_{\\mathrm{peri}} = 0.05$，$\\eta_{\\mathrm{enc}} = 0.05$，$\\eta_{\\mathrm{acc}} = 0.2$。\n  - 布尔决策阈值 $= 1\\times 10^{-6}$。\n\n您的程序应生成单行输出，其中包含案例A、案例B和案例C的结果，形式为一个以逗号分隔并用方括号括起来的列表，每个案例的结果是一个列表 $[\\delta_{\\mathrm{const}}, \\delta_{\\mathrm{adapt}}, b]$，其中布尔值 $b$ 如上文所定义。布尔值应以小写字符串 \"true\" 或 \"false\" 的形式打印。",
            "solution": "我们从点质量的 Newton 第二定律和牛顿引力定律开始。设质量为 $M_\\star$ 的中心恒星固定在原点，两颗质量分别为 $m_1$ 和 $m_2$ 的行星在一个包含恒星-行星和行星-行星相互作用的组合势下运动。平面运动是足够的，因此我们在二维空间中工作。\n\n行星 $i$ 的加速度由下式给出\n$$\n\\mathbf{a}_i = -\\frac{G M_\\star}{\\|\\mathbf{r}_i\\|^3}\\mathbf{r}_i + \\sum_{j\\ne i} G m_j \\frac{\\mathbf{r}_j - \\mathbf{r}_i}{\\|\\mathbf{r}_j - \\mathbf{r}_i\\|^3}.\n$$\n这直接源于牛顿万有引力定律和力的叠加原理。\n\n我们使用速度 Verlet 方案进行积分，对于一个时间步长 $\\Delta t$，该方案通过以下方式从 $(\\mathbf{r}_i^n,\\mathbf{v}_i^n)$ 更新到 $(\\mathbf{r}_i^{n+1},\\mathbf{v}_i^{n+1})$：\n$$\n\\mathbf{v}_i^{n+\\frac{1}{2}} = \\mathbf{v}_i^{n} + \\frac{1}{2}\\mathbf{a}_i^n \\Delta t, \\quad\n\\mathbf{r}_i^{n+1} = \\mathbf{r}_i^{n} + \\mathbf{v}_i^{n+\\frac{1}{2}} \\Delta t, \\quad\n\\mathbf{a}_i^{n+1} = \\mathbf{a}_i(\\mathbf{r}_1^{n+1},\\mathbf{r}_2^{n+1}), \\quad\n\\mathbf{v}_i^{n+1} = \\mathbf{v}_i^{n+\\frac{1}{2}} + \\frac{1}{2}\\mathbf{a}_i^{n+1}\\Delta t.\n$$\n这种积分器是二阶精确的，并且在恒定时间步长下具有时间可逆性和良好的能量特性。然而，在近距离相遇或近心点段，加速度和速度变化迅速，固定的时间步长会引发显著的数值能量漂移。\n\n我们设计一个与问题陈述一致的自适应子步进方案。其核心思想是在大部分演化过程中保持一个几乎恒定的顶层时间步长 $\\Delta t_{\\max}$，以避免破坏速度 Verlet 方案的近辛性质的大幅、频繁的改变，但在局域时间尺度要求更小步长时允许细化。因此，我们在每个基本区间 $\\Delta t_{\\mathrm{step}}$ 的开始计算以下时间尺度：\n\n1. 每颗行星 $i$ 相对于恒星的近心点通过时间尺度。我们将恒星-行星相互作用视为一个二体问题，从瞬时位置和速度中获得吻切根数。这是天体力学中在弱扰动下广泛使用的物理近似。比能量为 $\\varepsilon_i = \\frac{1}{2}\\|\\mathbf{v}_i\\|^2 - \\frac{G M_\\star}{\\|\\mathbf{r}_i\\|}$，比角动量大小为 $L_i = \\|\\mathbf{r}_i \\times \\mathbf{v}_i\\|$。偏心率为\n$$\ne_i = \\sqrt{1 + \\frac{2 \\varepsilon_i L_i^2}{(G M_\\star)^2}},\n$$\n对于束缚运动（$\\varepsilon_i  0$），半长轴为 $a_i = -\\frac{G M_\\star}{2\\varepsilon_i}$。近心点距离为 $q_i = a_i(1-e_i)$，近心点速度为 $v_{\\mathrm{peri},i} = \\sqrt{G M_\\star \\left(\\frac{2}{q_i} - \\frac{1}{a_i}\\right)}$。近心点时间尺度为 $t_{\\mathrm{peri},i} = \\frac{q_i}{v_{\\mathrm{peri},i}}$，它估计了穿越近心点区域所需的时间。如果吻切解是非束缚或退化的（$\\varepsilon_i\\ge 0$ 或 $e_i\\ge 1$），我们回退到使用局域动力学时间尺度 $t_{\\mathrm{dyn},i} = \\sqrt{\\frac{\\|\\mathbf{r}_i\\|^3}{G M_\\star}}$。\n\n2. 行星-行星相遇时间尺度 $t_{\\mathrm{enc}} = \\frac{r_{12}}{v_{\\mathrm{rel}}}$，其中 $r_{12} = \\|\\mathbf{r}_2 - \\mathbf{r}_1\\|$ 且 $v_{\\mathrm{rel}} = \\|\\mathbf{v}_2 - \\mathbf{v}_1\\|$。如果 $v_{\\mathrm{rel}}$ 极小，则将其设置为一个下限值 $\\delta_v$ 以避免奇异行为；这确保了细化仅在实际接近发生时才被驱动。\n\n3. 每颗行星的加速度时间尺度 $t_{\\mathrm{acc},i} = \\frac{\\|\\mathbf{v}_i\\|}{\\|\\mathbf{a}_i\\|}$，它估计了速度发生显著变化所需的时间。这个时间尺度在近心点和近距离相遇期间尤其敏感，因为在这些情况下 $|\\mathbf{a}_i|$ 很大。\n\n我们将这些时间尺度与安全因子 $\\eta_{\\mathrm{peri}}$、$\\eta_{\\mathrm{enc}}$ 和 $\\eta_{\\mathrm{acc}}$ 结合起来，设置目标子步长：\n$$\n\\Delta t_{\\mathrm{target}} = \\min\\left(\\eta_{\\mathrm{peri}} \\min_i t_{\\mathrm{peri},i},\\ \\eta_{\\mathrm{enc}} t_{\\mathrm{enc}},\\ \\eta_{\\mathrm{acc}} \\min_i t_{\\mathrm{acc},i},\\ \\Delta t_{\\mathrm{step}}\\right).\n$$\n如果 $\\Delta t_{\\mathrm{target}}$ 小于当前的基本步长 $\\Delta t_{\\mathrm{step}}$，我们使用 $N_{\\mathrm{sub}} = \\left\\lceil \\Delta t_{\\mathrm{step}} / \\Delta t_{\\mathrm{target}} \\right\\rceil$ 个大小为 $\\Delta t_{\\mathrm{sub}} = \\Delta t_{\\mathrm{step}} / N_{\\mathrm{sub}}$ 的子步。否则，我们用 $\\Delta t_{\\mathrm{step}}$ 执行一次速度 Verlet 更新。这种子步进在实现局域细化的同时，保持了近乎恒定的外层步长。与任意可变时间步长相比，在固定的基本区间内进行子步进减少了时间对称性被破坏的可能性，并减轻了能量漂移。\n\n为了衡量能量特性，我们计算总能量\n$$\nE = \\sum_{i=1}^{2} \\frac{1}{2} m_i \\|\\mathbf{v}_i\\|^2 - \\sum_{i=1}^{2} \\frac{G M_\\star m_i}{\\|\\mathbf{r}_i\\|} - \\frac{G m_1 m_2}{\\|\\mathbf{r}_2 - \\mathbf{r}_1\\|}\n$$\n在 $t=0$ 和 $t=T$ 时的值，并报告相对漂移 $\\delta = \\frac{|E(T) - E(0)|}{|E(0)|}$。我们对每个案例运行恒定时间步长模式和自适应子步进模式。每个案例的布尔输出为 $b = \\left(\\delta_{\\mathrm{adapt}} \\le \\mathrm{threshold}\\right) \\wedge \\left(\\delta_{\\mathrm{adapt}} \\le \\delta_{\\mathrm{const}} / 10\\right)$，量化了绝对控制和相对改进。\n\n我们现在来论证这些时间尺度及其作用：\n\n- 近心点时间尺度 $t_{\\mathrm{peri}}$ 的出现是因为，在平方反比定律势中，由于角动量和能量的守恒，速度在近心点附近达到峰值。位置的快速变化需要更小的时间步长来准确捕捉曲率并避免大的积分误差。\n- 相遇时间尺度 $t_{\\mathrm{enc}}$ 是分离距离被相对速度平流的时间。由于近距离相遇会导致强烈的相互加速度和急剧的偏转，当 $r_{12}$ 变小或 $v_{\\mathrm{rel}}$ 显著时，$\\eta_{\\mathrm{enc}} t_{\\mathrm{enc}}$ 会设置一个细化。\n- 加速度时间尺度 $t_{\\mathrm{acc}}$ 源于 $v = \\mathrm{d}x/\\mathrm{d}t$ 和 $\\mathrm{d}v/\\mathrm{d}t = a$。如果 $|\\mathbf{a}|$ 很大，速度会迅速变化，减小 $\\Delta t$ 可以使速度 Verlet 的 $O(\\Delta t^3)$ 阶局域截断误差保持有界。\n\n安全因子 $\\eta$ 强制留出一个余量，使得子步长是最小相关时间尺度的一个保守分数，从而减少细化过程中的振荡并确保稳定性。\n\n对于三个测试案例：\n\n- 案例A提供了一个理想路径，其中相互扰动弱，运动近圆，且间距大。能量漂移本质上应该很小，自适应性产生可比或略有改善的性能。\n- 案例B通过将两个木星质量的行星放置在近乎共轨的半径和对齐的方位角上来测试相遇驱动的自适应性。这会迅速引发强烈的相互作用。没有自适应性，固定时间步长会累积误差；自适应性在相遇过程中进行细化。\n- 案例C测试了近心点驱动的自适应性，其中一颗高偏心率的地球质量行星在近心点初始化，而一颗外侧的木星质量行星则在远处。近心点时间尺度很短，需要细化以避免大的能量误差。\n\n程序实现了这些原理，计算了所需的输出，并按规定在单行上打印汇总列表。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Constants in AU, yr, solar masses\nG = 4.0 * np.pi**2  # AU^3 / (yr^2 * M_sun)\n\ndef accel_planets(r, m, Mstar):\n    \"\"\"\n    Compute accelerations on two planets due to the fixed star and mutual gravity.\n    r: array shape (2, 2) of positions [ [x1,y1], [x2,y2] ]\n    m: array shape (2,) masses of planets\n    Mstar: scalar star mass\n    Returns accelerations array shape (2, 2)\n    \"\"\"\n    a = np.zeros_like(r)\n    for i in range(2):\n        ri = r[i]\n        ri_norm = np.linalg.norm(ri)\n        # Star contribution\n        if ri_norm > 0:\n            a[i] += -(G * Mstar / (ri_norm**3)) * ri\n        # Mutual planet-planet contribution\n        j = 1 - i\n        rij = r[j] - ri\n        d = np.linalg.norm(rij)\n        if d > 0:\n            a[i] += G * m[j] * rij / (d**3)\n    return a\n\ndef total_energy(r, v, m, Mstar):\n    \"\"\"\n    Compute total energy (kinetic + potential) of two planets in the fixed star potential and mutual interaction.\n    \"\"\"\n    # Kinetic\n    K = 0.0\n    for i in range(2):\n        K += 0.5 * m[i] * np.dot(v[i], v[i])\n    # Potential with star\n    U_star = 0.0\n    for i in range(2):\n        ri_norm = np.linalg.norm(r[i])\n        if ri_norm > 0:\n            U_star += -G * Mstar * m[i] / ri_norm\n    # Mutual potential\n    rij = r[1] - r[0]\n    d = np.linalg.norm(rij)\n    U_pp = -G * m[0] * m[1] / d if d > 0 else 0.0\n    return K + U_star + U_pp\n\ndef osculating_elements_star(ri, vi, Mstar):\n    \"\"\"\n    Compute osculating semimajor axis a and eccentricity e for a planet relative to the star,\n    treating the motion as a two-body problem with a fixed central mass Mstar.\n    Returns (a, e, bound) where bound is True if epsilon  0 and e  1.\n    \"\"\"\n    r = np.linalg.norm(ri)\n    v2 = np.dot(vi, vi)\n    mu = G * Mstar\n    eps = 0.5 * v2 - mu / r  # specific energy\n    # Specific angular momentum magnitude (2D cross product -> z-component)\n    h = abs(ri[0] * vi[1] - ri[1] * vi[0])\n    e_arg = 1.0 + (2.0 * eps * h**2) / (mu**2)\n    # Numerical safety: clamp tiny negatives due to roundoff\n    e_arg = max(e_arg, 0.0)\n    e = np.sqrt(e_arg)\n    bound = (eps  0.0) and (e  1.0)\n    if bound:\n        a = -mu / (2.0 * eps)\n    else:\n        a = np.nan\n    return a, e, bound\n\ndef pericenter_timescale(ri, vi, Mstar):\n    \"\"\"\n    Compute pericenter passage timescale t_peri for a planet relative to the star.\n    If unbound, return local dynamical timescale sqrt(r^3 / (G Mstar)).\n    \"\"\"\n    a, e, bound = osculating_elements_star(ri, vi, Mstar)\n    r = np.linalg.norm(ri)\n    mu = G * Mstar\n    if bound:\n        q = a * (1.0 - e)\n        # v_peri = sqrt(mu * (2/q - 1/a))\n        v_peri = np.sqrt(mu * (2.0 / q - 1.0 / a))\n        t_peri = q / v_peri\n        return t_peri\n    else:\n        return np.sqrt(r**3 / mu)\n\ndef encounter_timescale(r1, v1, r2, v2, v_floor=1e-10):\n    \"\"\"\n    Encounter timescale t_enc = r12 / max(v_rel, v_floor)\n    \"\"\"\n    rij = r2 - r1\n    r12 = np.linalg.norm(rij)\n    vrel = np.linalg.norm(v2 - v1)\n    vrel = max(vrel, v_floor)\n    return r12 / vrel\n\ndef acceleration_timescale(vi, ai, a_floor=1e-15):\n    \"\"\"\n    Acceleration timescale t_acc = |v| / max(|a|, a_floor)\n    \"\"\"\n    vnorm = np.linalg.norm(vi)\n    anorm = max(np.linalg.norm(ai), a_floor)\n    return vnorm / anorm\n\ndef integrate_system(m, Mstar, r0, v0, T, dt_max, adapt, etas):\n    \"\"\"\n    Integrate the two-planet system for time T with base step dt_max.\n    If adapt is True, perform substepping according to timescales and safety factors etas=(eta_peri, eta_enc, eta_acc).\n    Returns fractional energy drift delta.\n    \"\"\"\n    r = r0.copy()\n    v = v0.copy()\n    E0 = total_energy(r, v, m, Mstar)\n    # Number of base steps\n    n_steps = int(np.ceil(T / dt_max))\n    t = 0.0\n    for step in range(n_steps):\n        # Handle last partial base step\n        dt_step = dt_max if (t + dt_max) = T else (T - t)\n        if adapt:\n            # Compute accelerations at start of base step\n            a = accel_planets(r, m, Mstar)\n            # Timescales\n            t_peri1 = pericenter_timescale(r[0], v[0], Mstar)\n            t_peri2 = pericenter_timescale(r[1], v[1], Mstar)\n            t_enc = encounter_timescale(r[0], v[0], r[1], v[1])\n            t_acc1 = acceleration_timescale(v[0], a[0])\n            t_acc2 = acceleration_timescale(v[1], a[1])\n            eta_peri, eta_enc, eta_acc = etas\n            dt_target = min(eta_peri * min(t_peri1, t_peri2),\n                            eta_enc * t_enc,\n                            eta_acc * min(t_acc1, t_acc2),\n                            dt_step)\n            # Substeps\n            Nsub = int(np.ceil(dt_step / dt_target)) if dt_target > 0 else 1\n            dt_sub = dt_step / Nsub\n            # Perform substeps with velocity Verlet\n            for _ in range(Nsub):\n                a = accel_planets(r, m, Mstar)\n                v_half = v + 0.5 * a * dt_sub\n                r = r + v_half * dt_sub\n                a_new = accel_planets(r, m, Mstar)\n                v = v_half + 0.5 * a_new * dt_sub\n        else:\n            # Single velocity Verlet step of size dt_step\n            a = accel_planets(r, m, Mstar)\n            v_half = v + 0.5 * a * dt_step\n            r = r + v_half * dt_step\n            a_new = accel_planets(r, m, Mstar)\n            v = v_half + 0.5 * a_new * dt_step\n        t += dt_step\n    ET = total_energy(r, v, m, Mstar)\n    delta = abs(ET - E0) / abs(E0) if E0 != 0 else float('inf')\n    return float(delta)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Case A\n    Mstar_A = 1.0\n    m_A = np.array([1e-3, 3e-4], dtype=float)\n    r1_A = np.array([1.0, 0.0], dtype=float)\n    v1_A = np.array([0.0, 2.0*np.pi], dtype=float)\n    r2_A = np.array([1.8, 0.0], dtype=float)\n    v2_A = np.array([0.0, 2.0*np.pi/np.sqrt(1.8)], dtype=float)\n    T_A = 5.0\n    dt_max_A = 0.01\n    etas_A = (0.05, 0.05, 0.2)\n    threshold_A = 1e-6\n\n    # Case B\n    Mstar_B = 1.0\n    m_B = np.array([1e-3, 1e-3], dtype=float)\n    r1_B = np.array([1.00, 0.0], dtype=float)\n    v1_B = np.array([0.0, 2.0*np.pi], dtype=float)\n    r2_B = np.array([1.05, 0.0], dtype=float)\n    v2_B = np.array([0.0, 2.0*np.pi/np.sqrt(1.05)], dtype=float)\n    T_B = 0.5\n    dt_max_B = 0.01\n    etas_B = (0.05, 0.05, 0.2)\n    threshold_B = 1e-6\n\n    # Case C\n    Mstar_C = 1.0\n    m_C = np.array([3e-6, 1e-3], dtype=float)\n    # Planet 1 at pericenter for a=0.5, e=0.8 -> q=0.1\n    q1_C = 0.1\n    a1_C = 0.5\n    vperi1_C = np.sqrt(G * Mstar_C * (2.0/q1_C - 1.0/a1_C))\n    r1_C = np.array([q1_C, 0.0], dtype=float)\n    v1_C = np.array([0.0, vperi1_C], dtype=float)\n    # Planet 2 far, circular at 5 AU\n    r2_C = np.array([5.0, 0.0], dtype=float)\n    v2_C = np.array([0.0, 2.0*np.pi/np.sqrt(5.0)], dtype=float)\n    T_C = 1.0\n    dt_max_C = 0.01\n    etas_C = (0.05, 0.05, 0.2)\n    threshold_C = 1e-6\n\n    test_cases = [\n        # Each case: (Mstar, masses, r_init, v_init, T, dt_max, etas, threshold)\n        (Mstar_A, m_A, np.vstack([r1_A, r2_A]), np.vstack([v1_A, v2_A]), T_A, dt_max_A, etas_A, threshold_A),\n        (Mstar_B, m_B, np.vstack([r1_B, r2_B]), np.vstack([v1_B, v2_B]), T_B, dt_max_B, etas_B, threshold_B),\n        (Mstar_C, m_C, np.vstack([r1_C, r2_C]), np.vstack([v1_C, v2_C]), T_C, dt_max_C, etas_C, threshold_C),\n    ]\n\n    results = []\n    for (Mstar, masses, r_init, v_init, T, dt_max, etas, threshold) in test_cases:\n        # Constant timestep integration\n        delta_const = integrate_system(masses, Mstar, r_init.copy(), v_init.copy(), T, dt_max, adapt=False, etas=etas)\n        # Adaptive substepping integration\n        delta_adapt = integrate_system(masses, Mstar, r_init.copy(), v_init.copy(), T, dt_max, adapt=True, etas=etas)\n        improved = (delta_adapt = threshold) and (delta_adapt = (delta_const / 10.0))\n        results.append([delta_const, delta_adapt, improved])\n\n    # Final print statement in the exact required format.\n    # Python prints booleans as True/False; convert to lowercase 'true'/'false' for strict formatting.\n    def elem_to_str(x):\n        if isinstance(x, bool):\n            return 'true' if x else 'false'\n        else:\n            return str(x)\n    out = \"[\" + \",\".join(\"[\" + \",\".join(elem_to_str(e) for e in case) + \"]\" for case in results) + \"]\"\n    print(out)\n\nsolve()\n```"
        },
        {
            "introduction": "在掌握了可靠模拟的技巧之后，我们可以利用这一工具来揭示系统中的基本规律。这个实践聚焦于一个著名的经验定律，该定律描述了动力学不稳定性的时间尺度 $t_{\\mathrm{inst}}$ 如何随行星间距 $\\Delta$ 呈指数增长。您将对模拟数据进行最小二乘法拟合，以量化这一关系，这是将数值实验与简洁的预测模型相结合的一项核心技能 。",
            "id": "4169857",
            "problem": "您需要形式化并估计紧凑、等质量、等间距行星系统中动力学不稳定性时间对其初始间距的敏感度。请从经典力学和天体动力学的基本原理出发，构建一个定量推断程序，将首次紧密引力相遇的时间与相邻行星之间的归一化间距联系起来。\n\n使用以下基础：\n\n- 牛顿万有引力定律：质量为 $m$ 的行星因距离为 $r$ 处质量为 $M_\\star$ 的恒星而产生的加速度由 $G M_\\star / r^2$ 决定，其中 $G$ 是引力常数，$r$ 是间距。\n- 对于两颗质量相等的相邻行星，其质量分别为 $m_i$ 和 $m_{i+1}$，在半长轴 $a_i$ 和 $a_{i+1}$ 处绕一颗质量为 $M_\\star$ 的恒星运行，其相互希尔半径 (MHR) 定义为\n$$\nR_{\\mathrm{H,m}} \\equiv \\left(\\frac{m_i + m_{i+1}}{3 M_\\star}\\right)^{1/3} \\cdot \\frac{a_i + a_{i+1}}{2}.\n$$\n当质量相等，$m_i = m_{i+1} = m$ 时，此公式简化为\n$$\nR_{\\mathrm{H,m}} = \\left(\\frac{2m}{3 M_\\star}\\right)^{1/3} \\cdot \\frac{a_i + a_{i+1}}{2}.\n$$\n- 以相互希尔半径为单位，定义无量纲间距为\n$$\n\\Delta \\equiv \\frac{a_{i+1} - a_i}{R_{\\mathrm{H,m}}}.\n$$\n\n假设存在一个广泛报道的经验关系式，将等质量、等间距行星的不稳定时间 $t_{\\mathrm{inst}}$ 与间距 $\\Delta$ 联系起来。通过适当的变量变换将此关系式转换为线性模型，然后对每个数据集估计控制不稳定时间对 $\\Delta$ 敏感度的参数。在线性模型的背景下解释该参数，并通过最小二乘拟合计算它。\n\n此处，不稳定时间 $t_{\\mathrm{inst}}$ 定义为任意相邻行星对之间首次发生紧密相遇的时间，以最内侧行星的轨道周期为单位进行度量，因此 $t_{\\mathrm{inst}}$ 是一个无量纲量。所有角度（如有）均与本问题无关。请使用自然对数函数。所有结果应表示为无量纲浮点数。\n\n对于下面的测试套件，请使用以下数据集。每个数据集对应一个固定的相等行星质量比 $m/M_\\star$，并且要么直接提供一个 $\\Delta$ 值列表和相应的 $t_{\\mathrm{inst}}$ 值列表，要么提供了分数间距值，您必须首先使用相互希尔半径的定义从中计算出 $\\Delta$。当提供分数间距时，假设相邻行星遵循几何级数 $a_{i+1} = a_i (1 + \\epsilon)$，因此 $a_{i+1} - a_i = \\epsilon a_i$，并在相互希尔半径公式中使用精确平均值 $\\frac{a_i + a_{i+1}}{2} = a_i \\left(1 + \\frac{\\epsilon}{2}\\right)$。对于相等质量，这得出\n$$\n\\Delta(\\epsilon, m/M_\\star) = \\frac{\\epsilon}{\\left(\\frac{2 m}{3 M_\\star}\\right)^{1/3} \\left(1 + \\frac{\\epsilon}{2}\\right)}.\n$$\n\n使用的数据集：\n\n- 数据集1：质量比 $m/M_\\star = 1\\times 10^{-5}$。直接给出的间距和不稳定时间：\n  - $\\Delta$ 值：$[3.2, 3.6, 4.0, 4.4, 4.8]$。\n  - $t_{\\mathrm{inst}}$ 值（以内轨道周期为单位）：$[1200, 6000, 25000, 120000, 500000]$。\n\n- 数据集2：质量比 $m/M_\\star = 3\\times 10^{-5}$。直接给出的间距和不稳定时间：\n  - $\\Delta$ 值：$[2.8, 3.0, 3.2, 3.4]$。\n  - $t_{\\mathrm{inst}}$ 值（以内轨道周期为单位）：$[80, 220, 700, 2200]$。\n\n- 数据集3：质量比 $m/M_\\star = 5\\times 10^{-5}$。直接给出的间距和不稳定时间：\n  - $\\Delta$ 值：$[3.6, 4.0, 4.4, 4.8]$。\n  - $t_{\\mathrm{inst}}$ 值（以内轨道周期为单位）：$[600, 3000, 15000, 75000]$。\n\n- 数据集4：质量比 $m/M_\\star = 2\\times 10^{-5}$。分数间距值 $\\epsilon$ 和不稳定时间：\n  - $\\epsilon$ 值：$[0.06, 0.08, 0.10, 0.12]$。\n  - $t_{\\mathrm{inst}}$ 值（以内轨道周期为单位）：$[200, 1000, 5000, 25000]$。\n  在拟合之前，使用上述公式将该数据集的每个 $\\epsilon$ 转换为 $\\Delta$。\n\n任务要求：\n\n- 对于每个数据集，构建由经验关系式的变量变换所隐含的线性模型，并使用普通最小二乘法估计敏感度参数。\n- 最小二乘解必须从第一性原理进行解析计算，不得依赖任何黑箱拟合工具。根据需要使用 $t_{\\mathrm{inst}}$ 的自然对数进行变换，并将 $\\Delta$（或从 $\\epsilon$ 转换而来的值）作为自变量。\n- 数值稳定性：如果任何 $t_{\\mathrm{inst}}$ 为非正数，则必须丢弃；但是，所提供的数据集均为严格正数。\n- 输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。该列表应包含按数据集1到4的顺序排列的四个估计敏感度参数，每个参数四舍五入到三位小数，例如 $[x_1,x_2,x_3,x_4]$，其中每个 $x_i$ 是一个浮点数。\n\n您的最终输出必须是单行：一个包含四个浮点数的列表，对应四个数据集，无量纲，并按上述规定四舍五入到三位小数。",
            "solution": "我们从牛顿万有引力定律开始，该定律支配着行星围绕恒星的运动。在多行星系统中，长期稳定性受到以相互希尔半径 (MHR) 为单位测量的行星邻近程度的影响。对于质量均为 $m$、绕一颗质量为 $M_\\star$ 的恒星运行的相邻行星，其相互希尔半径为\n$$\nR_{\\mathrm{H,m}} = \\left(\\frac{2m}{3 M_\\star}\\right)^{1/3} \\cdot \\frac{a_i + a_{i+1}}{2}.\n$$\n以MHR为单位的无量纲间距是\n$$\n\\Delta = \\frac{a_{i+1} - a_i}{R_{\\mathrm{H,m}}}.\n$$\n\n当质量相等的相邻行星按几何级数 $a_{i+1} = a_i (1 + \\epsilon)$ 排列时，间距为 $a_{i+1} - a_i = \\epsilon a_i$，平均半长轴为 $\\frac{a_i + a_{i+1}}{2} = a_i \\left(1 + \\frac{\\epsilon}{2}\\right)$。代入MHR间距的定义可得\n$$\n\\Delta(\\epsilon, m/M_\\star) = \\frac{\\epsilon a_i}{\\left(\\frac{2m}{3 M_\\star}\\right)^{1/3} \\cdot a_i \\left(1 + \\frac{\\epsilon}{2}\\right)} = \\frac{\\epsilon}{\\left(\\frac{2 m}{3 M_\\star}\\right)^{1/3} \\left(1 + \\frac{\\epsilon}{2}\\right)}.\n$$\n因此，对于给定的 $\\epsilon$ 和 $m/M_\\star$，在几何级数中，$\\Delta$ 对于所有相邻行星对都是恒定的。\n\n对等质量、等间距行星系统的经验研究广泛报道，不稳定性时间随归一化间距的增大而迅速增长。让我们假设其标准指数形式为：\n$$\nt_{\\mathrm{inst}} \\sim t_0 \\exp(\\beta \\Delta),\n$$\n其中 $t_0$ 是一个特征时间尺度，$\\beta$ 是一个敏感度参数，用于捕捉不稳定性时间随间距 $\\Delta$ 增加的剧烈程度。这种标度关系的动因可以是间距增大的系统中混沌扩散的指数抑制，尽管其精确的微观推导涉及复杂的非线性动力学，超出了本练习的范围。我们在此的目标是为所提供的数据集估计 $\\beta$。\n\n为了将其转化为线性估计问题，我们对两边取自然对数：\n$$\n\\ln t_{\\mathrm{inst}} = \\ln t_0 + \\beta \\Delta.\n$$\n定义 $y \\equiv \\ln t_{\\mathrm{inst}}$ 和 $x \\equiv \\Delta$。该模型变为一个简单的线性关系 $y = c + \\beta x$，其中 $c = \\ln t_0$ 是截距，$\\beta$ 是斜率。\n\n我们通过普通最小二乘法 (OLS) 来估计 $\\beta$，该方法旨在最小化残差平方和 $\\sum_i (y_i - c - \\beta x_i)^2$。斜率的OLS解为\n$$\n\\beta = \\frac{\\sum_i (x_i - \\bar{x})(y_i - \\bar{y})}{\\sum_i (x_i - \\bar{x})^2},\n$$\n其中 $\\bar{x}$ 和 $\\bar{y}$ 分别是 $x_i$ 和 $y_i$ 的样本均值。截距为\n$$\nc = \\bar{y} - \\beta \\bar{x},\n$$\n特征时间尺度可以通过 $t_0 = \\exp(c)$ 恢复。然而，本任务只要求计算每个数据集的 $\\beta$。\n\n每个数据集的算法步骤：\n\n1. 读取 $m/M_\\star$。\n2. 如果数据集直接提供 $\\Delta$ 值，则设 $x_i = \\Delta_i$。如果提供分数间距值 $\\epsilon_i$，则使用以下公式将每个值转换为 $\\Delta_i$：\n   $$\n   \\Delta_i = \\frac{\\epsilon_i}{\\left(\\frac{2 m}{3 M_\\star}\\right)^{1/3} \\left(1 + \\frac{\\epsilon_i}{2}\\right)}.\n   $$\n3. 读取 $t_{\\mathrm{inst},i}$ 值；确保所有值都为严格正数。计算 $y_i = \\ln(t_{\\mathrm{inst},i})$。\n4. 计算 $\\bar{x}$、$\\bar{y}$，然后使用上述公式计算OLS斜率 $\\beta$。\n5. 将得到的 $\\beta$ 四舍五入到三位小数，以保证输出一致性。\n\n科学真实性与合理性：数据集使用的不稳定时间以内侧行星的轨道周期为单位（无量纲），间距 $\\Delta$ 以相互希尔半径为单位（无量纲）。在质量相等和归一化间距相等的情况下，$t_{\\mathrm{inst}}$ 对 $\\Delta$ 的指数敏感性与已有的关于行星-行星散射及动力学不稳定性的数值实验结果一致。在固定的 $\\Delta$ 下，较大的 $m/M_\\star$ 通常会减少 $t_{\\mathrm{inst}}$，并可能改变经验斜率 $\\beta$，我们在此从提供的模拟数据集中估计该值。\n\n程序将按给定顺序处理四个数据集，并打印一行包含四个估计 $\\beta$ 值的列表，每个值四舍五入到三位小数，格式为 $[x_1,x_2,x_3,x_4]$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef ols_slope(x, y):\n    \"\"\"\n    Compute the ordinary least squares slope for y = c + beta * x.\n    Assumes x and y are 1D numpy arrays of equal length with length >= 2.\n    \"\"\"\n    x_mean = np.mean(x)\n    y_mean = np.mean(y)\n    # Covariance and variance\n    cov_xy = np.sum((x - x_mean) * (y - y_mean))\n    var_x = np.sum((x - x_mean) ** 2)\n    # Protect against zero variance in x\n    if var_x == 0.0:\n        return np.nan\n    beta = cov_xy / var_x\n    return beta\n\ndef delta_from_epsilon(epsilon_array, mass_ratio):\n    \"\"\"\n    Convert fractional spacings epsilon to Delta using the mutual Hill radius\n    definition for equal masses with geometric progression a_{i+1} = a_i (1 + epsilon).\n    Delta = epsilon / [ ((2m)/(3M_star))^(1/3) * (1 + epsilon/2) ].\n    \"\"\"\n    k = ((2.0 * mass_ratio) / 3.0) ** (1.0 / 3.0)\n    eps = np.array(epsilon_array, dtype=float)\n    delta = eps / (k * (1.0 + eps / 2.0))\n    return delta\n\ndef fit_beta_from_delta(delta_array, t_inst_array):\n    \"\"\"\n    Given arrays of Delta and t_inst (positive), fit beta via ln-transform OLS.\n    \"\"\"\n    delta = np.array(delta_array, dtype=float)\n    t_inst = np.array(t_inst_array, dtype=float)\n    # Filter strictly positive times\n    mask = t_inst > 0.0\n    delta = delta[mask]\n    t_inst = t_inst[mask]\n    # Need at least two points to fit\n    if delta.size  2:\n        return np.nan\n    y = np.log(t_inst)\n    beta = ols_slope(delta, y)\n    return beta\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case is a dict with keys:\n    # - 'type': 'direct' or 'epsilon'\n    # - 'mass_ratio': m/M_star\n    # - 'delta' or 'epsilon': list of spacings\n    # - 't_inst': list of instability times in inner orbital periods\n    test_cases = [\n        {\n            \"type\": \"direct\",\n            \"mass_ratio\": 1e-5,\n            \"delta\": [3.2, 3.6, 4.0, 4.4, 4.8],\n            \"t_inst\": [1200, 6000, 25000, 120000, 500000],\n        },\n        {\n            \"type\": \"direct\",\n            \"mass_ratio\": 3e-5,\n            \"delta\": [2.8, 3.0, 3.2, 3.4],\n            \"t_inst\": [80, 220, 700, 2200],\n        },\n        {\n            \"type\": \"direct\",\n            \"mass_ratio\": 5e-5,\n            \"delta\": [3.6, 4.0, 4.4, 4.8],\n            \"t_inst\": [600, 3000, 15000, 75000],\n        },\n        {\n            \"type\": \"epsilon\",\n            \"mass_ratio\": 2e-5,\n            \"epsilon\": [0.06, 0.08, 0.10, 0.12],\n            \"t_inst\": [200, 1000, 5000, 25000],\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        mass_ratio = case[\"mass_ratio\"]\n        if case[\"type\"] == \"direct\":\n            delta = case[\"delta\"]\n            t_inst = case[\"t_inst\"]\n            beta = fit_beta_from_delta(delta, t_inst)\n        elif case[\"type\"] == \"epsilon\":\n            epsilon = case[\"epsilon\"]\n            t_inst = case[\"t_inst\"]\n            delta = delta_from_epsilon(epsilon, mass_ratio)\n            beta = fit_beta_from_delta(delta, t_inst)\n        else:\n            beta = np.nan\n        # Round to three decimals as required\n        if np.isnan(beta):\n            results.append(\"nan\")\n        else:\n            results.append(f\"{beta:.3f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "任何天体物理理论的最终检验标准是其解释观测现象的能力。最后的这个练习将理论与现实联系起来，让您在系外行星数据中寻找过去散射事件的蛛丝马迹。通过计算已知系外行星对的轨道间距，并检验其与高偏心率的相关性，您将亲身体验系外行星动力学家的真实研究工作 。",
            "id": "4169797",
            "problem": "给定您来自系外行星系统的多组行星对。对于每对行星，都指定了主恒星质量、行星质量、半长轴和偏心率。您的任务是为每对行星计算以共同希尔半径为单位的归一化间距（用 $\\Delta$ 表示），并在数据集层面上检验 $\\Delta \\le 10$ 的系统是否比 $\\Delta  10$ 的系统表现出更高的偏心率，这与过去的散射事件相符。该检验必须使用一种统计上可靠且不依赖于分布的方法。\n\n理论基础：\n- 使用牛顿引力和希尔球概念推导共同希尔半径。对于质量分别为 $m_1$ 和 $m_2$、半长轴分别为 $a_1$ 和 $a_2$（其中 $a_2  a_1$）且围绕一颗质量为 $M_\\star$ 的恒星运行的两颗行星，其共同希尔半径 $R_{\\mathrm{H}}$ 由下式给出\n$$\nR_{\\mathrm{H}} = \\frac{a_1+a_2}{2} \\left(\\frac{m_1 + m_2}{3 M_\\star}\\right)^{1/3}.\n$$\n- 归一化间距为\n$$\n\\Delta = \\frac{a_2 - a_1}{R_{\\mathrm{H}}}.\n$$\n- 行星对层面的偏心率度量 $e_{\\mathrm{pair}}$ 定义为两个偏心率中较大的一个：$e_{\\mathrm{pair}} = \\max(e_1, e_2)$。\n\n统计检验：\n- 将行星对划分为两组：$\\mathcal{G}_{\\mathrm{small}} = \\{ \\text{行星对} : \\Delta \\le 10 \\}$ 和 $\\mathcal{G}_{\\mathrm{large}} = \\{ \\text{行星对} : \\Delta  10 \\}$。\n- 使用单边 Mann–Whitney U (MWU) 检验来检验 $\\mathcal{G}_{\\mathrm{small}}$ 组中 $e_{\\mathrm{pair}}$ 的分布是否倾向于大于 $\\mathcal{G}_{\\mathrm{large}}$ 组。每个数据集报告一个布尔值：如果 MWU 的 $p$ 值小于 $0.05$ 且 $\\mathcal{G}_{\\mathrm{small}}$ 组中 $e_{\\mathrm{pair}}$ 的均值大于 $\\mathcal{G}_{\\mathrm{large}}$ 组的均值，则返回 $\\mathrm{True}$；否则返回 $\\mathrm{False}$。如果任一组为空，则返回 $\\mathrm{False}$。\n\n单位：\n- $M_\\star$ 必须以太阳质量为单位。\n- $m_1$ 和 $m_2$ 必须以地球质量为单位。\n- $a_1$ 和 $a_2$ 必须以天文单位 (AU) 为单位。\n- 偏心率 $e_1$ 和 $e_2$ 是无量纲数。\n- 本问题不涉及角度。\n\n实现要求：\n- 在计算 $R_{\\mathrm{H}}$ 之前，使用 $1\\,M_{\\oplus} = 3.003\\times 10^{-6}\\,M_{\\odot}$ 将行星质量从地球质量转换为太阳质量。\n- 对于每个数据集，计算所有的 $\\Delta$ 和 $e_{\\mathrm{pair}}$ 值，执行 MWU 检验，并按规定生成布尔输出。\n\n测试集：\n- 数据集 1 (混合型，预期 $\\mathcal{G}_{\\mathrm{small}}$ 组会表现出更高的偏心率)：\n  - $(M_\\star, m_1, m_2, a_1, a_2, e_1, e_2) = (1.0, 300.0, 200.0, 0.9, 1.3, 0.15, 0.20)$\n  - $(1.0, 100.0, 80.0, 0.5, 0.62, 0.12, 0.15)$\n  - $(1.0, 5.0, 5.0, 0.3, 0.6, 0.03, 0.02)$\n  - $(1.0, 10.0, 12.0, 1.0, 2.5, 0.04, 0.05)$\n  - $(1.0, 260.0, 300.0, 5.0, 5.3, 0.35, 0.30)$\n  - $(1.0, 20.0, 30.0, 0.9, 1.8, 0.06, 0.08)$\n- 数据集 2 (包含边界值 $\\Delta \\approx 10$，预期 $\\mathcal{G}_{\\mathrm{small}}$ 组不会表现出更高的偏心率)：\n  - $(1.0, 5.0, 5.0, 0.8925, 1.1075, 0.02, 0.03)$\n  - $(1.0, 5.0, 10.0, 0.5, 0.7, 0.10, 0.09)$\n  - $(1.0, 20.0, 20.0, 1.0, 1.18, 0.04, 0.04)$\n  - $(1.0, 10.0, 10.0, 0.2, 0.45, 0.08, 0.10)$\n  - $(1.0, 30.0, 40.0, 3.0, 3.25, 0.05, 0.07)$\n- 数据集 3 (主恒星质量可变，预期 $\\mathcal{G}_{\\mathrm{small}}$ 组会表现出更高的偏心率)：\n  - $(0.8, 300.0, 200.0, 1.0, 1.3, 0.25, 0.22)$\n  - $(0.8, 260.0, 300.0, 5.0, 5.3, 0.35, 0.30)$\n  - $(0.8, 100.0, 80.0, 0.5, 0.62, 0.15, 0.12)$\n  - $(0.8, 10.0, 10.0, 0.2, 0.45, 0.03, 0.04)$\n  - $(0.8, 20.0, 30.0, 0.9, 1.8, 0.06, 0.07)$\n- 数据集 4 (边界情况：所有行星对的 $\\Delta  10$，因此 $\\mathcal{G}_{\\mathrm{small}}$ 组为空；必须返回 $\\mathrm{False}$)：\n  - $(1.0, 5.0, 6.0, 0.3, 0.9, 0.12, 0.08)$\n  - $(1.2, 8.0, 7.0, 1.5, 3.0, 0.14, 0.10)$\n  - $(0.9, 4.0, 5.0, 0.1, 0.3, 0.05, 0.07)$\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含四个数据集的布尔结果，形式为方括号括起来的逗号分隔列表，例如 $[\\mathrm{True},\\mathrm{False},\\mathrm{True},\\mathrm{False}]$。输出值为纯布尔值，没有单位。",
            "solution": "问题陈述已经过严格验证，被认为是自洽的、有科学依据且适定的。所有数据、公式和流程均已提供，从而可以得出一个唯一的、可验证的解。我们将着手进行分析。\n\n目标是确定对于几组系外行星对数据集，轨道间距较小的系统是否表现出统计上显著更高的偏心率，这可能是过去动力学散射事件的一个潜在特征。这涉及到计算以共同希尔半径为单位的归一化间距 $\\Delta$ 和行星对的偏心率度量 $e_{\\mathrm{pair}}$，然后对两组系统进行统计比较。\n\n方法如下：\n\n1.  对于每个行星对 $(M_\\star, m_1, m_2, a_1, a_2, e_1, e_2)$，我们首先计算行星对层面的偏心率度量 $e_{\\mathrm{pair}}$，其定义为两颗行星偏心率中的最大值：\n    $$e_{\\mathrm{pair}} = \\max(e_1, e_2)$$\n\n2.  接下来，我们计算归一化间距 $\\Delta$。这需要计算共同希尔半径 $R_{\\mathrm{H}}$。以地球质量 ($M_{\\oplus}$) 给出的行星质量必须使用给定的关系式 $1\\,M_{\\oplus} = 3.003 \\times 10^{-6}\\,M_{\\odot}$ 转换为太阳质量 ($M_{\\odot}$)。设以太阳质量为单位的质量为 $M_{1, \\odot}$ 和 $M_{2, \\odot}$。\n    共同希尔半径则为：\n    $$R_{\\mathrm{H}} = \\frac{a_1+a_2}{2} \\left(\\frac{M_{1, \\odot} + M_{2, \\odot}}{3 M_\\star}\\right)^{1/3}$$\n\n3.  有了 $R_{\\mathrm{H}}$，归一化间距 $\\Delta$ 的计算公式如下：\n    $$\\Delta = \\frac{a_2 - a_1}{R_{\\mathrm{H}}}$$\n\n4.  根据 $\\Delta$ 的值，每对行星被分配到两组中的一组：\n    -   $\\mathcal{G}_{\\mathrm{small}} = \\{ \\text{行星对} : \\Delta \\le 10 \\}$\n    -   $\\mathcal{G}_{\\mathrm{large}} = \\{ \\text{行星对} : \\Delta  10 \\}$\n    对应于这些组的 $e_{\\mathrm{pair}}$ 值集合将分别表示为 $E_{\\mathrm{small}}$ 和 $E_{\\mathrm{large}}$。\n\n5.  分析的核心是一个统计检验。问题规定了每个数据集基于一个两部分条件的布尔输出。当且仅当以下两个条件都满足时，返回结果为 $\\mathrm{True}$：\n    -   小间距组的偏心率算术平均值严格大于大间距组的偏心率算术平均值：$\\mathrm{mean}(E_{\\mathrm{small}})  \\mathrm{mean}(E_{\\mathrm{large}})$。\n    -   单边 Mann-Whitney U (MWU) 检验（该检验测试的备择假设是 $E_{\\mathrm{small}}$ 的分布随机地大于 $E_{\\mathrm{large}}$ 的分布）得出的 $p$ 值严格小于 $0.05$。\n\n6.  作为一个边界条件，如果对于给定的数据集，$\\mathcal{G}_{\\mathrm{small}}$ 或 $\\mathcal{G}_{\\mathrm{large}}$ 组中任何一个为空，则该数据集的结果立即为 $\\mathrm{False}$。\n\n让我们对数据集 1 进行详细分析以说明此过程。该数据集由 6 对行星组成。\n\n-   行星对 1：$(1.0, 300.0, 200.0, 0.9, 1.3, 0.15, 0.20)$\n    $m_1 + m_2 = 500.0\\,M_\\oplus = 1.5015 \\times 10^{-3}\\,M_\\odot$。\n    $R_{\\mathrm{H}} = \\frac{0.9+1.3}{2} (\\frac{1.5015 \\times 10^{-3}}{3 \\times 1.0})^{1/3} \\approx 0.0873\\,\\text{AU}$。\n    $\\Delta = \\frac{1.3-0.9}{0.0873} \\approx 4.58$。由于 $\\Delta \\le 10$，该行星对属于 $\\mathcal{G}_{\\mathrm{small}}$ 组。\n    $e_{\\mathrm{pair}} = \\max(0.15, 0.20) = 0.20$。\n\n-   行星对 5：$(1.0, 260.0, 300.0, 5.0, 5.3, 0.35, 0.30)$\n    $m_1 + m_2 = 560.0\\,M_\\oplus = 1.68168 \\times 10^{-3}\\,M_\\odot$。\n    $R_{\\mathrm{H}} = \\frac{5.0+5.3}{2} (\\frac{1.68168 \\times 10^{-3}}{3 \\times 1.0})^{1/3} \\approx 0.3040\\,\\text{AU}$。\n    $\\Delta = \\frac{5.3-5.0}{0.3040} \\approx 0.99$。由于 $\\Delta \\le 10$，该行星对属于 $\\mathcal{G}_{\\mathrm{small}}$ 组。\n    $e_{\\mathrm{pair}} = \\max(0.35, 0.30) = 0.35$。\n\n将此过程应用于数据集 1 中的所有行星对，得到以下划分：\n-   $E_{\\mathrm{small}} = \\{0.20, 0.15, 0.35\\}$ 来自 $\\Delta \\approx \\{4.58, 3.71, 0.99\\}$ 的行星对。\n-   $E_{\\mathrm{large}} = \\{0.03, 0.05, 0.08\\}$ 来自 $\\Delta \\approx \\{30.71, 30.62, 19.10\\}$ 的行星对。\n\n现在，我们应用判定标准：\n-   $\\mathrm{mean}(E_{\\mathrm{small}}) = (0.20+0.15+0.35)/3 \\approx 0.233$。\n-   $\\mathrm{mean}(E_{\\mathrm{large}}) = (0.03+0.05+0.08)/3 \\approx 0.053$。\n条件 $\\mathrm{mean}(E_{\\mathrm{small}})  \\mathrm{mean}(E_{\\mathrm{large}})$ 得到满足。\n\n-   接下来，我们对 $E_{\\mathrm{small}}$ 和 $E_{\\mathrm{large}}$ 执行单边 Mann-Whitney U 检验。对于这两个样本量均为 $n_1=3$ 和 $n_2=3$ 的样本，数据按秩是完全分离的，这代表了最可能出现的极端结果。将这 6 个组合样本进行排列的方法有 $\\binom{6}{3} = 20$ 种。观测到的极端情况只出现一次。因此，对于这个最极端结果，其精确的单尾 $p$ 值为 $p = 1/20 = 0.05$。\n\n判定规则要求 $p$ 值严格小于 $0.05$。由于我们计算出的 $p$ 值为 $0.05$，条件 $p  0.05$ 未被满足。因此，数据集 1 的结果为 $\\mathrm{False}$。\n\n此处一个关键的见解是，对于某些小样本量，要获得小于常规显著性水平 $\\alpha = 0.05$ 的 $p$ 值在数学上是不可能的。对于样本量为 $(3, 3)$ 的情况，可能的最小 $p$ 值为 $0.05$。对于数据集 3，其样本量为 $(3, 2)$，可能的最小 $p$ 值为 $1/\\binom{5}{2} = 0.1$。在这些情况下，无论数据分离得多开，都永远无法在指定的显著性水平上拒绝原假设。这种统计功效的缺乏是数据点数量过少的直接后果。\n\n所有数据集的最终布尔结果都是通过严格遵守指定程序得出的。\n-   **数据集 1：** 结果为 $\\mathrm{False}$（$p=0.05$，不小于 $0.05$）。\n-   **数据集 2：** 结果为 $\\mathrm{False}$（均值条件不满足：$0.047 \\ngtr 0.1$）。\n-   **数据集 3：** 结果为 $\\mathrm{False}$（$p=0.1$，不小于 $0.05$）。\n-   **数据集 4：** 结果为 $\\mathrm{False}$（$\\mathcal{G}_{\\mathrm{small}}$ 组为空）。\n\n因此，基于对既定规则的严格应用，没有一个数据集满足输出 $\\mathrm{True}$ 的标准。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import mannwhitneyu\n\ndef solve():\n    \"\"\"\n    Main function to process datasets and print results.\n    \"\"\"\n    \n    # Conversion constant from Earth mass to Solar mass.\n    M_EARTH_TO_SOLAR = 3.003e-6\n\n    # Test suite of four datasets.\n    # Each tuple represents a planetary pair:\n    # (M_star, m1, m2, a1, a2, e1, e2)\n    # M_star in Solar masses, m1/m2 in Earth masses, a1/a2 in AU.\n    test_suite = [\n        # Dataset 1\n        [\n            (1.0, 300.0, 200.0, 0.9, 1.3, 0.15, 0.20),\n            (1.0, 100.0, 80.0, 0.5, 0.62, 0.12, 0.15),\n            (1.0, 5.0, 5.0, 0.3, 0.6, 0.03, 0.02),\n            (1.0, 10.0, 12.0, 1.0, 2.5, 0.04, 0.05),\n            (1.0, 260.0, 300.0, 5.0, 5.3, 0.35, 0.30),\n            (1.0, 20.0, 30.0, 0.9, 1.8, 0.06, 0.08),\n        ],\n        # Dataset 2\n        [\n            (1.0, 5.0, 5.0, 0.8925, 1.1075, 0.02, 0.03),\n            (1.0, 5.0, 10.0, 0.5, 0.7, 0.10, 0.09),\n            (1.0, 20.0, 20.0, 1.0, 1.18, 0.04, 0.04),\n            (1.0, 10.0, 10.0, 0.2, 0.45, 0.08, 0.10),\n            (1.0, 30.0, 40.0, 3.0, 3.25, 0.05, 0.07),\n        ],\n        # Dataset 3\n        [\n            (0.8, 300.0, 200.0, 1.0, 1.3, 0.25, 0.22),\n            (0.8, 260.0, 300.0, 5.0, 5.3, 0.35, 0.30),\n            (0.8, 100.0, 80.0, 0.5, 0.62, 0.15, 0.12),\n            (0.8, 10.0, 10.0, 0.2, 0.45, 0.03, 0.04),\n            (0.8, 20.0, 30.0, 0.9, 1.8, 0.06, 0.07),\n        ],\n        # Dataset 4\n        [\n            (1.0, 5.0, 6.0, 0.3, 0.9, 0.12, 0.08),\n            (1.2, 8.0, 7.0, 1.5, 3.0, 0.14, 0.10),\n            (0.9, 4.0, 5.0, 0.1, 0.3, 0.05, 0.07),\n        ],\n    ]\n\n    def process_dataset(dataset):\n        \"\"\"\n        Processes a single dataset of planetary pairs.\n        \"\"\"\n        e_pair_small = []\n        e_pair_large = []\n\n        for pair in dataset:\n            m_star, m1_earth, m2_earth, a1, a2, e1, e2 = pair\n\n            # Convert planet masses to Solar masses\n            m1_solar = m1_earth * M_EARTH_TO_SOLAR\n            m2_solar = m2_earth * M_EARTH_TO_SOLAR\n            \n            # Calculate mutual Hill radius\n            mass_ratio_term = (m1_solar + m2_solar) / (3 * m_star)\n            r_hill = ((a1 + a2) / 2) * (mass_ratio_term**(1/3))\n\n            # Calculate normalized separation, avoiding division by zero\n            if r_hill == 0:\n                # This case shouldn't happen with given data but is good practice\n                delta = float('inf')\n            else:\n                delta = (a2 - a1) / r_hill\n            \n            # Calculate pair-level eccentricity\n            e_pair = max(e1, e2)\n\n            # Partition the pair into groups based on delta\n            if delta = 10:\n                e_pair_small.append(e_pair)\n            else:\n                e_pair_large.append(e_pair)\n        \n        # If either group is empty, the result is False\n        if not e_pair_small or not e_pair_large:\n            return False\n\n        # Convert lists to numpy arrays for mean calculation\n        e_small_np = np.array(e_pair_small)\n        e_large_np = np.array(e_pair_large)\n\n        # Check if the mean of the small group is greater than the large group\n        mean_condition = np.mean(e_small_np) > np.mean(e_large_np)\n        \n        # Perform one-sided Mann-Whitney U test\n        # alternative='greater' tests if x is stochastically larger than y\n        try:\n            _, p_value = mannwhitneyu(e_small_np, e_large_np, alternative='greater')\n        except ValueError:\n            # This can happen if all values in one sample are the same,\n            # though not the case with the given test data.\n            return False\n\n        # The p-value must be strictly less than 0.05\n        p_value_condition = p_value  0.05\n\n        # Return True only if both conditions are met\n        return mean_condition and p_value_condition\n\n    results = [process_dataset(ds) for ds in test_suite]\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}