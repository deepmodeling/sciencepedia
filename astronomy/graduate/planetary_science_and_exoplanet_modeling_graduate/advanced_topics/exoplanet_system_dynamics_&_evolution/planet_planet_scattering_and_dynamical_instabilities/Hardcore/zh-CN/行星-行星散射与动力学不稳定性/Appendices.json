{
    "hands_on_practices": [
        {
            "introduction": "行星系统动力学不稳定性的一个核心特征是，其稳定时间尺度随着行星间距的增加呈指数增长。这项练习将引导你通过分析模拟数据来量化这一基本关系。你将把一个经验性的指数模型 $t_{\\mathrm{inst}} \\sim t_0 \\exp(\\beta \\Delta)$ 线性化，并利用最小二乘法拟合出关键的灵敏度参数 $\\beta$，从而掌握分析数值模拟输出和验证理论模型的基本技能。",
            "id": "4169857",
            "problem": "要求您形式化并估计紧凑、等质量、等间距行星系统中动力学不稳定时间对其初始间距的敏感性。从经典力学和天体力学的基本原理出发，构建一个定量推断程序，将首次近距离引力相遇的时间与相邻行星之间的归一化间距联系起来。\n\n使用以下基础：\n\n- 牛顿万有引力定律：质量为 $m$ 的行星因距离为 $r$、质量为 $M_\\star$ 的恒星而产生的加速度由 $G M_\\star / r^2$ 决定，其中 $G$ 是引力常数，$r$ 是间距。\n- 两个质量相等（均为 $m$）的相邻行星，以半长轴 $a_i$ 和 $a_{i+1}$ 绕质量为 $M_\\star$ 的恒星运行时，其相互希尔半径（MHR）定义为\n$$\nR_{\\mathrm{H,m}} \\equiv \\left(\\frac{m_i + m_{i+1}}{3 M_\\star}\\right)^{1/3} \\cdot \\frac{a_i + a_{i+1}}{2}.\n$$\n对于等质量 $m_i = m_{i+1} = m$，此式简化为\n$$\nR_{\\mathrm{H,m}} = \\left(\\frac{2m}{3 M_\\star}\\right)^{1/3} \\cdot \\frac{a_i + a_{i+1}}{2}.\n$$\n- 以相互希尔半径为单位，定义无量纲间距为\n$$\n\\Delta \\equiv \\frac{a_{i+1} - a_i}{R_{\\mathrm{H,m}}}.\n$$\n\n假设存在一个被广泛报道的经验关系，该关系将等质量、等间距行星的不稳定时间 $t_{\\mathrm{inst}}$ 与间距 $\\Delta$ 联系起来。通过适当的变量变换将此关系转换为线性模型，然后对每个数据集估计控制不稳定时间对 $\\Delta$ 敏感性的参数。在线性模型的背景下解释该参数，并通过最小二乘法拟合来计算它。\n\n此处，不稳定时间 $t_{\\mathrm{inst}}$ 定义为任意相邻行星对之间发生首次近距离接触的时间，以最内侧行星的轨道周期为单位进行度量，因此 $t_{\\mathrm{inst}}$ 是一个无量纲量。所有角度（如有）均与此问题无关。使用自然对数函数。所有结果应表示为无量纲浮点数。\n\n对于下方的测试套件，请使用以下数据集。每个数据集对应一个固定的相等行星质量比 $m/M_\\star$，并直接提供 $\\Delta$ 值和相应的 $t_{\\mathrm{inst}}$ 值列表，或提供分数间距值，您必须首先使用相互希尔半径定义从中计算 $\\Delta$。当提供分数间距时，假设相邻行星遵循几何级数 $a_{i+1} = a_i (1 + \\epsilon)$，因此 $a_{i+1} - a_i = \\epsilon a_i$，并在相互希尔半径公式中使用精确平均值 $\\frac{a_i + a_{i+1}}{2} = a_i \\left(1 + \\frac{\\epsilon}{2}\\right)$。对于等质量，这会得到\n$$\n\\Delta(\\epsilon, m/M_\\star) = \\frac{\\epsilon}{\\left(\\frac{2 m}{3 M_\\star}\\right)^{1/3} \\left(1 + \\frac{\\epsilon}{2}\\right)}.\n$$\n\n要使用的数据集：\n\n- 数据集 1：质量比 $m/M_\\star = 1\\times 10^{-5}$。直接间距和不稳定时间：\n  - $\\Delta$ 值：$[3.2, 3.6, 4.0, 4.4, 4.8]$。\n  - $t_{\\mathrm{inst}}$ 值（以内轨道周期为单位）：$[1200, 6000, 25000, 120000, 500000]$。\n\n- 数据集 2：质量比 $m/M_\\star = 3\\times 10^{-5}$。直接间距和不稳定时间：\n  - $\\Delta$ 值：$[2.8, 3.0, 3.2, 3.4]$。\n  - $t_{\\mathrm{inst}}$ 值（以内轨道周期为单位）：$[80, 220, 700, 2200]$。\n\n- 数据集 3：质量比 $m/M_\\star = 5\\times 10^{-5}$。直接间距和不稳定时间：\n  - $\\Delta$ 值：$[3.6, 4.0, 4.4, 4.8]$。\n  - $t_{\\mathrm{inst}}$ 值（以内轨道周期为单位）：$[600, 3000, 15000, 75000]$。\n\n- 数据集 4：质量比 $m/M_\\star = 2\\times 10^{-5}$。分数间距值 $\\epsilon$ 和不稳定时间：\n  - $\\epsilon$ 值：$[0.06, 0.08, 0.10, 0.12]$。\n  - $t_{\\mathrm{inst}}$ 值（以内轨道周期为单位）：$[200, 1000, 5000, 25000]$。\n  在拟合前，使用上述公式将此数据集中的每个 $\\epsilon$ 转换为 $\\Delta$。\n\n任务要求：\n\n- 对每个数据集，构建由经验关系的变量变换所蕴含的线性模型，并使用普通最小二乘法估计敏感性参数。\n- 最小二乘解必须从第一性原理出发进行解析计算，不得依赖任何黑箱拟合工具。根据变换需要，使用 $t_{\\mathrm{inst}}$ 的自然对数，并将 $\\Delta$（或从 $\\epsilon$ 转换而来）视为自变量。\n- 数值稳定性：如果任何 $t_{\\mathrm{inst}}$ 为非正数，则必须丢弃；然而，所提供的数据集均为严格正数。\n- 输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。该列表应按数据集 1 到 4 的顺序包含四个估计的敏感性参数，每个参数四舍五入到小数点后三位，例如 $[x_1,x_2,x_3,x_4]$，其中每个 $x_i$ 都是浮点数。\n\n您的最终输出必须是单行：一个包含四个浮点数的列表，对应四个数据集，无量纲，并按上述要求四舍五入到小数点后三位。",
            "solution": "我们从牛顿万有引力定律开始，该定律支配着行星围绕恒星的运动。在多行星系统中，长期稳定性受到以相互希尔半径（MHR）为单位测量的行星间邻近程度的影响。对于质量相等（均为 $m$）的相邻行星，绕质量为 $M_\\star$ 的恒星运行时，其相互希尔半径为\n$$\nR_{\\mathrm{H,m}} = \\left(\\frac{2m}{3 M_\\star}\\right)^{1/3} \\cdot \\frac{a_i + a_{i+1}}{2}.\n$$\n以 MHR 为单位的无量纲间距是\n$$\n\\Delta = \\frac{a_{i+1} - a_i}{R_{\\mathrm{H,m}}}.\n$$\n\n当质量相等的相邻行星按几何级数 $a_{i+1} = a_i (1 + \\epsilon)$ 排列时，间距为 $a_{i+1} - a_i = \\epsilon a_i$，平均半长轴为 $\\frac{a_i + a_{i+1}}{2} = a_i \\left(1 + \\frac{\\epsilon}{2}\\right)$。代入 MHR 间距定义可得\n$$\n\\Delta(\\epsilon, m/M_\\star) = \\frac{\\epsilon a_i}{\\left(\\frac{2m}{3 M_\\star}\\right)^{1/3} \\cdot a_i \\left(1 + \\frac{\\epsilon}{2}\\right)} = \\frac{\\epsilon}{\\left(\\frac{2 m}{3 M_\\star}\\right)^{1/3} \\left(1 + \\frac{\\epsilon}{2}\\right)}.\n$$\n因此，对于给定的 $\\epsilon$ 和 $m/M_\\star$，$\\Delta$ 在几何级数中的相邻行星对之间是恒定的。\n\n对等质量、等间距行星系统的经验研究广泛报道，不稳定时间随归一化间距的增加而迅速增长。让我们假设其具有标准指数形式：\n$$\nt_{\\mathrm{inst}} \\sim t_0 \\exp(\\beta \\Delta),\n$$\n其中 $t_0$ 是一个特征时间尺度，$\\beta$ 是一个敏感性参数，用于捕捉不稳定时间随间距 $\\Delta$ 增加的剧烈程度。这种标度关系可以由间距增大的系统中混沌扩散的指数抑制来解释，尽管其精确的微观推导涉及复杂的非线性动力学，超出了本练习的范围。我们在这里的目标是为所提供的数据集估计 $\\beta$。\n\n为将其转化为线性估计问题，对两边取自然对数：\n$$\n\\ln t_{\\mathrm{inst}} = \\ln t_0 + \\beta \\Delta.\n$$\n定义 $y \\equiv \\ln t_{\\mathrm{inst}}$ 和 $x \\equiv \\Delta$。模型变为简单的线性关系 $y = c + \\beta x$，其中 $c = \\ln t_0$ 是截距，$\\beta$ 是斜率。\n\n我们通过普通最小二乘法（OLS）估计 $\\beta$，该方法最小化残差平方和 $\\sum_i (y_i - c - \\beta x_i)^2$。斜率的 OLS 解为\n$$\n\\beta = \\frac{\\sum_i (x_i - \\bar{x})(y_i - \\bar{y})}{\\sum_i (x_i - \\bar{x})^2},\n$$\n其中 $\\bar{x}$ 和 $\\bar{y}$ 分别是 $x_i$ 和 $y_i$ 的样本均值。截距为\n$$\nc = \\bar{y} - \\beta \\bar{x},\n$$\n特征时间尺度可以恢复为 $t_0 = \\exp(c)$。然而，任务只要求每个数据集的 $\\beta$。\n\n每个数据集的算法步骤：\n\n1. 读取 $m/M_\\star$。\n2. 如果数据集直接提供 $\\Delta$ 值，则设 $x_i = \\Delta_i$。如果提供分数间距值 $\\epsilon_i$，则使用以下公式将每个值转换为 $\\Delta_i$：\n   $$\n   \\Delta_i = \\frac{\\epsilon_i}{\\left(\\frac{2 m}{3 M_\\star}\\right)^{1/3} \\left(1 + \\frac{\\epsilon_i}{2}\\right)}.\n   $$\n3. 读取 $t_{\\mathrm{inst},i}$ 值；确保所有值均为严格正数。计算 $y_i = \\ln(t_{\\mathrm{inst},i})$。\n4. 计算 $\\bar{x}$、$\\bar{y}$，然后使用上述公式计算 OLS 斜率 $\\beta$。\n5. 将得到的 $\\beta$ 四舍五入到小数点后三位，以保证输出一致性。\n\n科学真实性与合理性：数据集使用以最内侧行星轨道周期为单位（无量纲）的不稳定时间和以相互希尔半径为单位（无量纲）的间距 $\\Delta$。在等质量和等归一化间距的条件下，$t_{\\mathrm{inst}}$ 对 $\\Delta$ 的指数敏感性与行星-行星散射和动力学不稳定性中已有的数值实验结果一致。在固定的 $\\Delta$ 下，较大的 $m/M_\\star$ 通常会减少 $t_{\\mathrm{inst}}$，并可能改变经验斜率 $\\beta$，我们在此从提供的模拟数据集中估计该值。\n\n程序将按给定顺序处理四个数据集，并打印一行包含四个估计的 $\\beta$ 值的列表，每个值四舍五入到小数点后三位，格式为 $[x_1,x_2,x_3,x_4]$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef ols_slope(x, y):\n    \"\"\"\n    Compute the ordinary least squares slope for y = c + beta * x.\n    Assumes x and y are 1D numpy arrays of equal length with length >= 2.\n    \"\"\"\n    x_mean = np.mean(x)\n    y_mean = np.mean(y)\n    # Covariance and variance\n    cov_xy = np.sum((x - x_mean) * (y - y_mean))\n    var_x = np.sum((x - x_mean) ** 2)\n    # Protect against zero variance in x\n    if var_x == 0.0:\n        return np.nan\n    beta = cov_xy / var_x\n    return beta\n\ndef delta_from_epsilon(epsilon_array, mass_ratio):\n    \"\"\"\n    Convert fractional spacings epsilon to Delta using the mutual Hill radius\n    definition for equal masses with geometric progression a_{i+1} = a_i (1 + epsilon).\n    Delta = epsilon / [ ((2m)/(3M_star))^(1/3) * (1 + epsilon/2) ].\n    \"\"\"\n    k = ((2.0 * mass_ratio) / 3.0) ** (1.0 / 3.0)\n    eps = np.array(epsilon_array, dtype=float)\n    delta = eps / (k * (1.0 + eps / 2.0))\n    return delta\n\ndef fit_beta_from_delta(delta_array, t_inst_array):\n    \"\"\"\n    Given arrays of Delta and t_inst (positive), fit beta via ln-transform OLS.\n    \"\"\"\n    delta = np.array(delta_array, dtype=float)\n    t_inst = np.array(t_inst_array, dtype=float)\n    # Filter strictly positive times\n    mask = t_inst > 0.0\n    delta = delta[mask]\n    t_inst = t_inst[mask]\n    # Need at least two points to fit\n    if delta.size  2:\n        return np.nan\n    y = np.log(t_inst)\n    beta = ols_slope(delta, y)\n    return beta\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case is a dict with keys:\n    # - 'type': 'direct' or 'epsilon'\n    # - 'mass_ratio': m/M_star\n    # - 'delta' or 'epsilon': list of spacings\n    # - 't_inst': list of instability times in inner orbital periods\n    test_cases = [\n        {\n            \"type\": \"direct\",\n            \"mass_ratio\": 1e-5,\n            \"delta\": [3.2, 3.6, 4.0, 4.4, 4.8],\n            \"t_inst\": [1200, 6000, 25000, 120000, 500000],\n        },\n        {\n            \"type\": \"direct\",\n            \"mass_ratio\": 3e-5,\n            \"delta\": [2.8, 3.0, 3.2, 3.4],\n            \"t_inst\": [80, 220, 700, 2200],\n        },\n        {\n            \"type\": \"direct\",\n            \"mass_ratio\": 5e-5,\n            \"delta\": [3.6, 4.0, 4.4, 4.8],\n            \"t_inst\": [600, 3000, 15000, 75000],\n        },\n        {\n            \"type\": \"epsilon\",\n            \"mass_ratio\": 2e-5,\n            \"epsilon\": [0.06, 0.08, 0.10, 0.12],\n            \"t_inst\": [200, 1000, 5000, 25000],\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        mass_ratio = case[\"mass_ratio\"]\n        if case[\"type\"] == \"direct\":\n            delta = case[\"delta\"]\n            t_inst = case[\"t_inst\"]\n            beta = fit_beta_from_delta(delta, t_inst)\n        elif case[\"type\"] == \"epsilon\":\n            epsilon = case[\"epsilon\"]\n            t_inst = case[\"t_inst\"]\n            delta = delta_from_epsilon(epsilon, mass_ratio)\n            beta = fit_beta_from_delta(delta, t_inst)\n        else:\n            beta = np.nan\n        # Round to three decimals as required\n        if np.isnan(beta):\n            results.append(\"nan\")\n        else:\n            results.append(f\"{beta:.3f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在理解了稳定性如何依赖于初始间距之后，我们自然会问：不稳定性会留下什么可观测的后果？这项实践模拟了系外行星天文学家的工作，旨在检验散射理论的一个关键预测：轨道间距较小（即 $\\Delta$ 值较低）的行星系统，由于经历过更剧烈的动力学演化，其轨道偏心率应普遍更高。你将对一个模拟数据集应用统计检验，以寻找这种储存在行星系统架构中的动力学“化石记录”。",
            "id": "4169797",
            "problem": "您将获得多组来自系外行星系统的行星对数据。对于每一对行星，其主恒星质量、行星质量、半长轴和偏心率都已给定。您的任务是为每对行星计算以相互希尔半径为单位的归一化间距（用 $\\Delta$ 表示），并在数据集层面检验 $\\Delta \\le 10$ 的系统是否比 $\\Delta  10$ 的系统表现出更高的偏心率，以验证其与过去的散射事件是否一致。该检验必须使用统计上可靠的、无分布假设的方法进行。\n\n基本原理：\n- 使用牛顿引力和希尔球概念推导相互希尔半径。对于质量分别为 $m_1$ 和 $m_2$、半长轴分别为 $a_1$ 和 $a_2$（其中 $a_2  a_1$）的两颗行星，它们环绕一颗质量为 $M_\\star$ 的恒星运行，其相互希尔半径 $R_{\\mathrm{H}}$ 由下式给出\n$$\nR_{\\mathrm{H}} = \\frac{a_1+a_2}{2} \\left(\\frac{m_1 + m_2}{3 M_\\star}\\right)^{1/3}.\n$$\n- 归一化间距为\n$$\n\\Delta = \\frac{a_2 - a_1}{R_{\\mathrm{H}}}.\n$$\n- 行星对的偏心率度量 $e_{\\mathrm{pair}}$ 定义为两个偏心率中的较大者：$e_{\\mathrm{pair}} = \\max(e_1, e_2)$。\n\n统计检验：\n- 将行星对划分为两组：$\\mathcal{G}_{\\mathrm{small}} = \\{ \\text{行星对} : \\Delta \\le 10 \\}$ 和 $\\mathcal{G}_{\\mathrm{large}} = \\{ \\text{行星对} : \\Delta  10 \\}$。\n- 使用单边 Mann–Whitney U (MWU) 检验来测试 $\\mathcal{G}_{\\mathrm{small}}$ 组中 $e_{\\mathrm{pair}}$ 的分布是否倾向于比 $\\mathcal{G}_{\\mathrm{large}}$ 组中的更大。为每个数据集报告一个布尔值：如果 MWU 的 $p$ 值小于 $0.05$ 且 $\\mathcal{G}_{\\mathrm{small}}$ 组中 $e_{\\mathrm{pair}}$ 的均值大于 $\\mathcal{G}_{\\mathrm{large}}$ 组中的均值，则返回 $\\mathrm{True}$；否则返回 $\\mathrm{False}$。如果任一组为空，则返回 $\\mathrm{False}$。\n\n单位：\n- $M_\\star$ 必须以太阳质量为单位。\n- $m_1$ 和 $m_2$ 必须以地球质量为单位。\n- $a_1$ 和 $a_2$ 必须以天文单位 (AU) 为单位。\n- 偏心率 $e_1$ 和 $e_2$ 是无量纲数。\n- 本问题不涉及角度。\n\n实现要求：\n- 在计算 $R_{\\mathrm{H}}$ 之前，使用 $1\\,M_{\\oplus} = 3.003\\times 10^{-6}\\,M_{\\odot}$ 将行星质量从地球质量转换为太阳质量。\n- 对每个数据集，计算所有的 $\\Delta$ 和 $e_{\\mathrm{pair}}$ 值，执行 MWU 检验，并按规定生成布尔值输出。\n\n测试套件：\n- 数据集 1 (混合型，预计 $\\mathcal{G}_{\\mathrm{small}}$ 组表现出更高的偏心率):\n  - $(M_\\star, m_1, m_2, a_1, a_2, e_1, e_2) = (1.0, 300.0, 200.0, 0.9, 1.3, 0.15, 0.20)$\n  - $(1.0, 100.0, 80.0, 0.5, 0.62, 0.12, 0.15)$\n  - $(1.0, 5.0, 5.0, 0.3, 0.6, 0.03, 0.02)$\n  - $(1.0, 10.0, 12.0, 1.0, 2.5, 0.04, 0.05)$\n  - $(1.0, 260.0, 300.0, 5.0, 5.3, 0.35, 0.30)$\n  - $(1.0, 20.0, 30.0, 0.9, 1.8, 0.06, 0.08)$\n- 数据集 2 (包含边界值 $\\Delta \\approx 10$，预计 $\\mathcal{G}_{\\mathrm{small}}$ 组不会表现出更高的偏心率):\n  - $(1.0, 5.0, 5.0, 0.8925, 1.1075, 0.02, 0.03)$\n  - $(1.0, 5.0, 10.0, 0.5, 0.7, 0.10, 0.09)$\n  - $(1.0, 20.0, 20.0, 1.0, 1.18, 0.04, 0.04)$\n  - $(1.0, 10.0, 10.0, 0.2, 0.45, 0.08, 0.10)$\n  - $(1.0, 30.0, 40.0, 3.0, 3.25, 0.05, 0.07)$\n- 数据集 3 (主恒星质量可变，预计 $\\mathcal{G}_{\\mathrm{small}}$ 组表现出更高的偏心率):\n  - $(0.8, 300.0, 200.0, 1.0, 1.3, 0.25, 0.22)$\n  - $(0.8, 260.0, 300.0, 5.0, 5.3, 0.35, 0.30)$\n  - $(0.8, 100.0, 80.0, 0.5, 0.62, 0.15, 0.12)$\n  - $(0.8, 10.0, 10.0, 0.2, 0.45, 0.03, 0.04)$\n  - $(0.8, 20.0, 30.0, 0.9, 1.8, 0.06, 0.07)$\n- 数据集 4 (边缘案例：所有行星对的 $\\Delta  10$，因此 $\\mathcal{G}_{\\mathrm{small}}$ 为空；必须返回 $\\mathrm{False}$):\n  - $(1.0, 5.0, 6.0, 0.3, 0.9, 0.12, 0.08)$\n  - $(1.2, 8.0, 7.0, 1.5, 3.0, 0.14, 0.10)$\n  - $(0.9, 4.0, 5.0, 0.1, 0.3, 0.05, 0.07)$\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含四个数据集的布尔结果，形式为方括号内的逗号分隔列表，例如 $[\\mathrm{True},\\mathrm{False},\\mathrm{True},\\mathrm{False}]$。输出值为纯布尔值，没有单位。",
            "solution": "问题陈述已经过严格验证，被认为是自洽的、有科学依据且定义明确的。所有数据、公式和步骤均已提供，从而可以得出一个唯一且可验证的解。我们将开始进行分析。\n\n目标是针对几组系外行星对数据集，确定具有小轨道间距的系统是否表现出统计上显著更高的偏心率，这可能是过去动力学散射事件的一个潜在标志。这包括计算以相互希尔半径为单位的归一化间距 $\\Delta$ 和一个行星对偏心率度量 $e_{\\mathrm{pair}}$，然后对两组系统进行统计比较。\n\n方法如下：\n\n1.  对于每个行星对 $(M_\\star, m_1, m_2, a_1, a_2, e_1, e_2)$，我们首先计算行星对偏心率度量 $e_{\\mathrm{pair}}$，它被定义为两个行星偏心率中的最大值：\n    $$e_{\\mathrm{pair}} = \\max(e_1, e_2)$$\n\n2.  接下来，我们计算归一化间距 $\\Delta$。这需要用到相互希尔半径 $R_{\\mathrm{H}}$。行星质量以地球质量 ($M_{\\oplus}$) 给出，必须使用给定的关系式 $1\\,M_{\\oplus} = 3.003 \\times 10^{-6}\\,M_{\\odot}$ 将其转换为太阳质量 ($M_{\\odot}$)。设以太阳质量为单位的质量为 $M_{1, \\odot}$ 和 $M_{2, \\odot}$。\n    那么相互希尔半径为：\n    $$R_{\\mathrm{H}} = \\frac{a_1+a_2}{2} \\left(\\frac{M_{1, \\odot} + M_{2, \\odot}}{3 M_\\star}\\right)^{1/3}$$\n\n3.  有了 $R_{\\mathrm{H}}$，归一化间距 $\\Delta$ 的计算如下：\n    $$\\Delta = \\frac{a_2 - a_1}{R_{\\mathrm{H}}}$$\n\n4.  根据 $\\Delta$ 的值，每对行星被分配到两组中的一组：\n    -   $\\mathcal{G}_{\\mathrm{small}} = \\{ \\text{行星对} : \\Delta \\le 10 \\}$\n    -   $\\mathcal{G}_{\\mathrm{large}} = \\{ \\text{行星对} : \\Delta  10 \\}$\n    与这些组对应的 $e_{\\mathrm{pair}}$ 值集合将分别表示为 $E_{\\mathrm{small}}$ 和 $E_{\\mathrm{large}}$。\n\n5.  分析的核心是一个统计检验。问题规定了每个数据集的布尔输出基于一个两部分条件。当且仅当以下两个条件都满足时，返回结果 $\\mathrm{True}$：\n    -   小间距组中偏心率的算术平均值严格大于大间距组的算术平均值：$\\mathrm{mean}(E_{\\mathrm{small}})  \\mathrm{mean}(E_{\\mathrm{large}})$。\n    -   单边 Mann-Whitney U (MWU) 检验，用于检验备择假设，即 $E_{\\mathrm{small}}$ 的分布随机性地大于 $E_{\\mathrm{large}}$ 的分布，得出的 $p$ 值严格小于 0.05。\n\n6.  作为一个边界条件，如果对于一个给定的数据集，$\\mathcal{G}_{\\mathrm{small}}$ 或 $\\mathcal{G}_{\\mathrm{large}}$ 中任何一个为空，则该数据集的结果立即为 $\\mathrm{False}$。\n\n让我们对数据集 1 进行详细分析以说明此过程。该数据集包含 6 对行星。\n\n-   行星对 1: $(1.0, 300.0, 200.0, 0.9, 1.3, 0.15, 0.20)$\n    $m_1 + m_2 = 500.0\\,M_\\oplus = 1.5015 \\times 10^{-3}\\,M_\\odot$。\n    $R_{\\mathrm{H}} = \\frac{0.9+1.3}{2} (\\frac{1.5015 \\times 10^{-3}}{3 \\times 1.0})^{1/3} \\approx 0.0873\\,\\text{AU}$。\n    $\\Delta = \\frac{1.3-0.9}{0.0873} \\approx 4.58$。由于 $\\Delta \\le 10$，该行星对属于 $\\mathcal{G}_{\\mathrm{small}}$。\n    $e_{\\mathrm{pair}} = \\max(0.15, 0.20) = 0.20$。\n\n-   行星对 5: $(1.0, 260.0, 300.0, 5.0, 5.3, 0.35, 0.30)$\n    $m_1 + m_2 = 560.0\\,M_\\oplus = 1.68168 \\times 10^{-3}\\,M_\\odot$。\n    $R_{\\mathrm{H}} = \\frac{5.0+5.3}{2} (\\frac{1.68168 \\times 10^{-3}}{3 \\times 1.0})^{1/3} \\approx 0.3040\\,\\text{AU}$。\n    $\\Delta = \\frac{5.3-5.0}{0.3040} \\approx 0.99$。由于 $\\Delta \\le 10$，该行星对属于 $\\mathcal{G}_{\\mathrm{small}}$。\n    $e_{\\mathrm{pair}} = \\max(0.35, 0.30) = 0.35$。\n\n将此过程应用于数据集 1 中的所有行星对，得出以下划分：\n-   $E_{\\mathrm{small}} = \\{0.20, 0.15, 0.35\\}$ 来自 $\\Delta \\approx \\{4.58, 3.71, 0.99\\}$ 的行星对。\n-   $E_{\\mathrm{large}} = \\{0.03, 0.05, 0.08\\}$ 来自 $\\Delta \\approx \\{30.71, 30.62, 19.10\\}$ 的行星对。\n\n现在，我们应用判定准则：\n-   $\\mathrm{mean}(E_{\\mathrm{small}}) = (0.20+0.15+0.35)/3 \\approx 0.233$。\n-   $\\mathrm{mean}(E_{\\mathrm{large}}) = (0.03+0.05+0.08)/3 \\approx 0.053$。\n条件 $\\mathrm{mean}(E_{\\mathrm{small}})  \\mathrm{mean}(E_{\\mathrm{large}})$ 得到满足。\n\n-   接下来，我们对 $E_{\\mathrm{small}}$ 和 $E_{\\mathrm{large}}$ 执行单边 Mann-Whitney U 检验。对于这两个大小分别为 $n_1=3$ 和 $n_2=3$ 的样本，数据按秩完美分离，这代表了最极端可能的结果。排列这 6 个组合样本的方式有 $\\binom{6}{3} = 20$ 种。观察到的极端情况只发生一次。因此，对于这个最极端结果，精确的单尾 $p$ 值为 $p = 1/20 = 0.05$。\n\n判定规则要求 $p$ 值严格小于 0.05。由于我们计算出的 $p$ 值为 0.05，因此条件 $p  0.05$ 未被满足。因此，数据集 1 的结果是 $\\mathrm{False}$。\n\n这里一个关键的见解是，对于某些小样本量，要在数学上获得小于传统显著性水平 $\\alpha = 0.05$ 的 $p$ 值是不可能的。对于样本量为 (3, 3) 的情况，最小可能 $p$ 值为 0.05。对于数据集 3，样本量为 (3, 2)，最小可能 $p$ 值为 $1/\\binom{5}{2} = 0.1$。在这些情况下，无论数据分离得多开，都无法在指定的显著性水平上拒绝原假设。这种统计功效的缺乏是数据点数量过少的直接后果。\n\n所有数据集的最终布尔结果都是通过严格遵守指定程序得出的。\n-   **数据集 1:** 结果为 $\\mathrm{False}$ ($p=0.05$，不满足 $p  0.05$)。\n-   **数据集 2:** 结果为 $\\mathrm{False}$ (均值条件不满足：$0.047 \\ngtr 0.1$)。\n-   **数据集 3:** 结果为 $\\mathrm{False}$ ($p=0.1$，不满足 $p  0.05$)。\n-   **数据集 4:** 结果为 $\\mathrm{False}$ ($\\mathcal{G}_{\\mathrm{small}}$ 为空)。\n\n因此，基于对所述规则的严格应用，没有一个数据集满足获得 $\\mathrm{True}$ 结果的标准。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import mannwhitneyu\n\ndef solve():\n    \"\"\"\n    Main function to process datasets and print results.\n    \"\"\"\n    \n    # Conversion constant from Earth mass to Solar mass.\n    M_EARTH_TO_SOLAR = 3.003e-6\n\n    # Test suite of four datasets.\n    # Each tuple represents a planetary pair:\n    # (M_star, m1, m2, a1, a2, e1, e2)\n    # M_star in Solar masses, m1/m2 in Earth masses, a1/a2 in AU.\n    test_suite = [\n        # Dataset 1\n        [\n            (1.0, 300.0, 200.0, 0.9, 1.3, 0.15, 0.20),\n            (1.0, 100.0, 80.0, 0.5, 0.62, 0.12, 0.15),\n            (1.0, 5.0, 5.0, 0.3, 0.6, 0.03, 0.02),\n            (1.0, 10.0, 12.0, 1.0, 2.5, 0.04, 0.05),\n            (1.0, 260.0, 300.0, 5.0, 5.3, 0.35, 0.30),\n            (1.0, 20.0, 30.0, 0.9, 1.8, 0.06, 0.08),\n        ],\n        # Dataset 2\n        [\n            (1.0, 5.0, 5.0, 0.8925, 1.1075, 0.02, 0.03),\n            (1.0, 5.0, 10.0, 0.5, 0.7, 0.10, 0.09),\n            (1.0, 20.0, 20.0, 1.0, 1.18, 0.04, 0.04),\n            (1.0, 10.0, 10.0, 0.2, 0.45, 0.08, 0.10),\n            (1.0, 30.0, 40.0, 3.0, 3.25, 0.05, 0.07),\n        ],\n        # Dataset 3\n        [\n            (0.8, 300.0, 200.0, 1.0, 1.3, 0.25, 0.22),\n            (0.8, 260.0, 300.0, 5.0, 5.3, 0.35, 0.30),\n            (0.8, 100.0, 80.0, 0.5, 0.62, 0.15, 0.12),\n            (0.8, 10.0, 10.0, 0.2, 0.45, 0.03, 0.04),\n            (0.8, 20.0, 30.0, 0.9, 1.8, 0.06, 0.07),\n        ],\n        # Dataset 4\n        [\n            (1.0, 5.0, 6.0, 0.3, 0.9, 0.12, 0.08),\n            (1.2, 8.0, 7.0, 1.5, 3.0, 0.14, 0.10),\n            (0.9, 4.0, 5.0, 0.1, 0.3, 0.05, 0.07),\n        ],\n    ]\n\n    def process_dataset(dataset):\n        \"\"\"\n        Processes a single dataset of planetary pairs.\n        \"\"\"\n        e_pair_small = []\n        e_pair_large = []\n\n        for pair in dataset:\n            m_star, m1_earth, m2_earth, a1, a2, e1, e2 = pair\n\n            # Convert planet masses to Solar masses\n            m1_solar = m1_earth * M_EARTH_TO_SOLAR\n            m2_solar = m2_earth * M_EARTH_TO_SOLAR\n            \n            # Calculate mutual Hill radius\n            mass_ratio_term = (m1_solar + m2_solar) / (3 * m_star)\n            r_hill = ((a1 + a2) / 2) * (mass_ratio_term**(1/3))\n\n            # Calculate normalized separation, avoiding division by zero\n            if r_hill == 0:\n                # This case shouldn't happen with given data but is good practice\n                delta = float('inf')\n            else:\n                delta = (a2 - a1) / r_hill\n            \n            # Calculate pair-level eccentricity\n            e_pair = max(e1, e2)\n\n            # Partition the pair into groups based on delta\n            if delta = 10:\n                e_pair_small.append(e_pair)\n            else:\n                e_pair_large.append(e_pair)\n        \n        # If either group is empty, the result is False\n        if not e_pair_small or not e_pair_large:\n            return False\n\n        # Convert lists to numpy arrays for mean calculation\n        e_small_np = np.array(e_pair_small)\n        e_large_np = np.array(e_pair_large)\n\n        # Check if the mean of the small group is greater than the large group\n        mean_condition = np.mean(e_small_np) > np.mean(e_large_np)\n        \n        # Perform one-sided Mann-Whitney U test\n        # alternative='greater' tests if x is stochastically larger than y\n        try:\n            _, p_value = mannwhitneyu(e_small_np, e_large_np, alternative='greater')\n        except ValueError:\n            # This can happen if all values in one sample are the same,\n            # though not the case with the given test data.\n            return False\n\n        # The p-value must be strictly less than 0.05\n        p_value_condition = p_value  0.05\n\n        # Return True only if both conditions are met\n        return mean_condition and p_value_condition\n\n    results = [process_dataset(ds) for ds in test_suite]\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "前两项练习都依赖于N体模拟产生的数据，而这项最终实践将深入探讨这些模拟得以精确执行的核心机制。你将设计并实现一个自适应时间步长算法，以确保在行星近距离接触这种驱动动力学不稳定性的关键事件中，系统的总能量能够得到精确守恒。通过这项练习，你将洞悉整个行星散射研究领域的数值计算基础。",
            "id": "4169745",
            "problem": "您的任务是为由一颗中心恒星和两颗相互引力作用的行星组成的平面三体系统，构建并评估一个自适应时间步长方案。其科学目标是避免在行星间的近距离交会和近心点通过期间出现人为的能量漂移，这是研究行星-行星散射和动力学不稳定性时的一个常见挑战。您的程序必须实现一种算法，该算法根据近心点通过和交会尺度来评估时间步长标准，并使用子步长来确保数值稳健性。\n\n推导和算法设计所允许的基本依据包括牛顿运动定律、牛顿引力、运动学以及经过充分检验的中心势场下二体运动的轨道根数关系。\n\n使用以下定义和约束：\n\n- 单位：长度单位为天文单位 (AU)，质量单位为太阳质量，时间单位为年，速度单位为 AU/年，角度单位为弧度。在这些单位下，引力常数为 $G = 4\\pi^2$。\n- 质量为 $M_\\star$ 的中心恒星固定在原点不动。两颗质量分别为 $m_1$ 和 $m_2$ 的行星在恒星的引力势以及它们之间的相互引力作用下运动。\n- 令 $\\mathbf{r}_i$ 和 $\\mathbf{v}_i$ 表示行星 $i$ 相对于恒星的位置和速度，其中 $i \\in \\{1,2\\}$。两行星间的距离和相对速度分别为 $r_{12} = \\|\\mathbf{r}_2 - \\mathbf{r}_1\\|$ 和 $v_{\\mathrm{rel}} = \\|\\mathbf{v}_2 - \\mathbf{v}_1\\|$。\n- 使用速度 Verlet 方案进行积分。在一个大小为 $\\Delta t_{\\max}$ 的基本时间间隔上，按如下方式设计自适应子步长方案：\n  1. 对于每个行星 $i$，使用瞬时状态 $(\\mathbf{r}_i,\\mathbf{v}_i)$，假设恒星为点质量势，计算其与恒星的密切二体轨道根数。比轨道能量为 $\\varepsilon_i = \\frac{1}{2}\\|\\mathbf{v}_i\\|^2 - \\frac{G M_\\star}{\\|\\mathbf{r}_i\\|}$，比角动量大小为 $L_i = \\|\\mathbf{r}_i \\times \\mathbf{v}_i\\|$，偏心率为 $e_i = \\sqrt{1 + \\frac{2 \\varepsilon_i L_i^2}{(G M_\\star)^2}}$，对于 $\\varepsilon_i  0$ 的束缚运动，半长轴为 $a_i = -\\frac{G M_\\star}{2\\varepsilon_i}$。定义近心点距离 $q_i = a_i(1-e_i)$ 和近心点速度 $v_{\\mathrm{peri},i} = \\sqrt{G M_\\star \\left(\\frac{2}{q_i} - \\frac{1}{a_i}\\right)}$。近心点通过时标为 $t_{\\mathrm{peri},i} = \\frac{q_i}{v_{\\mathrm{peri},i}}$。如果 $\\varepsilon_i \\ge 0$ 或 $e_i \\ge 1$（非束缚或抛物线/双曲线轨道），则用局域动力学时标 $t_{\\mathrm{dyn},i} = \\sqrt{\\frac{\\|\\mathbf{r}_i\\|^3}{G M_\\star}}$ 替代 $t_{\\mathrm{peri},i}$。\n  2. 定义交会时标 $t_{\\mathrm{enc}} = \\frac{r_{12}}{\\max(v_{\\mathrm{rel}}, \\delta_v)}$，其中 $\\delta_v$ 是一个小的下限值，以避免除以零。\n  3. 定义每个行星的加速度时标 $t_{\\mathrm{acc},i} = \\frac{\\|\\mathbf{v}_i\\|}{\\|\\mathbf{a}_i\\|}$，其中 $\\mathbf{a}_i$ 是来自恒星和另一颗行星的总加速度。\n  4. 目标子步长为\n     $$\\Delta t_{\\mathrm{target}} = \\min\\left(\\eta_{\\mathrm{peri}} \\min_i t_{\\mathrm{peri},i},\\ \\eta_{\\mathrm{enc}} t_{\\mathrm{enc}},\\ \\eta_{\\mathrm{acc}} \\min_i t_{\\mathrm{acc},i},\\ \\Delta t_{\\mathrm{step}}\\right),$$\n     其中 $\\Delta t_{\\mathrm{step}}$ 是当前的基本步长大小（除了可能是最后一个部分步长外，等于 $\\Delta t_{\\max}$），而 $\\eta_{\\mathrm{peri}}, \\eta_{\\mathrm{enc}}, \\eta_{\\mathrm{acc}}$ 是严格介于 $0$ 和 $1$ 之间的无量纲安全因子。\n  5. 如果 $\\Delta t_{\\mathrm{target}}  \\Delta t_{\\mathrm{step}}$，则执行 $N_{\\mathrm{sub}} = \\left\\lceil \\frac{\\Delta t_{\\mathrm{step}}}{\\Delta t_{\\mathrm{target}}} \\right\\rceil$ 个大小为 $\\Delta t_{\\mathrm{sub}} = \\frac{\\Delta t_{\\mathrm{step}}}{N_{\\mathrm{sub}}}$ 的子步长。否则，执行一个大小为 $\\Delta t_{\\mathrm{step}}$ 的单步。\n\n行星 $i$ 的引力加速度为\n$$\n\\mathbf{a}_i = -\\frac{G M_\\star}{\\|\\mathbf{r}_i\\|^3}\\mathbf{r}_i + \\sum_{j\\ne i} G m_j \\frac{\\mathbf{r}_j - \\mathbf{r}_i}{\\|\\mathbf{r}_j - \\mathbf{r}_i\\|^3}.\n$$\n\n将双行星系统的总能量定义为\n$$\nE = \\sum_{i=1}^{2} \\frac{1}{2} m_i \\|\\mathbf{v}_i\\|^2 - \\sum_{i=1}^{2} \\frac{G M_\\star m_i}{\\|\\mathbf{r}_i\\|} - \\frac{G m_1 m_2}{\\|\\mathbf{r}_2 - \\mathbf{r}_1\\|}.\n$$\n计算能量的分数漂移 $\\delta = \\frac{|E(T) - E(0)|}{|E(0)|}$，这是一个无量纲量。\n\n实现两种积分模式：\n- 一个恒定时间步长模式，使用固定的 $\\Delta t_{\\max}$ 且不进行子步长。\n- 上文描述的自适应子步长模式。\n\n对下方的每个测试用例分别模拟两次（恒定和自适应），并为每个用例输出一个列表 $[\\delta_{\\mathrm{const}}, \\delta_{\\mathrm{adapt}}, b]$，其中 $b$ 是一个布尔值，指示自适应模式是否既将漂移相对于恒定模式减少了至少10倍，又达到了等于或低于指定阈值的绝对漂移。所有用例的结果必须汇总到单行打印，形式为一个逗号分隔的列表，并用方括号括起来，其中每个用例的结果本身也用方括号括起来，例如 $[[x_1,y_1,z_1],[x_2,y_2,z_2],[x_3,y_3,z_3]]$。\n\n角度单位要求：如果出现角度，用弧度度量。\n\n所有磁学或物理量必须严格使用上述指定单位表示。所有输出均为定义的无量纲浮点数或布尔值。\n\n用于覆盖理想路径、交会驱动自适应性和近心点驱动自适应性的测试套件和参数：\n\n- 用例 A（间距大、近圆形轨道）：\n  - $M_\\star = 1$。\n  - $m_1 = 1\\times 10^{-3}$, $m_2 = 3\\times 10^{-4}$。\n  - 初始位置和速度：$\\mathbf{r}_1(0) = (1, 0)$, $\\mathbf{v}_1(0) = (0, 2\\pi)$；$\\mathbf{r}_2(0) = (1.8, 0)$, $\\mathbf{v}_2(0) = \\left(0, \\frac{2\\pi}{\\sqrt{1.8}}\\right)$。\n  - 总模拟时间 $T = 5$。\n  - 基本步长 $\\Delta t_{\\max} = 0.01$。\n  - 安全因子 $\\eta_{\\mathrm{peri}} = 0.05$, $\\eta_{\\mathrm{enc}} = 0.05$, $\\eta_{\\mathrm{acc}} = 0.2$。\n  - 用于布尔决策的阈值 $= 1\\times 10^{-6}$。\n\n- 用例 B（近距离共轨分离以触发交会细化）：\n  - $M_\\star = 1$。\n  - $m_1 = 1\\times 10^{-3}$, $m_2 = 1\\times 10^{-3}$。\n  - 初始位置和速度：$\\mathbf{r}_1(0) = (1.00, 0)$, $\\mathbf{v}_1(0) = (0, 2\\pi)$；$\\mathbf{r}_2(0) = (1.05, 0)$, $\\mathbf{v}_2(0) = \\left(0, \\frac{2\\pi}{\\sqrt{1.05}}\\right)$。\n  - 总模拟时间 $T = 0.5$。\n  - 基本步长 $\\Delta t_{\\max} = 0.01$。\n  - 安全因子 $\\eta_{\\mathrm{peri}} = 0.05$, $\\eta_{\\mathrm{enc}} = 0.05$, $\\eta_{\\mathrm{acc}} = 0.2$。\n  - 用于布尔决策的阈值 $= 1\\times 10^{-6}$。\n\n- 用例 C（高偏心率近心点通过细化）：\n  - $M_\\star = 1$。\n  - $m_1 = 3\\times 10^{-6}$, $m_2 = 1\\times 10^{-3}$。\n  - 对于行星1，目标密切轨道根数值为 $a_1 = 0.5$, $e_1 = 0.8$，因此 $q_1 = 0.1$。在近心点进行初始化：$\\mathbf{r}_1(0) = (0.1, 0)$ 和 $\\mathbf{v}_1(0) = (0, v_{\\mathrm{peri},1})$，其中 $v_{\\mathrm{peri},1} = \\sqrt{G M_\\star \\left(\\frac{2}{q_1} - \\frac{1}{a_1}\\right)}$。\n  - 对于行星2，在远处进行圆形轨道初始化：$\\mathbf{r}_2(0) = (5, 0)$, $\\mathbf{v}_2(0) = \\left(0, \\frac{2\\pi}{\\sqrt{5}}\\right)$。\n  - 总模拟时间 $T = 1$。\n  - 基本步长 $\\Delta t_{\\max} = 0.01$。\n  - 安全因子 $\\eta_{\\mathrm{peri}} = 0.05$, $\\eta_{\\mathrm{enc}} = 0.05$, $\\eta_{\\mathrm{acc}} = 0.2$。\n  - 用于布尔决策的阈值 $= 1\\times 10^{-6}$。\n\n您的程序应生成单行输出，其中包含用例 A、用例 B 和用例 C 的结果，形式为一个逗号分隔的列表，并用方括号括起来，其中每个用例的结果是一个列表 $[\\delta_{\\mathrm{const}}, \\delta_{\\mathrm{adapt}}, b]$，布尔值 $b$ 的定义如上。布尔值应以 Python 期望的小写形式（即 true 或 false）打印。",
            "solution": "我们从点质量的牛顿第二定律和牛顿引力定律开始。设质量为 $M_\\star$ 的中心恒星固定在原点，两颗质量分别为 $m_1$ 和 $m_2$ 的行星在包含恒星-行星和行星-行星相互作用的组合势场中运动。平面运动是足够的，因此我们在二维空间中进行计算。\n\n行星 $i$ 的加速度由下式给出\n$$\n\\mathbf{a}_i = -\\frac{G M_\\star}{\\|\\mathbf{r}_i\\|^3}\\mathbf{r}_i + \\sum_{j\\ne i} G m_j \\frac{\\mathbf{r}_j - \\mathbf{r}_i}{\\|\\mathbf{r}_j - \\mathbf{r}_i\\|^3}.\n$$\n这直接源于牛顿万有引力定律和力的叠加原理。\n\n我们使用速度 Verlet 方案进行积分，对于一个时间步长 $\\Delta t$，它通过以下方式将状态从 $(\\mathbf{r}_i^n,\\mathbf{v}_i^n)$ 更新到 $(\\mathbf{r}_i^{n+1},\\mathbf{v}_i^{n+1})$：\n$$\n\\mathbf{v}_i^{n+\\frac{1}{2}} = \\mathbf{v}_i^{n} + \\frac{1}{2}\\mathbf{a}_i^n \\Delta t, \\quad\n\\mathbf{r}_i^{n+1} = \\mathbf{r}_i^{n} + \\mathbf{v}_i^{n+\\frac{1}{2}} \\Delta t, \\quad\n\\mathbf{a}_i^{n+1} = \\mathbf{a}_i(\\mathbf{r}_1^{n+1},\\mathbf{r}_2^{n+1}), \\quad\n\\mathbf{v}_i^{n+1} = \\mathbf{v}_i^{n+\\frac{1}{2}} + \\frac{1}{2}\\mathbf{a}_i^{n+1}\\Delta t.\n$$\n该积分器是二阶精确且时间可逆的，在恒定时间步长下具有良好的能量保持特性。然而，在近距离交会或近心点附近，加速度和速度变化迅速，固定的时间步长会引发显著的数值能量漂移。\n\n我们设计一个与问题陈述一致的自适应子步长方案。其核心思想是在大部分演化过程中保持一个近乎恒定的顶层时间步长 $\\Delta t_{\\max}$，以避免会破坏速度 Verlet 方案近辛性质的大幅、频繁的步长变化，但在局域时标要求更小步长时允许进行细化。因此，我们在每个基本时间间隔 $\\Delta t_{\\mathrm{step}}$ 的开始计算以下时标：\n\n1. 每个行星 $i$ 相对于恒星的近心点通过时标。我们将恒星-行星相互作用视为一个二体问题，从瞬时位置和速度获得密切轨道根数。这是天体力学中弱扰动下一种广泛使用的物理近似。比能量为 $\\varepsilon_i = \\frac{1}{2}\\|\\mathbf{v}_i\\|^2 - \\frac{G M_\\star}{\\|\\mathbf{r}_i\\|}$，比角动量大小为 $L_i = \\|\\mathbf{r}_i \\times \\mathbf{v}_i\\|$。偏心率为\n$$\ne_i = \\sqrt{1 + \\frac{2 \\varepsilon_i L_i^2}{(G M_\\star)^2}},\n$$\n对于束缚运动（$\\varepsilon_i0$），半长轴为 $a_i = -\\frac{G M_\\star}{2\\varepsilon_i}$。近心点距离为 $q_i = a_i(1-e_i)$，近心点速度为 $v_{\\mathrm{peri},i} = \\sqrt{G M_\\star \\left(\\frac{2}{q_i} - \\frac{1}{a_i}\\right)}$。近心点时标为 $t_{\\mathrm{peri},i} = \\frac{q_i}{v_{\\mathrm{peri},i}}$，它估算了穿越近心点区域所需的时间。如果密切轨道解是非束缚或退化的（$\\varepsilon_i\\ge 0$ 或 $e_i\\ge 1$），我们回退到使用局域动力学时标 $t_{\\mathrm{dyn},i} = \\sqrt{\\frac{\\|\\mathbf{r}_i\\|^3}{G M_\\star}}$。\n\n2. 行星-行星交会时标 $t_{\\mathrm{enc}} = \\frac{r_{12}}{v_{\\mathrm{rel}}}$，其中 $r_{12} = \\|\\mathbf{r}_2 - \\mathbf{r}_1\\|$ 且 $v_{\\mathrm{rel}} = \\|\\mathbf{v}_2 - \\mathbf{v}_1\\|$。如果 $v_{\\mathrm{rel}}$ 极小，则将其设置为一个下限值 $\\delta_v$ 以避免奇异行为；这确保了细化仅在实际接近发生时才被驱动。\n\n3. 每个行星的加速度时标 $t_{\\mathrm{acc},i} = \\frac{\\|\\mathbf{v}_i\\|}{\\|\\mathbf{a}_i\\|}$，它估算了速度发生显著变化所需的时间。这个时标在近心点和近距离交会期间特别敏感，因为此时 $|\\mathbf{a}_i|$ 很大。\n\n我们将这些时标与安全因子 $\\eta_{\\mathrm{peri}}$、$\\eta_{\\mathrm{enc}}$ 和 $\\eta_{\\mathrm{acc}}$ 结合，以设定目标子步长：\n$$\n\\Delta t_{\\mathrm{target}} = \\min\\left(\\eta_{\\mathrm{peri}} \\min_i t_{\\mathrm{peri},i},\\ \\eta_{\\mathrm{enc}} t_{\\mathrm{enc}},\\ \\eta_{\\mathrm{acc}} \\min_i t_{\\mathrm{acc},i},\\ \\Delta t_{\\mathrm{step}}\\right).\n$$\n如果 $\\Delta t_{\\mathrm{target}}$ 小于当前的基本步长 $\\Delta t_{\\mathrm{step}}$，我们使用 $N_{\\mathrm{sub}} = \\left\\lceil \\Delta t_{\\mathrm{step}} / \\Delta t_{\\mathrm{target}} \\right\\rceil$ 个大小为 $\\Delta t_{\\mathrm{sub}} = \\Delta t_{\\mathrm{step}} / N_{\\mathrm{sub}}$ 的子步长。否则，我们用 $\\Delta t_{\\mathrm{step}}$ 执行一次速度 Verlet 更新。这种子步长方法在实现局域细化的同时，保持了外部步长的近似恒定。与任意可变时间步长相比，在固定的基本间隔内进行子步长可以减少对时间对称性的潜在破坏，并减轻能量漂移。\n\n为衡量能量行为，我们计算总能量\n$$\nE = \\sum_{i=1}^{2} \\frac{1}{2} m_i \\|\\mathbf{v}_i\\|^2 - \\sum_{i=1}^{2} \\frac{G M_\\star m_i}{\\|\\mathbf{r}_i\\|} - \\frac{G m_1 m_2}{\\|\\mathbf{r}_2 - \\mathbf{r}_1\\|}\n$$\n在 $t=0$ 和 $t=T$ 时的值，并报告分数漂移 $\\delta = \\frac{|E(T) - E(0)|}{|E(0)|}$。我们对每个用例运行恒定时间步长模式和自适应子步长模式。每个用例的布尔输出为 $b = \\left(\\delta_{\\mathrm{adapt}} \\le \\mathrm{threshold}\\right) \\wedge \\left(\\delta_{\\mathrm{adapt}} \\le \\delta_{\\mathrm{const}} / 10\\right)$，量化了绝对控制和相对改进。\n\n我们现在阐明这些时标及其作用：\n\n- 近心点时标 $t_{\\mathrm{peri}}$ 的出现是因为根据角动量和能量守恒定律，在逆平方律势场中，速度在近心点达到峰值。位置的快速变化需要更小的时间步长来准确捕捉曲率并避免大的积分误差。\n- 交会时标 $t_{\\mathrm{enc}}$ 是相对速度对行星间距的平流时间。由于近距离交会会导致强烈的相互加速度和急剧的偏转，当 $r_{12}$ 变小或 $v_{\\mathrm{rel}}$ 显著时，$\\eta_{\\mathrm{enc}} t_{\\mathrm{enc}}$ 会设定一个细化。\n- 加速度时标 $t_{\\mathrm{acc}}$ 源于 $v = \\mathrm{d}x/\\mathrm{d}t$ 和 $\\mathrm{d}v/\\mathrm{d}t = a$。如果 $|\\mathbf{a}|$ 很大，速度变化迅速，减小 $\\Delta t$ 可以使速度 Verlet 的局部截断误差 $O(\\Delta t^3)$ 保持有界。\n\n安全因子 $\\eta$ 强制留出一个余量，使得子步长是最小相关时标的一个保守分数，从而减少细化过程中的振荡并确保稳定性。\n\n对于三个测试用例：\n\n- 用例 A 提供了一个理想路径，其中相互扰动弱、运动近圆形、间距大。能量漂移本身应该很小，自适应性产生的性能相当或略有改善。\n- 用例 B 通过将两个木星质量的行星置于几乎共轨的半径和对齐的方位角上，来测试由交会驱动的自适应性。这会迅速引发强烈的相互作用。没有自适应性，固定的时间步长会累积误差；自适应性则在交会过程中进行细化。\n- 用例 C 测试由近心点驱动的自adaptive性，其中一颗高偏心率的地球质量行星在近心点初始化，而一颗外部的木星质量行星在远处。近心点时标很短，需要细化以避免大的能量误差。\n\n程序实现了这些原理，计算了所需的输出，并按规定格式将汇总列表打印在单行上。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Constants in AU, yr, solar masses\nG = 4.0 * np.pi**2  # AU^3 / (yr^2 * M_sun)\n\ndef accel_planets(r, m, Mstar):\n    \"\"\"\n    Compute accelerations on two planets due to the fixed star and mutual gravity.\n    r: array shape (2, 2) of positions [ [x1,y1], [x2,y2] ]\n    m: array shape (2,) masses of planets\n    Mstar: scalar star mass\n    Returns accelerations array shape (2, 2)\n    \"\"\"\n    a = np.zeros_like(r)\n    for i in range(2):\n        ri = r[i]\n        ri_norm = np.linalg.norm(ri)\n        # Star contribution\n        if ri_norm > 0:\n            a[i] += -(G * Mstar / (ri_norm**3)) * ri\n        # Mutual planet-planet contribution\n        j = 1 - i\n        rij = r[j] - ri\n        d = np.linalg.norm(rij)\n        if d > 0:\n            a[i] += G * m[j] * rij / (d**3)\n    return a\n\ndef total_energy(r, v, m, Mstar):\n    \"\"\"\n    Compute total energy (kinetic + potential) of two planets in the fixed star potential and mutual interaction.\n    \"\"\"\n    # Kinetic\n    K = 0.0\n    for i in range(2):\n        K += 0.5 * m[i] * np.dot(v[i], v[i])\n    # Potential with star\n    U_star = 0.0\n    for i in range(2):\n        ri_norm = np.linalg.norm(r[i])\n        if ri_norm > 0:\n            U_star += -G * Mstar * m[i] / ri_norm\n    # Mutual potential\n    rij = r[1] - r[0]\n    d = np.linalg.norm(rij)\n    U_pp = -G * m[0] * m[1] / d if d > 0 else 0.0\n    return K + U_star + U_pp\n\ndef osculating_elements_star(ri, vi, Mstar):\n    \"\"\"\n    Compute osculating semimajor axis a and eccentricity e for a planet relative to the star,\n    treating the motion as a two-body problem with a fixed central mass Mstar.\n    Returns (a, e, bound) where bound is True if epsilon  0 and e  1.\n    \"\"\"\n    r = np.linalg.norm(ri)\n    v2 = np.dot(vi, vi)\n    mu = G * Mstar\n    eps = 0.5 * v2 - mu / r  # specific energy\n    # Specific angular momentum magnitude (2D cross product -> z-component)\n    h = abs(ri[0] * vi[1] - ri[1] * vi[0])\n    e_arg = 1.0 + (2.0 * eps * h**2) / (mu**2)\n    # Numerical safety: clamp tiny negatives due to roundoff\n    e_arg = max(e_arg, 0.0)\n    e = np.sqrt(e_arg)\n    bound = (eps  0.0) and (e  1.0)\n    if bound:\n        a = -mu / (2.0 * eps)\n    else:\n        a = np.nan\n    return a, e, bound\n\ndef pericenter_timescale(ri, vi, Mstar):\n    \"\"\"\n    Compute pericenter passage timescale t_peri for a planet relative to the star.\n    If unbound, return local dynamical timescale sqrt(r^3 / (G Mstar)).\n    \"\"\"\n    a, e, bound = osculating_elements_star(ri, vi, Mstar)\n    r = np.linalg.norm(ri)\n    mu = G * Mstar\n    if bound:\n        q = a * (1.0 - e)\n        # v_peri = sqrt(mu * (2/q - 1/a))\n        v_peri = np.sqrt(mu * (2.0 / q - 1.0 / a))\n        t_peri = q / v_peri\n        return t_peri\n    else:\n        return np.sqrt(r**3 / mu)\n\ndef encounter_timescale(r1, v1, r2, v2, v_floor=1e-10):\n    \"\"\"\n    Encounter timescale t_enc = r12 / max(v_rel, v_floor)\n    \"\"\"\n    rij = r2 - r1\n    r12 = np.linalg.norm(rij)\n    vrel = np.linalg.norm(v2 - v1)\n    vrel = max(vrel, v_floor)\n    return r12 / vrel\n\ndef acceleration_timescale(vi, ai, a_floor=1e-15):\n    \"\"\"\n    Acceleration timescale t_acc = |v| / max(|a|, a_floor)\n    \"\"\"\n    vnorm = np.linalg.norm(vi)\n    anorm = max(np.linalg.norm(ai), a_floor)\n    return vnorm / anorm\n\ndef integrate_system(m, Mstar, r0, v0, T, dt_max, adapt, etas):\n    \"\"\"\n    Integrate the two-planet system for time T with base step dt_max.\n    If adapt is True, perform substepping according to timescales and safety factors etas=(eta_peri, eta_enc, eta_acc).\n    Returns fractional energy drift delta.\n    \"\"\"\n    r = r0.copy()\n    v = v0.copy()\n    E0 = total_energy(r, v, m, Mstar)\n    # Number of base steps\n    n_steps = int(np.ceil(T / dt_max))\n    t = 0.0\n    for step in range(n_steps):\n        # Handle last partial base step\n        dt_step = dt_max if (t + dt_max) = T else (T - t)\n        if adapt:\n            # Compute accelerations at start of base step\n            a = accel_planets(r, m, Mstar)\n            # Timescales\n            t_peri1 = pericenter_timescale(r[0], v[0], Mstar)\n            t_peri2 = pericenter_timescale(r[1], v[1], Mstar)\n            t_enc = encounter_timescale(r[0], v[0], r[1], v[1])\n            t_acc1 = acceleration_timescale(v[0], a[0])\n            t_acc2 = acceleration_timescale(v[1], a[1])\n            eta_peri, eta_enc, eta_acc = etas\n            dt_target = min(eta_peri * min(t_peri1, t_peri2),\n                            eta_enc * t_enc,\n                            eta_acc * min(t_acc1, t_acc2),\n                            dt_step)\n            # Substeps\n            Nsub = int(np.ceil(dt_step / dt_target)) if dt_target > 0 else 1\n            dt_sub = dt_step / Nsub\n            # Perform substeps with velocity Verlet\n            for _ in range(Nsub):\n                a = accel_planets(r, m, Mstar)\n                v_half = v + 0.5 * a * dt_sub\n                r = r + v_half * dt_sub\n                a_new = accel_planets(r, m, Mstar)\n                v = v_half + 0.5 * a_new * dt_sub\n        else:\n            # Single velocity Verlet step of size dt_step\n            a = accel_planets(r, m, Mstar)\n            v_half = v + 0.5 * a * dt_step\n            r = r + v_half * dt_step\n            a_new = accel_planets(r, m, Mstar)\n            v = v_half + 0.5 * a_new * dt_step\n        t += dt_step\n    ET = total_energy(r, v, m, Mstar)\n    delta = abs(ET - E0) / abs(E0) if E0 != 0 else float('inf')\n    return float(delta)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Case A\n    Mstar_A = 1.0\n    m_A = np.array([1e-3, 3e-4], dtype=float)\n    r1_A = np.array([1.0, 0.0], dtype=float)\n    v1_A = np.array([0.0, 2.0*np.pi], dtype=float)\n    r2_A = np.array([1.8, 0.0], dtype=float)\n    v2_A = np.array([0.0, 2.0*np.pi/np.sqrt(1.8)], dtype=float)\n    T_A = 5.0\n    dt_max_A = 0.01\n    etas_A = (0.05, 0.05, 0.2)\n    threshold_A = 1e-6\n\n    # Case B\n    Mstar_B = 1.0\n    m_B = np.array([1e-3, 1e-3], dtype=float)\n    r1_B = np.array([1.00, 0.0], dtype=float)\n    v1_B = np.array([0.0, 2.0*np.pi], dtype=float)\n    r2_B = np.array([1.05, 0.0], dtype=float)\n    v2_B = np.array([0.0, 2.0*np.pi/np.sqrt(1.05)], dtype=float)\n    T_B = 0.5\n    dt_max_B = 0.01\n    etas_B = (0.05, 0.05, 0.2)\n    threshold_B = 1e-6\n\n    # Case C\n    Mstar_C = 1.0\n    m_C = np.array([3e-6, 1e-3], dtype=float)\n    # Planet 1 at pericenter for a=0.5, e=0.8 -> q=0.1\n    q1_C = 0.1\n    a1_C = 0.5\n    vperi1_C = np.sqrt(G * Mstar_C * (2.0/q1_C - 1.0/a1_C))\n    r1_C = np.array([q1_C, 0.0], dtype=float)\n    v1_C = np.array([0.0, vperi1_C], dtype=float)\n    # Planet 2 far, circular at 5 AU\n    r2_C = np.array([5.0, 0.0], dtype=float)\n    v2_C = np.array([0.0, 2.0*np.pi/np.sqrt(5.0)], dtype=float)\n    T_C = 1.0\n    dt_max_C = 0.01\n    etas_C = (0.05, 0.05, 0.2)\n    threshold_C = 1e-6\n\n    test_cases = [\n        # Each case: (Mstar, masses, r_init, v_init, T, dt_max, etas, threshold)\n        (Mstar_A, m_A, np.vstack([r1_A, r2_A]), np.vstack([v1_A, v2_A]), T_A, dt_max_A, etas_A, threshold_A),\n        (Mstar_B, m_B, np.vstack([r1_B, r2_B]), np.vstack([v1_B, v2_B]), T_B, dt_max_B, etas_B, threshold_B),\n        (Mstar_C, m_C, np.vstack([r1_C, r2_C]), np.vstack([v1_C, v2_C]), T_C, dt_max_C, etas_C, threshold_C),\n    ]\n\n    results = []\n    for (Mstar, masses, r_init, v_init, T, dt_max, etas, threshold) in test_cases:\n        # Constant timestep integration\n        delta_const = integrate_system(masses, Mstar, r_init.copy(), v_init.copy(), T, dt_max, adapt=False, etas=etas)\n        # Adaptive substepping integration\n        delta_adapt = integrate_system(masses, Mstar, r_init.copy(), v_init.copy(), T, dt_max, adapt=True, etas=etas)\n        improved = (delta_adapt = threshold) and (delta_adapt = (delta_const / 10.0))\n        results.append([delta_const, delta_adapt, improved])\n\n    # Final print statement in the exact required format.\n    # Python prints booleans as True/False; convert to lowercase 'true'/'false' for strict formatting.\n    def elem_to_str(x):\n        if isinstance(x, bool):\n            return 'true' if x else 'false'\n        else:\n            return str(x)\n    out = \"[\" + \",\".join(\"[\" + \",\".join(elem_to_str(e) for e in case) + \"]\" for case in results) + \"]\"\n    print(out)\n\nsolve()\n```"
        }
    ]
}