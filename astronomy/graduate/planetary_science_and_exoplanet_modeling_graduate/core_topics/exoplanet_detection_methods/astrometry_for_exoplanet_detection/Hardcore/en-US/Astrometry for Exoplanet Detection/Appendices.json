{
    "hands_on_practices": [
        {
            "introduction": "Before delving into complex time-series analysis, a crucial first step in astrometry is to develop an intuition for the scale of the expected signals. This exercise  provides a foundational calculation, grounding the abstract concept of astrometric wobble in the concrete principles of Newtonian two-body mechanics. By calculating the expected reflex motion caused by a stellar companion, you will not only practice fundamental physics but also understand why the amplitude of the signal is a powerful first clue in distinguishing massive stellar companions from their much lighter planetary counterparts.",
            "id": "4152281",
            "problem": "A Sun-like primary star of mass $M_{\\star} = 1.0\\,M_{\\odot}$ hosts a stellar companion of mass $M_{c} = 0.2\\,M_{\\odot}$ on a bound orbit with relative semi-major axis $a_{c} = 10\\,\\mathrm{AU}$, where $\\mathrm{AU}$ denotes the Astronomical Unit. The system is at a distance $d = 50\\,\\mathrm{pc}$ from Earth, where $\\mathrm{pc}$ denotes the parsec. Assume a near-circular orbit and note that, for astrometric measurements, the sky-projected semi-major axis of the primary’s barycentric orbit equals its true semi-major axis. Starting only from Newtonian two-body mechanics and the center-of-mass definition, and using the geometric definition of the parsec (the distance at which $1\\,\\mathrm{AU}$ subtends $1$ arcsecond), derive the expected angular astrometric semi-major axis $\\alpha$ (the primary’s reflex motion on the sky) caused by the companion. Express $\\alpha$ in milliarcseconds (mas), where $\\mathrm{mas}$ denotes milliarcsecond, and round your answer to three significant figures. Then, briefly explain how this amplitude compares to typical planetary astrometric signals around Sun-like stars to illustrate a simple classification criterion that uses a $1\\,\\mathrm{mas}$ demarcation between planetary-scale and stellar-companion-scale astrometric signatures. Your final reported value must be the numerical $\\alpha$ in milliarcseconds.",
            "solution": "The user-provided problem is subjected to validation before proceeding with a solution.\n\n### Step 1: Extract Givens\n- Primary star mass: $M_{\\star} = 1.0\\,M_{\\odot}$\n- Stellar companion mass: $M_{c} = 0.2\\,M_{\\odot}$\n- Relative semi-major axis of the companion's orbit: $a_{c} = 10\\,\\mathrm{AU}$\n- Distance to the system: $d = 50\\,\\mathrm{pc}$\n- Assumption: The orbit is near-circular.\n- Assumption: The sky-projected semi-major axis of the primary’s barycentric orbit equals its true semi-major axis.\n- Definition: The parsec is the distance at which $1\\,\\mathrm{AU}$ subtends an angle of $1$ arcsecond.\n- Task: Derive the angular astrometric semi-major axis $\\alpha$ in milliarcseconds ($\\mathrm{mas}$) and round to three significant figures.\n- Task: Briefly explain the comparison of this amplitude to typical planetary astrometric signals using a $1\\,\\mathrm{mas}$ demarcation.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is assessed for validity based on scientific principles and logical consistency.\n\n- **Scientific Grounding**: The problem is based on fundamental principles of Newtonian two-body mechanics and standard definitions used in astrometry. The physical parameters ($M_{\\star}$, $M_c$, $a_c$, $d$) are entirely realistic for a nearby binary star system.\n- **Well-Posedness**: The problem is well-posed. It provides all necessary data and clearly stated assumptions (circular orbit, favorable projection) to determine a unique solution for the astrometric amplitude $\\alpha$.\n- **Objectivity**: The problem is stated using precise, objective language and quantitative data.\n- **Completeness and Consistency**: The problem is self-contained and free of contradictions. The given data are sufficient and consistent.\n- **Realism**: The conditions and values are physically plausible.\n\n### Step 3: Verdict and Action\nThe problem is deemed **valid**. A solution will be formulated based on the provided information and established physical principles.\n\n### Derivation of the Solution\nThe astrometric signal is the apparent angular motion of the primary star on the celestial sphere. This motion is a reflex of its orbit around the common center of mass (barycenter) of the system it shares with its companion.\n\nFirst, we determine the physical size of the primary star's orbit. The system's barycenter is defined by the relation $M_{\\star}\\vec{r}_{\\star} + M_{c}\\vec{r}_{c} = \\vec{0}$, assuming the barycenter is at the origin of our coordinate system. Here, $\\vec{r}_{\\star}$ and $\\vec{r}_{c}$ are the position vectors of the primary star and the companion, respectively. The relative position vector is defined as $\\vec{r} = \\vec{r}_{c} - \\vec{r}_{\\star}$.\n\nWe can express the primary star's position vector, $\\vec{r}_{\\star}$, in terms of the relative vector $\\vec{r}$. From the barycenter equation, $M_{\\star}\\vec{r}_{\\star} = -M_{c}\\vec{r}_{c}$. Substituting $\\vec{r}_{c} = \\vec{r} + \\vec{r}_{\\star}$ gives:\n$$ M_{\\star}\\vec{r}_{\\star} = -M_{c}(\\vec{r} + \\vec{r}_{\\star}) $$\n$$ (M_{\\star} + M_{c})\\vec{r}_{\\star} = -M_{c}\\vec{r} $$\n$$ \\vec{r}_{\\star} = -\\frac{M_{c}}{M_{\\star} + M_{c}}\\vec{r} $$\nThis equation shows that the primary star orbits the barycenter in a path that is a scaled-down version of the relative orbit of the companion. The semi-major axis of the primary star's orbit, $a_{\\star}$, is therefore related to the relative semi-major axis, $a_{c}$, by the same scaling factor:\n$$ a_{\\star} = \\frac{M_{c}}{M_{\\star} + M_{c}}a_{c} $$\nSubstituting the given mass values:\n$$ a_{\\star} = \\frac{0.2\\,M_{\\odot}}{1.0\\,M_{\\odot} + 0.2\\,M_{\\odot}} a_{c} = \\frac{0.2}{1.2} a_{c} = \\frac{1}{6} a_{c} $$\nGiven $a_{c} = 10\\,\\mathrm{AU}$, the semi-major axis of the primary star's physical orbit is:\n$$ a_{\\star} = \\frac{1}{6} \\times 10\\,\\mathrm{AU} = \\frac{10}{6}\\,\\mathrm{AU} \\approx 1.667\\,\\mathrm{AU} $$\nNext, we calculate the angular size of this orbit as seen from Earth. The problem provides the geometric definition of the parsec, from which the small-angle formula for astrometry is directly derived: an object of size $s$ at a distance $d$ subtends an angle $\\theta$ given by $\\theta_{[\\mathrm{arcsec}]} = \\frac{s_{[\\mathrm{AU}]}}{d_{[\\mathrm{pc}]}}$.\n\nThe angular semi-major axis, $\\alpha$, is the apparent size of the physical semi-major axis $a_{\\star}$ at distance $d$. Applying the formula:\n$$ \\alpha = \\frac{a_{\\star, \\mathrm{AU}}}{d_{\\mathrm{pc}}} $$\nwhere $a_{\\star, \\mathrm{AU}}$ is the value of $a_{\\star}$ in units of $\\mathrm{AU}$ and $d_{\\mathrm{pc}}$ is the distance in $\\mathrm{pc}$.\nSubstituting the values $a_{\\star} = \\frac{10}{6}\\,\\mathrm{AU}$ and $d = 50\\,\\mathrm{pc}$:\n$$ \\alpha = \\frac{10/6}{50} = \\frac{10}{6 \\times 50} = \\frac{1}{30}\\,\\mathrm{arcseconds} $$\nThe problem requires the answer in milliarcseconds ($\\mathrm{mas}$). Since $1\\,\\mathrm{arcsecond} = 1000\\,\\mathrm{mas}$:\n$$ \\alpha = \\frac{1}{30} \\times 1000\\,\\mathrm{mas} = \\frac{100}{3}\\,\\mathrm{mas} \\approx 33.333...\\,\\mathrm{mas} $$\nRounding to three significant figures, we get:\n$$ \\alpha \\approx 33.3\\,\\mathrm{mas} $$\nThis value represents the amplitude of the astrometric wobble of the primary star.\n\n### Comparison to Planetary Signals\nThe calculated astrometric amplitude of $\\alpha \\approx 33.3\\,\\mathrm{mas}$ is significantly larger than the $1\\,\\mathrm{mas}$ threshold mentioned in the problem. This illustrates a key distinction:\nThe amplitude of the astrometric signal, $a_{\\star}$, is directly proportional to the mass of the companion, $M_c$ (for $M_c \\ll M_{\\star}$). Stellar companions, which have masses typically in the range of $0.08\\,M_{\\odot}$ to $1.0\\,M_{\\odot}$, are orders of magnitude more massive than even the most massive gas giant planets (which have masses up to about $0.013\\,M_{\\odot}$). Consequently, a stellar companion induces a much larger reflex motion in the primary star compared to a planet at a similar orbital separation. Planetary astrometric signals are typically in the sub-milliarcsecond ($< 1\\,\\mathrm{mas}$) to microarcsecond ($\\mu\\mathrm{as}$) range for solar-type stars at typical interstellar distances. For instance, Jupiter induces a reflex motion in the Sun with an amplitude of about $0.5\\,\\mathrm{mas}$ as seen from a distance of $10\\,\\mathrm{pc}$. The $1\\,\\mathrm{mas}$ value therefore serves as a useful, albeit approximate, empirical boundary. An astrometrically detected reflex motion significantly exceeding $1\\,\\mathrm{mas}$ is very likely caused by a stellar or brown dwarf companion rather than a planet.",
            "answer": "$$\\boxed{33.3}$$"
        },
        {
            "introduction": "Astrometric measurements are not made in a vacuum; the tiny signal from an exoplanet is superimposed on other effects, most notably the much larger parallax signal from Earth's own orbit around the Sun. This hands-on coding practice  explores this critical challenge by simulating a simplified one-dimensional observation. You will investigate the dangerous degeneracy that occurs when a planet's orbital period $P$ is close to one year, and quantify how fitting a misspecified model can systematically bias the measured stellar parallax $\\varpi$, a vital lesson in the importance of accurate modeling in data analysis.",
            "id": "4152260",
            "problem": "You are to write a complete, runnable program that generates synthetic one-dimensional along-scan astrometric measurements for a star with known true parallax and an orbiting planet, then fits an incorrect single-planet model to these data in order to quantify the resulting bias in the fitted parallax. Your program must compute the parallax bias for a small test suite of cases that explore the degeneracy when the planetary period is close to one year. All modeling and computation must be posed in purely mathematical terms and use physically plausible parameters and units.\n\nBegin from the following fundamental base and definitions.\n\n- Astrometric along-scan displacement is modeled as the sum of a constant position, a linear proper motion, the annual parallax signal due to the Earth's orbit, and the reflex motion induced by a single planet. We adopt a circular Earth orbit and work in an along-scan frame aligned with the ecliptic such that the annual parallax factor is a pure cosine at one-year period.\n\n- The along-scan observation at time $t$ (in years) is\n  $$ y(t) \\;=\\; \\theta_0 \\;+\\; \\mu \\,(t - t_\\mathrm{ref}) \\;+\\; \\varpi_\\mathrm{true} \\, p(t) \\;+\\; a \\,\\cos\\!\\big(\\omega_\\mathrm{true}\\, t + \\phi\\big) \\;+\\; \\varepsilon(t), $$\n  where $t_\\mathrm{ref}$ is a reference epoch in years, $\\theta_0$ is a constant offset in milliarcseconds, $\\mu$ is proper motion in milliarcseconds per year, $\\varpi_\\mathrm{true}$ is the true parallax in milliarcseconds, $p(t)$ is the scalar parallax factor, $a$ is the along-scan reflex amplitude in milliarcseconds, $\\omega_\\mathrm{true} = 2\\pi / P_\\mathrm{true}$ with $P_\\mathrm{true}$ the true orbital period in years, $\\phi$ is the orbital phase in radians, and $\\varepsilon(t)$ is zero-mean measurement noise in milliarcseconds.\n\n- The parallax factor is specified as\n  $$ p(t) \\;=\\; \\cos(2\\pi t), $$\n  which corresponds to a unit-amplitude annual ellipse projected onto the along-scan direction for a star on the ecliptic with suitably aligned scanning geometry. This is a standard and scientifically realistic simplification for exploring degeneracies between parallax and near-annual orbital periods.\n\nYou will fit an incorrect single-planet model to these data in which the planet's period is fixed to a value $P_\\mathrm{fit}$ that may differ from $P_\\mathrm{true}$. The fitted model is linear in its parameters:\n$$ y(t) \\approx \\theta_0' \\;+\\; \\mu' \\,(t - t_\\mathrm{ref}) \\;+\\; \\varpi_\\mathrm{fit} \\, p(t) \\;+\\; B \\,\\sin(\\omega_\\mathrm{fit} t) \\;+\\; C \\,\\cos(\\omega_\\mathrm{fit} t), $$\nwith unknowns $\\theta_0'$, $\\mu'$, $\\varpi_\\mathrm{fit}$, $B$, and $C$, and with $\\omega_\\mathrm{fit} = 2\\pi / P_\\mathrm{fit}$ fixed. The quantity of interest is the parallax bias\n$$ \\Delta \\varpi \\;=\\; \\varpi_\\mathrm{fit} \\;-\\; \\varpi_\\mathrm{true}, $$\nexpressed in milliarcseconds. You must obtain $\\varpi_\\mathrm{fit}$ via linear least squares for each test case.\n\nUse the following global measurement prescription, which is identical for all test cases unless otherwise specified:\n\n- Observation times: use $N = 80$ epochs uniformly spaced over a baseline of $T = 5$ years, starting at $t = 0$ years. That is, $t_i = i \\,\\Delta t$ for $i = 0, 1, \\dots, 79$, where $\\Delta t = T/N$ years.\n\n- Reference epoch: $t_\\mathrm{ref} = 2.5$ years.\n\n- Constant offset and proper motion: $\\theta_0 = 0$ milliarcseconds and $\\mu = 0$ milliarcseconds per year.\n\n- Noise: set $\\varepsilon(t) = 0$ for all $t$ (that is, no noise) to isolate structural bias.\n\n- Parallax factor: $p(t) = \\cos(2\\pi t)$, where the argument of the cosine is in radians, and $t$ is in years.\n\n- Angle unit: all angles such as $\\phi$ must be in radians.\n\n- Periods: all periods $P_\\mathrm{true}$ and $P_\\mathrm{fit}$ must be in years.\n\n- Amplitudes and parallax: all displacements and parallaxes must be in milliarcseconds.\n\nImplement the linear least squares fit by constructing the design matrix with columns corresponding to $1$, $(t - t_\\mathrm{ref})$, $p(t)$, $\\sin(\\omega_\\mathrm{fit} t)$, and $\\cos(\\omega_\\mathrm{fit} t)$, and solving for the parameters that minimize the squared residuals.\n\nTest suite. Compute $\\Delta \\varpi$ for each of the following five parameter sets, using the above observation prescription:\n\n- Case A (happy path, far from one year):\n  - $\\varpi_\\mathrm{true} = 100.0$ milliarcseconds,\n  - $a = 0.2$ milliarcseconds,\n  - $P_\\mathrm{true} = 2.0$ years,\n  - $\\phi = 0.7$ radians,\n  - $P_\\mathrm{fit} = 2.0$ years.\n\n- Case B (near-degenerate, slightly mismatched period):\n  - $\\varpi_\\mathrm{true} = 100.0$ milliarcseconds,\n  - $a = 0.2$ milliarcseconds,\n  - $P_\\mathrm{true} = 1.03$ years,\n  - $\\phi = 1.1$ radians,\n  - $P_\\mathrm{fit} = 1.01$ years.\n\n- Case C (degenerate true period at one year, incorrect fitted period):\n  - $\\varpi_\\mathrm{true} = 100.0$ milliarcseconds,\n  - $a = 0.2$ milliarcseconds,\n  - $P_\\mathrm{true} = 1.00$ years,\n  - $\\phi = 2.2$ radians,\n  - $P_\\mathrm{fit} = 0.95$ years.\n\n- Case D (edge case with no planet):\n  - $\\varpi_\\mathrm{true} = 100.0$ milliarcseconds,\n  - $a = 0.0$ milliarcseconds,\n  - $P_\\mathrm{true} = 0.80$ years,\n  - $\\phi = 0.0$ radians,\n  - $P_\\mathrm{fit} = 1.05$ years.\n\n- Case E (different parallax scale and near-annual periods):\n  - $\\varpi_\\mathrm{true} = 50.0$ milliarcseconds,\n  - $a = 0.5$ milliarcseconds,\n  - $P_\\mathrm{true} = 1.10$ years,\n  - $\\phi = 0.3$ radians,\n  - $P_\\mathrm{fit} = 1.02$ years.\n\nYour program must output a single line containing the biases for these five cases as a comma-separated Python-style list of floating-point numbers in milliarcseconds, each rounded to six decimal places, in the order [Case A, Case B, Case C, Case D, Case E]. For example, your program should produce a single line of output in the form\n`[bA,bB,bC,bD,bE]`\nwhere each entry is a float with exactly six digits after the decimal point and the unit implied to be milliarcseconds. No other text should be printed.",
            "solution": "The objective is to compute the bias induced in the astrometric parallax of a star when its observed motion is fitted with a model that assumes an incorrect orbital period for an orbiting exoplanet. The bias, $\\Delta \\varpi = \\varpi_\\mathrm{fit} - \\varpi_\\mathrm{true}$, is determined by generating synthetic, noise-free astrometric data based on a \"true\" model and then performing a linear least-squares fit using an \"incorrect\" model. This procedure isolates the structural bias arising from model misspecification, particularly in the challenging regime where the planetary period is close to one year, causing a degeneracy with the annual parallax signature.\n\nThe analysis is performed according to the following mathematical and algorithmic framework.\n\n### Mathematical Framework\n\n**1. Data Generation (True Model)**\n\nThe synthetic along-scan displacement data, $y(t_i)$, are generated at a series of discrete time points $t_i$. The model for the true displacement is given by:\n$$ y(t) \\;=\\; \\theta_0 \\;+\\; \\mu \\,(t - t_\\mathrm{ref}) \\;+\\; \\varpi_\\mathrm{true} \\, p(t) \\;+\\; a \\,\\cos\\!\\big(\\omega_\\mathrm{true}\\, t + \\phi\\big) \\;+\\; \\varepsilon(t) $$\nAccording to the problem specification, we use the global parameters $\\theta_0 = 0$, $\\mu = 0$, and $\\varepsilon(t) = 0$. The parallax factor is $p(t) = \\cos(2\\pi t)$. The true angular frequency of the planet is $\\omega_\\mathrm{true} = 2\\pi / P_\\mathrm{true}$. The equation for the generated data points thus simplifies to:\n$$ y(t_i) \\;=\\; \\varpi_\\mathrm{true} \\cos(2\\pi t_i) \\;+\\; a \\cos\\left(\\frac{2\\pi}{P_\\mathrm{true}} t_i + \\phi\\right) $$\nThe observation times are $t_i = i \\cdot \\Delta t$ for $i \\in \\{0, 1, \\dots, N-1\\}$, where the number of observations is $N=80$ over a total baseline of $T=5$ years, so the time step is $\\Delta t = T/N = 5/80 = 0.0625$ years.\n\n**2. Model Fitting (Linear Least Squares)**\n\nThe generated data vector, $\\mathbf{y} = [y(t_0), y(t_1), \\dots, y(t_{N-1})]^T$, is fitted with a linear model:\n$$ y(t) \\approx \\theta_0' \\;+\\; \\mu' \\,(t - t_\\mathrm{ref}) \\;+\\; \\varpi_\\mathrm{fit} \\, p(t) \\;+\\; B \\,\\sin(\\omega_\\mathrm{fit} t) \\;+\\; C \\,\\cos(\\omega_\\mathrm{fit} t) $$\nwhere $\\omega_\\mathrm{fit} = 2\\pi / P_\\mathrm{fit}$ is fixed for each test case. This can be expressed in matrix form as a linear system $\\mathbf{y} \\approx \\mathbf{A} \\mathbf{x}$, where $\\mathbf{x}$ is the vector of parameters to be determined and $\\mathbf{A}$ is the design matrix.\n\nThe parameter vector $\\mathbf{x}$ is a $5 \\times 1$ column vector containing the unknown coefficients:\n$$ \\mathbf{x} \\;=\\; \\begin{bmatrix} \\theta_0' \\\\ \\mu' \\\\ \\varpi_\\mathrm{fit} \\\\ B \\\\ C \\end{bmatrix} $$\n\nThe design matrix $\\mathbf{A}$ is an $N \\times 5$ matrix, where each column consists of a basis function evaluated at each observation time $t_i$. The $i$-th row of $\\mathbf{A}$ is:\n$$ \\mathbf{A}_{i,:} \\;=\\; \\begin{bmatrix} 1 & (t_i - t_\\mathrm{ref}) & \\cos(2\\pi t_i) & \\sin(\\omega_\\mathrm{fit} t_i) & \\cos(\\omega_\\mathrm{fit} t_i) \\end{bmatrix} $$\nwith the reference epoch being $t_\\mathrm{ref} = 2.5$ years.\n\n**3. Solution and Bias Calculation**\n\nThe best-fit parameter vector, $\\hat{\\mathbf{x}}$, is the one that minimizes the sum of squared residuals, $\\|\\mathbf{y} - \\mathbf{A}\\mathbf{x}\\|^2$. This is the standard linear least-squares problem, and its solution is formally given by $\\hat{\\mathbf{x}} = (\\mathbf{A}^T \\mathbf{A})^{-1} \\mathbf{A}^T \\mathbf{y}$. Numerically, this is solved robustly using methods such as QR decomposition, available in standard scientific computing libraries.\n\nAfter solving for $\\hat{\\mathbf{x}}$, the fitted parallax, $\\varpi_\\mathrm{fit}$, corresponds to the third element of the solution vector (index $2$, using $0$-based indexing):\n$$ \\varpi_\\mathrm{fit} \\;=\\; \\hat{\\mathbf{x}}_2 $$\nFinally, the parallax bias, $\\Delta \\varpi$, is computed for each test case as the difference between the fitted and true parallax values:\n$$ \\Delta \\varpi \\;=\\; \\varpi_\\mathrm{fit} - \\varpi_\\mathrm{true} $$\n\n### Algorithmic Implementation\n\nThe computation proceeds as follows for each of the five test cases:\n1.  Set the universal observation parameters: $N=80$, $T=5$ years, and $t_\\mathrm{ref} = 2.5$ years.\n2.  Generate the array of $N$ observation times, $t$, from $t=0$ up to, but not including, $t=T$.\n3.  For a given test case, retrieve the true parameters: $\\varpi_\\mathrm{true}$, $a$, $P_\\mathrm{true}$, $\\phi$, and the fitted period $P_\\mathrm{fit}$.\n4.  Construct the \"true\" data vector $\\mathbf{y}$ by evaluating $y(t_i)$ at each time point using the true model.\n5.  Construct the $N \\times 5$ design matrix $\\mathbf{A}$. The five columns are vectors representing the basis functions: $1$, $t - t_\\mathrm{ref}$, $\\cos(2\\pi t)$, $\\sin((2\\pi/P_\\mathrm{fit}) t)$, and $\\cos((2\\pi/P_\\mathrm{fit}) t)$.\n6.  Use a numerical least-squares solver, such as `numpy.linalg.lstsq`, to find the parameter vector $\\hat{\\mathbf{x}}$ that best fits the data $\\mathbf{y}$ with the model defined by $\\mathbf{A}$.\n7.  Extract the fitted parallax $\\varpi_\\mathrm{fit}$ from the third component of the resulting vector $\\hat{\\mathbf{x}}$.\n8.  Calculate the parallax bias $\\Delta \\varpi = \\varpi_\\mathrm{fit} - \\varpi_\\mathrm{true}$.\n9.  This process is repeated for all five test cases, and the resulting biases are collected and formatted for output.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the parallax bias for a series of astrometric test cases.\n\n    This function generates synthetic astrometric data for a star with a planet\n    and then fits a misspecified model to quantify the resulting bias in the\n    derived parallax.\n    \"\"\"\n    # Global measurement prescription\n    N = 80  # Number of epochs\n    T = 5.0  # Observation baseline in years\n    t_ref = 2.5  # Reference epoch in years\n    \n    # Observation times array\n    # t_i = i * Delta_t for i=0, ..., N-1, where Delta_t = T/N\n    # np.linspace(start, stop, num, endpoint=False) generates `num` points\n    # from `start` up to but not including `stop`.\n    times = np.linspace(0.0, T, N, endpoint=False)\n\n    # Test suite:\n    # (varpi_true, a, P_true, phi, P_fit)\n    test_cases = [\n        # Case A: happy path, far from one year\n        (100.0, 0.2, 2.0, 0.7, 2.0),\n        # Case B: near-degenerate, slightly mismatched period\n        (100.0, 0.2, 1.03, 1.1, 1.01),\n        # Case C: degenerate true period at one year, incorrect fitted period\n        (100.0, 0.2, 1.00, 2.2, 0.95),\n        # Case D: edge case with no planet\n        (100.0, 0.0, 0.80, 0.0, 1.05),\n        # Case E: different parallax scale and near-annual periods\n        (50.0, 0.5, 1.10, 0.3, 1.02),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        varpi_true, a_true, P_true, phi_true, P_fit = case\n\n        # 1. Generate synthetic \"true\" data\n        # y(t) = varpi_true * p(t) + a * cos(omega_true*t + phi)\n        # Note: theta_0 and mu are zero.\n        omega_true = 2.0 * np.pi / P_true\n        parallax_signal_true = varpi_true * np.cos(2.0 * np.pi * times)\n        planet_signal_true = a_true * np.cos(omega_true * times + phi_true)\n        y_observed = parallax_signal_true + planet_signal_true\n\n        # 2. Construct the design matrix for the least-squares fit\n        # The fitted model has 5 parameters: theta_0', mu', varpi_fit, B, C\n        # y(t) ~ theta_0' + mu'*(t-t_ref) + varpi_fit*p(t) + B*sin(omega_fit*t) + C*cos(omega_fit*t)\n        omega_fit = 2.0 * np.pi / P_fit\n        \n        # Columns of the design matrix A\n        col1 = np.ones(N)                  # Basis for theta_0'\n        col2 = times - t_ref               # Basis for mu'\n        col3 = np.cos(2.0 * np.pi * times) # Basis for varpi_fit\n        col4 = np.sin(omega_fit * times)   # Basis for B\n        col5 = np.cos(omega_fit * times)   # Basis for C\n        \n        design_matrix = np.vstack([col1, col2, col3, col4, col5]).T\n\n        # 3. Solve the linear least-squares problem Ax = y\n        # We use rcond=None to use the machine-precision default and suppress future warnings.\n        # lstsq returns a tuple; the first element is the solution vector x.\n        params_fit = np.linalg.lstsq(design_matrix, y_observed, rcond=None)[0]\n\n        # 4. Extract the fitted parallax and compute the bias\n        varpi_fit = params_fit[2]  # varpi_fit is the 3rd parameter (index 2)\n        parallax_bias = varpi_fit - varpi_true\n        \n        results.append(parallax_bias)\n\n    # Final print statement in the exact required format.\n    # The format specifier \"{:.6f}\" rounds the number to six decimal places.\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "This final practice integrates the full chain of astrometric detection, from celestial mechanics to statistical signal processing. Building a realistic model of an exoplanet's signal requires solving for the Keplerian orbit in three dimensions and projecting it onto the two-dimensional plane of the sky. In this comprehensive exercise , you will generate a complete synthetic dataset for a planetary system, including the addition of realistic measurement noise, and then apply the powerful technique of matched filtering to determine the statistical significance of your detection. This serves as a capstone, simulating the process an astronomer would follow to discover a new world.",
            "id": "4152314",
            "problem": "You are to implement a complete, runnable program that generates a synthetic two-dimensional astrometric time series for a star hosting an exoplanet and computes the detection significance using a matched-filter approach. The program must be self-contained and produce a single line of output as specified below.\n\nThe fundamental base to be used is as follows:\n- The two-body problem governed by Newtonian gravity, implying conservation of angular momentum and energy for a Keplerian orbit.\n- Kepler’s laws and Kepler’s equation for elliptical orbits: the relationship between mean anomaly $M$, eccentric anomaly $E$, and eccentricity $e$.\n- The standard sky-plane astrometric projection of the stellar reflex motion under a set of orbital elements, using rotation from the orbital plane to the plane of the sky parameterized by the longitude of the ascending node $\\Omega$, the argument of periastron $\\omega$, and the inclination $i$.\n- The assumption of independent, identically distributed Gaussian measurement noise in the right ascension and declination residuals (after parallax and proper motion have been removed), with a known standard deviation per coordinate.\n\nYou will generate the noiseless astrometric signal of the host star’s reflex motion induced by a single planet and add Gaussian noise to simulate observations. The motion should be computed from first principles, starting from the two-body Keplerian solution:\n- Use the relation $a^3/P^2 = M_{\\mathrm{tot}}$ in units $\\mathrm{AU}^3/\\mathrm{yr}^2$ when mass is in units of the solar mass, where $a$ is the planet–star relative semi-major axis, $P$ is the orbital period, and $M_{\\mathrm{tot}}$ is the total mass of the system. This uses the conventional scaling where the gravitational constant is absorbed into the unit choice.\n- The star’s reflex semi-major axis is $a_\\star = a \\, M_p / M_{\\mathrm{tot}}$, where $M_p$ is the planet mass and $M_{\\mathrm{tot}} = M_\\star + M_p$.\n- In the orbital plane, the coordinates of the orbit are $X_{\\mathrm{op}} = a_\\star (\\cos E - e)$ and $Y_{\\mathrm{op}} = a_\\star \\sqrt{1 - e^2} \\sin E$, where $E$ is the eccentric anomaly obtained from Kepler’s equation $M = E - e \\sin E$, with mean anomaly $M = M_0 + n (t - t_0)$ and mean motion $n = 2\\pi/P$.\n- Project to the sky plane using the Thiele–Innes rotation with constants $A$, $B$, $F$, $G$,\n  where $A = \\cos \\Omega \\cos \\omega - \\sin \\Omega \\sin \\omega \\cos i$, $B = \\sin \\Omega \\cos \\omega + \\cos \\Omega \\sin \\omega \\cos i$, $F = -\\cos \\Omega \\sin \\omega - \\sin \\Omega \\cos \\omega \\cos i$, and $G = -\\sin \\Omega \\sin \\omega + \\cos \\Omega \\cos \\omega \\cos i$,\n  so that the sky-plane offsets are $x = (A X_{\\mathrm{op}} + F Y_{\\mathrm{op}})/d$ and $y = (B X_{\\mathrm{op}} + G Y_{\\mathrm{op}})/d$, with $d$ the distance in parsec. Use that $1\\,\\mathrm{AU}$ at $1\\,\\mathrm{pc}$ subtends $1\\,\\mathrm{arcsec}$, and express astrometric offsets in microarcseconds.\n\nThe matched-filter detection significance is to be computed by forming a template from the noiseless model and correlating it with the noisy data under the assumption of known, white Gaussian noise. The detection significance is the signal-to-noise ratio of this matched filter under the Gaussian model with known covariance. You must not derive or use any heuristic shortcut formulae; base your computation on the above physical model and the definition of a matched filter for Gaussian noise.\n\nImplementation requirements and conventions:\n- All angles provided in the input parameter sets are in degrees and must be converted to radians for computation.\n- Time is in years and must be sampled uniformly over a specified observing baseline for each test case.\n- The epoch $t_0$ for the mean anomaly $M_0$ is the start of the time series, i.e., the first sample at $t = 0$.\n- Observation noise must be added independently to both $x$ and $y$ coordinates as zero-mean Gaussian noise with a specified standard deviation per coordinate. Use the specified pseudorandom number generator seed for each test case for reproducibility.\n- The right ascension and declination residuals are assumed to have had parallax and proper motion removed. You must not add any additional signals beyond the Keplerian reflex motion and the Gaussian noise.\n\nUnits and constants:\n- Period $P$ is in $\\mathrm{yr}$.\n- Distance $d$ is in $\\mathrm{pc}$.\n- Masses $M_\\star$ and $M_p$ are in units of the solar mass and the Jupiter mass, respectively. Use the conversion $1\\,M_{\\mathrm{Jup}} = 9.54588 \\times 10^{-4}\\,M_\\odot$.\n- Astrometric offsets must be computed in $\\mu\\mathrm{as}$ (microarcseconds).\n- Angles in the input are in degrees; convert to radians internally.\n- The detection significance is dimensionless.\n\nMatched-filter specification:\n- Construct the data vector as the concatenation of the $x$ and $y$ time series in $\\mu\\mathrm{as}$.\n- Construct the template vector from the noiseless model using the same parameters.\n- Assume a diagonal noise covariance with the given per-coordinate variance. Compute the matched-filter detection significance as the signal-to-noise ratio under this model.\n\nTest suite:\nFor each case below, simulate $N$ uniformly spaced observation times $t_k$ over the baseline from $t = 0$ to $t = T_{\\mathrm{obs}}$ inclusive, i.e., $t_k = k \\, T_{\\mathrm{obs}}/(N-1)$ for $k = 0,1,\\dots,N-1$. For each case, generate the noisy data using the specified seed and compute the matched-filter detection significance as described above. Use the exact parameter values given.\n\n- Case $1$ (baseline thumbnail case):\n  - $P = 1.8\\,\\mathrm{yr}$, $e = 0.3$, $i = 45^\\circ$, $\\Omega = 60^\\circ$, $\\omega = 120^\\circ$, $M_0 = 30^\\circ$,\n  - $M_\\star = 1.0\\,M_\\odot$, $M_p = 1.0\\,M_{\\mathrm{Jup}}$, $d = 10\\,\\mathrm{pc}$,\n  - $N = 80$, $T_{\\mathrm{obs}} = 5.0\\,\\mathrm{yr}$,\n  - noise standard deviation per coordinate $\\sigma = 10\\,\\mu\\mathrm{as}$,\n  - pseudorandom seed $42$.\n\n- Case $2$ (circular, face-on, higher precision, farther star):\n  - $P = 2.5\\,\\mathrm{yr}$, $e = 0.0$, $i = 0^\\circ$, $\\Omega = 10^\\circ$, $\\omega = 0^\\circ$, $M_0 = 200^\\circ$,\n  - $M_\\star = 1.1\\,M_\\odot$, $M_p = 0.3\\,M_{\\mathrm{Jup}}$, $d = 20\\,\\mathrm{pc}$,\n  - $N = 120$, $T_{\\mathrm{obs}} = 5.0\\,\\mathrm{yr}$,\n  - $\\sigma = 5\\,\\mu\\mathrm{as}$,\n  - seed $7$.\n\n- Case $3$ (edge-on, eccentric, low-mass planet, high noise):\n  - $P = 1.0\\,\\mathrm{yr}$, $e = 0.6$, $i = 90^\\circ$, $\\Omega = 0^\\circ$, $\\omega = 90^\\circ$, $M_0 = 0^\\circ$,\n  - $M_\\star = 0.8\\,M_\\odot$, $M_p = 0.1\\,M_{\\mathrm{Jup}}$, $d = 50\\,\\mathrm{pc}$,\n  - $N = 60$, $T_{\\mathrm{obs}} = 3.0\\,\\mathrm{yr}$,\n  - $\\sigma = 30\\,\\mu\\mathrm{as}$,\n  - seed $99$.\n\n- Case $4$ (null planet amplitude; same geometry as Case $1$ but $M_p = 0$):\n  - $P = 1.8\\,\\mathrm{yr}$, $e = 0.3$, $i = 45^\\circ$, $\\Omega = 60^\\circ$, $\\omega = 120^\\circ$, $M_0 = 30^\\circ$,\n  - $M_\\star = 1.0\\,M_\\odot$, $M_p = 0.0\\,M_{\\mathrm{Jup}}$, $d = 10\\,\\mathrm{pc}$,\n  - $N = 80$, $T_{\\mathrm{obs}} = 5.0\\,\\mathrm{yr}$,\n  - $\\sigma = 10\\,\\mu\\mathrm{as}$,\n  - seed $123$.\n\n- Case $5$ (long period, partial orbit coverage):\n  - $P = 8.0\\,\\mathrm{yr}$, $e = 0.2$, $i = 30^\\circ$, $\\Omega = 45^\\circ$, $\\omega = 45^\\circ$, $M_0 = 10^\\circ$,\n  - $M_\\star = 1.0\\,M_\\odot$, $M_p = 0.5\\,M_{\\mathrm{Jup}}$, $d = 30\\,\\mathrm{pc}$,\n  - $N = 50$, $T_{\\mathrm{obs}} = 3.0\\,\\mathrm{yr}$,\n  - $\\sigma = 10\\,\\mu\\mathrm{as}$,\n  - seed $2024$.\n\nOutput specification:\n- Your program must produce a single line of output containing the detection significances for Cases $1$ through $5$, in order, as a comma-separated list enclosed in square brackets, for example, `[result1,result2,result3,result4,result5]` with no spaces. Each `result_k` must be a floating-point number.\n\nPhysical and numerical units:\n- Express the astrometric offsets in $\\mu\\mathrm{as}$ internally when constructing the data and template.\n- Angles are specified in degrees in the input and must be converted to radians for computation.\n- The detection significance is dimensionless and must be output as a floating-point number for each test case.\n\nYour implementation must adhere to these assumptions and conventions without introducing any additional approximations beyond those implied by the fundamental base described above.",
            "solution": "The problem is **valid**. It is a well-defined, scientifically sound, and complete problem in computational astrophysics. The following solution implements the full simulation and analysis chain as specified.\n\nThe solution will be implemented by first defining a main function to manage the test cases. A helper function will encapsulate the logic for a single case, from parameter conversion to the final significance calculation. This helper function will perform the following steps:\n1.  **Parameter Preparation**: Convert input angles from degrees to radians and the planet mass from Jupiter masses to solar masses using the given conversion factor, $1\\,M_{\\mathrm{Jup}} = 9.54588 \\times 10^{-4}\\,M_\\odot$.\n2.  **System Properties**: Calculate the total system mass $M_{\\mathrm{tot}} = M_\\star + M_p$. From Kepler's third law in astronomical units, $a^3/P^2 = M_{\\mathrm{tot}}$, calculate the planet's semi-major axis $a$. Then, compute the star's much smaller reflex semi-major axis $a_\\star = a \\cdot M_p/M_{\\mathrm{tot}}$. The mean motion is $n=2\\pi/P$.\n3.  **Time Series Generation**: Create a uniformly-spaced time vector of $N$ points from $t=0$ to $t=T_{\\mathrm{obs}}$.\n4.  **Noiseless Signal (Template) Generation**: For each time point $t_k$:\n    a. Calculate the mean anomaly $M(t_k) = M_0 + n \\cdot t_k$, where $M_0$ is the initial mean anomaly at $t_0=0$.\n    b. Solve Kepler's equation, $M = E - e \\sin E$, for the eccentric anomaly $E$. This is a transcendental equation requiring an iterative numerical solver. Newton's method is an efficient choice.\n    c. Compute the star's coordinates in the orbital plane: $X_{\\mathrm{op}} = a_\\star (\\cos E - e)$ and $Y_{\\mathrm{op}} = a_\\star \\sqrt{1 - e^2} \\sin E$.\n    d. Project these coordinates onto the plane of the sky. First, compute the Thiele-Innes constants ($A$, $B$, $F$, $G$) from the orientation angles $i$, $\\Omega$, and $\\omega$.\n    e. Calculate the astrometric offsets in arcseconds: $x = (A X_{\\mathrm{op}} + F Y_{\\mathrm{op}})/d$ and $y = (B X_{\\mathrm{op}} + G Y_{\\mathrm{op}})/d$. The division by distance $d$ in parsecs correctly converts the displacement from AU to arcseconds.\n    f. Convert these offsets to microarcseconds ($\\mu\\mathrm{as}$) by multiplying by $10^6$. These time series for $x$ and $y$ constitute the noiseless model template.\n5.  **Noisy Data Simulation**:\n    a. Initialize a pseudorandom number generator with the specified seed for reproducibility.\n    b. Generate two sets of $N$ random numbers from a Gaussian distribution with mean $0$ and standard deviation $\\sigma$.\n    c. Add this noise to the noiseless $x$ and $y$ time series to create the simulated \"observed\" data.\n6.  **Matched-Filter Significance**:\n    a. The data vector $d$ and template vector $s$ are formed by concatenating their respective $x$ and $y$ time series.\n    b. For a signal template $s$ measured with data $d$ in the presence of independent Gaussian noise with per-coordinate standard deviation $\\sigma$, the detection significance (signal-to-noise ratio of the measured amplitude) is given by $\\mathrm{SNR} = (\\mathbf{s} \\cdot \\mathbf{d}) / (\\sigma \\sqrt{\\mathbf{s} \\cdot \\mathbf{s}})$, where $\\cdot$ denotes the vector dot product.\n    c. A special case is handled for $M_p = 0$, where the template signal $s$ is a zero vector. In this instance, the significance of detection is logically $0$.\n\nThis principled approach ensures that the entire calculation is derived from the fundamental physical model and statistical definitions provided.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test cases and print the results.\n    \"\"\"\n    M_JUP_TO_M_SUN = 9.54588e-4\n\n    test_cases = [\n        # Case 1 (baseline thumbnail case)\n        {'P': 1.8, 'e': 0.3, 'i': 45.0, 'Omega': 60.0, 'omega': 120.0, 'M0': 30.0,\n         'M_star': 1.0, 'M_p_jup': 1.0, 'd': 10.0,\n         'N': 80, 'T_obs': 5.0, 'sigma': 10.0, 'seed': 42},\n        # Case 2 (circular, face-on, higher precision, farther star)\n        {'P': 2.5, 'e': 0.0, 'i': 0.0, 'Omega': 10.0, 'omega': 0.0, 'M0': 200.0,\n         'M_star': 1.1, 'M_p_jup': 0.3, 'd': 20.0,\n         'N': 120, 'T_obs': 5.0, 'sigma': 5.0, 'seed': 7},\n        # Case 3 (edge-on, eccentric, low-mass planet, high noise)\n        {'P': 1.0, 'e': 0.6, 'i': 90.0, 'Omega': 0.0, 'omega': 90.0, 'M0': 0.0,\n         'M_star': 0.8, 'M_p_jup': 0.1, 'd': 50.0,\n         'N': 60, 'T_obs': 3.0, 'sigma': 30.0, 'seed': 99},\n        # Case 4 (null planet amplitude)\n        {'P': 1.8, 'e': 0.3, 'i': 45.0, 'Omega': 60.0, 'omega': 120.0, 'M0': 30.0,\n         'M_star': 1.0, 'M_p_jup': 0.0, 'd': 10.0,\n         'N': 80, 'T_obs': 5.0, 'sigma': 10.0, 'seed': 123},\n        # Case 5 (long period, partial orbit coverage)\n        {'P': 8.0, 'e': 0.2, 'i': 30.0, 'Omega': 45.0, 'omega': 45.0, 'M0': 10.0,\n         'M_star': 1.0, 'M_p_jup': 0.5, 'd': 30.0,\n         'N': 50, 'T_obs': 3.0, 'sigma': 10.0, 'seed': 2024},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = compute_significance(\n            P=case['P'], e=case['e'], i_deg=case['i'], Omega_deg=case['Omega'],\n            omega_deg=case['omega'], M0_deg=case['M0'], M_star=case['M_star'],\n            M_p_jup=case['M_p_jup'], d=case['d'], N=case['N'], T_obs=case['T_obs'],\n            sigma_muas=case['sigma'], seed=case['seed'],\n            m_jup_to_m_sun=M_JUP_TO_M_SUN\n        )\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef solve_kepler(M, e, tol=1e-12):\n    \"\"\"\n    Solves Kepler's equation M = E - e*sin(E) for E using Newton's method.\n    \"\"\"\n    E = M  # Initial guess\n    for _ in range(100):  # Safety break\n        f_E = E - e * np.sin(E) - M\n        f_prime_E = 1.0 - e * np.cos(E)\n        if abs(f_E)  tol:\n            break\n        E = E - f_E / f_prime_E\n    return E\n\ndef compute_significance(P, e, i_deg, Omega_deg, omega_deg, M0_deg,\n                         M_star, M_p_jup, d, N, T_obs, sigma_muas, seed,\n                         m_jup_to_m_sun):\n    \"\"\"\n    Computes the matched-filter detection significance for a single case.\n    \"\"\"\n    # 1. Parameter Preparation\n    M_p = M_p_jup * m_jup_to_m_sun\n    i = np.deg2rad(i_deg)\n    Omega = np.deg2rad(Omega_deg)\n    omega = np.deg2rad(omega_deg)\n    M0 = np.deg2rad(M0_deg)\n\n    # Handle the null planet mass case early to avoid unnecessary computation\n    if M_p == 0.0:\n        return 0.0\n\n    # 2. System Properties\n    M_tot = M_star + M_p\n    a = (M_tot * P**2)**(1/3.0)  # Relative semi-major axis in AU\n    a_star = a * M_p / M_tot     # Stellar reflex semi-major axis in AU\n    n = 2.0 * np.pi / P          # Mean motion in rad/yr\n\n    # 3. Time Series Generation\n    times = np.linspace(0, T_obs, N)\n\n    # 4. Noiseless Signal (Template) Generation\n    s_x = np.zeros(N)\n    s_y = np.zeros(N)\n\n    # Thiele-Innes constants\n    cos_i = np.cos(i)\n    sin_i = np.sin(i)\n    cos_Omega = np.cos(Omega)\n    sin_Omega = np.sin(Omega)\n    cos_omega = np.cos(omega)\n    sin_omega = np.sin(omega)\n\n    A = cos_Omega * cos_omega - sin_Omega * sin_omega * cos_i\n    B = sin_Omega * cos_omega + cos_Omega * sin_omega * cos_i\n    F = -cos_Omega * sin_omega - sin_Omega * cos_omega * cos_i\n    G = -sin_Omega * sin_omega + cos_Omega * cos_omega * cos_i\n\n    for k, t in enumerate(times):\n        # Mean anomaly\n        M_t = M0 + n * t\n        \n        # Eccentric anomaly\n        E = solve_kepler(M_t, e)\n\n        # Orbital plane coordinates\n        X_op = a_star * (np.cos(E) - e)\n        Y_op = a_star * np.sqrt(1.0 - e**2) * np.sin(E)\n\n        # Sky plane projection (in arcseconds)\n        offset_x_arcsec = (A * X_op + F * Y_op) / d\n        offset_y_arcsec = (B * X_op + G * Y_op) / d\n\n        # Store in µas\n        s_x[k] = offset_x_arcsec * 1e6\n        s_y[k] = offset_y_arcsec * 1e6\n        \n    s_template = np.concatenate((s_x, s_y))\n\n    # 5. Noisy Data Simulation\n    rng = np.random.default_rng(seed)\n    noise_x = rng.normal(0, sigma_muas, N)\n    noise_y = rng.normal(0, sigma_muas, N)\n    \n    d_x = s_x + noise_x\n    d_y = s_y + noise_y\n    d_data = np.concatenate((d_x, d_y))\n\n    # 6. Matched-Filter Significance Calculation\n    s_dot_s = np.dot(s_template, s_template)\n    \n    # If template has zero power (e.g., M_p=0 handled above, but as a safeguard)\n    if s_dot_s == 0.0:\n        return 0.0\n\n    s_dot_d = np.dot(s_template, d_data)\n    \n    significance = s_dot_d / (sigma_muas * np.sqrt(s_dot_s))\n    \n    return significance\n\nsolve()\n```"
        }
    ]
}