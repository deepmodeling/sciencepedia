{
    "hands_on_practices": [
        {
            "introduction": "The radial velocity method hinges on detecting the tiny wobble a star exhibits as it orbits the common center of mass with its planet. This first practice connects the foundational principles of two-body mechanics to the primary observable of the RV technique, the semi-amplitude $K$. By deriving the expected signal from first principles for a Jupiter-like planet, you will gain a concrete understanding of how planetary and stellar properties translate into a measurable Doppler shift and appreciate the instrumental precision required for exoplanet detection .",
            "id": "4184022",
            "problem": "A Sun-like host star of mass $M_{\\star} = 1\\,M_{\\odot}$ is orbited by a planet of mass $m_{p} = 1\\,M_{\\mathrm{J}}$ on a circular orbit with semi-major axis $a = 1\\,\\mathrm{AU}$ and orbital inclination $i = \\pi/2$ (edge-on). Using only Newton’s law of universal gravitation and the two-body dynamics for circular orbits, derive from first principles an expression for the star’s line-of-sight radial velocity as a function of time and identify the radial velocity semi-amplitude. Then evaluate the semi-amplitude numerically for the given system. Do not use any pre-derived exoplanet-specific formula; start from fundamental mechanics and the center-of-mass description of the two-body problem. Finally, briefly comment on whether such a signal is detectable with present-day high-precision spectrographs.\n\nTake the following constants:\n- Gravitational constant $G = 6.67430\\times 10^{-11}\\,\\mathrm{m^{3}\\,kg^{-1}\\,s^{-2}}$.\n- Solar mass $M_{\\odot} = 1.98847\\times 10^{30}\\,\\mathrm{kg}$.\n- Jupiter mass $M_{\\mathrm{J}} = 1.89813\\times 10^{27}\\,\\mathrm{kg}$.\n- Astronomical Unit $\\mathrm{AU} = 1.495978707\\times 10^{11}\\,\\mathrm{m}$.\n\nRound your final numerical answer for the semi-amplitude to three significant figures. Express the final semi-amplitude in meters per second (m/s).",
            "solution": "The problem as stated is scientifically grounded, self-contained, and well-posed. All data and constants necessary for a solution are provided, and there are no internal contradictions or violations of fundamental physical principles. The problem is therefore deemed valid and a solution will be derived.\n\nThe problem asks for the derivation of the star's line-of-sight radial velocity from first principles for a two-body system consisting of a star of mass $M_{\\star}$ and a planet of mass $m_p$. The two bodies orbit their common center of mass (CM) due to their mutual gravitational attraction.\n\nIn the center of mass frame, the position vectors of the star ($\\vec{r}_{\\star}$) and the planet ($\\vec{r}_p$) relative to the CM are related by the definition of the center of mass:\n$$M_{\\star}\\vec{r}_{\\star} + m_p\\vec{r}_p = \\vec{0}$$\nThe separation vector between the star and the planet is defined as $\\vec{a} = \\vec{r}_p - \\vec{r}_{\\star}$. From the CM equation, we have $\\vec{r}_p = -\\frac{M_{\\star}}{m_p}\\vec{r}_{\\star}$. Substituting this into the definition of $\\vec{a}$:\n$$\\vec{a} = -\\frac{M_{\\star}}{m_p}\\vec{r}_{\\star} - \\vec{r}_{\\star} = -\\left(\\frac{M_{\\star} + m_p}{m_p}\\right)\\vec{r}_{\\star}$$\nThis allows us to express the star's position vector relative to the CM in terms of the separation vector $\\vec{a}$:\n$$\\vec{r}_{\\star} = -\\frac{m_p}{M_{\\star} + m_p}\\vec{a}$$\nFor a circular orbit, the magnitude of the separation vector is constant, $|\\vec{a}| = a$, which is the semi-major axis. The star thus moves in a circular orbit around the CM with a radius $a_{\\star}$ given by:\n$$a_{\\star} = |\\vec{r}_{\\star}| = \\frac{m_p}{M_{\\star} + m_p}a$$\nThe gravitational force exerted by the planet on the star provides the necessary centripetal force for the star's orbit. However, it is more direct to analyze the dynamics of the equivalent one-body problem, where a reduced mass $\\mu = \\frac{M_{\\star}m_p}{M_{\\star}+m_p}$ orbits the total mass $M_{\\mathrm{tot}} = M_{\\star} + m_p$ at a distance $a$. The gravitational force is given by Newton's law:\n$$F_g = \\frac{G M_{\\star} m_p}{a^2}$$\nThis force provides the centripetal acceleration for the system. Using the relative coordinate framework, the equation of motion is $F_g = \\mu a_{\\mathrm{rel}}$, where $a_{\\mathrm{rel}}$ is the relative acceleration. For a circular orbit with angular velocity $\\omega$, the relative acceleration magnitude is $\\omega^2 a$.\n$$\\frac{G M_{\\star} m_p}{a^2} = \\left(\\frac{M_{\\star} m_p}{M_{\\star} + m_p}\\right) \\omega^2 a$$\nSolving for $\\omega^2$ gives Kepler's Third Law for a two-body system:\n$$\\omega^2 = \\frac{G(M_{\\star} + m_p)}{a^3}$$\nThe star orbits the CM with this same angular velocity $\\omega$. The magnitude of the star's orbital velocity, $v_{\\star}$, is therefore:\n$$v_{\\star} = \\omega a_{\\star} = \\sqrt{\\frac{G(M_{\\star} + m_p)}{a^3}} \\left(\\frac{m_p}{M_{\\star} + m_p}a\\right)$$\nSimplifying this expression, we get:\n$$v_{\\star} = \\frac{m_p \\sqrt{G(M_{\\star} + m_p)} a}{\\sqrt{a^3} (M_{\\star} + m_p)} = \\frac{m_p \\sqrt{G}}{\\sqrt{a} \\sqrt{M_{\\star} + m_p}} = m_p \\sqrt{\\frac{G}{a(M_{\\star} + m_p)}}$$\nThe line-of-sight radial velocity, $v_r(t)$, is the component of the star's orbital velocity vector, $\\vec{v}_{\\star}(t)$, along the observer's line of sight. The orbital inclination, $i$, is the angle between the normal to the orbital plane and the line of sight. For a circular orbit, the velocity vector $\\vec{v}_{\\star}(t)$ has a constant magnitude $v_{\\star}$ and rotates in the orbital plane. The component along the line of sight varies sinusoidally with time. The maximum value of this component, known as the radial velocity semi-amplitude $K$, is given by:\n$$K = v_{\\star} \\sin i$$\nThe full time-dependent expression for the star's radial velocity is $v_r(t) = K \\cos(\\omega t + \\phi)$, where $\\phi$ is a phase constant. The problem asks for the expression for $v_r(t)$ and the semi-amplitude $K$.\nThe expression for the semi-amplitude is:\n$$K = \\left(m_p \\sqrt{\\frac{G}{a(M_{\\star} + m_p)}}\\right) \\sin i$$\nThe star's line-of-sight radial velocity as a function of time is:\n$$v_r(t) = \\left(m_p \\sin i \\sqrt{\\frac{G}{a(M_{\\star} + m_p)}}\\right) \\cos\\left(\\sqrt{\\frac{G(M_{\\star} + m_p)}{a^3}} t + \\phi\\right)$$\nNow, we evaluate the semi-amplitude $K$ numerically. The given values are:\n$M_{\\star} = 1\\,M_{\\odot} = 1.98847\\times 10^{30}\\,\\mathrm{kg}$\n$m_{p} = 1\\,M_{\\mathrm{J}} = 1.89813\\times 10^{27}\\,\\mathrm{kg}$\n$a = 1\\,\\mathrm{AU} = 1.495978707\\times 10^{11}\\,\\mathrm{m}$\n$i = \\pi/2$, so $\\sin i = \\sin(\\pi/2) = 1$\n$G = 6.67430\\times 10^{-11}\\,\\mathrm{m^{3}\\,kg^{-1}\\,s^{-2}}$\n\nFirst, calculate the total mass $M_{\\star} + m_p$:\n$$M_{\\star} + m_p = 1.98847\\times 10^{30}\\,\\mathrm{kg} + 1.89813\\times 10^{27}\\,\\mathrm{kg} = 1.99036813\\times 10^{30}\\,\\mathrm{kg}$$\nNext, we calculate the term $a(M_{\\star} + m_p)$:\n$$a(M_{\\star} + m_p) = (1.495978707\\times 10^{11}\\,\\mathrm{m}) \\times (1.99036813\\times 10^{30}\\,\\mathrm{kg}) \\approx 2.977543\\times 10^{41}\\,\\mathrm{kg \\cdot m}$$\nNow we compute the term inside the square root:\n$$\\frac{G}{a(M_{\\star} + m_p)} = \\frac{6.67430\\times 10^{-11}\\,\\mathrm{m^{3}\\,kg^{-1}\\,s^{-2}}}{2.977543\\times 10^{41}\\,\\mathrm{kg \\cdot m}} \\approx 2.24158\\times 10^{-52}\\,\\mathrm{m^2\\,kg^{-2}\\,s^{-2}}$$\nTaking the square root:\n$$\\sqrt{\\frac{G}{a(M_{\\star} + m_p)}} \\approx \\sqrt{2.24158\\times 10^{-52}\\,\\mathrm{m^2\\,kg^{-2}\\,s^{-2}}} \\approx 1.49719\\times 10^{-26}\\,\\mathrm{m\\,kg^{-1}\\,s^{-1}}$$\nFinally, we calculate $K$:\n$$K = m_p \\sin i \\sqrt{\\frac{G}{a(M_{\\star} + m_p)}} = (1.89813\\times 10^{27}\\,\\mathrm{kg}) \\times 1 \\times (1.49719\\times 10^{-26}\\,\\mathrm{m\\,kg^{-1}\\,s^{-1}})$$\n$$K \\approx 28.418\\,\\mathrm{m/s}$$\nRounding to three significant figures, the radial velocity semi-amplitude is $28.4\\,\\mathrm{m/s}$.\n\nRegarding detectability, a radial velocity signal with a semi-amplitude of $K \\approx 28.4\\,\\mathrm{m/s}$ is well within the detection capabilities of modern high-precision spectrographs. Instruments like the High Accuracy Radial velocity Planet Searcher (HARPS) can achieve a long-term precision of approximately $1\\,\\mathrm{m/s}$, and newer spectrographs like ESPRESSO aim for a precision of $10\\,\\mathrm{cm/s}$. Therefore, a signal of this magnitude would be considered a strong and readily detectable signature of an orbiting exoplanet. The first exoplanet discovered around a sun-like star, $51\\,\\mathrm{Pegasi\\,b}$, induced a radial velocity variation with a semi-amplitude of about $56\\,\\mathrm{m/s}$. Jupiter induces a variation of about $12.4\\,\\mathrm{m/s}$ in the Sun's velocity. The calculated signal is thus very significant.",
            "answer": "$$\n\\boxed{28.4}\n$$"
        },
        {
            "introduction": "A critical feature of the radial velocity method is its inability to determine a planet's full orbit in three dimensions; it measures only the velocity component along our line of sight. This creates a fundamental ambiguity between a planet's mass $m_p$ and its orbital inclination $i$, as the signal is proportional to the minimum mass, $m_p \\sin i$. This practice explores the statistical nature of this ambiguity by deriving the probability distribution for the inclination angle under the standard assumption of isotropic orbits, allowing you to move from a measurement to a probabilistic statement about the planet's true mass .",
            "id": "4184037",
            "problem": "A Sun-like star shows a periodic Doppler wobble detected via the radial velocity (RV) method. The measured minimum mass of the companion is the product $m_{p}\\sin i$, where $m_{p}$ is the planet’s true mass and $i$ is the orbital inclination relative to the line of sight. Assume the orbital angular momentum vectors of exoplanet systems are randomly oriented in space (isotropy), the measurement uncertainty on $m_{p}\\sin i$ is negligible, and the RV signal depends only on $\\sin i$ so that $i$ and $\\pi - i$ are degenerate. Angles are measured in radians.\n\n1. From the assumption of isotropy and the geometry of a sphere, derive the prior probability density $p(i)$ for the inclination $i$ restricted to $i \\in [0,\\pi/2]$.\n\n2. For a specific system with measured $m_{p}\\sin i = 20\\,M_{\\oplus}$ (where $M_{\\oplus}$ denotes an Earth mass), compute the probability that the true mass exceeds $30\\,M_{\\oplus}$ under the prior you derived. Express the final probability as a decimal number rounded to four significant figures. Do not use a percentage sign.",
            "solution": "The problem statement is evaluated as scientifically grounded, well-posed, objective, and self-contained. It is based on established principles of the radial velocity method in exoplanetology and standard assumptions of statistical isotropy. All provided data and conditions are consistent and sufficient for a rigorous mathematical solution. The problem is therefore deemed **valid**.\n\nThe problem is divided into two parts. First, we must derive the prior probability density function (PDF) for the orbital inclination, $p(i)$, under the assumption of isotropic orientation. Second, we apply this PDF to calculate a specific probability for a given exoplanet system.\n\n**Part 1: Derivation of the Prior Probability Density $p(i)$**\n\nThe assumption that the orbital angular momentum vectors are randomly oriented in space (isotropy) means that the direction of the vector has a uniform probability distribution over the surface of a sphere. Let the line of sight from the observer to the star define the $z$-axis of a spherical coordinate system. The inclination angle, $i$, is the angle between the orbital angular momentum vector and the line of sight, which corresponds to the polar angle in this coordinate system.\n\nThe differential solid angle, $d\\Omega$, corresponding to a small patch on the surface of a unit sphere is given by:\n$$d\\Omega = \\sin(i) \\, di \\, d\\phi$$\nwhere $i$ is the polar angle (inclination) and $\\phi$ is the azimuthal angle. The range for these angles is $i \\in [0, \\pi]$ and $\\phi \\in [0, 2\\pi)$.\n\nFor a uniform distribution over the sphere, the probability of the vector pointing into a given solid angle $d\\Omega$ is proportional to the size of that solid angle. The total solid angle of a sphere is $4\\pi$ steradians. Therefore, the probability density with respect to solid angle is a constant, $p(\\Omega) = \\frac{1}{4\\pi}$. The probability $dP$ of finding the vector within the differential solid angle $d\\Omega$ is:\n$$dP = p(\\Omega) \\, d\\Omega = \\frac{1}{4\\pi} \\sin(i) \\, di \\, d\\phi$$\n\nTo find the probability density function for the inclination $i$, we integrate over all possible values of the azimuthal angle $\\phi$, from $0$ to $2\\pi$. The probability of the inclination being between $i$ and $i+di$, denoted as $p_{\\text{full}}(i)di$, is:\n$$p_{\\text{full}}(i)di = \\int_{0}^{2\\pi} \\frac{1}{4\\pi} \\sin(i) \\, di \\, d\\phi = \\frac{\\sin(i)di}{4\\pi} \\int_{0}^{2\\pi} d\\phi = \\frac{\\sin(i)di}{4\\pi} (2\\pi) = \\frac{1}{2}\\sin(i)di$$\nThus, for the full range of inclinations $i \\in [0, \\pi]$, the PDF is $p_{\\text{full}}(i) = \\frac{1}{2}\\sin(i)$.\n\nThe problem states that the radial velocity measurement is degenerate for inclinations $i$ and $\\pi - i$, because the observed velocity depends on $\\sin(i)$, and $\\sin(i) = \\sin(\\pi - i)$. By convention, we restrict the analysis to the domain $i \\in [0, \\pi/2]$. The probability of observing an inclination in a small interval $[i, i+di]$ within this restricted domain is the sum of the probabilities that the true inclination is in $[i, i+di]$ or $[\\pi-i, \\pi-i+di]$.\nLet $p(i)$ be the PDF for the restricted domain $i \\in [0, \\pi/2]$. Then:\n$$p(i)di = p_{\\text{full}}(i)di + p_{\\text{full}}(\\pi-i)di = \\frac{1}{2}\\sin(i)di + \\frac{1}{2}\\sin(\\pi-i)di$$\nSince $\\sin(i) = \\sin(\\pi - i)$, this simplifies to:\n$$p(i)di = \\frac{1}{2}\\sin(i)di + \\frac{1}{2}\\sin(i)di = \\sin(i)di$$\nSo, the probability density function for $i \\in [0, \\pi/2]$ is $p(i) = \\sin(i)$.\n\nWe verify that this PDF is properly normalized over its domain:\n$$\\int_{0}^{\\pi/2} p(i) \\, di = \\int_{0}^{\\pi/2} \\sin(i) \\, di = [-\\cos(i)]_{0}^{\\pi/2} = -\\cos\\left(\\frac{\\pi}{2}\\right) - (-\\cos(0)) = -0 - (-1) = 1$$\nThe PDF is correctly normalized. Therefore, the prior probability density for the inclination $i \\in [0, \\pi/2]$ is $p(i) = \\sin(i)$.\n\n**Part 2: Calculation of the Probability**\n\nWe are given a system with a measured minimum mass of $m_{p}\\sin i = 20\\,M_{\\oplus}$. We need to compute the probability that the true mass $m_{p}$ exceeds $30\\,M_{\\oplus}$.\n\nThe true mass $m_{p}$ can be expressed in terms of the measured value and the inclination $i$ as:\n$$m_{p} = \\frac{20\\,M_{\\oplus}}{\\sin i}$$\nThe condition $m_{p} > 30\\,M_{\\oplus}$ can be translated into a condition on the inclination $i$:\n$$\\frac{20\\,M_{\\oplus}}{\\sin i} > 30\\,M_{\\oplus}$$\n$$\\frac{20}{30} > \\sin i$$\n$$\\sin i  \\frac{2}{3}$$\nSince we are in the domain $i \\in [0, \\pi/2]$, the sine function is monotonically increasing. The inequality $\\sin i  2/3$ is equivalent to $0 \\le i  \\arcsin(2/3)$.\n\nThe probability $P(m_{p} > 30\\,M_{\\oplus})$ is therefore the probability that the inclination $i$ lies in the interval $[0, \\arcsin(2/3))$. We can find this by integrating the PDF $p(i) = \\sin(i)$ over this interval:\n$$P(m_{p} > 30\\,M_{\\oplus}) = P\\left(0 \\le i  \\arcsin\\left(\\frac{2}{3}\\right)\\right) = \\int_{0}^{\\arcsin(2/3)} \\sin(i) \\, di$$\nEvaluating the integral:\n$$P = [-\\cos(i)]_{0}^{\\arcsin(2/3)} = -\\cos\\left(\\arcsin\\left(\\frac{2}{3}\\right)\\right) - (-\\cos(0))$$\nWe know that $\\cos(0) = 1$. To evaluate $\\cos(\\arcsin(2/3))$, we use the trigonometric identity $\\cos^2(\\theta) + \\sin^2(\\theta) = 1$, which implies $\\cos(\\theta) = \\sqrt{1 - \\sin^2(\\theta)}$ for $\\theta$ in the first quadrant. Since $i = \\arcsin(2/3)$ is in $[0, \\pi/2]$, its cosine is positive.\nLet $\\theta = \\arcsin(2/3)$, so $\\sin(\\theta) = 2/3$.\n$$\\cos\\left(\\arcsin\\left(\\frac{2}{3}\\right)\\right) = \\sqrt{1 - \\left(\\frac{2}{3}\\right)^2} = \\sqrt{1 - \\frac{4}{9}} = \\sqrt{\\frac{5}{9}} = \\frac{\\sqrt{5}}{3}$$\nSubstituting this back into the probability calculation:\n$$P = -\\frac{\\sqrt{5}}{3} - (-1) = 1 - \\frac{\\sqrt{5}}{3}$$\nNow, we compute the numerical value and round to four significant figures.\nUsing the value $\\sqrt{5} \\approx 2.2360679...$:\n$$P \\approx 1 - \\frac{2.2360679}{3} \\approx 1 - 0.7453559... \\approx 0.2546440...$$\nRounding to four significant figures, we get $0.2546$.",
            "answer": "$$\\boxed{0.2546}$$"
        },
        {
            "introduction": "Idealized models are a starting point, but real astronomical data is invariably affected by noise sources beyond the formal measurement uncertainties, such as stellar activity or subtle instrumental variations. This exercise introduces the concept of a stellar \"jitter\" term, $\\sigma_\\mathrm{jit}$, which is an additional white-noise component added to the error budget to account for this excess scatter. By implementing a maximum likelihood estimation for this jitter term, you will practice a vital technique in modern statistical data analysis, enabling more realistic and robust modeling of RV datasets .",
            "id": "4184035",
            "problem": "You are given several independent sets of one-dimensional radial velocity residuals modeled as the output of the radial velocity method after subtraction of any deterministic signal (e.g., a Keplerian fit), together with per-measurement formal uncertainties that are suspected to underpredict the observed scatter. Assume the following physically and statistically grounded model: each measured residual $y_i$ is the sum of an unknown constant offset $\\gamma$ and a noise term that is the sum of two independent Gaussian contributions: a formal measurement error with known standard deviation $\\sigma_i$ and an additional constant white-noise \"jitter\" with unknown standard deviation $\\sigma_\\mathrm{jit} \\ge 0$. Under independence and Gaussianity, the total noise for point $i$ is Gaussian with zero mean and variance $v_i = \\sigma_i^2 + \\sigma_\\mathrm{jit}^2$. The joint likelihood of the data is the product of the individual Gaussian densities. Your task is to estimate $\\sigma_\\mathrm{jit}$ by maximum likelihood, profiling (i.e., optimizing) over the unknown offset $\\gamma$ at each trial value of $\\sigma_\\mathrm{jit}$.\n\nBase your derivation on the following fundamental principles and facts only: (i) independence of measurements; (ii) properties of Gaussian random variables, including that independent Gaussian variances add; (iii) the definition of likelihood under independence; (iv) the equivalence of maximum likelihood to minimizing the negative log-likelihood; (v) optimization of a scalar function over a closed interval.\n\nFor each dataset below, compute the maximum likelihood estimate $\\hat{\\sigma}_\\mathrm{jit}$ in $\\mathrm{m/s}$, rounded to three decimal places. You must treat $\\gamma$ as an unknown nuisance parameter to be optimized jointly (via profiling) with $\\sigma_\\mathrm{jit}$. Angles do not appear in this problem. Ensure that your program returns physically meaningful non-negative estimates, respecting the boundary at $\\sigma_\\mathrm{jit}=0$. Results must be expressed in $\\mathrm{m/s}$.\n\nTest suite (each dataset is a pair of lists, the first being residuals $y_i$ in $\\mathrm{m/s}$ and the second being formal uncertainties $\\sigma_i$ in $\\mathrm{m/s}$):\n\n- Case A (underestimated errors, moderate scatter):\n  $y = [1.7,\\,-2.1,\\,0.3,\\,3.2,\\,-1.8,\\,2.4,\\,-0.7,\\,1.1,\\,-3.0,\\,2.7,\\,-1.2,\\,0.9]$,\n  $\\sigma = [1.0,\\,1.1,\\,0.9,\\,1.2,\\,1.0,\\,1.0,\\,1.1,\\,0.9,\\,1.0,\\,1.2,\\,1.1,\\,1.0]$.\n\n- Case B (noise consistent with formal errors; boundary at zero jitter is relevant):\n  $y = [0.1,\\,-0.3,\\,0.5,\\,-0.2,\\,0.0,\\,0.4,\\,-0.6,\\,0.2]$,\n  $\\sigma = [0.5,\\,0.6,\\,0.4,\\,0.5,\\,0.4,\\,0.5,\\,0.6,\\,0.5]$.\n\n- Case C (heteroscedastic formal errors; large additional scatter):\n  $y = [8.0,\\,-7.5,\\,5.2,\\,-6.1,\\,7.9,\\,-5.3,\\,6.8,\\,-7.2,\\,5.5,\\,-6.4]$,\n  $\\sigma = [2.0,\\,1.5,\\,2.5,\\,1.8,\\,2.2,\\,1.7,\\,2.1,\\,1.6,\\,2.4,\\,1.9]$.\n\n- Case D (high-precision formal errors with small but non-negligible extra noise):\n  $y = [0.10,\\,0.12,\\,-0.05,\\,0.08,\\,-0.02,\\,0.03,\\,-0.07,\\,0.09,\\,-0.01,\\,0.04]$,\n  $\\sigma = [0.05,\\,0.05,\\,0.05,\\,0.05,\\,0.05,\\,0.05,\\,0.05,\\,0.05,\\,0.05,\\,0.05]$.\n\nYour program must compute $\\hat{\\sigma}_\\mathrm{jit}$ for each case by maximizing the likelihood with respect to $\\sigma_\\mathrm{jit}$ and $\\gamma$. The final output format must be a single line containing the four results as a comma-separated list enclosed in square brackets, in the order A, B, C, D, for example $[r_A,r_B,r_C,r_D]$, where each $r_\\cdot$ is a float rounded to three decimal places and implicitly in $\\mathrm{m/s}$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, as just specified. No other output is permitted.",
            "solution": "We begin from a generative model consistent with radial velocity residuals. Let the measured residuals be $\\{y_i\\}_{i=1}^N$ with formal uncertainties $\\{\\sigma_i\\}_{i=1}^N$. Assume an unknown constant offset $\\gamma$ and an additional white-noise \"jitter\" with standard deviation $\\sigma_\\mathrm{jit} \\ge 0$ that is independent of the formal measurement errors. Each datum is modeled as\n$$\ny_i = \\gamma + \\epsilon_i + \\eta_i,\n$$\nwhere $\\epsilon_i \\sim \\mathcal{N}(0,\\sigma_i^2)$ and $\\eta_i \\sim \\mathcal{N}(0,\\sigma_\\mathrm{jit}^2)$ are independent. By the properties of independent Gaussian random variables, $\\epsilon_i + \\eta_i \\sim \\mathcal{N}(0, \\sigma_i^2 + \\sigma_\\mathrm{jit}^2)$. Define $v_i(\\sigma_\\mathrm{jit}) = \\sigma_i^2 + \\sigma_\\mathrm{jit}^2$.\n\nUnder independence across $i$, the likelihood of the data given $(\\gamma,\\sigma_\\mathrm{jit})$ is\n$$\n\\mathcal{L}(\\gamma,\\sigma_\\mathrm{jit}) = \\prod_{i=1}^N \\frac{1}{\\sqrt{2\\pi v_i(\\sigma_\\mathrm{jit})}} \\exp\\!\\left( -\\frac{(y_i - \\gamma)^2}{2 v_i(\\sigma_\\mathrm{jit})} \\right).\n$$\nMaximizing the likelihood is equivalent to minimizing the negative log-likelihood\n$$\n\\mathrm{NLL}(\\gamma,\\sigma_\\mathrm{jit}) = \\frac{1}{2}\\sum_{i=1}^N \\left[ \\ln\\!\\left(2\\pi v_i(\\sigma_\\mathrm{jit})\\right) + \\frac{(y_i - \\gamma)^2}{v_i(\\sigma_\\mathrm{jit})} \\right].\n$$\nWe seek the maximum likelihood estimate $\\hat{\\sigma}_\\mathrm{jit}$ while treating $\\gamma$ as a nuisance parameter. For any fixed $\\sigma_\\mathrm{jit}$, the function $\\mathrm{NLL}(\\gamma,\\sigma_\\mathrm{jit})$ is strictly convex in $\\gamma$ because it is a weighted sum of squared residuals with positive weights $w_i(\\sigma_\\mathrm{jit}) = 1/v_i(\\sigma_\\mathrm{jit})$. Setting the derivative with respect to $\\gamma$ to zero yields\n$$\n\\frac{\\partial \\mathrm{NLL}}{\\partial \\gamma} = - \\sum_{i=1}^N \\frac{y_i - \\gamma}{v_i(\\sigma_\\mathrm{jit})} = 0 \\quad \\Longrightarrow \\quad \\hat{\\gamma}(\\sigma_\\mathrm{jit}) = \\frac{\\sum_{i=1}^N w_i(\\sigma_\\mathrm{jit}) y_i}{\\sum_{i=1}^N w_i(\\sigma_\\mathrm{jit})},\n$$\nwhich is the weighted mean with weights $w_i(\\sigma_\\mathrm{jit}) = 1/v_i(\\sigma_\\mathrm{jit})$. Substituting $\\hat{\\gamma}(\\sigma_\\mathrm{jit})$ back into $\\mathrm{NLL}$ yields the profiled negative log-likelihood\n$$\n\\mathrm{NLL}_p(\\sigma_\\mathrm{jit}) = \\frac{1}{2}\\sum_{i=1}^N \\left[ \\ln\\!\\left(2\\pi v_i(\\sigma_\\mathrm{jit})\\right) + \\frac{(y_i - \\hat{\\gamma}(\\sigma_\\mathrm{jit}))^2}{v_i(\\sigma_\\mathrm{jit})} \\right].\n$$\nThe maximum likelihood estimate $\\hat{\\sigma}_\\mathrm{jit}$ is any minimizer of $\\mathrm{NLL}_p(\\sigma_\\mathrm{jit})$ over the closed interval $\\sigma_\\mathrm{jit} \\in [0, \\infty)$. In practice, we search over $\\sigma_\\mathrm{jit} \\in [0, S_\\mathrm{max}]$ with a sufficiently large $S_\\mathrm{max}$ to contain the optimum. Because $v_i(\\sigma_\\mathrm{jit})$ grows with $\\sigma_\\mathrm{jit}$, $\\mathrm{NLL}_p(\\sigma_\\mathrm{jit})$ tends to increase for very large $\\sigma_\\mathrm{jit}$, so it suffices to set $S_\\mathrm{max}$ several times larger than the observed scatter.\n\nAlgorithmic procedure for each dataset:\n1. Given $y$ and $\\sigma$, define $v_i(\\sigma_\\mathrm{jit}) = \\sigma_i^2 + \\sigma_\\mathrm{jit}^2$.\n2. For any trial $\\sigma_\\mathrm{jit}  0$, compute weights $w_i(\\sigma_\\mathrm{jit}) = 1/v_i(\\sigma_\\mathrm{jit})$, the profiled offset $\\hat{\\gamma}(\\sigma_\\mathrm{jit}) = \\left(\\sum_i w_i y_i\\right)/\\left(\\sum_i w_i\\right)$, and the profiled negative log-likelihood $\\mathrm{NLL}_p(\\sigma_\\mathrm{jit})$ as above.\n3. Numerically minimize $\\mathrm{NLL}_p(\\sigma_\\mathrm{jit})$ over $\\sigma_\\mathrm{jit} \\in (0, S_\\mathrm{max}]$ using a bounded one-dimensional optimizer. Separately evaluate $\\mathrm{NLL}_p(0)$ corresponding to no additional jitter. Select the $\\sigma_\\mathrm{jit}$ that yields the smaller value between the interior minimizer and the boundary at $\\sigma_\\mathrm{jit}=0$.\n4. Report $\\hat{\\sigma}_\\mathrm{jit}$ in $\\mathrm{m/s}$, rounded to three decimal places.\n\nInterpretation of $\\hat{\\sigma}_\\mathrm{jit}$: If $\\hat{\\sigma}_\\mathrm{jit}$ is close to $0$, the formal uncertainties $\\{\\sigma_i\\}$ adequately describe the observed scatter. A strictly positive $\\hat{\\sigma}_\\mathrm{jit}$ indicates additional unmodeled white noise, which may be of astrophysical origin (e.g., stellar activity) or instrumental/systematic origin. The magnitude of $\\hat{\\sigma}_\\mathrm{jit}$ relative to a characteristic formal uncertainty (such as the median of $\\{\\sigma_i\\}$) conveys whether the extra noise is negligible, comparable, or dominant. Because the estimation is based on maximum likelihood with a profiled nuisance parameter, $\\hat{\\sigma}_\\mathrm{jit}$ reflects the amount of additional variance required to reconcile the distribution of residuals with the Gaussian noise model.\n\nThe implementation uses a robust bounded scalar minimization of $\\mathrm{NLL}_p(\\sigma_\\mathrm{jit})$ and an explicit comparison against the boundary at $\\sigma_\\mathrm{jit}=0$ to respect the physical constraint $\\sigma_\\mathrm{jit} \\ge 0$. The final printed list contains four floats corresponding to Cases A–D, in $\\mathrm{m/s}$, rounded to three decimal places, formatted as a comma-separated list enclosed in square brackets.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import minimize_scalar\n\ndef profiled_nll(s_jit, y, sig):\n    \"\"\"\n    Compute the profiled negative log-likelihood for given sigma_jit  0,\n    profiling over gamma (systemic offset).\n    \"\"\"\n    # Ensure non-negative s_jit inside; optimizer will keep s_jit  0 for interior search.\n    s2 = s_jit * s_jit\n    v = sig**2 + s2\n    # Numerical guard: avoid zero or negative variances\n    if np.any(v = 0.0) or not np.isfinite(s2):\n        return np.inf\n    w = 1.0 / v\n    # Weighted mean for gamma at this s_jit\n    gamma_hat = np.sum(w * y) / np.sum(w)\n    r = y - gamma_hat\n    # Negative log-likelihood\n    nll = 0.5 * np.sum(np.log(2.0 * np.pi * v) + (r * r) / v)\n    return float(nll)\n\ndef profiled_nll_at_zero(y, sig):\n    \"\"\"\n    Compute profiled NLL at s_jit = 0, handling that case explicitly.\n    \"\"\"\n    v = sig**2\n    w = 1.0 / v\n    gamma_hat = np.sum(w * y) / np.sum(w)\n    r = y - gamma_hat\n    nll = 0.5 * np.sum(np.log(2.0 * np.pi * v) + (r * r) / v)\n    return float(nll)\n\ndef estimate_sigma_jit_mle(y, sig):\n    \"\"\"\n    Estimate sigma_jit via maximum likelihood with profiling over gamma.\n    Returns the non-negative MLE.\n    \"\"\"\n    y = np.asarray(y, dtype=float)\n    sig = np.asarray(sig, dtype=float)\n\n    # Define an upper bound for search that is safely large relative to the data scatter.\n    # Use observed scatter and formal errors to scale the bound conservatively.\n    # Add margins to reduce risk of truncating the optimum.\n    scatter = np.std(y, ddof=1) if y.size  1 else np.abs(y[0])\n    s_upper = max(5.0 * scatter + 5.0 * np.median(sig), 50.0)\n\n    # Define objective for optimizer (interior of (0, s_upper])\n    obj = lambda s: profiled_nll(s, y, sig)\n\n    # Perform bounded scalar minimization on (eps, s_upper)\n    eps = 1e-12\n    res = minimize_scalar(obj, bounds=(eps, s_upper), method='bounded', options={'xatol': 1e-10})\n\n    # Evaluate at boundary s=0 explicitly\n    nll0 = profiled_nll_at_zero(y, sig)\n    s_opt = res.x if res.success else s_upper\n    nll_opt = obj(s_opt)\n\n    # Choose the better of s=0 and interior optimum\n    if nll0 = nll_opt + 0.0:\n        return 0.0\n    else:\n        # Numerical safety: enforce non-negativity\n        return max(0.0, float(s_opt))\n\ndef solve():\n    # Define the test cases from the problem statement.\n\n    # Case A\n    yA = np.array([1.7, -2.1, 0.3, 3.2, -1.8, 2.4, -0.7, 1.1, -3.0, 2.7, -1.2, 0.9], dtype=float)\n    sA = np.array([1.0, 1.1, 0.9, 1.2, 1.0, 1.0, 1.1, 0.9, 1.0, 1.2, 1.1, 1.0], dtype=float)\n\n    # Case B\n    yB = np.array([0.1, -0.3, 0.5, -0.2, 0.0, 0.4, -0.6, 0.2], dtype=float)\n    sB = np.array([0.5, 0.6, 0.4, 0.5, 0.4, 0.5, 0.6, 0.5], dtype=float)\n\n    # Case C\n    yC = np.array([8.0, -7.5, 5.2, -6.1, 7.9, -5.3, 6.8, -7.2, 5.5, -6.4], dtype=float)\n    sC = np.array([2.0, 1.5, 2.5, 1.8, 2.2, 1.7, 2.1, 1.6, 2.4, 1.9], dtype=float)\n\n    # Case D\n    yD = np.array([0.10, 0.12, -0.05, 0.08, -0.02, 0.03, -0.07, 0.09, -0.01, 0.04], dtype=float)\n    sD = np.array([0.05]*10, dtype=float)\n\n    test_cases = [\n        (yA, sA),\n        (yB, sB),\n        (yC, sC),\n        (yD, sD),\n    ]\n\n    results = []\n    for y, sig in test_cases:\n        sj = estimate_sigma_jit_mle(y, sig)\n        # Round to three decimals as required\n        results.append(f\"{sj:.3f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}