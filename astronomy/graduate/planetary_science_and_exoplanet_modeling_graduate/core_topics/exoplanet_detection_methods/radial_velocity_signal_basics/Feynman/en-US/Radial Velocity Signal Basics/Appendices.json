{
    "hands_on_practices": [
        {
            "introduction": "Understanding the radial velocity method begins with a fundamental question: how large is the signal we are trying to detect? This exercise provides a first-principles approach to this question by deriving the expected semi-amplitude ($K$) of a star's reflex motion due to a planetary companion. By applying this derivation to the familiar Sun-Jupiter system, you will develop a physical intuition for the scale of RV signals and how they depend on the planet's mass and orbital separation, a crucial skill for assessing the feasibility of exoplanet detection .",
            "id": "4174736",
            "problem": "A solar-type star of mass $M_{\\odot}$ and a single planet of mass $m_{p}$ form a bound two-body system on a circular orbit of period $P$ and relative semi-major axis $a$ (the separation between the star and the planet). The star executes a reflex motion about the system barycenter that produces a line-of-sight velocity signal known as the radial velocity (RV). Assume the orbit is edge-on to the observer (inclination $i=\\pi/2$) and has zero eccentricity. Starting from Newton's laws, the definition of the center of mass, and uniform circular motion, derive an expression for the star's RV semi-amplitude $K$ (the maximum absolute value of the star's line-of-sight velocity) in terms of $M_{\\odot}$, $m_{p}$, $a$, $P$, and $i$.\n\nThen, using your derived expression, compute:\n- The expected RV semi-amplitude for the Sun due to Jupiter, taking $P=11.86$ yr, $a=5.2$ au, $M_{\\odot}=1.9885\\times 10^{30}$ kg, and $m_{p}=m_{\\mathrm{J}}=1.8982\\times 10^{27}$ kg.\n- The scaling ratio of the Jupiter-induced semi-amplitude to that of an Earth analog orbiting the Sun, taking $P_{\\oplus}=1.000$ yr, $a_{\\oplus}=1.000$ au, and $m_{\\oplus}=5.9722\\times 10^{24}$ kg.\n\nUse the unit conversions $1\\,\\mathrm{au}=1.495978707\\times 10^{11}$ m and $1\\,\\mathrm{yr}=3.15576\\times 10^{7}$ s. Express the Jupiter semi-amplitude in $\\mathrm{m\\,s^{-1}}$ and the ratio as a pure decimal. Round your numerical results to four significant figures. Provide the final answer as a row matrix containing first the Jupiter semi-amplitude and second the ratio.",
            "solution": "The problem requires the derivation of the stellar radial velocity (RV) semi-amplitude, $K$, for a two-body system in a circular orbit, followed by numerical calculations for specific cases. The derivation must start from fundamental principles.\n\n### Part 1: Derivation of the RV Semi-Amplitude $K$\n\nWe consider a system consisting of a star of mass $M_s$ and a planet of mass $m_p$. The total mass of the system is $M_{tot} = M_s + m_p$. According to Newton's laws, in the absence of external forces, the star and the planet orbit their common center of mass (the barycenter).\n\nLet's place the origin of our coordinate system at the barycenter. The position vectors of the star, $\\vec{r}_s$, and the planet, $\\vec{r}_p$, satisfy the definition of the center of mass:\n$$M_s \\vec{r}_s + m_p \\vec{r}_p = \\vec{0}$$\nThe separation vector between the planet and the star is given by $\\vec{a} = \\vec{r}_p - \\vec{r}_s$. Its magnitude, $a=|\\vec{a}|$, is the orbital separation, which is constant for a circular orbit.\n\nWe can express the star's position vector, $\\vec{r}_s$, in terms of the separation vector, $\\vec{a}$. From the center of mass equation, we have $\\vec{r}_p = -\\frac{M_s}{m_p}\\vec{r}_s$. Substituting this into the separation vector equation gives:\n$$\\vec{a} = \\left(-\\frac{M_s}{m_p}\\right)\\vec{r}_s - \\vec{r}_s = -\\left(\\frac{M_s + m_p}{m_p}\\right)\\vec{r}_s$$\nSolving for $\\vec{r}_s$, we find:\n$$\\vec{r}_s = -\\frac{m_p}{M_s + m_p} \\vec{a}$$\nThis equation shows that the star orbits the barycenter in a path that is a scaled-down version of the planet's orbit relative to the star. Since the overall orbit is circular with a constant separation $a$, the star must execute a circular orbit around the barycenter. The radius of the star's orbit, $a_s$, is the magnitude of $\\vec{r}_s$:\n$$a_s = |\\vec{r}_s| = \\frac{m_p}{M_s + m_p} a$$\nThe star travels along this circular path with a period $P$, which is the orbital period of the system. For uniform circular motion, the star's orbital speed, $v_s$, is constant and is given by the circumference of its orbit divided by the period:\n$$v_s = \\frac{2\\pi a_s}{P}$$\nSubstituting the expression for $a_s$, we get the star's orbital speed:\n$$v_s = \\frac{2\\pi}{P} \\left( \\frac{m_p a}{M_s + m_p} \\right)$$\nThe radial velocity, $v_r$, is the component of the star's orbital velocity vector, $\\vec{v}_s$, along the observer's line-of-sight. This observed velocity varies sinusoidally as the star completes its orbit. The maximum value of this varying velocity depends on the inclination angle $i$ of the orbit, which is the angle between the normal to the orbital plane and the line of sight. The maximum observed line-of-sight velocity, or the RV semi-amplitude $K$, is given by:\n$$K = v_s \\sin(i)$$\nSubstituting the expression for $v_s$ gives the general formula for the RV semi-amplitude:\n$$K = \\frac{2\\pi a}{P} \\frac{m_p}{M_s + m_p} \\sin(i)$$\nThe problem specifies an edge-on orbit, which means the observer is in the plane of the orbit. In this case, the inclination is $i=\\pi/2$ radians, and $\\sin(i) = \\sin(\\pi/2) = 1$. The expression for the problem's configuration, using $M_{\\odot}$ for the star's mass, is therefore:\n$$K = \\frac{2\\pi a}{P} \\frac{m_p}{M_{\\odot} + m_p}$$\n\n### Part 2: Numerical Calculation for Sun-Jupiter System\n\nWe now compute the expected RV semi-amplitude $K_J$ for the Sun due to Jupiter's orbit. The given values are:\n- Star mass: $M_{\\odot} = 1.9885 \\times 10^{30}\\,\\mathrm{kg}$\n- Planet mass (Jupiter): $m_J = 1.8982 \\times 10^{27}\\,\\mathrm{kg}$\n- Orbital period: $P_J = 11.86\\,\\mathrm{yr}$\n- Orbital separation: $a_J = 5.2\\,\\mathrm{au}$\n\nWe must first convert the period and separation to SI units:\n$$P_J = 11.86\\,\\mathrm{yr} \\times (3.15576 \\times 10^7\\,\\mathrm{s/yr}) = 3.74273136 \\times 10^8\\,\\mathrm{s}$$\n$$a_J = 5.2\\,\\mathrm{au} \\times (1.495978707 \\times 10^{11}\\,\\mathrm{m/au}) = 7.7790892764 \\times 10^{11}\\,\\mathrm{m}$$\nThe total mass of the Sun-Jupiter system is:\n$$M_{\\odot} + m_J = 1.9885 \\times 10^{30}\\,\\mathrm{kg} + 1.8982 \\times 10^{27}\\,\\mathrm{kg} = 1.9903982 \\times 10^{30}\\,\\mathrm{kg}$$\nNow we substitute these values into our derived formula for $K$:\n$$K_J = \\frac{2\\pi (7.7790892764 \\times 10^{11}\\,\\mathrm{m})}{3.74273136 \\times 10^8\\,\\mathrm{s}} \\times \\frac{1.8982 \\times 10^{27}\\,\\mathrm{kg}}{1.9903982 \\times 10^{30}\\,\\mathrm{kg}}$$\n$$K_J \\approx (13059.54\\,\\mathrm{m/s}) \\times (9.53676 \\times 10^{-4})$$\n$$K_J \\approx 12.4556\\,\\mathrm{m/s}$$\nRounding to four significant figures, the RV semi-amplitude for the Sun due to Jupiter is $12.46\\,\\mathrm{m\\,s^{-1}}$.\n\n### Part 3: Scaling Ratio Calculation\n\nNext, we compute the ratio of the Jupiter-induced semi-amplitude to that of an Earth analog. The parameters for the Earth analog are:\n- Planet mass (Earth): $m_{\\oplus} = 5.9722 \\times 10^{24}\\,\\mathrm{kg}$\n- Orbital period: $P_{\\oplus} = 1.000\\,\\mathrm{yr}$\n- Orbital separation: $a_{\\oplus} = 1.000\\,\\mathrm{au}$\n\nThe ratio is given by $\\frac{K_J}{K_{\\oplus}}$. We can write this as:\n$$\\frac{K_J}{K_{\\oplus}} = \\frac{\\frac{2\\pi a_J}{P_J} \\frac{m_J}{M_{\\odot} + m_J}}{\\frac{2\\pi a_{\\oplus}}{P_{\\oplus}} \\frac{m_{\\oplus}}{M_{\\odot} + m_{\\oplus}}} = \\left(\\frac{a_J}{a_{\\oplus}}\\right) \\left(\\frac{P_{\\oplus}}{P_J}\\right) \\left(\\frac{m_J}{m_{\\oplus}}\\right) \\left(\\frac{M_{\\odot} + m_{\\oplus}}{M_{\\odot} + m_J}\\right)$$\nWe can use the given values directly in these ratios:\n- $\\frac{a_J}{a_{\\oplus}} = \\frac{5.2\\,\\mathrm{au}}{1.000\\,\\mathrm{au}} = 5.2$\n- $\\frac{P_{\\oplus}}{P_J} = \\frac{1.000\\,\\mathrm{yr}}{11.86\\,\\mathrm{yr}} \\approx 0.08431703$\n- $\\frac{m_J}{m_{\\oplus}} = \\frac{1.8982 \\times 10^{27}\\,\\mathrm{kg}}{5.9722 \\times 10^{24}\\,\\mathrm{kg}} \\approx 317.8347$\n- $\\frac{M_{\\odot} + m_{\\oplus}}{M_{\\odot} + m_J} = \\frac{1.9885 \\times 10^{30} + 5.9722 \\times 10^{24}}{1.9885 \\times 10^{30} + 1.8982 \\times 10^{27}} = \\frac{1.9885059722 \\times 10^{30}}{1.9903982 \\times 10^{30}} \\approx 0.9990491$\n\nMultiplying these factors:\n$$\\frac{K_J}{K_{\\oplus}} \\approx 5.2 \\times 0.08431703 \\times 317.8347 \\times 0.9990491$$\n$$\\frac{K_J}{K_{\\oplus}} \\approx 139.231$$\nRounding to four significant figures, the scaling ratio is $139.2$.",
            "answer": "$$\\boxed{\\begin{pmatrix} 12.46  139.2 \\end{pmatrix}}$$"
        },
        {
            "introduction": "While the semi-amplitude provides the scale of the RV signal, its true diagnostic power lies in its detailed shape over time, which encodes the full set of orbital parameters. This practice challenges you to build a complete computational model of a Keplerian RV curve from the ground up, translating an observation time into a precise velocity measurement. Mastering this process, from solving Kepler's equation numerically to applying the final velocity formula, is a core competency for modeling and interpreting RV data .",
            "id": "4174705",
            "problem": "You are to write a complete program that computes the line-of-sight stellar radial velocity induced by a single Keplerian companion at specified observation epochs. The program must implement the full mapping from time to true anomaly and then to radial velocity using first principles suitable for a two-body elliptical orbit, and it must not rely on any pre-tabulated or black-box orbital solution. Begin from fundamental laws and core definitions for Keplerian motion: the conservation of angular momentum, the constancy of areal velocity, and the definition of the mean anomaly as uniform in time for a bound ellipse. Build your solution by following these steps for each test case:\n- From the given orbital period $P$, eccentricity $e$, time of periastron passage $T_0$, and an observation time $t$, compute the mean anomaly $M$ from a uniform angular rate consistent with the area law. Ensure $M$ is put on a convenient principal branch.\n- Using the equivalence of mean area swept and eccentric anomaly, solve the transcendental equation linking $M$ and the eccentric anomaly $E$ for an ellipse. This equation is monotonic for $E \\in [0,2\\pi)$ and $e \\in [0,1)$, and it admits a unique solution for a given pair $(M,e)$ in this domain.\n- Convert the eccentric anomaly $E$ to the true anomaly $\\nu$ using only geometric relations between the auxiliary circle and the ellipse.\n- Evaluate the starâ€™s radial velocity along the line of sight under the standard single-planet reflex model for a Keplerian orbit, with a given semi-amplitude $K$, argument of periastron $\\omega$, and systemic velocity $\\gamma$. Assume angles are in radians. You must compute the final radial velocity in meters per second.\n\nPhysical and numerical units:\n- Period $P$, times $T_0$ and $t$ are in days.\n- Angles $M$, $E$, $\\nu$, and $\\omega$ are in radians.\n- The returned radial velocity must be expressed in meters per second (m/s) as a floating-point number.\n\nYour program must implement a robust numerical method to solve the transcendental equation for the eccentric anomaly $E$ for all eccentricities $e$ in $[0,1)$, including high eccentricity cases close to unity. The method must provide solutions accurate to within a relative tolerance of at most $10^{-10}$ in $E$.\n\nTest suite:\nFor each of the following parameter sets $(P,e,T_0,t,K,\\omega,\\gamma)$, compute the radial velocity value as specified above and express the result in meters per second. The test suite covers typical, circular, and high-eccentricity cases, as well as periastron and apastron alignments.\n- Case $1$: $(P,e,T_0,t,K,\\omega,\\gamma) = (\\,20.0,\\,0.25,\\,0.0,\\,5.0,\\,3.2,\\,1.1,\\,0.5\\,)$\n- Case $2$: $(P,e,T_0,t,K,\\omega,\\gamma) = (\\,10.0,\\,0.0,\\,0.0,\\,\\tfrac{10.0}{6.0},\\,10.0,\\,2.0,\\,0.0\\,)$\n- Case $3$: $(P,e,T_0,t,K,\\omega,\\gamma) = (\\,100.0,\\,0.8,\\,1000.0,\\,1000.0,\\,50.0,\\,0.3,\\,2.0\\,)$\n- Case $4$: $(P,e,T_0,t,K,\\omega,\\gamma) = (\\,50.0,\\,0.6,\\,500.0,\\,525.0,\\,20.0,\\,2.4,\\,-1.0\\,)$\n- Case $5$: $(P,e,T_0,t,K,\\omega,\\gamma) = (\\,365.25,\\,0.9,\\,0.0,\\,182.625,\\,5.0,\\,1.7,\\,0.0\\,)$\n\nFinal output format:\n- Your program should produce a single line of output containing the $5$ results as a comma-separated list enclosed in square brackets, in the order of the cases above. For example: $[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4,\\text{result}_5]$.\n- Each $\\text{result}_i$ must be a floating-point number representing the radial velocity in $\\text{m/s}$ at the corresponding epoch.",
            "solution": "The problem is valid as it is scientifically grounded in Keplerian mechanics, well-posed with a complete and consistent set of parameters, and stated objectively. The parameters provided in the test suite are physically realistic for exoplanetary systems.\n\nThe solution proceeds by mapping the observation time $t$ to the predicted stellar radial velocity $V_r$ through a sequence of deterministic calculations based on the principles of two-body orbital mechanics.\n\nStep 1: Computation of the Mean Anomaly ($M$)\nThe mean anomaly, $M$, is an angle that increases linearly with time, representing the fraction of the orbital period that has elapsed since the companion's last periastron passage. It is defined based on Kepler's Second Law, which implies a constant areal velocity. The mean motion, $n$, is the average angular speed over one orbit, given by $n = 2\\pi / P$, where $P$ is the orbital period. The mean anomaly at a given observation time $t$ is then calculated relative to the time of periastron passage, $T_0$.\n$$\nM(t) = n (t - T_0) = \\frac{2\\pi}{P} (t - T_0)\n$$\nTo handle multiple orbits and to establish a standard interval, the mean anomaly is typically expressed on the principal domain $[0, 2\\pi)$ by taking the value modulo $2\\pi$.\n$$\nM = \\left( \\frac{2\\pi}{P} (t - T_0) \\right) \\pmod{2\\pi}\n$$\n\nStep 2: Solution of Kepler's Equation for the Eccentric Anomaly ($E$)\nThe eccentric anomaly, $E$, is a geometric parameter that relates the position of an object on an elliptical orbit to a corresponding point on the ellipse's auxiliary circle. The relationship between the mean anomaly $M$ and the eccentric anomaly $E$ is given by Kepler's equation:\n$$\nM = E - e \\sin E\n$$\nwhere $e$ is the orbital eccentricity. This is a transcendental equation for $E$ and generally does not have an analytical solution, thus requiring a numerical method. We seek the root of the function $f(E) = E - e \\sin E - M$.\nThe Newton-Raphson method is a powerful and rapidly converging iterative technique for finding roots. Given an estimate $E_k$, the next, improved estimate $E_{k+1}$ is given by:\n$$\nE_{k+1} = E_k - \\frac{f(E_k)}{f'(E_k)}\n$$\nThe derivative of $f(E)$ with respect to $E$ is $f'(E) = 1 - e \\cos E$. For a bound orbit, the eccentricity $e$ is in the range $[0, 1)$, which ensures that $f'(E)  0$. This guarantees that $f(E)$ is strictly monotonic, so for any given $M$, a unique solution for $E$ exists. The iteration formula is:\n$$\nE_{k+1} = E_k - \\frac{E_k - e \\sin E_k - M}{1 - e \\cos E_k}\n$$\nThe iteration starts with an initial guess $E_0$ (e.g., $E_0 = M$) and is repeated until the change between successive iterations, $|E_{k+1} - E_k|$, falls below a specified tolerance, such as $10^{-12}$, which satisfies the problem's requirement for a relative tolerance of at most $10^{-10}$ for all relevant values of $E$.\n\nStep 3: Conversion to the True Anomaly ($\\nu$)\nThe true anomaly, $\\nu$, is the angle between the direction of periastron and the current position of the orbiting body, as seen from the central body (the focus of the ellipse). It is the true geometric angle in the orbital plane. The true anomaly can be derived from the eccentric anomaly $E$ using the geometric properties of the ellipse. The relationship between the coordinates on the auxiliary circle and on the ellipse leads to the following relations:\n$$\n\\cos \\nu = \\frac{\\cos E - e}{1 - e \\cos E}\n$$\n$$\n\\sin \\nu = \\frac{\\sqrt{1 - e^2} \\sin E}{1 - e \\cos E}\n$$\nTo robustly determine $\\nu$ in its correct quadrant $[0, 2\\pi)$, the two-argument arctangent function, $\\operatorname{atan2}(y, x)$, is employed:\n$$\n\\nu = \\operatorname{atan2}\\left(\\sqrt{1 - e^2} \\sin E, \\cos E - e\\right)\n$$\n\nStep 4: Computation of the Stellar Radial Velocity ($V_r$)\nThe observable radial velocity of the star is the projection of its orbital velocity vector onto the line of sight, superimposed on the constant velocity of the system's barycenter relative to the observer. This systemic velocity is denoted by $\\gamma$. The formula for the star's radial velocity at time $t$ is:\n$$\nV_r(t) = K \\left[ \\cos(\\nu(t) + \\omega) + e \\cos(\\omega) \\right] + \\gamma\n$$\nIn this expression, $K$ is the radial velocity semi-amplitude, which is the maximum variation of the star's orbital radial velocity. The angle $\\omega$ is the argument of periastron, which specifies the orientation of the ellipse in the orbital plane relative to the line of sight. The term $\\cos(\\nu(t)+\\omega)$ represents the primary varying component of the velocity, while the term $e \\cos(\\omega)$ is a constant offset that arises due to the eccentricity of the orbit and ensures that the time-average of the orbital component of the velocity is zero.\n\nThe overall procedure, executed for each test case, is to compute $M$ from the input times, solve for $E$ numerically, convert $E$ to $\\nu$, and finally substitute $\\nu$ into the radial velocity formula to obtain the final result.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve_kepler(M, e, tol=1e-12, max_iter=100):\n    \"\"\"\n    Solves Kepler's equation M = E - e*sin(E) for E using Newton-Raphson method.\n\n    Args:\n        M (float): Mean anomaly in radians.\n        e (float): Eccentricity (0 = e  1).\n        tol (float): Absolute tolerance for convergence of E.\n        max_iter (int): Maximum number of iterations.\n\n    Returns:\n        float: Eccentric anomaly E in radians.\n    \"\"\"\n    if e == 0.0:\n        return M\n\n    # An initial guess for E. M is a good guess for low e.\n    # For high e, M is not a great guess. M + e is a better heuristic.\n    E = M + e * np.sign(np.sin(M))\n    if E == M and M  0.1: # Catch cases where sin(M) is 0\n        E = M + e\n        \n    for _ in range(max_iter):\n        E_prev = E\n        # Newton-Raphson step\n        # f(E) = E - e*sin(E) - M\n        # f'(E) = 1 - e*cos(E)\n        f_E = E_prev - e * np.sin(E_prev) - M\n        fp_E = 1.0 - e * np.cos(E_prev)\n        \n        # The update step\n        E = E_prev - f_E / fp_E\n        \n        # Check for convergence\n        if abs(E - E_prev)  tol:\n            return E\n            \n    # If the loop finishes without converging (highly unlikely for valid inputs),\n    # return the last computed value.\n    return E\n\ndef calculate_radial_velocity(P, e, T0, t, K, omega, gamma):\n    \"\"\"\n    Computes the stellar radial velocity for a single Keplerian companion.\n\n    Args:\n        P (float): Orbital period in days.\n        e (float): Eccentricity.\n        T0 (float): Time of periastron passage in days.\n        t (float): Observation time in days.\n        K (float): RV semi-amplitude in m/s.\n        omega (float): Argument of periastron in radians.\n        gamma (float): Systemic velocity in m/s.\n\n    Returns:\n        float: The radial velocity in m/s.\n    \"\"\"\n    # Step 1: Compute Mean Anomaly (M)\n    # Mean motion n = 2*pi/P\n    # M = n * (t - T0)\n    # Ensure M is on the principal branch [0, 2*pi)\n    M = (2.0 * np.pi / P * (t - T0)) % (2.0 * np.pi)\n\n    # Step 2: Solve Kepler's Equation for Eccentric Anomaly (E)\n    E = solve_kepler(M, e)\n\n    # Step 3: Convert Eccentric Anomaly (E) to True Anomaly (nu)\n    # A robust way using atan2 to resolve quadrant ambiguity\n    # nu = atan2(sqrt(1-e^2)*sin(E), cos(E)-e)\n    cos_E = np.cos(E)\n    sin_E = np.sin(E)\n    nu = np.arctan2(np.sqrt(1.0 - e**2) * sin_E, cos_E - e)\n\n    # Step 4: Evaluate the Radial Velocity (Vr)\n    # Vr = K * (cos(omega + nu) + e * cos(omega)) + gamma\n    vr = K * (np.cos(omega + nu) + e * np.cos(omega)) + gamma\n    \n    return vr\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # (P, e, T0, t, K, omega, gamma)\n    test_cases = [\n        (20.0, 0.25, 0.0, 5.0, 3.2, 1.1, 0.5),\n        (10.0, 0.0, 0.0, 10.0 / 6.0, 10.0, 2.0, 0.0),\n        (100.0, 0.8, 1000.0, 1000.0, 50.0, 0.3, 2.0),\n        (50.0, 0.6, 500.0, 525.0, 20.0, 2.4, -1.0),\n        (365.25, 0.9, 0.0, 182.625, 5.0, 1.7, 0.0)\n    ]\n\n    results = []\n    for case in test_cases:\n        P, e, T0, t, K, omega, gamma = case\n        result = calculate_radial_velocity(P, e, T0, t, K, omega, gamma)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.10f}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "In real-world observations, the clean signature of a Keplerian orbit is often contaminated by the star's own intrinsic variability, known as stellar activity. This advanced practice moves from idealized models to the critical task of data diagnostics, equipping you with the tools to distinguish a genuine planetary signal from an activity-induced impostor. By analyzing simulated time series data, you will learn to use common activity proxies to quantify their correlation with measured radial velocities and assess their impact, a fundamental step in vetting any potential exoplanet candidate .",
            "id": "4174640",
            "problem": "You are given four deterministic time series test cases that emulate typical stellar radial velocity activity diagnostics and their relation to measured radial velocities. For each test case, you will be provided arrays representing time in days, the measured line-of-sight radial velocity (in $\\mathrm{m/s}$), its measurement uncertainty (in $\\mathrm{m/s}$), and three activity proxies: the Bisector Inverse Slope (BIS, in $\\mathrm{m/s}$), the Full Width at Half Maximum (FWHM, in $\\mathrm{m/s}$), and the Mount Wilson $S$-index (dimensionless). Your task is to evaluate the correlations between radial velocity and each activity proxy and to quantify the fraction of radial velocity variance explained by a linear combination of the proxies using a weighted linear model.\n\nFundamental base:\n- The radial velocity is the projection of the stellar velocity along the line of sight and is modeled as a time series $y_i$ with measurement uncertainties $\\sigma_i$ at times $t_i$.\n- Activity proxies such as the Bisector Inverse Slope (BIS), Full Width at Half Maximum (FWHM), and Mount Wilson $S$-index reflect line profile changes and chromospheric activity that can correlate with apparent radial velocity signals.\n- The Pearson correlation coefficient between two series is a standardized measure of linear association based on covariance and standard deviation.\n- A weighted linear model with an intercept minimizes the sum of weighted squared residuals, with weights $w_i$ proportional to the inverse variance, $w_i = 1/\\sigma_i^2$, yielding a best-fit linear combination of predictors. The fraction of variance explained is quantified by the coefficient of determination defined relative to the weighted variance about the weighted mean.\n\nFor each test case, compute:\n1. The Pearson correlation coefficient between the radial velocity series $y$ and each proxy series (BIS, FWHM, $S$-index), expressed as floats. If a series has zero standard deviation, define the correlation as $0.0$ by convention.\n2. The fraction of radial velocity variance explained by a weighted linear model $y = \\beta_0 + \\beta_{\\mathrm{BIS}}\\cdot \\mathrm{BIS} + \\beta_{\\mathrm{FWHM}}\\cdot \\mathrm{FWHM} + \\beta_{S}\\cdot S + \\epsilon$ using weights $w_i = 1/\\sigma_i^2$. Use the coefficient of determination based on the weighted residual sum-of-squares relative to the weighted total sum-of-squares about the weighted mean. If the weighted total variance is exactly zero, define the fraction explained as $0.0$.\n\nPhysical units requirement:\n- Express all final results as unitless floats rounded to $4$ decimal places. While the inputs have physical units, the correlation coefficients and the coefficient of determination are unitless.\n\nAngle unit:\n- Use radians for all trigonometric function arguments.\n\nTest suite:\n- Test case $1$ (\"happy path, strong correlations, heteroscedastic weights\"):\n  - $N = 24$, $t_i = i$ for $i = 0, 1, \\dots, 23$ (days).\n  - $\\mathrm{BIS}_i = 10 \\cdot \\sin\\left(2\\pi \\cdot t_i / 12\\right)$ in $\\mathrm{m/s}$.\n  - $\\mathrm{FWHM}_i = 0.5 \\cdot \\mathrm{BIS}_i + 2$ in $\\mathrm{m/s}$.\n  - $S_i = 0.35 + 0.01 \\cdot t_i$ (dimensionless).\n  - $y_i = 3 \\cdot \\mathrm{BIS}_i + 2 \\cdot \\mathrm{FWHM}_i + 100 \\cdot (S_i - 0.35) + 0.2 \\cdot \\sin(t_i)$ in $\\mathrm{m/s}$.\n  - $\\sigma_i = 1 + 0.1 \\cdot t_i$ in $\\mathrm{m/s}$.\n- Test case $2$ (\"near-zero correlations, different periodicities\"):\n  - $N = 25$, $t_i = i$ for $i = 0, 1, \\dots, 24$ (days).\n  - $\\mathrm{BIS}_i = 5 \\cdot \\sin\\left(2\\pi \\cdot t_i / 5\\right)$ in $\\mathrm{m/s}$.\n  - $\\mathrm{FWHM}_i = 3 \\cdot \\cos\\left(2\\pi \\cdot t_i / 5\\right)$ in $\\mathrm{m/s}$.\n  - $S_i = 0.4 + 0.02 \\cdot \\sin\\left(2\\pi \\cdot t_i / 9\\right)$ (dimensionless).\n  - $y_i = 8 \\cdot \\sin\\left(2\\pi \\cdot t_i / 7\\right) + 0.5 \\cdot \\sin\\left(2\\pi \\cdot t_i / 2\\right)$ in $\\mathrm{m/s}$.\n  - $\\sigma_i = 1$ in $\\mathrm{m/s}$ for all $i$.\n- Test case $3$ (\"moderate correlations, strong collinearity, heteroscedastic weights\"):\n  - $N = 30$, $t_i = i$ for $i = 0, 1, \\dots, 29$ (days).\n  - $\\mathrm{BIS}_i = 7 \\cdot \\sin\\left(2\\pi \\cdot t_i / 15\\right) + 0.2 \\cdot t_i$ in $\\mathrm{m/s}$.\n  - $\\mathrm{FWHM}_i = 14 \\cdot \\sin\\left(2\\pi \\cdot t_i / 15\\right) + 0.4 \\cdot t_i$ in $\\mathrm{m/s}$.\n  - $S_i = 0.38 + 0.01 \\cdot \\sin\\left(2\\pi \\cdot t_i / 5\\right)$ (dimensionless).\n  - $y_i = 2 \\cdot \\mathrm{BIS}_i + 1 \\cdot \\mathrm{FWHM}_i + 120 \\cdot (S_i - 0.38) + 3 \\cdot \\cos\\left(2\\pi \\cdot t_i / 4\\right)$ in $\\mathrm{m/s}$.\n  - $\\sigma_i = 0.5 + 0.05 \\cdot (t_i \\bmod 5)$ in $\\mathrm{m/s}$.\n- Test case $4$ (\"boundary case, zero variance in radial velocity\"):\n  - $N = 10$, $t_i = i$ for $i = 0, 1, \\dots, 9$ (days).\n  - $\\mathrm{BIS}_i = 2 \\cdot \\sin\\left(2\\pi \\cdot t_i / 10\\right)$ in $\\mathrm{m/s}$.\n  - $\\mathrm{FWHM}_i = 0.1 \\cdot \\mathrm{BIS}_i + \\sin\\left(2\\pi \\cdot t_i / 3\\right)$ in $\\mathrm{m/s}$.\n  - $S_i = 0.37 + 0.01 \\cdot \\cos\\left(2\\pi \\cdot t_i / 3\\right)$ (dimensionless).\n  - $y_i = 50$ in $\\mathrm{m/s}$ for all $i$.\n  - $\\sigma_i = 1 + 0.2 \\cdot t_i$ in $\\mathrm{m/s}$.\n\nFinal output format:\n- For each test case, produce a list of four floats $[r_{\\mathrm{BIS}}, r_{\\mathrm{FWHM}}, r_S, R^2]$ rounded to $4$ decimal places, where $r_{\\mathrm{BIS}}$ is the Pearson correlation coefficient between $y$ and BIS, $r_{\\mathrm{FWHM}}$ is that between $y$ and FWHM, $r_{S}$ is that between $y$ and $S$, and $R^2$ is the weighted fraction of variance explained by the combined proxies with an intercept.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element corresponds to one test case and is itself a list of four floats, for example: $[[a_1,b_1,c_1,d_1],[a_2,b_2,c_2,d_2],[a_3,b_3,c_3,d_3],[a_4,b_4,c_4,d_4]]$.",
            "solution": "The user requests the analysis of four simulated stellar radial velocity time series. For each case, we must compute the Pearson correlation coefficients between the radial velocity and three activity proxies, and subsequently determine the fraction of variance in the radial velocity explained by a weighted linear model incorporating these proxies.\n\nThe analysis proceeds in two main steps for each test case:\n1.  Calculation of Pearson correlation coefficients.\n2.  Calculation of the weighted coefficient of determination ($R^2$) from a multivariate linear regression.\n\n### 1. Pearson Correlation Coefficient\n\nThe Pearson correlation coefficient, $r_{XY}$, quantifies the linear relationship between two data series, $X$ and $Y$, each of length $N$. The formula is:\n$$\nr_{XY} = \\frac{\\sum_{i=1}^{N}(X_i - \\bar{X})(Y_i - \\bar{Y})}{\\sqrt{\\sum_{i=1}^{N}(X_i - \\bar{X})^2 \\sum_{i=1}^{N}(Y_i - \\bar{Y})^2}}\n$$\nwhere $\\bar{X}$ and $\\bar{Y}$ are the sample means of the series $X$ and $Y$, respectively. The numerator is the covariance between $X$ and $Y$, and the denominator is the product of their standard deviations. The value of $r_{XY}$ ranges from $-1$ to $+1$, indicating perfect negative and positive linear correlation, respectively, with $0$ indicating no linear correlation.\n\nFor this problem, we calculate three correlation coefficients for each test case: $r_{\\mathrm{BIS}}$ (between radial velocity $y$ and proxy BIS), $r_{\\mathrm{FWHM}}$ (between $y$ and FWHM), and $r_{S}$ (between $y$ and the $S$-index). Per the problem specification, if a series has a standard deviation of zero, the correlation coefficient is defined to be $0.0$.\n\n### 2. Weighted Linear Regression and Coefficient of Determination ($R^2$)\n\nThe second task is to model the radial velocity $y_i$ as a linear function of the activity proxies. The model includes an intercept term $\\beta_0$:\n$$\ny_i = \\beta_0 + \\beta_{\\mathrm{BIS}}\\cdot \\mathrm{BIS}_i + \\beta_{\\mathrm{FWHM}}\\cdot \\mathrm{FWHM}_i + \\beta_{S}\\cdot S_i + \\epsilon_i\n$$\nwhere $\\epsilon_i$ represents the residual error for the $i$-th observation. In matrix notation, this is expressed as $\\mathbf{y} = \\mathbf{X}\\boldsymbol{\\beta} + \\boldsymbol{\\epsilon}$, where:\n-   $\\mathbf{y}$ is the $N \\times 1$ vector of observed radial velocities.\n-   $\\mathbf{X}$ is the $N \\times 4$ design matrix, whose columns are a vector of ones (for the intercept), the BIS vector, the FWHM vector, and the $S$-index vector.\n-   $\\boldsymbol{\\beta}$ is the $4 \\times 1$ vector of coefficients to be estimated: $[\\beta_0, \\beta_{\\mathrm{BIS}}, \\beta_{\\mathrm{FWHM}}, \\beta_S]^T$.\n-   $\\boldsymbol{\\epsilon}$ is the $N \\times 1$ vector of errors.\n\nThe problem requires a weighted linear regression, where each observation is weighted by the inverse of its variance, $w_i = 1/\\sigma_i^2$. This method, known as Weighted Least Squares (WLS), finds the coefficient vector $\\hat{\\boldsymbol{\\beta}}$ that minimizes the weighted sum of squared residuals:\n$$\n\\chi^2 = \\sum_{i=1}^{N} w_i (y_i - \\hat{y}_i)^2\n$$\nwhere $\\hat{y}_i$ are the model-predicted values. This minimization problem can be solved by transforming it into an ordinary least squares (OLS) problem. Let $\\mathbf{W}$ be a diagonal matrix with entries $w_i$. We define transformed variables $\\mathbf{y}' = \\mathbf{L}\\mathbf{y}$ and $\\mathbf{X}' = \\mathbf{L}\\mathbf{X}$, where $\\mathbf{L}$ is a diagonal matrix with entries $L_{ii} = \\sqrt{w_i}$. The problem then becomes minimizing $||\\mathbf{y}' - \\mathbf{X}'\\boldsymbol{\\beta}||^2$, which can be solved robustly for $\\hat{\\boldsymbol{\\beta}}$ using numerical methods such as those provided by `numpy.linalg.lstsq`. This approach is stable even in cases of multicollinearity among the predictors (as in Test Case 3).\n\nOnce the coefficients $\\hat{\\boldsymbol{\\beta}}$ are determined, the model predictions are calculated as $\\hat{\\mathbf{y}} = \\mathbf{X}\\hat{\\boldsymbol{\\beta}}$. The fraction of variance explained is quantified by the weighted coefficient of determination, $R^2$:\n$$\nR^2 = 1 - \\frac{SS_{res, w}}{SS_{tot, w}}\n$$\n-   The weighted residual sum of squares is $SS_{res, w} = \\sum_{i=1}^{N} w_i (y_i - \\hat{y}_i)^2$.\n-   The weighted total sum of squares is $SS_{tot, w} = \\sum_{i=1}^{N} w_i (y_i - \\bar{y}_w)^2$.\n-   The weighted mean of the radial velocity is $\\bar{y}_w = \\frac{\\sum_{i=1}^{N} w_i y_i}{\\sum_{i=1}^{N} w_i}$.\n\nIn the special case where the weighted total variance (and thus $SS_{tot, w}$) is zero (as in Test Case 4), $R^2$ is defined to be $0.0$.\n\nFor each test case, the necessary time series are generated, followed by the calculation of the three correlation coefficients and the single $R^2$ value. All final results are rounded to four decimal places.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef generate_test_case_data(case_id):\n    \"\"\"\n    Generates the time series data for a specific test case.\n    \"\"\"\n    if case_id == 1:\n        N = 24\n        t = np.arange(N, dtype=float)\n        bis = 10.0 * np.sin(2.0 * np.pi * t / 12.0)\n        fwhm = 0.5 * bis + 2.0\n        s_idx = 0.35 + 0.01 * t\n        y = 3.0 * bis + 2.0 * fwhm + 100.0 * (s_idx - 0.35) + 0.2 * np.sin(t)\n        sigma = 1.0 + 0.1 * t\n    elif case_id == 2:\n        N = 25\n        t = np.arange(N, dtype=float)\n        bis = 5.0 * np.sin(2.0 * np.pi * t / 5.0)\n        fwhm = 3.0 * np.cos(2.0 * np.pi * t / 5.0)\n        s_idx = 0.4 + 0.02 * np.sin(2.0 * np.pi * t / 9.0)\n        y = 8.0 * np.sin(2.0 * np.pi * t / 7.0) + 0.5 * np.sin(2.0 * np.pi * t / 2.0)\n        sigma = np.ones(N)\n    elif case_id == 3:\n        N = 30\n        t = np.arange(N, dtype=float)\n        bis = 7.0 * np.sin(2.0 * np.pi * t / 15.0) + 0.2 * t\n        fwhm = 14.0 * np.sin(2.0 * np.pi * t / 15.0) + 0.4 * t\n        s_idx = 0.38 + 0.01 * np.sin(2.0 * np.pi * t / 5.0)\n        y = 2.0 * bis + 1.0 * fwhm + 120.0 * (s_idx - 0.38) + 3.0 * np.cos(2.0 * np.pi * t / 4.0)\n        sigma = 0.5 + 0.05 * (t % 5)\n    elif case_id == 4:\n        N = 10\n        t = np.arange(N, dtype=float)\n        bis = 2.0 * np.sin(2.0 * np.pi * t / 10.0)\n        fwhm = 0.1 * bis + np.sin(2.0 * np.pi * t / 3.0)\n        s_idx = 0.37 + 0.01 * np.cos(2.0 * np.pi * t / 3.0)\n        y = np.full(N, 50.0)\n        sigma = 1.0 + 0.2 * t\n    else:\n        raise ValueError(\"Invalid case_id\")\n\n    return y, sigma, bis, fwhm, s_idx\n\ndef calculate_metrics(y, sigma, bis, fwhm, s_idx):\n    \"\"\"\n    Calculates Pearson correlations and the weighted R^2 value.\n    \"\"\"\n    # 1. Pearson Correlation Coefficients\n    def safe_corrcoef(series1, series2):\n        if np.std(series1) == 0.0 or np.std(series2) == 0.0:\n            return 0.0\n        return np.corrcoef(series1, series2)[0, 1]\n\n    r_bis = safe_corrcoef(y, bis)\n    r_fwhm = safe_corrcoef(y, fwhm)\n    r_s = safe_corrcoef(y, s_idx)\n    \n    # 2. Weighted Coefficient of Determination (R^2)\n    # Construct design matrix X with an intercept\n    X = np.c_[np.ones_like(y), bis, fwhm, s_idx]\n    \n    # Calculate weights\n    w = 1.0 / sigma**2\n    \n    # Calculate weighted total sum of squares (SST_w)\n    y_weighted_mean = np.sum(w * y) / np.sum(w)\n    ss_tot_w = np.sum(w * (y - y_weighted_mean)**2)\n    \n    # Handle the boundary case of zero total variance\n    if ss_tot_w == 0.0:\n        R2 = 0.0\n    else:\n        # Solve the weighted least squares problem by transforming to OLS\n        # L is a diagonal matrix with sqrt(w_i)\n        L = np.sqrt(w)\n        # Transform variables: y' = Ly, X' = LX\n        y_prime = y * L\n        X_prime = X * L[:, np.newaxis]\n        \n        # Solve for coefficients using lstsq for numerical stability\n        beta_hat, _, _, _ = np.linalg.lstsq(X_prime, y_prime, rcond=None)\n        \n        # Calculate predicted values\n        y_hat = X @ beta_hat\n        \n        # Calculate weighted residual sum of squares (SSR_w)\n        ss_res_w = np.sum(w * (y - y_hat)**2)\n        \n        # Calculate R^2\n        R2 = 1.0 - ss_res_w / ss_tot_w\n\n    return [round(val, 4) for val in [r_bis, r_fwhm, r_s, R2]]\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases.\n    \"\"\"\n    test_cases = [1, 2, 3, 4]\n    results = []\n    \n    for case_id in test_cases:\n        # Generate data for the current test case\n        y, sigma, bis, fwhm, s_idx = generate_test_case_data(case_id)\n        \n        # Calculate the required metrics\n        metrics = calculate_metrics(y, sigma, bis, fwhm, s_idx)\n        results.append(metrics)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}