{
    "hands_on_practices": [
        {
            "introduction": "在对完整的径向速度时间序列进行建模之前，理解是哪些物理属性决定了信号的强度至关重要。本实践将指导您从牛顿运动定律和质心定义等基本原理出发，推导出径向速度半振幅 $K$ 的表达式。通过为像太阳-木星这样我们熟知的系统计算 $K$ 值，这项练习有助于您对我们旨在探测的信号尺度建立起物理直觉。",
            "id": "4174736",
            "problem": "一颗质量为 $M_{\\odot}$ 的类太阳恒星和一颗质量为 $m_{p}$ 的单一行星构成一个束缚双体系统，它们在周期为 $P$、相对半长轴为 $a$（恒星与行星之间的距离）的圆形轨道上运行。恒星围绕系统质心进行反射运动，产生一种称为视向速度（RV）的视向速度信号。假设轨道对观测者是侧向的（轨道倾角 $i=\\pi/2$），且偏心率为零。从牛顿定律、质心定义和匀速圆周运动出发，推导恒星视向速度半振幅 $K$（恒星视向速度的最大绝对值）的表达式，用 $M_{\\odot}$、$m_{p}$、$a$、$P$ 和 $i$ 表示。\n\n然后，使用你推导的表达式计算：\n- 由木星引起的太阳的预期视向速度半振幅，取 $P=11.86$ 年，$a=5.2$ au，$M_{\\odot}=1.9885\\times 10^{30}$ kg，以及 $m_{p}=m_{\\mathrm{J}}=1.8982\\times 10^{27}$ kg。\n- 木星引起的半振幅与围绕太阳运行的地球模拟体所引起的半振幅的比值，取 $P_{\\oplus}=1.000$ 年，$a_{\\oplus}=1.000$ au，以及 $m_{\\oplus}=5.9722\\times 10^{24}$ kg。\n\n使用单位换算 $1\\,\\mathrm{au}=1.495978707\\times 10^{11}$ m 和 $1\\,\\mathrm{yr}=3.15576\\times 10^{7}$ s。将木星的半振幅以 $\\mathrm{m\\,s^{-1}}$ 表示，比值以纯小数表示。将你的数值结果四舍五入到四位有效数字。以行矩阵的形式提供最终答案，其中第一个元素是木星的半振幅，第二个元素是该比值。",
            "solution": "题目要求推导圆形轨道上双体系统的恒星视向速度（RV）半振幅 $K$，然后对特定情况进行数值计算。推导必须从基本原理出发。\n\n### 第1部分：视向速度半振幅 $K$ 的推导\n\n我们考虑一个由质量为 $M_s$ 的恒星和质量为 $m_p$ 的行星组成的系统。系统总质量为 $M_{tot} = M_s + m_p$。根据牛顿定律，在没有外力的情况下，恒星和行星围绕它们的共同质心（barycenter）运动。\n\n让我们将坐标系的原点放在质心处。恒星的位置矢量 $\\vec{r}_s$ 和行星的位置矢量 $\\vec{r}_p$ 满足质心的定义：\n$$M_s \\vec{r}_s + m_p \\vec{r}_p = \\vec{0}$$\n行星与恒星之间的分离矢量由 $\\vec{a} = \\vec{r}_p - \\vec{r}_s$ 给出。其大小 $a=|\\vec{a}|$ 是轨道分离距离，对于圆形轨道而言，它是一个常数。\n\n我们可以用分离矢量 $\\vec{a}$ 来表示恒星的位置矢量 $\\vec{r}_s$。根据质心方程，我们有 $\\vec{r}_p = -\\frac{M_s}{m_p}\\vec{r}_s$。将此代入分离矢量方程可得：\n$$\\vec{a} = \\left(-\\frac{M_s}{m_p}\\right)\\vec{r}_s - \\vec{r}_s = -\\left(\\frac{M_s + m_p}{m_p}\\right)\\vec{r}_s$$\n解出 $\\vec{r}_s$，我们得到：\n$$\\vec{r}_s = -\\frac{m_p}{M_s + m_p} \\vec{a}$$\n该方程表明，恒星围绕质心运行的轨道是行星相对于恒星轨道的按比例缩小版本。由于整个轨道是圆形且分离距离 $a$ 恒定，恒星必须围绕质心做圆形轨道运动。恒星轨道的半径 $a_s$ 是 $\\vec{r}_s$ 的大小：\n$$a_s = |\\vec{r}_s| = \\frac{m_p}{M_s + m_p} a$$\n恒星以周期 $P$（即系统的轨道周期）沿此圆形路径运动。对于匀速圆周运动，恒星的轨道速度 $v_s$ 是恒定的，由其轨道周长除以周期给出：\n$$v_s = \\frac{2\\pi a_s}{P}$$\n代入 $a_s$ 的表达式，我们得到恒星的轨道速度：\n$$v_s = \\frac{2\\pi}{P} \\left( \\frac{m_p a}{M_s + m_p} \\right)$$\n视向速度 $v_r$ 是恒星轨道速度矢量 $\\vec{v}_s$ 沿观测者视线方向的分量。当恒星完成其轨道时，观测到的该速度呈正弦变化。这个变化速度的最大值取决于轨道的倾角 $i$，即轨道平面法线与视线之间的夹角。观测到的最大视向速度，即视向速度半振幅 $K$，由下式给出：\n$$K = v_s \\sin(i)$$\n代入 $v_s$ 的表达式，得到视向速度半振幅的通用公式：\n$$K = \\frac{2\\pi a}{P} \\frac{m_p}{M_s + m_p} \\sin(i)$$\n题目指定了侧向轨道，这意味着观测者位于轨道平面内。在这种情况下，倾角为 $i=\\pi/2$ 弧度，且 $\\sin(i) = \\sin(\\pi/2) = 1$。因此，对于题目给出的配置，使用 $M_{\\odot}$ 表示恒星质量，表达式为：\n$$K = \\frac{2\\pi a}{P} \\frac{m_p}{M_{\\odot} + m_p}$$\n\n### 第2部分：太阳-木星系统的数值计算\n\n我们现在计算由木星轨道引起的太阳的预期视向速度半振幅 $K_J$。给定值为：\n- 恒星质量：$M_{\\odot} = 1.9885 \\times 10^{30}\\,\\mathrm{kg}$\n- 行星质量（木星）：$m_J = 1.8982 \\times 10^{27}\\,\\mathrm{kg}$\n- 轨道周期：$P_J = 11.86\\,\\mathrm{yr}$\n- 轨道分离距离：$a_J = 5.2\\,\\mathrm{au}$\n\n我们必须首先将周期和分离距离转换为国际单位制（SI）单位：\n$$P_J = 11.86\\,\\mathrm{yr} \\times (3.15576 \\times 10^7\\,\\mathrm{s/yr}) = 3.74273136 \\times 10^8\\,\\mathrm{s}$$\n$$a_J = 5.2\\,\\mathrm{au} \\times (1.495978707 \\times 10^{11}\\,\\mathrm{m/au}) = 7.7790892764 \\times 10^{11}\\,\\mathrm{m}$$\n太阳-木星系统的总质量为：\n$$M_{\\odot} + m_J = 1.9885 \\times 10^{30}\\,\\mathrm{kg} + 1.8982 \\times 10^{27}\\,\\mathrm{kg} = 1.9903982 \\times 10^{30}\\,\\mathrm{kg}$$\n现在我们将这些值代入我们推导出的 $K$ 的公式中：\n$$K_J = \\frac{2\\pi (7.7790892764 \\times 10^{11}\\,\\mathrm{m})}{3.74273136 \\times 10^8\\,\\mathrm{s}} \\times \\frac{1.8982 \\times 10^{27}\\,\\mathrm{kg}}{1.9903982 \\times 10^{30}\\,\\mathrm{kg}}$$\n$$K_J \\approx (13059.54\\,\\mathrm{m/s}) \\times (9.53676 \\times 10^{-4})$$\n$$K_J \\approx 12.4556\\,\\mathrm{m/s}$$\n四舍五入到四位有效数字，由木星引起的太陽视向速度半振幅为 $12.46\\,\\mathrm{m\\,s^{-1}}$。\n\n### 第3部分：比值计算\n\n接下来，我们计算木星引起的半振幅与地球模拟体引起的半振幅之比。地球模拟体的参数为：\n- 行星质量（地球）：$m_{\\oplus} = 5.9722 \\times 10^{24}\\,\\mathrm{kg}$\n- 轨道周期：$P_{\\oplus} = 1.000\\,\\mathrm{yr}$\n- 轨道分离距离：$a_{\\oplus} = 1.000\\,\\mathrm{au}$\n\n该比值由 $\\frac{K_J}{K_{\\oplus}}$ 给出。我们可以将其写为：\n$$\\frac{K_J}{K_{\\oplus}} = \\frac{\\frac{2\\pi a_J}{P_J} \\frac{m_J}{M_{\\odot} + m_J}}{\\frac{2\\pi a_{\\oplus}}{P_{\\oplus}} \\frac{m_{\\oplus}}{M_{\\odot} + m_{\\oplus}}} = \\left(\\frac{a_J}{a_{\\oplus}}\\right) \\left(\\frac{P_{\\oplus}}{P_J}\\right) \\left(\\frac{m_J}{m_{\\oplus}}\\right) \\left(\\frac{M_{\\odot} + m_{\\oplus}}{M_{\\odot} + m_J}\\right)$$\n我们可以直接在这些比率中使用给定的值：\n- $\\frac{a_J}{a_{\\oplus}} = \\frac{5.2\\,\\mathrm{au}}{1.000\\,\\mathrm{au}} = 5.2$\n- $\\frac{P_{\\oplus}}{P_J} = \\frac{1.000\\,\\mathrm{yr}}{11.86\\,\\mathrm{yr}} \\approx 0.08431703$\n- $\\frac{m_J}{m_{\\oplus}} = \\frac{1.8982 \\times 10^{27}\\,\\mathrm{kg}}{5.9722 \\times 10^{24}\\,\\mathrm{kg}} \\approx 317.8347$\n- $\\frac{M_{\\odot} + m_{\\oplus}}{M_{\\odot} + m_J} = \\frac{1.9885 \\times 10^{30} + 5.9722 \\times 10^{24}}{1.9885 \\times 10^{30} + 1.8982 \\times 10^{27}} = \\frac{1.9885059722 \\times 10^{30}}{1.9903982 \\times 10^{30}} \\approx 0.9990491$\n\n将这些因子相乘：\n$$\\frac{K_J}{K_{\\oplus}} \\approx 5.2 \\times 0.08431703 \\times 317.8347 \\times 0.9990491$$\n$$\\frac{K_J}{K_{\\oplus}} \\approx 139.231$$\n四舍五入到四位有效数字，该比值为 $139.2$。",
            "answer": "$$\\boxed{\\begin{pmatrix} 12.46  139.2 \\end{pmatrix}}$$"
        },
        {
            "introduction": "虽然半振幅 $K$ 设定了信号的尺度，但径向速度曲线随时间变化的完整形状是由行星的轨道路径决定的，这由开普勒定律描述。这项编程练习要求您实现从观测时间 $t$ 到预测的恒星反射速度的整个计算链，包括为偏心轨道数值求解开普勒方程的关键步骤。这是系外行星建模中的一项基石技能。",
            "id": "4174705",
            "problem": "您需要编写一个完整的程序，用于计算在指定的观测历元，由单个开普勒伴星引起的恒星视向径向速度。该程序必须使用适用于双体椭圆轨道的第一性原理，实现从时间到真近点角再到径向速度的完整映射，并且不得依赖任何预先制表或黑箱的轨道解。从开普勒运动的基本定律和核心定义出发：角动量守恒、面积速度恒定，以及对于束缚椭圆轨道，平近点角随时间均匀变化的定义。对于每个测试用例，请按照以下步骤构建您的解决方案：\n- 根据给定的轨道周期 $P$、离心率 $e$、近星点通过时间 $T_0$ 和观测时间 $t$，依据与面积定律一致的匀角速率计算平近点角 $M$。确保将 $M$ 置于一个方便的主分支上。\n- 利用扫过的平均面积与偏近点角之间的等效关系，求解连接椭圆的平近点角 $M$ 和偏近点角 $E$ 的超越方程。对于 $E \\in [0,2\\pi)$ 和 $e \\in [0,1)$，该方程是单调的，并且在此域内对于给定的 $(M,e)$ 对存在唯一解。\n- 仅使用辅助圆和椭圆之间的几何关系，将偏近点角 $E$ 转换为真近点角 $\\nu$。\n- 在标准的单行星开普勒轨道反射模型下，根据给定的半振幅 $K$、近星点幅角 $\\omega$ 和系统速度 $\\gamma$，计算恒星沿视线方向的径向速度。假设角度单位为弧度。您必须以米/秒为单位计算最终的径向速度。\n\n物理和数值单位：\n- 周期 $P$、时间 $T_0$ 和 $t$ 的单位为天。\n- 角度 $M$、$E$、$\\nu$ 和 $\\omega$ 的单位为弧度。\n- 返回的径向速度必须以米/秒 (m/s) 为单位，表示为浮点数。\n\n您的程序必须实现一种稳健的数值方法，以求解所有在 $[0,1)$ 范围内的离心率 $e$（包括接近 1 的高离心率情况）下关于偏近点角 $E$ 的超越方程。该方法提供的解在 $E$ 上的相对容差必须不大于 $10^{-10}$。\n\n测试用例：\n对于以下每一组参数 $(P,e,T_0,t,K,\\omega,\\gamma)$，请按照上述规定计算径向速度值，并以米/秒为单位表示结果。测试用例涵盖了典型、圆形和高离心率的情况，以及近星点和远星点的对齐情况。\n- 情况 1：$(P,e,T_0,t,K,\\omega,\\gamma) = (\\,20.0,\\,0.25,\\,0.0,\\,5.0,\\,3.2,\\,1.1,\\,0.5\\,)$\n- 情况 2：$(P,e,T_0,t,K,\\omega,\\gamma) = (\\,10.0,\\,0.0,\\,0.0,\\,\\tfrac{10.0}{6.0},\\,10.0,\\,2.0,\\,0.0\\,)$\n- 情况 3：$(P,e,T_0,t,K,\\omega,\\gamma) = (\\,100.0,\\,0.8,\\,1000.0,\\,1000.0,\\,50.0,\\,0.3,\\,2.0\\,)$\n- 情况 4：$(P,e,T_0,t,K,\\omega,\\gamma) = (\\,50.0,\\,0.6,\\,500.0,\\,525.0,\\,20.0,\\,2.4,\\,-1.0\\,)$\n- 情况 5：$(P,e,T_0,t,K,\\omega,\\gamma) = (\\,365.25,\\,0.9,\\,0.0,\\,182.625,\\,5.0,\\,1.7,\\,0.0\\,)$\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个逗号分隔的列表，该列表包含按上述顺序排列的 5 个结果，并用方括号括起来。例如：$[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4,\\text{result}_5]$。\n- 每个 $\\text{result}_i$ 都必须是一个浮点数，表示相应历元的径向速度，单位为 $\\text{m/s}$。",
            "solution": "该问题是有效的，因为它在科学上基于开普勒力学，问题设定良好，具有完整且一致的参数集，并且陈述客观。测试用例中提供的参数对于系外行星系统是物理上真实的。\n\n求解过程通过基于双体轨道力学原理的一系列确定性计算，将观测时间 $t$ 映射到预测的恒星径向速度 $V_r$。\n\n步骤 1：计算平近点角 ($M$)\n平近点角 $M$ 是一个随时间线性增加的角度，表示自伴星上一次经过近星点以来所经过的轨道周期分数。它的定义基于开普勒第二定律，该定律意味着面积速度是恒定的。平运动 $n$ 是一个轨道周期内的平均角速度，由 $n = 2\\pi / P$ 给出，其中 $P$ 是轨道周期。在给定观测时间 $t$ 的平近点角是相对于近星点通过时间 $T_0$ 计算的。\n$$\nM(t) = n (t - T_0) = \\frac{2\\pi}{P} (t - T_0)\n$$\n为了处理多轨道情况并建立一个标准区间，平近点角通常通过对 $2\\pi$ 取模，表示在主域 $[0, 2\\pi)$ 上。\n$$\nM = \\left( \\frac{2\\pi}{P} (t - T_0) \\right) \\pmod{2\\pi}\n$$\n\n步骤 2：求解关于偏近点角 ($E$) 的开普勒方程\n偏近点角 $E$ 是一个几何参数，它将椭圆轨道上一个物体的位置与该椭圆辅助圆上的一个对应点联系起来。平近点角 $M$ 和偏近点角 $E$ 之间的关系由开普勒方程给出：\n$$\nM = E - e \\sin E\n$$\n这是一个关于 $E$ 的超越方程，通常没有解析解，因此需要数值方法。我们寻求函数 $f(E) = E - e \\sin E - M$ 的根。\nNewton-Raphson 方法是一种强大且快速收敛的求根迭代技术。给定一个估计值 $E_k$，下一个改进的估计值 $E_{k+1}$ 由下式给出：\n$$\nE_{k+1} = E_k - \\frac{f(E_k)}{f'(E_k)}\n$$\n$f(E)$ 对 $E$ 的导数是 $f'(E) = 1 - e \\cos E$。对于束缚轨道，离心率 $e$ 在范围 $[0, 1)$ 内，这确保了 $f'(E)  0$。这保证了 $f(E)$ 是严格单调的，因此对于任何给定的 $M$，都存在唯一的 $E$ 解。迭代公式为：\n$$\nE_{k+1} = E_k - \\frac{E_k - e \\sin E_k - M}{1 - e \\cos E_k}\n$$\n迭代从一个初始猜测值 $E_0$（例如 $E_0 = M$）开始，并重复进行，直到连续迭代之间的变化量 $|E_{k+1} - E_k|$ 小于指定的容差（例如 $10^{-12}$），这满足了问题对所有相关 $E$ 值最多 $10^{-10}$ 相对容差的要求。\n\n步骤 3：转换为真近点角 ($\\nu$)\n真近点角 $\\nu$ 是从中心天体（椭圆的焦点）看去，近星点方向与天体当前位置之间的夹角。它是轨道平面内的真实几何角度。真近点角可以利用椭圆的几何性质从偏近点角 $E$ 推导出来。辅助圆上的坐标与椭圆上的坐标之间的关系导出以下关系式：\n$$\n\\cos \\nu = \\frac{\\cos E - e}{1 - e \\cos E}\n$$\n$$\n\\sin \\nu = \\frac{\\sqrt{1 - e^2} \\sin E}{1 - e \\cos E}\n$$\n为了稳健地确定 $\\nu$ 在其正确的象限 $[0, 2\\pi)$ 内，使用了双参数反正切函数 $\\operatorname{atan2}(y, x)$：\n$$\n\\nu = \\operatorname{atan2}\\left(\\sqrt{1 - e^2} \\sin E, \\cos E - e\\right)\n$$\n\n步骤 4：计算恒星径向速度 ($V_r$)\n恒星的可观测径向速度是其轨道速度矢量在视线方向上的投影，叠加在系统质心相对于观测者的恒定速度上。这个系统速度用 $\\gamma$ 表示。恒星在时间 $t$ 的径向速度公式为：\n$$\nV_r(t) = K \\left[ \\cos(\\nu(t) + \\omega) + e \\cos(\\omega) \\right] + \\gamma\n$$\n在此表达式中，$K$ 是径向速度半振幅，即恒星轨道径向速度的最大变化量。角度 $\\omega$ 是近星点幅角，它指定了轨道平面中椭圆相对于视线的方向。项 $\\cos(\\nu(t)+\\omega)$ 代表速度的主要变化分量，而项 $e \\cos(\\omega)$ 是一个由轨道离心率引起的常数偏移，确保速度的轨道分量的时间平均值为零。\n\n对每个测试用例执行的总体流程是：从输入的时间计算 $M$，数值求解 $E$，将 $E$ 转换为 $\\nu$，最后将 $\\nu$ 代入径向速度公式以获得最终结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve_kepler(M, e, tol=1e-12, max_iter=100):\n    \"\"\"\n    Solves Kepler's equation M = E - e*sin(E) for E using Newton-Raphson method.\n\n    Args:\n        M (float): Mean anomaly in radians.\n        e (float): Eccentricity (0 = e  1).\n        tol (float): Absolute tolerance for convergence of E.\n        max_iter (int): Maximum number of iterations.\n\n    Returns:\n        float: Eccentric anomaly E in radians.\n    \"\"\"\n    if e == 0.0:\n        return M\n\n    # An initial guess for E. M is a good guess for low e.\n    # For high e, M is not a great guess. M + e is a better heuristic.\n    E = M + e * np.sign(np.sin(M))\n    if E == M and M  0.1: # Catch cases where sin(M) is 0\n        E = M + e\n        \n    for _ in range(max_iter):\n        E_prev = E\n        # Newton-Raphson step\n        # f(E) = E - e*sin(E) - M\n        # f'(E) = 1 - e*cos(E)\n        f_E = E_prev - e * np.sin(E_prev) - M\n        fp_E = 1.0 - e * np.cos(E_prev)\n        \n        # The update step\n        E = E_prev - f_E / fp_E\n        \n        # Check for convergence\n        if abs(E - E_prev)  tol:\n            return E\n            \n    # If the loop finishes without converging (highly unlikely for valid inputs),\n    # return the last computed value.\n    return E\n\ndef calculate_radial_velocity(P, e, T0, t, K, omega, gamma):\n    \"\"\"\n    Computes the stellar radial velocity for a single Keplerian companion.\n\n    Args:\n        P (float): Orbital period in days.\n        e (float): Eccentricity.\n        T0 (float): Time of periastron passage in days.\n        t (float): Observation time in days.\n        K (float): RV semi-amplitude in m/s.\n        omega (float): Argument of periastron in radians.\n        gamma (float): Systemic velocity in m/s.\n\n    Returns:\n        float: The radial velocity in m/s.\n    \"\"\"\n    # Step 1: Compute Mean Anomaly (M)\n    # Mean motion n = 2*pi/P\n    # M = n * (t - T0)\n    # Ensure M is on the principal branch [0, 2*pi)\n    M = (2.0 * np.pi / P * (t - T0)) % (2.0 * np.pi)\n\n    # Step 2: Solve Kepler's Equation for Eccentric Anomaly (E)\n    E = solve_kepler(M, e)\n\n    # Step 3: Convert Eccentric Anomaly (E) to True Anomaly (nu)\n    # A robust way using atan2 to resolve quadrant ambiguity\n    # nu = atan2(sqrt(1-e^2)*sin(E), cos(E)-e)\n    cos_E = np.cos(E)\n    sin_E = np.sin(E)\n    nu = np.arctan2(np.sqrt(1.0 - e**2) * sin_E, cos_E - e)\n\n    # Step 4: Evaluate the Radial Velocity (Vr)\n    # Vr = K * (cos(omega + nu) + e * cos(omega)) + gamma\n    vr = K * (np.cos(omega + nu) + e * np.cos(omega)) + gamma\n    \n    return vr\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # (P, e, T0, t, K, omega, gamma)\n    test_cases = [\n        (20.0, 0.25, 0.0, 5.0, 3.2, 1.1, 0.5),\n        (10.0, 0.0, 0.0, 10.0 / 6.0, 10.0, 2.0, 0.0),\n        (100.0, 0.8, 1000.0, 1000.0, 50.0, 0.3, 2.0),\n        (50.0, 0.6, 500.0, 525.0, 20.0, 2.4, -1.0),\n        (365.25, 0.9, 0.0, 182.625, 5.0, 1.7, 0.0)\n    ]\n\n    results = []\n    for case in test_cases:\n        P, e, T0, t, K, omega, gamma = case\n        result = calculate_radial_velocity(P, e, T0, t, K, omega, gamma)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.10f}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在现实中，测量的径向速度数据不仅包含行星信号，还包含了来自恒星本身的“噪声”。本实践将从理想化模型转向数据分析的实际挑战，要求您使用常见的恒星活动指标（如谱线平分线反斜率 BIS、半高全宽 FWHM 和 S-指数）来识别并量化它们与径向速度变化的相关性。这个练习模拟了筛选潜在系外行星候选体和避免假阳性信号的关键步骤。",
            "id": "4174640",
            "problem": "您将获得四个确定性的时间序列测试用例，这些用例模拟了典型的恒星径向速度活动诊断及其与测量的径向速度之间的关系。对于每个测试用例，您将获得表示时间的数组（单位：天）、测量的视线径向速度（单位：$\\mathrm{m/s}$）、其测量不确定度（单位：$\\mathrm{m/s}$）以及三个活动指标：均分线反斜率（BIS，单位：$\\mathrm{m/s}$）、半峰全宽（FWHM，单位：$\\mathrm{m/s}$）和威尔逊山 $S$ 指数（无量纲）。您的任务是评估径向速度与每个活动指标之间的相关性，并使用加权线性模型量化由这些指标的线性组合所解释的径向速度方差的分数。\n\n基本原理：\n- 径向速度是恒星速度沿视线的投影，并被建模为时间序列 $y_i$，在时间 $t_i$ 具有测量不确定度 $\\sigma_i$。\n- 诸如均分线反斜率（BIS）、半峰全宽（FWHM）和威尔逊山 $S$ 指数等活动指标反映了谱线轮廓的变化和色球活动，这些都可能与表观的径向速度信号相关。\n- 两个序列之间的皮尔逊相关系数是基于协方差和标准差的线性关联的标准化度量。\n- 一个带截距的加权线性模型最小化加权残差平方和，其中权重 $w_i$ 与方差的倒数成正比，$w_i = 1/\\sigma_i^2$，从而产生预测变量的最佳拟合线性组合。解释的方差分数由决定系数来量化，该系数是相对于关于加权平均值的加权方差定义的。\n\n对于每个测试用例，计算：\n1. 径向速度序列 $y$ 与每个指标序列（BIS、FWHM、$S$-指数）之间的皮尔逊相关系数，以浮点数表示。如果一个序列的标准差为零，则按惯例将相关性定义为 $0.0$。\n2. 使用权重 $w_i = 1/\\sigma_i^2$ 的加权线性模型 $y = \\beta_0 + \\beta_{\\mathrm{BIS}}\\cdot \\mathrm{BIS} + \\beta_{\\mathrm{FWHM}}\\cdot \\mathrm{FWHM} + \\beta_{S}\\cdot S + \\epsilon$ 所解释的径向速度方差的分数。使用基于加权残差平方和相对于关于加权平均值的加权总平方和的决定系数。如果加权总方差恰好为零，则将解释的分数定义为 $0.0$。\n\n物理单位要求：\n- 将所有最终结果表示为四舍五入到 $4$ 位小数的无量纲浮点数。虽然输入具有物理单位，但相关系数和决定系数是无量纲的。\n\n角度单位：\n- 对所有三角函数参数使用弧度。\n\n测试套件：\n- 测试用例 $1$（“理想情况，强相关性，异方差权重”）：\n  - $N = 24$, $t_i = i$ 对于 $i = 0, 1, \\dots, 23$ (天)。\n  - $\\mathrm{BIS}_i = 10 \\cdot \\sin\\left(2\\pi \\cdot t_i / 12\\right)$（单位：$\\mathrm{m/s}$）。\n  - $\\mathrm{FWHM}_i = 0.5 \\cdot \\mathrm{BIS}_i + 2$（单位：$\\mathrm{m/s}$）。\n  - $S_i = 0.35 + 0.01 \\cdot t_i$（无量纲）。\n  - $y_i = 3 \\cdot \\mathrm{BIS}_i + 2 \\cdot \\mathrm{FWHM}_i + 100 \\cdot (S_i - 0.35) + 0.2 \\cdot \\sin(t_i)$（单位：$\\mathrm{m/s}$）。\n  - $\\sigma_i = 1 + 0.1 \\cdot t_i$（单位：$\\mathrm{m/s}$）。\n- 测试用例 $2$（“近零相关性，不同周期性”）：\n  - $N = 25$, $t_i = i$ 对于 $i = 0, 1, \\dots, 24$ (天)。\n  - $\\mathrm{BIS}_i = 5 \\cdot \\sin\\left(2\\pi \\cdot t_i / 5\\right)$（单位：$\\mathrm{m/s}$）。\n  - $\\mathrm{FWHM}_i = 3 \\cdot \\cos\\left(2\\pi \\cdot t_i / 5\\right)$（单位：$\\mathrm{m/s}$）。\n  - $S_i = 0.4 + 0.02 \\cdot \\sin\\left(2\\pi \\cdot t_i / 9\\right)$（无量纲）。\n  - $y_i = 8 \\cdot \\sin\\left(2\\pi \\cdot t_i / 7\\right) + 0.5 \\cdot \\sin\\left(2\\pi \\cdot t_i / 2\\right)$（单位：$\\mathrm{m/s}$）。\n  - $\\sigma_i = 1$（单位：$\\mathrm{m/s}$），对于所有 $i$。\n- 测试用例 $3$（“中等相关性，强共线性，异方差权重”）：\n  - $N = 30$, $t_i = i$ 对于 $i = 0, 1, \\dots, 29$ (天)。\n  - $\\mathrm{BIS}_i = 7 \\cdot \\sin\\left(2\\pi \\cdot t_i / 15\\right) + 0.2 \\cdot t_i$（单位：$\\mathrm{m/s}$）。\n  - $\\mathrm{FWHM}_i = 14 \\cdot \\sin\\left(2\\pi \\cdot t_i / 15\\right) + 0.4 \\cdot t_i$（单位：$\\mathrm{m/s}$）。\n  - $S_i = 0.38 + 0.01 \\cdot \\sin\\left(2\\pi \\cdot t_i / 5\\right)$（无量纲）。\n  - $y_i = 2 \\cdot \\mathrm{BIS}_i + 1 \\cdot \\mathrm{FWHM}_i + 120 \\cdot (S_i - 0.38) + 3 \\cdot \\cos\\left(2\\pi \\cdot t_i / 4\\right)$（单位：$\\mathrm{m/s}$）。\n  - $\\sigma_i = 0.5 + 0.05 \\cdot (t_i \\bmod 5)$（单位：$\\mathrm{m/s}$）。\n- 测试用例 $4$（“边界情况，径向速度方差为零”）：\n  - $N = 10$, $t_i = i$ 对于 $i = 0, 1, \\dots, 9$ (天)。\n  - $\\mathrm{BIS}_i = 2 \\cdot \\sin\\left(2\\pi \\cdot t_i / 10\\right)$（单位：$\\mathrm{m/s}$）。\n  - $\\mathrm{FWHM}_i = 0.1 \\cdot \\mathrm{BIS}_i + \\sin\\left(2\\pi \\cdot t_i / 3\\right)$（单位：$\\mathrm{m/s}$）。\n  - $S_i = 0.37 + 0.01 \\cdot \\cos\\left(2\\pi \\cdot t_i / 3\\right)$（无量纲）。\n  - $y_i = 50$（单位：$\\mathrm{m/s}$），对于所有 $i$。\n  - $\\sigma_i = 1 + 0.2 \\cdot t_i$（单位：$\\mathrm{m/s}$）。\n\n最终输出格式：\n- 对于每个测试用例，生成一个包含四个浮点数的列表 $[r_{\\mathrm{BIS}}, r_{\\mathrm{FWHM}}, r_S, R^2]$，四舍五入到 $4$ 位小数，其中 $r_{\\mathrm{BIS}}$ 是 $y$ 和 BIS 之间的皮尔逊相关系数，$r_{\\mathrm{FWHM}}$ 是 $y$ 和 FWHM 之间的皮尔逊相关系数，$r_{S}$ 是 $y$ 和 $S$ 之间的皮尔逊相关系数，$R^2$ 是由带截距的组合指标解释的加权方差分数。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个元素对应一个测试用例，并且本身是一个包含四个浮点数的列表，例如：$[[a_1,b_1,c_1,d_1],[a_2,b_2,c_2,d_2],[a_3,b_3,c_3,d_3],[a_4,b_4,c_4,d_4]]$。",
            "solution": "用户要求分析四个模拟的恒星径向速度时间序列。对于每种情况，我们必须计算径向速度与三个活动指标之间的皮尔逊相关系数，然后确定由包含这些指标的加权线性模型所解释的径向速度方差的分数。\n\n每个测试用例的分析分两个主要步骤进行：\n1.  计算皮尔逊相关系数。\n2.  从多元线性回归中计算加权决定系数（$R^2$）。\n\n### 1. 皮尔逊相关系数\n\n皮尔逊相关系数 $r_{XY}$ 量化了两个长度均为 $N$ 的数据序列 $X$ 和 $Y$ 之间的线性关系。其公式为：\n$$\nr_{XY} = \\frac{\\sum_{i=1}^{N}(X_i - \\bar{X})(Y_i - \\bar{Y})}{\\sqrt{\\sum_{i=1}^{N}(X_i - \\bar{X})^2 \\sum_{i=1}^{N}(Y_i - \\bar{Y})^2}}\n$$\n其中 $\\bar{X}$ 和 $\\bar{Y}$ 分别是序列 $X$ 和 $Y$ 的样本均值。分子是 $X$ 和 $Y$ 之间的协方差，分母是它们标准差的乘积。$r_{XY}$ 的值范围从 $-1$ 到 $+1$，分别表示完全的负相关和正相关，而 $0$ 表示没有线性相关。\n\n对于此问题，我们为每个测试用例计算三个相关系数：$r_{\\mathrm{BIS}}$（径向速度 $y$ 和指标 BIS 之间）、$r_{\\mathrm{FWHM}}$（$y$ 和 FWHM 之间）以及 $r_{S}$（$y$ 和 $S$ 指数之间）。根据问题规范，如果一个序列的标准差为零，则相关系数定义为 $0.0$。\n\n### 2. 加权线性回归和决定系数（$R^2$）\n\n第二个任务是将径向速度 $y_i$ 建模为活动指标的线性函数。该模型包含一个截距项 $\\beta_0$：\n$$\ny_i = \\beta_0 + \\beta_{\\mathrm{BIS}}\\cdot \\mathrm{BIS}_i + \\beta_{\\mathrm{FWHM}}\\cdot \\mathrm{FWHM}_i + \\beta_{S}\\cdot S_i + \\epsilon_i\n$$\n其中 $\\epsilon_i$ 表示第 $i$ 个观测值的残差。用矩阵表示法，这表示为 $\\mathbf{y} = \\mathbf{X}\\boldsymbol{\\beta} + \\boldsymbol{\\epsilon}$，其中：\n-   $\\mathbf{y}$ 是观测到的径向速度的 $N \\times 1$ 向量。\n-   $\\mathbf{X}$ 是 $N \\times 4$ 的设计矩阵，其列分别是一个全为 1 的向量（用于截距）、BIS 向量、FWHM 向量和 $S$ 指数向量。\n-   $\\boldsymbol{\\beta}$ 是待估计的系数的 $4 \\times 1$ 向量：$[\\beta_0, \\beta_{\\mathrm{BIS}}, \\beta_{\\mathrm{FWHM}}, \\beta_S]^T$。\n-   $\\boldsymbol{\\epsilon}$ 是误差的 $N \\times 1$ 向量。\n\n问题要求进行加权线性回归，其中每个观测值都通过其方差的倒数 $w_i = 1/\\sigma_i^2$ 进行加权。这种方法称为加权最小二乘法（WLS），它找到最小化加权残差平方和的系数向量 $\\hat{\\boldsymbol{\\beta}}$：\n$$\n\\chi^2 = \\sum_{i=1}^{N} w_i (y_i - \\hat{y}_i)^2\n$$\n其中 $\\hat{y}_i$ 是模型预测值。这个最小化问题可以转化为一个普通最小二乘（OLS）问题。设 $\\mathbf{W}$ 是一个对角线元素为 $w_i$ 的对角矩阵。我们定义变换后的变量 $\\mathbf{y}' = \\mathbf{L}\\mathbf{y}$ 和 $\\mathbf{X}' = \\mathbf{L}\\mathbf{X}$，其中 $\\mathbf{L}$ 是一个对角线元素为 $L_{ii} = \\sqrt{w_i}$ 的对角矩阵。问题就变成了最小化 $||\\mathbf{y}' - \\mathbf{X}'\\boldsymbol{\\beta}||^2$，这可以使用数值方法（例如 `numpy.linalg.lstsq` 提供的那些）稳健地求解 $\\hat{\\boldsymbol{\\beta}}$。即使在预测变量之间存在多重共线性的情况下（如测试用例3），这种方法也是稳定的。\n\n一旦确定了系数 $\\hat{\\boldsymbol{\\beta}}$，模型预测值就可以计算为 $\\hat{\\mathbf{y}} = \\mathbf{X}\\hat{\\boldsymbol{\\beta}}$。解释的方差分数由加权决定系数 $R^2$ 量化：\n$$\nR^2 = 1 - \\frac{SS_{res, w}}{SS_{tot, w}}\n$$\n-   加权残差平方和为 $SS_{res, w} = \\sum_{i=1}^{N} w_i (y_i - \\hat{y}_i)^2$。\n-   加权总平方和为 $SS_{tot, w} = \\sum_{i=1}^{N} w_i (y_i - \\bar{y}_w)^2$。\n-   径向速度的加权平均值为 $\\bar{y}_w = \\frac{\\sum_{i=1}^{N} w_i y_i}{\\sum_{i=1}^{N} w_i}$。\n\n在加权总方差（也就是 $SS_{tot, w}$）为零的特殊情况下（如测试用例4），$R^2$ 定义为 $0.0$。\n\n对于每个测试用例，都会生成必要的时间序列，然后计算三个相关系数和单个 $R^2$ 值。所有最终结果都四舍五入到四位小数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef generate_test_case_data(case_id):\n    \"\"\"\n    Generates the time series data for a specific test case.\n    \"\"\"\n    if case_id == 1:\n        N = 24\n        t = np.arange(N, dtype=float)\n        bis = 10.0 * np.sin(2.0 * np.pi * t / 12.0)\n        fwhm = 0.5 * bis + 2.0\n        s_idx = 0.35 + 0.01 * t\n        y = 3.0 * bis + 2.0 * fwhm + 100.0 * (s_idx - 0.35) + 0.2 * np.sin(t)\n        sigma = 1.0 + 0.1 * t\n    elif case_id == 2:\n        N = 25\n        t = np.arange(N, dtype=float)\n        bis = 5.0 * np.sin(2.0 * np.pi * t / 5.0)\n        fwhm = 3.0 * np.cos(2.0 * np.pi * t / 5.0)\n        s_idx = 0.4 + 0.02 * np.sin(2.0 * np.pi * t / 9.0)\n        y = 8.0 * np.sin(2.0 * np.pi * t / 7.0) + 0.5 * np.sin(2.0 * np.pi * t / 2.0)\n        sigma = np.ones(N)\n    elif case_id == 3:\n        N = 30\n        t = np.arange(N, dtype=float)\n        bis = 7.0 * np.sin(2.0 * np.pi * t / 15.0) + 0.2 * t\n        fwhm = 14.0 * np.sin(2.0 * np.pi * t / 15.0) + 0.4 * t\n        s_idx = 0.38 + 0.01 * np.sin(2.0 * np.pi * t / 5.0)\n        y = 2.0 * bis + 1.0 * fwhm + 120.0 * (s_idx - 0.38) + 3.0 * np.cos(2.0 * np.pi * t / 4.0)\n        sigma = 0.5 + 0.05 * (t % 5)\n    elif case_id == 4:\n        N = 10\n        t = np.arange(N, dtype=float)\n        bis = 2.0 * np.sin(2.0 * np.pi * t / 10.0)\n        fwhm = 0.1 * bis + np.sin(2.0 * np.pi * t / 3.0)\n        s_idx = 0.37 + 0.01 * np.cos(2.0 * np.pi * t / 3.0)\n        y = np.full(N, 50.0)\n        sigma = 1.0 + 0.2 * t\n    else:\n        raise ValueError(\"Invalid case_id\")\n\n    return y, sigma, bis, fwhm, s_idx\n\ndef calculate_metrics(y, sigma, bis, fwhm, s_idx):\n    \"\"\"\n    Calculates Pearson correlations and the weighted R^2 value.\n    \"\"\"\n    # 1. Pearson Correlation Coefficients\n    def safe_corrcoef(series1, series2):\n        if np.std(series1) == 0.0 or np.std(series2) == 0.0:\n            return 0.0\n        return np.corrcoef(series1, series2)[0, 1]\n\n    r_bis = safe_corrcoef(y, bis)\n    r_fwhm = safe_corrcoef(y, fwhm)\n    r_s = safe_corrcoef(y, s_idx)\n    \n    # 2. Weighted Coefficient of Determination (R^2)\n    # Construct design matrix X with an intercept\n    X = np.c_[np.ones_like(y), bis, fwhm, s_idx]\n    \n    # Calculate weights\n    w = 1.0 / sigma**2\n    \n    # Calculate weighted total sum of squares (SST_w)\n    y_weighted_mean = np.sum(w * y) / np.sum(w)\n    ss_tot_w = np.sum(w * (y - y_weighted_mean)**2)\n    \n    # Handle the boundary case of zero total variance\n    if ss_tot_w == 0.0:\n        R2 = 0.0\n    else:\n        # Solve the weighted least squares problem by transforming to OLS\n        # L is a diagonal matrix with sqrt(w_i)\n        L = np.sqrt(w)\n        # Transform variables: y' = Ly, X' = LX\n        y_prime = y * L\n        X_prime = X * L[:, np.newaxis]\n        \n        # Solve for coefficients using lstsq for numerical stability\n        beta_hat, _, _, _ = np.linalg.lstsq(X_prime, y_prime, rcond=None)\n        \n        # Calculate predicted values\n        y_hat = X @ beta_hat\n        \n        # Calculate weighted residual sum of squares (SSR_w)\n        ss_res_w = np.sum(w * (y - y_hat)**2)\n        \n        # Calculate R^2\n        R2 = 1.0 - ss_res_w / ss_tot_w\n\n    return [round(val, 4) for val in [r_bis, r_fwhm, r_s, R2]]\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases.\n    \"\"\"\n    test_cases = [1, 2, 3, 4]\n    results = []\n    \n    for case_id in test_cases:\n        # Generate data for the current test case\n        y, sigma, bis, fwhm, s_idx = generate_test_case_data(case_id)\n        \n        # Calculate the required metrics\n        metrics = calculate_metrics(y, sigma, bis, fwhm, s_idx)\n        results.append(metrics)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}