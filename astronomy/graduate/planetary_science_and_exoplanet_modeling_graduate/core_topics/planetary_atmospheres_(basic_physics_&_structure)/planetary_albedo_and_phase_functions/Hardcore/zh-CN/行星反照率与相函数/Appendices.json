{
    "hands_on_practices": [
        {
            "introduction": "对行星反照率和相函数的任何深入研究都始于一个理想化的基准模型：朗伯球体。这个练习将指导你从基本物理原理出发，推导一个完美漫反射（朗伯）球体的光度学性质。通过完成这项实践，你将亲自验证几何反照率$A_g$、相积分$q$和邦德反照率$A_B$这些关键概念之间深刻的数学联系，为你理解更复杂的散射模型奠定坚实的理论基础。",
            "id": "4170317",
            "problem": "一颗半径为 $R$ 的系外行星被建模为一个均匀、完美漫反射（朗伯体）的球体，其表面反射率为1。恒星是一个遥远的点源，向行星提供准直辐照度 $F_{\\star}$，观测者也位于远场的 $\\Delta$ 距离处，因此辐射亮度沿直线守恒。朗伯表面的双向反射分布函数（BRDF）为 $1/\\pi$，在入射天顶角为 $\\theta_{0}$ 的准直光照下，从一个表面元发出的辐射亮度为 $I = \\left(F_{\\star}/\\pi\\right)\\cos\\theta_{0}$，且与出射方向无关。几何反照率 $A_{g}$ 定义为天体在满相（$\\alpha=0$）时观测到的通量，与一个具有相同横截面积、被正面照射和观测、且反射率同为1的平坦、完美漫反射朗伯盘的通量之比。行星相位角 $\\alpha$ 是在行星处，恒星方向与观测者方向之间的夹角；全文中使用弧度制的 $\\alpha$。盘积分相位函数 $\\Phi(\\alpha)$ 由 $F(\\alpha)=F(0)\\,\\Phi(\\alpha)$ 定义，其中 $F(\\alpha)$ 是在相位角 $\\alpha$ 处观测到的朗伯球体的总通量，并被归一化以使 $\\Phi(0)=1$。\n\n从朗伯余弦定律和辐射亮度不变性出发，并仅使用球面几何和能量守恒：\n- 通过将被观测通量表示为在被照亮和可见半球交集上的面积分，并对该积分以 $\\alpha$ 求解，来推导朗伯球体相位函数 $\\Phi_{L}(\\alpha)$。\n- 使用此 $\\Phi_{L}(\\alpha)$，计算反射率为1的朗伯球体的几何反照率 $A_{g}$，并证明其精确等于分数 $2/3$。\n- 计算由 $q_{L}=2\\int_{0}^{\\pi}\\Phi_{L}(\\alpha)\\sin\\alpha\\,\\mathrm{d}\\alpha$ 定义的相位积分 $q_{L}$（其中 $\\alpha$ 为弧度），并给出其精确值。\n- 使用邦德反照率 $A_{B}$ 的定义（即在所有散射角上反射的入射功率分数）以及连接邦德反照率、几何反照率和相位积分的标准关系 $A_{B}=q\\,A_{g}$，计算此朗伯球体的精确邦德反照率 $A_{B}$。\n\n提供 $A_{g}$、$q_{L}$ 和 $A_{B}$ 的精确值。无需四舍五入。按 $(A_{g},\\,q_{L},\\,A_{B})$ 的顺序，将您的最终三元组值表示为单行。",
            "solution": "我们按照问题的要求，分步推导所需的物理量。\n\n### 1. 朗伯球体在满相时的通量 $F(0)$\n在满相 ($\\alpha=0$) 时，观测者与恒星在同一方向。我们设置一个球坐标系，原点在行星中心，z轴指向恒星和观测者。入射光来自 $+z$ 方向，观测者在 $+z$ 方向的无穷远处。\n- 表面法向量为 $\\hat{n}$。\n- 入射角 $\\theta_0$ 等于出射角 $\\theta_e$。两者都是法向量 $\\hat{n}$ 与z轴的夹角，即球坐标中的天顶角 $\\theta$。所以 $\\cos\\theta_0 = \\cos\\theta_e = \\cos\\theta$。\n- 被照亮且可见的区域是 $\\theta \\in [0, \\pi/2]$ 的半球。\n- 根据朗伯定律，表面元的辐射亮度为 $I = \\frac{F_\\star}{\\pi} \\cos\\theta_0 = \\frac{F_\\star}{\\pi} \\cos\\theta$。\n- 观测者从表面元 $dS = R^2 \\sin\\theta d\\theta d\\phi$ 接收到的通量为 $dF = I \\cos\\theta_e \\frac{dS}{\\Delta^2}$。\n\n对整个可见半球积分，得到总通量 $F(0)$：\n$$ F(0) = \\int_{0}^{2\\pi} d\\phi \\int_{0}^{\\pi/2} \\left(\\frac{F_\\star}{\\pi} \\cos\\theta\\right) \\cos\\theta \\frac{R^2 \\sin\\theta d\\theta}{\\Delta^2} $$\n$$ F(0) = \\frac{F_\\star R^2}{\\pi \\Delta^2} (2\\pi) \\int_{0}^{\\pi/2} \\cos^2\\theta \\sin\\theta d\\theta $$\n令 $u = \\cos\\theta$, 则 $du = -\\sin\\theta d\\theta$。积分限从 $u(0)=1$ 变为 $u(\\pi/2)=0$。\n$$ \\int_{0}^{\\pi/2} \\cos^2\\theta \\sin\\theta d\\theta = \\int_{1}^{0} u^2 (-du) = \\int_{0}^{1} u^2 du = \\left[\\frac{u^3}{3}\\right]_0^1 = \\frac{1}{3} $$\n因此，\n$$ F(0) = \\frac{2 F_\\star R^2}{\\Delta^2} \\cdot \\frac{1}{3} = \\frac{2 F_\\star R^2}{3 \\Delta^2} $$\n\n### 2. 参考朗伯盘的通量 $F_{\\text{disk}}$\n参考盘是一个平坦、正面受光、正面观测的完美朗伯盘，半径为 $R$，反射率为1。\n- 对于盘上的任何点，入射角 $\\theta_0 = 0$，出射角 $\\theta_e = 0$。\n- 辐射亮度恒为 $I_{\\text{disk}} = \\frac{F_\\star}{\\pi} \\cos(0) = \\frac{F_\\star}{\\pi}$。\n- 观测到的通量是辐射亮度乘以盘的立体角 $\\frac{\\pi R^2}{\\Delta^2}$。\n$$ F_{\\text{disk}} = I_{\\text{disk}} \\frac{\\pi R^2}{\\Delta^2} = \\frac{F_\\star}{\\pi} \\frac{\\pi R^2}{\\Delta^2} = \\frac{F_\\star R^2}{\\Delta^2} $$\n\n### 3. 几何反照率 $A_g$\n根据定义，$A_g$ 是行星在满相时的通量与参考盘通量之比：\n$$ A_g = \\frac{F(0)}{F_{\\text{disk}}} = \\frac{2 F_\\star R^2 / (3 \\Delta^2)}{F_\\star R^2 / \\Delta^2} = \\frac{2}{3} $$\n\n### 4. 朗伯球体相位函数 $\\Phi_L(\\alpha)$\n对任意相位角 $\\alpha$ 的朗伯球体的盘积分通量是一个标准结果，其积分为：\n$$ F(\\alpha) = \\frac{F_\\star R^2}{\\pi \\Delta^2} [\\sin\\alpha + (\\pi - \\alpha)\\cos\\alpha] $$\n注意，该公式中的 $F_\\star$ 是指辐射亮度，若按问题中的辐照度定义，应为：\n$$ F(\\alpha) = \\frac{2 F_\\star R^2}{3 \\Delta^2} \\frac{\\sin\\alpha + (\\pi - \\alpha)\\cos\\alpha}{\\pi} $$\n根据相位函数的定义 $F(\\alpha) = F(0) \\Phi_L(\\alpha)$，我们有：\n$$ \\Phi_L(\\alpha) = \\frac{F(\\alpha)}{F(0)} = \\frac{\\frac{2 F_\\star R^2}{3 \\Delta^2} \\frac{\\sin\\alpha + (\\pi - \\alpha)\\cos\\alpha}{\\pi}}{\\frac{2 F_\\star R^2}{3 \\Delta^2}} = \\frac{\\sin\\alpha + (\\pi - \\alpha)\\cos\\alpha}{\\pi} $$\n此函数满足归一化条件 $\\Phi_L(0) = \\frac{\\sin(0) + (\\pi-0)\\cos(0)}{\\pi} = \\frac{\\pi}{\\pi} = 1$。\n\n### 5. 相位积分 $q_L$\n根据定义，$q_L = 2 \\int_0^\\pi \\Phi_L(\\alpha) \\sin\\alpha \\,d\\alpha$。\n$$ q_L = \\frac{2}{\\pi} \\int_0^\\pi (\\sin\\alpha + (\\pi - \\alpha)\\cos\\alpha) \\sin\\alpha \\,d\\alpha $$\n$$ q_L = \\frac{2}{\\pi} \\int_0^\\pi (\\sin^2\\alpha + \\pi\\sin\\alpha\\cos\\alpha - \\alpha\\sin\\alpha\\cos\\alpha) \\,d\\alpha $$\n我们分别计算这三部分的积分：\n1. $\\int_0^\\pi \\sin^2\\alpha \\,d\\alpha = \\int_0^\\pi \\frac{1-\\cos(2\\alpha)}{2} \\,d\\alpha = \\left[\\frac{\\alpha}{2} - \\frac{\\sin(2\\alpha)}{4}\\right]_0^\\pi = \\frac{\\pi}{2}$\n2. $\\int_0^\\pi \\pi\\sin\\alpha\\cos\\alpha \\,d\\alpha = \\frac{\\pi}{2} \\int_0^\\pi \\sin(2\\alpha) \\,d\\alpha = \\frac{\\pi}{2} \\left[-\\frac{\\cos(2\\alpha)}{2}\\right]_0^\\pi = 0$\n3. $\\int_0^\\pi \\alpha\\sin\\alpha\\cos\\alpha \\,d\\alpha = \\frac{1}{2} \\int_0^\\pi \\alpha\\sin(2\\alpha) \\,d\\alpha$\n   使用分部积分法 ($\\int u dv = uv - \\int v du$)，令 $u=\\alpha, dv=\\sin(2\\alpha)d\\alpha$：\n   $$ \\frac{1}{2} \\left( \\left[-\\alpha\\frac{\\cos(2\\alpha)}{2}\\right]_0^\\pi - \\int_0^\\pi -\\frac{\\cos(2\\alpha)}{2} \\,d\\alpha \\right) = \\frac{1}{2} \\left(-\\frac{\\pi}{2} + \\left[\\frac{\\sin(2\\alpha)}{4}\\right]_0^\\pi \\right) = -\\frac{\\pi}{4} $$\n将三部分加总，积分结果为 $\\frac{\\pi}{2} + 0 - (-\\frac{\\pi}{4}) = \\frac{3\\pi}{4}$。\n因此，\n$$ q_L = \\frac{2}{\\pi} \\cdot \\frac{3\\pi}{4} = \\frac{3}{2} $$\n\n### 6. 邦德反照率 $A_B$\n使用关系式 $A_B = q_L A_g$：\n$$ A_B = \\left(\\frac{3}{2}\\right) \\left(\\frac{2}{3}\\right) = 1 $$\n这个结果符合物理直觉：一个表面反射率为1的球体，其反射的总能量必然等于总入射能量，因此邦德反照率必须为1。\n\n最终，我们得到的三元组为 $(A_g, q_L, A_B) = (2/3, 3/2, 1)$。",
            "answer": "$$ \\boxed{ \\begin{pmatrix} \\frac{2}{3}  \\frac{3}{2}  1 \\end{pmatrix} } $$"
        },
        {
            "introduction": "在现代天体物理学中，我们通过将物理模型与观测数据进行拟合来揭示天体的性质。这项实践为你提供了将理论应用于实际研究的绝佳机会。你将设计并实现一个分层贝叶斯模型，用于联合分析来自多个波段的系外行星相曲线数据。通过这项练习，你不仅能掌握如何用Henyey-Greenstein函数等模型来描述散射，还将学习如何利用统计方法在不同数据集之间共享信息，从而更稳健地约束随波长变化的几何反照率$A_g(\\lambda)$和行星大气的共同散射参数。",
            "id": "4170251",
            "problem": "一颗在光学波段观测到的系外行星表现出随波长变化的反射光位相曲线。设行星与恒星的流量比由直接源自辐射能量守恒和平方反比几何关系的反射光标度模型给出：对于任何以 $b$ 索引的波段，以及任何恒星-观测者-行星相位角 $\\alpha$（以弧度为单位），期望的流量比为\n$$\n\\mu_b(\\alpha) = A_g^{(b)}\\,\\Phi(\\alpha;\\,\\boldsymbol{\\varphi})\\,\\left(\\frac{R_p}{a}\\right)^2,\n$$\n其中 $A_g^{(b)}$ 是波段 $b$ 的几何反照率，$\\Phi(\\alpha;\\,\\boldsymbol{\\varphi})$ 是一个在 $\\alpha=0$ 处归一化为 $1$ 的无量纲相位函数，$R_p$ 是行星半径，$a$ 是恒星与行星的间距。因子 $\\left(\\frac{R_p}{a}\\right)^2$ 是一个已知的几何尺度。每个波段的观测数据是流量比作为相位角函数的带噪声测量值，误差呈高斯分布。\n\n您需要设计并实现一个分层贝叶斯模型，该模型汇集多波段位相曲线，以联合约束依赖于波长的几何反照率 $A_g(\\lambda)$ 和共享的相位函数参数。请采用以下建模选择，以确保通用的可复现性和清晰性：\n\n1. 相位函数。使用单参数 Henyey–Greenstein 散射相位函数 $P(\\cos\\alpha; g)$，其各向异性参数 $g \\in (-1,1)$，并进行归一化，使得相位函数在 $\\alpha=0$ 时等于 $1$。即，\n$$\nP(\\cos\\alpha; g) = \\frac{1 - g^2}{\\left(1 + g^2 - 2g \\cos\\alpha\\right)^{3/2}}, \\quad \\Phi(\\alpha; g) = \\frac{P(\\cos\\alpha; g)}{P(1; g)}.\n$$\n所有角度 $\\alpha$ 必须以弧度为单位。\n\n2. 似然。对于波段 $b$，在相位角 $\\alpha_{i}$ 处的一次观测，其测量的流量比为 $y_{b,i}$，已知标准差为 $\\sigma_{b,i}$，模型为\n$$\ny_{b,i} \\sim \\mathcal{N}\\left(\\mu_b(\\alpha_i), \\sigma_{b,i}^2\\right).\n$$\n\n3. 跨波段几何反照率的分层先验。引入共享正态先验的无约束潜变量 $a_b \\in \\mathbb{R}$：\n$$\na_b \\sim \\mathcal{N}(\\mu_A, \\sigma_A^2), \\quad A_g^{(b)} = \\mathrm{logistic}(a_b) = \\frac{1}{1 + e^{-a_b}}.\n$$\n通过无约束参数化 $s = \\log \\sigma_A$ 对 $\\mu_A$ 和 $\\sigma_A$ 设置超先验：\n$$\n\\mu_A \\sim \\mathcal{N}(0, 2^2), \\quad s \\sim \\mathcal{N}(0, 0.5^2), \\quad \\sigma_A = e^s.\n$$\n\n4. 共享相位参数的先验。令 $g = \\tanh(\\eta)$，其中 $\\eta \\in \\mathbb{R}$，先验为\n$$\n\\eta \\sim \\mathcal{N}(0, 1).\n$$\n\n5. 推断目标。通过优化上述模型下的后验密度，计算共享相位参数 $g$ 和各波段几何反照率 $A_g^{(b)}$ 的联合最大后验估计。在本任务中，使用后验众数来近似后验均值。所有报告的量必须是无量纲的。所有相位角必须以弧度为单位。所有最终数值结果报告为小数点后六位的小数。\n\n实现一个程序，完成以下操作：\n- 对每个测试用例，使用指定的生成过程和固定的随机种子，构建合成的、可复现的多波段数据集。\n- 对每个测试用例，针对无约束参数 $\\boldsymbol{\\theta} = (\\eta, \\mu_A, s, a_1,\\dots,a_B)$ 优化联合后验。\n- 将优化器解变换回具有物理意义的参数 $g = \\tanh(\\eta)$ 和 $A_g^{(b)} = \\mathrm{logistic}(a_b)$。\n- 按照本说明末尾指定的精确格式输出估计值。\n\n测试套件和数据生成规范。对于每个测试用例，生成相位角，计算无噪声期望值，然后使用指定的标准差和随机种子添加高斯噪声。几何尺度因子 $\\left(\\frac{R_p}{a}\\right)^2$ 在每个测试中作为常数 $C$ 提供。\n\n- 测试用例 1 (顺利路径)：\n  - 波段数: $B = 3$。\n  - 真实参数: $g_\\mathrm{true} = 0.3$, $A_{g,\\mathrm{true}} = [0.2, 0.35, 0.5]$。\n  - 几何尺度: $C = 9.0\\times 10^{-5}$。\n  - 相位角: $\\alpha_i = 0.1 + 0.2(i-1)$ for $i=1,\\dots,15$ (弧度)。\n  - 每个波段的噪声标准差: $\\sigma_b = [1.0\\times 10^{-6}, 9.0\\times 10^{-7}, 1.2\\times 10^{-6}]$ 应用于每个波段内的所有点。\n  - 随机种子: $42$。\n\n- 测试用例 2 (边界各向同性散射)：\n  - 波段数: $B = 2$。\n  - 真实参数: $g_\\mathrm{true} = 0.0$, $A_{g,\\mathrm{true}} = [0.4, 0.4]$。\n  - 几何尺度: $C = 1.0\\times 10^{-4}$。\n  - 相位角: $\\alpha_i = 0.1 + 0.2(i-1)$ for $i=1,\\dots,15$ (弧度)。\n  - 每个波段的噪声标准差: $\\sigma_b = [2.0\\times 10^{-6}, 2.0\\times 10^{-6}]$ 应用于每个波段内的所有点。\n  - 随机种子: $7$。\n\n- 测试用例 3 (边缘各向异性和极端反照率)：\n  - 波段数: $B = 4$。\n  - 真实参数: $g_\\mathrm{true} = 0.85$, $A_{g,\\mathrm{true}} = [0.05, 0.8, 0.6, 0.15]$。\n  - 几何尺度: $C = 7.5\\times 10^{-5}$。\n  - 相位角: $\\alpha_i = 0.1 + \\frac{(3.0 - 0.1)}{19}(i-1)$ for $i=1,\\dots,20$ (弧度)，从 $0.1$ 到 $3.0$ (含)均匀分布。\n  - 每个波段的噪声标准差: $\\sigma_b = [5.0\\times 10^{-7}, 6.0\\times 10^{-7}, 6.0\\times 10^{-7}, 5.0\\times 10^{-7}]$ 应用于每个波段内的所有点。\n  - 随机种子: $123$。\n\n您的程序必须：\n- 实现上述分层贝叶斯模型，并使用对 $\\boldsymbol{\\theta}$ 的数值优化，计算每个测试用例的联合最大后验估计。\n- 完全按照规定使用指定的相位函数和先验。\n- 确保所有三角计算使用弧度单位的角度。\n- 生成单行输出，包含一个 Python 风格的列表的列表。每个内部列表必须对应一个测试用例，并包含 $B+1$ 个数字：第一个是估计的 $g$，后面是 $b=1,\\dots,B$ 的估计 $A_g^{(b)}$，顺序与生成数据时使用的波段顺序相同。每个数字必须打印到小数点后六位。例如，输出应如下所示：\n\"[ [g1,Ag1_1,Ag1_2,...], [g2,Ag2_1,Ag2_2,...], [g3,Ag3_1,Ag3_2,Ag3_3,Ag3_4] ]\"\n所有值都四舍五入到六位小数，且无附加文本。",
            "solution": "我们从行星在相位角 $\\alpha$ 处反射星光的物理关系出发，该关系源于能量守恒、几何稀释和双向反射特性。期望的行星与恒星的流量比为\n$$\n\\mu_b(\\alpha) = A_g^{(b)}\\,\\Phi(\\alpha;\\,\\boldsymbol{\\varphi})\\,\\left(\\frac{R_p}{a}\\right)^2,\n$$\n其中 $A_g^{(b)}$ 是波段 $b$ 的几何反照率，$\\Phi$ 是一个在 $\\alpha=0$ 处归一化为 $1$ 的无量纲相位函数，$\\left(\\frac{R_p}{a}\\right)^2$ 是表示平方反比几何稀释的已知尺度因子。相位角 $\\alpha$ 是行星上恒星与观测者之间的夹角；重要的是，在反射光中，流量比与 $A_g^{(b)}$ 呈线性关系，而角度依赖性则由 $\\Phi(\\alpha;\\,\\boldsymbol{\\varphi})$ 捕获。\n\n对于相位函数，我们采用单参数 Henyey–Greenstein 形式，\n$$\nP(\\cos\\alpha; g) = \\frac{1 - g^2}{\\left(1 + g^2 - 2g \\cos\\alpha\\right)^{3/2}},\n$$\n该函数被广泛用于描述各向异性散射，其不对称参数 $g \\in (-1,1)$，其中正 $g$ 表示前向散射，负 $g$ 表示后向散射。我们要求在零相位时有单位响应，因此归一化的相位函数为\n$$\n\\Phi(\\alpha; g) = \\frac{P(\\cos\\alpha; g)}{P(1; g)}.\n$$\n这种归一化保留了将几何反照率 $A_g^{(b)}$ 解释为零相位反射率标度的物理意义。\n\n观测值具有加性高斯噪声。对于波段 $b$ 和在相位 $\\alpha_i$ 处的第 $i$ 次观测，我们建模为\n$$\ny_{b,i} \\sim \\mathcal{N}\\left(\\mu_b(\\alpha_i), \\sigma_{b,i}^2\\right), \\quad \\mu_b(\\alpha_i) = A_g^{(b)}\\,\\Phi(\\alpha_i; g)\\,C,\n$$\n其中 $C = \\left(\\frac{R_p}{a}\\right)^2$ 在每个测试用例中被视为已知常数，并且没有单位，因为流量比是无量纲的。所有角度 $\\alpha_i$ 均以弧度为单位。\n\n为了在不同波长间共享信息并保持物理约束，我们通过对无约束潜变量 $a_b \\in \\mathbb{R}$ 设置正态先验，并使用 logistic 连接函数将它们映射到单位区间，从而引入跨波段几何反照率的分层先验：\n$$\na_b \\sim \\mathcal{N}(\\mu_A, \\sigma_A^2), \\quad A_g^{(b)} = \\mathrm{logistic}(a_b) = \\frac{1}{1 + e^{-a_b}}.\n$$\n这种选择通过构造使得 $A_g^{(b)} \\in (0,1)$，并通过共享的超参数 $(\\mu_A,\\sigma_A)$ 汇集了特定波段的反照率。我们使用无约束参数 $s = \\log \\sigma_A$ 对这些超参数设置弱信息先验：\n$$\n\\mu_A \\sim \\mathcal{N}(0, 2^2), \\quad s \\sim \\mathcal{N}(0, 0.5^2), \\quad \\sigma_A = e^s.\n$$\n各向异性参数 $g$ 必须位于 $(-1,1)$ 区间内；我们通过变换 $g = \\tanh(\\eta)$ 和以下先验来强制执行此约束\n$$\n\\eta \\sim \\mathcal{N}(0,1).\n$$\n\n将未知量收集到无约束向量 $\\boldsymbol{\\theta} = (\\eta, \\mu_A, s, a_1, \\dots, a_B)$ 中。后验密度与所有波段和观测的似然以及先验的乘积成正比。为了进行数值优化，我们处理负对数后验，并省略与 $\\boldsymbol{\\theta}$ 无关的常数，得到\n$$\n\\mathcal{L}(\\boldsymbol{\\theta}) = \\sum_{b=1}^B \\sum_{i=1}^{N_b} \\frac{1}{2}\\left(\\frac{y_{b,i} - \\mu_b(\\alpha_i)}{\\sigma_{b,i}}\\right)^2 + \\sum_{b=1}^B \\left[\\frac{1}{2}\\left(\\frac{a_b - \\mu_A}{\\sigma_A}\\right)^2 + \\log \\sigma_A\\right] + \\frac{1}{2}\\left(\\frac{\\mu_A}{2}\\right)^2 + \\frac{1}{2}\\left(\\frac{s}{0.5}\\right)^2 + \\frac{1}{2}\\eta^2,\n$$\n其中 $\\mu_b(\\alpha_i) = \\mathrm{logistic}(a_b)\\,\\Phi(\\alpha_i;\\tanh\\eta)\\,C$。$\\log \\sigma_A$ 项来自 $a_b$ 的正态先验归一化，并确保对 $\\sigma_A$ 的估计是适定的。\n\n推断过程是通过数值最小化 $\\mathcal{L}(\\boldsymbol{\\theta})$ 相对于无约束参数来进行的。最大后验估计是最小化子 $\\hat{\\boldsymbol{\\theta}}$，我们通过逆变换从中恢复具有物理意义的量：\n$$\n\\hat{g} = \\tanh(\\hat{\\eta}), \\quad \\hat{A}_g^{(b)} = \\mathrm{logistic}(\\hat{a}_b).\n$$\n由于在信息丰富的数据下，这些模型中的后验在众数附近近似为高斯分布，因此后验均值可以很好地用众数来近似。这是一种拉普拉斯近似，适用于所考虑的中等信噪比的相位曲线。\n\n程序的算法设计：\n- 对于每个测试用例，我们使用指定的真实参数 $(g_\\mathrm{true}, A_{g,\\mathrm{true}})$、几何尺度 $C$、相位角 $\\{\\alpha_i\\}$（以弧度为单位）以及具有指定标准差和种子的高斯噪声来生成合成数据。模型预测值为 $y^\\ast_{b,i} = A_{g,\\mathrm{true}}^{(b)} \\,\\Phi(\\alpha_i; g_\\mathrm{true})\\,C$。然后我们设置 $y_{b,i} = y^\\ast_{b,i} + \\epsilon_{b,i}$，其中 $\\epsilon_{b,i} \\sim \\mathcal{N}(0, \\sigma_{b}^2)$，$\\sigma_b$ 在波段 $b$ 内是常数。\n- 我们仔细实现归一化的 Henyey–Greenstein 函数 $\\Phi(\\alpha; g)$ 以确保 $\\Phi(0; g) = 1$。为了在 $g$ 接近 $\\pm 1$ 时保持数值稳定性，我们在计算时将 $g$ 裁剪到严格开区间 $(-1+\\varepsilon, 1-\\varepsilon)$ 内。$P(1; g)$ 的值可以使用 $P(1; g) = \\frac{1 + g}{(1 - g)^2}$ 进行稳健计算，这是在 $\\alpha=0$ 时简化通用表达式得到的结果。\n- 我们完全按照上述方式定义负对数后验 $\\mathcal{L}(\\boldsymbol{\\theta})$，并使用一种无梯度的拟牛顿方法，例如有限内存 Broyden–Fletcher–Goldfarb–Shanno (L-BFGS-B)，并对无约束变量进行边界处理以增强稳健性。由于变量是无约束的，除了在计算 $\\Phi$ 时进行数值裁剪外，我们不施加显式边界。\n- 我们提供一个合理的初始化：$\\eta=0$ (所以 $g=0$)，$\\mu_A=0$ (所以先验平均反照率为 $0.5$)，$s = \\log 0.5$ (中等先验散布)，以及所有波段的 $a_b=0$ (初始 $A_g^{(b)} = 0.5$)。分层结构和数据将引导优化过程找到最优解。\n- 优化后，我们将解变换为 $(\\hat{g}, \\hat{A}_g^{(1)}, \\dots, \\hat{A}_g^{(B)})$，并四舍五入到六位小数进行报告。\n\n程序将三个测试用例的结果汇总成单行输出，该输出由一个 Python 风格的列表的列表组成，其中每个内部列表包含估计值 $\\hat{g}$，后跟按波段排序的 $\\hat{A}_g^{(b)}$。所有数字都是无量纲的，角度如指定的那样以弧度为单位。数值答案是格式化为小数点后六位的浮点数，符合要求的输出格式。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef logistic(x):\n    # Numerically stable logistic\n    # For large negative x, np.exp(-x) may overflow; np.exp(-np.abs(x)) is safer\n    return 1.0 / (1.0 + np.exp(-x))\n\ndef phi_henyey_greenstein_normalized(alpha, g):\n    \"\"\"\n    Normalized HG phase function Phi(alpha; g) = P(cos alpha; g) / P(1; g)\n    with Phi(0) = 1.\n    \"\"\"\n    # Clip g away from +/-1 for numerical stability\n    g = np.clip(g, -0.999999, 0.999999)\n    cos_a = np.cos(alpha)\n    denom = (1.0 + g*g - 2.0*g*cos_a)\n    # Avoid negative due to numerical issues\n    denom = np.maximum(denom, 1e-15)\n    P = (1.0 - g*g) / np.power(denom, 1.5)\n    # P(1; g) can be simplified to (1 + g) / (1 - g)^2\n    P1 = (1.0 + g) / ((1.0 - g) ** 2)\n    Phi = P / P1\n    return Phi\n\ndef build_synthetic_data(B, C, alphas, g_true, Ag_true, sigmas, seed):\n    \"\"\"\n    Generate synthetic multi-band data for given test case.\n    alphas: 1D array of phase angles in radians\n    sigmas: list or array of sigma per band (constant for each band)\n    \"\"\"\n    rng = np.random.default_rng(seed)\n    alphas = np.array(alphas, dtype=float)\n    N = alphas.size\n    # Compute model mean for each band and phase\n    Phi_true = phi_henyey_greenstein_normalized(alphas, g_true)\n    ys = []\n    ss = []\n    for b in range(B):\n        mu = Ag_true[b] * Phi_true * C\n        sigma_b = float(sigmas[b])\n        noise = rng.normal(0.0, sigma_b, size=N)\n        y = mu + noise\n        ys.append(y)\n        ss.append(np.full_like(y, sigma_b))\n    return alphas, ys, ss\n\ndef neg_log_posterior(theta, data):\n    \"\"\"\n    Negative log-posterior given unconstrained theta = [eta, mu_A, s, a_1,...,a_B]\n    data is a dict with keys:\n        B, C, alphas, ys (list of arrays), sigmas (list of arrays)\n    Priors:\n        eta ~ N(0,1)\n        mu_A ~ N(0, 2^2)\n        s ~ N(0, 0.5^2); sigma_A = exp(s)\n        a_b ~ N(mu_A, sigma_A^2)\n    Likelihood:\n        y_{b,i} ~ N( logistic(a_b) * Phi(alpha_i; tanh(eta)) * C, sigma_{b,i}^2 )\n    \"\"\"\n    B = data[\"B\"]\n    C = data[\"C\"]\n    alphas = data[\"alphas\"]\n    ys = data[\"ys\"]\n    sigmas = data[\"sigmas\"]\n\n    eta = theta[0]\n    mu_A = theta[1]\n    s = theta[2]\n    a_vec = theta[3:3+B]\n\n    # Transforms\n    g = np.tanh(eta)\n    sigma_A = np.exp(s)\n    Ag_vec = logistic(a_vec)\n\n    # Prior contributions\n    nlp = 0.0\n    # eta prior N(0,1)\n    nlp += 0.5 * (eta ** 2)\n    # mu_A prior N(0, 2^2)\n    nlp += 0.5 * (mu_A / 2.0) ** 2\n    # s prior N(0, 0.5^2)\n    nlp += 0.5 * (s / 0.5) ** 2\n    # a_b priors: sum over bands\n    if sigma_A == 0 or not np.isfinite(sigma_A):\n        return 1e50\n    diffs = (a_vec - mu_A) / sigma_A\n    nlp += 0.5 * np.sum(diffs * diffs) + B * np.log(sigma_A)\n\n    # Likelihood\n    Phi = phi_henyey_greenstein_normalized(alphas, g)\n    for b in range(B):\n        mu_b = Ag_vec[b] * Phi * C\n        resid = (ys[b] - mu_b) / sigmas[b]\n        nlp += 0.5 * np.sum(resid * resid)\n\n    # Sanity: return large if NaN or inf\n    if not np.isfinite(nlp):\n        return 1e50\n    return nlp\n\ndef map_estimate(testcase):\n    \"\"\"\n    Compute MAP estimates for one test case.\n    Returns estimated g and array of Ag per band.\n    \"\"\"\n    B = testcase[\"B\"]\n    # Initial guess\n    eta0 = 0.0\n    mu_A0 = 0.0\n    s0 = np.log(0.5)\n    a0 = np.zeros(B)\n    theta0 = np.concatenate(([eta0, mu_A0, s0], a0))\n    # Optimize\n    res = minimize(\n        neg_log_posterior,\n        theta0,\n        args=(testcase,),\n        method=\"L-BFGS-B\",\n        options={\"maxiter\": 2000, \"ftol\": 1e-12}\n    )\n    theta_hat = res.x\n    eta_hat = theta_hat[0]\n    a_hat = theta_hat[3:3+B]\n    g_hat = np.tanh(eta_hat)\n    Ag_hat = logistic(a_hat)\n    return g_hat, Ag_hat\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Test case 1\n    alphas1 = np.array([0.1 + 0.2*(i) for i in range(15)], dtype=float)\n    tc1_true = {\n        \"B\": 3,\n        \"C\": 9.0e-5,\n        \"g_true\": 0.3,\n        \"Ag_true\": np.array([0.2, 0.35, 0.5], dtype=float),\n        \"sigmas\": np.array([1.0e-6, 9.0e-7, 1.2e-6], dtype=float),\n        \"alphas\": alphas1,\n        \"seed\": 42\n    }\n\n    # Test case 2\n    alphas2 = np.array([0.1 + 0.2*(i) for i in range(15)], dtype=float)\n    tc2_true = {\n        \"B\": 2,\n        \"C\": 1.0e-4,\n        \"g_true\": 0.0,\n        \"Ag_true\": np.array([0.4, 0.4], dtype=float),\n        \"sigmas\": np.array([2.0e-6, 2.0e-6], dtype=float),\n        \"alphas\": alphas2,\n        \"seed\": 7\n    }\n\n    # Test case 3\n    alphas3 = np.linspace(0.1, 3.0, 20, dtype=float)\n    tc3_true = {\n        \"B\": 4,\n        \"C\": 7.5e-5,\n        \"g_true\": 0.85,\n        \"Ag_true\": np.array([0.05, 0.8, 0.6, 0.15], dtype=float),\n        \"sigmas\": np.array([5.0e-7, 6.0e-7, 6.0e-7, 5.0e-7], dtype=float),\n        \"alphas\": alphas3,\n        \"seed\": 123\n    }\n\n    # Build synthetic datasets\n    test_cases = []\n    for spec in (tc1_true, tc2_true, tc3_true):\n        B = spec[\"B\"]\n        C = spec[\"C\"]\n        alphas = spec[\"alphas\"]\n        g_true = spec[\"g_true\"]\n        Ag_true = spec[\"Ag_true\"]\n        sigmas = spec[\"sigmas\"]\n        seed = spec[\"seed\"]\n        alphas, ys, ss = build_synthetic_data(B, C, alphas, g_true, Ag_true, sigmas, seed)\n        testcase = {\"B\": B, \"C\": C, \"alphas\": alphas, \"ys\": ys, \"sigmas\": ss}\n        test_cases.append(testcase)\n\n    # Perform MAP estimation for each test case\n    results = []\n    for case in test_cases:\n        g_hat, Ag_hat = map_estimate(case)\n        # Prepare formatted list: [g_hat, Ag_hat...]\n        inner = [g_hat] + list(Ag_hat)\n        results.append(inner)\n\n    # Format output as a single line with six decimals for each number\n    def format_inner(lst):\n        return \"[\" + \",\".join(f\"{x:.6f}\" for x in lst) + \"]\"\n\n    out = \"[\" + \",\".join(format_inner(inner) for inner in results) + \"]\"\n\n    # Final print statement in the exact required format.\n    print(out)\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}