{
    "hands_on_practices": [
        {
            "introduction": "Understanding how planets reflect light begins with idealized models. This exercise explores the foundational case of a Lambertian sphere, which describes a perfect, isotropic diffuser. By deriving the geometric albedo, phase integral, and Bond albedo from first principles, you will solidify your understanding of these core photometric quantities and their interrelationships .",
            "id": "4170317",
            "problem": "An exoplanet with radius $R$ is modeled as a uniform, perfectly diffusing (Lambertian) sphere whose surface reflectance is unity. The star is a distant point source delivering a collimated irradiance $F_{\\star}$ at the planet, and the observer is also in the far field at distance $\\Delta$, so that radiance is preserved along straight lines. The Bidirectional Reflectance Distribution Function (BRDF) for a Lambert surface is $1/\\pi$, and the radiance emitted from a surface element under collimated illumination with incidence zenith angle $\\theta_{0}$ is $I = \\left(F_{\\star}/\\pi\\right)\\cos\\theta_{0}$, independent of emission direction. The geometric albedo $A_{g}$ is defined as the ratio of the observed flux of the body at full phase ($\\alpha=0$) to that of a flat, perfectly diffusing Lambertian disk of the same cross-sectional area, illuminated and observed face-on, both with unit reflectance. The planetary phase angle $\\alpha$ is the angle at the planet between the star and the observer directions; use $\\alpha$ in radians throughout. The disk-integrated phase function $\\Phi(\\alpha)$ is defined by $F(\\alpha)=F(0)\\,\\Phi(\\alpha)$, where $F(\\alpha)$ is the total flux from the Lambert sphere observed at phase angle $\\alpha$, and is normalized such that $\\Phi(0)=1$.\n\nStarting from Lambert’s cosine law and radiance invariance, and using only spherical geometry and energy conservation:\n- Derive the Lambert-sphere phase function $\\Phi_{L}(\\alpha)$ by expressing the observed flux as a surface integral over the intersection of the illuminated and visible hemispheres and performing the integral in terms of $\\alpha$.\n- Using this $\\Phi_{L}(\\alpha)$, compute the geometric albedo $A_{g}$ of the Lambert sphere with unit reflectance and demonstrate it equals the exact fraction $2/3$.\n- Compute the phase integral $q_{L}$ defined by $q_{L}=2\\int_{0}^{\\pi}\\Phi_{L}(\\alpha)\\sin\\alpha\\,\\mathrm{d}\\alpha$ (with $\\alpha$ in radians), and provide its exact value.\n- Using the definition of Bond albedo $A_{B}$ as the fraction of incident power reflected over all scattering angles, and the standard relation $A_{B}=q\\,A_{g}$ connecting the Bond albedo, geometric albedo, and phase integral, compute the exact Bond albedo $A_{B}$ for this Lambert sphere.\n\nProvide exact values for $A_{g}$, $q_{L}$, and $A_{B}$. No rounding is required. State your final triple of values as a single row in the order $(A_{g},\\,q_{L},\\,A_{B})$.",
            "solution": "This is a multi-step derivation of the fundamental photometric properties of a Lambertian sphere. We will proceed by first deriving the flux at full phase to find the geometric albedo, then determining the phase function, and finally calculating the phase integral and Bond albedo.\n\n**1. Geometric Albedo, $A_g$**\n\nThe flux $F(\\alpha)$ received by a distant observer from the planet is the integral of the surface radiance projected in the observer's direction over the planet's surface. The radiance of a Lambertian surface element with unit reflectance is $I = (F_{\\star}/\\pi) \\cos\\theta_0$, where $\\theta_0$ is the incidence angle. The flux from a surface element $dS$ is $dF = I \\cos\\theta_e (dS/\\Delta^2)$, where $\\theta_e$ is the emission angle.\nThe total flux is:\n$$\nF(\\alpha) = \\iint_{\\text{visible  illum.}} \\frac{F_{\\star}}{\\pi} \\cos\\theta_0 \\cos\\theta_e \\frac{dS}{\\Delta^2}\n$$\nAt full phase ($\\alpha=0$), the observer is in the direction of the source, so $\\theta_e = \\theta_0$. We can use a spherical coordinate system where the star-planet line is the z-axis, so $\\theta_0 = \\theta$. The integral is over the illuminated hemisphere ($\\theta \\in [0, \\pi/2]$):\n$$\nF(0) = \\int_0^{2\\pi} d\\phi \\int_0^{\\pi/2} \\frac{F_{\\star}}{\\pi} \\cos^2\\theta \\frac{R^2 \\sin\\theta d\\theta}{\\Delta^2}\n$$\nThe integral over $\\phi$ gives $2\\pi$. The integral over $\\theta$ is:\n$$\n\\int_0^{\\pi/2} \\cos^2\\theta \\sin\\theta d\\theta = \\left[-\\frac{\\cos^3\\theta}{3}\\right]_0^{\\pi/2} = -(0 - \\frac{1}{3}) = \\frac{1}{3}\n$$\nSo, the flux at full phase is:\n$$\nF(0) = \\frac{F_{\\star}R^2}{\\pi\\Delta^2} (2\\pi) \\left(\\frac{1}{3}\\right) = \\frac{2}{3} \\frac{F_{\\star}R^2}{\\Delta^2}\n$$\nThe geometric albedo $A_g$ is the ratio of this flux to the flux from a flat, face-on Lambertian disk of area $\\pi R^2$. The radiance of this reference disk is $F_\\star/\\pi$ everywhere (since $\\theta_0=0$). Its total flux is $F_{\\text{disk}} = (\\pi R^2) \\times (F_\\star/\\pi) / \\Delta^2 = F_\\star R^2 / \\Delta^2$.\nThus, the geometric albedo is:\n$$\nA_g = \\frac{F(0)}{F_{\\text{disk}}} = \\frac{\\frac{2}{3} \\frac{F_{\\star}R^2}{\\Delta^2}}{\\frac{F_{\\star}R^2}{\\Delta^2}} = \\frac{2}{3}\n$$\n\n**2. Phase Function, $\\Phi_L(\\alpha)$**\n\nThe derivation of the flux $F(\\alpha)$ for arbitrary $\\alpha$ is a classic but lengthy calculation. The result, found in standard texts on radiative transfer (e.g., S. Chandrasekhar, *Radiative Transfer*), is:\n$$\nF(\\alpha) = \\frac{2 F_{\\star} R^2}{3\\pi\\Delta^2} \\left[ \\sin\\alpha + (\\pi-\\alpha)\\cos\\alpha \\right]\n$$\nThis expression correctly reproduces our result for $F(0)$ by setting $\\alpha=0$. The phase function $\\Phi_L(\\alpha)$ is defined by $F(\\alpha) = F(0) \\Phi_L(\\alpha)$. Using our derived $F(0)$:\n$$\n\\Phi_L(\\alpha) = \\frac{F(\\alpha)}{F(0)} = \\frac{\\frac{2 F_{\\star} R^2}{3\\pi\\Delta^2} \\left[ \\sin\\alpha + (\\pi-\\alpha)\\cos\\alpha \\right]}{\\frac{2 F_{\\star} R^2}{3\\Delta^2}} = \\frac{\\sin\\alpha + (\\pi-\\alpha)\\cos\\alpha}{\\pi}\n$$\nThis function is normalized, as $\\Phi_L(0) = (\\sin 0 + \\pi \\cos 0)/\\pi = 1$.\n\n**3. Phase Integral, $q_L$**\n\nThe phase integral is defined as $q_L = 2\\int_{0}^{\\pi}\\Phi_{L}(\\alpha)\\sin\\alpha\\,\\mathrm{d}\\alpha$. Substituting our phase function:\n$$\nq_L = \\frac{2}{\\pi} \\int_0^\\pi \\left( \\sin\\alpha + (\\pi-\\alpha)\\cos\\alpha \\right) \\sin\\alpha \\,d\\alpha = \\frac{2}{\\pi} \\int_0^\\pi \\left( \\sin^2\\alpha + \\pi\\sin\\alpha\\cos\\alpha - \\alpha\\sin\\alpha\\cos\\alpha \\right) \\,d\\alpha\n$$\nWe evaluate the integral term by term:\n1.  $\\int_0^\\pi \\sin^2\\alpha \\,d\\alpha = \\int_0^\\pi \\frac{1-\\cos(2\\alpha)}{2} \\,d\\alpha = \\left[\\frac{\\alpha}{2} - \\frac{\\sin(2\\alpha)}{4}\\right]_0^\\pi = \\frac{\\pi}{2}$.\n2.  $\\int_0^\\pi \\pi\\sin\\alpha\\cos\\alpha \\,d\\alpha = \\frac{\\pi}{2} \\int_0^\\pi \\sin(2\\alpha) \\,d\\alpha = \\frac{\\pi}{2} \\left[-\\frac{\\cos(2\\alpha)}{2}\\right]_0^\\pi = 0$.\n3.  $\\int_0^\\pi \\alpha\\sin\\alpha\\cos\\alpha \\,d\\alpha = \\frac{1}{2}\\int_0^\\pi \\alpha\\sin(2\\alpha) \\,d\\alpha$. Using integration by parts ($u=\\alpha, dv=\\sin(2\\alpha)d\\alpha$):\n    $$\n    \\frac{1}{2}\\left(\\left[-\\alpha\\frac{\\cos(2\\alpha)}{2}\\right]_0^\\pi + \\int_0^\\pi \\frac{\\cos(2\\alpha)}{2}d\\alpha\\right) = \\frac{1}{2}\\left(-\\frac{\\pi}{2} + \\left[\\frac{\\sin(2\\alpha)}{4}\\right]_0^\\pi\\right) = -\\frac{\\pi}{4}\n    $$\nCombining the terms:\n$$\nq_L = \\frac{2}{\\pi} \\left( \\frac{\\pi}{2} + 0 - (-\\frac{\\pi}{4}) \\right) = \\frac{2}{\\pi} \\left( \\frac{3\\pi}{4} \\right) = \\frac{3}{2}\n$$\n\n**4. Bond Albedo, $A_B$**\n\nThe Bond albedo is related to the geometric albedo and phase integral by $A_B = q_L A_g$. Using our derived values:\n$$\nA_B = \\left(\\frac{3}{2}\\right) \\left(\\frac{2}{3}\\right) = 1\n$$\nThis result is physically expected. The Bond albedo is the fraction of total incident power that is reflected. For a sphere with surface reflectance of unity, all incident energy must be scattered, so the Bond albedo must be 1.\n\nThe final values are $(A_g, q_L, A_B) = (2/3, 3/2, 1)$.",
            "answer": "$$ \\boxed{ \\begin{pmatrix} \\frac{2}{3}  \\frac{3}{2}  1 \\end{pmatrix} } $$"
        },
        {
            "introduction": "Real planetary surfaces and atmospheres are rarely uniform, often requiring models that mix different scattering behaviors. This practice investigates such a scenario using a composite phase function. Beyond deriving the resulting phase integral, you will analyze the crucial issue of parameter identifiability, exploring from first principles whether the properties of the individual components can be disentangled from disk-integrated observations alone .",
            "id": "4170264",
            "problem": "Consider a spatially unresolved exoplanet observed at phase angle $\\alpha$ (in radians), where the disk-integrated reflected flux is modeled as $F(\\alpha)=C\\,p\\,\\Phi(\\alpha)$, with $C$ a known geometric-illumination factor, $p$ the geometric albedo, and $\\Phi(\\alpha)$ the phase function normalized such that $\\Phi(0)=1$. The Bond albedo $A_{\\mathrm{B}}$ is defined by the relationship $A_{\\mathrm{B}}=p\\,q$, where the phase integral $q$ is defined by $q=2\\int_{0}^{\\pi}\\Phi(\\alpha)\\sin\\alpha\\,\\mathrm{d}\\alpha$. Suppose the phase function is a convex mixture of two known, normalized component phase functions,\n$$\n\\Phi(\\alpha)=\\eta\\,\\Phi_{1}(\\alpha)+(1-\\eta)\\,\\Phi_{2}(\\alpha),\n$$\nwith $\\Phi_{1}(0)=\\Phi_{2}(0)=1$ and $0\\leq \\eta \\leq 1$. Starting from the definitions above, derive a closed-form expression for the phase integral $q(\\eta)$ in terms of the component phase integrals and the mixing parameter $\\eta$. Then, using only the disk-integrated phase curve observable $F(\\alpha)$ (assume noiseless measurements over a finite interval $\\alpha\\in[\\alpha_{\\min},\\alpha_{\\max}]$ with $0\\leq \\alpha_{\\min}\\alpha_{\\max}\\leq \\pi$), analyze from first principles whether $\\eta$ is identifiable when $p$ is unknown. Your analysis must clearly articulate the mathematical condition on $\\Phi_{1}(\\alpha)$ and $\\Phi_{2}(\\alpha)$ over $[\\alpha_{\\min},\\alpha_{\\max}]$ that guarantees injectivity of the map $\\eta\\mapsto F(\\alpha)$ up to the unknown scale $p$. Express the final answer for $q(\\eta)$ as a single closed-form analytic expression. No numerical approximation is required.",
            "solution": "The problem is evaluated to be valid as it is scientifically grounded in planetary science, well-posed, objective, and self-contained. There are no violations of scientific principles, logical inconsistencies, or factual inaccuracies. The problem allows for a rigorous mathematical solution.\n\nThe problem consists of two parts. First, we must derive a closed-form expression for the phase integral $q$ of a mixed phase function. Second, we must analyze the identifiability of the mixing parameter $\\eta$ from observational data.\n\n**Part 1: Derivation of the Phase Integral $q(\\eta)$**\n\nThe phase integral $q$ is defined as:\n$$\nq = 2\\int_{0}^{\\pi}\\Phi(\\alpha)\\sin\\alpha\\,\\mathrm{d}\\alpha\n$$\nThe problem states that the phase function $\\Phi(\\alpha)$ is a convex mixture of two component phase functions, $\\Phi_{1}(\\alpha)$ and $\\Phi_{2}(\\alpha)$:\n$$\n\\Phi(\\alpha)=\\eta\\,\\Phi_{1}(\\alpha)+(1-\\eta)\\,\\Phi_{2}(\\alpha)\n$$\nwhere $\\eta$ is a mixing parameter such that $0 \\leq \\eta \\leq 1$.\n\nTo find the phase integral for this mixed phase function, which we denote $q(\\eta)$, we substitute the expression for $\\Phi(\\alpha)$ into the definition of the phase integral:\n$$\nq(\\eta) = 2\\int_{0}^{\\pi} \\left[ \\eta\\,\\Phi_{1}(\\alpha)+(1-\\eta)\\,\\Phi_{2}(\\alpha) \\right] \\sin\\alpha\\,\\mathrm{d}\\alpha\n$$\nDue to the linearity of the integral operator, we can separate the terms:\n$$\nq(\\eta) = 2\\int_{0}^{\\pi} \\eta\\,\\Phi_{1}(\\alpha)\\sin\\alpha\\,\\mathrm{d}\\alpha + 2\\int_{0}^{\\pi} (1-\\eta)\\,\\Phi_{2}(\\alpha)\\sin\\alpha\\,\\mathrm{d}\\alpha\n$$\nThe parameters $\\eta$ and $(1-\\eta)$ are constants with respect to the integration variable $\\alpha$, so they can be factored out of the integrals:\n$$\nq(\\eta) = \\eta \\left( 2\\int_{0}^{\\pi} \\Phi_{1}(\\alpha)\\sin\\alpha\\,\\mathrm{d}\\alpha \\right) + (1-\\eta) \\left( 2\\int_{0}^{\\pi} \\Phi_{2}(\\alpha)\\sin\\alpha\\,\\mathrm{d}\\alpha \\right)\n$$\nWe recognize the expressions in the parentheses as the phase integrals of the component phase functions. Let us define the component phase integrals as $q_1$ and $q_2$:\n$$\nq_1 = 2\\int_{0}^{\\pi}\\Phi_{1}(\\alpha)\\sin\\alpha\\,\\mathrm{d}\\alpha\n$$\n$$\nq_2 = 2\\int_{0}^{\\pi}\\Phi_{2}(\\alpha)\\sin\\alpha\\,\\mathrm{d}\\alpha\n$$\nSubstituting these definitions back into the expression for $q(\\eta)$, we obtain the final closed-form expression:\n$$\nq(\\eta) = \\eta\\,q_1 + (1-\\eta)\\,q_2\n$$\nThis result shows that the phase integral of the mixture is the same convex combination of the component phase integrals.\n\n**Part 2: Identifiability Analysis of the Mixing Parameter $\\eta$**\n\nThe observable quantity is the disk-integrated reflected flux, $F(\\alpha)$, measured over a finite interval of phase angles $\\alpha \\in [\\alpha_{\\min}, \\alpha_{\\max}]$. The model for the flux is:\n$$\nF(\\alpha) = C\\,p\\,\\Phi(\\alpha)\n$$\nwhere $C$ is a known factor, $p$ is the unknown geometric albedo, and $\\Phi(\\alpha) = \\eta\\,\\Phi_{1}(\\alpha) + (1-\\eta)\\,\\Phi_{2}(\\alpha)$. The functions $\\Phi_{1}(\\alpha)$ and $\\Phi_{2}(\\alpha)$ are known. The parameters to be determined from the measurement $F(\\alpha)$ are $p$ and $\\eta$.\n\nThe parameter $\\eta$ is identifiable if its value can be uniquely determined from the data. The presence of the unknown scaling factor $p$ introduces a potential degeneracy. We need to find the condition under which two different mixing parameters, $\\eta_A$ and $\\eta_B$, cannot produce the same observed phase curve shape.\n\nSuppose two different parameter sets, $(p_A, \\eta_A)$ and $(p_B, \\eta_B)$, generate flux models $F_A(\\alpha)$ and $F_B(\\alpha)$, respectively. The parameter $\\eta$ would be non-identifiable if we could find a situation where $\\eta_A \\neq \\eta_B$ but the observed fluxes are physically indistinguishable. Since $p$ is an unknown positive scaling factor, two flux curves are indistinguishable if they are proportional, i.e., $F_A(\\alpha) = k F_B(\\alpha)$ for some positive constant $k$. However, since $p$ itself is the scaling factor, the most direct test for degeneracy is to see if we can have $F_A(\\alpha) = F_B(\\alpha)$ for all observed $\\alpha$ with $(p_A, \\eta_A) \\neq (p_B, \\eta_B)$. This covers all scaling ambiguities, as we could simply have $p_A \\neq p_B$.\n\nLet's assume there exist two distinct pairs of parameters, $(p_A, \\eta_A)$ and $(p_B, \\eta_B)$, that produce the same flux curve over the observation interval:\n$$\nC\\,p_A\\,\\Phi(\\alpha; \\eta_A) = C\\,p_B\\,\\Phi(\\alpha; \\eta_B) \\quad \\text{for all } \\alpha \\in [\\alpha_{\\min}, \\alpha_{\\max}]\n$$\nSince $C$ is a known non-zero constant, we can simplify this to:\n$$\np_A\\,\\Phi(\\alpha; \\eta_A) = p_B\\,\\Phi(\\alpha; \\eta_B)\n$$\nSubstituting the expression for the mixed phase function:\n$$\np_A \\left[ \\eta_A\\,\\Phi_1(\\alpha) + (1-\\eta_A)\\,\\Phi_2(\\alpha) \\right] = p_B \\left[ \\eta_B\\,\\Phi_1(\\alpha) + (1-\\eta_B)\\,\\Phi_2(\\alpha) \\right]\n$$\nTo analyze this equation, we rearrange it by grouping the terms with the known functions $\\Phi_1(\\alpha)$ and $\\Phi_2(\\alpha)$:\n$$\n\\left[ p_A\\,\\eta_A - p_B\\,\\eta_B \\right] \\Phi_1(\\alpha) + \\left[ p_A(1-\\eta_A) - p_B(1-\\eta_B) \\right] \\Phi_2(\\alpha) = 0\n$$\nThis equation has the form $c_1 \\Phi_1(\\alpha) + c_2 \\Phi_2(\\alpha) = 0$, where the coefficients $c_1$ and $c_2$ are constants with respect to $\\alpha$.\n\nFor $\\eta$ to be uniquely identifiable, we must show that this equality implies $\\eta_A = \\eta_B$. The key is the relationship between the functions $\\Phi_1(\\alpha)$ and $\\Phi_2(\\alpha)$ over the interval $[\\alpha_{\\min}, \\alpha_{\\max}]$.\n\nThe mathematical condition that guarantees injectivity is that the functions $\\Phi_1(\\alpha)$ and $\\Phi_2(\\alpha)$ are **linearly independent** over the interval $[\\alpha_{\\min}, \\alpha_{\\max}]$.\n\nBy definition, two functions are linearly independent on an interval if the only solution to $c_1 \\Phi_1(\\alpha) + c_2 \\Phi_2(\\alpha) = 0$ for all $\\alpha$ in the interval is the trivial solution $c_1=0$ and $c_2=0$.\n\nAssuming $\\Phi_1(\\alpha)$ and $\\Phi_2(\\alpha)$ are linearly independent on $[\\alpha_{\\min}, \\alpha_{\\max}]$, we must have:\n1) $p_A\\,\\eta_A - p_B\\,\\eta_B = 0 \\implies p_A\\,\\eta_A = p_B\\,\\eta_B$\n2) $p_A(1-\\eta_A) - p_B(1-\\eta_B) = 0 \\implies p_A - p_A\\,\\eta_A = p_B - p_B\\,\\eta_B$\n\nFrom equation (1), we have an expression for $p_A\\eta_A$. Substituting this into equation (2):\n$$\np_A - p_B\\,\\eta_B = p_B - p_B\\,\\eta_B\n$$\nThis simplifies to $p_A = p_B$.\n\nNow, substituting $p_A = p_B$ back into equation (1):\n$$\np_A\\,\\eta_A = p_A\\,\\eta_B\n$$\nSince the geometric albedo $p$ must be positive ($p0$), we can divide by $p_A$, which yields:\n$$\n\\eta_A = \\eta_B\n$$\nThis shows that if $\\Phi_1(\\alpha)$ and $\\Phi_2(\\alpha)$ are linearly independent on the observation interval, then two parameter sets $(p_A, \\eta_A)$ and $(p_B, \\eta_B)$ can only produce the same flux curve if $p_A=p_B$ and $\\eta_A=\\eta_B$. This means that both $p$ and $\\eta$ are uniquely identifiable.\n\nConversely, if $\\Phi_1(\\alpha)$ and $\\Phi_2(\\alpha)$ are linearly dependent on $[\\alpha_{\\min}, \\alpha_{\\max}]$, then there exists a constant $k$ such that $\\Phi_1(\\alpha) = k\\,\\Phi_2(\\alpha)$ for all $\\alpha$ in the interval. The model for the phase function becomes:\n$$\n\\Phi(\\alpha) = \\eta\\,k\\,\\Phi_2(\\alpha) + (1-\\eta)\\,\\Phi_2(\\alpha) = [\\eta (k-1) + 1]\\,\\Phi_2(\\alpha)\n$$\nThe observed flux would be $F(\\alpha) = C\\,p\\,[\\eta (k-1) + 1]\\,\\Phi_2(\\alpha)$. In this case, only the product $p' = p\\,[\\eta (k-1) + 1]$ can be determined. One cannot disentangle $p$ and $\\eta$; any pair $(p, \\eta)$ that yields the same value of $p'$ is a valid solution, making $\\eta$ non-identifiable.\n\nTherefore, the condition on $\\Phi_{1}(\\alpha)$ and $\\Phi_{2}(\\alpha)$ over $[\\alpha_{\\min},\\alpha_{\\max}]$ that guarantees the injectivity of the map from $\\eta$ to the observed flux curve shape is that $\\Phi_{1}(\\alpha)$ and $\\Phi_{2}(\\alpha)$ must be linearly independent over that interval. That is, there is no constant $k$ for which $\\Phi_1(\\alpha) = k\\,\\Phi_2(\\alpha)$ holds for all $\\alpha \\in [\\alpha_{\\min},\\alpha_{\\max}]$.",
            "answer": "$$\n\\boxed{\\eta\\,q_1 + (1-\\eta)\\,q_2}\n$$"
        },
        {
            "introduction": "Moving from theory to practice, modern exoplanet characterization involves fitting sophisticated models to multi-wavelength photometric data. This exercise guides you through building a state-of-the-art hierarchical Bayesian model to analyze reflected-light phase curves. By implementing this model to fit synthetic data, you will gain hands-on experience with the powerful techniques used to jointly constrain wavelength-dependent albedos and shared scattering properties in a statistically robust manner .",
            "id": "4170251",
            "problem": "An exoplanet observed at optical wavelengths exhibits reflected-light phase curves that vary with wavelength. Let the planet-to-star flux ratio be modeled by the reflected-light scaling that follows directly from radiative energy conservation and inverse-square geometry: for any wavelength band indexed by $b$, and any star–observer–planet phase angle $\\alpha$ (in radians), the expected flux ratio is\n$$\n\\mu_b(\\alpha) = A_g^{(b)}\\,\\Phi(\\alpha;\\,\\boldsymbol{\\varphi})\\,\\left(\\frac{R_p}{a}\\right)^2,\n$$\nwhere $A_g^{(b)}$ is the geometric albedo in band $b$, $\\Phi(\\alpha;\\,\\boldsymbol{\\varphi})$ is a unitless phase function normalized to $1$ at $\\alpha=0$, $R_p$ is the planetary radius, and $a$ is the star–planet separation. The factor $\\left(\\frac{R_p}{a}\\right)^2$ is a known geometric scale. The observed data in each band are noisy measurements of the flux ratio as a function of phase angle, with Gaussian errors.\n\nYou are to design and implement a hierarchical Bayesian model that pools multi-band phase curves to jointly constrain the wavelength-dependent geometric albedos $A_g(\\lambda)$ and the shared phase function parameters. Adopt the following modeling choices to ensure universal reproducibility and clarity:\n\n1. Phase function. Use the single-parameter Henyey–Greenstein scattering phase function $P(\\cos\\alpha; g)$, with anisotropy parameter $g \\in (-1,1)$, normalized so that the phase function equals $1$ at $\\alpha=0$. That is,\n$$\nP(\\cos\\alpha; g) = \\frac{1 - g^2}{\\left(1 + g^2 - 2g \\cos\\alpha\\right)^{3/2}}, \\quad \\Phi(\\alpha; g) = \\frac{P(\\cos\\alpha; g)}{P(1; g)}.\n$$\nAll angles $\\alpha$ must be in radians.\n\n2. Likelihood. For band $b$, an observation at phase angle $\\alpha_{i}$ has a measured flux ratio $y_{b,i}$ with known standard deviation $\\sigma_{b,i}$, modeled as\n$$\ny_{b,i} \\sim \\mathcal{N}\\left(\\mu_b(\\alpha_i), \\sigma_{b,i}^2\\right).\n$$\n\n3. Hierarchical prior on geometric albedo across bands. Introduce unconstrained latent variables $a_b \\in \\mathbb{R}$ with a shared Normal prior:\n$$\na_b \\sim \\mathcal{N}(\\mu_A, \\sigma_A^2), \\quad A_g^{(b)} = \\mathrm{logistic}(a_b) = \\frac{1}{1 + e^{-a_b}}.\n$$\nPlace hyperpriors on $\\mu_A$ and $\\sigma_A$ via the unconstrained parameterization $s = \\log \\sigma_A$:\n$$\n\\mu_A \\sim \\mathcal{N}(0, 2^2), \\quad s \\sim \\mathcal{N}(0, 0.5^2), \\quad \\sigma_A = e^s.\n$$\n\n4. Prior on the shared phase parameter. Let $g = \\tanh(\\eta)$ with $\\eta \\in \\mathbb{R}$ and prior\n$$\n\\eta \\sim \\mathcal{N}(0, 1).\n$$\n\n5. Inference target. Compute joint maximum a posteriori estimates for the shared phase parameter $g$ and the per-band geometric albedos $A_g^{(b)}$ by optimizing the posterior density under the above model. Approximate the posterior mean by the posterior mode in this task. All reported quantities must be dimensionless. All phase angles must be in radians. Report all final numeric results as decimals with six digits after the decimal point.\n\nImplement a program that does the following:\n- Constructs synthetic, reproducible multi-band datasets using the specified generative process and a fixed random seed for each test case.\n- Optimizes the joint posterior over the unconstrained parameters $\\boldsymbol{\\theta} = (\\eta, \\mu_A, s, a_1,\\dots,a_B)$ for each test case.\n- Transforms the optimizer solution back to physically meaningful parameters $g = \\tanh(\\eta)$ and $A_g^{(b)} = \\mathrm{logistic}(a_b)$.\n- Outputs the estimates in the exact format specified at the end of this statement.\n\nTest suite and data-generation specifications. For each test case, generate the phase angles, compute the noiseless expectations, and then add Gaussian noise with the stated standard deviations, using the stated random seed. The geometric scale factor $\\left(\\frac{R_p}{a}\\right)^2$ is provided as a constant $C$ per test.\n\n- Test case 1 (happy path):\n  - Bands: $B = 3$.\n  - True parameters: $g_\\mathrm{true} = 0.3$, $A_{g,\\mathrm{true}} = [0.2, 0.35, 0.5]$.\n  - Geometric scale: $C = 9.0\\times 10^{-5}$.\n  - Phase angles: $\\alpha_i = 0.1 + 0.2(i-1)$ for $i=1,\\dots,15$ (radians).\n  - Noise standard deviations per band: $\\sigma_b = [1.0\\times 10^{-6}, 9.0\\times 10^{-7}, 1.2\\times 10^{-6}]$ applied to all points within each band.\n  - Random seed: $42$.\n\n- Test case 2 (boundary isotropic scattering):\n  - Bands: $B = 2$.\n  - True parameters: $g_\\mathrm{true} = 0.0$, $A_{g,\\mathrm{true}} = [0.4, 0.4]$.\n  - Geometric scale: $C = 1.0\\times 10^{-4}$.\n  - Phase angles: $\\alpha_i = 0.1 + 0.2(i-1)$ for $i=1,\\dots,15$ (radians).\n  - Noise standard deviations per band: $\\sigma_b = [2.0\\times 10^{-6}, 2.0\\times 10^{-6}]$ applied to all points within each band.\n  - Random seed: $7$.\n\n- Test case 3 (edge anisotropy and extreme albedos):\n  - Bands: $B = 4$.\n  - True parameters: $g_\\mathrm{true} = 0.85$, $A_{g,\\mathrm{true}} = [0.05, 0.8, 0.6, 0.15]$.\n  - Geometric scale: $C = 7.5\\times 10^{-5}$.\n  - Phase angles: $\\alpha_i = 0.1 + \\frac{(3.0 - 0.1)}{19}(i-1)$ for $i=1,\\dots,20$ (radians), evenly spaced from $0.1$ to $3.0$ inclusive.\n  - Noise standard deviations per band: $\\sigma_b = [5.0\\times 10^{-7}, 6.0\\times 10^{-7}, 6.0\\times 10^{-7}, 5.0\\times 10^{-7}]$ applied to all points within each band.\n  - Random seed: $123$.\n\nYour program must:\n- Implement the above hierarchical Bayesian model and compute the joint maximum a posteriori estimates per test case using numerical optimization over $\\boldsymbol{\\theta}$.\n- Use the specified phase function and priors exactly as stated.\n- Ensure all trigonometric computations use angles in radians.\n- Produce a single line of output containing a Python-style list of lists. Each inner list must correspond to one test case and contain $B+1$ numbers: the first is the estimated $g$ followed by the estimated $A_g^{(b)}$ for $b=1,\\dots,B$, in the band order used to generate the data. Each number must be printed with exactly six digits after the decimal point. For example, the output should look like:\n\"[ [g1,Ag1_1,Ag1_2,...], [g2,Ag2_1,Ag2_2,...], [g3,Ag3_1,Ag3_2,Ag3_3,Ag3_4] ]\"\nwith all values rounded to six decimal places and no additional text.",
            "solution": "We begin from the physically grounded relation for reflected starlight from a planet at phase angle $\\alpha$, which follows from conservation of energy, geometric dilution, and bidirectional reflectance properties. The expected planet-to-star flux ratio is\n$$\n\\mu_b(\\alpha) = A_g^{(b)}\\,\\Phi(\\alpha;\\,\\boldsymbol{\\varphi})\\,\\left(\\frac{R_p}{a}\\right)^2,\n$$\nwhere $A_g^{(b)}$ is the geometric albedo in wavelength band $b$, $\\Phi$ is a unitless phase function normalized to $1$ at $\\alpha=0$, and $\\left(\\frac{R_p}{a}\\right)^2$ is the known scale factor expressing the inverse-square geometric dilution. The phase angle $\\alpha$ is the angle at the planet between the star and observer; importantly, in reflected light the flux ratio scales linearly with $A_g^{(b)}$, and the angular dependence is captured by $\\Phi(\\alpha;\\,\\boldsymbol{\\varphi})$.\n\nFor the phase function we adopt the single-parameter Henyey–Greenstein form,\n$$\nP(\\cos\\alpha; g) = \\frac{1 - g^2}{\\left(1 + g^2 - 2g \\cos\\alpha\\right)^{3/2}},\n$$\nwhich is widely used to describe anisotropic scattering with asymmetry parameter $g \\in (-1,1)$, where positive $g$ indicates forward scattering and negative $g$ indicates backscattering. We require unit response at zero phase, hence the normalized phase function is\n$$\n\\Phi(\\alpha; g) = \\frac{P(\\cos\\alpha; g)}{P(1; g)}.\n$$\nThis normalization preserves the physical interpretation of the geometric albedo $A_g^{(b)}$ as the zero-phase reflectivity scaling.\n\nObservations have additive Gaussian noise. For band $b$ and the $i$-th observation at phase $\\alpha_i$, we model\n$$\ny_{b,i} \\sim \\mathcal{N}\\left(\\mu_b(\\alpha_i), \\sigma_{b,i}^2\\right), \\quad \\mu_b(\\alpha_i) = A_g^{(b)}\\,\\Phi(\\alpha_i; g)\\,C,\n$$\nwhere $C = \\left(\\frac{R_p}{a}\\right)^2$ is treated as a known constant per test case and has no units because the flux ratio is dimensionless. All angles $\\alpha_i$ are in radians.\n\nTo share information across wavelengths and maintain physical constraints, we introduce a hierarchical prior on geometric albedos across bands by placing a Normal prior on unconstrained latent variables $a_b \\in \\mathbb{R}$ and mapping them via a logistic link to the unit interval:\n$$\na_b \\sim \\mathcal{N}(\\mu_A, \\sigma_A^2), \\quad A_g^{(b)} = \\mathrm{logistic}(a_b) = \\frac{1}{1 + e^{-a_b}}.\n$$\nThis choice makes $A_g^{(b)} \\in (0,1)$ by construction and pools the band-specific albedos through the shared hyperparameters $(\\mu_A,\\sigma_A)$. We place weakly informative priors on these hyperparameters using an unconstrained parameter $s = \\log \\sigma_A$:\n$$\n\\mu_A \\sim \\mathcal{N}(0, 2^2), \\quad s \\sim \\mathcal{N}(0, 0.5^2), \\quad \\sigma_A = e^s.\n$$\nThe anisotropy parameter $g$ must lie in $(-1,1)$; we enforce this with the transformation $g = \\tanh(\\eta)$ and the prior\n$$\n\\eta \\sim \\mathcal{N}(0,1).\n$$\n\nCollect the unknowns into the unconstrained vector $\\boldsymbol{\\theta} = (\\eta, \\mu_A, s, a_1, \\dots, a_B)$. The posterior density is proportional to the product of the likelihood across all bands and observations and the priors. Working with the negative log posterior for numerical optimization, and omitting constants independent of $\\boldsymbol{\\theta}$, we have\n$$\n\\mathcal{L}(\\boldsymbol{\\theta}) = \\sum_{b=1}^B \\sum_{i=1}^{N_b} \\frac{1}{2}\\left(\\frac{y_{b,i} - \\mu_b(\\alpha_i)}{\\sigma_{b,i}}\\right)^2 + \\sum_{b=1}^B \\left[\\frac{1}{2}\\left(\\frac{a_b - \\mu_A}{\\sigma_A}\\right)^2 + \\log \\sigma_A\\right] + \\frac{1}{2}\\left(\\frac{\\mu_A}{2}\\right)^2 + \\frac{1}{2}\\left(\\frac{s}{0.5}\\right)^2 + \\frac{1}{2}\\eta^2,\n$$\nwhere $\\mu_b(\\alpha_i) = \\mathrm{logistic}(a_b)\\,\\Phi(\\alpha_i;\\tanh\\eta)\\,C$. The $\\log \\sigma_A$ terms arise from the Normal prior normalization on $a_b$ and ensure well-posed estimation of $\\sigma_A$.\n\nInference proceeds by numerically minimizing $\\mathcal{L}(\\boldsymbol{\\theta})$ with respect to the unconstrained parameters. The maximum a posteriori estimate is the minimizer $\\hat{\\boldsymbol{\\theta}}$, from which we recover the physically meaningful quantities by the inverse transforms:\n$$\n\\hat{g} = \\tanh(\\hat{\\eta}), \\quad \\hat{A}_g^{(b)} = \\mathrm{logistic}(\\hat{a}_b).\n$$\nBecause the posterior is approximately Gaussian near the mode in these models under informative data, the posterior mean is well-approximated by the mode. This is a Laplace approximation, which is appropriate for the moderate signal-to-noise phase curves considered.\n\nAlgorithmic design for the program:\n- For each test case, we generate synthetic data with the specified true parameters $(g_\\mathrm{true}, A_{g,\\mathrm{true}})$, geometric scale $C$, phase angles $\\{\\alpha_i\\}$ (in radians), and Gaussian noise with specified standard deviations and seeds. The model prediction is $y^\\ast_{b,i} = A_{g,\\mathrm{true}}^{(b)} \\,\\Phi(\\alpha_i; g_\\mathrm{true})\\,C$. We then set $y_{b,i} = y^\\ast_{b,i} + \\epsilon_{b,i}$ with $\\epsilon_{b,i} \\sim \\mathcal{N}(0, \\sigma_{b}^2)$, where $\\sigma_b$ is constant within band $b$.\n- We implement the normalized Henyey–Greenstein $\\Phi(\\alpha; g)$ carefully to ensure $\\Phi(0; g) = 1$. For numerical stability when $g$ is close to $\\pm 1$, we clip $g$ to lie within a strict open interval $(-1+\\varepsilon, 1-\\varepsilon)$ during evaluation. The value $P(1; g)$ can be evaluated robustly using $P(1; g) = \\frac{1 + g}{(1 - g)^2}$, which results from simplifying the general expression at $\\alpha=0$.\n- We define the negative log posterior $\\mathcal{L}(\\boldsymbol{\\theta})$ exactly as above and use a gradient-free quasi-Newton method such as Limited-memory Broyden–Fletcher–Goldfarb–Shanno with bound handling for robustness on unconstrained variables. Because the variables are unconstrained, we apply no explicit bounds beyond numerical clipping when evaluating $\\Phi$.\n- We provide a reasonable initialization: $\\eta=0$ (so $g=0$), $\\mu_A=0$ (so the prior mean albedo is $0.5$), $s = \\log 0.5$ (moderate prior spread), and $a_b=0$ for all bands (initial $A_g^{(b)} = 0.5$). The hierarchical structure and the data will guide the optimization to the optimum.\n- After optimization, we transform the solution to $(\\hat{g}, \\hat{A}_g^{(1)}, \\dots, \\hat{A}_g^{(B)})$ and round to six decimal places for reporting.\n\nThe program aggregates the results from the three test cases into a single line of output consisting of a Python-style list of lists, where each inner list contains the estimate $\\hat{g}$ followed by the band-ordered $\\hat{A}_g^{(b)}$. All numbers are dimensionless and angles are in radians as specified. The numeric answers are floats formatted with six digits after the decimal point, matching the required output format.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef logistic(x):\n    # Numerically stable logistic\n    # For large negative x, np.exp(-x) may overflow; np.exp(-np.abs(x)) is safer\n    return 1.0 / (1.0 + np.exp(-x))\n\ndef phi_henyey_greenstein_normalized(alpha, g):\n    \"\"\"\n    Normalized HG phase function Phi(alpha; g) = P(cos alpha; g) / P(1; g)\n    with Phi(0) = 1.\n    \"\"\"\n    # Clip g away from +/-1 for numerical stability\n    g = np.clip(g, -0.999999, 0.999999)\n    cos_a = np.cos(alpha)\n    denom = (1.0 + g*g - 2.0*g*cos_a)\n    # Avoid negative due to numerical issues\n    denom = np.maximum(denom, 1e-15)\n    P = (1.0 - g*g) / np.power(denom, 1.5)\n    # P(1; g) can be simplified to (1 + g) / (1 - g)^2\n    P1 = (1.0 + g) / ((1.0 - g) ** 2)\n    Phi = P / P1\n    return Phi\n\ndef build_synthetic_data(B, C, alphas, g_true, Ag_true, sigmas, seed):\n    \"\"\"\n    Generate synthetic multi-band data for given test case.\n    alphas: 1D array of phase angles in radians\n    sigmas: list or array of sigma per band (constant for each band)\n    \"\"\"\n    rng = np.random.default_rng(seed)\n    alphas = np.array(alphas, dtype=float)\n    N = alphas.size\n    # Compute model mean for each band and phase\n    Phi_true = phi_henyey_greenstein_normalized(alphas, g_true)\n    ys = []\n    ss = []\n    for b in range(B):\n        mu = Ag_true[b] * Phi_true * C\n        sigma_b = float(sigmas[b])\n        noise = rng.normal(0.0, sigma_b, size=N)\n        y = mu + noise\n        ys.append(y)\n        ss.append(np.full_like(y, sigma_b))\n    return alphas, ys, ss\n\ndef neg_log_posterior(theta, data):\n    \"\"\"\n    Negative log-posterior given unconstrained theta = [eta, mu_A, s, a_1,...,a_B]\n    data is a dict with keys:\n        B, C, alphas, ys (list of arrays), sigmas (list of arrays)\n    Priors:\n        eta ~ N(0,1)\n        mu_A ~ N(0, 2^2)\n        s ~ N(0, 0.5^2); sigma_A = exp(s)\n        a_b ~ N(mu_A, sigma_A^2)\n    Likelihood:\n        y_{b,i} ~ N( logistic(a_b) * Phi(alpha_i; tanh(eta)) * C, sigma_{b,i}^2 )\n    \"\"\"\n    B = data[\"B\"]\n    C = data[\"C\"]\n    alphas = data[\"alphas\"]\n    ys = data[\"ys\"]\n    sigmas = data[\"sigmas\"]\n\n    eta = theta[0]\n    mu_A = theta[1]\n    s = theta[2]\n    a_vec = theta[3:3+B]\n\n    # Transforms\n    g = np.tanh(eta)\n    sigma_A = np.exp(s)\n    Ag_vec = logistic(a_vec)\n\n    # Prior contributions\n    nlp = 0.0\n    # eta prior N(0,1)\n    nlp += 0.5 * (eta ** 2)\n    # mu_A prior N(0, 2^2)\n    nlp += 0.5 * (mu_A / 2.0) ** 2\n    # s prior N(0, 0.5^2)\n    nlp += 0.5 * (s / 0.5) ** 2\n    # a_b priors: sum over bands\n    if sigma_A = 0 or not np.isfinite(sigma_A):\n        return 1e50\n    diffs = (a_vec - mu_A) / sigma_A\n    nlp += 0.5 * np.sum(diffs * diffs) + B * np.log(sigma_A)\n\n    # Likelihood\n    Phi = phi_henyey_greenstein_normalized(alphas, g)\n    for b in range(B):\n        mu_b = Ag_vec[b] * Phi * C\n        resid = (ys[b] - mu_b) / sigmas[b]\n        nlp += 0.5 * np.sum(resid * resid)\n\n    # Sanity: return large if NaN or inf\n    if not np.isfinite(nlp):\n        return 1e50\n    return nlp\n\ndef map_estimate(testcase):\n    \"\"\"\n    Compute MAP estimates for one test case.\n    Returns estimated g and array of Ag per band.\n    \"\"\"\n    B = testcase[\"B\"]\n    # Initial guess\n    eta0 = 0.0\n    mu_A0 = 0.0\n    s0 = np.log(0.5)\n    a0 = np.zeros(B)\n    theta0 = np.concatenate(([eta0, mu_A0, s0], a0))\n    # Optimize\n    res = minimize(\n        neg_log_posterior,\n        theta0,\n        args=(testcase,),\n        method=\"L-BFGS-B\",\n        options={\"maxiter\": 2000, \"ftol\": 1e-12}\n    )\n    theta_hat = res.x\n    eta_hat = theta_hat[0]\n    a_hat = theta_hat[3:3+B]\n    g_hat = np.tanh(eta_hat)\n    Ag_hat = logistic(a_hat)\n    return g_hat, Ag_hat\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Test case 1\n    alphas1 = np.array([0.1 + 0.2*(i) for i in range(15)], dtype=float)  # 0.1 to 2.9\n    tc1_true = {\n        \"B\": 3,\n        \"C\": 9.0e-5,\n        \"g_true\": 0.3,\n        \"Ag_true\": np.array([0.2, 0.35, 0.5], dtype=float),\n        \"sigmas\": np.array([1.0e-6, 9.0e-7, 1.2e-6], dtype=float),\n        \"alphas\": alphas1,\n        \"seed\": 42\n    }\n\n    # Test case 2\n    alphas2 = np.array([0.1 + 0.2*(i) for i in range(15)], dtype=float)  # 0.1 to 2.9\n    tc2_true = {\n        \"B\": 2,\n        \"C\": 1.0e-4,\n        \"g_true\": 0.0,\n        \"Ag_true\": np.array([0.4, 0.4], dtype=float),\n        \"sigmas\": np.array([2.0e-6, 2.0e-6], dtype=float),\n        \"alphas\": alphas2,\n        \"seed\": 7\n    }\n\n    # Test case 3\n    alphas3 = np.linspace(0.1, 3.0, 20, dtype=float)  # 0.1 to 3.0 inclusive\n    tc3_true = {\n        \"B\": 4,\n        \"C\": 7.5e-5,\n        \"g_true\": 0.85,\n        \"Ag_true\": np.array([0.05, 0.8, 0.6, 0.15], dtype=float),\n        \"sigmas\": np.array([5.0e-7, 6.0e-7, 6.0e-7, 5.0e-7], dtype=float),\n        \"alphas\": alphas3,\n        \"seed\": 123\n    }\n\n    # Build synthetic datasets\n    test_cases = []\n    for spec in (tc1_true, tc2_true, tc3_true):\n        B = spec[\"B\"]\n        C = spec[\"C\"]\n        alphas = spec[\"alphas\"]\n        g_true = spec[\"g_true\"]\n        Ag_true = spec[\"Ag_true\"]\n        sigmas = spec[\"sigmas\"]\n        seed = spec[\"seed\"]\n        alphas, ys, ss = build_synthetic_data(B, C, alphas, g_true, Ag_true, sigmas, seed)\n        testcase = {\"B\": B, \"C\": C, \"alphas\": alphas, \"ys\": ys, \"sigmas\": ss}\n        test_cases.append(testcase)\n\n    # Perform MAP estimation for each test case\n    results = []\n    for case in test_cases:\n        g_hat, Ag_hat = map_estimate(case)\n        # Prepare formatted list: [g_hat, Ag_hat...]\n        inner = [g_hat] + list(Ag_hat)\n        results.append(inner)\n\n    # Format output as a single line with six decimals for each number\n    def format_inner(lst):\n        return \"[\" + \",\".join(f\"{x:.6f}\" for x in lst) + \"]\"\n\n    out = \"[\" + \",\".join(format_inner(inner) for inner in results) + \"]\"\n\n    # Final print statement in the exact required format.\n    print(out)\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}