{"hands_on_practices": [{"introduction": "Successful immune profiling hinges on robust experimental design, especially when targeting rare cell populations. This exercise [@problem_id:2888909] guides you through a critical a priori power calculation to determine the necessary sequencing depth for your experiment. By applying fundamental principles of probability, specifically a Poisson approximation to a binomial sampling process, you will learn to calculate the minimum number of cells, $n$, required to ensure your rare population of interest is captured with high confidence, a foundational skill for designing efficient and cost-effective single-cell studies.", "problem": "A droplet-based single-cell RNA sequencing (scRNA-seq) experiment aims to capture a representative sample of immune cells from a solid tissue in which a rare cell population has an expected fraction of $f = 0.001$. Assume cell capture events are independent and unbiased with respect to cell identity, that doublets are negligible, and that $f$ is constant across the captured sample. Let $X$ be the number of rare cells observed among $n$ captured cells. Using only fundamental definitions of the binomial model and the rare-event Poisson approximation, determine the minimal integer $n$ such that the probability of observing at least $k = 10$ rare cells satisfies $\\mathbb{P}(X \\geq 10) \\geq 0.95$. Clearly state your modeling assumptions. Report the minimal integer $n$ that satisfies the criterion. Do not include units in your final answer.", "solution": "The problem statement will first be validated for scientific and logical integrity.\n\nStep 1: Extract Givens\n- Expected fraction of a rare cell population: $f = 0.001$.\n- Number of captured cells: $n$.\n- Random variable for the number of observed rare cells: $X$.\n- Assumptions: Cell capture events are independent and unbiased; doublets are negligible; $f$ is constant.\n- Models to be used: Binomial model and Poisson approximation.\n- Target number of rare cells to observe: at least $k = 10$.\n- Probability criterion: $\\mathbb{P}(X \\geq 10) \\geq 0.95$.\n- Objective: Determine the minimal integer $n$ satisfying the criterion.\n\nStep 2: Validate Using Extracted Givens\n- **Scientifically Grounded**: The problem describes a standard experimental design calculation in single-cell genomics. The use of a binomial model for sampling and its Poisson approximation for rare events are fundamental and correct statistical practices in this context. The parameters provided ($f=0.001$, $k=10$) are realistic.\n- **Well-Posed**: The problem is mathematically well-defined. It requests the minimum integer $n$ that satisfies a specific probability inequality, for which a unique solution exists.\n- **Objective**: The problem is stated in precise, quantitative terms, free from ambiguity or subjective content.\n\nStep 3: Verdict and Action\nThe problem is deemed valid as it is scientifically sound, well-posed, and objective. A solution will now be derived.\n\nThe number of rare cells, $X$, observed among $n$ total captured cells is a random variable. Each cell capture is an independent Bernoulli trial with a probability of success (capturing a rare cell) of $p = f = 0.001$. The total number of trials is $n$. Therefore, $X$ follows a binomial distribution:\n$$X \\sim \\text{Binomial}(n, p)$$\nThe probability mass function is given by $\\mathbb{P}(X=j) = \\binom{n}{j} p^j (1-p)^{n-j}$.\n\nThe problem requires using the Poisson approximation, which is appropriate here as the number of trials $n$ is expected to be large and the probability of a success $p$ is small. The binomial distribution can be approximated by a Poisson distribution with parameter $\\lambda$, equal to the expected number of successes:\n$$\\lambda = E[X] = np$$\nThus, we model $X$ as:\n$$X \\approx \\text{Poisson}(\\lambda)$$\nwhere $\\lambda = n \\times 0.001$. The probability mass function under this approximation is $\\mathbb{P}(X=j) \\approx \\frac{e^{-\\lambda}\\lambda^j}{j!}$.\n\nThe problem is to find the minimal integer $n$ such that the probability of observing at least $k=10$ rare cells is no less than $0.95$:\n$$\\mathbb{P}(X \\geq 10) \\geq 0.95$$\nIt is more convenient to work with the complementary event, $\\mathbb{P}(X < 10)$. The inequality can be rewritten as:\n$$1 - \\mathbb{P}(X < 10) \\geq 0.95$$\n$$\\mathbb{P}(X \\leq 9) \\leq 0.05$$\nUsing the Poisson approximation, this condition is:\n$$\\sum_{j=0}^{9} \\frac{e^{-\\lambda}\\lambda^j}{j!} \\leq 0.05$$\nLet $F(\\lambda; m) = \\sum_{j=0}^{m} \\frac{e^{-\\lambda}\\lambda^j}{j!}$ denote the cumulative distribution function (CDF) of a Poisson distribution with parameter $\\lambda$. The function $F(\\lambda; m)$ is a monotonically decreasing function of $\\lambda$ for a fixed $m$. Therefore, the inequality $F(\\lambda; 9) \\leq 0.05$ will hold for all $\\lambda$ greater than or equal to some critical value, $\\lambda_{crit}$, where $F(\\lambda_{crit}; 9) = 0.05$.\n\nTo find $\\lambda_{crit}$, we use the fundamental identity relating the Poisson CDF to the regularized upper incomplete gamma function, which is in turn related to the CDF of the chi-squared ($\\chi^2$) distribution:\n$$\\mathbb{P}(X \\leq m) = \\frac{\\Gamma(m+1, \\lambda)}{\\Gamma(m+1)} = \\mathbb{P}(\\chi^2_{2(m+1)} > 2\\lambda)$$\nwhere $\\chi^2_{2(m+1)}$ is a chi-squared random variable with $2(m+1)$ degrees of freedom.\n\nFor our problem, $m=9$, so we have:\n$$\\mathbb{P}(X \\leq 9) = \\mathbb{P}(\\chi^2_{2(9+1)} > 2\\lambda) = \\mathbb{P}(\\chi^2_{20} > 2\\lambda)$$\nThe condition $\\mathbb{P}(X \\leq 9) \\leq 0.05$ becomes:\n$$\\mathbb{P}(\\chi^2_{20} > 2\\lambda) \\leq 0.05$$\nLet $\\chi^2_{\\alpha, \\nu}$ denote the upper critical value of the chi-squared distribution with $\\nu$ degrees of freedom for a significance level $\\alpha$, i.e., $\\mathbb{P}(\\chi^2_{\\nu} > \\chi^2_{\\alpha, \\nu}) = \\alpha$. From standard statistical tables, the critical value for $\\nu=20$ degrees of freedom and $\\alpha=0.05$ is:\n$$\\chi^2_{0.05, 20} \\approx 31.4104$$\nSince the tail probability function $\\mathbb{P}(\\chi^2_{20} > x)$ is a monotonically decreasing function of $x$, the inequality $\\mathbb{P}(\\chi^2_{20} > 2\\lambda) \\leq 0.05$ implies:\n$$2\\lambda \\geq \\chi^2_{0.05, 20}$$\n$$2\\lambda \\geq 31.4104$$\n$$\\lambda \\geq \\frac{31.4104}{2} = 15.7052$$\nNow, we substitute $\\lambda = np = n \\times 0.001$ back into the inequality:\n$$n \\times 0.001 \\geq 15.7052$$\nSolving for $n$:\n$$n \\geq \\frac{15.7052}{0.001}$$\n$$n \\geq 15705.2$$\nSince the number of cells $n$ must be an integer, the minimal integer value that satisfies this condition is the smallest integer greater than or equal to $15705.2$, which is:\n$$n_{min} = \\lceil 15705.2 \\rceil = 15706$$\nThus, a minimum of $15706$ cells must be captured to ensure the probability of observing at least $10$ rare cells is at least $0.95$, under the given assumptions.", "answer": "$$\\boxed{15706}$$", "id": "2888909"}, {"introduction": "Modern single-cell experiments generate vast datasets, often profiling millions of cells across tens of thousands of genes, making computational efficiency a primary concern. This practice [@problem_id:2888883] delves into the structure of the resulting count matrices, highlighting their inherent sparsity. You will derive the memory requirements for storing such a matrix using the Compressed Sparse Column (CSC) format, providing a tangible understanding of how data scale impacts computational resources and why specialized data structures are essential in bioinformatics.", "problem": "A single-cell ribonucleic acid (RNA) count matrix used for immune profiling can be modeled as a nonnegative integer matrix $X \\in \\mathbb{N}_{0}^{G \\times C}$, where $G$ is the number of genes and $C$ is the number of cells. In high-throughput single-cell assays, $X$ is typically sparse: most entries are zero because, for any given cell, only a small subset of genes have nonzero counts. Define the density $\\rho \\in [0,1]$ as the fraction of entries in $X$ that are nonzero. \n\nA standard machine representation for such count matrices is the Compressed Sparse Column (CSC) format. In CSC, the matrix is stored using three one-dimensional arrays:\n- a value array of length $\\mathrm{nnz}$ holding the nonzero counts,\n- a row-index array of length $\\mathrm{nnz}$ holding the row indices (gene indices) for each nonzero,\n- a column-pointer array of length $C+1$ marking the starting offset in the value array for each column (cell), where $\\mathrm{nnz}$ denotes the total number of nonzero entries.\n\nAssume the following data types are used:\n- nonzero values (unique molecular identifier counts) stored as $32$-bit unsigned integers (each occupying $4$ bytes),\n- row indices stored as $32$-bit unsigned integers (each occupying $4$ bytes),\n- column pointers stored as $64$-bit unsigned integers (each occupying $8$ bytes).\n\nStarting from the definitions above and without assuming any pre-derived memory formulas, derive a general expression for the total memory in bytes required to store $X$ in CSC as a function of $G$, $C$, and $\\rho$. Then evaluate it for $C = 10^{6}$ cells, $G = 2.0 \\times 10^{4}$ genes, and $\\rho = 0.01$. Express the final memory requirement in gigabytes (GB), using $1\\,\\mathrm{GB} = 10^{9}$ bytes, and round your final numerical answer to four significant figures.", "solution": "The problem will first be subjected to a rigorous validation process.\n\n**Step 1: Extract Givens**\n\nThe problem provides the following definitions, parameters, and conditions verbatim:\n- A count matrix $X \\in \\mathbb{N}_{0}^{G \\times C}$, where $G$ is the number of genes and $C$ is the number of cells.\n- The matrix $X$ is sparse.\n- Density $\\rho \\in [0,1]$ is the fraction of entries in $X$ that are nonzero.\n- The matrix is stored in Compressed Sparse Column (CSC) format using three arrays:\n    - A value array of length $\\mathrm{nnz}$ holding the nonzero counts.\n    - A row-index array of length $\\mathrm{nnz}$ holding the row indices.\n    - A column-pointer array of length $C+1$.\n- $\\mathrm{nnz}$ denotes the total number of nonzero entries.\n- Data types and memory sizes are specified:\n    - Nonzero values are $32$-bit unsigned integers, occupying $4$ bytes each.\n    - Row indices are $32$-bit unsigned integers, occupying $4$ bytes each.\n    - Column pointers are $64$-bit unsigned integers, occupying $8$ bytes each.\n- The objective is to derive a general expression for the total memory in bytes, $M$, as a function of $G$, $C$, and $\\rho$.\n- This expression is to be evaluated for $C = 10^{6}$ cells, $G = 2.0 \\times 10^{4}$ genes, and $\\rho = 0.01$.\n- The final numerical result must be expressed in gigabytes (GB), using the conversion $1\\,\\mathrm{GB} = 10^{9}$ bytes, and rounded to four significant figures.\n\n**Step 2: Validate Using Extracted Givens**\n\nThe problem is examined against the required criteria.\n- **Scientifically Grounded**: The problem is grounded in computational biology and computer science. The description of single-cell RNA-seq count matrices and their storage in CSC format is factually correct and standard practice in the field.\n- **Well-Posed**: The problem is well-posed. All required variables ($G$, $C$, $\\rho$), data type sizes, and storage format specifications are provided, enabling the derivation of a unique and meaningful solution.\n- **Objective**: The problem is stated with precise, objective language. There are no subjective or ambiguous terms.\n\nThe problem does not exhibit any invalidating flaws. It is scientifically sound, self-contained, and quantitatively formalizable. The provided values for $G$, $C$, and $\\rho$ are realistic for large-scale single-cell immunology studies. The use of $64$-bit pointers for a dataset of this scale, while not strictly necessary for the number of non-zero elements given ($\\mathrm{nnz} = 2 \\times 10^8 < 2^{32}$), is a common and reasonable choice in software libraries designed for scalability, and thus does not constitute a contradiction or an unrealistic condition.\n\n**Step 3: Verdict and Action**\n\nThe problem is **valid**. A solution will be derived.\n\n**Derivation of the Memory Expression**\n\nLet $M$ be the total memory required in bytes. The total memory is the sum of the memory consumed by the three arrays constituting the CSC format: the value array ($M_{\\text{val}}$), the row-index array ($M_{\\text{row}}$), and the column-pointer array ($M_{\\text{ptr}}$).\n\n$$M = M_{\\text{val}} + M_{\\text{row}} + M_{\\text{ptr}}$$\n\nFirst, we define the memory requirement for each array based on the problem statement.\nThe value array stores $\\mathrm{nnz}$ elements, with each element being a $32$-bit integer, which is specified as $4$ bytes.\n$$M_{\\text{val}} = \\mathrm{nnz} \\times 4$$\nThe row-index array also stores $\\mathrm{nnz}$ elements. Each row index is a $32$-bit integer, using $4$ bytes.\n$$M_{\\text{row}} = \\mathrm{nnz} \\times 4$$\nThe column-pointer array contains $C+1$ elements. Each element is a $64$-bit integer, using $8$ bytes.\n$$M_{\\text{ptr}} = (C+1) \\times 8$$\n\nSumming these components gives the total memory in bytes:\n$$M = (\\mathrm{nnz} \\times 4) + (\\mathrm{nnz} \\times 4) + ((C+1) \\times 8)$$\n$$M = \\mathrm{nnz} \\times 8 + (C+1) \\times 8$$\n$$M = 8(\\mathrm{nnz} + C + 1)$$\n\nThe number of nonzero elements, $\\mathrm{nnz}$, is given by the density $\\rho$ multiplied by the total number of entries in the matrix, which is $G \\times C$.\n$$\\mathrm{nnz} = \\rho G C$$\n\nSubstituting this expression for $\\mathrm{nnz}$ into the equation for $M$ yields the general expression for total memory as a function of $G$, $C$, and $\\rho$:\n$$M(G, C, \\rho) = 8(\\rho G C + C + 1)$$\n\nThis expression is derived from first principles as required.\n\n**Numerical Evaluation**\n\nWe now evaluate this expression for the given parameters:\n- $G = 2.0 \\times 10^{4}$\n- $C = 10^{6}$\n- $\\rho = 0.01 = 10^{-2}$\n\nFirst, calculate the number of nonzero elements, $\\mathrm{nnz}$:\n$$\\mathrm{nnz} = \\rho G C = (10^{-2}) \\times (2.0 \\times 10^{4}) \\times (10^{6}) = 2.0 \\times 10^{8}$$\n\nNow substitute this and the value of $C$ into the memory formula for $M$ in bytes:\n$$M = 8(\\mathrm{nnz} + C + 1)$$\n$$M = 8(2.0 \\times 10^{8} + 10^{6} + 1)$$\n$$M = 8(200,000,000 + 1,000,000 + 1)$$\n$$M = 8(201,000,001)$$\n$$M = 1,608,000,008 \\text{ bytes}$$\n\nThe problem requires the answer in gigabytes (GB), with the conversion $1\\,\\mathrm{GB} = 10^{9}$ bytes.\n$$M_{\\text{GB}} = \\frac{1,608,000,008}{10^{9}} = 1.608000008 \\text{ GB}$$\n\nFinally, this value must be rounded to four significant figures. The first four significant figures are $1$, $6$, $0$, and $8$. The fifth digit is $0$, so we do not round up.\n$$M_{\\text{GB}} \\approx 1.608$$\n\nThe final numerical answer is $1.608$.", "answer": "$$\n\\boxed{1.608}\n$$", "id": "2888883"}, {"introduction": "The raw output of a droplet-based sequencing experiment is often obscured by technical artifacts, with ambient RNA contamination being a primary challenge. This advanced exercise [@problem_id:2888861] tasks you with developing a rigorous statistical framework to model and correct for this noise. Through the derivation and application of a probabilistic mixture model with profiles $\\phi$ and $\\alpha$, you will gain hands-on experience in a critical data pre-processing step by solving for the decontaminated profile via maximum likelihood estimation, turning noisy measurements into biologically meaningful cellular data.", "problem": "You are tasked with formalizing and solving a probabilistic mixture model for ambient ribonucleic acid (RNA) contamination in single-cell droplet-based sequencing with Unique Molecular Identifier (UMI) counting, a standard setting for immune profiling at single-cell resolution. Each droplet (either a cell-containing droplet or an empty droplet) yields counts per gene. Consider the following well-tested facts and definitions as the foundational base for your derivation:\n\n- In droplet-based single-cell RNA sequencing with Unique Molecular Identifier (UMI) counts, it is standard to model the count of gene-specific molecules as independent Poisson random variables. For droplet $j$ and gene $g$, the count $X_{jg}$ is modeled as\n$$\nX_{jg} \\sim \\text{Poisson}\\left(s_j \\cdot \\lambda_{jg}\\right),\n$$\nwhere $s_j$ is a droplet-specific scaling capturing the total sampling depth, and $\\lambda_{jg}$ is the gene-specific expected fraction in droplet $j$.\n- For contamination modeling, a commonly used mixture structure is\n$$\n\\lambda_{jg} = (1 - \\rho_j)\\,\\phi_{jg} + \\rho_j\\,\\alpha_g,\n$$\nwhere $\\rho_j \\in [0,1)$ is the contamination fraction for droplet $j$, $\\phi_{j} = (\\phi_{jg})_{g=1}^G$ is the latent true cell profile for droplet $j$ (a probability vector with $\\phi_{jg} \\ge 0$ and $\\sum_{g=1}^G \\phi_{jg} = 1$), and $\\alpha = (\\alpha_g)_{g=1}^G$ is the ambient profile (a probability vector with $\\alpha_g \\ge 0$ and $\\sum_{g=1}^G \\alpha_g = 1$) shared across droplets.\n- Conditioning on the total count in a droplet $j$, $N_j = \\sum_{g=1}^G X_{jg}$, the vector of counts follows a multinomial distribution with probabilities proportional to $\\lambda_{jg}$, namely\n$$\n(X_{j1},\\dots,X_{jG}) \\,\\big|\\, N_j \\sim \\text{Multinomial}\\left(N_j,\\, y_j\\right), \\quad \\text{with} \\quad y_{jg} = (1 - \\rho_j)\\,\\phi_{jg} + \\rho_j\\,\\alpha_g.\n$$\n\nYour tasks:\n\n1) Ambient profile estimation from empty droplets. Assume a collection $\\mathcal{E}$ of empty droplets that contain only ambient RNA, so that for each $e \\in \\mathcal{E}$ and each gene $g$,\n$$\nX_{eg} \\sim \\text{Poisson}\\!\\left(s_e \\cdot \\rho_e \\cdot \\alpha_g\\right).\n$$\nShow that the maximum likelihood estimator (MLE) of the ambient profile $\\alpha$ is the normalized aggregate of empty-droplet counts,\n$$\n\\widehat{\\alpha}_g \\;=\\; \\frac{\\sum_{e \\in \\mathcal{E}} X_{eg}}{\\sum_{e \\in \\mathcal{E}} \\sum_{h=1}^G X_{eh}}.\n$$\n\n2) Cell profile decontamination via maximum likelihood. For a single cell-containing droplet $j$ with observed counts $c_g = X_{jg}$ and total $N = \\sum_{g=1}^G c_g$, and with a known contamination fraction $\\rho \\in [0,1)$ and known ambient profile $\\widehat{\\alpha}$, derive the maximum likelihood estimator of the decontaminated cell profile $\\phi = (\\phi_g)_{g=1}^G$, under the constraints $\\phi_g \\ge 0$ and $\\sum_{g=1}^G \\phi_g = 1$. Use only the foundational base provided above. Specifically, use the fact that, conditional on $N$, the likelihood is that of a multinomial with probabilities $y_g = (1 - \\rho)\\phi_g + \\rho \\widehat{\\alpha}_g$, and that the MLE for the multinomial probabilities without constraints is $\\widehat{y}_g = c_g / N$. Incorporate the constraints $y_g \\ge \\rho \\widehat{\\alpha}_g$ and $\\sum_{g=1}^G y_g = 1$ via a principled optimization approach to obtain an algorithmic solution for $\\widehat{\\phi}$.\n\n3) Algorithm design requirement. Your derivation must culminate in a numerically stable algorithm that:\n- Computes $\\widehat{\\alpha}$ from empty droplets by the MLE in task $1$.\n- Computes $\\widehat{\\phi}$ for a cell by finding the Kullbackâ€“Leibler optimal $y^{\\star}$ under the constraints $y_g \\ge a_g$ with $a_g = \\rho \\widehat{\\alpha}_g$ and $\\sum_g y_g = 1$, and then mapping back via\n$$\n\\widehat{\\phi}_g \\;=\\; \\frac{y_g^{\\star} - a_g}{1 - \\rho}.\n$$\nThe algorithm must satisfy the constraints even when some $\\widehat{y}_g = c_g/N$ fall below $a_g$. Your final expression for $\\widehat{\\phi}$ must be nonnegative and sum to $1$.\n\n4) Test suite and required outputs. Implement your derivation as a complete, runnable program that solves the following six test cases. In all cases, there are $G = 4$ genes, the empty-droplet counts for case $i$ are denoted $E^{(i)}$, the cell counts are $C^{(i)}$, and the contamination fraction is $r^{(i)}$. For each case, estimate $\\widehat{\\alpha}^{(i)}$ from the provided empty droplets and then compute $\\widehat{\\phi}^{(i)}$ for the provided cell counts and $r^{(i)}$.\n\n- Case $1$: $E^{(1)} = [100, 30, 20, 10]$, $C^{(1)} = [50, 5, 3, 2]$, $r^{(1)} = 0.2$.\n- Case $2$: $E^{(2)} = [0, 50, 50, 0]$, $C^{(2)} = [0, 10, 5, 5]$, $r^{(2)} = 0.1$.\n- Case $3$: $E^{(3)} = [200, 0, 0, 0]$, $C^{(3)} = [80, 10, 5, 5]$, $r^{(3)} = 0.6$.\n- Case $4$: $E^{(4)} = [90, 10, 0, 0]$, $C^{(4)} = [5, 3, 1, 1]$, $r^{(4)} = 0.5$.\n- Case $5$: $E^{(5)} = [70, 20, 10, 0]$, $C^{(5)} = [10, 0, 0, 0]$, $r^{(5)} = 0.3$.\n- Case $6$: $E^{(6)} = [1, 1, 1, 1]$, $C^{(6)} = [1, 2, 3, 4]$, $r^{(6)} = 0$.\n\n5) Final output format. For each case, output the decontaminated profile $\\widehat{\\phi}^{(i)}$ as a length-$4$ vector in the gene order given. Concatenate these six vectors in order into a single list of $24$ floating-point numbers. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example\n$[v_1, v_2, \\dots, v_{24}]$,\nwhere $v_k$ are the concatenated entries of $\\widehat{\\phi}^{(1)}, \\widehat{\\phi}^{(2)}, \\dots, \\widehat{\\phi}^{(6)}$ in that order. Express all numbers as decimals rounded to six places.", "solution": "The problem posed is scientifically sound, well-posed, and contains sufficient information for a unique solution. It is a standard problem in computational biology for analyzing single-cell sequencing data. I will proceed with the derivation and solution.\n\nThe solution is presented in three parts as requested by the task breakdown. First, the maximum likelihood estimator for the ambient RNA profile $\\alpha$ is derived. Second, the problem of estimating the true cell profile $\\phi$ is framed as a constrained optimization problem. Third, a numerically stable algorithm to solve this optimization problem is derived from the Karush-Kuhn-Tucker (KKT) conditions, leading to the final estimator for $\\phi$.\n\n**Part 1: Maximum Likelihood Estimation of the Ambient Profile $\\alpha$**\n\nWe are given a set of empty droplets $\\mathcal{E}$. For each droplet $e \\in \\mathcal{E}$ and gene $g$, the observed UMI count $X_{eg}$ follows a Poisson distribution, $X_{eg} \\sim \\text{Poisson}(s_e \\cdot \\rho_e \\cdot \\alpha_g)$. The parameters $s_e$ and $\\rho_e$ are nuisance parameters specific to each empty droplet. The parameter of interest is the ambient profile $\\alpha = (\\alpha_g)_{g=1}^G$, which is a probability vector satisfying $\\alpha_g \\ge 0$ and $\\sum_{g=1}^G \\alpha_g = 1$.\n\nThe likelihood function for the observed counts $\\{X_{eg}\\}_{e\\in\\mathcal{E}, g=1..G}$ is the product of individual Poisson probabilities, assuming independence across genes and droplets:\n$$\nL(\\alpha, \\{s_e, \\rho_e\\}) = \\prod_{e \\in \\mathcal{E}} \\prod_{g=1}^G \\frac{(s_e \\rho_e \\alpha_g)^{X_{eg}} e^{-(s_e \\rho_e \\alpha_g)}}{X_{eg}!}\n$$\nThe log-likelihood, $\\mathcal{L} = \\log L$, is given by:\n$$\n\\mathcal{L} = \\sum_{e \\in \\mathcal{E}} \\sum_{g=1}^G \\left( X_{eg} \\log(s_e \\rho_e \\alpha_g) - s_e \\rho_e \\alpha_g - \\log(X_{eg}!) \\right)\n$$\nWe can separate the terms involving $\\alpha$ from other terms:\n$$\n\\mathcal{L} = \\sum_{e,g} X_{eg} \\log(\\alpha_g) + \\sum_{e,g} X_{eg} \\log(s_e \\rho_e) - \\sum_{e,g} s_e \\rho_e \\alpha_g - \\sum_{e,g} \\log(X_{eg}!)\n$$\nLet $C_g = \\sum_{e \\in \\mathcal{E}} X_{eg}$ be the total count for gene $g$ across all empty droplets. The log-likelihood can be rewritten as:\n$$\n\\mathcal{L} = \\sum_{g=1}^G C_g \\log(\\alpha_g) - \\sum_{e \\in \\mathcal{E}} (s_e \\rho_e) \\sum_{g=1}^G \\alpha_g + \\text{const}\n$$\nUsing the constraint $\\sum_g \\alpha_g = 1$, the expression simplifies to:\n$$\n\\mathcal{L} = \\sum_{g=1}^G C_g \\log(\\alpha_g) - \\sum_{e \\in \\mathcal{E}} s_e \\rho_e + \\text{const}\n$$\nTo find the maximum likelihood estimator (MLE) for $\\alpha$, we must maximize $\\mathcal{L}$ with respect to $\\alpha$ subject to the constraints $\\alpha_g \\ge 0$ and $\\sum_g \\alpha_g = 1$. This is equivalent to maximizing the term $\\sum_g C_g \\log(\\alpha_g)$. We use the method of Lagrange multipliers. The Lagrangian is:\n$$\n\\Lambda(\\alpha, \\lambda) = \\sum_{g=1}^G C_g \\log(\\alpha_g) - \\lambda \\left(\\sum_{g=1}^G \\alpha_g - 1\\right)\n$$\nTaking the partial derivative with respect to $\\alpha_g$ and setting it to zero yields:\n$$\n\\frac{\\partial \\Lambda}{\\partial \\alpha_g} = \\frac{C_g}{\\alpha_g} - \\lambda = 0 \\implies \\alpha_g = \\frac{C_g}{\\lambda}\n$$\nTo find the Lagrange multiplier $\\lambda$, we enforce the sum-to-one constraint:\n$$\n\\sum_{g=1}^G \\alpha_g = \\sum_{g=1}^G \\frac{C_g}{\\lambda} = \\frac{1}{\\lambda} \\sum_{g=1}^G C_g = 1 \\implies \\lambda = \\sum_{h=1}^G C_h\n$$\nSubstituting $\\lambda$ back into the expression for $\\alpha_g$, we obtain the MLE:\n$$\n\\widehat{\\alpha}_g = \\frac{C_g}{\\sum_{h=1}^G C_h} = \\frac{\\sum_{e \\in \\mathcal{E}} X_{eg}}{\\sum_{h=1}^G \\sum_{e \\in \\mathcal{E}} X_{eh}}\n$$\nThis demonstrates that the MLE for the ambient profile is the normalized aggregate of counts from all empty droplets, as stated in the problem.\n\n**Part 2: Decontamination of a Cell Profile via Constrained Maximum Likelihood**\n\nFor a single cell-containing droplet, we observe counts $c = (c_1, \\dots, c_G)$ with total count $N = \\sum_g c_g$. Conditional on $N$, the counts follow a multinomial distribution $c \\sim \\text{Multinomial}(N, y)$, where the probability vector $y=(y_g)_{g=1}^G$ is a mixture of the true cell profile $\\phi$ and the ambient profile $\\widehat{\\alpha}$:\n$$\ny_g = (1 - \\rho)\\phi_g + \\rho \\widehat{\\alpha}_g\n$$\nHere, the contamination fraction $\\rho$ and the ambient profile $\\widehat{\\alpha}$ are assumed known. We seek the MLE of $\\phi$. The log-likelihood function for the multinomial distribution is:\n$$\n\\mathcal{L}(y | c) = K + \\sum_{g=1}^G c_g \\log(y_g)\n$$\nwhere $K$ is a constant. Maximizing this log-likelihood is equivalent to minimizing the Kullback-Leibler (KL) divergence from the empirical distribution $\\widehat{y} = (c_g/N)_{g=1}^G$ to the model distribution $y$.\n\nThe constraints on $\\phi$ ($\\phi_g \\ge 0$ and $\\sum_g \\phi_g = 1$) must be translated into constraints on $y$. Rearranging the mixture equation gives:\n$$\n\\phi_g = \\frac{y_g - \\rho \\widehat{\\alpha}_g}{1 - \\rho}\n$$\nThe constraint $\\phi_g \\ge 0$ implies $y_g - \\rho \\widehat{\\alpha}_g \\ge 0$, or $y_g \\ge \\rho \\widehat{\\alpha}_g$. Let us define the lower bound $a_g = \\rho \\widehat{\\alpha}_g$. The constraint becomes $y_g \\ge a_g$.\nThe constraint $\\sum_g \\phi_g = 1$ implies:\n$$\n\\sum_{g=1}^G \\frac{y_g - a_g}{1 - \\rho} = 1 \\implies \\frac{1}{1 - \\rho} \\left( \\sum_g y_g - \\sum_g a_g \\right) = 1\n$$\nSince $\\sum_g a_g = \\sum_g \\rho \\widehat{\\alpha}_g = \\rho \\sum_g \\widehat{\\alpha}_g = \\rho \\cdot 1 = \\rho$, the constraint simplifies to:\n$$\n\\frac{1}{1-\\rho} \\left( \\sum_g y_g - \\rho \\right) = 1 \\implies \\sum_g y_g = 1\n$$\nThus, the estimation of $\\phi$ is equivalent to solving the following constrained optimization problem for $y$:\n$$\n\\begin{aligned}\n\\text{maximize} \\quad & \\sum_{g=1}^G c_g \\log(y_g) \\\\\n\\text{subject to} \\quad & y_g \\ge a_g, \\quad \\forall g \\in \\{1, \\dots, G\\} \\\\\n& \\sum_{g=1}^G y_g = 1\n\\end{aligned}\n$$\nThe optimal solution $y^{\\star}$ can then be used to find the MLE for $\\phi$ via $\\widehat{\\phi}_g = (y^{\\star}_g - a_g)/(1-\\rho)$.\n\n**Part 3: Algorithmic Solution via KKT Conditions**\n\nWe solve the constrained optimization problem using the Karush-Kuhn-Tucker (KKT) conditions. The Lagrangian is:\n$$\nL(y, \\lambda, \\mu) = \\sum_{g=1}^G c_g \\log(y_g) - \\lambda \\left(\\sum_{g=1}^G y_g - 1\\right) + \\sum_{g=1}^G \\mu_g(y_g - a_g)\n$$\nwhere $\\lambda$ is the multiplier for the equality constraint and $\\mu_g \\ge 0$ are the multipliers for the inequality constraints. The KKT conditions are:\n1.  **Stationarity:** $\\frac{\\partial L}{\\partial y_g} = \\frac{c_g}{y_g} - \\lambda + \\mu_g = 0$\n2.  **Primal Feasibility:** $y_g \\ge a_g$ and $\\sum_g y_g = 1$\n3.  **Dual Feasibility:** $\\mu_g \\ge 0$\n4.  **Complementary Slackness:** $\\mu_g(y_g - a_g) = 0$\n\nFrom complementary slackness, for each gene $g$, either $\\mu_g = 0$ or $y_g = a_g$.\n- If the constraint is not active ($y_g > a_g$), then $\\mu_g=0$. Stationarity implies $\\frac{c_g}{y_g} = \\lambda$, so $y_g = c_g/\\lambda$. This occurs when $c_g/\\lambda > a_g$, or $c_g/a_g > \\lambda$.\n- If the constraint is active ($y_g = a_g$), then $\\mu_g \\ge 0$. Stationarity implies $\\mu_g = \\lambda - c_g/a_g \\ge 0$, so $\\lambda \\ge c_g/a_g$.\n\nThis partitions the set of genes into two subsets:\n- $S_{over} = \\{g \\mid y_g > a_g\\}$, for which $y_g = c_g/\\lambda$.\n- $S_{under} = \\{g \\mid y_g = a_g\\}$, for which the solution is fixed at the lower bound.\n\nThe value of $\\lambda$ acts as a threshold on the ratio $c_g/a_g$. We need to find the correct partition and the corresponding $\\lambda$. The sum-to-one constraint on $y$ gives:\n$$\n\\sum_{g=1}^G y_g = \\sum_{g \\in S_{over}} \\frac{c_g}{\\lambda} + \\sum_{g \\in S_{under}} a_g = 1\n$$\nFrom this, we can solve for $\\lambda$:\n$$\n\\lambda = \\frac{\\sum_{g \\in S_{over}} c_g}{1 - \\sum_{g \\in S_{under}} a_g}\n$$\nThis suggests an iterative algorithm:\n1.  Initialize $S_{over} = \\{1, \\dots, G\\}$ and $S_{under} = \\emptyset$.\n2.  Iterate until convergence:\n    a. Calculate $\\lambda$ using the current partition $(S_{over}, S_{under})$.\n    b. Identify the set of genes $V = \\{g \\in S_{over} \\mid c_g/\\lambda < a_g\\}$ for which the proposed solution $c_g/\\lambda$ violates the constraint.\n    c. If $V$ is empty, the partition is correct and the algorithm has converged. Break the loop.\n    d. If $V$ is not empty, update the partition by moving all genes in $V$ from $S_{over}$ to $S_{under}$ and repeat from step 2a.\n\nThis iterative process is guaranteed to converge because genes only move from $S_{over}$ to $S_{under}$, and there is a finite number of genes.\n\nOnce the final partition $(S_{over}^{\\star}, S_{under}^{\\star})$ and the corresponding $\\lambda^{\\star}$ are found, the optimal solution $y^{\\star}$ is:\n$$\ny_g^{\\star} = \\begin{cases} c_g / \\lambda^{\\star} & \\text{if } g \\in S_{over}^{\\star} \\\\ a_g & \\text{if } g \\in S_{under}^{\\star} \\end{cases}\n$$\nFinally, the MLE for the decontaminated profile $\\phi$ is calculated:\n$$\n\\widehat{\\phi}_g = \\frac{y_g^{\\star} - a_g}{1 - \\rho}\n$$\nFor genes in $S_{under}^{\\star}$, $y_g^{\\star} = a_g$, so $\\widehat{\\phi}_g = 0$. For genes in $S_{over}^{\\star}$, $y_g^{\\star} \\ge a_g$, so $\\widehat{\\phi}_g \\ge 0$. The resulting $\\widehat{\\phi}$ vector is guaranteed to have non-negative entries and sums to $1$, as shown in the thought process. This provides a complete, principled, and numerically stable algorithm.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the probabilistic mixture model for ambient RNA contamination\n    for a series of test cases.\n    \"\"\"\n    test_cases = [\n        # Case 1: E, C, r\n        ([100, 30, 20, 10], [50, 5, 3, 2], 0.2),\n        # Case 2: E, C, r\n        ([0, 50, 50, 0], [0, 10, 5, 5], 0.1),\n        # Case 3: E, C, r\n        ([200, 0, 0, 0], [80, 10, 5, 5], 0.6),\n        # Case 4: E, C, r\n        ([90, 10, 0, 0], [5, 3, 1, 1], 0.5),\n        # Case 5: E, C, r\n        ([70, 20, 10, 0], [10, 0, 0, 0], 0.3),\n        # Case 6: E, C, r\n        ([1, 1, 1, 1], [1, 2, 3, 4], 0.0)\n    ]\n\n    all_phi_hat_flat = []\n\n    for case_idx, (E_counts, C_counts, r) in enumerate(test_cases):\n        E = np.array(E_counts, dtype=np.float64)\n        C = np.array(C_counts, dtype=np.float64)\n\n        # Task 1: Estimate ambient profile alpha_hat\n        total_empty_counts = np.sum(E)\n        if total_empty_counts == 0:\n            num_genes = len(E)\n            alpha_hat = np.full(num_genes, 1.0 / num_genes)\n        else:\n            alpha_hat = E / total_empty_counts\n\n        # Handle trivial case of r=0 (no contamination)\n        if r == 0.0:\n            total_cell_counts = np.sum(C)\n            if total_cell_counts == 0:\n                num_genes = len(C)\n                phi_hat = np.full(num_genes, 1.0 / num_genes)\n            else:\n                phi_hat = C / total_cell_counts\n            all_phi_hat_flat.extend(phi_hat)\n            continue\n        \n        # Handle trivial case of a cell with no counts\n        if np.sum(C) == 0:\n            num_genes = len(C)\n            phi_hat = np.zeros(num_genes)\n            all_phi_hat_flat.extend(phi_hat)\n            continue\n\n        # Tasks 2  3: Decontaminate cell profile\n        a = r * alpha_hat\n        \n        # Check if unconstrained MLE is valid\n        y_hat = C / np.sum(C)\n        if np.all(y_hat = a):\n            y_star = y_hat\n        else:\n            # Iterative algorithm to find the optimal y_star\n            num_genes = len(C)\n            indices = np.arange(num_genes)\n            S_over_mask = np.ones(num_genes, dtype=bool)\n            epsilon = 1e-9 # For floating point comparisons\n\n            while True:\n                S_under_mask = ~S_over_mask\n                a_sum_under = np.sum(a[S_under_mask])\n                c_sum_over = np.sum(C[S_over_mask])\n\n                denominator = 1.0 - a_sum_under\n                \n                if c_sum_over == 0 or denominator = 0:\n                    lambda_val = 0\n                else:\n                    lambda_val = c_sum_over / denominator\n                \n                violations = np.zeros(num_genes, dtype=bool)\n                if lambda_val  0:\n                    over_indices = indices[S_over_mask]\n                    violated_indices = over_indices[C[over_indices]  lambda_val * a[over_indices] - epsilon]\n                    if len(violated_indices)  0:\n                        violations[violated_indices] = True\n                \n                if not np.any(violations):\n                    break\n                \n                S_over_mask[violations] = False\n\n            # Calculate final y_star based on converged partition\n            y_star = np.zeros_like(C)\n            S_under_mask = ~S_over_mask\n            y_star[S_under_mask] = a[S_under_mask]\n\n            # Re-calculate final lambda and y_star for S_over\n            a_sum_under = np.sum(a[S_under_mask])\n            c_sum_over = np.sum(C[S_over_mask])\n            denominator = 1.0 - a_sum_under\n            \n            if c_sum_over  0 and denominator  0:\n                lambda_val = c_sum_over / denominator\n                y_star[S_over_mask] = C[S_over_mask] / lambda_val\n            else: # If remaining counts are zero, y_star is also zero\n                y_star[S_over_mask] = 0.0\n        \n        # Map y_star back to phi_hat\n        phi_hat = (y_star - a) / (1.0 - r)\n        \n        # Normalize to correct for any floating point inaccuracies\n        phi_hat[phi_hat  0] = 0.0\n        phi_hat_sum = np.sum(phi_hat)\n        if phi_hat_sum  0:\n            phi_hat /= phi_hat_sum\n        \n        all_phi_hat_flat.extend(phi_hat)\n\n    # Format the final output as a comma-separated list of floats\n    # rounded to six decimal places, enclosed in square brackets.\n    output_str = \",\".join(f\"{x:.6f}\" for x in all_phi_hat_flat)\n    print(f\"[{output_str}]\")\n\nsolve()\n\n```", "id": "2888861"}]}