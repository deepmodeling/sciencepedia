## 引言
在我们的数字世界里，如何才能确定我们的设备正在运行真实、未经篡改的软件？如果用于检查恶意修改的代码本身就能被攻破，我们就会陷入一个怀疑的循环。这个根本性安全问题的解决方案是**信任链**（Chain of Trust），这是一个强大的模型，它从一个不可更改的基础上，构建起一个可验证的完整性保证。这一原则构成了从个人电脑到庞大云网络等一切事物中安全性的无形支柱。

本文将深入探讨这一关键概念的核心。在第一部分**“原则与机制”**中，我们将探索信任链是如何从一个不可变的[硬件信任根](@entry_id:1125916)（RoT）开始建立的。我们将审视[密码学](@entry_id:139166)签名的作用、[安全启动](@entry_id:754616)的逐步过程，以及使用[可信平台模块](@entry_id:756204)（[TPM](@entry_id:170576)）等技术的“可[度量启动](@entry_id:751820)”这一互补理念。随后，在**“应用与跨学科联系”**中，我们将看到这一原则在不同领域的实际应用。我们将从计算机的启动序列和对抗软件供应链攻击，到确保医疗保健中的[数据完整性](@entry_id:167528)和验证科学发现，揭示构建安全系统的统一方法。

## 原则与机制

你如何能信任一台计算机？这不是一个哲学谜题，而是现代技术中最根本的问题之一。当你的设备执行一次计算、显示一条信息或执行一个命令时，你如何知道它正在做你期望的事情？你如何知道软件没有被看不见的对手恶意篡改以进行欺骗、盗窃或导致系统崩溃？如果用于检查篡改的代码本身就可能被篡改，我们就会陷入一个令人晕眩的怀疑循环。要信任任何东西，我们必须从一些我们*无法*怀疑的东西开始。这便是**信任链**背后那个简单、优美而深刻的思想。

### 不容置疑的起点：[信任根](@entry_id:754420)

想象一下建造一座摩天大楼。你不会从装饰顶层公寓开始，而是会先打下深厚坚实的地基，让整个建筑的重量都可以毫无疑问地承载于其上。在计算领域，这个地基被称为**[硬件信任根](@entry_id:1125916)（Hardware Root of Trust, RoT）**。它是系统中一个微小、简单，且最重要的是**不可变**的部分。它的属性不是由软件策略决定的，而是被蚀刻在芯片本身的物理硅片中。

通常，这个 RoT 包含一小块**[只读存储器](@entry_id:175074)（Read-Only Memory, ROM）**。与可以反复写入的[主存储器](@entry_id:751652)（如 SSD 或闪存）不同，ROM 中的代码在出厂时就被固化，永远无法更改 。当你给设备通电时，处理器被硬性连接，以使其*仅*从这个特定的、受保护的 ROM 地址开始执行指令。

这段初始的、受信任的代码做什么呢？它的首要任务是充当一个守门人。一些微控制器具有巧妙的[微架构](@entry_id:751960)特性，比如一个简单的硬件触发器，可以命名为 $\text{fetch\_en}$，即“取指使能”。复位时，这个开关是关闭的，物理上阻止了处理器的指令获取单元从任何不受信任的可写内存中抓取指令。此时，处理器实际上对外部世界是“盲”的，只能执行其自身 ROM 中的可信代码。RoT 代码可以从外部闪存*读取数据*以进行检查，但它不能也不会*执行*这些数据。大门是关闭的，RoT 完全掌控一切。这种由硬件强制执行的“先验证后执行”规则是所有后续信任赖以建立的基石。

### 环环相扣，铸就信任链

ROM 代码本身非常小。它不知道如何运行一个完整的操作系统或复杂的应用程序。其唯一目的是在交出控制权之前，验证启动序列中的下一个软件——我们信任链中的第一个“环节”。但它如何验证呢？

这正是[现代密码学](@entry_id:274529)的精妙之处。ROM 中还包含一个不可变的**公钥**，我们称之为 $pk_{\text{root}}$ 。这个密钥是由设备制造商安全持有的密钥对中的公开部分。下一阶段的软件，比如[引导加载程序](@entry_id:746922)（bootloader），会附带一个**[数字签名](@entry_id:269311)**。这个签名是制造商使用其秘密的私钥 $sk_{\text{root}}$ 创建的一个特殊[密码学](@entry_id:139166)数值。

过程简单而强大：
1.  ROM 代码从闪存中读取引导加载程序的二[进制](@entry_id:634389)文件。
2.  它计算[引导加载程序](@entry_id:746922)的**[密码学哈希](@entry_id:1123262)**。[哈希函数](@entry_id:636237) $H(\cdot)$ 像是数据的唯一数字指纹；[引导加载程序](@entry_id:746922)代码中哪怕只有一个比特位的改变，也会产生一个截然不同的哈希值。
3.  然后，ROM 代码使用其公钥 $pk_{\text{root}}$，对照这个计算出的哈希值来验证引导加载程序的[数字签名](@entry_id:269311)。

[公钥密码学](@entry_id:150737)的魔力确保了只有用相应的私钥 $sk_{\text{root}}$ 创建的签名才会被认为是有效的 。如果攻击者以任何方式修改了引导加载程序，其哈希值就会改变，原始签名将不再匹配。如果攻击者试图为他们的恶意代码创建一个新的签名，他们也无法做到，因为他们没有制造商的私钥。

如果签名有效，ROM 代码就能以密码学的确定性知道引导加载程序是真实且未经篡改的。只有到那时，它才会“打开大门”——或许就是通过设置那个 $\text{fetch\_en}$ 位——并将[执行控制](@entry_id:896024)权转移给引导加载程序。

信任链的第一个环节就此铸成。现在，[引导加载程序](@entry_id:746922)是受信任的。它的代码随后为下一个环节重复完全相同的过程：它包含一个公钥，用以验证主[操作系统内核](@entry_id:752950)。内核一旦被验证并运行，就可以接着验证驱动程序和应用程序。这就是**信任链**：信任从一个不可变的、硬件锚定的环节，[传递性](@entry_id:141148)地传递到下一个可变的软件环节，每个环节都负责验证其后的环节 。这个在每个阶段进行*强制执行*，并在检查失败时拒绝启动系统的过程，被称为**[安全启动](@entry_id:754616)（Secure Boot）**。

### 链条的强度取决于其最薄弱的环节

这条链听起来非常坚固，但一个聪明的对手并不总是试图破坏某个环节，有时他们会试图利用其属性。一个系统的安全性取决于每一个其受损可能违反安全策略的组件的正确性。这组组件被称为**[可信计算基](@entry_id:756201)（Trusted Computing Base, TCB）**。安全设计的目标是使 TCB 尽可能小而简单，但在现实世界中，漏洞可能出现在意想不到的地方。

考虑**回滚攻击**。攻击者获取了一个旧版本但经过合法签名的固件，而该版本已知存在安全漏洞。这个签名是完全有效的！[安全启动过程](@entry_id:754617)会验证它，并愉快地加载这个有漏洞的代码。为了防止这种情况，信任链需要有时间记忆。这通过一个**防回滚计数器**来实现，它通常是芯片上的一块防篡改内存，只能增加，不能减少（一个单调计数器）。每个新固件版本都包含一个版本号 $v_i$。这个版本号是受[数字签名](@entry_id:269311)保护的数据的一部分。引导加载程序只有在新固件的版本 $v_i$ 大于或等于计数器中存储的当前版本 $c$ 时才会接受它。如果版本符合要求且签名验证通过，引导加载程序就会将计数器更新为新版本 $c \leftarrow v_i$，从而永久性地防止回滚到旧版本。

如果信任链延伸得不够远呢？想象一个具有完美[安全启动](@entry_id:754616)的系统。固件验证了引导加载程序，引导加载程序验证了[操作系统内核](@entry_id:752950)。内核启动了，纯净且受信任。但如果内核被配置了一个危险的设置：“允许加载未签名的内核模块”呢？攻击者可能获得短暂的物理访问权限，在硬盘上植入一个恶意的（但未签名的）驱动程序，而内核一旦启动，就会天真地加载并以最高系统权限执行它 。在启动过程中如此精心构建的信任链，因为运行中系统的一个策略配置错误而被打破。信任不是一次性事件，而是一个持续的过程。

即使是验证过程本身也可能成为薄弱环节。解析数字签名的代码可能很复杂。这些解析例程中的一个错误可能会被一个精心制作的无效签名所利用，从而欺骗验证者接受其为有效。总的“攻击面”是链上所有阶段所有此类潜在漏洞的总和。因此，安全不是一种“坚不可摧”的绝对状态，而是将风险降低到一个非常小的概率的可量化过程 。

### 两种信任哲学：保镖与公证人

到目前为止，我们一直关注[安全启动](@entry_id:754616)，这是一种*强制执行*的机制。它就像夜总会的保镖，在门口检查身份证，拒绝任何不在名单上的人进入。其目标是**阻止**未经授权的代码运行。这是一种极其强大的能力，而且正如我们所见，它可以用一个非常小的[信任根](@entry_id:754420)来实现，比如一个 ROM 和一个公钥 。

但是，还有另一种互补的信任哲学：*报告*。这就是**可[度量启动](@entry_id:751820)（Measured Boot）**和**[远程证明](@entry_id:754241)（Remote Attestation）**的世界，也正是在这里，像**[可信平台模块](@entry_id:756204)（Trusted Platform Module, [TPM](@entry_id:170576)）**这样的设备才真正大放异彩。

可[度量启动](@entry_id:751820)不像[安全启动](@entry_id:754616)那样阻止执行，而是像一个一丝不苟的公证人，记录下发生的一切。在启动链中的每个组件被执行之前，都会获取其[密码学哈希](@entry_id:1123262)（其唯一的指纹）。然后，这个哈希值被送入 [TPM](@entry_id:170576) 内部一组称为**平台配置寄存器（Platform Configuration Registers, PCRs）**的特殊寄存器中。这个过程不是简单的写入，而是一个“扩展”（extend）操作，形式上为 $\mathrm{PCR} \leftarrow H(\mathrm{PCR}_{\text{old}} \parallel H(\text{component}))$，它以密码学方式将新的度量值与该 PCR 中所有先前度量的历史记录绑定在一起 。你无法移除一个度量值或改变顺序，否则会产生一个完全不同的最终 PCR 值。

在启动过程结束时，PCRs 中包含一组[密码学](@entry_id:139166)数值，它们构成了整个已加载软件栈的不可伪造的摘要。可[度量启动](@entry_id:751820)本身并不会阻止恶意组件的加载；它只是勤勉地记录下它加载了。

那么这有什么意义呢？意义在于向远程方证明设备的状态。这就是**[远程证明](@entry_id:754241)**。远程服务器可以向设备发起质询，设备随后会要求其 [TPM](@entry_id:170576) 生成一个“报价”（quote）——一个使用唯一的、受保护的证明密钥，对当前的 PCR 值和一个来自服务器的随机质询（nonce）进行的数字签名。通过验证这个报价，远程服务器可以以密码学的确定性了解设备的确切软件状态。这就像公证人出示他签名并盖章的日志簿。如果 PCR 值与已知良好配置的“黄金值”相匹配，服务器就可以信任该设备，并例如为其提供网络凭证或数据加密密钥等机密信息 [@problem_-id:3679582]。如果它们不匹配，服务器就知道设备已被篡改，并可以拒绝服务。

[安全启动](@entry_id:754616)是强制执行安全状态的保镖。可[度量启动](@entry_id:751820)是提供证据供远程方验证该状态的公证人 。

### 一个全新的开始：动态[信任根](@entry_id:754420)

到目前为止，我们的故事总是从同一个地方开始：一次完整的系统重置。这被称为**静态可信度量根（Static Root of Trust for Measurement, SRTM）**，因为信任锚是在开机时静态建立的。但是，如果系统已经运行了一段时间，而你想在一个可证明的“干净”状态下启动一个敏感的应用程序，而不管可能存在错误或已受损的操作系统一直在做什么呢？

这就是**动态可信度量根（Dynamic Root of Trust for Measurement, DRTM）**的动机。它是一条特殊的 CPU 指令，可以在不重置整个机器的情况下，有效地触发信任度量过程的“微型重启” 。当执行这条指令时，硬件会原子性地执行一系列关键操作：它隔离一块内存，将一组特定的 [TPM](@entry_id:170576) PCRs 重置为已知的初始值，并将一小段新的代码（一个“延迟启动”加载器）度量到这些 PCRs 中。然后它开始执行这个加载器。

一瞬间，一条全新的信任链被创建出来，完全独立于机器的整个启动历史。这使得一个正在运行的系统可以按需创建一个可验证的干净环境，这是构建安全[虚拟机](@entry_id:756518)或隔离的可信应用程序的强大工具。它展示了这些基本原则令人难以置信的灵活性——从一个简单、不可改变的锚点，我们可以铸造出不仅坚固，而且动态、能适应现代计算复杂需求的[密码学](@entry_id:139166)信任链。

