## 引言
在任何复杂的计算机系统中，从单个[多核处理器](@entry_id:752266)到庞大的云数据中心，其核心挑战都是如何公平、高效地管理共享资源。一个系统如何能保证每个任务获得其应有的份额，同时又能为紧急工作负载提供最[大性](@entry_id:268856)能？基于信用的调度提供了一种优雅而强大的解决方案，它将抽象的公平性问题转化为具体的记账系统。该模型不依赖于简单的轮流机制，而是为资源访问引入了一种“货币”，解决了在保障所有用户公平份额与允许必要时高性能爆发之间的内在冲突。

本文将深入探讨这一基本概念。首先，在 **原理与机制** 部分，我们将探讨赚取、花费和节省资源信用的核心“银行业务”类比，以理解它如何确保公正性和响应能力。随后，在 **应用与跨学科联系** 部分，我们将看到同样的想法如何远远超出了 CPU 的范畴，为管理从磁盘 I/O 和内存到[硬件安全](@entry_id:169931)的一切事务提供了一个统一的框架。

## 原理与机制

想象一下，你和你的朋友们共享一个速度非常快的厨房。每个人都想做饭，但只有一个炉灶。你如何决定谁可以使用它，以及使用多长时间？如果一个人独占了它，其他人就会饿肚子。如果你们只是简单轮流，那么那个只需要用微波炉热个小零食的朋友，和那个准备三道菜大餐的朋友又该怎么办？你如何确保公平而又不造成浪费？

这是资源调度的经典困境，[操作系统](@entry_id:752937)每时每刻都在 CPU 上面临这个问题。基于信用的调度是为解决此问题而设计的最优雅、最强大的解决方案之一。它与金钱无关；它是一个关于公平的记账系统，一个将复杂的仲裁问题简化为简单算术的优美机制。

### 银行家类比：CPU信用作为货币

从本质上讲，基于信用的调度器将 CPU 时间视为一种货币。每个想要使用 CPU 的进程或[虚拟机](@entry_id:756518)都会被分配一个银行账户。

-   **赚取（补充率）**：系统每时每刻都会向你的账户中存入一股稳定的“CPU信用流”。这就是 **补充率**。这个速率对每个人来说并不相同；它根据你在系统中的 **公平份额** 来设定。如果你有权获得 10% 的 CPU，你的账户将以相当于持续使用 10% CPU 的速率进行补充。

-   **花费（消耗）**：当你在 CPU 上运行时，你会从你的账户中花费信用。如果你使用一个完整的 CPU 核心一秒钟，你可能会花费一个信用。

-   **节省（信用桶）**：如果你现在不需要 CPU 怎么办？也许你在等待用户输入或文件下载。在这段空闲时间内，你不花费信用。相反，你的补充率带来的存入开始在你的账户中积累，就像存钱一样。当然，你不能永远存下去；你能持有的信用数量是有限的，这个限制被称为 **信用上限** 或 **桶大小**。

这个简单的赚取、花费和节省模型是其基础。它将“公平”这一抽象概念转化为一个有形的量：你的信用余额。调度器的规则因此变得异常简单：在任何给定时刻，拥有最多信用的进程获得运行机会。

### 平衡账目：长期公平性与突发性能

这个银行业务系统同时实现了两个看似矛盾的目标：它保证了长期的公平性，同时允许短期的超高性能。让我们通过一个云提供商为不同客户管理虚拟机（VM）的例子来看看这是如何实现的。

首先是 **长期公平性**。在很长一段时间内，你花费的信用不能超过你赚取的信用。这意味着你的平均 CPU 使用率永远不会超过你的补充率。如果一个云提供商想保证客户获得总 CPU 容量 $C$ 中 $s_i$ 的公平份额，他们只需将客户的补充率 $\rho$ 设置为该份额：

$$
\rho = s_i \cdot C
$$

这个单一的方程优雅地强制执行了长期合同。无论客户的使用模式是突发性的还是平稳的，其平均消耗都与这个速率挂钩。

但性能又如何呢？这就是节省信用的魔力所在。如果一个客户的虚拟机一直处于空闲状态（例如，一个没有访客的 Web 服务器），它就会一[直积](@entry_id:143046)累信用，直到达到其上限 $B$。突然，大量的流量涌入。该虚拟机需要一次巨大的、短期的 CPU 算力爆发。由于它有大量的信用余额，调度器允许它以远高于其平均份额的速率运行，以最大可能速率消耗信用。这就是 **突发性能**。

这次爆发能持续多久？假设该[虚拟机](@entry_id:756518)在爆发期间使用了所有可用的 CPU 核心 $C$。它以速率 $C$ 花费信用，但仍以速率 $\rho$ 赚取信用。因此，它的净花费速率是 $(C - \rho)$。这次爆发将持续到其节省的信用 $B$ 耗尽为止。因此，爆发的持续时间 $\tau$ 为：

$$
\tau = \frac{B}{C - \rho}
$$

这为系统设计者提供了一个直接控制突发性的杠杆。如果他们希望允许一个虚拟机以全功率爆发最多（比如说）10秒，他们可以简单地重新[排列](@entry_id:136432)公式并相应地设置信用上限：$B = (C - \rho) \cdot \tau$。通过调整两个参数——用于公平性的补充率 $\rho$ 和用于突发性的桶大小 $B$——设计者可以创建一个复杂且可预测的服务。

### CPU 争夺战：一个公平行动的故事

信用系统的美妙之处在我们观察它解决冲突时最为明显。想象一个虚拟机主机上的经典“吵闹邻居”场景。我们有一个大型、消耗 CPU 的[虚拟机](@entry_id:756518)，称之为“Hercules”，它开始时拥有满满一桶信用。我们还有一个小型的、轻量级的虚拟机，称之为“Swift”，它大部分时间处于空闲状态，但需要在请求到来时立即响应。Swift 开始时信用为零。

在时间零点，Hercules 拥有更多信用，所以它开始运行，消耗整个 CPU。它的信用余额开始下降。与此同时，Swift 处于空闲状态，但正通过其补充率悄悄地积累信用。一场竞赛已经开始。

Swift 有机会运行吗？是的，信用系统保证了这一点。两件事正在并行发生：Hercules 的余额在消耗，而 Swift 的余额在增长。最终，Swift 的信用水平 *必然* 会超过 Hercules。问题是，在什么时候？

有趣的是，这可以通过两种方式发生。如果 Swift 的补充率非常高，它积累信用的速度可能会非常快，以至于在一次直接的“拦截”中超过 Hercules 不断下降的余额。这所需的时间取决于积累和花费的 *相对速率*。

然而，如果 Swift 的补充率较低，则会发生不同的情况。它可能会达到自己的信用上限，然后就带着满桶的信用耐心等待。Hercules 继续消耗自己的信用，直到其余额最终低于 Swift 的上限值。在那一刻，Swift 获得了 CPU。

这里的关键洞见是，存在一个 Swift 的 **临界补充率**。低于这个速率，运行所需的时间由“拦截”竞赛决定。高于这个速率，运行所需的时间变为一个常数，仅取决于 Hercules 消耗其初始优势所需的时间。通过将 Swift 的补充率设置在该临界阈值或之上，系统管理员可以保证一个最小的、最坏情况下的响应时间，从而有效地保护它免受吵闹邻居的影响。信用系统不仅提供了公平性，还提供了一种可调节的响应能力保证。

### 更深层次的统一：信用作为一种记忆和[老化](@entry_id:198459)的形式

那么，“信用”到底是什么？它仅仅是一种巧妙的记账技巧吗？答案更为深刻。信用是一种 **记忆**。它是系统记录哪些进程被不公平地阻止运行的方式。

在[操作系统](@entry_id:752937)的早期，设计者面临着 **饥饿** 问题，即如果总有更高优先级的进程准备就绪，一个低优先级的进程可能永远无法运行。一个经典的解决方案是 **[老化](@entry_id:198459)**：当一个进程在就绪队列中等待时，它的优先级会慢慢增加。等待的时间越长，它的优先级就越高，直到最终成为最高优先级的进程并得以运行。

让我们仔细看看。一个在等待时积累信用的进程，和一个在等待时优先级“[老化](@entry_id:198459)”的进程，看起来像是不同的想法。但它们是吗？

想象一个老化系统，其中一个等待进程 $i$ 的年龄 $a_i(t)$ 以速率 $\alpha_i$ 增加。现在考虑一个信用系统，其中它的信用 $c_i(t)$ 以速率 $r_i$ 增加。在这两种情况下，调度器都会选择具有最高值的进程。事实证明，如果速率成正比：$r_i = \kappa \cdot \alpha_i$（其中 $\kappa$ 是某个常数），那么这两个系统在数学上是等价的。如果这个条件成立，年龄最高的进程将永远是信用最多的那个进程。排名是相同的。调度决策是相同的。

这是一个美妙的统一。看似经济学概念的基于信用的“漏桶”模型，只是[老化](@entry_id:198459)这一基本公正原则的一个具体、可量化的实现。它是一种确保耐心最终得到回报的机制。

### 超越爆发：信用实现真正的比例共享

信用的力量甚至不止于此。它是一个通用的工具，用于追踪与理想公平份额的偏差。

考虑一个任务，它不仅是 CPU 密集型的，而且在需要 CPU 和等待 I/O（如从磁盘读取）之间交替。当它等待磁盘时，它没有使用其应有的 CPU 公平份额。那些未使用的份额应该怎么办？如果它被简单地分配给其他任务，那么我们的 I/O 密集型任务从长远来看，将获得比同等权重的 CPU 密集型任务更少的总 CPU 时间。这将违反长期公平性。

优雅的解决方案再次是信用。当任务因 I/O 而阻塞时，系统会追踪它 *本应* 获得的 CPU 份额，并将其累积为信用。当任务完成 I/O 并准备再次运行时，它会带着大量的信用余额返回。调度器随后可以利用这个余额暂时提升任务的 **有效权重**。这使得它能获得比正常情况下更大的 CPU 时间片，使其能够“追赶”上它错失的时间。当它消耗掉这些额外的服务时，它的信用余额会减少，其有效权重也恢复正常。

这个机制至关重要。它表明信用不仅仅用于管理那些想要爆发的贪婪用户。它们也用于保护行为良好但间歇性的任务，确保自愿为 I/O 放弃 CPU 不会导致它们从长远来看失去其公平份额。

然而，值得注意的是，信用机制的 *实现* 很重要。一个简单的调度器，仅仅在时间片开始时给予信用，然后平等对待所有信用持有者，可能无法提供细粒度的公平性。真正的比例调度器通常更深入地集成信用概念，用它来持续调整任务的优先级或[虚拟运行时间](@entry_id:756584)，确保公平性不仅在时间周期内维持，而且在每时每刻都得以维持。

从一个简单的银行业务类比，我们得出了一个强大而通用的机制。基于信用的调度提供了一种谈论公平性的语言，一套控制性能的杠杆，以及一种记忆，以确保在一个计算机系统复杂、混乱的生命周期中，正义最终得到伸张。

