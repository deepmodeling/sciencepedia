## 应用与跨学科联系

我们花了一些时间窥探[固态硬盘](@entry_id:755039)内部那个奇特而精彩的世界，一个由[浮栅晶体管](@entry_id:171866)奇特的量子力学规则所支配的世界。我们看到写入数据就像注入[电荷](@entry_id:275494)，而擦除数据则需要强行驱逐这些[电荷](@entry_id:275494)，这一行为是如此剧烈，以至于只能在大的内存块上进行，并会逐渐磨损设备。你可能会倾向于认为这些只是实现细节，是一些应由聪明的控制器隐藏起来的怪癖。但那样你就错过了故事中最精彩的部分。

事实是，这些看似底层的物理约束所带来的后果，会一直涟漪般地影响到计算栈的顶层。SSD 不仅仅是一个“更快的硬盘”，它是一种根本上不同的存储介质，其本质迫使我们重新思考从[操作系统](@entry_id:752937)的核心逻辑到我们最基础算法设计方式的一切。现代 SSD 的故事是一个关于协同设计的故事，是硬件与软件之间一场错综复杂而又优雅的舞蹈。

### [操作系统](@entry_id:752937)：连接两个世界的桥梁

第一个直面[闪存](@entry_id:176118)奇异规则的软件层是[操作系统](@entry_id:752937)。几十年来，[操作系统](@entry_id:752937)设计师们为旋转的磁盘完善了他们的技艺，在那种设备上，最慢的操作无疑是机械臂的物理移动。

解决方案是什么？想象一栋高楼里的一部电梯，访问各楼层的请求随机到来。一个愚蠢的电梯会按接收顺序处理请求，疯狂地上下穿梭。而一个聪明的电梯，则会先向上扫描，接上所有上行的人，然后再向下扫描。这就是[操作系统](@entry_id:752937)中“电梯调度器”的精髓。对于硬盘驱动器，它会根据 I/O 请求在磁盘上的物理位置对其进行排序，以最小化读写头的[寻道时间](@entry_id:754621)。这一策略曾是一代人存储性能的基石。

现在，SSD 登场了。它没有移动部件。“[寻道时间](@entry_id:754621)”几乎为零。在 SSD 上使用电梯调度器，就像在一栋拥有传送门的建筑里运行那部聪明的电梯——不仅无用，而且适得其反！现代 NVMe SSD 是一种大规模并行的设备，拥有许多可以同时处理请求的内部通道。其性能的关键在于同时为其提供许多独立的请求。电梯调度器通过将所有请求排序到一个单一的顺序队列中，完全破坏了这种并行性，迫使设备绑着一只手工作。一个技术上曾是绝妙的优化，对下一个技术却成了瓶颈。因此，现代[操作系统](@entry_id:752937)不得不开发全新的多队列子系统，允许应用程序将工作直接提交到硬件队列，从而释放设备的内部并行性。

这种重新思考旧有智慧的主题仍在继续。思考一下[操作系统](@entry_id:752937)的页面缓存。对于硬盘来说，一次读未命中（read miss）迫使从磁盘读取数据是一场灾难——会带来毫秒级的延迟。因此，[操作系统](@entry_id:752937)会试图在其 [RAM](@entry_id:173159) 缓存中保留尽可能多的数据。另一方面，写入通常会被缓冲和合并，但主要目标是避免缓慢的读取。在 SSD 上，这种成本模型被颠覆了。读取速度极快，以微秒计。然而，一次写入的“真实”成本，不仅是编程一个页面的时间，还有它稍后在[垃圾回收](@entry_id:637325)期间可能引起的“写放大”。

一个聪明的[操作系统](@entry_id:752937)可以利用这一点。由于读未命中的代价现在如此之低，[操作系统](@entry_id:752937)可以更积极地从其缓存中驱逐页面。这提供了一个稳定的“脏页”（需要写入磁盘的数据）流。然后，[操作系统](@entry_id:752937)可以扮演一个总指挥的角色：它不是在页面变脏时就随机地将它们写出，而是可以收集一大批，按其[逻辑地址](@entry_id:751440)排序，然后作为一个单一的、大的、顺序的流写出。从 FTL 的角度来看，这是一个完美的工作负载。它可以将这些数据整齐地安放在新的擦除块中，最大限度地减少碎片，并确保当垃圾回收最终发生时，效率会高得多。我们用几次廉价的额外读取，换取了写入长期成本的大幅降低。同样的原则也解释了为什么[操作系统](@entry_id:752937)级的[写缓冲](@entry_id:756779)（它将许多小的、随机的应用程序写入合并为更少、更大、更顺序的写入）对 SSD 如此有益——它将写入流整理成 FTL 可以高效处理的形式，从而极大地减少了写放大。

### 新的契约：主机-设备协作

很长一段时间里，FTL 是一个黑盒，一个不透明的层，它呈现出简单块设备的幻象，同时隐藏了闪存混乱的现实。但正如我们所见，这个幻象并不完美。拥有数据高层知识的[操作系统](@entry_id:752937)，通常能比只看到一连串逻辑块地址流的设备做出更好的决策。这开启了一个协作的新时代，主机和设备通过更丰富的接口进行通信。

最重要的例子是分离“热”数据和“冷”数据。想象一下你在打包裹。一个箱子里放你冬天的衣服，你一年后才需要。另一个箱子里放你的咖啡杯，你每天都用。把咖啡杯存放在储藏室后面、压在冬衣箱子底下是愚蠢的。然而，当 SSD 的 FTL 在不知不觉中将频繁更新的“热”数据（如数据库日志）与很少接触的“冷”数据（如归档照片）混合在同一个擦除块中时，情况正是如此。为了回收被覆盖的热页面的空间，GC 必须费力地将所有冷的、有效的数据先复制出去。

像 NVMe 这样的现代接口允许[操作系统](@entry_id:752937)向设备提供“提示”。通过用不同的流标识符标记写入，[操作系统](@entry_id:752937)可以告诉 FTL：“这些数据是热的，那些数据是冷的。”一个智能的 FTL 随后可以在物理上将这些流隔离到不同的擦除块中。现在，热数据块充满了很快就会失效的数据，使它们成为垃圾回收器完美的、易于清理的目标。写放大，其值约等于 $\frac{1}{1-v}$（其中 $v$ 是牺牲块中有效数据的比例），随着热数据块的 $v$ 趋近于零而急剧下降。这种简单的沟通行为节省了大量的内部工作。

这种更好的主机-设备契约的思想，在解决“双重日志”问题的架构中被推向了其逻辑终点。一些高级[文件系统](@entry_id:749324)，如 F2FS，本身就是“日志结构的”，旨在将所有写入都转化为一个顺序日志——这对于闪存来说是完美的。但是，当你在一个同样具有日志结构 FTL 的 SSD 上运行这样的[文件系统](@entry_id:749324)时，你就会遇到一个“相互倾轧”的问题。文件系统的清理器移动数据以减少其[内部碎片](@entry_id:637905)，从而产生新的写入；然后 FTL 的垃圾回收器可能再次移动相同的数据来清理它的块。这种冗余的工作会导致惩罚性的写放大。解决方案是什么？改变规则。像分区命名空间 (ZNS) 这样的接口将 SSD 的擦除块结构暴露给主机。主机同意只对这些“分区”进行顺序写入，作为回报，设备可以关闭其自身复杂的日志记录和[垃圾回收](@entry_id:637325)功能。重复工作被消除了，控制权被放在了拥有最多信息的地方——主机层面。

这种合作甚至延伸到管理设备的有限寿命。由于每个擦除周期都会造成微小的物理磨损，SSD 真的可能被“写到死”。[操作系统](@entry_id:752937)或数据中心管理员可以实施策略来控制这一点，例如，通过限制每分钟的逻辑写入次数来保证一个目标寿命，比如说五年。这是一种直接的、系统级的性能与可靠性之间的权衡，只有通过理解[闪存](@entry_id:176118)磨损的底层物理原理才可能实现。

### 为闪存重新构想的算法

[闪存](@entry_id:176118)的影响并不仅限于[操作系统](@entry_id:752937)；它一直延伸到基础数据结构和算法的设计中。几十年来，B+ 树几乎是每个数据库系统的主力。它的设计是为磁性磁盘完善的，在磁性磁盘上，更新是“原地”执行的。在闪存上，若不进行昂贵的擦除操作，这是不可能的。

解决方案是拥抱闪存的异地更新特性。我们不是修改一个树节点，而是创建一个新的副本——这种技术称为[写时复制](@entry_id:636568) (CoW)。当一个节点分裂时，我们将两个新节点写入新的页面，然后（延迟地）更新父节点以指向它们。旧节点只是被标记为无效，等待垃圾回收器稍后清理。这使得整个数据结构变成了一个只追加系统，[完美匹配](@entry_id:273916)了[闪存](@entry_id:176118)的优势。像 B-link 树这样的高级变体特别适合，因为它们能容忍暂时的不一致性，允许更新被批量处理并延迟地向上传播，从而进一步最小化写放大。类似的逻辑也适用于[哈希表](@entry_id:266620)。用于标记已删除槽位的“墓碑”是[哈希表](@entry_id:266620)算法的一个逻辑构造；它不能直接转换成存储的 TRIM 命令。正确的、[闪存](@entry_id:176118)感知的方法是定期重建表，只将有效的条目复制到新位置，然后对整个旧空间发出一个单一的、大的 TRIM 命令，FTL 可以以最高效率处理该命令。

然而，有时理论与实践的美妙融合意味着无需重新设计。考虑缓存无关合并[排序算法](@entry_id:261019)，这是一种理论上优雅的算法，它递归地对数据进行排序，而无需为任何特定的缓存或块大小进行调整。其基本操作涉及合并已排序的序列，这会产生长的、顺序的输出流。正如我们所见，这对于日志结构的 FTL 来说是理想的工作负载！该算法在抽象[内存模型](@entry_id:751871)中追求理论上的最优性，其结果是自然地产生了一种几乎[完美适应](@entry_id:263579) SSD 物理现实的写入模式。任何试图通过使其感知擦除块大小来“优化”它的尝试，都将是徒劳的，只会破坏其优雅性。

### 与熵共舞：安全与信息论

也许最令人惊讶的联系是与密码学和信息论领域的联系。现代应用程序要求加密以保护静态数据。一个好的加密算法将结构化的、可预测的明文转换为在计算上与随机噪声无法区分的密文。换句话说，它最大化了熵。

但在这里我们遇到了直接的冲突！SSD 的 FTL 配备了其自己的数据缩减功能，如压缩和去重，这些功能通过寻找和消除冗余来工作——也就是说，通过利用*低*熵。当 FTL 收到一串加密数据时，这些功能就完全失效了。它无法压缩看起来随机的密文，而且由于现代密码对每个块使用唯一的初始化向量，即使是相同的明文块也会产生唯一的密文块，从而完全挫败了去重功能。

这个僵局的解决方案是什么？不是削弱加密，例如使用会泄露底层数据信息的确定性方案。解决方案在于将整个系统视为一个整体。去除冗余的正确位置是在它被加密隐藏*之前*。一个智能的系统会首先在[操作系统](@entry_id:752937)层面压缩数据，然后才对更小的、压缩后的结果进行加密。FTL 仍然看到一个不可压缩、不可去重的流，但写入设备的总数据量已经被主机减少了。这种优雅的分层方法同时实现了安全性和效率，减少了物理写入并延长了驱动器的寿命。

从 I/O 请求的调度到 B+ 树的设计，再到加密文件系统的实现，[固态硬盘](@entry_id:755039)的内部机制几乎在计算机科学的每个角落都留下了自己的印记。解锁其性能的旅程是关于该领域统一性的一堂精彩课程，它表明，真正的理解并非来自孤立地优化某一层，而是来自欣赏所有层面之间美丽而错综复杂的相互作用。