{"hands_on_practices": [{"introduction": "要掌握一个新工具，第一步是熟悉其基本构造。本练习将引导你直接应用凯泽窗的定义公式，通过一个具体的数值计算，让你亲手实践并理解公式中每个参数（如窗长 $N$ 和形状参数 $\\beta$）的作用。这有助于将抽象的数学表达式转化为切实的计算过程。[@problem_id:1732504]", "problem": "在数字信号处理 (DSP) 中，窗函数对于设计实用的有限脉冲响应 (FIR) 滤波器至关重要。\n\n凯泽窗是一种通用的、近最优的窗，由形状参数 $\\beta$ 定义。\n\n对于索引 $0 \\le n \\le N-1$，一个 $N$ 点凯泽窗 $w[n]$ 的公式由下式给出：\n$$ w[n] = \\frac{I_0\\left(\\beta \\sqrt{1 - \\left(\\frac{2n - (N-1)}{N-1}\\right)^2}\\right)}{I_0(\\beta)} $$\n其中 $I_0(x)$ 是第一类零阶修正贝塞尔函数。\n\n一位工程师正在使用一个 13 点的凯泽窗 ($N=13$) 设计一个滤波器，其形状参数为 $\\beta = 4.0$。为了进行必要的计算，提供了以下零阶修正贝塞尔函数的值：$I_0(4.0) \\approx 11.3019$ 和 $I_0(2\\sqrt{3}) \\approx 7.0362$。\n\n计算在样本索引 $n=3$ 处窗函数的值。将最终答案四舍五入至四位有效数字。", "solution": "我们已知凯泽窗的定义\n$$\nw[n] = \\frac{I_{0}\\!\\left(\\beta \\sqrt{1 - \\left(\\frac{2n - (N-1)}{N-1}\\right)^{2}}\\right)}{I_{0}(\\beta)},\n$$\n其中 $N=13$，$\\beta=4.0$，我们需要求解 $w[3]$。\n\n首先计算归一化索引项：\n$$\nN-1=12,\\quad 2n-(N-1)=2\\cdot 3-12=-6,\\quad \\frac{2n-(N-1)}{N-1}=\\frac{-6}{12}=-\\frac{1}{2}.\n$$\n然后\n$$\n\\left(\\frac{2n-(N-1)}{N-1}\\right)^{2}=\\left(-\\frac{1}{2}\\right)^{2}=\\frac{1}{4},\\quad 1-\\left(\\frac{2n-(N-1)}{N-1}\\right)^{2}=1-\\frac{1}{4}=\\frac{3}{4},\n$$\n所以\n$$\n\\sqrt{1-\\left(\\frac{2n-(N-1)}{N-1}\\right)^{2}}=\\sqrt{\\frac{3}{4}}=\\frac{\\sqrt{3}}{2}.\n$$\n乘以 $\\beta$ 得到\n$$\n\\beta \\sqrt{1-\\left(\\frac{2n-(N-1)}{N-1}\\right)^{2}}=4\\cdot \\frac{\\sqrt{3}}{2}=2\\sqrt{3}.\n$$\n因此，\n$$\nw[3]=\\frac{I_{0}(2\\sqrt{3})}{I_{0}(4)}.\n$$\n使用给定的值 $I_{0}(4)\\approx 11.3019$ 和 $I_{0}(2\\sqrt{3})\\approx 7.0362$，我们得到\n$$\nw[3]\\approx \\frac{7.0362}{11.3019}\\approx 0.622568\\ldots\n$$\n四舍五入到四位有效数字，得到\n$$\nw[3]\\approx 0.6226.\n$$", "answer": "$$\\boxed{0.6226}$$", "id": "1732504"}, {"introduction": "在学会了如何计算窗函数的值之后，一个自然而然的问题是：我们为什么要使用凯泽窗，特别是那个神秘的参数 $\\beta$ 有什么用？这个练习将带你从计算转向概念理解，探讨凯泽窗的核心设计思想——主瓣宽度与旁瓣抑制之间的权衡。理解这种权衡是掌握滤波器设计的关键一步。[@problem_id:1732452]", "problem": "一位音频工程师正在使用数字信号处理（DSP）系统来分析一段复杂的音频录音。目标是识别同时播放的两个非常相似的音调的精确频率。为此，工程师在进行傅里叶变换之前，对音频信号的短分段应用了窗函数。区分两个间隔很近的频率的能力被称为频率分辨率。\n\n该系统使用凯泽窗（Kaiser window），对于长度 $N$ 和非负形状参数 $\\beta$，其定义为：\n$$\nw[n] = \\frac{I_0\\left(\\beta \\sqrt{1 - \\left(\\frac{2n}{N-1}\\right)^2}\\right)}{I_0(\\beta)}, \\quad \\text{for } -\\frac{N-1}{2} \\le n \\le \\frac{N-1}{2}\n$$\n其中 $I_0(x)$ 是第一类修正的零阶贝塞尔函数。\n\n工程师有一个固定的内存缓冲区，因此窗长 $N$ 在所有分析中都是恒定的。但是，他们可以为形状参数选择两种预设之一：\n- **窗 A：** $\\beta_A = 3.5$\n- **窗 B：** $\\beta_B = 7.5$\n\n为了获得尽可能高的频率分辨率，从而最好地区分这两个相似的音调，工程师应该选择哪个窗函数？其正确理由是什么？\n\nA. 窗 A，因为较小的 $\\beta$ 值会导致更窄的主瓣。\nB. 窗 B，因为较大的 $\\beta$ 值会导致更窄的主瓣。\nC. 窗 A，因为较小的 $\\beta$ 值会导致更大的旁瓣衰减。\nD. 窗 B，因为它提供了更好的频谱泄漏抑制，这总是理想的。\nE. 选择无关紧要，因为只有窗长 $N$ 影响频率分辨率。", "solution": "将频率分辨率定义为在加窗和傅里叶分析后，区分角频率为 $\\omega_{1}$ 和 $\\omega_{2}$ 的两个正弦波的能力。如果信号 $x[n]$ 被窗函数 $w[n]$ 加窗，则加窗后信号的频谱是原始频谱与窗函数变换的卷积：\n$$\nX_{w}(\\omega) = X(\\omega) * W(\\omega).\n$$\n对于两个音调，$X(\\omega)$ 是在 $\\omega_{1}$ 和 $\\omega_{2}$ 处的脉冲之和，因此 $X_{w}(\\omega)$ 是以 $\\omega_{1}$ 和 $\\omega_{2}$ 为中心的 $W(\\omega)$ 的移位副本之和。当频率间隔\n$$\n\\Delta \\omega \\equiv |\\omega_{2}-\\omega_{1}|\n$$\n超过 $W(\\omega)$ 的特征主瓣宽度（例如，第一零点到第一零点的宽度或半功率宽度）时，这两个音调是可分辨的。因此，对于固定的窗长 $N$，更高的频率分辨率需要更窄的 $W(\\omega)$ 主瓣：\n$$\n\\text{maximize resolution} \\;\\Longleftrightarrow\\; \\text{minimize } \\Delta \\omega_{\\text{main}}(\\beta,N).\n$$\n\n对于固定长度 $N$ 和形状参数 $\\beta \\ge 0$ 的凯泽窗，存在一个众所周知的单调权衡：\n- 随着 $\\beta$ 增加，旁瓣衰减增加（旁瓣电平降低）。\n- 随着 $\\beta$ 增加，主瓣宽度增加。等效地，\n$$\n\\frac{\\partial}{\\partial \\beta}\\,\\Delta \\omega_{\\text{main}}(\\beta,N)  0,\\qquad \\frac{\\partial}{\\partial \\beta}\\,A_{\\text{sl}}(\\beta)  0,\n$$\n其中 $A_{\\text{sl}}$ 表示旁瓣衰减。\n\n因此，在 $N$ 固定的情况下，要最小化 $\\Delta \\omega_{\\text{main}}(\\beta,N)$，需要选择较小的 $\\beta$。在两个预设值 $\\beta_{A}=3.5$ 和 $\\beta_{B}=7.5$ 之间，我们有\n$$\n\\Delta \\omega_{\\text{main}}(\\beta_{A},N)  \\Delta \\omega_{\\text{main}}(\\beta_{B},N),\n$$\n因此窗 A 产生更窄的主瓣，从而具有更高的频率分辨率。\n\n评估选项：\n- A 是正确的：较小的 $\\beta$ 产生更窄的主瓣，提高分辨率。\n- B 是错误的：较大的 $\\beta$ 会加宽主瓣。\n- C 是错误的：较小的 $\\beta$ 不会增加旁瓣衰减，而是会减少旁瓣衰减。\n- D 具有误导性：虽然较大的 $\\beta$ 会抑制旁瓣（减少泄漏），但它会加宽主瓣，并可能降低区分相近音调的能力；对于所述的分辨率目标，“总是理想的”并不正确。\n- E 是错误的：尽管 $N$ 强烈影响分辨率，但窗的形状（通过 $\\beta$）会改变主瓣宽度，从而改变固定 $N$ 时的有效分辨率。\n\n因此，基于关于主瓣宽度和频率分辨率的既定理由，正确的选择是窗 A。", "answer": "$$\\boxed{A}$$", "id": "1732452"}, {"introduction": "现在我们已经理解了凯泽窗的公式和其核心参数的意义，是时候将它应用到经典的信号处理问题——FIR滤波器设计中了。这个高级练习不仅要求理论分析，还需要动手编程，让你在一个实际场景中量化地观察和验证凯泽窗如何有效地抑制因信号截断而产生的吉布斯现象。这将理论知识与工程实践紧密地联系起来。[@problem_id:2894012]", "problem": "考虑一个理想离散时间低通滤波器，其截止角频率为 $\\,\\omega_c\\,$ (单位为弧度/采样点)，其冲激响应是著名的理想响应 $\\,h_{\\text{ideal}}[n]\\,$，由砖墙谱的离散时间傅里叶反变换得到。通过将 $\\,h_{\\text{ideal}}[n]\\,$ 在其中点截断至对称长度 $\\,N\\,$，并乘以一个锥削窗函数 $\\,w[n]\\,$，可以构造一个有限冲激响应 (FIR) 近似。该操作对应于频域中理想响应与 $\\,w[n]\\,$ 的离散时间傅里叶变换的卷积，这会在频带边缘以及当滤波器应用于单位阶跃输入时，在阶跃响应中引入常被称为吉布斯振荡的涟漪。\n\n从时域乘法与频域卷积之间的基本卷积-调制对偶性出发，并结合理想低通滤波器和因果 FIR 滤波器阶跃响应的定义，完成以下任务：\n\n1) 推导为什么使用矩形窗截断会在阶跃响应中产生振荡过冲。然后，论述用凯泽窗（基于零阶第一类修正贝塞尔函数）替代矩形窗如何改变频谱泄漏模式，并定性解释为什么随着凯泽窗参数 $\\,\\beta\\,$ 的增加，过冲幅度会减小。\n\n2) 令 $\\,h[n]\\,$ 表示通过将对称的加窗序列居中并平移，使其索引从 $\\,n=0\\,$ 运行到 $\\,n=N-1\\,$ 而得到的因果 FIR 滤波器。归一化系数，使直流 (DC) 增益为1，即强制 $\\,\\sum_{n=0}^{N-1} h[n] = 1\\,$。对于单位阶跃输入 $\\,u[n]\\,$，阶跃响应为 $\\,s[n] = \\sum_{k=0}^{\\min(n,N-1)} h[k]\\,$。将吉布斯过冲幅度定义为\n$$\n\\Delta \\triangleq \\max_{0 \\le n \\le N-1} s[n] \\;-\\; 1,\n$$\n并将相对于矩形截断的减小因子定义为\n$$\n\\rho(\\beta) \\triangleq \\frac{\\Delta_{\\text{Kaiser}}(\\beta)}{\\Delta_{\\text{rect}}},\n$$\n其中 $\\,\\Delta_{\\text{rect}}\\,$ 是使用矩形窗（对应于 $\\,\\beta=0\\,$）时的过冲幅度，而 $\\,\\Delta_{\\text{Kaiser}}(\\beta)\\,$ 是使用参数为 $\\,\\beta\\,$ 的凯泽窗时的过冲幅度。\n\n3) 实现一个算法，对于给定的 $\\,N\\,$、$\\,\\omega_c\\,$ 和 $\\,\\beta\\,$，该算法构建长度为 $\\,N\\,$ 的加窗低通滤波器，将其归一化至单位直流增益，从阶跃响应中计算 $\\,\\Delta\\,$，然后通过与具有相同 $\\,N\\,$ 和 $\\,\\omega_c\\,$ 的矩形窗情况进行比较来报告 $\\,\\rho(\\beta)\\,$。凯泽窗应使用其标准定义；所有角量均使用弧度/采样点为单位。最终输出必须是实数。\n\n你的程序必须为以下测试套件评估 $\\,\\rho(\\beta)\\,$，该套件旨在探测不同的工作状态：\n\n- 情况 $\\,1\\,$ (基线相等): $\\,N=51\\,$, $\\,\\omega_c = 0.4\\pi\\,$, $\\,\\beta=0\\,$.\n- 情况 $\\,2\\,$ (中等锥削): $\\,N=51\\,$, $\\,\\omega_c = 0.4\\pi\\,$, $\\,\\beta=5\\,$.\n- 情况 $\\,3\\,$ (典型强锥削): $\\,N=51\\,$, $\\,\\omega_c = 0.4\\pi\\,$, $\\,\\beta=8.6\\,$.\n- 情况 $\\,4\\,$ (非常强的锥削): $\\,N=51\\,$, $\\,\\omega_c = 0.4\\pi\\,$, $\\,\\beta=12\\,$.\n- 情况 $\\,5\\,$ (短滤波器，强锥削): $\\,N=11\\,$, $\\,\\omega_c = 0.4\\pi\\,$, $\\,\\beta=8.6\\,$.\n- 情况 $\\,6\\,$ (非常强锥削极限): $\\,N=51\\,$, $\\,\\omega_c = 0.4\\pi\\,$, $\\,\\beta=20\\,$.\n- 情况 $\\,7\\,$ (近奈奎斯特截止频率压力测试): $\\,N=51\\,$, $\\,\\omega_c = 0.9\\pi\\,$, $\\,\\beta=8.6\\,$.\n\n所有角度单位均为弧度/采样点。除此角度约定外，不涉及任何物理单位。每个报告的 $\\,\\rho(\\beta)\\,$ 必须是一个实值浮点数。你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如 $\\,\\texttt{[r_1,r_2,\\dots,r_7]}\\,$），每个条目按顺序对应于上述情况。每个 $\\,\\rho(\\beta)\\,$ 必须四舍五入到小数点后恰好六位。如果在任何情况下，基线矩形窗过冲 $\\,\\Delta_{\\text{rect}}\\,$ 数值上为零，则当 $\\,\\Delta_{\\text{Kaiser}}(\\beta)=0\\,$ 时将 $\\,\\rho(\\beta)\\,$ 定义为 $\\,1\\,$，否则定义为一个大的哨兵值 $\\,10^{6}\\,$。对于所提供的测试套件，在正确实现的情况下，此后备定义不应被触发。", "solution": "所提出的问题是数字信号处理领域一个适定的标准练习，具体涉及通过窗函数法设计有限冲激响应 (FIR) 滤波器。该问题具有科学依据，无内在矛盾，且所有术语都有正式定义。因此，我们将进行严谨的分析和求解。\n\n任务是首先为加窗 FIR 滤波器阶跃响应中的吉布斯现象提供理论依据，然后解释凯泽窗的缓解效应。随后，将实现一个数值算法来量化这种缓解效果。\n\n让我们从第一性原理开始。离散时间信号 $x[n]$ 与其离散时间傅里叶变换 (DTFT) $X(e^{j\\omega})$ 之间的关系由以下变换对给出：\n$$\nX(e^{j\\omega}) = \\sum_{n=-\\infty}^{\\infty} x[n]e^{-j\\omega n}\n$$\n$$\nx[n] = \\frac{1}{2\\pi} \\int_{-\\pi}^{\\pi} X(e^{j\\omega})e^{j\\omega n} d\\omega\n$$\n一个理想低通滤波器由一个矩形或“砖墙”频率响应 $H_{\\text{ideal}}(e^{j\\omega})$ 定义，其截止频率为 $\\omega_c$：\n$$\nH_{\\text{ideal}}(e^{j\\omega}) = \\begin{cases} 1,  |\\omega| \\le \\omega_c \\\\ 0,  \\omega_c  |\\omega| \\le \\pi \\end{cases}\n$$\n其对应的冲激响应 $h_{\\text{ideal}}[n]$ 通过应用离散时间傅里叶反变换得到：\n$$\nh_{\\text{ideal}}[n] = \\frac{1}{2\\pi} \\int_{-\\omega_c}^{\\omega_c} 1 \\cdot e^{j\\omega n} d\\omega = \\frac{1}{2\\pi} \\left[ \\frac{e^{j\\omega n}}{jn} \\right]_{-\\omega_c}^{\\omega_c} = \\frac{e^{j\\omega_c n} - e^{-j\\omega_c n}}{2\\pi jn} = \\frac{\\sin(\\omega_c n)}{\\pi n}\n$$\n对于 $n=0$ 处的奇异点，我们使用洛必达法则求极限，得到 $h_{\\text{ideal}}[0] = \\frac{\\omega_c}{\\pi}$。该冲激响应是无限长且非因果的，使其在实践中无法实现。\n\n为了创建一个实际可实现的 FIR 滤波器，我们将 $h_{\\text{ideal}}[n]$ 截断至有限长度 $N$。这是通过将其与一个有限长度的窗函数 $w[n]$ 相乘来实现的。对于长度为 $N$ 的零相位滤波器（$N$ 通常为奇数），窗函数 $w[n]$ 在 $|n| \\le (N-1)/2$ 范围内非零。得到的 FIR 冲激响应为：\n$$\nh_{\\text{FIR}}[n] = h_{\\text{ideal}}[n] \\cdot w[n]\n$$\n傅里叶变换的基本对偶性指出，时域中的乘法对应于频域中的周期卷积。因此，FIR 滤波器的频率响应为：\n$$\nH_{\\text{FIR}}(e^{j\\omega}) = \\frac{1}{2\\pi} H_{\\text{ideal}}(e^{j\\omega}) * W(e^{j\\omega}) = \\frac{1}{2\\pi} \\int_{-\\pi}^{\\pi} H_{\\text{ideal}}(e^{j\\theta}) W(e^{j(\\omega-\\theta)}) d\\theta\n$$\n其中 $W(e^{j\\omega})$ 是窗函数 $w[n]$ 的离散时间傅里叶变换。\n\n现在，我们分析使用矩形窗 $w_{\\text{rect}}[n]$ 进行截断的情况，该窗定义为在 $|n| \\le (N-1)/2$ 时为 $1$，否则为 $0$。其离散时间傅里叶变换是一个几何级数求和：\n$$\nW_{\\text{rect}}(e^{j\\omega}) = \\sum_{n=-(N-1)/2}^{(N-1)/2} e^{-j\\omega n} = \\frac{\\sin(\\omega N/2)}{\\sin(\\omega/2)}\n$$\n这个函数被称为狄利克雷核，由一个中心在 $\\omega=0$、宽度为 $4\\pi/N$ 的主瓣和一系列衰减的旁瓣组成。理想砖墙响应 $H_{\\text{ideal}}(e^{j\\omega})$ 与 $W_{\\text{rect}}(e^{j\\omega})$ 的卷积会使 $\\omega_c$ 处的急剧不连续性变得模糊。$W_{\\text{rect}}(e^{j\\omega})$ 的旁瓣会“印”在理想响应上，在 $H_{\\text{FIR}}(e^{j\\omega})$ 的通带和阻带中产生涟漪。这种现象被称为吉布斯振荡。\n\n滤波器 $h[n]$ 的阶跃响应 $s[n]$ 是其对单位阶跃输入 $u[n]$ 的响应。它是冲激响应的累积和：$s[n] = \\sum_{k=0}^{n} h[k]$。在频域中，阶跃响应的频谱近似为滤波器频率响应的积分。$H_{\\text{FIR}}(e^{j\\omega})$ 在截止频率边缘附近的大涟漪会导致阶跃响应 $s[n]$ 出现过冲。振荡函数的积分会产生一个超过最终稳态值的峰值。对于矩形窗，无论滤波器长度 $N$ 如何，第一个旁瓣的高度约为主瓣峰值的 $21.7\\%$（或 $-13.2$ dB）。这个固定的主涟漪相对高度是阶跃响应中约 $9\\%$ 的持续过冲的根本原因，该过冲不会随着 $N$ 的增加而减小。\n\n为了缓解这种行为，我们用一个具有更好频谱特性的窗来替换矩形窗。凯泽窗是一个绝佳的选择，其定义为：\n$$\nw_K[n; \\beta] = \\frac{I_0\\left(\\beta\\sqrt{1 - \\left(\\frac{2n}{N-1}\\right)^2}\\right)}{I_0(\\beta)}, \\quad |n| \\le \\frac{N-1}{2}\n$$\n这里，$I_0(x)$ 是零阶第一类修正贝塞尔函数，$\\beta$ 是一个形状参数。\n\n参数 $\\beta$ 控制着一个权衡。当 $\\beta=0$ 时，凯泽窗变为矩形窗。随着 $\\beta$ 的增加，窗函数变得更加锥形，将其能量集中在中心，并在其两端平滑地趋近于零。在频域中，增加 $\\beta$ 对 $W_K(e^{j\\omega})$ 有两个主要影响：\n1. 主瓣的宽度增加。这对应于所得滤波器中更宽的过渡带。\n2. 旁瓣中的能量急剧减少。即，峰值旁瓣电平被显著衰减。\n\n阶跃响应中的过冲是频域涟漪幅度的直接结果。通过选择 $\\beta > 0$ 的凯泽窗，我们选择了一个其离散时间傅里叶变换与矩形窗相比具有低得多的旁瓣的窗函数。旁瓣幅度的减小直接转化为卷积后滤波器响应 $H_{\\text{FIR}}(e^{j\\omega})$ 中更小的涟漪。更小的通带涟漪，特别是靠近截止频率的那个，意味着形成阶跃响应的积分累积了更少的额外能量，从而导致更小的过冲 $\\Delta$。因此，随着 $\\beta$ 的增加，窗函数的旁瓣衰减得到改善，导致阶跃响应过冲的单调减少，其代价是滤波器过渡带变宽。这就是使用凯泽窗进行过冲控制的基本原理。\n\n将要实现的算法将数值验证这一定性论证。它将构建滤波器，对其进行归一化以确保阶跃响应收敛到 $1$，将阶跃响应计算为累积和，并找到最大过冲 $\\Delta$。比率 $\\rho(\\beta)$ 将量化参数为 $\\beta$ 的凯泽窗相对于基线矩形窗情况的有效性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import i0\n\ndef calculate_overshoot(N, wc, beta):\n    \"\"\"\n    Calculates the Gibbs overshoot amplitude for a windowed-sinc FIR filter.\n\n    Args:\n        N (int): The length of the FIR filter. Must be odd.\n        wc (float): The cutoff angular frequency in radians per sample.\n        beta (float): The beta parameter for the Kaiser window. beta=0 corresponds\n                      to a rectangular window.\n\n    Returns:\n        float: The overshoot amplitude Delta.\n    \"\"\"\n    if N % 2 == 0:\n        raise ValueError(\"Filter length N must be odd for this symmetric design.\")\n\n    # 1. Create a symmetric time index array around n=0\n    # For N=51, this is -25, -24, ..., 0, ..., 24, 25\n    n = np.arange(-(N - 1) / 2, (N - 1) / 2 + 1)\n\n    # 2. Calculate the ideal low-pass filter impulse response (sinc function)\n    # The ideal response is h_ideal[n] = sin(wc*n) / (pi*n).\n    # We use np.sinc which is defined as sin(pi*x)/(pi*x), so we must scale the argument.\n    # h_ideal[n] = (wc/pi) * sinc(n*wc/pi)\n    h_ideal = (wc / np.pi) * np.sinc(n * wc / np.pi)\n\n    # 3. Generate the window function\n    if beta == 0:\n        # Rectangular window\n        window = np.ones(N)\n    else:\n        # Kaiser window, using the definition from the problem statement\n        # The argument 2*n/(N-1) maps the indices to the a_n range [-1, 1]\n        arg = beta * np.sqrt(1 - (2 * n / (N - 1))**2)\n        window = i0(arg) / i0(beta)\n\n    # 4. Apply the window to the ideal impulse response\n    # This creates the non-causal, zero-phase FIR filter coefficients\n    h_windowed = h_ideal * window\n\n    # 5. Normalize the filter coefficients for unit DC gain\n    # The sum of coefficients is the frequency response at omega=0 (DC)\n    # This ensures the step response settles to 1.\n    dc_gain = np.sum(h_windowed)\n    if np.isclose(dc_gain, 0):\n        # Avoid division by zero, though unlikely for a low-pass filter\n        h_normalized = h_windowed\n    else:\n        h_normalized = h_windowed / dc_gain\n\n    # 6. Compute the step response for the causal filter\n    # The coefficients are the same, just indexed from 0 to N-1.\n    # The step response is the cumulative sum of the impulse response.\n    step_response = np.cumsum(h_normalized)\n\n    # 7. Calculate the overshoot amplitude (Delta)\n    # Delta is defined as the maximum of the step response minus its final value (which is 1)\n    overshoot = np.max(step_response) - 1.0\n    \n    return overshoot\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each tuple is (N, omega_c, beta)\n    test_cases = [\n        (51, 0.4 * np.pi, 0.0),    # Case 1: Baseline (rectangular)\n        (51, 0.4 * np.pi, 5.0),    # Case 2: Moderate taper\n        (51, 0.4 * np.pi, 8.6),    # Case 3: Typical strong taper\n        (51, 0.4 * np.pi, 12.0),   # Case 4: Very strong taper\n        (11, 0.4 * np.pi, 8.6),    # Case 5: Short filter, strong taper\n        (51, 0.4 * np.pi, 20.0),   # Case 6: Very strong taper limit\n        (51, 0.9 * np.pi, 8.6),    # Case 7: Near-Nyquist cutoff stress test\n    ]\n\n    results = []\n    for N, wc, beta in test_cases:\n        # Calculate the overshoot for the rectangular window case (beta=0),\n        # which serves as the reference for the given N and wc.\n        delta_rect = calculate_overshoot(N, wc, 0.0)\n\n        # Calculate the overshoot for the specified Kaiser window case.\n        delta_kaiser = calculate_overshoot(N, wc, beta)\n\n        # Calculate the reduction factor rho(beta)\n        # Handle the fallback case where the reference overshoot is zero.\n        if np.isclose(delta_rect, 0.0):\n            if np.isclose(delta_kaiser, 0.0):\n                rho = 1.0\n            else:\n                rho = 1.0e6  # Sentinel value as per problem spec\n        else:\n            rho = delta_kaiser / delta_rect\n\n        # Round the result to exactly six digits after the decimal point.\n        results.append(round(rho, 6))\n\n    # Final print statement in the exact required format.\n    # map(str, ...) will convert each float to its string representation.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "2894012"}]}