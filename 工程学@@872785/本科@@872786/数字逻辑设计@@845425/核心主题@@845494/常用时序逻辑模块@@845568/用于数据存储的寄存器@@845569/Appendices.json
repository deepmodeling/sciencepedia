{"hands_on_practices": [{"introduction": "在复杂的数字系统中，寄存器常常需要从多个来源接收数据，例如算术逻辑单元（ALU）的输出或内存。本练习将指导您为这一常见场景设计核心的控制逻辑。您将学习如何使用一个选择信号，在两个不同的数据总线之间进行选择，这是构建灵活数据通路的一项基本技能。[@problem_id:1958039]", "problem": "在处理器寄存器文件的设计中，一个普遍的需求是创建一个可以从多个数据源之一加载数据的寄存器。考虑这样一个寄存器的一个单位元切片，它由一个D型触发器实现。该触发器在时钟信号 `CLK` 的上升沿捕获其数据输入 `D` 的值，并将其保持在输出 `Q` 上。\n\n这个特定的寄存器级必须能够从两个1位输入总线 `A` 或 `B` 中的一个加载数据。一个选择线 `S` 控制使用哪个数据源。其行为规定如下：\n- 如果选择线 `S` 为逻辑0，触发器应在下一个时钟上升沿加载来自输入 `A` 的值。\n- 如果选择线 `S` 为逻辑1，触发器应在下一个时钟上升沿加载来自输入 `B` 的值。\n\n使用标准的布尔代数表示法，其中加法（`+`）表示或运算，乘法（通过并列表示）表示与运算，撇号（例如 `S'`）表示非运算，下列哪个表达式正确定义了D型触发器的数据输入 `D` 的逻辑？\n\nA. $D = SA + S'B$\n\nB. $D = S'A + SB$\n\nC. $D = A \\oplus B$\n\nD. $D = (S+A)(S+B)$\n\nE. $D = AB + S$", "solution": "D型触发器在 $CLK$ 的上升沿捕获其数据输入 $D$ 上的值。该寄存器必须根据选择线 $S$ 从 $A$ 或 $B$ 中选择其 $D$ 输入，其具体行为如下：\n- 如果 $S=0$，则 $D$ 必须等于 $A$。\n- 如果 $S=1$，则 $D$ 必须等于 $B$。\n\n一个标准的布尔结构，当 $Z=0$ 时选择 $X$，当 $Z=1$ 时选择 $Y$，其表达式为：\n$$\nf(X,Y,Z)=XZ' + YZ.\n$$\n验证如下：\n- 如果 $Z=0$，则 $f=X(1)+Y(0)=X$。\n- 如果 $Z=1$，则 $f=X(0)+Y(1)=Y$。\n\n将 $X=A$，$Y=B$ 和 $Z=S$ 应用于此，所需的数据输入为：\n$$\nD = AS' + BS = S'A + SB.\n$$\n对照给定的行为进行检查：\n- 当 $S=0$ 时：$D = A(1) + B(0) = A$。\n- 当 $S=1$ 时：$D = A(0) + B(1) = B$。\n因此，该表达式满足要求。\n\n为完整起见，其他选项是错误的：\n- $SA + S'B$ 在 $S=0$ 时会得到 $D=B$，这与要求相矛盾。\n- $A \\oplus B$ 完全忽略了 $S$。\n- $(S+A)(S+B)$ 化简为 $S + AB$，这没有实现由 $S$ 控制的选择功能。\n- $AB + S$ 也是 $S + AB$，不是一个选择器。\n\n因此，正确的选项是 $D = S'A + SB$。", "answer": "$$\\boxed{B}$$", "id": "1958039"}, {"introduction": "在简单数据加载的基础上，我们现在将探索如何实现更精细的控制，即只更新寄存器中的特定位。本练习引入了“掩码”（mask）的概念，它充当了每个位的写使能信号，这是许多处理应用中的一项强大功能。通过追踪寄存器在几个时钟周期内的状态，您将对同步条件更新获得切实的理解。[@problem_id:1958064]", "problem": "正在分析一个特殊用途的4位同步寄存器，称为选择性更新寄存器。该寄存器有一个4位数据输入 `D[3:0]`、一个4位掩码输入 `M[3:0]` 和一个时钟输入 `CLK`。位的索引从右到左，因此 `D[0]` 是最低有效位。寄存器的状态由 `Q[3:0]` 表示。\n\n该寄存器在 `CLK` 信号的上升沿根据以下规则更新其状态，规则适用于从0到3的每个位 `i`：\n- 如果掩码位 `M[i]` 为 '1'，则对应的状态位 `Q[i]` 将用数据输入位 `D[i]` 的值进行更新。\n- 如果掩码位 `M[i]` 为 '0'，则对应的状态位 `Q[i]` 保持其先前的值，忽略数据输入位 `D[i]`。\n\n初始时，在时间 `t=0`，寄存器中存储的二进制值为 `1010`。在接下来的三个连续时钟周期内，应用了以下数据和掩码输入：\n- 在第1个时钟上升沿：`D = 1100`, `M = 0101`\n- 在第2个时钟上升沿：`D = 0111`, `M = 1100`\n- 在第3个时钟上升沿：`D = 1001`, `M = 1010`\n\n确定在第3个时钟上升沿之后，寄存器 `Q` 中存储的值。请以最终4位二进制值对应的十进制数形式提供您的答案。", "solution": "我们使用以下规则对每个位的选择性更新进行建模：对于在上升沿的每个位索引 $i \\in \\{0,1,2,3\\}$，\n$$\nQ^{+}[i] = \n\\begin{cases}\nD[i],  \\text{if } M[i] = 1,\\\\\nQ[i],  \\text{if } M[i] = 0.\n\\end{cases}\n$$\n等效地，在具有二进制值的布尔代数中，\n$$\nQ^{+}[i] = M[i]\\cdot D[i] + \\left(1 - M[i]\\right)\\cdot Q[i].\n$$\n初始状态在 $t=0$ 时：$Q=1010$，因此 $(Q[3],Q[2],Q[1],Q[0])=(1,0,1,0)$。\n\n第一个上升沿，输入为 $D=1100$ 和 $M=0101$：\n- $i=3$: $M[3]=0 \\Rightarrow Q^{+}[3]=Q[3]=1$。\n- $i=2$: $M[2]=1 \\Rightarrow Q^{+}[2]=D[2]=1$。\n- $i=1$: $M[1]=0 \\Rightarrow Q^{+}[1]=Q[1]=1$。\n- $i=0$: $M[0]=1 \\Rightarrow Q^{+}[0]=D[0]=0$。\n因此，在第1个上升沿之后：$Q=1110$。\n\n第二个上升沿，输入为 $D=0111$ 和 $M=1100$，从 $Q=1110$ 开始：\n- $i=3$: $M[3]=1 \\Rightarrow Q^{+}[3]=D[3]=0$。\n- $i=2$: $M[2]=1 \\Rightarrow Q^{+}[2]=D[2]=1$。\n- $i=1$: $M[1]=0 \\Rightarrow Q^{+}[1]=Q[1]=1$。\n- $i=0$: $M[0]=0 \\Rightarrow Q^{+}[0]=Q[0]=0$。\n因此，在第2个上升沿之后：$Q=0110$。\n\n第三个上升沿，输入为 $D=1001$ 和 $M=1010$，从 $Q=0110$ 开始：\n- $i=3$: $M[3]=1 \\Rightarrow Q^{+}[3]=D[3]=1$。\n- $i=2$: $M[2]=0 \\Rightarrow Q^{+}[2]=Q[2]=1$。\n- $i=1$: $M[1]=1 \\Rightarrow Q^{+}[1]=D[1]=0$。\n- $i=0$: $M[0]=0 \\Rightarrow Q^{+}[0]=Q[0]=0$。\n因此，在第3个上升沿之后：$Q=1100$。\n\n最终的4位值 $1100$ 等于 $1\\cdot 2^{3} + 1\\cdot 2^{2} + 0\\cdot 2^{1} + 0\\cdot 2^{0} = 8 + 4 = 12$（十进制）。", "answer": "$$\\boxed{12}$$", "id": "1958064"}, {"introduction": "寄存器的真正威力在于，我们可以通过设计自定义的组合逻辑来控制其状态转换，而不仅仅是简单的加载和保持操作。这个高级实践将挑战您创建一个具有独特双模行为的寄存器：加载新数据或翻转其现有状态。掌握这项技能使您能够为数字信号处理和密码学等领域的任务设计专用硬件。[@problem_id:1958052]", "problem": "一个用于数字信号处理应用的定制8位同步寄存器，称为条件状态修改器（Conditional State Modifier, CSM），正在被设计。该寄存器由八个相同且独立的位片（bit-slice）组成。对于每个位片 $i$（其中 $i$ 的范围从0到7），其行为由一个8位掩码向量 $M$ 中对应的位 $M_i$ 控制。该寄存器有一个8位的数据输入向量 $D$。所有状态变化都在一个公共时钟信号的上升沿发生。\n\n每个位片的行为定义如下：\n*   如果掩码位 $M_i = 1$，位 $i$ 的触发器将从相应的数据输入 $D_i$ 加载值。\n*   如果掩码位 $M_i = 0$，位 $i$ 的触发器将翻转其当前状态。\n\n假设每个位片都使用一个D型触发器实现。设 $Q_i$ 表示位 $i$ 的触发器的当前状态（输出），$J_i$ 是该D型触发器的逻辑输入。\n\n推导 $J_i$ 关于 $D_i$、$M_i$ 和 $Q_i$ 的最小化积之和（Sum-of-Products, SOP）布尔表达式。在您的表达式中，使用并列或点号表示“与”运算，使用加号表示“或”运算。使用上划线表示“非”运算（例如，$\\overline{X}$）。", "solution": "目标是确定D型触发器输入 $J_i$ 的布尔表达式，该触发器实现了条件状态修改器（CSM）第 $i$ 个位片的指定行为。对于D型触发器，其下一个状态 $Q_i(t+1)$ 等于时钟沿到达时其输入 $J_i$ 的值。因此，我们需要找到下一状态 $Q_i(t+1)$ 作为输入 $D_i$、$M_i$ 和当前状态 $Q_i$ 的函数表达式。\n\n我们可以通过考虑控制位 $M_i$ 的两种可能情况来分析这个问题。\n\n**情况1：$M_i = 1$（加载模式）**\n问题描述当 $M_i = 1$ 时，触发器从数据输入 $D_i$ 加载值。这意味着触发器的下一个状态应该等于 $D_i$。\n所以，对于 $M_i = 1$，我们有：\n$$Q_i(t+1) = D_i$$\n\n**情况2：$M_i = 0$（翻转模式）**\n问题描述当 $M_i = 0$ 时，触发器翻转其当前状态。翻转意味着下一个状态是当前状态 $Q_i$ 的逻辑非。\n所以，对于 $M_i = 0$，我们有：\n$$Q_i(t+1) = \\overline{Q_i}$$\n\n现在，我们需要将这两个互斥的条件组合成一个关于 $Q_i(t+1)$ 的单一布尔表达式。这可以使用一个等效于2选1多路复用器的结构来构建，其中 $M_i$ 作为选择线。这种结构的一般形式是：\n$$Q_i(t+1) = (M_i \\cdot \\text{Expression for } M_i=1) + (\\overline{M_i} \\cdot \\text{Expression for } M_i=0)$$\n\n代入我们为每种情况找到的表达式：\n当 $M_i$ 为真时，$M_i=1$ 的项有效，所以我们得到乘积项 $M_i D_i$。\n当 $\\overline{M_i}$ 为真时，$M_i=0$ 的项有效，所以我们得到乘积项 $\\overline{M_i} \\overline{Q_i}$。\n\n用逻辑“或”（加法）将这两个项组合起来，得到下一状态的完整特征方程：\n$$Q_i(t+1) = M_i D_i + \\overline{M_i} \\overline{Q_i}$$\n\n由于该寄存器是用D型触发器构建的，触发器的输入 $J_i$ 必须等于期望的下一状态 $Q_i(t+1)$。\n$$J_i = Q_i(t+1)$$\n因此，$J_i$ 的表达式为：\n$$J_i = M_i D_i + \\overline{M_i} \\overline{Q_i}$$\n\n这个表达式是积之和（SOP）形式。为了确认它是最小化的，我们可以分析这两个乘积项。项 $M_i D_i$ 包含文字 $M_i$ 和 $D_i$。项 $\\overline{M_i} \\overline{Q_i}$ 包含文字 $\\overline{M_i}$ 和 $\\overline{Q_i}$。这些项之间没有公共变量可用于通过布尔代数规则（如 $AX + A\\overline{X} = A$）进行进一步简化。这些项代表了覆盖函数“开”集（on-set）的本质主蕴含项，因此该表达式是最小化的。", "answer": "$$\\boxed{M_i D_i + \\overline{M_i} \\overline{Q_i}}$$", "id": "1958052"}]}