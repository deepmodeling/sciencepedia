{"hands_on_practices": [{"introduction": "现实世界的数字系统常常有超出教科书范例的独特操作要求。在这个问题中 [@problem_id:1928691]，你将为序列 `110` 设计一个检测器，但它在成功检测后有一个非标准的复位条件。这个练习考验你将具体的设计约束精确地转化为正确的状态转换图的能力，这是任何逻辑设计师的关键技能。", "problem": "一个数字控制系统需要一个Mealy型状态机来检测一个特定的、非重叠的输入序列。该状态机接收一个单比特串行输入 $X$，并产生一个单比特输出 $Z$。当且仅当最后接收到的三个输入为'110'时，状态机应在一个时钟周期内输出 $Z=1$。否则，输出 $Z$ 应为'0'。\n\n状态机的状态是根据输入流中已识别的最长后缀来定义的，该后缀同时也是目标序列'110'的前缀。\n- $S_0$：初始/复位状态，未检测到任何前缀。\n- $S_1$：最后一个输入为'1'的状态。\n- $S_2$：最后两个输入为'11'的状态。\n\n对于复位行为，规定了一个特殊的操作要求。在非重叠地检测到'110'序列后，状态机必须立即转移到表示刚刚接收到单个'1'的状态（即状态 $S_1$）。对于所有其他转移，状态机应转移到与新输入字符串末尾的'110'的最長有效前缀相对应的状态。\n\n根据这些规范，以下哪个陈述正确地描述了从状态 $S_2$ 开始的转移？\n\nA. 如果输入 $X$ 为'0'，则输出 $Z$ 为'1'，下一个状态为 $S_1$。如果输入 $X$ 为'1'，则输出 $Z$ 为'0'，下一个状态为 $S_2$。\n\nB. 如果输入 $X$ 为'0'，则输出 $Z$ 为'1'，下一个状态为 $S_0$。如果输入 $X$ 为'1'，则输出 $Z$ 为'0'，下一个状态为 $S_2$。\n\nC. 如果输入 $X$ 为'0'，则输出 $Z$ 为'1'，下一个状态为 $S_0$。如果输入 $X$ 为'1'，则输出 $Z$ 为'0'，下一个状态为 $S_1$。\n\nD. 如果输入 $X$ 为'0'，则输出 $Z$ 为'0'，下一个状态为 $S_1$。如果输入 $X$ 为'1'，则输出 $Z$ 为'0'，下一个状态为 $S_2$。\n\nE. 如果输入 $X$ 为'0'，则输出 $Z$ 为'1'，下一个状态为 $S_1$。如果输入 $X$ 为'1'，则输出 $Z$ 为'0'，下一个状态为 $S_0$。", "solution": "我们设计一个Mealy型状态机来检测非重叠序列“110”，其状态由观测到的输入的最长后缀定义，该后缀同时也是“110”的前缀：状态 $S_{0}$ 对应于没有匹配的前缀，状态 $S_{1}$ 对应于最后一个输入为“1”，状态 $S_{2}$ 对应于最后两个输入为“11”。当新接收的输入恰好完成目标序列“110”时，Mealy型输出 $Z$ 等于 1；否则 $Z$ 等于 0。此外，规范施加了一个特殊的复位行为：在非重叠检测到“110”后，下一个状态必须是 $S_{1}$，这会覆盖通常的最长后缀规则。\n\n我们分析从状态 $S_{2}$ 开始的转移，此时最后两个输入为“11”。\n\n1) 输入 $X$ 等于 0：\n- 最后三个输入变为“110”，因此发生了一次检测，并且根据Mealy型状态机的特性，在此输入下 $Z$ 等于 1。\n- 特殊要求规定，在非重叠检测之后，下一个状态立即为 $S_{1}$，而不管通常的后缀到前缀的映射规则。\n因此，从 $S_{2}$ 开始，当 $X$ 等于 0 时，我们得到 $Z$ 等于 1，下一个状态为 $S_{1}$。\n\n2) 输入 $X$ 等于 1：\n- 最后三个输入是“111”。下一个状态必须是与当前输入历史的最长后缀相对应的状态，该后缀同时也是“110”的前缀。在后缀“1”、“11”和“111”中，“110”的前缀有“1”和“11”，其中“11”是最长的。因此，下一个状态仍为 $S_{2}$。\n- 没有发生检测，因为观测到的三元组不是“110”，所以 $Z$ 等于 0。\n因此，从 $S_{2}$ 开始，当 $X$ 等于 1 时，我们得到 $Z$ 等于 0，下一个状态为 $S_{2}$。\n\n与选项比较，此行为与选项 A 中的描述完全匹配。", "answer": "$$\\boxed{A}$$", "id": "1928691"}, {"introduction": "现在，让我们来应对一个更抽象的挑战，它超越了检测固定模式的范畴。这个高级问题 [@problem_id:1928726] 要求你设计一个监控器，用以检查数据流中两个相邻数据块之间的特定*关系*。这将促使你深入思考状态的基本定义：为了正确工作，你的状态机必须记住的过去信息的绝对最小值是什么？", "problem": "在为高速串行通信线路设计专门的数据完整性监视器时，一项关键任务是检测输入比特流中的特定关系模式。您的任务是为此监视器设计核心逻辑，其形式为一个Mealy型有限状态机。\n\n该机器接收单个串行比特流，每个时钟周期一个比特。当最近接收的八个比特（例如 $x_7 x_6 x_5 x_4 x_3 x_2 x_1 x_0$，其中 $x_0$ 是最新的比特）满足一个特定条件时，机器的单个输出 $y$ 应为 `1`，且仅持续一个时钟周期。该条件是，最近的四比特半字节 ($(x_3 x_2 x_1 x_0)$) 是紧邻其前的四比特半字节 ($(x_7 x_6 x_5 x_4)$) 的按位取反。否则，输出 $y$ 应为 `0`。\n\n例如，如果最后接收的八个比特是 `11000011`，则输出 $y$ 将为 `1`，因为 `0011` 是 `1100` 的按位取反。如果下一个比特是 `1`，则新的八比特序列为 `10000111`。此时输出将为 `0`，因为 `0111` 不是 `1000` 的按位取反。\n\n确定正确实现此检测逻辑的Mealy机所需的最少状态数。", "solution": "设输入流为 $\\{b_{k}\\}_{k \\in \\mathbb{Z}}$，每个时钟周期一个比特。在时间 $n$（读取 $b_{n}$ 时），机器必须输出\n$$\ny_{n} = 1 \\quad \\text{iff} \\quad (b_{n-3},b_{n-2},b_{n-1},b_{n}) = \\overline{(b_{n-7},b_{n-6},b_{n-5},b_{n-4})}\n$$\n其中上划线表示按位取反；否则 $y_{n}=0$。\n\n上限（存在性）：一个Mealy机的状态等于当前输入之前的最后七个比特，这样的机器就足够了。将读取 $b_{n}$ 之前的状态定义为\n$$\ns_{n} = (b_{n-7},b_{n-6},b_{n-5},b_{n-4},b_{n-3},b_{n-2},b_{n-1}) \\in \\{0,1\\}^{7}.\n$$\n接收到输入 $b_{n}$ 后，8比特的窗口为 $(b_{n-7},\\ldots,b_{n})$。输出函数为\n$$\ny_{n} = 1 \\quad \\text{iff} \\quad (b_{n-3},b_{n-2},b_{n-1},b_{n}) = \\overline{(b_{n-7},b_{n-6},b_{n-5},b_{n-4})},\n$$\n它仅取决于 $s_{n}$ 和 $b_{n}$。下一状态更新是移位操作\n$$\ns_{n+1} = (b_{n-6},b_{n-5},b_{n-4},b_{n-3},b_{n-2},b_{n-1},b_{n}),\n$$\n它是 $s_{n}$ 和 $b_{n}$ 的确定性函数。因此，$2^{7}=128$ 个状态就足够了。\n\n下限（最小性）：我们证明，没有任何两个不同的7比特状态是等价的，因此至少需要 $2^{7}$ 个状态。设 $\\alpha=(a_{1},a_{2},a_{3},a_{4},a_{5},a_{6},a_{7})$ 和 $\\beta=(a'_{1},a'_{2},a'_{3},a'_{4},a'_{5},a'_{6},a'_{7})$ 是两个不同的状态，其中 $a_{i},a'_{i}\\in\\{0,1\\}$ 代表 $(b_{n-7},\\ldots,b_{n-1})$。设 $k$ 是满足 $a_{k}\\neq a'_{k}$ 的最小索引。选择一个整数 $d\\geq 0$ 使得 $k+d\\geq 4$，例如 $d=\\max(0,4-k)$。考虑一个长度为 $d+4$ 的后续序列，其定义如下：选取任意 $d$ 个比特（任意选择），然后选择接下来的4个比特，称之为 $v_{1},v_{2},v_{3},v_{4}$，使其成为4比特块 $U_{\\alpha}$ 的按位取反。在状态 $\\alpha$ 下，当该半字节的起始位置为 $k+d$ 时，$U_{\\alpha}$ 将扮演“较旧半字节”的角色。因为 $k+d\\geq 4$，相应的“较新半字节”在那个时刻完全位于未来的输入中，且等于 $(v_{1},v_{2},v_{3},v_{4})$，所以在状态 $\\alpha$ 下，当时的输出为 $1$。在状态 $\\beta$ 下，相应的4比特块 $U_{\\beta}$ 与 $U_{\\alpha}$ 在至少一个位置上不同（特别是在源于 $a_{k}\\neq a'_{k}$ 的位置上），因此相同的 $(v_{1},v_{2},v_{3},v_{4})$ 不可能等于 $\\overline{U_{\\beta}}$，输出为 $0$。因此，这两个状态可由某个后续序列区分，所以没有任何两个不同的7比特状态可以合并。\n\n因此，所需的最少状态数恰好是 $2^{7}=128$。", "answer": "$$\\boxed{128}$$", "id": "1928726"}]}