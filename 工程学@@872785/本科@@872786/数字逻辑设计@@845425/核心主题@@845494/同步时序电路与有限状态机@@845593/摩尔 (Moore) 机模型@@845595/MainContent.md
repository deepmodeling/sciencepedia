## 引言
在数字系统的世界里，能够“记忆”过去并据此决定未来行为的电路是构建复杂逻辑的基础。[有限状态机](@entry_id:174162)（FSM）正是描述这类[时序电路](@entry_id:174704)行为的核心抽象模型。然而，FSM并非铁板一块，根据其输出信号的生成方式，可以分为几种不同的类型。本文聚焦于其中一种基础且应用广泛的模型——[摩尔机](@entry_id:170836)（Moore Machine）。[摩尔机](@entry_id:170836)的独特之处在于其输出行为的稳定性和可预测性，它解决了如何将系统输出与内部“记忆”状态进行直接、清晰关联的问题。

本文将带领您系统地掌握[摩尔机](@entry_id:170836)模型。在“原理与机制”一章中，我们将深入其内部结构，学习如何用[状态图](@entry_id:176069)和[状态表](@entry_id:178995)来描述它，并探讨从抽象概念到物理电路的实现方法。接着，在“应用与跨学科连接”一章，我们将走出理论，探索[摩尔机](@entry_id:170836)在数字控制器、通信协议、[计算机体系结构](@entry_id:747647)乃至生物学和博弈论等领域的实际应用，展示其作为一种通用建模工具的强大能力。最后，“动手实践”部分将提供一系列精心设计的问题，引导您将所学知识付诸实践。学完本文，您将能够透彻理解[摩尔机](@entry_id:170836)的工作原理，并具备使用它来分析和设计实际时序系统的能力。

## 原理与机制

在前一章中，我们介绍了[有限状态机 (FSM)](@entry_id:176747) 作为设计[同步时序电路](@entry_id:175242)的抽象模型。本章将深入探讨一种特定类型的 FSM——**[摩尔机](@entry_id:170836) (Moore Machine)**。我们将详细阐述其基本原理、结构特性、分析与设计方法，并探讨一些高级概念。[摩尔机](@entry_id:170836)在[数字系统设计](@entry_id:168162)中无处不在，从简单的控制器到复杂的微处理器[指令解码器](@entry_id:750677)，理解其工作机制至关重要。

### [摩尔机](@entry_id:170836)的定义与结构

[摩尔机](@entry_id:170836)的核心定义特征在于其输出的生成方式。在一个[摩尔机](@entry_id:170836)中，**输出仅取决于当前的稳定状态**，而与当前的输入无关。这一定义性特征决定了其独特的结构和行为。

从结构上看，一个[同步时序电路](@entry_id:175242)可以被概念性地划分为两个主要部分：一个用于存储当前状态的**[状态寄存器](@entry_id:755408)**（通常由 D 型[触发器](@entry_id:174305)等[时序逻辑](@entry_id:181558)元件构成），以及用于计算下一[状态和](@entry_id:193625)输出的**[组合逻辑](@entry_id:265083)**。在[摩尔机](@entry_id:170836)模型中，这块[组合逻辑](@entry_id:265083)被进一步区分为两个独立的部分：

1.  **下一状态逻辑 (Next-State Logic)**：该部分的输入是电路的**当前状态**（来自[状态寄存器](@entry_id:755408)）和**外部输入**。其输出是电路的**下一状态**，这个输出将被送往[状态寄存器](@entry_id:755408)的输入端，准备在下一个时钟有效沿锁存。
2.  **输出逻辑 (Output Logic)**：该部分的输入**仅为电路的当前状态**。它的输出就是整个[摩尔机](@entry_id:170836)的输出。

我们可以用数学形式来精确描述这个关系。假设在时钟周期 $k$，机器的当前状态为 $s[k]$，外部输入为 $x[k]$，输出为 $y[k]$。那么，下一状态 $s[k+1]$ 和当前输出 $y[k]$ 分别由状态[转移函数](@entry_id:273897) $\delta$ 和输出函数 $\lambda$ 决定：

下一[状态函数](@entry_id:137683)：$s[k+1] = \delta(s[k], x[k])$
输出函数：$y[k] = \lambda(s[k])$

这种结构上的分离是[摩尔机](@entry_id:170836)与另一种主要 FSM 模型——[米利机](@entry_id:177066) (Mealy Machine)——的根本区别。在[米利机](@entry_id:177066)中，输出同时取决于当前[状态和](@entry_id:193625)当前输入，即 $y[k] = \lambda(s[k], x[k])$。[摩尔机](@entry_id:170836)输出对当前输入的“免疫性”是其最基本的结构属性 [@problem_id:1969121]。

从形式上讲，一个[摩尔机](@entry_id:170836)可以由一个五元组 $(Q, \Sigma, \Delta, \delta, \lambda)$ 定义，其中：
- $Q$ 是一个有限的**状态**集合。
- $\Sigma$ 是一个有限的**输入字母表**。
- $\Delta$ 是一个有限的**输出字母表**。
- $\delta: Q \times \Sigma \to Q$ 是**状态[转移函数](@entry_id:273897)**。
- $\lambda: Q \to \Delta$ 是**输出函数**。

注意输出函数 $\lambda$ 的定义域仅为状态集合 $Q$，这再次强调了其输出仅依赖于状态。

### [摩尔机](@entry_id:170836)的表示方法

为了清晰地描述和分析[摩尔机](@entry_id:170836)，工程师和理论家们使用两种标准化的表示方法：[状态表](@entry_id:178995)和[状态图](@entry_id:176069)。

#### [状态表](@entry_id:178995)

**[状态表](@entry_id:178995) (State Table)** 是一种表格形式的表示，它系统地列出了[状态机](@entry_id:171352)的所有行为。表的每一行对应一个状态，而列则展示了在不同输入下状态将如何转移，以及每个状态对应的输出是什么。

一个典型的[摩尔机](@entry_id:170836)[状态表](@entry_id:178995)包含以下几列：
- **当前状态 (Present State)**：列出机器的所有可能状态。
- **下一状态 (Next State)**：对于每一个可能的输入值，都有一列与之对应，指明在当前状态下，接收到该输入后将转移到的下一个状态。
- **输出 (Output)**：指明在当前状态下的输出值。在[摩尔机](@entry_id:170836)中，这一列的值仅与当前状态所在行相关。

例如，一个具有三个状态 ($S_0, S_1, S_2$)、一个二进制输入 $x$ 和一个二进制输出 $z$ 的[摩尔机](@entry_id:170836)，其[状态表](@entry_id:178995)可能如下所示 [@problem_id:1969126]：

| 当前状态 | 下一状态 (若输入 $x=0$) | 下一状态 (若输入 $x=1$) | 输出 ($z$) |
|:---:|:---:|:---:|:---:|
| $S_0$ | $S_1$ | $S_2$ | 0 |
| $S_1$ | $S_2$ | $S_1$ | 1 |
| $S_2$ | $S_0$ | $S_1$ | 0 |

从这个表中，我们可以清晰地读出所有信息：例如，当机器处于状态 $S_1$ 时，其输出为 $1$；此时如果输入为 $0$，下一个状态将是 $S_2$；如果输入为 $1$，它将保持在 $S_1$ 状态。

#### [状态图](@entry_id:176069)

**[状态图](@entry_id:176069) (State Diagram)** 是对[状态机](@entry_id:171352)行为的图形化表示，它能更直观地展示状态之间的流动关系。在[摩尔机](@entry_id:170836)的[状态图](@entry_id:176069)中：

- 每个**状态**用一个节点（通常是圆圈）表示。
- **状态的输出**被明确地写在代表该状态的节点**内部**。这是[摩尔机](@entry_id:170836)[状态图](@entry_id:176069)的一个标志性特征。
- **状态转移**用从一个节点指向另一个节点的有向边（箭头）表示。
- 每条边上都标有导致该次转移的**输入值**。

将上述[状态表](@entry_id:178995)转换为[状态图](@entry_id:176069)，我们会得到一个包含三个圆圈的图形。$S_0$ 和 $S_2$ 的圆圈内写着输出 "$0$"，而 $S_1$ 的圆圈内写着 "$1$"。从 $S_0$ 会有一条标有 "$0$" 的箭头指向 $S_1$，一条标有 "$1$" 的箭头指向 $S_2$。同样地，图中会画出所有其他的转移关系 [@problem_id:1969126]。这种图形化的表示方法对于理解和调试复杂的状态逻辑流非常有帮助。

### 物理实现与[状态编码](@entry_id:169998)

抽象的状态机模型最终需要通过物理电路来实现。这个过程涉及将抽象的状态映射到物理的存储元件上，即**[状态分配](@entry_id:172668) (State Assignment)** 或**[状态编码](@entry_id:169998) (State Encoding)**。

#### 状态容量与[触发器](@entry_id:174305)

[状态机](@entry_id:171352)的“记忆”功能是由[状态寄存器](@entry_id:755408)实现的，它由一组[触发器](@entry_id:174305)（如 D 型、T 型或 JK 型[触发器](@entry_id:174305)）构成。每个[触发器](@entry_id:174305)可以存储一个二进制位 (bit)。因此，由 $n$ 个[触发器](@entry_id:174305)构成的[状态寄存器](@entry_id:755408)总共可以表示 $2^n$ 种不同的二进制组合。这意味着，一个使用 $n$ 个[触发器](@entry_id:174305)的[摩尔机](@entry_id:170836)，其所能拥有的**最大状态数**为 $2^n$。例如，一个由四个 D 型[触发器](@entry_id:174305)构成的控制器，最多可以表示 $2^4 = 16$ 个不同的状态 [@problem_id:1969148]。在设计时，我们需要确保所选用的[触发器](@entry_id:174305)数量足以编码所有必要的状态，即 $n \ge \lceil \log_2(|Q|) \rceil$，其中 $|Q|$ 是状态的总数。

#### [状态分配](@entry_id:172668)及其影响

[状态分配](@entry_id:172668)是将抽象的状态（如 $S_0, S_1, S_2, ...$）与状态变量（即[触发器](@entry_id:174305)的输出，如 $Q_1, Q_0$）的具体二进制值进行映射的过程。这个选择并非无关紧要，它会直接影响到下一状态逻辑和输出逻辑的复杂性，进而影响电路的面积、速度和[功耗](@entry_id:264815)。

让我们通过一个 4 状态计数器（循环顺序为 $S_0 \to S_1 \to S_2 \to S_3 \to S_0$）的例子来比较两种常见的编码方案。假设输出 $Z$ 在状态 $S_2$ 和 $S_3$ 时为 $1$，否则为 $0$ [@problem_id:1969142]。

**方案 1：二[进制](@entry_id:634389)编码 (Binary Assignment)**
使用两个[状态变量](@entry_id:138790) $Q_1, Q_0$ 进行编码：
- $S_0: (Q_1, Q_0) = (0, 0)$
- $S_1: (Q_1, Q_0) = (0, 1)$
- $S_2: (Q_1, Q_0) = (1, 0)$
- $S_3: (Q_1, Q_0) = (1, 1)$

输出 $Z$ 在 $S_2$ 和 $S_3$ 时为 $1$，对应状态码为 $(1, 0)$ 和 $(1, 1)$。我们可以写出输出逻辑的[布尔表达式](@entry_id:262805)为 $Z_B = Q_1 \overline{Q_0} + Q_1 Q_0$。通过[布尔代数化简](@entry_id:260581)，得到 $Z_B = Q_1(\overline{Q_0} + Q_0) = Q_1$。输出逻辑非常简单，仅为一个[状态变量](@entry_id:138790)。

**方案 2：[独热编码](@entry_id:170007) (One-Hot Assignment)**
使用四个[状态变量](@entry_id:138790) $q_3, q_2, q_1, q_0$，每个状态由其中一个变量为 $1$ 来表示：
- $S_0: (q_3, q_2, q_1, q_0) = (0, 0, 0, 1)$
- $S_1: (q_3, q_2, q_1, q_0) = (0, 0, 1, 0)$
- $S_2: (q_3, q_2, q_1, q_0) = (0, 1, 0, 0)$
- $S_3: (q_3, q_2, q_1, q_0) = (1, 0, 0, 0)$

输出 $Z$ 在 $S_2$ 和 $S_3$ 时为 $1$，对应 $q_2=1$ 或 $q_3=1$。因此，输出逻辑表达式为 $Z_H = q_3 + q_2$。这个表达式本身已经是最简形式。

比较这两种方案，二[进制](@entry_id:634389)编码使用了最少的[触发器](@entry_id:174305)（2个），但其下一状态逻辑（此处未推导）通常比[独热编码](@entry_id:170007)更复杂。而[独热编码](@entry_id:170007)需要更多[触发器](@entry_id:174305)（4个），但其输出逻辑和下一状态逻辑往往非常简单。这种在[触发器](@entry_id:174305)数量和组合逻辑复杂度之间的权衡是 FSM 设计中的一个核心决策点。

### [摩尔机](@entry_id:170836)的分析与综合

对状态机的操作主要分为两类：分析（从现有电路推断其行为）和综合（从行为描述构建电路）。

#### 从电路到[状态表](@entry_id:178995)：[电路分析](@entry_id:261116)

分析一个已有的[时序电路](@entry_id:174704)，意味着要推导出它的[状态表](@entry_id:178995)或[状态图](@entry_id:176069)。这个过程始于电路的[逻辑门](@entry_id:142135)级描述，即[触发器](@entry_id:174305)的输入方程和电路的输出方程。

考虑一个由两个 T 型[触发器](@entry_id:174305)（状态变量为 $Q_A, Q_B$）、一个输入 $X$ 和一个输出 $Z$ 构成的[摩尔机](@entry_id:170836)。其逻辑由以下布尔方程定义 [@problem_id:1969093]：
- $T_A = X \cdot Q_B$
- $T_B = X + Q_A$
- $Z = Q_A \oplus Q_B$

为了分析它，我们首先需要 T 型[触发器](@entry_id:174305)的特性方程：$Q^+ = T \oplus Q$，其中 $Q^+$ 是下一个状态。

1.  **推导下一[状态方程](@entry_id:274378)**：
    $Q_A^+ = T_A \oplus Q_A = (X \cdot Q_B) \oplus Q_A$
    $Q_B^+ = T_B \oplus Q_B = (X + Q_A) \oplus Q_B$

2.  **构建[状态表](@entry_id:178995)**：我们可以通过遍历所有可能的当前状态 $(Q_A, Q_B)$ 和输入 $X$ 的组合，来计算出对应的下一状态 $(Q_A^+, Q_B^+)$ 和输出 $Z$。例如，当处于状态 $(Q_A, Q_B) = (0, 1)$ 且输入 $X=1$ 时：
    - $T_A = 1 \cdot 1 = 1$, $T_B = 1 + 0 = 1$
    - $Q_A^+ = 1 \oplus 0 = 1$, $Q_B^+ = 1 \oplus 1 = 0$
    - $Z = 0 \oplus 1 = 1$
    这样，我们就填充了[状态表](@entry_id:178995)的一行。重复此过程，即可得到完整的[状态表](@entry_id:178995)。

3.  **追踪行为**：有了[状态表](@entry_id:178995)，我们可以追踪机器对任意输入序列的响应。例如，从初始状态 $(0,0)$ 开始，输入序列为`1101`，我们可以逐个[时钟周期](@entry_id:165839)地计算[状态和](@entry_id:193625)输出，得到输出序列`01100`（包括初始状态的输出）。

#### 从[状态表](@entry_id:178995)到逻辑：输出[逻辑综合](@entry_id:274398)

综合是设计的核心环节，它涉及将[状态分配](@entry_id:172668)后的[状态表](@entry_id:178995)转化为实际的[组合逻辑](@entry_id:265083)电路。对于[摩尔机](@entry_id:170836)，输出逻辑的综合相对直接，因为它只依赖于状态变量。

假设我们有如下[状态分配](@entry_id:172668)表 [@problem_id:1969147]：

| 当前状态 | 状态变量 $(Q_1, Q_0)$ | ... | 输出 $Z$ |
|:---:|:---:|:---:|:---:|
| $S_0$ | (0, 0) | ... | 0 |
| $S_1$ | (0, 1) | ... | 1 |
| $S_2$ | (1, 0) | ... | 1 |

此外，状态 $(1,1)$ 未被使用，成为一个**[无关项](@entry_id:165299) (Don't-care condition)**。我们的任务是为输出 $Z$ 找到一个简化的[布尔表达式](@entry_id:262805)。我们可以为 $Z(Q_1, Q_0)$ 创建一个[真值表](@entry_id:145682)或卡诺图：

| $Q_1$ | $Q_0$ | $Z$ |
|---|---|---|
| 0 | 0 | 0 |
| 0 | 1 | 1 |
| 1 | 0 | 1 |
| 1 | 1 | X |

在卡诺图中，我们可以利用[无关项](@entry_id:165299) 'X' 来形成更大的组合，从而简化表达式。将 $Z=1$ 的项 $(0,1)$ 和 $(1,0)$ 与[无关项](@entry_id:165299) $(1,1)$ 结合，可以得到两个覆盖所有 '1' 的组合：一个覆盖了 $Q_1=1$ 的整行，得到项 $Q_1$；另一个覆盖了 $Q_0=1$ 的整列，得到项 $Q_0$。因此，简化的[和之积](@entry_id:271134) (SOP) 表达式为 $Z = Q_1 + Q_0$。这个表达式可以直接用一个[或门](@entry_id:168617)来实现。

### [摩尔机](@entry_id:170836)的设计方法：以[序列检测器](@entry_id:261086)为例

设计[状态机](@entry_id:171352)通常始于一个对所需行为的文字描述。一个典型的例子是**[序列检测器](@entry_id:261086) (Sequence Detector)**。让我们来设计一个[摩尔机](@entry_id:170836)，用于检测输入二进制序列中的 `11`。该机器应该能够识别重叠的序列，例如，输入 `01110` 应产生输出 `00110` [@problem_id:1969104]。

设计的关键第一步是**定义状态的含义**。每个状态都必须封装了关于过去输入历史的足够信息，以便对未来的输入做出正确的决策。

- **状态 $S_0$ (初始状态)**：我们还没有看到任何构成目标序列 `11` 的部分。或者说，最近的输入破坏了序列。这是我们的“默认”状态。输出为 $0$。
- **状态 $S_1$**：我们刚刚看到了一个 ‘1’。这是目标序列的第一个字符。我们正“在路上”。输出为 $0$。
- **状态 $S_2$**：我们刚刚看到了 `11`。我们成功检测到了序列。在这个状态，输出必须为 $1$。

接下来，我们基于这些状态定义来构建状态转移：

- **从 $S_0$ 出发**：
  - 输入 ‘0’：我们仍然没有看到 ‘1’ 的开始。保持在 $S_0$。
  - 输入 ‘1’：我们看到了序列的第一个 ‘1’。转移到 $S_1$。
- **从 $S_1$ 出发** (已看到一个 ‘1’)：
  - 输入 ‘0’：序列被打破（我们得到了 `10`）。必须回到初始状态 $S_0$。
  - 输入 ‘1’：我们得到了 `11`。成功！转移到 $S_2$。
- **从 $S_2$ 出发** (已看到 `11`)：
  - 输入 ‘0’：序列被打破（我们得到了 `110`）。回到 $S_0$。
  - 输入 ‘1’：我们得到了 `111`。这个新的 ‘1’ 与前一个 ‘1’ 构成了新的 `11` 重叠序列。因此，我们应该保持在 $S_2$，继续输出 ‘1’。

将这些逻辑整理成[状态表](@entry_id:178995)，我们便完成了对该[序列检测器](@entry_id:261086)的抽象设计。这个过程体现了从模糊的需求到精确的逻辑规范的转换，是[数字系统设计](@entry_id:168162)的核心技能。

### 关键行为特性：输出的时序延迟

[摩尔机](@entry_id:170836)的结构——输出仅依赖于寄存器锁存的状态——导致了一个非常重要且必须理解的行为特性：**输出相对于导致它的输入存在一个[时钟周期](@entry_id:165839)的延迟**。

让我们仔细分析这个因果链 [@problem_id:1969139]：

1.  在[时钟周期](@entry_id:165839) $k$ 的开始，系统处于状态 $s[k]$，输出为 $y[k] = \lambda(s[k])$。
2.  在该周期内，一个新的输入 $x[k]$ 到达。
3.  下一状态逻辑块根据 $s[k]$ 和 $x[k]$ 进行[组合逻辑](@entry_id:265083)运算，计算出下一状态 $s_\text{next} = \delta(s[k], x[k])$。这个计算在[时钟周期](@entry_id:165839)内发生。
4.  在时钟周期 $k+1$ 的有效沿（例如，上升沿），[状态寄存器](@entry_id:755408)将 $s_\text{next}$ 的值锁存。此时，机器的新状态变为 $s[k+1] = s_\text{next}$。
5.  在整个时钟周期 $k+1$ 中，输出逻辑块看到新的状态 $s[k+1]$，并据此生成新的输出 $y[k+1] = \lambda(s[k+1])$。

因此，由输入 $x[k]$ 引起的状态变化，要等到[时钟周期](@entry_id:165839) $k+1$ 才体现在[状态寄存器](@entry_id:755408)中，并进而影响输出 $y[k+1]$。这个固有的一周期延迟是[摩尔机](@entry_id:170836)模型的直接结果。这意味着[摩尔机](@entry_id:170836)的输出与输入是**异步**的（即使整个电路是同步的）。在需要输出与输入严格同步的应用中，这可能是一个缺点。然而，这种特性也使得[摩尔机](@entry_id:170836)的输出信号更加稳定、无毛刺 (glitch-free)，因为它们只在[时钟沿](@entry_id:171051)之后、状态稳定时才发生变化。

### 高级主题：状态化简与同构

在完成了初步设计后，我们常常需要对对[状态机](@entry_id:171352)进行优化，或者在形式上验证其与其他设计的等价性。

#### [状态等价](@entry_id:261329)与化简

**状态化简 (State Minimization)** 的目标是找到并移除冗余的状态，以最少的状态数量实现相同的功能，从而降低实现成本。

两个状态被认为是**等价的 (equivalent)**，如果且仅如果：
1.  它们有完全相同的输出。
2.  对于所有可能的输入，它们都转移到等价的状态。

这是一个递归的定义。实际操作中，我们通常使用一种称为**划分法 (Partitioning)** 的算法来找到等价状态。其步骤如下 [@problem_id:1969109]：
1.  **初始划分 ($P_0$)**：根据输出将所有状态分成若干组。所有输出相同的状态在同一组。
2.  **[迭代求精](@entry_id:167032)**：对于当前划分 $P_k$ 中的每一个组，检查组内的状态。如果对于某个输入，组内的两个状态转移到了 $P_k$ 中不同的组，那么这两个状态不等价，必须将它们分开。这样就形成了新的、更精细的划分 $P_{k+1}$。
3.  **终止**：重复上述过程，直到某次迭代后划分不再改变 ($P_{k+1} = P_k$)。此时，仍在同一组内的所有状态都是等价的。

例如，在分析一个六状态机时，我们首先可能会根据输出将 $\{S_0, S_1, S_3, S_4\}$ (输出 $0$) 和 $\{S_2, S_5\}$ (输出 $1$) 分成两组。然后，我们检查 $\{S_2, S_5\}$，发现对于输入 ‘0’，它们都转移到 $S_1$；对于输入 ‘1’，它们都转移到 $S_3$。由于它们的转移目标完全相同，因此它们是等价的。在最终的化简[状态机](@entry_id:171352)中，我们可以用一个状态来代替 $S_2$ 和 $S_5$。

#### 机器同构

**同构 (Isomorphism)** 是一个比[状态等价](@entry_id:261329)更强的概念，它描述的是两个状态机在结构上的完全一致性，仅仅是状态的命名可能不同。如果两个 FSM 是同构的，那么一个可以通过对状态进行重新标记而无缝地转变为另一个。

形式上，两个[摩尔机](@entry_id:170836) $M_1 = (Q_1, \Sigma, \Delta, \delta_1, \lambda_1)$ 和 $M_2 = (Q_2, \Sigma, \Delta, \delta_2, \lambda_2)$ 是同构的，如果存在一个**[双射函数](@entry_id:266779) (bijection)** $h: Q_1 \to Q_2$，对于所有状态 $q \in Q_1$ 和所有输入 $a \in \Sigma$ 都满足以下两个条件 [@problem_id:1969099]：

1.  **输出保持**：$\lambda_1(q) = \lambda_2(h(q))$
2.  **转移保持**：$h(\delta_1(q, a)) = \delta_2(h(q), a)$

要验证两个机器是否同构，我们需要尝试找到这样一个映射函数 $h$。首先，任何可能的映射都必须满足输出保持条件。例如，如果 $M_1$ 中有2个状态输出为 ‘A’，1个为 ‘B’，1个为 ‘C’，那么 $M_2$ 也必须有相同数量的对应输出状态，否则它们不可能是同构的。然后，在满足输出保持的候选映射下，我们必须逐一检查所有[状态和](@entry_id:193625)所有输入的转移是否也保持一致。如果能找到一个满足所有条件的映射，则两机同构；否则，它们不是同构的。

这个概念在硬件验证、设计重用和[逆向工程](@entry_id:754334)等领域非常重要，它提供了一种形式化的方法来判断两个看似不同的设计是否在功能上完全相同。