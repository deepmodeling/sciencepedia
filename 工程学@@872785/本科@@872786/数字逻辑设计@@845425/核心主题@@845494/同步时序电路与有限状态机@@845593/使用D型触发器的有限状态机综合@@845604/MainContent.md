## 引言
[有限状态机](@entry_id:174162)（FSM）是[数字逻辑设计](@entry_id:141122)的基石，为构建从简单计数器到复杂处理器控制单元的各类[时序电路](@entry_id:174704)提供了强大的理论框架。然而，从抽象的[状态图](@entry_id:176069)或[状态表](@entry_id:178995)到具体的硬件电路实现，需要一个系统化且严谨的转换过程。如何高效、正确地将一个状态机的行为逻辑转化为由[触发器](@entry_id:174305)和逻辑门构成的物理实体，是每个数字系统工程师必须掌握的核心技能。本文旨在深入探讨这一关键问题，重点介绍使用现代数字设计中最普及的时序元件——[D型触发器](@entry_id:171740)——进行FSM综合的全过程。

本文将引导读者分三步构建完整的知识体系。首先，在“原理与机制”一章中，我们将揭示[D型触发器](@entry_id:171740)为何能极大简化综合过程，并详细介绍从概念到逻辑表达式的[标准化](@entry_id:637219)设计流程。接着，在“应用与跨学科连接”一章中，我们将通过丰富的实例展示FSM在计算机体系结构、自动化控制和数字通信等领域的广泛应用，将理论与实践紧密相连。最后，“动手实践”部分将提供一系列精心设计的问题，帮助读者巩固所学知识，并将其应用于解决实际工程挑战。现在，让我们从FSM综合的核心原理出发，开始我们的学习之旅。

## 原理与机制

本章将深入探讨使用 D 型[触发器](@entry_id:174305)综合[有限状态机](@entry_id:174162)（FSM）的原理和实践方法。在上一章介绍 FSM 的基本概念之后，我们现在将注意力转向将抽象的[状态图](@entry_id:176069)转化为具体[数字逻辑电路](@entry_id:748425)的系统化过程。D 型[触发器](@entry_id:174305)是现代数字设计中最常用的时序元件，其行为特性使得 FSM 的综合过程既直接又富有条理。本章的目标是建立一个坚实的理论框架，并通过一系列精心设计的示例，阐明从问题描述到最终逻辑表达式的完整设计流程。

### D 型[触发器](@entry_id:174305)的核心作用：次态等于输入

使用 D 型[触发器](@entry_id:174305)进行 FSM 设计的全部理论基石可以归结为一个极为简洁的关系。一个 D 型[触发器](@entry_id:174305)在时钟的有效边沿（通常是上升沿）到来时，会将其输出 $Q$ 更新为其 D 输入端当时的值。换言之，[触发器](@entry_id:174305)的**次态** $Q^{+}$ 等于其**输入** $D$。

$$Q^{+} = D$$

这个特性是 FSM 综合的中心思想。它意味着，为 FSM 设计状态转移逻辑的挑战，完全转化为了一个为每个状态位（即每个 D 型[触发器](@entry_id:174305)）推导其 $D$ 输入的[组合逻辑](@entry_id:265083)表达式的问题。只要我们能确定在任何当前[状态和](@entry_id:193625)任何输入条件下，FSM 的下一个状态应该是什么，我们也就直接确定了驱动[状态寄存器](@entry_id:755408)中每个[触发器](@entry_id:174305)的逻辑。

让我们通过一个基本的“采样-保持”电路来阐明这一核心原理 [@problem_id:1938263]。设想一个 FSM，它有一个数据输入 `data` 和一个控制输入 `sample`。其功能要求是：当 `sample` 为 1 时，FSM 的状态在下一个[时钟周期](@entry_id:165839)更新为 `data` 的当前值；当 `sample` 为 0 时，FSM 保持其当前状态。如果我们用一个 D 型[触发器](@entry_id:174305)的输出 $Q$ 来存储这个状态，那么次态 $Q^{+}$ 的行为可以描述为：

- 若 $sample = 1$，则 $Q^{+} = \text{data}$。
- 若 $sample = 0$，则 $Q^{+} = Q$。

这两种情况可以用一个[布尔表达式](@entry_id:262805)完美地统一起来，这恰好是一个 2-1 多路选择器（MUX）的逻辑：

$$Q^{+} = (sample \cdot \text{data}) + (\overline{sample} \cdot Q)$$

根据 D 型[触发器](@entry_id:174305)的核心关系 $D = Q^{+}$，我们立刻得到了驱动该[触发器](@entry_id:174305)的 D 输入的逻辑表达式：

$$D_{ff} = (sample \cdot \text{data}) + (\overline{sample} \cdot Q)$$

这个简单的例子揭示了 FSM 设计的本质：将对状态转移的文字描述转化为次态方程，而对于 D 型[触发器](@entry_id:174305)，这些方程直接就是其输入激励方程。这个“保持或更新”的 MUX 结构是 FSM 设计中反复出现的一个基本模式。

### FSM 的系统化综合流程

尽管每个 FSM 的具体功能千差万别，但使用 D 型[触发器](@entry_id:174305)将其从概念转化为电路的综合过程遵循一个统一且系统化的流程。这个流程将复杂的设计任务分解为一系列定义明确、易于管理的步骤。

1.  **[状态图](@entry_id:176069)与[状态表](@entry_id:178995)构建**：这是设计的起点，也是最具创造性的一步。需要仔细分析问题描述，确定系统需要记忆哪些信息，并据此定义一组有限的状态。随后，明确在每个状态下，对于每种可能的输入，系统应转移到哪个次态，并产生什么输出。这个过程的结果通常是一个**[状态图](@entry_id:176069)**或等价的**[状态表](@entry_id:178995)**。在这一步，必须明确 FSM 是 **Moore 型**（输出仅取决于当前状态）还是 **Mealy 型**（输出取决于当前[状态和](@entry_id:193625)当前输入）。

2.  **[状态分配](@entry_id:172668) (State Assignment)**：为每个抽象的状态（如 $S_0, S_1, \dots$）分配一个唯一的二[进制](@entry_id:634389)编码。首先需要确定实现[状态寄存器](@entry_id:755408)所需的最少[触发器](@entry_id:174305)数量 $n$，它必须满足 $2^n \ge k$，其中 $k$ 是状态的总数。因此，$n = \lceil \log_2(k) \rceil$。[状态编码](@entry_id:169998)的选择会影响最终组合逻辑的复杂性，我们将在后续章节探讨这一点。

3.  **构建次态与输出表 (Implementation Table)**：将抽象的[状态表](@entry_id:178995)转化为一个二进制的[真值表](@entry_id:145682)。这个表的输入列包括所有外部输入信号和所有当前状态位（$Q_i$）。输出列包括所有次态位（$Q_i^{+}$）和所有 FSM 的输出信号（$Z_j$）。

4.  **推导逻辑表达式**：这是综合过程的核心计算步骤。对于每一个次态位 $Q_i^{+}$，从实现表中提取其对应的[真值表](@entry_id:145682)，然后使用布尔代数或[卡诺图](@entry_id:264061)（Karnaugh map）等工具，推导出其最小化的[组合逻辑](@entry_id:265083)表达式。由于我们使用 D 型[触发器](@entry_id:174305)，有 $D_i = Q_i^{+}$，所以这些表达式直接就是对应[触发器](@entry_id:174305)的 D 输入激励方程。同样地，为每个 FSM 输出 $Z_j$ 也推导出其逻辑表达式。

5.  **电路实现**：根据推导出的逻辑表达式，使用与门、或门、非门等逻辑门以及 D 型[触发器](@entry_id:174305)，绘制出最终的电[路图](@entry_id:274599)。

### Moore 型 FSM 综合实例

Moore 型 FSM 的输出仅由当前状态决定，这使得它们在某些应用中行为更稳定、可预测。我们通过两个例子来展示其综合过程。

#### 序列发生器

FSM 的一个常见用途是生成特定的周期性信号，此时 FSM 通常没有外部输入，我们称之为自治（autonomous）FSM。考虑一个任务：设计一个 Moore 型 FSM，生成一个周期为 4、[占空比](@entry_id:199172)为 25% 的波形，即信号 $Z$ 在一个[时钟周期](@entry_id:165839)内为高电平，在接下来的三个周期内为低电平 [@problem_id:1938283]。

1.  **状态与输出定义**：我们需要 4 个状态来构成一个周期。我们可以定义状态 $S_0$ 产生高电平输出，而 $S_1, S_2, S_3$ 产生低电平输出。状态转移序列是固定的：$S_0 \rightarrow S_1 \rightarrow S_2 \rightarrow S_3 \rightarrow S_0 \rightarrow \dots$

2.  **[状态分配](@entry_id:172668)**：4 个状态至少需要 $\lceil \log_2(4) \rceil = 2$ 个[触发器](@entry_id:174305)。我们使用两个[状态变量](@entry_id:138790) $Q_1, Q_0$。一个可能的分配方案是：$S_0=00, S_1=01, S_2=11, S_3=10$。

3.  **次态与输出表**：根据状态转移序列和分配，我们可以构建如下表格：

| 当前状态 ($Q_1Q_0$) | 次态 ($Q_1^{+}Q_0^{+}$) | 输出 (Z) |
| :------------------ | :-------------------- | :------- |
| 00                  | 01                    | 1        |
| 01                  | 11                    | 0        |
| 11                  | 10                    | 0        |
| 10                  | 00                    | 0        |

4.  **逻辑表达式推导**：
    - 对于输出 $Z$，它只在状态 $Q_1Q_0=00$ 时为 1，因此 $Z = \overline{Q_1}\overline{Q_0}$。
    - 对于次态位 $Q_1^{+}$，通过观察表格，我们发现 $Q_1^{+}$ 的值总是与当前状态位 $Q_0$ 的值相同。因此，$Q_1^{+} = Q_0$。
    - 对于次态位 $Q_0^{+}$，通过观察表格，我们发现 $Q_0^{+}$ 的值总是与当前状态位 $Q_1$ 的反相值相同。因此，$Q_0^{+} = \overline{Q_1}$。

    由于 $D_i = Q_i^{+}$，我们得到 D 输入的激励方程：
    $$D_1 = Q_0$$
    $$D_0 = \overline{Q_1}$$

这个例子展示了对于一个固定的序列发生器，其 D 输入逻辑可以非常简单，有时甚至只是其他状态位的连接或反相。

#### 带控制输入的计数器

现在，让我们在一个 Moore 型计数器中加入外部控制。考虑一个 2 位同步[格雷码](@entry_id:166435)计数器，它有一个使能输入 $E$ [@problem_id:1938272]。当 $E=1$ 时，计数器在每个[时钟周期](@entry_id:165839)前进到[格雷码](@entry_id:166435)序列的下一个值 ($00 \to 01 \to 11 \to 10 \to 00 \dots$)；当 $E=0$ 时，计数器保持当前状态。状态位 $Q_1, Q_0$ 同时也是电路的输出。

此设计的核心逻辑可以看作是在“保持”和“前进”两种模式之间选择：

- 若 $E=0$ (保持), 则 $Q_1^{+} = Q_1$ 且 $Q_0^{+} = Q_0$。
- 若 $E=1$ (前进), 我们需要确定[格雷码](@entry_id:166435)前进的逻辑。通过分析格雷码序列，可以发现次态 $Q_1^{+}$ 总是等于当前状态的 $Q_0$，而次态 $Q_0^{+}$ 总是等于当前状态的 $\overline{Q_1}$。

利用我们在“采样-保持”电路中看到的[多路选择器](@entry_id:172320)思想，我们可以为每个次态位构建逻辑表达式：

$$Q_1^{+} = (\overline{E} \cdot Q_1) + (E \cdot Q_0)$$
$$Q_0^{+} = (\overline{E} \cdot Q_0) + (E \cdot \overline{Q_1})$$

因此，D [触发器](@entry_id:174305)的输入激励方程为：

$$D_1 = \overline{E}Q_1 + EQ_0$$
$$D_0 = \overline{E}Q_0 + E\overline{Q_1}$$

这个例子完美地展示了如何将[控制信号](@entry_id:747841)（如使能 $E$）无缝地集成到 FSM 的[次态逻辑](@entry_id:164866)中，其结构本质上是为每个状态位选择下一个值是来自“保持”路径还是“更新”路径。

### Mealy 型 FSM 综合实例

Mealy 型 FSM 的输出依赖于当前[状态和](@entry_id:193625)当前输入，这使得它们能够对输入变化做出即时响应。这种特性在需要快速反应的应用（如数据检测）中非常有用。

#### 记忆历史输入

Mealy FSM 的状态通常用于“记忆”过去输入序列的关键信息。设想一个条件数据通路门 [@problem_id:1938298]，它有一个数据输入 $D$ 和一个门控输入 $G$。输出 $Z$ 必须等于 $D$，当且仅当 $G$ 在当前和前一个时钟周期都为 1；在所有其他情况下，$Z$ 必须为 0。

1.  **状态定义**：为了判断“前一个周期 $G$ 是否为 1”，FSM 必须存储一位历史信息。因此，我们需要一个状态位，我们称之为 $Q_0$。让 $Q_0$ 的含义定义为前一个时钟周期 $G$ 的值。即，$Q_0(t) = G(t-1)$。这是一个单[触发器](@entry_id:174305) FSM，有两个状态：$Q_0=0$（前一个 $G$ 为 0）和 $Q_0=1$（前一个 $G$ 为 1）。

2.  **[次态逻辑](@entry_id:164866)**：为了让 $Q_0$ 在下一个时钟周期 $(t+1)$ 能够代表当前周期 $(t)$ 的 $G$ 值，即 $Q_0(t+1) = G(t)$，我们必须在每个[时钟沿](@entry_id:171051)将当前的 $G$ 值采样到[触发器](@entry_id:174305)中。因此，次态方程为 $Q_0^{+} = G$。

3.  **D 输入和输出逻辑**：
    - D 输入逻辑非常直接：$D_0 = Q_0^{+} = G$。
    - 输出 $Z$ 的逻辑根据问题描述是：$Z=D$ 当且仅当 $G(t)=1$ 且 $G(t-1)=1$。用我们的[状态变量](@entry_id:138790)来表达，就是 $G=1$ 且 $Q_0=1$。所以，输出逻辑为 $Z = D \cdot G \cdot Q_0$。

这个例子清晰地展示了[状态变量](@entry_id:138790)作为“记忆”的直接作用，以及 Mealy 型输出如何结合当前输入 ($D, G$) 和历史信息（存储在 $Q_0$ 中）来产生结果。

#### [序列检测器](@entry_id:261086)

[序列检测器](@entry_id:261086)是 Mealy FSM 的经典应用。我们的任务是设计一个能够检测输入流 $X$ 中出现的重叠序列 `1001` 的 FSM [@problem_id:1938295]。当检测到序列时，输出 $Z$ 置为 1。

1.  **状态定义**：状态需要记录我们已经匹配了目标序列的多长的前缀。
    - $S_0$：初始状态，没有匹配到任何前缀（或者说匹配了空序列）。
    - $S_1$：刚刚接收到 `1`。
    - $S_2$：已经接收到 `10`。
    - $S_3$：已经接收到 `100`。

2.  **[状态分配](@entry_id:172668)与[状态表](@entry_id:178995)**：4 个状态需要 2 个[触发器](@entry_id:174305) ($Q_1, Q_0$)。一个给定的分配是 $S_0=00, S_1=01, S_2=11, S_3=10$。接下来，我们为每个[状态和](@entry_id:193625)每个输入 $X$ 确定次态和输出。例如：
    - 在 $S_2$ ($11$，已匹配 `10`)，如果输入 $X=0$，则匹配了 `100`，应转移到 $S_3$ ($10$)。输出 $Z=0$。
    - 在 $S_3$ ($10$，已匹配 `100`)，如果输入 $X=1$，则完整匹配了 `1001`。此时 Mealy 输出 $Z$ 必须为 1。同时，这个输入的 `1` 也是下一个可能的 `1001` 序列的开始，所以次态应为 $S_1$ ($01$)。

    将所有可能性系统地列出，可以得到完整的二进制实现表。

3.  **逻辑表达式推导**：从完整的实现表中，我们可以为 $D_1, D_0, Z$ 推导表达式。例如，通过分析次态 $Q_1^{+}$ 何时为 1，可以发现其仅在 (当前状态=$S_1$, 输入=$0$) 和 (当前状态=$S_2$, 输入=$0$) 时发生。使用给定的[状态分配](@entry_id:172668)，这对应于 $(Q_1Q_0=01, X=0)$ 和 $(Q_1Q_0=11, X=0)$。其逻辑表达式可以被最小化为：
    $$D_1 = Q_1^{+} = \overline{Q_1}Q_0\overline{X} + Q_1Q_0\overline{X} = (\overline{Q_1}+Q_1)Q_0\overline{X} = Q_0\overline{X}$$

    类似地，可以为 $D_0$ 和 $Z$ 导出最小化表达式：
    $$D_0 = X + \overline{Q_1}Q_0$$
    $$Z = XQ_1\overline{Q_0}$$

这个复杂的例子展示了遵循系统化流程的重要性，即使面对看似错综复杂的状态转移规则，也能有条不紊地推导出正确的实现逻辑。

### [状态分配](@entry_id:172668)与[逻辑优化](@entry_id:177444)

到目前为止，我们多是接受给定的[状态分配](@entry_id:172668)方案。然而，[状态分配](@entry_id:172668)本身是 FSM 设计中的一个关键决策点，它直接影响最终组合逻辑的复杂度和成本。

#### [状态分配](@entry_id:172668)的影响

不同的二[进制](@entry_id:634389)编码分配给相同的抽象状态集，会导致截然不同的次态和输出逻辑表达式。例如，对于一个 FSM，采用顺序[二进制码](@entry_id:266597)（$S_0=00, S_1=01, S_2=10, \dots$）和[格雷码](@entry_id:166435)（$S_0=00, S_1=01, S_2=11, \dots$）可能会产生复杂性截然不同的逻辑电路。虽然综合过程对于任何有效的分配都成立 [@problem_id:1938303]，但一个“好”的分配可以显著简化电路，减少门数、功耗和延迟。寻找最优[状态分配](@entry_id:172668)本身是一个复杂的问题，但在实践中，遵循一些启发式规则（如将具有共同次态的[状态分配](@entry_id:172668)给相邻的编码）通常能得到不错的结果。

#### 利用未使用状态：[无关项](@entry_id:165299)

当 FSM 的状态数 $k$ 不是 2 的整数次幂时，使用 $n=\lceil \log_2(k) \rceil$ 个[触发器](@entry_id:174305)会导致存在 $2^n - k$ 个未被使用的二进制编码。例如，一个 5 状态的 FSM 需要 3 个[触发器](@entry_id:174305)，这提供了 8 个可用编码，从而留下了 3 个未使用状态 [@problem_id:1961711]。

这些未使用状态在[逻辑综合](@entry_id:274398)中扮演了一个非常重要的角色。因为在正常操作下，FSM 永远不会进入这些状态，所以当这些未使用的编码作为当前状态出现在[次态逻辑](@entry_id:164866)的[真值表](@entry_id:145682)中时，对应的次态是什么我们并**不关心**。这些条目被称为**[无关项](@entry_id:165299) (don't-care conditions)**。

在[逻辑最小化](@entry_id:164420)（例如使用[卡诺图](@entry_id:264061)）的过程中，我们可以自由地将这些[无关项](@entry_id:165299)视为 0 或 1，以帮助我们形成更大、更简单的逻辑积项或和项。正确地利用[无关项](@entry_id:165299)是 FSM [逻辑优化](@entry_id:177444)的一个关键技术，它几乎总能带来更简洁的电路实现。

#### 备选方案：独热码 (One-Hot Encoding)

除了[最小二进制编码](@entry_id:166301)外，**独热码**是另一种重要的[状态分配](@entry_id:172668)策略。在一个具有 $k$ 个状态的独热 FSM 中，我们使用 $k$ 个[触发器](@entry_id:174305)，每个状态被分配一个其中只有一位为 '1'、其余位全为 '0' 的编码。例如，一个 3 状态的 FSM 可以使用编码 $001, 010, 100$ [@problem_id:1938277]。

这种编码方式的主要**优点**是其状态转移逻辑通常极其简单。例如，在一个简单的独热[环形计数器](@entry_id:168224)中（$001 \to 010 \to 100 \to 001$），每个[触发器](@entry_id:174305)的 D 输入就是其在环中的前一个[触发器](@entry_id:174305)的 Q 输出：

$$D_2 = Q_1$$
$$D_1 = Q_0$$
$$D_0 = Q_2$$

这种简化的逻辑可以提高 FSM 的运行速度。其**缺点**是需要更多的[触发器](@entry_id:174305)，这在过去被认为是一种资源浪费。然而，在现代 FPGA（[现场可编程门阵列](@entry_id:173712)）架构中，[触发器](@entry_id:174305)资源非常丰富，而布线和组合逻辑资源相对更为宝贵。因此，采用独热码来换取更简单、更快的[组合逻辑](@entry_id:265083)，是一种非常常见且高效的设计策略。

总而言之，使用 D 型[触发器](@entry_id:174305)进行 FSM 的设计是一个以 $D=Q^{+}$ 为核心的、系统化的过程。通过理解和应用[状态分配](@entry_id:172668)技术、利用[无关项](@entry_id:165299)进行优化以及根据目标平台（如 FPGA）的特性选择合适的编码方案（如独热码），设计者可以创造出功能正确、性能优越且资源高效的数字系统。