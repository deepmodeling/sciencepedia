{"hands_on_practices": [{"introduction": "理论上，我们可以用 AND 和 XOR 门来构建半加器。但在实际的芯片制造中，使用单一类型的“通用门”（如 NAND 门）来构建所有逻辑电路通常更具成本效益。这个练习 [@problem_id:1940533] 将挑战你仅使用 NAND 门来实现一个完整的半加器，这是一个将布尔代数理论转化为实际门级电路设计的经典实践，能够加深你对通用门和逻辑化简的理解。", "problem": "在数字逻辑设计中，半加器是一种基本的组合电路，它执行两个单位二进制数的算术加法。该电路有两个输入，我们称之为 $A$ 和 $B$，并产生两个输出：一个和位 $S$ 和一个进位位 $C$。这些输出的逻辑运算由以下布尔表达式定义：\n\n$S = A \\oplus B$（即 $A$ 和 $B$ 的异或）\n$C = A \\cdot B$（即 $A$ 和 $B$ 的逻辑与）\n\n一位逻辑设计师的任务是构建这个半加器电路，但有一个严格的设计约束：实现必须只使用双输入与非门。两个输入 $X$ 和 $Y$ 的与非（NAND）运算由表达式 $(X \\cdot Y)'$ 给出。\n\n确定构建一个能从输入 $A$ 和 $B$ 正确生成和（$S$）与进位（$C$）两个输出的完整半加器，所需双输入与非门的绝对最小数量。", "solution": "我们必须仅用双输入与非门来实现一个半加器。其输出由 $S = A \\oplus B$ 和 $C = A \\cdot B$ 定义，而一个双输入与非门是 $(X \\cdot Y)'$。\n\n使用标准的4个与非门实现异或（XOR）来构造 $S$，并进行合理安排，以便我们可以复用一个内部节点，再用一个与非门来获得 $C$：\n1) 计算共享的中间结果\n$$\nN_{1} = \\text{NAND}(A,B) = (A \\cdot B)'.\n$$\n2) 形成接下来的两个中间结果\n$$\nN_{2} = \\text{NAND}(A,N_{1}) = (A \\cdot N_{1})' = A' + N_{1}' = A' + A B,\n$$\n$$\nN_{3} = \\text{NAND}(B,N_{1}) = (B \\cdot N_{1})' = B' + N_{1}' = B' + A B,\n$$\n在每种情况下，我们都使用了德摩根定律 $(X \\cdot Y)' = X' + Y'$ 以及 $N_{1}' = ((A \\cdot B)')' = A \\cdot B$。\n3) 生成和\n$$\nS = \\text{NAND}(N_{2},N_{3}) = (N_{2} \\cdot N_{3})'.\n$$\n验证这是否等于 $A \\oplus B$：\n$$\nN_{2} \\cdot N_{3} = (A' + A B)(B' + A B)\n= A'B' + A'AB + ABB' + ABAB\n= A'B' + 0 + 0 + AB\n= A'B' + AB,\n$$\n所以\n$$\nS = (A'B' + AB)' = (A'B')' \\cdot (AB)' = (A + B) \\cdot (A' + B') = A'B + AB',\n$$\n这确实是 $A \\oplus B$。这部分使用了4个与非门。\n\n通过复用 $N_{1} = (A \\cdot B)'$ 并用一个额外的与非门（接成反相器）将其反相来获得进位：\n$$\nC = \\text{NAND}(N_{1},N_{1}) = (N_{1} \\cdot N_{1})' = N_{1}' = ((A \\cdot B)')' = A \\cdot B.\n$$\n这增加了一个与非门，总共需要5个与非门。\n\n为了论证其最小性：\n- 一个标准的结论是，仅用双输入与非门实现一个双输入异或门至少需要4个与非门。因此，任何正确的半加器都必须使用至少4个与非门来实现 $S = A \\oplus B$。\n- 进位 $C = A \\cdot B$ 无法从这4个门直接以正确的极性获得；然而，$(A \\cdot B)'$ 作为 $N_{1}$ 自然地出现了。从 $(A \\cdot B)'$ 生成 $C$ 至少需要一次额外的反相，在仅使用与非门的实现中，这恰好需要再多一个双输入与非门（其输入端连接在一起）。因此，至少需要 $4 + 1 = 5$ 个与非门。\n- 上述的显式构造使用了5个门，因此5是绝对最小值。\n\n因此，实现一个半加器所需的最小双输入与非门数量是5。", "answer": "$$\\boxed{5}$$", "id": "1940533"}, {"introduction": "随着数字系统变得越来越复杂，在门级进行设计已不现实。现代数字设计流程依赖于硬件描述语言 (HDL)，如 Verilog，它允许我们在更高的抽象层次上描述电路的行为。这个练习 [@problem_id:1940514] 要求你使用 Verilog 的行为建模风格来实现一个半加器，这不仅能巩固你对其功能的理解，还能让你体验到现代化的电路设计方法，并将逻辑表达式直接映射为硬件行为。", "problem": "一位嵌入式系统工程师正在为数字信号处理器（DSP）设计一个高度优化的核心。所需的一个基本构建模块是半加器。为了满足严格的综合和时序约束，强制规定了一种特定的行为建模风格。\n\n该半加器有两个单位输入 `A` 和 `B`，并产生一个两位输出向量 `Y`。设计规范规定如下：\n1.  输出 `Y` 必须是一个两位向量，其中最高有效位（MSB）`Y[1]` 代表进位输出（Carry-out），最低有效位（LSB）`Y[0]` 代表和（Sum）。\n2.  计算 `Y` 的全部逻辑必须在单个连续赋值语句中实现，并使用 Verilog 的三元条件运算符（`? :`）。\n\n根据*所有*设计规范，以下哪个 Verilog 模块正确地实现了半加器？\n\nA.\n```verilog\nmodule half_adder(input A, input B, output [1:0] Y);\n  assign Y = (A == 1'b1) ? {B, ~B} : {1'b0, B};\nendmodule\n```\n\nB.\n```verilog\nmodule half_adder(input A, input B, output [1:0] Y);\n  assign Y = (A == 1'b1) ? {1'b0, B} : {B, ~B};\nendmodule\n```\n\nC.\n```verilog\nmodule half_adder(input A, input B, output [1:0] Y);\n  assign Y = {A  B, A ^ B};\nendmodule\n```\n\nD.\n```verilog\nmodule half_adder(input A, input B, output [1:0] Y);\n  assign Y = (A == 1'b1) ? {~B, B} : {B, 1'b0};\nendmodule\n```\n\nE.\n```verilog\nmodule half_adder(input A, input B, output [1:0] Y);\n  assign Y = A + B;\nendmodule\n```", "solution": "一个具有单位输入 $A$ 和 $B$ 的半加器必须产生一个两位输出向量 $Y=\\{Y[1],Y[0]\\}$，其中进位输出为 $Y[1]$，和为 $Y[0]$。其规范布尔表达式为：\n$$\nY[1]=C=A \\land B,\\quad Y[0]=S=A \\oplus B,\n$$\n所以\n$$\nY=\\{A \\land B,\\ A \\oplus B\\}.\n$$\n规范还额外要求，整个逻辑必须使用 Verilog 三元运算符在单个连续赋值语句中实现。\n\n根据功能行为和建模风格约束来评估每个选项：\n\n- 选项 C:\n$$\nY=\\{A \\ B,\\ A \\oplus B\\}\n$$\n这个在功能上是正确的，但它没有使用三元运算符，违反了强制的建模风格。\n\n- 选项 E:\n$$\nY=A+B\n$$\n对于单位的 $A$ 和 $B$，两位和等于 $\\{A \\land B,\\ A \\oplus B\\}$，因此它在功能上是正确的。然而，它也没有使用三元运算符，违反了建模风格。\n\n- 选项 B 和 D 在功能上是不正确的。例如，当 $A=1$ 且 $B=1$ 时，期望的输出是 $\\{1,0\\}$，但选项 B 产生 $\\{0,1\\}$，选项 D 也产生 $\\{0,1\\}$，两者都不正确。\n\n- 选项 A:\n$$\nY=(A==1)\\ ?\\ \\{B,\\ \\neg B\\}\\ :\\ \\{0,\\ B\\}.\n$$\n通过对 $A$ 进行条件判断来证明其与规范形式等价：\n1) 如果 $A=1$，则期望的输出为 $C=A \\land B=B$ 和 $S=A \\oplus B=1 \\oplus B=\\neg B$，所以 $Y=\\{B,\\ \\neg B\\}$。\n2) 如果 $A=0$，则期望的输出为 $C=A \\land B=0$ 和 $S=A \\oplus B=0 \\oplus B=B$，所以 $Y=\\{0,\\ B\\}$。\n因此，选项 A 使用带有三元运算符的单个连续赋值语句，精确地实现了 $Y=\\{A \\land B,\\ A \\oplus B\\}$，满足所有规范。", "answer": "$$\\boxed{A}$$", "id": "1940514"}, {"introduction": "一个电路设计得再好，如果无法验证其在制造后是否正常工作，也是徒劳的。电路测试是确保数字系统可靠性的关键环节，而“固定型故障模型”是测试中最常用的概念之一。这个练习 [@problem_id:1940500] 将带你进入数字电路测试的世界，你需要为半加器设计一套最小化的测试向量集，以检测其输入和输出上可能出现的常见制造缺陷，从而培养系统化验证和故障排查的思维。", "problem": "在某新型微处理器的质量保证部门，您的任务是为一种基本逻辑块——半加器——开发测试程序。一个标准的半加器是一个数字电路，它有两个单比特输入 A 和 B，以及两个单比特输出：和（S）与进位（C）。其逻辑通过标准的门级设计实现：`S = A XOR B` 和 `C = A AND B`。\n\n为了验证制造出的电路，您将使用单一固定型故障模型。该模型假设一个制造缺陷可能导致电路中的某一条线路永久“固定”在逻辑0（固定为0）或逻辑1（固定为1）。您的测试必须能够检测出在两个输入（A, B）和两个输出（S, C）上发生的任何此类故障。\n\n一个测试向量是一个特定的输入组合 `(A, B)`。如果对于每一种可能的单一固定型故障，测试向量集中至少有一个向量能够产生与无故障电路不同的输出，那么这个测试向量集就被认为是‘完备的’。如果一个集合是完备的，并且不存在更小的完备集，那么该集合是‘最小的’。\n\n以下哪个测试向量集代表了用于测试半加器输入和输出上所有固定为0和固定为1故障的最小完备集？选择所有适用的选项。\n\nA. `{(0,0), (1,1)}`\n\nB. `{(0,1), (1,0), (1,1)}`\n\nC. `{(0,0), (0,1), (1,0), (1,1)}`\n\nD. `{(0,0), (1,0), (1,1)}`\n\nE. `{(0,0), (0,1), (1,0)}`\n\nF. `{(0,0), (0,1), (1,1)}`", "solution": "给定一个半加器，其有两个输入 $A,B$ 和两个输出 $S,C$，定义如下\n$$\nS = A \\oplus B, \\qquad C = A \\land B.\n$$\n这些方程所对应的真值表值为：\n- $(A,B)=(0,0)\\Rightarrow (S,C)=(0,0)$，\n- $(A,B)=(0,1)\\Rightarrow (S,C)=(1,0)$，\n- $(A,B)=(1,0)\\Rightarrow (S,C)=(1,0)$，\n- $(A,B)=(1,1)\\Rightarrow (S,C)=(0,1)$。\n\n在针对线路 $A,B,S,C$ 的单一固定型故障模型下，如果无故障电路计算出的输出 $(S,C)$ 与故障线路被强制固定到特定值时产生的输出不同，则该故障可被测试向量 $(A,B)$ 检测到。\n\n首先，推导每种故障类型的必要和充分检测条件。\n\n1) 输入固定型故障：\n- 对于 $A$ 固定为 $0$（记为 $A\\text{ s-a-}0$）：测试必须尝试设置 $A=1$ 并传播其影响。比较 $(1,B)$（正常）与 $(0,B)$（故障）的输出：\n  - 如果 $B=0$：$(1,0)\\Rightarrow (1,0)$ vs $(0,0)\\Rightarrow (0,0)$，因此 $S$ 不同；可检测到。\n  - 如果 $B=1$：$(1,1)\\Rightarrow (0,1)$ vs $(0,1)\\Rightarrow (1,0)$，$S$ 和 $C$ 都不同；可检测到。\n  因此，任何 $A=1$ 的向量都能检测到 $A\\text{ s-a-}0$。\n- 对于 $A$ 固定为 $1$（$A\\text{ s-a-}1$）：测试必须尝试设置 $A=0$ 并传播其影响。比较 $(0,B)$ 与 $(1,B)$ 的输出：\n  - 如果 $B=0$：$(0,0)\\Rightarrow (0,0)$ vs $(1,0)\\Rightarrow (1,0)$，$S$ 不同；可检测到。\n  - 如果 $B=1$：$(0,1)\\Rightarrow (1,0)$ vs $(1,1)\\Rightarrow (0,1)$，两者都不同；可检测到。\n  因此，任何 $A=0$ 的向量都能检测到 $A\\text{ s-a-}1$。\n- 根据对称性，对于 $B$：\n  - $B\\text{ s-a-}0$ 可由任何 $B=1$ 的向量检测到。\n  - $B\\text{ s-a-}1$ 可由任何 $B=0$ 的向量检测到。\n\n因此，为了检测所有输入固定型故障，测试集必须包含至少一个 $A=0$ 的向量和一个 $A=1$ 的向量，以及至少一个 $B=0$ 的向量和一个 $B=1$ 的向量。\n\n2) 输出固定型故障：\n- 对于 $S\\text{ s-a-}0$：需要一个在无故障情况下 $S=1$ 的向量（即 $(0,1)$ 或 $(1,0)$）。\n- 对于 $S\\text{ s-a-}1$：需要一个在无故障情况下 $S=0$ 的向量（即 $(0,0)$ 或 $(1,1)$）。\n- 对于 $C\\text{ s-a-}0$：需要一个在无故障情况下 $C=1$ 的向量。这只在 $(1,1)$ 时发生。\n- 对于 $C\\text{ s-a-}1$：需要一个在无故障情况下 $C=0$ 的向量（即 $(0,0)$、$(0,1)$、$(1,0)$ 中的任意一个）。\n\n因此，任何完备集都必须包含 $(1,1)$ 以检测 $C\\text{ s-a-}0$。它还必须包含至少一个 $S=1$ 的向量（$(0,1)$ 或 $(1,0)$）以检测 $S\\text{ s-a-}0$。$(1,1)$ 的存在已经提供了一个 $S=0$ 和 $C=1$ 的情况。结合输入故障的要求，必要条件可以简化为：\n- 包含 $(1,1)$，\n- 包含至少一个 $A=0$ 的向量，\n- 包含至少一个 $B=0$ 的向量，\n- 包含至少一个 $S=1$ 的向量（即，至少一个 $(1,0)$ 或 $(0,1)$）。\n\n因为 $(1,1)$ 固定了 $A=1$ 和 $B=1$，而单个额外的向量不能同时保证 $A=0$、$B=0$ 和 $S=1$，所以至少需要三个向量。因此，任何最小完备集的基数必须为 $3$。\n\n现在评估每个选项：\n\nA. $\\{(0,0),(1,1)\\}$:\n- 没有 $S=1$ 的向量，因此无法检测 $S\\text{ s-a-}0$。不是完备集。\n\nB. $\\{(0,1),(1,0),(1,1)\\}$:\n- 包含 $(1,1)$，有 $A=0$（来自 $(0,1)$）和 $A=1$（来自其他向量），有 $B=0$（来自 $(1,0)$）和 $B=1$（来自其他向量），并且有 $S=1$（来自 $(0,1)$ 或 $(1,0)$）。因此是完备的。\n- 最小性：移除 $(0,1)$ 会失去 $A=0$（无法检测 $A\\text{ s-a-}1$）；移除 $(1,0)$ 会失去 $B=0$（无法检测 $B\\text{ s-a-}1$）；移除 $(1,1)$ 会失去 $C=1$（无法检测 $C\\text{ s-a-}0$）。因此是最小的。\n\nC. $\\{(0,0),(0,1),(1,0),(1,1)\\}$:\n- 是完备的但不是最小的（存在更小的完备集，例如选项B）。\n\nD. $\\{(0,0),(1,0),(1,1)\\}$:\n- 包含 $(1,1)$，有 $A=0$（来自 $(0,0)$）和 $A=1$（来自其他向量），有 $B=0$（来自 $(0,0)$ 或 $(1,0)$）和 $B=1$（来自 $(1,1)$），并且有 $S=1$（来自 $(1,0)$）。因此是完备的。\n- 最小性：移除 $(0,0)$ 会失去 $A=0$（无法检测 $A\\text{ s-a-}1$）；移除 $(1,0)$ 会失去 $S=1$（无法检测 $S\\text{ s-a-}0$）；移除 $(1,1)$ 会失去 $C=1$（无法检测 $C\\text{ s-a-}0$）。因此是最小的。\n\nE. $\\{(0,0),(0,1),(1,0)\\}$:\n- 缺少 $(1,1)$，因此无法检测 $C\\text{ s-a-}0$。不是完备集。\n\nF. $\\{(0,0),(0,1),(1,1)\\}$:\n- 包含 $(1,1)$，有 $A=0$（来自 $(0,0)$ 或 $(0,1)$）和 $A=1$（来自 $(1,1)$），有 $B=0$（来自 $(0,0)$）和 $B=1$（来自 $(0,1)$ 或 $(1,1)$），并且有 $S=1$（来自 $(0,1)$）。因此是完备的。\n- 最小性：移除 $(0,0)$ 会失去 $B=0$（无法检测 $B\\text{ s-a-}1$）；移除 $(0,1)$ 会失去 $S=1$（无法检测 $S\\text{ s-a-}0$）；移除 $(1,1)$ 会失去 $C=1$（无法检测 $C\\text{ s-a-}0$）。因此是最小的。\n\n因此，既是最小的又是完备的集合是 B、D 和 F。", "answer": "$$\\boxed{BDF}$$", "id": "1940500"}]}