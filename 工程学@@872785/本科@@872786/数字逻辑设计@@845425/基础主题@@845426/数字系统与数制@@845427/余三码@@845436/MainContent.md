## 引言
在二[进制](@entry_id:634389)主导的数字世界中，如何高效、准确地处理十进制数始终是一个核心挑战。在众多[二进制编码的十进制](@entry_id:173257)数（BCD）方案中，余三码（Excess-3 Code）以其独特的设计在早期[计算机算术](@entry_id:165857)单元中脱颖而出。它不仅是一种表示十进制数的方法，更是一种巧妙简化硬件设计的工程解决方案。本文旨在深入剖析余三码背后的逻辑，解答为何这种“加3”的偏移设计能在算术运算，特别是减法中，带来显著优势。读者将通过“原理与机制”、“应用与跨学科联系”及“动手实践”三个章节的探索，系统地掌握余三码，从基础定义到实际电路应用，全面理解其在数字系统中的价值。

## 原理与机制

在数字系统中，为了便于处理十[进制](@entry_id:634389)数，发展出了多种二[进制](@entry_id:634389)编码方案，统称为[二进制编码的十进制](@entry_id:173257)数（Binary-Coded Decimal, BCD）。除了最常见的8421 [BCD码](@entry_id:173257)，余三码（Excess-3 Code）是一种在早期计算设备中占有重要地位的非加权[BCD码](@entry_id:173257)。本章将深入探讨余三码的核心原理、关键特性及其在[算术电路](@entry_id:274364)设计中的具体应用机制。

### 余三码的定义与基本特性

余三码的编码规则非常直观：对于一个给定的十[进制](@entry_id:634389)数位 $D$（$D$ 的取值范围为 $0$ 到 $9$），其对应的余三码是一个四位二进制数，该二[进制](@entry_id:634389)数所代表的数值为 $D+3$。换言之，余三码是在其对应的8421 [BCD码](@entry_id:173257)的基础上加上二[进制](@entry_id:634389)的`0011`（即十进制的3）。

例如，要得到十进制数位2的余三码，我们首先计算 $2+3=5$，然后将5转换为四位二[进制](@entry_id:634389)形式，得到 `0101`。下表列出了十进制数0到9及其对应的余三码。

| 十[进制](@entry_id:634389)数 (D) | D+3 | 余三码 |
| :---: | :---: | :---: |
| 0 | 3 | 0011 |
| 1 | 4 | 0100 |
| 2 | 5 | 0101 |
| 3 | 6 | 0110 |
| 4 | 7 | 0111 |
| 5 | 8 | 1000 |
| 6 | 9 | 1001 |
| 7 | 10 | 1010 |
| 8 | 11 | 1011 |
| 9 | 12 | 1100 |

从编码规则可以推导出解码过程：将给定的四位余三码看作一个标准的二[进制](@entry_id:634389)数，计算其十进制值 $V$，则原始的十进制数位 $D$ 就是 $V-3$。例如，假设一台老式数字万用表的内部[数据总线](@entry_id:167432)上传输着一个两位数的余三码序列 `0100 1001`，其中高位在前。第一个码字 `0100` 的二进制值为4，解码为十[进制](@entry_id:634389)数位 $4-3=1$。第二个码字 `1001` 的二[进制](@entry_id:634389)值为9，解码为 $9-3=6$。因此，该设备显示的数值为16 [@problem_id:1934258]。同理，若一个测量设备显示两位数，其十位和个位的余三码分别为 `0111` 和 `1010`，则十位的二[进制](@entry_id:634389)值为7，解码为 $7-3=4$；个位的二进制值为10，解码为 $10-3=7$。因此，完整的数值为47 [@problem_id:1934325]。

由于四位二进制数共有 $2^4=16$ 种组合，而余三码只使用了其中的10种来表示0到9。从上表可以看出，有效的余三码其二[进制](@entry_id:634389)值范围为3（`0011`）到12（`1100`）。这意味着有6个码字是无效或未使用的，它们是 `0000`、`0001`、`0010`、`1101`、`1110` 和 `1111`。因此，可以设计一个校验电路，当接收到的四位码字是这六种无效模式之一时，就发出错误信号 [@problem_id:1934314]。

### 分类：一种[无权码](@entry_id:174942)

数字编码可以分为**加权码（Weighted Code）**和**[无权码](@entry_id:174942)（Non-weighted Code）**。在一个四位加权码中，存在一组固定的权值 $(w_3, w_2, w_1, w_0)$，使得对于任何一个十[进制](@entry_id:634389)数位 $D$ 及其二[进制](@entry_id:634389)表示 $(b_3 b_2 b_1 b_0)$，都满足等式 $D = b_3 w_3 + b_2 w_2 + b_1 w_1 + b_0 w_0$。最典型的加权码是8421 [BCD码](@entry_id:173257)，其权值就是(8, 4, 2, 1)。

余三码则是一种[无权码](@entry_id:174942)。我们可以通过[反证法](@entry_id:276604)证明这一点。假设余三码是加权码，存在一组固定的权值 $(w_3, w_2, w_1, w_0)$。我们可以利用已知的编码建立一个线性方程组来求解这组权值 [@problem_id:1934273]。

- 对于十[进制](@entry_id:634389)数0，其余三码为 `0011`。根据加权码定义：$0 = 0 \cdot w_3 + 0 \cdot w_2 + 1 \cdot w_1 + 1 \cdot w_0 \Rightarrow w_1 + w_0 = 0$。
- 对于十进制数1，其余三码为 `0100`：$1 = 0 \cdot w_3 + 1 \cdot w_2 + 0 \cdot w_1 + 0 \cdot w_0 \Rightarrow w_2 = 1$。
- 对于十进制数2，其余三码为 `0101`：$2 = 0 \cdot w_3 + 1 \cdot w_2 + 0 \cdot w_1 + 1 \cdot w_0 \Rightarrow w_2 + w_0 = 2$。

从第二个方程我们直接得到 $w_2=1$。代入第三个方程，有 $1 + w_0 = 2$，解得 $w_0=1$。再将 $w_0=1$ 代入第一个方程，有 $w_1 + 1 = 0$，解得 $w_1=-1$。至此，我们得到了一组可能的权值：$w_2=1$, $w_1=-1$, $w_0=1$ (由于 $b_3$ 在这些例子中都为0， $w_3$ 的值尚不确定)。

现在，我们用这组权值来检验十进制数3（其余三码为 `0110`）是否满足条件：
$3 = 0 \cdot w_3 + 1 \cdot w_2 + 1 \cdot w_1 + 0 \cdot w_0 = w_2 + w_1$
将求得的 $w_2=1$ 和 $w_1=-1$ 代入，得到：
$3 = 1 + (-1) = 0$
这导出了一个矛盾的等式 $3=0$。这个矛盾证明了我们的初始假设是错误的，即不存在一组固定的权值能适用于所有的余三码编码。因此，余三码是[无权码](@entry_id:174942)。

### 自补特性

余三码最重要的特性是其**自补性 (Self-complementing Property)**。这个特性与十[进制](@entry_id:634389)数的**9的补数 (9's Complement)** 运算密切相关。一个十[进制](@entry_id:634389)数位 $D$ 的9的补数定义为 $9-D$。例如，2的9的补数是7。

余三码的自补特性指的是：一个十[进制](@entry_id:634389)数位 $D$ 的9的补数所对应的余三码，可以通过将 $D$ 的余三码按位取反（也称为求1的补数）得到。

这个特性的根本数学原因如下 [@problem_id:1934313]：
令 $E(D)$ 表示十[进制](@entry_id:634389)数位 $D$ 的余三码所代表的四位二[进制](@entry_id:634389)整数值。根据定义，$E(D) = D+3$。
对于一个任意的四位二[进制](@entry_id:634389)数 $X$，对其按位取反（求1的补数），得到的新二[进制](@entry_id:634389)数所代表的整数值是 $(2^4 - 1) - X = 15 - X$。
现在，我们对 $D$ 的余三码 $E(D)$ 进行按位取反操作，得到的数值为：
$$ 15 - E(D) = 15 - (D+3) = 12 - D $$
接下来，我们考察 $D$ 的9的补数，即 $9-D$。其对应的余三码的数值为：
$$ E(9-D) = (9-D) + 3 = 12 - D $$
比较上述两式，我们发现它们的结果完全相同。这意味着：
$$ \overline{E(D)} = E(9-D) $$
其中 $\overline{E(D)}$ 表示对 $E(D)$ 的四位二[进制](@entry_id:634389)表示进行按位取反。这从数学上证明了余三码的自补特性。这个特性之所以成立，是因为加3这个偏移量恰好使得十[进制](@entry_id:634389)下的“对9求补”操作，等价于四位二[进制](@entry_id:634389)编码下的“对15求补”（即按位取反）操作。

我们可以用一个具体的例子来验证这个属性 [@problem_id:1934315]。考虑十[进制](@entry_id:634389)数位 $D=4$。
- $D=4$ 的余三码是 $E(4) = 4+3=7$，二[进制](@entry_id:634389)为 `0111`。
- $D=4$ 的9的补数是 $9-4=5$。
- 5的余三码是 $E(5) = 5+3=8$，二[进制](@entry_id:634389)为 `1000`。
观察 `0111` 和 `1000`，可以清楚地看到后者是前者的按位取反。此外，它们代表的整数值之和为 $7+8=15$，这对于任意一个数位及其9的补数的余三码都是成立的，因为 $(D+3) + ((9-D)+3) = 15$。

自补特性的一个直接推论是关于最高有效位（Most Significant Bit, MSB）的关系 [@problem_id:1934291]。一个数位 $D$ 的余三码 $E(D)=D+3$ 的MSB为1，当且仅当 $D+3 \ge 8$，即 $D \ge 5$。而其9的补数 $9-D$ 的余三码 $E(9-D)=(9-D)+3$ 的MSB为1，当且仅当 $(9-D)+3 \ge 8$，即 $D \le 4$。可以发现，对于任意数位 $D$，$E(D)$ 的MSB与 $E(9-D)$ 的MSB总是相反的，这也是自补特性的体现。

### 在[算术电路](@entry_id:274364)中的应用

余三码的设计并非偶然，其独特的属性，特别是自补特性，为早期[算术逻辑单元](@entry_id:178218)（ALU）的设计带来了显著的便利。

#### 利用自补特性简化减法电路

在[数字电路](@entry_id:268512)中，减法运算通常通过补码加法来实现。对于十进制减法 $A-B$，可以转换为 $A$ 加上 $B$ 的补数。利用9的补数，减法可以通过 $A + (9的补数(B))$ 再进行相应修正来完成。

这正是余三码自补特性大放异彩的地方。要计算一个数的9的补数，在8421 [BCD码](@entry_id:173257)中需要相对复杂的组合逻辑电路。然而，在余三码中，只需对每一位的编码进行按位取反即可。这意味着求9的补数这一操作，仅需要一组非门（Inverter）就可以实现 [@problem_id:1934294]。

因此，设计一个十进制减法器时，可以复用一个已有的加法器。将被减数 $B$ 的余三码送入一组非门得到其9的补数的余三码，然后将其与被减数 $A$ 的余三码一起送入加法器。这样，仅用极少的额外硬件（非门）就实现了减法功能，极大地简化了[电路设计](@entry_id:261622)，降低了成本和复杂性 [@problem_id:1934312]。

#### 余三码的加法与修正

虽然余三码在减法中表现优异，其加法过程则需要一个额外的修正步骤。当两个用余三码表示的数位相加时，不能直接得到和的余三码。

假设我们想计算两个十进制数位 $D_1$ 和 $D_2$ 的和。它们的余三码值分别为 $E_1 = D_1+3$ 和 $E_2 = D_2+3$。一个标准的四位[二进制加法](@entry_id:176789)器会将这两个码字相加，得到的结果是：
$$ E_1 + E_2 = (D_1+3) + (D_2+3) = (D_1+D_2) + 6 $$
这个结果比我们期望的和的余三码 $E(D_1+D_2) = (D_1+D_2)+3$ 多了3。因此，需要进行修正。修正的规则取决于加法是否产生了十进制的进位，而这个进位信息恰好可以从四位[二进制加法](@entry_id:176789)器的进位输出 $C_{out}$ 获得。

**情况一：无十[进制](@entry_id:634389)进位 ($D_1+D_2 \le 9$)**
在这种情况下，[二进制加法](@entry_id:176789) $(D_1+3) + (D_2+3)$ 的结果不会超过 $9+3+9+3 = 24$，但由于 $D_1+D_2 \le 9$，所以 $(D_1+D_2)+6 \le 15$。这意味着四位[二进制加法](@entry_id:176789)器不会产生进位输出，即 $C_{out}=0$。加法器输出的四位和 $S$ 的值为 $V_{int} = (D_1+D_2)+6$。
我们期望得到的结果是 $(D_1+D_2)$ 的余三码，即 $(D_1+D_2)+3$。
因此，修正操作为：从中间和 $S$ 中减去3（即二进制的 `0011`）。
$S - 3 = ((D_1+D_2)+6) - 3 = (D_1+D_2)+3$
这种情况发生时，中间和 $S$ 的值 $V_{int}$ 的范围是从 $0+0+6=6$ 到 $9+0+6=15$ [@problem_id:1934305]。

**情况二：有十[进制](@entry_id:634389)进位 ($D_1+D_2 \ge 10$)**
在这种情况下，$(D_1+D_2)+6 \ge 16$。四位[二进制加法](@entry_id:176789)器会产生进位输出，即 $C_{out}=1$。这1个进位恰好可以作为向更高位的十[进制](@entry_id:634389)进位。加法器输出的四位和 $S$ 的值等于 $((D_1+D_2)+6) - 16$。
和的个位数字是 $U = (D_1+D_2) - 10$。我们期望得到的修正结果是 $U$ 的余三码，即 $U+3 = (D_1+D_2)-10+3 = (D_1+D_2)-7$。
我们对中间和 $S$ 进行的修正操作是：加上3（即二[进制](@entry_id:634389)的 `0011`）[@problem_id:1934307]。
$S+3 = ((D_1+D_2)+6 - 16) + 3 = (D_1+D_2) - 7$
这正是我们期望的结果。

综上所述，余三码加法的修正规则非常简洁：
- 如果四位[二进制加法](@entry_id:176789)器的进位输出 $C_{out}=1$，则将结果加上 `0011`。
- 如果进位输出 $C_{out}=0$，则将结果减去 `0011`。

### [错误检测](@entry_id:275069)能力

在数据传输和存储中，编码的抗干扰能力是一个重要指标，通常用**[最小汉明距离](@entry_id:272322) ($d_{min}$)** 来衡量。[汉明距离](@entry_id:157657)是指两个等长码字之间对应位置上不同字符的个数。一个编码集的[最小汉明距离](@entry_id:272322)是该集合中任意两个不同码字之间汉明距离的最小值。一个编码能够确保检测出 $s$ 个错误的条件是 $s \le d_{min}-1$。

我们来评估余三码的[错误检测](@entry_id:275069)能力 [@problem_id:1934288]。考虑两个相邻的十[进制](@entry_id:634389)数位1和2，它们的余三码分别是 `0100` 和 `0101`。这两个码字之间只有一个比特位不同，因此它们的汉明距离为1。
$$ d_H(0100, 0101) = 1 $$
由于[最小汉明距离](@entry_id:272322)是所有码对中距离的最小值，且任意两个不同码字的距离至少为1，因此余三码的[最小汉明距离](@entry_id:272322) $d_{min}=1$。

根据[错误检测](@entry_id:275069)能力公式，该编码能保证检测的错误位数 $s = d_{min}-1 = 1-1=0$。这意味着余三码**不具备**任何[单比特错误](@entry_id:165239)的检测能力。一个单比特翻转就可能将一个有效的码字变成另一个有效的码字（如 `0100` 变为 `0101`），从而使错误无法被发现。这是余三码相对于某些其他编码（如某些带有[奇偶校验位](@entry_id:170898)的编码）的一个局限性。