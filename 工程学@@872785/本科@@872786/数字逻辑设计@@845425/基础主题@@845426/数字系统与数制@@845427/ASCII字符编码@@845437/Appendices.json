{"hands_on_practices": [{"introduction": "这项练习是理解字符如何在内存中存储的基础，它模拟了在嵌入式系统中解读内存寄存器中字符数据的常见场景。通过这个练习，你将实践如何将字符转换为其 ASCII 码，再转换为十六进制，并理解字节序（endianness）如何影响数据在内存中的表示方式。这项实践将抽象的字符与其在数字世界中的具体形式联系起来。[@problem_id:1909396]", "problem": "在一个旧式控制系统中，一个16位内存寄存器用于存储一个双字符状态码。该系统遵循大端格式，其中第一个字符存储在高位字节（第15到8位），第二个字符存储在低位字节（第7到0位）。字符使用标准的7位美国信息交换标准代码（ASCII）方案进行编码，其中每个8位字节的最高有效位设置为0。\n\n为了诊断目的，您需要读取该寄存器的内容。如果寄存器存储的状态码是“OK”，请确定其作为一个单独的4位十六进制数的值。\n\n供您参考，这些字符的十进制ASCII值为：\n- 'O': 79\n- 'K': 75\n\n请提供最终的4位十六进制字符串。", "solution": "系统使用大端存储，8位字节承载7位ASCII字符，且最高有效位设置为零。提供的ASCII值为：'O'是 $79$；'K'是 $75$。将每个十进制代码转换为十六进制：\n- 对于'O'：$79 = 4 \\times 16 + 15 \\implies \\text{byte} = \\text{0x}4\\text{F}$。\n- 对于'K'：$75 = 4 \\times 16 + 11 \\implies \\text{byte} = \\text{0x}4\\text{B}$。\n\n在大端格式中，第一个字符占据高位字节，第二个字符占据低位字节，因此16位寄存器的值 $R$ 为\n$$R = (\\text{0x}4\\text{F} \\ll 8) + \\text{0x}4\\text{B} = \\text{0x}4\\text{F}00 + \\text{0x}4\\text{B} = \\text{0x}4\\text{F}4\\text{B}.$$\n\n等效地，以十进制形式表示，\n$$R = 79 \\times 2^{8} + 75,$$\n其对应的十六进制值同样为 $\\text{0x}4\\text{F}4\\text{B}$。\n\n因此，所需的4位十六进制字符串是 $4\\text{F}4\\text{B}$。", "answer": "$$\\boxed{4F4B}$$", "id": "1909396"}, {"introduction": "除了简单的存储，ASCII 编码的有序性还支持强大的算术操作。本练习将探讨如何利用字母表字符的连续编码来进行计算，例如找出字符之间的“距离”。这种技巧是许多计算系统中文字处理和解析算法的基石，能够让你更深入地理解数据表示的内在逻辑。[@problem_id:1909417]", "problem": "一个简单的微处理器正在被设计用于处理基于文本的数据。它使用8位美国信息交换标准代码（ASCII）来表示字符，其中最高有效位（MSB）始终为0。在ASCII标准中，小写英文字母字符 'a' 到 'z' 被分配了连续的整数代码。同样，大写英文字母字符 'A' 到 'Z' 也占据一个连续的代码块。\n\n已知字符 'a' 的ASCII码是 $61_{16}$（十六进制），字符 'A' 的ASCII码是 $41_{16}$（十六进制）。\n\n该处理器的算术逻辑单元（ALU）对两个字符的8位ASCII码执行减法运算。计算从 'x' 的ASCII码中减去 'G' 的ASCII码的结果。请将最终答案表示为一个两位数的十六进制数。", "solution": "小写字母的ASCII码从 'a' 的 $61_{16}$ 开始是连续的，大写字母的ASCII码从 'A' 的 $41_{16}$ 开始也是连续的。\n\n首先，计算 'x' 的ASCII码。字母 'x' 是第 $24$ 个小写字母，所以它与 'a' 的偏移量是 $24-1=23$。用十六进制表示，$23 = 17_{16}$。因此，\n$$\n\\text{ASCII}(\\text{'x'}) = 61_{16} + 17_{16} = 78_{16}.\n$$\n\n接着，计算 'G' 的ASCII码。字母 'G' 是第 $7$ 个大写字母，所以它与 'A' 的偏移量是 $7-1=6$。用十六进制表示，$6 = 06_{16}$。因此，\n$$\n\\text{ASCII}(\\text{'G'}) = 41_{16} + 06_{16} = 47_{16}.\n$$\n\nALU将 'G' 的ASCII码从 'x' 的ASCII码中减去，即：\n$$\n78_{16} - 47_{16} = 31_{16}.\n$$\n这个结果在8位以内，没有发生回绕。\n\n因此，两位十六进制的结果是 $31$。", "answer": "$$\\boxed{31}$$", "id": "1909417"}, {"introduction": "最后的这项练习将 ASCII 编码直接带入硬件设计领域，是理论联系实际的关键一步。你将设计一个组合逻辑电路，该电路能根据其 7 位二进制模式识别特定的字符子集——在本例中为小写元音字母。这个练习展示了数字系统如何在最基础的层面上构建，以处理和响应基于文本的信息。[@problem_id:1909416]", "problem": "一个数字控制系统的任务是解析使用7位美国信息交换标准代码（ASCII）编码的字符流。该系统的一个关键功能是实现一个组合逻辑电路，用以检测输入字符是否为小写元音字母（'a', 'e', 'i', 'o', 'u'）。\n\n该电路接受一个7位输入，由变量 $A_6, A_5, A_4, A_3, A_2, A_1, A_0$ 表示，其中 $A_6$ 是最高有效位（MSB）。该电路必须产生一个单位输出 $V$，如果输入字符是五个小写元音字母之一，则 $V$ 的逻辑值为'1'，否则为'0'。\n\n小写元音字母的7位ASCII码（二进制，比特 $A_6$ 在最左边）如下所示：\n- 'a': `1100001`\n- 'e': `1100101`\n- 'i': `1101001`\n- 'o': `1101111`\n- 'u': `1110101`\n\n你的任务是根据输入比特，推导出输出逻辑函数 $V$ 的最小化积之和（SOP）布尔表达式。在你的最终表达式中，使用撇号（例如，$A_0'$）表示逻辑非运算，并列（例如，$A_1 A_0$）表示逻辑与运算，`+` 符号表示逻辑或运算。", "solution": "给定一个7位ASCII输入 $(A_{6},A_{5},A_{4},A_{3},A_{2},A_{1},A_{0})$，当且仅当输入为小写元音字母时，输出 $V=1$：\n- a: $1100001$\n- e: $1100101$\n- i: $1101001$\n- o: $1101111$\n- u: $1110101$\n\n从这些编码中，可以观察到对于所有五个元音字母，$A_{6}=1$，$A_{5}=1$ 且 $A_{0}=1$。根据布尔代数的因式分解法则（提取公因子），该函数可以写成\n$$\nV = A_{6}A_{5}A_{0}f(A_{4},A_{3},A_{2},A_{1}),\n$$\n其中，当四位比特组合对应于所列元音字母时，$f$ 为 1：\n- a: $(A_{4},A_{3},A_{2},A_{1})=0000$\n- e: $0010$\n- i: $0100$\n- o: $0111$\n- u: $1010$\n\n我们现在通过组合相邻的最小项（使用卡诺图或邻接推理）来将 $f$ 最小化为积之和形式：\n- 将 a $(0000)$ 与 i $(0100)$ 配对：它们仅在 $A_{3}$ 上不同。蕴含项是 $A_{4}'A_{2}'A_{1}'$（因为 $A_{4}=0$, $A_{2}=0$, $A_{1}=0$ 是固定的，而 $A_{3}$ 是自由变量）。这覆盖了 a 和 i。\n- 将 e $(0010)$ 与 u $(1010)$ 配对：它们仅在 $A_{4}$ 上不同。蕴含项是 $A_{3}'A_{2}A_{1}'$（因为 $A_{3}=0$, $A_{2}=1$, $A_{1}=0$ 是固定的，而 $A_{4}$ 是自由变量）。这覆盖了 e 和 u。\n- 最小项 o $(0111)$ 在给定的五个中没有相邻的1，因此它形成一个必需的单项蕴含项 $A_{4}'A_{3}A_{2}A_{1}$。\n\n因此，$f$ 的最小积之和形式为\n$$\nf = A_{4}'A_{2}'A_{1}' + A_{3}'A_{2}A_{1}' + A_{4}'A_{3}A_{2}A_{1}.\n$$\n重新引入公因子 $A_{6}A_{5}A_{0}$ 并将整个函数写成SOP形式，得到\n$$\nV = A_{6}A_{5}A_{0}A_{4}'A_{2}'A_{1}' + A_{6}A_{5}A_{0}A_{3}'A_{2}A_{1}' + A_{6}A_{5}A_{0}A_{4}'A_{3}A_{2}A_{1}.\n$$\n每个乘积项对应一个从有效邻接中导出的质蕴含项，其中 o 的单项是必需的。无法进一步化简，因为 o 没有相邻的元音最小项，并且移除这三项中的任何一项都会导致至少一个元音未被覆盖。", "answer": "$$\\boxed{A_{6}A_{5}A_{0}A_{4}'A_{2}'A_{1}' + A_{6}A_{5}A_{0}A_{3}'A_{2}A_{1}' + A_{6}A_{5}A_{0}A_{4}'A_{3}A_{2}A_{1}}$$", "id": "1909416"}]}