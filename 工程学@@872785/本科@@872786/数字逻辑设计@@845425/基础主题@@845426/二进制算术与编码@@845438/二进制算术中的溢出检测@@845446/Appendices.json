{"hands_on_practices": [{"introduction": "为了掌握溢出的概念，我们首先从一个基本问题开始。这个练习旨在帮助你通过直观的十进制计算，来判断一个定长补码系统中的加法运算是否会超出其表示范围。通过解决这个问题 [@problem_id:1950184]，你将对溢出的核心定义——即运算结果落在可表示范围之外——建立起坚实的理解。", "problem": "一个简单的处理器核心被设计用来处理传感器数据。它专门使用 5 位二进制补码表示法来处理有符号整数。在此系统中，可表示的数字范围为 $-16$ 到 $+15$。该核心的算术逻辑单元 (ALU) 对两个 5 位操作数 $A$ 和 $B$ 执行加法运算。如果加法运算的真实结果超出了可表示的范围，就会发生溢出。\n\n给定几对十进制表示的操作数 $(A, B)$。您的任务是判断在下列加法运算 $A + B$ 中，哪一个会在这个 5 位二进制补码系统中导致溢出。\n\nA) $A = 12, B = -5$\nB) $A = -8, B = -7$\nC) $A = 9, B = 6$\nD) $A = 10, B = 6$\nE) $A = -15, B = 15$", "solution": "在一个字长为 $n$ 的二进制补码系统中，可表示的范围是从 $-2^{n-1}$ 到 $2^{n-1}-1$。对于 $n=5$，该范围是\n$$\n[-2^{4},\\,2^{4}-1]=[-16,\\,15].\n$$\n当真实整数和 $r=A+B$ 落在此区间之外时，加法会发生溢出。等价地，只有当两个同符号操作数相加，其结果的量值超出了可表示的界限时，才会发生溢出，这表现为结果的符号与操作数的符号不同。\n\n通过计算真实和并与该区间进行比较来评估每个选项：\n- A) $12+(-5)=7$，符号相反且 $7\\in[-16,15]$；无溢出。\n- B) $-8+(-7)=-15$，均为负数且 $-15\\in[-16,15]$；无溢出。\n- C) $9+6=15$，均为正数且 $15\\in[-16,15]$；无溢出。\n- D) $10+6=16$，均为正数且 $16\\notin[-16,15]$；发生溢出。\n- E) $-15+15=0$，符号相反且 $0\\in[-16,15]$；无溢出。\n\n因此，只有选项 D 会导致溢出。", "answer": "$$\\boxed{D}$$", "id": "1950184"}, {"introduction": "在理解了溢出的基本定义后，下一步是学习如何在二进制层面直接检测它，就像处理器在执行运算时所做的那样。这个练习模拟了一个微处理器累加器中的连续加法操作，要求你应用一个关键的硬件检测法则：当两个相同符号的数相加时，结果的符号不应与操作数相反。通过这个实践 [@problem_id:1950214]，你将学会直接分析二进制位来识别溢出，这是数字逻辑设计中的一项核心技能。", "problem": "一个8位微处理器使用补码表示有符号整数，它有一个记为 `ACC` 的累加寄存器。初始时，`ACC` 中的二进制值为 $A = 01101101_2$。执行一个小程序，该程序包含以下两个顺序执行的指令：\n\n1.  将值 $B = 01010110_2$ 加到 `ACC` 中。结果存回 `ACC`。\n2.  将值 $C = 10011011_2$ 加到 `ACC` 中。结果再次存回 `ACC`。\n\n基于这一系列操作，以下哪个陈述正确地描述了 `ACC` 寄存器中的最终二进制值，并指出了在哪一步加法中（如果有的话）发生了算术溢出？\n\nA. 最终 `ACC` 值：$01011110_2$，溢出：仅第一次加法。\n\nB. 最终 `ACC` 值：$11000011_2$，溢出：两次加法均无。\n\nC. 最终 `ACC` 值：$01011110_2$，溢出：两次加法都有。\n\nD. 最终 `ACC` 值：$10100001_2$，溢出：仅第二次加法。\n\nE. 最终 `ACC` 值：$11000011_2$，溢出：仅第一次加法。\n\nF. 最终 `ACC` 值：$01011110_2$，溢出：仅第二次加法。\n\nG. 最终 `ACC` 值：$01011110_2$，溢出：两次加法均无。", "solution": "我们使用8位补码算术，其中值的计算以 $2^{8}$ 为模，有符号数的范围是从 $-128$ 到 $127$。补码加法中发生溢出的充要条件是：两个加数有相同的符号位，而结果有相反的符号位（等价地，进入最高有效位的进位与产生的进位不同）。\n\n初始累加器值：$A=01101101_{2}$。第一次加法加上 $B=01010110_{2}$：\n$$\n01101101_{2}+01010110_{2}=11000011_{2}\\quad(\\text{mod }2^{8}).\n$$\n解释符号位：$A$ 和 $B$ 的符号位为 $0$（均为正数），而结果 $11000011_{2}$ 的符号位为 $1$（为负数）。因此，第一次加法导致有符号溢出。步骤1后，累加器的值为 $11000011_{2}$。\n\n第二次加法将 $C=10011011_{2}$ 加到当前累加器值上：\n$$\n11000011_{2}+10011011_{2}=1\\,01011110_{2}\\;\\Rightarrow\\;\\text{ACC}=01011110_{2}\\quad(\\text{discarding carry out}).\n$$\n这里两个加数 $11000011_{2}$ 和 $10011011_{2}$ 的符号位均为 $1$（均为负数），而结果 $01011110_{2}$ 的符号位为 $0$（为正数）。因此，第二次加法也导致有符号溢出。\n\n因此，最终累加器值为 $01011110_{2}$，并且两次加法都发生了溢出，这对应于选项C。", "answer": "$$\\boxed{C}$$", "id": "1950214"}, {"introduction": "前面的练习让你学会了如何识别溢出，现在我们将挑战升级：设计一个能够自动检测溢出的系统。这个高级实践将算术理论与实际的数字电路设计联系起来，要求你为串行加法器设计一个有限状态机（FSM）。通过构建这个状态机 [@problem_id:1950178]，你将把溢出检测的规则（最高位的进位输入与进位输出不同）转化为一个时序逻辑电路，这体现了从理论到应用的关键一步。", "problem": "一个专用的、资源受限的处理器设计有一个串行算术逻辑单元 (ALU)。该 ALU 对两个以二进制补码格式表示的 $n$ 位整数 $A$ 和 $B$ 进行操作。这些数字从最低有效位 (LSB) 开始逐位处理。在每个时钟周期 $i$（从 LSB 的 $i=0$ 到最高有效位 MSB 的 $i=n-1$），ALU 的 1 位全加器接收输入位 $a_i$ 和 $b_i$，以及来自前一级的输入进位 $c_i$，并计算出一个和位 $s_i$ 和一个输出进位 $c_{i+1}$。对于第一级，输入进位 $c_0$ 为 0。\n\n您的任务是指定一个米利型有限状态机 (FSM) 的行为，该 FSM 与全加器协同工作以检测算术溢出。该 FSM 必须生成一个单位输出 $V$。在对应于 MSB ($i=n-1$) 的时钟周期，$V$ 的值必须为 1（如果 $n$ 位加法期间发生了溢出），否则为 0。FSM 的状态转换与每对比特对的处理同步。\n\n该 FSM 有两个状态：\n-   $S_0$：表示到当前位片的输入进位 $c_i$ 为 0 的情况。\n-   $S_1$：表示到当前位片的输入进位 $c_i$ 为 1 的情况。\n\n在周期 $i$ 时，FSM 的输入是数据位 $a_i$ 和 $b_i$。FSM 从状态 $S_0$ 开始。\n\n以下哪个状态转换和输出表正确描述了这个用于检测溢出的米利型 FSM？\n\nA.\n| 当前状态 | 输入 ($a_i, b_i$) | 下一状态 | 输出 ($V_i$) |\n|:-------------:|:-----------------:|:----------:|:--------------:|\n|      $S_0$      |        00         |    $S_0$     |        0       |\n|      $S_0$      |        01         |    $S_0$     |        0       |\n|      $S_0$      |        10         |    $S_0$     |        0       |\n|      $S_0$      |        11         |    $S_1$     |        1       |\n|      $S_1$      |        00         |    $S_0$     |        1       |\n|      $S_1$      |        01         |    $S_1$     |        0       |\n|      $S_1$      |        10         |    $S_1$     |        0       |\n|      $S_1$      |        11         |    $S_1$     |        0       |\n\nB.\n| 当前状态 | 输入 ($a_i, b_i$) | 下一状态 | 输出 ($V_i$) |\n|:-------------:|:-----------------:|:----------:|:--------------:|\n|      $S_0$      |        00         |    $S_0$     |        0       |\n|      $S_0$      |        01         |    $S_0$     |        0       |\n|      $S_0$      |        10         |    $S_0$     |        0       |\n|      $S_0$      |        11         |    $S_1$     |        0       |\n|      $S_1$      |        00         |    $S_0$     |        1       |\n|      $S_1$      |        01         |    $S_1$     |        1       |\n|      $S_1$      |        10         |    $S_1$     |        1       |\n|      $S_1$      |        11         |    $S_1$     |        1       |\n\nC.\n| 当前状态 | 输入 ($a_i, b_i$) | 下一状态 | 输出 ($V_i$) |\n|:-------------:|:-----------------:|:----------:|:--------------:|\n|      $S_0$      |        00         |    $S_0$     |        0       |\n|      $S_0$      |        01         |    $S_0$     |        0       |\n|      $S_0$      |        10         |    $S_0$     |        0       |\n|      $S_0$      |        11         |    $S_1$     |        1       |\n|      $S_1$      |        00         |    $S_0$     |        0       |\n|      $S_1$      |        01         |    $S_1$     |        1       |\n|      $S_1$      |        10         |    $S_1$     |        1       |\n|      $S_1$      |        11         |    $S_1$     |        1       |\n\nD.\n| 当前状态 | 输入 ($a_i, b_i$) | 下一状态 | 输出 ($V_i$) |\n|:-------------:|:-----------------:|:----------:|:--------------:|\n|      $S_0$      |        00         |    $S_0$     |        1       |\n|      $S_0$      |        01         |    $S_1$     |        0       |\n|      $S_0$      |        10         |    $S_1$     |        0       |\n|      $S_0$      |        11         |    $S_1$     |        1       |\n|      $S_1$      |        00         |    $S_0$     |        1       |\n|      $S_1$      |        01         |    $S_0$     |        0       |\n|      $S_1$      |        10         |    $S_0$     |        0       |\n|      $S_1$      |        11         |    $S_1$     |        1       |", "solution": "我们每周期使用一个 1 位全加器串行地对两个二进制补码数进行相加。让 FSM 的状态对当前位片的输入进位进行编码：$S_{0}$ 表示 $c_{i}=0$，$S_{1}$ 表示 $c_{i}=1$。全加器的输出进位是\n$$\nc_{i+1}=a_{i}b_{i}+a_{i}c_{i}+b_{i}c_{i}.\n$$\n因此，下一状态函数由 $c_{i+1}$ 决定：\n- 如果 $c_{i}=0$（状态 $S_{0}$），则 $c_{i+1}=a_{i}b_{i}$。因此，从 $S_{0}$ 出发，只有当 $(a_{i},b_{i})=(1,1)$ 时，下一状态才是 $S_{1}$；否则保持在 $S_{0}$。\n- 如果 $c_{i}=1$（状态 $S_{1}$），则 $c_{i+1}=a_{i}+b_{i}$（逻辑或）。因此，从 $S_{1}$ 出发，只有当 $(a_{i},b_{i})=(0,0)$ 时，下一状态才是 $S_{0}$；否则保持在 $S_{1}$。\n\n在二进制补码加法中，MSB 处的溢出标志满足\n$$\nV_{n-1}=c_{n-1}\\oplus c_{n}.\n$$\n一个米利型 FSM 可以在周期 $i$ 使用以下公式生成这个标志\n$$\nV_{i}=c_{i}\\oplus c_{i+1},\n$$\n因为 $c_{i+1}$ 是当前状态和输入的函数。\n\n根据状态和输入计算输出：\n- 对于 $S_{0}$ ($c_{i}=0$): $V_{i}=0\\oplus c_{i+1}=c_{i+1}=a_{i}b_{i}$。因此，当 $(a_{i},b_{i})$ 分别为 $00,01,10,11$ 时，得到的 $V_{i}$ 分别为 $0,0,0,1$。\n- 对于 $S_{1}$ ($c_{i}=1$): $V_{i}=1\\oplus c_{i+1}=1\\oplus(a_{i}+b_{i})$。因此，当 $(a_{i},b_{i})$ 分别为 $00,01,10,11$ 时，得到的 $V_{i}$ 分别为 $1,0,0,0$。\n\n将推导出的下一状态和输出行为相结合，与选项 A 中的表格完全匹配，而与其他选项（其输出和/或转换不正确）不同。", "answer": "$$\\boxed{A}$$", "id": "1950178"}]}