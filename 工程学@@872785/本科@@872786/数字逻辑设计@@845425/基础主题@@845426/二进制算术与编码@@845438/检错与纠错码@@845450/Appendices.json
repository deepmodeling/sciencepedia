{"hands_on_practices": [{"introduction": "掌握纠错码理论的第一步是学习如何构建它们。这项基础练习将指导您完成为一个给定的4位数据字构建一个系统的(7,4)汉明码的全过程。通过亲手计算校验位并将它们与数据位结合，您将加深对如何通过增加冗余来保护数据完整性的理解，这是所有纠错方案的核心原则。[@problem_id:1933155]", "problem": "一个用于简化存储系统的数字控制器，其任务是使用系统（7,4）汉明码将4位数据字编码为7位码字，以实现单位错误纠正。7位码字的结构由比特位置 $c_7, c_6, c_5, c_4, c_3, c_2, c_1$ 定义，其中 $c_7$ 是最高有效位。\n\n比特的位置分配如下：\n- 奇偶校验位，记为 $p_1, p_2, p_4$，分别位于位置 $c_1, c_2, c_4$。这些位置对应于2的幂次方（即 $2^0, 2^1, 2^2$）。\n- 数据位，记为 $d_7, d_6, d_5, d_3$，分别位于剩余的位置 $c_7, c_6, c_5, c_3$。\n\n当一个表示为 $b_4 b_3 b_2 b_1$（其中 $b_4$ 是最高有效位）的4位数据字需要编码时，它会按如下方式映射到码字中的数据位位置：$d_7 = b_4$，$d_6 = b_3$，$d_5 = b_2$，以及 $d_3 = b_1$。\n\n奇偶校验位的值被计算以确保特定比特集合的偶校验。计算使用异或（XOR）运算，用符号 $\\oplus$ 表示。奇偶校验方程为：\n- $p_1 = d_3 \\oplus d_5 \\oplus d_7$\n- $p_2 = d_3 \\oplus d_6 \\oplus d_7$\n- $p_4 = d_5 \\oplus d_6 \\oplus d_7$\n\n给定4位数据字 `1011`，确定相应的7位系统汉明码字。请将您的答案表示为一个从 $c_7$ 到 $c_1$ 的7位二进制字符串。", "solution": "给定的4位数据字为 $b_{4}b_{3}b_{2}b_{1}=1011$。根据映射关系 $d_{7}=b_{4}$，$d_{6}=b_{3}$，$d_{5}=b_{2}$ 和 $d_{3}=b_{1}$，我们得到\n$$\nd_{7}=1,\\quad d_{6}=0,\\quad d_{5}=1,\\quad d_{3}=1.\n$$\n用于偶校验的奇偶校验位通过给定的异或方程计算得出：\n$$\np_{1}=d_{3}\\oplus d_{5}\\oplus d_{7}=1\\oplus 1\\oplus 1=(1\\oplus 1)\\oplus 1=0\\oplus 1=1,\n$$\n$$\np_{2}=d_{3}\\oplus d_{6}\\oplus d_{7}=1\\oplus 0\\oplus 1=(1\\oplus 0)\\oplus 1=1\\oplus 1=0,\n$$\n$$\np_{4}=d_{5}\\oplus d_{6}\\oplus d_{7}=1\\oplus 0\\oplus 1=(1\\oplus 0)\\oplus 1=1\\oplus 1=0.\n$$\n将这些位放入码字位置 $c_{7},c_{6},c_{5},c_{4},c_{3},c_{2},c_{1}$，其中 $c_{7}=d_{7}$，$c_{6}=d_{6}$，$c_{5}=d_{5}$，$c_{4}=p_{4}$，$c_{3}=d_{3}$，$c_{2}=p_{2}$，$c_{1}=p_{1}$，我们得到\n$$\n(c_{7},c_{6},c_{5},c_{4},c_{3},c_{2},c_{1})=(1,0,1,0,1,0,1).\n$$\n这满足了规定集合上的偶校验：$c_{1}\\oplus c_{3}\\oplus c_{5}\\oplus c_{7}=0$，$c_{2}\\oplus c_{3}\\oplus c_{6}\\oplus c_{7}=0$ 以及 $c_{4}\\oplus c_{5}\\oplus c_{6}\\oplus c_{7}=0$，从而证实了其正确性。", "answer": "$$\\boxed{1010101}$$", "id": "1933155"}, {"introduction": "虽然汉明码能有效地纠正单个比特错误，但了解其局限性也同样重要。本练习超越了简单的编码，探讨了一种称为“混叠”的现象，即某些双比特错误会产生与单比特错误相同的伴随式（syndrome），从而导致误纠。通过设计一个逻辑电路来检测一个特定的混叠情况，您将更深入地洞察汉明码的代数结构及其纠错能力的边界。[@problem_id:1933128]", "problem": "一个数字通信系统采用标准的系统(7,4)汉明码来防止单比特错误。在该方案中，构造一个7比特的码字 $C = (c_1, c_2, c_3, c_4, c_5, c_6, c_7)$，其中比特位置从左到右编号为1到7。对于任何有效码字，必须计算为0的奇偶校验方程定义如下：\n- 校验 1: $c_1 \\oplus c_3 \\oplus c_5 \\oplus c_7 = 0$\n- 校验 2: $c_2 \\oplus c_3 \\oplus c_6 \\oplus c_7 = 0$\n- 校验 3: $c_4 \\oplus c_5 \\oplus c_6 \\oplus c_7 = 0$\n\n在接收到7比特字 $R = (r_1, r_2, r_3, r_4, r_5, r_6, r_7)$ 后，会计算出一个伴随式 $S = (s_2, s_1, s_0)$。伴随式比特 $s_0, s_1, s_2$ 分别是接收到的字 $R$ 经过奇偶校验1、2和3的结果。伴随式的二进制值 $(s_2 s_1 s_0)_2$ 指示了单比特错误的位置。例如，伴随式为 $(1,0,1)$ 表示在比特位置5上存在错误。\n\n虽然该码可以纠正所有单比特错误，但某些双比特错误会产生一个与单比特错误相同的非零伴随式，从而导致错误纠正。这种现象被称为混叠（aliasing）。\n\n你的任务是设计一个专用检测器。构建一个组合逻辑电路，该电路以接收到的字 $R$ 的7个比特作为其输入。该电路的单个输出 $F$ 必须为逻辑'1'，当且仅当以下两个条件同时满足：\n1. 接收到的字 $R$ 本身是一个双比特错误模式，意味着其汉明权重恰好为2。\n2. 这个双比特模式产生的伴随式与位置5上的单比特错误所产生的伴随式相同。\n\n请提供输出 $F$ 关于输入比特 $r_1, \\dots, r_7$ 的最小化布尔表达式。你的表达式应为积之和形式。使用加号 `+` 表示逻辑或运算，并列表示逻辑与运算，上划线表示逻辑非运算（例如，$A\\overline{B} + C$）。", "solution": "设 $H$ 为与给定奇偶校验一致的 $3\\times 7$ 奇偶校验矩阵。对于任何接收到的字 $R=C+E$ (mod $2$)，其伴随式为\n$$\nS=H R^{T}=H(C+E)^{T}=H C^{T}+H E^{T}=0+H E^{T}=H E^{T}.\n$$\n因此，伴随式仅取决于错误模式 $E$。对于位置 $i$ 上的单比特错误，其错误向量为 $E=\\mathbf{e}_{i}$，伴随式等于 $H$ 的第 $i$ 列。根据给定的校验，\n- 校验1涉及位置 $\\{1,3,5,7\\}$，因此对于 $i\\in\\{1,3,5,7\\}$，$s_{0}=1$。\n- 校验2涉及位置 $\\{2,3,6,7\\}$，因此对于 $i\\in\\{2,3,6,7\\}$，$s_{1}=1$。\n- 校验3涉及位置 $\\{4,5,6,7\\}$，因此对于 $i\\in\\{4,5,6,7\\}$，$s_{2}=1$。\n\n因此，位置 $i$ 上的单比特错误产生的伴随式 $(s_2s_1s_0)_2$ 的值等于 $i$。\n\n在位置 $i$ 和 $j$ 上的双比特错误有 $E=\\mathbf{e}_{i}+\\mathbf{e}_{j}$ (mod $2$)，因此\n$$\nS=H(\\mathbf{e}_{i}+\\mathbf{e}_{j})^{T}=H\\mathbf{e}_{i}^{T}+H\\mathbf{e}_{j}^{T},\n$$\n即两个单比特错误伴随式的异或。我们需要这个双比特错误的伴随式等于位置5的单比特错误伴随式，即 $101$。因此，我们需要列 $i$ 和 $j$ 满足\n$$\n\\text{col}(i)\\oplus \\text{col}(j)=\\text{col}(5)=101.\n$$\n等价地，以二进制索引形式表示，$i\\oplus j=5$。枚举可得出唯一的无序解\n$$\n\\{i,j\\}\\in\\{\\{1,4\\},\\{2,7\\},\\{3,6\\}\\}.\n$$\n条件1（汉明权重恰好为 $2$）意味着所有其他比特必须为 $0$。因此，当且仅当 $R$ 等于这三个权重为2的模式之一时，所需的积之和表达式为1，该表达式为\n$$\nF=r_{1}r_{4}\\overline{r_{2}}\\overline{r_{3}}\\overline{r_{5}}\\overline{r_{6}}\\overline{r_{7}} + r_{2}r_{7}\\overline{r_{1}}\\overline{r_{3}}\\overline{r_{4}}\\overline{r_{5}}\\overline{r_{6}} + r_{3}r_{6}\\overline{r_{1}}\\overline{r_{2}}\\overline{r_{4}}\\overline{r_{5}}\\overline{r_{7}}.\n$$\n这三个最小项是孤立的（在精确权重约束下没有邻接关系），因此这是最小化的积之和形式。", "answer": "$$\\boxed{r_{1}r_{4}\\overline{r_{2}}\\overline{r_{3}}\\overline{r_{5}}\\overline{r_{6}}\\overline{r_{7}}+r_{2}r_{7}\\overline{r_{1}}\\overline{r_{3}}\\overline{r_{4}}\\overline{r_{5}}\\overline{r_{6}}+r_{3}r_{6}\\overline{r_{1}}\\overline{r_{2}}\\overline{r_{4}}\\overline{r_{5}}\\overline{r_{7}}}$$", "id": "1933128"}, {"introduction": "并非所有错误都是随机的；某些系统，如内存设备，更容易出现所有比特翻转方向相同的“单向错误”。这个练习介绍了一种为这类特定错误模型优化的伯格码（Berger code）。通过分析接收到的码字并计算其伴随式，您将学会如何识别单向错误的类型（$1 \\to 0$ 或 $0 \\to 1$），从而揭示一种不同于汉明码、基于计数而非距离的纠错码设计哲学。[@problem_id:1933130]", "problem": "一个高可靠性的数字系统采用可分伯格码（separable Berger code）来检测8位数据字传输过程中的单向错误。在此具体实现中，一个数据字 $D = D_7D_6...D_0$ 附加一个4位的校验字 $C = C_3C_2C_1C_0$。校验字 $C$ 是数据字 $D$ 中零的总数的4位无符号二进制表示。这个完整的12位结构构成了传输的码字 $W = D_7D_6...D_0C_3C_2C_1C_0$。\n\n单向错误是指传输的码字中有一个或多个位发生翻转，但所有翻转都是同一类型（即，全是 $1 \\to 0$ 翻转，或全是 $0 \\to 1$ 翻转，而不是两者的混合）的事件。\n\n接收端的解码器计算一个错误伴随式 $S$ 来检查错误。对于任何接收到的12位字 $W'=(D', C')$，伴随式定义为以下整数差：\n$$S = \\text{value}(C') - N_0(D')$$\n其中 $\\text{value}(C')$ 是接收到的校验位 $C'$ 所代表的无符号整数值，而 $N_0(D')$ 是接收到的数据字 $D'$ 中零位的总数。\n\n解码器接收到两个12位字：\n- $W_1 = 011100000000$\n- $W_2 = 111010110101$\n\n已知其中一个字是由一个有效的码字经历了一次单向 $1 \\to 0$ 错误事件产生的，而另一个字是由一个有效的码字经历了一次单向 $0 \\to 1$ 错误事件产生的。\n\n基于对每个接收到的字的错误伴随式的分析，确定哪个字对应哪种类型的单向错误。\n\nA) $W_1$ 由 $1 \\to 0$ 错误产生；$W_2$ 由 $0 \\to 1$ 错误产生。\n\nB) $W_1$ 由 $0 \\to 1$ 错误产生；$W_2$ 由 $1 \\to 0$ 错误产生。\n\nC) $W_1$ 和 $W_2$ 都由 $1 \\to 0$ 错误产生。\n\nD) $W_1$ 和 $W_2$ 都由 $0 \\to 1$ 错误产生。\n\nE) 伴随式的定义不足以区分这两种错误类型。", "solution": "该编码是具有8个数据位和4个校验位的可分伯格码。对于任何接收到的字 $W'=(D',C')$，解码器计算伴随式\n$$\nS=\\text{value}(C')-N_{0}(D'),\n$$\n其中 $\\text{value}(C')$ 是4个校验位所代表的无符号整数值，而 $N_{0}(D')$ 是8个数据位中零的数量。\n\n假设传输的码字是有效的，因此 $\\text{value}(C)=N_{0}(D)$。考虑单向错误的影响：\n\n- 如果错误是 $1 \\to 0$ 类型，那么在数据部分，有 $t_{d}\\geq 0$ 个1翻转为0，所以 $N_{0}(D')=N_{0}(D)+t_{d}$。在校验部分，只有1能翻转为0；设 $C$ 的数值总减少量为 $x\\geq 0$，所以 $\\text{value}(C')=\\text{value}(C)-x$。因此\n$$\nS=(\\text{value}(C)-x)-(N_{0}(D)+t_{d})=-(x+t_{d})  0,\n$$\n因为发生了错误，意味着 $x+t_{d}0$。\n\n- 如果错误是 $0 \\to 1$ 类型，那么在数据部分，有 $t_{d}\\geq 0$ 个0翻转为1，所以 $N_{0}(D')=N_{0}(D)-t_{d}$。在校验部分，只有0能翻转为1；设 $C$ 的数值总增加量为 $y\\geq 0$，所以 $\\text{value}(C')=\\text{value}(C)+y$。因此\n$$\nS=(\\text{value}(C)+y)-(N_{0}(D)-t_{d})=y+t_{d}>0,\n$$\n因为发生了错误，意味着 $y+t_{d}0$。\n\n因此，$S0$ 表示一个 $1 \\to 0$ 错误，而 $S>0$ 表示一个 $0 \\to 1$ 错误。\n\n现在为每个接收到的字计算 $S$。\n\n对于 $W_{1}=011100000000$，将其分割为 $D'=\\text{前8位}=01110000$ 和 $C'=\\text{后4位}=0000$。计算 $D'$ 中的零的数量：$01110000$ 有 $5$ 个零，所以 $N_{0}(D')=5$。$C'$ 的值是 $\\text{value}(0000)=0$。因此\n$$\nS_{1}=0-5=-50,\n$$\n所以 $W_{1}$ 是由一个 $1 \\to 0$ 错误产生的。\n\n对于 $W_{2}=111010110101$，将其分割为 $D'=\\text{前8位}=11101011$ 和 $C'=\\text{后4位}=0101$。计算 $D'$ 中的零的数量：$11101011$ 有 $2$ 个零，所以 $N_{0}(D')=2$。$C'$ 的值是 $\\text{value}(0101)=5$。因此\n$$\nS_{2}=5-2=3>0,\n$$\n所以 $W_{2}$ 是由一个 $0 \\to 1$ 错误产生的。\n\n因此，$W_{1}$ 对应一个 $1 \\to 0$ 错误，$W_{2}$ 对应一个 $0 \\to 1$ 错误。", "answer": "$$\\boxed{A}$$", "id": "1933130"}]}