## 引言
在[数字逻辑设计](@entry_id:141122)的广阔领域中，存储器通常被视为被动的数据存储单元。然而，某些存储器类型，特别是可编程[只读存储器](@entry_id:175074)（PROM），扮演着远超数据存储的动态角色。许多初学者仅将其理解为“只能读取、不可写入”的存储芯片，从而忽略了其作为强大、通用的[逻辑实现](@entry_id:173626)工具的核心价值。本文旨在填补这一认知空白，揭示PROM如何从一个简单的[存储阵列](@entry_id:174803)，转变为能够实现任意复杂组合逻辑电路乃至整个系统控制核心的关键构件。在接下来的章节中，我们将首先深入探讨PROM的**原理与机制**，从其基本结构和查找表本质出发，揭示其工作方式。随后，我们将在**应用与跨学科联系**一章中，探索PROM在[计算机体系结构](@entry_id:747647)、数字信号处理等领域的广泛实际应用。最后，通过一系列**动手实践**练习，您将有机会亲手将理论知识应用于解决具体的设计问题，从而真正掌握PROM的强大功能。

## 原理与机制

本章将深入探讨可编程[只读存储器](@entry_id:175074)（PROM）的核心工作原理及其在[数字系统设计](@entry_id:168162)中的应用机制。我们将从其基本结构出发，揭示其作为通用逻辑单元的强大能力，并进一步探讨其在系统级设计中的实际考量，包括时序性能和物理限制。

### PROM的基本结构与容量

从最根本的层面看，**[只读存储器](@entry_id:175074)（Read-Only Memory, ROM）**可以被理解为一个**[查找表](@entry_id:177908)（Look-Up Table, LUT）**。它的核心功能是为每一个输入的**地址（address）**，提供一个预先存储好的**数据字（data word）**作为输出。PROM作为ROM的一种，其特殊之处在于它允许用户在制造完成后进行一次性的编程。

一个PROM芯片的结构由两个关键参数定义：**地址线（address lines）**的数量和**数据线（data lines）**的数量。

- **地址线**决定了PROM可以唯一寻址的存储单元数量。若一个PROM有 $N_a$ 条地址线，由于每条线可以取值为逻辑0或逻辑1，总共可以形成 $2^{N_a}$ 种不同的输入组合。每一种组合都对应一个唯一的存储位置。因此，该PROM拥有 $2^{N_a}$ 个**字（words）**或存储单元。例如，一个用于实现具有5个输入变量的逻辑功能的PROM，其输入变量将连接到地址线上，因此它必须包含 $2^5 = 32$ 个不同的存储位置 [@problem_id:1955512]。

- **数据线**决定了每个存储单元可以存储的数据位的数量，即**字宽（word width）**。若一个PROM有 $N_d$ 条数据线，则每个地址对应的数据字就有 $N_d$ 位。

因此，一个具有 $N_a$ 条地址线和 $N_d$ 条数据线的PROM，其总**存储容量（storage capacity）** $C$（以比特为单位）可以通过以下公式计算：

$C = 2^{N_a} \times N_d$

这个公式是分析和选择PROM器件的基础。例如，一个用于字符生成的PROM芯片，若配备了6条地址线和8条数据线，则其总容量为 $2^6 \times 8 = 64 \times 8 = 512$ 比特 [@problem_id:1955531]。反之，如果我们知道一个PROM的总容量和它的数据字宽，我们也可以推断出它可以支持的输入变量数量。假设一个PROM的总容量为32768比特，数据输出宽度为16位，那么它可以提供的存储字数量为 $32768 / 16 = 2048$ 个。为了用这个PROM实现一个逻辑功能，输入变量的数量 $n$ 必须满足 $2^n \le 2048$。由于 $2048 = 2^{11}$，该PROM最多可以实现一个有11个输入变量的逻辑功能 [@problem_id:1955496]。

在实际系统中，地址通常以二进制形式提供，但在文档和分析中，为了方便起见，常使用[十六进制](@entry_id:176613)或十[进制](@entry_id:634389)表示。例如，在一个有8条地址线（$A_7$ 到 $A_0$）的系统中，如果逻辑分析仪捕获到的地址值为[十六进制](@entry_id:176613)的 $5A$，我们需要将其转换为十进制来理解其在地址空间中的确切位置。转换方法如下：

$N_{10} = 5 \times 16^1 + 10 \times 16^0 = 80 + 10 = 90$

这意味着系统正在访问第90号存储单元（地址从0开始计数）[@problem_id:1955477]。

### 作为通用组合逻辑单元的PROM

PROM最强大和最吸引人的特性之一是它可以实现**任何**具有特定输入和输出数量的**[组合逻辑](@entry_id:265083)函数（combinational logic function）**。这一特性源于其[查找表](@entry_id:177908)的内在本质。

任何一个组合逻辑函数都可以用一张**[真值表](@entry_id:145682)（truth table）**来完全定义。[真值表](@entry_id:145682)列出了所有可能的输入组合以及每种组合对应的输出值。这与PROM的结构形成了完美的对应关系：

- 函数的**输入变量**对应于PROM的**地址线**。一个有 $n$ 个输入变量的函数，其输入组合总数为 $2^n$。
- 函数的**输出值**对应于存储在PROM中相应地址的**数据**。一个有 $m$ 个输出变量的函数，其每个输入组合都对应一个 $m$ 位的输出值。

因此，要实现一个有 $n$ 个输入和 $m$ 个输出的[组合逻辑](@entry_id:265083)函数，我们只需要一个尺寸为 $2^n \times m$ 的PROM。这意味着该PROM需要有 $n$ 条地址线来接收函数输入，以及 $m$ 条数据线来产生函数输出。例如，实现一个4输入、3输出的逻辑电路，所需的最小PROM尺寸为 $2^4 \times 3$，即16个字，每个字3位宽 [@problem_id:1955495]。

编程过程就是将函数的真值表直接“烧录”到PROM中。对于真值表中的每一行，其输入组合形成一个地址，而该行的输出值就是应写入该地址的数据。

让我们通过一个具体例子来阐明这个过程 [@problem_id:1955478]。假设需要用一个 $8 \times 1$ 的PROM（即3条地址线 $A, B, C$ 和1条数据线 $F$）实现一个风扇控制逻辑。风扇在以下四种情况下启动（$F=1$）：
1. $\overline{A}\overline{B}C$ (输入为 001)
2. $\overline{A}B\overline{C}$ (输入为 010)
3. $A\overline{B}C$ (输入为 101)
4. $ABC$ (输入为 111)

我们将输入 $(A, B, C)$ 视为一个3位二[进制](@entry_id:634389)地址，其中 $A$ 为最高位（MSB），$C$ 为最低位（LSB）。我们可以构建如下真值表，其输出列 $F$ 直接定义了PROM在每个地址应存储的数据：

| 地址 (十进制) | 输入 (A, B, C) | 输出 F |
| :-------------: | :--------------: | :------: |
| 0               | 000              | 0        |
| 1               | 001              | 1        |
| 2               | 010              | 1        |
| 3               | 011              | 0        |
| 4               | 100              | 0        |
| 5               | 101              | 1        |
| 6               | 110              | 0        |
| 7               | 111              | 1        |

要编程这个PROM，我们只需将输出列 `01100101`（从地址0到7）的数据依次写入即可。如果将地址7的数据位视为MSB，地址0的数据位视为LSB，那么这8位数据 `10100110` 构成的二进制数，其十进制值为 $128 + 32 + 4 + 2 = 166$。通过这种方式，任何复杂的逻辑关系都可以被简化为一次性的存储器编程任务。

### 内部架构：与-或平面模型

为了更深入地理解PROM以及其他[可编程逻辑器件](@entry_id:178982)（PLD），我们可以使用一个更抽象的模型：**与-或平面（AND-OR plane）**结构。任何[布尔函数](@entry_id:276668)都可以表示为**积之和（Sum-of-Products, SOP）**形式。该结构直接映射了这种形式：一个**与门阵列（AND array）**用于生成乘积项（product terms），紧随其后的一个**[或门](@entry_id:168617)阵列（OR array）**将这些乘积项相加，得到最终的输出。

不同类型的PLD，其关键区别在于这两个阵列中哪些是固定的，哪些是可编程的。

- **PROM (Programmable Read-Only Memory):** 具有一个**固定的与平面**和一个**可编程的或平面**。其固定的与平面是一个完整的地址**解码器（decoder）**。对于 $n$ 个输入（地址线），该解码器会生成所有 $2^n$ 个**[最小项](@entry_id:178262)（minterms）**。每个[最小项](@entry_id:178262)是对应一个唯一输入组合的乘积项。由于所有可能的最小项都已生成，这个与平面是固定的、不可编程的。而或平面则是可编程的。对于每一个输出数据位，都有一个或门，设计者可以通过编程来选择哪些最小项的输出连接到这个[或门](@entry_id:168617)的输入。这本质上就是通过编程连接或断开内部的熔丝（fuses）或[浮栅晶体管](@entry_id:171866)。

- **PAL (Programmable Array Logic):** 与PROM相反，PAL具有一个**可编程的与平面**和一个**固定的或平面** [@problem_id:1954574]。用户可以编程与平面来生成所需的特定乘积项（不必是全部[最小项](@entry_id:178262)），但这组乘积项如何被[或门](@entry_id:168617)相加是固定的。例如，某个输出可能被硬连接为固定三个乘积项的或运算。这使得PAL在乘积项数量不多的情况下比PROM更高效。

- **PLA (Programmable Logic Array):** PLA提供了最大的灵活性，其**与平面和或平面都是可编程的** [@problem_id:1956870]。用户可以自由定义需要哪些乘积项，以及如何将这些乘积项组合成最终的输出。这允许乘积项在多个输出之间共享，从而实现更高效的逻辑压缩。

总结来说，PROM的“通用性”来自于其固定的与平面预先生成了所有可能的逻辑原子（[最小项](@entry_id:178262)），使得任何函数都可以通过在可编程的或平面中“挑选”和组合这些原子来构建。

### ROM的类型与编程机制

根据编程方式和时机的不同，ROM可以分为几类。理解它们的区别对于在工程实践中做出成本和灵活性兼顾的决策至关重要。

- **掩模ROM (Mask-Programmed ROM):** 这种ROM的数据内容是在芯片制造过程中，通过一个称为**光刻掩模（photolithographic mask）**的特定图形层永久性地“固化”到芯片结构中的。创建一套定制的掩模具有非常高昂的一次性投入成本（非经常性工程成本，NRE）。然而，一旦掩模制作完成，大规模生产的单位芯片成本极低。其内容一经制造便无法更改。

- **可编程ROM (PROM):** 这种ROM在出厂时所有存储位都处于一个默认状态（例如，全为'1'）。终端用户或工程师可以使用一个专门的设备——**PROM编程器（PROM programmer）**——对其进行一次性编程。编程过程通过施加高电压，选择性地“烧断”内部的微小熔丝或在[浮栅晶体管](@entry_id:171866)中注入[电荷](@entry_id:275494)，从而将特定位的状态永久地改变为相反状态（例如，变为'0'）。这个过程是不可逆的，因此PROM也被称为**一次性可编程（One-Time Programmable, OTP）**器件。

这两种ROM类型的成本结构和灵活性决定了它们在产品开发周期中的不同角色 [@problem_id:1956861]。

- 在**原型开发阶段**，固件和[逻辑设计](@entry_id:751449)可能需要多次修改和调试。此时，灵活性和快速迭代至关重要。使用Mask ROM是不可行的，因为每次修改都需要重新制造昂贵的掩模。PROM则非常适合此阶段：它没有高昂的启动成本，工程师可以快速在实验室内对新的芯片进行编程和测试。尽管每个PROM只能编程一次，但对于小批量的原型机（例如100台），其较高的单位成本仍然远低于Mask ROM的NRE成本。

- 在**大规模生产阶段**，设计已经最终确定，首要目标是最小化单位生产成本。此时，Mask ROM的优势就体现出来了。尽管有很高的初始NRE成本，但当生产量达到数十万甚至数百万片时，这笔成本被摊薄，使得其极低的单位芯片成本成为最具经济效益的选择。

因此，一个典型的产品开发策略是：在原型阶段使用PROM（或更灵活的[EPROM](@entry_id:174195)/[EEPROM](@entry_id:170779)）进行开发和验证，在设计冻结后转向Mask ROM进行大规模量产。

### 系统级设计与应用

除了作为独立的逻辑单元，PROM在更复杂的数字系统中也扮演着关键角色。

#### 存储器扩展

在许多设计中，单个PROM芯片的容量可能不足以满足需求。这时，可以通过将多个小容量PROM芯片组合起来，构建一个逻辑上统一的大容量存储系统。这种技术称为**存储器扩展（memory expansion）**。

实现存储器扩展的关键在于地址解码和[数据总线](@entry_id:167432)共享。让我们考虑一个使用两个 $32 \times 8$ PROM（PROM_0 和 PROM_1）来构建一个 $64 \times 8$ 存储系统的例子 [@problem_id:1955524]。

一个 $64 \times 8$ 的系统需要6条地址线（$A_5$ 到 $A_0$，因为 $2^6=64$）和8条数据线。而每个 $32 \times 8$ 的PROM只有5条地址线（$a_4$ 到 $a_0$，因为 $2^5=32$）。

扩展方案如下：
1.  **地址线连接：** 将系统[地址总线](@entry_id:173891)的低5位（$A_4$ 到 $A_0$）并行连接到两个PROM芯片的地址输入端。
2.  **芯[片选](@entry_id:173824)择：** 使用系统[地址总线](@entry_id:173891)的最高位（$A_5$）来区分这两个芯片。当 $A_5=0$ 时，我们希望选中PROM_0；当 $A_5=1$ 时，我们希望选中PROM_1。这通常通过一个**1-to-2解码器**实现。$A_5$作为解码器的选择输入，解码器的两个输出分别连接到两个PROM的**[片选](@entry_id:173824)（Chip Enable, CE）**引脚。[片选](@entry_id:173824)引脚通常是低电平有效的（表示为 $\overline{CE}$）。当 $\overline{CE}$ 为低电平时，芯片被激活；为高电平时，芯片被禁用，其数据输出端处于**[高阻态](@entry_id:163861)（high-impedance state）**。
3.  **[数据总线](@entry_id:167432)连接：** 将两个PROM芯片的8位数据输出线并联在一起，形成系统的8位[数据总线](@entry_id:167432)。由于在任何时刻只有一个芯片被[片选](@entry_id:173824)激活，另一个处于[高阻态](@entry_id:163861)，因此不会发生总线冲突。

在这样的系统中，当一个6位地址（例如十[进制](@entry_id:634389)的57）被提供时，系统首先根据最高位 $A_5$ 的值来决定激活哪个PROM。地址 $57_{10}$ 的二进制表示是 $111001_2$。因此 $A_5=1$，解码器将激活PROM_1并禁用PROM_0。然后，地址的低5位 $11001_2$（即十进制的25）被送到PROM_1的地址输入端。PROM_1就会将存储在其内部地址25的数据（例如 $4E_{16}$）输出到系统[数据总线](@entry_id:167432)上。

#### [时序逻辑](@entry_id:181558)与性能分析

PROM不仅限于实现[组合逻辑](@entry_id:265083)，它还可以作为**[同步时序电路](@entry_id:175242)（synchronous sequential circuit）**，如**[有限状态机](@entry_id:174162)（Finite State Machine, FSM）**中的核心部件。在FSM中，PROM可以被用作实现**[次态逻辑](@entry_id:164866)（next-state logic）**。

在一个典型的Moore型FSM中，当前状态存储在一个寄存器中。寄存器的输出（当前状态）作为地址输入到PROM中。PROM中预先存储了[状态转移表](@entry_id:163350)：每个地址（当前状态）对应的数据就是该状态下的下一个状态。PROM的输出（次态）再连接到[状态寄存器](@entry_id:755408)的输入端。在下一个时钟的上升沿，这个次态值将被锁存，成为新的当前状态。

在这种设计中，系统的最高运行速度（即最大时钟频率 $f_{max}$）受到信号在闭环路径中传播延迟的限制 [@problem_id:1955516]。一个时钟周期 $T_{clk}$ 必须足够长，以确保数据能在下一个[时钟沿](@entry_id:171051)到来之前稳定地从寄存器输出，经过PROM，并到达下一个寄存器的输入端。

关键时序参数包括：
- 寄存器的时钟到输出延迟 ($t_{clk-q}$): [时钟沿](@entry_id:171051)触发后，寄存器输出端出现有效数据所需的时间。
- PROM的访问时间 ($t_{acc}$): 地址输入稳定后，PROM数据输出端出现有效数据所需的时间。这相当于[组合逻辑](@entry_id:265083)的[传播延迟](@entry_id:170242) ($t_{pd,logic}$)。
- 寄存器的[建立时间](@entry_id:167213) ($t_{su}$): 数据在[时钟沿](@entry_id:171051)到来之前必须保持稳定的最短时间。

为了保证可靠操作，最小允许的[时钟周期](@entry_id:165839) $T_{min}$ 必须满足**[建立时间](@entry_id:167213)约束**：
$T_{clk} \ge t_{clk-q} + t_{acc} + t_{su}$

因此，最大时钟频率为：
$f_{max} = \frac{1}{T_{min}} = \frac{1}{t_{clk-q} + t_{acc} + t_{su}}$

例如，如果一个寄存器的 $t_{clk-q} = 2.5 \text{ ns}$，$t_{su} = 3.0 \text{ ns}$，而PROM的 $t_{acc} = 15.0 \text{ ns}$，则最小周期为 $2.5 + 15.0 + 3.0 = 20.5 \text{ ns}$。对应的最大[时钟频率](@entry_id:747385)为 $1 / (20.5 \times 10^{-9} \text{ s}) \approx 48.8 \text{ MHz}$。这个分析对于设计高性能数字系统至关重要。

### 物理限制：[逻辑冒险](@entry_id:174770)

尽管PROM在逻辑上是一个理想的[查找表](@entry_id:177908)，但其物理实现会带来一些非理想效应，其中最著名的是**[逻辑冒险](@entry_id:174770)（logic hazards）**。[逻辑冒险](@entry_id:174770)是指当输入发生变化时，电路的输出可能产生一个短暂的、不希望出现的毛刺（glitch）的现象。

**[静态冒险](@entry_id:163586)（static hazard）**是一种常见的[逻辑冒险](@entry_id:174770)。当单个输入变量改变，而理论上输出应保持稳定（恒为1或恒为0）时，输出却短暂地跳变到相反的状态再恢复。
- **[静态1冒险](@entry_id:261002) (Static-1 Hazard):** 输出本应保持为1，但瞬间跳变为0再恢复为1。
- **[静态0冒险](@entry_id:172764) (Static-0 Hazard):** 输出本应保持为0，但瞬间跳变为1再恢复为0。

在PROM中，[静态冒险](@entry_id:163586)的根源在于其内部的地址解码器存在传播延迟。当一个地址输入位改变时（例如，地址从 $011$ 变为 $111$），解码器内部需要从选中旧地址的逻辑路径切换到选中新地址的逻辑路径。由于物理路径延迟的微小差异，可能会出现一个极短的瞬间：旧地址已经被取消选择，而新地址还未被完全选择。在这个瞬间，没有任何存储单元被选中，导致PROM的数据输出可能短暂地变为一个默认值（通常是逻辑0）。

因此，如果一个输入转换（例如 $A \to B$）的起始[状态和](@entry_id:193625)结束状态，其对应的函数输出都应该是1（即 $F(A)=1$ 且 $F(B)=1$），那么这个转换就存在发生[静态1冒险](@entry_id:261002)的风险。

有趣的是，某些函数天生就不会在单变量输入变化时产生[静态冒险](@entry_id:163586) [@problem_id:1955539]。一个典型的例子是3输入[异或](@entry_id:172120)（XOR）函数 $F(A, B, C) = A \oplus B \oplus C$。异或函数的一个基本特性是，任何单个输入的改变都会导致输出的翻转。例如，$F(\overline{A}, B, C) = \overline{A} \oplus B \oplus C = \overline{F(A, B, C)}$。这意味着对于XOR函数，不存在任何单变量输入转换，使得输出在转换前后都保持为1。因此，用PROM实现 $A \oplus B \oplus C$ 时，不可能发生[静态1冒险](@entry_id:261002)。这个例子清晰地揭示了[静态冒险](@entry_id:163586)发生的根本条件：输出在逻辑上必须是稳定不变的。