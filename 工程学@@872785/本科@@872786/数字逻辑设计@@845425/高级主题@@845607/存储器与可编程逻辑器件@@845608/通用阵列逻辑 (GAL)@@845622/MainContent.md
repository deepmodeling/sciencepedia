## 引言
在[数字逻辑设计](@entry_id:141122)的广阔天地中，工程师们始终在寻求一种兼具灵活性、成本效益与开发效率的电路实现方案。在[标准逻辑](@entry_id:178384)门提供的基础功能与[专用集成电路](@entry_id:180670)（[ASIC](@entry_id:180670)）的高昂定制成本之间，存在着巨大的设计空间。早期的[可编程逻辑器件](@entry_id:178982)（PLD）虽然提供了解决方案，但其一次性可编程的特性给设计迭代和原型验证带来了诸多不便。通用阵列逻辑（Generic Array Logic, GAL）的出现，正是为了填补这一空白，它以其独特的可重复编程能力和灵活的架构，成为了数字设计领域的一块重要基石。

本文将带领读者全面、系统地掌握GAL技术。我们将分三个章节展开：首先，在“**原理与机制**”中，我们将深入剖析GAL的内部架构、基于[EEPROM](@entry_id:170779)的编程原理以及[输出逻辑宏单元](@entry_id:177990)（OLMC）的核心功能，揭示其如何实现复杂的逻辑功能。接着，在“**应用与跨学科连接**”中，我们将通过丰富的实例，展示如何利用GAL构建从简单译码器到复杂状态机、乃至高可靠性通信接口的各类电路，并探讨其在不同工程领域的角色。最后，“**动手实践**”部分将提供一系列精心设计的问题，引导您将理论付诸实践，巩固所学。

现在，让我们启程，首先深入探索GAL的内部世界，从它的基本原理与核心机制开始。

## 原理与机制

继前一章对[可编程逻辑器件](@entry_id:178982)（PLD）的概览之后，本章将深入探讨一类在[数字逻辑设计](@entry_id:141122)领域具有里程碑意义的器件——**通用阵列逻辑**（Generic Array Logic, GAL）。我们将系统地剖析GAL的内部结构、核心工作原理及其在实现[组合逻辑](@entry_id:265083)与[时序逻辑电路](@entry_id:167016)中的关键机制。

### GAL的基本架构

所有基于“与或”阵列的PLD，其核心思想都是为了以**[积之和](@entry_id:266697)**（Sum-of-Products, SOP）的形式实现[布尔函数](@entry_id:276668)。这通常通过一个**[与门](@entry_id:166291)阵列**（AND-plane）和一个**[或门](@entry_id:168617)阵列**（OR-plane）的级联结构来完成。[与门](@entry_id:166291)阵列负责从输入信号及其反相（[补码](@entry_id:756269)）中生成各个**乘积项**（product terms），而[或门](@entry_id:168617)阵列则将这些乘积项组合起来，形成最终的输出函数。不同类型的PLD，其关键区别在于这两个阵列的可编程性。

一个更早期的器件是**[可编程逻辑阵列](@entry_id:168853)**（Programmable Logic Array, PLA），其[与门](@entry_id:166291)阵列和或门阵列**均可编程**。这意味着设计者可以自由地定义每个乘积项的构成，并且可以自由地选择哪些乘积项被送入每一个或门。这种双重可编程性提供了极大的逻辑灵活性。

然而，GAL器件采用了另一种更为结构化的设计。GAL继承自其前身**[可编程阵列逻辑](@entry_id:172815)**（Programmable Array Logic, PAL），其核心架构特点是拥有一个**可编程的[与门](@entry_id:166291)阵列**和一个**固定的或门阵列**。具体来说，用户可以对与门阵列进行编程，以创建任意的乘积项；但是，每个输出的[或门](@entry_id:168617)能够接收的乘积项数量和来源是预先定义好的，不可更改。这种结构上的差异是区分GAL与PLA的关键所在 [@problem_id:1939699]。虽然牺牲了或门阵列的灵活性，但这种固定结构带来了时序性能上更强的确定性，我们将在后续章节中探讨这一优势。

#### 重复编程的物理基础

GAL中的“通用”（Generic）一词，其重要内涵在于**可重复编程性**。早期的PAL器件通常采用**熔丝**（fuse）或**反熔丝**（anti-fuse）技术。编程过程涉及对特定的金属连接点施加高电流，将其永久性地“烧断”（或接通）。这是一个物理上的、不可逆的过程，因此这类器件是**一次性可编程**（One-Time Programmable, OTP）的。这对于原型设计和调试阶段来说是极其不便的，因为任何[逻辑错误](@entry_id:140967)或设计变更都意味着需要废弃芯片并重新编程一颗新的。

GAL器件通过采用基于**[电可擦除可编程只读存储器](@entry_id:170779)**（Electrically Erasable Programmable Read-Only Memory, [EEPROM](@entry_id:170779)）的技术，彻底解决了这个问题。在其内部，逻辑连接的状态并非由物理熔丝决定，而是由[浮栅晶体管](@entry_id:171866)阵列中的[电荷](@entry_id:275494)状态决定。通过施加特定的电压，可以将[电荷](@entry_id:275494)隧穿并囚禁在绝缘的浮动栅极上，从而建立或断开一个逻辑连接。同样，通过不同的电压条件，可以移除这些[电荷](@entry_id:275494)，使器件恢复到“空白”状态。这个过程完全是电气的，可以重复数千次而不会损坏器件。正是这种基于[EEPROM](@entry_id:170779)的技术，赋予了GAL器件在开发阶段能够被反复擦除和重新配置的能力，极大地提高了设计迭代的效率和经济性 [@problem_id:1939737]。

#### 理解GAL的命名规范

为了快速识别一个GAL器件的基本能力，业界形成了一套标准的命名规范。以一个常见的型号**GAL22V10**为例，其名称中的数字和字母蕴含了丰富的架构信息：

*   **22**：这个数字代表器件的[与门](@entry_id:166291)阵列最多可以接收的**输入信号数量**。这些信号不仅包括专用的输入引脚，还包括从输出宏单元反馈回来的内部信号。
*   **V**：这个字母代表“**多功能**”（Versatile）或“可变”（Variable）。它表示器件的[输出逻辑宏单元](@entry_id:177990)（OLMC）是高度可配置的，例如可以选择输出是[组合逻辑](@entry_id:265083)还是寄存器逻辑，以及控制输出的极性等。
*   **10**：这个数字表示器件拥有的**[输出逻辑宏单元](@entry_id:177990)的数量**，即该器件最多可以产生10个独立的输出。

因此，`GAL22V10`描述了一个拥有最多22个阵列输入和10个多功能输出宏单元的器件。理解这一命名法有助于工程师在设计初期[快速选择](@entry_id:634450)合适的器件 [@problem_id:1939729]。

### 在GAL中实现组合逻辑

GAL实现逻辑功能的核心在于对其可编程[与门](@entry_id:166291)阵列的配置。每个[与门](@entry_id:166291)的输入端都连接到一个交叉点矩阵，该矩阵的“行”是所有可用的输入信号（例如，输入引脚 $A$、 $B$ 及其内部生成的反相信号 $\overline{A}$、$\overline{B}$），而“列”则通向不同的[与门](@entry_id:166291)，每个[与门](@entry_id:166291)产生一个乘积项。

在每个交叉点，都有一个[EEPROM](@entry_id:170779)单元。编程的过程就是设定这些单元的状态。我们可以通过一个简单的思想实验来理解这个过程 [@problem_id:1939710]：

假设我们需要在一个具有输入 $A$ 和 $B$ 的GAL器件上实现一个简单的反相器功能，即输出 $F = \overline{A}$。器件的输出 $F$ 由一个固定的[或门](@entry_id:168617)产生，其输入来自两个乘积项 $P_1$ 和 $P_2$，即 $F = P_1 + P_2$。为了实现 $F = \overline{A}$，我们只需让 $P_1 = \overline{A}$，并确保 $P_2$ 始终为逻辑 $0$。

乘积项 $P_1$ 由一个多输入与门生成，其输入端连接到 $A$、$\overline{A}$、 $B$、$\overline{B}$ 四条输入线。编程规则如下：
*   如果一个[交叉点](@entry_id:147634)单元被**编程**（Programmed），则对应的输入线连接到[与门](@entry_id:166291)。
*   如果一个[交叉点](@entry_id:147634)单元被**擦除**（Erased），则对应的输入线断开。在[与门](@entry_id:166291)输入端，一个断开的输入等效于逻辑 $1$。

为了使 $P_1 = \overline{A}$，我们必须：
1.  **编程**连接 $\overline{A}$ 输入线的单元，从而将 $\overline{A}$ 纳入[与门](@entry_id:166291)运算。
2.  **擦除**连接 $A$、 $B$ 和 $\overline{B}$ 输入线的单元，使它们在[与门](@entry_id:166291)输入端表现为逻辑 $1$。

这样，$P_1$ 的逻辑表达式即为 $P_1 = 1 \cdot \overline{A} \cdot 1 \cdot 1 = \overline{A}$。同时，我们将 $P_2$ 对应的与门所有输入都配置为不生成有效乘积项（例如，同时连接一个变量及其反相，如 $A \cdot \overline{A}$，结果恒为 $0$），从而使 $P_2 = 0$。最终，输出 $F$ 就实现了 $F = P_1 + P_2 = \overline{A} + 0 = \overline{A}$。这个例子清晰地展示了通过选择性地连接输入信号到[与门](@entry_id:166291)，来构建任意乘积项的基本原理。

### [输出逻辑宏单元](@entry_id:177990) (OLMC)：灵活性的核心

如果说可编程与门阵列是GAL的“肌肉”，那么**[输出逻辑宏单元](@entry_id:177990)**（Output Logic Macrocell, OLMC）就是其“大脑”和“神经末梢”。OLMC是连接内部与或逻辑阵列与外部物理引脚的关键接口电路，它赋予了GAL极大的功能灵活性。一个典型的OLMC包含多个可配置的组件，使其能够适应组合逻辑和[时序逻辑](@entry_id:181558)的各种需求。

#### 简单模式与寄存器模式

OLMC最核心的配置选项是在**简单模式**（Simple Mode）和**寄存器模式**（Registered Mode）之间进行选择 [@problem_id:1939720]。

*   **简单模式**用于实现纯**[组合逻辑](@entry_id:265083)**电路。在此模式下，来自固定或门阵列的“积之和”逻辑信号直接（或经过极性控制后）驱动输出引脚。输出信号完全由当前输入信号的逻辑组合决定，不涉及任何状态存储。

*   **寄存器模式**则用于实现**[同步时序逻辑](@entry_id:168673)**电路。在此模式下，来自或门的信号并不直接输出，而是作为数据输入（D输入）被送入一个**[D型触发器](@entry_id:171740)**。该[触发器](@entry_id:174305)的输出（Q）在[时钟信号](@entry_id:174447)的有效边沿被更新，并驱动输出引脚。这使得OLMC能够存储一个状态位，是构建计数器、状态机等[时序电路](@entry_id:174704)的基础。

#### OLMC的关键特性

除了模式选择，OLMC还提供了其他几项关键的可配置特性：

1.  **输出极性控制** (Output Polarity Control)：大多数OLMC包含一个可编程的[异或门](@entry_id:162892)（XOR gate），一端连接来自与或阵列的逻辑结果，另一端连接到一个可编程的控制位。通过设置该控制位为 $0$ 或 $1$ ，可以使[异或门](@entry_id:162892)起到同相缓冲或反相器的作用。这使得输出可以是**高电平有效**（active-high）或**低电平有效**（active-low），而无需修改与门阵列中的逻辑。例如，若内部逻辑 $L = A \oplus B$，通过配置极性控制，最终输出 $Z$ 可以是 $Z = L$ 或 $Z = \overline{L}$ [@problem_id:1939704]。

2.  **[三态输出](@entry_id:164419)控制** (Tri-state Output Control)：每个OLMC的输出都通过一个**[三态缓冲器](@entry_id:165746)**连接到物理引脚。该缓冲器的使能端通常由一个专用的、独立的乘积项，即**[输出使能](@entry_id:169609)项**（Output Enable, OE term），来控制。当OE项为逻辑 $1$ 时，缓冲器被激活，输出引脚驱动高电平或低电平；当OE项为逻辑 $0$ 时，缓冲器进入**[高阻态](@entry_id:163861)**（High-Impedance, Hi-Z），相当于从电路上断开。这一特性至关重要，它不仅允许多个器件共享一个公共总线，还使得一个引脚可以在不同时间被配置为输出或输入。

3.  **反馈路径** (Feedback Path)：这是实现复杂逻辑，尤其是[时序逻辑](@entry_id:181558)的生命线。OLMC的输出信号（无论是组合输出还是寄存器输出）都有一条路径可以**反馈**回可编程的[与门](@entry_id:166291)阵列，作为其输入的一部分。对于[时序逻辑](@entry_id:181558)而言，这条反馈路径的意义尤为重大。在寄存器模式下，[触发器](@entry_id:174305)中存储的当前状态（Q输出）通过该路径被送回[与门](@entry_id:166291)阵列，从而参与到计算下一状态的逻辑中。这完美地实现了[状态机](@entry_id:171352)模型中的核心思想：**次态 = f(现态, 输入)**。没有这条反馈路径，现态信息将无法被逻辑阵列所用，也就无法构建状态机 [@problem_id:1939728]。

### 设计考量与架构局限性

虽然GAL功能强大且灵活，但在实际设计中，工程师必须理解其架构带来的特定优势和固有的局限性。

#### 固定[或门](@entry_id:168617)阵列的权衡

与PLA相比，GAL的固定或门阵列结构是一个重要的设计权衡。其主要优点在于**时序性能的可预测性**。在GAL中，从任何输入到任何输出的传播延迟 $t_{PD}$ 是一个固定的、与所实现的逻辑功能无关的常数。这是因为信号总是穿过一个可编程的[与门](@entry_id:166291)阵列和一个结构固定的[或门](@entry_id:168617)阵列。相反，在PLA中，由于或门也是可编程的，其延迟会随着连接到该或门的乘积项数量（即[扇入](@entry_id:165329)数）的增加而变化。这意味着在PLA中，实现一个复杂函数（乘积项多）的输出会比实现一个[简单函数](@entry_id:137521)的输出慢。GAL的固定延迟特性极大地简化了系统的[时序分析](@entry_id:178997)和验证工作，使得设计师可以更容易地确保系统满足时钟频率要求 [@problem_id:1939722]。

#### 乘积项资源的限制

GAL最常见的局限性之一是每个OLMC可用的**乘积项数量是固定的且有限的**。例如，一个OLMC的[或门](@entry_id:168617)可能只能接收8个乘积项。如果一个布尔函数经过化简后，其最小“积之和”形式仍然需要9个乘积项，那么它就无法在单个OLMC中实现。

在这种情况下，设计师必须采用**逻辑分解**的技巧。这通常涉及将原函数拆分为多个部分，使用一个OLMC实现一个中间函数，然后将该中间函数的输出通过反馈路径送入另一个OLMC，作为最终函数的一部分。例如，一个需要四个乘积项的函数 $F = T_1 + T_2 + T_3 + T_4$，在一个最多支持三个乘积项的GAL上，可以这样实现 [@problem_id:1939718]：
*   **OLMC1**: 计算一个中间函数 $X = T_1 + T_2 + T_3$。
*   **OLMC2**: 利用OLMC1的反馈输出 $X$，计算最终函数 $F = X + T_4$。

这种方法虽然有效，但会增加额外的[传播延迟](@entry_id:170242)，并消耗更多的逻辑资源。

#### 从GAL到CPLD的演进

GAL的架构是**单片式**（monolithic）的，即一个大的、统一的[与门](@entry_id:166291)阵列服务于所有的OLMC。这种结构的缺点在于**[资源分配](@entry_id:136615)缺乏灵活性**。如果一个输出函数需要比单个OLMC所能提供的更多的乘积项，而其他OLMC却有很多空闲的乘积项，系统也无法将这些空闲资源“借”给需要它的那个输出。这种资源被“困”在特定宏单元中的现象，称为**资源搁浅**（resource stranding）。

为了克服这一限制，后来的**[复杂可编程逻辑器件](@entry_id:168079)**（Complex Programmable Logic Device, CPLD）应运而生。CPLD的架构并非单片式，而是由多个类似于GAL/PAL的**逻辑阵列块**（Logic Array Blocks, LABs）和一个中心**[可编程互连](@entry_id:172155)矩阵**（Programmable Interconnect Matrix, PIM）组成。如果一个函数过于复杂，无法在单个LAB中实现，PIM可以将多个LAB连接起来协同工作。这种[分而治之](@entry_id:273215)的架构提供了远超GAL的逻辑容量和资源利用灵活性，标志着[可编程逻辑](@entry_id:164033)技术向更高集成度和更复杂设计能力的又一次飞跃 [@problem_id:1939690]。

本章通过剖析GAL的内部原理与机制，揭示了其作为连接简单PLD与现代CPLD/FPGA的桥梁性技术的地位。掌握GAL的设计思想，对于理解所有现代[可编程逻辑器件](@entry_id:178982)的演化路径和核心概念至关重要。