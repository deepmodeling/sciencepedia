{"hands_on_practices": [{"introduction": "在分析整个数字系统的时序之前，我们必须首先理解其最基本信号路径的延迟。本练习将一个信号在CPLD内部的传播过程分解为几个关键部分——从输入引脚，经过可编程互连阵列（PIA）和逻辑阵列块（LAB），最终到达输出引脚——并演示如何利用数据手册中的参数计算总组合逻辑延迟。这是所有时序分析的基础。[@problem_id:1924368]", "problem": "一名工程专业的学生正在一个项目中使用特定的复杂可编程逻辑器件 (CPLD)。为确保其设计满足时序要求，他们必须计算一个关键组合逻辑函数的最坏情况传播延迟。该CPLD的架构包括输入引脚，信号通过输入引脚馈入中央可编程互连阵列 (PIA)，PIA再将信号路由到各个逻辑阵列块 (LAB)。LAB的输出随后被路由到一个输出引脚。\n\n该CPLD的数据手册为单通道组合路径提供了以下最坏情况时序参数：\n- $t_{IN}$: 从外部输入引脚，经过输入缓冲器，到PIA的延迟。数值：1.5 ns。\n- $t_{PIA}$: 信号从PIA路由到单个LAB输入的延迟。数值：3.0 ns。\n- $t_{LAB}$: 在单个LAB内部计算标准积之和表达式的内部组合逻辑延迟。数值：5.2 ns。\n- $t_{OUT}$: 从LAB输出到外部输出引脚的延迟。数值：2.3 ns。\n\n该学生需要实现逻辑函数 $Y = (A \\cdot B) + (C \\cdot \\neg D)$，其中 $A, B, C, D$ 是输入，$Y$ 是输出。假设整个函数在单个LAB内实现，并且信号遵循从输入引脚到输出引脚的直接路径，没有任何反馈。\n\n计算从任何输入信号（$A, B, C,$ 或 $D$）发生变化到相应变化出现在输出 $Y$ 的那一刻的最坏情况传播延迟 $t_{PD}$。答案以纳秒 (ns) 表示，并四舍五入到三位有效数字。", "solution": "题目要求我们计算从任一输入引脚（$A, B, C,$ 或 $D$）到输出引脚 $Y$ 的最坏情况传播延迟。该组合逻辑函数完全在一个LAB内实现，信号通过器件的单通道路径：输入引脚 $\\rightarrow$ 输入缓冲器 $\\rightarrow$ PIA $\\rightarrow$ LAB $\\rightarrow$ 输出引脚。\n\n根据给定的单通道组合路径时序参数的定义，总的最坏情况传播延迟是该路径上各顺序部分延迟的总和：\n- $t_{IN}$: 输入引脚到PIA，\n- $t_{PIA}$: PIA到LAB输入，\n- $t_{LAB}$: LAB内部的组合逻辑延迟（对于标准的积之和实现，这包括了必要的反相和与或结构，如 $A\\cdot B$ 和 $C\\cdot \\neg D$），\n- $t_{OUT}$: LAB输出到输出引脚。\n\n因此，最坏情况传播延迟满足\n$$\nt_{PD} = t_{IN} + t_{PIA} + t_{LAB} + t_{OUT}.\n$$\n\n使用所提供的最坏情况数值，\n$$\nt_{PD} = 1.5 + 3.0 + 5.2 + 2.3 = 12.0.\n$$\n\n这个总和已经反映了任何单个输入跃迁通过 $Y = (A \\cdot B) + (C \\cdot \\neg D)$ 的单个LAB实现传播时的最坏情况，并且已按要求四舍五入到三位有效数字。", "answer": "$$\\boxed{12.0}$$", "id": "1924368"}, {"introduction": "在同步系统中，仅仅知道组合逻辑的传播延迟是不够的，它只是时序难题的一部分。本练习在前一个练习的基础上，引入了至关重要的建立时间（setup time）约束，将传播延迟（$t_{PD}$）与触发器的时序特性（时钟到输出时间 $t_{CO}$ 和建立时间 $t_{SU}$）相结合。通过这个计算，你将能确定一个CPLD设计能够可靠运行的最高时钟频率。[@problem_id:1924348]", "problem": "一位数字系统工程师正在一个复杂可编程逻辑器件 (CPLD) 内设计一个同步状态机。该设计的关键时序路径由信号从源寄存器的输出端，经过一个组合逻辑块和内部布线，传播到目标寄存器的数据输入端所决定。两个寄存器都由同一个全局时钟驱动。\n\n该 CPLD 制造商的数据手册为所使用的器件系列提供了以下时序参数：\n- 任何寄存器的时钟到输出时间 ($t_{CO}$) 为 4.2 纳秒。\n- 任何寄存器数据输入的建立时间要求 ($t_{SU}$) 为 2.7 纳秒。\n\n根据该特定设计的综合与布局布线报告，该关键路径上通过组合逻辑和布线结构的总传播延迟 ($t_{PD}$) 为 7.1 纳秒。\n\n为确保可靠运行并避免亚稳态，该设计必须满足目标寄存器上的建立时间约束。计算此设计的最大安全工作时钟频率。\n\n以兆赫兹 (MHz) 为单位表示您的答案，并四舍五入到三位有效数字。", "solution": "对于由同一时钟驱动且时钟偏斜可忽略不计的两个寄存器之间的同步路径，其建立时间约束为\n$$\nT_{\\text{clk}} \\geq t_{CO} + t_{PD} + t_{SU}.\n$$\n给定 $t_{CO} = 4.2 \\times 10^{-9} \\text{ s}$，$t_{PD} = 7.1 \\times 10^{-9} \\text{ s}$，以及 $t_{SU} = 2.7 \\times 10^{-9} \\text{ s}$，最小允许时钟周期为\n$$\nT_{\\text{clk,min}} = \\left(4.2 + 7.1 + 2.7\\right) \\times 10^{-9} \\text{ s} = 14.0 \\times 10^{-9} \\text{ s}.\n$$\n最大时钟频率是最小周期的倒数：\n$$\nf_{\\text{max}} = \\frac{1}{T_{\\text{clk,min}}} = \\frac{1}{14.0 \\times 10^{-9} \\text{ s}} = \\frac{1}{14.0} \\times 10^{9} \\text{ Hz} = 71.4286 \\times 10^{6} \\text{ Hz}.\n$$\n以兆赫兹表示并四舍五入到三位有效数字，结果为 $71.4$ MHz。", "answer": "$$\\boxed{71.4}$$", "id": "1924348"}, {"introduction": "真实的工程设计充满了权衡与取舍，尤其当一个逻辑功能超出了单个CPLD宏单元的资源限制时。本练习将你置于一个实际的设计困境中：选择是使用产品项扩展还是逻辑重构。你需要评估这两种常用解决方案对性能（延迟）和资源消耗（宏单元数量）的影响，从而学会如何在相互冲突的设计目标之间做出明智的决策。[@problem_id:1924354]", "problem": "一位工程师的任务是在一个假设的复杂可编程逻辑器件 (CPLD) 上实现一个复杂的布尔函数。该 CPLD 的架构具有以下特性：\n- 每个宏单元包含一个可编程的与阵列，最多可支持5个乘积项 (p-term)。\n- 单次通过宏单元（从一个输入/输出 (I/O) 引脚到另一个 I/O 引脚）的总引脚到引脚传播延迟由其组成部分的延迟之和决定。\n- **$t_{LA} = 2.5 \\text{ ns}$**：逻辑阵列延迟，信号从输入引脚或内部反馈线，经过可编程互连阵列 (PIA)，传播到宏单元与门所需的时间。\n- **$t_{P-OR} = 1.5 \\text{ ns}$**：乘积项逻辑延迟，从与门经过宏单元主或门所需的时间。\n- **$t_{OUT} = 2.0 \\text{ ns}$**：输出路径延迟，从或门输出到外部 I/O 引脚所需的时间。\n- **$t_{EXP} = 1.0 \\text{ ns}$**：扩展延迟。当一个宏单元使用乘积项扩展从相邻宏单元借用项时，此固定延迟会加到其总传播路径中。\n- **$t_{FB} = 1.5 \\text{ ns}$**：反馈路径延迟，宏单元的输出被路由回 PIA 作为其他宏单元的输入所需的时间。\n\n目标布尔函数 $F$ 在其最小积之和形式下需要8个乘积项，这超出了单个宏单元的容量。工程师考虑了两种实现策略：\n\n**策略1：乘积项扩展**\n函数 $F$ 在一个主宏单元中实现。为了容纳所有8个p-term，它从一个相邻的宏单元借用必要的p-term。此过程会消耗整个相邻的宏单元，使其无法用于任何其他逻辑。\n\n**策略2：逻辑重构**\n该函数被手动分解为一个两级逻辑结构。前四个乘积项被分组为一个中间函数 $G_1$，其余四个乘积项被分组为第二个中间函数 $G_2$。$G_1$ 和 $G_2$ 在两个独立的宏单元中实现。它们的输出随后被反馈到 PIA 中。第三个宏单元用于实现最终函数 $F = G_1 + G_2$。\n\n分别计算策略1和策略2消耗的宏单元总数（$N_1$, $N_2$）和以纳秒为单位的总引脚到引脚传播延迟（$t_{PD,1}$, $t_{PD,2}$）。将你的最终答案表示为四个数值（$N_1$, $N_2$, $t_{PD,1}$, $t_{PD,2}$），所有值均四舍五入到两位有效数字。延迟值必须以纳秒为单位表示。", "solution": "CPLD 宏单元最多支持5个乘积项。给定的延迟为 $t_{LA} = 2.5 \\text{ ns}$, $t_{P-OR} = 1.5 \\text{ ns}$, $t_{OUT} = 2.0 \\text{ ns}$, $t_{EXP} = 1.0 \\text{ ns}$, 以及 $t_{FB} = 1.5 \\text{ ns}$。任何路径上的总引脚到引脚延迟是该路径上相关段延迟的总和。\n\n策略1使用乘积项扩展，在一个主宏单元中实现所有8个乘积项，并从一个相邻宏单元借用。这消耗了两个宏单元，因此 $N_{1} = 2$。引脚到引脚路径包括逻辑阵列、宏单元或门、输出路径和扩展开销。因此，\n$$\nt_{PD,1} = t_{LA} + t_{P-OR} + t_{OUT} + t_{EXP}.\n$$\n代入给定值，\n$$\nt_{PD,1} = 2.5 + 1.5 + 2.0 + 1.0 = 7.0 \\text{ ns}.\n$$\n四舍五入到两位有效数字，$t_{PD,1} = 7.0 \\text{ ns}$。\n\n策略2将 $F$ 分解为各有4个乘积项的 $G_{1}$ 和 $G_{2}$，在两个宏单元中实现，然后第三个宏单元计算 $F = G_{1} + G_{2}$。这消耗了三个宏单元，因此 $N_{2} = 3$。最坏情况下的引脚到引脚路径经过一个第一级宏单元，然后是最终宏单元。延迟是第一级逻辑和反馈，加上第二级逻辑和输出的总和：\n$$\nt_{PD,2} = \\underbrace{(t_{LA} + t_{P-OR} + t_{FB})}_{\\text{第一级}} + \\underbrace{(t_{LA} + t_{P-OR} + t_{OUT})}_{\\text{第二级}} = 2 t_{LA} + 2 t_{P-OR} + t_{FB} + t_{OUT}.\n$$\n代入给定值，\n$$\nt_{PD,2} = 2(2.5) + 2(1.5) + 1.5 + 2.0 = 5.0 + 3.0 + 1.5 + 2.0 = 11.5 \\text{ ns}.\n$$\n四舍五入到两位有效数字，$t_{PD,2} = 12 \\text{ ns}$。\n\n因此，结果为 $N_{1} = 2.0$, $N_{2} = 3.0$, $t_{PD,1} = 7.0 \\text{ ns}$, 以及 $t_{PD,2} = 12 \\text{ ns}$。", "answer": "$$\\boxed{\\begin{pmatrix}2.0  3.0  7.0  12\\end{pmatrix}}$$", "id": "1924354"}]}