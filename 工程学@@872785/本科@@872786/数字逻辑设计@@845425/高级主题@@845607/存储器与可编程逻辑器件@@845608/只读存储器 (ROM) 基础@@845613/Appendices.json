{"hands_on_practices": [{"introduction": "将组合逻辑电路的功能用只读存储器（ROM）实现，第一步就是确定所需ROM的规模。本练习旨在阐明电路的输入输出数量与ROM所需的地址空间和数据位宽之间的直接关系。掌握这种计算方法对于估算硬件资源和进行初步设计至关重要。[@problem_id:1956906]", "problem": "在为物联网（IoT）设备设计定制微控制器时，一个关键组件是指令译码器。该译码器作为一个组合逻辑电路，负责解释要执行的操作。译码器从指令寄存器接收一个4位的操作码作为其输入。根据这个操作码，它会生成3个不同的控制信号，并发送到微控制器的算术逻辑单元（ALU）。\n\n为了简化硬件设计并允许通过固件更新进行潜在的修改，一名工程师决定使用单个只读存储器（ROM）来实现这整个译码器逻辑。\n\n确定完全实现所述译码器功能所需的该ROM的最小总存储容量。请用位（bits）作答。", "solution": "用于实现组合译码器的只读存储器（ROM）为每一种可能的输入组合存储相应的输出字。如果输入宽度为 $n$ 位，输出宽度为 $m$ 位，那么地址数量为 $2^{n}$，每个地址存储 $m$ 位，因此总存储容量（以位计）为\n$$C=2^{n}\\cdot m.$$\n在此问题中，操作码宽度为 $n=4$，控制信号数量为 $m=3$，因此\n$$C=2^{4}\\cdot 3=16\\cdot 3=48\\ \\text{bits}.$$\n因此，所需的最小总存储容量为 $48$ 位。", "answer": "$$\\boxed{48}$$", "id": "1956906"}, {"introduction": "确定了ROM的规模之后，下一步便是编程其内部存储的数据。本练习将ROM视为一个物理实现的“真值表”，其中每个地址对应一种输入组合，而存储的数据就是相应的输出。通过将ROM编程为素数检测器，你将亲身体验如何将一个特定的逻辑函数转化为存储器中的二进制内容。[@problem_id:1956845]", "problem": "一位数字系统工程师的任务是为一个小型专用逻辑设备编程。该设备是一个 16x1 的只读存储器 (ROM)，它有 4 条地址线和一条数据输出线。这 4 条地址线接受一个 4 位无符号整数，我们可以将其表示为 $N$，对应于十进制值 0 到 15。该 ROM 需要被编程以实现一个素数检测器的功能。如果输入的整数 $N$ 是一个素数，则单条数据线应输出逻辑“1”，否则输出逻辑“0”。根据标准的数学定义，整数 0 和 1 不被认为是素数。\n\n您的任务是确定必须存储在此 ROM 中的完整 16 位数据内容，以实现所需的功能。请将您的最终答案表示为一个 16 位的二进制字符串，其中最左边的位对应于存储在地址 0 的数据，下一个位对应于地址 1，依此类推，直到最右边的位对应于地址 15 的数据。", "solution": "ROM 的地址由 $N \\in \\{0,1,\\dots,15\\}$ 标记。当且仅当 $N$ 是素数时，输出位为 $1$。根据定义，如果一个整数大于 $1$ 并且除了 $1$ 和它本身之外没有其他正因数，那么它就是素数。因此 $0$ 和 $1$ 不是素数，所以 $b_{0}=0$ 和 $b_{1}=0$。\n\n对于 $N \\geq 2$，测试从 $2$ 到 $\\lfloor \\sqrt{N} \\rfloor$ 的整数的可除性：\n- $N=2$：在 $[2,\\lfloor \\sqrt{2} \\rfloor]$ 区间内没有整数，所以是素数 $\\Rightarrow b_{2}=1$。\n- $N=3$：在 $[2,\\lfloor \\sqrt{3} \\rfloor]$ 区间内没有整数，所以是素数 $\\Rightarrow b_{3}=1$。\n- $N=4$：能被 $2$ 整除，是合数 $\\Rightarrow b_{4}=0$。\n- $N=5$：不能被 $2$ 整除，是素数 $\\Rightarrow b_{5}=1$。\n- $N=6$：能被 $2$ 整除，是合数 $\\Rightarrow b_{6}=0$。\n- $N=7$：不能被 $2$ 或 $3$ 整除，是素数 $\\Rightarrow b_{7}=1$。\n- $N=8$：能被 $2$ 整除，是合数 $\\Rightarrow b_{8}=0$。\n- $N=9$：能被 $3$ 整除，是合数 $\\Rightarrow b_{9}=0$。\n- $N=10$：能被 $2$ 整除，是合数 $\\Rightarrow b_{10}=0$。\n- $N=11$：不能被 $2$ 或 $3$ 整除，是素数 $\\Rightarrow b_{11}=1$。\n- $N=12$：能被 $2$ 整除，是合数 $\\Rightarrow b_{12}=0$。\n- $N=13$：不能被 $2$ 或 $3$ 整除，是素数 $\\Rightarrow b_{13}=1$。\n- $N=14$：能被 $2$ 整除，是合数 $\\Rightarrow b_{14}=0$。\n- $N=15$：能被 $3$ (和 $5$) 整除，是合数 $\\Rightarrow b_{15}=0$。\n\n因此，在 $\\{0,1,\\dots,15\\}$ 中的素数集合是 $\\{2,3,5,7,11,13\\}$，映射关系为\n$$\nb_{N}=\\begin{cases}\n1,  N \\in \\{2,3,5,7,11,13\\},\\\\\n0,  \\text{otherwise}.\n\\end{cases}\n$$\n将地址 $0$ (最左边) 到地址 $15$ (最右边) 的位列出，得到\n$$\nb_{0}b_{1}b_{2}b_{3}b_{4}b_{5}b_{6}b_{7}b_{8}b_{9}b_{10}b_{11}b_{12}b_{13}b_{14}b_{15}\n=0011010100010100.\n$$", "answer": "$$\\boxed{0011010100010100}$$", "id": "1956845"}, {"introduction": "理想的电路图常常忽略了信号传播延迟等真实世界的复杂性。本练习将探讨一个实际的设计挑战：由地址位变化不同步引起的ROM输出信号上的“毛刺”。通过分析这种现象，你将加深对时序危害的理解，并学习到标准的同步设计技巧，例如使用时钟控制的寄存器来锁存输出，以确保系统的稳定与可靠。[@problem_id:1956894]", "problem": "一个 16x1 的只读存储器 (ROM) 被用于一个数字系统中。该 ROM 有四条地址输入线，表示为 $A_3, A_2, A_1, A_0$，以及一条数据输出线 $D_0$。该 ROM 被编程为一个 4 输入的奇校验生成器。如果地址输入有奇数个'1'，输出 $D_0$ 为逻辑'1'；如果地址输入有偶数个'1'，输出 $D_0$ 为逻辑'0'。\n\n在物理实现中，到达 ROM 内部解码器的地址信号并不是在完全相同的瞬间变化的。这种时序偏移意味着在从一个地址转换到另一个地址期间，可能会瞬间选中一个或多个不正确的中间地址，从而可能在输出线 $D_0$ 上引起一个虚假的、短暂的脉冲，称为毛刺 (glitch)。当大量地址位同时变化而理想输出状态应保持不变时，发生毛刺的风险最高。\n\n在这种情况下，以下哪个选项正确地指出了一个极有可能产生输出毛刺的地址转换，并提出了一种在同步数字系统中减轻此类毛刺的有效的、标准的系统级技术？\n\nA. 转换：0001 到 0011；解决方法：在 ROM 输出 $D_0$ 上添加一个大电流缓冲器。\nB. 转换：0101 到 1010；解决方法：用一个访问时间更快的 ROM 替换它。\nC. 转换：0111 到 1000；解决方法：使用一个寄存器锁存 ROM 输出 $D_0$，该寄存器由时钟控制，在数据稳定后进行采样。\nD. 转换：0011 到 0110；解决方法：使用分立的异或门而不是 ROM 重新设计奇偶校验逻辑。\nE. 转换：0000 到 1111；解决方法：要求所有输入地址序列遵循格雷码模式。", "solution": "我们将编程后的 ROM 建模为实现 4 输入奇偶校验函数\n$$\nD_{0}=A_{3}\\oplus A_{2}\\oplus A_{1}\\oplus A_{0},\n$$\n其中，当输入中'1'的个数为偶数时 $D_{0}=0$，为奇数时 $D_{0}=1$。如果在两个地址向量之间转换时地址线没有同时切换，就可能发生毛刺，因为瞬间选中的中间地址的奇偶性可能与预期的最终奇偶性不同。当理想输出应保持不变而许多地址位同时变化时，风险最大，因为经过不同奇偶性的中间地址的概率随着转换的汉明距离的增加而增加。\n\n将两个地址向量 $\\mathbf{a}$ 和 $\\mathbf{b}$ 之间的汉明距离定义为\n$$\nd_{H}(\\mathbf{a},\\mathbf{b})=\\sum_{i=0}^{3}\\left|a_{i}-b_{i}\\right|,\n$$\n它计算了变化的比特数。为了获得最高的毛刺可能性，我们希望 $D_{0}(\\mathbf{a})=D_{0}(\\mathbf{b})$（理想输出恒定）且 $d_{H}$ 尽可能大。\n\n评估每个选项：\n\nA. 转换 0001 到 0011。奇偶性：$0001$ 有一个 1，所以是奇数，因此 $D_{0}=1$；$0011$ 有两个 1，所以是偶数，因此 $D_{0}=0$。理想输出发生变化，且只有一个比特变化 ($d_{H}=1$)。这不是一个高可能性的虚假毛刺情况。所提出的解决方法，即添加一个大电流缓冲器，并不能解决逻辑冒险，因为它没有消除中间地址解码或内部竞争。\n\nB. 转换 0101 到 1010。奇偶性：$0101$ 有两个 1，所以是偶数，$D_{0}=0$；$1010$ 有两个 1，所以是偶数，$D_{0}=0$。理想输出是恒定的，且所有四个比特都发生变化 ($d_{H}=4$)，这确实是一个高可能性的毛刺场景。然而，用更快的 ROM 替换并不能保证消除由输入到达时间不均和内部解码器竞争引起的冒险；它可能只会缩短毛刺，但不能确保在系统级别上的正确同步行为。\n\nC. 转换 0111 到 1000。奇偶性：$0111$ 有三个 1，所以是奇数，$D_{0}=1$；$1000$ 有一个 1，所以是奇数，$D_{0}=1$。理想输出是恒定的，且所有四个比特都发生变化 ($d_{H}=4$)，从而产生很高的毛刺可能性。所提出的解决方法是在一个寄存器中锁存 $D_{0}$，该寄存器由时钟控制，在 ROM 输出稳定后进行采样。在同步系统中，这是标准技术：选择时钟，使得寄存器在 ROM 及其地址输入满足建立时间和保持时间约束后对 $D_{0}$ 进行采样，从而滤除任何瞬态毛刺。\n\nD. 转换 0011 到 0110。奇偶性：$0011$ 有两个 1，偶数，$D_{0}=0$；$0110$ 有两个 1，偶数，$D_{0}=0$。理想输出是恒定的，但只有两个比特变化 ($d_{H}=2$)，这是一个较低但仍可能存在冒险的情况。使用异或门重新设计并不能从根本上消除冒险，除非该逻辑明确无冒险，并且与寄存输出相比，它仍然不构成标准的系统级缓解措施。\n\nE. 转换 0000 到 1111。奇偶性：$0000$ 有零个 1，偶数，$D_{0}=0$；$1111$ 有四个 1，偶数，$D_{0}=0$。理想输出是恒定的，并且所有四个比特都发生变化 ($d_{H}=4$)，因此该转换极有可能产生毛刺。要求格雷码序列可以通过确保单比特转换来减少毛刺，但对于同步系统中的任意地址，这通常不是一种标准的或普遍适用的系统级缓解措施；它对地址生成器施加了约束，并且其适用性不如寄存输出广泛。\n\n在指出高可能性转换的选项中，B、C 和 E 的 $d_{H}$ 均为 4 且理想输出恒定，但只有 C 提出了有效的、标准的同步系统补救措施，即寄存 ROM 输出以在稳定后采样。因此，正确选项是 C。", "answer": "$$\\boxed{C}$$", "id": "1956894"}]}