{"hands_on_practices": [{"introduction": "现场可编程门阵列（FPGA）的核心是其可配置的逻辑单元，而查找表（LUT）是这些单元中最基本的构件。本练习将带你亲手将一个布尔函数转换为具体的 LUT 配置位，这能帮助你深入理解 FPGA 是如何通过存储真值表来实现任意逻辑功能的。通过这个过程，你将掌握 FPGA 设计中最基础的操作。[@problem_id:1934992]", "problem": "在现场可编程门阵列 (FPGA) 中，一个基本的逻辑单元是查找表 (LUT)。一个 $k$ 输入查找表可以被配置以实现任意一个 $k$ 变量的布尔函数。这是通过对其 $2^k$ 个内部静态存储单元进行编程来实现的，这些单元存储了函数的真值表。\n\n考虑一个 4 输入查找表，其输入标记为 $I_3, I_2, I_1, I_0$，并有一个单一输出 $O$。这 16 个配置存储位对应于每一种可能的输入组合的查找表输出，按地址从 $(I_3, I_2, I_1, I_0) = (0,0,0,0)$到 $(1,1,1,1)$ 的顺序排列。\n\n你的任务是配置此查找表以实现以下 4 变量布尔函数：\n$$F(A, B, C, D) = (A \\oplus B) \\cdot (C \\odot D)$$\n其中 $\\oplus$ 表示异或 (XOR) 运算，而 $\\odot$ 表示同或 (XNOR) 运算。\n\n函数变量 $A, B, C, D$ 根据以下物理映射连接到查找表的输入端：\n- $A$ 连接到 $I_1$。\n- $B$ 连接到 $I_0$。\n- $C$ 连接到 $I_3$。\n- $D$ 连接到 $I_2$。\n\n确定必须加载到查找表存储器中的 16 位配置字符串。将你的答案表示为一个 16 位的二进制字符串，其中第一位对应地址 $(0,0,0,0)$ 的存储单元，最后一位对应地址 $(1,1,1,1)$ 的存储单元。", "solution": "一个 $k$ 输入查找表在一个有 $2^k$ 个条目的表中为每个输入地址 $(I_{3}, I_{2}, I_{1}, I_{0})$ 存储输出。在这里，$k=4$，所需的函数是\n$$F(A,B,C,D)=(A \\oplus B)\\cdot(C \\odot D),$$\n物理映射为 $A \\to I_{1}$，$B \\to I_{0}$，$C \\to I_{3}$，$D \\to I_{2}$。因此，对于一个地址 $(i_{3}, i_{2}, i_{1}, i_{0})$，查找表的输出为\n$$O=(i_{1} \\oplus i_{0}) \\cdot (i_{3} \\odot i_{2}).$$\n根据定义，$x \\oplus y=1$ 当且仅当 $x \\neq y$，$x \\odot y=1$ 当且仅当 $x=y$。因此，\n- 如果 $i_{3}=i_{2}$，则 $(i_{3} \\odot i_{2})=1$ 且 $O=i_{1} \\oplus i_{0}$。\n- 如果 $i_{3} \\neq i_{2}$，则 $(i_{3} \\odot i_{2})=0$ 且 $O=0$。\n\n按从 $(0,0,0,0)$到 $(1,1,1,1)$ 的顺序列举地址：\n\n1) 对于 $(i_{3},i_{2})=(0,0)$，地址 $(0,0,i_{1},i_{0})$ 产生\n$$(i_{1},i_{0})=(0,0)\\to 0,\\quad (0,1)\\to 1,\\quad (1,0)\\to 1,\\quad (1,1)\\to 0,$$\n所以这些位是：$0,1,1,0$。\n\n2) 对于 $(i_{3},i_{2})=(0,1)$，$(i_{3} \\odot i_{2})=0$，所以这些位是：$0,0,0,0$。\n\n3) 对于 $(i_{3},i_{2})=(1,0)$，$(i_{3} \\odot i_{2})=0$，所以这些位是：$0,0,0,0$。\n\n4) 对于 $(i_{3},i_{2})=(1,1)$，地址 $(1,1,i_{1},i_{0})$ 产生相同的异或模式：\n$$(i_{1},i_{0})=(0,0)\\to 0,\\quad (0,1)\\to 1,\\quad (1,0)\\to 1,\\quad (1,1)\\to 0,$$\n所以这些位是：$0,1,1,0$。\n\n按地址顺序（从 $0000$ 到 $1111$）串联起来，得到 16 位的配置：\n$$0110000000000110.$$", "answer": "$$\\boxed{0110000000000110}$$", "id": "1934992"}, {"introduction": "在实际设计中，复杂的逻辑功能往往超出了单个 LUT 的输入限制。本练习将通过一个简单的例子——实现一个7输入与门——来展示如何将一个较大的逻辑功能分解到多个 LUT 上。更重要的是，它将引导你分析这种分解对电路性能的影响，通过计算关键路径上的总传播延迟，让你对资源与速度之间的权衡有更直观的认识。[@problem_id:1935002]", "problem": "一位数字设计工程师的任务是在现代现场可编程门阵列（FPGA）上实现一个7输入逻辑与门。目标FPGA的逻辑结构由6输入查找表（LUT）构成。单个6输入LUT可以配置为实现最多6个变量的任意布尔函数。\n\n该FPGA架构的时序特性如下：\n- 从单个LUT的任意输入到其输出的传播延迟为 `T_LUT = 80` ps。\n- 从一个LUT的输出到后续LUT的输入的互连网络上的信号传播延迟为 `T_NET = 110` ps。\n\n在本分析中，假定与门的全部7个主输入在时间 `t=0` 时稳定并同时可用在第一级LUT的输入端。您的任务是确定资源效率最高的实现方案的参数，其中效率定义为使用最少数量的LUT。\n\n计算实现7输入与门所需的最少LUT数量（`L`），以及此实现的总最坏情况传播延迟（`D`）。延迟的测量从 `t=0` 开始，直到最终输出稳定为止。\n\n以一个2元素行矩阵 `[L, D]` 的形式报告您的答案，其中 `L` 是LUT的无量纲计数，`D` 是以皮秒为单位表示的总延迟。", "solution": "单个6输入LUT可以实现最多6个独立变量的任意布尔函数。一个7输入与门依赖于7个独立变量，因此无法用单个6输入LUT实现。因此，至少需要2个LUT。\n\n资源最少的结构使用2个LUT：\n- LUT1计算部分积 $$y_{1} = x_{1} \\land x_{2} \\land x_{3} \\land x_{4} \\land x_{5} \\land x_{6}$$。\n- LUT2计算最终输出 $$y = y_{1} \\land x_{7}$$。\n\n因此，最少LUT数量为 $L=2$。\n\n在时序方面，最坏情况传播延迟是从主输入到最终输出的最长串行路径上的延迟之和。贯穿两个LUT的路径包括：\n- 第一个LUT延迟 $T_{\\text{LUT}}$，用于产生 $y_{1}$，\n- 一个从LUT1输出到LUT2输入的LUT间网络延迟 $T_{\\text{NET}}$，\n- 第二个LUT延迟 $T_{\\text{LUT}}$，用于产生 $y$。\n\n因此，总延迟为\n$$\nD = T_{\\text{LUT}} + T_{\\text{NET}} + T_{\\text{LUT}} = 2T_{\\text{LUT}} + T_{\\text{NET}}.\n$$\n代入给定值 $T_{\\text{LUT}} = 80$ ps 和 $T_{\\text{NET}} = 110$ ps，可得\n$$\nD = 2 \\times 80 + 110 = 270.\n$$\n因此，$L=2$ 且 $D=270$（单位：皮秒）。", "answer": "$$\\boxed{\\begin{pmatrix} 2  270 \\end{pmatrix}}$$", "id": "1935002"}, {"introduction": "从抽象的逻辑设计到具体的硬件实现，高效地利用 FPGA 内部的专用硬件资源至关重要。本练习探讨了硬件描述语言（HDL）的编码风格如何直接影响综合工具的行为，特别是如何引导其推断出专用的块存储器（BRAM）而非低效的分布式逻辑。通过比较两种不同的 Verilog 代码，你将学会编写能够生成高性能、高效率硬件的 HDL 代码。[@problem_id:1934984]", "problem": "一位数字设计工程师的任务是在现场可编程门阵列（FPGA）上实现一个小型暂存存储器（scratchpad memory）。该存储器必须能够存储 $2^N$ 个字，每个字宽为 $M$ 位。主要目标是确保综合工具使用 FPGA 的专用高性能块状 RAM（Block RAM, BRAM）资源来实现该存储器，而不是使用通用逻辑元件（即分布式 RAM）来实现，后者在面积和速度方面的效率要低得多。\n\n工程师考虑了两种不同的 Verilog 编码风格，分别表示为 `Module_A` 和 `Module_B`。这两个模块在功能上都旨在实现一个简单的双端口存储器，带有一个写端口和一个读端口。\n\n**模块 A：**\n```verilog\nmodule Module_A #(\n    parameter N = 8, // Address width\n    parameter M = 16 // Data width\n) (\n    input                       clk,\n    input                       write_en,\n    input        [N-1:0]        write_addr,\n    input        [M-1:0]        write_data,\n    input        [N-1:0]        read_addr,\n    output logic [M-1:0]        read_data\n);\n    reg [M-1:0] memory_array [(2**N)-1:0];\n\n    // Write Port (Synchronous)\n    always @(posedge clk) begin\n        if (write_en) begin\n            memory_array[write_addr] = write_data;\n        end\n    end\n\n    // Read Port (Asynchronous)\n    assign read_data = memory_array[read_addr];\n\nendmodule\n```\n\n**模块 B：**\n```verilog\nmodule Module_B #(\n    parameter N = 8, // Address width\n    parameter M = 16 // Data width\n) (\n    input                       clk,\n    input                       write_en,\n    input        [N-1:0]        write_addr,\n    input        [M-1:0]        write_data,\n    input        [N-1:0]        read_addr,\n    output logic [M-1:0]        read_data\n);\n    reg [M-1:0] memory_array [(2**N)-1:0];\n\n    // Write Port (Synchronous)\n    always @(posedge clk) begin\n        if (write_en) begin\n            memory_array[write_addr] = write_data;\n        end\n    end\n\n    // Read Port (Synchronous)\n    always @(posedge clk) begin\n        read_data = memory_array[read_addr];\n    end\n\nendmodule\n```\n\n哪个模块代表了正确的编码风格以确保推断出 BRAM 资源？选择它的主要原因是什么？\n\nA. `Module_A` 更优，因为其异步读取提供了最低的读取延迟，这是存储器设计的一个主要目标。\nB. `Module_B` 更优，因为其同步读取行为直接映射到 FPGA 中专用块状 RAM 原语的寄存器输出架构。\nC. `Module_A` 更优，因为它通过避免在读取数据路径上使用时钟信号来降低功耗。\nD. `Module_B` 更优，因为综合工具只有在读和写操作都在同一个 `always` 块中描述时才能推断出存储器。\nE. 两个模块在 BRAM 推断方面是等效的；选择只是编码偏好问题，因为现代综合工具可以将任何一种风格优化为 BRAM。", "solution": "1. 目标与约束：目标是让综合工具推断出专用的块状 RAM（BRAM），而不是分布式 RAM。主流 FPGA BRAM 原语的关键架构约束是读取是同步的：被寻址的数据在时钟边沿产生，通常通过一个内部或外部的输出寄存器。形式上，BRAM 的语义对应于\n$$\n\\text{read\\_data}(t^{+})=\\text{memory}\\big(\\text{read\\_addr}(t)\\big),\n$$\n其中 $t^{+}$ 表示在时间 $t$ 的有效时钟边沿之后即刻的时间。相反，异步读取意味着\n$$\n\\text{read\\_data}(t)=\\text{memory}\\big(\\text{read\\_addr}(t)\\big),\n$$\n这是一个纯粹的组合逻辑依赖，没有时钟。\n\n2. `Module_A` 分析：写端口是同步的，与 BRAM 推断兼容，但读端口通过连续赋值是异步的：`assign read_data = memory_array[read_addr];`。这表达了组合逻辑的读取行为，即 $\\text{read\\_data}(t)$ 随着 $\\text{read\\_addr}(t)$ 的变化而立即变化，这不符合 BRAM 原语的同步读取要求。综合工具通常会将这种异步读取映射到分布式（LUT）RAM，而不是 BRAM。\n\n3. `Module_B` 分析：写端口和读端口都是同步和时钟驱动的。同步读取的代码 `always @(posedge clk) begin read_data = memory_array[read_addr]; end` 与 BRAM 的同步读取行为相匹配，即地址在时钟边沿被采样，数据在时钟边沿之后呈现，通常通过一个内部寄存器。因此，`Module_B` 遵循了公认的 BRAM 推断模板。\n\n4. 选项评估：\n- A 是不正确的，因为虽然异步读取可以减少表观延迟，但它在大多数 FPGA 上会阻止 BRAM 的推断。\n- B 是正确的，因为同步读取直接映射到 BRAM 的寄存器输出架构。\n- C 是不正确的；功耗在这里不是主要问题，并且异步读取会迫使实现使用 LUT RAM。\n- D 是不正确的；推断并不要求读和写在同一个 `always` 块中。\n- E 是不正确的；工具通常无法将异步读取的存储器映射到 BRAM。\n\n因此，正确的选择是 `Module_B`，主要原因是同步读取行为与 FPGA BRAM 原语的寄存器式、时钟驱动的读取架构一致，从而能够可靠地推断出 BRAM。", "answer": "$$\\boxed{B}$$", "id": "1934984"}]}