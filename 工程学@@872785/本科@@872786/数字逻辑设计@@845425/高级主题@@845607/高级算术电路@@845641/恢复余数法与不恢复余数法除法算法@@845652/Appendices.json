{"hands_on_practices": [{"introduction": "要想真正掌握数字电路如何执行除法，没有什么比一步步追踪其运算过程更有效的方法了。第一个练习将引导你手动执行恢复余数法除法算法，完成一个完整的运算过程 [@problem_id:1958382]。通过跟踪累加器（$A$）和商寄存器（$Q$）在每个周期中的状态，你将对定义该方法的核心“减法-恢复”逻辑建立具体的理解。", "problem": "一个简单的算术逻辑单元（ALU）被设计用于使用恢复除法算法执行无符号二进制除法。该 ALU 使用 4 位架构。考虑将被除数 9 除以除数 3 的运算。\n\n硬件由三个主要的 4 位寄存器组成：\n-   **M**：除数寄存器，用除数的值初始化。\n-   **Q**：商寄存器，用被除数的值初始化。\n-   **A**：累加器寄存器，初始化为零。\n\n恢复除法算法的执行周期数等于位数，本例中为 4。每个周期的步骤如下：\n1.  对由 A 和 Q 连接而成的 8 位寄存器对（`A` 后跟 `Q`）执行逻辑左移。\n2.  从 A 寄存器中减去 M 寄存器中的值（`A = A - M`）。\n3.  检查 A 寄存器的最高有效位（MSB）。\n    -   如果 A 的 MSB 为 1，则将 Q 的最低有效位（LSB）设置为 0，并通过将 M 加回到 A 来恢复 A 的值（`A = A + M`）。\n    -   如果 A 的 MSB 为 0，则将 Q 的最低有效位（LSB）设置为 1。\n\n对该算法进行手动追踪，计算 9（被除数）除以 3（除数）的过程。确定累加器（A）寄存器（存放余数）和商（Q）寄存器（存放商）中包含的最终二进制值。\n\n以一对 4 位二进制字符串的形式提供您的答案，按顺序表示 A 的最终值和 Q 的最终值。", "solution": "我们使用带有 4 位寄存器的无符号恢复除法。将被除数和除数编码为二进制，$Q=1001$（代表 $9$）和 $M=0011$（代表 $3$），并初始化 $A=0000$。对 $A$ 的算术运算以 4 位二进制补码形式进行，以便 MSB 在减法后指示符号。每个周期执行：(i) 对连接的寄存器对 $(A, Q)$ 进行逻辑左移，(ii) $A \\leftarrow A - M$，(iii) 如果 $\\text{MSB}(A)=1$，则将 $Q$ 的 LSB 设置为 $0$ 并恢复 $A \\leftarrow A+M$，否则将 $Q$ 的 LSB 设置为 $1$。我们执行 4 个周期。\n\n周期 1：\n左移 $(A, Q)$：从 $A=0000$, $Q=1001$ 变为 $A=0001$, $Q=0010$。\n相减：$A \\leftarrow 0001 - 0011 = 1110$（负数，MSB$=1$）。\n恢复并设置 $Q_{0}=0$：$A \\leftarrow 1110 + 0011 = 0001$，$Q$ 保持为 $0010$。\n\n周期 2：\n左移 $(A, Q)$：从 $A=0001$, $Q=0010$ 变为 $A=0010$, $Q=0100$。\n相减：$A \\leftarrow 0010 - 0011 = 1111$（负数，MSB$=1$）。\n恢复并设置 $Q_{0}=0$：$A \\leftarrow 1111 + 0011 = 0010$，$Q$ 保持为 $0100$。\n\n周期 3：\n左移 $(A, Q)$：从 $A=0010$, $Q=0100$ 变为 $A=0100$, $Q=1000$。\n相减：$A \\leftarrow 0100 - 0011 = 0001$（非负数，MSB$=0$）。\n设置 $Q_{0}=1$：$Q \\leftarrow 1001$；不恢复，$A=0001$。\n\n周期 4：\n左移 $(A, Q)$：从 $A=0001$, $Q=1001$ 变为 $A=0011$, $Q=0010$。\n相减：$A \\leftarrow 0011 - 0011 = 0000$（非负数，MSB$=0$）。\n设置 $Q_{0}=1$：$Q \\leftarrow 0011$；不恢复，$A=0000$。\n\n经过 4 个周期后，最终寄存器为 $A=0000$（余数）和 $Q=0011$（商），这对应于 $9 \\div 3 = 3$，余数为 $0$。", "answer": "$$\\boxed{\\begin{pmatrix}0000  0011\\end{pmatrix}}$$", "id": "1958382"}, {"introduction": "在恢复余数法的基础上，我们现在来探索一种更高效的替代方案：不恢复余数法除法算法。该算法巧妙地通过在后续步骤中补偿“透支”来避免耗时的“恢复”步骤，从而通常能够更快地执行 [@problem_id:1958432]。本练习将指导你完成其独特的周期，包括移位、根据当前余数的符号进行加法或减法，以及设置商的数位，从而与前一种方法形成鲜明对比。", "problem": "一个微处理器的算术逻辑单元 (ALU) 被设计用来执行使用4位不恢复余数算法的无符号整数除法。该ALU使用一个4位累加器寄存器 $A$ (初始化为零)，一个4位商寄存器 $Q$ (初始时存放被除数)，以及一个4位除数寄存器 $M$。\n\n该算法分 $n$ 个周期进行，其中 $n$ 是位数。在每个周期中，执行以下步骤：\n1. 检查累加器 $A$ 的符号位 (最高有效位)。\n2. 如果符号位为0 (正数)，则将组合的 $(A,Q)$ 寄存器左移一位，然后从 $A$ 中减去除数 $M$。\n3. 如果符号位为1 (负数)，则将组合的 $(A,Q)$ 寄存器左移一位，然后将除数 $M$ 加到 $A$ 上。\n4. $A$ 的新符号位决定了 $Q$ 的新最低有效位：如果新符号位为0，该位设置为1；如果新符号位为1，该位设置为0。\n\n您的任务是追踪此算法在被除数为13，除数为3时的执行过程。\n\n下列哪个选项正确表示了在四个周期中每个周期结束时寄存器 $A$ 和 $Q$ 的二进制内容？寄存器的状态应在四个周期完成后可能需要的任何最终校正步骤*之前*报告。\n\nA. 周期 1: A=1110, Q=1010; 周期 2: A=0000, Q=0101; 周期 3: A=1101, Q=1010; 周期 4: A=1110, Q=0100\n\nB. 周期 1: A=0001, Q=1010; 周期 2: A=0000, Q=0101; 周期 3: A=0000, Q=1010; 周期 4: A=0001, Q=0100\n\nC. 周期 1: A=1110, Q=1010; 周期 2: A=0000, Q=0101; 周期 3: A=1110, Q=0100; 周期 4: A=1111, Q=1000\n\nD. 周期 1: A=1110, Q=1010; 周期 2: A=1101, Q=0101; 周期 3: A=1101, Q=1010; 周期 4: A=1110, Q=0101", "solution": "我们使用给定的4位不恢复余数除法算法，其中累加器$A$初始化为$0000$，商寄存器$Q$初始化为被除数$1101$（即$13$），除数寄存器$M=0011$（即$3$）。$A$中的所有算术运算均以4位二进制补码形式进行，组合的$(A,Q)$作为一个8位寄存器进行左移。每次加/减法后，$A$的新符号位决定$Q_{0}$的值：如果$\\operatorname{sign}(A)=0$则设置$Q_{0}=1$，否则设置$Q_{0}=0$。我们报告每个周期结束时（设置$Q_{0}$后）的寄存器内容，并且不应用任何最终的余数校正。\n\n初始化: $A=0000$，$Q=1101$，$M=0011$。\n\n周期 1:\n- $\\operatorname{sign}(A)=0$，因此左移$(A,Q)$: $0000\\ 1101 \\to 0001\\ 1010$，所以$A=0001$，$Q=1010$。\n- 由于之前的$\\operatorname{sign}(A)$为$0$，计算$A:=A-M$: $0001-0011=1110$ (二进制补码)。\n- 新的$\\operatorname{sign}(A)=1$，因此设置$Q_{0}=0$。周期结束时: $A=1110$，$Q=1010$。\n\n周期 2:\n- $\\operatorname{sign}(A)=1$，因此左移$(A,Q)$: $1110\\ 1010 \\to 1101\\ 0100$，所以$A=1101$，$Q=0100$。\n- 由于之前的$\\operatorname{sign}(A)$为$1$，计算$A:=A+M$: $1101+0011=10000$，保留低4位，$A=0000$。\n- 新的$\\operatorname{sign}(A)=0$，因此设置$Q_{0}=1$。周期结束时: $A=0000$，$Q=0101$。\n\n周期 3:\n- $\\operatorname{sign}(A)=0$，因此左移$(A,Q)$: $0000\\ 0101 \\to 0000\\ 1010$，所以$A=0000$，$Q=1010$。\n- 由于之前的$\\operatorname{sign}(A)$为$0$，计算$A:=A-M$: $0000-0011=1101$。\n- 新的$\\operatorname{sign}(A)=1$，因此设置$Q_{0}=0$。周期结束时: $A=1101$，$Q=1010$。\n\n周期 4:\n- $\\operatorname{sign}(A)=1$，因此左移$(A,Q)$: $1101\\ 1010 \\to 1011\\ 0100$，所以$A=1011$，$Q=0100$。\n- 由于之前的$\\operatorname{sign}(A)$为$1$，计算$A:=A+M$: $1011+0011=1110$。\n- 新的$\\operatorname{sign}(A)=1$，因此设置$Q_{0}=0$。周期结束时: $A=1110$，$Q=0100$。\n\n周期结束时寄存器内容序列为：\n- 周期 1: $A=1110$，$Q=1010$\n- 周期 2: $A=0000$，$Q=0101$\n- 周期 3: $A=1101$，$Q=1010$\n- 周期 4: $A=1110$，$Q=0100$\n\n这与选项A匹配。", "answer": "$$\\boxed{A}$$", "id": "1958432"}, {"introduction": "一旦你熟悉了除法算法的机制，下一步就是推理其在特定条件下的行为。最后一个练习提出了一个挑战：你能否找出一对输入，使得恢复余数法算法陷入“最坏情况”，即在每个周期都需要进行恢复操作？[@problem_id:1958391]。成功解答这个问题需要你超越机械的追踪，转而分析触发恢复步骤的底层数学条件，从而加深你的概念性理解。", "problem": "在数字计算机算术中，恢复余数除法算法是一种执行无符号整数除法的方法。考虑一个用于将一个4位无符号被除数（初始在寄存器Q中）除以一个4位无符号除数（在寄存器M中）的系统。该过程使用一个4位累加器寄存器（A），其初始值为零。该除法算法进行四个周期。\n\n每个周期由以下微操作序列组成：\n1. 由A和Q连接形成的8位寄存器向左移一位。从A的最高有效位移出的位被丢弃，Q的最高有效位移入A的最低有效位。Q的新的最低有效位被设置为0。\n2. 从累加器A中减去除数M的值。此减法使用二进制补码运算执行。\n3. 检查A中结果的最高有效位（符号位）。如果为1（表示负结果），则执行“恢复”步骤，将M的值加回到A中。\n\n下列哪一对十进制被除数和除数（表示为4位无符号二进制数）会在所有四个周期中*都*需要执行“恢复”步骤？\n\nA. 被除数 = 12, 除数 = 3\nB. 被除数 = 9, 除数 = 4\nC. 被除数 = 7, 除数 = 8\nD. 被除数 = 15, 除数 = 2", "solution": "设4位寄存器为 $A$ (累加器)、$Q$ (被除数) 和 $M$ (除数)。初始化 $A=0$ 并设 $Q$ 的位为 $q_{3}q_{2}q_{1}q_{0}$ (其中 $q_{3}$ 是最高有效位)。每个周期执行：\n- 将连接的 $AQ$ 左移一位，得到\n$$A \\leftarrow (A \\ll 1) + q_{3}^{(\\text{current})}, \\quad Q \\leftarrow (Q \\ll 1) \\text{ with } Q_{0}=0,$$\n其中 $q_{3}^{(\\text{current})}$ 是 $Q$ 当前的最高有效位。\n- 用二进制补码从 $A$ 中减去 $M$：\n$$A \\leftarrow A - M.$$\n- 如果 $A$ 的符号位为 $1$ (即，在二进制补码中 $A - M  0$), 执行恢复步骤：\n$$A \\leftarrow A + M.$$\n\n关键观察：在周期 $k$ 的减法之前，$A$ 中的值等于原始被除数 $Q$ 的 $k$ 位前缀。这可以通过归纳法得出：\n- 对于 $k=1$, $A_{1}=(0 \\ll 1)+q_{3}=q_{3}$。\n- 如果 $A_{k}$ 等于 $k$ 位前缀 $q_{3}q_{2}\\dots q_{4-k}$，那么在下一次移位后，\n$A_{k+1}=(A_{k} \\ll 1) + q_{3-k}$\n这正是 $(k+1)$ 位前缀 $q_{3}q_{2}\\dots q_{4-k}q_{3-k}$。\n\n因此，在周期 $k$ 中，当且仅当 $A_{k} - M  0$ 时，减法结果为负（符号位为 $1$）。由于 $A_{k}$ 和 $M$ 是 $\\{0,1,\\dots,15\\}$ 中的非负整数，这等价于不等式\n$A_{k}  M.$\n因此，当且仅当以下条件成立时，四个周期中的每一个周期都会发生恢复步骤：\n$A_{1}  M,\\quad A_{2}  M,\\quad A_{3}  M,\\quad A_{4}  M,$\n其中 $A_{k}$ 是被除数的 $k$ 位前缀。\n\n评估每个选项：\n\nA. 被除数 $12$（二进制为 $1100_{2}$）且 $M=3$。\n- $A_{1}=1$，所以 $1  3$ 成立（恢复）。\n- $A_{2}=3$，所以 $3  3$ 为假；$A_{2}-M=0$ 是非负数（不恢复）。\n因此并非所有周期都恢复。\n\nB. 被除数 $9$（二进制为 $1001_{2}$）且 $M=4$。\n- $A_{1}=1$, 所以 $1  4$ (恢复)。\n- $A_{2}=2$, 所以 $2  4$ (恢复)。\n- $A_{3}=4$，所以 $4  4$ 为假；非负数（不恢复）。\n因此并非所有周期都恢复。\n\nC. 被除数 $7$（二进制为 $0111_{2}$）且 $M=8$。\n- $A_{1}=0$, 所以 $0  8$ (恢复)。\n- $A_{2}=1$, 所以 $1  8$ (恢复)。\n- $A_{3}=3$, 所以 $3  8$ (恢复)。\n- $A_{4}=7$, 所以 $7  8$ (恢复)。\n所有四个周期都需要恢复。\n\nD. 被除数 $15$（二进制为 $1111_{2}$）且 $M=2$。\n- $A_{1}=1$, 所以 $1  2$ (恢复)。\n- $A_{2}=3$，所以 $3  2$ 为假；非负数（不恢复）。\n因此并非所有周期都恢复。\n\n只有选项C满足对于 $k=1,2,3,4$ 都有 $A_{k}  M$。", "answer": "$$\\boxed{C}$$", "id": "1958391"}]}