{"hands_on_practices": [{"introduction": "决定使用跨位进位加法器（CSA）而非更简单的行波进位加法器（RCA）是复杂度与性能之间的经典工程权衡。本练习将指导你进行定量分析，以确定 CSA 速度更快的确切条件。通过为两种架构的最坏情况延迟建模，你将找到在何种最小位宽下，CSA 的旁路机制能够提供切实的性能优势 [@problem_id:1919270]。", "problem": "一个数字设计团队正在评估两种不同的 $n$ 位加法器架构，用于定制处理器：一种是简单的串行进位加法器（RCA），另一种是更复杂的跳跃进位加法器（CSA）。加法器的性能，以其最坏情况传播延迟来衡量，是选择的主要标准。\n\n该团队为其制造工艺确定了以下时序参数：\n- 单个1位全加器从进位输入到进位输出的传播延迟为 $t_{carry} = 0.8$ ns。\n- 单个1位全加器从进位输入到和输出的传播延迟为 $t_{sum} = 1.0$ ns。\n\n对于跳跃进位加法器，使用固定的块大小 $k=4$ 位。因此，总位数 $n$ 必须是4的倍数。一个4位块的跳跃进位逻辑已被设计和表征，其参数如下：\n- 进位信号旁路或“跳跃”一个4位块的传播延迟为 $t_{skip} = 1.2$ ns。\n\n$n$ 位RCA的最坏情况延迟是指在最低有效位产生一个进位，并传播到最高有效位以产生最终的和位所需的时间。$n$ 位CSA（其中有 $m = n/k$ 个块，且 $m \\ge 2$）的最坏情况路径包括进位在第一个块内串行传播，跳过 $m-2$ 个中间块，最后在最后一个块内串行传播以产生最终的和位所需的时间。\n\n确定最小整数位宽 $n$，使得 $n$ 位跳跃进位加法器严格快于（即具有更小的最坏情况传播延迟） $n$ 位串行进位加法器。", "solution": "令 $t_{carry}$ 为1位全加器从进位输入到进位输出的延迟，$t_{sum}$ 为1位全加器从进位输入到和输出的延迟，$t_{skip}$ 为跳跃进位加法器中每个 $k$ 位块的跳跃延迟，$k=4$ 为固定块大小，$n$ 为总位宽（$k$的倍数），$m=n/k$ 为块的数量。\n\n对于一个 $n$ 位串行进位加法器（RCA），最坏情况延迟是进位传播过 $n-1$ 级，然后产生最终的和：\n$$\nT_{\\mathrm{RCA}}(n) = (n-1)\\,t_{carry} + t_{sum}.\n$$\n\n对于一个具有 $m\\ge 2$ 个块的 $n$ 位跳跃进位加法器（CSA），最坏情况延迟路径是进位在第一个块内串行传播，跳过 $m-2$ 个中间块，然后在最后一个块内串行传播以产生最终的和。在第一个块内串行传播的延迟是 $k\\,t_{carry}$，跳过 $m-2$ 个块的延迟是 $(m-2)\\,t_{skip}$，在最后一个块内串行传播到最高有效和的延迟是 $(k-1)\\,t_{carry}+t_{sum}$。因此，\n$$\nT_{\\mathrm{CSA}}(n) = k\\,t_{carry} + (m-2)\\,t_{skip} + (k-1)\\,t_{carry} + t_{sum}\n= (2k-1)\\,t_{carry} + (m-2)\\,t_{skip} + t_{sum}.\n$$\n当 $m=\\frac{n}{k}$ 且 $k=4$ 时，\n$$\nT_{\\mathrm{CSA}}(n) = 7\\,t_{carry} + \\left(\\frac{n}{4}-2\\right)t_{skip} + t_{sum}.\n$$\n\n我们要求 $T_{\\mathrm{CSA}}(n)  T_{\\mathrm{RCA}}(n)$：\n$$\n7\\,t_{carry} + \\left(\\frac{n}{4}-2\\right)t_{skip} + t_{sum}  (n-1)\\,t_{carry} + t_{sum}.\n$$\n消去 $t_{sum}$ 并重新整理：\n$$\n(n-1)\\,t_{carry} - 7\\,t_{carry} > \\left(\\frac{n}{4}-2\\right)t_{skip}\n\\;\\;\\Longrightarrow\\;\\;\n(n-8)\\,t_{carry} > \\left(\\frac{n}{4}-2\\right)t_{skip} = \\frac{n-8}{4}\\,t_{skip}.\n$$\n对于 $m\\ge 2$，我们有 $n\\ge 8$。考虑：\n- 如果 $n=8$，等式两边都为零，得到的是等式，而不是严格不等式。\n- 如果 $n>8$，则 $n-8>0$，我们可以两边同除以 $(n-8)$ 得到\n$$\nt_{carry} > \\frac{1}{4}\\,t_{skip}.\n$$\n代入给定值 $t_{carry}=0.8$ ns 和 $t_{skip}=1.2$ ns，\n$$\n0.8 > \\frac{1}{4}\\cdot 1.2 = 0.3,\n$$\n该不等式成立。因此，对于所有大于8且为4的倍数的 $n$，CSA都严格快于RCA。满足条件的最小 $n$（且 $m\\ge 2$）是 $n=12$。\n\n快速验算：\n$$\nT_{\\mathrm{CSA}}(12) = 7\\cdot 0.8 + 1\\cdot 1.2 + t_{sum} = 6.8 + t_{sum},\\quad\nT_{\\mathrm{RCA}}(12) = 11\\cdot 0.8 + t_{sum} = 8.8 + t_{sum},\n$$\n所以当 $n=12$ 时，CSA 严格更快。", "answer": "$$\\boxed{12}$$", "id": "1919270"}, {"introduction": "虽然均匀分块为 CSA 设计提供了一个简单的起点，但使用非均匀分块通常可以实现更优越的性能。这个高级设计挑战要求你基于平衡延迟路径的核心原则，通过策略性地改变块大小来构建一个 32 位加法器 [@problem_id:1919293]。这种做法反映了构建高速算术电路所使用的关键优化技术，需要你求解一个约束系统以找到理想的配置。", "problem": "一位电气工程师的任务是设计一个高性能的32位跳跃进位加法器。为了优化加法器的速度，采用了非均匀分块策略。该设计受到一系列特定的架构和时序约束。\n\n**物理与时序模型：**\n- 进位通过单个全加器级的传播时间表示为 $t_{prop}$。\n- 进位“跳跃”过整个块所需的时间（假设组传播信号已准备好）表示为 $t_{skip}$。\n- 对于此特定技术，已知 $t_{skip} = 2 t_{prop}$。\n\n**架构约束：**\n- 该32位加法器由总共 $M=6$ 个块构成。\n- 块大小围绕加法器中心对称排列，遵循模式 $[k_1, k_2, k_3, k_3, k_2, k_1]$，其中 $k_i$ 是第 $i$ 个块的大小。\n- 设计必须恰好使用三种不同的正整数块大小，表示为 $S_A, S_B$ 和 $S_C$，并按 $S_A  S_B  S_C$ 的顺序排列。\n\n**优化原则：**\n加法器中的最坏情况进位传播延迟需要被最小化。这个最优值是通过平衡两条关键延迟路径来实现的：\n1.  **最大块内行波延迟 ($T_{ripple}$):** 进位在加法器最大块的所有级中传播所需的时间。进位在一个大小为 $k$ 的块中行波传播的时间是 $k \\cdot t_{prop}$。\n2.  **主跳跃路径延迟 ($T_{skip-path}$):** 源自第一个块起始处的进位信号，通过该块传播，跳过所有中间块，然后通过最后一个块传播所需的时间。该延迟被建模为第一个块中的行波时间、跨越 $M-2$ 个中间块的跳跃时间以及最后一个块中的行波时间之和。\n\n你的任务是确定满足所有这些条件的三个整数块大小 $S_A, S_B$ 和 $S_C$ 的值。将你的答案表示为一个包含三个整数的行矩阵 $[S_A, S_B, S_C]$。", "solution": "我们用对称模式 $[k_1, k_2, k_3, k_3, k_2, k_1]$ 表示这六个块的大小。总位数为32，因此块大小之和为：\n$$ 2(k_1 + k_2 + k_3) = 32 \\implies k_1 + k_2 + k_3 = 16 $$\n设计中有三种不同的正整数块大小，记为 $S_A  S_B  S_C$。因此，集合 $\\{k_1, k_2, k_3\\}$ 必须是集合 $\\{S_A, S_B, S_C\\}$ 的一个排列。\n\n接下来，我们为两条关键延迟路径建立模型：\n1.  **最大块内行波延迟 ($T_{ripple}$):** 这是进位在最大块（大小为 $S_C$）中传播所需的时间。\n    $$ T_{ripple} = S_C \\cdot t_{prop} $$\n2.  **主跳跃路径延迟 ($T_{skip-path}$):** 这是进位在第一个块（大小为 $k_1$）中行波传播，跳过中间的四个块，然后在最后一个块（大小也为 $k_1$）中行波传播所需的时间之和。\n    $$ T_{skip-path} = (k_1 \\cdot t_{prop}) + (4 \\cdot t_{skip}) + (k_1 \\cdot t_{prop}) $$\n    利用给定的时序关系 $t_{skip} = 2 t_{prop}$，我们得到：\n    $$ T_{skip-path} = 2k_1 \\cdot t_{prop} + 4(2 t_{prop}) = (2k_1 + 8) \\cdot t_{prop} $$\n\n优化的目标是平衡这两条路径的延迟，即 $T_{ripple} = T_{skip-path}$：\n$$ S_C \\cdot t_{prop} = (2k_1 + 8) \\cdot t_{prop} \\implies S_C = 2k_1 + 8 $$\n由于 $k_1$ 是一个正整数，这个关系式意味着 $S_C$ 必须大于 $k_1$。因此，$k_1$ 不能是最大的块 $S_C$。$k_1$ 只能是 $S_A$ 或 $S_B$。\n\n**情况一：$k_1 = S_A$**\n此时，$S_C = 2S_A + 8$。将此代入块大小总和方程 $S_A + S_B + S_C = 16$：\n$$ S_A + S_B + (2S_A + 8) = 16 \\implies 3S_A + S_B = 8 $$\n我们寻找满足 $S_A  S_B$ 的正整数解：\n- 如果 $S_A = 1$，则 $3(1) + S_B = 8 \\implies S_B = 5$。这满足 $1  5$。由此可得 $S_C = 2(1) + 8 = 10$。块大小集合为 $\\{1, 5, 10\\}$，满足 $S_A  S_B  S_C$。这是一个有效的解。\n- 如果 $S_A = 2$，则 $3(2) + S_B = 8 \\implies S_B = 2$。这不满足 $S_A  S_B$。\n\n**情况二：$k_1 = S_B$**\n此时，$S_C = 2S_B + 8$。将此代入总和方程 $S_A + S_B + S_C = 16$：\n$$ S_A + S_B + (2S_B + 8) = 16 \\implies S_A + 3S_B = 8 $$\n我们寻找满足 $S_A  S_B$ 的正整数解：\n- 如果 $S_B = 1$，则 $S_A = 5$。这不满足 $S_A  S_B$。\n- 如果 $S_B = 2$，则 $S_A = 2$。这不满足 $S_A  S_B$。\n\n因此，唯一有效的解是块大小集合 $\\{1, 5, 10\\}$。按升序排列，我们得到 $S_A=1, S_B=5, S_C=10$。\n答案以行矩阵 $[S_A, S_B, S_C]$ 的形式表示为 $[1, 5, 10]$。", "answer": "$$\\boxed{\\begin{pmatrix}1  5  10\\end{pmatrix}}$$", "id": "1919293"}, {"introduction": "设计电路只是工作的一半；确保其制造正确同样至关重要。这个问题让你扮演测试工程师的角色，负责验证跨位进位加法器的功能性 [@problem_id:1919283]。为了解决它，你必须精确定位能激活跨位进位路径的输入条件，从而揭示“固定型”故障，这体现了理解电路内部逻辑对于有效测试的重要性。", "problem": "一位工程师正在测试一个定制16位处理器的算术逻辑单元 (ALU)。该ALU的加法器是一个由四个4位串行进位加法器模块构成的进位跳跃加法器。这些模块分别表示为 B1（用于位0-3）、B2（用于位4-7）、B3（用于位8-11）和 B4（用于位12-15），其中位0是最低有效位 (LSB)。\n\n每个模块 $k$ 的跳跃逻辑操作如下：\n- 位级传播信号定义为 $p_i = A_i \\oplus B_i$，其中 $A_i$ 和 $B_i$ 是输入位。\n- 模块 $k$ 的组传播信号，记为 $P_k$，为真 ($P_k=1$) 当且仅当该模块内所有的位级传播信号都为真。\n- 模块 $k$ 的进位输出 $C_{out,k}$ 由其进位输入 $C_{in,k}$、组传播信号 $P_k$ 以及其内部生成的串行进位 $C_{ripple,k}$ 决定。逻辑方程为 $C_{out,k} = C_{ripple,k} + (P_k \\cdot C_{in,k})$，其中 '+' 符号表示逻辑或。$C_{ripple,k}$ 是假设模块 $k$ 的进位输入为0时，其4位串行进位链产生的进位输出。\n\n怀疑模块 B3 存在制造缺陷。故障模型为跳跃逻辑“卡在串行进位”，意味着模块 B3 的进位输出始终等于其内部串行进位，即 $C_{out,3} = C_{ripple,3}$。此故障实际上禁用了该模块的进位跳跃功能。\n\n下列哪个测试向量（以 $(A, B, C_{in,0})$ 形式指定）可用于检测此故障？操作数 $A$ 和 $B$ 以4位十六进制数给出，$C_{in,0}$ 是整个加法器的初始进位输入。\n\nA. $(A=\\text{0F0F}_{16}, B=\\text{F0F0}_{16}, C_{in,0}=1)$\n\nB. $(A=\\text{F0F0}_{16}, B=\\text{0F0F}_{16}, C_{in,0}=0)$\n\nC. $(A=\\text{00FF}_{16}, B=\\text{00FF}_{16}, C_{in,0}=1)$\n\nD. $(A=\\text{8000}_{16}, B=\\text{7FFF}_{16}, C_{in,0}=0)$\n\nE. $(A=\\text{FFFF}_{16}, B=\\text{FFFF}_{16}, C_{in,0}=0)$", "solution": "我们使用给定的4位模块的进位跳跃关系式：\n$$C_{out,k}^{good} = C_{ripple,k} + \\left(P_{k}\\, C_{in,k}\\right),$$\n以及在模块 B3 (位 8–11) 存在故障的情况下，\n$$C_{out,3}^{fault} = C_{ripple,3}.$$\n在 B3 的输出端，正常输出与故障输出之间出现差异当且仅当\n$$P_{3}=1,\\quad C_{in,3}=1,\\quad C_{ripple,3}=0.$$\n此外，如果 $P_{3}=1$，则 B3 中所有的位传播信号都满足 $p_{i}=1$ (对于 $i=8,\\dots,11$)，这意味着每个位上的 $A_{i}\\neq B_{i}$，因此没有位会产生进位 ($A_{i}B_{i}=0$ 对于所有 $i$)。当块的进位输入为0时，内部串行进位链不产生进位输出，因此\n$$P_{3}=1\\;\\Longrightarrow\\;C_{ripple,3}=0.$$\n因此，可检测性条件简化为 $P_{3}=1$ 和 $C_{in,3}=1$。后者是 B2 的进位输出：\n$$C_{in,3}=C_{out,2}=C_{ripple,2}+\\left(P_{2}\\, C_{in,2}\\right),\\quad C_{in,2}=C_{out,1}=C_{ripple,1}+\\left(P_{1}\\, C_{in,1}\\right), \\text{ and } C_{in,1}=C_{in,0}.$$\n对于每个4位模块 $k$，$P_{k}=1$ 当且仅当 $A$ 和 $B$ 对应的十六进制半字节是按位互补的（异或结果为 $F$），而 $C_{ripple,k}$ 等于这两个半字节在零进位输入下相加的进位输出（即，当且仅当半字节之和至少为16时，它为1）。\n\n按半字节 $D_{3}D_{2}D_{1}D_{0}$ （其中 $D_{2}$ 对应 B3）评估每个选项：\n\nA. $A=\\text{0F0F}_{16}$，$B=\\text{F0F0}_{16}$，$C_{in,0}=1$。\n- B3 (半字节 $D_{2}$): $A_2=0\\text{F}_{16}, B_2=0\\text{0}_{16}$。半字节不正确，应该是 $A=\\text{0F0F}$, $D_2$ 是 $F$. B=$F0F0$, $D_2$是 $0$. 所以 $A_2=0xF, B_2=0x0$。因此 $P_{3}=1$ 且 $C_{ripple,3}=0$。\n- B1 ($D_{0}$): $A_0=0\\text{F}_{16}, B_0=0\\text{0}_{16}$。$P_{1}=1, C_{ripple,1}=0$。$C_{in,1}=C_{in,0}=1$。因此 $C_{out,1}=0+(1\\cdot 1)=1$。\n- B2 ($D_{1}$): $A_1=0\\text{0}_{16}, B_1=0\\text{F}_{16}$。$P_{2}=1, C_{ripple,2}=0$。$C_{in,2}=C_{out,1}=1$。因此 $C_{out,2}=0+(1\\cdot 1)=1$。\n因此 $C_{in,3}=1$ 且 $P_{3}=1$。正常情况：$C_{out,3}^{good}=0+(1\\cdot 1)=1$。故障情况：$C_{out,3}^{fault}=0$。故障被检测到。\n\nB. $A=\\text{F0F0}_{16}$，$B=\\text{0F0F}_{16}$，$C_{in,0}=0$。\n- B3 ($D_{2}$): $A_2=0\\text{0}_{16}, B_2=0\\text{F}_{16}$，所以 $P_{3}=1, C_{ripple,3}=0$。\n- B1 ($D_{0}$): $A_0=0\\text{0}_{16}, B_0=0\\text{F}_{16}$。$P_{1}=1, C_{ripple,1}=0$。$C_{in,1}=C_{in,0}=0$，所以 $C_{out,1}=0$。\n- B2 ($D_{1}$): $A_1=0\\text{F}_{16}, B_1=0\\text{0}_{16}$。$P_{2}=1, C_{ripple,2}=0$。$C_{in,2}=C_{out,1}=0$，所以 $C_{out,2}=0$。\n因此 $C_{in,3}=0$。正常情况：$C_{out,3}^{good}=0+(1\\cdot 0)=0$。故障情况：$0$。未检测到。\n\nC. $A=\\text{00FF}_{16}$，$B=\\text{00FF}_{16}$，$C_{in,0}=1$。\n- B3 ($D_{2}$): $A_2=0\\text{0}_{16}, B_2=0\\text{0}_{16}$，所以 $P_{3}=0$。那么 $C_{out,3}^{good}=C_{ripple,3}$ 等于 $C_{out,3}^{fault}$。未检测到。\n\nD. $A=\\text{8000}_{16}$，$B=\\text{7FFF}_{16}$，$C_{in,0}=0$。\n- B3 ($D_{2}$): $A_2=0\\text{0}_{16}, B_2=0\\text{F}_{16}$，所以 $P_{3}=1, C_{ripple,3}=0$。\n- B1 ($D_{0}$): $A_0=0\\text{0}_{16}, B_0=0\\text{F}_{16}$。$P_{1}=1, C_{ripple,1}=0$，$C_{in,0}=0$，所以 $C_{out,1}=0$。\n- B2 ($D_{1}$): $A_1=0\\text{0}_{16}, B_1=0\\text{F}_{16}$。$P_{2}=1, C_{ripple,2}=0$，$C_{in,2}=0$，所以 $C_{out,2}=0$。\n因此 $C_{in,3}=0$。正常情况：$C_{out,3}^{good}=0$。故障情况：$0$。未检测到。\n\nE. $A=\\text{FFFF}_{16}$，$B=\\text{FFFF}_{16}$，$C_{in,0}=0$。\n- B3 ($D_{2}$): $A_2=0\\text{F}_{16}, B_2=0\\text{F}_{16}$，所以 $P_{3}=0$。那么 $C_{out,3}^{good}=C_{ripple,3}$ 等于 $C_{out,3}^{fault}$。未检测到。\n\n只有选项 A 满足 $P_{3}=1$ 和 $C_{in,3}=1$，因此它能检测到该故障。$C_{out,3}$ 中产生的差异会传播到最高有效位模块（以及最终的进位），从而保证在输出端的可观察性。", "answer": "$$\\boxed{A}$$", "id": "1919283"}]}