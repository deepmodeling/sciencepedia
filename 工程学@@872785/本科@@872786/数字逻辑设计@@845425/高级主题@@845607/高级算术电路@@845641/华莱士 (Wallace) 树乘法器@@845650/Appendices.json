{"hands_on_practices": [{"introduction": "在应用华莱士树复杂的缩减逻辑之前，我们必须首先理解其输入：部分积矩阵。这个练习将带你构想一个$4 \\times 6$乘法的部分积矩阵，这对于任何并行乘法器设计都是关键的第一步。通过确定部分积的总数和最高列的高度，你将学会如何量化乘法问题的初始复杂度，为后续的缩减阶段打下基础 [@problem_id:1977426]。", "problem": "在数字运算中，两个无符号二进制数相乘是一项基本操作。考虑一个4位无符号数（被乘数）与一个6位无符号数（乘数）相乘的情况。乘积是通过首先生成一个部分积数组，然后将它们相加而形成的。\n\n设4位被乘数为 $A$，其位为 $A_3A_2A_1A_0$；6位乘数为 $B$，其位为 $B_5B_4B_3B_2B_1B_0$。一个部分积项是由被乘数位 $A_i$ 和乘数位 $B_j$ 进行逻辑与运算形成的。该项在最终和中的权重为 $2^{i+j}$。\n\n在执行任何加法或规约操作（例如，使用华莱士树（Wallace Tree）或进位保留加法器（Carry-Save Adder）阵列）之前，这些单独的部分积位在概念上是根据其二进制权重排列成列的。所有具有相同权重 $2^k$（即 $i+j$ 的值相同）的项都属于同一列，称之为第 $k$ 列。一列的“高度”是它所包含的部分积位的数量。\n\n确定此 $4 \\times 6$ 乘法的以下两个量：\n1. 生成的部分积位的总数。\n2. 初始部分积矩阵中最高列的高度。\n\n将这两个整数答案以行矩阵的形式提供，其中总位数作为第一个元素，最高列的高度作为第二个元素。", "solution": "问题要求解 $4 \\times 6$ 无符号二进制乘法初始部分积矩阵的两个属性。被乘数 $A$ 为4位宽，因此其位的索引为 $i \\in \\{0, 1, 2, 3\\}$。乘数 $B$ 为6位宽，因此其位的索引为 $j \\in \\{0, 1, 2, 3, 4, 5\\}$。\n\n**第1部分：部分积位的总数**\n\n一个部分积位是由被乘数的一个位 $A_i$ 与乘数的一个位 $B_j$ 进行逻辑与运算形成的。由于被乘数有4位，乘数有6位，因此每个操作数各取一位的每种组合都形成一个唯一的部分积。\n\n因此，部分积位的总数是被乘数的位数与乘数的位数的乘积。\n\n部分积位总数 = ($A$的宽度) $\\times$ ($B$的宽度)\n$$ \\text{总位数} = 4 \\times 6 = 24 $$\n这是我们答案的第一部分。\n\n**第2部分：最高列的高度**\n\n部分积位根据其权重 $2^k$ 排列成列，其中列索引 $k$ 由位索引之和给出，$k = i + j$。第 $k$ 列的高度是满足 $i+j=k$ 的数对 $(i, j)$ 的数量，约束条件为 $0 \\le i \\le 3$ 和 $0 \\le j \\le 5$。\n\n我们可以通过为每个 $k$ 枚举有效的 $(i,j)$ 数对来系统地确定每列的高度：\n\n- **第 $k=0$ 列**：$i+j=0$。唯一有效的数对是 $(i,j)=(0,0)$。高度 = 1。\n- **第 $k=1$ 列**：$i+j=1$。有效的数对是 $(0,1)$ 和 $(1,0)$。高度 = 2。\n- **第 $k=2$ 列**：$i+j=2$。有效的数对是 $(0,2)$、$(1,1)$ 和 $(2,0)$。高度 = 3。\n- **第 $k=3$ 列**：$i+j=3$。有效的数对是 $(0,3)$、$(1,2)$、$(2,1)$ 和 $(3,0)$。高度 = 4。\n- **第 $k=4$ 列**：$i+j=4$。有效的数对是 $(0,4)$、$(1,3)$、$(2,2)$ 和 $(3,1)$。高度 = 4。\n- **第 $k=5$ 列**：$i+j=5$。有效的数对是 $(0,5)$、$(1,4)$、$(2,3)$ 和 $(3,2)$。高度 = 4。\n- **第 $k=6$ 列**：$i+j=6$。有效的数对是 $(1,5)$、$(2,4)$ 和 $(3,3)$。数对 $(0,6)$ 无效，因为 $j_{max}=5$。高度 = 3。\n- **第 $k=7$ 列**：$i+j=7$。有效的数对是 $(2,5)$ 和 $(3,4)$。高度 = 2。\n- **第 $k=8$ 列**：$i+j=8$。唯一有效的数对是 $(3,5)$。高度 = 1。\n- **第 $k=9$ 列**：$i+j=9$。不存在有效的数对。例如，$(3,6)$ 中 $j5$。高度 = 0。\n\n列高度的序列是 (1, 2, 3, 4, 4, 4, 3, 2, 1)。我们可以通过将这些高度相加来验证：$1+2+3+4+4+4+3+2+1 = 24$，这与第一部分计算的部分积位总数相符。\n\n通过检查高度序列，最大值为4。这出现在第 $k=3, 4, 5$ 列。\n\n因此，最高列的高度是4。这是我们答案的第二部分。\n\n两个所求的值都已确定。部分积位的总数是24，最高列的高度是4。", "answer": "$$\\boxed{\\begin{pmatrix} 24  4 \\end{pmatrix}}$$", "id": "1977426"}, {"introduction": "理解了初始矩阵的构成后，现在让我们深入华莱士树的核心机制：多级缩减过程。这个练习将指导你完整地完成一个$5 \\times 5$乘法器的缩减阶段，你需要追踪每一级所使用的全加器和半加器数量。通过这个过程，你将具体理解华莱士树是如何高效地将多行部分积压缩为最终两行，从而实现其高速运算的优势 [@problem_id:1977482]。", "problem": "在设计一个高速算术逻辑单元时，一位工程师正在使用华莱士树（Wallace tree）结构实现一个用于两个5位二进制数的无符号硬件乘法器。该乘法器首先生成一个部分积矩阵。然后通过一系列归约阶段将该矩阵化简为一个两行的矩阵。最后两行再使用一个常规的进位传播加法器进行相加。\n\n归约过程分阶段进行。在每个阶段，矩阵每一列内的位（bit）都根据贪心策略使用全加器（FA）和半加器（HA）进行归约：\n- 一个全加器以同一列中的三个位作为输入，为该列生成一个一位的和输出，并为下一个更高位（更有效）的列生成一个一位的进位输出。\n- 一个半加器以同一列中的两个位作为输入，为该列生成一个一位的和输出，并为下一个更高位的列生成一个一位的进位输出。\n\n在每一列中，会使用尽可能多的全加器。如果在形成三位数组后剩下两个位，则使用一个半加器。如果只剩下一个位，它将直接传递到下一阶段的同一列。来自加法器的和位以及任何直接传递的位，与来自相邻低位列的进位位一起，构成了下一阶段该列的行。重复此过程，直到矩阵中没有一列的位数超过两个。\n\n计算这个 $5 \\times 5$ 华莱士树乘法器的整个归约阶段所需的全部全加器和半加器的数量。以整数对 `(Total FAs, Total HAs)` 的形式给出你的答案。", "solution": "设两个5位无符号数为 $A = a_4a_3a_2a_1a_0$ 和 $B = b_4b_3b_2b_1b_0$。乘法 $A \\times B$ 会产生25个部分积位，$p_{ij} = a_i \\cdot b_j$。这些位根据其位权重移位后排列成一个矩阵。乘积最多可有 $5+5=10$ 位，因此列的索引从 C0（最低有效位）到 C9（最高有效位）。\n\n首先，我们确定初始部分积矩阵中每一列的位数（即高度）。\n- C0：1位 ($p_{00}$)\n- C1：2位 ($p_{01}, p_{10}$)\n- C2：3位 ($p_{02}, p_{11}, p_{20}$)\n- C3：4位 ($p_{03}, p_{12}, p_{21}, p_{30}$)\n- C4：5位 ($p_{04}, p_{13}, p_{22}, p_{31}, p_{40}$)\n- C5：4位 ($p_{14}, p_{23}, p_{32}, p_{41}$)\n- C6：3位 ($p_{24}, p_{33}, p_{42}$)\n- C7：2位 ($p_{34}, p_{43}$)\n- C8：1位 ($p_{44}$)\n- C9：0位\n\n初始的列高度向量 `N0`（从 C9 到 C0）是 `[0, 1, 2, 3, 4, 5, 4, 3, 2, 1]`。最大高度为5，因此需要进行归约。\n\n**归约阶段 1：**\n我们对 `N0` 的每一列应用加法器。对于高度为 $k$ 的列，我们使用 $\\lfloor k/3 \\rfloor$ 个全加器和 $\\lfloor (k \\pmod 3) / 2 \\rfloor$ 个半加器。每个全加器产生一个和位和一个进位位。每个半加器也产生一个和位和一个进位位。\n- C0 (k=1)：无加法器。1个位直接通过。(s=1, c=0)\n- C1 (k=2)：1个半加器。(s=1, c=1)。总计：1个半加器。\n- C2 (k=3)：1个全加器。(s=1, c=1)。总计：1个全加器，1个半加器。\n- C3 (k=4)：1个全加器，剩余1个位。(s=2, c=1)。总计：2个全加器，1个半加器。\n- C4 (k=5)：1个全加器，剩余2个位 - 1个半加器。(s=2, c=2)。总计：3个全加器，2个半加器。\n- C5 (k=4)：1个全加器，剩余1个位。(s=2, c=1)。总计：4个全加器，2个半加器。\n- C6 (k=3)：1个全加器。(s=1, c=1)。总计：5个全加器，2个半加器。\n- C7 (k=2)：1个半加器。(s=1, c=1)。总计：5个全加器，3个半加器。\n- C8 (k=1)：无加法器。1个位直接通过。(s=1, c=0)\n- C9 (k=0)：无位。(s=0, c=0)\n\n阶段1使用的加法器：**5个全加器，3个半加器**。\n\n现在，我们计算下一阶段的列高度 `N1`。第 `i` 列的高度是当前阶段第 `i` 列的和位数与第 `i-1` 列的进位数之和。\n`N1[i] = s_i + c_{i-1}`\n- N1[0] = 1 (s0)\n- N1[1] = 1 (s1) + 0 (c0) = 1\n- N1[2] = 1 (s2) + 1 (c1) = 2\n- N1[3] = 2 (s3) + 1 (c2) = 3\n- N1[4] = 2 (s4) + 1 (c3) = 3\n- N1[5] = 2 (s5) + 2 (c4) = 4\n- N1[6] = 1 (s6) + 1 (c5) = 2\n- N1[7] = 1 (s7) + 1 (c6) = 2\n- N1[8] = 1 (s8) + 1 (c7) = 2\n- N1[9] = 0 (s9) + 0 (c8) = 0\n列高度向量 `N1` 是 `[0, 2, 2, 2, 4, 3, 3, 2, 1, 1]`。最大高度为4。\n\n**归约阶段 2：**\n我们对 `N1` 重复此过程。\n- C0 (k=1), C1 (k=1)：直接通过。(s=1, c=0)\n- C2 (k=2)：1个半加器。(s=1, c=1)。总计：1个半加器。\n- C3 (k=3)：1个全加器。(s=1, c=1)。总计：1个全加器，1个半加器。\n- C4 (k=3)：1个全加器。(s=1, c=1)。总计：2个全加器，1个半加器。\n- C5 (k=4)：1个全加器，剩余1个位。(s=2, c=1)。总计：3个全加器，1个半加器。\n- C6 (k=2)：1个半加器。(s=1, c=1)。总计：3个全加器，2个半加器。\n- C7 (k=2)：1个半加器。(s=1, c=1)。总计：3个全加器，3个半加器。\n- C8 (k=2)：1个半加器。(s=1, c=1)。总计：3个全加器，4个半加器。\n- C9 (k=0)：无位。\n\n阶段2使用的加法器：**3个全加器，4个半加器**。\n\n计算 `N2`：\n- N2[0]=1, N2[1]=1, N2[2]=1, N2[3]=2, N2[4]=2, N2[5]=3, N2[6]=2, N2[7]=2, N2[8]=2, N2[9]=1。\n列高度向量 `N2` 是 `[1, 2, 2, 2, 3, 2, 2, 1, 1, 1]`。最大高度为3。\n\n**归约阶段 3：**\n我们对 `N2` 重复此过程。\n- C0,C1,C2 (k=1)：直接通过。(s=1, c=0)\n- C3 (k=2)：1个半加器。(s=1, c=1)。总计：1个半加器。\n- C4 (k=2)：1个半加器。(s=1, c=1)。总计：2个半加器。\n- C5 (k=3)：1个全加器。(s=1, c=1)。总计：1个全加器，2个半加器。\n- C6 (k=2)：1个半加器。(s=1, c=1)。总计：1个全加器，3个半加器。\n- C7 (k=2)：1个半加器。(s=1, c=1)。总计：1个全加器，4个半加器。\n- C8 (k=2)：1个半加器。(s=1, c=1)。总计：1个全加器，5个半加器。\n- C9 (k=1)：直接通过。(s=1, c=0)\n\n阶段3使用的加法器：**1个全加器，5个半加器**。\n\n计算 `N3`：\n- N3[0]=1, N3[1]=1, N3[2]=1, N3[3]=1, N3[4]=2, N3[5]=2, N3[6]=2, N3[7]=2, N3[8]=2, N3[9]=2。\n列高度向量 `N3` 是 `[2, 2, 2, 2, 2, 2, 1, 1, 1, 1]`。最大高度为2，因此归约阶段完成。\n\n**总加法器数：**\n为了求出加法器的总数，我们将每个阶段的计数相加。\n- 总全加器数 = (阶段1的全加器数) + (阶段2的全加器数) + (阶段3的全加器数) = $5 + 3 + 1 = 9$。\n- 总半加器数 = (阶段1的半加器数) + (阶段2的半加器数) + (阶段3的半加器数) = $3 + 4 + 5 = 12$。\n\n整个归约阶段需要9个全加器和12个半加器。", "answer": "$$\\boxed{\\begin{pmatrix} 9  12 \\end{pmatrix}}$$", "id": "1977482"}, {"introduction": "电路设计的理论知识在应用于硬件测试和调试等实际场景时才真正显示出其威力。这个问题模拟了一个常见的硬件故障——“固定为0”错误，并要求你分析它对乘法器输出的影响。通过计算这个位于华莱士树特定位置的故障所导致的最终乘积误差，你将亲身体会到单个局部故障是如何对电路输出产生可预测、可量化的影响，从而加深对电路内部数据流重要性的理解 [@problem_id:1977496]。", "problem": "一位工程师正在设计一个采用 Wallace 树架构的 5 位无符号二进制乘法器。该乘法器用于计算一个 5 位被乘数 $A = a_4a_3a_2a_1a_0$ 和一个 5 位乘数 $B = b_4b_3b_2b_1b_0$ 的乘积。操作数的位从 0 到 4 索引，其中第 0 位是最低有效位 (LSB)，第 4 位是最高有效位 (MSB)。在此架构中，初始步骤是生成一个部分积阵列。由逻辑与运算 $a_j \\land b_i$ 产生的位被放置在对应位权重为 $2^{j+i}$ 的列中。\n\n然后，Wallace 树使用多个阶段的并行加法器来压缩此部分积阵列。第一压缩阶段接收初始阵列，并应用全加器 (FA) 和半加器 (HA) 来减少行数。全加器是一种数字逻辑电路，它接收来自同一列的三个输入位，并产生一个和位和一个进位输出位。和位保留在同一列中以用于后续阶段，而进位输出位则传递到下一个更高有效位的列（即第 $k+1$ 列）以用于后续阶段。\n\n在制造后测试期间，发现了一个缺陷。在第一压缩阶段中，处理需要全加器的最高有效位列中各位的全加器，其进位输出线永久性地固定为 0（stuck-at-0）。\n\n对于被乘数为 $A = 28$、乘数为 $B = 28$ 的特定测试用例，计算故障乘法器计算出的乘积与正确乘积之间的数值差异。也就是说，求 $P_{\\text{faulty}} - P_{\\text{correct}}$ 的值。", "solution": "该问题要求计算一个 5x5 Wallace 树乘法器由于一个特定的固定 0 故障（stuck-at-0 fault）而在最终乘积中产生的误差。输入为 $A=28$ 和 $B=28$。\n\n首先，我们将被乘数 $A$ 和乘数 $B$ 表示为 5 位无符号二进制数。\n$A = 28_{10} = 16 + 8 + 4 = 1 \\cdot 2^4 + 1 \\cdot 2^3 + 1 \\cdot 2^2 + 0 \\cdot 2^1 + 0 \\cdot 2^0 = 11100_2$。\n所以，$a_4=1, a_3=1, a_2=1, a_1=0, a_0=0$。\n$B = 28_{10} = 11100_2$。\n所以，$b_4=1, b_3=1, b_2=1, b_1=0, b_0=0$。\n\n接下来，我们需要确定一个通用的 5x5 乘法的初始部分积阵列的结构。位 $a_j \\land b_i$ 放置在第 $j+i$ 列。列的索引从 0 到 8。我们确定初始阵列中每列的高度（位数）。\n\n- 第 0 列: $a_0b_0$ (高度: 1)\n- 第 1 列: $a_1b_0, a_0b_1$ (高度: 2)\n- 第 2 列: $a_2b_0, a_1b_1, a_0b_2$ (高度: 3)\n- 第 3 列: $a_3b_0, a_2b_1, a_1b_2, a_0b_3$ (高度: 4)\n- 第 4 列: $a_4b_0, a_3b_1, a_2b_2, a_1b_3, a_0b_4$ (高度: 5)\n- 第 5 列: $a_4b_1, a_3b_2, a_2b_3, a_1b_4$ (高度: 4)\n- 第 6 列: $a_4b_2, a_3b_3, a_2b_4$ (高度: 3)\n- 第 7 列: $a_4b_3, a_3b_4$ (高度: 2)\n- 第 8 列: $a_4b_4$ (高度: 1)\n\n任何高度为 3 或更高的列都需要一个全加器 (FA) 来进行压缩。在第一压缩阶段需要全加器的列是第 2、3、4、5 和 6 列。\n\n问题陈述故障发生在“需要全加器的最高有效位列”。根据我们的分析，这是第 6 列。\n\n第 6 列中的全加器将该列中的三个位作为其输入。这些输入是：\n1.  $I_1 = a_4b_2$\n2.  $I_2 = a_3b_3$\n3.  $I_3 = a_2b_4$\n\n现在，我们针对给定的 $A=11100_2$ 和 $B=11100_2$ 计算这些输入的值。\n- $a_4=1, a_3=1, a_2=1$\n- $b_4=1, b_3=1, b_2=1$\n\n- $I_1 = a_4 \\land b_2 = 1 \\land 1 = 1$\n- $I_2 = a_3 \\land b_3 = 1 \\land 1 = 1$\n- $I_3 = a_2 \\land b_4 = 1 \\land 1 = 1$\n\n第 6 列中全加器的输入是 $(1, 1, 1)$。\n\n一个输入为 $(x, y, z)$ 的全加器生成一个和 $S = x \\oplus y \\oplus z$ 和一个进位输出 $C_{out} = (x \\land y) \\lor (y \\land z) \\lor (z \\land x)$。\n对于输入 $(1, 1, 1)$:\n- 和位是 $S = 1 \\oplus 1 \\oplus 1 = 1$。该位保留在第 6 列以用于下一阶段。\n- 正确的进位输出位是 $C_{out} = (1 \\land 1) \\lor (1 \\land 1) \\lor (1 \\land 1) = 1$。该位应传递到第 7 列以用于下一阶段。\n\n故障是该进位输出线上的固定 0 故障。这意味着无论输入如何，进位输出总是 0。\n- 正确的进位输出: $C_{correct} = 1$\n- 故障的进位输出: $C_{faulty} = 0$\n\n这个来自第 6 列的进位输出位贡献给第 7 列。第 7 列中一个位的位置权重是 $2^7$。在最终和中引入的误差是进位值之差乘以其位置权重。\n\n误差 = $(C_{faulty} - C_{correct}) \\times (\\text{第 7 列的权重})$\n误差 = $(0 - 1) \\times 2^7$\n误差 = $-1 \\times 128$\n误差 = $-128$\n\n这个误差直接转化为故障乘积与正确乘积之间的差值，因为 Wallace 树是一个求和电路，而该故障只是从和中移除了一个项。\n因此，$P_{\\text{faulty}} - P_{\\text{correct}} = -128$。\n\n为了验证，正确的乘积是 $28 \\times 28 = 784$。故障乘法器计算出的和比正确的和少 128。所以，$P_{\\text{faulty}} = 784 - 128 = 656$。差值为 $656 - 784 = -128$。", "answer": "$$\\boxed{-128}$$", "id": "1977496"}]}