{"hands_on_practices": [{"introduction": "扫描链设计的核心思想是在测试模式下将电路中的所有触发器重新配置成一个巨大的移位寄存器。本练习将通过一个基础的仿真任务，帮助您形象地理解测试向量是如何逐个时钟周期、逐位地串行加载进扫描链的。掌握这种基本的数据移位机制是精通扫描测试的第一步。[@problem_id:1958985]", "problem": "在现代数字电路设计中，采用一种称为可测性设计 (DFT) 的技术来方便对制造出的芯片进行测试。一种常见的 DFT 方法是添加扫描链，它在特殊的测试模式下将电路的触发器重新配置成一个大型移位寄存器。\n\n考虑一个由五个D型触发器组成的简单5位扫描链，标记为 FF1 到 FF5。在测试模式下，FF1 的数据输入端连接到一个主输入端口 `scan_in`。FF1 的输出端 (Q1) 连接到 FF2 的输入端 (D2)，FF2 的输出端 (Q2) 连接到 FF3 的输入端 (D3)，以此类推，直到 FF5 的输出端 (Q5) 连接到一个主输出端口 `scan_out`。\n\n最初，扫描链中的所有五个触发器都被复位，因此它们的内容，表示为有序比特串 `[Q1, Q2, Q3, Q4, Q5]`，是 `00000`。\n\n一个测试向量序列 `10110` 通过 `scan_in` 端口在五个连续的时钟周期内被串行移入链中。序列的第一个比特 (`1`) 在第一个时钟周期施加于 `scan_in`，第二个比特 (`0`) 在第二个时钟周期施加，依此类推。\n\n在恰好5个时钟周期后，扫描链的二进制内容 `[Q1, Q2, Q3, Q4, Q5]` 是什么？\n\nA. `10110`\n\nB. `01101`\n\nC. `00000`\n\nD. `01100`\n\nE. `11010`", "solution": "在一个由上升沿触发的D型触发器组成的扫描链中，在每个有效时钟沿，下一个状态等于输入：对于 FF1，有 $Q_{1}^{+}=D_{1}=\\text{scan\\_in}$；对于 $i \\in \\{2,3,4,5\\}$，有 $Q_{i}^{+}=D_{i}=Q_{i-1}$。设 $Q_{i}[k]$ 表示第 $k$ 个时钟之后的内容，初始状态为 $Q_{i}[0]=0$。设串行输入序列为 $s[1]=1, s[2]=0, s[3]=1, s[4]=1, s[5]=0$。那么每个时钟周期的更新方程为\n$$\nQ_{1}[k]=s[k], \\quad Q_{i}[k]=Q_{i-1}[k-1] \\text{ for } i=2,3,4,5.\n$$\n迭代计算：\n- $k=1$ 时：$[Q_{1},Q_{2},Q_{3},Q_{4},Q_{5}]=[1,0,0,0,0]$。\n- $k=2$ 时：$[Q_{1},Q_{2},Q_{3},Q_{4},Q_{5}]=[0,1,0,0,0]$。\n- $k=3$ 时：$[Q_{1},Q_{2},Q_{3},Q_{4},Q_{5}]=[1,0,1,0,0]$。\n- $k=4$ 时：$[Q_{1},Q_{2},Q_{3},Q_{4},Q_{5}]=[1,1,0,1,0]$。\n- $k=5$ 时：$[Q_{1},Q_{2},Q_{3},Q_{4},Q_{5}]=[0,1,1,0,1]$。\n\n因此，在恰好五个时钟周期后，扫描链的内容是 $01101$，对应选项 B。", "answer": "$$\\boxed{B}$$", "id": "1958985"}, {"introduction": "在我们信任扫描测试的结果之前，必须首先确认扫描链本身没有缺陷。本练习探讨了“冲洗测试”（flush test）的概念，这是一种快速有效地验证扫描路径结构完整性的方法。通过选择正确的输入模式，我们可以高效地检测扫描链内部常见的制造缺陷，例如固定为0或固定为1的故障。[@problem_id:1958987]", "problem": "在现代超大规模集成（VLSI）电路设计中，一种常见的可测试性设计（DFT）技术是使用扫描链。这涉及将所有内部存储元件（如触发器）连接成一个长移位寄存器。在测试模式下，一个已知的比特序列可以通过专用的`Scan_In`端口移入此链，而产生的状态可以从`Scan_Out`端口移出。\n\n在使用扫描链测试电路的组合逻辑之前，首先验证扫描链本身的完整性至关重要。这通常通过“冲刷测试”来完成，即一个特定的比特模式被移过整个链，以确认其能正确传输数据。\n\n考虑一个由$N$个触发器组成的扫描链。我们希望执行一次冲刷测试，以检测扫描路径中最常见的制造缺陷，特别是单个固定为0故障（即某个节点永久性短路到地）和单个固定为1故障（即某个节点永久性短-路到电源）。\n\n当以下哪个输入数据序列在$N$个连续时钟周期内应用于`Scan_In`端口时，能为整个扫描链长度上的单个固定为0和固定为1故障提供最全面、最高效的检测？\n\nA. 恒定的`0`序列（即`000...`）。\n\nB. 恒定的`1`序列（即`111...`）。\n\nC. 交替的`0`和`1`序列（例如`010101...`）。\n\nD. 一个包含单个`1`后跟$N-1$个零的序列（一种“走动1”模式，即`1000...`）。\n\nE. $N/2$个零后跟$N/2$个一的序列（假设$N$为偶数）。", "solution": "设扫描链是由$N$个边沿触发的触发器级联而成，从$1$（最靠近`Scan_In`）到$N$（最靠近`Scan_Out`）进行索引。用$s(t)$表示施加的串行输入序列，在时间$t$每个时钟施加一个比特。在一个无故障的链中，当流水线被填满后，`Scan_Out`等于延迟了$N$个时钟周期的输入：\n$$\ny(t) = s(t - N).\n$$\n在第$k$级的单个固定为$b$故障（$b \\in \\{0,1\\}$）可以被抽象为强制第$k$级的输出恒定为$b$。因此，每当第$k$级的预期比特应为$1-b$时，就会产生一个差异，这个差异会传播到`Scan_Out`，并在适当的移位延迟后变得可观察。\n\n为了使用单次$N$周期冲刷来检测每个位置$k \\in \\{1,\\dots,N\\}$的固定为0和固定为1故障，所施加的序列$s(t)$必须：\n1) 在测试期间将每一级都驱动到逻辑$0$和逻辑$1$（以激励两种极性的故障）。\n2) 在相邻级之间创建频繁的$0 \\leftrightarrow 1$转换，确保在$N$周期窗口内，无论初始状态如何，差异都能迅速传播到`Scan_Out`。\n\n评估各个选项：\n\nA. 恒定$0$序列：对所有$t$，$s(t)=0$。这从未尝试在任何一级驱动一个$1$，因此固定为0的故障不会被激励；只有固定为1的故障可以被检测到。因此，它不全面。\n\nB. 恒定$1$序列：对所有$t$，$s(t)=1$。这从未尝试在任何一级驱动一个$0$，因此固定为1的故障不会被激励；只有固定为0的故障可以被检测到。因此，它不全面。\n\nC. 交替$0,1,0,1,\\dots$序列：$s(t)$每个周期翻转。对于任何一级$k$，该级的预期值在连续周期中在$0$和$1$之间交替，因此在$k$处，固定为0和固定为1的故障都会被激励。此外，连续的交替保证了相邻级之间频繁的转换，这使得由固定故障引起的任何差异都能在$N$周期的测试内迅速在`Scan_Out`处显现出来。这同时满足了完整性（在所有位置激励两种极性）和效率（单一模式，最大翻转率）。\n\nD. 走动$1$：$s(0)=1$ 且对于 $t \\in \\{1,\\dots,N-1\\}$，$s(t)=0$。每一级都看到大部分是$0$，只有一个$1$通过。这可以在$1$到达给定级时激励固定为0的故障，也可以揭示固定为1的故障，因为在大多数周期中都施加的是零。然而，相对于交替模式，某些位置（例如，靠近`Scan_Out`的位置）的检测延迟可能更长，并且在精确的$N$个应用周期内的完整性对于最后几级来说可能是边缘性的，因为单个$1$仅在第$N$个周期结束时才到达最后一级，在$N$个应用周期的规定约束下，没有额外的周期在`Scan_Out`进行观察。因此，对于单遍$N$周期冲刷来说，它不如交替序列鲁棒和高效。\n\nE. $N/2$个零后跟$N/2$个一的块（假设$N$为偶数）：这在输入流中只产生一次转换。许多级在$N$周期应用窗口内不会经历两种逻辑电平，因此在某些位置，两种固定故障极性中的一种可能不会被激励。因此，它不全面。\n\n因此，交替序列 $010101\\dots$ 为整个扫描链长度上的单个固定为0和固定为1故障提供了最全面、最高效的单遍检查。", "answer": "$$\\boxed{C}$$", "id": "1958987"}, {"introduction": "扫描链最强大的应用之一是故障诊断——精确定位复杂芯片内部的缺陷位置。本练习模拟了一个真实的诊断场景：测试中观察到的输出比特流与预期结果不匹配。通过仔细比较两个数据流并理解扫描路径的结构，您可以将错误追溯到捕获了错误数据的特定触发器，从而隔离故障的根本原因。[@problem_id:1958964]", "problem": "在现代片上系统 (SoC) 中，会使用可测试性设计 (DFT) 方法进行广泛的测试。其中的一个关键组成部分是扫描链，它在测试模式下将芯片的触发器连接成一个巨大的移位寄存器。这使得工程师能够控制和观察电路的内部状态。\n\n考虑一个包含 16 个状态保持触发器的数字逻辑块，索引为 FF1 到 FF16。为了测试目的，这些触发器已被连接成一个单一的扫描链。触发器的物理索引不一定与其在扫描链中的位置相对应。从扫描输入引脚到扫描输出引脚的具体扫描链顺序如下：\n\nFF13 → FF2 → FF9 → FF16 → FF5 → FF11 → FF4 → FF14 → FF8 → FF1 → FF10 → FF15 → FF6 → FF12 → FF3 → FF7\n\n在扫描输入一个特定的测试向量后，芯片会进入功能模式一个时钟周期，以将组合逻辑的输出捕获到触发器中。然后，芯片返回测试模式，并将捕获的状态扫描输出。\n\n基于无故障仿真的预期扫描输出比特流为：\n`E = 1011010111010110`\n\n从物理芯片上实际观测到的比特流为：\n`O = 1011010110010110`\n\n比特流从左到右读取，其中第一个比特是第一个从扫描输出引脚出来的，最后一个比特是最后一个。组合逻辑中存在一个单一的、非间歇性的故障，导致恰好一个触发器捕获了错误的值。请确定故障触发器 FF$k$ 的索引 $k$。捕获错误的第一个触发器被定义为在所有捕获了不正确数据的触发器中，沿着扫描路径距离扫描输出引脚最远（即最接近扫描输入引脚）的那个。", "solution": "问题要求我们通过分析预期和观测到的扫描输出比特流，来确定是哪个触发器 FF$k$ 捕获了不正确的值。问题的核心在于将比特流中的位置正确地映射到非顺序扫描链中的特定触发器。\n\n第一步：理解扫描输出过程\n问题指出，扫描输出比特流是通过移出捕获的值生成的，从最靠近扫描输出引脚的触发器开始。给出的扫描链顺序是从扫描输入到扫描输出。我们需要反转这个顺序，以找到数据出现在输出端时触发器的序列。\n\n给定的扫描链路径是：\nSCAN_IN → FF13 → FF2 → FF9 → FF16 → FF5 → FF11 → FF4 → FF14 → FF8 → FF1 → FF10 → FF15 → FF6 → FF12 → FF3 → FF7 → SCAN_OUT\n\n最靠近扫描输出引脚的触发器是 FF7。其捕获的值将是扫描输出流中的第一个比特。链中朝向扫描输入引脚的下一个触发器是 FF3，所以它的值将是第二个比特。这个过程一直持续到最后一个触发器 FF13（最靠近扫描输入引脚），其捕获的值将是比特流的最后一个比特。\n\n让我们建立从比特流中的比特位置（1到16）到其来源触发器索引的映射关系：\n- 比特 1：FF7\n- 比特 2：FF3\n- 比特 3：FF12\n- 比特 4：FF6\n- 比特 5：FF15\n- 比特 6：FF10\n- 比特 7：FF1\n- 比特 8：FF8\n- 比特 9：FF14\n- 比特 10：FF4\n- 比特 11：FF11\n- 比特 12：FF5\n- 比特 13：FF16\n- 比特 14：FF9\n- 比特 15：FF2\n- 比特 16：FF13\n\n第二步：识别预期和观测流之间的不匹配\n现在，我们比较预期比特流 `E` 和观测比特流 `O`，以找到任何错误的位置。\n\n预期：`E = 1011010111010110`\n观测：`O = 1011010110010110`\n\n让我们从左到右逐比特比较它们（位置1到16）：\n- 位置 1-9：比特相同 (`101101011`)。\n- 位置 10：`E` 的值为 `1`，而 `O` 的值为 `0`。这是一个不匹配。\n- 位置 11-16：比特相同 (`010110`)。\n\n唯一的不匹配发生在扫描输出流的第10个比特位置。\n\n第三步：定位故障触发器\n问题指出，错误的来源是扫描链中第一个捕获错误值的触发器，定义为在所有故障捕获中距离扫描输出引脚最远的那个。在扫描输出流中，较晚输出的比特对应于链中更深（距离扫描输出引脚更远）的触发器。因此，我们应该识别发生在最高比特位置索引处的不匹配。\n\n在这种情况下，只有一个不匹配，位于比特位置10。我们现在使用第一步中的映射来确定哪个触发器捕获的值对应于这第10个比特。\n\n根据我们的映射：比特10对应于由FF4捕获的值。\n\n由于这是唯一的错误，故障必定存在于为FF4提供输入的组合逻辑锥中。因此，FF4是捕获了错误值的触发器。故障触发器 FF$k$ 的索引 $k$ 是4。", "answer": "$$\\boxed{4}$$", "id": "1958964"}]}