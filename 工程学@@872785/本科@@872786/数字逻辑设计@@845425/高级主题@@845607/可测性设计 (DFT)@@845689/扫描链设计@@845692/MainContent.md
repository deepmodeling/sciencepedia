## 引言
随着集成电路（IC）的规模与复杂度以前所未有的速度增长，如何确保每一颗出厂芯片的功能完好无损，已成为[半导体](@entry_id:141536)行业面临的核心挑战。虽然组合逻辑电路的测试相对直接，但包含内部状态的[同步时序电路](@entry_id:175242)，其测试却异常困难。其根本症结在于测试过程中对电路内部状态的**可控性**和**[可观测性](@entry_id:152062)**极低，导致许多潜在的制造缺陷难以被激活和检测，这构成了[数字系统设计](@entry_id:168162)中的一个关键知识缺口。

为了攻克这一难题，业界发展出了“可测试性设计”（Design for Testability, DFT）方法学，其中，**[扫描链](@entry_id:171661)设计**是最为基础且应用最广泛的技术。本文将系统性地剖析[扫描链](@entry_id:171661)设计的原理、应用与实践。在第一部分“原理与机制”中，我们将深入探讨[扫描触发器](@entry_id:168275)的结构、[扫描链](@entry_id:171661)的构建与操作流程，并阐明其如何将时序测试化繁为简。接下来的“应用与跨学科联系”部分，将展示[扫描链](@entry_id:171661)如何与自动化工具协同工作，如何演进以应对高级[故障模型](@entry_id:172256)，并如何与BIST等系统级架构集成。最后，在“动手实践”部分，我们将通过具体问题，加深对[扫描链](@entry_id:171661)操作和诊断流程的理解。让我们首先从理解测试[时序电路](@entry_id:174704)的根本挑战开始，揭示[扫描链](@entry_id:171661)设计的精妙之处。

## 原理与机制

### 测试[时序电路](@entry_id:174704)的根本挑战

在[数字系统设计](@entry_id:168162)中，电路可以分为两大类：组合逻辑电路和[时序逻辑电路](@entry_id:167016)。组合逻辑电路的输出仅取决于其当前输入，使得其测试相对直接。我们可以通过施加一组精心设计的测试向量并观察输出来验证其功能的正确性。然而，[时序逻辑电路](@entry_id:167016)的测试则要复杂得多。它们的输出不仅取决于当前输入，还取决于电路内部的**状态**（由[触发器](@entry_id:174305)或锁存器等存储元件维持）。这种对历史状态的依赖性，使得测试[时序电路](@entry_id:174704)成为一项艰巨的任务。

核心困难在于两点：**[可控性](@entry_id:148402) (Controllability)** 和 **可观测性 (Observability)**。可控性指的是将电路内部的状态元件设置为特定值的难易程度。可观测性则指的是在不改变电路功能的前提下，观察其内部状态值的难易程度。对于一个复杂的[时序电路](@entry_id:174704)，要使其进入某个能够暴露特定制造缺陷的“目标状态”，可能需要一个非常长且复杂的输入序列。同样，当一个故障发生并改变了某个内部状态时，这个错误的效应可能需要经过许多个时钟周期才能传播到芯片的主输出引脚上被检测到。

为了具体理解这个挑战，让我们考虑一个假想的16位同步[二进制加法](@entry_id:176789)计数器 [@problem_id:1928147]。假设该计数器在每个时钟周期递增。电路中有一个主输出 $Z$，其逻辑由[组合逻辑](@entry_id:265083) $Z = (S_{13} \land S_7) \oplus S_2$ 决定，其中 $S_i$ 是计数器的第 $i$ 个状态位。现在，假设一个制造缺陷导致连接到 $S_{13}$ 的[与门](@entry_id:166291)输入发生了**固定为0的故障 (stuck-at-0 fault)**。这意味着，无论 $S_{13}$ 的实际值是什么，电路在计算 $Z$ 时都将其视为0。因此，故障电路的输出变为 $Z_{\text{faulty}} = (0 \land S_7) \oplus S_2 = S_2$。

为了检测到这个故障，我们必须创造一个条件，使得正常电路的输出 $Z_{\text{good}}$ 与故障电路的输出 $Z_{\text{faulty}}$ 不同。这种差异发生的条件是 $Z_{\text{good}} \oplus Z_{\text{faulty}} = 1$，即 $((S_{13} \land S_7) \oplus S_2) \oplus S_2 = S_{13} \land S_7 = 1$。换言之，我们必须将计数器置于一个同时满足 $S_{13}=1$ 和 $S_7=1$ 的状态。如果从复位状态（所有位为0）开始，通过正常的功能操作（即让计数器自增）来达到这个目标状态，我们需要等待多少个[时钟周期](@entry_id:165839)呢？最小的满足此条件的计数值是 $2^{13} + 2^7 = 8192 + 128 = 8320$。这意味着，我们必须让电路运行整整8320个时钟周期，才能在主输出 $Z$ 上首次观测到该故障的效应。对于一个拥有数百万门级和数万个[触发器](@entry_id:174305)的大型设计而言，所需的功能测试序列可能长得不切实际，甚至在计算上是不可行的。

这种困境催生了**可测试性设计 (Design for Testability, DFT)** 的概念，其核心思想是在设计阶段就植入额外的硬件结构，以简化后续的制造测试。在所有DFT技术中，**[扫描链](@entry_id:171661)设计 (Scan Chain Design)** 是最基本和最广泛应用的一种。

### [扫描触发器](@entry_id:168275)：基[本构建模](@entry_id:183370)块

[扫描链](@entry_id:171661)方法的核心思想是，在测试模式下，将电路中所有的或大部分的状态元件（[触发器](@entry_id:174305)）重新配置成一个巨大的[移位寄存器](@entry_id:754780)。这使得测试设备可以像串行数据线一样，“扫描”进任意的测试状态，并“扫描”出电路的内部响应状态，从而极大地提升了[可控性](@entry_id:148402)和[可观测性](@entry_id:152062)。

实现这一目标的基础是**[扫描触发器](@entry_id:168275) (scan flip-flop)**。一个标准的[扫描触发器](@entry_id:168275)是在一个普通的[D型触发器](@entry_id:171740)（D-FF）基础上构建的，其关键在于在其数据输入端增加了一个2选1多路复用器（MUX）[@problem_id:1958956]。这个结构引入了三个主要输入：
1.  **功能数据输入 ($D_{in}$)**：来自电路正常工作时的组合逻辑。
2.  **扫描输入 ($S_{in}$)**：来自[扫描链](@entry_id:171661)中前一个[触发器](@entry_id:174305)的输出。
3.  **扫描使能 ($SE$)**：一个全局[控制信号](@entry_id:747841)，用于切换工作模式。

[多路复用器](@entry_id:172320)的选择输入端由 $SE$ 控制。按照惯例，当 $SE=0$ 时，电路处于**正常模式 (Normal Mode)** 或**捕获模式 (Capture Mode)**，MUX选择 $D_{in}$ 作为D-FF的输入。当 $SE=1$ 时，电路处于**扫描模式 (Scan Mode)** 或**[移位](@entry_id:145848)模式 (Shift Mode)**，MUX选择 $S_{in}$ 作为D-FF的输入。因此，进入D-FF内部的数据输入 $D_{ff}$ 可以用以下[布尔表达式](@entry_id:262805)来描述：

$D_{ff} = \overline{SE} \cdot D_{in} + SE \cdot S_{in}$

这个简单的逻辑增强赋予了每个[触发器](@entry_id:174305)双重身份。在正常工作时（$SE=0$），它表现得就像一个普通的[触发器](@entry_id:174305)，存储来自其上游[组合逻辑](@entry_id:265083)的数据。而在测试时（$SE=1$），它忽略功能数据，转而接收来自 $S_{in}$ 的数据，成为移位寄存器的一个环节。

### 从[触发器](@entry_id:174305)到[扫描链](@entry_id:171661)：结构与操作

有了[扫描触发器](@entry_id:168275)后，下一步就是将它们连接起来形成**[扫描链](@entry_id:171661) (scan chain)**。在一个典型的全[扫描设计](@entry_id:177301)中，电路中所有的[触发器](@entry_id:174305)都被替换为[扫描触发器](@entry_id:168275)。然后，第 $i$ 个[扫描触发器](@entry_id:168275)的功能输出 $Q_i$ 会连接到第 $(i+1)$ 个[扫描触发器](@entry_id:168275)的扫描输入 $S_{in, i+1}$。这条链的起点是一个专用的芯片主输入引脚，称为**扫描输入 (Scan-In, SI)**，连接到第一个[触发器](@entry_id:174305)的 $S_{in}$。链的终点是最后一个[触发器](@entry_id:174305)的 $Q$ 输出，连接到一个专用的主输出引脚，称为**扫描输出 (Scan-Out, SO)** [@problem_id:1958991]。

值得注意的是，[扫描链](@entry_id:171661)中[触发器](@entry_id:174305)的顺序并非随机的。为了保证测试生成和诊断过程的确定性和效率，这个顺序通常由电子设计自动化（[EDA](@entry_id:172341)）工具根据严格的规则来确定。这些规则可能基于寄存器的字母顺序、每个寄存器内部位的顺序（例如，从最高有效位MSB到最低有效位LSB），以及物理布局的考虑，以最小化[扫描链](@entry_id:171661)的布线长度 [@problem_id:1958991]。

利用[扫描链](@entry_id:171661)进行一次完整的测试周期，通常包含以下三个核心步骤 [@problem_id:1958954]：

1.  **加载阶段 (Load Phase) / 扫描移入 (Scan-In)**：将 `SCAN_ENABLE` 信号置为高电平（$SE=1$），使所有[扫描触发器](@entry_id:168275)工作在移位模式。然后，在 `SCAN_IN` 引脚上逐位输入一个测试向量，并在每个时钟周期驱动一次时钟。如果[扫描链](@entry_id:171661)的长度为 $N$（即有 $N$ 个[触发器](@entry_id:174305)），那么经过 $N$ 个[时钟周期](@entry_id:165839)后，这个 $N$ 位的测试向量就会被完整地加载到[扫描链](@entry_id:171661)的 $N$ 个[触发器](@entry_id:174305)中。这一步实现了对电路状态的完全**可控性**。

2.  **捕获阶段 (Capture Phase)**：将 `SCAN_ENABLE` 信号置为低电平（$SE=0$），使电路返回到正常工作模式。然后，施加一个单独的、功能性的时钟脉冲。在这个脉冲的有效边沿，每个[触发器](@entry_id:174305)会捕获其功能数据输入 $D_{in}$ 上的值。这个值是上游[组合逻辑](@entry_id:265083)根据加载的测试向量计算出的结果。

3.  **卸载阶段 (Unload Phase) / 扫描移出 (Scan-Out)**：再次将 `SCAN_ENABLE` 信号置为高电平（$SE=1$），使电路回到[移位](@entry_id:145848)模式。接着，施加 $N$ 个时钟脉冲。在每个脉冲下，[扫描链](@entry_id:171661)中的数据都会向后移动一位，并从 `SCAN_OUT` 引脚移出。这样，先前捕获在 $N$ 个[触发器](@entry_id:174305)中的电路响应向量就被完整地读取出来，并由自动测试设备（ATE）进行比对和分析。这一步实现了对电路状态的完全**可观测性**。

这个过程清晰地展示了[扫描链](@entry_id:171661)如何解决可观测性问题。例如，要观察电路内部某个节点 `N` 的值，而该节点连接到[扫描链](@entry_id:171661)中第 $j$ 个[触发器](@entry_id:174305) `FF_j` 的功能输入端。我们只需执行以下两步操作 [@problem_id:1958943]：
- 首先，执行一个捕获周期（设置 `SCAN_EN = 0` 并施加一个时钟脉冲），将节点 `N` 的值锁存到 `FF_j` 中。
- 然后，切换到扫描模式（设置 `SCAN_EN = 1`），并施加 $K-j$ 个时钟脉冲（假设[扫描链](@entry_id:171661)总长度为 $K$）。这样，最初存储在 `FF_j` 中的值就会被一步步地移位，最终出现在第 $K$ 个[触发器](@entry_id:174305)的输出，也就是 `SCAN_OUT` 引脚上。

### 核心原理：将时序测试转化为组合测试

[扫描链](@entry_id:171661)的真正威力在于，它从根本上改变了测试问题的性质。通过提供在任意状态之间切换的机制（通过扫描），[扫描链](@entry_id:171661)有效地**在测试期间切断了[时序电路](@entry_id:174704)中的[反馈环](@entry_id:273536)路**。

在测试过程中，[触发器](@entry_id:174305)扮演了双重角色：在加载和捕获之间，它们是**伪主输入 (Pseudo-Primary Inputs)**，为[组合逻辑](@entry_id:265083)提供了激励；在捕获和卸载之间，它们又成了**伪主输出 (Pseudo-Primary Outputs)**，捕获了组合逻辑的响应。因此，测试一个复杂的[时序电路](@entry_id:174704)的艰巨任务，被简化为测试其内部的各个**[组合逻辑](@entry_id:265083)块**的相对简单的任务。自动测试向量生成（ATPG）工具可以专注于为这些独立的[组合逻辑](@entry_id:265083)块生成测试向量，而无需担心如何通过功能操作来控制和观察它们。

让我们回到之前的16位计数器例子 [@problem_id:1928147]。使用[扫描链](@entry_id:171661)，测试流程将发生巨大变化。为了在 $Z$ 输出端检测到 $S_{13}$ 的固定为0故障，我们仍然需要创造 $S_{13}=1$ 和 $S_7=1$ 的条件。但是，我们不再需要通过8320次递增来达到这个状态。取而代之的是：
1.  **扫描移入**：我们将目标状态（例如，二[进制](@entry_id:634389)数 $2^{13} + 2^7$）的前一个状态，即 $(2^{13} + 2^7) - 1$，作为测试向量。通过[扫描链](@entry_id:171661)将这个16位的值移入计数器的16个[触发器](@entry_id:174305)中。这需要16个扫描时钟周期。
2.  **捕获**：切换到正常模式，并施加一个时钟脉冲。计数器执行其功能操作（递增1），其状态变为 $2^{13} + 2^7$。此时，$S_{13}=1$ 和 $S_7=1$ 的条件满足，故障效应会立即体现在主输出 $Z$ 上。这个过程需要1个[时钟周期](@entry_id:165839)。

总共只需 $16 + 1 = 17$ 个时钟周期就可以检测到这个故障，而传统的顺序测试则需要8320个周期。这种效率上的巨大提升，正是[扫描设计](@entry_id:177301)成为行业标准的原因。

### 实践考量与权衡

虽然[扫描链](@entry_id:171661)极大地提高了可测试性，但它并非没有代价。在设计中实施[扫描链](@entry_id:171661)需要考虑一系列实际问题和权衡。

#### 测试时间与多[扫描链](@entry_id:171661)

对于一个拥有 $N$ 个[触发器](@entry_id:174305)和需要应用 $P$ 个测试向量的设计，测试总时间主要由扫描操作决定。在一种高效的流水线操作中，前一个测试模式的响应在被移出的同时，下一个测试模式的激励被移入 [@problem_id:1958971]。加载第一个向量需要 $N$ 个周期，之后每个向量的加载/卸载需要 $N$ 个周期，最后卸载最后一个响应也需要 $N$ 个周期（尽管这通常可以被忽略）。因此，总的扫描周期数大约为 $N \times P$。

对于包含数百万[触发器](@entry_id:174305)的大型芯片，即使扫描时钟频率很高（例如100 MHz），单个长[扫描链](@entry_id:171661)也会导致测试时间过长，从而增加每个芯片在昂贵测试设备上的成本。例如，一个有8192个[触发器](@entry_id:174305)的[扫描链](@entry_id:171661)，应用10000个测试模式，在100 MHz时钟下大约需要 $(10000+1) \times 8192 / (100 \times 10^6) \approx 819$ 毫秒 [@problem_id:1958971]。

为了解决这个问题，大型设计通常会将[触发器](@entry_id:174305)**划分为多条较短的[扫描链](@entry_id:171661)**，这些[扫描链](@entry_id:171661)可以并行地进行加载和卸载 [@problem_id:1958979]。例如，将一个包含1,200,000个[触发器](@entry_id:174305)的设计划分为100条独立的[扫描链](@entry_id:171661)，每条链的长度就缩短为12,000。由于所有链可以并行[移位](@entry_id:145848)，完成一次扫描操作所需的时间就由最长链的长度决定，从而将总测试时间近似缩短了100倍。这种策略的主要动机是**缩短测试应用时间**，直接降低制造成本。

#### 设计开销

引入[扫描链](@entry_id:171661)会带来两种主要的开销：面积和性能。

- **面积开销 (Area Overhead)**：最主要的面积开销来自于将每个标准[触发器](@entry_id:174305)替换为更大的[扫描触发器](@entry_id:168275)。[扫描触发器](@entry_id:168275)内部包含一个额外的多路复用器，这会增加其在硅片上占用的面积。对于一个有数十万甚至数百万[触发器](@entry_id:174305)的设计，这种累积的面积增加是相当可观的，通常是[扫描设计](@entry_id:177301)中最显著的成本 [@problem_id:1958940]。其他来源，如额外的[扫描链](@entry_id:171661)布线、测试时钟控制器或顶层的测试访问端口（TAP）控制器，虽然也贡献了开销，但其规模通常远小于所有[触发器](@entry_id:174305)单元面积增加的总和。

- **性能影响 (Performance Impact)**：[扫描链](@entry_id:171661)的引入也会对电路的正常工作性能产生负面影响。在功能路径上，每个[扫描触发器](@entry_id:168275)所包含的多路复用器都增加了一段额外的**传播延迟 ($t_{mux}$)** [@problem_id:1958966]。对于时序关键路径，这个额外的延迟必须被计算在内。一个同步路径的最小允许[时钟周期](@entry_id:165839) $T_{clk}$ 必须满足时序[建立时间](@entry_id:167213)（setup time）约束：
$T_{clk} \ge t_{c-q} + t_{comb} + t_{su}$
其中 $t_{c-q}$ 是源[触发器](@entry_id:174305)的时钟到Q端延迟， $t_{comb}$ 是组合逻辑路径延迟，$t_{su}$ 是目标[触发器](@entry_id:174305)的建立时间。在插入扫描MUX后，该路径的总延迟变为 $t_{comb} + t_{mux}$。因此，新的最小周期为：
$T_{clk, \text{scan}} \ge t_{c-q} + (t_{comb} + t_{mux}) + t_{su}$
这意味着，为了满足时序要求，电路可能需要以一个更长的[时钟周期](@entry_id:165839)（即更低的工作频率）运行，或者设计者必须花费更多精力来优化关键路径的时序以补偿MUX带来的延迟。

### 高级[扫描设计](@entry_id:177301)主题

在真实世界的大型设计中，[扫描链](@entry_id:171661)的实现还会遇到更复杂的问题，需要专门的技术来解决。

#### 处理[跨时钟域](@entry_id:173614)问题

当一条[扫描链](@entry_id:171661)需要跨越不同的**时钟域 (clock domains)** 时，例如从处理器核心的一个[触发器](@entry_id:174305)连接到外设模块的另一个[触发器](@entry_id:174305)，即使在测试模式下使用一个共同的测试时钟 `SCAN_CLK`，也会出现问题。由于物理距离遥远和布线复杂性，`SCAN_CLK` 到达两个[触发器](@entry_id:174305)的时刻可能存在显著差异，即**[时钟偏斜](@entry_id:177738) (clock skew)**。

如果捕获[触发器](@entry_id:174305) `FFb` 的时钟边沿比发射[触发器](@entry_id:174305) `FFa` 的时钟边沿晚到（正偏斜），可能会导致**[保持时间违例](@entry_id:175467) (hold time violation)** [@problem_id:1958939]。[保持时间](@entry_id:266567)要求新数据到达捕获[触发器](@entry_id:174305)输入端的时间不能太早，必须在时钟有效边沿之后的一小段时间内，旧数据保持稳定。当存在较大的正偏斜时，由 `FFa` 在一个[时钟沿](@entry_id:171051)发射的新数据，可能会在 `FFb` 的[时钟沿](@entry_id:171051)到达之前就已经传播到了 `FFb` 的输入端，从而过早地覆盖了 `FFb` 正准备捕获的旧数据，导致数据[移位](@entry_id:145848)错误。这个问题可以通过在跨域路径上插入一个**[锁存器](@entry_id:167607) (lock-up latch)** 来解决。这个锁存器通常被设计为在测试时钟的相反相位透明，它能有效地在数据路径上增加半个时钟周期的延迟，确保即使在有很大偏斜的情况下，[保持时间](@entry_id:266567)约束也能得到满足。

#### 与节电设计的交互

现代设计广泛采用**[时钟门控](@entry_id:170233) (clock gating)** 技术来节省动态功耗。[时钟门控](@entry_id:170233)单元（如ICG单元）会根据特定的使能条件来决定是否将时钟信号传递给一部分[触发器](@entry_id:174305)。然而，这种功能性设计可能会干扰[扫描链](@entry_id:171661)的正常工作。

考虑一个场景，其中一个[触发器](@entry_id:174305) `FF3` 的时钟 `GATED_CLK` 是由 `CLK AND Q2` 产生的，`Q2` 是[扫描链](@entry_id:171661)中前一个[触发器](@entry_id:174305) `FF2` 的输出 [@problem_id:1958983]。在扫描移位期间，如果 `Q2` 的值恰好变为0，那么 `FF3` 将不会接收到下一个时钟脉冲。结果是，`FF3` 不会更新其状态，也不会将数据传递给链中的下一个[触发器](@entry_id:174305)。这相当于在 `Q2=0` 的那个周期，[扫描链](@entry_id:171661)被“断开”了，导致整个测试失败。

为了避免这种情况，DFT规则要求，在测试模式下，所有[时钟门控](@entry_id:170233)逻辑必须被强制进入一个“使能”或“透明”的状态。这通常通过一个全局的 `TEST_MODE` 信号来实现，该信号会覆盖正常的功能性门控逻辑，确保在扫描[移位](@entry_id:145848)和捕获期间，所有参与[扫描链](@entry_id:171661)的[触发器](@entry_id:174305)都能可靠地接收到时钟信号。