{"hands_on_practices": [{"introduction": "我们从一个基本任务开始：创建一个小型只读存储器（ROM）。这个练习展示了数据流建模如何使用一个变量索引从一个常量向量中选择一个特定的位，这是构建存储器和查找表的核心概念。掌握这种方法可以让你在设计中高效地实现固定数据的存储。[@problem_id:1925969]", "problem": "您需要使用Verilog设计一个小型8位x1位只读存储器（ROM）。此ROM将为一个玩具机器人的启动序列存储一个固定的配置模式。该电路必须使用**数据流建模**来实现。\n\nVerilog模块必须命名为`simple_rom`，并具有以下端口：\n- 一个3位输入`address`，声明为`input wire [2:0] address`。\n- 一个1位输出`data_out`，声明为`output wire data_out`。\n\nROM必须硬编码以存储8位常量`8'b10110101`。在此常量中，第7位是最高有效位（MSB），第0位是最低有效位（LSB）。输入`address`的值直接对应于要读取的位索引。例如，如果`address`是`3'b110`（十进制为6），`data_out`应该是该常量的第6位的值。\n\n以下哪个Verilog模块使用单个数据流建模语句正确实现了这个`simple_rom`？\n\nA.\n```verilog\nmodule simple_rom(\n    input wire [2:0] address,\n    output wire data_out\n);\n    assign data_out = 8'b10110101[address];\nendmodule\n```\n\nB.\n```verilog\nmodule simple_rom(\n    input wire [2:0] address,\n    output wire data_out\n);\n    assign data_out = 8'b10101101[address];\nendmodule\n```\n\nC.\n```verilog\nmodule simple_rom(\n    input wire [2:0] address,\n    output reg data_out\n);\n    always @(*)\n        data_out = 8'b10110101[address];\nendmodule\n```\n\nD.\n```verilog\nmodule simple_rom(\n    input wire [2:0] address,\n    output wire data_out\n);\n    wire selected_bit;\n    assign selected_bit[address] = 8'b10110101;\n    assign data_out = selected_bit;\nendmodule\n```", "solution": "我们必须使用数据流建模来实现一个组合逻辑的8x1 ROM，在Verilog中，这意味着使用带有`assign`关键字的连续赋值来驱动一个线网（wire）输出。\n\nROM的内容固定为8位常量8'b10110101，其中位索引是标准的Verilog索引，第7位是MSB，第0位是LSB。要求是3位输入地址直接选择该常量的相应位；因此，一个正确的实现必须将`data_out`计算为该常量在索引`address`处的位选择，即`data_out`等于该常量的第`address`位的值。\n\n现在根据要求验证每个选项：\n\n1) 建模风格和单条语句：\n- 数据流建模需要连续赋值。单个`assign`语句满足“单个数据流建模语句”的要求。\n\n2) 正确的内容和索引：\n- 常量必须正好是`8'b10110101`。\n- 位选择必须是`something[address]`的形式，其中“something”是8位常量。\n\n3) 端口声明和语法正确性：\n- `address`必须声明为`input wire [2:0] address`。\n- 如果由`assign`驱动，`data_out`必须是线网（wire）。\n- 如果我们必须使用单个数据流语句，则不允许使用过程块（`always`）。\n\n评估选项：\n\nA. 使用单个连续赋值：`assign data_out = 8'b10110101[address];`\n- 建模：数据流，一条语句：满足要求。\n- 常量：正确 (`8'b10110101`)。\n- 索引：在Verilog中是合法的可变位选择；`address`选择给定常量的第`address`位，其中第7位为MSB，第0位为LSB，符合要求。\n- 端口：`input wire [2:0] address`和`output wire data_out`：正确。\n因此，A是正确的。\n\nB. 与A结构相同，但使用了`8'b10101101`而不是要求的`8'b10110101`：\n- 常量不正确，所以B不正确。\n\nC. 将输入声明为`input wire [2:0] address`（原始版本有`[2_0]`语法错误），并使用了`output reg data_out`和一个`always @(*)`过程块：\n- 这是行为建模，而不是单个数据流语句。因此，C不正确。\n\nD. 声明了线网`selected_bit`（标量），然后尝试：`assign selected_bit[address] = 8'b10110101;`\n- 这是一种非法的连续赋值形式：连续赋值的左侧必须是一个线网，而不是对标量的位选择，并且方向是反的（试图将一个向量赋给一个索引位）。还使用了两个`assign`语句，违反了“单个语句”的要求。\n因此，D不正确。\n\n只有A满足所有约束：正确的常量、正确的可变位选择、正确的端口以及单个数据流赋值。", "answer": "$$\\boxed{A}$$", "id": "1925969"}, {"introduction": "接下来，我们将探讨一个更专业的操作：奇偶校验。这个问题介绍了Verilog中的缩减运算符（reduction operators），这是一种高效的数据流工具，用于对单个向量的所有位执行位操作。通过这个练习，你将学会如何为错误检测等常见任务编写简洁且高度优化的代码。[@problem_id:1926027]", "problem": "一个数字电路被设计用于对一个8位数据总线执行一项特殊检查。该电路有一个8位输入向量，声明为 `wire [7:0] data_in;`，以及一个1位输出，`wire even_parity;`。该电路的功能是，如果 `data_in` 中值为 '1' 的比特数是偶数（包括0个 '1' 的情况），则将 `even_parity` 输出置为 '1'，否则置为 '0'。\n\n下列哪个单行 Verilog 数据流语句正确地实现了这一行为？\n\nA. `assign even_parity = ^data_in;`\n\nB. `assign even_parity = `\n\nC. `assign even_parity = |data_in;`\n\nD. `assign even_parity = ~^data_in;`\n\nE. `assign even_parity = ~`", "solution": "设8位输入表示为 $data\\_in = (d_{7}, d_{6}, \\ldots, d_{0})$，其中 $d_{i} \\in \\{0,1\\}$。奇偶校验函数可以用异或（XOR）表示为\n$$\np = d_{7} \\oplus d_{6} \\oplus \\cdots \\oplus d_{0} = \\left(\\sum_{i=0}^{7} d_{i}\\right) \\bmod 2.\n$$\n当 '1' 的数量为奇数时，这个 $p$ 等于 $1$，当 '1' 的数量为偶数时，等于 $0$。因此，所需的偶校验输出是 $p$ 的逻辑非：\n$$\n\\overline{p} = \\overline{d_{7} \\oplus d_{6} \\oplus \\cdots \\oplus d_{0}}.\n$$\n在 Verilog 中，缩减异或（reduction XOR）运算符写作一元运算符 `^`，所以 `^data_in` 计算的是 $p$（奇校验位）。缩减异或非（reduction XNOR）运算符写作一元运算符 `~^`，所以 `~^data_in` 计算的是 $\\overline{p}$，它在 '1' 的数量为偶数（包括零）时恰好为 $1$（偶校验位）。因此，正确的单行语句是 `assign even_parity = ~^data_in;`。\n\n为完整起见，其他选项实现了不同的缩减运算：\n- `` 计算 $\\prod_{i=0}^{7} d_{i}$，仅当所有比特都为 $1$ 时，结果才为 $1$。\n- `|data_in` 计算 $\\max(d_{0},\\ldots,d_{7})$，只要有任何一个比特为 $1$，结果就为 $1$。\n- `^data_in` 计算奇校验。\n- `~` 是缩减与（reduction AND）的非，除非所有比特都为 $1$，否则结果为 $1$。\n\n只有缩减异或非（reduction XNOR）与偶校验匹配。", "answer": "$$\\boxed{D}$$", "id": "1926027"}, {"introduction": "最后，让我们将所学技能应用于一个核心算术组件：一个可控的求反器。这个练习结合了位运算符和算术运算来实现二进制补码求反，展示了数据流建模如何直接映射到加法器/减法器电路的结构。通过这个实践，你将巩固对如何构建可重构算术逻辑的理解，这是创建算术逻辑单元（ALU）的基石。[@problem_id:1925996]", "problem": "您的任务是使用数据流 Verilog 设计一个可控的 8 位取反器。该电路是更大型的算术逻辑单元 (ALU) 中加法器/减法器单元的关键组件。\n\n计算 `A+B` 或 `A-B` 的 N 位加法器/减法器的标准硬件实现基于二进制补码恒等式 `-B = ~B + 1`。减法 `A-B` 通过计算 `A + ~B + 1` 来执行。这在硬件中通过使用 N 个异或门 (XOR) 根据一个 `subtract` 控制信号来条件性地反转 `B` 的各位，然后将同一个 `subtract` 信号送入 N 位加法器的进位输入端 (carry-in) 来高效实现。\n\n您的任务是实现该电路的一个特殊版本，用于计算 `Y = X` 或 `Y = -X`。这在功能上等同于计算 `0+X` 或 `0-X`。这个“符号控制单元”的 Verilog 模块具有以下接口：\n- 一个有符号的 8 位输入：`input signed [7:0] X`\n- 一个单位控制信号：`input negate`\n- 一个有符号的 8 位输出：`output [7:0] Y`\n\n要求的行为如下：\n- 如果 `negate` 信号是 `1'b0`，输出 `Y` 必须等于输入 `X`。\n- 如果 `negate` 信号是 `1'b1`，输出 `Y` 必须是 `X` 的二进制补码取反。\n\n遵循上述特定的加法器/减法器硬件原理，以下哪一个单行数据流 Verilog `assign` 语句正确且符合习惯地实现了此功能？\n\nA. `assign Y = (X ^ {8{negate}}) + negate;`\n\nB. `assign Y = negate ? (~X + 1) : X;`\n\nC. `assign Y = (X  {8{negate}}) + negate;`\n\nD. `assign Y = ~X + negate;`\n\nE. `assign Y = (X ~^ {8{negate}}) + negate;`", "solution": "目标是创建一个 Verilog `assign` 语句，该语句根据控制位 `negate` 实现条件性的二进制补码取反。问题明确要求实现要模拟标准的加法器/减法器硬件原理。\n\n所需的功能是：\n1.  如果 `negate = 0`，那么 `Y = X`。\n2.  如果 `negate = 1`，那么 `Y = -X`。\n\n在二进制补码表示法中，数字 `X` 的取反由公式 `-X = ~X + 1` 给出，其中 `~X` 是 `X` 的按位非 (one's complement) 运算。\n\n让我们将这两个条件组合成一个与加法器/减法器原理一致的、统一的表达式。该原理使用异或门 (XOR) 进行条件性反转，并使用控制信号作为加法的进位输入 (carry-in)。\n\n我们来分析表达式 `(X ^ S) + S`，其中 `S` 是一个根据需要进行广播或扩展的单位控制位。\n\n**情况 1：`negate = 0`**\n\n表达式变为 `(X ^ {8{1'b0}}) + 1'b0`。\n- 项 `{8{negate}}` 变为 `8'b00000000`。\n- `X ^ 8'b00000000` 的结果是 `X`，因为任何位与 0 进行异或运算，该位都保持不变。\n- 加法 `+ negate` 变为 `+ 0`。在 Verilog 中，当相加的操作数位宽不同时，较小的操作数会被零扩展以匹配较大的操作数。因此，`1'b0` 变为 `8'b00000000`。\n- 完整的表达式是 `X + 0`，结果为 `X`。\n这符合 `negate = 0` 的要求。\n\n**情况 2：`negate = 1`**\n\n表达式变为 `(X ^ {8{1'b1}}) + 1'b1`。\n- 项 `{8{negate}}` 变为 `8'b11111111`。\n- `X ^ 8'b11111111` 的结果是 `~X`（按位非或反码），因为任何位与 1 进行异或运算都会使该位翻转。\n- 加法 `+ negate` 变为 `+ 1`。`1'b1` 被零扩展为 `8'b00000001`。\n- 完整的表达式是 `~X + 1`。\n这正是二进制补码取反的精确公式。它符合 `negate = 1` 的要求。\n\n因此，语句 `assign Y = (X ^ {8{negate}}) + negate;` 正确地实现了所需功能，并直接映射到硬件原理：使用异或门进行条件性反转 (`X ^ {8{negate}}`)，并使用控制信号 `negate` 作为要加上的值（其作用等同于 `+1` 的进位输入）。\n\n现在，我们来分析为什么其他选项是错误的：\n\n- **B. `assign Y = negate ? (~X + 1) : X;`**：这个语句在功能上是正确的。它使用三元条件运算符 (`?:`) 在 `X` 和 `-X` 之间进行选择。然而，它模拟的是一个在两个独立计算的值之间进行选择的多路复用器。它没有模拟问题背景中描述的单一、可重构的数据通路（异或门组馈送一个加法器），而 `(X ^ S) + S` 正是代表了这种结构。问题要求的是基于那一特定原理的实现。\n\n- **C. `assign Y = (X  {8{negate}}) + negate;`**：这使用了按位与 (``)。\n    - 如果 `negate = 0`，它变为 `(X  8'b0) + 0`，结果为 `0`。这是错误的，因为输出应为 `X`。\n    - 如果 `negate = 1`，它变为 `(X  8'b11111111) + 1`，即 `X + 1`。这也是错误的。\n\n- **D. `assign Y = ~X + negate;`**：\n    - 如果 `negate = 0`，它变为 `~X + 0`，结果为 `~X`。这是错误的，因为输出应为 `X`。\n    - 如果 `negate = 1`，它变为 `~X + 1`，这在这种情况下是正确的。然而，由于它在 `negate = 0` 时失败，整个表达式是错误的。\n\n- **E. `assign Y = (X ~^ {8{negate}}) + negate;`**：这使用了按位同或 (`~^`)。`A ~^ B` 等价于 `~(A ^ B)`。\n    - 如果 `negate = 1`，它变为 `(X ~^ 8'b1) + 1`，即 `~(X ^ 8'b1) + 1`。\n    - `X ^ 8'b1` 是 `~X`。\n    - 所以表达式是 `~(~X) + 1`，简化为 `X + 1`。这是错误的。\n\n基于此分析，选项 A 是唯一一个在所有情况下功能正确，并且直接模拟了问题陈述中描述的特定硬件实现原理的选项。", "answer": "$$\\boxed{A}$$", "id": "1925996"}]}