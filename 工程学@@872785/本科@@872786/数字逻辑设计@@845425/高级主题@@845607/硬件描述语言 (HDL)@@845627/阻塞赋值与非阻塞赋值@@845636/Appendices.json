{"hands_on_practices": [{"introduction": "要想精通时序逻辑设计，理解非阻塞赋值（`=`）的基本行为至关重要。第一个练习要求你预测在单个时钟周期内，作用于同一个寄存器的两个非阻塞赋值语句的最终结果。这直接考验了“先读取所有右侧值，再更新所有左侧寄存器”的核心原则，这对于模拟并行硬件行为至关重要。", "problem": "在一个使用 Verilog 硬件描述语言 (HDL) 指定的数字电路设计中，一个名为 `vec` 的 4 位寄存器被声明为 `reg [3:0] vec;`。在时间 `t = 0` 时，该寄存器持有初始值 `4'b0010`。更新此寄存器的逻辑在一个对时钟信号 `clk` 的上升沿敏感的时钟进程中实现，如下面的代码片段所示：\n\n```verilog\nalways @(posedge clk) begin\n  vec[1:0] = 2'b11;\n  vec[3:2] = vec[1:0];\nend\n```\n\n假设系统以给定的初始值启动，并且第一个时钟上升沿发生在时间 `t_1  0`，确定在此第一个时钟沿之后寄存器 `vec` 的二进制值。\n\nA. `4'b0010`\n\nB. `4'b0011`\n\nC. `4'b1011`\n\nD. `4'b1111`", "solution": "我们给定一个 4 位寄存器，其初始值为 vec = 4'b0010，即 $vec[3:0] = (0,0,1,0)$，因此在 $t=0$ 时，$vec[1:0] = (1,0)$ 且 $vec[3:2] = (0,0)$。\n\n在时间 $t_{1}$ 的第一个 clk 上升沿，该进程执行两个非阻塞赋值。非阻塞赋值（`=`）的语义是：\n- 所有右侧表达式都使用时钟沿之前（旧）的值进行求值。\n- 在所有求值完成后，所有左侧变量将同时更新。\n\n因此，在上升沿时：\n1) 第一个赋值 `vec[1:0] = 2'b11;` 的右侧是一个常量，因此它调度了 `vec[1:0]` 的更新为 `2'b11`。\n2) 第二个赋值 `vec[3:2] = vec[1:0];` 的右侧是 `vec[1:0]` 的旧值，即 `2'b10`，因此它调度了 `vec[3:2]` 的更新为 `2'b10`。\n\n在两个已调度的更新同时生效后，新的寄存器值为\n$$vec[3:0] = (1,0,1,1),$$\n即二进制值 `4'b1011`，也就是选项 C。", "answer": "$$\\boxed{C}$$", "id": "1915845"}, {"introduction": "虽然 Verilog 允许在时钟模块中混合使用阻塞赋值（`=`）和非阻塞赋值（`=`），但这种做法是设计错误的常见来源。这个问题展示了一个看似简单的模块，它恰好混合了两种赋值方式，从而产生了可能不直观的行为。通过追踪信号，你将揭示这种混合如何造成意想不到的延迟，从而强化在时序逻辑中应专门使用非阻塞赋值进行状态更新的设计准则。", "problem": "在 Verilog 数字逻辑设计中，时钟驱动的过程块内阻塞赋值 (`=`) 和非阻塞赋值 (`=`) 之间的区别对于描述预期的硬件至关重要。请看以下 Verilog 模块代码片段：\n\n```verilog\nmodule mixed_assignments (\n  input  wire       clk,\n  input  wire       rst_n, // active-low asynchronous reset\n  input  wire       data_in,\n  output reg        data_out\n);\n\n  reg temp;\n\n  always @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n      temp = 1'b0;\n      data_out = 1'b0;\n    end else begin\n      temp = data_in;\n      data_out = temp;\n    end\n  end\n\nendmodule\n```\n\n一系列事件被施加到该模块的输入端。时钟信号 `clk` 的周期为 20 ns，其上升沿出现在 `t = 10, 30, 50, 70, ...` ns。复位信号 `rst_n` 在 `t  5` ns 期间有效（低电平），并在 `t >= 5` ns 期间无效（高电平）。输入 `data_in` 保持为 0，除了在 `25 ns = t  45 ns` 这段时间内有一个值为 1 的脉冲。\n\n输出信号 `data_out` 在时间 `t = 40` ns、`t = 60` ns 和 `t = 80` ns 的值分别是多少？\n\nA. 1, 0, 0\n\nB. 0, 1, 0\n\nC. 0, 0, 1\n\nD. 1, 1, 0\n\nE. 0, 0, 0", "solution": "为了解决这个问题，我们必须追踪寄存器 `temp` 和 `data_out` 在几个时钟周期内的值，并密切关注 `always` 块内阻塞 (`=`) 和非阻塞 (`=`) 赋值的规则。\n\n`always` 块在 `t  5` ns 期间因异步复位而激活，`temp` 和 `data_out` 都被非阻塞地赋值为 0。在所有相关的时钟沿（t >= 10 ns），`rst_n` 均为高电平，因此 `else` 块将被执行。\n\n`else` 块包含两条语句：\n1. `temp = data_in;` (非阻塞赋值)\n2. `data_out = temp;` (阻塞赋值)\n\n在一个时钟上升沿，`always` 块内的语句按顺序执行：\n- `temp = data_in;`: `data_in` 的当前值被求值，`temp` 的更新被调度到当前时间步的末尾。\n- `data_out = temp;`: `temp` 的值被求值，`data_out` 被立即更新。关键是，这个求值使用的是 `temp` 在该时间步开始时的值，因为 `temp = data_in` 的更新尚未生效。\n\n这实际上建立了一个两级流水线结构，其中 `data_in` 的值在一个周期后出现在 `temp` 中，再在一个周期后出现在 `data_out` 中。因此，`data_out` 的值反映的是 `temp` 在上一个周期的值。\n\n让我们逐个周期地追踪信号。\n初始状态 (由于复位)：`temp = 0`, `data_out = 0`。\n\n**周期 1：`t = 10` ns 的 `posedge clk`**\n- `data_in` = 0。`temp` 在此周期开始时为 0。\n- `temp = 0;` 被调度。\n- `data_out = 0;` (使用 `temp` 的旧值 0) 立即执行。\n- 在 `t=10` ns 之后的状态：`temp = 0`, `data_out = 0`。\n\n**周期 2：`t = 30` ns 的 `posedge clk`**\n- `data_in` = 1。`temp` 在此周期开始时为 0。\n- `temp = 1;` 被调度。\n- `data_out = 0;` (使用 `temp` 的旧值 0) 立即执行。\n- 在 `t=30` ns 之后的状态：`temp = 1`, `data_out = 0`。\n\n**在 `t = 40` ns 的求值：**\n`data_out` 的值由 `t=30` ns 的赋值决定，因此在 `t=40` ns 时, `data_out` 是 **0**。\n\n**周期 3：`t = 50` ns 的 `posedge clk`**\n- `data_in` = 0。`temp` 在此周期开始时为 1。\n- `temp = 0;` 被调度。\n- `data_out = 1;` (使用 `temp` 的旧值 1) 立即执行。\n- 在 `t=50` ns 之后的状态：`temp = 0`, `data_out = 1`。\n\n**在 `t = 60` ns 的求值：**\n`data_out` 的值由 `t=50` ns 的赋值决定，因此在 `t=60` ns 时, `data_out` 是 **1**。\n\n**周期 4：`t = 70` ns 的 `posedge clk`**\n- `data_in` = 0。`temp` 在此周期开始时为 0。\n- `temp = 0;` 被调度。\n- `data_out = 0;` (使用 `temp` 的旧值 0) 立即执行。\n- 在 `t=70` ns 之后的状态：`temp = 0`, `data_out = 0`。\n\n**在 `t = 80` ns 的求值：**\n`data_out` 的值由 `t=70` ns 的赋值决定，因此在 `t=80` ns 时, `data_out` 是 **0**。\n\n综合结果，`data_out` 在 `t = 40, 60, 80` ns 的值是 (0, 1, 0)。这对应于选项 B。", "answer": "$$\\boxed{B}$$", "id": "1915859"}, {"introduction": "赋值规则是与上下文相关的；适用于时序逻辑的规则对于组合逻辑通常是错误的。最后一个练习将我们的重点转移到用于模拟组合电路（如优先编码器）的 `always @(*)` 模块。你的任务是找出正确的实现方式，这将展示为什么阻塞赋值（`=`）是组合逻辑的标准选择，以确保输出随输入变化而即时更新。", "problem": "一位初级数字设计工程师的任务是使用 Verilog 创建一个 4-2 优先编码器。该编码器有一个 4 位数据输入 `d[3:0]`、一个 2 位编码输出 `y[1:0]` 和一个 1 位有效输出 `v`。电路应按如下方式工作：\n\n-   输出 `y` 应表示输入 `d` 中为高电平的最高有效位 (MSB) 的二进制索引。优先级从 MSB 到 LSB，意味着 `d[3]` 具有最高优先级，`d[0]` 具有最低优先级。\n-   如果 `d[3]` 为高电平，`y` 应为 `2'b11`。\n-   如果 `d[3]` 为低电平但 `d[2]` 为高电平，`y` 应为 `2'b10`。\n-   如果 `d[3]` 和 `d[2]` 为低电平但 `d[1]` 为高电平，`y` 应为 `2'b01`。\n-   如果 `d[3]`、`d[2]` 和 `d[1]` 为低电平但 `d[0]` 为高电平，`y` 应为 `2'b00`。\n-   如果 `d` 中至少有一位为高电平，则有效位 `v` 应为高电平。如果 `d` 是 `4'b0000`，则 `v` 应为低电平，且 `y` 的值无关紧要（don't care）。\n\n该工程师使用单个组合逻辑 `always @(*)` 块编写了一个初始实现。然而，在仿真期间，输出 `y` 和 `v` 未能在与输入 `d` 相同的仿真时间步内正确更新，导致在集成到更大的系统中时出现功能故障。\n\n你的任务是从以下选项中找出一个正确的实现，该实现描述了一个纯组合逻辑的优先编码器，并能在仿真和综合中可靠地产生正确的输出。\n\nA.\n```verilog\nalways @(*) begin\n  if (d[0]) begin\n    y = 2'b00;\n    v = 1'b1;\n  end else if (d[1]) begin\n    y = 2'b01;\n    v = 1'b1;\n  end else if (d[2]) begin\n    y = 2'b10;\n    v = 1'b1;\n  end else if (d[3]) begin\n    y = 2'b11;\n    v = 1'b1;\n  end else begin\n    y = 2'b00; // a 'don't care' value\n    v = 1'b0;\n  end\nend\n```\n\nB.\n```verilog\nalways @(*) begin\n  if (d[3]) begin\n    y = 2'b11;\n    v = 1'b1;\n  end else if (d[2]) begin\n    y = 2'b10;\n    v = 1'b1;\n  end else if (d[1]) begin\n    y = 2'b01;\n    v = 1'b1;\n  end else if (d[0]) begin\n    y = 2'b00;\n    v = 1'b1;\n  end else begin\n    y = 2'b00; // a 'don't care' value\n    v = 1'b0;\n  end\nend\n```\n\nC.\n```verilog\nalways @(*) begin\n  if (d[3]) begin\n    y = 2'b11;\n    v = 1'b1;\n  end else if (d[2]) begin\n    y = 2'b10;\n    v = 1'b1;\n  end else if (d[1]) begin\n    y = 2'b01;\n    v = 1'b1;\n  end else if (d[0]) begin\n    y = 2'b00;\n    v = 1'b1;\n  end else begin\n    y = 2'b00; // a 'don't care' value\n    v = 1'b0;\n  end\nend\n```\n\nD.\n```verilog\nalways @(*) begin\n  casex (d)\n    4'b1xxx: y = 2'b11;\n    4'b01xx: y = 2'b10;\n    4'b001x: y = 2'b01;\n    4'b0001: y = 2'b00;\n    default: y = 2'b00; // a 'don't care' value\n  endcase\n  \n  if (|d) begin\n    v = 1'b1;\n  end else begin\n    v = 1'b0;\n  end\nend\n```\n\nE.\n```verilog\nalways @(*) begin\n  y = 2'b00; // Default assignment\n  v = 1'b0;  // Default assignment\n  if (d[3]) begin\n    y = 2'b11;\n    v = 1'b1;\n  end else if (d[2]) begin\n    y = 2'b10;\n    v = 1'b1;\n  end else if (d[1]) begin\n    y = 2'b01;\n    v = 1'b1;\n  end else if (d[0]) {v, y} = {1'b1, 2'b00};\nend\n```", "solution": "我们需要一个纯组合逻辑的优先编码器，它：\n- 给予 MSB 优先：检查 $d[3]$，然后是 $d[2]$，然后是 $d[1]$，最后是 $d[0]$。\n- 在所有分支中驱动两个输出以避免产生锁存器。\n- 在组合逻辑 `always` 块中使用阻塞赋值 (`=`)，以便输出能在同一仿真时间步（delta 周期）内反映输入的变化。在组合逻辑中使用非阻塞赋值 (`=`) 会延迟更新，从而产生所描述的仿真问题。\n\n评估每个选项：\n\nA. 这在组合逻辑块中使用了阻塞赋值，但它从 LSB 检查到 MSB。如果有多个位为高电平，它会错误地将 $d[0]$ 的优先级置于 $d[3]$ 之上，违反了要求的 MSB 优先原则。因此，A 是不正确的。\n\nB. 这在组合逻辑 `always @(*)` 块中使用了非阻塞赋值 (`=`)。非阻塞赋值将更新推迟到时间步结束时，当与其他逻辑集成时，这可能导致输出无法在同一仿真时间步内按预期更新。这与报告的故障模式相符，因此 B 不是正确的修复方案。\n\nC. 这在组合逻辑 `always @(*)` 块中使用了阻塞赋值 (`=`)，并具有正确的 MSB 到 LSB 的优先级顺序。在 `if-else` 结构的每个分支中都对所有输出进行了赋值，因此不会推断出锁存器。这是在仿真和综合中实现组合逻辑优先编码器的标准、可靠的风格。\n\nD. 这使用 `casex` 进行优先级判断，并为有效位 `v` 使用了一个独立的条件语句。虽然可综合，但 `casex` 在处理 `x` 和 `z` 状态时可能导致仿真与综合不匹配，因此在 RTL 设计中通常不推荐使用。此外，将逻辑分成两个独立的块可能不如单个集成的 `if-else` 结构清晰。因此，D 不是最佳选择。\n\nE. 此选项中的所有赋值均为阻塞赋值，因此不存在混合赋值的问题。虽然此代码在功能上是正确的（它使用带有默认赋值的 `if-else` 结构来避免锁存器），但与选项 C 相比，其编码风格不一致（在最后一个条件中使用了连接赋值）。选项 C 的结构更统一，通常被认为是更清晰的实现。因此，C 是最佳选择。\n\n因此，正确的实现是 C。", "answer": "$$\\boxed{C}$$", "id": "1915902"}]}