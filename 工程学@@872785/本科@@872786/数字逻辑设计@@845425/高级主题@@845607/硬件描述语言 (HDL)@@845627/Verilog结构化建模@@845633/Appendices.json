{"hands_on_practices": [{"introduction": "复杂的数字系统，如算术逻辑单元（ALU），通常由更小的、可重用的构建块分层搭建而成。本练习将通过结构化建模的方式，实践如何将一个预定义的全加器模块与基本逻辑门组合起来，构建一个1位ALU切片[@problem_id:1964327]。通过这个练习，你将掌握如何实例化模块、连接信号，并使用控制信号来实现不同功能（如加法和逻辑运算）的选择，这是结构化建模中的一项核心技能。", "problem": "您的任务是使用 Verilog 创建一个名为 `ALU_slice` 的 1 位处理切片模块。该模块应通过实例化门级原语和一个已提供的 `full_adder` 模块，使用结构化建模来实现。\n\n**模块规范：**\n\n`ALU_slice` 模块具有以下端口：\n- 输入：`a` (1 位)、`b` (1 位)、`cin` (1 位进位输入)、`op` (1 位操作选择)。\n- 输出：`result` (1 位)、`cout` (1 位进位输出)。\n\n**功能行为：**\n\n该模块必须根据 `op` 信号执行两种操作之一：\n1.  如果 `op` 为 `0`，模块执行逻辑异或（XOR）操作。\n    - `result` 应为 `a XOR b`。\n    - `cout` 应为 `0`。\n2.  如果 `op` 为 `1`，模块执行算术加法（ADD）操作。\n    - `result` 应为 `a`、`b` 和 `cin` 的和。\n    - `cout` 应为加法产生的进位输出。\n\n**结构约束：**\n\n您的设计必须在结构上实例化并连接以下组件：\n- 一个 `full_adder` 模块（Verilog 代码如下所示）。\n- 一个用于逻辑操作的原语 `xor` 门。\n- 一个用于正确生成最终 `cout` 信号的原语 `and` 门。\n- 一个等效于 2-1 多路选择器的逻辑，由原语 `and`、`or`、`not` 门构建，用于选择最终的 `result`。\n\n**已提供的 `full_adder` 模块：**\n\n您必须使用以下 `full_adder` 模块，不得修改。\n\n```verilog\n// full_adder module\n// Outputs: sum, cout\n// Inputs: x, y, z\nmodule full_adder(sum, cout, x, y, z);\n  output sum, cout;\n  input  x, y, z;\n  wire   w1, w2, w3;\n\n  xor(w1, x, y);\n  xor(sum, w1, z);\n  and(w2, x, y);\n  and(w3, w1, z);\n  or(cout, w2, w3);\nendmodule\n```\n\n**问题：**\n\n以下哪个 Verilog 代码块根据所有规范正确地实现了 `ALU_slice` 模块？\n\n**A.**\n```verilog\nmodule ALU_slice(result, cout, a, b, cin, op);\n  output result, cout;\n  input a, b, cin, op;\n  wire fa_sum, fa_cout, xor_out;\n  wire s_not, w0, w1;\n\n  full_adder FA(fa_sum, fa_cout, a, b, cin);\n  xor G1(xor_out, a, b);\n\n  not N1(s_not, op);\n  and A1(w0, fa_sum, s_not); // MUX path for op=0 connected to fa_sum\n  and A2(w1, xor_out, op);   // MUX path for op=1 connected to xor_out\n  or O1(result, w0, w1);\n\n  and A3(cout, fa_cout, op);\nendmodule\n```\n\n**B.**\n```verilog\nmodule ALU_slice(result, cout, a, b, cin, op);\n  output result, cout;\n  input a, b, cin, op;\n  wire fa_sum, fa_cout, xor_out;\n  wire s_not, w0, w1;\n\n  full_adder FA(fa_sum, fa_cout, a, b, cin);\n  xor G1(xor_out, a, b);\n\n  not N1(s_not, op);\n  and A1(w0, xor_out, s_not);\n  and A2(w1, fa_sum, op);\n  or O1(result, w0, w1);\n\n  assign cout = fa_cout; // Incorrect cout logic\nendmodule\n```\n\n**C.**\n```verilog\nmodule ALU_slice(result, cout, a, b, cin, op);\n  output result, cout;\n  input a, b, cin, op;\n  wire fa_sum, fa_cout, xor_out;\n  wire s_not, w0, w1;\n\n  full_adder FA(fa_sum, fa_cout, a, b, cin);\n  xor G1(xor_out, a, b);\n\n  not N1(s_not, op);\n  and A1(w0, xor_out, s_not); // MUX path for op=0\n  and A2(w1, fa_sum, op);     // MUX path for op=1\n  or O1(result, w0, w1);\n\n  and A3(cout, fa_cout, op);\nendmodule\n```\n\n**D.**\n```verilog\nmodule ALU_slice(result, cout, a, b, cin, op);\n  output result, cout;\n  input a, b, cin, op;\n  wire fa_sum, fa_cout, xor_out;\n  wire s_not, w0, w1;\n\n  // Incorrect port mapping for full_adder\n  full_adder FA(fa_sum, fa_cout, a, b, op); \n  xor G1(xor_out, a, b);\n\n  not N1(s_not, op);\n  and A1(w0, xor_out, s_not);\n  and A2(w1, fa_sum, op);\n  or O1(result, w0, w1);\n\n  and A3(cout, fa_cout, op);\nendmodule\n```", "solution": "我们需要一个 1 位 ALU 切片，在 $op$ 的控制下，它可以在以下两者之间进行选择：\n- 当 $op=0$ 时进行逻辑异或：$result = a \\oplus b$, $cout=0$。\n- 当 $op=1$ 时进行算术加法：$result = sum(a,b,cin)$, $cout = carry\\_out(a,b,cin)$。\n\n设全加器对于输入 $(a,b,cin)$ 的输出为 $fa\\_sum$ 和 $fa\\_cout$，因此：\n- $fa\\_sum$ 是 $a+b+cin$ 的和位，\n- $fa\\_cout$ 是进位输出位。\n\n我们还实例化一个原语异或门，产生 $xor\\_out = a \\oplus b$。\n\n最终的 $result$ 必须由一个用原语门构建的二选一多路选择器来选择，以满足：\n$$\nresult = (\\lnot op) \\cdot (a \\oplus b) \\;\\; \\lor \\;\\; op \\cdot fa\\_sum.\n$$\n这在结构上是通过一个 NOT 门形成 $s\\_not=\\lnot op$ 和两个 AND 门来实现的：\n$$\nw0 = (a \\oplus b) \\cdot (\\lnot op), \\quad w1 = fa\\_sum \\cdot op,\n$$\n以及一个 OR 门：\n$$\nresult = w0 \\lor w1.\n$$\n\n所需的 $cout$ 行为是：\n$$\ncout =\n\\begin{cases}\n0,  op=0, \\\\\nfa\\_cout,  op=1,\n\\end{cases}\n$$\n这正是门控表达式\n$$\ncout = op \\cdot fa\\_cout,\n$$\n并且按要求使用一个原语 AND 门来生成最终的 $cout$。\n\n现在，根据这些等式和结构约束来检查每个选项：\n\n- 选项 A 将 MUX 路径连接为 $w0 = fa\\_sum \\cdot (\\lnot op)$ 和 $w1 = (a \\oplus b) \\cdot op$，得到\n$$\nresult = (\\lnot op)\\cdot fa\\_sum \\;\\lor\\; op \\cdot (a \\oplus b),\n$$\n这与所需的选择逻辑相反。因此，它不满足功能行为的要求。\n\n- 选项 B 实现了正确的 MUX：\n$$\nresult = (\\lnot op)\\cdot (a \\oplus b) \\;\\lor\\; op \\cdot fa\\_sum,\n$$\n但它无条件地将 $cout$ 设置为 $fa\\_cout$，这违反了当 $op=0$ 时 $cout=0$ 的要求，以及使用一个原语 AND 门来生成最终 $cout$ 的要求。\n\n- 选项 C 完全匹配：\n  - 对 $(a,b,cin)$ 使用全加器，\n  - $xor\\_out = a \\oplus b$，\n  - 使用 NOT/AND/OR 实现 MUX 为 $result = (\\lnot op)\\cdot (a \\oplus b) \\;\\lor\\; op \\cdot fa\\_sum$，\n  - 使用一个 AND 门实现 $cout = op \\cdot fa\\_cout$。\n  它同时满足了功能行为和结构约束。\n\n- 选项 D 错误地将 $op$ 而不是 $cin$ 作为全加器的第三个输入，因此加法忽略了 $cin$，功能上是错误的。\n\n因此，唯一正确的实现是选项 C。", "answer": "$$\\boxed{C}$$", "id": "1964327"}, {"introduction": "在掌握了组合逻辑的结构化建模后，下一步是构建具有记忆功能（即状态）的时序电路。本练习将指导你通过结构化地连接一组D触发器，来构建一个4位的“扭环计数器”（Johnson counter）[@problem_id:1964346]。这个实践的核心在于将电路的状态转移描述转化为具体的硬件连接，让你深刻理解如何通过模块实例化来创建移位寄存器和反馈路径，这是设计时序控制逻辑的基础。", "problem": "在数字系统中，控制逻辑通常需要特定的状态序列。你的任务是设计一个4位时序电路，我们称之为“扭环计数器”。该电路的行为和结构定义如下。\n\n电路有一个时钟输入 `clk`，一个低电平有效异步复位 `rst_n`，以及一个4位输出总线 `Q[3:0]`。当电路复位时（`rst_n` 为低电平），输出 `Q` 必须为 `4'b0000`。\n\n在非复位状态下，状态在 `clk` 的每个上升沿转换。数据路径遵循一个特定的移位和反馈模式：`Q[3]` 的值移到 `Q[2]`，`Q[2]` 的值移到 `Q[1]`，`Q[1]` 的值移到 `Q[0]`。该计数器的“扭曲”之处在于其反馈回路：最高有效位 `Q[3]` 的新值由最低有效位 `Q[0]` 的*反相*当前值决定。\n\n你的实现必须是纯结构化的。你需要使用一个名为 `d_ff` 的预定义D型触发器模块，该模块具有低电平有效异步复位功能。这个基本构建模块的Verilog定义如下：\n\n```verilog\nmodule d_ff (\n    output reg q,\n    input d,\n    input clk,\n    input rst_n\n);\n    // On the rising edge of the clock or falling edge of reset\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            q = 1'b0; // Asynchronous reset to 0\n        else\n            q = d;    // Synchronous data load\n    end\nendmodule\n```\n\n你需要通过结构化地实例化并连接四个 `d_ff` 模块的实例来完成下面的 `twisted_ring_counter` 模块的主体部分。\n\n```verilog\nmodule twisted_ring_counter (\n    output [3:0] Q,\n    input clk,\n    input rst_n\n);\n\n    // -- SELECT THE CORRECT CODE BLOCK FOR THIS SECTION --\n\nendmodule\n```\n\n根据规范，以下哪个Verilog代码片段正确实现了 `twisted_ring_counter` 模块的主体部分？\n\nA.\n```verilog\nwire not_Q0;\nassign not_Q0 = ~Q[0];\n\nd_ff ff3 (.q(Q[3]), .d(not_Q0), .clk(clk), .rst_n(rst_n));\nd_ff ff2 (.q(Q[2]), .d(Q[3]),   .clk(clk), .rst_n(rst_n));\nd_ff ff1 (.q(Q[1]), .d(Q[2]),   .clk(clk), .rst_n(rst_n));\nd_ff ff0 (.q(Q[0]), .d(Q[1]),   .clk(clk), .rst_n(rst_n));\n```\n\nB.\n```verilog\nd_ff ff3 (.q(Q[3]), .d(Q[0]),   .clk(clk), .rst_n(rst_n));\nd_ff ff2 (.q(Q[2]), .d(Q[3]),   .clk(clk), .rst_n(rst_n));\nd_ff ff1 (.q(Q[1]), .d(Q[2]),   .clk(clk), .rst_n(rst_n));\nd_ff ff0 (.q(Q[0]), .d(Q[1]),   .clk(clk), .rst_n(rst_n));\n```\n\nC.\n```verilog\nwire not_Q3;\nassign not_Q3 = ~Q[3];\n\nd_ff ff3 (.q(Q[3]), .d(Q[2]),   .clk(clk), .rst_n(rst_n));\nd_ff ff2 (.q(Q[2]), .d(Q[1]),   .clk(clk), .rst_n(rst_n));\nd_ff ff1 (.q(Q[1]), .d(Q[0]),   .clk(clk), .rst_n(rst_n));\nd_ff ff0 (.q(Q[0]), .d(not_Q3), .clk(clk), .rst_n(rst_n));\n```\n\nD.\n```verilog\nwire not_Q3;\nassign not_Q3 = ~Q[3];\n\nd_ff ff3 (.q(Q[3]), .d(not_Q3), .clk(clk), .rst_n(rst_n));\nd_ff ff2 (.q(Q[2]), .d(Q[3]),   .clk(clk), .rst_n(rst_n));\nd_ff ff1 (.q(Q[1]), .d(Q[2]),   .clk(clk), .rst_n(rst_n));\nd_ff ff0 (.q(Q[0]), .d(Q[1]),   .clk(clk), .rst_n(rst_n));\n```", "solution": "我们通过用当前输出表示次态方程来解释该规范。令 $Q_{i}^{+}$ 表示在 `clk` 的下一个上升沿之后 $Q[i]$ 的值（假设 $rst_n=1$）。所需的转换是：\n$$Q_{2}^{+}=Q_{3},\\quad Q_{1}^{+}=Q_{2},\\quad Q_{0}^{+}=Q_{1},\\quad Q_{3}^{+}=\\overline{Q_{0}}.$$\n因为所提供的 $d_ff$ 在 `clk` 的上升沿将其输入 $d$ 加载到 $q$ 中（除非异步复位，此时输出为 $0$），所以结构化地实现这些方程需要将每个触发器的 $d$ 输入连接到相应的右侧表达式：\n- 对于 $Q[3]$: $d=\\overline{Q[0]}$,\n- 对于 $Q[2]$: $d=Q[3]$,\n- 对于 $Q[1]$: $d=Q[2]$,\n- 对于 $Q[0]$: $d=Q[1]$.\n\n对照这些方程检查每个选项：\n- 选项A计算了一条用于 $\\overline{Q[0]}$ 的线网，并将 $d$ 输入连接为 $Q[3]\\leftarrow\\overline{Q[0]}$，$Q[2]\\leftarrow Q[3]$，$Q[1]\\leftarrow Q[2]$，$Q[0]\\leftarrow Q[1]$，这与所需的次态方程完全匹配。\n- 选项B使用 $Q[3]\\leftarrow Q[0]$（缺少反相），因此不满足 $Q_{3}^{+}=\\overline{Q_{0}}$。\n- 选项C实现了 $Q[3]\\leftarrow Q[2]$，$Q[2]\\leftarrow Q[1]$，$Q[1]\\leftarrow Q[0]$，$Q[0]\\leftarrow\\overline{Q[3]}$，这不仅移位方向相反，而且反相了错误的位。\n- 选项D使用 $Q[3]\\leftarrow\\overline{Q[3]}$，这使得 $Q[3]$ 无论 $Q[0]$ 如何都会翻转，违反了所需的反馈要求。\n\n所有选项都使用相同的具有低电平有效异步复位的 $d_ff$，因此在每种情况下，$rst_n=0$ 时 $Q=4'b0000$ 的复位行为都在结构上得到满足；区别在于 $d$ 输入的接线是否正确。因此，只有选项A正确实现了指定的扭环计数器。", "answer": "$$\\boxed{A}$$", "id": "1964346"}, {"introduction": "在数字设计中，我们常常需要在硬件资源消耗和处理速度之间做出权衡，而串行计算是实现资源优化的经典方法。本练习将挑战你设计一个比特串行加法器，它通过巧妙地组合一个全加器（组合逻辑）和一个用于存储进位的触发器（时序逻辑）来实现[@problem_id:1964345]。这项实践揭示了一种强大的设计模式——如何利用时序元件来控制和复用单个组合逻辑单元，从而在多个时钟周期内完成复杂操作，这对于设计面积高效的系统至关重要。", "problem": "您的任务是使用 Verilog 设计一个 4 位位串行加法器。位串行加法器在每个时钟周期处理多位数字的一个位，从最低有效位 (LSB) 开始。该设计必须是纯结构化的，使用一个预定义的 `full_adder` 模块和用于状态保持的触发器。\n\n您正在设计的 `serial_adder` 模块具有以下接口：\n- **输入**：\n    - `clk`：一个 1 位的时钟信号。\n    - `reset`：一个 1 位的高电平有效异步复位信号。当该信号有效时，加法器应被初始化以进行新的 4 位加法运算。\n    - `a`、`b`：1 位的输入，代表两个相加数字的当前位。\n- **输出**：\n    - `s`：一个 1 位的输出，用于表示当前和位。\n    - `done`：一个 1 位的信号，该信号应在产生最高有效位 (MSB) 和的那个周期内，被置为高电平，且仅持续一个时钟周期。\n\n我们为您提供了一个 `full_adder` 模块，其接口如下：\n`module full_adder(input a, b, cin, output s, cout);`\n\n您的 `serial_adder` 必须根据以下规则实现：\n1.  它必须且仅能实例化一个 `full_adder`。\n2.  一位加法的进位输出必须被存储，并在下一个时钟周期用作下一位加法的进位输入。LSB 的初始进位输入必须为 0。这种状态保持必须使用寄存器来实现。\n3.  必须使用一个 2 位计数器来跟踪正在处理的位位置（从位 0 到位 3）。该计数器也必须由 `reset` 信号复位。\n\n下面是 `serial_adder` 模块体的四种可能实现。请选择唯一正确实现了指定的 4 位位串行加法器的选项。\n\n**模块头：**\n`module serial_adder(input clk, reset, a, b, output s, done);`\n\n**代码片段：**\n\n**A.**\n```verilog\nwire carry_out;\nreg carry_reg;\nreg [1:0] count;\n\nfull_adder fa_inst (.a(a), .b(b), .cin(carry_reg), .s(s), .cout(carry_out));\n\nalways @(posedge clk or posedge reset) begin\n    if (reset)\n        carry_reg = 1'b0;\n    else\n        carry_reg = carry_out;\nend\n\nalways @(posedge clk or posedge reset) begin\n    if (reset)\n        count = 2'b00;\n    else if (count == 2'b11)\n        count = 2'b00;\n    else\n        count = count + 1;\nend\n\nassign done = (count == 2'b11);\n```\n\n**B.**\n```verilog\nwire carry;\nreg [1:0] count;\n\nfull_adder fa_inst (.a(a), .b(b), .cin(carry), .s(s), .cout(carry));\n\nalways @(posedge clk or posedge reset) begin\n    if (reset)\n        count = 2'b00;\n    else\n        count = count + 1;\nend\n\nassign done = (count == 2'b11);\n```\n\n**C.**\n```verilog\nwire carry_out;\nreg carry_reg;\nreg [1:0] count;\n\nfull_adder fa_inst (.a(a), .b(b), .cin(carry_reg), .s(s), .cout(carry_out));\n\nalways @(posedge clk or posedge reset) begin\n    if (reset)\n        carry_reg = 1'b1; // Reset carry to 1\n    else\n        carry_reg = carry_out;\nend\n\nalways @(posedge clk or posedge reset) begin\n    if (reset)\n        count = 2'b00;\n    else\n        count = count + 1;\nend\n\nassign done = (count == 2'b11);\n```\n\n**D.**\n```verilog\nwire carry_out;\nreg carry_reg;\nreg [1:0] count;\n\nfull_adder fa_inst (.a(a), .b(b), .cin(carry_reg), .s(s), .cout(s)); // Incorrect connection\n\nalways @(posedge clk or posedge reset) begin\n    if (reset)\n        carry_reg = 1'b0;\n    else\n        carry_reg = carry_out;\nend\n\nalways @(posedge clk or posedge reset) begin\n    if (reset)\n        count = 2'b00;\n    else\n        count = count + 1;\nend\n\nassign done = (count == 2'b10); // Incorrect done logic\n```", "solution": "我们首先重申一下 4 位位串行加法器所需的行为：\n\n- 必须且仅能实例化一个全加器，当前位的进位输出存储在一个寄存器中，并在下一个时钟周期用作进位输入。最低有效位的初始进位输入必须为零，这通过复位来强制实现，因此进位寄存器必须异步复位为零。\n- 一个 2 位计数器必须跟踪从 $0$ 到 $3$ 的位索引。该计数器必须由复位信号异步复位。信号 $done$ 必须在产生最高有效位和的同一时刻置为高电平，且仅持续一个时钟周期，即当当前位索引等于 $3$ 时。\n\n我们根据这些规则评估每个选项。\n\n选项 A：\n- 它实例化了且仅实例化了一个全加器，其连接为：$cin$ 由寄存器化的进位驱动，而 $cout$ 在下一个时钟被捕获到进位寄存器中。进位寄存器异步复位为零：\n  - 在 $reset$ 时：$carry\\_reg \\leftarrow 0$，满足了最低有效位的初始进位输入要求。\n  - 在每个时钟上升沿：$carry\\_reg \\leftarrow carry\\_out$，正确地将进位在位处理时间之间流水化传输。\n- 它使用一个 2 位计数器，并异步复位为零。在每个时钟周期：\n  - 如果当前计数等于 $3$，它加载 $0$；否则，它加 $1$。这实现了复位后的循环 $0 \\to 1 \\to 2 \\to 3 \\to 0 \\to \\dots$。\n- $done$ 被组合地赋值为 $(count == 3)$。由于当前周期的 $s$ 是当前位索引的和，当 $count=3$ 时置位 $done$ 与 MSB 和的产生是同步的，并且因为计数器在下一个周期复位为 $0$，所以 $done$ 在每个四位加法序列中仅在一个周期内为高。这符合要求。\n\n因此，A 满足所有约束条件。\n\n选项 B：\n- 进位是一个 `wire`，它同时被馈入 $cin$ 并来自 $cout$，这会产生一个组合逻辑环路，更重要的是，它没有实现带有初始零值的寄存器化进位。没有寄存器来保持进位，也没有将进位复位为零的操作，这违反了状态保持要求和初始进位输入要求。\n- 尽管存在一个 2 位计数器并且当 $count=3$ 时 $done$ 被置位，但缺少进位寄存器使得此选项不合格。\n\n选项 C：\n- 进位寄存器被异步复位为 1，即在 $reset$ 时：$carry\\_reg \\leftarrow 1$，这违反了最低有效位的初始进位输入必须为零的要求。\n- 计数器在每个周期递增并异步复位为零；尽管 2 位的位宽会导致自然回绕，但错误的进位初始化已经使此选项无效。\n\n选项 D：\n- 全加器的 $cout$ 被错误地连接到了 $s$ 端口，并且声明的 $carry\\_out$ 没有连接到全加器的 $cout$，这使得进位寄存器的更新毫无意义。\n- $done$ 逻辑在 $count=2$ 时置位，而不是在 $count=3$ 时，因此它与 MSB 和的产生不同步。\n- 这些接线和逻辑错误违反了指定的行为。\n\n通过此分析，只有选项 A 正确实现了指定的 4 位位串行加法器：它使用了且仅使用了一个全加器，正确地将进位寄存并复位为零，使用了一个可复位的 2 位计数器以按 $0$ 到 $3$ 的顺序计数，并在 MSB 和位产生时精确地将 $done$ 置位一个周期。", "answer": "$$\\boxed{A}$$", "id": "1964345"}]}