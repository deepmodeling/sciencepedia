{"hands_on_practices": [{"introduction": "我们从一个基础的数据操作任务开始：反转一个向量的比特顺序。这项练习是学习在行为级 Verilog 中使用 `for` 循环来对数据总线执行结构化、比特级操作的绝佳入门，这是在与不同硬件标准接口时的一项常见要求。通过这个练习，你将掌握如何通过索引来精确控制和重新排列信号位。[@problem_id:1912832]", "problem": "在设计现代现场可编程门阵列（FPGA）与旧式外围设备之间的接口时，一位工程师发现存在数据格式不兼容的问题。该旧式设备使用一个8位并行总线，但其对比特顺序的解释与标准的MSB优先（最高有效位）约定相反。具体来说，FPGA认为是`data[7]`（MSB）的位被外围设备视为第0位，`data[6]`被视为第1位，以此类推，直到`data[0]`（最低有效位，LSB）被视为第7位。\n\n为了解决这个问题，必须创建一个行为级Verilog模块。该模块将有一个8位输入端口`data_in`和一个8位输出端口`data_out_rev`。逻辑必须确保对于任何给定的`data_in`，输出`data_out_rev`是其比特反转后的版本。例如，如果`data_in`是`8'b11001010`，那么`data_out_rev`必须是`8'b01010011`。\n\n以下哪段行为级Verilog代码片段（设计用于放置在`always @(data_in)`块内）正确实现了这种比特反转逻辑？假设`data_out_rev`已被声明为`reg [7:0] data_out_rev;`。\n\nA.\n```verilog\ninteger i;\nfor (i = 0; i  8; i = i + 1) begin\n    data_out_rev[i] = data_in[7-i];\nend\n```\n\nB.\n```verilog\ninteger i;\nfor (i = 0; i  8; i = i + 1) begin\n    data_out_rev[i] = data_in[i];\nend\n```\n\nC.\n```verilog\ndata_out_rev = ~data_in;\n```\n\nD.\n```verilog\ndata_out_rev = ^data_in;\n```", "solution": "我们需要输出总线是输入总线的比特反转版本。形式上，对于所有比特索引 $i \\in \\{0,1,\\dots,7\\}$，正确的映射关系是\n$$\n\\text{data\\_out\\_rev}[i] = \\text{data\\_in}[7 - i]\n$$\n。\n评估每个选项：\n\n- 选项A通过一个从0到7遍历$i$的循环，实现了所要求的映射关系，即赋值$\\text{data\\_out\\_rev}[i] = \\text{data\\_in}[7-i]$。这符合规范。\n\n- 选项B赋值$\\text{data\\_out\\_rev}[i] = \\text{data\\_in}[i]$，这会保持比特顺序不变，因此没有反转比特。\n\n- 选项C执行按位取反操作：$\\text{data\\_out\\_rev}[i] = \\lnot \\text{data\\_in}[i]$。这是对位进行取反，而不是反转它们的位置。\n\n- 选项D对`data_in`应用了归约异或（reduction XOR）操作，产生一个单位比特的奇偶校验结果$\\bigoplus_{i=0}^{7} \\text{data\\_in}[i]$，这没有实现比特反转，也没有产生所需的8位反转向量。\n\n因此，只有选项A是正确的。", "answer": "$$\\boxed{A}$$", "id": "1912832"}, {"introduction": "接下来，我们将探讨如何使用行为级模型来实现一个纯组合逻辑电路——汉明码编码器。这个练习侧重于运用 Verilog 中的按位逻辑运算符（如异或 `^`）来计算校验位，并精确地将数据位和校验位组合成最终的码字。这不仅是纠错码理论的实际应用，也强化了使用 `always @*` 块来描述复杂组合逻辑函数的能力。[@problem_id:1912766]", "problem": "您的任务是设计一个纯组合逻辑的 (7,4) 汉明码生成器 Verilog 电路。该电路接收一个 4 位数据字作为输入，并生成一个 7 位码字作为输出。\n\n输入是一个名为 `data_in[3:0]` 的 4 位向量。这四个比特对应于汉明码的数据部分，我们将其表示为 $d_4, d_3, d_2, d_1$，映射关系如下：\n- $d_4 = \\text{data\\_in}[3]$\n- $d_3 = \\text{data\\_in}[2]$\n- $d_2 = \\text{data\\_in}[1]$\n- $d_1 = \\text{data\\_in}[0]$\n\n该电路必须根据以下标准奇偶校验方程计算三个偶校验位 $p_4, p_2, p_1$，其中 $\\oplus$ 表示按位异或（XOR）操作：\n- $p_1 = d_1 \\oplus d_2 \\oplus d_4$\n- $p_2 = d_1 \\oplus d_3 \\oplus d_4$\n- $p_4 = d_2 \\oplus d_3 \\oplus d_4$\n\n最终的 7 位输出 `hamming_out[6:0]` 必须通过将数据位和计算出的校验位按以下特定位置排列来构成：\n- `hamming_out[6]` = $d_4$\n- `hamming_out[5]` = $d_3$\n- `hamming_out[4]` = $d_2$\n- `hamming_out[3]` = $p_4$\n- `hamming_out[2]` = $d_1$\n- `hamming_out[1]` = $p_2$\n- `hamming_out[0]` = $p_1$\n\n根据这些规范，请确定以下哪个 Verilog 模块正确实现了此汉明码生成器的行为模型。\n\nA.\n```verilog\nmodule hamming_encoder(\n    input [3:0] data_in,\n    output reg [6:0] hamming_out\n);\n    always @* begin\n        // Parity bits\n        hamming_out[0] = data_in[0] ^ data_in[1] ^ data_in[3];\n        hamming_out[1] = data_in[0] ^ data_in[2] ^ data_in[3];\n        hamming_out[3] = data_in[1] ^ data_in[2] ^ data_in[3];\n        // Data bits\n        hamming_out[2] = data_in[0];\n        hamming_out[4] = data_in[1];\n        hamming_out[5] = data_in[2];\n        hamming_out[6] = data_in[3];\n    end\nendmodule\n```\n\nB.\n```verilog\nmodule hamming_encoder(\n    input [3:0] data_in,\n    output reg [6:0] hamming_out\n);\n    always @(data_in[1], data_in[2]) begin\n        hamming_out[0] = data_in[0] ^ data_in[1] ^ data_in[3];\n        hamming_out[1] = data_in[0] ^ data_in[2] ^ data_in[3];\n        hamming_out[3] = data_in[1] ^ data_in[2] ^ data_in[3];\n        hamming_out[2] = data_in[0];\n        hamming_out[4] = data_in[1];\n        hamming_out[5] = data_in[2];\n        hamming_out[6] = data_in[3];\n    end\nendmodule\n```\n\nC.\n```verilog\nmodule hamming_encoder(\n    input [3:0] data_in,\n    output reg [6:0] hamming_out\n);\n    always @* begin\n        hamming_out[0] = data_in[0] ^ data_in[1] ^ data_in[3];\n        hamming_out[1] = data_in[0] ^ data_in[2] ^ data_in[3];\n        hamming_out[3] = data_in[1]  data_in[2]  data_in[3];\n        hamming_out[2] = data_in[0];\n        hamming_out[4] = data_in[1];\n        hamming_out[5] = data_in[2];\n        hamming_out[6] = data_in[3];\n    end\nendmodule\n```\n\nD.\n```verilog\nmodule hamming_encoder(\n    input [3:0] data_in,\n    output [6:0] hamming_out\n);\n    always @* begin\n        hamming_out[0] = data_in[0] ^ data_in[1] ^ data_in[3];\n        hamming_out[1] = data_in[0] ^ data_in[2] ^ data_in[3];\n        hamming_out[3] = data_in[1] ^ data_in[2] ^ data_in[3];\n        hamming_out[2] = data_in[0];\n        hamming_out[4] = data_in[1];\n        hamming_out[5] = data_in[2];\n        hamming_out[6] = data_in[3];\n    end\nendmodule\n```\n\nE.\n```verilog\nmodule hamming_encoder(\n    input [3:0] data_in,\n    output reg [6:0] hamming_out\n);\n    always @* begin\n        // Incorrect mapping of data bits to output\n        hamming_out[0] = data_in[0] ^ data_in[1] ^ data_in[3];\n        hamming_out[1] = data_in[0] ^ data_in[2] ^ data_in[3];\n        hamming_out[3] = data_in[1] ^ data_in[2] ^ data_in[3];\n        hamming_out[2] = data_in[0];\n        hamming_out[4] = data_in[2]; // Wrong\n        hamming_out[5] = data_in[1]; // Wrong\n        hamming_out[6] = data_in[3];\n    end\nendmodule\n```", "solution": "给定数据到符号的映射关系 $d_{4}=\\text{data\\_in}[3]$、$d_{3}=\\text{data\\_in}[2]$、$d_{2}=\\text{data\\_in}[1]$、$d_{1}=\\text{data\\_in}[0]$ 以及偶校验方程\n$$\np_{1}=d_{1}\\oplus d_{2}\\oplus d_{4},\\quad\np_{2}=d_{1}\\oplus d_{3}\\oplus d_{4},\\quad\np_{4}=d_{2}\\oplus d_{3}\\oplus d_{4}.\n$$\n根据 `data_in` 的索引，这些方程变为\n$$\np_{1}=\\text{data\\_in}[0]\\oplus \\text{data\\_in}[1]\\oplus \\text{data\\_in}[3],\n$$\n$$\np_{2}=\\text{data\\_in}[0]\\oplus \\text{data\\_in}[2]\\oplus \\text{data\\_in}[3],\n$$\n$$\np_{4}=\\text{data\\_in}[1]\\oplus \\text{data\\_in}[2]\\oplus \\text{data\\_in}[3].\n$$\n要求的输出映射关系是\n$$\n\\text{hamming\\_out}[6]=d_{4}=\\text{data\\_in}[3],\\;\n\\text{hamming\\_out}[5]=d_{3}=\\text{data\\_in}[2],\\;\n\\text{hamming\\_out}[4]=d_{2}=\\text{data\\_in}[1],\\;\n\\text{hamming\\_out}[3]=p_{4},\\;\n\\text{hamming\\_out}[2]=d_{1}=\\text{data\\_in}[0],\\;\n\\text{hamming\\_out}[1]=p_{2},\\;\n\\text{hamming\\_out}[0]=p_{1}.\n$$\n现在逐一检查每个选项：\n\n- 选项 A 使用 `always @*`（组合逻辑），使用 XOR 运算符完全按照上述方式计算 $p_{1}$、$p_{2}$、$p_{4}$，并将数据位精确地分配到索引 $[2],[4],[5],[6]$。这同时满足了校验方程和比特位的排列要求，并且是纯组合逻辑。因此 A 是正确的。\n\n- 选项 B 使用了不完整的敏感列表 `always @(data_in[1], data_in[2])`。这忽略了 $\\text{data\\_in}[0]$ 和 $\\text{data\\_in}[3]$，因此即使赋值语句本身与方程匹配，它在仿真中也无法正确地模拟纯组合逻辑行为。因此 B 作为行为模型是不正确的。\n\n- 选项 C 错误地使用按位与（AND）运算符而不是异或（XOR）运算符来计算 $p_{4}$。因此 C 是不正确的。\n\n- 选项 D 将输出声明为线网类型（wire，隐式），但在 `always` 块内对其进行赋值，这在 Verilog 中要求 `reg` 类型。这不是一个正确的 Verilog 行为描述。因此 D 是不正确的。\n\n- 选项 E 交换了数据位的 $\\text{hamming\\_out}[4]$ 和 $\\text{hamming\\_out}[5]$，这与要求的映射关系相矛盾。因此 E 是不正确的。\n\n因此，唯一正确的模块是 A。", "answer": "$$\\boxed{A}$$", "id": "1912766"}, {"introduction": "最后，我们将重心从组合逻辑转向时序逻辑，以解决一个实际工程问题：对来自机械按钮的噪声信号进行“去抖”处理。这项练习要求你实现一个带有计数器的有限状态机（FSM），展示了如何使用行为级 Verilog 为具有记忆功能、并随时间响应时钟事件的系统建模。掌握 FSM 的设计是构建任何复杂数字系统的基石。[@problem_id:1912819]", "problem": "在数字系统中，机械式按钮和开关是常见的用户输入。然而，它们会受到一种称为“触点抖动”或“颤动”的物理现象的影响，即单次按下或释放动作会在稳定到最终状态之前，在逻辑高电平和低电平之间产生一系列快速的、带有噪声的无效转换。为了将这种按钮用作可靠的数字输入，需要一个“去抖动”电路。\n\n你的任务是分析一个按钮去抖动器的 Verilog 实现。该去抖动器应基于一个有限状态机（FSM）和一个计数器来工作。去抖动模块的规格如下：\n\n**模块接口：**\n-   `clk`：系统时钟输入。\n-   `reset_n`：低电平有效异步复位输入。\n-   `button_in`：来自按钮的带噪声输入。它通常为高电平（逻辑1），按下时变为低电平（逻辑0）。\n-   `pulse_out`：干净的、经过去抖动的输出。\n\n**功能行为：**\n1.  电路应检测到 `button_in` 信号被按下（变为0）。\n2.  检测到按下后，它必须等待并确认 `button_in` 信号在逻辑0状态下稳定保持整好16个连续的时钟周期。\n3.  如果信号在所需持续时间内保持稳定，模块必须在 `pulse_out` 上产生一个干净的、单周期的高电平脉冲。\n4.  脉冲产生后，电路必须等待 `button_in` 被释放（返回到1），然后才能准备好检测下一次按下。这可以防止在按钮被长时间按住时产生多个脉冲。\n5.  如果在16个周期的稳定性检查过程中的任何时刻，`button_in` 信号抖动回1，则检查失败，计时器必须被重置，并且电路应返回其初始状态。\n6.  异步 `reset_n` 信号在被断言（置为低电平）时，必须立即将FSM返回到其初始状态，重置所有计数器，并确保 `pulse_out` 为低电平。\n\n**FSM和实现细节：**\nFSM使用由参数定义的四个状态：\n`parameter IDLE = 2'b00, WAIT_STABLE = 2'b01, PULSE = 2'b10, WAIT_RELEASE = 2'b11;`\n它还使用一个参数来定义稳定持续时间，并使用一个计数器寄存器：\n`parameter STABLE_CYCLES = 16;`\n`reg [3:0] counter;`\n\n现给出四个不同的 Verilog 代码片段，每个都声称实现了该去抖动器 `always @(posedge clk or negedge reset_n)` 块内的逻辑。其中只有一个正确实现了所有指定的行为。请找出正确的实现。\n\nA.\n```verilog\nalways @(posedge clk or negedge reset_n) begin\n    if (!reset_n) begin\n        state = IDLE;\n        counter = 4'd0;\n        pulse_out = 1'b0;\n    end else begin\n        case (state)\n            IDLE: begin\n                pulse_out = 1'b0;\n                if (!button_in) begin\n                    state = WAIT_STABLE;\n                    counter = 4'd0;\n                end\n            end\n            WAIT_STABLE: begin\n                pulse_out = 1'b0;\n                if (!button_in) begin\n                    if (counter == STABLE_CYCLES - 1) begin\n                        state = PULSE;\n                    end else begin\n                        counter = counter + 1;\n                    end\n                end else begin\n                    state = IDLE;\n                end\n            end\n            PULSE: begin\n                pulse_out = 1'b1;\n                state = WAIT_RELEASE;\n                counter = 4'd0;\n            end\n            WAIT_RELEASE: begin\n                pulse_out = 1'b0;\n                if (button_in) begin\n                    state = IDLE;\n                end\n            end\n        endcase\n    end\nend\n```\n\nB.\n```verilog\nalways @(posedge clk or negedge reset_n) begin\n    if (!reset_n) begin\n        state = IDLE;\n        counter = 4'd0;\n        pulse_out = 1'b0;\n    end else begin\n        case (state)\n            IDLE: begin\n                pulse_out = 1'b0;\n                if (!button_in) begin\n                    state = WAIT_STABLE;\n                    counter = 4'd0;\n                end\n            end\n            WAIT_STABLE: begin\n                pulse_out = 1'b0;\n                if (!button_in) begin\n                    if (counter == STABLE_CYCLES - 1) begin\n                        state = PULSE;\n                    end else begin\n                        counter = counter + 1;\n                    end\n                end else begin\n                    state = IDLE;\n                end\n            end\n            PULSE: begin\n                pulse_out = 1'b1;\n                state = IDLE; // Transition to IDLE\n                counter = 4'd0;\n            end\n            WAIT_RELEASE: begin // Unused state\n                pulse_out = 1'b0;\n                state = IDLE;\n            end\n        endcase\n    end\nend\n```\n\nC.\n```verilog\nalways @(posedge clk or negedge reset_n) begin\n    if (!reset_n) begin\n        state = IDLE;\n        counter = 4'd0;\n        pulse_out = 1'b0;\n    end else begin\n        case (state)\n            IDLE: begin\n                pulse_out = 1'b0;\n                if (!button_in) begin\n                    state = WAIT_STABLE;\n                    counter = 4'd0;\n                end\n            end\n            WAIT_STABLE: begin\n                pulse_out = 1'b0;\n                if (!button_in) begin\n                    if (counter == STABLE_CYCLES - 1) begin\n                        state = PULSE;\n                    end else begin\n                        counter = counter + 1;\n                    end\n                end else begin\n                    state = IDLE;\n                end\n            end\n            PULSE: begin\n                pulse_out = 1'b1;\n                state = WAIT_RELEASE;\n                counter = 4'd0;\n            end\n            WAIT_RELEASE: begin\n                // pulse_out is not assigned here\n                if (button_in) begin\n                    state = IDLE;\n                    pulse_out = 1'b0;\n                end\n            end\n        endcase\n    end\nend\n```\n\nD.\n```verilog\nalways @(posedge clk or negedge reset_n) begin\n    if (!reset_n) begin\n        state = IDLE;\n        counter = 4'd0;\n        pulse_out = 1'b0;\n    end else begin\n        case (state)\n            IDLE: begin\n                pulse_out = 1'b0;\n                if (!button_in) begin\n                    state = WAIT_STABLE;\n                    // Counter not reset here\n                end\n            end\n            WAIT_STABLE: begin\n                pulse_out = 1'b0;\n                if (!button_in) begin\n                    if (counter == STABLE_CYCLES - 1) begin\n                        state = PULSE;\n                    end else begin\n                        counter = counter + 1;\n                    end\n                end else begin\n                    state = IDLE;\n                end\n            end\n            PULSE: begin\n                pulse_out = 1'b1;\n                state = WAIT_RELEASE;\n                counter = 4'd0; // Counter is reset here\n            end\n            WAIT_RELEASE: begin\n                pulse_out = 1'b0;\n                if (button_in) begin\n                    state = IDLE;\n                end\n            end\n        endcase\n    end\nend\n```", "solution": "我们将所需的FSM行为重述为约束条件，用以验证每个实现：\n- 在异步复位断言时，FSM必须立即进入IDLE状态，计数器置为$0$，且$pulse\\_out=0$。\n- 在IDLE状态，一旦检测到按键按下（$button\\_in=0$），FSM必须进入WAIT\\_STABLE状态，并将计数器重置为$0$。\n- 在WAIT\\_STABLE状态，当$button\\_in=0$时，它必须对连续的稳定低电平周期进行计数，并在恰好$STABLE\\_CYCLES=16$个这样的周期后，转换到PULSE状态。如果在达到16个周期之前的任何时候$button\\_in$返回到$1$，则检查失败，FSM必须返回到IDLE状态。\n- 在PULSE状态，它必须将$pulse\\_out$置为1，并持续恰好一个时钟周期，然后转换到WAIT\\_RELEASE状态，并确保计数器被重置。\n- 在WAIT\\_RELEASE状态，它必须将$pulse\\_out$取消断言，并等待直到按键释放（$button\\_in=1$）才返回IDLE状态，从而防止在按键保持按下时产生多个脉冲。\n\n我们现在来分析所使用的周期计数机制的正确性：以$counter=0$进入WAIT\\_STABLE状态，逻辑检查$counter==STABLE\\_CYCLES-1=15$。由于使用了非阻塞赋值，在WAIT\\_STABLE状态下且$button\\_in=0$时，在每个时钟上升沿会发生：\n- 进入后的第一个稳定周期，旧的$counter=0\\neq 15$，所以它递增到$1$。\n- 经过$k$个稳定周期后，旧的$counter=k-1$；如果$k-1\\neq 15$，它会递增到$k$。\n- 在第$16$个稳定周期，旧的$counter=15$，这满足了$counter==15$的条件，因此FSM在该时钟周期转换到PULSE状态。因此，PULSE状态恰好在观察到$16$个连续的稳定低电平周期后到达，这满足了规格要求。\n\n检查选项A：\n- IDLE：按下时，转换到WAIT\\_STABLE状态并将$counter$重置为$0$；$pulse\\_out=0$。\n- WAIT\\_STABLE：当$button\\_in=0$时，它递增$counter$，并在$counter==15$时转换到PULSE状态，如上所示，这恰好是$16$个周期。如果$button\\_in$返回到$1$，它会转换到IDLE状态。当FSM从IDLE再次进入WAIT\\_STABLE时，$counter$会被重置，因此在任何新的稳定性检查开始之前，计时器实际上都被重置了，这满足了功能要求。\n- PULSE：将$pulse\\_out$置为1，并在下一个时钟周期转换到WAIT\\_RELEASE状态；$counter$被重置，保证了单周期脉冲。\n- WAIT\\_RELEASE：强制$pulse\\_out=0$，并等待按键释放（$button\\_in=1$）后才返回IDLE，从而防止在按键保持按下时产生多个脉冲。\n- 复位行为是正确的。此外，该代码遵循了时序逻辑的最佳实践，对所有`reg`类型变量使用了非阻塞赋值（`=`）。因此，A满足所有要求。\n\n检查选项B：\n- PULSE直接转换到IDLE，绕过了WAIT\\_RELEASE状态。如果按钮保持按下，IDLE将立即检测到$button\\_in=0$并开始一个新的WAIT\\_STABLE周期，从而允许在按钮被按住期间每$16$个周期产生一次重复的脉冲。这违反了在脉冲后等待释放的要求。因此B是错误的。\n\n检查选项C：\n- 在WAIT\\_RELEASE状态，除非$button\\_in$为$1$，否则$pulse\\_out$不会被驱动为低电平。从$pulse\\_out=1$的PULSE状态转换而来，如果按钮保持按下（$button\\_in=0$），$pulse\\_out$将保持其之前的值$1$，从而产生一个多周期脉冲。这违反了单周期脉冲的要求。因此C是错误的。\n\n检查选项D：\n- 在IDLE状态，检测到按键按下时，它在进入WAIT\\_STABLE之前没有重置计数器。因此，等待长度取决于先前尝试中可能存在的陈旧计数值，这会缩短所需的16周期确认时间，并违反了在开始新检测时必须重置计时器的要求。因此D是错误的。\n\n因此，只有选项A正确地实现了所有指定的行为。", "answer": "$$\\boxed{A}$$", "id": "1912819"}]}