{"hands_on_practices": [{"introduction": "让我们从一个基础任务开始：反转一个向量的所有位。这个练习是学习 `generate for` 循环的绝佳入门，它演示了如何创建简单的、并行的、能适应不同数据宽度的硬件结构。掌握这种模式是构建可伸缩和可重用数字组件的第一步 [@problem_id:1950959]。", "problem": "在现代数字逻辑设计中，创建灵活且可复用的硬件模块是一项关键原则。Verilog 为此提供了 `parameter` 和 `generate` 结构。`parameter` 允许模块的特性（例如数据总线的宽度）在实例化时定义，而不是硬编码。`generate` 块允许基于这些参数创建重复的逻辑结构，该结构在仿真或综合之前的阐述阶段进行评估。\n\n考虑一个参数化的 `BitReverser` 模块的设计。该模块接收一个 N 位输入向量 `data_in`，并产生一个 N 位输出向量 `data_out`，其中 `data_out` 的比特位是 `data_in` 的比特位逆序排列。例如，如果 `N=8` 且 `data_in` 是 `8'b11001010`，那么 `data_out` 应该是 `8'b01010011`。\n\n该模块声明如下：\n```verilog\nmodule BitReverser #(parameter N = 8) (\n    input  wire [N-1:0] data_in,\n    output wire [N-1:0] data_out\n);\n\n    // Implementation to be inserted here\n\nendmodule\n```\n\n以下哪个 Verilog 代码片段在插入模块后，能为参数 `N` 的任何正整数值正确实现比特逆序逻辑？\n\nA.\n```verilog\ngenvar i;\ngenerate\n    for (i = 0; i  N; i = i + 1) begin : reverse_loop\n        assign data_out[i] = data_in[N-1-i];\n    end\nendgenerate\n```\n\nB.\n```verilog\ngenerate\n    for (integer i = 0; i  N; i = i + 1) begin : reverse_loop\n        assign data_out[i] = data_in[N-1-i];\n    end\nendgenerate\n```\n\nC.\n```verilog\ngenvar i;\ngenerate\n    for (i = 0; i  N; i = i + 1) begin\n        assign data_out[i] = data_in[N-1-i];\n    end\nendgenerate\n```\n\nD.\n```verilog\ngenvar i;\ngenerate\n    for (i = 0; i  N; i = i + 1) begin : reverse_loop\n        assign data_out[i] = data_in[N-i];\n    end\nendgenerate\n```\n\nE.\n```verilog\nalways @(*) begin\n    for (integer i = 0; i  N; i = i + 1) begin\n        data_out[i] = data_in[N-1-i];\n    end\nend\n```", "solution": "我们需要将每个输出比特连接到对应的镜像输入比特：对于每个索引 $i$（其中 $0 \\leq i \\leq N-1$），正确的映射是 $data\\_out[i] = data\\_in[N-1-i]$。这是一种纯粹的组合布线模式，完全在阐述时确定，应使用带有 genvar 索引的 generate-for 循环来实现，以产生连续赋值。\n\n根据 Verilog-2001 规则和所需的映射评估每个选项：\n\n- 选项 A：\n  - 使用带有 genvar 索引 $i$ 的 generate-for 循环，这是用于阐述时复制的正确结构。\n  - 使用名为 `reverse_loop` 的 generate 块（`begin : reverse_loop`），这是推荐的且符合标准的风格。\n  - 实现了正确的索引表达式 $N-1-i$。\n  - 这是正确的。\n\n- 选项 B：\n  - 在 generate-for 循环内部使用了 integer 类型的循环变量。在 Verilog-2001 的 generate-for 循环中，循环变量必须声明为 genvar，而不是 integer。因此，这不符合标准，是错误的。\n\n- 选项 C：\n  - 正确地使用了 genvar 并实现了正确的映射 $N-1-i$，但省略了 generate 块的标签。在标准的 Verilog-2001 中，for-generate 的主体应该是一个命名的 generate 块，以符合规范并避免工具问题。这种省略使其在严格的 Verilog-2001 用法中不合规。因此，它不是最佳的正确答案。\n\n- 选项 D：\n  - 使用了 $N-i$ 而不是 $N-1-i$，这在 $i=0$ 时会导致索引越界（访问 $data\\_in[N]$），并且整体映射会差一位。这是错误的。\n\n- 选项 E：\n  - 使用一个过程性的 `always @(*)` 块对 `data_out` 进行赋值，但 `data_out` 被声明为 `wire` 类型；过程赋值需要 `reg` 类型。因此，给定的代码无法编译。此外，这没有按照预期使用 `generate` 结构来创建阐述时结构。按其写法是错误的。\n\n因此，在所有选项中，唯一完全正确且符合标准的实现是 A。", "answer": "$$\\boxed{A}$$", "id": "1950959"}, {"introduction": "接下来，我们将构建一个灵活的奇偶校验生成器，这是数据通信系统中用于错误检测的常见组件。这个问题让我们更进一步，展示了如何使用 `generate` 循环来创建一串相互依赖的逻辑，类似于行波进位加法器。你还将学习如何不仅使用参数来定义大小，还能用它来条件性地改变模块的功能，例如在偶校验和奇校验之间切换 [@problem_id:1950971]。", "problem": "你的任务是设计一个灵活的 Verilog 奇偶校验生成器电路。该模块名为 `ParityGenerator`，应被参数化以处理可变宽度的输入数据向量，并产生偶校验或奇校验。\n\n该模块必须具有以下规范：\n-   一个参数 `WIDTH`，用于定义输入数据向量的位宽。\n-   一个参数 `PARITY_TYPE`，其中值 `0` 指定**偶校验**，值 `1` 指定**奇校验**。\n-   一个 `WIDTH` 位的输入端口 `data_in`。\n-   一个单比特输出端口 `parity_out`。\n\n功能定义如下：\n-   对于**偶校验**（`PARITY_TYPE = 0`），应设置 `parity_out` 位，使得 `data_in` 和 `parity_out` 的组合中 '1' 的总数为偶数。这等效于 `parity_out` 是 `data_in` 中所有位的异或（XOR）和。\n-   对于**奇校验**（`PARITY_TYPE = 1`），应设置 `parity_out` 位，使得 `data_in` 和 `parity_out` 的组合中 '1' 的总数为奇数。这等效于 `parity_out` 是 `data_in` 中所有位的异或非（XNOR）和。\n\n你的实现必须使用 `generate` `for` 循环来创建必要的组合逻辑结构。以下哪个 Verilog 代码片段正确实现了指定的 `ParityGenerator` 模块？\n\nA.\n```verilog\nmodule ParityGenerator #(\n    parameter WIDTH = 8,\n    parameter PARITY_TYPE = 0\n) (\n    input [WIDTH-1:0] data_in,\n    output parity_out\n);\n    wire [WIDTH:0] p_chain;\n    assign p_chain[0] = 0;\n\n    genvar i;\n    generate\n        for (i = 0; i  WIDTH; i = i + 1) begin : xor_chain\n            assign p_chain[i+1] = p_chain[i] ^ data_in[i];\n        end\n    endgenerate\n\n    assign parity_out = p_chain[WIDTH] | PARITY_TYPE;\nendmodule\n```\n\nB.\n```verilog\nmodule ParityGenerator #(\n    parameter WIDTH = 8,\n    parameter PARITY_TYPE = 0\n) (\n    input [WIDTH-1:0] data_in,\n    output parity_out\n);\n    wire [WIDTH:0] p_chain;\n    assign p_chain[0] = PARITY_TYPE;\n\n    integer i;\n    generate\n        for (i = 0; i  WIDTH; i = i + 1) begin : xor_chain\n            assign p_chain[i+1] = p_chain[i] ^ data_in[i];\n        end\n    endgenerate\n\n    assign parity_out = p_chain[WIDTH];\nendmodule\n```\n\nC.\n```verilog\nmodule ParityGenerator #(\n    parameter WIDTH = 8,\n    parameter PARITY_TYPE = 0\n) (\n    input [WIDTH-1:0] data_in,\n    output parity_out\n);\n    wire [WIDTH:0] p_chain;\n    assign p_chain[0] = PARITY_TYPE;\n\n    genvar i;\n    generate\n        for (i = 0; i  WIDTH; i = i + 1) begin : xor_chain\n            assign p_chain[i+1] = p_chain[i] ^ data_in[i];\n        end\n    endgenerate\n\n    assign parity_out = p_chain[WIDTH];\nendmodule\n```\n\nD.\n```verilog\nmodule ParityGenerator #(\n    parameter WIDTH = 8,\n    parameter PARITY_TYPE = 0\n) (\n    input [WIDTH-1:0] data_in,\n    output parity_out\n);\n    wire [WIDTH:0] p_chain;\n    assign p_chain[0] = PARITY_TYPE;\n\n    genvar i;\n    generate\n        for (i = 0; i  WIDTH; i = i + 1) begin : xor_chain\n            assign p_chain[i+1] = p_chain[i] ^ data_in[i+1];\n        end\n    endgenerate\n\n    assign parity_out = p_chain[WIDTH];\nendmodule\n```\n\nE.\n```verilog\nmodule ParityGenerator #(\n    parameter WIDTH = 8,\n    parameter PARITY_TYPE = 0\n) (\n    input [WIDTH-1:0] data_in,\n    output reg parity_out\n);\n    reg [WIDTH-1:0] p_temp;\n\n    genvar i;\n    generate\n        always @(*) begin\n            p_temp[0] = data_in[0];\n            for (i = 1; i  WIDTH; i = i + 1) begin\n                p_temp[i] = p_temp[i-1] ^ data_in[i];\n            end\n            parity_out = p_temp[WIDTH-1] ^ PARITY_TYPE;\n        end\n    endgenerate\nendmodule\n```", "solution": "设输入向量为 $d=\\text{data\\_in}$，其位为 $d_{i}$，其中 $i=0,\\dots,\\text{WIDTH}-1$。将数据的按位异或归约定义为\n$$\ns=\\bigoplus_{i=0}^{\\text{WIDTH}-1} d_{i}.\n$$\n校验位 $p=\\text{parity\\_out}$ 必须满足以下规范：\n- 对于偶校验 $\\text{PARITY\\_TYPE}=0$，$(d,p)$ 中 1 的总数是偶数，这要求 $s \\oplus p=0$。因此，\n$$\np=s.\n$$\n- 对于奇校验 $\\text{PARITY\\_TYPE}=1$，$(d,p)$ 中 1 的总数是奇数，这要求 $s \\oplus p=1$。因此，\n$$\np=\\overline{s}=s \\oplus 1.\n$$\n\n使用 $\\text{PARITY\\_TYPE}\\in\\{0,1\\}$ 将两种情况合并为一个表达式，得到\n$$\np = s \\oplus \\text{PARITY\\_TYPE}.\n$$\n使用 generate for 循环的结构化实现可以通过形成一个用 $\\text{PARITY\\_TYPE}$ 初始化的异或链来实现这一点：\n- 初始化 $p\\_{\\text{chain}}[0]=\\text{PARITY\\_TYPE}$。\n- 对于从 $0$ 到 $\\text{WIDTH}-1$ 的每个 $i$，计算 $p\\_{\\text{chain}}[i+1]=p\\_{\\text{chain}}[i]\\oplus d_{i}$。\n- 输出 $p=p\\_{\\text{chain}}[\\text{WIDTH}]$。\n\n这将得到 $p\\_{\\text{chain}}[\\text{WIDTH}]=\\left(\\bigoplus_{i=0}^{\\text{WIDTH}-1} d_{i}\\right)\\oplus \\text{PARITY\\_TYPE}=s\\oplus \\text{PARITY\\_TYPE}$，这与偶校验和奇校验所需的行为相匹配。\n\n现在评估这些选项：\n- A 通过链计算出 $p=s$，然后设置 $\\text{parity\\_out}=s \\lor \\text{PARITY\\_TYPE}$，对于 $\\text{PARITY\\_TYPE}=1$ 的情况，这将得到 $1$ 而不是 $\\overline{s}$，所以它是错误的。\n- B 使用 $p\\_{\\text{chain}}[0]=\\text{PARITY\\_TYPE}$ 并且逻辑上正确地计算了 $p=s\\oplus \\text{PARITY\\_TYPE}$，但是在 generate for 循环内部将循环变量声明为 integer 类型；generate 循环需要一个编译时 genvar，所以这不满足要求。\n- C 使用 $p\\_{\\text{chain}}[0]=\\text{PARITY\\_TYPE}$ 和一个基于 genvar 的 generate for 循环来计算 $p\\_{\\text{chain}}[\\text{WIDTH}]=s\\oplus \\text{PARITY\\_TYPE}$ 并将 $\\text{parity\\_out}$ 设置为该值；这同时满足了功能性和 generate 循环的要求。\n- D 使用了 $d_{i+1}$，这既跳过了 $d_{0}$ 又在 $i=\\text{WIDTH}-1$ 时导致越界访问，所以它是错误的。\n- E 在一个过程 for 循环中将一个 always 块与一个 genvar 混合使用，这是非法的；此外，它没有按要求正确使用 generate for 循环来创建结构化逻辑。\n\n因此，选项中唯一正确的实现是 C。", "answer": "$$\\boxed{C}$$", "id": "1950971"}, {"introduction": "最后，我们将挑战设计一个优先级编码器，它是仲裁器和中断控制器中的关键构建模块。这个练习展示了 `generate` 结构的一种更高级的用法，即实现一个优先级链，其输出取决于满足特定条件的第一个信号的位置。这项强大的技术对于在复杂数字系统中管理资源访问和处理有优先级的事件至关重要 [@problem_id:1950986]。", "problem": "您的任务是设计一个参数化的 Verilog 模块 `find_first_zero`，该模块是处理状态标志或掩码的系统中常用的组件。该模块必须在从输入向量的最低有效位 (LSB) 开始搜索时，识别出找到的第一个 '0' 位的索引。\n\n**模块规格：**\n*   **模块名称**：`find_first_zero`\n*   **参数**：一个整数 `WIDTH`，定义输入向量的位宽。\n*   **输入**：`data_in`，一个大小为 `[WIDTH-1:0]` 的逻辑向量。\n*   **输出**：`index`，一个大小为 `[$clog2(WIDTH+1)-1:0]` 的逻辑向量。\n*   **功能**：\n    *   `index` 输出必须保持从索引 0 (LSB) 向索引 `WIDTH-1`（最高有效位，MSB）扫描 `data_in` 时遇到的第一个 '0' 的位位置。\n    *   在 `data_in` 不包含 '0' 位（即所有位都为 '1'）的特殊情况下，`index` 输出必须设置为值 `WIDTH`。\n\n下面是为该模块主体提出的四种不同的 Verilog 代码片段。哪一个正确地实现了指定的功能？\n\nA.\n```verilog\ngenerate\n    genvar i;\n    wire [$clog2(WIDTH+1)-1:0] index_stage [WIDTH:0];\n    assign index_stage[WIDTH] = WIDTH;\n    for (i = WIDTH-1; i >= 0; i=i-1) begin: priority_chain\n        assign index_stage[i] = (~data_in[i]) ? i : index_stage[i+1];\n    end\n    assign index = index_stage[0];\nendgenerate\n```\n\nB.\n```verilog\ngenerate\n    genvar i;\n    wire [$clog2(WIDTH+1)-1:0] index_stage [WIDTH:0];\n    assign index_stage[0] = WIDTH;\n    for (i = 0; i  WIDTH; i=i+1) begin: priority_chain\n        assign index_stage[i+1] = (~data_in[i]) ? i : index_stage[i];\n    end\n    assign index = index_stage[WIDTH];\nendgenerate\n```\n\nC.\n```verilog\ngenerate\n    genvar i;\n    for (i = 0; i  WIDTH; i=i+1) begin: priority_chain\n        always @(*) begin\n            if (~data_in[i])\n                index = i;\n        end\n    end\nendgenerate\n```\n\nD.\n```verilog\ngenerate\n    genvar i;\n    wire [$clog2(WIDTH+1)-1:0] index_stage [WIDTH:0];\n    assign index_stage[WIDTH] = WIDTH;\n    for (i = WIDTH-1; i >= 0; i=i-1) begin: priority_chain\n        assign index_stage[i] = (~data_in[i]) ? index_stage[i+1] : i;\n    end\n    assign index = index_stage[0];\nendgenerate\n```", "solution": "我们需要一个组合逻辑模块，对于一个输入向量 $data\\_in[WIDTH-1:0]$，当从最低有效位扫描到最高有效位时，它返回满足 $data\\_in[j]=0$ 的最小索引 $j \\in \\{0,\\dots,WIDTH-1\\}$。如果不存在这样的 $j$，则输出必须是 $WIDTH$。定义目标函数\n$$\nf(i)=\\begin{cases}\n\\min\\{j \\mid j\\in [i, WIDTH-1],\\ data\\_in[j]=0\\},  \\text{如果存在这样的 } j,\\\\\nWIDTH,  \\text{否则}。\n\\end{cases}\n$$\n所期望的输出是 $f(0)$。\n\n分析每个选项：\n\n选项 A：\n它定义了一个链式结构 $index\\_stage[i]$，边界条件为 $index\\_stage[WIDTH]=WIDTH$，并且对于 $i$ 从 $WIDTH-1$ 递减到 $0$：\n$$\nindex\\_stage[i] = \\begin{cases}\ni,  \\text{如果 } \\lnot data\\_in[i],\\\\\nindex\\_stage[i+1],  \\text{否则}。\n\\end{cases}\n$$\n这个递推关系与 $f(i)$ 的定义相符：显然 $index\\_stage[WIDTH]=f(WIDTH)=WIDTH$。对于递减的 $i$，如果 $data\\_in[i]=0$，那么在 $i$ 或 $i$ 以上位置的第一个零就是 $i$，所以 $f(i)=i$。否则，在 $i$ 或 $i$ 以上位置的第一个零与在 $i+1$ 或 $i+1$ 以上位置的第一个零相同，所以 $f(i)=f(i+1)$。因此，通过归纳法，$index\\_stage[i]=f(i)$ 对所有 $i$ 成立，并且最终的赋值 $index=index\\_stage[0]=f(0)$ 精确地实现了所要求的行为，包括全为 '1' 的情况得出 $WIDTH$。\n\n选项 B：\n它设置 $index\\_stage[0]=WIDTH$，并且对于 $i$ 从 $0$ 递增到 $WIDTH-1$：\n$$\nindex\\_stage[i+1] = \\begin{cases}\ni,  \\text{如果 } \\lnot data\\_in[i],\\\\\nindex\\_stage[i],  \\text{否则}。\n\\end{cases}\n$$\n这个逻辑在每次遇到新的零时都会覆盖存储的索引，因此 $index\\_stage[WIDTH]$ 变为具有 $data\\_in[i]=0$ 的最大索引 $i$，即从 LSB 到 MSB 扫描时的最后一个零。例如，当 $data\\_in$ 在位置 $2:0$ 为 $\\dots 1 0 0$ 时，结果是 $1$ 而不是正确的 $0$。因此它是错误的。\n\n选项 C：\n它创建了多个 always 块，每个块都可能在没有默认赋值的情况下为同一个信号 $index$ 赋值。这会导致 $index$ 上有多个过程驱动，并且没有定义选择第一个零的优先级。它也无法处理全为 '1' 的情况，因为 $index$ 将保持未赋值状态。它没有实现指定的功能。\n\n选项 D：\n它使用 $index\\_stage[WIDTH]=WIDTH$ 并且对于递减的 $i$：\n$$\nindex\\_stage[i] = \\begin{cases}\nindex\\_stage[i+1],  \\text{如果 } \\lnot data\\_in[i],\\\\\ni,  \\text{否则}。\n\\end{cases}\n$$\n这与所需的递推关系相反。例如，对于全为 '1' 的情况，会得到 $index\\_stage[0]=0$ 而不是 $WIDTH$，这违反了规范。因此它是错误的。\n\n因此，只有选项 A 正确地实现了所需的功能，包括找不到零的边界情况。", "answer": "$$\\boxed{A}$$", "id": "1950986"}]}