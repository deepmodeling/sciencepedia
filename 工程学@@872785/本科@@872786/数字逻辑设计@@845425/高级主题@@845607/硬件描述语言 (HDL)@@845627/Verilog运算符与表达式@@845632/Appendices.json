{"hands_on_practices": [{"introduction": "求一个数的补码是数字系统中一项基本而重要的运算，通常用于表示负数和执行减法。虽然大多数人学习的公式是“取反加一”（`~x + 1`），但本次练习将挑战你从一个更基本的算术角度来思考。通过仅使用减法，你可以更深刻地理解二进制负数在硬件中是如何通过算术运算自然产生的，从而巩固数学定义与 Verilog 实现之间的联系。[@problem_id:1975734]", "problem": "在数字逻辑设计中，计算一个二进制数的补码是一项基本操作，常用于表示负数或执行减法运算。给定一个声明为 `reg [3:0] x;` 的4位Verilog变量，你的任务是找出一个表达式来计算其补码。\n\n你的实现必须遵守一个特定的设计约束：该表达式*只能*使用二进制减法运算符（`-`）和一个Verilog整数字面量。严禁使用其他算术或按位运算符，例如加法（`+`）、按位非（`~`）等。\n\n在给定的约束条件下，以下哪个Verilog表达式正确地实现了这一操作？\n\nA. `4'hF - x`\nB. `1'b1 - x`\nC. `x - 1'b1`\nD. `4'h0 - x`\nE. `~x`", "solution": "目标是仅使用减法运算符和一个常量来求出4位数 `x` 的补码。\n\n首先，我们回顾一下定义一个N位数 `x` 的补码的两种常见方法。\n\n1.  **按位取反再加一：** 通过对 `x` 的所有位进行取反（得到反码），然后再加1，即可求得补码。在Verilog中，这表示为 `~x + 1'b1`。问题的约束禁止使用 `~` 和 `+` 运算符，因此这种方法被明确禁止。\n\n2.  **数学定义：** 对于一个N位数 `x`，其补码定义为 $(2^N) - x$。对于我们的4位变量（`N=4`），该公式变为 $(2^4) - x = 16 - x$。然而，这适用于 `x` 非零的情况。对于 `x=0`，其补码是0。公式 $(2^4)-0 = 16$ 的二进制结果是 `10000`，而在一个4位系统中，最高有效位是一个溢出位，会被舍弃，最终剩下 `0000`。因此，在模$2^N$算术下，该公式也适用于 `x=0` 的情况。\n\n现在，我们需要将这个数学概念转换成一个只使用减法运算符和一个常量的有效Verilog表达式。\n\n在补码算术中，求负操作（即求 `-x`）是通过计算补码来执行的。因此，求 `x` 的补码的表达式等价于表达式 `0 - x`。\n\n让我们用一个例子来分析。设 `x = 4'b0011`（十进制为3）。\n在4位补码算术中，减法 `0 - 3` 的过程如下：\n`0 - 3` 等价于 `0 + (-3)`。\n`0` 的4位表示是 `4'b0000`。\n`-3` 的4位表示是 `3`（`4'b0011`）的补码。\n`4'b0011` 的补码是 `~4'b0011 + 1'b1 = 4'b1100 + 1'b1 = 4'b1101`。\n所以，`0 - 3` 的结果应该是 `4'b1101`。\n\n让我们看看Verilog表达式 `4'h0 - x` 是否能得到这个结果。\n设 `x = 4'b0011`。\n表达式为 `4'h0 - 4'b0011`，即 `4'b0000 - 4'b0011`。\n执行二进制减法：\n```\n  (Borrow)\n  1 0 0 0 0\n-   0 0 1 1\n-----------\n    1 1 0 1\n```\n结果是 `4'b1101`，这正是 `4'b0011` 的正确补码。在定宽无符号算术中，来自最高有效位的借位会被舍弃，Verilog的 `-` 运算符在此上下文中正是如此工作的，实际上执行的是模$2^4$算术。\n\n因此，表达式 `4'h0 - x` 正确地计算了 `x` 的补码，同时满足了问题的约束条件。使用的常量是 `4'h0`（或 `4'd0`，或简称 `0`）。\n\n让我们回顾一下各个选项：\nA. `4'hF - x`：这是 `15 - x`，它计算的是 `x` 的反码。对于 `x=3`，结果是 `15-3=12` (`4'b1100`)，这是按位取反的结果，而不是补码。\nB. `1'b1 - x`：这是 `1 - x`。对于 `x=3`，结果是 `1 - 3 = -2`。`-2` 的4位表示是 `4'b1110`。这不是 `x` 的补码（`4'b1101`）。\nC. `x - 1'b1`：这只是将 `x` 减1。\nD. `4'h0 - x`：正如我们所推导的，它正确地计算了 `x` 的补码。它只使用了减法运算符和一个常量 `4'h0`。\nE. `~x`：这计算的是反码，并且由于使用了 `~` 运算符而被明确禁止。\n\n因此，选项D是正确答案。", "answer": "$$\\boxed{D}$$", "id": "1975734"}, {"introduction": "在掌握了基本的算术运算后，我们来处理一个更复杂的场景，它涉及多个有符号数的操作。这个问题将检验你对 Verilog 中有符号数运算关键规则的理解，包括在有符号数上进行按位操作，以及保留符号位的算术右移（``）。通过逐步计算，你将练习如何精确追踪表达式求值过程中的位宽和符号扩展，这是确保数字逻辑设计正确的核心技能。[@problem_id:1975764]", "problem": "在一个运行于 Verilog 硬件描述语言 (HDL) 平台上的数字逻辑仿真环境中，一个小型计算模块正在接受测试。该模块包含三个有符号寄存器，定义如下：`reg signed [4:0] operand_A;`、`reg signed [4:0] operand_B;` 和 `reg signed [5:0] result_reg;`。\n\n初始时，这些寄存器被设置为特定的十进制值：`operand_A` 被初始化为 `9`，`operand_B` 被初始化为 `-12`。\n\n随后执行一个单独的阻塞赋值操作：\n`result_reg = (operand_A  operand_B) + (operand_B  2);`\n\n假设遵循标准的 Verilog 语义，其中 `` 是按位与运算符，`` 是算术右移运算符，`+` 是加法。中间表达式的位宽由该表达式内最大操作数的位宽决定。右侧计算出的最终值随后被赋给左侧的寄存器，如果目标寄存器更宽，则会进行符号扩展。\n\n你的任务是确定此操作完成后存储在 `result_reg` 中的最终有符号十进制值。", "solution": "我们处理的是有符号二进制补码整数。寄存器 $operand\\_A$ 和 $operand\\_B$ 是 $[4:0]$（5位，范围从 $-16$ 到 $15$），而 $result\\_reg$ 是 $[5:0]$（6位，范围从 $-32$ 到 $31$）。每个子表达式的位宽等于其操作数的最大位宽；此处所有操作数均为5位，因此每个子表达式都是5位有符号数，而最终赋给6位目标寄存器时，会对这个5位结果进行符号扩展。\n\n用5位二进制补码表示这些值：\n$$9 \\to 01001_{2}, \\quad -12:\\ 12=01100_{2},\\ \\text{取反}\\to 10011_{2},\\ \\text{加 }1\\to 10100_{2}.$$\n因此 $operand\\_A=01001_{2}$ 且 $operand\\_B=10100_{2}$。\n\n计算按位与（结果为5位）：\n$$01001_{2}\\ \\text{与}\\ 10100_{2} = 00000_{2}.$$\n\n计算将 $operand\\_B$ 算术右移2位（由于该值为负，复制符号位）：\n$$10100_{2} \\xrightarrow{\\text{算术右移1位}} 11010_{2} \\xrightarrow{\\text{算术右移1位}} 11101_{2}.$$\n\n将两个5位有符号结果相加：\n$$00000_{2} + 11101_{2} = 11101_{2}.$$\n\n赋给 $result\\_reg$ $[5:0]$，并进行符号扩展（扩展到6位）：\n$$11101_{2} \\to 111101_{2}.$$\n\n将 $111101_{2}$ 解释为一个6位有符号数：\n$$111101_{2} = -3.$$\n因此，存储在 $result\\_reg$ 中的最终有符号十进制值为 $-3$。", "answer": "$$\\boxed{-3}$$", "id": "1975764"}]}