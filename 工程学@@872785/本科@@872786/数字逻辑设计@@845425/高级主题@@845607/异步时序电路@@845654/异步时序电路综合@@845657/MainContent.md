## 引言
[异步时序电路](@entry_id:170735)，作为[数字逻辑设计](@entry_id:141122)的一个重要分支，通过摆脱全局时钟的束缚，在速度、功耗和模块化方面展现出独特的潜力。然而，这种无时钟的设计[范式](@entry_id:161181)也引入了传统[同步设计](@entry_id:163344)中不存在的复杂时序问题，如[竞争条件](@entry_id:177665)和逻辑险象，它们是导致电路功能失效的根源。掌握如何系统性地识别并解决这些挑战，是设计可靠异步系统的关键。本文旨在提供一个关于[异步时序电路](@entry_id:170735)综合的全面指南，帮助读者从零开始，构建功能正确且稳健的无时钟电路。

在接下来的内容中，我们将分三步深入探索这一领域。首先，在“原理与机制”章节中，我们将详细剖析异步设计的核心流程，从使用流表精确描述电路行为，到通过状态化简与无[竞争状态](@entry_id:177665)分配来解决竞争问题，再到利用共识项消除组合逻辑中的险象。随后，在“应用与跨学科连接”章节中，我们将展示这些理论如何在实际场景中发挥作用，包括处理物理世界的[抖动信号](@entry_id:177752)、设计资源仲裁器、实现[跨时钟域](@entry_id:173614)通信，甚至在系统生物学中的建模应用。最后，“动手实践”部分将提供一系列精心设计的问题，引导您亲手完成状态合并、[状态分配](@entry_id:172668)和逻辑推导等关键综合步骤，将理论知识转化为实践能力。

## 原理与机制

与[同步时序电路](@entry_id:175242)依赖于全局[时钟信号](@entry_id:174447)来协调状态变化不同，[异步时序电路](@entry_id:170735)没有集中的时钟。状态的变迁由输入信号的变化直接触发。这种设计[范式](@entry_id:161181)带来了对速度和[功耗](@entry_id:264815)的潜在优势，但也引入了独特的、必须被系统性地理解和解决的设计挑战。本章将深入探讨[异步时序电路](@entry_id:170735)合成的核心原理与机制，从抽象的规范描述开始，逐步解决[状态分配](@entry_id:172668)中的竞争问题和组合逻辑中的险象问题，最终构建出可靠的电路。

### 从规范到流表：描述电路行为

[异步电路设计](@entry_id:172174)的起点是将非形式化的行为描述转化为一种精确的数学形式。在[同步设计](@entry_id:163344)中，我们使用[状态图](@entry_id:176069)和[状态表](@entry_id:178995)；在异步设计中，我们使用一个类似的工具，称为**流表 (flow table)**。

流表是一个二维表格，其行代表电路的内部状态，列代表所有可能的输入组合。表中的每个条目指定了在当前[状态和](@entry_id:193625)当前输入下，电路的下一个[状态和](@entry_id:193625)输出。当一个条目指定的下一个状态与当前状态相同时，我们称之为一个**稳定状态 (stable state)**。此时，电路处于平衡，除非输入发生变化，否则它将一直保持在这个状态。相反，如果下一个状态与当前状态不同，我们称之为一个**非稳定状态 (unstable state)**。电路将从这个非稳定状态自动跃迁到指定的下一个稳定状态。

为了系统地捕捉所有可能的行为，我们通常从构建一个**原始流表 (primitive flow table)** 开始。在原始流表中，每一行只包含一个稳定状态。这种方法的优点是它能明确地表示出由不同输入序列导向的、即使输入相同但历史不同的状态。

让我们通过一个安全互锁系统的设计实例来理解这个过程 [@problem_id:1911362]。该系统有两个按钮输入 $x_1$ 和 $x_2$，以及一个输出 $Z$。只有当按钮严格按照先按 $x_1$ 再按 $x_2$ 的顺序操作时，输出 $Z$ 才为 1，从而启动机器。任何其他操作顺序或按钮的释放都会使 $Z$ 保持或回到 0。我们假设电路工作在**基本模式 (fundamental mode)** 下，即一次只有一个输入可以改变。

1.  **识别稳定状态**:
    *   初始状态，两个按钮都未按下 ($x_1x_2=00$)，系统处于复位状态。我们称之为状态 A，输出 $Z=0$。这是一个稳定状态。
    *   从状态 A 按下 $x_1$，输入为 $x_1x_2=10$。系统进入一个新状态 B，记住了 $x_1$ 是第一个被按下的。输出仍为 $Z=0$。这是第二个稳定状态。
    *   从状态 A 按下 $x_2$，输入为 $x_1x_2=01$。系统进入状态 C，记住了这是一个错误的起始顺序。输出为 $Z=0$。这是第三个稳定状态。
    *   从状态 B（已按下 $x_1$）再按下 $x_2$，输入变为 $x_1x_2=11$。这是正确的序列，系统进入状态 D，输出 $Z=1$。这是第四个稳定状态。
    *   从状态 C（已按下 $x_2$）再按下 $x_1$，输入变为 $x_1x_2=11$。这是错误的序列，系统进入状态 E，输出必须为 $Z=0$。这是第五个稳定状态。

2.  **构建原始流表**: 我们将这些稳定状态（用圆圈表示）和它们之间的跃迁填入表格。例如，在状态 A ($x_1x_2=00$) 时，如果 $x_1$ 变为 1，输入变为 10，电路将进入一个非稳定状态，其目标是稳定状态 B。我们在 A 行的 10 列填入 `B, 0`。如果从稳定状态 D ($Z=1$) 释放任何一个按钮，例如 $x_1$，输入变为 01，输出必须立即变为 0，并且电路应跃迁到与当前输入 01 对应的稳定状态，即 C。因此，在 D 行的 01 列，我们填入 `C, 0`。遵循这个逻辑，我们可以构建出完整的原始流表。

通过这种方式，原始流表精确地捕捉了设计的时序要求，为后续的综合步骤奠定了基础。

### 状态化简：合并流表

原始流表虽然详尽，但通常包含冗余的状态。例如，两个不同的状态，如果在所有可能的输入序列下都产生相同的输出并且跃迁到等价的下一状态，那么它们就是**等价的 (equivalent)**。对于不完全指定的流表（即包含“[无关项](@entry_id:165299)”的表），如果两个状态在所有输入下的输出和下一状态都不冲突，则它们是**兼容的 (compatible)**。通过合并这些等价或兼容的状态，我们可以得到一个状态数更少的**合并流表 (merged flow table)**，从而简化最终的电路实现。

状态化简过程通常遵循以下步骤 [@problem_id:1911376]：
1.  **输出划分**: 首先，根据输出将所有状态划分为不同的组。两个状态如果对于某个相同的输入，其指定的输出不同，那么它们绝对不能合并。
2.  **寻找兼容对**: 在每个组内，系统地检查每一对状态 $(S_i, S_j)$。如果对于所有输入，它们的输出兼容（相同或其中一个为[无关项](@entry_id:165299)），并且它们的下一状态也兼容（相同，或其中一个为[无关项](@entry_id:165299)，或形成一个新的需要被满足的兼容对），则这对状态是兼容的。这个过程通常借助一个蕴含图来记录状态对之间的依赖关系。
3.  **确定最大兼容集**: 找到所有相互兼容的状态组成的最大集合，即**最大兼容集 (maximal compatibles)**。
4.  **寻找最小闭合覆盖**: 从最大兼容集中选择一个[子集](@entry_id:261956)，这个[子集](@entry_id:261956)必须能“覆盖”所有原始状态，并且满足“闭合”性质。**闭合 (closure)** 性质要求，对于覆盖集中的任何一个兼容集和任何一个输入，其所有成员的下一状态必须都包含在覆盖集中的某一个兼容集之内。

这个过程的目标是找到覆盖所有状态的最少数量的兼容集。这个数量就是最小化后电路所需的状态数。例如，在分析一个具有六个状态 (a-f) 的原始流表后，我们可能发现状态 {a, b, d, e} 都是相互兼容的，可以合并成一个新状态 S1，而状态 {c, f} 也是兼容的，可以合并成 S2。如果 {S1, S2} 这个集合满足闭合性质，那么我们就成功地将一个六状态的[电路简化](@entry_id:270214)为了一个二状态的电路 [@problem_id:1911376]。

### [状态分配](@entry_id:172668)的挑战：竞争条件

在得到合并流表后，下一步是为每个[状态分配](@entry_id:172668)一个唯一的二[进制](@entry_id:634389)编码，这个过程称为**[状态分配](@entry_id:172668) (state assignment)**。在[异步电路](@entry_id:169162)中，这是最关键且最容易出错的步骤。问题的根源在于，当状态跃迁需要多个[状态变量](@entry_id:138790)（例如，从 `00` 跃迁到 `11`）同时改变时，物理电路中的门延迟和[信号传播延迟](@entry_id:271898)不可能是完全一致的。

这种需要多个[状态变量](@entry_id:138790)同时变化的情况被称为**竞争条件 (race condition)**。由于延迟的微小差异，[状态变量](@entry_id:138790)的变化顺序变得不确定。例如，从 `00` 到 `11` 的跃迁可能会先经过中间状态 `01`，也可能先经过 `10`。

竞争本身不一定是问题。如果所有可能的中间路径最终都导向同一个正确的稳定状态，那么这个竞争就是**非关键竞争 (non-critical race)**。然而，如果不同的变化顺序导致电路稳定在不同的状态，其中至少有一个是错误的，那么这个竞争就是**关键竞争 (critical race)**。关键竞争是[异步电路](@entry_id:169162)的“致命杀手”，它会导致电路行为不可预测，必须在设计阶段完全消除。

让我们看一个具体的例子 [@problem_id:1911351]。假设一个电路的[状态分配](@entry_id:172668)如下，当输入 $x$ 从 0 变为 1 时，电路需要从状态 `(y1, y2) = 00` 跃迁到 `11`。
*   如果 $y_1$ 先变化：状态变为 `10`。假设在输入 $x=1$ 时，`10` 是一个稳定状态。那么电路就会错误地停留在 `10`。
*   如果 $y_2$ 先变化：状态变为 `01`。假设在输入 $x=1$ 时，`01` 也是一个稳定状态。那么电路就会错误地停留在 `01`。

由于最终状态取决于哪个[状态变量](@entry_id:138790)“赢得”了竞争，并且结果都不是预期的 `11`，这就是一个典型的关键竞争。

最简单的竞争来自于基础的[锁存器](@entry_id:167607)。一个由交叉耦合的[或非门](@entry_id:174081)构成的 SR 锁存器，当输入 S 和 R 同时从 1 变为 0 时，两个门都试图将自己的输出拉高。哪个门的速度稍微快一点，就会“赢得”竞争，将锁存器置于其对应的稳定状态（$Q=1$ 或 $Q=0$）。最终结果是不可预测的，完全取决于门之间微小的、不可避免的物理差异 [@problem_id:1911320]。

### 无竞争的[状态分配](@entry_id:172668)策略

[状态分配](@entry_id:172668)的首要目标就是避免关键竞争。最理想的策略是：**为任意两个需要直接相互跃迁的[状态分配](@entry_id:172668)海明距离为 1 的编码**。海明距离为 1 意味着两个编码只有一个比特位不同，因此跃迁时只需要改变一个状态变量，从根本上消除了竞争的发生。

为了系统地实现这一点，我们可以使用**状态邻接图 (state adjacency diagram)**。
1.  首先，检查合并流表，找出所有在单个输入变化下发生跃迁的状态对。例如，如果状态 A 在某输入下会跃迁到 B，那么 (A, B) 就是一个需要邻接的对。
2.  将所有[状态表示](@entry_id:141201)为图的顶点，并将所有需要邻接的对用边连接起来，形成邻接图。
3.  然后，尝试将这个图嵌入到一个布尔[超立方体](@entry_id:273913)中（例如，对于 4 个状态，就是嵌入一个 2-维的正方形），使得所有通过边连接的顶点在[超立方体](@entry_id:273913)上也是相邻的。

例如，对于一个四状态 (A, B, C, D) 的电路，如果流表要求 A 与 B、A 与 D、B 与 C、D 与 C 之间都有跃迁，那么我们需要找到一个分配方案，使得这些对的海明距离都为 1。将 A, B, C, D 分配为 `00`, `01`, `11`, `10` 恰好满足这个要求，因为它们在 2-维布尔空间中形成了一个循环路径（[格雷码](@entry_id:166435)），所有相邻状态的海明距离都是 1 [@problem_id:1911377]。

然而，并非所有邻接图都能完美地嵌入到相应维度的[超立方体](@entry_id:273913)中。在这种情况下，我们必须采用更高级的策略，其中一种是巧妙地利用**非关键竞争**。

如果一个跃迁（例如，从状态 D 到 B）不可避免地需要改变两个状态位（例如，从 `10` 到 `01`），我们可以检查其可能的中间状态（`00` 和 `11`）。如果在导致该跃迁的输入条件下，这两个中间状态都会确定性地导向最终目标状态 B，那么无论竞争如何发生，结果都是正确的。这样的竞争就是非关键的，是允许存在的。在设计一个 011 [序列检测器](@entry_id:261086)时，我们可能会遇到从状态 D (`10`) 到 B (`01`) 的跃迁。如果其可能的中间状态 A (`00`) 和 C (`11`) 在该输入条件下都会跃迁到 B，那么这个双比特变化的分配方案就是有效的 [@problem_id:1911309]。

### 实现与险象消除

完成无关键竞争的[状态分配](@entry_id:172668)后，我们就可以为每个[状态变量](@entry_id:138790) $Y_i$ 和每个输出 $Z_j$ 推导其逻辑表达式（激励函数和输出函数）。这些函数通常用[卡诺图](@entry_id:264061)来化简。然而，[异步电路](@entry_id:169162)的组合逻辑部分也隐藏着自己的时序问题，即**险象 (hazards)**。

险象是当单个输入变量改变时，本应保持恒定输出的组合逻辑电路中出现的短暂毛刺。
*   **静态险象 (Static Hazards)**: 输出本应保持不变（1 或 0），但却瞬间跳变到相反的值再恢复。
    *   **静态-1 险象**: 输出本应为 1，但出现 $1 \to 0 \to 1$ 的毛刺。
    *   **静态-0 险象**: 输出本应为 0，但出现 $0 \to 1 \to 0$ 的毛刺。
*   **动态险象 (Dynamic Hazards)**: 输出本应只改变一次（从 0 到 1 或从 1 到 0），但却发生了多次跳变（如 $1 \to 0 \to 1 \to 0$）。

在[异步电路](@entry_id:169162)中，这些毛刺可能会被[反馈回路](@entry_id:273536)错误地解释为有效的状态变化信号，导致电路进入错误状态。因此，必须消除所有险象。

对于使用“与非”或“或非”门实现的“与-或”式（SOP）逻辑，我们主要关心静态-1险象。它发生在[卡诺图](@entry_id:264061)中两个相邻的‘1’被不同的乘积项（蕴含项）所覆盖时。当输入从一个‘1’对应的[最小项](@entry_id:178262)变化到另一个相邻的‘1’时，电路会暂时从一个乘积项的有效范围“脱离”，在另一个乘积项的有效范围“生效”之前，存在一个短暂的瞬间，两个乘积项的输出都为 0，导致总输出出现毛刺。

解决方案是添加一个冗余的乘积项来“桥接”这个间隙。这个冗余项被称为**共识项 (consensus term)**。根据[共识定理](@entry_id:177696) $AB + A'C = AB + A'C + BC$，对于由变量 $A$ 分隔的两个乘积项 $AB$ 和 $A'C$，共识项就是 $BC$。在卡诺图上，这相当于添加一个新的蕴含项来同时覆盖那两个原本分离的相邻的‘1’。

例如，对于一个激励函数 $Y = x'y' + xz$，当输入从 $(0,0,1)$ 变为 $(1,0,1)$ 时，电路的覆盖范围从 $x'y'$ 切换到 $xz$。这两个乘积项由 $x$ 和 $x'$ 分隔，它们的共识项是 $y'z$。将这个共识项加入表达式，得到 $Y = x'y' + xz + y'z$，即可消除该路径上的静态-1险象 [@problem_id:1911315]。在一个完整的电路中，我们需要为所有激励函数中的每一对可能产生险象的乘积项都添加共识项，以确保电路的完全无险象运行 [@problem_id:1911350]。

需要注意的是，险象分为**逻辑险象 (logic hazard)** 和**功能险象 (function hazard)**。逻辑险象是实现的缺陷，可以通过添加[冗余逻辑](@entry_id:163017)（如共识项）来修复。而功能险象是电路功能规范本身固有的问题。当输入发生多于一个比特的变化时，如果初始和最终状态的输出都为 1，但所有可能的中间状态的输出都被规范为 0，那么无论如何实现，都无法避免 $1 \to 0 \to 1$ 的毛刺。这种险象无法通过修改逻辑来消除，只能通过改变输入的变化方式或修改功能规范来解决 [@problem_id:1911310]。

### [亚稳态](@entry_id:167515)：不可避免的风险

即使我们完美地解决了所有关键竞争和逻辑险象，[异步电路](@entry_id:169162)中还潜藏着一个更根本的物理现象：**亚稳态 (metastability)**。亚稳态是指一个[双稳态](@entry_id:269593)元件（如[锁存器](@entry_id:167607)）的输出在一个不确定的时间内停留在逻辑‘0’和‘1’之间的某个中间电压值，既非高也非低。

[亚稳态](@entry_id:167515)的根源在于对时序要求的违反。当一个锁存器的输入信号变化得太靠近其锁存[时钟沿](@entry_id:171051)（对于[同步电路](@entry_id:172403)）或当其[建立时间](@entry_id:167213)和保持时间要求被违反时（对于[异步电路](@entry_id:169162)），就会发生亚稳态。在我们的 SR [锁存器](@entry_id:167607)例子中，当 S 和 R 输入几乎同时从高电平变为低电平时，两个或非门都在争夺对电路状态的控制权。如果两个输入的变化时间差 $\Delta t = |t_S - t_R|$ 非常小，电路就可能进入一个“平衡”点，像一个被精确地竖立在针尖上的铅笔。在这个不稳定的[平衡点](@entry_id:272705)，输出电压停留在逻辑阈值附近，直到[热噪声](@entry_id:139193)或其他微小扰动最终将其推向一个稳定的逻辑状态（0 或 1）。

关键在于，从[亚稳态](@entry_id:167515)中“恢复”到稳定状态所需的时间是无法预测的。虽然它最终总会解决，但这个解决时间可能比正常的门延迟长得多。

研究表明，当输入信号变化的间隔时间小于一个门的[传播延迟](@entry_id:170242) $t_{pd}$ 时，即 $\Delta t \lt t_{pd}$，发生亚稳态的风险会显著增高 [@problem_id:1911371]。这是因为在第一个输入变化的效果通过一个门传播并影响到另一个门之前，第二个（相反的）输入变化已经发生，从而在[反馈环](@entry_id:273536)路中制造了一场无法立即解决的“冲突”。

[亚稳态](@entry_id:167515)无法被完全消除，它是任何双稳态电路固有的物理特性。在设计中，我们能做的不是消除它，而是降低其发生的概率，并确保系统能够从其影响中恢复，例如通过使用多级[同步器](@entry_id:175850)来增加亚稳态的解决时间，从而极大地降低错误传播到系统其余部分的概率。理解[亚稳态](@entry_id:167515)是设计任何处理[异步信号](@entry_id:746555)的可靠数字系统的基础。