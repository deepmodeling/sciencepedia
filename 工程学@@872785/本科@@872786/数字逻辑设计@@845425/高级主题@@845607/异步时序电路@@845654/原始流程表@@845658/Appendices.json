{"hands_on_practices": [{"introduction": "我们从时序逻辑中的一个基本概念——记忆——开始。这个练习要求你设计一个电路，其输出会随着每一次输入变化而翻转，这对于纯组合逻辑电路来说是不可能完成的任务。通过确定所需的状态，你将亲身体验如何使用原始流程表为电路赋予记忆过去事件的能力。[@problem_id:1953742]", "problem": "一个异步时序电路有一个单输入 `x` 和一个单输出 `z`。该电路被设计为一个边沿触发的翻转设备。具体来说，对于输入线 `x` 上的任何变化（无论是从 0 到 1 还是从 1 到 0），输出 `z` 都必须翻转其当前值。例如，如果 `z` 当前为 0，`x` 的下一次变化将导致 `z` 变为 1。随后 `x` 的变化将导致 `z` 变为 0，依此类推。\n\n假设该电路由一个原始流程表描述，其中每一行恰好包含一个稳定状态，请确定完全指定此行为所需的稳定状态总数。", "solution": "设输入为 $x \\in \\{0,1\\}$，输出为 $z \\in \\{0,1\\}$。在具有单个输入的异步时序电路的原始流程表中，每个稳定状态都与一个确切的输入值相关联（即该状态所在列是唯一的稳定列）。因此，对于任何稳定状态 $s$，都存在一个唯一的 $i_{s} \\in \\{0,1\\}$，使得当 $x=i_{s}$ 时状态 $s$是稳定的。\n\n设计要求是边沿触发翻转：每当 $x$ 发生变化（无论是 $0 \\to 1$ 还是 $1 \\to 0$），输出都必须翻转。如果 $z$ 表示变化前的输出，那么变化后输出必须为\n$$\nz^{+} = 1 - z.\n$$\n当 $x$ 保持不变（无变化）时，输出必须保持其当前值。\n\n考虑这对稳定状态集合 $S$ 的影响：\n- 在任何稳定状态 $s \\in S$ 中，当输入 $x=i_{s}$ 保持不变时，输出必须保持在一个固定的值 $z_{s} \\in \\{0,1\\}$。\n- 当 $x$ 从 $i_{s}$ 变为 $1-i_{s}$ 时，机器必须转换到一个在新输入下稳定的状态，并且在该新状态下，输出必须是 $1 - z_{s}$。\n\n我们现在证明 $|S|$ 的一个下界。\n- 假设（为了引出矛盾）$|S|=2$。那么存在一个状态 $s_{0}$，它在 $x=0$ 时稳定，输出为 $z_{0}$；以及一个状态 $s_{1}$，它在 $x=1$ 时稳定，输出为 $z_{1}$。每当 $x=1$ 保持不变时，电路必须处于状态 $s_{1}$，因此无论历史如何，输出都强制为 $z_{1}$。然而，翻转要求规定，根据已发生的输入变化的奇偶性，当 $x=1$ 保持不变时，两种输出值 $0$ 和 $1$ 都必须是可达的（因为每次变化都会翻转 $z$）。对于 $x=1$ 只有一个具有固定输出 $z_{1}$ 的稳定状态 $s_{1}$ 来说，这是不可能的。因此 $|S| \\geq 4$。\n\n我们现在展示一个恰好有四个稳定状态的构造，以证明其充分性。定义四个稳定状态，通过其稳定时的输入和输出值来区分：\n- $A_{0}$：当 $x=0$ 时稳定，输出 $z=0$。\n- $A_{1}$：当 $x=0$ 时稳定，输出 $z=1$。\n- $B_{0}$：当 $x=1$ 时稳定，输出 $z=0$。\n- $B_{1}$：当 $x=1$ 时稳定，输出 $z=1$。\n\n状态转换定义如下：\n- 如果输入保持不变，机器停留在同一状态（原始流程表中的唯一稳定列）。\n- 当 $x$ 从 $0$ 变为 $1$ 时，翻转 $z$ 并从 $A_{0} \\to B_{1}$ 以及 $A_{1} \\to B_{0}$。\n- 当 $x$ 从 $1$ 变为 $0$ 时，翻转 $z$ 并从 $B_{0} \\to A_{1}$ 以及 $B_{1} \\to A_{0}$。\n\n这满足了每次输入变化时 $z^{+} = 1 - z$ 的要求，并在 $x$ 恒定时保持 $z$ 不变，且每个状态只有一个稳定输入，符合原始流程表的要求。因此，所需的最少且充足的稳定状态数为 $4$。", "answer": "$$\\boxed{4}$$", "id": "1953742"}, {"introduction": "构建可靠的系统通常意味着要为无效输入做好准备。本练习将探讨一种故障检测器的设计，它能识别两个输入同时变化的情况——这种情况违反了基本模式的假设。你将学习如何将状态划分为正常工作模式和一个永久性的“陷阱”状态，这是创建健壮的异步设计的关键技术。[@problem_id:1953732]", "problem": "一个异步时序电路被设计为在基本模式下工作。它有两个二进制输入，$X_1$ 和 $X_2$，以及一个单一输出，$E$。\n\n在正常操作下，任何时候只允许一个输入发生变化。在下一次输入变化发生之前，电路有足够的时间转换到一个新的稳定状态。该电路的目的是作为一个故障检测器。如果两个输入 $X_1$ 和 $X_2$ 的值同时变化（例如，从 $X_1X_2 = 00$ 转换到 $11$，或从 $X_1X_2 = 01$ 转换到 $10$），电路必须转换到一个唯一的、永久的错误状态。\n\n对于所有正常操作状态，输出 $E$ 定义为 $0$；对于错误状态，输出 $E$ 定义为 $1$。一旦电路进入错误状态，无论后续输入如何变化，它都必须无限期地保持在该状态。\n\n假设在正常的、非错误操作期间，电路必须能够对四种可能的输入组合（$00, 01, 10, 11$）中的任何一种保持稳定。原始流程表是一种状态转换表，其中每一行代表一个唯一的内部状态，并且每一行只包含一个稳定状态条目（对于可能对多个或所有输入都稳定的终端“陷阱”状态，可以有例外）。\n\n为这个故障检测器指定完整的原始流程表，所需的最少行数（即总内部状态数），包括错误状态，是多少？", "solution": "由于电路工作在基本模式下，在正常操作中，每次只有一个输入变化，且电路在下一次变化前会稳定下来。在原始流程表中，每个内部状态（行）只有一个稳定的输入列；只有一个终端陷阱（错误）状态允许对多个输入保持稳定。\n\n要求1（正常稳定性）：在正常的、非错误操作期间，机器必须能够对四种输入组合 $00,01,10,11$ 中的每一种都保持稳定，且输出 $E=0$。由于原始流程表中的每一行只能有一个稳定的输入，要实现对所有四种输入组合的稳定性，至少需要四个不同的正常内部状态，每个输入组合对应一个。因此，正常操作状态至少需要 $4$ 行。\n\n要求2（永久性错误）：必须有一个唯一的永久性错误状态，其输出 $E=1$，当两个输入同时变化时（从 $00$ 到 $11$ 或从 $01$ 到 $10$），机器会进入该状态。一旦进入该状态，无论输入如何变化，它都必须保持不变，因此它必须是一个对所有四个输入都稳定的陷阱状态。这个错误状态不能与任何正常状态合并，因为正常状态的输出必须为 $E=0$，并且每个正常行只能对单个输入稳定。因此，至少需要额外的一行用于错误陷阱状态。\n\n下限：综合以上所述，至少需要 $4+1=5$ 行。\n\n用 $5$ 行实现的可行性：使用四个正常行，每个行恰好在一个输入 $00,01,10,11$ 上稳定，以及一个对所有输入都稳定的错误陷阱行。定义状态转换，使得从一个正常状态出发，单个比特的输入变化直接转换到相应的相邻正常状态（保持正常行为），而两个比特的变化（非相邻输入）则转换到错误陷阱状态。这满足了规范要求，并且只使用了 $5$ 行。\n\n因此，所需的最小行数（总内部状态数），包括错误状态，是 $5$。", "answer": "$$\\boxed{5}$$", "id": "1953732"}, {"introduction": "现实世界的系统常常需要管理对共享资源的竞争性请求，这个过程称为仲裁。这个高级练习要求你为一个后进先出（LIFO）仲裁器建模，其内部状态不仅要记住谁拥有资源，还要记住被抢占请求的完整历史。这个问题将挑战你对“状态”可以表示什么，以及其复杂性如何随系统逻辑需求的增加而扩展的理解。[@problem_id:1953743]", "problem": "需要设计一个异步的、三输入的、抢占式后进先出（LIFO）仲裁器。该仲裁器有三个请求输入 $R_2, R_1, R_0$ 和三个相应的授权输出 $G_2, G_1, G_0$。其行为由以下规则定义：\n\n1.  最初，系统处于空闲状态，没有请求被断言，也没有授权被发出。输出向量 $(G_2, G_1, G_0)$ 为 $(0,0,0)$。\n2.  授权被授予最近断言的请求。在任何时候只有一个授权可以是活动的。对请求 $R_i$ 的活动授权由输出向量表示，其中只有第 $i$ 个分量为 1（例如，$G_1=1$ 对应于 $(0,1,0)$）。\n3.  如果在一个请求 $R_{old}$ 当前持有授权时，一个新的请求 $R_{new}$ 被断言，那么 $R_{new}$ 会抢占 $R_{old}$ 并获得授权。被抢占的请求 $R_{old}$ 被推入一个由被抢占请求组成的后进先出（LIFO）堆栈。\n4.  当当前获得授权的请求被撤销断言时，如果抢占堆栈顶部的请求（即最近被抢占的请求）仍然处于断言状态，则授权将传递给它。这实际上是从堆栈中“弹出”该请求。\n5.  如果一个请求从堆栈中弹出但已不再被断言，仲裁器会尝试将授权授予堆栈中的下一个请求，并持续此过程直到发出授权或堆栈为空。如果堆栈变空，仲裁器返回到空闲状态。\n6.  如果一个当前在抢占堆栈上（但未持有授权）的请求被撤销断言，它会直接从其在堆栈中的位置被移除，而不会影响当前的授权持有者。\n\n假设在任何时候只有一个输入可以改变，可以构建一个原始流程表来描述电路的行为。每个唯一的抢占序列对应一个唯一的内部状态。对于给定的输入组合，可能存在多个稳定状态，每个状态对应于不同的请求到达历史。\n\n对于任何单个输入组合 $(R_2, R_1, R_0)$，可能存在的不同稳定状态的最大数量是多少？", "solution": "我们通过断言的请求集合来为一个固定的输入组合建模其行为。设 $S \\subseteq \\{R_{2},R_{1},R_{0}\\}$ 是在给定输入向量 $(R_{2},R_{1},R_{0})$ 下当前被断言的请求的子集，并设 $k=|S| \\in \\{0,1,2,3\\}$。\n\n根据规则：\n- 当 $k \\geq 1$ 时，恰好有一个授权是活动的，即授予 $S$ 中最近断言的请求。\n- 抢占堆栈以“后进先出”的顺序包含其他被断言的请求，任何被撤销断言的请求都会被立即移除（因此堆栈中只包含仍然被断言的请求）。\n- 对于固定的输入（没有进一步的变化），不会发生状态转换；因此，稳定性完全由当前断言的请求是如何到达的历史决定的。\n\n因此，对于一个给定的、有 $k$ 个不同请求被断言的集合 $S$，这 $k$ 个请求的每一种可能的到达顺序（抢占序列）都会产生一个不同的内部状态：顺序中最近的请求持有授权，其余的 $k-1$ 个请求按后进先出（LIFO）顺序占据堆栈。$k$ 个不同元素的不同到达顺序的数量是 $k!$。问题描述确认了每个唯一的抢占序列都对应一个唯一的内部状态，因此对于一个有 $k$ 个请求被断言的固定输入，其不同稳定状态的数量恰好是\n$$\nk!.\n$$\n为了找到所有输入组合中的最大值，我们在 $k \\leq 3$ 的约束下最大化 $k!$。这在 $k=3$（所有三个请求都被断言）时发生，得出\n$$\n3! = 6.\n$$\n因此，对于任何单个输入组合，不同稳定状态的最大数量是 $6$。", "answer": "$$\\boxed{6}$$", "id": "1953743"}]}