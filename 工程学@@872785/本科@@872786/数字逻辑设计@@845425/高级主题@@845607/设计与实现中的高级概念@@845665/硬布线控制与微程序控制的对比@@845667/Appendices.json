{"hands_on_practices": [{"introduction": "理解微程序控制的第一步是深入其核心——微指令。微指令的每一个比特位都不是凭空产生的，而是为了精确控制数据通路上的某个具体硬件。这个练习将带你从头开始，根据给定的CPU数据通路需求，设计一个水平微指令的格式，从而亲身体会控制信号是如何被编码成微程序的基本单元的。[@problem_id:1941350]", "problem": "一个工程团队正在为一款新型32位中央处理器（CPU）设计其控制单元。他们选择了一种微程序方法，并采用纯水平格式，通过消除控制信号的译码延迟来最大化性能。该CPU的数据通路包含以下组件和要求，每个微指令都必须对其进行管理：\n\n1.  **寄存器文件**：该CPU包含一个带有32个通用寄存器的寄存器文件。一条微指令必须能够为两个源寄存器（源A和源B）和一个目标寄存器指定地址。它还必须包含一个专用的位，用于启用或禁用对目标寄存器的写操作（`RegWrite`）。\n\n2.  **算术逻辑单元（ALU）**：ALU能够执行30种不同的操作。ALU的控制方案是未编码的，这意味着对于这30种操作中的每一种，微指令中都有一个专用的、独立的控制位。\n\n3.  **数据通路多路选择器**：\n    *   一个2选1多路选择器用于选择第二个ALU操作数。其单个控制位（`ALUSrc`）在源寄存器B的值和主指令提供的立即数之间进行选择。\n    *   另一个2选1多路选择器用于选择要写回寄存器文件的数据。其单个控制位（`MemToReg`）在ALU的结果和从内存中获取的数据之间进行选择。\n\n4.  **内存接口**：与主存储器的接口需要两个独立的控制信号：`MemRead`用于发起读操作，`MemWrite`用于发起写操作。\n\n5.  **分支控制**：两个独立的控制位用于程序流控制：`PCWrite`用于启用对程序计数器的更新，`Branch`用于执行条件分支。\n\n6.  **微程序定序**：每条微指令必须明确指定要执行的下一条微指令的地址。存放微程序的控制存储器总容量为1024条微指令。\n\n根据这些规格，确定该控制单元中单条微指令的总宽度（以比特为单位）。", "solution": "要确定微指令的宽度，需要将每个指定字段所需的比特数相加。\n\n寄存器文件寻址：\n- 有$32$个寄存器，因此每个寄存器地址需要 $\\log_{2} 32 = 5$ 比特。\n- 两个源地址和一个目标地址需要\n$$2 \\cdot 5 + 5 = 15 \\text{ bits}.$$\n- 加上单个写使能位：\n$$15 + 1 = 16 \\text{ bits}.$$\n\nALU控制：\n- 具有$30$种不同操作的非编码控制使用$30$个独立的比特：\n$$30 \\text{ bits}.$$\n\n数据通路多路选择器：\n- 两个$2$选$1$多路选择器控制信号（$\\text{ALUSrc}$ 和 $\\text{MemToReg}$）需要\n$$1 + 1 = 2 \\text{ bits}.$$\n\n内存接口：\n- $\\text{MemRead}$ 和 $\\text{MemWrite}$ 需要\n$$1 + 1 = 2 \\text{ bits}.$$\n\n分支控制：\n- $\\text{PCWrite}$ 和 $\\text{Branch}$ 需要\n$$1 + 1 = 2 \\text{ bits}.$$\n\n微程序定序：\n- 控制存储器有$1024$个条目，因此下一地址字段需要\n$$\\log_{2} 1024 = 10 \\text{ bits}.$$\n\n微指令总宽度：\n$$16 + 30 + 2 + 2 + 2 + 10 = 62 \\text{ bits}.$$", "answer": "$$\\boxed{62}$$", "id": "1941350"}, {"introduction": "硬布线控制和微程序控制最核心的权衡之一在于速度与灵活性。硬布线通常更快，但究竟快多少？这个练习将此权衡从定性描述转化为定量分析。通过推导一个决定哪种设计时钟周期更短的关键阈值，你将能够精确理解影响性能的关键因素，例如逻辑门延迟和控制存储器的访问时间。[@problem_id:1941359]", "problem": "一个数字系统工程团队正在评估一个新处理器控制单元的两种不同设计理念。两种设计都必须实现相同的指令集架构（ISA）。\n\n第一个选项是**硬连线控制单元**。该设计的性能受限于最长的组合逻辑路径。最大逻辑深度，定义为从输入到输出的任何路径中门的最大数量，用 $D_{HW}$ 表示。该设计的时钟周期由通过此最长路径的传播延迟加上状态寄存器的建立时间决定。\n\n第二个选项是**微程序控制单元**。该设计使用一个实现为只读存储器（ROM）的控制存储器和一些支持逻辑。该设计的时钟周期（即一个微周期的时间）由获取下一条微指令所需的关键路径决定。该路径包括访问ROM，通过下一地址生成逻辑处理部分取出的微指令，并为后续周期准备微程序计数器。下一地址生成电路的逻辑深度用 $D_{addr}$ 表示。\n\n对于两种设计，假设如下：\n- 所有逻辑门的传播延迟均为 $t_{pd}$。\n- 所有寄存器（例如，硬连线单元中的状态寄存器，微程序单元中的微程序计数器）的建立时间均为 $t_{setup}$。\n- 微程序单元中的ROM具有指定的存取时间 $T_{ROM}$。\n\n为了决定哪种设计在原始时钟速度方面更优越，团队希望找到一个临界阈值。推导ROM存取时间的阈值表达式，我们称之为 $T_{threshold}$。如果所选组件的实际ROM存取时间 $T_{ROM}$ 大于此 $T_{threshold}$，则硬连线控制单元的时钟周期将严格短于微程序控制单元。请用 $D_{HW}$、$D_{addr}$ 和 $t_{pd}$ 来表示你的答案。", "solution": "同步设计的时钟周期由最长路径上的关键组合逻辑延迟加上目标寄存器的建立时间之和决定。\n\n对于硬连线控制单元，最大逻辑深度为 $D_{HW}$ 个门，每个门的传播延迟为 $t_{pd}$，目标寄存器的建立时间为 $t_{setup}$。因此，时钟周期为\n$$\nT_{HW} = D_{HW}\\,t_{pd} + t_{setup}.\n$$\n\n对于微程序控制单元，每个微周期的关键路径包括ROM存取加上深度为 $D_{addr}$ 的下一地址生成逻辑，然后是存入建立时间为 $t_{setup}$ 的微程序计数器。因此，时钟周期为\n$$\nT_{MP} = T_{ROM} + D_{addr}\\,t_{pd} + t_{setup}.\n$$\n\n当 $T_{HW}  T_{MP}$ 时，硬连线控制单元严格更快（即具有严格更短的时钟周期）。代入上述表达式，有 $D_{HW}\\,t_{pd} + t_{setup}  T_{ROM} + D_{addr}\\,t_{pd} + t_{setup}$。从两边消去 $t_{setup}$ 并重新整理以分离出 $T_{ROM}$，可得 $T_{ROM} > (D_{HW} - D_{addr})\\,t_{pd}$。\n\n因此，两种设计性能持平时的阈值ROM存取时间为\n$$\nT_{threshold} = (D_{HW} - D_{addr})\\,t_{pd}.\n$$\n当 $T_{ROM} > T_{threshold}$ 时，硬连线控制单元的时钟周期严格短于微程序控制单元。", "answer": "$$\\boxed{(D_{HW}-D_{addr})\\,t_{pd}}$$", "id": "1941359"}, {"introduction": "仅仅比较时钟周期可能无法完全反映真实性能的差异，因为不同控制方式执行一条复杂指令所需的总周期数也不同。这个最终练习通过一个具体的内存搜索指令，对两种控制单元的完整执行过程进行建模和比较。通过计算总执行时间，你将看到微程序控制的灵活性开销和硬布线控制为特定任务高度优化的效率是如何在实践中体现的。[@problem_id:1941358]", "problem": "一位数字系统架构师正在为一款新的中央处理器 (CPU) 设计控制单元。其中一项要求是实现一条特殊指令 `SEARCH`，该指令对一个内存区域执行线性扫描。该指令的功能是在一个由 `L` 个连续内存字组成的块中搜索一个特定值。您的任务是分析硬布线控制单元和微程序控制单元在执行这条 `SEARCH` 指令时的性能差异。\n\n分析针对的是最坏情况，即未找到目标值，指令必须遍历整个 `L` 字的数据块。系统具有以下特性：\n- 要搜索的内存块长度为 `L = 120` 字。\n- 任何内存读取操作都需要 CPU 等待一个固定的时长，即 `N_mem_cycles = 18` 个时钟周期。\n\n每种实现方式的执行时间（以时钟周期为单位）建模如下：\n\n**1. 硬布线控制单元：**\n控制逻辑被实现为一个高度优化的有限状态机 (FSM)。\n- `SEARCH` 宏指令的初始取指和译码需要 4 个时钟周期。\n- 对于 `L` 次迭代中的每一次，FSM 执行必要的内部逻辑（计算内存地址、比较检索到的值以及管理循环计数器）。由于并行硬件，所有这些内部逻辑在每次迭代中 `C_hw_loop = 3` 个时钟周期内完成。这是在内存访问时间之外的开销。\n- 在最后一次迭代的比较失败后，会额外花费一个时钟周期来处理循环终止条件并结束指令。\n\n**2. 微程序控制单元：**\n`SEARCH` 指令在控制存储器（微代码）中被实现为一个例程。\n- `SEARCH` 宏指令的初始取指和译码需要 4 个时钟周期，之后控制权转移到 `SEARCH` 微例程。\n- 微例程以一条设置微指令开始，该指令需要 1 个时钟周期。\n- 微例程的主循环执行 `L` 次。每次迭代由一个微指令序列组成。除非另有说明，否则一条微指令需要 1 个时钟周期来执行。一次迭代的序列如下：\n    - 地址计算：2 条微指令。\n    - 内存读取：1 条微指令，该指令会使控制单元停顿。这条微指令的执行需要 `N_mem_cycles` 个时钟周期才能完成。\n    - 值比较：1 条微指令。\n    - 计数器增量：1 条微指令。\n    - 循环控制（条件分支）：1 条微指令。\n- 循环结束后，会执行一条结束微指令，需要 1 个时钟周期。\n\n计算微程序实现的总执行时间与硬布线实现的总执行时间之比（`T_microprogrammed / T_hardwired`）。将您的答案表示为一个实数，并四舍五入到四位有效数字。", "solution": "定义 $L$ 为要扫描的字数，$N_{\\text{mem\\_cycles}}$ 为以时钟周期为单位的固定内存读取延迟。\n\n硬布线控制单元：\n- 初始取指和译码耗费 $4$ 个周期。\n- $L$ 次迭代中的每一次都执行耗费 $C_{\\text{hw\\_loop}}=3$ 个周期的内部逻辑和一次耗费 $N_{\\text{mem\\_cycles}}$ 个周期的内存读取。因此，每次迭代的成本是 $3+N_{\\text{mem\\_cycles}}$。\n- 在最后一次比较失败后，有 $1$ 个周期的终止开销。\n因此，\n$$\nT_{\\text{hardwired}} \\;=\\; 4 \\;+\\; L\\,(3+N_{\\text{mem\\_cycles}}) \\;+\\; 1 \\;=\\; 5 \\;+\\; L\\,(N_{\\text{mem\\_cycles}}+3).\n$$\n代入 $L=120$ 和 $N_{\\text{mem\\_cycles}}=18$，\n$$\nT_{\\text{hardwired}} \\;=\\; 5 \\;+\\; 120\\cdot(18+3) \\;=\\; 5 \\;+\\; 120\\cdot 21 \\;=\\; 2525.\n$$\n\n微程序控制单元：\n- 初始取指和译码耗费 $4$ 个周期。\n- 设置微指令耗费 $1$ 个周期。\n- 每次迭代包括地址计算（$2$ 个周期）、内存读取停顿（$N_{\\text{mem\\_cycles}}$ 个周期）、比较（$1$ 个周期）、计数器增量（$1$ 个周期）和循环控制（$1$ 个周期），每次迭代总计 $N_{\\text{mem\\_cycles}}+5$ 个周期。\n- 结束微指令耗费 $1$ 个周期。\n因此，\n$$\nT_{\\text{microprogrammed}} \\;=\\; 4 \\;+\\; 1 \\;+\\; L\\,(N_{\\text{mem\\_cycles}}+5) \\;+\\; 1 \\;=\\; 6 \\;+\\; L\\,(N_{\\text{mem\\_cycles}}+5).\n$$\n代入 $L=120$ 和 $N_{\\text{mem\\_cycles}}=18$，\n$$\nT_{\\text{microprogrammed}} \\;=\\; 6 \\;+\\; 120\\cdot(18+5) \\;=\\; 6 \\;+\\; 120\\cdot 23 \\;=\\; 2766.\n$$\n\n所求的比率为\n$$\n\\frac{T_{\\text{microprogrammed}}}{T_{\\text{hardwired}}}\n\\;=\\;\n\\frac{6 + L\\,(N_{\\text{mem\\_cycles}}+5)}{5 + L\\,(N_{\\text{mem\\_cycles}}+3)}\n\\;=\\;\n\\frac{2766}{2525}\n\\approx 1.095445\\ldots\n$$\n四舍五入到四位有效数字，结果为 $1.095$。", "answer": "$$\\boxed{1.095}$$", "id": "1941358"}]}