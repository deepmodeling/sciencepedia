{"hands_on_practices": [{"introduction": "许多现实世界的系统，从家用电器到工业机器，都依赖于基于状态的控制。这个练习提供了一个实际场景——一个自动浴室风扇——来练习将一组操作规则转换为一个正式的算法状态机（ASM）图。这里的关键挑战 [@problem_id:1908113] 是为摩尔（Moore）型状态机正确定义状态和转换，特别需要注意如何利用一个专门的状态来生成一个单周期控制脉冲。", "problem": "您的任务是使用摩尔（Moore）型算法状态机（ASM）为自动化浴室通风系统设计一个数字控制器。该系统根据一个墙壁开关和一个外部定时器来控制灯和风扇。\n\n**系统组件和信号：**\n\n*   **输入：**\n    *   `S`：来自墙壁开关的单比特输入。当开关闭合时 `S=1`，断开时 `S=0`。\n    *   `T`：来自定时器模块的单比特输入。当倒计时完成时，定时器在一个时钟周期内输出 `T=1`。在其他情况下，`T=0`。\n\n*   **输出：**\n    *   `L`：控制灯的单比特输出。`L=1` 表示开灯，`L=0` 表示关灯。\n    *   `F`：控制风扇的单比特输出。`F=1` 表示开启风扇，`F=0` 表示关闭风扇。\n    *   `Start_Timer`：一个单比特输出，当其有效（`Start_Timer=1`）时，指示外部定时器模块开始倒计时。该信号应为一个单周期脉冲。\n\n**行为要求：**\n\n1.  初始状态下，灯和风扇都关闭。\n2.  当用户打开开关（`S=1`）时，灯和风扇立即开启。只要开关闭合，它们就保持开启状态。\n3.  当用户关闭开关（`S=0`）时，灯立即关闭。但风扇保持开启状态。\n4.  在关闭开关的同时，控制器必须向定时器模块发送一个单周期的启动信号。\n5.  风扇将继续运行，直到定时器完成其周期（由 `T=1` 指示），此时风扇关闭。\n6.  如果在灯关闭后的“延时”期间（即定时器完成之前），用户重新打开开关（`S=1`），系统应立即返回到灯和风扇都开启的状态，从而有效取消定时器的倒计时。\n\n以下哪项描述准确地表示了此控制器的摩尔（Moore）型 ASM？\n\nA. ASM 有四个状态：`IDLE`、`ACTIVE`、`START_DELAY` 和 `FAN_OVERRUN`。\n    - `IDLE`：输出为 `L=0`、`F=0`、`Start_Timer=0`。如果 `S=1`，则转移到 `ACTIVE`。\n    - `ACTIVE`：输出为 `L=1`、`F=1`、`Start_Timer=0`。如果 `S=0`，则转移到 `START_DELAY`。\n    - `START_DELAY`：输出为 `L=0`、`F=1`、`Start_Timer=1`。无条件转移到 `FAN_OVERRUN`。\n    - `FAN_OVERRUN`：输出为 `L=0`、`F=1`、`Start_Timer=0`。如果 `S=1`，则转移到 `ACTIVE`。如果 `S=0` 且 `T=1`，则转移到 `IDLE`。\n\nB. ASM 有三个状态：`OFF`、`ON` 和 `OVERRUN`。\n    - `OFF`：输出为 `L=0`、`F=0`、`Start_Timer=0`。如果 `S=1`，则转移到 `ON`。\n    - `ON`：输出为 `L=1`、`F=1`、`Start_Timer=0`。如果 `S=0`，则转移到 `OVERRUN`。\n    - `OVERRUN`：输出为 `L=0`、`F=1`、`Start_Timer=1`。如果 `S=1`，则转移到 `ON`。如果 `S=0` 且 `T=1`，则转移到 `OFF`。\n\nC. ASM 有四个状态：`IDLE`、`ACTIVE`、`START_DELAY` 和 `FAN_OVERRUN`。\n    - `IDLE`：输出为 `L=0`、`F=0`、`Start_Timer=0`。如果 `S=1`，则转移到 `ACTIVE`。\n    - `ACTIVE`：输出为 `L=1`、`F=1`、`Start_Timer=0`。如果 `S=0`，则转移到 `START_DELAY`。\n    - `START_DELAY`：输出为 `L=0`、`F=1`、`Start_Timer=1`。无条件转移到 `FAN_OVERRUN`。\n    - `FAN_OVERRUN`：输出为 `L=0`、`F=1`、`Start_Timer=0`。如果 `T=1`，则转移到 `IDLE`。\n\nD. ASM 有三个状态：`IDLE`、`ACTIVE` 和 `FAN_WAIT`。\n    - `IDLE`：输出为 `L=0`、`F=0`。如果 `S=1`，则转移到 `ACTIVE`。\n    - `ACTIVE`：输出为 `L=1`、`F=1`。在 `S` 变为 0 的转移发生时，它输出 `Start_Timer=1` 并进入 `FAN_WAIT`。\n    - `FAN_WAIT`：输出为 `L=0`、`F=1`。如果 `S=1`，则转移到 `ACTIVE`。如果 `T=1`，则转移到 `IDLE`。", "solution": "我们将控制器建模为摩尔（Moore）型 ASM，根据定义，其输出仅取决于当前状态。要求的行为对 ASM 结构意味着以下约束：\n1) 初始状态下，灯和风扇都关闭，因此必须存在一个初始状态，其输出为 $L=0$ 和 $F=0$。\n2) 当 $S=1$ 时，只要 $S=1$ 保持， $L$ 和 $F$ 都必须为 $1$。因此，必须存在一个状态，其输出为 $L=1$ 和 $F=1$，并且当 $S=1$ 时，存在从初始状态到该状态的转移。\n3) 当 $S$ 变为 $0$ 时，灯必须立即关闭，风扇保持开启。在摩尔机中，这意味着下一个状态的输出必须为 $L=0$ 和 $F=1$。\n4) 当 $S$ 变为 $0$ 的同时，必须产生一个单周期的 $Start\\_Timer$ 脉冲。在摩尔 ASM 中，产生单时钟脉冲的标准方法是进入一个专用的瞬时状态，其输出包含 $Start\\_Timer=1$，然后在下一个时钟无条件地转移到 $Start\\_Timer=0$ 的稳定延时运行状态。因此，我们需要一个输出为 $(L,F,Start\\_Timer)=(0,1,1)$ 的状态，该状态无条件地转移到一个输出为 $(0,1,0)$ 的状态。\n5) 风扇一直运行到定时器输出 $T=1$ 为止，此时风扇关闭。因此，当 $T=1$ 且 $S=0$ 时，我们必须从延时运行状态 $(L,F)=(0,1)$ 转移到空闲状态 $(0,0)$。\n6) 如果用户在延时运行期间（即 $T=1$ 之前）将 $S$ 重新置为 $1$，系统必须立即返回到 $(L,F)=(1,1)$ 的状态，从而取消定时器。在摩尔 ASM 中，这意味着从任何与延时运行相关的状态，当 $S=1$ 时，我们都必须优先转移到 $(1,1)$ 状态。\n\n现在根据这些摩尔机约束来评估各个选项：\n- 选项 A 提供了四个状态：$IDLE$ 状态，输出为 $(L,F,Start\\_Timer)=(0,0,0)$；$ACTIVE$ 状态，输出为 $(1,1,0)$；$START\\_DELAY$ 状态，输出为 $(0,1,1)$；以及 $FAN\\_OVERRUN$ 状态，输出为 $(0,1,0)$。从 $ACTIVE$ 状态在 $S=0$ 时转移到 $START\\_DELAY$ 状态，由于在下一个时钟会无条件转移到 $FAN\\_OVERRUN$ 状态，这使得 $Start\\_Timer=1$ 恰好维持一个周期。在 $FAN\\_OVERRUN$ 状态下，如果 $S=1$，则转移回 $ACTIVE$（立即取消定时器）；如果 $S=0$ 且 $T=1$，则转移到 $IDLE$（风扇关闭）。所有输出都基于状态，因此这是一个有效的摩尔 ASM，并且它满足了单周期 $Start\\_Timer$ 的要求以及所有 1-6 的行为要求。\n- 选项 B 在整个 $OVERRUN$ 状态期间都将 $Start\\_Timer$ 置为 1，而该状态会持续多个周期直到 $T=1$，这违反了单周期脉冲的要求。因此，该选项不正确。\n- 选项 C 缺少了在延时运行期间当 $S=1$ 时从延时状态转移到活动状态的路径，这违反了立即返回“两者都开启”状态并取消定时器的要求。因此，该选项不正确。\n- 选项 D 在“$S$ 变为 0 的转移发生时”置位 $Start\\_Timer$，这使得 $Start\\_Timer$ 的输出依赖于转移而不是纯粹地依赖于状态。这不是摩尔机的规范。因此，它不是一个有效的摩尔型 ASM。\n\n只有选项 A 满足摩尔型的要求和所有指定的行为，包括通过一个专用的瞬时状态生成单周期的 $Start\\_Timer$ 脉冲，以及在延时运行期间正确处理 $S=1$ 时的取消操作。", "answer": "$$\\boxed{A}$$", "id": "1908113"}, {"introduction": "ASM图是一种抽象的设计工具，而下一个关键步骤是将其转化为物理电路。这个练习 [@problem_id:1957151] 聚焦于从设计到实现这一重要转变，并以一个常见且重要的开关去抖动电路为例。你将推导出驱动存储状态机状态的触发器所需的布尔逻辑表达式，从而将高层次的ASM图与底层的逻辑门世界直接联系起来。", "problem": "在数字逻辑设计中，与按钮等机械元件接口时会遇到一个挑战，称为触点抖动。当按下或释放机械开关时，其金属触点会发生物理性反弹，产生一系列快速的、伪造的电脉冲，而不是一个单一、干净的跳变。一个常见的解决方案是使用实现为有限状态机（FSM）的去抖动电路。\n\n你的任务是为这样一个 FSM 设计组合逻辑。该 FSM 有两个输入和两个输出：\n- **输入：**\n  - `S`：来自开关的原始信号。按下时`S=1`，释放时`S=0`。该信号是“抖动的”。\n  - `T`：来自外部定时器的信号。`T=1`表示预定义的稳定周期已过。否则`T=0`。\n- **输出：**\n  - `Z`：去抖动后的干净输出信号。在确认有效的按钮按下后，它应该是一个单脉冲，高电平有效且仅持续一个时钟周期。\n  - `E`：外部定时器的使能信号。`E=1`启动或运行定时器。\n\n该 FSM 遵循此行为，由算法状态机（ASM）图描述：\n1.  从`IDLE`状态（`S0`）开始，等待开关被按下（`S=1`）。在此状态下，`Z=0`且`E=0`。\n2.  检测到`S=1`后，转换到`WAIT`状态（`S1`）。在此状态下，通过设置`E=1`来使能定时器。保持`Z=0`。\n3.  保持在`WAIT`状态，直到定时器完成（`T=1`）。\n4.  一旦`T=1`，再次检查开关输入`S`。\n    - 如果`S=1`（按键稳定），则转换到`PULSE`状态（`S2`）。\n    - 如果`S=0`（是抖动/噪声），则转换回`IDLE`状态。\n5.  在`PULSE`状态，将干净的输出`Z`置为1，持续一个时钟周期。定时器应被禁用（`E=0`）。\n6.  单个脉冲周期后，转换到`HELD`状态（`S3`），机器在该状态等待用户释放开关（`S=0`）。在此状态下，`Z=0`且`E=0`。\n7.  在`HELD`状态下，一旦`S=0`，则转换回`IDLE`状态，以等待下一次按键。\n\n该 FSM 将使用两个 D 型触发器实现，状态变量为 `Q1` 和 `Q0`。状态分配如下：\n- `S0` (IDLE): `Q1Q0 = 00`\n- `S1` (WAIT): `Q1Q0 = 01`\n- `S2` (PULSE): `Q1Q0 = 10`\n- `S3` (HELD): `Q1Q0 = 11`\n\n你的任务是确定触发器输入`D1`和`D0`以及去抖动输出`Z`的正确的、简化的积和式布尔表达式。在下面的表达式中，`·`表示逻辑与，`+`表示逻辑或，撇号`'`表示逻辑非。\n\n以下哪个选项提供了正确的方程组？\n\nA.\n`D1 = Q1·Q0' + Q1·Q0·S + Q0·S·T`\n`D0 = Q1·Q0' + Q1'·Q0·T' + Q1'·Q0'·S + Q1·Q0·S`\n`Z = Q1·Q0'`\n\nB.\n`D1 = Q1 + S·T`\n`D0 = Q1·Q0' + Q1'·Q0·T' + Q0'·S`\n`Z = Q1·Q0'`\n\nC.\n`D1 = Q1·Q0' + Q1·Q0·S + Q0·S·T`\n`D0 = Q1·Q0' + Q1'·Q0·T' + Q1'·Q0'·S + Q1·Q0·S`\n`Z = Q1`\n\nD.\n`D1 = Q1·Q0' + Q0·T`\n`D0 = Q1'·S + Q1·Q0' + Q1'·Q0`\n`Z = Q1·Q0'`\n\nE.\n`D1 = Q1·Q0' + Q1'·Q0·S·T`\n`D0 = Q1'·Q0'·S + Q1·Q0'`\n`Z = Q1·Q0'`", "solution": "我们将现态位表示为 $Q_{1}$ 和 $Q_{0}$，次态位（D 输入）表示为 $D_{1}=Q_{1}^{+}$ 和 $D_{0}=Q_{0}^{+}$。输入为 $S$（开关）和 $T$（定时器完成）。状态编码如下：\n- $S0$ (IDLE): $Q_{1}Q_{0}=00$\n- $S1$ (WAIT): $Q_{1}Q_{0}=01$\n- $S2$ (PULSE): $Q_{1}Q_{0}=10$\n- $S3$ (HELD): $Q_{1}Q_{0}=11$\n\n根据 ASM 描述，状态转换行为如下：\n- 从 $00$ (IDLE) 状态：如果 $S=0$，则保持 $00$；如果 $S=1$，则转移到 $01$。此处 $T$ 无关。\n- 从 $01$ (WAIT) 状态：如果 $T=0$，则保持 $01$；如果 $T=1$，则当 $S=1$ 时转移到 $10$，否则（$S=0$）转移到 $00$。\n- 从 $10$ (PULSE) 状态：在下一个时钟沿无条件转移到 $11$。\n- 从 $11$ (HELD) 状态：如果 $S=1$，则保持 $11$；如果 $S=0$，则转移到 $00$。此处 $T$ 无关。\n\n我们现在以积和式的形式推导 $D_{1}$ 和 $D_{0}$。\n\n首先，$D_{1}=1$ 的条件是次态满足 $Q_{1}^{+}=1$。列举各种情况：\n- 从 $01$ 状态，当 $T=1$ 且 $S=1$ 时：$01\\to 10$，所以 $Q_{1}^{+}=1$。这产生项 $Q_{1}'Q_{0} S T$。\n- 从 $10$ 状态：无论 $S,T$ 如何，$10\\to 11$，因此对于所有现态最小项 $Q_{1}=1,Q_{0}=0$，$Q_{1}^{+}=1$。这产生项 $Q_{1}Q_{0}'$。\n- 从 $11$ 状态，当 $S=1$ 时：$11\\to 11$，所以 $Q_{1}^{+}=1$。这产生项 $Q_{1}Q_{0}S$。\n将项 $Q_{1}'Q_{0}ST$ 和 $Q_{1}Q_{0}ST$ (包含在 $Q_{1}Q_{0}S$ 中) 合并，得到 $Q_{0}ST$。\n因此，\n$$\nD_{1}=Q_{1}Q_{0}'+Q_{1}Q_{0}S+Q_{0}ST.\n$$\n\n其次，$D_{0}=1$ 的条件是次态满足 $Q_{0}^{+}=1$。列举各种情况：\n- 从 $00$ 状态，当 $S=1$ 时：$00\\to 01$，所以 $Q_{0}^{+}=1$。这产生项 $Q_{1}'Q_{0}'S$。\n- 从 $01$ 状态，当 $T=0$ 时：$01\\to 01$，所以无论 $S$ 如何，$Q_{0}^{+}=1$。这产生项 $Q_{1}'Q_{0}T'$。\n- 从 $10$ 状态：$10\\to 11$，因此对于所有现态最小项 $Q_{1}=1,Q_{0}=0$，$Q_{0}^{+}=1$。这产生项 $Q_{1}Q_{0}'$。\n- 从 $11$ 状态，当 $S=1$ 时：$11\\to 11$，所以 $Q_{0}^{+}=1$。这产生项 $Q_{1}Q_{0}S$。\n因此，\n$$\nD_{0}=Q_{1}Q_{0}'+Q_{1}'Q_{0}T'+Q_{1}'Q_{0}'S+Q_{1}Q_{0}S.\n$$\n\n最后，去抖动输出 $Z$ 必须只在 PULSE 状态 $S2$ ($Q_{1}Q_{0}=10$) 下有效，因此\n$$\nZ=Q_{1}Q_{0}'.\n$$\n\n与选项比较，这些表达式与选项 A 完全匹配。", "answer": "$$\\boxed{A}$$", "id": "1957151"}, {"introduction": "ASM是像处理器这样复杂数字系统中控制单元的核心。这个高级问题 [@problem_id:1908116] 要求你为一个执行算术除法的硬件单元设计控制器。重点在于通过发出一系列精确的控制信号来协调一个由寄存器、移位寄存器和算术逻辑单元（ALU）组成的数据通路。这个练习将加深你对控制单元如何与数据通路交互的理解，以及在一个复杂的多周期算法中，摩尔型和米利（Mealy）型输出之间的重要区别。", "problem": "你的任务是为一个专用硬件单元设计一个控制器，该硬件单元使用多周期不恢复余数除法算法，对两个 $N$ 位无符号整数（一个被除数和一个除数）进行除法运算。\n\n**数据通路与控制信号：**\n由你的算法状态机 (ASM) 控制的数据通路包括一个 ($N$+1) 位寄存器 `A`（累加器，初始化为零）、一个 $N$ 位移位寄存器 `Q`（用于存放被除数/商）、一个 $N$ 位寄存器 `M`（用于存放除数）和一个 $N$ 位递减计数器 `n`。控制器接收以下状态输入：\n- `start`：启动除法过程的单周期信号。\n- `n_zero`：当计数器 `n` 为零时为高电平的信号。\n- `A_sign`：寄存器 `A` 的最高有效位 (MSB)，表示其符号（0 为正，1 为负）。\n\n控制器必须生成以下控制信号：\n- `Init_Cycle`：在单个周期内执行初始化任务的信号。\n- `n_dec`：将计数器 `n` 减一。\n- `AQ_shift_left`：对级联寄存器 `{A, Q}` 执行 1 位逻辑左移。\n- `A_load_from_ALU`：将数据通路的算术逻辑单元 (ALU) 的输出加载到寄存器 `A`。\n- `ALU_op_is_add`：用于 ALU 的信号。如果为高电平，ALU 计算 `A + M`；如果为低电平，则计算 `A - M`。\n- `Q0_write_enable`：使能 `Q` 的最低有效位 `Q[0]` 进行更新。当此信号有效时，数据通路硬件设定将值 `NOT(ALU_output_sign)` 写入 `Q[0]`。\n- `A_load_correction`：用于在最终校正步骤中将 `A + M` 的结果加载到寄存器 `A` 的信号。\n- `Done`：算法完成时置位的信号。\n\n**算法规范：**\n控制器必须实现以下多周期算法：\n1.  **空闲阶段：** 控制器在 `IDLE` 状态下等待，直到 `start` 信号被置位。\n2.  **初始化周期：** 收到 `start` 后，控制器转换到 `INIT` 状态一个周期，并置位 `Init_Cycle` 信号。该信号使数据通路将 `A` 加载为 0，`Q` 加载为被除数，`M` 加载为除数，计数器 `n` 加载为 $N$。\n3.  **迭代循环（每位 2 个周期）：** 然后控制器进入一个重复 $N$ 次的循环。每次迭代包括两个连续的周期（两个状态）：\n    a. **移位周期：** `{A, Q}` 寄存器左移一位，计数器 `n` 递减。\n    b. **ALU 周期：** 根据移位后 `A` 的符号 (`A_sign`)，执行一次 ALU 操作，并将结果存回 `A`。具体来说，如果 `A_sign` 为 0，则操作为 `A - M`。如果 `A_sign` 为 1，则操作为 `A + M`。同时，将新的商位写入 `Q[0]`。\n4.  **校正周期：** $N$ 次迭代后（当 `n_zero` 为高电平时检测到），控制器检查 `A` 中最终余数的符号。如果 `A` 为负 (`A_sign = 1`)，则执行一个单周期校正步骤，其中 `A` 更新为 `A + M`。如果 `A` 为非负，则跳过此周期。\n5.  **完成阶段：** 控制器将 `Done` 信号置位一个周期，然后返回 `IDLE` 状态。\n\n**问题：**\n对于一个根据这些规范设计的最小化 ASM 控制器，请识别出在对应于算法 **ALU 周期**（步骤 3b）的状态中，作为 **Moore 输出** 被置位的完整控制信号集合。Moore 输出是一个仅根据处于特定状态而被置位的控制信号，并且与在该周期内评估的状态输入（`start`、`n_zero`、`A_sign`）无关。\n\nA. `{AQ_shift_left, n_dec}`\nB. `{A_load_from_ALU, Q0_write_enable}`\nC. `{n_dec, A_load_from_ALU}`\nD. `{A_load_from_ALU, Q0_write_enable, ALU_op_is_add}`\nE. `{A_load_correction}`", "solution": "我们必须确定在 ALU 周期状态（步骤 3b）下，哪些控制信号被置位纯粹是因为控制器处于该状态，即作为 Moore 输出，且与状态输入的当前值无关。\n\n根据算法，ALU 周期在每次迭代中执行以下操作：\n- 对 $A$ 和 $M$ 进行一次 ALU 操作，该操作根据 $A\\_{sign}$ 选择：如果 $A\\_{sign}=0$，计算 $A - M$；如果 $A\\_{sign}=1$，计算 $A + M$。\n- 将结果加载回 $A$。\n- 同时，通过使能 $Q0\\_write\\_enable$ 将新的商位写入 $Q[0]$；当使能时，数据通路硬件设定会写入 $\\operatorname{NOT}(\\text{ALU\\_output\\_sign})$。\n\n由此可知，在每个 ALU 周期中，无论 $A\\_{sign}$、$n\\_{zero}$ 或 $start$ 的值如何，都必须置位的信号是：\n- $A\\_{load\\_from\\_ALU}$: 在此周期中，需要将 ALU 结果存入 $A$，对于每次迭代的 ALU 阶段都是无条件执行的。\n- $Q0\\_{write\\_enable}$: 在此周期中，需要写入商位，对于每次迭代的 ALU 阶段都是无条件执行的。\n\n信号 $ALU\\_{op\\_is\\_add}$ 由同一周期内的 $A\\_{sign}$ 决定（它在 $A+M$ 和 $A-M$ 之间进行选择），因此它不是 Moore 输出；它是一个依赖于 Mealy 的控制。信号 $AQ\\_{shift\\_left}$ 和 $n\\_{dec}$ 属于移位周期，而不属于 ALU 周期。信号 $A\\_{load\\_correction}$ 仅属于最终的校正周期。这些信号都不是仅因处于 ALU 周期状态而被置位。\n\n因此，在 ALU 周期中置位的 Moore 输出的完整集合恰好是 $\\{A\\_{load\\_from\\_ALU}, Q0\\_{write\\_enable}\\}$，这对应于选项 B。", "answer": "$$\\boxed{B}$$", "id": "1908116"}]}