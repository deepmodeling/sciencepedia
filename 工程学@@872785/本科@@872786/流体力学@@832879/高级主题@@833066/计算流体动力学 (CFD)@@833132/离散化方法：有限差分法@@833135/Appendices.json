{"hands_on_practices": [{"introduction": "将描述物理现象的微分方程转化为计算机可以求解的代数方程组，是有限差分法的核心步骤。本练习将引导你处理一个基本而重要的模型——一维稳态对流扩散方程，它同时包含了流体输运（对流）和物质扩散两个过程。通过这个实践，你将学会如何为方程中具有不同物理特性的项选择合适的离散格式，例如为对流项选择迎风格式，为扩散项选择中心差分格式，这是计算流体力学中的一项基本技能 [@problem_id:1749174]。", "problem": "考虑在具有均匀单向流体流动的窄通道中，化学物质的一维稳态输运。该物质的浓度，用 $\\phi(x)$ 表示，由对流扩散方程控制：\n$$u \\frac{d\\phi}{dx} - D \\frac{d^2\\phi}{dx^2} = 0$$\n其中，$u$ 是沿x轴的恒定正流体速度，$D$ 是恒定的扩散系数。\n\n为了数值求解该方程，空间域被离散化为一个均匀网格，网格间距为常数 $\\Delta x$。网格节点 $i$ 处的浓度值用 $\\phi_i$ 表示。\n\n建立了一个数值模型，对流项 ($u \\frac{d\\phi}{dx}$) 采用一阶迎风差分格式，扩散项 ($-D \\frac{d^2\\phi}{dx^2}$) 采用二阶中心差分格式。\n\n通过在内部网格节点 $i$ 上应用这些离散格式，得到的代数方程可以重排为 $A \\phi_i = B \\phi_{i-1} + C \\phi_{i+1}$ 的形式。以下哪个选项正确表示了这个有限差分方程？\n\nA. $(2D - u \\Delta x) \\phi_i = D \\phi_{i-1} + (D - u \\Delta x) \\phi_{i+1}$\n\nB. $4D \\phi_i = (2D + u \\Delta x) \\phi_{i-1} + (2D - u \\Delta x) \\phi_{i+1}$\n\nC. $(u \\Delta x + 2D) \\phi_i = (u \\Delta x + D) \\phi_{i-1} + D \\phi_{i+1}$\n\nD. $(u \\Delta x + D) \\phi_i = (u \\Delta x + D) \\phi_{i-1}$\n\nE. $(u \\Delta x - 2D) \\phi_i = (u \\Delta x - D) \\phi_{i-1} - D \\phi_{i+1}$", "solution": "目标是将给定的一维稳态对流扩散方程进行离散化，并将其重排为指定的代数形式。\n\n控制微分方程为：\n$$u \\frac{d\\phi}{dx} - D \\frac{d^2\\phi}{dx^2} = 0$$\n\n空间域以均匀间距 $\\Delta x$ 进行离散化，使得节点 $i$ 处的浓度为 $\\phi_i$，其西侧相邻节点的浓度为 $\\phi_{i-1}$，东侧相邻节点的浓度为 $\\phi_{i+1}$。\n\n首先，我们对对流（或平流）项 $u \\frac{d\\phi}{dx}$ 进行离散化。题目指定采用一阶迎风差分格式。由于速度 $u$ 为正，流动方向为x轴正方向。因此，对于节点 $i$ ，“迎风”方向是流体来源的方向，即节点 $i-1$。这对应于一阶后向差分格式。\n$$u \\frac{d\\phi}{dx} \\bigg|_i \\approx u \\frac{\\phi_i - \\phi_{i-1}}{\\Delta x}$$\n\n接下来，我们对扩散项 $-D \\frac{d^2\\phi}{dx^2}$ 进行离散化。题目指定对二阶导数采用二阶中心差分格式。\n$$\\frac{d^2\\phi}{dx^2} \\bigg|_i \\approx \\frac{\\phi_{i+1} - 2\\phi_i + \\phi_{i-1}}{(\\Delta x)^2}$$\n因此，离散化后的扩散项为：\n$$-D \\frac{d^2\\phi}{dx^2} \\bigg|_i \\approx -D \\frac{\\phi_{i+1} - 2\\phi_i + \\phi_{i-1}}{(\\Delta x)^2}$$\n\n现在，我们将这些离散形式代入回原始的控制方程中：\n$$u \\frac{\\phi_i - \\phi_{i-1}}{\\Delta x} - D \\frac{\\phi_{i+1} - 2\\phi_i + \\phi_{i-1}}{(\\Delta x)^2} = 0$$\n\n为了简化并消除分母，我们将整个方程乘以 $(\\Delta x)^2$：\n$$(\\Delta x)^2 \\left( u \\frac{\\phi_i - \\phi_{i-1}}{\\Delta x} \\right) - (\\Delta x)^2 \\left( D \\frac{\\phi_{i+1} - 2\\phi_i + \\phi_{i-1}}{(\\Delta x)^2} \\right) = 0$$\n$$u \\Delta x (\\phi_i - \\phi_{i-1}) - D (\\phi_{i+1} - 2\\phi_i + \\phi_{i-1}) = 0$$\n\n现在，我们展开这些项：\n$$u \\Delta x \\phi_i - u \\Delta x \\phi_{i-1} - D \\phi_{i+1} + 2D \\phi_i - D \\phi_{i-1} = 0$$\n\n最后一步是将此方程重排为 $A \\phi_i = B \\phi_{i-1} + C \\phi_{i+1}$ 的形式。我们将所有包含 $\\phi_i$ 的项归到左侧，所有其他项归到右侧。\n\n合并包含 $\\phi_i$ 的项：\n$$(u \\Delta x + 2D) \\phi_i$$\n\n合并包含 $\\phi_{i-1}$ 和 $\\phi_{i+1}$ 的项并将它们移到右侧：\n$$u \\Delta x \\phi_{i-1} + D \\phi_{i-1} + D \\phi_{i+1}$$\n$$(u \\Delta x + D) \\phi_{i-1} + D \\phi_{i+1}$$\n\n令左右两边相等，得到最终重排的代数方程：\n$$(u \\Delta x + 2D) \\phi_i = (u \\Delta x + D) \\phi_{i-1} + D \\phi_{i+1}$$\n\n将此结果与给定选项进行比较：\nA. $(2D - u \\Delta x) \\phi_i = D \\phi_{i-1} + (D - u \\Delta x) \\phi_{i+1}$ (不正确，这是对流项使用前向差分的结果)\nB. $4D \\phi_i = (2D + u \\Delta x) \\phi_{i-1} + (2D - u \\Delta x) \\phi_{i+1}$ (不正确，这是对流项使用中心差分的结果)\nC. $(u \\Delta x + 2D) \\phi_i = (u \\Delta x + D) \\phi_{i-1} + D \\phi_{i+1}$ (正确)\nD. $(u \\Delta x + D) \\phi_i = (u \\Delta x + D) \\phi_{i-1}$ (不正确，缺少扩散项和 $\\phi_{i+1}$)\nE. $(u \\Delta x - 2D) \\phi_i = (u \\Delta x - D) \\phi_{i-1} - D \\phi_{i+1}$ (不正确，处理扩散项时出现符号错误)\n\n因此，正确选项是C。", "answer": "$$\\boxed{C}$$", "id": "1749174"}, {"introduction": "在真实的工程和科学问题中，为了高效地捕捉局部剧烈变化的区域（如边界层或激波），我们往往需要使用非均匀网格。本练习旨在让你掌握如何在非均匀网格上构造高精度的差分格式，这是将有限差分法应用于复杂问题的关键一步。通过为非均匀网格上的压力梯度推导一个二阶精度的表达式，你将学到一种更通用、更强大的离散化方法，从而能够处理更具挑战性的实际问题 [@problem_id:1749171]。", "problem": "在开发一维流体流动的数值求解器时，一项常见任务是评估作为流体驱动力的压力梯度。考虑这样一种情景：压力场 $p(x)$ 仅在非均匀计算网格上的一系列离散点上是已知的。我们感兴趣的是，在位于位置 $x_i$ 的特定网格点（节点）$i$ 处，求取压力梯度的高保真度近似。该节点的压力为 $p_i$。相邻节点为位于位置 $x_{i-1}$ 的节点 $i-1$（压力为 $p_{i-1}$）和位于位置 $x_{i+1}$ 的节点 $i+1$（压力为 $p_{i+1}$）。网格间距不是恒定的，因此通常情况下，$x_{i+1} - x_i \\neq x_i - x_{i-1}$。\n\n您的任务是推导在位置 $x_i$ 处压力梯度 $\\frac{dp}{dx}$ 的二阶精确有限差分近似。将您的最终答案表示为以给定的网格点位置 $x_{i-1}$、$x_i$、$x_{i+1}$ 和相应的压力值 $p_{i-1}$、$p_i$、$p_{i+1}$ 表示的解析表达式。", "solution": "我们寻求在非均匀网格上使用三个点 $(x_{i-1},p_{i-1})$、$(x_{i},p_{i})$ 和 $(x_{i+1},p_{i+1})$ 对 $\\left.\\frac{dp}{dx}\\right|_{x_{i}}$ 进行二阶精确近似。令 $h_{-}=x_{i}-x_{i-1}$ 且 $h_{+}=x_{i+1}-x_{i}$。构建二次 Lagrange 插值 $p(x)\\approx \\sum_{j\\in\\{i-1,i,i+1\\}} p_{j} L_{j}(x)$，其中\n$$\nL_{i-1}(x)=\\frac{(x-x_{i})(x-x_{i+1})}{(x_{i-1}-x_{i})(x_{i-1}-x_{i+1})},\\quad\nL_{i}(x)=\\frac{(x-x_{i-1})(x-x_{i+1})}{(x_{i}-x_{i-1})(x_{i}-x_{i+1})},\\quad\nL_{i+1}(x)=\\frac{(x-x_{i-1})(x-x_{i})}{(x_{i+1}-x_{i-1})(x_{i+1}-x_{i})}.\n$$\n于是\n$$\n\\left.\\frac{dp}{dx}\\right|_{x_{i}} \\approx p_{i-1} L_{i-1}'(x_{i})+p_{i} L_{i}'(x_{i})+p_{i+1} L_{i+1}'(x_{i}).\n$$\n对每个基函数求导，并在 $x=x_{i}$ 处求值。使用等式 $x_{i-1}-x_{i}=-h_{-}$，$x_{i-1}-x_{i+1}=-(h_{-}+h_{+})$，$x_{i}-x_{i-1}=h_{-}$，$x_{i}-x_{i+1}=-h_{+}$，$x_{i+1}-x_{i-1}=h_{-}+h_{+}$ 和 $x_{i+1}-x_{i}=h_{+}$，我们得到\n$$\nL_{i-1}'(x_{i})=-\\frac{h_{+}}{h_{-}(h_{-}+h_{+})},\\quad\nL_{i}'(x_{i})=\\frac{h_{+}-h_{-}}{h_{-}h_{+}},\\quad\nL_{i+1}'(x_{i})=\\frac{h_{-}}{h_{+}(h_{-}+h_{+})}.\n$$\n因此，\n$$\n\\left.\\frac{dp}{dx}\\right|_{x_{i}} \\approx -\\frac{h_{+}}{h_{-}(h_{-}+h_{+})}p_{i-1}+\\frac{h_{+}-h_{-}}{h_{-}h_{+}}p_{i}+\\frac{h_{-}}{h_{+}(h_{-}+h_{+})}p_{i+1}.\n$$\n将 $h_{-}=x_{i}-x_{i-1}$ 和 $h_{+}=x_{i+1}-x_{i}$ 代回，即可得到以网格位置表示的所求表达式：\n$$\n\\left.\\frac{dp}{dx}\\right|_{x_{i}} \\approx -\\frac{x_{i+1}-x_{i}}{(x_{i}-x_{i-1})(x_{i+1}-x_{i-1})}p_{i-1}+\\frac{(x_{i+1}-x_{i})-(x_{i}-x_{i-1})}{(x_{i}-x_{i-1})(x_{i+1}-x_{i})}p_{i}+\\frac{x_{i}-x_{i-1}}{(x_{i+1}-x_{i})(x_{i+1}-x_{i-1})}p_{i+1}.\n$$\n因为这是通过这三个节点的二次 Lagrange 插值的导数，所以在光滑场上，其截断误差为 $O(h^{2})$，从而在非均匀网格上提供了一个二阶精确的近似。", "answer": "$$\\boxed{-\\frac{x_{i+1}-x_{i}}{(x_{i}-x_{i-1})(x_{i+1}-x_{i-1})}p_{i-1}+\\frac{(x_{i+1}-x_{i})-(x_{i}-x_{i-1})}{(x_{i}-x_{i-1})(x_{i+1}-x_{i})}p_{i}+\\frac{x_{i}-x_{i-1}}{(x_{i+1}-x_{i})(x_{i+1}-x_{i-1})}p_{i+1}}$$", "id": "1749171"}, {"introduction": "一个完整的数值求解过程不仅包括对控制方程内部点的离散，还必须精确地处理边界条件。本项高级练习将带你深入探索并比较处理导数（Neumann）边界条件的两种常用方法。通过编写代码来求解一个完整的边值问题，你将对比“虚拟网格点”（ghost point）方法和“单侧差分”（one-sided difference）方法的精度差异，并学习如何通过数值实验来验证算法的收敛阶。这个过程模拟了计算程序开发与验证的核心环节，是从理论学习迈向实际应用的重要一步 [@problem_id:2392721]。", "problem": "考虑在闭区间 $[0,1]$ 上的一维、线性、二阶边值问题，其形式如下：\n$$-u''(x) = f(x), \\quad x \\in (0,1),$$\n其满足以下混合边界条件：\n$$u'(0) = g, \\qquad u(1) = \\beta.$$\n假设一个精确且足够光滑的解 $u(x)$ 是先验已知的，并且 $f(x)$、$g$ 和 $\\beta$ 由该精确解一致地定义。\n\n您的任务是编写一个完整的、可运行的程序。对于下面列出的每个测试用例，该程序需要构建一个均匀网格 $x_j = j h$（其中 $h = 1/N$，$j = 0,1,\\dots,N$ 且 $N \\in \\{20,40,80,160\\}$），使用内部算子 $-u''(x)$ 的标准二阶中心有限差分离散化来近似解，并以两种不同的、均达到二阶精度的方式实现 $x=0$ 处的诺伊曼边界条件：\n- 方法 A：使用一个位于域外的辅助未知量来施加诺伊曼条件，以实现二阶精度的边界处理。\n- 方法 B：使用一个仅由域内节点支持且能达到二阶精度的边界近似来施加诺伊曼条件。\n\n在这两种方法中，都直接使用 $x=1$ 处的狄利克雷边界条件 $u(1)=\\beta$。对于每种方法和每个 $N$，计算其最大范数误差：\n$$E_\\infty(h) = \\max_{0 \\le j \\le N} \\left| u_h(x_j) - u(x_j) \\right|,$$\n其中 $u_h(x_j)$ 表示在节点 $x_j$ 处的数值近似解。然后，对于每种方法，通过对所有 $N$ 值的数据对 $(h, E_\\infty(h))$ 进行模型 $E_\\infty(h) \\approx C h^p$ 拟合，来估计观测到的精度阶 $p$。该拟合在 $\\log E_\\infty$ 对 $\\log h$ 的关系上使用普通最小二乘法 (OLS) 完成。请一致地使用自然对数或以 10 为底的对数；估计的指数 $p$ 必须是拟合出的斜率。对于下文中的三角函数，角度应以弧度为单位进行解释。\n\n使用以下三个测试用例，每个用例均由一个精确解 $u(x)$、对应的强制项 $f(x) = -u''(x)$、诺伊曼数据 $g = u'(0)$ 和狄利克雷数据 $\\beta = u(1)$ 所定义：\n- 测试 1 (光滑指数函数)：$u(x) = \\mathrm{e}^{x}$，因此 $f(x) = -\\mathrm{e}^{x}$，$g = 1$，$\\beta = \\mathrm{e}$。\n- 测试 2 (零通量双曲余弦)：$u(x) = \\cosh(x)$，因此 $f(x) = -\\cosh(x)$，$g = 0$，$\\beta = \\cosh(1)$。\n- 测试 3 (振荡仿射)：$u(x) = \\sin(2\\pi x) + x$，因此 $f(x) = 4\\pi^2 \\sin(2\\pi x)$，$g = 2\\pi + 1$，$\\beta = 1$。\n\n对于每个测试用例，报告三个实数：\n- 方法 A 的估计阶数 $p_A$，\n- 方法 B 的估计阶数 $p_B$，\n- 误差比 $R = E_{\\infty,A}(h_{\\min}) / E_{\\infty,B}(h_{\\min})$，其中对于两种方法，$h_{\\min}$ 都对应于 $N=160$。\n\n最终输出格式：您的程序应生成单行输出，其中包含三个测试的所有结果，形式为方括号内以逗号分隔的十进制数列表。数字必须按 $[p_A^{(1)}, p_B^{(1)}, R^{(1)}, p_A^{(2)}, p_B^{(2)}, R^{(2)}, p_A^{(3)}, p_B^{(3)}, R^{(3)}]$ 的顺序排列，其中上标表示测试用例的索引。每个数值必须打印并四舍五入到小数点后恰好六位。不应打印任何额外文本。\n\n本问题中不涉及物理单位。所有角度都必须以弧度为单位进行解释。", "solution": "用户要求使用有限差分法求解一个一维、线性、二阶边值问题 (BVP)。该问题在区间 $[0,1]$ 上求解：\n$$ -u''(x) = f(x), \\quad x \\in (0,1) $$\n其混合边界条件为：\n$$ u'(0) = g, \\quad u(1) = \\beta $$\n解决方案包括对求解域和微分算子进行离散化，使用两种不同的方法以二阶精度实现边界条件，针对几种不同的网格分辨率计算与已知精确解的误差，并估计精度阶。\n\n求解域 $[0,1]$ 通过一个包含 $N+1$ 个点的均匀网格进行离散化，点为 $x_j = j h$，$j = 0, 1, \\dots, N$，其中步长 $h = 1/N$。数值解是在这些网格点上的值的向量 $u_j \\approx u(x_j)$。根据狄利克雷边界条件，值 $u_N = u(x_N) = u(1) = \\beta$ 是已知的。未知量是 $N$ 个值 $u_0, u_1, \\dots, u_{N-1}$。\n\n在内部网格点 $x_j$（$j=1, \\dots, N-1$），二阶导数 $-u''(x)$ 使用二阶精度的中心有限差分格式来近似：\n$$ -u''(x_j) \\approx -\\frac{u(x_{j-1}) - 2u(x_j) + u(x_{j+1})}{h^2} $$\n将此离散化应用于每个内部点 $x_j$ 处的微分方程，得到一组线性方程：\n$$ -\\frac{u_{j-1} - 2u_j + u_{j+1}}{h^2} = f(x_j) \\equiv f_j $$\n可以重排为：\n$$ -u_{j-1} + 2u_j - u_{j+1} = h^2 f_j $$\n这些是关于 $j=1, \\dots, N-1$ 的 $N-1$ 个方程。对于 $j=N-1$ 的方程涉及已知值 $u_N=\\beta$：\n$$ -u_{N-2} + 2u_{N-1} - u_N = h^2 f_{N-1} \\implies -u_{N-2} + 2u_{N-1} = h^2 f_{N-1} + \\beta $$\n此方程的右侧通过移项已知项 $\\beta$ 而被修改。为了形成一个关于 $N$ 个未知数的 $N$ 个方程的完整系统，需要在左边界 $x_0=0$ 处增加一个从诺伊曼条件 $u'(0)=g$ 导出的额外方程。为此指定了两种方法。\n\n**方法 A：鬼点离散化**\n该方法在域外引入一个“鬼点” (ghost point) $x_{-1} = -h$。诺伊曼条件 $u'(0) = g$ 使用关于 $x_0$ 的二阶中心差分进行离散化：\n$$ u'(0) \\approx \\frac{u_1 - u_{-1}}{2h} = g \\implies u_{-1} = u_1 - 2hg $$\n假设微分方程在边界点 $x_0=0$ 处也成立。应用中心差分格式来计算 $-u''(0)$，得到：\n$$ -\\frac{u_{-1} - 2u_0 + u_1}{h^2} = f_0 $$\n将鬼点值 $u_{-1}$ 的表达式代入此方程以消去它：\n$$ -\\frac{(u_1 - 2hg) - 2u_0 + u_1}{h^2} = f_0 \\implies 2u_0 - 2u_1 = h^2 f_0 - 2hg $$\n这构成了线性系统的第一个方程。\n\n**方法 B：单边离散化**\n该方法通过对诺伊曼条件使用一个二阶精度的单边差分公式来避免使用域外的点。使用一个涉及 $u_0, u_1, u_2$ 的前向差分格式：\n$$ u'(0) \\approx \\frac{-3u_0 + 4u_1 - u_2}{2h} = g $$\n此近似由泰勒级数展开推导而来，其截断误差为 $O(h^2)$ 阶。重排后直接得到线性系统的第一个方程：\n$$ -3u_0 + 4u_1 - u_2 = 2hg $$\n注意，这个方程取代了在 $x_0=0$ 处的离散化偏微分方程 (PDE)。\n\n**线性系统与求解**\n对于这两种方法，我们都构建一个 $N \\times N$ 的线性系统，其形式为 $A \\mathbf{u} = \\mathbf{b}$，其中 $\\mathbf{u} = [u_0, u_1, \\dots, u_{N-1}]^T$。\n\n对于方法 A，该系统为：\n$$\n\\begin{pmatrix}\n2  -2    \\\\\n-1  2  -1   \\\\\n \\ddots  \\ddots  \\ddots  \\\\\n  -1  2  -1 \\\\\n   -1  2\n\\end{pmatrix}\n\\begin{pmatrix} u_0 \\\\ u_1 \\\\ \\vdots \\\\ u_{N-2} \\\\ u_{N-1} \\end{pmatrix} =\n\\begin{pmatrix} h^2 f_0 - 2hg \\\\ h^2 f_1 \\\\ \\vdots \\\\ h^2 f_{N-2} \\\\ h^2 f_{N-1} + \\beta \\end{pmatrix}\n$$\n\n对于方法 B，该系统为：\n$$\n\\begin{pmatrix}\n-3  4  -1   \\\\\n-1  2  -1   \\\\\n \\ddots  \\ddots  \\ddots  \\\\\n  -1  2  -1 \\\\\n   -1  2\n\\end{pmatrix}\n\\begin{pmatrix} u_0 \\\\ u_1 \\\\ \\vdots \\\\ u_{N-2} \\\\ u_{N-1} \\end{pmatrix} =\n\\begin{pmatrix} 2hg \\\\ h^2 f_1 \\\\ \\vdots \\\\ h^2 f_{N-2} \\\\ h^2 f_{N-1} + \\beta \\end{pmatrix}\n$$\n使用标准的线性求解器求解该系统以得到 $\\mathbf{u}$。完整的数值解即为 $\\mathbf{u}_h = [u_0, \\dots, u_{N-1}, \\beta]^T$。\n\n**误差分析与精度阶**\n对每个网格尺寸 $h$ 计算最大范数误差：\n$$ E_\\infty(h) = \\max_{0 \\le j \\le N} \\left| u_j - u(x_j) \\right| $$\n理论误差关系为 $E_\\infty(h) \\approx C h^p$，其中 $p$ 是精度阶。为了估计 $p$，我们对此模型的对数变换形式执行线性回归：\n$$ \\log(E_\\infty(h)) \\approx \\log(C) + p \\log(h) $$\n对数据点 $(\\log(h), \\log(E_\\infty(h)))$（其中 $N \\in \\{20, 40, 80, 160\\}$）进行拟合所得的回归线的斜率，即为估计的精度阶 $p$。这通过普通最小二乘法 (OLS) 实现。程序使用 `numpy.polyfit` 函数（阶数为 1）来计算此斜率。\n\n程序为三个测试用例中的每一个都实现了此过程，分别计算方法 A 和方法 B 的估计阶数 $p_A$ 和 $p_B$，并在最细的网格分辨率 ($N=160$) 下计算两种方法的误差之比 $R$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve_bvp(N, u_exact_func, f_func, g, beta, method):\n    \"\"\"\n    Solves the BVP for a given N and method.\n    Returns the maximum-norm error.\n    \"\"\"\n    h = 1.0 / N\n    # Grid for unknowns u_0 to u_{N-1}\n    x_unknowns = np.linspace(0, 1.0 - h, N)\n    f_vals = f_func(x_unknowns)\n\n    # Initialize matrix A and vector b for the system A*u = b\n    A = np.zeros((N, N))\n    b = np.zeros(N)\n\n    # --- Construct the linear system ---\n\n    # Fill interior rows (j=1 to N-2) based on the centered difference stencil\n    # -u_{j-1} + 2u_j - u_{j+1} = h^2 * f_j\n    for j in range(1, N - 1):\n        A[j, j-1] = -1.0\n        A[j, j]   = 2.0\n        A[j, j+1] = -1.0\n        b[j]      = h**2 * f_vals[j]\n\n    # Equation for j=N-1 (near Dirichlet boundary)\n    # -u_{N-2} + 2u_{N-1} = h^2 * f_{N-1} + beta\n    if N > 1:\n        A[N-1, N-2] = -1.0\n    A[N-1, N-1] = 2.0\n    b[N-1] = h**2 * f_vals[N-1] + beta\n\n    # Equation for j=0 (Neumann boundary)\n    if method == 'A':\n        # Ghost point method: 2u_0 - 2u_1 = h^2*f_0 - 2*h*g\n        A[0, 0] = 2.0\n        if N > 1:\n            A[0, 1] = -2.0\n        b[0] = h**2 * f_vals[0] - 2.0 * h * g\n        # For N > 1, the j=1 equation is standard\n        if N > 1:\n            A[1, 0] = -1.0\n            A[1, 1] = 2.0\n            if N > 2:\n                A[1, 2] = -1.0\n            b[1] = h**2 * f_vals[1]\n\n    elif method == 'B':\n        # One-sided 2nd order method: -3u_0 + 4u_1 - u_2 = 2*h*g\n        A[0, 0] = -3.0\n        if N > 1:\n            A[0, 1] = 4.0\n        if N > 2:\n            A[0, 2] = -1.0\n        b[0] = 2.0 * h * g\n        # For N > 1, the j=1 equation is standard\n        if N > 1:\n            A[1, 0] = -1.0\n            A[1, 1] = 2.0\n            if N > 2:\n                A[1, 2] = -1.0\n            b[1] = h**2 * f_vals[1]\n\n    # --- Solve and compute error ---\n    \n    u_numeric_part = np.linalg.solve(A, b)\n    u_numeric = np.append(u_numeric_part, beta)\n\n    # Full grid from x_0 = 0 to x_N = 1\n    x_full = np.linspace(0, 1, N + 1)\n    u_exact_vals = u_exact_func(x_full)\n\n    error = np.max(np.abs(u_numeric - u_exact_vals))\n    return error\n\ndef solve_one_case(test_case_def):\n    \"\"\"\n    Processes one test case for all N values and both methods.\n    Returns p_A, p_B, R.\n    \"\"\"\n    u_exact_func, f_func, g, beta = test_case_def\n    \n    N_vals = np.array([20, 40, 80, 160])\n    h_vals = 1.0 / N_vals\n    \n    errors_A = []\n    errors_B = []\n    \n    for N in N_vals:\n        errors_A.append(solve_bvp(N, u_exact_func, f_func, g, beta, 'A'))\n        errors_B.append(solve_bvp(N, u_exact_func, f_func, g, beta, 'B'))\n\n    # Use OLS on log-log data to find order of accuracy p\n    log_h_vals = np.log(h_vals)\n    log_errors_A = np.log(errors_A)\n    log_errors_B = np.log(errors_B)\n    \n    p_A, _ = np.polyfit(log_h_vals, log_errors_A, 1)\n    p_B, _ = np.polyfit(log_h_vals, log_errors_B, 1)\n    \n    # Error ratio at the finest grid\n    R = errors_A[-1] / errors_B[-1]\n    \n    return p_A, p_B, R\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test 1: u(x) = exp(x)\n        (lambda x: np.exp(x), lambda x: -np.exp(x), 1.0, np.exp(1.0)),\n        # Test 2: u(x) = cosh(x)\n        (lambda x: np.cosh(x), lambda x: -np.cosh(x), 0.0, np.cosh(1.0)),\n        # Test 3: u(x) = sin(2*pi*x) + x\n        (lambda x: np.sin(2*np.pi*x) + x, lambda x: 4*np.pi**2*np.sin(2*np.pi*x), 2*np.pi + 1, 1.0)\n    ]\n\n    results = []\n    for case in test_cases:\n        p_A, p_B, R = solve_one_case(case)\n        results.extend([p_A, p_B, R])\n\n    # Final print statement in the exact required format.\n    formatted_results = [f\"{val:.6f}\" for val in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2392721"}]}