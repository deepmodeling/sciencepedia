{"hands_on_practices": [{"introduction": "表面扩散本质上是原子在一系列晶格稳定吸附位点之间的不连续跳跃。为了理解这一过程，我们首先必须量化单次跳跃的速率。本练习 [@problem_id:2791158] 邀请您从基本的统计力学原理出发，推导著名的阿伦尼乌斯关系，将跳跃速率与迁移能垒和温度联系起来。通过计算跳跃速率及其倒数——平均停留时间，您将对表面原子运动的时间尺度建立起基础性的理解。", "problem": "晶体表面上的一个吸附原子处于一个周期性势场中，其中等效的吸附位点被迁移势垒隔开。考虑单个吸附原子在最近邻位点之间进行热激活跳跃。假设以下具有物理动机的基础：(i) 吸附原子在结合阱中的局域振动提供了一个尝试频率，该频率被解释为穿越势垒的无关联尝试的特征速率；(ii) 正则玻尔兹曼分布决定了热涨落提供足够能量以达到势垒的概率；(iii) 穿越势垒事件是无记忆的，因此跳跃的等待时间分布是指数型的。\n\n从这些基础出发，推导跳跃速率作为迁移能垒 $E_{m}$、尝试频率 $\\nu$、玻尔兹曼常数 $k_{B}$ 和温度 $T$ 的函数表达式。根据无记忆性，将平均驻留时间与跳跃速率联系起来。然后，对于一个特征为 $E_{m}=0.35\\,\\mathrm{eV}$、$\\nu=1.0\\times 10^{13}\\,\\mathrm{s^{-1}}$ 和 $T=500\\,\\mathrm{K}$ 的吸附原子，数值计算跳跃速率和平均驻留时间。使用 $k_{B}=8.617333262\\times 10^{-5}\\,\\mathrm{eV\\,K^{-1}}$。\n\n将跳跃速率以 $\\mathrm{s^{-1}}$ 为单位表示，平均驻留时间以 $\\mathrm{s}$ 为单位表示。将两个数值结果均四舍五入至三位有效数字。", "solution": "问题陈述在科学上是合理的且表述清晰。它描述了热激活表面扩散的经典情景，该情景是使用统计力学和动力学的基本原​​理来阐述的。我们将继续进行推导和计算。\n\n首先，我们推导跳跃速率 $\\Gamma$ 的表达式。问题提供了三个物理基础。基础 (i) 给出了尝试频率 $\\nu$，即吸附原子从其局域势阱中尝试穿越能垒的速率。基础 (ii) 使用正则玻尔兹曼分布来定义成功尝试的概率。一次成功的尝试要求吸附原子拥有等于或大于迁移能垒 $E_{m}$ 的热能。此类事件的概率 $P_{\\text{success}}$ 由玻尔兹曼因子给出：\n$$ P_{\\text{success}} = \\exp\\left(-\\frac{E_{m}}{k_{B}T}\\right) $$\n其中 $k_{B}$ 是玻尔兹曼常数，$T$ 是绝对温度。总跳跃速率 $\\Gamma$ 是单位时间内的尝试次数与每次尝试成功的概率的乘积。\n$$ \\Gamma = \\nu \\times P_{\\text{success}} = \\nu \\exp\\left(-\\frac{E_{m}}{k_{B}T}\\right) $$\n这是热激活过程速率的标准阿伦尼乌斯表达式。\n\n接下来，我们将平均驻留时间 $\\tau$ 与跳跃速率 $\\Gamma$ 联系起来。基础 (iii) 指出穿越势垒事件是无记忆的。由无记忆事件构成的过程是泊松过程。对于这样一个平均速率恒为 $\\Gamma$ 的过程，连续事件之间的时间间隔 $t$ 服从指数概率分布，其概率密度函数为 $p(t)$：\n$$ p(t) = \\Gamma \\exp(-\\Gamma t) \\quad \\text{for } t \\ge 0 $$\n平均驻留时间 $\\tau$ 是等待时间 $t$ 的期望值。它通过对所有可能的时间从 $0$ 到 $\\infty$ 积分 $t \\cdot p(t)$ 来计算：\n$$ \\tau = \\langle t \\rangle = \\int_{0}^{\\infty} t \\, p(t) \\, dt = \\int_{0}^{\\infty} t \\, \\Gamma \\exp(-\\Gamma t) \\, dt $$\n我们使用分部积分法求解此积分，令 $u=t$ 且 $dv = \\Gamma \\exp(-\\Gamma t) \\, dt$。这得到 $du=dt$ 和 $v = -\\exp(-\\Gamma t)$。\n$$ \\tau = \\left[ -t \\exp(-\\Gamma t) \\right]_{0}^{\\infty} - \\int_{0}^{\\infty} (-\\exp(-\\Gamma t)) \\, dt $$\n边界项 $\\left[ -t \\exp(-\\Gamma t) \\right]_{0}^{\\infty}$ 在 $t=0$ 和 $t \\to \\infty$ 时均等于 $0$。表达式简化为：\n$$ \\tau = \\int_{0}^{\\infty} \\exp(-\\Gamma t) \\, dt = \\left[ -\\frac{1}{\\Gamma}\\exp(-\\Gamma t) \\right]_{0}^{\\infty} = \\left(0\\right) - \\left(-\\frac{1}{\\Gamma}\\exp(0)\\right) = \\frac{1}{\\Gamma} $$\n因此，在吸附位点中的平均驻留时间是跳跃速率的倒数。\n\n最后，我们使用给定值进行数值计算：$E_{m} = 0.35\\,\\mathrm{eV}$，$\\nu = 1.0 \\times 10^{13}\\,\\mathrm{s^{-1}}$，$T = 500\\,\\mathrm{K}$，以及 $k_{B} = 8.617333262 \\times 10^{-5}\\,\\mathrm{eV\\,K^{-1}}$。\n首先，我们计算指数中的无量纲项：\n$$ \\frac{E_{m}}{k_{B}T} = \\frac{0.35}{(8.617333262 \\times 10^{-5}) \\times 500} \\approx 8.12321 $$\n现在我们计算跳跃速率 $\\Gamma$：\n$$ \\Gamma = (1.0 \\times 10^{13}) \\times \\exp(-8.12321) \\approx (1.0 \\times 10^{13}) \\times (2.9653 \\times 10^{-4}) \\approx 2.9653 \\times 10^{9}\\,\\mathrm{s^{-1}} $$\n四舍五入到三位有效数字，跳跃速率为：\n$$ \\Gamma \\approx 2.97 \\times 10^{9}\\,\\mathrm{s^{-1}} $$\n平均驻留时间 $\\tau$ 是 $\\Gamma$ 的倒数：\n$$ \\tau = \\frac{1}{\\Gamma} \\approx \\frac{1}{2.9653 \\times 10^{9}\\,\\mathrm{s^{-1}}} \\approx 3.3723 \\times 10^{-10}\\,\\mathrm{s} $$\n四舍五入到三位有效数字，平均驻留时间为：\n$$ \\tau \\approx 3.37 \\times 10^{-10}\\,\\mathrm{s} $$", "answer": "$$\\boxed{\\begin{pmatrix} 2.97 \\times 10^{9}  3.37 \\times 10^{-10} \\end{pmatrix}}$$", "id": "2791158"}, {"introduction": "虽然单个原子的跳跃是随机的，但它们在时间上的集体效应会导致可预测的宏观扩散现象，这一现象由扩散系数 $D$ 描述。该系数与粒子均方位移的增长直接相关。本实践问题 [@problem_id:2791155] 要求您使用随机行走模型来形式化这种联系。通过推导一个受两种独立迁移机制影响的粒子的有效扩散系数，您将学习到不同微观路径的贡献如何在宏观层面进行叠加。", "problem": "一个吸附原子在平坦、各向同性的晶体平台上通过两种独立的基元机制进行扩散：最近邻跃迁和原子交换。一次跃迁事件使吸附原子在平面内沿一个均匀随机的方向位移一个固定大小为 $a_h$ 的矢量，该过程作为泊松过程发生，速率为 $k_h$（单位时间内的事件数）。一次交换事件使吸附原子在平面内沿一个均匀随机的方向位移一个固定大小为 $a_x$ 的矢量，该过程作为独立的泊松过程发生，速率为 $k_x$。假设没有外部偏压，位移方向独立同分布且均值为零，并且连续事件在机制内部和机制之间都是不相关的。\n\n从二维表面扩散系数的定义出发（即均方位移与时间之间的长时间比例常数），请从第一性原理推导出一个结合了两种机制的有效扩散系数 $D_{\\mathrm{eff}}$ 的精确闭式表达式。您的推导必须明确使用独立泊松过程和不相关随机位移的统计特性来获得均方位移的增长率。\n\n以 $k_h$、$k_x$、$a_h$ 和 $a_x$ 的形式给出一个单一的解析表达式作为您的最终结果。最终表达式中不要包含单位。无需四舍五入。如果进行数值计算，扩散系数应以平方米每秒（即 $\\mathrm{m}^2\\,\\mathrm{s}^{-1}$）为单位报告。", "solution": "所述问题在物理上和数学上都是有效的。这是输运现象统计力学中的一个标准练习，特别是随机行走理论。所有必要的参数和条件都已给出，问题是适定的。我们将继续进行推导。\n\n出发点是二维扩散系数 $D$ 的定义，它在长时间极限下将粒子的均方位移（MSD）与时间 $t$ 联系起来：\n$$ D = \\lim_{t \\to \\infty} \\frac{\\langle |\\vec{r}(t) - \\vec{r}(0)|^2 \\rangle}{4t} $$\n为方便起见，让我们坐标系的原点与吸附原子的初始位置重合，因此 $\\vec{r}(0) = \\vec{0}$。那么，在时间 $t$ 的位移矢量为 $\\vec{R}(t) = \\vec{r}(t)$。因此，有效扩散系数 $D_{\\mathrm{eff}}$ 为：\n$$ D_{\\mathrm{eff}} = \\lim_{t \\to \\infty} \\frac{\\langle |\\vec{R}(t)|^2 \\rangle}{4t} $$\n总位移 $\\vec{R}(t)$ 是在时间间隔 $[0, t]$ 内发生的所有跃迁和交换事件产生的各个位移的矢量和。设 $N_h(t)$ 是此时间间隔内跃迁事件的次数，$N_x(t)$ 是交换事件的次数。设 $\\vec{s}_{h,i}$ 是第 $i$ 次跃迁事件的位移矢量，$\\vec{s}_{x,j}$ 是第 $j$ 次交换事件的位移矢量。总位移为：\n$$ \\vec{R}(t) = \\sum_{i=1}^{N_h(t)} \\vec{s}_{h,i} + \\sum_{j=1}^{N_x(t)} \\vec{s}_{x,j} $$\n我们现在必须计算均方位移 $\\langle |\\vec{R}(t)|^2 \\rangle = \\langle \\vec{R}(t) \\cdot \\vec{R}(t) \\rangle$。期望值 $\\langle \\dots \\rangle$ 表示对所有可能的随机轨迹的平均，这包括对每种类型事件的数量以及每一步的随机方向进行平均。\n$$ \\langle |\\vec{R}(t)|^2 \\rangle = \\left\\langle \\left( \\sum_{i=1}^{N_h(t)} \\vec{s}_{h,i} + \\sum_{j=1}^{N_x(t)} \\vec{s}_{x,j} \\right) \\cdot \\left( \\sum_{k=1}^{N_h(t)} \\vec{s}_{h,k} + \\sum_{l=1}^{N_x(t)} \\vec{s}_{x,l} \\right) \\right\\rangle $$\n展开点积得到四项：\n$$ \\langle |\\vec{R}(t)|^2 \\rangle = \\left\\langle \\sum_{i,k=1}^{N_h(t)} \\vec{s}_{h,i} \\cdot \\vec{s}_{h,k} \\right\\rangle + \\left\\langle \\sum_{j,l=1}^{N_x(t)} \\vec{s}_{x,j} \\cdot \\vec{s}_{x,l} \\right\\rangle + 2\\left\\langle \\sum_{i=1}^{N_h(t)} \\sum_{j=1}^{N_x(t)} \\vec{s}_{h,i} \\cdot \\vec{s}_{x,j} \\right\\rangle $$\n根据问题陈述，所有位移事件都是不相关的。这意味着对于任意两个不同的事件，其点积的期望等于其期望的点积：对于 $(\\alpha, i) \\neq (\\beta, j)$，有 $\\langle \\vec{s}_{\\alpha, i} \\cdot \\vec{s}_{\\beta, j} \\rangle = \\langle \\vec{s}_{\\alpha, i} \\rangle \\cdot \\langle \\vec{s}_{\\beta, j} \\rangle$。\n由于两种过程的步进方向都是均匀随机的，因此任何单一步骤的平均位移都是零矢量：对于所有 $i, j$，都有 $\\langle \\vec{s}_{h,i} \\rangle = \\vec{0}$ 和 $\\langle \\vec{s}_{x,j} \\rangle = \\vec{0}$。\n因此，和式中所有索引不同的交叉项都消失了。例如，在第一项中，对于 $i \\neq k$，有 $\\langle \\vec{s}_{h,i} \\cdot \\vec{s}_{h,k} \\rangle = 0$。这同样适用于第二项。第三项完全消失，因为 $\\langle \\vec{s}_{h,i} \\cdot \\vec{s}_{x,j} \\rangle = \\langle \\vec{s}_{h,i} \\rangle \\cdot \\langle \\vec{s}_{x,j} \\rangle = \\vec{0} \\cdot \\vec{0} = 0$，因为两种机制是独立的。\n因此，MSD 的表达式简化为只包含对角项（$i=k$ 和 $j=l$）：\n$$ \\langle |\\vec{R}(t)|^2 \\rangle = \\left\\langle \\sum_{i=1}^{N_h(t)} |\\vec{s}_{h,i}|^2 + \\sum_{j=1}^{N_x(t)} |\\vec{s}_{x,j}|^2 \\right\\rangle $$\n位移矢量的大小是给定的固定常数：$|\\vec{s}_{h,i}| = a_h$ 和 $|\\vec{s}_{x,j}| = a_x$。因此，$|\\vec{s}_{h,i}|^2 = a_h^2$ 且 $|\\vec{s}_{x,j}|^2 = a_x^2$。\n$$ \\langle |\\vec{R}(t)|^2 \\rangle = \\left\\langle N_h(t) a_h^2 + N_x(t) a_x^2 \\right\\rangle $$\n根据期望算子的线性性质，这变为：\n$$ \\langle |\\vec{R}(t)|^2 \\rangle = a_h^2 \\langle N_h(t) \\rangle + a_x^2 \\langle N_x(t) \\rangle $$\n问题陈述，跃迁和交换是速率分别为 $k_h$ 和 $k_x$ 的独立泊松过程。对于速率为 $\\lambda$ 的泊松过程，在时间间隔 $t$ 内的平均事件数为 $\\langle N(t) \\rangle = \\lambda t$。将此应用于我们的两个过程：\n$$ \\langle N_h(t) \\rangle = k_h t $$\n$$ \\langle N_x(t) \\rangle = k_x t $$\n将这些结果代入 MSD 的表达式，我们得到：\n$$ \\langle |\\vec{R}(t)|^2 \\rangle = a_h^2 (k_h t) + a_x^2 (k_x t) = (k_h a_h^2 + k_x a_x^2)t $$\n这表明 MSD 随时间线性增长，这是扩散运动的标志。因此，长时间极限是平凡的。\n最后，我们使用其定义计算有效扩散系数：\n$$ D_{\\mathrm{eff}} = \\lim_{t \\to \\infty} \\frac{(k_h a_h^2 + k_x a_x^2)t}{4t} $$\n因子 $t$ 消去，得到最终表达式：\n$$ D_{\\mathrm{eff}} = \\frac{k_h a_h^2 + k_x a_x^2}{4} $$\n这个结果可以解释为由每个独立机制贡献的单个扩散系数之和，$D_{\\mathrm{eff}} = D_h + D_x$，其中 $D_h = \\frac{k_h a_h^2}{4}$ 和 $D_x = \\frac{k_x a_x^2}{4}$。这种可加性是两个扩散路径统计独立性的直接结果。", "answer": "$$\\boxed{\\frac{k_h a_h^2 + k_x a_x^2}{4}}$$", "id": "2791155"}, {"introduction": "将理论模型与实验现实联系起来是现代科学的基石。例如，通过扫描隧道显微镜等手段对原子运动进行的真实测量是在离散的时间点上记录的，并且不可避免地会受到噪声的干扰。这个高级练习 [@problem_id:2791218] 将让您扮演实验科学家的角色，任务是从一个带噪声的离散时间序列中估算扩散系数。您将首先使用动力学蒙特卡洛模拟生成合成数据，然后应用贝叶斯推断框架来恢复底层的物理参数，从而得出一个包含不确定性的稳健估计。", "problem": "您的任务是估计单个吸附原子在晶体表面进行二维迁移的表面扩散系数 $D$，方法是通过将动力学蒙特卡洛（KMC）模拟的轨迹拟合到合成的实验时间序列数据，并通过使用适当先验的贝叶斯推断来量化不确定性。吸附原子位于晶格间距为 $a$ 的正方形晶格上，并进行连续时间最近邻随机游走：两次跳跃之间的等待时间服从速率为 $k$ 的指数分布，该速率不随时间变化，并且每次跳跃都以相等的概率使位置沿 $x$ 或 $y$ 轴改变 $\\pm a$。测量在离散时间点进行，并受到每个坐标上独立的、标准差已知的 $\\sigma_{\\text{obs}}$ 高斯噪声的干扰。\n\n从连续时间随机游走和扩散的基本原理出发，推导出观测增量的似然函数，并将其在贝叶斯框架内使用，通过反映尺度不变性的适当先验来推断 $D$。在对数均匀间隔的 $D$ 网格上进行数值推断，并报告 $D$ 的后验均值和95%等尾置信区间。\n\n要求：\n\n1. 物理模型与推断目标\n   - 将底层吸附原子的动力学建模为在晶格间距为 $a$、跳跃速率为 $k$ 的正方形晶格上的连续时间最近邻随机游走（一个连续时间马尔可夫链）。\n   - 有效二维扩散系数 $D$ 与微观参数之间的关系必须在您的解决方案中从第一性原理推导得出。\n   - 观测：在时间点 $0 = t_0  t_1  \\dots  t_N$，测得的位置 $\\mathbf{Z}_i = (Z^x_i,Z^y_i)$ 满足 $\\mathbf{Z}_i = \\mathbf{X}(t_i) + \\boldsymbol{\\varepsilon}_i$，其中 $\\mathbf{X}(t)$ 是真实轨迹，$\\boldsymbol{\\varepsilon}_i$ 是独立的零均值高斯误差，其协方差为 $\\sigma_{\\text{obs}}^2 \\mathbf{I}_2$。\n\n2. 似然函数构建\n   - 从连续时间随机游走的定义和多次跳跃的中心极限定理行为出发，推导出在给定 $D$、采样间隔 $\\Delta t_i = t_{i+1} - t_i$ 和已知的 $\\sigma_{\\text{obs}}$ 的情况下，观测增量 $\\Delta \\mathbf{Z}_i = \\mathbf{Z}_{i+1} - \\mathbf{Z}_i$ 的易于处理的似然函数。\n   - 您的推导必须从核心定义（泊松跳跃计数、跳跃的独立性、方差的可加性）开始，而不是从快捷公式开始，并且必须清楚地证明所使用的任何高斯近似的合理性。\n\n3. 先验与后验\n   - 对 $D$ 使用一个在一个物理上合理的有界域 $[D_{\\min},D_{\\max}]$ 上对单位尺度选择不变的先验。陈述并证明您的选择。\n   - 在一个在 $\\log D$ 上均匀的网格上数值计算 $D$ 的后验分布。\n   - 从该后验分布中，计算 $D$ 的后验均值和95%等尾置信区间。\n\n4. 通过动力学蒙特卡洛生成数据（用于测试可复现性）\n   - 对于下面的每个测试用例，使用该测试的底层真实扩散系数 $D_{\\text{true}}$ 通过KMC生成一个合成的“实验”轨迹。使用推导出的 $D$ 和 $k$ 之间的关系来参数化KMC跳跃过程。通过对指数等待时间和跳跃方向进行采样，精确地模拟分段常数轨迹 $\\mathbf{X}(t)$，然后在指定的时间点对观测位置进行采样，并在每个坐标上添加标准差为 $\\sigma_{\\text{obs}}$ 的独立高斯噪声。\n   - 使用固定的随机种子 $1729$ 以确保所有测试的可复现性。\n\n5. 单位与输出\n   - 所有扩散系数必须以 $\\mathrm{m}^2/\\mathrm{s}$ 为单位表示。\n   - 您的程序必须生成单行输出，其中包含一个由方括号括起来的逗号分隔列表形式的结果，其中每个元素对应一个测试用例，并且本身是一个三元素列表 $[m,\\ell,u]$，包含 $D$ 的后验均值 $m$、95%置信区间的下界 $\\ell$ 和上界 $u$，所有单位均为 $\\mathrm{m}^2/\\mathrm{s}$。使用标准浮点格式；科学记数法是可接受的。\n\n6. 测试套件\n   - 使用以下四个测试用例。对于每个用例，生成观测时间，使用指定参数模拟KMC轨迹，添加测量噪声，然后从含噪声的时间序列中推断 $D$。\n   - 通用设置：将Jeffreys先验边界设置为 $D_{\\min} = 10^{-24}\\ \\mathrm{m}^2/\\mathrm{s}$ 和 $D_{\\max} = 10^{-14}\\ \\mathrm{m}^2/\\mathrm{s}$，晶格间距设置为 $a = 2.5 \\times 10^{-10}\\ \\mathrm{m}$。\n   - 用例A（理想情况）：$D_{\\text{true}} = 5.0 \\times 10^{-19}\\ \\mathrm{m}^2/\\mathrm{s}$，$N = 1000$ 个增量，采样间隔均匀为 $\\Delta t = 0.1\\ \\mathrm{s}$，测量噪声 $\\sigma_{\\text{obs}} = 2.0 \\times 10^{-11}\\ \\mathrm{m}$。\n   - 用例B（低 $D$ 边界）：$D_{\\text{true}} = 1.0 \\times 10^{-21}\\ \\mathrm{m}^2/\\mathrm{s}$，$N = 1000$ 个增量，采样间隔均匀为 $\\Delta t = 0.1\\ \\mathrm{s}$，测量噪声 $\\sigma_{\\text{obs}} = 1.0 \\times 10^{-11}\\ \\mathrm{m}$。\n   - 用例C（非均匀采样）：$D_{\\text{true}} = 2.0 \\times 10^{-18}\\ \\mathrm{m}^2/\\mathrm{s}$，$N = 800$ 个增量，采样间隔 $\\Delta t_i$ 独立地在 $0.05\\ \\mathrm{s}$ 和 $0.2\\ \\mathrm{s}$ 之间均匀分布，测量噪声 $\\sigma_{\\text{obs}} = 3.0 \\times 10^{-11}\\ \\mathrm{m}$。\n   - 用例D（高观测噪声）：$D_{\\text{true}} = 1.0 \\times 10^{-19}\\ \\mathrm{m}^2/\\mathrm{s}$，$N = 1500$ 个增量，采样间隔均匀为 $\\Delta t = 0.05\\ \\mathrm{s}$，测量噪声 $\\sigma_{\\text{obs}} = 1.0 \\times 10^{-10}\\ \\mathrm{m}$。\n\n7. 最终输出格式\n   - 您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表形式的结果，顺序为 [用例A, 用例B, 用例C, 用例D]。每个用例应为一个包含三个浮点数的列表 $[m,\\ell,u]$，给出 $D$ 的后验均值和95%置信区间界限，单位为 $\\mathrm{m}^2/\\mathrm{s}$。例如：[[m_A,l_A,u_A],[m_B,l_B,u_B],[m_C,l_C,u_C],[m_D,l_D,u_D]]。\n\n您的最终答案必须是一个完整的、可运行的程序，该程序无需任何用户输入即可执行所有步骤，并且只打印指定的单行输出。", "solution": "我们从吸附原子在晶体表面迁移的连续时间随机游走模型开始。吸附原子位于晶格间距为 $a$ 的二维正方形晶格上，并进行最近邻跳跃。两次跳跃之间的等待时间 $\\tau$ 服从速率为 $k$ 的指数分布，因此在时间间隔 $[0,t]$ 内的跳跃次数 $N(t)$ 是一个泊松随机变量，其均值为 $\\mathbb{E}[N(t)] = k t$。每次跳跃都是独立的，并且以 $1/4$ 的相等概率使位置改变四个向量 $\\{(\\pm a,0),(0,\\pm a)\\}$ 中的一个。\n\n$D$ 与 $k$ 之间的关系。考虑 $n$ 次跳跃后的位移。设 $\\Delta \\mathbf{r}_j$ 为第 $j$ 次跳跃向量。$n$ 次跳跃后的净位移为 $\\mathbf{R}_n = \\sum_{j=1}^n \\Delta \\mathbf{r}_j$。因为跳跃是独立的、中心化的且在晶格上是各向同性的，我们有 $\\mathbb{E}[\\Delta \\mathbf{r}_j] = \\mathbf{0}$ 和 $\\mathbb{E}[\\|\\Delta \\mathbf{r}_j\\|^2] = a^2$。由于独立性和零均值，交叉项的期望值为零，因此 $\\mathbb{E}[\\|\\mathbf{R}_n\\|^2] = \\sum_{j=1}^n \\mathbb{E}[\\|\\Delta \\mathbf{r}_j\\|^2] = n a^2$。在连续时间中，跳跃次数 $N(t)$ 是均值为 $k t$ 的泊松分布，均方位移变为\n$$\n\\mathbb{E}\\left[\\|\\mathbf{X}(t) - \\mathbf{X}(0)\\|^2\\right] = \\mathbb{E}\\left[\\|\\mathbf{R}_{N(t)}\\|^2\\right] = a^2 \\, \\mathbb{E}[N(t)] = a^2 k t.\n$$\n对于一个扩散系数为 $D$ 的二维扩散过程，Einstein关系给出 $\\mathbb{E}[\\|\\mathbf{X}(t) - \\mathbf{X}(0)\\|^2] = 4 D t$。将这两个表达式相等，得到微观跳跃速率和宏观扩散系数之间的基本关系：\n$$\nD = \\frac{a^2 k}{4}.\n$$\n此推导仅使用了连续时间马尔可夫跳跃过程的核心定义和经过充分验证的扩散Einstein关系。\n\n观测模型与似然函数。观测在严格递增的时间点 $0 = t_0  t_1  \\dots  t_N$ 进行。测得的位置为\n$$\n\\mathbf{Z}_i = \\mathbf{X}(t_i) + \\boldsymbol{\\varepsilon}_i,\n$$\n其中 $\\boldsymbol{\\varepsilon}_i \\sim \\mathcal{N}(\\mathbf{0}, \\sigma_{\\text{obs}}^2 \\mathbf{I}_2)$ 在不同 $i$ 之间是独立的，并且与动力学过程无关。考虑在间隔 $\\Delta t_i = t_{i+1} - t_i$ 内的观测增量 $\\Delta \\mathbf{Z}_i = \\mathbf{Z}_{i+1} - \\mathbf{Z}_i$。我们可以写成\n$$\n\\Delta \\mathbf{Z}_i = \\Delta \\mathbf{X}_i + \\boldsymbol{\\eta}_i,\n$$\n其中 $\\Delta \\mathbf{X}_i = \\mathbf{X}(t_{i+1}) - \\mathbf{X}(t_i)$ 且 $\\boldsymbol{\\eta}_i = \\boldsymbol{\\varepsilon}_{i+1} - \\boldsymbol{\\varepsilon}_i$。噪声差 $\\boldsymbol{\\eta}_i \\sim \\mathcal{N}(\\mathbf{0}, 2 \\sigma_{\\text{obs}}^2 \\mathbf{I}_2)$ 并且在不同 $i$ 之间是独立的，因为 $\\boldsymbol{\\varepsilon}_i$ 是独立的。对于动力学，在平均包含多次跳跃的短时间间隔 $\\Delta t_i$ 内，随机游走增量的中心极限定理意味着 $\\Delta \\mathbf{X}_i$ 近似为零均值高斯分布，每个坐标的协方差为 $2 D \\Delta t_i \\, \\mathbf{I}_2$。这是由独立跳跃增量的可加性以及复合泊松过程在扩散极限下收敛于布朗运动得出的。\n\n因此，增量 $\\Delta \\mathbf{Z}_i$ 是两个独立中心高斯分布的和，其本身也是高斯分布：\n$$\n\\Delta \\mathbf{Z}_i \\sim \\mathcal{N}\\!\\left(\\mathbf{0}, \\left(2 D \\Delta t_i + 2 \\sigma_{\\text{obs}}^2\\right)\\mathbf{I}_2\\right).\n$$\n将增量幅值的平方记为 $r_i^2 = (\\Delta Z^x_i)^2 + (\\Delta Z^y_i)^2$，每个坐标的方差记为 $v_i(D) = 2 D \\Delta t_i + 2 \\sigma_{\\text{obs}}^2$。来自区间 $i$ 的似然贡献是在 $\\Delta \\mathbf{Z}_i$ 处计算的二维各向同性高斯分布的密度：\n$$\np(\\Delta \\mathbf{Z}_i \\mid D) = \\frac{1}{2 \\pi v_i(D)} \\exp\\!\\left(-\\frac{r_i^2}{2 v_i(D)}\\right).\n$$\n假设在给定 $D$ 的情况下增量是独立的（这对于布朗运动和独立观测噪声都成立），则完整似然是 $i=0,\\dots,N-1$ 的乘积，对数似然为\n$$\n\\log p(\\{\\Delta \\mathbf{Z}_i\\} \\mid D) = - \\sum_{i=0}^{N-1} \\left[ \\log\\!\\left(2 \\pi v_i(D)\\right) + \\frac{r_i^2}{2 v_i(D)} \\right].\n$$\n\n先验与后验。扩散系数 $D$ 是一个正尺度参数。一个在测量尺度变化下保持不变的标准选择是Jeffreys先验，对于一个尺度参数，它在一个有界域上具有 $p(D) \\propto 1/D$ 的形式，以使其成为正常的。我们采用\n$$\np(D) = \\frac{1}{Z} \\cdot \\frac{1}{D} \\cdot \\mathbf{1}\\{D_{\\min} \\le D \\le D_{\\max}\\},\n$$\n其中 $D_{\\min} = 10^{-24}\\ \\mathrm{m}^2/\\mathrm{s}$ 和 $D_{\\max} = 10^{-14}\\ \\mathrm{m}^2/\\mathrm{s}$，$Z$ 是归一化常数。等价地，这是在 $[\\log D_{\\min}, \\log D_{\\max}]$ 上对 $\\theta = \\log D$ 的均匀先验。在数值上，方便的做法是在一个等间距的网格上对 $\\theta$ 进行离散化，计算未归一化的后验 $p(\\theta \\mid \\text{data}) \\propto p(\\theta)\\, p(\\text{data}\\mid D(\\theta)) \\propto p(\\text{data}\\mid D(\\theta))$，通过求和将其归一化，然后通过对 $\\theta$ 的数值积分计算后验摘要。具体来说，如果 $\\{\\theta_j\\}_{j=1}^G$ 是 $[\\log D_{\\min}, \\log D_{\\max}]$ 上的一个间距为 $\\Delta \\theta$ 的均匀网格，且 $D_j = e^{\\theta_j}$，我们设\n$$\nw_j \\propto \\exp\\!\\left(\\log p(\\{\\Delta \\mathbf{Z}_i\\} \\mid D_j)\\right),\n$$\n归一化 $p_j = w_j / \\sum_{m=1}^G w_m$，然后计算后验均值为\n$$\n\\mathbb{E}[D \\mid \\text{data}] \\approx \\sum_{j=1}^G D_j\\, p_j,\n$$\n并通过 $p_j$ 的累积和分别达到累积概率 $0.025$ 和 $0.975$ 来计算95%等尾置信区间的端点，这两者都解释为在 $\\theta$-网格上（$\\theta$ 上的均匀先验）。\n\n通过动力学蒙特卡洛生成数据。对于每个测试用例，我们首先构建观测时间网格。然后，给定指定的 $D_{\\text{true}}$ 和晶格间距 $a$，我们从推导的关系式中计算 $k = 4 D_{\\text{true}} / a^2$。我们通过抽取速率为 $k$ 的指数等待时间，并在每次跳跃时以相等概率选择四个晶格方向中的一个，来模拟一个连续时间随机游走轨迹，累积跳跃时间和位置。真实位置 $\\mathbf{X}(t)$ 在跳跃时间之间是分段常数。为了获得在观测时间 $\\{t_i\\}$ 的真实位置，我们遍历跳跃时间，并在每个 $t_i$ 记录当前的晶格位置。最后，我们在每个坐标上添加标准差为 $\\sigma_{\\text{obs}}$ 的独立高斯噪声，形成 $\\mathbf{Z}_i$。\n\n测试套件细节。我们使用以下四个用例，所有用例的晶格间距 $a = 2.5 \\times 10^{-10}\\ \\mathrm{m}$，Jeffreys先验边界为 $D_{\\min} = 10^{-24}\\ \\mathrm{m}^2/\\mathrm{s}$，$D_{\\max} = 10^{-14}\\ \\mathrm{m}^2/\\mathrm{s}$。随机种子固定为 $1729$。\n\n- 用例A：$D_{\\text{true}} = 5.0 \\times 10^{-19}\\ \\mathrm{m}^2/\\mathrm{s}$，$N = 1000$ 个增量，均匀采样间隔 $\\Delta t = 0.1\\ \\mathrm{s}$，$\\sigma_{\\text{obs}} = 2.0 \\times 10^{-11}\\ \\mathrm{m}$。\n- 用例B：$D_{\\text{true}} = 1.0 \\times 10^{-21}\\ \\mathrm{m}^2/\\mathrm{s}$，$N = 1000$ 个增量，均匀采样间隔 $\\Delta t = 0.1\\ \\mathrm{s}$，$\\sigma_{\\text{obs}} = 1.0 \\times 10^{-11}\\ \\mathrm{m}$。\n- 用例C：$D_{\\text{true}} = 2.0 \\times 10^{-18}\\ \\mathrm{m}^2/\\mathrm{s}$，$N = 800$ 个增量，采样间隔 $\\Delta t_i \\sim \\text{Uniform}(0.05, 0.2)\\ \\mathrm{s}$ 独立分布，$\\sigma_{\\text{obs}} = 3.0 \\times 10^{-11}\\ \\mathrm{m}$。\n- 用例D：$D_{\\text{true}} = 1.0 \\times 10^{-19}\\ \\mathrm{m}^2/\\mathrm{s}$，$N = 1500$ 个增量，均匀采样间隔 $\\Delta t = 0.05\\ \\mathrm{s}$，$\\sigma_{\\text{obs}} = 1.0 \\times 10^{-10}\\ \\mathrm{m}$。\n\n算法实现。程序对每个用例按以下步骤进行：\n- 通过对指定的采样间隔进行累积求和，构建观测时间 $\\{t_i\\}$。\n- 使用速率 $k = 4 D_{\\text{true}} / a^2$ 生成KMC轨迹，记录在 $\\{t_i\\}$ 处的真实位置，并添加标准差为 $\\sigma_{\\text{obs}}$ 的高斯测量噪声以获得观测值。\n- 形成观测增量 $\\Delta \\mathbf{Z}_i$ 和时间间隔 $\\Delta t_i$。\n- 在 $[ \\log D_{\\min}, \\log D_{\\max}]$ 范围内 $\\log D$ 均匀的网格 $\\{\\theta_j\\}$ 上，对每个 $D_j = e^{\\theta_j}$ 使用以下公式评估对数似然：\n$$\n\\log p(\\{\\Delta \\mathbf{Z}_i\\} \\mid D_j) = - \\sum_{i=0}^{N-1} \\left[ \\log\\!\\left( 2 \\pi \\left( 2 D_j \\Delta t_i + 2 \\sigma_{\\text{obs}}^2 \\right) \\right) + \\frac{r_i^2}{2 \\left( 2 D_j \\Delta t_i + 2 \\sigma_{\\text{obs}}^2 \\right)} \\right].\n$$\n- 在 $\\theta$-网格上归一化后验分布，计算后验均值 $\\mathbb{E}[D \\mid \\text{data}]$ 以及通过在 $\\theta$ 上的累积分布上求和与插值，计算95%等尾置信区间的2.5%和97.5%分位数。\n\n所有报告的扩散系数必须以 $\\mathrm{m}^2/\\mathrm{s}$ 为单位，并且程序必须打印包含一个四元素列表的单行，每个列表对应一个测试用例，格式为 $[m,\\ell,u]$，其中 $m$ 是后验均值，$\\ell,u$ 分别是95%置信区间的下界和上界，均为浮点数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef kmc_generate_observations(D_true, a, t_obs, sigma_obs, rng):\n    \"\"\"\n    Generate a 2D KMC trajectory observed at times t_obs with Gaussian measurement noise.\n    Continuous-time nearest-neighbor random walk on square lattice with spacing a\n    and jump rate k = 4 D_true / a^2.\n    \"\"\"\n    k = 4.0 * D_true / (a * a)\n    # Handle k=0 edge case (immobile): just zeros\n    x, y = 0.0, 0.0\n    positions = np.zeros((len(t_obs), 2), dtype=float)\n\n    if k == 0.0:\n        true_positions = positions.copy()\n    else:\n        # Simulate jump times and positions, then sample at t_obs\n        t = 0.0\n        # Iterator over observation times\n        idx_obs = 0\n        # Directions: (+a,0), (-a,0), (0,+a), (0,-a)\n        dirs = np.array([[a, 0.0], [-a, 0.0], [0.0, a], [0.0, -a]], dtype=float)\n        # Record positions at each observation time\n        while idx_obs  len(t_obs):\n            # Fill positions at current time before any new jump that exceeds current observation time\n            if t >= t_obs[idx_obs]:\n                positions[idx_obs, 0] = x\n                positions[idx_obs, 1] = y\n                idx_obs += 1\n                continue\n            # Generate next waiting time\n            wait = rng.exponential(1.0 / k)\n            # If next jump occurs after next observation, hold position until that obs time\n            if t + wait > t_obs[idx_obs]:\n                # No jump before next observation; just advance time to that obs time\n                t = t_obs[idx_obs]\n                positions[idx_obs, 0] = x\n                positions[idx_obs, 1] = y\n                idx_obs += 1\n            else:\n                # A jump occurs; update time and position\n                t += wait\n                step = dirs[rng.integers(0, 4)]\n                x += step[0]\n                y += step[1]\n        true_positions = positions\n\n    # Add Gaussian measurement noise\n    noisy_positions = true_positions + rng.normal(loc=0.0, scale=sigma_obs, size=true_positions.shape)\n    return noisy_positions\n\ndef compute_loglikelihood(D, dx, dy, dt, sigma_obs):\n    \"\"\"\n    Compute the log-likelihood of observed increments given D, under the Gaussian increment model:\n    Delta Z_i ~ N(0, (2 D dt_i + 2 sigma_obs^2) I_2).\n    \"\"\"\n    # Per-coordinate variance for each interval\n    var = 2.0 * D * dt + 2.0 * (sigma_obs ** 2)\n    # Avoid numerical issues if var is extremely small\n    # Clip at a small positive minimum\n    var = np.clip(var, 1e-300, None)\n    r2 = dx * dx + dy * dy\n    # For 2D isotropic Gaussian: density = (1 / (2*pi*var)) * exp(-r2 / (2*var))\n    # Log-likelihood sum over intervals\n    loglik = -np.sum(np.log(2.0 * np.pi * var) + r2 / (2.0 * var))\n    return loglik\n\ndef bayes_posterior_stats(dx, dy, dt, sigma_obs, D_min=1e-24, D_max=1e-14, ngrid=1600):\n    \"\"\"\n    Compute posterior over D using a Jeffreys prior (uniform in log D) on [D_min, D_max].\n    Return posterior mean and equal-tailed 95% credible interval.\n    \"\"\"\n    theta_grid = np.linspace(np.log(D_min), np.log(D_max), ngrid)\n    D_grid = np.exp(theta_grid)\n\n    # Vectorized log-likelihood evaluation\n    # For numerical stability, subtract the maximum log-likelihood before exponentiating.\n    loglik_vals = np.array([compute_loglikelihood(D, dx, dy, dt, sigma_obs) for D in D_grid])\n    max_ll = np.max(loglik_vals)\n    weights_unnorm = np.exp(loglik_vals - max_ll)\n\n    # Posterior over theta is proportional to weights_unnorm (since prior over theta is uniform)\n    weights_sum = np.sum(weights_unnorm)\n    if not np.isfinite(weights_sum) or weights_sum == 0.0:\n        # Fallback: if degenerate, return nan\n        return float('nan'), float('nan'), float('nan')\n\n    p_theta = weights_unnorm / weights_sum\n\n    # Posterior mean E[D] = ∫ e^theta p(theta|data) dtheta ≈ sum(D_j * p_theta_j)\n    post_mean = float(np.sum(D_grid * p_theta))\n\n    # Compute equal-tailed 95% credible interval from CDF over theta\n    cdf = np.cumsum(p_theta)\n    # Ensure last element is exactly one\n    cdf[-1] = 1.0\n\n    def quantile_from_cdf(prob):\n        # Find first index where cdf >= prob\n        idx = np.searchsorted(cdf, prob, side='left')\n        if idx == 0:\n            return float(D_grid[0])\n        elif idx >= len(cdf):\n            return float(D_grid[-1])\n        else:\n            # Linear interpolation on the theta-grid CDF\n            cdf_lo = cdf[idx - 1]\n            cdf_hi = cdf[idx]\n            theta_lo = theta_grid[idx - 1]\n            theta_hi = theta_grid[idx]\n            if cdf_hi == cdf_lo:\n                theta_q = theta_lo\n            else:\n                frac = (prob - cdf_lo) / (cdf_hi - cdf_lo)\n                theta_q = theta_lo + frac * (theta_hi - theta_lo)\n            return float(np.exp(theta_q))\n\n    lower = quantile_from_cdf(0.025)\n    upper = quantile_from_cdf(0.975)\n\n    return post_mean, lower, upper\n\ndef prepare_test_cases():\n    # Common parameters\n    a = 2.5e-10  # meters\n    rng = np.random.default_rng(1729)\n\n    test_cases = []\n\n    # Case A\n    D_true_A = 5.0e-19\n    N_A = 1000\n    dt_A = np.full(N_A, 0.1)\n    t_obs_A = np.concatenate(([0.0], np.cumsum(dt_A)))\n    sigma_A = 2.0e-11\n    Z_A = kmc_generate_observations(D_true_A, a, t_obs_A, sigma_A, rng)\n    test_cases.append((Z_A, t_obs_A, sigma_A))\n\n    # Case B\n    D_true_B = 1.0e-21\n    N_B = 1000\n    dt_B = np.full(N_B, 0.1)\n    t_obs_B = np.concatenate(([0.0], np.cumsum(dt_B)))\n    sigma_B = 1.0e-11\n    Z_B = kmc_generate_observations(D_true_B, a, t_obs_B, sigma_B, rng)\n    test_cases.append((Z_B, t_obs_B, sigma_B))\n\n    # Case C (uneven sampling)\n    D_true_C = 2.0e-18\n    N_C = 800\n    dt_C = rng.uniform(0.05, 0.2, size=N_C)\n    t_obs_C = np.concatenate(([0.0], np.cumsum(dt_C)))\n    sigma_C = 3.0e-11\n    Z_C = kmc_generate_observations(D_true_C, a, t_obs_C, sigma_C, rng)\n    test_cases.append((Z_C, t_obs_C, sigma_C))\n\n    # Case D (high observation noise)\n    D_true_D = 1.0e-19\n    N_D = 1500\n    dt_D = np.full(N_D, 0.05)\n    t_obs_D = np.concatenate(([0.0], np.cumsum(dt_D)))\n    sigma_D = 1.0e-10\n    Z_D = kmc_generate_observations(D_true_D, a, t_obs_D, sigma_D, rng)\n    test_cases.append((Z_D, t_obs_D, sigma_D))\n\n    return test_cases\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = prepare_test_cases()\n\n    results = []\n    for Z, t_obs, sigma_obs in test_cases:\n        # Compute increments and time intervals\n        dZ = Z[1:] - Z[:-1]\n        dx = dZ[:, 0]\n        dy = dZ[:, 1]\n        dt = t_obs[1:] - t_obs[:-1]\n        # Bayesian inference for D\n        mean_D, lo_D, hi_D = bayes_posterior_stats(dx, dy, dt, sigma_obs,\n                                                   D_min=1e-24, D_max=1e-14, ngrid=2000)\n        # Format as scientific notation with 6 significant digits for readability\n        results.append([f\"{mean_D:.6e}\", f\"{lo_D:.6e}\", f\"{hi_D:.6e}\"])\n\n    # Final print statement in the exact required format.\n    # Print nested list with each inner list corresponding to a case [mean, lower, upper]\n    inner = [f\"[{','.join(case)}]\" for case in results]\n    print(f\"[{','.join(inner)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2791218"}]}