{"hands_on_practices": [{"introduction": "这项练习将宏观上可实验测量的表面张力 $\\gamma$ 与基本的界面热力学过剩量联系起来 [@problem_id:2792430]。通过将界面的吉布斯模型应用于纯物质，我们可以推导出表面过剩熵 $s^{\\sigma}$ 和表面过剩焓 $h^{\\sigma}$ 的表达式。这个练习提供了一个具体的例子，说明了如何从宏观数据中提取微观热力学信息，这是界面热力学的一块基石。", "problem": "考虑一个处于大气压下的平面水-空气界面。设表面张力用 $\\gamma(T)$ 表示，单位面积的表面过剩熵和单位面积的表面过剩焓分别用 $s^{\\sigma}(T)$ 和 $h^{\\sigma}(T)$ 表示。假设系统为单组分（水），并使用Gibbs的划分表面构造，使得平面界面的表面过剩体积和表面过剩分子数均为零。\n\n使用纯物质表面的第一性原理热力学，推导在恒定压力下，将 $s^{\\sigma}(T)$ 和 $h^{\\sigma}(T)$ 与 $\\gamma(T)$ 及其温度导数联系起来的表达式。然后，使用下面给出的室温附近水的 $\\gamma(T)$ 的表格数据，数值计算 $s^{\\sigma}(298.15\\,\\mathrm{K})$ 和 $h^{\\sigma}(298.15\\,\\mathrm{K})$：\n- $T = 293.15\\,\\mathrm{K}$, $\\gamma = 72.77\\,\\mathrm{mN}\\,\\mathrm{m}^{-1}$\n- $T = 298.15\\,\\mathrm{K}$, $\\gamma = 71.97\\,\\mathrm{mN}\\,\\mathrm{m}^{-1}$\n- $T = 303.15\\,\\mathrm{K}$, $\\gamma = 71.17\\,\\mathrm{mN}\\,\\mathrm{m}^{-1}$\n\n使用在 $293.15\\,\\mathrm{K}$ 和 $303.15\\,\\mathrm{K}$ 处的邻近值，通过中心差分法近似计算 $\\left.\\partial \\gamma / \\partial T\\right|_{T=298.15\\,\\mathrm{K}}$。评论 $s^{\\sigma}$ 和 $h^{\\sigma}$ 相对于室温附近液态水的代表性体相值 $s_{\\mathrm{bulk}} \\approx 3.9 \\times 10^{6}\\,\\mathrm{J}\\,\\mathrm{m}^{-3}\\,\\mathrm{K}^{-1}$ 和 $\\rho c_{p} T \\approx 1.2 \\times 10^{9}\\,\\mathrm{J}\\,\\mathrm{m}^{-3}$ 的符号和数量级，并解释您比较的物理意义。\n\n最终答案仅报告 $h^{\\sigma}(298.15\\,\\mathrm{K})$ 的数值，单位为 $\\mathrm{J}\\,\\mathrm{m}^{-2}$，并四舍五入到三位有效数字。最终报告的数字中不要包含单位。", "solution": "表面的基本热力学性质由表面过剩量来描述。对于单组分系统，表面张力 $\\gamma$ 的变化（即单位面积的表面过剩Gibbs自由能 $g^{\\sigma}$）由Gibbs吸附方程给出：\n$$d\\gamma = -s^{\\sigma} dT + \\tau dP - \\Gamma d\\mu$$\n其中，$s^{\\sigma}$ 是单位面积的表面过剩熵，$T$ 是绝对温度，$\\tau$ 是表面厚度（与表面过剩体积有关），$P$ 是压力，$\\Gamma$ 是表面过剩浓度，$\\mu$ 是化学势。\n\n问题指定使用Gibbs划分表面，使得表面过剩分子数（因此浓度 $\\Gamma$）为零。对于平面界面，这种选择也导致表面过剩体积为零，从而 $\\tau=0$。实验在恒定大气压下进行，因此 $dP=0$。在这些针对纯物质的特定和标准条件下，方程显著简化为：\n$$d\\gamma = -s^{\\sigma} dT$$\n由此，我们直接得到恒压下单位面积表面过剩熵的表达式：\n$$s^{\\sigma}(T) = -\\left(\\frac{\\partial \\gamma}{\\partial T}\\right)_{P}$$\n这是第一个所需的关系式。\n\n接下来，我们推导单位面积表面过剩焓 $h^{\\sigma}(T)$ 的表达式。根据标准热力学定义，表面过剩焓与表面过剩Gibbs自由能和表面过剩熵相关：\n$$g^{\\sigma} = h^{\\sigma} - T s^{\\sigma}$$\n认识到表面张力 $\\gamma$ 是单位面积的表面过剩Gibbs自由能，即 $\\gamma = g^{\\sigma}$，我们可以写出：\n$$h^{\\sigma} = \\gamma + T s^{\\sigma}$$\n将先前推导的 $s^{\\sigma}$ 表达式代入此方程，得到第二个所需的关系式，即表面的Gibbs-Helmholtz方程：\n$$h^{\\sigma}(T) = \\gamma(T) - T \\left(\\frac{\\partial \\gamma}{\\partial T}\\right)_{P}$$\n\n现在，我们进行数值计算。问题要求使用所提供的数据，通过中心差分近似法计算在 $T = 298.15\\,\\mathrm{K}$ 时的 $(\\partial \\gamma / \\partial T)_{P}$。\n数据如下：\n$T_1 = 293.15\\,\\mathrm{K}$, $\\gamma_1 = 72.77\\,\\mathrm{mN}\\,\\mathrm{m}^{-1} = 72.77 \\times 10^{-3}\\,\\mathrm{J}\\,\\mathrm{m}^{-2}$\n$T_2 = 298.15\\,\\mathrm{K}$, $\\gamma_2 = 71.97\\,\\mathrm{mN}\\,\\mathrm{m}^{-1} = 71.97 \\times 10^{-3}\\,\\mathrm{J}\\,\\mathrm{m}^{-2}$\n$T_3 = 303.15\\,\\mathrm{K}$, $\\gamma_3 = 71.17\\,\\mathrm{mN}\\,\\mathrm{m}^{-1} = 71.17 \\times 10^{-3}\\,\\mathrm{J}\\,\\mathrm{m}^{-2}$\n\n在 $T_2$ 处的导数的中心差分近似为：\n$$\\left.\\frac{\\partial \\gamma}{\\partial T}\\right|_{T=298.15\\,\\mathrm{K}} \\approx \\frac{\\gamma_3 - \\gamma_1}{T_3 - T_1} = \\frac{(71.17 - 72.77) \\times 10^{-3}\\,\\mathrm{J}\\,\\mathrm{m}^{-2}}{(303.15 - 293.15)\\,\\mathrm{K}}$$\n$$\\left.\\frac{\\partial \\gamma}{\\partial T}\\right|_{T=298.15\\,\\mathrm{K}} \\approx \\frac{-1.60 \\times 10^{-3}\\,\\mathrm{J}\\,\\mathrm{m}^{-2}}{10\\,\\mathrm{K}} = -1.60 \\times 10^{-4}\\,\\mathrm{J}\\,\\mathrm{m}^{-2}\\,\\mathrm{K}^{-1}$$\n\n利用这个导数，我们现在可以计算在 $T=298.15\\,\\mathrm{K}$ 时的 $s^{\\sigma}$ 和 $h^{\\sigma}$。\n$$s^{\\sigma}(298.15\\,\\mathrm{K}) = -\\left(\\frac{\\partial \\gamma}{\\partial T}\\right)_{P} \\approx -(-1.60 \\times 10^{-4}\\,\\mathrm{J}\\,\\mathrm{m}^{-2}\\,\\mathrm{K}^{-1}) = 1.60 \\times 10^{-4}\\,\\mathrm{J}\\,\\mathrm{m}^{-2}\\,\\mathrm{K}^{-1}$$\n对于表面过剩焓：\n$$h^{\\sigma}(298.15\\,\\mathrm{K}) = \\gamma(298.15\\,\\mathrm{K}) - T \\left(\\frac{\\partial \\gamma}{\\partial T}\\right)_{P}$$\n$$h^{\\sigma}(298.15\\,\\mathrm{K}) \\approx (71.97 \\times 10^{-3}\\,\\mathrm{J}\\,\\mathrm{m}^{-2}) - (298.15\\,\\mathrm{K})(-1.60 \\times 10^{-4}\\,\\mathrm{J}\\,\\mathrm{m}^{-2}\\,\\mathrm{K}^{-1})$$\n$$h^{\\sigma}(298.15\\,\\mathrm{K}) \\approx 0.07197\\,\\mathrm{J}\\,\\mathrm{m}^{-2} + 0.047704\\,\\mathrm{J}\\,\\mathrm{m}^{-2} = 0.119674\\,\\mathrm{J}\\,\\mathrm{m}^{-2}$$\n\n最后，我们对这些结果进行评论。\n表面过剩熵 $s^{\\sigma}$ 为正。这表明界面区域比体相液体更无序。与体相中的分子相比，表面分子具有更少的近邻和更弱的分子间相互作用，导致更大的运动自由度，从而具有更高的熵。\n表面过剩焓 $h^{\\sigma}$ 也为正。焓是形成系统所需的能量。正的 $h^{\\sigma}$ 表明创建表面需要消耗能量，这与将分子从体相带到表面需要破坏内聚键的物理事实相符。注意，$h^{\\sigma}$ 是创建表面所提供的总能量，包括所做的功 $\\gamma$ 和从周围吸收的热量 $T s^{\\sigma}$。由于 $h^{\\sigma} \\approx 0.120\\,\\mathrm{J}\\,\\mathrm{m}^{-2}$ 大于 $\\gamma \\approx 0.072\\,\\mathrm{J}\\,\\mathrm{m}^{-2}$，等温形成水表面的过程是吸热的。\n\n为了与体相性质进行比较，我们必须引入界面厚度的特征长度尺度 $\\delta$，通常为几个分子直径的量级，例如 $\\delta \\approx 1\\,\\mathrm{nm} = 10^{-9}\\,\\mathrm{m}$。\n我们将表面过剩熵 $s^{\\sigma}$ 与此厚度的体相层的熵 $s_{\\mathrm{bulk}} \\times \\delta$ 进行比较：\n$$\\frac{s^{\\sigma}}{s_{\\mathrm{bulk}} \\times \\delta} \\approx \\frac{1.60 \\times 10^{-4}\\,\\mathrm{J}\\,\\mathrm{m}^{-2}\\,\\mathrm{K}^{-1}}{(3.9 \\times 10^{6}\\,\\mathrm{J}\\,\\mathrm{m}^{-3}\\,\\mathrm{K}^{-1}) \\times (10^{-9}\\,\\mathrm{m})} = \\frac{1.60 \\times 10^{-4}}{3.9 \\times 10^{-3}} \\approx 0.041$$\n表面过剩熵约为一纳米厚体相水层熵的 $4\\%$。这表明，虽然表面确实更无序，但过剩量仅占界面区域总熵的一小部分。\n\n我们将表面过剩焓 $h^{\\sigma}$ 与相同厚度 $\\delta$ 下体相的特征热能密度 $(\\rho c_{p} T)$ 进行比较：\n$$\\frac{h^{\\sigma}}{(\\rho c_{p} T) \\times \\delta} \\approx \\frac{0.119674\\,\\mathrm{J}\\,\\mathrm{m}^{-2}}{(1.2 \\times 10^{9}\\,\\mathrm{J}\\,\\mathrm{m}^{-3}) \\times (10^{-9}\\,\\mathrm{m})} = \\frac{0.119674}{1.2} \\approx 0.10$$\n表面过剩焓约为一纳米厚体相液体特征热能的 $10\\%$。这表明，与创建表面相关的能量在分子尺度上是显著的，但当在稍大的尺度上观察时，它只占该区域总能量的一个很小但不可忽略的部分。\n\n$h^{\\sigma}(298.15\\,\\mathrm{K})$ 的值四舍五入到三位有效数字为 $0.120\\,\\mathrm{J}\\,\\mathrm{m}^{-2}$。", "answer": "$$\\boxed{1.20 \\times 10^{-1}}$$", "id": "2792430"}, {"introduction": "当温度接近临界点 $T_c$ 时，表面张力的温度依赖性变得尤为有趣，此时它会遵循一个普适的标度律而趋于零 [@problem_id:2792417]。本计算练习将一个简单的线性近似模型与物理上更为准确的古根海姆式幂律模型进行对比。通过生成并拟合模拟数据，您将获得模型选择的实践经验，并理解为何临界现象需要超越简单泰勒展开的理论。", "problem": "您需要实现一个程序，用于评估两种唯象模型在一个简单流体（在约化单位下的类 Lennard-Jones 流体）纳米尺度上，对表面张力与温度依赖关系的预测精度。评估范围为靠近临界点且存在稳定液-汽界面的区域。该场景需要生成合成观测数据，以模拟物理上真实的近临界表面张力随温度的衰减情况，然后在相同数据上比较两种模型：一种是温度线性模型，另一种是与经验性 Guggenheim 标度框架一致的临界标度幂律模型。所有符号和温度均采用约化 Lennard-Jones 单位，因此是无量纲的。\n\n使用的基本原理如下：(i) 表面张力是形成单位面积界面所需的可逆功，因此是一种自由能密度；(ii) 简单流体的表面张力随温度升高而减小，并在临界温度时消失；(iii) 远离奇异点的一般解析模型可以一阶近似为关于温度的线性展开；(iv) 在临界点附近，实验观测和理论支持的标度律描述了简单流体界面性质的非解析幂律衰减。感兴趣的温度范围严格介于 $0.6 T_c$ 和 $T_c$ 之间，其中 $T_c$ 是临界温度。\n\n您将为每个测试用例执行以下操作：\n\n1. 合成数据生成。\n   - 构建表面张力对温度的真实基准函数依赖关系，使其在临界温度 $T_c$ 处消失，并具有由指数 $\\mu_{\\text{true}}$ 和振幅 $A_{\\text{true}}$ 表征的非解析代数奇异性。仅在训练标签中添加标准差为 $\\sigma$ 的独立同分布高斯噪声。\n   - 使用指定的整数随机种子，从开区间 $(0.6 T_c,\\, 0.98 T_c)$ 中独立且均匀地采样训练温度，以保证可复现性。训练样本数量为 $N_{\\text{train}}$。\n   - 测试温度确定性地放置在闭区间 $[0.6 T_c,\\, 0.99 T_c]$ 的一个包含 $N_{\\text{test}}$ 个点的均匀网格上。测试目标值为这些温度下的无噪声真实基准值。\n\n2. 在训练集上进行模型拟合。\n   - 模型 L（温度线性模型）：通过对含噪声的训练数据进行普通最小二乘法拟合，得到表面张力与温度的仿射依赖关系。这对应于相对于某个参考点，在温度上的一阶解析近似。\n   - 模型 G（临界标度/类 Guggenheim 模型）：在指数 $\\mu_g$ 固定的情况下，仅对振幅进行普通最小二乘法拟合，以符合表面张力在 $T=T_c$ 时消失的幂律依赖关系。\n\n3. 在测试集上进行精度评估。\n   - 对每个模型，根据无噪声的真实基准值，计算在测试网格上的均方根误差 (RMSE)。根据设计，此评估衡量的是每个模型恢复底层物理规律的好坏，而不是特定噪声实现的好坏。\n   - 每个测试用例报告一个浮点数，其值为 $\\mathrm{RMSE}_{\\mathrm{L}} - \\mathrm{RMSE}_{\\mathrm{G}}$。正值表示在该测试用例中，临界标度模型的性能优于线性模型。\n\n为确保可复现性和覆盖范围的精确细节：\n\n- 使用约化 Lennard-Jones 单位（无量纲），因此不需要物理单位转换。\n- 对类 Guggenheim 模型使用以下固定指数：$\\mu_g = 11/9$。\n- 对于真实基准生成器，指数 $\\mu_{\\text{true}}$ 可能等于 $\\mu_g$ 或略有不同，具体取决于测试用例。\n- 对于每个测试用例，用 $A_{\\text{true}}$ 表示振幅， $T_c$ 表示临界温度， $\\sigma$ 表示训练噪声标准差， $N_{\\text{train}}$ 表示训练样本数， $N_{\\text{test}}$ 表示测试样本数， $\\text{seed}$ 表示整数随机种子。\n\n需要实现的测试套件：\n\n- 用例 1（理想情况，低噪声）：\n  - $T_c = 1.312$, $A_{\\text{true}} = 1.0$, $\\mu_{\\text{true}} = 11/9$, $\\sigma = 0.01$, $N_{\\text{train}} = 50$, $N_{\\text{test}} = 200$, $\\text{seed} = 0$.\n- 用例 2（增加噪声）：\n  - $T_c = 1.312$, $A_{\\text{true}} = 1.0$, $\\mu_{\\text{true}} = 11/9$, $\\sigma = 0.05$, $N_{\\text{train}} = 50$, $N_{\\text{test}} = 200$, $\\text{seed} = 1$.\n- 用例 3（小样本训练）：\n  - $T_c = 1.312$, $A_{\\text{true}} = 1.0$, $\\mu_{\\text{true}} = 11/9$, $\\sigma = 0.01$, $N_{\\text{train}} = 8$, $N_{\\text{test}} = 200$, $\\text{seed} = 2$.\n- 用例 4（指数不匹配以测试鲁棒性）：\n  - $T_c = 1.312$, $A_{\\text{true}} = 1.0$, $\\mu_{\\text{true}} = 1.26$, $\\sigma = 0.01$, $N_{\\text{train}} = 50$, $N_{\\text{test}} = 200$, $\\text{seed} = 3$.\n- 用例 5（不同振幅和中等噪声）：\n  - $T_c = 1.312$, $A_{\\text{true}} = 0.8$, $\\mu_{\\text{true}} = 11/9$, $\\sigma = 0.02$, $N_{\\text{train}} = 50$, $N_{\\text{test}} = 200$, $\\text{seed} = 4$.\n\n您的程序应遵循的实现细节：\n\n- 对于训练集：\n  - 使用指定的种子，从 $\\mathrm{Uniform}(0.6 T_c,\\, 0.98 T_c)$ 中抽取 $T_{\\text{train},i} \\sim \\mathrm{Uniform}(0.6 T_c,\\, 0.98 T_c)$, $i=1,\\dots,N_{\\text{train}}$。\n  - 使用 $A_{\\text{true}}$ 和 $\\mu_{\\text{true}}$，通过近临界代数衰减计算在 $T_{\\text{train},i}$ 处的无噪声真实基准表面张力值，然后添加标准差为 $\\sigma$ 的独立高斯噪声。\n- 对于测试集：\n  - 将 $T_{\\text{test},j}$ 构建为在 $[0.6 T_c,\\, 0.99 T_c]$ 区间内含 $N_{\\text{test}}$ 个点的均匀网格。\n  - 使用带有 $A_{\\text{true}}$ 和 $\\mu_{\\text{true}}$ 的无噪声真实基准模型来计算在 $T_{\\text{test},j}$ 处的目标值。\n- 通过对带有截距项的 $(T_{\\text{train},i}, \\gamma_{\\text{train},i})$ 进行普通最小二乘法拟合来拟合模型 L。\n- 通过对 $(x_i, \\gamma_{\\text{train},i})$ 进行通过原点的普通最小二乘法拟合来拟合模型 G，其中 $x_i$ 是使用 $\\mu_g$ 和 $T_c$ 从 $T_{\\text{train},i}$ 构建的临界标度回归量。\n- 在测试集上，根据无噪声的真实基准值计算 $\\mathrm{RMSE}_{\\mathrm{L}}$ 和 $\\mathrm{RMSE}_{\\mathrm{G}}$，然后为每个用例输出 $\\mathrm{RMSE}_{\\mathrm{L}} - \\mathrm{RMSE}_{\\mathrm{G}}$。\n\n最终输出格式：\n\n- 您的程序应生成一行输出，其中包含 5 个实数值结果，形式为逗号分隔的列表，并用方括号括起来，每个浮点数四舍五入到恰好六位小数（例如，[$0.001234$,$0.056789$,$-0.012300$,$\\dots$]）。", "solution": "目标是实现一个数值实验，以比较两种竞争模型在临界点 $T_c$ 附近预测简单流体表面张力 $\\gamma$ 随温度 $T$ 变化的预测精度。这两个模型是一个通用的线性近似模型和一个有物理动机的临界标度律模型。所有量都以无量纲的约化单位表示。\n\n**理论框架**\n液体的表面张力是其与气相界面处过剩自由能的度量。根据热力学第二定律，随着温度升高，该自由能必须减小，并在临界温度 $T_c$ 处消失，此时液相和气相之间的区别消失。\n\n合成数据的真实基准行为基于已广泛建立的 Guggenheim 标度律：\n$$\n\\gamma_{\\text{true}}(T) = A_{\\text{true}} \\left(1 - \\frac{T}{T_c}\\right)^{\\mu_{\\text{true}}}\n$$\n其中 $A_{\\text{true}}$ 是临界振幅，$\\mu_{\\text{true}}$ 是临界指数。这种函数形式捕捉了临界点附近热力学性质的非解析特性。\n\n我们比较两个拟合从此真实基准生成的含噪声数据的模型：\n1. **模型 L (线性模型)：** $\\gamma_L(T) = aT + b$。此模型代表 $\\gamma(T)$ 在某个参考温度附近的泰勒级数一阶展开。虽然简单，但它无法捕捉当 $T \\to T_c$ 时的正确奇异行为，因为它预测了一个非零的表面张力 $\\gamma_L(T_c) = aT_c + b \\neq 0$。\n2. **模型 G (类 Guggenheim 模型)：** $\\gamma_G(T) = A_G \\left(1 - \\frac{T}{T_c}\\right)^{\\mu_g}$。此模型正确地包含了 $\\gamma(T_c) = 0$ 的物理约束，并假设了奇异性的正确函数形式。指数固定为经验值 $\\mu_g = 11/9$，这是一个接近于简单流体普适类理论值的常数。\n\n**算法流程**\n对于每个测试用例，我们执行以下步骤：\n\n**1. 数据生成**\n- 我们定义给定测试用例的参数：$T_c, A_{\\text{true}}, \\mu_{\\text{true}}, \\sigma, N_{\\text{train}}, N_{\\text{test}},$ 和 `seed`。\n- 使用以指定 `seed` 初始化的随机数生成器，我们从区间 $(0.6 T_c, 0.98 T_c)$ 上的均匀分布中抽取 $N_{\\text{train}}$ 个训练温度 $T_{\\text{train},i}$。\n- 我们生成相应的含噪声的表面张力训练标签：\n  $$\n  \\gamma_{\\text{train},i} = A_{\\text{true}}\\left(1 - \\frac{T_{\\text{train},i}}{T_c}\\right)^{\\mu_{\\text{true}}} + \\epsilon_i, \\quad \\text{其中 } \\epsilon_i \\sim \\mathcal{N}(0, \\sigma^2)\n  $$\n- 我们创建一个包含 $N_{\\text{test}}$ 个测试温度 $T_{\\text{test},j}$ 的确定性网格，这些温度在线性区间 $[0.6 T_c, 0.99 T_c]$ 内均匀分布。\n- 测试集的目标值是无噪声的真实基准值：\n  $$\n  \\gamma_{\\text{test},j} = A_{\\text{true}}\\left(1 - \\frac{T_{\\text{test},j}}{T_c}\\right)^{\\mu_{\\text{true}}}\n  $$\n\n**2. 模型拟合**\n模型拟合在训练集 $(T_{\\text{train},i}, \\gamma_{\\text{train},i})$ 上进行。两种拟合都使用普通最小二乘法 (OLS)。\n\n- **对于模型 L：** 我们寻找参数 $\\hat{a}$ 和 $\\hat{b}$ 以最小化残差平方和：$\\sum_{i=1}^{N_{\\text{train}}} (\\gamma_{\\text{train},i} - (aT_{\\text{train},i} + b))^2$。这是一个标准的线性回归问题。此问题的设计矩阵是 $\\mathbf{X}_L \\in \\mathbb{R}^{N_{\\text{train}} \\times 2}$，其行为 $[T_{\\text{train},i}, 1]$。\n- **对于模型 G：** 我们寻找参数 $\\hat{A}_G$ 以最小化 $\\sum_{i=1}^{N_{\\text{train}}} (\\gamma_{\\text{train},i} - A_G x_i)^2$，其中回归量为 $x_i = (1 - T_{\\text{train},i}/T_c)^{\\mu_g}$。这是一个通过原点的线性回归。单个参数 $A_G$ 的 OLS 估计量具有闭式解：\n  $$\n  \\hat{A}_G = \\frac{\\sum_{i=1}^{N_{\\text{train}}} x_i \\gamma_{\\text{train},i}}{\\sum_{i=1}^{N_{\\text{train}}} x_i^2}\n  $$\n\n**3. 模型评估**\n拟合后，我们使用估计的参数在测试温度网格 $T_{\\text{test},j}$ 上进行预测。\n- 模型 L 的预测：$\\hat{\\gamma}_{L,j} = \\hat{a} T_{\\text{test},j} + \\hat{b}$。\n- 模型 G 的预测：$\\hat{\\gamma}_{G,j} = \\hat{A}_G (1 - T_{\\text{test},j}/T_c)^{\\mu_g}$。\n\n然后，我们针对无噪声的测试目标值 $\\gamma_{\\text{test},j}$ 计算每个模型的均方根误差 (RMSE)。\n$$\n\\mathrm{RMSE}_{\\mathrm{L}} = \\sqrt{\\frac{1}{N_{\\text{test}}} \\sum_{j=1}^{N_{\\text{test}}} (\\hat{\\gamma}_{L,j} - \\gamma_{\\text{test},j})^2}\n$$\n$$\n\\mathrm{RMSE}_{\\mathrm{G}} = \\sqrt{\\frac{1}{N_{\\text{test}}} \\sum_{j=1}^{N_{\\text{test}}} (\\hat{\\gamma}_{G,j} - \\gamma_{\\text{test},j})^2}\n$$\n每个用例最终报告的值是差值 $\\mathrm{RMSE}_{\\mathrm{L}} - \\mathrm{RMSE}_{\\mathrm{G}}$。正值表示模型 G，即有物理动机的幂律模型，比通用的线性模型更准确地表示了底层物理规律。这是预期的结果，特别是当温度范围接近临界点时，函数的曲率变得显著且其行为是奇异的。\n\n现在将着手为五个指定的测试用例执行此程序。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# No other libraries are permitted.\n\ndef solve():\n    \"\"\"\n    Evaluates the predictive accuracy of a linear model vs. a critical-scaling model\n    for the temperature dependence of surface tension near a critical point.\n    \"\"\"\n    \n    # Test suite to implement:\n    # (Tc, A_true, mu_true, sigma, N_train, N_test, seed)\n    test_cases = [\n        # Case 1 (happy path, low noise)\n        (1.312, 1.0, 11/9, 0.01, 50, 200, 0),\n        # Case 2 (increased noise)\n        (1.312, 1.0, 11/9, 0.05, 50, 200, 1),\n        # Case 3 (small-sample training)\n        (1.312, 1.0, 11/9, 0.01, 8, 200, 2),\n        # Case 4 (exponent mismatch to test robustness)\n        (1.312, 1.0, 1.26, 0.01, 50, 200, 3),\n        # Case 5 (different amplitude and moderate noise)\n        (1.312, 0.8, 11/9, 0.02, 50, 200, 4)\n    ]\n    \n    results = []\n    mu_g = 11/9 # Fixed exponent for the Guggenheim-like model\n\n    for case in test_cases:\n        Tc, A_true, mu_true, sigma, N_train, N_test, seed = case\n        \n        # 1. Synthetic data generation\n        \n        # Initialize random number generator for reproducibility\n        rng = np.random.default_rng(seed)\n        \n        # Training set generation\n        T_train_min, T_train_max = 0.6 * Tc, 0.98 * Tc\n        T_train = rng.uniform(T_train_min, T_train_max, size=N_train)\n        \n        # Ground-truth function\n        def gamma_true(T, A, mu):\n            # The term (1 - T/Tc) can become negative if T > Tc, which is not\n            # expected in this temperature range, but handle for safety.\n            # Using np.maximum to avoid nan from negative bases in power.\n            base = np.maximum(0, 1 - T / Tc)\n            return A * (base ** mu)\n\n        # Generate noisy training labels\n        gamma_train_true_vals = gamma_true(T_train, A_true, mu_true)\n        noise = rng.normal(0, sigma, size=N_train)\n        gamma_train_noisy = gamma_train_true_vals + noise\n        \n        # Test set generation\n        T_test_min, T_test_max = 0.6 * Tc, 0.99 * Tc\n        T_test = np.linspace(T_test_min, T_test_max, N_test)\n        \n        # Generate noise-free test labels (ground truth)\n        gamma_test_true = gamma_true(T_test, A_true, mu_true)\n        \n        # 2. Model fitting on the training set\n        \n        # Model L (Linear): y = a*T + b\n        # Using np.linalg.lstsq for stable OLS solution\n        X_L = np.vstack([T_train, np.ones(N_train)]).T\n        a, b = np.linalg.lstsq(X_L, gamma_train_noisy, rcond=None)[0]\n        \n        # Model G (Guggenheim-like): y = A_G * (1 - T/Tc)^mu_g\n        # This is a regression through the origin.\n        x_G_train = (1 - T_train / Tc)**mu_g\n        # OLS estimator for regression through origin: sum(xy) / sum(x^2)\n        A_G = (x_G_train @ gamma_train_noisy) / (x_G_train @ x_G_train)\n        \n        # 3. Accuracy evaluation on the test set\n        \n        # Predictions on the test set\n        gamma_pred_L = a * T_test + b\n        \n        x_G_test = (1 - T_test / Tc)**mu_g\n        gamma_pred_G = A_G * x_G_test\n        \n        # Compute RMSE against noise-free ground truth\n        rmse_L = np.sqrt(np.mean((gamma_pred_L - gamma_test_true)**2))\n        rmse_G = np.sqrt(np.mean((gamma_pred_G - gamma_test_true)**2))\n        \n        # Calculate the difference\n        diff_rmse = rmse_L - rmse_G\n        results.append(diff_rmse)\n        \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\nsolve()\n```", "id": "2792417"}, {"introduction": "现代表面科学在很大程度上依赖于分子模拟来探测量-质界面性质 [@problem_id:2792442]。这项高级练习将深入探讨如何从界面的微观涨落中直接测量宏观热力学量，例如表面熵 $s^{\\sigma}$。您将基于毛细波理论和能量均分定理推导出一个表面张力的估计量，然后在一个数值实验中使用它来验证热力学上的一致性，从而架起连接统计力学与宏观热力学的桥梁。", "problem": "你的任务是实现一个完整、可复现的数值实验，从界面高度涨落中推断单位面积的表面熵（记为 $s^{\\sigma}$），并通过与表面张力对温度导数的有限差分估计进行比较，来验证其一致性。你的实验必须源于第一性原理，并适用于纳米力学以及表面与界面科学领域。\n\n请从以下基本依据和核心定义开始：\n- 考虑一个由小斜率高度场 $h(x,y)$ 描述的液体界面，该界面位于一个投影面积为 $A = L^2$ 的平坦参考平面之上，并在边长为 $L$ 的正方形上具有周期性边界条件。在小斜率体系中，长波长模式的毛细波哈密顿量是 $h$ 的二次型，由下式给出\n$$\nE[h] = \\frac{\\gamma}{2} \\int_A \\lvert \\nabla h \\rvert^2 \\, \\mathrm{d}^2 r \\;+\\; \\frac{\\kappa}{2} \\int_A \\lvert \\nabla^2 h \\rvert^2 \\, \\mathrm{d}^2 r,\n$$\n其中 $\\gamma$ 是表面张力（单位为 $\\mathrm{N/m}$），$\\kappa$ 是一个设定微观截止的小刚度（单位为 $\\mathrm{J}$）。这个二次型是描述长波长下液体界面毛细波涨落的一个广为接受的连续介质模型；$\\kappa$ 项对紫外发散进行正则化，并在高波数 $k$ 下模拟微观结构。\n- 使用单位面积表面熵的定义，\n$$\ns^{\\sigma} = -\\left( \\frac{\\partial \\gamma}{\\partial T} \\right),\n$$\n在恒定的化学势和压力下求值。\n- 使用经典统计力学的能量均分定理：每个独立的二次自由度贡献的平均能量为 $\\frac{1}{2} k_{\\mathrm{B}} T$，其中 $k_{\\mathrm{B}}$ 是玻尔兹曼常数。对于具有周期性边界条件的实数场的独立傅里叶模式 $h_{\\mathbf{k}}$，总能量是 $\\lvert h_{\\mathbf{k}} \\rvert^2$ 的二次贡献之和。\n\n你的任务是：\n1. 从上述依据出发，推导出一个从温度为 $T$ 的界面高度涨落系综中估计 $\\gamma$ 的统计一致估计量。你的推导必须仅使用所述原理（二次哈密顿量、模式均分以及实数场的傅里叶模式性质）。不要假设任何未由这些原理推出的额外唯象简化公式。\n2. 设计一个合成数据生成器，该生成器能够抽取模式振幅的独立样本，这些样本足以在一系列温度下估计 $\\gamma(T)$。为了真实性，利用复高斯模式的模平方呈指数分布这一事实，并确保你的采样过程尊重波矢半平面中模式的独立性结构。使用一个边长为 $L$ 的正方形域，并将分析限制在波数大小处于一个频带内的模式，该频带避开了零模式并限制了由 $\\kappa$ 项引起的紫外污染。\n3. 对于下面的每个测试用例，通过两种独立的数值途径来估计 $s^{\\sigma}$：\n   - 对目标温度 $T_0$ 附近的一个温度窗口内的 $\\gamma(T)$ 进行局部线性回归，然后将 $s^{\\sigma}$ 作为负斜率。\n   - 在 $T_0$ 处以步长 $\\Delta T$ 计算 $\\gamma$ 对温度导数的中心有限差分估计，然后将 $s^{\\sigma}$ 作为该有限差分的负值。\n4. 对于每个测试用例，报告 $s^{\\sigma}$ 的两种估计是否在指定的相对容差内一致，以及基于回归的估计相对于用于生成合成数据的基准模型是否准确。\n\n合成数据模型和物理常数：\n- 在合成数据生成器中，对基准表面张力使用线性的温度依赖关系，\n$$\n\\gamma_{\\mathrm{true}}(T) = \\gamma_{\\mathrm{ref}} - a \\left( T - T_{\\mathrm{ref}} \\right),\n$$\n参数为 $\\gamma_{\\mathrm{ref}} = 0.072\\ \\mathrm{N/m}$，$T_{\\mathrm{ref}} = 300\\ \\mathrm{K}$，以及 $a = 1.5 \\times 10^{-4}\\ \\mathrm{N/(m\\cdot K)}$。这与在中等温度范围内观测到的常见液体的典型斜率相符。因此，要恢复的精确目标是 $s^{\\sigma}_{\\mathrm{true}} = a$，单位为 $\\mathrm{N/(m\\cdot K)}$。\n- 玻尔兹曼常数：$k_{\\mathrm{B}} = 1.380649 \\times 10^{-23}\\ \\mathrm{J/K}$。\n- 使用边长为 $L$（每个测试用例中指定）和面积为 $A = L^2$ 的正方形域；允许的波矢为 $\\mathbf{k} = \\frac{2\\pi}{L}(n_x,n_y)$，其中 $n_x,n_y$ 为整数，并遵循适用于实数场的独立半平面约束：只包括 $n_y  0$ 或 $\\left( n_y = 0 \\text{ and } n_x  0 \\right)$ 的模式，并排除 $\\mathbf{k}=\\mathbf{0}$。将模式限制在整数分量 $\\lvert n_x \\rvert,\\lvert n_y \\rvert \\le n_{\\max}$ 和一个排除零模式的下限内。\n\n测试套件：\n实现三个测试用例，每个用例指定域大小、采样深度和温度窗口。对于每个用例，生成温度 $T_j = T_0 + j\\,\\Delta T$（其中 $j \\in \\{-3,-2,-1,0,1,2,3\\}$），通过你推导的估计量从涨落中估计 $\\gamma(T_j)$，然后在 $T_0$ 处计算 $s^{\\sigma}$ 的局部回归估计和有限差分估计。\n- 用例 1（理想情况）：$T_0 = 298\\ \\mathrm{K}$，$\\Delta T = 8\\ \\mathrm{K}$，$L = 2.0 \\times 10^{-7}\\ \\mathrm{m}$，$n_{\\max} = 6$，$M = 1500$（每个模式和温度的独立样本数），$\\kappa = 0\\ \\mathrm{J}$。\n- 用例 2（更高温度窗口）：$T_0 = 360\\ \\mathrm{K}$，$\\Delta T = 15\\ \\mathrm{K}$，$L = 2.5 \\times 10^{-7}\\ \\mathrm{m}$，$n_{\\max} = 8$，$M = 2000$，$\\kappa = 0\\ \\mathrm{J}$。\n- 用例 3（紫外正则化非零）：$T_0 = 320\\ \\mathrm{K}$，$\\Delta T = 10\\ \\mathrm{K}$，$L = 2.0 \\times 10^{-7}\\ \\mathrm{m}$，$n_{\\max} = 8$，$M = 2500$，$\\kappa = 5.0 \\times 10^{-19}\\ \\mathrm{J}$。\n\n需要遵守的数值和统计细节：\n- 使用 $\\lvert h_{\\mathbf{k}} \\rvert^2$ 的独立抽样，其呈指数分布，且均值与你的推导在温度 $T$ 和参数 $\\gamma_{\\mathrm{true}}(T)$、$\\kappa$ 下所蕴含的模式方差一致。对 $M$ 个样本进行平均，以形成模式二阶矩的一致估计量。将多个模式组合起来，对 $k$ 的适当幂次进行回归，以估计 $\\gamma(T)$，而不预先假设 $\\kappa$ 是否为零。\n- 对于每个 $T$，通过对一个变换后的可观测量进行线性最小二乘拟合来估计 $\\gamma(T)$，该变换能够导出一个关于 $\\gamma$ 和 $\\kappa$ 的无截距项的线性关系，正如你从能量均分和二次哈密顿量的推导所蕴含的那样。在你的解决方案中明确说明这个变换和拟合的特征。\n- 对于 $T_0$ 处的 $s^{\\sigma}$ 的局部斜率估计，对 $j \\in \\{-3,-2,-1,0,1,2,3\\}$ 的 $\\gamma(T_j)$ 与 $T_j$ 的关系拟合一条直线，并取拟合斜率的负值。\n- 对于 $T_0$ 处的有限差分估计，使用 $T_0 \\pm \\Delta T$ 计算中心差分，并取该差分除以 $2\\Delta T$ 后的负值。\n\n单位、容差和输出：\n- 以 $\\mathrm{N/(m\\cdot K)}$ 为单位报告所有单位面积表面熵值 $s^{\\sigma}$。\n- 对于每个用例，评估两个条件：\n  1. 基于回归的估计和有限差分估计之间的一致性，其相对于 $s^{\\sigma}_{\\mathrm{true}}$ 的相对差异在 $10\\%$ 以内。\n  2. 基于回归的估计与 $s^{\\sigma}_{\\mathrm{true}}$ 的相对误差小于 $10\\%$。\n  将一个用例的布尔结果设为这两个条件的逻辑与。\n- 你的程序应产生单行输出，其中包含三个测试用例的结果，形式为方括号内由逗号分隔的布尔值列表，例如 $[\\text{True},\\text{False},\\text{True}]$。\n\n所有数值选择必须科学上合理，并与所述物理模型一致。使用的单位：$k_{\\mathrm{B}}$ 为 $\\mathrm{J/K}$，长度为 $\\mathrm{m}$，表面张力为 $\\mathrm{N/m}$，温度为 $\\mathrm{K}$。代码必须完全自包含，并可通过固定的随机种子复现。不允许用户输入。", "solution": "**1. 表面张力估计量的推导**\n\n分析始于所给出的、描述投影面积为 $A = L^2$ 上的液体界面高度 $h(\\mathbf{r})$ 的毛细波哈密顿量：\n$$\nE[h] = \\frac{\\gamma}{2} \\int_A \\lvert \\nabla h \\rvert^2 \\, \\mathrm{d}^2 r \\;+\\; \\frac{\\kappa}{2} \\int_A \\lvert \\nabla^2 h \\rvert^2 \\, \\mathrm{d}^2 r\n$$\n其中 $\\mathbf{r} = (x,y)$。高度场 $h(\\mathbf{r})$ 是一个定义在具有周期性边界条件的正方形域上的实函数。它可以由其复傅里叶级数表示：\n$$\nh(\\mathbf{r}) = \\sum_{\\mathbf{k}} h_{\\mathbf{k}} e^{i \\mathbf{k} \\cdot \\mathbf{r}}\n$$\n由于周期性边界条件，波矢 $\\mathbf{k}$ 是离散的：$\\mathbf{k} = \\frac{2\\pi}{L}(n_x, n_y)$，其中 $n_x, n_y$ 为整数索引。由于 $h(\\mathbf{r})$ 是实数，其傅里叶系数必须满足厄米共轭条件 $h_{-\\mathbf{k}} = h_{\\mathbf{k}}^*$。\n\n为了用傅里叶模式 $h_{\\mathbf{k}}$ 表示能量，我们应用帕塞瓦尔定理。梯度和拉普拉斯算子的傅里叶变换为：\n$$\n\\mathcal{F}[\\nabla h](\\mathbf{k}) = i \\mathbf{k} h_{\\mathbf{k}}\n$$\n$$\n\\mathcal{F}[\\nabla^2 h](\\mathbf{k}) = -k^2 h_{\\mathbf{k}}\n$$\n其中 $k = |\\mathbf{k}|$。对于面积 $A$ 上的积分，帕塞瓦尔定理指出 $\\int_A |f(\\mathbf{r})|^2 \\, \\mathrm{d}^2 r = A \\sum_{\\mathbf{k}} |f_{\\mathbf{k}}|^2$。将此应用于能量项，得到：\n$$\n\\int_A \\lvert \\nabla h \\rvert^2 \\, \\mathrm{d}^2 r = A \\sum_{\\mathbf{k}} |i \\mathbf{k} h_{\\mathbf{k}}|^2 = A \\sum_{\\mathbf{k}} k^2 |h_{\\mathbf{k}}|^2\n$$\n$$\n\\int_A \\lvert \\nabla^2 h \\rvert^2 \\, \\mathrm{d}^2 r = A \\sum_{\\mathbf{k}} |-k^2 h_{\\mathbf{k}}|^2 = A \\sum_{\\mathbf{k}} k^4 |h_{\\mathbf{k}}|^2\n$$\n将这些代入哈密顿量，得到总能量是各模式贡献的总和：\n$$\nE = \\sum_{\\mathbf{k}} \\frac{A}{2} (\\gamma k^2 + \\kappa k^4) |h_{\\mathbf{k}}|^2\n$$\n厄米共轭条件 $h_{-\\mathbf{k}} = h_{\\mathbf{k}}^*$ 意味着 $\\mathbf{k}$ 和 $-\\mathbf{k}$ 处的模式不是独立的。为了处理独立的自由度，我们将求和写在一个独立的波矢半平面上（例如，$n_y > 0$ 或 $n_y=0$ 且 $n_x > 0$），这排除了 $\\mathbf{k}=\\mathbf{0}$ 模式。对于每个这样的 $\\mathbf{k}$（假设 $\\mathbf{k} \\neq -\\mathbf{k}$），来自 $(\\mathbf{k}, -\\mathbf{k})$ 对的能量贡献是：\n$$\nE_{\\mathbf{k}, \\text{pair}} = \\frac{A}{2} (\\gamma k^2 + \\kappa k^4) |h_{\\mathbf{k}}|^2 + \\frac{A}{2} (\\gamma k^2 + \\kappa k^4) |h_{-\\mathbf{k}}|^2 = A (\\gamma k^2 + \\kappa k^4) |h_{\\mathbf{k}}|^2\n$$\n写作 $h_{\\mathbf{k}} = u_{\\mathbf{k}} + i v_{\\mathbf{k}}$，我们有 $|h_{\\mathbf{k}}|^2 = u_{\\mathbf{k}}^2 + v_{\\mathbf{k}}^2$。变量 $u_{\\mathbf{k}}$ 和 $v_{\\mathbf{k}}$ 代表两个独立的实二次自由度。根据经典统计力学的能量均分定理，每个这样的自由度贡献的平均能量为 $\\frac{1}{2} k_{\\mathrm{B}} T$。因此，这对模式的总平均能量是 $k_{\\mathrm{B}} T$：\n$$\n\\langle E_{\\mathbf{k}, \\text{pair}} \\rangle = \\left\\langle A (\\gamma k^2 + \\kappa k^4) (u_{\\mathbf{k}}^2 + v_{\\mathbf{k}}^2) \\right\\rangle = k_{\\mathrm{B}} T\n$$\n这使我们能够找到模式振幅平方的热平均值：\n$$\n\\left\\langle |h_{\\mathbf{k}}|^2 \\right\\rangle = \\frac{k_{\\mathrm{B}} T}{A (\\gamma k^2 + \\kappa k^4)}\n$$\n这个基本关系将可观测量 $\\langle |h_{\\mathbf{k}}|^2 \\rangle$ 与物理参数 $\\gamma$ 和 $\\kappa$ 联系起来。\n\n**2. 数值实验和最小二乘估计**\n\n为了从涨落数据中估计 $\\gamma$ 和 $\\kappa$，我们将推导出的方程重排为线性形式。对于每个模式 $\\mathbf{k}$，我们有：\n$$\n\\gamma k^2 + \\kappa k^4 = \\frac{k_{\\mathrm{B}} T}{A \\left\\langle |h_{\\mathbf{k}}|^2 \\right\\rangle}\n$$\n该方程的形式为线性模型 $y = \\beta_1 x_1 + \\beta_2 x_2$，其中系数为 $\\beta_1 = \\gamma$ 和 $\\beta_2 = \\kappa$。线性回归的变量是：\n-   因变量：$Y_{\\mathbf{k}} = \\frac{k_{\\mathrm{B}} T}{A \\left\\langle |h_{\\mathbf{k}}|^2 \\right\\rangle_{\\text{sim}}}$\n-   自变量：$X_{1,\\mathbf{k}} = k^2$ 和 $X_{2,\\mathbf{k}} = k^4$\n\n对于每个指定的温度 $T_j$，数值实验按以下步骤进行：\n1.  **生成模式**：根据规则生成一组独立的波矢 $\\mathbf{k}_i$：$\\mathbf{k}_i = \\frac{2\\pi}{L}(n_x, n_y)$，其中整数索引 $|n_x|, |n_y| \\le n_{\\max}$，并遵循半平面约束（$n_y > 0$ 或 ($n_y = 0$ 且 $n_x > 0$)）。\n2.  **生成合成数据**：对于每个模式 $\\mathbf{k}_i$，计算真实的表面张力 $\\gamma_{\\text{true}}(T_j)$。使用上面推导的公式计算理论平均涨落 $\\mu_{\\mathbf{k}_i} = \\langle |h_{\\mathbf{k}_i}|^2 \\rangle$。根据规定，复高斯模式的模平方 $|h_{\\mathbf{k}}|^2$ 服从指数分布。我们从一个尺度（均值）参数为 $\\mu_{\\mathbf{k}_i}$ 的指数分布中抽取 $M$ 个 $|h_{\\mathbf{k}_i}|^2$ 的样本。这 $M$ 次抽样的样本均值提供了模拟的平均值 $\\left\\langle |h_{\\mathbf{k}_i}|^2 \\right\\rangle_{\\text{sim}}$。\n3.  **线性最小二乘拟合**：用所有模式 $\\{\\mathbf{k}_i\\}$ 的数据点构建一个线性系统。自变量矩阵 $X$ 的行为 $[k_i^2, k_i^4]$，因变量向量 $Y$ 的元素为 $Y_{\\mathbf{k}_i}$。使用线性最小二乘法求解系统 $Y = X \\beta$ 以得到 $\\beta = [\\gamma, \\kappa]^T$。这就得出了估计值 $\\gamma_{\\text{est}}(T_j)$。\n\n对于一系列温度 $T_j = T_0 + j\\,\\Delta T$（其中 $j \\in \\{-3, \\dots, 3\\}$），重复此过程。\n\n**3. 单位面积表面熵 $s^{\\sigma}$ 的计算**\n\n单位面积表面熵定义为 $s^{\\sigma} = -(\\frac{\\partial \\gamma}{\\partial T})$。我们按照要求，使用两种独立的方法从计算出的离散点集 $(\\gamma_{\\text{est}}(T_j), T_j)$ 中估计这个量。\n\n1.  **局部线性回归**：使用普通最小二乘法将一条直线 $\\gamma(T) = \\gamma_0 - s^{\\sigma}_{\\text{reg}} T$ 拟合到七个 $(\\gamma_{\\text{est}}(T_j), T_j)$ 数据点。估计的表面熵 $s^{\\sigma}_{\\text{reg}}$ 是拟合斜率的负值。此方法使用了温度窗口中的所有数据，提供了一个稳健的估计。\n\n2.  **中心有限差分**：此方法提供了在中心温度 $T_0$ 处的导数的局部估计。它使用在 $T_0 + \\Delta T$ 和 $T_0 - \\Delta T$ 处的估计 $\\gamma$ 值：\n    $$\n    s^{\\sigma}_{\\text{fd}} = - \\frac{\\gamma_{\\text{est}}(T_0 + \\Delta T) - \\gamma_{\\text{est}}(T_0 - \\Delta T)}{2 \\Delta T}\n    $$\n这个估计对单个 $\\gamma$ 估计中的噪声更敏感，但它是导数定义的直接实现。\n\n程序将为每个测试用例实现这一完整过程，根据指定的容差验证结果，并报告一个布尔值结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport collections\n\n# Define physical constants and ground truth model parameters\nKB_CONST = 1.380649e-23  # Boltzmann constant in J/K\nGAMMA_REF = 0.072       # Reference surface tension in N/m at T_ref\nT_REF = 300.0           # Reference temperature in K\nA_PARAM = 1.5e-4        # Temperature coefficient of surface tension in N/(m.K)\nS_SIGMA_TRUE = A_PARAM  # Ground truth for surface entropy per unit area\n\n# Define a named tuple for holding test case parameters for clarity\nTestCase = collections.namedtuple('TestCase', ['T0', 'delta_T', 'L', 'n_max', 'M', 'kappa'])\n\ndef gamma_true_model(T):\n    \"\"\"Computes the ground-truth surface tension at temperature T.\"\"\"\n    return GAMMA_REF - A_PARAM * (T - T_REF)\n\ndef estimate_gamma_at_temp(T, L, n_max, M, kappa, rng):\n    \"\"\"\n    Performs a numerical experiment to estimate gamma at a single temperature T.\n    The random number generator 'rng' is passed in to ensure sequence is maintained.\n    \"\"\"\n    area = L**2\n    \n    # 1. Generate wave vectors and their squared magnitudes\n    k_squared_vals = []\n    # Loop over integer indices to generate wave vectors k = (2*pi/L)*(nx, ny)\n    # The selection rule ensures we cover an independent half-plane of modes\n    for nx in range(-n_max, n_max + 1):\n        for ny in range(-n_max, n_max + 1):\n            if ny > 0 or (ny == 0 and nx > 0):\n                k_sq = ((2 * np.pi / L)**2) * (nx**2 + ny**2)\n                k_squared_vals.append(k_sq)\n    \n    k_squared_vals = np.array(k_squared_vals)\n    k_fourth_vals = k_squared_vals**2\n\n    # 2. Generate synthetic fluctuation data\n    # Calculate true gamma at this temperature to find theoretical mode variance\n    gamma_T_true = gamma_true_model(T)\n    \n    # Calculate the theoretical mean of |h_k|^2 for each mode\n    # |h_k|^2> = k_B * T / (A * (gamma*k^2 + kappa*k^4))\n    denominator = area * (gamma_T_true * k_squared_vals + kappa * k_fourth_vals)\n    # Avoid division by zero if any k or the entire denominator is zero\n    denominator[denominator == 0] = 1e-99\n    mean_h_k_sq = (KB_CONST * T) / denominator\n    \n    # Simulate the measurement of |h_k|^2> by averaging M samples\n    # |h_k|^2 is exponentially distributed with the mean calculated above\n    simulated_h_k_sq_mean = np.array([\n        np.mean(rng.exponential(scale=mean_val, size=M))\n        for mean_val in mean_h_k_sq\n    ])\n\n    # 3. Formulate and solve the linear least-squares problem\n    # The model is: gamma*k^2 + kappa*k^4 = k_B*T / (A * |h_k|^2>)\n    # We solve for [gamma, kappa]\n    Y = (KB_CONST * T) / (area * simulated_h_k_sq_mean)\n    X = np.vstack([k_squared_vals, k_fourth_vals]).T\n    \n    # Solve Y = X * [gamma, kappa]^T\n    coeffs, _, _, _ = np.linalg.lstsq(X, Y, rcond=None)\n    \n    gamma_est = coeffs[0]\n    return gamma_est\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and produce the final output.\n    \"\"\"\n    # Set a fixed random seed for reproducibility of the numerical experiment\n    rng = np.random.default_rng(42)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        TestCase(T0=298.0, delta_T=8.0, L=2.0e-7, n_max=6, M=1500, kappa=0.0),\n        TestCase(T0=360.0, delta_T=15.0, L=2.5e-7, n_max=8, M=2000, kappa=0.0),\n        TestCase(T0=320.0, delta_T=10.0, L=2.0e-7, n_max=8, M=2500, kappa=5.0e-19)\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        # Generate the list of temperatures for the current test case\n        temperatures = [case.T0 + j * case.delta_T for j in range(-3, 4)]\n        \n        # Estimate gamma for each temperature in the window\n        estimated_gammas = [\n            estimate_gamma_at_temp(T, case.L, case.n_max, case.M, case.kappa, rng)\n            for T in temperatures\n        ]\n        \n        # Estimate surface entropy s_sigma using two methods\n        \n        # 1. Local Linear Regression\n        # Fit a line to the (T, gamma) data points: gamma = slope * T + intercept\n        slope, _ = np.polyfit(temperatures, estimated_gammas, 1)\n        # s_sigma = -d(gamma)/dT, so it is the negative of the slope\n        s_sigma_reg = -slope\n        \n        # 2. Central Finite Difference\n        # Access the gamma estimates at T0 - delta_T and T0 + delta_T\n        # The list 'temperatures' has 7 elements, indexed 0..6\n        # j=-1 -> T0-delta_T -> index 2\n        # j=1  -> T0+delta_T -> index 4\n        gamma_minus = estimated_gammas[2]\n        gamma_plus = estimated_gammas[4]\n        s_sigma_fd = -(gamma_plus - gamma_minus) / (2 * case.delta_T)\n\n        # Verification against the specified conditions\n        # Condition 1: agreement between the two estimation methods\n        rel_diff_methods = abs(s_sigma_reg - s_sigma_fd) / S_SIGMA_TRUE\n        cond1 = rel_diff_methods = 0.10\n        \n        # Condition 2: accuracy of the regression-based estimate\n        rel_err_reg = abs(s_sigma_reg - S_SIGMA_TRUE) / S_SIGMA_TRUE\n        cond2 = rel_err_reg = 0.10\n        \n        # Final boolean result for the case is the logical AND of the two conditions\n        all_results.append(cond1 and cond2)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```", "id": "2792442"}]}