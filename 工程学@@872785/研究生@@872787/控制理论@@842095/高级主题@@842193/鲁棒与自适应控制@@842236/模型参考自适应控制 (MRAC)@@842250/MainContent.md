## 引言
在[控制工程](@entry_id:149859)领域，设计能够应对不确定性的控制器是一项核心挑战。物理系统的参数，如飞行器的气动系数、机器人的负载质量或[化学反应](@entry_id:146973)的速率常数，往往是未知或随时间变化的。模型参考[自适应控制](@entry_id:262887)（Model Reference Adaptive Control, MRAC）为此类问题提供了一套强大而优雅的解决方案。其核心思想是：定义一个具有理想性能的“参考模型”，并设计一个能够在线“学习”和调整自身参数的控制器，以强制被控对象的行为无论如何都去精确地模仿这个参考模型。

本文旨在系统地介绍MRAC的理论、应用与实践。我们将深入探讨其背后的数学原理，揭示[自适应控制](@entry_id:262887)器如何保证稳定性的同时实现高性能跟踪。文章将分为三个核心章节：在“原理与机制”中，我们将从基本框架出发，通过[李雅普诺夫方法](@entry_id:635639)推导[自适应律](@entry_id:276528)，并讨论[持续激励](@entry_id:263834)、[未建模动态](@entry_id:264781)等关键理论问题。随后的“应用与跨学科联系”章节将展示MRAC在航空航天、机器人、生物医学等领域的广泛应用，并探讨其与[鲁棒控制](@entry_id:260994)、机器学习等现代[范式](@entry_id:161181)的深刻联系。最后，在“动手实践”部分，我们将通过一系列精心设计的练习，将理论知识转化为解决实际问题的能力。现在，让我们从MRAC最核心的设计原理与机制开始。

## 原理与机制

在“引言”章节中，我们已经了解了模型参考[自适应控制](@entry_id:262887)（MRAC）的基本目标：设计一个能够在线调整自身参数的控制器，以强制一个参数未知或时变的“被控对象”系统的行为去精确地跟随一个给定的、性能优良的“参考模型”的行为。本章将深入探讨实现这一目标所需的核心原理与关键机制。我们将从系统设计的基本前提条件入手，通过严谨的理论推导，揭示[自适应律](@entry_id:276528)的内在工作方式，并最终讨论在实际应用中必须考虑的一些高级主题和限制。

### MRAC设计的核心目标与基本框架

模型参考[自适应控制](@entry_id:262887)的出发点是明确定义一个控制问题。我们考虑一个物理系统，即**被控对象（plant）**，其动态行为可以由一个[微分方程](@entry_id:264184)描述，但其中的一些物理参数是未知的。与此同时，我们定义一个**参考模型（reference model）**，它是一个具有理想动态特性的、完全已知的稳定系统。控制器的任务，就是根据被控对象输出与参考模型输出之间的**[跟踪误差](@entry_id:273267)（tracking error）**，实时调整其控制策略，最终目的是使这个误差趋近于零。

为了具体阐述，我们以一个简单的一阶[线性时不变](@entry_id:276287)（LTI）系统为例 [@problem_id:2725806]。假设被控对象的动态为：
$$
\dot{x}(t) = a x(t) + b u(t)
$$
其中 $x(t)$ 是系统的状态（例如温度、速度或角度），$u(t)$ 是控制输入。这里的参数 $a$ 和 $b$ 是未知的常数。我们只知道控制增益 $b$ 的符号，即 $\operatorname{sgn}(b)$，但不知道其具体大小。

我们期望该系统表现出如下参考模型的动态特性：
$$
\dot{x}_m(t) = a_m x_m(t) + b_m r(t)
$$
其中 $x_m(t)$ 是理想的模型状态，$r(t)$ 是外部给定的参考指令信号。参考模型的参数 $a_m$ 和 $b_m$ 是我们精心选择的，用以定义期望的响应特性，例如响应速度和[稳态](@entry_id:182458)增益。为了确保期望的行为是稳定的，我们要求 $a_m  0$。

控制的核心目标是让被控对象的状态 $x(t)$ 精确跟踪参考模型的状态 $x_m(t)$。为此，我们定义[跟踪误差](@entry_id:273267) $e(t) = x(t) - x_m(t)$。我们的最终目标是设计一个控制律 $u(t)$，它能够调整自身，使得对于任何有界的参考指令 $r(t)$，系统中的所有信号都保持有界，并且[跟踪误差](@entry_id:273267)能够渐近收敛到零，即：
$$
\lim_{t \to \infty} e(t) = 0
$$

这个看似简单的目标引出了一系列深刻的理论问题：我们应该如何构建控制器？设计控制器需要哪些关于被控对象的先验知识？我们如何设计参数的调整机制（即**[自适应律](@entry_id:276528)**），并保证整个闭环系统的稳定？接下来的小节将逐一回答这些问题。

### MRAC设计的基本前提条件

在着手设计[自适应控制](@entry_id:262887)器之前，我们必须明确，并非所有系统都能应用标准的MRAC方法。为了保证理论上的可行性和最终的稳定性，被控对象和我们选择的参考模型都必须满足一些基本假设。

#### 对被控对象的假设

标准的MRAC理论为了保证稳定性，通常需要对被控对象做出三个关键的先验假设 [@problem_id:1591785]：

1.  **已知的[相对阶](@entry_id:171358)**：被控对象[传递函数](@entry_id:273897)的[相对阶](@entry_id:171358)（分母多项式的阶数减去分子多项式的阶数）必须是已知的。[相对阶](@entry_id:171358)决定了从控制输入到系统输出的直接时间延迟。控制器结构的设计，特别是为了保证稳定性而引入的滤波器，直接依赖于这个数值。如果[相对阶](@entry_id:171358)未知，就无法正确构建控制律和保证稳定性的数学证明。

2.  **[最小相位系统](@entry_id:268223)**：被控对象的[传递函数](@entry_id:273897)必须是**[最小相位](@entry_id:273619)**的，这意味着其所有的零点都位于复平面的左半部分（具有负实部）。在控制理论中，[非最小相位](@entry_id:267340)（即在右半平面有零点）的系统具有内在的性能限制，例如在[阶跃响应](@entry_id:148543)中会出现初始的“反向”行为。在MRAC中，控制器[实质](@entry_id:149406)上试图“抵消”或“逆转”被控对象的某些动态。如果系统存在不稳定的零点，这种抵消操作会导致内部不稳定，从而破坏整个[闭环系统](@entry_id:270770)的稳定性。

3.  **已知的高频增益符号**：被控对象[传递函数](@entry_id:273897)的高频增益（通常表示为 $k_p$ 或对于[一阶系统](@entry_id:147467)中的 $b$）的符号必须是已知的。高频增益决定了在极高频率下输入和输出之间的瞬时关系，其符号决定了控制作用的正确“方向”。例如，如果控制器认为增加输入会提高输出，但实际上会降低输出（即增益符号为负），那么基于这个错误假设的自适应调整将会是正反馈，迅速导致系统失稳。虽然[自适应控制](@entry_id:262887)器可以学习增益的大小，但学习其符号则要困难得多，标准设计中通常假定其已知。

#### 对参考模型的选择

我们也不能随意选择参考模型。参考模型的选择直接决定了我们为被控对象设定的性能目标，因此也必须遵循两条基本原则 [@problem_id:1591803]：

1.  **参考模型必须是稳定的**：这一点非常直观。参考模型定义了我们期望的“理想”行为。如果我们选择一个不稳定的参考模型，例如一个其输出会无界增长的模型，那么MRAC的目标就变成了迫使被控对象去跟踪一个发散的轨迹。这不仅在物理上是不可取的，而且会驱动被控对象和控制器进入[不稳定状态](@entry_id:197287)。因此，参考模型的所有极点都必须位于稳定的左半复平面。

2.  **参考模型的[相对阶](@entry_id:171358)必须不小于被控对象的[相对阶](@entry_id:171358)**：这个条件源于控制器的**因果性（causality）**或物理[可实现性](@entry_id:193701)。从概念上讲，为了让被控对象 $G_p(s)$ 的输出完全匹配模型 $G_m(s)$ 的输出，所需的[控制信号](@entry_id:747841) $U(s)$ 可以（非正式地）表示为 $U(s) = G_p(s)^{-1} G_m(s) R(s)$。如果参考模型的[相对阶](@entry_id:171358) $n_m^*$ 小于被控对象的[相对阶](@entry_id:171358) $n_p^*$，那么控制器 $G_p(s)^{-1} G_m(s)$ 的[相对阶](@entry_id:171358)将为负值。这意味着它的分子多项式阶数高于分母，对应于一个需要对输入信号进行[微分](@entry_id:158718)的系统。理想的微分器在物理上是不可实现的（非因果的），因为它需要预知输入信号未来的变化。因此，为了得到一个物理上可实现的控制器，必须满足 $n_m^* \ge n_p^*$。

满足了上述对被控对象和参考模型的前提条件后，我们就可以进入[自适应律](@entry_id:276528)设计的核心阶段。

### 自适应机制的设计：从梯度法到李雅普诺夫综合

[自适应律](@entry_id:276528)是MRAC的核心，它描述了控制器参数如何根据[跟踪误差](@entry_id:273267)进行实时更新。历史上，有两种主要的设计哲学：基于[梯度下降](@entry_id:145942)的MIT规则和基于[稳定性理论](@entry_id:149957)的李雅普诺夫综合法。

#### MIT规则与[李雅普诺夫方法](@entry_id:635639)的对比

**MIT规则**是最早期的[自适应律](@entry_id:276528)设计方法之一 [@problem_id:1591793]。其思想非常直观：定义一个代价函数，通常是瞬时误差的平方 $J(\theta) = \frac{1}{2} e^2$，然后沿着该[代价函数](@entry_id:138681)对控制器参数 $\theta$ 的负梯度方向进行调整，以期最小化误差。参数的更新法则形如：
$$
\frac{d\theta}{dt} = - \gamma \frac{\partial J}{\partial \theta} = - \gamma e \frac{\partial e}{\partial \theta}
$$
其中 $\gamma > 0$ 是一个称为**自适应增益**或[学习率](@entry_id:140210)的正常数。这种方法是性能驱动的，试图在每个瞬间都减小误差。然而，MIT规则的主要缺陷在于它只保证了参数朝着减小瞬时误差的方向调整，但并未提供整个闭环系统长期稳定性的严格保证。在某些情况下，它可能导致系统[振荡](@entry_id:267781)甚至不稳定。

为了克服这一根本性缺陷，现代MRAC设计普遍采用**李雅普诺夫综合法（Lyapunov synthesis）**。与MIT规则不同，[李雅普诺夫方法](@entry_id:635639)将**稳定性**作为设计的首要出发点。其核心思想是构造一个李雅普诺夫函数 $V$，它同时是[跟踪误差](@entry_id:273267) $e$ 和参数误差 $\tilde{\theta}$ 的函数。然后，我们去**推导**出一个[自适应律](@entry_id:276528)，这个[自适应律](@entry_id:276528)能够确保李雅普诺夫函数的时间导数 $\dot{V}$ 是负半定的（即 $\dot{V} \le 0$）。如果能做到这一点，[李雅普诺夫稳定性理论](@entry_id:177166)就能保证 $V$ 是有界的，进而保证[跟踪误差](@entry_id:273267)和参数误差都是有界的，从而确保了整个系统的稳定性。这种方法不是简单地优化性能，而是通过构造性的证明来确保稳定。

#### 基于李雅普诺夫理论的直接MRAC设计

让我们回到前面的[一阶系统](@entry_id:147467)示例，详细展示如何使用[李雅普诺夫方法](@entry_id:635639)设计一个[自适应控制](@entry_id:262887)器 [@problem_id:2725806]。

1.  **推导误差动态方程**：我们从[跟踪误差](@entry_id:273267)的导数开始：
    $$
    \dot{e} = \dot{x} - \dot{x}_m = (a x + b u) - (a_m x_m + b_m r)
    $$
    为了得到一个关于误差 $e$ 的方程，我们巧妙地添加并减去 $a_m x$：
    $$
    \dot{e} = a_m(x - x_m) + (a - a_m)x + b u - b_m r = a_m e + (a - a_m)x + b u - b_m r
    $$
    这个方程被称为**误差动态方程**。它描述了[跟踪误差](@entry_id:273267)如何随[时间演化](@entry_id:153943)。我们的目标是设计 $u(t)$ 来消除等式右边除 $a_m e$ 之外的所有项，从而使误差动态衰减为 $\dot{e} = a_m e$（由于 $a_m  0$，误差将[指数收敛](@entry_id:142080)到零）。

2.  **理想控制器与匹配条件**：如果参数 $a$ 和 $b$ 是已知的，我们可以设计一个“理想”的控制器 $u^*(t)$ 来完美地实现这一目标。该理想控制器需要满足：
    $$
    (a - a_m)x + b u^* - b_m r = 0
    $$
    解出 $u^*$，我们得到：
    $$
    u^*(t) = \frac{a_m - a}{b} x(t) + \frac{b_m}{b} r(t)
    $$
    这个表达式揭示了理想控制输入的结构：它是系统状态 $x(t)$ 和参考指令 $r(t)$ 的[线性组合](@entry_id:154743)。这启发我们，即使在 $a$ 和 $b$ 未知的情况下，也应该采用类似的控制器结构：
    $$
    u(t) = \theta_1(t) x(t) + \theta_2(t) r(t) = \theta(t)^\top \phi(t)
    $$
    其中 $\theta(t) = \begin{pmatrix} \theta_1(t)  \theta_2(t) \end{pmatrix}^\top$ 是待调整的控制器参数向量，而 $\phi(t) = \begin{pmatrix} x(t)  r(t) \end{pmatrix}^\top$ 是由可测量信号组成的**回归向量（regressor vector）**。这种假设，即存在一个常数向量 $\theta^*$ 使得理想控制 $u^*$ 可以被表示为 $\theta^{*\top} \phi(t)$，被称为**匹配条件（matching condition）**。在这里，理想参数为 $\theta^* = \begin{pmatrix} \frac{a_m - a}{b}  \frac{b_m}{b} \end{pmatrix}^\top$。

3.  **参数误差形式的误差动态**：将我们设计的自适应控制器 $u = \theta^\top \phi$ 代入误差动态方程，并利用 $u^*$ 的表达式，我们得到：
    $$
    \dot{e} = a_m e + b(u - u^*) = a_m e + b(\theta^\top \phi - \theta^{*\top} \phi) = a_m e + b (\theta - \theta^*)^\top \phi
    $$
    定义参数误差 $\tilde{\theta}(t) = \theta(t) - \theta^*$，误差动态最终可以写成一个简洁而优美的形式：
    $$
    \dot{e}(t) = a_m e(t) + b \tilde{\theta}(t)^\top \phi(t)
    $$

4.  **构造[李雅普诺夫函数](@entry_id:273986)并推导[自适应律](@entry_id:276528)**：现在我们构造一个[李雅普诺夫函数](@entry_id:273986)候选者，它同时包含了[跟踪误差](@entry_id:273267)和参数误差：
    $$
    V(e, \tilde{\theta}) = \frac{1}{2} e^2 + \frac{1}{2} |b| \tilde{\theta}^\top \Gamma^{-1} \tilde{\theta}
    $$
    这里，$\Gamma$ 是一个对称正定的矩阵，称为自适应增益矩阵。$|b|$ 的出现是为了在求导后能够处理未知的 $b$。对 $V$ 求时间导数：
    $$
    \dot{V} = e \dot{e} + |b| \tilde{\theta}^\top \Gamma^{-1} \dot{\tilde{\theta}}
    $$
    因为 $\theta^*$ 是常数，所以 $\dot{\tilde{\theta}} = \dot{\theta}$。将误差动态方程代入：
    $$
    \dot{V} = e(a_m e + b \tilde{\theta}^\top \phi) + |b| \tilde{\theta}^\top \Gamma^{-1} \dot{\theta} = a_m e^2 + e b \tilde{\theta}^\top \phi + |b| \tilde{\theta}^\top \Gamma^{-1} \dot{\theta}
    $$
    $$
    \dot{V} = a_m e^2 + \tilde{\theta}^\top (b \phi e + |b| \Gamma^{-1} \dot{\theta})
    $$
    为了使 $\dot{V} \le 0$，我们的目标是选择 $\dot{\theta}$ 来消除括号中的[交叉](@entry_id:147634)项。令括号内的表达式为零：
    $$
    b \phi e + |b| \Gamma^{-1} \dot{\theta} = 0 \quad \implies \quad \dot{\theta} = - \Gamma \frac{b}{|b|} \phi e
    $$
    由于 $\frac{b}{|b|} = \operatorname{sgn}(b)$，我们得到了最终的[自适应律](@entry_id:276528)：
    $$
    \dot{\theta}(t) = - \Gamma \operatorname{sgn}(b) \phi(t) e(t)
    $$
    这个[自适应律](@entry_id:276528)是物理可实现的，因为它只需要高频增益 $b$ 的符号，而不需要其大小。例如，对于我们的控制器 $u = \theta_1 x + \theta_2 r$，具体的更新法则就是 [@problem_id:1591807]：
    $$
    \dot{\theta}_1(t) = - \gamma_1 \operatorname{sgn}(b) x(t) e(t)
    $$
    $$
    \dot{\theta}_2(t) = - \gamma_2 \operatorname{sgn}(b) r(t) e(t)
    $$
    将这个[自适应律](@entry_id:276528)代入 $\dot{V}$ 的表达式，[交叉](@entry_id:147634)项被消除，我们得到：
    $$
    \dot{V} = a_m e^2
    $$
    由于我们选择的参考模型是稳定的（$a_m  0$），所以 $\dot{V} \le 0$。根据李雅普诺夫理论，这保证了 $e(t)$ 和 $\tilde{\theta}(t)$ 都是有界的。进一步可以证明，系统中的所有信号（$x(t), u(t)$ 等）也都是有界的。更重要的是，通过应用**[Barbalat引理](@entry_id:170875)**，可以证明[跟踪误差](@entry_id:273267)最终会收敛到零，即 $\lim_{t\to\infty} e(t) = 0$。至此，我们通过一个严谨的、以稳定性为核心的推导，成功地设计出了一个有效的自适应控制器。

### 直接与间接自适应控制架构

前面所推导的MRAC方案属于**直接[自适应控制](@entry_id:262887)（Direct MRAC）** [@problem_id:1591812]。在这种架构中，[自适应律](@entry_id:276528)直接更新**控制器**的参数（例如 $\theta_1, \theta_2$），其目标是直接使[跟踪误差](@entry_id:273267) $e(t)$ 最小化。整个过程中，系统从不试图去显式地估计被控对象的未知物理参数（例如 $a, b$）。

与此相对的是**间接自适应控制（Indirect MRAC）**。这种方法遵循一种“辨识-控制”分离的哲学，分为两步进行：
1.  **[参数辨识](@entry_id:275549)**：设计一个在线的**[参数估计](@entry_id:139349)器（parameter estimator）**，它利用被控对象的输入 $u(t)$ 和输出 $y_p(t)$ 来实时地生成对未知物理参数的估计值，例如 $\hat{a}(t)$ 和 $\hat{b}(t)$。
2.  **控制器参数计算**：根据**[确定性等价原理](@entry_id:177529)（certainty equivalence principle）**，我们将这些实时估计值 $\hat{a}(t), \hat{b}(t)$ 当作是真实的参数值，然后用它们来计算控制器参数。例如，在我们的例子中，控制器参数会根据理想匹配关系实时计算：
    $$
    k_y(t) = \frac{a_m - \hat{a}(t)}{\hat{b}(t)}, \quad k_r(t) = \frac{b_m}{\hat{b}(t)}
    $$

直接法和间接法各有优缺点。直接法通常结构更简单，计算量可能更小。间接法则提供对物理参数的明确估计，这在某些应用中可能很有用，例如用于系统监控或故障诊断。需要强调的是，没有一种方法在所有情况下都绝对优于另一种，例如，在[收敛速度](@entry_id:636873)方面，两者并无普遍的快慢之分。

### 高级主题与实际考量

虽然我们已经建立了一套看似完美的理论框架，但在将MRAC应用于实际系统时，还会遇到一些更深层次的问题。

#### [持续激励](@entry_id:263834)与参数收敛问题

我们已经证明，只要设计得当，MRAC可以保证[跟踪误差](@entry_id:273267) $e(t)$ 收敛到零。一个自然的问题是：这是否意味着我们估计的控制器参数 $\theta(t)$ 也会收敛到它们的“真实”理想值 $\theta^*$？

答案是：**不一定** [@problem_id:1591808]。[跟踪误差](@entry_id:273267)收敛是比参数收敛更弱的条件。参数能否收敛到其唯一[真值](@entry_id:636547)，取决于系统是否受到**[持续激励](@entry_id:263834)（Persistent Excitation, PE）**。直观地说，输入信号 $r(t)$ 必须“足够丰富”，能够激励起系统所有的动态模式，这样[自适应算法](@entry_id:142170)才能从系统的响应中“学习”到所有未知参数的信息。

一个典型的非[持续激励](@entry_id:263834)信号是常数输入 [@problem_id:1591798]。假设在我们的系统中，参考指令 $r(t)$ 是一个非零常数 $R_0$。系统稳定后，$\dot{y}_p = \dot{y}_m = 0$，[跟踪误差](@entry_id:273267) $e=0$。此时，模型和被控对象的[稳态](@entry_id:182458)输出均为 $y_{p,ss} = y_{m,ss} = - (b_m/a_m) R_0$。将这些[稳态](@entry_id:182458)值代入被控对象的闭环动态方程，并令 $\dot{y}_p = 0$，我们得到一个关于[稳态](@entry_id:182458)控制器参数 $\hat{k}_x(\infty)$ 和 $\hat{k}_r(\infty)$ 的[约束方程](@entry_id:138140)：
$$
(a_p + b_p \hat{k}_x(\infty)) \left(-\frac{b_m}{a_m} R_0\right) + (b_p \hat{k}_r(\infty)) R_0 = 0
$$
整理后可得：
$$
\hat{k}_x(\infty) - \frac{a_m b_p}{b_m} \hat{k}_r(\infty) = -\frac{a_p}{b_m}
$$
这是一个关于两个未知参数 $\hat{k}_x(\infty)$ 和 $\hat{k}_r(\infty)$ 的**单个线性方程**。这意味着，任何满足这条直线关系的参数组合都能使系统在常数输入下实现零[稳态](@entry_id:182458)[跟踪误差](@entry_id:273267)。自适应系统找到了一个能解决当前特定任务（跟踪一个常数指令）的解，但由于输入信号不够丰富（只激励了系统的[直流增益](@entry_id:267449)），它无法从无限多的可行解中唯一地辨识出那个“真正的”理想参数 $\theta^*$。

为了保证参数收敛，回归向量 $\phi(t)$ 必须是[持续激励](@entry_id:263834)的。这通常要求参考输入信号 $r(t)$ 包含足够多的频率分量，例如，至少包含与待辨识参数数量相等的不同频率的[正弦波](@entry_id:274998)之和。

#### 严格正实条件与[未建模动态](@entry_id:264781)

在推导一阶系统的[自适应律](@entry_id:276528)时，李雅普诺夫分析相对直接。对于更高阶的系统，稳定性证明通常依赖于一个关键的性质：某个误差[传递函数](@entry_id:273897)必须是**严格正实（Strictly Positive Real, SPR）**的。

一个[传递函数](@entry_id:273897) $G(s)$ 被称为SPR，如果 [@problem_id:2725814]：
1.  $G(s)$ 是稳定的（所有极点在左半平面）。
2.  对于所有实数频率 $\omega$，其频率响应的实部为正，即 $\operatorname{Re}[G(j\omega)] > 0$。

在[奈奎斯特图](@entry_id:264096)上，这意味着 $G(j\omega)$ 的曲线完全位于复平面的右半部分。从时域角度，根据**Kalman-Yakubovich-Popov (KYP)引理**，一个[传递函数](@entry_id:273897) $G(s) = C(sI-A)^{-1}B$ 是SPR的，等价于存在对称正定矩阵 $P$ 和 $Q$，满足如下[矩阵方程](@entry_id:203695)：
$$
A^\top P + PA = -Q
$$
$$
PB = C^\top
$$
在MRAC的稳定性证明中，我们通过各种设计（如滤波）来构造一个误差系统，使其[传递函数](@entry_id:273897)满足SPR条件，从而保证李雅普诺夫导数的负定性。

然而，在现实世界中，任何数学模型都是对物理系统的一种近似。实际系统总是存在**[未建模动态](@entry_id:264781)（unmodeled dynamics）**，特别是那些响应速度很快的高频动态，例如传感器延迟、执行器动态等。这些[未建模动态](@entry_id:264781)是MRAC在实际应用中面临的最大挑战之一 [@problem_id:1591826]。

假设我们的理想模型是一个[一阶系统](@entry_id:147467) $G_{p,nom}(s) = \frac{K}{s+a}$，但真实系统因为一个快速的执行器动态，其[传递函数](@entry_id:273897)更准确地描述为 $G_{p,true}(s) = \frac{K}{s+a} \cdot \frac{p}{s+p}$，其中 $p \gg a$。这个额外的高频极点 $s=-p$ 会引入随频率增加的**相位滞后**。[传递函数](@entry_id:273897)的总相位为：
$$
\angle G_{p,true}(j\omega) = -\arctan\left(\frac{\omega}{a}\right) - \arctan\left(\frac{\omega}{p}\right)
$$
当没有[未建模动态](@entry_id:264781)时（即 $p \to \infty$），相位角始终在 $-90^\circ$ 和 $0^\circ$ 之间，满足SPR的相位条件（对于一阶系统，SPR要求相位在 $\pm 90^\circ$ 之内）。但当存在高频极点时，总的[相位滞后](@entry_id:172443)会更严重。当频率升高到某个临界值 $\omega_c$ 时，总相位可能会达到 $-90^\circ$ 的边界。我们可以通过求解 $\angle G_{p,true}(j\omega_c) = -90^\circ$ 来找到这个临界频率，这等价于 $\arctan(\frac{\omega_c}{a}) + \arctan(\frac{\omega_c}{p}) = 90^\circ$。利用[三角恒等式](@entry_id:165065)可以求得：
$$
\omega_c = \sqrt{ap}
$$
当工作频率超过 $\omega_c$ 时，系统的相位将超出 $-90^\circ$，SPR条件被破坏。这意味着在这些高频段，误差系统不再具有保证稳定所需的“无源性”，[自适应律](@entry_id:276528)可能会与高频动态发生非预期的相互作用，导致参数漂移、系统[振荡](@entry_id:267781)甚至失稳。这就是为什么在实践中，MRAC系统对高频噪声和[未建模动态](@entry_id:264781)非常敏感，通常需要结合鲁棒控制技术（如参数投影、$\sigma$-修正等）来缓解这些问题，确保在真实环境下的稳定运行。