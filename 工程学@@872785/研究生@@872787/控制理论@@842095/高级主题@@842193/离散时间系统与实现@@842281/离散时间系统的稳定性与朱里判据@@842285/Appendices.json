{"hands_on_practices": [{"introduction": "本练习旨在搭建起舒尔稳定性（所有极点均在单位圆内）的抽象定义与系统参数的具体代数条件之间的桥梁。通过推导二阶多项式的稳定性判据，您将看到这些条件如何在系数空间中定义出一个简单、具体的几何区域，从而对稳定性如何从 z 平面映射到参数平面建立起基础性的理解。[@problem_id:2747062]", "problem": "考虑一个关于复变量 $z$ 的首一二次多项式 $p(z)=z^{2}+a_{1}z+a_{2}$，其中参数 $a_{1}$ 和 $a_{2}$ 为实数。在离散时间（DT）稳定性分析中，一个多项式被称为舒尔（Schur）稳定，当且仅当其所有根都严格位于开单位圆盘 $\\{z\\in\\mathbb{C}:|z|1\\}$ 内部。从这个定义出发，利用单位圆盘与开左半平面之间的任一严格证明的变换，并结合一个二次多项式连续时间稳定性的充要条件检验，推导出刻画 $p(z)$ 舒尔稳定性的关于系数 $a_{1}$ 和 $a_{2}$ 的完整线性不等式约束集。然后，解释每个约束如何限制极点（根）相对于单位圆的位置，明确地将这些约束与边界点 $z=1$ 和 $z=-1$ 以及根的乘积联系起来。\n\n最后，假设系数对 $(a_{1},a_{2})$ 是从矩形区域 $\\{(a_{1},a_{2})\\in\\mathbb{R}^{2}:-2\\le a_{1}\\le 2,\\,-1.5\\le a_{2}\\le 1.5\\}$ 中均匀抽取的。计算在此分布下 $p(z)$ 是舒尔稳定的确切概率（以一个最简分数表示）。将你的最终答案以一个无单位的单一数字形式给出。如果进行任何数值计算，请给出精确结果；无需四舍五入。", "solution": "所陈述的问题是适定的、有科学依据且自洽的。这是离散时间线性系统稳定性分析中的一个标准练习。我们按要求进行推导。\n\n所考虑的多项式是 $p(z) = z^{2} + a_{1}z + a_{2}$，其中 $a_{1}$ 和 $a_{2}$ 是实数参数。一个多项式是舒尔稳定的，当且仅当其所有根都严格位于开单位圆盘 $\\{z \\in \\mathbb{C} : |z|  1\\}$ 内部。\n\n我们将采用双线性变换，该变换将 $w$ 平面的开左半平面映射到 $z$ 平面的开单位圆盘。该变换由下式给出：\n$$ z = \\frac{1+w}{1-w} $$\n一个多项式 $p(z)$ 是舒尔稳定的，当且仅当变换后的关于 $w$ 的多项式（我们称之为 $q(w)$）的所有根都位于开左半平面内（即，是赫尔维茨（Hurwitz）稳定的）。将该变换代入多项式方程 $p(z)=0$：\n$$ \\left(\\frac{1+w}{1-w}\\right)^{2} + a_{1}\\left(\\frac{1+w}{1-w}\\right) + a_{2} = 0 $$\n为了消除分母，我们将整个方程乘以 $(1-w)^{2}$，假设 $w \\neq 1$（这对应于 $z \\to \\infty$，而不是首一多项式的根）。\n$$ (1+w)^{2} + a_{1}(1+w)(1-w) + a_{2}(1-w)^{2} = 0 $$\n展开各项：\n$$ (1 + 2w + w^{2}) + a_{1}(1 - w^{2}) + a_{2}(1 - 2w + w^{2}) = 0 $$\n收集 $w$ 的各次幂的系数：\n$$ w^{2}(1 - a_{1} + a_{2}) + w(2 - 2a_{2}) + (1 + a_{1} + a_{2}) = 0 $$\n令这个变换后的多项式为 $q(w) = A w^{2} + B w + C$，其中系数为：\n$$ A = 1 - a_{1} + a_{2} $$\n$$ B = 2(1 - a_{2}) $$\n$$ C = 1 + a_{1} + a_{2} $$\n对于一个实系数的二次多项式是赫尔维茨稳定的，其所有系数符号相同是充要条件。由于一个代数方程乘以 $-1$ 不会改变其根，我们可以不失一般性地假设所有系数都为正。\n所有系数均为负（$A0$, $B0$, $C0$）的情况要求 $B = 2(1-a_2)  0$，这意味着 $a_2 > 1$。如果 $z_1, z_2$ 是 $p(z)$ 的根，那么根据韦达定理（Vieta's formulas），它们的乘积是 $z_1 z_2 = a_2$。如果 $a_2 > 1$，则 $|z_1 z_2| = |a_2| = a_2 > 1$。这意味着至少有一个根的模必须大于1，这违反了舒尔稳定性的条件。因此，对于一个稳定系统，所有系数均为负的情况是不可能的。\n因此，我们必须有 $A>0$，$B>0$，和 $C>0$。这些严格不等式是必需的，因为如果任何系数为零，多项式的阶数会降低，这对应于 $p(z)$ 的一个根位于单位圆的边界上（具体来说，$A=0 \\implies p(-1)=0$ 且 $C=0 \\implies p(1)=0$），这并非严格稳定。\n\n关于 $a_1$ 和 $a_2$ 的线性不等式约束集是：\n1. $ A = 1 - a_{1} + a_{2} > 0 $\n2. $ B = 2(1 - a_{2}) > 0 \\implies 1 - a_{2} > 0 \\implies a_{2}  1 $\n3. $ C = 1 + a_{1} + a_{2} > 0 $\n\n这三个不等式定义了给定二次多项式的舒尔稳定区域。\n\n接下来，我们解释这些约束。\n变换后多项式的系数 $A$ 和 $C$ 就是原始多项式在 $z=-1$ 和 $z=1$ 处的值：\n$A = p(-1) = (-1)^{2} + a_{1}(-1) + a_{2} = 1 - a_{1} + a_{2}$。\n$C = p(1) = 1^{2} + a_{1}(1) + a_{2} = 1 + a_{1} + a_{2}$。\n\n1.  约束 $1 + a_{1} + a_{2} > 0$ 等价于 $p(1) > 0$。点 $z=1$ 位于单位圆的边界上。如果存在一个实根 $z_r \\ge 1$，由于另一个根 $z'$ 必须满足 $z_r z' = a_2$ 和 $z_r+z'=-a_1$，并且对于实数 $x$ 的抛物线 $p(x)$ 开口向上，那么 $p(1)$ 将是非正的。因此，$p(1) > 0$ 可以防止任何实根位于 $z=1$ 或其外部。\n\n2.  约束 $1 - a_{1} + a_{2} > 0$ 等价于 $p(-1) > 0$。点 $z=-1$ 也位于单位圆的边界上。通过类似的推理，如果存在一个实根 $z_r \\le -1$，那么 $p(-1)$ 将是非正的。因此，$p(-1) > 0$ 可以防止任何实根位于 $z=-1$ 或其外部。\n\n3.  约束 $a_{2}  1$。根据韦达定理，$a_2$ 是根的乘积，即 $a_{2} = z_{1}z_{2}$。舒尔稳定性的条件是 $|z_1|1$ 和 $|z_2|1$，这意味着 $|z_1 z_2|  1$，即 $|a_2|  1$。这等价于 $-1  a_2  1$。我们推导出的约束是 $a_2  1$。另一半，$a_2 > -1$，是前两个约束的推论：将 $1 + a_{1} + a_{2} > 0$ 和 $1 - a_{1} + a_{2} > 0$ 相加得到 $2 + 2a_{2} > 0$，即 $a_{2} > -1$。如果根是共轭复数，$z_{1,2} = r \\exp(\\pm i\\theta)$，它们的乘积是 $a_2 = z_1 z_2 = r^2$。条件 $a_2  1$ 直接转化为 $r^2  1$，这意味着根的模 $r$ 小于1。因此，这个约束直接保证了复数根的稳定性，并且与实数根的稳定性条件相一致。\n\n最后，我们计算概率。在 $(a_{1}, a_{2})$ 平面上的舒尔稳定区域是由以下不等式定义的一个三角形：\n- $a_{2}  1$\n- $a_{2} > a_{1} - 1$\n- $a_{2} > -a_{1} - 1$\n\n该三角形的顶点通过求解等式得到：\n- $a_2=1$ 和 $a_2=a_1-1 \\implies 1=a_1-1 \\implies a_1=2$。顶点：$(2, 1)$。\n- $a_2=1$ 和 $a_2=-a_1-1 \\implies 1=-a_1-1 \\implies a_1=-2$。顶点：$(-2, 1)$。\n- $a_2=a_1-1$ 和 $a_2=-a_1-1 \\implies a_1-1 = -a_1-1 \\implies 2a_1=0 \\implies a_1=0$，得到 $a_2=-1$。顶点：$(0, -1)$。\n稳定区域是一个顶点分别为 $(-2, 1)$、$(2, 1)$ 和 $(0, -1)$ 的三角形。\n这个三角形的面积，记为 $\\mathcal{A}_{\\text{stable}}$，是 $\\frac{1}{2} \\times \\text{底} \\times \\text{高}$。底是从 $(-2, 1)$ 到 $(2, 1)$ 的线段，长度为 $2 - (-2) = 4$。高是顶点 $(0, -1)$ 到直线 $a_{2}=1$ 的垂直距离，即 $1 - (-1) = 2$。\n$$ \\mathcal{A}_{\\text{stable}} = \\frac{1}{2} \\times 4 \\times 2 = 4 $$\n系数对 $(a_1, a_2)$ 是从矩形区域 $R = \\{(a_1, a_2) : -2 \\le a_1 \\le 2, -1.5 \\le a_2 \\le 1.5\\}$ 中均匀抽取的。\n这个矩形区域的面积 $\\mathcal{A}_{\\text{rect}}$ 是：\n$$ \\mathcal{A}_{\\text{rect}} = (2 - (-2)) \\times (1.5 - (-1.5)) = 4 \\times 3 = 12 $$\n为了求概率，我们必须确定稳定三角形与抽样矩形区域的交集面积。三角形的 $a_1$ 坐标范围从 $-2$ 到 $2$，这完全包含在矩形区域的 $a_1$ 范围 $[-2, 2]$ 内。三角形的 $a_2$ 坐标范围从 $-1$ 到 $1$，这完全包含在矩形区域的 $a_2$ 范围 $[-1.5, 1.5]$ 内。因此，稳定三角形完全位于抽样矩形区域内部。\n$p(z)$ 是舒尔稳定的概率是稳定区域的面积与总抽样区域面积之比：\n$$ P(\\text{stable}) = \\frac{\\mathcal{A}_{\\text{stable}}}{\\mathcal{A}_{\\text{rect}}} = \\frac{4}{12} = \\frac{1}{3} $$\n这就是确切的概率。", "answer": "$$ \\boxed{\\frac{1}{3}} $$", "id": "2747062"}, {"introduction": "在二阶系统分析的基础上，本问题要求您将 Jury 判据的完整递归方法应用于一个包含可变参数 $k$ 的三阶系统。这种练习代表了控制工程中的一项常见任务：确定可调控制器增益的精确范围，以保证闭环系统保持稳定。它将巩固您对高阶系统进行符号化稳定性分析的能力。[@problem_id:2747037]", "problem": "一个离散时间线性时不变系统由特征多项式 $p(z) = z^{3} + z^{2} + (2 - k) z + k$ 刻画，其中 $k \\in \\mathbb{R}$。一个实系数多项式是舒尔稳定的，当且仅当其所有零点都严格位于开单位圆盘 $\\{z \\in \\mathbb{C} : |z|  1\\}$ 内部。Jury 稳定性判据提供了一个充要过程，其基本思想是通过映射 $z \\mapsto 1/z$ 将多项式关于单位圆进行反转，并递归地构造系数为原多项式系数的仿射组合的降阶多项式，通过检验这些系数的一组有限的严格不等式来证明舒尔稳定性。\n\n从舒尔稳定性的定义和 Jury 判据对3阶多项式的构造方法（多项式反转和递归消元）出发，推导针对上述多项式 $p(z)$ 的全部充要严格不等式，并用它们来刻画使 $p(z)$ 舒尔稳定的所有实数 $k$ 的集合。\n\n令 $\\mathcal{K} \\subset \\mathbb{R}$ 表示所有这样的 $k$ 的集合。集合 $\\mathcal{K}$ 的勒贝格测度（即总长度）是多少？请以单个实数形式给出最终答案。无需四舍五入。", "solution": "该问题要求我们确定使多项式 $p(z) = z^{3} + z^{2} + (2 - k) z + k$ 舒尔稳定的参数 $k$ 的实数值集合，然后计算该集合的勒贝格测度。一个多项式是舒尔稳定的，如果其所有根都严格位于复平面的开单位圆盘内部。推导必须从 Jury 稳定性判据的基本原理出发。\n\n设多项式的一般形式为 $P_n(z) = \\sum_{i=0}^{n} a_i z^i$，其中系数为实数且 $a_n > 0$。对于 $p(z)$，我们有阶数 $n=3$，系数为 $a_3=1$，$a_2=1$，$a_1=2-k$ 和 $a_0=k$。首项系数 $a_3=1$ 为正。\n\n舒尔稳定性的充要条件可以从一个递归过程中推导出来。$P_n(z)$ 的稳定性等价于满足 $|a_0/a_n|  1$ 以及一个降阶多项式 $P_{n-1}(z)$ 的舒尔稳定性。在应用递归步骤之前，必须检查两个初步的必要条件：\n1. $P_n(1) > 0$\n2. $(-1)^n P_n(-1) > 0$\n\n我们将这些条件应用于给定的多项式 $p(z)$。\n\n第一个必要条件：$p(1) > 0$。\n$$p(1) = (1)^3 + (1)^2 + (2-k)(1) + k = 1 + 1 + 2 - k + k = 4$$\n不等式 $4 > 0$ 总是成立，对 $k$ 不施加任何约束。\n\n第二个必要条件：对于 $n=3$，此条件为 $(-1)^3 p(-1) > 0$，即 $p(-1)  0$。\n$$p(-1) = (-1)^3 + (-1)^2 + (2-k)(-1) + k = -1 + 1 - 2 + k + k = 2k - 2$$\n不等式 $2k - 2  0$ 简化为 $2k  2$，这给出了约束条件 $k  1$。\n\n现在，我们根据题目要求，进行测试的递归部分。递归的基本步骤要求常数项的绝对值严格小于首项系数的绝对值。\n对于 $p(z)$，此条件为 $|a_0|  a_3$。\n$$|k|  1$$\n这等价于区间 $-1  k  1$。这个条件比 $k1$ 更严格，因此在此阶段，稳定性的要求是 $k \\in (-1, 1)$。\n\n下一步是构造降阶多项式并检查其稳定性。如果 $p(z)$ 是舒尔稳定的，那么通过以下构造得出的多项式 $p_2(z)$ 也必须是舒尔稳定的。令 $p^*(z)$ 为反转多项式：\n$$p^*(z) = z^3 p(1/z) = z^3( (1/z)^3 + (1/z)^2 + (2-k)(1/z) + k ) = 1 + z + (2-k)z^2 + kz^3$$\n递归步长参数为 $\\alpha_3 = a_0/a_3 = k/1 = k$。降阶多项式 $p_2(z)$ 由下式给出：\n$$p_2(z) = \\frac{1}{z} (p(z) - \\alpha_3 p^*(z))$$\n代入 $p(z)$、$p^*(z)$ 和 $\\alpha_3=k$ 的表达式：\n$$p(z) - k p^*(z) = (z^3 + z^2 + (2-k)z + k) - k(kz^3 + (2-k)z^2 + z + 1)$$\n$$= (1-k^2)z^3 + (1 - k(2-k))z^2 + (2-k - k)z + (k-k)$$\n$$= (1-k^2)z^3 + (1 - 2k + k^2)z^2 + (2-2k)z$$\n$$= (1-k^2)z^3 + (1-k)^2 z^2 + 2(1-k)z$$\n除以 $z$ 得到二次多项式 $p_2(z)$：\n$$p_2(z) = (1-k^2)z^2 + (1-k)^2 z + 2(1-k)$$\n设该二次多项式的系数为 $b_2 = 1-k^2$，$b_1 = (1-k)^2$ 和 $b_0 = 2(1-k)$。为了使 $p_2(z)$ 舒尔稳定，必须满足其自身的稳定性条件。首项系数 $b_2 = 1-k^2$ 必须为正，这意味着 $k^2  1$，即 $|k|1$。这与我们已有的条件是一致的。\n\n对于首项系数 $b_2 > 0$ 的二次多项式 $b_2 z^2 + b_1 z + b_0$，其舒尔稳定条件为：\n1. $p_2(1) > 0 \\implies b_2+b_1+b_0 > 0$\n2. $p_2(-1) > 0 \\implies b_2-b_1+b_0 > 0$\n3. $|b_0|  b_2$\n\n让我们为 $p_2(z)$ 检验这些条件：\n1. $b_2+b_1+b_0 = (1-k^2) + (1-k)^2 + 2(1-k) = (1-k)(1+k) + (1-k)(1-k) + 2(1-k) = (1-k)[(1+k) + (1-k) + 2] = 4(1-k)$。\n由于我们要求 $|k|1$，因此 $1-k > 0$，所以 $4(1-k) > 0$ 成立。\n\n2. $b_2-b_1+b_0 = (1-k^2) - (1-k)^2 + 2(1-k) = (1-k)(1+k) - (1-k)(1-k) + 2(1-k) = (1-k)[(1+k) - (1-k) + 2] = (1-k)(2k+2) = 2(1-k^2)$。\n由于 $|k|1$，因此 $1-k^2 > 0$，所以 $2(1-k^2) > 0$ 成立。\n\n3. $|b_0|  b_2$。\n$$|2(1-k)|  1-k^2$$\n在我们当前 $|k|1$ 的约束下，$1-k$ 这一项是严格为正的。所以， $|2(1-k)| = 2(1-k)$。不等式为：\n$$2(1-k)  1-k^2$$\n我们可以将右边重写为 $(1-k)(1+k)$：\n$$2(1-k)  (1-k)(1+k)$$\n因为 $1-k > 0$，我们可以在不等式两边同时除以 $(1-k)$ 而不改变不等号的方向：\n$$2  1+k$$\n$$k > 1$$\n\n要使原多项式 $p(z)$ 舒尔稳定，所有推导出的关于 $k$ 的条件必须同时成立。我们已经累积了以下严格不等式集合：\na) 来自 $p(z)$ 的 $|a_0|  a_3$ 条件：$-1  k  1$。\nb) 来自 $p_2(z)$ 的 $|b_0|  b_2$ 条件：$k > 1$。\n\n$k$ 的解必须位于这两个条件所定义的集合的交集中：\n$$\\mathcal{K} = \\{k \\in \\mathbb{R} \\mid (-1  k  1) \\land (k > 1) \\}$$\n开区间 $(-1, 1)$ 和开区间 $(1, \\infty)$ 的交集是空集。\n$$\\mathcal{K} = \\emptyset$$\n因此，不存在实数 $k$ 使得给定的多项式是舒尔稳定的。\n\n最后一步是求集合 $\\mathcal{K}$ 的勒贝格测度。根据定义，空集的勒贝格测度为零。", "answer": "$$\\boxed{0}$$", "id": "2747037"}, {"introduction": "检验理解程度的最终标准是将理论转化为功能性算法的能力。这最后一个实践将指导您从第一性原理出发，实现 Jury 稳定性判据，最终编写出一个能够对各种多项式进行鲁棒分类的程序。通过应对数值精度和临界稳定情况等挑战，您将对计算稳定性分析的实际方面有更深刻的认识。[@problem_id:2747031]", "problem": "设计并实现一个程序，该程序针对给定的一组复变量 $z$ 的实系数首一或非首一多项式，使用基于原理的 Jury 稳定性判据实现，判断其对应的离散时间线性时不变特征多项式是否为严格 Schur 稳定。此问题必须从第一性原理出发：即从离散时间线性时不变系统渐近稳定的定义开始，该定义为系统的特征多项式所有根都严格位于开单位圆盘 $\\{z \\in \\mathbb{C} : |z|  1\\}$ 内部。您的实现必须达成一个等效于 Jury 准则的无需求根判定过程，该过程基于一个经过数学证明的递归，并保持与根位置定义的等价性。请勿依赖显式求根。\n\n您必须生成单行输出，该输出按下方指定的精确格式汇总所有给定测试多项式的判定结果。\n\n定义和要求：\n- 一个实系数多项式 $p(z) = a_0 z^n + a_1 z^{n-1} + \\cdots + a_n$ 是严格 Schur 稳定的，当且仅当其所有根 $z_i$ 均满足 $|z_i|  1$。\n- 临界稳定情况，即至少有一个根位于单位圆 $\\{|z| = 1\\}$ 上的情况，必须归类为非严格 Schur 稳定。\n- 接近不稳定但严格稳定的情况（例如，根的模非常接近 $1$，如 $|z_i| = 0.9999$）必须被正确归类为严格 Schur 稳定。\n- 您的算法必须是数值稳健的。在中间条件的与 1 的比较中，请使用一个小的容差 $\\varepsilon$。在 $\\varepsilon$ 范围内的任何与 1 的相等情况都必须被视为非严格 Schur 稳定，而任何至少以 $\\varepsilon$ 成立的严格不等式都必须被视为有利于稳定。\n\n测试套件：\n评估以下多项式列表，每个多项式以 $z$ 的降幂系数向量形式给出。例如，列表 $[a_0,a_1,\\ldots,a_n]$ 代表 $a_0 z^n + a_1 z^{n-1} + \\cdots + a_n$。\n\n为以下 $12$ 个多项式提供判定结果：\n- 情况 $1$ (稳定, 一阶): $[1,-0.5]$。\n- 情况 $2$ (临界, 一阶): $[1,-1.0]$。\n- 情况 $3$ (不稳定, 一阶): $[1,-1.001]$。\n- 情况 $4$ (接近不稳定但稳定, 一阶): $[1,-0.9999]$。\n- 情况 $5$ (稳定, 二阶): $[1,-0.8,0.15]$。\n- 情况 $6$ (不稳定, 二阶): $[1,-1.7,0.6]$。\n- 情况 $7$ (临界, 二阶, 在 $1$ 处有一个实根): $[1,-1.5,0.5]$。\n- 情况 $8$ (临界, 二阶, 有一对在单位圆上、角度为 $0.7$ 弧度的共轭复根): $[1,-1.529684374568977,1.0]$。\n- 情况 $9$ (稳定, 三阶: 一对半径为 $0.8$、角度为 $0.7$ 弧度的共轭复根和一个位于 $0.3$ 的实根): $[1,-1.5237474996551816,1.0071242498965545,-0.192]$。\n- 情况 $10$ (接近不稳定但稳定, 三阶: 一对半径为 $0.999$、角度为 $1.0$ 弧度的共轭复根和一个位于 $0.7$ 的实根): $[1,-1.7795240071245434,1.7536678049871803,-0.6986007]$。\n- 情况 $11$ (稳定, 非首一二阶缩放测试): $[2,-1.6,0.3]$。\n- 情况 $12$ (临界, 有重单位根): $[1,-2.0,1.0]$。\n\n输出规范：\n- 对每个多项式，输出一个布尔值以指示其是否为严格 Schur 稳定：当且仅当所有根都满足 $|z_i|  1$ 时输出 $\\mathrm{True}$；否则输出 $\\mathrm{False}$（这包括临界稳定和不稳定情况）。\n- 将所有 $12$ 个布尔结果汇总到一个列表中，顺序与上述情况列表一致。\n- 您的程序应生成单行输出，其中仅包含此列表，元素以逗号分隔，并用方括号括起来，例如：$[ \\mathrm{True}, \\mathrm{False} ]$。除逗号后允许的单个空格外，不应有额外的空白字符，也不应有多余的文本。\n\n角度单位：上文提及的所有角度（如适用）均以弧度为单位。\n\n数值单位：不涉及物理单位；所有量均为无量纲。\n\n您的实现必须是自包含的，且不得读取任何输入。它必须按上述规定计算并打印最终的布尔值列表。", "solution": "该问题要求实现一个针对实系数多项式严格 Schur 稳定性的判定过程。一个多项式被定义为严格 Schur 稳定，如果它的所有根都位于复平面中的开单位圆盘内部。这是离散时间线性时不变（LTI）系统稳定性分析中的一个基本概念。该过程必须基于第一性原理，从稳定性的定义出发，并且必须等效于 Jury 稳定性判据。\n\n**原理与理论基础**\n\n一个离散时间 LTI 系统是渐近稳定的，当且仅当其特征多项式 $P(z) = a_0 z^n + a_1 z^{n-1} + \\dots + a_n$ 的所有根 $z_i$ 都满足条件 $|z_i|  1$。直接计算根在数值上是病态的，并且计算成本高昂。代数稳定性判据，例如 Jury 判据，通过直接检查多项式的系数提供了一种稳健的替代方法。\n\nJury 判据是 Schur-Cohn 判据在实系数多项式上的特例。其理论基础在于复变函数论，特别是 Rouché 定理，该定理可以计算解析函数在一条闭合轮廓线内部的零点数量。\n\n**递归算法的推导**\n\n设 $P_n(z) = \\sum_{i=0}^{n} a_i z^{n-i}$ 是一个 $n$ 次实系数多项式。不失一般性，我们可以假设其首项系数 $a_0 > 0$。如果 $a_0  0$，我们可以分析 $-P_n(z)$，它具有相同的根。如果 $a_0 = 0$，则该多项式的次数小于 $n$。\n\n稳定性判据的核心是一个递归论证，它在每一步降低多项式的次数，同时保持稳定性属性不变。\n\n1.  **基本条件**：所有根满足 $|z_i|  1$ 的一个必要条件是所有根的乘积的模必须小于 1。根据韦达定理 (Vieta's formulas)，根的乘积为 $\\prod_{i=1}^n z_i = (-1)^n \\frac{a_n}{a_0}$。取其模，我们得到 $|\\prod z_i| = \\prod |z_i| = |\\frac{a_n}{a_0}|$。如果所有 $|z_i|  1$，那么必然有 $|\\frac{a_n}{a_0}|  1$。在我们假设 $a_0 > 0$ 的情况下，这简化为 $|a_n|  a_0$。如果此条件不满足（即 $|a_n| \\ge a_0$），则至少有一个根位于单位圆上或单位圆外，该多项式不是严格 Schur 稳定的。\n\n2.  **递归步骤**：如果条件 $|a_n|  a_0$ 成立，我们继续构造一个次数较低的多项式 $P_{n-1}(z)$，其稳定性与 $P_n(z)$ 的稳定性等价。这可以通过 Rouché 定理实现。我们定义“反转”多项式 $P_n^*(z) = z^n P_n(1/z) = \\sum_{i=0}^{n} a_{n-i} z^{n-i}$。在单位圆上，即 $|z|=1$ 处，我们有 $|P_n(z)| = |P_n^*(z)|$。如果 $P_n(z)$ 在单位圆上没有根，则条件 $|a_n|  a_0$ 意味着在 $|z|=1$ 上有 $|a_n P_n^*(z)|  |a_0 P_n(z)|$。根据 Rouché 定理，多项式 $Q(z) = a_0 P_n(z) - a_n P_n^*(z)$ 在单位圆盘内的根数量与 $a_0 P_n(z)$ 相同，因此也与 $P_n(z)$ 相同。\n\n    $Q(z)$ 的系数由 $\\sum_{i=0}^n (a_0 a_i - a_n a_{n-i}) z^{n-i}$ 给出。其常数项为 $a_0 a_n - a_n a_0 = 0$，这意味着 $Q(z)$ 在 $z=0$ 处有一个根。因此，我们可以定义一个新的 $n-1$ 次多项式：\n    $$P_{n-1}(z) = \\frac{1}{z} Q(z) = \\frac{1}{z} (a_0 P_n(z) - a_n P_n^*(z))$$\n    现在，$P_n(z)$ 的稳定性等价于 $P_{n-1}(z)$ 的稳定性，前提是初始条件 $|a_n|  a_0$ 成立且 $P_n(z)$ 在单位圆上没有根。\n\n3.  **算法**：整个算法是该逻辑的递归应用。\n    设 $P^{(k)}(z) = \\sum_{i=0}^k a_i^{(k)} z^{k-i}$ 为第 $k$ 步的多项式，其中 $P^{(n)}(z) = P_n(z)$。\n    对于每一步 $k = n, n-1, \\dots, 2$：\n    a. 检查条件 $|a_k^{(k)}|  a_0^{(k)}$。如果不满足，则多项式不稳定。可以证明，如果首项系数初始为正，则在整个过程中 $a_0^{(k)}$ 将保持为正。\n    b. 构造下一个多项式 $P^{(k-1)}(z)$。其系数 $a_i^{(k-1)}$ 由以下关系给出：\n       $$a_i^{(k-1)} = a_i^{(k)} - \\left(\\frac{a_k^{(k)}}{a_0^{(k)}}\\right) a_{k-i}^{(k)}, \\quad \\text{for } i=0, \\dots, k-1.$$\n    当我们得到一个一阶多项式 $P^{(1)}(z) = a_0^{(1)} z + a_1^{(1)}$ 时，递归终止。它的唯一根是 $z = -a_1^{(1)} / a_0^{(1)}$。为保证稳定性，我们需要 $|-a_1^{(1)}/a_0^{(1)}|  1$，这等价于 $|a_1^{(1)}|  a_0^{(1)}$。\n\n4.  **奇异情况和初步判别**：只要在任何步骤中 $|a_k^{(k)}| \\neq a_0^{(k)}$，递归就有效。如果出现相等的情况，这表明有根在单位圆上，意味着系统不是严格稳定的。为保证数值稳健性，我们使用一个小的容差 $\\varepsilon$ 来检查 $|a_k^{(k)}| \\ge a_0^{(k)}$。此外，两个稳定性的必要条件提供了一种有效检测某些不稳定情况的方法：\n    - $P(1) > 0$\n    - $(-1)^n P(-1) > 0$\n    不满足这些条件意味着不稳定。例如，如果 $P(1)=0$，则在 $z=1$ 处有一个根。如果 $P(1)  0$（对于 $a_0>0$），则必定存在奇数个大于 1 的实根。这两种情况都违反了严格 Schur 稳定性。我们的实现将使用这些检查来进行快速排除。\n\n**实现总结**\n\n该算法通过迭代过程实现：\n1.  标准化输入系数向量，使首项系数为正。\n2.  检查两个初步条件：$P(1) > 0$ 和 $(-1)^n P(-1) > 0$。\n3.  从 $n$ 次迭代递减至 1 次。在每个次数为 $k$ 的步骤中，测试条件 $|a_k|  a_0$。如果通过，则计算新的 $k-1$ 次多项式的系数。\n4.  如果任何测试失败，则终止并返回 `False`。\n5.  如果循环完成，则所有条件都已满足，该多项式是严格 Schur 稳定的。返回 `True`。\n所有浮点数比较都使用一个小的容差 $\\varepsilon$，以处理数值精度问题并正确分类临界情况。在最终的一阶多项式 $q_0 z + q_1$ 中，稳定性要求 $|q_1|  |q_0|$。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Schur stability problem for a suite of test polynomials using\n    a principle-based implementation of the Jury stability test.\n    \"\"\"\n\n    test_cases = [\n        # Case 1 (stable, first order): [1, -0.5]\n        [1, -0.5],\n        # Case 2 (marginal, first order): [1, -1.0]\n        [1, -1.0],\n        # Case 3 (unstable, first order): [1, -1.001]\n        [1, -1.001],\n        # Case 4 (nearly unstable but stable, first order): [1, -0.9999]\n        [1, -0.9999],\n        # Case 5 (stable, second order): [1, -0.8, 0.15]\n        [1, -0.8, 0.15],\n        # Case 6 (unstable, second order): [1, -1.7, 0.6]\n        [1, -1.7, 0.6],\n        # Case 7 (marginal, second order with a real root at 1): [1, -1.5, 0.5]\n        [1, -1.5, 0.5],\n        # Case 8 (marginal, second order with a complex-conjugate unit-circle pair): [1, -1.529684374568977, 1.0]\n        [1, -1.529684374568977, 1.0],\n        # Case 9 (stable, third order): [1, -1.5237474996551816, 1.0071242498965545, -0.192]\n        [1, -1.5237474996551816, 1.0071242498965545, -0.192],\n        # Case 10 (nearly unstable but stable, third order): [1, -1.7795240071245434, 1.7536678049871803, -0.6986007]\n        [1, -1.7795240071245434, 1.7536678049871803, -0.6986007],\n        # Case 11 (stable, non-monic second order): [2, -1.6, 0.3]\n        [2, -1.6, 0.3],\n        # Case 12 (marginal with repeated unit root): [1, -2.0, 1.0]\n        [1, -2.0, 1.0],\n    ]\n\n    def is_schur_stable(coeffs):\n        \"\"\"\n        Determines if a polynomial is strictly Schur-stable using the Jury test.\n\n        Args:\n            coeffs: A list or numpy array of polynomial coefficients in descending powers of z.\n\n        Returns:\n            True if all roots are strictly inside the unit circle, False otherwise.\n        \"\"\"\n        # A small tolerance for floating-point comparisons.\n        EPSILON = 1e-9\n\n        # Convert to a NumPy array for vectorized operations.\n        p = np.array(coeffs, dtype=np.float64)\n\n        # 1. Preprocessing: Handle leading zeros to find the true degree.\n        # The problem statement implies a_0 is the coeff of z^n, but good practice is to be robust.\n        nonzero_indices = np.where(np.abs(p) > EPSILON)[0]\n        if len(nonzero_indices) == 0: # Zero polynomial\n            return True # Or could be considered ill-defined, but has no roots.\n        \n        p = p[nonzero_indices[0]:]\n        n = len(p) - 1\n\n        # Degree 0 polynomial (a non-zero constant) has no roots, so it is stable.\n        if n  1:\n            return True\n\n        # 2. Normalization: Ensure leading coefficient is positive. This does not alter the roots.\n        if p[0]  0:\n            p = -p\n\n        # 3. Preliminary Necessary Conditions (Fast Fail).\n        # Condition 1: P(1) > 0.\n        # If P(1) = 0, there is at least one root on or outside the unit circle at z>=1.\n        p_at_1 = np.sum(p)\n        if p_at_1 = EPSILON:\n            return False\n\n        # Condition 2: (-1)^n * P(-1) > 0.\n        # This checks for roots on or outside the unit circle at z=-1.\n        p_at_minus_1 = np.sum(p * ((-1)**np.arange(n, -1, -1)))\n        if ((-1)**n) * p_at_minus_1 = EPSILON:\n            return False\n\n        # 4. Main Recursive Test (implemented iteratively).\n        current_coeffs = p.copy()\n        for k in range(n, 1, -1):\n            # The polynomial at this iteration has degree k.\n            \n            # Core Jury/Schur-Cohn condition: |a_k|  a_0.\n            c0 = current_coeffs[0]\n            ck = current_coeffs[k]\n\n            # If |a_k| >= a_0, the polynomial is not strictly stable.\n            # This is a singular case in the test and detects roots on or outside the unit circle.\n            if abs(ck) >= c0 - EPSILON:\n                return False\n\n            # Form the next polynomial of degree k-1 using the Schur-Cohn reduction.\n            alpha = ck / c0\n            \n            # The coefficients of the reduced polynomial of degree k-1 are computed.\n            next_coeffs = np.zeros(k) # k elements for degree k-1\n            for j in range(k):\n                next_coeffs[j] = current_coeffs[j] - alpha * current_coeffs[k - j]\n            \n            current_coeffs = next_coeffs\n\n        # 5. Final Condition for the resulting degree-1 polynomial.\n        # After the loop, current_coeffs represents q_0*z + q_1.\n        # Stability requires the root z = -q1/q0 to satisfy |z|1, hence |q1|  |q0|.\n        # By construction, q0 is positive.\n        q0 = current_coeffs[0]\n        q1 = current_coeffs[1]\n        \n        if abs(q1) >= q0 - EPSILON:\n            return False\n\n        # If all checks pass, the polynomial is strictly Schur-stable.\n        return True\n\n    results = [is_schur_stable(case) for case in test_cases]\n    \n    # Format the output as a single-line comma-separated list of booleans.\n    print(f\"[{','.join(str(r) for r in results)}]\")\n\nsolve()\n```", "id": "2747031"}]}