{"hands_on_practices": [{"introduction": "我们首先通过一个经典问题来学习一种强大的分析工具——平均法。许多物理和工程系统可以被建模为带有微小非线性项的振荡器，而平均法为我们提供了一种系统性的方法来预测这些系统的长期行为，特别是稳定极限环的存在与特性。这项练习将引导你应用一阶平均法，从一个弱非线性振荡器方程中推导出决定振幅和相位的慢变流方程，并最终计算出极限环的振幅。[@problem_id:2731668]", "problem": "考虑由二阶常微分方程（ODE）控制的弱非线性振子\n$$\n\\ddot{x} + x = \\varepsilon f(x,\\dot{x}),\n$$\n其中 $0  \\varepsilon \\ll 1$，且\n$$\nf(x,\\dot{x}) = \\alpha \\dot{x} - \\beta x^{2}\\dot{x} - \\gamma \\dot{x}^{3},\n$$\n$\\alpha, \\beta, \\gamma$ 为实参数。假设 $\\alpha > 0$ 且 $\\beta + 3\\gamma > 0$，从而可能存在一个唯一的、稳定的、有限振幅的极限环。\n\n从无强迫线性振子 $\\ddot{x} + x = 0$ 作为基系统出发，使用一阶平均法，通过将状态写成极坐标形式 $x(t) = r(t)\\cos(\\theta(t))$ 和 $\\dot{x}(t) = -r(t)\\sin(\\theta(t))$，其中 $\\theta(t) = t + \\phi(t)$，并在基振荡的一个周期内进行平均，推导振幅 $r(t)$ 和相位 $\\phi(t)$ 的平均慢流方程。根据平均振幅方程，确定所有不動點，并找出对应于极限环振幅的非零不動點。\n\n最终答案只需提供以 $\\alpha$、$\\beta$ 和 $\\gamma$ 表示的非零不動點振幅的精确闭式解析表达式。最终答案中不要提供任何中间步骤。无需进行数值近似或四舍五入。", "solution": "所给问题是使用微扰法分析弱非线性振子的一个标准练习。该问题提法恰当，科学上合理，并为其解决提供了所有必要信息。我将开始推导过程。\n\n控制方程是一个二阶常微分方程：\n$$\n\\ddot{x} + x = \\varepsilon f(x,\\dot{x})\n$$\n其中 $0  \\varepsilon \\ll 1$ 且 $f(x,\\dot{x}) = \\alpha \\dot{x} - \\beta x^{2}\\dot{x} - \\gamma \\dot{x}^{3}$。我们的任务是使用平均法求出极限环的振幅。\n\n按照建议，我们采用范德波尔变换到极坐标：\n$$\nx(t) = r(t)\\cos(\\theta(t))\n$$\n$$\n\\dot{x}(t) = -r(t)\\sin(\\theta(t))\n$$\n其中相位定义为 $\\theta(t) = t + \\phi(t)$。变量 $r(t)$ 和 $\\phi(t)$ 被假定为慢变量，这是该方法的关键假设。\n\n将 $x(t)$ 对时间求导得到：\n$$\n\\dot{x} = \\dot{r}\\cos\\theta - r\\dot{\\theta}\\sin\\theta\n$$\n将其与施加的条件 $\\dot{x} = -r\\sin\\theta$ 进行比较，并代入 $\\dot{\\theta} = 1 + \\dot{\\phi}$，我们得到对慢变量的第一个约束条件：\n$$\n\\dot{r}\\cos\\theta - r(1+\\dot{\\phi})\\sin\\theta = -r\\sin\\theta\n$$\n$$\n\\dot{r}\\cos\\theta - r\\dot{\\phi}\\sin\\theta = 0\n$$\n\n接下来，我们将 $\\dot{x}(t)$ 对时间求导：\n$$\n\\ddot{x} = -\\dot{r}\\sin\\theta - r\\dot{\\theta}\\cos\\theta\n$$\n将此式与 $x = r\\cos\\theta$ 代入原始常微分方程得到：\n$$\n(-\\dot{r}\\sin\\theta - r\\dot{\\theta}\\cos\\theta) + r\\cos\\theta = \\varepsilon f(r\\cos\\theta, -r\\sin\\theta)\n$$\n再次使用 $\\dot{\\theta} = 1+\\dot{\\phi}$，我们得到第二个约束条件：\n$$\n-\\dot{r}\\sin\\theta - r(1+\\dot{\\phi})\\cos\\theta + r\\cos\\theta = \\varepsilon f(x, \\dot{x})\n$$\n$$\n-\\dot{r}\\sin\\theta - r\\dot{\\phi}\\cos\\theta = \\varepsilon f(x, \\dot{x})\n$$\n\n现在我们得到一个关于 $\\dot{r}$ 和 $\\dot{\\phi}$ 的二元线性方程组：\n$$\n\\begin{cases}\n\\dot{r}\\cos\\theta - r\\dot{\\phi}\\sin\\theta = 0 \\\\\n-\\dot{r}\\sin\\theta - r\\dot{\\phi}\\cos\\theta = \\varepsilon f(x, \\dot{x})\n\\end{cases}\n$$\n求解该方程组得到振幅和相位的精确演化方程：\n$$\n\\dot{r} = -\\varepsilon f(x, \\dot{x})\\sin\\theta\n$$\n$$\n\\dot{\\phi} = -\\frac{\\varepsilon}{r}f(x, \\dot{x})\\cos\\theta\n$$\n现在，我们将函数 $f(x, \\dot{x})$ 用 $r$ 和 $\\theta$ 表示：\n$$\nf(r\\cos\\theta, -r\\sin\\theta) = \\alpha(-r\\sin\\theta) - \\beta(r\\cos\\theta)^{2}(-r\\sin\\theta) - \\gamma(-r\\sin\\theta)^{3}\n$$\n$$\nf(r\\cos\\theta, -r\\sin\\theta) = -r\\alpha\\sin\\theta + r^{3}\\beta\\cos^{2}\\theta\\sin\\theta + r^{3}\\gamma\\sin^{3}\\theta\n$$\n将此式代入 $\\dot{r}$ 的方程中：\n$$\n\\dot{r} = -\\varepsilon(-r\\alpha\\sin\\theta + r^{3}\\beta\\cos^{2}\\theta\\sin\\theta + r^{3}\\gamma\\sin^{3}\\theta)\\sin\\theta\n$$\n$$\n\\dot{r} = \\varepsilon(r\\alpha\\sin^{2}\\theta - r^{3}\\beta\\cos^{2}\\theta\\sin^{2}\\theta - r^{3}\\gamma\\sin^{4}\\theta)\n$$\n一阶平均法表明，$r$ 的慢动力学可以通过将其演化方程的右侧在快变量 $\\theta$ 的一个周期（从 $0$ 到 $2\\pi$）上进行平均来近似。在此积分过程中，慢变量 $r$ 被视为常数。平均后的方程记为 $\\langle\\dot{r}\\rangle$，为：\n$$\n\\langle\\dot{r}\\rangle = \\frac{1}{2\\pi} \\int_{0}^{2\\pi} \\varepsilon(r\\alpha\\sin^{2}\\theta - r^{3}\\beta\\cos^{2}\\theta\\sin^{2}\\theta - r^{3}\\gamma\\sin^{4}\\theta) d\\theta\n$$\n为了计算这个积分，我们使用以下标准定积分：\n$$\n\\int_{0}^{2\\pi} \\sin^{2}\\theta \\,d\\theta = \\pi\n$$\n$$\n\\int_{0}^{2\\pi} \\cos^{2}\\theta\\sin^{2}\\theta \\,d\\theta = \\int_{0}^{2\\pi} \\frac{1}{4}\\sin^{2}(2\\theta) \\,d\\theta = \\frac{\\pi}{4}\n$$\n$$\n\\int_{0}^{2\\pi} \\sin^{4}\\theta \\,d\\theta = \\int_{0}^{2\\pi} \\left(\\frac{1-\\cos(2\\theta)}{2}\\right)^{2} d\\theta = \\frac{1}{4} \\int_{0}^{2\\pi} (1 - 2\\cos(2\\theta) + \\cos^{2}(2\\theta)) d\\theta = \\frac{1}{4}(2\\pi - 0 + \\pi) = \\frac{3\\pi}{4}\n$$\n将这些结果代入平均方程中：\n$$\n\\langle\\dot{r}\\rangle = \\frac{\\varepsilon}{2\\pi} \\left( r\\alpha(\\pi) - r^{3}\\beta\\left(\\frac{\\pi}{4}\\right) - r^{3}\\gamma\\left(\\frac{3\\pi}{4}\\right) \\right)\n$$\n$$\n\\langle\\dot{r}\\rangle = \\frac{\\varepsilon r}{2} \\left(\\alpha - \\frac{r^{2}}{4}\\beta - \\frac{3r^{2}}{4}\\gamma\\right)\n$$\n$$\n\\langle\\dot{r}\\rangle = \\frac{\\varepsilon r}{8} \\left(4\\alpha - r^{2}(\\beta + 3\\gamma)\\right)\n$$\n此平均振幅方程的不动点通过令 $\\langle\\dot{r}\\rangle = 0$ 求得。这给出两个解：\n1. $r = 0$，这是对应于原点平衡点的平凡不动点。\n2. $4\\alpha - r^{2}(\\beta + 3\\gamma) = 0$，这对应于极限环的非零振幅。\n\n我们求解第二种情况下的 $r$：\n$$\nr^{2}(\\beta + 3\\gamma) = 4\\alpha\n$$\n$$\nr^{2} = \\frac{4\\alpha}{\\beta + 3\\gamma}\n$$\n由于振幅 $r$ 必须为正，我们取正平方根：\n$$\nr = \\sqrt{\\frac{4\\alpha}{\\beta + 3\\gamma}} = 2\\sqrt{\\frac{\\alpha}{\\beta + 3\\gamma}}\n$$\n问题陈述中说明 $\\alpha > 0$ 且 $\\beta + 3\\gamma > 0$，这保证了平方根下的表达式为正且有定义，从而得到一个实的、有限的极限环振幅。对不动点的稳定性分析证实了其稳定性，因为右侧对 $r$ 的导数在该不动点处的值为 $-\\varepsilon\\alpha$，为负值。这证实了它代表一个稳定的极限环。", "answer": "$$\\boxed{2\\sqrt{\\frac{\\alpha}{\\beta + 3\\gamma}}}$$", "id": "2731668"}, {"introduction": "在处理了平滑的非线性系统后，我们将注意力转向具有不连续或“硬”非线性的系统，这类系统在控制工程中非常普遍。这项练习探讨了一个典型的继电器反馈系统，它展示了一个简单的开关元件如何导致稳定的自激振荡。通过分段求解系统的线性动力学，你将推导出一个精确的解析表达式来计算极限环的周期，从而深入理解一种完全不同的振荡产生机制。[@problem_id:2731666]", "problem": "考虑一个单输入单输出反馈互联系统，该系统由一个一阶线性时不变对象和一个带迟滞的对称继电器组成。该对象的模型为\n$$\\tau \\,\\dot{y}(t) + y(t) = k\\,u(t),$$\n其中常数 $\\tau>0$ 和 $k>0$，输出为 $y(t)$，输入为 $u(t)\\in\\{-M,+M\\}$，其固定幅值为 $M>0$。该继电器是对称的，其迟滞半宽为 $h$，满足 $0  h  kM$。继电器的开关逻辑如下：当输出 $y$ 上升并达到 $y=h$ 时，控制输入切换到 $u=-M$；当输出 $y$ 下降并达到 $y=-h$ 时，控制输入切换到 $u=+M$。\n\n假设系统已进入一个稳定的极限环振荡。你的任务是通过分段求解线性常微分方程来推导此极限环的周期 $T$。\n\n最终答案只需提供以 $\\tau$、$k$、$M$ 和 $h$ 表示的周期 $T$ 的精确闭式解析表达式。最终答案中不要提供任何中间步骤。无需进行数值近似或四舍五入。", "solution": "问题的陈述需要经过验证。\n\n**第1步：提取已知条件**\n- 系统动力学：$\\tau \\,\\dot{y}(t) + y(t) = k\\,u(t)$\n- 常数：$\\tau>0$，$k>0$，$M>0$，$0  h  kM$\n- 继电器开关逻辑：\n  - 如果 $y$ 上升至 $h$，$u$ 切换到 $-M$\n  - 如果 $y$ 下降至 $-h$，$u$ 切换到 $+M$\n- 目标：计算极限环的周期 $T$。\n\n**第2步：分析半个周期**\n由于系统的对称性，极限环的周期 $T$ 是系统从 $y=-h$ 上升到 $y=h$ 所用时间 $T_1$ 的两倍，即 $T = 2T_1$。我们专注于计算 $T_1$。\n\n在这个半周期内，系统输出从 $y=-h$ 开始上升，这意味着控制输入必须是 $u=+M$。动力学方程为：\n$$\n\\tau \\dot{y} + y = kM\n$$\n这是一个一阶线性常微分方程。其通解为 $y(t) = y_{\\text{ss}} + (y_{\\text{initial}} - y_{\\text{ss}})e^{-t/\\tau}$，其中 $y_{\\text{ss}} = kM$ 是稳态解。\n该阶段的初始条件是 $y(0)=-h$。将 $t=0$ 代入通解，我们有：\n$$\ny(t) = kM + (-h - kM)e^{-t/\\tau}\n$$\n该阶段在输出达到 $y=h$ 时结束。我们设这个时间为 $T_1$，即 $y(T_1)=h$。代入方程：\n$$\nh = kM + (-h - kM)e^{-T_1/\\tau}\n$$\n现在，我们求解 $T_1$。重新整理方程：\n$$\nh - kM = -(h + kM)e^{-T_1/\\tau}\n$$\n$$\n(h + kM)e^{-T_1/\\tau} = kM - h\n$$\n$$\ne^{-T_1/\\tau} = \\frac{kM - h}{kM + h}\n$$\n两边取自然对数：\n$$\n-\\frac{T_1}{\\tau} = \\ln\\left(\\frac{kM - h}{kM + h}\\right)\n$$\n$$\nT_1 = -\\tau \\ln\\left(\\frac{kM - h}{kM + h}\\right) = \\tau \\ln\\left(\\left(\\frac{kM - h}{kM + h}\\right)^{-1}\\right) = \\tau \\ln\\left(\\frac{kM + h}{kM - h}\\right)\n$$\n条件 $0  h  kM$ 确保了对数函数的参数大于1，因此 $T_1$ 是一个正实数。\n\n**第3步：计算完整周期**\n由于系统的对称性，从 $y=h$ 下降到 $y=-h$ 的半周期（此时 $u=-M$）所用时间 $T_2$ 与 $T_1$ 相等。\n因此，总周期为：\n$$\nT = T_1 + T_2 = 2T_1 = 2\\tau \\ln\\left(\\frac{kM + h}{kM - h}\\right)\n$$\n这个结果是精确的，并用给定的参数表示。推导过程是正确的。", "answer": "$$\\boxed{2\\tau \\ln\\left(\\frac{kM + h}{kM - h}\\right)}$$", "id": "2731666"}, {"introduction": "我们的最后一个实践从连续时间的微分方程转向离散时间的映射，并进入数值探索的领域。圆映射（circle map）是一个著名的模型，它描述了振荡器的同步现象，例如萤火虫的同步闪烁或心脏细胞的搏动。这个编程练习要求你通过数值计算来探索旋转数，并构建所谓的“魔鬼阶梯”——一个美丽的分形结构，它揭示了系统响应频率如何锁定在驱动频率的有理倍数上。这项实践突显了计算在揭示非线性系统复杂且常常反直觉行为方面所扮演的关键角色。[@problem_id:2731669]", "problem": "考虑由以下提升动力学定义的离散时间圆映射\n$$\nx_{k+1} \\;=\\; x_k \\;+\\; \\Omega \\;-\\; \\frac{K}{2\\pi}\\,\\sin(2\\pi x_k),\n$$\n其中 $x_k \\in \\mathbb{R}$，$K \\ge 0$ 是非线性参数，$\\Omega \\in [0,1]$ 是归一化驱动频率。圆上的物理相位是 $\\theta_k = x_k \\bmod 1$。旋转数由以下极限定义\n$$\n\\rho(K,\\Omega) \\;=\\; \\lim_{n\\to\\infty} \\frac{x_n - x_0}{n},\n$$\n对于该系统，此极限在广泛条件下存在，并且在遍历区域中与 $x_0$ 无关。作为 $\\Omega$ 的函数（对于固定的 $K$），映射 $\\Omega \\mapsto \\rho(K,\\Omega)$ 会形成一个非递减的阶梯状函数，其平台指示了频率锁定（也称为模式锁定），此时 $\\rho$ 在 $\\Omega$ 的非零区间上取有理数值 $p/q$。这种分形单调函数通常被称为魔鬼阶梯。\n\n你的任务是，对于几个固定的 $K$ 值，在一个 $\\Omega$ 值网格上数值近似 $\\rho(K,\\Omega)$，检测 $\\rho$ 为小分母有理数的频率锁定平台，并测量平台宽度。仅使用通过提升动力学和基本数值迭代得到的旋转数定义。\n\n使用以下数值程序和检测标准。\n\n- 对于指定网格上的每一对 $(K,\\Omega)$，从 $x_0=0$ 开始迭代提升映射来近似旋转数：\n  1. 运行 $N_{\\mathrm{tr}}$ 步的暂态过程，以减少对初始条件的敏感性。\n  2. 然后运行 $N_{\\mathrm{avg}}$ 步并计算\n     $$\n     \\widehat{\\rho}(K,\\Omega) \\;=\\; \\frac{x_{N_{\\mathrm{tr}}+N_{\\mathrm{avg}}} - x_{N_{\\mathrm{tr}}}}{N_{\\mathrm{avg}}}.\n     $$\n- 要识别给定 $(K,\\Omega)$ 处的频率锁定，请使用最佳有理逼近（例如，连分数）将 $\\widehat{\\rho}$ 近似为一个满足 $1 \\le q \\le q_{\\max}$ 的有理数 $p/q$。如果满足以下条件，则将该点声明为锁定：\n  $$\n  \\left| \\widehat{\\rho}(K,\\Omega) - \\frac{p}{q} \\right| \\le \\varepsilon_{\\mathrm{lock}},\n  $$\n  并记录标签 $(p,q)$。\n- 要为给定的 $K$ 和一系列 $\\Omega$ 值识别平台，请找到 $\\Omega$ 的连续区间，其中所有点都锁定在相同的 $(p,q)$ 上。平台宽度是该区间中最大和最小 $\\Omega$ 之间的差。如果一个平台包含至少 $m_{\\min}$ 个网格点且宽度至少为 $w_{\\min}$，则接受该平台。\n\n在本问题的所有计算中，采用以下固定的数值设置：\n- 使用 $N_{\\mathrm{tr}} = 1500$，$N_{\\mathrm{avg}} = 3000$。\n- 使用 $[0,1]$ 内含 $N_{\\Omega} = 401$ 个点（包括端点）的均匀 $\\Omega$ 网格，即步长为 $1/400$。\n- 使用 $q_{\\max} = 8$，锁定容差 $\\varepsilon_{\\mathrm{lock}} = 5\\times 10^{-4}$，最小平台宽度 $w_{\\min} = 0.01$，以及最小平台点数 $m_{\\min} = 3$。\n- 对所有运行使用 $x_0 = 0$。\n\n测试套件。\n您必须评估以下四个测试用例，每个用例由 $(K,\\Omega_{\\min},\\Omega_{\\max},N_{\\Omega},q_{\\max},w_{\\min})$ 定义：\n1. $K = 0.0$, $\\Omega_{\\min} = 0.0$, $\\Omega_{\\max} = 1.0$, $N_{\\Omega} = 401$, $q_{\\max} = 8$, $w_{\\min} = 0.01$。\n2. $K = 0.5$, $\\Omega_{\\min} = 0.0$, $\\Omega_{\\max} = 1.0$, $N_{\\Omega} = 401$, $q_{\\max} = 8$, $w_{\\min} = 0.01$。\n3. $K = 1.0$, $\\Omega_{\\min} = 0.0$, $\\Omega_{\\max} = 1.0$, $N_{\\Omega} = 401$, $q_{\\max} = 8$, $w_{\\min} = 0.01$。\n4. $K = 1.2$, $\\Omega_{\\min} = 0.0$, $\\Omega_{\\max} = 1.0$, $N_{\\Omega} = 401$, $q_{\\max} = 8$, $w_{\\min} = 0.01$。\n\n对于每个测试用例，您的程序必须：\n- 计算给定 $K$ 在 $\\Omega$ 网格上所有被接受的平台列表。\n- 每个测试用例返回三个输出：\n  1. 被接受的平台的整数总数。\n  2. 一个布尔值，指示 $1:2$ 锁定平台（即 $\\rho = 1/2$）是否存在于被接受的平台中。\n  3. 最宽的被接受平台的宽度，作为一个实数，四舍五入到4位小数。\n\n最终输出格式。\n您的程序应生成单行输出，其中包含四个测试用例的结果，格式为一个用方括号括起来的、由逗号分隔的列表的列表。每个内部列表对应于上述顺序中的一个测试用例，并且必须具有 $[\\text{计数},\\text{布尔值},\\text{宽度}]$ 的形式，例如：\n$[[3,True,0.1250],[\\dots],[\\dots],[\\dots]]$。\n本问题不涉及单位。根据映射的定义，正弦函数内的角度以弧度为单位。所有浮点输出在打印前必须按上述规定四舍五入到4位小数。", "solution": "该问题要求对标准圆映射进行数值研究，这是研究非线性动力系统和频率锁定现象的一个基本模型。目标是对于非线性参数 $K$ 的几个值，在驱动频率 $\\Omega$ 的网格上近似旋转数 $\\rho(K,\\Omega)$，并识别和表征被称为阿诺德舌 (Arnold tongues) 的频率锁定平台。\n\n解决方案是通过直接实现问题陈述中指定的程序来构建的。该方法论遵循基于第一性原理的层级结构。\n\n分析的核心是旋转数，定义为 $\\rho = \\lim_{n\\to\\infty} (x_n - x_0)/n$。这个量度量了系统相位的平均渐近变化率。我们被要求通过迭代提升映射来计算数值近似值 $\\widehat{\\rho}$：\n$$\nx_{k+1} = x_k + \\Omega - \\frac{K}{2\\pi}\\sin(2\\pi x_k)\n$$\n对每对 $(K, \\Omega)$ 的计算从 $x_0 = 0$ 开始。前 $N_{\\mathrm{tr}} = 1500$ 次迭代作为暂态阶段被舍弃，以确保系统已稳定到其吸引子上。随后的 $N_{\\mathrm{avg}} = 3000$ 次迭代用于计算平均频率：\n$$\n\\widehat{\\rho}(K,\\Omega) = \\frac{x_{N_{\\mathrm{tr}}+N_{\\mathrm{avg}}} - x_{N_{\\mathrm{tr}}}}{N_{\\mathrm{avg}}}\n$$\n对于每个指定的测试用例 $K$，此程序被系统地应用于区间 $[0,1]$ 内含 $N_{\\Omega} = 401$ 个 $\\Omega$ 值的均匀网格上的每个点。\n\n一旦为给定的 $\\Omega$ 计算出 $\\widehat{\\rho}$，下一步就是测试频率锁定。这是一个分类任务。如果一个点的数值计算旋转数与一个简单有理数足够接近，则该点被视为锁定。这是通过一个两步过程实现的：\n1.  **最佳有理逼近**：对于每个 $\\widehat{\\rho}$，我们找到最佳有理逼近 $p/q$，其中分母 $q$ 不超过最大值 $q_{\\max} = 8$。这是通过使用连分数方法在算法上完成的，该方法在标准库中有高效的实现。\n2.  **锁定条件**：如果计算出的旋转数与其有理逼近之间的绝对差在指定的容差范围内，则点 $(\\Omega, \\widehat{\\rho})$ 被分类为以有理数 $p/q$ 锁定：\n    $$\n    \\left| \\widehat{\\rho}(K,\\Omega) - \\frac{p}{q} \\right| \\le \\varepsilon_{\\mathrm{lock}}\n    $$\n    其中 $\\varepsilon_{\\mathrm{lock}} = 5 \\times 10^{-4}$。如果满足此条件，则该状态被标记为对 $(p,q)$；否则，它被视为未锁定。\n\n在给定 $K$ 的 $\\Omega$ 网格上的所有点都被分类后，扫描生成的标签序列以识别平台。平台被定义为网格点的连续子序列，其中所有点都锁定到相同的有理数 $(p,q)$。\n\n每个识别出的潜在平台随后都要经过验证标准的检验，以过滤掉虚假或不重要的结果。只有当一个段同时满足以下两个条件时，才被接受为有效平台：\n- 它必须包含至少 $m_{\\min} = 3$ 个连续的网格点。\n- 该段中 $\\Omega$ 值的跨度（定义为该段的 $\\Omega_{\\max} - \\Omega_{\\min}$）必须至少为 $w_{\\min} = 0.01$。\n\n最后，对于每个 $K$ 值，分析被接受的平台集合以提取所需的摘要指标：\n1.  被接受平台的总数。\n2.  一个布尔标志，指示对应于 $1:2$ 频率锁定（$\\rho = 1/2$）的平台是否存在于被接受的集合中。\n3.  找到的最宽平台的宽度，四舍五入到四位小数。对于没有被接受平台的情况，此宽度报告为 $0$。\n\n这整个计算过程被封装在一个程序中，该程序遍历四个指定的 $K$ 值，对每个值执行分析，并按要求将最终结果格式化为单行输出。$K=0$ 的情况作为一个基线，此时映射是线性的（$x_{k+1} = x_k + \\Omega$），因此 $\\rho=\\Omega$。在这种线性情况下，真正的平台无法形成，并且指定的验证标准能如预期地正确过滤掉有理逼近过程产生的任何假象。对于 $K>0$，非线性会引发真正的频率锁定，而该算法旨在检测和测量由此产生的平台。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom fractions import Fraction\n\ndef solve():\n    \"\"\"\n    Solves the circle map problem by numerically approximating rotation numbers,\n    detecting frequency-locked plateaus, and reporting statistics for several\n    nonlinearity parameters K.\n    \"\"\"\n    # Define the fixed numerical settings from the problem statement.\n    N_TR = 1500\n    N_AVG = 3000\n    EPS_LOCK = 5e-4\n    M_MIN = 3\n    X0 = 0.0\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (K, Omega_min, Omega_max, N_Omega, q_max, w_min)\n        (0.0, 0.0, 1.0, 401, 8, 0.01),\n        (0.5, 0.0, 1.0, 401, 8, 0.01),\n        (1.0, 0.0, 1.0, 401, 8, 0.01),\n        (1.2, 0.0, 1.0, 401, 8, 0.01),\n    ]\n\n    all_case_results = []\n    for K, omega_min, omega_max, n_omega, q_max, w_min in test_cases:\n        # Create the grid of Omega values.\n        omega_grid = np.linspace(omega_min, omega_max, n_omega)\n        locked_states = []\n\n        # Pre-compute the K-dependent term for efficiency.\n        k_term = K / (2 * np.pi)\n\n        # Iterate over each Omega to compute rho_hat and determine its locked state.\n        for omega in omega_grid:\n            x = X0\n            \n            # 1. Iterate the map to compute rho_hat.\n            # Transient steps.\n            for _ in range(N_TR):\n                x = x + omega - k_term * np.sin(2 * np.pi * x)\n            \n            x_transient = x\n            \n            # Averaging steps.\n            for _ in range(N_AVG):\n                x = x + omega - k_term * np.sin(2 * np.pi * x)\n            \n            x_final = x\n            \n            rho_hat = (x_final - x_transient) / N_AVG\n            \n            # 2. Find best rational approximation p/q.\n            frac = Fraction(rho_hat).limit_denominator(q_max)\n            p, q = frac.numerator, frac.denominator\n            \n            # 3. Check for frequency locking.\n            if abs(rho_hat - p / q) = EPS_LOCK and q >= 1:\n                locked_states.append((p, q))\n            else:\n                locked_states.append(None)\n        \n        # 4. Identify and validate plateaus from contiguous locked states.\n        accepted_plateaus = []\n        i = 0\n        while i  n_omega:\n            current_state = locked_states[i]\n            if current_state is None:\n                i += 1\n                continue\n            \n            # A potential plateau starts at index i.\n            start_index = i\n            j = i + 1\n            while j  n_omega and locked_states[j] == current_state:\n                j += 1\n            end_index = j - 1\n            \n            # Apply validation criteria for the identified segment.\n            num_points = end_index - start_index + 1\n            if num_points >= M_MIN:\n                width = omega_grid[end_index] - omega_grid[start_index]\n                if width >= w_min:\n                    p_val, q_val = current_state\n                    plateau_info = {'p': p_val, 'q': q_val, 'width': width}\n                    accepted_plateaus.append(plateau_info)\n            \n            i = j  # Continue search from the end of the current segment.\n        \n        # 5. Compute the required output metrics for the current test case.\n        count = len(accepted_plateaus)\n        has_1_2 = any(p['p'] == 1 and p['q'] == 2 for p in accepted_plateaus)\n        \n        max_width = 0.0\n        if accepted_plateaus:\n            max_width = max(p['width'] for p in accepted_plateaus)\n            \n        all_case_results.append([count, has_1_2, max_width])\n    \n    # Final print statement in the exact required format.\n    result_strings = []\n    for count, has_bool, width in all_case_results:\n        bool_str = 'True' if has_bool else 'False'\n        width_str = f\"{round(width, 4):.4f}\" # Round then format\n        result_strings.append(f\"[{count},{bool_str},{width_str}]\")\n        \n    final_output = f\"[{','.join(result_strings)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "2731669"}]}