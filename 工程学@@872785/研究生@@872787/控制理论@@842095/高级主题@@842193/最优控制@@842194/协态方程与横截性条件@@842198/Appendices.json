{"hands_on_practices": [{"introduction": "在将横截条件当作既定公式来应用之前，理解其来源至关重要。本练习将引导你从第一性原理出发，为一个状态被约束在流形（单位球面）上的问题推导横截条件 [@problem_id:2698222]。通过将协态向量与约束流形的切空间几何联系起来，你将对这些基本的最优性条件获得更深刻、更直观的理解。", "problem": "考虑一个有限时域最优控制问题，其状态为 $x(t) \\in \\mathbb{R}^{n}$，控制为 $u(t) \\in \\mathbb{R}^{m}$，由光滑的控制仿射系统 $\\dot{x}(t) = f(x(t),u(t),t)$ 在区间 $t \\in [0,T]$ 上支配，其中 $T0$ 是固定的。性能指标是纯积分成本 $J[u(\\cdot)] = \\int_{0}^{T} L(x(t),u(t),t)\\, \\mathrm{d}t$，其中 $L$ 和 $f$ 对所有参数都是连续可微的。初始状态 $x(0)$ 是固定的，终端状态 $x(T)$ 被约束在由 $\\|x(T)\\| = 1$ 定义的单位球面上。没有终端成本，也没有不等式端点约束。假设庞特里亚金极大值原理 (PMP) 所要求的所有标准正则性和限定条件都成立，包括存在一个绝对连续的协态 $ \\lambda(t) \\in \\mathbb{R}^{n}$ 和一个最大化的哈密顿量。\n\n从PMP的基本变分结构和端点约束的几何学出发，通过刻画约束流形的切空间并对所有容许的端点变分强制边界项为零，推导与等式约束 $\\|x(T)\\|=1$ 相关的终端时刻 $T$ 的几何横截条件。计算此几何横截条件所蕴含的终端协态 $ \\lambda(T)$ 的容许形式，最终答案仅用 $x(T)$ 和一个标量拉格朗日乘子表示。以单一闭式符号表达式的形式提供最终答案，无需单位，也无需数值近似。[@problem_id:483]", "solution": "问题陈述经过验证，确认有效。这是一个在最优控制理论领域内提法恰当、有科学依据的问题，包含了进行严格推导所需的所有必要信息。\n\n目标是最小化由 $\\dot{x}(t) = f(x(t),u(t),t)$ 支配的系统的性能指标 $J[u(\\cdot)] = \\int_{0}^{T} L(x(t),u(t),t)\\, \\mathrm{d}t$。初始状态 $x(0)$ 是固定的，终端状态 $x(T)$ 被约束在 $\\mathbb{R}^{n}$ 中的一个特定流形——单位球面上。该终端约束由等式 $g(x(T)) = 0$ 给出，其中 $g(x) = \\|x\\|^2 - 1 = x^T x - 1$。性能指标中没有终端成本部分。\n\n根据庞特里亚金极大值原理 (PMP)，我们定义哈密顿量 $H(x, u, \\lambda, t) = L(x, u, t) + \\lambda^T f(x, u, t)$。将变分法应用于成本泛函，并结合系统动力学，可以得出最优性的必要条件。在引入协态动力学 $\\dot{\\lambda}^T = -\\frac{\\partial H}{\\partial x}$ 和最优性条件 $\\frac{\\partial H}{\\partial u} = 0$ 后，成本泛函的一阶变分简化为边界项：\n$$\n\\delta J = \\lambda(T)^T \\delta x(T) - \\lambda(0)^T \\delta x(0)\n$$\n其中 $\\delta x(t)$ 是状态轨迹的变分。\n\n初始状态 $x(0)$ 被指定为固定的。因此，任何容许的变分都必须满足 $\\delta x(0) = 0$。这将边界项条件简化为：\n$$\n\\delta J = \\lambda(T)^T \\delta x(T)\n$$\n对于最优轨迹，成本的一阶变分 $\\delta J$ 对于任何容许的控制扰动都必须是非负的。在终端约束的背景下，这意味着对于终端状态的所有*容许*变分 $\\delta x(T)$，边界项必须为零。因此，我们必须有：\n$$\n\\lambda(T)^T \\delta x(T) = 0\n$$\n一个容许的变分 $\\delta x(T)$ 是与终端约束一致的变分。终端状态 $x(T)$ 被约束在流形 $\\mathcal{S} = \\{x \\in \\mathbb{R}^{n} \\mid \\|x\\| = 1 \\}$ 上。从该流形上一点 $x(T)$ 出发的任何无穷小变分 $\\delta x(T)$ 都必须位于该点处流形的切空间内，我们将其表示为 $T_{x(T)}\\mathcal{S}$。\n\n流形 $\\mathcal{S}$ 被定义为函数 $g(x) = x^T x - 1$ 的一个水平集。切空间 $T_{x(T)}\\mathcal{S}$ 是所有与定义函数 $g(x)$ 在点 $x(T)$ 的梯度正交的向量的集合。$g(x)$ 的梯度为：\n$$\n\\nabla g(x) = \\frac{\\partial}{\\partial x} (x^T x - 1) = 2x\n$$\n因此，在 $x(T)$ 处的切空间是所有满足以下条件的向量 $\\delta x(T)$ 的集合：\n$$\n(\\nabla g(x(T)))^T \\delta x(T) = 0\n$$\n代入梯度的表达式，我们得到：\n$$\n(2x(T))^T \\delta x(T) = 0 \\implies x(T)^T \\delta x(T) = 0\n$$\n这个方程在几何上表明，任何容许的变分 $\\delta x(T)$ 都必须与位置向量 $x(T)$ 本身正交。对于以原点为中心的球面来说，这是一个直观的结果：任何一点的切平面都与指向该点的半径向量正交。\n\n横截条件要求对于所有属于切空间 $T_{x(T)}\\mathcal{S}$ 的向量 $\\delta x(T)$，都有 $\\lambda(T)^T \\delta x(T) = 0$。换句话说，对于所有满足 $x(T)^T \\delta x(T) = 0$ 的 $\\delta x(T)$，都有 $\\lambda(T)^T \\delta x(T) = 0$。\n\n这是线性代数中的一个基本结果。如果一个向量 $\\lambda(T)$ 与一个子空间（切空间 $T_{x(T)}\\mathcal{S}$）中的每个向量都正交，那么 $\\lambda(T)$ 必须位于该子空间的正交补空间中。切空间的正交补空间是流形在 $x(T)$ 处的法空间。\n\n流形 $\\mathcal{S}$ 在 $x(T)$ 处的法空间是由梯度向量 $\\nabla g(x(T))$ 张成的空间。在这种情况下，法空间是由向量 $2x(T)$ 张成的一维空间，或者等价地，由向量 $x(T)$ 张成。\n$$\n\\text{法空间} = \\text{span}\\{\\nabla g(x(T))\\} = \\text{span}\\{x(T)\\}\n$$\n因此，终端协态向量 $\\lambda(T)$ 必须是这个法空间的元素。这意味着 $\\lambda(T)$ 必须与终端状态向量 $x(T)$ 共线。我们可以将这种关系表示为：\n$$\n\\lambda(T) = \\nu \\, x(T)\n$$\n其中 $\\nu$ 是一个标量比例常数。这个标量 $\\nu$ 被解释为与终端等式约束 $g(x(T))=0$ 相关联的拉格朗日乘子。它的具体值不能仅由横截条件确定，而需要通过求解完整的两点边值问题来找到。\n\n该表达式提供了由“最终状态位于单位球面上”这一约束所对应的几何横截条件决定的终端协态 $\\lambda(T)$ 的形式。", "answer": "$$\n\\boxed{\\nu \\, x(T)}\n$$", "id": "2698222"}, {"introduction": "现在，让我们将理论应用于一个终端时间不固定的最小燃料消耗问题 [@problem_id:2698226]。该问题要求使用一个不同但同样重要的横截条件：$H(T)=0$。这个练习将锻炼你应用完整的庞特里亚金极大值原理（Pontryagin's Maximum Principle）来求解最优控制和最优终端时间的能力。", "problem": "考虑具有有界控制的标量控制仿射系统的最小燃料转移问题\n$$\\dot{x}(t) = u(t), \\quad |u(t)| \\leq U,$$\n其初始条件固定为\n$$x(0) = x_{0} \\quad \\text{with} \\quad x_{0}  0,$$\n终端状态固定为\n$$x(T) = 0,$$\n其中终端时间 $T$ 是自由的，且所有量均为无量纲。运行成本是 $L_{1}$-范数的光滑近似，\n$$L_{\\varepsilon}(u) = \\sqrt{u(t)^{2} + \\varepsilon^{2}}, \\quad \\varepsilon  0.$$\n待最小化的性能指标为\n$$J_{\\varepsilon}[u, T] = \\int_{0}^{T} \\sqrt{u(t)^{2} + \\varepsilon^{2}} \\, dt.$$\n仅使用庞特里亚金最大值原理 (PMP) 的基本原理和核心定义，推导最优性的必要条件，包括伴随（协态）动力学以及与自由终端时间相关的适当横截性条件。然后，通过在最优解上强制执行横截性条件以及状态动力学和控制约束，确定最优终端时间 $T^{\\star}$。您的最终答案必须是关于 $x_{0}$ 和 $U$ 的 $T^{\\star}$ 的单个闭式解析表达式。", "solution": "该问题旨在为动力学为 $\\dot{x}(t) = u(t)$ 且控制有界 $|u(t)| \\leq U$ 的标量系统找到最优终端时间 $T^{\\star}$。状态必须从初始条件 $x(0) = x_{0}$（其中 $x_{0}  0$）转移到固定的终端状态 $x(T) = 0$，其中终端时间 $T$ 是自由的。目标是最小化性能指标 $J_{\\varepsilon}[u, T] = \\int_{0}^{T} \\sqrt{u(t)^{2} + \\varepsilon^{2}} \\, dt$，其中 $\\varepsilon  0$。我们将使用庞特里亚金最大值原理 (PMP) 来推导最优性的必要条件。\n\n首先，我们定义哈密顿量 $H$。对于正常极值，哈密顿量由运行成本与协态向量和状态动力学函数的内积之和给出。这里，状态是 $x$，控制是 $u$，协态是 $p$，运行成本是 $L(u) = \\sqrt{u^{2} + \\varepsilon^{2}}$，状态动力学是 $f(x, u) = u$。\n$$H(x, p, u) = L(u) + p \\cdot f(x, u) = \\sqrt{u^{2} + \\varepsilon^{2}} + p u$$\n\n根据 PMP，对于最优控制 $u^{\\star}(t)$ 和相应的状态轨迹 $x^{\\star}(t)$，必须存在一个协态轨迹 $p^{\\star}(t)$，使得以下必要条件得到满足：\n\n1.  状态方程：$\\dot{x}^{\\star}(t) = \\frac{\\partial H}{\\partial p} = u^{\\star}(t)$。这就是给定的系统动力学。\n\n2.  协态（伴随）方程：协态的动力学由 $\\dot{p}^{\\star}(t) = -\\frac{\\partial H}{\\partial x}$ 给出。\n    $$\\dot{p}^{\\star}(t) = -\\frac{\\partial}{\\partial x} \\left(\\sqrt{(u^{\\star}(t))^{2} + \\varepsilon^{2}} + p^{\\star}(t) u^{\\star}(t)\\right) = 0$$\n    这意味着协态沿着最优轨迹是恒定的：$p^{\\star}(t) = p_{c}$，其中 $p_{c}$ 是某个常数。\n\n3.  哈密顿量最小化条件：对于几乎所有的 $t \\in [0, T^{\\star}]$，最优控制 $u^{\\star}(t)$ 必须在容许控制集 $U_{adm} = \\{u \\in \\mathbb{R} : |u| \\leq U\\}$ 上最小化哈密顿量。\n    $$u^{\\star}(t) = \\arg\\min_{|u| \\leq U} H(x^{\\star}(t), p_{c}, u) = \\arg\\min_{|u| \\leq U} \\left(\\sqrt{u^{2} + \\varepsilon^{2}} + p_{c} u\\right)$$\n\n4.  自由终端时间 $T$ 的横截性条件：对于终端状态固定且终端时间自由的问题，沿着最优轨迹在终端时间评估的哈密顿量必须为零。\n    $$H(x^{\\star}(T^{\\star}), p_{c}, u^{\\star}(T^{\\star})) = 0$$\n    由于哈密顿量不显式依赖于时间，并且 $\\dot{x}^{\\star}$ 和 $\\dot{p}^{\\star}$ 都只是 $x, p, u$ 的函数，因此哈密顿量沿着最优轨迹是恒定的。因此，对于所有 $t \\in [0, T^{\\star}]$，$H(t) = 0$。\n\n现在，我们分析哈密顿量最小化问题以确定最优控制 $u^{\\star}$。令 $h(u) = \\sqrt{u^{2} + \\varepsilon^{2}} + p_{c} u$。该函数是严格凸的，因为它的二阶导数 $h''(u) = \\frac{\\varepsilon^{2}}{(u^{2}+\\varepsilon^{2})^{3/2}}$ 对于 $\\varepsilon  0$ 是严格为正的。$h(u)$ 在紧区间 $[-U, U]$ 上的最小值必然存在，并且要么在导数为零的点（内部解），要么在边界 $u = \\pm U$ 处。\n\n我们首先考虑内部（非饱和）解的情况，即 $|u^{\\star}|  U$。这要求 $h(u)$ 在 $u=u^{\\star}$ 处的导数为零：\n$$\\frac{\\partial h}{\\partial u} \\bigg|_{u=u^{\\star}} = \\frac{u^{\\star}}{\\sqrt{(u^{\\star})^{2} + \\varepsilon^{2}}} + p_{c} = 0 \\quad (1)$$\n这意味着 $p_{c} = -\\frac{u^{\\star}}{\\sqrt{(u^{\\star})^{2} + \\varepsilon^{2}}}$。由此可见 $|p_{c}| = \\frac{|u^{\\star}|}{\\sqrt{(u^{\\star})^{2} + \\varepsilon^{2}}}  1$。\n现在我们应用横截性条件，$H=0$：\n$$\\sqrt{(u^{\\star})^{2} + \\varepsilon^{2}} + p_{c} u^{\\star} = 0 \\quad (2)$$\n将(1)式中的 $p_c$ 代入(2)式：\n$$\\sqrt{(u^{\\star})^{2} + \\varepsilon^{2}} + \\left(-\\frac{u^{\\star}}{\\sqrt{(u^{\\star})^{2} + \\varepsilon^{2}}}\\right) u^{\\star} = 0$$\n$$\\sqrt{(u^{\\star})^{2} + \\varepsilon^{2}} = \\frac{(u^{\\star})^{2}}{\\sqrt{(u^{\\star})^{2} + \\varepsilon^{2}}}$$\n$$(u^{\\star})^{2} + \\varepsilon^{2} = (u^{\\star})^{2}$$\n$$\\varepsilon^{2} = 0$$\n这与给定条件 $\\varepsilon  0$ 相矛盾。因此，非饱和的最优控制是不可能的。最优控制必须位于容许集的边界上。\n\n最优控制必须是 $u^{\\star}(t) = U$ 或 $u^{\\star}(t) = -U$。由于状态必须从 $x(0) = x_{0}  0$ 驱动到 $x(T) = 0$，速度 $\\dot{x} = u$ 平均必须为负。由于 $p_c$ 是常数，最小化哈密顿量的控制 $u^{\\star}$ 也是常数。因此，对于所有 $t \\in [0, T^{\\star}]$，最优控制必须是 $u^{\\star}(t) = -U$。\n\n现在我们将此控制策略应用于系统动力学和边界条件，以找到最优时间 $T^{\\star}$。\n$$\\dot{x}(t) = -U$$\n从 $t=0$ 积分到 $t=T^{\\star}$：\n$$\\int_{0}^{T^{\\star}} \\dot{x}(t) \\, dt = \\int_{0}^{T^{\\star}} -U \\, dt$$\n$$x(T^{\\star}) - x(0) = -U T^{\\star}$$\n代入边界条件 $x(0) = x_{0}$ 和 $x(T^{\\star}) = 0$：\n$$0 - x_{0} = -U T^{\\star}$$\n$$T^{\\star} = \\frac{x_{0}}{U}$$\n\n最后，我们必须验证该解与PMP的所有必要条件一致。对于由横截性条件确定的 $p_c$ 值，控制 $u^{\\star} = -U$ 必须是 $H(u)$ 的最小化子。\n横截性条件 $H=0$ 与 $u^{\\star} = -U$ 给出：\n$$H = \\sqrt{(-U)^{2} + \\varepsilon^{2}} + p_{c}(-U) = 0$$\n$$\\sqrt{U^{2} + \\varepsilon^{2}} - p_{c} U = 0$$\n$$p_{c} = \\frac{\\sqrt{U^{2} + \\varepsilon^{2}}}{U}$$\n为了使 $u^{\\star} = -U$ 成为凸函数 $h(u)$ 的最小化子，在 $u=-U$ 处的导数必须为非负：\n$$h'(-U) = \\frac{-U}{\\sqrt{(-U)^{2} + \\varepsilon^{2}}} + p_{c} \\geq 0$$\n$$p_{c} \\geq \\frac{U}{\\sqrt{U^{2} + \\varepsilon^{2}}}$$\n代入我们找到的 $p_c$ 值：\n$$\\frac{\\sqrt{U^{2} + \\varepsilon^{2}}}{U} \\geq \\frac{U}{\\sqrt{U^{2} + \\varepsilon^{2}}}$$\n两边同乘以 $U\\sqrt{U^{2} + \\varepsilon^{2}}$（一个正量，因为解决该问题需要 $U0$ 且 $\\varepsilon0$）：\n$$(\\sqrt{U^{2} + \\varepsilon^{2}})^{2} \\geq U^{2}$$\n$$U^{2} + \\varepsilon^{2} \\geq U^{2}$$\n$$\\varepsilon^{2} \\geq 0$$\n由于 $\\varepsilon0$，此不等式成立。控制 $u^{\\star}(t)=-U$ 及终端时间 $T^{\\star} = x_0/U$ 满足PMP的所有必要条件。这是最优解的唯一候选者。", "answer": "$$\\boxed{\\frac{x_{0}}{U}}$$", "id": "2698226"}, {"introduction": "对于复杂的优化控制问题，解析解往往是不可行的。本实践将通过指导你实现一个打靶法，来弥合理论与计算之间的鸿沟 [@problem_id:2698225]。你将利用从庞特里亚金极大值原理（Pontryagin's Maximum Principle）推导出的状态和协态方程，构建一个两点边值问题，并使用牛顿法这一科学计算中的强大技术对其进行数值求解。", "problem": "要求您实现、分析并测试一种牛顿型打靶法，该方法通过更新初始协态来强制满足有限时域最优控制问题中的终端等式约束。该方法必须使用庞特里亚金最小值原理 (PMP)、伴随 (协态) 方程以及终端约束相对于初始协态的灵敏度分析，从第一性原理推导得出。实现时必须对相应的常微分方程 (ODE) 进行数值积分，并使用通过变分 (灵敏度) 方程计算出的雅可比矩阵，通过牛顿法迭代更新初始协态。\n\n考虑以下有限时域最优控制问题：\n- 最小化积分代价\n$$\nJ(u) \\;=\\; \\int_{0}^{T} \\tfrac{1}{2}\\,\\big(x(t)^{\\top} Q\\,x(t) \\;+\\; u(t)^{\\top} R \\, u(t)\\big)\\, dt,\n$$\n受限于线性时不变动态系统\n$$\n\\dot{x}(t) \\;=\\; A\\,x(t) \\;+\\; B\\,u(t), \\quad x(0) \\;=\\; x_{0},\n$$\n以及终端等式约束\n$$\n\\psi\\big(x(T)\\big) \\;=\\; C\\,x(T) \\;-\\; x_{T} \\;=\\; 0.\n$$\n其中，$x(t) \\in \\mathbb{R}^{n}$，$u(t) \\in \\mathbb{R}^{m}$，$A \\in \\mathbb{R}^{n \\times n}$，$B \\in \\mathbb{R}^{n \\times m}$，$Q \\in \\mathbb{R}^{n \\times n}$ 是半正定的，$R \\in \\mathbb{R}^{m \\times m}$ 是正定的，$C \\in \\mathbb{R}^{r \\times n}$，$x_{0} \\in \\mathbb{R}^{n}$ 是给定的，$x_{T} \\in \\mathbb{R}^{r}$ 是给定的，且 $T  0$ 是固定的。假设 $m = 1$ 且 $R$ 是一个标量 (即，$R \\in \\mathbb{R}$ 且 $R  0$)。\n\n基本原理和推导要求：\n- 使用庞特里亚金最小值原理 (PMP)。定义哈密顿量\n$$\nH(x,u,\\lambda) \\;=\\; \\tfrac{1}{2}\\,\\big(x^{\\top} Q\\,x \\;+\\; u^{\\top} R\\,u\\big) \\;+\\; \\lambda^{\\top}(A x + B u),\n$$\n其中协态为 $\\lambda(t) \\in \\mathbb{R}^{n}$。PMP 得出以下必要条件：\n    - 状态方程：$\\dot{x}(t) \\;=\\; A\\,x(t) \\;+\\; B\\,u(t)$，其中 $x(0)=x_{0}$。\n    - 协态方程：$\\dot{\\lambda}(t) \\;=\\; -Q\\,x(t) \\;-\\; A^{\\top}\\lambda(t)$。\n    - 最优控制 (一阶条件)：$\\partial H/\\partial u \\;=\\; R u \\;+\\; B^{\\top}\\lambda \\;=\\; 0$，因此 $u(t) \\;=\\; -R^{-1} B^{\\top}\\lambda(t)$。\n    - 等式约束的终端横截性条件：存在一个拉格朗日乘子 $\\nu \\in \\mathbb{R}^{r}$ 使得 $\\lambda(T) \\;=\\; C^{\\top}\\nu$ 且 $\\psi\\big(x(T)\\big)=0$。\n- 为了对初始协态实施单次打靶牛顿法，将 $\\lambda(0)$ 视为决策向量。对于任意猜测的 $\\lambda(0)$，使用 $u(t) = -R^{-1} B^{\\top}\\lambda(t)$ 将耦合的状态-协态 ODE 向前积分，以获得 $x(T)$ 和终端残差\n$$\nr\\big(\\lambda(0)\\big) \\;=\\; \\psi\\big(x(T)\\big) \\;=\\; C\\,x(T) \\;-\\; x_{T}.\n$$\n- 推导并积分关于 $\\lambda(0)$ 的变分 (灵敏度) ODE，以获得牛顿法所需的雅可比矩阵。设 $S(t) = \\dfrac{\\partial x(t)}{\\partial \\lambda(0)} \\in \\mathbb{R}^{n \\times n}$ 和 $M(t) = \\dfrac{\\partial \\lambda(t)}{\\partial \\lambda(0)} \\in \\mathbb{R}^{n \\times n}$。使用 $f(x,\\lambda) = A x + B u$ 和 $u(\\lambda) = -R^{-1} B^{\\top}\\lambda$ 的定义，以及协态动态，推导出线性时变矩阵 ODE\n$$\n\\begin{aligned}\n\\dot{S}(t) \\;=\\; A\\,S(t) \\;-\\; B\\,R^{-1} B^{\\top}\\,M(t), \\\\\n\\dot{M}(t) \\;=\\; -Q\\,S(t) \\;-\\; A^{\\top} M(t),\n\\end{aligned}\n$$\n初始条件为 $S(0) = 0$ 和 $M(0)=I_{n}$。约束的终端灵敏度则为\n$$\nJ\\big(\\lambda(0)\\big) \\;=\\; \\frac{\\partial \\psi(x(T))}{\\partial \\lambda(0)} \\;=\\; C\\,S(T).\n$$\n- 对 $\\lambda(0)$ 实施牛顿法，使用以下更新\n$$\n\\lambda(0) \\leftarrow \\lambda(0) \\;-\\; \\Delta, \\quad \\text{其中 } J\\,\\Delta \\;=\\; r.\n$$\n如果 $J$ 不是方阵或不可逆，则在最小二乘意义下求解。迭代直至 $\\lVert r \\rVert_{2}$ 低于指定容差或达到最大迭代次数。\n\n编程任务：\n- 实现一个程序，对每个给定的测试用例，执行上述牛顿型打靶法：\n    - 对 $\\big(x(t),\\lambda(t),S(t),M(t)\\big)$ 的耦合 ODE 系统在 $[0,T]$ 上进行数值积分。\n    - 计算终端残差 $r$ 和雅可比矩阵 $J$。\n    - 通过牛顿步中的线性求解更新 $\\lambda(0)$。\n    - 重复直至收敛。\n- 将 $r$ 的欧几里得范数停止容差设为 $\\varepsilon = 10^{-9}$，最大迭代次数为 10。\n- 将 $\\lambda(0)$ 初始化为零向量。\n- 使用 $10^{-10}$ 的绝对和相对 ODE 求解器容差。\n\n测试套件：\n提供以下四种情况的数值结果。每种情况下，$n = 2$，$m = 1$。\n\n- 情况 1 (理想情况，方形终端约束):\n    - $A = \\begin{bmatrix} 0  1 \\\\ -1  -\\tfrac{1}{2}\\end{bmatrix}$,\n      $B = \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix}$,\n      $Q = \\begin{bmatrix} 1  0 \\\\ 0  1 \\end{bmatrix}$,\n      $R = 1$,\n      $C = \\begin{bmatrix} 1  0 \\\\ 0  1 \\end{bmatrix}$,\n      $x_{0} = \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix}$,\n      $x_{T} = \\begin{bmatrix} 0 \\\\ 0 \\end{bmatrix}$,\n      $T = 2$.\n- 情况 2 (欠定终端约束，最小二乘牛顿步):\n    - $A = \\begin{bmatrix} 0  1 \\\\ -1  -\\tfrac{1}{2}\\end{bmatrix}$,\n      $B = \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix}$,\n      $Q = \\begin{bmatrix} 1  0 \\\\ 0  1 \\end{bmatrix}$,\n      $R = 1$,\n      $C = \\begin{bmatrix} 1  0 \\end{bmatrix}$,\n      $x_{0} = \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix}$,\n      $x_{T} = \\begin{bmatrix} 0 \\end{bmatrix}$,\n      $T = 2$.\n- 情况 3 (双积分器，方形终端约束):\n    - $A = \\begin{bmatrix} 0  1 \\\\ 0  0 \\end{bmatrix}$,\n      $B = \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix}$,\n      $Q = \\begin{bmatrix} 1  0 \\\\ 0  0.1 \\end{bmatrix}$,\n      $R = 0.1$,\n      $C = \\begin{bmatrix} 1  0 \\\\ 0  1 \\end{bmatrix}$,\n      $x_{0} = \\begin{bmatrix} 1 \\\\ -1 \\end{bmatrix}$,\n      $x_{T} = \\begin{bmatrix} 0 \\\\ 0 \\end{bmatrix}$,\n      $T = 1.5$.\n- 情况 4 (不同阻尼和单分量约束):\n    - $A = \\begin{bmatrix} 0  1 \\\\ -2  -0.2 \\end{bmatrix}$,\n      $B = \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix}$,\n      $Q = \\begin{bmatrix} 1  0 \\\\ 0  1 \\end{bmatrix}$,\n      $R = 10$,\n      $C = \\begin{bmatrix} 0  1 \\end{bmatrix}$,\n      $x_{0} = \\begin{bmatrix} 0.5 \\\\ -0.5 \\end{bmatrix}$,\n      $x_{T} = \\begin{bmatrix} 0 \\end{bmatrix}$,\n      $T = 1.2$.\n\n要求输出：\n- 对于每种情况，在牛顿迭代终止后，返回终端残差的欧几里得范数 $\\lVert r \\rVert_{2}$。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，每个残差四舍五入到 10 位小数，按情况 1 到 4 的顺序排列 (例如，$[0.0,0.0,0.0,0.0]$ 表示在舍入误差内精确满足)。\n\n约束和说明：\n- 不出现角度；不需要角度单位。\n- 没有要报告的显式物理单位。\n- 牛顿步使用数值稳定的线性代数运算 (对于可能非方阵的 $J$ 使用最小二乘法)。\n- 实现必须是自包含的，不需要输入，并以指定格式精确打印一行。", "solution": "问题陈述已经过严格验证，并被认定为有效。它在科学上基于最优控制理论的原理，特别是针对带终端约束的线性二次系统的庞特里亚金最小值原理。该问题是适定的、客观的，并提供了构建唯一且有意义的数值解所需的所有必要信息。不存在逻辑矛盾、事实不健全或含糊不清之处。因此，我们可以继续进行解的推导和实现。\n\n该问题要求解决一个有限时域最优控制问题，其定义为最小化一个二次型代价泛函：\n$$\nJ(u) = \\int_{0}^{T} \\tfrac{1}{2}\\,\\big(x(t)^{\\top} Q\\,x(t) + u(t)^{\\top} R \\, u(t)\\big)\\, dt\n$$\n受限于线性时不变动态系统：\n$$\n\\dot{x}(t) = A\\,x(t) + B\\,u(t), \\quad x(0) = x_{0}\n$$\n以及一个终端等式约束：\n$$\n\\psi\\big(x(T)\\big) = C\\,x(T) - x_{T} = 0\n$$\n这里，$x(t) \\in \\mathbb{R}^{n}$，$u(t) \\in \\mathbb{R}^{m}$，并且所有矩阵和向量都具有相容的维度。给定 $n=2$ 和 $m=1$。\n\n根据庞特里亚金最小值原理，我们引入哈密顿量 $H(x, u, \\lambda)$：\n$$\nH(x, u, \\lambda) = \\tfrac{1}{2}\\,\\big(x^{\\top} Q\\,x + u^{\\top} R\\,u\\big) + \\lambda^{\\top}(A x + B u)\n$$\n其中 $\\lambda(t) \\in \\mathbb{R}^{n}$ 是协态向量。最优性的必要条件是：\n1.  状态方程：$\\dot{x} = \\nabla_{\\lambda}H = Ax + Bu$。\n2.  协态方程：$\\dot{\\lambda} = -\\nabla_{x}H = -Qx - A^{\\top}\\lambda$。\n3.  最优性条件：$\\nabla_{u}H = Ru + B^{\\top}\\lambda = 0$。由于 $R$ 是正定的，这给出了用协态表示的最优控制律：\n    $$\n    u^{*}(t) = -R^{-1}B^{\\top}\\lambda(t)\n    $$\n4.  横截性条件：对于终端约束 $\\psi(x(T))=0$，必须存在一个拉格朗日乘子向量 $\\nu \\in \\mathbb{R}^{r}$，使得 $\\lambda(T) = \\frac{\\partial}{\\partial x(T)} [\\nu^\\top \\psi(x(T))]^\\top = C^\\top \\nu$。\n\n将最优控制 $u^*(t)$ 代入状态和协态方程，得到一个线性常微分方程 (ODE) 的耦合系统：\n$$\n\\begin{aligned}\n\\dot{x}(t) = A\\,x(t) - B\\,R^{-1}B^{\\top}\\lambda(t) \\\\\n\\dot{\\lambda}(t) = -Q\\,x(t) - A^{\\top}\\lambda(t)\n\\end{aligned}\n$$\n这可以写成块矩阵形式：\n$$\n\\frac{d}{dt}\\begin{pmatrix} x(t) \\\\ \\lambda(t) \\end{pmatrix} = \\begin{pmatrix} A  -BR^{-1}B^{\\top} \\\\ -Q  -A^{\\top} \\end{pmatrix} \\begin{pmatrix} x(t) \\\\ \\lambda(t) \\end{pmatrix}\n$$\n该系统构成一个两点边值问题 (TPBVP)，其边界条件为 $x(0) = x_0$ 和终端条件 $C x(T) - x_T = 0$。初始协态 $\\lambda(0)$ 是未知的。\n\n打靶法将此 TPBVP 转化为一个初值问题。我们将未知的初始协态 $\\lambda(0)$ 视为一个决策变量。对于一个给定的 $\\lambda(0)$ 猜测值，我们可以将 ODE 系统从 $t=0$ 到 $t=T$ 向前积分。这会产生一个作为初始猜测值函数的终端状态，即 $x(T; \\lambda(0))$。问题就变成了找到 $\\lambda(0)$ 以满足终端约束。这是一个关于残差函数 $r(\\lambda(0))$ 的求根问题：\n$$\nr\\big(\\lambda(0)\\big) = C\\,x(T; \\lambda(0)) - x_{T} = 0\n$$\n我们采用牛顿法来求解这个关于 $\\lambda(0)$ 的非线性方程组。迭代更新公式为：\n$$\n\\lambda(0)_{k+1} = \\lambda(0)_{k} - \\Delta_k\n$$\n其中 $\\Delta_k$ 是线性系统 $J_k \\Delta_k = r_k$ 的解。这里，$r_k = r(\\lambda(0)_k)$ 是第 $k$ 次迭代的残差，而 $J_k$ 是残差函数在 $\\lambda(0)_k$ 处求值的雅可比矩阵：\n$$\nJ(\\lambda(0)) = \\frac{\\partial r(\\lambda(0))}{\\partial \\lambda(0)} = C \\frac{\\partial x(T)}{\\partial \\lambda(0)}\n$$\n为了计算雅可比矩阵，我们需要终端状态相对于初始协态的灵敏度。我们定义灵敏度矩阵 $S(t) = \\frac{\\partial x(t)}{\\partial \\lambda(0)} \\in \\mathbb{R}^{n \\times n}$ 和 $M(t) = \\frac{\\partial \\lambda(t)}{\\partial \\lambda(0)} \\in \\mathbb{R}^{n \\times n}$。通过对耦合的 $(x, \\lambda)$ ODE 系统关于 $\\lambda(0)$ 求导，我们得到变分 (或灵敏度) 方程：\n$$\n\\frac{d}{dt}\\begin{pmatrix} S(t) \\\\ M(t) \\end{pmatrix} = \\begin{pmatrix} A  -BR^{-1}B^{\\top} \\\\ -Q  -A^{\\top} \\end{pmatrix} \\begin{pmatrix} S(t) \\\\ M(t) \\end{pmatrix}\n$$\n这些灵敏度矩阵的初始条件由原始系统的初始条件导出。因为 $x(0) = x_0$ 是固定的且不依赖于 $\\lambda(0)$，所以其导数为零：$S(0) = \\frac{\\partial x(0)}{\\partial \\lambda(0)} = 0$。初始协态 $\\lambda(0)$ 是自变量，所以它对自己求导得到单位矩阵：$M(0) = \\frac{\\partial \\lambda(0)}{\\partial \\lambda(0)} = I_n$。\n\n完整的数值流程如下。我们构建一个增广状态向量 $Y(t)$，它连接了状态、协态和向量化的灵敏度矩阵：\n$$\nY(t) = \\begin{pmatrix} x(t) \\\\ \\lambda(t) \\\\ \\text{vec}(S(t)) \\\\ \\text{vec}(M(t)) \\end{pmatrix} \\in \\mathbb{R}^{2n+2n^2}\n$$\n$Y(t)$ 的动态由四个耦合矩阵 ODE 的组合系统给出。基于牛顿的打靶法的数值算法如下：\n1.  初始化初始协态的猜测值，$\\lambda(0)_0 = 0 \\in \\mathbb{R}^n$。\n2.  对于每次迭代 $k = 0, 1, \\dots, \\text{max\\_iter}-1$：\n    a. 使用 $x_0$、当前猜测值 $\\lambda(0)_k$、$S(0) = 0$ 和 $M(0) = I_n$ 构建增广系统的初始条件 $Y(0)$。\n    b. 使用数值求解器 (例如，龙格-库塔法) 以高精度将增广 ODE 系统从 $t=0$ 积分到 $t=T$。\n    c. 从终端解 $Y(T)$ 中提取终端状态 $x(T)$ 和终端灵敏度矩阵 $S(T)$。\n    d. 计算残差 $r_k = C\\,x(T) - x_T$ 及其欧几里得范数 $\\|r_k\\|_2$。\n    e. 如果 $\\|r_k\\|_2$ 低于指定的容差 $\\varepsilon = 10^{-9}$，则达到收敛，迭代终止。\n    f. 计算雅可比矩阵 $J_k = C\\,S(T)$。\n    g. 求解线性系统 $J_k \\Delta_k = r_k$ 以获得更新步长 $\\Delta_k$。使用最小二乘求解器 (`numpy.linalg.lstsq`) 来稳健地处理方阵 ($r=n$) 和非方阵 ($r \\neq n$) 的雅可比矩阵。\n    h. 更新初始协态：$\\lambda(0)_{k+1} = \\lambda(0)_{k} - \\Delta_k$。\n3.  在循环终止后 (无论是通过收敛还是达到最大迭代次数)，最终的残差范数 $\\|r_k\\|_2$ 将作为结果报告。\n\n对提供的四个测试用例均实施此流程。用于 ODE 求解器的状态向量是一个包含 $x$、$\\lambda$、$S$ 和 $M$ 所有分量的一维扁平化数组。ODE 系统函数正确地解包此向量，计算导数，并将它们作为扁平化向量返回。", "answer": "```python\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and run the shooting method for each.\n    \"\"\"\n    \n    # Case 1: happy path, square terminal constraint\n    case1 = {\n        \"A\": np.array([[0, 1], [-1, -0.5]]),\n        \"B\": np.array([[0], [1]]),\n        \"Q\": np.array([[1, 0], [0, 1]]),\n        \"R\": 1.0,\n        \"C\": np.array([[1, 0], [0, 1]]),\n        \"x0\": np.array([1, 0]),\n        \"xT\": np.array([0, 0]),\n        \"T\": 2.0\n    }\n\n    # Case 2: underdetermined terminal constraint\n    case2 = {\n        \"A\": np.array([[0, 1], [-1, -0.5]]),\n        \"B\": np.array([[0], [1]]),\n        \"Q\": np.array([[1, 0], [0, 1]]),\n        \"R\": 1.0,\n        \"C\": np.array([[1, 0]]),\n        \"x0\": np.array([1, 0]),\n        \"xT\": np.array([0]),\n        \"T\": 2.0\n    }\n\n    # Case 3: double integrator, square terminal constraint\n    case3 = {\n        \"A\": np.array([[0, 1], [0, 0]]),\n        \"B\": np.array([[0], [1]]),\n        \"Q\": np.array([[1, 0], [0, 0.1]]),\n        \"R\": 0.1,\n        \"C\": np.array([[1, 0], [0, 1]]),\n        \"x0\": np.array([1, -1]),\n        \"xT\": np.array([0, 0]),\n        \"T\": 1.5\n    }\n\n    # Case 4: different damping and single component constraint\n    case4 = {\n        \"A\": np.array([[0, 1], [-2, -0.2]]),\n        \"B\": np.array([[0], [1]]),\n        \"Q\": np.array([[1, 0], [0, 1]]),\n        \"R\": 10.0,\n        \"C\": np.array([[0, 1]]),\n        \"x0\": np.array([0.5, -0.5]),\n        \"xT\": np.array([0]),\n        \"T\": 1.2\n    }\n\n    test_cases = [case1, case2, case3, case4]\n    results = []\n\n    for case in test_cases:\n        final_residual_norm = run_shooting_method(\n            case[\"A\"], case[\"B\"], case[\"Q\"], case[\"R\"], case[\"C\"],\n            case[\"x0\"], case[\"xT\"], case[\"T\"]\n        )\n        results.append(f\"{final_residual_norm:.10f}\")\n\n    print(f\"[{','.join(results)}]\")\n\ndef run_shooting_method(A, B, Q, R, C, x0, xT, T):\n    \"\"\"\n    Performs the Newton-type shooting method for a single optimal control problem.\n\n    Args:\n        A, B, Q, R, C: System matrices\n        x0, xT: Initial state and target vector for the terminal constraint\n        T: Final time\n\n    Returns:\n        The Euclidean norm of the final terminal residual.\n    \"\"\"\n    n = A.shape[0]\n    \n    # Since R is a scalar m=1, R_inv is simple.\n    R_inv = 1.0 / R\n    \n    # Pre-compute matrix products for efficiency in the ODE function.\n    BRB_T = B @ B.T * R_inv\n\n    def ode_system(t, y):\n        \"\"\"\n        Defines the augmented ODE system for [x, lambda, S, M].\n        y is a flattened vector of size (2n + 2n^2).\n        \"\"\"\n        # Unpack state vector y\n        x = y[0:n]\n        lam = y[n:2*n]\n        S_flat = y[2*n : 2*n + n*n]\n        M_flat = y[2*n + n*n : 2*n + 2*n*n]\n        \n        S = S_flat.reshape((n, n))\n        M = M_flat.reshape((n, n))\n        \n        # State and Costate ODEs\n        dx_dt = A @ x - BRB_T @ lam\n        dlam_dt = -Q @ x - A.T @ lam\n        \n        # Sensitivity ODEs\n        dS_dt = A @ S - BRB_T @ M\n        dM_dt = -Q @ S - A.T @ M\n        \n        # Pack derivatives into a flat vector for the solver\n        dy_dt = np.concatenate((\n            dx_dt,\n            dlam_dt,\n            dS_dt.flatten(),\n            dM_dt.flatten()\n        ))\n        return dy_dt\n\n    # Newton's method settings\n    lambda0 = np.zeros(n)\n    max_iter = 10\n    conv_tol = 1e-9\n    ode_tol = 1e-10\n\n    residual_norm = -1.0\n\n    for i in range(max_iter):\n        # Set initial conditions for the augmented system\n        S0 = np.zeros((n, n))\n        M0 = np.eye(n)\n        y0 = np.concatenate((\n            x0,\n            lambda0,\n            S0.flatten(),\n            M0.flatten()\n        ))\n        \n        # Integrate the augmented ODEs\n        sol = solve_ivp(\n            ode_system,\n            [0, T],\n            y0,\n            method='RK45', \n            rtol=ode_tol,\n            atol=ode_tol\n        )\n        \n        # Extract terminal values from the integration result\n        y_T = sol.y[:, -1]\n        x_T_sim = y_T[0:n]\n        S_T = y_T[2*n : 2*n + n*n].reshape((n, n))\n        \n        # Compute the terminal residual and its norm\n        residual = C @ x_T_sim - xT\n        residual_norm = np.linalg.norm(residual)\n        \n        # Check for convergence\n        if residual_norm  conv_tol:\n            break\n            \n        # Compute the Jacobian for the Newton step\n        jacobian = C @ S_T\n        \n        # Solve for the Newton update delta: J * delta = r\n        # Use least squares to handle both square and non-square Jacobians\n        delta, _, _, _ = np.linalg.lstsq(jacobian, residual, rcond=None)\n        \n        # Update the initial costate guess\n        lambda0 = lambda0 - delta\n        \n    return residual_norm\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2698225"}]}