## 引言
在现代工程与科学系统中，控制器不仅需要引导系统实现期望的性能，还必须在严格的物理、安全和经济约束下运行。传统控制方法在系统性地处理这些复杂约束方面常常力有不逮，而[模型预测控制](@entry_id:146965)（Model Predictive Control, MPC）正是在这一背景下应运而生并大放异彩的先进控制策略。MPC的核心思想是通过预测系统未来的动态行为，并在每一个决策瞬间进行[在线优化](@entry_id:636729)，从而找到既满足所有约束又能在某种意义上达到最优的控制策略。这种前瞻性和处理约束的内在能力，使其成为解决现代复杂动态系统控制问题的关键技术。

本文旨在为读者提供一个关于[模型预测控制](@entry_id:146965)原理的全面而深入的指南，系统地解决“MPC是什么”以及“它为什么有效”这两个核心问题。我们将通过三个层次递进的章节来构建您的知识体系：
*   在**“原理与机制”**一章中，我们将深入剖析MPC的理论基石，从其[滚动时域](@entry_id:181425)优化的核心理念，到如何将控制问题转化为可计算的二次规划（QP）问题，再到确保系统稳定性的关键——终端成分的设计。
*   在**“应用与[交叉](@entry_id:147634)学科联系”**一章中，我们将理论与实践相结合，通过一系列覆盖[控制工程](@entry_id:149859)、[机器人学](@entry_id:150623)、经济优化乃至生物医学工程的案例，展示MPC作为一种通用优化框架的强大威力与灵活性。
*   最后，在**“动手实践”**部分，您将通过解决具体问题来巩固所学知识，亲身体验从理论构建到鲁棒性实现的全过程。

现在，让我们从MPC最根本的构成要素开始，深入探索其精妙的原理与工作机制。

## 原理与机制

在“引言”章节中，我们概述了[模型预测控制](@entry_id:146965)（MPC）作为一种先进控制策略的动机和基本思想。本章将深入探讨其核心原理与工作机制，从其数学表述、稳定性保证到应对现实世界复杂性的高级扩展。我们将系统地构建一个框架，不仅解释MPC“做什么”，更重要的是解释它“为什么”能有效工作。

### 核心思想：滚动优化的[最优控制](@entry_id:138479)

[模型预测控制](@entry_id:146965)的基石是一个在每个采样时刻重复执行的简单而强大的理念：基于系统模型，预测未来的系统行为，并在线求解一个开环最优控制问题，然后将该优化结果的初始部分应用于系统。这一过程在时间上不断“滚动”向前，从而形成一个闭环反馈策略。

#### 系统预测模型

为了预测未来，MPC必须依赖于一个描述系统动态行为的数学模型。在[数字控制](@entry_id:275588)的背景下，最常用的模型是[离散时间状态空间](@entry_id:261361)表示。对于一个线性时不变（LTI）系统，其动态可以表示为：
$$
x_{k+1} = A x_k + B u_k
$$
其中，$x_k \in \mathbb{R}^n$ 是在时刻 $k$ 的系统状态向量，$u_k \in \mathbb{R}^m$ 是控制输入向量，$A \in \mathbb{R}^{n \times n}$ 和 $B \in \mathbb{R}^{n \times m}$ 分别是状态矩阵和输入矩阵。

在许多实际应用中，被控对象（plant）本质上是连续时间的，其动态由[微分方程](@entry_id:264184) $\dot{x}(t) = A_c x(t) + B_c u(t)$ 描述。为了将其转换为MPC所需的离散时间形式，必须进行离散化。一个精确且常用的方法是假设控制输入在每个[采样周期](@entry_id:265475) $T_s$ 内保持不变，即采用**[零阶保持器](@entry_id:264751)（Zero-Order Hold, ZOH）**。在这种假设下，从时刻 $t_k = k T_s$ 到 $t_{k+1} = (k+1) T_s$，[连续时间系统](@entry_id:276553)的精确解可以推导出离散时间模型中的矩阵 $A$ 和 $B$ [@problem_id:2724702]。

具体而言，离散状态矩阵 $A$ 是连续状态矩阵 $A_c$ 的**矩阵指数**：
$$
A = \exp(A_c T_s)
$$
而离散输入矩阵 $B$ 通过对[矩阵指数](@entry_id:139347)的积分得到：
$$
B = \left( \int_{0}^{T_s} \exp(A_c \tau) \, \mathrm{d}\tau \right) B_c
$$
如果 $A_c$ 是可逆的，这个积分有一个更简洁的[封闭形式](@entry_id:272960)：$B = A_c^{-1} (\exp(A_c T_s) - I) B_c$。然而，即使 $A_c$ 是奇异的（例如，包含[积分器](@entry_id:261578)），积分形式的定义仍然有效。此外，这些矩阵还可以通过一个巧妙的计算技巧得到，即计算一个[增广矩阵](@entry_id:150523)的指数 [@problem_id:2724702]：
$$
\exp\left(\begin{pmatrix} A_c  B_c \\ 0  0 \end{pmatrix} T_s\right) = \begin{pmatrix} A  B \\ 0  I \end{pmatrix}
$$
值得注意的是，像前向欧拉法这样的简单[数值近似](@entry_id:161970)（$A \approx I + A_c T_s, B \approx B_c T_s$）虽然计算简单，但除非 $T_s$ 极小，否则它并不是精确的表示，可能导致显著的模型失配和性能下降。

#### 有限时域最优控制问题 (FHOCP)

在每个采样时刻 $t$（离散时刻 $k$），MPC控制器会测量或估计当前状态 $x(t)$。然后，它求解一个**有限时域最优控制问题（Finite-Horizon Optimal Control Problem, FHOCP）**，以确定未来 $N$ 步的[最优控制](@entry_id:138479)序列 $\mathbf{u} = \{u_0, u_1, \ldots, u_{N-1}\}$。一个典型的FHOCP表述如下 [@problem_id:2724696]：

**最小化** 一个[代价函数](@entry_id:138681) $J$，它由两部分组成：
1.  **阶段代价（Stage Cost）**：对[预测时域](@entry_id:261473)内每个时刻的状态偏差和控制能耗进行惩罚。
2.  **终端代价（Terminal Cost）**：对[预测时域](@entry_id:261473)终点（时刻 $N$）的状态进行惩罚。

一个标准的二次代价函数形式为：
$$
J = \underbrace{\sum_{i=0}^{N-1} (x_i^\top Q x_i + u_i^\top R u_i)}_{\text{阶段代价}} + \underbrace{x_N^\top P x_N}_{\text{终端代价}}
$$
其中，$Q \succeq 0$ 和 $R \succ 0$ 是调节[状态和](@entry_id:193625)输入权重的对称矩阵，$P \succeq 0$ 是终端权重矩阵。

该[优化问题](@entry_id:266749)**受制于**一系列约束：
1.  **[初始条件](@entry_id:152863)**：预测轨迹的起点必须是当前测量的状态：$x_0 = x(t)$。
2.  **系统动态**：预测的状态序列必须遵循系统模型：$x_{i+1} = A x_i + B u_i$ for $i=0, \ldots, N-1$。
3.  **状态与输入约束**：预测的整个[状态和](@entry_id:193625)输入序列必须位于允许的集合内：$x_i \in \mathcal{X}$ 和 $u_i \in \mathcal{U}$。这些约束通常代表物理限制，如[执行器饱和](@entry_id:274581)、安全操作区域等。
4.  **[终端约束](@entry_id:176488)**：预测轨迹的终点状态必须位于一个预先定义的**[终端集](@entry_id:163892)** $\mathcal{X}_f$ 内：$x_N \in \mathcal{X}_f$。

#### [滚动时域](@entry_id:181425)策略

在求解上述FHOCP得到最优控制序列 $\{u_0^\star, u_1^\star, \ldots, u_{N-1}^\star\}$ 后，MPC并不执行整个序列。取而代之的是，它只将序列的**第一个元素** $u_0^\star$ 应用于被控对象。随后，它会**丢弃**该[优化问题](@entry_id:266749)的其余部分。

在下一个采样时刻 $t+1$，系统演化到新的状态 $x(t+1)$。控制器会测量这个新状态，并以此为新的[初始条件](@entry_id:152863)，再次求解一个从 $t+1$ 开始、长度为 $N$ 的FHOCP。这个“求解-应用-测量-重复”的循环，就是**[滚动时域](@entry_id:181425)（Receding Horizon）**或**滚动优化（Rolling Horizon）**策略的精髓。正是这种不断重新规划并利用最新状态信息（即反馈）的机制，使得MPC能够有效应对扰动和[模型不确定性](@entry_id:265539)，尽管其每次求解的都是一个开环的[最优控制](@entry_id:138479)问题。

### 计算机制：二次规划（QP）的构建

理论上的FHOCP表述必须转化为一个计算机可以高效求解的具体数学问题。对于具有线性动态、二次代价和多胞体约束（即[线性不等式](@entry_id:174297)约束）的MPC问题，FHOCP可以被精确地转化为一个**二次规划（Quadratic Program, QP）**问题。Q[P问题](@entry_id:267898)是[凸优化](@entry_id:137441)中研究得最透彻的问题之一，存在多种成熟的数值求解器。

转化的核心在于将问题的所有决策变量和约束都表示成一个统一的形式。这个过程通常称为**凝聚（Condensation）**，因为它将[状态变量](@entry_id:138790)从[优化问题](@entry_id:266749)中“凝聚”掉，只留下控制输入序列作为唯一的决策变量。

#### 预测矩阵与[代价函数](@entry_id:138681)重写

首先，我们通过递归展开系统动态方程，将未来所有预测状态 $x_1, \ldots, x_N$ 表示为初始状态 $x_0$ 和控制输入序列 $U = \begin{pmatrix} u_0^\top  \cdots  u_{N-1}^\top \end{pmatrix}^\top$ 的线性函数 [@problem_id:2724637]：
$$
\underbrace{\begin{pmatrix} x_1 \\ x_2 \\ \vdots \\ x_N \end{pmatrix}}_{\mathbf{X}} = \underbrace{\begin{pmatrix} A \\ A^2 \\ \vdots \\ A^N \end{pmatrix}}_{\mathcal{A}} x_0 + \underbrace{\begin{pmatrix} B  0  \cdots  0 \\ AB  B  \cdots  0 \\ \vdots  \vdots  \ddots  \vdots \\ A^{N-1}B  A^{N-2}B  \cdots  B \end{pmatrix}}_{\mathcal{B}} U
$$
这里的 $\mathcal{A}$ 和 $\mathcal{B}$ 称为**预测矩阵**。$\mathcal{B}$ 是一个块下三角[托普利茨矩阵](@entry_id:271334)。

利用这些堆叠的向量和矩阵，原代价函数 $J$ 可以重写为仅关于决策变量 $U$ 的函数。状态相关的代价项变为：
$$
x_0^\top Q x_0 + \mathbf{X}^\top \mathcal{Q} \mathbf{X} = x_0^\top Q x_0 + (\mathcal{A}x_0 + \mathcal{B}U)^\top \mathcal{Q} (\mathcal{A}x_0 + \mathcal{B}U)
$$
其中 $\mathcal{Q} = \mathrm{diag}(Q, \ldots, Q, P)$ 是块对角的状态权重矩阵。输入相关的代价项则简单地是 $U^\top \mathcal{R} U$，其中 $\mathcal{R} = \mathrm{diag}(R, \ldots, R)$。

展开并合并所有项后，代价函数 $J$ 可以被整理成标准QP代价函数的形式：
$$
J(U) = \frac{1}{2} U^\top H U + h^\top U + c
$$
通过比较系数，我们可以得到**Hessian矩阵** $H$ 和**梯度向量** $h$ 的表达式 [@problem_id:2724637]：
$$
H = 2(\mathcal{B}^\top \mathcal{Q} \mathcal{B} + \mathcal{R})
$$
$$
h = 2\mathcal{B}^\top \mathcal{Q} \mathcal{A} x_0
$$
常数项 $c$ 不影响优化结果。注意到Hessian矩阵 $H$ 是常数，可以在[控制器设计](@entry_id:274982)阶段离线计算。而梯度向量 $h$ 线性依赖于当前状态 $x_0$，需要在每个采样时刻在线更新。

#### 约束的线性化

接下来，所有的[状态和](@entry_id:193625)输入约束也必须转化为关于 $U$ 的[线性不等式](@entry_id:174297)，形式为 $G U \le w$。

**输入约束** $u_k \in \mathcal{U}$ for $k=0,\ldots,N-1$，如果 $\mathcal{U}$ 是一个由 $H_u u \le h_u$ 定义的多胞体，那么所有 $N$ 个约束可以被简单地堆叠成一个大的块[对角形式](@entry_id:264850) [@problem_id:2724707]：
$$
(I_N \otimes H_u) U \le (\mathbf{1}_N \otimes h_u)
$$
其中 $\otimes$ 表示克罗内克积，$I_N$ 是 $N$ 维单位矩阵，$\mathbf{1}_N$ 是元素全为1的 $N$ 维列向量。

**状态约束** $x_k \in \mathcal{X}$ for $k=1,\ldots,N$，如果 $\mathcal{X}$ 是一个由 $H_x x \le h_x$ 定义的多胞体，我们首先将其写成堆叠形式 $(I_N \otimes H_x) \mathbf{X} \le (\mathbf{1}_N \otimes h_x)$。然后，利用预测方程 $\mathbf{X} = \mathcal{A} x_0 + \mathcal{B} U$ 替换 $\mathbf{X}$，并将与 $x_0$ 相关的项（在优化时是常数）移到不等式右侧，得到 [@problem_id:2724707]：
$$
(I_N \otimes H_x) \mathcal{B} U \le (\mathbf{1}_N \otimes h_x) - (I_N \otimes H_x) \mathcal{A} x_0
$$

将输入和状态约束的所有这些[线性不等式](@entry_id:174297)组合在一起，我们就得到了一个单一的大型[线性不等式](@entry_id:174297) $G U \le w + E x_0$，其中 $G, w, E$ 是由系统和约束参数构成的适当维度的矩阵。

最终，在每个采样时刻，MPC控制器求解以下标准Q[P问题](@entry_id:267898)：
$$
\min_{U} \quad \frac{1}{2} U^\top H U + h^\top U \quad \text{subject to} \quad G U \le w + E x_0
$$
这清晰地揭示了MPC的计算本质：它是一个反复求解[参数化](@entry_id:272587)QP的过程，其中参数（[梯度向量](@entry_id:141180) $h$ 和不等式右侧）随当前状态 $x_0$ 变化。

### 稳定性保证：终端成分的设计

一个设计良好的控制器必须能保证[闭环系统](@entry_id:270770)的稳定。对于MPC，这意味着两个关键性质：

1.  **[递归可行性](@entry_id:167169)（Recursive Feasibility）**：如果FHOCP在当前时刻 $k$ 有解，那么在未来的所有时刻 $k+1, k+2, \ldots$ 它也必须有解。否则，控制器将在某个时刻无法计算出合法的控制输入，导致控制失败。
2.  **[渐近稳定性](@entry_id:149743)（Asymptotic Stability）**：在没有扰动的情况下，[闭环系统](@entry_id:270770)状态应收敛到[平衡点](@entry_id:272705)（通常是原点）。

仅仅选择一个有限的[预测时域](@entry_id:261473) $N$ 并不能自动保证这些性质。稳定性的秘诀在于对**终端代价** $x_N^\top P x_N$ 和**[终端集](@entry_id:163892)** $\mathcal{X}_f$ 的审慎设计。这些“终端成分”的作用是为有限时域[优化问题](@entry_id:266749)提供一个关于时域之外（即从时刻 $N$ 到无穷远）的近似价值和安全区域的概要。

#### 稳定性证明框架

证明MPC稳定性的标准方法是证明FHOCP的最优代价值 $V_N^*(x)$ 是一个**[李雅普诺夫函数](@entry_id:273986)**。这意味着我们需要证明 $V_N^*(x)$ 是正定的，并且沿着闭环轨迹是严格递减的。

证明过程的精髓如下 [@problem_id:2724726] [@problem_id:2884303]：
在时刻 $k$，我们求解得到最优序列 $\{u_{i|k}^\star\}_{i=0}^{N-1}$ 和最优状态轨迹 $\{x_{i|k}^\star\}_{i=0}^{N}$。施加控制 $u_k = u_{0|k}^\star$ 后，系统到达新状态 $x_{k+1} = x_{1|k}^\star$。

为了证明**[递归可行性](@entry_id:167169)**，我们在时刻 $k+1$ 构造一个可行（但不一定最优）的控制序列。一个自然的选择是采用时刻 $k$ 计划的“尾巴”，并附加一个新的终端控制：$\{u_{1|k}^\star, \ldots, u_{N-1|k}^\star, u_{N|k}\}$。为确保这个序列完全可行，最后的控制 $u_{N|k}$ 必须能将状态 $x_{N|k}^\star$ 保持在约束内，并引导其后继状态 $x_{N+1|k}$ 仍在[终端集](@entry_id:163892) $\mathcal{X}_f$ 中。

为了证明**李雅普诺夫递减性** ($V_N^*(x_{k+1})  V_N^*(x_k)$)，我们将上述构造的可行序列的代价与 $V_N^*(x_k)$ 进行比较。经过推导，代价的差值可以被约束为：
$$
V_N^*(x_{k+1}) - V_N^*(x_k) \le -\ell(x_k, u_k^\star) + \left[ \ell(x_N^\star, u_N) + V_f(x_{N+1}) - V_f(x_N^\star) \right]
$$
其中 $\ell(x,u) = x^\top Q x + u^\top R u$ 是阶段代价。要使 $V_N^*$ 成为[李雅普诺夫函数](@entry_id:273986)，我们必须确保方括号内的项是非正的。

#### 构造稳定的终端成分

上述分析引出了保证稳定性的充分条件，这些条件将终端代价和[终端集](@entry_id:163892)与一个预先设计的**局部[稳定控制器](@entry_id:168369)** $u=Kx$ 联系起来 [@problem_id:2724726] [@problem_id:2884303]：

1.  **终端控制器**：选择一个线性[反馈增益](@entry_id:271155) $K$，使得[闭环系统](@entry_id:270770) $x_{k+1} = (A+BK)x_k$ 是稳定的（即 $A+BK$ 是舒尔矩阵）。一个系统化且最优的选择是使用与MPC阶段代价 $(Q,R)$ 相同的权重，求解**[线性二次调节器](@entry_id:267871)（LQR）**问题。

2.  **终端代价**：终端代价权重 $P$ 应选为与上述[LQR问题](@entry_id:267315)相关的**离散[代数黎卡提方程](@entry_id:193917)（DARE）**的解：
    $$
    P = A^\top P A - (A^\top P B)(R+B^\top P B)^{-1}(B^\top P A) + Q
    $$
    这个特定的 $P$ 恰好满足李雅普诺夫递减条件，即 $V_f((A+BK)x) - V_f(x) = -\ell(x, Kx)$，使得上述代价差值不等式中的方括号项为零。

3.  **[终端集](@entry_id:163892)**：[终端集](@entry_id:163892) $\mathcal{X}_f$ 必须是[闭环系统](@entry_id:270770) $x_{k+1}=(A+BK)x_k$ 的一个**正[不变集](@entry_id:275226)（Positively Invariant Set）**。这意味着，任何从 $\mathcal{X}_f$ 内部开始的轨迹，在 $u=Kx$ 的控制下，将永远保持在 $\mathcal{X}_f$ 内部。同时，为满足约束，$\mathcal{X}_f$ 必须满足：
    *   $x \in \mathcal{X}_f \implies x \in \mathcal{X}$ （状态约束）
    *   $x \in \mathcal{X}_f \implies Kx \in \mathcal{U}$ （输入约束）

满足这些条件的 $\mathcal{X}_f$ 保证了[递归可行性](@entry_id:167169)。一个常见的选择是形如 $\mathcal{X}_f = \{x \mid x^\top P x \le \alpha\}$ 的[椭球体](@entry_id:165811)，其中 $P$ 是DARE的解。我们需要找到最大的 $\alpha > 0$，使得这个椭球完全位于[状态和](@entry_id:193625)输入约束所定义的区域内 [@problem_id:2724634]。

**例：[终端集](@entry_id:163892)计算**
考虑系统 $A = \begin{pmatrix} 1  1 \\ 0  1 \end{pmatrix}$, $B = \begin{pmatrix} 0 \\ 1 \end{pmatrix}$，代价权重 $Q=I, R=1$，以及约束 $|x_1| \le 1, |x_2| \le 1, |u| \le 1$。
首先，求解DARE得到 $P \approx \begin{pmatrix} 2.95  2.37 \\ 2.37  4.61 \end{pmatrix}$ 和LQR增益 $K \approx \begin{pmatrix} -0.42  -1.24 \end{pmatrix}$。
然后，我们寻找最大的 $\alpha$，使得椭球 $x^\top P x \le \alpha$ 内的所有点都满足约束。
-   $|x_1| \le 1$ 对 $\alpha$ 的限制为 $\alpha \le 1/(P^{-1})_{11} \approx 1.73$。
-   $|x_2| \le 1$ 对 $\alpha$ 的限制为 $\alpha \le 1/(P^{-1})_{22} \approx 2.71$。
-   $|Kx| \le 1$ 对 $\alpha$ 的限制为 $\alpha \le 1/(K P^{-1} K^\top) \approx 2.76$。
因此，最大的可行 $\alpha^\star$ 是这些值中的最小值，即 $\alpha^\star \approx 1.73$ [@problem_id:2724634]。这提供了一个具体的方法来构造保证稳定性的[终端集](@entry_id:163892)。

### 高级主题与实践扩展

基础的MPC框架虽然强大，但在面对更复杂的现实场景时需要扩展。以下我们探讨两个重要的方向：鲁棒性和处理约束冲突。

#### 应对不确定性：[鲁棒模型预测控制](@entry_id:174393)

现实世界中的系统总是受到扰动 $w_k$ 的影响，其动态更准确地描述为 $x_{k+1} = A x_k + B u_k + w_k$。标称MPC（即假设 $w_k=0$ 的MPC）在存在扰动时可能会违反约束，甚至导致[优化问题](@entry_id:266749)变得不可行。[鲁棒MPC](@entry_id:174393)旨在显式地处理这些不确定性。

**[不变集](@entry_id:275226)概念的演进**
在标称MPC中，我们使用**控制[不变集](@entry_id:275226)（Control Invariant Set）**的概念来设计[终端集](@entry_id:163892)。一个集合 $C$ 是控制不变的，如果对于集合中的任意状态 $x \in C$，**存在**一个允许的控制 $u \in \mathcal{U}$，使得后继状态 $Ax+Bu$ 仍在 $C$ 内 [@problem_id:2724771]。

为了处理扰动，我们需要一个更强的概念：**鲁棒正[不变集](@entry_id:275226)（Robust Positively Invariant, RPI, Set）**。对于一个受扰动的系统 $x_{k+1} = f(x_k) + w_k$，一个集合 $S$ 是RPI的，如果对于集合中的任意状态 $x \in S$ 和**任意**可能的扰动 $w \in \mathcal{W}$，后继状态 $f(x)+w$ 都保持在 $S$ 内。这个“任意扰动”的量词是其与控制不变性的根本区别。

**基于管道（Tube-based）的[鲁棒MPC](@entry_id:174393)**
一种流行且直观的[鲁棒MPC](@entry_id:174393)方法是“管道MPC” [@problem_id:2724771]。其思想是将真实状态 $x_k$ 分解为一个标称状态 $\bar{x}_k$ 和一个误差状态 $e_k = x_k - \bar{x}_k$。
-   标称状态 $\bar{x}_k$ 遵循无扰动的标称模型 $\bar{x}_{k+1} = A \bar{x}_k + B v_k$，并由一个MPC控制器（针对标称输入 $v_k$）进行优化。
-   误差状态 $e_k$ 由一个局部反馈律 $u_k = v_k + K e_k$ 来抑制。误差动态为 $e_{k+1} = (A+BK)e_k + w_k$。
-   设计的关键是找到一个RPI集 $\mathcal{Z}$（称为管道[截面](@entry_id:154995)），使得如果初始误差 $e_0 \in \mathcal{Z}$，那么对于所有未来的扰动 $w_k \in \mathcal{W}$，误差将永远被限制在管道内，即 $e_k \in \mathcal{Z}$。

为了确保真实状态 $x_k$ 和真实输入 $u_k$ 始终满足原始硬约束，标称MPC必须在一个**收紧的约束集**内进行优化。这些收紧的集是通过从原始约束集中“雕刻”出误差可能占据的空间来获得的，这个操作称为**庞特里亚金[差集](@entry_id:140904)（Pontryagin Difference）** $\mathcal{A} \ominus \mathcal{B} = \{x \mid x+\mathcal{B} \subseteq \mathcal{A}\}$ [@problem_id:2724784]。
-   收紧的状态约束集为 $\mathcal{X}_{\text{tight}} = \mathcal{X} \ominus \mathcal{Z}$。
-   收紧的输入约束集为 $\mathcal{U}_{\text{tight}} = \mathcal{U} \ominus K\mathcal{Z}$，其中 $K\mathcal{Z} = \{Kz \mid z \in \mathcal{Z}\}$。

例如，如果状态约束为 $|x_1| \le 4$，管道[截面](@entry_id:154995)为 $|e_1| \le 0.6$，那么标称状态必须满足 $|\bar{x}_1| \le 4 - 0.6 = 3.4$ [@problem_id:2724784]。通过在这种更保守的约束下为标称系统规划路径，我们可以保证即使在最坏的扰动情况下，真实系统也永远不会违反原始约束。

#### 应对[不可行性](@entry_id:164663)：软约束

当系统受到大的、未预料到的扰动时，即使是[鲁棒MPC](@entry_id:174393)，其[优化问题](@entry_id:266749)也可能变得不可行（例如，没有任何控制序列可以在收紧的约束内将状态带回[终端集](@entry_id:163892)）。为了避免控制器在这种情况下彻底失效，我们可以引入**软约束（Soft Constraints）** [@problem_id:2724828]。

其思想是引入非负的**[松弛变量](@entry_id:268374)** $s_k \ge 0$，允许约束在必要时被违反。例如，一个硬约束 $Cx_k \le d$ 被软化为 $Cx_k \le d + s_k$。当然，这些[松弛变量](@entry_id:268374)必须被惩罚，以激励优化器尽可能地使它们为零。这通过在[代价函数](@entry_id:138681)中增加一个惩罚项来实现。

常用的惩罚有两种 [@problem_id:2724828]：
1.  **线性（$L_1$）惩罚**：在[代价函数](@entry_id:138681)中加入 $\rho \sum_k \|s_k\|_1$。从[KKT条件](@entry_id:185881)可知，这等价于[对相关](@entry_id:203353)约束的拉格朗日乘子设置一个[上界](@entry_id:274738) $\rho$。这种惩罚倾向于产生**稀疏**的违规，即当违规不可避免时，优化器倾向于让少数几个[松弛变量](@entry_id:268374)承担所有违规，而其他变量保持为零。
2.  **二次（$L_2^2$）惩罚**：在[代价函数](@entry_id:138681)中加入 $\rho \sum_k \|s_k\|_2^2$。在这种情况下，拉格朗日乘子与[松弛变量](@entry_id:268374)的大小成正比。由于平方项的存在，大的违规会受到不成比例的重罚。因此，这种惩罚倾向于将不可避免的违规**分散**到多个时刻或多个约束上，产生更“平滑”的违规行为。

使用软约束的主要优点是，只要输入集 $\mathcal{U}$ 非空，[优化问题](@entry_id:266749)总是**可行**的 [@problem_id:2724828]。对于任何给定的输入序列，总能找到足够大的[松弛变量](@entry_id:268374)来满足被软化的状态约束。这极大地增强了MPC控制器在恶劣条件下的鲁棒性和可靠性。