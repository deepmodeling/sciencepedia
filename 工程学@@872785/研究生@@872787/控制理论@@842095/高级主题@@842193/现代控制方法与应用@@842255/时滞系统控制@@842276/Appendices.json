{"hands_on_practices": [{"introduction": "要真正掌握史密斯预估器的威力，没有什么比通过一个具体的例子进行分析和设计更有效了。这个练习将指导你完成一个典型的连续时间系统的控制设计流程，首先为无延迟部分设计一个控制器，然后将其嵌入史密斯预估器架构中。通过推导闭环传递函数，你将亲眼见证史密斯预估器如何巧妙地将时滞项从特征方程中移除，从而实现对有大时滞系统的有效控制。[@problem_id:2696599]", "problem": "考虑一个稳定的、严格真分的时滞对象，其传递函数为 $P(s)=G(s)\\exp(-Ls)$，其中 $G(s)=\\frac{1}{(s+1)^{2}}$ 且 $L=1$（时间单位为秒）。一个形如 $C(s)=k\\frac{s+z}{s+p}$ 的严格真分控制器被用于一个史密斯预估器结构中，该结构使用对象的精确内部模型。您将为无时滞对象 $G(s)$ 设计控制器 $C(s)$，然后解析地推导使用和不使用史密斯预估器时的闭环传递函数。\n\n从史密斯预估器结构的定义和标准框图代数出发，执行以下步骤：\n\n1) 对于围绕 $G(s)$ 的无时滞回路，要求闭环特征多项式在 $s=-a$ 处有一个三阶实数重根，其中 $a=\\frac{2}{3}$，并且从参考输入到输出的无时滞闭环具有单位稳态增益。使用这两个规范来确定 $k$、$z$ 和 $p$ 的值。\n\n2) 使用精确的史密斯预估器（具有精确的内部模型）和您在步骤1中得到的 $C(s)$，从第一性原理出发，为整个时滞对象推导从参考输入到输出的闭环传递函数 $T_{\\mathrm{SP}}(s)$。然后，在时域中推导相应的单位阶跃响应 $y_{\\mathrm{SP}}(t)$。\n\n3) 为了进行比较，推导不使用史密斯预估器时的标准单位反馈闭环传递函数 $T_{\\mathrm{NP}}(s)$，并写出其特征方程。根据特征方程中是否存在指数因子，简要说明极点位置有何不同。\n\n请以仅含 $s$ 的解析表达式形式提供您的最终答案 $T_{\\mathrm{SP}}(s)$。不需要进行数值舍入。最终答案表达式中不应包含物理单位。", "solution": "首先将对问题陈述的科学合理性、完整性和客观性进行验证。\n\n步骤1：提取已知条件\n- 对象传递函数：$P(s)=G(s)\\exp(-Ls)$\n- 对象的无时滞部分：$G(s)=\\frac{1}{(s+1)^{2}}$\n- 时间延迟：$L=1$\n- 控制器形式：$C(s)=k\\frac{s+z}{s+p}$，声明为严格真分。\n- 采用精确内部模型（$G_m(s)=G(s)$, $L_m=L$）的史密斯预估器配置。\n- 针对无时滞回路（$C(s)$ 和 $G(s)$）的设计规范1：闭环特征多项式为 $(s+a)^3$，其中 $a=\\frac{2}{3}$。\n- 针对无时滞回路的设计规范2：从参考输入到输出的闭环传递函数具有单位稳态增益。\n\n步骤2：使用提取的已知条件进行验证\n- **科学依据**：该问题是控制理论中一个关于时滞系统史密斯预估器设计与分析的标准练习。所有概念都是该领域的基础。它在科学上是合理的。\n- **适定性**：该问题提供了足够的规范（极点配置和稳态增益）来唯一确定控制器参数。任务定义清晰且按顺序进行。\n- **客观性**：问题以精确的数学和工程术语陈述，不含主观性。\n- **完整性与一致性**：该问题在很大程度上是自洽的。存在一个微小的不一致之处：问题要求一个“严格真分”控制器，但为实现特定的三阶特征多项式和单位稳态增益的设计规范导出的控制器在原点有一个极点（$p=0$），这是一个比例-积分（PI）控制器。PI控制器是真分的，但不是严格真分的。这是此类设计问题中的常见结果，并不会使问题不可解。其意图是明确的，找到参数的方法也是明确的。我们将继续进行，并注意到这个术语上的微小不精确性。\n\n步骤3：结论与行动\n该问题被认为是**有效的**，仅需注意“严格真分”控制器术语的微小不精确性。将提供完整的解决方案。\n\n**第1部分：控制器设计**\n\n我们首先考虑无时滞反馈回路，它由控制器 $C(s)$ 和无时滞对象 $G(s)$ 在单位反馈配置中组成。开环传递函数是 $L_0(s) = C(s)G(s)$。\n$$L_0(s) = \\left( k\\frac{s+z}{s+p} \\right) \\left( \\frac{1}{(s+1)^2} \\right) = \\frac{k(s+z)}{(s+p)(s+1)^2}$$\n这个无时滞系统的闭环传递函数 $T_0(s)$ 由下式给出：\n$$T_0(s) = \\frac{L_0(s)}{1+L_0(s)} = \\frac{\\frac{k(s+z)}{(s+p)(s+1)^2}}{1+\\frac{k(s+z)}{(s+p)(s+1)^2}} = \\frac{k(s+z)}{(s+p)(s+1)^2 + k(s+z)}$$\n无时滞闭环系统的特征多项式是 $T_0(s)$ 的分母：\n$$\\Delta_0(s) = (s+p)(s+1)^2 + k(s+z)$$\n展开此多项式，我们得到：\n$$\\Delta_0(s) = (s+p)(s^2+2s+1) + ks+kz = s^3 + 2s^2 + s + ps^2 + 2ps + p + ks + kz$$\n$$\\Delta_0(s) = s^3 + (2+p)s^2 + (1+2p+k)s + (p+kz)$$\n问题要求这个特征多项式在 $s=-a$ 处有一个三阶实数重根，其中 $a=\\frac{2}{3}$。期望的特征多项式是：\n$$\\Delta_{\\text{desired}}(s) = \\left(s+\\frac{2}{3}\\right)^3 = s^3 + 3s^2\\left(\\frac{2}{3}\\right) + 3s\\left(\\frac{2}{3}\\right)^2 + \\left(\\frac{2}{3}\\right)^3 = s^3 + 2s^2 + \\frac{4}{3}s + \\frac{8}{27}$$\n通过令 $\\Delta_0(s)$ 和 $\\Delta_{\\text{desired}}(s)$ 的系数相等：\n\\begin{itemize}\n    \\item $s^2$ 的系数：$2+p = 2 \\implies p=0$。\n    \\item $s^1$ 的系数：$1+2p+k = \\frac{4}{3} \\implies 1+2(0)+k = \\frac{4}{3} \\implies k=\\frac{1}{3}$。\n    \\item $s^0$ 的系数：$p+kz = \\frac{8}{27} \\implies 0 + \\left(\\frac{1}{3}\\right)z = \\frac{8}{27} \\implies z=\\frac{8}{9}$。\n\\end{itemize}\n得到的控制器是：\n$$C(s) = \\frac{1}{3}\\frac{s+8/9}{s} = \\frac{s+8/9}{3s}$$\n这是一个PI控制器。如前所述，它是真分的（分母阶数=分子阶数），但不是严格真分的。\n\n第二个规范是无时滞闭环必须具有单位稳态增益。稳态增益是传递函数 $T_0(s)$ 在 $s=0$ 处的值。\n$$T_0(s) = \\frac{k(s+z)}{(s+a)^3} = \\frac{\\frac{1}{3}(s+\\frac{8}{9})}{(s+\\frac{2}{3})^3}$$\n稳态增益是 $T_0(0)$：\n$$T_0(0) = \\frac{\\frac{1}{3}(\\frac{8}{9})}{(\\frac{2}{3})^3} = \\frac{\\frac{8}{27}}{\\frac{8}{27}} = 1$$\n这个规范被我们的设计所满足。\n\n**第2部分：史密斯预估器分析**\n\n史密斯预估器结构的通用闭环传递函数是：\n$$T_{\\mathrm{SP}}(s) = \\frac{C(s)P(s)}{1 + C(s)G_m(s) + C(s)(P(s) - P_m(s))}$$\n其中 $P(s) = G(s)\\exp(-Ls)$ 是实际对象，$P_m(s)=G_m(s)\\exp(-L_m s)$ 是模型。问题声明使用了精确的内部模型，所以 $G_m(s) = G(s)$ 且 $L_m = L$。表达式显著简化：\n$$T_{\\mathrm{SP}}(s) = \\frac{C(s)G(s)\\exp(-Ls)}{1 + C(s)G(s) + C(s)(G(s)\\exp(-Ls) - G(s)\\exp(-Ls))} = \\frac{C(s)G(s)\\exp(-Ls)}{1 + C(s)G(s)}$$\n$\\frac{C(s)G(s)}{1 + C(s)G(s)}$ 这一项恰好是无时滞系统的闭环传递函数 $T_0(s)$。因此：\n$$T_{\\mathrm{SP}}(s) = T_0(s) \\exp(-Ls)$$\n代入之前推导的 $T_0(s)$ 表达式：\n$$T_{\\mathrm{SP}}(s) = \\frac{\\frac{1}{3}(s+\\frac{8}{9})}{(s+\\frac{2}{3})^3} \\exp(-s)$$\n我们简化这个表达式：\n$$T_{\\mathrm{SP}}(s) = \\frac{\\frac{1}{3}\\frac{9s+8}{9}}{(\\frac{3s+2}{3})^3} \\exp(-s) = \\frac{\\frac{9s+8}{27}}{\\frac{(3s+2)^3}{27}} \\exp(-s) = \\frac{9s+8}{(3s+2)^3} \\exp(-s)$$\n这是所求的闭环传递函数。\n\n为了求出单位阶跃响应 $y_{\\mathrm{SP}}(t)$，我们将 $T_{\\mathrm{SP}}(s)$ 乘以单位阶跃的拉普拉斯变换 $R(s) = \\frac{1}{s}$：\n$$Y_{\\mathrm{SP}}(s) = T_{\\mathrm{SP}}(s) \\frac{1}{s} = \\frac{9s+8}{s(3s+2)^3} \\exp(-s)$$\n响应 $y_{\\mathrm{SP}}(t)$ 是 $Y_{\\mathrm{SP}}(s)$ 的拉普拉斯逆变换。令 $Y_0(s) = \\frac{9s+8}{s(3s+2)^3}$。那么 $y_{\\mathrm{SP}}(t) = \\mathcal{L}^{-1}\\{Y_0(s)\\exp(-s)\\} = y_0(t-1)u(t-1)$，其中 $y_0(t) = \\mathcal{L}^{-1}\\{Y_0(s)\\}$ 且 $u(t)$ 是亥维赛德阶跃函数。我们对 $Y_0(s)$ 进行部分分式展开：\n$$Y_0(s) = \\frac{9s+8}{27s(s+\\frac{2}{3})^3} = \\frac{A}{s} + \\frac{B_1}{s+\\frac{2}{3}} + \\frac{B_2}{(s+\\frac{2}{3})^2} + \\frac{B_3}{(s+\\frac{2}{3})^3}$$\n求得系数为 $A=1$, $B_1=-1$, $B_2=-\\frac{2}{3}$, 以及 $B_3=-\\frac{1}{9}$。\n$$Y_0(s) = \\frac{1}{s} - \\frac{1}{s+\\frac{2}{3}} - \\frac{2/3}{(s+\\frac{2}{3})^2} - \\frac{1/9}{(s+\\frac{2}{3})^3}$$\n利用性质 $\\mathcal{L}^{-1}\\left\\{\\frac{1}{(s+a)^n}\\right\\} = \\frac{t^{n-1}}{(n-1)!}\\exp(-at)$ 进行拉普拉斯逆变换：\n$$y_0(t) = \\left(1 - \\exp(-\\frac{2}{3}t) - \\frac{2}{3}t\\exp(-\\frac{2}{3}t) - \\frac{1}{9}\\frac{t^2}{2!}\\exp(-\\frac{2}{3}t)\\right)u(t)$$\n$$y_0(t) = \\left(1 - \\exp(-\\frac{2}{3}t)\\left[1 + \\frac{2}{3}t + \\frac{1}{18}t^2\\right]\\right)u(t)$$\n因此，最终的响应是：\n$$y_{\\mathrm{SP}}(t) = \\left(1 - \\exp(-\\frac{2}{3}(t-1))\\left[1 + \\frac{2}{3}(t-1) + \\frac{1}{18}(t-1)^2\\right]\\right)u(t-1)$$\n\n**第3部分：与标准反馈的比较**\n\n如果没有史密斯预估器，系统是一个标准的单位反馈回路，包含控制器 $C(s)$ 和对象 $P(s)=G(s)\\exp(-Ls)$。闭环传递函数 $T_{\\mathrm{NP}}(s)$ 是：\n$$T_{\\mathrm{NP}}(s) = \\frac{C(s)P(s)}{1+C(s)P(s)} = \\frac{C(s)G(s)\\exp(-Ls)}{1+C(s)G(s)\\exp(-Ls)}$$\n代入 $C(s)$ 和 $G(s)$ 的表达式：\n$$T_{\\mathrm{NP}}(s) = \\frac{\\frac{s+8/9}{3s(s+1)^2}\\exp(-s)}{1+\\frac{s+8/9}{3s(s+1)^2}\\exp(-s)} = \\frac{(s+8/9)\\exp(-s)}{3s(s+1)^2 + (s+8/9)\\exp(-s)}$$\n通过将分母设为零得到特征方程：\n$$1+C(s)G(s)\\exp(-Ls) = 0 \\implies 3s(s+1)^2 + (s+8/9)\\exp(-s) = 0$$\n根本区别在于特征方程。\n- **使用史密斯预估器**：特征方程是 $1+C(s)G(s)=0$，即 $(s+\\frac{2}{3})^3=0$。这是一个多项式方程，有有限数量的极点（三个极点在 $s=-2/3$）。时滞被有效地从稳定性判断回路中移除，允许进行常规的极点配置。\n- **不使用史密斯预估器**：特征方程是 $1+C(s)G(s)\\exp(-s)=0$。这是一个超越方程，也称为准多项式。由于 $\\exp(-s)$ 项的存在，它在s平面内有无穷多个极点，使得稳定性分析和控制器设计变得异常复杂。与理想的史密斯预估器情况相比，其性能通常会因时滞而下降。", "answer": "$$\\boxed{\\frac{9s+8}{(3s+2)^{3}}\\exp(-s)}$$", "id": "2696599"}, {"introduction": "理论上的完美模型在付诸实践时总会遇到挑战，史密斯预估器也不例外，尤其是在数字化实现的过程中。这个练习将带你从连续时间过渡到离散时间，探讨零阶保持器 (ZOH) 采样对时滞系统建模的影响。你将发现，连续时间中的时滞 $L$ 并不总能精确地等于采样周期 $T_s$ 的整数倍，由此产生的“分数延迟”是标准史密斯预估器无法完全补偿的，这也是预估器性能在实际中下降的一个关键因素。[@problem_id:2696618]", "problem": "考虑一个连续时间、开环稳定、单输入单输出的被控对象，其输入输出存在时间延迟，模型为\n$$\nG_{p}(s) \\;=\\; \\frac{k}{s+a}\\,\\exp(-L s),\n$$\n其中 $k \\in \\mathbb{R}$，$a0$ 且 $L0$。使用被控对象动态的内部无延迟模型和已知的输入输出延迟设计一个史密斯预估器。该控制器以数字方式实现，带有一个零阶保持器 (ZOH) 输入设备和一个周期为 $T_{s}0$ 的采样器。\n\n仅使用以下基本原理：\n- 零阶保持器在每个采样区间内作为分段常数输入的定义，\n- 线性时不变状态演化，包括状态转移矩阵和卷积积分，\n- ZOH 系统的 $z$ 变换和脉冲传递函数的定义，\n\n执行以下任务：\n1. 从无延迟的连续时间被控对象动态 $\\dot{x}(t)=-a\\,x(t)+k\\,u(t)$，$y(t)=x(t)$ 出发，推导 ZOH 脉冲传递函数 $G(z)$，该函数将采样并保持的输入 $u[k]$ 映射到采样输出 $y[k]$。\n2. 将连续时间输入输出延迟 $\\exp(-L s)$ 建模为离散时间中的整数采样点移位，并证明它由因子 $z^{-N}$ 表示，其中 $N=\\lfloor L/T_{s}\\rfloor$。识别并精确定义剩余分数延迟。\n3. 结合方程解释剩余分数延迟如何影响频率响应和史密斯预估器的延迟补偿，并识别低频下的主导小角度近似。\n\n您用于评分的最终交付成果是一个关于 ZOH 离散化、整数延迟近似的被控对象的单一闭式解析表达式\n$$\nG_{p}(z) \\;=\\; \\text{(整数延迟因子)} \\times G(z),\n$$\n该表达式应通过 $z$ 和取整运算符直接用 $k$、$a$、$L$ 和 $T_{s}$ 表示。无需也不允许进行数值计算。最终答案必须是单一的解析表达式；最终表达式中不应包含任何单位。", "solution": "我们从无延迟的被控对象动态和零阶保持器 (ZOH) 的定义开始。在每个采样区间 $[kT_{s},(k+1)T_{s})$ 内，ZOH 保持输入恒定，因此对于 $t \\in [kT_{s},(k+1)T_{s})$，有 $u(t)=u[k]$。连续时间状态根据线性时不变系统演化\n$$\n\\dot{x}(t) \\;=\\; -a\\,x(t) + k\\,u(t), \\quad y(t)=x(t).\n$$\n令 $x[k]\\triangleq x(kT_{s})$ 和 $y[k]\\triangleq y(kT_{s})$。在 ZOH 下的精确离散化是通过状态转移矩阵和输入卷积积分得到的。在一个采样区间内，\n$$\nx((k+1)T_{s}) \\;=\\; \\exp(-a T_{s})\\,x(kT_{s}) \\;+\\; \\int_{0}^{T_{s}} \\exp\\!\\big(-a (T_{s}-\\tau)\\big)\\,k\\,u[k]\\,\\mathrm{d}\\tau.\n$$\n计算该积分得到\n$$\n\\int_{0}^{T_{s}} \\exp\\!\\big(-a (T_{s}-\\tau)\\big)\\,k\\,u[k]\\,\\mathrm{d}\\tau\n\\;=\\; k\\,u[k]\\,\\exp(-a T_{s})\\int_{0}^{T_{s}}\\exp(a \\tau)\\,\\mathrm{d}\\tau\n\\;=\\; k\\,u[k]\\;\\frac{1-\\exp(-a T_{s})}{a}.\n$$\n因此，精确的离散时间状态更新为\n$$\nx[k+1] \\;=\\; \\exp(-a T_{s})\\,x[k] \\;+\\; \\frac{k\\big(1-\\exp(-a T_{s})\\big)}{a}\\,u[k],\n$$\n并且当 $y[k]=x[k]$ 时，对于零初始条件的 $z$ 变换给出\n$$\nz X(z) \\;=\\; \\exp(-a T_{s})\\,X(z) \\;+\\; \\frac{k\\big(1-\\exp(-a T_{s})\\big)}{a}\\,U(z).\n$$\n求解从 $U(z)$ 到 $Y(z)=X(z)$ 的脉冲传递函数，\n$$\n\\frac{Y(z)}{U(z)} \\;=\\; \\frac{\\dfrac{k\\big(1-\\exp(-a T_{s})\\big)}{a}}{z-\\exp(-a T_{s})}\n\\;=\\; \\frac{k\\big(1-\\exp(-a T_{s})\\big)}{a}\\;\\frac{z^{-1}}{1-\\exp(-a T_{s})\\,z^{-1}}.\n$$\n因此，无延迟动态的 ZOH 脉冲传递函数是\n$$\nG(z) \\;=\\; \\frac{k\\big(1-\\exp(-a T_{s})\\big)}{a}\\;\\frac{z^{-1}}{1-\\exp(-a T_{s})\\,z^{-1}}.\n$$\n\n接下来，我们考虑连续时间输入输出延迟。一个纯延迟 $\\exp(-L s)$ 以周期 $T_{s}$ 进行采样，在离散时间中表示为一个整数采样点移位 $z^{-N}$，其中\n$$\nN \\;=\\; \\left\\lfloor \\frac{L}{T_{s}} \\right\\rfloor.\n$$\n这表示包含在 $L$ 中的最大整数个完整采样周期。剩余的，或称为分数，延迟是\n$$\n\\varepsilon \\;\\triangleq\\; L \\;-\\; N T_{s}, \\quad \\varepsilon \\in [0, T_{s}).\n$$\n因此，通过整数移位来近似连续时间延迟会产生离散时间延迟因子 $z^{-N}$，并忽略了剩余延迟 $\\varepsilon$。\n\n连续时间延迟在单位圆 $z=\\exp(\\mathrm{j}\\omega)$ 上评估的、在离散时间频率 $\\omega$（单位为弧度/采样点）下的精确频率响应为\n$$\n\\exp(-L s)\\Big|_{s=\\tfrac{1}{T_{s}}\\ln z} \\;\\leadsto\\; \\exp\\!\\big(-\\mathrm{j}\\,\\omega\\,\\tfrac{L}{T_{s}}\\big),\n$$\n其中该映射使用 $z=\\exp(s T_{s})$ 进行稳态正弦分析。将 $L=N T_{s}+\\varepsilon$ 分解得到\n$$\n\\exp\\!\\big(-\\mathrm{j}\\,\\omega\\,\\tfrac{L}{T_{s}}\\big) = \\exp(-\\mathrm{j}\\,\\omega\\frac{N T_{s}+\\varepsilon}{T_{s}}) = \\exp(-\\mathrm{j}\\,\\omega N)\\;\\exp(-\\mathrm{j}\\,\\omega\\frac{\\varepsilon}{T_{s}}) = z^{-N}\\exp(-\\mathrm{j}\\,\\omega\\frac{\\varepsilon}{T_{s}}).\n$$\n因此，仅用 $z^{-N}$ 替代连续延迟会忽略乘法因子 $\\exp(-\\mathrm{j}\\,\\omega \\frac{\\varepsilon}{T_s})$，这是一个与频率相关的相位滞后，没有幅值失真。对于小的 $\\omega$（相对于奈奎斯特频率），主导的小角度近似是\n$$\n\\exp(-\\mathrm{j}\\,\\omega \\frac{\\varepsilon}{T_s}) \\;\\approx\\; 1 \\;-\\; \\mathrm{j}\\,\\omega \\frac{\\varepsilon}{T_s},\n$$\n这意味着一个近似为 $-\\omega \\varepsilon/T_s$ 弧度的附加相位滞后，以及一阶可忽略的增益误差。在史密斯预估器中，预估器消除了建模的整数延迟 $z^{-N}$，但剩余分数延迟 $\\varepsilon$ 无法通过整数移位消除，并作为未补偿的相位滞后而保留下来。这会减小延迟裕度，并可能降低闭环鲁棒性，其严重程度随 $\\varepsilon$ 和环路穿越频率的增加而增加。\n\n将 ZOH 离散化动态与整数延迟近似相结合，复合的离散时间、整数延迟近似的被控对象是\n$$\nG_{p}(z) \\;=\\; z^{-N}\\,G(z) \\;=\\; z^{-N}\\,\\frac{k\\big(1-\\exp(-a T_{s})\\big)}{a}\\;\\frac{z^{-1}}{1-\\exp(-a T_{s})\\,z^{-1}},\n$$\n其中 $N=\\left\\lfloor \\dfrac{L}{T_{s}} \\right\\rfloor$。这就是所要求的用 $k$、$a$、$L$ 和 $T_{s}$ 表示的闭式解析表达式。", "answer": "$$\\boxed{z^{-\\left\\lfloor L/T_{s}\\right\\rfloor}\\,\\frac{k\\left(1-\\exp(-a T_{s})\\right)}{a}\\,\\frac{z^{-1}}{1-\\exp(-a T_{s})\\,z^{-1}}}$$", "id": "2696618"}, {"introduction": "在掌握了理论分析与实现挑战之后，是时候将所有知识融会贯通，通过编程来构建一个完整的离散时间史密斯预估器了。本练习要求你为一个离散时间对象设计一个比例控制器，并编写仿真代码来测试其在单位阶跃响应下的性能。这个过程不仅能加深你对离散系统信号流的理解，还将迫使你解决实现中可能出现的代数环问题，是理论走向实践的关键一步。[@problem_id:2696634]", "problem": "考虑一个带有纯输入延迟的离散时间单输入单输出 (SISO) 线性时不变 (LTI) 对象模型。标称对象（无延迟）由复 $z$ 域中的传递函数给出\n$$\nG(z) = \\frac{0.1}{1 - 0.9 z^{-1}},\n$$\n真实对象包含 $N$ 个采样点的纯延迟，因此真实对象为\n$$\nG_{\\text{true}}(z) = z^{-N} G(z),\n$$\n其中 $N = 3$。对于所有整数时间索引 $k \\ge 0$，参考输入为单位阶跃 $r(k) = 1$。所有仿真都应在单位采样的离散时间中进行，因此时间以整数值的采样点来衡量。下面要求的所有时间索引都是采样点索引（单位：采样点）。\n\n你的任务是为这个延迟对象实现一个离散 Smith 预估器，使用一个与真实对象完全匹配的内部模型（相同的 $G(z)$ 和相同的延迟 $N$）。Smith 预估器必须按如下方式配置：\n\n1. Smith 预估器中使用的控制器 $C(z)$ 应为一个比例控制器 $C(z) = K$，其中增益 $K$ 不直接给出，但必须通过对无延迟标称对象 $G(z)$ 在单位负反馈下进行极点配置来设计。具体来说，对于为无延迟闭环选择的一个期望闭环极点 $p_d \\in (0,1)$（即带有 $G(z)$ 和控制器 $C(z)$ 但没有延迟的系统的闭环极点），确定实现此极点的比例增益 $K$。\n\n2. 使用标准的离散时间 Smith 预估器结构：控制器 $C(z)$ 作用于参考输入和一个预测的无延迟输出之间的差值。令 $y(k)$ 为真实对象输出，$y_m(k)$ 为带有延迟 $N$ 的对象模型的输出，$y_{m0}(k)$ 为无延迟的对象模型的输出。控制器使用的内部预测无延迟输出为\n$$\ny_{\\text{sp}}(k) = y_{m0}(k) + y(k) - y_m(k).\n$$\n控制律为\n$$\nu(k) = K \\left( r(k) - y_{\\text{sp}}(k) \\right).\n$$\n\n3. 使用与 $G(z)$ 对应的标准因果差分方程，在时域中实现对象和模型的动态：\n$$\ny(k) = 0.9\\, y(k-1) + 0.1\\, u(k), \\quad \\text{(无延迟)}\n$$\n和\n$$\ny(k) = 0.9\\, y(k-1) + 0.1\\, u(k-N), \\quad \\text{(带延迟 } N \\text{)}.\n$$\n所有初始条件均为零，输入延迟通过一个用零初始化的长度为 $N$ 的先进先出 (FIFO) 缓冲区实现。\n\n重要实现说明：由于 $G(z)$ 有一个非零直接项（即输出依赖于 $u(k)$），$y_{m0}(k)$ 的方程包含 $u(k)$，而 $u(k)$ 是由控制器使用 $y_{\\text{sp}}(k)$ 计算得出的，$y_{\\text{sp}}(k)$ 本身又使用 $y_{m0}(k)$。为避免代数环，你必须为比例控制器以闭合形式显式求解 $u(k)$。其结果是一个因果计算，使用 $y(k)$、$y_m(k)$ 和 $y_{m0}(k-1)$ 来计算 $u(k)$，之后再更新 $y_{m0}(k)$。\n\n设计基础和数据：\n- $G(z)$ 的模型参数为 $a = 0.9$ 和 $b = 0.1$，意味着无延迟模型的差分方程为 $y(k) = a\\, y(k-1) + b\\, u(k)$。\n- 对象延迟为 $N = 3$ 个采样点。\n- 阶跃输入为 $r(k) = 1$（对于所有 $k \\ge 0$）。\n- 仿真时长为 $T = 120$ 个采样点，即 $k = 0,1,\\dots,119$。\n\n通过极点配置进行控制器设计：\n- 对于带有单位负反馈和对象 $G(z)$ 的无延迟闭环，选择一个期望的实数闭环极点 $p_d \\in (0,1)$，并设计一个比例增益 $K$，使得（无延迟闭环的）闭环极点恰好为 $p_d$。你必须从第一性原理推导 $K$。\n\n需要计算和返回的内容：\n- 对于下面指定的每个测试用例（每个用例具有不同的期望极点 $p_d$），实现 Smith 预估器，仿真对单位阶跃的闭环响应，并报告以下三个量：\n  1. 时间索引 $k = N + 5$ 处的输出采样值 $y(k)$。\n  2. 时间索引 $k = N + 20$ 处的输出采样值 $y(k)$。\n  3. 最终仿真时间 $k = T - 1$ 处的输出采样值 $y(k)$。\n- 这三个量都是无量纲的，应作为实数报告，并四舍五入到 6 位小数。\n\n测试套件：\n- 为无延迟设计使用以下期望闭环极点：\n  - 情况 A: $p_d = 0.2$\n  - 情况 B: $p_d = 0.5$\n  - 情况 C: $p_d = 0.8$\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表。顺序是先情况 A 的值，然后是情况 B 的值，最后是情况 C 的值。在每种情况下，按上述顺序报告三个值。具体来说，输出必须是\n$$\n[ y_{A,N+5}, y_{A,N+20}, y_{A,T-1}, y_{B,N+5}, y_{B,N+20}, y_{B,T-1}, y_{C,N+5}, y_{C,N+20}, y_{C,T-1} ],\n$$\n每个条目都四舍五入到 6 位小数。", "solution": "问题需要进行验证。\n\n**步骤 1：提取已知条件**\n- 标称对象传递函数: $G(z) = \\frac{0.1}{1 - 0.9 z^{-1}}$。一般形式为 $G(z) = \\frac{b}{1 - a z^{-1}}$，其中 $a=0.9$，$b=0.1$。\n- 真实对象传递函数: $G_{\\text{true}}(z) = z^{-N} G(z)$。\n- 对象延迟: $N = 3$ 个采样点。\n- 参考输入: $r(k) = 1$ (对于 $k \\ge 0$)。\n- 仿真时长: $T = 120$ 个采样点 ($k \\in [0, 119]$)。\n- 控制器: 比例控制器，$C(z) = K$。\n- 控制器设计: 为无延迟单位负反馈回路进行极点配置，期望闭环极点为 $p_d$。\n- Smith 预估器结构:\n  - 控制律: $u(k) = K ( r(k) - y_{\\text{sp}}(k) )$。\n  - 预测的无延迟输出: $y_{\\text{sp}}(k) = y_{m0}(k) + y(k) - y_m(k)$，其中 $y(k)$ 是真实对象输出，$y_m(k)$ 是延迟模型输出，$y_{m0}(k)$ 是无延迟模型输出。\n- 时域动态:\n  - 无延迟对象/模型: $y(k) = a y(k-1) + b u(k)$。\n  - 延迟对象/模型: $y(k) = a y(k-1) + b u(k-N)$。\n- 初始条件: 所有状态和缓冲区均为零。\n- 代数环警告: $u(k)$ 必须显式求解。\n- 测试用例（期望极点 $p_d$）: 情况 A: $p_d=0.2$，情况 B: $p_d=0.5$，情况 C: $p_d=0.8$。\n- 要求输出: 对于每种情况，$y(N+5)$、$y(N+20)$ 和 $y(T-1)$ 的值。\n\n**步骤 2：使用提取的已知条件进行验证**\n该问题是离散时间控制理论中的一个标准练习。它具有科学依据，使用了 LTI 系统和 Smith 预估器架构的既定原理。问题是适定的，为获得唯一的数值解提供了所有必要的参数和条件。语言客观而精确。没有违反科学或数学原理，没有信息缺失，也没有矛盾。解决代数环的要求在数字信号处理（DSP）和控制实现中是一个非平凡但标准的程序，反映了对计算因果性的正确理解。\n\n**步骤 3：结论与行动**\n问题有效。将提供解决方案。\n\n**基于原理的解决方案**\n\n目标是为带输入延迟的一阶离散时间对象设计并仿真一个 Smith 预估器。解决方案分三个阶段进行：控制器综合、离散时间仿真方程的构建和数值实现。\n\n**1. 通过极点配置进行控制器综合**\n\n比例控制器增益 $K$ 是为标称对象 $G(z) = \\frac{b}{1 - a z^{-1}}$ 在单位负反馈配置下（无延迟）设计的。这个无延迟系统的闭环传递函数 $T_{CL}(z)$ 为：\n$$\nT_{CL}(z) = \\frac{C(z)G(z)}{1 + C(z)G(z)} = \\frac{K \\frac{b}{1 - a z^{-1}}}{1 + K \\frac{b}{1 - a z^{-1}}}\n$$\n分子和分母同乘以 $(1 - a z^{-1})$ 得：\n$$\nT_{CL}(z) = \\frac{Kb}{1 - a z^{-1} + Kb} = \\frac{Kb}{(1+Kb) - a z^{-1}}\n$$\n闭环极点 $z_p$ 可由特征方程求得，即令传递函数的分母为零：\n$$\n(1+Kb) - a z^{-1} = 0 \\implies z_p = \\frac{a}{1+Kb}\n$$\n我们需要将此极点配置在期望位置 $p_d$。因此，我们令 $z_p = p_d$：\n$$\np_d = \\frac{a}{1+Kb}\n$$\n解此方程求控制器增益 $K$ 得：\n$$\np_d(1+Kb) = a \\implies p_d + p_d Kb = a \\implies K = \\frac{a - p_d}{p_d b}\n$$\n使用给定参数 $a = 0.9$ 和 $b = 0.1$，我们为每个测试用例计算 $K$：\n- 情况 A ($p_d = 0.2$): $K = \\frac{0.9 - 0.2}{0.2 \\times 0.1} = \\frac{0.7}{0.02} = 35$。\n- 情况 B ($p_d = 0.5$): $K = \\frac{0.9 - 0.5}{0.5 \\times 0.1} = \\frac{0.4}{0.05} = 8$。\n- 情况 C ($p_d = 0.8$): $K = \\frac{0.9 - 0.8}{0.8 \\times 0.1} = \\frac{0.1}{0.08} = 1.25$。\n\n**2. Smith 预估器仿真方程**\n\n仿真需要仔细处理计算依赖关系以保证因果性。在每个离散时间步 $k$，我们必须计算当前控制输入 $u(k)$ 并更新所有系统状态。问题描述正确地指出了在 $u(k)$ 的定义中存在一个代数环。我们按如下方式解决这个问题。\n\n控制律为 $u(k) = K(r(k) - y_{sp}(k))$。代入 $y_{sp}(k) = y_{m0}(k) + y(k) - y_m(k)$ 的定义：\n$$\nu(k) = K(r(k) - [y_{m0}(k) + y(k) - y_m(k)])\n$$\n无延迟模型的输出由差分方程 $y_{m0}(k) = a y_{m0}(k-1) + b u(k)$ 给出。将其代入控制律：\n$$\nu(k) = K(r(k) - [ (a y_{m0}(k-1) + b u(k)) + y(k) - y_m(k) ])\n$$\n展开并合并含有 $u(k)$ 的项：\n$$\nu(k) = K r(k) - K a y_{m0}(k-1) - K b u(k) - K y(k) + K y_m(k)\n$$\n$$\nu(k) (1 + Kb) = K [ r(k) - y(k) + y_m(k) - a y_{m0}(k-1) ]\n$$\n这就得到了控制输入 $u(k)$ 的显式、因果的更新规则：\n$$\nu(k) = \\frac{K}{1 + Kb} [ r(k) - y(k) + y_m(k) - a y_{m0}(k-1) ]\n$$\n在时间步 $k$，$y(k)$ 和 $y_m(k)$ 的值是可用的，因为它们依赖于输入 $u(k-N)$，这是一个过去的值。$y_{m0}(k-1)$ 的值也是一个过去的状态。因此，$u(k)$ 可以被计算出来。\n\n**3. 仿真算法**\n\n仿真对 $k = 0, 1, \\dots, T-1$ 进行迭代。在每一步 $k$，按顺序执行以下计算：\n\n1.  **检索过去的值**：从时间步 $k-1$ 获取状态值（例如 $y(k-1)$、$y_m(k-1)$、$y_{m0}(k-1)$）和延迟输入 $u(k-N)$。当 $k-1  0$ 或 $k-N  0$ 时，根据初始条件，这些值为零。\n2.  **计算延迟输出**：计算真实对象和延迟模型的输出。由于模型是完美的，它们的动态由相同的方程控制：\n    $$\n    y(k) = a y(k-1) + b u(k-N)\n    $$\n    $$\n    y_m(k) = a y_m(k-1) + b u(k-N)\n    $$\n    在理想仿真中，对所有 $k$ 都有 $y(k) = y_m(k)$。\n3.  **计算控制输入**：使用推导出的因果公式计算 $u(k)$：\n    $$\n    u(k) = \\frac{K}{1 + Kb} [ r(k) - y(k) + y_m(k) - a y_{m0}(k-1) ]\n    $$\n    这里 $r(k)=1$。在这个理想情况下，$y(k)-y_m(k)$ 项将为零。\n4.  **计算无延迟模型输出**：使用刚计算出的 $u(k)$ 更新无延迟模型的状态：\n    $$\n    y_{m0}(k) = a y_{m0}(k-1) + b u(k)\n    $$\n5.  **存储状态**：将计算出的值 $y(k)$、$y_m(k)$、$y_{m0}(k)$ 和 $u(k)$ 存储起来，用于后续时间步。\n\n该算法针对每个设计案例在指定的时长 $T=120$ 内实现。然后提取并报告在 $k=N+5=8$、$k=N+20=23$ 和 $k=T-1=119$ 时的输出值 $y(k)$。带有完美模型的 Smith 预估器的行为是产生一个等效于无延迟系统响应的闭环响应，但在时间上平移了延迟 $N$。系统输出 $y(k)$ 应表现出一阶系统的动态，其极点为 $p_d$，但其响应从 $k=N$ 开始。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the discrete-time Smith predictor problem for a plant with time delay.\n    \"\"\"\n    # Define system parameters from the problem statement.\n    a = 0.9  # Plant pole\n    b = 0.1  # Plant numerator gain\n    N = 3    # Input delay in samples\n    T = 120  # Total simulation time in samples\n\n    # Define the test cases with different desired closed-loop poles.\n    test_cases_pd = [0.2, 0.5, 0.8]\n\n    # A list to store the final results for all test cases.\n    results = []\n\n    # Iterate through each test case.\n    for p_d in test_cases_pd:\n        # 1. Controller Design: Calculate proportional gain K by pole placement.\n        # The formula K = (a - p_d) / (p_d * b) is derived from setting the\n        # delay-free closed-loop pole to p_d.\n        K = (a - p_d) / (p_d * b)\n\n        # 2. Simulation Initialization: Create arrays to store system signals over time.\n        # All signals are initialized to zero, which handles the initial conditions.\n        y = np.zeros(T)      # True plant output\n        ym = np.zeros(T)     # Delayed plant model output\n        ym0 = np.zeros(T)    # Undelayed plant model output\n        u = np.zeros(T)      # Control input\n        r = np.ones(T)       # Reference input (unit step)\n\n        # Pre-calculate a constant factor for the control input equation.\n        u_factor = K / (1 + K * b)\n\n        # 3. Simulation Loop: Iterate from k = 0 to T-1.\n        for k in range(T):\n            # Retrieve past values, handling boundary conditions at k=0.\n            # If the index is negative, the value is 0.\n            y_km1 = y[k - 1] if k > 0 else 0.0\n            ym_km1 = ym[k - 1] if k > 0 else 0.0\n            ym0_km1 = ym0[k - 1] if k > 0 else 0.0\n            \n            # The input u(k-N) causes the delay. For k  N, u(k-N) is 0.\n            u_k_minus_N = u[k - N] if k >= N else 0.0\n\n            # Update delayed outputs based on past values. This must be done\n            # before calculating the current control input u(k).\n            y[k] = a * y_km1 + b * u_k_minus_N\n            ym[k] = a * ym_km1 + b * u_k_minus_N\n\n            # Calculate the current control input u(k).\n            # The formula is derived to resolve the algebraic loop.\n            # Since the model is perfect, y[k] - ym[k] will be zero.\n            u[k] = u_factor * (r[k] - y[k] + ym[k] - a * ym0_km1)\n            \n            # Update the undelayed model output using the newly calculated u(k).\n            ym0[k] = a * ym0_km1 + b * u[k]\n\n        # 4. Extract and Store Results for the current test case.\n        # The required time indices are N+5, N+20, and T-1.\n        y_N_plus_5 = y[N + 5]\n        y_N_plus_20 = y[N + 20]\n        y_T_minus_1 = y[T - 1]\n\n        # Append the rounded results to the main results list.\n        results.extend([\n            np.round(y_N_plus_5, 6),\n            np.round(y_N_plus_20, 6),\n            np.round(y_T_minus_1, 6)\n        ])\n\n    # 5. Final Output: Print the results in the specified format.\n    # The format is a single line: [val1,val2,val3,...]\n    print(f\"[{','.join(map(str, results))}]\")\n\n# Execute the main function.\nsolve()\n```", "id": "2696634"}]}