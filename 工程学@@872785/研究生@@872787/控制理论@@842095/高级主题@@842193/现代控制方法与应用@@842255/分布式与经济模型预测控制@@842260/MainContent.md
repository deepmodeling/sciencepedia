## 引言
[模型预测控制](@entry_id:146965)（MPC）是现代控制工程的支柱，但其传统形式主要局限于跟踪预设的[设定点](@entry_id:154422)。面对日益复杂的[大规模系统](@entry_id:166848)——如智能电网和化工流程——其控制目标已转变为追求整体经济效益和运行效率。这一需求催生了[经济模型预测控制](@entry_id:174671)（eMPC）和[分布](@entry_id:182848)式[模型预测控制](@entry_id:146965)（dMPC），它们是为应对现代系统在经济性、规模性和复杂性上的新挑战而设计的先进策略。

本文旨在系统性地介绍eMPC与dMPC的核心思想与方法，填补传统控制与现代复杂[系统优化](@entry_id:262181)需求之间的知识鸿沟。在接下来的内容中：
*   **“原理与机制”**一章将从MPC基础出发，深入剖析eMPC的经济优化机理和dMPC的[分布](@entry_id:182848)式协调架构。
*   **“应用与交叉学科关联”**一章将展示这些理论在工程、生物学和经济学中的实际应用与深刻联系。
*   **“动手实践”**环节将通过具体练习，巩固您对核心算法的理解。

现在，让我们开始深入探索这些先进控制策略的理论框架。

## 原理与机制

本章旨在深入探讨[模型预测控制](@entry_id:146965)（MPC）的核心原理与机制，从其基本形式出发，逐步扩展至[经济模型预测控制](@entry_id:174671)（eMPC）和[分布](@entry_id:182848)式[模型预测控制](@entry_id:146965)（dMPC）的前沿领域。我们将系统性地建立这些控制策略的理论框架，并通过具体的数学构造和实例来阐明其内在机理。

### [模型预测控制](@entry_id:146965)基础

[模型预测控制](@entry_id:146965)是一种基于模型的先进控制策略，它通过在有限时间范围内反复在线求解一个[最优控制](@entry_id:138479)问题，来计算当前时刻的[最优控制](@entry_id:138479)输入。

#### 有限时域[最优控制](@entry_id:138479)问题

[模型预测控制](@entry_id:146965)的核心是一个在每个采样时刻求解的**有限时域最优控制问题 (finite-horizon optimal control problem)**。考虑一个离散时间线性时不变（LTI）系统，其动态由以下[状态空间方程](@entry_id:266994)描述：

$$
x_{k+1} = A x_k + B u_k
$$

其中 $x_k \in \mathbb{R}^n$ 是系统在时刻 $k$ 的状态，而 $u_k \in \mathbb{R}^m$ 是控制输入。系统通常受到[状态和](@entry_id:193625)输入的约束，即 $x_k \in \mathcal{X}$ 和 $u_k \in \mathcal{U}$，其中 $\mathcal{X}$ 和 $\mathcal{U}$ 是给定的[紧凸集](@entry_id:272594)。

在任意时刻 $k$，控制器利用系统模型来预测未来 $N$ 步的行为，其中 $N$ 被称为**[预测时域](@entry_id:261473) (prediction horizon)**。控制器的目标是找到一个输入序列 $\{u_{k|k}, u_{k+1|k}, \dots, u_{k+N-1|k}\}$ 以及相应的状态序列 $\{x_{k|k}, x_{k+1|k}, \dots, x_{k+N|k}\}$，使得一个预定义的代价[函数最小化](@entry_id:138381)。这里的记号 $z_{k+i|k}$ 表示在时刻 $k$ 对未来时刻 $k+i$ 的变量 $z$ 的预测值。

一个典型的有限时域最优控制问题 [@problem_id:2701661] 可以表述为：

$$
\begin{aligned}
\min_{ \{u_{k+i|k}\}, \{x_{k+i|k}\} }  \quad \sum_{i=0}^{N-1} \ell(x_{k+i|k}, u_{k+i|k}) + V_f(x_{k+N|k}) \\
\text{s.t.}  \quad x_{k|k} = x_k, \\
 \quad x_{k+i+1|k} = A x_{k+i|k} + B u_{k+i|k},  \forall i \in \{0, \dots, N-1\}, \\
 \quad x_{k+i|k} \in \mathcal{X},  \forall i \in \{0, \dots, N-1\}, \\
 \quad u_{k+i|k} \in \mathcal{U},  \forall i \in \{0, \dots, N-1\}, \\
 \quad x_{k+N|k} \in \mathcal{X}_f.
\end{aligned}
$$

其中：
- $\ell(x, u)$ 是**阶段代价 (stage cost)**，通常是一个惩罚状态偏离原点和控制能量消耗的正定函数，例如 $\ell(x,u) = x^\top Q x + u^\top R u$。
- $V_f(x)$ 是**终端代价 (terminal cost)**，用于近似[预测时域](@entry_id:261473)之外的未来代价。
- $x_{k|k} = x_k$ 是[初始条件](@entry_id:152863)约束，它将预测与当前测量的系统状态 $x_k$ 联系起来。
- $x_{k+i+1|k} = A x_{k+i|k} + B u_{k+i|k}$ 是系统动态模型约束。
- $x_{k+i|k} \in \mathcal{X}$ 和 $u_{k+i|k} \in \mathcal{U}$ 是在整个[预测时域](@entry_id:261473)内必须满足的[状态和](@entry_id:193625)输入约束。
- $x_{k+N|k} \in \mathcal{X}_f$ 是**[终端约束](@entry_id:176488) (terminal constraint)**，其中 $\mathcal{X}_f \subseteq \mathcal{X}$ 是一个精心设计的**[终端集](@entry_id:163892) (terminal set)**，它对于保证[闭环系统](@entry_id:270770)的稳定性和[递归可行性](@entry_id:167169)至关重要。

#### [滚动时域](@entry_id:181425)策略

如果控制器在时刻 $k$ 计算出整个最优输入序列 $\{u^\star_{k|k}, \dots, u^\star_{k+N-1|k}\}$ 并将其全部开环地施加于系统，那么它将无法响应未预料到的扰动或模型失配。MPC的巧妙之处在于采用了**[滚动时域](@entry_id:181425)策略 (receding horizon policy)**。

该策略规定 [@problem_id:2701661]：
1.  在时刻 $k$，测量或估计当前状态 $x_k$。
2.  求解上述有限时域最优控制问题，得到[最优控制](@entry_id:138479)序列 $\{u^\star_{k|k}, \dots, u^\star_{k+N-1|k}\}$。
3.  **仅将序列中的第一个控制输入 $u_k = u^\star_{k|k}$ 施加于系统。**
4.  丢弃该序列的其余部分。
5.  在下一个时刻 $k+1$，系统演化到新的状态 $x_{k+1}$。控制器测量此新状态，并回到第1步，重新求解一个基于新状态的、向未来滚动的[优化问题](@entry_id:266749)。

这种“在每个时间步都重新规划”的策略引入了**反馈机制**。通过不断地根据最新的状态信息来修正控制计划，MPC能够有效地抑制扰动并适应系统变化，从而实现鲁棒的[闭环控制](@entry_id:271649)。

#### 确保稳定性与可行性：[终端约束](@entry_id:176488)成分

一个简单的MPC方案（例如，不包含终端代价和[终端集](@entry_id:163892)）可能无法保证[闭环系统](@entry_id:270770)的稳定性和**[递归可行性](@entry_id:167169) (recursive feasibility)**。[递归可行性](@entry_id:167169)意味着如果在时刻 $k$ [优化问题](@entry_id:266749)是可行的，那么在时刻 $k+1$ 它也必定是可行的。没有这个保证，控制器可能在未来的某个时刻找不到一个满足所有约束的控制输入，从而导致控制失败。

为了提供理论保证，MPC的设计中通常会引入终端代价 $V_f$ 和[终端集](@entry_id:163892) $\mathcal{X}_f$ [@problem_id:2701657]。这些**[终端约束](@entry_id:176488)成分 (terminal ingredients)** 的设计原则基于[Lyapunov稳定性理论](@entry_id:177166)。其核心思想是，[终端集](@entry_id:163892) $\mathcal{X}_f$ 应是一个在某个辅助**终端控制器 (terminal controller)** $u = Kx$ 作用下的**正[不变集](@entry_id:275226) (positively invariant set)**。这意味着一旦系统的状态进入 $\mathcal{X}_f$，终端控制器就能将其维持在 $\mathcal{X}_f$ 内，同时满足所有[状态和](@entry_id:193625)输入约束。

具体设计过程如下 [@problem_id:2701657]：
1.  **设计终端控制器**：首先，考虑与阶段代价 $\ell(x,u)=x^\top Q x + u^\top R u$ 相关的无约束无限时域[最优控制](@entry_id:138479)问题，即[线性二次调节器](@entry_id:267871)（LQR）问题。其[最优控制](@entry_id:138479)器是一个[线性状态反馈](@entry_id:271397)律 $u=Kx$，其中 $K$ 是 stabilizing gain。对应的最优[代价函数](@entry_id:138681)（或值函数）是一个二次型 $V^\star(x) = x^\top P x$。根据Bellman最优性原理，矩阵 $P$ 必须满足**离散时间代数[Riccati方程](@entry_id:184132) (Discrete-time Algebraic Riccati Equation, DARE)**：
    $$
    P = A^\top P A - (A^\top P B)(R+B^\top P B)^{-1}(B^\top P A) + Q
    $$
    对于一个纯量系统 $x_{k+1}=ax_k+bu_k$ 和代价 $\ell(x_k, u_k) = Qx_k^2 + Ru_k^2$，这个方程简化为 $b^2 P^2 + (R(1-a^2) - Q b^2) P - Q R = 0$。

2.  **选择终端代价与控制器**：选择LQR的值函数作为终端代价，即 $V_f(x) = x^\top P x$，并选择LQR反馈律 $u=Kx$ 作为终端控制器。在DARE成立的条件下，$V_f(x)$ 是闭环系统 $x_{k+1}=(A+BK)x_k$ 的一个[Lyapunov函数](@entry_id:273986)，因为 $V_f(x_{k+1}) - V_f(x_k) = -x_k^\top(Q+K^\top R K)x_k \le 0$。

3.  **确定[终端集](@entry_id:163892)**：[终端集](@entry_id:163892) $\mathcal{X}_f$ 被定义为一个水平集 $\mathcal{X}_f = \{x \mid x^\top P x \le \alpha\}$。这个集合必须满足两个条件：
    a. **正[不变性](@entry_id:140168) (Positive Invariance)**：Lyapunov递减的性质已保证，若 $x_k \in \mathcal{X}_f$，则 $x_{k+1}=(A+BK)x_k$ 也在 $\mathcal{X}_f$ 内。
    b. **[约束满足](@entry_id:275212) (Constraint Satisfaction)**：对于所有 $x \in \mathcal{X}_f$，终端控制器 $u=Kx$ 必须满足输入约束 $u \in \mathcal{U}$，同时状态约束 $x \in \mathcal{X}$ 也必须满足。例如，对于输入约束 $|u_k| \le \bar{u}$，我们需要 $|Kx| \le \bar{u}$ 对所有 $x \in \mathcal{X}_f$ 成立。这限制了 $\alpha$ 的最大取值。通过分析在集合 $\mathcal{X}_f$ 内 $|Kx|$ 的最大值，可以确定最大的允许值 $\alpha^\star$。

通过这种方式构造的[终端约束](@entry_id:176488)成分，可以证明：如果在时刻 $k$ [优化问题](@entry_id:266749)是可行的，那么在时刻 $k+1$ 总能构造出一个[可行解](@entry_id:634783)（即，施加 $u_k=u^\star_{k|k}$ 后，将剩余的计划 $\{u^\star_{k+1|k}, \dots, u^\star_{k+N-1|k}\}$ 平移，并在最后一步施加终端控制律 $u=Kx_{k+N|k}$）。这保证了[递归可行性](@entry_id:167169)。同时，最优[代价函数](@entry_id:138681)可以被证明是一个Lyapunov函数，从而保证了闭环系统的[渐近稳定性](@entry_id:149743)。

### [经济模型预测控制](@entry_id:174671) (eMPC)

传统的MPC（通常称为跟踪MPC）的主要目标是使系统状态跟踪一个预先给定的[设定点](@entry_id:154422)或参考轨迹。然而，在许多应用中，真正的目标并非跟踪某个特定值，而是优化某个具有直接经济意义的性能指标，例如最小化运行成本、最大化产量或利润。[经济模型预测控制](@entry_id:174671)（eMPC）正是为解决这类问题而生。

#### 超越[设定点](@entry_id:154422)跟踪：经济目标
eMPC与传统MPC的根本区别在于其**阶段代价 (stage cost)** 的选择 [@problem_id:2701652]。eMPC采用一个通用的**经济阶段代价 (economic stage cost)** $\ell(x,u)$，它直接量化了系统的经济性能。与跟踪MPC的代价函数不同，经济[代价函数](@entry_id:138681)通常不具备以下性质：
- **非[正定性](@entry_id:149643)**：它不一定是关于某个[设定点](@entry_id:154422)的正定函数。例如，一个利润函数可能在很大的操作区域内都是正的。
- **未知最优工作点**：使单步经济代价最优的操作点 $(x_s, u_s)$ 可能不是系统应该长时间运行的最佳点。真正的目标是优化长期的平均性能，例如最小化渐近平均代价：
  $$
  \limsup_{T \to \infty} \frac{1}{T} \sum_{k=0}^{T-1} \ell(x_k, u_k)
  $$

因此，eMPC的任务不是将系统驱动到一个预设的目标，而是让系统**自主地寻找并收敛到最经济的运行模式**，无论这个模式是一个[稳态](@entry_id:182458)点还是一个动态的轨迹。

#### 最优行为：从[不动点](@entry_id:156394)到周期轨道

由于eMPC优化的是[一般性](@entry_id:161765)的经济指标，其闭环系统的行为可能远比收敛到一个[固定点](@entry_id:156394)要丰富得多。一个经典例子是，当经济代价函数随时间变化时（例如，电价在一天[内波](@entry_id:261048)动），最优的运行模式可能是一个**[周期轨道](@entry_id:275117) (periodic orbit)** [@problem_id:2701689]。

考虑一个库存管理系统，其库存水平 $x_k$ 的动态为 $x_{k+1} = x_k + u_k - d$，其中 $u_k$ 是采购量， $d$ 是恒定的需求量。
- 如果采用**跟踪MPC**，目标是维持库存水平在一个理想的参考值 $x_r$ (例如，$x_r=0.5$)，其阶段代价为 $\ell_t(x,u) = (x - x_r)^2 + \rho u^2$。在这种情况下，最优的[稳态运行](@entry_id:755412)点是 $(x_s, u_s) = (0.5, 0.5)$，闭环系统将渐近收敛于此。
- 现在，如果采用**eMPC**，目标是最小化采购成本 $\ell_{e,k}(x,u) = p_k u_k$，其中采购单价 $p_k$ 呈周期性变化（例如，偶数时刻价格低 $p_{2m}=0$，奇数时刻价格高 $p_{2m+1}=1$）。在这种情况下，维持恒定的采购量 $u_k=0.5$ 显然不是最经济的。一个更优的策略是在价格低时多买（例如，$u_{2m} = 1$），在价格高时少买（例如，$u_{2m+1}=0$），只要平均采购量等于需求量即可。这种“低买高卖”的策略使得库存水平在一个周期为2的[轨道](@entry_id:137151)上波动。计算表明，这种周期性操作的平均成本严格低于任何[稳态](@entry_id:182458)操作。因此，eMPC控制器将自动发现并驱动系统收敛到这个经济上最优的周期轨道，而不是一个固定的[平衡点](@entry_id:272705) [@problem_id:2701689]。

这个例子清晰地展示了eMPC的强大之处：它能够利用动态操作来发掘并利用时变的经济机会，从而实现超越[稳态](@entry_id:182458)操作的性能。

#### eMPC的理论基础

由于经济代价函数缺乏传统代价函数的良好性质（如[正定性](@entry_id:149643)），e[MPC的稳定性](@entry_id:172566)与性能分析需要更复杂的理论工具。

##### 巡航特性

**巡航特性 (turnpike property)** 是经济[最优控制理论](@entry_id:139992)中的一个深刻结果，它描述了长时域最优轨迹的普遍行为 [@problem_id:2701670]。这个名字来源于一个经济学比喻：在两个城市之间开车的最佳路径是尽快上高速公路（即“turnpike”），沿高速公路行驶大部分路程，然后在接近目的地时离开。

类似地，对于一个具有经济目标的有限时域[最优控制](@entry_id:138479)问题，当[预测时域](@entry_id:261473) $N$ 足够长时，其最优状态轨迹 $x_k^\star$ 会表现出以下行为：
1.  从初始状态 $x_0$ 快速移动到一个被称为**经济最优[稳态](@entry_id:182458) (economically optimal steady state)** $x^s$ 的邻域。
2.  在 $x^s$ 的邻域内“巡航”大部分时间。
3.  在时域即将结束时，离开 $x^s$ 的邻域以满足[终端约束](@entry_id:176488)。

更精确地，在某些技术条件下（主要是严格耗散性），可以证明最优轨迹偏离[稳态](@entry_id:182458)的总量是被一个与时域长度 $N$ 无关的常数 $C$ 所界定的，即 $\sum_{k=0}^{N-1} \alpha(\Vert x_k^\star - x^s\Vert) \le C$，其中 $\alpha$ 是一个正定函数。这意味着，轨迹必须在绝大多数时间步长上保持在 $x^s$ 附近，只有在时域的开始和结束阶段（即所谓的“[边界层](@entry_id:139416)”）才允许有显著偏离。这个特性解释了为什么eMPC尽管是[在线优化](@entry_id:636729)，其行为却常常围绕着一个潜在的、由经济目标决定的[稳态](@entry_id:182458)点。

##### 严格[耗散性](@entry_id:162959)与稳定性

证明eMPC稳定性的关键挑战在于其代价函数通常不能直接作为Lyapunov函数。现代eMPC理论的核心工具是**耗散性理论 (dissipativity theory)**。一个系统被称为关于某个**供给率 (supply rate)** $s(x,u)$ 是耗散的，如果存在一个**[储能函数](@entry_id:197811) (storage function)** $S(x)$，使得[储能](@entry_id:264866)的变化量不超过供给量，即 $S(f(x,u)) - S(x) \le s(x,u)$。

对于eMPC，供给率通常被定义为经济代价与其最优[稳态](@entry_id:182458)值之差，即 $s(x,u) = \ell(x,u) - \ell(x^\star, u^\star)$。为了证明稳定性，我们需要一个更强的条件，即**严格[耗散性](@entry_id:162959) (strict dissipativity)** [@problem_id:2701669]。系统被称为严格耗散的，如果存在[储能函数](@entry_id:197811) $S(x)$ 和一个类-$\mathcal{K}_\infty$函数 $\rho$，使得以下不等式成立：
$$
S(f(x,u)) - S(x) \le \ell(x,u) - \ell(x^\star, u^\star) - \rho(\Vert(x,u) - (x^\star, u^\star)\Vert)
$$
这个不等式意味着，系统“耗散”的能量不仅由供给率决定，还有一部分因为偏离最优[稳态](@entry_id:182458)而被额外耗散掉。

严格耗散性之所以关键，是因为它允许我们构造一个“旋转后”的[代价函数](@entry_id:138681)。定义一个**旋转阶段代价 (rotated stage cost)**：
$$
\ell_r(x,u) := \ell(x,u) - \ell(x^\star, u^\star) + S(x) - S(f(x,u))
$$
利用严格耗散性不等式，我们可以证明 $\ell_r(x,u) \ge \rho(\Vert(x,u) - (x^\star, u^\star)\Vert)$。这意味着，虽然原始经济代价 $\ell(x,u)$ 不是正定的，但这个旋转后的代价 $\ell_r(x,u)$ 是关于最优[稳态](@entry_id:182458) $(x^\star, u^\star)$ 的正定函数。

旋转代价的巧妙之处在于，其在时域内的积分与原始经济代价的积分密切相关，因为中间的[储能函数](@entry_id:197811)项会形成一个伸缩和 (telescoping sum)：$\sum_{i=0}^{N-1} \ell_r(x_i, u_i) = \sum_{i=0}^{N-1} (\ell(x_i, u_i) - \ell(x^\star, u^\star)) + S(x_0) - S(x_N)$。这使得我们可以将与eMPC相关的最[优值函数](@entry_id:173036)（经过[旋转变换](@entry_id:200017)后）证明为一个Lyapunov函数，从而在适当的[终端约束](@entry_id:176488)条件下，保证[闭环系统](@entry_id:270770)渐近收敛于经济最优[稳态](@entry_id:182458)。

### [分布](@entry_id:182848)式[模型预测控制](@entry_id:146965) (dMPC)

许多现代工程系统，如电网、水利网络、交通系统和大型化工厂，本质上是由大量相互关联的子系统构成的大规模系统。对这类系统采用集中式MPC通常是不可行的，因为它需要一个中央控制器收集所有子系统的信息，并求解一个维度极高的[优化问题](@entry_id:266749)，这会带来巨大的计算负担和通信瓶颈。[分布](@entry_id:182848)式[模型预测控制](@entry_id:146965)（dMPC）旨在通过将控制任务分解给多个协同工作的局部控制器来克服这些挑战。

#### 表示互联：动态耦合与图

理解dMPC的第一步是形式化地描述子系统之间的相互作用。在一个由 $M$ 个子系统组成的网络中，第 $i$ 个子系统的动态可以表示为：
$$
x_{i,k+1} = A_i x_{i,k} + B_i u_{i,k} + \sum_{j \in \mathcal{N}_i} A_{ij} x_{j,k}
$$
这里的求和项代表了**动态耦合 (dynamic coupling)**：子系统 $j$ 的状态 $x_{j,k}$ 直接影响子系统 $i$ 的下一个状态 $x_{i,k+1}$。这种耦合的存在当且仅当[耦合矩阵](@entry_id:191757) $A_{ij} \neq 0$ [@problem_id:2701665]。

这些有向的物理交互关系可以很自然地用一个**有向图 (directed graph)** $G=(\mathcal{V}, \mathcal{E})$ 来表示。图的顶点集 $\mathcal{V}=\{1, \dots, M\}$ 代表所有子系统。如果子系统 $j$ 的状态影响子系统 $i$，我们就在图中画一条从 $j$ 指向 $i$ 的边，即 $(j,i) \in \mathcal{E}$。因此，影响子系统 $i$ 的邻居集合 $\mathcal{N}_i$ 正是图中所有指向节点 $i$ 的节点的集合（即 $i$ 的入邻居）。值得注意的是，这个**物理耦合图**描述了系统的内在结构，它与控制器之间用于协调的**通信图**可能是不同的。

#### [分布式控制](@entry_id:167172)架构

根据信息流结构和协调方式的不同，大规模系统的MPC可以分为几种主要架构 [@problem_id:2701637]：

- **分散式MPC (Decentralized MPC)**：这是最简单的架构，各个子系统的控制器之间**没有在线通信**。每个控制器仅根据自己的局部测量和模型做出决策，通常将来自邻居的耦合项 $A_{ij}x_j$ 视为未知的扰动。这种方法简单、鲁棒，但由于完全忽略了协调，通常性能较差，甚至可能导致系统不稳定，尤其是在耦合较强的情况下。

- **[分布](@entry_id:182848)式MPC (Distributed MPC)**：在此架构中，局部控制器通过一个通信网络进行**点对点 (peer-to-peer)** 的协商。在每个采样时刻，它们会迭代地交换信息（如预测的轨迹或代价信息），并更新各自的控制计划，直到达成某种程度的共识或满足[收敛条件](@entry_id:166121)。这种方式旨在通过局部协调来逼近集中式MPC的性能，而无需一个中央权威。

- **分层式MPC (Hierarchical MPC)**：此架构采用**自上而下**的控制结构。一个高层（或协调层）控制器负责整个网络的宏观决策，它基于一个简化的、聚合的系统模型进行优化，并将结果（如设定点、资源配额或经济价格）作为指令下发给多个底层局部控制器。底层控制器则在遵循[上层](@entry_id:198114)指令的前提下，求解各自的局部MPC问题以优化本地性能。信息流是双向的：指令向下传递，而聚合的响应或状态信息则向上汇报。

#### dMPC中的协调机制

[分布](@entry_id:182848)式和分层式MPC的核心在于其**协调机制 (coordination mechanisms)**，即多个决策者如何调整各自的计划以共同实现一个全局目标。

##### 原[问题分解](@entry_id:272624)：迭代最优响应

对于一个合作式的dMPC问题，如果其全局[目标函数](@entry_id:267263)（例如，所有子系统经济代价之和）是可知的，协调可以通过**迭代最优响应 (iterative best response)** 来实现。其基本思想是，在每次迭代中，每个控制器假设其邻居的控制策略是固定的，然后求解自己的最优控制序列。

- **Jacobi方案 (并行)**：在每次迭代中，所有控制器**同时**基于其他控制器在上一轮迭代中广播的计划，来计算自己的新计划。
- **Gauss-Seidel方案 (串行)**：控制器们按照一个预先确定的顺序（例如 $1, 2, \dots, M$）**依次**更新自己的计划。控制器 $i$ 在计算时，会利用所有已经完成[本轮](@entry_id:169326)更新的控制器（$j<i$）的最新计划，而对于还未更新的控制器（$j>i$），则使用它们在上一轮的旧计划。