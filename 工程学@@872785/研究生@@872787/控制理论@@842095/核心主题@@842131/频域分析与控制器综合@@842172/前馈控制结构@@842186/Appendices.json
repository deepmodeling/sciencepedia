{"hands_on_practices": [{"introduction": "在实践中，前馈控制可以通过多种方式实现，其中两种常见的方法是使用外部参考预滤波器和修改PID控制器内部的设定点权重。本练习旨在揭示这两种看似不同的架构在数学上的内在联系 [@problem_id:2708600]。通过推导它们等效的条件，您将更深刻地理解前馈原理如何嵌入到不同的控制结构中，并学会在不同实现之间进行转换和选择。", "problem": "考虑一个单位反馈下的单输入单输出 (SISO) 线性时不变 (LTI) 被控对象，其传递函数为 $G(s)$。提出了两种参考整形架构，两者均由相同的参考信号 $R(s)$ 驱动，并使用相同的比例-积分-微分 (PID) 系数 $K_p$、$K_i$ 和 $K_d$：\n\n- 架构 $\\mathcal{W}$ (设定点加权 PID，无前置滤波器)：控制输入由一个 PID 生成，其中比例项对参考使用权重 $\\beta$，积分项使用误差，微分项对参考的微分使用权重 $\\gamma$。在拉普拉斯域中，控制律为\n$$\nU_{\\mathcal{W}}(s) \\;=\\; K_p\\big(\\beta\\,R(s) - Y(s)\\big) \\;+\\; \\frac{K_i}{s}\\big(R(s)-Y(s)\\big) \\;+\\; K_d\\,s\\big(\\gamma\\,R(s) - Y(s)\\big),\n$$\n且被控对象输出为 $Y(s) = G(s)\\,U_{\\mathcal{W}}(s)$。\n\n- 架构 $\\mathcal{F}$ (带参考前置滤波器的无加权 PID)：参考信号在进入求和点之前，首先由一个严格真或真的稳定滤波器 $F(s)$进行滤波，然后一个标准的（无加权的）PID作用于产生的误差。在拉普拉斯域中，\n$$\nU_{\\mathcal{F}}(s) \\;=\\; \\Big(K_p + \\frac{K_i}{s} + K_d\\,s\\Big)\\,\\big(F(s)\\,R(s) - Y(s)\\big),\n$$\n且 $Y(s) = G(s)\\,U_{\\mathcal{F}}(s)$。\n\n从单位反馈 SISO LTI 系统的基本闭环关系出发，比较这两种架构的闭环参考到输出映射 $T_{\\mathcal{W}}(s) \\equiv \\dfrac{Y(s)}{R(s)}$ 和 $T_{\\mathcal{F}}(s) \\equiv \\dfrac{Y(s)}{R(s)}$。除了假设 $G(s)$ 是一个因果被控对象的真传递函数外，不对其作任何特殊假设，判断下列哪个陈述是正确的。\n\nA. 对于单位反馈且两种架构中 $K_p$、$K_i$、$K_d$ 均相同的情况，这两种架构对于所有的 $R(s)$ 和所有的 $G(s)$ 是参考等效的，当且仅当\n$$\nF(s) \\;=\\; \\frac{K_p\\,\\beta \\;+\\; \\dfrac{K_i}{s} \\;+\\; K_d\\,\\gamma\\,s}{K_p \\;+\\; \\dfrac{K_i}{s} \\;+\\; K_d\\,s}.\n$$\n\nB. 参考等效性要求前置滤波器明确地依赖于被控对象以补偿环路增益，即对于合适的控制器选择，$F(s) = \\dfrac{1 + G(s)C_y(s)}{1 + G(s)C(s)}$，其中 $C_y(s)$ 表示输出所见的加权 PID，$C(s)$ 表示架构 $\\mathcal{F}$ 中的无加权 PID。\n\nC. 通过选择与 $K_p$、$K_i$、$K_d$ 和 $G(s)$ 无关的常数 $F(s) = \\beta$，可以使两种架构对于阶跃参考信号是参考等效的。\n\nD. 只有当 $\\beta = \\gamma = 1$ 时，这两种架构才能参考等效，在这种情况下，任何具有单位直流 (DC) 增益的稳定滤波器 $F(s)$ 都会产生相同的闭环参考映射。\n\n选择正确的选项。通过从基本原理推导相关的闭环映射，并陈述等效的充要条件来证明你的选择。", "solution": "我们从单位反馈 SISO LTI 系统的基本闭环关系开始。在整个推导过程中，$R(s)$ 是参考信号，$Y(s)$ 是输出，$U(s)$ 是控制输入，$G(s)$ 是被控对象传递函数。\n\n1) 架构 $\\mathcal{W}$ (设定点加权 PID)\n\n根据定义，\n$$\nU_{\\mathcal{W}}(s) \\;=\\; K_p\\big(\\beta\\,R - Y\\big) \\;+\\; \\frac{K_i}{s}\\big(R - Y\\big) \\;+\\; K_d\\,s\\big(\\gamma\\,R - Y\\big).\n$$\n将参考项和输出项分组：\n$$\nU_{\\mathcal{W}}(s) \\;=\\; \\underbrace{\\Big(K_p\\,\\beta + \\frac{K_i}{s} + K_d\\,\\gamma\\,s\\Big)}_{C_{rw}(s)}\\,R(s) \\;-\\; \\underbrace{\\Big(K_p + \\frac{K_i}{s} + K_d\\,s\\Big)}_{C_y(s)}\\,Y(s).\n$$\n被控对象遵循 $Y = G\\,U_{\\mathcal{W}}$，因此\n$$\nY(s) \\;=\\; G(s)\\,\\Big(C_{rw}(s)\\,R(s) - C_y(s)\\,Y(s)\\Big),\n$$\n于是\n$$\n\\big(1 + G(s)\\,C_y(s)\\big)\\,Y(s) \\;=\\; G(s)\\,C_{rw}(s)\\,R(s).\n$$\n因此，架构 $\\mathcal{W}$ 的闭环参考到输出映射为\n$$\nT_{\\mathcal{W}}(s) \\;\\equiv\\; \\frac{Y(s)}{R(s)} \\;=\\; \\frac{G(s)\\,C_{rw}(s)}{1 + G(s)\\,C_y(s)},\n$$\n其中\n$$\nC_{rw}(s) \\;=\\; K_p\\,\\beta + \\frac{K_i}{s} + K_d\\,\\gamma\\,s, \n\\qquad\nC_y(s) \\;=\\; K_p + \\frac{K_i}{s} + K_d\\,s.\n$$\n\n2) 架构 $\\mathcal{F}$ (带前置滤波器的无加权 PID)\n\n在此架构中，\n$$\nU_{\\mathcal{F}}(s) \\;=\\; C(s)\\,\\big(F(s)\\,R(s) - Y(s)\\big),\n\\qquad\nC(s) \\;=\\; K_p + \\frac{K_i}{s} + K_d\\,s.\n$$\n根据 $Y = G\\,U_{\\mathcal{F}}$，我们得到\n$$\nY(s) \\;=\\; G(s)\\,C(s)\\,\\big(F(s)\\,R(s) - Y(s)\\big),\n$$\n所以\n$$\n\\big(1 + G(s)\\,C(s)\\big)\\,Y(s) \\;=\\; G(s)\\,C(s)\\,F(s)\\,R(s).\n$$\n因此，架构 $\\mathcal{F}$ 的闭环参考到输出映射为\n$$\nT_{\\mathcal{F}}(s) \\;\\equiv\\; \\frac{Y(s)}{R(s)} \\;=\\; \\frac{G(s)\\,C(s)\\,F(s)}{1 + G(s)\\,C(s)}.\n$$\n\n3) 等效条件\n\n为了实现参考等效，我们要求在关心区域内的所有 $s$ 以及在单位反馈假设下所有允许的 $G(s)$，都有 $T_{\\mathcal{W}}(s) \\equiv T_{\\mathcal{F}}(s)$。\n由于根据构造 $C_y(s) = C(s)$（它们是同一个无加权 PID），分母已经匹配：\n$$\n1 + G(s)\\,C_y(s) \\;=\\; 1 + G(s)\\,C(s).\n$$\n因此，$T_{\\mathcal{W}}$ 和 $T_{\\mathcal{F}}$ 的相等性简化为分子相等：\n$$\nG(s)\\,C_{rw}(s) \\;=\\; G(s)\\,C(s)\\,F(s) \\quad \\text{for all } G(s).\n$$\n消去 $G(s)$ 得到充要条件\n$$\nC_{rw}(s) \\;=\\; C(s)\\,F(s).\n$$\n代入定义，\n$$\nK_p\\,\\beta + \\frac{K_i}{s} + K_d\\,\\gamma\\,s \\;=\\; \\Big(K_p + \\frac{K_i}{s} + K_d\\,s\\Big)\\,F(s),\n$$\n于是\n$$\nF(s) \\;=\\; \\frac{K_p\\,\\beta + \\dfrac{K_i}{s} + K_d\\,\\gamma\\,s}{K_p + \\dfrac{K_i}{s} + K_d\\,s}.\n$$\n该条件与被控对象 $G(s)$ 无关，是实现参考等效的充要条件。\n\n关于可实现性的补充说明：\n- 分子和分母同乘以 $s$ 可得\n$$\nF(s) \\;=\\; \\frac{K_d\\,\\gamma\\,s^2 + K_p\\,\\beta\\,s + K_i}{K_d\\,s^2 + K_p\\,s + K_i},\n$$\n这是真的（proper）。当 $\\gamma = 0$ 时，$F(s)$ 是严格真的（strictly proper）。直流 (DC) 增益是 $F(0) = 1$，高频极限是 $\\lim_{s\\to\\infty}F(s) = \\gamma$。\n\n4)逐个选项分析\n\n- 选项 A：这正是我们刚从基本原理推导出的充要条件，并且它与 $G(s)$ 无关。结论：正确。\n\n- 选项 B：该选项断言了一个依赖于被控对象的条件 $F(s) = \\dfrac{1 + G(s)C_y(s)}{1 + G(s)C(s)}$。然而，我们已经证明，因为 $C_y(s) = C(s)$，分母自动匹配，等效性简化为与被控对象无关的 $F(s) = \\dfrac{C_{rw}(s)}{C(s)}$。结论：不正确。\n\n- 选项 C：选择 $F(s) = \\beta$ 会得到\n$$\nT_{\\mathcal{F}}(s) \\;=\\; \\frac{G(s)\\,C(s)\\,\\beta}{1 + G(s)\\,C(s)}.\n$$\n但设定点加权映射是\n$$\nT_{\\mathcal{W}}(s) \\;=\\; \\frac{G(s)\\,(K_p\\,\\beta + \\frac{K_i}{s} + K_d\\,\\gamma\\,s)}{1 + G(s)\\,(K_p + \\frac{K_i}{s} + K_d\\,s)},\n$$\n通常情况下，即使对于阶跃输入（其拉普拉斯变换与 $1/s$ 成比例），它也不等于 $T_{\\mathcal{F}}(s)$，除非存在限制性的、非通用的参数关系。结论：不正确。\n\n- 选项 D：当 $\\beta = \\gamma = 1$ 时，架构 $\\mathcal{W}$ 简化为无前置滤波器的无加权 PID，因此 $T_{\\mathcal{W}}(s) = \\dfrac{G(s)\\,C(s)}{1 + G(s)\\,C(s)}$。为实现等效，我们需要 $F(s) \\equiv 1$。任何具有单位直流增益的稳定滤波器 $F(s)$ 都足够，这一说法是不正确的；只有 $F(s) \\equiv 1$ 才能保持整个频率响应不变。结论：不正确。", "answer": "$$\\boxed{A}$$", "id": "2708600"}, {"introduction": "具有显著时间延迟的系统对反馈控制构成了巨大挑战，这常常导致在特定反馈结构（如史密斯预估器）与真正的前馈扰动抑制之间产生混淆。本练习要求进行批判性分析，以明确区分这两种控制策略 [@problem_id:2708598]。通过剖析基于模型的反馈补偿（史密斯预估器）和用于扰动抑制的前馈控制的各自作用，您将澄清它们在应对复杂动态系统时的不同目标和机制。", "problem": "考虑一个具有纯输入输出死区的单输入单输出线性时不变 (LTI) 被控对象。从执行器作用到测量输出的真实被控对象被建模为 $P(s) = P_0(s)\\,e^{-s\\theta}$，其中 $P_0(s)$ 是一个严格真分、稳定、最小相位的传递函数，$\\theta  0$ 是一个已知的恒定死区时间。一个控制器 $C(s)$ 使用 Smith 预估器架构实现，其内部模型为 $\\hat P_0(s)$ 并包含相同的已知延迟 $e^{-s\\theta}$。Smith 预估器通过结合测量输出和模型响应来构建一个无延迟的伪输出，从而使控制器 $C(s)$ 的运行就好像反馈路径中不存在延迟一样。\n\n此外，一个输入扰动在被控对象动态之前，与控制器输出在同一个物理求和节点上以相加的方式进入。具体来说，执行器输入为 $u_{\\mathrm{act}}(s) = u(s) + H(s)\\,d(s)$，其中 $u(s)$ 是控制信号，$d(s)$ 是一个外部扰动，$H(s)$ 是一个已知的稳定传递函数，用于建模扰动到执行器求和节点的路径。一个可用的测量扰动代理 $d_m(s)$ 通过 $d_m(s) = M(s)\\,e^{-s\\theta_m}\\,d(s)$ 与 $d(s)$ 相关联，其中 $M(s)$ 是一个已知的、稳定的、可逆的传递函数，$\\theta_m \\ge 0$ 是测量通道中一个已知的传感器/传输延迟。您可以假设 $M(s)$ 和 $H(s)$ 是真分函数，并且 $M(s)$ 是最小相位的，因此 $M(s)^{-1}$ 是稳定的。\n\n一个测量扰动前馈路径 $u_f(s) = F(s)\\,d_m(s)$ 将与反馈控制器并联添加，并在与 $u(s)$ 和 $H(s)\\,d(s)$ 相同的执行器求和节点处求和。$F(s)$ 的设计目标是尽可能地消除 $d(s)$ 对输出 $y(s)$ 的影响，同时保留反馈回路的名义 Smith 预估器特性。\n\n根据框图代数的第一性原理、用 $e^{-s\\cdot}$ 表示时延的拉普拉斯域形式，以及闭环特征方程作为单位反馈互连下参考到输出传递函数分母的标准定义，选择下面所有正确的陈述。\n\nA. Smith 预估器是一种前馈控制器，因为它使用过程模型来预测延迟输出，并注入一个提前抵消延迟的控制信号；因此，它取代了反馈，而不是重构反馈。\n\nB. 在精确模型匹配 $\\hat P_0(s) = P_0(s)$ 的情况下，Smith 预估器从反馈回路的闭环特征方程中移除了显式因子 $e^{-s\\theta}$，但参考到输出的传递函数在其分子中仍然包含真实的被控对象延迟 $e^{-s\\theta}$ 作为因子。\n\nC. 为了使用测量代理 $d_m(s)$ 消除被控对象输出端的扰动，理想的前馈控制器是 $F(s) = -\\,P_0(s)^{-1}\\,e^{+s\\theta}\\,H(s)\\,M(s)^{-1}\\,e^{+s\\theta_m}$，这样前馈路径可以反转死区时间和无延迟被控对象，以便在下游对齐并消除扰动。\n\nD. 如果控制和扰动在相同的被控对象死区时间上游的同一执行器求和节点进入，并且模型知识是精确的，那么为了前馈设计的目的而忽略反馈回路，消除扰动的选择是 $F(s) = -\\,H(s)\\,M(s)^{-1}\\,e^{+s\\theta_m}$；这只有在测量代理相对于扰动到达执行器求和节点提供了至少 $\\theta_m$ 秒的预见时才是因果的。\n\nE. 在一个由 Smith 预估器调节的系统中，添加一个正确求和的测量扰动前馈路径 $u_f(s) = F(s)\\,d_m(s)$，必然会通过将 $e^{-s\\theta}$ 重新引入分母来改变闭环特征方程，从而有使预估器不稳定的风险。\n\n选择所有正确的选项。", "solution": "首先将验证问题陈述，然后从第一性原理推导出解决方案。\n\n### 问题验证\n\n**步骤 1：提取已知条件**\n\n-   被控对象模型：$P(s) = P_0(s)e^{-s\\theta}$\n-   被控对象特性：$P_0(s)$ 是一个严格真分、稳定、最小相位的传递函数。$\\theta  0$ 是一个已知的恒定死区时间。\n-   控制器：$C(s)$ 采用 Smith 预估器架构。\n-   内部模型：$\\hat{P}(s) = \\hat{P}_0(s)e^{-s\\theta}$。\n-   扰动模型：输入扰动 $d(s)$ 在执行器处进入。总执行器输入为 $u_{\\mathrm{act}}(s) = u(s) + H(s)d(s)$，其中 $u(s)$ 是控制信号。$H(s)$ 是一个已知的稳定传递函数。\n-   测量扰动代理：$d_m(s) = M(s)e^{-s\\theta_m}d(s)$。\n-   测量通道特性：$M(s)$ 是一个已知的、稳定的、可逆的、最小相位的传递函数。$M(s)$ 和 $H(s)$ 是真分函数。$\\theta_m \\ge 0$ 是一个已知的延迟。\n-   前馈控制器：$u_f(s) = F(s)d_m(s)$ 在执行器求和节点处添加。\n-   最终执行器输入：$u_{\\mathrm{act}}(s) = u(s) + u_f(s) + H(s)d(s)$。\n-   设计目标：$F(s)$ 应消除 $d(s)$ 对输出 $y(s)$ 的影响。\n-   特征方程定义：参考到输出传递函数的分母。\n\n**步骤 2：使用提取的已知条件进行验证**\n\n该问题描述了一个经典但高级的控制系统设计场景，涉及用于死区补偿的 Smith 预估器和用于扰动抑制的前馈控制器。所有组件和概念——LTI 系统、传递函数、死区时间、Smith 预估器、前馈控制、稳定性、因果性——都是控制理论的标准元素。\n\n-   **科学依据：** 该问题牢固地基于线性控制理论的既定原则。该设置对于过程控制应用是现实的。不存在科学上或事实上的不健全之处。\n-   **适定性：** 该问题提供了足够的信息来推导所需的传递函数并分析系统的特性。选项中提出的问题是具体的，可以严格回答。\n-   **客观性：** 语言精确且技术性强。问题设置中没有使用主观或模棱两可的陈述。\n-   **其他缺陷：** 问题是自洽的、一致的，并且没有表现出任何其他无效性标志（不切实际、不适定、微不足道等）。\n\n**步骤 3：结论和行动**\n\n问题陈述是 **有效的**。可以推导出解决方案。\n\n### 推导与选项分析\n\n设 $r(s)$ 为参考输入。在 Smith 预估器架构中，反馈控制器 $C(s)$ 作用于误差信号 $e_{sp}(s) = r(s) - y_{sp}(s)$，其中 $y_{sp}(s)$ 是一个经过延迟补偿的伪输出。来自反馈路径的控制信号是 $u(s) = C(s)(r(s) - y_{sp}(s))$。伪输出的构造为 $y_{sp}(s) = y(s) + (\\hat{P}_0(s) - \\hat{P}(s))u(s) = y(s) + \\hat{P}_0(s)(1 - e^{-s\\theta})u(s)$。\n\n被控对象输出为 $y(s) = P(s)u_{\\mathrm{act}}(s) = P_0(s)e^{-s\\theta}[u(s) + u_f(s) + H(s)d(s)]$。\n\n题目给定假设模型精确匹配，因此 $\\hat{P}_0(s) = P_0(s)$。将此式和 $y(s)$ 的表达式代入 $u(s)$ 的方程中：\n$u(s) = C(s) \\left[ r(s) - \\left( P_0(s)e^{-s\\theta}[u(s) + u_f(s) + H(s)d(s)] + P_0(s)(1 - e^{-s\\theta})u(s) \\right) \\right]$\n$u(s) = C(s) \\left[ r(s) - P_0(s)e^{-s\\theta}u(s) - P_0(s)e^{-s\\theta}(u_f(s) + H(s)d(s)) - P_0(s)u(s) + P_0(s)e^{-s\\theta}u(s) \\right]$\n$u(s) = C(s) \\left[ r(s) - P_0(s)u(s) - P_0(s)e^{-s\\theta}(u_f(s) + H(s)d(s)) \\right]$\n求解 $u(s)$：\n$u(s) [1 + C(s)P_0(s)] = C(s)r(s) - C(s)P_0(s)e^{-s\\theta}[u_f(s) + H(s)d(s)]$\n$u(s) = \\frac{C(s)}{1 + C(s)P_0(s)}r(s) - \\frac{C(s)P_0(s)e^{-s\\theta}}{1 + C(s)P_0(s)}[u_f(s) + H(s)d(s)]$\n\n现在我们求被控对象输出 $y(s)$：\n$y(s) = P_0(s)e^{-s\\theta}[u(s) + u_f(s) + H(s)d(s)]$\n代入 $u(s)$ 的表达式：\n$y(s) = P_0(s)e^{-s\\theta}\\left[ \\frac{C(s)}{1+C(s)P_0(s)}r(s) - \\frac{C(s)P_0(s)e^{-s\\theta}}{1+C(s)P_0(s)}[u_f(s) + H(s)d(s)] + [u_f(s) + H(s)d(s)] \\right]$\n$y(s) = \\frac{C(s)P_0(s)e^{-s\\theta}}{1+C(s)P_0(s)}r(s) + P_0(s)e^{-s\\theta}\\left[1 - \\frac{C(s)P_0(s)e^{-s\\theta}}{1+C(s)P_0(s)}\\right][u_f(s) + H(s)d(s)]$\n\n**A. 选项 A 的评估**\n该陈述声称 Smith 预估器是一种取代反馈的前馈控制器。这从根本上是错误的。Smith 预估器是一种基于模型的 *反馈* 控制策略。其结构明确是一个反馈回路，其中控制器输出 $u(s)$ 取决于参考 $r(s)$ 与从被控对象输出 $y(s)$ 导出的信号 $y_{sp}(s)$ 之间的误差。它不是取代反馈，而是重构反馈回路，以改善含死区系统的性能。“预估”是在反馈补偿器内部进行的，旨在有效地从特征方程中移除延迟，而不是以开环方式运行。\n**结论：错误**\n\n**B. 选项 B 的评估**\n从推导出的 $y(s)$ 表达式，参考到输出的传递函数 $G_{yr}(s)$ 是：\n$$G_{yr}(s) = \\frac{y(s)}{r(s)} = \\frac{C(s)P_0(s)e^{-s\\theta}}{1+C(s)P_0(s)}$$\n通过将此传递函数的分母设为零，得到闭环特征方程：\n$$1 + C(s)P_0(s) = 0$$\n这个方程不包含死区项 $e^{-s\\theta}$，这证实了陈述的第一部分。Smith 预估器有效地使反馈回路的行为就像它在控制无延迟的被控对象 $P_0(s)$ 一样。\n然而，传递函数 $G_{yr}(s)$ 的分子明确包含因子 $e^{-s\\theta}$。这意味着对参考变化的整体闭环响应仍将表现出完整的被控对象死区时间 $\\theta$，这是物理上不可避免的。陈述的两个部分都是正确的。\n**结论：正确**\n\n**C. 选项 C 的评估**\n前馈控制器 $F(s)$ 的目标是消除扰动 $d(s)$ 对输出 $y(s)$ 的影响。前馈设计的一个标准原则是独立于反馈回路分析扰动路径，因为反馈旨在校正残余误差。扰动 $d(s)$ 通过两条路径影响输出 $y(s)$：\n1. 直接扰动路径：$d(s) \\rightarrow H(s) \\rightarrow u_{\\mathrm{act}}(s) \\rightarrow P(s) \\rightarrow y(s)$。贡献：$P(s)H(s)d(s)$。\n2. 前馈控制路径：$d(s) \\rightarrow M(s)e^{-s\\theta_m} \\rightarrow d_m(s) \\rightarrow F(s) \\rightarrow u_f(s) \\rightarrow u_{\\mathrm{act}}(s) \\rightarrow P(s) \\rightarrow y(s)$。贡献：$P(s)F(s)M(s)e^{-s\\theta_m}d(s)$。\n\n为了完美消除，这些贡献的总和必须为零：\n$P(s)H(s)d(s) + P(s)F(s)M(s)e^{-s\\theta_m}d(s) = 0$\n由于 $P(s)$ 不恒为零，我们可以用它来除：\n$H(s) + F(s)M(s)e^{-s\\theta_m} = 0$\n求解理想的前馈控制器 $F(s)$：\n$$F(s) = -H(s)M(s)^{-1}e^{+s\\theta_m}$$\n选项 C 中给出的公式 $F(s) = -P_0(s)^{-1}e^{+s\\theta}H(s)M(s)^{-1}e^{+s\\theta_m}$ 是不正确的。它试图反转被控对象动态 $P_0(s)e^{-s\\theta}$，这是不必要的，因为扰动和控制作用都通过同一个被控对象。此外，由于 $P_0(s)$ 是严格真分函数，其逆 $P_0(s)^{-1}$ 是非真分函数，因此物理上不可实现。项 $e^{+s\\theta}$ 也是非因果的。\n**结论：错误**\n\n**D. 选项 D 的评估**\n此选项正确地陈述了为进行前馈设计而忽略反馈回路的原则。正如为选项 C 推导的那样，理想的扰动消除选择 $F(s)$ 确实是：\n$$F(s) = -H(s)M(s)^{-1}e^{+s\\theta_m}$$\n这证实了陈述的第一部分。第二部分讨论了因果性。传递函数 $F(s)$ 包含项 $e^{+s\\theta_m}$。在时域中，这对应于 $\\theta_m$ 的时间提前。如果 $\\theta_m > 0$，这个操作是非因果的，因为它需要其输入信号的未来值。一个具有传递函数 $F(s)$ 的 LTI 系统是因果的，当且仅当其冲激响应 $f(t)$ 对于所有 $t  0$ 都为零。当 $\\theta_m > 0$ 时，$e^{+s\\theta_m}$ 的存在将使 $f(t)$ 在 $t  0$ 时不为零。因此，对于 $\\theta_m > 0$，$F(s)$ 是一个非因果传递函数。这样的控制器只有在其输入信号的预见可用时才能实现。该陈述说，只有在提供了至少 $\\theta_m$ 秒的预见时，$F(s)$ 才是因果的。这种措辞在控制领域很常见，意指该控制器是“可实现的”或“可执行的”。在这一惯例下，该陈述是正确的。\n**结论：正确**\n\n**E. 选项 E 的评估**\n闭环系统的特征方程决定了其稳定性。正如问题中所定义和为选项 B 所推导的，特征方程是参考到输出传递函数的分母，即 $1+C(s)P_0(s)=0$。这个推导是在包含前馈路径 $u_f(s)=F(s)d_m(s)$ 的整个系统上进行的。前馈控制器 $F(s)$ 和扰动信号 $d_m(s)$ 并未出现在特征方程中。这是 LTI 系统的一个基本属性：一个前馈路径，它接收一个外部信号并将其输出加到控制信号上，不会改变闭环系统的极点，因此不影响其稳定性。稳定性是由反馈回路结构本身决定的。声称添加前馈路径“必然改变闭环特征方程”的说法是错误的。\n**结论：错误**", "answer": "$$\\boxed{BD}$$", "id": "2708598"}, {"introduction": "理想的前馈控制依赖于对被控对象的完美模型，这在现实中几乎是不可能获得的。因此，设计一个在模型不确定性存在时依然表现良好的控制器是一项关键的工程任务。这个高级练习介绍了一种基于凸优化的现代鲁棒设计方法 [@problem_id:2708558]，您将构建并求解一个优化问题，以设计一个能在一定参数范围内最小化最坏情况残余振动的输入整形器，从而掌握一种应对真实世界挑战的强大工具。", "problem": "考虑一个单模线性时不变 (LTI) 系统，其主导柔性动力学可以由一个二阶振荡器很好地近似，该振荡器具有未知的固有频率和阻尼比，由以下连续时间常微分方程建模：\n$$\n\\ddot{x}(t) + 2 \\zeta \\omega_n \\dot{x}(t) + \\omega_n^2 x(t) = u(t),\n$$\n其中 $x(t)$ 是模态位移，$u(t)$ 是输入，$\\omega_n$ 是以弧度/秒为单位的固有频率，$\\zeta$ 是阻尼比。一个长度为 $N$、采样周期为 $T_s$ 的有限脉冲响应 (FIR) 前馈 $h[k]$ 用于在施加到系统之前整形单位阶跃指令。该 FIR 是因果的，意味着对于所有 $k  0$，$h[k] = 0$；并且是非负的，意味着对于 $k = 0,1,\\dots,N-1$，$h[k] \\ge 0$。单位稳态跟踪由以下线性约束强制执行：\n$$\n\\sum_{k=0}^{N-1} h[k] = 1.\n$$\n\n当整形后的输入由在时间 $t_k = k T_s$ 处幅值为 $h[k]$ 的非负脉冲组成时，与欠阻尼模态相关的残余振动幅值由每个脉冲引起的衰减正弦波的线性叠加决定。对于给定的 $(\\omega_n,\\zeta)$ 且 $\\zeta \\in [0,1)$，阻尼固有频率为：\n$$\n\\omega_d = \\omega_n \\sqrt{1 - \\zeta^2},\n$$\n整形后输入引起的残余振动量级可以表示为 FIR 系数的复仿射函数的模：\n$$\nR(\\omega_n,\\zeta; h) = \\left| \\sum_{k=0}^{N-1} h[k] \\, e^{-\\zeta \\omega_n t_k} \\, e^{-j \\omega_d t_k} \\right|.\n$$\n此表达式源于脉冲序列与系统模态响应的卷积，使用了叠加原理和二阶系统的标准齐次解。\n\n您需要通过对不确定性进行网格化，为 $(\\omega_n,\\zeta)$ 的不确定性集合建立并求解一个离散时间的凸最坏情况设计问题。决策变量是 FIR 系数 $h[0],\\dots,h[N-1]$ 和一个作为最坏情况残余幅值上界的铭图变量 $t \\ge 0$。不确定性集合被指定为一个矩形区域：\n$$\n\\mathcal{U} = \\{ (\\omega_n,\\zeta) \\mid \\omega_n \\in [\\omega_{\\min}, \\omega_{\\max}], \\; \\zeta \\in [\\zeta_{\\min}, \\zeta_{\\max}] \\},\n$$\n您必须通过一个笛卡尔积网格来近似该集合，该网格由在 $[\\omega_{\\min}, \\omega_{\\max}]$ 中均匀分布的 $n_\\omega$ 个点和在 $[\\zeta_{\\min}, \\zeta_{\\max}]$ 中均匀分布的 $n_\\zeta$ 个点组成。对于每个网格点 $(\\omega_n,\\zeta)$，施加二阶锥约束：\n$$\n\\left\\| \n\\begin{bmatrix}\n\\Re \\left\\{ \\sum_{k=0}^{N-1} h[k] \\, e^{-\\zeta \\omega_n t_k} \\, e^{-j \\omega_d t_k} \\right\\} \\\\\n\\Im \\left\\{ \\sum_{k=0}^{N-1} h[k] \\, e^{-\\zeta \\omega_n t_k} \\, e^{-j \\omega_d t_k} \\right\\}\n\\end{bmatrix}\n\\right\\|_2 \\le t,\n$$\n同时还有非负性约束 $h[k] \\ge 0$，由有限支撑 $k=0,\\dots,N-1$ 强制执行的因果性，以及单位增益约束 $\\sum_{k=0}^{N-1} h[k] = 1$。这得到了一个二阶锥规划 (SOCP) 形式的凸优化问题。\n\n您的任务是实现一个程序，对于下面指定的每个测试用例，构建不确定性网格，按所述建立凸优化问题，并计算最小化的最坏情况残余幅值：\n$$\nt^\\star = \\min_{h[0],\\dots,h[N-1], \\, t} \\; t \\quad \\text{在所有网格点上满足上述约束。}\n$$\n\n对于每个测试用例，程序必须返回最优最坏情况残余幅值 $t^\\star$ 作为一个浮点数。\n\n使用以下测试套件。所有时间单位为秒，所有角频率单位为弧度/秒。角度单位默认为弧度。\n\n- 案例1 (一般情况，轻阻尼，中等网格):\n  - $N = 5$, $T_s = 0.02$\n  - $\\omega_{\\min} = 8.0$, $\\omega_{\\max} = 12.0$\n  - $\\zeta_{\\min} = 0.01$, $\\zeta_{\\max} = 0.05$\n  - 网格大小: $n_\\omega = 7$, $n_\\zeta = 3$\n\n- 案例2 (边界情况，无不确定性):\n  - $N = 3$, $T_s = 0.05$\n  - $\\omega_{\\min} = \\omega_{\\max} = 10.0$\n  - $\\zeta_{\\min} = \\zeta_{\\max} = 0.02$\n  - 网格大小: $n_\\omega = 1$, $n_\\zeta = 1$\n\n- 案例3 (更宽频率范围，包含零阻尼):\n  - $N = 7$, $T_s = 0.01$\n  - $\\omega_{\\min} = 5.0$, $\\omega_{\\max} = 15.0$\n  - $\\zeta_{\\min} = 0.0$, $\\zeta_{\\max} = 0.10$\n  - 网格大小: $n_\\omega = 7$, $n_\\zeta = 3$\n\n附加要求和说明:\n- 将 $t_k$ 解释为 $k T_s$，其中 $k=0,1,\\dots,N-1$。\n- 对于 $\\zeta \\ge 1$ (这在测试套件中不会出现)，为完整性起见，定义 $\\omega_d = 0$，但您在这里不需要用到这种情况。\n- 程序必须独立求解每个案例，并输出三个最优值 $t^\\star$。\n\n最终输出格式:\n- 您的程序应生成单行输出，其中包含结果，形式为逗号分隔的三个浮点数列表，按上述案例的顺序排列，四舍五入到六位小数，并用方括号括起来。例如：\"[0.123456,0.234567,0.345678]\"。", "solution": "问题陈述经评估有效。这是一个适定的、有科学依据的鲁棒前馈控制设计问题，被构建为一个凸优化问题。所提供的数据和约束是完整、一致的，能够得到唯一且有意义的解。没有违反科学原理或数学逻辑的地方。\n\n任务是设计一个有限脉冲响应 (FIR) 滤波器，由其系数 $h[k]$（其中 $k \\in \\{0, 1, \\dots, N-1\\}$）表示，以最小化二阶系统在系统固有频率 $\\omega_n$ 和阻尼比 $\\zeta$ 的指定不确定性集合上的最坏情况残余振动。这是振动控制中输入整形的一个经典问题。\n\n该优化问题可以构建为一个二阶锥规划 (SOCP)。决策变量是 $N$ 个滤波器系数 $h[k]$ 和一个辅助铭图变量 $t$。优化变量向量为 $\\mathbf{x} = [h[0], h[1], \\dots, h[N-1], t]^T \\in \\mathbb{R}^{N+1}$。\n\n目标是最小化最坏情况残余振动幅值，这由铭图变量 $t$ 来表示。因此，目标函数是：\n$$\n\\min_{\\mathbf{x}} t\n$$\n这是一个线性目标函数 $f(\\mathbf{x}) = \\mathbf{c}^T \\mathbf{x}$，其中 $\\mathbf{c} = [0, \\dots, 0, 1]^T$。\n\n优化变量的约束如下：\n\n1.  **单位直流增益**：FIR 滤波器必须对阶跃输入有单位稳态响应，这转化为对系数的线性等式约束：\n    $$\n    \\sum_{k=0}^{N-1} h[k] = 1\n    $$\n    用矩阵形式表示，这是 $\\mathbf{A}_{eq} \\mathbf{x} = \\mathbf{b}_{eq}$，其中 $\\mathbf{A}_{eq} = [1, 1, \\dots, 1, 0]$ (一个 $1 \\times (N+1)$ 的行向量) 且 $\\mathbf{b}_{eq} = [1]$。\n\n2.  **非负性**：滤波器系数必须为非负，铭图变量 $t$ 也必须为非负。这些是变量的箱型约束：\n    $$\n    h[k] \\ge 0 \\quad \\text{对于 } k = 0, \\dots, N-1\n    $$\n    $$\n    t \\ge 0\n    $$\n    注意，单位增益约束与非负性约束相结合，意味着 $0 \\le h[k] \\le 1$。\n\n3.  **最坏情况残余振动**：问题的核心在于在离散化的不确定性集合上约束残余振动。不确定性集合 $\\mathcal{U} = [\\omega_{\\min}, \\omega_{\\max}] \\times [\\zeta_{\\min}, \\zeta_{\\max}]$ 被离散化为一个包含 $M = n_\\omega \\times n_\\zeta$ 个点的网格，记为 $(\\omega_{n,i}, \\zeta_i)$，其中 $i=1, \\dots, M$。对于该网格上的每个点，残余振动量级必须小于或等于 $t$。\n    残余量级由 $R_i = \\left| \\sum_{k=0}^{N-1} h[k] v_{i,k} \\right|$ 给出，其中 $v_{i,k}$ 是一个复数，表示系统在时间 $t_k = k T_s$ 对脉冲的响应：\n    $$\n    v_{i,k} = e^{-\\zeta_i \\omega_{n,i} t_k} e^{-j \\omega_{d,i} t_k}\n    $$\n    其中 $\\omega_{d,i} = \\omega_{n,i} \\sqrt{1 - \\zeta_i^2}$。\n    每个网格点 $i$ 的约束是 $R_i \\le t$。这可以表示为一个二阶锥约束：\n    $$\n    \\sqrt{ \\left( \\sum_{k=0}^{N-1} h[k] \\Re\\{v_{i,k}\\} \\right)^2 + \\left( \\sum_{k=0}^{N-1} h[k] \\Im\\{v_{i,k}\\} \\right)^2 } \\le t\n    $$\n    这 $M$ 个约束确保了 $t$ 是对于所有测试的参数组合的残余量级的上界。由于这些约束必须对所有 $i \\in \\{1, \\dots, M\\}$ 成立， $t$ 成为网格上最坏情况（最大）残余的上界。\n\n最终的优化问题是一个凸 SOCP。我们将使用 Python 的 `scipy.optimize.minimize` 函数和 `SLSQP` (序列最小二乘规划) 求解器来实现一个解决方案，该求解器适用于一般的非线性约束优化问题。问题的凸性确保了 `SLSQP` 会找到全局最小值。\n\n每个测试用例的实现过程如下：\n1.  **问题构建**：使用 `numpy.linspace` 为 $\\omega_n$ 和 $\\zeta$ 构建不确定性网格。预先计算一个维度为 $M \\times N$ 的复数值矩阵 $\\mathbf{V}$，其元素为 $v_{i,k}$。然后将该矩阵分解为其的实部和虚部，$\\mathbf{V}_{re}$ 和 $\\mathbf{V}_{im}$。\n2.  **优化问题构建**：\n    - 定义大小为 $N+1$ 的优化变量向量 $\\mathbf{x}$。\n    - 目标函数被设置为返回 $\\mathbf{x}$ 的最后一个元素，即 $t$。\n    - 构建一个初始猜测值。$\\mathbf{h}$ 的均匀分布（即 $h[k] = 1/N$）是一个合理的起点。然后将初始 $t_0$ 设置为该初始 $\\mathbf{h}$ 的最坏情况残余。\n    - 为每个变量指定边界：$h[k] \\in [0, 1]$ 和 $t \\in [0, \\infty)$。\n    - 将单位增益约束构建为 `LinearConstraint`。\n    - 使用单个 `NonlinearConstraint` 对象构建 $M$ 个 SOC 约束。该对象被给定一个函数，用于计算所有 $i$ 的约束值向量 $g_i(\\mathbf{x}) = t - R_i(\\mathbf{h})$。约束为 $g_i(\\mathbf{x}) \\ge 0$。为了提高求解器的性能和可靠性，还提供了约束函数的雅可比矩阵。$g_i$ 关于 $\\mathbf{h}$ 和 $t$ 的雅可比矩阵是：\n      $$\n      \\nabla_{\\mathbf{h}} g_i = -\\frac{ (\\Re\\{\\mathbf{v}_i^T \\mathbf{h}\\}) \\Re\\{\\mathbf{v}_i\\}^T + (\\Im\\{\\mathbf{v}_i^T \\mathbf{h}\\}) \\Im\\{\\mathbf{v}_i\\}^T }{ \\left| \\mathbf{v}_i^T \\mathbf{h} \\right| }, \\quad \\frac{\\partial g_i}{\\partial t} = 1\n      $$\n      其中 $\\mathbf{v}_i$ 是 $\\mathbf{V}$ 的第 $i$ 行。注意处理分母为零的情况。\n3.  **求解**：使用这些组件调用 `minimize` 函数。从结果中提取目标函数的最优值 $t^\\star$。对每个测试用例重复此过程，并按指定格式化最终结果。", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import minimize, LinearConstraint, NonlinearConstraint\n\ndef solve_case(N, Ts, w_min, w_max, z_min, z_max, n_w, n_z):\n    \"\"\"\n    Formulates and solves the convex optimization problem for one test case.\n    \"\"\"\n    # 1. Construct the uncertainty grid and the complex coefficient matrix V\n    omegas = np.linspace(w_min, w_max, n_w)\n    zetas = np.linspace(z_min, z_max, n_z)\n    grid_points = np.array(np.meshgrid(omegas, zetas)).T.reshape(-1, 2)\n    M = len(grid_points)\n    times = np.arange(N) * Ts\n\n    V_matrix = np.zeros((M, N), dtype=np.complex128)\n    for i, (wn, zeta) in enumerate(grid_points):\n        # We are guaranteed zeta  1 by the problem statement.\n        wd = wn * np.sqrt(1 - zeta**2)\n        for k, tk in enumerate(times):\n            exponent = complex(-zeta * wn * tk, -wd * tk)\n            V_matrix[i, k] = np.exp(exponent)\n\n    V_re = np.real(V_matrix)\n    V_im = np.imag(V_matrix)\n\n    # 2. Define the optimization problem for scipy.optimize.minimize\n    # Optimization variables: x = [h_0, ..., h_{N-1}, t]\n    \n    # Objective function\n    def obj_fun(x):\n        return x[-1]\n\n    # Initial guess\n    h0 = np.ones(N) / N\n    real_parts_0 = V_re @ h0\n    imag_parts_0 = V_im @ h0\n    mags_0 = np.sqrt(real_parts_0**2 + imag_parts_0**2)\n    t0 = np.max(mags_0) if mags_0.size > 0 else 1.0\n    x0 = np.append(h0, t0)\n\n    # Bounds on variables: 0 = h[k] = 1, 0 = t\n    bounds = [(0.0, 1.0)] * N + [(0.0, None)]\n\n    # Equality constraint: sum(h) = 1\n    A_eq = np.append(np.ones(N), 0.0).reshape(1, N + 1)\n    eq_constraint = LinearConstraint(A_eq, 1.0, 1.0)\n\n    # SOC constraints: t - |V*h| >= 0 for each grid point\n    def soc_con_fun(x):\n        h = x[:-1]\n        t = x[-1]\n        real_parts = V_re @ h\n        imag_parts = V_im @ h\n        mags = np.sqrt(real_parts**2 + imag_parts**2)\n        return t - mags\n\n    def soc_con_jac(x):\n        h = x[:-1]\n        t = x[-1] # noqa: F841\n        real_parts = V_re @ h\n        imag_parts = V_im @ h\n        mags = np.sqrt(real_parts**2 + imag_parts**2)\n        \n        jac_h = np.zeros((M, N))\n        \n        # Mask for non-zero magnitudes to avoid division by zero\n        nonzero_mag_idx = mags > 1e-12\n        \n        if np.any(nonzero_mag_idx):\n            mags_safe = mags[nonzero_mag_idx]\n            num_h = -(real_parts[nonzero_mag_idx, np.newaxis] * V_re[nonzero_mag_idx, :] +\n                      imag_parts[nonzero_mag_idx, np.newaxis] * V_im[nonzero_mag_idx, :])\n            jac_h[nonzero_mag_idx, :] = num_h / mags_safe[:, np.newaxis]\n            \n        jac_t = np.ones((M, 1))\n        \n        return np.hstack((jac_h, jac_t))\n\n    soc_constraint = NonlinearConstraint(soc_con_fun, 0, np.inf, jac=soc_con_jac)\n\n    # 3. Solve the optimization problem\n    result = minimize(obj_fun, x0, method='SLSQP',\n                      bounds=bounds,\n                      constraints=[eq_constraint, soc_constraint],\n                      options={'ftol': 1e-10, 'maxiter': 500})\n                      \n    return result.fun\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        # Case 1 (general, lightly damped, moderate grid):\n        {'N': 5, 'Ts': 0.02, 'w_min': 8.0, 'w_max': 12.0, 'z_min': 0.01, 'z_max': 0.05, 'n_w': 7, 'n_z': 3},\n        # Case 2 (boundary, no uncertainty):\n        {'N': 3, 'Ts': 0.05, 'w_min': 10.0, 'w_max': 10.0, 'z_min': 0.02, 'z_max': 0.02, 'n_w': 1, 'n_z': 1},\n        # Case 3 (wider frequency range, includes zero damping):\n        {'N': 7, 'Ts': 0.01, 'w_min': 5.0, 'w_max': 15.0, 'z_min': 0.0, 'z_max': 0.10, 'n_w': 7, 'n_z': 3}\n    ]\n    \n    results = []\n    for case in test_cases:\n        t_star = solve_case(case['N'], case['Ts'], case['w_min'], case['w_max'],\n                            case['z_min'], case['z_max'], case['n_w'], case['n_z'])\n        results.append(t_star)\n\n    results_formatted = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(results_formatted)}]\")\n\nsolve()\n```", "id": "2708558"}]}