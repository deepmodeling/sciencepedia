{"hands_on_practices": [{"introduction": "Betti 倒易定理不仅是一个深刻的理论结果，也是一个强大的工程计算工具。本练习旨在通过一个实例，展示如何巧妙地利用该定理来求解复杂结构中的位移。通过构建一个简单的辅助载荷状态，我们可以避免直接求解真实载荷下复杂的边值问题，从而大大简化计算过程。", "problem": "一根细长的棱柱形线性弹性杆占据一维区域 $x \\in [0,L]$。其轴向位移为 $u(x)$，轴向力为 $N(x)$，杨氏模量为 $E$，横截面积为 $A$。这些量均为常数，除了在位于 $x=a$ 处传感器周围的一个对称凹槽邻域内，该处的局部轴向刚度有所降低。具体来说，在区间 $x \\in [a-c,\\,a+c]$ 内，有效乘积为 $E A \\to \\eta E A$（其中 $0<\\eta<1$），而在此区间外，刚度为 $E A$。假设 $0<c<\\min\\{a,\\,L-a\\}$，以确保凹槽完全位于杆的内部。左端被固定，$u(0)=0$，右端无牵引力，$N(L)=0$。在整个区间 $[0,L]$ 上，该杆承受一个沿 $+x$ 方向的均匀轴向体力密度 $b_0$（单位长度上的力）。没有施加其他外力。\n\n位于 $x=a$ 处的位移传感器记录了轴向位移 $u(a)$。请您利用 Betti 互易定理来确定 $u(a)$，并使用同一带凹槽杆在 $x=a$ 处沿 $+x$ 方向施加单位轴向点力时的响应作为辅助状态。请从一维线性弹性和平衡的基本陈述（包括定义 $N(x)=E A(x)\\,u'(x)$ 和 $N'(x) + b(x) = 0$）出发，并使用 Clapeyron 的总应变能定理来证明 Betti 恒等式所需的互易性。在不引用预制影响函数的情况下推导辅助位移场 $u^{(2)}(x)$，并计算 Betti 关系式以提取真实载荷下的 $u(a)$。\n\n请以关于 $L$、$a$、$c$、$\\eta$、$E$、$A$ 和 $b_0$ 的单个闭式解析表达式的形式给出您的最终答案。位移以米为单位表示。不要代入数值。", "solution": "所述问题在一维线性弹性框架内是一个适定的探究。该问题是自洽的、一致的，且有科学依据。它不违反任何基本原则，并包含了获得唯一解所需的所有信息。因此，将提供一个解。\n\n该问题要求使用 Betti 互易定理来求解非均匀杆中某点 $x=a$ 在体力作用下的位移。这需要为同一个弹性体定义两种载荷和响应状态。\n\n首先，按照要求，使用 Clapeyron 定理建立 Betti 定理的理论基础。考虑施加在同一个线性弹性体上的两个独立载荷系统，用上标 $(1)$ 和 $(2)$ 表示。该物体的特性由其刚度分布 $K(x) = E A(x)$ 定义。每个载荷系统都包含体力 $b(x)$ 和边界牵引力，从而产生位移场 $u(x)$、应变场 $\\epsilon(x) = u'(x)$ 和应力场 $N(x) = K(x)\\epsilon(x)$。\n\n叠加状态 $(1+2)$ 的总应变能为 $U_{1+2} = \\frac{1}{2}\\int_0^L N^{(1+2)}\\epsilon^{(1+2)} dx$。由于线性性质，$N^{(1+2)} = N^{(1)} + N^{(2)}$ 且 $\\epsilon^{(1+2)} = \\epsilon^{(1)} + \\epsilon^{(2)}$。\n展开能量表达式得到：\n$$U_{1+2} = \\frac{1}{2}\\int_0^L (N^{(1)} + N^{(2)})(\\epsilon^{(1)} + \\epsilon^{(2)}) dx = U_1 + U_2 + \\int_0^L N^{(1)}\\epsilon^{(2)} dx$$\n其中 $U_1 = \\frac{1}{2}\\int_0^L N^{(1)}\\epsilon^{(1)} dx$ 和 $U_2 = \\frac{1}{2}\\int_0^L N^{(2)}\\epsilon^{(2)} dx$ 分别是单个状态的应变能。相互作用能项为 $U_{12} = \\int_0^L N^{(1)}\\epsilon^{(2)} dx$。因为本构关系是线性的，$N^{(1)} = K(x)\\epsilon^{(1)}$，相互作用能可以写成 $\\int_0^L K(x)\\epsilon^{(1)}\\epsilon^{(2)} dx$。这种形式的对称性意味着 $\\int_0^L N^{(1)}\\epsilon^{(2)} dx = \\int_0^L N^{(2)}\\epsilon^{(1)} dx$。\n\n外力所做的功为 $W_{ext}$。对于叠加状态，$W_{ext}^{(1+2)} = W_{ext}^{(1)} + W_{ext}^{(2)} + W_{12} + W_{21}$，其中 $W_{12}$ 是状态 $(1)$ 的力在状态 $(2)$ 的位移上做的功，而 $W_{21}$ 是状态 $(2)$ 的力在状态 $(1)$ 的位移上做的功。\nClapeyron 定理指出 $W_{ext} = 2U$。将此应用于状态 $(1)$、$(2)$ 和 $(1+2)$：\n$W_{ext}^{(1)} = 2U_1$，$W_{ext}^{(2)} = 2U_2$，以及 $W_{ext}^{(1+2)} = 2U_{1+2}$。\n将这些代入展开的功表达式中：\n$$2U_1 + 2U_2 + W_{12} + W_{21} = 2(U_1 + U_2 + \\int_0^L N^{(1)}\\epsilon^{(2)} dx)$$\n这可以简化为 $W_{12} + W_{21} = 2 \\int_0^L N^{(1)}\\epsilon^{(2)} dx$。\n虚功原理指出外力功等于内力功（应变能变化）。因此，$W_{12} = \\int_0^L N^{(1)}\\epsilon^{(2)} dx$。\n代入此结果可得 $W_{12} + W_{21} = 2 W_{12}$，从而得到 Betti 互易定理：$W_{12} = W_{21}$。\n\n我们为这个问题定义两种状态：\n**状态 1 (真实状态):**\n- 载荷：均匀体力 $b^{(1)}(x) = b_0$。\n- 边界条件：$u^{(1)}(0) = 0$, $N^{(1)}(L) = 0$。\n- 产生的场：$u^{(1)}(x)$，$N^{(1)}(x)$。待求量为 $u^{(1)}(a)$。\n\n**状态 2 (辅助状态):**\n- 载荷：位于 $x=a$ 处的单位点力，表示为体力 $b^{(2)}(x) = \\delta(x-a)$，其中 $\\delta$ 是 Dirac δ 函数。\n- 边界条件：$u^{(2)}(0) = 0$, $N^{(2)}(L) = 0$。\n- 产生的场：$u^{(2)}(x)$，$N^{(2)}(x)$。\n\n功的表达式为：\n$W_{12} = \\int_0^L b^{(1)}(x) u^{(2)}(x) dx + [N^{(1)}(x) u^{(2)}(x)]_0^L$\n$W_{21} = \\int_0^L b^{(2)}(x) u^{(1)}(x) dx + [N^{(2)}(x) u^{(1)}(x)]_0^L$\n\n根据指定条件计算这些项：\n对于 $W_{12}$：$[N^{(1)}(x) u^{(2)}(x)]_0^L = N^{(1)}(L)u^{(2)}(L) - N^{(1)}(0)u^{(2)}(0) = (0)u^{(2)}(L) - N^{(1)}(0)(0) = 0$。\n因此，$W_{12} = \\int_0^L b_0 u^{(2)}(x) dx = b_0 \\int_0^L u^{(2)}(x) dx$。\n\n对于 $W_{21}$：$\\int_0^L b^{(2)}(x) u^{(1)}(x) dx = \\int_0^L \\delta(x-a) u^{(1)}(x) dx = u^{(1)}(a)$。\n边界项为 $[N^{(2)}(x) u^{(1)}(x)]_0^L = N^{(2)}(L)u^{(1)}(L) - N^{(2)}(0)u^{(1)}(0) = (0)u^{(1)}(L) - N^{(2)}(0)(0) = 0$。\n因此，$W_{21} = u^{(1)}(a)$。\n\n令 $W_{12} = W_{21}$ 相等，得到中心关系式：\n$$u^{(1)}(a) = b_0 \\int_0^L u^{(2)}(x) dx$$\n\n问题现在简化为求解辅助位移场 $u^{(2)}(x)$ 并在定义域上对其进行积分。\n对于状态 2，轴向力 $N^{(2)}(x)$ 的平衡方程为 $N^{(2)'}(x) + b^{(2)}(x) = 0$，即 $N^{(2)'}(x) = -\\delta(x-a)$。\n从 $x$ 积分到 $L$：$\\int_x^L N^{(2)'}(\\xi) d\\xi = -\\int_x^L \\delta(\\xi-a) d\\xi$。\n如果 $x < a < L$，则 $N^{(2)}(L) - N^{(2)}(x) = -1$；如果 $a < x < L$，则为 $0$。\n由于 $N^{(2)}(L)=0$，我们得到当 $x<a$ 时 $N^{(2)}(x) = 1$，当 $x>a$ 时 $N^{(2)}(x)=0$。\n\n位移 $u^{(2)}(x)$ 可以通过对应变 $u^{(2)'}(x) = N^{(2)}(x)/K(x)$ 积分求得，并满足边界条件 $u^{(2)}(0)=0$。刚度 $K(x)$ 是分段的：\n$$K(x) = \\begin{cases} EA & 0 \\le x < a-c \\\\ \\eta EA & a-c \\le x < a+c \\\\ EA & a+c \\le x \\le L \\end{cases}$$\n我们分段积分 $u^{(2)'}(x)$：\n- 对于 $0 \\le x < a-c$：$u^{(2)'}(x) = \\frac{1}{EA}$。$u^{(2)}(x) = \\frac{x}{EA}$。\n- 对于 $a-c \\le x < a$：$u^{(2)'}(x) = \\frac{1}{\\eta EA}$。$u^{(2)}(x) = u^{(2)}(a-c) + \\int_{a-c}^x \\frac{d\\xi}{\\eta EA} = \\frac{a-c}{EA} + \\frac{x-(a-c)}{\\eta EA}$。\n- 对于 $a \\le x \\le L$：$u^{(2)'}(x) = \\frac{0}{K(x)} = 0$。对于 $x \\ge a$，$u^{(2)}(x)$ 是常数。其值为 $u^{(2)}(a)$。\n$u^{(2)}(a) = u^{(2)}_{x \\to a^-} = \\frac{a-c}{EA} + \\frac{a-(a-c)}{\\eta EA} = \\frac{1}{EA}\\left(a-c + \\frac{c}{\\eta}\\right)$。因此，对于 $x \\ge a$，$u^{(2)}(x) = \\frac{1}{EA}\\left(a-c+\\frac{c}{\\eta}\\right)$。\n\n所需积分 $I = \\int_0^L u^{(2)}(x) dx$ 通过叠加法计算。令 $u^{(2)}(x) = u^{(2)}_{unif}(x) + \\Delta u^{(2)}(x)$，其中 $u^{(2)}_{unif}(x)$ 是均匀杆（$\\eta=1, c=0$）的解，$\\Delta u^{(2)}(x)$ 是由凹槽引起的附加位移。\n对于均匀杆，$u^{(2)}_{unif}(x) = \\frac{1}{EA}\\min(x,a)$。积分为：\n$I_{unif} = \\int_0^L u^{(2)}_{unif}(x) dx = \\int_0^a \\frac{x}{EA} dx + \\int_a^L \\frac{a}{EA} dx = \\frac{1}{EA}\\left[\\frac{a^2}{2} + a(L-a) \\right] = \\frac{a(2L-a)}{2EA}$。\n\n附加位移 $\\Delta u^{(2)}(x)$ 仅在 $x > a-c$ 时非零：\n- 对于 $a-c \\le x < a$：$\\Delta u^{(2)}(x) = u^{(2)}(x) - u^{(2)}_{unif}(x) = \\frac{1}{EA}\\left(a-c+\\frac{x-a+c}{\\eta} - x\\right) = \\frac{x-a+c}{EA}\\left(\\frac{1}{\\eta}-1\\right)$。\n- 对于 $x \\ge a$：$\\Delta u^{(2)}(x) = u^{(2)}(x) - u^{(2)}_{unif}(x) = \\frac{1}{EA}\\left(a-c+\\frac{c}{\\eta} - a\\right) = \\frac{c}{EA}\\left(\\frac{1}{\\eta}-1\\right)$。\n\n附加位移的积分为：\n$\\Delta I = \\int_{a-c}^a \\frac{x-a+c}{EA}\\left(\\frac{1}{\\eta}-1\\right) dx + \\int_a^L \\frac{c}{EA}\\left(\\frac{1}{\\eta}-1\\right) dx$\n$\\Delta I = \\frac{1}{EA}\\left(\\frac{1}{\\eta}-1\\right) \\left[ \\int_{a-c}^a (x-a+c) dx + \\int_a^L c \\,dx \\right]$\n$\\Delta I = \\frac{1}{EA}\\left(\\frac{1}{\\eta}-1\\right) \\left[ \\left[\\frac{(x-a+c)^2}{2}\\right]_{a-c}^a + [cx]_a^L \\right]$\n$\\Delta I = \\frac{1}{EA}\\left(\\frac{1}{\\eta}-1\\right) \\left[ \\frac{c^2}{2} + c(L-a) \\right] = \\frac{c}{EA}\\left(\\frac{1}{\\eta}-1\\right)\\left(L-a+\\frac{c}{2}\\right)$。\n\n总积分为 $I = I_{unif} + \\Delta I$：\n$$I = \\frac{1}{EA}\\left[ \\frac{a(2L-a)}{2} + c\\left(\\frac{1}{\\eta}-1\\right)\\left(L-a+\\frac{c}{2}\\right) \\right]$$\n\n最后，传感器处的位移为 $u^{(1)}(a) = u(a) = b_0 I$。该表达式的单位在量纲上是正确的长度单位，如果所有输入量均采用一致的国际单位制（SI）单位，则该位移将以米表示。\n$$u(a) = \\frac{b_0}{EA}\\left[ \\frac{a(2L-a)}{2} + c\\left(\\frac{1}{\\eta}-1\\right)\\left(L-a+\\frac{c}{2}\\right) \\right]$$", "answer": "$$\\boxed{\\frac{b_0}{EA} \\left[ \\frac{a(2L-a)}{2} + c \\left( \\frac{1}{\\eta} - 1 \\right) \\left( L - a + \\frac{c}{2} \\right) \\right]}$$", "id": "2618422"}, {"introduction": "Clapeyron 定理和 Betti 定理的成立依赖于特定的假设，其中线性是关键之一。本练习将引导你探索一个非线性超弹性系统，以揭示这些经典定理的适用边界。你将发现，尽管 Clapeyron 定理中简洁的能量公式 $U = \\frac{1}{2}\\mathbf{P}\\cdot\\mathbf{u}$ 在非线性情况下失效，但对于保守系统，其增量形式的倒易性依然成立。", "problem": "考虑一个具有广义位移 $u_1$ 和 $u_2$ 的一维两自由度弹性系统。每个节点通过刚度为 $k$ 的线性弹簧接地，两个节点由一个超弹性耦合元件连接，其储存能根据相对位移 $d = u_1 - u_2$ 由 $W_c(d) = \\dfrac{c}{4}\\,d^4$ 给出，其中 $c>0$ 是一个材料参数。因此，总内应变能为\n$$U_{\\text{int}}(u_1,u_2) = \\dfrac{k}{2}\\,u_1^2 + \\dfrac{k}{2}\\,u_2^2 + \\dfrac{c}{4}\\,(u_1 - u_2)^4.$$\n两个点荷载 $P_1$ 和 $P_2$ 分别作用于节点上，方向为正 $u_1$ 和 $u_2$ 方向。荷载在等温、率无关的条件下，通过两个连续阶段准静态地施加：\n- 阶段 1：$P_1$ 从 0 增加到 5，同时 $P_2=0$。\n- 阶段 2：$P_2$ 从 0 增加到 1，同时 $P_1$ 保持在 5 不变。\n假设在一致单位（牛顿和米）下 $k=2$ 和 $c=1$，并假设应变足够小，使得上述超弹性储存能表达式始终有效，但允许大位移，因此不采用几何线性化。\n\n任务：\n- 从总势能驻值原理和保守功的定义出发，推导阶段 2 结束时的平衡条件，并求解最终位移 $u_1$ 和 $u_2$。\n- 仅使用第一性原理（功能平衡和力-位移关系的积分），计算沿指定顺序路径施加的荷载所做的总外功 $W_{\\text{seq}}$ 以及最终平衡状态下的内应变能 $U_{\\text{int}}$。\n- 考虑诊断量\n$$U_C = \\dfrac{1}{2}\\big(P_1 u_1 + P_2 u_2\\big) \\quad \\text{在最终平衡荷载和位移下求值。}$$\n计算最终平衡状态下的标量差 $\\Delta = U_C - U_{\\text{int}}$，并结合 Clapeyron 定理归属的经典功公式在这种非线性情况下的适用性，解释其符号。\n- 围绕最终平衡构型，通过对内力关于 $(u_1,u_2)$ 微分，构建对称切线刚度，并用它来评估由单位探测试探荷载产生的两个增量位移：节点 1 处单位荷载引起的 $\\delta u^{(1)}_2$，以及节点 2 处单位荷载引起的 $\\delta u^{(2)}_1$。讨论对于这些小扰动，Maxwell–Betti 互易性在此超弹性系统中是否成立。\n\n你最终报告的量必须是单个标量 $\\Delta$，单位为焦耳。将你的答案四舍五入到 $4$ 位有效数字，并以 $\\mathrm{J}$ 表示。", "solution": "对问题陈述进行验证。\n\n**步骤 1：提取已知条件**\n- 系统：一维、两自由度弹性系统。\n- 广义位移：$u_1$, $u_2$。\n- 内应变能：$U_{\\text{int}}(u_1,u_2) = \\dfrac{k}{2}\\,u_1^2 + \\dfrac{k}{2}\\,u_2^2 + \\dfrac{c}{4}\\,(u_1 - u_2)^4$。\n- 施加荷载：$P_1$, $P_2$。\n- 加载路径：\n  - 阶段 1：$P_1$ 从 0 增加到 5，同时 $P_2=0$。\n  - 阶段 2：$P_2$ 从 0 增加到 1，同时 $P_1$ 保持在 5 不变。\n- 常数：$k=2$, $c=1$，单位为一致的 SI 单位（N, m, J）。\n- 假设：过程是准静态、等温且率无关的。材料是超弹性的。允许大位移，但应变很小。\n- 任务：\n  1. 找到最终平衡位移 $(u_1, u_2)$。\n  2. 计算总外功 $W_{\\text{seq}}$ 和最终内能 $U_{\\text{int}}$。\n  3. 计算并解释 $\\Delta = U_C - U_{\\text{int}}$，其中 $U_C = \\dfrac{1}{2}(P_1 u_1 + P_2 u_2)$。\n  4. 分析最终平衡状态附近的增量互易性 (Maxwell-Betti)。\n- 要求输出：标量值 $\\Delta$。\n\n**步骤 2：使用提取的已知条件进行验证**\n- **科学基础**：该问题在连续介质力学和变分原理方面有坚实的基础。它描述了一个具有非线性势能的超弹性系统，这是高等力学中的一个标准课题。能量函数在物理上是合理的，代表了接地的线性弹簧和一个非线性刚化耦合。\n- **适定性**：该问题是适定的。所提供的信息足以确定一个唯一的平衡状态。势能函数的构造确保了稳定解的存在。\n- **客观性**：问题以精确、客观和定量的术语陈述。没有主观或模糊的陈述。\n\n**步骤 3：结论与行动**\n该问题在科学上是合理的、自洽的且适定的。这是一个有效的非线性固体力学问题。我将继续进行求解。\n\n**平衡状态的推导**\n系统的总势能 $\\Pi$ 是内应变能 $U_{\\text{int}}$ 和外荷载势能 $W_{\\text{ext}} = - (P_1 u_1 + P_2 u_2)$ 的和。\n$$ \\Pi(u_1, u_2) = U_{\\text{int}} - W_{\\text{ext}} = \\dfrac{k}{2}\\,u_1^2 + \\dfrac{k}{2}\\,u_2^2 + \\dfrac{c}{4}\\,(u_1 - u_2)^4 - P_1 u_1 - P_2 u_2 $$\n总势能驻值原理指出，为达到平衡，$\\Pi$ 的一次变分必须为零，这意味着其对广义坐标的偏导数必须为零。\n$$ \\dfrac{\\partial \\Pi}{\\partial u_1} = k u_1 + c(u_1 - u_2)^3 - P_1 = 0 $$\n$$ \\dfrac{\\partial \\Pi}{\\partial u_2} = k u_2 - c(u_1 - u_2)^3 - P_2 = 0 $$\n这些是平衡方程，可以写成施加力的表达式：\n$$ P_1 = k u_1 + c(u_1 - u_2)^3 $$\n$$ P_2 = k u_2 - c(u_1 - u_2)^3 $$\n在阶段 2 结束时，荷载为 $P_1=5$ 和 $P_2=1$。常数为 $k=2$ 和 $c=1$。最终位移 $(u_1, u_2)$ 的方程组为：\n$$ 5 = 2 u_1 + (u_1 - u_2)^3 $$\n$$ 1 = 2 u_2 - (u_1 - u_2)^3 $$\n这个非线性系统可以被高效求解。将两个方程相加可以消去三次项：\n$$ 5 + 1 = (2 u_1 + (u_1 - u_2)^3) + (2 u_2 - (u_1 - u_2)^3) $$\n$$ 6 = 2 u_1 + 2 u_2 \\implies u_1 + u_2 = 3 $$\n设相对位移为 $d = u_1 - u_2$。用第一个原方程减去第二个：\n$$ 5 - 1 = (2 u_1 + d^3) - (2 u_2 - d^3) $$\n$$ 4 = 2(u_1 - u_2) + 2d^3 \\implies 4 = 2d + 2d^3 $$\n两边除以 2，得到一个关于 $d$ 的三次方程：\n$$ d^3 + d - 2 = 0 $$\n通过检验可知，$d=1$ 是一个解：$(1)^3 + (1) - 2 = 0$。函数 $f(d)=d^3+d-2$ 的导数是 $f'(d) = 3d^2+1$，对所有实数 $d$ 都是严格为正的。因此，$f(d)$ 是一个严格单调递增的函数，$d=1$ 是唯一的实数解。\n我们现在得到一个关于 $u_1$ 和 $u_2$ 的线性方程组：\n$$ u_1 + u_2 = 3 $$\n$$ u_1 - u_2 = 1 $$\n将这两个方程相加得到 $2u_1 = 4$，所以 $u_1 = 2$。\n将 $u_1=2$ 代入第一个方程得到 $2 + u_2 = 3$，所以 $u_2 = 1$。\n最终平衡位移为 $u_1 = 2\\,\\text{m}$ 和 $u_2 = 1\\,\\text{m}$。\n\n**功和能量的计算**\n在最终平衡状态 $(u_1, u_2) = (2, 1)$ 下的内应变能 $U_{\\text{int}}$ 为：\n$$ U_{\\text{int}} = \\dfrac{2}{2}(2)^2 + \\dfrac{2}{2}(1)^2 + \\dfrac{1}{4}(2 - 1)^4 = 4 + 1 + \\dfrac{1}{4} = 5.25\\,\\text{J} $$\n该系统是超弹性的，意味着内力是保守的，并且可以从势能 $U_{\\text{int}}$ 导出。对于一个保守系统中的准静态过程，外力所做的功 $W_{\\text{ext}}$ 等于内应变能的变化量。\n$$ W_{\\text{seq}} = \\int_{\\text{path}} \\mathbf{P} \\cdot d\\mathbf{u} = \\int_{\\text{path}} (\\nabla U_{\\text{int}}) \\cdot d\\mathbf{u} = U_{\\text{int, final}} - U_{\\text{int, initial}} $$\n由于系统从 $u_1=u_2=0$ 且 $U_{\\text{int, initial}}=0$ 的未变形状态开始，因此所做的总外功等于最终的内应变能，而与加载路径无关。\n$$ W_{\\text{seq}} = U_{\\text{int}} = 5.25\\,\\text{J} $$\n在这种超弹性情况下，指定顺序加载路径与总功的计算无关，这是将其与非保守系统区分开来的一个关键特征。\n\n**Clapeyron 定理和量 $\\Delta$**\n我们现在计算诊断量 $U_C$：\n$$ U_C = \\dfrac{1}{2}(P_1 u_1 + P_2 u_2) = \\dfrac{1}{2}((5)(2) + (1)(1)) = \\dfrac{1}{2}(10 + 1) = \\dfrac{11}{2} = 5.5\\,\\text{J} $$\n差值 $\\Delta$ 为：\n$$ \\Delta = U_C - U_{\\text{int}} = 5.5 - 5.25 = 0.25\\,\\text{J} $$\n为了解释这个结果，我们注意到 Clapeyron 定理 $W_{ext} = U_{int} = \\frac{1}{2} \\sum P_i u_i$ 仅对线性弹性系统有效。由于势能中的四次项，所考虑的系统是非线性的。$\\Delta$ 的非零值量化了 Clapeyron 定理的失效程度。\n\n更深入的分析揭示了这种差异的来源。从平衡方程我们可以写出：\n$$ P_1 u_1 + P_2 u_2 = (k u_1 + c d^3)u_1 + (k u_2 - c d^3)u_2 = k u_1^2 + k u_2^2 + c d^3(u_1 - u_2) = k u_1^2 + k u_2^2 + c d^4 $$\n其中 $d = u_1 - u_2$。\n那么，$U_C$ 可以用位移表示为：\n$$ U_C = \\dfrac{1}{2}(k u_1^2 + k u_2^2 + c d^4) = \\dfrac{k}{2}u_1^2 + \\dfrac{k}{2}u_2^2 + \\dfrac{c}{2}d^4 $$\n因此，差值 $\\Delta$ 为：\n$$ \\Delta = U_C - U_{\\text{int}} = \\left(\\dfrac{k}{2}u_1^2 + \\dfrac{k}{2}u_2^2 + \\dfrac{c}{2}d^4\\right) - \\left(\\dfrac{k}{2}u_1^2 + \\dfrac{k}{2}u_2^2 + \\dfrac{c}{4}d^4\\right) = \\dfrac{c}{4}d^4 $$\n这证实了我们的数值计算，因为 $\\Delta = \\dfrac{1}{4}(1)^4 = 0.25$。符号为正，因为 $c>0$。这表明对于这个“刚化”系统（其中力随位移的增加超过线性比例），实际储存的能量 $U_{\\text{int}}$ 小于线性公式预测的 $U_C$ 值。对于刚化系统，量 $U_C$ 高估了储存的能量。\n\n**Maxwell-Betti 互易性**\n对于最终平衡状态附近的小扰动 $(\\delta u_1, \\delta u_2)$，增量力通过切线刚度矩阵 $\\mathbf{K}_T$ 相关联：\n$$ \\mathbf{K}_T = \\begin{pmatrix} \\frac{\\partial^2 U_{\\text{int}}}{\\partial u_1^2} & \\frac{\\partial^2 U_{\\text{int}}}{\\partial u_1 \\partial u_2} \\\\ \\frac{\\partial^2 U_{\\text{int}}}{\\partial u_2 \\partial u_1} & \\frac{\\partial^2 U_{\\text{int}}}{\\partial u_2^2} \\end{pmatrix} = \\begin{pmatrix} k + 3c(u_1-u_2)^2 & -3c(u_1-u_2)^2 \\\\ -3c(u_1-u_2)^2 & k + 3c(u_1-u_2)^2 \\end{pmatrix} $$\n由于 $U_{\\text{int}}$ 是一个光滑函数，微分的顺序无关紧要，因此 $\\mathbf{K}_T$ 是对称的。这种对称性是 Maxwell-Betti 互易性增量形式的数学基础。在最终状态（$k=2$, $c=1$, $d=1$），该矩阵为：\n$$ \\mathbf{K}_T = \\begin{pmatrix} 5 & -3 \\\\ -3 & 5 \\end{pmatrix} $$\n柔度矩阵是 $\\mathbf{C}_T = \\mathbf{K}_T^{-1} = \\frac{1}{16}\\begin{pmatrix} 5 & 3 \\\\ 3 & 5 \\end{pmatrix}$。\n节点 1 处单位增量荷载引起的节点 2 位移为 $\\delta u^{(1)}_2 = C_{T,21} = 3/16$。\n节点 2 处单位增量荷载引起的节点 1 位移为 $\\delta u^{(2)}_1 = C_{T,12} = 3/16$。\n由于 $\\delta u^{(1)}_2 = \\delta u^{(2)}_1$，Maxwell-Betti 互易性对于小扰动成立。这说明尽管全局力-位移关系是非线性的，但围绕平衡点的局部行为是线性和互易的，因为系统是超弹性的。\n\n要求的最终量是标量差 $\\Delta$。\n$$ \\Delta = 0.25\\,\\text{J} $$\n按要求四舍五入到 4 位有效数字，该值为 $0.2500\\,\\text{J}$。", "answer": "$$ \\boxed{0.2500} $$", "id": "2618447"}, {"introduction": "当材料行为涉及能量耗散和路径依赖时，例如在弹塑性变形中，Betti 倒易定理便不再适用。本计算实践将带你进入非线性有限元分析的世界，通过模拟一个弹塑性杆在不同加载-卸载路径下的响应，来亲自验证并量化倒易定理的失效。这项练习不仅能加深你对倒易定理根本前提的理解，还能锻炼你处理非保守系统的计算力学技能。", "problem": "考虑一根承受轴向载荷的一维小应变杆，其被离散为$2$个线性轴向单元和$3$个节点，节点索引为$i \\in \\{0,1,2\\}$。节点$i=0$为固定端（本质边界条件$u_0=0$），节点$i=1,2$为自由端。设单元$e=1$连接节点$(0,1)$，单元$e=2$连接节点$(1,2)$。该杆的属性在每个单元内呈空间分段常数：长度$L_e$、横截面积$A_e$、杨氏模量$E_e$、初始屈服应力$\\sigma_{y0,e}$和线性各向同性硬化模量$H_e$。假设为小应变、准静态演化，并采用与率无关的、具有线性各向同性硬化的双线性弹塑性本构律。单元$e$中的应变为$\\varepsilon_e = (u_j - u_i)/L_e$，其中$(i,j)$是单元$e$的端点节点。Cauchy应力$\\sigma_e$遵循加法分解$\\varepsilon_e = \\varepsilon_{e}^e + \\varepsilon_{e}^p$，其中线性弹性关系为$\\sigma_e = E_e \\varepsilon_{e}^e$，以及标准的一维$J_2$型屈服条件$f_e = |\\sigma_e| - (\\sigma_{y0,e} + H_e \\alpha_e) \\le 0$，此处$\\alpha_e$是累积塑性应变。在每个载荷增量步，强制执行内部与外部节点力的全局平衡（虚功原理），并对局部本构方程进行一致的返回映射积分，以更新$(\\sigma_e,\\varepsilon_{e}^p,\\alpha_e)$，同时满足Karush–Kuhn–Tucker条件。在每个载荷步，使用带有单元算法切线的Newton型迭代法来求解非线性平衡方程。\n\nBetti互易定理指出，对于一个具有对称刚度的线性弹性系统，施加于同一结构上的任意两个静力许可载荷$\\mathbf{P}^{(1)}$和$\\mathbf{P}^{(2)}$，等式$\\mathbf{P}^{(1)} \\cdot \\mathbf{u}^{(2)} = \\mathbf{P}^{(2)} \\cdot \\mathbf{u}^{(1)}$成立，其中$\\mathbf{u}^{(k)}$是由$\\mathbf{P}^{(k)}$引起的位移场。在具有路径依赖内变量的弹塑性系统中，互易性可能失效。\n\n设计并实现一个计算测试，对于施加于同一初始杆件的两个独立载荷工况（历史），计算其最终位移向量$\\mathbf{u}^{(1)}$和$\\mathbf{u}^{(2)}$，并评估每个载荷工况最终步骤的标量值$\\mathbf{P}^{(1)} \\cdot \\mathbf{u}^{(2)}$和$\\mathbf{P}^{(2)} \\cdot \\mathbf{u}^{(1)}$。此处，点积是针对自由节点自由度（$i=1,2$）计算的。报告每个测试实例的差值$\\Delta = \\mathbf{P}^{(1)} \\cdot \\mathbf{u}^{(2)} - \\mathbf{P}^{(2)} \\cdot \\mathbf{u}^{(1)}$，以量化互易性的失效程度。\n\n使用的基本原理：\n- 准静态形式的线性动量平衡（在每个步骤中，内部节点力之和等于外部节点力）。\n- 轴向应变协调性：$\\varepsilon_e = (u_j - u_i)/L_e$。\n- 弹性范围内的线性弹性：$\\sigma_e = E_e (\\varepsilon_e - \\varepsilon_{e}^p)$，其中$\\varepsilon_{e}^p$是塑性应变。\n- 标准的一维弹塑性，包含线性各向同性硬化、屈服条件$f_e \\le 0$、一致性条件以及每个增量步的返回映射。\n- 使用虚功原理来组装内力和算法切线刚度：单元内部节点力等于$\\int_0^{L_e} \\mathbf{B}_e^\\top \\sigma_e A_e \\, dx$，其中$\\mathbf{B}_e = [-1/L_e, 1/L_e]$；单元切线等于$\\int_0^{L_e} \\mathbf{B}_e^\\top E_{t,e} A_e \\mathbf{B}_e \\, dx$，其中$E_{t,e}$是由局部本构更新给出的算法切线模量。\n\n要求的单位和输出：\n- 所有输入均采用国际单位制（SI）：长度单位为$\\mathrm{m}$，面积单位为$\\mathrm{m}^2$，力单位为$\\mathrm{N}$，应力单位为$\\mathrm{Pa}$，模量单位为$\\mathrm{Pa}$。\n- 位移必须以$\\mathrm{m}$为单位进行计算。\n- 报告的差值$\\Delta$必须以$\\mathrm{N}\\cdot\\mathrm{m}$（焦耳）为单位表示。\n- 你的程序必须打印一行，其中包含以下测试组的三个$\\Delta$值列表，四舍五入到六位小数，格式必须完全符合：$[\\Delta_1,\\Delta_2,\\Delta_3]$。\n\n测试组：\n- 所有测试的几何和材料属性：\n  - 单元$e=1$：$L_1 = 0.6\\,\\mathrm{m}$，$A_1 = 1.0\\times 10^{-3}\\,\\mathrm{m}^2$，$E_1 = 210\\times 10^{9}\\,\\mathrm{Pa}$，$\\sigma_{y0,1} = 300\\times 10^{6}\\,\\mathrm{Pa}$，$H_1 = 1.0\\times 10^{9}\\,\\mathrm{Pa}$。\n  - 单元$e=2$：$L_2 = 0.4\\,\\mathrm{m}$，$A_2 = 0.5\\times 10^{-3}\\,\\mathrm{m}^2$，$E_2 = 210\\times 10^{9}\\,\\mathrm{Pa}$，$\\sigma_{y0,2} = 250\\times 10^{6}\\,\\mathrm{Pa}$，$H_2 = 1.0\\times 10^{9}\\,\\mathrm{Pa}$。\n- 外部节点力按步骤以向量$\\mathbf{P} = [P_0, P_1, P_2]$（单位：$\\mathrm{N}$）的形式给出，其中$P_0$对应节点$i=0$（此处恒为$0$），$P_1$对应节点$i=1$，$P_2$对应节点$i=2$。每个测试包含施加于同一初始杆件的两个独立载荷工况：\n  - 测试$1$（主要为弹性卸载-再加载）：\n    - 载荷工况$(1)$：仅在节点$i=2$上施加载荷历史，步骤为$\\mathbf{P}^{(1)}(t)$：\n      - $[0, 0, 0] \\to [0, 0, 10{,}000] \\to [0, 0, 30{,}000] \\to [0, 0, 40{,}000] \\to [0, 0, 20{,}000] \\to [0, 0, 30{,}000]$。\n    - 载荷工况$(2)$：仅在节点$i=1$上施加载荷历史，步骤为$\\mathbf{P}^{(2)}(t)$：\n      - $[0, 0, 0] \\to [0, 5{,}000, 0] \\to [0, 15{,}000, 0] \\to [0, 20{,}000, 0] \\to [0, 10{,}000, 0] \\to [0, 15{,}000, 0]$。\n  - 测试$2$（单调塑性）：\n    - 载荷工况$(1)$：仅节点$i=2$，\n      - $[0, 0, 0] \\to [0, 0, 80{,}000] \\to [0, 0, 140{,}000] \\to [0, 0, 160{,}000]$。\n    - 载荷工况$(2)$：仅节点$i=1$，\n      - $[0, 0, 0] \\to [0, 150{,}000, 0] \\to [0, 300{,}000, 0] \\to [0, 320{,}000, 0]$。\n  - 测试$3$（弹塑性卸载-再加载）：\n    - 载荷工况$(1)$：仅节点$i=2$，\n      - $[0, 0, 0] \\to [0, 0, 100{,}000] \\to [0, 0, 180{,}000] \\to [0, 0, 120{,}000] \\to [0, 0, 150{,}000]$。\n    - 载荷工况$(2)$：仅节点$i=1$，\n      - $[0, 0, 0] \\to [0, 120{,}000, 0] \\to [0, 220{,}000, 0] \\to [0, 80{,}000, 0] \\to [0, 180{,}000, 0]$。\n\n对于每个测试：\n- 从初始状态（$\\varepsilon_{e}^p = 0$, $\\alpha_e = 0$, $\\mathbf{u} = \\mathbf{0}$）开始，独立地对每个载荷工况在其完整的步骤历史中进行积分，在每一步中使用带有局部本构更新的单元算法切线的Newton型方法来强制平衡。在每个载荷工况$k \\in \\{1,2\\}$的最后一步，记录自由节点位移向量$\\mathbf{u}_\\mathrm{free}^{(k)} = [u_1^{(k)}, u_2^{(k)}]$和相应的外部节点力向量$\\mathbf{P}_\\mathrm{free}^{(k)} = [P_1^{(k)}, P_2^{(k)}]$。\n- 计算$\\Delta = \\mathbf{P}^{(1)}_\\mathrm{free} \\cdot \\mathbf{u}^{(2)}_\\mathrm{free} - \\mathbf{P}^{(2)}_\\mathrm{free} \\cdot \\mathbf{u}^{(1)}_\\mathrm{free}$（单位：$\\mathrm{N}\\cdot\\mathrm{m}$），并四舍五入到六位小数。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[x_1,x_2,x_3]$），其中每个$x_i$是测试$i$的$\\Delta$值（单位：$\\mathrm{N}\\cdot\\mathrm{m}$），并四舍五入到六位小数。", "solution": "所提出的问题是计算固体力学领域，特别是非线性有限元分析领域中，一个适定且标准的练习。它要求实现一个数值程序来模拟一维杆在轴向载荷下的行为，并考虑以带有线性各向同性硬化的弹塑性形式存在的材料非线性。最终目标是，在存在路径依赖的塑性变形的情况下，通过计算来研究Betti互易定理的失效。该问题是有效的，并将按所述方式求解。\n\n该解决方案基于有限元法（FEM）构建，用于求解准静态、小应变弹塑性问题。其核心组成部分包括平衡方程的建立、通过返回映射算法进行的本构积分，以及用于在每个载荷增量步求解所得非线性系统的Newton-Raphson方案。\n\n**1. 系统离散化与运动学**\n\n该系统由三个索引为$i=0,1,2$的节点和两个单元组成。节点$0$是固定的，因此其位移$u_0 = 0$。自由度（DOFs）是节点$1$和$2$的位移，用向量$\\mathbf{u} = [u_1, u_2]^T$表示。\n\n每个单元$e$中的轴向应变$\\varepsilon_e$由节点位移定义。对于这个双单元系统：\n- 单元$1$（节点$0, 1$）：$\\varepsilon_1 = (u_1 - u_0) / L_1 = u_1 / L_1$\n- 单元$2$（节点$1, 2$）：$\\varepsilon_2 = (u_2 - u_1) / L_2$\n\n**2. 虚功原理与平衡**\n\n系统的静力平衡由虚功原理控制，该原理指出，对于任意运动学许可的虚位移场$\\delta\\mathbf{u} = [\\delta u_1, \\delta u_2]^T$，应力所做的内功必须等于外加载荷所做的外功。\n\n虚内功为：\n$$ \\delta W_{\\text{int}} = \\sum_{e=1}^{2} \\int_{V_e} \\sigma_e \\delta\\varepsilon_e \\, dV_e = (A_1 \\sigma_1) \\delta u_1 + (A_2 \\sigma_2)(\\delta u_2 - \\delta u_1) $$\n按虚位移重新整理各项：\n$$ \\delta W_{\\text{int}} = (A_1 \\sigma_1 - A_2 \\sigma_2) \\delta u_1 + (A_2 \\sigma_2) \\delta u_2 $$\n虚外功为$\\delta W_{\\text{ext}} = \\mathbf{P}^T \\delta\\mathbf{u} = P_1 \\delta u_1 + P_2 \\delta u_2$，其中$\\mathbf{P} = [P_1, P_2]^T$是自由节点上的外力向量。\n\n对于任意$\\delta\\mathbf{u}$，令$\\delta W_{\\text{int}} = \\delta W_{\\text{ext}}$，可得平衡方程组$\\mathbf{F}_{\\text{int}}(\\mathbf{u}) = \\mathbf{P}$，其中内力向量$\\mathbf{F}_{\\text{int}}$为：\n$$ \\mathbf{F}_{\\text{int}}(\\mathbf{u}) = \\begin{pmatrix} A_1 \\sigma_1 - A_2 \\sigma_2 \\\\ A_2 \\sigma_2 \\end{pmatrix} $$\n应力$\\sigma_1$和$\\sigma_2$本身通过材料的本构关系成为位移$u_1$和$u_2$的非线性函数。\n\n**3. 本构模型：带返回映射的弹塑性**\n\n材料遵循与率无关的一维双线性弹塑性模型，并带有线性各向同性硬化。在从时间$t_n$到$t_{n+1}$的每个载荷步中，必须对本构方程进行积分，以求得与给定总应变$\\varepsilon_{n+1}$相对应的应力$\\sigma_{n+1}$。这通过标准的隐式弹性预测/塑性修正方案（返回映射）实现。对于每个单元$e$：\n\n- **状态变量**：先前收敛步骤$n$的状态是已知的：应力$\\sigma_n$、塑性应变$\\varepsilon^p_n$和累积塑性应变$\\alpha_n$。\n- **弹性预测**：假设整个应变增量是弹性的，计算试探应力$\\sigma^{\\text{trial}}$：\n$$ \\sigma^{\\text{trial}} = E (\\varepsilon_{n+1} - \\varepsilon^p_n) $$\n- **屈服条件检查**：根据屈服准则检查试探状态：\n$$ f^{\\text{trial}} = |\\sigma^{\\text{trial}}| - (\\sigma_{y0} + H \\alpha_n) $$\n- **本构更新**：\n    - 如果$f^{\\text{trial}} \\le 0$，则该步为弹性。状态更新为：\n    $$ \\sigma_{n+1} = \\sigma^{\\text{trial}}, \\quad \\varepsilon^p_{n+1} = \\varepsilon^p_n, \\quad \\alpha_{n+1} = \\alpha_n $$\n    材料响应由杨氏模量控制，因此算法切线模量为$E_t = E$。\n    - 如果$f^{\\text{trial}} > 0$，则发生塑性流动。状态必须被“返回”到屈服面上。通过强制执行一致性条件$f_{n+1}=0$来找到塑性一致性乘子$\\Delta\\gamma$：\n    $$ \\Delta\\gamma = \\frac{f^{\\text{trial}}}{E + H} $$\n    然后更新（修正）状态变量：\n    $$ \\alpha_{n+1} = \\alpha_n + \\Delta\\gamma $$\n    $$ \\varepsilon^p_{n+1} = \\varepsilon^p_n + \\Delta\\gamma \\cdot \\text{sign}(\\sigma^{\\text{trial}}) $$\n    $$ \\sigma_{n+1} = E (\\varepsilon_{n+1} - \\varepsilon^p_{n+1}) = \\sigma^{\\text{trial}} - E \\cdot \\Delta\\gamma \\cdot \\text{sign}(\\sigma^{\\text{trial}}) $$\n    此塑性步的一致算法切线模量为：\n    $$ E_t = \\frac{EH}{E+H} $$\n\n**4. 非线性求解器：Newton-Raphson方法**\n\n在每个载荷步$t_{n+1}$，目标是找到满足非线性平衡方程的位移向量$\\mathbf{u}_{n+1}$：\n$$ \\mathbf{R}(\\mathbf{u}_{n+1}) = \\mathbf{P}_{n+1} - \\mathbf{F}_{\\text{int}}(\\mathbf{u}_{n+1}) = \\mathbf{0} $$\n这通过Newton-Raphson方法迭代求解。从初始猜测$\\mathbf{u}^{(0)} = \\mathbf{u}_n$开始，在每次迭代$k$中对系统进行线性化：\n$$ \\mathbf{K}_T^{(k)} \\Delta\\mathbf{u}^{(k)} = \\mathbf{R}^{(k)} $$\n其中$\\mathbf{R}^{(k)} = \\mathbf{P}_{n+1} - \\mathbf{F}_{\\text{int}}(\\mathbf{u}^{(k)})$是残余力向量，$\\mathbf{K}_T^{(k)}$是迭代$k$时的全局切线刚度矩阵。位移更新为：$\\mathbf{u}^{(k+1)} = \\mathbf{u}^{(k)} + \\Delta\\mathbf{u}^{(k)}$。此过程重复进行，直到残余力的范数低于指定容差。\n\n切线刚度矩阵是内力向量对位移的导数，$\\mathbf{K}_T = \\partial\\mathbf{F}_{\\text{int}}/\\partial\\mathbf{u}$。对于我们的系统：\n$$ \\mathbf{K}_T = \\begin{pmatrix} A_1 \\frac{\\partial\\sigma_1}{\\partial u_1} - A_2 \\frac{\\partial\\sigma_2}{\\partial u_1} & A_1 \\frac{\\partial\\sigma_1}{\\partial u_2} - A_2 \\frac{\\partial\\sigma_2}{\\partial u_2} \\\\ A_2 \\frac{\\partial\\sigma_2}{\\partial u_1} & A_2 \\frac{\\partial\\sigma_2}{\\partial u_2} \\end{pmatrix} $$\n使用链式法则和单元运动学：\n$\\frac{\\partial\\sigma_1}{\\partial u_1} = \\frac{d\\sigma_1}{d\\varepsilon_1} \\frac{\\partial\\varepsilon_1}{\\partial u_1} = E_{t,1} \\frac{1}{L_1}$, $\\frac{\\partial\\sigma_1}{\\partial u_2} = 0$。\n$\\frac{\\partial\\sigma_2}{\\partial u_1} = \\frac{d\\sigma_2}{d\\varepsilon_2} \\frac{\\partial\\varepsilon_2}{\\partial u_1} = E_{t,2} \\frac{-1}{L_2}$, $\\frac{\\partial\\sigma_2}{\\partial u_2} = \\frac{d\\sigma_2}{d\\varepsilon_2} \\frac{\\partial\\varepsilon_2}{\\partial u_2} = E_{t,2} \\frac{1}{L_2}$。\n代入这些，得到全局切线刚度矩阵：\n$$ \\mathbf{K}_T = \\begin{pmatrix} \\frac{A_1 E_{t,1}}{L_1} + \\frac{A_2 E_{t,2}}{L_2} & -\\frac{A_2 E_{t,2}}{L_2} \\\\ -\\frac{A_2 E_{t,2}}{L_2} & \\frac{A_2 E_{t,2}}{L_2} \\end{pmatrix} $$\n其中$E_{t,e}$是单元$e$的算法切线模量，由当前迭代的本构更新确定。\n\n**5. 互易性计算测试**\n\n程序实现了所述的求解器。对于三个测试中的每一个，它都执行两次独立的模拟，每个载荷工况一次，都从一个初始（无应力、无变形）状态开始。在每个载荷历史结束时，记录最终的外部力向量$\\mathbf{P}_{\\text{free}}^{(k)}$和最终的位移向量$\\mathbf{u}_{\\text{free}}^{(k)}$（对于$k=1,2$）。然后按规定计算量$\\Delta$：\n$$ \\Delta = \\mathbf{P}_{\\text{free}}^{(1)} \\cdot \\mathbf{u}_{\\text{free}}^{(2)} - \\mathbf{P}_{\\text{free}}^{(2)} \\cdot \\mathbf{u}_{\\text{free}}^{(1)} $$\n对于测试1，两个载荷路径都完全保持在弹性域内，系统表现为线性。刚度矩阵是对称且恒定的，这是Betti定理成立的条件。因此，$\\Delta$预计为零（在数值精度范围内）。对于测试2和3，至少有一个载荷路径中发生了塑性变形。这种路径依赖的耗散行为破坏了Betti定理的假设，因此预计会出现非零的$\\Delta$，用以量化互易性的失效程度。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the computational mechanics problem to test Betti's reciprocal theorem\n    for an elastoplastic bar.\n    \"\"\"\n\n    class Element:\n        \"\"\"Represents a 1D axial element with bilinear elastoplastic material behavior.\"\"\"\n        def __init__(self, L, A, E, sig_y0, H):\n            self.L = L\n            self.A = A\n            self.E = E\n            self.sig_y0 = sig_y0\n            self.H = H\n            self.reset()\n\n        def reset(self):\n            \"\"\"Resets the element to a virgin state.\"\"\"\n            self.sigma = 0.0      # Stress\n            self.epsilon_p = 0.0  # Plastic strain\n            self.alpha = 0.0      # Accumulated plastic strain\n\n    def run_load_case(elements, load_history, max_iter=30, tol=1e-8):\n        \"\"\"\n        Simulates the response of the bar for a given load history using a\n        Newton-Raphson solver.\n        \n        Args:\n            elements (list): A list containing the two Element objects.\n            load_history (list): A sequence of external force vectors [P1, P2].\n            max_iter (int): Maximum number of Newton-Raphson iterations per step.\n            tol (float): Convergence tolerance for the residual norm.\n\n        Returns:\n            numpy.ndarray: The final displacement vector [u1, u2].\n        \"\"\"\n        el1, el2 = elements\n        \n        # Reset elements to virgin state before starting the simulation\n        el1.reset()\n        el2.reset()\n        \n        u_free = np.zeros(2) # [u1, u2]\n\n        for p_target in load_history[1:]: # Start from the first non-zero load step\n            P_ext = np.array(p_target, dtype=float)\n            \n            # Newton-Raphson iterations to find equilibrium at P_ext\n            u_iter = u_free.copy()\n            \n            # State at the beginning of the load increment (converged state from previous step)\n            initial_states = {\n                'el1': {'ep': el1.epsilon_p, 'alpha': el1.alpha},\n                'el2': {'ep': el2.epsilon_p, 'alpha': el2.alpha}\n            }\n\n            for i in range(max_iter):\n                # 1. Calculate trial state based on current displacement guess u_iter\n                eps1_k = u_iter[0] / el1.L\n                eps2_k = (u_iter[1] - u_iter[0]) / el2.L\n\n                # --- Element 1 properties at iteration k ---\n                sig1_trial = el1.E * (eps1_k - initial_states['el1']['ep'])\n                f1_trial = abs(sig1_trial) - (el1.sig_y0 + el1.H * initial_states['el1']['alpha'])\n                \n                if f1_trial = 0.0: # Elastic\n                    sig1_k = sig1_trial\n                    Et1_k = el1.E\n                else: # Plastic\n                    d_gamma1 = f1_trial / (el1.E + el1.H)\n                    sig1_k = sig1_trial - el1.E * d_gamma1 * np.sign(sig1_trial)\n                    Et1_k = (el1.E * el1.H) / (el1.E + el1.H)\n\n                # --- Element 2 properties at iteration k ---\n                sig2_trial = el2.E * (eps2_k - initial_states['el2']['ep'])\n                f2_trial = abs(sig2_trial) - (el2.sig_y0 + el2.H * initial_states['el2']['alpha'])\n\n                if f2_trial = 0.0: # Elastic\n                    sig2_k = sig2_trial\n                    Et2_k = el2.E\n                else: # Plastic\n                    d_gamma2 = f2_trial / (el2.E + el2.H)\n                    sig2_k = sig2_trial - el2.E * d_gamma2 * np.sign(sig2_trial)\n                    Et2_k = (el2.E * el2.H) / (el2.E + el2.H)\n                \n                # 2. Assemble internal force vector and calculate residual\n                F_int = np.array([el1.A * sig1_k - el2.A * sig2_k, el2.A * sig2_k])\n                R = P_ext - F_int\n\n                # 3. Check for convergence\n                norm_R = np.linalg.norm(R)\n                if norm_R  tol:\n                    break\n                if i == max_iter - 1:\n                    print(\"Warning: Newton-Raphson did not converge.\")\n\n                # 4. Assemble tangent stiffness matrix\n                k1 = el1.A * Et1_k / el1.L\n                k2 = el2.A * Et2_k / el2.L\n                K_T = np.array([[k1 + k2, -k2], [-k2, k2]])\n                \n                # 5. Solve for displacement increment and update\n                delta_u = np.linalg.solve(K_T, R)\n                u_iter += delta_u\n            \n            # After convergence, update permanent state for the next load step\n            u_free = u_iter.copy()\n            \n            # --- Update element 1 final state for this step ---\n            eps1_final = u_free[0] / el1.L\n            sig1_trial = el1.E * (eps1_final - initial_states['el1']['ep'])\n            f1_trial = abs(sig1_trial) - (el1.sig_y0 + el1.H * initial_states['el1']['alpha'])\n            if f1_trial > 0.0:\n                d_gamma1 = f1_trial / (el1.E + el1.H)\n                el1.alpha = initial_states['el1']['alpha'] + d_gamma1\n                el1.epsilon_p = initial_states['el1']['ep'] + d_gamma1 * np.sign(sig1_trial)\n            el1.sigma = el1.E * (eps1_final - el1.epsilon_p)\n\n            # --- Update element 2 final state for this step ---\n            eps2_final = (u_free[1] - u_free[0]) / el2.L\n            sig2_trial = el2.E * (eps2_final - initial_states['el2']['ep'])\n            f2_trial = abs(sig2_trial) - (el2.sig_y0 + el2.H * initial_states['el2']['alpha'])\n            if f2_trial > 0.0:\n                d_gamma2 = f2_trial / (el2.E + el2.H)\n                el2.alpha = initial_states['el2']['alpha'] + d_gamma2\n                el2.epsilon_p = initial_states['el2']['ep'] + d_gamma2 * np.sign(sig2_trial)\n            el2.sigma = el2.E * (eps2_final - el2.epsilon_p)\n            \n        return u_free\n\n    # Define common material and geometric properties\n    props1 = {'L': 0.6, 'A': 1.0e-3, 'E': 210e9, 'sig_y0': 300e6, 'H': 1.0e9}\n    props2 = {'L': 0.4, 'A': 0.5e-3, 'E': 210e9, 'sig_y0': 250e6, 'H': 1.0e9}\n\n    # Problem statement gives loads as [P0, P1, P2]. We only need free DOFs [P1, P2].\n    test_cases = [\n        # Test 1 (predominantly elastic unloading–reloading)\n        {\n            'P1_hist': [[0, 0], [0, 10000], [0, 30000], [0, 40000], [0, 20000], [0, 30000]],\n            'P2_hist': [[0, 0], [5000, 0], [15000, 0], [20000, 0], [10000, 0], [15000, 0]]\n        },\n        # Test 2 (monotonic plastic)\n        {\n            'P1_hist': [[0, 0], [0, 80000], [0, 140000], [0, 160000]],\n            'P2_hist': [[0, 0], [150000, 0], [300000, 0], [320000, 0]]\n        },\n        # Test 3 (elastoplastic unloading–reloading)\n        {\n            'P1_hist': [[0, 0], [0, 100000], [0, 180000], [0, 120000], [0, 150000]],\n            'P2_hist': [[0, 0], [120000, 0], [220000, 0], [80000, 0], [180000, 0]]\n        }\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        # Instantiate elements for the current test\n        element1 = Element(**props1)\n        element2 = Element(**props2)\n        elements = [element1, element2]\n\n        # Simulate Load Case 1\n        u_final_1 = run_load_case(elements, case['P1_hist'])\n        P_final_1 = np.array(case['P1_hist'][-1])\n\n        # Simulate Load Case 2\n        u_final_2 = run_load_case(elements, case['P2_hist'])\n        P_final_2 = np.array(case['P2_hist'][-1])\n        \n        # Compute Delta to quantify reciprocity breakdown\n        delta = P_final_1 @ u_final_2 - P_final_2 @ u_final_1\n        \n        # The problem asks for rounding to six decimal places, not just formatting\n        results.append(f\"{delta:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2618402"}]}