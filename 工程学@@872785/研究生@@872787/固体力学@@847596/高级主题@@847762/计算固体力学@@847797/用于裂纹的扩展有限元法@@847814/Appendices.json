{"hands_on_practices": [{"introduction": "在任何扩展有限元法（XFEM）模拟中，首要任务是算法性地识别出哪些单元和节点受到了裂纹的影响。本练习旨在演示如何利用水平集（level-set）数据，将网格单元分类为标准单元、裂纹单元、Heaviside富集单元或裂尖富集单元。这是后续应用正确富集函数的基础步骤，也是XFEM前处理阶段的关键环节。[@problem_id:2637826]", "problem": "给定用于扩展有限元法 (XFEM) 的平面裂纹的双水平集表示。该表示使用两个有符号距离场：一个法向水平集 $\\phi(\\mathbf{x})$ 表示裂纹面，一个切向水平集 $\\psi(\\mathbf{x})$ 表示裂纹前缘（尖端）坐标。裂纹集由以下基本定义确定：\n- 实际裂纹面（内部，即破碎的材料）是集合 $\\{\\mathbf{x} \\mid \\phi(\\mathbf{x}) = 0, \\ \\psi(\\mathbf{x})  0\\}$。\n- 裂纹尖端是点集 $\\{\\mathbf{x} \\mid \\phi(\\mathbf{x}) = 0, \\ \\psi(\\mathbf{x}) = 0\\}$。\n\n在节点离散化中，给定网格节点 $\\{i\\}$ 处的节点值 $\\{\\phi_i\\}$ 和 $\\{\\psi_i\\}$。对于每个具有节点索引集 $\\mathcal{N}(e)$ 的单元 $e$，您必须根据 $\\{\\phi_i\\}_{i \\in \\mathcal{N}(e)}$ 和 $\\{\\psi_i\\}_{i \\in \\mathcal{N}(e)}$ 的符号模式，将该单元精确地分类为以下互斥类别之一：\n- 标准单元 ($0$)：无需裂纹相关富集。\n- 裂纹单元 ($1$)：实际裂纹穿过单元的至少一个顶点（节点），但单元内部未被裂纹分割且不包含尖端。\n- Heaviside 单元 ($2$)：实际裂纹面分割单元内部（裂纹面两侧位移不连续），且该单元不包含尖端。\n- 尖端单元 ($3$)：单元包含裂纹尖端（需要近尖端渐近富集）。\n\n使用以下稳健的、考虑容差的逻辑准则。设容差为 $\\varepsilon = 10^{-7}$。定义考虑容差的符号函数\n$$\n\\operatorname{sgn}_\\varepsilon(a) = \n\\begin{cases}\n-1,  a  -\\varepsilon,\\\\\n0,  |a| \\le \\varepsilon,\\\\\n+1,  a  \\varepsilon.\n\\end{cases}\n$$\n对于一个单元 $e$，定义考虑容差的符号集合\n$$\nS_\\phi(e) = \\{\\operatorname{sgn}_\\varepsilon(\\phi_i) \\mid i \\in \\mathcal{N}(e)\\}, \\quad\nS_\\psi(e) = \\{\\operatorname{sgn}_\\varepsilon(\\psi_i) \\mid i \\in \\mathcal{N}(e)\\}.\n$$\n定义布尔谓词\n- $\\text{has\\_sign\\_change}(S) \\equiv (\\min S = -1) \\wedge (\\max S = +1)$，\n- $\\text{all\\_behind\\_tip}(e) \\equiv \\max\\{\\psi_i \\mid i \\in \\mathcal{N}(e)\\}  -\\varepsilon$。\n\n然后使用以下规则对单元进行分类：\n1. 尖端单元 ($3$) 当且仅当 $\\text{has\\_sign\\_change}(S_\\phi(e))$ 且 $\\text{has\\_sign\\_change}(S_\\psi(e))$。\n2. Heaviside 单元 ($2$) 当且仅当 $\\text{has\\_sign\\_change}(S_\\phi(e))$ 且 $\\text{all\\_behind\\_tip}(e)$ 且该单元不是尖端单元。\n3. 裂纹单元 ($1$) 当且仅当该单元既不是尖端单元也不是 Heaviside 单元，并且存在某个节点 $j \\in \\mathcal{N}(e)$ 满足 $|\\phi_j| \\le \\varepsilon$ 且 $\\psi_j  -\\varepsilon$。\n4. 标准单元 ($0$) 其他情况。\n\n接下来，根据每个节点 $i$ 在富集单元中的成员关系及其自身的水平集值，将其精确地分类为以下互斥类别之一：\n- 标准节点 ($0$)。\n- 裂纹节点 ($1$)。\n- Heaviside 节点 ($2$)。\n- 尖端节点 ($3$)。\n\n对节点使用以下具有优先顺序的规则，容差同样为 $\\varepsilon$：\n1. 尖端节点 ($3$)：节点 $i$ 至少属于一个尖端单元。\n2. 裂纹节点 ($1$)：$|\\phi_i| \\le \\varepsilon$ 且 $\\psi_i  -\\varepsilon$。\n3. Heaviside 节点 ($2$)：节点 $i$ 至少属于一个 Heaviside 单元。\n4. 标准节点 ($0$)：以上条件均不适用。\n\n在一个程序中实现这些规则，并将其应用于以下测试套件。网格由节点水平集值和单元连接关系定义。所有数值均为无量纲单位。\n\n测试套件：\n- 容差：$\\varepsilon = 10^{-7}$。\n- 由 $i \\in \\{0,1,\\dots,11\\}$ 索引的节点及其 $(\\phi_i,\\psi_i)$ 对：\n  - $i=0$: $(+0.3,\\ -0.5)$\n  - $i=1$: $(-0.4,\\ -0.6)$\n  - $i=2$: $(+0.2,\\ -0.1)$\n  - $i=3$: $(-0.1,\\ -0.2)$\n  - $i=4$: $(0.0,\\ -0.3)$\n  - $i=5$: $(+0.2,\\ +0.1)$\n  - $i=6$: $(-0.2,\\ +0.2)$\n  - $i=7$: $(+0.05,\\ -0.05)$\n  - $i=8$: $(+0.3,\\ +0.4)$\n  - $i=9$: $(-0.3,\\ +0.3)$\n  - $i=10$: $(+10^{-8},\\ -0.4)$\n  - $i=11$: $(0.0,\\ 0.0)$\n- 由 $e \\in \\{0,1,2,3,4,5\\}$ 索引的单元及其节点索引集 $\\mathcal{N}(e)$：\n  - $e=0$: $\\{0,1,2\\}$\n  - $e=1$: $\\{2,5,6\\}$\n  - $e=2$: $\\{2,4,5\\}$\n  - $e=3$: $\\{5,8,9\\}$\n  - $e=4$: $\\{0,2,7\\}$\n  - $e=5$: $\\{2,6,11\\}$\n\n您的程序必须：\n- 精确实现上述逻辑准则，使用指定的容差 $\\varepsilon$。\n- 生成两个整数列表：\n  - 第一个列表按索引顺序 $e=0$ 到 $e=5$ 包含单元分类，使用整数代码 $0$ (标准)，$1$ (裂纹)，$2$ (Heaviside)，$3$ (尖端)。\n  - 第二个列表按索引顺序 $i=0$ 到 $i=11$ 包含节点分类，使用相同的整数代码映射。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含这两个列表，形式为单个逗号分隔的列表并用方括号括起来，即，确切格式为 $[[a_0,a_1,\\dots,a_5],[b_0,b_1,\\dots,b_{11}]]$，不含空格。\n- 每个 $a_e$ 和 $b_i$ 必须是整数。\n\n不应读取用户输入。程序必须是自包含的并确定性地运行。", "solution": "所提出的问题是计算力学领域中一个适定且具有科学依据的练习，具体涉及使用扩展有限元法 (XFEM) 进行裂纹分析时有限元单元及其节点的分类。所有定义、规则和数据均已提供，从而可以得到一个确定性且可验证的解。该问题是有效的。\n\n求解过程分为两个主要阶段：首先，对每个单元进行分类；其次，根据指定的逻辑准则对每个节点进行分类。\n\n基本参数是容差 $\\varepsilon = 10^{-7}$ 和节点水平集值 $(\\phi_i, \\psi_i)$。\n\n首先，我们使用以下函数为每个节点的水平集值建立考虑容差的符号：\n$$\n\\operatorname{sgn}_\\varepsilon(a) = \n\\begin{cases}\n-1,  a  -\\varepsilon \\\\\n0,  |a| \\le \\varepsilon \\\\\n+1,  a  \\varepsilon\n\\end{cases}\n$$\n所有 $12$ 个节点的符号预计算如下：\n- 节点 $0: (\\phi_0, \\psi_0) = (+0.3, -0.5) \\implies (\\operatorname{sgn}_\\varepsilon(\\phi_0), \\operatorname{sgn}_\\varepsilon(\\psi_0)) = (+1, -1)$\n- 节点 $1: (\\phi_1, \\psi_1) = (-0.4, -0.6) \\implies (\\operatorname{sgn}_\\varepsilon(\\phi_1), \\operatorname{sgn}_\\varepsilon(\\psi_1)) = (-1, -1)$\n- 节点 $2: (\\phi_2, \\psi_2) = (+0.2, -0.1) \\implies (\\operatorname{sgn}_\\varepsilon(\\phi_2), \\operatorname{sgn}_\\varepsilon(\\psi_2)) = (+1, -1)$\n- 节点 $3: (\\phi_3, \\psi_3) = (-0.1, -0.2) \\implies (\\operatorname{sgn}_\\varepsilon(\\phi_3), \\operatorname{sgn}_\\varepsilon(\\psi_3)) = (-1, -1)$\n- 节点 $4: (\\phi_4, \\psi_4) = (0.0, -0.3) \\implies (\\operatorname{sgn}_\\varepsilon(\\phi_4), \\operatorname{sgn}_\\varepsilon(\\psi_4)) = (0, -1)$\n- 节点 $5: (\\phi_5, \\psi_5) = (+0.2, +0.1) \\implies (\\operatorname{sgn}_\\varepsilon(\\phi_5), \\operatorname{sgn}_\\varepsilon(\\psi_5)) = (+1, +1)$\n- 节点 $6: (\\phi_6, \\psi_6) = (-0.2, +0.2) \\implies (\\operatorname{sgn}_\\varepsilon(\\phi_6), \\operatorname{sgn}_\\varepsilon(\\psi_6)) = (-1, +1)$\n- 节点 $7: (\\phi_7, \\psi_7) = (+0.05, -0.05) \\implies (\\operatorname{sgn}_\\varepsilon(\\phi_7), \\operatorname{sgn}_\\varepsilon(\\psi_7)) = (+1, -1)$\n- 节点 $8: (\\phi_8, \\psi_8) = (+0.3, +0.4) \\implies (\\operatorname{sgn}_\\varepsilon(\\phi_8), \\operatorname{sgn}_\\varepsilon(\\psi_8)) = (+1, +1)$\n- 节点 $9: (\\phi_9, \\psi_9) = (-0.3, +0.3) \\implies (\\operatorname{sgn}_\\varepsilon(\\phi_9), \\operatorname{sgn}_\\varepsilon(\\psi_9)) = (-1, +1)$\n- 节点 $10: (\\phi_{10}, \\psi_{10}) = (+10^{-8}, -0.4) \\implies (\\operatorname{sgn}_\\varepsilon(\\phi_{10}), \\operatorname{sgn}_\\varepsilon(\\psi_{10})) = (0, -1)$\n- 节点 $11: (\\phi_{11}, \\psi_{11}) = (0.0, 0.0) \\implies (\\operatorname{sgn}_\\varepsilon(\\phi_{11}), \\operatorname{sgn}_\\varepsilon(\\psi_{11})) = (0, 0)$\n\n**阶段 1：单元分类**\n\n我们使用已定义的规则分析每个单元 $e \\in \\{0, \\dots, 5\\}$，这些规则因其结构而是互斥的。\n\n- **单元 $e=0, \\mathcal{N}(0)=\\{0, 1, 2\\}$**：\n  - $S_\\phi(0)=\\{\\operatorname{sgn}_\\varepsilon(\\phi_0), \\operatorname{sgn}_\\varepsilon(\\phi_1), \\operatorname{sgn}_\\varepsilon(\\phi_2)\\} = \\{+1, -1, +1\\}$。\n  - $S_\\psi(0)=\\{\\operatorname{sgn}_\\varepsilon(\\psi_0), \\operatorname{sgn}_\\varepsilon(\\psi_1), \\operatorname{sgn}_\\varepsilon(\\psi_2)\\} = \\{-1, -1, -1\\}$。\n  - $\\text{has\\_sign\\_change}(S_\\phi(0))$ 为真。$\\text{has\\_sign\\_change}(S_\\psi(0))$ 为假。因此，不是尖端单元。\n  - $\\text{all\\_behind\\_tip}(0)$ 为真，因为 $\\max\\{\\psi_0, \\psi_1, \\psi_2\\} = -0.1  -\\varepsilon$。\n  - 适用规则 2：$\\text{has\\_sign\\_change}(S_\\phi)$ 为真且 $\\text{all\\_behind\\_tip}(e)$ 为真。\n  - 分类：**Heaviside 单元 (2)**。\n\n- **单元 $e=1, \\mathcal{N}(1)=\\{2, 5, 6\\}$**：\n  - $S_\\phi(1)=\\{\\operatorname{sgn}_\\varepsilon(\\phi_2), \\operatorname{sgn}_\\varepsilon(\\phi_5), \\operatorname{sgn}_\\varepsilon(\\phi_6)\\} = \\{+1, +1, -1\\}$。\n  - $S_\\psi(1)=\\{\\operatorname{sgn}_\\varepsilon(\\psi_2), \\operatorname{sgn}_\\varepsilon(\\psi_5), \\operatorname{sgn}_\\varepsilon(\\psi_6)\\} = \\{-1, +1, +1\\}$。\n  - $\\text{has\\_sign\\_change}(S_\\phi(1))$ 为真。$\\text{has\\_sign\\_change}(S_\\psi(1))$ 为真。\n  - 适用规则 1。\n  - 分类：**尖端单元 (3)**。\n\n- **单元 $e=2, \\mathcal{N}(2)=\\{2, 4, 5\\}$**：\n  - $S_\\phi(2)=\\{\\operatorname{sgn}_\\varepsilon(\\phi_2), \\operatorname{sgn}_\\varepsilon(\\phi_4), \\operatorname{sgn}_\\varepsilon(\\phi_5)\\} = \\{+1, 0, +1\\}$。\n  - $S_\\psi(2)=\\{\\operatorname{sgn}_\\varepsilon(\\psi_2), \\operatorname{sgn}_\\varepsilon(\\psi_4), \\operatorname{sgn}_\\varepsilon(\\psi_5)\\} = \\{-1, -1, +1\\}$。\n  - $\\text{has\\_sign\\_change}(S_\\phi(2))$ 为假。不是尖端单元或 Heaviside 单元。\n  - 规则 3 检查：对于节点 $j=4$，$|\\phi_4|=0.0 \\le \\varepsilon$ 且 $\\psi_4=-0.3  -\\varepsilon$。条件满足。\n  - 分类：**裂纹单元 (1)**。\n\n- **单元 $e=3, \\mathcal{N}(3)=\\{5, 8, 9\\}$**：\n  - $S_\\phi(3)=\\{\\operatorname{sgn}_\\varepsilon(\\phi_5), \\operatorname{sgn}_\\varepsilon(\\phi_8), \\operatorname{sgn}_\\varepsilon(\\phi_9)\\} = \\{+1, +1, -1\\}$。\n  - $S_\\psi(3)=\\{\\operatorname{sgn}_\\varepsilon(\\psi_5), \\operatorname{sgn}_\\varepsilon(\\psi_8), \\operatorname{sgn}_\\varepsilon(\\psi_9)\\} = \\{+1, +1, +1\\}$。\n  - $\\text{has\\_sign\\_change}(S_\\phi(3))$ 为真，但 $\\text{has\\_sign\\_change}(S_\\psi(3))$ 为假。不是尖端单元。\n  - $\\text{all\\_behind\\_tip}(3)$ 为假，因为 $\\max\\{\\psi_5, \\psi_8, \\psi_9\\} = 0.4  -\\varepsilon$。不是 Heaviside 单元。\n  - 规则 3 检查：没有节点 $j \\in \\{5, 8, 9\\}$ 满足 $|\\phi_j| \\le \\varepsilon$。不是裂纹单元。\n  - 适用规则 4。\n  - 分类：**标准单元 (0)**。\n\n- **单元 $e=4, \\mathcal{N}(4)=\\{0, 2, 7\\}$**：\n  - $S_\\phi(4)=\\{\\operatorname{sgn}_\\varepsilon(\\phi_0), \\operatorname{sgn}_\\varepsilon(\\phi_2), \\operatorname{sgn}_\\varepsilon(\\phi_7)\\} = \\{+1, +1, +1\\}$。\n  - $S_\\psi(4)=\\{\\operatorname{sgn}_\\varepsilon(\\psi_0), \\operatorname{sgn}_\\varepsilon(\\psi_2), \\operatorname{sgn}_\\varepsilon(\\psi_7)\\} = \\{-1, -1, -1\\}$。\n  - $\\text{has\\_sign\\_change}(S_\\phi(4))$ 为假。不是尖端单元或 Heaviside 单元。\n  - 规则 3 检查：没有节点 $j \\in \\{0, 2, 7\\}$ 满足 $|\\phi_j| \\le \\varepsilon$。不是裂纹单元。\n  - 适用规则 4。\n  - 分类：**标准单元 (0)**。\n\n- **单元 $e=5, \\mathcal{N}(5)=\\{2, 6, 11\\}$**：\n  - $S_\\phi(5)=\\{\\operatorname{sgn}_\\varepsilon(\\phi_2), \\operatorname{sgn}_\\varepsilon(\\phi_6), \\operatorname{sgn}_\\varepsilon(\\phi_{11})\\} = \\{+1, -1, 0\\}$。\n  - $S_\\psi(5)=\\{\\operatorname{sgn}_\\varepsilon(\\psi_2), \\operatorname{sgn}_\\varepsilon(\\psi_6), \\operatorname{sgn}_\\varepsilon(\\psi_{11})\\} = \\{-1, +1, 0\\}$。\n  - $\\text{has\\_sign\\_change}(S_\\phi(5))$ 为真。$\\text{has\\_sign\\_change}(S_\\psi(5))$ 为真。\n  - 适用规则 1。\n  - 分类：**尖端单元 (3)**。\n\n得到的单元分类列表为 $[2, 3, 1, 0, 0, 3]$。\n\n**阶段 2：节点分类**\n\n我们根据具有优先顺序的规则对每个节点 $i \\in \\{0, \\dots, 11\\}$ 进行分类。为方便起见，首先构建一个从节点到其所属单元的映射。\n- 尖端单元是 $\\{1, 5\\}$。\n- Heaviside 单元是 $\\{0\\}$。\n\n- **节点 0**：位于单元 $\\{0, 4\\}$ 中。规则 1 (尖端)：否。规则 2 (裂纹, $|\\phi_0| \\le \\varepsilon \\land \\psi_0  -\\varepsilon $)：否 ($|\\phi_0|=0.3$)。规则 3 (Heaviside)：是，在单元 0 中。分类：**Heaviside (2)**。\n- **节点 1**：位于单元 $\\{0\\}$ 中。规则 1 (尖端)：否。规则 2 (裂纹)：否 ($|\\phi_1|=0.4$)。规则 3 (Heaviside)：是，在单元 0 中。分类：**Heaviside (2)**。\n- **节点 2**：位于单元 $\\{0, 1, 2, 4, 5\\}$ 中。规则 1 (尖端)：是，在单元 1 和 5 中。分类：**尖端 (3)**。\n- **节点 3**：不属于任何单元。规则 1：否。规则 2：否 ($|\\phi_3|=0.1$)。规则 3：否。规则 4：是。分类：**标准 (0)**。\n- **节点 4**：位于单元 $\\{2\\}$ 中。规则 1：否。规则 2：是 ($|\\phi_4|=0.0 \\le \\varepsilon$ 且 $\\psi_4=-0.3  -\\varepsilon$)。分类：**裂纹 (1)**。\n- **节点 5**：位于单元 $\\{1, 2, 3\\}$ 中。规则 1：是，在单元 1 中。分类：**尖端 (3)**。\n- **节点 6**：位于单元 $\\{1, 5\\}$ 中。规则 1：是，在单元 1 和 5 中。分类：**尖端 (3)**。\n- **节点 7**：位于单元 $\\{4\\}$ 中。规则 1：否。规则 2：否 ($|\\phi_7|=0.05$)。规则 3：否。规则 4：是。分类：**标准 (0)**。\n- **节点 8**：位于单元 $\\{3\\}$ 中。规则 1：否。规则 2：否 ($|\\phi_8|=0.3$)。规则 3：否。规则 4：是。分类：**标准 (0)**。\n- **节点 9**：位于单元 $\\{3\\}$ 中。规则 1：否。规则 2：否 ($|\\phi_9|=0.3$)。规则 3：否。规则 4：是。分类：**标准 (0)**。\n- **节点 10**：不属于任何单元。规则 1：否。规则 2：是 ($|\\phi_{10}|=10^{-8} \\le \\varepsilon$ 且 $\\psi_{10}=-0.4  -\\varepsilon$)。分类：**裂纹 (1)**。\n- **节点 11**：位于单元 $\\{5\\}$ 中。规则 1：是，在单元 5 中。分类：**尖端 (3)**。\n\n得到的节点分类列表为 $[2, 2, 3, 0, 1, 3, 3, 0, 0, 0, 1, 3]$。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements XFEM element and node classification based on level-set values.\n    \"\"\"\n    # Define problem data\n    TOL = 1e-7\n    NODES = np.array([\n        [+0.3,   -0.5],    # 0\n        [-0.4,   -0.6],    # 1\n        [+0.2,   -0.1],    # 2\n        [-0.1,   -0.2],    # 3\n        [0.0,    -0.3],    # 4\n        [+0.2,   +0.1],    # 5\n        [-0.2,   +0.2],    # 6\n        [+0.05,  -0.05],   # 7\n        [+0.3,   +0.4],    # 8\n        [-0.3,   +0.3],    # 9\n        [1e-8,   -0.4],    # 10\n        [0.0,    0.0],     # 11\n    ])\n    ELEMENTS = [\n        [0, 1, 2],  # 0\n        [2, 5, 6],  # 1\n        [2, 4, 5],  # 2\n        [5, 8, 9],  # 3\n        [0, 2, 7],  # 4\n        [2, 6, 11], # 5\n    ]\n\n    # --- Helper functions ---\n    def sgn_eps(a, eps):\n        if a  -eps:\n            return -1\n        if a > eps:\n            return 1\n        return 0\n\n    def has_sign_change(s):\n        return min(s) == -1 and max(s) == 1\n\n    def all_behind_tip(psi_vals, eps):\n        return max(psi_vals)  -eps\n\n    # --- Stage 1: Element Classification ---\n    elem_classifications = []\n    \n    for e_idx, node_indices in enumerate(ELEMENTS):\n        phi_vals = NODES[node_indices, 0]\n        psi_vals = NODES[node_indices, 1]\n\n        s_phi = {sgn_eps(p, TOL) for p in phi_vals}\n        s_psi = {sgn_eps(p, TOL) for p in psi_vals}\n\n        is_tip = has_sign_change(s_phi) and has_sign_change(s_psi)\n        \n        if is_tip:\n            elem_classifications.append(3) # Tip element\n            continue\n\n        is_heaviside = has_sign_change(s_phi) and all_behind_tip(psi_vals, TOL)\n        \n        if is_heaviside:\n            elem_classifications.append(2) # Heaviside element\n            continue\n\n        is_cracked = False\n        for node_idx in node_indices:\n            phi_node, psi_node = NODES[node_idx]\n            if abs(phi_node) = TOL and psi_node  -TOL:\n                is_cracked = True\n                break\n        \n        if is_cracked:\n            elem_classifications.append(1) # Cracked element\n        else:\n            elem_classifications.append(0) # Standard element\n\n    # --- Stage 2: Node Classification ---\n    \n    # Build a map from node index to a list of elements it belongs to\n    num_nodes = len(NODES)\n    node_to_elems = {i: [] for i in range(num_nodes)}\n    for e_idx, node_indices in enumerate(ELEMENTS):\n        for n_idx in node_indices:\n            node_to_elems[n_idx].append(e_idx)\n            \n    node_classifications = []\n    \n    for i in range(num_nodes):\n        # Rule 1: Tip node (belongs to at least one tip element)\n        is_tip_node = False\n        if i in node_to_elems:\n            for e_idx in node_to_elems[i]:\n                if elem_classifications[e_idx] == 3:\n                    is_tip_node = True\n                    break\n        if is_tip_node:\n            node_classifications.append(3)\n            continue\n            \n        # Rule 2: Cracked node (based on its own level-set values)\n        phi_i, psi_i = NODES[i]\n        is_cracked_node = abs(phi_i) = TOL and psi_i  -TOL\n        if is_cracked_node:\n            node_classifications.append(1)\n            continue\n            \n        # Rule 3: Heaviside node (belongs to at least one Heaviside element)\n        is_heaviside_node = False\n        if i in node_to_elems:\n            for e_idx in node_to_elems[i]:\n                if elem_classifications[e_idx] == 2:\n                    is_heaviside_node = True\n                    break\n        if is_heaviside_node:\n            node_classifications.append(2)\n            continue\n            \n        # Rule 4: Standard node (otherwise)\n        node_classifications.append(0)\n    \n    # Final output formatting\n    elem_str = ','.join(map(str, elem_classifications))\n    node_str = ','.join(map(str, node_classifications))\n    print(f\"[[{elem_str}],[{node_str}]]\")\n\nsolve()\n```", "id": "2637826"}, {"introduction": "识别出富集单元后，下一步是构建它们对全局刚度矩阵的贡献。本练习深入探讨了XFEM的核心，展示了Heaviside富集如何改变单元的應變-位移关系，并在刚度矩阵中引入新的耦合项，特别是标准自由度与富集自由度之间的耦合。通过这个练习，您可以理解富集是如何在代数层面影响有限元系统的。[@problem_id:2637785]", "problem": "一个处于平面应变状态的二维、均匀、各向同性的线性弹性体，使用边长为 $a$、单位厚度为 $t=1$ 的四节点双线性四边形单元进行离散。该单元与全局坐标轴对齐，占据 $[0,a]\\times[0,a]$ 的正方形区域。材料的杨氏模量为 $E$，泊松比为 $\\nu$。该单元被一条无牵引力的直线裂纹切割，使得单元面积的 $f_{-}$ 部分位于裂纹的负侧，剩余的 $f_{+}=1-f_{-}$ 部分位于裂纹的正侧，其中 Heaviside 增强函数 $H(\\boldsymbol{x})$ 分别等于 $-1$ 和 $+1$。节点1处的 Heaviside 值为 $H_{1}=+1$（即节点1位于正侧）。\n\n采用扩展有限元法 (XFEM) 的位移近似使用了基于 Heaviside 增强的单位分解。对于标准节点位移 $\\{\\boldsymbol{u}_{i}\\}$ 和增强自由度 (DOF) $\\{\\boldsymbol{a}_{j}\\}$，增强位移场为\n$$\n\\boldsymbol{u}(\\boldsymbol{x})=\\sum_{i=1}^{4} N_{i}(\\boldsymbol{x})\\,\\boldsymbol{u}_{i}+\\sum_{j\\in\\mathcal{J}} N_{j}(\\boldsymbol{x})\\big(H(\\boldsymbol{x})-H_{j}\\big)\\,\\boldsymbol{a}_{j},\n$$\n其中 $\\mathcal{J}$ 是 Heaviside 增强节点的集合，$N_{i}$ 是双线性形函数。小应变张量满足\n$$\n\\boldsymbol{\\varepsilon}(\\boldsymbol{x})=\\mathcal{L}\\,\\boldsymbol{u}(\\boldsymbol{x}),\n$$\n其中微分算子 $\\mathcal{L}$ 以平面应变的常规方式将位移映射到应变。本构关系为 $\\boldsymbol{\\sigma}=\\boldsymbol{D}\\,\\boldsymbol{\\varepsilon}$，其中 $\\boldsymbol{D}$ 是平面应变弹性矩阵。忽略 $H(\\boldsymbol{x})$ 的分布梯度（该梯度仅在裂纹线上有支撑，并且对无牵引力裂纹的区域刚度没有贡献），该单元在 $H(\\boldsymbol{x})$ 为常数的两个不相交子域的并集上进行积分。\n\n任务：\n1. 从线性弹性的弱形式出发，用应变-位移矩阵的形式，陈述耦合标准自由度和增强自由度的单元刚度贡献项，并写出在 $H(\\boldsymbol{x})$ 为常数的子域上节点 $i$ 的应变-位移矩阵 $\\boldsymbol{B}_{i}^{\\mathrm{std}}$ 和 $\\boldsymbol{B}_{i}^{H}$。明确指出 Heaviside 增强如何在每个子域上修正应变-位移关系。\n2. 考虑一个单一的 Heaviside 增强节点 $i=1$，计算耦合节点1的标准x自由度与节点1的增强x自由度的单元刚度矩阵标量项，记为 $K_{(1x),(1a_{x})}^{(e)}$。在每个子域上使用单点积分，其中应变-位移矩阵在单元形心处进行计算。单元边长为 $a=10\\,\\mathrm{mm}$，$E=210\\times 10^{3}\\,\\mathrm{N/mm}^{2}$，$\\nu=0.30$，$f_{-}=0.40$，$t=1\\,\\mathrm{mm}$。最终答案以 $\\mathrm{N/mm}$ 为单位表示，并四舍五入至四位有效数字。\n\n边长为 $a$ 的正方形上双线性形函数形心梯度的有用数据：在形心处，节点1的导数为\n$$\n\\frac{\\partial N_{1}}{\\partial x}=-\\frac{1}{2a},\\qquad \\frac{\\partial N_{1}}{\\partial y}=-\\frac{1}{2a}.\n$$", "solution": "该问题要求在扩展有限元法 (XFEM) 的背景下，对一个用 Heaviside 函数增强的四边形单元的刚度矩阵进行分析。首先，验证问题的正确性，并在确认其有效后，推导出解答。\n\n问题陈述提出了两个任务。第一个是概念性的，要求推导耦合刚度项并确定应变-位移矩阵。第二个是刚度矩阵分量的具体计算。\n\n对于第一个任务，我们从虚功原理开始。一个单元的内虚功由下式给出\n$$ \\delta W_{\\text{int}}^{(e)} = \\int_{\\Omega^{(e)}} \\delta\\boldsymbol{\\varepsilon}^{T} \\boldsymbol{\\sigma} \\, d\\Omega $$\n其中 $\\boldsymbol{\\sigma}$ 是应力张量，$\\delta\\boldsymbol{\\varepsilon}$ 是虚应变张量，$\\Omega^{(e)}$ 是单元域。使用线性弹性本构关系 $\\boldsymbol{\\sigma} = \\boldsymbol{D} \\boldsymbol{\\varepsilon}$，上式变为\n$$ \\delta W_{\\text{int}}^{(e)} = \\int_{\\Omega^{(e)}} \\delta\\boldsymbol{\\varepsilon}^{T} \\boldsymbol{D} \\boldsymbol{\\varepsilon} \\, d\\Omega $$\n位移场 $\\boldsymbol{u}(\\boldsymbol{x})$ 和虚位移场 $\\delta\\boldsymbol{u}(\\boldsymbol{x})$ 使用 XFEM 单位分解框架进行近似：\n$$ \\boldsymbol{u}(\\boldsymbol{x})=\\sum_{i=1}^{4} N_{i}(\\boldsymbol{x})\\,\\boldsymbol{u}_{i}+\\sum_{j\\in\\mathcal{J}} N_{j}(\\boldsymbol{x})\\big(H(\\boldsymbol{x})-H_{j}\\big)\\,\\boldsymbol{a}_{j} $$\n$$ \\delta\\boldsymbol{u}(\\boldsymbol{x})=\\sum_{i=1}^{4} N_{i}(\\boldsymbol{x})\\,\\delta\\boldsymbol{u}_{i}+\\sum_{j\\in\\mathcal{J}} N_{j}(\\boldsymbol{x})\\big(H(\\boldsymbol{x})-H_{j}\\big)\\,\\delta\\boldsymbol{a}_{j} $$\n此处，$\\boldsymbol{u}_i$ 是标准节点位移，$\\boldsymbol{a}_j$ 是增强节点集合 $\\mathcal{J}$ 的增强自由度 (DOF)。应变场 $\\boldsymbol{\\varepsilon} = \\mathcal{L}\\boldsymbol{u}$ 是通过应用对称梯度算子 $\\mathcal{L}$ 得到的。关键的是，问题陈述要求忽略 $H(\\boldsymbol{x})$ 梯度的分布部分，这对于无牵引力裂纹是一个标准处理程序。因此，$\\nabla(N_j(H-H_j)) \\approx (\\nabla N_j)(H-H_j)$。这导出了应变场：\n$$ \\boldsymbol{\\varepsilon}(\\boldsymbol{x}) \\approx \\sum_{i=1}^{4} (\\mathcal{L}N_i) \\boldsymbol{u}_i + \\sum_{j\\in\\mathcal{J}} (H(\\boldsymbol{x})-H_j) (\\mathcal{L}N_j) \\boldsymbol{a}_j $$\n这可以写成矩阵形式：\n$$ \\boldsymbol{\\varepsilon}(\\boldsymbol{x}) = \\sum_{i=1}^{4} \\boldsymbol{B}_{i}^{\\mathrm{std}} \\boldsymbol{u}_i + \\sum_{j\\in\\mathcal{J}} (H(\\boldsymbol{x})-H_j) \\boldsymbol{B}_{j}^{\\mathrm{std}} \\boldsymbol{a}_j $$\n其中 $\\boldsymbol{B}_{i}^{\\mathrm{std}}$ 是节点 $i$ 的标准应变-位移矩阵：\n$$ \\boldsymbol{B}_{i}^{\\mathrm{std}}(\\boldsymbol{x}) = \\begin{pmatrix} \\frac{\\partial N_{i}}{\\partial x}  0 \\\\ 0  \\frac{\\partial N_{i}}{\\partial y} \\\\ \\frac{\\partial N_{i}}{\\partial y}  \\frac{\\partial N_{i}}{\\partial x} \\end{pmatrix} $$\n节点 $j$ 处增强自由度对应变的贡献由 $\\boldsymbol{B}_{j}^{H}\\boldsymbol{a}_j$ 给出。从上面的应变表达式，我们确定在 $H(\\boldsymbol{x})$ 为常数的任何子域上的增强应变-位移矩阵为：\n$$ \\boldsymbol{B}_{j}^{H}(\\boldsymbol{x}) = \\big(H(\\boldsymbol{x}) - H_j\\big) \\boldsymbol{B}_{j}^{\\mathrm{std}}(\\boldsymbol{x}) $$\nHeaviside 增强通过用分段常数因子 $(H(\\boldsymbol{x}) - H_j)$ 缩放标准 $\\boldsymbol{B}$ 矩阵，从而修正了应变-位移关系。\n\n将离散化的应变和虚应变代入内功表达式，得到单元刚度矩阵。节点 $i$ 的标准自由度 ($\\boldsymbol{u}_i$) 和节点 $j$ 的增强自由度 ($\\boldsymbol{a}_j$) 之间的耦合子矩阵由虚功表达式中的交叉项 $\\int_{\\Omega^{(e)}} (\\delta\\boldsymbol{\\varepsilon}^{\\text{std},i})^T \\boldsymbol{D} \\boldsymbol{\\varepsilon}^{\\text{enr},j} \\, d \\Omega$ 推导得出。这给出了所要求的刚度贡献项：\n$$ \\boldsymbol{K}_{ij}^{\\mathrm{std}-H} = \\int_{\\Omega^{(e)}} (\\boldsymbol{B}_{i}^{\\mathrm{std}})^T \\boldsymbol{D} \\boldsymbol{B}_{j}^{H} \\, t \\, dA = \\int_{\\Omega^{(e)}} \\big(H(\\boldsymbol{x}) - H_j\\big) (\\boldsymbol{B}_{i}^{\\mathrm{std}})^T \\boldsymbol{D} \\boldsymbol{B}_{j}^{\\mathrm{std}} \\, t \\, dA $$\n这就完成了第一个任务。\n\n对于第二个任务，我们必须计算特定的刚度项 $K_{(1x),(1a_{x})}^{(e)}$，它耦合了节点1的标准x自由度和节点1的增强x自由度。因此相关节点为 $i=j=1$。刚度子矩阵为：\n$$ \\boldsymbol{K}_{11}^{\\mathrm{std}-H} = \\int_{\\Omega^{(e)}} \\big(H(\\boldsymbol{x}) - H_1\\big) (\\boldsymbol{B}_{1}^{\\mathrm{std}})^T \\boldsymbol{D} \\boldsymbol{B}_{1}^{\\mathrm{std}} \\, t \\, dA $$\n区域 $\\Omega^{(e)}$ 被分成两个子域：$H(\\boldsymbol{x})=-1$ 的 $\\Omega_{-}^{(e)}$ 和 $H(\\boldsymbol{x})=+1$ 的 $\\Omega_{+}^{(e)}$。已知 $H_1 = +1$。该积分变为：\n$$ \\boldsymbol{K}_{11}^{\\mathrm{std}-H} = \\int_{\\Omega_{-}^{(e)}} (-1 - 1) (\\boldsymbol{B}_{1}^{\\mathrm{std}})^T \\boldsymbol{D} \\boldsymbol{B}_{1}^{\\mathrm{std}} \\, t \\, dA + \\int_{\\Omega_{+}^{(e)}} (+1 - 1) (\\boldsymbol{B}_{1}^{\\mathrm{std}})^T \\boldsymbol{D} \\boldsymbol{B}_{1}^{\\mathrm{std}} \\, t \\, dA $$\n在 $\\Omega_{+}^{(e)}$ 上的积分为零。这简化为：\n$$ \\boldsymbol{K}_{11}^{\\mathrm{std}-H} = -2 \\int_{\\Omega_{-}^{(e)}} (\\boldsymbol{B}_{1}^{\\mathrm{std}})^T \\boldsymbol{D} \\boldsymbol{B}_{1}^{\\mathrm{std}} \\, t \\, dA $$\n我们对该积分在单元形心 $\\boldsymbol{x}_c$ 处使用单点积分。子域 $\\Omega_{-}^{(e)}$ 的面积为 $A_{-} = f_{-} A_{\\text{elem}} = f_{-} a^2$。其近似值为：\n$$ \\boldsymbol{K}_{11}^{\\mathrm{std}-H} \\approx -2 \\, t \\, (f_{-} a^2) \\left[ (\\boldsymbol{B}_{1}^{\\mathrm{std}})^T \\boldsymbol{D} \\boldsymbol{B}_{1}^{\\mathrm{std}} \\right]_{\\boldsymbol{x}_c} $$\n项 $K_{(1x),(1a_{x})}^{(e)}$ 是这个 $2 \\times 2$ 矩阵的 $(1,1)$ 分量。设矩阵乘积为 $\\boldsymbol{M} = (\\boldsymbol{B}_{1}^{\\mathrm{std}})^T \\boldsymbol{D} \\boldsymbol{B}_{1}^{\\mathrm{std}}$。我们要求解分量 $M_{11}$。\n平面应变的弹性矩阵 $\\boldsymbol{D}$ 为：\n$$ \\boldsymbol{D} = \\frac{E}{(1+\\nu)(1-2\\nu)} \\begin{pmatrix} 1-\\nu  \\nu  0 \\\\ \\nu  1-\\nu  0 \\\\ 0  0  \\frac{1-2\\nu}{2} \\end{pmatrix} $$\n令 $D_{11} = \\frac{E(1-\\nu)}{(1+\\nu)(1-2\\nu)}$ 且 $D_{33} = \\frac{E}{2(1+\\nu)}$。\n在形心处，使用给定的导数 $\\frac{\\partial N_1}{\\partial x} = -\\frac{1}{2a}$ 和 $\\frac{\\partial N_1}{\\partial y} = -\\frac{1}{2a}$，B矩阵为：\n$$ \\boldsymbol{B}_{1}^{\\mathrm{std}}|_{\\boldsymbol{x}_c} = \\begin{pmatrix} -1/(2a)  0 \\\\ 0  -1/(2a) \\\\ -1/(2a)  -1/(2a) \\end{pmatrix} $$\n乘积 $\\boldsymbol{M}$ 的 $(1,1)$ 分量是：\n$$ M_{11} = \\left( \\frac{\\partial N_1}{\\partial x} \\right)^2 D_{11} + \\left( \\frac{\\partial N_1}{\\partial y} \\right)^2 D_{33} = \\left(-\\frac{1}{2a}\\right)^2 D_{11} + \\left(-\\frac{1}{2a}\\right)^2 D_{33} = \\frac{1}{4a^2} (D_{11} + D_{33}) $$\n将此代入 $K_{(1x),(1a_{x})}^{(e)}$ 的表达式中：\n$$ K_{(1x),(1a_{x})}^{(e)} \\approx -2 \\, t \\, (f_{-} a^2) \\left[ \\frac{1}{4a^2} (D_{11} + D_{33}) \\right] = - \\frac{1}{2} f_{-} t (D_{11} + D_{33}) $$\n正如预期的，$a^2$ 项被消去。现在我们合并 $(D_{11} + D_{33})$ 的项：\n$$ D_{11} + D_{33} = \\frac{E(1-\\nu)}{(1+\\nu)(1-2\\nu)} + \\frac{E}{2(1+\\nu)} = \\frac{E}{(1+\\nu)} \\left( \\frac{2(1-\\nu) + (1-2\\nu)}{2(1-2\\nu)} \\right) = \\frac{E(3-4\\nu)}{2(1+\\nu)(1-2\\nu)} $$\n刚度分量的最终符号表达式为：\n$$ K_{(1x),(1a_{x})}^{(e)} = - \\frac{1}{2} f_{-} t \\left( \\frac{E(3-4\\nu)}{2(1+\\nu)(1-2\\nu)} \\right) = - \\frac{E f_{-} t (3-4\\nu)}{4(1+\\nu)(1-2\\nu)} $$\n现在，我们代入给定的数值：$E=210\\times 10^{3}\\,\\mathrm{N/mm}^{2}$，$\\nu=0.30$，$f_{-}=0.40$ 和 $t=1\\,\\mathrm{mm}$。\n$$ K_{(1x),(1a_{x})}^{(e)} = - \\frac{(210 \\times 10^{3}) (0.40) (1) (3 - 4 \\times 0.30)}{4(1+0.30)(1 - 2 \\times 0.30)} $$\n$$ K_{(1x),(1a_{x})}^{(e)} = - \\frac{(210 \\times 10^{3}) (0.40) (1.8)}{4(1.3)(0.4)} = - \\frac{151200}{2.08} \\approx -72692.30769 \\, \\mathrm{N/mm} $$\n将结果四舍五入到四位有效数字，得到 $-72690 \\, \\mathrm{N/mm}$。", "answer": "$$\\boxed{-72690}$$", "id": "2637785"}, {"introduction": "一个完整的有限元模型不仅需要刚度矩阵，还需要一致的载荷向量。本练习解决了在一个被裂纹部分穿透的边界上施加外部牵引力（Neumann边界条件）的实际挑战，确保在物理加载的边界段上能够准确地计算虚功。掌握这项技能对于在XFEM中正确模拟外部载荷至关重要。[@problem_id:2637765]", "problem": "考虑一个二维小应变线性弹性体，其通过线性有限元进行离散化，并利用扩展有限元法 (XFEM) 中的 Heaviside 增强来表示一个无牵引力裂纹。设某一边界边是长度为 $L$ 的直线段，由弧长坐标 $s \\in [0, L]$ 参数化，其在 $s=0$ 和 $s=L$ 处有两个节点。一个均匀的指定牵引力 $\\mathbf{t}(s) = t_{0}\\,\\mathbf{e}_{y}$ 作为 Neumann 边界条件作用于该边，其中 $t_{0}  0$ 是一个常数，$\\mathbf{e}_{y}$ 是 $y$ 方向的单位向量。\n\n一条直线裂纹在该边的 $s = s_{a}$ 和 $s = s_{b}$ 两点处与之相交，其中 $0 \\leq s_{a}  s_{b} \\leq L$。中间子段 $[s_{a}, s_{b}]$ 是新生成的裂纹口，且无牵引力；因此，Neumann 牵引力仅施加在可见的子段 $[0, s_{a}] \\cup [s_{b}, L]$ 上。沿该边的有限元插值使用与两个边界节点相关的标准线性边形函数 $N_{1}(s) = 1 - \\frac{s}{L}$ 和 $N_{2}(s) = \\frac{s}{L}$，以及每个节点的标准两个平移自由度 $(x,y)$。假设父单元中存在 Heaviside 增强，但对于此外边界牵引力，没有外部牵引力施加到增强自由度上。\n\n从线性弹性的虚功原理和 Neumann 边界条件的一致性载荷向量的定义出发，推导该边界边对全局系统贡献的 $4 \\times 1$ 单元一致性节点载荷向量的闭式表达式，其顺序为 $\\left[r_{1x},\\, r_{1y},\\, r_{2x},\\, r_{2y}\\right]^{\\mathsf{T}}$，并用 $L$、$s_{a}$、$s_{b}$ 和 $t_{0}$ 表示。您的推导必须明确说明裂纹对边界的部分移除，并论证在存在 XFEM 增强的情况下，该公式如何避免重复计算或遗漏牵引力功。\n\n请将您的最终答案表示为单个解析表达式。无需进行数值计算或四舍五入。最终表达式中不要包含物理单位。如果出现角度，应以弧度为单位。", "solution": "该问题是有效的，因为它在科学上基于线性弹性和有限元法，问题提法是适定的，具有完整且一致的给定条件，并以客观、正式的语言表述。我们可以着手求解。\n\n一致性节点载荷向量 $\\mathbf{r}$ 的推导始于虚功原理。由指定牵引力向量 $\\mathbf{t}$ 在边界 $\\Gamma_t$ 上所做的外虚功 $\\delta W_{ext}$ 由下式给出：\n$$ \\delta W_{ext} = \\int_{\\Gamma_t} \\mathbf{t} \\cdot \\delta\\mathbf{u} \\, d\\Gamma $$\n在有限元法的背景下，虚位移场 $\\delta\\mathbf{u}$ 是通过形函数从虚拟节点位移 $\\delta\\mathbf{d}$ 插值得到的。问题指明，为了计算此外功贡献，我们只考虑标准的、未增强的自由度。因此，沿边界边的位移场使用标准线性形函数 $N_1(s)$ 和 $N_2(s)$ 进行近似：\n$$ \\mathbf{u}(s) = \\begin{pmatrix} u_x(s) \\\\ u_y(s) \\end{pmatrix} = \\begin{pmatrix} N_1(s)  0 \\\\ 0  N_1(s) \\end{pmatrix} \\begin{pmatrix} d_{1x} \\\\ d_{1y} \\end{pmatrix} + \\begin{pmatrix} N_2(s)  0 \\\\ 0  N_2(s) \\end{pmatrix} \\begin{pmatrix} d_{2x} \\\\ d_{2y} \\end{pmatrix} $$\n这可以写成矩阵形式 $\\mathbf{u}(s) = \\mathbf{N}(s) \\mathbf{d}$，其中 $\\mathbf{d} = \\left[d_{1x}, d_{1y}, d_{2x}, d_{2y}\\right]^{\\mathsf{T}}$ 是节点位移向量，$\\mathbf{N}(s)$ 是形函数矩阵：\n$$ \\mathbf{N}(s) = \\begin{pmatrix} N_1(s)  0  N_2(s)  0 \\\\ 0  N_1(s)  0  N_2(s) \\end{pmatrix} $$\n虚位移为 $\\delta\\mathbf{u}(s) = \\mathbf{N}(s) \\delta\\mathbf{d}$。将其代入虚功表达式，我们得到：\n$$ \\delta W_{ext} = \\int_{\\Gamma_t} \\mathbf{t}^{\\mathsf{T}} (\\mathbf{N}(s) \\delta\\mathbf{d}) \\, ds = \\delta\\mathbf{d}^{\\mathsf{T}} \\int_{\\Gamma_t} \\mathbf{N}(s)^{\\mathsf{T}} \\mathbf{t} \\, ds $$\n根据定义，$\\delta W_{ext} = \\delta\\mathbf{d}^{\\mathsf{T}} \\mathbf{r}$，其中 $\\mathbf{r}$ 是一致性节点载荷向量。因此，\n$$ \\mathbf{r} = \\int_{\\Gamma_t} \\mathbf{N}(s)^{\\mathsf{T}} \\mathbf{t}(s) \\, ds $$\n问题指出，牵引力 $\\mathbf{t}(s) = t_0 \\, \\mathbf{e}_y$ 仅施加在子段 $[0, s_a] \\cup [s_b, L]$ 上。因此，积分域 $\\Gamma_t$ 是这两个区间的并集。积分必须相应地拆分：\n$$ \\mathbf{r} = \\int_{0}^{s_a} \\mathbf{N}(s)^{\\mathsf{T}} \\mathbf{t}(s) \\, ds + \\int_{s_b}^{L} \\mathbf{N}(s)^{\\mathsf{T}} \\mathbf{t}(s) \\, ds $$\n向量和矩阵如下所示：\n$$ \\mathbf{t}(s) = \\begin{pmatrix} 0 \\\\ t_0 \\end{pmatrix}, \\quad N_1(s) = 1 - \\frac{s}{L}, \\quad N_2(s) = \\frac{s}{L} $$\n形函数矩阵的转置是：\n$$ \\mathbf{N}(s)^{\\mathsf{T}} = \\begin{pmatrix} N_1(s)  0 \\\\ 0  N_1(s) \\\\ N_2(s)  0 \\\\ 0  N_2(s) \\end{pmatrix} = \\begin{pmatrix} 1 - \\frac{s}{L}  0 \\\\ 0  1 - \\frac{s}{L} \\\\ \\frac{s}{L}  0 \\\\ 0  \\frac{s}{L} \\end{pmatrix} $$\n被积函数变为：\n$$ \\mathbf{N}(s)^{\\mathsf{T}} \\mathbf{t}(s) = \\begin{pmatrix} 1 - \\frac{s}{L}  0 \\\\ 0  1 - \\frac{s}{L} \\\\ \\frac{s}{L}  0 \\\\ 0  \\frac{s}{L} \\end{pmatrix} \\begin{pmatrix} 0 \\\\ t_0 \\end{pmatrix} = t_0 \\begin{pmatrix} 0 \\\\ 1 - \\frac{s}{L} \\\\ 0 \\\\ \\frac{s}{L} \\end{pmatrix} $$\n载荷向量 $\\mathbf{r} = \\left[r_{1x}, r_{1y}, r_{2x}, r_{2y}\\right]^{\\mathsf{T}}$ 的分量是通过在指定域上对此向量的分量进行积分来计算的。\n如纯 $y$ 方向牵引力所预期的，$x$ 方向的分量为零：\n$$ r_{1x} = \\int_{\\Gamma_t} 0 \\, ds = 0 $$\n$$ r_{2x} = \\int_{\\Gamma_t} 0 \\, ds = 0 $$\n作用在节点 $1$ 上 $y$ 方向的力 $r_{1y}$ 为：\n$$ r_{1y} = \\int_{0}^{s_a} t_0 \\left(1 - \\frac{s}{L}\\right) ds + \\int_{s_b}^{L} t_0 \\left(1 - \\frac{s}{L}\\right) ds $$\n$$ r_{1y} = t_0 \\left[ s - \\frac{s^2}{2L} \\right]_{0}^{s_a} + t_0 \\left[ s - \\frac{s^2}{2L} \\right]_{s_b}^{L} $$\n$$ r_{1y} = t_0 \\left( \\left(s_a - \\frac{s_a^2}{2L}\\right) - 0 \\right) + t_0 \\left( \\left(L - \\frac{L^2}{2L}\\right) - \\left(s_b - \\frac{s_b^2}{2L}\\right) \\right) $$\n$$ r_{1y} = t_0 \\left( s_a - \\frac{s_a^2}{2L} + \\frac{L}{2} - s_b + \\frac{s_b^2}{2L} \\right) = \\frac{t_0}{2L} \\left( 2Ls_a - s_a^2 + L^2 - 2Ls_b + s_b^2 \\right) $$\n$$ r_{1y} = \\frac{t_0}{2L} \\left( L^2 - 2L(s_b - s_a) + s_b^2 - s_a^2 \\right) $$\n作用在节点 $2$ 上 $y$ 方向的力 $r_{2y}$ 为：\n$$ r_{2y} = \\int_{0}^{s_a} t_0 \\left(\\frac{s}{L}\\right) ds + \\int_{s_b}^{L} t_0 \\left(\\frac{s}{L}\\right) ds $$\n$$ r_{2y} = t_0 \\left[ \\frac{s^2}{2L} \\right]_{0}^{s_a} + t_0 \\left[ \\frac{s^2}{2L} \\right]_{s_b}^{L} $$\n$$ r_{2y} = t_0 \\left( \\frac{s_a^2}{2L} - 0 \\right) + t_0 \\left( \\frac{L^2}{2L} - \\frac{s_b^2}{2L} \\right) $$\n$$ r_{2y} = \\frac{t_0}{2L} \\left( s_a^2 + L^2 - s_b^2 \\right) $$\n\n裂纹对边界的部分移除通过为外功计算正确定义积分域 $\\Gamma_t = [0, s_a] \\cup [s_b, L]$ 来体现。裂纹口段 $[s_a, s_b]$ 无牵引力，因此对功积分为零。\n\n该公式避免了重复计算或遗漏功，因为其计算基于 FEM 中的标准、一致性程序。外牵引力所做的功通过在牵引力非零的精确边界段上积分来完全计算。然后，通过虚功原理将产生的功一致性地分配到节点自由度上。问题指出，牵引力功仅与标准自由度相关，这意味着增强自由度没有直接施加的外部节点力。这是一个常见且物理上合理的假设，即外部宏观载荷作用于由标准 FEM 节点表示的体材料连续体上，而不是作用于裂纹面增强的数学抽象上。裂纹的几何存在通过调整积分限完全捕捉，而运动学增强（Heaviside 函数）按照指示被正确地从外部载荷向量计算中排除，从而防止任何形式的重复计算或功的错误归属。\n\n最终组装的载荷向量为：\n$$ \\mathbf{r} = \\begin{pmatrix} 0 \\\\ \\frac{t_0}{2L} (L^2 - 2L(s_b - s_a) + s_b^2 - s_a^2) \\\\ 0 \\\\ \\frac{t_0}{2L} (L^2 + s_a^2 - s_b^2) \\end{pmatrix} $$", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n0 \\\\\n\\frac{t_0}{2L} (L^2 - 2L(s_b - s_a) + s_b^2 - s_a^2) \\\\\n0 \\\\\n\\frac{t_0}{2L} (L^2 + s_a^2 - s_b^2)\n\\end{pmatrix}\n}\n$$", "id": "2637765"}]}