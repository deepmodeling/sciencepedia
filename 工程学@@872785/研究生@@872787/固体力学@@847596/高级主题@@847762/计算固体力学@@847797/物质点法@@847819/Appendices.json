{"hands_on_practices": [{"introduction": "要深刻理解任何数值方法，关键在于将其与已知的理论联系起来。本练习旨在揭示物质点法（MPM）与有限元法（FEM）之间深刻的内在联系。通过从弱形式出发，在一个简化的理想一维杆模型中，您将亲手推导MPM的离散方程如何自然地演化为集总质量有限元法的形式，从而为理解MPM的离散化过程奠定坚实的基础。[@problem_id:2657718]", "problem": "考虑一根直的、一维的杆，其质量密度 $\\rho$ 均匀，横截面积 $A$ 恒定，占据参考域 $\\Omega = [0,L]$。假设该杆初始无应力，并受到一个空间上均匀的单位质量体力 $b$（例如，重力加速度）的作用，边界上没有施加面力。使用物质点法（MPM），并采用在均匀背景网格上定义的线性有限元形函数，其中网格节点的位置为 $x_j = j\\,\\Delta x$（$j$ 为整数），$\\Delta x$ 是均匀的单元尺寸。\n\n你需要从线性动量平衡的弱形式和伽辽金投影的定义出发。然后，做出以下与标准 MPM 实现一致的建模选择：\n- 在背景网格上使用线性（分段仿射）帽子函数 $N_j(x)$ 作为试函数和检验函数。\n- 通过每单元一个粒子（位于单元中心）的粒子求积法来近似域积分。每个物质点（粒子）的质量为 $m_p = \\rho\\,A\\,\\Delta x$，体积为 $V_p = A\\,\\Delta x$。\n\n假设在所关注的瞬间，柯西应力处处为零（因此只有惯性和体力有贡献）。对于任意内部节点 $i$（即恰好有两个相邻单元的节点），从第一性原理出发，推导弱形式如何简化为一个节点方程，该方程与通过集中质量有限元离散化得到的方程相同。特别地，确定节点 $i$ 处由体力引起的节点右端项的闭式表达式，在没有内力的情况下，该项等于惯性项 $m_i\\,a_i$。\n\n以单个符号表达式的形式提供你的最终答案。不要代入数值。方框内的答案无需单位。", "solution": "所述问题具有科学依据，是适定的且自洽的。它展示了计算固体力学领域的一个标准推导，具体涉及物质点法 (MPM)。不存在不一致或谬误。因此，我们着手求解。\n\n出发点是线性动量平衡的弱形式，也称为虚功原理。对于占据域 $\\Omega$ 的一维连续介质，其柯西应力为 $\\sigma$，单位质量体力为 $b$，该原理表述为：\n$$\n\\int_{\\Omega} \\rho a \\delta u \\, dV + \\int_{\\Omega} \\sigma \\frac{d(\\delta u)}{dx} \\, dV = \\int_{\\Omega} \\rho b \\delta u \\, dV + \\left[ T \\delta u \\right]_{\\partial\\Omega}\n$$\n其中 $a$ 是加速度，$\\delta u$ 是任意虚位移（检验函数），$\\rho$ 是质量密度，$dV = A dx$ 是微分体积元（$A$ 是横截面积），$T = \\sigma A$ 是边界 $\\partial\\Omega$ 上的面力。\n\n问题指明，杆初始无应力，并且在所关注的瞬间柯西应力处处为零，因此 $\\sigma = 0$。问题还指出边界上没有施加面力，因此边界项 $\\left[ T \\delta u \\right]_{\\partial\\Omega}$ 为零。弱形式因此显著简化为：\n$$\n\\int_{\\Omega} \\rho a \\delta u \\, dV = \\int_{\\Omega} \\rho b \\delta u \\, dV\n$$\n我们现在在背景网格上应用伽辽金法。连续加速度场 $a(x)$ 通过节点加速度 $a_j$ 和基于网格的形函数 $N_j(x)$ 的线性组合来近似：\n$$\na(x) \\approx \\sum_{j} a_j N_j(x)\n$$\n检验函数 $\\delta u$ 选自相同的形函数基。为了找到特定节点 $i$ 的方程，我们设 $\\delta u(x) = N_i(x)$。将这些代入简化的弱形式，得到：\n$$\n\\int_{\\Omega} \\rho \\left( \\sum_{j} a_j N_j(x) \\right) N_i(x) \\, dV = \\int_{\\Omega} \\rho b N_i(x) \\, dV\n$$\n在物质点法中，连续介质积分通过对一组由 $p$ 索引的物质点（粒子）求和来近似。量 $f(x)$ 的积分近似为 $\\int_{\\Omega} f(x) \\, dV \\approx \\sum_p f(x_p) V_p$，其中 $x_p$ 是粒子 $p$ 的位置，$V_p$ 是其体积。将此求积法则应用于方程两边，得到：\n$$\n\\sum_p \\rho_p \\left( \\sum_{j} a_j N_j(x_p) \\right) N_i(x_p) V_p = \\sum_p \\rho_p b N_i(x_p) V_p\n$$\n使用粒子质量的定义 $m_p = \\rho_p V_p$，并认识到体力 $b$ 是均匀的，我们可以写出：\n$$\n\\sum_j \\left( \\sum_p m_p N_i(x_p) N_j(x_p) \\right) a_j = b \\sum_p m_p N_i(x_p)\n$$\n这是离散化的运动方程。右边的项是节点 $i$ 处由体力引起的节点力，我们将其记为 $F_i^{\\text{body}}$。问题要求给出该项的显式表达式。\n$$\nF_i^{\\text{body}} = b \\sum_p m_p N_i(x_p)\n$$\n问题指明每个单元有一个粒子，位于单元中心，每个粒子的质量为 $m_p = \\rho A \\Delta x$。网格节点位于 $x_j = j \\Delta x$。对于内部节点 $i$，线性“帽子”形函数 $N_i(x)$ 仅在域 $[x_{i-1}, x_{i+1}]$ 上非零。其显式形式为：\n$$\nN_i(x) = \\begin{cases}\n\\frac{x - x_{i-1}}{\\Delta x}  & \\text{if } x \\in [x_{i-1}, x_{i}] \\\\\n\\frac{x_{i+1} - x}{\\Delta x}  & \\text{if } x \\in [x_{i}, x_{i+1}] \\\\\n0  & \\text{otherwise}\n\\end{cases}\n$$\n由于 $N_i(x)$ 的支集是区间 $[(i-1)\\Delta x, (i+1)\\Delta x]$，只有位于该区间内的粒子才会对 $F_i^{\\text{body}}$ 的求和有贡献。由于每个单元的中心有一个粒子，相关的粒子是：\n1. 单元 $i-1$ 中的粒子，其范围是 $[x_{i-1}, x_i]$。其位置是 $x_{p,i-1} = x_{i-1} + \\frac{\\Delta x}{2} = (i-1)\\Delta x + \\frac{\\Delta x}{2} = (i - \\frac{1}{2})\\Delta x$。\n2. 单元 $i$ 中的粒子，其范围是 $[x_i, x_{i+1}]$。其位置是 $x_{p,i} = x_i + \\frac{\\Delta x}{2} = i\\Delta x + \\frac{\\Delta x}{2} = (i + \\frac{1}{2})\\Delta x$。\n\n我们在以下两个粒子位置处计算形函数 $N_i(x)$ 的值：\n对于位于域 $[x_{i-1}, x_i]$ 内的粒子 $x_{p,i-1}$：\n$$\nN_i(x_{p,i-1}) = \\frac{(i - \\frac{1}{2})\\Delta x - (i-1)\\Delta x}{\\Delta x} = \\frac{\\frac{1}{2}\\Delta x}{\\Delta x} = \\frac{1}{2}\n$$\n对于位于域 $[x_i, x_{i+1}]$ 内的粒子 $x_{p,i}$：\n$$\nN_i(x_{p,i}) = \\frac{(i+1)\\Delta x - (i + \\frac{1}{2})\\Delta x}{\\Delta x} = \\frac{\\frac{1}{2}\\Delta x}{\\Delta x} = \\frac{1}{2}\n$$\n现在我们通过对这两个粒子的贡献求和来计算节点力 $F_i^{\\text{body}}$。所有其他粒子都位于 $N_i(x)$ 的支集之外，贡献为零。\n$$\nF_i^{\\text{body}} = b \\left( m_p N_i(x_{p,i-1}) + m_p N_i(x_{p,i}) \\right)\n$$\n$$\nF_i^{\\text{body}} = b \\left( m_p \\cdot \\frac{1}{2} + m_p \\cdot \\frac{1}{2} \\right) = b \\, m_p\n$$\n代入给定的粒子质量表达式 $m_p = \\rho A \\Delta x$，我们得到节点体力的最终表达式：\n$$\nF_i^{\\text{body}} = \\rho b A \\Delta x\n$$\n该表达式确实与标准集中质量有限元法中得到的节点力相同。在这种情况下，内部节点 $i$ 的集中质量为 $m_i = \\rho A \\Delta x$（来自两个相邻单元的质量各一半），而一致性节点体力为 $\\int \\rho b N_i(x) dV = \\rho b A \\int_{x_{i-1}}^{x_{i+1}} N_i(x) dx = \\rho b A \\Delta x$。每个单元中心有一个粒子的 MPM 公式精确地再现了集中质量有限元法的结果。在没有内力的情况下，该节点的运动方程为 $m_i a_i = F_i^{\\text{body}}$，变为 $(\\rho A \\Delta x) a_i = \\rho b A \\Delta x$，正确地得到 $a_i=b$。所求的量是右端项的表达式。", "answer": "$$\n\\boxed{\\rho b A \\Delta x}\n$$", "id": "2657718"}, {"introduction": "物质点法的核心在于粒子与网格之间的信息传递，而不同的传递方案（如PIC和FLIP）会带来截然不同的数值特性。本实践练习将引导您通过编写代码，直观地量化和比较经典PIC格式与动量守恒的FLIP格式在数值耗散上的差异。通过模拟一个理想涡旋的动能变化，您将获得关于如何选择合适MPM变体以控制数值误差的宝贵实践经验。[@problem_id:2657769]", "problem": "本题要求您定量比较物质点法 (MPM) 中使用的质点网格法 (PIC) 和流体隐式质点法 (FLIP) 的网格到质点 (G2P) 速度更新，针对一个二维不可压缩涡旋，通过测量一次传递循环后总动能的变化来衡量其数值耗散。此比较必须在一个没有外力、没有基于网格的时间积分的环境中进行，以便动能的任何变化都完全由传递方案引起。\n\n请从实体力学和连续介质力学数值方法中的以下基本和核心定义出发：\n- 牛顿第二定律和线性动量守恒。\n- 网格上的质量集中和质量加权平均。\n- 结构化网格上线性有限元形函数的单位分解特性。\n- 动能的定义。\n\n考虑一个边长为 $L$ 的方形周期性域，由一个 $N \\times N$ 个节点的均匀笛卡尔节点网格离散化，节点间距为 $h = L/N$。设质点带有质量 $m_p$、位置 $\\mathbf{x}_p \\in [0,L)^2$ 和速度 $\\mathbf{v}_p$。使用双线性（张量积）分段线性帽函数作为质点到网格 (P2G) 和网格到质点 (G2P) 传递的形函数。在一维中，帽函数为 $\\phi(r) = \\max(1 - |r|, 0)$，在二维中，从质点 $p$ 到位置为 $\\mathbf{x}_i$ 的节点 $i$ 的权重为 $w_{ip} = \\phi\\!\\left(\\frac{x_i - x_p}{h}\\right)\\phi\\!\\left(\\frac{y_i - y_p}{h}\\right)$。假设所有网格索引都进行周期性包裹处理。\n\n实现以下 P2G 和 G2P 传递：\n1) P2G 质量和动量传递：\n- 节点质量 $m_i = \\sum_{p} m_p w_{ip}$。\n- 节点动量 $\\mathbf{p}_i = \\sum_{p} m_p w_{ip} \\mathbf{v}_p$。\n- 对于 $m_i > 0$ 的节点，节点速度为 $\\mathbf{v}_i = \\mathbf{p}_i / m_i$，否则 $\\mathbf{v}_i = \\mathbf{0}$。\n\n2) PIC 的 G2P 速度更新：\n- $\\mathbf{v}_p^{\\text{PIC}} = \\sum_{i} w_{ip} \\mathbf{v}_i$。\n\n3) 无网格更新（无外力，无时间积分）下 FLIP 的 G2P 速度更新：\n- 设 $\\mathbf{v}_i^{n}$ 是通过从 $\\mathbf{v}_p^{n}$ 进行 P2G 传递得到的节点速度。\n- 假设 $\\mathbf{v}_i^{n+1} = \\mathbf{v}_i^{n}$（网格上无变化）。\n- 那么 FLIP 更新为 $\\mathbf{v}_p^{\\text{FLIP}} = \\mathbf{v}_p^{n} + \\sum_{i} w_{ip}(\\mathbf{v}_i^{n+1} - \\mathbf{v}_i^{n})$，简化为 $\\mathbf{v}_p^{\\text{FLIP}} = \\mathbf{v}_p^{n}$。\n\n通过绕区域中心 $\\mathbf{c} = (L/2,L/2)$ 的刚体旋转（简单涡旋）来定义初始质点速度：\n- $\\mathbf{v}(\\mathbf{x}) = \\omega \\begin{bmatrix} -(y - c_y) \\\\ x - c_x \\end{bmatrix}$，\n其中 $\\omega$ 是一个指定的标量角速度。该速度场是无散度的，并且其分量在空间上是线性的。\n\n对于每个测试用例，计算 PIC 和 FLIP 在一次 P2G+G2P 循环前后的总动能：\n- $E_{\\text{before}} = \\tfrac{1}{2}\\sum_{p} m_p \\|\\mathbf{v}_p\\|^2$，\n- $E_{\\text{after}}^{\\text{PIC}} = \\tfrac{1}{2}\\sum_{p} m_p \\|\\mathbf{v}_p^{\\text{PIC}}\\|^2$，\n- $E_{\\text{after}}^{\\text{FLIP}} = \\tfrac{1}{2}\\sum_{p} m_p \\|\\mathbf{v}_p^{\\text{FLIP}}\\|^2$。\n将能量比 $r_{\\text{PIC}} = E_{\\text{after}}^{\\text{PIC}}/E_{\\text{before}}$ 和 $r_{\\text{FLIP}} = E_{\\text{after}}^{\\text{FLIP}}/E_{\\text{before}}$ 作为无量纲量报告（不需要物理单位）。\n\n您的程序必须精确实现上述传递过程，并评估以下测试套件。对于所有测试，使用域 $[0,L)^2$，$L = 1.0$，周期性边界，双线性帽函数，且无网格求解（即 $\\mathbf{v}_i^{n+1} = \\mathbf{v}_i^{n}$）。\n\n测试套件：\n- 测试 1（正常路径）：$N = 32$，$\\omega = 10.0$。每个单元使用 4 个质点，通过在每个单元内使用固定的随机种子 $123$ 进行抖动采样放置。所有质点的质量均为 $m_p = 1.0$。\n- 测试 2（边界情况：单个质点）：$N = 16$，$\\omega = 5.0$。使用一个位于位置 $(x,y) = (0.321, 0.654)$ 的单个质点，其质量为 $m_p = 1.0$。\n- 测试 3（粗网格与结构化采样）：$N = 8$，$\\omega = 20.0$。在每个单元中心放置一个质点，所有质点的质量均为 $m_p = 1.0$。\n- 测试 4（易于发生抵消的配置）：$N = 16$，$\\omega = 15.0$。使用两个质量均为 $m_p = 1.0$ 的质点，分别位于位置 $(x,y) = (0.3, 0.5)$ 和 $(x,y) = (0.7, 0.5)$。\n\n对于每个测试，计算一次 P2G+G2P 循环后的 $r_{\\text{PIC}}$ 和 $r_{\\text{FLIP}}$。您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表，结果顺序为\n$[r_{\\text{PIC}}^{(1)}, r_{\\text{FLIP}}^{(1)}, r_{\\text{PIC}}^{(2)}, r_{\\text{FLIP}}^{(2)}, r_{\\text{PIC}}^{(3)}, r_{\\text{FLIP}}^{(3)}, r_{\\text{PIC}}^{(4)}, r_{\\text{FLIP}}^{(4)}]$。", "solution": "问题陈述经过了严格验证，被认为是定义明确、科学合理且内部一致的。未发现任何缺陷、模糊不清或矛盾之处。因此，该问题被视为有效，解题过程如下。\n\n问题的核心是比较物质点法 (MPM) 中两种常见的网格到质点 (G2P) 速度更新方案的数值耗散特性：质点网格法 (PIC) 和流体隐式质点法 (FLIP)。此比较在简化条件下进行——无外力且无网格量的时间积分——以分离出纯粹由质点-网格-质点传递循环所导致的能量变化。\n\n基本传递过程定义如下。给定一组质点 $p$，每个质点具有质量 $m_p$、位置 $\\mathbf{x}_p$ 和速度 $\\mathbf{v}_p$，在一个由节点 $i$ 组成的网格上，节点位置为 $\\mathbf{x}_i$，形函数为 $w_{ip} = w_i(\\mathbf{x}_p)$，则程序为：\n\n$1$. 质点到网格 (P2G) 传递：\n节点质量 $m_i$ 和动量 $\\mathbf{p}_i$ 通过集中质点贡献来计算。\n$$m_i = \\sum_{p} m_p w_{ip}$$\n$$\\mathbf{p}_i = \\sum_{p} m_p w_{ip} \\mathbf{v}_p$$\n然后，节点速度 $\\mathbf{v}_i$ 作为质量加权平均值求得。\n$$\\mathbf{v}_i = \\begin{cases} \\mathbf{p}_i / m_i  & \\text{if } m_i > 0 \\\\ \\mathbf{0}  & \\text{if } m_i = 0 \\end{cases}$$\n\n$2$. 网格到质点 (G2P) 传递：\n新的质点速度通过从网格插值计算得出。\n对于 PIC，新速度是网格速度场的绝对插值：\n$$\\mathbf{v}_p^{\\text{PIC}} = \\sum_{i} w_{ip} \\mathbf{v}_i$$\n对于 FLIP，更新是增量式的。根据问题指定的条件，即没有网格求解，步末的网格速度 $\\mathbf{v}_i^{n+1}$ 与步初的网格速度 $\\mathbf{v}_i^{n}$ 相同。\n$$\\mathbf{v}_p^{\\text{FLIP}} = \\mathbf{v}_p^{n} + \\sum_{i} w_{ip} (\\mathbf{v}_i^{n+1} - \\mathbf{v}_i^{n}) = \\mathbf{v}_p^{n} + \\sum_{i} w_{ip} (\\mathbf{v}_i^{n} - \\mathbf{v}_i^{n}) = \\mathbf{v}_p^{n}$$\n这个简化是问题约束的直接逻辑结果。它揭示了 FLIP 方案的一个基本属性：在没有网格级更新的情况下，质点速度保持不变。\n\n动能变化的分析，通过比率 $r_{\\text{PIC}} = E_{\\text{after}}^{\\text{PIC}}/E_{\\text{before}}$ 和 $r_{\\text{FLIP}} = E_{\\text{after}}^{\\text{FLIP}}/E_{\\text{before}}$ 来衡量，从这些定义出发。\n\n对于 FLIP 更新，由于 $\\mathbf{v}_p^{\\text{FLIP}} = \\mathbf{v}_p^{n}$，在这种情况下，根据构造，动能是完全守恒的。\n$$E_{\\text{after}}^{\\text{FLIP}} = \\frac{1}{2}\\sum_{p} m_p \\|\\mathbf{v}_p^{\\text{FLIP}}\\|^2 = \\frac{1}{2}\\sum_{p} m_p \\|\\mathbf{v}_p^{n}\\|^2 = E_{\\text{before}}$$\n因此，对于所有测试用例，$r_{\\text{FLIP}} = 1.0$。\n\n对于 PIC 更新，分析取决于质点配置和速度场的性质。P2G-G2P 两步过程相当于一个平滑操作。质点的速度首先被投影到网格上，与相邻质点的贡献进行平均。然后，这个经过平均的网格速度场被插值回质点的位置。这个往返过程，$\\mathbf{v}_p \\to \\{\\mathbf{v}_i\\} \\to \\mathbf{v}_p^{\\text{PIC}}$，通常不是一个恒等操作，并且已知具有数值耗散性。\n新的质点速度可以表示为：\n$$\\mathbf{v}_p^{\\text{PIC}} = \\sum_{i} w_{ip} \\left( \\frac{\\sum_q m_q w_{iq} \\mathbf{v}_q}{\\sum_r m_r w_{ir}} \\right)$$\n\n我们分析四个指定的测试用例：\n\n测试 1：抖动质点采样（每个单元 4 个质点）。质点位置是不规则的。初始速度场 $\\mathbf{v}(\\mathbf{x}) = \\omega [-(y - c_y), x - c_x]^T$ 是线性的。然而，在不规则放置的质点上对这个线性场进行 P2G 质量加权平均，通常不会得到恰好等于 $\\mathbf{v}(\\mathbf{x}_i)$ 的网格速度 $\\mathbf{v}_i$。随后的 G2P 插值会引入进一步的误差。通过平均造成的信息损失会导致数值耗散，我们预期 $r_{\\text{PIC}} < 1.0$。这种情况需要完整的数值评估。\n\n测试 2：单个质点。网格仅从这一个质点接收质量和动量。在任何受影响的节点 $i$ 上，节点速度变为 $\\mathbf{v}_i = (m_p w_{ip} \\mathbf{v}_p) / (m_p w_{ip}) = \\mathbf{v}_p$。然后 G2P 更新给出 $\\mathbf{v}_p^{\\text{PIC}} = \\sum_i w_{ip} \\mathbf{v}_i = (\\sum_i w_{ip}) \\mathbf{v}_p$。由于形函数的单位分解特性（$\\sum_i w_{ip} = 1$），这简化为 $\\mathbf{v}_p^{\\text{PIC}} = \\mathbf{v}_p$。动能是守恒的。因此，$r_{\\text{PIC}} = 1.0$。\n\n测试 3：每个单元中心一个质点。这种高度结构化的布置与线性速度场以一种可预测的方式相互作用。对任何节点 $i$ 的 P2G 传递都涉及对四个相邻单元中心的质点速度进行平均。由于 $\\mathbf{v}(\\mathbf{x})$ 的线性和质点位置相对于节点的对称性，得到的节点速度恰好是速度场在该节点位置的值：$\\mathbf{v}_i = \\mathbf{v}(\\mathbf{x}_i)$。随后，G2P 传递将这些精确的节点速度插值回质点位置（一个单元中心）。同样，由于线性和对称性，这个插值是精确的：$\\mathbf{v}_p^{\\text{PIC}} = \\mathbf{v}(\\mathbf{x}_p) = \\mathbf{v}_p$。P2G-G2P 循环是一个恒等操作，动能是守恒的。因此，$r_{\\text{PIC}} = 1.0$。\n\n测试 4：两个质点位于位置 $\\mathbf{x}_{p1}=(0.3, 0.5)$ 和 $\\mathbf{x}_{p2}=(0.7, 0.5)$，网格 $N=16$，因此 $h=1/16=0.0625$。归一化的x坐标为 $x_{p1}/h = 4.8$ 和 $x_{p2}/h = 11.2$。第一个质点影响x索引为4和5的节点。第二个质点影响x索引为11和12的节点。受影响的网格节点集合是不相交的。因此，质点之间没有通过网格的相互作用。每个质点的信息被传递到其局部网格邻域，然后独立地传回。与测试2一样，这导致每个质点的 $\\mathbf{v}_p^{\\text{PIC}} = \\mathbf{v}_p$。动能是守恒的，因此 $r_{\\text{PIC}} = 1.0$。\n\n实现过程首先为每个测试用例生成质点位置。然后，为每个用例计算初始速度和动能。P2G 传递通过遍历所有质点并在一个 $N \\times N$ 的网格上累积它们对质量和动量的贡献来执行，节点索引采用周期性边界条件。然后计算节点速度。PIC 的 G2P 传递通过再次遍历质点来执行，插值节点速度以找到新的质点速度。最后，计算得到的动能，并除以初始值以获得 $r_{\\text{PIC}}$。$r_{\\text{FLIP}}$ 的值始终为 $1.0$。收集结果并按指定格式输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_simulation(N, omega, particle_positions, m_p):\n    \"\"\"\n    Performs one P2G-G2P cycle and computes kinetic energy ratios.\n    \"\"\"\n    L = 1.0\n    h = L / N\n    c = np.array([L / 2.0, L / 2.0])\n\n    num_particles = particle_positions.shape[0]\n    if num_particles == 0:\n        return 1.0, 1.0\n\n    particle_masses = np.full(num_particles, m_p)\n\n    # 1. Initial velocities and kinetic energy\n    rel_pos = particle_positions - c\n    particle_velocities = omega * np.stack([-rel_pos[:, 1], rel_pos[:, 0]], axis=1)\n\n    ke_before = 0.5 * np.sum(particle_masses * np.sum(particle_velocities**2, axis=1))\n\n    if ke_before  1e-15:\n        # If initial energy is zero, any after energy is also zero. Ratio is 1.\n        return 1.0, 1.0\n\n    # 2. P2G Transfer (Particle to Grid)\n    grid_mass = np.zeros((N, N))\n    grid_momentum = np.zeros((N, N, 2))\n\n    for p in range(num_particles):\n        pos = particle_positions[p]\n        vel = particle_velocities[p]\n        mass = particle_masses[p]\n\n        grid_coord = pos / h\n        base_node_idx = np.floor(grid_coord).astype(int)\n        frac_coord = grid_coord - base_node_idx\n        fx, fy = frac_coord[0], frac_coord[1]\n\n        # Iterate over 2x2 stencil of nodes\n        for i_off in range(2):\n            for j_off in range(2):\n                node_idx = (\n                    (base_node_idx[0] + i_off) % N,\n                    (base_node_idx[1] + j_off) % N,\n                )\n\n                if i_off == 0 and j_off == 0: weight = (1.0 - fx) * (1.0 - fy)\n                elif i_off == 1 and j_off == 0: weight = fx * (1.0 - fy)\n                elif i_off == 0 and j_off == 1: weight = (1.0 - fx) * fy\n                else: weight = fx * fy\n\n                grid_mass[node_idx[1], node_idx[0]] += mass * weight\n                grid_momentum[node_idx[1], node_idx[0], :] += mass * weight * vel\n    \n    # 3. Compute nodal velocities\n    grid_velocity = np.zeros((N, N, 2))\n    valid_nodes_mask = grid_mass > 1e-15\n    grid_velocity[valid_nodes_mask] = grid_momentum[valid_nodes_mask] / grid_mass[valid_nodes_mask, np.newaxis]\n\n    # 4. G2P Transfer (Grid to Particle - PIC)\n    new_particle_velocities_pic = np.zeros_like(particle_velocities)\n\n    for p in range(num_particles):\n        pos = particle_positions[p]\n        \n        grid_coord = pos / h\n        base_node_idx = np.floor(grid_coord).astype(int)\n        frac_coord = grid_coord - base_node_idx\n        fx, fy = frac_coord[0], frac_coord[1]\n\n        # Iterate over 2x2 stencil\n        for i_off in range(2):\n            for j_off in range(2):\n                node_idx = (\n                    (base_node_idx[0] + i_off) % N,\n                    (base_node_idx[1] + j_off) % N,\n                )\n                \n                if i_off == 0 and j_off == 0: weight = (1.0 - fx) * (1.0 - fy)\n                elif i_off == 1 and j_off == 0: weight = fx * (1.0 - fy)\n                elif i_off == 0 and j_off == 1: weight = (1.0 - fx) * fy\n                else: weight = fx * fy\n                \n                vel_i = grid_velocity[node_idx[1], node_idx[0], :]\n                new_particle_velocities_pic[p, :] += weight * vel_i\n    \n    # 5. Final kinetic energy (PIC)\n    ke_after_pic = 0.5 * np.sum(particle_masses * np.sum(new_particle_velocities_pic**2, axis=1))\n    \n    # 6. Ratios\n    r_pic = ke_after_pic / ke_before\n    # As derived from the problem statement, FLIP is perfectly conservative here\n    r_flip = 1.0\n    \n    return r_pic, r_flip\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_params = [\n        # (N, omega, m_p)\n        (32, 10.0, 1.0), # Test 1\n        (16, 5.0, 1.0),  # Test 2\n        (8, 20.0, 1.0),   # Test 3\n        (16, 15.0, 1.0)  # Test 4\n    ]\n\n    # ---- Generate particle positions for each test case ----\n\n    # Test 1: Jittered sampling\n    N1 = test_params[0][0]\n    h1 = 1.0 / N1\n    rng = np.random.default_rng(123)\n    positions1 = []\n    for i in range(N1):\n        for j in range(N1):\n            random_offsets = rng.random((4, 2))\n            for k in range(4):\n                px = (i + random_offsets[k, 0]) * h1\n                py = (j + random_offsets[k, 1]) * h1\n                positions1.append([px, py])\n    positions1 = np.array(positions1)\n\n    # Test 2: Single particle\n    positions2 = np.array([[0.321, 0.654]])\n\n    # Test 3: Structured sampling (cell centers)\n    N3 = test_params[2][0]\n    h3 = 1.0 / N3\n    grid_i, grid_j = np.meshgrid(np.arange(N3), np.arange(N3))\n    positions3 = (np.stack([grid_i.ravel(), grid_j.ravel()], axis=1) + 0.5) * h3\n\n    # Test 4: Two symmetric particles\n    positions4 = np.array([[0.3, 0.5], [0.7, 0.5]])\n\n    all_positions = [positions1, positions2, positions3, positions4]\n\n    # ---- Run simulations and collect results ----\n    results = []\n    for i, params in enumerate(test_params):\n        N, omega, m_p = params\n        particle_positions = all_positions[i]\n        \n        r_pic, r_flip = run_simulation(N, omega, particle_positions, m_p)\n        \n        results.append(r_pic)\n        results.append(r_flip)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.8f}' for r in results)}]\")\n\nsolve()\n```", "id": "2657769"}, {"introduction": "在固体力学模拟中，准确地模拟接触和摩擦至关重要，但这在数值上极具挑战性，常常引发非物理的“颤振”现象。本练习将带您深入探讨这一问题，要求您首先实现一个理想的库仑摩擦模型，并分析其在显式时间积分下产生数值颤振的原因。接着，您将实现一种光滑正则化方法，通过对比两种模型的行为，学习一种在MPM及其他方法中广泛用于提升接触模拟稳定性和真实性的实用技术。[@problem_id:2657740]", "problem": "考虑一个质点，代表一个质量为 $m$ 的刚性物块，在重力加速度为 $g$、库仑摩擦系数为 $\\mu$ 的条件下，在一个刚性水平面上滑动。设该物块沿平面具有切向速度 $v(t)$，并受到一个给定的外部切向力 $f_{\\mathrm{ext}}(t)$，而法向反作用力为 $N = m g$。假设物质点法 (MPM) 接触更新在一个步长为 $\\Delta t$ 的均匀时间网格上以速度-冲量的方式执行，在每个时间步中，先对外部力进行显式更新，然后进行摩擦修正。所有物理量必须用国际单位制（米、千克、秒）表示。所要求的输出（转换次数）是整数，因此是无量纲的。\n\n从动力学第二定律（牛顿定律）和库仑摩擦的定义出发，完成以下任务：\n\n1) 从第一性原理出发，推导一个在速度-冲量层面模拟理想库仑粘滑的离散时间显式接触更新。令 $t_n = n \\Delta t$ 且 $v_n \\equiv v(t_n)$。定义一个无摩擦的速度预测值 $v_n^{\\star} = v_n + \\frac{f_{\\mathrm{ext}}(t_n)}{m} \\Delta t$。利用一个容许的摩擦冲量大小至多为 $\\mu N \\Delta t = \\mu m g \\Delta t$ 这一事实。证明在每个时间步 $n$ 的理想库仑决策可以表述为停止滑动所需的冲量 $J_{\\mathrm{req}} = m \\lvert v_n^{\\star}\\rvert$ 与最大容许摩擦冲量 $J_{\\max} = \\mu m g \\Delta t$ 之间的比较。如果 $J_{\\max} \\ge J_{\\mathrm{req}}$，则更新强制粘滞（$v_{n+1} = 0$，摩擦力恰好抵消该步长内的运动）；否则发生滑动，此时 $v_{n+1} = v_n^{\\star} - \\operatorname{sign}(v_n^{\\star})\\, \\mu g \\Delta t$。从 $m \\frac{dv}{dt} = f_{\\mathrm{ext}}(t) + f_{\\mathrm{fr}}(t)$ 和库仑摩擦 $\\lvert f_{\\mathrm{fr}} \\rvert \\le \\mu N$（滑动时 $f_{\\mathrm{fr}} = -\\mu N\\, \\operatorname{sign}(v)$）出发，给出这些条件的清晰推导。\n\n2) 分析当外力大小接近库仑阈值 $\\mu N$ 时，为何在这种显式决策模型中，粘滑转换点附近会发生数值颤振（高频粘滑切换）。你的分析必须从库仑定律所隐含的不连续性以及离散时间决策 $J_{\\max} \\gtrless J_{\\mathrm{req}}$ 出发进行推理，不借助任何经验性修正。\n\n3) 提出并论证一种平滑正则化方法，通过使切向牵引力成为滑动速率的平滑函数来减轻颤振。一个可接受的选择是速率正则化的库仑模型：\n$$\nf_{\\mathrm{fr}}^{\\mathrm{reg}}(v) \\;=\\; -\\, \\mu\\, m\\, g \\; \\tanh\\!\\left(\\frac{\\lvert v \\rvert}{v_0}\\right)\\, \\operatorname{sign}(v),\n$$\n其中 $v_0  0$ 是一个小的正则化速度。从 $m \\frac{dv}{dt} = f_{\\mathrm{ext}}(t) + f_{\\mathrm{fr}}^{\\mathrm{reg}}(v)$ 出发，并使用显式时间步进，推导相应的显式更新，该更新首先应用外力步，然后应用正则化摩擦力。对于正则化模型，定义一个二元的“类滑动”状态：如果 $\\lvert f_{\\mathrm{fr}}^{\\mathrm{reg}}\\rvert \\ge \\gamma \\, \\mu m g$，则 $s_n^{\\mathrm{reg}} = 1$，否则 $s_n^{\\mathrm{reg}} = 0$，其中 $\\gamma \\in (0,1)$ 是一个固定的阈值因子。并解释这如何为计算正则化下的状态转换次数提供一个一致的基础。\n\n4) 将理想库仑更新和正则化更新实现为一个程序，在时间范围 $T$ 内模拟该物块，初始条件为 $v(0) = 0$。对于每个时间步，根据推导的冲量比较，将理想库仑模型的状态分类为“粘滞”($s_n = 0$)或“滑动”($s_n = 1$)；并使用指定的 $\\gamma$ 和推导的阈值标准，将正则化模型的状态分类为“类粘滞”或“类滑动”。计算在整个模拟过程中每个模型的状态转换总次数，其中一次转换定义为在连续时间步中状态在 $0$ 和 $1$ 之间发生变化。\n\n你的程序必须实现以下测试套件。在每个测试中，使用外部驱动力\n$$\nf_{\\mathrm{ext}}(t) \\;=\\; A \\, \\sin\\!\\left(2\\pi f\\, t\\right) \\;+\\; \\varepsilon \\, \\sin\\!\\left(2\\pi f_h\\, t\\right),\n$$\n其中 $A = \\alpha \\, \\mu m g$ 且 $\\varepsilon = \\eta \\, \\mu m g$。对于所有测试，设置 $m = 1.0$ 千克，$\\mu = 0.4$ (无量纲)，$g = 9.81$ 米每平方秒，$f = 5.0$ 赫兹，$f_h = 400.0$ 赫兹，以及 $\\gamma = 0.95$。时间范围为 $T$ 秒，时间步长为 $\\Delta t$ 秒，具体值依测试而定。正则化速度为 $v_0$ 米每秒，具体值依测试而定。初始速度为 $v(0) = 0$ 米每秒。\n\n- 测试 1（接近阈值，有小的高频扰动，中等时间步长）：$\\alpha = 1.0$，$\\eta = 0.02$，$\\Delta t = 0.001$，$T = 0.5$，$v_0 = 0.02$。\n\n- 测试 2（高于阈值，无扰动，精细时间步长）：$\\alpha = 1.1$，$\\eta = 0.0$，$\\Delta t = 0.0005$，$T = 0.5$，$v_0 = 0.02$。\n\n- 测试 3（接近阈值，有更强的高频扰动，粗糙时间步长）：$\\alpha = 1.0$，$\\eta = 0.05$，$\\Delta t = 0.002$，$T = 0.5$，$v_0 = 0.02$。\n\n对于每个测试，程序必须输出一个包含两个整数的列表 $[n_{\\mathrm{Coulomb}}, n_{\\mathrm{reg}}]$，其中 $n_{\\mathrm{Coulomb}}$ 是理想库仑决策模型下的粘滑转换总次数，而 $n_{\\mathrm{reg}}$ 是使用所选 $\\gamma$ 的正则化模型下的类粘滞/类滑动转换总次数。你的程序应生成单行输出，其中包含所有三个测试的结果，格式为一个用方括号括起来的逗号分隔列表，例如 $[[x_1,y_1],[x_2,y_2],[x_3,y_3]]$，其中每个 $x_i$ 和 $y_i$ 都是整数。不应打印任何额外文本。", "solution": "问题陈述在科学上是合理的、良定的，并包含了完整解答所需的所有信息。它提出了一个计算力学中关于摩擦数值处理的标准而非平凡的问题。因此，该问题是有效的。\n\n解决方案按照问题陈述的要求分为四个部分呈现。\n\n**1) 理想库仑接触更新的推导**\n\n质点的运动由一维的牛顿第二定律决定：\n$$\nm \\frac{dv}{dt} = f_{\\mathrm{ext}}(t) + f_{\\mathrm{fr}}(t)\n$$\n其中 $m$ 是质量，$v(t)$ 是速度，$f_{\\mathrm{ext}}(t)$ 是外部切向力，$f_{\\mathrm{fr}}(t)$ 是摩擦力。库仑摩擦模型为 $f_{\\mathrm{fr}}$ 提供了本构律。它指出摩擦力的大小受最大静摩擦力的限制，$\\lvert f_{\\mathrm{fr}} \\rvert \\le \\mu N$，其中 $\\mu$ 是摩擦系数，$N$ 是法向力。对于水平面上的物块，$N = m g$。\n\n该模型区分两种状态：\n-   **粘滞 (Stick)**：如果物块没有移动 ($v = 0$) 并且防止运动所需的摩擦力大小小于或等于最大静摩擦力，即 $\\lvert f_{\\mathrm{ext}} \\rvert \\le \\mu N$。在这种情况下，摩擦力恰好平衡外力，$f_{\\mathrm{fr}} = -f_{\\mathrm{ext}}$，导致合力为零，并继续保持零速度。\n-   **滑动 (Slip)**：如果物块正在移动 ($v \\neq 0$)，摩擦力变为动摩擦力，以其最大可能的大小与运动方向相反：$f_{\\mathrm{fr}} = - \\mu N \\operatorname{sign}(v)$。\n\n我们被要求使用速度-冲量公式推导一个离散时间的显式更新。我们将时间以步长 $\\Delta t$ 离散化，即 $t_n = n \\Delta t$ 和 $v_n = v(t_n)$。我们使用一种算子分裂法，其中外力和摩擦力被顺序施加。\n\n首先，我们通过在时间步 $[t_n, t_{n+1}]$ 上仅对外力的影响进行积分来计算一个预测速度 $v_n^{\\star}$。使用显式（前向欧拉）积分：\n$$\nm(v_n^{\\star} - v_n) = \\int_{t_n}^{t_{n+1}} f_{\\mathrm{ext}}(t) dt \\approx f_{\\mathrm{ext}}(t_n) \\Delta t\n$$\n这给出了规定的预测速度：\n$$\nv_n^{\\star} = v_n + \\frac{f_{\\mathrm{ext}}(t_n)}{m} \\Delta t\n$$\n这个速度 $v_n^{\\star}$ 代表了在没有摩擦的情况下，质点在时间 $t_{n+1}$ 时会具有的速度。\n\n接下来，我们施加一个作为冲量的摩擦修正 $J_{\\mathrm{fr}}$，以获得最终速度 $v_{n+1}$：\n$$\nv_{n+1} = v_n^{\\star} + \\frac{J_{\\mathrm{fr}}}{m}\n$$\n为了确定 $J_{\\mathrm{fr}}$，我们在冲量层面上施加库仑条件。理想情况是粘滞，即 $v_{n+1} = 0$。通过在上述方程中设置 $v_{n+1}=0$ 可以找到实现这一点所需的冲量：\n$$\n0 = v_n^{\\star} + \\frac{J_{\\mathrm{req}}}{m} \\implies J_{\\mathrm{req}} = -m v_n^{\\star}\n$$\n这个所需冲量的大小为 $J_{\\mathrm{req}} = \\lvert -m v_n^{\\star} \\rvert = m \\lvert v_n^{\\star} \\rvert$。\n\n然而，摩擦冲量是有限的。摩擦力的最大大小为 $\\mu N = \\mu m g$。在一个时间步 $\\Delta t$ 内，最大可用摩擦冲量的大小是：\n$$\nJ_{\\max} = (\\mu N) \\Delta t = \\mu m g \\Delta t\n$$\n决策逻辑源于对所需冲量与可用冲量的比较：\n\n-   **粘滞条件 (Stick Condition)**：如果所需冲量的大小小于或等于最大可用冲量（$J_{\\mathrm{req}} \\le J_{\\max}$），则表面可以提供强制粘滞所需的冲量。\n    $$\n    m \\lvert v_n^{\\star} \\rvert \\le \\mu m g \\Delta t\n    $$\n    在这种情况下，摩擦冲量恰好是停止运动所需的冲量，$J_{\\mathrm{fr}} = J_{\\mathrm{req}} = -m v_n^{\\star}$，最终速度为 $v_{n+1} = 0$。\n\n-   **滑动条件 (Slip Condition)**：如果所需冲量的大小超过了最大可用冲量（$J_{\\mathrm{req}}  J_{\\max}$），则表面无法阻止滑动。\n    $$\n    m \\lvert v_n^{\\star} \\rvert  \\mu m g \\Delta t\n    $$\n    在这种情况下，摩擦力以其最大能力作用，与预测的运动方向相反。预测运动的方向由 $\\operatorname{sign}(v_n^{\\star})$ 给出。因此，摩擦冲量为：\n    $$\n    J_{\\mathrm{fr}} = -J_{\\max} \\operatorname{sign}(v_n^{\\star}) = - \\mu m g \\Delta t \\operatorname{sign}(v_n^{\\star})\n    $$\n    最终速度则为：\n    $$\n    v_{n+1} = v_n^{\\star} + \\frac{J_{\\mathrm{fr}}}{m} = v_n^{\\star} - \\frac{\\mu m g \\Delta t \\operatorname{sign}(v_n^{\\star})}{m} = v_n^{\\star} - \\mu g \\Delta t \\operatorname{sign}(v_n^{\\star})\n    $$\n这就完成了指定的离散时间显式接触更新的推导。\n\n**2) 数值颤振分析**\n\n数值颤振是在摩擦的数值模拟中可能出现的、粘滞和滑动状态之间的非物理高频振荡。在所推导的显式模型中，其根源在于时间离散化与理想库仑摩擦定律不连续性的结合。\n\n决策规则 $J_{\\mathrm{req}} \\gtrless J_{\\max}$ 是一个尖锐的二元开关。我们来分析当外力大小接近静摩擦极限 $\\lvert f_{\\mathrm{ext}} \\rvert \\approx \\mu m g$ 时的行为。考虑系统在时间 $t_n$ 处于粘滞状态，因此 $v_n = 0$。预测速度为 $v_n^{\\star} = \\frac{f_{\\mathrm{ext}}(t_n)}{m} \\Delta t$。粘滞条件 $m \\lvert v_n^{\\star} \\rvert \\le \\mu m g \\Delta t$ 简化为 $\\lvert f_{\\mathrm{ext}}(t_n) \\rvert \\le \\mu m g$。\n\n现在，假设外力略微超过这个阈值：$\\lvert f_{\\mathrm{ext}}(t_n) \\rvert = \\mu m g + \\delta$，其中 $\\delta  0$ 是一个小量。粘滞条件被违反，系统转换到一个滑动步：\n$$\nv_{n+1} = v_n^{\\star} - \\mu g \\Delta t \\operatorname{sign}(v_n^{\\star}) = \\frac{f_{\\mathrm{ext}}(t_n)}{m}\\Delta t - \\mu g \\Delta t \\operatorname{sign}\\left(\\frac{f_{\\mathrm{ext}}(t_n)}{m}\\Delta t\\right)\n$$\n由于 $\\operatorname{sign}(f_{\\mathrm{ext}}(t_n)) = \\operatorname{sign}(v_n^{\\star})$，上式变为：\n$$\nv_{n+1} = \\left( \\frac{\\lvert f_{\\mathrm{ext}}(t_n) \\rvert}{m} - \\mu g \\right) \\Delta t \\operatorname{sign}(v_n^{\\star}) = \\frac{\\delta}{m} \\Delta t \\operatorname{sign}(v_n^{\\star})\n$$\n速度 $v_{n+1}$ 很小但不为零。\n\n在下一步 $t_{n+1}$，我们假设外力 $f_{\\mathrm{ext}}(t_{n+1})$ 仍然接近阈值，甚至可能由于其振荡特性而改变了符号或大小。我们计算新的预测速度：\n$$\nv_{n+1}^{\\star} = v_{n+1} + \\frac{f_{\\mathrm{ext}}(t_{n+1})}{m} \\Delta t\n$$\n显式更新在整个时间段 $\\Delta t$ 内施加了完整的动摩擦冲量。这可能导致“过冲”。例如，如果 $f_{\\mathrm{ext}}$ 返回到略低于阈值的值，上一步施加的动摩擦冲量可能过大，导致 $v_{n+1}$ “过冲”零点。新的预测值 $v_{n+1}^{\\star}$ 可能会变得非常小，甚至改变符号。如果它变得足够小，使得 $m \\lvert v_{n+1}^{\\star} \\rvert \\le \\mu m g \\Delta t$，算法将再次决定粘滞，设置 $v_{n+2} = 0$。\n\n这个在几个时间步内发生的粘滞 $\\to$ 滑动 $\\to$ 粘滞序列就是数值颤振。核心问题是从静摩擦条件到全动摩擦力的硬切换。显式数值方案无法平滑地解决这个转换，并且会过度修正，被离散的决策逻辑在不连续点上来回驱动。$f_{\\mathrm{ext}}(t)$ 中高频分量的存在加剧了这个问题，它导致合力快速穿过稳定性阈值 $\\mu m g$，从而持续触发数值开关的不稳定动力学。\n\n**3) 平滑正则化**\n\n为减轻颤振，我们可以用一个平滑的正则化模型来替代不连续的库仑定律。所提出的速率正则化模型是：\n$$\nf_{\\mathrm{fr}}^{\\mathrm{reg}}(v) \\;=\\; -\\, \\mu\\, m\\, g \\; \\tanh\\!\\left(\\frac{\\lvert v \\rvert}{v_0}\\right)\\, \\operatorname{sign}(v)\n$$\n其中 $v_0  0$ 是一个小的正则化速度。这个函数是连续且平滑的。对于小滑动速率（$\\lvert v \\rvert \\ll v_0$），我们有 $\\tanh(x) \\approx x$，所以 $f_{\\mathrm{fr}}^{\\mathrm{reg}}(v) \\approx -\\frac{\\mu m g}{v_0} v$，这是一种粘性阻尼的形式。对于大滑动速率（$\\lvert v \\rvert \\gg v_0$），$\\tanh(\\dots) \\to 1$，我们恢复了理想动摩擦，$f_{\\mathrm{fr}}^{\\mathrm{reg}}(v) \\to - \\mu m g \\operatorname{sign}(v)$。参数 $v_0$ 控制了类粘滞（粘性）和类滑动（饱和）区域之间转换的陡峭程度。通过移除 $v=0$ 处的不连续性，该模型消除了数值不稳定性的来源。\n\n相应的显式更新从 $m \\frac{dv}{dt} = f_{\\mathrm{ext}}(t) + f_{\\mathrm{fr}}^{\\mathrm{reg}}(v)$ 推导得出。使用与之前相同的算子分裂方案：\n1. 预测步（外力）：\n   $$\n   v_n^{\\star} = v_n + \\frac{f_{\\mathrm{ext}}(t_n)}{m} \\Delta t\n   $$\n2. 修正步（正则化摩擦）：摩擦冲量是通过使用更新后的速度 $v_n^{\\star}$ 来定义该时间间隔内的摩擦力来计算的。\n   $$\n   J_{\\mathrm{fr}}^{\\mathrm{reg}} = f_{\\mathrm{fr}}^{\\mathrm{reg}}(v_n^{\\star}) \\Delta t = - \\mu m g \\tanh\\left(\\frac{\\lvert v_n^{\\star} \\rvert}{v_0}\\right) \\operatorname{sign}(v_n^{\\star}) \\Delta t\n   $$\n   最终速度是：\n   $$\n   v_{n+1} = v_n^{\\star} + \\frac{J_{\\mathrm{fr}}^{\\mathrm{reg}}}{m} = v_n^{\\star} - \\mu g \\Delta t \\tanh\\left(\\frac{\\lvert v_n^{\\star} \\rvert}{v_0}\\right) \\operatorname{sign}(v_n^{\\star})\n   $$\n在正则化模型中，速度很少精确为零。为了为粘滞/滑动状态创建一个可比较的度量，我们根据摩擦力与其饱和值 $\\mu m g$ 的接近程度来定义一个“类滑动”状态。如果在时间 $t_n$ 的摩擦力大小达到其最大值的某个显著比例 $\\gamma$，则声明为类滑动状态 $s_n^{\\mathrm{reg}} = 1$：\n$$\n\\lvert f_{\\mathrm{fr}}^{\\mathrm{reg}}(v_n) \\rvert \\ge \\gamma \\mu m g\n$$\n代入力的定义并化简，得到关于速度 $v_n$ 的条件：\n$$\n\\mu m g \\tanh\\left(\\frac{\\lvert v_n \\rvert}{v_0}\\right) \\ge \\gamma \\mu m g \\implies \\tanh\\left(\\frac{\\lvert v_n \\rvert}{v_0}\\right) \\ge \\gamma\n$$\n如果满足此条件，$s_n^{\\mathrm{reg}} = 1$；否则，状态为“类粘滞”，$s_n^{\\mathrm{reg}} = 0$。这为计算转换次数提供了一个一致的基础，因为它将连续的速度空间映射到一个二元状态分类上，该分类反映了物理过程：“类粘滞”对应于摩擦曲线的陡峭粘性部分，而“类滑动”对应于饱和的类库仑部分。\n\n**4) 程序实现**\n\n前几节推导的逻辑在最终答案中提供的 Python 代码中得以实现。该程序为三个指定的测试用例模拟了理想库仑模型和正则化模型，计算了每种模型的状态转换次数，并以要求的格式输出结果。", "answer": "```python\nimport numpy as np\n\ndef simulate(m, mu, g, alpha, eta, f, f_h, T, dt, v0, gamma):\n    \"\"\"\n    Simulates the sliding block problem for both ideal Coulomb and regularized models.\n    \"\"\"\n    num_steps = int(T / dt)\n    \n    # Pre-calculate force constants\n    mu_m_g = mu * m * g\n    A = alpha * mu_m_g\n    epsilon = eta * mu_m_g\n    \n    # Initialize velocities\n    v_coulomb = 0.0\n    v_reg = 0.0\n    \n    # Store state sequences (0 for stick/stick-like, 1 for slip/slip-like)\n    coulomb_states = []\n    reg_states = []\n\n    for n in range(num_steps):\n        t_n = n * dt\n        f_ext = A * np.sin(2 * np.pi * f * t_n) + epsilon * np.sin(2 * np.pi * f_h * t_n)\n\n        # ---- Ideal Coulomb Model ----\n        v_star_coulomb = v_coulomb + (f_ext / m) * dt\n        j_req = m * abs(v_star_coulomb)\n        j_max = mu_m_g * dt\n        \n        current_coulomb_state = 0\n        if j_req = j_max:\n            # Stick step\n            v_next_coulomb = 0.0\n            current_coulomb_state = 0\n        else:\n            # Slip step\n            v_next_coulomb = v_star_coulomb - np.sign(v_star_coulomb) * mu * g * dt\n            current_coulomb_state = 1\n        \n        coulomb_states.append(current_coulomb_state)\n        v_coulomb = v_next_coulomb\n\n        # ---- Regularized Model ----\n        # State is determined based on velocity at the start of the step\n        current_reg_state = 0\n        if v0 > 0:\n            if np.tanh(abs(v_reg) / v0) >= gamma:\n                current_reg_state = 1\n            else:\n                current_reg_state = 0\n        reg_states.append(current_reg_state)\n        \n        # Update velocity for the next step\n        v_star_reg = v_reg + (f_ext / m) * dt\n        if v0 > 0:\n            friction_term = mu * g * dt * np.tanh(abs(v_star_reg) / v0) * np.sign(v_star_reg)\n        else: # Handle v0=0 case to avoid division by zero, though not used in tests\n            friction_term = mu * g * dt * np.sign(v_star_reg)\n\n        v_next_reg = v_star_reg - friction_term\n        v_reg = v_next_reg\n\n    # Count transitions\n    n_coulomb = 0\n    for i in range(len(coulomb_states) - 1):\n        if coulomb_states[i] != coulomb_states[i+1]:\n            n_coulomb += 1\n            \n    n_reg = 0\n    for i in range(len(reg_states) - 1):\n        if reg_states[i] != reg_states[i+1]:\n            n_reg += 1\n    \n    return [n_coulomb, n_reg]\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Common parameters for all tests\n    m = 1.0     # kg\n    mu = 0.4    # dimensionless\n    g = 9.81    # m/s^2\n    f = 5.0     # Hz\n    f_h = 400.0 # Hz\n    gamma = 0.95 # dimensionless\n\n    test_cases = [\n        # (alpha, eta, dt, T, v0)\n        # Test 1: Near-threshold with small high-frequency perturbation, moderate time step\n        (1.0, 0.02, 0.001, 0.5, 0.02),\n        # Test 2: Above-threshold, no perturbation, fine time step\n        (1.1, 0.0, 0.0005, 0.5, 0.02),\n        # Test 3: Near-threshold with stronger high-frequency perturbation, coarse time step\n        (1.0, 0.05, 0.002, 0.5, 0.02),\n    ]\n\n    results = []\n    for case in test_cases:\n        alpha, eta, dt, T, v0 = case\n        result = simulate(m, mu, g, alpha, eta, f, f_h, T, dt, v0, gamma)\n        results.append(result)\n\n    # Format output as specified: [[x1,y1],[x2,y2],[x3,y3]]\n    print(str(results).replace(\" \", \"\"))\n\nsolve()\n```", "id": "2657740"}]}