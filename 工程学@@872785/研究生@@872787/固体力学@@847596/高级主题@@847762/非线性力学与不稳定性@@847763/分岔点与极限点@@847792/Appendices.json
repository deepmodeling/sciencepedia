{"hands_on_practices": [{"introduction": "对结构失稳的理解通常始于分析分岔点，即新的平衡路径从主路径上分出。本练习 ([@problem_id:2543000]) 提供了一个动手实践，应用有限元法来确定经典的欧拉-伯努利梁的临界屈曲荷载。通过从第一性原理推导刚度矩阵并求解最终的特征值问题，您将亲身体验计算方法如何近似分岔现象，以及这些结果如何与精确的解析解进行比较。", "problem": "一根长度为 $L$、抗弯刚度为 $EI$ 的均质棱柱形欧拉-伯努利梁，其形心轴受到一个恒定的端部力 $N$ 的轴向压缩。假设应变和转角均为小量，并忽略剪切变形。该梁两端简支，模型化为 $w(0)=0$, $w(L)=0$，且端部转角自由。将屈曲的检测视为平衡的分岔，其特征是总势能的二阶变分失去正定性，等效于切线刚度的最小特征值消失。\n\n使用有限元法（FEM），采用一个具有 Hermite 三次插值横向位移 $w(x)$ 的双节点欧拉-伯努利梁单元，节点自由度（DOFs）为 $x=0$ 处的 $w_{1}$、$\\theta_{1}$ 和 $x=L$ 处的 $w_{2}$、$\\theta_{2}$，从第一性原理出发，按以下步骤进行：\n- 从虚功原理和由 $N$ 引起的几何非线性的线性化出发，推导以 Hermite 形函数表示的一致单元弯曲刚度和几何（初应力）刚度。\n- 组集单元切线刚度，通过约束 $w_{1}=0$ 和 $w_{2}=0$ 同时保持 $\\theta_{1}$ 和 $\\theta_{2}$ 自由来施加简支边界条件，并写出针对转动自由度的简化广义特征值问题。\n- 求解此简化问题，以获得预测分岔的最低临界荷载 $N_{\\mathrm{cr}}^{\\mathrm{FE}}$。\n\n设简支梁的解析欧拉屈曲荷载为 $N_{\\mathrm{cr}}^{\\mathrm{exact}}=\\pi^{2} EI / L^{2}$。作为您的最终答案，报告单一的无量纲比值\n$$\nr \\;=\\; \\frac{N_{\\mathrm{cr}}^{\\mathrm{FE}}}{N_{\\mathrm{cr}}^{\\mathrm{exact}}}.\n$$\n请用精确的闭式解析表达式表示您的最终结果。不要进行四舍五入或近似计算。", "solution": "该问题陈述具有科学依据、是适定的且客观的。它提出了一个计算结构力学中的标准问题，特别是弹性屈曲的有限元分析。所有必需的数据和条件都已提供，没有矛盾或谬误。该问题是有效的。我们按照要求从第一性原理出发进行求解。\n\n该分析基于承受轴向压缩力 $N$ 的欧拉-伯努利梁的线性化虚功原理。切线刚度矩阵 $\\mathbf{K}_T$ 是标准弹性（弯曲）刚度矩阵 $\\mathbf{K}_E$ 和几何（初应力）刚度矩阵 $\\mathbf{K}_G$ 的和。当 $\\mathbf{K}_T$ 不再是正定时发生屈曲分岔，这等效于找到最低的荷载 $N$，使得特征值问题 $(\\mathbf{K}_E - \\mathbf{K}_G(N)) \\mathbf{d} = \\mathbf{0}$ 存在非平凡解 $\\mathbf{d} \\neq \\mathbf{0}$。由于 $\\mathbf{K}_G$ 线性依赖于 $N$，我们写作 $\\mathbf{K}_G = N \\mathbf{K}_{G0}$，问题变为一个标准的线性特征值问题 $(\\mathbf{K}_E - N_{\\mathrm{cr}} \\mathbf{K}_{G0}) \\mathbf{d} = \\mathbf{0}$，其中 $N_{\\mathrm{cr}}$ 是临界荷载。\n\n使用一个长度为 $L$ 的双节点梁单元。横向位移场 $w(x)$ 使用 Hermite 三次形函数进行插值。节点自由度（DOFs）为 $\\mathbf{d} = [w_1, \\theta_1, w_2, \\theta_2]^T$，其中 $w_1 = w(0)$，$\\theta_1 = w'(0)$，$w_2 = w(L)$，以及 $\\theta_2 = w'(L)$。位移由 $w(x) = \\mathbf{N}(x) \\mathbf{d}$ 给出，其中 $\\mathbf{N}(x) = [H_1(x), H_2(x), H_3(x), H_4(x)]$ 是形函数向量。用无量纲坐标 $\\xi = x/L$ 表示，这些形函数为：\n$$ H_1(\\xi) = 1 - 3\\xi^2 + 2\\xi^3 $$\n$$ H_2(\\xi) = L(\\xi - 2\\xi^2 + \\xi^3) $$\n$$ H_3(\\xi) = 3\\xi^2 - 2\\xi^3 $$\n$$ H_4(\\xi) = L(-\\xi^2 + \\xi^3) $$\n\n梁柱的内虚功，考虑弯曲和轴向力的影响，其线性化形式为：\n$$ \\delta W_{\\mathrm{int}} = \\int_0^L \\delta\\epsilon_{xx} \\sigma_{xx} dA dx = \\int_0^L EI \\delta w'' w'' dx + \\int_0^L N \\delta w' w' dx $$\n其中 $w''$ 是曲率，$w'$ 是转角。第一项产生弹性刚度矩阵 $\\mathbf{K}_E$，第二项产生几何刚度矩阵 $\\mathbf{K}_G$。\n\n弹性刚度矩阵 $\\mathbf{K}_E$ 的分量由弯曲应变能导出：\n$$ K_{E,ij} = EI \\int_0^L H_i''(x) H_j''(x) dx = EI \\int_0^1 H_i''(\\xi L) H_j''(\\xi L) L d\\xi $$\n在单元域 $[0, L]$ 上计算这些标准积分，得到矩阵：\n$$ \\mathbf{K}_E = \\frac{EI}{L^3} \\begin{pmatrix} 12 & 6L & -12 & 6L \\\\ 6L & 4L^2 & -6L & 2L^2 \\\\ -12 & -6L & 12 & -6L \\\\ 6L & 2L^2 & -6L & 4L^2 \\end{pmatrix} $$\n\n几何刚度矩阵 $\\mathbf{K}_G = N \\mathbf{K}_{G0}$ 的分量由轴向力 $N$ 因构件转动所做的功导出：\n$$ K_{G,ij} = \\int_0^L N H_i'(x) H_j'(x) dx = N \\int_0^1 H_i'(\\xi L) H_j'(\\xi L) L d\\xi $$\n因此，矩阵 $\\mathbf{K}_{G0}$ 为：\n$$ K_{G0,ij} = \\int_0^L H_i'(x) H_j'(x) dx $$\n计算这些积分得到：\n$$ \\mathbf{K}_G = \\frac{N}{30L} \\begin{pmatrix} 36 & 3L & -36 & 3L \\\\ 3L & 4L^2 & -3L & -L^2 \\\\ -36 & -3L & 36 & -3L \\\\ 3L & -L^2 & -3L & 4L^2 \\end{pmatrix} $$\n\n问题指定了简支边界条件，即 $w(0)=w_1=0$ 和 $w(L)=w_2=0$。这些约束消去了第一和第三个自由度。特征值问题被简化到自由转动自由度 $\\theta_1$ 和 $\\theta_2$ 的子空间。我们提取 $\\mathbf{K}_E$ 和 $\\mathbf{K}_G$ 中对应于第二行和第四行及第二列和第四列的子矩阵。\n简化后的弹性刚度矩阵 $\\mathbf{K}_{E, red}$ 为：\n$$ \\mathbf{K}_{E, red} = \\frac{EI}{L^3} \\begin{pmatrix} 4L^2 & 2L^2 \\\\ 2L^2 & 4L^2 \\end{pmatrix} = \\frac{EI}{L} \\begin{pmatrix} 4 & 2 \\\\ 2 & 4 \\end{pmatrix} $$\n简化后的几何刚度矩阵 $\\mathbf{K}_{G, red}$ 为：\n$$ \\mathbf{K}_{G, red} = \\frac{N}{30L} \\begin{pmatrix} 4L^2 & -L^2 \\\\ -L^2 & 4L^2 \\end{pmatrix} = \\frac{NL}{30} \\begin{pmatrix} 4 & -1 \\\\ -1 & 4 \\end{pmatrix} $$\n\n针对临界荷载 $N = N_{\\mathrm{cr}}^{\\mathrm{FE}}$ 的简化特征值问题为：\n$$ (\\mathbf{K}_{E, red} - N_{\\mathrm{cr}}^{\\mathrm{FE}} \\mathbf{K}_{G0, red}) \\begin{pmatrix} \\theta_1 \\\\ \\theta_2 \\end{pmatrix} = \\mathbf{0} $$\n代入矩阵可得：\n$$ \\left( \\frac{EI}{L} \\begin{pmatrix} 4 & 2 \\\\ 2 & 4 \\end{pmatrix} - N_{\\mathrm{cr}}^{\\mathrm{FE}} \\frac{L}{30} \\begin{pmatrix} 4 & -1 \\\\ -1 & 4 \\end{pmatrix} \\right) \\begin{pmatrix} \\theta_1 \\\\ \\theta_2 \\end{pmatrix} = \\mathbf{0} $$\n为了得到非平凡解，矩阵的行列式必须为零。我们定义一个无量纲特征值 $\\lambda = \\frac{N_{\\mathrm{cr}}^{\\mathrm{FE}} L^2}{30EI}$。特征方程变为：\n$$ \\det \\left( \\begin{pmatrix} 4 & 2 \\\\ 2 & 4 \\end{pmatrix} - \\lambda \\begin{pmatrix} 4 & -1 \\\\ -1 & 4 \\end{pmatrix} \\right) = 0 $$\n$$ \\det \\begin{pmatrix} 4 - 4\\lambda & 2 + \\lambda \\\\ 2 + \\lambda & 4 - 4\\lambda \\end{pmatrix} = 0 $$\n$$ (4 - 4\\lambda)^2 - (2 + \\lambda)^2 = 0 $$\n该方程可以因式分解为平方差形式：\n$$ [4(1-\\lambda) - (2+\\lambda)] [4(1-\\lambda) + (2+\\lambda)] = 0 $$\n这导出了 $\\lambda$ 的两个可能解：\n1. $4 - 4\\lambda - 2 - \\lambda = 0 \\implies 2 - 5\\lambda = 0 \\implies \\lambda_1 = \\frac{2}{5}$\n2. $4 - 4\\lambda + 2 + \\lambda = 0 \\implies 6 - 3\\lambda = 0 \\implies \\lambda_2 = 2$\n\n最低临界荷载对应于最小的特征值 $\\lambda_1$。\n$$ N_{\\mathrm{cr}}^{\\mathrm{FE}} = \\frac{30EI}{L^2} \\lambda_1 = \\frac{30EI}{L^2} \\left(\\frac{2}{5}\\right) = \\frac{12EI}{L^2} $$\n简支梁的解析欧拉屈曲荷载由 $N_{\\mathrm{cr}}^{\\mathrm{exact}} = \\frac{\\pi^2 EI}{L^2}$ 给出。\n\n所要求的比值 $r$ 为：\n$$ r = \\frac{N_{\\mathrm{cr}}^{\\mathrm{FE}}}{N_{\\mathrm{cr}}^{\\mathrm{exact}}} = \\frac{12EI/L^2}{\\pi^2EI/L^2} = \\frac{12}{\\pi^2} $$\n这个结果表明，由于其多项式形函数，单个有限元模型过于刚硬，高估了真实的屈曲荷载。误差约为 21.6%。需要更多的单元才能收敛到精确解。", "answer": "$$\n\\boxed{\\frac{12}{\\pi^2}}\n$$", "id": "2543000"}, {"introduction": "除了分岔，极限点失稳（或称“跳跃”）是另一种关键的失效模式，结构会动态地跃迁到一个远处的稳定构型。本练习 ([@problem_id:2618872]) 使用一个经典的浅拱模型，深入探讨了这一过程的能量学。通过分析系统的势能，您将推导出平衡路径，定位临界极限点，并计算麦克斯韦荷载，以确定跳跃过程是否是能量耗散的。", "problem": "一个跨度远大于矢高的两端铰接对称浅弹性拱，受到一个缓慢增加的静横向广义荷载作用。标准的单模态Rayleigh–Ritz简化法导出一个无量纲单自由度总势能\n$$\n\\Pi(q;\\,\\Lambda) \\;=\\; \\frac{1}{4}\\,\\big(q^{2}-1\\big)^{2} \\;-\\; \\Lambda\\,q,\n$$\n其中 $q$ 是对称模态的无量纲广义位移幅值，$\\Lambda$ 是与 $q$ 共轭的无量纲静荷载。假设加载是准静态的，惯性可忽略不计，且粘性阻尼很小，因此平衡点是 $\\Pi$ 的驻点，并且在荷载控制下，突跳发生在平衡路径上的第一个极限（折叠）点。\n\n仅使用固体力学中能量最小化和分岔理论的基本原理：\n\n1) 根据 $\\Pi(q;\\Lambda)$ 的驻值条件推导平衡路径 $\\Lambda(q)$。\n\n2) 通过在静加载下强制平衡路径相对于 $q$ 丧失局部可逆性来定位极限（折叠）点，并提取当 $\\Lambda$ 从 $\\Lambda=0$ 开始单调增加时，从左侧势阱（即零荷载时 $q \\approx -1$）附近出发所达到的第一个极限点 $\\Lambda_{L1}$。\n\n3) 将麦克斯韦荷载 $\\Lambda_{M}$ 定义为在该 $\\Lambda$ 值下，两个共存的稳定平衡点具有相等总势能。从总势能的定义出发，不使用任何预先给出的公式，推导等面积条件并计算由此得到的 $\\Lambda_{M}$。\n\n4) 基于 $\\Lambda_{M}$ 和 $\\Lambda_{L1}$ 的比较，说明在静加载下，从左侧势阱在第一个极限点发生的突跳是否是耗散的（即，是否存在总势能的净释放）。\n\n答案要求：\n- 将麦克斯韦荷载和第一个极限点表示为精确的无量纲数。不要四舍五入。\n- 以有序对 $\\big(\\Lambda_{M},\\,\\Lambda_{L1}\\big)$ 的形式提供您的最终答案。\n- 最终答案中不要包含单位（根据构造，变量是无量纲的）。", "solution": "首先确认该问题具有科学依据、提法恰当且客观。它代表了弹性稳定理论中的一个典型问题，特别是通过尖点突变势能建模的浅拱突跳屈曲。该问题可以使用基本原理求解。\n\n系统的总势能由下式给出\n$$\n\\Pi(q;\\,\\Lambda) \\;=\\; \\frac{1}{4}\\,\\big(q^{2}-1\\big)^{2} \\;-\\; \\Lambda\\,q\n$$\n其中 $q$ 是广义位移，$\\Lambda$ 是施加的静荷载。\n\n1) 平衡路径的推导。\n根据驻值势能原理，平衡构型是总势能相对于广义坐标 $q$ 取驻值的构型。这在数学上表示为 $\\Pi$ 的一阶变分为零，对于单自由度系统即为 $\\frac{\\partial \\Pi}{\\partial q} = 0$。\n对 $\\Pi$ 求关于 $q$ 的导数：\n$$\n\\frac{\\partial \\Pi}{\\partial q} = \\frac{\\partial}{\\partial q} \\left[ \\frac{1}{4}(q^4 - 2q^2 + 1) - \\Lambda q \\right] = \\frac{1}{4}(4q^3 - 4q) - \\Lambda\n$$\n令导数为零得到平衡方程：\n$$\nq^3 - q - \\Lambda = 0\n$$\n该方程定义了平衡路径，它将荷载 $\\Lambda$ 表示为位移 $q$ 的函数：\n$$\n\\Lambda(q) = q^3 - q\n$$\n\n2) 极限点的定位。\n极限点（或折叠分岔点）是平衡路径上的临界点，平衡的稳定性在这些点上发生改变。稳定的平衡对应于势能的局部最小值，这要求 $\\Pi$ 对 $q$ 的二阶导数为正。当该二阶导数变为零时，稳定性丧失。\n势能的二阶导数为：\n$$\n\\frac{\\partial^2 \\Pi}{\\partial q^2} = \\frac{\\partial}{\\partial q}(q^3-q-\\Lambda) = 3q^2 - 1\n$$\n极限点的条件是 $\\frac{\\partial^2 \\Pi}{\\partial q^2} = 0$，这给出：\n$$\n3q^2 - 1 = 0 \\implies q^2 = \\frac{1}{3} \\implies q_{L} = \\pm \\frac{1}{\\sqrt{3}} = \\pm \\frac{\\sqrt{3}}{3}\n$$\n这些是系统两个极限点处的位移值。相应的荷载值通过将这些 $q_{L}$ 值代入平衡路径方程 $\\Lambda(q) = q^3 - q$ 来求得：\n对于 $q_{L} = -\\frac{\\sqrt{3}}{3}$：\n$$\n\\Lambda_{L1} = \\left(-\\frac{\\sqrt{3}}{3}\\right)^3 - \\left(-\\frac{\\sqrt{3}}{3}\\right) = -\\frac{3\\sqrt{3}}{27} + \\frac{\\sqrt{3}}{3} = -\\frac{\\sqrt{3}}{9} + \\frac{3\\sqrt{3}}{9} = \\frac{2\\sqrt{3}}{9}\n$$\n对于 $q_{L} = +\\frac{\\sqrt{3}}{3}$：\n$$\n\\Lambda_{L2} = \\left(\\frac{\\sqrt{3}}{3}\\right)^3 - \\left(\\frac{\\sqrt{3}}{3}\\right) = \\frac{3\\sqrt{3}}{27} - \\frac{\\sqrt{3}}{3} = \\frac{\\sqrt{3}}{9} - \\frac{3\\sqrt{3}}{9} = -\\frac{2\\sqrt{3}}{9}\n$$\n问题陈述加载从 $\\Lambda=0$ 开始，靠近左侧势阱（$q \\approx -1$）。初始状态是 $(q, \\Lambda) = (-1, 0)$ 处的一个稳定平衡点，因为 $\\frac{\\partial^2 \\Pi}{\\partial q^2}|_{q=-1} = 3(-1)^2 - 1 = 2 > 0$。随着荷载 $\\Lambda$ 从 $0$ 单调增加，系统沿着从 $q=-1$ 开始的稳定平衡路径移动。这条路径会导向遇到的第一个极限点，该点必须有正荷载。这对应于 $q = -\\frac{\\sqrt{3}}{3}$ 处的极限点。\n因此，第一个极限点荷载是 $\\Lambda_{L1} = \\frac{2\\sqrt{3}}{9}$。\n\n3) 麦克斯韦荷载的推导。\n麦克斯韦荷载 $\\Lambda_M$ 定义为荷载参数 $\\Lambda$ 的一个值，在该值下，两个不同的稳定平衡点（例如在位移 $q_1$ 和 $q_2$ 处）具有相等的总势能：$\\Pi(q_1; \\Lambda_M) = \\Pi(q_2; \\Lambda_M)$。\n这个条件意味着这两个状态之间的势能变化为零：\n$$\n\\Pi(q_2; \\Lambda_M) - \\Pi(q_1; \\Lambda_M) = \\int_{q_1}^{q_2} \\frac{\\partial \\Pi(q; \\Lambda_M)}{\\partial q} dq = 0\n$$\n代入导数 $\\frac{\\partial \\Pi}{\\partial q} = q^3 - q - \\Lambda_M$：\n$$\n\\int_{q_1}^{q_2} (q^3 - q - \\Lambda_M) dq = 0\n$$\n这可以使用平衡路径函数 $\\Lambda(q) = q^3 - q$ 重写为：\n$$\n\\int_{q_1}^{q_2} (\\Lambda(q) - \\Lambda_M) dq = 0\n$$\n这就是等面积条件：直线 $\\Lambda = \\Lambda_M$ 必须从平衡路径曲线 $\\Lambda(q)$ 上切出两个面积相等的区域。\n点 $q_1$ 和 $q_2$ 本身是荷载 $\\Lambda_M$ 下的平衡点，因此它们是平衡方程 $q^3 - q - \\Lambda_M = 0$ 的根。\n势能 $\\Pi(q; \\Lambda) = \\frac{1}{4}(q^2-1)^2 - \\Lambda q$ 的结构表明，当 $\\Lambda=0$ 时，势能 $\\Pi(q;0)=\\frac{1}{4}(q^2-1)^2$ 是对称的。平衡方程变为 $q^3-q=0$，其根为 $q=0, \\pm 1$。稳定平衡点（$3q^2-1>0$）位于 $q_1 = -1$ 和 $q_2 = 1$。\n我们来计算它们在 $\\Lambda=0$ 时的势能：\n$$\n\\Pi(-1; 0) = \\frac{1}{4}((-1)^2-1)^2 - 0 = 0\n$$\n$$\n\\Pi(1; 0) = \\frac{1}{4}((1)^2-1)^2 - 0 = 0\n$$\n由于两个稳定平衡点的势能相等，麦克斯韦荷载恰好是 $\\Lambda_M = 0$。我们可以用等面积法则来验证这一点：\n$$\n\\int_{-1}^{1} (q^3 - q - 0) dq = \\left[ \\frac{q^4}{4} - \\frac{q^2}{2} \\right]_{-1}^{1} = \\left(\\frac{1}{4}-\\frac{1}{2}\\right) - \\left(\\frac{1}{4} - \\frac{1}{2}\\right) = 0\n$$\n条件得到满足。因此，$\\Lambda_M = 0$。\n\n4) 突跳过程中的耗散。\n从左侧势阱发生的突跳发生在极限荷载 $\\Lambda_{L1} = \\frac{2\\sqrt{3}}{9}$ 处。在这一点上，系统处于失稳的边缘。在静加载下，荷载 $\\Lambda$ 保持在 $\\Lambda_{L1}$，系统动态地跳跃到同一荷载下另一个可达的稳定平衡状态。\n麦克斯韦荷载 $\\Lambda_M = 0$ 是两个稳定平衡“势阱”具有相等势能时的荷载。对于任何荷载 $\\Lambda > \\Lambda_M$，势能表达式中的 $-\\Lambda q$ 项会使系统产生偏向，降低正 $q$ 处势阱的能量，并升高负 $q$ 处势阱的能量。\n由于突跳发生在 $\\Lambda_{L1} = \\frac{2\\sqrt{3}}{9} > 0 = \\Lambda_M$，所以跳跃是从一个较高能量的状态（左侧势阱中的突跳前平衡）到一个较低能量的状态（右侧势阱中的突跳后平衡）。这一转变涉及系统总势能的净减少，即 $\\Delta\\Pi  0$。释放的能量被耗散掉，通常是通过粘性阻尼或应力波的发射。因此，该突跳是耗散的。\n\n最终答案要求提供有序对 $(\\Lambda_M, \\Lambda_{L1})$。根据以上推导，我们得到 $\\Lambda_M = 0$ 和 $\\Lambda_{L1} = \\frac{2\\sqrt{3}}{9}$。", "answer": "$$\n\\boxed{\\left(0, \\frac{2\\sqrt{3}}{9}\\right)}\n$$", "id": "2618872"}, {"introduction": "虽然识别临界点至关重要，但追踪完整的临界前后平衡路径才能全面了解结构的行为。这个实践性编程练习 ([@problem_id:2618840]) 将挑战您编写弧长法，这是一种稳健的数值技术，用于导航标准荷载控制方法失效的极限点。通过将此算法应用于一个非线性的两杆桁架，您将获得路径跟踪分析的计算力学第一手经验。", "problem": "考虑一个经历大位移的对称两杆桁架。支座位于坐标 $\\left(-a,0\\right)$ 和 $\\left(a,0\\right)$ 处，均为铰支座。顶点节点初始位于 $\\left(0,h_0\\right)$，通过轴向刚度为 $EA$、未变形长度为 $L_0=\\sqrt{a^2+h_0^2}$ 的两个相同杆件连接到两个支座。顶点节点被约束为只能垂直移动，向下的位移记为 $w \\ge 0$。一个大小为 $\\lambda$（单位：牛顿）的垂直参考荷载向下作用于顶点节点。如果需要，角度单位为弧度。所有长度必须以米为单位，所有力必须以牛顿为单位。您需要实现弧长法（也称为 Riks 法）来追踪由几何非线性（突跳）引起的平衡路径，并穿过一个极限点（折叠点）。您必须从第一性原理出发，推导并实现所有必要的方程。\n\n任务：\n- 采用以下定义：顶点的内广义力（与向下位移 $w$ 共轭）是总内应变能对 $w$ 的导数。仅使用以下基本原理：能量守恒、线性弹性轴向行为下桁架杆件的轴向应变能定义以及变形后构型的几何关系。位移为 $w$ 时杆件的长度为 $L(w)=\\sqrt{a^2+\\left(h_0-w\\right)^2}$，每根杆件的轴向应变能为 $U_b=\\dfrac{EA}{2L_0}\\left(L(w)-L_0\\right)^2$。总内能是两根相同杆件的能量之和。根据这些定义和几何关系，推导残差形式的平衡方程 $r\\left(w,\\lambda\\right)=0$，$r\\left(w,\\lambda\\right)=f_{\\mathrm{int}}(w)-\\lambda$，并推导标量切线刚度 $K_t(w)=\\dfrac{\\partial f_{\\mathrm{int}}}{\\partial w}(w)$。不要使用任何现成的或简化的公式；推导必须基于所述的基本原理。\n- 针对单一位移自由度 $w$ 和荷载参数 $\\lambda$ 建立弧长法。使用二次约束 $g\\left(w,\\lambda\\right)=\\left(w-w_n\\right)^2+\\alpha\\left(\\lambda-\\lambda_n\\right)^2-\\Delta s^2=0$，其中 $\\left(w_n,\\lambda_n\\right)$ 是上一个荷载-位移步的收敛状态，$\\Delta s$ 是给定的弧长半径。必须选择缩放参数 $\\alpha$ 来平衡位移和荷载的单位；采用 $\\alpha=\\left(K_t\\left(0\\right)^{-1}\\right)^2$ 的选择，其中 $K_t\\left(0\\right)$ 是 $w=0$ 时的初始切线刚度。明确指定由平衡方程线性化得到的预测方向，并对其进行缩放以满足弧长约束。推导增广系统 $\\left\\{r,g\\right\\}$ 的牛顿校正系统，并展示预测-校正迭代方程。\n- 实现一个稳健的算法，该算法能够：\n  - 在 $\\left(w_0,\\lambda_0\\right)=\\left(0,0\\right)$ 处初始化，采用 $\\alpha=\\left(K_t\\left(0\\right)^{-1}\\right)^2$，并以弧长步长 $\\Delta s$ 前进。\n  - 通过强制缩放度量下的点积 $\\left[\\Delta w,\\sqrt{\\alpha}\\Delta\\lambda\\right]\\cdot\\left[\\Delta w_{\\text{prev}},\\sqrt{\\alpha}\\Delta\\lambda_{\\text{prev}}\\right]$ 为非负，来使用与上一步一致的预测方向。\n  - 在每一步中对 $2\\times 2$ 增广系统应用牛顿迭代，直到 $r$ 和 $g$ 的绝对残差均低于其原生单位下的固定容差：使用绝对容差 $\\varepsilon_r$（单位：牛顿）和 $\\varepsilon_g$（单位：$\\text{m}^2$），除 $\\alpha$ 外不进行无量纲化。\n  - 通过监控 $K_t(w)$ 的符号来检测并报告第一个极限点（折叠点）。当首次发现 $K_t$ 在两个连续收敛状态之间发生符号变化时，将折叠点置于区间内，并通过对 $K_t(w)=0$ 进行一维二分法来计算折叠位移 $w_{\\mathrm{fold}}$ 的近似值，然后计算 $\\lambda_{\\mathrm{fold}}=f_{\\mathrm{int}}(w_{\\mathrm{fold}})$。如果在规定的步数内未检测到折叠点，则报告未通过折叠点。\n  - 如果某一步未能收敛，则对弧长半径 $\\Delta s$ 使用回溯策略：失败时将 $\\Delta s$ 减半并重试同一步，如果 $\\Delta s$ 低于规定的最小值，则中止该案例。\n\n输出要求：\n- 对于每个测试案例，您的程序必须按顺序输出一个包含以下条目的列表：$\\left[\\lambda_{\\mathrm{fold}},w_{\\mathrm{fold}},\\text{passed\\_fold},\\lambda_{\\mathrm{end}},N_{\\mathrm{steps}}\\right]$，其中 $\\lambda_{\\mathrm{fold}}$ 的单位是牛顿， $w_{\\mathrm{fold}}$ 的单位是米，$\\text{passed\\_fold}$ 是一个布尔值，$\\lambda_{\\mathrm{end}}$ 是最终收敛的荷载（单位：牛顿），$N_{\\mathrm{steps}}$ 是已完成的收敛弧长步数的整数值。如果未检测到折叠点，则输出 $\\lambda_{\\mathrm{fold}}=-1.0$ 和 $w_{\\mathrm{fold}}=-1.0$。\n- 您的程序应生成单行输出，其中包含用方括号括起来的案例结果的逗号分隔列表，例如： “[[case1_result_list],[case2_result_list],[case3_result_list]]”。\n\n测试套件：\n使用以下参数值，所有长度单位为米，所有力单位为牛顿，角度单位为弧度。\n- 案例 1（带有突跳的浅层结构标准路径）：$a=1.0$，$h_0=0.05$，$EA=1.0\\times 10^{5}$，$\\Delta s=0.003$，$N_{\\max}=120$，$\\varepsilon_r=1.0\\times 10^{-8}$，$\\varepsilon_g=1.0\\times 10^{-12}$，最小步长 $\\Delta s_{\\min}=1.0\\times 10^{-5}$。\n- 案例 2（更高的高度，在步数预算内预计不会发生突跳）：$a=1.0$，$h_0=0.5$，$EA=1.0\\times 10^{5}$，$\\Delta s=0.010$，$N_{\\max}=60$，$\\varepsilon_r=1.0\\times 10^{-8}$，$\\varepsilon_g=1.0\\times 10^{-12}$，最小步长 $\\Delta s_{\\min}=1.0\\times 10^{-5}$。\n- 案例 3（非常浅，更强的突跳，更小的弧长）：$a=1.0$，$h_0=0.02$，$EA=1.0\\times 10^{5}$，$\\Delta s=0.002$，$N_{\\max}=150$，$\\varepsilon_r=1.0\\times 10^{-8}$，$\\varepsilon_g=1.0\\times 10^{-12}$，最小步长 $\\Delta s_{\\min}=1.0\\times 10^{-5}$。\n\n最终答案规范：\n- 将完整的求解器实现为一个独立的程序，该程序不接受任何输入，并精确打印一行：一个包含上述格式的三个案例结果的列表。所有计算必须遵守给定的单位和定义。不允许外部数据或用户交互。", "solution": "所提出的问题要求推导和实现一种数值路径跟踪算法，具体来说是弧长法，以追踪两杆桁架的非线性平衡路径。分析必须从第一性原理出发。该问题在科学上是合理的、适定的，并包含了完整解答所需的所有信息。我们接下来进行推导和后续的实现。\n\n该系统由两根相同的杆件组成，其轴向刚度为 $EA$，初始长度为 $L_0 = \\sqrt{a^2 + h_0^2}$。杆件将位于 $(\\pm a, 0)$ 的支座与初始位于 $(0, h_0)$ 的顶点节点连接起来。顶点被约束为只能垂直移动，向下的位移记为 $w$。一个向下的外荷载 $\\lambda$ 施加于顶点。\n\n首先，我们建立结构的基本状态方程，即内力和切线刚度，作为广义位移 $w$ 的函数。\n\n在变形构型中，每根杆件的长度 $L(w)$ 由系统的几何关系给出：\n$$L(w) = \\sqrt{a^2 + (h_0 - w)^2}$$\n问题基于线弹性材料模型将单根杆件的轴向应变能 $U_b$ 定义为：\n$$U_b = \\frac{EA}{2L_0} (L(w) - L_0)^2$$\n两杆系统的总内应变能 $U_{\\text{total}}$ 是每根杆件能量的总和：\n$$U_{\\text{total}}(w) = 2 U_b = \\frac{EA}{L_0} (L(w) - L_0)^2$$\n问题指出，与位移 $w$ 共轭的内广义力 $f_{\\text{int}}(w)$ 是总应变能对 $w$ 的导数。这是虚功原理的直接应用。\n$$f_{\\text{int}}(w) = \\frac{dU_{\\text{total}}}{dw}$$\n应用链式法则，我们得到：\n$$f_{\\text{int}}(w) = \\frac{EA}{L_0} \\cdot 2(L(w) - L_0) \\cdot \\frac{dL(w)}{dw}$$\n杆长对位移 $w$ 的导数是：\n$$\\frac{dL(w)}{dw} = \\frac{d}{dw}\\left(a^2 + (h_0 - w)^2\\right)^{1/2} = \\frac{1}{2L(w)} \\cdot 2(h_0 - w) \\cdot (-1) = \\frac{w - h_0}{L(w)}$$\n将此代入 $f_{\\text{int}}(w)$ 的表达式中，得到内力：\n$$f_{\\text{int}}(w) = \\frac{2EA}{L_0} (L(w) - L_0) \\frac{w - h_0}{L(w)} = 2EA \\left(1 - \\frac{L_0}{L(w)}\\right) \\frac{w - h_0}{L_0}$$\n平衡要求内力与外荷载 $\\lambda$ 相平衡。这给出了残差方程 $r(w, \\lambda) = 0$：\n$$r(w, \\lambda) = f_{\\text{int}}(w) - \\lambda = 0$$\n平衡路径的稳定性由切线刚度 $K_t(w)$ 决定，它是内力对位移的导数：\n$$K_t(w) = \\frac{df_{\\text{int}}}{dw} = \\frac{d}{dw} \\left[ \\frac{2EA}{L_0} \\left( (w - h_0) - L_0 \\frac{w - h_0}{L(w)} \\right) \\right]$$\n$$K_t(w) = \\frac{2EA}{L_0} \\left[ 1 - L_0 \\frac{d}{dw}\\left(\\frac{w - h_0}{L(w)}\\right) \\right]$$\n使用商法则，几何项的导数是：\n$$\\frac{d}{dw}\\left(\\frac{w - h_0}{L(w)}\\right) = \\frac{1 \\cdot L(w) - (w - h_0) \\frac{dL}{dw}}{L(w)^2} = \\frac{L(w) - (w-h_0)\\frac{w-h_0}{L(w)}}{L(w)^2} = \\frac{L(w)^2 - (w-h_0)^2}{L(w)^3}$$\n由于 $L(w)^2 = a^2 + (h_0 - w)^2 = a^2 + (w-h_0)^2$，分子简化为 $a^2$。因此：\n$$\\frac{d}{dw}\\left(\\frac{w - h_0}{L(w)}\\right) = \\frac{a^2}{L(w)^3}$$\n将其代回，我们得到切线刚度的最终表达式：\n$$K_t(w) = \\frac{2EA}{L_0} \\left( 1 - \\frac{L_0 a^2}{L(w)^3} \\right)$$\n当切线刚度为零，$K_t(w) = 0$ 时，出现极限点或折叠点，这表示失稳以及荷载-位移曲线上的一个极大值或极小值。\n\n为了追踪穿过此类极限点的平衡路径，标准的荷载控制方法会失效。我们采用弧长法，该方法通过在状态空间 $(w, \\lambda)$ 中对步长施加约束来增广平衡方程。在每一步需要求解的方程组是：\n$$ \\mathbf{F}(w, \\lambda) = \\begin{Bmatrix} r(w, \\lambda) \\\\ g(w, \\lambda) \\end{Bmatrix} = \\begin{Bmatrix} f_{\\mathrm{int}}(w) - \\lambda \\\\ (w-w_n)^2 + \\alpha(\\lambda-\\lambda_n)^2 - \\Delta s^2 \\end{Bmatrix} = \\begin{Bmatrix} 0 \\\\ 0 \\end{Bmatrix} $$\n这里，$(w_n, \\lambda_n)$ 是前一步收敛的平衡点，$\\Delta s$ 是给定的弧长半径，而 $\\alpha$ 是一个缩放参数，用以协调位移和荷载的不同物理单位。根据规定，我们使用 $\\alpha = (K_t(0)^{-1})^2$，其中 $K_t(0) = 2EA h_0^2 / L_0^3$ 是初始刚度。\n\n求解过程是一个预测-校正方案。\n首先，沿着在 $(w_n, \\lambda_n)$ 处平衡路径的切线方向，进行预测步。切线方向 $(\\Delta w_p, \\Delta \\lambda_p)$ 满足 $d r = K_t(w_n) dw - d\\lambda = 0$，因此 $\\Delta \\lambda_p = K_t(w_n) \\Delta w_p$。对该方向进行缩放以满足弧长约束：\n$$ (\\Delta w_p)^2 + \\alpha (\\Delta \\lambda_p)^2 = \\Delta s^2 \\implies \\Delta w_p^2 (1 + \\alpha K_t(w_n)^2) = \\Delta s^2$$\n求解预测增量：\n$$ \\Delta w_p = \\beta, \\quad \\Delta \\lambda_p = \\beta K_t(w_n), \\quad \\text{其中} \\quad \\beta = \\pm \\frac{\\Delta s}{\\sqrt{1 + \\alpha K_t(w_n)^2}} $$\n选择 $\\beta$ 的符号以保持沿路径遍历的一致方向，确保当前步向量与前一步向量的缩放点积为非负。预测点为 $(w_n + \\Delta w_p, \\lambda_n + \\Delta \\lambda_p)$。\n\n其次，从预测点开始，校正阶段使用牛顿法来寻找满足增广系统 $\\mathbf{F}(w, \\lambda) = \\mathbf{0}$ 的点。在每次牛顿迭代 $k$ 中，我们求解线性系统以获得校正量 $(\\delta w, \\delta \\lambda)$：\n$$ \\mathbf{J}(w^{(k)}, \\lambda^{(k)}) \\begin{Bmatrix} \\delta w \\\\ \\delta \\lambda \\end{Bmatrix} = - \\mathbf{F}(w^{(k)}, \\lambda^{(k)}) $$\n雅可比矩阵 $\\mathbf{J}$ 是：\n$$ \\mathbf{J} = \\begin{bmatrix} \\frac{\\partial r}{\\partial w}  \\frac{\\partial r}{\\partial \\lambda} \\\\ \\frac{\\partial g}{\\partial w}  \\frac{\\partial g}{\\partial \\lambda} \\end{bmatrix} = \\begin{bmatrix} K_t(w^{(k)})  -1 \\\\ 2(w^{(k)} - w_n)  2\\alpha(\\lambda^{(k)} - \\lambda_n) \\end{bmatrix} $$\n迭代 $w^{(k+1)} = w^{(k)} + \\delta w$，$\\lambda^{(k+1)} = \\lambda^{(k)} + \\delta \\lambda$ 将持续进行，直到残差 $|r|$ 和 $|g|$ 低于各自的容差 $\\varepsilon_r$ 和 $\\varepsilon_g$。\n\n通过监测 $K_t(w)$ 的符号来检测第一个极限点。在两个连续的收敛点 $(w_n, \\lambda_n)$ 和 $(w_{n+1}, \\lambda_{n+1})$ 之间符号的改变表明已经通过了一个折叠点。然后，通过使用二分法在区间 $[w_n, w_{n+1}]$ 内找到方程 $K_t(w) = 0$ 的根 $w_{\\text{fold}}$，来精确确定折叠点的位置 $(w_{\\text{fold}}, \\lambda_{\\text{fold}})$。相应的荷载为 $\\lambda_{\\text{fold}} = f_{\\text{int}}(w_{\\text{fold}})$。该算法通过在某步未能收敛时将弧长 $\\Delta s$ 减半来引入回溯机制，从而提供稳健性。", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import bisect\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for the two-bar truss problem.\n    \"\"\"\n\n    class TwoBarTruss:\n        \"\"\"Encapsulates the physics of the two-bar truss.\"\"\"\n        def __init__(self, a, h0, EA):\n            if not (a > 0 and h0 >= 0 and EA > 0):\n                raise ValueError(\"Physical parameters a, h0, EA must be positive.\")\n            self.a = float(a)\n            self.h0 = float(h0)\n            self.EA = float(EA)\n            # Undeformed length of each bar\n            self.L0 = np.sqrt(self.a**2 + self.h0**2)\n\n        def get_current_length(self, w):\n            \"\"\"Computes the length of a bar for a given vertical displacement w.\"\"\"\n            return np.sqrt(self.a**2 + (self.h0 - w)**2)\n\n        def get_internal_force(self, w):\n            \"\"\"Computes the internal force f_int(w).\"\"\"\n            if self.L0 == 0: return 0.0 # Should not happen with valid h0>0 or a>0\n            L_w = self.get_current_length(w)\n            if L_w  1e-12:  # Avoid division by zero\n                # Physically, w cannot reach h0 +/- sqrt(L0^2-a^2) = 2h0 or 0\n                # if the bar is to have non-zero length, unless a=0.\n                # However, for robustness we check.\n                if np.isclose(w, self.h0) and self.a == 0:\n                  return 0.0 # special case of vertical bars\n                return np.inf\n            \n            # Per derivation: f_int = 2EA*(1 - L0/L(w))*(w-h0)/L0\n            return (2.0 * self.EA / self.L0) * (1.0 - self.L0 / L_w) * (w - self.h0)\n\n        def get_tangent_stiffness(self, w):\n            \"\"\"Computes the tangent stiffness K_t(w).\"\"\"\n            if self.L0 == 0: return np.inf\n            L_w = self.get_current_length(w)\n            if L_w  1e-12:\n                return np.inf\n\n            # Per derivation: K_t = (2*EA/L0) * (1 - L0*a^2 / L(w)^3)\n            return (2.0 * self.EA / self.L0) * (1.0 - self.L0 * self.a**2 / L_w**3)\n\n    def run_arc_length_analysis(params):\n        \"\"\"\n        Performs the arc-length analysis for a single set of parameters.\n        \"\"\"\n        a, h0, EA, ds_initial, N_max, tol_r, tol_g, ds_min = params\n        newton_max_iter = 15\n        \n        truss = TwoBarTruss(a, h0, EA)\n\n        # Initialization\n        w_n, lambda_n = 0.0, 0.0\n        path_history = [(w_n, lambda_n)]\n        \n        # Store increments for direction control\n        dw_prev, dlambda_prev = 0.0, 0.0\n        \n        # Initial stiffness and scaling parameter alpha\n        K0 = truss.get_tangent_stiffness(0.0)\n        if K0 = 0: # Initial state must be stable\n            return [-1.0, -1.0, False, lambda_n, 0]\n        alpha = (1.0 / K0)**2\n\n        # Fold tracking\n        fold_found, passed_fold = False, False\n        w_fold, lambda_fold = -1.0, -1.0\n        kt_prev = K0\n        \n        num_converged_steps = 0\n        current_step = 0\n        while current_step  N_max:\n            ds = ds_initial\n            step_converged_with_backtracking = False\n\n            while ds >= ds_min:\n                # Predictor phase\n                K_tn = truss.get_tangent_stiffness(w_n)\n                \n                # Determine sign of predictor step\n                if num_converged_steps == 0:\n                    sign = 1.0 # Start with increasing load\n                else:\n                    # dot product in scaled metric\n                    dot = dw_prev * 1.0 + dlambda_prev * alpha * K_tn # Predictor tangent dot product\n                    sign = np.sign(dot) if dot != 0 else 1.0\n\n                beta = sign * ds / np.sqrt(1.0 + alpha * K_tn**2)\n                dw_p = beta\n                dlambda_p = beta * K_tn\n                \n                w_k, lambda_k = w_n + dw_p, lambda_n + dlambda_p\n\n                # Corrector phase (Newton-Raphson)\n                converged = False\n                for _ in range(newton_max_iter):\n                    f_int_k = truss.get_internal_force(w_k)\n                    r_k = f_int_k - lambda_k\n                    g_k = (w_k - w_n)**2 + alpha * (lambda_k - lambda_n)**2 - ds**2\n\n                    if abs(r_k)  tol_r and abs(g_k)  tol_g:\n                        converged = True\n                        break\n\n                    K_t_k = truss.get_tangent_stiffness(w_k)\n                    \n                    # Jacobian of the augmented system\n                    J11 = K_t_k\n                    J12 = -1.0\n                    J21 = 2.0 * (w_k - w_n)\n                    J22 = 2.0 * alpha * (lambda_k - lambda_n)\n                    \n                    detJ = J11 * J22 - J12 * J21\n                    if abs(detJ)  1e-20: # Avoid singular Jacobian\n                        converged = False\n                        break\n                    \n                    # Solve 2x2 system for corrections\n                    delta_w = (-J22 * r_k + J12 * g_k) / detJ\n                    delta_lambda = (J21 * r_k - J11 * g_k) / detJ\n\n                    w_k += delta_w\n                    lambda_k += delta_lambda\n                \n                if converged:\n                    w_next, lambda_next = w_k, lambda_k\n                    path_history.append((w_next, lambda_next))\n                    \n                    dw_prev = w_next - w_n\n                    dlambda_prev = lambda_next - lambda_n\n                    w_n, lambda_n = w_next, lambda_next # Update for next step\n                    \n                    current_step += 1\n                    num_converged_steps += 1\n\n                    # Check for fold crossing\n                    kt_next = truss.get_tangent_stiffness(w_n)\n                    if not fold_found and kt_prev * kt_next  0:\n                        fold_found = True\n                        passed_fold = True\n                        # Bisection to find w_fold where K_t(w) = 0\n                        try:\n                            w_fold = bisect(truss.get_tangent_stiffness, path_history[-2][0], w_n, xtol=1e-12, maxiter=50)\n                            lambda_fold = truss.get_internal_force(w_fold)\n                        except (ValueError, RuntimeError):\n                            # Bisection fails if endpoints don't have opposite signs\n                            # which can happen with numerical noise. Just take an estimate.\n                            w_fold = (path_history[-2][0] + w_n) / 2\n                            lambda_fold = truss.get_internal_force(w_fold)\n                    \n                    kt_prev = kt_next\n                    step_converged_with_backtracking = True\n                    break # Exit backtracking loop\n                else:\n                    ds /= 2.0 # Halve step size and retry\n\n            if not step_converged_with_backtracking:\n                break # Abort if step fails to converge even with min step size\n\n        return [lambda_fold, w_fold, passed_fold, lambda_n, num_converged_steps]\n\n    test_cases = [\n        # Case 1: a, h0, EA, ds, N_max, tol_r, tol_g, ds_min\n        (1.0, 0.05, 1.0e5, 0.003, 120, 1.0e-8, 1.0e-12, 1.0e-5),\n        # Case 2\n        (1.0, 0.5, 1.0e5, 0.010, 60, 1.0e-8, 1.0e-12, 1.0e-5),\n        # Case 3\n        (1.0, 0.02, 1.0e5, 0.002, 150, 1.0e-8, 1.0e-12, 1.0e-5),\n    ]\n\n    results = []\n    for params in test_cases:\n        case_result = run_arc_length_analysis(params)\n        results.append(case_result)\n\n    # Format output as a string representation of a list of lists\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2618840"}]}