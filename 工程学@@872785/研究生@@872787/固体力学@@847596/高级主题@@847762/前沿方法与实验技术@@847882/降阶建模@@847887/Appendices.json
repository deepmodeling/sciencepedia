{"hands_on_practices": [{"introduction": "数据驱动的降阶建模的第一步是根据仿真数据（即“快照”）创建一个高效的基。本征正交分解（Proper Orthogonal Decomposition, POD）提供了一个在平均最小二乘意义上最优的基。在处理力学系统时，关键是要在能量范数下衡量这种最优性。这项实践将指导您完成使用带权内积的POD来量化基所捕获的能量，从而使您能够就模型的大小做出明智的决策。[@problem_id:2679837]", "problem": "考虑瞬态弹性动力学中的降阶建模问题，其中一组位移或速度快照的能量含量，是在一个代表离散化能量内积的对称正定 (SPD) 加权下进行评估的。令 $X \\in \\mathbb{R}^{n \\times m}$ 是一个快照矩阵，其列为状态快照；令 $W \\in \\mathbb{R}^{n \\times n}$ 是一个定义了加权内积 $\\langle u,v \\rangle_W = u^\\top W v$ 的 SPD 矩阵。目标是确定在 $W$-内积下，$X$ 的总能量含量有多少被一个最优秩-$r$ 子空间的前 $r$ 个模态所捕获，并选择最小的 $r$，使得舍弃的能量分数最多为指定的容差 $\\varepsilon$。所有量都是无量纲的分数；不需要物理单位。问题不涉及角度；不需要角度单位。\n\n仅从内积、正交投影和加权范数下的能量等基础线性代数原理出发，推导在 $W$-内积下，与 $X$ 相关的最佳 $r$ 维子空间所捕获的累积能量含量的度量。利用该推导设计一个算法，对于每个测试用例 $(X,W,\\varepsilon)$，该算法计算：\n- 满足舍弃能量分数小于或等于 $\\varepsilon$ 的最小整数 $r \\ge 0$，以及\n- 在该 $r$ 下达到的舍弃能量分数。\n\n如果在 $W$-内积下 $X$ 的总能量为零，则定义 $r=0$ 且舍弃能量分数为 $0$。将舍弃能量分数表示为四舍五入到10位小数的小数。\n\n您的程序必须解决以下测试套件。每个用例都明确提供了 $X$、$W$ 和 $\\varepsilon$。\n\n测试用例 #1：\n- $n = 5$, $m = 4$。\n- $W_1 = I_5$。\n- $X_1 = \\begin{bmatrix}\n1.5  0.0  0.0  0.0 \\\\\n0.0  1.2  0.0  0.0 \\\\\n0.1  0.0  0.9  0.0 \\\\\n0.0  0.1  0.0  0.6 \\\\\n0.05  0.02  0.01  0.01\n\\end{bmatrix}$。\n- $\\varepsilon_1 = 0.1$。\n\n测试用例 #2：\n- $n = 5$, $m = 3$。\n- $W_2 = \\mathrm{diag}(2.0, 1.0, 0.5, 1.5, 1.0)$。\n- $X_2 = \\begin{bmatrix}\n1.0  0.5  0.2 \\\\\n0.0  0.4  0.0 \\\\\n0.0  0.0  0.3 \\\\\n0.2  0.0  0.1 \\\\\n0.0  0.0  0.05\n\\end{bmatrix}$。\n- $\\varepsilon_2 = 0.01$。\n\n测试用例 #3 (秩亏快照)：\n- $n = 5$, $m = 3$。\n- $W_3 = I_5$。\n- $X_3 = \\begin{bmatrix}\n1.0  1.0  0.0 \\\\\n0.0  0.0  0.0 \\\\\n0.5  0.5  0.0 \\\\\n0.0  0.0  0.0 \\\\\n0.2  0.2  0.0\n\\end{bmatrix}$。\n- $\\varepsilon_3 = 0$。\n\n测试用例 #4 (全 SPD 加权)：\n- $n = 5$, $m = 2$。\n- $W_4 = \\begin{bmatrix}\n2.0  0.3  0.0  0.0  0.0 \\\\\n0.3  1.5  0.2  0.0  0.0 \\\\\n0.0  0.2  1.2  0.1  0.0 \\\\\n0.0  0.0  0.1  1.1  0.05 \\\\\n0.0  0.0  0.0  0.05  1.0\n\\end{bmatrix}$。\n- $X_4 = \\begin{bmatrix}\n0.5  0.1 \\\\\n0.1  0.4 \\\\\n0.0  0.3 \\\\\n0.2  0.0 \\\\\n0.0  0.1\n\\end{bmatrix}$。\n- $\\varepsilon_4 = 0.5$。\n\n对于每个测试用例，您的程序必须：\n- 计算满足舍弃能量分数小于或等于 $\\varepsilon$ 的最小 $r$ 值，\n- 计算在该 $r$ 值下，四舍五入到10位小数的舍弃能量分数，\n- 以 $[r, \\text{discarded}]$ 形式的列表输出该用例的结果。\n\n最终输出格式要求：\n您的程序应生成单行输出，其中包含所有测试用例的结果，形式为一个用方括号括起来的逗号分隔列表，其中每个测试用例的结果本身也是一个带方括号的列表。例如，输出必须是 $[[r_1,\\text{discarded}_1],[r_2,\\text{discarded}_2],[r_3,\\text{discarded}_3],[r_4,\\text{discarded}_4]]$ 的形式，并且行内任何地方都不能有空格。", "solution": "分析问题陈述的有效性。\n\n步骤1：提取已知条件\n- 一个快照矩阵 $X \\in \\mathbb{R}^{n \\times m}$，其列为状态快照。\n- 一个对称正定 (SPD) 加权矩阵 $W \\in \\mathbb{R}^{n \\times n}$。\n- 一个加权内积，定义为 $\\langle u,v \\rangle_W = u^\\top W v$。\n- 一个舍弃能量分数的容差 $\\varepsilon$。\n- 目标是找到最小的整数 $r \\ge 0$，使得最优秩-$r$ 子空间所舍弃的能量分数 $\\le \\varepsilon$。\n- 每个测试用例的输出是一对值：$[r, \\text{达到的舍弃分数}]$。\n- 一个特殊条件：如果 $X$ 的总能量为零，则 $r=0$ 且舍弃分数为 $0$。\n- 提供了四个测试用例，包含明确的矩阵 $X_i, W_i$ 和容差 $\\varepsilon_i$。\n\n测试用例 1: $X_1 \\in \\mathbb{R}^{5 \\times 4}$, $W_1 = I_5$, $\\varepsilon_1 = 0.1$。\n测试用例 2: $X_2 \\in \\mathbb{R}^{5 \\times 3}$, $W_2 = \\mathrm{diag}(2.0, 1.0, 0.5, 1.5, 1.0)$, $\\varepsilon_2 = 0.01$。\n测试用例 3: $X_3 \\in \\mathbb{R}^{5 \\times 3}$, $W_3 = I_5$, $\\varepsilon_3 = 0$。\n测试用例 4: $X_4 \\in \\mathbb{R}^{5 \\times 2}$, $W_4$ 是一个全 SPD 矩阵, $\\varepsilon_4 = 0.5$。\n\n步骤2：使用提取的已知条件进行验证\n- **科学依据**：该问题在固体力学中的线性代数及其在降阶建模（特别是本征正交分解或POD）中的应用方面有充分的依据。使用与系统能量（例如，动能或势能）相对应的加权内积是标准做法。\n- **适定性**：该问题是适定的。最优子空间的存在性得到保证，并且找到它的方法（与奇异值或特征值分解相关）是既定的。所提供的数据足以找到 $r$ 和相应分数的唯一解。\n- **客观性**：该问题以精确的数学定义客观地陈述，没有主观性语言。\n- 该问题不违反任何无效性标准。它是可形式化的、完整的、现实的，并且需要基于基本原理的非平凡推理。\n\n步骤3：结论与行动\n问题是有效的。将提供一个完整的、有理有据的解决方案。\n\n**解的推导**\n\n我们的任务是找到一个最优秩-$r$ 子空间，以最佳方式近似一组快照 $\\{x_i\\}_{i=1}^m$，这些快照是矩阵 $X \\in \\mathbb{R}^{n \\times m}$ 的列。近似的质量由捕获的能量含量来衡量，其中能量通过加权内积 $\\langle u, v \\rangle_W = u^\\top W v$ 及其诱导范数 $\\|u\\|_W = \\sqrt{u^\\top W u}$ 来定义。矩阵 $W \\in \\mathbb{R}^{n \\times n}$ 是对称正定 (SPD) 的。\n\n$1$. 总能量含量：\n单个快照向量 $x_i$ 的能量是其范数的平方，即 $\\|x_i\\|_W^2 = x_i^\\top W x_i$。整个快照集的总能量含量是各个快照能量的总和：\n$$ E_{total} = \\sum_{i=1}^{m} \\|x_i\\|_W^2 = \\sum_{i=1}^{m} x_i^\\top W x_i $$\n这个和可以用迹算子来表示。矩阵乘积 $X^\\top W X$ 的第 $i$ 个对角元素恰好是 $x_i^\\top W x_i$。因此，总能量是这个乘积的迹：\n$$ E_{total} = \\mathrm{Tr}(X^\\top W X) $$\n\n$2$. 变换到标准欧几里得空间：\n在一般加权内积下寻找最优子空间的问题，可以通过将其转换为标准欧几里得内积（其中 $\\langle u,v \\rangle = u^\\top v$）下的等价问题来简化。\n由于 $W$ 是 SPD 的，它允许唯一的 Cholesky 分解 $W = L L^\\top$，其中 $L$ 是一个对角项为正的实数下三角矩阵。加权内积可以重写为：\n$$ \\langle u, v \\rangle_W = u^\\top W v = u^\\top (L L^\\top) v = (L^\\top u)^\\top (L^\\top v) $$\n此表达式表明，向量 $u$ 和 $v$ 的 $W$-内积等价于变换后向量 $\\tilde{u} = L^\\top u$ 和 $\\tilde{v} = L^\\top v$ 的标准欧几里得内积。\n\n因此，在 $W$-范数下为原始快照 $X = [x_1, \\dots, x_m]$ 寻找最优表示，等价于在标准欧几里得范数下为变换后的快照 $\\tilde{X} = L^\\top X = [L^\\top x_1, \\dots, L^\\top x_m]$ 寻找最优表示。总能量在此变换下保持不变：\n$$ E_{total} = \\mathrm{Tr}(X^\\top W X) = \\mathrm{Tr}(X^\\top L L^\\top X) = \\mathrm{Tr}((L^\\top X)^\\top(L^\\top X)) = \\mathrm{Tr}(\\tilde{X}^\\top \\tilde{X}) = \\|\\tilde{X}\\|_F^2 $$\n其中 $\\|\\cdot\\|_F$ 表示 Frobenius 范数。\n\n$3$. 最优子空间和奇异值分解 (SVD)：\n根据 Eckart-Young-Mirsky 定理，矩阵 $\\tilde{X}$ 在 Frobenius 范数下的最佳秩-$r$ 近似由其截断奇异值分解 (SVD) 给出。设 $\\tilde{X}$ 的 SVD 为 $\\tilde{X} = U \\Sigma V^\\top$，其中 $U \\in \\mathbb{R}^{n \\times n}$ 和 $V \\in \\mathbb{R}^{m \\times m}$ 是正交矩阵，$\\Sigma \\in \\mathbb{R}^{n \\times m}$ 是一个由奇异值 $\\sigma_1 \\ge \\sigma_2 \\ge \\dots \\ge 0$ 构成的对角矩阵。\n最优秩-$r$ 子空间由 $U$ 的前 $r$ 列张成。此子空间捕获的能量等于 $\\tilde{X}$ 在此子空间上投影的 Frobenius 范数的平方。这等于前 $r$ 个奇异值的平方和：\n$$ E_r = \\sum_{i=1}^{r} \\sigma_i^2 $$\n\n$4$. 与特征值问题的关系：\n计算 $\\tilde{X}$ 的完整 SVD 可能计算量很大，特别是当 $n$ 很大时。有一个更直接的方法可用。$\\tilde{X}$ 的奇异值的平方是矩阵 $\\tilde{X}^\\top \\tilde{X}$ 的特征值。这个被称为相关矩阵的较小矩阵的维度为 $m \\times m$：\n$$ C = \\tilde{X}^\\top \\tilde{X} = (L^\\top X)^\\top(L^\\top X) = X^\\top L L^\\top X = X^\\top W X $$\n设 $\\lambda_1 \\ge \\lambda_2 \\ge \\dots \\ge \\lambda_m \\ge 0$ 是对称半正定矩阵 $C = X^\\top W X$ 的特征值。那么，对于 $i=1, \\dots, m$，有 $\\lambda_i = \\sigma_i^2$。\n\n$5$. 舍弃能量分数：\n总能量是 $C$ 的所有特征值之和：$E_{total} = \\sum_{i=1}^{m} \\lambda_i$。\n前 $r$ 个模态捕获的能量为 $E_r = \\sum_{i=1}^{r} \\lambda_i$。\n舍弃的能量是剩余部分：$E_{discarded}(r) = E_{total} - E_r = \\sum_{i=r+1}^{m} \\lambda_i$。\n因此，对于秩-$r$ 近似，舍弃的能量分数为：\n$$ f_d(r) = \\frac{E_{discarded}(r)}{E_{total}} = \\frac{\\sum_{i=r+1}^{m} \\lambda_i}{\\sum_{i=1}^{m} \\lambda_i} $$\n\n$6$. 算法设计：\n基于上述推导，找到满足 $f_d(r) \\le \\varepsilon$ 的最小整数 $r \\ge 0$ 的算法如下：\n1.  给定矩阵 $X$、$W$ 和容差 $\\varepsilon$。\n2.  构建相关矩阵 $C = X^\\top W X$。\n3.  计算 $C$ 的特征值。由于 $C$ 是对称的，其所有特征值都是实数。又由于它也是半正定的，所有特征值都是非负的。\n4.  按降序对特征值进行排序：$\\lambda_1 \\ge \\lambda_2 \\ge \\dots \\ge \\lambda_m \\ge 0$。\n5.  计算总能量 $E_{total} = \\sum_{i=1}^{m} \\lambda_i$。\n6.  如果 $E_{total}$ 在数值上为零，问题陈述指定返回 $r=0$ 和舍弃分数 $0.0$。\n7.  遍历可能的秩 $r$（从 $0$到 $m$）。对于每个 $r$：\n    a. 计算捕获的能量 $E_r = \\sum_{i=1}^{r} \\lambda_i$。（对于 $r=0$，$E_0=0$）。\n    b. 计算舍弃能量分数 $f_d(r) = (E_{total} - E_r) / E_{total}$。\n    c. 如果 $f_d(r) \\le \\varepsilon$，则此 $r$ 值为所需的最小秩。算法终止并返回此 $r$ 和计算出的 $f_d(r)$。\n此迭代过程保证能找到最小的 $r$，因为舍弃能量分数是 $r$ 的一个单调非增函数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import linalg\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and generate the final output.\n    \"\"\"\n    # Test case #1\n    X1 = np.array([\n        [1.5, 0.0, 0.0, 0.0],\n        [0.0, 1.2, 0.0, 0.0],\n        [0.1, 0.0, 0.9, 0.0],\n        [0.0, 0.1, 0.0, 0.6],\n        [0.05, 0.02, 0.01, 0.01]\n    ])\n    W1 = np.identity(5)\n    epsilon1 = 0.1\n\n    # Test case #2\n    X2 = np.array([\n        [1.0, 0.5, 0.2],\n        [0.0, 0.4, 0.0],\n        [0.0, 0.0, 0.3],\n        [0.2, 0.0, 0.1],\n        [0.0, 0.0, 0.05]\n    ])\n    W2 = np.diag([2.0, 1.0, 0.5, 1.5, 1.0])\n    epsilon2 = 0.01\n\n    # Test case #3\n    X3 = np.array([\n        [1.0, 1.0, 0.0],\n        [0.0, 0.0, 0.0],\n        [0.5, 0.5, 0.0],\n        [0.0, 0.0, 0.0],\n        [0.2, 0.2, 0.0]\n    ])\n    W3 = np.identity(5)\n    epsilon3 = 0.0\n\n    # Test case #4\n    X4 = np.array([\n        [0.5, 0.1],\n        [0.1, 0.4],\n        [0.0, 0.3],\n        [0.2, 0.0],\n        [0.0, 0.1]\n    ])\n    W4 = np.array([\n        [2.0, 0.3, 0.0, 0.0, 0.0],\n        [0.3, 1.5, 0.2, 0.0, 0.0],\n        [0.0, 0.2, 1.2, 0.1, 0.0],\n        [0.0, 0.0, 0.1, 1.1, 0.05],\n        [0.0, 0.0, 0.0, 0.05, 1.0]\n    ])\n    epsilon4 = 0.5\n\n    test_cases = [\n        (X1, W1, epsilon1),\n        (X2, W2, epsilon2),\n        (X3, W3, epsilon3),\n        (X4, W4, epsilon4)\n    ]\n\n    results = []\n    for X, W, epsilon in test_cases:\n        result = compute_optimal_rank(X, W, epsilon)\n        results.append(result)\n\n    # Format the final output string without spaces.\n    inner_results_str = [f\"[{r},{d}]\" for r, d in results]\n    final_output = f\"[{','.join(inner_results_str)}]\"\n    \n    print(final_output)\n\ndef compute_optimal_rank(X, W, epsilon):\n    \"\"\"\n    Computes the smallest rank r and the corresponding discarded energy fraction.\n\n    Args:\n        X (np.ndarray): Snapshot matrix of size n x m.\n        W (np.ndarray): SPD weighting matrix of size n x n.\n        epsilon (float): Tolerance for the discarded energy fraction.\n\n    Returns:\n        list: A list containing [r, discarded_fraction].\n    \"\"\"\n    # Form the m x m correlation matrix C = X^T * W * X\n    C = X.T @ W @ X\n\n    # The eigenvalues of C are the squared singular values of L^T * X.\n    # We use eigh for symmetric matrices, which is numerically stable and efficient.\n    # It returns eigenvalues in ascending order.\n    eigenvalues = linalg.eigh(C, eigvals_only=True)\n    \n    # Sort eigenvalues in descending order\n    eigenvalues = np.sort(eigenvalues)[::-1]\n    \n    # Total energy is the sum of all eigenvalues.\n    total_energy = np.sum(eigenvalues)\n\n    # Handle the case where total energy is zero.\n    if np.isclose(total_energy, 0.0):\n        return [0, 0.0]\n\n    # Number of snapshots (and maximum possible rank)\n    m = X.shape[1]\n\n    # Iterate from r=0 to m to find the smallest r satisfying the condition.\n    cumulative_energy = 0.0\n    for r in range(m + 1):\n        if r == 0:\n            retained_energy = 0.0\n        else:\n            # For a given r, we retain the first r largest eigenvalues.\n            retained_energy = np.sum(eigenvalues[:r])\n\n        discarded_fraction = (total_energy - retained_energy) / total_energy\n        \n        # Check against the tolerance.\n        if discarded_fraction = epsilon:\n            # Found the minimal r. Round the fraction and return.\n            return [r, round(discarded_fraction, 10)]\n    \n    # This part should not be reached for epsilon >= 0, as for r=m,\n    # the discarded fraction is 0. It's included for robustness.\n    return [m, 0.0]\n\nsolve()\n```", "id": "2679837"}, {"introduction": "构建好基之后，下一步是通过伽辽金投影（Galerkin projection）来创建降阶模型（ROM）。人们很容易认为，能够精确重建数据的基一定能产生具有精确动力学行为的ROM。然而，对于由非正规算子主导的系统，情况并非总是如此，这些系统即使在渐近稳定时也可能表现出瞬态增长。伽辽金投影可能会无意中捕捉到这种瞬态增长机制，并将其转化为ROM中的永久性不稳定性。这个练习提供了一个至关重要的警示案例。您将构建一个场景，其中一个稳定的全阶模型产生了一个不稳定的降阶模型，这突显了投影的潜在风险以及对ROM进行稳定性分析的重要性。[@problem_id:2432128]", "problem": "要求您实现一个完整的数值实验，来展示以下现象：对于一个稳定的全阶线性时不变系统，固有正交分解 (POD) 基在重构训练快照方面可能表现出色，然而，通过 Galerkin 投影得到的降阶模型 (ROM) 却可能产生不稳定的动力学，并在时间积分时发生爆破。\n\n您的实现必须从全阶常微分方程开始\n$$\n\\frac{d\\mathbf{x}}{dt} = \\mathbf{A}\\mathbf{x} + \\mathbf{b},\n$$\n其中 $\\mathbf{A}\\in\\mathbb{R}^{n\\times n}$ 和 $\\mathbf{b}\\in\\mathbb{R}^{n}$ 是常数，$\\mathbf{x}(t)\\in\\mathbb{R}^{n}$ 是状态。所有计算都在实数上进行，使用标准的欧几里得内积。在整个实验中，您将使用 $n=2$。\n\n基本定义和要求：\n- 固有正交分解 (POD) 基：给定一个快照矩阵\n$$\n\\mathbf{X} = \\begin{bmatrix}\\mathbf{x}(t_1)  \\mathbf{x}(t_2)  \\cdots  \\mathbf{x}(t_m)\\end{bmatrix}\\in\\mathbb{R}^{n\\times m},\n$$\n计算其奇异值分解 (SVD) $\\mathbf{X}=\\mathbf{U}\\mathbf{\\Sigma}\\mathbf{V}^\\top$。秩为 $r$ 的 POD 基 $\\mathbf{Q}\\in\\mathbb{R}^{n\\times r}$ 取为 $\\mathbf{U}$ 的前 $r$ 列。\n- Galerkin 投影：降阶算子和降阶强迫项为\n$$\n\\mathbf{A}_r = \\mathbf{Q}^\\top\\mathbf{A}\\mathbf{Q}\\in\\mathbb{R}^{r\\times r},\\qquad \\mathbf{b}_r=\\mathbf{Q}^\\top\\mathbf{b}\\in\\mathbb{R}^{r}.\n$$\n降阶状态 $\\mathbf{z}(t)\\in\\mathbb{R}^{r}$ 的演化遵循\n$$\n\\frac{d\\mathbf{z}}{dt} = \\mathbf{A}_r \\mathbf{z} + \\mathbf{b}_r,\\qquad \\mathbf{x}_r(t)=\\mathbf{Q}\\mathbf{z}(t).\n$$\n- 时间积分：对全阶模型和 ROM 均使用经典的四阶 Runge–Kutta 方法，并采用固定的时间步长 $h0$。将初始条件设置为 $\\mathbf{x}(0)=\\mathbf{0}$ 和 $\\mathbf{z}(0)=\\mathbf{Q}^\\top\\mathbf{x}(0)=\\mathbf{0}$。\n- 快照采集：在训练区间 $[0,T_{\\text{train}}]$ 上以恒定时间步长 $h$ 对全阶模型进行积分，在每个步骤采样状态以构成 $\\mathbf{X}$。\n- 重构误差：将训练快照的相对 POD 重构误差度量为\n$$\n\\varepsilon_{\\text{rec}} = \\frac{\\lVert \\mathbf{X} - \\mathbf{Q}\\mathbf{Q}^\\top \\mathbf{X}\\rVert_F}{\\lVert \\mathbf{X}\\rVert_F},\n$$\n其中 $\\lVert\\cdot\\rVert_F$ 表示 Frobenius 范数。\n- 爆破检测：在测试区间 $[0,T_{\\text{test}}]$ 上用相同的 $h$ 对全阶模型和 ROM 进行演化。如果在任何时间步，当前状态的欧几里得范数超过阈值 $M$，或者任何分量变为非数值或无穷大，则声明解“已爆破”。使用阈值 $M=10^6$。\n\n为导致 ROM 不稳定性而构造的强迫项：\n- 对于每个测试，您必须按如下方式构造常数强迫项 $\\mathbf{b}$。计算对称部分 $\\mathbf{S}=\\frac{1}{2}(\\mathbf{A}+\\mathbf{A}^\\top)$ 及其与 $\\mathbf{S}$ 的最大特征值相关的主单位特征向量 $\\mathbf{q}\\in\\mathbb{R}^{n}$（以任意但确定的方式处理并列情况）。设置\n$$\n\\mathbf{b}=-\\mathbf{A}\\mathbf{q}.\n$$\n这种构造确保了全阶稳态为 $\\mathbf{x}_\\infty = -\\mathbf{A}^{-1}\\mathbf{b}=\\mathbf{q}$。当 $\\mathbf{A}$ 是高度非正规的且 $\\mathbf{S}$ 的最大特征值为正时，使用 $r=1$ 和 $\\mathbf{Q}=\\mathbf{q}$ 获得的标量 ROM 的降阶动力学为 $\\frac{dz}{dt} = a_r z + b_r$，其中 $a_r=\\mathbf{q}^\\top\\mathbf{A}\\mathbf{q}0$ 且 $b_r=-a_r$，该系统是不稳定的，并从 $z(0)=0$ 开始发散。\n\n所有测试的通用数值规格：\n- 使用 $n=2$。\n- 使用 $h=10^{-3}$。\n- 使用经典的四阶 Runge–Kutta 方法。\n- 对所有向量范数使用欧几里得范数。\n- 使用 $\\mathbf{x}(0)=\\mathbf{0}$。\n\n测试套件：\n针对以下参数集实现上述过程。在每种情况下，定义 $\\mathbf{A}$，按规定计算 $\\mathbf{q}$ 和 $\\mathbf{b}$，在 $[0,T_{\\text{train}}]$ 上采集快照以构成 $\\mathbf{Q}$，然后构建 ROM 并在 $[0,T_{\\text{test}}]$ 上运行两个模型。\n\n- 测试 1 (高度非正规，秩为1的 POD)：\n  - $\\mathbf{A}=\\begin{bmatrix}-0.1  \\alpha \\\\ 0  -1.0\\end{bmatrix}$，其中 $\\alpha=50.0$，\n  - $r=1$，\n  - $T_{\\text{train}}=4.0$，\n  - $T_{\\text{test}}=1.0$。\n- 测试 2 (高度非正规，秩为2的 POD)：\n  - $\\mathbf{A}=\\begin{bmatrix}-0.1  \\alpha \\\\ 0  -1.0\\end{bmatrix}$，其中 $\\alpha=50.0$，\n  - $r=2$，\n  - $T_{\\text{train}}=4.0$，\n  - $T_{\\text{test}}=1.0$。\n- 测试 3 (对称负定，秩为1的 POD)：\n  - $\\mathbf{A}=\\begin{bmatrix}-1.0  0.0 \\\\ 0.0  -2.0\\end{bmatrix}$，\n  - $r=1$,\n  - $T_{\\text{train}}=4.0$,\n  - $T_{\\text{test}}=1.0$。\n- 测试 4 (更高度非正规，秩为1的 POD)：\n  - $\\mathbf{A}=\\begin{bmatrix}-0.1  \\alpha \\\\ 0  -1.0\\end{bmatrix}$，其中 $\\alpha=120.0$，\n  - $r=1$,\n  - $T_{\\text{train}}=4.0$,\n  - $T_{\\text{test}}=1.0$。\n\n要求输出：\n- 对每个测试，输出一个包含三个条目的列表：\n  - 标量 $\\varepsilon_{\\text{rec}}$，四舍五入到六位小数，\n  - 一个布尔值，指示 ROM 是否在 $[0,T_{\\text{test}}]$ 上发生爆破，\n  - 一个布尔值，指示全阶模型是否在 $[0,T_{\\text{test}}]$ 上发生爆破。\n- 将所有测试的结果汇总到一行中，格式为逗号分隔并用方括号括起来的列表，顺序与测试顺序相同。示例格式：\n$[\\,[\\varepsilon_{\\text{rec}}^{(1)},\\,\\text{ROM}^{(1)}\\_\\text{blowup},\\,\\text{FOM}^{(1)}\\_\\text{blowup}],\\,[\\varepsilon_{\\text{rec}}^{(2)},\\,\\text{ROM}^{(2)}\\_\\text{blowup},\\,\\text{FOM}^{(2)}\\_\\text{blowup}],\\,\\ldots\\,]$。", "solution": "用户提出了一个计算工程领域的问题，具体涉及从固有正交分解 (POD) 和 Galerkin 投影导出的降阶模型 (ROM) 的稳定性。任务是通过数值实验来展示一种已知的失效模式：尽管全阶模型 (FOM) 是稳定的，但 ROM 却可能不稳定。这种现象是由高度非正规算子控制的系统的典型特征。\n\n问题陈述已经过验证，被认为是科学上合理、适定且完整的。所有的定义、参数和步骤都已明确说明，足以得出一个唯一且可验证的解。我们将继续进行分析和实现。\n\n问题的核心在于矩阵 $\\mathbf{A}$ 的谱与其数值范围（或值域）之间的区别，后者定义为 $W(\\mathbf{A}) = \\{\\mathbf{v}^\\dagger\\mathbf{A}\\mathbf{v} : \\mathbf{v} \\in \\mathbb{C}^n, \\lVert\\mathbf{v}\\rVert_2 = 1\\}$。对于一个线性时不变系统 $\\frac{d\\mathbf{x}}{dt} = \\mathbf{A}\\mathbf{x}$，其稳定性由 $\\mathbf{A}$ 的特征值（谱，$\\sigma(\\mathbf{A})$）决定。如果所有特征值的实部都为负，则系统是稳定的，并且当 $t\\to\\infty$ 时 $\\lVert\\mathbf{x}(t)\\rVert \\to 0$。然而，如果 $\\mathbf{A}$ 是非正规的（即 $\\mathbf{A}\\mathbf{A}^\\top \\neq \\mathbf{A}^\\top\\mathbf{A}$），则可能出现瞬态增长。数值范围为这种瞬态行为提供了洞察。数值范围的实部由矩阵的对称部分 $\\mathbf{S} = \\frac{1}{2}(\\mathbf{A} + \\mathbf{A}^\\top)$ 控制，因为 $\\text{Re}(\\mathbf{v}^\\top\\mathbf{A}\\mathbf{v}) = \\mathbf{v}^\\top\\mathbf{S}\\mathbf{v}$。$\\mathbf{S}$ 的一个正特征值意味着 $\\mathbf{A}$ 的数值范围延伸到了右半平面，这表明存在瞬态能量增长的可能。\n\n使用秩为 $r$ 的 POD 基 $\\mathbf{Q}$ 进行 Galerkin 投影，将 FOM $\\frac{d\\mathbf{x}}{dt} = \\mathbf{A}\\mathbf{x} + \\mathbf{b}$ 转换为 ROM $\\frac{d\\mathbf{z}}{dt} = \\mathbf{A}_r\\mathbf{z} + \\mathbf{b}_r$，其中 $\\mathbf{A}_r = \\mathbf{Q}^\\top\\mathbf{A}\\mathbf{Q}$。ROM 的稳定性由降阶矩阵 $\\mathbf{A}_r$ 的特征值决定。关键在于，$\\mathbf{A}_r$ 的特征值包含在 $\\mathbf{A}$ 的数值范围之内，但不一定在其谱的凸包之内。如果数值范围 $W(\\mathbf{A})$ 跨入右半平面，就有可能找到一个投影子空间（基 $\\mathbf{Q}$），使得 $\\mathbf{A}_r$ 具有正实部的特征值，从而使 ROM 不稳定。\n\n问题的构造旨在揭示这种病态现象。FOM 是稳定的（$\\mathbf{A}$ 的特征值为 $\\{-0.1, -1.0\\}$）。强迫项 $\\mathbf{b} = -\\mathbf{A}\\mathbf{q}$ 的选择使得 FOM 的稳态为 $\\mathbf{x}_{\\infty} = \\mathbf{q}$，其中 $\\mathbf{q}$ 是与 $\\mathbf{S}$ 的最大特征值相对应的特征向量。这将系统动力学推向最大瞬态增长的方向。由此产生的快照将由这个方向主导，导致主 POD 模态（$\\mathbf{Q}$ 的第一列）与 $\\mathbf{q}$ 对齐。对于秩为1的 ROM ($r=1$)，降阶矩阵 $\\mathbf{A}_r$ 变为一个标量 $a_r = \\mathbf{Q}^\\top\\mathbf{A}\\mathbf{Q}$。如果 $\\mathbf{Q} \\approx \\mathbf{q}$，则 $a_r \\approx \\mathbf{q}^\\top\\mathbf{A}\\mathbf{q} = \\mathbf{q}^\\top\\mathbf{S}\\mathbf{q} = \\lambda_{\\max}(\\mathbf{S})$。对于测试1和4中的非正规矩阵，$\\lambda_{\\max}(\\mathbf{S})  0$，从而导致一个不稳定的 ROM。\n\n每个测试案例的计算流程如下：\n$1$. 定义系统参数：矩阵 $\\mathbf{A}$、ROM 秩 $r$，以及时间区间 $T_{\\text{train}}$ 和 $T_{\\text{test}}$。维度为 $n=2$，时间步长为 $h=10^{-3}$。\n$2$. 构造强迫项：计算对称部分 $\\mathbf{S} = \\frac{1}{2}(\\mathbf{A} + \\mathbf{A}^\\top)$。求其特征值和特征向量。设 $\\mathbf{q}$ 为对应于最大特征值的归一化特征向量。设置 $\\mathbf{b} = -\\mathbf{A}\\mathbf{q}$。\n$3$. 生成训练数据：使用经典的四阶 Runge-Kutta 方法，从 $\\mathbf{x}(0)=\\mathbf{0}$ 开始，在时间区间 $[0, T_{\\text{train}}]$ 上对 FOM $\\frac{d\\mathbf{x}}{dt} = \\mathbf{A}\\mathbf{x} + \\mathbf{b}$ 进行积分。每个时间步的状态被收集到快照矩阵 $\\mathbf{X}$ 中。\n$4$. 计算 POD 基：对快照矩阵执行奇异值分解 (SVD)，$\\mathbf{X} = \\mathbf{U}\\mathbf{\\Sigma}\\mathbf{V}^\\top$。秩为 $r$ 的 POD 基 $\\mathbf{Q}$ 由 $\\mathbf{U}$ 的前 $r$ 列构成。\n$5$. 计算重构误差：相对 Frobenius 范数误差计算为 $\\varepsilon_{\\text{rec}} = \\lVert \\mathbf{X} - \\mathbf{Q}\\mathbf{Q}^\\top \\mathbf{X}\\rVert_F / \\lVert \\mathbf{X}\\rVert_F$。\n$6$. 构建 ROM：降阶系统矩阵为 $\\mathbf{A}_r = \\mathbf{Q}^\\top\\mathbf{A}\\mathbf{Q}$ 和 $\\mathbf{b}_r = \\mathbf{Q}^\\top\\mathbf{b}$。\n$7$. 进行时间积分测试：FOM 和 ROM 都从零初始条件（$\\mathbf{x}(0)=\\mathbf{0}$, $\\mathbf{z}(0)=\\mathbf{0}$）开始，在区间 $[0, T_{\\text{test}}]$ 上进行积分。在积分过程中，每一步都将状态向量的欧几里得范数与爆破阈值 $M=10^6$ 进行比较。\n$8$. 记录结果：该测试的最终输出是计算出的 $\\varepsilon_{\\text{rec}}$、一个指示 ROM 是否爆破的布尔值，以及一个指示 FOM 是否爆破的布尔值。\n\n测试的预期结果：\n- **测试 1**：（$\\mathbf{A}$ 非正规， $r=1$）：$\\mathbf{A}$ 是稳定的。$\\mathbf{b}$ 的构造和 $r=1$ 的选择旨在产生一个不稳定的 ROM。我们预期会有一个小的 $\\varepsilon_{\\text{rec}}$、ROM 发生爆破，而 FOM 不会爆破。\n- **测试 2**：（$\\mathbf{A}$ 非正规， $r=2$）：此处 $r=n=2$。POD 基 $\\mathbf{Q}$ 将是 $\\mathbb{R}^2$ 的一个完备标准正交基。因此，$\\mathbf{Q}\\mathbf{Q}^\\top = \\mathbf{I}$，这意味着重构误差 $\\varepsilon_{\\text{rec}}$ 将为零（或在机器精度量级）。ROM 在动力学上与 FOM 等价，只是在不同的基中表示。由于 FOM 是稳定的，ROM 也将是稳定的。我们预期 $\\varepsilon_{\\text{rec}} \\approx 0$，ROM 和 FOM 均不会爆破。\n- **测试 3**：（$\\mathbf{A}$ 对称， $r=1$）：$\\mathbf{A}$ 是一个正规矩阵。其数值范围是其特征值（即 $\\{-1.0, -2.0\\}$）的凸包。因此，数值范围是实轴上的区间 $[-2.0, -1.0]$。降阶算子 $a_r = \\mathbf{Q}^\\top\\mathbf{A}\\mathbf{Q}$ 必须为负。ROM 将是稳定的。我们预期两个模型都不会发生爆破。\n- **测试 4**：（$\\mathbf{A}$ 更非正规， $r=1$）：与测试1类似，但具有更大的非对角项 $\\alpha=120.0$。这增加了非正规性，导致 $\\mathbf{S}$ 有一个更大的正特征值。ROM 的不稳定性应该会更加显著。我们预期会有一个小的 $\\varepsilon_{\\text{rec}}$、ROM 发生爆破，而 FOM 不会爆破。\n\n现在将实现上述逻辑。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import eigh\n\ndef solve():\n    \"\"\"\n    Implements the full numerical experiment to demonstrate ROM instability\n    for a stable FOM.\n    \"\"\"\n\n    def rk4_step(f, y, h, A, b):\n        \"\"\"A single step of the classical fourth-order Runge-Kutta method.\"\"\"\n        k1 = f(y, A, b)\n        k2 = f(y + h / 2 * k1, A, b)\n        k3 = f(y + h / 2 * k2, A, b)\n        k4 = f(y + h * k3, A, b)\n        return y + h / 6 * (k1 + 2 * k2 + 2 * k3 + k4)\n\n    def lti_rhs(y, A, b):\n        \"\"\"RHS of the LTI system dy/dt = Ay + b.\"\"\"\n        return A @ y + b\n\n    def simulate(A, b, y0, T, h, M):\n        \"\"\"\n        Simulates an LTI system and returns snapshots and blow-up status.\n        \"\"\"\n        num_steps = int(T / h)\n        y = y0.copy()\n        snapshots = [y0.copy()]\n        blew_up = False\n        \n        for _ in range(num_steps):\n            y = rk4_step(lti_rhs, y, h, A, b)\n            if not blew_up and (np.linalg.norm(y) > M or not np.all(np.isfinite(y))):\n                blew_up = True\n            \n            snapshots.append(y.copy())\n            \n        return np.array(snapshots).T, blew_up\n\n    # General parameters\n    n = 2\n    h = 1e-3\n    M = 1e6\n    x0 = np.zeros(n)\n\n    # Test cases from the problem statement.\n    test_cases = [\n        # (A_params, r, T_train, T_test)\n        ({\"alpha\": 50.0}, 1, 4.0, 1.0),\n        ({\"alpha\": 50.0}, 2, 4.0, 1.0),\n        ({\"alpha\": None}, 1, 4.0, 1.0), # Symmetric case\n        ({\"alpha\": 120.0}, 1, 4.0, 1.0),\n    ]\n\n    results = []\n    \n    for i, (params, r, T_train, T_test) in enumerate(test_cases):\n        # 1. Define A\n        if i == 2: # Test 3: Symmetric case\n            A = np.array([[-1.0, 0.0], [0.0, -2.0]])\n        else: # Tests 1, 2, 4: Non-normal case\n            alpha = params[\"alpha\"]\n            A = np.array([[-0.1, alpha], [0.0, -1.0]])\n\n        # 2. Construct b\n        S = 0.5 * (A + A.T)\n        eigvals, eigvecs = eigh(S)\n        q = eigvecs[:, -1] # Dominant eigenvector (eigh sorts eigenvalues)\n        b = -A @ q\n\n        # 3. Generate FOM snapshots for training\n        X, _ = simulate(A, b, x0, T_train, h, M)\n\n        # 4. Compute POD basis Q\n        U, s, _ = np.linalg.svd(X, full_matrices=False)\n        Q = U[:, :r]\n\n        # 5. Calculate reconstruction error\n        # eps_rec = norm(X - Q @ Q.T @ X) / norm(X)\n        # Using singular values is more direct: sqrt(sum(s_i^2 for i>r)) / sqrt(sum(s_i^2))\n        if X.shape[1]>1:\n         norm_X_sq = np.sum(s**2)\n         if norm_X_sq > 1e-12: # Avoid division by zero for zero snapshots\n            norm_err_sq = np.sum(s[r:]**2)\n            eps_rec = np.sqrt(norm_err_sq / norm_X_sq)\n         else:\n            eps_rec = 0.0\n        else:\n            eps_rec = 0.0\n\n        # 6. Form the ROM\n        Ar = Q.T @ A @ Q\n        br = Q.T @ b\n        z0 = np.zeros(r)\n\n        # 7. Simulate FOM and ROM for testing, check blow-up\n        _, fom_blew_up = simulate(A, b, x0, T_test, h, M)\n        _, rom_blew_up = simulate(Ar, br, z0, T_test, h, M)\n\n        # 8. Record results\n        results.append([round(eps_rec, 6), rom_blew_up, fom_blew_up])\n\n    # Final print statement in the exact required format.\n    # Convert bools to lowercase 'true'/'false' for JS-like format\n    formatted_results = []\n    for res in results:\n        eps_str = f\"{res[0]:.6f}\"\n        rom_bool_str = str(res[1]).lower()\n        fom_bool_str = str(res[2]).lower()\n        formatted_results.append(f\"[{eps_str},{rom_bool_str},{fom_bool_str}]\")\n\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2432128"}, {"introduction": "对于非线性系统的ROM，仅靠投影不足以保证计算效率的提升。计算非线性项的成本仍可能取决于完整系统的规模，这会抵消降阶带来的好处。超降阶（Hyper-reduction）技术，例如离散经验插值法（Discrete Empirical Interpolation Method, DEIM），解决了这一瓶颈。它们使用相同的基来近似非线性项，但仅在少数精心挑选的“稀疏”采样点上进行计算。在这项实践中，您将为一个非线性问题实现一个完整的流程：从求解全阶模型、为内力构建POD基，到设计采样点集和评估重建精度。这展示了如何使非线性ROM真正实现高效计算。[@problem_id:2679826]", "problem": "您的任务是构建和评估一个降阶模型，用于在有限元法（FEM）的背景下，使用稀疏采样重构高维内力向量。目标是利用内力降阶基的主元分解来设计一个采样集，并计算重构误差作为多个基尺寸下采样点数量的函数。最终输出是无量纲的相对误差，必须以浮点数形式报告。\n\n从以下固体力学和数值线性代数的基本原理开始：\n\n- 内力向量源于最小势能原理。考虑一个离散势能，由下式给出\n$$\n\\Pi(u) = \\tfrac{1}{2} u^{\\mathsf{T}} K u + \\sum_{i=1}^{n} \\tfrac{\\alpha_i}{4} u_i^4 - f^{\\mathsf{T}} u,\n$$\n其中 $u \\in \\mathbb{R}^{n}$ 是位移向量，$K \\in \\mathbb{R}^{n \\times n}$ 是一个对称正定刚度矩阵，代表线性弹性离散化，$\\alpha_i  0$ 是非线性刚度系数，$f \\in \\mathbb{R}^{n}$ 是外载荷向量。内力向量是应变能的梯度，\n$$\nf_{\\mathrm{int}}(u) = \\nabla_u \\left( \\tfrac{1}{2} u^{\\mathsf{T}} K u + \\sum_{i=1}^{n} \\tfrac{\\alpha_i}{4} u_i^4 \\right) = K u + \\alpha \\odot u^{\\odot 3},\n$$\n其中 $\\alpha = [\\alpha_1,\\dots,\\alpha_n]^{\\mathsf{T}}$，$\\odot$ 表示哈达玛积（Hadamard product），$u^{\\odot 3}$ 是逐元素立方。静力平衡满足 $f_{\\mathrm{int}}(u) = f$。\n\n- 使用牛顿法从基本原理求解平衡方程。定义残差 $r(u) = K u + \\alpha \\odot u^{\\odot 3} - f$ 和雅可比矩阵 $J(u) = K + \\operatorname{diag}(3 \\alpha \\odot u^{\\odot 2})$。牛顿迭代过程为\n$$\nJ(u^{(k)}) \\, \\Delta u^{(k)} = - r(u^{(k)}), \\quad u^{(k+1)} = u^{(k)} + \\Delta u^{(k)}.\n$$\n\n- 通过本征正交分解（Proper Orthogonal Decomposition, POD）为内力构建一个降阶基，该分解通过对快照矩阵进行奇异值分解（Singular Value Decomposition, SVD）获得。给定一个训练快照矩阵 $F_{\\mathrm{train}} \\in \\mathbb{R}^{n \\times N_{\\mathrm{train}}}$，其列是内力快照，计算其 SVD 并保留前 $r$ 个左奇异向量，以形成一个基 $U_r \\in \\mathbb{R}^{n \\times r}$。\n\n- 使用降阶基的主元分解设计一个稀疏采样集。对 $U_r^{\\mathsf{T}}$ 使用主元 QR 分解来选择信息丰富的采样索引（也称为 QDEIM，是离散经验插值法（Discrete Empirical Interpolation Method, DEIM）的一种特殊情况）。让主元 QR 分解返回的置换定义一个有序的采样索引列表 $\\mathcal{P}_r = [p_1, p_2, \\dots, p_n]$。对于指定的采样数量 $m$，使用前 $m$ 个索引 $\\{p_1, \\dots, p_m\\}$。\n\n- 对于一个测试内力 $f \\in \\mathbb{R}^n$，使用稀疏本征正交分解（gappy POD）最小二乘系统从 $m$ 个采样条目中重构它\n$$\n\\min_{c \\in \\mathbb{R}^r} \\left\\| S U_r c - S f \\right\\|_2,\n$$\n其中 $S \\in \\mathbb{R}^{m \\times n}$ 选择被采样的行。使用 Moore-Penrose 伪逆（MPP）计算 $c = (S U_r)^{+} S f$ 并设置重构结果为 $\\widehat{f} = U_r c$。报告相对误差\n$$\ne = \\frac{\\| \\widehat{f} - f \\|_2}{\\| f \\|_2},\n$$\n该误差是无量纲的。\n\n实现以下具体的、完全指定的实例：\n\n- 维度：$n = 60$。\n- 刚度：$K \\in \\mathbb{R}^{60 \\times 60}$ 是两端带有狄利克雷边界条件的标准三对角离散拉普拉斯算子，即对于 $i=1,\\dots,60$，$(K)_{ii} = 2$；对于 $i=1,\\dots,59$，$(K)_{i,i+1} = (K)_{i+1,i} = -1$，其他位置为零。\n- 非线性系数：对于 $i=1,\\dots,60$，定义 $\\alpha_i = 1 + \\tfrac{1}{2} \\sin^2\\!\\left( \\tfrac{2 \\pi i}{61} \\right)$。\n- 牛顿求解器：初始化 $u^{(0)} = 0$，使用绝对收敛准则 $\\|r(u^{(k)})\\|_2 \\leq \\varepsilon$（其中 $\\varepsilon = 10^{-10}$）和最大迭代次数 $k_{\\max} = 50$。如果在 $k_{\\max}$ 次迭代内未达到收敛，则使用最后一次迭代的结果。\n- 训练数据：快照数量 $N_{\\mathrm{train}} = 80$。使用固定的随机种子 $s_{\\mathrm{train}} = 2025$ 生成独立同分布的外载荷 $f \\sim \\mathcal{N}(0,\\sigma^2 I)$，其中 $\\sigma = 0.1$。对每个载荷，求解平衡以获得 $u$，然后计算 $f_{\\mathrm{int}}(u)$，它构成 $F_{\\mathrm{train}}$ 的一列。\n- 测试数据：快照数量 $N_{\\mathrm{test}} = 30$。使用固定的随机种子 $s_{\\mathrm{test}} = 1337$ 生成载荷 $f \\sim \\mathcal{N}(0,\\sigma^2 I)$，其中 $\\sigma = 0.1$。对每个载荷，像训练时一样计算相应的内力快照，以形成 $F_{\\mathrm{test}} \\in \\mathbb{R}^{n \\times N_{\\mathrm{test}}}$。\n- 降阶基：考虑尺寸为 $r \\in \\{4, 8, 12\\}$ 的 POD 力基。\n- 采样设计：对于每个 $r$，从 $U_r^{\\mathsf{T}}$ 的主元 QR 分解计算主元顺序 $\\mathcal{P}_r$。对于每个指定的采样数 $m$，使用 $\\mathcal{P}_r$ 中的前 $m$ 个索引来定义采样算子 $S$。如果 $m  r$，仍然使用 Moore-Penrose 伪逆求解最小二乘问题。如果 $m  r$，系统是超定的，在最小二乘意义下求解。\n- 误差度量：对于每对 $(r,m)$，计算所有 $N_{\\mathrm{test}}$ 个测试快照的平均相对误差 $\\bar{e}(r,m)$。每个 $\\bar{e}(r,m)$ 都是一个浮点数。\n\n测试套件规范：\n\n- 基尺寸：$r \\in \\{4, 8, 12\\}$。\n- 对于 $r = 4$，采样数 $m \\in \\{3, 4, 8\\}$。\n- 对于 $r = 8$，采样数 $m \\in \\{4, 8, 12\\}$。\n- 对于 $r = 12$，采样数 $m \\in \\{6, 12, 20\\}$。\n- 用于输出聚合所需的评估顺序是\n$$\n[(4,3), (4,4), (4,8), (8,4), (8,8), (8,12), (12,6), (12,12), (12,20)]。\n$$\n\n程序要求：\n\n- 实现指定的完整流程：模型定义、牛顿求解、快照收集、POD 基计算、通过对 $U_r^{\\mathsf{T}}$ 进行主元 QR 分解的采样索引设计、通过 Moore-Penrose 伪逆的稀疏重构，以及平均相对误差计算。\n- 所有计算都是无量纲的；不需要进行物理单位转换。最终输出是无量纲的浮点数。\n- 您的程序应产生单行输出，其中包含按上述评估顺序排列的九个平均相对误差，格式为用方括号括起来的逗号分隔列表。每个浮点数应四舍五入到小数点后六位。例如，一个可接受的格式是\n$$\n[\\bar{e}_{1},\\bar{e}_{2},\\dots,\\bar{e}_{9}],\n$$\n其中每个 $\\bar{e}_{i}$ 都精确打印到小数点后六位。", "solution": "所提出的问题是有效的、有科学依据的且适定的。它概述了非线性固体力学降阶建模领域中的一个完整数值实验。我们将进行系统的求解。\n\n总体目标是评估一种稀疏重构技术在重构高维内力向量方面的有效性，该向量是计算固体力学中的一个关键量。该方法依赖于一系列标准且重要的数值程序：通过牛顿法求解非线性系统，通过本征正交分解（POD）生成降阶基，使用基于 QR 的算法选择最优采样位置，最后，从稀疏测量中重构全向量以计算误差。\n\n首先，我们定义全阶模型（FOM）。系统的状态由位移向量 $u \\in \\mathbb{R}^n$ 描述。内力 $f_{\\mathrm{int}}(u)$ 作为应变能的梯度导出，应变能是总势能 $\\Pi(u)$ 的一个组成部分。给定势能\n$$\n\\Pi(u) = \\tfrac{1}{2} u^{\\mathsf{T}} K u + \\sum_{i=1}^{n} \\tfrac{\\alpha_i}{4} u_i^4 - f^{\\mathsf{T}} u,\n$$\n内力为\n$$\nf_{\\mathrm{int}}(u) = \\nabla_u \\left( \\tfrac{1}{2} u^{\\mathsf{T}} K u + \\sum_{i=1}^{n} \\tfrac{\\alpha_i}{4} u_i^4 \\right) = K u + \\alpha \\odot u^{\\odot 3}.\n$$\n此处，$K \\in \\mathbb{R}^{n \\times n}$ 是线性刚度矩阵，$\\alpha \\in \\mathbb{R}^n$ 是非线性材料系数向量，$\\odot$ 表示逐元素的哈达玛积。对于给定的外载荷向量 $f \\in \\mathbb{R}^n$，通过求解非线性方程组 $f_{\\mathrm{int}}(u) = f$ 来找到静力平衡状态。\n\n为求解此非线性系统，我们采用牛顿法。我们定义残差函数 $r(u) = f_{\\mathrm{int}}(u) - f = K u + \\alpha \\odot u^{\\odot 3} - f$。牛顿法的迭代更新规则是在每一步 $k$ 求解一个线性系统以获得位移修正量 $\\Delta u^{(k)}$：\n$$\nJ(u^{(k)}) \\, \\Delta u^{(k)} = - r(u^{(k)}),\n$$\n随后更新位移向量：\n$$\nu^{(k+1)} = u^{(k)} + \\Delta u^{(k)}.\n$$\n雅可比矩阵 $J(u)$，即切线刚度矩阵，是残差相对于 $u$ 的导数：\n$$\nJ(u) = \\frac{\\partial r(u)}{\\partial u} = K + \\operatorname{diag}(3 \\alpha \\odot u^{\\odot 2}).\n$$\n迭代从初始猜测 $u^{(0)} = 0$ 开始，并持续进行，直到残差的欧几里得范数低于容差 $\\varepsilon = 10^{-10}$。\n\n下一阶段是为降阶模型生成数据。我们生成两组数据：一组用于构建模型的训练集和一组用于评估模型的测试集。对于每组数据，我们从指定的正态分布中生成若干个随机的外载荷向量 $f$。对于每个 $f$，我们使用牛顿求解器求解 FOM 平衡方程 $f_{\\mathrm{int}}(u) = f$ 以找到相应的位移 $u$。计算得到的内力向量 $f_{\\mathrm{int}}(u)$ 被存储为快照矩阵中的一列。这样就得到了训练快照矩阵 $F_{\\mathrm{train}} \\in \\mathbb{R}^{n \\times N_{\\mathrm{train}}}$ 和测试快照矩阵 $F_{\\mathrm{test}} \\in \\mathbb{R}^{n \\times N_{\\mathrm{test}}}$。\n\n收集到训练数据后，我们构建降阶基。使用本征正交分解（POD）方法来找到一个最优地捕捉训练数据方差的低维基。这通过计算训练矩阵的奇异值分解（SVD）来实现：\n$$\nF_{\\mathrm{train}} = U \\Sigma V^{\\mathsf{T}}.\n$$\n左奇异向量，即矩阵 $U \\in \\mathbb{R}^{n \\times n}$ 的列，构成了内力空间的一个标准正交基。我们通过仅保留与最大奇异值相对应的前 $r$ 列来截断此基，从而形成降阶基 $U_r \\in \\mathbb{R}^{n \\times r}$。\n\n稀疏重构中的一个关键步骤是选择一个最优的 $m$ 个测量位置（或传感器布局）集合。我们使用一种称为 Q-DEIM 的方法，该方法采用主元 QR 分解。我们计算降阶基转置 $U_r^{\\mathsf{T}}$ 的主元 QR 分解：\n$$\nU_r^{\\mathsf{T}} P = Q R,\n$$\n其中 $P$ 是一个表示主元顺序的置换矩阵。该置换按线性无关性的降序识别出 $U_r^{\\mathsf{T}}$ 的列（从而对应于 $U_r$ 的行）。我们从此置换中选择前 $m$ 个索引 $\\{p_1, \\dots, p_m\\}$ 作为我们的采样索引集。这些索引定义了一个采样算子 $S \\in \\mathbb{R}^{m \\times n}$，它是一个从向量中提取 $m$ 个相应行的矩阵。\n\n最后，我们在测试数据上评估重构性能。对于测试快照矩阵 $F_{\\mathrm{test}}$ 中的每个测试内力向量 $f_{\\mathrm{test}}$，我们首先对其进行采样以获得其测量值 $S f_{\\mathrm{test}}$。稀疏 POD 方法假设全向量可以近似为基向量的线性组合，$f_{\\mathrm{test}} \\approx \\widehat{f} = U_r c$，其中 $c \\in \\mathbb{R}^r$ 是未知系数。应用采样算子得到 $S f_{\\mathrm{test}} \\approx S U_r c$。我们通过最小化采样条目中的差异（在最小二乘意义上）来求解系数 $c$：\n$$\n\\min_{c \\in \\mathbb{R}^r} \\| S U_r c - S f_{\\mathrm{test}} \\|_2.\n$$\n解由 Moore-Penrose 伪逆（MPP）给出：\n$$\nc = (S U_r)^{+} S f_{\\mathrm{test}}.\n$$\n重构的全状态向量即为 $\\widehat{f} = U_r c$。我们使用相对误差来量化重构的准确性：\n$$\ne = \\frac{\\| \\widehat{f} - f_{\\mathrm{test}} \\|_2}{\\| f_{\\mathrm{test}} \\|_2}.\n$$\n对所有测试快照重复此过程，并为每个指定的基尺寸 $r$ 和采样数 $m$ 的组合计算平均相对误差 $\\bar{e}(r, m)$。计算针对问题陈述中指定的 $(r,m)$ 对进行，最终产生九个误差值。", "answer": "```python\nimport numpy as np\nfrom scipy.linalg import qr, pinv\n\ndef solve():\n    \"\"\"\n    Implements the full pipeline for constructing and evaluating a reduced-order model \n    for internal force reconstruction using gappy POD.\n    \"\"\"\n    \n    # --- 1. Problem Specification ---\n    n = 60\n    alpha_coeffs = 1.0 + 0.5 * np.sin(2 * np.pi * np.arange(1, n + 1) / (n + 1))**2\n    \n    # Newton solver parameters\n    u0 = np.zeros(n)\n    tol = 1e-10\n    max_iter = 50\n    \n    # Data generation parameters\n    n_train = 80\n    n_test = 30\n    sigma = 0.1\n    seed_train = 2025\n    seed_test = 1337\n    \n    # Test cases: (basis_size_r, num_samples_m)\n    test_cases = [\n        (4, 3), (4, 4), (4, 8),\n        (8, 4), (8, 8), (8, 12),\n        (12, 6), (12, 12), (12, 20)\n    ]\n    \n    # --- 2. Full-Order Model (FOM) Definition ---\n    def construct_stiffness_matrix(dim):\n        K = np.diag(np.full(dim, 2.0))\n        K += np.diag(np.full(dim - 1, -1.0), k=1)\n        K += np.diag(np.full(dim - 1, -1.0), k=-1)\n        return K\n\n    K = construct_stiffness_matrix(n)\n\n    def newton_solve(f, u_init, K_mat, alpha_vec, tolerance, max_iterations):\n        \"\"\"Solves the nonlinear system K*u + alpha*(u**3) = f using Newton's method.\"\"\"\n        u = u_init.copy()\n        for _ in range(max_iterations):\n            u_sq = u**2\n            u_cubed = u_sq * u\n            \n            # Residual\n            r = K_mat @ u + alpha_vec * u_cubed - f\n            if np.linalg.norm(r)  tolerance:\n                break\n            \n            # Jacobian\n            J = K_mat + np.diag(3.0 * alpha_vec * u_sq)\n            \n            # Solve linear system for update\n            delta_u = np.linalg.solve(J, -r)\n            u += delta_u\n        \n        # Return the internal force f_int = K*u + alpha*(u**3)\n        return K_mat @ u + alpha_vec * (u**3)\n\n    # --- 3. Snapshot Generation ---\n    def generate_snapshots(num_snapshots, rand_seed):\n        \"\"\"Generates load vectors and solves FOM to get internal force snapshots.\"\"\"\n        rng = np.random.default_rng(rand_seed)\n        f_snapshots = np.zeros((n, num_snapshots))\n        \n        for i in range(num_snapshots):\n            f_ext = rng.normal(0, sigma, n)\n            f_int = newton_solve(f_ext, u0, K, alpha_coeffs, tol, max_iter)\n            f_snapshots[:, i] = f_int\n            \n        return f_snapshots\n\n    F_train = generate_snapshots(n_train, seed_train)\n    F_test = generate_snapshots(n_test, seed_test)\n    \n    # --- 4. ROM Construction: POD Basis ---\n    # Compute SVD of the training data matrix\n    U, _, _ = np.linalg.svd(F_train, full_matrices=False)\n    \n    results = []\n    \n    # --- 5. Evaluation Loop ---\n    for r, m in test_cases:\n        # a. Get reduced basis\n        Ur = U[:, :r]\n        \n        # b. Select sampling indices via pivoted QR on Ur.T (Q-DEIM)\n        _, _, p = qr(Ur.T, pivoting=True)\n        sample_indices = p[:m]\n        \n        # c. Evaluate reconstruction error on test data\n        errors_for_case = []\n        for j in range(F_test.shape[1]):\n            f_test = F_test[:, j]\n            \n            # Sample the test vector and the basis\n            S_Ur = Ur[sample_indices, :]\n            S_f_test = f_test[sample_indices]\n            \n            # Solve for coefficients via Moore-Penrose Pseudoinverse\n            # c = (S*Ur)^+ * (S*f_test)\n            c = pinv(S_Ur) @ S_f_test\n            \n            # Reconstruct the full vector\n            f_recon = Ur @ c\n            \n            # Calculate relative error\n            norm_f_test = np.linalg.norm(f_test)\n            if norm_f_test > 1e-12:\n                error = np.linalg.norm(f_recon - f_test) / norm_f_test\n                errors_for_case.append(error)\n        \n        # d. Compute average error for the (r, m) pair\n        avg_error = np.mean(errors_for_case) if errors_for_case else 0.0\n        results.append(avg_error)\n        \n    # --- 6. Final Output Formatting ---\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2679826"}]}