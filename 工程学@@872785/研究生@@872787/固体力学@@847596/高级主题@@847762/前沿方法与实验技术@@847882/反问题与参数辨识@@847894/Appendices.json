{"hands_on_practices": [{"introduction": "在参数识别中，我们通常假设测量误差服从高斯分布，并使用最小二乘法来最小化模型预测与观测数据之间的残差。然而，真实的实验数据往往包含离群点，这些异常值会对最小二乘估计产生不成比例的巨大影响，从而导致结果失真。本实践练习[@problem_id:2650354]将引导你超越传统的高斯假设，探索如何使用更稳健的损失函数（如Huber损失和学生t分布损失）来减小离群点的影响，从而获得更可靠的材料参数估计。", "problem": "考虑一根一维轴向加载的等截面杆，其长度为 $L$，横截面积为 $A$，由杨氏模量为 $E$ 的线性弹性、均匀、各向同性材料制成。在施加的轴向力 $F$ 作用下，轴向应力为 $\\sigma = F/A$，轴向应变为 $\\varepsilon = \\sigma/E$，杆端缩短（轴向位移）为 $u = \\varepsilon L$。综合这些定义可得正向模型 $u = FL/(AE)$。假设我们试图在存在测量噪声和可能的离群值的情况下，从多组载荷-位移测量值 $\\{(F_i, u_i^{\\mathrm{obs}})\\}_{i=1}^N$ 中识别 $E$。为了获得一个关于未知数的线性反演问题，定义柔度 $p = 1/E$，这样每个数据点的正向模型就变为 $u_i = c_i p$，其中 $c_i = F_i L / A$。\n\n反演问题是根据数据 $\\{(c_i, u_i^{\\mathrm{obs}})\\}_{i=1}^N$，通过最小化残差 $r_i(p) = u_i^{\\mathrm{obs}} - c_i p$ 的数据失配损失之和来估计 $E$（等价于 $p$）。从线性弹性和最大似然估计的原理出发，构建以下三种估计器：\n- 高斯（最小二乘）估计器，它最小化 $\\sum_{i=1}^N \\rho_{\\mathrm{G}}(r_i)$，其中 $\\rho_{\\mathrm{G}}(r) = \\tfrac{1}{2}(r/s)^2$，其中 $s$ 是一个任意的正尺度因子。\n- Huber 估计器，它最小化 $\\sum_{i=1}^N \\rho_{\\mathrm{H}}(r_i)$，其中 $\\rho_{\\mathrm{H}}(r)$ 是阈值为 $\\delta$ 的 Huber 损失。使用一个稳健的、数据驱动的阈值，具体为 $\\delta = 1.345\\, s$，其中 $s$ 是在每次迭代中估计的稳健残差尺度，$s = 1.4826 \\, \\mathrm{MAD}(r)$，$\\mathrm{MAD}(r) = \\mathrm{median}_i(|r_i - \\mathrm{median}_j(r_j)|)$，并在需要时设置一个严格为正的数值下限以避免除以零。\n- 学生 t 估计器，它最小化 $\\sum_{i=1}^N \\rho_{\\mathrm{t}}(r_i)$，其中 $\\rho_{\\mathrm{t}}(r) = \\tfrac{\\nu+1}{2}\\log\\left(1 + \\dfrac{r^2}{\\nu s^2}\\right)$，自由度为 $\\nu$，稳健尺度 $s$ 如上所述。\n\n你的任务是，从第一性原理出发，推导高斯情况下的正规方程以及 Huber 和学生 t 情况的一阶最优性条件，并实现一个算法，该算法：\n- 以闭合形式计算高斯估计值。\n- 使用从影响函数 $\\psi(r) = \\partial \\rho(r)/\\partial r$ 推导出的迭代重加权最小二乘程序来求解 Huber 和学生 t 的情况，使用 $w_i = \\psi(r_i)/r_i$ 作为迭代权重，并在每次迭代中通过加权最小二乘更新 $p$。在每次迭代中重新计算稳健尺度 $s$，对于 Huber 损失，重新计算阈值 $\\delta$。对于学生 t 损失，使用固定的 $\\nu$。迭代直至 $p$ 的变化量低于用户选择的容差或达到最大迭代次数。在优化过程中强制执行物理容许性约束 $E > 0$（等价于 $p > 0$）。\n\n将 $E$ 的最终答案以吉帕斯卡 (GPa) 为单位表示，四舍五入到三位小数。\n\n测试套件。使用以下物理上一致的参数和观测数据。在所有情况下，取 $L = 2$ 米， $A = 10^{-4}$ 米$^2$，真实模量 $E_{\\mathrm{true}} = 210$ GPa，该值仅用于生成无噪声的正向响应，但对于反演求解器是未知的。\n\n- 情况 $\\#1$（行为良好的数据）：$N = 4$，载荷 $\\{F_i\\} = [5000, 10000, 15000, 20000]$ N。对应的无噪声位移为 $[FL/(AE_{\\mathrm{true}})] = [c_i/E_{\\mathrm{true}}] = [10^8, 2\\cdot 10^8, 3\\cdot 10^8, 4\\cdot 10^8]/(210\\cdot 10^9)$ m。观测位移包含小噪声：$u^{\\mathrm{obs}} = [0.0004763904761904762, 0.0009522809523809524, 0.0014287214285714286, 0.0019047119047619049]$ m。\n- 情况 $\\#2$（两个大离群值）：载荷与情况 $\\#1$ 相同。观测位移：$u^{\\mathrm{obs}} = [0.0004763904761904762, 0.0014522809523809524, 0.0008287214285714286, 0.0019047119047619049]$ m。\n- 情况 $\\#3$（接近零的载荷和一个严重离群值）：$N = 4$，载荷 $\\{F_i\\} = [0, 2000, 4000, 30000]$ N。观测位移：$u^{\\mathrm{obs}} = [0.0000001, 0.0001906761904761905, 0.000380852380952381, 0.001857142857142857]$ m。\n\n对于学生 t 损失，所有情况均使用 $\\nu = 3$。对于 Huber，按照规定在每次迭代中根据稳健尺度 $s$ 计算 $\\delta$。对于所有三种情况，你可以用高斯（最小二乘）估计值来初始化迭代方法。使用任何合理的数值容差和迭代上限，以确保这些数据收敛。\n\n最终输出格式。你的程序应生成单行输出，按顺序包含从情况 $\\#1$ 到 $\\#3$ 的结果，即在高斯、Huber 和学生 t 损失下估计的模量（以 GPa 为单位）的三元组，四舍五入到三位小数，并聚合成一个列表的列表，例如：\n- 输出形状：$\\big[[E_{\\mathrm{G},1}, E_{\\mathrm{H},1}, E_{\\mathrm{t},1}], [E_{\\mathrm{G},2}, E_{\\mathrm{H},2}, E_{\\mathrm{t},2}], [E_{\\mathrm{G},3}, E_{\\mathrm{H},3}, E_{\\mathrm{t},3}]\\big]$。\n- 单位说明：所有条目均以 GPa 表示。\n- 四舍五入说明：将每个条目精确到三位小数。", "solution": "所述问题经过了严格的验证。\n\n**步骤 1：提取的已知条件**\n- **物理模型**：一根长度为 $L$、面积为 $A$、杨氏模量为 $E$ 的一维等截面杆。\n- **正向模型**：在轴向力 $F$ 作用下，杆端缩短 $u$ 由 $u = FL/(AE)$ 给出。\n- **反演问题构建**：\n    - 未知参数：柔度 $p = 1/E$。\n    - 线性化模型：$u_i = c_i p$，其中 $c_i = F_i L / A$。\n    - 数据：一组 $N$ 个测量值 $\\{(F_i, u_i^{\\mathrm{obs}})\\}_{i=1}^N$。\n    - 目标：通过最小化关于残差 $r_i(p) = u_i^{\\mathrm{obs}} - c_i p$ 的成本函数 $J(p) = \\sum_{i=1}^N \\rho(r_i)$ 来估计 $p$。\n- **损失函数**：\n    1.  **高斯**：$\\rho_{\\mathrm{G}}(r) = \\tfrac{1}{2}(r/s)^2$。\n    2.  **Huber**：$\\rho_{\\mathrm{H}}(r)$，一个具有数据驱动阈值 $\\delta = 1.345\\, s$ 的 Huber 损失，其中 $s$ 是一个稳健的尺度估计。\n    3.  **学生 t**：$\\rho_{\\mathrm{t}}(r) = \\tfrac{\\nu+1}{2}\\log\\left(1 + \\dfrac{r^2}{\\nu s^2}\\right)$，自由度为 $\\nu$。\n- **稳健尺度估计**：$s = 1.4826 \\, \\mathrm{MAD}(r)$，其中 $\\mathrm{MAD}(r) = \\mathrm{median}_i(|r_i - \\mathrm{median}_j(r_j)|)$。建议使用一个正的数值下限。\n- **算法要求**：\n    - 推导高斯情况下的正规方程并提供闭合形式解。\n    - 推导 Huber 和学生 t 情况的一阶最优性条件。\n    - 为 Huber 和学生 t 实现迭代重加权最小二乘 (IRLS) 程序，其中权重由 $w_i = \\psi(r_i)/r_i$ 定义，且 $\\psi(r) = \\partial \\rho/\\partial r$。必须在每次迭代中重新计算尺度 $s$ 和阈值 $\\delta$。\n    - 强制执行物理容许性约束 $E > 0$（即 $p > 0$）。\n- **测试数据**：\n    - 公共参数：$L = 2$ 米， $A = 10^{-4}$ 米$^2$，学生 t 估计器的 $\\nu = 3$。\n    - 情况 $\\#1$：行为良好的数据，力 $\\{F_i\\} = [5000, 10000, 15000, 20000]$ N，对应的位移 $u^{\\mathrm{obs}} = [0.00047639..., 0.00095228..., 0.00142872..., 0.00190471...]$ m。\n    - 情况 $\\#2$：带有两个离群值的数据，力与情况 $\\#1$ 相同，但 $u^{\\mathrm{obs}} = [0.00047639..., 0.00145228..., 0.00082872..., 0.00190471...]$ m。\n    - 情况 $\\#3$：带有接近零的载荷和一个严重离群值的数据，力 $\\{F_i\\} = [0, 2000, 4000, 30000]$ N，且 $u^{\\mathrm{obs}} = [0.0000001, 0.00019067..., 0.00038085..., 0.00185714...]$ m。\n\n**步骤 2：使用提取的已知条件进行验证**\n对问题进行有效性评估。\n- **科学基础**：该问题基于线性弹性的基本理论和统计参数估计（最大似然、稳健回归）的既定原则。这是合理的。\n- **适定性**：该构建导致了单个参数的凸优化问题，这些问题允许唯一且稳定的解。该问题是适定的。\n- **客观性**：问题使用精确的数学和物理术语陈述，没有主观性或模糊性。\n- **完整性**：提供了所有必要的参数、数据和算法约束。问题是自包含的。\n- **现实性**：物理参数和数据对于典型的涉及实验测量的工程场景是一致和现实的。噪声和离群值的存在是指定方法所解决的实际问题。\n\n**步骤 3：结论与行动**\n该问题在科学上是合理的、适定的、客观的和完整的。它代表了应用于固体力学的反演问题理论中的一个标准的、非平凡的任务。因此，该问题被认为是**有效的**，并将提供一个解。\n\n---\n\n**求解推导**\n\n目标是找到最小化总损失 $J(p) = \\sum_{i=1}^N \\rho(r_i(p))$ 的柔度 $p$，其中 $r_i(p) = u_i^{\\mathrm{obs}} - c_i p$。最小化的一阶必要条件是目标函数对未知参数 $p$ 的导数必须为零：\n$$\n\\frac{dJ}{dp} = \\sum_{i=1}^N \\frac{d\\rho(r_i)}{dr_i} \\frac{dr_i}{dp} = 0\n$$\n残差的导数是 $\\frac{dr_i}{dp} = -c_i$。损失函数 $\\rho$ 对其参数的导数是影响函数，$\\psi(r) = d\\rho/dr$。因此，最优性条件是：\n$$\n\\sum_{i=1}^N \\psi(r_i) (-c_i) = 0 \\quad \\implies \\quad \\sum_{i=1}^N c_i \\psi(r_i(p)) = 0\n$$\n\n**1. 高斯（最小二乘）估计器**\n对于高斯情况，损失为 $\\rho_{\\mathrm{G}}(r) = \\frac{1}{2s^2} r^2$。常数因子 $\\frac{1}{2s^2}$ 在最小化时可以忽略，所以我们实际上是最小化 $J_{LS}(p) = \\sum_{i=1}^N r_i^2$。影响函数为 $\\psi_{\\mathrm{G}}(r) = r$。\n代入最优性条件：\n$$\n\\sum_{i=1}^N c_i r_i = \\sum_{i=1}^N c_i (u_i^{\\mathrm{obs}} - c_i p) = 0\n$$\n整理关于 $p$ 的方程，得到正规方程：\n$$\n\\left(\\sum_{i=1}^N c_i^2\\right) p = \\sum_{i=1}^N c_i u_i^{\\mathrm{obs}}\n$$\n这给出了最小二乘估计 $p_{\\mathrm{LS}}$ 的闭合形式解：\n$$\np_{\\mathrm{LS}} = \\frac{\\sum_{i=1}^N c_i u_i^{\\mathrm{obs}}}{\\sum_{i=1}^N c_i^2} = \\frac{\\mathbf{c}^T \\mathbf{u}^{\\mathrm{obs}}}{\\mathbf{c}^T \\mathbf{c}}\n$$\n其中 $\\mathbf{c} = [c_1, \\dots, c_N]^T$ 且 $\\mathbf{u}^{\\mathrm{obs}} = [u_1^{\\mathrm{obs}}, \\dots, u_N^{\\mathrm{obs}}]^T$。\n\n**2. 用于稳健估计器的迭代重加权最小二乘（IRLS）**\n对于 Huber 和学生 t 估计器，最优性条件 $\\sum_i c_i \\psi(r_i(p)) = 0$ 是关于 $p$ 的非线性方程，需要迭代求解。IRLS 算法通过定义权重函数 $w(r) = \\psi(r)/r$ 来推导。最优性条件可以重写为：\n$$\n\\sum_{i=1}^N c_i w(r_i) r_i = \\sum_{i=1}^N c_i w(r_i) (u_i^{\\mathrm{obs}} - c_i p) = 0\n$$\n如果权重 $w_i$ 保持不变，这个方程是关于 $p$ 的线性方程。这提示了一个迭代过程。在第 $k+1$ 次迭代中，给定估计值 $p^{(k)}$，我们计算残差 $r_i^{(k)}$，然后计算权重 $w_i^{(k)} = w(r_i^{(k)})$，并解出新的估计值 $p^{(k+1)}$：\n$$\n\\left(\\sum_{i=1}^N w_i^{(k)} c_i^2\\right) p^{(k+1)} = \\sum_{i=1}^N w_i^{(k)} c_i u_i^{\\mathrm{obs}}\n$$\n$$\np^{(k+1)} = \\frac{\\sum_{i=1}^N w_i^{(k)} c_i u_i^{\\mathrm{obs}}}{\\sum_{i=1}^N w_i^{(k)} c_i^2} = \\frac{\\mathbf{c}^T \\mathbf{W}^{(k)} \\mathbf{u}^{\\mathrm{obs}}}{\\mathbf{c}^T \\mathbf{W}^{(k)} \\mathbf{c}}\n$$\n其中 $\\mathbf{W}^{(k)}$ 是一个对角矩阵，其对角线元素为 $w_i^{(k)}$。迭代继续进行，直到收敛，即 $|p^{(k+1)} - p^{(k)}|$ 小于预设的容差。\n\n**2.1. Huber 估计器**\nHuber 影响函数是 $\\psi_{\\mathrm{H}}(r) = \\mathrm{min}(|r|, \\delta) \\, \\mathrm{sgn}(r)$。因此，权重函数是：\n$$\nw_{\\mathrm{H}}(r) = \\frac{\\psi_{\\mathrm{H}}(r)}{r} = \\begin{cases} 1 & |r| \\le \\delta \\\\ \\delta/|r| & |r| > \\delta \\end{cases} = \\mathrm{min}(1, \\delta/|r|)\n$$\n在每次 IRLS 迭代中，根据当前残差 $\\mathbf{r}^{(k)}$ 计算稳健尺度 $s^{(k)}$，并将阈值更新为 $\\delta^{(k)} = 1.345 s^{(k)}$。这些值用于计算权重 $w_i^{(k)}$。\n\n**2.2. 学生 t 估计器**\n损失函数为 $\\rho_{\\mathrm{t}}(r) = \\frac{\\nu+1}{2}\\log(1 + \\frac{r^2}{\\nu s^2})$。影响函数是：\n$$\n\\psi_{\\mathrm{t}}(r) = \\frac{d\\rho_t}{dr} = \\frac{\\nu+1}{2} \\cdot \\frac{1}{1 + r^2/(\\nu s^2)} \\cdot \\frac{2r}{\\nu s^2} = \\frac{(\\nu+1)r}{\\nu s^2 + r^2}\n$$\n相应的权重函数是：\n$$\nw_{\\mathrm{t}}(r) = \\frac{\\psi_{\\mathrm{t}}(r)}{r} = \\frac{\\nu+1}{\\nu s^2 + r^2}\n$$\n在每次 IRLS 迭代中，根据当前残差 $\\mathbf{r}^{(k)}$ 计算稳健尺度 $s^{(k)}$，然后用它来计算权重 $w_i^{(k)}$。\n\n**3. 物理容许性**\n物理约束 $E > 0$ 意味着 $p > 0$。在 IRLS 更新中，分母 $\\sum w_i c_i^2$ 保证为正，因为对于 Huber 和学生 t 估计器，$w_i > 0$ 且 $c_i^2 \\ge 0$。对于物理上合理的数据，其中施加的力 $F_i$（因此 $c_i$）和测量的位移 $u_i^{\\mathrm{obs}}$ 符号相同，分子 $\\sum w_i c_i u_i^{\\mathrm{obs}}$ 预期为正。如果数值更新产生 $p \\le 0$，则通过将其钳位在一个小的正值 $\\epsilon_p > 0$ 上，将其投影到容许集上。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for Young's modulus E using Gaussian, Huber, and Student's-t estimators\n    for three different data cases.\n    \"\"\"\n    # Common physical parameters\n    L = 2.0  # m\n    A = 1.0e-4  # m^2\n\n    # Test suite containing three cases\n    test_cases = [\n        {\n            \"F\": np.array([5000, 10000, 15000, 20000]),  # N\n            \"u_obs\": np.array([0.0004763904761904762, 0.0009522809523809524, \n                               0.0014287214285714286, 0.0019047119047619049])  # m\n        },\n        {\n            \"F\": np.array([5000, 10000, 15000, 20000]),  # N\n            \"u_obs\": np.array([0.0004763904761904762, 0.0014522809523809524, \n                               0.0008287214285714286, 0.0019047119047619049])  # m\n        },\n        {\n            \"F\": np.array([0, 2000, 4000, 30000]),  # N\n            \"u_obs\": np.array([0.0000001, 0.0001906761904761905, \n                               0.000380852380952381, 0.001857142857142857])  # m\n        }\n    ]\n\n    # IRLS algorithm parameters\n    nu = 3.0  # Degrees of freedom for Student's-t loss\n    tol = 1.0e-12  # Convergence tolerance for compliance p\n    max_iter = 100  # Maximum number of iterations\n    s_floor = 1.0e-12  # Numerical floor for robust scale s\n    p_floor = 1.0e-15  # Numerical floor for compliance p (to enforce p > 0)\n\n    all_results = []\n\n    for case in test_cases:\n        F = case[\"F\"]\n        u_obs = case[\"u_obs\"]\n        c = F * L / A  # Model coefficients\n\n        # --- Gaussian (Least-Squares) Estimator ---\n        # Closed-form solution: p_ls = (c^T u_obs) / (c^T c)\n        p_ls_numerator = np.dot(c, u_obs)\n        p_ls_denominator = np.dot(c, c)\n        p_ls = p_ls_numerator / p_ls_denominator if p_ls_denominator > 0 else 0.0\n        \n        # Ensure physical admissibility\n        p_ls = max(p_ls, p_floor)\n        E_g_gpa = (1.0 / p_ls) / 1.0e9\n\n        case_results = [E_g_gpa]\n\n        # --- Huber Estimator (IRLS) ---\n        p_h = p_ls  # Initialize with LS estimate\n        for _ in range(max_iter):\n            r = u_obs - c * p_h\n            \n            # Robust scale estimation (MAD)\n            med_r = np.median(r)\n            mad = np.median(np.abs(r - med_r))\n            s = max(1.4826 * mad, s_floor)\n            delta = 1.345 * s\n\n            # Calculate weights\n            abs_r = np.abs(r)\n            # Handle r_i -> 0 case by setting weight to 1\n            weights_h = np.ones_like(r)\n            nonzero_r_mask = abs_r > 1e-12\n            weights_h[nonzero_r_mask] = np.minimum(1.0, delta / abs_r[nonzero_r_mask])\n            \n            # Weighted least squares update\n            numerator = np.dot(c, weights_h * u_obs)\n            denominator = np.dot(c, weights_h * c)\n            \n            p_h_new = numerator / denominator if denominator > 0 else p_h\n            p_h_new = max(p_h_new, p_floor)  # Enforce positivity\n\n            if np.abs(p_h_new - p_h)  tol:\n                p_h = p_h_new\n                break\n            \n            p_h = p_h_new\n        \n        E_h_gpa = (1.0 / p_h) / 1.0e9\n        case_results.append(E_h_gpa)\n        \n        # --- Student's-t Estimator (IRLS) ---\n        p_t = p_ls  # Initialize with LS estimate\n        for _ in range(max_iter):\n            r = u_obs - c * p_t\n\n            # Robust scale estimation (MAD)\n            med_r = np.median(r)\n            mad = np.median(np.abs(r - med_r))\n            s = max(1.4826 * mad, s_floor)\n            \n            # Calculate weights\n            weights_t = (nu + 1.0) / (nu * s**2 + r**2)\n            \n            # Weighted least squares update\n            numerator = np.dot(c, weights_t * u_obs)\n            denominator = np.dot(c, weights_t * c)\n\n            p_t_new = numerator / denominator if denominator > 0 else p_t\n            p_t_new = max(p_t_new, p_floor) # Enforce positivity\n\n            if np.abs(p_t_new - p_t)  tol:\n                p_t = p_t_new\n                break\n            \n            p_t = p_t_new\n\n        E_t_gpa = (1.0 / p_t) / 1.0e9\n        case_results.append(E_t_gpa)\n        \n        all_results.append(case_results)\n\n    # Format the final output string according to the problem specification\n    final_output_parts = []\n    for case_res_list in all_results:\n        formatted_list = [f\"{val:.3f}\" for val in case_res_list]\n        final_output_parts.append(f\"[{','.join(formatted_list)}]\")\n    \n    print(f\"[{','.join(final_output_parts)}]\")\n\nsolve()\n```", "id": "2650354"}, {"introduction": "除了处理数据中的噪声和离群点，逆问题的另一个核心挑战是模型误差，即我们用来描述物理系统的数学模型本身可能是不完美的。本实践练习[@problem_id:2650379]通过一个具体的数值实验来阐明这一问题。你将看到，在识别空间变化的杨氏模量$E(x)$时，仅仅因为对泊松比$\\nu$做出了一个不准确的假设，就会对识别结果引入系统性的偏差。这个练习强调了批判性地评估正向模型中所有假设的重要性。", "problem": "考虑一个长度为 $L$、横截面积恒为 $A$ 的长棱柱杆中，空间变化的杨氏模量 $E(x)$ 的一维识别问题。该杆受到侧向约束，使得其变形为单轴应变状态。在 $x=L$ 处，该杆受到恒定的轴向力 $P$ 加载，并满足 $u(0)=0$，其中 $u(x)$ 表示轴向位移。假设为线性弹性和小应变。您将使用已知的真实模量场 $E_{\\mathrm{true}}(x)$ 和真实泊松比 $\\nu_{\\mathrm{true}}$ 来生成合成（无噪声）位移数据，然后假设一个可能不正确的泊松比 $\\nu_{\\mathrm{assumed}}$，对 $E(x)$ 进行局部（逐点）反演识别。您的目标是计算仅由泊松比设定错误所导致的恢复模量场中的平均相对偏差。\n\n推导和算法必须仅从以下基本原理出发：\n- 一维线性动量平衡：在没有体力的情况下，$\\dfrac{d \\sigma_{xx}}{dx} = 0$，其中 $\\sigma_{xx}(x)$ 是轴向 Cauchy 应力。\n- 小应变运动学：$\\epsilon_{xx}(x) = \\dfrac{du}{dx}$，其中 $\\epsilon_{xx}(x)$ 是轴向应变。\n- 三维线性各向同性弹性（Hooke 定律）：$\\boldsymbol{\\sigma} = 2 \\mu \\boldsymbol{\\epsilon} + \\lambda \\, \\mathrm{tr}(\\boldsymbol{\\epsilon}) \\, \\mathbf{I}$，其中 Lamé 参数为 $\\mu = \\dfrac{E}{2(1+\\nu)}$ 和 $\\lambda = \\dfrac{E \\nu}{(1+\\nu)(1-2\\nu)}$，$E$ 是杨氏模量，$\\nu$ 是泊松比。\n- 单轴应变条件：$\\epsilon_{yy} = \\epsilon_{zz} = 0$。\n\n在这些基本原理下，您必须构建一个合成正向模型以生成 $u(x)$，然后构建一个反演估计器，以从 $u(x)$、$P$ 和 $A$ 中恢复 $E(x)$，同时在反演步骤中明确假设一个可能与 $\\nu_{\\mathrm{true}}$ 不同的值 $\\nu_{\\mathrm{assumed}}$。不应添加观测噪声；唯一的误差来源必须是反演步骤中设定的错误泊松比。\n\n固定的物理和数值设置（请严格使用这些设置）：\n- 几何与载荷：$L = 1 \\ \\mathrm{m}$，$A = 1 \\times 10^{-4} \\ \\mathrm{m}^2$，$P = 3 \\times 10^{3} \\ \\mathrm{N}$。\n- 真实模量场：$E_{\\mathrm{true}}(x) = E_{0} \\left[ 1 + 0.4 \\sin\\left(2 \\pi \\dfrac{x}{L}\\right) + 0.2 \\cos\\left(4 \\pi \\dfrac{x}{L}\\right) \\right]$，其中 $E_{0} = 70 \\times 10^{9} \\ \\mathrm{Pa}$。\n- 离散化：在 $[0,L]$ 上使用 $N = 1001$ 个均匀间隔的点。\n\n正向（合成）模型规范（推导并实现）：\n- 根据线性动量平衡，轴向应力在空间上是恒定的，等于 $\\sigma_{xx}(x) = \\dfrac{P}{A}$。\n- 在三维线性弹性定律中使用单轴应变条件，确定连接 $\\sigma_{xx}(x)$、$\\epsilon_{xx}(x)$、$E_{\\mathrm{true}}(x)$ 和 $\\nu_{\\mathrm{true}}$ 的关系。用它来计算 $\\epsilon_{xx}^{\\mathrm{true}}(x)$，然后通过对 $\\epsilon_{xx}^{\\mathrm{true}}(x)$ 积分并满足 $u^{\\mathrm{true}}(0)=0$ 来计算 $u^{\\mathrm{true}}(x)$。\n\n反演（恢复）模型规范（推导并实现）：\n- 给定 $u^{\\mathrm{true}}(x)$，使用离散差分从数值上近似 $\\epsilon_{xx}(x)$。\n- 使用相同的单轴应变关系，但使用 $\\nu_{\\mathrm{assumed}}$ 和已知的 $\\sigma_{xx} = \\dfrac{P}{A}$，逐点恢复一个场 $E_{\\mathrm{rec}}(x)$。\n\n需要报告的偏差度量：\n- 计算逐点相对偏差 $b(x) = \\dfrac{E_{\\mathrm{rec}}(x) - E_{\\mathrm{true}}(x)}{E_{\\mathrm{true}}(x)}$，并报告每个测试案例的平均相对偏差 $\\overline{b} = \\dfrac{1}{N} \\sum_{i=1}^{N} b(x_i)$。\n- 将每个平均相对偏差表示为小数（不带百分号）。\n\n测试套件（按顺序独立评估每个案例）：\n- 案例 1：$\\nu_{\\mathrm{true}} = 0.30$，$\\nu_{\\mathrm{assumed}} = 0.30$。\n- 案例 2：$\\nu_{\\mathrm{true}} = 0.30$，$\\nu_{\\mathrm{assumed}} = 0.25$。\n- 案例 3：$\\nu_{\\mathrm{true}} = 0.45$，$\\nu_{\\mathrm{assumed}} = 0.30$。\n- 案例 4：$\\nu_{\\mathrm{true}} = -0.20$，$\\nu_{\\mathrm{assumed}} = 0.20$。\n- 案例 5：$\\nu_{\\mathrm{true}} = 0.49$，$\\nu_{\\mathrm{assumed}} = 0.48$。\n\n您的程序必须：\n- 严格按照规范实现正向和反演步骤。\n- 对所有物理量使用 $\\mathrm{SI}$ 单位（米、牛顿、帕斯卡）；报告的平均相对偏差是无量纲的，必须以小数形式输出。\n- 生成单行输出，其中包含上述案例的五个平均相对偏差值，以逗号分隔，并用方括号括起来，顺序与规定一致。在打印前将每个值四舍五入到六位小数，例如 $[0.000000,0.123456,\\dots]$。", "solution": "该问题已经过验证，被认为是科学上合理、适定且完整的。我们将着手进行推导和求解。\n\n分析从指定的基本连续介质力学原理开始。目标是量化由于泊松比 $\\nu$ 设定错误而在反演识别的杨氏模量 $E(x)$ 中产生的偏差。\n\n首先，我们为指定的单轴应变状态建立一维本构关系。三维线性各向同性弹性定律由下式给出：\n$$\n\\boldsymbol{\\sigma} = \\lambda \\, \\mathrm{tr}(\\boldsymbol{\\epsilon}) \\, \\mathbf{I} + 2 \\mu \\boldsymbol{\\epsilon}\n$$\n其中 $\\boldsymbol{\\sigma}$ 是 Cauchy 应力张量，$\\boldsymbol{\\epsilon}$ 是无穷小应变张量，$\\mathbf{I}$ 是二阶单位张量，$\\lambda$ 和 $\\mu$ 是 Lamé 参数。它们与杨氏模量 $E$ 和泊松比 $\\nu$ 的关系如下：\n$$\n\\lambda = \\frac{E \\nu}{(1+\\nu)(1-2\\nu)}, \\quad \\mu = \\frac{E}{2(1+\\nu)}\n$$\n问题陈述了单轴应变条件，这意味着应变张量分量为 $\\epsilon_{xx}(x) \\neq 0$ 和 $\\epsilon_{yy} = \\epsilon_{zz} = \\epsilon_{xy} = \\epsilon_{yz} = \\epsilon_{zx} = 0$。因此，应变张量的迹为 $\\mathrm{tr}(\\boldsymbol{\\epsilon}) = \\epsilon_{xx}$。应力张量的轴向分量 $\\sigma_{xx}$ 于是为：\n$$\n\\sigma_{xx} = \\lambda \\epsilon_{xx} + 2 \\mu \\epsilon_{xx} = (\\lambda + 2\\mu) \\epsilon_{xx}\n$$\n项 $M = \\lambda + 2\\mu$ 是 P 波模量，在单轴应变条件下，它充当有效的一维弹性模量。我们将 $M$ 用 $E$ 和 $\\nu$ 表示：\n$$\nM = \\frac{E \\nu}{(1+\\nu)(1-2\\nu)} + 2 \\left( \\frac{E}{2(1+\\nu)} \\right) = \\frac{E}{1+\\nu} \\left( \\frac{\\nu}{1-2\\nu} + 1 \\right) = \\frac{E(1-\\nu)}{(1+\\nu)(1-2\\nu)}\n$$\n因此，一维本构定律是：\n$$\n\\sigma_{xx}(x) = M(x) \\epsilon_{xx}(x) = \\frac{E(x)(1-\\nu)}{(1+\\nu)(1-2\\nu)} \\epsilon_{xx}(x)\n$$\n注意，$E$ 以及因此 $M$ 都是空间坐标 $x$ 的函数。\n\n在没有体力的情况下，一维线性动量平衡为 $\\frac{d\\sigma_{xx}}{dx} = 0$。这意味着轴向应力 $\\sigma_{xx}$ 沿杆是恒定的。给定在杆端 $x=L$ 施加的力 $P$ 和恒定的横截面积 $A$，应力是均匀的：\n$$\n\\sigma_{xx}(x) = \\frac{P}{A}\n$$\n\n求解过程分两个阶段进行：一个用于生成合成数据的正向模型，以及一个用于识别目标参数的反演模型。\n\n1.  **正向模型：生成合成位移数据**\n    我们使用真实材料属性 $E_{\\mathrm{true}}(x)$ 和 $\\nu_{\\mathrm{true}}$ 来计算真实应变场 $\\epsilon_{xx}^{\\mathrm{true}}(x)$。从推导的本构定律可知：\n    $$\n    \\epsilon_{xx}^{\\mathrm{true}}(x) = \\frac{\\sigma_{xx}}{M_{\\mathrm{true}}(x)} = \\frac{P}{A} \\left( \\frac{(1+\\nu_{\\mathrm{true}})(1-2\\nu_{\\mathrm{true}})}{E_{\\mathrm{true}}(x)(1-\\nu_{\\mathrm{true}})} \\right)\n    $$\n    其中 $E_{\\mathrm{true}}(x) = E_{0} \\left[ 1 + 0.4 \\sin\\left(2 \\pi \\frac{x}{L}\\right) + 0.2 \\cos\\left(4 \\pi \\frac{x}{L}\\right) \\right]$。轴向位移 $u^{\\mathrm{true}}(x)$ 通过对应变场积分得到，并考虑边界条件 $u(0)=0$：\n    $$\n    u^{\\mathrm{true}}(x) = \\int_0^x \\epsilon_{xx}^{\\mathrm{true}}(s) \\, ds\n    $$\n    此积分在 $N=1001$ 个点的离散网格上进行数值计算。\n\n2.  **反演模型：恢复杨氏模量**\n    反演过程使用合成位移数据 $u^{\\mathrm{true}}(x)$ 来恢复杨氏模量，但假设使用的是一个可能不正确的泊松比 $\\nu_{\\mathrm{assumed}}$。\n    首先，通过对位移场进行数值微分来估计应变场：$\\epsilon_{xx}^{\\mathrm{num}}(x) = \\frac{du^{\\mathrm{true}}}{dx}$。这通过有限差分近似来完成。\n    接下来，我们重排本构方程以求解恢复的模量 $E_{\\mathrm{rec}}(x)$。该模型假设关系为 $\\sigma_{xx} = M_{\\mathrm{rec}}(x) \\epsilon_{xx}^{\\mathrm{num}}(x)$，其中 $M_{\\mathrm{rec}}(x)$ 基于 $E_{\\mathrm{rec}}(x)$ 和 $\\nu_{\\mathrm{assumed}}$：\n    $$\n    E_{\\mathrm{rec}}(x) = M_{\\mathrm{rec}}(x) \\frac{(1+\\nu_{\\mathrm{assumed}})(1-2\\nu_{\\mathrm{assumed}})}{1-\\nu_{\\mathrm{assumed}}}\n    $$\n    代入 $M_{\\mathrm{rec}}(x) = \\frac{\\sigma_{xx}}{\\epsilon_{xx}^{\\mathrm{num}}(x)}$，我们得到：\n    $$\n    E_{\\mathrm{rec}}(x) = \\frac{P}{A} \\frac{1}{\\epsilon_{xx}^{\\mathrm{num}}(x)} \\left( \\frac{(1+\\nu_{\\mathrm{assumed}})(1-2\\nu_{\\mathrm{assumed}})}{1-\\nu_{\\mathrm{assumed}}} \\right)\n    $$\n    此方程允许逐点恢复杨氏模量场。\n\n3.  **偏差分析**\n    逐点相对偏差定义为 $b(x) = \\frac{E_{\\mathrm{rec}}(x) - E_{\\mathrm{true}}(x)}{E_{\\mathrm{true}}(x)} = \\frac{E_{\\mathrm{rec}}(x)}{E_{\\mathrm{true}}(x)} - 1$。\n    如果我们忽略数值微分引入的微小误差，使得 $\\epsilon_{xx}^{\\mathrm{num}}(x) \\approx \\epsilon_{xx}^{\\mathrm{true}}(x)$，我们就可以推导出偏差的解析表达式。将 $\\epsilon_{xx}^{\\mathrm{true}}(x)$ 的表达式代入 $E_{\\mathrm{rec}}(x)$ 的恢复方程中：\n    $$\n    E_{\\mathrm{rec}}(x) \\approx E_{\\mathrm{true}}(x) \\left[ \\frac{(1+\\nu_{\\mathrm{true}})(1-2\\nu_{\\mathrm{true}})}{1-\\nu_{\\mathrm{true}}} \\right]^{-1} \\left[ \\frac{(1+\\nu_{\\mathrm{assumed}})(1-2\\nu_{\\mathrm{assumed}})}{1-\\nu_{\\mathrm{assumed}}} \\right]\n    $$\n    因此，相对偏差近似为常数，且与 $x$ 无关：\n    $$\n    b(x) \\approx \\frac{F(\\nu_{\\mathrm{assumed}})}{F(\\nu_{\\mathrm{true}})} - 1, \\quad \\text{其中 } F(\\nu) = \\frac{(1+\\nu)(1-2\\nu)}{1-\\nu}\n    $$\n    需要报告的量是平均相对偏差 $\\overline{b}$，它是通过对每个测试案例中所有 $N$ 个网格点上的 $b(x_i)$ 进行平均计算得出的。由于解析偏差近似为常数，平均值将非常接近这个理论预测值，其中微小的偏差来自于数值积分和微分误差。\n\n最终的算法是通过对测试套件中的每一对 $(\\nu_{\\mathrm{true}}, \\nu_{\\mathrm{assumed}})$ 执行这些步骤来实现的。", "answer": "```python\nimport numpy as np\nfrom scipy.integrate import cumulative_trapezoid\n\ndef solve():\n    \"\"\"\n    Computes the mean relative bias in recovered Young's modulus due to\n    Poisson's ratio misspecification in a 1D inverse problem.\n    \"\"\"\n    # Fixed physical and numerical settings\n    L = 1.0  # m\n    A = 1.0e-4  # m^2\n    P = 3.0e3  # N\n    E0 = 70.0e9  # Pa\n    N = 1001  # number of points\n\n    # Discretization\n    x = np.linspace(0, L, N)\n    \n    # Ground-truth modulus field\n    E_true = E0 * (1.0 + 0.4 * np.sin(2.0 * np.pi * x / L) + 0.2 * np.cos(4.0 * np.pi * x / L))\n    \n    # Constant axial stress\n    sigma_xx = P / A\n\n    # Test cases: (nu_true, nu_assumed)\n    test_cases = [\n        (0.30, 0.30),\n        (0.30, 0.25),\n        (0.45, 0.30),\n        (-0.20, 0.20),\n        (0.49, 0.48),\n    ]\n\n    results = []\n\n    def poisson_factor_F(nu):\n        \"\"\"\n        Calculates the factor G(nu) from the solution derivation:\n        G(nu) = (1+nu)*(1-2*nu) / (1-nu)\n        \"\"\"\n        if nu == 1.0 or nu == 0.5 or nu == -1.0:\n            return np.nan # Prevent division by zero / instability\n        return (1.0 + nu) * (1.0 - 2.0 * nu) / (1.0 - nu)\n\n    for nu_true, nu_assumed in test_cases:\n        # --- FORWARD MODEL ---\n        # 1. Compute true strain field\n        # The 1D constitutive law for uniaxial strain is sigma_xx = M * eps_xx,\n        # where M = E * (1-nu) / ((1+nu)*(1-2*nu)).\n        # Rearranging for strain: eps_xx = sigma_xx * ((1+nu)*(1-2*nu)) / (E * (1-nu))\n        # which is eps_xx = (sigma_xx / E) * G(nu)\n        factor_for_strain_calc = poisson_factor_F(nu_true)\n        eps_xx_true = (sigma_xx / E_true) * factor_for_strain_calc\n        \n        # 2. Compute true displacement by integrating strain\n        # u(x) = integral from 0 to x of eps(s) ds, with u(0)=0.\n        u_true = cumulative_trapezoid(eps_xx_true, x, initial=0.0)\n        \n        # --- INVERSE MODEL ---\n        # 1. Numerically differentiate displacement to get strain\n        # eps_num(x) = du/dx\n        eps_xx_num = np.gradient(u_true, x)\n        \n        # 2. Recover Young's modulus E_rec\n        # From the constitutive law, E_rec = M_rec * ((1+nu_assumed)(1-2*nu_assumed))/(1-nu_assumed)\n        # and M_rec = sigma_xx / eps_xx_num.\n        # So E_rec = (sigma_xx / eps_xx_num) * G(nu_assumed)\n        factor_for_E_rec = poisson_factor_F(nu_assumed)\n        \n        # To avoid potential division by zero if eps_xx_num is ever zero\n        # (not expected here, but good practice).\n        # We know eps_xx is strictly positive for P>0.\n        E_rec = (sigma_xx / eps_xx_num) * factor_for_E_rec\n        \n        # --- BIAS CALCULATION ---\n        # Calculate pointwise relative bias\n        relative_bias = (E_rec - E_true) / E_true\n        \n        # Calculate mean relative bias\n        mean_relative_bias = np.mean(relative_bias)\n        \n        results.append(mean_relative_bias)\n        \n    # Format the final output as a comma-separated list of strings,\n    # with each value rounded to six decimal places.\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2650379"}, {"introduction": "在掌握了如何处理不完美的数据和模型之后，一个自然而然的问题是：我们如何主动设计实验来获取信息量最大的数据？本实践练习[@problem_id:2650344]将你带入实验设计优化的领域。通过使用贝叶斯框架，你将定量地比较不同力学测试（单轴拉伸、双轴拉伸和剪切）在识别Mooney-Rivlin材料参数时的价值。这项练习旨在培养一种战略性思维，即如何设计实验，以便最有效地约束我们感兴趣的参数，从而最大限度地减少其后验不确定性。", "problem": "考虑一个不可压缩、各向同性的超弹性固体，其模型为Mooney–Rivlin存储能量密度函数，由$W = C_{10} (I_{1} - 3) + C_{01} (I_{2} - 3)$给出，其中$C_{10}$和$C_{01}$是待辨识的未知材料参数，$I_{1}$和$I_{2}$是左Cauchy–Green张量$B$的第一和第二不变量。对于一个存储能量为$W(I_{1}, I_{2})$的不可压缩各向同性超弹性材料，其Cauchy应力由标准公式$\\sigma = -p \\, I + 2 \\, \\partial W / \\partial I_{1} \\, B - 2 \\, \\partial W / \\partial I_{2} \\, B^{-1}$给出，其中$p$是强制施加不可压缩性约束的Lagrange乘子。在三种典型试验类型中，主拉伸或变形梯度规定如下：(i) 单轴拉伸，主拉伸为$\\lambda_{1} = \\lambda$, $\\lambda_{2} = \\lambda_{3} = \\lambda^{-1/2}$；(ii) 等双轴拉伸，主拉伸为$\\lambda_{1} = \\lambda_{2} = \\lambda$, $\\lambda_{3} = \\lambda^{-2}$；以及 (iii) 简单剪切，变形梯度为$F = \\begin{bmatrix} 1  \\gamma  0 \\\\ 0  1  0 \\\\ 0  0  1 \\end{bmatrix}$。测量的Cauchy应力分量（单轴拉伸的轴向应力，等双轴拉伸的面内应力，以及剪切试验的剪切分量$\\sigma_{12}$）可以表示为$(C_{10}, C_{01})$和所施加的应变度量$\\lambda$或$\\gamma$的确定性函数，这些函数由本构律、不可压缩性约束和侧向无牵引力边界条件导出。假设在每个测量的应力分量上存在附加的、独立的、同分布的、均值为零且已知标准差为$\\sigma_{\\text{noise}}$（单位为兆帕斯卡，MPa）的高斯测量噪声。假设参数向量$\\theta = [C_{10}, C_{01}]^{\\mathsf{T}}$服从均值为零、先验协方差为$\\Sigma_{0} = \\operatorname{diag}(0.25, 0.25)$（单位为$(\\text{MPa})^{2}$）的高斯先验分布。\n\n使用关于设计的局部贝叶斯线性模型（对于这些试验是精确的，因为测量的应力是$C_{10}$和$C_{01}$的仿射函数），在雅可比矩阵为$J$（行是在每次测量时测量的应力相对于参数的灵敏度）和噪声方差为$\\sigma_{\\text{noise}}^{2}$的设计下，Fisher信息矩阵为$J^{\\mathsf{T}} J / \\sigma_{\\text{noise}}^{2}$，近似后验协方差为$\\Sigma_{\\text{post}} = \\big(\\Sigma_{0}^{-1} + J^{\\mathsf{T}} J / \\sigma_{\\text{noise}}^{2}\\big)^{-1}$。将设计的期望后验方差定义为$\\operatorname{tr}(\\Sigma_{\\text{post}})$，单位为$(\\text{MPa})^{2}$。\n\n您的任务是实现一个程序，对于下面测试套件中的每个实验设计，使用Mooney–Rivlin模型在指定测试运动学下的相应应力-应变关系来构造雅可比矩阵$J$，计算$\\Sigma_{\\text{post}}$，并返回$\\operatorname{tr}(\\Sigma_{\\text{post}})$。\n\n用作推导基础的基本定律和核心定义：\n- Mooney–Rivlin存储能量的定义$W = C_{10} (I_{1} - 3) + C_{01} (I_{2} - 3)$。\n- 不可压缩超弹性材料的Cauchy应力$\\sigma = -p \\, I + 2 \\, \\partial W / \\partial I_{1} \\, B - 2 \\, \\partial W / \\partial I_{2} \\, B^{-1}$，其中$B = F F^{\\mathsf{T}}$。\n- 对于单轴和等双轴拉伸，无牵引力的横向应力决定了压力$p$。\n- 对于简单剪切，剪切应力分量$\\sigma_{12}$与$p$无关。\n\n精确定义每个测试要使用的应力分量：\n- 单轴：测量的轴向Cauchy应力$\\sigma_{\\text{uni}}(\\lambda; C_{10}, C_{01})$，作为拉伸$\\lambda$的函数。\n- 等双轴：测量的面内Cauchy应力$\\sigma_{\\text{biax}}(\\lambda; C_{10}, C_{01})$，作为拉伸$\\lambda$的函数。\n- 简单剪切：测量的剪切Cauchy应力$\\sigma_{12}(\\gamma; C_{10}, C_{01})$，作为剪切量$\\gamma$的函数。\n\n您必须推导出计算每次测量的雅可比矩阵行$\\partial \\sigma / \\partial C_{10}$和$\\partial \\sigma / \\partial C_{01}$所需的显式形式。\n\n测试套件：\n- 情况$1$（单轴，中等范围和噪声）：使用$n = 11$个均匀分布在$[1.0, 1.6]$区间的拉伸量$\\lambda$，噪声标准差$\\sigma_{\\text{noise}} = 0.1$ MPa。\n- 情况$2$（等双轴，中等范围和噪声）：使用$n = 11$个均匀分布在$[1.0, 1.3]$区间的拉伸量$\\lambda$，噪声标准差$\\sigma_{\\text{noise}} = 0.1$ MPa。\n- 情况$3$（简单剪切，中等范围和噪声）：使用$n = 11$个均匀分布在$[0.0, 0.8]$区间的剪切量$\\gamma$，噪声标准差$\\sigma_{\\text{noise}} = 0.1$ MPa。\n- 情况$4$（单轴，窄范围但低噪声）：使用$n = 5$个均匀分布在$[1.0, 1.2]$区间的拉伸量$\\lambda$，噪声标准差$\\sigma_{\\text{noise}} = 0.02$ MPa。\n- 情况$5$（混合设计）：结合$n_{\\text{uni}} = 6$个均匀分布在$[1.0, 1.6]$区间的单轴拉伸量$\\lambda$和$n_{\\text{biax}} = 6$个均匀分布在$[1.0, 1.3]$区间的等双轴拉伸量$\\lambda$，所有测量的噪声标准差均为$\\sigma_{\\text{noise}} = 0.1$ MPa。在计算$\\Sigma_{\\text{post}}$之前，将所有测量值堆叠成一个单一的雅可比矩阵。\n\n所有拉伸量$\\lambda$和剪切量$\\gamma$都是无量纲的，所有应力单位均为兆帕斯卡（MPa）。先验协方差$\\Sigma_{0}$的单位是$(\\text{MPa})^{2}$。对于每种情况，计算标量$\\operatorname{tr}(\\Sigma_{\\text{post}})$，单位为$(\\text{MPa})^{2}$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按情况1到5的顺序排列（例如，$[v_{1},v_{2},v_{3},v_{4},v_{5}]$），其中每个$v_{i}$是$\\operatorname{tr}(\\Sigma_{\\text{post}})$的值，单位为$(\\text{MPa})^{2}$，并四舍五入到六位小数。", "solution": "所述问题在科学上是合理的、适定的，并包含了获得唯一解所需的所有必要信息。它基于连续介质力学和贝叶斯推断的既定原理。因此，该问题是有效的，我们继续进行推导和求解。\n\n目标是计算Mooney-Rivlin超弹性固体材料参数$\\theta = [C_{10}, C_{01}]^{\\mathsf{T}}$在五种不同实验设计下的期望后验方差，定义为$\\operatorname{tr}(\\Sigma_{\\text{post}})$。后验协方差由贝叶斯线性模型的公式给出：\n$$\n\\Sigma_{\\text{post}} = \\left(\\Sigma_{0}^{-1} + \\frac{J^{\\mathsf{T}} J}{\\sigma_{\\text{noise}}^{2}}\\right)^{-1}\n$$\n在此，$\\Sigma_{0} = \\operatorname{diag}(0.25, 0.25) \\, (\\text{MPa})^2$是先验协方差，因此其逆矩阵为$\\Sigma_{0}^{-1} = \\operatorname{diag}(4, 4) \\, (\\text{MPa})^{-2}$。$\\sigma_{\\text{noise}}$项是测量噪声的标准差，$J$是雅可比矩阵，其行是测量的应力分量相对于参数$C_{10}$和$C_{01}$的灵敏度。\n\n中心任务是推导雅可比矩阵各行的解析表达式，这需要推导出三种测试配置中每一种的测量应力。Mooney-Rivlin存储能量函数为$W = C_{10}(I_1 - 3) + C_{01}(I_2 - 3)$。应力计算所需的偏导数为：\n$$\n\\frac{\\partial W}{\\partial I_1} = C_{10}, \\quad \\frac{\\partial W}{\\partial I_2} = C_{01}\n$$\n不可压缩材料的Cauchy应力张量为$\\sigma = -pI + 2 \\frac{\\partial W}{\\partial I_1} B - 2 \\frac{\\partial W}{\\partial I_2} B^{-1}$，其中$B = FF^{\\mathsf{T}}$是左Cauchy-Green变形张量，$p$是静水压力。对于指定的模型，这变为：\n$$\n\\sigma = -pI + 2C_{10}B - 2C_{01}B^{-1}\n$$\n该表达式对于参数$C_{10}$和$C_{01}$是线性的。因此，每次测试中测量的应力$\\sigma_{\\text{meas}}$将采用$\\sigma_{\\text{meas}} = f(\\text{strain})C_{10} + g(\\text{strain})C_{01}$的形式。构成雅可比矩阵$J$各行的灵敏度因此为$[\\frac{\\partial \\sigma_{\\text{meas}}}{\\partial C_{10}}, \\frac{\\partial \\sigma_{\\text{meas}}}{\\partial C_{01}}] = [f(\\text{strain}), g(\\text{strain})]$。\n\n**1. 单轴拉伸**\n主拉伸为$\\lambda_1 = \\lambda$和$\\lambda_2 = \\lambda_3 = \\lambda^{-1/2}$。左Cauchy-Green张量$B$及其逆矩阵是对角的：\n$$\nB = \\operatorname{diag}(\\lambda^2, \\lambda^{-1}, \\lambda^{-1}), \\quad B^{-1} = \\operatorname{diag}(\\lambda^{-2}, \\lambda, \\lambda)\n$$\n主应力为$\\sigma_{ii} = -p + 2C_{10}B_{ii} - 2C_{01}(B^{-1})_{ii}$。轴向应力是$\\sigma_{11}$，横向应力是$\\sigma_{22}$和$\\sigma_{33}$。根据无牵引力边界条件$\\sigma_{22} = \\sigma_{33} = 0$，我们从$\\sigma_{22} = 0$求解压力$p$：\n$$\n0 = -p + 2C_{10}\\lambda^{-1} - 2C_{01}\\lambda \\implies p = 2C_{10}\\lambda^{-1} - 2C_{01}\\lambda\n$$\n于是，测量的轴向应力$\\sigma_{\\text{uni}} = \\sigma_{11}$为：\n$$\n\\sigma_{\\text{uni}} = -(2C_{10}\\lambda^{-1} - 2C_{01}\\lambda) + 2C_{10}\\lambda^2 - 2C_{01}\\lambda^{-2}\n$$\n$$\n\\sigma_{\\text{uni}} = 2(\\lambda^2 - \\lambda^{-1})C_{10} + 2(\\lambda - \\lambda^{-2})C_{01}\n$$\n对于给定的拉伸$\\lambda$，雅可比矩阵的相应行为$[2(\\lambda^2 - \\lambda^{-1}), 2(\\lambda - \\lambda^{-2})]$。\n\n**2. 等双轴拉伸**\n主拉伸为$\\lambda_1 = \\lambda_2 = \\lambda$和$\\lambda_3 = \\lambda^{-2}$。张量$B$和$B^{-1}$为：\n$$\nB = \\operatorname{diag}(\\lambda^2, \\lambda^2, \\lambda^{-4}), \\quad B^{-1} = \\operatorname{diag}(\\lambda^{-2}, \\lambda^{-2}, \\lambda^4)\n$$\n测量的面内应力为$\\sigma_{\\text{biax}} = \\sigma_{11} = \\sigma_{22}$。横向应力为$\\sigma_{33}$，在无牵引力条件下为零。我们从$\\sigma_{33} = 0$求解$p$：\n$$\n0 = -p + 2C_{10}\\lambda^{-4} - 2C_{01}\\lambda^4 \\implies p = 2C_{10}\\lambda^{-4} - 2C_{01}\\lambda^4\n$$\n将$p$代入$\\sigma_{11}$的表达式中：\n$$\n\\sigma_{\\text{biax}} = -(2C_{10}\\lambda^{-4} - 2C_{01}\\lambda^4) + 2C_{10}\\lambda^2 - 2C_{01}\\lambda^{-2}\n$$\n$$\n\\sigma_{\\text{biax}} = 2(\\lambda^2 - \\lambda^{-4})C_{10} + 2(\\lambda^4 - \\lambda^{-2})C_{01}\n$$\n对于给定的拉伸$\\lambda$，雅可比矩阵的行为$[2(\\lambda^2 - \\lambda^{-4}), 2(\\lambda^4 - \\lambda^{-2})]$。\n\n**3. 简单剪切**\n变形梯度为$F = \\begin{bmatrix} 1  \\gamma  0 \\\\ 0  1  0 \\\\ 0  0  1 \\end{bmatrix}$。张量$B$和$B^{-1}$为：\n$$\nB = \\begin{bmatrix} 1+\\gamma^2  \\gamma  0 \\\\ \\gamma  1  0 \\\\ 0  0  1 \\end{bmatrix}, \\quad B^{-1} = \\begin{bmatrix} 1  -\\gamma  0 \\\\ -\\gamma  1+\\gamma^2  0 \\\\ 0  0  1 \\end{bmatrix}\n$$\n测量的剪切应力分量$\\sigma_{12}$与压力$p$无关：\n$$\n\\sigma_{12} = 2C_{10}B_{12} - 2C_{01}(B^{-1})_{12} = 2C_{10}(\\gamma) - 2C_{01}(-\\gamma)\n$$\n$$\n\\sigma_{12} = (2\\gamma)C_{10} + (2\\gamma)C_{01}\n$$\n对于给定的剪切量$\\gamma$，雅可比矩阵行为$[2\\gamma, 2\\gamma]$。两列完全相同，这表明仅凭简单剪切数据无法唯一地区分$C_{10}$和$C_{01}$，只能区分它们的和。贝叶斯先验对这种不适定性进行了正则化。\n\n**计算步骤**\n对于五种情况中的每一种，执行以下算法：\n1.  为指定的范围和数据点数量生成应变度量（$\\lambda$或$\\gamma$）数组。\n2.  通过遍历应变度量并使用上述推导的表达式计算相应的行来构造雅可比矩阵$J$。对于混合模式情况，计算单轴和等双轴子设计的雅可比矩阵，并将它们垂直堆叠。\n3.  根据数据计算Fisher信息矩阵，$H = J^{\\mathsf{T}} J / \\sigma_{\\text{noise}}^2$。\n4.  计算后验协方差矩阵$\\Sigma_{\\text{post}} = (\\Sigma_{0}^{-1} + H)^{-1}$。\n5.  计算其迹$\\operatorname{tr}(\\Sigma_{\\text{post}})$，该值代表参数的总期望后验方差。\n\n此过程在随附的程序中实现。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements the derivation and calculation for identifying Mooney-Rivlin parameters.\n    For each of the five experimental designs, it constructs the Jacobian,\n    computes the posterior covariance matrix using a Bayesian linear model,\n    and calculates its trace. The results are printed in the specified format.\n    \"\"\"\n\n    # Prior inverse covariance matrix, units of (MPa)^-2, derived from\n    # Sigma_0 = diag(0.25, 0.25).\n    SIGMA0_INV = np.array([[4.0, 0.0], [0.0, 4.0]])\n\n    def get_uniaxial_jacobian(lambdas: np.ndarray) - np.ndarray:\n        \"\"\"Constructs the Jacobian for uniaxial tension tests.\"\"\"\n        num_points = len(lambdas)\n        J = np.zeros((num_points, 2))\n        for i, lam in enumerate(lambdas):\n            # Sensitivity of axial stress w.r.t. C10\n            J[i, 0] = 2 * (lam**2 - 1 / lam)\n            # Sensitivity of axial stress w.r.t. C01\n            J[i, 1] = 2 * (lam - 1 / lam**2)\n        return J\n\n    def get_equibiaxial_jacobian(lambdas: np.ndarray) - np.ndarray:\n        \"\"\"Constructs the Jacobian for equibiaxial tension tests.\"\"\"\n        num_points = len(lambdas)\n        J = np.zeros((num_points, 2))\n        for i, lam in enumerate(lambdas):\n            # Sensitivity of in-plane stress w.r.t. C10\n            J[i, 0] = 2 * (lam**2 - 1 / lam**4)\n            # Sensitivity of in-plane stress w.r.t. C01\n            J[i, 1] = 2 * (lam**4 - 1 / lam**2)\n        return J\n\n    def get_shear_jacobian(gammas: np.ndarray) - np.ndarray:\n        \"\"\"Constructs the Jacobian for simple shear tests.\"\"\"\n        num_points = len(gammas)\n        J = np.zeros((num_points, 2))\n        for i, gam in enumerate(gammas):\n            # Sensitivity of shear stress w.r.t. C10\n            J[i, 0] = 2 * gam\n            # Sensitivity of shear stress w.r.t. C01\n            J[i, 1] = 2 * gam\n        return J\n\n    def compute_trace_post_cov(J: np.ndarray, sigma_noise: float) - float:\n        \"\"\"Computes the trace of the posterior covariance matrix.\"\"\"\n        # Fisher information from the likelihood, units of (MPa)^-2.\n        H = J.T @ J / (sigma_noise**2)\n        # Posterior inverse covariance (prior + likelihood), units of (MPa)^-2.\n        Sigma_post_inv = SIGMA0_INV + H\n        # Posterior covariance, units of (MPa)^2.\n        Sigma_post = np.linalg.inv(Sigma_post_inv)\n        # Expected posterior variance, defined as tr(Sigma_post).\n        return np.trace(Sigma_post)\n\n    test_cases = [\n        {'type': 'uniaxial', 'n': 11, 'range': [1.0, 1.6], 'sigma_noise': 0.1},\n        {'type': 'equibiaxial', 'n': 11, 'range': [1.0, 1.3], 'sigma_noise': 0.1},\n        {'type': 'shear', 'n': 11, 'range': [0.0, 0.8], 'sigma_noise': 0.1},\n        {'type': 'uniaxial', 'n': 5, 'range': [1.0, 1.2], 'sigma_noise': 0.02},\n        {'type': 'mixed', 'n_uni': 6, 'range_uni': [1.0, 1.6],\n                           'n_biax': 6, 'range_biax': [1.0, 1.3], 'sigma_noise': 0.1}\n    ]\n\n    results = []\n    for case in test_cases:\n        if case['type'] == 'uniaxial':\n            strains = np.linspace(case['range'][0], case['range'][1], case['n'])\n            J = get_uniaxial_jacobian(strains)\n            trace = compute_trace_post_cov(J, case['sigma_noise'])\n        elif case['type'] == 'equibiaxial':\n            strains = np.linspace(case['range'][0], case['range'][1], case['n'])\n            J = get_equibiaxial_jacobian(strains)\n            trace = compute_trace_post_cov(J, case['sigma_noise'])\n        elif case['type'] == 'shear':\n            strains = np.linspace(case['range'][0], case['range'][1], case['n'])\n            J = get_shear_jacobian(strains)\n            trace = compute_trace_post_cov(J, case['sigma_noise'])\n        elif case['type'] == 'mixed':\n            strains_uni = np.linspace(case['range_uni'][0], case['range_uni'][1], case['n_uni'])\n            J_uni = get_uniaxial_jacobian(strains_uni)\n            strains_biax = np.linspace(case['range_biax'][0], case['range_biax'][1], case['n_biax'])\n            J_biax = get_equibiaxial_jacobian(strains_biax)\n            J = np.vstack([J_uni, J_biax])\n            trace = compute_trace_post_cov(J, case['sigma_noise'])\n        results.append(trace)\n\n    # Final print statement in the exact required format.\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2650344"}]}