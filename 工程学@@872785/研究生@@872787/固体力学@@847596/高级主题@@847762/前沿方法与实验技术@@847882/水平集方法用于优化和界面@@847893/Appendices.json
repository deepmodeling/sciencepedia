{"hands_on_practices": [{"introduction": "水平集方法的核心在于其能够优雅地描述运动界面的动力学。本练习将理论付诸实践，通过一个经典场景——在毛细作用力下由曲率驱动的晶粒收缩——来探索界面的演化。通过从基本原理出发，您将推导出描述圆形界面半径随时间变化的控制方程，从而加深对法向速度 $V_n$、曲率 $\\kappa$ 以及水平集函数 $\\phi$ 之间内在联系的理解 [@problem_id:2654310]。", "problem": "考虑一个多晶薄膜中的圆形晶粒，其边界被建模为平面内的一条光滑闭合曲线 $\\Gamma(t)$。设界面由一个符号距离函数 $\\phi(x,y,t)$ 的零水平集表示，该函数选为 $\\phi(x,y,t) = \\sqrt{x^{2}+y^{2}} - R(t)$，使得在晶粒外部 $\\phi > 0$，在内部 $\\phi  0$，且 $\\Gamma(t) = \\{(x,y): \\phi(x,y,t) = 0\\}$。在固体力学中，该界面在毛细作用下通过曲率驱动运动进行演化，其法向速度为\n$$\nV_{n} = - M \\, \\gamma \\, \\kappa,\n$$\n其中 $M$ 是迁移率（单位为 $\\mathrm{m^{2}/(N \\cdot s)}$），$\\gamma$ 是单位长度的边界能（线张力，单位为 $\\mathrm{N}$），$\\kappa$ 是曲线的标量曲率，计算公式为 $\\kappa = \\nabla \\cdot \\left( \\frac{\\nabla \\phi}{|\\nabla \\phi|} \\right)$，并在 $\\Gamma(t)$ 上求值。水平集方法通过以下偏微分方程（PDE）将法向速度与水平集函数关联起来\n$$\n\\phi_{t} + V_{n} \\, |\\nabla \\phi| = 0.\n$$\n仅从这些定义和基本关系出发，推导半径 $R(t)$ 的演化规律，并在初始半径 $R(0) = R_{0}$ 的条件下求解。使用您推导出的解，计算晶粒坍缩成一个点（即 $R(t^{\\ast}) = 0$）时的消失时间 $t^{\\ast}$，参数如下：\n- $R_{0} = 50 \\,\\mu\\mathrm{m}$，\n- $M = 1.0 \\times 10^{-9}\\,\\mathrm{m^{2}/(N \\cdot s)}$，\n- $\\gamma = 1.0\\,\\mathrm{N}$。\n以 $\\mathrm{s}$ 为单位表示最终时间，并将您的答案四舍五入到三位有效数字。", "solution": "问题陈述已经过验证，是有效的。它在科学上基于连续介质力学和水平集方法的原理，在数学上是适定的，并且所有提供的数据都是自洽的，足以得到唯一解。因此，我们可以进行推导。\n\n该问题要求推导圆形晶粒半径 $R(t)$ 的演化规律，其边界由函数 $\\phi(x,y,t) = \\sqrt{x^{2}+y^{2}} - R(t)$ 的零水平集描述。该演化由水平集方程和法向速度的物理定律决定。\n\n首先，我们从水平集函数 $\\phi$ 计算必要的几何量。为方便起见，使用径向坐标 $r = \\sqrt{x^{2}+y^{2}}$ 来表示 $\\phi$，即 $\\phi(r,t) = r - R(t)$。\n\n$\\phi$ 的梯度计算如下：\n$$\n\\nabla \\phi = \\left( \\frac{\\partial \\phi}{\\partial x}, \\frac{\\partial \\phi}{\\partial y} \\right) = \\left( \\frac{x}{\\sqrt{x^{2}+y^{2}}}, \\frac{y}{\\sqrt{x^{2}+y^{2}}} \\right) = \\left( \\frac{x}{r}, \\frac{y}{r} \\right)\n$$\n该矢量是指向外部的单位径向矢量 $\\hat{\\mathbf{r}}$。\n\n梯度的模为：\n$$\n|\\nabla \\phi| = \\sqrt{\\left(\\frac{x}{r}\\right)^{2} + \\left(\\frac{y}{r}\\right)^{2}} = \\sqrt{\\frac{x^{2}+y^{2}}{r^{2}}} = 1\n$$\n对于除原点外的所有点，此式均成立，这与符号距离函数的性质相符。\n\n水平集的单位法向量 $\\mathbf{n}$ 由下式给出：\n$$\n\\mathbf{n} = \\frac{\\nabla \\phi}{|\\nabla \\phi|} = \\nabla \\phi = \\hat{\\mathbf{r}}\n$$\n\n曲率 $\\kappa$ 定义为单位法向量的散度：\n$$\n\\kappa = \\nabla \\cdot \\mathbf{n} = \\frac{\\partial}{\\partial x}\\left(\\frac{x}{r}\\right) + \\frac{\\partial}{\\partial y}\\left(\\frac{y}{r}\\right)\n$$\n$$\n\\kappa = \\left( \\frac{1}{r} - \\frac{x^{2}}{r^{3}} \\right) + \\left( \\frac{1}{r} - \\frac{y^{2}}{r^{3}} \\right) = \\frac{2}{r} - \\frac{x^{2}+y^{2}}{r^{3}} = \\frac{2}{r} - \\frac{r^{2}}{r^{3}} = \\frac{1}{r}\n$$\n问题要求在界面 $\\Gamma(t)$ 上计算 $\\kappa$，其中 $r = R(t)$。因此，在晶界上：\n$$\n\\kappa = \\frac{1}{R(t)}\n$$\n\n接下来，我们计算水平集演化方程 $\\phi_{t} + V_{n} \\, |\\nabla \\phi| = 0$ 中的各项。$\\phi$ 对时间 $t$ 的偏导数为：\n$$\n\\phi_{t} = \\frac{\\partial}{\\partial t} \\left( \\sqrt{x^{2}+y^{2}} - R(t) \\right) = -\\frac{dR}{dt}\n$$\n\n将 $\\phi_{t}$ 和 $|\\nabla \\phi|$ 代入水平集方程可得：\n$$\n-\\frac{dR}{dt} + V_{n} (1) = 0 \\implies V_{n} = \\frac{dR}{dt}\n$$\n此结果证实，界面沿外法线 $\\mathbf{n}$ 方向的法向速度 $V_{n}$ 正是半径 $R(t)$ 的变化率。\n\n问题给出了由毛细作用引起的法向速度的物理定律：\n$$\nV_{n} = - M \\, \\gamma \\, \\kappa\n$$\n代入界面上的曲率表达式 $\\kappa = 1/R(t)$：\n$$\nV_{n} = - \\frac{M\\gamma}{R(t)}\n$$\n\n通过令 $V_{n}$ 的两个表达式相等，我们得到控制半径 $R(t)$ 演化的常微分方程（ODE）：\n$$\n\\frac{dR}{dt} = - \\frac{M\\gamma}{R(t)}\n$$\n\n这是一个可分离变量的常微分方程。我们在初始条件 $R(0) = R_{0}$ 下求解它。\n$$\nR \\, dR = -M\\gamma \\, dt\n$$\n对两边从初始状态 $(t=0, R=R_{0})$ 积分到一般状态 $(t, R(t))$：\n$$\n\\int_{R_{0}}^{R(t)} R' \\, dR' = \\int_{0}^{t} -M\\gamma \\, dt'\n$$\n$$\n\\left[ \\frac{1}{2}(R')^{2} \\right]_{R_{0}}^{R(t)} = -M\\gamma [t']_{0}^{t}\n$$\n$$\n\\frac{1}{2}R(t)^{2} - \\frac{1}{2}R_{0}^{2} = -M\\gamma t\n$$\n求解 $R(t)$，我们得到半径的演化规律：\n$$\nR(t)^{2} = R_{0}^{2} - 2M\\gamma t\n$$\n$$\nR(t) = \\sqrt{R_{0}^{2} - 2M\\gamma t}\n$$\n\n消失时间 $t^{\\ast}$ 是晶粒消失的时刻，即 $R(t^{\\ast})=0$。在我们的解中令 $R(t^{\\ast})=0$：\n$$\n0 = R_{0}^{2} - 2M\\gamma t^{\\ast}\n$$\n$$\nt^{\\ast} = \\frac{R_{0}^{2}}{2M\\gamma}\n$$\n\n最后，我们代入给定的数值参数来计算 $t^{\\ast}$。这些参数必须使用一致的国际单位制（SI）单位。\n$R_{0} = 50 \\,\\mu\\mathrm{m} = 5.0 \\times 10^{-5}\\,\\mathrm{m}$\n$M = 1.0 \\times 10^{-9}\\,\\mathrm{m^{2}/(N \\cdot s)}$\n$\\gamma = 1.0\\,\\mathrm{N}$\n\n$$\nt^{\\ast} = \\frac{(5.0 \\times 10^{-5})^{2}}{2 \\cdot (1.0 \\times 10^{-9}) \\cdot (1.0)} = \\frac{25 \\times 10^{-10}}{2.0 \\times 10^{-9}} = \\frac{2.5 \\times 10^{-9}}{2.0 \\times 10^{-9}}\\,\\mathrm{s}\n$$\n$$\nt^{\\ast} = 1.25\\,\\mathrm{s}\n$$\n该值已按要求表示为三位有效数字。", "answer": "$$\\boxed{1.25}$$", "id": "2654310"}, {"introduction": "从连续的解析世界过渡到离散的计算世界时，数值精度成为一个核心挑战。本练习聚焦于在笛卡尔网格上准确计算几何量（如曲率）时所产生的离散误差问题。您将通过一个编程实践，实现并评估一种关键的校正技术——符号距离函数重初始化（signed-distance reinitialization），它通过求解一个特定的哈密顿-雅可比方程来强制执行 Eikonal 方程 $|\\nabla \\phi|=1$。完成此练习将使您掌握提高水平集模拟几何保真度的基本数值方法 [@problem_id:2654323]。", "problem": "考虑一个二维无量纲方形域 $\\Omega=[0,1]\\times[0,1]$，该域由一个包含 $N\\times N$ 个节点的均匀笛卡尔网格离散化，网格间距为 $h=\\frac{1}{N-1}$。一个界面 $\\Gamma$ 由标量场 $\\phi(x,y)$ 的零水平集隐式表示，其中 $\\phi$ 是一个有向距离函数，在界面内部为负，外部为正。在用于固体力学中优化和界面的水平集方法中，曲率等几何量出现在灵敏度分析和界面正则化中，而这些量的离散近似会引入依赖于 $h$ 和离散格式的几何误差。本练习研究基准离散曲率误差以及一种基于有向距离重初始化的修正方法，并要求您计算该修正方法带来的误差减小量。\n\n您必须实现一个完整的程序，该程序针对一系列圆形界面，计算基准离散平均曲率及其误差，应用重初始化偏微分方程 (PDE) 来修正离散几何误差，重新计算曲率，并报告每个测试案例中修正后误差与基准误差的比率。\n\n物理和数值设置如下。\n\n- 界面 $\\Gamma$ 是一个半径为 $R$、圆心为 $(x_c,y_c)$ 的圆，其有向距离场为\n$$\n\\phi_0(x,y)=\\sqrt{(x-x_c)^2+(y-y_c)^2}-R.\n$$\n- 对于一个圆，其精确平均曲率（法线方向朝外）是一个常数，等于\n$$\n\\kappa_{\\text{exact}}=\\frac{1}{R}.\n$$\n- 网格节点上的离散曲率根据曲率的定义（单位法向量的散度）从基本原理出发进行计算。令 $\\nabla \\phi=(\\phi_x,\\phi_y)$ 表示梯度，单位法向量为 $n=\\frac{\\nabla \\phi}{\\|\\nabla \\phi\\|}$，其中 $\\|\\nabla \\phi\\|=\\sqrt{\\phi_x^2+\\phi_y^2}$。则\n$$\n\\kappa=\\nabla\\cdot n=\\frac{\\partial n_x}{\\partial x}+\\frac{\\partial n_y}{\\partial y}.\n$$\n在网格上，内部使用二阶中心差分，边界上使用一阶单边差分。为避免除以零，将范数正则化为 $\\|\\nabla \\phi\\|_\\varepsilon=\\sqrt{\\phi_x^2+\\phi_y^2+\\varepsilon^2}$，其中 $\\varepsilon=\\alpha h$，$\\alpha$ 是一个无量纲常数，并设置 $n=\\nabla \\phi/\\|\\nabla \\phi\\|_\\varepsilon$。\n\n- 基准离散曲率误差通过界面周围窄带内的均方根 (RMS) 误差来量化。窄带定义为\n$$\n\\mathcal{B}=\\{(i,j)\\ \\text{grid nodes}\\ :\\ |\\phi_0(x_i,y_j)|\\le 2h\\}.\n$$\n如果 $M$ 是 $\\mathcal{B}$ 中的节点数，定义\n$$\nE_{\\text{base}}=\\left(\\frac{1}{M}\\sum_{(i,j)\\in\\mathcal{B}}\\left(\\kappa_{ij}-\\kappa_{\\text{exact}}\\right)^2\\right)^{1/2}.\n$$\n\n- 修正是指有向距离重初始化，它在伪时间 $\\tau$ 内强制执行程函方程 $\\|\\nabla \\phi\\|=1$，同时保持 $\\phi=0$ 等值线不变。从 $\\phi(x,y,0)=\\phi_0(x,y)$ 开始，演化\n$$\n\\frac{\\partial \\phi}{\\partial \\tau} = s(\\phi_0)\\left(1-\\|\\nabla \\phi\\|\\right),\n$$\n其中 $s(\\phi_0)$ 是一个平滑符号函数。使用针对 $\\|\\nabla \\phi\\|$ 的一阶迎风 Godunov 通量和 $\\tau$ 方向的显式欧拉步来离散化这个哈密顿-雅可比 (HJ) 方程。令 $D^+_x\\phi$ 和 $D^-_x\\phi$ 分别表示 $x$ 方向的前向和后向单边有限差分，$y$ 方向类似，边界上采用齐次诺伊曼处理。对每个节点，定义\n$$\ns(\\phi_0)=\\frac{\\phi_0}{\\sqrt{\\phi_0^2+h^2}}.\n$$\n对于 Godunov 通量，对每个节点定义：\n- 如果 $s(\\phi_0)\\ge 0$，\n$$\nG=\\sqrt{\\max\\left(\\left(\\max(D^-_x\\phi,0)\\right)^2,\\left(\\min(D^+_x\\phi,0)\\right)^2\\right)+\\max\\left(\\left(\\max(D^-_y\\phi,0)\\right)^2,\\left(\\min(D^+_y\\phi,0)\\right)^2\\right)}.\n$$\n- 如果 $s(\\phi_0)  0$，\n$$\nG=\\sqrt{\\max\\left(\\left(\\min(D^-_x\\phi,0)\\right)^2,\\left(\\max(D^+_x\\phi,0)\\right)^2\\right)+\\max\\left(\\left(\\min(D^-_y\\phi,0)\\right)^2,\\left(\\max(D^+_y\\phi,0)\\right)^2\\right)}.\n$$\n那么一个显式步长为\n$$\n\\phi^{n+1}=\\phi^n-\\Delta \\tau\\, s(\\phi_0)\\,(G-1).\n$$\n使用伪时间步长 $\\Delta \\tau=\\beta h$，其中 $\\beta=\\beta_0\\in(0,1)$，并推进固定的步数 $N_\\tau$。\n\n- 重初始化后，在同一窄带 $\\mathcal{B}$ 内计算修正后的曲率及相关的 RMS 误差：\n$$\nE_{\\text{corr}}=\\left(\\frac{1}{M}\\sum_{(i,j)\\in\\mathcal{B}}\\left(\\kappa^{\\text{corr}}_{ij}-\\kappa_{\\text{exact}}\\right)^2\\right)^{1/2}.\n$$\n\n- 每个测试案例关注的量是比率\n$$\n\\rho=\\frac{E_{\\text{corr}}}{E_{\\text{base}}}.\n$$\n如果 $E_{\\text{base}}$ 在数值上与零无法区分，则按惯例定义 $\\rho=1$。\n\n实现所需的数值细节：\n- 使用 $\\varepsilon=\\alpha h$，其中 $\\alpha=0.5$。\n- 使用 $\\beta_0=0.3$ 和 $N_\\tau=120$。\n- 对 $\\partial\\Omega$ 处的所有有限差分使用齐次诺伊曼边界条件，通过一阶单边差分实现。\n\n测试套件：\n对以下每个参数元组 $(N,R,x_c,y_c)$，按上述方法计算 $\\rho$。所有量均为无量纲。\n\n- 情况1：$(N,R,x_c,y_c)=(129,0.3,0.37,0.41)$，一个中等分辨率、圆心偏离网格中心的圆。\n- 情况2：$(N,R,x_c,y_c)=(33,0.3,0.37,0.41)$，一个粗网格。\n- 情况3：$(N,R,x_c,y_c)=(129,0.08,0.5,0.5)$，一个半径接近网格尺度的小圆。\n- 情况4：$(N,R,x_c,y_c)=(129,0.3,0.15,0.5)$，一个界面与边界相交的圆。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个逗号分隔的列表，用方括号括起来，按上述情况的顺序排列，即\n$$\n[\\rho_1,\\rho_2,\\rho_3,\\rho_4].\n$$\n每个 $\\rho_k$ 必须作为浮点数输出。没有物理单位；所有值都是无量纲的。不出现角度。任何地方都不得出现百分比；每个比率 $\\rho_k$ 都是一个纯数。", "solution": "所述问题是一项适定且科学合理的数值方法练习，适用于水平集应用。它是自洽的，所有必要的参数、方程和算法都已指定。任务是实现一个指定的数值方案，以量化有向距离重初始化过程后界面曲率近似的改善程度。该问题是有效的，将遵循指定的方法构建解决方案。\n\n问题的核心在于笛卡尔网格上几何量和微分算子的离散化。我们将详细介绍从初始设置到最终误差分析的每个计算步骤。\n\n**1. 离散化和初始状态**\n\n域 $\\Omega = [0,1] \\times [0,1]$ 被离散化为 $N \\times N$ 的节点网格。网格间距在两个方向上是均匀的，由 $h = 1 / (N-1)$ 给出。网格节点 $(x_i, y_j)$ 的坐标为 $x_i = i h$ 和 $y_j = j h$，其中 $i,j \\in \\{0, 1, \\dots, N-1\\}$。\n\n初始界面是一个半径为 $R$、圆心为 $(x_c, y_c)$ 的圆。该界面被隐式表示为初始有向距离函数 (SDF) $\\phi_0$ 的零等值线：\n$$\n\\phi_0(x,y) = \\sqrt{(x-x_c)^2 + (y-y_c)^2} - R\n$$\n在每个网格节点 $(x_i, y_j)$ 上评估此解析函数，以产生离散场 $\\phi_{0,ij}$。\n\n**2. 基准曲率和误差计算**\n\n平均曲率 $\\kappa$ 定义为单位法向量场的散度，即 $\\kappa = \\nabla \\cdot n$。单位法向量 $n$ 由水平集函数的梯度计算得出，$n = \\nabla\\phi / \\|\\nabla\\phi\\|$。当 $\\|\\nabla\\phi\\|$ 接近于零时必须避免除以零，这种情况可能发生在远离界面处或由于数值伪影。因此，使用正则化范数：\n$$\nn = \\frac{\\nabla\\phi}{\\|\\nabla\\phi\\|_\\varepsilon} \\quad \\text{其中} \\quad \\|\\nabla\\phi\\|_\\varepsilon = \\sqrt{(\\phi_x)^2 + (\\phi_y)^2 + \\varepsilon^2}\n$$\n正则化参数为 $\\varepsilon = \\alpha h$，其中指定的常数 $\\alpha=0.5$。\n\n计算 $\\nabla\\phi = (\\phi_x, \\phi_y)$ 和散度 $\\nabla \\cdot n$ 所需的导数使用有限差分进行近似。问题指定内部节点使用二阶中心差分，边界使用一阶单边差分。\n对于网格上的一个通用场 $f(x,y)$，在节点 $(i,j)$ 处的偏导数 $\\partial f / \\partial x$ 计算如下：\n- $ \\frac{f_{i+1,j} - f_{i-1,j}}{2h} $，对于 $i \\in \\{1, \\dots, N-2\\}$ (内部)。\n- $ \\frac{f_{1,j} - f_{0,j}}{h} $，对于 $i=0$ (边界)。\n- $ \\frac{f_{N-1,j} - f_{N-2,j}}{h} $，对于 $i=N-1$ (边界)。\n同样的模板沿 $j$ 索引应用于 $y$ 方向的导数。该格式首先应用于从 $\\phi_0$ 计算 $\\nabla\\phi_0$，然后再应用于从法向量场 $n$ 的分量计算 $\\nabla \\cdot n$。\n\n基准曲率场 $\\kappa_{ij}$ 是从初始 SDF $\\phi_0$ 计算得出的。通过与圆的精确解析曲率 $\\kappa_{\\text{exact}} = 1/R$ 进行比较来评估此数值曲率的准确性。误差通过靠近界面的节点窄带 $\\mathcal{B}$ 上的均方根 (RMS) 误差来量化：\n$$\n\\mathcal{B} = \\{ (i,j) \\text{ 节点} \\mid |\\phi_0(x_i, y_j)| \\le 2h \\}\n$$\n基准 RMS 误差 $E_{\\text{base}}$ 为：\n$$\nE_{\\text{base}} = \\sqrt{\\frac{1}{M} \\sum_{(i,j) \\in \\mathcal{B}} (\\kappa_{ij} - \\kappa_{\\text{exact}})^2}\n$$\n其中 $M$ 是窄带 $\\mathcal{B}$ 中节点的总数。\n\n**3. 有向距离重初始化**\n\n离散 SDF $\\phi_0$ 仅在连续意义上是真正的距离函数。在网格上，其离散梯度大小 $\\|\\nabla \\phi_0\\|$ 可能会偏离 1。这种偏差会在曲率计算中引入误差。重初始化过程演化场 $\\phi$，以更好地在网格上满足程函方程 $\\|\\nabla\\phi\\| = 1$，同时保持零水平集静止。这是通过求解哈密顿-雅可比 PDE 实现的：\n$$\n\\frac{\\partial \\phi}{\\partial \\tau} + s(\\phi_0)( \\|\\nabla \\phi\\| - 1 ) = 0\n$$\n伪时间为 $\\tau$。项 $s(\\phi_0)$ 是一个平滑符号函数，它决定了信息流动的方向（从界面向内或向外）：\n$$\ns(\\phi_0) = \\frac{\\phi_0}{\\sqrt{\\phi_0^2 + h^2}}\n$$\n该 PDE 被数值求解。伪时间演化使用显式欧拉方法：\n$$\n\\phi^{k+1} = \\phi^k - \\Delta\\tau \\cdot s(\\phi_0) (G - 1)\n$$\n其中 $G$ 是 $\\|\\nabla\\phi\\|$ 的数值近似，时间步长为 $\\Delta\\tau = \\beta h$ 且 $\\beta=0.3$。演化进行 $N_\\tau = 120$ 步。\n\n空间项 $\\|\\nabla\\phi\\|$ 使用一阶 Godunov 通量进行离散化，这是一种适用于哈密顿-雅可比方程的迎风格式。该格式根据 $s(\\phi_0)$ 的符号选择适当的单边差分，该符号决定了特征线的方向。令 $D^\\pm_x \\phi$ 和 $D^\\pm_y \\phi$ 为前向/后向有限差分。Godunov 通量 $G$ 定义为：\n- 对于 $s(\\phi_0) \\ge 0$ (向外传播)：\n$$ G = \\sqrt{\\max\\left((\\max(D^-_x\\phi,0))^2,(\\min(D^+_x\\phi,0))^2\\right)+\\max\\left((\\max(D^-_y\\phi,0))^2,(\\min(D^+_y\\phi,0))^2\\right)} $$\n- 对于 $s(\\phi_0)  0$ (向内传播)：\n$$ G = \\sqrt{\\max\\left((\\min(D^-_x\\phi,0))^2,(\\max(D^+_x\\phi,0))^2\\right)+\\max\\left((\\min(D^-_y\\phi,0))^2,(\\max(D^+_y\\phi,0))^2\\right)} $$\n单边差分 $D^\\pm_x \\phi$, $D^\\pm_y \\phi$ 使用齐次诺伊曼边界条件。这是通过在模板需要域外点时将导数设置为零来实现的。例如，在左边界 $i=0$ 处，$D^-_x\\phi$ 设置为 $0$。在右边界 $i=N-1$ 处，$D^+_x\\phi$ 设置为 $0$。\n\n**4. 修正误差和最终比率**\n\n$N_\\tau$ 步之后，重初始化产生一个修正后的场 $\\phi_{\\text{corr}}$。使用这个新场，采用与计算基准曲率完全相同的过程来计算修正后的曲率场 $\\kappa^{\\text{corr}}$。然后，在由初始场 $\\phi_0$ 定义的同一窄带 $\\mathcal{B}$ 上计算修正后的 RMS 误差 $E_{\\text{corr}}$：\n$$\nE_{\\text{corr}} = \\sqrt{\\frac{1}{M} \\sum_{(i,j) \\in \\mathcal{B}} (\\kappa^{\\text{corr}}_{ij} - \\kappa_{\\text{exact}})^2}\n$$\n每个测试案例的最终结果是修正后误差与基准误差的比率：\n$$\n\\rho = \\frac{E_{\\text{corr}}}{E_{\\text{base}}}\n$$\n$\\rho  1$ 的值表示重初始化过程成功减少了离散曲率计算中的几何引入误差。如果 $E_{\\text{base}}$ 在数值上为零，我们取 $\\rho=1$。至此算法完成。", "answer": "```python\nimport numpy as np\n\ndef compute_gradient(phi, h):\n    \"\"\"\n    Computes the gradient of a 2D scalar field phi using second-order\n    central differences in the interior and first-order at boundaries.\n    \"\"\"\n    N = phi.shape[0]\n    grad_x = np.zeros_like(phi)\n    grad_y = np.zeros_like(phi)\n\n    # Gradient in x-direction\n    grad_x[:, 1:-1] = (phi[:, 2:] - phi[:, :-2]) / (2.0 * h)\n    grad_x[:, 0] = (phi[:, 1] - phi[:, 0]) / h\n    grad_x[:, -1] = (phi[:, -1] - phi[:, -2]) / h\n\n    # Gradient in y-direction\n    grad_y[1:-1, :] = (phi[2:, :] - phi[:-2, :]) / (2.0 * h)\n    grad_y[0, :] = (phi[1, :] - phi[0, :]) / h\n    grad_y[-1, :] = (phi[-1, :] - phi[-2, :]) / h\n\n    return grad_x, grad_y\n\ndef compute_divergence(vx, vy, h):\n    \"\"\"\n    Computes the divergence of a 2D vector field (vx, vy) using second-order\n    central differences in the interior and first-order at boundaries.\n    \"\"\"\n    dvx_dx = np.zeros_like(vx)\n    dvy_dy = np.zeros_like(vy)\n\n    # Partial derivative of vx w.r.t. x\n    dvx_dx[:, 1:-1] = (vx[:, 2:] - vx[:, :-2]) / (2.0 * h)\n    dvx_dx[:, 0] = (vx[:, 1] - vx[:, 0]) / h\n    dvx_dx[:, -1] = (vx[:, -1] - vx[:, -2]) / h\n\n    # Partial derivative of vy w.r.t. y\n    dvy_dy[1:-1, :] = (vy[2:, :] - vy[:-2, :]) / (2.0 * h)\n    dvy_dy[0, :] = (vy[1, :] - vy[0, :]) / h\n    dvy_dy[-1, :] = (vy[-1, :] - vy[-2, :]) / h\n\n    return dvx_dx + dvy_dy\n    \ndef get_one_sided_diffs(phi, h):\n    \"\"\"\n    Computes first-order one-sided differences with homogeneous Neumann BCs.\n    \"\"\"\n    # D_x^+ phi\n    dx_p = (np.roll(phi, -1, axis=1) - phi) / h\n    dx_p[:, -1] = 0.0\n\n    # D_x^- phi\n    dx_m = (phi - np.roll(phi, 1, axis=1)) / h\n    dx_m[:, 0] = 0.0\n\n    # D_y^+ phi\n    dy_p = (np.roll(phi, -1, axis=0) - phi) / h\n    dy_p[-1, :] = 0.0\n\n    # D_y^- phi\n    dy_m = (phi - np.roll(phi, 1, axis=0)) / h\n    dy_m[0, :] = 0.0\n    \n    return dx_p, dx_m, dy_p, dy_m\n\ndef compute_curvature(phi, h, alpha):\n    \"\"\"Computes the curvature from the level set field phi.\"\"\"\n    epsilon = alpha * h\n    grad_phi_x, grad_phi_y = compute_gradient(phi, h)\n    \n    norm_grad_phi_eps = np.sqrt(grad_phi_x**2 + grad_phi_y**2 + epsilon**2)\n    \n    # Avoid division by zero, although epsilon should prevent it.\n    # Set norm to 1.0 where it's zero to avoid NaN.\n    norm_grad_phi_eps[norm_grad_phi_eps  1e-15] = 1.0\n\n    nx = grad_phi_x / norm_grad_phi_eps\n    ny = grad_phi_y / norm_grad_phi_eps\n    \n    kappa = compute_divergence(nx, ny, h)\n    return kappa\n\ndef solve_case(params):\n    \"\"\"\n    Runs the full simulation for a single test case.\n    \"\"\"\n    N, R, xc, yc = params\n    alpha = 0.5\n    beta0 = 0.3\n    N_tau = 120\n\n    h = 1.0 / (N - 1)\n    x = np.linspace(0.0, 1.0, N)\n    y = np.linspace(0.0, 1.0, N)\n    X, Y = np.meshgrid(x, y, indexing='ij')\n\n    # 1. Initial State and Baseline Error\n    phi0 = np.sqrt((X - xc)**2 + (Y - yc)**2) - R\n    kappa_exact = 1.0 / R\n\n    kappa_base = compute_curvature(phi0, h, alpha)\n    \n    narrow_band_mask = np.abs(phi0) = 2.0 * h\n    M = np.sum(narrow_band_mask)\n\n    if M == 0:\n        # Handle cases where the band is empty, though unlikely.\n        return 1.0\n\n    error_sq_base = (kappa_base[narrow_band_mask] - kappa_exact)**2\n    E_base = np.sqrt(np.sum(error_sq_base) / M)\n    \n    if E_base  1e-15:\n        return 1.0\n\n    # 2. Reinitialization\n    phi = phi0.copy()\n    s_phi0 = phi0 / np.sqrt(phi0**2 + h**2)\n    dt = beta0 * h\n\n    for _ in range(N_tau):\n        dx_p, dx_m, dy_p, dy_m = get_one_sided_diffs(phi, h)\n        \n        # Godunov flux for s >= 0\n        term_x_pos = np.maximum(np.maximum(dx_m, 0.0)**2, np.minimum(dx_p, 0.0)**2)\n        term_y_pos = np.maximum(np.maximum(dy_m, 0.0)**2, np.minimum(dy_p, 0.0)**2)\n        G_pos = np.sqrt(term_x_pos + term_y_pos)\n        \n        # Godunov flux for s  0\n        term_x_neg = np.maximum(np.minimum(dx_m, 0.0)**2, np.maximum(dx_p, 0.0)**2)\n        term_y_neg = np.maximum(np.minimum(dy_m, 0.0)**2, np.maximum(dy_p, 0.0)**2)\n        G_neg = np.sqrt(term_x_neg + term_y_neg)\n        \n        G = np.where(s_phi0 >= 0, G_pos, G_neg)\n        \n        phi -= dt * s_phi0 * (G - 1.0)\n\n    # 3. Corrected Error\n    phi_corr = phi\n    kappa_corr = compute_curvature(phi_corr, h, alpha)\n    \n    error_sq_corr = (kappa_corr[narrow_band_mask] - kappa_exact)**2\n    E_corr = np.sqrt(np.sum(error_sq_corr) / M)\n    \n    rho = E_corr / E_base\n    return rho\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    # Test cases: (N, R, x_c, y_c)\n    test_cases = [\n        (129, 0.3, 0.37, 0.41),  # Case 1\n        (33, 0.3, 0.37, 0.41),   # Case 2\n        (129, 0.08, 0.5, 0.5),   # Case 3\n        (129, 0.3, 0.15, 0.5),   # Case 4\n    ]\n\n    results = []\n    for case in test_cases:\n        rho = solve_case(case)\n        results.append(rho)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2654323"}, {"introduction": "水平集方法在结构优化中的一个强大应用是寻找最优的材料布局。为了通过基于梯度的方法进行优化，我们必须高效地计算目标函数（如结构的柔度）相对于设计变量的灵敏度（即梯度）。本练习将指导您使用伴随法（adjoint method）这一强大的工具来推导并实现这种梯度计算。您还将通过与有限差分法的梯度进行对比来验证伴随法的正确性，这是开发可靠优化算法时一项至关重要的“梯度检验”步骤 [@problem_id:2654352]。", "problem": "您将使用一个标量椭圆模型，在固体力学中实现并评估一个基于水平集的材料优化代理模型的数值微分精度。物理背景是一个二维域，其中材料分布由一个水平集函数隐式定义，结构响应则由一个代替线性弹性的标量椭圆偏微分方程 (PDE) 建模。您的任务是使用伴随法推导类柔度目标函数关于水平集参数的梯度，对偏微分方程和梯度进行一致性离散化，并将伴随梯度与不同步长下的有限差分近似进行比较。在本问题中，所有量均视为无量纲，因此不需要进行物理单位转换。\n\n本问题的基本基础是以标量椭圆偏微分方程形式表示的平衡定律、柔度的变分定义以及链式法则/伴随法。请仅从以下基本原理和定义出发：\n- 具有空间变化电导率的标量椭圆偏微分方程为 $-\\nabla \\cdot (k(\\mathbf{x}) \\nabla u(\\mathbf{x})) = s(\\mathbf{x})$，在单位正方形域 $\\Omega = (0,1) \\times (0,1)$ 上，边界条件为 $\\partial \\Omega$ 上的狄利克雷边界条件 $u = 0$。\n- 类柔度泛函为 $J = \\int_{\\Omega} s(\\mathbf{x})\\, u(\\mathbf{x}) \\, d\\mathbf{x}$。\n- 设计由一个通过径向基函数构建的水平集函数 $\\phi(\\mathbf{x};\\boldsymbol{\\alpha})$ 编码，电导率通过 $\\phi$ 的光滑亥维赛德函数定义。\n- 链式法则和伴随法将 $J$ 关于 $\\boldsymbol{\\alpha}$ 的导数与状态解 $u$ 和伴随解 $p$ 联系起来。\n\n待实现的模型规格：\n- 电导率为 $k(\\mathbf{x}) = k_{\\text{void}} + \\left(k_{\\text{solid}} - k_{\\text{void}}\\right) \\rho(\\mathbf{x})$，其中 $\\rho(\\mathbf{x}) = H_{\\varepsilon}(\\phi(\\mathbf{x};\\boldsymbol{\\alpha}))$ 是水平集的光滑亥维赛德函数。\n- 水平集为 $\\phi(\\mathbf{x};\\boldsymbol{\\alpha}) = \\sum_{j=1}^{M} \\alpha_j R_j(\\mathbf{x})$，其中高斯径向基函数为 $R_j(\\mathbf{x}) = \\exp\\!\\left(-\\frac{\\|\\mathbf{x}-\\mathbf{c}_j\\|^2}{\\sigma^2}\\right)$，中心为 $\\mathbf{c}_j \\in \\Omega$，宽度为 $\\sigma$。\n- 光滑亥维赛德函数为：若 $\\phi \\le -\\varepsilon$，则 $H_{\\varepsilon}(\\phi) = 0$；若 $\\phi \\ge \\varepsilon$，则 $H_{\\varepsilon}(\\phi) = 1$；若 $|\\phi|  \\varepsilon$，则 $H_{\\varepsilon}(\\phi) = \\frac{1}{2}\\left(1 + \\frac{\\phi}{\\varepsilon} + \\frac{1}{\\pi}\\sin\\!\\left(\\pi \\frac{\\phi}{\\varepsilon}\\right)\\right)$。其导数（一个光滑狄拉克δ函数）为：若 $|\\phi| \\ge \\varepsilon$，则 $\\delta_{\\varepsilon}(\\phi) = 0$；若 $|\\phi|  \\varepsilon$，则 $\\delta_{\\varepsilon}(\\phi) = \\frac{1}{2\\varepsilon}\\left(1 + \\cos\\!\\left(\\pi \\frac{\\phi}{\\varepsilon}\\right)\\right)$。\n\n离散模型和数值要求：\n- 在一个包含 $N \\times N$ 个内部点的均匀网格上离散化PDE，网格间距为 $h = \\frac{1}{N+1}$，在边界点上使用齐次狄利克雷边界值 $u=0$。使用带有可变系数的五点模板和内部面上的算术平均来组装 $-\\nabla \\cdot (k \\nabla u)$ 的离散算子；在与边界相邻的面上，取面电导率等于内部单元的电导率。\n- 使用恒定源 $s(\\mathbf{x}) \\equiv 1$。\n- 通过黎曼和 $J \\approx \\sum_{i} s_i u_i h^2$ 计算离散柔度 $J$。\n- 从第一性原理（PDE、柔度定义和伴随法）出发，推导并实现伴随梯度 $\\frac{dJ}{d\\alpha_j}$。对包含 $|\\nabla u|^2$ 的积分使用一致的离散近似，内部使用中心差分，并通过狄利克雷值填充以在边界处实现单侧一致性。\n\n设计参数化：\n- 使用 $M = 3$ 个径向基函数，中心为 $\\mathbf{c}_1 = (0.3, 0.3)$、$\\mathbf{c}_2 = (0.7, 0.3)$、$\\mathbf{c}_3 = (0.5, 0.7)$。\n- 使用宽度 $\\sigma = 0.15$。\n- 使用基准设计向量 $\\boldsymbol{\\alpha}_0 = [0.2, -0.3, 0.1]$。\n- 使用电导率值 $k_{\\text{solid}} = 1.0$ 和 $k_{\\text{void}} = 10^{-3}$。\n\n亥维赛德平滑：\n- 使用 $\\varepsilon = 2 h$ 作为亥维赛德函数的平滑半宽。\n\n为比较而需实现的数值微分方案：\n- 分量 $j$ 的前向差分：$\\left(\\frac{\\partial J}{\\partial \\alpha_j}\\right)_{\\text{FD}} \\approx \\frac{J(\\boldsymbol{\\alpha}_0 + h_{\\text{fd}} \\mathbf{e}_j) - J(\\boldsymbol{\\alpha}_0)}{h_{\\text{fd}}}$。\n- 分量 $j$ 的中心差分：$\\left(\\frac{\\partial J}{\\partial \\alpha_j}\\right)_{\\text{CD}} \\approx \\frac{J(\\boldsymbol{\\alpha}_0 + h_{\\text{fd}} \\mathbf{e}_j) - J(\\boldsymbol{\\alpha}_0 - h_{\\text{fd}} \\mathbf{e}_j)}{2 h_{\\text{fd}}}$。\n\n误差度量：\n- 对于梯度向量 $\\mathbf{g}_{\\text{ref}}$ 和 $\\mathbf{g}_{\\text{num}}$，计算分量相对误差 $e_j = \\frac{|g_{\\text{num},j} - g_{\\text{ref},j}|}{\\max(|g_{\\text{ref},j}|, \\tau)}$，使用一个小的容差 $\\tau = 10^{-12}$ 以避免除以零，并报告各分量的最大值 $\\max_j e_j$。\n- 对于方向 $\\mathbf{v}$（其中 $\\|\\mathbf{v}\\|_2 = 1$）的方向导数检验，将中心差分方向导数 $\\frac{J(\\boldsymbol{\\alpha}_0 + h_{\\text{fd}} \\mathbf{v}) - J(\\boldsymbol{\\alpha}_0 - h_{\\text{fd}} \\mathbf{v})}{2 h_{\\text{fd}}}$ 与内积 $\\mathbf{g}_{\\text{ref}} \\cdot \\mathbf{v}$ 进行比较，并报告绝对误差。\n\n测试套件：\n- 使用以下四个测试用例，每个用例产生一个实值结果：\n    1. 网格尺寸 $N = 31$，中心差分步长 $h_{\\text{fd}} = 10^{-4}$；报告在 $\\boldsymbol{\\alpha}_0$ 处评估的中心差分梯度与伴随梯度之间的最大分量相对误差。\n    2. 网格尺寸 $N = 31$，中心差分步长 $h_{\\text{fd}} = 10^{-1}$；报告在 $\\boldsymbol{\\alpha}_0$ 处评估的中心差分梯度与伴随梯度之间的最大分量相对误差。\n    3. 网格尺寸 $N = 31$，前向差分步长 $h_{\\text{fd}} = 10^{-8}$；报告在 $\\boldsymbol{\\alpha}_0$ 处评估的前向差分梯度与伴随梯度之间的最大分量相对误差。\n    4. 网格尺寸 $N = 31$，中心差分步长 $h_{\\text{fd}} = 10^{-6}$，固定方向 $\\mathbf{v} = \\frac{1}{\\|\\tilde{\\mathbf{v}}\\|_2}\\tilde{\\mathbf{v}}$（其中 $\\tilde{\\mathbf{v}} = [0.5, -0.7, 0.2]$）；报告中心差分方向导数与 $\\mathbf{g}_{\\text{ref}} \\cdot \\mathbf{v}$ 之间的绝对误差。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，“[result1,result2,result3,result4]”），结果的顺序与上面列出的四个测试用例完全一致。所有结果都是无量纲的实数。", "solution": "问题陈述已经过严格验证，并被确定为有效。它在科学上基于连续介质力学和数值分析的原理，特别是关于使用水平集方法的拓扑优化和通过伴随法进行的灵敏度分析。该问题是良构的、客观的，并为数值实验提供了一套完整且一致的规范。这是一个实质性的、可验证的计算问题，而非琐碎或定义不清的问题。因此，我们可以开始求解。\n\n问题的核心是计算类柔度目标函数关于定义材料分布的设计参数的梯度。设计由一个水平集函数参数化，结构响应由一个标量椭圆偏微分方程控制。我们将首先使用连续伴随法推导梯度的表达式，然后详细说明用于数值实现的一致性离散化。\n\n系统的状态由在域 $\\Omega = (0,1) \\times (0,1)$ 上的标量椭圆偏微分方程的解 $u(\\mathbf{x})$ 描述：\n$$ -\\nabla \\cdot (k(\\mathbf{x}) \\nabla u(\\mathbf{x})) = s(\\mathbf{x}) $$\n边界条件为 $\\partial\\Omega$ 上的齐次狄利克雷边界条件 $u=0$。电导率 $k(\\mathbf{x})$ 通过水平集函数 $\\phi(\\mathbf{x}; \\boldsymbol{\\alpha})$ 依赖于设计参数 $\\boldsymbol{\\alpha}$。目标泛函定义为：\n$$ J = \\int_{\\Omega} s(\\mathbf{x}) u(\\mathbf{x}) \\, d\\mathbf{x} $$\n我们寻求梯度 $\\frac{dJ}{d\\boldsymbol{\\alpha}}$。使用伴随法，我们引入一个带有伴随变量（拉格朗日乘子）$p(\\mathbf{x})$ 的拉格朗日函数 $\\mathcal{L}$：\n$$ \\mathcal{L}(u, p, \\boldsymbol{\\alpha}) = J(u, \\boldsymbol{\\alpha}) + \\int_{\\Omega} p \\left(\\nabla \\cdot (k(\\boldsymbol{\\alpha}) \\nabla u) + s\\right) \\, d\\mathbf{x} $$\n只要状态方程和伴随方程得到满足，目标函数关于设计参数 $\\alpha_j$ 的全导数就由拉格朗日函数的偏导数给出。我们首先通过要求 $\\mathcal{L}$ 关于状态变量 $u$ 的 Gâteaux 导数对于所有容许的变分 $\\delta u$ 为零来建立伴随方程：\n$$ \\frac{\\partial \\mathcal{L}}{\\partial u}(\\delta u) = \\int_{\\Omega} s \\, \\delta u \\, d\\mathbf{x} + \\int_{\\Omega} p \\, \\nabla \\cdot (k \\nabla \\delta u) \\, d\\mathbf{x} = 0 $$\n对第二项进行两次分部积分，并利用 $\\delta u = 0$ 在 $\\partial\\Omega$ 上的事实，我们得到：\n$$ \\int_{\\Omega} p \\, \\nabla \\cdot (k \\nabla \\delta u) \\, d\\mathbf{x} = \\int_{\\Omega} (\\nabla \\cdot (k \\nabla p)) \\delta u \\, d\\mathbf{x} $$\n因此，Gâteaux 导数的条件变为：\n$$ \\int_{\\Omega} \\left(s + \\nabla \\cdot (k \\nabla p)\\right) \\delta u \\, d\\mathbf{x} = 0 $$\n由于这对任何容许的 $\\delta u$ 都必须成立，我们得到伴随方程：\n$$ -\\nabla \\cdot (k(\\boldsymbol{\\alpha}) \\nabla p) = s $$\n伴随边界条件为 $p=0$ 在 $\\partial\\Omega$ 上。对于这个特定问题，伴随方程与状态方程相同，这意味着伴随解等于状态解，即 $p=u$。这是具有此类目标泛函的自伴随问题的一个特征。\n\n在伴随方程满足的情况下，通过对拉格朗日函数求关于 $\\alpha_j$ 的偏导数，可以找到目标函数的梯度：\n$$ \\frac{dJ}{d\\alpha_j} = \\frac{\\partial \\mathcal{L}}{\\partial \\alpha_j} = \\int_{\\Omega} p \\, \\nabla \\cdot \\left( \\frac{\\partial k}{\\partial \\alpha_j} \\nabla u \\right) \\, d\\mathbf{x} $$\n应用分部积分并使用 $p=0$ 在 $\\partial\\Omega$ 上，这变为：\n$$ \\frac{dJ}{d\\alpha_j} = - \\int_{\\Omega} \\frac{\\partial k}{\\partial \\alpha_j} (\\nabla p \\cdot \\nabla u) \\, d\\mathbf{x} $$\n代入 $p=u$，我们得到：\n$$ \\frac{dJ}{d\\alpha_j} = - \\int_{\\Omega} \\frac{\\partial k}{\\partial \\alpha_j} |\\nabla u|^2 \\, d\\mathbf{x} $$\n连续推导的最后一步是求 $\\frac{\\partial k}{\\partial \\alpha_j}$。使用链式法则和给定的模型规格：\n$$ \\frac{\\partial k}{\\partial \\alpha_j} = \\frac{\\partial k}{\\partial \\rho} \\frac{\\partial \\rho}{\\partial \\phi} \\frac{\\partial \\phi}{\\partial \\alpha_j} $$\n其中 $\\rho(\\mathbf{x}) = H_{\\varepsilon}(\\phi(\\mathbf{x};\\boldsymbol{\\alpha}))$。各项为：\n- $\\frac{\\partial k}{\\partial \\rho} = k_{\\text{solid}} - k_{\\text{void}}$\n- $\\frac{\\partial \\rho}{\\partial \\phi} = \\delta_{\\varepsilon}(\\phi)$，光滑狄拉克δ函数。\n- $\\frac{\\partial \\phi}{\\partial \\alpha_j} = R_j(\\mathbf{x})$，第 $j$ 个径向基函数。\n\n将这些代入梯度表达式，得到梯度分量的最终连续形式：\n$$ \\frac{dJ}{d\\alpha_j} = - (k_{\\text{solid}} - k_{\\text{void}}) \\int_{\\Omega} \\delta_{\\varepsilon}(\\phi(\\mathbf{x};\\boldsymbol{\\alpha})) R_j(\\mathbf{x}) |\\nabla u|^2 \\, d\\mathbf{x} $$\n\n对于数值实现，我们使用一个具有 $N \\times N$ 个内部点且间距为 $h = 1/(N+1)$ 的均匀网格来离散化域 $\\Omega$。状态方程使用五点有限差分格式进行离散化，得到一个稀疏线性系统 $\\mathbf{A}(\\boldsymbol{\\alpha})\\mathbf{u} = \\mathbf{s}$，其中 $\\mathbf{u}$ 是内部网格点上的解值向量，$\\mathbf{s}$ 是源项值的向量，所有点的 $s_{i,j}=1$。刚度矩阵 $\\mathbf{A}$ 是基于单元面上电导率 $k$ 的算术平均构建的，并遵循指定的规则，即边界处的面电导率取为相邻内部单元的电导率。\n\n一旦求解状态方程得到 $\\mathbf{u}$，我们就可以计算梯度。问题指示我们使用灵敏度积分的一致性离散近似。我们将通过在内部网格点上进行黎曼和来计算此积分：\n$$ \\frac{dJ}{d\\alpha_j} \\approx - (k_{\\text{solid}} - k_{\\text{void}}) h^2 \\sum_{i=1}^{N} \\sum_{l=1}^{N} \\left( \\delta_{\\varepsilon}(\\phi_{i,l}) R_{j, i,l} |\\nabla u|^2_{i,l} \\right) $$\n其中指数 $(i,l)$ 遍历 $N \\times N$ 内部网格。项 $|\\nabla u|^2_{i,l}$ 使用二阶中心差分计算。为了在边界附近一致地处理点，离散解向量 $\\mathbf{u}$ 被重塑为一个 $N \\times N$ 的数组，并用一层零填充，以表示齐次狄利克雷边界条件。这使得中心差分模板可以统一应用于所有内部点。\n\n整体算法如下：\n1. 对于给定的设计向量 $\\boldsymbol{\\alpha}$，在网格上评估水平集函数 $\\phi$ 和电导率场 $k$。\n2. 基于电导率场 $k$ 组装稀疏刚度矩阵 $\\mathbf{A}$。\n3. 求解线性系统 $\\mathbf{A}\\mathbf{u} = \\mathbf{s}$ 以获得离散状态解 $\\mathbf{u}$。\n4. 在零填充的解数组上使用中心差分计算离散梯度场 $|\\nabla u|^2$。\n5. 对于每个设计参数 $\\alpha_j$，通过求和对灵敏度表达式进行数值积分来评估梯度分量 $\\frac{dJ}{d\\alpha_j}$。\n\n然后，如此处基于伴随法计算的梯度 $\\mathbf{g}_{\\text{ref}}$，将与测试套件中指定的、使用不同步长 $h_{\\text{fd}}$ 的前向和中心有限差分格式计算的梯度进行比较。计算规定的误差度量（分量相对误差和方向导数绝对误差）以验证实现。", "answer": "```python\nimport numpy as np\nfrom scipy.sparse import lil_matrix, csc_matrix\nfrom scipy.sparse.linalg import spsolve\n\ndef solve():\n    \"\"\"\n    Implements and assesses numerical differentiation for a level set based material\n    optimization problem in solid mechanics.\n    \"\"\"\n\n    class LevelSetSolver:\n        \"\"\"\n        A class to solve the scalar elliptic PDE and compute sensitivities.\n        \"\"\"\n        def __init__(self, N, M, c, sigma, k_solid, k_void):\n            self.N = N\n            self.M = M\n            self.c = np.array(c)\n            self.sigma = sigma\n            self.k_solid = k_solid\n            self.k_void = k_void\n\n            self.h = 1.0 / (N + 1)\n            self.epsilon = 2.0 * self.h\n\n            # Create grid coordinates\n            x_coords = np.linspace(self.h, 1.0 - self.h, N)\n            self.x_grid, self.y_grid = np.meshgrid(x_coords, x_coords)\n\n            # Pre-compute RBFs on the grid\n            self.R = np.zeros((M, N, N))\n            for j in range(M):\n                dist_sq = (self.x_grid - self.c[j, 0])**2 + (self.y_grid - self.c[j, 1])**2\n                self.R[j] = np.exp(-dist_sq / self.sigma**2)\n\n        def H_eps(self, phi):\n            \"\"\" Smoothed Heaviside function. \"\"\"\n            H = np.zeros_like(phi)\n            mask_le = phi = -self.epsilon\n            mask_ge = phi >= self.epsilon\n            mask_mid = np.abs(phi)  self.epsilon\n\n            H[mask_le] = 0.0\n            H[mask_ge] = 1.0\n            phi_mid = phi[mask_mid]\n            H[mask_mid] = 0.5 * (1.0 + phi_mid / self.epsilon + (1.0 / np.pi) * np.sin(np.pi * phi_mid / self.epsilon))\n            return H\n\n        def delta_eps(self, phi):\n            \"\"\" Smoothed Dirac delta function. \"\"\"\n            delta = np.zeros_like(phi)\n            mask_mid = np.abs(phi)  self.epsilon\n            phi_mid = phi[mask_mid]\n            delta[mask_mid] = (1.0 / (2.0 * self.epsilon)) * (1.0 + np.cos(np.pi * phi_mid / self.epsilon))\n            return delta\n\n        def get_k_field_and_phi(self, alpha):\n            \"\"\" Calculates conductivity k(x) and level set phi(x) for a given alpha. \"\"\"\n            phi = np.tensordot(alpha, self.R, axes=1)\n            rho = self.H_eps(phi)\n            k = self.k_void + (self.k_solid - self.k_void) * rho\n            return k, phi\n\n        def assemble_A(self, k):\n            \"\"\" Assembles the sparse stiffness matrix A.\"\"\"\n            N = self.N\n            h = self.h\n            A = lil_matrix((N * N, N * N))\n            \n            # Iterate through interior grid points\n            for i in range(N):  # y-index\n                for j in range(N):  # x-index\n                    idx = i * N + j  # 1D index\n\n                    # Conductivity at faces using specified rules\n                    # West face (x-dir)\n                    k_W = k[i, j] if j == 0 else (k[i, j] + k[i, j - 1]) / 2.0\n                    # East face (x-dir)\n                    k_E = k[i, j] if j == N - 1 else (k[i, j] + k[i, j + 1]) / 2.0\n                    # South face (y-dir)\n                    k_S = k[i, j] if i == 0 else (k[i, j] + k[i - 1, j]) / 2.0\n                    # North face (y-dir)\n                    k_N = k[i, j] if i == N - 1 else (k[i, j] + k[i + 1, j]) / 2.0\n                    \n                    # Fill matrix A based on 5-point stencil\n                    A[idx, idx] = (k_W + k_E + k_S + k_N)\n                    if j > 0: A[idx, idx - 1] = -k_W  # West neighbor\n                    if j  N - 1: A[idx, idx + 1] = -k_E  # East neighbor\n                    if i > 0: A[idx, idx - N] = -k_S  # South neighbor\n                    if i  N - 1: A[idx, idx + N] = -k_N  # North neighbor\n\n            return csc_matrix(A / h**2)\n\n        def solve_state(self, alpha):\n            \"\"\" Solves the PDE for the state variable u. \"\"\"\n            k, phi = self.get_k_field_and_phi(alpha)\n            A = self.assemble_A(k)\n            s = np.ones(self.N * self.N)\n            u_flat = spsolve(A, s)\n            u = u_flat.reshape((self.N, self.N))\n            return u, k, phi\n\n        def compute_J(self, u):\n            \"\"\" Computes the objective functional J. \"\"\"\n            return self.h**2 * np.sum(u)\n\n        def calculate_J_at_alpha(self, alpha):\n            \"\"\" Utility function to get J directly from an alpha vector. \"\"\"\n            u, _, _ = self.solve_state(alpha)\n            return self.compute_J(u)\n\n        def compute_adjoint_gradient(self, alpha):\n            \"\"\" Computes the gradient of J w.r.t. alpha using the adjoint method. \"\"\"\n            u, _, phi = self.solve_state(alpha)\n            \n            N, h = self.N, self.h\n            \n            # Pad u with zero boundary values for gradient calculation\n            u_padded = np.zeros((N + 2, N + 2))\n            u_padded[1:-1, 1:-1] = u\n\n            # Compute gradient of u using centered differences on padded array\n            du_dy = (u_padded[2:, 1:-1] - u_padded[:-2, 1:-1]) / (2.0 * h)\n            du_dx = (u_padded[1:-1, 2:] - u_padded[1:-1, :-2]) / (2.0 * h)\n            grad_u_sq = du_dx**2 + du_dy**2\n\n            delta = self.delta_eps(phi)\n            \n            # Calculate each component of the gradient vector\n            grad_J = np.zeros(self.M)\n            for j in range(self.M):\n                integrand = delta * self.R[j] * grad_u_sq\n                grad_J[j] = -(self.k_solid - self.k_void) * np.sum(integrand) * h**2\n            \n            return grad_J\n\n    # Problem parameters\n    N = 31\n    M = 3\n    c = [[0.3, 0.3], [0.7, 0.3], [0.5, 0.7]]\n    sigma = 0.15\n    alpha_0 = np.array([0.2, -0.3, 0.1])\n    k_solid = 1.0\n    k_void = 1e-3\n    tau = 1e-12\n\n    # Initialize solver\n    solver = LevelSetSolver(N, M, c, sigma, k_solid, k_void)\n    \n    # Calculate reference gradient using the adjoint method\n    g_ref = solver.compute_adjoint_gradient(alpha_0)\n\n    results = []\n\n    # Test Case 1: Central difference, h_fd = 1e-4\n    h_fd_1 = 1e-4\n    g_cd_1 = np.zeros(M)\n    for j in range(M):\n        alpha_plus = alpha_0.copy(); alpha_plus[j] += h_fd_1\n        alpha_minus = alpha_0.copy(); alpha_minus[j] -= h_fd_1\n        g_cd_1[j] = (solver.calculate_J_at_alpha(alpha_plus) - solver.calculate_J_at_alpha(alpha_minus)) / (2.0 * h_fd_1)\n    rel_error_1 = np.abs(g_cd_1 - g_ref) / np.maximum(np.abs(g_ref), tau)\n    results.append(np.max(rel_error_1))\n\n    # Test Case 2: Central difference, h_fd = 1e-1\n    h_fd_2 = 1e-1\n    g_cd_2 = np.zeros(M)\n    for j in range(M):\n        alpha_plus = alpha_0.copy(); alpha_plus[j] += h_fd_2\n        alpha_minus = alpha_0.copy(); alpha_minus[j] -= h_fd_2\n        g_cd_2[j] = (solver.calculate_J_at_alpha(alpha_plus) - solver.calculate_J_at_alpha(alpha_minus)) / (2.0 * h_fd_2)\n    rel_error_2 = np.abs(g_cd_2 - g_ref) / np.maximum(np.abs(g_ref), tau)\n    results.append(np.max(rel_error_2))\n\n    # Test Case 3: Forward difference, h_fd = 1e-8\n    h_fd_3 = 1e-8\n    g_fd_3 = np.zeros(M)\n    J_0 = solver.calculate_J_at_alpha(alpha_0)\n    for j in range(M):\n        alpha_plus = alpha_0.copy(); alpha_plus[j] += h_fd_3\n        g_fd_3[j] = (solver.calculate_J_at_alpha(alpha_plus) - J_0) / h_fd_3\n    rel_error_3 = np.abs(g_fd_3 - g_ref) / np.maximum(np.abs(g_ref), tau)\n    results.append(np.max(rel_error_3))\n\n    # Test Case 4: Directional derivative check\n    h_fd_4 = 1e-6\n    v_tilde = np.array([0.5, -0.7, 0.2])\n    v = v_tilde / np.linalg.norm(v_tilde)\n    alpha_plus = alpha_0 + h_fd_4 * v\n    alpha_minus = alpha_0 - h_fd_4 * v\n    dir_deriv_cd = (solver.calculate_J_at_alpha(alpha_plus) - solver.calculate_J_at_alpha(alpha_minus)) / (2.0 * h_fd_4)\n    dir_deriv_adj = np.dot(g_ref, v)\n    abs_error_4 = np.abs(dir_deriv_cd - dir_deriv_adj)\n    results.append(abs_error_4)\n\n    # Format and print the final output\n    print(f\"[{','.join(f'{r:.12e}' for r in results)}]\")\n\nsolve()\n```", "id": "2654352"}]}