{"hands_on_practices": [{"introduction": "在焓法中，焓是模型求解的主要变量，而温度和液相分数等物理量则需从焓值中反算得出。本实践旨在建立并实现一个稳健的算法，用于从已知的比焓$h$中恢复温度$T$和液相分数$f_l$ [@problem_id:2482083]。通过解决这个核心反演问题，您将深刻理解固相、糊状区和液相中焓与温度的本构关系，为构建任何基于焓法的相变模型打下坚实的基础。", "problem": "您正在使用焓法对一维控制体中的相变进行建模。该控制体中包含一种纯物质，在一定的温度区间内发生固液相变。在焓法中，单元的总比焓 $h$ 被存储，并通过能量守恒方程进行时间推进。为了从已知的 $h$ 重构温度 $T$ 和液相质量分数 $f_l$，您必须仅使用基本原理和最简闭合模型来反转焓-温度映射。\n\n基本依据和建模假设：\n- 使用能量守恒定律以及比焓是显热和潜热贡献之和的定义。\n- 假设固相和液相的比热容 $c_p$ 为常数且相同。\n- 假设局部热平衡（LTE），因此控制体内的两相可用单一温度 $T$ 来表征。\n- 在糊状区使用标准的杠杆定则闭合模型，即，在固相线温度 $T_s$ 和液相线温度 $T_l$ 之间的两相区间内，液相分数 $f_l$ 随温度 $T$ 从 0 单调变化到 1，并且潜热 $L$ 在此区间内根据 LTE 进行一致性分配。\n- 取参考状态为：在固相线上，当没有潜热贡献时，比焓为零，即，在 $T=T_s$ 且 $f_l=0$ 时，$h=0$。\n\n您的任务：\n- 从上述原理出发，推导一个从比焓 $h$ 到 $(T, f_l)$ 对的稳健的分段可逆映射，该映射既适用于 $T_l > T_s$ 的有限糊状区情况，也适用于 $T_l=T_s$ 的等温相变极限情况。\n- 证明您的映射在 $T$ 上是单调的，并且反演 $(h \\mapsto (T, f_l))$ 在有限精度算法下是适定且数值稳健的。\n- 将推导出的反演过程实现为一个程序，该程序在给定 $(h, T_s, T_l, c_p, L)$ 的情况下，恢复 $(T, f_l)$。\n- 强制执行物理约束 $f_l \\in [0,1]$，并且在两相区间内，$T \\in [T_s, T_l]$。如果 $T_l=T_s$，则将其解释为在 $T=T_s$ 处具有潜热平台的等温相变。\n- 明确指定单位：$T$、$T_s$ 和 $T_l$ 的单位是开尔文（K），$h$ 和 $L$ 的单位是焦耳每千克（J/kg），$c_p$ 的单位是焦耳每千克开尔文（J/(kg·K)）。温度以开尔文表示，$f_l$ 表示为 $[0,1]$ 区间内的小数。将 $T$ 和 $f_l$ 都四舍五入到六位小数。\n\n测试套件：\n对于下面的每个参数集 $(h,T_s,T_l,c_p,L)$，计算并返回 $(T,f_l)$，结果需使用指定的单位并进行四舍五入。测试套件涵盖了亚固相区、糊状区和超液相区，以及等温极限和边界条件。\n\n- 案例 A（亚固相区，有限糊状区间）：$(h, T_s, T_l, c_p, L) = (-100000, 300, 350, 2000, 250000)$\n- 案例 B（糊状区内部，有限糊状区间）：$(h, T_s, T_l, c_p, L) = (175000, 300, 350, 2000, 250000)$\n- 案例 C（液相线边界，有限糊状区间）：$(h, T_s, T_l, c_p, L) = (350000, 300, 350, 2000, 250000)$\n- 案例 D（超液相区，有限糊状区间）：$(h, T_s, T_l, c_p, L) = (450000, 300, 350, 2000, 250000)$\n- 案例 E（等温潜热平台）：$(h, T_s, T_l, c_p, L) = (50000, 300, 300, 1000, 100000)$\n- 案例 F（等温，超液相区）：$(h, T_s, T_l, c_p, L) = (150000, 300, 300, 1000, 100000)$\n- 案例 G（糊状区下边界，有限糊状区间）：$(h, T_s, T_l, c_p, L) = (0, 300, 350, 2000, 250000)$\n\n最终输出格式：\n您的程序应生成单行输出，其中按顺序包含案例 A 到 G 的结果，形式为方括号括起来的逗号分隔列表。每个元素本身必须是一个双元素列表 $[T,f_l]$，两个值都四舍五入到六位小数。例如，整体结构必须如下所示：[[T_A,f_A],[T_B,f_B],...,[T_G,f_G]]（不要包含变量名；这只是结构示例）。数字必须以小数形式打印，而不是分数，并且输出行中不带任何单位。", "solution": "比焓 $h$ 的基本关系是其显热和潜热分量之和。根据题设，参考状态为 $T=T_s$ 且 $f_l=0$ 时 $h=0$。总比焓 $h$ 与温度 $T$ 和液相分数 $f_l$ 的关系为：\n$$h(T, f_l) = c_p (T - T_s) + f_l L$$\n\n为了建立从 $h$ 到 $(T, f_l)$ 的唯一映射，我们分三种情况讨论：\n\n1.  **固相区 ($T  T_s$):** 材料完全是固态，因此 $f_l=0$。焓完全是显热：\n    $$h = c_p (T - T_s)$$\n    此时 $h  0$。反解可得 $T = T_s + h/c_p$。\n\n2.  **液相区 ($T > T_l$):** 材料完全是液态，因此 $f_l=1$。焓包括从 $T_s$ 加热到 $T$ 的全部显热和全部潜热：\n    $$h = c_p (T - T_s) + L$$\n    定义液相线上的焓值为 $h_l = c_p(T_l - T_s) + L$。当 $h > h_l$ 时，材料处于液相区。反解可得 $T = T_s + (h - L)/c_p$。\n\n3.  **相变区 ($T_s \\le T \\le T_l$):** 材料是固液混合物。最简单的模型是假设液相分数与温度呈线性关系：\n    $$f_l(T) = \\frac{T - T_s}{T_l - T_s}$$\n    代入总焓方程可得 $h = c_p(T-T_s) + L f_l(T)$。利用 $T-T_s = f_l(T_l-T_s)$，我们可以消去 $T$：\n    $$h = c_p f_l (T_l - T_s) + L f_l = f_l [c_p (T_l - T_s) + L] = f_l \\cdot h_l$$\n    因此，在 $0 \\le h \\le h_l$ 的范围内，我们可以先求得液相分数 $f_l = h / h_l$，然后求得温度 $T = T_s + f_l (T_l - T_s)$。\n\n**等温情况 ($T_s = T_l$):**\n此时 $h_l = L$。\n- 对于 $h  0$ (固相), $f_l=0$, $T=T_s+h/c_p$。\n- 对于 $h > L$ (液相), $f_l=1$, $T=T_s+(h-L)/c_p$。\n- 对于 $0 \\le h \\le L$ (相变平台), $T=T_s$, $f_l=h/L$。\n\n该分段映射在数值上是稳健且适定的。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for temperature (T) and liquid fraction (f_l) from specific enthalpy (h)\n    using the enthalpy method for phase change, covering multiple test cases.\n    \"\"\"\n\n    # test_cases format: (h, T_s, T_l, c_p, L)\n    # Units: h, L [J/kg]; T_s, T_l [K]; c_p [J/(kg·K)]\n    test_cases = [\n        # Case A: Subsolidus, finite mushy interval\n        (-100000.0, 300.0, 350.0, 2000.0, 250000.0),\n        # Case B: Mushy interior, finite mushy interval\n        (175000.0, 300.0, 350.0, 2000.0, 250000.0),\n        # Case C: Liquid boundary, finite mushy interval\n        (350000.0, 300.0, 350.0, 2000.0, 250000.0),\n        # Case D: Superliquid, finite mushy interval\n        (450000.0, 300.0, 350.0, 2000.0, 250000.0),\n        # Case E: Isothermal latent plateau\n        (50000.0, 300.0, 300.0, 1000.0, 100000.0),\n        # Case F: Isothermal, superliquid\n        (150000.0, 300.0, 300.0, 1000.0, 100000.0),\n        # Case G: Mushy lower boundary, finite mushy interval\n        (0.0, 300.0, 350.0, 2000.0, 250000.0),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        h, T_s, T_l, c_p, L = case\n        \n        # Enforce physical assumptions for robustness, although test cases are well-behaved.\n        # Tolerate floating point inaccuracies for T_l == T_s comparison.\n        is_isothermal = abs(T_l - T_s)  1e-9\n\n        if is_isothermal:\n            # Isothermal phase change at T_s\n            h_l = L\n        else:\n            # Phase change over a mushy interval [T_s, T_l]\n            h_l = c_p * (T_l - T_s) + L\n        \n        h_s = 0.0\n\n        T, f_l = 0.0, 0.0\n\n        if h  h_s:\n            # Subsolidus (solid) regime\n            f_l = 0.0\n            T = T_s + h / c_p\n        elif h > h_l:\n            # Superliquid (liquid) regime\n            f_l = 1.0\n            T = T_s + (h - L) / c_p\n        else: # h_s = h = h_l\n            # Phase change regime (mushy or isothermal plateau)\n            if is_isothermal:\n                T = T_s\n                # Avoid division by zero if L=0 (no phase change), though problem implies L>0.\n                f_l = h / L if L > 0 else 0.0\n            else: # Mushy zone\n                # Numerically robust calculation: find f_l first\n                # f_l = h / h_l ; T = T_s + f_l * (T_l - T_s)\n                # Avoid division by zero if h_l=0 (unphysical for L>0, T_l>T_s)\n                f_l = h / h_l if h_l > 0 else 0.0\n                T = T_s + f_l * (T_l - T_s)\n\n        # Round to six decimal places as required\n        T_rounded = round(T, 6)\n        f_l_rounded = round(f_l, 6)\n        \n        # Ensure T_rounded isn't negative zero\n        if T_rounded == -0.0:\n            T_rounded = 0.0\n            \n        results.append([T_rounded, f_l_rounded])\n\n    # Format the final output string exactly as specified, without extra spaces\n    # Example: [[T_A,f_l_A],[T_B,f_l_B]]\n    result_str = \"[\" + \",\".join([f\"[{r[0]},{r[1]}]\" for r in results]) + \"]\"\n    print(result_str)\n\nsolve()\n```", "id": "2482083"}, {"introduction": "在建立数值模型后，下一步是正确地施加边界条件，以模拟系统与外部环境的相互作用。本实践要求您从第一性原理出发，为邻近对流边界的控制体推导其离散的焓平衡方程 [@problem_id:2482106]。通过这个练习，您将学会如何将连续的物理边界条件（如第三类边界条件）转化为有限体积法中的离散源项，这是确保仿真能量守恒和物理真实性的关键一步。", "problem": "一个相变材料（PCM）构成的一维半无限大平板占据了 $x \\ge 0$ 的半空间。该平板通过焓法进行建模，其中体积焓 $H(T)$ 通过一个适当的随温度变化的函数关系来同时考虑显热和潜热。固体中的控制能量守恒定律仅为热传导，其中导热系数 $k$ 被视为常数。位于 $x=0$ 的边界暴露于环境温度为 $T_{\\infty}$、对流换热系数为 $h_c$ 的外部流体中，因此边界处的热交换由牛顿冷却定律控制。您使用以单元为中心的有限体积法（FVM）对固体进行离散化，考虑邻近边界的控制体积，记为 $P$，其厚度为 $\\Delta x$，横截面积为 $A$（因此控制体积为 $V_P = A\\,\\Delta x$）。设 $T_P$ 表示 $P$ 中的单元中心温度，设 $T_w$ 表示位于 $x=0$ 的边界面上的温度。\n\n从基本原理出发，不使用任何预先封装的离散化公式：\n\n- 利用 $V_P$ 上的能量守恒积分形式、傅里叶热传导定律和牛顿冷却定律，为单元 $P$ 构建半离散焓平衡方程，并明确定义 $x=0$ 处边界热通量 $q_w$ 的符号约定。\n- 在 $x=0$ 处施加对流（罗宾）边界条件，方法是在 $x=0$ 的边界面和 $x=\\Delta x/2$ 的单元中心之间使用线性重构，以消去 $T_w$，用 $T_P$ 和 $T_{\\infty}$ 来表示。\n- 在得到的半离散焓平衡方程中，将边界贡献识别为一个体积源项 $S_b(T_P)$，该源项仅依赖于 $k$、$h_c$、$\\Delta x$、$T_{\\infty}$ 和 $T_P$。\n\n请提供要添加到单元 $P$ 焓平衡方程右侧的体积边界源项 $S_b(T_P)$ 的精确解析表达式。将 $S_b(T_P)$ 以 $\\mathrm{W}\\,\\mathrm{m}^{-3}$ 为单位表示。最终答案必须是仅包含 $k$、$h_c$、$\\Delta x$、$T_{\\infty}$ 和 $T_P$ 的单个闭式表达式。", "solution": "该问题陈述已经过验证，被认为是具有科学依据、提法恰当且客观的。它构成了计算传热学领域的一个标准推导。我们将从基本原理出发，推导所要求的表达式。\n\n控制体积 $V_P$ 的能量守恒定律的积分形式为：\n$$\n\\frac{d}{dt} \\int_{V_P} H(T) \\, dV = - \\oint_{\\partial V_P} \\vec{q} \\cdot d\\vec{S}\n$$\n其中 $H(T)$ 是体积焓（单位为 $\\mathrm{J}\\,\\mathrm{m}^{-3}$），$\\vec{q}$ 是热通量矢量（单位为 $\\mathrm{W}\\,\\mathrm{m}^{-2}$），$t$ 是时间，$V_P$ 是控制体积，$\\partial V_P$ 是其边界面。\n\n对于所述的邻近边界的一维单元中心控制体积 $P$，其体积为 $V_P = A \\Delta x$，其中 $A$ 是横截面积，$\\Delta x$ 是厚度。该控制体积从 $x=0$ 处的物理边界（西面，$w$）延伸到 $x=\\Delta x$ 处的内部单元面（东面，$e$）。定义温度 $T_P$ 的单元中心位于 $x_P = \\Delta x/2$。\n\n假设单元内的焓是均匀的，即 $H(T) \\approx H(T_P) = H_P$，则积分能量平衡简化为一个半离散常微分方程：\n$$\nV_P \\frac{dH_P}{dt} = A q_w - A q_e\n$$\n此处，我们采用的符号约定是热通量 $q$ 在 $x$ 正方向上为正。因此，$q_w$ 是在西面（$x=0$）进入控制体积的热通量，$q_e$ 是在东面（$x=\\Delta x$）离开的热通量。等式两边同除以控制体积 $V_P = A \\Delta x$，我们得到单位体积的能量平衡：\n$$\n\\frac{dH_P}{dt} = \\frac{q_w}{\\Delta x} - \\frac{q_e}{\\Delta x}\n$$\n问题要求的是此平衡方程中的边界贡献，我们将其识别为体积源项 $S_b(T_P)$。该项源于西面的通量 $q_w$：\n$$\nS_b(T_P) = \\frac{q_w}{\\Delta x}\n$$\n为了确定 $q_w$，我们必须施加对流边界条件。在表面 $x=0$ 处，热通量是连续的。它由流体侧的牛顿冷却定律和固体侧的傅里叶热传导定律给出。\n1. 从温度为 $T_{\\infty}$ 的流体到温度为 $T_w$ 的壁面的对流通量：\n$$\nq_w = h_c (T_{\\infty} - T_w)\n$$\n2. 从壁面进入固体的传导通量：\n$$\nq_w = -k \\left. \\frac{\\partial T}{\\partial x} \\right|_{x=0}\n$$\n题目指定在 $x=0$ 的边界面和 $x_P = \\Delta x/2$ 的单元中心之间对温度分布使用线性重构。这使我们能够近似壁面处的温度梯度：\n$$\n\\left. \\frac{\\partial T}{\\partial x} \\right|_{x=0} \\approx \\frac{T_P - T_w}{x_P - 0} = \\frac{T_P - T_w}{\\Delta x / 2}\n$$\n将此近似代入傅里叶定律，得到：\n$$\nq_w = -k \\left( \\frac{T_P - T_w}{\\Delta x / 2} \\right) = \\frac{2k}{\\Delta x} (T_w - T_P)\n$$\n通过令 $q_w$ 的对流和传导表达式相等，我们施加了边界处的通量连续性条件：\n$$\nh_c (T_{\\infty} - T_w) = \\frac{2k}{\\Delta x} (T_w - T_P)\n$$\n我们现在必须解这个代数方程，以单元温度 $T_P$ 和环境温度 $T_{\\infty}$ 来表示未知的壁面温度 $T_w$：\n$$\nh_c T_{\\infty} - h_c T_w = \\frac{2k}{\\Delta x} T_w - \\frac{2k}{\\Delta x} T_P\n$$\n$$\nh_c T_{\\infty} + \\frac{2k}{\\Delta x} T_P = T_w \\left( h_c + \\frac{2k}{\\Delta x} \\right)\n$$\n$$\nT_w = \\frac{h_c T_{\\infty} + \\frac{2k}{\\Delta x} T_P}{h_c + \\frac{2k}{\\Delta x}}\n$$\n现在我们可以构建体积源项 $S_b(T_P)$ 的最终表达式。我们将 $T_w$ 的表达式代入公式 $S_b(T_P) = \\frac{h_c(T_{\\infty} - T_w)}{\\Delta x}$：\n$$\nS_b(T_P) = \\frac{h_c}{\\Delta x} \\left( T_{\\infty} - \\frac{h_c T_{\\infty} + \\frac{2k}{\\Delta x} T_P}{h_c + \\frac{2k}{\\Delta x}} \\right)\n$$\n为了简化，我们将括号内的项通分：\n$$\nS_b(T_P) = \\frac{h_c}{\\Delta x} \\left( \\frac{T_{\\infty} \\left(h_c + \\frac{2k}{\\Delta x}\\right) - \\left(h_c T_{\\infty} + \\frac{2k}{\\Delta x} T_P\\right)}{h_c + \\frac{2k}{\\Delta x}} \\right)\n$$\n展开分子：\n$$\nS_b(T_P) = \\frac{h_c}{\\Delta x} \\left( \\frac{h_c T_{\\infty} + \\frac{2k}{\\Delta x} T_{\\infty} - h_c T_{\\infty} - \\frac{2k}{\\Delta x} T_P}{h_c + \\frac{2k}{\\Delta x}} \\right)\n$$\n$h_c T_{\\infty}$ 项相互抵消，剩下：\n$$\nS_b(T_P) = \\frac{h_c}{\\Delta x} \\left( \\frac{\\frac{2k}{\\Delta x} (T_{\\infty} - T_P)}{h_c + \\frac{2k}{\\Delta x}} \\right)\n$$\n为了消除繁分数，我们可以将内部分数的分子和分母同乘以 $\\Delta x$：\n$$\nS_b(T_P) = \\frac{h_c}{\\Delta x} \\left( \\frac{2k (T_{\\infty} - T_P)}{h_c \\Delta x + 2k} \\right)\n$$\n最后，合并各项，得到体积边界源项的完整表达式：\n$$\nS_b(T_P) = \\frac{2 k h_c}{\\Delta x (2k + h_c \\Delta x)} (T_{\\infty} - T_P)\n$$\n该表达式表示由于 $x=0$ 处的对流边界条件，单位时间、单位体积内，添加到第一个控制体积的净热量。", "answer": "$$\n\\boxed{\\frac{2 k h_c (T_{\\infty} - T_P)}{\\Delta x (2k + h_c \\Delta x)}}\n$$", "id": "2482106"}, {"introduction": "虽然简化的分段线性模型有助于理解基本概念，但真实材料的相变行为通常更为复杂，其焓-温度关系 $h(T)$ 可能是高度非线性的。本实践将挑战您为具有非线性本构关系的材料设计一个稳健的数值反演程序 [@problem_id:2482091]。通过实施一个基于求根器的方法，您将掌握处理实际工程问题中遇到的复杂材料属性的先进技术，并体会到焓法在处理这类问题时的通用性。", "problem": "本文使用一维焓法来模拟具有随温度变化的复杂、非线性液相分数分布的相变过程。考虑单位质量比焓 $h(T)$，其定义在有界温度区间 $[T_{\\min},T_{\\max}]$（单位为开尔文）上，参考点取在 $T_{\\min}$，并通过液相分数引入潜热。待使用的本构关系如下：\n- 比热容 $c_p(T)$（单位 J/(kg·K)），由 $c_p(T)=a+b\\,(T-T_0)^2$ 给出，其中常数 $a\\ge 0$ 和 $b\\ge 0$。\n- 液相分数 $f_\\ell(T)\\in[0,1]$，定义为平滑阶跃函数的加权叠加，\n$$\nf_\\ell(T)=\\sum_{i=1}^m w_i\\,\\sigma\\!\\left(\\frac{T-T_i}{s_i}\\right),\n$$\n其中 $\\sigma(x)=\\dfrac{1}{1+e^{-x}}$ 是 logistic 函数，权重 $w_i$ 满足 $\\sum_{i=1}^m w_i=1$，$T_i$ 是相变温度（单位为开尔文），$s_i0$ 是平滑宽度（单位为开尔文）。为保证数值稳定性，如有需要，$f_\\ell(T)$ 的值应被钳位在区间 $[0,1]$ 内。\n- 潜热 $L$（单位 J/kg），且 $L\\ge 0$。\n\n比焓为\n$$\nh(T)=\\int_{T_{\\min}}^{T} c_p(\\theta)\\,\\mathrm{d}\\theta+L\\,f_\\ell(T),\n$$\n单位为 J/kg。注意，$h(T_{\\min})=\\int_{T_{\\min}}^{T_{\\min}} c_p(\\theta)\\,\\mathrm{d}\\theta+L\\,f_\\ell(T_{\\min})=L\\,f_\\ell(T_{\\min})$，以及 $h(T_{\\max})=\\int_{T_{\\min}}^{T_{\\max}} c_p(\\theta)\\,\\mathrm{d}\\theta+L\\,f_\\ell(T_{\\max})$。\n\n任务。设计并实现一个鲁棒的、全局收敛的求逆程序。该程序在给定一个目标焓值 $h^\\ast$（单位 J/kg）时，返回满足 $h(T)=h^\\ast$ 的唯一 $T\\in[T_{\\min},T_{\\max}]$（如果存在这样的 $T$）。该程序必须：\n- 按上述定义处理 $f_\\ell(T)$，它可能是非线性的，并导致 $h(T)$ 非凸，但由于 $c_p(T)\\ge 0$ 和 $L\\ge 0$，可确保 $h(T)$ 在 $[T_{\\min},T_{\\max}]$ 上具有单调性。\n- 对残差 $g(T)=h(T)-h^\\ast$ 使用一个基于区间法的求根器，该求根器保证收敛，而不管 $h(T)$ 的局部非凸性如何，且不假设凸性或仅依赖于局部导数。如果 $h^\\ast\\le h(T_{\\min})$，它必须返回边界值 $T_{\\min}$；如果 $h^\\ast\\ge h(T_{\\max})$，则必须返回边界值 $T_{\\max}$。\n- 使用提供的本构形式计算 $h(T)$，其中的积分根据二次函数 $c_p(T)$ 精确计算，即\n$$\n\\int_{T_{\\min}}^{T} c_p(\\theta)\\,\\mathrm{d}\\theta=a\\,(T-T_{\\min})+\\frac{b}{3}\\left[(T-T_0)^3-(T_{\\min}-T_0)^3\\right].\n$$\n\n本问题不涉及角度单位。所有温度都必须以开尔文报告，最终答案必须以开尔文为单位打印，并精确到小数点后六位。\n\n测试套件。使用以下六个案例。对于每个案例，按规定定义 $h^\\ast$，然后进行求逆以获得相应的温度。程序必须计算并按顺序输出这六个案例的温度列表。\n\n- 案例1：\n  - $T_{\\min}=300$ K, $T_{\\max}=1300$ K。\n  - $a=900$ J/(kg·K), $b=0$, $T_0=0$ K。\n  - $L=2.5\\times 10^5$ J/kg。\n  - $f_\\ell(T)=\\sigma\\!\\left(\\dfrac{T-900}{15}\\right)$。\n  - 定义 $h^\\ast=h(T^\\dagger)$，其中 $T^\\dagger=920$ K。\n\n- 案例2：\n  - $T_{\\min}=300$ K, $T_{\\max}=1400$ K。\n  - $a=1000$ J/(kg·K), $b=0$, $T_0=0$ K。\n  - $L=3.0\\times 10^5$ J/kg。\n  - $f_\\ell(T)=0.6\\,\\sigma\\!\\left(\\dfrac{T-700}{10}\\right)+0.4\\,\\sigma\\!\\left(\\dfrac{T-1000}{20}\\right)$。\n  - 定义 $h^\\ast=h(T^\\dagger)$，其中 $T^\\dagger=950$ K。\n\n- 案例3：\n  - $T_{\\min}=300$ K, $T_{\\max}=1200$ K。\n  - $a=850$ J/(kg·K), $b=0$, $T_0=0$ K。\n  - $L=1.8\\times 10^5$ J/kg。\n  - $f_\\ell(T)=\\sigma\\!\\left(\\dfrac{T-800}{0.8}\\right)$。\n  - 定义 $h^\\ast=h(T^\\dagger)$，其中 $T^\\dagger=800.2$ K。\n\n- 案例4：\n  - $T_{\\min}=300$ K, $T_{\\max}=1300$ K。\n  - $a=700$ J/(kg·K), $b=0.5$ J/(kg·K$^3$), $T_0=500$ K。\n  - $L=2.2\\times 10^5$ J/kg。\n  - $f_\\ell(T)=0.2\\,\\sigma\\!\\left(\\dfrac{T-600}{12}\\right)+0.5\\,\\sigma\\!\\left(\\dfrac{T-900}{25}\\right)+0.3\\,\\sigma\\!\\left(\\dfrac{T-1100}{15}\\right)$。\n  - 定义 $h^\\ast=h(T^\\dagger)$，其中 $T^\\dagger=1000$ K。\n\n- 案例5（下限测试）：\n  - 使用与案例2相同的参数。\n  - 定义 $h^\\ast=h(T_{\\min})-10^4$ J/kg。\n\n- 案例6（上限测试）：\n  - 使用与案例1相同的参数。\n  - 定义 $h^\\ast=h(T_{\\max})+10^4$ J/kg。\n\n最终输出格式。您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔的结果列表，例如 `[result1,result2,...,result6]`。每个温度都必须以开尔文为单位报告，精确到小数点后六位，并按案例1到6的顺序排列。", "solution": "我们从能量守恒和相变焓法中比焓的定义开始。对于一个温度为 $T$、液相分数为 $f_\\ell(T)$ 的一维材料单元，其单位质量比焓 $h(T)$ 的变化来自显热和潜热。显热贡献由比热容 $c_p(T)$ 的积分给出，潜热贡献为 $L\\,f_\\ell(T)$，其中 $L$ 是单位质量的熔化潜热。这就得到了本构定义\n$$\nh(T)=\\int_{T_{\\min}}^{T} c_p(\\theta)\\,\\mathrm{d}\\theta+L\\,f_\\ell(T),\n$$\n其中 $h(T_{\\min})=L\\,f_\\ell(T_{\\min})$。\n\n对于所选的参数形式 $c_p(T)=a+b\\,(T-T_0)^2$（其中 $a\\ge 0, b\\ge 0$），该积分存在精确的反导数，\n$$\n\\int_{T_{\\min}}^{T} c_p(\\theta)\\,\\mathrm{d}\\theta=a\\,(T-T_{\\min})+\\frac{b}{3}\\left[(T-T_0)^3-(T_{\\min}-T_0)^3\\right].\n$$\n因此，一旦给定 $a$、$b$、$T_0$、$L$ 以及液相分数分布 $f_\\ell(T)$，模型就被完全确定。液相分数定义为 logistic 阶跃的凸组合，\n$$\nf_\\ell(T)=\\sum_{i=1}^m w_i\\,\\sigma\\!\\left(\\frac{T-T_i}{s_i}\\right),\\quad \\sigma(x)=\\frac{1}{1+e^{-x}},\\quad \\sum_{i=1}^m w_i=1,\\quad s_i0,\n$$\n为了数值鲁棒性，可以选择性地将其钳位在 $[0,1]$ 区间内。$h(T)$ 的一阶导数为\n$$\n\\frac{\\mathrm{d}h}{\\mathrm{d}T}=c_p(T)+L\\,\\frac{\\mathrm{d}f_\\ell}{\\mathrm{d}T}.\n$$\n因为对于基于 logistic 函数的 $f_\\ell(T)$ 有 $c_p(T)\\ge a\\ge 0$ 和 $\\dfrac{\\mathrm{d}f_\\ell}{\\mathrm{d}T}\\ge 0$，所以我们有 $\\dfrac{\\mathrm{d}h}{\\mathrm{d}T}\\ge a\\ge 0$。在我们的测试套件中，所有案例均满足 $a0$，这保证了对于所有 $T\\in[T_{\\min},T_{\\max}]$ 都有 $\\dfrac{\\mathrm{d}h}{\\mathrm{d}T}0$。因此，$h(T)$ 是严格递增的，从而确保了逆函数 $T(h)$ 在 $[T_{\\min},T_{\\max}]$ 上的存在性和唯一性。尽管由于多重相变或依赖于温度的 $c_p(T)$，$h(T)$ 可能非凸（即存在 $\\dfrac{\\mathrm{d}^2 h}{\\mathrm{d}T^2}$ 符号改变的区域），但单调性足以保证鲁棒的求逆。\n\n为了对给定的 $h^\\ast$ 进行 $h(T)$ 的求逆，我们将问题重构为求解残差\n$$\ng(T)=h(T)-h^\\ast.\n$$\n的根。因为 $h(T)$ 在 $[T_{\\min},T_{\\max}]$ 上是连续且严格递增的，所以 $g(T)$ 也是连续且严格递增的，因此区间内的任何根都是唯一的。通过利用这种单调性的基于区间法的求根器，可以获得一个鲁棒的求逆程序：\n- 计算 $h_{\\min}=h(T_{\\min})$ 和 $h_{\\max}=h(T_{\\max})$。\n- 如果 $h^\\ast\\le h_{\\min}$，返回 $T_{\\min}$；如果 $h^\\ast\\ge h_{\\max}$，返回 $T_{\\max}$。\n- 否则，$g(T_{\\min})=h_{\\min}-h^\\ast0$ 并且 $g(T_{\\max})=h_{\\max}-h^\\ast0$，所以在 $(T_{\\min},T_{\\max})$ 内存在唯一的根。使用一种区间法，例如 Richard Brent 算法（该算法将二分法、割线法和逆二次插值与区间保障机制相结合）来寻找根。对于在区间端点函数值异号的连续函数，Brent 方法是全局收敛的，并且对非凸性不敏感。\n\n这种设计是基于原理的：它从焓的定义出发，通过证明 $h(T)$ 的单调性来保证可逆性。所选的数值方法确保了鲁棒性，而不依赖于局部凸性或导数。\n\n评估的算法细节：\n- 通过 logistic 定义来评估 $f_\\ell(T)$。为保证数值稳定性，对大的 $|x|$ 使用 $\\sigma(x)$ 的饱和处理（例如，将 $x\\le -40$ 视为 $\\sigma(x)\\approx 0$，将 $x\\ge 40$ 视为 $\\sigma(x)\\approx 1$），并在需要时将最终的 $f_\\ell(T)$ 钳位在 $[0,1]$ 区间内。\n- 使用二次多项式 $c_p(T)$ 精确计算显热积分，即\n$$\n\\int_{T_{\\min}}^{T} c_p(\\theta)\\,\\mathrm{d}\\theta=a\\,(T-T_{\\min})+\\frac{b}{3}\\left[(T-T_0)^3-(T_{\\min}-T_0)^3\\right].\n$$\n- 将显热和潜热贡献相加来计算 $h(T)$，并计算 $g(T)=h(T)-h^\\ast$。在 $[T_{\\min},T_{\\max}]$ 上应用基于区间法的求根器。\n- 将最终温度四舍五入到小数点后六位，并以开尔文报告。\n\n测试套件处理：\n- 案例1-4 为 $[T_{\\min},T_{\\max}]$ 内的一个指定 $T^\\dagger$ 定义了 $h^\\ast=h(T^\\dagger)$。根据严格单调性，求逆结果必须在数值容差范围内返回 $T=T^\\dagger$。\n- 案例5定义了一个下限压力测试 $h^\\ast=h(T_{\\min})-10^4$ J/kg，该测试必须返回 $T_{\\min}$。\n- 案例6定义了一个上限压力测试 $h^\\ast=h(T_{\\max})+10^4$ J/kg，该测试必须返回 $T_{\\max}$。\n\n最终程序构建每个案例，按规定计算相应的 $h^\\ast$，使用区间法执行求逆，并按要求打印单行输出，其中包含六个温度值（以开尔文为单位，每个都精确到六位小数），用方括号括起来并用逗号分隔。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import root_scalar\n\ndef sigmoid(x: float) -> float:\n    # Numerically stable logistic function with saturation.\n    if x = -40.0:\n        return 0.0\n    if x >= 40.0:\n        return 1.0\n    return 1.0 / (1.0 + np.exp(-x))\n\ndef liquid_fraction(T: float, fl_params):\n    # fl_params: list of tuples (w_i, T_i, s_i)\n    val = 0.0\n    for (w, Ti, si) in fl_params:\n        val += w * sigmoid((T - Ti) / si)\n    # Clamp to [0,1] to avoid any numerical overshoot.\n    if val  0.0:\n        val = 0.0\n    elif val > 1.0:\n        val = 1.0\n    return val\n\ndef sensible_integral(T: float, Tmin: float, a: float, b: float, T0: float) -> float:\n    # Exact integral of c_p(T) = a + b*(T - T0)^2 from Tmin to T\n    return a * (T - Tmin) + (b / 3.0) * ((T - T0) ** 3 - (Tmin - T0) ** 3)\n\ndef enthalpy(T: float, params: dict) -> float:\n    Tmin = params[\"Tmin\"]\n    a = params[\"a\"]\n    b = params[\"b\"]\n    T0 = params[\"T0\"]\n    L = params[\"L\"]\n    fl = params[\"fl\"]\n    h_sens = sensible_integral(T, Tmin, a, b, T0)\n    f = liquid_fraction(T, fl)\n    return h_sens + L * f\n\ndef invert_temperature(params: dict, h_star: float) -> float:\n    Tmin = params[\"Tmin\"]\n    Tmax = params[\"Tmax\"]\n\n    # Compute enthalpy at bounds\n    h_min = enthalpy(Tmin, params)\n    h_max = enthalpy(Tmax, params)\n\n    # Bound handling\n    if h_star = h_min:\n        return float(Tmin)\n    if h_star >= h_max:\n        return float(Tmax)\n\n    # Define residual g(T) = h(T) - h_star\n    def g(T):\n        return enthalpy(T, params) - h_star\n\n    # Brent's method on [Tmin, Tmax]\n    sol = root_scalar(g, bracket=[Tmin, Tmax], method=\"brentq\", xtol=1e-12, rtol=1e-12, maxiter=200)\n    if not sol.converged:\n        # As a last resort fallback, perform bisection manually\n        a_, b_ = Tmin, Tmax\n        fa, fb = g(a_), g(b_)\n        # Ensure bracketing exists (should be true due to checks above)\n        for _ in range(200):\n            m = 0.5 * (a_ + b_)\n            fm = g(m)\n            if fm == 0.0 or abs(b_ - a_)  1e-12:\n                return m\n            if np.sign(fm) == np.sign(fa):\n                a_, fa = m, fm\n            else:\n                b_, fb = m, fm\n        return 0.5 * (a_ + b_)\n    return float(sol.root)\n\ndef solve():\n    # Define the six test cases as per the problem statement.\n    # Each case is a dict with parameters for c_p, f_l, latent heat, and T bounds.\n    # For Cases 1-4 we define probe_T from which h_star is generated.\n    # For Cases 5-6 we define offsets relative to h(Tmin) and h(Tmax).\n    cases = []\n\n    # Case 1\n    cases.append({\n        \"Tmin\": 300.0, \"Tmax\": 1300.0,\n        \"a\": 900.0, \"b\": 0.0, \"T0\": 0.0,\n        \"L\": 2.5e5,\n        \"fl\": [(1.0, 900.0, 15.0)],\n        \"probe_T\": 920.0,\n        \"offset\": None\n    })\n\n    # Case 2\n    cases.append({\n        \"Tmin\": 300.0, \"Tmax\": 1400.0,\n        \"a\": 1000.0, \"b\": 0.0, \"T0\": 0.0,\n        \"L\": 3.0e5,\n        \"fl\": [(0.6, 700.0, 10.0), (0.4, 1000.0, 20.0)],\n        \"probe_T\": 950.0,\n        \"offset\": None\n    })\n\n    # Case 3\n    cases.append({\n        \"Tmin\": 300.0, \"Tmax\": 1200.0,\n        \"a\": 850.0, \"b\": 0.0, \"T0\": 0.0,\n        \"L\": 1.8e5,\n        \"fl\": [(1.0, 800.0, 0.8)],\n        \"probe_T\": 800.2,\n        \"offset\": None\n    })\n\n    # Case 4\n    cases.append({\n        \"Tmin\": 300.0, \"Tmax\": 1300.0,\n        \"a\": 700.0, \"b\": 0.5, \"T0\": 500.0,\n        \"L\": 2.2e5,\n        \"fl\": [(0.2, 600.0, 12.0), (0.5, 900.0, 25.0), (0.3, 1100.0, 15.0)],\n        \"probe_T\": 1000.0,\n        \"offset\": None\n    })\n\n    # Case 5 (lower-bound test) - same parameters as Case 2, offset below h(Tmin)\n    cases.append({\n        \"Tmin\": 300.0, \"Tmax\": 1400.0,\n        \"a\": 1000.0, \"b\": 0.0, \"T0\": 0.0,\n        \"L\": 3.0e5,\n        \"fl\": [(0.6, 700.0, 10.0), (0.4, 1000.0, 20.0)],\n        \"probe_T\": None,\n        \"offset\": (\"low\", 1.0e4)  # h_star = h(Tmin) - 1e4\n    })\n\n    # Case 6 (upper-bound test) - same parameters as Case 1, offset above h(Tmax)\n    cases.append({\n        \"Tmin\": 300.0, \"Tmax\": 1300.0,\n        \"a\": 900.0, \"b\": 0.0, \"T0\": 0.0,\n        \"L\": 2.5e5,\n        \"fl\": [(1.0, 900.0, 15.0)],\n        \"probe_T\": None,\n        \"offset\": (\"high\", 1.0e4)  # h_star = h(Tmax) + 1e4\n    })\n\n    results = []\n    for case in cases:\n        params = {\n            \"Tmin\": case[\"Tmin\"],\n            \"Tmax\": case[\"Tmax\"],\n            \"a\": case[\"a\"],\n            \"b\": case[\"b\"],\n            \"T0\": case[\"T0\"],\n            \"L\": case[\"L\"],\n            \"fl\": case[\"fl\"],\n        }\n        if case[\"probe_T\"] is not None:\n            # Construct h_star = h(T_dagger) for the given probe temperature\n            T_probe = case[\"probe_T\"]\n            h_star = enthalpy(T_probe, params)\n        else:\n            # Construct h_star from offset relative to boundary enthalpy\n            which, mag = case[\"offset\"]\n            if which == \"low\":\n                h_star = enthalpy(params[\"Tmin\"], params) - mag\n            elif which == \"high\":\n                h_star = enthalpy(params[\"Tmax\"], params) + mag\n            else:\n                raise ValueError(\"Unknown offset specifier.\")\n\n        T_inv = invert_temperature(params, h_star)\n        # Round to exactly 6 decimals for output\n        results.append(f\"{T_inv:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2482091"}]}