{"hands_on_practices": [{"introduction": "在多组分系统分析中，熟练地在质量和摩尔基准之间转换浓度是至关重要的第一步。本练习将引导你从第一性原理出发，推导和应用转换公式，从而巩固对混合物平均分子量和组分摩尔分数的计算。[@problem_id:2504316]", "problem": "一种混合均匀的非反应性三元气体混合物占据一个大的等温控制体积。纯组分的分子量由 $W = \\{16,\\,28,\\,44\\}\\,\\mathrm{g/mol}$ 给出，混合物的质量分数向量为 $Y = \\{0.2,\\,0.3,\\,0.5\\}$。严格从质量分数 $Y_i \\equiv m_i/m$、摩尔分数 $X_i \\equiv n_i/n$ 和混合物平均分子量 $\\bar{W} \\equiv m/n$ 的基本定义出发（其中 $m_i$ 是组分 $i$ 的质量，$m$ 是总质量，$n_i$ 是组分 $i$ 的摩尔数，$n$ 是总摩尔数），推导将 $\\bar{W}$ 和摩尔分数 $X_i$ 与已知集合 $\\{W_i\\}$ 和 $\\{Y_i\\}$ 联系起来的表达式。然后根据给定数据计算这些表达式的值。\n\n将混合物平均分子量的最终值以 $\\mathrm{g/mol}$ 为单位表示，并将摩尔分数表示为无量纲小数。将所有小数量四舍五入到五位有效数字。\n\n您最终报告的结果必须是 $\\big(\\bar{W},\\;X_1,\\;X_2,\\;X_3\\big)$ 形式的单行向量。", "solution": "问题陈述已经过验证，被认为是科学上合理、提法恰当且客观的。它提出了一个在基于质量和基于摩尔的浓度度量之间进行转换的标准练习，这对于传质学和化学热力学的研究至关重要。所有必要的数据和定义都已提供，不存在任何矛盾。给定质量分数的总和为 $\\sum_i Y_i = 0.2 + 0.3 + 0.5 = 1$，这是正确的。我们将继续进行推导和计算。\n\n任务是根据给定的质量分数 $Y_i$ 和组分分子量 $W_i$，推导混合物平均分子量 $\\bar{W}$ 和摩尔分数 $X_i$ 的表达式。我们必须严格从提供的基本定义出发。\n\n给定的定义是：\n1. 组分 $i$ 的质量分数：$Y_i \\equiv \\frac{m_i}{m}$\n2. 组分 $i$ 的摩尔分数：$X_i \\equiv \\frac{n_i}{n}$\n3. 混合物平均分子量：$\\bar{W} \\equiv \\frac{m}{n}$\n\n此处，$m_i$ 和 $n_i$ 分别是组分 $i$ 的质量和摩尔数，$m = \\sum_i m_i$ 和 $n = \\sum_i n_i$ 分别是混合物的总质量和总摩尔数。对于纯组分 $i$，其质量和摩尔数之间的关系由其分子量 $W_i$ 给出：\n$$m_i = n_i W_i \\quad \\implies \\quad n_i = \\frac{m_i}{W_i}$$\n\n首先，我们推导混合物平均分子量 $\\bar{W}$ 的表达式。我们从其定义 $\\bar{W} = m/n$ 开始。总摩尔数 $n$ 可以表示为各组分摩尔数之和：\n$$n = \\sum_i n_i = \\sum_i \\frac{m_i}{W_i}$$\n根据质量分数的定义，我们有 $m_i = Y_i m$。将此代入 $n$ 的表达式中：\n$$n = \\sum_i \\frac{Y_i m}{W_i} = m \\sum_i \\frac{Y_i}{W_i}$$\n现在，我们将这个 $n$ 的结果代回到 $\\bar{W}$ 的定义中：\n$$\\bar{W} = \\frac{m}{n} = \\frac{m}{m \\sum_{i} \\frac{Y_i}{W_i}}$$\n总质量 $m$ 被消去，得到用已知量表示的 $\\bar{W}$ 的最终表达式：\n$$\\bar{W} = \\frac{1}{\\sum_{i} \\frac{Y_i}{W_i}}$$\n\n接下来，我们推导摩尔分数 $X_i$ 的表达式。我们从定义 $X_i = n_i/n$ 开始。我们可以用质量和分子量来表示 $n_i$ 和 $n$：\n$$X_i = \\frac{m_i/W_i}{m/\\bar{W}}$$\n重新整理这个方程得到：\n$$X_i = \\left(\\frac{m_i}{m}\\right) \\frac{\\bar{W}}{W_i}$$\n认识到项 $(m_i/m)$ 正是质量分数 $Y_i$，我们得到所需的关系式：\n$$X_i = Y_i \\frac{\\bar{W}}{W_i}$$\n\n现在，我们对给定数据进行数值计算：\n组分分子量：$W_1 = 16\\,\\mathrm{g/mol}$，$W_2 = 28\\,\\mathrm{g/mol}$，$W_3 = 44\\,\\mathrm{g/mol}$。\n组分质量分数：$Y_1 = 0.2$，$Y_2 = 0.3$，$Y_3 = 0.5$。\n\n首先，我们计算 $\\bar{W}$。我们计算分母中的和：\n$$\\sum_{i} \\frac{Y_i}{W_i} = \\frac{0.2}{16} + \\frac{0.3}{28} + \\frac{0.5}{44}$$\n$$\\sum_{i} \\frac{Y_i}{W_i} = 0.0125 + 0.0107142857... + 0.0113636363... \\approx 0.034577922\\,\\mathrm{mol/g}$$\n混合物平均分子量是这个和的倒数：\n$$\\bar{W} = \\frac{1}{0.034577922...} \\approx 28.92018779\\,\\mathrm{g/mol}$$\n四舍五入到五位有效数字，我们得到：\n$$\\bar{W} \\approx 28.920\\,\\mathrm{g/mol}$$\n\n使用这个 $\\bar{W}$ 的值（在中间计算中使用更高精度以避免舍入误差），我们计算摩尔分数 $X_i$：\n对于组分1：\n$$X_1 = Y_1 \\frac{\\bar{W}}{W_1} = 0.2 \\times \\frac{28.92018779}{16} \\approx 0.361502347$$\n四舍五入到五位有效数字：$X_1 \\approx 0.36150$。\n\n对于组分2：\n$$X_2 = Y_2 \\frac{\\bar{W}}{W_2} = 0.3 \\times \\frac{28.92018779}{28} \\approx 0.309859154$$\n四舍五入到五位有效数字：$X_2 \\approx 0.30986$。\n\n对于组分3：\n$$X_3 = Y_3 \\frac{\\bar{W}}{W_3} = 0.5 \\times \\frac{28.92018779}{44} \\approx 0.328638497$$\n四舍五入到五位有效数字：$X_3 \\approx 0.32864$。\n\n作为一致性检验，摩尔分数的总和必须为1：\n$$\\sum_i X_i = 0.36150 + 0.30986 + 0.32864 = 1.00000$$\n结果是一致的。按要求四舍五入后的最终值被组合成指定的行向量格式。", "answer": "$$\\boxed{\\begin{pmatrix} 28.920 & 0.36150 & 0.30986 & 0.32864 \\end{pmatrix}}$$", "id": "2504316"}, {"introduction": "浓度梯度是驱动物质扩散的根本原因，而通量是量化这一过程的关键物理量。本练习将菲克扩散定律 (Fick's law) 与浓度概念相结合，展示了如何利用摩尔分数梯度来计算稳态扩散过程中的摩尔通量，并进一步将其转换为质量通量，从而将抽象的浓度单位与可测量的输运速率联系起来。[@problem_id:2504222]", "problem": "一种由氧气（组分 $1$）和氮气（组分 $2$）组成的二元理想气体混合物，被置于两个相距 $L = 0.01\\,\\mathrm{m}$ 的平行、等温、等压平面之间。该系统处于均匀压力 $p = 1.00\\times 10^{5}\\,\\mathrm{Pa}$ 和温度 $T = 300\\,\\mathrm{K}$ 下。二元扩散系数为恒定值 $D_{12} = 2.00\\times 10^{-5}\\,\\mathrm{m^2/s}$。氧气的摩尔分数从 $z = 0$ 处的 $X_1 = 0.10$ 线性变化到 $z = L$ 处的 $X_1 = 0.30$。假设系统为一维稳态，无化学反应，无宏观摩尔对流（即等摩尔反向扩散，使得 $N_1 + N_2 = 0$）。氧气的摩尔质量为 $M_1 = 32.00\\times 10^{-3}\\,\\mathrm{kg/mol}$。取普适气体常数为 $R = 8.314462618\\,\\mathrm{J/(mol\\cdot K)}$。\n\n仅使用基本输运定义和理想气体定律，确定：\n- 氧气的有符号稳态摩尔通量 $N_1$（单位为 $\\mathrm{mol\\,m^{-2}\\,s^{-1}}$），其中 $z$ 轴方向从 $X_1=0.10$ 的平面指向 $X_1=0.30$ 的平面，\n- 以及相应的氧气有符号质量通量 $j_1$（单位为 $\\mathrm{kg\\,m^{-2}\\,s^{-1}}$）。\n\n将摩尔通量以 $\\mathrm{mol\\,m^{-2}\\,s^{-1}}$ 为单位表示，质量通量以 $\\mathrm{kg\\,m^{-2}\\,s^{-1}}$ 为单位表示。将每个值四舍五入至四位有效数字。你的最终答案必须仅包含这两个数字，按 $\\left(N_1,\\; j_1\\right)$ 的顺序排列，并作为与所述 $z$ 轴方向一致的有符号量报告。", "solution": "该问题陈述已经过严格验证，被认为是科学上合理、提法得当且客观的。它提出了一个基于基本原理的可解的传质问题。因此，我们可以开始求解。\n\n问题要求在特定条件下，确定氧气（组分 $1$）在与氮气（组分 $2$）的二元混合物中的稳态摩尔通量 $N_1$ 和质量通量 $j_1$。分析始于二元混合物中组分摩尔通量的通用表达式，该表达式结合了菲克扩散和对流：\n$$N_1 = -C D_{12} \\frac{dX_1}{dz} + X_1(N_1 + N_2)$$\n其中 $N_1$ 是组分 $1$ 的摩尔通量，$C$ 是混合物的总摩尔浓度，$D_{12}$ 是二元扩散系数，$X_1$ 是组分 $1$ 的摩尔分数，$z$ 是空间坐标，$N_2$ 是组分 $2$ 的摩尔通量。\n\n问题明确指出了等摩尔反向扩散的条件，即没有净摩尔通量：\n$$N_1 + N_2 = 0$$\n这个条件通过消除对流项来简化通用通量方程，将其简化为菲克第一扩散定律：\n$$N_1 = -C D_{12} \\frac{dX_1}{dz}$$\n为了求解 $N_1$，我们必须确定总摩尔浓度 $C$ 和摩尔分数梯度 $\\frac{dX_1}{dz}$。\n\n该混合物被视为理想气体。理想气体混合物的总摩尔浓度 $C$ 由理想气体定律给出：\n$$C = \\frac{p}{RT}$$\n其中 $p$ 是绝对压力，$R$ 是普适气体常数，$T$ 是绝对温度。代入给定值：\n$$p = 1.00 \\times 10^5\\,\\mathrm{Pa}$$\n$$R = 8.314462618\\,\\mathrm{J/(mol\\cdot K)}$$\n$$T = 300\\,\\mathrm{K}$$\n总摩尔浓度为：\n$$C = \\frac{1.00 \\times 10^5}{8.314462618 \\times 300} \\approx 40.088\\,\\mathrm{mol/m^3}$$\n\n问题指出，氧气的摩尔分数 $X_1$ 随位置 $z$ 从 $X_1(z=0) = 0.10$ 线性变化到 $X_1(z=L) = 0.30$，其中 $L = 0.01\\,\\mathrm{m}$。对于线性分布，梯度 $\\frac{dX_1}{dz}$ 是一个常数，可以作为有限差分计算：\n$$\\frac{dX_1}{dz} = \\frac{X_1(L) - X_1(0)}{L - 0} = \\frac{0.30 - 0.10}{0.01\\,\\mathrm{m}} = \\frac{0.20}{0.01\\,\\mathrm{m}} = 20\\,\\mathrm{m^{-1}}$$\n梯度的正号证实了组分 $1$ 的浓度沿着问题中定义的 z 轴正方向增加。\n\n现在，$N_1$ 的通量方程的所有分量都已确定。我们将 $C$、$D_{12}$ 和 $\\frac{dX_1}{dz}$ 的值代入简化后的菲克定律方程。\n已知 $D_{12} = 2.00 \\times 10^{-5}\\,\\mathrm{m^2/s}$，摩尔通量 $N_1$ 为：\n$$N_1 = -\\left(\\frac{p}{RT}\\right) D_{12} \\frac{dX_1}{dz} = -\\left(\\frac{1.00 \\times 10^5}{8.314462618 \\times 300}\\right) \\times (2.00 \\times 10^{-5}) \\times (20)$$\n$$N_1 \\approx -(40.08839) \\times (2.00 \\times 10^{-5}) \\times (20) \\approx -0.016035\\,\\mathrm{mol\\,m^{-2}\\,s^{-1}}$$\n负号表示氧气的净扩散发生在浓度降低的方向上，即从 $z=L$ 到 $z=0$ 的方向，也就是 z 轴负方向。四舍五入到四位有效数字，摩尔通量为：\n$$N_1 \\approx -1.604 \\times 10^{-2}\\,\\mathrm{mol\\,m^{-2}\\,s^{-1}}$$\n\n接下来，我们计算相应的氧气质量通量 $j_1$。质量通量通过组分的摩尔质量 $M_1$ 与摩尔通量相关联：\n$$j_1 = N_1 \\cdot M_1$$\n已知氧气的摩尔质量为 $M_1 = 32.00 \\times 10^{-3}\\,\\mathrm{kg/mol}$，我们得到：\n$$j_1 = (-0.016035356...) \\times (32.00 \\times 10^{-3}) \\approx -0.00051313\\,\\mathrm{kg\\,m^{-2}\\,s^{-1}}$$\n质量通量的符号与摩尔通量的符号相同，表明传质发生在 z 轴负方向。四舍五入到四位有效数字，质量通量为：\n$$j_1 \\approx -5.131 \\times 10^{-4}\\,\\mathrm{kg\\,m^{-2}\\,s^{-1}}$$\n解答完毕。所求的量已根据基本原理和提供的数据确定。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n-1.604 \\times 10^{-2} & -5.131 \\times 10^{-4}\n\\end{pmatrix}\n}\n$$", "id": "2504222"}, {"introduction": "理论上完美的公式在实际的数值计算中可能因为舍入误差而失效，导致非物理的结果。本练习揭示了一个在浓度基准转换中常见的数值陷阱：一个看似无害的舍入步骤如何导致计算出的质量分数为负值。你将通过编程实践，实现并对比一个“朴素”算法和一个经过修正的、能保证结果物理有效性的稳健算法。[@problem_id:2504315]", "problem": "给定多组分系统中组分测度的基本定义。对于包含 $m$ 种物质的混合物，其摩尔分数为 $X_i$，分子量为 $W_i$（对所有 $i$ 都有 $W_i > 0$），混合物平均分子量的定义为\n$$\n\\bar{W} \\equiv \\sum_{i=1}^m X_i W_i,\n$$\n质量分数 $Y_i$ 的定义为\n$$\nY_i \\equiv \\frac{X_i W_i}{\\bar{W}}.\n$$\n反之，给定质量分数 $Y_i$ 和分子量 $W_i$，摩尔分数的计算公式为\n$$\nX_i \\equiv \\frac{Y_i/W_i}{\\sum_{j=1}^m Y_j/W_j}.\n$$\n$\\{X_i\\}$ 和 $\\{Y_i\\}$ 都必须满足对所有 $i$ 都有 $X_i \\ge 0$，$Y_i \\ge 0$，并且 $\\sum_i X_i = \\sum_i Y_i = 1$。\n\n一个将摩尔分数 $\\{X_i\\}$ 转换为质量分数 $\\{Y_i\\}$ 的朴素实现有时会采用以下步骤，其动机可能是定点数格式或减少计算量的尝试：\n- 计算 $\\bar{W}$。\n- 将 $\\bar{W}$ 四舍五入到 $p$ 位有效数字，得到 $\\widehat{\\bar{W}}$。\n- 对所有 $i$ 计算 $\\widehat{Y}_i \\leftarrow \\frac{X_i W_i}{\\widehat{\\bar{W}}}$。\n- 对 $i=1,\\dots,m-1$，将每个 $\\widehat{Y}_i$ 四舍五入到 $q$ 位小数。\n- 通过将最后一个组分设置为余数来强制满足求和约束：$\\widehat{Y}_m \\leftarrow 1 - \\sum_{i=1}^{m-1} \\widehat{Y}_i$（不再进行四舍五入）。\n\n不幸的是，由于对 $\\bar{W}$ 的四舍五入，即使输入 $\\{X_i\\}$ 完全有效，这个朴素的流程也可能产生 $\\widehat{Y}_m < 0$。\n\n任务：\n1. 从上述定义和逻辑出发，推导为什么将 $\\bar{W}$ 四舍五入到一个比真实值 $\\bar{W}$ 更小的值会乘性地放大所有计算出的 $\\widehat{Y}_i$，并且当与前 $m-1$ 个组分的独立四舍五入以及最后一个组分的余数规则相结合时，会迫使 $\\widehat{Y}_m$ 变为负数。\n2. 提出并实现一个保正修复方法，以避免这种病态问题，同时仍然允许四舍五入到 $q$ 位小数。你的修复方法必须从第一性原理推导得出，并且必须确保非负性和总和精确为一。一种数学上可靠的方法是：\n   - 首先以全精度计算未舍入的分子 $\\tilde{Y}_i \\equiv X_i W_i$，然后对其进行归一化以获得 $Y_i^\\ast \\equiv \\tilde{Y}_i / \\sum_{j=1}^m \\tilde{Y}_j$。\n   - 将 $Y_i^\\ast$ 独立地四舍五入到 $q$ 位小数，得到一个向量 $v$。\n   - 使用欧几里得投影将 $v$ 投影到概率单纯形 $\\Delta \\equiv \\{ y \\in \\mathbb{R}^m \\mid \\sum_{i=1}^m y_i = 1,\\ y_i \\ge 0\\}$ 上，得到满足约束条件的 $Y^{\\mathrm{fix}}$（通过构造满足）。\n   - 你必须描述所使用的投影算子。\n\n实现要求：\n- 编写一个程序，实现两个转换器：\n  - 一个朴素转换器 $\\mathcal{C}_{\\mathrm{naive}}(X,W,p,q)$，实现上述流程（将 $\\bar{W}$ 四舍五入到 $p$ 位有效数字，计算并四舍五入前 $m-1$ 个质量分数到 $q$ 位小数，并将最后一个设置为余数）。\n  - 一个修复后的转换器 $\\mathcal{C}_{\\mathrm{fix}}(X,W,q)$，实现对 $\\tilde{Y}_i \\equiv X_i W_i$ 的归一化以及将四舍五入到 $q$ 位小数的向量在 $\\Delta$ 上的欧几里得投影。\n- 对于每个测试用例，你的程序必须按顺序报告：一个整数，指示朴素转换的结果中是否有任何分量为负（若有任何 $\\widehat{Y}_i < 0$ 则为 $1$，否则为 $0$）；一个整数，对修复后的转换指示相同的情况；朴素转换结果的最小分量值；以及修复后转换结果的最小分量值。\n\n测试套件：\n- 使用以下测试用例。在所有情况下，根据定义\n$$\nX_i \\equiv \\frac{Y_i^{\\mathrm{target}}/W_i}{\\sum_{j=1}^m Y_j^{\\mathrm{target}}/W_j}.\n$$\n从提供的目标质量分数 $Y_i^{\\mathrm{target}}$ 和分子量 $W_i$ 计算摩尔分数 $X_i$。然后将这两个转换器应用于这些 $X_i$ 和 $W_i$ 以及指定的 $p$ 和 $q$。\n\n令 $m$ 表示每种情况下的物质种类数。\n\n- 案例 A（预期朴素方法会失败的反例）：\n  - 分子量：$W = [90,\\ 110,\\ 120,\\ 300]$。\n  - 目标质量分数：$Y^{\\mathrm{target}} = \\left[\\frac{1 - \\varepsilon}{3},\\ \\frac{1 - \\varepsilon}{3},\\ \\frac{1 - \\varepsilon}{3},\\ \\varepsilon\\right]$，其中 $\\varepsilon = 10^{-4}$。\n  - 舍入参数：$\\bar{W}$ 取 $p=1$ 位有效数字，质量分数取 $q=2$ 位小数。\n\n- 案例 B（高精度舍入；预期朴素方法安全）：\n  - 分子量：$W = [90,\\ 110,\\ 120,\\ 300]$。\n  - 目标质量分数：$Y^{\\mathrm{target}} = \\left[\\frac{1 - \\varepsilon}{3},\\ \\frac{1 - \\varepsilon}{3},\\ \\frac{1 - \\varepsilon}{3},\\ \\varepsilon\\right]$，其中 $\\varepsilon = 10^{-4}$。\n  - 舍入参数：$\\bar{W}$ 取 $p=5$ 位有效数字，质量分数取 $q=4$ 位小数。\n\n- 案例 C（典型气体混合物；预期朴素方法安全）：\n  - 分子量：$W = [2.016,\\ 28.014,\\ 31.998,\\ 44.01]$。\n  - 目标质量分数：$Y^{\\mathrm{target}} = [0.7,\\ 0.1,\\ 0.1,\\ 0.1]$。\n  - 舍入参数：$\\bar{W}$ 取 $p=1$ 位有效数字，质量分数取 $q=2$ 位小数。\n\n输出规范：\n- 你的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表。每个测试用例必须贡献一个包含四个数字的子列表，顺序为：$\\left[\\text{neg\\_naive},\\ \\text{neg\\_fix},\\ \\min(\\widehat{Y}),\\ \\min(Y^{\\mathrm{fix}})\\right]$。前两项使用整数，后两项使用实数。最后一行必须是\n$$\n[\\ [a_1,b_1,c_1,d_1],\\ [a_2,b_2,c_2,d_2],\\ [a_3,b_3,c_3,d_3]\\ ]\n$$\n的形式，不得有任何附加文本。", "solution": "问题陈述经过严格审查，被认为是有效的。它在科学上基于质量浓度和摩尔浓度的原理，定义和目标清晰，问题阐述良好，并且没有歧义或矛盾。因此，我们可以进行完整的解答。\n\n任务有两部分：首先，对一个将摩尔分数转换为质量分数的朴素数值算法进行理论分析，该算法可能产生不符合物理实际的负值结果；其次，提出、推导并实现一个鲁棒的算法来纠正这种病态问题。\n\n**第一部分：朴素转换算法失效模式分析**\n\n所给出的定义是标准的。对于一个包含 $m$ 种物质，摩尔分数为 $\\{X_i\\}_{i=1}^m$，分子量为 $\\{W_i\\}_{i=1}^m$ 的混合物，其真实平均分子量为 $\\bar{W} = \\sum_{i=1}^m X_i W_i$。真实的质量分数由 $Y_i = \\frac{X_i W_i}{\\bar{W}}$ 给出。根据定义，这些真实的质量分数是非负的（因为 $X_i \\ge 0$ 且 $W_i > 0$，所以 $Y_i \\ge 0$）并且总和为一（$\\sum_{i=1}^m Y_i = \\frac{\\sum_{i=1}^m X_i W_i}{\\bar{W}} = \\frac{\\bar{W}}{\\bar{W}} = 1$）。\n\n这个朴素算法引入了几个破坏这些性质的舍入步骤。我们来分析其执行序列：\n1.  计算真实的平均分子量 $\\bar{W}$，然后将其四舍五入到 $p$ 位有效数字，得到 $\\widehat{\\bar{W}}$。\n2.  使用这个经过舍入的分母计算中间质量分数，我们记为 $\\widehat{Y}_i'$：$\\widehat{Y}_i' = \\frac{X_i W_i}{\\widehat{\\bar{W}}}$。\n3.  前 $m-1$ 个最终分量 $\\widehat{Y}_i$（对于 $i=1, \\dots, m-1$）是通过将 $\\widehat{Y}_i'$ 四舍五入到 $q$ 位小数得到的。\n4.  最后一个分量 $\\widehat{Y}_m$ 作为余数计算得出：$\\widehat{Y}_m = 1 - \\sum_{i=1}^{m-1} \\widehat{Y}_i$。\n\n关键缺陷源于第一步。让我们将中间分数 $\\widehat{Y}_i'$ 与真实分数 $Y_i$ 联系起来：\n$$\n\\widehat{Y}_i' = \\frac{X_i W_i}{\\widehat{\\bar{W}}} = \\left(\\frac{X_i W_i}{\\bar{W}}\\right) \\left(\\frac{\\bar{W}}{\\widehat{\\bar{W}}}\\right) = Y_i \\left(\\frac{\\bar{W}}{\\widehat{\\bar{W}}}\\right)\n$$\n这个方程揭示了中间分数 $\\widehat{Y}_i'$ 是真实分数 $Y_i$ 乘以一个公共的乘法因子 $k = \\frac{\\bar{W}}{\\widehat{\\bar{W}}}$。\n\n问题中描述的病态问题特别在 $\\bar{W}$ 被向下舍入时出现，即 $\\widehat{\\bar{W}} < \\bar{W}$。在这种情况下，缩放因子 $k$ 大于 1。因此，每个中间质量分数 $\\widehat{Y}_i'$ 相对于其真实值 $Y_i$ 都被系统性地放大了。\n\n这些被放大的中间分数的总和是：\n$$\n\\sum_{i=1}^m \\widehat{Y}_i' = \\sum_{i=1}^m Y_i \\left(\\frac{\\bar{W}}{\\widehat{\\bar{W}}}\\right) = \\left(\\frac{\\bar{W}}{\\widehat{\\bar{W}}}\\right) \\sum_{i=1}^m Y_i = \\frac{\\bar{W}}{\\widehat{\\bar{W}}} > 1\n$$\n因此，前 $m-1$ 个被放大的分量的总和是 $\\sum_{i=1}^{m-1} \\widehat{Y}_i' = (\\frac{\\bar{W}}{\\widehat{\\bar{W}}}) \\sum_{i=1}^{m-1} Y_i = (\\frac{\\bar{W}}{\\widehat{\\bar{W}}})(1 - Y_m)$。\n\n然后，算法将这前 $m-1$ 个被放大的值 $\\widehat{Y}_i'$（对于 $i=1, \\dots, m-1$）四舍五入到 $q$ 位小数。我们将此操作表示为 $\\text{round}(\\cdot, q)$。用于计算余数的总和是 $S_{m-1} = \\sum_{i=1}^{m-1} \\text{round}(\\widehat{Y}_i', q)$。\n\n最后一个分量是 $\\widehat{Y}_m = 1 - S_{m-1}$。当且仅当 $S_{m-1} > 1$ 时，$\\widehat{Y}_m$ 会出现负值。\n\n当满足两个条件时，这种情况最有可能发生：\n1.  放大因子 $k = \\bar{W}/\\widehat{\\bar{W}}$ 显著大于 1。\n2.  最后一个组分的真实质量分数 $Y_m$ 非常小。\n\n如果 $Y_m$ 很小（例如 $Y_m \\ll 1$），那么 $\\sum_{i=1}^{m-1} Y_i = 1 - Y_m$ 就非常接近 1。被放大的中间分量的总和 $\\sum_{i=1}^{m-1} \\widehat{Y}_i'$ 约等于 $k = \\bar{W}/\\widehat{\\bar{W}}$，这个值大于 1。随后的到 $q$ 位小数的舍入操作作用于每个被放大的项。虽然舍入可以增加或减少一个值，但如果 $\\widehat{Y}_i'$ 的值被充分放大，其总和 $S_{m-1}$ 很可能仍大于 1。例如，如果舍入操作对被放大的值平均倾向于向上取整，那么总和将被推得更远，超过 1。这迫使 $\\widehat{Y}_m = 1 - S_{m-1}$ 变为负值，这是一个不符合物理实际的结果。\n\n**第二部分：一个鲁棒的、保正的解决方案**\n\n一个鲁棒的算法必须在数学上保证最终的质量分数 $\\{Y_i^{\\mathrm{fix}}\\}$ 满足约束条件：对所有 $i$ 都有 $Y_i^{\\mathrm{fix}} \\ge 0$ 并且 $\\sum_{i=1}^m Y_i^{\\mathrm{fix}} = 1$。朴素方法之所以失败，是因为它在最后一步孤立地强制执行求和约束，而此时各分量已经受到多个、不协调的舍入操作的扰动。一种有原则的方法是协同地强制执行约束。\n\n所提出并实现的修复方法遵循以下步骤：\n1.  **计算未舍入的分子：**首先，我们使用完整的机器精度计算质量分数公式的分子 $\\tilde{Y}_i = X_i W_i$。这些值与每种物质的质量成正比。\n2.  **归一化为精确质量分数：**我们通过归一化这些分子来计算精确的质量分数 $Y_i^\\ast$：\n    $$\n    Y_i^\\ast = \\frac{\\tilde{Y}_i}{\\sum_{j=1}^m \\tilde{Y}_j}\n    $$\n    通过构造，这个精确质量分数向量 $Y^\\ast$ 满足 $Y_i^\\ast \\ge 0$ 和 $\\sum_i Y_i^\\ast = 1$。这避免了对 $\\bar{W}$ 的过早舍入及其相关的放大误差。\n3.  **应用舍入：**现在将所需的到 $q$ 位小数的舍入应用于正确的质量分数：$v_i = \\text{round}(Y_i^\\ast, q)$。得到的向量 $v$ 具有所需的精度，但不再保证总和为 1。然而，其分量保持非负。\n4.  **投影到概率单纯形：**为了在保持非负性的同时恢复求和约束，并尽可能接近舍入后的值 $v_i$，我们将向量 $v$ 投影到标准概率单纯形 $\\Delta^m = \\{ y \\in \\mathbb{R}^m \\mid \\sum_{i=1}^m y_i = 1, y_i \\ge 0 \\}$ 上。这是一个定义明确的数学运算，它能找到唯一的向量 $Y^{\\mathrm{fix}} \\in \\Delta^m$ 来最小化欧几里得距离 $\\| Y^{\\mathrm{fix}} - v \\|_2$。这个二次规划问题的解可以被高效地找到。该投影算子的算法描述如下：\n    a. 将向量 $v$ 的分量按降序排序，得到一个新向量 $u$，其中 $u_1 \\ge u_2 \\ge \\dots \\ge u_m$。\n    b. 找到整数 $\\rho$，它是满足以下条件的最大索引 $j \\in \\{1, \\dots, m\\}$：\n    $$\n    u_j - \\frac{1}{j}\\left(\\sum_{k=1}^j u_k - 1\\right) > 0\n    $$\n    c. 使用这个 $\\rho$ 值定义一个阈值 $\\lambda$：\n    $$\n    \\lambda = \\frac{1}{\\rho}\\left(\\sum_{k=1}^\\rho u_k - 1\\right)\n    $$\n    d. 然后通过对原始向量 $v$ 进行软阈值操作来获得投影向量 $Y^{\\mathrm{fix}}$ 的分量：\n    $$\n    Y_i^{\\mathrm{fix}} = \\max(v_i - \\lambda, 0)\n    $$\n此过程保证了得到的向量 $Y^{\\mathrm{fix}}$ 是单纯形上离 $v$ 最近的唯一一个点，因此通过构造满足 $Y_i^{\\mathrm{fix}} \\ge 0$ 和 $\\sum_i Y_i^{\\mathrm{fix}} = 1$。该方法是鲁棒的，因为它将舍入视为一种扰动，并系统地寻找最佳的有效表示。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef round_sig(x, p):\n    \"\"\"\n    Rounds a number x to p significant digits.\n    \"\"\"\n    if x == 0:\n        return 0.0\n    if p = 0:\n        raise ValueError(\"Number of significant digits must be positive.\")\n    \n    # Calculate the number of decimal places needed for rounding\n    # based on the magnitude of x.\n    num_decimals = p - int(math.floor(math.log10(abs(x)))) - 1\n    return round(x, num_decimals)\n\ndef naive_converter(X, W, p, q):\n    \"\"\"\n    Implements the naive conversion pipeline from mole fractions to mass fractions.\n    \n    Args:\n        X (np.ndarray): Mole fractions.\n        W (np.ndarray): Molecular weights.\n        p (int): Number of significant digits to round the mean molecular weight.\n        q (int): Number of decimal places to round the mass fractions.\n    \n    Returns:\n        np.ndarray: Computed mass fractions, possibly with negative components.\n    \"\"\"\n    m = len(X)\n    \n    # 1. Compute true mean molecular weight\n    W_bar_true = np.sum(X * W)\n    \n    # 2. Round W_bar_true to p significant digits\n    W_bar_hat = round_sig(W_bar_true, p)\n    \n    # 3. Compute intermediate mass fractions\n    Y_hat_unrounded = (X * W) / W_bar_hat\n    \n    Y_hat = np.zeros(m)\n    \n    # 4. Round first m-1 components\n    for i in range(m - 1):\n        Y_hat[i] = round(Y_hat_unrounded[i], q)\n        \n    # 5. Enforce summation constraint for the last component\n    Y_hat[m - 1] = 1.0 - np.sum(Y_hat[:m - 1])\n    \n    return Y_hat\n\ndef fixed_converter(X, W, q):\n    \"\"\"\n    Implements the robust conversion using normalization and projection onto the simplex.\n    \n    Args:\n        X (np.ndarray): Mole fractions.\n        W (np.ndarray): Molecular weights.\n        q (int): Number of decimal places to round the mass fractions.\n        \n    Returns:\n        np.ndarray: Positivity- and sum-preserving mass fractions.\n    \"\"\"\n    # 1. Compute unrounded numerators\n    Y_tilde = X * W\n    \n    # 2. Normalize to get exact mass fractions\n    sum_Y_tilde = np.sum(Y_tilde)\n    if sum_Y_tilde == 0:\n        return np.ones_like(X) / len(X) # Handle case of all-zero input\n    Y_star = Y_tilde / sum_Y_tilde\n    \n    # 3. Apply rounding\n    v = np.round(Y_star, q)\n    \n    # 4. Project v onto the probability simplex\n    \n    # Check if a projection is needed\n    if abs(np.sum(v) - 1.0)  1e-9 and np.all(v >= 0):  # Use tolerance for float comparison\n        return v\n\n    m = len(v)\n    # Sort v in descending order\n    u = np.sort(v)[::-1]\n    \n    # Compute cumulative sum of sorted values\n    cssv = np.cumsum(u)\n    \n    # Find rho: the largest j such that u_j - (1/j)(sum(u_k) - 1) > 0\n    indices = np.arange(1, m + 1)\n    condition = u - (cssv - 1) / indices > 0\n    \n    # np.where returns a tuple of arrays; we get the last index where condition is True\n    rho = np.where(condition)[0][-1] + 1\n    \n    # Compute lambda\n    lambda_ = (cssv[rho - 1] - 1) / rho\n    \n    # Compute the projection\n    Y_fix = np.maximum(v - lambda_, 0)\n    \n    return Y_fix\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and print results.\n    \"\"\"\n    epsilon = 1e-4\n    test_cases = [\n        {\n            \"name\": \"Case A\",\n            \"W\": np.array([90.0, 110.0, 120.0, 300.0]),\n            \"Y_target\": np.array([(1 - epsilon) / 3, (1 - epsilon) / 3, (1 - epsilon) / 3, epsilon]),\n            \"p\": 1,\n            \"q\": 2\n        },\n        {\n            \"name\": \"Case B\",\n            \"W\": np.array([90.0, 110.0, 120.0, 300.0]),\n            \"Y_target\": np.array([(1 - epsilon) / 3, (1 - epsilon) / 3, (1 - epsilon) / 3, epsilon]),\n            \"p\": 5,\n            \"q\": 4\n        },\n        {\n            \"name\": \"Case C\",\n            \"W\": np.array([2.016, 28.014, 31.998, 44.01]),\n            \"Y_target\": np.array([0.7, 0.1, 0.1, 0.1]),\n            \"p\": 1,\n            \"q\": 2\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        W = case[\"W\"]\n        Y_target = case[\"Y_target\"]\n        p = case[\"p\"]\n        q = case[\"q\"]\n        \n        # Calculate input mole fractions X from target mass fractions Y_target\n        Y_over_W = Y_target / W\n        sum_Y_over_W = np.sum(Y_over_W)\n        X = Y_over_W / sum_Y_over_W\n\n        # Run naive converter\n        Y_naive = naive_converter(X, W, p, q)\n        neg_naive = 1 if np.any(Y_naive  0) else 0\n        min_naive = np.min(Y_naive)\n\n        # Run fixed converter\n        Y_fix = fixed_converter(X, W, q)\n        neg_fix = 1 if np.any(Y_fix  0) else 0\n        min_fix = np.min(Y_fix)\n        \n        # Ensure correct formatting for the minimum values\n        # The projection might result in exact zeros, don't use scientific notation for that.\n        min_n_str = f\"{min_naive:.10f}\".rstrip('0').rstrip('.') if not np.isclose(min_naive, 0) else \"0.0\"\n        min_f_str = f\"{min_fix:.10f}\".rstrip('0').rstrip('.') if not np.isclose(min_fix, 0) else \"0.0\"\n\n        # The problem asks for real numbers, so standard float representation is fine.\n        all_results.append(f\"[{neg_naive},{neg_fix},{min_naive},{min_fix}]\")\n\n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n```", "id": "2504315"}]}