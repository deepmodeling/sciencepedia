{"hands_on_practices": [{"introduction": "在应用任何物理定律之前，确保其量纲一致性是至关重要的第一步。本练习将引导你通过量纲分析，推导Paris定律中材料常数 $C$ 的物理单位，揭示其单位如何依赖于指数 $m$。这个基础练习有助于加深对Paris定律方程结构的理解，并避免在工程计算中出现单位错误。[@problem_id:2885911]", "problem": "一个金属结构试件在循环加载下经历疲劳，其每循环裂纹扩展速率由一个与 I 型应力强度因子范围相关的幂律关系所决定。设 $a$ 表示裂纹长度，单位为米，I 型应力强度因子范围 $\\Delta K$ 的单位为兆帕斯卡-米平方根，即 $\\Delta K$ 的单位为 $\\text{MPa}\\sqrt{\\text{m}}$，其中兆帕斯卡（MPa）等于 $10^{6}$ 帕斯卡（Pa）。每循环裂纹扩展速率 $da/d(\\text{cycle})$ 与 $(\\Delta K)^{m}$ 成正比，比例常数 $C$ 未知，且取决于材料和环境。\n\n假设使用国际单位制（SI）基本单位：千克（kg）、米（m）和秒（s），并视“循环”为无量纲计数（为了清晰起见，您可以明确地跟踪“每循环”，但它不引入 SI 基本量纲）。\n\n使用量纲分析，并从应力单位为压力（帕斯卡），$1\\,\\text{Pa} = 1\\,\\text{kg}\\,\\text{m}^{-1}\\,\\text{s}^{-2}$，以及 I 型应力强度因子量纲的定义 $[\\Delta K] = [\\text{stress}]\\,[\\text{length}]^{1/2}$ 出发，确定比例常数 $C$ 必须具有的物理单位，以使该关系对于任意实数指数 $m$ 都是量纲一致的。\n\n将您的最终答案表示为 $C$ 的 SI 基本单位 $(\\text{kg}, \\text{m}, \\text{s})$ 的指数行向量，该向量是 $m$ 的函数，并按此顺序排列。例如，形式为 $\\text{kg}^{\\alpha}\\,\\text{m}^{\\beta}\\,\\text{s}^{\\gamma}$ 的答案应按指定顺序报告为单行向量 $(\\alpha, \\beta, \\gamma)$。无需进行数值计算。", "solution": "任务是根据量纲一致性的要求确定比例常数 $C$ 的单位。所考虑的裂纹扩展定律指出，每循环的裂纹扩展速率与 I 型应力强度因子范围的幂成正比。将比例常数表示为 $C$，指数表示为 $m$。每循环的速率为 $da/d(\\text{cycle})$，其中 $a$ 的单位是长度。\n\n我们使用国际单位制（SI）基本单位千克（kg）、米（m）和秒（s）进行量纲分析，并利用以下基本事实：\n- 应力是压力，单位为 $[\\text{stress}] = [\\text{Pa}] = \\text{kg}\\,\\text{m}^{-1}\\,\\text{s}^{-2}$。\n- I 型应力强度因子 $K$ 的量纲为 $[\\text{stress}]\\,[\\text{length}]^{1/2}$，因此 $[K] = \\text{kg}\\,\\text{m}^{-1}\\,\\text{s}^{-2}\\cdot \\text{m}^{1/2} = \\text{kg}\\,\\text{m}^{-1/2}\\,\\text{s}^{-2}$。\n- 范围 $\\Delta K$ 与 $K$ 具有相同的量纲，所以 $[\\Delta K] = \\text{kg}\\,\\text{m}^{-1/2}\\,\\text{s}^{-2}$。以兆帕斯卡-米平方根（$\\text{MPa}\\sqrt{\\text{m}}$）报告 $K$ 或 $\\Delta K$ 不会改变其相对于帕斯卡的量纲，因为连接 MPa 和 Pa 的因子 $10^{6}$ 是无量纲的；它只改变数值大小。\n\n每循环的裂纹扩展速率 $da/d(\\text{cycle})$ 的单位是长度/循环。由于“循环”在国际单位制中是无量纲计数，因此 $da/d(\\text{cycle})$ 的 SI 基本量纲简化为长度的量纲：\n$$\n\\left[\\frac{da}{d(\\text{cycle})}\\right] = \\text{m}.\n$$\n\n该比例关系意味着\n$$\n\\left[\\frac{da}{d(\\text{cycle})}\\right] = [C]\\,[\\Delta K]^{m}.\n$$\n求解 $C$ 的单位可得\n$$\n[C] = \\frac{\\left[\\dfrac{da}{d(\\text{cycle})}\\right]}{[\\Delta K]^{m}} = \\frac{\\text{m}}{\\left(\\text{kg}\\,\\text{m}^{-1/2}\\,\\text{s}^{-2}\\right)^{m}}.\n$$\n对分母进行幂运算，\n$$\n[\\Delta K]^{m} = \\text{kg}^{m}\\,\\text{m}^{-m/2}\\,\\text{s}^{-2m}.\n$$\n因此，\n$$\n[C] = \\text{kg}^{-m}\\,\\text{m}^{1 + \\frac{m}{2}}\\,\\text{s}^{2m}.\n$$\n\n如果希望将“每循环”作为一个记账标签来跟踪，那么也可以用兆帕斯卡（MPa）和米（m）来写出明确的工程单位：\n$$\n[C] = \\text{MPa}^{-m}\\,\\text{m}^{1 - \\frac{m}{2}}\\,\\text{cycle}^{-1},\n$$\n这是等效的，因为 $\\text{MPa}$ 与 $\\text{Pa}$ 具有相同的量纲，且因子 $10^{6}$ 是无量纲的。将 $\\text{MPa}^{-m}$ 展开为 SI 基本单位可恢复表达式\n$$\n[C] = \\text{kg}^{-m}\\,\\text{m}^{1+\\frac{m}{2}}\\,\\text{s}^{2m},\n$$\n其中“循环”在国际单位制中是无量纲的。\n\n问题要求将最终答案表示为 $(\\text{kg}, \\text{m}, \\text{s})$ 的指数行向量，并按此顺序排列。从 SI 基本单位表达式中读出指数可得：\n- $\\text{kg}$ 的指数：$-m$，\n- $\\text{m}$ 的指数：$1 + \\dfrac{m}{2}$，\n- $\\text{s}$ 的指数：$2m$。\n\n因此，所要求的行向量是 $( -m,\\ 1 + \\dfrac{m}{2},\\ 2m )$。", "answer": "$$\\boxed{(-m, 1+\\frac{m}{2}, 2m)}$$", "id": "2885911"}, {"introduction": "掌握了Paris定律的基础后，我们将其应用于一个核心工程任务：预测恒定振幅载荷下的疲劳寿命。由于真实部件的几何形状通常很复杂，通过解析积分求解寿命是罕见的，因此数值积分成为一种标准方法。本练习要求你编写程序，通过数值求积来计算裂纹扩展所需的循环次数，从而将理论知识转化为实用的计算技能。[@problem_id:2885969]", "problem": "一个结构板含有一个单边裂纹，承受循环远场拉伸载荷。你需要计算在恒定幅值的循环应力作用下，裂纹从初始长度 $a_i$ 扩展到最终长度 $a_f$ 所需的载荷循环次数。你的推导和算法必须从以下基本原理出发，不得假设任何闭式积分结果：\n- I 型加载的应力强度因子范围定义为 $\\Delta K(a) = Y(a/W)\\,\\Delta \\sigma \\,\\sqrt{\\pi a}$，其中 $Y(a/W)$ 是一个无量纲的几何修正函数，$W$ 是板的宽度，$a$ 是裂纹长度，$\\Delta \\sigma$ 是施加的远场应力范围。\n- Paris 区的疲劳裂纹扩展速率遵循一个经过经验充分验证的、与应力强度因子范围的幂律关系，由材料常数 $C$ 和 $m$ 表征。\n- 从 $a_i$ 扩展到 $a_f$ 所需的循环次数 $N$ 是通过对裂纹扩展速率的倒数在 $a$ 上积分来确定的。\n\n使用数值积分来计算得到 $N$ 的定积分。不允许使用闭式反导数；你必须以足够的精度进行数值积分。采用以下科学上公认的单边裂纹板几何因子多项式近似（在 $0 \\le a/W \\lesssim 0.6$ 范围内有效）：\n$$\nY(\\alpha) \\equiv Y\\!\\left(\\frac{a}{W}\\right) = 1.12 - 0.231\\,\\alpha + 10.55\\,\\alpha^2 - 21.72\\,\\alpha^3 + 30.39\\,\\alpha^4,\n$$\n其中 $\\alpha = a/W$。\n\n物理和数值单位：\n- 使用国际单位制（SI）。裂纹长度 $a$、$a_i$、$a_f$ 和宽度 $W$ 必须以米（m）为单位。应力 $\\Delta \\sigma$ 必须以兆帕（MPa）为单位。应力强度因子范围 $\\Delta K$ 的单位则为 $\\text{MPa}\\sqrt{\\text{m}}$。\n- 材料常数 $C$ 的单位必须是 $\\text{m/cycle} \\cdot (\\text{MPa}\\sqrt{\\text{m}})^{-m}$，这样裂纹扩展速率的单位就是 $\\text{m/cycle}$。\n- 输出循环次数，单位为“次”（无量纲），并四舍五入到六位小数。\n\n测试集：\n对以下每一组参数，计算裂纹从 $a_i = 1\\,\\text{mm}$ 扩展到 $a_f = 10\\,\\text{mm}$ 所需的循环次数 $N$。在你的计算中将毫米转换为米：$1\\,\\text{mm} = 1.0\\times 10^{-3}\\,\\text{m}$ 和 $10\\,\\text{mm} = 1.0\\times 10^{-2}\\,\\text{m}$。确保积分域中的所有 $a/W$ 值都保持在 $Y(\\alpha)$ 的规定有效范围内。\n- 情况 1（理想情况）：$W = 50\\,\\text{mm}$，$\\Delta \\sigma = 100\\,\\text{MPa}$，$C = 1.0\\times 10^{-12}$，$m = 3.0$。\n- 情况 2（减小的应力范围）：$W = 50\\,\\text{mm}$，$\\Delta \\sigma = 50\\,\\text{MPa}$，$C = 1.0\\times 10^{-12}$，$m = 3.0$。\n- 情况 3（增大的指数）：$W = 50\\,\\text{mm}$，$\\Delta \\sigma = 100\\,\\text{MPa}$，$C = 1.0\\times 10^{-12}$，$m = 4.0$。\n- 情况 4（更窄的板，几何有效性边界）：$W = 25\\,\\text{mm}$，$\\Delta \\sigma = 100\\,\\text{MPa}$，$C = 1.0\\times 10^{-12}$，$m = 3.0$。\n- 情况 5（不同的材料常数）：$W = 40\\,\\text{mm}$，$\\Delta \\sigma = 80\\,\\text{MPa}$，$C = 5.0\\times 10^{-13}$，$m = 3.2$。\n\n算法要求：\n- 对于每种情况，你的程序必须使用一个鲁棒的积分方法，在 $a \\in [a_i,a_f]$ 上数值计算定义 $N$ 的积分，并使用足够小的绝对和相对容差以确保结果中至少有六位有效数字。\n- 完全按照上面给出的方式处理 $Y(a/W)$，其中 $a$ 和 $W$ 始终以米为单位。\n- 对每种情况，验证在整个积分区间内 $a/W \\le 0.6$；如果任何测试用例违反了此条件，则计算将无效（但是，所提供的测试集已构造为满足此条件）。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含五个情况的结果，格式为一个由方括号括起来的逗号分隔列表，每个值都以“次”为单位四舍五入到六位小数（例如，$[n_1,n_2,n_3,n_4,n_5]$）。", "solution": "在尝试求解之前，对问题陈述进行验证。\n\n**步骤 1：提取已知条件**\n- 疲劳裂纹扩展速率定律：隐含地给出为 Paris-Erdogan 定律，$da/dN = f(\\Delta K)$。\n- 定律的显式形式：$da/dN = C(\\Delta K)^m$。\n- I 型应力强度因子范围：$\\Delta K(a) = Y(a/W)\\,\\Delta \\sigma \\,\\sqrt{\\pi a}$。\n- 单边裂纹板的几何修正函数：$Y(\\alpha) = 1.12 - 0.231\\,\\alpha + 10.55\\,\\alpha^2 - 21.72\\,\\alpha^3 + 30.39\\,\\alpha^4$，其中 $\\alpha = a/W$。\n- $Y(\\alpha)$ 的有效范围：$0 \\le a/W \\lesssim 0.6$。\n- 裂纹从 $a_i$ 扩展到 $a_f$ 所需的循环次数 $N$：$N = \\int_{a_i}^{a_f} \\frac{1}{da/dN} \\, da$。\n- 数值计算要求：$N$ 的积分必须使用数值积分计算，而不是闭式反导数。\n- 单位：裂纹长度（$a, a_i, a_f, W$）以米（m）为单位，应力范围 $\\Delta \\sigma$ 以兆帕（MPa）为单位，$\\Delta K$ 的单位为 $\\text{MPa}\\sqrt{\\text{m}}$，材料常数 $C$ 的单位为 $\\text{m/cycle} \\cdot (\\text{MPa}\\sqrt{\\text{m}})^{-m}$。\n- 初始和最终裂纹长度：$a_i = 1\\,\\text{mm} = 1.0 \\times 10^{-3}\\,\\text{m}$，$a_f = 10\\,\\text{mm} = 1.0 \\times 10^{-2}\\,\\text{m}$。\n- 测试用例：\n  - 情况 1：$W = 50\\,\\text{mm} = 5.0 \\times 10^{-2}\\,\\text{m}$，$\\Delta \\sigma = 100\\,\\text{MPa}$，$C = 1.0 \\times 10^{-12}$，$m = 3.0$。\n  - 情况 2：$W = 50\\,\\text{mm} = 5.0 \\times 10^{-2}\\,\\text{m}$，$\\Delta \\sigma = 50\\,\\text{MPa}$，$C = 1.0 \\times 10^{-12}$，$m = 3.0$。\n  - 情况 3：$W = 50\\,\\text{mm} = 5.0 \\times 10^{-2}\\,\\text{m}$，$\\Delta \\sigma = 100\\,\\text{MPa}$，$C = 1.0 \\times 10^{-12}$，$m = 4.0$。\n  - 情况 4：$W = 25\\,\\text{mm} = 2.5 \\times 10^{-2}\\,\\text{m}$，$\\Delta \\sigma = 100\\,\\text{MPa}$，$C = 1.0 \\times 10^{-12}$，$m = 3.0$。\n  - 情况 5：$W = 40\\,\\text{mm} = 4.0 \\times 10^{-2}\\,\\text{m}$，$\\Delta \\sigma = 80\\,\\text{MPa}$，$C = 5.0 \\times 10^{-13}$，$m = 3.2$。\n- 算法要求：验证积分区间 $[a_i, a_f]$ 上的 $a/W \\le 0.6$。\n\n**步骤 2：使用提取的已知条件进行验证**\n- **科学基础和客观性**：该问题基于线弹性断裂力学的公认原理，特别是用于疲劳裂纹扩展的 Paris-Erdogan 定律。这是材料科学和机械工程中的一个标准和基本概念。其表述是客观的，并使用了精确的标准术语。\n- **适定性**：该问题是适定的。它要求计算一个在指定积分区间 $[a_i, a_f]$ 上连续且表现良好的函数的定积分，因为 $a_i  0$。对于循环次数 $N$，存在一个唯一的、稳定的解。\n- **不完整或矛盾的设置**：该问题是自洽的。为每个测试用例提供了所有必需的材料常数、几何参数和加载条件。单位是内部一致的。必须检查几何函数的有效性条件 $a/W \\le 0.6$。对于所有情况，最大裂纹长度为 $a_f = 1.0 \\times 10^{-2}\\,\\text{m}$。\n  - 情况 1：$a_f/W = (1.0 \\times 10^{-2}) / (5.0 \\times 10^{-2}) = 0.2 \\le 0.6$。有效。\n  - 情况 2：$a_f/W = (1.0 \\times 10^{-2}) / (5.0 \\times 10^{-2}) = 0.2 \\le 0.6$。有效。\n  - 情况 3：$a_f/W = (1.0 \\times 10^{-2}) / (5.0 \\times 10^{-2}) = 0.2 \\le 0.6$。有效。\n  - 情况 4：$a_f/W = (1.0 \\times 10^{-2}) / (2.5 \\times 10^{-2}) = 0.4 \\le 0.6$。有效。\n  - 情况 5：$a_f/W = (1.0 \\times 10^{-2}) / (4.0 \\times 10^{-2}) = 0.25 \\le 0.6$。有效。\n所有测试用例在整个积分域上都满足有效性条件。\n- **不切实际或不可行**：所提供的材料参数和应力水平对于常见的工程合金（如钢或铝）在循环加载条件下的情况是现实的。\n\n**步骤 3：结论和行动**\n该问题在科学上是合理的、适定的和完整的。它是**有效**的。将提供一个解决方案。\n\n**解题推导**\n裂纹扩展速率 $da/dN$ 与载荷循环次数 $N$ 之间的基本关系，可以通过对微分形式进行变量分离得到：\n$$ dN = \\frac{da}{da/dN} $$\n为了求出裂纹从初始长度 $a_i$ 扩展到最终长度 $a_f$ 所需的总循环次数 $N$，我们必须在裂纹长度区间上对该表达式进行积分：\n$$ N = \\int_{a_i}^{a_f} \\frac{1}{da/dN} \\, da $$\n疲劳裂纹的扩展速率 $da/dN$ 由 Paris-Erdogan 定律控制，该定律将扩展速率与应力强度因子范围 $\\Delta K$ 相关联：\n$$ \\frac{da}{dN} = C (\\Delta K)^m $$\n其中 $C$ 和 $m$ 是经验性材料常数。\n\n将 Paris 定律代入 $N$ 的积分中，得到：\n$$ N = \\int_{a_i}^{a_f} \\frac{1}{C (\\Delta K)^m} \\, da $$\n应力强度因子范围 $\\Delta K$ 是施加的应力范围 $\\Delta \\sigma$、裂纹长度 $a$ 以及构件几何形状的函数。对于指定的单边裂纹板，它由下式给出：\n$$ \\Delta K(a) = Y(\\alpha) \\Delta \\sigma \\sqrt{\\pi a} $$\n其中 $\\alpha = a/W$，$Y(\\alpha)$ 是无量纲的几何修正因子，以多项式形式给出：\n$$ Y(\\alpha) = 1.12 - 0.231\\,\\alpha + 10.55\\,\\alpha^2 - 21.72\\,\\alpha^3 + 30.39\\,\\alpha^4 $$\n通过将 $\\Delta K(a)$ 的表达式代入 $N$ 的积分中，我们得到完整的被积函数：\n$$ N = \\int_{a_i}^{a_f} \\frac{1}{C \\left( Y(a/W) \\Delta \\sigma \\sqrt{\\pi a} \\right)^m} \\, da $$\n这可以重写为将常数项从积分中分离出来：\n$$ N = \\frac{1}{C (\\Delta \\sigma)^m (\\pi)^{m/2}} \\int_{a_i}^{a_f} \\frac{1}{\\left( Y(a/W) \\sqrt{a} \\right)^m} \\, da $$\n由于 $Y(a/W)$ 的多项式形式，该积分没有通用的闭式解析解。因此，按照问题的要求，数值积分是其评估的正确且必要的方法。我们定义被积函数 $f(a)$：\n$$ f(a) = \\frac{1}{C \\left( Y(a/W) \\Delta \\sigma \\sqrt{\\pi a} \\right)^m} $$\n循环次数则为 $N = \\int_{a_i}^{a_f} f(a) \\, da$。这个定积分将使用一个鲁棒的数值积分算法为每个测试用例计算，确保所有物理量都一致使用国际单位制。裂纹长度 $a$、$a_i$、$a_f$ 和板宽 $W$ 的单位是米（m）。应力范围 $\\Delta \\sigma$ 的单位是兆帕（MPa）。Paris 常数 $C$ 的单位是 $\\text{m/cycle} \\cdot (\\text{MPa}\\sqrt{\\text{m}})^{-m}$。得到的 $N$ 值将是一个代表循环次数的无量纲量。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import integrate\n\ndef solve():\n    \"\"\"\n    Computes the number of fatigue cycles for crack growth using numerical integration\n    of the Paris law.\n    \"\"\"\n    \n    # Define the initial and final crack lengths in meters.\n    a_i = 1.0e-3  # m\n    a_f = 1.0e-2  # m\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (W_m, delta_sigma_MPa, C, m)\n    # W_m is the plate width in meters.\n    # delta_sigma_MPa is the stress range in MPa.\n    # C is the Paris law constant in m/cycle * (MPa*sqrt(m))^-m.\n    # m is the Paris law exponent (dimensionless).\n    test_cases = [\n        # Case 1: Happy path\n        (50.0e-3, 100.0, 1.0e-12, 3.0),\n        # Case 2: Reduced stress range\n        (50.0e-3, 50.0, 1.0e-12, 3.0),\n        # Case 3: Increased exponent\n        (50.0e-3, 100.0, 1.0e-12, 4.0),\n        # Case 4: Narrower plate\n        (25.0e-3, 100.0, 1.0e-12, 3.0),\n        # Case 5: Different material constants\n        (40.0e-3, 80.0, 5.0e-13, 3.2),\n    ]\n\n    results = []\n    \n    # Polynomial coefficients for the geometry function Y(alpha), where alpha = a/W.\n    # Y(alpha) = c0 + c1*alpha + c2*alpha^2 + c3*alpha^3 + c4*alpha^4\n    Y_coeffs = np.array([30.39, -21.72, 10.55, -0.231, 1.12])\n\n    def Y(alpha):\n        \"\"\"\n        Computes the geometry correction factor Y for a given alpha = a/W.\n        \"\"\"\n        return np.polyval(Y_coeffs, alpha)\n\n    for case in test_cases:\n        W_m, delta_sigma_MPa, C, m = case\n\n        def integrand(a):\n            \"\"\"\n            Defines the function 1 / (da/dN) to be integrated with respect to crack length 'a'.\n            All units must be consistent (SI/MPa based).\n            \n            Args:\n                a (float): Crack length in meters.\n\n            Returns:\n                float: The value of 1 / (da/dN) in units of cycles/m.\n            \"\"\"\n            # Calculate dimensionless crack length ratio\n            alpha = a / W_m\n\n            # Check if a/W is within the valid range for the geometry function Y.\n            # The problem statement guarantees this, but it is good practice.\n            if not (0 = alpha = 0.6):\n                # This should not be reached with the given test cases.\n                # Return infinity to signal an error if quad explores outside the domain.\n                return np.inf\n            \n            # Calculate geometry factor\n            Y_val = Y(alpha)\n            \n            # Calculate stress intensity factor range (MPa*sqrt(m))\n            delta_K = Y_val * delta_sigma_MPa * np.sqrt(np.pi * a)\n            \n            # Calculate crack growth rate (m/cycle) using Paris law\n            da_dN = C * (delta_K ** m)\n            \n            # The function to integrate is the reciprocal of the growth rate\n            return 1.0 / da_dN\n\n        # Perform numerical integration from a_i to a_f\n        # quad returns a tuple (result, error_estimate)\n        N_cycles, _ = integrate.quad(\n            integrand, \n            a_i, \n            a_f,\n            epsabs=1e-9, # Absolute tolerance for high accuracy\n            epsrel=1e-9  # Relative tolerance for high accuracy\n        )\n        \n        results.append(N_cycles)\n\n    # Final print statement must be in the exact required format.\n    # Each value is formatted to six decimal places.\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\nsolve()\n```", "id": "2885969"}, {"introduction": "在现实世界的应用中，结构部件很少承受简单的恒定振幅载荷。本项高级练习将挑战你模拟更真实的变幅载荷谱下的裂纹扩展。你将实现一个逐周期模拟，其中包含了裂纹闭合和过载引起的延迟等关键物理效应，这些都是工业界进行复杂疲劳分析时必须考虑的重要因素。[@problem_id:2885943]", "problem": "您需要实现一个模拟，模拟单边裂纹有限宽度板在规定的块状循环加载谱作用下的疲劳裂纹扩展。每个周期的裂纹扩展由一个关于有效应力强度因子范围的幂律关系决定，该关系经过裂纹闭合函数和延迟因子的修正。模拟必须逐周期显式迭代以累积裂纹扩展量。所有物理量在适用时必须采用国际单位制（SI），其中应力单位为兆帕，长度单位为米，应力强度因子单位为兆帕乘以米的平方根。\n\n从以下基本事实和定义开始。\n\n1) I型加载下单边裂纹有限宽度板的应力强度因子：其范围由每个周期的最大和最小水平构建。对于每个周期，在裂纹长度为 $a$ 和板宽度为 $W$ 的情况下，处理\n$$\nY\\left(\\frac{a}{W}\\right) = 1.12 - 0.231\\left(\\frac{a}{W}\\right) + 10.55\\left(\\frac{a}{W}\\right)^2 - 21.72\\left(\\frac{a}{W}\\right)^3 + 30.39\\left(\\frac{a}{W}\\right)^4,\n$$\n并定义最大和最小I型应力强度因子为\n$$\nK_{\\max} = Y\\left(\\frac{a}{W}\\right)\\,\\sigma_{\\max}\\,\\sqrt{\\pi a},\\quad\nK_{\\min} = Y\\left(\\frac{a}{W}\\right)\\,\\sigma_{\\min}\\,\\sqrt{\\pi a},\n$$\n其中 $\\sigma_{\\max}$ 和 $\\sigma_{\\min}$ 分别是周期内的最大和最小施加名义应力。应力比为 $R=\\sigma_{\\min}/\\sigma_{\\max}$，范围为 $\\Delta K = K_{\\max}-K_{\\min} = (1-R)\\,K_{\\max}$。\n\n2) 基于Newman的平面应力经验性裂纹张开估算的有效范围：定义\n$$\n\\phi(R) = 0.825 - 0.34\\,R + 0.05\\,R^2,\n$$\n并将其裁剪至区间 $[0,1]$。对于 $-1 \\le R \\le 1$，裂纹张开比为 $K_{\\mathrm{op}}/K_{\\max}=\\phi(R)$，对于此范围之外的任何 $R$ 值，应用裁剪。裂纹张开函数为\n$$\nU(R) = \\frac{K_{\\max} - K_{\\mathrm{op}}}{\\Delta K} = \\frac{1 - \\phi(R)}{1 - R},\n$$\n裁剪至区间 $[0,1]$，并在极限情况下，当 $R\\to 1$ 以至于 $\\Delta K \\to 0$ 时，解释为 $U(R)=1$。有效范围为 $\\Delta K_{\\mathrm{eff}} = U(R)\\,\\Delta K$。\n\n3) 通过Wheeler型塑性区模型实现延迟：假设屈服强度为 $\\sigma_{y}$。对于被指定为过载事件的周期，计算过载尖端的平面应力单调塑性区尺寸：\n$$\nr_{p,\\mathrm{ol}} = \\frac{1}{2\\pi}\\left(\\frac{K_{\\max,\\mathrm{ol}}}{\\sigma_{y}}\\right)^2,\n$$\n并记录过载时的裂纹长度为 $a_{\\mathrm{ol}}$。对于后续周期，直到裂纹尖端达到 $a \\ge a_{\\mathrm{ol}} + r_{p,\\mathrm{ol}}$，应用一个延迟因子\n$$\nf_{\\mathrm{ret}} = \\left(\\max\\left(0,\\frac{a_{\\mathrm{ol}} + r_{p,\\mathrm{ol}} - a}{r_{p,\\mathrm{ol}}}\\right)\\right)^{\\gamma_{w}},\n$$\n其中 Wheeler 指数 $\\gamma_{w}$ 为给定值。当 $a \\ge a_{\\mathrm{ol}} + r_{p,\\mathrm{ol}}$ 时，设置 $f_{\\mathrm{ret}}=1$，直到下一次过载。如果在前一个过载塑性区耗尽之前发生新的过载，则使用新过载周期的 $K_{\\max}$ 覆盖 $a_{\\mathrm{ol}}$ 和 $r_{p,\\mathrm{ol}}$。\n\n您的程序必须：\n- 对于每个周期，计算 $Y$、$K_{\\max}$、$K_{\\min}$、$\\Delta K$、$U(R)$、$\\Delta K_{\\mathrm{eff}}$ 和 $f_{\\mathrm{ret}}$。\n- 使用提供的材料常数 $C$ 和 $m$，以有效范围的幂律形式，按周期增量推进裂纹长度。\n- 累积整个块状谱的总裂纹扩展量。\n- 对每个测试用例，输出总裂纹扩展量 $\\Delta a = a_{\\mathrm{final}} - a_{0}$。\n\n科学真实性约束：\n- 一致地使用单位：$\\sigma$ 和 $\\sigma_{y}$ 以兆帕为单位， $a$ 和 $W$ 以米为单位， $K$ 以 $\\mathrm{MPa}\\sqrt{\\mathrm{m}}$ 为单位，材料系数 $C$ 以 $\\mathrm{m}/\\mathrm{cycle}/(\\mathrm{MPa}\\sqrt{\\mathrm{m}})^{m}$ 为单位。\n- 使用如上所示的平面应力塑性区缩放因子 $1/(2\\pi)$。\n- 使用如上给出的应力强度因子几何函数 $Y(a/W)$，不作修改。\n- 使用 $\\gamma_{w} = 1.0$。\n\n数值计算说明：\n- 对每个测试用例，生成一个浮点数，等于总裂纹扩展量 $\\Delta a$（单位为米），四舍五入到 $10^{-12}$ 米。\n- 不涉及角度，因此不需要角度单位。\n\n测试套件：\n实现以下三个测试用例。对于每个用例，给定板宽度 $W$、初始裂纹长度 $a_{0}$、屈服强度 $\\sigma_{y}$、材料常数 $C$ 和 $m$，以及一个由载荷段组成的块状谱。每个载荷段是一个元组 $\\left(N_{i}, \\sigma_{\\max,i}, R_{i}, \\mathrm{OL}_{i}\\right)$，表示在该水平下连续 $N_{i}$ 个周期，其中 $R_{i}=\\sigma_{\\min,i}/\\sigma_{\\max,i}$，$\\mathrm{OL}_{i}$ 是一个布尔值，指示该段的第一个周期是否为延迟模型的过载事件。如果存在过载事件，则必须在应用该过载周期的增量后更新 $a_{\\mathrm{ol}}$ 和 $r_{p,\\mathrm{ol}}$。\n\n- 测试用例 1：\n  - $W = 0.10$ 米, $a_{0} = 0.005$ 米, $\\sigma_{y} = 350$ 兆帕, $C = 2.0\\times 10^{-12}$, $m = 3.2$。\n  - 块状谱：\n    - $\\left(1000, 120, 0.10, \\text{false}\\right)$\n    - $\\left(1, 220, 0.10, \\text{true}\\right)$\n    - $\\left(2000, 120, 0.10, \\text{false}\\right)$\n    - $\\left(1000, 140, 0.30, \\text{false}\\right)$\n\n- 测试用例 2：\n  - $W = 0.08$ 米, $a_{0} = 0.004$ 米, $\\sigma_{y} = 400$ 兆帕, $C = 1.5\\times 10^{-12}$, $m = 3.0$。\n  - 块状谱：\n    - $\\left(3000, 100, -0.30, \\text{false}\\right)$\n    - $\\left(1000, 140, 0.00, \\text{false}\\right)$\n\n- 测试用例 3：\n  - $W = 0.06$ 米, $a_{0} = 0.020$ 米, $\\sigma_{y} = 500$ 兆帕, $C = 5.0\\times 10^{-13}$, $m = 3.5$。\n  - 块状谱：\n    - $\\left(800, 160, 0.40, \\text{false}\\right)$\n    - $\\left(1, 260, 0.40, \\text{true}\\right)$\n    - $\\left(1500, 160, 0.40, \\text{false}\\right)$\n    - $\\left(1, 300, 0.40, \\text{true}\\right)$\n    - $\\left(1000, 170, 0.40, \\text{false}\\right)$\n\n算法与实现要求：\n- 按提供的顺序逐周期迭代。在每个段内，当且仅当 $\\mathrm{OL}_{i}=\\mathrm{true}$ 时，将第一个周期视为过载；否则它是一个常规周期。\n- 按照描述使用 $\\phi(R)$ 和 $U(R)$ 的裁剪规则。\n- 为了数值稳健性，如果 $R$ 非常接近 $1$ 以至于 $1-R  10^{-9}$，则在该周期设置 $U(R)=1$。\n- 如果在模拟期间 $a/W$ 超过 $0.6$，对于此问题继续使用相同的 $Y(a/W)$ 关系。\n- 要求的最终输出格式是包含三个结果的单行 Python 风格列表，结果按顺序排列，每个结果四舍五入到 $10^{-12}$ 米。例如，打印的行必须看起来像\n  $$\n  [x_{1},x_{2},x_{3}]\n  $$\n  其中 $x_{i}$ 是以米为单位的十进制数。\n\n您的程序必须是一个完整的、可运行的脚本，且只产生这一行输出，不含其他任何内容。", "solution": "问题陈述已经过严格验证。它具有科学依据、问题设定良好、客观且内部一致。它提出了一个计算断裂力学中标准的、尽管复杂的问题，要求在变幅加载下对疲劳裂纹扩展定律进行数值积分。所提供的模型——应力强度因子的多项式几何函数、Newman 的裂纹闭合模型和 Wheeler 延迟模型——都是该领域的既定组成部分。每个测试用例的所有必要参数、边界条件和材料常数都已提供。关于数值算法的说明，包括对过载事件和数值稳定性考虑的具体处理，都是明确且足以开发出无歧义的实现。该问题被认为是有效的，并将提供解决方案。\n\n任务是模拟单边裂纹板在块状加载谱作用下疲劳裂纹的逐周期扩展。对于三个测试用例中的每一个，所需的输出是总裂纹扩展量 $\\Delta a$。\n\n模拟的核心是裂纹扩展定律，它整合了施加应力范围、裂纹闭合和过载引起的延迟效应。每个周期的裂纹扩展增量 $\\Delta a_{\\text{cycle}}$ 由修正的 Paris 定律给出：\n$$\n\\frac{da}{dN} \\approx \\Delta a_{\\text{cycle}} = f_{\\text{ret}} \\cdot C \\cdot (\\Delta K_{\\text{eff}})^m\n$$\n其中 $C$ 和 $m$ 是材料常数，$\\Delta K_{\\text{eff}}$ 是有效应力强度因子范围，而 $f_{\\text{ret}}$ 是延迟因子。模拟通过在加载谱中指定的总周期数上累积这些增量来进行。\n\n对于当前裂纹长度为 $a$ 的每个周期的计算过程如下：\n\n首先，使用给定的多项式计算有限宽度板的几何校正因子 $Y(a/W)$：\n$$\nY\\left(\\frac{a}{W}\\right) = 1.12 - 0.231\\left(\\frac{a}{W}\\right) + 10.55\\left(\\frac{a}{W}\\right)^2 - 21.72\\left(\\frac{a}{W}\\right)^3 + 30.39\\left(\\frac{a}{W}\\right)^4\n$$\n其中 $W$ 是板的宽度。\n\n其次，计算当前周期在应力为 $\\sigma_{\\max}$ 和 $\\sigma_{\\min}$ 时的最大和最小应力强度因子 $K_{\\max}$ 和 $K_{\\min}$：\n$$\nK_{\\max} = Y\\left(\\frac{a}{W}\\right)\\,\\sigma_{\\max}\\,\\sqrt{\\pi a}\n$$\n$$\nK_{\\min} = Y\\left(\\frac{a}{W}\\right)\\,\\sigma_{\\min}\\,\\sqrt{\\pi a}\n$$\n应力强度因子范围是 $\\Delta K = K_{\\max} - K_{\\min}$。\n\n第三，引入裂纹闭合效应以确定有效应力强度因子范围 $\\Delta K_{\\text{eff}}$。这基于 Newman 的经验模型。周期的应力比为 $R = \\sigma_{\\min}/\\sigma_{\\max}$。首先计算裂纹张开函数 $\\phi(R)$。输入值 $R$ 在用于公式前被裁剪至区间 $[-1, 1]$，输出被裁剪至 $[0, 1]$：\n$$\nR_{\\text{clipped}} = \\max(-1, \\min(1, R))\n$$\n$$\n\\phi(R) = \\text{clip}_{[0,1]}\\left(0.825 - 0.34\\,R_{\\text{clipped}} + 0.05\\,R_{\\text{clipped}}^2\\right)\n$$\n然后确定裂纹闭合参数 $U(R)$。为保证 $R \\to 1$ 时的数值稳定性，如果 $1-R  10^{-9}$，则将 $U(R)$ 设为 $1$。否则，计算如下：\n$$\nU(R) = \\frac{1 - \\phi(R)}{1 - R}\n$$\n该结果同样被裁剪至区间 $[0, 1]$。于是有效范围为：\n$$\n\\Delta K_{\\text{eff}} = U(R)\\,\\Delta K\n$$\n\n第四，根据 Wheeler 模型计算延迟因子 $f_{\\text{ret}}$。该模型考虑了由先前过载产生的塑性区内的压缩残余应力。过载由其最大应力强度因子 $K_{\\max,\\text{ol}}$ 和其发生时的裂纹长度 $a_{\\text{ol}}$ 定义。相关的塑性区尺寸为：\n$$\nr_{p,\\text{ol}} = \\frac{1}{2\\pi}\\left(\\frac{K_{\\max,\\text{ol}}}{\\sigma_{y}}\\right)^2\n$$\n其中 $\\sigma_y$ 是材料的屈服强度。对于后续的周期，只要当前长度为 $a$ 的裂纹尖端位于该过载塑性区内（即 $a  a_{\\text{ol}} + r_{p,\\text{ol}}$），就应用延迟因子：\n$$\nf_{\\text{ret}} = \\left(\\frac{a_{\\text{ol}} + r_{p,\\text{ol}} - a}{r_{p,\\text{ol}}}\\right)^{\\gamma_{w}}\n$$\n其中 Wheeler 指数给定为 $\\gamma_w = 1.0$。如果裂纹已经扩展到过载塑性区之外（$a \\ge a_{\\text{ol}} + r_{p,\\text{ol}}$），则不发生延迟，且 $f_{\\text{ret}} = 1$。最初，没有活动的过载。如果发生新的过载，其对应的 $a_{\\text{ol}}$ 和 $r_{p,\\text{ol}}$ 将覆盖任何先前的值。\n\n计算过程是在一个逐周期循环中对这些步骤的直接实现。\n\n1.  为每个测试用例初始化状态变量：当前裂纹长度 $a \\leftarrow a_0$，以及过载参数 $a_{\\text{ol}}$ 和 $r_{p,\\text{ol}}$ 初始化为表示无活动延迟。\n2.  遍历指定的加载块。对每个块，遍历指定的周期数 $N_i$。\n3.  在每个周期中，使用当前的 $a$ 值和周期的加载参数（$\\sigma_{\\max}$、$R$）计算裂纹扩展增量 $\\Delta a_{\\text{cycle}}$。\n4.  更新裂纹长度：$a \\leftarrow a + \\Delta a_{\\text{cycle}}$。\n5.  如果当前周期被指定为过载，其 $K_{\\max}$ 被记录为 $K_{\\max,\\text{ol}}$。计算新的过载塑性区尺寸 $r_{p,\\text{ol}}$。根据问题的明确指示，将过载裂纹长度 $a_{\\text{ol}}$ 设置为*新更新*的裂纹长度 $a$。\n6.  在所有块中的所有周期完成后，总裂纹扩展量计算为 $\\Delta a = a_{\\text{final}} - a_0$。\n\n该算法应用于三个测试用例中的每一个，使用它们各自的参数和加载谱。最终结果四舍五入到指定的 $10^{-12}$ 米精度。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the fatigue crack growth simulation for all test cases.\n    \"\"\"\n\n    # Test cases defined in the problem statement\n    test_cases = [\n        {\n            \"W\": 0.10, \"a0\": 0.005, \"sigma_y\": 350,\n            \"C\": 2.0e-12, \"m\": 3.2,\n            \"spectrum\": [\n                (1000, 120, 0.10, False),\n                (1, 220, 0.10, True),\n                (2000, 120, 0.10, False),\n                (1000, 140, 0.30, False),\n            ]\n        },\n        {\n            \"W\": 0.08, \"a0\": 0.004, \"sigma_y\": 400,\n            \"C\": 1.5e-12, \"m\": 3.0,\n            \"spectrum\": [\n                (3000, 100, -0.30, False),\n                (1000, 140, 0.00, False),\n            ]\n        },\n        {\n            \"W\": 0.06, \"a0\": 0.020, \"sigma_y\": 500,\n            \"C\": 5.0e-13, \"m\": 3.5,\n            \"spectrum\": [\n                (800, 160, 0.40, False),\n                (1, 260, 0.40, True),\n                (1500, 160, 0.40, False),\n                (1, 300, 0.40, True),\n                (1000, 170, 0.40, False),\n            ]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        delta_a = run_simulation(case)\n        results.append(round(delta_a, 12))\n\n    print(f\"[{','.join(map(str, results))}]\")\n\n\ndef run_simulation(params):\n    \"\"\"\n    Performs the cycle-by-cycle fatigue crack growth simulation for a single test case.\n    \"\"\"\n    W = params[\"W\"]\n    a = params[\"a0\"]\n    a0 = params[\"a0\"]\n    sigma_y = params[\"sigma_y\"]\n    C = params[\"C\"]\n    m = params[\"m\"]\n    spectrum = params[\"spectrum\"]\n    gamma_w = 1.0\n\n    # Retardation state variables\n    a_ol = -1.0  # Crack length at last overload, initialized to indicate no overload\n    r_p_ol = 0.0   # Plastic zone size of last overload\n\n    for (N_cycles, sigma_max, R, is_ol_segment) in spectrum:\n        sigma_min = R * sigma_max\n        \n        for cycle in range(1, N_cycles + 1):\n            # 1. Geometry Factor Y(a/W)\n            x = a / W\n            Y = 1.12 - 0.231*x + 10.55*x**2 - 21.72*x**3 + 30.39*x**4\n            \n            # 2. Stress-Intensity Factor (SIF) calculations\n            K_max = Y * sigma_max * np.sqrt(np.pi * a)\n            delta_K = K_max * (1 - R)\n\n            # 3. Effective SIF range (Crack Closure)\n            R_clipped = np.clip(R, -1.0, 1.0)\n            phi_val = 0.825 - 0.34*R_clipped + 0.05*R_clipped**2\n            phi = np.clip(phi_val, 0.0, 1.0)\n            \n            if (1.0 - R)  1e-9:\n                U = 1.0\n            else:\n                U = (1.0 - phi) / (1.0 - R)\n            U = np.clip(U, 0.0, 1.0)\n            \n            delta_K_eff = U * delta_K\n\n            # 4. Retardation Factor (Wheeler Model)\n            if a  a_ol + r_p_ol:\n                f_ret = ((a_ol + r_p_ol - a) / r_p_ol)**gamma_w\n                f_ret = max(0.0, f_ret)\n            else:\n                f_ret = 1.0\n\n            # 5. Crack growth increment\n            da = f_ret * C * (delta_K_eff**m)\n\n            # 6. Update crack length\n            a += da\n\n            # 7. Overload update logic\n            is_overload_cycle = (cycle == 1 and is_ol_segment)\n            if is_overload_cycle:\n                # Update retardation parameters based on this overload cycle\n                # Note: K_max_ol is the K_max calculated in this very cycle\n                K_max_ol = K_max\n                # Plane-stress monotonic plastic zone size\n                r_p_ol_new = (1.0 / (2.0 * np.pi)) * (K_max_ol / sigma_y)**2\n                # Overwrite old values\n                r_p_ol = r_p_ol_new\n                a_ol = a  # Use the *new* crack length as specified\n    \n    return a - a0\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2885943"}]}