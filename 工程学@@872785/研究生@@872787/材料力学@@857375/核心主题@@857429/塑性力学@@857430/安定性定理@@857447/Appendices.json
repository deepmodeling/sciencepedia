{"hands_on_practices": [{"introduction": "本实践探讨一个经典的热机工程问题：一个两端完全固定的杆件，在循环变化的温度作用下如何达到安定状态。通过构建一个不随时间变化的残余应力场，并将其与弹性热应力叠加，我们可以运用 Melan 的静力安定定理来确定结构能够承受的最大温度变化范围。这个练习旨在阐明残余应力在防止棘轮效应或交变塑性失效中的关键作用，是理解安定理论在材料和结构设计中实际应用的绝佳起点 [@problem_id:2916218]。", "problem": "一根长度为 $L$、横截面积恒定的棱柱形均质各向同性杆，其两端被完全约束以防止轴向位移。该材料遵循小应变、率无关的线性弹性行为，其杨氏模量为 $E$，直到在单轴拉伸/压缩下达到屈服应力 $\\sigma_{y}$ 而屈服，超过该点后材料表现为理想塑性。该杆具有恒定的线性热膨胀系数 $\\alpha$。它承受一个空间均匀、准静态的温度历史 $T(t)$，该温度在一个没有初始应力的参考温度上下，于 $-\\Delta T$ 和 $+\\Delta T$ 之间对称地重复循环。\n\n使用Melan静力安定定理以及叠加一个不随时间变化的残余应力场的思想，按以下步骤进行：\n\n- 设 $\\sigma^{e}(t)$ 表示在给定的热载荷下，如果塑性应变在任何时候都被约束为零，且满足与两端完全固定相符的轴向协调性时，所产生的弹性应力场。设 $\\sigma^{r}$ 是一个不随时间变化的残余应力，假定其在杆的横截面上均匀分布且沿杆的长度方向恒定。通过在每一时刻强制执行 $|\\sigma^{e}(t)+\\sigma^{r}|\\le \\sigma_{y}$，要求应力场 $\\sigma^{e}(t)+\\sigma^{r}$ 在循环过程中的所有时间内都保持在弹性域内。\n\n- 推导最大温度幅值 $\\Delta T_{\\text{crit}}$，使得存在至少一个常数 $\\sigma^{r}$，对于该常数，上述条件在整个对称循环 $T(t)\\in[-\\Delta T,\\,+\\Delta T]$ 中都成立。您的推导必须从基本的运动学和本构关系出发，并且除了安定条件的陈述外，不得假定任何专门的公式。\n\n将您关于 $\\Delta T_{\\text{crit}}$ 的最终答案表示为以 $E$、$\\sigma_{y}$ 和 $\\alpha$ 表示的单个闭式解析表达式。最终结果必须不带单位书写，但为了解释，$\\Delta T_{\\text{crit}}$ 应以开尔文表示。", "solution": "所述问题是有效的。这是一个在热弹塑性力学和结构力学领域中提法明确、有科学依据的问题，具体涉及Melan静力安定定理的应用。所有必要信息都已提供，目标明确且可形式化。我们将开始推导。\n\n问题要求找到最大温度幅值 $\\Delta T_{\\text{crit}}$，在此条件下，一个两端完全约束的单轴受载杆将会安定。安定意味着经过一段有限的初始塑性变形后，结构的响应变为纯弹性，且塑性应变累积停止。Melan静力安定定理为此提供了发生的条件。该定理指出，如果能够找到一个不随时间变化的自平衡残余应力场 $\\sigma^{r}$，使得该残余应力与纯弹性应力解 $\\sigma^{e}(t)$ 的和，在各处、对于所有变化的施加载荷都满足屈服准则，则安定发生。\n\n首先，我们必须确定纯弹性应力场 $\\sigma^{e}(t)$。杆是完全约束的，这意味着总轴向应变 $\\epsilon_{\\text{total}}$ 在任何时候都必须为零。\n总应变是弹性应变 ($\\epsilon^{e}$)、塑性应变 ($\\epsilon^{p}$) 和热应变 ($\\epsilon^{th}$) 的总和：\n$$ \\epsilon_{\\text{total}} = \\epsilon^{e} + \\epsilon^{p} + \\epsilon^{th} $$\n由于杆的两端是固定的，总伸长量为零，因此 $\\epsilon_{\\text{total}} = 0$。\n问题要求的是纯弹性应力响应，这是一个假设的应力场，其计算假设材料行为是纯弹性的，即为此计算目的将塑性应变约束为零 ($\\epsilon^{p}=0$)。\n因此，弹性分析的协调条件变为：\n$$ \\epsilon^{e} + \\epsilon^{th} = 0 $$\n热应变由 $\\epsilon^{th}(t) = \\alpha T(t)$ 给出，其中 $\\alpha$ 是热膨胀系数，$T(t)$ 是相对于无应力参考状态的温度变化。\n根据单轴应力的胡克定律，弹性应变与弹性应力 $\\sigma^{e}$ 相关：$\\epsilon^{e}(t) = \\frac{\\sigma^{e}(t)}{E}$，其中 $E$ 是杨氏模量。\n将这些本构关系代入协调方程，得到：\n$$ \\frac{\\sigma^{e}(t)}{E} + \\alpha T(t) = 0 $$\n由此，我们解出纯弹性应力作为温度的函数：\n$$ \\sigma^{e}(t) = -E \\alpha T(t) $$\n温度 $T(t)$ 在 $-\\Delta T$ 和 $+\\Delta T$ 之间对称循环。因此，我们可以确定在一个循环中弹性应力的最小值和最大值。\n最大弹性应力 $\\sigma^{e}_{\\text{max}}$ 出现在最低温度 $T = -\\Delta T$ 时：\n$$ \\sigma^{e}_{\\text{max}} = -E \\alpha (-\\Delta T) = E \\alpha \\Delta T $$\n这对应于一个拉应力。\n最小弹性应力 $\\sigma^{e}_{\\text{min}}$ 出现在最高温度 $T = +\\Delta T$ 时：\n$$ \\sigma^{e}_{\\text{min}} = -E \\alpha (+\\Delta T) = -E \\alpha \\Delta T $$\n这对应于一个压应力。\n\n现在，我们应用Melan安定定理。我们将一个不随时间变化的、空间均匀的残余应力 $\\sigma^{r}$ 叠加到弹性应力场上。任意时刻的总应力为 $\\sigma(t) = \\sigma^{e}(t) + \\sigma^{r}$。为使安定发生，这个总应力必须在所有时间 $t$ 内都保持在弹性域内。理想塑性材料的屈服准则是 $|\\sigma| \\le \\sigma_{y}$，其中 $\\sigma_{y}$ 是屈服应力。\n因此，安定条件是：\n$$ |\\sigma^{e}(t) + \\sigma^{r}| \\le \\sigma_{y} \\quad \\text{对所有 } t $$\n这个单一不等式等价于两个必须在所有时间内同时满足的条件：\n$$ -\\sigma_{y} \\le \\sigma^{e}(t) + \\sigma^{r} \\le \\sigma_{y} $$\n为了让这些不等式在整个循环中都成立，它们必须在最关键的点上成立，即弹性应力最大和最小的点。\n第一个不等式 $\\sigma^{e}(t) + \\sigma^{r} \\le \\sigma_{y}$ 在 $\\sigma^{e}(t)$ 达到最大值时最为严格。所以，我们必须满足：\n$$ \\sigma^{e}_{\\text{max}} + \\sigma^{r} \\le \\sigma_{y} \\quad (1) $$\n第二个不等式 $\\sigma^{e}(t) + \\sigma^{r} \\ge -\\sigma_{y}$ 在 $\\sigma^{e}(t)$ 达到最小值时最为严格。所以，我们必须满足：\n$$ \\sigma^{e}_{\\text{min}} + \\sigma^{r} \\ge -\\sigma_{y} \\quad (2) $$\n这两个不等式定义了残余应力 $\\sigma^{r}$ 可能取值的范围：\n由(1)得：\n$$ \\sigma^{r} \\le \\sigma_{y} - \\sigma^{e}_{\\text{max}} $$\n由(2)得：\n$$ \\sigma^{r} \\ge -\\sigma_{y} - \\sigma^{e}_{\\text{min}} $$\n一个有效的残余应力 $\\sigma^{r}$ 存在的充要条件是 $\\sigma^{r}$ 的下界小于或等于其上界：\n$$ -\\sigma_{y} - \\sigma^{e}_{\\text{min}} \\le \\sigma_{y} - \\sigma^{e}_{\\text{max}} $$\n重新排列这个不等式，将弹性应力和屈服应力分组，我们得到：\n$$ \\sigma^{e}_{\\text{max}} - \\sigma^{e}_{\\text{min}} \\le 2\\sigma_{y} $$\n这是对称加载循环中安定的基本条件。它表明纯弹性应力的总范围 $\\Delta\\sigma^{e} = \\sigma^{e}_{\\text{max}} - \\sigma^{e}_{\\text{min}}$ 不得超过两倍的屈服应力。\n现在让我们代入 $\\sigma^{e}_{\\text{max}}$ 和 $\\sigma^{e}_{\\text{min}}$ 的表达式：\n$$ (E \\alpha \\Delta T) - (-E \\alpha \\Delta T) \\le 2\\sigma_{y} $$\n$$ 2 E \\alpha \\Delta T \\le 2\\sigma_{y} $$\n简化这个不等式，得到使安定成为可能的温度幅值 $\\Delta T$ 的条件：\n$$ E \\alpha \\Delta T \\le \\sigma_{y} $$\n$$ \\Delta T \\le \\frac{\\sigma_{y}}{E \\alpha} $$\n问题要求的是能够发生安定的最大温度幅值 $\\Delta T_{\\text{crit}}$。这对应于不等式变为等式的边界情况。\n因此，临界温度幅值为：\n$$ \\Delta T_{\\text{crit}} = \\frac{\\sigma_{y}}{E \\alpha} $$\n如果 $\\Delta T > \\Delta T_{\\text{crit}}$，弹性应力范围 $2 E \\alpha \\Delta T$ 将大于 $2\\sigma_{y}$，就不可能找到一个残余应力 $\\sigma^r$ 使得总应力在整个循环中都保持在屈服极限内。在这种情况下，结构将表现出棘轮效应或交替塑性，意味着每个循环中都会发生塑性变形，而无法达到安定状态。", "answer": "$$\\boxed{\\frac{\\sigma_{y}}{E \\alpha}}$$", "id": "2916218"}, {"introduction": "在理解了静力安定定理的基本应用后，我们转向一个更复杂的结构——刚接门式框架。此练习的独特之处在于，它要求我们同时运用 Melan 的静力（下限）定理和 Koiter 的运动（上限）定理来求解安定极限。通过证明这两种理论方法得出的边界值完全吻合，我们不仅能得到问题的精确解，还能深刻体会到安定理论的完备性与优雅性 [@problem_id:2684276]。", "problem": "考虑一个单跨单层刚接门式框架，由两个高度为 $h$ 的相同棱柱形柱子组成，通过一根具有无限抗弯强度的刚性梁连接。材料表现为理想弹塑性，在两根柱子的顶部和底部的潜在塑性铰位置，其全塑性弯矩承载力 $M_p$ 处处相等。适用小位移运动学，且可忽略几何非线性。不存在竖向重力荷载。\n\n结构承受一个作用在梁上的准静态、零均值、重复水平点荷载，其形式为 $H(t)=\\lambda\\,H_0\\,s(t)$，其中 $H_00$ 是给定的参考荷载，$\\lambda0$ 是一个未知的标量荷载乘子，$s(t)$ 是一个有界标量函数，在所有时间 $t$ 内满足 $-1\\le s(t)\\le 1$，并在重复循环中取遍该区间内的所有极值。假设采用相关联、速率无关的无硬化塑性理论，且塑性变形仅以理想塑性铰的形式集中在柱顶和柱底。\n\n仅使用刚塑性机构的基本运动学、虚功原理以及 Melan 静力安定定理（下限法）和 Koiter 运动安定定理（上限法）的定义，完成以下任务：\n\n- 构建一个静力容许的、不随时间变化的残余弯矩场，以根据 Melan 静力安定定理证明在某个最大 $\\lambda$ 值下结构发生安定，并推导相应的 $\\lambda$ 的下限。\n\n- 构建一个与框架和荷载集相容的、形状不随时间变化的单参数机动容许塑性机构，并使用 Koiter 运动安定定理推导相应的 $\\lambda$ 的上限。\n\n证明对于此框架和荷载，这两个界限重合，并得出精确的安定乘子 $\\lambda_{\\mathrm{sh}}$ 的一个以 $M_p$、$h$ 和 $H_0$ 表示的封闭形式表达式。\n\n你的最终答案必须是 $\\lambda_{\\mathrm{sh}}$ 的单一解析表达式。请用 $M_p$、$h$ 和 $H_0$ 的符号表示你的最终答案。最终方框内的答案不要包含单位。", "solution": "问题陈述需要经过验证。\n\n**步骤1：提取已知条件**\n- 结构：单跨单层刚接门式框架。\n- 柱：两根相同的棱柱形柱，高度为 $h$。\n- 梁：刚性，抗弯强度无限大。\n- 材料行为：理想弹塑性。\n- 塑性承载力：柱顶和柱底的全塑性弯矩 $M_p$ 处处相等。\n- 运动学：适用小位移理论；忽略几何非线性。\n- 重力荷载：无。\n- 荷载：作用在梁上的准静态、零均值、重复水平点荷载 $H(t)=\\lambda\\,H_0\\,s(t)$。\n- 荷载参数：$H_00$（参考荷载），$\\lambda0$（荷载乘子），时间函数 $s(t)$ 有界，即在所有时间 $t$ 内满足 $-1 \\le s(t) \\le 1$，且覆盖此区间内的所有值。\n- 塑性模型：相关联、速率无关、无硬化，塑性变形集中在四个理想塑性铰位置（柱顶和柱底）。\n\n**步骤2：使用提取的已知条件进行验证**\n- 该问题具有**科学依据**。这是结构塑性安定理论中的一个经典问题，利用了 Melan 和 Koiter 的基本定理。相关假设（理想弹塑性材料、理想塑性铰、刚性梁）是结构分析中的标准理想化方法。\n- 该问题是**适定的**。其几何形状、材料属性和荷载都有明确定义。目标是找到一个特定、唯一的值，即安定乘子 $\\lambda_{\\mathrm{sh}}$。\n- 该问题是**客观的**。其语言技术性强且精确，没有主观或模糊的术语。\n- 问题陈述是自洽的，不包含矛盾信息。所做的理想化与求解所需的方法（安定定理）是一致的。\n\n**步骤3：结论与行动**\n该问题被判定为**有效**。将提供解答。\n\n**弹性响应分析**\n\n门式框架的几何形状是对称的，荷载水平作用于梁上。梁被指定为具有无限抗弯强度，意味着它是刚性的且不发生弯曲。由于结构和荷载的整体对称性，刚性梁将水平平移而无转动。因此，两根柱子的顶部经历相等的水平位移 $\\Delta(t)$，但没有转动。柱底是固定的，因此既不发生平移也不发生转动。\n\n因此，每根高度为 $h$ 的柱子都处于两端固定的状态（底部固定，顶部抗转动固定），并承受横向剪力。总水平荷载 $H(t)$ 平均分配到两根相同的柱子上，所以每根柱子中的剪力为 $V(t) = \\frac{H(t)}{2}$。\n\n对于一根两端固定、高度为 $h$ 且承受剪力 $V$ 的柱子，其顶部和底部产生的弯矩大小相等，方向相同。端部弯矩 $M$ 与剪力 $V$ 之间的关系由 $M_{top} + M_{base} = V h$ 给出。由于 $M_{top} = M_{base} = M^E$，我们有 $2M^E = Vh$，从而得到 $M^E = \\frac{Vh}{2}$。\n\n代入 $V(t) = \\frac{H(t)}{2}$，所有四个潜在塑性铰位置（每根柱的顶部和底部）的弹性弯矩 $M^E(t)$ 是相同的：\n$$ M^E(t) = \\frac{1}{2} \\left( \\frac{H(t)}{2} \\right) h = \\frac{H(t)h}{4} $$\n使用给定的荷载表达式 $H(t) = \\lambda H_0 s(t)$，弹性弯矩为：\n$$ M^E(t) = \\frac{\\lambda H_0 h}{4} s(t) $$\n由于函数 $s(t)$ 在区间 $[-1, 1]$ 内变化，因此四个位置中每个位置的弹性弯矩包络为：\n$$ M^E_{max} = \\frac{\\lambda H_0 h}{4} $$\n$$ M^E_{min} = -\\frac{\\lambda H_0 h}{4} $$\n因此，弹性弯矩的范围是：\n$$ \\Delta M^E = M^E_{max} - M^E_{min} = \\frac{\\lambda H_0 h}{4} - \\left(-\\frac{\\lambda H_0 h}{4}\\right) = \\frac{\\lambda H_0 h}{2} $$\n\n**使用 Melan 静力定理求解 $\\lambda_{\\mathrm{sh}}$ 的下限**\n\nMelan 定理指出，如果存在一个不随时间变化、自平衡的残余弯矩场 $M^r$，使得弹性弯矩 $M^E(t)$ 与残余弯矩 $M^r$ 的叠加在任何点和任何时间都不违反屈服条件，则结构将发生安定（即，在经历一个初始的塑性变形阶段后，完全弹性响应）。屈服条件为 $|M| \\le M_p$。\n\n因此，为使安定发生，我们必须找到一个自平衡的 $M^r$ 场，使得对于每个潜在的塑性铰位置 $i$：\n$$ |M^E_i(t) + M^r_i| \\le M_p \\quad \\forall t $$\n由于所有四个位置的弹性弯矩都相同，我们可以省略 $M^E$ 的下标 $i$。该条件等价于以下两个不等式：\n$$ M^E_{max} + M^r_i \\le M_p $$\n$$ M^E_{min} + M^r_i \\ge -M_p $$\n代入 $M^E_{max}$ 和 $M^E_{min}$ 的表达式：\n$$ \\frac{\\lambda H_0 h}{4} + M^r_i \\le M_p \\implies M^r_i \\le M_p - \\frac{\\lambda H_0 h}{4} $$\n$$ -\\frac{\\lambda H_0 h}{4} + M^r_i \\ge -M_p \\implies M^r_i \\ge -M_p + \\frac{\\lambda H_0 h}{4} $$\n为了使 $M^r_i$ 的值存在，下限必须小于或等于上限：\n$$ -M_p + \\frac{\\lambda H_0 h}{4} \\le M_p - \\frac{\\lambda H_0 h}{4} $$\n$$ \\frac{\\lambda H_0 h}{2} \\le 2 M_p $$\n$$ \\lambda \\le \\frac{4 M_p}{H_0 h} $$\n这个不等式确定了任何安定解可能存在的 $\\lambda$ 的最大可能值。为确认这是一个可达到的下限，我们必须证明对于这个 $\\lambda$ 值，存在一个有效的自平衡残余弯矩场。\n\n让我们测试特定的荷载乘子 $\\lambda = \\frac{4 M_p}{H_0 h}$。对于这个值，关于 $M^r_i$ 的条件变为：\n$$ M^r_i \\le M_p - \\frac{1}{4} \\left(\\frac{4 M_p}{H_0 h}\\right) H_0 h = M_p - M_p = 0 $$\n$$ M^r_i \\ge -M_p + \\frac{1}{4} \\left(\\frac{4 M_p}{H_0 h}\\right) H_0 h = -M_p + M_p = 0 $$\n这两个条件共同要求所有四个位置 $i=1,2,3,4$ 的 $M^r_i=0$。平凡场 $M^r_i = 0$ 是一个有效的自平衡残余弯矩场。因此，根据 Melan 定理，当 $\\lambda \\le \\frac{4 M_p}{H_0 h}$ 时，结构保证会安定。这提供了安定乘子的下限：\n$$ \\lambda_{\\mathrm{sh}} \\ge \\frac{4 M_p}{H_0 h} $$\n\n**使用 Koiter 运动安定定理求解 $\\lambda_{\\mathrm{sh}}$ 的上限**\n\nKoiter 定理指出，如果能找到一个机动容许的塑性机构，使得在该机构的一个塑性变形循环中，弹性应力所做的功大于或等于塑性机构内部耗散的能量，则结构不会发生安定。破坏可能以增量坍塌（棘轮效应）或交变塑性（低周疲劳）的形式发生。由于所施加的荷载是零均值的，增量坍塌不是预期的破坏模式。我们研究由交变塑性引起的破坏。\n\n如果一个位置的弹性应力（或弯矩）范围超过屈服强度（或塑性弯矩承载力）的两倍，该位置就会发生交变塑性。我们可以通过构建一个合适的塑性变形循环，用 Koiter 定理来形式化这个问题。\n\n考虑一个机动容许机构，它由单个塑性铰位置（例如，位置1，即左柱底部）的一个塑性循环组成。设该循环包含一个 $+\\Delta\\theta_p$ 的塑性转动，随后是一个 $-\\Delta\\theta_p$ 的塑性转动，使塑性铰返回其初始方向。\n\n在此循环中耗散的总内能为：\n$$ D_{cycle} = \\int_{cycle} |M_p d\\theta_p| = M_p |+\\Delta\\theta_p| + M_p |-\\Delta\\theta_p| = 2M_p \\Delta\\theta_p $$\n在这个塑性循环中，弹性弯矩 $M_1^E(t)$ 所做的功为 $W^E_{cycle} = \\int_{cycle} M_1^E(t) d\\theta_p(t)$。为了获得安定的上限（即找到确定会发生破坏的荷载），我们考虑最不利的情况，即功被最大化。这种情况发生在正塑性转动 $+\\Delta\\theta_p$ 恰好在弹性弯矩 $M_1^E(t)$ 达到其最大值 $M^E_{max}$ 时发生，而负塑性转动 $-\\Delta\\theta_p$ 在弯矩达到其最小值 $M^E_{min}$ 时发生。\n$$ W^E_{cycle, max} = M^E_{max} (\\Delta\\theta_p) + M^E_{min} (-\\Delta\\theta_p) = (M^E_{max} - M^E_{min}) \\Delta\\theta_p = \\Delta M^E \\Delta\\theta_p $$\n代入弹性弯矩范围 $\\Delta M^E = \\frac{\\lambda H_0 h}{2}$：\n$$ W^E_{cycle, max} = \\frac{\\lambda H_0 h}{2} \\Delta\\theta_p $$\n根据 Koiter 定理，如果 $W^E_{cycle, max} \\ge D_{cycle}$，则安定破坏必定发生。\n$$ \\frac{\\lambda H_0 h}{2} \\Delta\\theta_p \\ge 2M_p \\Delta\\theta_p $$\n两边除以 $\\Delta\\theta_p  0$：\n$$ \\frac{\\lambda H_0 h}{2} \\ge 2M_p \\implies \\lambda \\ge \\frac{4 M_p}{H_0 h} $$\n此条件提供了安定乘子的一个上限。如果 $\\lambda$ 大于或等于这个值，结构必定会破坏。\n$$ \\lambda_{\\mathrm{sh}} \\le \\frac{4 M_p}{H_0 h} $$\n\n**结论**\n\n通过 Melan 定理进行的静力（下限）分析得出 $\\lambda_{\\mathrm{sh}} \\ge \\frac{4 M_p}{H_0 h}$。\n通过 Koiter 定理进行的运动（上限）分析得出 $\\lambda_{\\mathrm{sh}} \\le \\frac{4 M_p}{H_0 h}$。\n\n由于安定乘子的下限和上限重合，我们确定了其精确值：\n$$ \\lambda_{\\mathrm{sh}} = \\frac{4 M_p}{H_0 h} $$\n该值对应于结构的弹性极限，此时最大弹性弯矩等于塑性弯矩承载力。对于这个具有零均值循环荷载的特定问题，不存在一个荷载乘子范围，使得有限的塑性变形能导致有利的残余应力状态和随后的弹性安定。一旦达到弹性极限，结构就会因交变塑性而破坏。", "answer": "$$\n\\boxed{\\frac{4 M_p}{H_0 h}}\n$$", "id": "2684276"}, {"introduction": "为了将抽象的安定理论与现代工程实践相结合，本练习将引导你把静力安定问题转化为一个线性规划（Linear Programming, LP）问题。对于由多面体定义的屈服准则，安定条件可以被精确地表述为一系列线性的等式和不等式约束。这个实践要求你为离散化的应力空间构建一个LP模型，以数值方式计算最大安定荷载因子，这充分展示了如何利用计算工具来解决复杂的安定性分析问题 [@problem_id:2916223]。", "problem": "考虑基于 Melan 定理在离散化应力空间上建立的静态（下界）安定验证。设结构由应力合力向量 $s \\in \\mathbb{R}^n$ 和不随时间变化的残余应力 $r \\in \\mathbb{R}^n$ 表示。设容许应力域为多面体集 $\\{s \\in \\mathbb{R}^n : \\lvert s_i \\rvert \\le \\sigma_y, \\, i = 1,\\dots,n\\}$，其中给定屈服极限 $\\sigma_y \\gt 0$（这是无穷范数 Tresca 型近似）。设残余应力的平衡由一个满秩线性算子 $E \\in \\mathbb{R}^{q \\times n}$ 表示，使得容许的残余应力满足 $E r = 0$。设荷载在一个凸紧集内变化，其极点由 $m$ 个弹性应力影响向量 $\\{p^{(k)} \\in \\mathbb{R}^n\\}_{k=1}^m$ 表示。对于荷载因子 $\\lambda \\ge 0$，Melan 静态安定条件要求存在一个残余应力 $r$，使得对于每个极限荷载 $k \\in \\{1,\\dots,m\\}$，\n$$\nr + \\lambda \\, p^{(k)} \\in \\{s \\in \\mathbb{R}^n : \\lvert s_i \\rvert \\le \\sigma_y, \\, i=1,\\dots,n\\},\n\\quad \\text{and} \\quad E r = 0.\n$$\n根据线性性和凸性，只需在有限的极值点集上检查不等式即可。\n\n任务：\n- 从第一性原理出发，推导一个线性规划公式，该公式计算最大安定荷载因子 $\\lambda^\\star$，并在所有达到 $\\lambda^\\star$ 的残余应力中，选择一个具有最小 $\\ell_1$ 范数的残余应力。您必须通过以下方式完成此任务：\n  1. 建立一个以 $(r,\\lambda)$ 为变量的线性规划，在给定的 $m$ 个荷载极值下的平衡和屈服约束下最大化 $\\lambda$。\n  2. 建立第二个以 $(r,t)$ 为变量的线性规划，在将 $\\lambda$ 固定为最优值 $\\lambda^\\star$ 的情况下，最小化 $\\sum_{i=1}^n t_i$，约束条件为 $t_i \\ge \\lvert r_i \\rvert$、相同的平衡约束以及在 $\\lambda^\\star$ 处评估的相同屈服约束。\n- 您的程序必须仅使用数据 $(\\sigma_y, E, \\{p^{(k)}\\}_{k=1}^m)$ 来实现这两个线性规划。\n\n程序需要编码的数学公式要求：\n- 对第一个线性规划，使用残余应力 $r \\in \\mathbb{R}^n$ 和荷载因子 $\\lambda \\in \\mathbb{R}$ 作为决策变量。施加 $\\lambda \\ge 0$。对于每个极值 $k \\in \\{1,\\dots,m\\}$ 和分量 $i \\in \\{1,\\dots,n\\}$，通过以下一对线性不等式强制实施屈服容许性\n$$\nr_i + \\lambda \\, p^{(k)}_i \\le \\sigma_y, \\qquad -r_i - \\lambda \\, p^{(k)}_i \\le \\sigma_y,\n$$\n并通过 $E r = 0$ 施加平衡约束。最大化 $\\lambda$。\n- 对于第二个线性规划，固定 $\\lambda = \\lambda^\\star$ 并引入辅助变量 $t \\in \\mathbb{R}^n$，其中 $t_i \\ge 0$ 且\n$$\nr_i - t_i \\le 0, \\qquad -r_i - t_i \\le 0,\n$$\n这些条件共同意味着 $t_i \\ge \\lvert r_i \\rvert$。在这些约束、$E r = 0$ 以及将 $\\lambda$ 替换为 $\\lambda^\\star$ 的相同屈服约束下，最小化 $\\sum_{i=1}^n t_i$。\n\n实现与输出：\n- 实现一个程序，对于下面的每个测试用例，返回数对 $[\\lambda^\\star, \\|r^\\star\\|_1]$，其中 $\\lambda^\\star$ 是第一个线性规划的最优荷载因子，$\\|r^\\star\\|_1$ 是第二个线性规划在 $\\lambda^\\star$ 时的最优值 $\\sum_{i=1}^n t_i$。\n- 您的程序必须输出一行，其中包含结果，格式为逗号分隔的列表的列表，每个测试用例一个列表，每个浮点数四舍五入到 $6$ 位小数，例如 $\\big[\\,[\\lambda_1^\\star,\\|r_1^\\star\\|_1],[\\lambda_2^\\star,\\|r_2^\\star\\|_1]\\,\\big]$。\n\n测试套件：\n- 使用三个案例，每个案例由 $(n,m,\\sigma_y,E,\\{p^{(k)}\\}_{k=1}^m)$ 指定：\n  1. 案例 A（理想情况，对称极值）：$n = 2$，$m = 2$，$\\sigma_y = 1$，$E = \\begin{bmatrix} 1  1 \\end{bmatrix}$，$p^{(1)} = \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix}$，$p^{(2)} = \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix}$。\n  2. 案例 B（通过平衡进行缩放和耦合）：$n = 2$，$m = 2$，$\\sigma_y = \\tfrac{3}{2}$，$E = \\begin{bmatrix} 1  -1 \\end{bmatrix}$，$p^{(1)} = \\begin{bmatrix} 1 \\\\ 1 \\end{bmatrix}$，$p^{(2)} = \\begin{bmatrix} 1 \\\\ -1 \\end{bmatrix}$。\n  3. 案例 C（需要非平凡残余应力的非对称极值）：$n = 2$，$m = 2$，$\\sigma_y = 1$，$E = \\begin{bmatrix} 1  1 \\end{bmatrix}$，$p^{(1)} = \\begin{bmatrix} 2 \\\\ -1 \\end{bmatrix}$，$p^{(2)} = \\begin{bmatrix} -1 \\\\ 2 \\end{bmatrix}$。\n\n最终输出格式：\n- 程序必须精确打印一行：一个包含三个条目的列表，每个条目是案例的列表 $[\\lambda^\\star,\\|r^\\star\\|_1]$，没有空格，每个数字四舍五入到 $6$ 位小数，即 $\\big[\\,[\\lambda_A^\\star,\\|r_A^\\star\\|_1],[\\lambda_B^\\star,\\|r_B^\\star\\|_1],[\\lambda_C^\\star,\\|r_C^\\star\\|_1]\\,\\big]$。", "solution": "我们从 Melan 静态安定定理开始，该定理指出，如果一个结构承受来自凸紧荷载域的可变荷载，只要存在一个不随时间变化、自平衡的残余应力 $r$，使得对于所有容许的荷载历史，总应力保持在弹性域内，则该结构最终会安定下来（长期来看不再发生塑性变形）。在离散化设置中，对荷载的弹性应力响应可以表示为 $p \\in \\mathbb{R}^n$，容许应力域是一个凸集 $Y \\subset \\mathbb{R}^n$。静态（下界）声明确保，如果存在一个满足 $E r = 0$ 的 $r$，使得对于凸荷载集中的所有 $p$ 和某个最大 $\\lambda$，$r + \\lambda p \\in Y$，则结构会安定。因为荷载集是凸的，且约束 $r + \\lambda p \\in Y$ 对 $p$ 是凸的，所以只需检查有限个极值点 $\\{p^{(k)}\\}_{k=1}^m$。\n\n为了获得线性或二阶锥规划，我们必须选择 $Y$ 作为一个具有易于处理的不等式的凸集。如果我们选择 von Mises (J$_2$) 屈服域，条件 $\\|r + \\lambda p^{(k)}\\|_2 \\le \\sigma_y$ 是二阶锥可表示的。为了保持在线性规划的框架内，我们采用多面体 Tresca/无穷范数近似：\n$$\nY = \\{ s \\in \\mathbb{R}^n : -\\sigma_y \\le s_i \\le \\sigma_y, \\, i=1,\\dots,n \\}.\n$$\n然后，强制 $r + \\lambda p^{(k)} \\in Y$ 等价于对每个分量 $i$ 和极值 $k$ 的一对线性不等式：\n$$\nr_i + \\lambda p^{(k)}_i \\le \\sigma_y, \\qquad -r_i - \\lambda p^{(k)}_i \\le \\sigma_y.\n$$\n此外，$r$ 必须是自平衡的，由线性方程组 $E r = 0$ 编码。\n\n第一个线性规划（最大化荷载因子）。将决策变量集合为 $(r,\\lambda) \\in \\mathbb{R}^{n+1}$ 并施加 $\\lambda \\ge 0$。该线性规划为\n$$\n\\begin{aligned}\n\\max_{r \\in \\mathbb{R}^n,\\, \\lambda \\in \\mathbb{R}} \\  \\lambda \\\\\n\\text{subject to } \\  r_i + \\lambda p^{(k)}_i \\le \\sigma_y, \\quad i=1,\\dots,n,\\ k=1,\\dots,m, \\\\\n -r_i - \\lambda p^{(k)}_i \\le \\sigma_y, \\quad i=1,\\dots,n,\\ k=1,\\dots,m, \\\\\n E r = 0, \\\\\n \\lambda \\ge 0,\n\\end{aligned}\n$$\n其中 $r$ 是自由变量。因为对于不同的 $k$，约束将相同的 $r$ 与不同的 $\\lambda p^{(k)}$ 耦合起来，并且 $E r = 0$ 限制了 $r$，所以对于非平凡的 $\\{p^{(k)}\\}$ 集合，该问题是适定且有界的。\n\n第二个线性规划（在 $\\lambda^\\star$ 处的最小 $\\ell_1$ 范数残余应力）。固定从第一个规划中获得的 $\\lambda = \\lambda^\\star$，并引入辅助变量 $t \\in \\mathbb{R}^n$，其中 $t_i \\ge 0$ 且 $t_i \\ge \\lvert r_i \\rvert$。标准线性化使用\n$$\nr_i - t_i \\le 0, \\qquad -r_i - t_i \\le 0, \\qquad t_i \\ge 0,\n$$\n这意味着 $t_i \\ge \\lvert r_i \\rvert$，因此 $\\sum_i t_i \\ge \\sum_i \\lvert r_i \\rvert = \\|r\\|_1$。最小化 $\\sum_i t_i$ 可以在所有维持 $\\lambda^\\star$ 的残余应力中实现最小的 $\\ell_1$ 范数。该线性规划为\n$$\n\\begin{aligned}\n\\min_{r \\in \\mathbb{R}^n,\\, t \\in \\mathbb{R}^n} \\  \\sum_{i=1}^n t_i \\\\\n\\text{subject to } \\  r_i + \\lambda^\\star p^{(k)}_i \\le \\sigma_y, \\quad i=1,\\dots,n,\\ k=1,\\dots,m, \\\\\n -r_i - \\lambda^\\star p^{(k)}_i \\le \\sigma_y, \\quad i=1,\\dots,n,\\ k=1,\\dots,m, \\\\\n r_i - t_i \\le 0, \\quad -r_i - t_i \\le 0, \\quad t_i \\ge 0, \\quad i=1,\\dots,n, \\\\\n E r = 0.\n\\end{aligned}\n$$\n\n算法转换：\n- 通过为每个 $k$ 和 $i$ 堆叠行来组合屈服约束的不等式矩阵：一行中 $r_i$ 和 $\\lambda$ 的系数分别为 $1$ 和 $p^{(k)}_i$，另一行中分别为 $-1$ 和 $-p^{(k)}_i$。两种情况下，右侧均为 $\\sigma_y$。\n- 对于第一个线性规划，使用目标向量 $c = [0,\\dots,0,-1]$ 来最小化 $- \\lambda$（即最大化 $\\lambda$）。\n- 对于第二个线性规划，将 $\\lambda = \\lambda^\\star$ 固定为常数，并为变量 $(r,t)$ 组合不等式，捕捉屈服和绝对值线性化，目标向量 $c = [0,\\dots,0,1,\\dots,1]$ 用于求和 $t_i$。\n- 在两个程序中都将 $E r = 0$ 作为等式约束强制执行。\n- 使用可靠的线性规划求解器求解线性规划。用于线性规划的 SciPy 例程通过 HiGHS 后端支持这些。\n\n测试套件的原理和覆盖范围：\n- 案例 A 使用对称极值和单一平衡约束 $r_1 + r_2 = 0$，这会产生一个明确、有界的最大荷载因子 $\\lambda^\\star$，并演示多个极值如何耦合单个 $r$。\n- 案例 B 将屈服极限缩放至 $\\sigma_y = \\tfrac{3}{2}$，并使用 $r_1 - r_2 = 0$ 形式的 $E r = 0$，探讨平衡空间如何修改容许残余应力，并展示在这种离散设置下 $\\lambda^\\star$ 与 $\\sigma_y$ 的预期线性缩放关系。\n- 案例 C 使用与案例 A 相同的平衡约束，但具有非对称极值 $p^{(1)}$ 和 $p^{(2)}$，旨在需要一个非平凡的残余应力才能达到最大 $\\lambda^\\star$，从而对第二个线性规划进行测试。\n\n输出规范：\n- 对于每个案例，以浮点数形式报告数对 $[\\lambda^\\star,\\|r^\\star\\|_1]$，四舍五入到 $6$ 位小数，并将它们聚合到一个列表中，打印在没有空格的一行上：$\\big[\\,[\\lambda_A^\\star,\\|r_A^\\star\\|_1],[\\lambda_B^\\star,\\|r_B^\\star\\|_1],[\\lambda_C^\\star,\\|r_C^\\star\\|_1]\\,\\big]$。\n\n上述公式严格遵循应用于离散化应力模型的线性化 Melan 静态定理，仅使用平衡和屈服容许性的基本定义，并利用凸性将验证限制在有限的荷载极值集上。由此产生的程序是线性的，因此对于指定的小维测试套件可以高效、稳健地求解。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef solve_case_sigma_E_P(sigma_y, E, P_list):\n    \"\"\"\n    Solve the two-stage shakedown LP:\n    Stage 1: maximize lambda subject to yield constraints at extremes and equilibrium E r = 0\n    Stage 2: with lambda* fixed, minimize ||r||_1 using standard LP linearization with t = |r|\n    Inputs:\n        sigma_y: float  0\n        E: (q, n) numpy array\n        P_list: list of m numpy arrays of shape (n,) representing elastic stress influence at extremes\n    Returns:\n        lambda_star: float\n        l1_min: float (sum of t_i at optimum, equals minimal ||r||_1)\n    \"\"\"\n    # Dimensions\n    n = P_list[0].shape[0]\n    m = len(P_list)\n    q = E.shape[0] if E is not None and E.size  0 else 0\n\n    # Stage 1: LP in variables x = [r (n), lambda (1)]\n    # Build inequality constraints A_ub x = b_ub for yield at each extreme\n    A_ub = []\n    b_ub = []\n    for k in range(m):\n        p_k = P_list[k].reshape(-1)\n        for i in range(n):\n            # r_i + lambda * p_k[i] = sigma_y\n            row = np.zeros(n + 1)\n            row[i] = 1.0\n            row[-1] = p_k[i]\n            A_ub.append(row)\n            b_ub.append(sigma_y)\n            # -r_i - lambda * p_k[i] = sigma_y\n            row = np.zeros(n + 1)\n            row[i] = -1.0\n            row[-1] = -p_k[i]\n            A_ub.append(row)\n            b_ub.append(sigma_y)\n    A_ub = np.array(A_ub) if A_ub else None\n    b_ub = np.array(b_ub) if b_ub else None\n\n    # Equality constraints: E r = 0\n    if q  0:\n        A_eq = np.zeros((q, n + 1))\n        A_eq[:, :n] = E\n        b_eq = np.zeros(q)\n    else:\n        A_eq = None\n        b_eq = None\n\n    # Variable bounds: r free, lambda = 0\n    bounds = [(None, None)] * n + [(0.0, None)]\n\n    # Objective: minimize -lambda\n    c = np.zeros(n + 1)\n    c[-1] = -1.0\n\n    res1 = linprog(c, A_ub=A_ub, b_ub=b_ub, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method=\"highs\")\n    if not res1.success:\n        # In unexpected failure cases, return NaNs to signal an issue.\n        return float(\"nan\"), float(\"nan\")\n\n    x_star = res1.x\n    lambda_star = x_star[-1]\n\n    # Stage 2: LP in variables y = [r (n), t (n)]\n    # Fix lambda = lambda_star in the yield constraints (becomes a constant RHS shift)\n    A_ub2 = []\n    b_ub2 = []\n\n    for k in range(m):\n        p_k = P_list[k].reshape(-1)\n        for i in range(n):\n            # r_i + lambda_star * p_k[i] = sigma_y\n            row = np.zeros(2 * n)\n            row[i] = 1.0  # r_i\n            # no coefficient on t here\n            A_ub2.append(row)\n            b_ub2.append(sigma_y - lambda_star * p_k[i])\n            # -r_i - lambda_star * p_k[i] = sigma_y  -  -r_i = sigma_y + lambda_star * p_k[i]\n            row = np.zeros(2 * n)\n            row[i] = -1.0  # -r_i\n            A_ub2.append(row)\n            b_ub2.append(sigma_y + lambda_star * p_k[i])\n\n    # Absolute value linearization: r_i - t_i = 0 and -r_i - t_i = 0, and t_i = 0\n    for i in range(n):\n        row = np.zeros(2 * n)\n        row[i] = 1.0      # r_i\n        row[n + i] = -1.0 # -t_i\n        A_ub2.append(row)\n        b_ub2.append(0.0)\n\n        row = np.zeros(2 * n)\n        row[i] = -1.0     # -r_i\n        row[n + i] = -1.0 # -t_i\n        A_ub2.append(row)\n        b_ub2.append(0.0)\n\n    A_ub2 = np.array(A_ub2) if A_ub2 else None\n    b_ub2 = np.array(b_ub2) if b_ub2 else None\n\n    # Equality constraints: E r = 0\n    if q  0:\n        A_eq2 = np.zeros((q, 2 * n))\n        A_eq2[:, :n] = E\n        b_eq2 = np.zeros(q)\n    else:\n        A_eq2 = None\n        b_eq2 = None\n\n    # Bounds: r free, t = 0\n    bounds2 = [(None, None)] * n + [(0.0, None)] * n\n\n    # Objective: minimize sum t_i\n    c2 = np.zeros(2 * n)\n    c2[n:] = 1.0\n\n    res2 = linprog(c2, A_ub=A_ub2, b_ub=b_ub2, A_eq=A_eq2, b_eq=b_eq2, bounds=bounds2, method=\"highs\")\n    if not res2.success:\n        return float(lambda_star), float(\"nan\")\n\n    y_star = res2.x\n    t_star = y_star[n:]\n    l1_min = float(np.sum(t_star))\n\n    return float(lambda_star), float(l1_min)\n\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Case A\n    sigma_A = 1.0\n    E_A = np.array([[1.0, 1.0]])\n    P_A = [np.array([1.0, 0.0]), np.array([0.0, 1.0])]\n\n    # Case B\n    sigma_B = 1.5\n    E_B = np.array([[1.0, -1.0]])\n    P_B = [np.array([1.0, 1.0]), np.array([1.0, -1.0])]\n\n    # Case C\n    sigma_C = 1.0\n    E_C = np.array([[1.0, 1.0]])\n    P_C = [np.array([2.0, -1.0]), np.array([-1.0, 2.0])]\n\n    test_cases = [\n        (sigma_A, E_A, P_A),\n        (sigma_B, E_B, P_B),\n        (sigma_C, E_C, P_C),\n    ]\n\n    results = []\n    for sigma_y, E, P_list in test_cases:\n        lam_star, l1_norm = solve_case_sigma_E_P(sigma_y, E, P_list)\n        # Round to 6 decimals for output\n        lam_star = float(np.round(lam_star, 6)) if np.isfinite(lam_star) else lam_star\n        l1_norm = float(np.round(l1_norm, 6)) if np.isfinite(l1_norm) else l1_norm\n        results.append((lam_star, l1_norm))\n\n    # Final print statement in the exact required format: no spaces, numbers with 6 decimals.\n    formatted = []\n    for lam, nrm in results:\n        if np.isnan(lam) or np.isnan(nrm):\n            # Represent NaNs in a consistent float format with 6 decimals\n            lam_str = \"nan\"\n            nrm_str = \"nan\"\n        else:\n            lam_str = f\"{lam:.6f}\"\n            nrm_str = f\"{nrm:.6f}\"\n        formatted.append(f\"[{lam_str},{nrm_str}]\")\n    print(f\"[[{results[0][0]:.6f},{results[0][1]:.6f}],[{results[1][0]:.6f},{results[1][1]:.6f}],[{results[2][0]:.6f},{results[2][1]:.6f}]]\")\n\nsolve()\n```", "id": "2916223"}]}