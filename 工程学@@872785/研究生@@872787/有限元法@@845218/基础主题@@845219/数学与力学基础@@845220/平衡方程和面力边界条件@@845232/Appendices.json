{"hands_on_practices": [{"introduction": "在有限元分析中，精确计算外力所做的功至关重要。本练习关注于如何通过数值积分（特别是高斯求积）来处理施加在单元边界上的牵引力边界条件。通过这个实践，你将掌握如何根据形函数和牵引力场的多项式次数，确定保证积分精确性所需的最小积分点数，这是确保有限元解精度的基础一步。[@problem_id:2556076]", "problem": "考虑一个可变形体的平衡，该平衡由无惯性项的柯西动量平衡方程控制。其强形式为：在域内，柯西应力张量的散度加上体力场等于零；在部分边界上，由一个面力边界条件指定了表面牵引力矢量。将域记为 $\\Omega$，指定面力的边界记为 $\\Gamma_{t}$，柯西应力张量记为 $\\boldsymbol{\\sigma}$，外单位法向量记为 $\\boldsymbol{n}$，单位体积的体力记为 $\\boldsymbol{b}$，指定的面力矢量记为 $\\boldsymbol{t}$。基本定律为：在 $\\Omega$ 内 $\\nabla \\cdot \\boldsymbol{\\sigma} + \\boldsymbol{b} = \\boldsymbol{0}$，以及在 $\\Gamma_{t}$ 上 $\\boldsymbol{\\sigma} \\boldsymbol{n} = \\boldsymbol{t}$。使用虚功原理和具有适当本质边界条件的测试（虚位移）场 $\\boldsymbol{v}$，其弱形式包含边界积分 $\\int_{\\Gamma_{t}} \\boldsymbol{v} \\cdot \\boldsymbol{t} \\,\\mathrm{d}\\Gamma$。在有限元法 (FEM) 中，使用形函数 $N_{i}$，来自 $\\Gamma_{t}$ 对节点 $i$ 的全局载荷向量的贡献为 $\\int_{\\Gamma_{t}} N_{i} \\, \\boldsymbol{t} \\cdot \\boldsymbol{e} \\,\\mathrm{d}\\Gamma$，其中 $\\boldsymbol{e}$ 是一个用于选择位移分量的标准基向量。\n\n假设单元为等参单元，每个单元上具有仿射（线性）几何映射，因此边界边和面从参考边和面进行仿射映射。这使得边界雅可比因子在每条边或每个面上为常数，并确保物理边或面上的多项式面力场在参考坐标系中变为一个总次数相同的多项式。考虑限制在边或面上的次数为 $r \\in \\mathbb{N}$ 的多项式 Lagrange 形函数，以及在该边或面上，在相应参考坐标系中次数为 $q \\in \\mathbb{N}_{0}$ 的多项式面力场。在这些假设下，边或面上的边界项的被积函数是一个多项式，其次数由 $N_{i}$ 与面力的乘积决定，并乘以一个常数边界雅可比因子。\n\n你的任务是实现适用于边界积分的数值求积法则，并对每种给定情况，确定精确积分边界面力项所需的最小求积点数：\n- 在边上：在参考区间 $[-1,1]$ 上实现适用于任意正整数点数 $n$ 的 Gauss–Legendre 求积，并确定保证在仿射边上精确积分多项式被积函数的最小 $n$。\n- 在三角形面上：在参考三角形上实现对总次数最高为指定次数 $s$（$s \\in \\{1,2,3,4,5\\}$）的多项式精确的对称求积法则（例如，Dunavant 型法则），并确定保证在仿射三角形面上精确积分多项式被积函数的最小求积点数。\n\n从第一性原理出发：从强形式和面力边界条件开始，推导出弱形式边界项，在仿射映射假设下，用 $r$ 和 $q$ 表示边界面力贡献的被积函数的多项式次数，并推导出相关的求积精度要求。然后，实现相应的求积法则，并计算下面每个测试用例所需的最小点数。\n\n测试套件（每一项指定实体类型和序对 $(r,q)$）：\n- 边：$(r,q) = (1,1)$。\n- 边：$(r,q) = (2,0)$。\n- 边：$(r,q) = (3,2)$。\n- 边：$(r,q) = (1,0)$。\n- 三角形面：$(r,q) = (1,1)$。\n- 三角形面：$(r,q) = (2,2)$。\n- 三角形面：$(r,q) = (3,1)$。\n- 三角形面：$(r,q) = (1,0)$。\n\n你的程序必须：\n- 在 $[-1,1]$ 上实现适用于任意正整数 $n$ 的 Gauss–Legendre 求积。\n- 实现对总多项式次数 $s \\in \\{1,2,3,4,5\\}$ 精确的三角形求积法则。\n- 对于每个测试用例，计算在所述假设下确保精确计算边界牵引力积分所需的最小求积点数。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔的整数列表（例如，$[a,b,c]$），每个整数是对应于上面所列顺序的测试用例的最小求积点数。", "solution": "我们从无惯性项和准静态条件下的线性动量平衡方程 $\\nabla \\cdot \\boldsymbol{\\sigma} + \\boldsymbol{b} = \\boldsymbol{0}$ in $\\Omega$ 开始，并辅以面力边界条件 $\\boldsymbol{\\sigma}\\boldsymbol{n} = \\boldsymbol{t}$ on $\\Gamma_{t}$。设 $\\boldsymbol{v}$ 为一个容许虚位移场。虚功原理得出\n$$\n\\int_{\\Omega} \\boldsymbol{\\varepsilon}(\\boldsymbol{v}) : \\boldsymbol{\\sigma} \\,\\mathrm{d}\\Omega = \\int_{\\Omega} \\boldsymbol{v}\\cdot \\boldsymbol{b} \\,\\mathrm{d}\\Omega + \\int_{\\Gamma_{t}} \\boldsymbol{v}\\cdot \\boldsymbol{t} \\,\\mathrm{d}\\Gamma,\n$$\n其中 $\\boldsymbol{\\varepsilon}(\\boldsymbol{v})$ 是小应变张量。在采用形函数 $N_{i}$ 和节点虚位移 $\\delta \\boldsymbol{u}_{i}$ 的有限元法 (FEM) 离散化中，我们取 $\\boldsymbol{v} \\approx \\sum_{i} N_{i} \\,\\delta \\boldsymbol{u}_{i}$。与节点 $i$ 和给定平移分量方向相关联的离散载荷向量分量的面力边界贡献是\n$$\nf_{i}^{\\Gamma} = \\int_{\\Gamma_{t}} N_{i} \\, t \\, \\mathrm{d}\\Gamma,\n$$\n其中 $t$ 表示面力矢量的相应分量。这个标量边界积分在单元边界段上进行计算：在二维情况下是边（一维流形），在三维情况下是面（二维流形）。\n\n我们假设一个在每个单元上具有仿射（线性）几何映射的等参格式。对于边积分，从参考区间 $[-1,1]$ 到物理边的映射是仿射的。将参考积分转换为物理积分的边界雅可比因子 $J_{\\Gamma}$ 在每个仿射边上是常数，因此除了一个乘法常数外，被积函数的多项式特性不受影响。设边上的形函数在限制到边上时是次数为 $r \\in \\mathbb{N}$ 的多项式，并且面力分量 $t$ 沿该边是次数为 $q \\in \\mathbb{N}_{0}$ 的多项式。那么，边上的被积函数 $N_{i} \\, t$ 在参考坐标中是次数为 $r+q$ 的一维多项式。\n\n为了用 $n$ 点的 Gauss–Legendre 求积在 $[-1,1]$ 上精确地积分这个多项式，我们使用一个众所周知的事实，即一个 $n$ 点的 Gauss–Legendre 法则对所有次数不超过 $2n-1$ 的多项式都是精确的。因此，精确性要求：\n$$\n2n - 1 \\ge r + q \\quad \\Longrightarrow \\quad n \\ge \\left\\lceil \\frac{r+q+1}{2} \\right\\rceil,\n$$\n所以，在仿射边上所需的最小 Gauss–Legendre 点数为 $n_{\\text{edge}} = \\left\\lceil \\frac{r+q+1}{2} \\right\\rceil$。\n\n对于四面体单元的三角形面，从参考三角形到物理面的映射是仿射的。边界面积雅可比 $J_{\\Gamma}$ 在每个面上是常数，次数为 $r$ 的形函数 $N_{i}$ 限制在面上时，是参考三角形坐标系中总次数为 $r$ 的二元多项式。如果面力分量 $t$ 在该面上是总次数为 $q$ 的二元多项式，那么乘积 $N_{i}\\, t$ 是一个总次数为 $r+q$ 的二元多项式。如果 $s \\ge r+q$，一个对所有总次数不超过 $s$ 的多项式都精确的对称三角形求积法则将能精确地积分此项。具有保证精度次数 $s$ 的最少点数法则已被广泛制成表格。其中一组方便的法则是 Dunavant 法则，例如：\n- 次数 $s \\le 1$：$1$ 个点（形心法则）。\n- 次数 $s \\le 2$：$3$ 个点。\n- 次数 $s \\le 3$：$4$ 个点。\n- 次数 $s \\le 4$：$6$ 个点。\n- 次数 $s \\le 5$：$7$ 个点。\n\n因此，对于在所述假设下的三角形面，通过选择满足 $s \\ge r+q$ 的最小可用法则并报告其点数，即可获得最小求积点数。\n\n算法设计：\n- 使用正交多项式机制在 $[-1,1]$ 上实现 Gauss–Legendre 求积，以获得任意 $n$ 的节点和权重。其精度次数为 $2n-1$，因此所需的最小 $n$ 为 $n_{\\text{edge}} = \\left\\lceil \\frac{r+q+1}{2} \\right\\rceil$。\n- 实现针对精度次数 $s \\in \\{1,2,3,4,5\\}$ 的三角形求积法则及其节点和权重（例如，Dunavant 法则）。对于给定的 $(r,q)$，计算 $m = r+q$，选取满足 $s \\ge m$ 的最小 $s \\in \\{1,2,3,4,5\\}$，并返回该法则的点数。\n- 将这些按指定顺序应用于测试套件，并以整数形式输出最小点数。\n\n将公式应用于测试套件，得出：\n- 边 $(r,q)=(1,1)$: $n_{\\text{edge}}=\\left\\lceil \\frac{1+1+1}{2} \\right\\rceil = \\left\\lceil \\frac{3}{2} \\right\\rceil = 2$。\n- 边 $(r,q)=(2,0)$: $n_{\\text{edge}}=\\left\\lceil \\frac{2+0+1}{2} \\right\\rceil = \\left\\lceil \\frac{3}{2} \\right\\rceil = 2$。\n- 边 $(r,q)=(3,2)$: $n_{\\text{edge}}=\\left\\lceil \\frac{3+2+1}{2} \\right\\rceil = \\left\\lceil \\frac{6}{2} \\right\\rceil = 3$。\n- 边 $(r,q)=(1,0)$: $n_{\\text{edge}}=\\left\\lceil \\frac{1+0+1}{2} \\right\\rceil = \\left\\lceil \\frac{2}{2} \\right\\rceil = 1$。\n- 面 $(r,q)=(1,1)$: $m=1+1=2 \\Rightarrow s=2$ 即可 $\\Rightarrow 3$ 个点。\n- 面 $(r,q)=(2,2)$: $m=2+2=4 \\Rightarrow s=4$ 即可 $\\Rightarrow 6$ 个点。\n- 面 $(r,q)=(3,1)$: $m=3+1=4 \\Rightarrow s=4$ 即可 $\\Rightarrow 6$ 个点。\n- 面 $(r,q)=(1,0)$: $m=1+0=1 \\Rightarrow s=1$ 即可 $\\Rightarrow 1$ 个点。\n\n因此，所需的输出按顺序为整数 $[2,2,3,1,3,6,6,1]$，程序将使用所实现的求积法则逻辑来计算这些值。", "answer": "```python\nimport numpy as np\n\n# Implement Gauss-Legendre quadrature on [-1, 1]\ndef gauss_legendre_rule(n):\n    # Returns nodes and weights for n-point Gauss-Legendre\n    # Using numpy's leggauss for robustness\n    from numpy.polynomial.legendre import leggauss\n    nodes, weights = leggauss(n)\n    return nodes, weights\n\n# Implement Dunavant-type symmetric triangle quadrature rules\n# providing exactness up to degrees 1..5. Returns (points, weights, degree, n_points).\n# Points are given in barycentric coordinates (L1,L2,L3) with L1+L2+L3=1, L_i >= 0.\ndef triangle_rule_by_degree_exactness(s_required):\n    # Select the minimal rule with exactness >= s_required from available set.\n    # Data from standard Dunavant rules.\n    rules = [\n        # degree, points (barycentric), weights\n        (1,\n         np.array([[1/3, 1/3, 1/3]]),\n         np.array([1.0])),\n        (2,\n         np.array([\n             [2/3, 1/6, 1/6],\n             [1/6, 2/3, 1/6],\n             [1/6, 1/6, 2/3],\n         ]),\n         np.array([1/3, 1/3, 1/3])),\n        (3,\n         np.array([\n             [1/3, 1/3, 1/3],\n             [0.6, 0.2, 0.2],\n             [0.2, 0.6, 0.2],\n             [0.2, 0.2, 0.6],\n         ]),\n         np.array([-27/48, 25/48, 25/48, 25/48])),\n        (4,\n         np.array([\n             [0.445948490915965, 0.445948490915965, 0.108103018168070],\n             [0.445948490915965, 0.108103018168070, 0.445948490915965],\n             [0.108103018168070, 0.445948490915965, 0.445948490915965],\n             [0.091576213509771, 0.091576213509771, 0.816847572980458],\n             [0.091576213509771, 0.816847572980458, 0.091576213509771],\n             [0.816847572980458, 0.091576213509771, 0.091576213509771],\n         ]),\n         np.array([\n             0.223381589678011,\n             0.223381589678011,\n             0.223381589678011,\n             0.109951743655322,\n             0.109951743655322,\n             0.109951743655322,\n         ])),\n        (5,\n         np.array([\n             [1/3, 1/3, 1/3],\n             [0.059715871789770, 0.470142064105115, 0.470142064105115],\n             [0.470142064105115, 0.059715871789770, 0.470142064105115],\n             [0.470142064105115, 0.470142064105115, 0.059715871789770],\n             [0.797426985353087, 0.101286507323456, 0.101286507323456],\n             [0.101286507323456, 0.797426985353087, 0.101286507323456],\n             [0.101286507323456, 0.101286507323456, 0.797426985353087],\n         ]),\n         np.array([\n             0.225000000000000,\n             0.132394152788506,\n             0.132394152788506,\n             0.132394152788506,\n             0.125939180544827,\n             0.125939180544827,\n             0.125939180544827,\n         ])),\n    ]\n    # Choose smallest rule with degree >= s_required\n    for degree, pts, wts in rules:\n        if degree >= s_required:\n            return pts, wts, degree, pts.shape[0]\n    # If higher degree requested than available, raise error\n    raise ValueError(\"Requested triangle quadrature exactness degree exceeds available rules (max 5).\")\n\n# Compute minimal number of Gauss-Legendre points for edge integrals\ndef minimal_edge_points(r, q):\n    # n such that 2n-1 >= r+q -> n >= ceil((r+q+1)/2)\n    return int(np.ceil((r + q + 1) / 2.0))\n\n# Compute minimal number of triangle quadrature points for face integrals\ndef minimal_triangle_face_points(r, q):\n    m = r + q  # required total degree exactness\n    _, _, _, npts = triangle_rule_by_degree_exactness(m)\n    return npts\n\ndef solve():\n    # Define the test suite in the specified order\n    # Each tuple: (entity_type, r, q)\n    test_cases = [\n        (\"edge\", 1, 1),\n        (\"edge\", 2, 0),\n        (\"edge\", 3, 2),\n        (\"edge\", 1, 0),\n        (\"face_triangle\", 1, 1),\n        (\"face_triangle\", 2, 2),\n        (\"face_triangle\", 3, 1),\n        (\"face_triangle\", 1, 0),\n    ]\n\n    results = []\n    for entity, r, q in test_cases:\n        if entity == \"edge\":\n            # implement rule (nodes, weights) though only count is needed\n            n = minimal_edge_points(r, q)\n            _nodes, _weights = gauss_legendre_rule(n)\n            results.append(n)\n        elif entity == \"face_triangle\":\n            npts = minimal_triangle_face_points(r, q)\n            # also obtain nodes and weights (unused in result)\n            _pts, _wts, _deg, _ = triangle_rule_by_degree_exactness(r + q)\n            results.append(npts)\n        else:\n            raise ValueError(\"Unknown entity type in test cases.\")\n\n    # Final output format: single line with comma-separated list enclosed in brackets\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2556076"}, {"introduction": "代码验证是计算力学中的一个核心环节，它确保我们的数值模型能够准确反映物理现实。本练习利用经典的Airy应力函数构造一个具有精确解析解的平面应力问题，并要求你实现一个完整的有限元程序来求解，并将数值结果与解析解进行比较。这个过程不仅能检验你对单元刚度矩阵和牵引力载荷向量装配的理解，更是方法验证（verification）的一个经典实例。[@problem_id:2556099]", "problem": "考虑在矩形域 $\\Omega = [0,L_x] \\times [0,L_y]$ 上的二维、小应变、线性弹性静力学中的平面应力问题。设材料是均匀且各向同性的，其杨氏模量为 $E$，泊松比为 $\\nu$。未知位移场为 $\\mathbf{u}(x,y) = (u_x(x,y), u_y(x,y))$。不存在体力。在整个边界 $\\partial \\Omega$ 上给定面力。\n\n为确保精确满足体力为零的强形式平衡方程，使用一个 Airy 应力函数 $F(x,y)$ 并将应力张量定义为\n$$\n\\sigma_{xx} = \\frac{\\partial^2 F}{\\partial y^2}, \\quad\n\\sigma_{yy} = \\frac{\\partial^2 F}{\\partial x^2}, \\quad\n\\sigma_{xy} = -\\frac{\\partial^2 F}{\\partial x \\partial y}.\n$$\n选择三次 Airy 应力函数\n$$\nF(x,y) = a\\,x\\,y^3 + b\\,x^3\\,y + c\\,x^2\\,y + d\\,x\\,y^2,\n$$\n其中 $a$、$b$、$c$ 和 $d$ 是给定的常数。由于 $F$ 是一个至多三次的多项式，它是双调和的，因此产生的应力场在线性弹性中满足体力为零时的协调性条件。\n\n边界上的面力定义为 $\\mathbf{t} = \\boldsymbol{\\sigma}\\,\\mathbf{n}$，其中 $\\mathbf{n}$ 是向外的单位法向量。在矩形的四条边上，向外的单位法向量是常数：\n- 在 $x=0$ 上：$\\mathbf{n} = (-1,0)$，\n- 在 $x=L_x$ 上：$\\mathbf{n} = (1,0)$，\n- 在 $y=0$ 上：$\\mathbf{n} = (0,-1)$，\n- 在 $y=L_y$ 上：$\\mathbf{n} = (0,1)$。\n\n令平面应力的本构关系通过以下方式将应力与工程应变 $\\boldsymbol{\\varepsilon}_{\\text{eng}} = (\\varepsilon_{xx}, \\varepsilon_{yy}, \\gamma_{xy})^T$ 联系起来\n$$\n\\boldsymbol{\\sigma} = \\mathbf{D}\\,\\boldsymbol{\\varepsilon}_{\\text{eng}}, \\quad\n\\mathbf{D} = \\frac{E}{1-\\nu^2}\n\\begin{bmatrix}\n1 & \\nu & 0 \\\\\n\\nu & 1 & 0 \\\\\n0 & 0 & \\frac{1-\\nu}{2}\n\\end{bmatrix},\n$$\n以及柔度关系 $\\boldsymbol{\\varepsilon}_{\\text{eng}} = \\mathbf{S}\\,\\boldsymbol{\\sigma}$，其中\n$$\n\\mathbf{S} =\n\\begin{bmatrix}\n\\frac{1}{E} & -\\frac{\\nu}{E} & 0 \\\\\n-\\frac{\\nu}{E} & \\frac{1}{E} & 0 \\\\\n0 & 0 & \\frac{2(1+\\nu)}{E}\n\\end{bmatrix}.\n$$\n工程剪应变为 $\\gamma_{xy} = \\partial u_x/\\partial y + \\partial u_y/\\partial x$。在没有体力和只有面力边界条件的情况下，弱形式为：找到 $\\mathbf{u} \\in V$，使得对于所有虚位移 $\\mathbf{v} \\in V_0$，有\n$$\n\\int_{\\Omega} \\boldsymbol{\\varepsilon}_{\\text{eng}}(\\mathbf{v})^T \\mathbf{D}\\, \\boldsymbol{\\varepsilon}_{\\text{eng}}(\\mathbf{u}) \\, d\\Omega\n=\n\\int_{\\partial \\Omega} \\mathbf{v} \\cdot \\mathbf{t} \\, d\\Gamma.\n$$\n为了唯一地消除刚体模式，施加最小的基本约束\n$$\nu_x(0,0) = 0,\\quad u_y(0,0) = 0,\\quad u_y(L_x,0)=0.\n$$\n\n任务。实现一个协调有限元方法（FEM），在 $N_x \\times N_y$ 个单元的均匀网格上使用双线性等参四边形单元，以求解由 Airy 应力函数引起的牵引场下的上述弱形式。通过执行高斯求积来组装全局刚度矩阵和一致的 Neumann 载荷向量：\n- 对单元刚度使用 $2 \\times 2$ 高斯积分，\n- 对每条边界边上的面力载荷使用 $2$ 点高斯积分。\n\n通过对从 Airy 导出的应力经由平面应力柔度关系获得的应变场进行积分，构造一个精确位移场 $(u_x^\\star, u_y^\\star)$。定义\n$$\n\\sigma_{xx} = 6 a\\, x y + 2 d\\, x,\\quad\n\\sigma_{yy} = 6 b\\, x y + 2 c\\, y,\\quad\n\\tau_{xy} = -3 a\\, y^2 - 3 b\\, x^2 - 2 c\\, x - 2 d\\, y.\n$$\n工程应变为\n$$\n\\varepsilon_{xx} = \\frac{1}{E}\\left(\\sigma_{xx} - \\nu \\sigma_{yy}\\right),\\quad\n\\varepsilon_{yy} = \\frac{1}{E}\\left(\\sigma_{yy} - \\nu \\sigma_{xx}\\right),\\quad\n\\gamma_{xy} = \\frac{2(1+\\nu)}{E}\\,\\tau_{xy}.\n$$\n积分 $\\partial u_x/\\partial x = \\varepsilon_{xx}$ 和 $\\partial u_y/\\partial y = \\varepsilon_{yy}$，并通过强制实施 $\\gamma_{xy} = \\partial u_x/\\partial y + \\partial u_y/\\partial x$ 来确定缺失的单变量函数。一个特殊的多项式解（不考虑刚体运动）是\n$$\nu_x^{\\text{base}}(x,y) = \\frac{1}{E}\\left( (3a-3\\nu b)\\, x^2 y + d\\, x^2 - 2\\nu c\\, x y \\right) - \\frac{1}{E}\\left( ((2+\\nu)a + b)\\, y^3 + (2+\\nu)\\, d\\, y^2 \\right),\n$$\n$$\nu_y^{\\text{base}}(x,y) = \\frac{1}{E}\\left( (3b-3\\nu a)\\, x y^2 + c\\, y^2 - 2\\nu d\\, x y \\right) - \\frac{1}{E}\\left( (a + (2+\\nu)b)\\, x^3 + (2+\\nu)\\, c\\, x^2 \\right).\n$$\n为了在不改变应变场的情况下满足三个基本约束，通过一个标量角度参数 $\\theta$ 的刚性旋转来增强解：\n$$\nu_x^\\star(x,y) = u_x^{\\text{base}}(x,y) - \\theta\\, y, \\quad\nu_y^\\star(x,y) = u_y^{\\text{base}}(x,y) + \\theta\\, x.\n$$\n选择 $\\theta$ 来强制实施 $u_y^\\star(L_x,0)=0$。使用 $u_y^{\\text{base}}(x,0) = -\\frac{1}{E}\\left( (a + (2+\\nu) b)\\, x^3 + (2+\\nu)\\, c\\, x^2 \\right)$，可得到\n$$\n\\theta = -\\frac{u_y^{\\text{base}}(L_x,0)}{L_x}\n= \\frac{1}{E}\\left[\\left(a+(2+\\nu)b\\right)L_x^2 + (2+\\nu)\\, c\\, L_x \\right].\n$$\n\n数值验证。使用带有顶点片权重的离散类 $L^2$ 范数，在网格节点上比较有限元解 $\\mathbf{u}_h$ 和精确解 $\\mathbf{u}^\\star$。对每个节点 $i$，定义权重 $w_i$ 为每个相邻单元面积的四分之一之和。计算相对误差\n$$\n\\eta = \\frac{\\left(\\sum_i w_i \\left[ (u_{x,h}(\\mathbf{x}_i) - u_x^\\star(\\mathbf{x}_i))^2 + (u_{y,h}(\\mathbf{x}_i) - u_y^\\star(\\mathbf{x}_i))^2 \\right]\\right)^{1/2}}{\\left(\\sum_i w_i \\left[ (u_x^\\star(\\mathbf{x}_i))^2 + (u_y^\\star(\\mathbf{x}_i))^2 \\right]\\right)^{1/2}},\n$$\n如果分母为零，则定义 $\\eta = 0$。\n\n测试套件。您的程序必须评估以下三种情况，并为每种情况输出相对误差 $\\eta$：\n\n- 情况1（非平凡，中等 $\\nu$）：\n  - $L_x=1.0$, $L_y=0.8$, $N_x=10$, $N_y=8$, $E=1000.0$, $\\nu=0.3$,\n  - $a=0.7$, $b=-0.4$, $c=0.5$, $d=-0.2$.\n\n- 情况2（平凡，零面力边缘情况）：\n  - $L_x=1.0$, $L_y=1.0$, $N_x=4$, $N_y=4$, $E=500.0$, $\\nu=0.25$,\n  - $a=0.0$, $b=0.0$, $c=0.0$, $d=0.0$.\n\n- 情况3（平面应力下近乎不可压缩）：\n  - $L_x=2.0$, $L_y=1.0$, $N_x=16$, $N_y=8$, $E=2000.0$, $\\nu=0.49$,\n  - $a=0.2$, $b=0.3$, $c=-0.1$, $d=0.15$.\n\n最终输出格式。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，“[result1,result2,result3]”），其中每个项目是对应测试用例的相对误差 $\\eta$（一个浮点数），顺序如上所列。不允许有其他输出。所有量都是无量纲的；不需要物理单位。", "solution": "所提出的问题是计算力学中的一个标准练习，具体地说是将有限元方法（FEM）应用于平面应力条件下的二维线性弹性静力学问题。该问题定义明确、科学上合理且内部一致。\n\n首先，对问题陈述进行验证。控制方程是线性弹性静力学的方程。使用 Airy 应力函数 $F(x,y)$ 来定义应力场 $(\\sigma_{xx}, \\sigma_{yy}, \\sigma_{xy})$ 是一种经典方法，用以确保强形式平衡方程 $\\boldsymbol{\\nabla} \\cdot \\boldsymbol{\\sigma} = \\mathbf{0}$ 被恒等满足。为 $F(x,y)$ 选择的多项式形式是双调和的，这保证了对于均匀、各向同性且体力为零的材料，所产生的应力场满足协调方程。所提供的本构关系是平面应力的标准关系。弱形式是从虚功原理正确推导出来的。给定的边界面力是通过 $\\mathbf{t} = \\boldsymbol{\\sigma} \\mathbf{n}$ 从应力张量正确推导出来的。纯 Neumann 边值问题固有的刚体运动问题，通过施加足以产生唯一解的最小基本约束得到了正确处理。所提供的位移场解析解已经通过对应变场（从应力场通过柔度关系导出）进行积分并确保协调性来验证，这证实了其正确性。数值误差度量是一个标准的加权离散 $L^2$ 范数。所有测试用例都提供了完整的数据。因此，该问题被认为是有效且可解的。\n\n该解决方案将使用标准的有限元方法程序，在均匀的矩形网格上对双线性四边形单元进行实现。\n\n1.  **网格生成**：生成一个 $N_x \\times N_y$ 单元的均匀网格，产生 $(N_x+1) \\times (N_y+1)$ 个节点。系统地创建节点坐标和单元连接性（一个列出构成每个单元的节点的列表）。\n\n2.  **单元级计算**：对于每个双线性四边形单元，必须计算 $8 \\times 8$ 的单元刚度矩阵 $k^e$。该矩阵源于弱形式的体积积分：\n    $$\n    k^e = \\int_{\\Omega_e} B^T D B \\, d\\Omega\n    $$\n    在这里，$D$ 是 $3 \\times 3$ 的平面应力本构矩阵，$B$ 是 $3 \\times 8$ 的应变-位移矩阵，它将应变分量 $(\\varepsilon_{xx}, \\varepsilon_{yy}, \\gamma_{xy})$ 与单元的 $8$ 个节点位移自由度联系起来。$B$ 的条目取决于双线性形函数 $N_i$ 的空间导数。该积分在单元域 $\\Omega_e$ 上计算。通过将单元映射到 $(\\xi, \\eta)$ 坐标系中的规范方形域 $[-1,1] \\times [-1,1]$，使用 $2 \\times 2$ 高斯求积对积分进行数值计算。\n\n3.  **组装**：全局刚度矩阵 $K$ 和全局力向量 $F$ 初始化为零。然后，代码遍历所有单元，计算每个 $k^e$，并根据单元的连接性将其组装到全局矩阵 $K$ 中的适当位置。\n\n4.  **载荷向量计算**：全局力向量 $F$ 表示由给定的边界面力所做的功。它是通过在边界 $\\partial\\Omega$ 上对虚位移和面力向量的点积进行积分来计算的：\n    $$\n    F_i = \\int_{\\partial \\Omega} N_i \\mathbf{t} \\, d\\Gamma\n    $$\n    这被分解为沿矩形域的四个边界边的积分。对于每个边界边，积分是一维线积分，使用 2 点高斯-勒让德求积法则进行数值计算。首先在每个边界边上的高斯点处计算面力向量 $\\mathbf{t}(x,y)$。\n\n5.  **施加边界条件**：全局系统 $K\\mathbf{d} = F$ 是奇异的，因为问题在整个边界上具有 Neumann 边界条件，允许刚体运动。为了获得唯一解，强制施加指定的基本约束 $u_x(0,0)=0$、$u_y(0,0)=0$ 和 $u_y(L_x,0)=0$。这通常通过修改矩阵 $K$ 和向量 $F$ 来完成。对于每个受约束的自由度（DOF）$i$，将 $K$ 的相应行和列清零，$K_{ii}$ 设置为 $1$，并将 $F_i$ 设置为给定的位移值，在此所有情况下均为 $0$。\n\n6.  **线性系统求解**：施加约束后，修正后的线性方程组 $K\\mathbf{d} = F$ 变为非奇异的，并使用标准线性求解器求解全局位移向量 $\\mathbf{d}$。\n\n7.  **误差计算**：现在，数值解 $\\mathbf{u}_h$ 在节点处是已知的。精确解析解 $\\mathbf{u}^\\star$ 也在每个节点坐标处进行评估。然后使用给定的离散加权 $L^2$ 范数计算相对误差 $\\eta$。节点权重 $w_i$ 计算为与节点 $i$ 相邻的每个单元面积的四分之一之和。对于精确解为零的特殊情况（情况2），误差范数的分母为零，根据问题定义，误差 $\\eta$ 取为 $0$。\n\n此过程系统地应用于问题陈述中指定的三个测试用例。", "answer": "```python\nimport numpy as np\nfrom scipy import linalg\n\ndef solve():\n    \"\"\"\n    Main solver function that runs the test suite and prints the results.\n    \"\"\"\n\n    def solve_case(Lx, Ly, Nx, Ny, E, nu, a, b, c, d):\n        \"\"\"\n        Solves a single instance of the 2D elastostatics problem using FEM.\n        \"\"\"\n        # 1. MESH GENERATION\n        hx = Lx / Nx\n        hy = Ly / Ny\n        n_nodes_x = Nx + 1\n        n_nodes_y = Ny + 1\n        num_nodes = n_nodes_x * n_nodes_y\n        num_elements = Nx * Ny\n        num_dofs = 2 * num_nodes\n\n        nodes = np.zeros((num_nodes, 2))\n        for j in range(n_nodes_y):\n            for i in range(n_nodes_x):\n                node_idx = j * n_nodes_x + i\n                nodes[node_idx, 0] = i * hx\n                nodes[node_idx, 1] = j * hy\n\n        elements = np.zeros((num_elements, 4), dtype=int)\n        for j in range(Ny):\n            for i in range(Nx):\n                el_idx = j * Nx + i\n                n1 = j * n_nodes_x + i\n                n2 = j * n_nodes_x + i + 1\n                n3 = (j + 1) * n_nodes_x + i + 1\n                n4 = (j + 1) * n_nodes_x + i\n                elements[el_idx] = [n1, n2, n3, n4]\n\n        # 2. ELEMENT-LEVEL CALCULATIONS  ASSEMBLY\n        D = (E / (1 - nu**2)) * np.array([\n            [1, nu, 0],\n            [nu, 1, 0],\n            [0, 0, (1 - nu) / 2]\n        ])\n\n        gp_loc = 1.0 / np.sqrt(3.0)\n        gauss_points_1d = np.array([-gp_loc, gp_loc])\n        gauss_weights_1d = np.array([1.0, 1.0])\n        \n        K = np.zeros((num_dofs, num_dofs))\n\n        detJ = hx * hy / 4.0\n\n        for el_idx in range(num_elements):\n            k_e = np.zeros((8, 8))\n            for i_gp, xi in enumerate(gauss_points_1d):\n                w_xi = gauss_weights_1d[i_gp]\n                for j_gp, eta in enumerate(gauss_points_1d):\n                    w_eta = gauss_weights_1d[j_gp]\n                    \n                    dNdxi = 0.25 * np.array([-(1 - eta), (1 - eta), (1 + eta), -(1 + eta)])\n                    dNdeta = 0.25 * np.array([-(1 - xi), -(1 + xi), (1 + xi), (1 - xi)])\n                    \n                    dNdx = dNdxi * (2.0 / hx)\n                    dNdy = dNdeta * (2.0 / hy)\n                    \n                    B = np.zeros((3, 8))\n                    for i in range(4):\n                        B[0, 2*i] = dNdx[i]\n                        B[1, 2*i+1] = dNdy[i]\n                        B[2, 2*i] = dNdy[i]\n                        B[2, 2*i+1] = dNdx[i]\n                    \n                    k_e += B.T @ D @ B * w_xi * w_eta * detJ\n            \n            node_indices = elements[el_idx]\n            dof_indices = [idx for i in node_indices for idx in (2*i, 2*i+1)]\n            K[np.ix_(dof_indices, dof_indices)] += k_e\n\n        # 3. LOAD VECTOR CALCULATION\n        F = np.zeros(num_dofs)\n\n        def get_stress(x, y):\n            s_xx = 6 * a * x * y + 2 * d * x\n            s_yy = 6 * b * x * y + 2 * c * y\n            s_xy = -3 * a * y**2 - 3 * b * x**2 - 2 * c * x - 2 * d * y\n            return s_xx, s_yy, s_xy\n\n        # Boundary loop (bottom, right, top, left)\n        boundary_edges = []\n        for i in range(Nx): boundary_edges.append(((i, 0), (i + 1, 0))) # Bottom\n        for j in range(Ny): boundary_edges.append(((Nx, j), (Nx, j + 1))) # Right\n        for i in range(Nx): boundary_edges.append(((Nx - i, Ny), (Nx - i - 1, Ny))) # Top\n        for j in range(Ny): boundary_edges.append(((0, Ny - j), (0, Ny - j - 1))) # Left\n\n        normals = [np.array([0, -1]), np.array([1, 0]), np.array([0, 1]), np.array([-1, 0])]\n\n        edge_idx_offset = 0\n        for side_idx in range(4):\n            normal = normals[side_idx]\n            num_side_elements = Nx if side_idx % 2 == 0 else Ny\n            \n            for i in range(num_side_elements):\n                n_start_idx = edge_idx_offset + i\n                start_node_coords, end_node_coords = boundary_edges[n_start_idx]\n                \n                n1 = start_node_coords[1] * n_nodes_x + start_node_coords[0]\n                n2 = end_node_coords[1] * n_nodes_x + end_node_coords[0]\n\n                edge_vec = nodes[n2] - nodes[n1]\n                edge_len = np.linalg.norm(edge_vec)\n                detJ_1d = edge_len / 2.0\n                \n                f_e = np.zeros(4)\n                for i_gp, s in enumerate(gauss_points_1d):\n                    w = gauss_weights_1d[i_gp]\n                    gp_coord = (nodes[n1] + nodes[n2]) / 2.0 + s * detJ_1d * (edge_vec / edge_len)\n                    \n                    s_xx, s_yy, s_xy = get_stress(gp_coord[0], gp_coord[1])\n                    sigma = np.array([[s_xx, s_xy], [s_xy, s_yy]])\n                    t = sigma @ normal\n                    \n                    N_1d = np.array([(1-s)/2.0, (1+s)/2.0])\n                    f_e[0] += N_1d[0] * t[0] * w * detJ_1d\n                    f_e[1] += N_1d[0] * t[1] * w * detJ_1d\n                    f_e[2] += N_1d[1] * t[0] * w * detJ_1d\n                    f_e[3] += N_1d[1] * t[1] * w * detJ_1d\n\n                dofs = [2*n1, 2*n1+1, 2*n2, 2*n2+1]\n                F[dofs] += f_e\n            edge_idx_offset += num_side_elements\n\n        # 4. APPLY BOUNDARY CONDITIONS\n        bc_dofs = [0, 1, 2 * Nx + 1]\n        for dof in bc_dofs:\n            K[dof, :] = 0\n            K[:, dof] = 0\n            K[dof, dof] = 1.0\n            F[dof] = 0.0\n        \n        # 5. SOLVE LINEAR SYSTEM\n        u_h_vec = linalg.solve(K, F)\n        u_h = u_h_vec.reshape((num_nodes, 2))\n        \n        # 6. ERROR COMPUTATION\n        def u_base_x(x, y):\n            term1 = (1/E) * ( (3*a - 3*nu*b) * x**2 * y + d*x**2 - 2*nu*c*x*y )\n            term2 = (1/E) * ( ((2+nu)*a + b) * y**3 + (2+nu)*d*y**2 )\n            return term1 - term2\n        \n        def u_base_y(x, y):\n            term1 = (1/E) * ( (3*b - 3*nu*a) * x*y**2 + c*y**2 - 2*nu*d*x*y )\n            term2 = (1/E) * ( (a + (2+nu)*b) * x**3 + (2+nu)*c*x**2 )\n            return term1 - term2\n\n        theta = (1/E) * ( (a + (2+nu)*b)*Lx**2 + (2+nu)*c*Lx )\n\n        def u_star_x(x, y): return u_base_x(x, y) - theta * y\n        def u_star_y(x, y): return u_base_y(x, y) + theta * x\n\n        u_exact = np.array([[u_star_x(x, y), u_star_y(x, y)] for x, y in nodes])\n            \n        weights = np.zeros(num_nodes)\n        el_area = hx * hy\n        for el_idx in range(num_elements):\n            weights[elements[el_idx]] += el_area / 4.0\n\n        err_num_sq = np.sum(weights * np.sum((u_h - u_exact)**2, axis=1))\n        norm_den_sq = np.sum(weights * np.sum(u_exact**2, axis=1))\n\n        if norm_den_sq  1e-25: return 0.0\n        \n        return np.sqrt(err_num_sq / norm_den_sq)\n\n    test_cases = [\n        {'Lx': 1.0, 'Ly': 0.8, 'Nx': 10, 'Ny': 8, 'E': 1000.0, 'nu': 0.3,\n         'a': 0.7, 'b': -0.4, 'c': 0.5, 'd': -0.2},\n        {'Lx': 1.0, 'Ly': 1.0, 'Nx': 4, 'Ny': 4, 'E': 500.0, 'nu': 0.25,\n         'a': 0.0, 'b': 0.0, 'c': 0.0, 'd': 0.0},\n        {'Lx': 2.0, 'Ly': 1.0, 'Nx': 16, 'Ny': 8, 'E': 2000.0, 'nu': 0.49,\n         'a': 0.2, 'b': 0.3, 'c': -0.1, 'd': 0.15},\n    ]\n\n    results = [solve_case(**case) for case in test_cases]\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2556099"}, {"introduction": "当解析解不易获得时，我们如何系统地验证有限元代码的正确性？“制造解方法”（Method of Manufactured Solutions, MMS）提供了一个强大而通用的框架。本练习将引导你设计一个完整的验证计划，通过“制造”一个光滑的解，反向推导出相应的体力项和边界条件，从而检验代码的正确性和收敛阶。掌握MMS是成为一名严谨的计算科学家或工程师的必备技能。[@problem_id:2556121]", "problem": "考虑一个静态、小应变、线弹性体，该物体占据开放方域 $\\Omega=(0,1)^2\\subset\\mathbb{R}^2$，其边界为 $\\partial\\Omega=\\Gamma_u\\cup\\Gamma_t$，且 $\\Gamma_u\\cap\\Gamma_t=\\emptyset$。令 $\\boldsymbol{u}:\\Omega\\to\\mathbb{R}^2$ 表示位移场，$\\boldsymbol{\\varepsilon}(\\boldsymbol{u})=\\tfrac{1}{2}\\left(\\nabla\\boldsymbol{u}+(\\nabla\\boldsymbol{u})^\\top\\right)$ 表示线性化应变张量，$\\boldsymbol{\\sigma}(\\boldsymbol{u})$ 表示在拉梅参数 $\\lambda0$ 和 $\\mu0$ 的平面应变条件下，各向同性线弹性的柯西应力张量，由 $\\boldsymbol{\\sigma}(\\boldsymbol{u})=\\lambda\\,(\\nabla\\cdot\\boldsymbol{u})\\,\\boldsymbol{I}+2\\mu\\,\\boldsymbol{\\varepsilon}(\\boldsymbol{u})$ 给出。体力为 $\\boldsymbol{b}:\\Omega\\to\\mathbb{R}^2$。$\\partial\\Omega$ 上的外单位法向量为 $\\boldsymbol{n}$。静态平衡的强形式为 $\\nabla\\cdot\\boldsymbol{\\sigma}+\\boldsymbol{b}=\\boldsymbol{0}$ in $\\Omega$，其位移边界条件为 $\\boldsymbol{u}=\\bar{\\boldsymbol{u}}$ on $\\Gamma_u$，面力边界条件为 $\\boldsymbol{t}=\\bar{\\boldsymbol{t}}$ on $\\Gamma_t$，其中边界力向量满足柯西关系 $\\boldsymbol{t}=\\boldsymbol{\\sigma}\\,\\boldsymbol{n}$ on $\\partial\\Omega$。\n\n您计划使用人工解法来验证此问题的基于位移的有限元法(FEM)实现，该方法在边界的非空部分上施加非平凡的、空间变化的力。目标是评估代码的正确性（平衡性的一致性和边界条件的施加）以及关于网格尺寸 $h$ 的多项式次数为 $k$ 的单元的渐近收敛率，此过程使用准均匀细化和足够光滑的数据。\n\n以下哪项概述了一个正确且完整的验证方案，该方案与上述控制定律一致，适用于评估正确性和最优收敛性，并特别检验了具有已知非零面力的面力边界条件？\n\nA. 选择一个足够光滑、非平凡的人工位移 $\\boldsymbol{u}^\\star\\in C^\\infty(\\overline{\\Omega})$，其在 $\\Gamma_t$ 上的限制与本构律结合时能产生非零面力。通过 $\\boldsymbol{b}^\\star=-\\nabla\\cdot\\boldsymbol{\\sigma}(\\boldsymbol{u}^\\star)$ in $\\Omega$ 定义体力。在一个非空的 $\\Gamma_u$ 上指定 $\\bar{\\boldsymbol{u}}=\\boldsymbol{u}^\\star$，并在一个非空的、不相交的 $\\Gamma_t$ 上指定 $\\bar{\\boldsymbol{t}}=\\boldsymbol{\\sigma}(\\boldsymbol{u}^\\star)\\,\\boldsymbol{n}$，以避免刚体模式，同时检验面力的施加。在一系列使用 k 阶单元的准均匀网格上求解，使用足够精确的积分方法来整合刚度和载荷项，使其误差在离散误差范围内。计算相对于 $\\boldsymbol{u}^\\star$ 在 $H^1$-半范数和 $L^2$-范数下的误差，并验证当 $h\\to 0$ 时，与光滑解的最佳逼近性质一致的预期渐近收敛率。\n\nB. 选择一个光滑的 $\\boldsymbol{u}^\\star$。通过 $\\boldsymbol{b}^\\star=\\nabla\\cdot\\boldsymbol{\\sigma}(\\boldsymbol{u}^\\star)$ 定义体力，通过 $\\bar{\\boldsymbol{t}}=-\\boldsymbol{\\sigma}(\\boldsymbol{u}^\\star)\\,\\boldsymbol{n}$ on $\\Gamma_t$ 定义面力。在 $\\Gamma_u$ 上施加 $\\boldsymbol{u}^\\star$，并通过监测最大节点位移误差来验证收敛性，期望对于所有 $k\\ge 1$，在 $L^\\infty$-范数下的收敛率为 $h^{k+1}$。\n\nC. 构造一个光滑且对称但不必与任何位移相容的应力场 $\\boldsymbol{\\sigma}^\\star$，在 $\\Omega$ 中设置 $\\boldsymbol{b}^\\star=\\boldsymbol{0}$，并在整个边界 $\\Gamma_t=\\partial\\Omega$ 上施加 $\\bar{\\boldsymbol{t}}=\\boldsymbol{\\sigma}^\\star\\,\\boldsymbol{n}$，不设位移约束。如果有限元解计算出的位移场，其数值应力在某个容差范围内逐点匹配 $\\boldsymbol{\\sigma}^\\star$，则验证其正确性，并报告能量范数下的收敛性。\n\nD. 选择一个光滑位移 $\\boldsymbol{u}^\\star$ 并在 $\\Omega$ 中定义 $\\boldsymbol{b}^\\star=-\\nabla\\cdot\\boldsymbol{\\sigma}(\\boldsymbol{u}^\\star)$，但取 $\\Gamma_u=\\emptyset$ 并在 $\\Gamma_t=\\partial\\Omega$ 上施加无面力边界条件 $\\bar{\\boldsymbol{t}}=\\boldsymbol{0}$，理由是体力已经检验了平衡，因此非零面力是不必要的。仅在 $L^2$-范数下确认收敛性。\n\nE. 选择一个光滑位移 $\\boldsymbol{u}^\\star$ 并定义数据，使其在强形式下满足平衡，但在组装单元矩阵和边界面力时，为降低计算成本，故意使用低阶数值积分（例如，仅对次数最高为 $k-1$ 的多项式精确）。通过检查 $H^1$-半范数误差是否随 $h$ 减小来验证正确性和收敛性，并报告任何观察到的收敛率，只要其是单调的即可接受。\n\n选择最能满足所述验证目标，并与平衡方程和面力边界条件完全一致的选项。", "solution": "任务是为线性弹性静力学问题确定一个正确且完整的基于位移的有限元法(FEM)实现的验证方案。该验证将使用人工解法(MMS)来评估代码的正确性和渐近收敛率，并特别要求测试非零面力边界条件。\n\n该问题的控制方程为：\n1.  域 $\\Omega$ 内的平衡方程：$\\nabla\\cdot\\boldsymbol{\\sigma} + \\boldsymbol{b} = \\boldsymbol{0}$\n2.  本构律（平面应变，各向同性线弹性）：$\\boldsymbol{\\sigma}(\\boldsymbol{u}) = \\lambda\\,(\\nabla\\cdot\\boldsymbol{u})\\,\\boldsymbol{I} + 2\\mu\\,\\boldsymbol{\\varepsilon}(\\boldsymbol{u})$\n3.  应变-位移关系：$\\boldsymbol{\\varepsilon}(\\boldsymbol{u}) = \\tfrac{1}{2}\\left(\\nabla\\boldsymbol{u} + (\\nabla\\boldsymbol{u})^\\top\\right)$\n4.  位移（狄利克雷）边界条件：$\\boldsymbol{u} = \\bar{\\boldsymbol{u}}$ on $\\Gamma_u$\n5.  面力（诺伊曼）边界条件：$\\boldsymbol{\\sigma}\\boldsymbol{n} = \\bar{\\boldsymbol{t}}$ on $\\Gamma_t$\n\n人工解法(MMS)是一种严谨的验证技术。其步骤包括：\n1.  选择一个人工解 $\\boldsymbol{u}^\\star$，该解必须足够光滑，以确保能够观察到理论上的渐近收敛率。\n2.  将 $\\boldsymbol{u}^\\star$ 代入控制微分方程和边界条件，以推导出必要的源项和边界数据。这确保了 $\\boldsymbol{u}^\\star$ 是所构造问题的精确解析解。\n    - 根据平衡方程：$\\boldsymbol{b}^\\star = -\\nabla\\cdot\\boldsymbol{\\sigma}(\\boldsymbol{u}^\\star)$。\n    - 根据位移边界条件：$\\bar{\\boldsymbol{u}} = \\boldsymbol{u}^\\star$ on $\\Gamma_u$。\n    - 根据面力边界条件：$\\bar{\\boldsymbol{t}} = \\boldsymbol{\\sigma}(\\boldsymbol{u}^\\star)\\boldsymbol{n}$ on $\\Gamma_t$。\n3.  使用有限元代码对此构造的边值问题进行数值求解。\n4.  在适当的范数下，计算数值解 $\\boldsymbol{u}_h$ 与已知的精确解 $\\boldsymbol{u}^\\star$ 之间的误差。\n5.  通过在一系列相继细化的网格（网格尺寸 $h \\to 0$）上求解来进行收敛性研究，并验证误差是否以理论预测的速率减小。对于一个光滑解 $\\boldsymbol{u}^\\star$ 和多项式次数为 $k$ 的拉格朗日有限元，预期的最优收敛率为：\n    - $\\|\\boldsymbol{u}^\\star - \\boldsymbol{u}_h\\|_{H^1(\\Omega)} = O(h^k)$ （或等价地，对于 $H^1$-半范数）。\n    - $\\|\\boldsymbol{u}^\\star - \\boldsymbol{u}_h\\|_{L^2(\\Omega)} = O(h^{k+1})$。\n\n实现的一个关键方面是，用于组装刚度矩阵和载荷向量的数值积分必须足够精确，以免污染离散误差。否则，观察到的收敛率将是次优的。\n\n现在，我将根据这些原则评估每个选项。\n\n**选项A评估**\n此选项建议：\n1.  选择一个光滑的人工位移 $\\boldsymbol{u}^\\star$。这是正确的起点。\n2.  将体力定义为 $\\boldsymbol{b}^\\star = -\\nabla\\cdot\\boldsymbol{\\sigma}(\\boldsymbol{u}^\\star)$。这是正确的。\n3.  在一个非空的 $\\Gamma_u$ 上指定边界条件 $\\bar{\\boldsymbol{u}} = \\boldsymbol{u}^\\star$，并在一个非空的 $\\Gamma_t$ 上指定 $\\bar{\\boldsymbol{t}} = \\boldsymbol{\\sigma}(\\boldsymbol{u}^\\star)\\boldsymbol{n}$。这正确地推导出了边界数据。通过设置一个非空的 $\\Gamma_u$，可以确保问题是适定的，并避免刚体模式。通过选择能够产生非零面力的 $\\boldsymbol{u}^\\star$，它满足了检验面力边界条件实现的具体目标。\n4.  使用足够精确的积分方法，以避免引入显著的积分误差。这是实现最优收敛率的一个关键且正确的考虑。\n5.  在 $H^1$-半范数和 $L^2$-范数下计算误差，并检查预期的渐近收敛率。这代表了对收敛性进行的一次完整和标准的验证。\n\n该方案在方法论上是健全、完整，并且与有限元法和人工解法的理论一致。\n结论：**正确**。\n\n**选项B评估**\n此选项建议：\n1.  将体力定义为 $\\boldsymbol{b}^\\star = \\nabla\\cdot\\boldsymbol{\\sigma}(\\boldsymbol{u}^\\star)$。这里的符号错误。从平衡方程 $\\nabla\\cdot\\boldsymbol{\\sigma}+\\boldsymbol{b}=\\boldsymbol{0}$ 推导出的正确关系是 $\\boldsymbol{b} = -\\nabla\\cdot\\boldsymbol{\\sigma}$。\n2.  将面力定义为 $\\bar{\\boldsymbol{t}} = -\\boldsymbol{\\sigma}(\\boldsymbol{u}^\\star)\\boldsymbol{n}$。这里的符号也错误。边界条件是 $\\boldsymbol{\\sigma n} = \\bar{\\boldsymbol{t}}$。\n3.  它建议只监测最大节点位移误差。虽然 $L^\\infty$-范数是一个有效的误差度量，但仅关注节点值可能会产生误导。更重要的是，使用像 $L^2$ 和 $H^1$ 这样的积分范数是标准做法，并且更为稳健，因为它们衡量了整个域上的误差，并与问题的弱形式直接相关。\n\n在人工数据定义中的符号错误是根本性缺陷。代码将求解一个不同于以 $\\boldsymbol{u}^\\star$ 为解的问题，这使得任何针对 $\\boldsymbol{u}^\\star$ 的误差计算对于验证来说都毫无意义。\n结论：**不正确**。\n\n**选项C评估**\n此选项有几个根本性缺陷：\n1.  它建议构造一个“不必与任何位移相容”的应力场 $\\boldsymbol{\\sigma}^\\star$。一个不相容的应力场违反了应变协调条件。基于位移的有限元格式在一个函数空间中寻求解答，其中应变根据定义是由位移导出的，因此是相容的。这样的问题在基于位移的框架内没有解。\n2.  它设置了一个纯面力问题（$\\Gamma_u = \\emptyset$）。对于弹性静力学，这样的问题是不适定的，因为解在刚体运动（在 $\\mathbb{R}^2$ 中，两个平移和一个旋转）的意义下是不确定的。只有当外载荷（体力和面力）自平衡时，解才存在。验证测试应基于一个适定的问题。\n3.  验证标准（“数值应力在容差范围内逐点匹配 $\\boldsymbol{\\sigma}^\\star$”）不是人工解法的标准程序。标准程序是检查主场变量（$\\boldsymbol{u}$）相对于其已知精确解（$\\boldsymbol{u}^\\star$）的收敛率。\n\n这种方法与弹性力学和基于位移的有限元法的数学基础都不一致。\n结论：**不正确**。\n\n**选项D评估**\n此选项建议：\n1.  设置 $\\Gamma_u=\\emptyset$ 并在 $\\Gamma_t=\\partial\\Omega$ 上设置 $\\bar{\\boldsymbol{t}}=\\boldsymbol{0}$。与选项C一样，这设置了一个不适定的纯诺伊曼问题。\n2.  它认为测试非零面力是不必要的。这明确地未能满足问题描述中提出的一个关键目标：“特别是在已知非零面力的情况下检验面力边界条件”。验证非零面力的边界积分的组装是一个全面的验证套件中必不可少的部分。\n3.  它建议仅在 $L^2$-范数下确认收敛性。这是一个不完整的检查。在能量范数（$H^1$-范数）下的收敛是标准有限元理论（通过Céa引理）的主要结果，必须得到验证。\n\n这个方案是有缺陷的，因为它构建了一个不适定的问题，并且未能满足指定的验证目标。\n结论：**不正确**。\n\n**选项E评估**\n此选项有两个主要缺陷：\n1.  它建议使用“故意低阶的数值积分”。这会引入积分误差，随着网格的细化，该误差将主导离散误差，从而无法观察到最优的理论收敛率。验证研究的目的是确认代码在正确配置下能够达到这些最优速率。故意使用不精确的积分会破坏这个目标。虽然减缩积分有其用途，但它不是旨在确认理论速率的标准验证方案的一部分。\n2.  它提出了一个宽松的成功标准：“检查 $H^1$-半范数误差是否随 $h$ 减小，并报告任何观察到的速率，只要其是单调的即可接受。”这完全不够。人工解法的目标是定量验证。必须检查收敛的*速率*是否与理论预测（例如 $O(h^k)$）相匹配。任何单调减少都不能作为正确性的可接受证明。一个有错误的代码可能仍然会显示某种程度的收敛，但速率是次优的。\n\n这个方案描述了一个拙劣且不确定的验证过程。\n结论：**不正确**。\n\n总而言之，只有选项A概述了一个严谨、理论上健全，并满足问题中所有要求的验证方案。它正确地应用了人工解法，确保了一个适定的问题，并指定了对正确性和最优性能的适当检查。", "answer": "$$\\boxed{A}$$", "id": "2556121"}]}