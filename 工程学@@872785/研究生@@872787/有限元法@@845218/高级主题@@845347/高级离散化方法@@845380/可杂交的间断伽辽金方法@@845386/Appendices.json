{"hands_on_practices": [{"introduction": "HDG 方法的威力在于其能够将一个全局问题分解为一系列独立的、在单元上局部求解的问题。这第一个实践对于理解这一核心概念至关重要。通过为一个简单的参考单元推导局部矩阵，您将具体地理解原始未知量 $u_h$ 和通量未知量 $\\boldsymbol{q}_h$ 是如何被单元层面上的新迹未知量 $\\widehat{u}_h$ 所决定的 ([@problem_id:2566501])。这个练习构成了静态凝聚以及整个 HDG 框架的基础。", "problem": "考虑在顶点为 $(0,0)$、$(1,0)$ 和 $(0,1)$ 的参考单元三角形 $\\widehat{T}$ 上的泊松方程的可杂交间断伽辽金 (HDG) 方法。设扩散系数为常数 $1$，且稳定化参数 $\\tau$ 在每条边上为常数。处理 $\\widehat{T}$ 上的一阶系统\n$\\boldsymbol{q} + \\nabla u = \\boldsymbol{0}$ 和 $\\nabla \\cdot \\boldsymbol{q} = f$，并假设 $f \\equiv 0$，以便局部求解器将迹未知量 $\\widehat{u}_h$ 映射到单元未知量 $(q_h,u_h)$，而无载荷项的贡献。\n\n在每条边 $\\mathcal{F} \\subset \\partial \\widehat{T}$ 上，使用多项式空间 $V_h(\\widehat{T}) = [\\mathcal{P}_k(\\widehat{T})]^2$、$W_h(\\widehat{T}) = \\mathcal{P}_k(\\widehat{T})$ 和 $M_h(\\partial \\widehat{T}) = \\mathcal{P}_k(\\mathcal{F})$，其中 $k = 1$。设 $\\{\\boldsymbol{\\varphi}_i\\}_{i=1}^{N_v}$ 为 $V_h(\\widehat{T})$ 的一组基，$\\{\\phi_j\\}_{j=1}^{N_w}$ 为 $W_h(\\widehat{T})$ 的一组基，$\\{\\psi_m\\}_{m=1}^{N_m}$ 为由逐边基组装成的 $M_h(\\partial \\widehat{T})$ 的一组基。在 $\\partial \\widehat{T}$ 上采用数值通量 $\\widehat{q}_h \\cdot n = q_h \\cdot n + \\tau\\,(u_h - \\widehat{u}_h)$。\n\n从一阶系统的弱形式出发，推导将迹系数 $\\widehat{\\boldsymbol{u}} \\in \\mathbb{R}^{N_m}$ 映射到 $(q_h,u_h)$ 的局域系数的单元局部线性系统，其分块形式写作\n$$\n\\begin{pmatrix}\n\\mathbf{M}  \\mathbf{D}^\\top \\\\\n\\mathbf{B}  \\mathbf{N}\n\\end{pmatrix}\n\\begin{pmatrix}\n\\boldsymbol{q} \\\\\n\\boldsymbol{u}\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n\\mathbf{C} \\\\\n\\mathbf{T}\n\\end{pmatrix}\n\\widehat{\\boldsymbol{u}}.\n$$\n此处，向量 $\\boldsymbol{q} \\in \\mathbb{R}^{N_v}$ 和 $\\boldsymbol{u} \\in \\mathbb{R}^{N_w}$ 分别汇集了 $q_h$ 和 $u_h$ 在所选基下的系数，而 $\\widehat{\\boldsymbol{u}}$ 汇集了 $\\widehat{u}_h$ 在 $\\partial \\widehat{T}$ 上的系数。显式地将每个局部矩阵 $\\mathbf{M}$、$\\mathbf{D}$、$\\mathbf{B}$、$\\mathbf{N}$、$\\mathbf{C}$ 和 $\\mathbf{T}$ 用关于所选基的单元或边积分表示。然后，对于参考单元三角形 $\\widehat{T}$ 上的 $k=1$ 情况，计算这些矩阵的尺寸（行数和列数）。\n\n最后，基于你的推导，确定在组装 HDG 局部系统时每个单元的局部未知量总数 $N_{\\text{tot}}$，即在 $\\widehat{T}$ 上当 $k=1$ 时拼接向量 $(\\boldsymbol{q}, \\boldsymbol{u}, \\widehat{\\boldsymbol{u}})$ 的维数。将 $N_{\\text{tot}}$ 以无单位的单个整数形式报告。", "solution": "所述问题具有科学依据、是适定的、客观的且自洽的。这是数值分析领域，特别是关于有限元方法的一个标准推导。不存在矛盾、歧义或事实性错误。因此，该问题被认为是有效的，并将提供解答。\n\n该问题要求推导在参考单元三角形 $\\widehat{T}$ 上应用可杂交间断伽辽金 (HDG) 方法求解泊松方程的局部线性系统。控制性一阶系统由以下方程给出：\n$$\n\\boldsymbol{q} + \\nabla u = \\boldsymbol{0} \\quad \\text{in } \\widehat{T}\n$$\n$$\n\\nabla \\cdot \\boldsymbol{q} = f \\quad \\text{in } \\widehat{T}\n$$\n我们已知源项 $f \\equiv 0$，扩散系数为 $1$，多项式次数为 $k=1$。\n\n单元局部系统的推导过程是通过建立这些方程的弱形式。我们将第一个方程乘以一个向量检验函数 $\\boldsymbol{v} \\in V_h(\\widehat{T})$，第二个方程乘以一个标量检验函数 $w \\in W_h(\\widehat{T})$，然后在单元 $\\widehat{T}$ 上积分。\n\n对于第一个方程，我们有：\n$$\n\\int_{\\widehat{T}} (\\boldsymbol{q}_h \\cdot \\boldsymbol{v}) \\, d\\boldsymbol{x} + \\int_{\\widehat{T}} (\\nabla u_h \\cdot \\boldsymbol{v}) \\, d\\boldsymbol{x} = 0\n$$\n对第二项应用分部积分（格林第一恒等式）可得：\n$$\n\\int_{\\widehat{T}} (\\nabla u_h \\cdot \\boldsymbol{v}) \\, d\\boldsymbol{x} = -\\int_{\\widehat{T}} u_h (\\nabla \\cdot \\boldsymbol{v}) \\, d\\boldsymbol{x} + \\int_{\\partial \\widehat{T}} u_h (\\boldsymbol{v} \\cdot \\boldsymbol{n}) \\, dS\n$$\n在 HDG 方法中，标量场 $u_h$ 在边界 $\\partial \\widehat{T}$ 上的迹被一个新的独立未知量，即数值迹 $\\widehat{u}_h \\in M_h(\\partial \\widehat{T})$ 所取代。将此代入方程，我们得到第一个偏微分方程的弱形式：\n$$\n\\int_{\\widehat{T}} (\\boldsymbol{q}_h \\cdot \\boldsymbol{v}) \\, d\\boldsymbol{x} - \\int_{\\widehat{T}} u_h (\\nabla \\cdot \\boldsymbol{v}) \\, d\\boldsymbol{x} + \\int_{\\partial \\widehat{T}} \\widehat{u}_h (\\boldsymbol{v} \\cdot \\boldsymbol{n}) \\, dS = 0, \\quad \\forall \\boldsymbol{v} \\in V_h(\\widehat{T})\n$$\n\n对于第二个方程 $\\nabla \\cdot \\boldsymbol{q}_h = 0$，其弱形式为：\n$$\n\\int_{\\widehat{T}} (\\nabla \\cdot \\boldsymbol{q}_h) w \\, d\\boldsymbol{x} = 0\n$$\n应用分部积分可得：\n$$\n-\\int_{\\widehat{T}} (\\boldsymbol{q}_h \\cdot \\nabla w) \\, d\\boldsymbol{x} + \\int_{\\partial \\widehat{T}} (\\boldsymbol{q}_h \\cdot \\boldsymbol{n}) w \\, dS = 0\n$$\n通量的法向分量 $\\boldsymbol{q}_h \\cdot \\boldsymbol{n}$ 被数值通量 $\\widehat{\\boldsymbol{q}}_h \\cdot \\boldsymbol{n} = \\boldsymbol{q}_h \\cdot \\boldsymbol{n} + \\tau (u_h - \\widehat{u}_h)$ 所取代，其中 $\\tau$ 是稳定化参数。这导出了第二个弱形式：\n$$\n-\\int_{\\widehat{T}} (\\boldsymbol{q}_h \\cdot \\nabla w) \\, d\\boldsymbol{x} + \\int_{\\partial \\widehat{T}} (\\boldsymbol{q}_h \\cdot \\boldsymbol{n} + \\tau (u_h - \\widehat{u}_h)) w \\, dS = 0, \\quad \\forall w \\in W_h(\\widehat{T})\n$$\n\n为了获得矩阵系统，我们将离散解在其各自的基中展开：\n$\\boldsymbol{q}_h = \\sum_{j=1}^{N_v} q_j \\boldsymbol{\\varphi}_j(\\boldsymbol{x})$，$u_h = \\sum_{j=1}^{N_w} u_j \\phi_j(\\boldsymbol{x})$，以及 $\\widehat{u}_h = \\sum_{j=1}^{N_m} \\widehat{u}_j \\psi_j(\\boldsymbol{x})$。我们依次对每个基函数进行检验。设检验函数为 $\\boldsymbol{v} = \\boldsymbol{\\varphi}_i$ 和 $w = \\phi_i$。\n\n从第一个弱形式方程出发，令 $\\boldsymbol{v} = \\boldsymbol{\\varphi}_i$（$i=1, \\dots, N_v$）：\n$$\n\\sum_{j=1}^{N_v} \\left( \\int_{\\widehat{T}} \\boldsymbol{\\varphi}_j \\cdot \\boldsymbol{\\varphi}_i \\, d\\boldsymbol{x} \\right) q_j - \\sum_{j=1}^{N_w} \\left( \\int_{\\widehat{T}} (\\nabla \\cdot \\boldsymbol{\\varphi}_i) \\phi_j \\, d\\boldsymbol{x} \\right) u_j = - \\sum_{j=1}^{N_m} \\left( \\int_{\\partial \\widehat{T}} (\\boldsymbol{\\varphi}_i \\cdot \\boldsymbol{n}) \\psi_j \\, dS \\right) \\widehat{u}_j\n$$\n将其与目标系统的第一个分块行 $\\mathbf{M}\\boldsymbol{q} + \\mathbf{D}^\\top\\boldsymbol{u} = \\mathbf{C}\\widehat{\\boldsymbol{u}}$ 进行比较，我们确定了以下矩阵（使用行索引 $i$，列索引 $j$）：\n- $\\mathbf{M}_{ij} = \\int_{\\widehat{T}} \\boldsymbol{\\varphi}_j \\cdot \\boldsymbol{\\varphi}_i \\, d\\boldsymbol{x}$\n- $(\\mathbf{D}^\\top)_{ij} = - \\int_{\\widehat{T}} (\\nabla \\cdot \\boldsymbol{\\varphi}_i) \\phi_j \\, d\\boldsymbol{x}$\n- $\\mathbf{C}_{ij} = -\\int_{\\partial \\widehat{T}} (\\boldsymbol{\\varphi}_i \\cdot \\boldsymbol{n}) \\psi_j \\, dS$\n\n从第二个弱形式方程出发，令 $w = \\phi_i$（$i=1, \\dots, N_w$）：\n$$\n\\sum_{j=1}^{N_v} \\left( -\\int_{\\widehat{T}} \\boldsymbol{\\varphi}_j \\cdot \\nabla \\phi_i \\, d\\boldsymbol{x} + \\int_{\\partial \\widehat{T}} (\\boldsymbol{\\varphi}_j \\cdot \\boldsymbol{n}) \\phi_i \\, dS \\right) q_j + \\sum_{j=1}^{N_w} \\left( \\int_{\\partial \\widehat{T}} \\tau \\phi_j \\phi_i \\, dS \\right) u_j = \\sum_{j=1}^{N_m} \\left( \\int_{\\partial \\widehat{T}} \\tau \\phi_i \\psi_j \\, dS \\right) \\widehat{u}_j\n$$\n对第一项使用分部积分：$-\\int_{\\widehat{T}} \\boldsymbol{\\varphi}_j \\cdot \\nabla \\phi_i \\, d\\boldsymbol{x} = \\int_{\\widehat{T}} (\\nabla \\cdot \\boldsymbol{\\varphi}_j) \\phi_i \\, d\\boldsymbol{x} - \\int_{\\partial \\widehat{T}} (\\boldsymbol{\\varphi}_j \\cdot \\boldsymbol{n}) \\phi_i \\, dS$。边界项相互抵消，简化了表达式。\n与第二个分块行 $\\mathbf{B}\\boldsymbol{q} + \\mathbf{N}\\boldsymbol{u} = \\mathbf{T}\\widehat{\\boldsymbol{u}}$ 进行比较，我们确定：\n- $\\mathbf{B}_{ij} = \\int_{\\widehat{T}} (\\nabla \\cdot \\boldsymbol{\\varphi}_j) \\phi_i \\, d\\boldsymbol{x}$\n- $\\mathbf{N}_{ij} = \\int_{\\partial \\widehat{T}} \\tau \\phi_j \\phi_i \\, dS$\n- $\\mathbf{T}_{ij} = \\int_{\\partial \\widehat{T}} \\tau \\phi_i \\psi_j \\, dS$\n\n从这些定义中，我们观察到关系 $\\mathbf{B} = -\\mathbf{D}$，其中矩阵 $\\mathbf{D}$ 是 $\\mathbf{D}^\\top$ 的转置，即 $D_{ji} = (\\mathbf{D}^\\top)_{ij}$。\n\n接下来，我们计算在二维域参考单元三角形 $\\widehat{T}$ 上，当 $k=1$ 时这些矩阵的尺寸。\n多项式空间 $\\mathcal{P}_k(\\mathbb{R}^d)$ 的维数是 $\\binom{k+d}{d}$。\n- 对于标量空间 $W_h(\\widehat{T}) = \\mathcal{P}_1(\\widehat{T})$，我们有 $d=2, k=1$。其维数为 $N_w = \\binom{1+2}{2} = 3$。\n- 对于向量空间 $V_h(\\widehat{T}) = [\\mathcal{P}_1(\\widehat{T})]^2$，两个分量中的每一个都位于一个 $3$ 维空间中。因此，总维数为 $N_v = 2 \\times 3 = 6$。\n- 对于迹空间 $M_h(\\partial \\widehat{T})$，边界由 $3$ 条边组成。在每条边 $\\mathcal{F}$（一个一维域）上，空间为 $\\mathcal{P}_1(\\mathcal{F})$。其维数为 $\\binom{1+1}{1} = 2$。由于迹空间是每条边上空间的直和，总维数为 $N_m = 3 \\times 2 = 6$。\n\n矩阵的尺寸（行数 $\\times$ 列数）由相应空间的维数确定：\n- $\\mathbf{M}: N_v \\times N_v \\implies 6 \\times 6$\n- $\\mathbf{D}^\\top: N_v \\times N_w \\implies 6 \\times 3$\n- $\\mathbf{B}: N_w \\times N_v \\implies 3 \\times 6$\n- $\\mathbf{N}: N_w \\times N_w \\implies 3 \\times 3$\n- $\\mathbf{C}: N_v \\times N_m \\implies 6 \\times 6$\n- $\\mathbf{T}: N_w \\times N_m \\implies 3 \\times 6$\n\n最后，单元局部未知量的总数 $N_{\\text{tot}}$ 是 $\\boldsymbol{q}_h$、$u_h$ 和 $\\widehat{u}_h$ 的系数数量之和。\n$$\nN_{\\text{tot}} = N_v + N_w + N_m\n$$\n代入为 $k=1$ 计算出的维数：\n$$\nN_{\\text{tot}} = 6 + 3 + 6 = 15\n$$\n这是局部未知量向量 $(\\boldsymbol{q}, \\boldsymbol{u}, \\widehat{\\boldsymbol{u}})$ 的总维数。", "answer": "$$\\boxed{15}$$", "id": "2566501"}, {"introduction": "一旦理解了局部系统，下一步就是观察它们如何被“粘合”在一起，形成一个关于迹未知量的全局问题。本实践将背景简化到一维和最低阶多项式，以清晰直观地展示静态凝聚的过程 ([@problem_id:2566544])。您将看到，通过在单元边界上强制执行通量连续性，如何导出一个稀疏的“骨架”系统，并发现先进的 HDG 方法与我们所熟悉的有限差分格式之间惊人的联系。", "problem": "考虑一维空间中的扩散模型问题：求解 $u$ 使得在 $(0,L)$ 上满足 $-(\\kappa u^{\\prime})^{\\prime} = f$，并带有齐次 Dirichlet 边界条件 $u(0)=0$ 和 $u(L)=0$，其中 $\\kappa0$ 为常数。将区间离散为一个由 $N$ 个尺寸为 $h = L/N$ 的单元组成的均匀网格，节点为 $\\{x_i\\}_{i=0}^{N}$。应用可杂交间断 Galerkin (HDG, hybridizable discontinuous Galerkin) 方法，在每个单元 $K=[x_{i-1},x_i]$ 上对单元未知数使用 $k=0$ 的多项式次数，并在所有面上使用常数稳定化参数 $\\tau0$。使用一阶系统，其通量为 $q = -\\kappa u^{\\prime}$，并在 $\\partial K$ 上使用标准 HDG 数值通量 $\\widehat{q}\\,n = q\\,n + \\tau\\,(u - \\widehat{u})$，其中 $n$ 是外法线，$u$ 和 $q$ 表示单元未知数（在 $K$ 上为常数），$\\widehat{u}$ 是定义在网格骨架上的单值迹未知数（每个节点一个标量）。\n\n从每个单元 $K$ 上的 HDG 局部方程出发：\n- $(\\kappa^{-1} q, r)_K - (u, r^{\\prime})_K + \\langle \\widehat{u}, r\\,n \\rangle_{\\partial K} = 0$，对所有在 $K$ 上的常数 $r$ 成立，\n- $-(q, v^{\\prime})_K + \\langle \\widehat{q}\\,n, v \\rangle_{\\partial K} = (f, v)_K$，对所有在 $K$ 上的常数 $v$ 成立，\n并施加全局 HDG 传输条件，即在每个内部节点处数值通量 $\\widehat{q}\\,n$ 的总和为零，消去单元未知数 $u$ 和 $q$，从而得到关于节点迹未知数 $\\{\\widehat{u}_i\\}_{i=1}^{N-1}$ 的凝聚的全局（骨架）系统。证明该凝聚的骨架系统在内部节点上具有一个与标准二阶差分格式 $[1,\\,-2,\\,1]$ 成比例的三对角三点格式。\n\n使得凝聚的骨架刚度矩阵等于标准二阶差分三对角矩阵在内部节点上的 $c$ 倍的精确比例常数 $c$ 是多少，用 $\\kappa$、$h$ 和 $\\tau$ 表示？请以 $c$ 的单一闭式解析表达式给出您的答案。", "solution": "我们从扩散方程 $-(\\kappa u^{\\prime})^{\\prime} = f$ on $(0,L)$ 及齐次 Dirichlet 边界条件 $u(0)=0$ 和 $u(L)=0$ 开始。引入一阶系统\n$$\nq = -\\kappa u^{\\prime}, \\qquad -q^{\\prime} = f.\n$$\n在均匀网格上使用多项式次数 $k=0$ 的可杂交间断 Galerkin (HDG, hybridizable discontinuous Galerkin) 方法中，单元未知数 $(q,u)$ 在每个长度为 $h$ 的单元 $K=[x_{i-1},x_i]$ 上是常数，而迹 $\\widehat{u}$ 在每个节点 $x_i$ 处是一个标量。数值通量为\n$$\n\\widehat{q}\\,n = q\\,n + \\tau\\,(u - \\widehat{u}) \\quad \\text{on } \\partial K,\n$$\n其中稳定化参数 $\\tau0$ 是常数。\n\n令 $(\\cdot,\\cdot)_K$ 表示 $K$ 上的 $L^2$ 内积，$\\langle \\cdot, \\cdot \\rangle_{\\partial K}$ 表示在两个单元面上的求和。由于 $k=0$，测试函数 $r$ 和 $v$ 在 $K$ 上是常数，因此 $r^{\\prime} = 0$ 和 $v^{\\prime} = 0$。单元 $K$ 上的局部 HDG 方程简化为：\n$$\n(\\kappa^{-1} q, r)_K + \\langle \\widehat{u}, r\\,n \\rangle_{\\partial K} = 0, \\qquad \\langle \\widehat{q}\\,n, v \\rangle_{\\partial K} = (f, v)_K,\n$$\n对所有常数 $r$ 和 $v$ 成立。取 $r=1$ 和 $v=1$，并利用 $(\\kappa^{-1} q, 1)_K = \\kappa^{-1} q\\, h$ 和 $(f,1)_K = \\bar{f}_K\\, h$（其中 $\\bar{f}_K$ 是 $f$ 在 $K$ 上的单元平均值），并将左右端点的节点迹值分别记为 $\\widehat{u}_{i-1}$ 和 $\\widehat{u}_{i}$，我们得到：\n$$\n\\kappa^{-1} q\\, h + \\big(\\widehat{u}_i \\cdot (+1) + \\widehat{u}_{i-1} \\cdot (-1)\\big) = 0,\n$$\n即\n$$\nq = -\\kappa\\,\\frac{\\widehat{u}_i - \\widehat{u}_{i-1}}{h}.\n$$\n对于第二个局部方程，我们对两个面上的数值通量贡献求和。在 $x_{i-1}$ 处单位外法线为 $n=-1$，在 $x_i$ 处为 $n=+1$，并在每个面上使用 $\\widehat{q}\\,n = q\\,n + \\tau (u - \\widehat{u})$，可得：\n$$\n\\langle \\widehat{q}\\,n, 1 \\rangle_{\\partial K}\n= \\big[q\\cdot(+1) + \\tau\\,(u - \\widehat{u}_i)\\big] + \\big[q\\cdot(-1) + \\tau\\,(u - \\widehat{u}_{i-1})\\big]\n= \\tau\\,[2u - (\\widehat{u}_i + \\widehat{u}_{i-1})].\n$$\n令其与 $(f,1)_K = \\bar{f}_K h$ 相等，得出局部关系\n$$\n\\tau\\,[2u - (\\widehat{u}_i + \\widehat{u}_{i-1})] = \\bar{f}_K\\, h,\n$$\n因此\n$$\nu = \\frac{1}{2}\\,(\\widehat{u}_i + \\widehat{u}_{i-1}) + \\frac{h}{2\\tau}\\,\\bar{f}_K.\n$$\n\n现在，我们在每个内部节点 $x_i$ 处施加全局 HDG 传输条件，即来自相邻单元穿过该节点的数值通量之和为零：\n$$\n\\big(\\widehat{q}\\,n\\big)\\big|_{K_{L},\\,\\text{right face at }x_i} + \\big(\\widehat{q}\\,n\\big)\\big|_{K_{R},\\,\\text{left face at }x_i} = 0,\n$$\n其中 $K_L=[x_{i-1},x_i]$ 且 $K_R=[x_i,x_{i+1}]$。在 $K_L$ 上使用先前导出的局部表达式 $q_L = -\\kappa(\\widehat{u}_i - \\widehat{u}_{i-1})/h$ 和 $u_L = \\tfrac{1}{2}(\\widehat{u}_i + \\widehat{u}_{i-1}) + \\tfrac{h}{2\\tau}\\,\\bar{f}_{L}$，来自 $K_L$ 右侧面的数值通量为\n$$\n\\big(\\widehat{q}\\,n\\big)_{K_L,\\text{ right}} = q_L\\cdot(+1) + \\tau\\,(u_L - \\widehat{u}_i)\n= -\\frac{\\kappa}{h}\\,(\\widehat{u}_i - \\widehat{u}_{i-1}) + \\frac{\\tau}{2}\\,(\\widehat{u}_{i-1} - \\widehat{u}_i) + \\frac{h}{2}\\,\\bar{f}_L.\n$$\n类似地，在 $K_R$ 上，有 $q_R = -\\kappa(\\widehat{u}_{i+1} - \\widehat{u}_i)/h$ 和 $u_R = \\tfrac{1}{2}(\\widehat{u}_{i+1} + \\widehat{u}_{i}) + \\tfrac{h}{2\\tau}\\,\\bar{f}_{R}$，来自左侧面的数值通量为\n$$\n\\big(\\widehat{q}\\,n\\big)_{K_R,\\text{ left}} = q_R\\cdot(-1) + \\tau\\,(u_R - \\widehat{u}_i)\n= \\frac{\\kappa}{h}\\,(\\widehat{u}_{i+1} - \\widehat{u}_i) + \\frac{\\tau}{2}\\,(\\widehat{u}_{i+1} - \\widehat{u}_i) + \\frac{h}{2}\\,\\bar{f}_R.\n$$\n将二者相加并设为零，得到内部节点 $x_i$ 处的凝聚全局方程：\n$$\n\\Big(\\frac{\\kappa}{h} + \\frac{\\tau}{2}\\Big)\\,\\widehat{u}_{i-1} - \\Big(2\\,\\frac{\\kappa}{h} + \\tau\\Big)\\,\\widehat{u}_{i} + \\Big(\\frac{\\kappa}{h} + \\frac{\\tau}{2}\\Big)\\,\\widehat{u}_{i+1}\n= -\\frac{h}{2}\\,(\\bar{f}_L + \\bar{f}_R).\n$$\n注意到左侧可以因式分解为\n$$\n\\Big(\\frac{\\kappa}{h} + \\frac{\\tau}{2}\\Big)\\,\\big(\\widehat{u}_{i-1} - 2\\,\\widehat{u}_i + \\widehat{u}_{i+1}\\big),\n$$\n因为 $- \\big(2\\,\\tfrac{\\kappa}{h} + \\tau\\big) = -2 \\big(\\tfrac{\\kappa}{h} + \\tfrac{\\tau}{2}\\big)$。因此，在内部节点上的凝聚骨架刚度矩阵正好是标准二阶差分三对角矩阵（格式为 $[1,\\,-2,\\,1]$）的一个常数倍。\n\n因此，使得凝聚骨架矩阵等于标准二阶差分矩阵 $c$ 倍的比例常数 $c$ 为\n$$\nc = \\frac{\\kappa}{h} + \\frac{\\tau}{2}.\n$$\n该常数与源项 $f$ 无关，仅取决于 $\\kappa$、$h$ 和稳定化参数 $\\tau$。", "answer": "$$\\boxed{\\frac{\\kappa}{h}+\\frac{\\tau}{2}}$$", "id": "2566544"}, {"introduction": "HDG 方法的效率在大规模并行计算中才真正得以体现，这正是其结构带来的直接优势。这最后一个实践将从理论转向一个实际的算法挑战，旨在解决骨架系统的并行组装问题 ([@problem_id:2566516])。您将为一个分布式内存环境设计一种通信策略，模拟来自不同处理器的局部贡献如何被高效地组合起来以构建全局系统。对于任何想要实现现代有限元方法的计算科学家来说，这都是一项关键技能。", "problem": "构建一个可实现的算法，用于在多个消息传递接口 (MPI) 进程之间并行化可杂交间断伽辽金 (HDG) 方法中的局部静态凝聚和骨架组装，并为共享面指定显式通信模式。从伽辽金有限元组装的基本属性出发，即单元贡献是可加一致的，并且杂交（静态凝聚）会消去内部未知数以获得迹（骨架）未知数上的舒尔补。具体而言，假设以下基本事实：(i) 对于每个单元 $K$，内部未知数在局部被消去，以产生面-局部贡献，这些贡献进入一个单元级的迹上舒尔补算子；(ii) 骨架上的全局组装是每个面上相关单元贡献的加和；在区域分解下，只有当面所邻接的单元位于不同的 MPI 进程上时，才需要通信。\n\n您必须完成以下所有任务。\n\n1) 从第一性原理出发，推导出一个算法流程，该流程：\n- 在每个 MPI 进程上，为该进程拥有的所有单元独立执行局部求解。\n- 对于每个可能位于不同进程上的两个单元所共享的面，确定一个唯一的面所有者进程，并规定一种邻居聚合通信模式，其中，对于每对进程 $(r_{\\text{src}}, r_{\\text{dst}})$，所有从 $r_{\\text{src}}$ 发往 $r_{\\text{dst}}$ 的面贡献被打包成单条消息，并按全局面标识符的升序排列。\n- 在每个面的所有者进程上，通过将接收到的贡献与任何本地贡献相加，组装最终的面块。\n\n2) 实现一个程序，在给定下面抽象描述的离散化的情况下，为每个测试用例计算两个可测量的量：\n- 全局组装的骨架算子限制在对角面块上的弗罗贝尼乌斯范数，定义如下。对于每个具有 $m$ 个迹自由度的面 $f$，令 $S^{(e)}_{ff} \\in \\mathbb{R}^{m \\times m}$ 表示与面 $f$ 相邻的单元 $e$ 的局部面块贡献。面 $f$ 的组装面块为 $S_{f} = \\sum_{e \\in \\mathcal{N}(f)} S^{(e)}_{ff}$，其中 $\\mathcal{N}(f)$ 是与面 $f$ 相邻的单元集合。考虑块对角矩阵 $S = \\operatorname{diag}(S_{0}, S_{1}, \\dots, S_{F-1}) \\in \\mathbb{R}^{(mF) \\times (mF)}$，其中 $F$ 是面的数量。输出 $S$ 的弗罗贝尼乌斯范数 $\\|S\\|_{F}$。\n- 总通信量，以在上述邻居聚合规则下，所有消息中发送的浮点标量（双精度浮点数）数量衡量。每个源自非所有者进程上的单元 $e$ 并发往面 $f$ 的所有者进程的贡献 $S^{(e)}_{ff}$，会为通信量增加 $m^{2}$ 个双精度浮点数。令 $M$ 为不同邻居聚合消息的数量（具有非零有效载荷的不同有序进程对的数量）。您还必须计算 $M$。\n\n3) 为使问题自包含且纯粹算法化，局部舒尔面块贡献 $S^{(e)}_{ff}$ 应通过以下规则确定性地生成，该规则模拟了由消元产生的对称正定面块：\n- 对于面 $f$ 和相邻单元 $e$，定义一个向量 $v \\in \\mathbb{R}^{m}$，其分量为 $v_{i} = (e+1) + 0.1\\,(f+1) + 0.01\\,(i+1)$，$i=0,\\dots,m-1$，并设 $\\alpha = 1.0 + \\big((e + 2f) \\bmod 3\\big)$。则\n$$\nS^{(e)}_{ff} \\;=\\; \\alpha I_{m} + v v^{\\top},\n$$\n其中 $I_{m}$ 是 $m \\times m$ 的单位矩阵。此定义确保了对称性和正定性，无需任何偏微分方程的具体细节，并与加性面组装一致。\n\n4) 通信和所有权规则：\n- 每个面 $f$ 都有一个唯一的所有者进程 $r_{\\text{own}}(f)$，该进程从其相邻单元的进程集合中选出。如果与面 $f$ 相邻的单元 $e$ 位于进程 $r(e)$ 上，且 $r(e) \\neq r_{\\text{own}}(f)$，则其贡献 $S^{(e)}_{ff}$ 必须从 $r(e)$ 发送到 $r_{\\text{own}}(f)$。\n- 邻居聚合消息传递规定，对于每个有序对 $(r_{\\text{src}}, r_{\\text{dst}})$，只发送一条消息，其中包含所有满足 $r(e)=r_{\\text{src}}$ 和 $r_{\\text{own}}(f)=r_{\\text{dst}}$ 的所需贡献 $S^{(e)}_{ff}$ 的串联，并按全局面标识符 $f$ 的升序排列。\n\n5) 测试套件。您的程序必须硬编码并执行以下三个测试用例。在每个用例中，您应计算并输出弗罗贝尼乌斯范数 $\\|S\\|_{F}$、消息数 $M$ 和发送的双精度浮点数总数 $V$。\n\n- 测试用例 A（含一个跨进程面的链）：\n    - 进程数：$R=2$。\n    - 单元数：$E=3$，单元 $e=0,1,2$ 的进程所有权分别为 $[0,0,1]$。\n    - 面数：$F=4$，邻接关系和所有者进程如下：\n        - 面 $f=0$：相邻单元 $[0]$，所有者进程 $0$。\n        - 面 $f=1$：相邻单元 $[0,1]$，所有者进程 $0$。\n        - 面 $f=2$：相邻单元 $[1,2]$，所有者进程 $1$。\n        - 面 $f=3$：相邻单元 $[2]$，所有者进程 $1$。\n    - 每面的迹自由度：$m=2$。\n\n- 测试用例 B（含两个跨进程面的多进程链）：\n    - 进程数：$R=3$。\n    - 单元数：$E=4$，单元 $e=0,1,2,3$ 的进程所有权分别为 $[0,1,1,2]$。\n    - 面数：$F=6$，邻接关系和所有者进程如下：\n        - 面 $f=0$：相邻单元 $[0]$，所有者进程 $0$。\n        - 面 $f=1$：相邻单元 $[0,1]$，所有者进程 $0$。\n        - 面 $f=2$：相邻单元 $[1]$，所有者进程 $1$。\n        - 面 $f=3$：相邻单元 $[1,2]$，所有者进程 $1$。\n        - 面 $f=4$：相邻单元 $[2,3]$，所有者进程 $2$。\n        - 面 $f=5$：相邻单元 $[3]$，所有者进程 $2$。\n    - 每面的迹自由度：$m=3$。\n\n- 测试用例 C（无跨进程面）：\n    - 进程数：$R=2$。\n    - 单元数：$E=3$，单元 $e=0,1,2$ 的进程所有权分别为 $[0,0,1]$。\n    - 面数：$F=4$，邻接关系和所有者进程如下：\n        - 面 $f=0$：相邻单元 $[0]$，所有者进程 $0$。\n        - 面 $f=1$：相邻单元 $[0,1]$，所有者进程 $0$。\n        - 面 $f=2$：相邻单元 $[1]$，所有者进程 $0$。\n        - 面 $f=3$：相邻单元 $[2]$，所有者进程 $1$。\n    - 每面的迹自由度：$m=1$。\n\n6) 最终输出格式。您的程序必须生成一行输出，其中包含一个扁平列表，按 A、B、C 的顺序，每个测试用例的三元组 $[\\Vert S \\Vert_F, M, V]$ 在各用例间串联而成。具体来说，打印单行格式如下：\n\"[$x_A,y_A,z_A,x_B,y_B,z_B,x_C,y_C,z_C$]\"\n其中 $x_{\\bullet}$ 是弗罗贝尼乌斯范数 $\\|S\\|_{F}$（浮点数），$y_{\\bullet}$ 是消息数 $M$（整数），$z_{\\bullet}$ 是双精度浮点数总数 $V$（整数）。\n\n不出现角度，也没有物理单位。所有输出均为纯数。\n\n您的程序必须是自包含的，无需输入，并精确遵循所述的通信和组装规则。您的算法和实现不得假设超出此处定义的结构，不得使用任何外部文件或网络，并且不得依赖执行环境中指定范围之外的库。", "solution": "所提出的问题是为可杂交间断伽辽金 (HDG) 方法的骨架矩阵组装阶段构建并实现一种并行算法。该问题定义明确、科学上合理且内部一致。它为单元级贡献提供了一个抽象而形式化的框架，并为进程间通信规定了清晰的方案，从而可以得出一个严谨的算法解。我们将从第一性原理出发推导该算法，然后进行实现。\n\n有限元组装的基本原理是将一个全局算子加性分解为网格 $\\mathcal{T}_h$ 中每个单元 $K$ 的局部贡献之和。对于 HDG 方法，在对每个单元内部的未知数进行局部静态凝聚之后，我们得到一个关于网格骨架 $\\mathcal{F}_h$ 的面上解的迹相关自由度的系统。全局骨架算子 $S$ 是通过对相邻单元的贡献求和来组装的。也就是说，对于每个面 $f \\in \\mathcal{F}_h$，全局系统中的相应块 $S_f$ 由下式给出：\n$$\nS_{f} = \\sum_{e \\in \\mathcal{N}(f)} S^{(e)}_{ff}\n$$\n其中 $\\mathcal{N}(f)$ 是与面 $f$ 相邻的单元集合，而 $S^{(e)}_{ff}$ 是由单元 $e$ 上的局部求解产生的对该面块 $S_f$ 的贡献。\n\n在带有区域分解的并行环境中，单元集 $\\mathcal{T}_h$ 被划分到 $R$ 个消息传递接口 (MPI) 进程中。令 $r(e)$ 表示拥有单元 $e$ 的进程。当一个面 $f$ 位于不同进程所拥有的单元之间的边界上时，通信就成为必要。问题指出，每个面 $f$ 都有一个唯一的所有者进程 $r_{\\text{own}}(f)$，它负责组装最终的块 $S_f$。\n\n基于这些原则，我们为并行组装推导出以下算法流程。\n\n**步骤 1：局部计算舒尔补贡献**\n\n这第一个阶段是易于并行的（embarrassingly parallel）。每个 MPI 进程 $r \\in \\{0, \\dots, R-1\\}$ 遍历其拥有的所有单元 $e$（即满足 $r(e) = r$ 的单元）。对于每个这样的单元 $e$，该进程识别所有与其相邻的面 $f$。对于每对 $(e,f)$，它计算局部贡献矩阵 $S^{(e)}_{ff} \\in \\mathbb{R}^{m \\times m}$。根据问题陈述，此计算定义为：\n$$\nS^{(e)}_{ff} = \\alpha I_{m} + v v^{\\top}\n$$\n其中 $I_m$ 是 $m \\times m$ 的单位矩阵，$\\alpha = 1.0 + \\big((e + 2f) \\bmod 3\\big)$，并且向量 $v \\in \\mathbb{R}^{m}$ 的分量为 $v_{i} = (e+1) + 0.1(f+1) + 0.01(i+1)$，$i \\in \\{0, \\dots, m-1\\}$。这些局部计算出的矩阵存储在计算它们的进程的内存中。\n\n**步骤 2：通信规划与数据交换**\n\n局部计算完成后，每个进程必须确定其计算出的哪些贡献需要发送给其他进程。\n\n对于每个进程 $r_{\\text{src}} \\in \\{0, \\dots, R-1\\}$：\n1.  初始化一个通信伙伴集合，$\\text{Partners}_{\\text{send}} = \\emptyset$。\n2.  初始化用于缓冲传出消息的数据结构，例如，一个以目标进程为键的字典 `send_buffers`。\n3.  遍历每个本地拥有的单元 $e$（其中 $r(e) = r_{\\text{src}}$）及其每个相邻面 $f$。\n4.  获取该面的所有者进程 $r_{\\text{dst}} = r_{\\text{own}}(f)$。\n5.  如果 $r_{\\text{src}} \\neq r_{\\text{dst}}$，则贡献 $S^{(e)}_{ff}$ 必须进行通信。此贡献被标记为发送到进程 $r_{\\text{dst}}$。将序对 $(r_{\\text{src}}, r_{\\text{dst}})$ 添加到一个全局通信序对集合中，该集合将用于确定总消息数 $M$。要发送的数据大小，即 $m \\times m$ 个浮点数，被加到总通信量 $V$ 中。\n6.  遵循邻居聚合消息规则，从 $r_{\\text{src}}$ 到 $r_{\\text{dst}}$ 的所有贡献被打包到单个消息缓冲区中。问题规定，这些作为矩阵 $S^{(e)}_{ff}$ 的贡献，按全局面标识符 $f$ 的升序排列。\n\n这个规划阶段确定了完整的通信模式。随后，在实际的 MPI 实现中，各进程将执行非阻塞发送和接收（`MPI_Isend`、`MPI_Irecv`），然后进行等待（`MPI_Waitall`）以确保所有数据都已交换。\n\n**步骤 3：在所有者进程上进行全局组装**\n\n每个进程 $r \\in \\{0, \\dots, R-1\\}$ 负责为其拥有的所有面 $f$（即其中 $r_{\\text{own}}(f) = r$）组装最终矩阵 $S_f$。\n\n对于每个进程 $r_{\\text{own}} \\in \\{0, \\dots, R-1\\}$：\n1.  为所有满足 $r_{\\text{own}}(f) = r_{\\text{own}}$ 的面 $f$ 初始化空矩阵 $S_f = 0 \\in \\mathbb{R}^{m \\times m}$。\n2.  处理局部贡献：对于每个由 $r_{\\text{own}}$ 拥有的面 $f$，以及每个同样由 $r_{\\text{own}}$ 拥有的相邻单元 $e$（即 $r(e) = r_{\\text{own}}$），添加本地存储的贡献：$S_f \\leftarrow S_f + S^{(e)}_{ff}$。\n3.  处理远程贡献：对于每个其他进程 $r_{\\text{src}}$，解包接收到的消息缓冲区（如果有）。对于缓冲区中的每个贡献 $S^{(e)}_{ff}$（与一个面标识符 $f$ 相关联），将其添加到相应的矩阵中：$S_f \\leftarrow S_f + S^{(e)}_{ff}$。\n\n此步骤后，每个矩阵 $S_f$ 都已完全组装并驻留在其所有者进程 $r_{\\text{own}}(f)$ 上。\n\n**步骤 4：计算输出量**\n\n最后一步是根据组装好的系统和通信计划计算所需的度量指标。我们的实现将串行模拟此逻辑。\n\n1.  **总通信量 ($V$) 和消息数 ($M$)：** 这些在步骤 2 中确定。\n    -   $V$ 是所有跨越进程边界的矩阵大小之和：$V = \\sum_{r(e) \\neq r_{\\text{own}}(f)} m^2$。\n    -   $M$ 是至少发送一个矩阵的唯一有序序对 $(r_{\\text{src}}, r_{\\text{dst}})$ 的总数。\n\n2.  **弗罗贝尼乌斯范数 ($\\|S\\|_F$)：** 全局矩阵 $S$ 是块对角矩阵，$S = \\operatorname{diag}(S_{0}, S_{1}, \\dots, S_{F-1})$，其中 $F$ 是面的总数。弗罗贝尼乌斯范数定义为 $\\|A\\|_F = \\sqrt{\\sum_{i,j} |a_{ij}|^2}$。对于块对角矩阵，这简化为对角块范数平方和的平方根：\n    $$\n    \\|S\\|_{F} = \\sqrt{\\sum_{f=0}^{F-1} \\|S_f\\|_F^2}\n    $$\n    在并行计算中，每个进程 $r$ 将为其拥有的面计算范数的平方和，即 $\\sum_{f: r_{\\text{own}}(f)=r} \\|S_f\\|_F^2$。将使用一个全局归约操作（带有 `MPI_SUM` 算子的 `MPI_Allreduce`）来计算所有进程的总和。最终结果是该全局总和的平方根。\n\n我们的实现将对每个测试用例执行这些步骤，以产生所需的数值结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to orchestrate the solution for all test cases.\n    It defines test cases, runs the simulation for each, and prints the result.\n    \"\"\"\n\n    # Test Case A\n    case_A = {\n        \"name\": \"A\",\n        \"num_ranks\": 2,\n        \"num_elements\": 3,\n        \"element_ranks\": [0, 0, 1],\n        \"num_faces\": 4,\n        \"face_adjacencies\": [[0], [0, 1], [1, 2], [2]],\n        \"face_owners\": [0, 0, 1, 1],\n        \"m\": 2,\n    }\n\n    # Test Case B\n    case_B = {\n        \"name\": \"B\",\n        \"num_ranks\": 3,\n        \"num_elements\": 4,\n        \"element_ranks\": [0, 1, 1, 2],\n        \"num_faces\": 6,\n        \"face_adjacencies\": [[0], [0, 1], [1], [1, 2], [2, 3], [3]],\n        \"face_owners\": [0, 0, 1, 1, 2, 2],\n        \"m\": 3,\n    }\n\n    # Test Case C\n    case_C = {\n        \"name\": \"C\",\n        \"num_ranks\": 2,\n        \"num_elements\": 3,\n        \"element_ranks\": [0, 0, 1],\n        \"num_faces\": 4,\n        \"face_adjacencies\": [[0], [0, 1], [1], [2]],\n        \"face_owners\": [0, 0, 0, 1],\n        \"m\": 1,\n    }\n\n    test_cases = [case_A, case_B, case_C]\n    final_results = []\n\n    for case in test_cases:\n        norm_S_F, M, V = compute_hdg_assembly(case)\n        final_results.extend([norm_S_F, M, V])\n\n    # Format and print the final output as a single-line list.\n    print(f\"[{','.join(map(str, final_results))}]\")\n\n\ndef compute_hdg_assembly(case):\n    \"\"\"\n    Simulates the HDG skeleton assembly for a single test case.\n    \n    Args:\n        case (dict): A dictionary containing all parameters for the test case.\n        \n    Returns:\n        tuple: A tuple containing (Frobenius norm, number of messages, communication volume).\n    \"\"\"\n\n    # Extract parameters from the case dictionary\n    num_elements = case[\"num_elements\"]\n    num_faces = case[\"num_faces\"]\n    m = case[\"m\"]\n    element_ranks = case[\"element_ranks\"]\n    face_adjacencies = case[\"face_adjacencies\"]\n    face_owners = case[\"face_owners\"]\n\n    # Step 1: Local Computation of Schur Complement Contributions\n    # We store all contributions in a dictionary for easy lookup.\n    # The key is a tuple (element_id, face_id).\n    local_contributions = {}\n    \n    # In a real scenario, each rank computes only its own elements.\n    # Here, we simulate this by iterating through all elements and their faces.\n    for e in range(num_elements):\n        # Find all faces adjacent to element e\n        adjacent_faces = [f for f, adj_elems in enumerate(face_adjacencies) if e in adj_elems]\n        for f in adjacent_faces:\n            # Generate the local contribution matrix S^(e)_(ff)\n            v = np.array([(e + 1) + 0.1 * (f + 1) + 0.01 * (i + 1) for i in range(m)])\n            alpha = 1.0 + ((e + 2 * f) % 3)\n            S_eff = alpha * np.identity(m) + np.outer(v, v)\n            local_contributions[(e, f)] = S_eff\n\n    # Step 2  3: Communication Planning and Global Assembly\n    # We simulate the assembly process on the owner ranks.\n    \n    # Initialize storage for the final assembled face blocks\n    assembled_face_blocks = [np.zeros((m, m)) for _ in range(num_faces)]\n    \n    # Initialize communication metrics\n    comm_volume = 0\n    comm_pairs = set()\n\n    # Iterate through all faces to assemble them\n    for f in range(num_faces):\n        owner_rank = face_owners[f]\n        adjacent_elements = face_adjacencies[f]\n        \n        for e in adjacent_elements:\n            src_rank = element_ranks[e]\n            contribution = local_contributions[(e, f)]\n            \n            # If element rank is not the face owner rank, communication is required\n            if src_rank != owner_rank:\n                comm_volume += m * m\n                comm_pairs.add((src_rank, owner_rank))\n            \n            # The owner rank adds the contribution (whether local or received)\n            assembled_face_blocks[f] += contribution\n            \n    num_messages = len(comm_pairs)\n\n    # Step 4: Computation of Final Quantities\n    \n    # Calculate Frobenius norm of the block-diagonal matrix S\n    sum_sq_norms = 0.0\n    for S_f in assembled_face_blocks:\n        sum_sq_norms += np.linalg.norm(S_f, 'fro')**2\n    \n    norm_S_F = np.sqrt(sum_sq_norms)\n    \n    return norm_S_F, num_messages, comm_volume\n\n# Execute the main function when the script is run.\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2566516"}]}