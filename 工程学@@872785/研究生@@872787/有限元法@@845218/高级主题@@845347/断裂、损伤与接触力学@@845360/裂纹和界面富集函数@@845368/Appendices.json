{"hands_on_practices": [{"introduction": "在扩展有限元方法（XFEM）等界面建模技术中，我们通常使用水平集函数来隐式地表示裂纹或材料界面。当我们在有限元网格上对这个连续的水平集函数进行离散化（例如，使用线性插值）时，我们实际上是用一个分段线性的近似来代替真实的、可能是弯曲的界面，这必然会引入几何误差。这个练习将指导你通过分析推导，量化这种近似所带来的主导误差，并理解它如何与单元尺寸 $h$ 和界面曲率 $\\kappa$ 相关，这是构建精确裂纹模型的关键第一步 [@problem_id:2551518]。", "problem": "考虑一个光滑的材料界面，它被隐式地表示为一个标量场 $\\phi(\\boldsymbol{x})$ 的零水平集，其中 $\\boldsymbol{x} \\in \\mathbb{R}^{2}$，使得 $\\Gamma=\\{\\boldsymbol{x}:\\phi(\\boldsymbol{x})=0\\}$，并且在 $\\Gamma$ 的一个邻域内 $|\\nabla \\phi|\\neq 0$。在一个边长为 $h$ 的方形有限单元内，对单元上的 $\\phi$ 进行标准的分段线性插值，通过连接插值后 $\\phi$ 变号的两个边交点，得到单元内部界面的一个线性（直线）近似。假设在该单元的范围内，精确界面 $\\Gamma$ 可以很好地被一个曲率为常数 $\\kappa$、半径为 $R=1/|\\kappa|$ 的密切圆弧所近似，并且直线重构在单元内部构成一条长度为 $L=h$ 的弦。\n\n从 $\\phi$ 的光滑性和曲率定义所导出的基本几何关系和泰勒展开出发，推导真实界面与其在单元内的直线重构之间的最大法向距离的主阶表达式。将这个主阶最大几何误差 $\\delta_{\\max}$ 表示为 $h$ 和 $\\kappa$ 的函数的闭式形式。\n\n然后，提出一种基于 $\\phi$ 的二次近似的子单元界面重构方法，该方法在单元内界面位置上至少达到二阶精度。使用泰勒定理和 $\\Gamma$ 的隐函数表示，从第一性原理出发，证明您所提方法的精度阶数。\n\n最终答案仅需报告您得到的 $\\delta_{\\max}$ 的闭式解析表达式。无需进行数值取整，也无需物理单位。", "solution": "所提出的问题在偏微分方程数值分析领域，特别是在涉及扩展有限元法（XFEM）或水平集法等界面追踪方法的范畴内，是有效的、有科学依据且适定的。我将提供完整的解答。该问题包括两个部分，我将依次进行阐述。\n\n**第1部分：主阶最大几何误差 $\\delta_{\\max}$ 的推导**\n\n问题指明，真实界面 $\\Gamma$ 在局部被一个曲率为常数 $\\kappa$ 的圆弧所近似，其在有限单元内的分段线性重构是该圆弧的一条弦。圆弧的半径为 $R = 1/|\\kappa|$，弦长给定为 $L=h$，其中 $h$ 是方形单元的边长。\n\n我们的目标是求出圆弧与其弦之间的最大法向距离 $\\delta_{\\max}$。该距离是由圆弧和弦所定义的弓形高。让我们建立一个坐标系，圆心在原点 $(0,0)$。圆的方程为 $x^2 + y^2 = R^2$。我们可以将弦沿垂直方向放置，平行于 $y$ 轴，连接点 $(x_c, -L/2)$ 和 $(x_c, L/2)$。最大距离 $\\delta_{\\max}$ 将位于 $x$ 轴上。\n\n弦的端点位于圆上。将一个端点 $(x_c, L/2)$ 代入圆的方程得到：\n$$ x_c^2 + \\left(\\frac{L}{2}\\right)^2 = R^2 $$\n解出 $x_c$，我们得到 $x_c = \\sqrt{R^2 - \\frac{L^2}{4}}$。最大距离 $\\delta_{\\max}$ 是半径 $R$（圆弧在x轴上的范围）与弦的坐标 $x_c$ 之差。\n$$ \\delta_{\\max} = R - x_c = R - \\sqrt{R^2 - \\frac{L^2}{4}} $$\n在给定假设下，这是最大几何误差的精确表达式。为了找到对于小单元尺寸 $h$（因此 $L$ 也很小）且 $h \\ll R$ 时的主阶表达式，我们进行泰勒展开。我们从平方根项中提出因子 $R$：\n$$ \\delta_{\\max} = R - R\\left(1 - \\frac{L^2}{4R^2}\\right)^{1/2} $$\n我们使用 $(1-z)^{1/2}$ 的二项式级数展开，其中 $z = \\frac{L^2}{4R^2}$ 是一个小量。展开式为：\n$$ (1-z)^{1/2} = 1 - \\frac{1}{2}z - \\frac{1}{8}z^2 - O(z^3) $$\n将此代入 $\\delta_{\\max}$ 的表达式中：\n$$ \\delta_{\\max} = R \\left[ 1 - \\left( 1 - \\frac{1}{2}\\left(\\frac{L^2}{4R^2}\\right) - \\frac{1}{8}\\left(\\frac{L^2}{4R^2}\\right)^2 - \\dots \\right) \\right] $$\n$$ \\delta_{\\max} = R \\left[ \\frac{L^2}{8R^2} + \\frac{L^4}{128R^4} + O\\left(\\left(\\frac{L}{R}\\right)^6\\right) \\right] $$\n$$ \\delta_{\\max} = \\frac{L^2}{8R} + \\frac{L^4}{128R^3} + \\dots $$\n问题要求的是主阶表达式，即当 $L \\to 0$ 时该级数中的第一项也是起主导作用的项。\n$$ \\delta_{\\max} \\approx \\frac{L^2}{8R} $$\n最后，代入给定关系 $L=h$ 和 $R = 1/|\\kappa|$：\n$$ \\delta_{\\max} \\approx \\frac{h^2}{8(1/|\\kappa|)} = \\frac{|\\kappa| h^2}{8} $$\n此结果表明，分段线性界面重构的几何误差相对于单元尺寸 $h$ 是二阶的，即 $O(h^2)$。\n\n**第2部分：高阶界面重构方法的提议**\n\n线性重构产生的几何误差为 $O(h^2)$ 阶。为了达到更高的精度，我们必须对水平集函数 $\\phi(\\boldsymbol{x})$ 使用更高阶的近似。\n\n**提议的方法：** 我提议一种基于水平集函数 $\\phi(\\boldsymbol{x})$ 的**二次插值**的子单元界面重构方法。这需要一个支持二次基函数的有限元公式，例如6节点三角形（$T_2$）或9节点四边形（$Q_2$）。插值后的水平集函数 $\\phi^h_{quad}(\\boldsymbol{x})$ 由下式给出：\n$$ \\phi^h_{quad}(\\boldsymbol{x}) = \\sum_{j} M_j(\\boldsymbol{x}) \\phi(\\boldsymbol{x}_j) $$\n其中 $M_j(\\boldsymbol{x})$ 是二次形函数，求和遍及高阶单元的节点 $\\boldsymbol{x}_j$。近似界面 $\\Gamma^h$ 则是该二次场的零等值线：\n$$ \\Gamma^h = \\{ \\boldsymbol{x} \\in \\Omega_e \\mid \\phi^h_{quad}(\\boldsymbol{x}) = 0 \\} $$\n这将单元内的界面定义为一个圆锥曲线，它可以表示曲率，因此能提供比直线更精确的近似。\n\n**精度证明：** 界面位置的精度可以与函数 $\\phi$ 的插值误差联系起来。设 $\\boldsymbol{x}_\\Gamma$ 是精确界面 $\\Gamma$ 上的一个点（因此 $\\phi(\\boldsymbol{x}_\\Gamma) = 0$），并设 $\\boldsymbol{x}^h_\\Gamma$ 是近似界面 $\\Gamma^h$ 上的对应点。点 $\\boldsymbol{x}^h_\\Gamma$ 与 $\\boldsymbol{x}_\\Gamma$ 相距一个法向距离 $\\delta$，因此 $\\boldsymbol{x}^h_\\Gamma = \\boldsymbol{x}_\\Gamma + \\delta \\boldsymbol{n}$，其中 $\\boldsymbol{n}$ 是 $\\Gamma$ 在 $\\boldsymbol{x}_\\Gamma$ 处的单位法向量。\n\n根据定义，$\\phi^h(\\boldsymbol{x}^h_\\Gamma) = 0$。精确函数在该近似点的值为 $\\phi(\\boldsymbol{x}^h_\\Gamma) = \\phi(\\boldsymbol{x}^h_\\Gamma) - \\phi^h(\\boldsymbol{x}^h_\\Gamma) = E(\\boldsymbol{x}^h_\\Gamma)$，其中 $E$ 是插值误差。\n对 $\\phi$ 在 $\\boldsymbol{x}_\\Gamma$ 处进行一阶泰勒展开，得到：\n$$ \\phi(\\boldsymbol{x}^h_\\Gamma) = \\phi(\\boldsymbol{x}_\\Gamma) + \\nabla \\phi(\\boldsymbol{x}_\\Gamma) \\cdot (\\delta \\boldsymbol{n}) + O(\\delta^2) $$\n因为 $\\phi(\\boldsymbol{x}_\\Gamma) = 0$ 且 $\\boldsymbol{n} = \\nabla\\phi/|\\nabla\\phi|$，上式简化为 $\\phi(\\boldsymbol{x}^h_\\Gamma) \\approx \\delta |\\nabla\\phi(\\boldsymbol{x}_\\Gamma)|$。问题说明 $|\\nabla\\phi| \\neq 0$，因此我们可以将几何误差 $\\delta$ 写为：\n$$ \\delta \\approx \\frac{\\phi(\\boldsymbol{x}^h_\\Gamma)}{|\\nabla\\phi(\\boldsymbol{x}_\\Gamma)|} = \\frac{E(\\boldsymbol{x}^h_\\Gamma)}{|\\nabla\\phi(\\boldsymbol{x}_\\Gamma)|} $$\n这表明几何误差与 $\\phi$ 的插值误差成正比。根据标准逼近理论，对于一个足够光滑的函数，在尺寸为 $h$ 的单元上使用 $p$ 次多项式进行插值，其误差阶为 $O(h^{p+1})$。\n\n对于第1部分中的线性重构，$p=1$，导致插值误差 $E = O(h^2)$ 和几何误差 $\\delta = O(h^2)$，这与我们的推导一致。\n\n对于提议的二次重构，$p=2$。插值误差为 $E = O(h^{p+1}) = O(h^3)$。因此，界面的几何误差为 $\\delta = O(h^3)$。该方法具有三阶精度，从而超过了“至少二阶精度”的要求，并且相比线性方法有显著改进。", "answer": "$$\\boxed{\\frac{|\\kappa| h^{2}}{8}}$$", "id": "2551518"}, {"introduction": "在理解了界面的几何表示及其近似误差之后，下一个实际的挑战是在有限元程序中实现一个算法，以自动识别哪些单元被裂纹所切割。这个练习提供了一个在双线性四边形单元上执行此任务的具体算法，包括如何处理裂纹尖端恰好位于节点或沿单元边界等退化情况。掌握这种稳健的检测技术对于任何成功的XFEM代码实现都是至关重要的 [@problem_id:2551479]。", "problem": "给定一个用于扩展有限元法（XFEM）裂纹和界面富集任务的参考单元，该任务限定于二维双线性四边形有限元。该参考单元具有局部等参坐标 $(\\xi,\\eta)\\in[-1,1]^2$ 和四个局部节点，按左下角开始逆时针排序：节点 $0$ 位于 $(\\xi,\\eta)=(-1,-1)$，节点 $1$ 位于 $(\\xi,\\eta)=(+1,-1)$，节点 $2$ 位于 $(\\xi,\\eta)=(+1,+1)$，节点 $3$ 位于 $(\\xi,\\eta)=(-1,+1)$。在每个节点 $i\\in\\{0,1,2,3\\}$ 上，都有一个标量水平集值 $\\phi_i$，表示到裂纹面的有符号距离：$\\phi_i0$ 表示一侧，$\\phi_i0$ 表示另一侧，$\\phi_i=0$ 表示界面。符号约定是任意的，但必须一致使用。\n\n目标：仅使用节点水平集值和参考单元上的标准双线性插值，您的任务是稳健地检测裂纹是否与单元相交，并构建裂纹两侧的高斯积分点列表。\n\n需遵循的原则：\n- 插值：在单元内部，水平集场 $\\phi(\\xi,\\eta)$ 是使用标准双线性四边形形函数从 $\\{\\phi_i\\}$ 插值得到的。\n- 裂纹相交检测必须对退化情况具有稳健性，包括节点值在零附近的一个小容差 $\\tau$ 内，以及裂纹尖端与节点重合或沿某条边延伸的情况。使用容差 $\\tau=10^{-8}$。\n- 对于数值积分，使用张量积高斯法则，在 $(\\xi,\\eta)=\\left(\\pm 1/\\sqrt{3},\\pm 1/\\sqrt{3}\\right)$ 处取 $2\\times 2$ 个点，权重为单位权重。按 $(-1/\\sqrt{3},-1/\\sqrt{3})$、$(+1/\\sqrt{3},-1/\\sqrt{3})$、$(+1/\\sqrt{3},+1/\\sqrt{3})$、$(-1/\\sqrt{3},+1/\\sqrt{3})$ 的顺序将高斯点索引为 $0,1,2,3$。\n- 分类：如果 $\\phi(\\xi,\\eta)\\tau$，则高斯点属于正侧；如果 $\\phi(\\xi,\\eta)-\\tau$，则属于负侧；如果 $|\\phi(\\xi,\\eta)|\\le \\tau$，则认为其位于界面上（在此任务中，界面点应从两侧的列表中排除）。\n\n需实现的稳健裂纹相交判定规则：\n- 令 $\\operatorname{sgn}_\\tau(\\phi_i)$ 为：若 $\\phi_i\\tau$ 则为 $+1$，若 $\\phi_i-\\tau$ 则为 $-1$，否则为 $0$。\n- 如果满足以下任一条件，则声明该单元为“切割”单元：\n  - 在 $\\{\\operatorname{sgn}_\\tau(\\phi_i)\\}_{i=0}^3$ 中同时出现 $+1$ 和 $-1$ 符号，或\n  - 在 $\\{(0\\!-\\!1),(1\\!-\\!2),(2\\!-\\!3),(3\\!-\\!0)\\}$ 这几条不同的单元边中，至少有 $2$ 条边出现界面事件，其中边 $(i\\!-\\!j)$ 上的“界面事件”定义为 $\\operatorname{sgn}_\\tau(\\phi_i)\\cdot \\operatorname{sgn}_\\tau(\\phi_j)0$ 或 $\\operatorname{sgn}_\\tau(\\phi_i),\\operatorname{sgn}_\\tau(\\phi_j)$ 中恰好有一个为 $0$。\n此规则必须将顶点处的裂纹尖端以及穿过节点或沿边延伸的界面视为“切割”情况。\n\n输出构建：\n- 对每个单元，根据上述分类规则，构建两个高斯点索引列表：位于正侧的索引列表和位于负侧的索引列表。对应于界面点（即在高斯点处 $|\\phi|\\le \\tau$）的索引应从两个列表中排除。\n- 此外，输出单元是否被切割，用整数 $1$（切割）或 $0$（未切割）表示。\n\n测试套件：\n为以下 $4$ 个单元实现您的程序，每个单元由其节点水平集数组 $[\\phi_0,\\phi_1,\\phi_2,\\phi_3]$ 指定：\n- 情况 $1$（对角线穿越）：$[-1.0,\\,1.0,\\,1.0,\\,-1.0]$。\n- 情况 $2$（无切割）：$[2.0,\\,3.0,\\,2.5,\\,2.2]$。\n- 情况 $3$（裂纹尖端在顶点）：$[0.0,\\,1.0,\\,1.0,\\,-1.0]$。\n- 情况 $4$（掠过但切割）：$[-0.2,\\,-0.1,\\,0.1,\\,0.2]$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个长度为 $4$ 的列表，第 $k$ 个条目对应于情况 $k$，其本身是一个形式为 $[c, P, N]$ 的列表，其中 $c\\in\\{0,1\\}$ 是切割标志，$P$ 是正侧高斯点索引列表，$N$ 是负侧高斯点索引列表。\n- 输出必须严格以逗号分隔的列表形式打印，并用方括号括起来，其中不能有任何空格。例如：\"[[1,[0,2],[1,3]],[0,[0,1,2,3],[]],...]\"。", "solution": "问题陈述具有科学依据，提法恰当且客观。它为检测双线性四边形有限元内的裂纹相交以及根据裂纹对高斯积分点进行分类提供了一套完整且一致的规则。其中引用的原理——水平集表示法、使用双线性形函数的等参映射以及高斯积分法——是扩展有限元法（XFEM）的基础。因此，我将直接进行求解方案的构建。\n\n问题的核心是在参考单元域 $(\\xi, \\eta) \\in [-1, 1]^2$ 内评估标量水平集场 $\\phi(\\xi, \\eta)$。该场是利用标准双线性形函数 $N_i(\\xi, \\eta)$ 从给定的节点值 $\\{\\phi_0, \\phi_1, \\phi_2, \\phi_3\\}$ 插值得到的：\n$$\n\\phi(\\xi, \\eta) = \\sum_{i=0}^{3} N_i(\\xi, \\eta) \\phi_i\n$$\n四个形函数对应于从角点 $(\\xi, \\eta) = (-1, -1)$ 开始逆时针排序的节点 $0, 1, 2, 3$：\n\\begin{itemize}\n    \\item $N_0(\\xi, \\eta) = \\frac{1}{4}(1-\\xi)(1-\\eta)$\n    \\item $N_1(\\xi, \\eta) = \\frac{1}{4}(1+\\xi)(1-\\eta)$\n    \\item $N_2(\\xi, \\eta) = \\frac{1}{4}(1+\\xi)(1+\\eta)$\n    \\item $N_3(\\xi, \\eta) = \\frac{1}{4}(1-\\xi)(1+\\eta)$\n\\end{itemize}\n\n对于每个以节点值数组 $[\\phi_0, \\phi_1, \\phi_2, \\phi_3]$ 给出的测试用例，其处理过程分为两个主要阶段：裂纹相交检测和高斯点分类。\n\n**1. 裂纹相交检测**\n\n此阶段确定单元是否被由 $\\phi(\\xi, \\eta)=0$ 定义的裂纹界面“切割”。问题指定了一个稳健的决策规则，该规则能处理诸如裂纹尖端位于节点或沿边等退化情况。设零容差为 $\\tau = 10^{-8}$。\n\n首先，我们为节点值 $\\phi_i$ 定义一个带阈值的符号函数：\n$$\n\\operatorname{sgn}_\\tau(\\phi_i) = \\begin{cases} +1  \\text{ if } \\phi_i  \\tau \\\\ -1  \\text{ if } \\phi_i  -\\tau \\\\ 0  \\text{ if } |\\phi_i| \\le \\tau \\end{cases}\n$$\n如果满足以下两个条件中至少一个，则单元被声明为“切割”单元（输出标志 $c=1$）：\n\na) 节点符号集合 $\\{\\operatorname{sgn}_\\tau(\\phi_i)\\}_{i=0}^3$ 中同时包含 $+1$ 和 $-1$。这是裂纹清晰地将单元节点分开的标准情况。\n\nb) 单元的至少两条不同边出现“界面事件”。这些边是 $(0-1)$、$(1-2)$、$(2-3)$ 和 $(3-0)$。边 $(i-j)$ 上出现界面事件的条件是 $\\operatorname{sgn}_\\tau(\\phi_i) \\cdot \\operatorname{sgn}_\\tau(\\phi_j)  0$（符号改变）或 $\\operatorname{sgn}_\\tau(\\phi_i)$ 与 $\\operatorname{sgn}_\\tau(\\phi_j)$ 中恰好有一个为零。第二个条件能够稳健地检测到位于节点上的裂纹尖端，否则条件（a）会漏掉这种情况。\n\n如果两个条件都不满足，则单元未被切割（$c=0$）。\n\n**2. 高斯点分类**\n\n此阶段根据标准 $2 \\times 2$ 高斯积分点相对于裂纹的位置对其进行划分。四个高斯点按局部坐标索引为 $0, 1, 2, 3$，其中 $\\gamma = 1/\\sqrt{3}$：\n\\begin{itemize}\n    \\item 点 $0$：$(\\xi_0, \\eta_0) = (-\\gamma, -\\gamma)$\n    \\item 点 $1$：$(\\xi_1, \\eta_1) = (+\\gamma, -\\gamma)$\n    \\item 点 $2$：$(\\xi_2, \\eta_2) = (+\\gamma, +\\gamma)$\n    \\item 点 $3$：$(\\xi_3, \\eta_3) = (-\\gamma, +\\gamma)$\n\\end{itemize}\n\n对于每个高斯点 $k \\in \\{0, 1, 2, 3\\}$，通过双线性插值公式计算水平集值 $\\phi_k = \\phi(\\xi_k, \\eta_k)$。然后根据以下分类规则将该点的索引添加到一个列表 $P$（正侧）或 $N$（负侧）中：\n\\begin{itemize}\n    \\item 如果 $\\phi_k  \\tau$，则将索引 $k$ 添加到列表 $P$。\n    \\item 如果 $\\phi_k  -\\tau$，则将索引 $k$ 添加到列表 $N$。\n    \\item 如果 $|\\phi_k| \\le \\tau$，则该点位于界面上，并从两个列表中排除。\n\\end{itemize}\n\n每个测试用例的最终输出是一个列表，包含切割标志 $c$、正侧高斯点索引列表 $P$ 和负侧高斯点索引列表 $N$。以下程序实现了这一逻辑。", "answer": "```python\nimport numpy as np\n\ndef format_list_no_spaces(data):\n    \"\"\"\n    Recursively formats a list into a string representation without spaces.\n    This is required to match the exact output format string.\n    \"\"\"\n    if isinstance(data, list):\n        return f\"[{','.join(format_list_no_spaces(item) for item in data)}]\"\n    else:\n        return str(data)\n\ndef solve():\n    \"\"\"\n    Solves the XFEM enrichment problem for the given test cases.\n    \"\"\"\n    # Test cases defined as lists of nodal level set values [phi_0, phi_1, phi_2, phi_3]\n    test_cases = [\n        [-1.0, 1.0, 1.0, -1.0],   # Case 1: diagonal crossing\n        [2.0, 3.0, 2.5, 2.2],     # Case 2: no cut\n        [0.0, 1.0, 1.0, -1.0],    # Case 3: crack tip at a vertex\n        [-0.2, -0.1, 0.1, 0.2]    # Case 4: grazing but cutting\n    ]\n\n    # Tolerance for zero-checks\n    tau = 1.0e-8\n\n    # Gauss point coordinates for a 2x2 rule\n    gamma = 1.0 / np.sqrt(3.0)\n    gp_coords = [\n        (-gamma, -gamma),  # GP 0\n        (gamma, -gamma),   # GP 1\n        (gamma, gamma),    # GP 2\n        (-gamma, gamma)    # GP 3\n    ]\n    \n    # Bilinear shape functions, evaluated at (xi, eta)\n    def shape_functions(xi, eta):\n        return np.array([\n            0.25 * (1.0 - xi) * (1.0 - eta),  # N0\n            0.25 * (1.0 + xi) * (1.0 - eta),  # N1\n            0.25 * (1.0 + xi) * (1.0 + eta),  # N2\n            0.25 * (1.0 - xi) * (1.0 + eta)   # N3\n        ])\n\n    # Filtered sign function\n    def sgn_tau(x, tol):\n        if x > tol:\n            return 1\n        elif x  -tol:\n            return -1\n        else:\n            return 0\n\n    results = []\n    for phi_nodes in test_cases:\n        phi_nodes = np.array(phi_nodes)\n        \n        # --- 1. Crack Intersection Detection ---\n        is_cut = 0\n        phi_signs = [sgn_tau(p, tau) for p in phi_nodes]\n        \n        # Condition (a): Mixed signs at nodes\n        if 1 in phi_signs and -1 in phi_signs:\n            is_cut = 1\n        else:\n            # Condition (b): At least 2 interface events on edges\n            edges = [(0, 1), (1, 2), (2, 3), (3, 0)]\n            interface_event_count = 0\n            for i, j in edges:\n                s_i, s_j = phi_signs[i], phi_signs[j]\n                # Event: sign change or exactly one node on interface\n                if (s_i * s_j  0) or ((s_i == 0) != (s_j == 0)):\n                    interface_event_count += 1\n            \n            if interface_event_count >= 2:\n                is_cut = 1\n\n        # --- 2. Gauss Point Classification ---\n        P, N = [], []\n        for k in range(len(gp_coords)):\n            xi, eta = gp_coords[k]\n            # Interpolate level set value at Gauss point\n            N_vals = shape_functions(xi, eta)\n            phi_gp = np.dot(N_vals, phi_nodes)\n            \n            # Classify the point\n            if phi_gp > tau:\n                P.append(k)\n            elif phi_gp  -tau:\n                N.append(k)\n        \n        results.append([is_cut, P, N])\n\n    # --- 3. Format and Print Output ---\n    formatted_results = [format_list_no_spaces(r) for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2551479"}, {"introduction": "真实的断裂力学问题往往涉及裂纹的扩展。本练习旨在解决一个更高级的挑战：当裂纹在模拟中从一个增量步扩展到下一个增量步时，如何动态更新富集节点的集合。这里的核心目标是通过在不同步骤之间映射自由度来保持解的连续性，这是实现稳定且准确的准静态或动态裂纹扩展模拟的一项关键技术 [@problem_id:2551517]。", "problem": "给定一个带有裂纹富集函数的二维标量单位分解有限元近似。离散场为\n$$\nu(\\mathbf{x}) \\approx \\sum_{I \\in \\mathcal{N}} N_I(\\mathbf{x})\\, d_I \\;+\\; \\sum_{I \\in \\mathcal{E}_H} N_I(\\mathbf{x})\\, H(\\mathbf{x})\\, a_I \\;+\\; \\sum_{I \\in \\mathcal{E}_B} N_I(\\mathbf{x})\\, B(\\mathbf{x})\\, b_I,\n$$\n其中 $N_I(\\mathbf{x})$ 是节点拉格朗日形函数，具有克罗内克-德尔塔性质 $N_I(\\mathbf{x}_J) = \\delta_{IJ}$，$\\mathcal{N}$ 是所有节点的集合，$\\mathcal{E}_H$ 是亥维赛富集节点的集合，$\\mathcal{E}_B$ 是分支富集节点的集合。亥维赛富集 $H(\\mathbf{x})$ 定义为到裂纹线的符号距离函数 $\\phi(\\mathbf{x})$ 的符号，分支富集 $B(\\mathbf{x})$ 是一个近尖端标量函数 $B(\\mathbf{x}) = \\sqrt{r(\\mathbf{x})}$，其中 $r(\\mathbf{x})$ 是从 $\\mathbf{x}$ 到裂纹尖端的欧几里得距离。离散未知数向量为：$d_I$ 代表标准自由度，$a_I$ 代表亥维赛富集自由度，$b_I$ 代表分支富集自由度。我们考虑一个标量场（例如，反平面位移），因此所有自由度都是标量。\n\n变分形式是标准的 Galerkin 方法：给定一个从线性椭圆偏微分方程和适当边界条件导出的双线性形式 $a(\\cdot,\\cdot)$ 和一个线性泛函 $\\ell(\\cdot)$，求解 $u \\in \\mathcal{V}_h$ 使得对于所有 $v \\in \\mathcal{V}_h$ 都有 $a(u,v) = \\ell(v)$，其中 $\\mathcal{V}_h$ 是由上述函数张成的离散单位分解富集试验空间。\n\n在每个扩展步 $s$ 中，裂纹由一个端点为 $\\mathbf{c}_1^{(s)}$ 和 $\\mathbf{c}_2^{(s)}$ 的直线段表示，其尖端位于 $\\mathbf{t}^{(s)} = \\mathbf{c}_2^{(s)}$。在两个连续的步骤 $s$ 和 $s+1$ 之间，裂纹扩展，富集节点集从 $(\\mathcal{E}_H^{(s)}, \\mathcal{E}_B^{(s)})$ 变为 $(\\mathcal{E}_H^{(s+1)}, \\mathcal{E}_B^{(s+1)})$。亥维赛函数 $H(\\mathbf{x})$ 使用到通过 $(\\mathbf{c}_1^{(s)},\\mathbf{c}_2^{(s)})$ 的无限直线的符号距离，并带有一个判平项 $\\varepsilon$ 以避免节点恰好在线上时值为零。具体来说，对于一个点 $\\mathbf{x}$，\n$$\n\\phi^{(s)}(\\mathbf{x}) = \\mathbf{n}^{(s)} \\cdot (\\mathbf{x} - \\mathbf{c}_1^{(s)}) + \\varepsilon\\,\\mathbf{w}\\cdot \\mathbf{x}, \\quad H^{(s)}(\\mathbf{x}) = \\mathrm{sign}(\\phi^{(s)}(\\mathbf{x})),\n$$\n其中 $\\mathbf{d}^{(s)} = \\mathbf{c}_2^{(s)}-\\mathbf{c}_1^{(s)}$，$\\mathbf{n}^{(s)} = (-d_y^{(s)}, d_x^{(s)})$ 是直线法线的一个固定方向，$\\mathbf{w}$ 是一个固定的非零向量（使用 $\\mathbf{w} = (1,2)$）。分支富集为 $B^{(s)}(\\mathbf{x}) = \\sqrt{\\|\\mathbf{x}-\\mathbf{t}^{(s)}\\|_2}$。\n\n在节点配置点 $\\mathbf{x}_J$ 处，场的计算值为\n$$\nu(\\mathbf{x}_J) = d_J \\;+\\; \\mathbb{1}_{\\{J \\in \\mathcal{E}_H\\}}\\,H(\\mathbf{x}_J)\\,a_J \\;+\\; \\mathbb{1}_{\\{J \\in \\mathcal{E}_B\\}}\\,B(\\mathbf{x}_J)\\,b_J,\n$$\n因为 $N_I(\\mathbf{x}_J) = \\delta_{IJ}$。定义一个从堆叠的自由度向量到节点值的每步线性映射\n$$\n\\mathbf{v}^{(s)} = \\mathbf{A}^{(s)} \\mathbf{d}^{(s)}, \\quad \\mathbf{v}^{(s)} \\in \\mathbb{R}^{N_n},\n$$\n其中 $N_n$ 是节点数，$\\mathbf{d}^{(s)}$ 首先堆叠所有标准自由度 $d_I$，然后是所有 $I \\in \\mathcal{E}_H^{(s)}$ 的亥维赛富集自由度 $a_I$，最后是所有 $I \\in \\mathcal{E}_B^{(s)}$ 的分支富集自由度 $b_I$。\n\n目标。当富集支持从步骤 $s$ 更新到 $s+1$ 时，设计并实现一个算法来构建一个延拓算子 $\\mathbf{P}^{(s\\to s+1)}$，使得对于任何旧的自由度 $\\mathbf{d}^{(s)}$，新的自由度\n$$\n\\mathbf{d}^{(s+1)} = \\mathbf{P}^{(s\\to s+1)} \\mathbf{d}^{(s)}\n$$\n能产生保留的节点值，\n$$\n\\mathbf{A}^{(s+1)} \\mathbf{d}^{(s+1)} = \\mathbf{A}^{(s)} \\mathbf{d}^{(s)},\n$$\n当该方程有解时。否则，在最小二乘意义下最小化差值的欧几里得范数。更新还必须支持随着裂纹的增长添加新的富集自由度和移除过时的自由度，同时在节点处保持解在步骤间的连续性。使用 Moore–Penrose 伪逆来定义\n$$\n\\mathbf{P}^{(s\\to s+1)} := \\left(\\mathbf{A}^{(s+1)}\\right)^+ \\mathbf{A}^{(s)}.\n$$\n\n网格和富集选择。在单位正方形域 $[0,1]\\times[0,1]$ 上使用一个均匀的结构化四边形网格，包含 $2\\times 2$ 个单元和 $3\\times 3$ 个节点。如果裂纹段与单元矩形相交（在矩形内有非零长度的交集），则该单元被标记为被裂纹切割。亥维赛富集节点 $\\mathcal{E}_H^{(s)}$ 是属于任何被切割单元的所有节点。分支富集节点 $\\mathcal{E}_B^{(s)}$ 是所有到裂纹尖端的距离严格小于给定半径 $R_{\\mathrm{tip}}^{(s)}$ 的节点。通过在每个节点 $\\mathbf{x}_J$ 处计算系数来构建 $\\mathbf{A}^{(s)}$：\n- 标准自由度 $d_J$ 对应的列为 $1$，\n- 如果 $J \\in \\mathcal{E}_H^{(s)}$，则 $a_J$ 对应的列为 $H^{(s)}(\\mathbf{x}_J) \\in \\{-1,1\\}$，\n- 如果 $J \\in \\mathcal{E}_B^{(s)}$，则 $b_J$ 对应的列为 $B^{(s)}(\\mathbf{x}_J) = \\sqrt{\\|\\mathbf{x}_J - \\mathbf{t}^{(s)}\\|_2}$。\n\n测试向量。为进行测试，通过以下方式定义一个确定性的旧自由度向量 $\\mathbf{d}^{(s)}$\n$$\nd_J = \\sin(\\pi x_J)\\cos(\\pi y_J), \\quad a_J = 0.1\\,(x_J+y_J), \\quad b_J = 0.05\\,(x_J - y_J),\n$$\n适用于相关集合中的所有节点 $J$，其中 $(x_J,y_J)$ 是节点坐标。条目 $a_J$ 和 $b_J$ 仅分别包含在 $\\mathcal{E}_H^{(s)}$ 和 $\\mathcal{E}_B^{(s)}$ 中的节点。\n\n要实现的任务。\n- 构建网格和节点坐标。\n- 对于每个步骤 $s$ 和 $s+1$，给定裂纹端点和尖端，构建 $\\mathcal{E}_H^{(s)}$、$\\mathcal{E}_B^{(s)}$ 以及相应的矩阵 $\\mathbf{A}^{(s)}$ 和 $\\mathbf{A}^{(s+1)}$。\n- 计算延拓算子 $\\mathbf{P}^{(s\\to s+1)}$ 并应用它将 $\\mathbf{d}^{(s)}$ 映射到 $\\mathbf{d}^{(s+1)}$。\n- 评估最大绝对偏差\n$$\n\\delta_{\\max} = \\max_J \\left| \\left(\\mathbf{A}^{(s+1)} \\mathbf{d}^{(s+1)}\\right)_J - \\left(\\mathbf{A}^{(s)} \\mathbf{d}^{(s)}\\right)_J \\right|.\n$$\n- 统计在更新过程中添加和移除了多少个富集自由度：\n$$\nN_{\\mathrm{add}} = \\left|\\mathcal{E}_H^{(s+1)} \\setminus \\mathcal{E}_H^{(s)}\\right| + \\left|\\mathcal{E}_B^{(s+1)} \\setminus \\mathcal{E}_B^{(s)}\\right|, \\quad\nN_{\\mathrm{rem}} = \\left|\\mathcal{E}_H^{(s)} \\setminus \\mathcal{E}_H^{(s+1)}\\right| + \\left|\\mathcal{E}_B^{(s)} \\setminus \\mathcal{E}_B^{(s+1)}\\right|.\n$$\n\n角度单位。所有三角函数均使用弧度。\n\n不需要物理单位；所有量均为无量纲。\n\n测试套件。为以下三种情况实现上述内容，每种情况都定义了步骤 $s$ 和 $s+1$ 的裂纹数据和尖端半径。所有情况都使用相同的网格。\n- 情况 1：\n  - 步骤 $s$：$\\mathbf{c}_1^{(s)} = (0.2,0.5)$，$\\mathbf{c}_2^{(s)} = (0.5,0.5)$，$\\mathbf{t}^{(s)} = (0.5,0.5)$，$R_{\\mathrm{tip}}^{(s)} = 0.3$。\n  - 步骤 $s+1$：$\\mathbf{c}_1^{(s+1)} = (0.2,0.5)$，$\\mathbf{c}_2^{(s+1)} = (0.8,0.5)$，$\\mathbf{t}^{(s+1)} = (0.8,0.5)$，$R_{\\mathrm{tip}}^{(s+1)} = 0.3$。\n- 情况 2：\n  - 步骤 $s$：$\\mathbf{c}_1^{(s)} = (0.2,0.2)$，$\\mathbf{c}_2^{(s)} = (0.5,0.5)$，$\\mathbf{t}^{(s)} = (0.5,0.5)$，$R_{\\mathrm{tip}}^{(s)} = 0.25$。\n  - 步骤 $s+1$：$\\mathbf{c}_1^{(s+1)} = (0.2,0.2)$，$\\mathbf{c}_2^{(s+1)} = (0.8,0.5)$，$\\mathbf{t}^{(s+1)} = (0.8,0.5)$，$R_{\\mathrm{tip}}^{(s+1)} = 0.25$。\n- 情况 3（节点位于裂纹线上的边界情况）：\n  - 步骤 $s$：$\\mathbf{c}_1^{(s)} = (0.0,0.5)$，$\\mathbf{c}_2^{(s)} = (0.5,0.5)$，$\\mathbf{t}^{(s)} = (0.5,0.5)$，$R_{\\mathrm{tip}}^{(s)} = 0.2$。\n  - 步骤 $s+1$：$\\mathbf{c}_1^{(s+1)} = (0.0,0.5)$，$\\mathbf{c}_2^{(s+1)} = (0.9,0.5)$，$\\mathbf{t}^{(s+1)} = (0.9,0.5)$，$R_{\\mathrm{tip}}^{(s+1)} = 0.2$。\n\n在所有情况中均使用 $\\varepsilon = 10^{-8}$ 和 $\\mathbf{w} = (1,2)$。\n\n要求的最终输出格式。您的程序应产生单行输出，包含一个类似 JSON 的列表的列表\n$$\n\\big[ [\\delta_{\\max}^{(1)}, N_{\\mathrm{add}}^{(1)}, N_{\\mathrm{rem}}^{(1)}], [\\delta_{\\max}^{(2)}, N_{\\mathrm{add}}^{(2)}, N_{\\mathrm{rem}}^{(2)}], [\\delta_{\\max}^{(3)}, N_{\\mathrm{add}}^{(3)}, N_{\\mathrm{rem}}^{(3)}] \\big],\n$$\n不含空格，其中上标表示情况编号。每个 $\\delta_{\\max}^{(i)}$ 必须是浮点数，每个 $N_{\\mathrm{add}}^{(i)}$ 和 $N_{\\mathrm{rem}}^{(i)}$ 必须是整数。程序不得读取任何输入，且必须按原样运行。对于延拓算子，必须使用 Moore–Penrose 伪逆。", "solution": "所提出的问题是计算力学领域中一个适定且科学上合理的练习，特别是在用于断裂分析的扩展有限元法（XFEM）的背景下。它要求实现一个程序，在准静态裂纹扩展模拟的两个连续步骤之间传递解数据。这种传递，或称为延拓，对于保持解的连续性并为下一个非线性求解提供一个好的初始猜测至关重要。该问题是有效的，并提供了所有必要的数据和定义。\n\n任务的核心是构建一个延拓算子 $\\mathbf{P}^{(s\\to s+1)}$，它将自由度向量 $\\mathbf{d}^{(s)}$ 从步骤 $s$ 映射到步骤 $s+1$ 的 $\\mathbf{d}^{(s+1)}$。该算子必须确保在网格节点上评估的物理场尽可能地被保留。场的保留表示为最小化节点值向量 $\\mathbf{v}^{(s+1)}$ 和 $\\mathbf{v}^{(s)}$ 之间差值的欧几里得范数。节点值向量由线性映射 $\\mathbf{v}^{(s)} = \\mathbf{A}^{(s)} \\mathbf{d}^{(s)}$ 和 $\\mathbf{v}^{(s+1)} = \\mathbf{A}^{(s+1)} \\mathbf{d}^{(s+1)}$ 定义。目标是找到 $\\mathbf{d}^{(s+1)} = \\mathbf{P}^{(s\\to s+1)} \\mathbf{d}^{(s)}$，使得 $\\mathbf{A}^{(s+1)} \\mathbf{d}^{(s+1)} \\approx \\mathbf{A}^{(s)} \\mathbf{d}^{(s)}$。\n\n对于未知向量 $\\mathbf{x} = \\mathbf{d}^{(s+1)}$，方程 $\\mathbf{A}^{(s+1)} \\mathbf{x} = \\mathbf{A}^{(s)} \\mathbf{d}^{(s)}$ 的最小二乘解由 $\\mathbf{d}^{(s+1)} = (\\mathbf{A}^{(s+1)})^{+} (\\mathbf{A}^{(s)} \\mathbf{d}^{(s)})$ 给出，其中 $(\\mathbf{A}^{(s+1)})^{+}$ 是 $\\mathbf{A}^{(s+1)}$ 的 Moore-Penrose 伪逆。由此，延拓算子被确定为 $\\mathbf{P}^{(s\\to s+1)} = (\\mathbf{A}^{(s+1)})^{+} \\mathbf{A}^{(s)}$。\n\n每个测试用例的逐步过程如下：\n\n1.  **网格生成**：在单位正方形 $[0,1] \\times [0,1]$ 上创建一个均匀的 $2 \\times 2$ 四边形网格。这将产生 $3 \\times 3 = 9$ 个节点。建立坐标和单元-节点连接关系。\n\n2.  **状态处理（针对步骤 $s$ 和 $s+1$）**：对于每个步骤，给定裂纹几何形状（$\\mathbf{c}_1, \\mathbf{c}_2$）和富集参数，我们执行以下操作：\n    *   **富集集识别**：\n        *   通过识别所有被裂纹段“切割”的单元来确定亥维赛富集节点集 $\\mathcal{E}_H$。如果裂纹段与其内部相交，则认为该单元被切割，这通过使用一个稳健的线段-矩形相交算法来确定。被切割单元的所有节点都添加到 $\\mathcal{E}_H$ 中。\n        *   通过找到所有到裂纹尖端 $\\mathbf{t}$ 的欧几里得距离严格小于给定半径 $R_{\\mathrm{tip}}$ 的节点来确定分支富集节点集 $\\mathcal{E}_B$。\n    *   **矩阵 $\\mathbf{A}$ 的构建**：矩阵 $\\mathbf{A}$ 将全局自由度向量映射到节点场值向量。其结构源自节点评估公式：\n        $$u(\\mathbf{x}_J) = d_J \\;+\\; \\mathbb{1}_{\\{J \\in \\mathcal{E}_H\\}}\\,H(\\mathbf{x}_J)\\,a_J \\;+\\; \\mathbb{1}_{\\{J \\in \\mathcal{E}_B\\}}\\,B(\\mathbf{x}_J)\\,b_J$$\n        这意味着对于给定的节点 $J$，其场值 $u(\\mathbf{x}_J)$ 仅取决于与该节点关联的自由度 $d_J, a_J, b_J$。尺寸为 $N_n \\times (N_n + |\\mathcal{E}_H| + |\\mathcal{E}_B|)$ 的矩阵 $\\mathbf{A}$ 构建如下：\n        - 前 $N_n$ 列，对应于标准自由度 $d_J$，构成一个单位矩阵。\n        - 对于每个节点 $J \\in \\mathcal{E}_H$，为自由度 $a_J$ 添加一列。该列除第 $J$ 行外全为零，第 $J$ 行包含亥维赛函数 $H(\\mathbf{x}_J)$ 的值。函数 $H(\\mathbf{x}_J) = \\mathrm{sign}(\\phi(\\mathbf{x}_J))$，其中 $\\phi$ 是到裂纹线的符号距离，并带有一个小的扰动以防止零值。\n        - 类似地，对于每个节点 $J \\in \\mathcal{E}_B$，为自由度 $b_J$ 添加一列。该列除第 $J$ 行外全为零，第 $J$ 行包含分支函数 $B(\\mathbf{x}_J) = \\sqrt{r(\\mathbf{x}_J)}$ 的值。\n\n3.  **测试向量构建**：对于步骤 $s$，构建自由度测试向量 $\\mathbf{d}^{(s)}$。其分量根据提供的公式填充：$d_J = \\sin(\\pi x_J)\\cos(\\pi y_J)$，对于 $J \\in \\mathcal{E}_H^{(s)}$，$a_J = 0.1(x_J+y_J)$，对于 $J \\in \\mathcal{E}_B^{(s)}$，$b_J = 0.05(x_J - y_J)$。\n\n4.  **延拓与评估**：\n    *   计算延拓算子：$\\mathbf{P}^{(s\\to s+1)} = (\\mathbf{A}^{(s+1)})^{+} \\mathbf{A}^{(s)}$，使用 Moore-Penrose 伪逆。\n    *   旧的自由度被映射到新的配置：$\\mathbf{d}^{(s+1)} = \\mathbf{P}^{(s\\to s+1)} \\mathbf{d}^{(s)}$。\n    *   计算更新前后的节点值向量：$\\mathbf{v}^{(s)} = \\mathbf{A}^{(s)} \\mathbf{d}^{(s)}$ 和 $\\mathbf{v}^{(s+1)} = \\mathbf{A}^{(s+1)} \\mathbf{d}^{(s+1)}$。\n    *   计算节点值的最大绝对偏差：$\\delta_{\\max} = \\max_J \\left| (\\mathbf{v}^{(s+1)})_J - (\\mathbf{v}^{(s)})_J \\right|$。根据构造，该值代表投影的最小二乘误差，预计会很小。\n    *   通过在两个步骤之间使用集合运算比较富集集 $\\mathcal{E}_H$ 和 $\\mathcal{E}_B$，来统计添加的（$N_{\\mathrm{add}}$）和移除的（$N_{\\mathrm{rem}}$）富集自由度的数量。\n\n对提供的三个测试用例中的每一个都实现了这整个序列。", "answer": "```python\nimport numpy as np\n\nclass CrackUpdateSolver:\n    \"\"\"\n    Solves for the prolongation operator and evaluates its performance for a given crack propagation step.\n    This class handles the entire process for a single test case, from mesh setup to final metric calculation.\n    \"\"\"\n    def __init__(self, case_data, mesh_params, epsilon, w_vec):\n        \"\"\"\n        Initializes the solver with test case data and global parameters.\n        \n        Args:\n            case_data (dict): Contains crack geometry and enrichment radii for steps s and s+1.\n            mesh_params (dict): Specifies the number of elements in x and y directions.\n            epsilon (float): Small perturbation parameter for the signed distance function.\n            w_vec (tuple): Perturbation vector for the signed distance function.\n        \"\"\"\n        self.case_data = case_data\n        self.mesh_params = mesh_params\n        self.epsilon = epsilon\n        self.w_vec = np.array(w_vec)\n        self._setup_mesh()\n\n    def _setup_mesh(self):\n        \"\"\"\n        Generates a uniform rectangular mesh with specified node and element counts.\n        \"\"\"\n        nx, ny = self.mesh_params['nx'], self.mesh_params['ny']\n        self.num_nodes = (nx + 1) * (ny + 1)\n        \n        x_coords = np.linspace(0, 1, nx + 1)\n        y_coords = np.linspace(0, 1, ny + 1)\n        \n        # Node coordinates, indexed row-wise\n        self.nodes = np.array([[x, y] for y in y_coords for x in x_coords])\n        \n        # Element definitions, including node indices and bounding boxes\n        self.elements = []\n        for j in range(ny):\n            for i in range(nx):\n                n0 = j * (nx + 1) + i\n                n1 = n0 + 1\n                n3 = (j + 1) * (nx + 1) + i + 1\n                n2 = n3 - 1\n                self.elements.append({\n                    'nodes': [n0, n1, n3, n2],\n                    'bbox': [x_coords[i], x_coords[i+1], y_coords[j], y_coords[j+1]]\n                })\n\n    def _segment_intersects_box(self, p1, p2, bbox):\n        \"\"\"\n        Checks if a line segment intersects an axis-aligned bounding box with non-zero length.\n        This uses a variation of the Liang-Barsky line clipping algorithm.\n        \"\"\"\n        p1_arr, p2_arr = np.array(p1), np.array(p2)\n        d = p2_arr - p1_arr\n        xmin, xmax, ymin, ymax = bbox\n        bounds = np.array([[xmin, xmax], [ymin, ymax]])\n        \n        t_near, t_far = 0.0, 1.0\n\n        for i in range(2):  # For x and y dimensions\n            if np.isclose(d[i], 0):  # Segment is parallel to slab boundaries\n                if p1_arr[i]  bounds[i, 0] or p1_arr[i] > bounds[i, 1]:\n                    return False  # Segment is outside the slab\n            else:\n                t1 = (bounds[i, 0] - p1_arr[i]) / d[i]\n                t2 = (bounds[i, 1] - p1_arr[i]) / d[i]\n\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                \n                t_near = max(t_near, t1)\n                t_far = min(t_far, t2)\n        \n        return t_near  t_far\n\n    def _process_step(self, step_data):\n        \"\"\"\n        Processes a single crack step to determine enrichment sets and construct the matrix A.\n        \"\"\"\n        c1, c2, tip, r_tip = np.array(step_data['c1']), np.array(step_data['c2']), np.array(step_data['t']), step_data['R_tip']\n\n        # Determine Heaviside-enriched nodes\n        E_H = set()\n        for elem in self.elements:\n            if self._segment_intersects_box(c1, c2, elem['bbox']):\n                E_H.update(elem['nodes'])\n        \n        # Determine branch-enriched nodes\n        E_B = set()\n        for i, node_coord in enumerate(self.nodes):\n            dist_to_tip = np.linalg.norm(node_coord - tip)\n            if dist_to_tip  r_tip:\n                E_B.add(i)\n\n        E_H_sorted, E_B_sorted = sorted(list(E_H)), sorted(list(E_B))\n        \n        num_d, num_a, num_b = self.num_nodes, len(E_H_sorted), len(E_B_sorted)\n        total_dofs = num_d + num_a + num_b\n        A = np.zeros((self.num_nodes, total_dofs))\n        A[:, :num_d] = np.identity(num_d)\n        \n        # Add columns for Heaviside DOFs\n        crack_vec = c2 - c1\n        normal = np.array([-crack_vec[1], crack_vec[0]])\n        for i, node_idx in enumerate(E_H_sorted):\n            node_coord = self.nodes[node_idx]\n            phi = normal @ (node_coord - c1) + self.epsilon * (self.w_vec @ node_coord)\n            H_val = np.sign(phi)\n            if np.isclose(H_val, 0): H_val = 1.0  # Robust tie-breaker\n            A[node_idx, num_d + i] = H_val\n            \n        # Add columns for Branch DOFs\n        for i, node_idx in enumerate(E_B_sorted):\n            node_coord = self.nodes[node_idx]\n            B_val = np.sqrt(np.linalg.norm(node_coord - tip))\n            A[node_idx, num_d + num_a + i] = B_val\n\n        return A, E_H, E_B\n\n    def run(self):\n        \"\"\"\n        Executes the full analysis for the test case.\n        \"\"\"\n        # Process step s\n        A_s, E_H_s, E_B_s = self._process_step(self.case_data['s'])\n\n        # Build test DOF vector for step s\n        E_H_s_sorted, E_B_s_sorted = sorted(list(E_H_s)), sorted(list(E_B_s))\n        num_d_s, num_a_s, num_b_s = self.num_nodes, len(E_H_s_sorted), len(E_B_s_sorted)\n        d_vec_s = np.zeros(num_d_s + num_a_s + num_b_s)\n        \n        for i in range(self.num_nodes):\n            x, y = self.nodes[i]\n            d_vec_s[i] = np.sin(np.pi * x) * np.cos(np.pi * y)\n        for i, node_idx in enumerate(E_H_s_sorted):\n            x, y = self.nodes[node_idx]\n            d_vec_s[num_d_s + i] = 0.1 * (x + y)\n        for i, node_idx in enumerate(E_B_s_sorted):\n            x, y = self.nodes[node_idx]\n            d_vec_s[num_d_s + num_a_s + i] = 0.05 * (x - y)\n\n        # Process step s+1\n        A_s1, E_H_s1, E_B_s1 = self._process_step(self.case_data['s+1'])\n\n        # Compute prolongation and evaluate\n        P = np.linalg.pinv(A_s1) @ A_s\n        d_vec_s1 = P @ d_vec_s\n        v_s = A_s @ d_vec_s\n        v_s1 = A_s1 @ d_vec_s1\n        delta_max = np.max(np.abs(v_s1 - v_s))\n\n        # Count changes in enriched DOFs\n        N_add = len(E_H_s1 - E_H_s) + len(E_B_s1 - E_B_s)\n        N_rem = len(E_H_s - E_H_s1) + len(E_B_s - E_B_s1)\n            \n        return [delta_max, N_add, N_rem]\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results in the specified format.\n    \"\"\"\n    test_cases = [\n        { # Case 1\n            's': {'c1': (0.2, 0.5), 'c2': (0.5, 0.5), 't': (0.5, 0.5), 'R_tip': 0.3},\n            's+1': {'c1': (0.2, 0.5), 'c2': (0.8, 0.5), 't': (0.8, 0.5), 'R_tip': 0.3}\n        },\n        { # Case 2\n            's': {'c1': (0.2, 0.2), 'c2': (0.5, 0.5), 't': (0.5, 0.5), 'R_tip': 0.25},\n            's+1': {'c1': (0.2, 0.2), 'c2': (0.8, 0.5), 't': (0.8, 0.5), 'R_tip': 0.25}\n        },\n        { # Case 3\n            's': {'c1': (0.0, 0.5), 'c2': (0.5, 0.5), 't': (0.5, 0.5), 'R_tip': 0.2},\n            's+1': {'c1': (0.0, 0.5), 'c2': (0.9, 0.5), 't': (0.9, 0.5), 'R_tip': 0.2}\n        }\n    ]\n    \n    mesh_params = {'nx': 2, 'ny': 2}\n    epsilon = 1e-8\n    w_vec = (1, 2)\n    \n    results = []\n    for case in test_cases:\n        solver = CrackUpdateSolver(case, mesh_params, epsilon, w_vec)\n        result = solver.run()\n        results.append(f\"[{result[0]:.10e},{result[1]},{result[2]}]\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2551517"}]}