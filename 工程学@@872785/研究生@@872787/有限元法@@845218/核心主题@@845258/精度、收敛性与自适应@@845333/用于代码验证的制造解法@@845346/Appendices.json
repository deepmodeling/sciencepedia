{"hands_on_practices": [{"introduction": "第一个练习将带您完整地体验MMS工作流程。我们的目标不仅仅是检查代码能否运行，而是要定量地验证其是否以理论预期的速率收敛。这个练习将通过在一个二维泊松问题上应用MMS，并计算收敛阶，来展示代码验证的“黄金标准”。[@problem_id:2444940]", "problem": "考虑方形域 $\\Omega = [0,1] \\times [0,1]$ 上的二维泊松方程，\n$$\\nabla^2 u(x,y) = f(x,y), \\quad (x,y) \\in \\Omega,$$\n其狄利克雷边界条件由一个构造解 $u_{m}(x,y)$ 指定，\n$$u(x,y)\\big|_{\\partial \\Omega} = u_{m}(x,y),$$\n其中\n$$u_{m}(x,y) = \\sin(\\pi x)\\,\\cosh(y) + x^2 y^3.$$\n所有三角函数的参数都必须以弧度为单位进行解释。\n\n您的任务是使用构造解法来验证一个泊松方程的数值求解器。具体来说：\n- 通过对构造解 $u_{m}(x,y)$ 应用拉普拉斯算子 $\\nabla^2$，精确推导源项 $f(x,y)$。\n- 对于指定的 $N$ 值，在包含边界的、尺寸为 $N \\times N$ 个节点的均匀笛卡尔网格上，使用推导出的 $f(x,y)$ 求解该边界值问题。\n- 在每个网格上，通过在 $\\partial \\Omega$ 上将 $u(x,y)$ 设置为等于 $u_{m}(x,y)$ 来精确施加狄利克雷边界条件。\n- 在网格节点上，将计算出的数值解 $u_{\\text{num}}$ 与精确的构造解 $u_{m}$ 进行比较，以量化误差。\n\n对于一个具有 $N \\times N$ 个节点和均匀间距 $h = 1/(N-1)$ 的网格，定义以下误差度量：\n- 所有网格节点上的离散最大范数（无穷范数），\n$$E_{\\infty}(N) = \\max_{0 \\le i,j \\le N-1} \\left| u_{\\text{num}}(x_i,y_j) - u_{m}(x_i,y_j) \\right|.$$\n- 所有网格节点上的离散 $L^2$ 范数，\n$$E_{2}(N) = \\left( \\sum_{i=0}^{N-1} \\sum_{j=0}^{N-1} \\left( u_{\\text{num}}(x_i,y_j) - u_{m}(x_i,y_j) \\right)^2 \\, h^2 \\right)^{1/2}.$$\n\n使用离散 $L^2$ 误差，计算在两个尺寸分别为 $N_1$ 和 $N_2$（其中 $N_2 = 2N_1 - 1$，使得网格间距减半）的网格之间的观测精度阶 $p$，公式如下\n$$p = \\frac{\\log\\left( \\dfrac{E_{2}(N_1)}{E_{2}(N_2)} \\right)}{\\log(2)}.$$\n\n角度单位说明：所有角度均以弧度为单位。\n\n测试套件和要求输出：\n- 测试用例1：$N = 3$。报告 $E_{\\infty}(3)$。\n- 测试用例2：$N = 9$。报告 $E_{2}(9)$。\n- 测试用例3：$N_1 = 17$ 和 $N_2 = 33$。根据上述公式，由 $E_{2}(17)$ 和 $E_{2}(33)$ 计算并报告观测到的精度阶 $p$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含按顺序 $[E_{\\infty}(3), E_{2}(9), p]$ 排列的结果，形式为用方括号括起来的逗号分隔列表。\n- 每个数值条目必须格式化为十进制数，小数点后恰好有10位数字。\n- 例如，一个有效的输出行形式为：$[0.1234567890,0.0123456789,1.9876543210]$。", "solution": "所述问题构成了一项适定的、有科学依据的数值方法验证任务。它遵循了计算工程的既定原则，特别是使用构造解法来验证泊松方程有限差分求解器的实现。所有必要的数据、方程和定义均已提供，并且没有内部矛盾或与科学相悖的事实。因此，该问题是有效的，并将构建一个解决方案。\n\n该方法论包括两个主要阶段：首先，解析推导构造解所需的源项；其次，对由此产生的边界值问题进行数值求解并计算误差度量。\n\n首先，我们通过对指定的构造解 $u_{m}(x,y)$ 应用拉普拉斯算子 $\\nabla^2 = \\frac{\\partial^2}{\\partial x^2} + \\frac{\\partial^2}{\\partial y^2}$ 来推导源项 $f(x,y)$。\n构造解给出如下：\n$$u_{m}(x,y) = \\sin(\\pi x)\\cosh(y) + x^2 y^3$$\n我们计算关于 $x$ 和 $y$ 的偏导数。\n对于 $x$ 的导数：\n$$ \\frac{\\partial u_{m}}{\\partial x} = \\pi \\cos(\\pi x)\\cosh(y) + 2x y^3 $$\n$$ \\frac{\\partial^2 u_{m}}{\\partial x^2} = -\\pi^2 \\sin(\\pi x)\\cosh(y) + 2 y^3 $$\n对于 $y$ 的导数：\n$$ \\frac{\\partial u_{m}}{\\partial y} = \\sin(\\pi x)\\sinh(y) + 3x^2 y^2 $$\n$$ \\frac{\\partial^2 u_{m}}{\\partial y^2} = \\sin(\\pi x)\\cosh(y) + 6x^2 y $$\n源项 $f(x,y)$ 是这些二阶导数之和：\n$$ f(x,y) = \\nabla^2 u_{m} = \\frac{\\partial^2 u_{m}}{\\partial x^2} + \\frac{\\partial^2 u_{m}}{\\partial y^2} $$\n$$ f(x,y) = \\left(-\\pi^2 \\sin(\\pi x)\\cosh(y) + 2 y^3\\right) + \\left(\\sin(\\pi x)\\cosh(y) + 6x^2 y\\right) $$\n合并各项得到精确的源函数：\n$$ f(x,y) = (1 - \\pi^2)\\sin(\\pi x)\\cosh(y) + 6x^2 y + 2y^3 $$\n\n其次，我们在覆盖域 $\\Omega = [0,1] \\times [0,1]$ 的一个 $N \\times N$ 节点的均匀笛卡尔网格上求解泊松方程 $\\nabla^2 u(x,y) = f(x,y)$。网格坐标为 $x_j = j h$ 和 $y_i = i h$，其中 $i,j \\in \\{0, 1, \\dots, N-1\\}$，网格间距 $h = 1/(N-1)$。令 $U_{i,j}$ 表示 $u(y_i, x_j)$ 的数值近似。在每个内部节点 $(y_i, x_j)$（其中 $i,j \\in \\{1, \\dots, N-2\\}$）处，使用二阶中心有限差分格式来近似拉普拉斯算子：\n$$ \\frac{U_{i,j+1} - 2U_{i,j} + U_{i,j-1}}{h^2} + \\frac{U_{i+1,j} - 2U_{i,j} + U_{i-1,j}}{h^2} = f(y_i, x_j) $$\n整理此差分模板，得到每个内部节点的线性方程：\n$$ U_{i,j-1} + U_{i,j+1} + U_{i-1,j} + U_{i+1,j} - 4U_{i,j} = h^2 f(y_i, x_j) $$\n这组针对 $(N-2)^2$ 个未知内部节点值的 $(N-2)^2$ 个方程构成了一个形式为 $A \\mathbf{u} = \\mathbf{b}$ 的线性系统。向量 $\\mathbf{u}$ 包含未知值 $U_{i,j}$，例如按行主序排列。矩阵 $A$ 是一个稀疏的块三对角矩阵，表示有限差分模板的连通性。右端向量 $\\mathbf{b}$ 包含根据已知边界条件调整后的 $h^2 f(y_i, x_j)$ 的值。对于一个与边界相邻的内部节点 $(y_i, x_j)$，差分模板中的相应项（例如，如果 $i=1$，则为 $U_{0,j}$）是来自狄利克雷条件 $u_m(y_0, x_j)$ 的已知值，并被移到方程的右侧。\n\n完整的数值解 $u_{\\text{num}}$ 是通过求解该线性系统得到内部值，并将其与由 $u_m(x,y)$ 指定的精确边界值相结合而组装得到的。\n\n误差使用指定的离散范数进行量化。离散最大范数 $E_{\\infty}(N)$ 计算如下：\n$$ E_{\\infty}(N) = \\max_{0 \\le i,j \\le N-1} | u_{\\text{num}}(y_i, x_j) - u_{m}(y_i, x_j) | $$\n离散 $L^2$ 范数 $E_{2}(N)$ 计算如下：\n$$ E_{2}(N) = \\left( \\sum_{i=0}^{N-1} \\sum_{j=0}^{N-1} ( u_{\\text{num}}(y_i, x_j) - u_{m}(y_i, x_j) )^2 h^2 \\right)^{1/2} $$\n然后，通过比较在两个连续细化的网格（$N_1$ 和 $N_2=2N_1-1$，这对应于将网格间距 $h$ 减半）上的 $L^2$ 误差来计算观测到的精度阶 $p$：\n$$ p = \\frac{\\log( E_{2}(N_1) / E_{2}(N_2) )}{\\log(2)} $$\n预期该值约为2，这与有限差分格式的二阶精度一致。\n\n该实现将为指定的 $N$ 值（$N=3, 9, 17, 33$）构建并求解线性系统，以计算所要求的误差度量。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to orchestrate the solution process for all test cases.\n    \"\"\"\n    \n    # Define PI for use in trigonometric functions.\n    PI = np.pi\n\n    def u_m(x, y):\n        \"\"\"\n        Computes the manufactured solution u_m(x,y).\n        - x, y can be NumPy arrays.\n        \"\"\"\n        return np.sin(PI * x) * np.cosh(y) + x**2 * y**3\n\n    def f_source(x, y):\n        \"\"\"\n        Computes the source term f(x,y) derived from grad^2(u_m).\n        - x, y can be NumPy arrays.\n        \"\"\"\n        term1 = (1.0 - PI**2) * np.sin(PI * x) * np.cosh(y)\n        term2 = 6.0 * x**2 * y\n        term3 = 2.0 * y**3\n        return term1 + term2 + term3\n\n    def solve_poisson(N):\n        \"\"\"\n        Solves the Poisson equation on an N x N grid using finite differences.\n        \n        Args:\n            N (int): The number of nodes along one dimension of the grid.\n\n        Returns:\n            tuple: A tuple containing:\n                - u_num (np.ndarray): The N x N numerical solution array.\n                - u_exact (np.ndarray): The N x N exact manufactured solution array.\n                - h (float): The grid spacing.\n        \"\"\"\n        if N  2:\n            raise ValueError(\"Grid size N must be at least 2.\")\n        if N == 2: # No interior points\n            h = 1.0\n            x = np.linspace(0.0, 1.0, N)\n            y = np.linspace(0.0, 1.0, N)\n            xx, yy = np.meshgrid(x, y, indexing='xy')\n            u_exact = u_m(xx, yy)\n            return u_exact, u_exact, h\n\n        # 1. Grid setup\n        h = 1.0 / (N - 1)\n        x = np.linspace(0.0, 1.0, N)\n        y = np.linspace(0.0, 1.0, N)\n        xx, yy = np.meshgrid(x, y, indexing='xy')\n\n        # 2. Evaluate exact solution and source term\n        u_exact = u_m(xx, yy)\n        f_vals = f_source(xx, yy)\n\n        # 3. Setup linear system Ax = b for interior points\n        num_interior_nodes_1d = N - 2\n        num_unknowns = num_interior_nodes_1d**2\n        \n        A = np.zeros((num_unknowns, num_unknowns))\n        b = np.zeros(num_unknowns)\n\n        # The mapping from 2D interior grid index (i_int, j_int) to 1D vector index k\n        # is row-major: k = i_int * num_interior_nodes_1d + j_int\n        # This corresponds to full grid index (i, j) where i = i_int + 1, j = j_int + 1\n        for k in range(num_unknowns):\n            i_int = k // num_interior_nodes_1d\n            j_int = k % num_interior_nodes_1d\n            \n            i = i_int + 1\n            j = j_int + 1\n\n            # Main diagonal coefficient for -4*U_ij\n            A[k, k] = -4.0\n\n            # Right-hand side from source term f(y_i, x_j)\n            b[k] = h**2 * f_vals[i, j]\n\n            # Neighbor contribution (x-direction, j-1)\n            if j == 1:\n                b[k] -= u_exact[i, 0]\n            else:\n                A[k, k - 1] = 1.0\n\n            # Neighbor contribution (x-direction, j+1)\n            if j == N - 2:\n                b[k] -= u_exact[i, N - 1]\n            else:\n                A[k, k + 1] = 1.0\n\n            # Neighbor contribution (y-direction, i-1)\n            if i == 1:\n                b[k] -= u_exact[0, j]\n            else:\n                A[k, k - num_interior_nodes_1d] = 1.0\n\n            # Neighbor contribution (y-direction, i+1)\n            if i == N - 2:\n                b[k] -= u_exact[N - 1, j]\n            else:\n                A[k, k + num_interior_nodes_1d] = 1.0\n\n        # 4. Solve the linear system\n        u_interior_flat = np.linalg.solve(A, b)\n        u_interior = u_interior_flat.reshape((num_interior_nodes_1d, num_interior_nodes_1d))\n\n        # 5. Construct the full numerical solution grid\n        u_num = np.copy(u_exact)  # Initialize with correct boundary values\n        u_num[1:N-1, 1:N-1] = u_interior\n\n        return u_num, u_exact, h\n\n    # Test case 1: N = 3, compute E_infinity\n    u_num_3, u_exact_3, _ = solve_poisson(N=3)\n    e_inf_3 = np.max(np.abs(u_num_3 - u_exact_3))\n\n    # Test case 2: N = 9, compute E_2\n    u_num_9, u_exact_9, h_9 = solve_poisson(N=9)\n    e_2_9 = np.sqrt(np.sum((u_num_9 - u_exact_9)**2) * h_9**2)\n\n    # Test case 3: N1=17, N2=33, compute order of accuracy p\n    # Compute E_2 for N=17\n    u_num_17, u_exact_17, h_17 = solve_poisson(N=17)\n    e_2_17 = np.sqrt(np.sum((u_num_17 - u_exact_17)**2) * h_17**2)\n    \n    # Compute E_2 for N=33\n    u_num_33, u_exact_33, h_33 = solve_poisson(N=33)\n    e_2_33 = np.sqrt(np.sum((u_num_33 - u_exact_33)**2) * h_33**2)\n    \n    # Compute order of accuracy p\n    p = np.log(e_2_17 / e_2_33) / np.log(2.0)\n    \n    # Compile and format results\n    results = [e_inf_3, e_2_9, p]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{x:.10f}' for x in results)}]\")\n\nsolve()\n```", "id": "2444940"}, {"introduction": "第二个练习揭示了MMS一个特殊而强大的功能。通过精心选择一个低阶多项式作为制造解，我们可以测试我们的数值格式是否对该类函数“精确”，这意味着误差应为零（在机器精度范围内）。这种“精确性测试”为离散算子的实现提供了一个清晰明确的验证。[@problem_id:2444972]", "problem": "考虑在单位正方形域 $\\Omega = [0,1] \\times [0,1]$ 上带有狄利克雷边界条件的二维泊松问题。您需要应用制造解方法进行代码验证，具体如下。设制造解为一个二次多项式\n$$\nu_m(x,y) = a x^2 + b x y + c y^2 + d x + e y + f,\n$$\n其中 $a$、$b$、$c$、$d$、$e$ 和 $f$ 为实常数。定义源项 $s(x,y)$，使得 $u_m$ 精确满足带有负拉普拉斯算子的泊松方程，\n$$\n- \\Delta u(x,y) = s(x,y) \\quad \\text{in } \\Omega,\n$$\n以及狄利克雷边界条件\n$$\nu(x,y) = u_m(x,y) \\quad \\text{for } (x,y) \\in \\partial \\Omega.\n$$\n使用标准的二阶中心有限差分格式，在一个均匀的笛卡尔网格上对 $-\\Delta$ 进行离散化。该网格在每个空间方向上有 $N$ 个内部节点，网格间距为 $h = \\frac{1}{N+1}$。设内部网格点为 $\\{(x_i,y_j)\\}_{i,j=1}^N$，其中 $x_i = i h$，$y_j = j h$。对于每个内部节点 $(i,j)$，需要执行的离散内部方程为：\n$$\n\\frac{-u_{i+1,j} - u_{i-1,j} - u_{i,j+1} - u_{i,j-1} + 4 u_{i,j}}{h^2} = s(x_i,y_j),\n$$\n其中狄利克雷边界值由 $\\partial \\Omega$ 上的 $u_m$ 给出。此处，$u_{i,j}$ 表示对 $u(x_i,y_j)$ 的离散近似。\n\n对于下方的每个测试用例，计算包括边界节点在内的整个网格上的离散解，然后报告最大节点绝对误差\n$$\nE_\\infty = \\max_{0 \\le i \\le N+1,\\; 0 \\le j \\le N+1} \\left| u_{i,j} - u_m(x_i,y_j) \\right|.\n$$\n不涉及任何物理单位。如果出现任何角度，都必须以弧度解释，但此处无需用到角度。\n\n测试套件（每个用例为 $(N, a, b, c, d, e, f)$）：\n- 用例 1：$(\\,10,\\, 1.0,\\, 0.5,\\, 2.0,\\, -1.0,\\, 0.25,\\, -0.75\\,)$\n- 用例 2：$(\\,15,\\, 0.0,\\, 3.0,\\, 0.0,\\, 0.0,\\, 0.0,\\, 0.0\\,)$\n- 用例 3：$(\\,8,\\, 0.0,\\, 0.0,\\, 0.0,\\, -2.0,\\, 1.5,\\, 0.1\\,)$\n- 用例 4：$(\\,12,\\, -0.7,\\, 0.0,\\, 0.4,\\, 0.0,\\, 0.0,\\, 2.0\\,)$\n\n您的程序必须按以上列出的顺序为每个用例计算 $E_\\infty$，并生成一行输出，其中包含用逗号分隔并用方括号括起来的四个结果，例如“[$r_1$,$r_2$,$r_3$,$r_4$]”。每个 $r_k$ 都必须是浮点数。不允许有其他输出。", "solution": "用户提供了一个计算工程问题，要求应用制造解方法（MMS）进行代码验证。任务是计算二维泊松方程有限差分解的最大节点误差，其中精确解是一个选定的制造多项式。\n\n**问题验证**\n\n首先，我必须对问题进行严格的验证。\n\n**步骤1：提取已知条件**\n- **控制方程**：二维泊松方程 $-\\Delta u(x,y) = s(x,y)$，在 $\\Omega = [0,1] \\times [0,1]$ 上。\n- **制造解**：$u_m(x,y) = a x^2 + b x y + c y^2 + d x + e y + f$。\n- **源项**：由 $-\\Delta u_m(x,y)$ 导出的 $s(x,y)$。\n- **边界条件**：狄利克雷条件，$u(x,y) = u_m(x,y)$ 在 $\\partial \\Omega$ 上。\n- **离散化**：在均匀网格上的二阶中心有限差分格式。\n- **网格**：每个方向有 $N$ 个内部节点，间距 $h = 1/(N+1)$。网格点为 $(x_i, y_j) = (ih, jh)$。\n- **离散方程**：$\\frac{4u_{i,j} - u_{i+1,j} - u_{i-1,j} - u_{i,j+1} - u_{i,j-1}}{h^2} = s(x_i,y_j)$，适用于内部节点 $i,j \\in \\{1, \\dots, N\\}$。\n- **误差度量**：$E_\\infty = \\max_{0 \\le i,j \\le N+1} | u_{i,j} - u_m(x_i,y_j) |$。\n- **测试用例**：提供了四组参数 $(N, a, b, c, d, e, f)$。\n\n**步骤2：使用提取的已知条件进行验证**\n- **科学依据**：该问题在根本上是合理的。它使用了泊松方程、制造解方法和有限差分法，这些都是数值分析和计算工程中的标准概念。\n- **适定性**：该问题是适定的。带有狄利克雷条件的泊松方程有唯一解。由有限差分离散化得到的相应线性系统是非奇异的，并且也有唯一解。计算误差的请求是代码验证中的一个标准程序。\n- **客观性**：该问题使用精确、客观的数学语言陈述，没有歧义或主观成分。\n\n该问题是自洽、一致且科学有效的。所有必要信息均已提供。\n\n**步骤3：结论与行动**\n问题有效。我将继续进行求解。\n\n**基于原理的求解设计**\n\n这个问题的核心在于理解有限差分格式的截断误差。制造解方法是专门为测试代码实现而设计的，它提供一个已知精确解的问题。\n\n1.  **源项的推导**：\n    制造解为 $u_m(x,y) = a x^2 + b x y + c y^2 + d x + e y + f$。我们必须首先计算其拉普拉斯算子以定义源项 $s(x,y) = -\\Delta u_m(x,y)$。\n    偏导数如下：\n    $\\frac{\\partial u_m}{\\partial x} = 2ax + by + d$\n    $\\frac{\\partial^2 u_m}{\\partial x^2} = 2a$\n    $\\frac{\\partial u_m}{\\partial y} = bx + 2cy + e$\n    $\\frac{\\partial^2 u_m}{\\partial y^2} = 2c$\n    拉普拉斯算子为 $\\Delta u_m = \\frac{\\partial^2 u_m}{\\partial x^2} + \\frac{\\partial^2 u_m}{\\partial y^2} = 2a + 2c$。\n    因此，源项是一个常数：$s(x,y) = -(2a + 2c)$。\n\n2.  **截断误差分析**：\n    负拉普拉斯算子的离散算子是 $L_h u_{i,j} = \\frac{4u_{i,j} - u_{i+1,j} - u_{i-1,j} - u_{i,j+1} - u_{i,j-1}}{h^2}$。\n    该算子的截断误差 $\\tau$ 由 $\\tau = L_h u - (-\\Delta u)$ 给出。对于一个足够光滑的函数 $u$，泰勒级数展开表明 $\\tau = -\\frac{h^2}{12}(\\frac{\\partial^4 u}{\\partial x^4} + \\frac{\\partial^4 u}{\\partial y^4}) + \\mathcal{O}(h^4)$。\n    该格式是二阶精确的。然而，对于我们特定的制造解 $u_m(x,y)$，它是一个二次多项式，所有三阶及更高阶的偏导数都恒等于零。\n    具体来说，$\\frac{\\partial^4 u_m}{\\partial x^4} = 0$ 且 $\\frac{\\partial^4 u_m}{\\partial y^4} = 0$。\n    这意味着截断误差的主项为零。事实上，所有高阶项也为零。对于二次多项式，截断误差精确为零：$\\tau = 0$。\n    这意味着当有限差分算子应用于任何二次多项式时，它能精确地再现连续微分算子：\n    $$\n    L_h u_m(x_i, y_j) = -\\Delta u_m(x_i, y_j) = s(x_i, y_j)\n    $$\n    这个恒等式是解决该问题的关键。它表明，在网格点上求值的制造解是离散方程组的精确解。\n\n3.  **数值实现策略**：\n    任务是计算离散解 $u_{i,j}$ 并将其与精确解 $u_m(x_i, y_j)$ 进行比较。步骤如下：\n    a.  **网格设置**：定义一个包含 $(N+2) \\times (N+2)$ 个点的均匀网格，覆盖域 $[0,1] \\times [0,1]$。\n    b.  **系统构建**：为内部网格点上的 $N^2$ 个未知值构建线性系统 $A \\mathbf{u} = \\mathbf{b}$。矩阵 $A$ 代表五点模板的系数（对角线上为 4，相邻点为 -1）。向量 $\\mathbf{b}$ 包含源项值 $h^2 s(x_i,y_j)$ 和从 $u_m$ 导出的已知边界值。\n    c.  **系统求解**：求解稀疏线性系统以得到内部未知数向量 $\\mathbf{u}$。\n    d.  **误差计算**：通过将已解出的内部值与给定的边界值相结合，重构完整的解网格 $u_{i,j}$。然后，计算该数值解与在网格上求值的制造解之间的最大绝对差：$E_\\infty = \\max |u_{i,j} - u_m(x_i,y_j)|$。\n\n    鉴于截断误差为零，数值解 $u_{i,j}$ 在所有网格点上必须与 $u_m(x_i,y_j)$ 相同，直至浮点精度限制。\n    因此，预期误差 $E_\\infty$ 将是一个非常小的数，量级约为机器精度。一个非零的结果将表明线性系统求解器或问题设置的实现中存在错误。所提供的代码稳健地实现了此过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import diags\nfrom scipy.sparse.linalg import spsolve\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test suite.\n    \"\"\"\n    test_cases = [\n        # (N, a, b, c, d, e, f)\n        (10, 1.0, 0.5, 2.0, -1.0, 0.25, -0.75),\n        (15, 0.0, 3.0, 0.0, 0.0, 0.0, 0.0),\n        (8, 0.0, 0.0, 0.0, -2.0, 1.5, 0.1),\n        (12, -0.7, 0.0, 0.4, 0.0, 0.0, 2.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        N, a, b, c, d, e, f = case\n        error = calculate_max_error(N, a, b, c, d, e, f)\n        results.append(f\"{error:.15e}\")\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef calculate_max_error(N, a, b, c, d, e, f):\n    \"\"\"\n    Calculates the maximum absolute nodal error for a single test case by\n    setting up and solving the discrete Poisson equation.\n    \"\"\"\n    h = 1.0 / (N + 1)\n\n    # 1. Set up the grid and coordinates.\n    # The grid is indexed by (j, i) corresponding to (y, x) for standard\n    # row-major array ordering.\n    x_coords = np.linspace(0.0, 1.0, N + 2)\n    y_coords = np.linspace(0.0, 1.0, N + 2)\n    X, Y = np.meshgrid(x_coords, y_coords, indexing='xy')\n\n    # 2. Define manufactured solution and evaluate on the grid.\n    u_m_func = lambda x, y: a*x**2 + b*x*y + c*y**2 + d*x + e*y + f\n    u_m_grid = u_m_func(X, Y)\n\n    # The source term s(x,y) = -Laplacian(u_m) = -(2a + 2c) is a constant.\n    s_val = -(2*a + 2*c)\n\n    # 3. Set up the linear system A*u = b for interior nodes.\n    # The N*N unknowns correspond to interior grid points, flattened using\n    # row-major ordering: k = (j-1)*N + (i-1).\n    \n    # Construct the sparse matrix A for the 5-point stencil:\n    # 4*u_ji - u_{j,i-1} - u_{j,i+1} - u_{j-1,i} - u_{j+1,i}\n    \n    d_main = np.full(N*N, 4.0)\n    d_h_off = np.full(N*N - 1, -1.0)\n    d_v_off = np.full(N*N - N, -1.0)\n    \n    # Zero out connections between the end of a grid row and the start of the next.\n    for j in range(1, N):\n        d_h_off[j*N - 1] = 0.0\n    \n    diagonals = [d_main, d_h_off, d_h_off, d_v_off, d_v_off]\n    offsets = [0, -1, 1, -N, N]\n    A = diags(diagonals, offsets, shape=(N*N, N*N), format='csr')\n\n    # 4. Construct the RHS vector b.\n    b = np.zeros(N*N)\n    for j in range(1, N + 1):      # y-index on grid\n        for i in range(1, N + 1):  # x-index on grid\n            k = (j - 1) * N + (i - 1)  # row-major vector index\n            \n            # Source term contribution\n            b[k] = h**2 * s_val\n            \n            # Add contributions from known boundary values\n            if i == 1:   # Left boundary (x=0)\n                b[k] += u_m_grid[j, 0]\n            if i == N:   # Right boundary (x=1)\n                b[k] += u_m_grid[j, N+1]\n            if j == 1:   # Bottom boundary (y=0)\n                b[k] += u_m_grid[0, i]\n            if j == N:   # Top boundary (y=1)\n                b[k] += u_m_grid[N+1, i]\n\n    # 5. Solve the linear system for interior node values.\n    u_interior_vec = spsolve(A, b)\n\n    # 6. Reconstruct the full solution grid.\n    u_discrete = np.zeros((N + 2, N + 2))\n    \n    # Set boundary values from manufactured solution\n    u_discrete[0, :] = u_m_grid[0, :]\n    u_discrete[N+1, :] = u_m_grid[N+1, :]\n    u_discrete[:, 0] = u_m_grid[:, 0]\n    u_discrete[:, N+1] = u_m_grid[:, N+1]\n    \n    # Fill interior with the solved values, reshaped according to row-major order.\n    u_discrete[1:N+1, 1:N+1] = u_interior_vec.reshape((N, N), order='C')\n\n    # 7. Calculate the maximum absolute error over the entire grid.\n    error = np.max(np.abs(u_discrete - u_m_grid))\n    \n    return error\n\nsolve()\n\n```", "id": "2444972"}, {"introduction": "最后一个练习将我们带向真实世界的复杂性。大多数有限元代码使用映射单元来处理复杂几何形状，这会在方程中引入几何项（如雅可比矩阵 $X$ 和度量张量 $G$）。一个稳健的验证过程必须确保这些项被正确实现，这需要一个能与它们充分耦合的制造解。本练习演示了如何设计这样一个高级测试来验证三维曲线坐标系下的复杂单元。[@problem_id:2576815]", "problem": "考虑在有限元法 (FEM) 中，使用制造解方法 (MMS) 来验证三维映射单元扩散算子。设物理域由从参考立方体（坐标为 $(\\xi,\\eta,\\zeta)\\in[0,1]^3$）到物理坐标 $(x,y,z)$ 的三线性曲线映射表示，其形式如下：\n$$\n\\begin{aligned}\nx(\\xi,\\eta,\\zeta) = \\xi + a \\sin(\\pi \\xi)\\sin(\\pi \\eta) + b\\,\\zeta^2,\\\\\ny(\\xi,\\eta,\\zeta) = \\eta + c\\,\\xi\\,\\eta + d \\sin(\\pi \\zeta),\\\\\nz(\\xi,\\eta,\\zeta) = \\zeta + e\\,\\xi\\,\\zeta + f\\,\\eta\\,\\zeta,\n\\end{aligned}\n$$\n其中 $a,b,c,d,e,f$ 是实数参数。所有三角函数的参数均以弧度为单位。记雅可比矩阵为 $X_{i\\alpha}=\\partial x_i/\\partial \\xi_\\alpha$，其中 $i\\in\\{1,2,3\\}$ 对应于 $(x,y,z)$，$\\alpha\\in\\{1,2,3\\}$ 对应于 $(\\xi,\\eta,\\zeta)$。设 $J=\\det(X)$ 为雅可比行列式，$G=X^\\top X$ 为协变度量张量，$g=G^{-1}$ 为逆变度量张量，其分量为 $g^{\\alpha\\beta}$。\n\n我们寻求一个制造解 $u_m(\\xi,\\eta,\\zeta)$，使其与三维曲线单元中的度量项强耦合，确保所有的映射分量和混合导数都得到检验。考虑以下 $u_m$：\n$$\n\\begin{aligned}\nu_m(\\xi,\\eta,\\zeta) = \\sin\\!\\Big(\\pi(\\xi + 0.2\\,\\eta)\\Big)\\,\\cos\\!\\Big(\\pi(\\zeta + 0.1\\,\\xi\\,\\eta)\\Big) \\\\\n\\quad + \\xi^2 \\eta + \\eta^2 \\zeta + \\zeta^2 \\xi + \\xi \\eta \\zeta.\n\\end{aligned}\n$$\n设物理空间中的稳态扩散方程为\n$$\n- \\nabla \\cdot (k \\nabla u) = f,\n$$\n其中传导系数 $k0$ 为常数。当使用曲线坐标的标准变换恒等式在参考坐标系中表示时，标量 $u(\\xi,\\eta,\\zeta)$ 在物理空间中的拉普拉斯算子由下式给出：\n$$\n\\Delta u = \\frac{1}{J} \\,\\partial_\\alpha\\!\\left(J\\, g^{\\alpha\\beta}\\, \\partial_\\beta u\\right),\n$$\n其中 $\\partial_\\alpha$ 表示对参考坐标 $\\xi_\\alpha\\in\\{\\xi,\\eta,\\zeta\\}$ 的偏微分，并对重复的希腊字母索引应用爱因斯坦求和约定。因此，制造源项为：\n$$\nf(\\xi,\\eta,\\zeta) = -k\\,\\Delta u_m(\\xi,\\eta,\\zeta) = -\\frac{k}{J} \\,\\partial_\\alpha\\!\\left(J\\, g^{\\alpha\\beta}\\, \\partial_\\beta u_m\\right).\n$$\n\n任务：\n1. 实现该映射，并对于给定的 $(a,b,c,d,e,f)$，计算任意点 $(\\xi,\\eta,\\zeta)$ 处的 $X$、$J$、$G$ 和 $g$。解析地计算 $u_m$ 相对于 $(\\xi,\\eta,\\zeta)$ 的所有一阶导数。对于散度项 $\\partial_\\alpha\\!\\left(J\\, g^{\\alpha\\beta}\\, \\partial_\\beta u_m\\right)$，在相应的参考坐标方向上使用中心有限差分，步长 $h = 1\\times 10^{-6}$，同时保持另外两个坐标固定，即\n$$\n\\partial_\\xi Q_\\xi \\approx \\frac{Q_\\xi(\\xi+h,\\eta,\\zeta)-Q_\\xi(\\xi-h,\\eta,\\zeta)}{2h},\\quad Q_\\xi = J\\,g^{\\xi\\beta}\\,\\partial_\\beta u_m,\n$$\n$\\partial_\\eta Q_\\eta$ 和 $\\partial_\\zeta Q_\\zeta$ 的计算方式与此类似。使用以下公式：\n$$\n\\Delta u_m(\\xi,\\eta,\\zeta) \\approx \\frac{1}{J(\\xi,\\eta,\\zeta)}\\left[\\partial_\\xi Q_\\xi + \\partial_\\eta Q_\\eta + \\partial_\\zeta Q_\\zeta\\right].\n$$\n2. 对于每个指定的参数集和传导系数，在下面列出的采样点上评估 $f(\\xi,\\eta,\\zeta)$，并报告这些点的均方根 (RMS) 值：\n$$\n\\text{RMS}(f) = \\sqrt{\\frac{1}{N}\\sum_{n=1}^N f(\\xi_n,\\eta_n,\\zeta_n)^2},\\quad N=4,\n$$\n采样点为\n$$\n(\\xi,\\eta,\\zeta)\\in\\Big\\{(0.33,0.27,0.41),\\,(0.73,0.19,0.87),\\,(0.51,0.61,0.29),\\,(0.23,0.47,0.79)\\Big\\}.\n$$\n3. 使用以下参数集 $(a,b,c,d,e,f)$ 和传导系数 $k$ 的测试套件：\n- 情况A（仿射边界条件检查）：$(a,b,c,d,e,f)=(0,0,0,0,0,0)$ 且 $k=2.0$。\n- 情况B（中等曲率）：$(a,b,c,d,e,f)=(0.1,0.05,0.2,0.07,0.15,0.12)$ 且 $k=1.0$。\n- 情况C（较强曲率）：$(a,b,c,d,e,f)=(0.2,0.1,0.3,0.15,0.25,0.22)$ 且 $k=0.7$。\n\n所有三角函数参数必须以弧度为单位。无需报告物理单位。角度以弧度为单位。您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，$[r_1,r_2,r_3]$），其中 $r_i$ 是测试套件中第 $i$ 个参数集（按 A、B、C 的顺序）的上述定义的 RMS 值。每个 $r_i$ 必须是一个浮点数。程序必须是自包含的，且不使用外部输入。", "solution": "该问题陈述已经过严格验证，被认为是科学上合理、适定且完整的。它描述了在计算力学领域中使用制造解方法进行数值代码验证的一个标准（尽管计算密集）的流程。我们将着手构建解决方案。\n\n目标是计算在曲线坐标变换下，与一个预设的制造解 $u_m(\\xi, \\eta, \\zeta)$ 相对应的制造源项 $f(\\xi, \\eta, \\zeta)$。其控制方程是稳态扩散方程 $- \\nabla \\cdot (k \\nabla u) = f$。\n\n物理空间 $(x, y, z)$ 和参考空间 $(\\xi, \\eta, \\zeta)$ 中拉普拉斯算子之间的基本关系由下式给出：\n$$\n\\Delta u = \\frac{1}{J} \\frac{\\partial}{\\partial \\xi^\\alpha} \\left( J g^{\\alpha\\beta} \\frac{\\partial u}{\\partial \\xi^\\beta} \\right)\n$$\n这里隐含了对重复索引 $\\alpha, \\beta \\in \\{1, 2, 3\\}$ 的求和。量 $J$ 和 $g^{\\alpha\\beta}$ 分别是雅可比行列式和逆变度量张量的分量，它们都源自坐标映射 $x_i(\\xi_\\alpha)$。\n\n流程如下：\n1.  解析地推导雅可比矩阵 $X_{i\\alpha} = \\partial x_i / \\partial \\xi_\\alpha$ 的分量。\n2.  解析地推导制造解在参考坐标系中的梯度分量 $\\partial_\\alpha u_m = \\partial u_m / \\partial \\xi_\\alpha$。\n3.  对于任意点 $(\\xi, \\eta, \\zeta)$，数值计算几何张量和参考坐标系中的通量矢量。\n4.  使用二阶中心有限差分格式数值逼近通量矢量的散度，以计算 $\\Delta u_m$。\n5.  计算制造源项 $f = -k \\Delta u_m$。\n6.  最后，对每个测试案例，在指定的采样点上计算 $f$ 的均方根 (RMS) 值。\n\n**1. 雅可比矩阵推导**\n映射由以下公式给出：\n$$\n\\begin{aligned}\nx(\\xi,\\eta,\\zeta) = \\xi + a \\sin(\\pi \\xi)\\sin(\\pi \\eta) + b\\,\\zeta^2 \\\\\ny(\\xi,\\eta,\\zeta) = \\eta + c\\,\\xi\\,\\eta + d \\sin(\\pi \\zeta) \\\\\nz(\\xi,\\eta,\\zeta) = \\zeta + e\\,\\xi\\,\\zeta + f\\,\\eta\\,\\zeta\n\\end{aligned}\n$$\n雅可比矩阵 $X$ 的分量为 $X_{i\\alpha} = \\partial x_i / \\partial \\xi_\\alpha$（其中 $x_1=x, x_2=y, x_3=z$ 且 $\\xi_1=\\xi, \\xi_2=\\eta, \\xi_3=\\zeta$）是：\n$$\nX = \\begin{pmatrix}\n\\frac{\\partial x}{\\partial \\xi}  \\frac{\\partial x}{\\partial \\eta}  \\frac{\\partial x}{\\partial \\zeta} \\\\\n\\frac{\\partial y}{\\partial \\xi}  \\frac{\\partial y}{\\partial \\eta}  \\frac{\\partial y}{\\partial \\zeta} \\\\\n\\frac{\\partial z}{\\partial \\xi}  \\frac{\\partial z}{\\partial \\eta}  \\frac{\\partial z}{\\partial \\zeta}\n\\end{pmatrix}\n$$\n各个分量是：\n$$\n\\begin{aligned}\n\\frac{\\partial x}{\\partial \\xi} = 1 + a \\pi \\cos(\\pi \\xi)\\sin(\\pi \\eta) \\\\\n\\frac{\\partial x}{\\partial \\eta} = a \\pi \\sin(\\pi \\xi)\\cos(\\pi \\eta) \\\\\n\\frac{\\partial x}{\\partial \\zeta} = 2 b \\zeta \\\\\n\\frac{\\partial y}{\\partial \\xi} = c \\eta \\\\\n\\frac{\\partial y}{\\partial \\eta} = 1 + c \\xi \\\\\n\\frac{\\partial y}{\\partial \\zeta} = d \\pi \\cos(\\pi \\zeta) \\\\\n\\frac{\\partial z}{\\partial \\xi} = e \\zeta \\\\\n\\frac{\\partial z}{\\partial \\eta} = f \\zeta \\\\\n\\frac{\\partial z}{\\partial \\zeta} = 1 + e \\xi + f \\eta\n\\end{aligned}\n$$\n\n**2. 制造解梯度推导**\n制造解是：\n$$\nu_m(\\xi,\\eta,\\zeta) = \\sin\\Big(\\pi(\\xi + 0.2\\eta)\\Big)\\cos\\Big(\\pi(\\zeta + 0.1\\xi\\eta)\\Big) + \\xi^2 \\eta + \\eta^2 \\zeta + \\zeta^2 \\xi + \\xi \\eta \\zeta\n$$\n它对参考坐标的偏导数是：\n$$\n\\begin{aligned}\n\\frac{\\partial u_m}{\\partial \\xi} = \\ \\pi \\cos\\Big(\\pi(\\xi+0.2\\eta)\\Big) \\cos\\Big(\\pi(\\zeta+0.1\\xi\\eta)\\Big) \\\\\n- 0.1\\pi\\eta \\sin\\Big(\\pi(\\xi+0.2\\eta)\\Big) \\sin\\Big(\\pi(\\zeta+0.1\\xi\\eta)\\Big) \\\\\n+ 2\\xi\\eta + \\zeta^2 + \\eta\\zeta \\\\\n\\\\\n\\frac{\\partial u_m}{\\partial \\eta} = \\ 0.2\\pi \\cos\\Big(\\pi(\\xi+0.2\\eta)\\Big) \\cos\\Big(\\pi(\\zeta+0.1\\xi\\eta)\\Big) \\\\\n- 0.1\\pi\\xi \\sin\\Big(\\pi(\\xi+0.2\\eta)\\Big) \\sin\\Big(\\pi(\\zeta+0.1\\xi\\eta)\\Big) \\\\\n+ \\xi^2 + 2\\eta\\zeta + \\xi\\zeta \\\\\n\\\\\n\\frac{\\partial u_m}{\\partial \\zeta} = \\ -\\pi \\sin\\Big(\\pi(\\xi+0.2\\eta)\\Big) \\sin\\Big(\\pi(\\zeta+0.1\\xi\\eta)\\Big) + \\eta^2 + 2\\zeta\\xi + \\xi\\eta\n\\end{aligned}\n$$\n\n**3. 源项的数值计算**\n对于给定点 $(\\xi, \\eta, \\zeta)$，我们定义一个与通量相关的矢量 $Q$，其分量为：\n$$\nQ_\\alpha = J g^{\\alpha\\beta} \\frac{\\partial u_m}{\\partial \\xi^\\beta}\n$$\n这些分量明确写出为：\n$$\n\\begin{aligned}\nQ_\\xi = J \\left( g^{\\xi\\xi} \\frac{\\partial u_m}{\\partial \\xi} + g^{\\xi\\eta} \\frac{\\partial u_m}{\\partial \\eta} + g^{\\xi\\zeta} \\frac{\\partial u_m}{\\partial \\zeta} \\right) \\\\\nQ_\\eta = J \\left( g^{\\eta\\xi} \\frac{\\partial u_m}{\\partial \\xi} + g^{\\eta\\eta} \\frac{\\partial u_m}{\\partial \\eta} + g^{\\eta\\zeta} \\frac{\\partial u_m}{\\partial \\zeta} \\right) \\\\\nQ_\\zeta = J \\left( g^{\\zeta\\xi} \\frac{\\partial u_m}{\\partial \\xi} + g^{\\zeta\\eta} \\frac{\\partial u_m}{\\partial \\eta} + g^{\\zeta\\zeta} \\frac{\\partial u_m}{\\partial \\zeta} \\right)\n\\end{aligned}\n$$\n其中 $J = \\det(X)$ 且 $g = (X^T X)^{-1}$。拉普拉斯算子中的散度项 $\\partial_\\alpha Q_\\alpha$ 通过中心差分近似，步长为 $h = 1 \\times 10^{-6}$：\n$$\n\\partial_\\alpha Q_\\alpha \\approx \\frac{Q_\\xi(\\xi+h, \\eta, \\zeta) - Q_\\xi(\\xi-h, \\eta, \\zeta)}{2h} + \\frac{Q_\\eta(\\xi, \\eta+h, \\zeta) - Q_\\eta(\\xi, \\eta-h, \\zeta)}{2h} + \\frac{Q_\\zeta(\\xi, \\eta, \\zeta+h) - Q_\\zeta(\\xi, \\eta, \\zeta-h)}{2h}\n$$\n然后，在点 $(\\xi, \\eta, \\zeta)$ 处的拉普拉斯算子计算如下：\n$$\n\\Delta u_m(\\xi, \\eta, \\zeta) \\approx \\frac{1}{J(\\xi,\\eta,\\zeta)} \\left( \\partial_\\alpha Q_\\alpha \\right)\n$$\n源项为 $f(\\xi, \\eta, \\zeta) = -k \\Delta u_m$。\n\n**4. RMS 计算**\nRMS 值在 $N=4$ 个采样点 $(\\xi_n, \\eta_n, \\zeta_n)$ 上计算：\n$$\n\\text{RMS}(f) = \\sqrt{\\frac{1}{N}\\sum_{n=1}^N f(\\xi_n,\\eta_n,\\zeta_n)^2}\n$$\n对问题陈述中指定的三个测试案例中的每一个都执行此过程。实现将使用数值库进行矩阵运算，如行列式和求逆。所有三角函数的输入都被视为弧度。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to execute the Method of Manufactured Solutions task.\n    It computes the RMS of the source term for three different test cases.\n    \"\"\"\n    \n    # Define the finite difference step size\n    H = 1e-6\n    \n    # Define the sample points in the reference domain\n    sample_points = [\n        (0.33, 0.27, 0.41),\n        (0.73, 0.19, 0.87),\n        (0.51, 0.61, 0.29),\n        (0.23, 0.47, 0.79)\n    ]\n    \n    # Define the test cases with mapping parameters and conductivity\n    test_cases = [\n        # Case A: Affine mapping\n        {'params': (0.0, 0.0, 0.0, 0.0, 0.0, 0.0), 'k': 2.0},\n        # Case B: Moderate curvature\n        {'params': (0.1, 0.05, 0.2, 0.07, 0.15, 0.12), 'k': 1.0},\n        # Case C: Stronger curvature\n        {'params': (0.2, 0.1, 0.3, 0.15, 0.25, 0.22), 'k': 0.7}\n    ]\n\n    def get_grad_um(xi, eta, zeta):\n        \"\"\"\n        Computes the analytical gradient of the manufactured solution u_m\n        in the reference coordinates (xi, eta, zeta).\n        \"\"\"\n        term1_arg1 = np.pi * (xi + 0.2 * eta)\n        term1_arg2 = np.pi * (zeta + 0.1 * xi * eta)\n        \n        sin1 = np.sin(term1_arg1)\n        cos1 = np.cos(term1_arg1)\n        sin2 = np.sin(term1_arg2)\n        cos2 = np.cos(term1_arg2)\n\n        # Partial derivative with respect to xi\n        du_dxi = (np.pi * cos1 * cos2 \n                  - 0.1 * np.pi * eta * sin1 * sin2 \n                  + 2.0 * xi * eta + zeta**2 + eta * zeta)\n                  \n        # Partial derivative with respect to eta\n        du_deta = (0.2 * np.pi * cos1 * cos2 \n                   - 0.1 * np.pi * xi * sin1 * sin2 \n                   + xi**2 + 2.0 * eta * zeta + xi * zeta)\n                   \n        # Partial derivative with respect to zeta\n        du_dzeta = (-np.pi * sin1 * sin2 \n                    + eta**2 + 2.0 * zeta * xi + xi * eta)\n        \n        return np.array([du_dxi, du_deta, du_dzeta])\n\n    def compute_Q_and_J(xi, eta, zeta, params):\n        \"\"\"\n        Computes the flux-related vector Q and the Jacobian determinant J.\n        \"\"\"\n        a, b, c, d, e, f = params\n        pi = np.pi\n        \n        # Jacobian matrix X\n        X = np.zeros((3, 3))\n        X[0, 0] = 1.0 + a * pi * np.cos(pi * xi) * np.sin(pi * eta)\n        X[0, 1] = a * pi * np.sin(pi * xi) * np.cos(pi * eta)\n        X[0, 2] = 2.0 * b * zeta\n        X[1, 0] = c * eta\n        X[1, 1] = 1.0 + c * xi\n        X[1, 2] = d * pi * np.cos(pi * zeta)\n        X[2, 0] = e * zeta\n        X[2, 1] = f * zeta\n        X[2, 2] = 1.0 + e * xi + f * eta\n        \n        # Jacobian determinant J\n        J = np.linalg.det(X)\n        \n        # Covariant metric tensor G and contravariant metric tensor g\n        G = X.T @ X\n        g = np.linalg.inv(G)\n        \n        # Gradient of u_m\n        grad_u = get_grad_um(xi, eta, zeta)\n        \n        # Flux vector Q\n        Q = J * (g @ grad_u)\n        \n        return Q, J\n\n    def calculate_source_rms(params, k):\n        \"\"\"\n        Calculates the RMS of the manufactured source term over the sample points.\n        \"\"\"\n        f_squared_values = []\n        \n        for xi_c, eta_c, zeta_c in sample_points:\n            # Finite difference approximation for the divergence of Q\n            Q_px, _ = compute_Q_and_J(xi_c + H, eta_c, zeta_c, params)\n            Q_mx, _ = compute_Q_and_J(xi_c - H, eta_c, zeta_c, params)\n            div_Q_xi = (Q_px[0] - Q_mx[0]) / (2.0 * H)\n            \n            Q_py, _ = compute_Q_and_J(xi_c, eta_c + H, zeta_c, params)\n            Q_my, _ = compute_Q_and_J(xi_c, eta_c - H, zeta_c, params)\n            div_Q_eta = (Q_py[1] - Q_my[1]) / (2.0 * H)\n\n            Q_pz, _ = compute_Q_and_J(xi_c, eta_c, zeta_c + H, params)\n            Q_mz, _ = compute_Q_and_J(xi_c, eta_c, zeta_c - H, params)\n            div_Q_zeta = (Q_pz[2] - Q_mz[2]) / (2.0 * H)\n            \n            div_Q = div_Q_xi + div_Q_eta + div_Q_zeta\n            \n            # Jacobian determinant at the center point\n            _, J_c = compute_Q_and_J(xi_c, eta_c, zeta_c, params)\n            \n            # Laplacian of the manufactured solution\n            laplacian_um = div_Q / J_c\n            \n            # Manufactured source term f\n            f_val = -k * laplacian_um\n            f_squared_values.append(f_val**2)\n            \n        return np.sqrt(np.mean(f_squared_values))\n\n    results = []\n    for case in test_cases:\n        rms_val = calculate_source_rms(case['params'], case['k'])\n        results.append(rms_val)\n        \n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2576815"}]}