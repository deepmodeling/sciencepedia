{"hands_on_practices": [{"introduction": "本练习是进入后验误差估计世界至关重要的第一步。我们将剖析一个经典的一维泊松问题，对此问题，我们可以用封闭形式推导出精确解、有限元近似解以及真实误差。通过手动构建一个标准的基于残差的误差估计子 [@problem_id:2539270]，您将对其组成部分——单元残差和单元间通量跳跃——获得具体的理解，并了解它们如何组合以逼近误差。本练习最终将计算效率指数，为我们提供一个直接衡量估计子质量的指标。", "problem": "考虑在 $(0,1)$ 上的边值问题 $-u''=1$，其带有齐次狄利克雷边界条件 $u(0)=u(1)=0$。令 $V:=H_{0}^{1}(0,1)$，并令 $u\\in V$ 表示其精确解。令 $\\{\\mathcal{T}_h\\}$ 为 $(0,1)$ 上的一族均匀网格，其中包含 $N\\in\\mathbb{N}$ 个大小为 $h=1/N$ 的单元，并令 $V_h\\subset V$ 为与 $\\mathcal{T}_h$ 相关的协调分片线性有限元空间。令 $u_h\\in V_h$ 为 $V_h$ 中弱问题的 Galerkin 解。从弱残差及其通过分部积分的局部化出发，构建一个标准的基于残差的后验误差估计子，该估计子由单元（体积）残差和单元间法向通量跳跃以及网格尺寸缩放构成。以仅含 $N$ 的闭式函数形式，计算以下两者：\n- 全局基于残差的估计子 $\\eta(N)$，\n- 精确能量范数误差 $\\|u-u_h\\|_{H_{0}^{1}(0,1)}$。\n然后构建效率指数 $\\theta(N):=\\eta(N)\\big/\\|u-u_h\\|_{H_{0}^{1}(0,1)}$。\n\n请以仅含 $N$ 的单个闭式表达式给出最终答案（无需数值取整）。", "solution": "所述问题是有效的。这是一个偏微分方程数值分析中的适定、典范问题，特别是在有限元方法的后验误差估计这一主题下。所有组成部分都定义清晰且在数学上是合理的。我们将着手求解。\n\n边值问题是：\n$$ -u'' = 1 \\quad \\text{on } (0,1), \\quad u(0)=u(1)=0 $$\n弱形式的空间是 $V := H_{0}^{1}(0,1)$。弱形式是找到 $u \\in V$ 使得\n$$ a(u,v) = L(v) \\quad \\forall v \\in V, $$\n其中双线性形式 $a(u,v)$ 和线性泛函 $L(v)$ 由下式给出：\n$$ a(u,v) := \\int_{0}^{1} u'(x) v'(x) \\, dx, \\quad L(v) := \\int_{0}^{1} 1 \\cdot v(x) \\, dx $$\n与此问题相关的能量范数是 $\\|v\\|_{H_{0}^{1}(0,1)} = (\\int_{0}^{1} (v'(x))^2 \\, dx)^{1/2} = \\|v'\\|_{L^2(0,1)}$。\n\n首先，我们求精确解 $u(x)$。对 $-u''=1$ 积分两次得到 $u(x) = -\\frac{1}{2}x^2 + C_1 x + C_2$。应用边界条件 $u(0)=0$ 和 $u(1)=0$ 得到 $C_2=0$ 和 $C_1=\\frac{1}{2}$。因此，精确解是\n$$ u(x) = \\frac{1}{2}x(1-x) $$\n精确解的导数是 $u'(x) = \\frac{1}{2} - x$。\n\n接下来，我们刻画 Galerkin 解 $u_h \\in V_h$。空间 $V_h$ 由在均匀网格上的连续分片线性函数构成，其节点为 $x_i = i h$（$i=0, \\dots, N$），其中 $h=1/N$。Galerkin 问题是：找到 $u_h \\in V_h$ 使得\n$$ a(u_h, v_h) = L(v_h) \\quad \\forall v_h \\in V_h $$\n对于这个特定问题，有限元解 $u_h$ 在网格节点处对精确解 $u$ 进行插值：$u_h(x_i) = u(x_i)$ 对所有 $i=0, \\dots, N$ 成立。在每个单元 $T_i := [x_{i-1}, x_i]$ 上，$u_h$ 是线性的，所以其导数 $u_h'$ 是一个常数。这个常数是\n$$ u_h'(x)|_{T_i} = \\frac{u_h(x_i) - u_h(x_{i-1})}{h} = \\frac{u(ih) - u((i-1)h)}{h} $$\n代入 $u(x)$ 的表达式：\n$$ u_h'(x)|_{T_i} = \\frac{1}{h} \\left( \\frac{1}{2}ih(1-ih) - \\frac{1}{2}(i-1)h(1-(i-1)h) \\right) = \\frac{1}{2} (1 - (2i-1)h) $$\n这等于精确导数 $u'(x)$ 在单元中点 $x_{i-1/2} = (i-1/2)h$ 处的值。\n\n现在我们计算精确能量范数误差 $\\|u-u_h\\|_{H_{0}^{1}(0,1)}$。\n$$ \\|u-u_h\\|_{H_{0}^{1}(0,1)}^2 = \\int_{0}^{1} (u'(x) - u_h'(x))^2 \\, dx = \\sum_{i=1}^{N} \\int_{x_{i-1}}^{x_i} (u'(x) - u_h'(x))^2 \\, dx $$\n在一个单元 $T_i$ 上，被积函数是：\n$$ (u'(x) - u_h'(x))^2 = \\left( \\left(\\frac{1}{2} - x\\right) - \\frac{1}{2}(1 - (2i-1)h) \\right)^2 = \\left( (i-1/2)h - x \\right)^2 $$\n令 $s = x - (i-1/2)h$。在 $T_i$ 上的积分变为：\n$$ \\int_{-h/2}^{h/2} s^2 \\, ds = \\left[ \\frac{s^3}{3} \\right]_{-h/2}^{h/2} = \\frac{1}{3} \\left( \\left(\\frac{h}{2}\\right)^3 - \\left(-\\frac{h}{2}\\right)^3 \\right) = \\frac{h^3}{12} $$\n这个结果对于所有 $N$ 个单元都是相同的。将这些贡献相加得到总平方误差：\n$$ \\|u-u_h\\|_{H_{0}^{1}(0,1)}^2 = \\sum_{i=1}^{N} \\frac{h^3}{12} = N \\frac{h^3}{12} = N \\frac{(1/N)^3}{12} = \\frac{1}{12N^2} $$\n因此，精确误差为：\n$$ \\|u-u_h\\|_{H_{0}^{1}(0,1)} = \\sqrt{\\frac{1}{12N^2}} = \\frac{1}{2\\sqrt{3}N} $$\n\n接下来，我们构造标准的基于残差的后验误差估计子。误差 $e = u-u_h$ 对所有 $v_h \\in V_h$ 满足 Galerkin 正交性条件 $a(e, v_h)=0$。对于任意 $v \\in V$，误差方程为 $a(e,v) = L(v) - a(u_h,v)$。这个右端项是弱残差。通过逐单元分部积分，它可以写成：\n$$ L(v) - a(u_h,v) = \\sum_{i=1}^{N} \\int_{T_i} (1+u_h''(x)) v(x) \\, dx + \\sum_{i=1}^{N-1} [[-u_h']](x_i) v(x_i) $$\n其中 $R_{T_i} = 1+u_h''|_{T_i}$ 是单元残差，$J_i = [[-u_h']](x_i)$ 是内部节点 $x_i$ 处的跳跃残差。\n对于一维问题，标准的估计子平方是：\n$$ \\eta^2 = \\sum_{i=1}^{N} h^2 \\|R_{T_i}\\|_{L^2(T_i)}^2 + \\sum_{i=1}^{N-1} |[[u_h']](x_i)|^2 $$\n我们计算各个分量。由于 $u_h$ 在每个单元 $T_i$ 上是线性的，所以 $u_h''=0$。因此，单元残差 $R_{T_i} = 1$。其 $L^2$-范数的平方是：\n$$ \\|R_{T_i}\\|_{L^2(T_i)}^2 = \\int_{x_{i-1}}^{x_i} 1^2 \\, dx = h $$\n在内部节点 $x_i$ 处导数的跳跃是：\n$$ [[u_h']](x_i) = u_h'(x)|_{T_{i+1}} - u_h'(x)|_{T_i} = \\frac{1}{2}(1 - (2(i+1)-1)h) - \\frac{1}{2}(1 - (2i-1)h) $$\n$$ = \\frac{1}{2}(1 - (2i+1)h - 1 + (2i-1)h) = \\frac{1}{2}(-2h) = -h $$\n体积残差平方和是：\n$$ \\sum_{i=1}^{N} h^2 \\|R_{T_i}\\|_{L^2(T_i)}^2 = \\sum_{i=1}^{N} h^2 \\cdot h = N h^3 $$\n跳跃残差平方和是：\n$$ \\sum_{i=1}^{N-1} |[[u_h']](x_i)|^2 = \\sum_{i=1}^{N-1} (-h)^2 = (N-1)h^2 $$\n总估计子平方是这两部分之和。代入 $h=1/N$：\n$$ \\eta^2 = N h^3 + (N-1)h^2 = N (1/N)^3 + (N-1)(1/N)^2 = \\frac{1}{N^2} + \\frac{N-1}{N^2} = \\frac{N}{N^2} = \\frac{1}{N} $$\n因此，估计子为：\n$$ \\eta(N) = \\sqrt{\\frac{1}{N}} = \\frac{1}{\\sqrt{N}} $$\n\n最后，我们计算效率指数 $\\theta(N) = \\eta(N) / \\|u-u_h\\|_{H_{0}^{1}(0,1)}$：\n$$ \\theta(N) = \\frac{1/\\sqrt{N}}{1/(2\\sqrt{3}N)} = \\frac{2\\sqrt{3}N}{\\sqrt{N}} = 2\\sqrt{3}\\sqrt{N} = \\sqrt{12N} $$", "answer": "$$\\boxed{\\sqrt{12N}}$", "id": "2539270"}, {"introduction": "现实世界中的工程和物理问题通常涉及复杂的边界条件，这些边界条件超出了简单的齐次狄利克雷约束。本练习 [@problem_id:2539242] 直面这一现实，重点关注如何为诺伊曼（Neumann）和罗宾（Robin）条件正确地建立边界残差，这对于误差估计子的整体可靠性至关重要。通过解决一个具有混合边界条件的二维问题，您将学会推导和计算这些特定的边界贡献项，这是将误差估计应用于更实际场景所必需的技能。", "problem": "考虑标量扩散偏微分方程 (PDE)\n$$-\\nabla \\cdot (\\kappa \\nabla u) = f \\quad \\text{in } \\Omega := (0,1)\\times(0,1),$$\n在边界 $\\Gamma = \\partial \\Omega$ 上具有混合边界条件，边界由剖分 $\\Gamma = \\Gamma_{D} \\cup \\Gamma_{N} \\cup \\Gamma_{R}$ 给出，其中 $\\Gamma_{D}$ 是左边界和上边界的并集，$\\Gamma_{N}$ 是右边界 $\\{1\\}\\times[0,1]$，$\\Gamma_{R}$ 是下边界 $[0,1]\\times\\{0\\}$。边界条件为\n$$u = 0 \\ \\text{on } \\Gamma_{D}, \\qquad \\kappa \\,\\partial_{n} u = g_{N} \\ \\text{on } \\Gamma_{N}, \\qquad \\kappa \\,\\partial_{n} u + \\beta\\, u = g_{R} \\ \\text{on } \\Gamma_{R},$$\n其中 $\\boldsymbol{n}$ 为单位外法向量。假设 $\\kappa = 2$ 且 $\\beta = 1$，并令 $g_{N}(y) = 1 + y$（对于 $(x,y) \\in \\Gamma_{N}$）以及 $g_{R}(x) = 2 - x$（对于 $(x,y) \\in \\Gamma_{R}$）。源项 $f$ 是光滑的，但除此之外未指定，因为只需要计算边界贡献。\n\n令 $u_h$ 为一个连续分片仿射有限元法 (FEM) 近似，该近似定义在一个形则三角剖分上，此剖分引出以下四个长度均为 $h_E = 0.5$ 的直边界边：\n$$E_{1} = [0,0.5]\\times\\{0\\} \\subset \\Gamma_{R}, \\quad E_{2} = [0.5,1]\\times\\{0\\} \\subset \\Gamma_{R},$$\n$$E_{3} = \\{1\\}\\times[0,0.5] \\subset \\Gamma_{N}, \\quad E_{4} = \\{1\\}\\times[0.5,1] \\subset \\Gamma_{N}.$$\n在与每条边 $E_i$ 相邻的单个三角形 $T_i$ 上，$u_h$ 的局部仿射表示为\n$$u_h(x,y) = c_i + a_i\\, x + b_i\\, y,$$\n其梯度 $\\nabla u_h|_{T_i} = (a_i,b_i)$ 由下式给出\n$$(a_1,b_1,c_1) = (0.5,-0.2,1.0), \\quad (a_2,b_2,c_2) = (0.6,0.1,0.8),$$\n$$(a_3,b_3,c_3) = (-0.3,0.4,0.2), \\quad (a_4,b_4,c_4) = (0.1,0.7,-0.1).$$\n\n从弱形式出发，通过逐单元分部积分，推导在混合边界条件的标准基于残差的后验误差估计子中出现的边界残差项，并用数据和 $u_h$ 表示 Neumann 边和 Robin 边的相应边界残差。然后，使用你推导出的表达式，计算估计子的边界部分，\n$$\\eta_{\\partial} := \\left(\\sum_{E \\subset \\Gamma_{N}} h_E \\,\\|g_N - \\kappa\\,\\partial_n u_h\\|_{0,E}^{2} \\;+\\; \\sum_{E \\subset \\Gamma_{R}} h_E \\,\\|g_R - (\\kappa\\,\\partial_n u_h + \\beta\\, u_h)\\|_{0,E}^{2}\\right)^{1/2},$$\n其中 $\\|\\cdot\\|_{0,E}$ 表示边 $E$ 上的 $L^2$ 范数，且 $\\partial_n u_h := \\nabla u_h \\cdot \\boldsymbol{n}$。\n\n在 $\\Gamma_{R}$ 上取外法向量 $\\boldsymbol{n} = (0,-1)$，在 $\\Gamma_{N}$ 上取 $\\boldsymbol{n} = (1,0)$。使用给定的 $u_h$ 的仿射形式以及数据 $g_N$、$g_R$，通过直接计算来精确计算边积分。将 $\\eta_{\\partial}$ 的最终数值四舍五入到四位有效数字。你的最终答案应表示为一个纯数（无单位）。", "solution": "对问题陈述进行审查后，认定其有效。该问题在科学上基于有限元法后验误差估计理论，是适定的，所有必要数据均已提供，并以客观、精确的语言表述。未发现任何瑕疵。因此，我们可以开始求解。\n\n任务有两部分：首先，从问题的弱形式推导边界残差项；其次，计算边界误差估计子 $\\eta_{\\partial}$ 的数值。\n\n令测试空间 $V$ 为在 Dirichlet 边界 $\\Gamma_D$ 上为零且具有平方可积一阶导数的函数的 Sobolev 空间，即 $V := \\{v \\in H^1(\\Omega) \\mid v|_{\\Gamma_D} = 0\\}$。对于精确解 $u \\in H^1(\\Omega)$ 且 $u|_{\\Gamma_D} = 0$，其弱形式是找到 $u$，使得对于所有 $v \\in V$：\n$$ \\int_{\\Omega} \\kappa \\nabla u \\cdot \\nabla v \\, d\\boldsymbol{x} + \\int_{\\Gamma_R} \\beta u v \\, ds = \\int_{\\Omega} f v \\, d\\boldsymbol{x} + \\int_{\\Gamma_N} g_N v \\, ds + \\int_{\\Gamma_R} g_R v \\, ds. $$\n记此式为 $a(u,v) = L(v)$。有限元解 $u_h \\in V_h \\subset V$ 的构造使其满足 Galerkin 正交性。误差 $e = u - u_h$ 满足 $a(e,v) = a(u,v) - a(u_h,v) = L(v) - a(u_h,v)$，对所有 $v \\in V$ 成立。展开此式可得：\n$$ a(e,v) = \\int_{\\Omega} f v \\, d\\boldsymbol{x} + \\int_{\\Gamma_N} g_N v \\, ds + \\int_{\\Gamma_R} g_R v \\, ds - \\int_{\\Omega} \\kappa \\nabla u_h \\cdot \\nabla v \\, d\\boldsymbol{x} - \\int_{\\Gamma_R} \\beta u_h v \\, ds. $$\n我们对包含 $\\nabla u_h$ 的项逐单元应用分部积分（格林第一恒等式）：\n$$ \\int_{\\Omega} \\kappa \\nabla u_h \\cdot \\nabla v \\, d\\boldsymbol{x} = \\sum_{T} \\int_{T} \\kappa \\nabla u_h \\cdot \\nabla v \\, d\\boldsymbol{x} = \\sum_{T} \\left( \\int_{T} (-\\nabla \\cdot (\\kappa \\nabla u_h)) v \\, d\\boldsymbol{x} + \\int_{\\partial T} (\\kappa \\nabla u_h \\cdot \\boldsymbol{n}_T) v \\, ds \\right). $$\n由于 $\\kappa$ 是常数且 $u_h$ 是分片仿射的，其梯度 $\\nabla u_h$ 是分片常数，因此在每个单元 $T$ 内部 $\\nabla \\cdot (\\kappa \\nabla u_h) = 0$。误差方程变为：\n$$ a(e,v) = \\int_{\\Omega} f v \\, d\\boldsymbol{x} - \\sum_{T} \\int_{\\partial T} (\\kappa \\partial_n u_h) v \\, ds + \\int_{\\Gamma_N} g_N v \\, ds + \\int_{\\Gamma_R} g_R v \\, ds - \\int_{\\Gamma_R} \\beta u_h v \\, ds. $$\n对单元边界 $\\partial T$ 的求和可分为对内部边 $\\mathcal{E}_I$ 和边界边的求和。跨内部边的跳跃会产生边残差，但我们只关心边界贡献。收集边界 $\\Gamma = \\Gamma_N \\cup \\Gamma_R$ 上的项（因为在 $\\Gamma_D$ 上 $v=0$），我们得到：\n$$ a(e,v) = \\dots + \\sum_{E \\subset \\Gamma_N} \\int_E (g_N - \\kappa \\partial_n u_h) v \\, ds + \\sum_{E \\subset \\Gamma_R} \\int_E (g_R - \\kappa \\partial_n u_h - \\beta u_h) v \\, ds. $$\n此推导确定了边界残差。对于一条边 $E \\subset \\Gamma_N$ (Neumann)，残差为 $R_N = g_N - \\kappa \\partial_n u_h$。对于一条边 $E \\subset \\Gamma_R$ (Robin)，残差为 $R_R = g_R - (\\kappa \\partial_n u_h + \\beta u_h)$。这些正是 $\\eta_{\\partial}$ 定义中出现的项。\n\n现在，我们计算对 $\\eta_{\\partial}^2$ 有贡献的各个项。给定 $\\kappa=2$，$\\beta=1$，以及对所有边 $h_E=0.5$。\n\n**边 $E_1 = [0,0.5]\\times\\{0\\} \\subset \\Gamma_R$:**\n外法向量为 $\\boldsymbol{n} = (0,-1)$。在相邻的三角形 $T_1$ 上，$u_h(x,y) = 1.0 + 0.5x - 0.2y$ 且 $\\nabla u_h|_{T_1} = (0.5, -0.2)$。\n法向导数部分为 $\\kappa \\partial_n u_h = \\kappa(\\nabla u_h \\cdot \\boldsymbol{n}) = 2((0.5, -0.2) \\cdot (0,-1)) = 2(0.2) = 0.4$。\n在 $E_1$ 上，$y=0$，所以 $u_h(x,0) = 1.0 + 0.5x$。Robin 数据为 $g_R(x) = 2 - x$。\n残差为 $R_R|_{E_1} = g_R - (\\kappa \\partial_n u_h + \\beta u_h) = (2 - x) - (0.4 + 1 \\cdot (1.0 + 0.5x)) = 0.6 - 1.5x$。\n$L^2$范数的平方为 $\\|R_R\\|_{0,E_1}^2 = \\int_0^{0.5} (0.6 - 1.5x)^2 dx = \\int_0^{0.5} (0.36 - 1.8x + 2.25x^2) dx = [0.36x - 0.9x^2 + 0.75x^3]_0^{0.5} = 0.36(0.5) - 0.9(0.25) + 0.75(0.125) = 0.18 - 0.225 + 0.09375 = 0.04875$。\n对 $\\eta_{\\partial}^2$ 的贡献为 $h_{E_1} \\|R_R\\|_{0,E_1}^2 = 0.5 \\times 0.04875 = 0.024375$。\n\n**边 $E_2 = [0.5,1]\\times\\{0\\} \\subset \\Gamma_R$:**\n法向量为 $\\boldsymbol{n} = (0,-1)$。在 $T_2$ 上，$\\nabla u_h|_{T_2} = (0.6, 0.1)$。\n$\\kappa \\partial_n u_h = 2((0.6, 0.1) \\cdot (0,-1)) = 2(-0.1) = -0.2$。\n在 $E_2$ 上，$u_h(x,0) = 0.8 + 0.6x$。Robin 数据为 $g_R(x) = 2 - x$。\n残差为 $R_R|_{E_2} = (2 - x) - (-0.2 + 1 \\cdot (0.8 + 0.6x)) = 1.4 - 1.6x$。\n$\\|R_R\\|_{0,E_2}^2 = \\int_{0.5}^1 (1.4 - 1.6x)^2 dx = [ \\frac{(1.4 - 1.6x)^3}{3 \\cdot (-1.6)} ]_{0.5}^1 = -\\frac{1}{4.8} ((-0.2)^3 - (0.6)^3) = -\\frac{1}{4.8} (-0.008 - 0.216) = \\frac{0.224}{4.8} = \\frac{7}{150}$。\n贡献为 $h_{E_2} \\|R_R\\|_{0,E_2}^2 = 0.5 \\times \\frac{7}{150} = \\frac{7}{300}$。\n\n**边 $E_3 = \\{1\\}\\times[0,0.5] \\subset \\Gamma_N$:**\n外法向量为 $\\boldsymbol{n} = (1,0)$。在 $T_3$ 上，$\\nabla u_h|_{T_3} = (-0.3, 0.4)$。\n$\\kappa \\partial_n u_h = 2((-0.3, 0.4) \\cdot (1,0)) = 2(-0.3) = -0.6$。\nNeumann 数据为 $g_N(y) = 1 + y$。\n残差为 $R_N|_{E_3} = g_N - \\kappa \\partial_n u_h = (1+y) - (-0.6) = 1.6 + y$。\n$\\|R_N\\|_{0,E_3}^2 = \\int_0^{0.5} (1.6 + y)^2 dy = [ \\frac{(1.6+y)^3}{3} ]_0^{0.5} = \\frac{1}{3} (2.1^3 - 1.6^3) = \\frac{1}{3} (9.261 - 4.096) = \\frac{5.165}{3}$。\n贡献为 $h_{E_3} \\|R_N\\|_{0,E_3}^2 = 0.5 \\times \\frac{5.165}{3} = \\frac{5.165}{6}$。\n\n**边 $E_4 = \\{1\\}\\times[0.5,1] \\subset \\Gamma_N$:**\n法向量为 $\\boldsymbol{n} = (1,0)$。在 $T_4$ 上，$\\nabla u_h|_{T_4} = (0.1, 0.7)$。\n$\\kappa \\partial_n u_h = 2((0.1, 0.7) \\cdot (1,0)) = 2(0.1) = 0.2$。\nNeumann 数据为 $g_N(y) = 1 + y$。\n残差为 $R_N|_{E_4} = (1+y) - 0.2 = 0.8 + y$。\n$\\|R_N\\|_{0,E_4}^2 = \\int_{0.5}^1 (0.8 + y)^2 dy = [ \\frac{(0.8+y)^3}{3} ]_{0.5}^1 = \\frac{1}{3} (1.8^3 - 1.3^3) = \\frac{1}{3} (5.832 - 2.197) = \\frac{3.635}{3}$。\n贡献为 $h_{E_4} \\|R_N\\|_{0,E_4}^2 = 0.5 \\times \\frac{3.635}{3} = \\frac{3.635}{6}$。\n\n最后，我们将这些贡献相加得到 $\\eta_{\\partial}^2$：\n$$ \\eta_{\\partial}^2 = 0.024375 + \\frac{7}{300} + \\frac{5.165}{6} + \\frac{3.635}{6}. $$\n为进行精确计算，我们转换为分数：\n$0.024375 = \\frac{39}{1600}$。\n$\\frac{7}{300}$。\n$\\frac{5.165}{6} = \\frac{1033}{1200}$。\n$\\frac{3.635}{6} = \\frac{727}{1200}$。\n$$ \\eta_{\\partial}^2 = \\frac{39}{1600} + \\frac{7}{300} + \\frac{1033}{1200} + \\frac{727}{1200} = \\frac{39}{1600} + \\frac{7}{300} + \\frac{1760}{1200} = \\frac{39}{1600} + \\frac{7}{300} + \\frac{22}{15}. $$\n分母 $1600$、$300$ 和 $15$ 的最小公倍数为 $4800$。\n$$ \\eta_{\\partial}^2 = \\frac{39 \\cdot 3}{4800} + \\frac{7 \\cdot 16}{4800} + \\frac{22 \\cdot 320}{4800} = \\frac{117 + 112 + 7040}{4800} = \\frac{7269}{4800}. $$\n此分数可通过分子分母同除以 $3$ 来简化：\n$$ \\eta_{\\partial}^2 = \\frac{2423}{1600}. $$\n现在我们计算 $\\eta_{\\partial}$ 的值：\n$$ \\eta_{\\partial} = \\sqrt{\\frac{2423}{1600}} = \\frac{\\sqrt{2423}}{40} \\approx \\frac{49.223977896}{40} \\approx 1.2305994474. $$\n四舍五入到四位有效数字得到 $1.231$。", "answer": "$$\\boxed{1.231}$$", "id": "2539242"}, {"introduction": "后验误差指示子的最终目标是引导自适应网格细化，使模拟能够自动将计算资源集中在最需要的地方。本练习 [@problem_id:2539292] 将从计算过渡到实现，要求您从头开始构建一个完整的自适应有限元方法（AFEM）循环。通过编写“求解-估计-标记-细化”这一循环的代码，您将亲眼见证基于残差的指示子如何有效地检测解的特征（例如由材料界面引起的奇异性），并驱动网格进行自适应，从而实现更高的精度和效率。", "problem": "考虑在开区间 $\\Omega = (0,1)$ 上的含两种材料的一维标量扩散问题：求 $u:\\overline{\\Omega}\\to\\mathbb{R}$，其满足齐次狄利克雷边界条件 $u(0)=0$ 和 $u(1)=0$，并且\n$$\n-\\frac{d}{dx}\\left( k(x)\\,\\frac{du}{dx}(x) \\right) = f(x)\\quad\\text{对于 }x\\in(0,1),\n$$\n其中标量扩散系数 $k(x)$ 是分段常数，在材料界面 $x_{\\star} = 0.5$ 处有单次跳跃，即当 $x  x_{\\star}$ 时，$k(x)=k_1$；当 $x \\ge x_{\\star}$ 时，$k(x)=k_2$。源项是常数 $f(x)=c$。该问题的弱形式是找到 $u\\in H_0^1(\\Omega)$，使得对于所有 $v\\in H_0^1(\\Omega)$，$\\int_0^1 k(x) u'(x) v'(x) dx = \\int_0^1 f(x) v(x) dx$。\n\n你的任务是实现一个基于 Python 的自适应有限元方法（AFEM）求解器，该求解器使用连续分段线性有限元，并由基于残差的后验误差指示器驱动。指示器由单元体残差和通量跳跃残差构成。在单元 $T_i$ 上的局部指示器 $\\eta_{T_i}^2$ 由下式给出：\n$$ \\eta_{T_i}^2 = h_i^2 \\|c\\|_{L^2(T_i)}^2 + \\frac{1}{2}h_i |J_{i-1}|^2 + \\frac{1}{2}h_i |J_i|^2 $$\n其中 $h_i$ 是单元 $T_i$ 的长度，$J_i = [k_h u_h']_{x_i}$ 是内部节点 $x_i$ 处的离散通量跳跃。\n\nAFEM 循环应按如下方式进行：\n1.  **求解 (SOLVE)**：在当前网格上计算 $u_h$。\n2.  **估计 (ESTIMATE)**：计算每个单元的 $\\eta_{T_i}^2$。\n3.  **标记 (MARK)**：使用 Dörfler 标记（体标记法），选择一个最小的单元集合 $\\mathcal{M}$，使得 $\\sum_{T \\in \\mathcal{M}} \\eta_T^2 \\ge \\theta \\sum_{\\text{all } T} \\eta_T^2$，其中 $\\theta \\in (0,1)$ 是一个给定的参数。\n4.  **细化 (REFINE)**：通过二等分每个被标记的单元来创建新网格。\n\n针对下面给出的每个测试用例，从指定的初始网格开始，运行 AFEM 算法 $L$ 次迭代。在第 $L$ 次迭代之后，确定在标记阶段选择的单元集 $\\mathcal{M}_L$ 中，有多少比例的单元与材料界面 $x_{\\star}=0.5$ 的邻域 $[x_{\\star}-\\delta, x_{\\star}+\\delta]$ 相交。如果这个比例大于或等于阈值 $\\alpha$，则测试通过（True）。\n\n你的代码应产生一个包含每个测试用例结果（True 或 False）的 Python 列表。\n\n**测试用例：**\n1. `(k1, k2)=(1,10), c=1, L=5, theta=0.5, delta=0.1, alpha=0.6`, 初始网格节点: `[0, 1/3, 2/3, 1]`\n2. `(k1, k2)=(1,1000), c=1, L=4, theta=0.5, delta=0.08, alpha=0.6`, 初始网格节点: `[0, 1/3, 2/3, 1]`\n3. `(k1, k2)=(1,1), c=1, L=4, theta=0.5, delta=0.08, alpha=0.6`, 初始网格节点: `[0, 1/3, 2/3, 1]`\n4. `(k1, k2)=(0.01,1), c=1, L=5, theta=0.5, delta=0.08, alpha=0.6`, 初始网格节点: `[0, 0.5, 1]`", "solution": "所提出的问题是偏微分方程数值分析领域中一个明确定义的任务，具体涉及一维扩散问题的自适应有限元方法（FEM）。\n\n问题验证如下：\n- **已知条件**：所有必要的组成部分均已提供：控制微分方程 $-\\frac{d}{dx}(k(x) \\frac{du}{dx}) = f(x)$、域 $\\Omega=(0,1)$、齐次狄利克雷边界条件、在 $x_{\\star}=0.5$ 处有跳跃的分段常数扩散系数 $k(x)$、常数源项 $f(x)=c$、弱形式，以及构建基于残差的后验误差指示器的核心原则。自适应策略，包括Dörfler标记和二等分细化，也已明确指定。测试套件提供了所有必要的参数 $(k_1, k_2, c, L, \\theta, \\delta, \\alpha)$ 和初始网格配置。\n- **验证结论**：该问题是**有效的**。它在科学上是合理的，基于已建立的有限元方法（FEM）和后验误差估计理论。它是适定的、客观的、完整的并且计算上是可行的。该任务要求从第一性原理推导并实现一个特定算法，这是科学计算中的一个标准且非平凡的练习。\n\n解决方案的步骤是首先形式化后验误差指示器，然后概述自适应算法，最后实现它以解决给定的测试用例。\n\n### 数学公式\n\n**1. 有限元离散化**\n我们在 $\\Omega=(0,1)$ 的网格 $\\mathcal{T}_h = \\{T_i\\}$ 上使用连续分段线性有限元，其中每个单元 $T_i$ 是一个闭区间 $[x_{i-1}, x_i]$。在由 $x=0$ 和 $x=1$ 处为零的连续分段线性函数构成的空间 $V_h \\subset H_0^1(\\Omega)$ 中寻求有限元解 $u_h$。伽辽金公式为：求 $u_h \\in V_h$，使得对于所有 $v_h \\in V_h$：\n$$\na(u_h, v_h) := \\int_0^1 k(x) u_h'(x) v_h'(x) dx = \\int_0^1 f(x) v_h(x) dx\n$$\n这会导出一个线性方程组 $AU=b$，其中 $U$ 是 $u_h$ 在内部节点处的节点值向量。\n\n对于一个长度为 $h_i = x_i - x_{i-1}$ 的单元 $T_i = [x_{i-1}, x_i]$，计算其单元刚度矩阵和载荷向量。系数 $k(x)$ 在网格上被近似为分段常数函数 $k_h$，其中 $k_h|_{T_i} = k((x_{i-1}+x_i)/2)$。当 $f(x)=c$ 时，可得：\n$$\nA^{(i)} = \\frac{k_h|_{T_i}}{h_i} \\begin{pmatrix} 1  -1 \\\\ -1  1 \\end{pmatrix}, \\quad b^{(i)} = \\frac{c h_i}{2} \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix}\n$$\n\n**2. 基于残差的后验误差指示器**\n误差 $e=u-u_h$ 满足从弱残差导出的后验误差关系。对于任何 $v \\in H_0^1(\\Omega)$：\n$$\na(e,v) = \\int_0^1 f v dx - \\int_0^1 k u_h' v' dx = \\sum_{T \\in \\mathcal{T}_h} \\left( \\int_T f v dx - \\int_T k u_h' v' dx \\right)\n$$\n按单元进行分部积分并重新整理各项，可得到用单元残差和通量跳跃表示的误差。误差的能量范数平方由局部误差指示器 $\\eta_T^2$ 的平方和所界定。与问题原则一致的、在单元 $T_i=[x_{i-1}, x_i]$ 上的局部指示器的一个标准形式由一个体项和边（跳跃）项组成：\n$$\n\\eta_{T_i}^2 = h_i^2 \\| f + (k_h u_h')' \\|_{L^2(T_i)}^2 + \\frac{1}{2}h_i |J_{i-1}|^2 + \\frac{1}{2}h_i |J_{i}|^2\n$$\n此处，由于 $u_h$ 是线性的且 $k_h$ 在 $T_i$ 上是常数，强残差 $(k_h u_h')'$ 为零。内部节点 $x_i$ 处的跳跃 $J_i$ 是离散通量的跳跃：\n$$\nJ_i = [k_h u_h']_{x_i} = (k_h u_h')|_{T_{i+1}} - (k_h u_h')|_{T_i}\n$$\n对于边界节点，跳跃为零。当 $f(x)=c$ 时，指示器简化为：\n$$\n\\eta_{T_i}^2 = h_i^2 \\int_{x_{i-1}}^{x_i} c^2 dx + \\frac{1}{2}h_i (J_{i-1}^2 + J_i^2) = c^2 h_i^3 + \\frac{1}{2}h_i (J_{i-1}^2 + J_i^2)\n$$\n此形式具有适当的尺度，并用于指导网格细化。\n\n### 自适应算法\n\n自适应循环按预定迭代次数 $L$ 进行。在每次迭代中：\n1.  **求解**：给定当前网格（一个排序的节点数组），组装全局刚度矩阵 $A$ 和载荷向量 $b$。通过将系统简化为内部节点来施加齐次狄利克雷边界条件。求解线性系统以获得有限元解 $u_h$ 的节点值 $U$。\n2.  **估计**：使用上面推导的公式，计算网格中所有单元 $T_i$ 的单元误差指示器 $\\eta_{T_i}^2$。这需要计算每个单元上的导数 $u_h'$，然后计算每个内部节点处的通量跳跃 $J_i$。\n3.  **标记**：采用Dörfler标记策略。计算指示器总和 $\\mathcal{E}^2 = \\sum_i \\eta_{T_i}^2$。按指示器值降序对单元进行排序。标记一个最小的单元集合 $\\mathcal{M}$，使得 $\\sum_{T \\in \\mathcal{M}} \\eta_T^2 \\ge \\theta \\mathcal{E}^2$。\n4.  **细化**：通过二等分每个被标记的单元来生成新网格。新的节点集由现有节点集加上所有被标记单元的中点构成。\n\n经过 $L$ 次迭代后，对最后一步中标记的单元集 $\\mathcal{M}_L$ 进行分析。我们计算 $\\mathcal{M}_L$ 中与材料界面邻域 $[x_{\\star}-\\delta, x_{\\star}+\\delta]$ 相交的单元所占的比例。如果一个单元 $[x_{i-1}, x_i]$ 满足 $x_i  x_{\\star}-\\delta$ 且 $x_{i-1}  x_{\\star}+\\delta$，则它与该邻域相交。如果此比例大于或等于阈值 $\\alpha$，则认为细化集中在界面处。\n\n此过程构成了一个解决问题并评估测试用例的完整算法。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport scipy.linalg\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for the adaptive finite element problem.\n    \"\"\"\n    test_cases = [\n        # Test 1: (k1, k2)=(1,10), c=1, L=5, theta=0.5, delta=0.1, alpha=0.6\n        (1, 10, 1, 5, 0.5, 0.1, 0.6, [0, 1/3, 2/3, 1]),\n        # Test 2: (k1, k2)=(1,1000), c=1, L=4, theta=0.5, delta=0.08, alpha=0.6\n        (1, 1000, 1, 4, 0.5, 0.08, 0.6, [0, 1/3, 2/3, 1]),\n        # Test 3: (k1, k2)=(1,1), c=1, L=4, theta=0.5, delta=0.08, alpha=0.6\n        (1, 1, 1, 4, 0.5, 0.08, 0.6, [0, 1/3, 2/3, 1]),\n        # Test 4: (k1, k2)=(0.01,1), c=1, L=5, theta=0.5, delta=0.08, alpha=0.6\n        (0.01, 1, 1, 5, 0.5, 0.08, 0.6, [0, 0.5, 1]),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_adaptive_fem(*case)\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\n\ndef run_adaptive_fem(k1, k2, c, L, theta, delta, alpha, initial_nodes):\n    \"\"\"\n    Executes the adaptive FEM for a single test case.\n    \"\"\"\n    x_star = 0.5\n\n    def k_func(x):\n        # Per problem, k(x) jumps at x_star.\n        # k(x) = k1 for x  x_star, k2 for x >= x_star.\n        if np.isscalar(x):\n            return k1 if x  x_star else k2\n        return np.where(x  x_star, k1, k2)\n\n    nodes = np.array(initial_nodes)\n    marked_indices = []\n    nodes_on_which_marking_was_done = nodes\n\n    for iter_num in range(L):\n        if iter_num == L - 1:\n            nodes_on_which_marking_was_done = np.copy(nodes)\n        \n        num_nodes = len(nodes)\n        num_elements = num_nodes - 1\n        h = np.diff(nodes)\n        \n        num_unknowns = num_nodes - 2\n        if num_unknowns = 0:\n            marked_indices = list(range(num_elements))\n            new_nodes_set = set(nodes)\n            for idx in marked_indices:\n                new_node = (nodes[idx] + nodes[idx+1]) / 2.0\n                new_nodes_set.add(new_node)\n            nodes = np.array(sorted(list(new_nodes_set)))\n            continue\n\n        A = np.zeros((num_unknowns, num_unknowns))\n        b = np.zeros(num_unknowns)\n        \n        element_midpoints = nodes[:-1] + h / 2.0\n        k_h = k_func(element_midpoints)\n\n        diag = k_h[:-1] / h[:-1] + k_h[1:] / h[1:]\n        np.fill_diagonal(A, diag)\n        \n        off_diag = -k_h[1:-1] / h[1:-1]\n        np.fill_diagonal(A[1:], off_diag)\n        np.fill_diagonal(A[:, 1:], off_diag)\n        \n        b[:] = c * (h[:-1] + h[1:]) / 2.0\n\n        try:\n            U_interior = scipy.linalg.solve(A, b, assume_a='sym')\n        except np.linalg.LinAlgError:\n            U_interior = np.zeros(num_unknowns)\n\n        U = np.concatenate(([0.0], U_interior, [0.0]))\n        u_h_deriv = np.diff(U) / h\n        flux = k_h * u_h_deriv\n        jumps = flux[1:] - flux[:-1]\n        full_jumps = np.concatenate(([0.0], jumps, [0.0]))\n\n        indicators_sq = np.zeros(num_elements)\n        for i in range(num_elements):\n            h_i = h[i]\n            J_left_sq = full_jumps[i]**2\n            J_right_sq = full_jumps[i+1]**2\n            \n            bulk_term = (c**2) * (h_i**3)\n            jump_term = 0.5 * h_i * (J_left_sq + J_right_sq)\n            indicators_sq[i] = bulk_term + jump_term\n            \n        marked_indices = []\n        total_indicator_sq_sum = np.sum(indicators_sq)\n        if total_indicator_sq_sum > 1e-18:\n            sorted_indices = np.argsort(indicators_sq)[::-1]\n            cumulative_sum = 0.0\n            for idx in sorted_indices:\n                marked_indices.append(idx)\n                cumulative_sum += indicators_sq[idx]\n                if cumulative_sum >= theta * total_indicator_sq_sum:\n                    break\n        \n        if not marked_indices:\n            break \n            \n        new_nodes_set = set(nodes)\n        for idx in marked_indices:\n            new_node = (nodes[idx] + nodes[idx+1]) / 2.0\n            new_nodes_set.add(new_node)\n        nodes = np.array(sorted(list(new_nodes_set)))\n\n    if not marked_indices:\n        return False\n        \n    num_marked = len(marked_indices)\n    num_intersecting = 0\n    neighborhood_min = x_star - delta\n    neighborhood_max = x_star + delta\n    \n    for idx in marked_indices:\n        elem_left = nodes_on_which_marking_was_done[idx]\n        elem_right = nodes_on_which_marking_was_done[idx+1]\n        \n        if elem_right > neighborhood_min and elem_left  neighborhood_max:\n            num_intersecting += 1\n            \n    fraction = num_intersecting / num_marked if num_marked > 0 else 0.0\n    \n    return fraction >= alpha\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2539292"}]}