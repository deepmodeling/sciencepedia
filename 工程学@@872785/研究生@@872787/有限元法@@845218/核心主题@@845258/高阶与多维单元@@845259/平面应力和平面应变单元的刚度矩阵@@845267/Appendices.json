{"hands_on_practices": [{"introduction": "在计算任何单元的刚度矩阵之前，我们必须首先确保其几何形状是有效的。对于等参单元，这一步通过检查雅可比行列式 $\\det J$ 的符号来完成，它将“父”单元的自然坐标系映射到物理坐标系。这项实践练习将引导您计算一个四边形单元在数值积分点上的雅可比行列式，这是一个核心的计算技能，可以帮助您识别由于网格扭曲导致的单元“翻转”（即 $\\det J < 0$），这在实际的有限元分析中是必须避免的。[@problem_id:2554541]", "problem": "在有限元法 (FEM) 中，计算平面应力或平面应变下二维线性弹性分析的单元刚度矩阵的背景下，考虑一个 $4$ 节点等参四边形单元，其节点的标准自然（母）坐标分配如下：节点 $1 \\equiv (\\xi,\\eta)=(-1,-1)$，节点 $2 \\equiv (1,-1)$，节点 $3 \\equiv (1,1)$，节点 $4 \\equiv (-1,1)$。该单元节点的相应物理坐标（单位为米）为：\n- 节点 $1$：$(x_{1},y_{1})=(0,-1)$，\n- 节点 $2$：$(x_{2},y_{2})=(3.5,-1)$，\n- 节点 $3$：$(x_{3},y_{3})=(-1.5,1)$，\n- 节点 $4$：$(x_{4},y_{4})=(0,1)$。\n\n仅从双线性等参映射 $x(\\xi,\\eta)=\\sum_{i=1}^{4}N_{i}(\\xi,\\eta)\\,x_{i}$、$y(\\xi,\\eta)=\\sum_{i=1}^{4}N_{i}(\\xi,\\eta)\\,y_{i}$（使用标准双线性形函数 $N_{i}(\\xi,\\eta)$）以及行列式为 $\\det J(\\xi,\\eta)$ 的雅可比矩阵 $J(\\xi,\\eta)=\\begin{bmatrix}\\partial x/\\partial \\xi & \\partial x/\\partial \\eta \\\\ \\partial y/\\partial \\xi & \\partial y/\\partial \\eta \\end{bmatrix}$ 的定义出发，完成以下任务：\n\n- 在每个标准的 $2\\times 2$ 高斯点 $(\\xi,\\eta)\\in\\{(\\pm 1/\\sqrt{3},\\pm 1/\\sqrt{3})\\}$ 处推导 $\\det J$。\n- 使用这些值评估单元是否反转（即，是否存在至少一个高斯点使得 $\\det J < 0$）。\n- 作为最终数值结果，报告四个高斯点中 $\\det J$ 的最小值。\n\n将您报告的最终最小行列式值四舍五入到四位有效数字，并以平方米为单位表示。最终答案仅提供该单个实数。", "solution": "该问题陈述已经过严格验证，被认为是有效的。它在科学上基于连续介质力学和有限元法的原理，是适定的，提供了所有必要信息，并以客观、精确的语言表述。因此，我们可以着手求解。\n\n该问题要求计算一个给定的 $4$ 节点等参四边形单元在四个特定高斯求积点处的雅可比矩阵行列式 $\\det J$。从母单元坐标 $(\\xi, \\eta)$ 到物理坐标 $(x, y)$ 的映射由等参公式给出：\n$$\nx(\\xi,\\eta)=\\sum_{i=1}^{4}N_{i}(\\xi,\\eta)\\,x_{i}\n$$\n$$\ny(\\xi,\\eta)=\\sum_{i=1}^{4}N_{i}(\\xi,\\eta)\\,y_{i}\n$$\n其中 $(x_i, y_i)$ 是节点 $i$ 的物理坐标，$N_i(\\xi, \\eta)$ 是双线性形函数。对于标准的 $4$ 节点四边形，它们是：\n$$\nN_{1}(\\xi,\\eta) = \\frac{1}{4}(1-\\xi)(1-\\eta)\n$$\n$$\nN_{2}(\\xi,\\eta) = \\frac{1}{4}(1+\\xi)(1-\\eta)\n$$\n$$\nN_{3}(\\xi,\\eta) = \\frac{1}{4}(1+\\xi)(1+\\eta)\n$$\n$$\nN_{4}(\\xi,\\eta) = \\frac{1}{4}(1-\\xi)(1+\\eta)\n$$\n问题中对雅可比矩阵 $J$ 的定义 $J(\\xi,\\eta)=\\begin{bmatrix} \\partial x/\\partial \\xi & \\partial x/\\partial \\eta \\\\ \\partial y/\\partial \\xi & \\partial y/\\partial \\eta \\end{bmatrix}$ 是标准的，我们将遵循该定义进行计算。$J$ 的分量通过对映射方程求导得到：\n$$\n\\frac{\\partial x}{\\partial \\xi} = \\sum_{i=1}^{4}\\frac{\\partial N_{i}}{\\partial \\xi}x_{i}, \\quad \\frac{\\partial x}{\\partial \\eta} = \\sum_{i=1}^{4}\\frac{\\partial N_{i}}{\\partial \\eta}x_{i}\n$$\n$$\n\\frac{\\partial y}{\\partial \\xi} = \\sum_{i=1}^{4}\\frac{\\partial N_{i}}{\\partial \\xi}y_{i}, \\quad \\frac{\\partial y}{\\partial \\eta} = \\sum_{i=1}^{4}\\frac{\\partial N_{i}}{\\partial \\eta}y_{i}\n$$\n形函数的偏导数是：\n$$\n\\frac{\\partial N_{1}}{\\partial \\xi} = -\\frac{1}{4}(1-\\eta), \\quad \\frac{\\partial N_{2}}{\\partial \\xi} = \\frac{1}{4}(1-\\eta), \\quad \\frac{\\partial N_{3}}{\\partial \\xi} = \\frac{1}{4}(1+\\eta), \\quad \\frac{\\partial N_{4}}{\\partial \\xi} = -\\frac{1}{4}(1+\\eta)\n$$\n$$\n\\frac{\\partial N_{1}}{\\partial \\eta} = -\\frac{1}{4}(1-\\xi), \\quad \\frac{\\partial N_{2}}{\\partial \\eta} = -\\frac{1}{4}(1+\\xi), \\quad \\frac{\\partial N_{3}}{\\partial \\eta} = \\frac{1}{4}(1+\\xi), \\quad \\frac{\\partial N_{4}}{\\partial \\eta} = \\frac{1}{4}(1-\\xi)\n$$\n节点坐标给出为：$(x_1, y_1)=(0, -1)$，$(x_2, y_2)=(3.5, -1)$，$(x_3, y_3)=(-1.5, 1)$ 和 $(x_4, y_4)=(0, 1)$。我们将这些值代入雅可比分量的表达式中。\n\n对于 $J_{11} = \\partial x/\\partial \\xi$：\n$$\n\\frac{\\partial x}{\\partial \\xi} = \\frac{1}{4}[-x_1(1-\\eta) + x_2(1-\\eta) + x_3(1+\\eta) - x_4(1+\\eta)]\n$$\n$$\n\\frac{\\partial x}{\\partial \\xi} = \\frac{1}{4}[-(0)(1-\\eta) + (3.5)(1-\\eta) + (-1.5)(1+\\eta) - (0)(1+\\eta)] = \\frac{1}{4}[3.5 - 3.5\\eta - 1.5 - 1.5\\eta] = \\frac{1}{4}(2 - 5\\eta)\n$$\n对于 $J_{12} = \\partial x/\\partial \\eta$：\n$$\n\\frac{\\partial x}{\\partial \\eta} = \\frac{1}{4}[-x_1(1-\\xi) - x_2(1+\\xi) + x_3(1+\\xi) + x_4(1-\\xi)]\n$$\n$$\n\\frac{\\partial x}{\\partial \\eta} = \\frac{1}{4}[-(0)(1-\\xi) - (3.5)(1+\\xi) + (-1.5)(1+\\xi) + (0)(1-\\xi)] = \\frac{1}{4}[-3.5 - 3.5\\xi - 1.5 - 1.5\\xi] = \\frac{1}{4}(-5 - 5\\xi) = -\\frac{5}{4}(1+\\xi)\n$$\n对于 $J_{21} = \\partial y/\\partial \\xi$：\n$$\n\\frac{\\partial y}{\\partial \\xi} = \\frac{1}{4}[-y_1(1-\\eta) + y_2(1-\\eta) + y_3(1+\\eta) - y_4(1+\\eta)]\n$$\n$$\n\\frac{\\partial y}{\\partial \\xi} = \\frac{1}{4}[-(-1)(1-\\eta) + (-1)(1-\\eta) + (1)(1+\\eta) - (1)(1+\\eta)] = \\frac{1}{4}[ (1-\\eta) - (1-\\eta) + (1+\\eta) - (1+\\eta) ] = 0\n$$\n对于 $J_{22} = \\partial y/\\partial \\eta$：\n$$\n\\frac{\\partial y}{\\partial \\eta} = \\frac{1}{4}[-y_1(1-\\xi) - y_2(1+\\xi) + y_3(1+\\xi) + y_4(1-\\xi)]\n$$\n$$\n\\frac{\\partial y}{\\partial \\eta} = \\frac{1}{4}[-(-1)(1-\\xi) - (-1)(1+\\xi) + (1)(1+\\xi) + (1)(1-\\xi)] = \\frac{1}{4}[1-\\xi + 1+\\xi + 1+\\xi + 1-\\xi] = \\frac{4}{4} = 1\n$$\n因此，雅可比矩阵为：\n$$\nJ(\\xi,\\eta) = \\begin{bmatrix} \\frac{1}{4}(2 - 5\\eta) & -\\frac{5}{4}(1+\\xi) \\\\ 0 & 1 \\end{bmatrix}\n$$\n雅可比矩阵的行列式为：\n$$\n\\det J(\\xi,\\eta) = \\left(\\frac{1}{4}(2 - 5\\eta)\\right)(1) - \\left(-\\frac{5}{4}(1+\\xi)\\right)(0) = \\frac{1}{4}(2 - 5\\eta)\n$$\n我们必须在四个标准的 $2 \\times 2$ 高斯点处计算 $\\det J$，这些点是 $(\\xi_i, \\eta_j)$，其中 $\\xi_i, \\eta_j \\in \\{-1/\\sqrt{3}, 1/\\sqrt{3}\\}$。令 $a = 1/\\sqrt{3}$。这四个点是 $(-a, -a)$、$(a, -a)$、$(a, a)$ 和 $(-a, a)$。注意，$\\det J$ 仅依赖于 $\\eta$。\n\n1. 对于 $\\eta = -1/\\sqrt{3}$ 的两个高斯点：\n   $$\n   \\det J = \\frac{1}{4}\\left(2 - 5\\left(-\\frac{1}{\\sqrt{3}}\\right)\\right) = \\frac{1}{4}\\left(2 + \\frac{5}{\\sqrt{3}}\\right)\n   $$\n   数值上，$\\det J = \\frac{1}{4}(2 + 2.88675...) = \\frac{4.88675...}{4} = 1.22168...\n   $$\n\n2. 对于 $\\eta = 1/\\sqrt{3}$ 的两个高斯点：\n   $$\n   \\det J = \\frac{1}{4}\\left(2 - 5\\left(\\frac{1}{\\sqrt{3}}\\right)\\right) = \\frac{1}{4}\\left(2 - \\frac{5}{\\sqrt{3}}\\right)\n   $$\n   数值上，$\\det J = \\frac{1}{4}(2 - 2.88675...) = \\frac{-0.88675...}{4} = -0.22168...\n   $$\n\n在高斯点处的四个行列式值为 $\\{1.22168..., 1.22168..., -0.22168..., -0.22168...\\}$。\n存在至少一个 $\\det J  0$ 的高斯点表明单元映射是反转的。在这种情况下，四个高斯点中有两个表现出负的雅可比行列式。这样的单元在几何上是无效的，并会导致有限元分析失败。\n\n四个高斯点中 $\\det J$ 的最小值是那个负值。\n$$\n\\min(\\det J) = -0.22168...\n$$\n问题指定节点坐标的单位是米，因此雅可比行列式的单位是平方米。最终结果必须四舍五入到四位有效数字。\n$$\n\\min(\\det J) \\approx -0.2217\n$$", "answer": "$$ \\boxed{-0.2217} $$", "id": "2554541"}, {"introduction": "确认了单元的几何有效性后，下一步是组装单元刚度矩阵 $\\boldsymbol{K}_e$ 并分析其基本特性。一项关键的验证步骤是对 $\\boldsymbol{K}_e$ 进行特征分析，以识别其零能模式。通过这项编程实践，您将学会区分物理上必须存在的刚体运动模式和由于不恰当的数值积分（例如减缩积分）而产生的伪零能模式（即“沙漏模式”），后者会导致单元在数值上不稳定。[@problem_id:2554569]", "problem": "构建一个程序，从虚功原理和等参插值的定义出发，组装单元刚度矩阵并执行特征分析，以识别二维弹性问题中的刚体模态和任何伪零能机制。具体来说，考虑在平面应力和平面应变假设下的常应变三角形 (CST) 和四节点四边形 (Q4) 单元。从单元刚度矩阵由双线性形式给出的基本恒等式出发\n$$\n\\mathbf{K}_e \\;=\\; \\int_{\\Omega_e} \\mathbf{B}^\\mathsf{T} \\, \\mathbf{D} \\, \\mathbf{B} \\; t \\; \\mathrm{d}\\Omega,\n$$\n其中 $t$ 是厚度，$\\mathbf{D}$ 是对应于平面应力或平面应变的各向同性弹性矩阵，$\\mathbf{B}$ 是从插值函数的空间导数获得的应变-位移矩阵，实现以下内容：\n- 对于常应变三角形 (CST)：在单元域上为常数的 $\\mathbf{B}$ 矩阵，并采用精确的面积积分。\n- 对于四节点四边形 (Q4)：采用等参双线性插值和数值积分。使用 $2 \\times 2$ Gauss 法则进行完全积分，使用 $1 \\times 1$ Gauss 法则（单个中心点）进行减缩积分。\n\n对每个单元刚度矩阵 $\\mathbf{K}_e$ 进行特征分析，并计算数值上为零的特征值的数量，这被解释为零能模态的数量。根据力学理论，二维空间中应恰好存在三个刚体模态（两个平移和一个平面内旋转）。任何额外的数值零特征值都表示存在伪机制。\n\n您的程序必须使用标准线性弹性理论实现平面应力和平面应变的各向同性弹性矩阵 $\\mathbf{D}$：\n- 平面应力：\n$$\n\\mathbf{D}_{\\text{ps}} \\;=\\; \\frac{E}{1-\\nu^2}\\begin{bmatrix}\n1  \\nu  0\\\\\n\\nu  1  0\\\\\n0  0  \\frac{1-\\nu}{2}\n\\end{bmatrix},\n$$\n- 平面应变：\n$$\n\\mathbf{D}_{\\text{pe}} \\;=\\; \\frac{E}{(1+\\nu)(1-2\\nu)}\\begin{bmatrix}\n1-\\nu  \\nu  0\\\\\n\\nu  1-\\nu  0\\\\\n0  0  \\frac{1-2\\nu}{2}\n\\end{bmatrix}.\n$$\n\n对于 Q4 单元，在局部坐标为 $(\\xi,\\eta)\\in[-1,1]\\times[-1,1]$ 的母单元域上使用标准的双线性等参形函数，计算积分点处的雅可比矩阵 $\\mathbf{J}$ 及其行列式，并通过 $\\mathbf{J}^{-1}$ 将导数转换到物理坐标系。对于完全积分，使用位于 $(\\pm 1/\\sqrt{3}, \\pm 1/\\sqrt{3})$ 的四个 Gauss 点，每个点的权重为 $1$；对于减缩积分，使用单个点 $(0,0)$，总权重为 $4$。\n\n通过将每个特征值的绝对值与一个和该情况下的最大特征值幅度成比例的容差进行比较，来数值地检测零特征值的数量。在谱半径上使用 $10^{-8}$ 的相对容差，并带有一个小的绝对下限，以使最终计数为整数。\n\n测试套件。您的程序必须按顺序运行以下五个测试用例，并为每个用例返回近似为零的特征值的数量：\n\n1. CST，平面应力。节点位于 $(x_1,y_1)=(0,0)$、$(x_2,y_2)=(1,0)$、$(x_3,y_3)=(0,1)$，厚度 $t=0.05\\,\\mathrm{m}$，Young模量 $E=210\\times 10^9\\,\\mathrm{Pa}$，Poisson比 $\\nu=0.29$。\n\n2. Q4，平面应力，完全积分。节点位于 $(x_1,y_1)=(0,0)$、$(x_2,y_2)=(1,0)$、$(x_3,y_3)=(1,1)$、$(x_4,y_4)=(0,1)$，厚度 $t=0.05\\,\\mathrm{m}$，Young模量 $E=210\\times 10^9\\,\\mathrm{Pa}$，Poisson比 $\\nu=0.29$。\n\n3. Q4，平面应力，减缩积分。几何形状和材料与案例2相同，但在 $(\\xi,\\eta)=(0,0)$ 处使用 $1\\times 1$ Gauss 法则。\n\n4. Q4，平面应力，在一个扭曲单元上进行减缩积分。节点位于 $(x_1,y_1)=(0,0)$、$(x_2,y_2)=(2,0.2)$、$(x_3,y_3)=(2.2,1.8)$、$(x_4,y_4)=(0,1)$，厚度 $t=0.1\\,\\mathrm{m}$，Young模量 $E=70\\times 10^9\\,\\mathrm{Pa}$，Poisson比 $\\nu=0.25$。\n\n5. Q4，平面应变，完全积分。节点位于 $(x_1,y_1)=(0,0)$、$(x_2,y_2)=(2,0)$、$(x_3,y_3)=(2,1)$、$(x_4,y_4)=(0,1)$，厚度 $t=0.1\\,\\mathrm{m}$，Young模量 $E=1\\times 10^6\\,\\mathrm{Pa}$，Poisson比 $\\nu=0.49$。\n\n对于每个案例，计算单元刚度矩阵的近似零特征值的整数数量。您的程序的最终输出必须是单行文本，其中包含一个 Python 风格的列表，列表内有五个整数，顺序与测试套件案例相同，且不带单位（整数是无单位的）。您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，$[3,3,5,5,3]$）。", "solution": "该问题定义明确，并基于计算固体力学的既定原理。它要求实现和分析有限元方法中的基本单元类型。我们将继续进行推导和求解。\n\n单元刚度矩阵 $\\mathbf{K}_e$ 的基础是虚功原理，该原理将内虚功与外虚功等同起来。对于线性弹性连续体，这引出了势能的表达式，其平稳性条件产生平衡方程。单元刚度矩阵源于应变能项，由应变能密度的体积分给出。对于厚度均匀为 $t$ 的单元 $\\Omega_e$，其表达式为：\n$$\n\\mathbf{K}_e = \\int_{\\Omega_e} \\mathbf{B}^\\mathsf{T} \\mathbf{D} \\mathbf{B} \\, t \\, \\mathrm{d}\\Omega\n$$\n此处，$\\mathbf{B}$ 是应变-位移矩阵，它将工程应变向量 $\\boldsymbol{\\epsilon} = [\\epsilon_x, \\epsilon_y, \\gamma_{xy}]^\\mathsf{T}$ 与节点位移向量 $\\mathbf{d}_e$ 联系起来。矩阵 $\\mathbf{D}$ 是材料本构矩阵，通过 $\\boldsymbol{\\sigma} = \\mathbf{D}\\boldsymbol{\\epsilon}$ 将应力 $\\boldsymbol{\\sigma}$ 与应变 $\\boldsymbol{\\epsilon}$ 联系起来。\n\n单元内的位移场是使用形函数 $\\mathbf{N}$ 从节点位移 $\\mathbf{d}_e$ 插值得到的：\n$$\n\\mathbf{u}(x,y) = \\mathbf{N}(x,y) \\mathbf{d}_e\n$$\n通过将运动微分算子 $\\mathcal{L}$ 应用于位移场来获得应变：\n$$\n\\boldsymbol{\\epsilon} = \\mathcal{L} \\mathbf{u} = \\mathcal{L} (\\mathbf{N} \\mathbf{d}_e) = (\\mathcal{L} \\mathbf{N}) \\mathbf{d}_e\n$$\n由此，应变-位移矩阵被确定为 $\\mathbf{B} = \\mathcal{L}\\mathbf{N}$。对于二维问题，该算子为：\n$$\n\\mathcal{L} = \\begin{bmatrix} \\frac{\\partial}{\\partial x}  0 \\\\ 0  \\frac{\\partial}{\\partial y} \\\\ \\frac{\\partial}{\\partial y}  \\frac{\\partial}{\\partial x} \\end{bmatrix}\n$$\n\n材料行为由各向同性弹性矩阵 $\\mathbf{D}$ 描述。对于指定的二维状态：\n-   平面应力 ($\\sigma_z = 0$)：适用于薄结构。该矩阵为：\n    $$\n    \\mathbf{D}_{\\text{ps}} = \\frac{E}{1-\\nu^2}\\begin{bmatrix}\n    1  \\nu  0 \\\\\n    \\nu  1  0 \\\\\n    0  0  \\frac{1-\\nu}{2}\n    \\end{bmatrix}\n    $$\n-   平面应变 ($\\epsilon_z = 0$)：适用于面外变形受约束的厚结构。该矩阵为：\n    $$\n    \\mathbf{D}_{\\text{pe}} = \\frac{E}{(1+\\nu)(1-2\\nu)}\\begin{bmatrix}\n    1-\\nu  \\nu  0 \\\\\n    \\nu  1-\\nu  0 \\\\\n    0  0  \\frac{1-2\\nu}{2}\n    \\end{bmatrix}\n    $$\n其中 $E$ 是 Young模量，$\\nu$ 是 Poisson比。\n\n我们现在将为每种单元类型构建刚度矩阵。\n\n**常应变三角形 (CST) 单元**\n\nCST 是一个 3 节点三角形单元，每个节点有 2 个自由度 (DOF)，总共有 6 个自由度。位移场是线性插值的：\n$$\nu(x,y) = N_1 u_1 + N_2 u_2 + N_3 u_3 \\quad \\text{and} \\quad v(x,y) = N_1 v_1 + N_2 v_2 + N_3 v_3\n$$\n线性形函数 $N_i(x,y)$ 具有恒定的一阶导数。因此，应变分量 $\\epsilon_x = \\partial u/\\partial x$、$\\epsilon_y = \\partial v/\\partial y$ 和 $\\gamma_{xy} = \\partial u/\\partial y + \\partial v/\\partial x$ 在整个单元内是恒定的，这也是该单元名称的由来。应变-位移矩阵 $\\mathbf{B}$ 是一个恒定的 $3 \\times 6$ 矩阵。\n对于节点按逆时针顺序排列为 $(x_1, y_1)$、$(x_2, y_2)$ 和 $(x_3, y_3)$ 的三角形，$\\mathbf{B}$ 矩阵由下式给出：\n$$\n\\mathbf{B} = \\frac{1}{2A} \\begin{bmatrix}\ny_2 - y_3  0  y_3 - y_1  0  y_1 - y_2  0 \\\\\n0  x_3 - x_2  0  x_1 - x_3  0  x_2 - x_1 \\\\\nx_3 - x_2  y_2 - y_3  x_1 - x_3  y_3 - y_1  x_2 - x_1  y_1 - y_2\n\\end{bmatrix}\n$$\n其中 $A$ 是三角形的面积。由于 $\\mathbf{B}$、$\\mathbf{D}$ 和 $t$ 是常数，刚度矩阵积分简化为直接乘积：\n$$\n\\mathbf{K}_e = \\mathbf{B}^\\mathsf{T} \\mathbf{D} \\mathbf{B} \\, (A \\cdot t)\n$$\n\n**四节点四边形 (Q4) 单元**\n\nQ4 单元是一个 4 节点单元，总共有 8 个自由度。该公式是等参的，意味着使用相同的形函数来插值几何形状和位移场。我们使用一个由局部坐标 $(\\xi, \\eta) \\in [-1, 1] \\times [-1, 1]$ 定义的标准母单元域。双线性形函数为：\n$$\nN_i(\\xi, \\eta) = \\frac{1}{4}(1 + \\xi_i \\xi)(1 + \\eta_i \\eta)\n$$\n其中 $(\\xi_i, \\eta_i)$ 是母单元域中节点 $i$ 的坐标：对于节点 1、2、3、4，分别为 $(-1,-1)$、$(1,-1)$、$(1,1)$、$(-1,1)$。\n\n物理坐标 $(x,y)$ 是从母单元坐标映射而来的：\n$$\nx(\\xi, \\eta) = \\sum_{i=1}^{4} N_i(\\xi, \\eta) x_i \\quad \\text{and} \\quad y(\\xi, \\eta) = \\sum_{i=1}^{4} N_i(\\xi, \\eta) y_i\n$$\n应变-位移矩阵 $\\mathbf{B}$ 需要相对于物理坐标 $(x,y)$ 的导数，这些导数是通过链式法则，从相对于母单元坐标 $(\\xi, \\eta)$ 的导数获得，其中涉及雅可比矩阵 $\\mathbf{J}$：\n$$\n\\begin{Bmatrix} \\frac{\\partial}{\\partial x} \\\\ \\frac{\\partial}{\\partial y} \\end{Bmatrix} = \\mathbf{J}^{-1} \\begin{Bmatrix} \\frac{\\partial}{\\partial \\xi} \\\\ \\frac{\\partial}{\\partial \\eta} \\end{Bmatrix} \\quad \\text{where} \\quad \\mathbf{J} = \\begin{bmatrix} \\frac{\\partial x}{\\partial \\xi}  \\frac{\\partial y}{\\partial \\xi} \\\\ \\frac{\\partial x}{\\partial \\eta}  \\frac{\\partial y}{\\partial \\eta} \\end{bmatrix}\n$$\n现在 $\\mathbf{B}$ 矩阵是 $(\\xi, \\eta)$ 的函数。刚度矩阵积分被转换到母单元域：\n$$\n\\mathbf{K}_e = \\int_{-1}^{1} \\int_{-1}^{1} \\mathbf{B}(\\xi, \\eta)^\\mathsf{T} \\mathbf{D} \\mathbf{B}(\\xi, \\eta) \\, \\det(\\mathbf{J}) \\, t \\, \\mathrm{d}\\xi \\, \\mathrm{d}\\eta\n$$\n这个积分使用 Gauss 积分进行数值计算：\n$$\n\\mathbf{K}_e \\approx t \\sum_{i=1}^{n_p} \\sum_{j=1}^{n_p} w_i w_j \\left( \\mathbf{B}(\\xi_i, \\eta_j)^\\mathsf{T} \\mathbf{D} \\mathbf{B}(\\xi_i, \\eta_j) \\det(\\mathbf{J}(\\xi_i, \\eta_j)) \\right)\n$$\n其中 $(\\xi_i, \\eta_j)$ 是 Gauss 点，$w_i, w_j$ 是相应的权重。\n-   **完全积分：** 使用 $2 \\times 2$ 法则 ($n_p=2$)。积分点为 $(\\pm 1/\\sqrt{3}, \\pm 1/\\sqrt{3})$，所有权重均为 $1$。该法则能精确积分最高 3 次的多项式，这足以精确积分一个矩形 Q4 单元的刚度矩阵。\n-   **减缩积分：** 使用 $1 \\times 1$ 法则 ($n_p=1$)。单点位于中心 $(\\xi, \\eta) = (0,0)$，权重为 $w_1 \\cdot w_1 = 4$。此方法计算效率高，但可能引入伪零能模态，即所谓的沙漏。\n\n**刚度矩阵的特征分析**\n\n$\\mathbf{K}_e$ 的特征值表示其对应特征模态（变形形状）的能量代价。零特征值对应于零能模态，即一种不产生应变也因此不产生应力的变形。对于二维空间中任何无约束的单元，必须恰好有 3 个这样的模态：2 个刚体平移和 1 个平面内刚体旋转。这些是物理上正确的。\n\n任何额外的零能模态都是伪模态，是单元构造产生的非物理假象。它们被称为“沙漏模态”，表示单元可以在不储存任何应变能的情况下以某种模式变形，从而使其不稳定。任务是对每个计算出的 $\\mathbf{K}_e$ 进行特征分析，并计算数值上为零的特征值的数量。如果一个特征值 $\\lambda$ 的绝对值小于相对于谱半径（最大绝对特征值）$\\lambda_{\\text{max}}$ 的一个容差，则认为其为零：\n$$\n|\\lambda|  10^{-8} \\cdot \\lambda_{\\text{max}}\n$$\n这个计数揭示了每种单元配置的刚体模态数量加上任何伪机制的数量。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef get_D(E, nu, analysis_type):\n    \"\"\"\n    Computes the isotropic elasticity matrix D for plane stress or plane strain.\n    \"\"\"\n    if analysis_type == \"plane_stress\":\n        if abs(1.0 - nu**2)  1e-12:\n            raise ValueError(\"Invalid Poisson's ratio for plane stress: 1 - nu^2 is zero.\")\n        factor = E / (1.0 - nu**2)\n        D = factor * np.array([\n            [1.0, nu, 0.0],\n            [nu, 1.0, 0.0],\n            [0.0, 0.0, (1.0 - nu) / 2.0]\n        ])\n    elif analysis_type == \"plane_strain\":\n        denom = (1.0 + nu) * (1.0 - 2.0 * nu)\n        if abs(denom)  1e-12:\n            raise ValueError(\"Invalid Poisson's ratio for plane strain: (1+nu)(1-2*nu) is zero.\")\n        factor = E / denom\n        D = factor * np.array([\n            [1.0 - nu, nu, 0.0],\n            [nu, 1.0 - nu, 0.0],\n            [0.0, 0.0, (1.0 - 2.0 * nu) / 2.0]\n        ])\n    else:\n        raise ValueError(f\"Invalid analysis type: {analysis_type}\")\n    return D\n\ndef stiffness_cst(nodes, t, E, nu, analysis_type):\n    \"\"\"\n    Computes the stiffness matrix for a Constant Strain Triangle (CST) element.\n    \"\"\"\n    # Nodal coordinates\n    x1, y1 = nodes[0]\n    x2, y2 = nodes[1]\n    x3, y3 = nodes[2]\n\n    # Area of the triangle\n    A = 0.5 * np.linalg.det(np.array([[1.0, x1, y1], [1.0, x2, y2], [1.0, x3, y3]]))\n    if A = 1e-12:\n        raise ValueError(\"Degenerate or inverted triangle element.\")\n\n    # Components for the constant B matrix\n    b1 = y2 - y3\n    b2 = y3 - y1\n    b3 = y1 - y2\n    c1 = x3 - x2\n    c2 = x1 - x3\n    c3 = x2 - x1\n\n    # B matrix (strain-displacement matrix)\n    B = (1.0 / (2.0 * A)) * np.array([\n        [b1, 0.0, b2, 0.0, b3, 0.0],\n        [0.0, c1, 0.0, c2, 0.0, c3],\n        [c1, b1, c2, b2, c3, b3]\n    ])\n\n    D = get_D(E, nu, analysis_type)\n    \n    Ke = B.T @ D @ B * A * t\n    return Ke\n\ndef stiffness_q4(nodes, t, E, nu, analysis_type, integration_rule):\n    \"\"\"\n    Computes the stiffness matrix for a 4-node quadrilateral (Q4) element.\n    \"\"\"\n    D = get_D(E, nu, analysis_type)\n\n    if integration_rule == \"full\":  # 2x2\n        gauss_points_1d = [-1.0/np.sqrt(3.0), 1.0/np.sqrt(3.0)]\n        gauss_weights_1d = [1.0, 1.0]\n    elif integration_rule == \"reduced\":  # 1x1\n        gauss_points_1d = [0.0]\n        gauss_weights_1d = [2.0]\n    else:\n        raise ValueError(f\"Invalid integration rule: {integration_rule}\")\n\n    Ke = np.zeros((8, 8))\n\n    for xi in gauss_points_1d:\n        for eta in gauss_points_1d:\n            weight = gauss_weights_1d[gauss_points_1d.index(xi)] * \\\n                     gauss_weights_1d[gauss_points_1d.index(eta)]\n\n            # Derivatives of shape functions w.r.t. parent coordinates (xi, eta)\n            # N_derivs_parent[0, i] = dN_i/d_xi, N_derivs_parent[1, i] = dN_i/d_eta\n            N_derivs_parent = 0.25 * np.array([\n                [-(1.0 - eta), (1.0 - eta), (1.0 + eta), -(1.0 + eta)],\n                [-(1.0 - xi), -(1.0 + xi), (1.0 + xi), (1.0 - xi)]\n            ])\n\n            # Jacobian matrix\n            # Note: The Jacobian J here is the transpose of the standard definition in some texts.\n            # J_ij = dx_i / d_xi_j. Here it is J_ij = d_coord_i / d_xi_j\n            J = nodes.T @ N_derivs_parent.T\n            # The definition in the problem text is J_ij = d_xi_i/d_x_j so we use J.T\n            # Rechecking the problem: J = [dx/d_xi, dy/d_xi; dx/d_eta, dy/d_eta].\n            # This is non-standard. The standard is J = [dx/d_xi, dx/d_eta; dy/d_xi, dy/d_eta]\n            # My `nodes.T @ N_derivs_parent.T` calculation gives [ [dx/dxi, dy/dxi], [dx/deta, dy/deta] ]\n            # So I must transpose it to match the solution text's J\n            # J_calc = N_derivs_parent @ nodes has shape (2,2)\n            # J_calc[0,0] = dN/dxi . x = dx/dxi\n            # J_calc[0,1] = dN/dxi . y = dy/dxi\n            # J_calc[1,0] = dN/deta . x = dx/deta\n            # J_calc[1,1] = dN/deta . y = dy/deta\n            # This is what I have implemented in other problems. Let's use this.\n            J = N_derivs_parent @ nodes\n\n            detJ = np.linalg.det(J)\n            if detJ = 1e-12:\n                raise ValueError(\"Jacobian determinant is non-positive. Check element geometry or node ordering.\")\n\n            # Derivatives of shape functions w.r.t. physical coordinates (x, y)\n            J_inv = np.linalg.inv(J)\n            N_derivs_physical = J_inv @ N_derivs_parent\n\n            # B matrix assembly\n            B = np.zeros((3, 8))\n            for k in range(4):\n                dNdX_k = N_derivs_physical[0, k]\n                dNdY_k = N_derivs_physical[1, k]\n                B[0, 2*k]      = dNdX_k\n                B[1, 2*k + 1]  = dNdY_k\n                B[2, 2*k]      = dNdY_k\n                B[2, 2*k + 1]  = dNdX_k\n\n            Ke += B.T @ D @ B * detJ * weight * t\n            \n    return Ke\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        {'type': 'CST', 'nodes': np.array([[0,0],[1,0],[0,1]]), 't': 0.05, 'E': 210e9, 'nu': 0.29, 'analysis': 'plane_stress', 'integration': None},\n        {'type': 'Q4',  'nodes': np.array([[0,0],[1,0],[1,1],[0,1]]), 't': 0.05, 'E': 210e9, 'nu': 0.29, 'analysis': 'plane_stress', 'integration': 'full'},\n        {'type': 'Q4',  'nodes': np.array([[0,0],[1,0],[1,1],[0,1]]), 't': 0.05, 'E': 210e9, 'nu': 0.29, 'analysis': 'plane_stress', 'integration': 'reduced'},\n        {'type': 'Q4',  'nodes': np.array([[0,0],[2,0.2],[2.2,1.8],[0,1]]), 't': 0.1, 'E': 70e9, 'nu': 0.25, 'analysis': 'plane_stress', 'integration': 'reduced'},\n        {'type': 'Q4',  'nodes': np.array([[0,0],[2,0],[2,1],[0,1]]), 't': 0.1, 'E': 1e6, 'nu': 0.49, 'analysis': 'plane_strain', 'integration': 'full'},\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        if case['type'] == 'CST':\n            Ke = stiffness_cst(case['nodes'], case['t'], case['E'], case['nu'], case['analysis'])\n        elif case['type'] == 'Q4':\n            Ke = stiffness_q4(case['nodes'], case['t'], case['E'], case['nu'], case['analysis'], case['integration'])\n        else:\n            raise ValueError(f\"Unknown element type specified in test case: {case['type']}\")\n            \n        # Eigenanalysis\n        # Stiffness matrix is real and symmetric, so use eigvalsh for efficiency.\n        eigenvalues = np.linalg.eigvalsh(Ke)\n        \n        # Count near-zero eigenvalues based on relative tolerance\n        max_eig_abs = np.max(np.abs(eigenvalues))\n        \n        zero_eig_count = 0\n        if max_eig_abs  1e-9: # Safeguard for a nearly zero matrix\n            # If all eigenvalues are effectively zero, all are zero modes\n            zero_eig_count = len(eigenvalues)\n        else:\n            rel_tolerance = 1e-8 * max_eig_abs\n            zero_eig_count = np.sum(np.abs(eigenvalues)  rel_tolerance)\n            \n        results.append(int(zero_eig_count))\n        \n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == '__main__':\n    solve()\n```", "id": "2554569"}, {"introduction": "一个几何有效且数值稳定的单元还必须足够精确才能在分析中发挥作用。最后的这项实践将指导您通过将有限元解与已知的解析解进行比较，来量化评估不同类型单元（常应变三角形单元 CST 与双线性四边形单元 Q4）的近似误差。通过实施这个验证测试，您将对单元的插值阶次如何决定其精度和收敛性有一个具体的、实践性的理解。[@problem_id:2554580]", "problem": "编写一个程序，该程序使用两种标准的有限元插值方法——常应变三角形 (CST) 和双线性四边形 (Q4)——在平面应力和平面应变两种假设下，构建并比较二维线性弹性问题的单元级应力近似误差。该比较必须基于一个已知的二次位移场，以便能够解析地获得精确的应变场和应力场。\n\n任务要求完全基于以下原理和核心定义进行：\n- 运动学：小应变张量是位移的对称梯度。根据工程剪应变约定，面内应变向量为\n$$\n\\boldsymbol{\\varepsilon}(x,y) = \\begin{bmatrix}\\varepsilon_{xx}(x,y) \\\\ \\varepsilon_{yy}(x,y) \\\\ \\gamma_{xy}(x,y)\\end{bmatrix}\n= \\begin{bmatrix}\\dfrac{\\partial u_x}{\\partial x} \\\\ \\dfrac{\\partial u_y}{\\partial y} \\\\ \\dfrac{\\partial u_x}{\\partial y} + \\dfrac{\\partial u_y}{\\partial x}\\end{bmatrix}.\n$$\n- 本构关系：在线性弹性条件下，柯西应力向量为\n$$\n\\boldsymbol{\\sigma}(x,y) = \\mathbf{D} \\, \\boldsymbol{\\varepsilon}(x,y),\n$$\n其中，平面应力的本构矩阵为\n$$\n\\mathbf{D}_{\\mathrm{ps}} = \\frac{E}{1-\\nu^2}\n\\begin{bmatrix}\n1  \\nu  0 \\\\\n\\nu  1  0 \\\\\n0  0  \\dfrac{1-\\nu}{2}\n\\end{bmatrix},\n$$\n平面应变的本构矩阵为\n$$\n\\mathbf{D}_{\\mathrm{pe}} = \\frac{E}{(1+\\nu)(1-2\\nu)}\n\\begin{bmatrix}\n1-\\nu  \\nu  0 \\\\\n\\nu  1-\\nu  0 \\\\\n0  0  \\dfrac{1-2\\nu}{2}\n\\end{bmatrix}.\n$$\n- 插值：有限元位移场是通过形函数对节点位移进行插值来构建的。对于 CST，形函数在每个三角形上是线性的，产生分片常数应变。对于仿射、轴对齐的矩形网格上的 Q4，形函数在每个四边形上是双线性的，产生分片线性应变。\n\n使用单位正方形域 $[0,1]\\times[0,1]$，并由均匀的 $N\\times N$ 轴对齐正方形网格进行离散。对于 CST 近似，将每个正方形沿左下到右上的对角线分割成两个三角形。对于 Q4 近似，在每个正方形上使用双线性形函数。不要组装任何全局系统；而是对每个单元，通过在单元节点处对精确位移场进行采样来设置单元节点位移，使用单元的形函数在单元内部插值位移场，通过微分得到近似应变 $\\boldsymbol{\\varepsilon}^h$，然后计算近似应力 $\\boldsymbol{\\sigma}^h = \\mathbf{D}\\boldsymbol{\\varepsilon}^h$。\n\n采用精确位移场\n$$\nu_x(x,y) = a_1 x^2 + a_2 x y + a_3 y^2 + a_4 x + a_5 y + a_6,\\quad\nu_y(x,y) = b_1 x^2 + b_2 x y + b_3 y^2 + b_4 x + b_5 y + b_6,\n$$\n固定系数为\n$$\na_1=1,\\; a_2=\\tfrac{1}{2},\\; a_3=\\tfrac{1}{5},\\; a_4=\\tfrac{1}{10},\\; a_5=\\tfrac{1}{20},\\; a_6=\\tfrac{1}{100},\\\\\nb_1=-\\tfrac{3}{10},\\; b_2=\\tfrac{2}{5},\\; b_3=\\tfrac{9}{10},\\; b_4=\\tfrac{1}{5},\\; b_5=-\\tfrac{1}{10},\\; b_6=-\\tfrac{1}{50}.\n$$\n由此，通过微分计算精确应变 $\\boldsymbol{\\varepsilon}(x,y)$ 和精确应力 $\\boldsymbol{\\sigma}(x,y) = \\mathbf{D}\\boldsymbol{\\varepsilon}(x,y)$。\n\n对于误差测量，使用相对 $L^2$ 型应力误差范数\n$$\n\\eta = \\left(\\frac{\\int_{\\Omega} \\lVert \\boldsymbol{\\sigma}(x,y) - \\boldsymbol{\\sigma}^h(x,y) \\rVert_2^2 \\, \\mathrm{d}\\Omega}{\\int_{\\Omega} \\lVert \\boldsymbol{\\sigma}(x,y) \\rVert_2^2 \\, \\mathrm{d}\\Omega}\\right)^{1/2},\n$$\n该范数是无量纲的。通过在每个单元上使用精确或足够精确的高斯积分来数值近似这些积分：\n- 对于 CST 三角形，使用三角形上的 2 次精确积分法则（三个等权重的点）。\n- 对于矩形上的 Q4 四边形，在自然坐标中使用张量积 $2\\times 2$ 高斯积分。\n\n你的程序必须：\n- 通过 $\\mathbf{D}_{\\mathrm{ps}}$ 和 $\\mathbf{D}_{\\mathrm{pe}}$ 实现平面应力和平面应变。\n- 按所述实现 CST 和 Q4 单元运动学。\n- 对每个测试用例，计算两个数值：CST 相对误差 $\\eta_{\\mathrm{CST}}$ 和 Q4 相对误差 $\\eta_{\\mathrm{Q4}}$。\n\n使用以下参数集测试套件，其中 $E$ 是以帕斯卡为单位的杨氏模量，$\\nu$ 是泊松比。所有输出都必须报告为无量纲的十进制数（无物理单位）：\n- 测试 $1$：平面应力，$E=200\\times 10^9$，$\\nu=0.3$，$N=1$。\n- 测试 $2$：平面应力，$E=200\\times 10^9$，$\\nu=0.3$，$N=4$。\n- 测试 $3$：平面应变，$E=70\\times 10^9$，$\\nu=0.25$，$N=2$。\n- 测试 $4$：平面应变，$E=70\\times 10^9$，$\\nu=0$，$N=3$。\n\n最终输出格式：\n- 你的程序应生成单行输出，包含一个由方括号括起来的、逗号分隔的列表，其中包含 8 个结果，顺序如下\n$$\n[\\eta_{\\mathrm{CST}}^{(1)},\\eta_{\\mathrm{Q4}}^{(1)},\\eta_{\\mathrm{CST}}^{(2)},\\eta_{\\mathrm{Q4}}^{(2)},\\eta_{\\mathrm{CST}}^{(3)},\\eta_{\\mathrm{Q4}}^{(3)},\\eta_{\\mathrm{CST}}^{(4)},\\eta_{\\mathrm{Q4}}^{(4)}].\n$$", "solution": "我们从运动学和本构基础开始。位移场被指定为 $x$ 和 $y$ 的二次多项式，因此通过微分得到的精确应变场 $\\boldsymbol{\\varepsilon}(x,y)$，\n$$\n\\varepsilon_{xx} = \\frac{\\partial u_x}{\\partial x},\\quad\n\\varepsilon_{yy} = \\frac{\\partial u_y}{\\partial y},\\quad\n\\gamma_{xy} = \\frac{\\partial u_x}{\\partial y} + \\frac{\\partial u_y}{\\partial x},\n$$\n是关于 $(x,y)$ 的线性函数。精确应力场由线性弹性本构矩阵 $\\mathbf{D}$ 得出：\n$$\n\\boldsymbol{\\sigma}(x,y) = \\mathbf{D} \\, \\boldsymbol{\\varepsilon}(x,y).\n$$\n我们计算相对 $L^2$ 型应力误差\n$$\n\\eta = \\left(\\frac{\\int_{\\Omega} \\lVert \\boldsymbol{\\sigma} - \\boldsymbol{\\sigma}^h \\rVert_2^2 \\, \\mathrm{d}\\Omega}{\\int_{\\Omega} \\lVert \\boldsymbol{\\sigma} \\rVert_2^2 \\, \\mathrm{d}\\Omega}\\right)^{1/2},\n$$\n其中 $\\boldsymbol{\\sigma}^h$ 表示通过对精确节点位移进行插值并在单元内微分得到的有限元应力。这种设置在不求解平衡方程的情况下分离出了插值误差。\n\n对于常应变三角形 (CST)，单元形函数是关于 $(x,y)$ 的线性函数，因此位移插值是线性的，其梯度以及应变 $\\boldsymbol{\\varepsilon}^h$ 在每个三角形内是常数。对于节点为 $\\left(x_i,y_i\\right)$，$i\\in\\{1,2,3\\}$ 的三角形，其应变-位移矩阵 $\\mathbf{B}$ 为\n$$\n\\mathbf{B} = \\frac{1}{2A}\n\\begin{bmatrix}\nb_1  0  b_2  0  b_3  0 \\\\\n0  c_1  0  c_2  0  c_3 \\\\\nc_1  b_1  c_2  b_2  c_3  b_3\n\\end{bmatrix},\n$$\n其中 $A$ 是三角形面积，$(b_i,c_i)$ 是几何系数\n$$\nb_1 = y_2 - y_3,\\quad b_2 = y_3 - y_1,\\quad b_3 = y_1 - y_2; \\quad\nc_1 = x_3 - x_2,\\quad c_2 = x_1 - x_3,\\quad c_3 = x_2 - x_1.\n$$\n给定节点位移向量 $\\mathbf{d}_e = [u_1,v_1,u_2,v_2,u_3,v_3]^\\top$（通过在三角形节点处采样精确位移填充），单元应变为 $\\boldsymbol{\\varepsilon}^h = \\mathbf{B}\\mathbf{d}_e$，单元应力为 $\\boldsymbol{\\sigma}^h = \\mathbf{D}\\boldsymbol{\\varepsilon}^h$，两者在三角形上均为常数。由于精确应力是关于 $(x,y)$ 的线性函数，而 CST 应力是常数，它们的差是线性的；其范数的平方是一个二次多项式。我们使用一个 2 次三点高斯积分法则在每个三角形上精确地积分它，该法则使用重心坐标点 $(\\tfrac{2}{3},\\tfrac{1}{6},\\tfrac{1}{6})$ 及其置换，每个点的权重为 $\\tfrac{1}{3}$，并按三角形面积进行缩放。\n\n对于轴对齐矩形单元上的双线性四边形 (Q4)，从自然坐标 $(\\xi,\\eta)\\in[-1,1]^2$ 的等参映射采用双线性形函数\n$$\nN_1=\\tfrac{1}{4}(1-\\xi)(1-\\eta),\\;\nN_2=\\tfrac{1}{4}(1+\\xi)(1-\\eta),\\;\nN_3=\\tfrac{1}{4}(1+\\xi)(1+\\eta),\\;\nN_4=\\tfrac{1}{4}(1-\\xi)(1+\\eta).\n$$\n位移插值为\n$$\n\\mathbf{u}^h(\\xi,\\eta) = \\sum_{a=1}^4 N_a(\\xi,\\eta)\\,\\mathbf{u}_a,\n$$\n其中 $\\mathbf{u}_a$ 是四边形顶点处的精确节点位移。应变通过对 $\\mathbf{u}^h$ 关于物理坐标求导得出。使用雅可比矩阵 $\\mathbf{J}=\\frac{\\partial(x,y)}{\\partial(\\xi,\\eta)}$ 和链式法则，\n$$\n\\begin{bmatrix}\n\\frac{\\partial N_a}{\\partial x} \\\\\n\\frac{\\partial N_a}{\\partial y}\n\\end{bmatrix}\n= \\mathbf{J}^{-1}\n\\begin{bmatrix}\n\\frac{\\partial N_a}{\\partial \\xi} \\\\\n\\frac{\\partial N_a}{\\partial \\eta}\n\\end{bmatrix},\n$$\n我们在每个积分点上组装 Q4 的标准 $\\mathbf{B}$ 矩阵，使用 $\\mathbf{d}_e=[u_1,v_1,u_2,v_2,u_3,v_3,u_4,v_4]^\\top$ 计算 $\\boldsymbol{\\varepsilon}^h = \\mathbf{B}\\mathbf{d}_e$，然后计算 $\\boldsymbol{\\sigma}^h=\\mathbf{D}\\boldsymbol{\\varepsilon}^h$。因为在仿射映射的矩形上，精确应力和 Q4 应力都是关于 $(x,y)$ 的线性函数，所以它们的差也是线性的，其范数的平方是二次的。我们通过在 $(\\xi,\\eta)$ 中使用张量积 $2\\times 2$ 高斯积分来精确地积分它，积分点位于 $\\xi,\\eta=\\pm 1/\\sqrt{3}$，权重为单位权重，并按 $\\det\\mathbf{J}$ 进行缩放。\n\n对于这两种单元类型，我们通过积分逐个单元地累加分子\n$$\n\\int_{\\Omega} \\lVert \\boldsymbol{\\sigma}-\\boldsymbol{\\sigma}^h\\rVert_2^2 \\,\\mathrm{d}\\Omega\n$$\n和分母\n$$\n\\int_{\\Omega} \\lVert \\boldsymbol{\\sigma}\\rVert_2^2 \\,\\mathrm{d}\\Omega\n$$\n以获得相对误差 $\\eta$。\n\n为什么对于二次位移场，Q4 与 CST 不同：\n- 精确应变是关于 $(x,y)$ 的线性函数，因为位移是二次的。CST 应变在每个三角形内是常数，这是该区域上对线性场的最佳常数近似，导致一个具有相对较大常数的一阶（$\\mathcal{O}(h)$）梯度误差。\n- Q4 应变在每个矩形内是线性的（在仿射网格上），更紧密地匹配了精确的线性变化。虽然双线性位移不能精确地再现纯 $x^2$ 或 $y^2$ 项，但其导数是线性的，由于部分再现了混合项和更好的局部拟合，因此产生了一个具有较小常数的一阶（$\\mathcal{O}(h)$）梯度误差。\n- 因此，对于相同的网格，我们期望 $\\eta_{\\mathrm{Q4}} \\ll \\eta_{\\mathrm{CST}}$，并且随着 $N$ 的增加（网格细化），两者都会减小。\n\n程序实现：\n- 通过对给定的二次多项式进行解析微分得到精确应变。\n- 通过 $\\mathbf{D}_{\\mathrm{ps}}$ 和 $\\mathbf{D}_{\\mathrm{pe}}$ 得到精确应力。\n- CST：通过三角形 $\\mathbf{B}$ 矩阵得到单元级常数 $\\boldsymbol{\\sigma}^h$，并使用 2 次三角形积分进行误差积分。\n- Q4：通过等参微分和 $2\\times 2$ 高斯积分得到逐点的 $\\boldsymbol{\\sigma}^h(\\xi,\\eta)$。\n- 对四个指定测试的相对误差进行聚合。输出是包含八个无量纲数字的单行，按要求顺序排列。\n\n这种设计尊重了基本的运动学和本构定律，在没有全局平衡的情况下分离了插值效应，并使用了对于误差被积函数中遇到的多项式次数而言是精确的积分法则。", "answer": "```python\nimport numpy as np\n\n# Finite Element interpolation error comparison for CST vs Q4\n# under plane stress / plane strain, using a known quadratic displacement field.\n\ndef constitutive_matrix(E, nu, mode):\n    if mode == 'plane_stress':\n        fac = E / (1.0 - nu**2)\n        D = fac * np.array([\n            [1.0, nu, 0.0],\n            [nu, 1.0, 0.0],\n            [0.0, 0.0, (1.0 - nu) / 2.0]\n        ])\n    elif mode == 'plane_strain':\n        fac = E / ((1.0 + nu) * (1.0 - 2.0 * nu))\n        D = fac * np.array([\n            [1.0 - nu, nu, 0.0],\n            [nu, 1.0 - nu, 0.0],\n            [0.0, 0.0, (1.0 - 2.0 * nu) / 2.0]\n        ])\n    else:\n        raise ValueError(\"Unknown mode\")\n    return D\n\n# Quadratic displacement coefficients\na1, a2, a3, a4, a5, a6 = 1.0, 0.5, 0.2, 0.1, 0.05, 0.01\nb1, b2, b3, b4, b5, b6 = -0.3, 0.4, 0.9, 0.2, -0.1, -0.02\n\ndef exact_u(x, y):\n    ux = a1*x*x + a2*x*y + a3*y*y + a4*x + a5*y + a6\n    uy = b1*x*x + b2*x*y + b3*y*y + b4*x + b5*y + b6\n    return ux, uy\n\ndef exact_strain(x, y):\n    dux_dx = 2.0*a1*x + a2*y + a4\n    dux_dy = a2*x + 2.0*a3*y + a5\n    duy_dx = 2.0*b1*x + b2*y + b4\n    duy_dy = b2*x + 2.0*b3*y + b5\n    exx = dux_dx\n    eyy = duy_dy\n    gxy = dux_dy + duy_dx\n    return np.array([exx, eyy, gxy])\n\ndef exact_sigma(x, y, D):\n    return D @ exact_strain(x, y)\n\ndef B_matrix_CST(coords):\n    x1, y1 = coords[0]\n    x2, y2 = coords[1]\n    x3, y3 = coords[2]\n    A2 = (x2 - x1)*(y3 - y1) - (x3 - x1)*(y2 - y1)  # 2*A\n    if abs(A2)  1e-12:\n        raise ValueError(\"Degenerate triangle\")\n    b1 = y2 - y3\n    b2 = y3 - y1\n    b3 = y1 - y2\n    c1 = x3 - x2\n    c2 = x1 - x3\n    c3 = x2 - x1\n    B = np.array([\n        [b1, 0.0, b2, 0.0, b3, 0.0],\n        [0.0, c1, 0.0, c2, 0.0, c3],\n        [c1, b1, c2, b2, c3, b3]\n    ]) / A2\n    A = 0.5 * A2\n    return B, A\n\n# Triangle quadrature: degree-2 exact (three points)\ntri_qw = np.array([1.0/3.0, 1.0/3.0, 1.0/3.0])\ntri_qL = np.array([\n    [2.0/3.0, 1.0/6.0, 1.0/6.0],\n    [1.0/6.0, 2.0/3.0, 1.0/6.0],\n    [1.0/6.0, 1.0/6.0, 2.0/3.0]\n])\n\n# Q4 shape functions and derivatives\ndef q4_shape_funcs(xi, eta):\n    N = np.array([\n        0.25*(1.0 - xi)*(1.0 - eta),\n        0.25*(1.0 + xi)*(1.0 - eta),\n        0.25*(1.0 + xi)*(1.0 + eta),\n        0.25*(1.0 - xi)*(1.0 + eta)\n    ])\n    dN_dxi = np.array([\n        -0.25*(1.0 - eta),\n         0.25*(1.0 - eta),\n         0.25*(1.0 + eta),\n        -0.25*(1.0 + eta)\n    ])\n    dN_deta = np.array([\n        -0.25*(1.0 - xi),\n        -0.25*(1.0 + xi),\n         0.25*(1.0 + xi),\n         0.25*(1.0 - xi)\n    ])\n    return N, dN_dxi, dN_deta\n\ngauss_pts = [-1.0/np.sqrt(3.0), 1.0/np.sqrt(3.0)]\ngauss_wts = [1.0, 1.0]\n\ndef compute_errors(Ndiv, E, nu, mode):\n    D = constitutive_matrix(E, nu, mode)\n    xs = np.linspace(0.0, 1.0, Ndiv+1)\n    ys = np.linspace(0.0, 1.0, Ndiv+1)\n    num_cst, den_cst = 0.0, 0.0\n    num_q4, den_q4 = 0.0, 0.0\n\n    for i in range(Ndiv):\n        for j in range(Ndiv):\n            quad_coords = np.array([\n                [xs[i], ys[j]], [xs[i+1], ys[j]],\n                [xs[i+1], ys[j+1]], [xs[i], ys[j+1]]\n            ])\n\n            # Q4 contribution\n            de_q4 = np.array([v for p in quad_coords for v in exact_u(p[0], p[1])])\n            for w_xi, xi in zip(gauss_wts, gauss_pts):\n                for w_eta, eta in zip(gauss_wts, gauss_pts):\n                    N, dN_dxi, dN_deta = q4_shape_funcs(xi, eta)\n                    x = np.dot(N, quad_coords[:,0])\n                    y = np.dot(N, quad_coords[:,1])\n                    \n                    J = np.array([\n                        [np.dot(dN_dxi, quad_coords[:,0]), np.dot(dN_dxi, quad_coords[:,1])],\n                        [np.dot(dN_deta, quad_coords[:,0]), np.dot(dN_deta, quad_coords[:,1])]\n                    ])\n                    detJ = np.linalg.det(J)\n                    invJ = np.linalg.inv(J)\n                    \n                    B = np.zeros((3, 8))\n                    for a in range(4):\n                        dN_xy = invJ @ np.array([dN_dxi[a], dN_deta[a]])\n                        B[0, 2*a]   = dN_xy[0]\n                        B[1, 2*a+1] = dN_xy[1]\n                        B[2, 2*a]   = dN_xy[1]\n                        B[2, 2*a+1] = dN_xy[0]\n                        \n                    sig_h = D @ (B @ de_q4)\n                    sig_ex = exact_sigma(x, y, D)\n                    diff = sig_ex - sig_h\n                    w = w_xi * w_eta * detJ\n                    num_q4 += np.dot(diff, diff) * w\n                    den_q4 += np.dot(sig_ex, sig_ex) * w\n\n            # CST contribution\n            tris = [np.array([quad_coords[0], quad_coords[1], quad_coords[2]]),\n                    np.array([quad_coords[0], quad_coords[2], quad_coords[3]])]\n            for tri in tris:\n                Bc, A = B_matrix_CST(tri)\n                de_tri = np.array([v for p in tri for v in exact_u(p[0], p[1])])\n                sig_h = D @ (Bc @ de_tri)\n                for wL, L in zip(tri_qw, tri_qL):\n                    x = L[0]*tri[0,0] + L[1]*tri[1,0] + L[2]*tri[2,0]\n                    y = L[0]*tri[0,1] + L[1]*tri[1,1] + L[2]*tri[2,1]\n                    sig_ex = exact_sigma(x, y, D)\n                    diff = sig_ex - sig_h\n                    w = A * wL\n                    num_cst += np.dot(diff, diff) * w\n                    den_cst += np.dot(sig_ex, sig_ex) * w\n\n    eta_cst = np.sqrt(num_cst / den_cst) if den_cst > 0 else 0.0\n    eta_q4  = np.sqrt(num_q4  / den_q4)  if den_q4 > 0 else 0.0\n    return eta_cst, eta_q4\n\ndef solve():\n    test_cases = [\n        (1, 200e9, 0.3, 'plane_stress'),\n        (4, 200e9, 0.3, 'plane_stress'),\n        (2, 70e9, 0.25, 'plane_strain'),\n        (3, 70e9, 0.0, 'plane_strain')\n    ]\n    results = []\n    for (N, E, nu, mode) in test_cases:\n        eta_cst, eta_q4 = compute_errors(N, E, nu, mode)\n        results.append(eta_cst)\n        results.append(eta_q4)\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2554580"}]}