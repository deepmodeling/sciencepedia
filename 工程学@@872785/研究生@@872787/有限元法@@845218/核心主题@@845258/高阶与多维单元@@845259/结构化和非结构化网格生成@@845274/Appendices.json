{"hands_on_practices": [{"introduction": "一个有效的有限元网格不仅是形状良好单元的集合，它更必须代表一个拓扑上一致的空间划分。本实践深入探讨了任何有效的三维四面体网格都必须满足的基本拓扑属性。通过应用欧拉-庞加莱公式等概念，你将学习如何根据其顶点、边、面和单元的数量来验证网格结构的完整性，甚至推断出区域边界的属性。[@problem_id:2604551] 这是网格验证中至关重要的第一步，确保在进行任何几何分析或模拟之前，网格的连接性是健全的。", "problem": "一个由Delaunay型生成器产生的非结构化四面体有限元网格，离散化了一个带边界的紧致、连通、可定向的三维区域。该网格是一个单纯复形，其顶点、边、三角形面和四面体的数量由元组 $\\left(N_{v},N_{e},N_{f},N_{t}\\right)=\\left(500,1332,1630,800\\right)$ 给出。假设该区域的边界是一个连通的二维流形，由网格中边界三角形面的子集进行三角剖分。\n\n从单纯复形的欧拉示性数定义出发，并仅使用单纯形之间的基本关联计数，推导连接 $N_{v}$、$N_{e}$、$N_{f}$、$N_{t}$ 以及边界面数量 $B_{f}$ 的必要拓扑一致性关系。使用这些关系来验证给定的元组是否能表示一个具有流形边界的拓扑一致的非结构化四面体网格。然后，仅使用关于流形及其边界的欧拉示性数的基本拓扑事实，推断出连通边界曲面的亏格 $g$。\n\n给出你的最终答案，为整数形式的 $g$ 值。无需四舍五入。", "solution": "问题陈述已经过验证，被认为是计算拓扑学和计算几何领域中一个适定且具有科学依据的问题，因为它应用于有限元方法。该问题是自洽的、客观的，且无矛盾。我现在将提供解答。\n\n该问题要求推导一个三维单纯复形（一个四面体网格）的拓扑一致性关系。该单纯复形离散化了一个带连通边界 $\\partial M$ 的紧致、连通、可定向的三维流形 $M$。给定顶点数 $N_v = 500$、边数 $N_e = 1332$、面数 $N_f = 1630$ 和四面体数 $N_t = 800$。\n\n首先，我们基于维度为2的单纯形（面）和维度为3的单纯形（四面体）之间的关联计数来推导一个关系。设面的集合被划分为内部面 $F_i$ 和边界面 $F_b$。它们的数量分别为 $N_{fi}$ 和 $B_f$，使得 $N_f = N_{fi} + B_f$。每个四面体由4个三角形面界定。因此，对所有四面体的面数求和，得到总共 $4N_t$ 个面-四面体关联。\n根据定义，一个内部面恰好被两个四面体共享。一个边界面恰好属于一个四面体。因此，我们可以将面-四面体关联的总数表示为对所有面的求和：\n$$ \\sum_{k \\in \\text{Tetrahedra}} (\\text{number of faces in } k) = \\sum_{f \\in \\text{Faces}} (\\text{number of tetrahedra containing } f) $$\n$$ 4N_t = 2N_{fi} + 1B_f $$\n将 $N_{fi} = N_f - B_f$ 代入此方程，我们得到：\n$$ 4N_t = 2(N_f - B_f) + B_f $$\n$$ 4N_t = 2N_f - 2B_f + B_f $$\n$$ 4N_t = 2N_f - B_f $$\n这得到了第一个必要的一致性关系，它允许我们从给定的网格计数中确定边界面的数量：\n$$ B_f = 2N_f - 4N_t $$\n\n其次，我们使用流形的欧拉示性数理论。对流形 $M$ 进行三角剖分的三维单纯复形 $\\mathcal{K}$ 的欧拉示性数 $\\chi$ 由其单纯形数量的交错和给出：\n$$ \\chi(M) = \\chi(\\mathcal{K}) = N_v - N_e + N_f - N_t $$\n对于带边界 $\\partial M$ 的紧致、可定向的 $n$-流形 $M$，Lefschetz对偶性给出了它们欧拉示性数之间的关系。对于我们 $n=3$ 的情况，此关系为 $\\chi(M) = \\frac{1}{2}\\chi(\\partial M)$。\n边界 $\\partial M$ 被陈述为一个连通、可定向的二维流形（一个闭合曲面）。这种曲面的欧拉示性数由其亏格 $g$ 根据以下公式确定：\n$$ \\chi(\\partial M) = 2 - 2g $$\n结合这些拓扑事实，我们推导出第二个基本关系：\n$$ N_v - N_e + N_f - N_t = \\frac{1}{2}(2 - 2g) = 1 - g $$\n这个关系将网格单纯形的宏观计数与其边界曲面的拓扑亏格联系起来。\n\n现在，我们使用这些推导出的关系来验证给定数据 $\\left(N_{v},N_{e},N_{f},N_{t}\\right)=\\left(500,1332,1630,800\\right)$ 的一致性，并推断出亏格 $g$。\n\n首先，我们使用关联关系计算边界面的数量 $B_f$：\n$$ B_f = 2(1630) - 4(800) = 3260 - 3200 = 60 $$\n对于一个闭合流形的拓扑一致三角剖分，边界面的数量 $B_f$ 必须是一个正偶数。我们的结果 $B_f = 60$ 满足这些条件，表明面和四面体的计数与存在有效边界三角剖分是一致的。\n\n接下来，我们计算三维复形的欧拉示性数：\n$$ \\chi(\\mathcal{K}) = N_v - N_e + N_f - N_t = 500 - 1332 + 1630 - 800 $$\n$$ \\chi(\\mathcal{K}) = -832 + 1630 - 800 = 798 - 800 = -2 $$\n现在我们应用第二个关系，$N_v - N_e + N_f - N_t = 1 - g$：\n$$ -2 = 1 - g $$\n求解亏格 $g$：\n$$ g = 1 - (-2) = 3 $$\n亏格 $g$ 必须是一个非负整数。我们的结果 $g=3$ 是有效的。一致性可以被交叉检验：边界曲面是一个亏格 $g=3$ 的可定向曲面（一个三环面），其欧拉示性数 $\\chi(\\partial M) = 2 - 2(3) = -4$。关系 $\\chi(M) = \\frac{1}{2}\\chi(\\partial M)$ 得到满足，因为 $-2 = \\frac{1}{2}(-4)$。\n\n因此，所提供的单纯形计数元组 $\\left(500,1332,1630,800\\right)$ 在拓扑上与一个离散化了连通三维流形的四面体网格的描述是一致的，该流形的边界是一个亏格 $g=3$ 的连通可定向曲面。", "answer": "$$\\boxed{3}$$", "id": "2604551"}, {"introduction": "虽然拓扑一致性是必要条件，但网格单元的几何质量对于模拟精度至关重要。对同一区域采用不同的有效三角剖分，可能会导致截然不同的结果。本动手练习通过在一个四边形区域上，使用两种不同的三角剖分方案求解一个简单的弹性问题，来展示这一关键原则。[@problem_id:2412649] 通过比较最终的位移场，你将具体理解网格划分的决策（即使只是单一对角线的选择），是如何直接影响离散模型的刚度以及有限元解的准确性。", "problem": "您需要实现并分析一个最小线性弹性有限元模型，该模型针对一个凸四边形，使用两种不同的三角剖分选择进行离散化。目标是通过测量计算出的位移场差异，来量化这些不同三角剖分对解的影响。背景设定为平面应力下的平面、线性、各向同性弹性问题，使用具有恒定应变的三节点线性三角形单元。\n\n基本原理：\n- 使用最小势能原理和虚功原理来推导离散方程。虚功原理指出，在平衡状态下，对于任何虚位移场，内部虚功等于外部虚功。\n- 使用平面应力下线性各向同性材料的胡克定律：应力-应变关系是线性的，通过一个本构矩阵将应变映射到应力。\n- 使用标准的有限元方法（FEM），采用常应变三角形（CST）单元，其中应变-位移矩阵在每个三角形单元内是恒定的。\n\n任务要求：\n- 域：一个凸四边形，其顶点按逆时针顺序标记为节点 $0$、$1$、$2$、$3$。\n- 必须考虑两种三角剖分：\n  - 三角剖分A：使用对角线 $\\overline{0-2}$ 形成三角形 $(0,1,2)$ 和 $(0,2,3)$。\n  - 三角剖分B：使用对角线 $\\overline{1-3}$ 形成三角形 $(0,1,3)$ 和 $(1,2,3)$。\n- 材料模型：平面应力下的线性各向同性弹性体，具有杨氏模量 $E$（单位：帕斯卡），泊松比 $\\nu$（无量纲），以及均匀厚度 $t$（单位：米）。\n- 荷载和边界条件：\n  - 在右侧边 $\\overline{1-2}$ 上施加均匀的表面牵引力向量 $\\mathbf{p}$（单位：帕斯卡）。假设 $\\mathbf{p}$ 在整个边上是恒定的，并作用于厚度为 $t$ 的二维体的边缘。\n  - 在节点 $0$ 和 $3$ 的两个位移分量上施加齐次狄利克雷边界条件（零位移），以消除刚体模态。\n- 离散化与组装：\n  - 根据虚功原理，使用常应变-位移矩阵和适用于平面应力的本构矩阵，推导并实现三节点线性三角形的单元刚度矩阵。\n  - 计算并组装边界边 $\\overline{1-2}$ 上均匀牵引力的一致等效节点荷载。对于长度为 $L$、承受恒定牵引力 $\\mathbf{p}$ 和厚度为 $t$ 的直边，根据沿边的形函数标准一致荷载推导，将荷载分配到两个边节点上。\n  - 为每种三角剖分方法组装全局刚度矩阵和全局力向量，并求解得到的线性系统以获得节点位移。\n- 比较度量：\n  - 对于每个测试用例，计算由三角剖分A和三角剖分B产生的完整位移向量（包括所有四个节点的 $x$ 和 $y$ 分量）之差的欧几里得范数。以米为单位报告此标量范数。\n\n单位和数值输出：\n- 所有几何坐标均以米为单位。\n- 杨氏模量 $E$ 以帕斯卡为单位。\n- 泊松比 $\\nu$ 是无量纲的。\n- 厚度 $t$ 以米为单位。\n- 牵引力向量的分量以帕斯卡为单位。\n- 比较度量（位移差的范数）必须以米为单位，作为浮点值报告。\n- 输出值应四舍五入至 $9$ 位有效数字。\n\n测试套件：\n实现您的程序以运行以下三种情况。对于每种情况，右边缘是节点 $1$ 和 $2$ 之间的线段，左侧边界条件应用于节点 $0$ 和 $3$。\n\n- 情况 $1$（一般凸四边形）：\n  - 坐标（米）：$\\left[(0,0),\\ (2,0),\\ (2,1),\\ (0.2,1.2)\\right]$\n  - 材料：$E = 7.0 \\times 10^{10}\\ \\text{Pa}$，$\\nu = 0.33$，$t = 0.01\\ \\text{m}$\n  - 在 $\\overline{1-2}$ 上的牵引力：$\\mathbf{p} = (1.0 \\times 10^{6},\\ 0)$ Pa\n- 情况 $2$（轴对齐的矩形）：\n  - 坐标（米）：$\\left[(0,0),\\ (1,0),\\ (1,1),\\ (0,1)\\right]$\n  - 材料：$E = 1.0 \\times 10^{7}\\ \\text{Pa}$，$\\nu = 0.25$，$t = 0.05\\ \\text{m}$\n  - 在 $\\overline{1-2}$ 上的牵引力：$\\mathbf{p} = (5.0 \\times 10^{4},\\ 0)$ Pa\n- 情况 $3$（高泊松比的细长凸四边形）：\n  - 坐标（米）：$\\left[(0,0),\\ (3,0),\\ (3,0.1),\\ (0,0.2)\\right]$\n  - 材料：$E = 2.0 \\times 10^{9}\\ \\text{Pa}$，$\\nu = 0.49$，$t = 0.01\\ \\text{m}$\n  - 在 $\\overline{1-2}$ 上的牵引力：$\\mathbf{p} = (1.0 \\times 10^{4},\\ 0)$ Pa\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，例如 $[\\text{result}_1, \\text{result}_2, \\text{result}_3]$，不含空格。每个 $\\text{result}_{i}$ 是案例 $i$ 中两种三角剖分选择之间位移差的欧几里得范数，单位为米，四舍五入至 $9$ 位有效数字。\n- 程序必须是自包含的，不需要任何输入，并且可以按原样运行。\n\n注意：\n- 首次出现任何缩写时，请使用其全称，例如，有限元方法（Finite Element Method, FEM）和常应变三角形（Constant Strain Triangle, CST）。\n- 通过使用一致的单位和稳定的边界条件来确保科学真实性。", "solution": "该问题要求使用有限元方法（Finite Element Method, FEM）分析网格拓扑对线性弹性问题解的影响。具体来说，我们需要为一个受到表面牵引力和固定边界条件作用的凸四边形域计算位移场。该域通过两种不同的方式进行网格划分，并计算所得位移向量之差的欧几里得范数。分析基于平面应力条件下的线性弹性理论，使用三节点常应变三角形（Constant Strain Triangle, CST）单元进行离散。\n\n求解过程分为几个步骤：推导单元刚度矩阵、计算一致节点荷载、组装全局方程组、施加边界条件、求解节点位移，最后比较两种三角剖分的计算结果。\n\n**1. 常应变三角形（CST）的有限元列式**\n\n我们考虑一个具有三个节点（按逆时针顺序索引为 $i, j, k$）的三角形单元。单元内的位移场 $\\mathbf{u}(x, y)$ 通过线性形函数 $N_i, N_j, N_k$ 进行近似：\n$$ \\mathbf{u}(x, y) = \\begin{Bmatrix} u_x(x,y) \\\\ u_y(x,y) \\end{Bmatrix} = \\sum_{m=i,j,k} N_m(x,y) \\begin{Bmatrix} u_m \\\\ v_m \\end{Bmatrix} $$\n其中 $(u_m, v_m)$ 是节点 $m$ 处的位移分量。这可以写成矩阵形式 $\\mathbf{u} = \\mathbf{N} \\mathbf{d}^e$，其中 $\\mathbf{d}^e = \\{u_i, v_i, u_j, v_j, u_k, v_k\\}^T$ 是单元的节点位移向量，$\\mathbf{N}$ 是形函数矩阵：\n$$ \\mathbf{N} = \\begin{bmatrix} N_i & 0 & N_j & 0 & N_k & 0 \\\\ 0 & N_i & 0 & N_j & 0 & N_k \\end{bmatrix} $$\n二维问题的应变向量为 $\\boldsymbol{\\epsilon} = \\{\\epsilon_{xx}, \\epsilon_{yy}, \\gamma_{xy}\\}^T$。应变由位移导出：\n$$ \\epsilon_{xx} = \\frac{\\partial u_x}{\\partial x}, \\quad \\epsilon_{yy} = \\frac{\\partial u_y}{\\partial y}, \\quad \\gamma_{xy} = \\frac{\\partial u_x}{\\partial y} + \\frac{\\partial u_y}{\\partial x} $$\n这种关系表示为 $\\boldsymbol{\\epsilon} = \\mathbf{L} \\mathbf{u}$，其中 $\\mathbf{L}$ 是微分算子矩阵。代入 $\\mathbf{u}$ 的有限元近似，我们得到应变-位移关系：\n$$ \\boldsymbol{\\epsilon} = (\\mathbf{L} \\mathbf{N}) \\mathbf{d}^e = \\mathbf{B} \\mathbf{d}^e $$\n对于CST单元，得到的应变-位移矩阵 $\\mathbf{B}$ 在单元内是恒定的。其表达式为：\n$$ \\mathbf{B} = \\frac{1}{2A_e} \\begin{bmatrix} y_{jk} & 0 & y_{ki} & 0 & y_{ij} & 0 \\\\ 0 & x_{kj} & 0 & x_{ik} & 0 & x_{ji} \\\\ x_{kj} & y_{jk} & x_{ik} & y_{ki} & x_{ji} & y_{ij} \\end{bmatrix} $$\n其中 $(x_m, y_m)$ 是节点 $m$ 的坐标，$x_{pq} = x_p - x_q$，$y_{pq} = y_p - y_q$，$A_e$ 是单元的面积，计算公式为 $A_e = \\frac{1}{2} |x_i(y_j - y_k) + x_j(y_k - y_i) + x_k(y_i - y_j)|$。\n\n应力向量 $\\boldsymbol{\\sigma} = \\{\\sigma_{xx}, \\sigma_{yy}, \\tau_{xy}\\}^T$ 通过胡克定律与应变向量相关联，$\\boldsymbol{\\sigma} = \\mathbf{C} \\boldsymbol{\\epsilon}$，其中 $\\mathbf{C}$ 是本构矩阵。对于平面应力下的各向同性材料，$\\mathbf{C}$ 为：\n$$ \\mathbf{C} = \\frac{E}{1 - \\nu^2} \\begin{bmatrix} 1 & \\nu & 0 \\\\ \\nu & 1 & 0 \\\\ 0 & 0 & \\frac{1-\\nu}{2} \\end{bmatrix} $$\n这里，$E$ 是杨氏模量，$\\nu$ 是泊松比。\n\n单元刚度矩阵 $\\mathbf{k}^e$ 由虚功原理推导得出，其积分形式为：\n$$ \\mathbf{k}^e = \\int_{V_e} \\mathbf{B}^T \\mathbf{C} \\mathbf{B} \\, dV $$\n假设厚度 $t$ 均匀，且矩阵 $\\mathbf{B}$ 和 $\\mathbf{C}$ 为常数，积分简化为：\n$$ \\mathbf{k}^e = t \\cdot A_e \\cdot \\mathbf{B}^T \\mathbf{C} \\mathbf{B} $$\n这将为每个单元生成一个 $6 \\times 6$ 的对称矩阵。\n\n**2. 一致节点荷载**\n\n一个均匀的表面牵引力向量 $\\mathbf{p} = \\{p_x, p_y\\}^T$ 施加在边 $\\overline{1-2}$ 上。功等效的节点力通过将牵引力乘以形函数在加载边上积分得到。对于两个节点之间长度为 $L$ 的直边，使用线性形函数，总力 $L \\cdot t \\cdot \\mathbf{p}$ 被平均分配到两个节点上。施加在边上节点 $m$ 的力向量为：\n$$ \\mathbf{f}_m = \\frac{L \\cdot t}{2} \\mathbf{p} $$\n在本问题中，荷载作用于边 $\\overline{1-2}$，因此节点 $1$ 和 $2$ 各自分担一半的总力。\n\n**3. 全局系统组装与求解**\n\n该域包含四个节点，因此有 $4 \\times 2 = 8$ 个自由度（DOFs）。全局刚度矩阵 $\\mathbf{K}$（$8 \\times 8$）和全局力向量 $\\mathbf{F}$（$8 \\times 1$）通过对每个单元的贡献求和来组装。对于给定三角剖分中的每个三角形，计算其单元刚度矩阵 $\\mathbf{k}^e$，并根据单元的全局节点索引将其项加到 $\\mathbf{K}$ 的相应位置。\n\n全局方程组为 $\\mathbf{K}\\mathbf{U} = \\mathbf{F}$，其中 $\\mathbf{U}$ 是全局节点位移向量。在节点 $0$ 和 $3$ 处施加齐次狄利克雷边界条件，即 $u_{0x} = u_{0y} = u_{3x} = u_{3y} = 0$。这对应于自由度 $0, 1, 6, 7$。通过将系统划分为自由自由度和固定自由度来施加这些条件。系统简化为：\n$$ \\mathbf{K}_{ff} \\mathbf{U}_f = \\mathbf{F}_f $$\n其中下标 $f$ 表示自由自由度，即节点 $1$ 和 $2$ 处的 $x$ 和 $y$ 位移（自由度 $2, 3, 4, 5$）。$\\mathbf{K}_{ff}$ 是 $\\mathbf{K}$ 的一个 $4 \\times 4$ 子矩阵。求解这个简化系统以得到未知位移 $\\mathbf{U}_f$。然后将 $\\mathbf{U}_f$ 与固定节点的零位移结合，构建完整的位移向量 $\\mathbf{U}$。\n\n**4. 三角剖分与比较**\n\n对具有顶点 $(0,1,2,3)$ 的四边形域的两种不同三角剖分执行此过程：\n- **三角剖分 A：** 域被对角线 $\\overline{0-2}$ 分割成三角形 $(0,1,2)$ 和 $(0,2,3)$。\n- **三角剖分 B：** 域被对角线 $\\overline{1-3}$ 分割成三角形 $(0,1,3)$ 和 $(1,2,3)$。\n\n这将产生两个完整的位移向量 $\\mathbf{U}_A$ 和 $\\mathbf{U}_B$。两者解之间的差异通过差向量的欧几里得范数来量化：\n$$ \\text{差异} = ||\\mathbf{U}_A - \\mathbf{U}_B||_2 = \\sqrt{\\sum_{i=0}^{7} (U_{A,i} - U_{B,i})^2} $$\n这个标量值表示了由于选择不同内部对角线（这是影响解质量的网格生成的根本方面）而导致的计算位移场的总体差异。对提供的三个测试用例中的每一个都重复整个过程。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the FEM analysis for all test cases.\n    \"\"\"\n    test_cases = [\n        {\n            \"coords\": np.array([[0.0, 0.0], [2.0, 0.0], [2.0, 1.0], [0.2, 1.2]]),\n            \"material\": {\"E\": 7.0e10, \"nu\": 0.33, \"t\": 0.01},\n            \"traction\": {\"edge_nodes\": (1, 2), \"p\": np.array([1.0e6, 0.0])},\n        },\n        {\n            \"coords\": np.array([[0.0, 0.0], [1.0, 0.0], [1.0, 1.0], [0.0, 1.0]]),\n            \"material\": {\"E\": 1.0e7, \"nu\": 0.25, \"t\": 0.05},\n            \"traction\": {\"edge_nodes\": (1, 2), \"p\": np.array([5.0e4, 0.0])},\n        },\n        {\n            \"coords\": np.array([[0.0, 0.0], [3.0, 0.0], [3.0, 0.1], [0.0, 0.2]]),\n            \"material\": {\"E\": 2.0e9, \"nu\": 0.49, \"t\": 0.01},\n            \"traction\": {\"edge_nodes\": (1, 2), \"p\": np.array([1.0e4, 0.0])},\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        coords = case[\"coords\"]\n        \n        # Triangulation A: diagonal 0-2 -> triangles (0,1,2) and (0,2,3)\n        triangles_A = [np.array([0, 1, 2]), np.array([0, 2, 3])]\n        U_A = compute_displacements(coords, triangles_A, case[\"material\"], case[\"traction\"])\n\n        # Triangulation B: diagonal 1-3 -> triangles (0,1,3) and (1,2,3)\n        triangles_B = [np.array([0, 1, 3]), np.array([1, 2, 3])]\n        U_B = compute_displacements(coords, triangles_B, case[\"material\"], case[\"traction\"])\n\n        # Compute the Euclidean norm of the difference vector\n        norm_diff = np.linalg.norm(U_A - U_B)\n        results.append(norm_diff)\n\n    formatted_results = [f\"{res:.9g}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\n\ndef compute_displacements(coords, triangles, material, traction):\n    \"\"\"\n    Computes the nodal displacements for a given mesh, material, and loading.\n\n    Args:\n        coords (np.ndarray): Nodal coordinates, shape (num_nodes, 2).\n        triangles (list of np.ndarray): List of triangles, each defined by 3 node indices.\n        material (dict): Dictionary with keys 'E', 'nu', 't'.\n        traction (dict): Dictionary with keys 'edge_nodes', 'p'.\n\n    Returns:\n        np.ndarray: The global displacement vector of shape (num_nodes*2,).\n    \"\"\"\n    num_nodes = coords.shape[0]\n    num_dofs = num_nodes * 2\n    K_global = np.zeros((num_dofs, num_dofs))\n    F_global = np.zeros(num_dofs)\n\n    # Material properties\n    E, nu, t = material['E'], material['nu'], material['t']\n\n    # Constitutive matrix for plane stress\n    C = (E / (1 - nu**2)) * np.array([\n        [1, nu, 0],\n        [nu, 1, 0],\n        [0, 0, (1 - nu) / 2]\n    ])\n\n    # Assemble global stiffness matrix\n    for tri_nodes in triangles:\n        n1, n2, n3 = tri_nodes\n        c1, c2, c3 = coords[n1], coords[n2], coords[n3]\n        \n        # Calculate element area (ensuring counter-clockwise ordering)\n        area = 0.5 * np.linalg.det(np.array([[1, c1[0], c1[1]], [1, c2[0], c2[1]], [1, c3[0], c3[1]]]))\n        \n        # Strain-displacement matrix (B)\n        y23 = c2[1] - c3[1]\n        y31 = c3[1] - c1[1]\n        y12 = c1[1] - c2[1]\n        x32 = c3[0] - c2[0]\n        x13 = c1[0] - c3[0]\n        x21 = c2[0] - c1[0]\n\n        B = (1 / (2 * area)) * np.array([\n            [y23, 0,   y31, 0,   y12, 0  ],\n            [0,   x32, 0,   x13, 0,   x21],\n            [x32, y23, x13, y31, x21, y12]\n        ])\n\n        # Element stiffness matrix\n        k_elem = t * area * (B.T @ C @ B)\n\n        # Assemble into global matrix\n        dof_map = np.array([2*n1, 2*n1+1, 2*n2, 2*n2+1, 2*n3, 2*n3+1])\n        for i in range(6):\n            for j in range(6):\n                K_global[dof_map[i], dof_map[j]] += k_elem[i, j]\n\n    # Assemble global force vector from traction\n    node_a_idx, node_b_idx = traction['edge_nodes']\n    p_vec = traction['p']\n    \n    coord_a = coords[node_a_idx]\n    coord_b = coords[node_b_idx]\n    edge_length = np.linalg.norm(coord_b - coord_a)\n    \n    # Consistent nodal forces (split equally for linear edge)\n    force_on_node = (edge_length * t / 2) * p_vec\n    \n    F_global[2*node_a_idx : 2*node_a_idx+2] += force_on_node\n    F_global[2*node_b_idx : 2*node_b_idx+2] += force_on_node\n\n    # Apply boundary conditions (nodes 0 and 3 are fixed)\n    fixed_dofs = [0, 1, 6, 7]\n    all_dofs = np.arange(num_dofs)\n    free_dofs = np.setdiff1d(all_dofs, fixed_dofs)\n\n    # Solve the reduced system K_ff * U_f = F_f\n    K_ff = K_global[np.ix_(free_dofs, free_dofs)]\n    F_f = F_global[free_dofs]\n    \n    try:\n        U_f = np.linalg.solve(K_ff, F_f)\n    except np.linalg.LinAlgError:\n        print(\"Error: The stiffness matrix is singular.\")\n        return np.zeros(num_dofs)\n\n    # Reconstruct full displacement vector\n    U_global = np.zeros(num_dofs)\n    U_global[free_dofs] = U_f\n\n    return U_global\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2412649"}, {"introduction": "通常，初始算法生成的网格会包含一些形状不佳的单元，这可能会影响模拟的准确性和稳定性。我们通常可以通过一种称为“平滑”的过程来提高其质量，而无需完全重新生成网格。本高级实践将网格平滑构建为一个数值优化问题，其目标是通过调整节点位置来最小化一个基于单元质量度量的全局“能量”泛函。[@problem_id:2604559] 你将推导此能量泛函的梯度并实现一个基于梯度的优化步骤，从而掌握一个主动提升网格质量的强大工具。", "problem": "给定一个包含节点坐标和单元连接关系的二维三角网格。请基于每个三角形单元的平均比质量度量定义一个能量泛函，并使用带有线搜索步的梯度法，对自由节点的坐标进行最小化。您的任务是从第一性原理出发，推导该能量关于节点坐标的梯度，并实现一个在线搜索步中能够降低能量同时保持边界节点固定的单步线搜索。\n\n基本和核心定义：\n- 一个三角网格由位置为 $\\mathbf{p}_i \\in \\mathbb{R}^2$ 的节点和连接关系为三元组 $(i,j,k)$（索引节点）的三角形单元组成。\n- 对于顶点为 $\\mathbf{p}_1, \\mathbf{p}_2, \\mathbf{p}_3$ 的单个三角形，定义其有向面积为\n$$\nA = \\frac{1}{2} \\left( (\\mathbf{p}_2 - \\mathbf{p}_1) \\times (\\mathbf{p}_3 - \\mathbf{p}_1) \\right)\n$$,\n其中，二维标量叉积定义为 $\\mathbf{u} \\times \\mathbf{v} = u_x v_y - u_y v_x$。\n- 定义边向量 $\\mathbf{e}_1 = \\mathbf{p}_2 - \\mathbf{p}_3$、$\\mathbf{e}_2 = \\mathbf{p}_3 - \\mathbf{p}_1$ 和 $\\mathbf{e}_3 = \\mathbf{p}_1 - \\mathbf{p}_2$，以及边长平方和\n$$\nS = \\lVert \\mathbf{e}_1 \\rVert^2 + \\lVert \\mathbf{e}_2 \\rVert^2 + \\lVert \\mathbf{e}_3 \\rVert^2\n$$.\n- 一个三角形的平均比质量度量的平方定义为\n$$\ng = \\frac{48 A^2}{S^2}\n$$,\n该度量满足 $0 \\le g \\le 1$，对于等边三角形，$g=1$。基于此，定义每个单元的能量为\n$$\n\\phi = 1 - g = 1 - \\frac{48 A^2}{S^2}.\n$$\n- 对于一个有 $M$ 个三角形的网格，其全局能量泛函为\n$$\nE(\\mathbf{P}) = \\sum_{e=1}^{M} \\phi_e,\n$$\n其中 $\\mathbf{P}$ 堆叠了所有节点的坐标。\n\n推导任务：\n1. 根据以上定义，推导单元能量 $\\phi$ 关于节点坐标 $\\mathbf{p}_1, \\mathbf{p}_2, \\mathbf{p}_3$ 的梯度。仅使用面积、边长的定义以及标准微分法则作为出发点。特别地，使用以下事实：$A = \\tfrac{1}{2}(\\mathbf{p}_2 - \\mathbf{p}_1)^T \\mathbf{Z} (\\mathbf{p}_3 - \\mathbf{p}_1)$（其中 $\\mathbf{Z}=\\begin{bmatrix}0 & -1 \\\\ 1 & 0\\end{bmatrix}$），以及 $\\nabla_{\\mathbf{x}} \\lVert \\mathbf{x} - \\mathbf{a} \\rVert^2 = 2(\\mathbf{x} - \\mathbf{a})$。除这些核心定义外，不要假定任何捷径公式。\n2. 通过对所有单元的贡献求和，组装全局梯度 $\\nabla E(\\mathbf{P})$。将一些节点视为固定节点（边界节点），其余节点视为自由节点；更新只应用于自由节点。\n3. 实现一个带有 Armijo 条件的回溯线搜索单步，以选择沿限于自由节点的最速下降方向的步长 $\\alpha$。具体来说，对于给定的初始步长 $\\alpha_0$、缩减因子 $\\beta$（其中 $0  \\beta  1$）和 Armijo 参数 $c_1$（其中 $0  c_1  1$），搜索步长 $\\alpha$，从 $\\alpha_0$ 开始，然后乘以 $\\beta$，直到满足 Armijo 条件：$E(\\mathbf{P} + \\alpha \\mathbf{d}) \\le E(\\mathbf{P}) + c_1 \\alpha \\nabla E(\\mathbf{P})^T \\mathbf{d}$。\n\n测试案例：\n您的实现将被评估是否能通过以下四个测试案例。这些案例将验证您梯度计算的正确性、线搜索的能量下降能力，以及在退化情况下的稳定性。\n- 案例 1：将您的解析梯度与通过中心差分计算的有限差分梯度进行比较，以验证其正确性。报告归一化后的差异范数。\n- 案例 2：在一个略微扰动的结构化网格上应用一个优化步骤，其中只有一个内部节点是自由的。验证总能量是否降低。\n- 案例 3：在一个只有一个自由内部节点的非结构化扇形网格上应用一个优化步骤。验证总能量是否降低。\n- 案例 4：在一个完美的等边三角形上应用一个优化步骤，所有节点都是自由的。验证能量几乎没有变化，表明您的方法在最优配置下是稳定的。\n\n输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，例如 $[0.0001,True,True,1e-15]$。\n- 第一个结果是案例1中解析梯度和有限差分梯度之间差异的相对范数，应为浮点数。\n- 第二个和第三个结果是案例2和案例3的布尔值，指示能量是否降低。\n- 第四个结果是案例4中初始能量和最终能量之间差异的绝对值，应为浮点数。\n- 最终结果不需要四舍五入。\n- 该程序必须是自包含的，不需要任何输入，并且可以按原样运行。", "solution": "所提出的问题是计算几何和数值方法中的一个适定且标准的任务，特别是在有限元方法中网格质量优化的背景下。它具有科学依据，内容自洽且客观。推导和实现所需的所有必要定义和数据均已提供。因此，该问题是有效的，有必要给出解答。\n\n主要任务是推导每个单元的能量泛函 $\\phi_e$ 相对于其顶点坐标的梯度。对于一个顶点为 $\\mathbf{p}_1, \\mathbf{p}_2, \\mathbf{p}_3 \\in \\mathbb{R}^2$ 的三角形，其单元能量由下式给出：\n$$\n\\phi = 1 - g = 1 - \\frac{48 A^2}{S^2}\n$$\n其中 $A$ 是三角形的有向面积，$S$ 是其边长的平方和。我们的目标是计算 $k \\in \\{1, 2, 3\\}$ 的 $\\nabla_{\\mathbf{p}_k} \\phi$。\n\n使用链式法则，$\\phi$ 的梯度为：\n$$\n\\nabla_{\\mathbf{p}_k} \\phi = - \\nabla_{\\mathbf{p}_k} g = -48 \\, \\nabla_{\\mathbf{p}_k} \\left( \\frac{A^2}{S^2} \\right)\n$$\n应用向量微分的商法则，其中 $u = A^2$ 且 $v = S^2$：\n$$\n\\nabla_{\\mathbf{p}_k} \\left( \\frac{A^2}{S^2} \\right) = \\frac{(\\nabla_{\\mathbf{p}_k} A^2) S^2 - A^2 (\\nabla_{\\mathbf{p}_k} S^2)}{S^4}\n$$\n我们有 $\\nabla_{\\mathbf{p}_k} A^2 = 2A \\nabla_{\\mathbf{p}_k} A$ 和 $\\nabla_{\\mathbf{p}_k} S^2 = 2S \\nabla_{\\mathbf{p}_k} S$。代入可得：\n$$\n\\nabla_{\\mathbf{p}_k} \\left( \\frac{A^2}{S^2} \\right) = \\frac{(2A \\nabla_{\\mathbf{p}_k} A) S^2 - A^2 (2S \\nabla_{\\mathbf{p}_k} S)}{S^4} = \\frac{2AS(S \\nabla_{\\mathbf{p}_k} A - A \\nabla_{\\mathbf{p}_k} S)}{S^4} = 2A \\frac{S \\nabla_{\\mathbf{p}_k} A - A \\nabla_{\\mathbf{p}_k} S}{S^3}\n$$\n因此，能量泛函 $\\phi$ 的梯度为：\n$$\n\\nabla_{\\mathbf{p}_k} \\phi = -96A \\frac{S (\\nabla_{\\mathbf{p}_k} A) - A (\\nabla_{\\mathbf{p}_k} S)}{S^3}\n$$\n为了完成推导，我们必须求出面积 $A$ 和边长平方和 $S$ 的梯度。\n\n首先，我们推导面积 $A$ 的梯度。问题提供了表达式 $A = \\frac{1}{2}(\\mathbf{p}_2 - \\mathbf{p}_1)^T \\mathbf{Z} (\\mathbf{p}_3 - \\mathbf{p}_1)$，其中 $\\mathbf{Z} = \\begin{bmatrix} 0  -1 \\\\ 1  0 \\end{bmatrix}$。让我们计算 $\\nabla_{\\mathbf{p}_1} A$。使用矩阵演算的乘积法则和恒等式 $\\mathbf{Z}^T = -\\mathbf{Z}$，$f(\\mathbf{x}) = (\\mathbf{a}-\\mathbf{x})^T \\mathbf{M} (\\mathbf{b}-\\mathbf{x})$ 对 $\\mathbf{x}$ 的导数为 $\\nabla_{\\mathbf{x}} f = -(\\mathbf{M}(\\mathbf{b}-\\mathbf{x}) + \\mathbf{M}^T(\\mathbf{a}-\\mathbf{x}))$。对于 $A$，我们有 $\\mathbf{x}=\\mathbf{p}_1, \\mathbf{a}=\\mathbf{p}_2, \\mathbf{b}=\\mathbf{p}_3$ 和 $\\mathbf{M}=\\frac{1}{2}\\mathbf{Z}$。\n$$\n\\nabla_{\\mathbf{p}_1} A = -\\left( \\frac{1}{2}\\mathbf{Z}(\\mathbf{p}_3 - \\mathbf{p}_1) + \\frac{1}{2}\\mathbf{Z}^T(\\mathbf{p}_2 - \\mathbf{p}_1) \\right) = -\\frac{1}{2}\\left( \\mathbf{Z}(\\mathbf{p}_3 - \\mathbf{p}_1) - \\mathbf{Z}(\\mathbf{p}_2 - \\mathbf{p}_1) \\right) = -\\frac{1}{2}\\mathbf{Z}(\\mathbf{p}_3 - \\mathbf{p}_2) = \\frac{1}{2}\\mathbf{Z}(\\mathbf{p}_2 - \\mathbf{p}_3)\n$$\n通过循环置换或类似的推导，我们找到所有三个顶点的梯度。使用边向量的定义 $\\mathbf{e}_1 = \\mathbf{p}_2 - \\mathbf{p}_3$、$\\mathbf{e}_2 = \\mathbf{p}_3 - \\mathbf{p}_1$ 和 $\\mathbf{e}_3 = \\mathbf{p}_1 - \\mathbf{p}_2$：\n$$\n\\nabla_{\\mathbf{p}_1} A = \\frac{1}{2}\\mathbf{Z}\\mathbf{e}_1 \\quad, \\quad \\nabla_{\\mathbf{p}_2} A = \\frac{1}{2}\\mathbf{Z}\\mathbf{e}_2 \\quad, \\quad \\nabla_{\\mathbf{p}_3} A = \\frac{1}{2}\\mathbf{Z}\\mathbf{e}_3\n$$\n其次，我们推导 $S = \\lVert \\mathbf{e}_1 \\rVert^2 + \\lVert \\mathbf{e}_2 \\rVert^2 + \\lVert \\mathbf{e}_3 \\rVert^2$ 的梯度。\n$$\nS = \\lVert \\mathbf{p}_2 - \\mathbf{p}_3 \\rVert^2 + \\lVert \\mathbf{p}_3 - \\mathbf{p}_1 \\rVert^2 + \\lVert \\mathbf{p}_1 - \\mathbf{p}_2 \\rVert^2\n$$\n使用恒等式 $\\nabla_{\\mathbf{x}} \\lVert \\mathbf{x} - \\mathbf{a} \\rVert^2 = 2(\\mathbf{x} - \\mathbf{a})$，我们计算 $S$ 相对于 $\\mathbf{p}_1$ 的梯度：\n$$\n\\nabla_{\\mathbf{p}_1} S = \\nabla_{\\mathbf{p}_1} \\lVert \\mathbf{p}_2 - \\mathbf{p}_3 \\rVert^2 + \\nabla_{\\mathbf{p}_1} \\lVert \\mathbf{p}_3 - \\mathbf{p}_1 \\rVert^2 + \\nabla_{\\mathbf{p}_1} \\lVert \\mathbf{p}_1 - \\mathbf{p}_2 \\rVert^2\n$$\n$$\n\\nabla_{\\mathbf{p}_1} S = 0 + 2(\\mathbf{p}_1 - \\mathbf{p}_3) + 2(\\mathbf{p}_1 - \\mathbf{p}_2) = 4\\mathbf{p}_1 - 2\\mathbf{p}_2 - 2\\mathbf{p}_3\n$$\n通过循环置换，相对于所有顶点的梯度为：\n$$\n\\nabla_{\\mathbf{p}_1} S = 4\\mathbf{p}_1 - 2\\mathbf{p}_2 - 2\\mathbf{p}_3 \\\\\n\\nabla_{\\mathbf{p}_2} S = 4\\mathbf{p}_2 - 2\\mathbf{p}_3 - 2\\mathbf{p}_1 \\\\\n\\nabla_{\\mathbf{p}_3} S = 4\\mathbf{p}_3 - 2\\mathbf{p}_1 - 2\\mathbf{p}_2\n$$\n将 $\\nabla_{\\mathbf{p}_k} A$ 和 $\\nabla_{\\mathbf{p}_k} S$ 的这些表达式代入 $\\nabla_{\\mathbf{p}_k} \\phi$ 的公式中，即可得到实现所需的最终解析梯度表达式。令 $\\mathbf{g}_{A,k} = \\nabla_{\\mathbf{p}_k} A$ 和 $\\mathbf{g}_{S,k} = \\nabla_{\\mathbf{p}_k} S$。顶点 $\\mathbf{p}_k$ 的能量梯度为：\n$$\n\\nabla_{\\mathbf{p}_k} \\phi = -96 A \\frac{S \\, \\mathbf{g}_{A,k} - A \\, \\mathbf{g}_{S,k}}{S^3}\n$$\n全局梯度 $\\nabla E(\\mathbf{P})$ 是通过将每个单元 $e$ 对其相应全局节点 $k$ 的贡献 $\\nabla_{\\mathbf{p}_k} \\phi_e$ 相加来组装的。\n\n对于优化步骤，使用回溯线搜索。搜索方向 $\\mathbf{d}$ 是全局梯度的负值，且仅限于自由节点：如果节点 $i$ 是自由的，则 $\\mathbf{d}_i = -\\nabla_{\\mathbf{p}_i} E$；如果是固定的，则 $\\mathbf{d}_i = \\mathbf{0}$。使用 Armijo 条件来找到合适的步长 $\\alpha$：\n$$\nE(\\mathbf{P} + \\alpha \\mathbf{d}) \\le E(\\mathbf{P}) + c_1 \\alpha \\nabla E(\\mathbf{P})^T \\mathbf{d}\n$$\n对于某个常数 $c_1 \\in (0,1)$。从初始的 $\\alpha_0$ 开始，将 $\\alpha$ 以因子 $\\beta \\in (0,1)$ 递减，直到满足此条件。", "answer": "```python\nimport numpy as np\n\ndef element_energy_and_grad(p1, p2, p3):\n    \"\"\"\n    Computes the energy and gradient for a single triangular element.\n\n    Args:\n        p1 (np.ndarray): Coordinates of vertex 1.\n        p2 (np.ndarray): Coordinates of vertex 2.\n        p3 (np.ndarray): Coordinates of vertex 3.\n\n    Returns:\n        tuple: A tuple containing the element energy (float) and a (3, 2) numpy\n               array of gradients with respect to each vertex.\n    \"\"\"\n    p = np.array([p1, p2, p3], dtype=float)\n    \n    # Edge vectors as defined in the problem: e_i is opposite p_i\n    e1_vec = p[1, :] - p[2, :]\n    e2_vec = p[2, :] - p[0, :]\n    e3_vec = p[0, :] - p[1, :]\n    \n    # Sum of squared edge lengths, S\n    S = np.sum(e1_vec**2) + np.sum(e2_vec**2) + np.sum(e3_vec**2)\n    \n    # Handle case of coincident points\n    if S  1e-14:\n        return 1.0, np.zeros((3, 2))\n\n    # Oriented area, A\n    A = 0.5 * (p1[0]*(p2[1]-p3[1]) + p2[0]*(p3[1]-p1[1]) + p3[0]*(p1[1]-p2[1]))\n    \n    # Handle degenerate triangle (zero area)\n    if abs(A)  1e-14:\n        # For A=0, g=0, phi=1. The gradient of g is zero, so grad of phi is also zero.\n        return 1.0, np.zeros((3, 2))\n\n    # Per-element energy, phi\n    g = 48.0 * A**2 / S**2\n    phi = 1.0 - g\n    \n    # Gradient of Area, grad(A) w.r.t. p1, p2, p3\n    Z = np.array([[0, -1], [1, 0]])\n    grad_A_p1 = 0.5 * (Z @ e1_vec)\n    grad_A_p2 = 0.5 * (Z @ e2_vec)\n    grad_A_p3 = 0.5 * (Z @ e3_vec)\n    \n    # Gradient of S, grad(S) w.r.t. p1, p2, p3\n    grad_S_p1 = 4*p[0] - 2*p[1] - 2*p[2]\n    grad_S_p2 = 4*p[1] - 2*p[0] - 2*p[2]\n    grad_S_p3 = 4*p[2] - 2*p[0] - 2*p[1]\n    \n    # Gradient of phi, grad(phi)\n    common_factor = -96.0 * A / S**3\n    \n    grad_phi_p1 = common_factor * (S * grad_A_p1 - A * grad_S_p1)\n    grad_phi_p2 = common_factor * (S * grad_A_p2 - A * grad_S_p2)\n    grad_phi_p3 = common_factor * (S * grad_A_p3 - A * grad_S_p3)\n    \n    grads = np.array([grad_phi_p1, grad_phi_p2, grad_phi_p3])\n    \n    return phi, grads\n\ndef global_energy(nodes, triangles):\n    \"\"\"Computes the total energy of the mesh.\"\"\"\n    total_energy = 0.0\n    for tri in triangles:\n        p1, p2, p3 = nodes[tri[0]], nodes[tri[1]], nodes[tri[2]]\n        phi, _ = element_energy_and_grad(p1, p2, p3)\n        total_energy += phi\n    return total_energy\n\ndef global_energy_and_grad(nodes, triangles):\n    \"\"\"Computes the total energy and its gradient for the mesh.\"\"\"\n    total_energy = 0.0\n    global_grad = np.zeros_like(nodes, dtype=float)\n    \n    for tri_indices in triangles:\n        idx1, idx2, idx3 = tri_indices\n        p1, p2, p3 = nodes[idx1], nodes[idx2], nodes[idx3]\n        \n        phi, element_grads = element_energy_and_grad(p1, p2, p3)\n        \n        total_energy += phi\n        global_grad[idx1] += element_grads[0]\n        global_grad[idx2] += element_grads[1]\n        global_grad[idx3] += element_grads[2]\n        \n    return total_energy, global_grad\n\ndef line_search_step(nodes, triangles, free_nodes_mask, alpha0, beta, c1):\n    \"\"\"Performs a single backtracking line search step.\"\"\"\n    E_initial, grad = global_energy_and_grad(nodes, triangles)\n    \n    d = -grad\n    d[~free_nodes_mask] = 0.0\n    \n    m = np.sum(grad * d)\n    \n    if abs(m)  1e-14:\n        return nodes, False\n\n    alpha = alpha0\n    for _ in range(20):\n        nodes_new = nodes + alpha * d\n        E_new = global_energy(nodes_new, triangles)\n        \n        if E_new = E_initial + c1 * alpha * m:\n            return nodes_new, bool(E_new  E_initial - 1e-12)\n            \n        alpha *= beta\n        \n    return nodes, False\n\ndef solve():\n    \"\"\"Runs all test cases and prints the results.\"\"\"\n\n    # Test Case 1: Analytic vs Finite Difference Gradient\n    p1 = np.array([0.0, 0.0]); p2 = np.array([1.0, 0.0]); p3 = np.array([0.1, 0.9])\n    _, g_analytic_parts = element_energy_and_grad(p1, p2, p3)\n    g_analytic = g_analytic_parts.flatten()\n    g_fd = np.zeros(6)\n    h = 1e-6\n    points = np.array([p1, p2, p3])\n    for i in range(3):\n        for j in range(2):\n            points_p = points.copy(); points_p[i, j] += h / 2\n            phi_p, _ = element_energy_and_grad(points_p[0], points_p[1], points_p[2])\n            points_m = points.copy(); points_m[i, j] -= h / 2\n            phi_m, _ = element_energy_and_grad(points_m[0], points_m[1], points_m[2])\n            g_fd[i*2 + j] = (phi_p - phi_m) / h\n    result1 = np.linalg.norm(g_analytic - g_fd) / (np.linalg.norm(g_analytic) + 1e-12)\n\n    # Test Case 2: Structured Mesh Energy Decrease\n    nodes_tc2 = np.array([[c/2.0, r/2.0] for r in range(3) for c in range(3)], dtype=float)\n    nodes_tc2[4] += np.array([0.2, -0.1])\n    triangles_tc2 = np.array([[0, 1, 4], [0, 4, 3], [1, 2, 5], [1, 5, 4],\n                              [3, 4, 7], [3, 7, 6], [4, 5, 8], [4, 8, 7]], dtype=int)\n    free_mask_tc2 = np.array([i == 4 for i in range(9)], dtype=bool)\n    _, result2 = line_search_step(\n        nodes_tc2, triangles_tc2, free_mask_tc2, alpha0=0.1, beta=0.5, c1=1e-4)\n\n    # Test Case 3: Unstructured Fan Mesh Energy Decrease\n    nodes_tc3 = np.array([[0.0, 0.0], [1.0, 0.0], [0.2, 1.1], [-0.1, 0.8], [0.5, 0.5]])\n    triangles_tc3 = np.array([[0, 1, 4], [1, 2, 4], [2, 3, 4], [3, 0, 4]], dtype=int)\n    free_mask_tc3 = np.array([i == 4 for i in range(5)], dtype=bool)\n    _, result3 = line_search_step(\n        nodes_tc3, triangles_tc3, free_mask_tc3, alpha0=0.5, beta=0.5, c1=1e-4)\n\n    # Test Case 4: Near-Optimal Element Stability\n    nodes_tc4 = np.array([[0.0, 0.0], [1.0, 0.0], [0.5, np.sqrt(3)/2.0]])\n    triangles_tc4 = np.array([[0, 1, 2]], dtype=int)\n    free_mask_tc4 = np.ones(3, dtype=bool)\n    E_initial_tc4 = global_energy(nodes_tc4, triangles_tc4)\n    nodes_new_tc4, _ = line_search_step(\n        nodes_tc4, triangles_tc4, free_mask_tc4, alpha0=0.2, beta=0.5, c1=1e-4)\n    E_final_tc4 = global_energy(nodes_new_tc4, triangles_tc4)\n    result4 = abs(E_final_tc4 - E_initial_tc4)\n    \n    results = [result1, result2, result3, result4]\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2604559"}]}