{"hands_on_practices": [{"introduction": "有限元法的核心在于使用一组基函数来逼近真实的解。因此，理解这些基函数的近似能力至关重要。本练习将引导你验证一维分层二次形函数是否能精确表示线性函数，并量化其对一个简单非线性函数的插值误差[@problem_id:2538578]。通过这个实践，你将加深对有限元插值理论和误差分析的理解。", "problem": "考虑一个长度为 $L$ 的一维杆有限元，占据区间 $x \\in [0,L]$。令参考坐标为 $\\xi \\in [-1,1]$，其与物理坐标的仿射映射关系为 $x(\\xi) = \\frac{L}{2}(1+\\xi)$。一个分层二次近似空间由以下三个形函数定义\n$$\nN_{1}(\\xi) = \\frac{1-\\xi}{2}, \n\\quad\nN_{2}(\\xi) = \\frac{1+\\xi}{2}, \n\\quad\nN_{3}(\\xi) = 1 - \\xi^{2},\n$$\n其中 $N_{1}$ 和 $N_{2}$ 张成线性子空间，$N_{3}$ 是一个在单元端点处为零的二次气泡函数。该插值算子作用于一个足够光滑的标量场 $u(x)$，其形式如下：\n$$\nI_{h}u(x) \\;=\\; u(0)\\,N_{1}(\\xi(x)) \\;+\\; u(L)\\,N_{2}(\\xi(x)) \\;+\\; \\Big(u\\!\\left(\\tfrac{L}{2}\\right) - \\tfrac{u(0)+u(L)}{2}\\Big)\\,N_{3}(\\xi(x)),\n$$\n使得近似值在 $x=0$、$x=L/2$ 和 $x=L$ 处与 $u$ 的值相匹配。\n\n任务：\n1) 仅使用形函数的性质和插值算子 $I_{h}$ 的定义，证明任何具有常数 $a$ 和 $b$ 的仿射函数 $u(x) = a + b x$ 都能被该分层二次函数集精确再生，即在 $[0,L]$ 上有 $I_{h}u(x) \\equiv u(x)$。\n\n2) 对于三次函数 $u(x) = x^{3}$，推导其点态插值误差\n$$\ne(x) \\;=\\; u(x) - I_{h}u(x)\n$$\n在 $[0,L]$ 上的表达式，然后通过计算其 $L^{2}$ 范数的平方\n$$\n\\|e\\|_{L^{2}(0,L)}^{2} \\;=\\; \\int_{0}^{L} \\big(e(x)\\big)^{2}\\,dx\n$$\n来量化该误差，得到一个仅用 $L$ 表示的闭式解析表达式。\n\n请将 $\\|e\\|_{L^{2}(0,L)}^{2}$ 的精确解析表达式（用 $L$ 表示）作为你的最终答案。无需四舍五入。", "solution": "该问题提法恰当，具有科学依据，并包含获得唯一解所需的所有信息。这是有限元方法中关于插值理论和误差分析的一个标准练习。因此，将提供解答。\n\n问题分为两部分。第一部分是证明给定的分层二次插值算子能精确再生任何仿射函数。第二部分是计算三次函数 $u(x) = x^3$ 的插值误差的 $L^2$ 范数的平方。\n\n第1部分：对仿射函数的精确性。\n设仿射函数为 $u(x) = a + bx$，其中 $a, b \\in \\mathbb{R}$ 为常数。我们必须证明其插值函数 $I_h u(x)$ 对于所有 $x \\in [0,L]$ 都与 $u(x)$ 恒等。\n\n插值算子定义为：\n$$\nI_{h}u(x) = u(0)N_{1}(\\xi(x)) + u(L)N_{2}(\\xi(x)) + \\left(u\\left(\\frac{L}{2}\\right) - \\frac{u(0)+u(L)}{2}\\right)N_{3}(\\xi(x))\n$$\n首先，我们在插值点 $x=0$，$x=L/2$ 和 $x=L$ 处计算函数 $u(x)$ 的值：\n$$u(0) = a + b(0) = a$$\n$$u(L) = a + bL$$\n$$u\\left(\\frac{L}{2}\\right) = a + b\\frac{L}{2}$$\n\n接下来，我们计算分层气泡函数 $N_3(\\xi)$ 的系数。该系数由 $c_3 = u(\\frac{L}{2}) - \\frac{u(0)+u(L)}{2}$ 给出。\n代入上面的值：\n$$\nc_3 = \\left(a + \\frac{bL}{2}\\right) - \\frac{a + (a+bL)}{2} = \\left(a + \\frac{bL}{2}\\right) - \\frac{2a+bL}{2} = \\left(a + \\frac{bL}{2}\\right) - \\left(a + \\frac{bL}{2}\\right) = 0\n$$\n由于对于任何仿射函数，$N_3(\\xi)$ 的系数都为零，插值算子简化为：\n$$\nI_h u(x) = u(0) N_1(\\xi(x)) + u(L) N_2(\\xi(x))\n$$\n代入 $u(0)$、$u(L)$、$N_1(\\xi)$ 和 $N_2(\\xi)$ 的表达式：\n$$\nI_h u(x) = a \\left(\\frac{1-\\xi}{2}\\right) + (a+bL) \\left(\\frac{1+\\xi}{2}\\right)\n$$\n我们展开并简化这个表达式：\n$$\nI_h u(x) = \\frac{a - a\\xi + a + a\\xi + bL + bL\\xi}{2} = \\frac{2a + bL + bL\\xi}{2} = a + \\frac{bL}{2}(1+\\xi)\n$$\n现在，我们使用给定的仿射映射 $x(\\xi) = \\frac{L}{2}(1+\\xi)$。将此代入我们得到的 $I_h u(x)$ 表达式中：\n$$\nI_h u(x) = a + b \\left(\\frac{L}{2}(1+\\xi)\\right) = a + bx\n$$\n由于 $u(x) = a + bx$，我们证明了对于任何仿射函数，$I_h u(x) = u(x)$。该插值格式对于次数至多为1的多项式是精确的。\n\n第2部分：对三次函数的误差分析。\n设函数为 $u(x) = x^3$。我们需要求出插值误差 $e(x) = u(x) - I_h u(x)$，并计算其 $L^2$ 范数的平方 $\\|e\\|_{L^2(0,L)}^2$。\n\n首先，我们在插值点计算 $u(x)=x^3$ 的值：\n$$u(0) = 0^3 = 0$$\n$$u(L) = L^3$$\n$$u\\left(\\frac{L}{2}\\right) = \\left(\\frac{L}{2}\\right)^3 = \\frac{L^3}{8}$$\n\n接下来，我们计算插值算子 $I_h u(x)$ 的系数：\n$N_1(\\xi)$ 的系数是 $u(0) = 0$。\n$N_2(\\xi)$ 的系数是 $u(L) = L^3$。\n$N_3(\\xi)$ 的系数是 $c_3 = u(\\frac{L}{2}) - \\frac{u(0)+u(L)}{2}$：\n$$\nc_3 = \\frac{L^3}{8} - \\frac{0 + L^3}{2} = \\frac{L^3}{8} - \\frac{4L^3}{8} = -\\frac{3L^3}{8}\n$$\n因此，插值函数为：\n$$\nI_h u(x) = (0)N_1(\\xi) + (L^3)N_2(\\xi) + \\left(-\\frac{3L^3}{8}\\right)N_3(\\xi) = L^3\\left(\\frac{1+\\xi}{2}\\right) - \\frac{3L^3}{8}\\left(1-\\xi^2\\right)\n$$\n为了求误差，最方便的方法是将 $u(x)$ 表示为参考坐标 $\\xi$ 的函数。使用映射 $x(\\xi) = \\frac{L}{2}(1+\\xi)$：\n$$\nu(x) = x^3 = \\left( \\frac{L}{2}(1+\\xi) \\right)^3 = \\frac{L^3}{8}(1+\\xi)^3\n$$\n误差函数 $e(x)$ 可以写成 $\\xi$ 的函数：\n$$\ne(\\xi) = u(\\xi) - I_h u(\\xi) = \\frac{L^3}{8}(1+\\xi)^3 - \\left[ L^3\\left(\\frac{1+\\xi}{2}\\right) - \\frac{3L^3}{8}\\left(1-\\xi^2\\right) \\right]\n$$\n提出公因式 $\\frac{L^3}{8}$：\n$$\ne(\\xi) = \\frac{L^3}{8} \\left[ (1+\\xi)^3 - 4(1+\\xi) + 3(1-\\xi^2) \\right]\n$$\n展开方括号内的项：\n$$\ne(\\xi) = \\frac{L^3}{8} \\left[ (1+3\\xi+3\\xi^2+\\xi^3) - (4+4\\xi) + (3-3\\xi^2) \\right]\n$$\n合并 $\\xi$ 的同次幂项：\n$$\ne(\\xi) = \\frac{L^3}{8} \\left[ (1-4+3) + (3-4)\\xi + (3-3)\\xi^2 + \\xi^3 \\right] = \\frac{L^3}{8} (\\xi^3 - \\xi)\n$$\n现在我们计算 $L^2$ 范数的平方，$\\|e\\|_{L^2(0,L)}^2 = \\int_0^L (e(x))^2 dx$。我们将此积分转换到参考域 $\\xi \\in [-1,1]$。微分元变换为 $dx = \\frac{dx}{d\\xi}d\\xi = \\frac{L}{2}d\\xi$。\n$$\n\\|e\\|_{L^2(0,L)}^2 = \\int_{-1}^{1} (e(\\xi))^2 \\frac{L}{2} d\\xi = \\int_{-1}^{1} \\left( \\frac{L^3}{8}(\\xi^3-\\xi) \\right)^2 \\frac{L}{2} d\\xi\n$$\n$$\n\\|e\\|_{L^2(0,L)}^2 = \\left(\\frac{L^3}{8}\\right)^2 \\frac{L}{2} \\int_{-1}^{1} (\\xi^3-\\xi)^2 d\\xi = \\frac{L^6}{64} \\frac{L}{2} \\int_{-1}^{1} (\\xi^6 - 2\\xi^4 + \\xi^2) d\\xi = \\frac{L^7}{128} \\int_{-1}^{1} (\\xi^6 - 2\\xi^4 + \\xi^2) d\\xi\n$$\n被积函数是一个偶函数，所以积分值等于从 $0$ 到 $1$ 积分值的两倍：\n$$\n\\int_{-1}^{1} (\\xi^6 - 2\\xi^4 + \\xi^2) d\\xi = 2 \\int_{0}^{1} (\\xi^6 - 2\\xi^4 + \\xi^2) d\\xi = 2 \\left[ \\frac{\\xi^7}{7} - \\frac{2\\xi^5}{5} + \\frac{\\xi^3}{3} \\right]_0^1\n$$\n$$\n= 2 \\left( \\frac{1}{7} - \\frac{2}{5} + \\frac{1}{3} \\right) = 2 \\left( \\frac{15 - 42 + 35}{105} \\right) = 2 \\left( \\frac{8}{105} \\right) = \\frac{16}{105}\n$$\n最后，我们将这个结果代回到范数的表达式中：\n$$\n\\|e\\|_{L^2(0,L)}^2 = \\frac{L^7}{128} \\cdot \\frac{16}{105} = \\frac{L^7}{8 \\cdot 105} = \\frac{L^7}{840}\n$$\n插值误差的 $L^2$ 范数的平方是 $\\frac{L^7}{840}$。", "answer": "$$\n\\boxed{\\frac{L^{7}}{840}}\n$$", "id": "2538578"}, {"introduction": "在理解了形函数的近似能力后，下一步是构建单元刚度矩阵，这通常需要进行数值积分。为了确保计算的精确性和效率，选择合适的数值积分方案是关键一步。本练习将挑战你确定一个能够精确积分一维分层二次单元所有刚度矩阵项所需的最小高斯点数[@problem_id:2538587]。这个过程将揭示形函数导数、雅可比行列式和积分阶次之间的内在联系。", "problem": "考虑一个一维杆有限元，其二次分层形函数定义在参考区间 $\\left[-1,1\\right]$ 上。设分层基函数选为两个线性的端点函数和一个内部的富集（气泡）函数，\n$$\nN_{1}(\\xi)=\\frac{1-\\xi}{2},\\quad N_{2}(\\xi)=\\frac{1+\\xi}{2},\\quad N_{3}(\\xi)=1-\\xi^{2},\\quad \\xi\\in\\left[-1,1\\right].\n$$\n假设杨氏模量 $E$ 和横截面积 $A$ 为常数，并且从参考坐标 $\\xi$ 到物理坐标 $x$ 的几何映射为线性等参映射，因此雅可比行列式 $J=\\frac{dx}{d\\xi}$ 在单元上为常数。单元刚度矩阵的各项定义为\n$$\nk_{ij}=\\int_{\\Omega_{e}} B_{i}(x)\\,E\\,A\\,B_{j}(x)\\,dx,\\quad B_{i}(x)=\\frac{dN_{i}}{dx},\\quad i,j\\in\\{1,2,3\\}.\n$$\n仅以此定义为出发点，并且不预先假设任何特定的数值积分公式，确定在区间 $\\left[-1,1\\right]$ 上，为使该单元的所有刚度项 $k_{ij}$ 在所述假设下被精确积分，所需的高斯-勒让德积分点 $n$ 的最小整数数量。最终答案以一个无单位的整数形式给出。", "solution": "所述问题具有科学依据，是适定的、客观且自洽的。这是有限元方法中的一个标准问题。验证成功。\n\n目标是确定为精确积分所有刚度矩阵项 $k_{ij}$ 所需的高斯-勒让德积分点 $n$ 的最小整数数量。在参考区间 $\\left[-1,1\\right]$ 上，$n$ 点的高斯-勒让德积分方案可以精确积分最高为 $p = 2n-1$ 次的多项式。因此，问题简化为找出用于计算刚度项的被积函数的最高多项式次数。\n\n刚度矩阵项 $k_{ij}$ 由在物理单元域 $\\Omega_{e}$ 上的积分定义：\n$$\nk_{ij}=\\int_{\\Omega_{e}} B_{i}(x)\\,E\\,A\\,B_{j}(x)\\,dx\n$$\n这里，$E$ 是杨氏模量，$A$ 是横截面积，两者都假设为常数。应变-位移矩阵分量 $B_{i}(x)$ 是形函数 $N_{i}$ 相对于物理坐标 $x$ 的导数：\n$$\nB_{i}(x) = \\frac{dN_{i}}{dx}\n$$\n为了计算该积分，我们必须将其从物理坐标 $x$ 变换到参考坐标 $\\xi \\in \\left[-1,1\\right]$。问题陈述中使用了线性等参映射，这意味着变换的雅可比行列式 $J = \\frac{dx}{d\\xi}$ 是常数。微分长度元变换为 $dx = J\\,d\\xi$。\n\n使用链式法则，关于 $x$ 的导数与关于 $\\xi$ 的导数关系如下：\n$$\n\\frac{dN_{i}}{dx} = \\frac{dN_{i}}{d\\xi}\\frac{d\\xi}{dx} = \\frac{1}{J}\\frac{dN_{i}}{d\\xi}\n$$\n将这些表达式代入 $k_{ij}$ 的积分中：\n$$\nk_{ij} = \\int_{-1}^{1} \\left(\\frac{1}{J}\\frac{dN_{i}}{d\\xi}\\right) E A \\left(\\frac{1}{J}\\frac{dN_{j}}{d\\xi}\\right) (J\\,d\\xi)\n$$\n由于 $E$、$A$ 和 $J$ 都是常数，我们可以简化此表达式：\n$$\nk_{ij} = \\frac{EA}{J} \\int_{-1}^{1} \\left(\\frac{dN_{i}}{d\\xi}\\right) \\left(\\frac{dN_{j}}{d\\xi}\\right) d\\xi\n$$\n常数前置因子 $\\frac{EA}{J}$ 不影响被积函数的多项式次数。被积函数为 $I_{ij}(\\xi) = \\left(\\frac{dN_{i}}{d\\xi}\\right) \\left(\\frac{dN_{j}}{d\\xi}\\right)$。我们必须找出对于所有 $i,j \\in \\{1, 2, 3\\}$，$I_{ij}(\\xi)$ 的最高多项式次数。\n\n首先，我们计算给定分层形函数关于 $\\xi$ 的导数：\n$$\nN_{1}(\\xi)=\\frac{1-\\xi}{2} \\implies \\frac{dN_{1}}{d\\xi} = -\\frac{1}{2}\n$$\n$$\nN_{2}(\\xi)=\\frac{1+\\xi}{2} \\implies \\frac{dN_{2}}{d\\xi} = \\frac{1}{2}\n$$\n$$\nN_{3}(\\xi)=1-\\xi^{2} \\implies \\frac{dN_{3}}{d\\xi} = -2\\xi\n$$\n这些导数分别是 $0$ 次、$0$ 次和 $1$ 次的多项式。令 $P[f(\\xi)]$ 表示函数 $f(\\xi)$ 的多项式次数。\n\n现在，我们确定所有唯一对 $(i,j)$ 的被积函数 $I_{ij}(\\xi)$ 的次数：\n- 对于 $(i,j) = (1,1)$：$I_{11}(\\xi) = (-\\frac{1}{2})(-\\frac{1}{2}) = \\frac{1}{4}$。次数为 $P[I_{11}] = 0$。\n- 对于 $(i,j) = (1,2)$：$I_{12}(\\xi) = (-\\frac{1}{2})(\\frac{1}{2}) = -\\frac{1}{4}$。次数为 $P[I_{12}] = 0$。\n- 对于 $(i,j) = (1,3)$：$I_{13}(\\xi) = (-\\frac{1}{2})(-2\\xi) = \\xi$。次数为 $P[I_{13}] = 1$。\n- 对于 $(i,j) = (2,2)$：$I_{22}(\\xi) = (\\frac{1}{2})(\\frac{1}{2}) = \\frac{1}{4}$。次数为 $P[I_{22}] = 0$。\n- 对于 $(i,j) = (2,3)$：$I_{23}(\\xi) = (\\frac{1}{2})(-2\\xi) = -\\xi$。次数为 $P[I_{23}] = 1$。\n- 对于 $(i,j) = (3,3)$：$I_{33}(\\xi) = (-2\\xi)(-2\\xi) = 4\\xi^{2}$。次数为 $P[I_{33}] = 2$。\n\n在所有被积函数 $I_{ij}(\\xi)$ 中找到的最高多项式次数 $p_{\\text{max}}$ 为 $2$，它出现在 $k_{33}$ 项中。\n\n要精确积分一个次数为 $p_{\\text{max}}$ 的多项式，高斯-勒让德积分点数 $n$ 必须满足条件：\n$$\n2n - 1 \\ge p_{\\text{max}}\n$$\n代入 $p_{\\text{max}} = 2$：\n$$\n2n - 1 \\ge 2\n$$\n解出 $n$：\n$$\n2n \\ge 3\n$$\n$$\nn \\ge 1.5\n$$\n由于积分点数 $n$ 必须是整数，满足此不等式的最小整数值为 $n=2$。因此，需要 $2$ 个高斯-勒让德积分点才能精确积分刚度矩阵的所有项。", "answer": "$$\\boxed{2}$$", "id": "2538587"}, {"introduction": "分层基函数的一个显著优势是它们天然支持高效的计算技术，例如静态凝聚。由于高阶“气泡”形函数的自由度完全局限于单元内部，我们可以在全局组装前将其在单元层面精确消除。本练习是一个综合性的编程实践，你将实现并验证静态凝聚过程，证明其在不损失节点位移解精度的情况下，能够有效减小全局系统规模[@problem_id:2538553]。", "problem": "实现一个一维有限元求解器，用于求解轴向受载杆，每个网格区间上使用一个二次分层单元。每个单元有两个端节点自由度和一个内部分层气泡自由度，其形函数在单元两端为零。从虚功原理、父域上的形函数定义以及小应变线性弹性理论出发，构建单元刚度矩阵和一致单元载荷向量。然后通过两种方式组装全局系统：(i) 包含所有端节点和内部气泡未知量的完整系统，以及 (ii) 在单元级别通过精确 Schur 补消除法消去内部气泡未知量的静力凝聚系统。在相同的边界条件和载荷下求解这两个全局系统，并在一系列测试案例中验证端节点位移和端节点力残差在指定公差范围内匹配。\n\n基本原理：\n- 虚功原理指出，对于处于轴向变形的弹性杆，通过要求对于所有虚位移，内部虚功等于外部虚功，可以获得离散平衡，从而得到线性系统 $$\\mathbf{K}\\,\\mathbf{u}=\\mathbf{F},$$ 其中 $$\\mathbf{K}$$ 是由单元贡献组装而成的全局刚度矩阵，$$\\mathbf{u}$$ 是全局位移向量，$$\\mathbf{F}$$ 是由体力及面力组装而成的全局载荷向量。\n- 在一个父坐标 $$\\xi\\in[-1,1]$$ 上，通过雅可比 $$J=L/2$$ 仿射映射到一个长度为 $$L$$ 的物理单元，使用以下分层形函数\n  $$N_{1}(\\xi)=\\frac{1-\\xi}{2},\\quad N_{2}(\\xi)=\\frac{1+\\xi}{2},\\quad N_{3}(\\xi)=1-\\xi^{2},$$\n  其中 $$N_{3}(\\pm 1)=0$$，因此相关自由度是单元内部的。轴向应变为 $$\\varepsilon=\\mathrm{d}u/\\mathrm{d}x,$$，其中 $$u(x)=\\sum_{a=1}^{3}N_{a}(\\xi(x))\\,d_{a}.$$\n- 单元刚度和一致载荷由下式得出\n  $$\\mathbf{K}^{e}=\\int_{-1}^{1}\\left(\\frac{\\mathrm{d}\\mathbf{N}}{\\mathrm{d}x}\\right)^{\\!\\!T} E A \\left(\\frac{\\mathrm{d}\\mathbf{N}}{\\mathrm{d}x}\\right) J\\,\\mathrm{d}\\xi,\\qquad \\mathbf{f}^{e}=\\int_{-1}^{1}\\mathbf{N}^{T} b\\, J\\,\\mathrm{d}\\xi,$$\n  其中 $$E$$ 是杨氏模量，$$A$$ 是横截面积，$$b$$ 是单位长度的体力密度。端部面力在全局组装时作为边界节点上的节点力计入。\n- 静力凝聚通过应用对应于主（端节点）和内部（气泡）未知量的单元级分区的 Schur 补，精确地消除了每个单元的内部气泡自由度，从而产生对全局节点系统的凝聚单元贡献，而不会损失节点解的精度。\n\n你的程序必须：\n- 使用上述分层形函数，并对在 $$\\xi\\in[-1,1]$$ 上产生的多项式采用精确的数值积分方法，推导并实现单元矩阵。\n- 为每个测试案例组装并求解完整全局系统（包括内部气泡未知量）和凝聚全局系统（逐单元消除气泡）。\n- 通过在指定节点直接指定位移值来施加本质边界条件。\n- 对两种公式计算全局系统上的节点力残差 $$\\mathbf{r}=\\mathbf{K}\\mathbf{u}-\\mathbf{F}$$。对于约束节点，这些残差与反力一致；对于自由节点，在平衡状态下它们应在数值上为零。\n- 对于每个测试案例，验证完整系统和凝聚系统在两个域端点处的端节点位移和端节点残差在相对公差 $$10^{-9}$$ 和绝对公差 $$10^{-12}$$ 内是相同的。\n\n物理和数值单位：\n- 所有输入均采用国际单位制（SI）：长度单位为米（$$m$$），杨氏模量单位为帕斯卡（$$Pa$$），面积单位为平方米（$$m^{2}$$），体力密度单位为牛顿每米（$$N/m$$），节点载荷单位为牛顿（$$N$$），位移单位为米（$$m$$）。\n- 最终输出仅包含布尔值，因此输出不需要单位。\n\n测试套件：\n对于每个案例，杆被划分为 $$n_{e}$$ 个单元，具有给定的单元长度、材料属性和分布体力。节点载荷作用于全局节点，本质边界条件指定节点位移。使用以下数据。\n\n- 案例 $$1$$（正常路径，混合加载，右端自由）：\n  - 单元数量 $$n_{e}=3.$$\n  - 单元长度 $$\\{0.4,\\,0.3,\\,0.3\\}~m.$$\n  - 每个单元的杨氏模量 $$\\{2.10\\times 10^{11},\\,2.10\\times 10^{11},\\,2.10\\times 10^{11}\\}~Pa.$$\n  - 面积 $$\\{5.0\\times 10^{-4},\\,5.0\\times 10^{-4},\\,5.0\\times 10^{-4}\\}~m^{2}.$$\n  - 体力 $$\\{1.0\\times 10^{3},\\,1.0\\times 10^{3},\\,1.0\\times 10^{3}\\}~N/m.$$\n  - $$4$$ 个全局节点上的节点集中载荷：$$\\{0,\\,0,\\,0,\\,1.0\\times 10^{5}\\}~N.$$\n  - 本质边界条件：左端位移 $$u(0)=0~m.$$\n\n- 案例 $$2$$（边界情况，两端固定，负体力）：\n  - 单元数量 $$n_{e}=1.$$\n  - 单元长度 $$\\{2.0\\}~m.$$\n  - 杨氏模量 $$\\{7.0\\times 10^{10}\\}~Pa.$$\n  - 面积 $$\\{1.0\\times 10^{-3}\\}~m^{2}.$$\n  - 体力 $$\\{-5.0\\times 10^{2}\\}~N/m.$$\n  - $$2$$ 个全局节点上的节点集中载荷：$$\\{0,\\,0\\}~N.$$\n  - 本质边界条件：$$u(0)=0~m,$$ 和 $$u(2.0)=0~m.$$\n\n- 案例 $$3$$（非均质材料和面积，指定右端位移，内部节点载荷）：\n  - 单元数量 $$n_{e}=4.$$\n  - 单元长度 $$\\{0.25,\\,0.25,\\,0.25,\\,0.25\\}~m.$$\n  - 杨氏模量 $$\\{2.0\\times 10^{11},\\,1.5\\times 10^{11},\\,1.0\\times 10^{11},\\,1.2\\times 10^{11}\\}~Pa.$$\n  - 面积 $$\\{8.0\\times 10^{-4},\\,1.2\\times 10^{-3},\\,1.0\\times 10^{-3},\\,9.0\\times 10^{-4}\\}~m^{2}.$$\n  - 体力 $$\\{0,\\,5.0\\times 10^{3},\\,-3.0\\times 10^{3},\\,2.0\\times 10^{3}\\}~N/m.$$\n  - $$5$$ 个全局节点上的节点集中载荷：$$\\{0,\\,0,\\,2.0\\times 10^{3},\\,0,\\,0\\}~N.$$\n  - 本质边界条件：$$u(0)=0~m,$$ 和 $$u(1.0)=1.0\\times 10^{-4}~m.$$\n\n- 案例 $$4$$（强非均质性，混合边界，非零面力符号）：\n  - 单元数量 $$n_{e}=2.$$\n  - 单元长度 $$\\{0.5,\\,1.5\\}~m.$$\n  - 杨氏模量 $$\\{1.0\\times 10^{11},\\,5.0\\times 10^{10}\\}~Pa.$$\n  - 面积 $$\\{7.0\\times 10^{-4},\\,7.0\\times 10^{-4}\\}~m^{2}.$$\n  - 体力 $$\\{1.0\\times 10^{2},\\,0\\}~N/m.$$\n  - $$3$$ 个全局节点上的节点集中载荷：$$\\{0,\\,0,\\,-1.0\\times 10^{4}\\}~N.$$\n  - 本质边界条件：$$u(0)=0~m.$$\n\n算法要求：\n- 在 $$\\xi\\in[-1,1]$$ 上使用至少三点的高斯-勒让德求积法，以精确计算给定多项式场的单元积分。\n- 为完整系统和凝聚系统组装全局矩阵。\n- 通过将系统划分为自由和固定集合并求解简化的线性系统来施加本质边界条件。\n- 为两种公式计算全局节点残差向量 $$\\mathbf{r}=\\mathbf{K}\\mathbf{u}-\\mathbf{F}$$。\n- 对于每个案例，在左右两端节点上比较两种公式的：\n  - 位移，和\n  - 节点残差（在位移被规定的地方等于反力）。\n- 如果两端的节点位移和两端的节点残差在指定的相对公差 $$10^{-9}$$ 和绝对公差 $$10^{-12}$$ 内匹配，则测试案例通过。\n\n最终输出格式：\n- 你的程序应生成一行输出，其中包含四个测试案例的布尔结果，格式为方括号括起来的逗号分隔列表（例如，$$[true,false,true,true]$$，但使用 Python 的布尔值大写形式）。顺序必须是案例 $$1$$、案例 $$2$$、案例 $$3$$、案例 $$4$$。", "solution": "所提出的问题是有限元方法中一个适定且科学上合理的练习，基于线性弹性和计算力学的既定原理。它内容完整、逻辑一致，并且所有提供的数据都符合物理实际。该问题经过验证，可以构建解决方案。\n\n目标是使用特定的二次分层单元，为轴向受载杆实现一个一维有限元求解器。我们必须通过两种方式构建和求解全局系统：一个包含所有自由度（DOF）的完整系统，以及一个在单元级别消除了内自由度的静力凝聚系统。这两种方法的一致性将得到验证。\n\n首先，我们推导单元刚度矩阵 $\\mathbf{K}^e$ 和单元一致载荷向量 $\\mathbf{f}^e$。分析在父单元域 $\\xi \\in [-1, 1]$ 上进行，该域被映射到长度为 $L$ 的物理单元上。此映射的雅可比是 $J = L/2$。\n\n分层形函数如下：\n$$N_{1}(\\xi)=\\frac{1-\\xi}{2},\\quad N_{2}(\\xi)=\\frac{1+\\xi}{2},\\quad N_{3}(\\xi)=1-\\xi^{2}$$\n其中 $N_1$ 和 $N_2$ 与单元的起始和结束节点相关联，而 $N_3$ 是与内部自由度相关联的“气泡”函数，它在单元两端的值为零 ($N_3(\\pm 1) = 0$)。\n\n单元内的轴向位移场 $u$ 被插值为 $u(\\xi) = \\mathbf{N}(\\xi) \\mathbf{d}^e$，其中 $\\mathbf{N} = [N_1, N_2, N_3]$ 且 $\\mathbf{d}^e = [d_1, d_2, d_3]^T$ 是单元节点位移。\n\n轴向应变 $\\varepsilon = du/dx$ 通过链式法则与父坐标导数相关：\n$$\\frac{d}{dx} = \\frac{d\\xi}{dx}\\frac{d}{d\\xi} = \\frac{1}{J}\\frac{d}{d\\xi}$$\n形函数相对于 $\\xi$ 的导数为：\n$$\\frac{dN_1}{d\\xi} = -\\frac{1}{2}, \\quad \\frac{dN_2}{d\\xi} = \\frac{1}{2}, \\quad \\frac{dN_3}{d\\xi} = -2\\xi$$\n因此，应变-位移矩阵 $\\mathbf{B}$ 为：\n$$\\mathbf{B}(\\xi) = \\frac{d\\mathbf{N}}{dx} = \\frac{1}{J} \\frac{d\\mathbf{N}}{d\\xi} = \\frac{1}{J} \\begin{bmatrix} -1/2 & 1/2 & -2\\xi \\end{bmatrix}$$\n\n单元刚度矩阵 $\\mathbf{K}^e$ 由以下公式给出：\n$$\\mathbf{K}^{e}=\\int_{0}^{L} \\mathbf{B}^T E A \\mathbf{B} \\,dx = \\int_{-1}^{1} \\mathbf{B}(\\xi)^T E A \\mathbf{B}(\\xi) J \\,d\\xi$$\n假设杨氏模量 $E$ 和面积 $A$ 在单元内是常数：\n$$\\mathbf{K}^e = EAJ \\int_{-1}^{1} \\left(\\frac{1}{J^2}\\right) \\left(\\frac{d\\mathbf{N}}{d\\xi}\\right)^T \\left(\\frac{d\\mathbf{N}}{d\\xi}\\right) \\,d\\xi = \\frac{EA}{J} \\int_{-1}^{1} \\begin{bmatrix} -1/2 \\\\ 1/2 \\\\ -2\\xi \\end{bmatrix} \\begin{bmatrix} -1/2 & 1/2 & -2\\xi \\end{bmatrix} \\,d\\xi$$\n$$\\mathbf{K}^e = \\frac{EA}{J} \\int_{-1}^{1} \\begin{bmatrix} 1/4 & -1/4 & \\xi \\\\ -1/4 & 1/4 & -\\xi \\\\ \\xi & -\\xi & 4\\xi^2 \\end{bmatrix} \\,d\\xi$$\n多项式项的积分为 $\\int_{-1}^1 1 \\,d\\xi = 2$、$\\int_{-1}^1 \\xi \\,d\\xi = 0$ 和 $\\int_{-1}^1 \\xi^2 \\,d\\xi = 2/3$。使用这些结果：\n$$\\mathbf{K}^e = \\frac{EA}{J} \\begin{bmatrix} 1/2 & -1/2 & 0 \\\\ -1/2 & 1/2 & 0 \\\\ 0 & 0 & 8/3 \\end{bmatrix} = \\frac{2EA}{L} \\begin{bmatrix} 1/2 & -1/2 & 0 \\\\ -1/2 & 1/2 & 0 \\\\ 0 & 0 & 8/3 \\end{bmatrix} = \\frac{EA}{L} \\begin{bmatrix} 1 & -1 & 0 \\\\ -1 & 1 & 0 \\\\ 0 & 0 & 16/3 \\end{bmatrix}$$\n一个关键的观察是刚度矩阵是块对角矩阵。线性节点自由度（$d_1, d_2$）与内部分层自由度（$d_3$）是解耦的。这是因为交叉项导数乘积的积分，例如 $\\frac{dN_1}{d\\xi}\\frac{dN_3}{d\\xi} = \\xi$，在对称域 $[-1, 1]$ 上为零。\n\n由恒定体力 $b$ 引起的一致单元载荷向量 $\\mathbf{f}^e$ 为：\n$$\\mathbf{f}^{e} = \\int_{0}^{L} \\mathbf{N}^T b \\,dx = \\int_{-1}^{1} \\mathbf{N}(\\xi)^T b J \\,d\\xi$$\n$$\\mathbf{f}^e = bJ \\int_{-1}^{1} \\begin{bmatrix} (1-\\xi)/2 \\\\ (1+\\xi)/2 \\\\ 1-\\xi^2 \\end{bmatrix} d\\xi = b \\frac{L}{2} \\begin{bmatrix} 1 \\\\ 1 \\\\ 4/3 \\end{bmatrix}$$\n这些积分将使用3点高斯-勒让德求积法进行数值计算，该方法对最高5次的多项式是精确的，这对于我们最高2次的被积函数是足够的。\n\n对于**完整系统**，我们将 $3 \\times 3$ 单元矩阵组装成一个全局系统。总自由度数将是 $n_{nodes} + n_{elements}$。前 $n_{nodes}$ 个自由度对应于物理节点，随后的 $n_{elements}$ 个自由度对应于每个单元的内部气泡模式。\n\n对于**静力凝聚系统**，我们在单元级别消除内部自由度 $d_3$。一个单元系统被划分为主（p）和内部（i）自由度：\n$$ \\begin{bmatrix} \\mathbf{K}_{pp}  \\mathbf{K}_{pi} \\\\ \\mathbf{K}_{ip}  K_{ii} \\end{bmatrix} \\begin{Bmatrix} \\mathbf{d}_p \\\\ d_i \\end{Bmatrix} = \\begin{Bmatrix} \\mathbf{f}_p \\\\ f_i \\end{Bmatrix} $$\n针对主自由度 $\\mathbf{d}_p$ 的凝聚（Schur 补）系统为 $\\mathbf{K}_{cond}^e \\mathbf{d}_p = \\mathbf{f}_{cond}^e$，其中：\n$$\\mathbf{K}_{cond}^e = \\mathbf{K}_{pp} - \\mathbf{K}_{pi} K_{ii}^{-1} \\mathbf{K}_{ip}$$\n$$\\mathbf{f}_{cond}^e = \\mathbf{f}_p - \\mathbf{K}_{pi} K_{ii}^{-1} f_i$$\n由于我们的 $\\mathbf{K}^e$ 的解耦特性，我们有 $\\mathbf{K}_{pi} = \\mathbf{0}$ 和 $\\mathbf{K}_{ip} = \\mathbf{0}^T$。方程简化为：\n$$\\mathbf{K}_{cond}^e = \\mathbf{K}_{pp} = \\frac{EA}{L} \\begin{bmatrix} 1 & -1 \\\\ -1 & 1 \\end{bmatrix}$$\n$$\\mathbf{f}_{cond}^e = \\mathbf{f}_p = \\frac{bL}{2} \\begin{bmatrix} 1 \\\\ 1 \\end{bmatrix}$$\n这揭示了凝聚系统等效于使用线性杆单元的标准有限元分析。当单元内的材料属性恒定时，气泡函数不会改变节点位移解。\n\n实现将按以下步骤进行：\n1.  对每个测试案例，定义参数。\n2.  一个循环遍历每个单元，使用数值积分计算其刚度矩阵和载荷向量。\n3.  组装完整全局系统矩阵 $(\\mathbf{K}_{full}, \\mathbf{F}_{full})$。该系统的大小为 $(n_{nodes} + n_{elements}) \\times (n_{nodes} + n_{elements})$。\n4.  通过首先对每个单元执行静力凝聚来组装凝聚全局系统矩阵 $(\\mathbf{K}_{cond}, \\mathbf{F}_{cond})$。该系统的大小为 $n_{nodes} \\times n_{nodes}$。\n5.  将节点集中载荷添加到各自的全局力向量中。\n6.  通过将每个系统划分为自由和固定自由度，并为自由自由度求解简化系统，来施加本质边界条件（指定位移）。\n7.  重建完整的位移向量 $(\\mathbf{u}_{full}, \\mathbf{u}_{cond})$。\n8.  使用公式 $\\mathbf{r} = \\mathbf{K}\\mathbf{u} - \\mathbf{F}$ 计算全局节点残差向量 $(\\mathbf{r}_{full}, \\mathbf{r}_{cond})$。\n9.  最后，使用指定的公差 ($rtol=10^{-9}, atol=10^{-12}$) 比较两种解的端节点位移和端节点残差。一个布尔结果表示一个测试案例的所有比较是否通过。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases for the 1D hierarchical FEA solver.\n    \"\"\"\n    test_cases = [\n        { # Case 1\n            \"n_e\": 3,\n            \"lengths\": [0.4, 0.3, 0.3],\n            \"E\": [2.10e11, 2.10e11, 2.10e11],\n            \"A\": [5.0e-4, 5.0e-4, 5.0e-4],\n            \"b\": [1.0e3, 1.0e3, 1.0e3],\n            \"nodal_loads\": [0.0, 0.0, 0.0, 1.0e5],\n            \"bcs\": {0: 0.0}\n        },\n        { # Case 2\n            \"n_e\": 1,\n            \"lengths\": [2.0],\n            \"E\": [7.0e10],\n            \"A\": [1.0e-3],\n            \"b\": [-5.0e2],\n            \"nodal_loads\": [0.0, 0.0],\n            \"bcs\": {0: 0.0, 1: 0.0} \n        },\n        { # Case 3\n            \"n_e\": 4,\n            \"lengths\": [0.25, 0.25, 0.25, 0.25],\n            \"E\": [2.0e11, 1.5e11, 1.0e11, 1.2e11],\n            \"A\": [8.0e-4, 1.2e-3, 1.0e-3, 9.0e-4],\n            \"b\": [0.0, 5.0e3, -3.0e3, 2.0e3],\n            \"nodal_loads\": [0.0, 0.0, 2.0e3, 0.0, 0.0],\n            \"bcs\": {0: 0.0, 4: 1.0e-4}\n        },\n        { # Case 4\n            \"n_e\": 2,\n            \"lengths\": [0.5, 1.5],\n            \"E\": [1.0e11, 5.0e10],\n            \"A\": [7.0e-4, 7.0e-4],\n            \"b\": [1.0e2, 0.0],\n            \"nodal_loads\": [0.0, 0.0, -1.0e4],\n            \"bcs\": {0: 0.0}\n        },\n    ]\n\n    results = []\n    for case_data in test_cases:\n        results.append(run_case(case_data))\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef get_element_matrices(L, E, A, b):\n    \"\"\"\n    Computes element stiffness matrix and load vector using 3-point Gauss quadrature.\n    \"\"\"\n    Ke = np.zeros((3, 3))\n    fe = np.zeros(3)\n    J = L / 2.0\n\n    # 3-point Gauss-Legendre quadrature\n    gauss_points = [-np.sqrt(3.0 / 5.0), 0.0, np.sqrt(3.0 / 5.0)]\n    gauss_weights = [5.0 / 9.0, 8.0 / 9.0, 5.0 / 9.0]\n\n    for xi, w in zip(gauss_points, gauss_weights):\n        # Shape functions N(xi)\n        N = np.array([(1.0 - xi) / 2.0, (1.0 + xi) / 2.0, 1.0 - xi**2])\n        # Derivatives of shape functions w.r.t. xi\n        dN_dxi = np.array([-0.5, 0.5, -2.0 * xi])\n        # B matrix (derivatives of N w.r.t. x)\n        B = dN_dxi / J\n\n        Ke += np.outer(B, B) * E * A * J * w\n        fe += N * b * J * w\n        \n    return Ke, fe\n\ndef solve_system(K, F, bcs, n_dof):\n    \"\"\"\n    Applies boundary conditions and solves the linear system.\n    \"\"\"\n    dof_fixed = np.array(list(bcs.keys()), dtype=int)\n    dof_all = np.arange(n_dof)\n    dof_free = np.setdiff1d(dof_all, dof_fixed)\n\n    u = np.zeros(n_dof)\n    for dof, val in bcs.items():\n        u[dof] = val\n\n    if len(dof_free) > 0:\n        K_ff = K[np.ix_(dof_free, dof_free)]\n        K_fd = K[np.ix_(dof_free, dof_fixed)]\n        F_f = F[dof_free]\n        u_d = u[dof_fixed]\n\n        F_eff = F_f - K_fd @ u_d\n        u[dof_free] = np.linalg.solve(K_ff, F_eff)\n    \n    return u\n\ndef run_case(case):\n    \"\"\"\n    Runs a single test case for both full and condensed systems and compares results.\n    \"\"\"\n    n_e = case[\"n_e\"]\n    n_nodes = n_e + 1\n    \n    # --- Full System ---\n    n_dof_full = n_nodes + n_e\n    K_full = np.zeros((n_dof_full, n_dof_full))\n    F_full = np.zeros(n_dof_full)\n\n    # --- Condensed System ---\n    n_dof_cond = n_nodes\n    K_cond = np.zeros((n_dof_cond, n_dof_cond))\n    F_cond = np.zeros(n_dof_cond)\n\n    for i in range(n_e):\n        L, E, A, b = case[\"lengths\"][i], case[\"E\"][i], case[\"A\"][i], case[\"b\"][i]\n        Ke, fe = get_element_matrices(L, E, A, b)\n        \n        # Assembly for full system\n        node_indices = [i, i + 1]\n        bubble_index = n_nodes + i\n        full_dof_map = np.array([node_indices[0], node_indices[1], bubble_index])\n        K_full[np.ix_(full_dof_map, full_dof_map)] += Ke\n        F_full[full_dof_map] += fe\n\n        # Static condensation and assembly for condensed system\n        K_pp = Ke[:2, :2]\n        K_pi = Ke[:2, 2:3]\n        K_ip = Ke[2:3, :2]\n        K_ii = Ke[2, 2]\n        f_p = fe[:2]\n        f_i = fe[2]\n        \n        K_cond_e = K_pp - (K_pi @ K_ip) / K_ii\n        f_cond_e = f_p - (K_pi.flatten() * f_i) / K_ii\n\n        cond_dof_map = np.array(node_indices)\n        K_cond[np.ix_(cond_dof_map, cond_dof_map)] += K_cond_e\n        F_cond[cond_dof_map] += f_cond_e\n\n    # Add nodal loads\n    F_full[:n_nodes] += case[\"nodal_loads\"]\n    F_cond += case[\"nodal_loads\"]\n\n    # Solve systems\n    bcs_full = case[\"bcs\"]\n    u_full = solve_system(K_full, F_full, bcs_full, n_dof_full)\n    \n    # Remap BCs for condensed system, as they only affect nodes\n    bcs_cond = {k: v for k, v in bcs_full.items() if k  n_nodes}\n    u_cond = solve_system(K_cond, F_cond, bcs_cond, n_dof_cond)\n\n    # Calculate residuals\n    r_full = K_full @ u_full - F_full\n    r_cond = K_cond @ u_cond - F_cond\n\n    # Extract nodal values from full system for comparison\n    u_full_nodes = u_full[:n_nodes]\n    r_full_nodes = r_full[:n_nodes]\n\n    # Comparison\n    rtol, atol = 1e-9, 1e-12\n    \n    disp_left_ok = np.isclose(u_full_nodes[0], u_cond[0], rtol=rtol, atol=atol)\n    disp_right_ok = np.isclose(u_full_nodes[-1], u_cond[-1], rtol=rtol, atol=atol)\n    \n    res_left_ok = np.isclose(r_full_nodes[0], r_cond[0], rtol=rtol, atol=atol)\n    res_right_ok = np.isclose(r_full_nodes[-1], r_cond[-1], rtol=rtol, atol=atol)\n    \n    return all([disp_left_ok, disp_right_ok, res_left_ok, res_right_ok])\n\nsolve()\n```", "id": "2538553"}]}