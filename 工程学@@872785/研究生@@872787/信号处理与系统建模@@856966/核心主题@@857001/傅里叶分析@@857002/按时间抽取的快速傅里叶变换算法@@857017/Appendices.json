{"hands_on_practices": [{"introduction": "DIT-FFT 算法的核心在于其“分治”策略，它将一个大的 DFT 分解为多个小的 DFT。这个过程始于对输入序列进行“位倒序”重排，然后进行多级蝶形运算。本练习将带你亲手实践 DIT-FFT 的初始阶段，通过计算一个 4 点序列在位倒序和第一级蝶形运算后的中间结果，从而牢固掌握该算法的基本力学。[@problem_id:1711383]", "problem": "一个标准的基2时间抽取（DIT）快速傅里叶变换（FFT）算法被用来分析一个4点离散时间信号。该算法首先根据时间索引的比特反转对输入序列 $x[n]$ 进行重排。在此重排之后，第一个计算阶段通过对比特反转序列的相邻对执行2点离散傅里叶变换（DFT）来产生一个中间序列 $G[n]$。\n\n考虑一个由 $x[n] = (1+j)^{n}$ 定义的输入序列，其中 $n=0, 1, 2, 3$，而 $j$ 是满足 $j^2=-1$ 的虚数单位。\n\n计算由4点DIT-FFT算法第一阶段产生的中间序列 $G[n] = \\{G[0], G[1], G[2], G[3]\\}$ 的四个复数值。将你的答案表示为四个复数的序列。", "solution": "我们给定一个4点基2时间抽取FFT。在此算法中，首先通过比特反转时间索引来重排输入 $x[n]$，然后对相邻对执行2点DFT，以产生中间序列 $G[n]$。\n\n首先计算输入样本：\n对于 $x[n]=(1+j)^{n}$，其中 $j^2=-1$：\n$$\nx[0]=(1+j)^{0}=1,\\quad\nx[1]=(1+j)^{1}=1+j,\n$$\n$$\nx[2]=(1+j)^{2}=1+2j+j^{2}=2j,\\quad\nx[3]=(1+j)^{3}=(1+j)\\cdot(1+j)^{2}=(1+j)\\cdot 2j=2j+2j^{2}=-2+2j.\n$$\n\n接下来对索引 $n\\in\\{0,1,2,3\\}$ 应用比特反转。使用2位比特反转：\n$$\n0\\,(00)\\to 0\\,(00),\\quad 1\\,(01)\\to 2\\,(10),\\quad 2\\,(10)\\to 1\\,(01),\\quad 3\\,(11)\\to 3\\,(11).\n$$\n因此，比特反转序列为\n$$\n[x[0],\\,x[2],\\,x[1],\\,x[3]]=[1,\\,2j,\\,1+j,\\,-2+2j].\n$$\n\n第一阶段对相邻对执行2点DFT。对于一对 $(a,b)$，2点DFT产生\n$$\nA[0]=a+b,\\qquad A[1]=a-b.\n$$\n将此应用于两个相邻对：\n\n第1对：$(a,b)=(1,\\,2j)$\n$$\nG[0]=1+2j,\\qquad G[1]=1-2j.\n$$\n\n第2对：$(a,b)=(1+j,\\,-2+2j)$\n$$\nG[2]=(1+j)+(-2+2j)=-1+3j,\\qquad G[3]=(1+j)-(-2+2j)=3-j.\n$$\n\n因此，中间序列为\n$$\nG[n]=\\{\\,1+2j,\\;1-2j,\\;-1+3j,\\;3-j\\,\\}.\n$$", "answer": "$$\\boxed{\\begin{pmatrix}1+2j  1-2j  -1+3j  3-j\\end{pmatrix}}$$", "id": "1711383"}, {"introduction": "高效的 FFT 实现通常采用“就地”计算以节省内存，但这要求输入数据预先经过位倒序排列。本练习将深入探讨位倒序置换这一关键环节，要求你不仅要从第一性原理推导出其数学定义，还要设计一种不依赖循环、仅使用位运算的 $O(1)$ 常数时间算法。这对于理解 FFT 在底层硬件上的高性能实现至关重要。[@problem_id:2863895]", "problem": "设 $N = 2^{p}$，其中整数 $p \\geq 1$。考虑长度为 $N$ 的离散傅里叶变换 (DFT)，其定义为\n$$\nX[k] = \\sum_{n=0}^{N-1} x[n] \\exp\\!\\left(-\\mathrm{j}\\, \\frac{2\\pi}{N} n k\\right).\n$$\n时域抽取（decimation-in-time）快速傅里叶变换 (FFT) 会将输入序列 $x[n]$ 重新排序为比特反转（bit-reversed）索引顺序，从而使得递归的基-2 分解能够实现原位计算（in-place computation），而无需在各阶段之间进行额外的置换。\n\n- 仅使用二进制表示的基本性质和 DFT 的基-2 分解，根据 $n$ 的二进制位，为 $n \\in \\{0,\\dots,2^{p}-1\\}$ 形式化地定义比特反转置换 $r(n)$。你的定义必须精确说明二进制位是如何被置换的，并且不得假定任何关于 $r(n)$ 的先验公式。\n\n- 从关于固定宽度二进制字和比特分组的第一性原理出发，推导出一个仅使用位运算（bitwise operations）来计算 $r(n)$ 的 $O(1)$ 方法（在固定字长下为常数时间）。具体来说，假设机器字长至少为 16 位，并限制 $p \\leq 16$。你可以使用位运算符：位与 &、位或 |、左移 $\\ll$ 和右移 $\\gg$，并且可以使用以 $\\mathtt{0x\\cdots}$ 形式书写的固定十六进制掩码。提供一个有限的、固定的掩码和移位操作序列，该序列对于任何 $n \\in \\{0,\\dots,2^{p}-1\\}$，都能在与 $n$ 和 $p$（其中 $p \\leq 16$）无关的常数步数内生成 $r(n)$。通过将掩码和移位序列的每个阶段与定义明确的比特组反转相关联，来证明其正确性。\n\n- 最后，设 $p=11$ 且 $n=1373$。计算 $r(n)$ 的数值，并以单个十进制整数形式给出最终答案。无需四舍五入。", "solution": "该问题陈述具有科学依据、提法明确且客观。它涉及数字信号处理中的一个基本主题——时域抽取快速傅里叶变换 (FFT) 算法所需的标准比特反转置换。问题被恰当地约束，并要求一个形式化定义、一个算法推导以及一个具体的数值结果。所有必要的信息都已提供，不存在内部矛盾或逻辑缺陷。因此，该问题被认为是有效的，我们可以着手解决。\n\n问题分为三个部分。我们将按顺序解决它们。\n\n首先，我们必须为集合 $\\{0, 1, \\dots, 2^p - 1\\}$ 中的整数 $n$ 形式化地定义比特反转置换 $r(n)$。任何这样的整数 $n$ 都有一个唯一的 $p$ 位二进制表示。设该表示为\n$$\nn = (b_{p-1} b_{p-2} \\dots b_1 b_0)_2\n$$\n其中 $b_j \\in \\{0, 1\\}$ 是第 $j$ 位比特。$n$ 的值由多项式表示给出\n$$\nn = \\sum_{j=0}^{p-1} b_j 2^j\n$$\n比特 $b_j$ 可以通过整数运算从 $n$ 中正式提取：$b_j = \\lfloor n/2^j \\rfloor \\pmod 2$。\n\n比特反转置换 $r(n)$ 是通过反转 $n$ 的二进制表示中比特的顺序而得到的整数。如果 $n$ 的二进制表示如上所述，则 $r(n)$ 的表示为\n$$\nr(n) = (b_0 b_1 \\dots b_{p-2} b_{p-1})_2\n$$\n$r(n)$ 的值因此由相应的多项式表示给出，其中比特 $b_j$ 的权重从 $2^j$ 变为 $2^{p-1-j}$：\n$$\nr(n) = \\sum_{j=0}^{p-1} b_j 2^{p-1-j}\n$$\n这就构成了基于 $n$ 的二进制位的比特反转置换的形式化定义。\n\n其次，我们必须推导一个在 $p \\le 16$ 的情况下，使用位运算来计算 $r(n)$ 的常数时间 $O(1)$ 方法。我们假设整数 $n$ 存储在至少 16 位的机器字中。一个朴素的逐比特反转需要一个 $p$ 次迭代的循环，这在一般意义上不是常数时间，尽管对于固定的字长它是。问题要求一个与 $n$ 和 $p$（对于 $p \\le 16$）无关的固定操作序列方法，这意味着一个并行的比特反转算法。\n\n策略是通过连续交换相邻的比特块来反转比特，其中块的大小在每个阶段都加倍。对于一个 16 位字，这需要 $\\log_2(16) = 4$ 个阶段，外加一个最终的对齐步骤。设初始值为 $n$。我们将每个阶段的结果表示为 $n_k$。\n\n阶段 1：交换相邻的单个比特。\n我们希望交换比特对 $(b_{15}, b_{14})$、$(b_{13}, b_{12})$、...、$(b_1, b_0)$。我们可以通过与 $\\mathtt{0x5555} = (0101010101010101)_2$ 进行掩码操作来分离所有偶数位置上的比特（$b_0, b_2, \\dots, b_{14}$）。我们通过与 $\\mathtt{0xAAAA} = (1010101010101010)_2$ 进行掩码操作来分离所有奇数位置上的比特（$b_1, b_3, \\dots, b_{15}$）。然后我们将偶数位的比特左移 1 位，奇数位的比特右移 1 位，并用位或运算将它们组合起来。\n$$\nn_1 = \\left( (n \\ \\ \\ \\mathtt{0xAAAA}) \\gg 1 \\right) \\ | \\ \\left( (n \\ \\ \\ \\mathtt{0x5555}) \\ll 1 \\right)\n$$\n此操作后，$n_1$ 的比特顺序为 $(b_{14}b_{15}b_{12}b_{13} \\dots b_0b_1)_2$。\n\n阶段 2：交换相邻的 2 比特块。\n现在比特对已按相反顺序排列。接下来我们交换相邻的 2 比特块。例如，我们交换 $(b_{14}b_{15})$ 和 $(b_{12}b_{13})$。我们使用掩码 $\\mathtt{0xCCCC} = (1100110011001100)_2$ 分离每个 4 比特半字节中的高 2 比特块，并将它们右移 2 位。我们使用 $\\mathtt{0x3333} = (0011001100110011)_2$ 分离低 2 比特块，并将它们左移 2 位。\n$$\nn_2 = \\left( (n_1 \\ \\ \\ \\mathtt{0xCCCC}) \\gg 2 \\right) \\ | \\ \\left( (n_1 \\ \\ \\ \\mathtt{0x3333}) \\ll 2 \\right)\n$$\n现在比特顺序为 $(b_{12}b_{13}b_{14}b_{15} \\dots b_0b_1b_2b_3)_2$。\n\n阶段 3：交换相邻的 4 比特块。\n我们继续交换相邻的 4 比特块（半字节）。掩码为 $\\mathtt{0xF0F0} = (1111000011110000)_2$ 和 $\\mathtt{0x0F0F} = (0000111100001111)_2$，移位量为 4。\n$$\nn_3 = \\left( (n_2 \\ \\ \\ \\mathtt{0xF0F0}) \\gg 4 \\right) \\ | \\ \\left( (n_2 \\ \\ \\ \\mathtt{0x0F0F}) \\ll 4 \\right)\n$$\n比特顺序变为 $(b_8 \\dots b_{15} b_0 \\dots b_7)_2$。\n\n阶段 4：交换相邻的 8 比特块。\n最后，我们交换 16 位字的两个 8 位字节。掩码为 $\\mathtt{0xFF00} = (1111111100000000)_2$ 和 $\\mathtt{0x00FF} = (0000000011111111)_2$，移位量为 8。\n$$\nn_4 = \\left( (n_3 \\ \\ \\ \\mathtt{0xFF00}) \\gg 8 \\right) \\ | \\ \\left( (n_3 \\ \\ \\ \\mathtt{0x00FF}) \\ll 8 \\right)\n$$\n执行这四个阶段会导致 16 位字的比特完全反转。如果 $n = (0 \\dots 0 b_{p-1} \\dots b_0)_2$，那么 $n_4 = (b_0 \\dots b_{p-1} 0 \\dots 0)_2$。反转后的 $p$ 比特序列现在占据了 16 位字的最高有效 $p$ 位。\n\n最后一步：对齐。\n为了获得最终的整数值，我们必须将结果右移，以将反转后的比特移到最低有效位置。原始 $p$ 位数（在 16 位字内）的前导零的数量是 $16-p$。这些零已变成尾随零。我们必须按此数量右移。\n$$\nr(n) = n_4 \\gg (16 - p)\n$$\n这个由五个操作（四次交换和一次最终移位）组成的序列对于任何 $n$ 和任何 $p \\le 16$ 都是常数，因此满足 $O(1)$ 的要求。\n\n第三，我们计算当 $p=11$ 且 $n=1373$ 时 $r(n)$ 的数值。\n首先，我们找到 $n=1373$ 的 11 位二进制表示。\n$$\n1373 = 1024 + 256 + 64 + 16 + 8 + 4 + 1\n$$\n$$\n1373 = 1 \\cdot 2^{10} + 0 \\cdot 2^9 + 1 \\cdot 2^8 + 0 \\cdot 2^7 + 1 \\cdot 2^6 + 0 \\cdot 2^5 + 1 \\cdot 2^4 + 1 \\cdot 2^3 + 1 \\cdot 2^2 + 0 \\cdot 2^1 + 1 \\cdot 2^0\n$$\n因此，11 位表示为 $n = (10101011101)_2$。这些比特是 $b_{10} = 1, b_9=0, b_8=1, b_7=0, b_6=1, b_5=0, b_4=1, b_3=1, b_2=1, b_1=0, b_0=1$。\n\n为了找到 $r(n)$，我们将这个比特串反转得到 $(10111010101)_2$。\n现在，我们将这个反转后的二进制数转换回其十进制整数值。\n$$\nr(1373) = (10111010101)_2\n$$\n$$\nr(1373) = 1 \\cdot 2^{10} + 0 \\cdot 2^9 + 1 \\cdot 2^8 + 1 \\cdot 2^7 + 1 \\cdot 2^6 + 0 \\cdot 2^5 + 1 \\cdot 2^4 + 0 \\cdot 2^3 + 1 \\cdot 2^2 + 0 \\cdot 2^1 + 1 \\cdot 2^0\n$$\n$$\nr(1373) = 1 \\cdot 1024 + 0 + 1 \\cdot 256 + 1 \\cdot 128 + 1 \\cdot 64 + 0 + 1 \\cdot 16 + 0 + 1 \\cdot 4 + 0 + 1 \\cdot 1\n$$\n$$\nr(1373) = 1024 + 256 + 128 + 64 + 16 + 4 + 1\n$$\n将这些值相加：\n$$\n1024 + 256 = 1280\n$$\n$$\n1280 + 128 = 1408\n$$\n$$\n1408 + 64 = 1472\n$$\n$$\n1472 + 16 = 1488\n$$\n$$\n1488 + 4 = 1492\n$$\n$$\n1492 + 1 = 1493\n$$\n因此，数值为 $1493$。", "answer": "$$\n\\boxed{1493}\n$$", "id": "2863895"}, {"introduction": "虽然基-2 FFT 算法极大地降低了计算复杂度，但还存在更优化的变体。分裂基 (split-radix) FFT 算法通过一种更精细的分解方式，进一步减少了所需的乘法运算次数，是目前最高效的 FFT 算法之一。本练习将指导你剖析一个 16 点分裂基 DIT-FFT 的递归结构，通过识别和量化其中的“非平凡”乘法，你将能深刻理解算法效率的来源。[@problem_id:2863892]", "problem": "设 $x[n]$ 是一个长度为 $N$ 的序列，其离散傅里叶变换 (DFT) 定义为 $X[k] = \\sum_{n=0}^{N-1} x[n] W_{N}^{nk}$，其中 $W_{N} \\triangleq \\exp(-\\mathrm{j} 2\\pi/N)$ 且 $\\mathrm{j}$ 是虚数单位。时域抽取 (DIT) 分裂基快速傅里叶变换 (FFT) (FFT 代表快速傅里叶变换) 通过将时间索引分裂为偶数索引和模 $4$ 的两个奇数剩余类，来递归地分解 DFT，从而在每一级产生一个 $N/2$ 点 DFT 和两个 $N/4$ 点 DFT，这些 DFT 通过形式为 $W_{N}^{k}$ 和 $W_{N}^{3k}$ 的旋转因子进行重组。\n\n对于 $N=16$，构建分裂基 DIT 流程，通过在每个重组级别上明确标识出乘以 $N/4$ 点子变换输出的旋转因子集合。以弧度为单位列举相应的旋转角。当且仅当一个乘数的旋转因子恰好为 $\\pm 1$ 或 $\\pm \\mathrm{j}$ 时（等价地，如果其角度与 $0$, $\\pi/2$, $\\pi$, 或 $3\\pi/2$ 模 $2\\pi$ 同余），将其归类为“平凡”的。包括在 $N=16$ 流程的偶数索引分支中出现的 $N=8$ 子 FFT。角度必须以弧度为单位报告。\n\n最后，设 $M$ 表示在整个 $N=16$ 分裂基 DIT FFT 流程中由旋转因子引起的非平凡复数乘法的总数（计算递归中所有重组阶段的乘法，且每个旋转因子的乘法只计算一次；不计算加法或平凡乘法），精确确定 $M$ 的值。你的最终答案必须是这个单一的整数 $M$，不带单位。不需要四舍五入。[@problem_id:54]", "solution": "该问题要求分析针对长度为 $N=16$ 的序列的时域抽取 (DIT) 分裂基快速傅里叶变换 (FFT) 算法。我们必须识别递归中每个阶段的旋转因子，并确定非平凡复数乘法的总数，记为 $M$。\n\n一个长度为 $N$ 的离散傅里叶变换 (DFT) 定义为：\n$$X[k] = \\sum_{n=0}^{N-1} x[n] W_{N}^{nk}, \\quad k = 0, 1, \\dots, N-1$$\n其中 $W_N \\triangleq \\exp(-\\mathrm{j} 2\\pi/N)$ 是旋转因子。\n\n分裂基算法通过将时间索引 $n$ 分裂为偶数索引 ($2n$)、形式为 $4n+1$ 的奇数索引和形式为 $4n+3$ 的奇数索引来分解 DFT 的求和。这会得到：\n$$X[k] = \\sum_{n=0}^{N/2-1} x[2n]W_N^{2nk} + \\sum_{n=0}^{N/4-1} x[4n+1]W_N^{(4n+1)k} + \\sum_{n=0}^{N/4-1} x[4n+3]W_N^{(4n+3)k}$$\n使用属性 $W_N^{ab} = W_{N/a}^b$，这可以表示为更小的 DFT：\n$$X[k] = \\sum_{n=0}^{N/2-1} x[2n]W_{N/2}^{nk} + W_N^k \\sum_{n=0}^{N/4-1} x[4n+1]W_{N/4}^{nk} + W_N^{3k} \\sum_{n=0}^{N/4-1} x[4n+3]W_{N/4}^{nk}$$\n这表明一个长度为 $N$ 的 DFT 可以由一个长度为 $N/2$ 的 DFT 和两个长度为 $N/4$ 的 DFT 计算得出。这些较小 DFT 的重组需要与旋转因子 $W_N^k$ 和 $W_N^{3k}$ 进行复数乘法。\n\n如果旋转因子为 $\\pm 1$ 或 $\\pm \\mathrm{j}$，则该乘法被定义为“平凡”的。这对应于旋转角是 $\\pi/2$ 的整数倍。旋转因子 $W_N^p$ 的角度是 $-2\\pi p/N$。为了使该角度成为 $\\pi/2$ 的整数倍，即对于某个整数 $q$ 有 $-2\\pi p/N = q(\\pi/2)$，我们必须有 $4p = -qN$，这意味着 $p$ 必须是 $N/4$ 的整数倍。\n\n我们现在将分析 $N=16$ 分裂基 FFT 的递归结构，以计算非平凡乘法的数量。\n\n**1. $N=16$ 的重组阶段**\n$16$ 点 DFT 的计算基于一个 $8$ 点 DFT 和两个 $4$ 点 DFT。重组过程涉及乘以两个 $4$ 点 DFT 输出的旋转因子。这些因子的索引范围从 $k=0$ 到 $N/4-1 = 16/4-1 = 3$。对于 $k=0$ 的因子是 $W_{16}^0=1$，这是一个平凡乘法，不计入在内。我们考虑 $k \\in \\{1, 2, 3\\}$。\n旋转因子的集合是 $\\{W_{16}^k | k=1,2,3\\}$ 和 $\\{W_{16}^{3k} | k=1,2,3\\}$。\n\n-   集合 1: $\\{W_{16}^1, W_{16}^2, W_{16}^3\\}$。\n    -   $W_{16}^1$ 的角度：$-2\\pi(1)/16 = -\\pi/8$ 弧度。\n    -   $W_{16}^2$ 的角度：$-2\\pi(2)/16 = -\\pi/4$ 弧度。\n    -   $W_{16}^3$ 的角度：$-2\\pi(3)/16 = -3\\pi/8$ 弧度。\n-   集合 2: $\\{W_{16}^3, W_{16}^6, W_{16}^9\\}$。\n    -   $W_{16}^3$ 的角度：$-2\\pi(3)/16 = -3\\pi/8$ 弧度。\n    -   $W_{16}^6$ 的角度：$-2\\pi(6)/16 = -3\\pi/4$ 弧度。\n    -   $W_{16}^9$ 的角度：$-2\\pi(9)/16 = -9\\pi/8$ 弧度。\n\n这些角度（$-\\pi/8, -\\pi/4, -3\\pi/8, -3\\pi/4, -9\\pi/8$）都不是 $\\pi/2$ 的整数倍。因此，在此阶段的所有 $2 \\times (16/4 - 1) = 2 \\times 3 = 6$ 次复数乘法都是非平凡的。\n\n**2. $N=8$ 子 FFT 的重组阶段**\n$N=16$ 的计算需要一个 $N=8$ 的子 FFT。这个 $8$ 点 DFT 又是通过一个 $4$ 点 DFT 和两个 $2$ 点 DFT 计算得出的。重组乘数由 $W_8^k$ 和 $W_8^{3k}$ 给出，其中 $k=0, \\dots, 8/4-1=1$。我们只需要考虑 $k=1$。\n旋转因子的集合是 $\\{W_8^1\\}$ 和 $\\{W_8^3\\}$。\n\n-   集合 1: $\\{W_8^1\\}$。\n    -   $W_8^1$ 的角度：$-2\\pi(1)/8 = -\\pi/4$ 弧度。\n-   集合 2: $\\{W_8^3\\}$。\n    -   $W_8^3$ 的角度：$-2\\pi(3)/8 = -3\\pi/4$ 弧度。\n\n$-\\pi/4$ 和 $-3\\pi/4$ 都不是 $\\pi/2$ 的整数倍。因此，两次乘法都是非平凡的。此阶段的非平凡乘法总数为 $2 \\times (8/4 - 1) = 2 \\times 1 = 2$。\n\n**3. $N=4$ 子 FFT 的重组阶段**\n完整的递归过程涉及几个 $N=4$ 的子 FFT。一个 $N=4$ 的分裂基 FFT 被分解为一个 $2$ 点 DFT 和两个 $1$ 点 DFT。重组乘数将是 $W_4^k$ 和 $W_4^{3k}$，其中 $k=0, \\dots, 4/4-1=0$。由于 $k$ 的范围为空（因为 $k=0$ 是平凡的），所以在任何 $N=4$ 子 FFT 的重组阶段中，乘法次数为零。\n\n**4. 非平凡乘法总数 ($M$)**\n非平凡复数乘法的总数 $M$ 是整个递归流程中所有重组阶段此类乘法之和。设 $M(N)$ 为长度为 $N$ 的 FFT 的非平凡乘法次数。\n递归结构如下：\n$$M(N) = M_{recomb}(N) + M(N/2) + 2 \\times M(N/4)$$\n其中 $M_{recomb}(N)$ 是大小为 $N$ 的重组阶段中的非平凡乘法次数。\n\n-   基本情况：一个 $2$ 点 DFT 只涉及加法和减法，所以 $M(2)=0$。一个 $1$ 点 DFT 是一个恒等操作，所以 $M(1)=0$。\n-   对于 $N=4$：$M_{recomb}(4) = 2 \\times (4/4-1) = 0$。因此，$M(4) = M_{recomb}(4) + M(2) + 2M(1) = 0 + 0 + 2(0) = 0$。\n-   对于 $N=8$：$M_{recomb}(8) = 2$。因此，$M(8) = M_{recomb}(8) + M(4) + 2M(2) = 2 + 0 + 2(0) = 2$。\n-   对于 $N=16$：$M_{recomb}(16) = 6$。因此，$M(16) = M_{recomb}(16) + M(8) + 2M(4) = 6 + 2 + 2(0) = 8$。\n\n整个 $N=16$ 流程的非平凡乘法总数 $M$ 正是 $M(16)$。\n计算过程展开如下：\n- $N=16$ FFT 的顶层分解贡献了 $6$ 次非平凡乘法。\n- 这产生了一个大小为 $N=8$ 的子问题和两个大小为 $N=4$ 的子问题。\n- 这两个 $N=4$ 的子问题各自贡献 $M(4)=0$ 次乘法。\n- 这个 $N=8$ 的子问题贡献了 $M(8)=2$ 次乘法。该子问题本身会分解为更小的 FFT（$N=4$ 和 $N=2$），但它们的贡献已经包含在 $M(8)$ 的值中。\n\n将所有阶段的贡献相加：\n$$M = M_{recomb}(16) + M(8) + 2M(4) = 6 + 2 + 2(0) = 8.$$\n因此，在整个 $N=16$ 分裂基 DIT FFT 流程中，由旋转因子引起的非平凡复数乘法总数为 $8$。", "answer": "$$\\boxed{8}$$", "id": "2863892"}]}