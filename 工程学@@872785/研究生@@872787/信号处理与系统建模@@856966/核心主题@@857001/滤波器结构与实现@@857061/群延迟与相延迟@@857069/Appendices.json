{"hands_on_practices": [{"introduction": "该练习探讨了最简单的具有延迟特性的系统：理想时间平移。通过分析这个非因果的“预测”系统，我们可以为相位延迟和群延迟的含义建立一个清晰直观的基准，并看到在这无色散的场景中，这两种延迟如何与时间平移量完美对应。[@problem_id:1723782]", "problem": "一个线性时不变（LTI）系统被设计为一个“预测器”，其产生的输出信号是其输入信号的时间提前版本。该系统的输入-输出关系由以下方程给出：\n$$y(t) = x(t + t_0)$$\n其中 $x(t)$ 是输入信号，$y(t)$ 是输出信号，$t_0$ 是一个表示时间提前量值的正实数常量。\n\n这个系统虽然是非因果的，因此在实时中无法物理实现，但它是信号处理理论中的一个基本概念。你的任务是分析其在频域中的行为。\n\n确定该系统的相位延迟 $\\tau_p(\\omega)$ 和群延迟 $\\tau_g(\\omega)$ 的表达式，使其作为角频率 $\\omega$ 和时间提前量 $t_0$ 的函数。\n\n将你的答案表示为一个双元素行矩阵，其中第一个元素是相位延迟 $\\tau_p(\\omega)$ 的表达式，第二个元素是群延迟 $\\tau_g(\\omega)$ 的表达式。", "solution": "为了确定系统的相位延迟和群延迟，我们首先需要找到其频率响应 $H(\\omega)$。频率响应是系统脉冲响应 $h(t)$ 的傅里叶变换。\n\n脉冲响应 $h(t)$ 是当输入为 Dirac δ函数 $x(t) = \\delta(t)$ 时系统的输出。将此代入系统的输入-输出关系，得到：\n$$h(t) = \\delta(t + t_0)$$\n现在，我们计算 $h(t)$ 的傅里叶变换来求得 $H(\\omega)$：\n$$H(\\omega) = \\mathcal{F}\\{h(t)\\} = \\int_{-\\infty}^{\\infty} h(t) e^{-j\\omega t} dt = \\int_{-\\infty}^{\\infty} \\delta(t + t_0) e^{-j\\omega t} dt$$\n利用 Dirac δ函数的筛选特性，即 $\\int_{-\\infty}^{\\infty} \\delta(t - a) f(t) dt = f(a)$，我们可以计算该积分。在我们的例子中，δ函数位于 $t = -t_0$ 处。因此，我们有：\n$$H(\\omega) = e^{-j\\omega(-t_0)} = e^{j\\omega t_0}$$\n频率响应 $H(\\omega)$ 可以用极坐标形式表示为 $H(\\omega) = |H(\\omega)| e^{j\\theta(\\omega)}$，其中 $|H(\\omega)|$ 是幅度响应，$\\theta(\\omega)$ 是相位响应。\n对于 $H(\\omega) = e^{j\\omega t_0}$，其幅度为 $|H(\\omega)| = |e^{j\\omega t_0}| = 1$。相位响应为：\n$$\\theta(\\omega) = \\omega t_0$$\n相位延迟 $\\tau_p(\\omega)$ 定义为相位响应的负值除以角频率：\n$$\\tau_p(\\omega) = -\\frac{\\theta(\\omega)}{\\omega}$$\n代入我们得到的 $\\theta(\\omega)$ 表达式：\n$$\\tau_p(\\omega) = -\\frac{\\omega t_0}{\\omega} = -t_0$$\n群延迟 $\\tau_g(\\omega)$ 定义为相位响应对角频率的导数的负值：\n$$\\tau_g(\\omega) = -\\frac{d\\theta(\\omega)}{d\\omega}$$\n代入我们得到的 $\\theta(\\omega)$ 表达式并对 $\\omega$ 求导：\n$$\\tau_g(\\omega) = -\\frac{d}{d\\omega}(\\omega t_0) = -t_0$$\n相位延迟和群延迟都是常数，且等于 $-t_0$。这个负值表示时间提前，这与系统定义 $y(t) = x(t+t_0)$ 一致。$-t_0$ 的延迟等效于 $t_0$ 的提前。\n\n相位延迟为 $-t_0$ 意味着输入信号的每个单独的频率分量（正弦波）都会在输出端提前 $t_0$ 秒出现。群延迟为 $-t_0$ 意味着一个窄带频率的包络也会提前 $t_0$ 秒且无失真。\n\n最终答案是一个包含相位延迟和群延迟表达式的双元素行矩阵。\n第一个元素：$\\tau_p(\\omega) = -t_0$\n第二个元素：$\\tau_g(\\omega) = -t_0$", "answer": "$$\\boxed{\\begin{pmatrix} -t_0  -t_0 \\end{pmatrix}}$$", "id": "1723782"}, {"introduction": "从理想情况转向实际应用，本问题将研究一阶全通滤波器，这是相位均衡中的一个基本组件。在本练习中，您将发现群延迟如何随频率变化——这种现象被称为相位失真——并学会量化一个常见模拟电路中的这种变化特性。[@problem_id:1723771]", "problem": "在电信和音频工程中，全通滤波器是用于修改系统相位响应而不改变其幅度响应的关键组件。它们通常用作相位均衡器，以补偿不必要的时延和信号失真。\n\n考虑一个一阶模拟全通滤波器，其在拉普拉斯域中的传递函数由下式描述：\n$$ H(s) = \\frac{a-s}{s+a} $$\n其中 $s$ 是复频率，$a$ 是一个定义滤波器特性的正实数常数。参数 $a$ 的单位是弧度/秒。\n\n滤波器的群延迟，记为 $\\tau_g(\\omega)$，量化了信号不同频率分量的幅度包络所经历的时延。它被正式定义为滤波器相位响应 $\\phi(\\omega)$ 相对于角频率 $\\omega$ 的负导数。恒定的群延迟对于保持复杂信号的波形至关重要。\n\n确定该全通滤波器的群延迟恰好是其在直流（$\\omega=0$）处值的一半时的正角频率 $\\omega_0$。用参数 $a$ 表示你的答案 $\\omega_0$。", "solution": "对于传递函数为 $H(s) = \\frac{a - s}{s + a}$ 且 $a0$ 的一阶全通滤波器，通过代入 $s = j\\omega$ 来计算频率响应，得到 $H(j\\omega) = \\frac{a - j\\omega}{a + j\\omega}$。相位响应是分子和分母的辐角之差：\n$$\n\\phi(\\omega) = \\arg(a - j\\omega) - \\arg(a + j\\omega) = -\\arctan\\!\\left(\\frac{\\omega}{a}\\right) - \\arctan\\!\\left(\\frac{\\omega}{a}\\right) = -2\\,\\arctan\\!\\left(\\frac{\\omega}{a}\\right).\n$$\n群延迟定义为 $\\tau_{g}(\\omega) = -\\frac{d\\phi(\\omega)}{d\\omega}$。使用 $\\frac{d}{d\\omega}\\arctan(u) = \\frac{1}{1+u^{2}}\\frac{du}{d\\omega}$，令 $u = \\frac{\\omega}{a}$ 且 $\\frac{du}{d\\omega} = \\frac{1}{a}$ 进行求导，得到\n$$\n\\frac{d\\phi}{d\\omega} = -2 \\cdot \\frac{1}{1+(\\omega/a)^{2}} \\cdot \\frac{1}{a} = -\\frac{2a}{a^{2}+\\omega^{2}},\n$$\n因此\n$$\n\\tau_{g}(\\omega) = -\\frac{d\\phi}{d\\omega} = \\frac{2a}{a^{2}+\\omega^{2}}.\n$$\n在直流处，$\\tau_{g}(0) = \\frac{2a}{a^{2}} = \\frac{2}{a}$。我们要寻找 $\\omega_{0}  0$ 使得 $\\tau_{g}(\\omega_{0}) = \\frac{1}{2}\\tau_{g}(0) = \\frac{1}{a}$。建立方程并求解：\n$$\n\\frac{2a}{a^{2}+\\omega_{0}^{2}} = \\frac{1}{a}\n\\;\\;\\Longrightarrow\\;\\;\n2a^{2} = a^{2} + \\omega_{0}^{2}\n\\;\\;\\Longrightarrow\\;\\;\n\\omega_{0}^{2} = a^{2}\n\\;\\;\\Longrightarrow\\;\\;\n\\omega_{0} = a,\n$$\n其中取正根。", "answer": "$$\\boxed{a}$$", "id": "1723771"}, {"introduction": "这项高级实践练习旨在弥合解析公式与现实世界信号处理之间的鸿沟，因为在实际工作中我们通常处理的是采样数据。您将通过编写程序来数值计算群延迟和相位延迟，解决相位展开和数值微分等关键挑战，并用典型的系统类型来测试您的代码。[@problem_id:2875342]", "problem": "你的任务是设计并实现一个程序，用于计算与线性时不变系统的离散时间频率响应相关的两种延迟度量：相位延迟和群延迟。你的程序必须通过提取解卷相位并对其相对于角频率进行数值微分，来处理在指定角频率网格上的复频率响应采样值。角频率单位必须是弧度/样本。不允许用户输入；所有参数必须在程序内部定义，并且输出必须按要求的格式打印。\n\n起点和约束。仅使用离散时间线性时不变系统和离散时间傅里叶变换（DTFT）的基本定义。频率响应是系统脉冲响应的 DTFT，是角频率的复函数。相位定义为该复函数的辐角。脉冲响应中的时间平移会引入一个依赖于频率的复指数因子。所有推理都应基于这些基础，避免使用任何作为最终目标给出的捷径公式。从这些基础出发，推导从解卷相位中获得两种延迟度量的计算过程，并在均匀的角频率网格上稳健地实现它，注意时移特性所隐含的符号约定。不要为目标量假设任何特殊的解析形式；相反，应通过相位解卷和数值微分从采样数据中提取它们。确保数值微分与以弧度/样本为单位的角频率一致，并使用能处理边界的有限差分法实现。以数学上一致的方式处理角频率为零的特殊情况。\n\n频率网格。在闭区间 $[0,\\pi]$ 上使用一个包含 $N_\\omega = 4097$ 个角频率 $\\{\\omega_k\\}_{k=0}^{N_\\omega-1}$ 的均匀间隔网格，单位为弧度/样本。即 $\\omega_0 = 0$ 且 $\\omega_{N_\\omega-1} = \\pi$。\n\n在代码中实现的步骤。\n- 给定所有 $\\omega_k$ 的采样值 $H(e^{j\\omega_k})$，计算每个 $k$ 的主值相位 $\\phi_{\\mathrm{pv}}(\\omega_k)$，即 $H(e^{j\\omega_k})$ 的辐角，单位为弧度。\n- 对相位进行解卷以获得连续的 $\\phi(\\omega_k)$，消除 $k$ 之间的 $2\\pi$ 不连续性。\n- 使用内部点的中心有限差分和边界点的适当单边差分，对解卷相位相对于 $\\omega$ 进行数值微分，以获得所有 $\\omega_k$ 处的数值导数。\n- 使用与线性时不变系统的 DTFT 时移特性一致的标准符号约定，将相位斜率转换为其中一种延迟度量。\n- 在定义有意义的地方，直接从解卷相位和角频率定义第二种延迟度量；在 $\\omega_0 = 0$ 处，使用从基于斜率的延迟计算出的极限值，以避免除以零。\n\n测试套件。通过在采样点上解析地构造 $H(e^{j\\omega})$ 来实现三个测试系统。对每个系统，在指定的网格上计算两种延迟度量，然后计算一个单一的标量诊断量，该诊断量将在聚合输出中返回。\n\n- 测试 A（纯整数样本延迟）。设 $n_0 = 7$。定义 $H_A(e^{j\\omega}) = e^{-j\\omega n_0}$。在网格上计算基于斜率的延迟后，计算索引 $k \\in \\{5,6,\\dots,N_\\omega-6\\}$ 范围内与 $n_0$ 的最大绝对偏差，以避免边界伪影。将此最大偏差报告为一个以样本为单位的浮点数。\n\n- 测试 B（一阶低通，稳定极点严格位于单位圆内）。设 $\\alpha = 0.9$。定义 $H_B(e^{j\\omega}) = \\dfrac{1-\\alpha}{1 - \\alpha e^{-j\\omega}}$。计算两种延迟度量。在最小正角频率 $\\omega_1$ 处（即索引 $k=1$ 处），计算两种延迟度量之间的绝对差。将此绝对差报告为一个以样本为单位的浮点数。\n\n- 测试 C（一阶稳定全通）。设 $a = 0.6$。定义 $H_C(e^{j\\omega}) = \\dfrac{a - e^{-j\\omega}}{1 - a e^{-j\\omega}}$。计算整个网格上基于斜率的延迟，然后计算其在所有 $k$ 上的算术平均值。将此平均值与 $1$ 之间的绝对差报告为一个以样本为单位的浮点数。\n\n角度和单位。所有角度单位均为弧度，所有角频率单位均为弧度/样本，延迟度量单位为样本。\n\n最终输出格式。你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序为 $[\\text{测试 A 结果}, \\text{测试 B 结果}, \\text{测试 C 结果}]$。例如，输出必须看起来像 $[x_A,x_B,x_C]$，包含三个浮点数，没有其他文本。\n\n你的解决方案必须实现为一个完整的、可运行的程序，并遵守指定的执行环境。", "solution": "问题陈述已经过严格验证，被认为是有效的。它科学地植根于离散时间信号处理的原理，是适定的，提供了所有必要的信息，并且是客观地表述的。因此，我们将着手构建解决方案。\n\n问题的核心是计算离散时间线性时不变（LTI）系统的两个延迟度量：群延迟和相位延迟。这些度量源自系统的频率响应，即其脉冲响应 $h(n)$ 的离散时间傅里叶变换（DTFT）。\n\n设频率响应表示为 $H(e^{j\\omega})$，其中 $\\omega$ 是角频率，单位为弧度/样本。$H(e^{j\\omega})$ 是一个复函数，可以表示为极坐标形式：\n$$ H(e^{j\\omega}) = |H(e^{j\\omega})| e^{j\\phi(\\omega)} $$\n其中 $|H(e^{j\\omega})|$ 是幅度响应，$\\phi(\\omega)$ 是相位响应。\n\n群延迟和相位延迟的定义受 DTFT 的时移特性启发。考虑一个脉冲响应 $h(n)$ 及其延迟版本 $h_d(n) = h(n-n_0)$，其中 $n_0$ 是一个以样本为单位的恒定整数延迟。$h_d(n)$ 的 DTFT 是：\n$$ H_d(e^{j\\omega}) = \\sum_{n=-\\infty}^{\\infty} h(n-n_0) e^{-j\\omega n} $$\n通过变量替换 $m = n-n_0$，我们得到：\n$$ H_d(e^{j\\omega}) = \\sum_{m=-\\infty}^{\\infty} h(m) e^{-j\\omega (m+n_0)} = e^{-j\\omega n_0} \\sum_{m=-\\infty}^{\\infty} h(m) e^{-j\\omega m} = H(e^{j\\omega}) e^{-j\\omega n_0} $$\n延迟系统的相位是 $\\phi_d(\\omega) = \\phi(\\omega) - \\omega n_0$。一个恒定的时间延迟 $n_0$ 引入了一个斜率为 $-n_0$ 的线性相位分量。这种关系确立了延迟定义的符号约定。\n\n**群延迟** $\\tau_g(\\omega)$ 量化了通过系统的信号包络的延迟，定义为相位对频率的负变化率：\n$$ \\tau_g(\\omega) = -\\frac{d\\phi(\\omega)}{d\\omega} $$\n对于纯延迟系统，其相位为 $\\phi(\\omega) = - \\omega n_0$（假设原始系统相位为零），群延迟为 $\\tau_g(\\omega) = -(-n_0) = n_0$，这正确地恢复了恒定的时间平移。\n\n**相位延迟** $\\tau_p(\\omega)$ 量化了正弦信号载波频率的延迟，定义为：\n$$ \\tau_p(\\omega) = -\\frac{\\phi(\\omega)}{\\omega} $$\n对于纯延迟系统，$\\tau_p(\\omega) = -(-\\omega n_0 / \\omega) = n_0$。对于像纯延迟这样的非色散系统，群延迟和相位延迟是相同的。\n\n在 $\\omega=0$ 时，对于任何实值脉冲响应，由于 $\\phi(0)=0$，相位延迟的定义会导致不定式 $0/0$。这一点的值由极限确定，可以使用 L'Hopital's rule 进行评估：\n$$ \\lim_{\\omega \\to 0} \\tau_p(\\omega) = \\lim_{\\omega \\to 0} \\left( -\\frac{\\phi(\\omega)}{\\omega} \\right) = -\\left. \\frac{d\\phi(\\omega)}{d\\omega} \\right|_{\\omega=0} = \\tau_g(0) $$\n这证实了问题中指定的处理 $\\omega=0$ 情况的步骤。\n\n计算过程在一个包含 $N_\\omega = 4097$ 个频率的离散网格 $\\{\\omega_k\\}_{k=0}^{N_\\omega-1}$ 上执行，这些频率在 $[0, \\pi]$ 上均匀间隔。频率步长为 $\\Delta\\omega = \\pi / (N_\\omega - 1)$。\n\n1.  **相位提取**：对于给定的复频率响应 $H(e^{j\\omega_k})$，使用 `atan2` 函数计算主值相位 $\\phi_{\\mathrm{pv}}(\\omega_k)$，该函数将相位映射到区间 $(-\\pi, \\pi]$。\n2.  **相位解卷**：主值相位可能包含 $\\pm 2\\pi$ 的人为跳变。通过“解卷”恢复连续相位函数 $\\phi(\\omega_k)$，该过程包括对连续元素加上或减去 $2\\pi$ 的整数倍，以消除大于阈值（通常为 $\\pi$）的跳变。\n3.  **群延迟的数值微分**：使用有限差分近似导数 $d\\phi/d\\omega$。\n    - 对于内部点（$k=1, \\dots, N_\\omega - 2$）：使用二阶精确的中心差分：\n      $$ \\left.\\frac{d\\phi}{d\\omega}\\right|_{\\omega_k} \\approx \\frac{\\phi(\\omega_{k+1}) - \\phi(\\omega_{k-1})}{2 \\Delta\\omega} $$\n    - 对于边界点（$k=0$ 和 $k=N_\\omega-1$）：使用一阶精确的单边差分：\n      $$ \\left.\\frac{d\\phi}{d\\omega}\\right|_{\\omega_0} \\approx \\frac{\\phi(\\omega_1) - \\phi(\\omega_0)}{\\Delta\\omega}, \\quad \\left.\\frac{d\\phi}{d\\omega}\\right|_{\\omega_{N_\\omega-1}} \\approx \\frac{\\phi(\\omega_{N_\\omega-1}) - \\phi(\\omega_{N_\\omega-2})}{\\Delta\\omega} $$\n    群延迟则为 $\\tau_g(\\omega_k) = - (d\\phi/d\\omega)|_{\\omega_k}$。\n4.  **相位延迟计算**：对于 $k  0$，相位延迟直接计算为 $\\tau_p(\\omega_k) = -\\phi(\\omega_k)/\\omega_k$。在 $k=0$ 处，我们设置 $\\tau_p(\\omega_0) = \\tau_g(\\omega_0)$。\n\n三个测试案例分析如下：\n- **测试 A：纯整数延迟**。系统为 $H_A(e^{j\\omega}) = e^{-j\\omega n_0}$，其中 $n_0=7$。解析相位为 $\\phi(\\omega) = -7\\omega$，解析群延迟对于所有 $\\omega$ 均为 $\\tau_g(\\omega) = 7$。指定的诊断量度量了在频率范围内部数值群延迟计算的最大误差，避免了精度较低的边界近似。\n- **测试 B：一阶低通滤波器**。系统为 $H_B(e^{j\\omega}) = \\frac{1-\\alpha}{1 - \\alpha e^{-j\\omega}}$，其中 $\\alpha=0.9$。这是一个色散系统，意味着其相位响应不随频率线性变化。因此，对于 $\\omega  0$，有 $\\tau_g(\\omega) \\neq \\tau_p(\\omega)$。诊断量度量了在第一个非零频率点 $\\omega_1$ 处这两种延迟之间的差异，为系统在低频下的色散提供了定量度量。\n- **测试 C：一阶全通滤波器**。系统为 $H_C(e^{j\\omega}) = \\frac{a - e^{-j\\omega}}{1 - a e^{-j\\omega}}$，其中 $a=0.6$。其幅度响应对于所有 $\\omega$ 均为 $|H_C(e^{j\\omega})|=1$。群延迟不是恒定的；其解析形式为 $\\tau_g(\\omega) = \\frac{1-a^2}{1+a^2-2a\\cos\\omega}$。该系统的一个关键特性是其在区间 $[0, \\pi]$ 上的平均群延迟恰好为 $1$：\n  $$ \\bar{\\tau_g} = \\frac{1}{\\pi} \\int_0^\\pi \\tau_g(\\omega) \\, d\\omega = \\frac{1-a^2}{\\pi} \\int_0^\\pi \\frac{d\\omega}{1+a^2-2a\\cos\\omega} = \\frac{1-a^2}{\\pi} \\left[ \\frac{\\pi}{1-a^2} \\right] = 1 $$\n  诊断量计算了网格上数值计算的群延迟值 $\\{\\tau_g(\\omega_k)\\}$ 的算术平均值，这是对该积分的离散近似。这个数值平均值与理论值 $1$ 之间的绝对差测试了在整个频率范围内群延迟计算的总体精度。\n\n现在将基于这些原理进行实现。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes phase and group delays for three test systems and reports diagnostic quantities.\n    \"\"\"\n    N_omega = 4097\n    omega = np.linspace(0, np.pi, N_omega)\n    delta_omega = np.pi / (N_omega - 1)\n\n    def compute_delays(H, omega_grid, delta_omega_val):\n        \"\"\"\n        Computes group and phase delay from a complex frequency response.\n\n        Args:\n            H (np.ndarray): Complex frequency response samples.\n            omega_grid (np.ndarray): The angular frequency grid.\n            delta_omega_val (float): The spacing of the frequency grid.\n\n        Returns:\n            tuple[np.ndarray, np.ndarray]: A tuple containing the group delay and phase delay.\n        \"\"\"\n        # Step 1: Compute principal-value phase\n        phi_pv = np.angle(H)\n\n        # Step 2: Unwrap the phase\n        phi_uw = np.unwrap(phi_pv)\n\n        # Step 3: Numerically differentiate for group delay\n        # np.gradient uses centered differences for interior and one-sided for boundaries.\n        # This matches the problem specification.\n        # tau_g = -d(phi)/d(omega)\n        dphi_domega = np.gradient(phi_uw, delta_omega_val)\n        tau_g = -dphi_domega\n\n        # Step 4: Compute phase delay\n        # tau_p = -phi/omega\n        # To avoid division by zero at omega=0, we suppress the warning and handle it separately.\n        with np.errstate(divide='ignore', invalid='ignore'):\n            tau_p = -phi_uw / omega_grid\n        \n        # Handle the special case at omega = 0 using the limiting value, tau_g(0).\n        if omega_grid[0] == 0:\n            tau_p[0] = tau_g[0]\n\n        return tau_g, tau_p\n\n    # --- Test Cases ---\n    results = []\n\n    # Test A: Pure integer sample delay\n    n0 = 7.0\n    H_A = np.exp(-1j * omega * n0)\n    tau_g_A, _ = compute_delays(H_A, omega, delta_omega)\n    # Diagnostic: max absolute deviation from n0, avoiding boundary artifacts.\n    # The spec is k in {5, ..., N_omega-6}. In Python slicing this is [5:N_omega-5]\n    deviation_A = np.max(np.abs(tau_g_A[5:N_omega-5] - n0))\n    results.append(deviation_A)\n\n    # Test B: First-order low-pass filter\n    alpha = 0.9\n    H_B = (1 - alpha) / (1 - alpha * np.exp(-1j * omega))\n    tau_g_B, tau_p_B = compute_delays(H_B, omega, delta_omega)\n    # Diagnostic: absolute difference between the two delays at the smallest positive frequency (k=1)\n    diff_B = np.abs(tau_g_B[1] - tau_p_B[1])\n    results.append(diff_B)\n\n    # Test C: First-order stable all-pass\n    a = 0.6\n    # Note: A small epsilon is added to the denominator to prevent potential floating point issues\n    # if the denominator becomes exactly zero, although it is not expected for this H(w).\n    denominator_C = 1 - a * np.exp(-1j * omega)\n    H_C = (a - np.exp(-1j * omega)) / denominator_C\n    tau_g_C, _ = compute_delays(H_C, omega, delta_omega)\n    # Diagnostic: absolute difference between the arithmetic mean of tau_g and 1.\n    mean_tau_g_C = np.mean(tau_g_C)\n    diff_C = np.abs(mean_tau_g_C - 1.0)\n    results.append(diff_C)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2875342"}]}