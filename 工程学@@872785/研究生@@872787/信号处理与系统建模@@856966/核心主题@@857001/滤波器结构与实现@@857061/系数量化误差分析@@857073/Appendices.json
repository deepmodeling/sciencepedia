{"hands_on_practices": [{"introduction": "对于无限冲激响应（IIR）滤波器，其稳定性和频率响应特性由其极点位置精确决定。在实际的数字实现中，滤波器系数必须被量化为有限的位数，这不可避免地会导致极点位置的偏移。本练习将通过解析推导，帮助你掌握量化系数对极点位置（以极径 $r$ 和极角 $\\theta$ 表示）影响的灵敏度分析方法，这是理解和预测滤波器性能因量化而退化的第一步。[@problem_id:2858988]", "problem": "考虑一个具有传递函数的实系数二阶（双二阶）数字滤波器\n$$\nH(z) \\;=\\; \\frac{b_0 + b_1 z^{-1} + b_2 z^{-2}}{1 + a_1 z^{-1} + a_2 z^{-2}},\n$$\n其中 $b_0$、$b_1$、$b_2$、$a_1$ 和 $a_2$ 均为实数。假设极点对是共轭复数，因此分母多项式有两个根 $z_p$ 和 $z_p^{\\ast}$，它们严格位于单位圆内且不在实轴上。定义极点的极坐标表示为 $z_p = r \\exp(j \\theta)$，其中半径 $r \\in (0,1)$，幅角 $\\theta \\in (0,\\pi)$（以弧度为单位）。\n\n假设系数 $a_1$ 和 $a_2$ 受到微小的有限字长量化扰动，这些扰动被建模为独立的、足够小的微分 $\\mathrm{d}a_1$ 和 $\\mathrm{d}a_2$。将极点不变量 $r$ 和 $\\theta$ 关于 $a_1$ 和 $a_2$ 的局部灵敏度定义为偏导数 $\\frac{\\partial r}{\\partial a_1}$、$\\frac{\\partial r}{\\partial a_2}$、$\\frac{\\partial \\theta}{\\partial a_1}$ 和 $\\frac{\\partial \\theta}{\\partial a_2}$，使得一阶变化量满足\n$$\n\\mathrm{d}r \\;\\approx\\; \\frac{\\partial r}{\\partial a_1}\\,\\mathrm{d}a_1 \\;+\\; \\frac{\\partial r}{\\partial a_2}\\,\\mathrm{d}a_2,\\qquad\n\\mathrm{d}\\theta \\;\\approx\\; \\frac{\\partial \\theta}{\\partial a_1}\\,\\mathrm{d}a_1 \\;+\\; \\frac{\\partial \\theta}{\\partial a_2}\\,\\mathrm{d}a_2.\n$$\n\n仅从具有共轭复数根的实系数二次式的基本多项式因式分解以及 $r$ 和 $\\theta$ 的定义出发，推导这四个偏导数关于 $a_1$ 和 $a_2$ 的闭式表达式，并满足容许条件 $a_2>0$ 和 $a_1^2  4a_2$。按照 $\\left(\\frac{\\partial r}{\\partial a_1},\\,\\frac{\\partial r}{\\partial a_2},\\,\\frac{\\partial \\theta}{\\partial a_1},\\,\\frac{\\partial \\theta}{\\partial a_2}\\right)$ 的顺序报告你的最终结果。角度必须以弧度表示。无需进行数值计算；仅提供精确的解析表达式。", "solution": "该问题是有效的。这是数字滤波器灵敏度分析中的一个标准练习，它具有科学依据、是适定且客观的。我们将开始推导。\n\n滤波器的极点是分母多项式 $D(z^{-1}) = 1 + a_1 z^{-1} + a_2 z^{-2}$ 的根。这等价于求特征多项式 $P(z) = z^2 + a_1 z + a_2 = 0$ 的根。\n问题陈述了极点是一对共轭复数，记为 $z_p = r \\exp(j\\theta)$ 和 $z_p^{\\ast} = r \\exp(-j\\theta)$，其中 $r \\in (0,1)$ 且 $\\theta \\in (0,\\pi)$。\n\n多项式 $P(z)$ 可以根据其根进行因式分解：\n$$P(z) = (z - z_p)(z - z_p^{\\ast}) = z^2 - (z_p + z_p^{\\ast})z + z_p z_p^{\\ast}$$\n通过将这个展开形式的系数与 $z^2 + a_1 z + a_2$ 进行比较，我们建立了系数 $(a_1, a_2)$ 与极点的极坐标表示 $(r, \\theta)$ 之间的关系。\n\n根的和为：\n$$z_p + z_p^{\\ast} = r \\exp(j\\theta) + r \\exp(-j\\theta) = r(\\cos\\theta + j\\sin\\theta) + r(\\cos\\theta - j\\sin\\theta) = 2r\\cos\\theta$$\n根的积为：\n$$z_p z_p^{\\ast} = (r \\exp(j\\theta))(r \\exp(-j\\theta)) = r^2$$\n\n令系数相等，得到以下方程组：\n$$a_1 = -2r\\cos\\theta \\quad (1)$$\n$$a_2 = r^2 \\quad (2)$$\n\n这些方程将 $a_1$ 和 $a_2$ 定义为 $r$ 和 $\\theta$ 的函数。我们需要求出 $r$ 和 $\\theta$ 关于 $a_1$ 和 $a_2$ 的偏导数。我们将使用隐式微分法。我们将 $r$ 和 $\\theta$ 视为 $a_1$ 和 $a_2$ 的函数，并对联立方程 $(1)$ 和 $(2)$ 分别关于 $a_1$ 和 $a_2$ 求导。\n\n首先，我们对 $a_1$ 求导：\n$$\\frac{\\partial}{\\partial a_1}(a_1) = 1 = \\frac{\\partial}{\\partial a_1}(-2r\\cos\\theta) = -2\\left(\\frac{\\partial r}{\\partial a_1}\\cos\\theta - r\\sin\\theta\\frac{\\partial \\theta}{\\partial a_1}\\right)$$\n$$\\frac{\\partial}{\\partial a_1}(a_2) = 0 = \\frac{\\partial}{\\partial a_1}(r^2) = 2r\\frac{\\partial r}{\\partial a_1}$$\n\n从第二个微分方程可知，由于 $r \\in (0,1)$，我们有 $r \\neq 0$，这意味着：\n$$\\frac{\\partial r}{\\partial a_1} = 0$$\n将此结果代入第一个微分方程：\n$$1 = -2\\left(0 \\cdot \\cos\\theta - r\\sin\\theta\\frac{\\partial \\theta}{\\partial a_1}\\right) = 2r\\sin\\theta\\frac{\\partial \\theta}{\\partial a_1}$$\n解出 $\\frac{\\partial \\theta}{\\partial a_1}$ 得：\n$$\\frac{\\partial \\theta}{\\partial a_1} = \\frac{1}{2r\\sin\\theta}$$\n\n接下来，我们对原方程组关于 $a_2$ 求导：\n$$\\frac{\\partial}{\\partial a_2}(a_1) = 0 = \\frac{\\partial}{\\partial a_2}(-2r\\cos\\theta) = -2\\left(\\frac{\\partial r}{\\partial a_2}\\cos\\theta - r\\sin\\theta\\frac{\\partial \\theta}{\\partial a_2}\\right)$$\n$$\\frac{\\partial}{\\partial a_2}(a_2) = 1 = \\frac{\\partial}{\\partial a_2}(r^2) = 2r\\frac{\\partial r}{\\partial a_2}$$\n\n从第二个微分方程中，我们求得 $\\frac{\\partial r}{\\partial a_2}$：\n$$\\frac{\\partial r}{\\partial a_2} = \\frac{1}{2r}$$\n将此代入第一个微分方程：\n$$0 = -2\\left(\\frac{1}{2r}\\cos\\theta - r\\sin\\theta\\frac{\\partial \\theta}{\\partial a_2}\\right) = -\\frac{\\cos\\theta}{r} + 2r\\sin\\theta\\frac{\\partial \\theta}{\\partial a_2}$$\n解出 $\\frac{\\partial \\theta}{\\partial a_2}$：\n$$2r\\sin\\theta\\frac{\\partial \\theta}{\\partial a_2} = \\frac{\\cos\\theta}{r} \\implies \\frac{\\partial \\theta}{\\partial a_2} = \\frac{\\cos\\theta}{2r^2\\sin\\theta}$$\n\n推导出的偏导数目前是用 $r$ 和 $\\theta$ 表示的。我们必须将它们转换为仅用 $a_1$ 和 $a_2$ 表示的表达式。\n根据方程 $(2)$，$r = \\sqrt{a_2}$ (因为 $r>0$)。\n根据方程 $(1)$，$\\cos\\theta = -\\frac{a_1}{2r} = -\\frac{a_1}{2\\sqrt{a_2}}$。\n由于 $\\theta \\in (0,\\pi)$，$\\sin\\theta$ 必须为正。因此：\n$$\\sin\\theta = \\sqrt{1 - \\cos^2\\theta} = \\sqrt{1 - \\left(-\\frac{a_1}{2\\sqrt{a_2}}\\right)^2} = \\sqrt{1 - \\frac{a_1^2}{4a_2}} = \\frac{\\sqrt{4a_2 - a_1^2}}{2\\sqrt{a_2}}$$\n容许条件 $a_1^2  4a_2$ 确保了平方根内的值为正。\n\n现在我们将这些表达式代回到我们的偏导数结果中。\n\n对于 $\\frac{\\partial r}{\\partial a_1}$：\n结果已经是确定的：$\\frac{\\partial r}{\\partial a_1} = 0$。\n\n对于 $\\frac{\\partial r}{\\partial a_2}$：\n$$\\frac{\\partial r}{\\partial a_2} = \\frac{1}{2r} = \\frac{1}{2\\sqrt{a_2}}$$\n\n对于 $\\frac{\\partial \\theta}{\\partial a_1}$：\n$$\\frac{\\partial \\theta}{\\partial a_1} = \\frac{1}{2r\\sin\\theta} = \\frac{1}{2(\\sqrt{a_2})\\left(\\frac{\\sqrt{4a_2 - a_1^2}}{2\\sqrt{a_2}}\\right)} = \\frac{1}{\\sqrt{4a_2 - a_1^2}}$$\n\n对于 $\\frac{\\partial \\theta}{\\partial a_2}$：\n$$\\frac{\\partial \\theta}{\\partial a_2} = \\frac{\\cos\\theta}{2r^2\\sin\\theta} = \\frac{-\\frac{a_1}{2\\sqrt{a_2}}}{2(a_2)\\left(\\frac{\\sqrt{4a_2 - a_1^2}}{2\\sqrt{a_2}}\\right)} = \\frac{-\\frac{a_1}{2\\sqrt{a_2}}}{\\frac{a_2\\sqrt{4a_2 - a_1^2}}{\\sqrt{a_2}}} = -\\frac{a_1}{2\\sqrt{a_2}} \\cdot \\frac{\\sqrt{a_2}}{a_2\\sqrt{4a_2 - a_1^2}} = -\\frac{a_1}{2a_2\\sqrt{4a_2 - a_1^2}}$$\n\n四个偏导数是：\n$\\frac{\\partial r}{\\partial a_1} = 0$\n$\\frac{\\partial r}{\\partial a_2} = \\frac{1}{2\\sqrt{a_2}}$\n$\\frac{\\partial \\theta}{\\partial a_1} = \\frac{1}{\\sqrt{4a_2 - a_1^2}}$\n$\\frac{\\partial \\theta}{\\partial a_2} = -\\frac{a_1}{2a_2\\sqrt{4a_2 - a_1^2}}$\n\n这些就是所要求的用 $a_1$ 和 $a_2$ 表示的闭式表达式。条件 $a_2>0$ 和 $a_1^24a_2$ 确保所有表达式都是良定义且为实数。我们现在按指定顺序组合最终答案。", "answer": "$$\\boxed{\\begin{pmatrix} 0,  \\frac{1}{2\\sqrt{a_2}},  \\frac{1}{\\sqrt{4a_2 - a_1^2}},  -\\frac{a_1}{2a_2\\sqrt{4a_2 - a_1^2}} \\end{pmatrix}}$$.", "id": "2858988"}, {"introduction": "理论上相同的理想滤波器可以有多种不同的实现结构，例如直接型或更复杂的级联/并联形式。这些结构在面对系数的量化时表现出截然不同的鲁棒性。本练习将引导你通过编程实践，量化比较直接型（Direct-Form）和极零点（Pole-Zero）参数化这两种实现方式，在系数被量化后对滤波器幅频响应的影响。通过将测量到的误差与基于灵敏度分析的理论预测进行对比，你将深入理解为何选择合适的滤波器结构对于最小化量化效应至关重要。[@problem_id:2858985]", "problem": "给定一类实数、因果、二阶无限冲激响应（IIR）数字滤波器，其具有一对共轭复数零点和一对共轭复数极点，由以下传递函数描述\n$$\nH(z) \\;=\\; \\frac{B(z)}{A(z)} \\;=\\; \\frac{b_0 + b_1 z^{-1} + b_2 z^{-2}}{1 + a_1 z^{-1} + a_2 z^{-2}} \\,,\n$$\n其中，按照惯例 $a_0 = 1$。对于极坐标形式的极零点参数化，你也可以写作\n$$\nB(z) \\;=\\; g \\,\\bigl(1 - 2 r_z \\cos\\phi_z \\, z^{-1} + r_z^2 z^{-2}\\bigr), \\quad\nA(z) \\;=\\; 1 - 2 r_p \\cos\\phi_p \\, z^{-1} + r_p^2 z^{-2},\n$$\n其中参数为实数 $g \\in \\mathbb{R}$，$r_z \\in [0,1]$，$r_p \\in [0,1)$，$\\phi_z \\in [0,\\pi]$ 以及 $\\phi_p \\in [0,\\pi]$（角度以弧度为单位）。对应的多项式系数为 $b_0 = g$，$b_1 = -2 g r_z \\cos\\phi_z$，$b_2 = g r_z^2$，$a_1 = -2 r_p \\cos\\phi_p$ 和 $a_2 = r_p^2$。\n\n你的任务是分析系数的量化对于两种实现相同理想幅度响应的不同实现方式的幅度响应的影响：\n- 实现 A（直接形式系数的量化）：将多项式系数 $\\{b_0,b_1,b_2,a_1,a_2\\}$ 直接量化到步长为 $\\Delta_c$ 的均匀网格上。\n- 实现 B（极零点参数的量化）：将极零点参数 $\\{g,r_z,\\phi_z,r_p,\\phi_p\\}$ 分别量化到步长为 $\\Delta_g,\\Delta_{r_z},\\Delta_{\\phi_z},\\Delta_{r_p},\\Delta_{\\phi_p}$ 的均匀网格上，然后映射到多项式系数。\n\n对于两种实现，在网格 $\\omega \\in [0,\\pi]$ 上定义理想复频率响应为\n$$\nH(e^{j\\omega}) \\;=\\; \\frac{B(e^{j\\omega})}{A(e^{j\\omega})} \\,,\n$$\n以及理想幅度响应为 $|H(e^{j\\omega})|$。\n\n你必须：\n- 在每种实现中，将量化实现为四舍五入到最近的量化网格点。对于实现 A，对所有五个系数 $\\{b_0,b_1,b_2,a_1,a_2\\}$ 使用相同的步长 $\\Delta_c$。对于实现 B，使用下面测试套件中给出的每个参数指定的步长。量化是对称且无偏的。\n- 对于每种实现，计算量化后在 $[0,\\pi]$ 范围内的 $N$ 个频率样本的均匀网格上的实测均方根（RMS）幅度响应偏差：\n$$\nE_{\\mathrm{meas}} \\;=\\; \\sqrt{\\frac{1}{N}\\sum_{k=1}^{N}\\left(\\left|H_q(e^{j\\omega_k})\\right| - \\left|H(e^{j\\omega_k})\\right|\\right)^2}.\n$$\n- 使用一阶扰动模型独立预测均方根幅度响应偏差。将每个量化参数视为真实参数加上一个独立的、零均值的量化误差，该误差在宽度等于该参数量化步长的区间上均匀分布。对于参数向量 $\\boldsymbol{\\theta}$，$|H(e^{j\\omega})|$ 关于理想参数的线性化得出一个逐点方差预测\n$$\n\\sigma^2_{|H|}(\\omega) \\;\\approx\\; \\sum_{i} \\left(\\frac{\\partial |H(e^{j\\omega})|}{\\partial \\theta_i}\\right)^2 \\,\\mathrm{Var}(\\delta \\theta_i),\n$$\n其中对于每个量化步长为 $\\Delta_i$ 的独立量化参数，有 $\\mathrm{Var}(\\delta \\theta_i) = \\Delta_i^2/12$。将此预测的逐点方差在频率上取平均，然后取平方根，以获得预测的均方根偏差\n$$\nE_{\\mathrm{pred}} \\;=\\; \\sqrt{\\frac{1}{N}\\sum_{k=1}^{N}\\sigma^2_{|H|}(\\omega_k)}.\n$$\n- 使用两个数组 $\\bigl\\{\\sigma^2_{|H|}(\\omega_k)\\bigr\\}_{k=1}^N$ 和 $\\bigl\\{\\bigl(|H_q(e^{j\\omega_k})|-|H(e^{j\\omega_k})|\\bigr)^2\\bigr\\}_{k=1}^N$ 之间的皮尔逊相关系数，来量化预测的逐点方差与整个频率网格上的实际误差平方之间的一致性。\n\n从线性时不变系统的频率响应和一阶泰勒线性化的基本定义开始推导。不要假设任何关于灵敏度的黑箱公式。\n\n角度单位要求：所有角度 $\\phi$ 和频率 $\\omega$ 均以弧度为单位。不涉及物理单位。数值答案必须以浮点值形式提供。\n\n测试套件。使用以下三个测试用例，每个用例指定理想的极零点参数、一个归一化频率 $\\omega_0$（在该频率下通过选择 $g$ 将增益设为 1），以及两种实现的量化步长。对于每个用例，首先计算 $g$ 使得对于理想（未量化）参数 $\\left|H\\left(e^{j\\omega_0}\\right)\\right|=1$ 成立。然后执行两种实现的量化和所有要求的计算。在 $[0,\\pi]$（含端点）上使用一个包含 $N = 1024$ 个样本的均匀频率网格。\n\n- 用例 $1$（低通形状）：\n  - 归一化前的理想参数：$r_z = 1.0$，$\\phi_z = \\pi$，$r_p = 0.80$，$\\phi_p = 0.0$。\n  - 归一化频率：$\\omega_0 = 0.0$。\n  - 实现 A 量化：$\\Delta_c = 2^{-10}$。\n  - 实现 B 量化：$\\Delta_g = 2^{-10}$，$\\Delta_{r_z} = 2^{-10}$，$\\Delta_{\\phi_z} = 2^{-12}$，$\\Delta_{r_p} = 2^{-10}$，$\\Delta_{\\phi_p} = 2^{-12}$。\n\n- 用例 $2$（高 Q 值谐振形状）：\n  - 归一化前的理想参数：$r_z = 1.0$，$\\phi_z = 0.0$，$r_p = 0.98$，$\\phi_p = 0.3\\pi$。\n  - 归一化频率：$\\omega_0 = 0.3\\pi$。\n  - 实现 A 量化：$\\Delta_c = 2^{-12}$。\n  - 实现 B 量化：$\\Delta_g = 2^{-12}$，$\\Delta_{r_z} = 2^{-14}$，$\\Delta_{\\phi_z} = 2^{-14}$，$\\Delta_{r_p} = 2^{-14}$，$\\Delta_{\\phi_p} = 2^{-14}$。\n\n- 用例 $3$（陷波形状）：\n  - 归一化前的理想参数：$r_z = 1.0$，$\\phi_z = 0.6\\pi$，$r_p = 0.95$，$\\phi_p = 0.6\\pi$。\n  - 归一化频率：$\\omega_0 = 0.0$。\n  - 实现 A 量化：$\\Delta_c = 2^{-8}$。\n  - 实现 B 量化：$\\Delta_g = 2^{-8}$，$\\Delta_{r_z} = 2^{-10}$，$\\Delta_{\\phi_z} = 2^{-10}$，$\\Delta_{r_p} = 2^{-10}$，$\\Delta_{\\phi_p} = 2^{-10}$。\n\n要求输出。对于每个用例，按以下顺序生成六个浮点值：\n- $E_{\\mathrm{meas}}^{\\mathrm{df}}$（实现 A 的实测均方根偏差），\n- $E_{\\mathrm{pred}}^{\\mathrm{df}}$（实现 A 的预测均方根偏差），\n- $C^{\\mathrm{df}}$（实现 A 中预测方差与实际误差平方之间的皮尔逊相关性），\n- $E_{\\mathrm{meas}}^{\\mathrm{pz}}$（实现 B 的实测均方根偏差），\n- $E_{\\mathrm{pred}}^{\\mathrm{pz}}$（实现 B 的预测均方根偏差），\n- $C^{\\mathrm{pz}}$（实现 B 中预测方差与实际误差平方之间的皮尔逊相关性）。\n\n最终输出格式。你的程序应生成单行输出，其中包含所有三个用例的结果，形式为单个扁平的、逗号分隔的列表，并用方括号括起来，顺序如下\n`[E_{\\mathrm{meas}}^{\\mathrm{df}}(1),\\,E_{\\mathrm{pred}}^{\\mathrm{df}}(1),\\,C^{\\mathrm{df}}(1),\\,E_{\\mathrm{meas}}^{\\mathrm{pz}}(1),\\,E_{\\mathrm{pred}}^{\\mathrm{pz}}(1),\\,C^{\\mathrm{pz}}(1),\\,E_{\\mathrm{meas}}^{\\mathrm{df}}(2),\\,E_{\\mathrm{pred}}^{\\mathrm{df}}(2),\\,C^{\\mathrm{df}}(2),\\,E_{\\mathrm{meas}}^{\\mathrm{pz}}(2),\\,E_{\\mathrm{pred}}^{\\mathrm{pz}}(2),\\,C^{\\mathrm{pz}}(2),\\,E_{\\mathrm{meas}}^{\\mathrm{df}}(3),\\,E_{\\mathrm{pred}}^{\\mathrm{df}}(3),\\,C^{\\mathrm{df}}(3),\\,E_{\\mathrm{meas}}^{\\mathrm{pz}}(3),\\,E_{\\mathrm{pred}}^{\\mathrm{pz}}(3),\\,C^{\\mathrm{pz}}(3)]`\n只打印这一行，不带任何附加文本。", "solution": "该问题要求对二阶IIR数字滤波器的两种不同实现中系数的量化误差进行深入分析。该分析涉及对幅度响应偏差的直接测量和基于一阶灵敏度模型的理论预测。我们必须验证问题，从基本原理推导必要的数学框架，然后对给定的测试用例实施计算。\n\n该问题具有科学依据，提法明确，客观且完整。它提出了一个关于有限字长效应的数字信号处理领域的标准而非凡的任务。所提供的参数和条件在物理上是现实的，并允许得到一个唯一的、有意义的解。因此，该问题被认为是有效的。\n\n滤波器的传递函数由下式给出\n$$\nH(z) = \\frac{B(z)}{A(z)} = \\frac{b_0 + b_1 z^{-1} + b_2 z^{-2}}{1 + a_1 z^{-1} + a_2 z^{-2}}\n$$\n其复频率响应通过代入 $z = e^{j\\omega}$（其中 $\\omega \\in [0, \\pi]$）得到 $H(e^{j\\omega})$。幅度响应为 $|H(e^{j\\omega})|$。\n\n预测性分析的核心在于计算幅度响应相对于参数变化的灵敏度。复函数幅度 $|H|$ 相对于实参数 $\\theta$ 的灵敏度可以从 $|H|^2 = H H^*$ 推导得出，其中 $H^*$ 是 $H$ 的复共轭。对 $\\theta$ 微分得到 $2|H|\\frac{\\partial|H|}{\\partial\\theta} = H^*\\frac{\\partial H}{\\partial\\theta} + H\\frac{\\partial H^*}{\\partial\\theta} = 2\\mathrm{Re}\\left(H^*\\frac{\\partial H}{\\partial\\theta}\\right)$。因此，对于 $|H| \\neq 0$，幅度灵敏度为\n$$\n\\frac{\\partial|H|}{\\partial\\theta} = \\frac{1}{|H|}\\mathrm{Re}\\left(H^*\\frac{\\partial H}{\\partial\\theta}\\right)\n$$\n我们将此通用公式应用于我们的两种实现。\n\n**实现 A：直接形式系数的量化**\n\n参数是多项式系数本身，$\\boldsymbol{\\theta}_{\\mathrm{A}} = \\{b_0, b_1, b_2, a_1, a_2\\}$。我们必须求出 $H(e^{j\\omega})$ 对每个系数的偏导数。令 $H = B/A$。\n\n1.  相对于分子系数 $b_i$ 的灵敏度：\n    $H$ 对 $b_i$ 的导数为 $\\frac{\\partial H}{\\partial b_i} = \\frac{1}{A} \\frac{\\partial B}{\\partial b_i}$。由于 $B(e^{j\\omega}) = \\sum_{k=0}^{2} b_k e^{-jk\\omega}$，我们有 $\\frac{\\partial B}{\\partial b_i} = e^{-ji\\omega}$。因此，$\\frac{\\partial H}{\\partial b_i} = \\frac{e^{-ji\\omega}}{A}$。\n    幅度灵敏度为：\n    $$\n    \\frac{\\partial |H|}{\\partial b_i} = \\frac{1}{|H|} \\mathrm{Re}\\left( H^* \\frac{e^{-ji\\omega}}{A} \\right) = \\frac{1}{|H|} \\mathrm{Re}\\left( \\frac{B^*}{A^*} \\frac{e^{-ji\\omega}}{A} \\right) = \\frac{1}{|H||A|^2} \\mathrm{Re}\\left( B^* e^{-ji\\omega} \\right)\n    $$\n    如果 $|H|$ 接近于零，此公式可能不稳定。一种更稳健的替代推导方法从 $|H|^2 = |B|^2/|A|^2$ 开始。$\\frac{\\partial|H|^2}{\\partial b_i} = \\frac{1}{|A|^2} \\frac{\\partial|B|^2}{\\partial b_i}$。由于 $|B|^2 = B B^*$，$\\frac{\\partial|B|^2}{\\partial b_i} = 2\\mathrm{Re}\\left(B^*\\frac{\\partial B}{\\partial b_i}\\right) = 2\\mathrm{Re}\\left(B^* e^{-ji\\omega}\\right)$。所以，$\\frac{\\partial|H|}{\\partial b_i} = \\frac{1}{2|H|} \\frac{\\partial|H|^2}{\\partial b_i} = \\frac{1}{|H||A|^2} \\mathrm{Re}\\left(B^* e^{-ji\\omega}\\right)$。表达式是相同的，但推导过程证实了其形式。\n\n2.  相对于分母系数 $a_i$ 的灵敏度：\n    $H$ 对 $a_i$ 的导数为 $\\frac{\\partial H}{\\partial a_i} = -\\frac{B}{A^2}\\frac{\\partial A}{\\partial a_i}$。由于 $A(e^{j\\omega}) = 1 + \\sum_{k=1}^{2} a_k e^{-jk\\omega}$，我们有 $\\frac{\\partial A}{\\partial a_i} = e^{-ji\\omega}$。因此，$\\frac{\\partial H}{\\partial a_i} = -H \\frac{e^{-ji\\omega}}{A}$。\n    幅度灵敏度为：\n    $$\n    \\frac{\\partial |H|}{\\partial a_i} = \\frac{1}{|H|} \\mathrm{Re}\\left( H^* \\left(-H \\frac{e^{-ji\\omega}}{A}\\right) \\right) = -\\frac{|H|^2}{|H|} \\mathrm{Re}\\left(\\frac{e^{-ji\\omega}}{A}\\right) = -|H| \\mathrm{Re}\\left(\\frac{e^{-ji\\omega}A^*}{|A|^2}\\right) = -\\frac{|H|}{|A|^2}\\mathrm{Re}\\left(A^* e^{-ji\\omega}\\right)\n    $$\n\n对于实现 A，假设独立的量化误差方差为 $\\Delta_c^2/12$，预测的逐点方差为：\n$$\n\\sigma^2_{|H|, \\mathrm{df}}(\\omega) = \\frac{\\Delta_c^2}{12} \\left[ \\sum_{i=0}^{2} \\left(\\frac{\\partial |H|}{\\partial b_i}\\right)^2 + \\sum_{i=1}^{2} \\left(\\frac{\\partial |H|}{\\partial a_i}\\right)^2 \\right]\n$$\n\n**实现 B：极零点参数的量化**\n\n参数为 $\\boldsymbol{\\theta}_{\\mathrm{B}} = \\{g, r_z, \\phi_z, r_p, \\phi_p\\}$。我们使用链式法则：$\\frac{\\partial |H|}{\\partial \\theta_j} = \\sum_i \\frac{\\partial |H|}{\\partial c_i} \\frac{\\partial c_i}{\\partial \\theta_j}$，其中 $c_i \\in \\{b_0, ..., a_2\\}$ 且 $\\theta_j \\in \\boldsymbol{\\theta}_{\\mathrm{B}}$。灵敏度 $\\frac{\\partial |H|}{\\partial c_i}$ 从实现 A 中已知。我们需要雅可比矩阵 $\\frac{\\partial c_i}{\\partial \\theta_j}$。\n\n系数映射为：$b_0 = g$，$b_1 = -2 g r_z \\cos\\phi_z$，$b_2 = g r_z^2$，$a_1 = -2 r_p \\cos\\phi_p$ 和 $a_2 = r_p^2$。\n\n1.  相对于 $g$ 的灵敏度：$H$ 是 $g$ 的线性函数。假设 $g0$，则 $|H|=g|H_{norm}|$，所以 $\\frac{\\partial |H|}{\\partial g} = |H_{norm}| = \\frac{|H|}{g}$。\n2.  相对于 $r_z$ 的灵敏度：影响 $b_1$ 和 $b_2$。\n    $\\frac{\\partial |H|}{\\partial r_z} = \\frac{\\partial |H|}{\\partial b_1}\\frac{\\partial b_1}{\\partial r_z} + \\frac{\\partial |H|}{\\partial b_2}\\frac{\\partial b_2}{\\partial r_z} = \\frac{\\partial |H|}{\\partial b_1}(-2g\\cos\\phi_z) + \\frac{\\partial |H|}{\\partial b_2}(2gr_z)$。\n3.  相对于 $\\phi_z$ 的灵敏度：影响 $b_1$。\n    $\\frac{\\partial |H|}{\\partial \\phi_z} = \\frac{\\partial |H|}{\\partial b_1}\\frac{\\partial b_1}{\\partial \\phi_z} = \\frac{\\partial |H|}{\\partial b_1}(2gr_z\\sin\\phi_z)$。\n4.  相对于 $r_p$ 的灵敏度：影响 $a_1$ 和 $a_2$。\n    $\\frac{\\partial |H|}{\\partial r_p} = \\frac{\\partial |H|}{\\partial a_1}\\frac{\\partial a_1}{\\partial r_p} + \\frac{\\partial |H|}{\\partial a_2}\\frac{\\partial a_2}{\\partial r_p} = \\frac{\\partial |H|}{\\partial a_1}(-2\\cos\\phi_p) + \\frac{\\partial |H|}{\\partial a_2}(2r_p)$。\n5.  相对于 $\\phi_p$ 的灵敏度：影响 $a_1$。\n    $\\frac{\\partial |H|}{\\partial \\phi_p} = \\frac{\\partial |H|}{\\partial a_1}\\frac{\\partial a_1}{\\partial \\phi_p} = \\frac{\\partial |H|}{\\partial a_1}(2r_p\\sin\\phi_p)$。\n\n对于实现 B，预测的逐点方差是每个参数贡献的总和，每个步长为 $\\Delta_i$ 的参数方差为 $\\Delta_i^2/12$：\n$$\n\\sigma^2_{|H|, \\mathrm{pz}}(\\omega) = \\frac{1}{12} \\left[ \\left(\\frac{\\partial |H|}{\\partial g}\\right)^2 \\Delta_g^2 + \\left(\\frac{\\partial |H|}{\\partial r_z}\\right)^2 \\Delta_{r_z}^2 + \\left(\\frac{\\partial |H|}{\\partial \\phi_z}\\right)^2 \\Delta_{\\phi_z}^2 + \\left(\\frac{\\partial |H|}{\\partial r_p}\\right)^2 \\Delta_{r_p}^2 + \\left(\\frac{\\partial |H|}{\\partial \\phi_p}\\right)^2 \\Delta_{\\phi_p}^2 \\right]\n$$\n\n**计算步骤**\n\n对于每个测试用例：\n1.  定义频率网格 $\\omega_k = k\\pi/(N-1)$，其中 $k=0, ..., N-1$，$N=1024$。\n2.  使用理想的极零点参数，找到增益 $g$ 以满足 $|H(e^{j\\omega_0})|=1$。这涉及计算 $H_{g=1}(e^{j\\omega_0})$ 并设置 $g = 1/|H_{g=1}(e^{j\\omega_0})|$。\n3.  计算理想的多项式系数 $\\{b_0, b_1, b_2, a_1, a_2\\}$ 和网格上的理想频率响应 $H(e^{j\\omega_k})$。\n4.  **对于实现 A**：\n    a. 使用步长 $\\Delta_c$ 量化 $\\{b_0, b_1, b_2, a_1, a_2\\}$。量化函数为 $Q(x, \\Delta) = \\Delta \\cdot \\text{round}(x/\\Delta)$。\n    b. 计算量化后的响应 $H_q(e^{j\\omega_k})$ 并测量 $E_{\\mathrm{meas}}^{\\mathrm{df}}$。\n    c. 计算灵敏度 $\\partial|H|/\\partial c_i$ 和预测方差 $\\sigma^2_{|H|, \\mathrm{df}}(\\omega_k)$。\n    d. 计算预测误差 $E_{\\mathrm{pred}}^{\\mathrm{df}}$。\n    e. 计算误差平方数组和预测方差数组之间的皮尔逊相关性 $C^{\\mathrm{df}}$。\n5.  **对于实现 B**：\n    a. 使用各自的步长量化 $\\{g, r_z, \\phi_z, r_p, \\phi_p\\}$。\n    b. 计算所得的多项式系数和量化后的响应 $H_q(e^{j\\omega_k})$。测量 $E_{\\mathrm{meas}}^{\\mathrm{pz}}$。\n    c. 计算灵敏度 $\\partial|H|/\\partial\\theta_j$ 和预测方差 $\\sigma^2_{|H|, \\mathrm{pz}}(\\omega_k)$。\n    d. 计算预测误差 $E_{\\mathrm{pred}}^{\\mathrm{pz}}$。\n    e. 计算皮尔逊相关性 $C^{\\mathrm{pz}}$。\n\n将实施此程序以生成所需的数值结果。", "answer": "```python\nimport numpy as np\n\ndef quantize(x, delta):\n    \"\"\"Rounds x to the nearest multiple of delta.\"\"\"\n    return delta * np.round(x / delta)\n\ndef pz_to_poly(g, r_z, phi_z, r_p, phi_p):\n    \"\"\"Maps pole-zero parameters to polynomial coefficients.\"\"\"\n    b0 = g\n    b1 = -2 * g * r_z * np.cos(phi_z)\n    b2 = g * r_z**2\n    a1 = -2 * r_p * np.cos(phi_p)\n    a2 = r_p**2\n    return np.array([b0, b1, b2]), np.array([a1, a2])\n\ndef evaluate_freq_response(b, a, omega):\n    \"\"\"\n    Evaluates the frequency response H(e^{j*omega}) for a filter.\n    b = [b0, b1, b2], a = [a1, a2].\n    \"\"\"\n    z_inv = np.exp(-1j * omega)\n    B_z = b[0] + b[1] * z_inv + b[2] * z_inv**2\n    A_z = 1 + a[0] * z_inv + a[1] * z_inv**2\n    H_z = B_z / A_z\n    return H_z, B_z, A_z\n\ndef pearson_corr(x, y):\n    \"\"\"Computes Pearson correlation, robust to constant inputs.\"\"\"\n    if np.std(x) == 0 or np.std(y) == 0:\n        return 0.0\n    return np.corrcoef(x, y)[0, 1]\n\ndef process_case(case):\n    \"\"\"\n    Processes a single test case to compute the six required metrics.\n    \"\"\"\n    # Unpack case parameters\n    (r_z, phi_z, r_p, phi_p), omega_0, delta_c, deltas_pz = case\n    delta_g, delta_rz, delta_phiz, delta_rp, delta_phip = deltas_pz\n    N = 1024\n    omega = np.linspace(0, np.pi, N)\n\n    # 1. Gain Normalization\n    _, b_norm_coeffs = pz_to_poly(1.0, r_z, phi_z, r_p, phi_p)\n    a_norm_coeffs_full = np.array([1, -2*r_p*np.cos(phi_p), r_p**2])\n    \n    H_at_omega0, _, _ = evaluate_freq_response(\n        np.array([1, -2*r_z*np.cos(phi_z), r_z**2]), \n        np.array([-2*r_p*np.cos(phi_p), r_p**2]),\n        np.array([omega_0])\n    )\n    g = 1.0 / np.abs(H_at_omega0[0])\n\n    # 2. Ideal Filter Parameters and Response\n    ideal_pz_params = {'g': g, 'r_z': r_z, 'phi_z': phi_z, 'r_p': r_p, 'phi_p': phi_p}\n    b_ideal_coeffs, a_ideal_coeffs = pz_to_poly(g, r_z, phi_z, r_p, phi_p)\n    \n    H_ideal, B_ideal, A_ideal = evaluate_freq_response(b_ideal_coeffs, a_ideal_coeffs, omega)\n    H_ideal_mag = np.abs(H_ideal)\n\n    # --- Realization A: Direct-Form ---\n    # 3a. Quantize coefficients and compute quantized response\n    b_q_df = quantize(b_ideal_coeffs, delta_c)\n    a_q_df = quantize(a_ideal_coeffs, delta_c)\n    H_q_df, _, _ = evaluate_freq_response(b_q_df, a_q_df, omega)\n    H_q_df_mag = np.abs(H_q_df)\n\n    # 4a. Measured error\n    sq_err_df = (H_q_df_mag - H_ideal_mag)**2\n    E_meas_df = np.sqrt(np.mean(sq_err_df))\n\n    # 5a. Predicted error\n    z_inv = np.exp(-1j * omega)\n    H_ideal_mag_safe = np.where(H_ideal_mag == 0, 1e-12, H_ideal_mag)\n\n    # Sensitivities wrt b_i\n    dabsH_db0 = (1 / (H_ideal_mag_safe * np.abs(A_ideal)**2)) * np.real(np.conj(B_ideal) * 1)\n    dabsH_db1 = (1 / (H_ideal_mag_safe * np.abs(A_ideal)**2)) * np.real(np.conj(B_ideal) * z_inv)\n    dabsH_db2 = (1 / (H_ideal_mag_safe * np.abs(A_ideal)**2)) * np.real(np.conj(B_ideal) * z_inv**2)\n    \n    # Sensitivities wrt a_i\n    dabsH_da1 = - (H_ideal_mag / np.abs(A_ideal)**2) * np.real(np.conj(A_ideal) * z_inv)\n    dabsH_da2 = - (H_ideal_mag / np.abs(A_ideal)**2) * np.real(np.conj(A_ideal) * z_inv**2)\n    \n    var_H_df = (dabsH_db0**2 + dabsH_db1**2 + dabsH_db2**2 + dabsH_da1**2 + dabsH_da2**2) * (delta_c**2 / 12)\n    E_pred_df = np.sqrt(np.mean(var_H_df))\n\n    # 6a. Correlation\n    C_df = pearson_corr(var_H_df, sq_err_df)\n    \n    # --- Realization B: Pole-Zero ---\n    # 3b. Quantize parameters and compute quantized response\n    g_q = quantize(g, delta_g)\n    rz_q = quantize(r_z, delta_rz)\n    phiz_q = quantize(phi_z, delta_phiz)\n    rp_q = quantize(r_p, delta_rp)\n    phip_q = quantize(phi_p, delta_phip)\n    \n    b_q_pz, a_q_pz = pz_to_poly(g_q, rz_q, phiz_q, rp_q, phip_q)\n    H_q_pz, _, _ = evaluate_freq_response(b_q_pz, a_q_pz, omega)\n    H_q_pz_mag = np.abs(H_q_pz)\n\n    # 4b. Measured error\n    sq_err_pz = (H_q_pz_mag - H_ideal_mag)**2\n    E_meas_pz = np.sqrt(np.mean(sq_err_pz))\n\n    # 5b. Predicted error (via chain rule)\n    dabsH_dg = H_ideal_mag / g\n    \n    dabsH_drz = dabsH_db1 * (-2 * g * np.cos(phi_z)) + dabsH_db2 * (2 * g * r_z)\n    dabsH_dphiz = dabsH_db1 * (2 * g * r_z * np.sin(phi_z))\n    \n    dabsH_drp = dabsH_da1 * (-2 * np.cos(phi_p)) + dabsH_da2 * (2 * r_p)\n    dabsH_dphip = dabsH_da1 * (2 * r_p * np.sin(phi_p))\n\n    var_H_pz = (\n        (dabsH_dg**2 * delta_g**2) +\n        (dabsH_drz**2 * delta_rz**2) +\n        (dabsH_dphiz**2 * delta_phiz**2) +\n        (dabsH_drp**2 * delta_rp**2) +\n        (dabsH_dphip**2 * delta_phip**2)\n    ) / 12\n    E_pred_pz = np.sqrt(np.mean(var_H_pz))\n\n    # 6b. Correlation\n    C_pz = pearson_corr(var_H_pz, sq_err_pz)\n\n    return E_meas_df, E_pred_df, C_df, E_meas_pz, E_pred_pz, C_pz\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1\n        (\n            (1.0, np.pi, 0.80, 0.0),                  # (rz, phiz, rp, phip)\n            0.0,                                      # omega_0\n            2**-10,                                   # delta_c\n            (2**-10, 2**-10, 2**-12, 2**-10, 2**-12) # (dg, drz, dphiz, drp, dphip)\n        ),\n        # Case 2\n        (\n            (1.0, 0.0, 0.98, 0.3 * np.pi),\n            0.3 * np.pi,\n            2**-12,\n            (2**-12, 2**-14, 2**-14, 2**-14, 2**-14)\n        ),\n        # Case 3\n        (\n            (1.0, 0.6 * np.pi, 0.95, 0.6 * np.pi),\n            0.0,\n            2**-8,\n            (2**-8, 2**-10, 2**-10, 2**-10, 2**-10)\n        )\n    ]\n\n    results = []\n    for case in test_cases:\n        case_results = process_case(case)\n        results.extend(case_results)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2858985"}, {"introduction": "系数量化只是有限字长效应的一部分。在定点处理器中，每次算术运算（如乘法）后的取整或截断操作，会引入非线性行为，即使在没有输入信号的情况下也能产生寄生振荡，即“极限环”（limit cycles）。本练习要求你通过精确的定点仿真，探索一个二阶IIR滤波器在零输入条件下的动态行为。通过编程确定系统的死区（deadband）宽度和最小非零极限环的振幅，你将亲身体验到由算术量化引起的、线性分析无法捕捉到的复杂动态现象。[@problem_id:2858969]", "problem": "给定一类离散时间、实系数、二阶无限脉冲响应（IIR）系统，该系统采用定点算术实现，并在每个基本运算中进行系数的量化和舍入。该系统由直接型递归定义：\n$$\ny[n] \\;=\\; -a_1\\,y[n-1] \\;-\\; a_2\\,y[n-2] \\;+\\; b_0\\,x[n] \\;+\\; b_1\\,x[n-1] \\;+\\; b_2\\,x[n-2],\n$$\n输入为零，即\n$$\nx[n] \\equiv 0,\n$$\n因此系统演化简化为\n$$\ny[n] \\;=\\; -a_1\\,y[n-1] \\;-\\; a_2\\,y[n-2],\n$$\n但在定点环境中计算，其中每次乘法和每次加法都立即舍入到信号字网格，并饱和到信号范围。系数在使用前被量化。假设采用以下计算模型。\n\n1. 信号字格式：二进制补码定点数，恰好有一位符号位和 $F_s$ 位小数位（没有整数幅值位）。可表示的信号集合为\n$$\n\\mathcal{Y}_{F_s} \\;=\\; \\left\\{ m \\cdot 2^{-F_s} \\;:\\; m \\in \\mathbb{Z}, \\; -2^{F_s} \\le m \\le 2^{F_s}-1 \\right\\},\n$$\n饱和边界为\n$$\ny_{\\min} \\;=\\; -1, \n\\qquad\ny_{\\max} \\;=\\; 1 - 2^{-F_s}.\n$$\n令 $\\Delta_s \\triangleq 2^{-F_s}$ 表示信号量化步长。\n\n2. 系数字格式：实系数 $a_1$ 和 $a_2$ 被量化为 $F_c$ 个小数位，方法是舍入到 $\\Delta_c \\triangleq 2^{-F_c}$ 的最近倍数（出现平局时，舍入到最近的偶数量化级别）。量化后的系数为\n$$\n\\widehat{a}_i \\;=\\; \\operatorname{Q}_c(a_i) \\;=\\; \\operatorname{round\\_to\\_nearest\\_even}\\!\\left(a_i, \\Delta_c\\right), \\quad i \\in \\{1,2\\}。\n$$\n\n3. 算术模型（每次运算都进行舍入并带饱和）：在每个时间点 $n$，计算\n- 两个乘积 $p_1[n] = -\\widehat{a}_1 \\, y[n-1]$ 和 $p_2[n] = -\\widehat{a}_2 \\, y[n-2]$，每个乘积都立即舍入到 $\\Delta_s$ 的最近倍数（平局时舍入到最近的偶数），然后饱和到 $[y_{\\min}, y_{\\max}]$ 范围内，\n- 接着是一个加法 $s[n] = p_1[n] + p_2[n]$，立即饱和到 $[y_{\\min}, y_{\\max}]$ 范围内（由于操作数已经在信号网格上，因此不需要额外的舍入），\n- 最后 $y[n] = s[n]$。\n\n4. 信号网格上的状态空间表示：系统在时间 $n$ 的状态是有序对\n$$\n\\mathbf{s}[n] \\triangleq \\big(y[n], \\; y[n-1]\\big) \\in \\mathcal{Y}_{F_s} \\times \\mathcal{Y}_{F_s},\n$$\n且下一状态是当前状态的确定性函数，即\n$$\n\\mathbf{s}[n+1] \\;=\\; \\Phi(\\mathbf{s}[n]),\n$$\n由上述算术模型导出。由于状态空间是有限的且动力学是确定性的，每个轨迹最终都会进入周期性（收敛到一个不动点或一个非平凡的极限环）。\n\n任务所需的定义：\n\n- 沿 $y[-1]$ 轴的死区宽度：考虑零输入并将初始条件限制为\n$$\ny[-2] \\;=\\; 0, \n\\qquad\ny[-1] \\in \\mathcal{Y}_{F_s}。\n$$\n定义\n$$\n\\mathcal{D} \\;=\\; \\left\\{ y[-1] \\in \\mathcal{Y}_{F_s} \\;:\\; \\text{轨迹收敛到零不动点 } (y[n]\\equiv 0) \\right\\}。\n$$\n设 $D$ 是非负数 $d$ 的上确界，使得整个对称区间 $[-d, d] \\cap \\mathcal{Y}_{F_s}$ 都包含在 $\\mathcal{D}$ 中。死区宽度是这个最大对称区间的长度，\n$$\nW_{\\mathrm{dead}} \\;\\triangleq\\; 2D。\n$$\n\n- 最小非零极限环振幅：对于零输入动力学中的任何周期轨道（极限环），将其振幅定义为\n$$\nA(\\text{环}) \\;\\triangleq\\; \\max_{n \\text{ 在环上}} |y[n]|。\n$$\n在所有非零极限环中，定义\n$$\nA_{\\min} \\;\\triangleq\\; \\min_{\\text{非零极限环}} A(\\text{环})。\n$$\n如果没有非零极限环，则定义 $A_{\\min} \\triangleq 0$。\n\n你的任务是编写一个程序，对于给定的参数集测试套件 $(a_1, a_2, F_c, F_s)$，在上述模型所隐含的有限状态空间上执行精确的定点仿真，并计算：\n\n- 死区宽度 $W_{\\mathrm{dead}}$（一个与 $y[n]$ 单位相同的实数），\n- 最小非零极限环振幅 $A_{\\min}$（一个与 $y[n]$ 单位相同的实数）。\n\n在系数的量化步骤和每次乘法结果处，你必须处理“向最近的偶数舍入”规则。所有饱和操作必须符合信号范围 $[y_{\\min}, y_{\\max}]$。和值也进行饱和处理，但由于其操作数已在信号网格上，因此无需额外舍入。\n\n测试套件：\n\n- 案例 1：$a_1 = -1.8$， $a_2 = 0.81$， $F_c = 6$， $F_s = 6$。\n- 案例 2：$a_1 = 0.0$， $a_2 = 0.0$， $F_c = 10$， $F_s = 5$。\n- 案例 3：$a_1 = -1.98$， $a_2 = 0.9801$， $F_c = 10$， $F_s = 7$。\n\n你的程序应该生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。每个测试案例的结果本身必须是一个形如 $[W_{\\mathrm{dead}}, A_{\\min}]$ 的双元素列表，两者都表示为十进制实数。例如，输出格式必须完全是\n`[[W_1, A_1], [W_2, A_2], [W_3, A_3]]`\n此问题不涉及物理单位。不出现角度。除了指定的单行输出外，不要打印任何其他文本。算法必须相对于有限定点模型是精确的；不要使用随机噪声模型或渐近近似。", "solution": "该问题是有效的，因为它在科学上基于数字信号处理的原理，特别是IIR滤波器中有限字长效应的分析。该问题提法明确、客观，并为计算上可行的任务提供了一套完整且一致的规范。\n\n通过在系统的有限状态空间上执行其动力学的精确仿真来找到解决方案。核心原理是将定点信号值和算术运算映射到整数算术上，以避免浮点不精确性，并直接处理问题的离散性质。\n\n首先，我们形式化系统状态及其演化。时间 $n$ 的状态是前一个输出对 $\\mathbf{s}[n-1] = (y[n-1], y[n-2])$。由于信号值 $y$ 属于离散集合 $\\mathcal{Y}_{F_s} = \\{ m \\cdot \\Delta_s : m \\in \\mathbb{Z}, -2^{F_s} \\le m \\le 2^{F_s}-1 \\}$，其中 $\\Delta_s = 2^{-F_s}$，因此用整数对 $(m_{n-1}, m_{n-2})$ 来表示状态是精确且计算上有利的。整数乘数 $m$ 的范围从 $m_{\\min} = -2^{F_s}$ 到 $m_{\\max} = 2^{F_s}-1$。状态空间是一个包含 $(m_{\\max} - m_{\\min} + 1)^2 = (2 \\cdot 2^{F_s})^2 = 4 \\cdot 2^{2F_s}$ 个状态的有限网格。\n\n状态转移函数 $\\mathbf{s}[n] = \\Phi(\\mathbf{s}[n-1])$ 被实现为一个将整数状态 $(m_{n-1}, m_{n-2})$ 映射到下一个状态 $(m_n, m_{n-1})$ 的函数。新整数乘数 $m_n$ 的计算遵循指定的算术模型：\n1.  **系数的量化**：实系数 $a_1$ 和 $a_2$ 首先被量化为其定点表示 $\\widehat{a}_1$ 和 $\\widehat{a}_2$，方法是舍入到 $\\Delta_c = 2^{-F_c}$ 的最近倍数，平局时舍入到最近的偶数量化级别。这在每个测试案例中执行一次。\n    $$\n    \\widehat{a}_i = \\operatorname{round\\_to\\_nearest\\_even}(a_i, \\Delta_c)\n    $$\n2.  **乘积计算**：计算中间乘积 $p_1[n] = -\\widehat{a}_1 y[n-1]$ 和 $p_2[n] = -\\widehat{a}_2 y[n-2]$。在我们的整数模型中，这对应于计算 $-\\widehat{a}_1 m_{n-1} \\Delta_s$ 和 $-\\widehat{a}_2 m_{n-2} \\Delta_s$。\n3.  **舍入**：每个乘积都舍入到 $\\Delta_s$ 的最近倍数。一个中间值 $V$ 被舍入到 $k \\cdot \\Delta_s$，其中 $k$ 是最接近 $V/\\Delta_s$ 的整数。因此，第一个乘积的整数乘数 $m_{p1}$ 是通过对值 $-\\widehat{a}_1 m_{n-1}$ 进行舍入找到的：\n    $$\n    m_{p1} = \\operatorname{round\\_half\\_to\\_even}(-\\widehat{a}_1 m_{n-1})\n    $$\n    类似地，$m_{p2} = \\operatorname{round\\_half\\_to\\_even}(-\\widehat{a}_2 m_{n-2})$。Python 3 中的标准 `round()` 函数实现了所需的“平局时向偶数舍入”规则。\n4.  **饱和与求和**：乘积的整数乘数被饱和到范围 $[m_{\\min}, m_{\\max}]$ 内。然后将饱和后的乘数 $m_{p1, \\text{sat}}$ 和 $m_{p2, \\text{sat}}$ 相加。和值再次被饱和到同一范围，以产生新输出的最终整数乘数 $m_n$。\n    $$\n    m_n = \\operatorname{clip}(m_{p1, \\text{sat}} + m_{p2, \\text{sat}}, m_{\\min}, m_{\\max})\n    $$\n\n对于有限状态空间上的确定性状态转移函数，每个轨迹最终都必须变为周期性的，收敛到不动点或极限环。为了找到这些吸引子及其吸引盆，我们对状态空间进行穷举搜索。我们使用一个二维数组 `fate` 来存储每个状态的最终归宿。我们遍历每个状态 $(m_1, m_2)$。如果其归宿未知，我们从该状态开始模拟轨迹，并记录路径。路径的模拟在遇到一个已被分类的状态时终止，或者当它重复自身路径中的一个状态时终止，从而识别出一个新的环。然后记录新遍历路径中所有状态的归宿。环被分类为零不动点 $(0,0)$ 或非零极限环，并为其计算振幅。\n\n最后，我们计算所需的量：\n-   **最小非零极限环振幅 ($A_{\\min}$)**：这是为所有已识别的非零极限环计算的振幅中的最小值。一个环的振幅定义为环上 $\\max|y[n]|$，其计算方式为 $(\\max|m_n|) \\cdot \\Delta_s$。如果未找到非零极限环，则 $A_{\\min}$ 为 $0$。\n-   **死区宽度 ($W_{\\mathrm{dead}}$)**：死区与初始值 $y[-1]$（其中 $y[-2]=0$）的集合 $\\mathcal{D}$ 相关，对于这些初始值，系统会收敛到零不动点。我们找到最大的整数 $M \\ge 0$，使得对于范围 $[-M, M]$ 内的所有整数乘数 $k$，从状态 $(k, 0)$ 开始的轨迹都收敛到零不动点 $(0,0)$。死区的半宽为 $D = M \\cdot \\Delta_s$，全宽为 $W_{\\mathrm{dead}} = 2D$。\n\n这种系统化的方法保证了对指定定点模型的精确分析。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the IIR filter analysis problem for a suite of test cases.\n    \"\"\"\n\n    def analyze_system(a1, a2, Fc, Fs):\n        \"\"\"\n        Performs exact fixed-point simulation and analysis for a single system.\n\n        Args:\n            a1 (float): The ideal coefficient a1.\n            a2 (float): The ideal coefficient a2.\n            Fc (int): The number of fractional bits for coefficients.\n            Fs (int): The number of fractional bits for the signal.\n\n        Returns:\n            list: A list containing [W_dead, A_min].\n        \"\"\"\n        # 1. Setup\n        delta_c = 2**(-Fc)\n        delta_s = 2**(-Fs)\n        m_limit = 2**Fs\n        m_min = -m_limit\n        m_max = m_limit - 1\n\n        # Quantize coefficients using round-half-to-even\n        a1_hat = np.round(a1 / delta_c) * delta_c\n        a2_hat = np.round(a2 / delta_c) * delta_c\n\n        # State space representation: integer multipliers (m1, m2)\n        # fate array: 0=unvisited, -1=converges to zero, 0=cycle_id\n        state_space_dim = m_max - m_min + 1\n        fate = np.zeros((state_space_dim, state_space_dim), dtype=np.int32)\n        \n        cycles = {}  # {cycle_id: {'amplitude': float}}\n        cycle_id_counter = 1\n\n        # 2. State Space Traversal\n        for m1_init in range(m_min, m_max + 1):\n            for m2_init in range(m_min, m_max + 1):\n                idx1, idx2 = m1_init + m_limit, m2_init + m_limit\n                \n                if fate[idx1, idx2] != 0:\n                    continue\n\n                # Start a new trajectory simulation\n                s_current = (m1_init, m2_init)\n                path = [s_current]\n                path_dict = {s_current: 0}\n\n                while True:\n                    m_prev1, m_prev2 = s_current\n\n                    # Fixed-point arithmetic using integer multipliers\n                    # round() in Python 3 is round-half-to-even\n                    prod1 = round(-a1_hat * m_prev1)\n                    prod2 = round(-a2_hat * m_prev2)\n                    \n                    prod1_sat = int(np.clip(prod1, m_min, m_max))\n                    prod2_sat = int(np.clip(prod2, m_min, m_max))\n                    \n                    sum_val = prod1_sat + prod2_sat\n                    m_next = int(np.clip(sum_val, m_min, m_max))\n                    \n                    s_next = (m_next, m_prev1)\n                    \n                    next_idx1, next_idx2 = s_next[0] + m_limit, s_next[1] + m_limit\n                    \n                    if fate[next_idx1, next_idx2] != 0:\n                        merged_fate = fate[next_idx1, next_idx2]\n                        for s_in_path in path:\n                            s_idx1 = s_in_path[0] + m_limit\n                            s_idx2 = s_in_path[1] + m_limit\n                            fate[s_idx1, s_idx2] = merged_fate\n                        break\n                    \n                    if s_next in path_dict:\n                        cycle_start_index = path_dict[s_next]\n                        cycle_states = path[cycle_start_index:]\n                        transient_states = path[:cycle_start_index]\n\n                        if len(cycle_states) == 1 and cycle_states[0] == (0, 0):\n                            current_fate = -1\n                        else:\n                            current_fate = cycle_id_counter\n                            max_abs_m = 0\n                            for s_in_cycle in cycle_states:\n                                max_abs_m = max(max_abs_m, abs(s_in_cycle[0]))\n                            \n                            amplitude = max_abs_m * delta_s\n                            cycles[current_fate] = {'amplitude': amplitude}\n                            cycle_id_counter += 1\n\n                        for s in transient_states:\n                            fate[s[0] + m_limit, s[1] + m_limit] = current_fate\n                        for s in cycle_states:\n                            fate[s[0] + m_limit, s[1] + m_limit] = current_fate                        \n                        break\n\n                    path.append(s_next)\n                    path_dict[s_next] = len(path) - 1\n                    s_current = s_next\n\n        # 3. Calculate W_dead\n        m2_idx_zero = 0 + m_limit\n        max_m_deadband = 0\n        if fate[0 + m_limit, m2_idx_zero] == -1:\n            for m in range(1, m_limit):\n                fate_pos = fate[m + m_limit, m2_idx_zero]\n                fate_neg = fate[-m + m_limit, m2_idx_zero]\n                \n                if fate_pos == -1 and fate_neg == -1:\n                    max_m_deadband = m\n                else:\n                    break\n        D = max_m_deadband * delta_s\n        W_dead = 2 * D\n\n        # 4. Calculate A_min\n        all_amplitudes = [c['amplitude'] for c in cycles.values()]\n        A_min = min(all_amplitudes) if all_amplitudes else 0.0\n        \n        return [W_dead, A_min]\n\n    test_cases = [\n        (-1.8, 0.81, 6, 6),\n        (0.0, 0.0, 10, 5),\n        (-1.98, 0.9801, 10, 7),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = analyze_system(*case)\n        results.append(result)\n\n    formatted_results = [f\"[{r[0]},{r[1]}]\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2858969"}]}