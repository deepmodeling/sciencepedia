{"hands_on_practices": [{"introduction": "在许多资源受限的嵌入式系统中，定点运算因其效率而成为首选。然而，在反馈回路中，量化误差的累积可能导致意想不到的自持振荡，即“极限环”，即使在没有外部输入的情况下也是如此。本练习将引导您通过逐步追踪一个简单的一阶递归滤波器，亲手揭示并量化这种由量化引起的非线性现象，从而具体理解有限精度如何影响系统的动态行为和稳定性。[@problem_id:2887725]", "problem": "考虑一个在定点算术中实现的、零外部输入的一阶递归数字滤波器。理想的实值递归由 $y[n]=a\\,y[n-1]$ 给出，其中 $|a|<1$。该实现使用带符号的定点格式，其最低有效位（LSB）步长为 $\\Delta>0$，动态范围无限（无溢出），并在状态更新时应用一个舍入量化器。量化器定义为 $Q(x)=\\Delta \\,\\mathrm{Round}_{\\mathrm{half\\text{-}away}}(x/\\Delta)$，其中 $\\mathrm{Round}_{\\mathrm{half\\text{-}away}}(\\cdot)$ 舍入到最近的整数，并在遇到半整数时向远离零的方向舍入。因此，实现的递归是\n$$\ny[n] \\;=\\; Q\\!\\big(a\\,y[n-1]\\big).\n$$\n假设 $\\Delta=1$（因此所有可表示的值都是整数），系数 $a=-\\tfrac{1}{2}$ 在乘法器中精确表示，并且初始条件为 $y[-1]=1$。不存在饱和、非规格化处理和随机效应。\n\n1) 仅使用上述定义和所述的递归，分析零输入行为并确定是否会出现非零极限环。如果出现，导出其精确周期，并量化其稳态振幅 $A_{\\mathrm{lim}}$，该振幅为轨道稳定后 $y[n]$ 所达到的最大绝对值，以最低有效位为单位（即 $\\Delta$ 的倍数）。\n\n2) 为了消除此定点实现中的确定性极限环，你需要提出一种应用于量化器输入的减法抖动方案，其中相同的抖动在量化后立即被减去。具体来说，考虑将更新修改为\n$$\ny[n] \\;=\\; Q\\!\\big(a\\,y[n-1] + d[n]\\big) \\;-\\; d[n],\n$$\n其中 $\\{d[n]\\}$ 是一个独立同分布的零均值抖动序列，其连续概率密度支撑在一个对称的有界区间上。在经典要求下，即对于所有输入值，有效量化误差必须独立于量化器的输入，确定能为所述舍入模式实现这一保证的最小峰峰值抖动振幅 $A_{d,\\min}$，以最低有效位为单位表示。\n\n将你的最终结果报告为一个双元素行向量 $\\big[A_{\\mathrm{lim}},\\,A_{d,\\min}\\big]$，以最低有效位为单位。不需要单位。如果需要数值，请提供精确的整数值；不要四舍五入。", "solution": "首先验证问题，以确保其科学上合理、良构且客观。\n\n**问题验证**\n\n步骤1：提取已知条件\n- 理想递归：$y[n]=a\\,y[n-1]$，其中 $|a|<1$。\n- 实现递归：$y[n] = Q(a\\,y[n-1])$。\n- 量化器：$Q(x)=\\Delta \\,\\mathrm{Round}_{\\mathrm{half\\text{-}away}}(x/\\Delta)$，其中 $\\mathrm{Round}_{\\mathrm{half\\text{-}away}}(\\cdot)$ 舍入到最近的整数，通过向远离零的方向舍入来解决半整数问题。\n- LSB步长：$\\Delta=1$。\n- 系数：$a=-\\tfrac{1}{2}$。\n- 初始条件：$y[-1]=1$。\n- 第1部分中无溢出、无饱和、无随机效应。\n- 第1部分任务：确定是否存在非零极限环。如果存在，求其周期和稳态振幅 $A_{\\mathrm{lim}}$。\n- 第2部分的抖动递归：$y[n] = Q(a\\,y[n-1] + d[n]) - d[n]$，其中 $\\{d[n]\\}$ 是一个独立同分布的零均值抖动序列，其连续概率密度支撑在一个对称的有界区间上。\n- 第2部分任务：求使有效量化误差独立于量化器输入的最小峰峰值抖动振幅 $A_{d,\\min}$。\n- 最终答案格式：一个行向量 $[A_{\\mathrm{lim}}, A_{d,\\min}]$。\n\n步骤2：验证\n- 问题是**科学上合理的**。它使用标准模型解决了数字信号处理的核心概念，即定点算术、量化误差、极限环和抖动。\n- 问题是**良构的**。两个部分都要求从一个完全确定的确定性系统（第1部分）和一个标准的统计要求（第2部分）中导出特定的量。可以通过正确应用原理来确定解的存在性和唯一性。\n- 问题是**客观的**。它以精确的数学语言陈述，没有歧义或主观内容。\n- 所有必要的数据（$\\Delta, a, y[-1]$，量化器和抖动方案的精确形式）都已提供，使得问题**自洽且完整**。\n- **没有矛盾**或不切实际的条件。\n\n步骤3：结论\n该问题被认为是**有效的**。将提供完整解答。\n\n**第1部分：极限环分析**\n\n系统由非线性差分方程 $y[n] = Q(a\\,y[n-1])$ 描述。\n给定参数 $\\Delta=1$ 和 $a = -\\frac{1}{2}$，递归变为：\n$$y[n] = Q\\left(-\\frac{1}{2}y[n-1]\\right) = \\mathrm{Round}_{\\mathrm{half\\text{-}away}}\\left(-\\frac{1}{2}y[n-1]\\right)$$\n量化器将其参数舍入到最近的整数。对于恰好在半整数上的值（例如 $k+0.5$），它向远离零的方向舍入。这意味着对于正参数 $u$，$\\mathrm{Round}_{\\mathrm{half\\text{-}away}}(u) = \\lfloor u+0.5 \\rfloor$，对于负参数 $u$，$\\mathrm{Round}_{\\mathrm{half\\text{-}away}}(u) = \\lceil u-0.5 \\rceil$。当 $n \\ge 0$ 时，可表示的值 $y[n]$ 是整数。\n\n我们从初始条件 $y[-1]=1$ 开始计算序列 $y[n]$。\n当 $n=0$ 时：\n$$y[0] = \\mathrm{Round}_{\\mathrm{half\\text{-}away}}\\left(-\\frac{1}{2}y[-1]\\right) = \\mathrm{Round}_{\\mathrm{half\\text{-}away}}\\left(-\\frac{1}{2} \\cdot 1\\right) = \\mathrm{Round}_{\\mathrm{half\\text{-}away}}(-0.5)$$\n参数为负，因此我们向远离零的方向舍入。\n$$y[0] = -1$$\n当 $n=1$ 时：\n$$y[1] = \\mathrm{Round}_{\\mathrm{half\\text{-}away}}\\left(-\\frac{1}{2}y[0]\\right) = \\mathrm{Round}_{\\mathrm{half\\text{-}away}}\\left(-\\frac{1}{2} \\cdot (-1)\\right) = \\mathrm{Round}_{\\mathrm{half\\text{-}away}}(0.5)$$\n参数为正，因此我们向远离零的方向舍入。\n$$y[1] = 1$$\n当 $n=2$ 时：\n$$y[2] = \\mathrm{Round}_{\\mathrm{half\\text{-}away}}\\left(-\\frac{1}{2}y[1]\\right) = \\mathrm{Round}_{\\mathrm{half\\text{-}away}}\\left(-\\frac{1}{2} \\cdot 1\\right) = \\mathrm{Round}_{\\mathrm{half\\text{-}away}}(-0.5) = -1$$\n当 $n=3$ 时：\n$$y[3] = \\mathrm{Round}_{\\mathrm{half\\text{-}away}}\\left(-\\frac{1}{2}y[2]\\right) = \\mathrm{Round}_{\\mathrm{half\\text{-}away}}\\left(-\\frac{1}{2} \\cdot (-1)\\right) = \\mathrm{Round}_{\\mathrm{half\\text{-}away}}(0.5) = 1$$\n对于 $n \\ge 0$ 的序列是 $\\{-1, 1, -1, 1, \\dots\\}$。系统已进入一个非零极限环。\n该极限环的周期是 $T=2$。稳态轨道中的值为 $\\{-1, 1\\}$。\n稳态振幅 $A_{\\mathrm{lim}}$ 是在周期内达到的最大绝对值：\n$$A_{\\mathrm{lim}} = \\max_{y \\in \\{-1, 1\\}} |y| = \\max(|-1|, |1|) = 1$$\n以 LSB 为单位（$\\Delta=1$），振幅为 $1$。\n\n**第2部分：抖动振幅确定**\n\n加抖动的系统由 $y[n] = Q(x[n] + d[n]) - d[n]$ 给出，其中 $x[n] = a\\,y[n-1]$。\n有效量化误差 $e_{\\mathrm{eff}}[n]$ 由关系式 $y[n] = x[n] + e_{\\mathrm{eff}}[n]$ 定义。\n通过代入 $y[n]$ 的表达式，我们得到：\n$$x[n] + e_{\\mathrm{eff}}[n] = Q(x[n] + d[n]) - d[n]$$\n$$e_{\\mathrm{eff}}[n] = Q(x[n] + d[n]) - (x[n] + d[n])$$\n令 $u[n] = x[n] + d[n]$。误差为 $e_{\\mathrm{eff}}[n] = Q(u[n]) - u[n]$。这是量化器输入的标准量化误差，该输入为 $u[n]$。我们将此误差函数表示为 $e_Q(u) = Q(u)-u$。\n\n问题要求有效误差 $e_{\\mathrm{eff}}[n]$ 的统计特性独立于输入 $x[n]$。这是抖动理论中的一个经典结果。实现此目的的条件是，加抖动的输入模量化步长 $\\Delta$ 后的概率密度函数（PDF）必须是均匀的。\n设 $x$ 为固定输入值，$d$ 为抖动随机变量。令 $u = x+d$。条件是 $U = u \\pmod \\Delta$ 的概率密度函数在区间 $[0, \\Delta)$ 上必须是均匀的，即对于 $v \\in [0, \\Delta)$，有 $p_U(v) = 1/\\Delta$。\n\n$U$ 的 PDF 可以通过对所有混叠求和（Roberts' Theorem）来用抖动 PDF $p_d(\\cdot)$ 表示：\n$$p_U(v) = \\sum_{k=-\\infty}^{\\infty} p_{x+d}(v+k\\Delta) = \\sum_{k=-\\infty}^{\\infty} p_d(v-x+k\\Delta)$$\n为了使该和独立于 $x$ 并等于 $1/\\Delta$，对于任何移位，该和是常数就足够了。这简化为对抖动 PDF 本身的要求：\n$$\\sum_{k=-\\infty}^{\\infty} p_d(z+k\\Delta) = \\frac{1}{\\Delta} \\quad \\text{对于所有 } z \\in \\mathbb{R}$$\n抖动支撑在一个对称有界区间 $[-A_p, A_p]$ 上。峰峰值振幅为 $A_d = 2A_p$。我们需要找到 $A_d$ 的最小可能值。\n\n我们来分析这个和。如果支撑宽度 $A_d = 2A_p$ 小于 $\\Delta$，即 $A_p  \\Delta/2$，那么对于某些 $z$ 值，对所有整数 $k$，$z+k\\Delta$ 都会落在支撑区间 $[-A_p, A_p]$ 之外。对于这样的 $z$，和中的每一项 $p_d(z+k\\Delta)$ 都为零，所以和为零。这与和等于 $1/\\Delta$ 的要求相矛盾。因此，峰峰值振幅 $A_d$ 必须至少为 $\\Delta$。\n$$A_d \\ge \\Delta$$\n现在我们必须检查最小值 $A_d = \\Delta$ 是否可以实现。如果 $A_d = \\Delta$，则 $A_p = \\Delta/2$，支撑区间为 $[-\\Delta/2, \\Delta/2]$。\n一个在 $[-\\Delta/2, \\Delta/2]$ 上均匀分布的抖动信号的 PDF 为：\n$$p_d(v) = \\begin{cases} 1/\\Delta  \\text{对于 } v \\in [-\\Delta/2, \\Delta/2] \\\\ 0  \\text{其它情况} \\end{cases}$$\n对于这个 PDF，和 $\\sum_k p_d(z+k\\Delta)$ 对所有 $z$ 都等于 $1/\\Delta$。对于任何 $z$，恰好存在一个整数 $k$，使得 $z+k\\Delta$ 落入形如 $[c, c+\\Delta)$ 的区间。如果我们将此区间中心设在 0，即 $[-\\Delta/2, \\Delta/2]$，则恰好存在一个 $k$ 使得 $z+k\\Delta$ 在此支撑区间内（不考虑端点，因为对于连续变量其测度为零）。因此，和的值为 $1/\\Delta$。\n这证实了峰峰值振幅为 $\\Delta$ 是足够的。虽然问题指定了“连续概率密度”，但均匀分布是满足该条件的连续随机变量的典型例子，其在此背景下的使用是标准的。任何在严格意义上连续（即函数 $p_d(v)$ 是连续的）且满足条件的抖动 PDF 都必须具有比 $\\Delta$ 更宽的支撑区间。然而，存在合适 PDF 的最小*支撑宽度*是 $\\Delta$。因此，最小振幅是在这个标准背景下解释的。\n\n因此，最小峰峰值抖动振幅为 $\\Delta$。\n给定 $\\Delta=1$，\n$$A_{d,\\min} = 1$$\n\n**最终结果**\n\n所需的两个值为 $A_{\\mathrm{lim}}=1$ 和 $A_{d,\\min}=1$。最终答案是行向量 $[1, 1]$。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n1  1\n\\end{pmatrix}\n}\n$$", "id": "2887725"}, {"introduction": "尽管浮点数提供了巨大的动态范围，但它们并非对精度问题免疫。一个典型且重要的问题是“灾难性抵消”，即两个几乎相等的数值相减，可能导致相对精度的灾难性损失。本练习将挑战您分析一个此类现象的经典案例，精确量化信息损失的程度，并推导出一个代数上等价但数值上稳定的替代算法。掌握这种诊断和重构计算的能力，是编写稳健科学和工程代码的关键技能。[@problem_id:2887738]", "problem": "一项计算在电气和电子工程师协会（Institute of Electrical and Electronics Engineers, IEEE）浮点算术标准（IEEE 754）的 binary64 格式下执行，采用“舍入到最近，偶数优先”的舍入模式，以及精确舍入的平方根。回顾一下，binary64 的有效数（significand）具有固定的 $p=53$ 位精度（包括隐含的前导位）。对于量级约为 $2^{k}$ 的数，其末位单位（ULP）为 $2^{k-52}$。令 $\\operatorname{fl}(\\cdot)$ 表示一个实数运算的精确舍入 binary64 结果。\n\n考虑实数 $r_{1}=\\sqrt{N+1}$ 和 $r_{2}=\\sqrt{N}$，其中 $N=2^{104}$。定义 binary64 数 $a=\\operatorname{fl}(r_{1})$ 和 $b=\\operatorname{fl}(r_{2})$。\n\n(i) 仅使用上述定义以及 ULP 间距和向最近舍入的一般性质，构造出明确的 binary64 数对 $a$ 和 $b$，并证明它们的减法表现出灾难性抵消，即 $\\operatorname{fl}(a-b)$ 无法解析出真实的实数差 $r_{1}-r_{2}$。\n\n(ii) 为了量化减法中有效位的损失，定义损失指数\n$$\nK \\triangleq \\left\\lfloor \\log_{2}\\!\\left(\\frac{M}{D}\\right)\\right\\rfloor,\n$$\n其中 $M=\\max\\{|r_{1}|,|r_{2}|\\}$ 且 $D=|r_{1}-r_{2}|$。对于上面指定的 $N$，精确计算 $K$。\n\n(iii) 推荐并证明一个用于计算 $r_{1}-r_{2}$ 的数学等价重构式，该重构式能避免在 binary64 中的灾难性抵消，要求从第一性原理推导它，而不是引用一个已知公式，并（从 ULP 和向最近舍入的角度定性地）解释为什么重构后的计算是数值稳定的。\n\n最终答案只需提供第 (ii) 部分的 $K$ 值。无需舍入说明，因为结果是一个没有物理单位的精确整数。", "solution": "在尝试解决问题之前，将根据指定标准对问题进行验证。\n\n步骤 1：提取已知条件\n- 计算格式：电气和电子工程师协会（Institute of Electrical and Electronics Engineers, IEEE）浮点算术标准（IEEE 754）binary64。\n- 舍入模式：向最邻近数舍入，偶数优先。\n- 平方根：精确舍入，记为 $\\operatorname{fl}(\\sqrt{\\cdot})$。\n- 有效数精度：$p=53$ 位（包括隐含的前导位）。\n- 末位单位（ULP）：对于量级约为 $2^{k}$ 的数，ULP 为 $2^{k-52}$。\n- 浮点舍入函数：$\\operatorname{fl}(\\cdot)$。\n- 实数量：$r_{1}=\\sqrt{N+1}$ 和 $r_{2}=\\sqrt{N}$。\n- 常数：$N=2^{104}$。\n- 浮点数：$a=\\operatorname{fl}(r_{1})$ 和 $b=\\operatorname{fl}(r_{2})$。\n- 损失指数定义：$K \\triangleq \\left\\lfloor \\log_{2}\\!\\left(\\frac{M}{D}\\right)\\right\\rfloor$，其中 $M=\\max\\{|r_{1}|,|r_{2}|\\}$ 且 $D=|r_{1}-r_{2}|$。\n\n步骤 2：使用提取的已知条件进行验证\n该问题具有科学依据，植根于 IEEE 754 定义的数值分析和浮点算术的标准原则。这是一个适定问题，提供了所有必要的参数（$N$、$p$、舍入模式）以唯一确定所讨论的量。问题陈述客观，并使用精确、正式的语言。这是一个标准的、非平凡的问题，旨在说明灾难性抵消现象及其缓解方法，与数字表示这一主题直接相关。清单中未发现任何缺陷。\n\n步骤 3：结论与行动\n问题有效。将提供一个完整、合理的解答。\n\n解答过程将依次处理问题的三个部分。\n\n(i) 显式构造 $a$ 和 $b$ 并演示灾难性抵消。\n\n首先，我们分析 $r_{2} = \\sqrt{N} = \\sqrt{2^{104}} = 2^{52}$。在 binary64 格式中，一个数表示为 $\\pm (1.f)_{2} \\times 2^{e_{\\text{biased}}-1023}$。$2^{52}$ 这个值可以写成 $1.0 \\times 2^{52}$。该表示的有效数是 1 后面跟全是零，指数是 52。这是一个精确的二进制浮点数。因此，它在 binary64 中的表示是精确的：$b = \\operatorname{fl}(r_{2}) = \\operatorname{fl}(2^{52}) = 2^{52}$。\n\n接下来，我们分析 $r_{1} = \\sqrt{N+1} = \\sqrt{2^{104}+1}$。我们使用二项式展开式处理 $\\sqrt{1+x}$，其中 $x$ 很小：$\\sqrt{1+x} = 1 + \\frac{1}{2}x - \\frac{1}{8}x^2 + O(x^3)$。\n$r_{1} = \\sqrt{2^{104}(1 + 2^{-104})} = 2^{52}\\sqrt{1 + 2^{-104}}$。\n令 $x = 2^{-104}$，我们有：\n$r_{1} = 2^{52} \\left(1 + \\frac{1}{2}(2^{-104}) - \\frac{1}{8}(2^{-104})^2 + \\dots \\right) = 2^{52} \\left(1 + 2^{-105} - 2^{-3} \\cdot 2^{-208} + \\dots \\right) = 2^{52} + 2^{-53} - 2^{-159} + \\dots$。\n$r_{1}$ 的值略大于 $2^{52}$。我们必须确定它如何舍入为一个 binary64 数。浮点数 $b$ 是 $2^{52}$。我们需要找到比 $b$ 大的下一个可表示的 binary64 数。\n量级约为 $2^{52}$ 的数的末位单位是 $\\operatorname{ulp}(2^{52})$。指数为 $E=52$。精度为 $p=53$。ULP 由 $2^{E-(p-1)} = 2^{52-(53-1)} = 2^{0} = 1$ 给出。\n因此，$2^{52}$ 附近的可表示数之间的间隔为 $1$。包围 $r_{1}$ 的两个 binary64 数是 $y_{\\text{low}} = 2^{52}$ 和 $y_{\\text{high}} = 2^{52}+1$。\n舍入模式是向最邻近数舍入，偶数优先。$y_{\\text{low}}$ 和 $y_{\\text{high}}$ 之间的中点是 $m = \\frac{y_{\\text{low}}+y_{\\text{high}}}{2} = \\frac{2^{52} + (2^{52}+1)}{2} = 2^{52} + \\frac{1}{2} = 2^{52} + 2^{-1}$。\n我们的值是 $r_{1} = 2^{52} + 2^{-53} - 2^{-159} + \\dots$。由于 $2^{-53}  2^{-1}$，显然 $r_{1}  m$。\n因此，$r_{1}$ 向下舍入到最近的可表示数，即 $y_{\\text{low}}$。\n所以，$a = \\operatorname{fl}(r_{1}) = 2^{52}$。\n我们因此构造了明确的数对：$a = 2^{52}$ 和 $b = 2^{52}$。\n计算出的减法结果是 $\\operatorname{fl}(a-b) = \\operatorname{fl}(2^{52}-2^{52}) = \\operatorname{fl}(0) = 0$。\n真实的实数差是 $r_{1}-r_{2} = \\sqrt{2^{104}+1} - 2^{52}$。根据我们的展开式，这个差是 $r_{1}-r_{2} = 2^{-53} - 2^{-159} + \\dots$，这是一个约等于 $2^{-53}$ 的很小的正数。\n计算结果是 $0$，而真实结果非零。相对误差基本上是无穷大。这演示了灾难性抵消：将 $r_1$ 和 $r_2$ 舍入为 $a$ 和 $b$ 的初始步骤丢失了关于它们微小差异的所有信息。减法 $\\operatorname{fl}(a-b)$ 未能解析出真实的差值 $r_1-r_2$。\n\n(ii) 计算损失指数 $K$。\n\n损失指数定义为 $K = \\left\\lfloor \\log_{2}\\!\\left(\\frac{M}{D}\\right)\\right\\rfloor$。\n我们有 $M = \\max\\{|r_{1}|,|r_{2}|\\} = \\max\\{\\sqrt{N+1}, \\sqrt{N}\\} = \\sqrt{N+1}$。\n并且 $D = |r_{1}-r_{2}| = \\sqrt{N+1} - \\sqrt{N}$。\n比率为 $\\frac{M}{D} = \\frac{\\sqrt{N+1}}{\\sqrt{N+1} - \\sqrt{N}}$。\n为了简化这个表达式，我们将分数 $\\frac{1}{D}$ 的分子和分母同乘以其分母的共轭表达式：\n$D = \\frac{(\\sqrt{N+1} - \\sqrt{N})(\\sqrt{N+1} + \\sqrt{N})}{\\sqrt{N+1} + \\sqrt{N}} = \\frac{(N+1) - N}{\\sqrt{N+1} + \\sqrt{N}} = \\frac{1}{\\sqrt{N+1} + \\sqrt{N}}$。\n因此，$\\frac{M}{D} = M \\cdot (\\sqrt{N+1} + \\sqrt{N}) = \\sqrt{N+1}(\\sqrt{N+1} + \\sqrt{N}) = (N+1) + \\sqrt{N(N+1)}$。\n代入 $N=2^{104}$：\n$\\frac{M}{D} = (2^{104}+1) + \\sqrt{2^{104}(2^{104}+1)} = 2^{104}+1 + \\sqrt{2^{208}+2^{104}}$。\n我们需要求这个量的以 2 为底的对数的整数部分。令 $Y = \\frac{M}{D}$。\n我们建立 $Y$ 的界限。\n对于下界：\n$\\sqrt{2^{208}+2^{104}} > \\sqrt{2^{208}} = 2^{104}$。\n所以，$Y > (2^{104}+1) + 2^{104} = 2 \\cdot 2^{104} + 1 = 2^{105} + 1$。\n对于上界，考虑恒等式 $(x+y)^{2} = x^2+2xy+y^2$。令 $x=2^{104}$ 和 $y=1/2=2^{-1}$。\n$(2^{104} + 2^{-1})^2 = (2^{104})^2 + 2(2^{104})(2^{-1}) + (2^{-1})^2 = 2^{208} + 2^{104} + \\frac{1}{4}$。\n由于 $2^{208}+2^{104}  2^{208}+2^{104}+1/4$，我们有 $\\sqrt{2^{208}+2^{104}}  \\sqrt{(2^{104}+2^{-1})^2} = 2^{104}+2^{-1}$。\n所以，$Y  (2^{104}+1) + (2^{104}+2^{-1}) = 2 \\cdot 2^{104} + 1.5 = 2^{105} + 1.5$。\n我们已经建立了严格的界限 $2^{105} + 1  Y  2^{105} + 1.5$。\n取以 2 为底的对数：\n$\\log_{2}(2^{105}+1)  \\log_{2}(Y)  \\log_{2}(2^{105}+1.5)$。\n由于 $2^{105}  2^{105}+1$，我们有 $\\log_{2}(2^{105})  \\log_{2}(2^{105}+1)$，这意味着 $105  \\log_{2}(Y)$。\n同样，由于 $2^{105}+1.5  2^{106}$，我们有 $\\log_{2}(Y)  \\log_{2}(2^{106}) = 106$。\n所以，$105  \\log_{2}(Y)  106$。\n因此，该值的底函数为 $\\lfloor \\log_{2}(Y) \\rfloor = 105$。\n$K=105$。\n\n(iii) 重构与证明。\n\n$r_{1}-r_{2} = \\sqrt{N+1} - \\sqrt{N}$ 中的灾难性抵消源于两个几乎相等的大数相减。为避免这种情况，我们必须重构表达式以消除减法。这可以通过乘以并除以共轭表达式 $\\sqrt{N+1}+\\sqrt{N}$ 来推导：\n$r_{1}-r_{2} = (\\sqrt{N+1} - \\sqrt{N}) \\times \\frac{\\sqrt{N+1}+\\sqrt{N}}{\\sqrt{N+1}+\\sqrt{N}} = \\frac{(N+1)-N}{\\sqrt{N+1}+\\sqrt{N}} = \\frac{1}{\\sqrt{N+1}+\\sqrt{N}}$。\n这就是推荐的重构式。\n\n证明：重构后的表达式是数值稳定的，因为它用一个良性的加法替换了有问题的减法。\n让我们分析在 binary64 中计算 $y = \\frac{1}{\\sqrt{N+1}+\\sqrt{N}}$ 的过程。\n1. 计算 $a = \\operatorname{fl}(\\sqrt{N+1})$ 和 $b = \\operatorname{fl}(\\sqrt{N})$。如第 (i) 部分所示，对于 $N=2^{104}$，这两个值都舍入到相同的值 $2^{52}$。\n2. 计算和 $S = \\operatorname{fl}(a+b) = \\operatorname{fl}(2^{52}+2^{52}) = \\operatorname{fl}(2 \\cdot 2^{52}) = \\operatorname{fl}(2^{53})$。这个运算是精确的，所以 $S=2^{53}$。\n3. 计算最终结果 $R = \\operatorname{fl}(1/S) = \\operatorname{fl}(1/2^{53}) = \\operatorname{fl}(2^{-53})$。值 $2^{-53}$ 是 2 的幂，可以精确地表示为一个规格化的 binary64 数。所以最终计算结果精确地为 $R=2^{-53}$。\n\n真实值为 $D = \\frac{1}{\\sqrt{2^{104}+1}+2^{52}}$。如第 (i) 部分所示，$\\sqrt{2^{104}+1} = 2^{52}+2^{-53}-\\dots$。\n所以，$D = \\frac{1}{(2^{52}+2^{-53}-\\dots)+2^{52}} = \\frac{1}{2^{53}+2^{-53}-\\dots}$。\n这个值非常接近 $\\frac{1}{2^{53}} = 2^{-53}$。\n重构计算的相对误差约为 $\\left| \\frac{D-R}{D} \\right| \\approx \\left| \\frac{(2^{-53}(1-2^{-106})) - 2^{-53}}{2^{-53}(1-2^{-106})} \\right| \\approx 2^{-106}$，这是一个极小的值。\n定性地看，原始形式 $\\operatorname{fl}(\\operatorname{fl}(\\sqrt{N+1}) - \\operatorname{fl}(\\sqrt{N}))$ 会失败，因为真实差值 $|r_1-r_2| \\approx 2^{-53}$ 小于计算单个平方根时的舍入误差，该误差的量级为 $\\operatorname{ulp}(\\sqrt{N}) = \\operatorname{ulp}(2^{52}) = 1$。真实差值的所有有效位都丢失了。\n相比之下，重构后的表达式计算 $\\operatorname{fl}(1 / (\\operatorname{fl}(\\sqrt{N+1}) + \\operatorname{fl}(\\sqrt{N})))$。加法 $\\sqrt{N+1}+\\sqrt{N}$ 是数值稳定的，因为它将两个大的、正的、几乎相等的数相加。和的相对误差很小。随后的除法也是一个稳定的运算。新算法保留了信息并得出一个高度准确的结果。", "answer": "$$\n\\boxed{105}\n$$", "id": "2887738"}, {"introduction": "为了在设计阶段系统地评估数字信号处理（DSP）算法在定点约束下的性能，一个灵活的仿真框架是不可或缺的。这样的框架允许工程师在信号处理路径的各个关键节点插入量化器，精确模拟硬件中的取整和饱和效应。在这个综合性练习中，您将设计并实现一个完整的一阶滤波器仿真器。这项实践使您能够测试不同的定点格式，并系统地识别和分析如饱和、极限环和误差累积等潜在的有限精度问题。[@problem_id:2887709]", "problem": "设计并实现一个完整的、可运行的程序，模拟离散时间线性时不变算法内部每个运算的定点量化。要模拟的算法是一个一阶直接型差分方程，带有一个前馈延迟和一个反馈延迟。该框架必须允许在明确定义的操作位置插入量化器，并且必须精确地建模舍入和饱和。\n\n您必须从以下核心定义开始。\n\n1. 有符号定点格式由字长 $W \\in \\mathbb{Z}_{\\ge 2}$ 和小数位数 $F \\in \\mathbb{Z}_{\\ge 0}$ 指定，通常表示为 $Q(W,F)$。实数表示为按 $2^{-F}$ 缩放的整数，其二进制补码饱和边界由下式给出：\n$$\nx_{\\min} \\,=\\, -\\frac{2^{W-1}}{2^F}, \\quad x_{\\max} \\,=\\, \\frac{2^{W-1}-1}{2^F}.\n$$\n量化器 $Q_{W,F}(\\cdot)$ 将任何实数输入 $x \\in \\mathbb{R}$ 映射到 $Q(W,F)$ 中最接近的可表示值，采用“四舍六入五成双”（rounding to nearest, ties to even）的舍入规则，然后饱和到 $[x_{\\min}, x_{\\max}]$。\n\n2. 为实现“四舍六入五成双”的舍入规则，请在缩放后的整数域中应用该规则：令 $s = x \\cdot 2^F$。将 $s$ 映射为 $r = \\mathrm{round\\_to\\_nearest\\_even}(s)$，然后将 $r$ 裁剪到整数区间 $[ -2^{W-1},\\, 2^{W-1}-1 ]$ 内，最后返回 $r / 2^F$。当 $r$ 在裁剪前落在整数区间之外时，就会发生饱和。\n\n3. 首项系数归一化的一阶直接型差分方程由实系数 $b_0, b_1, a_1 \\in \\mathbb{R}$ 和以下递归式定义：\n$$\ny[n] \\,=\\, b_0\\,x[n] \\,+\\, b_1\\,x[n-1] \\,-\\, a_1\\,y[n-1],\n$$\n对于 $n \\in \\{0,1,2,\\dots\\}$，初始条件为 $x[-1]=0$ 和 $y[-1]=0$。所有信号都是无量纲的实值序列。实值参考输出是在 $\\mathbb{R}$ 中评估递归式且不进行任何量化所产生的序列。\n\n您的任务是设计一个仿真框架，在算法的特定操作位置插入定点量化器。一个由五个布尔值组成的位置选择向量决定是否在以下每个位置应用量化器，顺序如下：\n- 输入采样点：在时间 $n$ 使用 $x[n]$ 之前对其进行量化，\n- 乘法点：量化每次标量乘法的结果，\n- 加法点：量化每次加法/减法的结果，\n- 状态更新点：量化将为下一个时间步存储的内部状态 $y[n]$，\n- 输出点：量化作为输出返回的最终 $y[n]$。\n\n如果一个位置被禁用，相应的中间值将不经量化直接通过。必须在所有启用的量化器位置上统计饱和事件；每次发生裁剪到 $x_{\\min}$ 或 $x_{\\max}$ 的情况时，将一个全局饱和计数器加 1。\n\n实现此框架并将其应用于以下测试套件。对于每个案例，您必须在需要时同时运行量化仿真（启用指定位置）和实值参考递归（无量化），然后计算指定的度量指标。\n\n测试用例 1（所有位置启用，中等精度的理想路径）：\n- 定点格式：$Q(W,F)$，其中 $W=8$, $F=6$。\n- 舍入模式：四舍六入五成双；饱和：如上所述的二进制补码边界。\n- 启用的量化器位置：输入、乘法、加法、状态更新、输出。\n- 系数：$b_0=0.625$, $b_1=0.375$, $a_1=-0.3$。\n- 对于 $n=0,\\dots,19$ 的输入序列 $x[n]$：$[\\,0.5,\\,-0.5,\\,0.25,\\,-0.25,\\,1.0,\\,-1.0,\\,0.75,\\,-0.75,\\,0.125,\\,-0.125,\\,0.0,\\,0.6,\\,-0.6,\\,0.9,\\,-0.9,\\,1.5,\\,-1.5,\\,0.03125,\\,-0.03125,\\,0.0\\,]$。\n- 需报告的度量指标：在 $n=0,\\dots,19$ 范围内，量化输出与实值参考输出之间的最大绝对误差，以实数形式表示。\n\n测试用例 2（所有位置启用，粗糙精度的饱和压力测试）：\n- 定点格式：$Q(W,F)$，其中 $W=4$, $F=2$。\n- 舍入模式：四舍六入五成双；饱和：如上所述的二进制补码边界。\n- 启用的量化器位置：输入、乘法、加法、状态更新、输出。\n- 系数：$b_0=1.0$, $b_1=1.0$, $a_1=-0.5$。\n- 对于 $n=0,\\dots,4$ 的输入序列 $x[n]$：$[\\,2.0,\\,2.0,\\,2.0,\\,2.0,\\,2.0\\,]$。\n- 需报告的度量指标：仿真期间在所有启用位置上遇到的饱和事件总数，以非负整数形式表示。\n\n测试用例 3（仅在输出端测试舍入平局行为，恒等算法）：\n- 定点格式：$Q(W,F)$，其中 $W=5$, $F=2$。\n- 舍入模式：四舍六入五成双；饱和：如上所述的二进制补码边界。\n- 启用的量化器位置：仅输出；算法为恒等式 $y[n]=x[n]$，无其他操作。\n- 对于 $n=0,\\dots,4$ 的输入序列 $x[n]$：$[\\,(-2+0.5)/4,\\,(-1+0.5)/4,\\,(0+0.5)/4,\\,(1+0.5)/4,\\,(2+0.5)/4\\,]$。\n- 需报告的度量指标：整数缩放输出 $r[n]$ 的列表，使得 $r[n] = y_q[n]\\cdot 2^F$，其中 $y_q[n]$ 是量化输出。每个 $r[n]$ 都必须报告为整数，利用了 $y_q[n]$ 在 $Q(W,F)$ 网格上可精确表示的特性。\n\n最终输出格式规范。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果。该列表必须按顺序包含三个测试用例的度量指标：测试用例 1 的一个实数，测试用例 2 的一个非负整数，以及测试用例 3 的一个整数列表。例如，一个语法上有效的输出看起来像 $[\\,0.001234,\\,7,\\,[\\,\\dots\\,]\\,]$，其中的实际值由您的计算确定。不应打印额外的文本或行。此问题不涉及角度，也不涉及任何物理单位；所有量均为指定的无量纲实数或整数。确保您的实现是自包含的，并且仅使用指定的语言和库。", "solution": "问题陈述已经过严格验证，并被确定为是合理的。它在科学上基于数字信号处理原理，定义明确，数据充分，表述客观，是一个格式规范的问题。该问题是建模离散时间系统中有限精度效应的标准练习，没有任何逻辑矛盾、事实错误或不可行的要求。因此，我们可以着手解决。\n\n任务的核心是为一阶线性时不变（LTI）系统构建一个仿真框架，考虑在各个计算阶段的定点量化效应。解决方案分为两个主要部分：一个通用的定点量化器和一个实现指定差分方程数据流的仿真循环。\n\n**1. 定点量化器模型**\n\n一个有符号定点数格式，表示为 $Q(W,F)$，由字长 $W$ 和小数位数 $F$ 定义。一个实数 $x \\in \\mathbb{R}$ 由一个按 $2^{-F}$ 因子缩放的整数 $r$ 表示。可表示范围由二进制补码整数范围 $[I_{\\min}, I_{\\max}]$ 决定，其中 $I_{\\min} = -2^{W-1}$ 且 $I_{\\max} = 2^{W-1}-1$。相应的实值范围是 $[x_{\\min}, x_{\\max}]$，其中 $x_{\\min} = I_{\\min} \\cdot 2^{-F}$ 且 $x_{\\max} = I_{\\max} \\cdot 2^{-F}$。\n\n量化函数 $Q_{W,F}(x)$ 将实数输入 $x$ 映射到此格式。该过程定义如下：\n1.  **缩放**：将实数 $x$ 缩放到整数域：$s = x \\cdot 2^F$。\n2.  **舍入**：将缩放后的值 $s$ 舍入到最近的整数。当 $s$ 正好位于两个整数之间（平局）时，它将被舍入到最近的偶数。这就是“四舍六入五成双”（round half to even）规则。令结果为 $r = \\mathrm{round\\_half\\_to\\_even}(s)$。\n3.  **饱和（裁剪）**：将整数 $r$ 裁剪到可表示范围 $[I_{\\min}, I_{\\max}]$ 内。令 $r_{clipped} = \\max(I_{\\min}, \\min(I_{\\max}, r))$。当且仅当 $r_{clipped} \\neq r$ 时，记录一个饱和事件。\n4.  **反向缩放**：通过将裁剪后的整数缩放回实数域来获得最终的量化值：$x_q = r_{clipped} \\cdot 2^{-F}$。\n\n整个过程被封装在一个可重用的软件组件中（在实现中是一个类），该组件用 $W$ 和 $F$ 初始化，并提供一个执行量化的方法，同时通过一个外部计数器跟踪饱和事件。\n\n**2. 差分方程仿真数据流**\n\n要仿真的系统是一阶差分方程：\n$$\ny[n] \\,=\\, b_0\\,x[n] \\,+\\, b_1\\,x[n-1] \\,-\\, a_1\\,y[n-1]\n$$\n初始条件为 $x[-1]=0$ 和 $y[-1]=0$。仿真必须在一个布尔向量控制的五个特定位置上对量化进行建模。每个时间步 $n$ 的数据流如下，其中 $Q(\\cdot)$ 表示在相应位置启用时调用量化器。上一步的状态保存在内存变量 $x_{mem}$（代表 $x[n-1]$）和 $y_{mem}$（代表 $y[n-1]$）中。\n\n1.  **输入量化（位置 1）**：对当前输入样本 $x[n]$ 进行量化。\n    $$\n    x_q[n] = Q_{input}(x[n])\n    $$\n2.  **乘法量化（位置 2）**：计算方程中的三个乘积并立即进行量化。\n    $$\n    t_0[n] = Q_{mul}(b_0 \\cdot x_q[n])\n    $$\n    $$\n    t_1[n] = Q_{mul}(b_1 \\cdot x_{mem})\n    $$\n    $$\n    t_2[n] = Q_{mul}(-a_1 \\cdot y_{mem})\n    $$\n3.  **加法量化（位置 3）**：对各项求和，并在两次加法运算后分别进行量化。\n    $$\n    s_1[n] = Q_{add}(t_0[n] + t_1[n])\n    $$\n    $$\n    y_{pre}[n] = Q_{add}(s_1[n] + t_2[n])\n    $$\n    值 $y_{pre}[n]$ 是在被导向输出和反馈路径之前的临时结果。\n\n4.  **状态更新和输出量化（位置 4 和 5）**：值 $y_{pre}[n]$ 是下一个状态和当前输出的源。这些路径有其各自独立的量化位置。\n    -   通过在状态更新位置对 $y_{pre}[n]$ 进行量化来计算反馈延迟的新状态：\n        $$\n        y_{mem, new} = Q_{state}(y_{pre}[n])\n        $$\n    -   通过在输出位置对 $y_{pre}[n]$ 进行量化来计算当前步骤的最终输出：\n        $$\n        y_{out}[n] = Q_{output}(y_{pre}[n])\n        $$\n5.  **状态寄存器更新**：为下一个时间步 $(n+1)$ 更新内存寄存器。\n    $$\n    x_{mem} \\leftarrow x_q[n]\n    $$\n    $$\n    y_{mem} \\leftarrow y_{mem, new}\n    $$\n对输入信号中的所有样本重复此序列。\n\n**3. 应用于测试用例**\n\n将所描述的框架应用于每个测试用例。\n\n-   **测试用例 1**：我们需要量化输出和理想输出之间的最大绝对误差。对 $n=0, \\dots, 19$ 运行两次仿真：一次是启用所有量化位置（$W=8, F=6$）以生成 $y_q[n]$，另一次是禁用所有位置的参考仿真（等效于无限精度浮点运算）以生成 $y_{ref}[n]$。度量指标是 $\\max_{n} |y_q[n] - y_{ref}[n]|$。\n\n-   **测试用例 2**：我们使用粗糙格式（$W=4, F=2$）和旨在导致溢出的输入来仿真系统。所有量化位置均已启用。仿真循环如上所述进行，报告的单个度量指标是在所有操作和时间步中累积的饱和事件总数。\n\n-   **测试用例 3**：此案例旨在测试“四舍六入五成双”规则。算法是一个简单的恒等式 $y[n]=x[n]$，仅启用输出位置的量化。对于每个输入样本 $x[n]$，我们计算 $y_q[n] = Q_{5,2}(x[n])$。所需的度量指标是整数缩放输出 $r[n] = y_q[n] \\cdot 2^F$ 的列表。这等效于量化过程中的整数值 $r_{clipped}$，需要为每个输入样本获取并报告该值。\n\n实现将严格遵循此设计以产生所需的结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final results.\n    \"\"\"\n\n    class Quantizer:\n        \"\"\"\n        Implements a signed fixed-point quantizer with saturation.\n        \"\"\"\n        def __init__(self, W, F):\n            if not (isinstance(W, int) and W >= 2):\n                raise ValueError(\"W must be an integer >= 2.\")\n            if not (isinstance(F, int) and F >= 0):\n                raise ValueError(\"F must be an integer >= 0.\")\n            \n            self.W = W\n            self.F = F\n            self.scale = 2.0**F\n            \n            self.int_min = -(2**(W - 1))\n            self.int_max = 2**(W - 1) - 1\n\n        def quantize(self, x, sat_counter):\n            \"\"\"\n            Quantizes a real value x to the Q(W,F) format.\n            - Rounds to nearest, ties to even.\n            - Clips to the representable range (saturation).\n            - Increments sat_counter[0] if saturation occurs.\n            \"\"\"\n            s = x * self.scale\n            # numpy.round implements round-half-to-even\n            r = int(np.round(s))\n            \n            r_clipped = max(self.int_min, min(self.int_max, r))\n            \n            if r != r_clipped:\n                sat_counter[0] += 1\n            \n            return float(r_clipped) / self.scale\n\n    def run_simulation(W, F, coeffs, x_in, sites):\n        \"\"\"\n        Simulates the first-order difference equation with fixed-point quantization.\n        \n        Args:\n            W (int): Word length.\n            F (int): Fractional bits.\n            coeffs (dict): Filter coefficients {b0, b1, a1}.\n            x_in (list): Input signal sequence.\n            sites (list[bool]): 5-element boolean list for enabling quantizer sites.\n            \n        Returns:\n            tuple: (list of output samples, final saturation count).\n        \"\"\"\n        quantizer = Quantizer(W, F) if any(sites) else None\n        sat_counter = [0]\n        \n        # Unpack site booleans for clarity\n        site_in, site_mul, site_add, site_state, site_out = sites\n\n        # Helper to conditionally quantize\n        def _quantize(val, site_enabled):\n            if site_enabled and quantizer:\n                return quantizer.quantize(val, sat_counter)\n            return val\n\n        x_mem = 0.0\n        y_mem = 0.0\n        y_out_list = []\n\n        for x_n in x_in:\n            # 1. Input Quantization\n            x_q = _quantize(x_n, site_in)\n\n            # 2. Multiplication Quantization\n            t0 = _quantize(coeffs['b0'] * x_q, site_mul)\n            t1 = _quantize(coeffs['b1'] * x_mem, site_mul)\n            t2 = _quantize(-coeffs['a1'] * y_mem, site_mul)\n            \n            # 3. Addition Quantization\n            s1 = _quantize(t0 + t1, site_add)\n            y_pre = _quantize(s1 + t2, site_add)\n            \n            # 5. Output Quantization (before state update)\n            y_out = _quantize(y_pre, site_out)\n            y_out_list.append(y_out)\n\n            # 4. State Update Quantization\n            y_mem_new = _quantize(y_pre, site_state)\n            \n            # Update state registers for next iteration\n            x_mem = x_q\n            y_mem = y_mem_new\n            \n        return y_out_list, sat_counter[0]\n\n    # --- Test Case 1 ---\n    W1, F1 = 8, 6\n    coeffs1 = {'b0': 0.625, 'b1': 0.375, 'a1': -0.3}\n    x_in1 = [0.5, -0.5, 0.25, -0.25, 1.0, -1.0, 0.75, -0.75, 0.125, -0.125,\n             0.0, 0.6, -0.6, 0.9, -0.9, 1.5, -1.5, 0.03125, -0.03125, 0.0]\n    sites1_quantized = [True] * 5\n    sites1_real = [False] * 5\n\n    y_q, _ = run_simulation(W1, F1, coeffs1, x_in1, sites1_quantized)\n    y_ref, _ = run_simulation(W1, F1, coeffs1, x_in1, sites1_real)\n    \n    max_abs_error = np.max(np.abs(np.array(y_q) - np.array(y_ref)))\n    \n    # --- Test Case 2 ---\n    W2, F2 = 4, 2\n    coeffs2 = {'b0': 1.0, 'b1': 1.0, 'a1': -0.5}\n    x_in2 = [2.0, 2.0, 2.0, 2.0, 2.0]\n    sites2 = [True] * 5\n    \n    _, total_saturations = run_simulation(W2, F2, coeffs2, x_in2, sites2)\n\n    # --- Test Case 3 ---\n    W3, F3 = 5, 2\n    x_in3 = [(-2 + 0.5) / 4, (-1 + 0.5) / 4, (0 + 0.5) / 4, (1 + 0.5) / 4, (2 + 0.5) / 4]\n    \n    quantizer3 = Quantizer(W3, F3)\n    sat_counter3 = [0]\n    y_q3 = [quantizer3.quantize(x, sat_counter3) for x in x_in3]\n    \n    scale3 = 2.0**F3\n    # Multiply by scale and round to correct for potential float inaccuracies\n    scaled_output_integers = [int(round(y * scale3)) for y in y_q3]\n\n    # --- Final Output ---\n    results = [max_abs_error, total_saturations, scaled_output_integers]\n    print(f\"[{results[0]},{results[1]},{results[2]}]\")\n\n\nsolve()\n\n```", "id": "2887709"}]}