{"hands_on_practices": [{"introduction": "在许多科学和工程应用中，神经状态空间模型被用来描述本质上连续的时间动态过程。然而，为了在数字计算机上实现和模拟这些模型，我们必须将其转换为离散时间表示。本练习将指导您完成一个基本但至关重要的过程：使用零阶保持 (ZOH) 假设对连续时间线性系统进行离散化。通过从常微分方程的基本解出发，您将推导出离散时间的状态更新方程，这是连接理论与实践的关键一步。[@problem_id:2886125]", "problem": "给定连续时间线性时不变状态空间模型，作为神经状态空间建模管道的线性主干。该主干由矩阵 $A \\in \\mathbb{R}^{n \\times n}$、$B \\in \\mathbb{R}^{n \\times m}$、$C \\in \\mathbb{R}^{p \\times n}$ 和 $D \\in \\mathbb{R}^{p \\times m}$ 以及一个采样周期 $\\Delta \\in \\mathbb{R}_{0}$ 指定。假设输入上存在零阶保持器 (ZOH)，请从第一性原理推导出一个正确的离散时间状态更新和输出方程，该方程将采样时刻 $k \\in \\mathbb{Z}_{\\ge 0}$ 映射到 $k+1$。仅使用线性时不变动力学的基本解和 ZOH 假设作为你的出发点。然后，实现一个程序，计算离散时间矩阵 $(A_d,B_d,C_d,D_d)$，并对给定的分段常数输入模拟离散时间输出序列。\n\n连续时间模型为\n$x'(t) = A x(t) + B u(t)$ 和 $y(t) = C x(t) + D u(t)$。\n在零阶保持器 (ZOH) 假设下，输入 $u(t)$ 在每个采样区间 $[k\\Delta, (k+1)\\Delta)$ 上保持恒定；将该常数值记为 $u_k \\in \\mathbb{R}^m$。离散时间模型的形式为\n$x_{k+1} = A_d x_k + B_d u_k$ 和 $y_k = C_d x_k + D_d u_k$，\n其中 $k \\in \\mathbb{Z}_{\\ge 0}$。\n\n你的程序必须：\n- 计算由 ZOH 假设所蕴含的 $(A_d,B_d,C_d,D_d)$，不使用本问题陈述中任何预先声明的快捷公式，而是从线性时不变系统的基本解和 ZOH 输入模型推导得出。\n- 对于每个测试用例，在给定初始状态 $x_0$ 和一个在 $N$ 步上指定的分段常数输入计划的情况下，模拟输出序列 $\\{y_k\\}_{k=0}^{N-1}$。\n- 对于每个测试用例，返回一个等于输出序列平方和的实数，即 $\\sum_{k=0}^{N-1} \\lVert y_k \\rVert_2^2$，表示为一个实标量（不涉及物理单位）。\n- 将每个返回的标量四舍五入到恰好 $6$ 位小数。\n\n输入计划以段列表 $(k_{\\mathrm{start}}, k_{\\mathrm{end}}, v)$ 的形式给出，其中 $k_{\\mathrm{start}}$ 和 $k_{\\mathrm{end}}$ 是满足 $0 \\le k_{\\mathrm{start}} \\le k_{\\mathrm{end}} \\le N-1$ 的整数，而 $v \\in \\mathbb{R}^m$ 是在闭区间 $\\{k_{\\mathrm{start}}, \\dots, k_{\\mathrm{end}}\\}$ 内对所有整数 $k$ 施加的恒定输入。\n\n测试套件：\n- 测试用例 $1$（正常路径，二阶，严格真）：\n  - $A = \\begin{bmatrix} 0  1 \\\\ -2  -0.5 \\end{bmatrix}$，$B = \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix}$，$C = \\begin{bmatrix} 1  0 \\end{bmatrix}$，$D = \\begin{bmatrix} 0 \\end{bmatrix}$。\n  - $\\Delta = 0.1$。\n  - $x_0 = \\begin{bmatrix} 1.0 \\\\ 0.0 \\end{bmatrix}$。\n  - $N = 50$。\n  - 输入段：$(0, 19, [1.0])$，$(20, 49, [0.0])$。\n- 测试用例 $2$（边界情况，A 等于零且有非零直接馈通）：\n  - $A = \\begin{bmatrix} 0 \\end{bmatrix}$，$B = \\begin{bmatrix} 1 \\end{bmatrix}$，$C = \\begin{bmatrix} 1 \\end{bmatrix}$，$D = \\begin{bmatrix} 0.5 \\end{bmatrix}$。\n  - $\\Delta = 0.25$。\n  - $x_0 = \\begin{bmatrix} 0.0 \\end{bmatrix}$。\n  - $N = 8$。\n  - 输入段：$(0, 3, [2.0])$，$(4, 7, [-2.0])$。\n- 测试用例 $3$（振荡边缘动力学）：\n  - $A = \\begin{bmatrix} 0  -1 \\\\ 1  0 \\end{bmatrix}$，$B = \\begin{bmatrix} 0 \\\\ 0.5 \\end{bmatrix}$，$C = \\begin{bmatrix} 0  1 \\end{bmatrix}$，$D = \\begin{bmatrix} 0 \\end{bmatrix}$。\n  - $\\Delta = 0.2$。\n  - $x_0 = \\begin{bmatrix} 0.0 \\\\ 1.0 \\end{bmatrix}$。\n  - $N = 20$。\n  - 输入段：$(0, 9, [0.3])$，$(10, 19, [0.0])$。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含三个测试用例的结果，格式为用方括号括起来的逗号分隔列表，每个数字都精确到六位小数，并且不含任何附加文本。例如：“[1.234000,5.678900,0.000123]”。", "solution": "该问题要求推导并实现一种方法，在零阶保持器 (ZOH) 假设下，对连续时间线性时不变 (LTI) 状态空间模型进行离散化。\n\n连续时间模型由以下状态和输出方程给出：\n$$\nx'(t) = A x(t) + B u(t)\n$$\n$$\ny(t) = C x(t) + D u(t)\n$$\n其中 $x(t) \\in \\mathbb{R}^n$ 是状态向量，$u(t) \\in \\mathbb{R}^m$ 是输入向量，$y(t) \\in \\mathbb{R}^p$ 是输出向量。矩阵 $A$、$B$、$C$ 和 $D$ 具有兼容的维度。\n\n目标是找到以周期 $\\Delta > 0$ 采样的等效离散时间模型，其形式为：\n$$\nx_{k+1} = A_d x_k + B_d u_k\n$$\n$$\ny_k = C_d x_k + D_d u_k\n$$\n其中 $x_k = x(k\\Delta)$，$y_k = y(k\\Delta)$，而 $u_k$ 是在区间 $[k\\Delta, (k+1)\\Delta)$ 上的恒定输入值。\n\n推导过程从连续时间 LTI 状态方程的基本解开始，该解由常数变易法公式给出。对于初始时间 $t_0$ 和最终时间 $t$，状态为：\n$$\nx(t) = e^{A(t-t_0)} x(t_0) + \\int_{t_0}^{t} e^{A(t-\\tau)} B u(\\tau) d\\tau\n$$\n\n我们将此公式应用于单个采样区间，从 $t_0 = k\\Delta$ 到 $t = (k+1)\\Delta$。区间开始时的状态为 $x(k\\Delta) = x_k$。区间结束时的状态为 $x((k+1)\\Delta) = x_{k+1}$。ZOH 假设指出，对于 $\\tau \\in [k\\Delta, (k+1)\\Delta)$，输入 $u(\\tau)$ 是恒定的，其值为 $u_k$。\n\n将这些代入解的公式中：\n$$\nx_{k+1} = e^{A((k+1)\\Delta - k\\Delta)} x_k + \\int_{k\\Delta}^{(k+1)\\Delta} e^{A((k+1)\\Delta - \\tau)} B u_k d\\tau\n$$\n\n我们可以简化这个表达式。第一项给出了离散系统的状态转移矩阵：\n$$\ne^{A\\Delta} x_k\n$$\n通过观察，我们确定离散时间状态矩阵 $A_d$：\n$$\nA_d = e^{A\\Delta}\n$$\n第二项涉及积分。由于 $u_k$ 在积分区间上是一个常数向量，因此可以将其从积分中提出：\n$$\n\\left( \\int_{k\\Delta}^{(k+1)\\Delta} e^{A((k+1)\\Delta - \\tau)} d\\tau \\right) B u_k\n$$\n为了计算该积分，我们进行变量代换。令 $\\sigma = (k+1)\\Delta - \\tau$。则 $d\\sigma = -d\\tau$。积分限从 $\\tau=k\\Delta \\rightarrow \\sigma=\\Delta$ 和 $\\tau=(k+1)\\Delta \\rightarrow \\sigma=0$ 变化。\n$$\n\\int_{\\Delta}^{0} e^{A\\sigma} (-d\\sigma) = \\int_{0}^{\\Delta} e^{A\\sigma} d\\sigma\n$$\n因此，第二项是 $\\left(\\int_{0}^{\\Delta} e^{A\\sigma} d\\sigma \\right) B u_k$。通过与离散时间模型形式进行比较，我们确定离散时间输入矩阵 $B_d$：\n$$\nB_d = \\left( \\int_{0}^{\\Delta} e^{A\\sigma} d\\sigma \\right) B\n$$\n因此，完整的离散时间状态更新方程为：\n$$\nx_{k+1} = (e^{A\\Delta}) x_k + \\left( \\int_{0}^{\\Delta} e^{A\\sigma} d\\sigma \\right) B u_k\n$$\n虽然当 $A$ 可逆时，该积分可以计算为 $A^{-1}(e^{A\\Delta}-I)$，但实现上需要一种更通用且数值上更鲁棒的方法。这种方法被称为矩阵指数法或 van Loan 方法，可以同时计算 $A_d$ 和 $B_d$。考虑大小为 $(n+m) \\times (n+m)$ 的增广矩阵 $M$：\n$$\nM = \\begin{bmatrix} A  B \\\\ 0  0 \\end{bmatrix}\n$$\n矩阵 $M\\Delta$ 的指数可以用分块矩阵公式表示。指数的级数展开表明：\n$$\ne^{M\\Delta} = \\begin{bmatrix} e^{A\\Delta}  \\left(\\int_0^\\Delta e^{A\\sigma} d\\sigma\\right) B \\\\ 0  I_m \\end{bmatrix} = \\begin{bmatrix} A_d  B_d \\\\ 0  I_m \\end{bmatrix}\n$$\n其中 $I_m$ 是 $m \\times m$ 的单位矩阵。这允许使用单次矩阵指数计算来同时计算 $A_d$ 和 $B_d$，即使对于奇异矩阵 $A$ 也是鲁棒的。\n\n接下来，我们推导离散时间输出矩阵 $C_d$ 和 $D_d$。离散输出 $y_k$ 是连续输出在时间 $t=k\\Delta$ 的采样值：\n$$\ny_k = y(k\\Delta) = C x(k\\Delta) + D u(k\\Delta)\n$$\n使用定义 $x_k = x(k\\Delta)$ 和 ZOH 属性 $u(k\\Delta) = u_k$，我们得到：\n$$\ny_k = C x_k + D u_k\n$$\n将其与通用形式 $y_k = C_d x_k + D_d u_k$ 进行比较，我们直接确定：\n$$\nC_d = C\n$$\n$$\nD_d = D\n$$\n至此，推导完成。实现将构建增广矩阵 $M$，计算其指数以找到 $A_d$ 和 $B_d$，然后使用所有四个离散矩阵 $(A_d, B_d, C_d, D_d)$ 来模拟系统在 $N$ 步内的响应。对于从 $0$ 到 $N-1$ 的每一步 $k$，计算输出 $y_k$，并累加其欧几里得范数平方的和，即 $\\sum_{k=0}^{N-1} \\lVert y_k \\rVert_2^2$。", "answer": "```python\nimport numpy as np\nfrom scipy.linalg import expm\n\ndef solve():\n    \"\"\"\n    Solves the problem by discretizing continuous-time state-space models\n    and simulating their response to compute a metric.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"A\": np.array([[0.0, 1.0], [-2.0, -0.5]]),\n            \"B\": np.array([[0.0], [1.0]]),\n            \"C\": np.array([[1.0, 0.0]]),\n            \"D\": np.array([[0.0]]),\n            \"Delta\": 0.1,\n            \"x0\": np.array([1.0, 0.0]),\n            \"N\": 50,\n            \"input_segments\": [(0, 19, [1.0]), (20, 49, [0.0])],\n        },\n        {\n            \"A\": np.array([[0.0]]),\n            \"B\": np.array([[1.0]]),\n            \"C\": np.array([[1.0]]),\n            \"D\": np.array([[0.5]]),\n            \"Delta\": 0.25,\n            \"x0\": np.array([0.0]),\n            \"N\": 8,\n            \"input_segments\": [(0, 3, [2.0]), (4, 7, [-2.0])],\n        },\n        {\n            \"A\": np.array([[0.0, -1.0], [1.0, 0.0]]),\n            \"B\": np.array([[0.0], [0.5]]),\n            \"C\": np.array([[0.0, 1.0]]),\n            \"D\": np.array([[0.0]]),\n            \"Delta\": 0.2,\n            \"x0\": np.array([0.0, 1.0]),\n            \"N\": 20,\n            \"input_segments\": [(0, 9, [0.3]), (10, 19, [0.0])],\n        },\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        A, B, C, D = case[\"A\"], case[\"B\"], case[\"C\"], case[\"D\"]\n        Delta, x0, N = case[\"Delta\"], case[\"x0\"], case[\"N\"]\n        input_segments = case[\"input_segments\"]\n\n        n, m = A.shape[1], B.shape[1]\n\n        # Construct the augmented matrix M for ZOH discretization.\n        M = np.zeros((n + m, n + m))\n        M[:n, :n] = A\n        M[:n, n:] = B\n        \n        # Compute the matrix exponential.\n        E = expm(M * Delta)\n        \n        # Extract discrete-time matrices Ad and Bd.\n        Ad = E[:n, :n]\n        Bd = E[:n, n:]\n        \n        # Cd and Dd are the same as C and D for ZOH sampled at t_k.\n        Cd = C\n        Dd = D\n\n        # Construct the full input sequence u_k for k=0...N-1.\n        u_sequence = np.zeros((N, m))\n        for k_start, k_end, v in input_segments:\n            for k in range(k_start, k_end + 1):\n                u_sequence[k, :] = v\n\n        # Simulate the discrete-time system.\n        x_current = x0.copy().reshape(-1, 1)\n        sum_of_squares = 0.0\n\n        for k in range(N):\n            u_k = u_sequence[k].reshape(-1, 1)\n\n            # Calculate output y_k = C_d * x_k + D_d * u_k\n            y_k = Cd @ x_current + Dd @ u_k\n\n            # Accumulate the sum of squares of the L2 norm of the output.\n            sum_of_squares += np.sum(y_k**2)\n\n            # Update state for next step: x_{k+1} = A_d * x_k + B_d * u_k\n            x_current = Ad @ x_current + Bd @ u_k\n            \n        results.append(sum_of_squares)\n\n    # Format the final output string as required.\n    output_str = \"[\" + \",\".join([f\"{r:.6f}\" for r in results]) + \"]\"\n    print(output_str)\n\nsolve()\n```", "id": "2886125"}, {"introduction": "获得离散时间状态空间模型后，下一步是分析其动态特性。频率响应是理解系统如何处理不同频率成分信号的有力工具，它揭示了系统的滤波特性、共振行为和稳定性。本练习将引导您直接从状态空间矩阵 $(A, B, C, D)$ 出发，通过在单位圆上求解一系列线性方程组来计算系统的频率响应 $|H(e^{j\\omega})|$。这种方法不仅加深了对状态空间与频域之间联系的理解，还是一种在数值上比直接计算传递函数更稳健的实用技术。[@problem_id:2886136]", "problem": "您将获得离散时间单输入单输出（SISO）线性状态空间模型，这些模型是神经状态空间模型在平衡点附近的局部线性化结果。一个神经状态空间模型由参数化映射 $f_{\\theta}$ 和 $g_{\\theta}$ 组成，其状态和输出的演化方式为 $x_{k+1} = f_{\\theta}(x_k,u_k)$ 和 $y_k = g_{\\theta}(x_k,u_k)$。在平衡点附近的小信号近似下，该模型线性化为离散时间线性时不变状态空间形式 $x_{k+1} = A x_k + B u_k$ 和 $y_k = C x_k + D u_k$，其中 $A$、$B$、$C$ 和 $D$ 是在平衡点处求得的雅可比矩阵。\n\n从离散时间信号的 $z$ 变换和离散时间傅里叶变换（DTFT）的定义出发，并且仅使用零初始条件下的线性时不变状态空间方程 $x_{k+1} = A x_k + B u_k$ 和 $y_k = C x_k + D u_k$，推导在单位圆 $z = e^{j\\omega}$ 上从输入 $u_k$ 到输出 $y_k$ 的复频率响应的频域表达式，然后求出其幅值响应 $\\lvert H(e^{j\\omega}) \\rvert$。您的算法必须通过对网格中的每个频率求解与 $A$ 的预解式相关的线性系统来评估响应，而不能使用任何预先推导的简化公式。如果相关矩阵是数值奇异或病态的，则将幅值视为 $+\\infty$。\n\n角度单位说明：所有频率 $\\omega$ 的单位均为弧度/采样点。\n\n数值奇异性和病态规则：对于每个频率 $\\omega$，构造矩阵 $M(\\omega) = e^{j\\omega} I - A$。如果 $M(\\omega)$ 在 $2$-范数下的条件数超过 $10^{12}$，或者 $M(\\omega)$ 在数值线性代数中是奇异的（求解失败），则在该 $\\omega$ 处定义 $\\lvert H(e^{j\\omega}) \\rvert = +\\infty$。在最终输出中，将 $+\\infty$ 表示为字符串 $\\,\\text{inf}\\,$。\n\n对于下面的每个测试用例，计算在指定频率网格上 $\\lvert H(e^{j\\omega}) \\rvert$ 的最大值。每个测试用例返回一个标量。当最大值为有限值时，将其四舍五入到六位小数。当最大值为无穷大时，打印 $\\,\\text{inf}\\,$。\n\n所有测试用例共用的频率网格为 $\\Omega = [\\,0,\\ \\pi/4,\\ \\pi/2,\\ 3\\pi/4,\\ \\pi\\,]$。\n\n测试套件：\n- 测试用例 1（稳定的类二阶振荡器）：\n  - $A_1 = \\begin{bmatrix} 0.7  -0.4 \\\\ 0.4  0.7 \\end{bmatrix}$, $B_1 = \\begin{bmatrix} 1.0 \\\\ 0.0 \\end{bmatrix}$, $C_1 = \\begin{bmatrix} 1.0  0.0 \\end{bmatrix}$, $D_1 = \\begin{bmatrix} 0.0 \\end{bmatrix}$。\n- 测试用例 2（非零直通项）：\n  - $A_2 = \\begin{bmatrix} 0.2  0.0 \\\\ 0.0  0.5 \\end{bmatrix}$, $B_2 = \\begin{bmatrix} 1.0 \\\\ 1.0 \\end{bmatrix}$, $C_2 = \\begin{bmatrix} 0.5  -0.5 \\end{bmatrix}$, $D_2 = \\begin{bmatrix} 0.3 \\end{bmatrix}$。\n- 测试用例 3（单位圆上的临界极点导致在 $\\omega = 0$ 处共振）：\n  - $A_3 = \\begin{bmatrix} 1.0  0.0 \\\\ 0.0  0.2 \\end{bmatrix}$, $B_3 = \\begin{bmatrix} 1.0 \\\\ 0.0 \\end{bmatrix}$, $C_3 = \\begin{bmatrix} 1.0  0.0 \\end{bmatrix}$, $D_3 = \\begin{bmatrix} 0.0 \\end{bmatrix}$。\n- 测试用例 4（零输入到状态通道；恒等于零的响应）：\n  - $A_4 = \\begin{bmatrix} 0.9 \\end{bmatrix}$, $B_4 = \\begin{bmatrix} 0.0 \\end{bmatrix}$, $C_4 = \\begin{bmatrix} 1.0 \\end{bmatrix}$, $D_4 = \\begin{bmatrix} 0.0 \\end{bmatrix}$。\n\n实现要求：\n- 对于每个 $\\omega \\in \\Omega$，设置 $z = e^{j\\omega}$，构造 $M(\\omega) = z I - A$，如果 $M(\\omega)$ 是良态的，则求解 $M(\\omega) X(\\omega) = B$ 以得到 $X(\\omega)$，然后根据 $X(\\omega)$ 和给定的矩阵计算复数标量 $H(e^{j\\omega})$。取其幅值，并通过求最大值在 $\\Omega$ 上进行聚合。\n- 病态阈值：使用 $2$-范数下的条件数截断值 $10^{12}$ 来判断在该频率下是否将 $\\lvert H(e^{j\\omega}) \\rvert$ 设置为 $+\\infty$。\n- 将最终输出表示为每个测试用例一个标量：$\\Omega$ 上的最大幅值。对于有限的最大值，四舍五入到六位小数。对于无穷大的最大值，打印 $\\,\\text{inf}\\,$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含与四个测试用例相对应的四个结果，形式为用方括号括起来的逗号分隔列表（例如，$[r_1,r_2,r_3,r_4]$），其中每个 $r_i$ 遵循上述的四舍五入和无穷大约定。", "solution": "该问题要求对几个离散时间线性时不变（LTI）状态空间模型，推导并计算其频率响应幅值。推导必须源于第一性原理，即 $z$ 变换的定义，而计算则必须遵循一个涉及求解线性系统的特定数值程序。\n\n让我们从给定的离散时间 LTI 系统的状态空间表示开始：\n$$x_{k+1} = A x_k + B u_k$$\n$$y_k = C x_k + D u_k$$\n此处，$k \\in \\mathbb{Z}$ 是时间索引，$x_k \\in \\mathbb{R}^n$ 是状态向量，$u_k \\in \\mathbb{R}$ 是标量输入，$y_k \\in \\mathbb{R}$ 是标量输出。矩阵 $A, B, C, D$ 的维度是兼容的：$A \\in \\mathbb{R}^{n \\times n}$，$B \\in \\mathbb{R}^{n \\times 1}$，$C \\in \\mathbb{R}^{1 \\times n}$，以及 $D \\in \\mathbb{R}^{1 \\times 1}$。\n\n一个离散时间序列 $f_k$ 的 $z$ 变换定义为 $F(z) = \\mathcal{Z}\\{f_k\\} = \\sum_{k=0}^{\\infty} f_k z^{-k}$，其中 $z$ 是一个复变量。$z$ 变换的一个关键性质是时移性质，该性质指出，对于序列 $f_{k+1}$，其变换为 $\\mathcal{Z}\\{f_{k+1}\\} = z F(z) - z f_0$。\n\n我们给定的条件是零初始状态，即 $x_0 = 0$。对状态和输出方程应用 $z$ 变换，我们得到：\n1.  状态方程的变换：\n    $\\mathcal{Z}\\{x_{k+1}\\} = \\mathcal{Z}\\{A x_k + B u_k\\}$\n    使用线性和时移性质，并设 $x_0=0$：\n    $$z X(z) = A X(z) + B U(z)$$\n    其中 $X(z)$、$U(z)$ 和 $Y(z)$ 分别是序列 $x_k$、$u_k$ 和 $y_k$ 的 $z$ 变换。\n\n2.  输出方程的变换：\n    $\\mathcal{Z}\\{y_k\\} = \\mathcal{Z}\\{C x_k + D u_k\\}$\n    使用线性性质：\n    $$Y(z) = C X(z) + D U(z)$$\n\n我们的目标是找到传递函数 $H(z) = Y(z)/U(z)$，它表示 $z$ 域中的输入-输出关系。为此，我们首先求解变换后的状态方程以得到 $X(z)$：\n$$z X(z) - A X(z) = B U(z)$$\n$$(zI - A) X(z) = B U(z)$$\n其中 $I$ 是 $n \\times n$ 的单位矩阵。如果矩阵 $(zI - A)$ 是可逆的，我们可以写出：\n$$X(z) = (zI - A)^{-1} B U(z)$$\n矩阵 $(zI - A)^{-1}$ 被称为矩阵 $A$ 的预解式。\n\n现在，我们将这个 $X(z)$ 的表达式代入变换后的输出方程：\n$$Y(z) = C \\left( (zI - A)^{-1} B U(z) \\right) + D U(z)$$\n提出 $U(z)$：\n$$Y(z) = \\left[ C (zI - A)^{-1} B + D \\right] U(z)$$\n因此，传递函数 $H(z)$ 是：\n$$H(z) = \\frac{Y(z)}{U(z)} = C (zI - A)^{-1} B + D$$\n\n系统的频率响应是通过在复平面的单位圆上（其中 $z = e^{j\\omega}$）计算传递函数 $H(z)$ 得到的。在这里，$\\omega$ 是归一化角频率，单位为弧度/采样点，且 $\\omega \\in [-\\pi, \\pi]$。\n$$H(e^{j\\omega}) = C (e^{j\\omega}I - A)^{-1} B + D$$\n频率响应的幅值为 $\\lvert H(e^{j\\omega}) \\rvert$。\n\n问题要求我们避免直接计算矩阵的逆。相反，我们必须求解一个线性方程组。让我们为每个频率 $\\omega$ 定义一个复向量 $X(\\omega)$。这个向量不是状态变换 $X(z)$，而是从它派生出的一个依赖于频率的量。令 $M(\\omega) = e^{j\\omega}I - A$。$H(e^{j\\omega})$ 表达式中的项 $(e^{j\\omega}I - A)^{-1} B$ 可以通过求解以下线性系统来计算：\n$$M(\\omega) X(\\omega) = B$$\n以求得向量 $X(\\omega)$。一旦找到 $X(\\omega)$，频率响应就可以计算为：\n$$H(e^{j\\omega}) = C X(\\omega) + D$$\n这种方法在数值上比直接求逆更可取。\n\n系统的稳定性和响应特性由 $A$ 的特征值决定，这些特征值是系统的极点。如果 $A$ 的某个特征值 $\\lambda_p$ 位于单位圆上，即 $|\\lambda_p|=1$，那么对于某个频率 $\\omega_p$，我们有 $\\lambda_p = e^{j\\omega_p}$。在这个频率下，$z = e^{j\\omega_p} = \\lambda_p$，矩阵 $M(\\omega_p) = e^{j\\omega_p}I - A = \\lambda_p I - A$ 变为奇异矩阵。这对应于单位圆上的一个极点，导致无限大的响应幅值（共振）。\n\n在数值计算中，真正的奇异性是罕见的。相反，我们检查矩阵 $M(\\omega)$ 是否是病态的，这表明其接近奇异。条件数 $\\mathrm{cond}(M)$ 量化了这一点。一个大的条件数意味着输入中的小扰动会导致解的巨大变化，使得线性系统的解不可靠。问题指定了一个阈值 $10^{12}$：如果 $\\mathrm{cond}_2(M(\\omega)) > 10^{12}$，或者如果数值求解器因奇异性而失败，我们必须将幅值视为无穷大，即 $\\lvert H(e^{j\\omega}) \\rvert = +\\infty$。\n\n总的算法如下：\n对于每个给定的测试用例 $(A, B, C, D)$：\n1.  初始化一个空列表来存储幅值。\n2.  对于指定网格 $\\Omega = [0, \\pi/4, \\pi/2, 3\\pi/4, \\pi]$ 中的每个频率 $\\omega$：\n    a.  设置 $z = e^{j\\omega}$。\n    b.  构造复矩阵 $M(\\omega) = zI - A$。\n    c.  计算 $M(\\omega)$ 的 $2$-范数条件数。\n    d.  如果 $\\mathrm{cond}_2(M(\\omega)) > 10^{12}$ 或者使用 $M(\\omega)$ 求解失败，则此频率的幅值为 $+\\infty$。\n    e.  否则，求解线性系统 $M(\\omega) X(\\omega) = B$ 以得到复向量 $X(\\omega)$。\n    f.  计算复标量响应 $H(e^{j\\omega}) = C X(\\omega) + D$。\n    g.  计算幅值 $\\lvert H(e^{j\\omega}) \\rvert$。\n    h.  将计算出的幅值（有限或无限）添加到列表中。\n3.  在幅值列表中找到最大值。\n4.  如果最大值是有限的，则将其格式化为六位小数。如果是无限的，则表示为 'inf'。\n此过程将应用于所有测试用例。", "answer": "```python\nimport numpy as np\n\ndef calculate_max_magnitude(A_in, B_in, C_in, D_in, omega_grid, cond_thresh):\n    \"\"\"\n    Calculates the maximum magnitude of the frequency response for a state-space model.\n\n    The function computes the frequency response H(e^jω) = C(e^jω*I - A)^-1 * B + D\n    by solving a linear system for each ω in the grid. It handles ill-conditioning\n    by checking the matrix condition number against a threshold.\n    \"\"\"\n    # Convert input lists to numpy arrays with appropriate types and shapes\n    A = np.array(A_in, dtype=np.float64)\n    B = np.array(B_in, dtype=np.float64).reshape(-1, 1)\n    C = np.array(C_in, dtype=np.float64).reshape(1, -1)\n    D = np.array(D_in, dtype=np.float64).reshape(1, 1)\n    \n    n = A.shape[0]\n    I = np.eye(n, dtype=np.complex128)\n    \n    magnitudes = []\n\n    for omega in omega_grid:\n        z = np.exp(1j * omega)\n        M = z * I - A\n        is_infinite = False\n\n        # Check for singularity or ill-conditioning\n        try:\n            # np.linalg.cond can be expensive, but is required by the problem spec.\n            # A LinAlgError might be raised for exactly singular matrices.\n            cond_num = np.linalg.cond(M)\n            if cond_num > cond_thresh:\n                is_infinite = True\n        except np.linalg.LinAlgError:\n            is_infinite = True\n\n        if is_infinite:\n            magnitudes.append(np.inf)\n            continue\n            \n        # Solve the linear system (zI - A)X = B\n        try:\n            # X(ω) is the frequency-dependent state response vector\n            X_omega = np.linalg.solve(M, B)\n            \n            # H(e^jω) = C*X(ω) + D\n            H_omega = C @ X_omega + D\n            magnitudes.append(np.abs(H_omega[0, 0]))\n        except np.linalg.LinAlgError:\n            # This is a fallback; the condition number check should pre-empt this.\n            magnitudes.append(np.inf)\n            \n    max_mag = np.max(magnitudes)\n    \n    if np.isinf(max_mag):\n        return \"inf\"\n    else:\n        return f\"{max_mag:.6f}\"\n\ndef solve():\n    \"\"\"\n    Defines test cases and computes the result for each, printing the final output.\n    \"\"\"\n    test_cases = [\n        # Test Case 1: stable second-order oscillator-like\n        {\n            \"A\": [[0.7, -0.4], [0.4, 0.7]],\n            \"B\": [[1.0], [0.0]],\n            \"C\": [[1.0, 0.0]],\n            \"D\": [[0.0]]\n        },\n        # Test Case 2: nonzero direct term\n        {\n            \"A\": [[0.2, 0.0], [0.0, 0.5]],\n            \"B\": [[1.0], [1.0]],\n            \"C\": [[0.5, -0.5]],\n            \"D\": [[0.3]]\n        },\n        # Test Case 3: marginal pole on the unit circle\n        {\n            \"A\": [[1.0, 0.0], [0.0, 0.2]],\n            \"B\": [[1.0], [0.0]],\n            \"C\": [[1.0, 0.0]],\n            \"D\": [[0.0]]\n        },\n        # Test Case 4: zero input-to-state channel\n        {\n            \"A\": [[0.9]],\n            \"B\": [[0.0]],\n            \"C\": [[1.0]],\n            \"D\": [[0.0]]\n        }\n    ]\n    \n    omega_grid = [0.0, np.pi/4, np.pi/2, 3*np.pi/4, np.pi]\n    cond_thresh = 1e12\n    \n    results = []\n    for case in test_cases:\n        result = calculate_max_magnitude(\n            case[\"A\"], case[\"B\"], case[\"C\"], case[\"D\"], omega_grid, cond_thresh\n        )\n        results.append(result)\n        \n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2886136"}, {"introduction": "现代神经状态空间模型的一个核心优势在于能够学习具有特定先验结构和保证稳定性的模型。这超越了传统的无约束系统辨识，使得模型更加可靠和可解释。在本练习中，您将模拟一个带约束的训练过程，其中一个从数据中辨识出的模型参数将被投影到一个满足预设稳定裕度和阻尼比要求的有效集合中。这项实践揭示了赋予神经状态空间模型强大性能和稳定性的高级技术，确保了学习到的模型不仅准确，而且表现良好。[@problem_id:2886035]", "problem": "给定一个连续时间神经状态空间模型，其右侧参数化为块对角二阶振荡器形式的结构化线性映射。其动力学方程为\n$$\n\\dot{x}(t) = f_{\\theta}(x(t),u(t)) = A_{\\theta} x(t) + B u(t),\n$$\n在此任务中，训练和验证时 $u(t) \\equiv 0$，因此自由响应满足\n$$\n\\dot{x}(t) = A_{\\theta} x(t).\n$$\n$A_{\\theta}$ 的每个 $2 \\times 2$ 对角块都模拟一个规范形式的阻尼二阶振荡器\n$$\nA(\\zeta,\\omega_n) = \\begin{bmatrix} 0  1 \\\\ -\\omega_n^2  -2\\zeta \\omega_n \\end{bmatrix},\n$$\n其中 $\\zeta$ 是阻尼比，$\\omega_n$ 是自然频率。完整的 $A_{\\theta}$ 是一个由两个此类 $2 \\times 2$ 块组成的块对角矩阵，状态维数为 $4$。一个块的特征值为\n$$\n\\lambda_{\\pm} = -\\zeta \\,\\omega_n \\pm \\omega_n \\sqrt{\\zeta^2 - 1}.\n$$\n对于 $\\zeta \\in (0,1)$，特征值为一个复共轭对，其实部为 $-\\zeta \\omega_n$，虚部幅值为 $\\omega_n \\sqrt{1-\\zeta^2}$，阻尼比为 $\\zeta$。对于 $\\zeta \\ge 1$，特征值为实数且严格为负，为进行稳定性裕度检查，传统的阻尼比被视为 $1$。\n\n在采样间隔 $\\Delta t$ 内的离散时间流由矩阵指数给出\n$$\nx_{k+1} = \\Phi x_k,\\quad \\Phi = \\exp(A_{\\theta}\\,\\Delta t),\n$$\n其中 $x_k = x(k\\, \\Delta t)$。对于足够丰富的状态轨迹 $x_k$，单步流矩阵 $\\Phi$ 可以通过最小二乘法估计为以下问题的解\n$$\n\\min_{\\Phi} \\sum_{k=0}^{T-2} \\|x_{k+1} - \\Phi x_k\\|_2^2,\n$$\n这会产生闭式估计\n$$\n\\widehat{\\Phi} = X_1 X_0^{\\dagger},\n$$\n其中 $X_0 = [x_0, x_1, \\dots, x_{T-2}]$，$X_1 = [x_1, x_2, \\dots, x_{T-1}]$，并且 $X_0^{\\dagger}$ 表示 Moore–Penrose 伪逆。通过主矩阵对数恢复连续时间估计\n$$\n\\widehat{A} = \\Delta t^{-1} \\log(\\widehat{\\Phi}).\n$$\n\n您的任务是实现一个约束训练（辨识）过程，以强制执行感知阻尼的稳定性裕度。具体来说，设计一个从无约束估计 $\\widehat{A}$ 到约束矩阵 $A_{\\theta}$ 的映射，其中 $A_{\\theta}$ 的两个 $2 \\times 2$ 块具有 $A(\\zeta_i,\\omega_{n,i})$ 的形式，并满足以下约束\n- 每个模态 $i$ 的阻尼比下界 $ \\zeta_i \\ge \\zeta_{\\min}$，以及\n- 实部稳定性裕度 $ -\\max \\operatorname{Re} \\lambda(A_{\\theta}) \\ge \\alpha_{\\min}$。\n\n对于给定的 $(\\zeta,\\omega_n)$ 对，块特征值中负实部的最小幅值为\n$$\nm(\\zeta,\\omega_n) =\n\\begin{cases}\n\\zeta\\,\\omega_n,  \\text{if } \\zeta \\in (0,1),\\\\\n\\omega_n\\left(\\zeta - \\sqrt{\\zeta^2 - 1}\\right),  \\text{if } \\zeta \\ge 1.\n\\end{cases}\n$$\n为强制执行实部稳定性裕度，请确保对每个模态 $i$ 都有 $m(\\zeta_i,\\omega_{n,i}) \\ge \\alpha_{\\min}$。\n\n需实现的步骤：\n1. 通过选择具有参数 $(\\zeta_{i}^{\\star}, \\omega_{n,i}^{\\star})$ 的两个模态来生成基准数据，构建块对角矩阵 $A^{\\star}$，以 $\\Delta t$ 秒为周期进行采样，并从给定的初始条件 $x_0$ 开始，对 $T$ 个样本进行仿真 $x_{k+1} = \\exp(A^{\\star} \\Delta t)\\,x_k$。使用 $u_k \\equiv 0$ 和 $C = I$，使观测输出为 $y_k = x_k$。\n2. 通过最小二乘法辨识离散流 $\\widehat{\\Phi}$，然后通过主矩阵对数计算 $\\widehat{A}$。\n3. 对于 $\\widehat{A}$ 的每个 $2 \\times 2$ 块，通过从块的元素中提取临时参数 $(\\tilde{\\zeta},\\tilde{\\omega}_n)$，然后应用约束 $\\zeta \\leftarrow \\max(\\tilde{\\zeta}, \\zeta_{\\min})$ 和 $\\omega_n \\leftarrow \\max\\big(\\tilde{\\omega}_n, \\alpha_{\\min}/f(\\zeta)\\big)$，将其投影到约束流形上，其中\n$$\nf(\\zeta) =\n\\begin{cases}\n\\zeta,  \\text{if } \\zeta \\in (0,1),\\\\\n\\zeta - \\sqrt{\\zeta^2 - 1},  \\text{if } \\zeta \\ge 1.\n\\end{cases}\n$$\n然后将该块重建为 $A(\\zeta,\\omega_n)$ 并组装学习到的 $A_{\\theta}$。\n4. 通过计算以下内容，验证学习到的极点是否满足目标裕度：\n   - 最小负实部 $-\\max \\operatorname{Re}\\lambda(A_{\\theta})$，并检查其在 $10^{-6}$ 的容差内是否至少为 $\\alpha_{\\min}$，以及\n   - 跨模态的最小阻尼比，对于复共轭对计算为 $\\zeta$（或对于实数负极点为 $1$），并检查其在 $10^{-6}$ 的容差内是否至少为 $\\zeta_{\\min}$。\n\n所有时间单位均为秒。没有需要指定单位的角度量。不涉及百分比。\n\n为以下包含三种情况的测试套件实现上述过程。每种情况指定 $(\\zeta_{\\min}, \\alpha_{\\min}, \\Delta t, T, (\\omega_{n,1}^{\\star}, \\omega_{n,2}^{\\star}), (\\zeta_{1}^{\\star}, \\zeta_{2}^{\\star}), x_0)$:\n- 情况 1：$\\zeta_{\\min} = 0.2$, $\\alpha_{\\min} = 0.05$, $\\Delta t = 0.05$, $T = 200$, $(\\omega_{n,1}^{\\star}, \\omega_{n,2}^{\\star}) = (0.8, 1.3)$, $(\\zeta_{1}^{\\star}, \\zeta_{2}^{\\star}) = (0.3, 0.5)$, $x_0 = [1.0, 0.0, 0.8, 0.0]^{\\top}$。\n- 情况 2：$\\zeta_{\\min} = 0.7$, $\\alpha_{\\min} = 0.2$, $\\Delta t = 0.05$, $T = 180$, $(\\omega_{n,1}^{\\star}, \\omega_{n,2}^{\\star}) = (1.0, 1.2)$, $(\\zeta_{1}^{\\star}, \\zeta_{2}^{\\star}) = (0.8, 1.1)$, $x_0 = [1.0, 0.0, 0.5, 0.0]^{\\top}$。\n- 情况 3：$\\zeta_{\\min} = 0.95$, $\\alpha_{\\min} = 0.6$, $\\Delta t = 0.02$, $T = 300$, $(\\omega_{n,1}^{\\star}, \\omega_{n,2}^{\\star}) = (0.7, 2.0)$, $(\\zeta_{1}^{\\star}, \\zeta_{2}^{\\star}) = (1.0, 0.97)$, $x_0 = [1.2, 0.0, 0.4, 0.0]^{\\top}$。\n\n您的程序必须为每种情况执行数据生成、辨识、通过上述投影进行的约束训练以及验证。对于每种情况，输出一个布尔值，指示学习到的 $A_{\\theta}$ 是否在指定容差内同时满足阻尼比和稳定性裕度约束。\n\n最终输出格式：您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，“[result1,result2,result3]”）。每个结果必须是 Python 布尔字面值“True”或“False”。", "solution": "所提出的问题要求为一个连续时间线性状态空间模型实现并验证一个约束系统辨识过程。该模型的动力学矩阵 $A_{\\theta}$ 在结构上是由两个二阶振荡器系统组成的块对角矩阵。任务是从仿真数据中辨识此矩阵，并随后对模态阻尼比和整个系统的稳定性裕度强制施加约束。\n\n该过程可分为四个不同且连续的步骤：\n1.  **数据生成**：通过矩阵 $A^{\\star}$ 定义一个基准系统，并通过仿真离散时间演化来生成状态轨迹。\n2.  **系统辨识**：使用最小二乘法从轨迹中估计离散时间状态转移矩阵 $\\widehat{\\Phi}$，并从中恢复连续时间动力学矩阵 $\\widehat{A}$。\n3.  **约束投影**：提取已辨识矩阵 $\\widehat{A}$ 的参数，并将其投影到一个满足给定阻尼和稳定性约束的有效集合上。\n4.  **验证**：检查最终的约束矩阵 $A_{\\theta}$，以确保其满足所需属性。\n\n我们现在将详细说明每个步骤的数学基础。\n\n**步骤 1：数据生成**\n连续时间动力学由线性常微分方程 $\\dot{x}(t) = A^{\\star} x(t)$ 描述。系统矩阵 $A^{\\star}$ 是一个 $4 \\times 4$ 的块对角矩阵，由两个 $2 \\times 2$ 的块构成，每个块代表一个阻尼谐振子：\n$$\nA^{\\star} = \\begin{bmatrix} A(\\zeta_1^{\\star}, \\omega_{n,1}^{\\star})  \\mathbf{0}_{2\\times2} \\\\ \\mathbf{0}_{2\\times2}  A(\\zeta_2^{\\star}, \\omega_{n,2}^{\\star}) \\end{bmatrix}\n$$\n二阶块的规范形式由下式给出：\n$$\nA(\\zeta, \\omega_n) = \\begin{bmatrix} 0  1 \\\\ -\\omega_n^2  -2\\zeta \\omega_n \\end{bmatrix}\n$$\n其中 $\\zeta$ 是阻尼比，$\\omega_n$ 是自然频率。该微分方程的解给出了在采样间隔 $\\Delta t$ 内的离散时间状态转移：\n$$\nx_{k+1} = x((k+1)\\Delta t) = \\exp(A^{\\star} \\Delta t) x(k \\Delta t) = \\Phi^{\\star} x_k\n$$\n我们从指定的初始条件 $x_0$ 开始，生成长度为 $T$ 的状态轨迹 $\\{x_k\\}_{k=0}^{T-1}$。\n\n**步骤 2：最小二乘系统辨识**\n根据仿真轨迹，我们构建两个由连续状态向量组成的数据矩阵：\n$$\nX_0 = [x_0, x_1, \\dots, x_{T-2}] \\in \\mathbb{R}^{4 \\times (T-1)}\n$$\n$$\nX_1 = [x_1, x_2, \\dots, x_{T-1}] \\in \\mathbb{R}^{4 \\times (T-1)}\n$$\n这些矩阵通过状态转移矩阵 $\\Phi^{\\star}$ 相关联，即 $X_1 = \\Phi^{\\star} X_0$。我们寻求一个最小二乘估计 $\\widehat{\\Phi}$，以最小化残差的平方弗罗贝尼乌斯范数 $\\|X_1 - \\Phi X_0\\|_F^2$。其解由下式给出：\n$$\n\\widehat{\\Phi} = X_1 X_0^{\\dagger}\n$$\n其中 $X_0^{\\dagger}$ 是 $X_0$ 的 Moore-Penrose 伪逆。随后，我们通过计算主矩阵对数来恢复连续时间动力学矩阵的估计值 $\\widehat{A}$：\n$$\n\\widehat{A} = \\frac{1}{\\Delta t} \\log(\\widehat{\\Phi})\n$$\n该矩阵 $\\widehat{A}$ 是一个无约束估计，可能不完全符合 $A_\\theta$ 的结构性约束。\n\n**步骤 3：约束参数投影**\n问题要求对 $\\widehat{A}$ 的每个 $2 \\times 2$ 对角块的参数进行投影，以强制执行所需的约束。让我们考虑其中一个块 $\\widehat{A}_{ii}$：\n$$\n\\widehat{A}_{ii} = \\begin{bmatrix} \\hat{a}_{11}  \\hat{a}_{12} \\\\ \\hat{a}_{21}  \\hat{a}_{22} \\end{bmatrix}\n$$\n通过将其第二行与规范形式 $A(\\zeta, \\omega_n)$ 进行比较，我们提取出临时参数 $(\\tilde{\\zeta}, \\tilde{\\omega}_n)$。根据 $-\\tilde{\\omega}_n^2 = \\hat{a}_{21}$ 和 $-2\\tilde{\\zeta} \\tilde{\\omega}_n = \\hat{a}_{22}$，我们得到：\n$$\n\\tilde{\\omega}_n = \\sqrt{-\\hat{a}_{21}} \\quad \\text{和} \\quad \\tilde{\\zeta} = \\frac{-\\hat{a}_{22}}{2 \\tilde{\\omega}_n}\n$$\n在数值计算上，必须注意确保平方根的参数为非负，并避免除以零。\n然后对这些临时参数进行投影以满足约束。首先应用阻尼比约束 $\\zeta_i \\ge \\zeta_{\\min}$：\n$$\n\\zeta = \\max(\\tilde{\\zeta}, \\zeta_{\\min})\n$$\n接下来，强制执行稳定性裕度约束 $-\\max \\operatorname{Re} \\lambda(A_{\\theta}) \\ge \\alpha_{\\min}$。对于单个块，这等同于确保其特征值实部的幅值至少为 $\\alpha_{\\min}$。该幅值由 $m(\\zeta, \\omega_n) = \\omega_n f(\\zeta)$ 给出，其中函数 $f(\\zeta)$ 定义为：\n$$\nf(\\zeta) = \\begin{cases}\n\\zeta,  \\text{if } 0  \\zeta  1 \\\\\n\\zeta - \\sqrt{\\zeta^2 - 1},  \\text{if } \\zeta \\ge 1\n\\end{cases}\n$$\n约束 $m(\\zeta, \\omega_n) \\ge \\alpha_{\\min}$ 意味着 $\\omega_n \\ge \\alpha_{\\min} / f(\\zeta)$。这通过对自然频率进行投影来强制执行：\n$$\n\\omega_n = \\max\\left(\\tilde{\\omega}_n, \\frac{\\alpha_{\\min}}{f(\\zeta)}\\right)\n$$\n此投影使用了已经过约束的 $\\zeta$ 值。利用每个模态的最终约束参数 $(\\zeta, \\omega_n)$，重建 $A_{\\theta}$ 的相应块，并组装完整的 $A_{\\theta}$。\n\n**步骤 4：验证**\n最终构建的矩阵 $A_{\\theta}$ 将对照两个约束进行验证，容差为 $10^{-6}$。\n1.  **稳定性裕度**：计算 $A_\\theta$ 的特征值，并确认 $-\\max \\operatorname{Re} \\lambda(A_{\\theta}) \\ge \\alpha_{\\min}$。\n2.  **阻尼比**：对于每个模态 $i$，如果模态是欠阻尼的（$0  \\zeta_i  1$），则有效阻尼比取为 $\\zeta_i$；如果是临界阻尼或过阻尼的（$\\zeta_i \\ge 1$），则取为 $1$。这些有效阻尼比的最小值不得小于 $\\zeta_{\\min}$。\n\n所述过程是稳健的，并基于已确立的原则。假设有足够的数值精度，该投影通过构造确保了最终参数将满足设计标准。我们现在开始进行实现。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import expm, logm, block_diag\n\ndef solve():\n    \"\"\"\n    Implements and verifies a constrained identification procedure for a neural state-space model.\n    \"\"\"\n    \n    # Each tuple: (zeta_min, alpha_min, dt, T, (w_n1*, w_n2*), (z1*, z2*), x0)\n    test_cases = [\n        (0.2, 0.05, 0.05, 200, (0.8, 1.3), (0.3, 0.5), np.array([1.0, 0.0, 0.8, 0.0])),\n        (0.7, 0.2, 0.05, 180, (1.0, 1.2), (0.8, 1.1), np.array([1.0, 0.0, 0.5, 0.0])),\n        (0.95, 0.6, 0.02, 300, (0.7, 2.0), (1.0, 0.97), np.array([1.2, 0.0, 0.4, 0.0])),\n    ]\n\n    results = []\n\n    for case in test_cases:\n        zeta_min, alpha_min, dt, T, omegas_star, zetas_star, x0 = case\n\n        # --- Step 1: Data Generation ---\n        def create_A_block(zeta, omega_n):\n            \"\"\"Constructs a 2x2 second-order oscillator block.\"\"\"\n            return np.array([[0, 1], [-omega_n**2, -2 * zeta * omega_n]])\n\n        A1_star = create_A_block(zetas_star[0], omegas_star[0])\n        A2_star = create_A_block(zetas_star[1], omegas_star[1])\n        A_star = block_diag(A1_star, A2_star)\n        \n        Phi_star = expm(A_star * dt)\n        \n        X = np.zeros((4, T))\n        X[:, 0] = x0\n        for k in range(T - 1):\n            X[:, k + 1] = Phi_star @ X[:, k]\n\n        # --- Step 2: System Identification ---\n        X0_data = X[:, :T-1]\n        X1_data = X[:, 1:T]\n        \n        Phi_hat = X1_data @ np.linalg.pinv(X0_data)\n        \n        # Recover continuous-time matrix, taking real part to discard numerical noise\n        A_hat = logm(Phi_hat).real / dt\n\n        # --- Step 3: Constrained Parameter Projection ---\n        def f_zeta(zeta):\n            \"\"\"Computes the function f(zeta) for the stability margin constraint.\"\"\"\n            if 0  zeta  1:\n                return zeta\n            elif zeta >= 1:\n                # To avoid potential numerical issues with sqrt(z^2 - 1) when z is close to 1\n                if np.isclose(zeta, 1.0):\n                    return 1.0\n                return zeta - np.sqrt(zeta**2 - 1)\n            return 0.0 # Should not be reached as zeta >= zeta_min > 0\n\n        A_theta_blocks = []\n        constrained_zetas = []\n        for i in range(2):\n            A_hat_block = A_hat[2*i : 2*i+2, 2*i : 2*i+2]\n            a21 = A_hat_block[1, 0]\n            a22 = A_hat_block[1, 1]\n\n            # Extract provisional parameters\n            omega_n_tilde_sq = -a21\n            omega_n_tilde = np.sqrt(max(1e-12, omega_n_tilde_sq))\n            \n            zeta_tilde = -a22 / (2 * omega_n_tilde)\n\n            # Apply damping ratio constraint\n            zeta = max(zeta_tilde, zeta_min)\n            constrained_zetas.append(zeta)\n\n            # Apply stability margin constraint\n            f_val = f_zeta(zeta)\n            \n            # Avoid division by zero if f_val is non-positive\n            min_omega_from_alpha = alpha_min / f_val if f_val > 1e-12 else float('inf')\n            \n            omega_n = max(omega_n_tilde, min_omega_from_alpha)\n            \n            # Reconstruct the block\n            A_theta_block = create_A_block(zeta, omega_n)\n            A_theta_blocks.append(A_theta_block)\n        \n        A_theta = block_diag(*A_theta_blocks)\n\n        # --- Step 4: Verification ---\n        eigvals = np.linalg.eigvals(A_theta)\n        \n        # Verify stability margin\n        max_real_part = np.max(np.real(eigvals))\n        margin_ok = (-max_real_part) >= (alpha_min - 1e-6)\n\n        # Verify damping ratio\n        effective_zetas = [z if z  1.0 else 1.0 for z in constrained_zetas]\n        min_damping_ratio = min(effective_zetas)\n        damping_ok = min_damping_ratio >= (zeta_min - 1e-6)\n        \n        results.append(margin_ok and damping_ok)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2886035"}]}