{"hands_on_practices": [{"introduction": "本练习旨在通过具体计算巩固对完美重构（Perfect Reconstruction, PR）滤波器组核心机制的理解。通过对一个简短的符号信号应用哈尔（Haar）小波变换，您将亲手执行分析和综合步骤，从而直观地验证信号如何被分解并能无损地恢复[@problem_id:2916288]。这项基础实践是理解更复杂小波系统如何工作的关键第一步。", "problem": "考虑一个长度为 $4$ 的离散时间信号，其样本为 $x[0]=\\alpha$，$x[1]=\\beta$，$x[2]=\\gamma$ 和 $x[3]=\\delta$，其中 $\\alpha,\\beta,\\gamma,\\delta \\in \\mathbb{R}$。设一个双通道分析/合成滤波器组由 Haar 小波构成，该小波被视为一个特殊的正交归一双正交对。分析低通和高通滤波器分别为 $h_{0}[n]=\\left\\{\\frac{1}{\\sqrt{2}},\\frac{1}{\\sqrt{2}}\\right\\}$ 和 $h_{1}[n]=\\left\\{\\frac{1}{\\sqrt{2}},-\\frac{1}{\\sqrt{2}}\\right\\}$，每个滤波器长度为 $2$。分析阶段包括滤波和随后的 $2$ 倍下采样，通过将样本分组为不重叠的相邻对来应用，不进行边界环绕处理。合成阶段是分析阶段的精确逆过程，可以通过 Haar 滤波器组的完美重构 (PR) 特性或通过反转相应提升方案的预测和更新算子的提升步骤来获得。\n\n任务：\n1) 仅使用线性时不变滤波、2倍下采样和给定分析滤波器的定义，显式计算第一级近似序列 $a_{1}[k]$ 和细节序列 $d_{1}[k]$（对于 $k\\in\\{0,1\\}$），用 $\\alpha,\\beta,\\gamma,\\delta$ 表示。\n2) 直接从第一性原理推导合成关系，可使用分析多相映射的逆，或使用适用于 Haar 情况的包含分裂-预测-更新-缩放步骤的提升方案的逆。使用这些关系以符号形式用 $\\alpha,\\beta,\\gamma,\\delta$ 重构 $\\hat{x}[n]$（对于 $n\\in\\{0,1,2,3\\}$）。\n3) 通过将重构误差能量 $E(\\alpha,\\beta,\\gamma,\\delta)=\\sum_{n=0}^{3}\\left(x[n]-\\hat{x}[n]\\right)^{2}$ 表示为关于 $\\alpha,\\beta,\\gamma,\\delta$ 的闭式表达式，来符号化地验证完美重构 (PR)。你的最终答案必须是这个 $E(\\alpha,\\beta,\\gamma,\\delta)$。\n4) 为了数值验证您的符号推导，取具体值 $x[0]=2$，$x[1]=-1$，$x[2]=0$，$x[3]=3$，并计算数值 $a_{1}[k]$、$d_{1}[k]$ 和 $\\hat{x}[n]$，以确认符号化得到的 $E$ 值。不需要四舍五入；以精确形式保留任何出现的 $\\sqrt{2}$。\n\n将最终答案表示为关于 $E(\\alpha,\\beta,\\gamma,\\delta)$ 的单一闭式表达式，不带单位。不要提供不等式或方程；只提供表达式。不需要四舍五入。", "solution": "在尝试任何解答之前，对问题陈述进行验证。\n\n步骤 1：提取已知条件\n- 信号：长度为 $4$ 的离散时间信号，记为 $x[n]$，样本为 $x[0]=\\alpha$，$x[1]=\\beta$，$x[2]=\\gamma$ 和 $x[3]=\\delta$。参数 $\\alpha, \\beta, \\gamma, \\delta$ 是实数，即 $\\alpha,\\beta,\\gamma,\\delta \\in \\mathbb{R}$。\n- 滤波器组：一个基于 Haar 小波的双通道分析/合成系统。\n- 分析滤波器：\n  - 低通：$h_{0}[n]=\\left\\{\\frac{1}{\\sqrt{2}},\\frac{1}{\\sqrt{2}}\\right\\}$，对于 $n \\in \\{0, 1\\}$。\n  - 高通：$h_{1}[n]=\\left\\{\\frac{1}{\\sqrt{2}},-\\frac{1}{\\sqrt{2}}\\right\\}$，对于 $n \\in \\{0, 1\\}$。\n- 分析过程：“滤波和随后的 $2$ 倍下采样，通过将样本分组为不重叠的相邻对来应用，不进行边界环绕处理。”\n- 合成过程：分析阶段的精确逆过程。\n- 任务 1：计算第一级近似序列 $a_{1}[k]$ 和细节序列 $d_{1}[k]$（对于 $k\\in\\{0,1\\}$）。\n- 任务 2：推导合成关系并重构信号 $\\hat{x}[n]$（对于 $n\\in\\{0,1,2,3\\}$）。\n- 任务 3：通过找到重构误差能量 $E(\\alpha,\\beta,\\gamma,\\delta)=\\sum_{n=0}^{3}\\left(x[n]-\\hat{x}[n]\\right)^{2}$ 的闭式表达式来验证完美重构 (PR)。\n- 任务 4：使用 $x[0]=2$，$x[1]=-1$，$x[2]=0$，$x[3]=3$ 对符号推导进行数值验证。\n- 最终答案：$E(\\alpha,\\beta,\\gamma,\\delta)$ 的表达式。\n\n步骤 2：使用提取的已知条件进行验证\n- 科学基础：该问题在根本上是合理的。它基于数字信号处理的既定原理，特别是离散小波变换 (DWT)、滤波器组和提升方案，所有这些都是工程和应用数学中的标准课题。Haar 小波是一个典型的例子。\n- 适定性：该问题是适定的。信号是有限的，滤波器有明确定义，边界处理（“不重叠的相邻对”）也已明确指定。这确保了可以确定唯一的解。\n- 客观性：问题以精确、客观和数学化的语言陈述，没有任何主观或模糊的术语。\n\n步骤 3：结论和行动\n该问题是有效的。这是离散信号处理中的一个标准练习，具有科学基础、适定性和客观性。现在将提供完整的解答。\n\n该问题需要一个四部分的推导和验证过程。我们将有条不紊地完成每个任务。短语“将样本分组为不重叠的相邻对”意味着变换被独立地应用于对 $(x[0], x[1])$ 和对 $(x[2], x[3])$。\n\n任务 1：分析阶段计算\n分析阶段计算近似系数 $a_{1}[k]$ 和细节系数 $d_{1}[k]$。对于基于块的非重叠变换，这等同于将滤波操作应用于每对样本。设滤波器系数的索引从 $n=0$到 $n=1$。\n\n对于第一对 $(x[0], x[1]) = (\\alpha, \\beta)$，对应于 $k=0$：\n近似系数 $a_{1}[0]$ 使用低通滤波器 $h_0[n]$ 计算：\n$$a_{1}[0] = h_{0}[0]x[0] + h_{0}[1]x[1] = \\frac{1}{\\sqrt{2}}\\alpha + \\frac{1}{\\sqrt{2}}\\beta = \\frac{\\alpha+\\beta}{\\sqrt{2}}$$\n细节系数 $d_{1}[0]$ 使用高通滤波器 $h_1[n]$ 计算：\n$$d_{1}[0] = h_{1}[0]x[0] + h_{1}[1]x[1] = \\frac{1}{\\sqrt{2}}\\alpha - \\frac{1}{\\sqrt{2}}\\beta = \\frac{\\alpha-\\beta}{\\sqrt{2}}$$\n\n对于第二对 $(x[2], x[3]) = (\\gamma, \\delta)$，对应于 $k=1$：\n近似系数 $a_{1}[1]$ 的计算类似：\n$$a_{1}[1] = h_{0}[0]x[2] + h_{0}[1]x[3] = \\frac{1}{\\sqrt{2}}\\gamma + \\frac{1}{\\sqrt{2}}\\delta = \\frac{\\gamma+\\delta}{\\sqrt{2}}$$\n细节系数 $d_{1}[1]$ 为：\n$$d_{1}[1] = h_{1}[0]x[2] + h_{1}[1]x[3] = \\frac{1}{\\sqrt{2}}\\gamma - \\frac{1}{\\sqrt{2}}\\delta = \\frac{\\gamma-\\delta}{\\sqrt{2}}$$\n\n任务 2：合成阶段推导和重构\n问题要求从第一性原理推导合成关系，特别是逆提升方案。首先，我们建立与我们的分析滤波器相对应的正向提升方案。\n\n正向提升方案：\n1.  分裂：信号 $x[n]$ 被分裂为偶数索引样本 $x_e[k] = x[2k]$ 和奇数索引样本 $x_o[k] = x[2k+1]$。\n2.  预测：形成细节信号。为了匹配 $d_1[k] = \\frac{x[2k]-x[2k+1]}{\\sqrt{2}}$，未缩放的细节必须是 $d_1'[k] = x[2k] - x[2k+1]$。\n3.  更新：形成近似信号。为了匹配 $a_1[k] = \\frac{x[2k]+x[2k+1]}{\\sqrt{2}}$，未缩放的近似为 $a_1'[k] = \\frac{x[2k]+x[2k+1]}{2}$。我们可以用一个更新步骤来表示它：$a_1'[k] = x_o[k] + \\frac{1}{2}d_1'[k] = x[2k+1] + \\frac{1}{2}(x[2k]-x[2k+1]) = \\frac{x[2k]+x[2k+1]}{2}$。\n4.  缩放：应用归一化。$d_1[k] = d_1'[k] / \\sqrt{2}$ 且 $a_1[k] = a_1'[k] \\times \\sqrt{2}$。\n\n逆提升方案：\n为了重构信号，我们按相反顺序反转这些步骤。\n1.  逆缩放：我们恢复未缩放的系数 $d_1'[k]$ 和 $a_1'[k]$。\n    $$d_1'[k] = d_1[k] \\times \\sqrt{2}$$\n    $$a_1'[k] = a_1[k] / \\sqrt{2}$$\n2.  逆更新：我们从 $a_1'[k]$ 和 $d_1'[k]$ 恢复奇数索引样本 $x_o[k]$。根据更新步骤 $a_1'[k] = x_o[k] + \\frac{1}{2}d_1'[k]$，我们有：\n    $$\\hat{x}_o[k] = a_1'[k] - \\frac{1}{2}d_1'[k]$$\n3.  逆预测：我们从 $d_1'[k]$ 和现已知的 $\\hat{x}_o[k]$ 恢复偶数索引样本 $x_e[k]$。根据预测步骤 $d_1'[k] = x_e[k] - x_o[k]$，我们有：\n    $$\\hat{x}_e[k] = d_1'[k] + \\hat{x}_o[k]$$\n4.  合并：重构的信号样本为 $\\hat{x}[2k] = \\hat{x}_e[k]$ 和 $\\hat{x}[2k+1] = \\hat{x}_o[k]$。\n\n现在，我们应用这些合成关系来符号化地重构 $\\hat{x}[n]$。\n对于 $k=0$：\n1.  逆缩放：\n    $d_1'[0] = \\left(\\frac{\\alpha-\\beta}{\\sqrt{2}}\\right)\\sqrt{2} = \\alpha-\\beta$\n    $a_1'[0] = \\left(\\frac{\\alpha+\\beta}{\\sqrt{2}}\\right)/\\sqrt{2} = \\frac{\\alpha+\\beta}{2}$\n2.  逆更新（重构 $\\hat{x}[1]$）：\n    $\\hat{x}[1] = \\hat{x}_o[0] = a_1'[0] - \\frac{1}{2}d_1'[0] = \\frac{\\alpha+\\beta}{2} - \\frac{1}{2}(\\alpha-\\beta) = \\frac{\\alpha+\\beta-\\alpha+\\beta}{2} = \\beta$\n3.  逆预测（重构 $\\hat{x}[0]$）：\n    $\\hat{x}[0] = \\hat{x}_e[0] = d_1'[0] + \\hat{x}_o[0] = (\\alpha-\\beta) + \\beta = \\alpha$\n\n对于 $k=1$：\n1.  逆缩放：\n    $d_1'[1] = \\left(\\frac{\\gamma-\\delta}{\\sqrt{2}}\\right)\\sqrt{2} = \\gamma-\\delta$\n    $a_1'[1] = \\left(\\frac{\\gamma+\\delta}{\\sqrt{2}}\\right)/\\sqrt{2} = \\frac{\\gamma+\\delta}{2}$\n2.  逆更新（重构 $\\hat{x}[3]$）：\n    $\\hat{x}[3] = \\hat{x}_o[1] = a_1'[1] - \\frac{1}{2}d_1'[1] = \\frac{\\gamma+\\delta}{2} - \\frac{1}{2}(\\gamma-\\delta) = \\frac{\\gamma+\\delta-\\gamma+\\delta}{2} = \\delta$\n3.  逆预测（重构 $\\hat{x}[2]$）：\n    $\\hat{x}[2] = \\hat{x}_e[1] = d_1'[1] + \\hat{x}_o[1] = (\\gamma-\\delta) + \\delta = \\gamma$\n\n重构的信号是 $\\hat{x}[n] = \\{\\alpha, \\beta, \\gamma, \\delta\\}$。\n\n任务 3：重构误差能量\n重构误差能量定义为 $E(\\alpha,\\beta,\\gamma,\\delta)=\\sum_{n=0}^{3}\\left(x[n]-\\hat{x}[n]\\right)^{2}$。\n从任务 2 中，我们已经确定重构信号与原始信号相同：\n$\\hat{x}[0]=\\alpha=x[0]$\n$\\hat{x}[1]=\\beta=x[1]$\n$\\hat{x}[2]=\\gamma=x[2]$\n$\\hat{x}[3]=\\delta=x[3]$\n因此，每个样本点的误差都为零：对于所有 $n \\in \\{0, 1, 2, 3\\}$，$x[n]-\\hat{x}[n]=0$。\n因此，总误差能量为：\n$$E(\\alpha, \\beta, \\gamma, \\delta) = (x[0]-\\hat{x}[0])^2 + (x[1]-\\hat{x}[1])^2 + (x[2]-\\hat{x}[2])^2 + (x[3]-\\hat{x}[3])^2$$\n$$E(\\alpha, \\beta, \\gamma, \\delta) = (\\alpha-\\alpha)^2 + (\\beta-\\beta)^2 + (\\gamma-\\gamma)^2 + (\\delta-\\delta)^2 = 0^2 + 0^2 + 0^2 + 0^2 = 0$$\n这符号化地证明了 Haar 滤波器组提供了完美重构。误差能量的闭式表达式就是 $0$。\n\n任务 4：数值验证\n为了确认符号结果，我们使用具体信号 $x[n] = \\{2, -1, 0, 3\\}$。这里，$\\alpha=2$，$\\beta=-1$，$\\gamma=0$，$\\delta=3$。\n分析系数：\n$a_{1}[0] = \\frac{2+(-1)}{\\sqrt{2}} = \\frac{1}{\\sqrt{2}}$\n$d_{1}[0] = \\frac{2-(-1)}{\\sqrt{2}} = \\frac{3}{\\sqrt{2}}$\n$a_{1}[1] = \\frac{0+3}{\\sqrt{2}} = \\frac{3}{\\sqrt{2}}$\n$d_{1}[1] = \\frac{0-3}{\\sqrt{2}} = -\\frac{3}{\\sqrt{2}}$\n\n重构：\n我们使用从任务2推导出的逆提升步骤。\n对于 $k=0$（重构 $\\hat{x}[0]$ 和 $\\hat{x}[1]$）：\n1. 逆缩放：\n   $d_1'[0] = d_1[0] \\sqrt{2} = \\frac{3}{\\sqrt{2}}\\sqrt{2} = 3$\n   $a_1'[0] = a_1[0] / \\sqrt{2} = \\frac{1/\\sqrt{2}}{\\sqrt{2}} = \\frac{1}{2}$\n2. 逆更新（恢复 $\\hat{x}[1]$）:\n   $\\hat{x}[1] = \\hat{x}_o[0] = a_1'[0] - \\frac{1}{2}d_1'[0] = \\frac{1}{2} - \\frac{1}{2}(3) = -1$。\n3. 逆预测（恢复 $\\hat{x}[0]$）:\n   $\\hat{x}[0] = \\hat{x}_e[0] = d_1'[0] + \\hat{x}_o[0] = 3 + (-1) = 2$。\n\n对于 $k=1$（重构 $\\hat{x}[2]$ 和 $\\hat{x}[3]$）：\n1. 逆缩放：\n   $d_1'[1] = d_1[1] \\sqrt{2} = -\\frac{3}{\\sqrt{2}}\\sqrt{2} = -3$\n   $a_1'[1] = a_1[1] / \\sqrt{2} = \\frac{3/\\sqrt{2}}{\\sqrt{2}} = \\frac{3}{2}$\n2. 逆更新（恢复 $\\hat{x}[3]$）:\n   $\\hat{x}[3] = \\hat{x}_o[1] = a_1'[1] - \\frac{1}{2}d_1'[1] = \\frac{3}{2} - \\frac{1}{2}(-3) = 3$。\n3. 逆预测（恢复 $\\hat{x}[2]$）:\n   $\\hat{x}[2] = \\hat{x}_e[1] = d_1'[1] + \\hat{x}_o[1] = -3 + 3 = 0$。\n\n重构的信号是 $\\hat{x}[n] = \\{2, -1, 0, 3\\}$，与原始信号相同。数值误差能量 $E$ 为 $0$，确认了符号结果。推导是合理的。最终答案是误差能量 $E(\\alpha,\\beta,\\gamma,\\delta)$ 的符号表达式。", "answer": "$$\n\\boxed{0}\n$$", "id": "2916288"}, {"introduction": "在掌握了基础的两通道分解之后，本练习将引导您探索小波包变换的灵活性和强大功能。您将通过编程实现一个完整的小波包分解树，并验证无论选择哪种“可容许基”（admissible basis），完美重构特性依然成立[@problem_id:2916274]。这个实践揭示了小波包如何为信号提供定制化的频率分析能力，这是其在高级信号处理中广泛应用的核心原因。", "problem": "给定一项任务，要求在双正交框架内，使用通过提升方案实现的 Haar 基，实现并分析一个两级小波包变换 (WPT)。目标是计算深度为 $2$ 的所有节点系数，并验证当使用匹配的对偶合成时，不同的容许基能够产生完全相同的重构结果。\n\n从以下基本定义和事实开始：\n\n- 提升方案将双正交小波变换实现为一系列可逆的线性步骤。对于一个偶数长度的离散时间信号 $x[n]$，定义奇偶分裂为 $e[k] = x[2k]$ 和 $o[k] = x[2k+1]$。\n- 预测算子 $\\mathcal{P}$ 通过 $d[k] = o[k] - e[k]$ 生成细节系数。\n- 更新算子 $\\mathcal{U}$ 通过 $a[k] = e[k] + \\frac{1}{2} d[k]$ 生成粗糙（近似）系数。\n- 合成（对偶）算子精确地反转这些步骤：$e[k] = a[k] - \\frac{1}{2} d[k]$，$o[k] = d[k] + e[k]$，并通过交错恢复原始信号：$x[2k] = e[k]$，$x[2k+1] = o[k]$。\n- 上述分析和合成步骤对构成了一个通过提升方案实现的双正交 Haar 变换，并实现了完美重构 (Perfect Reconstruction, PR)。\n- 小波包分解将相同的双通道分裂应用于近似和细节通道，从而产生一个完整的子带二叉树。在深度为 $2$ 时，第 $1$ 层的节点是 $A_1$ 和 $D_1$，四个第 $2$ 层的节点是来自 $A_1$ 的 $AA$、$AD$ 和来自 $D_1$ 的 $DA$、$DD$。\n- 一个容许基是树叶节点的集合，这些叶节点两两不交，且其并集覆盖了根节点。为了精确重构，每个选定的叶节点必须沿着其路径通过匹配的对偶变换进行合成，并且未分解叶节点的父节点必须与其兄弟节点通过逆提升步骤进行合并。\n\n待完成的任务：\n\n1. 实现上述用于 Haar 双正交变换的分析和合成提升步骤。\n2. 实现一个信号 $x[n]$ 的深度为 $2$ 的小波包分解，以计算所有节点系数 $A_1$、$D_1$、$AA$、$AD$、$DA$、$DD$。\n3. 使用匹配的对偶算子实现依赖于基的重构：\n   - 基 $\\mathcal{B}_1$：均匀深度为 $2$ 的叶节点 $\\{AA, AD, DA, DD\\}$。\n   - 基 $\\mathcal{B}_2$：仅分裂近似分支 $\\{AA, AD, D_1\\}$。\n   - 基 $\\mathcal{B}_3$：仅分裂细节分支 $\\{A_1, DA, DD\\}$。\n   当一个分支被分裂时，重构必须首先将其子节点合成为父节点，然后将第 $1$ 层的节点对合成为根节点。\n4. 对于下面的每个测试用例，计算最大绝对重构误差 $E = \\max_n |x[n] - \\hat{x}[n]|$，并验证 $E \\le \\tau$ 是否成立，其中容差 $\\tau = 10^{-12}$。为每个测试用例报告一个布尔值。\n\n测试套件：\n\n- 使用长度为 $8$ 的信号，以便深度为 $2$ 的分解可以明确定义而无需边界处理。三个信号如下：\n  - $x^{(1)} = [\\, 3.0,\\, 1.0,\\, 0.0,\\, -1.0,\\, 2.0,\\, 4.0,\\, -2.0,\\, 0.5 \\,]$。\n  - $x^{(2)} = [\\, 5.0,\\, 5.0,\\, 5.0,\\, 5.0,\\, 5.0,\\, 5.0,\\, 5.0,\\, 5.0 \\,]$。\n  - $x^{(3)} = [\\, 1.0,\\, -1.0,\\, 1.0,\\, -1.0,\\, 1.0,\\, -1.0,\\, 1.0,\\, -1.0 \\,]$。\n- 将每个信号与每个基 $\\mathcal{B}_1$、$\\mathcal{B}_2$、$\\mathcal{B}_3$ 结合，得到 $9$ 个测试用例。对于每个用例，输出一个布尔值，指示重构是否通过容差检查 $E \\le \\tau$。\n\n最终输出格式：\n\n- 你的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表。该列表必须按以下顺序包含 $9$ 个布尔值：$(x^{(1)}, \\mathcal{B}_1)$、$(x^{(1)}, \\mathcal{B}_2)$、$(x^{(1)}, \\mathcal{B}_3)$、$(x^{(2)}, \\mathcal{B}_1)$、$(x^{(2)}, \\mathcal{B}_2)$、$(x^{(2)}, \\mathcal{B}_3)$、$(x^{(3)}, \\mathcal{B}_1)$、$(x^{(3)}, \\mathcal{B}_2)$、$(x^{(3)}, \\mathcal{B}_3)$。例如，输出格式必须与 $[True,True,True,True,True,True,True,True,True]$ 完全一样，没有多余的空格。", "solution": "我们使用通过提升方案实现的 Haar 基，形式化地描述了两级小波包分解和重构，并论证了为何当使用匹配的对偶算子时，任何容许基都能重构出原始信号。\n\n基础算子：\n\n- 奇偶分裂：对于一个偶数长度的离散时间信号 $x[n]$，定义 $e[k] = x[2k]$ 和 $o[k] = x[2k+1]$，其中 $k = 0, 1, \\dots, \\frac{N}{2}-1$。\n- 预测（分析）：细节系数为 $d[k] = o[k] - e[k]$。这对应于通过偶数位样本预测奇数位样本并存储预测误差。\n- 更新（分析）：近似系数为 $a[k] = e[k] + \\frac{1}{2} d[k]$。这使用细节系数更新粗糙尺度，以保持低频矩。\n- 合成（对偶）：通过 $e[k] = a[k] - \\frac{1}{2} d[k]$，然后 $o[k] = d[k] + e[k]$ 实现精确反演，并通过交错可恢复 $x[2k] = e[k]$ 和 $x[2k+1] = o[k]$。\n\n分析映射 $(x \\mapsto (a, d))$ 是一个可逆线性算子，其逆算子如上所示；因此，这构成了一个具有完美重构 (PR) 的双正交对。完美重构 (PR) 属性通过直接代入即可立即验证：\n$$\ne[k] = \\Big(e[k] + \\tfrac{1}{2} d[k]\\Big) - \\tfrac{1}{2} d[k] = e[k], \\quad\no[k] = d[k] + e[k] = (o[k] - e[k]) + e[k] = o[k].\n$$\n因此，交错操作能精确地再现 $x[n]$。\n\n小波包树：\n\n- $x[n]$ 的第 $1$ 级分解产生 $(A_1, D_1) = (a^{(1)}, d^{(1)})$，由 $(e^{(0)}, o^{(0)})$ 按上述方法计算得出。\n- 第 $2$ 级分解通过将相同的提升步骤应用于 $A_1$ 和 $D_1$ 来进行：\n  - 从 $A_1$ 我们通过奇偶分裂和相同的预测-更新对获得 $(AA, AD)$。\n  - 从 $D_1$ 我们类似地获得 $(DA, DD)$。\n\n令 $\\mathcal{L}$ 表示分析提升算子，$\\mathcal{L}^{-1}$ 表示其合成对偶算子。在第 $1$ 级，我们将 $\\mathcal{L}$ 应用于 $x$ 以获得 $(A_1, D_1)$。在第 $2$ 级，$\\mathcal{L}$ 被独立地应用于 $A_1$ 和 $D_1$，产生四个孙子节点 $(AA, AD, DA, DD)$。\n\n容许基与重构：\n\n- 容许基是一组叶节点的集合，它们对树进行划分，使得根部的每个原始自由度都恰好被表示一次。深度为 $2$ 的例子：\n  - $\\mathcal{B}_1 = \\{ AA, AD, DA, DD \\}$ (均匀细化)。\n  - $\\mathcal{B}_2 = \\{ AA, AD, D_1 \\}$ (仅细化近似分支)。\n  - $\\mathcal{B}_3 = \\{ A_1, DA, DD \\}$ (仅细化细节分支)。\n- 使用匹配的对偶算子进行重构，会沿着从每个选定叶节点到根节点的路径复合逆提升算子：\n  - 对于 $\\mathcal{B}_1$，合成 $A_1 = \\mathcal{L}^{-1}(AA, AD)$ 和 $D_1 = \\mathcal{L}^{-1}(DA, DD)$，然后 $x = \\mathcal{L}^{-1}(A_1, D_1)$。\n  - 对于 $\\mathcal{B}_2$，合成 $A_1 = \\mathcal{L}^{-1}(AA, AD)$ 并使用原始的 $D_1$，然后 $x = \\mathcal{L}^{-1}(A_1, D_1)$。\n  - 对于 $\\mathcal{B}_3$，合成 $D_1 = \\mathcal{L}^{-1}(DA, DD)$ 并使用原始的 $A_1$，然后 $x = \\mathcal{L}^{-1}(A_1, D_1)$。\n  \n因为每个 $\\mathcal{L}$ 都有一个双边逆 $\\mathcal{L}^{-1}$，并且不同的分支操作于不相交的索引集（由于奇偶分裂），线性和块对角结构意味着，只要每个自由度都恰好被包含一次，沿选定叶节点路径的任何逆算子复合都会恢复出相同的向量 $x$。更形式化地讲，如果我们用 $T$ 表示将 $x$ 映射到 $(AA, AD, DA, DD)$ 的完整第 $2$ 级分析算子，用 $T^{-1}$ 表示其块级逆算子（首先重构 $(A_1, D_1)$ 然后是 $x$），那么容许基对应于将 $T$ 剪枝为块三角形式，其逆通过在细化分支上部分应用 $T^{-1}$ 并直接传递未细化的父节点来获得。由于所有路径都使用匹配的对偶算子，净算子是 $\\mathbb{R}^N$ 上的恒等算子。\n\n算法设计：\n\n- 使用显式公式 $d = o - e$，$a = e + \\frac{1}{2}d$ 实现分析提升步骤。\n- 使用 $e = a - \\frac{1}{2}d$，$o = d + e$ 和交错操作实现合成提升步骤。\n- 通过将分析步骤应用于根节点，然后应用于其两个子节点，来实现深度为 $2$ 的 WPT。\n- 通过沿必要的分支自底向上应用合成步骤，来实现针对选定基的重构。\n- 对于每个测试用例，计算最大绝对误差 $E = \\max_n |x[n] - \\hat{x}[n]|$ 并检查 $E \\le \\tau$，其中 $\\tau = 10^{-12}$。\n\n测试套件与预期结果：\n\n- 长度为 $8$ 的信号：$x^{(1)} = [\\, 3.0,\\, 1.0,\\, 0.0,\\, -1.0,\\, 2.0,\\, 4.0,\\, -2.0,\\, 0.5 \\,]$，$x^{(2)} = [\\, 5.0,\\, 5.0,\\, 5.0,\\, 5.0,\\, 5.0,\\, 5.0,\\, 5.0,\\, 5.0 \\,]$，$x^{(3)} = [\\, 1.0,\\, -1.0,\\, 1.0,\\, -1.0,\\, 1.0,\\, -1.0,\\, 1.0,\\, -1.0 \\,]$。\n- 基 $\\mathcal{B}_1$、$\\mathcal{B}_2$、$\\mathcal{B}_3$ 如上定义。\n- 由于合成使用分析的精确对偶算子，PR 保证了在精确算术中重构误差恰好为零，并且在浮点容差范围内数值上为零。因此，对于 $\\tau = 10^{-12}$，9 个布尔值中的每一个都应该是 $True$。\n\n最终答案中指定的程序实现了这些步骤，并按要求的顺序打印出包含 $9$ 个布尔值的单行列表。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef analysis_lifting_haar_biorth(x: np.ndarray):\n    \"\"\"\n    One-level biorthogonal Haar analysis via lifting:\n    - Split into even and odd\n    - Predict: d = o - e\n    - Update:  a = e + 0.5 * d\n    Returns (a, d)\n    \"\"\"\n    e = x[0::2]\n    o = x[1::2]\n    d = o - e\n    a = e + 0.5 * d\n    return a, d\n\ndef synthesis_lifting_haar_biorth(a: np.ndarray, d: np.ndarray):\n    \"\"\"\n    One-level biorthogonal Haar synthesis via lifting:\n    - Invert update: e = a - 0.5 * d\n    - Invert predict: o = d + e\n    - Interleave to reconstruct x\n    Returns reconstructed x\n    \"\"\"\n    e = a - 0.5 * d\n    o = d + e\n    x = np.empty(e.size + o.size, dtype=float)\n    x[0::2] = e\n    x[1::2] = o\n    return x\n\ndef wp2_forward(x: np.ndarray):\n    \"\"\"\n    Two-level wavelet packet decomposition using the above lifting steps.\n    Returns a dictionary with A1, D1, AA, AD, DA, DD.\n    \"\"\"\n    a1, d1 = analysis_lifting_haar_biorth(x)\n    aa, ad = analysis_lifting_haar_biorth(a1)\n    da, dd = analysis_lifting_haar_biorth(d1)\n    return {\n        'A1': a1,\n        'D1': d1,\n        'AA': aa,\n        'AD': ad,\n        'DA': da,\n        'DD': dd\n    }\n\ndef reconstruct_from_basis(coeffs: dict, basis: str):\n    \"\"\"\n    Reconstruct the signal from depth-2 wavelet packet coefficients using different admissible bases:\n    - basis == 'B1': leaves {AA, AD, DA, DD}\n    - basis == 'B2': leaves {AA, AD, D1}\n    - basis == 'B3': leaves {A1, DA, DD}\n    Returns reconstructed signal x_hat.\n    \"\"\"\n    if basis == 'B1':\n        # First synthesize A1 and D1 from their children\n        a1_hat = synthesis_lifting_haar_biorth(coeffs['AA'], coeffs['AD'])\n        d1_hat = synthesis_lifting_haar_biorth(coeffs['DA'], coeffs['DD'])\n        # Then synthesize full signal\n        x_hat = synthesis_lifting_haar_biorth(a1_hat, d1_hat)\n        return x_hat\n    elif basis == 'B2':\n        # Synthesize A1 from AA, AD; use original D1\n        a1_hat = synthesis_lifting_haar_biorth(coeffs['AA'], coeffs['AD'])\n        d1 = coeffs['D1']\n        x_hat = synthesis_lifting_haar_biorth(a1_hat, d1)\n        return x_hat\n    elif basis == 'B3':\n        # Synthesize D1 from DA, DD; use original A1\n        d1_hat = synthesis_lifting_haar_biorth(coeffs['DA'], coeffs['DD'])\n        a1 = coeffs['A1']\n        x_hat = synthesis_lifting_haar_biorth(a1, d1_hat)\n        return x_hat\n    else:\n        raise ValueError(\"Unknown basis identifier\")\n\ndef max_abs_err(x: np.ndarray, y: np.ndarray) -> float:\n    return float(np.max(np.abs(x - y)))\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Signals of length 8\n    x1 = np.array([3.0, 1.0, 0.0, -1.0, 2.0, 4.0, -2.0, 0.5], dtype=float)\n    x2 = np.array([5.0]*8, dtype=float)\n    x3 = np.array([1.0, -1.0, 1.0, -1.0, 1.0, -1.0, 1.0, -1.0], dtype=float)\n\n    signals = [x1, x2, x3]\n    bases = ['B1', 'B2', 'B3']  # B1: {AA,AD,DA,DD}, B2: {AA,AD,D1}, B3: {A1,DA,DD}\n    tol = 1e-12\n\n    test_cases = []\n    for sig in signals:\n        for b in bases:\n            test_cases.append((sig, b))\n\n    results = []\n    for x, basis in test_cases:\n        coeffs = wp2_forward(x)\n        x_hat = reconstruct_from_basis(coeffs, basis)\n        err = max_abs_err(x, x_hat)\n        results.append(err = tol)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2916274"}, {"introduction": "最后的这项实践将重点转向提升方案（lifting scheme）——一种现代且高效的小波构造方法。通过编程实现整数可逆的 Le Gall $5/3$ 双正交小波变换，您将了解双正交小波是如何通过一系列预测和更新步骤构建的，以及如何通过精确的舍入控制来实现完全无损的变换[@problem_id:2916322]。这项技术是现代数据压缩标准（如 JPEG 2000）的基石。", "problem": "设计并实现一个完整的、可运行的程序，该程序使用提升方案和明确指定的舍入规则，计算并反转与 Le Gall $5/3$ 双正交小波相对应的整数可逆变换。程序必须通过数值验证来证明对于一组短整数信号，重构是无损的，并为每种情况报告一个布尔结果。\n\n从以下基本原理开始：\n- 提升方案将双通道完美重构滤波器组分解为一系列作用于偶数和奇数索引样本的预测和更新步骤。给定一个长度为 $N$ 的输入整数序列 $x$，对其所有有效索引，定义其偶数索引部分 $s$ 和奇数索引部分 $o$ 为 $s[n] = x[2n]$ 和 $o[n] = x[2n+1]$。已知 Le Gall $5/3$ 双正交小波允许使用提升分解，其预测算子与 $-1/2$ 成比例，更新算子与 $1/4$ 成比例。\n- 整数到整数变换是通过将实值线性组合替换为整数组合，并随后进行指定的舍入来构建的，这样，正向和反向步骤都能将整数精确地映射到整数，并且在与相同的边界处理结合时，它们的复合操作为恒等变换。\n\n任务和规范：\n1. 在 $(s,o)$ 上使用两个提升步骤实现正向变换：\n   - 预测步骤（奇数更新）：使用 $s[n]$ 的邻居从 $o[n]$ 计算细节样本 $d[n]$，这对应于系数为 $-1/2$ 的线性预测，但通过应用以下舍入规则来确保整数输出：对于除以 $2$ 的运算，使用平均值的向下取整。具体来说，在计算两个整数 $a$ 和 $b$ 的平均值时，将其解释为 $\\left\\lfloor \\dfrac{a + b}{2} \\right\\rfloor$。\n   - 更新步骤（偶数更新）：使用与更新系数 $1/4$ 对应的相邻细节样本 $d$ 来细化 $s[n]$，通过带有偏移的向下取整实现四舍五入。具体来说，对于两个整数 $u$ 和 $v$ 的和，将 $\\dfrac{u+v}{4}$ 解释为 $\\left\\lfloor \\dfrac{u + v + 2}{4} \\right\\rfloor$。\n2. 边界处理：对缺失的邻居使用边界对称延拓。如果邻居索引超出有效范围，则用最近的有效索引替换它。对于细节数组 $d$ 为空的特殊情况（当 $N = 1$ 时发生），将更新贡献定义为 $0$。\n3. 通过代数方式反转正向提升步骤来实现逆变换，使用相同的舍入约定和边界处理，并按相反的应用顺序进行。\n4. 验证：对于每个测试用例，计算正向变换 $(s,d)$，然后进行逆变换以重构 $\\hat{x}$，并逐元素检查是否 $\\hat{x} = x$ 完全相等，以产生一个布尔结果。\n5. 测试套件需覆盖一般情况和边缘情况。使用以下输入信号，每个信号都表示为 Python 风格的列表，但为了数学上的清晰度，此处的每个整数都用 LaTeX 显示：\n   - 情况 1（混合符号，奇数长度）：$\\left[\\,7,-3,2,9,-8,1,0\\,\\right]$。\n   - 情况 2（短，偶数长度）：$\\left[\\,-3,7\\,\\right]$。\n   - 情况 3（单元素）：$\\left[\\,42\\,\\right]$。\n   - 情况 4（常数）：$\\left[\\,5,5,5,5,5\\,\\right]$。\n   - 情况 5（交替大数值）：$\\left[\\,1000,-1000,1000,-1000,999,-999\\,\\right]$。\n   - 情况 6（零和负数，奇数长度）：$\\left[\\,0,-1,0,-1,0\\,\\right]$。\n6. 输出格式：您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的布尔值列表。例如，三个测试用例的输出应类似于 $\\left[\\mathrm{True},\\mathrm{False},\\mathrm{True}\\right]$。\n\n您的实现必须是自包含的，使用与指定的基于向下取整的舍入规则一致的整数算术，并使用所述的对称延拓边界规则。不适用任何物理单位或角度单位。唯一允许的输出是针对指定测试套件的、按所提供确切顺序排列的单行布尔值列表。", "solution": "在尝试解决方案之前，对问题进行验证。\n\n**第1步：提取已知条件**\n- **变换**：用于 Le Gall $5/3$ 双正交小波的整数可逆变换。\n- **方法**：由预测步骤和更新步骤组成的提升方案。\n- **输入信号**：长度为 $N$ 的整数序列 $x$。\n- **信号分解**：$s[n] = x[2n]$（偶数索引样本），$o[n] = x[2n+1]$（奇数索引样本）。\n- **正向变换步骤**：\n  1. **预测（奇数更新）**：细节系数 $d[n]$ 是根据 $o[n]$ 及其在 $s$ 中的邻居计算的。该操作对应于系数为 $-\\frac{1}{2}$ 的实值预测器。两个整数 $a$ 和 $b$ 的平均值舍入规则指定为 $\\left\\lfloor \\frac{a + b}{2} \\right\\rfloor$。\n  2. **更新（偶数更新）**：近似系数 $a[n]$ 是通过用其相邻的细节系数 $d$ 来细化 $s[n]$ 计算得出的。该操作对应于系数为 $\\frac{1}{4}$ 的实值更新。项 $\\frac{u+v}{4}$ 的舍入规则指定为 $\\left\\lfloor \\frac{u + v + 2}{4} \\right\\rfloor$。\n- **边界处理**：对称延拓，解释为“用最近的有效索引替换越界的邻居索引”。为细节数组 $d$ 为空（当 $N=1$ 时）定义了一个特殊情况，此时更新贡献为 $0$。\n- **逆变换**：以相反的顺序代数地反转正向提升步骤，使用相同的舍入和边界处理规则。\n- **验证**：对于每个测试用例信号 $x$，计算正向变换得到 $(a, d)$，然后计算逆变换得到 $\\hat{x}$，并验证是否 $\\hat{x} = x$。\n- **测试用例**：\n  1. $[7, -3, 2, 9, -8, 1, 0]$\n  2. $[-3, 7]$\n  3. $[42]$\n  4. $[5, 5, 5, 5, 5]$\n  5. $[1000, -1000, 1000, -1000, 999, -999]$\n  6. $[0, -1, 0, -1, 0]$\n- **输出格式**：一行输出，包含一个用方括号括起来的、以逗号分隔的各测试用例的布尔结果列表。\n\n**第2步：使用提取的已知条件进行验证**\n对问题的有效性进行评估：\n- **科学依据**：该问题建立在小波理论和提升方案的既定数学原理之上。Le Gall $5/3$ 小波是双正交小波的一个标准例子，其通过提升方案的实现是一种有据可查的技术。使用指定舍入规则的整数到整数变换是无损信号处理的一种有效方法。\n- **定义明确**：问题被精确地规定。它提供了所有必要的组成部分：输入数据结构、变换方程、精确的整数舍入规则以及边界处理条件。这确保了可以构建一个唯一且可验证的解决方案。\n- **客观性**：问题以精确、客观的语言陈述，没有歧义或主观论断。\n\n**第3步：结论和行动**\n问题是**有效的**。这是一个定义明确且自包含的计算信号处理练习。现在将推导出解决方案。\n\n### 解决方案推导\n\n通过提升方案实现整数可逆 Le Gall $5/3$ 小波变换，需要仔细构建正向和逆向变换步骤，并严格遵守指定的舍入和边界规则。\n\n**1. 正向变换**\n\n正向变换将一个长度为 $N$ 的输入整数信号 $x$ 映射为一对整数序列：近似系数 $a$ 和细节系数 $d$。\n\n**a. 分割**\n输入信号 $x$ 首先被分割成其偶数索引元素 $s$ 和奇数索引元素 $o$：\n$$ s[n] = x[2n], \\quad n \\in [0, \\lceil N/2 \\rceil - 1] $$\n$$ o[n] = x[2n+1], \\quad n \\in [0, \\lfloor N/2 \\rfloor - 1] $$\n$s$ 和 $o$ 的长度分别为 $N_s = \\lceil N/2 \\rceil$ 和 $N_o = \\lfloor N/2 \\rfloor$。\n\n**b. 预测步骤**\n奇数样本 $o$ 被更新以产生细节系数 $d$。实值提升步骤为 $d[n] = o[n] - \\frac{1}{2}(s[n] + s[n+1])$。指定的整数实现是：\n$$ d[n] = o[n] - \\left\\lfloor \\frac{s_{left} + s_{right}}{2} \\right\\rfloor $$\n这对从 $0$ 到 $N_o-1$ 的每个 $n$ 进行计算。邻居 $s_{left}$ 和 $s_{right}$ 对应于 $s[n]$ 和 $s[n+1]$。需要进行边界处理。\n- 对于 $o[n]$，左邻居是 $s[n]$，由于 $n \\le N_o-1  N_s$，它总是在界内。\n- 右邻居是 $s[n+1]$。如果 $n+1 \\ge N_s$，则索引越界。最近的有效索引是 $N_s-1$。\n因此，邻居是 $s_{left} = s[n]$ 和 $s_{right} = s[\\min(n+1, N_s-1)]$。\n\n**c. 更新步骤**\n偶数样本 $s$ 使用新计算的细节系数 $d$ 进行更新，以产生近似系数 $a$。实值步骤为 $a[n] = s[n] + \\frac{1}{4}(d[n-1] + d[n])$。指定的整数实现是：\n$$ a[n] = s[n] + \\left\\lfloor \\frac{d_{left} + d_{right} + 2}{4} \\right\\rfloor $$\n这对从 $0$ 到 $N_s-1$ 的每个 $n$ 进行计算。\n- 特殊情况：如果 $N=1$，则 $N_o=0$，细节序列 $d$ 为空。问题指定更新为 $0$，所以 $a[0] = s[0]$。\n- 一般情况 ($N_o  0$)：对于 $s[n]$，邻居是 $d[n-1]$ 和 $d[n]$。应用边界处理：\n  - 左邻居 $d_{left}$ 在索引 $n-1$ 处找到。如果 $n-1  0$，最近的有效索引是 $0$。所以，$d_{left} = d[\\max(0, n-1)]$。\n  - 右邻居 $d_{right}$ 在索引 $n$ 处找到。如果 $n \\ge N_o$，最近的有效索引是 $N_o-1$。所以，$d_{right} = d[\\min(n, N_o-1)]$。\n\n**2. 逆变换**\n\n逆变换通过反转正向步骤，从系数 $(a, d)$ 重构原始信号 $\\hat{x}$。\n\n**a. 逆更新步骤**\n首先，我们反转更新步骤以恢复原始的偶数样本，我们将其表示为 $s_{rec}$。这是通过减法实现的：\n$$ s_{rec}[n] = a[n] - \\left\\lfloor \\frac{d_{left} + d_{right} + 2}{4} \\right\\rfloor $$\n$d_{left}$ 和 $d_{right}$ 的边界处理与正向更新步骤中的相同。此操作对从 $0$ 到 $N_s-1$ 的每个 $n$ 执行。\n\n**b. 逆预测步骤**\n接下来，我们反转预测步骤以恢复原始的奇数样本 $o_{rec}$。这是通过加法实现的：\n$$ o_{rec}[n] = d[n] + \\left\\lfloor \\frac{s_{rec, left} + s_{rec, right}}{2} \\right\\rfloor $$\n此操作使用刚恢复的偶数样本 $s_{rec}$。来自 $s_{rec}$ 的邻居的边界处理与正向预测步骤中的相同。此操作对从 $0$ 到 $N_o-1$ 的每个 $n$ 执行。\n\n**c. 合并**\n最后，通过交错恢复的偶数和奇数样本来形成重构信号 $\\hat{x}$：\n$$ \\hat{x}[2n] = s_{rec}[n] $$\n$$ \\hat{x}[2n+1] = o_{rec}[n] $$\n\n**3. 验证**\n通过检查原始信号 $x$ 和重构信号 $\\hat{x}$ 之间的逐元素相等性来验证完美重构属性。对于每个测试用例，结果是一个布尔值，指示 $x = \\hat{x}$ 是否成立。因为整数算术被设计为完全可逆的，所以此检查验证了实现的正确性。所有测试用例预计都会产生 `True` 结果。", "answer": "```python\nimport numpy as np\n\ndef forward_lg53(x_in):\n    \"\"\"\n    Computes the forward Le Gall 5/3 integer wavelet transform using the lifting scheme.\n    \"\"\"\n    x = np.array(x_in, dtype=np.int64)\n    N = len(x)\n\n    if N == 0:\n        return np.array([], dtype=np.int64), np.array([], dtype=np.int64)\n\n    # Split the signal into even and odd samples\n    s = x[0::2]\n    o = x[1::2]\n    Ns = len(s)\n    No = len(o)\n\n    # 1. Predict step (odd samples update)\n    # d[n] = o[n] - floor((s[n] + s[n+1]) / 2)\n    d = np.zeros(No, dtype=np.int64)\n    for n in range(No):\n        s_left = s[n]\n        # Boundary handling for the right neighbor\n        s_right_idx = min(n + 1, Ns - 1)\n        s_right = s[s_right_idx]\n        d[n] = o[n] - (s_left + s_right) // 2\n\n    # 2. Update step (even samples update)\n    # a[n] = s[n] + floor((d[n-1] + d[n] + 2) / 4)\n    a = np.zeros(Ns, dtype=np.int64)\n    if No == 0:  # This handles the N=1 case where d is empty\n        a = s.copy()\n    else:\n        for n in range(Ns):\n            # Boundary handling for detail coefficient neighbors\n            d_left_idx = max(0, n - 1)\n            d_right_idx = min(n, No - 1)\n            d_left = d[d_left_idx]\n            d_right = d[d_right_idx]\n            a[n] = s[n] + (d_left + d_right + 2) // 4\n            \n    return a, d\n\ndef inverse_lg53(a, d):\n    \"\"\"\n    Computes the inverse Le Gall 5/3 integer wavelet transform.\n    \"\"\"\n    a = np.array(a, dtype=np.int64)\n    d = np.array(d, dtype=np.int64)\n    Ns = len(a)\n    No = len(d)\n    N = Ns + No\n\n    if N == 0:\n        return np.array([], dtype=np.int64)\n\n    # 1. Inverse Update step (recover s)\n    # s_rec[n] = a[n] - floor((d[n-1] + d[n] + 2) / 4)\n    s_rec = np.zeros(Ns, dtype=np.int64)\n    if No == 0: # Handles N=1 case\n        s_rec = a.copy()\n    else:\n        for n in range(Ns):\n            d_left_idx = max(0, n - 1)\n            d_right_idx = min(n, No - 1)\n            d_left = d[d_left_idx]\n            d_right = d[d_right_idx]\n            s_rec[n] = a[n] - (d_left + d_right + 2) // 4\n\n    # 2. Inverse Predict step (recover o)\n    # o_rec[n] = d[n] + floor((s_rec[n] + s_rec[n+1]) / 2)\n    o_rec = np.zeros(No, dtype=np.int64)\n    for n in range(No):\n        s_left = s_rec[n]\n        s_right_idx = min(n + 1, Ns - 1)\n        s_right = s_rec[s_right_idx]\n        o_rec[n] = d[n] + (s_left + s_right) // 2\n\n    # Merge the recovered even and odd samples\n    x_rec = np.zeros(N, dtype=np.int64)\n    x_rec[0::2] = s_rec\n    x_rec[1::2] = o_rec\n\n    return x_rec\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and verify perfect reconstruction.\n    \"\"\"\n    test_cases = [\n        # Case 1: mixed signs, odd length\n        [7, -3, 2, 9, -8, 1, 0],\n        # Case 2: short, even length\n        [-3, 7],\n        # Case 3: singleton\n        [42],\n        # Case 4: constant\n        [5, 5, 5, 5, 5],\n        # Case 5: alternating large magnitudes\n        [1000, -1000, 1000, -1000, 999, -999],\n        # Case 6: zeros and negatives, odd length\n        [0, -1, 0, -1, 0],\n    ]\n\n    results = []\n    for case in test_cases:\n        # Convert to numpy array with a safe integer type\n        x_original = np.array(case, dtype=np.int64)\n\n        # Perform forward transform\n        approximation_coeffs, detail_coeffs = forward_lg53(x_original)\n\n        # Perform inverse transform\n        x_reconstructed = inverse_lg53(approximation_coeffs, detail_coeffs)\n\n        # Verify perfect reconstruction\n        is_perfect = np.array_equal(x_original, x_reconstructed)\n        results.append(is_perfect)\n\n    # Format the output as specified\n    # The boolean values are capitalized in Python, so they are converted to lowercase\n    # for full compliance with the example format \"[True,False,True]\".\n    # However, Python's str(True) is 'True', which is standard. Example format\n    # is illustrative. We will use standard string conversion.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2916322"}]}