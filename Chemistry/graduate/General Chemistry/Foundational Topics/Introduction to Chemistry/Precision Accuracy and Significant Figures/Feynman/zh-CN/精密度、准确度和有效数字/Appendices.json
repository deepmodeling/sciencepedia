{
    "hands_on_practices": [
        {
            "introduction": "在化学研究中，我们经常通过组合多个独立测量的量来计算最终结果，例如平衡常数 $K$。每个原始测量值都带有其自身的不确定性，而这些不确定性会如何传递并影响最终计算值的精度，是实验数据处理中的一个核心问题。本练习旨在通过一个典型的化学平衡场景，让您动手实践不确定性传播的基本法则，从而精确地量化派生量的置信区间。",
            "id": "2952265",
            "problem": "在恒温下，某溶质在水溶液中的可逆二聚反应通过分光光度法进行监测，$$2\\,\\mathrm{R} \\rightleftharpoons \\mathrm{P},$$ 其以摩尔浓度表示的平衡常数定义为 $$K = \\frac{c_{\\mathrm{P}}}{\\left(c_{\\mathrm{R}}\\right)^{2}},$$ 其中 $c_{\\mathrm{P}}$ 和 $c_{\\mathrm{R}}$ 分别表示产物和反应物的平衡摩尔浓度。浓度 $c_{\\mathrm{P}}$ 是通过单波长 Beer–Lambert 法从校准后的吸光度中获得的，而 $c_{\\mathrm{R}}$ 是通过另外的多波长拟合获得的；这两次测定在统计上是独立的。将报告的不确定度视为仅由随机效应引起的相对标准不确定度（一个标准差），并假设不确定度足够小，以致一阶线性化有效。相对标准不确定度为 $$u_{r}\\!\\left(c_{\\mathrm{P}}\\right)=5\\% \\quad\\text{and}\\quad u_{r}\\!\\left(c_{\\mathrm{R}}\\right)=2\\%,$$ 此处，根据定义，$$u_{r}(x)=\\frac{u(x)}{x}$$ 且 $u(x)$ 是 $x$ 的标准不确定度。在这些条件下，计算 $K$ 的相对标准不确定度，记为 $u_{r}(K)$。将您的最终答案四舍五入至 $3$ 位有效数字，并以纯小数形式表示（不带百分号）。最终答案必须是单个实数。",
            "solution": "经审慎核查，该问题陈述在科学上是合理的，表述清晰，且无矛盾或歧义之处。其前提条件在物理上是现实的，并为得出唯一解提供了所有必要信息。此任务是计量学中不确定度传播原理的标准应用，这是实验科学中的一个基本概念。因此，我们着手进行求解。\n\n该问题要求根据推导平衡常数所用浓度的相对标准不确定度，计算平衡常数 $K$ 的相对标准不确定度 $u_r(K)$。平衡常数 $K$ 由以下函数定义：\n$$K = \\frac{c_{\\mathrm{P}}}{\\left(c_{\\mathrm{R}}\\right)^{2}}$$\n其中 $c_{\\mathrm{P}}$ 是产物的摩尔浓度，$c_{\\mathrm{R}}$ 是反应物的摩尔浓度。问题陈述指出 $c_{\\mathrm{P}}$ 和 $c_{\\mathrm{R}}$ 的测量在统计上是独立的。\n\n对于形式为 $Y = f(X_1, X_2, \\dots, X_n)$ 的通用函数，其中输入量 $X_i$ 是独立的，其合成标准不确定度的平方 $u^2(Y)$ 由不确定度传播定律给出：\n$$u^2(Y) = \\sum_{i=1}^{n} \\left(\\frac{\\partial f}{\\partial X_i}\\right)^2 u^2(X_i)$$\n这可以用相对不确定度来表示。对于一个幂乘积形式的函数，例如 $Y = C X_1^{a_1} X_2^{a_2} \\cdots X_n^{a_n}$，其中 $C$ 是一个没有不确定度的常数，其相对标准不确定度的平方 $u_r^2(Y)$ 可简化为各独立相对标准不确定度平方的加权和：\n$$u_r^2(Y) = \\left(\\frac{u(Y)}{Y}\\right)^2 = \\sum_{i=1}^{n} a_i^2 \\left(\\frac{u(X_i)}{X_i}\\right)^2 = \\sum_{i=1}^{n} a_i^2 u_r^2(X_i)$$\n平衡常数就是这种形式，可以写成 $K = c_{\\mathrm{P}}^{1} c_{\\mathrm{R}}^{-2}$。变量为 $c_{\\mathrm{P}}$ 和 $c_{\\mathrm{R}}$，对应的指数为 $a_{\\mathrm{P}} = 1$ 和 $a_{\\mathrm{R}} = -2$。\n\n应用相对不确定度传播的简化法则，$K$ 的相对标准不确定度的平方为：\n$$u_r^2(K) = (a_{\\mathrm{P}})^2 u_r^2(c_{\\mathrm{P}}) + (a_{\\mathrm{R}})^2 u_r^2(c_{\\mathrm{R}})$$\n代入指数 $a_{\\mathrm{P}} = 1$ 和 $a_{\\mathrm{R}} = -2$：\n$$u_r^2(K) = (1)^2 u_r^2(c_{\\mathrm{P}}) + (-2)^2 u_r^2(c_{\\mathrm{R}})$$\n$$u_r^2(K) = u_r^2(c_{\\mathrm{P}}) + 4 u_r^2(c_{\\mathrm{R}})$$\n问题给出了以下相对标准不确定度：\n$$u_{r}(c_{\\mathrm{P}}) = 5\\% = 0.05$$\n$$u_{r}(c_{\\mathrm{R}}) = 2\\% = 0.02$$\n我们将这些数值代入推导出的方程中：\n$$u_r^2(K) = (0.05)^2 + 4(0.02)^2$$\n计算过程如下：\n$$u_r^2(K) = 0.0025 + 4(0.0004)$$\n$$u_r^2(K) = 0.0025 + 0.0016$$\n$$u_r^2(K) = 0.0041$$\n为了求得相对标准不确定度 $u_r(K)$，我们对该值取平方根：\n$$u_r(K) = \\sqrt{0.0041}$$\n$$u_r(K) \\approx 0.06403124237$$\n题目要求最终答案四舍五入到 $3$ 位有效数字。第一个非零数字是 $6$，所以三位有效数字是 $6$、$4$ 和 $0$。\n$$u_r(K) = 0.0640$$\n这就是以纯小数表示的最终数值答案。",
            "answer": "$$\\boxed{0.0640}$$"
        },
        {
            "introduction": "科学计算的严谨性不仅体现在公式的正确应用上，更体现在计算过程的每一步骤中。一个常见的、看似无害的习惯——过早地对中间结果进行四舍五入——有时会引入严重的系统偏差，甚至导致错误的科学结论。本练习通过一个精心设计的近化学计量反应场景，生动地揭示了这一“陷阱”的危害，您将亲眼见证过早取整如何颠倒了反应中极限试剂的判定。",
            "id": "2952416",
            "problem": "通过将一氧化氮和氧气混合进行气相氧化反应，其配平的化学方程式为\n$$2\\,\\mathrm{NO}(g)+\\mathrm{O_2}(g)\\longrightarrow 2\\,\\mathrm{NO_2}(g)。$$\n一位化学家通过称量 $m_{\\mathrm{NO}}=30.15603\\ \\mathrm{g}$ 的一氧化氮和 $m_{\\mathrm{O_2}}=16.080595\\ \\mathrm{g}$ 的氧气，制备了接近化学计量比的反应物。在所有计算中使用以下摩尔质量：$M_{\\mathrm{NO}}=30.006\\ \\mathrm{g\\ mol^{-1}}$ 和 $M_{\\mathrm{O_2}}=31.998\\ \\mathrm{g\\ mol^{-1}}$。假设没有副反应，且限量反应物完全消耗。\n\n从作为化学计量基础的基本原子守恒定律出发，并遵循有效数字的运算规则，即中间量应保留额外位数，只对最终报告的量进行舍入，请按以下步骤进行：\n\n1. 采用最佳实践（使用给定数据的全部可用精度，不对中间的摩尔数进行舍入），通过从未舍入的摩尔数中正确确定限量反应物，来计算生成的二氧化氮的理论量 $n_{\\mathrm{NO_2,correct}}$（单位为 $\\mathrm{mol}$）。\n2. 采用一种为说明陷阱而故意设计的不当做法：在进行任何比较之前，首先将每种反应物计算出的初始摩尔量舍入到恰好 $3$ 位有效数字，然后根据这些舍入后的摩尔数确定限量反应物，并计算相应的预测产物量 $n_{\\mathrm{NO_2,wrong}}$（单位为 $\\mathrm{mol}$）。\n3. 计算由过早舍入引入的相对差异的大小，\n$$\\delta=\\left|\\frac{n_{\\mathrm{NO_2,wrong}}-n_{\\mathrm{NO_2,correct}}}{n_{\\mathrm{NO_2,correct}}}\\right|.$$\n\n将最终量 $\\delta$ 表示为无量纲小数。将最终答案舍入至四位有效数字。",
            "solution": "出发点是配平的方程式中所蕴含的原子守恒定律。对于一个初始摩尔量为 $n_{\\mathrm{A}}^{0}$ 和 $n_{\\mathrm{B}}^{0}$ 的一般反应 $\\nu_{\\mathrm{A}}\\mathrm{A}+\\nu_{\\mathrm{B}}\\mathrm{B}\\rightarrow \\nu_{\\mathrm{P}}\\mathrm{P}$，其可达到的反应进度 $\\xi$ 受化学计量的限制，即\n$$\\xi=\\min\\!\\left(\\frac{n_{\\mathrm{A}}^{0}}{\\nu_{\\mathrm{A}}},\\frac{n_{\\mathrm{B}}^{0}}{\\nu_{\\mathrm{B}}}\\right),\\quad n_{\\mathrm{P}}=\\nu_{\\mathrm{P}}\\xi,$$\n这反映了产物的量受限于化学计量比例较小的那种反应物。对于本例，\n$$2\\,\\mathrm{NO}+\\mathrm{O_2}\\rightarrow 2\\,\\mathrm{NO_2},$$\n因此 $\\nu_{\\mathrm{NO}}=2$，$\\nu_{\\mathrm{O_2}}=1$，且 $\\nu_{\\mathrm{NO_2}}=2$。有效数字的运算规则是，在中间步骤中保留所有可用数字，仅对最终报告的量进行舍入，以避免因过早舍入而引入人为偏差。\n\n步骤 $1$（最佳实践，不过早舍入）：\n- 根据给定的质量和摩尔质量计算初始摩尔量：\n$$n_{\\mathrm{NO}}=\\frac{m_{\\mathrm{NO}}}{M_{\\mathrm{NO}}}=\\frac{30.15603\\ \\mathrm{g}}{30.006\\ \\mathrm{g\\ mol^{-1}}}.$$\n由于该数值是特意构造的，在所示精度下有 $30.15603=30.006\\times 1.00500$，所以计算结果为\n$$n_{\\mathrm{NO}}=1.00500\\ \\mathrm{mol}.$$\n类似地，\n$$n_{\\mathrm{O_2}}=\\frac{m_{\\mathrm{O_2}}}{M_{\\mathrm{O_2}}}=\\frac{16.080595\\ \\mathrm{g}}{31.998\\ \\mathrm{g\\ mol^{-1}}}\\approx 0.50255\\ \\mathrm{mol},$$\n因为 $31.998\\times 0.50255=16.0805949\\ \\mathrm{g}$，这与 $16.080595\\ \\mathrm{g}$ 的最后一位显示数字相符。\n- 比较化学计量需求：\n$$2\\,n_{\\mathrm{O_2}}=2\\times 0.50255=1.00510\\ \\mathrm{mol\\ NO\\ equivalents}.$$\n我们发现 $n_{\\mathrm{NO}}=1.00500<2\\,n_{\\mathrm{O_2}}=1.00510$，因此在使用未舍入的摩尔数计算时，一氧化氮是（极其微弱的）限量反应物。\n- 因此，理论上生成的二氧化氮的摩尔数等于消耗的一氧化氮的摩尔数，即\n$$n_{\\mathrm{NO_2,correct}}=n_{\\mathrm{NO}}=1.00500\\ \\mathrm{mol}.$$\n\n步骤 $2$（不当实践：在确定限量反应物前，过早舍入到 3 位有效数字）：\n- 首先将每种反应物的初始摩尔量舍入到恰好 3 位有效数字：\n$$n_{\\mathrm{NO,\\ rounded}}=\\text{round}_{3\\ \\mathrm{sf}}(1.00500\\ \\mathrm{mol})=1.01\\ \\mathrm{mol},$$\n$$n_{\\mathrm{O_2,\\ rounded}}=\\text{round}_{3\\ \\mathrm{sf}}(0.50255\\ \\mathrm{mol})=0.503\\ \\mathrm{mol}.$$\n- 基于这些舍入后的量进行比较：\n$$2\\,n_{\\mathrm{O_2,\\ rounded}}=2\\times 0.503=1.006\\ \\mathrm{mol}.$$\n因为 $1.006<1.01$，舍入后的数据会错误地指出氧气是限量反应物。\n- 因此，在这种不当操作下，预测的产物量为\n$$n_{\\mathrm{NO_2,wrong}}=2\\,n_{\\mathrm{O_2,\\ rounded}}=1.006\\ \\mathrm{mol}.$$\n\n步骤 $3$（量化过早舍入引入的差异）：\n- 计算相对差异的大小\n$$\\delta=\\left|\\frac{n_{\\mathrm{NO_2,wrong}}-n_{\\mathrm{NO_2,correct}}}{n_{\\mathrm{NO_2,correct}}}\\right|=\\left|\\frac{1.006-1.00500}{1.00500}\\right|=\\frac{0.00100}{1.00500}.$$\n- 按要求进行数值计算，并将最终结果舍入至四位有效数字：\n$$\\delta\\approx 9.950248756\\times 10^{-4}\\ \\longrightarrow\\ \\delta=9.950\\times 10^{-4}.$$\n写成小数形式，\n$$\\delta=0.0009950,$$\n它有四位有效数字。\n\n这个计算表明，在一个几乎完全符合化学计量比的混合物中，过早舍入会改变限量反应物的判断，并导致预测产率产生数量级为 $10^{-3}$ 的偏差，这个偏差远超舍入单位本身，从而说明了为什么必须将额外位数保留到计算的最后一步。",
            "answer": "$$\\boxed{0.0009950}$$"
        },
        {
            "introduction": "虽然解析方法在处理简单函数的不确定性传播时非常有效，但当面对复杂的模型或非标准的数据分布（如物理约束导致的截断数据）时，它们往往力不从心。本练习将引导您进入现代计算统计学的领域，学习使用蒙特卡洛（Monte Carlo）模拟这一强大工具来处理这类复杂问题。通过模拟一个有物理下限（吸光度 $A \\ge 0$）的测量过程，您将学习如何正确地为受限数据建模，并直观地比较其与理想化（无截断）模型在结果上的差异。",
            "id": "2952283",
            "problem": "您正在为普通化学中的一种基于光谱的浓度测定法进行测量和报告建模，该模型带有一个具有物理意义的截尾约束。检测器返回一个经过基线校正的吸光度 $A$，根据吸收物理学和校准流程，该值必须满足 $A \\ge 0$。截尾前的噪声可以用一个均值为 $\\mu_A$、标准差为 $\\sigma_A$ 的正态分布来建模，这是许多仪器噪声源广泛接受的经验模型。分析物浓度 $c$ 与吸光度通过遵循比尔-朗伯定律的线性校准关系相关联：$c = A / (\\varepsilon \\, \\ell)$，其中 $\\varepsilon$ 是摩尔吸光系数，$\\ell$ 是光程长度。您将演示蒙特卡洛传播如何通过从正确的截断分布中抽样，直接处理 $A \\ge 0$ 的截尾情况，并且您将展示与非截尾模型相比，截尾如何影响 $c$ 的均值和中心 $95\\%$ 置信区间。\n\n您可以使用的基本原理：大数定律、期望值和分位数的定义、正态分布的性质以及比尔-朗伯定律。不要使用任何截断正态矩的闭式公式。您必须通过蒙特卡洛抽样进行近似。\n\n使用的定义：\n- 随机变量 $Z$ 的期望值是 $\\mathbb{E}[Z]$。\n- $Z$ 样本的中心 $95\\%$ 置信区间是位于概率 $0.025$ 和 $0.975$ 的经验分位数之间的区间。\n- 对于 $A$ 的截尾（截断）正态分布，通过从正态分布中抽样并拒绝 $A < 0$ 的值来强制执行 $A \\ge 0$；在编程上，您必须直接从截断分布中抽样以避免效率低下。\n- 关于有效数字的报告规则，令 $m$ 为 $c$ 均值的蒙特卡洛估计值，令 $L$ 和 $U$ 为中心 $95\\%$ 置信区间的下界和上界。定义半宽 $h = (U - L)/2$。为了创建符合普通化学中常见不确定度报告实践的报告，将 $h$ 四舍五入到一位有效数字，然后将 $m$ 四舍五入到与舍入后的 $h$ 相同的小数位。然后，将舍入后的区间报告为 $[m - h_{\\mathrm{rounded}}, \\, m + h_{\\mathrm{rounded}}]$。这将产生与不确定度相关的有效数字规则一致的值。所有浓度必须以 $\\mathrm{mol}\\,\\mathrm{L}^{-1}$ 表示。\n\n您的程序必须对每个测试用例，使用相同的抽样次数 $N$ 执行以下两种蒙特卡洛传播：\n- 非截尾模型：在不强制执行 $A \\ge 0$ 的情况下，从 $\\mathcal{N}(\\mu_A, \\sigma_A^2)$ 中抽样 $A_{\\mathrm{unc}}$。\n- 截尾模型：从截断到 $A \\ge 0$ 的 $\\mathcal{N}(\\mu_A, \\sigma_A^2)$ 中抽样 $A_{\\mathrm{cen}}$。\n\n然后通过 $c = A/(\\varepsilon \\, \\ell)$ 转换为浓度，以获得样本 $c_{\\mathrm{unc}}$ 和 $c_{\\mathrm{cen}}$。对每个模型，计算样本均值 $m$、中心 $95\\%$ 置信区间 $[L, U]$、半宽 $h = (U-L)/2$，然后根据上述定义生成舍入后的三元组 $(m_{\\mathrm{rounded}}, L_{\\mathrm{rounded}}, U_{\\mathrm{rounded}})$。\n\n物理单位：\n- 报告和内部计算时，$c$ 的单位为 $\\mathrm{mol}\\,\\mathrm{L}^{-1}$，$\\varepsilon$ 的单位为 $\\mathrm{L}\\,\\mathrm{mol}^{-1}\\,\\mathrm{cm}^{-1}$，$\\ell$ 的单位为 $\\mathrm{cm}$，$A$ 无单位。您的最终程序输出必须是代表 $\\mathrm{mol}\\,\\mathrm{L}^{-1}$ 的浮点数；不要打印单位。\n\n角度单位不适用。\n\n测试套件：\n每个测试用例使用 $N = 200{,}000$ 次抽样，并使用以下参数集来检验不同的情况。每个用例是一个元组 $(\\mu_A, \\sigma_A, \\varepsilon, \\ell)$。\n- 用例 $1$（远高于截尾阈值；截尾影响可忽略不计）：$(\\mu_A = 0.500, \\ \\sigma_A = 0.010, \\ \\varepsilon = 12500, \\ \\ell = 1.00)$。\n- 用例 $2$（接近阈值；截尾导致中度偏斜）：$(\\mu_A = 0.050, \\ \\sigma_A = 0.050, \\ \\varepsilon = 12500, \\ \\ell = 1.00)$。\n- 用例 $3$（接近零；截尾效应强）：$(\\mu_A = 0.005, \\ \\sigma_A = 0.010, \\ \\varepsilon = 12500, \\ \\ell = 1.00)$。\n- 用例 $4$（负均值；物理约束占主导地位）：$(\\mu_A = -0.002, \\ \\sigma_A = 0.005, \\ \\varepsilon = 12500, \\ \\ell = 1.00)$。\n\n答案规格：\n- 对每个测试用例，计算两个舍入后的三元组 $(m_{\\mathrm{unc}}, L_{\\mathrm{unc}}, U_{\\mathrm{unc}})$ 和 $(m_{\\mathrm{cen}}, L_{\\mathrm{cen}}, U_{\\mathrm{cen}})$，单位均为 $\\mathrm{mol}\\,\\mathrm{L}^{-1}$，并根据上述有效数字规则进行舍入。\n- 将每个测试用例的结果汇总为一个包含六个浮点数的列表，顺序为：$[m_{\\mathrm{unc}}, L_{\\mathrm{unc}}, U_{\\mathrm{unc}}, m_{\\mathrm{cen}}, L_{\\mathrm{cen}}, U_{\\mathrm{cen}}]$。\n- 最终输出格式：您的程序应生成单行输出，其中包含一个由四个按序排列的用例列表组成的列表。例如，外部结构必须类似 $[[\\dots],[\\dots],[\\dots],[\\dots]]$，其中包含数值浮点数。\n\n科学真实性：\n- 使用固定的随机种子以确保结果可复现。\n- 不要假设截断矩有任何闭式形式；通过抽样进行近似。\n- 确保通过从截断正态分布中抽样来实现截尾。\n\n您的程序必须只产生指定的单行输出，不得包含其他任何内容。所有数值答案均代表以 $\\mathrm{mol}\\,\\mathrm{L}^{-1}$ 为单位的浓度，并根据所述的有效数字规则进行舍入。",
            "solution": "所提出的问题要求在一个常见的分析化学场景中，对一个具有物理动机的截尾约束进行定量分析。我们需要比较一个理想化的、非截尾的测量模型与一个更现实的、截尾的模型，在后一个模型中，物理量吸光度不能为负。此比较将使用蒙特卡洛不确定度传播方法进行。如上所述，该问题在科学上是合理的、适定的，并为严谨的计算解决方案提供了所有必要信息。下面我们着手进行分析。\n\n问题的核心在于将带有噪声的吸光度测量值 $A$ 的不确定度传播到推导出的浓度 $c$。这些量之间的关系由比尔-朗伯定律给出：\n$$ c = \\frac{A}{\\varepsilon \\ell} $$\n其中 $\\varepsilon$ 是摩尔吸光系数，$\\ell$ 是光程长度。为方便起见，我们为每个实验设置定义一个常数 $k = \\varepsilon \\ell$，因此 $c = A/k$。\n\n问题为吸光度测量值 $A$ 指定了两种模型：\n\n1.  **非截尾模型**：这是一个理想化模型，其中测量噪声被假定为完全高斯分布。我们通过从正态分布 $A_{\\mathrm{unc}} \\sim \\mathcal{N}(\\mu_A, \\sigma_A^2)$ 中抽样，生成大量的（$N$个）吸光度样本 $\\{A_{\\mathrm{unc}, i}\\}_{i=1}^N$。该模型可能产生不符合物理意义的负吸光度值。\n\n2.  **截尾模型**：该模型包含了吸光度不能为负的物理约束，即 $A \\ge 0$。我们通过从相同的正态分布 $\\mathcal{N}(\\mu_A, \\sigma_A^2)$ 中抽样生成 $N$ 个样本 $\\{A_{\\mathrm{cen}, i}\\}_{i=1}^N$，但将其截断到区间 $[0, \\infty)$。这是一个从根本上为非负的测量过程的正确统计表示。在编程上，这是通过从截断正态分布中抽样来实现的，这种方法比简单的拒绝/接受循环更有效率。\n\n对于两种模型，每个吸光度样本 $A_i$ 都通过 $c_i = A_i/k$ 转换为一个浓度样本。这样就得到了两组浓度样本 $\\{c_{\\mathrm{unc}, i}\\}$ 和 $\\{c_{\\mathrm{cen}, i}\\}$。\n\n基于这些样本，我们按照规定执行统计分析。对于每组样本：\n- 平均浓度 $m$ 通过样本均值来估计：$m \\approx \\frac{1}{N} \\sum_{i=1}^{N} c_i$。\n- 中心 $95\\%$ 置信区间 $[L, U]$ 由浓度样本在概率 $p=0.025$ 和 $p=0.975$ 处的经验分位数确定。\n- 根据指定的舍入程序构建一个便于报告的区间。计算置信区间的半宽 $h = (U - L)/2$，并将其舍入到一位有效数字得到 $h_{\\mathrm{rounded}}$。然后将均值 $m$ 舍入到与 $h_{\\mathrm{rounded}}$ 相同的小数位，得到 $m_{\\mathrm{rounded}}$。最终报告的区间是 $[m_{\\mathrm{rounded}} - h_{\\mathrm{rounded}}, m_{\\mathrm{rounded}} + h_{\\mathrm{rounded}}]$，报告的三元组是 $(m_{\\mathrm{rounded}}, L_{\\mathrm{rounded}}, U_{\\mathrm{rounded}})$。\n\n实现代码使用 `numpy` 进行数组操作和随机数生成，使用 `scipy.stats.truncnorm` 从截断正态分布中进行高效抽样。`truncnorm` 的参数是根据问题给出的 $\\mu_A$、$\\sigma_A$ 以及下截断边界 $a=0$ 推导出来的。相应的标准化下界是 $\\alpha = (a - \\mu_A) / \\sigma_A = -\\mu_A / \\sigma_A$，而上界是 $\\beta = \\infty$。固定的随机种子确保了蒙特卡洛模拟的可复现性。\n\n所选的测试用例将说明截尾的不同影响：\n- **用例 1 ($\\mu_A = 0.500, \\sigma_A = 0.010$)**：此情况下 $\\mu_A \\gg \\sigma_A$，因此 $A<0$ 的概率可以忽略不计。截尾和非截尾的结果应该几乎相同。\n- **用例 2 ($\\mu_A = 0.050, \\sigma_A = 0.050$)**：此情况下 $\\mu_A = \\sigma_A$，非截尾分布中有相当一部分是负值。截尾会切掉这部分尾部，导致更高的平均浓度和右偏分布。\n- **用例 3 ($\\mu_A = 0.005, \\sigma_A = 0.010$)**：此情况下 $\\mu_A < \\sigma_A$，截尾效应更加显著。截尾分布的均值将显著地移向一个正值，与母正态分布相比，其分布将高度扭曲。\n- **用例 4 ($\\mu_A = -0.002, \\sigma_A = 0.005$)**：真实的平均吸光度是负值，这种情况可能由于基线过度校正而发生。非截尾模型会得出一个不符合物理意义的负平均浓度。而截尾模型正确地反映了物理现实，只产生非负的吸光度，从而得到一个有物理意义的正平均浓度。这个用例凸显了正确进行物理建模的至关重要性。",
            "answer": "```python\nimport numpy as np\nfrom scipy.stats import truncnorm\nimport math\n\ndef calculate_and_round(c_samples):\n    \"\"\"\n    Calculates the mean, 95% credible interval, and rounded reporting values.\n    \"\"\"\n    m = np.mean(c_samples)\n    L, U = np.quantile(c_samples, [0.025, 0.975])\n    h = (U - L) / 2.0\n\n    if h <= 0:\n        # This case is not expected with N=200,000 but handled for robustness.\n        # If uncertainty is zero or negative, no rounding rule is applicable.\n        return m, m, m\n\n    # Round h to one significant figure\n    power_h = math.floor(math.log10(h))\n    factor_h = 10**power_h\n    h_rounded = round(h / factor_h) * factor_h\n\n    # Round m to the same decimal place as h_rounded\n    # The 'decimal place' is determined by the magnitude of h_rounded\n    if h_rounded == 0:\n        # This should not happen if h > 0 because 1 <= h/factor_h < 10,\n        # so round(h/factor_h) >= 1. Safeguard is for theoretical robustness.\n        m_rounded = m\n    else:\n        power_m_round = math.floor(math.log10(h_rounded))\n        factor_m = 10**power_m_round\n        m_rounded = round(m / factor_m) * factor_m\n\n    L_rounded = m_rounded - h_rounded\n    U_rounded = m_rounded + h_rounded\n    \n    return m_rounded, L_rounded, U_rounded\n\ndef solve():\n    \"\"\"\n    Main solver function to run simulations and print results.\n    \"\"\"\n    # Set a fixed random seed for reproducibility.\n    np.random.seed(0)\n    \n    # Number of Monte Carlo draws\n    N = 200000\n\n    # Test suite: tuples of (mu_A, sigma_A, epsilon, ell)\n    test_cases = [\n        (0.500, 0.010, 12500, 1.00),\n        (0.050, 0.050, 12500, 1.00),\n        (0.005, 0.010, 12500, 1.00),\n        (-0.002, 0.005, 12500, 1.00),\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        mu_A, sigma_A, epsilon, ell = case\n        k = epsilon * ell\n\n        # Uncensored model\n        A_unc = np.random.normal(loc=mu_A, scale=sigma_A, size=N)\n        c_unc = A_unc / k\n        unc_triple = calculate_and_round(c_unc)\n\n        # Censored model\n        a_std = (0 - mu_A) / sigma_A\n        b_std = np.inf\n        A_cen = truncnorm.rvs(a=a_std, b=b_std, loc=mu_A, scale=sigma_A, size=N)\n        c_cen = A_cen / k\n        cen_triple = calculate_and_round(c_cen)\n\n        # Aggregate results for this case\n        case_results = [*unc_triple, *cen_triple]\n        all_results.append(case_results)\n\n    # Format the final output string as a list of lists.\n    # Using repr() for canonical string representation of floats.\n    output_parts = []\n    for res_list in all_results:\n        output_parts.append(f\"[{','.join(map(repr, res_list))}]\")\n    final_output = f\"[{','.join(output_parts)}]\"\n    \n    print(final_output)\n\nsolve()\n```"
        }
    ]
}