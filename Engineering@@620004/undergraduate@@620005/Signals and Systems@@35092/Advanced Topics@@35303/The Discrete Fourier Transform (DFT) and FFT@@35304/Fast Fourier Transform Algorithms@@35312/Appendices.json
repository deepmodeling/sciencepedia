{"hands_on_practices": [{"introduction": "The Fast Fourier Transform isn't just a single algorithm, but a family of them that brilliantly exploit the symmetries of the Discrete Fourier Transform. This first exercise takes you under the hood of the classic radix-2 Decimation-In-Time (DIT) FFT. Before the main 'butterfly' computations can begin, the input data must be reordered in a specific way, and this practice [@problem_id:1717784] has you perform this crucial 'bit-reversal' permutation, a foundational step for many efficient in-place FFT implementations.", "problem": "An embedded systems engineer is tasked with implementing a real-time audio spectrum analyzer on a microcontroller with limited memory. To achieve this, the engineer decides to use the radix-2 Decimation-In-Time (DIT) Fast Fourier Transform (FFT) algorithm. The first crucial step of this algorithm involves re-ordering the input time-domain samples before the main butterfly computations begin. This re-ordering is accomplished by placing the sample from index $n$ of the original sequence, $x[n]$, into a new position, index $k$, in the scrambled sequence. The new index $k$ is found by reversing the binary representation of the original index $n$.\n\nConsider a discrete-time signal that has been sampled to produce an $N=8$ point sequence, denoted as $x[n]$ for $n=0, 1, 2, ..., 7$. According to the DIT-FFT's bit-reversal procedure, the sample $x[6]$ will be moved to a new index in the re-ordered input buffer. What is the numerical value of this new index?", "solution": "In a radix-2 DIT-FFT with sequence length $N=2^{m}$, the bit-reversal re-ordering maps an index $n$ to $k$ by reversing the $m$-bit binary representation of $n$. Formally, if $n=\\sum_{i=0}^{m-1} b_{i} 2^{i}$ with $b_{i}\\in\\{0,1\\}$, then the bit-reversed index is\n$$\nk=\\sum_{i=0}^{m-1} b_{i} 2^{m-1-i}.\n$$\nFor $N=8$, we have $m=\\log_{2}(8)=3$. The index $n=6$ has the 3-bit binary representation\n$$\n6=1\\cdot 2^{2}+1\\cdot 2^{1}+0\\cdot 2^{0}\\;\\Rightarrow\\;(110)_{2},\n$$\nso $b_{2}=1$, $b_{1}=1$, $b_{0}=0$. Reversing these three bits gives $(011)_{2}$, which in decimal is\n$$\nk=0\\cdot 2^{2}+1\\cdot 2^{1}+1\\cdot 2^{0}=3.\n$$\nTherefore, under the DIT-FFT bit-reversal re-ordering for $N=8$, the sample $x[6]$ is moved to index $k=3$.", "answer": "$$\\boxed{3}$$", "id": "1717784"}, {"introduction": "Moving from the internal mechanics of the FFT to its real-world application, we encounter the challenge of analyzing finite data records. In practice, we can only ever observe a signal for a limited duration, which mathematically acts like multiplying the true signal by a window function. This exercise [@problem_id:1717762] explores the unavoidable consequence known as spectral leakage, where the energy of a pure sinusoid appears to 'leak' into adjacent frequency bins, and challenges you to quantify this effectâ€”a vital skill for interpreting any measured spectrum correctly.", "problem": "An engineer is analyzing a vibration signal from a large industrial motor. For this analysis, the signal is modeled as a pure sinusoid, $x(t) = \\cos(2\\pi f_c t)$, where the effects of amplitude and phase are ignored as they do not influence the final required ratio. The signal is sampled by an Analog-to-Digital Converter (ADC) at a sampling rate of $f_s = 8000 \\text{ Hz}$. A total of $N = 1024$ samples are collected and then processed using a Fast Fourier Transform (FFT) algorithm, which computes the Discrete Fourier Transform (DFT).\n\nThe true rotational frequency of the motor results in a vibration signal with a frequency of $f_c = 150.0 \\text{ Hz}$. Due to the finite sampling duration, this frequency does not coincide exactly with any of the frequency bins of the 1024-point FFT. As a result, the signal's energy appears spread across multiple frequency bins, a phenomenon known as spectral leakage.\n\nLet $X[k]$ be the complex-valued coefficient of the $k$-th frequency bin of the FFT, where $k$ is an integer from $0$ to $N-1$. Calculate the ratio of the magnitude of the FFT coefficient in the adjacent bin above the true frequency to the magnitude of the FFT coefficient in the adjacent bin below the true frequency. Specifically, determine the value of the ratio $|X[k_{above}]| / |X[k_{below}]|$ where $k_{below}$ and $k_{above}$ are the integer bin indices immediately below and above the true signal frequency $f_c$, respectively.\n\nExpress your answer as a single real number rounded to three significant figures.", "solution": "We sample the continuous-time sinusoid $x(t)=\\cos(2\\pi f_{c}t)$ to obtain the discrete-time sequence $x[n]=\\cos\\!\\left(2\\pi \\frac{f_{c}}{f_{s}}n\\right)$ for $n=0,\\ldots,N-1$. The $N$-point DFT is defined by\n$$\nX[k]=\\sum_{n=0}^{N-1}x[n]\\exp\\!\\left(-j\\frac{2\\pi kn}{N}\\right).\n$$\nUsing $x[n]=\\frac{1}{2}\\left(\\exp\\!\\left(j2\\pi \\frac{f_{c}}{f_{s}}n\\right)+\\exp\\!\\left(-j2\\pi \\frac{f_{c}}{f_{s}}n\\right)\\right)$ and linearity,\n$$\nX[k]=\\frac{1}{2}X_{+}[k]+\\frac{1}{2}X_{-}[k],\n$$\nwhere\n$$\nX_{+}[k]=\\sum_{n=0}^{N-1}\\exp\\!\\left(j2\\pi n\\left(\\frac{f_{c}}{f_{s}}-\\frac{k}{N}\\right)\\right),\\qquad\nX_{-}[k]=\\sum_{n=0}^{N-1}\\exp\\!\\left(-j2\\pi n\\left(\\frac{f_{c}}{f_{s}}+\\frac{k}{N}\\right)\\right).\n$$\nEach is a finite geometric series. Let $\\Delta=\\frac{f_{c}}{f_{s}}-\\frac{k}{N}$. Then\n$$\nX_{+}[k]=\\exp\\!\\left(j\\pi (N-1)\\Delta\\right)\\frac{\\sin(\\pi N\\Delta)}{\\sin(\\pi \\Delta)},\n$$\nso\n$$\n|X_{+}[k]|=\\frac{|\\sin(\\pi N\\Delta)|}{|\\sin(\\pi \\Delta)|}.\n$$\nDefine the bin location of the tone as $r=\\frac{Nf_{c}}{f_{s}}$ and the fractional offset $\\alpha=r-\\lfloor r\\rfloor\\in(0,1)$. The adjacent bins around $f_{c}$ are $k_{below}=\\lfloor r\\rfloor$ and $k_{above}=\\lfloor r\\rfloor+1$. Then\n$$\n\\Delta_{below}=\\frac{f_{c}}{f_{s}}-\\frac{k_{below}}{N}=\\frac{r}{N}-\\frac{\\lfloor r\\rfloor}{N}=\\frac{\\alpha}{N},\\qquad\n\\Delta_{above}=\\frac{f_{c}}{f_{s}}-\\frac{k_{above}}{N}=\\frac{\\alpha-1}{N}=-\\frac{1-\\alpha}{N}.\n$$\nThus, for the complex exponential component near $+f_{c}$,\n$$\n|X_{+}[k_{below}]|=\\frac{|\\sin(\\pi \\alpha)|}{|\\sin(\\pi \\alpha/N)|},\\qquad\n|X_{+}[k_{above}]|=\\frac{|\\sin(\\pi (1-\\alpha))|}{|\\sin(\\pi (1-\\alpha)/N)|}.\n$$\nUsing $|\\sin(\\pi \\alpha)|=|\\sin(\\pi (1-\\alpha))|$, the ratio governed by the main lobe is\n$$\nR\\equiv\\frac{|X[k_{above}]|}{|X[k_{below}]|}\\approx\\frac{|X_{+}[k_{above}]|}{|X_{+}[k_{below}]|}=\\frac{|\\sin(\\pi \\alpha/N)|}{|\\sin(\\pi (1-\\alpha)/N)|}.\n$$\nNow substitute the given parameters to find $\\alpha$. With $f_{s}=8000$, $N=1024$, and $f_{c}=150$,\n$$\nr=\\frac{Nf_{c}}{f_{s}}=\\frac{1024\\cdot 150}{8000}=19.2,\\qquad \\alpha=0.2.\n$$\nHence\n$$\nR=\\frac{\\sin\\!\\left(\\pi\\cdot \\frac{0.2}{1024}\\right)}{\\sin\\!\\left(\\pi\\cdot \\frac{0.8}{1024}\\right)}.\n$$\nBecause the arguments are small, using $\\sin(x)\\approx x$ gives\n$$\nR\\approx\\frac{\\pi\\cdot 0.2/1024}{\\pi\\cdot 0.8/1024}=\\frac{0.2}{0.8}=\\frac{1}{4}=0.25.\n$$\nRounded to three significant figures, the ratio is $0.250$.", "answer": "$$\\boxed{0.250}$$", "id": "1717762"}, {"introduction": "While library functions for the FFT are powerful tools, true mastery comes from understanding their connection to the fundamental definition of the Discrete Fourier Transform (DFT). This final practice bridges the gap between the abstract theory and the 'black box' of a canned FFT routine by having you build your own reference implementation from first principles. In this coding exercise [@problem_id:2391694], you will implement the DFT as a direct matrix-vector multiplication and use it to rigorously verify the correctness of a standard FFT library, solidifying your understanding of its core mathematical properties.", "problem": "You are to implement and use a reference discrete Fourier transform based on the linear algebraic definition to verify the correctness of a canned Fast Fourier Transform (FFT) implementation on small problem sizes. Start from the following foundational base:\n\n- The complex exponentials $e^{\\mathrm{i} 2 \\pi k n / N}$ form an orthogonal basis on the discrete grid $n \\in \\{0,1,\\dots,N-1\\}$ with respect to the discrete inner product, and they are $N$-periodic in $n$ and $k$.\n- The discrete Fourier transform is a linear change of basis between the standard basis in the time domain and the complex-exponential basis in the frequency domain.\n- The discrete-time signals are modeled as finite sequences of length $N$ with complex values, and angles are measured in radians.\n\nTasks:\n\n1) Implement a function that computes the discrete Fourier transform as a pure matrix-vector multiplication using an explicitly formed $N \\times N$ complex matrix. This must be the direct, quadratic-time method without any divide-and-conquer optimization. Denote the input vector by $x \\in \\mathbb{C}^N$ and the output by $X \\in \\mathbb{C}^N$. Choose the forward transform convention consistent with the default normalization of a standard library FFT: the forward transform has no scaling, and the inverse has a factor $1/N$.\n\n2) Implement the corresponding inverse transform as a pure matrix-vector multiplication using the inverse of the forward transform matrix, in a manner consistent with the chosen forward convention.\n\n3) Using your matrix-based transforms, verify the correctness of a canned FFT implementation (use the standard library FFT available in your language; in Python this is the default behavior of numpy.fft.fft) by checking the following properties for each test case listed below:\n- Forward agreement: your direct-transform $X$ matches the canned FFT result within a numerical tolerance.\n- Inverse agreement: applying your direct inverse transform to the canned FFT result reconstructs the original signal within the same tolerance.\n- Energy conservation (Parseval relation for the adopted normalization): $\\sum_{n=0}^{N-1} |x_n|^2$ equals $\\frac{1}{N} \\sum_{k=0}^{N-1} |X_k|^2$ within the tolerance.\n- Hermitian symmetry for real inputs: if $x$ is real-valued, then $X_k = \\overline{X_{(-k) \\bmod N}}$ for all $k$, within the tolerance.\n\nNumerical details:\n\n- Use absolute tolerance $10^{-10}$ and relative tolerance $10^{-10}$.\n- Angles are in radians.\n\nTest suite:\n\nFor each case, let $n \\in \\{0,1,\\dots,N-1\\}$.\n\n- Case A (happy path, complex scalar): $N = 1$, $x_0 = 3 - 2\\mathrm{i}$.\n- Case B (boundary size, real alternating): $N = 2$, $x_0 = 1$, $x_1 = -1$.\n- Case C (prime length, complex mix): $N = 3$, $x_0 = 1 + 2\\mathrm{i}$, $x_1 = -3 + 0.5\\mathrm{i}$, $x_2 = -\\mathrm{i}$.\n- Case D (power of two, single-bin cosine): $N = 4$, $x_n = \\cos(2 \\pi n / 4)$.\n- Case E (sparse impulse): $N = 5$, $x_n = 2$ if $n = 2$, and $x_n = 0$ otherwise.\n- Case F (complex chirp): $N = 8$, $x_n = \\exp(\\mathrm{i} \\pi n (n-1) / 8)$.\n- Case G (random complex, reproducible): $N = 16$, $x_n = a_n + \\mathrm{i} b_n$, where $\\{a_n\\}$ and $\\{b_n\\}$ are independent standard normal deviates generated with a fixed seed $12345$.\n\nFor each case, produce a single boolean indicating whether all applicable checks pass. The tolerance comparisons must use the specified absolute and relative tolerances.\n\nFinal output format:\n\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with boolean literals written as $\\text{True}$ or $\\text{False}$, in the order of Cases A through G. For example: $[\\text{True},\\text{False},\\text{True}]$.", "solution": "The problem statement is subjected to validation.\n\n**Step 1: Extracted Givens**\n- **Principle**: The discrete Fourier transform (DFT) is a linear transformation from the standard basis to an orthogonal basis of complex exponentials $e^{\\mathrm{i} 2 \\pi k n / N}$ on the grid $n \\in \\{0, 1, \\dots, N-1\\}$.\n- **Task 1**: Implement a forward DFT, $X = Wx$, by explicitly constructing the $N \\times N$ DFT matrix $W$. This is a direct, $O(N^2)$ algorithm.\n- **Task 2**: Implement the corresponding inverse DFT, $x = W_{\\text{inv}}X$, by constructing the inverse matrix $W_{\\text{inv}}$.\n- **Normalization Convention**: The forward transform is unscaled. The inverse transform is scaled by a factor of $1/N$.\n- **Task 3**: Verify a canned Fast Fourier Transform (FFT) implementation by checking four properties for a suite of test cases:\n    1.  **Forward Agreement**: The direct DFT result must match the canned FFT result.\n    2.  **Inverse Agreement**: Applying the direct IDFT to the canned FFT result must reconstruct the original signal.\n    3.  **Energy Conservation (Parseval's Relation)**: $\\sum_{n=0}^{N-1} |x_n|^2 = \\frac{1}{N} \\sum_{k=0}^{N-1} |X_k|^2$.\n    4.  **Hermitian Symmetry**: For real-valued inputs $x$, the transform must satisfy $X_k = \\overline{X_{(-k) \\bmod N}}$.\n- **Numerical Tolerance**: Absolute tolerance $10^{-10}$, relative tolerance $10^{-10}$.\n- **Test Cases**:\n    - **A**: $N=1$, $x_0 = 3 - 2\\mathrm{i}$.\n    - **B**: $N=2$, $x = [1, -1]$.\n    - **C**: $N=3$, $x = [1 + 2\\mathrm{i}, -3 + 0.5\\mathrm{i}, -\\mathrm{i}]$.\n    - **D**: $N=4$, $x_n = \\cos(2 \\pi n / 4)$.\n    - **E**: $N=5$, $x = [0, 0, 2, 0, 0]$.\n    - **F**: $N=8$, $x_n = \\exp(\\mathrm{i} \\pi n(n-1) / 8)$.\n    - **G**: $N=16$, $x_n = a_n + \\mathrm{i} b_n$ from standard normal deviates with seed $12345$.\n- **Final Output**: A single boolean result for each test case, indicating if all applicable checks pass.\n\n**Step 2: Validation**\nThe problem is assessed for scientific validity, well-posedness, and objectivity.\n- **Scientific Grounding**: The problem is fundamentally sound. It is based on the standard mathematical definition of the Discrete Fourier Transform, its matrix representation, and its core properties like Parseval's theorem and Hermitian symmetry. The specified normalization is a common convention.\n- **Well-Posedness**: The problem is unambiguous and self-contained. It provides all necessary data (signals, sizes $N$), algorithms to implement, properties to verify, and strict numerical tolerances. A unique, verifiable outcome (a list of booleans) is expected.\n- **Objectivity**: The language is precise and devoid of subjective claims. The tasks are purely computational and verifiable.\n\n**Step 3: Verdict**\nThe problem is deemed **valid**. It is a well-defined exercise in numerical verification, rooted in the fundamental principles of Fourier analysis. I will now provide the solution.\n\n---\n\nThe solution requires the implementation of the Discrete Fourier Transform (DFT) and its inverse as direct matrix-vector multiplications to serve as a reference for verifying a Fast Fourier Transform (FFT) implementation.\n\n**1. Forward Discrete Fourier Transform (DFT)**\nThe DFT maps a discrete signal vector $x \\in \\mathbb{C}^N$ of length $N$ to its frequency-domain representation $X \\in \\mathbb{C}^N$. For each frequency component $k \\in \\{0, 1, \\dots, N-1\\}$, the value $X_k$ is computed as the projection of the signal $x$ onto the complex exponential basis vector corresponding to frequency $k$. Adhering to the standard definition, this is:\n$$\nX_k = \\sum_{n=0}^{N-1} x_n e^{-\\mathrm{i} 2 \\pi k n / N}\n$$\nThis set of $N$ linear equations can be expressed in matrix form as $X = Wx$, where $W$ is the $N \\times N$ DFT matrix. The elements of this matrix, indexed by row $k$ and column $n$, are given by:\n$$\nW_{kn} = e^{-\\mathrm{i} 2 \\pi k n / N}\n$$\nThe implementation will construct this matrix explicitly and perform the matrix-vector multiplication, which has a computational complexity of $O(N^2)$. This is in contrast to FFT algorithms, which compute the same transform in $O(N \\log N)$ time.\n\n**2. Inverse Discrete Fourier Transform (IDFT)**\nThe inverse transform reconstructs the original signal $x$ from its spectrum $X$. Based on the specified normalization convention (no scaling on the forward transform), the inverse transform must include a scaling factor of $1/N$ to ensure that the composition of the forward and inverse transforms yields the identity operation. The formula is:\n$$\nx_n = \\frac{1}{N} \\sum_{k=0}^{N-1} X_k e^{\\mathrm{i} 2 \\pi k n / N}\n$$\nIn matrix form, this is $x = W_{\\text{inv}}X$. The inverse matrix $W_{\\text{inv}}$ has elements:\n$$\n(W_{\\text{inv}})_{nk} = \\frac{1}{N} e^{\\mathrm{i} 2 \\pi n k / N}\n$$\nIt is a fundamental property of the DFT matrix that $W^{-1} = \\frac{1}{N}W^*$, where $W^*$ is the conjugate transpose of $W$. This follows from the orthogonality of the columns of $W$. Our implementation will construct the matrix for the inverse transform and apply it.\n\n**3. Verification Procedure**\nThe correctness of a canned FFT routine is verified against our direct matrix implementation by performing four checks for each test case. All numerical comparisons use a relative tolerance of $r_{tol} = 10^{-10}$ and an absolute tolerance of $a_{tol} = 10^{-10}$.\n\n- **Forward Agreement:** We compute $X_{\\text{direct}} = Wx$ and obtain $X_{\\text{FFT}}$ from the standard library function. We then verify that $X_{\\text{direct}}$ and $X_{\\text{FFT}}$ are element-wise equal within the specified tolerance.\n\n- **Inverse Agreement:** We verify that the original signal $x$ is recovered when our direct inverse transform is applied to the result of the canned FFT, $X_{\\text{FFT}}$. We compute $x_{\\text{rec}} = W_{\\text{inv}} X_{\\text{FFT}}$ and check that $x$ and $x_{\\text{rec}}$ are element-wise equal within tolerance.\n\n- **Energy Conservation (Parseval's Relation):** For the specified normalization, the sum of squared magnitudes of the signal elements is related to the sum of squared magnitudes of its transform coefficients by the identity:\n$$\n\\sum_{n=0}^{N-1} |x_n|^2 = \\frac{1}{N} \\sum_{k=0}^{N-1} |X_k|^2\n$$\nWe compute both the left-hand side and the right-hand side of this equation and verify they are equal within the given tolerance.\n\n- **Hermitian Symmetry:** This property applies only to signals $x$ that are purely real-valued ($x_n \\in \\mathbb{R}$ for all $n$). For such signals, the DFT spectrum exhibits conjugate symmetry:\n$$\nX_k = \\overline{X_{(-k) \\pmod{N}}}\n$$\nThis is checked for all $k \\in \\{0, 1, \\dots, N-1\\}$. This implies that $X_0$ is real, and if $N$ is even, $X_{N/2}$ is also real. This check is performed only for the test cases with real-valued inputs.\n\nFor each test case, the final result is a single boolean value, which is true if and only if all applicable checks pass.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and run the DFT verification process.\n    \"\"\"\n    \n    # Define test cases as a list of dictionaries.\n    # Each dictionary specifies the signal size N and a function to generate the signal x.\n    test_cases = [\n        {\n            \"id\": \"A\",\n            \"N\": 1,\n            \"x_func\": lambda N: np.array([3.0 - 2.0j]),\n            \"is_real\": False,\n        },\n        {\n            \"id\": \"B\",\n            \"N\": 2,\n            \"x_func\": lambda N: np.array([1.0, -1.0]),\n            \"is_real\": True,\n        },\n        {\n            \"id\": \"C\",\n            \"N\": 3,\n            \"x_func\": lambda N: np.array([1.0 + 2.0j, -3.0 + 0.5j, -1.0j]),\n            \"is_real\": False,\n        },\n        {\n            \"id\": \"D\",\n            \"N\": 4,\n            \"x_func\": lambda N: np.cos(2 * np.pi * 1 * np.arange(N) / N),\n            \"is_real\": True,\n        },\n        {\n            \"id\": \"E\",\n            \"N\": 5,\n            \"x_func\": lambda N: np.array([0.0, 0.0, 2.0, 0.0, 0.0]),\n            \"is_real\": True,\n        },\n        {\n            \"id\": \"F\",\n            \"N\": 8,\n            \"x_func\": lambda N: np.exp(1j * np.pi * np.arange(N) * (np.arange(N) - 1) / N),\n            \"is_real\": False,\n        },\n        {\n            \"id\": \"G\",\n            \"N\": 16,\n            \"x_func\": lambda N: (\n                (rng := np.random.default_rng(12345)).standard_normal(N) +\n                1j * rng.standard_normal(N)\n            ),\n            \"is_real\": False,\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        N = case[\"N\"]\n        x = case[\"x_func\"](N)\n        is_real_input = case[\"is_real\"]\n        \n        # Run all verification checks for the current case.\n        passed = run_verification(x, N, is_real_input)\n        results.append(passed)\n\n    # Print the final results in the specified format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef run_verification(x, N, is_real_input):\n    \"\"\"\n    Performs all DFT verification checks for a given signal x of size N.\n    \"\"\"\n    rtol = 1e-10\n    atol = 1e-10\n    \n    checks_passed = []\n\n    # --- 1. Forward Agreement Check ---\n    # Construct the direct DFT matrix W\n    k = np.arange(N).reshape((N, 1))\n    n = np.arange(N)\n    W = np.exp(-2j * np.pi * k * n / N)\n\n    # Compute direct DFT and canned FFT\n    X_direct = W @ x\n    X_fft = np.fft.fft(x)\n    \n    forward_agreement = np.allclose(X_direct, X_fft, rtol=rtol, atol=atol)\n    checks_passed.append(forward_agreement)\n\n    # --- 2. Inverse Agreement Check ---\n    # Construct the direct IDFT matrix W_inv\n    # The unscaled matrix is the conjugate transpose of W, or simply change the sign of the exponent.\n    W_inv_unscaled = np.exp(2j * np.pi * k * n / N)\n    W_inv = (1 / N) * W_inv_unscaled\n    \n    # Reconstruct the signal from the canned FFT result\n    x_reconstructed = W_inv @ X_fft\n    \n    inverse_agreement = np.allclose(x, x_reconstructed, rtol=rtol, atol=atol)\n    checks_passed.append(inverse_agreement)\n\n    # --- 3. Energy Conservation (Parseval's Relation) Check ---\n    energy_x = np.sum(np.abs(x)**2)\n    energy_X = (1 / N) * np.sum(np.abs(X_direct)**2)\n\n    parseval_check = np.isclose(energy_x, energy_X, rtol=rtol, atol=atol)\n    checks_passed.append(parseval_check)\n\n    # --- 4. Hermitian Symmetry Check (for real inputs only) ---\n    if is_real_input:\n        # Check that the input signal is indeed real, as a sanity check.\n        assert np.all(np.abs(x.imag) < atol)\n        \n        # Check X_k = conj(X_{(-k) mod N})\n        indices = np.arange(N)\n        neg_indices_mod_N = (-indices) % N\n        X_conj_symmetric = np.conj(X_direct[neg_indices_mod_N])\n        \n        hermitian_check = np.allclose(X_direct, X_conj_symmetric, rtol=rtol, atol=atol)\n        checks_passed.append(hermitian_check)\n\n    # Return True only if all executed checks passed.\n    return all(checks_passed)\n\nsolve()\n```", "id": "2391694"}]}