{"hands_on_practices": [{"introduction": "The Discrete Fourier Transform (DFT) provides a frequency-domain perspective of a finite-length signal by decomposing it into a sum of complex sinusoids. To truly understand how the DFT acts as a \"frequency lens,\" the best starting point is to analyze how it \"sees\" one of its own fundamental building blocks. This exercise [@problem_id:1759639] has you calculate the DFT of a single, pure complex exponential, revealing the transform's ability to perfectly isolate a specific frequency component.", "problem": "In digital signal processing, the Discrete Fourier Transform (DFT) is a fundamental tool for analyzing the frequency content of a finite-length signal. Consider a simplified model of a pure tone signal after sampling. This signal, denoted as $x[n]$, is represented by a single complex exponential.\n\nThe signal is a sequence of length $N$ defined as:\n$$x[n] = \\exp\\left(j \\frac{2\\pi k_0 n}{N}\\right)$$\nfor the time index $n = 0, 1, \\ldots, N-1$. Here, $k_0$ is an integer constant representing the normalized frequency of the tone, and it satisfies $0 \\le k_0 < N$.\n\nYour task is to compute the $N$-point DFT of this signal. The DFT, denoted by $X[k]$, is defined by the analysis equation:\n$$X[k] = \\sum_{n=0}^{N-1} x[n] \\exp\\left(-j \\frac{2\\pi kn}{N}\\right)$$\nwhere $k$ is the frequency index, taking integer values from $k = 0, 1, \\ldots, N-1$.\n\nFind a single, closed-form analytic expression for $X[k]$ in terms of $N$, $k$, and $k_0$.", "solution": "We start from the DFT analysis equation and substitute the given signal. By definition,\n$$\nX[k] = \\sum_{n=0}^{N-1} x[n] \\exp\\left(-j \\frac{2\\pi kn}{N}\\right).\n$$\nWith $x[n] = \\exp\\left(j \\frac{2\\pi k_{0} n}{N}\\right)$, this becomes\n$$\nX[k] = \\sum_{n=0}^{N-1} \\exp\\left(j \\frac{2\\pi k_{0} n}{N}\\right)\\exp\\left(-j \\frac{2\\pi k n}{N}\\right) \n= \\sum_{n=0}^{N-1} \\exp\\left(j \\frac{2\\pi (k_{0}-k) n}{N}\\right).\n$$\nDefine the ratio\n$$\nr \\triangleq \\exp\\left(j \\frac{2\\pi (k_{0}-k)}{N}\\right).\n$$\nThen\n$$\nX[k] = \\sum_{n=0}^{N-1} r^{n}.\n$$\nThis is a finite geometric series. Using the geometric series sum,\n$$\n\\sum_{n=0}^{N-1} r^{n} = \n\\begin{cases}\n\\frac{1 - r^{N}}{1 - r}, & r \\neq 1, \\\\\nN, & r = 1,\n\\end{cases}\n$$\nand noting that\n$$\nr^{N} = \\exp\\left(j \\frac{2\\pi (k_{0}-k) N}{N}\\right) = \\exp\\left(j 2\\pi (k_{0}-k)\\right) = 1,\n$$\nwe have:\n- If $r \\neq 1$ (equivalently $k \\neq k_{0}$ for $k,k_{0}\\in\\{0,\\ldots,N-1\\}$), then $1 - r^{N} = 0$ while $1 - r \\neq 0$, so $X[k] = 0$.\n- If $r = 1$ (equivalently $k = k_{0}$), then every term of the sum equals $1$, so $X[k] = N$.\n\nCombining these cases gives the closed-form expression\n$$\nX[k] = N\\,\\delta_{k,k_{0}},\n$$\nwhere $\\delta_{k,k_{0}}$ is the Kronecker delta, equal to $1$ if $k=k_{0}$ and $0$ otherwise.", "answer": "$$\\boxed{N\\,\\delta_{k,k_{0}}}$$", "id": "1759639"}, {"introduction": "One of the most powerful applications of the DFT is the ability to perform filtering by directly manipulating a signal's frequency spectrum. This practice [@problem_id:1759601] guides you through a quintessential digital signal processing task: implementing an ideal low-pass filter by zeroing out specific DFT coefficients. By calculating the result in the time domain, you will gain hands-on experience with frequency-domain filtering and observe its important, and sometimes non-intuitive, consequences.", "problem": "Consider a discrete-time signal $x[n]$ of length $N=16$. The signal is defined as a rectangular pulse: $x[n]=1$ for $0 \\le n \\le 4$, and $x[n]=0$ for $5 \\le n \\le 15$. This signal is processed by an ideal low-pass filter in the frequency domain. The N-point Discrete Fourier Transform (DFT) of the signal, denoted by $X[k]$, is multiplied by a filter frequency response $H[k]$ to produce the output spectrum $Y[k] = X[k]H[k]$. The filter is defined as $H[k]=1$ for $k \\in \\{0, 1, 2, 14, 15\\}$ and $H[k]=0$ for all other values of $k$ in the range $0 \\le k \\le 15$. The output signal in the time domain, $y[n]$, is then obtained by taking the N-point Inverse Discrete Fourier Transform (IDFT) of $Y[k]$. Calculate the value of the output signal sample $y[7]$. Round your final answer to four significant figures.", "solution": "Let $N=16$ and define the $N$-point DFT and IDFT by\n$$\nX[k]=\\sum_{n=0}^{15} x[n]\\exp(-\\mathrm{j}2\\pi kn/16),\\quad\ny[n]=\\frac{1}{16}\\sum_{k=0}^{15} Y[k]\\exp(\\mathrm{j}2\\pi kn/16),\n$$\nwith $Y[k]=X[k]H[k]$. Since $x[n]=1$ for $0\\leq n\\leq 4$ and $x[n]=0$ otherwise, we have for $k\\in\\{0,1,\\dots,15\\}$,\n$$\nX[k]=\\sum_{n=0}^{4}\\exp(-\\mathrm{j}2\\pi kn/16).\n$$\nFor $k=0$, $X[0]=5$. For $k\\neq 0$, using the geometric sum in Dirichlet form with $M=5$ and $\\theta=2\\pi k/16$,\n$$\nX[k]=\\exp\\!\\big(-\\mathrm{j}\\theta(M-1)/2\\big)\\,\\frac{\\sin(M\\theta/2)}{\\sin(\\theta/2)}\n=\\exp\\!\\big(-\\mathrm{j}\\theta\\cdot 2\\big)\\,\\frac{\\sin(5\\theta/2)}{\\sin(\\theta/2)}.\n$$\nThe filter keeps only $k\\in\\{0,1,2,14,15\\}$, so\n$$\ny[n]=\\frac{1}{16}\\Big(X[0]+X[1]\\exp(\\mathrm{j}\\omega n)+X[2]\\exp(\\mathrm{j}2\\omega n)+X[14]\\exp(\\mathrm{j}14\\omega n)+X[15]\\exp(\\mathrm{j}15\\omega n)\\Big),\n$$\nwith $\\omega=2\\pi/16$. Using $X[16-k]=X[k]^{*}$ and $\\exp(\\mathrm{j}14\\omega n)=\\exp(-\\mathrm{j}2\\omega n)$, $\\exp(\\mathrm{j}15\\omega n)=\\exp(-\\mathrm{j}\\omega n)$, this becomes\n$$\ny[n]=\\frac{1}{16}\\Big(X[0]+2\\Re\\{X[1]\\exp(\\mathrm{j}\\omega n)\\}+2\\Re\\{X[2]\\exp(\\mathrm{j}2\\omega n)\\}\\Big).\n$$\nWe now specialize to $n=7$. Compute $X[1]$ and $X[2]$ explicitly:\n- For $k=1$, $\\theta=\\pi/8$, so\n$$\nX[1]=\\exp(-\\mathrm{j}\\pi/4)\\,\\frac{\\sin(5\\pi/16)}{\\sin(\\pi/16)}.\n$$\nThus\n$$\n\\Re\\{X[1]\\exp(\\mathrm{j}\\omega\\cdot 7)\\}=\\frac{\\sin(5\\pi/16)}{\\sin(\\pi/16)}\\cos\\!\\Big(7\\frac{\\pi}{8}-\\frac{\\pi}{4}\\Big)=\\frac{\\sin(5\\pi/16)}{\\sin(\\pi/16)}\\cos\\!\\Big(\\frac{5\\pi}{8}\\Big).\n$$\n- For $k=2$, $\\theta=\\pi/4$, so\n$$\nX[2]=\\exp(-\\mathrm{j}\\pi/2)\\,\\frac{\\sin(5\\pi/8)}{\\sin(\\pi/8)}.\n$$\nThus\n$$\n\\Re\\{X[2]\\exp(\\mathrm{j}2\\omega\\cdot 7)\\}=\\frac{\\sin(5\\pi/8)}{\\sin(\\pi/8)}\\cos\\!\\Big(7\\frac{\\pi}{4}-\\frac{\\pi}{2}\\Big)=\\frac{\\sin(5\\pi/8)}{\\sin(\\pi/8)}\\cos\\!\\Big(\\frac{5\\pi}{4}\\Big).\n$$\nTherefore\n$$\ny[7]=\\frac{1}{16}\\left(5+2\\frac{\\sin(5\\pi/16)}{\\sin(\\pi/16)}\\cos\\!\\Big(\\frac{5\\pi}{8}\\Big)+2\\frac{\\sin(5\\pi/8)}{\\sin(\\pi/8)}\\cos\\!\\Big(\\frac{5\\pi}{4}\\Big)\\right).\n$$\nUse exact trigonometric values where available:\n$$\n\\cos\\!\\Big(\\frac{5\\pi}{8}\\Big)=-\\cos\\!\\Big(\\frac{3\\pi}{8}\\Big),\\quad \\cos\\!\\Big(\\frac{5\\pi}{4}\\Big)=-\\frac{\\sqrt{2}}{2},\\quad \\frac{\\sin(5\\pi/8)}{\\sin(\\pi/8)}=\\frac{\\sin(3\\pi/8)}{\\sin(\\pi/8)}=1+\\sqrt{2}.\n$$\nNumerically,\n$$\n\\frac{\\sin(5\\pi/16)}{\\sin(\\pi/16)}\\approx 4.2619726274,\\quad \\cos\\!\\Big(\\frac{5\\pi}{8}\\Big)\\approx -0.3826834324,\\quad 1+\\sqrt{2}\\approx 2.4142135624,\n$$\nso\n$$\n2\\frac{\\sin(5\\pi/16)}{\\sin(\\pi/16)}\\cos\\!\\Big(\\frac{5\\pi}{8}\\Big)\\approx -3.2619726274,\\quad\n2\\frac{\\sin(5\\pi/8)}{\\sin(\\pi/8)}\\cos\\!\\Big(\\frac{5\\pi}{4}\\Big)=-(\\sqrt{2}+2)\\approx -3.4142135624.\n$$\nHence\n$$\ny[7]\\approx \\frac{1}{16}\\Big(5-3.2619726274-3.4142135624\\Big)\\approx -0.1047616369,\n$$\nwhich rounded to four significant figures is $-0.1048$.", "answer": "$$\\boxed{-0.1048}$$", "id": "1759601"}, {"introduction": "While the DFT is theoretically powerful, its widespread use in everything from audio processing to medical imaging is only possible because of an incredibly efficient algorithm for its computation: the Fast Fourier Transform (FFT). This practice [@problem_id:2387187] is a deep dive into the engine of modern signal processing. By implementing the FFT from scratch and using it to verify core DFT properties, you will gain a profound appreciation for the computational foundation that makes large-scale Fourier analysis practical.", "problem": "Let $N$ be a positive integer of the form $N = 2^m$ for some nonnegative integer $m$. For a length-$N$ complex-valued sequence $x = \\{x_n\\}_{n=0}^{N-1}$, the discrete Fourier transform (DFT) $X = \\{X_k\\}_{k=0}^{N-1}$ is defined by\n$$\nX_k = \\sum_{n=0}^{N-1} x_n \\, e^{-2\\pi i \\, k n / N} \\quad \\text{for } k = 0,1,\\dots,N-1,\n$$\nand the inverse discrete Fourier transform (IDFT) is defined by\n$$\nx_n = \\frac{1}{N} \\sum_{k=0}^{N-1} X_k \\, e^{+2\\pi i \\, k n / N} \\quad \\text{for } n = 0,1,\\dots,N-1,\n$$\nwhere all angles are in radians.\n\nWrite a complete program that, without calling any library Fourier transform routines, computes the DFT and IDFT for sequences of length $N = 2^m$. Your program must also verify the following fundamental properties against explicit test cases using only these definitions:\n\n- Circular convolution theorem: For sequences $a$ and $b$ of length $N$, their length-$N$ circular convolution $c$ defined by $c_n = \\sum_{m=0}^{N-1} a_m \\, b_{(n-m) \\bmod N}$ satisfies $C_k = A_k B_k$, where $A$, $B$, and $C$ are the DFTs of $a$, $b$, and $c$, respectively.\n- Parseval identity (with the above normalization): $\\sum_{n=0}^{N-1} |x_n|^2 = \\frac{1}{N} \\sum_{k=0}^{N-1} |X_k|^2$.\n\nYour program must implement its own fast algorithm to compute the DFT and IDFT for $N = 2^m$, and must include a direct $\\mathcal{O}(N^2)$ DFT for verification. Use a numerical tolerance $\\varepsilon = 10^{-9}$ where boolean validations are required. All angles must be interpreted in radians.\n\nUse the following test suite, and produce the outputs in the order given below:\n\n- Test $1$ (DFT correctness versus direct DFT, happy path): Let $N = 8$ and $x = [0,1,2,3,4,3,2,1]$. Compute $X$ using your fast implementation and $\\tilde{X}$ using the direct DFT. Output a boolean equal to $\\text{True}$ if $\\max_k |X_k - \\tilde{X}_k| \\le \\varepsilon$, otherwise $\\text{False}$.\n- Test $2$ (Inverse transform recovery): Using the same $N$ and $x$ as in Test $1$, compute $x'$ by applying your IDFT to $X$ from your fast implementation. Output a boolean equal to $\\text{True}$ if $\\max_n |x'_n - x_n| \\le \\varepsilon$, otherwise $\\text{False}$.\n- Test $3$ (Circular convolution via frequency domain): Let $N = 8$, $a = [1,2,3,0,0,0,0,0]$, and $b = [0,1,0,0,0,0,0,0]$. Compute the length-$N$ circular convolution $c$ directly from its definition. Separately, compute $\\hat{c}$ by taking the DFTs of $a$ and $b$, multiplying pointwise, and applying the IDFT. Output the scalar $\\max_n |c_n - \\hat{c}_n|$ as a floating-point number.\n- Test $4$ (Parseval identity): Let $N = 16$ and $x_n = \\sin\\!\\left( \\frac{2\\pi \\cdot 3 \\, n}{N} \\right) + \\frac{1}{2} \\cos\\!\\left( \\frac{2\\pi \\cdot 5 \\, n}{N} \\right)$ for $n = 0,1,\\dots,15$. Compute $X$ by your fast implementation. Output the scalar $\\left| \\sum_{n=0}^{N-1} |x_n|^2 - \\frac{1}{N} \\sum_{k=0}^{N-1} |X_k|^2 \\right|$ as a floating-point number.\n- Test $5$ (Edge case $N=1$): Let $N = 1$ and $x = [3 + 4i]$. Compute $X$ and then $x'$ via IDFT. Output a boolean equal to $\\text{True}$ if $|x'_0 - x_0| \\le \\varepsilon$, otherwise $\\text{False}$.\n- Test $6$ (Smallest nontrivial size $N=2$): Let $N = 2$ and $x = [1,-1]$. Compute $X$ by your fast implementation. The exact DFT under the given convention is $[0,2]$. Output the scalar $\\max_k |X_k - [0,2]_k|$ as a floating-point number.\n\nFinal output format: Your program should produce a single line of output containing the six results, in order, as a comma-separated list enclosed in square brackets, for example, $[r_1,r_2,r_3,r_4,r_5,r_6]$. All boolean entries must be either $\\text{True}$ or $\\text{False}$, and all real-valued entries must be printed in standard decimal or scientific notation. No other text should be printed.", "solution": "The core of the problem is the computation of the DFT, $X$, for a given discrete, complex-valued sequence, $x = \\{x_n\\}_{n=0}^{N-1}$, of length $N$. The definition is given as:\n$$\nX_k = \\sum_{n=0}^{N-1} x_n \\, e^{-2\\pi i \\, k n / N} \\quad \\text{for } k = 0,1,\\dots,N-1.\n$$\nA direct implementation of this formula involves two nested loops, one for each index $k$ from $0$ to $N-1$ and one for each index $n$ from $0$ to $N-1$. This leads to a computational complexity of $\\mathcal{O}(N^2)$, which is inefficient for large $N$. For verification purposes, such a direct method will be implemented.\n\nThe problem specifies that $N$ is a power of two, i.e., $N = 2^m$ for some non-negative integer $m$. This structure is key for employing a Fast Fourier Transform (FFT) algorithm, specifically the Cooley-Tukey decimation-in-time algorithm. This algorithm reduces the complexity from $\\mathcal{O}(N^2)$ to $\\mathcal{O}(N \\log N)$. The principle is one of divide and conquer. The length-$N$ DFT is recursively broken down into two length-$(N/2)$ DFTs.\n\nLet the sequence $x_n$ be split into its even-indexed elements, forming a sequence $x'_m = x_{2m}$, and its odd-indexed elements, forming a sequence $x''_m = x_{2m+1}$, each of length $N/2$. The DFT sum can be rewritten as:\n$$\nX_k = \\sum_{m=0}^{N/2-1} x_{2m} e^{-2\\pi i k (2m) / N} + \\sum_{m=0}^{N/2-1} x_{2m+1} e^{-2\\pi i k (2m+1) / N}\n$$\n$$\nX_k = \\sum_{m=0}^{N/2-1} x'_m e^{-2\\pi i k m / (N/2)} + e^{-2\\pi i k/N} \\sum_{m=0}^{N/2-1} x''_m e^{-2\\pi i k m / (N/2)}\n$$\nLet $X'_k$ and $X''_k$ be the length-$(N/2)$ DFTs of $x'_m$ and $x''_m$, respectively. The expressions above become:\n$$\nX_k = X'_{k \\bmod (N/2)} + W_N^k X''_{k \\bmod (N/2)}\n$$\nwhere $W_N^k = e^{-2\\pi i k/N}$ is the \"twiddle factor\". For $k$ in the first half of the indices, $0 \\le k < N/2$, we have:\n$$\nX_k = X'_k + W_N^k X''_k\n$$\nFor the second half, where the index is $k+N/2$ for $0 \\le k < N/2$, we use the properties $X'_{k+N/2} = X'_k$, $X''_{k+N/2} = X''_k$, and $W_N^{k+N/2} = -W_N^k$. This yields:\n$$\nX_{k+N/2} = X'_k - W_N^k X''_k\n$$\nThis recursive definition allows the construction of the full DFT. The recursion terminates at the base case $N=1$, where the DFT of a sequence $\\{x_0\\}$ is simply $\\{X_0\\} = \\{x_0\\}$. Our implementation will follow this recursive structure.\n\nThe Inverse Discrete Fourier Transform (IDFT) is defined as:\n$$\nx_n = \\frac{1}{N} \\sum_{k=0}^{N-1} X_k \\, e^{+2\\pi i \\, k n / N}\n$$\nA separate implementation is not necessary. We can relate the IDFT to the forward DFT. Observe the following derivation:\n$$\nN \\cdot \\overline{x_n} = \\overline{\\sum_{k=0}^{N-1} X_k e^{+2\\pi i k n / N}} = \\sum_{k=0}^{N-1} \\overline{X_k} e^{-2\\pi i k n / N}\n$$\nThe right-hand side is the DFT of the complex-conjugated sequence $\\{\\overline{X_k}\\}_{k=0}^{N-1}$. Therefore, we can find $x_n$ by computing the DFT of $\\overline{X}$, taking the complex conjugate of the result, and scaling by $1/N$. That is, $x = \\frac{1}{N} \\overline{\\text{DFT}(\\overline{X})}$. This allows us to use our efficient FFT implementation to compute the inverse transform (IFFT) as well.\n\nThe problem further requires verification of two fundamental theorems.\n\nFirst, the circular convolution theorem. The circular convolution $c$ of two length-$N$ sequences, $a$ and $b$, is given by $c_n = \\sum_{m=0}^{N-1} a_m b_{(n-m) \\bmod N}$. The theorem states that the DFT of the convolution is the pointwise product of the individual DFTs: $C_k = A_k B_k$. Thus, one can compute $c$ via the frequency domain: $c = \\text{IDFT}(\\text{DFT}(a) \\odot \\text{DFT}(b))$, where $\\odot$ denotes element-wise multiplication. We will test this by computing $c$ both directly and via the frequency domain route and comparing the results.\n\nSecond, Parseval's identity. For the given DFT normalization, the identity is:\n$$\n\\sum_{n=0}^{N-1} |x_n|^2 = \\frac{1}{N} \\sum_{k=0}^{N-1} |X_k|^2\n$$\nThis theorem relates the total energy of a signal in the time domain to its energy in the frequency domain. We will verify this for a specific test signal.\n\nThe program will proceed by first defining the necessary functions: a direct $\\mathcal{O}(N^2)$ DFT, a recursive $\\mathcal{O}(N \\log N)$ FFT, an IFFT based on the FFT, and a direct circular convolution function. Then, it will execute the $6$ specified test cases using these functions and a numerical tolerance of $\\varepsilon = 10^{-9}$ for comparisons. The results will be collected and printed in the required format.", "answer": "```python\nimport numpy as np\n\ndef direct_dft(x):\n    \"\"\"\n    Computes the Discrete Fourier Transform of a sequence x using the direct O(N^2) method.\n    \"\"\"\n    x = np.asarray(x, dtype=complex)\n    N = x.shape[0]\n    n = np.arange(N)\n    k = n.reshape((N, 1))\n    W = np.exp(-2j * np.pi * k * n / N)\n    X = np.dot(W, x)\n    return X\n\ndef fft(x):\n    \"\"\"\n    Computes the Discrete Fourier Transform of a sequence x using the recursive\n    Cooley-Tukey FFT algorithm. Assumes N is a power of 2.\n    \"\"\"\n    x = np.asarray(x, dtype=complex)\n    N = x.shape[0]\n\n    if N <= 1:\n        return x\n\n    # Decimate: split into even and odd subsequences\n    x_even = fft(x[0::2])\n    x_odd = fft(x[1::2])\n\n    # Combine\n    k = np.arange(N // 2)\n    twiddle_factors = np.exp(-2j * np.pi * k / N)\n    \n    X = np.concatenate([x_even + twiddle_factors * x_odd,\n                          x_even - twiddle_factors * x_odd])\n    return X\n\ndef ifft(X):\n    \"\"\"\n    Computes the Inverse Discrete Fourier Transform using the forward FFT algorithm.\n    \"\"\"\n    X = np.asarray(X, dtype=complex)\n    N = X.shape[0]\n    \n    # Use the property: IDFT(X) = (1/N) * conj(DFT(conj(X)))\n    x = np.conjugate(fft(np.conjugate(X))) / N\n    return x\n\ndef circular_conv(a, b):\n    \"\"\"\n    Computes the circular convolution of two sequences a and b directly.\n    \"\"\"\n    a = np.asarray(a, dtype=complex)\n    b = np.asarray(b, dtype=complex)\n    N = len(a)\n    c = np.zeros(N, dtype=complex)\n    for n in range(N):\n        for m in range(N):\n            c[n] += a[m] * b[(n - m) % N]\n    return c\n\ndef solve():\n    \"\"\"\n    Runs the full test suite and prints the formatted results.\n    \"\"\"\n    epsilon = 1e-9\n    results = []\n\n    # Test 1: DFT correctness versus direct DFT\n    N1 = 8\n    x1 = np.array([0, 1, 2, 3, 4, 3, 2, 1], dtype=float)\n    X_fast = fft(x1)\n    X_direct = direct_dft(x1)\n    err1 = np.max(np.abs(X_fast - X_direct))\n    results.append(err1 <= epsilon)\n\n    # Test 2: Inverse transform recovery\n    x_prime = ifft(X_fast)\n    err2 = np.max(np.abs(x_prime - x1))\n    results.append(err2 <= epsilon)\n\n    # Test 3: Circular convolution via frequency domain\n    N3 = 8\n    a3 = np.array([1, 2, 3, 0, 0, 0, 0, 0], dtype=float)\n    b3 = np.array([0, 1, 0, 0, 0, 0, 0, 0], dtype=float)\n    c_direct = circular_conv(a3, b3)\n    A3 = fft(a3)\n    B3 = fft(b3)\n    C_freq = A3 * B3\n    c_hat = ifft(C_freq)\n    err3 = np.max(np.abs(c_direct - c_hat))\n    results.append(err3)\n\n    # Test 4: Parseval identity\n    N4 = 16\n    n4 = np.arange(N4)\n    x4 = np.sin(2 * np.pi * 3 * n4 / N4) + 0.5 * np.cos(2 * np.pi * 5 * n4 / N4)\n    X4 = fft(x4)\n    sum_sq_x = np.sum(np.abs(x4)**2)\n    sum_sq_X_scaled = np.sum(np.abs(X4)**2) / N4\n    err4 = np.abs(sum_sq_x - sum_sq_X_scaled)\n    results.append(err4)\n\n    # Test 5: Edge case N=1\n    x5 = np.array([3 + 4j])\n    X5 = fft(x5)\n    x5_prime = ifft(X5)\n    err5 = np.abs(x5_prime[0] - x5[0])\n    results.append(err5 <= epsilon)\n\n    # Test 6: Smallest nontrivial size N=2\n    x6 = np.array([1, -1], dtype=float)\n    X6 = fft(x6)\n    X_exact = np.array([0, 2], dtype=complex)\n    err6 = np.max(np.abs(X6 - X_exact))\n    results.append(err6)\n\n    # Format and print final output\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2387187"}]}