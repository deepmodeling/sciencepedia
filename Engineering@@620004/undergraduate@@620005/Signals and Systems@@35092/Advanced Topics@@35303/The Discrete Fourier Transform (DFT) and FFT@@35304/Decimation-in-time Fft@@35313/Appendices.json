{"hands_on_practices": [{"introduction": "The incredible speed of the Fast Fourier Transform (FFT) algorithm hinges on a \"divide and conquer\" strategy. For the Decimation-in-Time (DIT) approach, this starts with a clever reordering of the input data before any calculations begin. This exercise [@problem_id:1711351] focuses squarely on this crucial first step, challenging you to understand the bit-reversal permutation and how it determines which pairs of input samples are fed into the first stage of butterfly computations.", "problem": "In the implementation of a Radix-2 Decimation-in-Time (DIT) Fast Fourier Transform (FFT) algorithm, the input sequence `x[n]` is first reordered based on a bit-reversal permutation before the butterfly computations commence. The reordered sequence, let's call it `x'[m]`, is formed by moving the input sample `x[n]` to the new index `m`, where `m` is the bit-reversed value of the original index `n`.\n\nAfter this permutation, the algorithm proceeds through $\\log_2(N)$ stages of butterfly computations. The first stage consists of `N/2` two-point butterfly operations. Each butterfly takes a pair of adjacent elements from the reordered sequence, `x'[2j]` and `x'[2j+1]`, as its inputs for `j = 0, 1, ..., N/2 - 1`.\n\nConsider an input sequence `x[n]` of length `N = 32`. The sample `x[5]` is one of the two inputs to a specific butterfly in the first stage of the computation. Your task is to identify the index, `k`, of the other input sample from the original sequence, `x[k]`, that is paired with `x[5]` in this first-stage butterfly operation.", "solution": "For a Radix-2 DIT FFT with input bit-reversal, the permutation is defined by $x'[m]=x[n]$ with $m=B(n)$, where $B(\\cdot)$ denotes bit-reversal on $L=\\log_{2}(N)$ bits. For $N=32$, we have $L=5$. In the first stage, butterflies operate on adjacent entries in the reordered sequence, i.e., pairs $\\big(x'[2j],x'[2j+1]\\big)$, so if $x'[m]$ is in a butterfly, its partner index in the reordered array is $m\\oplus 1$ (XOR with $1$ toggles the least significant bit).\n\nGiven that $x[5]$ participates in a first-stage butterfly, let $m=B(5)$. Write $5$ in $5$-bit binary: $5=(00101)_{2}$. Reversing the bits yields $B(5)=(10100)_{2}=20$, hence $m=20$. Its partner index in the reordered sequence is\n$$\nm'=m\\oplus 1=20\\oplus 1=21.\n$$\nThe partner originates from index $k$ such that $B(k)=m'$, i.e., $k=B(m')$ since bit-reversal is an involution, $B(B(n))=n$. Compute $B(21)$: $21=(10101)_{2}$, whose reversal is again $(10101)_{2}$, so\n$$\nk=B(21)=21.\n$$\nTherefore, in the first-stage butterfly, $x[5]$ is paired with $x[21]$.", "answer": "$$\\boxed{21}$$", "id": "1711351"}, {"introduction": "Once the input signal is reordered, the DIT-FFT algorithm processes it through a series of computational stages known as a flowgraph. This practice [@problem_id:1711379] offers a hands-on opportunity to trace a simple, fundamental signal—the unit impulse—through the entire 8-point FFT process. By tracking how the values propagate and combine at each butterfly stage, you will gain a concrete understanding of how the algorithm systematically builds the final frequency spectrum.", "problem": "Consider the computation of an 8-point Discrete Fourier Transform (DFT) using the standard Decimation-In-Time (DIT) Fast Fourier Transform (FFT) algorithm. The input signal to the algorithm is the discrete-time unit impulse sequence, defined as $x[n] = \\delta[n]$, for $n \\in \\{0, 1, \\dots, 7\\}$.\n\nThe DIT-FFT algorithm proceeds in $\\log_2(N)$ stages for an $N$-point transform. For this 8-point transform, there are 3 stages. The process begins with bit-reversing the order of the input sequence $x[n]$ to produce the initial sequence for the first stage. The output of stage $m$ serves as the input for stage $m+1$.\n\nLet the vector of complex values entering the final stage (Stage 3) be denoted by $X_{2}[k]$ for $k \\in \\{0, 1, \\dots, 7\\}$. Determine the correct sequence for $X_{2}[k]$.\n\nThe twiddle factor is defined as $W_N^k = \\exp(-j\\frac{2\\pi k}{N})$. The fundamental DIT butterfly computation takes two inputs, $A$ and $B$, and produces two outputs, $A'$ and $B'$, according to the relations:\n$A' = A + W_N^k B$\n$B' = A - W_N^k B$\n\nWhich of the following represents the sequence $X_2[k]$?\n\nA. $\\{1, 1, 1, 1, 0, 0, 0, 0\\}$\n\nB. $\\{1, 1, 0, 0, 0, 0, 0, 0\\}$\n\nC. $\\{1, 1, 1, 1, 1, 1, 1, 1\\}$\n\nD. $\\{1, 0, 0, 0, 0, 0, 0, 0\\}$\n\nE. $\\{1, 0, 1, 0, 1, 0, 1, 0\\}$", "solution": "We are computing an 8-point DIT-FFT with input $x[n]=\\delta[n]$ for $n\\in\\{0,1,\\dots,7\\}$, where $x[0]=1$ and $x[n]=0$ for $n\\neq 0$. In the DIT-FFT with natural-order output, the algorithm begins by bit-reversing the input sequence. Let $\\mathrm{rev}(m)$ denote the 3-bit reversal of the index $m$. The stage-1 input is the bit-reversed sequence $v[m]=x[\\mathrm{rev}(m)]$. Since $x[n]$ is zero for all $n\\neq 0$, and $\\mathrm{rev}(0)=0$, it follows that\n$$\nv[0]=x[\\mathrm{rev}(0)]=x[0]=1,\\quad v[m]=x[\\mathrm{rev}(m)]=0\\ \\text{for}\\ m\\neq 0,\n$$\nso the sequence entering Stage 1 is $[1,0,0,0,0,0,0,0]$.\n\nAt each butterfly, with inputs $A$ and $B$, the outputs are\n$$\nA' = A + W_{8}^{k} B,\\quad B' = A - W_{8}^{k} B,\n$$\nwith $W_{8}^{k}=\\exp\\!\\left(-j\\frac{2\\pi k}{8}\\right)$. Because $B=0$ whenever it is paired with $A=1$ in this problem, the twiddle factor does not affect the nonzero computations.\n\nStage 1 (butterflies of length $2$): pairs are $(0,1)$, $(2,3)$, $(4,5)$, $(6,7)$. The only nonzero pair is $(0,1)$ with $(A,B)=(1,0)$, yielding $(A',B')=(1,1)$. All other pairs yield $(0,0)$. Therefore, the output of Stage 1 is\n$$\n[1,1,0,0,0,0,0,0].\n$$\n\nStage 2 (butterflies of length $4$): pairs are $(0,2)$ and $(1,3)$ in the first group, and $(4,6)$ and $(5,7)$ in the second group. Using the Stage 1 output, the nonzero pairs are $(0,2)$ with $(A,B)=(1,0)$ and $(1,3)$ with $(A,B)=(1,0)$, each producing $(1,1)$. The second group remains zeros. Thus, the output of Stage 2, which is the input to the final stage, is\n$$\nX_{2}[k]=[1,1,1,1,0,0,0,0].\n$$\n\nThis matches option A. (As a consistency check, Stage 3 would then combine these to yield the final DFT $X[k]=1$ for all $k$, as expected for the DFT of a unit impulse.)", "answer": "$$\\boxed{A}$$", "id": "1711379"}, {"introduction": "Bridging the gap between theory and practice is a vital skill in computational science. This advanced exercise [@problem_id:2443897] challenges you to move beyond paper-and-pencil analysis and implement the bit-reversal permutation as an efficient, iterative computer algorithm. By developing this code, you will solidify your understanding of the FFT's data access patterns, a key to appreciating the performance of optimized scientific computing libraries.", "problem": "You are asked to connect the mathematical structure of the Discrete Fourier Transform (DFT) with the data-access pattern required by a radix-$2$ decimation-in-time Fast Fourier Transform (FFT) algorithm, and then implement that access pattern as an efficient, iterative permutation generator.\n\nStarting from the definition of the Discrete Fourier Transform (DFT), for a sequence of length $N$, with $N = 2^m$ where $m \\in \\mathbb{N}$,\n$$\nX[k] = \\sum_{n=0}^{N-1} x[n] \\, e^{-j 2\\pi \\frac{k n}{N}}, \\quad k \\in \\{0,1,\\dots,N-1\\},\n$$\nderive, by repeatedly splitting the sum into even and odd indices, that the radix-$2$ decimation-in-time factorization implies an input reordering that corresponds to reversing the $m$-bit binary representation of each time index. In particular, let $k$ have the $m$-bit binary expansion $k = \\sum_{i=0}^{m-1} b_i 2^i$ with $b_i \\in \\{0,1\\}$, and define the bit-reversal map $\\pi_m$ by\n$$\n\\pi_m(k) = \\sum_{i=0}^{m-1} b_i \\, 2^{m-1-i}.\n$$\nExplain why an in-place radix-$2$ decimation-in-time FFT computes outputs in natural order when the inputs are first rearranged according to $x_{\\mathrm{reordered}}[k] = x[\\pi_m(k)]$. Your derivation should rely only on the DFT definition, binary expansion, and properties of exponentials, not on any pre-quoted FFT formulas.\n\nTask:\n- Implement a function that, given a positive integer $N$, returns the length-$N$ list of integers $[\\pi_m(0), \\pi_m(1), \\dots, \\pi_m(N-1)]$ when $N$ is a power of two, and raises an error otherwise. The implementation must:\n  - Be iterative (no recursion).\n  - Run in time $\\mathcal{O}(N)$ and space $\\mathcal{O}(1)$ beyond the output array.\n  - Use only integer and bitwise operations to construct the permutation.\n- Apply your permutation to the identity sequence $[0,1,\\dots,N-1]$ by indexing with the permutation so that the resulting list equals the permutation itself, i.e., $[\\pi_m(0), \\pi_m(1), \\dots, \\pi_m(N-1)]$.\n- Error handling: if $N$ is not a positive power of two, your program should not terminate abnormally; instead, for that test case, record a boolean indicating that an error was correctly detected.\n\nConstraints:\n- Do not use recursion.\n- Do not call any library FFT routines.\n\nTest suite:\nFor each $N$ in the set $\\{\\,1,\\,2,\\,8,\\,16,\\,12,\\,0\\,\\}$:\n- If $N$ is a positive power of two, output the list $[\\pi_m(0), \\pi_m(1), \\dots, \\pi_m(N-1)]$.\n- If $N$ is not a positive power of two (including $N=0$), output the boolean $\\,\\mathrm{True}\\,$ if your implementation detects this and handles it by raising an error, and $\\,\\mathrm{False}\\,$ otherwise.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the same order as the test suite values of $N$. Each list must be printed with brackets and comma-separated integers, and booleans must be printed as $\\,\\mathrm{True}\\,$ or $\\,\\mathrm{False}\\,$. For example, a valid final line could be\n$[ [0], [0,1], [0,4,2,6,1,5,3,7], [0,8,4,12,2,10,6,14,1,9,5,13,3,11,7,15], True, True ]$.", "solution": "The problem requires a derivation of the bit-reversal input permutation for the radix-$2$ decimation-in-time (DIT) Fast Fourier Transform (FFT) algorithm, followed by an efficient iterative implementation of the permutation generator.\n\nFirst, we shall derive the necessity of the bit-reversal permutation. The Discrete Fourier Transform (DFT) of a sequence $x[n]$ of length $N$ is defined as:\n$$\nX[k] = \\sum_{n=0}^{N-1} x[n] W_N^{kn}, \\quad k \\in \\{0, 1, \\dots, N-1\\}\n$$\nwhere $W_N = e^{-j 2\\pi/N}$ is the principal $N$-th root of unity. We consider the case where $N$ is a power of two, $N=2^m$ for some non-negative integer $m$.\n\nThe principle of decimation-in-time is to split the sum over the time-domain index $n$ into even and odd terms. Let $n=2r$ for even indices and $n=2r+1$ for odd indices, where $r$ ranges from $0$ to $N/2-1$.\n$$\nX[k] = \\sum_{r=0}^{N/2-1} x[2r] W_N^{k(2r)} + \\sum_{r=0}^{N/2-1} x[2r+1] W_N^{k(2r+1)}\n$$\nUsing the property $W_N^2 = W_{N/2}$, the expression becomes:\n$$\nX[k] = \\sum_{r=0}^{N/2-1} x[2r] W_{N/2}^{kr} + W_N^k \\sum_{r=0}^{N/2-1} x[2r+1] W_{N/2}^{kr}\n$$\nThis reveals that the $N$-point DFT can be computed from two $(N/2)$-point DFTs: one of the even-indexed part of $x[n]$ (let's call it $x_e[r] = x[2r]$) and one of the odd-indexed part ($x_o[r] = x[2r+1]$). Let $X_e[k]$ and $X_o[k]$ be the respective $(N/2)$-point DFTs. Due to the periodicity of the DFT, for $k \\ge N/2$, $X_e[k] = X_e[k \\pmod{N/2}]$ and $X_o[k] = X_o[k \\pmod{N/2}]$. This yields the butterfly relations:\n$$\n\\begin{cases}\nX[k] = X_e[k] + W_N^k X_o[k] & \\text{for } 0 \\le k < N/2 \\\\\nX[k+N/2] = X_e[k] - W_N^k X_o[k] & \\text{for } 0 \\le k < N/2\n\\end{cases}\n$$\nwhere we used $W_N^{k+N/2} = W_N^k W_N^{N/2} = -W_N^k$.\n\nThis decomposition can be applied recursively. At each stage of decimation, we sort the sequence based on whether the indices are even or odd. Let us trace the position of a single input sample $x[n]$. The index $n$ has an $m$-bit binary representation, $n = (b_{m-1} b_{m-2} \\dots b_1 b_0)_2 = \\sum_{i=0}^{m-1} b_i 2^i$.\n\nAt the first decimation stage, the sequence is split based on the parity of $n$, which is determined by its least significant bit (LSB), $b_0$. All samples $x[n]$ with $b_0=0$ (even) are grouped together, and all samples with $b_0=1$ (odd) are grouped together.\nIn a conceptual tree of computations, this corresponds to branching based on $b_0$. If we were to reorder the input array so that all even-indexed elements come first, followed by all odd-indexed elements, the position of $x[n]$ would now depend on $b_0$ as its most significant bit (MSB).\n\nAt the second stage, each of these two groups is decimated further. For instance, the even group $\\{x[2r]\\}$ is split based on the parity of the new index $r$. The binary representation of $r$ is $(b_{m-1} b_{m-2} \\dots b_1)_2$, since $r=n/2$. The parity of $r$ is determined by its LSB, which is the bit $b_1$ of the original index $n$. This split determines the second MSB of the final shuffled index.\n\nThis process continues for $m$ stages. At stage $s$ (for $s=1, \\dots, m$), the decimation is based on the bit $b_{s-1}$ of the original index $n$. The sequence of decisions made to locate sample $x[n]$ in the fully decimated structure is $(b_0, b_1, \\dots, b_{m-1})$. If we define the final shuffled index $p$ such that its binary representation is constructed from this sequence of decisions from MSB to LSB, we get $p = (b_0 b_1 \\dots b_{m-1})_2$.\n\nLet's write this formally. The original index is $n = \\sum_{i=0}^{m-1} b_i 2^i$. The shuffled index is $p = \\sum_{i=0}^{m-1} b_i 2^{m-1-i}$. This is precisely the bit-reversal map $\\pi_m(n)$ defined in the problem.\nTherefore, the DIT decomposition naturally implies that to reach the terminal stage of length-$1$ DFTs (which are the samples themselves), the input sequence $x[n]$ must be reordered to the sequence $x'[\\pi_m(n)] = x[n]$.\n\nAn iterative, in-place FFT algorithm computes the transform bottom-up, starting with length-$2$ DFTs and proceeding through stages to length-$N$. To enable efficient in-place computation where butterfly operations access elements with a simple, regular stride, the input array must be pre-shuffled. By ordering the input as $x'[\\pi_m(n)] = x[n]$, the algorithm can proceed through its stages, and the final output values $X[k]$ will be stored in natural order, i.e., at index $k$ of the array.\n\nFor implementation, an efficient $\\mathcal{O}(N)$ iterative algorithm is required to generate the bit-reversal permutation $[\\pi_m(0), \\pi_m(1), \\dots, \\pi_m(N-1)]$. A naive approach of reversing the bits for each integer from $0$ to $N-1$ would take $\\mathcal{O}(N \\log N)$ time. An $\\mathcal{O}(N)$ algorithm can be formulated using a recurrence.\nLet $\\text{rev}[i]$ denote $\\pi_m(i)$. The base case is $\\text{rev}[0] = 0$. For $i>0$, we can compute $\\text{rev}[i]$ from a previously computed value. Consider the relationship between $i$ and $i' = i \\gg 1$ (integer division by $2$). In binary, $i'$ is $i$ with its LSB removed. The bit-reversal of $i'$ is $\\text{rev}[i']$. If we shift $\\text{rev}[i']$ to the right by one bit, we get the bit-reversal of $i'$ with a $0$ appended as the MSB. This corresponds to most of the bits of $\\text{rev}[i]$. The only missing part is the LSB of $i$ (`i & 1`), which must become the MSB of $\\text{rev}[i]$. This is achieved by shifting `i & 1` left by $m-1$ positions.\nThis leads to the recurrence relation:\n$$\n\\text{rev}[i] = (\\text{rev}[i \\gg 1] \\gg 1) \\ | \\ ((i \\ \\& \\ 1) \\ll (m-1))\n$$\nwhere `|` denotes the bitwise OR operation, `&` is bitwise AND, and `>>`, `<<` are bitwise shifts. Since $m = \\log_2 N$, it can be computed as $m = N.\\text{bit\\_length}() - 1$.\nThis relation allows for an iterative computation of the entire permutation array `rev` in $\\mathcal{O}(N)$ time, as each step takes constant time and there are $N$ steps. The space complexity is $\\mathcal{O}(1)$ beyond the $\\mathcal{O}(N)$ storage for the output array itself.\nA check for whether $N$ is a positive power of two can be performed efficiently using the bitwise trick `(N > 0) and (N & (N - 1) == 0)`.", "answer": "```python\nimport numpy as np\n# Per problem specification, numpy and scipy are part of the execution environment.\n# They are not used in the solution logic to adhere to problem constraints.\n\ndef generate_bit_reversal_permutation(N: int) -> list[int]:\n    \"\"\"\n    Generates the bit-reversal permutation for a given size N.\n\n    Args:\n        N: The size of the sequence, must be a positive power of two.\n\n    Returns:\n        A list of integers representing the bit-reversal permutation.\n\n    Raises:\n        ValueError: If N is not a positive power of two.\n    \"\"\"\n    # Validate that N is a positive power of two.\n    # The expression `(N & (N - 1) == 0)` is true for powers of two.\n    # `N > 0` excludes the case N=0.\n    if not (N > 0 and (N & (N - 1) == 0)):\n        raise ValueError(\"N must be a positive power of two.\")\n\n    if N == 1:\n        return [0]\n\n    # m is the number of bits required to represent numbers up to N-1.\n    # For N=2^m, the number of bits is m.\n    # In Python, m = log2(N) can be found using N.bit_length() - 1.\n    m = N.bit_length() - 1\n\n    # `rev` will store the permutation, where rev[i] is the bit-reversal of i.\n    rev = [0] * N\n\n    # The algorithm computes rev[i] based on rev[i >> 1] in O(1) time.\n    # Total time complexity is O(N).\n    for i in range(1, N):\n        # rev[i >> 1] is the bit-reversal of i with its LSB dropped.\n        # Shifting this right by 1 makes space for the new MSB.\n        # (i & 1) is the LSB of i.\n        # Shifting this left by m-1 positions makes it the MSB.\n        rev[i] = (rev[i >> 1] >> 1) | ((i & 1) << (m - 1))\n        \n    return rev\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the final output.\n    \"\"\"\n    test_cases = [1, 2, 8, 16, 12, 0]\n    results = []\n\n    for N in test_cases:\n        try:\n            # Attempt to generate the permutation for the given N.\n            permutation = generate_bit_reversal_permutation(N)\n            results.append(permutation)\n        except ValueError:\n            # If a ValueError is raised, it means the invalid N was correctly detected.\n            # As per the problem, we record `True` in this case.\n            results.append(True)\n    \n    # Format the output string according to the strict problem specification.\n    # Lists are formatted as `[item1,item2,...]` with no spaces.\n    # Booleans are formatted as `True` or `False`.\n    # The entire result is a comma-separated list enclosed in brackets.\n    results_str = []\n    for res in results:\n        if isinstance(res, list):\n            # Custom formatting for lists to match the required output style\n            results_str.append(f\"[{','.join(map(str, res))}]\")\n        else:\n            # Standard string representation for booleans (True/False)\n            results_str.append(str(res))\n    \n    print(f\"[{','.join(results_str)}]\")\n\nsolve()\n```", "id": "2443897"}]}