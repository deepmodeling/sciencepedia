{"hands_on_practices": [{"introduction": "Understanding the OR gate begins with its core principle: the output is true if at least one input is true. This exercise [@problem_id:1970234] moves beyond a simple truth table by framing this principle as a counting problem within a practical, hypothetical scenario. By determining how many fault conditions can trigger a vehicle's warning system, you will develop an intuitive and quantitative feel for the OR gate's fundamental behavior.", "problem": "A simplified diagnostic system for a vehicle's engine monitors four key subsystems: fuel pressure, oil temperature, coolant level, and battery voltage. For each subsystem, a sensor outputs a single binary signal: a `0` if the subsystem is operating within its normal parameters, and a `1` if it has registered a fault. A central warning light on the dashboard is designed to illuminate if a fault is detected in *at least one* of these four subsystems.\n\nAssuming each sensor's output is independent and can be either `0` or `1`, determine the total number of distinct four-signal combinations from the sensors that will cause the warning light to illuminate.", "solution": "Each subsystem's sensor output is binary, so each sensor has $2$ possible outputs. With four independent sensors, the multiplication principle gives the total number of four-signal combinations as\n$$\n2^{4}.\n$$\nThe warning light illuminates if at least one sensor outputs $1$. Using the complement principle, the number of combinations that do not trigger the light corresponds to the case with no faults, i.e., all four outputs are $0$, which is exactly\n$$\n1\n$$\ncombination.\n\nTherefore, the number of combinations that do trigger the warning light is\n$$\n2^{4} - 1 = 16 - 1 = 15.\n$$", "answer": "$$\\boxed{15}$$", "id": "1970234"}, {"introduction": "In digital logic design, efficiency and standardization often lead to building complex circuits from a single type of gate. This practice problem [@problem_id:1970226] challenges you to implement the OR function using only NAND gates, which are known as \"universal gates\". Solving this puzzle requires applying De Morgan’s laws and solidifies the understanding that logical functions can be realized in multiple, equivalent ways, a key skill in circuit optimization.", "problem": "In digital logic circuit design, NAND gates are known as \"universal gates\" because they can be used to construct any other type of logic gate. Consider the Boolean function for a 2-input OR gate, given by the expression $F = A + B$, where $A$ and $B$ are the inputs. Your task is to implement this OR function using only 2-input NAND gates. What is the minimum number of 2-input NAND gates required to construct a circuit that correctly performs the 2-input OR operation?", "solution": "We seek to realize the Boolean OR function $F=A+B$ using only 2-input NAND gates. A 2-input NAND computes $\\operatorname{NAND}(X,Y)=\\overline{X \\cdot Y}$. By De Morgan’s law,\n$$\nA+B=\\overline{\\overline{A}\\cdot \\overline{B}}.\n$$\nUsing only NAND gates, we can generate a NOT by tying a gate’s inputs together:\n$$\n\\operatorname{NAND}(A,A)=\\overline{A\\cdot A}=\\overline{A}, \\quad \\operatorname{NAND}(B,B)=\\overline{B}.\n$$\nFeeding these two complemented signals into a third NAND gate yields\n$$\n\\operatorname{NAND}(\\overline{A},\\overline{B})=\\overline{\\overline{A}\\cdot \\overline{B}}=A+B.\n$$\nTherefore, three 2-input NAND gates suffice.\n\nTo show minimality, note that with a single NAND gate the only possible outputs are $\\overline{A\\cdot B}$, $\\overline{A}$, or $\\overline{B}$, none of which equals $A+B$. With two NAND gates, consider the possible topologies:\n1) Let $X=\\operatorname{NAND}(A,B)=\\overline{A\\cdot B}$. The second gate can produce $\\operatorname{NAND}(X,X)=A\\cdot B$, or $\\operatorname{NAND}(X,A)=\\overline{X\\cdot A}=\\overline{A\\cdot \\overline{B}}=\\overline{A}+B$, or $\\operatorname{NAND}(X,B)=A+\\overline{B}$. None equals $A+B$.\n2) If the first gate inverts one input, e.g., $X=\\operatorname{NAND}(A,A)=\\overline{A}$, then the second gate output is $\\operatorname{NAND}(X,B)=\\overline{\\overline{A}\\cdot B}=A+\\overline{B}$ (symmetrically, $\\overline{A}+B$ if inverting $B$ first), which again is not $A+B$.\n\nSince two NAND gates cannot realize $A+B$ and three can, the minimum number required is three.", "answer": "$$\\boxed{3}$$", "id": "1970226"}, {"introduction": "How can we be certain that a manufactured logic gate works correctly? This question is central to the field of hardware testing, and this exercise [@problem_id:1970239] introduces a fundamental concept used to answer it: the stuck-at fault model. You will devise a minimal set of test inputs to verify the functionality of an OR gate, learning to think not just about how a gate should work, but also about the specific ways it might fail.", "problem": "In the quality assurance process for manufacturing digital integrated circuits, a common approach is to use simplified fault models to generate test patterns. One of the most widely used models is the single stuck-at fault model. This model assumes that a defect in the circuit will cause a single line (an input or an output of a gate) to be permanently fixed at a logic 0 (stuck-at-0) or a logic 1 (stuck-at-1).\n\nConsider a single 3-input OR gate, a fundamental component in a larger digital system. This gate has inputs labeled $A$, $B$, and $C$, and an output $Z$. A test vector is a specific combination of logic values applied to the inputs $(A, B, C)$. To detect a particular fault, a test vector must be chosen such that the output $Z$ of the faulty gate is different from the output of a fault-free gate.\n\nYour task is to identify the minimal set of input test vectors required to detect all possible single stuck-at-0 and single stuck-at-1 faults on the three inputs ($A, B, C$) of this OR gate. Below are several possible sets of test vectors, where each vector is represented in the format $(ABC)$.\n\nWhich of the following options represents the minimal test set?\n\nA. $\\{(000), (111)\\}$\n\nB. $\\{(001), (010), (100)\\}$\n\nC. $\\{(000), (001), (010), (100)\\}$\n\nD. $\\{(000), (110), (101), (011)\\}$\n\nE. $\\{(000), (001), (010), (011), (100), (101), (110), (111)\\}$", "solution": "Let the 3-input OR gate implement $Z = A \\lor B \\lor C$, which we denote algebraically as $Z = A + B + C$ (logical OR).\n\nUnder the single stuck-at fault model on inputs only, to detect a fault on a given input line, a test vector must both:\n1) Activate the fault: drive the line to the opposite value of the stuck value.\n2) Propagate the fault effect to the output: ensure the output depends on that line so that the faulty and fault-free outputs differ.\n\nDetection conditions for an OR gate:\n- To detect a stuck-at-0 on input $X \\in \\{A,B,C\\}$, we must set $X=1$ (activation) and force all other inputs to $0$ (propagation), so that the fault-free output is $1$ whereas with $X$ stuck at $0$ the output becomes $0$. Thus, the required vectors are $100$ for $A$ stuck-at-0, $010$ for $B$ stuck-at-0, and $001$ for $C$ stuck-at-0. Any vector with another input equal to $1$ would mask the effect, since $1$ on any other input forces $Z=1$ regardless of $X$.\n- To detect a stuck-at-1 on input $X$, we must set $X=0$ (activation) and also set all other inputs to $0$ (propagation), so that the fault-free output is $0$, while with $X$ stuck at $1$ the output becomes $1$. For an OR gate, the single vector $000$ detects all three input stuck-at-1 faults simultaneously, because any one input stuck at $1$ changes $Z$ from $0$ to $1$.\n\nTherefore, a minimal complete test set that detects all six single input faults is $\\{000,100,010,001\\}$. No smaller set can work: detecting all three stuck-at-0 faults requires three distinct singleton-$1$ patterns, and detecting any stuck-at-1 fault requires $000$ (no vector containing a $1$ can detect an input stuck-at-1 on an OR gate, since $Z$ would be $1$ both fault-free and faulty).\n\nChecking the options:\n- A: $\\{000,111\\}$ fails to detect any stuck-at-0 faults.\n- B: $\\{001,010,100\\}$ fails to detect any stuck-at-1 faults.\n- C: $\\{000,001,010,100\\}$ matches the minimal set derived.\n- D: $\\{000,110,101,011\\}$ fails to detect stuck-at-0 faults (masking).\n- E: All $8$ vectors detect all faults but is not minimal.\n\nHence the minimal test set is option C.", "answer": "$$\\boxed{C}$$", "id": "1970239"}]}