{"hands_on_practices": [{"introduction": "To begin our hands-on exploration, we'll start with the most fundamental operation: arithmetic. This exercise simulates a scenario within a microcontroller where you must add a positive and a negative number using 6-bit two's complement representation. Mastering this process is crucial, as it reveals the elegance of two's complement in simplifying hardware by turning subtraction into a straightforward addition operation.", "problem": "A microcontroller for a specialized cryogenic system uses a 6-bit architecture to process sensor data. It represents signed integer values for temperature fluctuations around a stable setpoint using two's complement representation. The system is initially in a state with a temperature fluctuation recorded as the decimal value $+12$. During an experimental procedure, a cooling pulse is applied, which the system registers as a change of $-25$ in the same units. The microcontroller computes the new temperature fluctuation value by adding the initial value to the registered change.\n\nWhat is the final 6-bit binary value representing the new temperature fluctuation as stored in the microcontroller's register?\n\nA. $\\mathtt{110011}$\n\nB. $\\mathtt{001101}$\n\nC. $\\mathtt{110010}$\n\nD. $\\mathtt{011011}$\n\nE. $\\mathtt{100111}$", "solution": "A 6-bit two's complement system represents integers in the range from $-2^{5}$ to $2^{5}-1$, i.e., from $-32$ to $31$. The initial value is $+12$, and the change is $-25$. The updated value is computed by addition:\n$$12+(-25)=-13.$$\nSince $-13$ lies within the representable range, we convert $-13$ to 6-bit two's complement. First write $13$ in binary using 6 bits. Because $13=8+4+1$, its binary form is\n$$13 \\rightarrow \\mathtt{001101}.$$\nTo obtain $-13$ in two's complement, invert all bits and add $1$:\n$$\\text{invert}(\\mathtt{001101})=\\mathtt{110010},$$\n$$\\mathtt{110010}+1=\\mathtt{110011}.$$\nWe can verify the value by evaluating the weighted sum for two's complement: for $\\mathtt{110011}$, the value is\n$$-2^{5}+2^{4}+2^{1}+2^{0}=-32+16+2+1=-13,$$\nwhich matches the computed result. Therefore, the final 6-bit register value is $\\mathtt{110011}$, corresponding to option A.", "answer": "$$\\boxed{A}$$", "id": "1973785"}, {"introduction": "Now that we've seen a successful calculation, let's explore the boundaries of the system. This practice [@problem_id:1973830] confronts a seemingly simple sum, $5 + 5$, but within the tight constraints of a 4-bit register. This will allow you to directly observe the phenomenon of \"overflow,\" a critical concept in digital systems where the result of an operation is too large to be represented, leading to an unexpected and incorrect outcome.", "problem": "A computer engineering student is designing a simple custom processor with a Minimal Arithmetic Logic Unit (MALU). This MALU is designed to operate on fixed-size registers. Each register in the MALU is 4 bits wide, and all signed integers are stored using the two's complement representation scheme.\n\nThe student wishes to test the adder circuit by performing the operation $A + B$, where the decimal value of operand A is 5 and the decimal value of operand B is also 5. The addition is performed in binary, and the 4-bit result is stored in a destination register. Due to the limited size of the register, the final stored bit pattern may not represent the true mathematical sum.\n\nWhat is the decimal integer value represented by the 4-bit pattern stored in the destination register after this operation?", "solution": "A 4-bit two's complement register represents signed integers in the range $[-2^{3}, 2^{3}-1] = [-8, 7]$. The value of a 4-bit word $b_{3}b_{2}b_{1}b_{0}$ is\n$$\nV(b_{3}b_{2}b_{1}b_{0}) = -b_{3}2^{3} + b_{2}2^{2} + b_{1}2^{1} + b_{0}2^{0}.\n$$\nThe decimal value $5$ fits in this range, and its 4-bit two's complement representation is $0101_{2}$. Adding $A=B=5$ with a 4-bit adder yields the modulo $2^{4}$ sum:\n$$\n(5 + 5) \\bmod 2^{4} = 10 \\bmod 16 = 10,\n$$\nwhose 4-bit binary pattern is $1010_{2}$. Interpreting this stored pattern as a two's complement number gives\n$$\nV(1010) = -1 \\cdot 2^{3} + 0 \\cdot 2^{2} + 1 \\cdot 2^{1} + 0 \\cdot 2^{0} = -8 + 2 = -6.\n$$\nThis reflects signed overflow (the true sum $10$ lies outside $[-8, 7]$), but the destination register holds the pattern $1010_{2}$, which represents the decimal value $-6$.", "answer": "$$\\boxed{-6}$$", "id": "1973830"}, {"introduction": "This final practice connects our low-level understanding of two's complement arithmetic to real-world software performance. We will analyze a common compiler optimization where multiplication by 3 is replaced by a faster bit shift and addition, formalized as $(x \\ll 1) + x$. Your task in this thought experiment [@problem_id:1973825] is to determine for which values this optimization fails due to overflow, demonstrating that what is mathematically true is not always computationally valid in a finite-bit system.", "problem": "Consider an 8-bit two's complement integer, denoted by $x$. In this system, integers can range from -128 to 127. A common compiler optimization for multiplication by a small constant is to use shifts and additions. For instance, multiplication by 3 can be expressed as $3x = 2x + x$. In terms of bitwise operations, this might be implemented as the computation `(x << 1) + x`.\n\nLet's analyze the validity of this optimization under the identity $3x = (x \\ll 1) + x$. Here, $x$ is an 8-bit two's complement integer variable. The operation `x << 1` denotes a **logical** left shift of the bit pattern of $x$ by one position. The `+` operation represents standard 8-bit two's complement addition. The left side of the identity, $3x$, represents the true mathematical product, which may fall outside the 8-bit representable range. The right side represents the result of the computation as performed by an 8-bit processor.\n\nDetermine the total number of distinct integer values of $x$ in the 8-bit two's complement range for which this identity fails, i.e., the computed result of `(x << 1) + x` is not equal to the mathematical value of $3x$.", "solution": "Let $x$ be an 8-bit two's complement integer, so $x \\in \\{-128,-127,\\dots,127\\}$. On an 8-bit processor:\n- Logical left shift by one, $x \\ll 1$, corresponds to multiplying by $2$ modulo $256$; that is,\n$$\nx \\ll 1 \\equiv 2x \\pmod{256}.\n$$\n- Two's complement 8-bit addition corresponds to addition modulo $256$.\n\nTherefore, the computed expression satisfies\n$$\n(x \\ll 1) + x \\equiv (2x) + x \\equiv 3x \\pmod{256}.\n$$\nInterpreting the 8-bit result as a signed integer means it equals the unique integer in $\\{-128,\\dots,127\\}$ congruent to $3x \\pmod{256}$. Hence the computed result equals the true mathematical value $3x$ if and only if $3x$ itself lies in the representable range $[-128,127]$. Thus the identity holds exactly for those $x$ satisfying\n$$\n-128 \\leq 3x \\leq 127.\n$$\nDividing by $3$ (preserving inequalities since $3>0$) gives\n$$\n-\\frac{128}{3} \\leq x \\leq \\frac{127}{3}.\n$$\nWith $x$ integral, this is\n$$\nx \\in \\left[\\left\\lceil -\\frac{128}{3} \\right\\rceil,\\ \\left\\lfloor \\frac{127}{3} \\right\\rfloor\\right] = [-42,\\,42].\n$$\nThe number of such $x$ is\n$$\n42 - (-42) + 1 = 85.\n$$\nSince there are $256$ total 8-bit two's complement values, the number of $x$ for which the identity fails is\n$$\n256 - 85 = 171.\n$$", "answer": "$$\\boxed{171}$$", "id": "1973825"}]}