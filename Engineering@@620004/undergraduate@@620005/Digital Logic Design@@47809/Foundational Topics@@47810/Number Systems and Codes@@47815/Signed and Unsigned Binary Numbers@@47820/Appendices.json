{"hands_on_practices": [{"introduction": "Before we can explore complex operations, we must master the fundamentals of number representation. This first exercise focuses on the core skill of interpreting and performing arithmetic with numbers in the two's complement format, which is the standard way modern computers represent signed integers. By working through the addition of a positive and a negative number within a fixed-bit system, you will solidify your understanding of how to convert these binary patterns into their correct decimal values [@problem_id:1960895].", "problem": "In a custom-built microcontroller designed for a physics experiment, data values are processed using 6-bit registers. Signed integers within this system are represented using two's complement encoding.\n\nTwo registers, `R1` and `R2`, store the binary values `011011` and `101010`, respectively. An arithmetic logic unit (ALU) is instructed to compute the sum of the signed integers stored in these two registers.\n\nCalculate the result of the operation `R1 + R2`. Express your final answer as a single signed decimal integer.", "solution": "In a 6-bit two's complement system, the representable range is from $-2^{5}$ to $2^{5}-1$, i.e., $[-32, 31]$. For a 6-bit word $b_{5}b_{4}b_{3}b_{2}b_{1}b_{0}$, if $b_{5}=0$ the value is the usual unsigned sum, and if $b_{5}=1$ the value is negative, equal to the negative of the two's complement magnitude.\n\nRegister $R1$ has $011011_{2}$ with most significant bit $0$, hence it is nonnegative and its value is computed by positional weights:\n$$\n\\operatorname{val}(R1)=0\\cdot 2^{5}+1\\cdot 2^{4}+1\\cdot 2^{3}+0\\cdot 2^{2}+1\\cdot 2^{1}+1\\cdot 2^{0}=16+8+2+1=27.\n$$\n\nRegister $R2$ has $101010_{2}$ with most significant bit $1$, hence it is negative. Its two's complement magnitude is obtained by inverting bits and adding $1$:\n$$\n101010_{2}\\ \\xrightarrow{\\text{invert}}\\ 010101_{2}\\ \\xrightarrow{+1}\\ 010110_{2}.\n$$\nThus the magnitude is\n$$\n|R2|=0\\cdot 2^{5}+1\\cdot 2^{4}+0\\cdot 2^{3}+1\\cdot 2^{2}+1\\cdot 2^{1}+0\\cdot 2^{0}=16+4+2=22,\n$$\nso\n$$\n\\operatorname{val}(R2)=-22.\n$$\n\nThe ALU computes the sum of the signed integers:\n$$\n\\operatorname{val}(R1)+\\operatorname{val}(R2)=27+(-22)=5.\n$$\nSince $5\\in[-32,31]$, there is no overflow, and the result is the signed decimal integer $5$.", "answer": "$$\\boxed{5}$$", "id": "1960895"}, {"introduction": "In digital systems, a single string of bits can represent different values depending on the context. This practice challenges you to consider this duality by performing a single binary addition and interpreting the result in two ways: as an unsigned integer and as a signed integer [@problem_id:1960891]. You will also confront a critical issue in computer arithmetic: overflow. This occurs when a calculation's result is too large to be represented in the available number of bits, leading to an incorrect signed value, a concept you will explore by determining the state of the overflow flag.", "problem": "A custom-designed 8-bit microprocessor for an embedded system represents signed integers using the two's complement format. The Arithmetic Logic Unit (ALU) within this processor is tasked with adding two values originating from different system status registers. The two values are provided as the hexadecimal numbers `B4` and `9A`. Your task is to perform this addition as the ALU would. After the addition, the 8-bit binary result is used for two separate purposes: as an unsigned integer for a checksum calculation, and for an overflow check on the signed operation.\n\nDetermine:\n1. The value of the 8-bit sum when interpreted as an *unsigned* integer, expressed in decimal.\n2. A single binary digit indicating the status of the arithmetic overflow flag for the *signed* addition (1 if an overflow occurs, 0 if it does not).\n\nProvide these two values as a pair, in the order specified.", "solution": "We model the ALU operation as 8-bit addition modulo $2^{8}$. Let the two given 8-bit operands be interpreted as hexadecimal numbers B4 and 9A. Converting to decimal for ease of arithmetic:\n$$\n\\text{B4} = 11 \\cdot 16 + 4 = 180, \\quad \\text{9A} = 9 \\cdot 16 + 10 = 154.\n$$\nThe arithmetic sum in unbounded integers is\n$$\n180 + 154 = 334.\n$$\nSince the ALU is 8-bit, the stored result is the sum modulo $2^{8}$:\n$$\ns \\equiv 334 \\pmod{2^{8}} \\quad \\Rightarrow \\quad s = 334 - 256 = 78.\n$$\nEquivalently in hexadecimal, $\\text{B4} + \\text{9A} = \\text{14E}$, and the 8-bit result is the lower byte $\\text{4E}$, which is $4 \\cdot 16 + 14 = 78$ in decimal. Thus, when interpreted as an unsigned 8-bit integer, the sum is $78$.\n\nFor the signed overflow flag in two’s complement, overflow occurs if and only if the two addends have the same sign and the result has the opposite sign. In 8-bit two’s complement, the sign bit is the most significant bit. The binary forms are\n$$\n\\text{B4} = 10110100_{2}, \\quad \\text{9A} = 10011010_{2}, \\quad \\text{result} = 01001110_{2}.\n$$\nBoth inputs have sign bit $1$ (they are negative), while the 8-bit result has sign bit $0$ (it appears nonnegative). Therefore, an overflow has occurred, and the overflow flag is $1$. This is consistent with interpreting the inputs as signed values $-76$ and $-102$, whose true sum is $-178$, which lies outside the representable 8-bit two’s complement range $[-128, 127]$.\n\nThe required pair is the unsigned 8-bit sum in decimal and the overflow flag bit, in that order.", "answer": "$$\\boxed{\\begin{pmatrix}78  1\\end{pmatrix}}$$", "id": "1960891"}, {"introduction": "Processors use status flags to signal the outcome of arithmetic operations, but their meanings can be subtle and are often confused. This exercise tackles one of the most common points of confusion: the difference between the carry-out flag ($C_{out}$) and the overflow flag ($V$). By analyzing several addition scenarios, you will learn to identify a case where adding two numbers generates a carry-out from the most significant bit, but the signed result remains valid and does not trigger an overflow [@problem_id:1960941]. Mastering this distinction is essential for understanding low-level programming and computer architecture.", "problem": "In digital systems, signed integers are commonly represented using the two's complement format. Consider an 8-bit processor that performs arithmetic on such numbers. The valid range for an 8-bit two's complement number is from -128 to +127. When two numbers are added, two important flags are often considered: the carry-out flag ($C_{out}$) from the most significant bit (MSB), and the overflow flag ($V$), which indicates if the result is arithmetically incorrect because it falls outside the representable range.\n\nYou are given four pairs of 8-bit two's complement numbers. Your task is to identify which pair, when added together, results in a carry-out from the MSB ($C_{out} = 1$) but does **not** result in an arithmetic overflow ($V = 0$).\n\nWhich of the following pairs of 8-bit two's complement numbers satisfies these criteria?\n\nA. `11111111` and `11111110`\n\nB. `10011100` and `10011100`\n\nC. `01100100` and `01100100`\n\nD. `00010100` and `00011110`", "solution": "The problem asks us to find a pair of 8-bit two's complement numbers that, when added, produce a carry-out from the most significant bit (MSB), but do not cause an arithmetic overflow.\n\nFirst, let's establish the rules for two's complement arithmetic in 8 bits.\nThe range of representable numbers is $[-2^{8-1}, 2^{8-1}-1]$, which is $[-128, 127]$.\nA number is negative if its MSB (bit 7) is 1, and positive or zero if its MSB is 0.\n\nAn arithmetic overflow occurs under two conditions:\n1.  The sum of two positive numbers results in a negative number (MSB of sum is 1).\n2.  The sum of two negative numbers results in a positive number (MSB of sum is 0).\nThe sum of a positive and a negative number can never cause an overflow.\n\nThe carry-out ($C_{out}$) is the carry generated from the addition at the MSB position (bit 7).\n\nA common way to detect overflow is by comparing the carry-in to the MSB ($C_{in,7}$) and the carry-out from the MSB ($C_{out}$). Overflow occurs if and only if $C_{in,7} \\neq C_{out}$. The problem statement requires no overflow, which means we are looking for a case where $C_{in,7} = C_{out}$. Since the problem also requires $C_{out}=1$, we are specifically looking for a case where $C_{in,7}=1$ and $C_{out}=1$.\n\nLet's analyze each option.\n\n**A. `11111111` and `11111110`**\n- **Decimal Values:**\n  - `11111111` is the two's complement representation of -1.\n  - `11111110` is the two's complement representation of -2.\n- **Expected Sum:** $(-1) + (-2) = -3$. This value is within the range [-128, 127], so no overflow should occur.\n- **Binary Addition:**\n  ```\n     11111111   (carries)\n     11111111   (-1)\n   + 11111110   (-2)\n   -----------\n   1 11111101\n  ```\n- **Analysis:**\n  - The 8-bit result is `11111101`, which is the two's complement of -3. The result is arithmetically correct, so there is **no overflow**.\n  - There is a carry of 1 generated from the MSB position. Thus, **$C_{out} = 1$**.\n- This pair satisfies both conditions: $C_{out} = 1$ and no overflow.\n\n**B. `10011100` and `10011100`**\n- **Decimal Values:**\n  - `10011100` is the two's complement of `01100100` (100). So, `10011100` represents -100.\n- **Expected Sum:** $(-100) + (-100) = -200$. This value is outside the range [-128, 127]. An overflow must occur.\n- **Binary Addition:**\n  ```\n      11  111     (carries)\n     10011100   (-100)\n   + 10011100   (-100)\n   -----------\n   1 01011000\n  ```\n- **Analysis:**\n  - The 8-bit result is `01011000`, which represents +88. Since we added two negative numbers and got a positive result, an **overflow has occurred**.\n  - There is a carry of 1 generated from the MSB position. Thus, **$C_{out} = 1$**.\n- This pair does not satisfy the \"no overflow\" condition.\n\n**C. `01100100` and `01100100`**\n- **Decimal Values:**\n  - `01100100` represents +100.\n- **Expected Sum:** $100 + 100 = 200$. This value is outside the range [-128, 127]. An overflow must occur.\n- **Binary Addition:**\n  ```\n     1  1        (carries)\n     01100100   (+100)\n   + 01100100   (+100)\n   -----------\n   0 11001000\n  ```\n- **Analysis:**\n  - The 8-bit result is `11001000`, which represents -56. Since we added two positive numbers and got a negative result, an **overflow has occurred**.\n  - There is no carry generated from the MSB position. Thus, **$C_{out} = 0$**.\n- This pair fails both conditions.\n\n**D. `00010100` and `00011110`**\n- **Decimal Values:**\n  - `00010100` represents +20.\n  - `00011110` represents +30.\n- **Expected Sum:** $20 + 30 = 50$. This value is within the range [-128, 127], so no overflow should occur.\n- **Binary Addition:**\n  ```\n       111       (carries)\n     00010100   (+20)\n   + 00011110   (+30)\n   -----------\n   0 00110010\n  ```\n- **Analysis:**\n  - The 8-bit result is `00110010`, which represents +50. The result is arithmetically correct, so there is **no overflow**.\n  - There is no carry generated from the MSB position. Thus, **$C_{out} = 0$**.\n- This pair does not satisfy the $C_{out}=1$ condition.\n\n**Conclusion:**\nOnly the pair in option A, `11111111` and `11111110`, results in a carry-out of 1 from the MSB while also producing a correct sum (no overflow).", "answer": "$$\\boxed{A}$$", "id": "1960941"}]}