{"hands_on_practices": [{"introduction": "To begin our hands-on exploration, we address the most fundamental concept defining a combinational circuit: its output is determined exclusively by its current inputs. This exercise [@problem_id:1959207] presents a scenario that directly tests this principle by asking you to classify a circuit that performs a seemingly complex arithmetic check. Your task is to look past the \"algorithm\" you might use to solve the problem mentally and focus on whether the circuit needs to remember any past information to produce its output.", "problem": "A digital logic circuit is to be designed to check for a specific property of a 4-bit unsigned binary number, represented by the inputs $B_3 B_2 B_1 B_0$, where $B_3$ is the most significant bit. The circuit has a single output, $Y$, which is logic '1' if the decimal equivalent of the input number is divisible by 3, and logic '0' otherwise. Assume all 4 input bits are available simultaneously (in parallel).\n\nConsidering the most direct implementation based on the fundamental definitions of logic circuit types, which of the following statements is the most accurate description of this circuit?\n\nA. The circuit must be sequential because checking for divisibility is an arithmetic process that inherently involves a sequence of steps, similar to long division, requiring state to be maintained.\n\nB. The circuit is best classified as combinational because for any given 4-bit input pattern, the output is fixed and depends solely on the current values of the input bits, not on any past inputs or states.\n\nC. The circuit could be implemented as either combinational or sequential, but the sequential implementation would be more efficient as it can process the bits one by one, reducing the required number of logic gates.\n\nD. The circuit must be sequential because determining divisibility by 3 for a binary number requires knowing the remainder from previous bit positions, which must be stored in a memory element like a flip-flop.\n\nE. The circuit is best classified as combinational, but only if the output is allowed to have a propagation delay. If an instantaneous output is required, a sequential circuit is necessary.", "solution": "Define the 4-bit unsigned integer represented by the parallel inputs as $N = B_{3}2^{3} + B_{2}2^{2} + B_{1}2^{1} + B_{0}2^{0}$, where each $B_{i} \\in \\{0,1\\}$ and $B_{3}$ is the most significant bit. The required output is the Boolean function $Y$ given by\n$$\nY = \\begin{cases}\n1, & \\text{if } 3 \\text{ divides } N,\\\\\n0, & \\text{otherwise}.\n\\end{cases}\n$$\nBy the fundamental definitions in digital logic, a combinational circuit is one in which outputs are functions solely of the current inputs, with no dependence on past inputs or internal stored state; a sequential circuit is one in which outputs depend on current inputs and on internal state that encodes past inputs (memory elements such as latches or flip-flops).\n\nSince all four input bits are provided simultaneously (in parallel), $N$ is fully determined at the current time by $(B_{3},B_{2},B_{1},B_{0})$. Therefore $Y$ is a function $f:\\{0,1\\}^{4} \\to \\{0,1\\}$, which can be implemented as a purely combinational network. An explicit construction is obtained by enumerating the 4-bit values that are multiples of $3$ in the range $0$ to $15$:\n$$\n\\{0,3,6,9,12,15\\}.\n$$\nIn binary, these correspond to input patterns $(B_{3}B_{2}B_{1}B_{0})$ equal to $0000, 0011, 0110, 1001, 1100, 1111$. Using canonical sum-of-minterms form (with $+$ as OR, juxtaposition as AND, and $\\overline{\\cdot}$ as NOT), the purely combinational realization is\n$$\nY = \\overline{B_{3}}\\overline{B_{2}}\\overline{B_{1}}\\overline{B_{0}}\n+ \\overline{B_{3}}\\overline{B_{2}}B_{1}B_{0}\n+ \\overline{B_{3}}B_{2}B_{1}\\overline{B_{0}}\n+ B_{3}\\overline{B_{2}}\\overline{B_{1}}B_{0}\n+ B_{3}B_{2}\\overline{B_{1}}\\overline{B_{0}}\n+ B_{3}B_{2}B_{1}B_{0}.\n$$\nThis expression depends only on the current values of $B_{3},B_{2},B_{1},B_{0}$; it uses no memory and no notion of past inputs, hence it is combinational. Equivalently, using modular arithmetic to further justify combinational implementability, note that\n$$\n2^{0} \\equiv 1 \\pmod{3},\\quad 2^{1} \\equiv 2 \\pmod{3},\\quad 2^{2} \\equiv 1 \\pmod{3},\\quad 2^{3} \\equiv 2 \\pmod{3},\n$$\nso\n$$\nN \\bmod 3 \\equiv B_{0} + 2B_{1} + B_{2} + 2B_{3} \\pmod{3},\n$$\nwhere the right-hand side is an arithmetic sum of current input bits. The predicate “$N \\bmod 3 = 0$” can thus be tested with a purely combinational network built from adders and simple logic gates, again confirming that no state is needed.\n\nEvaluating the options:\n- A is incorrect: although long division is a sequential algorithm, hardware need not mimic that process when inputs are available in parallel; a direct combinational function exists as shown.\n- B is correct: for any given 4-bit input, the output is fixed and depends only on those current bits; a truth table or canonical sum-of-products gives a combinational realization.\n- C is misleading in this context: while one could design a sequential machine that reads bits serially and tracks the remainder modulo $3$, that is not the most direct classification for parallel inputs, and it introduces state, clocking, and latency; for a 4-bit parallel input, the natural and most direct implementation is combinational.\n- D is incorrect for parallel inputs: the “remainder from previous bit positions” argument applies to serial processing; with all bits present simultaneously, no memory is needed.\n- E is incorrect: all real circuits (combinational and sequential) have propagation delay; combinational classification does not require zero delay, and sequential circuits do not provide instantaneous outputs either.\n\nTherefore, the most accurate description is that the circuit is best classified as combinational because the output depends solely on the current input bits.", "answer": "$$\\boxed{B}$$", "id": "1959207"}, {"introduction": "Having established the nature of combinational logic, we now turn to a scenario where that model is insufficient. This practice [@problem_id:1959211] introduces a critical change: inputs arrive one by one over time, rather than all at once. This forces us to consider the core feature of sequential circuits—memory—as you design a circuit that must recognize a specific pattern in a serial data stream, a foundational task in communication and data processing systems.", "problem": "A digital system needs to monitor a single serial data line, `X`, on which bits arrive one by one, synchronized with a clock pulse. The system must design a circuit that produces an output `Z`, which goes to logic '1' for exactly one clock cycle immediately upon detecting the specific 3-bit sequence '101' in the incoming data stream. For example, if the input stream is `...011010...`, the output `Z` should be `...000010...`.\n\nWhich of the following statements provides the most accurate classification and reasoning for the type of logic circuit required for this task?\n\nA. The circuit must be combinational, as the output `Z` is a Boolean function of the three most recent input bits. These three bits can be treated as a 3-bit parallel input to the logic gates.\n\nB. The circuit must be sequential, as it needs to remember at least the two previous bits from the input stream to determine if the current bit completes the target sequence. This requires state-holding elements.\n\nC. The circuit can be either combinational or sequential. A combinational approach is simpler but a sequential one might be more power-efficient.\n\nD. The circuit must be sequential, because any circuit that uses a clock signal is, by definition, a sequential circuit.\n\nE. The circuit must be combinational, because it does not need to produce a sequence of outputs, only a single '1' when the pattern is found.", "solution": "Let the serial input at clock time index $n$ be $X_{n} \\in \\{0,1\\}$, and the output be $Z_{n} \\in \\{0,1\\}$. The specification “assert $Z$ for exactly one clock cycle immediately upon detecting the 3-bit sequence 101” means\n$$\nZ_{n} = 1 \\;\\;\\Longleftrightarrow\\;\\; (X_{n-2},\\,X_{n-1},\\,X_{n}) = (1,\\,0,\\,1),\n$$\nand $Z_{n}=0$ otherwise. Equivalently, as a Boolean expression,\n$$\nZ_{n} = X_{n-2}\\,\\overline{X_{n-1}}\\,X_{n}.\n$$\n\nTo compute $Z_{n}$ at time $n$, the circuit must have access to the values $X_{n-1}$ and $X_{n-2}$ from previous clock cycles. A purely combinational circuit’s output depends only on its current inputs; it has no mechanism to retain past inputs. Therefore, unless the previous bits are made available as simultaneous inputs, the function $Z_{n}$ cannot be realized by combinational logic alone.\n\nMaking $X_{n-1}$ and $X_{n-2}$ available at time $n$ requires storing past input values, which is precisely what state-holding elements (e.g., flip-flops in a shift register) provide. The presence and use of such memory elements define a sequential circuit. Hence the correct classification is that the circuit must be sequential because it must remember at least the two previous bits to determine whether the current bit completes the pattern $101$.\n\nEvaluating the options:\n- A is incorrect because treating the “three most recent bits” as parallel inputs already presumes storage (sequential elements) to capture past bits; combinational logic alone cannot create those inputs from a single serial stream.\n- B is correct: the circuit must be sequential, and the reasoning—needing to remember at least the two previous bits—is exact.\n- C is incorrect because a purely combinational realization is not possible for a serial input without added memory, which makes it sequential.\n- D is incorrect in its reasoning: the mere use of a clock does not, by itself, make a circuit sequential; the necessity of memory (state) does.\n- E is incorrect: even though the desired output is a single-cycle pulse, generating it on a serial stream requires memory of past bits, hence sequential logic.\n\nTherefore, the most accurate classification and reasoning are given in option B.", "answer": "$$\\boxed{B}$$", "id": "1959211"}, {"introduction": "Our final practice moves beyond simple classification into the realm of real-world engineering design. While some problems, like the previous sequence detector, demand a sequential approach, others allow for either a combinational or a sequential solution. This exercise [@problem_id:1959219] a factorial calculator, challenges you to analyze the crucial trade-offs between these two architectures, weighing the high speed of a combinational design against the resource efficiency of a sequential one.", "problem": "An engineer is tasked with designing a specialized digital circuit to compute the factorial, $F = N!$, of a 4-bit unsigned integer input, $N$. The input $N$ can range from 0 to 15. The circuit's output must be the full, un-truncated binary representation of $F$. By definition, $0! = 1$.\n\nThe engineer is considering two distinct architectural approaches for this task:\n\n1.  **Purely Combinational Design:** This circuit is conceptualized as a monolithic logic block. A common way to implement such a function is with a Read-Only Memory (ROM), where the 4-bit input $N$ acts as the address, and the corresponding output is the pre-computed value of $N!$.\n\n2.  **Sequential Design:** This circuit utilizes a datapath controlled by a Finite State Machine (FSM). The calculation is performed iteratively over several clock cycles. For instance, the circuit might initialize an accumulator to 1, and then in subsequent cycles, multiply the accumulator's value by 2, then 3, and so on, up to $N$. Assume this design requires one clock cycle for each multiplication step.\n\nTo make an informed decision, a comparative analysis is required. First, determine the minimum number of bits, $W$, necessary for the output bus to represent the factorial value for all possible valid inputs. Then, evaluate the primary characteristics and resource requirements of both design approaches.\n\nWhich of the following statements provides the most accurate comparison between the two designs for this specific application?\n\nA. The combinational ROM-based design would require a memory of size $2^{15} \\times W$ bits, making it impractical. The sequential design is significantly faster because it operates on a high-frequency clock.\n\nB. The output requires $W=32$ bits. The combinational design is generally faster for any given input, while the sequential design is generally more area-efficient due to the sharing of hardware resources like the multiplier.\n\nC. The output requires $W=41$ bits. The combinational ROM-based design would have a total size of $16 \\times 41$ bits and exhibits a lower latency (faster computation) than the sequential design, which requires a number of clock cycles proportional to the input $N$.\n\nD. The output requires $W=41$ bits. The sequential design is the only viable option because a combinational implementation is logically impossible due to the super-exponential growth of the factorial function.\n\nE. The combinational design's complexity is primarily determined by the need for a $W \\times 4$ bit multiplier. In contrast, the sequential design is simpler as it only requires an FSM controller and registers.", "solution": "The output width must accommodate the largest factorial over the input range $N \\in \\{0,1,\\dots,15\\}$. The maximum value is $15!$, so the required number of bits is\n$$\nW=\\left\\lfloor \\log_{2}\\!\\left(15!\\right) \\right\\rfloor + 1.\n$$\nCompute $15!$ via successive multiplication:\n$$\n10!=3628800,\\quad 11!=39916800,\\quad 12!=479001600,\\quad 13!=6227020800,\\quad 14!=87178291200,\\quad 15!=1307674368000.\n$$\nCompare to powers of two:\n$$\n2^{40}=1099511627776,\\quad 2^{41}=2199023255552,\n$$\nand observe\n$$\n2^{40}<15!=1307674368000<2^{41}.\n$$\nTherefore,\n$$\nW=\\left\\lfloor \\log_{2}\\!\\left(15!\\right) \\right\\rfloor + 1=41.\n$$\n\nNow compare the two architectures.\n\nFor a combinational ROM-based design, a $4$-bit input addresses a ROM with $2^{4}=16$ entries. Each entry must store the full factorial value, so the ROM size is\n$$\n16 \\times W = 16 \\times 41 \\text{ bits}.\n$$\nThe latency is one combinational propagation from input to output, which is lower than any multi-cycle sequential approach for $N \\geq 2$.\n\nFor a sequential design using an FSM-controlled datapath that iteratively multiplies an accumulator by integers from $2$ up to $N$, the latency in clock cycles is proportional to $N$ (one multiplication per cycle), with a worst case on the order of $15$ cycles. The datapath needs at least a $W$-bit accumulator and a multiplier that can multiply a $W$-bit value by an integer up to $N \\leq 15$ (i.e., a $W \\times 4$-bit multiplication per step), plus control and registers. While hardware can be shared across cycles, the latency is higher than the single-cycle combinational ROM for typical technology assumptions.\n\nEvaluating the statements:\n- A is incorrect: a $4$-bit input ROM has $2^{4}=16$ addresses, not $2^{15}$, and the sequential design is not faster in latency than a single-cycle ROM.\n- B is incorrect: $W \\neq 32$; it must be $41$ bits.\n- C is correct: $W=41$, the ROM size is $16 \\times 41$ bits, and the combinational design has lower latency than the sequential design, whose cycle count scales with $N$.\n- D is incorrect: a combinational implementation is feasible here; the growth rate of the factorial function does not preclude a ROM for $N \\leq 15$.\n- E is incorrect: a combinational ROM-based design does not require a $W \\times 4$ multiplier; that applies to the sequential approach.\n\nThus, the most accurate comparison is given by option C.", "answer": "$$\\boxed{C}$$", "id": "1959219"}]}