{"hands_on_practices": [{"introduction": "In asynchronous sequential circuits, the internal state must capture not just the current inputs, but also the history of past events. A simple edge-triggered toggle circuit is a perfect illustration of this principle, as its output depends on the parity of input changes. This foundational exercise [@problem_id:1953742] will test your understanding of how internal states are used to create memory, requiring you to determine the minimum number of states needed to distinguish different operational histories.", "problem": "An asynchronous sequential circuit has a single input `x` and a single output `z`. The circuit is designed to function as an edge-triggered toggle device. Specifically, for any change on the input line `x` (either from 0 to 1 or from 1 to 0), the output `z` must toggle its current value. For example, if `z` is currently 0, the next change in `x` will cause `z` to become 1. The subsequent change in `x` will then cause `z` to become 0, and so on.\n\nAssuming the circuit is described by a primitive flow table, where each row contains exactly one stable state, determine the total number of stable states required to fully specify this behavior.", "solution": "Let the input be $x \\in \\{0,1\\}$ and the output be $z \\in \\{0,1\\}$. In a primitive flow table for an asynchronous sequential circuit with a single input, each stable state is associated with exactly one input value (the unique column in which the state is stable). Thus, for any stable state $s$, there is exactly one $i_{s} \\in \\{0,1\\}$ such that $s$ is stable when $x=i_{s}$.\n\nThe specification requires an edge-triggered toggle: on every change of $x$ (either $0 \\to 1$ or $1 \\to 0$), the output must toggle. If $z$ denotes the output just before the change, then immediately after the change it must be\n$$\nz^{+} = 1 - z.\n$$\nWhile $x$ remains constant (no change), the output must hold its current value.\n\nConsider the implications for the set of stable states $S$:\n- In any stable state $s \\in S$ with input $x=i_{s}$ held constant, the output must remain at a fixed value $z_{s} \\in \\{0,1\\}$.\n- When $x$ changes from $i_{s}$ to $1-i_{s}$, the machine must transition to a state stable under the new input, and in that new state the output must be $1 - z_{s}$.\n\nWe now show a lower bound on $|S|$.\n- Suppose, for contradiction, that $|S|=2$. Then there is one state $s_{0}$ stable for $x=0$ with output $z_{0}$ and one state $s_{1}$ stable for $x=1$ with output $z_{1}$. Whenever $x=1$ is held, the circuit must be in $s_{1}$, so the output is forced to $z_{1}$ regardless of history. However, the toggle requirement demands that, depending on the parity of the number of input changes that have occurred, both output values $0$ and $1$ must be attainable while $x=1$ is held (since each change flips $z$). This is impossible with a single state $s_{1}$ for $x=1$ having fixed output $z_{1}$. Hence $|S| \\geq 4$.\n\nWe now exhibit a construction with exactly four stable states, proving sufficiency. Define four stable states distinguished by input stability and output value:\n- $A_{0}$: stable for $x=0$, with $z=0$.\n- $A_{1}$: stable for $x=0$, with $z=1$.\n- $B_{0}$: stable for $x=1$, with $z=0$.\n- $B_{1}$: stable for $x=1$, with $z=1$.\n\nState transitions are defined by:\n- If the input remains constant, the machine stays in the same state (the unique stable column in the primitive flow table).\n- On a change of $x$ from $0$ to $1$, toggle $z$ and move $A_{0} \\to B_{1}$ and $A_{1} \\to B_{0}$.\n- On a change of $x$ from $1$ to $0$, toggle $z$ and move $B_{0} \\to A_{1}$ and $B_{1} \\to A_{0}$.\n\nThis satisfies $z^{+} = 1 - z$ on every input change and holds $z$ while $x$ is constant, with exactly one stable input per state, as required by a primitive flow table. Therefore, the minimal and sufficient number of stable states is $4$.", "answer": "$$\\boxed{4}$$", "id": "1953742"}, {"introduction": "Building on the concept of state, we now explore a practical application in robust system design. Asynchronous circuits often operate under the fundamental-mode assumption, where only one input changes at a time. This practice [@problem_id:1953732] challenges you to design a fault detector that identifies violations of this rule, introducing the critical concept of a permanent \"trap\" state to handle errors and ensure system integrity.", "problem": "An asynchronous sequential circuit is designed to operate in fundamental mode. It has two binary inputs, $X_1$ and $X_2$, and a single output, $E$.\n\nUnder normal operation, only one input is permitted to change at any given time. The circuit is given sufficient time to transition to a new stable state before the next input change occurs. The purpose of this circuit is to act as a fault detector. If both inputs $X_1$ and $X_2$ change their values simultaneously (e.g., a transition from `00` to `11`, or from `01` to `10`), the circuit must transition to a unique and permanent error state.\n\nThe output $E$ is defined to be $0$ for all normal operating states and $1$ for the error state. Once the circuit enters the error state, it must remain there indefinitely, regardless of any subsequent changes to the inputs.\n\nAssume the circuit must be capable of being stable for any of the four possible input combinations (`00`, `01`, `10`, `11`) during normal, non-error operation. A primitive flow table is a state transition table in which each row represents a unique internal state, and each row contains exactly one stable state entry (an exception can be made for a terminal \"trap\" state which may be stable for multiple or all inputs).\n\nWhat is the minimum number of rows (i.e., total internal states), including the error state, required to specify the complete primitive flow table for this fault detector?", "solution": "Because the circuit operates in fundamental mode, under normal operation only one input changes at a time and the circuit settles to a stable state before the next change. In a primitive flow table, each internal state (row) has exactly one stable input column; only a terminal trap (error) state is allowed to be stable for multiple inputs.\n\nRequirement 1 (normal stability): The machine must be capable of being stable for each of the four input combinations `00`, `01`, `10`, `11` during normal, non-error operation, with output $E=0$. Since each row in a primitive flow table may have exactly one stable input, realizing stability for all four input combinations requires at least four distinct normal internal states, one per input combination. Therefore, at least $4$ rows are required for the normal operating states.\n\nRequirement 2 (permanent error): There must be a unique permanent error state with output $E=1$ that the machine enters if both inputs change simultaneously (from `00` to `11` or from `01` to `10`). Once entered, it must remain regardless of inputs, so it must be a trap state stable for all four inputs. This error state cannot be merged with any normal state because normal states must have $E=0$ and each normal row can only be stable for a single input. Hence, at least one additional row is needed for the error trap.\n\nLower bound: Combining the above, at least $4+1=5$ rows are necessary.\n\nAchievability with $5$ rows: Use four normal rows, each stable at exactly one of the inputs `00`, `01`, `10`, `11`, and one error trap row stable for all inputs. Define transitions so that from a normal state, a single-bit input change goes directly to the corresponding adjacent normal state (preserving normal behavior), while a two-bit change (nonadjacent input) goes to the error trap. This satisfies the specification and uses only $5$ rows.\n\nTherefore, the minimum number of rows (total internal states), including the error state, is $5$.", "answer": "$$\\boxed{5}$$", "id": "1953732"}, {"introduction": "Finally, let's apply our knowledge to a more complex, real-world system: a preemptive Last-In-First-Out (LIFO) arbiter, which manages access to a shared resource. This advanced problem [@problem_id:1953743] demonstrates how the circuit's internal state can represent not just a single past event, but a structured history, like a stack of pending requests. Your task is to analyze how the sequence of events directly determines the number of stable states required for a single input combination, revealing the power of primitive flow tables to model sophisticated, history-dependent behavior.", "problem": "An asynchronous 3-input preemptive Last-In-First-Out (LIFO) arbiter is to be designed. The arbiter has three request inputs, $R_2, R_1, R_0$, and three corresponding grant outputs, $G_2, G_1, G_0$. The behavior is defined by the following rules:\n\n1.  Initially, the system is in an idle state with no requests asserted and no grants issued. The output vector $(G_2, G_1, G_0)$ is $(0,0,0)$.\n2.  The grant is issued to the request that was asserted most recently. Only one grant can be active at a time. An active grant for request $R_i$ is represented by the output vector where only the $i$-th component is 1 (e.g., $G_1=1$ corresponds to $(0,1,0)$).\n3.  If a new request $R_{new}$ is asserted while another request $R_{old}$ currently holds the grant, $R_{new}$ preempts $R_{old}$ and receives the grant. The preempted request $R_{old}$ is pushed onto a LIFO stack of preempted requests.\n4.  When the currently granted request is de-asserted, the grant is passed to the request at the top of the preemption stack (the most recently preempted request), provided it is still asserted. This effectively \"pops\" the request from the stack.\n5.  If a request is popped from the stack but is no longer asserted, the arbiter attempts to grant the next request on the stack, continuing this process until a grant is issued or the stack is empty. If the stack becomes empty, the arbiter returns to the idle state.\n6.  If a request that is currently on the preemption stack (but not holding the grant) is de-asserted, it is simply removed from its position in the stack without affecting the current grant holder.\n\nAssuming that only one input can change at a time, a primitive flow table can be constructed to describe the circuit's behavior. Each unique sequence of preemptions corresponds to a unique internal state. For a given input combination, there can be multiple stable states, each corresponding to a different history of request arrivals.\n\nWhat is the maximum number of distinct stable states that can exist for any single input combination $(R_2, R_1, R_0)$?", "solution": "We model the behavior for a fixed input combination by the set of asserted requests. Let $S \\subseteq \\{R_{2},R_{1},R_{0}\\}$ be the subset of requests currently asserted under a given input vector $(R_{2},R_{1},R_{0})$, and let $k=|S| \\in \\{0,1,2,3\\}$.\n\nBy the rules:\n- Exactly one grant is active when $k \\geq 1$, namely for the most recently asserted request in $S$.\n- The preemption stack contains the other asserted requests in last-in-first-out order, and any de-asserted request is immediately removed (so the stack contains only still-asserted requests).\n- For fixed inputs (no further changes), no transitions occur; hence stability is determined solely by the history of how the currently asserted requests arrived.\n\nTherefore, for a given $S$ with $k$ distinct requests asserted, each possible arrival order (sequence of preemptions) of these $k$ requests produces a distinct internal state: the most recent in the order holds the grant, and the remaining $k-1$ occupy the stack in LIFO order. The number of distinct arrival orders of $k$ distinct elements is $k!$. The problem statement confirms that each unique sequence of preemptions corresponds to a unique internal state, so the number of distinct stable states for a fixed input with $k$ asserted requests is exactly\n$$\nk!.\n$$\nTo find the maximum over all input combinations, we maximize $k!$ subject to $k \\leq 3$. This occurs at $k=3$ (all three requests asserted), yielding\n$$\n3! = 6.\n$$\nThus, the maximum number of distinct stable states for any single input combination is $6$.", "answer": "$$\\boxed{6}$$", "id": "1953743"}]}