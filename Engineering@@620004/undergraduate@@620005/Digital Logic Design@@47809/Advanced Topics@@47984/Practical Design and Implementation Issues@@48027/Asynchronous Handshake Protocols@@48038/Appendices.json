{"hands_on_practices": [{"introduction": "Before we can build or analyze a digital system, we must first describe its behavior precisely. Asynchronous handshake protocols are no exception, and their sequential nature makes them perfect candidates for modeling as Finite-State Machines (FSMs). This practice will guide you through the fundamental process of translating a rule-based description of a 4-phase handshake receiver into a formal state table, which is the first step toward hardware implementation [@problem_id:1910555].", "problem": "In an asynchronous data transfer system, a receiver unit must coordinate with a sender using a handshake protocol. Consider a simple receiver implementing a 4-phase handshake protocol. The receiver's behavior is governed by a single input signal from the sender, $Req$ (Request), and it produces a single output signal to the sender, $Ack$ (Acknowledge).\n\nThe behavior of this receiver's sequential circuit can be described by a state diagram with two states: `S0` (Idle) and `S1` (Data Latched). The initial state of the system is `S0`. The state transitions and outputs are defined as follows:\n\n1.  In state `S0`, the $Ack$ signal is held low (logic 0). The receiver remains in `S0` as long as $Req$ is low (logic 0).\n2.  When the $Req$ signal goes high (logic 1), the receiver transitions from state `S0` to state `S1`.\n3.  Upon entering state `S1`, the $Ack$ signal is driven high (logic 1). The receiver remains in `S1` as long as $Req$ is high.\n4.  When the $Req$ signal returns to low (logic 0), the receiver transitions from state `S1` back to state `S0`, completing the handshake cycle.\n\nYour task is to create the corresponding state table for this Moore-type finite-state machine. A state table systematically lists the next state and the output for every possible combination of the present state and input.\n\nWhich of the following options correctly represents the state table for the described 4-phase handshake receiver?\n\n**A.**\n| Present State | Input $Req$ | Next State | Output $Ack$ |\n|:-------------:|:-----------:|:----------:|:------------:|\n|      `S0`     |      0      |    `S0`    |      1       |\n|      `S0`     |      1      |    `S1`    |      1       |\n|      `S1`     |      0      |    `S0`    |      0       |\n|      `S1`     |      1      |    `S1`    |      0       |\n\n**B.**\n| Present State | Input $Req$ | Next State | Output $Ack$ |\n|:-------------:|:-----------:|:----------:|:------------:|\n|      `S0`     |      0      |    `S0`    |      0       |\n|      `S0`     |      1      |    `S1`    |      0       |\n|      `S1`     |      0      |    `S0`    |      1       |\n|      `S1`     |      1      |    `S1`    |      1       |\n\n**C.**\n| Present State | Input $Req$ | Next State | Output $Ack$ |\n|:-------------:|:-----------:|:----------:|:------------:|\n|      `S0`     |      0      |    `S1`    |      0       |\n|      `S0`     |      1      |    `S0`    |      0       |\n|      `S1`     |      0      |    `S1`    |      1       |\n|      `S1`     |      1      |    `S0`    |      1       |\n\n**D.**\n| Present State | Input $Req$ | Next State | Output $Ack$ |\n|:-------------:|:-----------:|:----------:|:------------:|\n|      `S0`     |      0      |    `S0`    |      0       |\n|      `S0`     |      1      |    `S0`    |      1       |\n|      `S1`     |      0      |    `S1`    |      0       |\n|      `S1`     |      1      |    `S1`    |      1       |", "solution": "A Moore finite-state machine has outputs determined solely by the present state. From the description: in state $S0$ the output $Ack$ is held low and in state $S1$ the output $Ack$ is held high. Therefore,\n$$Ack(S0)=0,\\quad Ack(S1)=1.$$\nThe state transitions are governed by the input $Req$ as follows: remain in $S0$ while $Req=0$ and go to $S1$ when $Req=1$; remain in $S1$ while $Req=1$ and go to $S0$ when $Req=0$. Therefore, the next-state function satisfies\n$$\\text{Next}(S0,Req=0)=S0,\\quad \\text{Next}(S0,Req=1)=S1,$$\n$$\\text{Next}(S1,Req=1)=S1,\\quad \\text{Next}(S1,Req=0)=S0.$$\nCombining these with the Moore outputs gives the four required rows:\n- Present $S0$, $Req=0$: Next $S0$, $Ack=0$.\n- Present $S0$, $Req=1$: Next $S1$, $Ack=0$.\n- Present $S1$, $Req=0$: Next $S0$, $Ack=1$.\n- Present $S1$, $Req=1$: Next $S1$, $Ack=1$.\nComparing with the provided options, only option B matches these next-state and output relations exactly.", "answer": "$$\\boxed{B}$$", "id": "1910555"}, {"introduction": "Understanding a protocol's logic is only half the story; we must also analyze its performance. In asynchronous systems, speed is not governed by a global clock but by the causal chain of events in a handshake. This exercise demonstrates how to calculate the minimum time for a complete 4-phase data transaction by summing the logic and propagation delays, providing a clear insight into the real-world performance limitations of these protocols [@problem_id:1910561].", "problem": "In the design of a modern System-on-Chip (SoC), a central processing unit (CPU) communicates with a specialized neural processing unit (NPU) to offload machine learning computations. The communication link between them uses an asynchronous 4-phase non-return-to-zero (NRZ) handshake protocol controlled by two signals: `VALID`, asserted by the CPU (sender) to indicate that data is available, and `READY`, asserted by the NPU (receiver) to acknowledge that the data has been read.\n\nA complete transaction cycle consists of four distinct signal transitions:\n1. The CPU asserts `VALID` high.\n2. The NPU responds by asserting `READY` high.\n3. The CPU sees `READY` is high and de-asserts `VALID` low.\n4. The NPU sees `VALID` is low and de-asserts `READY` low, returning the system to its initial state.\n\nThe timing characteristics of the link are determined by the following delays:\n- Sender logic delay ($t_{sl}$): The time required for the CPU's logic to process an input change and assert or de-assert the `VALID` signal is 120 ps.\n- Receiver logic delay ($t_{rl}$): The time required for the NPU's logic to process an input change and assert or de-assert the `READY` signal is 150 ps.\n- Interconnect propagation delay ($t_{wire}$): The time it takes for a signal change on either the `VALID` or `READY` line to travel along the wire from the CPU to the NPU (or vice versa) is 80 ps.\n\nCalculate the minimum total time required to complete one full data transaction. This time is measured from the moment the CPU initiates the transfer (starting the process of asserting `VALID`) until the system is fully reset to its initial state and ready to begin the next transaction. Express your final answer in nanoseconds (ns), rounded to two significant figures.", "solution": "We model the 4-phase handshake as a sequence of causally dependent events, each incurring logic delay at the driving end and propagation over the interconnect. Let $t_{sl}$ be the sender (CPU) logic delay, $t_{rl}$ the receiver (NPU) logic delay, and $t_{wire}$ the interconnect propagation delay. The total transaction time is measured from when the CPU starts asserting $VALID$ until the CPU has observed $READY$ deasserted and both signals are back low.\n\nStep-by-step timing:\n1) CPU asserts $VALID$: CPU logic delay $t_{sl}$, then the $VALID$ edge propagates to NPU in $t_{wire}$.\nCumulative time after step 1: $t_{sl} + t_{wire}$.\n\n2) NPU asserts $READY$: NPU logic delay $t_{rl}$, then $READY$ edge propagates to CPU in $t_{wire}$.\nAdditional time for step 2: $t_{rl} + t_{wire}$.\nCumulative time after step 2: $t_{sl} + t_{wire} + t_{rl} + t_{wire}$.\n\n3) CPU deasserts $VALID$: upon seeing $READY$ high at CPU, CPU logic delay $t_{sl}$ to drive $VALID$ low, then $VALID$ low propagates to NPU in $t_{wire}$.\nAdditional time for step 3: $t_{sl} + t_{wire}$.\nCumulative time after step 3: $t_{sl} + t_{wire} + t_{rl} + t_{wire} + t_{sl} + t_{wire}$.\n\n4) NPU deasserts $READY$: upon seeing $VALID$ low at NPU, NPU logic delay $t_{rl}$ to drive $READY$ low, then $READY$ low propagates to CPU in $t_{wire}$ (ensuring the initiator sees the handshake complete and the system is ready for the next transaction).\nAdditional time for step 4: $t_{rl} + t_{wire}$.\n\nTherefore, the minimum total time is\n$$\nT_{\\text{min}} \\;=\\; 2\\,t_{sl} \\;+\\; 2\\,t_{rl} \\;+\\; 4\\,t_{wire}.\n$$\n\nSubstituting the given values (in picoseconds) and then converting to nanoseconds:\n$$\nT_{\\text{min}} \\;=\\; 2\\cdot 120 \\;+\\; 2\\cdot 150 \\;+\\; 4\\cdot 80 \\;=\\; 240 \\;+\\; 300 \\;+\\; 320 \\;=\\; 860 \\text{ ps} \\;=\\; 0.86 \\text{ ns}.\n$$\nRounded to two significant figures, the result is $0.86$ ns.", "answer": "$$\\boxed{0.86}$$", "id": "1910561"}, {"introduction": "A well-designed protocol should not only work under ideal conditions but also behave predictably when faults occur. This practice delves into the critical area of system robustness by presenting a hypothetical fault scenarioâ€”a \"stuck-at-1\" failure on the $Req$ signal. By carefully tracing the protocol's steps under this condition, you will discover how such a simple error can lead to a system deadlock, highlighting the importance of fault analysis in designing reliable asynchronous systems [@problem_id:1910529].", "problem": "An asynchronous data transfer system uses a 4-phase handshake protocol to coordinate communication between a sender and a receiver. The protocol operates using a Request ($Req$) signal from the sender and an Acknowledge ($Ack$) signal from the receiver. Initially, both $Req$ and $Ack$ are at logic low (0).\n\nThe standard operational sequence for one data transfer is as follows:\n1. The sender places data on the data bus and then asserts $Req$ by setting it to logic high (1).\n2. The receiver detects $Req$ is high, reads the data from the bus, and then asserts $Ack$ by setting it to logic high (1).\n3. The sender detects $Ack$ is high and de-asserts $Req$ by setting it to logic low (0).\n4. The receiver detects $Req$ is low and de-asserts $Ack$ by setting it to logic low (0), returning the system to its initial state, ready for the next transfer.\n\nNow, consider a fault scenario. The system starts in the initial state where $Req = 0$ and $Ack = 0$. The sender initiates a transfer by executing step 1 correctly. However, immediately after the $Req$ signal goes high, a \"stuck-at-1\" fault occurs, permanently forcing the $Req$ signal to remain at logic high, regardless of the sender's attempts to change it.\n\nAssuming the receiver is functioning correctly and responds according to the protocol rules, what will be the final, stable logic levels of the $Req$ and $Ack$ signals?\n\nA. $Req = 0$, $Ack = 0$\nB. $Req = 0$, $Ack = 1$\nC. $Req = 1$, $Ack = 0$\nD. $Req = 1$, $Ack = 1$\nE. The signals will oscillate and never reach a stable state.", "solution": "We will trace the state of the $Req$ and $Ack$ signals step-by-step, following the rules of the 4-phase handshake protocol and considering the specified fault. The state of the system can be represented by the pair ($Req$, $Ack$).\n\n**Initial State:**\nThe system starts in the quiescent state where no transfer is in progress. According to the problem description, $Req = 0$ and $Ack = 0$.\nState: ($Req$, $Ack$) = (0, 0).\n\n**Protocol Step 1:**\nThe sender initiates a transfer. It places data on the bus and asserts its Request signal. $Req$ changes from 0 to 1.\nState becomes: ($Req$, $Ack$) = (1, 0).\nAt this exact moment, the \"stuck-at-1\" fault occurs on the $Req$ line. This means the $Req$ signal is now permanently fixed at logic high (1) for the remainder of the process.\n\n**Protocol Step 2:**\nThe receiver, which is functioning correctly, detects that $Req$ is high (1). According to the protocol, it responds by reading the data and then asserting its Acknowledge signal. $Ack$ changes from 0 to 1.\nState becomes: ($Req$, $Ack$) = (1, 1).\n\n**Protocol Step 3:**\nThe sender, whose internal logic is working correctly, detects that $Ack$ is high (1). According to the protocol, it should now de-assert its Request signal. The sender's logic attempts to drive the $Req$ line to logic low (0). However, due to the stuck-at-1 fault on the line itself, the signal remains high.\nState remains: ($Req$, $Ack$) = (1, 1).\n\n**Protocol Step 4:**\nThe receiver is now waiting for the next event dictated by the protocol. Step 4 of the protocol states: \"The receiver detects $Req$ is low and de-asserts $Ack$\". Since the $Req$ signal is stuck at 1, the condition for the receiver to de-assert $Ack$ (i.e., $Req = 0$) is never met. The receiver will therefore continue to hold $Ack$ at logic high (1), waiting indefinitely for $Req$ to go low.\n\n**Conclusion:**\nThe sender is waiting for $Ack$ to go low before it can start a new cycle (though it is already stuck in step 3), and the receiver is waiting for $Req$ to go low before it will lower $Ack$. Neither condition can be met. The system is in a deadlock. The signals stop changing and remain in the state where both are asserted.\n\nTherefore, the final, stable logic levels are $Req = 1$ and $Ack = 1$. This corresponds to option D.", "answer": "$$\\boxed{D}$$", "id": "1910529"}]}