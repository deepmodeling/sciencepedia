{"hands_on_practices": [{"introduction": "Bridging the gap between a conceptual circuit diagram and its implementation in a hardware description language (HDL) is a crucial skill in digital logic design. This first practice challenges you to identify the correct Verilog code for a standard two-flop synchronizer from a set of options. Successfully completing this exercise will help you recognize proper synchronization structures in complex codebases and avoid common, yet critical, implementation errors. [@problem_id:1974107]", "problem": "In the design of a complex System-on-Chip (SoC), a central processing unit (CPU) running on a high-frequency clock, `clk_fast`, needs to send a single-bit \"transaction complete\" signal to a peripheral device controller that operates on an independent and slower clock, `clk_slow`. Because the two clock domains are asynchronous, simply connecting the signal wire between them can lead to a hazardous condition known as metastability, where a flip-flop in the receiving domain enters an unstable, intermediate state for an unpredictable amount of time.\n\nTo mitigate this risk, a synchronizer circuit is required. A common and robust technique for single-bit signals is the two-flop synchronizer. Its purpose is to sample the asynchronous input and allow one full clock cycle for any potential metastability to resolve before the signal is passed to the rest of the logic in the destination clock domain.\n\nConsider the following four Verilog module definitions intended to transfer a signal `sig_in` (from the source clock domain) to `sig_out` (for use in the destination clock domain) using the destination clock `dest_clk`. Which of the modules correctly implements a standard two-flop synchronizer?\n\n**A.**\n```verilog\nmodule synchronizer_A (\n  input  sig_in,\n  input  dest_clk,\n  output reg sig_out\n);\n  reg sig_meta_stage;\n\n  always @(posedge dest_clk) begin\n    sig_meta_stage <= sig_in;\n    sig_out <= sig_meta_stage;\n  end\nendmodule\n```\n\n**B.**\n```verilog\nmodule synchronizer_B (\n  input  sig_in,\n  input  dest_clk,\n  output reg sig_out\n);\n  always @(posedge dest_clk) begin\n    sig_out <= sig_in;\n  end\nendmodule\n```\n\n**C.**\n```verilog\nmodule synchronizer_C (\n  input  sig_in,\n  input  dest_clk,\n  output sig_out\n);\n  assign sig_out = sig_in;\nendmodule\n```\n\n**D.**\n```verilog\nmodule synchronizer_D (\n  input  sig_in,\n  input  dest_clk,\n  output reg sig_out\n);\n  always @(dest_clk or sig_in) begin\n    if (dest_clk) begin\n      sig_out <= sig_in;\n    end\n  end\nendmodule\n```", "solution": "We need a standard two-flop synchronizer, which consists of two cascaded edge-triggered flip-flops clocked by the destination clock. The first stage samples the asynchronous input and may enter metastability; the second stage samples the first stage one full destination clock period later, providing a resolution time approximately equal to the destination clock period. The mean time between failures improves roughly as\n$$\nMTBF = \\frac{1}{f_{\\text{clk}} f_{\\text{data}}} \\exp\\!\\left(\\frac{T_{\\text{res}} - t_{0}}{\\tau}\\right),\n$$\nwhere $f_{\\text{clk}}$ is the destination clock frequency, $f_{\\text{data}}$ is the asynchronous input toggle rate, $\\tau$ is the flip-flop’s metastability time constant, $t_{0}$ is a device-specific constant, and $T_{\\text{res}}$ is the available resolution time. Using two stages increases $T_{\\text{res}}$ by about one clock period compared to a single stage, thereby exponentially reducing the failure rate.\n\nTo be correct, the Verilog must:\n- Instantiate two registers (flip-flops) in series.\n- Clock both registers on the destination clock’s positive edge.\n- Use non-blocking assignments so that the second stage samples the prior value of the first stage, ensuring one full clock cycle of resolution.\n\nEvaluate the options:\n\nA. The code declares an intermediate register $sig\\_meta\\_stage$ and updates it and $sig\\_out$ on $posedge\\ dest\\_clk$ using non-blocking assignments:\n$$\n\\begin{aligned}\nsig\\_meta\\_stage &\\leftarrow sig\\_in \\quad \\text{on } posedge(dest\\_clk),\\\\\nsig\\_out &\\leftarrow sig\\_meta\\_stage \\quad \\text{on } posedge(dest\\_clk).\n\\end{aligned}\n$$\nDue to non-blocking semantics, $sig\\_out$ captures the previous value of $sig\\_meta\\_stage$, thus forming two cascaded flip-flops clocked by $dest\\_clk$. This is a correct two-flop synchronizer.\n\nB. Only one flip-flop is used:\n$$\nsig\\_out \\leftarrow sig\\_in \\quad \\text{on } posedge(dest\\_clk),\n$$\nwhich does not provide the extra resolution cycle and is not a two-flop synchronizer.\n\nC. A continuous assignment\n$$\nsig\\_out = sig\\_in\n$$\nprovides no synchronization at all and directly forwards the asynchronous signal, which is unsafe.\n\nD. The sensitivity list is level-sensitive, and the body uses\n$$\n\\text{if }(dest\\_clk)\\ \\ sig\\_out \\leftarrow sig\\_in,\n$$\nwhich is not an edge-triggered flip-flop and can infer a latch or gated behavior, violating synchronous design practices. It is not a two-flop synchronizer.\n\nTherefore, only module A correctly implements the standard two-flop synchronizer.", "answer": "$$\\boxed{A}$$", "id": "1974107"}, {"introduction": "After identifying the correct structure of a synchronizer, the next step is to understand its dynamic behavior, especially during a metastable event. This exercise provides a detailed scenario where the first flip-flop becomes metastable and asks you to determine the precise behavior of the final, synchronized output. By analyzing the timing parameters, you will see firsthand how the second flip-flop provides a full clock cycle for the metastable signal to resolve, thus ensuring a stable output is passed to the rest of the system. [@problem_id:1974076]", "problem": "A digital system uses a two-stage synchronizer to safely introduce an asynchronous signal, `D_in`, into a synchronous domain. The synchronous domain is governed by a clock, `CLK`. The synchronizer consists of two positive-edge-triggered D-type Flip-Flops (DFFs), named `DFF1` and `DFF2`, connected in series. The output `Q1` of `DFF1` is connected to the input `D2` of `DFF2`, and the asynchronous signal `D_in` is connected to the input `D1` of `DFF1`. The final synchronized output of the circuit is `Q2`.\n\nThe system has the following timing characteristics:\n- The clock `CLK` has a period of `T_clk = 12.0` ns. The clock signal is initially low, and its first rising edge occurs at `t = 0` ns.\n- For both identical DFFs, the setup time is `t_su = 1.0` ns, the hold time is `t_h = 0.5` ns, and the clock-to-Q propagation delay is `t_cq = 0.7` ns.\n\nInitially, at `t < 0`, the signals `D_in`, `Q1`, and `Q2` are all stable at logic low (0). The asynchronous signal `D_in` undergoes a single transition from low to high at time `t = 23.6` ns.\n\nThis input transition causes a timing violation, and as a result, the output `Q1` of the first flip-flop becomes metastable. It is experimentally observed for this specific event that the metastable output `Q1` eventually resolves to a stable logic high (1) value at time `t = 31.5` ns.\n\nBased on this complete description of the event, which of the following statements correctly describes the behavior of the final output signal, `Q2`?\n\nA. `Q2` remains low indefinitely.\n\nB. `Q2` transitions to high at `t = 24.7` ns.\n\nC. `Q2` transitions to high at `t = 36.7` ns.\n\nD. The output `Q2` also becomes metastable after the clock edge at `t = 36` ns.\n\nE. `Q2` transitions to high at `t = 31.5` ns.", "solution": "The rising clock edges occur at times given by $t_{k} = k T_{\\mathrm{clk}}$ with $T_{\\mathrm{clk}}=12.0\\,\\text{ns}$, so the relevant edges are at $t_{2}=24\\,\\text{ns}$ and $t_{3}=36\\,\\text{ns}$. Each DFF requires its input to be stable over the aperture window\n$$\n[t_{k}-t_{su},\\; t_{k}+t_{h}]\n$$\nwith $t_{su}=1.0\\,\\text{ns}$ and $t_{h}=0.5\\,\\text{ns}$.\n\nFor $DFF1$ at $t_{2}=24\\,\\text{ns}$, the asynchronous input $D_{\\mathrm{in}}$ transitions at $t=23.6\\,\\text{ns}$, which lies inside the setup window $[23.0\\,\\text{ns},\\,24.5\\,\\text{ns}]$, causing a setup violation and metastability in $Q_{1}$. It is given that this metastable $Q_{1}$ eventually resolves to a stable high at $t=31.5\\,\\text{ns}$.\n\nConsider $DFF2$. Its input is $D_{2}=Q_{1}$, and its sampling edges are the same $t_{2}=24\\,\\text{ns}$ and $t_{3}=36\\,\\text{ns}$. For the $t_{2}=24\\,\\text{ns}$ edge, the required stability window is\n$$\n[24\\,\\text{ns}-1.0\\,\\text{ns},\\;24\\,\\text{ns}+0.5\\,\\text{ns}] = [23.0\\,\\text{ns},\\,24.5\\,\\text{ns}].\n$$\nBefore the edge, $Q_{1}$ was low; after the edge, the earliest $Q_{1}$ can change is bounded by the clock-to-$Q$ delay of $DFF1$, so a nonmetastable transition would not appear before $t=24\\,\\text{ns}+t_{cq}=24.7\\,\\text{ns}$. In this event, $Q_{1}$ is metastable and does not resolve to a stable high until $t=31.5\\,\\text{ns}$, which is also later than $24.5\\,\\text{ns}$. Therefore, over $[23.0\\,\\text{ns},\\,24.5\\,\\text{ns}]$, $D_{2}$ is effectively stable low for sampling purposes, so $DFF2$ cleanly captures a low at $t=24\\,\\text{ns}$ and $Q_{2}$ remains low after that edge.\n\nFor the next edge at $t_{3}=36\\,\\text{ns}$, the setup/hold window is\n$$\n[36\\,\\text{ns}-1.0\\,\\text{ns},\\;36\\,\\text{ns}+0.5\\,\\text{ns}] = [35.0\\,\\text{ns},\\,36.5\\,\\text{ns}].\n$$\nSince $Q_{1}$ has been stably high since $t=31.5\\,\\text{ns}$, $D_{2}$ satisfies both setup and hold around $t=36\\,\\text{ns}$. Thus $DFF2$ captures a high at the $t=36\\,\\text{ns}$ clock edge, and its output $Q_{2}$ transitions high after its own clock-to-$Q$ delay:\n$$\nt_{Q_{2}\\uparrow} = 36\\,\\text{ns} + t_{cq} = 36.7\\,\\text{ns}.\n$$\nTherefore, the correct description is that $Q_{2}$ transitions to high at $t=36.7\\,\\text{ns}$, which corresponds to option C. Options A, B, D, and E are inconsistent: A is false because the high is captured at the next clock; B would require $DFF2$ to have captured high at $t=24\\,\\text{ns}$, which it did not; D is false because $Q_{1}$ is stable well before $t=36\\,\\text{ns}$, so $DFF2$ does not become metastable; E is false because $DFF2$ is edge-triggered and cannot update at $t=31.5\\,\\text{ns}$.", "answer": "$$\\boxed{C}$$", "id": "1974076"}, {"introduction": "While a two-flop synchronizer significantly improves reliability, it's important to recognize that metastability is a probabilistic phenomenon, and failures, though rare, are still possible. This final practice moves from qualitative concepts to quantitative system design by having you calculate the Mean Time Between Failures (MTBF). You will use a standard industry formula to determine the minimum number of flip-flops required in a synchronizer chain to meet a demanding reliability target, showcasing how design decisions directly impact long-term system stability. [@problem_id:1974062]", "problem": "In modern System on Chip (SoC) design, ensuring reliable data transfer between asynchronous clock domains is a critical task. A common method to mitigate metastability issues is to use a synchronizer chain composed of several flip-flops.\n\nConsider an SoC where a peripheral sensor module sends a single-bit `data_valid` signal to a central processing core. The core operates on a system clock with a frequency $f_{\\text{clk}} = 500 \\text{ MHz}$. The `data_valid` signal, which originates from the sensor's clock domain, is asynchronous to the core's clock and has an average transition rate of $f_{\\text{data}} = 10 \\text{ kHz}$.\n\nThe flip-flops used to build the synchronizer chain in the core's clock domain are characterized by a metastability resolution time constant $\\tau = 150 \\text{ ps}$ and a timing window $T_W = 20 \\text{ ps}$ where an input transition can cause a metastable event. The Mean Time Between Failures (MTBF) for an N-stage flip-flop synchronizer is given by the equation:\n$$\n\\text{MTBF} = \\frac{\\exp\\left(\\frac{(N-1) T_{\\text{clk}}}{\\tau}\\right)}{f_{\\text{clk}} f_{\\text{data}} T_W}\n$$\nwhere $T_{\\text{clk}}$ is the period of the synchronizing clock.\n\nTo ensure the long-term reliability of the system, the design specification requires a synchronizer MTBF of at least 100 years. For the purpose of calculation, assume there are exactly 365.25 days in a year.\n\nDetermine the minimum integer number of flip-flops, $N$, required in the synchronizer chain to meet or exceed this reliability target.", "solution": "The problem asks for the minimum integer number of flip-flops, $N$, in a synchronizer chain to achieve a target Mean Time Between Failures (MTBF).\n\nThe governing equation for the MTBF of an N-stage synchronizer is provided:\n$$\n\\text{MTBF} = \\frac{\\exp\\left(\\frac{(N-1) T_{\\text{clk}}}{\\tau}\\right)}{f_{\\text{clk}} f_{\\text{data}} T_W}\n$$\n\nWe are given the following parameters:\n- Target MTBF, $\\text{MTBF}_{\\text{target}} = 100 \\text{ years}$\n- System clock frequency, $f_{\\text{clk}} = 500 \\text{ MHz} = 500 \\times 10^6 \\text{ Hz}$\n- Asynchronous data transition rate, $f_{\\text{data}} = 10 \\text{ kHz} = 10 \\times 10^3 \\text{ Hz}$\n- Metastability resolution time constant, $\\tau = 150 \\text{ ps} = 150 \\times 10^{-12} \\text{ s}$\n- Metastability timing window, $T_W = 20 \\text{ ps} = 20 \\times 10^{-12} \\text{ s}$\n\nFirst, we must convert all parameters to a consistent set of units (SI units).\nThe system clock period $T_{\\text{clk}}$ is the reciprocal of the clock frequency:\n$$\nT_{\\text{clk}} = \\frac{1}{f_{\\text{clk}}} = \\frac{1}{500 \\times 10^6 \\text{ Hz}} = 2 \\times 10^{-9} \\text{ s}\n$$\n\nThe target MTBF needs to be converted from years to seconds:\n$$\n\\text{MTBF}_{\\text{target}} = 100 \\text{ years} \\times 365.25 \\frac{\\text{days}}{\\text{year}} \\times 24 \\frac{\\text{hours}}{\\text{day}} \\times 3600 \\frac{\\text{seconds}}{\\text{hour}}\n$$\n$$\n\\text{MTBF}_{\\text{target}} = 3,155,760,000 \\text{ s} = 3.15576 \\times 10^9 \\text{ s}\n$$\n\nWe need to find the minimum integer $N$ such that $\\text{MTBF} \\geq \\text{MTBF}_{\\text{target}}$. We set up the inequality:\n$$\n\\frac{\\exp\\left(\\frac{(N-1) T_{\\text{clk}}}{\\tau}\\right)}{f_{\\text{clk}} f_{\\text{data}} T_W} \\geq \\text{MTBF}_{\\text{target}}\n$$\n\nNow, we solve for $N$. First, isolate the exponential term:\n$$\n\\exp\\left(\\frac{(N-1) T_{\\text{clk}}}{\\tau}\\right) \\geq \\text{MTBF}_{\\text{target}} \\cdot f_{\\text{clk}} \\cdot f_{\\text{data}} \\cdot T_W\n$$\n\nTake the natural logarithm ($\\ln$) of both sides:\n$$\n\\frac{(N-1) T_{\\text{clk}}}{\\tau} \\geq \\ln(\\text{MTBF}_{\\text{target}} \\cdot f_{\\text{clk}} \\cdot f_{\\text{data}} \\cdot T_W)\n$$\n\nRearrange to solve for $N$:\n$$\nN-1 \\geq \\frac{\\tau}{T_{\\text{clk}}} \\ln(\\text{MTBF}_{\\text{target}} \\cdot f_{\\text{clk}} \\cdot f_{\\text{data}} \\cdot T_W)\n$$\n$$\nN \\geq 1 + \\frac{\\tau}{T_{\\text{clk}}} \\ln(\\text{MTBF}_{\\text{target}} \\cdot f_{\\text{clk}} \\cdot f_{\\text{data}} \\cdot T_W)\n$$\n\nNow, we substitute the numerical values. Let's first calculate the term inside the logarithm:\n$$\n\\text{Term} = \\text{MTBF}_{\\text{target}} \\cdot f_{\\text{clk}} \\cdot f_{\\text{data}} \\cdot T_W\n$$\n$$\n\\text{Term} = (3.15576 \\times 10^9 \\text{ s}) \\cdot (500 \\times 10^6 \\text{ s}^{-1}) \\cdot (10 \\times 10^3 \\text{ s}^{-1}) \\cdot (20 \\times 10^{-12} \\text{ s})\n$$\n$$\n\\text{Term} = (3.15576 \\times 10^9) \\cdot (5 \\times 10^8) \\cdot (1 \\times 10^4) \\cdot (2 \\times 10^{-11})\n$$\n$$\n\\text{Term} = (3.15576 \\cdot 5 \\cdot 1 \\cdot 2) \\times 10^{(9+8+4-11)} = 31.5576 \\times 10^{10} = 3.15576 \\times 10^{11}\n$$\n\nNow, we can substitute this back into the inequality for $N$:\n$$\nN \\geq 1 + \\left(\\frac{150 \\times 10^{-12} \\text{ s}}{2 \\times 10^{-9} \\text{ s}}\\right) \\ln(3.15576 \\times 10^{11})\n$$\n\nCalculate the pre-factor and the logarithm:\n$$\n\\frac{\\tau}{T_{\\text{clk}}} = \\frac{150 \\times 10^{-12}}{2000 \\times 10^{-12}} = \\frac{150}{2000} = \\frac{3}{40} = 0.075\n$$\n$$\n\\ln(3.15576 \\times 10^{11}) \\approx 26.4776\n$$\n\nSubstitute these values back into the inequality for $N$:\n$$\nN \\geq 1 + 0.075 \\times 26.4776\n$$\n$$\nN \\geq 1 + 1.98582\n$$\n$$\nN \\geq 2.98582\n$$\n\nSince the number of flip-flops $N$ must be an integer, we need to find the smallest integer that is greater than or equal to 2.98582. This value is 3.\n\nTherefore, the minimum number of flip-flops required is 3.", "answer": "$$\\boxed{3}$$", "id": "1974062"}]}