{"hands_on_practices": [{"introduction": "A core challenge in asynchronous FIFO design is safely transferring pointer values between different clock domains. This practice introduces Gray code, a special binary sequence where successive values differ by only one bit, as a solution to prevent data corruption during synchronization. This exercise will help you master the fundamental technique of converting a standard binary pointer into its Gray code equivalent, an essential skill for building reliable cross-domain communication circuits [@problem_id:1910272].", "problem": "In digital systems, an asynchronous First-In First-Out (FIFO) buffer is a crucial component for reliably transferring data between two modules that operate with different, unrelated clocks (a situation known as crossing clock domains). To keep track of where to write data and where to read from, the FIFO uses internal counters called a write pointer and a read pointer, which index the memory locations within the buffer.\n\nA major design challenge in asynchronous FIFOs is safely passing the value of a pointer from one clock domain to the other for synchronization and status flag generation (e.g., full or empty signals). If a standard binary counter is used for the pointers, multiple bits can change simultaneously when the counter increments (for example, transitioning from binary `011` to `100`). If the receiving clock samples the pointer during this multi-bit transition, it might capture a meaningless intermediate value, leading to a catastrophic system failure.\n\nTo prevent this issue, pointers in asynchronous FIFOs are almost always implemented using Gray code, a binary numeral system where any two successive values differ in only one bit. This single-bit change property ensures that even if the pointer is sampled during a transition, the received value will be either the old value or the new value, both of which are valid states.\n\nConsider an 8-word deep asynchronous FIFO, which requires a 3-bit pointer to address its memory locations. At a certain moment, the binary value of the write pointer is `101`. To safely transfer this pointer value to the read clock domain, it must first be converted to its Gray code equivalent.\n\nWhich of the following represents the correct 3-bit Gray code for the binary pointer value `101`?\n\nA. 111\n\nB. 101\n\nC. 110\n\nD. 010", "solution": "To convert a binary value to Gray code, use the bitwise relation between the binary bits $b_{2}, b_{1}, b_{0}$ (with $b_{2}$ the most significant bit) and the Gray code bits $g_{2}, g_{1}, g_{0}$:\n$$\ng_{2} = b_{2}, \\quad g_{1} = b_{2} \\oplus b_{1}, \\quad g_{0} = b_{1} \\oplus b_{0},\n$$\nwhere $\\oplus$ denotes the XOR operation.\n\nGiven the binary pointer `101`, we have $b_{2} = 1$, $b_{1} = 0$, and $b_{0} = 1$. Compute each Gray bit:\n$$\ng_{2} = 1, \\quad g_{1} = 1 \\oplus 0 = 1, \\quad g_{0} = 0 \\oplus 1 = 1.\n$$\nThus, the 3-bit Gray code is `111`, which corresponds to option A.", "answer": "$$\\boxed{A}$$", "id": "1910272"}, {"introduction": "Once pointers are safely represented, they must be used to generate status flags like 'empty' or 'full'. This exercise focuses on deriving the logic for the 'empty' flag by comparing the write pointer with the synchronized read pointer. Mastering this comparison logic is the first step toward creating the control circuitry that prevents FIFO underflow, where a read is attempted on an empty buffer [@problem_id:1910260].", "problem": "In digital systems, an asynchronous First-In, First-Out (FIFO) buffer is commonly used to safely pass data between two modules operating in different and unrelated clock domains. To manage the buffer, pointers are used to track the locations for writing and reading data.\n\nConsider an asynchronous FIFO where the data pointers are 3-bit binary numbers. In the \"write\" clock domain, a write pointer, `w_ptr`, indicates the next memory location to be written. Its individual bits are denoted as `w_2`, `w_1`, and `w_0`, where `w_2` is the most significant bit. In the \"read\" clock domain, a read pointer indicates the next location to be read. To check the status of the FIFO, this read pointer is synchronized and brought into the write clock domain, where it is called `r_ptr_sync`. Its bits are denoted as `r_2`, `r_1`, and `r_0`.\n\nThe FIFO is considered \"empty\" if and only if the write pointer is identical to the synchronized read pointer (`w_ptr = r_ptr_sync`).\n\nYour task is to derive the Boolean logic expression for the `empty` signal. This signal should be `1` when the FIFO is empty and `0` otherwise. Your expression must be a function of the individual pointer bits: `w_2, w_1, w_0, r_2, r_1, r_0`. Express your final answer using standard Boolean operators: `+` for OR, `\\cdot` for AND, and an overbar for the NOT operation (e.g., `\\overline{A}`).", "solution": "The FIFO is empty if and only if the write pointer equals the synchronized read pointer, i.e., $w\\_ptr = r\\_ptr\\_sync$. For 3-bit pointers, this equality holds exactly when all corresponding bit pairs are equal:\n$$\n\\text{empty} = (w_2 = r_2) \\cdot (w_1 = r_1) \\cdot (w_0 = r_0).\n$$\nFor Boolean variables, equality of two bits $A$ and $B$ is given by the XNOR form:\n$$\n(A = B) = A \\cdot B + \\overline{A} \\cdot \\overline{B}.\n$$\nApplying this to each bit pair yields\n$$\n\\text{empty} = \\left(w_2 \\cdot r_2 + \\overline{w_2} \\cdot \\overline{r_2}\\right) \\cdot \\left(w_1 \\cdot r_1 + \\overline{w_1} \\cdot \\overline{r_1}\\right) \\cdot \\left(w_0 \\cdot r_0 + \\overline{w_0} \\cdot \\overline{r_0}\\right).\n$$\nThis expression is $1$ exactly when all three bit pairs match, and $0$ otherwise, as required.", "answer": "$$\\boxed{\\left(w_{2}\\cdot r_{2}+\\overline{w_{2}}\\cdot\\overline{r_{2}}\\right)\\cdot\\left(w_{1}\\cdot r_{1}+\\overline{w_{1}}\\cdot\\overline{r_{1}}\\right)\\cdot\\left(w_{0}\\cdot r_{0}+\\overline{w_{0}}\\cdot\\overline{r_{0}}\\right)}$$", "id": "1910260"}, {"introduction": "Distinguishing a 'full' FIFO from an 'empty' one presents a unique challenge, as the simple pointer equality used for the 'empty' check is no longer sufficient. This advanced practice explores a common and robust solution using extended $(N+1)$-bit pointers to create unambiguous 'full' and 'empty' conditions. By deriving the logic for a write-enable signal based on the 'full' status, you will implement a critical flow control mechanism that prevents data overflow and ensures the integrity of the FIFO buffer [@problem_id:1910302].", "problem": "You are a junior digital logic designer tasked with creating a portion of the control logic for an asynchronous First-In First-Out (FIFO) buffer. The FIFO has a storage depth of $D=2^N$ data words.\n\nTo correctly manage the buffer's state and prevent overflow or underflow across different clock domains, the FIFO uses $(N+1)$-bit binary pointers: a write pointer `wr_ptr` and a read pointer `rd_ptr`. These pointers range from $0$ to $2^{N+1}-1$.\n\nWithin the write clock domain, you are provided with the following signals:\n- `wr_req`: An active-high signal. When `wr_req` is logic '1', there is an external request to write data into the FIFO.\n- `wr_ptr[(N):0]`: The current $(N+1)$-bit write pointer.\n- `rd_ptr_sync[(N):0]`: The $(N+1)$-bit read pointer, which has been safely synchronized from the read clock domain into the write clock domain.\n\nThe status of the FIFO is determined by comparing `wr_ptr` and `rd_ptr_sync` according to the following rules:\n- **Full Condition**: The FIFO is considered full when the most significant bit (MSB), which is bit $N$, of the pointers are different, but all the lower $N$ bits (from bit $N-1$ down to $0$) are identical.\n- **Empty Condition**: The FIFO is considered empty when the write pointer and the synchronized read pointer are identical (`wr_ptr == rd_ptr_sync`).\n\nYour task is to derive the logic for the internal write enable signal, `wr_en`. `wr_en` should be asserted (logic '1') if and only if an external write is requested (`wr_req` is '1') AND the FIFO is not full.\n\nDerive a simplified Boolean expression for `wr_en` in terms of `wr_req` and the individual bits of the pointers `wr_ptr` and `rd_ptr_sync`.", "solution": "Let $\\mathrm{wr\\_ptr}_{i}$ and $\\mathrm{rd\\_ptr\\_sync}_{i}$ denote bit $i$ of the write and synchronized read pointers, respectively, with $i \\in \\{0,1,\\ldots,N\\}$ and $i=N$ the MSB. By the stated rules:\n- Full condition:\n$$\n\\text{FULL}=\\left(\\mathrm{wr\\_ptr}_{N} \\oplus \\mathrm{rd\\_ptr\\_sync}_{N}\\right)\\land \\bigwedge_{i=0}^{N-1}\\lnot\\!\\left(\\mathrm{wr\\_ptr}_{i} \\oplus \\mathrm{rd\\_ptr\\_sync}_{i}\\right).\n$$\n- Empty condition:\n$$\n\\text{EMPTY}=\\bigwedge_{i=0}^{N}\\lnot\\!\\left(\\mathrm{wr\\_ptr}_{i} \\oplus \\mathrm{rd\\_ptr\\_sync}_{i}\\right).\n$$\nThe internal write enable must assert if and only if an external write is requested and the FIFO is not full, so\n$$\n\\mathrm{wr\\_en}=\\mathrm{wr\\_req}\\land \\lnot(\\text{FULL}).\n$$\nApplying De Morganâ€™s law to $\\lnot(\\text{FULL})$ gives\n$$\n\\lnot(\\text{FULL})=\\lnot\\!\\left(\\mathrm{wr\\_ptr}_{N} \\oplus \\mathrm{rd\\_ptr\\_sync}_{N}\\right)\\lor \\bigvee_{i=0}^{N-1}\\left(\\mathrm{wr\\_ptr}_{i} \\oplus \\mathrm{rd\\_ptr\\_sync}_{i}\\right).\n$$\nTherefore,\n$$\n\\mathrm{wr\\_en}=\\mathrm{wr\\_req}\\land\\left(\\lnot\\!\\left(\\mathrm{wr\\_ptr}_{N} \\oplus \\mathrm{rd\\_ptr\\_sync}_{N}\\right)\\lor \\bigvee_{i=0}^{N-1}\\left(\\mathrm{wr\\_ptr}_{i} \\oplus \\mathrm{rd\\_ptr\\_sync}_{i}\\right)\\right).\n$$\nThis expression states that a write is enabled when a write is requested and either the MSBs are equal or at least one of the lower $N$ bits differs, which is exactly the negation of the full condition.", "answer": "$$\\boxed{\\mathrm{wr\\_req}\\land\\left(\\lnot\\!\\left(\\mathrm{wr\\_ptr}_{N} \\oplus \\mathrm{rd\\_ptr\\_sync}_{N}\\right)\\lor \\bigvee_{i=0}^{N-1}\\left(\\mathrm{wr\\_ptr}_{i} \\oplus \\mathrm{rd\\_ptr\\_sync}_{i}\\right)\\right)}$$", "id": "1910302"}]}