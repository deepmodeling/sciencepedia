{"hands_on_practices": [{"introduction": "In digital design, maximizing efficiency often means repurposing existing components for multiple tasks. This practice explores a cornerstone technique: implementing subtraction using only a standard parallel adder. By understanding and applying two's complement arithmetic, you can configure an adder to perform subtraction, a skill that is fundamental to designing efficient Arithmetic Logic Units (ALUs). This exercise [@problem_id:1942940] will solidify your grasp of how number representations enable hardware versatility.", "problem": "A digital circuit is being designed to perform a specific arithmetic operation on a 4-bit unsigned binary number, $A = A_3A_2A_1A_0$. The core of this circuit is a standard 4-bit binary parallel adder. This adder has two 4-bit data inputs, designated as $X$ and $W$, and a single-bit carry-in, $C_{in}$. The circuit's 4-bit output, $Y = Y_3Y_2Y_1Y_0$, is taken directly from the sum output of the adder.\n\nThe circuit must compute the operation $Y = A - 2$. The input number $A$ is connected to the adder's $X$ input. To achieve the desired subtraction, the second data input $W = W_3W_2W_1W_0$ and the carry-in $C_{in}$ must be set to specific constant binary values. Assume that any overflow from the 4-bit calculation is ignored.\n\nWhich of the following configurations for the input $W$ and carry-in $C_{in}$ will correctly implement the operation $Y = A - 2$?\n\nNote: The binary values for $W$ are given with the most significant bit first (e.g., $W_3W_2W_1W_0$).\n\nA. $W=1101_2$, $C_{in}=1$\n\nB. $W=0010_2$, $C_{in}=0$\n\nC. $W=1101_2$, $C_{in}=0$\n\nD. $W=0001_2$, $C_{in}=1$\n\nE. $W=1110_2$, $C_{in}=1$", "solution": "The problem requires us to implement the subtraction operation $Y = A - 2$ using a 4-bit parallel adder. In digital logic, subtraction is typically performed by adding the 2's complement of the subtrahend. Therefore, the operation $A - 2$ can be rewritten as $A + (-2)$, where $-2$ is represented in its 4-bit 2's complement form.\n\nFirst, we must find the 4-bit 2's complement representation of the number 2.\nThe positive number 2 in a 4-bit binary format is $0010_2$.\n\nTo find the 2's complement, we follow two steps:\n1.  Find the 1's complement by inverting all the bits of the number.\n    The 1's complement of $0010_2$ is $1101_2$.\n2.  Add 1 to the 1's complement to get the 2's complement.\n    $1101_2 + 1 = 1110_2$.\n\nSo, the 4-bit 2's complement representation of $-2$ is $1110_2$.\nThe desired computation $Y = A - 2$ is thus equivalent to the addition $Y = A + 1110_2$. The problem states that any overflow is ignored, which is consistent with 2's complement arithmetic.\n\nThe 4-bit parallel adder circuit calculates the sum $S = X + W + C_{in}$, where $X$ and $W$ are the 4-bit inputs and $C_{in}$ is the carry-in. We are given that the input $A$ is connected to $X$ (so $X=A$) and the output $Y$ is the sum $S$ (so $Y=S$).\nSubstituting these into the adder's equation gives:\n$Y = A + W + C_{in}$.\n\nTo implement the desired operation, this expression must be equivalent to $Y = A + 1110_2$. By comparing the two expressions, we can deduce the necessary condition for the inputs $W$ and $C_{in}$:\n$A + W + C_{in} = A + 1110_2$\n$W + C_{in} = 1110_2$\n\nNow we must evaluate each of the given options to find which one satisfies this condition. The addition of $C_{in}$ occurs at the least significant bit position of $W$.\n\nA. $W=1101_2$, $C_{in}=1$.\n   The sum is $1101_2 + 1 = 1110_2$. This matches our required value.\n\nB. $W=0010_2$, $C_{in}=0$.\n   The sum is $0010_2 + 0 = 0010_2$. This is incorrect. This configuration would compute $Y=A+2$.\n\nC. $W=1101_2$, $C_{in}=0$.\n   The sum is $1101_2 + 0 = 1101_2$. This is incorrect. This configuration would compute $Y=A-3$, since $1101_2$ is the 2's complement of 3.\n\nD. $W=0001_2$, $C_{in}=1$.\n   The sum is $0001_2 + 1 = 0010_2$. This is incorrect. This configuration would compute $Y=A+2$.\n\nE. $W=1110_2$, $C_{in}=1$.\n   The sum is $1110_2 + 1 = 1111_2$. This is incorrect. This configuration would compute $Y=A-1$, since $1111_2$ is the 2's complement of 1.\n\nOnly option A results in $W + C_{in} = 1110_2$. This configuration corresponds to the standard method of implementing subtraction $A-B$ as $A + \\bar{B} + 1$, where $\\bar{B}$ is the 1's complement of $B$. In our case, $B=0010_2$, so $\\bar{B}=1101_2$, which is set as the input $W$. The `$+\\,1$` is provided by setting the carry-in $C_{in}=1$. Thus, this is the correct configuration.", "answer": "$$\\boxed{A}$$", "id": "1942940"}, {"introduction": "Building upon the basics of arithmetic circuits, this next challenge involves designing a unit with data-dependent behavior. Your task is to create a circuit that either increments or decrements its input based on whether the number is even or odd. This problem [@problem_id:1942952] encourages you to look past a generic, complex solution and use logical analysis to discover a surprisingly elegant and simple implementation, a common theme in expert digital design.", "problem": "A digital systems engineer is designing a special-purpose 4-bit Conditional Arithmetic Unit (CAU). The CAU takes a 4-bit unsigned binary number, $A = A_3A_2A_1A_0$, as input, where $A_3$ is the most significant bit (MSB) and $A_0$ is the least significant bit (LSB). The unit produces a 4-bit output $S = S_3S_2S_1S_0$. The behavior of the CAU is defined as follows:\n\n- If the input number $A$ is even, the output $S$ must be the result of the arithmetic operation $A+1$.\n- If the input number $A$ is odd, the output $S$ must be the result of the arithmetic operation $A-1$.\n\nAll operations are performed using unsigned 4-bit arithmetic, ignoring any overflow or underflow. Your task is to determine the set of simplified Boolean logic expressions for the output bits ($S_3, S_2, S_1, S_0$) in terms of the input bits ($A_3, A_2, A_1, A_0$). Standard Boolean notation is used, where logical AND is represented by juxtaposition (e.g., $XY$), logical OR by a plus sign ($+$), logical NOT by an overbar (e.g., $\\bar{X}$), and exclusive-OR (XOR) by $\\oplus$.\n\nWhich of the following sets of equations correctly describes the output bits of the CAU?\n\nA.\n$S_3 = A_3$\n$S_2 = A_2$\n$S_1 = A_1$\n$S_0 = \\bar{A_0}$\n\nB.\n$S_3 = A_3 \\oplus (A_2 A_1 A_0)$\n$S_2 = A_2 \\oplus (A_1 A_0)$\n$S_1 = A_1 \\oplus A_0$\n$S_0 = \\bar{A_0}$\n\nC.\n$S_3 = A_3 \\oplus (\\bar{A_2} \\bar{A_1} \\bar{A_0})$\n$S_2 = A_2 \\oplus (\\bar{A_1} \\bar{A_0})$\n$S_1 = A_1 \\oplus \\bar{A_0}$\n$S_0 = \\bar{A_0}$\n\nD.\n$S_3 = A_3 \\oplus (A_2 A_1 A_0)$\n$S_2 = A_2 \\oplus (A_1 A_0)$\n$S_1 = A_1 \\oplus A_0$\n$S_0 = 1$", "solution": "Let the input be $A=A_{3}A_{2}A_{1}A_{0}$ and the output be $S=S_{3}S_{2}S_{1}S_{0}$. The CAU performs\n- $S=A+1$ if $A$ is even, i.e., $A_{0}=0$,\n- $S=A-1$ if $A$ is odd, i.e., $A_{0}=1$,\nusing unsigned 4-bit arithmetic with overflow/underflow ignored.\n\nAnalyze each bit using the carry/borrow properties for $\\pm 1$ at the least significant bit:\n- If $A_{0}=0$ (even), then adding $1$ flips only the least significant bit: there is no carry into higher bits because $0+1$ at bit $0$ produces $1$ with carry $0$. Therefore,\n$$\nS_{0}=1,\\quad S_{1}=A_{1},\\quad S_{2}=A_{2},\\quad S_{3}=A_{3}.\n$$\n- If $A_{0}=1$ (odd), then subtracting $1$ flips only the least significant bit: there is no borrow into higher bits because $1-1$ at bit $0$ produces $0$ with borrow $0$. Therefore,\n$$\nS_{0}=0,\\quad S_{1}=A_{1},\\quad S_{2}=A_{2},\\quad S_{3}=A_{3}.\n$$\n\nCombining both cases yields\n$$\nS_{0}=\\bar{A_{0}},\\quad S_{1}=A_{1},\\quad S_{2}=A_{2},\\quad S_{3}=A_{3}.\n$$\nThis matches option A exactly, and disagrees with options B, C, and D which incorrectly toggle higher bits or fix $S_{0}$.", "answer": "$$\\boxed{A}$$", "id": "1942952"}, {"introduction": "Moving from abstract logic gates to modern implementation, this advanced practice explores how arithmetic circuits are realized within Field-Programmable Gate Arrays (FPGAs). You will map a 4-bit incrementer onto an array of simplified, but realistic, logic cells, each containing a Look-Up Table (LUT) and dedicated carry logic. This problem [@problem_id:1942932] demystifies hardware synthesis, showing how abstract designs are broken down and efficiently mapped onto the physical resources of reconfigurable chips.", "problem": "In modern reconfigurable hardware like Field-Programmable Gate Arrays (FPGAs), complex arithmetic circuits are constructed by chaining together specialized logic cells. Consider the design of a 4-bit synchronous binary incrementer, which computes the output $S = A + 1$ for a 4-bit input $A = A_3A_2A_1A_0$.\n\nThis incrementer is to be implemented by cascading four identical Arithmetic Logic Cells (ALCs), indexed from $i=0$ for the least significant bit (LSB) to $i=3$ for the most significant bit (MSB). The carry-in to the first cell, $C_0$, is permanently connected to a logic '1'.\n\nEach ALC for stage $i$ is defined by the following structure:\n- **Inputs**: A data bit $A_i$ and a carry-in bit $C_i$.\n- **Outputs**: A sum bit $S_i$ and a carry-out bit $C_{i+1}$.\n- **Internal Components and Wiring**:\n    1.  A 3-input Look-Up Table (LUT), whose output is denoted `LUT_OUT`. The LUT's inputs, $I_1, I_2, I_3$, can be connected to any signal from the set $\\{A_i, C_i, '0' \\text{(GND)}, '1' \\text{(VCC)}\\}$.\n    2.  A dedicated 2-input XOR gate that generates the sum bit, with the fixed wiring: $S_i = \\text{LUT\\_OUT} \\oplus C_i$.\n    3.  A 2-to-1 multiplexer (MUX) that generates the carry-out bit $C_{i+1}$. The MUX inputs, `Sel`, $D_0$, and $D_1$, can be connected to any signal from the set $\\{A_i, C_i, '0', '1', \\text{LUT\\_OUT}\\}$.\n\nYour task is to determine the correct configuration for the LUTs within the ALCs to properly realize the 4-bit incrementer.\n\nLet $f_0(A_0, C_0)$ be the Boolean function implemented by the LUT in cell $ALC_0$, and let $f_i(A_i, C_i)$ be the Boolean function implemented by the LUT in any of the subsequent cells $ALC_i$ (for $i \\in \\{1, 2, 3\\}$). Which of the following options correctly specifies these functions?\n\nA. $f_0 = A_0$; and for $i>0$, $f_i = A_i$.\n\nB. $f_0 = \\neg A_0$; and for $i>0$, $f_i = A_i \\oplus C_i$.\n\nC. $f_0 = 1$; and for $i>0$, $f_i = A_i$.\n\nD. $f_0 = A_0$; and for $i>0$, $f_i = A_i \\cdot C_i$.\n\nE. $f_0 = A_0 \\oplus C_0$; and for $i>0$, $f_i = A_i \\oplus C_i$.", "solution": "We implement a 4-bit incrementer computing $S = A + 1$ with $A = A_{3}A_{2}A_{1}A_{0}$ and $C_{0} = 1$. For each bit $i$, the required sum and carry-out for incrementing are the standard ripple-carry relations:\n$$\nS_{i} = A_{i} \\oplus C_{i}, \\quad C_{i+1} = A_{i} \\cdot C_{i}.\n$$\n\nEach ALC has a LUT output denoted $\\text{LUT\\_OUT}$ and a fixed sum wiring:\n$$\nS_{i} = \\text{LUT\\_OUT} \\oplus C_{i}.\n$$\nTo match the required sum $S_{i} = A_{i} \\oplus C_{i}$ for all $i$, we must have\n$$\n\\text{LUT\\_OUT} = A_{i},\n$$\nindependent of $C_{i}$. In particular, for $i=0$ with $C_{0}=1$, this yields\n$$\nS_{0} = \\text{LUT\\_OUT} \\oplus C_{0} = A_{0} \\oplus 1 = \\neg A_{0},\n$$\nwhich is the correct least significant sum bit for incrementing.\n\nNext, verify that the carry-out can be realized by the MUX. We need $C_{i+1} = A_{i} \\cdot C_{i}$. Using the available MUX connections, choose\n- $\\text{Sel} = A_{i}$,\n- $D_{0} = 0$,\n- $D_{1} = C_{i}$.\nThen the MUX output is $C_{i+1} = 0$ when $A_{i}=0$ and $C_{i+1} = C_{i}$ when $A_{i}=1$, which is exactly $A_{i} \\cdot C_{i}$. Alternatively, with $\\text{LUT\\_OUT} = A_{i}$, one could set $\\text{Sel} = C_{i}$, $D_{0} = 0$, $D_{1} = \\text{LUT\\_OUT}$ to achieve the same function.\n\nTherefore, the correct LUT functions are $f_{0}(A_{0}, C_{0}) = A_{0}$ and, for all $i \\in \\{1,2,3\\}$, $f_{i}(A_{i}, C_{i}) = A_{i}$.\n\nTo eliminate the other options:\n- If $f_{0} = \\neg A_{0}$, then $S_{0} = \\neg A_{0} \\oplus 1 = A_{0}$, which is incorrect for incrementing. For $i>0$, $f_{i} = A_{i} \\oplus C_{i}$ gives $S_{i} = (A_{i} \\oplus C_{i}) \\oplus C_{i} = A_{i}$, not $A_{i} \\oplus C_{i}$; hence option B is invalid.\n- If $f_{0} = 1$, then $S_{0} = 1 \\oplus 1 = 0$, not $\\neg A_{0}$; hence option C is invalid.\n- If $f_{i} = A_{i} \\cdot C_{i}$ for $i>0$, then $S_{i} = (A_{i} \\cdot C_{i}) \\oplus C_{i} = C_{i} \\cdot \\neg A_{i}$, not $A_{i} \\oplus C_{i}$; hence option D is invalid.\n- If $f_{i} = A_{i} \\oplus C_{i}$ for any $i$, then $S_{i} = (A_{i} \\oplus C_{i}) \\oplus C_{i} = A_{i}$, not $A_{i} \\oplus C_{i}$; hence option E is invalid.\n\nThus the only configuration that yields the correct sum and enables correct carry generation with the given MUX is $f_{0} = A_{0}$ and $f_{i} = A_{i}$ for $i>0$, which is option A.", "answer": "$$\\boxed{A}$$", "id": "1942932"}]}