{"hands_on_practices": [{"introduction": "The restoring division algorithm provides a direct and intuitive way to implement binary division in hardware, closely mirroring the long division method taught in grade school. This first exercise serves as a foundational practice, guiding you through a complete, cycle-by-cycle execution of the algorithm. By manually tracing the state of the accumulator ($A$), quotient ($Q$), and divisor ($M$) registers, you will build a concrete understanding of how the process of shifting, subtracting, and restoring systematically yields the final quotient and remainder [@problem_id:1958382].", "problem": "A simple Arithmetic Logic Unit (ALU) is designed to perform unsigned binary division using the restoring division algorithm. The ALU uses a 4-bit architecture. Consider the operation of dividing a dividend of 9 by a divisor of 3.\n\nThe hardware consists of three primary 4-bit registers:\n-   **M**: The Divisor register, which is initialized with the value of the divisor.\n-   **Q**: The Quotient register, which is initialized with the value of the dividend.\n-   **A**: The Accumulator register, which is initialized to zero.\n\nThe restoring division algorithm proceeds for a number of cycles equal to the number of bits, which is 4 in this case. The steps for each cycle are as follows:\n1.  Perform a logical left shift on the 8-bit register pair formed by concatenating A and Q (`A` followed by `Q`).\n2.  Subtract the value in the M register from the A register (`A = A - M`).\n3.  Examine the most significant bit (MSB) of the A register.\n    -   If the MSB of A is 1, set the least significant bit (LSB) of Q to 0 and restore the value of A by adding M back to it (`A = A + M`).\n    -   If the MSB of A is 0, set the LSB of Q to 1.\n\nPerform a manual trace of this algorithm for the division of 9 (dividend) by 3 (divisor). Determine the final binary values contained in the Accumulator (A) register, which holds the remainder, and the Quotient (Q) register, which holds the quotient.\n\nProvide your answer as a pair of 4-bit binary strings, representing the final value of A and the final value of Q, in that order.", "solution": "We use unsigned restoring division with 4-bit registers. Encode the dividend and divisor in binary as $Q=1001$ (for $9$) and $M=0011$ (for $3$), and initialize $A=0000$. Arithmetic on $A$ is performed in 4-bit two’s-complement so that the MSB indicates sign after subtraction. Each cycle performs: (i) logical left shift of the concatenated pair $(A,Q)$, (ii) $A \\leftarrow A - M$, (iii) if $\\text{MSB}(A)=1$ then set the LSB of $Q$ to $0$ and restore $A \\leftarrow A+M$, else set the LSB of $Q$ to $1$. We perform 4 cycles.\n\nCycle 1:\nLeft shift $(A,Q)$: $A$ becomes $0001$, $Q$ becomes $001\\_$.\nSubtract: $A \\leftarrow 0001 - 0011 = 1110$ (negative, MSB$=1$).\nSet $Q_0=0$, making $Q=0010$. Restore $A$: $A \\leftarrow 1110 + 0011 = 0001$.\n\nCycle 2:\nLeft shift $(A,Q)$: $A$ becomes $0010$, $Q$ becomes $010\\_$.\nSubtract: $A \\leftarrow 0010 - 0011 = 1111$ (negative, MSB$=1$).\nSet $Q_0=0$, making $Q=0100$. Restore $A$: $A \\leftarrow 1111 + 0011 = 0010$.\n\nCycle 3:\nLeft shift $(A,Q)$: $A$ becomes $0100$, $Q$ becomes $100\\_$.\nSubtract: $A \\leftarrow 0100 - 0011 = 0001$ (nonnegative, MSB$=0$).\nSet $Q_0=1$, making $Q=1001$. No restore is needed, so $A$ remains $0001$.\n\nCycle 4:\nLeft shift $(A,Q)$: $A$ becomes $0011$, $Q$ becomes $001\\_$.\nSubtract: $A \\leftarrow 0011 - 0011 = 0000$ (nonnegative, MSB$=0$).\nSet $Q_0=1$, making $Q=0011$. No restore is needed, so $A$ remains $0000$.\n\nAfter 4 cycles, the final registers are $A=0000$ (remainder) and $Q=0011$ (quotient), which corresponds to $9 \\div 3 = 3$ with remainder $0$.", "answer": "$$\\boxed{\\begin{pmatrix}0000 & 0011\\end{pmatrix}}$$", "id": "1958382"}, {"introduction": "While the restoring algorithm is straightforward, its restoration step can be computationally expensive. The non-restoring division algorithm optimizes this process by eliminating the need to add the divisor back after an unsuccessful subtraction. This practice challenges you to trace this more efficient method, where the logic pivots based on the sign of the accumulator at each step [@problem_id:1958432]. Carefully following this procedure will highlight the clever trade-off it makes: slightly more complex control logic in exchange for faster overall execution.", "problem": "A microprocessor's Arithmetic Logic Unit (ALU) is designed to perform unsigned integer division using a 4-bit non-restoring algorithm. The ALU uses a 4-bit accumulator register `A` (initialized to zero), a 4-bit quotient register `Q` (which initially holds the dividend), and a 4-bit divisor register `M`.\n\nThe algorithm proceeds in `n` cycles, where `n` is the number of bits. In each cycle, the following steps are performed:\n1. Examine the sign of the accumulator `A` (most significant bit).\n2. If the sign is 0 (positive), the combined `A,Q` register is shifted left by one bit, and the divisor `M` is subtracted from `A`.\n3. If the sign is 1 (negative), the combined `A,Q` register is shifted left by one bit, and the divisor `M` is added to `A`.\n4. The new sign of `A` determines the new least significant bit of `Q`: if the new sign is 0, the bit is set to 1; if the new sign is 1, the bit is set to 0.\n\nYour task is to trace the execution of this algorithm for a dividend of 13 and a divisor of 3.\n\nWhich of the following options correctly represents the binary contents of registers `A` and `Q` at the end of each of the four cycles? The state of the registers should be reported *before* any final correction step that might be required to adjust the remainder after the four cycles are complete.\n\nA. Cycle 1: A=1110, Q=1010; Cycle 2: A=0000, Q=0101; Cycle 3: A=1101, Q=1010; Cycle 4: A=1110, Q=0100\n\nB. Cycle 1: A=0001, Q=1010; Cycle 2: A=0000, Q=0101; Cycle 3: A=0000, Q=1010; Cycle 4: A=0001, Q=0100\n\nC. Cycle 1: A=1110, Q=1010; Cycle 2: A=0000, Q=0101; Cycle 3: A=1110, Q=0100; Cycle 4: A=1111, Q=1000\n\nD. Cycle 1: A=1110, Q=1010; Cycle 2: A=1101, Q=0101; Cycle 3: A=1101, Q=1010; Cycle 4: A=1110, Q=0101", "solution": "We use the given 4-bit non-restoring division algorithm with accumulator $A$ initialized to $0000$, quotient register $Q$ initialized to the dividend $1101$ (which is $13$), and divisor register $M=0011$ (which is $3$). All arithmetic in $A$ is performed in 4-bit two’s complement, and the combined $\\{A,Q\\}$ is shifted left as a single $8$-bit register. After each add/subtract, the new sign of $A$ sets $Q_{0}$: if $\\operatorname{sign}(A)=0$ set $Q_{0}=1$, else set $Q_{0}=0$. We report the register contents at the end of each cycle (after setting $Q_{0}$), and we do not apply any final remainder correction.\n\nInitialization: $A=0000$, $Q=1101$, $M=0011$.\n\nCycle 1:\n- $\\operatorname{sign}(A)=0$, so shift left $\\{A,Q\\}$: $0000\\ 1101 \\to 0001\\ 1010$, hence $A=0001$, $Q=1010$.\n- Since $\\operatorname{sign}(A)$ was $0$, compute $A:=A-M$: $0001-0011=1110$ (two’s complement).\n- New $\\operatorname{sign}(A)=1$, so set $Q_{0}=0$. Thus end of cycle: $A=1110$, $Q=1010$.\n\nCycle 2:\n- $\\operatorname{sign}(A)=1$, so shift left $\\{A,Q\\}$: $1110\\ 1010 \\to 1101\\ 0100$, hence $A=1101$, $Q=0100$.\n- Since $\\operatorname{sign}(A)$ was $1$, compute $A:=A+M$: $1101+0011=10000$, keep low $4$ bits $A=0000$.\n- New $\\operatorname{sign}(A)=0$, so set $Q_{0}=1$. Thus end of cycle: $A=0000$, $Q=0101$.\n\nCycle 3:\n- $\\operatorname{sign}(A)=0$, so shift left $\\{A,Q\\}$: $0000\\ 0101 \\to 0000\\ 1010$, hence $A=0000$, $Q=1010$.\n- Since $\\operatorname{sign}(A)$ was $0$, compute $A:=A-M$: $0000-0011=1101$.\n- New $\\operatorname{sign}(A)=1$, so set $Q_{0}=0$. Thus end of cycle: $A=1101$, $Q=1010$.\n\nCycle 4:\n- $\\operatorname{sign}(A)=1$, so shift left $\\{A,Q\\}$: $1101\\ 1010 \\to 1011\\ 0100$, hence $A=1011$, $Q=0100$.\n- Since $\\operatorname{sign}(A)$ was $1$, compute $A:=A+M$: $1011+0011=1110$.\n- New $\\operatorname{sign}(A)=1$, so set $Q_{0}=0$. Thus end of cycle: $A=1110$, $Q=0100$.\n\nThe sequence of end-of-cycle register contents is:\n- Cycle 1: $A=1110$, $Q=1010$\n- Cycle 2: $A=0000$, $Q=0101$\n- Cycle 3: $A=1101$, $Q=1010$\n- Cycle 4: $A=1110$, $Q=0100$\n\nThis matches option A.", "answer": "$$\\boxed{A}$$", "id": "1958432"}, {"introduction": "To truly master an algorithm, one must be able to predict its behavior under specific conditions. This problem moves beyond simple execution and into the realm of analysis, asking you to identify a scenario where the restoring division algorithm is forced into its \"restore\" step during every single cycle. Solving this requires a deeper insight into the relationship between the partial remainder in the accumulator and the divisor, solidifying your understanding of why and when the restoration is necessary [@problem_id:1958391].", "problem": "In digital computer arithmetic, the restoring division algorithm is a method for performing unsigned integer division. Consider a system designed to divide a 4-bit unsigned dividend (initially in register Q) by a 4-bit unsigned divisor (in register M). The process uses a 4-bit accumulator register (A), which is initialized to zero. The division algorithm proceeds for four cycles.\n\nEach cycle consists of the following sequence of micro-operations:\n1. The 8-bit register formed by concatenating A and Q is shifted one bit to the left. The bit shifted out from the most significant bit of A is discarded, and the most significant bit of Q is shifted into the least significant bit of A. The new least significant bit of Q is set to 0.\n2. The value of the divisor M is subtracted from the accumulator A. This subtraction is performed using two's complement arithmetic.\n3. The most significant bit (the sign bit) of the result in A is checked. If it is 1 (indicating a negative result), a \"restore\" step is performed by adding the value of M back to A.\n\nWhich of the following pairs of a decimal dividend and divisor, represented as 4-bit unsigned binary numbers, will require a \"restore\" step to be performed in *every* one of the four cycles?\n\nA. Dividend = 12, Divisor = 3\n\nB. Dividend = 9, Divisor = 4\n\nC. Dividend = 7, Divisor = 8\n\nD. Dividend = 15, Divisor = 2", "solution": "Let the 4-bit registers be $A$ (accumulator), $Q$ (dividend), and $M$ (divisor). Initialize $A=0$ and let $Q$ have bits $q_{3}q_{2}q_{1}q_{0}$ (with $q_{3}$ the most significant bit). Each cycle performs:\n- Shift left the concatenated $AQ$ by one bit, which yields\n$$A \\leftarrow (A \\ll 1) + q_{3}^{(\\text{current})}, \\quad Q \\leftarrow (Q \\ll 1) \\text{ with } Q_{0}=0,$$\nwhere $q_{3}^{(\\text{current})}$ is the current most significant bit of $Q$.\n- Subtract $M$ from $A$ in two’s complement:\n$$A \\leftarrow A - M.$$\n- If the sign bit of $A$ is $1$ (i.e., $A - M < 0$ in two’s complement), perform the restore step:\n$$A \\leftarrow A + M.$$\n\nKey observation: Before the subtraction in cycle $k$, the value in $A$ equals the $k$-bit prefix of the original dividend $Q$. This follows by induction:\n- For $k=1$, $A_{1}=(0 \\ll 1)+q_{3}=q_{3}$.\n- If $A_{k}$ equals the $k$-bit prefix $q_{3}q_{2}\\dots q_{4-k}$, then after the next shift,\n$$A_{k+1}=(A_{k} \\ll 1) + q_{3-k}$$\nwhich is exactly the $(k+1)$-bit prefix $q_{3}q_{2}\\dots q_{4-k}q_{3-k}$.\n\nThus, in cycle $k$, the subtraction result is negative (sign bit $1$) if and only if $A_{k} - M < 0$. Since $A_{k}$ and $M$ are non-negative integers in $\\{0,1,\\dots,15\\}$, this is equivalent to the inequality\n$$A_{k} < M.$$\nTherefore, a restore step occurs in every one of the four cycles if and only if\n$$A_{1} < M,\\quad A_{2} < M,\\quad A_{3} < M,\\quad A_{4} < M,$$\nwhere $A_{k}$ are the $k$-bit prefixes of the dividend.\n\nEvaluate each option:\n\nA. Dividend $12$ with binary $1100_{2}$ and $M=3$.\n- $A_{1}=1$, so $1<3$ holds (restore).\n- $A_{2}=3$, so $3<3$ is false; $A_{2}-M=0$ is non-negative (no restore).\nThus not all cycles restore.\n\nB. Dividend $9$ with binary $1001_{2}$ and $M=4$.\n- $A_{1}=1<4$ (restore).\n- $A_{2}=2<4$ (restore).\n- $A_{3}=4$, so $4<4$ is false; non-negative (no restore).\nThus not all cycles restore.\n\nC. Dividend $7$ with binary $0111_{2}$ and $M=8$.\n- $A_{1}=0<8$ (restore).\n- $A_{2}=1<8$ (restore).\n- $A_{3}=3<8$ (restore).\n- $A_{4}=7<8$ (restore).\nAll four cycles require restore.\n\nD. Dividend $15$ with binary $1111_{2}$ and $M=2$.\n- $A_{1}=1<2$ (restore).\n- $A_{2}=3$, so $3<2$ is false; non-negative (no restore).\nThus not all cycles restore.\n\nOnly option C satisfies $A_{k}<M$ for $k=1,2,3,4$, so it requires a restore step in every cycle.", "answer": "$$\\boxed{C}$$", "id": "1958391"}]}