{"hands_on_practices": [{"introduction": "The power of a Carry-Save Adder lies in its modular design, which starts with a fundamental building block. This core component is a single-bit adder that takes three inputs from the same bit position—let's call them $a_i$, $b_i$, and $c_i$—and cleverly 'compresses' them into a two-bit result. This essential exercise [@problem_id:1918736] focuses on deriving the two outputs, a sum bit $s_i$ and a carry bit $c'_{i}$, solidifying the basic arithmetic that underpins the entire CSA architecture.", "problem": "A single-bit stage of a carry-save adder is a fundamental digital logic circuit. It accepts three bits as input, denoted as $a_i$, $b_i$, and $c_i$, and produces two output bits: a sum bit, $s_i$, and a carry-out bit, $c'_{i}$. The function of the circuit is to compute the arithmetic sum of the three input bits. This sum is then represented as a two-bit binary number, $(c'_{i}s_i)_2$, where $c'_{i}$ is the most significant bit and $s_i$ is the least significant bit. For example, if the inputs are $a_i=1, b_i=1, c_i=0$, their arithmetic sum is $1+1+0=2$, which is represented in binary as $10_2$. Therefore, the circuit outputs would be $c'_{i}=1$ and $s_i=0$.\n\nWhich of the following sets of input-to-output mappings, presented in the format `(a_i, b_i, c_i) -> (s_i, c'_i)`, correctly describes the behavior of this circuit for the given inputs?\n\nA.\nSet 1: `(0, 1, 1) -> (0, 1)`\nSet 2: `(1, 1, 1) -> (1, 1)`\nSet 3: `(1, 0, 0) -> (1, 0)`\n\nB.\nSet 1: `(0, 1, 1) -> (1, 0)`\nSet 2: `(1, 1, 1) -> (1, 1)`\nSet 3: `(1, 0, 0) -> (1, 0)`\n\nC.\nSet 1: `(0, 1, 1) -> (0, 1)`\nSet 2: `(1, 1, 1) -> (1, 0)`\nSet 3: `(1, 0, 0) -> (1, 0)`\n\nD.\nSet 1: `(0, 1, 1) -> (0, 1)`\nSet 2: `(1, 1, 1) -> (0, 1)`\nSet 3: `(1, 0, 0) -> (0, 0)`", "solution": "A single-bit carry-save adder stage computes the arithmetic sum of three input bits $a_{i}$, $b_{i}$, and $c_{i}$. Let $S = a_{i} + b_{i} + c_{i}$, where addition is ordinary integer addition with $a_{i}, b_{i}, c_{i} \\in \\{0,1\\}$. The two-bit output $(c'_{i}s_{i})_{2}$ must satisfy\n$$\ns_{i} = S \\bmod 2, \\qquad c'_{i} = \\left\\lfloor \\frac{S}{2} \\right\\rfloor.\n$$\nEquivalently, in Boolean algebra,\n$$\ns_{i} = a_{i} \\oplus b_{i} \\oplus c_{i}, \\qquad c'_{i} = a_{i} b_{i} \\lor b_{i} c_{i} \\lor a_{i} c_{i}.\n$$\nEvaluate for each given input triple:\n\n- For $(a_{i}, b_{i}, c_{i}) = (0,1,1)$: \n$$\nS = 0 + 1 + 1 = 2, \\quad s_{i} = 2 \\bmod 2 = 0, \\quad c'_{i} = \\left\\lfloor \\frac{2}{2} \\right\\rfloor = 1,\n$$\nso $(s_{i}, c'_{i}) = (0,1)$.\n\n- For $(a_{i}, b_{i}, c_{i}) = (1,1,1)$:\n$$\nS = 1 + 1 + 1 = 3, \\quad s_{i} = 3 \\bmod 2 = 1, \\quad c'_{i} = \\left\\lfloor \\frac{3}{2} \\right\\rfloor = 1,\n$$\nso $(s_{i}, c'_{i}) = (1,1)$.\n\n- For $(a_{i}, b_{i}, c_{i}) = (1,0,0)$:\n$$\nS = 1 + 0 + 0 = 1, \\quad s_{i} = 1 \\bmod 2 = 1, \\quad c'_{i} = \\left\\lfloor \\frac{1}{2} \\right\\rfloor = 0,\n$$\nso $(s_{i}, c'_{i}) = (1,0)$.\n\nComparing with the options, only option A lists all three mappings correctly.", "answer": "$$\\boxed{A}$$", "id": "1918736"}, {"introduction": "With the single-bit logic established, we can now assemble these blocks to see the true speed advantage of a Carry-Save Adder. A multi-bit CSA consists of an array of these adders working in parallel, with each one handling a different bit position simultaneously and independently. This exercise [@problem_id:1918731] provides hands-on practice with this core operation, guiding you to calculate the separate sum ($S$) and carry ($C_{vec}$) vectors, which are generated without waiting for any carry propagation.", "problem": "A specialized Digital Signal Processor (DSP) core is designed to perform rapid Finite Impulse Response (FIR) filtering, a common operation in audio processing. A key component of this core is a circuit that must add three 4-bit unsigned binary numbers simultaneously. To achieve the required speed, a Carry-Save Adder (CSA) is employed. A CSA is a type of digital adder which generates a partial sum and a sequence of carry bits from three or more numbers. It defers the final carry propagation to a later stage, thus avoiding the delay of a conventional ripple-carry adder.\n\nConsider the first stage of a 4-bit CSA processing three input operands: $X = 1010_2$, $Y = 0101_2$, and $Z = 1100_2$. This stage consists of four parallel full adders, one for each bit position. The full adder at bit position $i$ takes the input bits $X_i$, $Y_i$, and $Z_i$ and produces a sum bit $S_i$ and a carry-out bit $c_{i+1}$.\n\nDetermine the resulting 4-bit partial sum vector, $S = S_3S_2S_1S_0$, and the 4-bit carry vector, $C_{vec} = c_4c_3c_2c_1$, that are the outputs of this CSA stage.\n\nPresent your answer as a row matrix containing the two 4-bit binary strings. The first element of the matrix should be the sum vector $S$, and the second element should be the carry vector $C_{vec}$.", "solution": "A carry-save full adder at bit position $i$ takes three input bits $(X_{i},Y_{i},Z_{i})$ and produces:\n$$S_{i}=X_{i}\\oplus Y_{i}\\oplus Z_{i},\\qquad c_{i+1}=X_{i}Y_{i}+Y_{i}Z_{i}+Z_{i}X_{i}.$$\nFor $X=1010_{2}$, $Y=0101_{2}$, $Z=1100_{2}$, the bit assignments are:\n$$(X_{3},X_{2},X_{1},X_{0})=(1,0,1,0),\\quad (Y_{3},Y_{2},Y_{1},Y_{0})=(0,1,0,1),\\quad (Z_{3},Z_{2},Z_{1},Z_{0})=(1,1,0,0).$$\nCompute per bit:\n- For $i=0$: $(X_{0},Y_{0},Z_{0})=(0,1,0)$, so $S_{0}=0\\oplus 1\\oplus 0=1$, and $c_{1}=0\\cdot 1+1\\cdot 0+0\\cdot 0=0$.\n- For $i=1$: $(X_{1},Y_{1},Z_{1})=(1,0,0)$, so $S_{1}=1\\oplus 0\\oplus 0=1$, and $c_{2}=1\\cdot 0+0\\cdot 0+1\\cdot 0=0$.\n- For $i=2$: $(X_{2},Y_{2},Z_{2})=(0,1,1)$, so $S_{2}=0\\oplus 1\\oplus 1=0$, and $c_{3}=0\\cdot 1+1\\cdot 1+0\\cdot 1=1$.\n- For $i=3$: $(X_{3},Y_{3},Z_{3})=(1,0,1)$, so $S_{3}=1\\oplus 0\\oplus 1=0$, and $c_{4}=1\\cdot 0+0\\cdot 1+1\\cdot 1=1$.\nThus the partial sum vector is $S=S_{3}S_{2}S_{1}S_{0}=0011$, and the carry vector is $C_{vec}=c_{4}c_{3}c_{2}c_{1}=1100$.", "answer": "$$\\boxed{\\begin{pmatrix} 0011 & 1100 \\end{pmatrix}}$$", "id": "1918731"}, {"introduction": "The first stage of a CSA brilliantly reduces three operands into two intermediate vectors, but the job is not yet complete. To obtain the final result, these two vectors—the partial sum vector $S$ and the carry vector $C$—must be added together using a conventional adder where carry propagation takes place. This final practice problem [@problem_id:1918753] walks you through this crucial second stage, demonstrating how the deferred carries are resolved to produce the correct final sum.", "problem": "In high-performance Digital Signal Processing (DSP) applications, fast multiplication is crucial. This is often implemented by summing a series of partial products. To accelerate the process of adding multiple operands, a Carry-Save Adder (CSA) is frequently employed. Unlike a conventional adder, a CSA reduces three input numbers into two output numbers—a sum vector and a carry vector—without the delay of full carry propagation.\n\nConsider a custom-designed 4-bit DSP core that uses a CSA as a key component. The CSA takes three 4-bit operands and produces a 4-bit sum vector, $S$, and a 4-bit carry vector, $C$. The carry vector $C$ is formed by taking the carry bit generated from each of the four internal full adders and shifting this sequence one position to the left, with a zero filling the least significant bit position. These two resulting vectors, $S$ and $C$, are then passed to a final 4-bit Ripple-Carry Adder (RCA) to produce the final sum. The carry-out from this final RCA becomes the most significant bit of the overall result.\n\nSuppose for a specific computation, the CSA stage outputs the sum vector $S = 1011_2$ and the carry vector $C = 0110_2$. Calculate the final 5-bit sum that results from adding these two vectors. Provide the answer as a 5-bit binary number.", "solution": "A carry-save adder produces a sum vector $S$ and a shifted carry vector $C$ that are then combined by a ripple-carry adder (RCA). The RCA forms the final result by adding $S$ and $C$ with full carry propagation from least significant bit (LSB) to most significant bit (MSB). Let $S = s_{3}s_{2}s_{1}s_{0} = 1011_{2}$ and $C = c_{3}c_{2}c_{1}c_{0} = 0110_{2}$. Initialize the incoming carry as $k_{0} = 0$. For each bit position $i \\in \\{0,1,2,3\\}$, the RCA computes\n$$\nr_{i} = s_{i} \\oplus c_{i} \\oplus k_{i}, \\quad\nk_{i+1} = (s_{i} \\land c_{i}) \\lor (s_{i} \\land k_{i}) \\lor (c_{i} \\land k_{i}).\n$$\nCompute bit by bit:\n\n- LSB ($i=0$): $s_{0}=1$, $c_{0}=0$, $k_{0}=0$,\n$$\nr_{0} = 1 \\oplus 0 \\oplus 0 = 1, \\quad\nk_{1} = (1 \\land 0) \\lor (1 \\land 0) \\lor (0 \\land 0) = 0.\n$$\n\n- $i=1$: $s_{1}=1$, $c_{1}=1$, $k_{1}=0$,\n$$\nr_{1} = 1 \\oplus 1 \\oplus 0 = 0, \\quad\nk_{2} = (1 \\land 1) \\lor (1 \\land 0) \\lor (1 \\land 0) = 1.\n$$\n\n- $i=2$: $s_{2}=0$, $c_{2}=1$, $k_{2}=1$,\n$$\nr_{2} = 0 \\oplus 1 \\oplus 1 = 0, \\quad\nk_{3} = (0 \\land 1) \\lor (0 \\land 1) \\lor (1 \\land 1) = 1.\n$$\n\n- MSB of 4-bit stage ($i=3$): $s_{3}=1$, $c_{3}=0$, $k_{3}=1$,\n$$\nr_{3} = 1 \\oplus 0 \\oplus 1 = 0, \\quad\nk_{4} = (1 \\land 0) \\lor (1 \\land 1) \\lor (0 \\land 1) = 1.\n$$\n\nThe final 5-bit result is the concatenation of the final carry-out and the four sum bits:\n$$\nr_{4}r_{3}r_{2}r_{1}r_{0} = 1\\,0\\,0\\,0\\,1 = 10001_{2}.\n$$", "answer": "$$\\boxed{10001_{2}}$$", "id": "1918753"}]}