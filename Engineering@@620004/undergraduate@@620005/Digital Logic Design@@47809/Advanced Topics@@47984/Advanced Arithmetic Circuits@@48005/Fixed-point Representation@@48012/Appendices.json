{"hands_on_practices": [{"introduction": "Before diving into complex applications, it is essential to master the fundamentals of fixed-point representation. This first practice exercise grounds your understanding by walking you through the core process of converting decimal numbers, both positive and negative, into a specific fixed-point format and then performing a basic arithmetic operation. By working through the conversion to Q4.4 format and executing a binary addition using two's complement, you will build the foundational skills necessary for all subsequent work with fixed-point numbers [@problem_id:1935892].", "problem": "A simple embedded system uses a dedicated Digital Signal Processor (DSP) to process sensor data. The DSP represents all numbers using a signed 8-bit fixed-point format, specifically the Q4.4 format. In this convention, a number has 4 bits for the integer part (including one sign bit) and 4 bits for the fractional part. Negative numbers are represented using two's complement.\n\nThe system takes a raw sensor reading and adds a pre-determined calibration offset to it. In a particular instance, the raw sensor reading is equivalent to the decimal value $5.75$, and the calibration offset is equivalent to the decimal value $-2.25$.\n\nThe DSP performs the addition of these two values. What is the resulting 8-bit binary string, without any spaces or a binary point, that represents the final calibrated value in the Q4.4 format?\n\nChoose the correct option from the following:\n\nA. `00111000`\n\nB. `00110111`\n\nC. `01111100`\n\nD. `11011100`\n\nE. `11001000`", "solution": "In Q4.4 fixed-point with two's complement, an 8-bit stored integer $N$ represents the real value $v$ via $v = \\frac{N}{2^{4}}$, and conversely $N = v \\cdot 2^{4}$. Addition is performed on the stored integers modulo $2^{8}$, with the carry out discarded.\n\nCompute the stored integers:\n- For the raw reading $v_{1} = 5.75$, we have $N_{1} = 5.75 \\cdot 2^{4} = 92$. In 8-bit binary, $92$ is 01011100.\n- For the offset $v_{2} = -2.25$, we have $N_{2} = -2.25 \\cdot 2^{4} = -36$. The 8-bit two's complement for $-36$ is obtained from $36 = 00100100$ by inverting and adding $1$, giving 11011100.\n\nAdd the stored integers (modulo $2^{8}$):\n$$N_{\\text{sum}} = N_{1} + N_{2} = 92 + (-36) = 56.$$\nEquivalently, binary addition 01011100 + 11011100 produces a carry that is discarded, yielding 00111000.\n\nConvert back to the real value to verify:\n$$v_{\\text{sum}} = \\frac{N_{\\text{sum}}}{2^{4}} = \\frac{56}{16} = 3.5,$$\nwhich lies within the Q4.4 range. Therefore, the resulting 8-bit Q4.4 representation is 00111000, corresponding to option A.", "answer": "$$\\boxed{A}$$", "id": "1935892"}, {"introduction": "While fixed-point arithmetic is efficient, it comes with a critical limitation: a finite representable range. This exercise transitions from basic operations to the practical challenge of arithmetic overflow, a common source of error in digital systems. You will analyze a subtraction operation within a Q5.3 system to determine if the result exceeds the format's boundaries, learning the conditions that lead to overflow and how to detect it [@problem_id:1935887]. Understanding these limits is crucial for designing reliable and bug-free hardware.", "problem": "An embedded control system for a robotic arm uses a signed 8-bit fixed-point number system to represent joint velocities. The format is a Q5.3 two's complement representation, meaning there are 5 bits for the integer part (including the sign bit) and 3 bits for the fractional part.\n\nThe controller needs to compute the relative velocity between two joints. It has two stored velocity values: `A`, representing the decimal value 10, and `B`, representing the decimal value -10. The system hardware calculates the difference $D = A - B$.\n\nWhich of the following statements correctly describes the outcome of this specific calculation within the processor?\n\nA. Overflow does not occur, and the result is correctly represented as 20.\n\nB. Overflow does not occur because the subtraction of two numbers with opposite signs can never result in an overflow.\n\nC. Overflow occurs because the operation, which is equivalent to adding two positive numbers, yields a result with a negative sign bit.\n\nD. Overflow occurs because the value -10 cannot be represented in the Q5.3 format.\n\nE. Overflow occurs because the final carry-out bit from the most significant bit position is 0.", "solution": "In an 8-bit two's complement fixed-point system with Q5.3 format, there are 5 integer bits including the sign bit and 3 fractional bits. The quantization step is $2^{-3}$. The representable range for a signed Q$5.3$ number is obtained from the two's complement range scaled by $2^{-3}$:\n$$\nx_{\\min}=-2^{5-1}=-2^{4}=-16,\\qquad x_{\\max}=2^{5-1}-2^{-3}=2^{4}-2^{-3}=16-2^{-3}=15.875.\n$$\nTherefore, both $A=10$ and $B=-10$ are representable.\n\nThe fixed-point encoding uses scaling by $2^{3}$, so the stored integer codes are\n$$\nk_{A}=A\\cdot 2^{3}=10\\cdot 2^{3}=80,\\qquad k_{B}=B\\cdot 2^{3}=-10\\cdot 2^{3}=-80.\n$$\nIn 8-bit two's complement, $k_{A}=80$ is $01010000_2$, and $k_{B}=-80$ is $10110000_2$.\n\nThe hardware computes the difference $D=A-B$. In two's complement arithmetic,\n$D=A-B=A+(-B)$.\nSince $B=-10$, we have $-B=+10$, so the operation is equivalent to adding two positive numbers:\n$D=10+10=20$.\nIn code space this corresponds to\n$$\nk_{D}=k_{A}-k_{B}=80-(-80)=160.\n$$\nThe valid code range for 8-bit two's complement is $[-2^{7},\\,2^{7}-1]=[-128,\\,127]$. The value $k_{D}=160$ is outside this range, so the 8-bit adder will wrap modulo $2^{8}$:\n$$\nk_{D}\\equiv 160 \\pmod{256}=160-256=-96.\n$$\nThe stored result code is thus $10100000_2$, which has a sign bit of $1$ (negative). Interpreted as a Q5.3 value, this code represents\n$$\nx_{D}=-96\\cdot 2^{-3}=-12,\n$$\nwhich is not the mathematically correct $20$ and also lies within the representable range only due to wrap-around; this discrepancy indicates signed overflow.\n\nThe standard two's complement signed-overflow condition for addition is that adding two operands with the same sign yields a result with a different sign. Here, $A$ and $-B$ are both positive, while the result's sign bit is $1$ (negative), so overflow occurs. Equivalently, overflow can be detected by the exclusive-or of the carry into and the carry out of the most significant bit; for $01010000+01010000$, the carry into the MSB is $1$ and the carry out is $0$, so their exclusive-or is $1$, confirming overflow.\n\nEvaluating the options:\n- A is false because $20$ exceeds the maximum $15.875$, so overflow does occur and the result is not correctly represented.\n- B is false because $A-B$ with $B0$ is equivalent to adding two positive numbers, which can overflow.\n- C is true: the operation is equivalent to adding two positive numbers and yields a negative sign bit, the canonical two's complement overflow condition.\n- D is false because $-10$ is representable in Q5.3.\n- E is false as stated: a final carry-out of $0$ alone does not imply overflow; the correct criterion uses the exclusive-or of carry into and out of the MSB.\n\nTherefore, the correct statement is C.", "answer": "$$\\boxed{C}$$", "id": "1935887"}, {"introduction": "This final practice demonstrates the true power of fixed-point representation in real-world engineering, moving from theory to hardware optimization. In many digital signal processing (DSP) applications, multiplication by a constant can be implemented far more efficiently without a full multiplier circuit. This problem challenges you to design such a circuit using only shifters and adders by leveraging the Canonical Signed Digit (CSD) representation of the constant, a technique that guarantees the minimal number of arithmetic operations. This is a practical application that highlights how number representation directly impacts hardware efficiency, cost, and power consumption [@problem_id:1935863].", "problem": "In many Digital Signal Processing (DSP) applications, it is necessary to multiply a stream of data by a fixed constant. To create efficient hardware that minimizes circuit area and power consumption, full multiplier circuits are often avoided. Instead, such \"constant multiplication\" is implemented using only arithmetic shifters (which perform multiplication or division by powers of two) and adders/subtractors. The efficiency of this method depends on representing the constant using the minimum possible number of non-zero digits.\n\nYou are tasked with designing such a specialized arithmetic unit. The unit takes an 8-bit signed input number `X`, which is in a Q4.4 fixed-point format (4 integer bits including the sign bit, and 4 fractional bits). The unit must compute $Y = X \\times 2.3125$.\n\nYour design must be based on the Canonical Signed Digit (CSD) representation of the constant $2.3125$. The Canonical Signed Digit (CSD) representation is a system where each digit can be $1$, $0$, or $\\bar{1}$ (representing -1), with the crucial property that no two consecutive digits are non-zero. This property guarantees the minimum number of non-zero digits for any given constant.\n\nWhich of the following sequences of shift-and-add/subtract operations correctly implements the desired multiplication $Y = X \\times 2.3125$ with the minimum number of arithmetic operations (additions or subtractions) that results from using the CSD method?\n\n**Notation**:\n- $X$ is the input number.\n- `(X  n)` denotes an arithmetic left shift of $X$ by $n$ bits (equivalent to multiplication by $2^n$).\n- `(X >> n)` denotes an arithmetic right shift of $X$ by $n$ bits (equivalent to division by $2^n$).\n\nA. `Y = (X  1) + (X >> 2) + (X >> 4)`\n\nB. `Y = (X  1) + (X >> 1) - (X >> 2) + (X >> 4)`\n\nC. `Y = (X  2) - (X >> 2) - (X >> 4)`\n\nD. `Y = (X  1) + (X >> 2) + (X >> 3) - (X >> 4)`\n\nE. `Y = (X  2) - (X >> 1) + (X >> 3)`", "solution": "The problem requires us to find the most efficient implementation of multiplication by the constant $K=2.3125$ using only shifters and adders/subtractors. The method specified is to use the Canonical Signed Digit (CSD) representation of the constant.\n\n**Step 1: Convert the constant to binary representation.**\nFirst, we convert the constant $K = 2.3125$ into its binary equivalent. We can do this by converting the integer and fractional parts separately.\nThe integer part is $2$, which is $(10)_2$.\nThe fractional part is $0.3125$. To convert this, we can express it as a sum of negative powers of two.\n$0.3125 = \\frac{3125}{10000} = \\frac{5}{16}$.\nAs a fraction with a power-of-two denominator, this is easy to convert:\n$\\frac{5}{16} = \\frac{4+1}{16} = \\frac{4}{16} + \\frac{1}{16} = 2^{-2} + 2^{-4}$.\nIn binary, this fractional part is $0.0101_2$.\nCombining the integer and fractional parts, the binary representation of $2.3125$ is $10.0101_2$.\n\n**Step 2: Convert the binary representation to CSD representation.**\nThe CSD representation is unique for any number and has the property that no two consecutive digits are non-zero. The digits can be $\\{1, 0, \\bar{1}\\}$, where $\\bar{1} = -1$.\nA common algorithm to convert a binary number to CSD is to replace any sequence of $k \\ge 2$ ones, of the form `01...1` (with $k$ ones), with `10...0`$\\bar{1}$.\nLet's examine our binary number: $10.0101_2$.\nThe non-zero digits are at the positions corresponding to $2^1$, $2^{-2}$, and $2^{-4}$. There are no consecutive non-zero digits in this representation. For example, there is no `11` or `11` pattern.\nSince the binary representation $10.0101_2$ already satisfies the CSD property (no two consecutive non-zero digits), it is identical to its CSD representation.\nSo, $K_{CSD} = 10.0101_{CSD}$.\n\n**Step 3: Translate the CSD representation into shift-and-add operations.**\nThe CSD representation $10.0101_{CSD}$ corresponds to the following sum of signed powers of two:\n$K = 1 \\cdot 2^1 + 0 \\cdot 2^0 + 0 \\cdot 2^{-1} + 1 \\cdot 2^{-2} + 0 \\cdot 2^{-3} + 1 \\cdot 2^{-4}$\n$K = 2^1 + 2^{-2} + 2^{-4}$\nTo multiply the input `X` by this constant, we perform the operation:\n$Y = X \\times K = X \\times (2^1 + 2^{-2} + 2^{-4})$\nDistributing `X` across the terms gives:\n$Y = (X \\times 2^1) + (X \\times 2^{-2}) + (X \\times 2^{-4})$\nThis expression can be implemented using arithmetic shifts:\n`Y = (X  1) + (X >> 2) + (X >> 4)`\n\n**Step 4: Match the result with the given options.**\nThe derived expression `Y = (X  1) + (X >> 2) + (X >> 4)` corresponds exactly to option A.\nThis implementation has three non-zero terms, which requires $3-1 = 2$ additions. This is the minimum number of operations because the CSD representation is minimal.\n\nLet's briefly examine the other options. Some options, like B and D, also compute the correct value but are not based on the minimal CSD form:\n- Option B: `Y = (X  1) + (X >> 1) - (X >> 2) + (X >> 4)` represents $K = 2 + 0.5 - 0.25 + 0.0625 = 2.3125$. This implementation requires 3 add/subtract operations.\n- Option D: `Y = (X  1) + (X >> 2) + (X >> 3) - (X >> 4)` represents $K = 2 + 0.25 + 0.125 - 0.0625 = 2.3125$. This implementation also requires 3 add/subtract operations.\nThese are valid but less efficient signed-digit representations. The question asks for the implementation derived from the CSD method, which is guaranteed to be the most efficient in terms of the number of add/subtract operations. Options C and E result in incorrect constant values.\n\nTherefore, Option A is the correct answer as it represents the unique, minimal CSD implementation.", "answer": "$$\\boxed{A}$$", "id": "1935863"}]}