{"hands_on_practices": [{"introduction": "Before we can build a complex multiplier, we must first understand its most fundamental component: the generation of partial products. This initial stage forms the bedrock of array multipliers, where each bit of the multiplier is ANDed with the entire multiplicand. This exercise [@problem_id:1914114] provides a practical starting point by asking you to calculate the basic gate count required, giving you a tangible sense of how a circuit's complexity scales with the size of the numbers being processed.", "problem": "A team of digital logic designers is creating a specialized co-processor for a real-time Digital Signal Processing (DSP) application. A key component of this co-processor is a dedicated hardware multiplier designed to perform multiplication of two unsigned binary numbers. The architecture specifies that the first operand (the multiplicand) is a 7-bit number, and the second operand (the multiplier) is a 5-bit number.\n\nThe multiplication process is implemented using the standard array multiplier method. In the first stage of this process, a set of partial products is generated. Each partial product is formed by the logical AND operation between one bit of the multiplier and all the bits of the multiplicand. These partial products are then fed into an array of adders in the subsequent stage.\n\nAssuming the hardware for generating these partial products is constructed exclusively from two-input AND gates, calculate the total number of two-input AND gates required for this partial product generation stage.", "solution": "Let the multiplicand have $m$ bits and the multiplier have $n$ bits. For a standard array multiplier, the partial product bits are generated by ANDing each bit of the multiplicand with each bit of the multiplier. If $a_{i}$ denotes the $i$th bit of the multiplicand for $i \\in \\{0,\\dots,m-1\\}$ and $b_{j}$ denotes the $j$th bit of the multiplier for $j \\in \\{0,\\dots,n-1\\}$, then each partial product bit is\n$$\np_{i,j} = a_{i} \\land b_{j},\n$$\nwhich is implemented by one two-input AND gate.\n\nTherefore, the total number of two-input AND gates required equals the total number of such $(i,j)$ pairs, which is the size of the Cartesian product of the $m$ multiplicand bits and $n$ multiplier bits:\n$$\n\\sum_{j=0}^{n-1}\\sum_{i=0}^{m-1} 1 = m \\times n.\n$$\nSubstituting $m=7$ and $n=5$ gives\n$$\n7 \\times 5 = 35.\n$$\nHence, the partial product generation stage requires $35$ two-input AND gates.", "answer": "$$\\boxed{35}$$", "id": "1914114"}, {"introduction": "While the standard array multiplier is straightforward, its performance can be significantly improved. Booth's algorithm is a powerful technique that enhances efficiency by reducing the number of addition and subtraction operations, particularly when multiplying signed numbers. This thought experiment [@problem_id:1914183] challenges you to think critically about the core principle of Booth's algorithm—skipping over runs of identical bits—to find a multiplier that leverages this feature for maximum efficiency.", "problem": "In digital systems, Booth's algorithm is a multiplication algorithm that multiplies two signed binary numbers in 2's complement notation. Its efficiency stems from its ability to handle strings of consecutive ones in the multiplier, often reducing the number of required addition and subtraction operations compared to the standard \"add and shift\" method. The algorithm inspects the multiplier bits from right to left, one pair at a time.\n\nConsider the multiplication of two signed 4-bit integers, $P = M \\times R$, where $M$ is the multiplicand and $R$ is the multiplier. The number of addition and subtraction operations performed by Booth's algorithm is determined entirely by the bit pattern of the multiplier $R$.\n\nYour task is to find a non-zero 4-bit binary value for the multiplier $R$ that results in the minimum possible number of total addition and subtraction operations. If multiple such 4-bit values for $R$ exist, select the one that represents the signed decimal integer with the smallest absolute value (i.e., the value closest to zero). Provide this 4-bit binary value as your answer.", "solution": "Let the 4-bit two’s complement multiplier be $R = Q_{3}Q_{2}Q_{1}Q_{0}$ with an extra bit $Q_{-1}=0$ appended at the right as in Booth’s algorithm. At each step $i \\in \\{0,1,2,3\\}$, the algorithm examines the pair $(Q_{i},Q_{i-1})$ and:\n- performs an addition if $(Q_{i},Q_{i-1})=(1,0)$,\n- performs a subtraction if $(Q_{i},Q_{i-1})=(0,1)$,\n- performs no operation if $(Q_{i},Q_{i-1})=(0,0)$ or $(1,1)$.\n\nTherefore, the total number of additions and subtractions is exactly the number of transitions between adjacent bits in the extended sequence $Q_{-1},Q_{0},Q_{1},Q_{2},Q_{3}$. Equivalently,\n$$\nN_{\\text{ops}}=\\sum_{i=0}^{3} \\mathbf{1}\\{Q_{i}\\neq Q_{i-1}\\},\n$$\nwhere $\\mathbf{1}\\{\\cdot\\}$ is the indicator function.\n\nThe minimum possible value of $N_{\\text{ops}}$ for a non-zero $R$ is $1$. Indeed:\n- If $R=0000$, then $N_{\\text{ops}}=0$, but this is excluded by the non-zero constraint.\n- If $R\\neq 0000$, let $k$ be the smallest index with $Q_{k}=1$. Since $Q_{-1}=0$ and $Q_{0},\\ldots,Q_{k-1}=0$ by minimality of $k$, the pair $(Q_{k},Q_{k-1})=(1,0)$ contributes at least one operation, hence $N_{\\text{ops}} \\geq 1$.\n- To achieve $N_{\\text{ops}}=1$, there must be no further transitions, which requires $Q_{j}=1$ for all $j \\geq k$. Thus $R$ must have the form of a single transition from zeros (least significant side) to ones (most significant side).\n\nFor 4 bits, the exact $R$ that yield $N_{\\text{ops}}=1$ are\n$$\nR \\in \\{1000,\\,1100,\\,1110,\\,1111\\}.\n$$\nIn 4-bit two’s complement these represent, respectively,\n$$\n1000=-8,\\quad 1100=-4,\\quad 1110=-2,\\quad 1111=-1.\n$$\nAmong these, the smallest absolute value is $|-1|=1$, corresponding to $R=1111$.\n\nTherefore, the non-zero 4-bit multiplier that minimizes the number of additions/subtractions and, among ties, has the smallest absolute value is $1111$.", "answer": "$$\\boxed{1111}$$", "id": "1914183"}, {"introduction": "Moving from algorithmic theory to practical design, the final step is to translate the logic of binary multiplication into a physical circuit. Each output bit of a multiplier corresponds to a specific Boolean function of the input bits, which can be optimized and implemented with standard logic gates. This hands-on design problem [@problem_id:1382069] tasks you with synthesizing the logic for a single output bit using only NAND gates, bridging the gap between abstract arithmetic and concrete gate-level implementation.", "problem": "A digital logic circuit is designed to perform the multiplication of two 2-bit unsigned binary numbers. The first number is represented as $A=A_1A_0$, and the second number is $B=B_1B_0$. The values of these numbers are given by $A = 2A_1 + A_0$ and $B = 2B_1 + B_0$, where $A_1, A_0, B_1, B_0$ are the individual bits. The circuit produces a 4-bit unsigned binary product, $P=P_3P_2P_1P_0$, where the value of the product is $P = 8P_3 + 4P_2 + 2P_1 + P_0$.\n\nThe entire circuit must be constructed using only 2-input NAND gates. Assuming an optimal design based on a minimal sum-of-products or product-of-sums expression, determine the minimum number of 2-input NAND gates required to implement the logic for the output bit $P_2$ alone.", "solution": "Let the inputs be $A_{1},A_{0},B_{1},B_{0}$ and the product bits be $P_{3}P_{2}P_{1}P_{0}$. For a $2$-bit unsigned multiplier, the partial products are:\n- $x_{0}=A_{0}B_{0}$ contributes to $P_{0}$,\n- $x_{1}=A_{1}B_{0}$ and $x_{2}=A_{0}B_{1}$ sum to form $P_{1}$ with carry $c_{1}=x_{1}x_{2}$,\n- $x_{3}=A_{1}B_{1}$ combines with $c_{1}$ to form $P_{2}$ and a carry to $P_{3}$.\n\nThus,\n$$\nP_{2}=x_{3}\\oplus c_{1}=(A_{1}B_{1})\\oplus\\big((A_{1}B_{0})(A_{0}B_{1})\\big).\n$$\n\nConstructing the truth set for $P_{2}$ (equivalently by enumerating products) shows that $P_{2}=1$ for input combinations $(A_{1},A_{0},B_{1},B_{0})\\in\\{(1,0,1,0),(1,0,1,1),(1,1,1,0)\\}$. A minimal sum-of-products cover is\n$$\nP_{2}=A_{1}B_{1}\\overline{B_{0}}+A_{1}\\overline{A_{0}}B_{1}.\n$$\nFactoring yields a more convenient form for NAND implementation:\n$$\nP_{2}=A_{1}B_{1}\\left(\\overline{A_{0}}+\\overline{B_{0}}\\right)=A_{1}B_{1}\\,\\overline{A_{0}B_{0}}.\n$$\n\nNow implement $P_{2}=S\\,T$ with only $2$-input NAND gates, where $S=A_{1}B_{1}$ and $T=\\overline{A_{0}B_{0}}$.\n\nGate-level synthesis with $2$-input NANDs:\n- Compute $\\overline{S}=\\overline{A_{1}B_{1}}$ by one NAND: $G_{1}=\\operatorname{NAND}(A_{1},B_{1})$.\n- Invert to get $S$ by one NAND: $G_{2}=\\operatorname{NAND}(G_{1},G_{1})=A_{1}B_{1}$.\n- Compute $T=\\overline{A_{0}B_{0}}$ by one NAND: $G_{3}=\\operatorname{NAND}(A_{0},B_{0})$.\n- Form $\\overline{ST}$ by one NAND: $G_{4}=\\operatorname{NAND}(G_{2},G_{3})=\\overline{(A_{1}B_{1})\\,\\overline{A_{0}B_{0}}}$.\n- Invert to obtain $P_{2}$ by one NAND: $G_{5}=\\operatorname{NAND}(G_{4},G_{4})=P_{2}$.\n\nThis realizes $P_{2}$ with exactly $5$ two-input NAND gates. Any attempt to reduce the count further fails because:\n- The minimal SOP has two $3$-literal product terms; implementing their NAND-NAND form with $2$-input gates requires at least $7$ gates unless factoring is used.\n- The factored form $A_{1}B_{1}\\,\\overline{A_{0}B_{0}}$ separates the variables optimally and achieves the minimal known count, and structural constraints of NAND-only logic necessitate the two inversions accounted for above.\nTherefore, the minimum number of $2$-input NAND gates required to implement $P_{2}$ is $5$.", "answer": "$$\\boxed{5}$$", "id": "1382069"}]}