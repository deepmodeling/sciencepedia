{"hands_on_practices": [{"introduction": "The first step in mastering any data representation is learning to interpret its structure. This exercise provides foundational practice by asking you to decode a binary pattern from a custom floating-point format into its familiar decimal value. Mastering this process is essential for understanding how computers store and manipulate non-integer numbers at the bit level. [@problem_id:1937520]", "problem": "An engineer is designing a low-power microcontroller for an environmental sensor. To conserve memory, the microcontroller uses a custom 10-bit floating-point number format to represent sensor readings. This format is defined as follows:\n\n- **Sign (S)**: 1 bit (0 for positive, 1 for negative)\n- **Exponent (E)**: 5 bits, using an exponent bias of 15.\n- **Fraction (F)**: 4 bits\n\nThe bits are arranged in the order S, E, F, from most significant to least significant. The value of a normalized number is given by the formula $V = (-1)^{S} \\times (1.F)_{2} \\times 2^{(E-15)}$, where $(1.F)_{2}$ is the mantissa with an implicit leading 1. The special cases for an exponent of all zeros (denormalized numbers/zero) or all ones (infinity/NaN) do not apply to this problem.\n\nSuppose the microcontroller's memory contains the 10-bit binary value `1100101100`. Determine the decimal value represented by this floating-point number. Express your answer as a decimal number, rounded to four significant figures if necessary.", "solution": "The 10-bit word is 1100101100, arranged as $S|E|F$ with $S$ the first bit, $E$ the next five bits, and $F$ the last four bits. Thus $S=1$, $E=10010_{2}$, and $F=1100_{2}$. Since $E$ is neither all zeros nor all ones, the number is normalized and we use\n$$\nV = (-1)^{S}\\,(1.F)_{2}\\,2^{(E-15)}.\n$$\n\nConvert the exponent: \n$$\nE = 1\\cdot 2^{4} + 0\\cdot 2^{3} + 0\\cdot 2^{2} + 1\\cdot 2^{1} + 0\\cdot 2^{0} = 16 + 2 = 18,\n$$\nso the unbiased exponent is\n$$\nE - 15 = 18 - 15 = 3.\n$$\n\nCompute the mantissa:\n$$\n(1.F)_{2} = 1 + 1\\cdot 2^{-1} + 1\\cdot 2^{-2} + 0\\cdot 2^{-3} + 0\\cdot 2^{-4} = 1 + \\frac{1}{2} + \\frac{1}{4} = \\frac{7}{4}.\n$$\n\nWith $S=1$, the sign factor is $(-1)^{1}=-1$. Therefore,\n$$\nV = -\\frac{7}{4}\\,2^{3} = -\\frac{7}{4}\\cdot 8 = -14.\n$$\n\nThis is an exact decimal value; rounding is not needed.", "answer": "$$\\boxed{-14}$$", "id": "1937520"}, {"introduction": "Floating-point numbers are powerful, but they trade infinite precision for a vast range. This practice problem delves into the direct consequences of this trade-off by having you encode a decimal number and calculate the unavoidable representation error. You'll see firsthand how limitations in storage, such as a small fraction field, affect the accuracy of data in a computational system. [@problem_id:1937508]", "problem": "A specialized embedded system uses a custom 8-bit floating-point number representation to store sensor data. This format is defined as follows:\n- 1 bit for the sign (S): 0 for positive, 1 for negative.\n- 4 bits for the exponent (E): The exponent is stored with a bias of 7.\n- 3 bits for the fraction (F): The number is normalized in the form $1.F...$ and the leading 1 is implicit.\n\nThe bits are arranged in the order S, E, F. If a number's binary representation has more fractional bits than can be stored, the system truncates the excess bits (it does not round).\n\nCalculate the absolute representation error that occurs when the system attempts to store the decimal value $9.2$. Provide your answer as a decimal number rounded to three significant figures.", "solution": "A normalized floating-point value in this format is\n$$V=(-1)^{S}\\left(1+\\sum_{i=1}^{3}f_{i}2^{-i}\\right)2^{E-\\mathrm{bias}},$$\nwith $\\mathrm{bias}=7$, $S$ the sign bit, $E$ the 4-bit exponent, and $f_{i}$ the three fraction bits. Truncation means we keep only the first three fractional bits after normalization and discard the rest.\n\nFor $9.2>0$, $S=0$. Convert $9.2$ to binary and normalize. Since $9.2=1001.0011001100\\ldots_{2}$, normalization gives\n$$9.2=1.0010011001100\\ldots_{2}\\times 2^{3},$$\nso the unbiased exponent is $e=3$ and the stored exponent is $E=e+\\mathrm{bias}=3+7=10$.\n\nThe normalized mantissa has fractional bits $0010011\\ldots$; truncating to three fraction bits yields $F=001$, so the stored mantissa is\n$$M_{\\text{stored}}=1.001_{2}=1+2^{-3}.$$\nTherefore, the stored value is\n$$V_{\\text{stored}}=(1+2^{-3})2^{3}=2^{3}+1=9.$$\n\nThe absolute representation error is\n$$\\left|9.2-9\\right|=0.2.$$\nRounded to three significant figures, this is $0.200$.", "answer": "$$\\boxed{0.200}$$", "id": "1937508"}, {"introduction": "How can a processor compare two floating-point numbers without performing a slow, full-scale subtraction? This advanced problem reveals the elegant design principle that makes fast comparisons possible. By treating positive, normalized floating-point numbers as integers, you will discover a clever optimization that highlights the synergy between data representation and efficient hardware design. [@problem_id:1937471]", "problem": "A specialized Arithmetic Logic Unit (ALU) is being designed to perform fast comparisons on 16-bit custom floating-point numbers. The format for these numbers is defined as follows:\n- 1 bit for the sign (S), where S=0 is positive.\n- 5 bits for the biased exponent (E).\n- 10 bits for the mantissa (M).\n\nThe bit pattern is organized as `S | EEEEE | MMMMMMMMMM`. The value of a number is given by $V = (-1)^S \\times 2^{E - \\text{bias}} \\times (1.M)_2$, where the bias is $15$. This format only represents normalized numbers, meaning the special exponent values for zero, infinity, and Not-a-Number (NaN) are not used in this ALU's scope.\n\nYour task is to analyze the logic for a comparator that takes two **positive, normalized** floating-point numbers, $N_A$ and $N_B$, and determines their relative magnitude. The goal is to achieve this comparison with minimal hardware complexity, ideally avoiding a full floating-point subtraction.\n\nConsider the specific case where the 16-bit patterns for two numbers are $P_A = 42\\text{C}0_{16}$ and $P_B = 4280_{16}$. Based on the principles of floating-point comparison, which of the following statements is/are correct for comparing any two positive, normalized numbers in this format, including the specific pair provided?\n\nA. For any two positive, normalized numbers in this format, the number whose bit pattern represents a larger unsigned integer is the larger of the two numbers.\n\nB. For the specific inputs $P_A = 42\\text{C}0_{16}$ and $P_B = 4280_{16}$, the outcome of the comparison is that the number represented by $P_A$ is less than the number represented by $P_B$.\n\nC. A hardware comparator for this task can be implemented using a single 16-bit integer magnitude comparator, without needing to isolate the exponent and mantissa fields.\n\nD. Since the most significant hexadecimal digits of $P_A$ and $P_B$ are identical (both are '4'), the next step must be to compare the least significant hexadecimal digits ('0' for $P_A$ and '0' for $P_B$); since these are also identical, the numbers must be numerically equal.\n\nE. The most efficient comparison logic must first convert both numbers to a 32-bit fixed-point format before a comparison can be made to ensure no precision is lost.", "solution": "We are given a 16-bit positive, normalized floating-point format with fields $S|EEEEE|MMMMMMMMMM$, value\n$$\nV = (-1)^{S} \\times 2^{E-\\text{bias}} \\times (1.M)_{2}, \\quad \\text{bias}=15,\n$$\nand only normalized numbers are considered (no zero, infinity, NaN, or subnormals). For the comparator, the inputs are restricted to positive numbers, so $S=0$ for both operands.\n\nFor any two positive, normalized values $N_{A}$ and $N_{B}$ with fields $(E_{A},M_{A})$ and $(E_{B},M_{B})$, write the significand explicitly as\n$$\n(1.M)_{2} = 1 + \\frac{M}{2^{10}},\n$$\nso that\n$$\nN = 2^{E-\\text{bias}} \\left(1 + \\frac{M}{2^{10}}\\right).\n$$\nThe ordering follows directly:\n- If $E_{A} > E_{B}$, then $E_{A} \\geq E_{B}+1$, hence\n$$\nN_{A} \\geq 2^{E_{A}-\\text{bias}} > 2^{E_{B}-\\text{bias}} \\left(2 - 2^{-10}\\right) \\geq N_{B},\n$$\nso $N_{A} > N_{B}$.\n- If $E_{A} = E_{B}$, then\n$$\nN_{A} > N_{B} \\iff \\left(1 + \\frac{M_{A}}{2^{10}}\\right) > \\left(1 + \\frac{M_{B}}{2^{10}}\\right) \\iff M_{A} > M_{B}.\n$$\nTherefore, over this restricted domain, numerical order is exactly the lexicographic order of $(E,M)$. Because the bit pattern places $E$ in the more significant bits than $M$, for $S=0$ this is the same as the unsigned integer order of the entire 16-bit word. Hence:\n- For any two positive, normalized numbers, the larger unsigned 16-bit pattern corresponds to the larger value. This proves statement A is correct.\n- Consequently, a single 16-bit unsigned magnitude comparator applied to the full 16-bit patterns suffices; there is no need to isolate fields, provided both inputs are known to be positive and normalized. This proves statement C is correct.\n\nNow evaluate the specific inputs $P_{A} = 42\\text{C}0_{16}$ and $P_{B} = 4280_{16}$.\n\nDecode $P_{A} = 0100\\,0010\\,1100\\,0000_{2}$:\n- $S=0$.\n- $E$ is the next $5$ bits after $S$: bits $b_{14}\\ldots b_{10}$ are $10000_{2}$, so $E_{A}=16$.\n- $M_{A}$ is the remaining $10$ bits $b_{9}\\ldots b_{0}$: $1011000000_{2}$, i.e., $M_{A}=\\text{0x2C0}$.\n\nDecode $P_{B} = 0100\\,0010\\,1000\\,0000_{2}$:\n- $S=0$.\n- $E_{B}=10000_{2}=16$.\n- $M_{B}=1010000000_{2}$, i.e., $M_{B}=\\text{0x280}$.\n\nSince $E_{A}=E_{B}$ and $M_{A} > M_{B}$, it follows that $N_{A} > N_{B}$. Therefore, for the specific pair, the correct ordering is that $P_{A}$ represents a larger number than $P_{B}$, so statement B (claiming $P_{A} < P_{B}$) is false.\n\nAssess the remaining statements:\n- Statement D is false: equal most significant hexadecimal digits do not imply jumping to least significant digits; comparison must proceed from most significant to next most significant positions. Here, at the third hexadecimal digit, $\\text{C} > \\text{8}$, so $42\\text{C}0_{16} > 4280_{16}$.\n- Statement E is false: no conversion to a 32-bit fixed-point format is needed. The lexicographic property shown above ensures that a simple 16-bit unsigned comparator suffices without any precision transformation.\n\nThus, the correct statements are A and C.", "answer": "$$\\boxed{AC}$$", "id": "1937471"}]}