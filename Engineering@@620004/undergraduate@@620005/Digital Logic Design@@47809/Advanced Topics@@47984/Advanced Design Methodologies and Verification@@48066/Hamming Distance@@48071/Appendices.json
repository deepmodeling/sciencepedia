{"hands_on_practices": [{"introduction": "The first step in mastering error control is learning to quantify errors. This exercise provides a foundational workout in calculating the Hamming distance, the fundamental metric for measuring the difference between two binary strings. By working with a common data representation, Binary-Coded Decimal (BCD), you will gain hands-on practice in applying the definition of Hamming distance to a tangible digital system scenario [@problem_id:1941080].", "problem": "In digital systems, decimal digits are often represented using a scheme known as Binary-Coded Decimal (BCD). In the standard 8421 BCD encoding, each decimal digit from 0 to 9 is represented by its corresponding 4-bit binary equivalent. The Hamming distance between two binary strings of equal length is defined as the number of bit positions in which the two strings differ.\n\nConsider a scenario where a digital device intends to transmit the 4-bit BCD representation for the decimal digit 3. However, due to a fault, the device transmits the 4-bit BCD representation for the decimal digit 9 instead. What is the Hamming distance between the intended and the actually transmitted 4-bit codes?\n\nA. 1\n\nB. 2\n\nC. 3\n\nD. 4\n\nE. 6", "solution": "In 8421 BCD, each decimal digit is represented by a 4-bit binary with weights 8, 4, 2, 1. Thus:\n- The intended digit $3$ is encoded as $0011$ because $3=2+1$.\n- The transmitted digit $9$ is encoded as $1001$ because $9=8+1$.\n\nThe Hamming distance between two equal-length binary strings equals the number of positions at which the corresponding bits differ. Equivalently, it equals the Hamming weight (number of ones) of their bitwise XOR:\n$$d_{H}(C_{i},C_{t}) = \\text{wt}\\!\\left(C_{i} \\oplus C_{t}\\right).$$\nWith $C_{i}=0011$ and $C_{t}=1001$, compute\n$$0011 \\oplus 1001 = 1010,$$\nwhich has two ones. Therefore,\n$$d_{H}(0011,1001)=2,$$\ncorresponding to option B.", "answer": "$$\\boxed{B}$$", "id": "1941080"}, {"introduction": "Moving from manual calculation to automated hardware, this exercise challenges you to design a digital circuit that computes the Hamming distance between two binary words. This practice is crucial for understanding how abstract mathematical concepts are translated into tangible logic gates, forming the building blocks of real-world data integrity systems. You will apply principles of Boolean algebra and logic minimization to create an efficient hardware implementation [@problem_id:1941078].", "problem": "In digital communication systems, ensuring data integrity is paramount. One fundamental metric used in error detection is the Hamming distance, which quantifies the number of bit positions at which two binary words of the same length differ.\n\nConsider a monitoring circuit designed to compare a transmitted 3-bit binary word, $A = A_2A_1A_0$, with a received 3-bit binary word, $B = B_2B_1B_0$. The circuit's output, $Z$, is a 2-bit binary number, $Z=Z_1Z_0$ (where $Z_1$ is the most significant bit), that represents the Hamming distance $d_H(A, B)$. The relationship between the Hamming distance and the output $Z$ is defined as follows:\n- If $d_H(A, B) = 0$, then $Z_1Z_0 = 00$.\n- If $d_H(A, B) = 1$, then $Z_1Z_0 = 01$.\n- If $d_H(A, B) = 2$, then $Z_1Z_0 = 10$.\n- If $d_H(A, B) = 3$, then $Z_1Z_0 = 11$.\n\nYour task is to determine the number of product terms in the minimal Sum-of-Products (SOP) Boolean expressions for each of the output bits, $Z_1$ and $Z_0$. These expressions should be considered as functions of the six input variables: $A_2, A_1, A_0, B_2, B_1, B_0$.\n\nProvide your answer as a row matrix containing two integers, where the first integer is the number of product terms for $Z_1$ and the second is the number of product terms for $Z_0$.", "solution": "Let $D_{i} \\equiv A_{i} \\oplus B_{i}$ for $i \\in \\{2,1,0\\}$. By definition of Hamming distance between the 3-bit words $A$ and $B$, the number of differing bit positions is the integer sum\n$$\nd_{H}(A,B)=D_{2}+D_{1}+D_{0}.\n$$\nThe output $Z=Z_{1}Z_{0}$ is the standard binary encoding of this sum:\n- $Z_{0}$ is the least significant bit of $D_{2}+D_{1}+D_{0}$, hence\n$$\nZ_{0}=D_{2}\\oplus D_{1}\\oplus D_{0}.\n$$\n- $Z_{1}$ is the most significant bit, which for three inputs is the threshold function “at least two ones,” equivalently\n$$\nZ_{1}=D_{2}D_{1}+D_{2}D_{0}+D_{1}D_{0}.\n$$\n\nWe now determine minimal SOP sizes over the six input variables $A_{2},A_{1},A_{0},B_{2},B_{1},B_{0}$.\n\nFirst, use the SOP forms for XOR and XNOR on each pair:\n$$\nD_{i}=A_{i}\\oplus B_{i}=\\overline{A_{i}}B_{i}+A_{i}\\overline{B_{i}},\\qquad\n\\overline{D_{i}}=A_{i}\\odot B_{i}=A_{i}B_{i}+\\overline{A_{i}}\\overline{B_{i}}.\n$$\n\nFor $Z_{0}$, by associativity and commutativity of $\\oplus$,\n$$\nZ_{0}=(A_{2}\\oplus B_{2})\\oplus(A_{1}\\oplus B_{1})\\oplus(A_{0}\\oplus B_{0})\n= A_{2}\\oplus B_{2}\\oplus A_{1}\\oplus B_{1}\\oplus A_{0}\\oplus B_{0}.\n$$\nThus $Z_{0}$ is the six-variable odd-parity function. Flipping any single one of the six inputs toggles $Z_{0}$, so no two input assignments at Hamming distance one (in the six-variable space) are both in the on-set. Therefore, in a Karnaugh-map or cube-graph sense, there are no implicants larger than a single minterm; the minimal SOP consists of exactly one product term per on-set minterm. Since exactly half of the $2^{6}$ input assignments yield odd parity, the on-set size is $2^{6-1}=32$. Hence the minimal SOP for $Z_{0}$ has $32$ product terms.\n\nFor $Z_{1}$, use\n$$\nZ_{1}=D_{2}D_{1}+D_{2}D_{0}+D_{1}D_{0}.\n$$\nEach product $D_{i}D_{j}$ expands (using the SOP form of $D_{k}$) as\n$$\nD_{i}D_{j}=(\\overline{A_{i}}B_{i}+A_{i}\\overline{B_{i}})(\\overline{A_{j}}B_{j}+A_{j}\\overline{B_{j}})\n$$\n$$\n=\\;\\overline{A_{i}}B_{i}\\,\\overline{A_{j}}B_{j}\\;+\\;\\overline{A_{i}}B_{i}\\,A_{j}\\overline{B_{j}}\\;+\\;A_{i}\\overline{B_{i}}\\,\\overline{A_{j}}B_{j}\\;+\\;A_{i}\\overline{B_{i}}\\,A_{j}\\overline{B_{j}}.\n$$\nThese are four distinct 4-literal product terms that do not involve the third pair $(A_{k},B_{k})$. Within each set of four, no two terms differ in exactly one literal (they differ by two literals within a pair), so they cannot be combined into larger implicants. Across different pair-combinations (e.g., between $D_{2}D_{1}$ and $D_{2}D_{0}$), the terms involve different variable pairs and again cannot be combined into fewer or larger product terms. Therefore each of the three pairwise products contributes exactly $4$ irreducible product terms, for a total of $3\\times 4=12$ product terms in the minimal SOP for $Z_{1}$.\n\nThus, the numbers of product terms in the minimal SOPs are $12$ for $Z_{1}$ and $32$ for $Z_{0}$.", "answer": "$$\\boxed{\\begin{pmatrix}12 & 32\\end{pmatrix}}$$", "id": "1941078"}, {"introduction": "This final practice delves into the deep connection between Hamming distance and the power of error-correcting codes. Starting from a realistic scenario of a system failure, you will use logical deduction to uncover a code's limitations by determining its minimum distance, $d_{\\min}$. This analysis will then allow you to explore the theoretical boundaries of error correction by evaluating a \"perfect code\" using the Hamming bound, linking a practical problem to the fundamental principles of information theory [@problem_id:1941082].", "problem": "A controller for a high-precision robotic arm uses 7-bit binary words to send motion commands. To protect these commands against electrical noise in the factory environment, the system uses an error-control code, which designates a specific subset of the 128 possible 7-bit strings as valid \"codewords\". All other strings are considered invalid.\n\nDuring a quality assurance test, engineers identified a critical vulnerability. When the controller attempts to send the valid codeword $C_A = 1010101$, a single bit-flip due to noise can result in the corrupted word $R = 1011101$. The system's error-correction logic detects an error but is unable to perform a correction because it determines that the received word $R$ is equidistant from two different valid codewords: the original $C_A$ and another valid codeword, $C_B$.\n\nThis ambiguity reveals the true minimum Hamming distance ($d_{\\min}$) of the code currently in use. Your task is to analyze this situation and then evaluate a proposed replacement. The replacement would be a hypothetical, *different* coding scheme, also using 7-bit words, that is designed to be a \"perfect code\". This perfect code is required to have a new minimum distance of $d'_{\\min} = d_{\\min} + 1$. For such a perfect code, what is the maximum number of unique valid codewords, $M$, that it could contain?\n\nNote: A perfect code capable of correcting $t$ errors in $n$-bit words satisfies the Hamming bound with equality: $M \\cdot \\sum_{i=0}^{t} \\binom{n}{i} = 2^n$.", "solution": "The problem asks for the number of codewords, $M$, in a hypothetical 7-bit perfect code. To find $M$ using the given formula, we first need to determine the parameters $n$ and $t$ for this hypothetical code.\n\nThe word length is given as $n=7$. The error-correction capability, $t$, depends on the code's minimum Hamming distance, $d'_{\\min}$. The problem states that for the hypothetical code, $d'_{\\min} = d_{\\min} + 1$, where $d_{\\min}$ is the minimum Hamming distance of the *original* code described in the scenario. Therefore, our first step is to determine $d_{\\min}$ from the information provided.\n\nThe scenario describes a situation where a received word $R=1011101$ is equidistant from two valid codewords, $C_A=1010101$ and $C_B$. The problem states that $R$ is the result of a single bit-flip from $C_A$. The Hamming distance, which counts the number of differing bits, between $C_A$ and $R$ is indeed 1:\n$d_H(C_A, R) = d_H(1010101, 1011101) = 1$ (they differ only in the 4th bit from the left).\n\nSince $R$ is equidistant from $C_A$ and $C_B$, the Hamming distance between $R$ and $C_B$ must also be 1:\n$d_H(R, C_B) = 1$.\n\nNow we can relate the distance between the two valid codewords, $C_A$ and $C_B$, using the triangle inequality property of Hamming distance:\n$d_H(C_A, C_B) \\le d_H(C_A, R) + d_H(R, C_B)$\nSubstituting the known distances:\n$d_H(C_A, C_B) \\le 1 + 1 = 2$\n\nSince $C_A$ and $C_B$ are distinct valid codewords, their Hamming distance must be a positive integer. Thus, $d_H(C_A, C_B)$ can be either 1 or 2. If $d_H(C_A, C_B) = 1$, it would mean $C_B$ could be formed by flipping a single bit of $C_A$. However, the scenario states that flipping a single bit of $C_A$ results in the corrupted word $R$, and the system is unable to decide between $C_A$ and $C_B$, which implies $R$ is not a valid codeword itself. This ambiguity in correction means $R$ must be distinct from both $C_A$ and $C_B$. This would be impossible if $d_H(C_A, C_B) = 1$. Therefore, $d_H(C_A, C_B)$ must be 2.\n\nThe minimum Hamming distance of a code, $d_{\\min}$, is the smallest Hamming distance between any pair of distinct valid codewords. Since we have found a pair of valid codewords $(C_A, C_B)$ with a distance of 2, the minimum Hamming distance for the entire code can be no larger than 2, i.e., $d_{\\min} \\le 2$. Since $d_{\\min}$ must be at least 2 for any single-error detection, we can conclude that the minimum Hamming distance of the original code is exactly $d_{\\min}=2$.\n\nNow we can characterize the hypothetical perfect code. Its minimum Hamming distance is:\n$d'_{\\min} = d_{\\min} + 1 = 2 + 1 = 3$.\n\nThe number of errors, $t$, that a code with minimum distance $d'_{\\min}$ can correct is given by the formula $t = \\lfloor \\frac{d'_{\\min} - 1}{2} \\rfloor$.\nSubstituting $d'_{\\min} = 3$:\n$t = \\lfloor \\frac{3 - 1}{2} \\rfloor = \\lfloor \\frac{2}{2} \\rfloor = 1$.\nSo, the hypothetical perfect code is a single-error-correcting code.\n\nWe are now ready to use the Hamming bound formula provided in the problem statement for a perfect code:\n$M \\cdot \\sum_{i=0}^{t} \\binom{n}{i} = 2^n$.\n\nSubstituting the known values $n=7$ and $t=1$:\n$M \\cdot \\left( \\binom{7}{0} + \\binom{7}{1} \\right) = 2^7$.\n\nWe calculate the binomial coefficients:\n$\\binom{7}{0} = \\frac{7!}{0!(7-0)!} = 1$\n$\\binom{7}{1} = \\frac{7!}{1!(7-1)!} = \\frac{7}{1} = 7$\n\nSubstituting these values back into the equation:\n$M \\cdot (1 + 7) = 128$\n$8M = 128$\n\nSolving for $M$:\n$M = \\frac{128}{8} = 16$.\n\nThe maximum number of unique valid codewords in the hypothetical perfect code is 16.", "answer": "$$\\boxed{16}$$", "id": "1941082"}]}