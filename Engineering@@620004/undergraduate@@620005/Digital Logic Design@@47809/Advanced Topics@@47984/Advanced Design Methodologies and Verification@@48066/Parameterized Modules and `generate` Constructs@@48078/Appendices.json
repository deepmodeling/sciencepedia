{"hands_on_practices": [{"introduction": "Mastering parameterized design begins with understanding how to replicate simple hardware structures. This first exercise provides a classic entry point into the Verilog `generate` construct by tasking you with building a scalable bit reverser [@problem_id:1950959]. This practice is fundamental because it directly illustrates how a `generate for` loop can create multiple instances of a continuous assignment to define a purely structural, parallel wiring pattern based on a module's parameters.", "problem": "In modern digital logic design, creating flexible and reusable hardware modules is a key principle. Verilog provides `parameter` and `generate` constructs for this purpose. A `parameter` allows a module's characteristics, such as the width of a data bus, to be defined at instantiation time rather than being hardcoded. A `generate` block allows for the creation of repetitive logic structures based on these parameters, which is evaluated during the elaboration phase before simulation or synthesis.\n\nConsider the design of a parameterized `BitReverser` module. This module takes an N-bit input vector, `data_in`, and produces an N-bit output vector, `data_out`, where the bits of `data_in` are in the reverse order. For example, if `N=8` and `data_in` is `8'b11001010`, `data_out` should be `8'b01010011`.\n\nThe module is declared as follows:\n```verilog\nmodule BitReverser #(parameter N = 8) (\n    input  wire [N-1:0] data_in,\n    output wire [N-1:0] data_out\n);\n\n    // Implementation to be inserted here\n\nendmodule\n```\n\nWhich of the following Verilog code snippets, when inserted into the module, correctly implements the bit-reversal logic for any positive integer value of the parameter `N`?\n\nA.\n```verilog\ngenvar i;\ngenerate\n    for (i = 0; i < N; i = i + 1) begin : reverse_loop\n        assign data_out[i] = data_in[N-1-i];\n    end\nendgenerate\n```\n\nB.\n```verilog\ngenerate\n    for (integer i = 0; i < N; i = i + 1) begin : reverse_loop\n        assign data_out[i] = data_in[N-1-i];\n    end\nendgenerate\n```\n\nC.\n```verilog\ngenvar i;\ngenerate\n    for (i = 0; i < N; i = i + 1) begin\n        assign data_out[i] = data_in[N-1-i];\n    end\nendgenerate\n```\n\nD.\n```verilog\ngenvar i;\ngenerate\n    for (i = 0; i < N; i = i + 1) begin : reverse_loop\n        assign data_out[i] = data_in[N-i];\n    end\nendgenerate\n```\n\nE.\n```verilog\nalways @(*) begin\n    for (integer i = 0; i < N; i = i + 1) begin\n        data_out[i] = data_in[N-1-i];\n    end\nend\n```", "solution": "We need to connect each output bit to the corresponding mirrored input bit: for every index $i$ with $0 \\leq i \\leq N-1$, the correct mapping is $data\\_out[i] = data\\_in[N-1-i]$. This is a purely combinational wiring pattern that is entirely determined at elaboration time and should be implemented with a generate-for loop using a genvar index, producing continuous assignments.\n\nEvaluate each option against Verilog-2001 rules and the required mapping:\n\n- Option A:\n  - Uses a generate-for loop with a genvar index $i$, which is the correct construct for elaboration-time replication.\n  - Uses a named generate block begin : reverse_loop, which is the recommended and standard-compliant style.\n  - Implements the correct index expression $N-1-i$.\n  - This is correct.\n\n- Option B:\n  - Uses an integer loop variable inside a generate-for loop. In Verilog-2001 generate-for, the loop variable must be declared as genvar, not integer. Hence this is not standard-compliant and is incorrect.\n\n- Option C:\n  - Uses genvar correctly and implements the correct mapping $N-1-i$, but omits the label on the generate block. In standard Verilog-2001, the for-generate body should be a named generate block to be compliant and avoid tool issues. This omission makes it noncompliant in strict Verilog-2001 usage. Therefore, it is not the best correct answer.\n\n- Option D:\n  - Uses $N-i$ instead of $N-1-i$, which causes an out-of-range index when $i=0$ (accessing $data\\_in[N]$) and an off-by-one mapping overall. Incorrect.\n\n- Option E:\n  - Uses a procedural always @(*) block assigning to data_out, but data_out is declared as wire; procedural assignment requires reg. As given, this does not compile. Also, this is not using the generate construct as intended for elaboration-time structure. Incorrect as written.\n\nTherefore, the only fully correct and standard-compliant implementation among the options is A.", "answer": "$$\\boxed{A}$$", "id": "1950959"}, {"introduction": "Building on the concept of replication, we now apply `generate` constructs to create computational logic rather than just simple wiring. This practice challenges you to implement a parameterized binary-to-Gray code converter, a common block in digital communication systems [@problem_id:1950975]. By generating the logic for each bit based on the formula $g_i = b_{i+1} \\oplus b_i$, you will gain insight into how `generate` translates an algorithm into a parallel hardware structure, a powerful alternative to abstract vector-level operations.", "problem": "In digital systems, Gray codes are frequently used to prevent spurious outputs from electromechanical switches and to facilitate error correction in digital communications. A key property of Gray code is that adjacent values differ by only one bit.\n\nYour task is to identify the correct, synthesizable, and parameterized Verilog module, `binary_to_gray`, that converts an `N`-bit binary number to its corresponding `N`-bit Gray code representation. The module must be parameterized by `WIDTH` to represent the bit-width `N`.\n\nThe conversion from an `N`-bit binary number `b` to an `N`-bit Gray code `g` is defined by the following rules:\n-   The most significant bit (MSB) of the Gray code is identical to the MSB of the binary number. For an `N`-bit vector indexed from `N-1` down to `0`, this means:\n    $g_{N-1} = b_{N-1}$\n-   For all other bits `i` (where $0 \\le i < N-1$), the Gray code bit is the exclusive-OR (XOR) of the corresponding binary bit and the binary bit at the next most significant position:\n    $g_i = b_{i+1} \\oplus b_i$\n\nThe module must have the following port definitions:\n-   `input [WIDTH-1:0] b`\n-   `output [WIDTH-1:0] g`\n\nYour implementation must adhere to a specific structural design pattern: the logic for bits `g[WIDTH-2]` down to `g[0]` must be generated using a `generate for` loop. The MSB, `g[WIDTH-1]`, must be handled by a separate continuous assignment statement.\n\nFrom the options below, select the one that correctly implements the `binary_to_gray` module according to all the specified rules and constraints.\n\nA.\n```verilog\nmodule binary_to_gray #(parameter WIDTH = 8) (\n    input [WIDTH-1:0] b,\n    output [WIDTH-1:0] g\n);\n    assign g[WIDTH-1] = b[WIDTH-1];\n    genvar i;\n    generate\n        for (i = 0; i < WIDTH - 1; i = i + 1) begin : gray_gen_loop\n            assign g[i] = b[i+1] ^ b[i];\n        end\n    endgenerate\nendmodule\n```\n\nB.\n```verilog\nmodule binary_to_gray #(parameter WIDTH = 8) (\n    input [WIDTH-1:0] b,\n    output [WIDTH-1:0] g\n);\n    genvar i;\n    generate\n        for (i = 0; i < WIDTH; i = i + 1) begin : gray_gen_loop\n            assign g[i] = b[i+1] ^ b[i];\n        end\n    endgenerate\nendmodule\n```\n\nC.\n```verilog\nmodule binary_to_gray #(parameter WIDTH = 8) (\n    input [WIDTH-1:0] b,\n    output [WIDTH-1:0] g\n);\n    assign g[WIDTH-1] = b[WIDTH-1];\n    genvar i;\n    generate\n        for (i = 0; i < WIDTH - 1; i = i + 1) begin : gray_gen_loop\n            assign g[i+1] = b[i+1] ^ b[i];\n        end\n    endgenerate\nendmodule\n```\n\nD.\n```verilog\nmodule binary_to_gray #(parameter WIDTH = 8) (\n    input [WIDTH-1:0] b,\n    output [WIDTH-1:0] g\n);\n    assign g = b ^ (b >> 1);\nendmodule\n```", "solution": "We are required to implement a parameterized Verilog module that converts an $N$-bit binary vector $b$ to its Gray code $g$ using the relations\n$$g_{N-1}=b_{N-1},$$\n$$g_{i}=b_{i+1}\\oplus b_{i}\\quad \\text{for }0\\leq i\\leq N-2.$$\nAdditionally, the design constraint mandates that $g[WIDTH-1]$ must be assigned using a separate continuous assignment, while $g[WIDTH-2]$ down to $g[0]$ must be generated using a generate-for loop.\n\nEvaluate each option against these rules:\n\n- Option A: It assigns $g_{WIDTH-1}=b_{WIDTH-1}$ separately, and uses a generate-for loop with index $i$ from $0$ to $WIDTH-2$ to assign $g[i]=b[i+1]\\oplus b[i]$. This matches the formulas exactly, uses correct bounds, and adheres to the structural constraint. It is synthesizable and parameterized.\n\n- Option B: The loop runs for $i<WIDTH$, so when $i=WIDTH-1$ it attempts to use $b[WIDTH]$, which is out of bounds. It also does not handle the MSB by a separate assignment. Therefore it violates both indexing correctness and the structural constraint.\n\n- Option C: While it assigns $g_{WIDTH-1}=b_{WIDTH-1}$ separately, the generate-for loop assigns $g[i+1]=b[i+1]\\oplus b[i]$, which causes two problems: $g[0]$ is never assigned in the loop, and when $i=WIDTH-2$ it reassigns $g[WIDTH-1]$, conflicting with the separate MSB assignment. This violates the structural constraint and correctness.\n\n- Option D: The vector expression $g=b\\oplus (b\\gg 1)$ is functionally correct for Gray code conversion, since it yields $g_{N-1}=b_{N-1}$ and $g_{i}=b_{i+1}\\oplus b_{i}$. However, it does not use a generate-for loop for bits $g[WIDTH-2:0]$, and does not use a separate continuous assignment for the MSB as required. Hence it violates the specified design pattern.\n\nTherefore, only Option A satisfies all specified functional and structural requirements.", "answer": "$$\\boxed{A}$$", "id": "1950975"}, {"introduction": "Our final practice explores an advanced and powerful application of `generate` loops: the creation of priority logic. You are tasked with designing a module to find the first '0' bit in a vector, a core function in many decoders and arbiters [@problem_id:1950986]. This exercise demonstrates how to build a priority chain—a cascading structure of multiplexers—where each generated block depends on the next, showcasing a sophisticated design pattern for handling complex, prioritized decision-making in hardware.", "problem": "You are tasked with designing a parameterized Verilog module, `find_first_zero`, which is a common component in systems that need to process status flags or masks. The module must identify the index of the first '0' bit found when searching from the least significant bit (LSB) of an input vector.\n\n**Module Specifications:**\n*   **Module Name**: `find_first_zero`\n*   **Parameter**: An integer `WIDTH` that defines the bit-width of the input vector.\n*   **Input**: `data_in`, a logic vector of size `[WIDTH-1:0]`.\n*   **Output**: `index`, a logic vector of size `[$clog2(WIDTH+1)-1:0]`.\n*   **Functionality**:\n    *   The `index` output must hold the bit position of the first '0' encountered when scanning `data_in` from index 0 (LSB) towards index `WIDTH-1`, the Most Significant Bit (MSB).\n    *   In the specific case where `data_in` contains no '0' bits (i.e., all bits are '1'), the `index` output must be set to the value `WIDTH`.\n\nBelow are four different Verilog code snippets proposed for the body of this module. Which one correctly implements the specified functionality?\n\nA.\n```verilog\ngenerate\n    genvar i;\n    wire [$clog2(WIDTH+1)-1:0] index_stage [WIDTH:0];\n    assign index_stage[WIDTH] = WIDTH;\n    for (i = WIDTH-1; i >= 0; i=i-1) begin: priority_chain\n        assign index_stage[i] = (~data_in[i]) ? i : index_stage[i+1];\n    end\n    assign index = index_stage[0];\nendgenerate\n```\n\nB.\n```verilog\ngenerate\n    genvar i;\n    wire [$clog2(WIDTH+1)-1:0] index_stage [WIDTH:0];\n    assign index_stage[0] = WIDTH;\n    for (i = 0; i < WIDTH; i=i+1) begin: priority_chain\n        assign index_stage[i+1] = (~data_in[i]) ? i : index_stage[i];\n    end\n    assign index = index_stage[WIDTH];\nendgenerate\n```\n\nC.\n```verilog\ngenerate\n    genvar i;\n    for (i = 0; i < WIDTH; i=i+1) begin: priority_chain\n        always @(*) begin\n            if (~data_in[i])\n                index = i;\n        end\n    end\nendgenerate\n```\n\nD.\n```verilog\ngenerate\n    genvar i;\n    wire [$clog2(WIDTH+1)-1:0] index_stage [WIDTH:0];\n    assign index_stage[WIDTH] = WIDTH;\n    for (i = WIDTH-1; i >= 0; i=i-1) begin: priority_chain\n        assign index_stage[i] = (~data_in[i]) ? index_stage[i+1] : i;\n    end\n    assign index = index_stage[0];\nendgenerate\n```", "solution": "We need a combinational module that, for an input vector $data\\_in[WIDTH-1:0]$, returns the smallest index $j \\in \\{0,\\dots,WIDTH-1\\}$ such that $data\\_in[j]=0$ when scanning from least significant bit to most significant bit. If no such $j$ exists, the output must be $WIDTH$. Define the target function\n$$\nf(i)=\\begin{cases}\n\\min\\{j \\mid j\\in [i, WIDTH-1],\\ data\\_in[j]=0\\}, & \\text{if such } j \\text{ exists},\\\\\nWIDTH, & \\text{otherwise}.\n\\end{cases}\n$$\nThe desired output is $f(0)$.\n\nAnalyze each option:\n\nOption A:\nIt defines a chain $index\\_stage[i]$ with boundary $index\\_stage[WIDTH]=WIDTH$, and for $i$ from $WIDTH-1$ down to $0$:\n$$\nindex\\_stage[i] = \\begin{cases}\ni, & \\text{if } data\\_in[i]=0,\\\\\nindex\\_stage[i+1], & \\text{otherwise}.\n\\end{cases}\n$$\nThis recurrence matches the definition of $f(i)$: clearly $index\\_stage[WIDTH]=f(WIDTH)=WIDTH$. For $i$ descending, if $data\\_in[i]=0$, then the first zero at or above $i$ is $i$, so $f(i)=i$. Otherwise, the first zero at or above $i$ is the same as at or above $i+1$, so $f(i)=f(i+1)$. Therefore by induction $index\\_stage[i]=f(i)$ for all $i$, and the final assignment $index=index\\_stage[0]=f(0)$ is exactly the required behavior, including the all-ones case yielding $WIDTH$.\n\nOption B:\nIt sets $index\\_stage[0]=WIDTH$ and for $i$ from $0$ up to $WIDTH-1$:\n$$\nindex\\_stage[i+1] = \\begin{cases}\ni, & \\text{if } data\\_in[i]=0,\\\\\nindex\\_stage[i], & \\text{otherwise}.\n\\end{cases}\n$$\nThis logic overwrites the stored index whenever a new zero is encountered, thus $index\\_stage[WIDTH]$ becomes the largest index $i$ with $data\\_in[i]=0$, i.e., the last zero when scanning from LSB to MSB. For example, with $data\\_in= \\dots 1 0 0$ at positions $2:0$, the result becomes $1$ instead of the correct $0$. Hence it is incorrect.\n\nOption C:\nIt creates multiple always blocks, each potentially assigning to the same signal $index$ without a default assignment. This causes multiple procedural drivers on $index$ and no defined priority to select the first zero. It also fails the all-ones case, since $index$ would remain unassigned. It does not implement the specified functionality.\n\nOption D:\nIt uses $index\\_stage[WIDTH]=WIDTH$ and for $i$ descending:\n$$\nindex\\_stage[i] = \\begin{cases}\nindex\\_stage[i+1], & \\text{if } data\\_in[i]=0,\\\\\ni, & \\text{otherwise}.\n\\end{cases}\n$$\nThis is inverted from the needed recurrence. For instance, with all ones, one obtains $index\\_stage[0]=0$ instead of $WIDTH$, violating the specification. Therefore it is incorrect.\n\nThus, only Option A correctly implements the required functionality, including the boundary case where no zero is found.", "answer": "$$\\boxed{A}$$", "id": "1950986"}]}