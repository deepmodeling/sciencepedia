{"hands_on_practices": [{"introduction": "The journey from a procedural algorithm to a hardware description often begins with defining states. This practice uses the classic example of a serial 2's complement converter to challenge you to think about the fundamental 'modes' of operation an algorithm requires [@problem_id:1908089]. By identifying the minimum number of states needed to remember the algorithm's progress, you'll master the crucial first step in any Algorithmic State Machine (ASM) design.", "problem": "A digital control system is to be designed for a processor that calculates the 2's complement of a 4-bit binary number. The number is provided to the system serially, one bit at a time, on an input line `Din`, starting with the least significant bit (LSB). The system produces the resulting 2's complement number serially on an output line `Dout`.\n\nThe operation is initiated by a `start` signal, which is asserted high for one clock cycle. The controller's task is to manage the conversion process. The rule for the bit-wise conversion is as follows: starting from the LSB, copy the input bits from `Din` to `Dout` until the first '1' is encountered. This first '1' is also copied directly to the output. For all subsequent bits in the 4-bit sequence, the input bit from `Din` must be inverted before being sent to `Dout`.\n\nAfter processing all 4 bits, the controller must return to an idle state where it waits for the next `start` signal. The controller's logic is to be represented by an Algorithmic State Machine (ASM) chart. You can assume that the controller has access to an external signal that indicates when the 4-bit operation is complete.\n\nDetermine the minimum number of states required to implement this controller's ASM chart.", "solution": "We model the controller as a finite-state machine that governs the serial bit-by-bit 2's-complement rule: starting from the LSB, copy input bits to the output until the first $1$ is seen (that first $1$ is also copied), then invert all subsequent bits. The system processes exactly $4$ bits per operation, with an external signal indicating completion, and returns to idle awaiting the next $start$ pulse.\n\nStep 1: Identify the independent control modes required by the algorithm.\n- There is an initialization/waiting condition in which the controller must ignore data and wait for $start=1$. This is an idle condition distinct from processing. Call it the Idle state.\n- During processing, the output rule depends on whether the first $1$ has been seen yet. Define a Boolean flag $f$:\n  - $f=0$: the first $1$ has not yet been seen. Output rule: $D_{out}=D_{in}$.\n  - $f=1$: the first $1$ has been seen. Output rule: $D_{out}=D_{in}'$.\n  These are two distinct output behaviors for the same input, so they must be distinct processing states. Call them Pass (for $f=0$) and Invert (for $f=1$).\n\nThus, the candidate minimal set of states is:\n- Idle: waiting for $start=1$; initializes the bit counter (external) and any datapath on $start$.\n- Pass: $D_{out}=D_{in}$; transition to Invert upon observing $D_{in}=1$ (the first $1$); remain in Pass if $D_{in}=0$.\n- Invert: $D_{out}=D_{in}'$; remain in Invert for all subsequent bits.\n\nStep 2: Specify transitions, including completion.\nLet $done$ be the external signal that becomes $1$ when $4$ bits have been processed.\n- Idle:\n  - If $start=1$, perform initialization actions (e.g., reset/load counter) and go to Pass on the next clock.\n  - Else remain in Idle.\n- Pass:\n  - Output action: $D_{out}=D_{in}$.\n  - Next-state logic: if $done=1$ then go to Idle; else if $D_{in}=1$ then go to Invert; else remain in Pass.\n- Invert:\n  - Output action: $D_{out}=D_{in}'$.\n  - Next-state logic: if $done=1$ then go to Idle; else remain in Invert.\n\nStep 3: Argue minimality.\n- Idle cannot be merged with any processing state because in Idle the machine must wait for $start$ and not drive the datapath for serial conversion; its next-state conditions depend on $start$, whereas processing states condition on $D_{in}$ and $done$.\n- Pass and Invert cannot be merged because on identical inputs they produce different outputs: in Pass, $D_{out}=D_{in}$; in Invert, $D_{out}=D_{in}'$. Hence they are distinguishable states in the sense of finite-state machine minimality (their output functions differ).\n- No additional states are required for bit counting because $done$ is provided externally; thus per-bit progression does not require per-bit states.\n\nTherefore, the minimum number of ASM states is exactly three: Idle, Pass, and Invert. This achieves the required behavior and is provably minimal given the distinct control modes the algorithm requires.", "answer": "$$\\boxed{3}$$", "id": "1908089"}, {"introduction": "An abstract ASM chart is only a blueprint; its true power is realized when converted into a physical circuit. This exercise bridges that gap by tackling the highly practical problem of debouncing a noisy mechanical switch [@problem_id:1957151]. Given a complete state diagram and state assignment, your task is to derive the combinational logic that drives the state registers, providing a clear link between the high-level ASM concept and the gate-level hardware implementation.", "problem": "In digital logic design, interfacing with mechanical components like push-buttons presents a challenge known as contact bounce. When a mechanical switch is pressed or released, its metal contacts physically bounce, creating a series of rapid, spurious electrical pulses instead of a single, clean transition. A common solution is to use a debouncing circuit implemented as a Finite State Machine (FSM).\n\nYou are tasked with designing the combinational logic for such an FSM. The FSM has two inputs and two outputs:\n- **Inputs:**\n  - `S`: The raw signal from the switch. `S=1` when pressed, `S=0` when released. This signal is \"bouncy.\"\n  - `T`: A signal from an external timer. `T=1` indicates that a pre-defined stabilization period has elapsed. `T=0` otherwise.\n- **Outputs:**\n  - `Z`: The debounced, clean output signal. It should be a single pulse, active high for exactly one clock cycle, after a valid button press is confirmed.\n  - `E`: An enable signal for the external timer. `E=1` starts or runs the timer.\n\nThe FSM follows this behavior, captured by an Algorithmic State Machine (ASM) chart:\n1.  Start in an `IDLE` state (`S0`), waiting for the switch to be pressed (`S=1`). In this state, `Z=0` and `E=0`.\n2.  Upon detecting `S=1`, transition to a `WAIT` state (`S1`). In this state, enable the timer by setting `E=1`. Keep `Z=0`.\n3.  Stay in the `WAIT` state until the timer is done (`T=1`).\n4.  Once `T=1`, check the switch input `S` again.\n    - If `S=1` (the press is stable), transition to a `PULSE` state (`S2`).\n    - If `S=0` (it was a bounce/noise), transition back to the `IDLE` state.\n5.  In the `PULSE` state, assert the clean output `Z=1` for one clock cycle. The timer should be disabled (`E=0`).\n6.  After the single pulse cycle, transition to a `HELD` state (`S3`), where the machine waits for the user to release the switch (`S=0`). In this state, `Z=0` and `E=0`.\n7.  Once `S=0` in the `HELD` state, transition back to the `IDLE` state to await the next press.\n\nThe FSM is to be implemented using two D-type flip-flops, with state variables `Q1` and `Q0`. The state assignment is as follows:\n- `S0` (IDLE): `Q1Q0 = 00`\n- `S1` (WAIT): `Q1Q0 = 01`\n- `S2` (PULSE): `Q1Q0 = 10`\n- `S3` (HELD): `Q1Q0 = 11`\n\nYour task is to determine the correct set of simplified, sum-of-products Boolean expressions for the flip-flop inputs, `D1` and `D0`, and for the debounced output, `Z`. In the expressions below, `·` denotes logical AND, `+` denotes logical OR, and a prime `'` denotes logical NOT.\n\nWhich of the following options provides the correct set of equations?\n\nA.\n$D_1 = Q_1 \\cdot Q_0' + Q_1 \\cdot Q_0 \\cdot S + Q_0 \\cdot S \\cdot T$\n$D_0 = Q_1 \\cdot Q_0' + Q_1' \\cdot Q_0 \\cdot T' + Q_1' \\cdot Q_0' \\cdot S + Q_1 \\cdot Q_0 \\cdot S$\n$Z = Q_1 \\cdot Q_0'$\n\nB.\n$D_1 = Q_1 + S \\cdot T$\n$D_0 = Q_1 \\cdot Q_0' + Q_1' \\cdot Q_0 \\cdot T' + Q_0' \\cdot S$\n$Z = Q_1 \\cdot Q_0'$\n\nC.\n$D_1 = Q_1 \\cdot Q_0' + Q_1 \\cdot Q_0 \\cdot S + Q_0 \\cdot S \\cdot T$\n$D_0 = Q_1 \\cdot Q_0' + Q_1' \\cdot Q_0 \\cdot T' + Q_1' \\cdot Q_0' \\cdot S + Q_1 \\cdot Q_0 \\cdot S$\n$Z = Q_1$\n\nD.\n$D_1 = Q_1 \\cdot Q_0' + Q_0 \\cdot T$\n$D_0 = Q_1' \\cdot S + Q_1 \\cdot Q_0' + Q_1' \\cdot Q_0$\n$Z = Q_1 \\cdot Q_0'$\n\nE.\n$D_1 = Q_1 \\cdot Q_0' + Q_1' \\cdot Q_0 \\cdot S \\cdot T$\n$D_0 = Q_1' \\cdot Q_0' \\cdot S + Q_1 \\cdot Q_0'$\n$Z = Q_1 \\cdot Q_0'$", "solution": "We denote the present-state bits by $Q_{1}$ and $Q_{0}$, and the next-state bits (the D inputs) by $D_{1}=Q_{1}^{+}$ and $D_{0}=Q_{0}^{+}$. The inputs are $S$ (switch) and $T$ (timer done). States are encoded as:\n- $S0$ (IDLE): $Q_{1}Q_{0}=00$\n- $S1$ (WAIT): $Q_{1}Q_{0}=01$\n- $S2$ (PULSE): $Q_{1}Q_{0}=10$\n- $S3$ (HELD): $Q_{1}Q_{0}=11$\n\nFrom the ASM description, the transition behavior is:\n- From $00$ (IDLE): if $S=0$ then stay $00$; if $S=1$ then go to $01$. $T$ is irrelevant here.\n- From $01$ (WAIT): if $T=0$ then stay $01$; if $T=1$ then if $S=1$ go to $10$, else ($S=0$) go to $00$.\n- From $10$ (PULSE): unconditionally go to $11$ on the next clock.\n- From $11$ (HELD): if $S=1$ then stay $11$; if $S=0$ then go to $00$. $T$ is irrelevant here.\n\nWe now derive $D_{1}$ and $D_{0}$ as sum-of-products.\n\nFirst, $D_{1}=1$ exactly when the next state has $Q_{1}^{+}=1$. Enumerating the cases:\n- From $01$ with $T=1$ and $S=1$: $01\\to 10$, so $Q_{1}^{+}=1$. This yields the term $Q_{0} S T$.\n- From $10$: $10\\to 11$ regardless of $S,T$, so $Q_{1}^{+}=1$ for all present minterms with $Q_{1}=1,Q_{0}=0$. This yields the term $Q_{1}Q_{0}'$.\n- From $11$ with $S=1$: $11\\to 11$, so $Q_{1}^{+}=1$. This yields the term $Q_{1}Q_{0}S$.\nTherefore,\n$$\nD_{1}=Q_{1}Q_{0}'+Q_{1}Q_{0}S+Q_{0}ST.\n$$\n\nNext, $D_{0}=1$ exactly when the next state has $Q_{0}^{+}=1$. Enumerating the cases:\n- From $00$ with $S=1$: $00\\to 01$, so $Q_{0}^{+}=1$. This yields $Q_{1}'Q_{0}'S$.\n- From $01$ with $T=0$: $01\\to 01$, so $Q_{0}^{+}=1$ regardless of $S$. This yields $Q_{1}'Q_{0}T'$.\n- From $10$: $10\\to 11$, so $Q_{0}^{+}=1$ for all present minterms with $Q_{1}=1,Q_{0}=0$. This yields $Q_{1}Q_{0}'$.\n- From $11$ with $S=1$: $11\\to 11$, so $Q_{0}^{+}=1$. This yields $Q_{1}Q_{0}S$.\nTherefore,\n$$\nD_{0}=Q_{1}Q_{0}'+Q_{1}'Q_{0}T'+Q_{1}'Q_{0}'S+Q_{1}Q_{0}S.\n$$\n\nFinally, the debounced output $Z$ must be asserted only in the PULSE state $S2$ ($Q_{1}Q_{0}=10$), thus\n$$\nZ=Q_{1}Q_{0}'.\n$$\n\nComparing with the options, these expressions match option A exactly.", "answer": "$$\\boxed{A}$$", "id": "1957151"}, {"introduction": "ASM charts excel at orchestrating complex, multi-cycle computations within a digital datapath. This advanced problem places you in the role of designing a controller for a non-restoring hardware divider, a core component in many processors [@problem_id:1908116]. Your focus will be on how different states assert specific control signals to manage registers and an ALU, and to correctly identify which signals depend solely on the state (Moore outputs)—a critical distinction in high-performance controller design.", "problem": "You are tasked with designing a controller for a dedicated hardware unit that performs division of two N-bit unsigned integers, a dividend and a divisor, using the multi-cycle non-restoring division algorithm.\n\n**Datapath and Control Signals:**\nThe datapath controlled by your Algorithmic State Machine (ASM) includes an (N+1)-bit register `A` (accumulator, initialized to zero), an N-bit shift register `Q` (for the dividend/quotient), an N-bit register `M` (for the divisor), and an N-bit down-counter `n`. The controller receives the following status inputs:\n- `start`: A single-cycle signal that initiates the division process.\n- `n_zero`: A signal that is high when the counter `n` is zero.\n- `A_sign`: The most significant bit (MSB) of register `A`, indicating its sign (0 for positive, 1 for negative).\n\nThe controller must generate the following control signals:\n- `Init_Cycle`: A signal to perform the initialization tasks in a single cycle.\n- `n_dec`: Decrements the counter `n` by one.\n- `AQ_shift_left`: Performs a 1-bit logical left shift on the concatenated register `{A, Q}`.\n- `A_load_from_ALU`: Loads register `A` with the output of the datapath's Arithmetic Logic Unit (ALU).\n- `ALU_op_is_add`: A signal for the ALU. If high, the ALU computes `A + M`; if low, it computes `A - M`.\n- `Q0_write_enable`: Enables the least significant bit of `Q`, `Q[0]`, to be updated. The datapath is hardwired to write the value `NOT(ALU_output_sign)` into `Q[0]` when this signal is active.\n- `A_load_correction`: A signal that loads register `A` with the result of `A + M` for the final correction step.\n- `Done`: A signal that is asserted upon completion of the algorithm.\n\n**Algorithm Specification:**\nThe controller must implement the following multi-cycle algorithm:\n1.  **Idle Phase:** The controller waits in an `IDLE` state until the `start` signal is asserted.\n2.  **Initialization Cycle:** Upon receiving `start`, the controller transitions to an `INIT` state for one cycle, asserting the `Init_Cycle` signal. This signal causes the datapath to load `A` with 0, `Q` with the dividend, `M` with the divisor, and the counter `n` with `N`.\n3.  **Iteration Loop (2 cycles per bit):** The controller then enters a loop that repeats `N` times. Each iteration consists of two sequential cycles (two states):\n    a. **Shift Cycle:** The `{A, Q}` register is shifted left by one bit, and the counter `n` is decremented.\n    b. **ALU Cycle:** Based on the sign of `A` after the shift (`A_sign`), an ALU operation is performed and the result is stored back in `A`. Specifically, if `A_sign` is 0, the operation is `A - M`. If `A_sign` is 1, the operation is `A + M`. Concurrently, the new quotient bit is written to `Q[0]`.\n4.  **Correction Cycle:** After `N` iterations (detected when `n_zero` is high), the controller checks the sign of the final remainder in `A`. If `A` is negative (`A_sign = 1`), a single-cycle correction step is performed where `A` is updated with `A + M`. If `A` is non-negative, this cycle is skipped.\n5.  **Done Phase:** The controller asserts the `Done` signal for one cycle and returns to the `IDLE` state.\n\n**Question:**\nFor a minimal ASM controller designed according to these specifications, identify the complete set of control signals that are asserted as **Moore outputs** in the state corresponding to the **ALU Cycle** (Step 3b) of the algorithm. A Moore output is a control signal that is asserted based solely on being in a particular state and is independent of the status inputs (`start`, `n_zero`, `A_sign`) evaluated during that cycle.\n\nA. `{AQ_shift_left, n_dec}`\nB. `{A_load_from_ALU, Q0_write_enable}`\nC. `{n_dec, A_load_from_ALU}`\nD. `{A_load_from_ALU, Q0_write_enable, ALU_op_is_add}`\nE. `{A_load_correction}`", "solution": "We must identify which control signals are asserted in the ALU Cycle state (Step 3b) purely because the controller is in that state, i.e., Moore outputs, independent of the current values of the status inputs.\n\nAccording to the algorithm, the ALU Cycle performs, for every iteration:\n- An ALU operation on $A$ with $M$, chosen based on `A_sign`: if `A_sign` is 0, compute $A - M$; if `A_sign` is 1, compute $A + M$.\n- Load the result back into $A$.\n- Concurrently write the new quotient bit into $Q[0]$, by enabling `Q0_write_enable`; the datapath hardwiring writes $\\operatorname{NOT}(\\text{ALU\\_output\\_sign})$ when enabled.\n\nFrom this, the signals that must be asserted in every ALU Cycle, regardless of `A_sign`, `n_zero`, or `start`, are:\n- `A_load_from_ALU`: required to store the ALU result into $A$ in this cycle, unconditionally for each iteration’s ALU phase.\n- `Q0_write_enable`: required to write the quotient bit in this cycle, unconditionally for each iteration’s ALU phase.\n\nThe signal `ALU_op_is_add` is determined by `A_sign` in this same cycle (it selects between $A+M$ and $A-M$), hence it is not a Moore output; it is a Mealy-dependent control. The signals `AQ_shift_left` and `n_dec` belong to the Shift Cycle, not the ALU Cycle. The signal `A_load_correction` belongs only to the final Correction Cycle. None of these are asserted solely by being in the ALU Cycle state.\n\nTherefore, the complete set of Moore outputs asserted in the ALU Cycle is exactly `{A_load_from_ALU, Q0_write_enable}`, which corresponds to option B.", "answer": "$$\\boxed{B}$$", "id": "1908116"}]}