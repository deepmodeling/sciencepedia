{"hands_on_practices": [{"introduction": "At the heart of many BIST systems is the Test Pattern Generator (TPG), which is responsible for creating the inputs that exercise the Circuit Under Test (CUT). This exercise focuses on the most common TPG implementation: the Linear Feedback Shift Register (LFSR). By manually tracing the state transitions of a 3-bit LFSR, you will gain a concrete understanding of how a simple digital circuit, governed by a mathematical polynomial, can generate a pseudo-random sequence of test vectors. [@problem_id:1917404]", "problem": "In the design of a Built-In Self-Test (BIST) system, a Test Pattern Generator (TPG) is required to produce a sequence of inputs for a circuit under test. A 3-bit Linear Feedback Shift Register (LFSR) is chosen for this purpose.\n\nThe LFSR is constructed using D flip-flops whose outputs are labeled $Q_2$, $Q_1$, and $Q_0$, representing the state from most significant bit to least significant bit. The register operates as a right-shift register: on each clock cycle, the bit at $Q_2$ moves to $Q_1$, and the bit at $Q_1$ moves to $Q_0$. The bit at $Q_0$ is discarded after being used in the feedback calculation.\n\nThe new input bit fed into the first flip-flop ($D_2$) is determined by a feedback function. This function is defined by the primitive polynomial $P(x) = x^3 + x + 1$. The convention for implementing this polynomial is that the input to the most significant bit ($D_2$) is the exclusive-OR (XOR) sum of the outputs corresponding to the lower-power terms of the polynomial. That is, a term $x^k$ for $k \\in \\{0, 1, 2\\}$ in the polynomial indicates that the output $Q_k$ is an input to the XOR gate providing the feedback.\n\nIf the LFSR is initialized to the non-zero state $Q_2Q_1Q_0 = 100$, what is the binary state of the register, represented as the string $Q_2Q_1Q_0$, after exactly 5 clock cycles?\n\nA. `011`\n\nB. `111`\n\nC. `001`\n\nD. `010`\n\nE. `110`", "solution": "The LFSR is a right-shift register with state bits $(Q_{2},Q_{1},Q_{0})$ and primitive polynomial $P(x)=x^{3}+x+1$. The convention implies taps at $x^{1}$ and $x^{0}$, so the feedback into $D_{2}$ is the XOR of $Q_{1}$ and $Q_{0}$:\n$$D_{2}=Q_{1}\\oplus Q_{0}.$$\nRight-shift operation gives the next-state relations:\n$$Q_{2}^{+}=D_{2}=Q_{1}\\oplus Q_{0},\\quad Q_{1}^{+}=Q_{2},\\quad Q_{0}^{+}=Q_{1}.$$\nThus the state update is\n$$(Q_{2}^{+},Q_{1}^{+},Q_{0}^{+})=(Q_{1}\\oplus Q_{0},\\,Q_{2},\\,Q_{1}).$$\nStarting from the initial non-zero state $(Q_{2},Q_{1},Q_{0})=(1,0,0)$, iterate for 5 clock cycles:\n\nCycle 1:\n$$Q_{2}^{+}=0\\oplus 0=0,\\quad Q_{1}^{+}=1,\\quad Q_{0}^{+}=0\\;\\Rightarrow\\;(0,1,0).$$\n\nCycle 2:\n$$Q_{2}^{+}=1\\oplus 0=1,\\quad Q_{1}^{+}=0,\\quad Q_{0}^{+}=1\\;\\Rightarrow\\;(1,0,1).$$\n\nCycle 3:\n$$Q_{2}^{+}=0\\oplus 1=1,\\quad Q_{1}^{+}=1,\\quad Q_{0}^{+}=0\\;\\Rightarrow\\;(1,1,0).$$\n\nCycle 4:\n$$Q_{2}^{+}=1\\oplus 0=1,\\quad Q_{1}^{+}=1,\\quad Q_{0}^{+}=1\\;\\Rightarrow\\;(1,1,1).$$\n\nCycle 5:\n$$Q_{2}^{+}=1\\oplus 1=0,\\quad Q_{1}^{+}=1,\\quad Q_{0}^{+}=1\\;\\Rightarrow\\;(0,1,1).$$\n\nAfter exactly 5 clock cycles the state is $Q_{2}Q_{1}Q_{0}=011$, which corresponds to option A.", "answer": "$$\\boxed{A}$$", "id": "1917404"}, {"introduction": "Once test patterns are generated, we must evaluate their effectiveness. This practice introduces the critical concept of fault coverage, the primary metric for quantifying the quality of a test set. Using the single stuck-at fault model, you will analyze how a limited set of test vectors applied to a simple XOR gate can detect some, but not all, potential manufacturing defects. This exercise highlights the direct relationship between the applied patterns and the ability to guarantee a circuit's reliability. [@problem_id:1917374]", "problem": "In the design of a novel low-power microprocessor, a critical parity-checking unit relies on a fundamental two-input XOR gate. Let the inputs to this gate be denoted as $I_1$ and $I_2$, and the output as $O$. To ensure operational reliability after manufacturing, a rudimentary Built-In Self-Test (BIST) controller is integrated into the chip. Due to stringent area and power constraints, this controller is only capable of generating a very limited set of test vectors. The entire test sequence consists of just two input patterns applied to $(I_1, I_2)$: the pattern $(0, 1)$ followed by the pattern $(1, 0)$.\n\nYour task is to analyze the effectiveness of this BIST scheme. The primary concern is the detection of single stuck-at faults. This fault model assumes that exactly one of the gate's terminals—either an input ($I_1$, $I_2$) or the output ($O$)—is permanently \"stuck\" at a logic 0 (stuck-at-0 fault) or a logic 1 (stuck-at-1 fault). For this analysis, assume that only one such fault can be present in the circuit at any given time.\n\nCalculate the fault coverage achieved by this specific BIST sequence for the two-input XOR gate. Express your answer as a decimal value, rounded to three significant figures.", "solution": "We analyze a two-input XOR gate with inputs $I_{1}$, $I_{2}$ and output $O$, where $O=I_{1}\\oplus I_{2}$. The BIST applies two patterns: $(I_{1},I_{2})=(0,1)$ and $(1,0)$. Under fault-free operation, for both patterns the output is\n$$\nO_{\\text{good}}(0,1)=0\\oplus 1=1,\\quad O_{\\text{good}}(1,0)=1\\oplus 0=1.\n$$\nUnder the single stuck-at fault model at terminals $\\{I_{1},I_{2},O\\}$ with SA0 or SA1, there are $6$ faults total. A fault is detected if, for at least one applied pattern, the observed output differs from the fault-free output.\n\n- Fault $I_{1}$ SA0: Effective input becomes $(0,1)$ for the first pattern, yielding $O=0\\oplus 1=1$ (no detection on $(0,1)$), and becomes $(0,0)$ for the second pattern, yielding $O=0\\oplus 0=0\\neq 1$ (detected on $(1,0)$).\n- Fault $I_{1}$ SA1: Effective input becomes $(1,1)$ for the first pattern, yielding $O=1\\oplus 1=0\\neq 1$ (detected on $(0,1)$), and remains $(1,0)$ for the second, yielding $O=1$ (already detected).\n- Fault $I_{2}$ SA0: Effective input becomes $(0,0)$ for the first pattern, yielding $O=0\\oplus 0=0\\neq 1$ (detected on $(0,1)$), and remains $(1,0)$ for the second, yielding $O=1$ (already detected).\n- Fault $I_{2}$ SA1: Effective input remains $(0,1)$ for the first pattern, yielding $O=1$ (no detection on $(0,1)$), and becomes $(1,1)$ for the second, yielding $O=1\\oplus 1=0\\neq 1$ (detected on $(1,0)$).\n- Fault $O$ SA0: Observed output is $0$ for both patterns, while $O_{\\text{good}}=1$ for both, hence detected.\n- Fault $O$ SA1: Observed output is $1$ for both patterns, matching $O_{\\text{good}}=1$ for both, hence not detected.\n\nThus $5$ out of $6$ faults are detected. The fault coverage is\n$$\n\\text{coverage}=\\frac{5}{6}=0.833\\ldots,\n$$\nwhich rounded to three significant figures is $0.833$.", "answer": "$$\\boxed{0.833}$$", "id": "1917374"}, {"introduction": "Observing and comparing the entire output stream of a complex circuit is impractical. BIST overcomes this by using an Output Response Analyzer (ORA) to compress the lengthy output data into a compact, verifiable \"signature.\" This final practice demonstrates a straightforward signature analysis technique known as ones-counting. You will simulate the function of an ORA by accumulating the number of '1's from a sequence of output vectors to compute the final signature, illustrating the core principle of data compression in testing. [@problem_id:1917364]", "problem": "A digital systems engineer is testing a newly fabricated logic circuit using a Built-In Self-Test (BIST) mechanism. The BIST hardware includes a test response analyzer designed to generate a signature from the circuit's 4-bit output bus, denoted as `Y[3:0]`.\n\nThe analyzer's operation is as follows: It contains an internal accumulator register which is initialized to zero before the test sequence begins. At each clock cycle during the test, the analyzer counts the number of bits that are at a high logic level ('1') on the output bus `Y`. This count is then added to the value currently stored in the accumulator register. This process repeats for the entire duration of the test sequence.\n\nFor a fault-free circuit, the test sequence is known to produce the following output vectors on the bus `Y[3:0]` over three consecutive clock cycles:\n- At clock cycle T=1: `1011`\n- At clock cycle T=2: `0110`\n- At clock cycle T=3: `1111`\n\nAssuming the circuit is fault-free, calculate the final signature, which is the decimal value stored in the accumulator register after the third clock cycle (at T=3).", "solution": "The analyzer accumulates, over time, the count of high bits on the 4-bit bus. Let $A_{t}$ be the accumulator value after clock cycle $t$, with initial condition $A_{0}=0$. Let $w(b)$ denote the number of ones in a 4-bit vector $b$ (its Hamming weight). At each cycle,\n$$\nA_{t}=A_{t-1}+w\\big(Y(T=t)\\big).\n$$\nCompute the weights for the given outputs:\n$$\nw(1011)=3,\\quad w(0110)=2,\\quad w(1111)=4.\n$$\nUpdate the accumulator over the three cycles:\n$$\nA_{1}=A_{0}+3=0+3=3,\n$$\n$$\nA_{2}=A_{1}+2=3+2=5,\n$$\n$$\nA_{3}=A_{2}+4=5+4=9.\n$$\nTherefore, the final signature after $T=3$ is $A_{3}=9$.", "answer": "$$\\boxed{9}$$", "id": "1917364"}]}