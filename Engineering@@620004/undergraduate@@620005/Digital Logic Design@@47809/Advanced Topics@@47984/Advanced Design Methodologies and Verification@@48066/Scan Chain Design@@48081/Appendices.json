{"hands_on_practices": [{"introduction": "Mastering scan chain design begins with understanding its most fundamental behavior: acting as a large shift register. This initial exercise focuses on the core mechanics of serially shifting data through a chain of flip-flops. By tracing the contents of the chain cycle by cycle, you will build an intuitive grasp of how a test vector is loaded, which is the foundational skill for all scan-based testing techniques. [@problem_id:1958985]", "problem": "In modern digital circuit design, a technique known as Design for Testability (DFT) is employed to facilitate testing of manufactured chips. A common DFT method involves adding scan chains, which reconfigure the circuit's flip-flops into a large shift register during a special test mode.\n\nConsider a simple 5-bit scan chain composed of five D-type flip-flops, labeled FF1 through FF5. In test mode, the data input of FF1 is connected to a primary input port `scan_in`. The output of FF1 (Q1) is connected to the input of FF2 (D2), the output of FF2 (Q2) to the input of FF3 (D3), and so on, until the output of FF5 (Q5), which is connected to a primary output port `scan_out`.\n\nInitially, all five flip-flops in the scan chain are reset, so their contents, represented as the ordered bit-string `[Q1, Q2, Q3, Q4, Q5]`, are `00000`.\n\nA test vector sequence `10110` is serially shifted into the chain via the `scan_in` port over five consecutive clock cycles. The first bit of the sequence (`1`) is applied at `scan_in` for the first clock cycle, the second bit (`0`) is applied for the second clock cycle, and so forth.\n\nWhat is the binary content of the scan chain, `[Q1, Q2, Q3, Q4, Q5]`, after exactly 5 clock cycles?\n\nA. `10110`\n\nB. `01101`\n\nC. `00000`\n\nD. `01100`\n\nE. `11010`", "solution": "In a scan chain made of positive-edge triggered D flip-flops, at each active clock edge the next state equals the input: for FF1, $Q_{1}^{+}=D_{1}=\\text{scan\\_in}$; for $i \\in \\{2,3,4,5\\}$, $Q_{i}^{+}=D_{i}=Q_{i-1}$. Let $Q_{i}[k]$ denote the content after the $k$-th clock, with initial state $Q_{i}[0]=0$. Let the applied serial inputs be $s[1]=1$, $s[2]=0$, $s[3]=1$, $s[4]=1$, $s[5]=0$. Then the update equations per clock are\n$$\nQ_{1}[k]=s[k], \\quad Q_{i}[k]=Q_{i-1}[k-1] \\text{ for } i=2,3,4,5.\n$$\nCompute iteratively:\n- $k=1$: $[Q_{1},Q_{2},Q_{3},Q_{4},Q_{5}]=[1,0,0,0,0]$.\n- $k=2$: $[Q_{1},Q_{2},Q_{3},Q_{4},Q_{5}]=[0,1,0,0,0]$.\n- $k=3$: $[Q_{1},Q_{2},Q_{3},Q_{4},Q_{5}]=[1,0,1,0,0]$.\n- $k=4$: $[Q_{1},Q_{2},Q_{3},Q_{4},Q_{5}]=[1,1,0,1,0]$.\n- $k=5$: $[Q_{1},Q_{2},Q_{3},Q_{4},Q_{5}]=[0,1,1,0,1]$.\n\nThus, after exactly five clock cycles, the scan chain content is $01101$, corresponding to option B.", "answer": "$$\\boxed{B}$$", "id": "1958985"}, {"introduction": "Once we understand how to load data into a scan chain, the next step is to interpret the data that is shifted out. This practice transitions from mechanics to diagnostics, the primary purpose of scan testing. By comparing the expected, fault-free output with an observed, erroneous bitstream, you can pinpoint the exact location of a failure within the circuit, a crucial skill for debugging manufactured chips. [@problem_id:1958964]", "problem": "In a modern System-on-Chip (SoC), extensive testing is performed using Design-for-Test (DFT) methodologies. A key component of this is the scan chain, which connects the chip's flip-flops into a giant shift register during test mode. This allows engineers to control and observe the internal state of the circuit.\n\nConsider a digital logic block containing 16 state-holding flip-flops, indexed FF1 through FF16. For testing purposes, these have been connected into a single scan chain. The physical index of a flip-flop does not necessarily correspond to its position in the scan chain. The specific scan chain order, from the scan-in pin to the scan-out pin, is as follows:\n\nFF13 → FF2 → FF9 → FF16 → FF5 → FF11 → FF4 → FF14 → FF8 → FF1 → FF10 → FF15 → FF6 → FF12 → FF3 → FF7\n\nAfter scanning in a specific test vector, the chip is placed in functional mode for a single clock cycle to capture the outputs of the combinational logic into the flip-flops. The chip is then returned to test mode, and the captured state is scanned out.\n\nThe expected scan-out bitstream, based on a fault-free simulation, is:\n`E = 1011010111010110`\n\nThe actually observed bitstream from the physical chip is:\n`O = 1011010110010110`\n\nThe bitstreams are read from left to right, where the first bit is the first one to emerge from the scan-out pin, and the last bit is the last one. A single, non-intermittent fault exists in the combinational logic, causing exactly one flip-flop to capture an erroneous value. Identify the index $k$ of the faulty flip-flop $\\text{FF}_k$. The first flip-flop to capture an error is defined as the one that is furthest along the scan path from the scan-out pin (i.e., closest to the scan-in pin) among all flip-flops that captured incorrect data.", "solution": "The problem requires us to identify which flip-flop, $\\text{FF}_k$, captured an incorrect value by analyzing the expected and observed scan-out bitstreams. The core of the problem lies in correctly mapping the positions in the bitstream to the specific flip-flops in the non-sequential scan chain.\n\nStep 1: Understand the Scan-Out Process\nThe problem states that the scan-out bitstream is generated by shifting the captured values out, starting from the flip-flop closest to the scan-out pin. The scan chain order is given from scan-in to scan-out. We need to reverse this order to find the sequence of flip-flops as their data appears at the output.\n\nThe given scan chain path is:\nSCAN_IN → FF13 → FF2 → FF9 → FF16 → FF5 → FF11 → FF4 → FF14 → FF8 → FF1 → FF10 → FF15 → FF6 → FF12 → FF3 → FF7 → SCAN_OUT\n\nThe flip-flop nearest to the scan-out pin is FF7. Its captured value will be the first bit in the scan-out stream. The next flip-flop in the chain towards the scan-in pin is FF3, so its value will be the second bit. This continues until the last flip-flop, FF13 (nearest to the scan-in pin), whose captured value will be the last bit of the stream.\n\nLet's establish the mapping from the bit position in the stream (1 to 16) to the originating flip-flop index:\n- Bit 1: FF7\n- Bit 2: FF3\n- Bit 3: FF12\n- Bit 4: FF6\n- Bit 5: FF15\n- Bit 6: FF10\n- Bit 7: FF1\n- Bit 8: FF8\n- Bit 9: FF14\n- Bit 10: FF4\n- Bit 11: FF11\n- Bit 12: FF5\n- Bit 13: FF16\n- Bit 14: FF9\n- Bit 15: FF2\n- Bit 16: FF13\n\nStep 2: Identify Mismatches between Expected and Observed Streams\nNow, we compare the expected bitstream `E` with the observed bitstream `O` to find the position of any errors.\n\nExpected: `E = 1011010111010110`\nObserved: `O = 1011010110010110`\n\nLet's compare them bit by bit from left to right (position 1 to 16):\n- Positions 1-9: The bits are identical (`101101011`).\n- Position 10: `E` has a `1`, while `O` has a `0`. This is a mismatch.\n- Positions 11-16: The bits are identical (`010110`).\n\nThe only mismatch occurs at the 10th bit position of the scan-out stream.\n\nStep 3: Localize the Faulty Flip-Flop\nThe problem states that the source of the error is the first flip-flop in the scan chain to capture an erroneous value, defined as the one furthest from the scan-out pin among all faulty captures. In a scan-out stream, bits that come out later correspond to flip-flops that are deeper (further from the scan-out pin) in the chain. Therefore, we should identify the mismatch that occurs at the highest bit position index.\n\nIn this case, there is only one mismatch, at bit position 10. We now use the mapping from Step 1 to determine which flip-flop's captured value corresponds to this 10th bit.\n\nAccording to our mapping: Bit 10 corresponds to the value captured by FF4.\n\nSince this is the only error, the fault must be in the combinational logic cone that provides the input to FF4. Therefore, FF4 is the flip-flop that captured the erroneous value. The index $k$ of the faulty flip-flop $\\text{FF}_k$ is 4.", "answer": "$$\\boxed{4}$$", "id": "1958964"}, {"introduction": "While scan chains are a powerful tool for testing and diagnosis, their implementation does not automatically guarantee a perfectly testable chip. This final practice moves beyond the mechanics to explore the real-world limitations and complexities that engineers face. Understanding why a 'full-scan' design might still yield less than 100% fault coverage is key to developing a mature perspective on Design for Testability (DFT) and managing realistic test goals. [@problem_id:1958975]", "problem": "A junior digital design engineer is working on a complex System-on-Chip (SoC) design. For testability, a \"full-scan\" methodology was implemented, where 100% of the synchronous flip-flops in the design were stitched into a single scan chain. After running an Automatic Test Pattern Generation (ATPG) tool, the engineer is surprised to see that the final report indicates a stuck-at fault coverage of 99.2%, not 100%. The senior engineer explains that even with a full-scan implementation, achieving 100% stuck-at fault coverage is not always possible.\n\nWhich of the following are valid reasons that could explain why the stuck-at fault coverage reported by the ATPG tool is less than 100% in this scenario? Select all that apply.\n\nA. The design contains combinational logic gates whose output state, under any possible input from the scan flip-flops or primary inputs, can never affect the value captured by a scan flip-flop or a primary output. A fault on such a gate is considered redundant and untestable.\n\nB. The scan chain itself has a manufacturing defect, such as a broken connection between two scan flip-flops.\n\nC. The design contains purely asynchronous circuits (e.g., an asynchronous First-In, First-Out (FIFO) buffer or a ripple counter) whose internal nodes are not part of the synchronous scan path.\n\nD. Functional constraints on the design prohibit certain input combinations. If a fault requires one of these illegal combinations to be tested, the ATPG tool will classify it as untestable.\n\nE. The ATPG tool was configured with a limited effort level (e.g., a maximum number of backtracks or CPU time per fault), and it \"gave up\" on finding a test for a small number of complex faults, classifying them as \"ATPG-undetermined\".", "solution": "Define the stuck-at fault coverage as\n$$\nC_{sa}=\\frac{N_{\\text{det}}}{N_{\\text{total}}},\n$$\nwhere $N_{\\text{det}}$ is the number of detected stuck-at faults and $N_{\\text{total}}$ is the total number of modeled stuck-at faults. A value of $C_{sa}=1.0$ corresponds to complete detection; the report of $0.992$ indicates some faults are not detected.\n\nA full-scan implementation guarantees that all synchronous flip-flops are controllable and observable through the scan chain, effectively reducing sequential test generation to combinational ATPG between scan cells. However, full scan does not eliminate all causes of untestability or all practical limits of ATPG. Evaluate each option:\n\nConsider A. If a combinational gate’s output cannot, under any assignments to controllable inputs (primary inputs and scan-loaded flip-flop states), affect any observable point (scan flip-flop capture or primary output), then any stuck-at fault on that gate output is redundant. Such faults are provably untestable and remain in $N_{\\text{total}}$ but not in $N_{\\text{det}}$, reducing $C_{sa}$. Thus A is a valid reason.\n\nConsider B. A manufacturing defect in the scan chain (for example, a broken connection between scan flip-flops) affects silicon behavior during test application but does not affect the ATPG coverage report, which is computed on the design netlist under the assumption of fault-free scan infrastructure. The ATPG tool’s reported $C_{sa}$ is generated pre-silicon and reflects testability of modeled faults, not actual post-fabrication defects. Therefore B is not a valid explanation for the ATPG-reported coverage.\n\nConsider C. Purely asynchronous circuits or elements whose internal nodes are not included in the synchronous scan path may have limited controllability or observability from the scan chain. Faults inside such blocks can be untestable or very difficult to test, decreasing $N_{\\text{det}}$ and lowering $C_{sa}$. Thus C is a valid reason.\n\nConsider D. If functional constraints disallow certain input combinations or states, ATPG honors these constraints and avoids generating patterns that violate them. Any fault that requires a prohibited combination to be sensitized or observed will be classified as untestable, again decreasing $N_{\\text{det}}$. Thus D is a valid reason.\n\nConsider E. Practical ATPG runs are often bounded by effort limits such as maximum backtracks or CPU time per fault. For some hard faults, the tool may terminate search and classify them as ATPG-undetermined, which counts as undetected and lowers $C_{sa}$. Thus E is a valid reason.\n\nTherefore, the valid reasons are A, C, D, and E.", "answer": "$$\\boxed{ACDE}$$", "id": "1958975"}]}