{"hands_on_practices": [{"introduction": "Before commanding a processor to perform complex tasks, it is essential to understand how to instruct it to do nothing at all. This exercise explores the concept of a No-Operation (NOP) instruction, a fundamental tool in computer architecture for pipeline management and timing. By determining the control signals that prevent any change to the processor's state, you will gain a foundational understanding of what each primary control signal enables or disables in the datapath [@problem_id:1926298].", "problem": "Consider a simplified single-cycle processor architecture. The processor's control unit generates several signals to direct the operation of the datapath. The state of the processor is defined by the contents of its registers and data memory. A crucial requirement for pipelines and instruction scheduling is the ability to execute an instruction that has no effect on the processor's state, known as a No-Operation (NOP) instruction. The only change that occurs during the execution of a NOP is that the Program Counter (PC) is incremented to point to the next instruction in sequence.\n\nFor this processor, we are interested in four primary control signals generated by the main control unit:\n\n*   `RegWrite`: When asserted (set to 1), this signal enables the writing of a value into a destination register in the register file. When de-asserted (set to 0), the register file is not modified.\n*   `MemRead`: When asserted (set to 1), this signal enables a read operation from the data memory.\n*   `MemWrite`: When asserted (set to 1), this signal enables a write operation to the data memory.\n*   `Branch`: When asserted (set to 1), this signal indicates that the PC may be updated with a new target address if other conditions (like the result of an Arithmetic Logic Unit comparison) are met, causing a potential change in control flow. When de-asserted (set to 0), the PC is always updated to `$PC+4$` (assuming 4-byte instructions), proceeding to the next sequential instruction.\n\nWhich of the following sets of values for the control signals (`RegWrite`, `MemRead`, `MemWrite`, `Branch`) correctly implements a NOP instruction?\n\nA. (0, 0, 0, 0)\n\nB. (1, 0, 0, 0)\n\nC. (0, 1, 0, 0)\n\nD. (0, 0, 1, 0)\n\nE. (0, 0, 0, 1)", "solution": "A NOP must not alter the architectural state (defined here as the contents of the register file and the data memory), and must only advance the program counter to the next sequential instruction. This implies:\n- No register write: set $RegWrite = 0$ so that no destination register is modified.\n- No memory write: set $MemWrite = 0$ to prevent any change to data memory.\n- Sequential PC update only: to guarantee $PC \\leftarrow PC + 4$ unconditionally, the branch control must be de-asserted, hence $Branch = 0$. If $Branch = 1$, then depending on condition signals, the PC may change to a branch target, violating the requirement that the instruction have no effect other than the sequential increment for all possible states.\n- No memory read: set $MemRead = 0$. Although a pure memory read does not by itself change the defined architectural state (registers and data memory) if $RegWrite = 0$, asserting $MemRead$ could cause unintended side effects (e.g., exceptions or memory-mapped I/O), which would violate the requirement that the only change is $PC \\leftarrow PC + 4$. Therefore, to strictly implement a NOP with no effects other than the PC increment, $MemRead$ must be $0$.\n\nEvaluating the options:\n- A. $(0, 0, 0, 0)$ satisfies all the above: no register write, no memory access, no branch, so only $PC \\leftarrow PC + 4$ occurs.\n- B. $(1, 0, 0, 0)$ writes a register, changing state; not a NOP.\n- C. $(0, 1, 0, 0)$ reads memory; to strictly ensure no effects other than the PC increment for all states, this is rejected.\n- D. $(0, 0, 1, 0)$ writes memory; not a NOP.\n- E. $(0, 0, 0, 1)$ may change control flow depending on conditions; not guaranteed to be a NOP.\n\nTherefore, the correct control setting for a NOP is option A.", "answer": "$$\\boxed{A}$$", "id": "1926298"}, {"introduction": "Having established a baseline with the NOP instruction, we now move to orchestrating a meaningful operation. This practice challenges you to design the control logic for a custom memory-store instruction, which involves calculating an address and writing data from a register to memory. By mapping the instruction's requirements to the specific settings of the datapath's control signals, you will practice the core task of a control unit: translating an instruction's intent into concrete hardware actions [@problem_id:1926288].", "problem": "Consider a simplified single-cycle processor datapath designed to execute a set of instructions. The datapath includes a register file with two read ports and one write port, a main memory unit, and an Arithmetic Logic Unit (ALU). The flow of data is managed by several control signals and multiplexers.\n\nThe primary control signals and their functions are defined as follows:\n- `RegWrite` (1 bit): When set to 1, enables writing the result to the register file.\n- `MemtoReg` (1 bit): Selects the data source for the register file's write port. If 0, the source is the ALU result; if 1, the source is the data read from memory.\n- `MemRead` (1 bit): When set to 1, a read operation is performed on the main memory.\n- `MemWrite` (1 bit): When set to 1, a write operation is performed on the main memory.\n- `ALUSrc` (1 bit): Selects the second operand for the ALU. If 0, the operand is from the second read port of the register file; if 1, the operand is the sign-extended 16-bit immediate value from the instruction.\n- `Branch` (1 bit): When set to 1, enables logic for a conditional branch instruction.\n- `ALUOp` (2 bits): A 2-bit signal, composed of `` `ALUOp_1` `` and `` `ALUOp_0` ``, that specifies the ALU's operation. The codes are: `00` for bitwise AND, `01` for bitwise OR, `10` for addition, and `11` for subtraction.\n\nA new instruction, `STOR_OFFSET Rsrc, immediate(Rbase)`, has been added to the instruction set. This instruction performs the following operation: it retrieves the value from register `Rsrc` and stores it in memory at an address calculated by adding the value in register `Rbase` to the sign-extended `immediate` value. The operation can be described as:\n$$\n\\text{Memory}[\\text{Register}[\\text{Rbase}] + \\text{sign\\_extend}(\\text{immediate})] \\leftarrow \\text{Register}[\\text{Rsrc}]\n$$\n\nYour task is to determine the state of the primary control signals required for the processor to correctly execute the `STOR_OFFSET` instruction. Provide the binary values for the signals in the following specific order: (`RegWrite`, `ALUSrc`, `MemtoReg`, `MemRead`, `MemWrite`, `Branch`, `ALUOp_1`, `ALUOp_0`).", "solution": "The instruction semantics are given by:\n$$\n\\text{Memory}\\big[\\text{Register}[R_{\\text{base}}] + \\text{sign\\_extend}(\\text{immediate})\\big] \\leftarrow \\text{Register}[R_{\\text{src}}].\n$$\nTo implement this on the single-cycle datapath, the following actions must occur in one cycle:\n1) Read two registers: $\\text{Register}[R_{\\text{base}}]$ (for address computation) and $\\text{Register}[R_{\\text{src}}]$ (the data to store).\n2) Compute the effective address using the ALU:\n$$\n\\text{ALU\\_result} = \\text{Register}[R_{\\text{base}}] + \\text{sign\\_extend}(\\text{immediate}).\n$$\nThis requires selecting the sign-extended immediate as the ALU second operand and selecting the ALU operation as addition.\n3) Perform a memory write at the computed address with write data equal to $\\text{Register}[R_{\\text{src}}]$.\n4) Do not write any value back to the register file, since a store does not produce a register result.\n\nMapping these requirements to control signals:\n- RegWrite: No register write-back is performed for a store, hence set to $0$.\n- ALUSrc: The ALU second operand must be the sign-extended immediate for base-plus-offset addressing, hence set to $1$.\n- MemtoReg: The register write-back data source is irrelevant because RegWrite is $0$; this is a don't-care. It can be set to $0$ without affecting correctness.\n- MemRead: A store does not read from memory, hence set to $0$.\n- MemWrite: A store writes to memory, hence set to $1$.\n- Branch: This instruction is not a branch, hence set to $0$.\n- ALUOp: The ALU must perform addition for effective address calculation. Given the encoding, addition corresponds to $\\text{ALUOp} = 10$, i.e., $\\text{ALUOp\\_1} = 1$ and $\\text{ALUOp\\_0} = 0$.\n\nTherefore, in the specified order $(\\text{RegWrite}, \\text{ALUSrc}, \\text{MemtoReg}, \\text{MemRead}, \\text{MemWrite}, \\text{Branch}, \\text{ALUOp\\_1}, \\text{ALUOp\\_0})$, the required control values are:\n$$\n(0, 1, 0, 0, 1, 0, 1, 0).\n$$", "answer": "$$\\boxed{\\begin{pmatrix}0  1  0  0  1  0  1  0\\end{pmatrix}}$$", "id": "1926288"}, {"introduction": "Real-world processors execute instructions over multiple clock cycles, using a Finite State Machine (FSM) to sequence the necessary steps. This idealized view is complicated by components like memory, which may not respond instantaneously. This exercise introduces the concept of a multi-cycle control unit and the challenge of handling hardware delays, where the controller must \"wait\" for a signal like $MemReady$ before proceeding. Analyzing the state sequence for a load instruction with a memory stall will deepen your understanding of how control units maintain correct operation in asynchronous environments [@problem_id:1926245].", "problem": "Consider a simplified multi-cycle processor designed to execute a small instruction set. The processor's control unit is implemented as a Finite State Machine (FSM). The FSM has the following states, identified by numbers:\n- State 0: Instruction Fetch (Fetches the instruction from memory).\n- State 1: Instruction Decode (Decodes the instruction and fetches source registers).\n- State 2: Execute (Performs an Arithmetic Logic Unit, or ALU, operation for an R-type instruction).\n- State 3: R-type Write-back (Writes the ALU result back to a register).\n- State 4: Memory Address Calculation (Calculates the effective memory address for a load or store instruction).\n- State 5: Memory Read (Reads data from the memory location specified by the ALU).\n- State 6: Memory Write-back (Writes the data fetched from memory back to a register).\n\nThe processor's memory unit can be slow. To handle this, the FSM has a special behavior in State 5. When the FSM is in State 5, it checks an input signal called `MemReady`.\n- If `MemReady` is 1, it means the memory has successfully provided the data, and the FSM transitions to State 6 on the next clock edge.\n- If `MemReady` is 0, it means the memory is still processing the read request, and the FSM remains in State 5 on the next clock edge, effectively waiting for the memory.\n\nAssume that a `load` instruction is being executed. The memory is slow and requires exactly one extra clock cycle to provide the data. This means that after the FSM first enters State 5, the `MemReady` signal will be 0 for one full clock cycle, and will become 1 at the end of that cycle.\n\nGiven this scenario, what is the complete sequence of states (represented by their numbers) that the control unit FSM will pass through to execute this single `load` instruction, starting from the beginning of the instruction execution (State 0)?\n\nA. 0, 1, 4, 5, 6\n\nB. 0, 1, 2, 3\n\nC. 0, 1, 4, 5, 5, 6\n\nD. 0, 1, 5, 6\n\nE. 0, 1, 4, 5, 4, 6", "solution": "A load instruction in this multi-cycle FSM follows the standard path of instruction fetch, decode, address calculation, memory read, and register write-back. With state numbers, the nominal sequence when memory responds immediately is $0 \\rightarrow 1 \\rightarrow 4 \\rightarrow 5 \\rightarrow 6$.\n\nHowever, the transition rule in State $5$ is conditional on the input $MemReady$: while in State $5$, if $MemReady=1$, the FSM transitions to State $6$ on the next clock edge; if $MemReady=0$, the FSM remains in State $5$ on the next clock edge. The problem specifies that after the FSM first enters State $5$, $MemReady=0$ for one full clock cycle and becomes $1$ at the end of that cycle. Consequently, upon first being in State $5$, the FSM observes $MemReady=0$ at the next clock edge and thus stays in State $5$ for one extra cycle. After that waiting cycle, $MemReady=1$, so on the next clock edge the FSM transitions from State $5$ to State $6$.\n\nTherefore, starting from the beginning of the instruction execution, the complete sequence of states is:\n$0$ (fetch) $\\rightarrow$ $1$ (decode) $\\rightarrow$ $4$ (address calculation) $\\rightarrow$ $5$ (memory read, initial entry) $\\rightarrow$ $5$ (stall due to $MemReady=0$) $\\rightarrow$ $6$ (write-back).\n\nThis matches option C.", "answer": "$$\\boxed{C}$$", "id": "1926245"}]}