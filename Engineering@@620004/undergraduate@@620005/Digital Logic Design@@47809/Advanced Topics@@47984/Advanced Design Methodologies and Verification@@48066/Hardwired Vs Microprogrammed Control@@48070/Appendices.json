{"hands_on_practices": [{"introduction": "The fundamental unit of control in a microprogrammed architecture is the microinstructionâ€”a low-level command that directly orchestrates the CPU's datapath. This first practice invites you to design a microinstruction from scratch for a processor with a \"horizontal\" format, where many control signals are given their own bits. By calculating the total width of the microinstruction, you will gain a concrete understanding of how the datapath's requirements directly translate into the size of the control store. [@problem_id:1941350]", "problem": "An engineering team is designing the control unit for a new 32-bit Central Processing Unit (CPU). They have opted for a microprogrammed approach using a purely horizontal format to maximize performance by eliminating decoding delays for control signals. The datapath of the CPU has the following components and requirements that must be managed by each microinstruction:\n\n1.  **Register File**: The CPU contains a register file with 32 general-purpose registers. A microinstruction must be able to specify the addresses for two source registers (sources A and B) and one destination register. It must also include a single, dedicated bit to enable or disable writing to the destination register (`RegWrite`).\n\n2.  **Arithmetic Logic Unit (ALU)**: The ALU is capable of performing 30 distinct operations. The control scheme for the ALU is unencoded, meaning that for each of the 30 operations, there is a dedicated, independent control bit in the microinstruction.\n\n3.  **Data Path Multiplexers**:\n    *   One 2-to-1 multiplexer selects the second ALU operand. Its single control bit (`ALUSrc`) chooses between the value from source register B and an immediate value provided by the main instruction.\n    *   Another 2-to-1 multiplexer selects the data to be written back into the register file. Its single control bit (`MemToReg`) chooses between the result from the ALU and data fetched from memory.\n\n4.  **Memory Interface**: The interface to the main memory requires two separate control signals: `MemRead` to initiate a read operation and `MemWrite` to initiate a write operation.\n\n5.  **Branching Control**: Two independent control bits are used for program flow: `PCWrite` to enable updates to the program counter and `Branch` to execute a conditional branch.\n\n6.  **Microprogram Sequencing**: Each microinstruction must explicitly specify the address of the next microinstruction to be executed. The control store that holds the microprogram has a total capacity of 1024 microinstructions.\n\nBased on these specifications, determine the total width, in bits, of a single microinstruction in this control unit.", "solution": "To determine the microinstruction width, sum the bits required by each specified field.\n\nRegister file addressing:\n- There are $32$ registers, so each register address requires $\\log_{2} 32 = 5$ bits.\n- Two source addresses and one destination address require\n$$2 \\cdot 5 + 5 = 15 \\text{ bits}.$$\n- Add the single write-enable bit:\n$$15 + 1 = 16 \\text{ bits}.$$\n\nALU control:\n- Unencoded control with $30$ distinct operations uses $30$ independent bits:\n$$30 \\text{ bits}.$$\n\nData path multiplexers:\n- Two $2$-to-$1$ mux controls ($\\text{ALUSrc}$ and $\\text{MemToReg}$) require\n$$1 + 1 = 2 \\text{ bits}.$$\n\nMemory interface:\n- $\\text{MemRead}$ and $\\text{MemWrite}$ require\n$$1 + 1 = 2 \\text{ bits}.$$\n\nBranching control:\n- $\\text{PCWrite}$ and $\\text{Branch}$ require\n$$1 + 1 = 2 \\text{ bits}.$$\n\nMicroprogram sequencing:\n- Control store has $1024$ entries, so the next-address field needs\n$$\\log_{2} 1024 = 10 \\text{ bits}.$$\n\nTotal microinstruction width:\n$$16 + 30 + 2 + 2 + 2 + 10 = 62 \\text{ bits}.$$", "answer": "$$\\boxed{62}$$", "id": "1941350"}, {"introduction": "Having explored the static structure of a microinstruction, we now turn to dynamic performance. A primary trade-off between hardwired and microprogrammed control is execution speed. This exercise challenges you to formalize this trade-off by deriving a critical performance threshold based on an abstract timing model. By finding the condition under which the hardwired unit achieves a shorter clock period, you will develop a clear, analytical understanding of when its speed advantage outweighs the flexibility of a microprogrammed approach. [@problem_id:1941359]", "problem": "A digital systems engineering team is evaluating two different design philosophies for the control unit of a new processor. Both designs must implement the same Instruction Set Architecture (ISA).\n\nThe first option is a **hardwired control unit**. The performance of this design is limited by the longest combinational logic path. The maximum logic depth, defined as the greatest number of gates in any path from input to output, is denoted by $D_{HW}$. The clock period for this design is determined by the propagation delay through this longest path plus the setup time for the state registers.\n\nThe second option is a **microprogrammed control unit**. This design uses a control store implemented as a Read-Only Memory (ROM) and some supporting logic. The clock period for this design (i.e., the time for one micro-cycle) is determined by the critical path required to fetch the next microinstruction. This path involves accessing the ROM, processing part of the fetched microinstruction through next-address generation logic, and preparing the microprogram counter for the subsequent cycle. The logic depth of the next-address generation circuitry is denoted by $D_{addr}$.\n\nFor both designs, assume the following:\n- All logic gates have an identical propagation delay of $t_{pd}$.\n- All registers (e.g., state registers in the hardwired unit, the microprogram counter in the microprogrammed unit) have an identical setup time of $t_{setup}$.\n- The ROM in the microprogrammed unit has a specified access time of $T_{ROM}$.\n\nTo decide which design is superior in terms of raw clock speed, the team wants to find a critical threshold. Derive an expression for the threshold value of the ROM access time, let's call it $T_{threshold}$. If the actual ROM access time $T_{ROM}$ of the chosen component is greater than this $T_{threshold}$, the hardwired control unit will have a strictly shorter clock period than the microprogrammed control unit. Express your answer in terms of $D_{HW}$, $D_{addr}$, and $t_{pd}$.", "solution": "The clock period of a synchronous design is determined by the sum of the critical combinational logic delay along the longest path plus the setup time of the destination registers.\n\nFor the hardwired control unit, the maximum logic depth is $D_{HW}$ gates, each with propagation delay $t_{pd}$, and the destination register has setup time $t_{setup}$. Therefore, the clock period is\n$$\nT_{HW} = D_{HW}\\,t_{pd} + t_{setup}.\n$$\n\nFor the microprogrammed control unit, the critical path per micro-cycle consists of the ROM access plus the next-address generation logic of depth $D_{addr}$, followed by registering into the microprogram counter with setup time $t_{setup}$. Therefore, the clock period is\n$$\nT_{MP} = T_{ROM} + D_{addr}\\,t_{pd} + t_{setup}.\n$$\n\nThe hardwired control unit is strictly faster (has a strictly shorter clock period) when $T_{HW} < T_{MP}$. Substituting the expressions above,\n$$\nD_{HW}\\,t_{pd} + t_{setup} < T_{ROM} + D_{addr}\\,t_{pd} + t_{setup}.\n$$\nCancel $t_{setup}$ from both sides and rearrange to isolate $T_{ROM}$:\n$$\nD_{HW}\\,t_{pd} < T_{ROM} + D_{addr}\\,t_{pd}\n\\;\\;\\Longrightarrow\\;\\;\nT_{ROM} > (D_{HW} - D_{addr})\\,t_{pd}.\n$$\n\nThus, the threshold ROM access time at which both designs tie is\n$$\nT_{threshold} = (D_{HW} - D_{addr})\\,t_{pd}.\n$$\nFor $T_{ROM} > T_{threshold}$, the hardwired control unit has a strictly shorter clock period than the microprogrammed control unit.", "answer": "$$\\boxed{(D_{HW}-D_{addr})\\,t_{pd}}$$", "id": "1941359"}, {"introduction": "Our final practice synthesizes the previous concepts into a detailed performance analysis of a complex, iterative instruction. We will compare the total execution time for a memory `SEARCH` task when implemented with both a hardwired Finite State Machine (FSM) and a microcoded routine. This exercise reveals how the overhead of microinstruction fetching competes with the optimized logic of a hardwired unit, especially in scenarios involving loops and memory latency, allowing you to quantify the performance difference. [@problem_id:1941358]", "problem": "A digital systems architect is designing the control unit for a new Central Processing Unit (CPU). One of the requirements is to implement a specialized instruction, `SEARCH`, which performs a linear scan through a region of memory. The instruction's function is to search a block of `L` contiguous memory words for a specific value. You are tasked with analyzing the performance difference between a hardwired control unit and a microprogrammed control unit for executing this `SEARCH` instruction.\n\nThe analysis is for the worst-case scenario where the value is not found, and the instruction must iterate through the entire block of `L` words. The system has the following characteristics:\n- The length of the memory block to be searched is `L = 120` words.\n- Any memory read operation requires the CPU to wait for a fixed duration of `N_mem_cycles = 18` clock cycles.\n\nThe execution time in clock cycles for each implementation is modeled as follows:\n\n**1. Hardwired Control Unit:**\nThe control logic is implemented as a highly optimized Finite State Machine (FSM).\n- The initial fetch and decode of the `SEARCH` macro-instruction takes 4 clock cycles.\n- For each of the `L` iterations, the FSM performs the necessary internal logic (calculating the memory address, comparing the retrieved value, and managing the loop counter). Due to parallel hardware, all this internal logic completes in `C_hw_loop = 3` clock cycles per iteration. This is in addition to the memory access time.\n- After the final iteration's comparison fails, one additional clock cycle is spent to process the loop termination condition and end the instruction.\n\n**2. Microprogrammed Control Unit:**\nThe `SEARCH` instruction is implemented as a routine in a control store (microcode).\n- The initial fetch and decode of the `SEARCH` macro-instruction takes 4 clock cycles, after which control is transferred to the `SEARCH` micro-routine.\n- The micro-routine begins with a single setup microinstruction, which takes 1 clock cycle.\n- The main loop of the micro-routine executes `L` times. Each iteration consists of a sequence of microinstructions. A microinstruction takes 1 clock cycle to execute, unless stated otherwise. The sequence for one iteration is:\n    - Address Calculation: 2 microinstructions.\n    - Memory Read: 1 microinstruction which stalls the control unit. This single microinstruction's execution takes `N_mem_cycles` clock cycles to complete.\n    - Value Comparison: 1 microinstruction.\n    - Counter Increment: 1 microinstruction.\n    - Loop Control (conditional branch): 1 microinstruction.\n- After the loop finishes, a single finalization microinstruction is executed, which takes 1 clock cycle.\n\nCalculate the ratio of the total execution time of the microprogrammed implementation to the total execution time of the hardwired implementation (`T_microprogrammed / T_hardwired`). Express your answer as a single real number rounded to four significant figures.", "solution": "Define $L$ as the number of words to scan and $N_{\\text{mem\\_cycles}}$ as the fixed memory-read latency in clock cycles.\n\nHardwired control unit:\n- Initial fetch and decode costs $4$ cycles.\n- Each of the $L$ iterations performs internal logic costing $C_{\\text{hw\\_loop}}=3$ cycles and one memory read costing $N_{\\text{mem\\_cycles}}$ cycles. Thus, per-iteration cost is $3+N_{\\text{mem\\_cycles}}$.\n- After the final failed comparison, there is a $1$-cycle termination.\nTherefore,\n$$\nT_{\\text{hardwired}} \\;=\\; 4 \\;+\\; L\\,(3+N_{\\text{mem\\_cycles}}) \\;+\\; 1 \\;=\\; 5 \\;+\\; L\\,(N_{\\text{mem\\_cycles}}+3).\n$$\nSubstituting $L=120$ and $N_{\\text{mem\\_cycles}}=18$,\n$$\nT_{\\text{hardwired}} \\;=\\; 5 \\;+\\; 120\\cdot(18+3) \\;=\\; 5 \\;+\\; 120\\cdot 21 \\;=\\; 2525.\n$$\n\nMicroprogrammed control unit:\n- Initial fetch and decode costs $4$ cycles.\n- Setup microinstruction costs $1$ cycle.\n- Each iteration consists of address calculation ($2$ cycles), memory read stall ($N_{\\text{mem\\_cycles}}$ cycles), comparison ($1$), counter increment ($1$), and loop control ($1$), totaling $N_{\\text{mem\\_cycles}}+5$ cycles per iteration.\n- Finalization microinstruction costs $1$ cycle.\nTherefore,\n$$\nT_{\\mu} \\;=\\; 4 \\;+\\; 1 \\;+\\; L\\,(N_{\\text{mem\\_cycles}}+5) \\;+\\; 1 \\;=\\; 6 \\;+\\; L\\,(N_{\\text{mem\\_cycles}}+5).\n$$\nSubstituting $L=120$ and $N_{\\text{mem\\_cycles}}=18$,\n$$\nT_{\\mu} \\;=\\; 6 \\;+\\; 120\\cdot(18+5) \\;=\\; 6 \\;+\\; 120\\cdot 23 \\;=\\; 2766.\n$$\n\nThe required ratio is\n$$\n\\frac{T_{\\mu}}{T_{\\text{hardwired}}}\n\\;=\\;\n\\frac{6 + L\\,(N_{\\text{mem\\_cycles}}+5)}{5 + L\\,(N_{\\text{mem\\_cycles}}+3)}\n\\;=\\;\n\\frac{2766}{2525}\n\\approx 1.095445\\ldots\n$$\nRounded to four significant figures, this is $1.095$.", "answer": "$$\\boxed{1.095}$$", "id": "1941358"}]}