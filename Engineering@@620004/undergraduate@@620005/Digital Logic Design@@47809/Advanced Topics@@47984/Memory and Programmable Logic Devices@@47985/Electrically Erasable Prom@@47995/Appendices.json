{"hands_on_practices": [{"introduction": "Before data can be stored or retrieved, a processor must be able to uniquely pinpoint every storage location within a memory chip. This initial practice focuses on the most fundamental aspect of memory architecture: addressing. By working through this problem [@problem_id:1932063], you will calculate the number of address lines required for a given memory capacity, reinforcing the direct relationship between a chip's size and the physical hardware needed to interface with it.", "id": "1932063", "problem": "A digital systems engineer is tasked with integrating a non-volatile memory module into a new embedded system. The selected component is an Electrically Erasable Programmable Read-Only Memory (EEPROM) chip with a memory organization specified as 4K x 8. This notation indicates that the memory array consists of 4K individual storage locations, known as words, and each word is capable of storing 8 bits of data. For addressing purposes in digital memory systems, the prefix 'K' represents a multiplier of $1024$. In order for the processor to read from or write to a specific word, it must provide a unique binary address to the EEPROM's address input pins. Determine the minimum number of address lines that the address bus must have to be able to uniquely specify every distinct word location within this EEPROM chip.\n\n", "solution": "The memory is organized as $4\\text{K} \\times 8$, meaning there are $N$ distinct word locations where\n$$\nN = 4 \\times \\text{K} = 4 \\times 1024.\n$$\nUsing the definition $\\text{K} = 1024 = 2^{10}$, this becomes\n$$\nN = 4 \\times 2^{10} = 2^{2} \\times 2^{10} = 2^{12}.\n$$\nIn a binary-addressed memory, $n$ address lines can uniquely select $2^{n}$ locations. The minimum $n$ required satisfies\n$$\n2^{n} \\geq N \\quad \\Longrightarrow \\quad n \\geq \\log_{2}(N).\n$$\nThus the minimum number of address lines is\n$$\nn_{\\min} = \\lceil \\log_{2}(N) \\rceil = \\lceil \\log_{2}(2^{12}) \\rceil = 12.\n$$\nThe $8$ in $4\\text{K} \\times 8$ refers to the data width per word and does not affect the number of address lines.", "answer": "$$\\boxed{12}$$"}, {"introduction": "Successfully interfacing with memory goes beyond simply providing the correct address; it demands precise timing. This exercise [@problem_id:1932077] delves into the critical role of timing specifications, which are a common source of errors in real-world embedded systems. By analyzing a scenario with a timing violation, you will learn to predict the logical consequences of such a fault, a crucial skill for both robust design and effective debugging.", "id": "1932077", "problem": "A microcontroller is interfaced with a parallel Electrically Erasable Programmable Read-Only Memory (EEPROM) chip. The memory has a 16-bit address bus and an 8-bit data bus. A write cycle to the EEPROM is controlled by several signals, including the active-low Write Enable signal ($\\overline{WE}$). The manufacturer's datasheet for the EEPROM specifies the following minimum timing requirements for a write cycle:\n\n-   Address Setup Time ($t_{AS}$): The address on the bus must be stable for at least 20 ns before $\\overline{WE}$ transitions from high to low.\n-   Address Hold Time ($t_{AH}$): The address on the bus must remain stable for at least 5 ns after $\\overline{WE}$ transitions from low to high.\n-   Data Setup Time ($t_{DS}$): The data on the bus must be stable for at least 15 ns before $\\overline{WE}$ transitions from low to high.\n-   Write Pulse Width ($t_{WP}$): The $\\overline{WE}$ signal must remain low for a minimum of 40 ns.\n\nAssume all other timing requirements (e.g., $t_{AH}$, $t_{DS}$, $t_{WP}$) are met by the microcontroller.\n\nThe microcontroller attempts to perform a write operation. Initially, the address bus holds the value `0xABCC`. At time $t=0$, the microcontroller changes the address on the bus to `0xABCD` and places the data value `0x55` on the data bus. At time $t=12$ ns, the microcontroller pulls the $\\overline{WE}$ signal low to initiate the write. After 50 ns (at $t=62$ ns), it raises $\\overline{WE}$ back to high, concluding the write pulse.\n\nBefore this operation, the data stored at address `0xABCC` was `0xFF`, and the data stored at address `0xABCD` was also `0xFF`.\n\nAfter this single, faulty write cycle is completed, what are the final data values stored at memory addresses `0xABCC` and `0xABCD`, respectively? Select the option that represents the pair (Data at `0xABCC`, Data at `0xABCD`).\n\nA. (`0x55`, `0x55`)\nB. (`0xFF`, `0x55`)\nC. (`0x55`, `0xFF`)\nD. (`0xFF`, `0xFF`)\nE. The contents of both locations become corrupted and are indeterminate.\n\n", "solution": "The write-cycle timing constraints from the datasheet require that the address be valid and stable for at least $t_{AS}$ before the falling edge of $\\overline{WE}$, and that data and address meet their setup/hold times around the rising edge of $\\overline{WE}$. Specifically:\n- Address setup: the address must be stable for at least $t_{AS}=20\\ \\text{ns}$ before $\\overline{WE}$ transitions high-to-low.\n- Address hold: the address must remain stable for at least $t_{AH}=5\\ \\text{ns}$ after $\\overline{WE}$ transitions low-to-high.\n- Data setup: the data must be stable for at least $t_{DS}=15\\ \\text{ns}$ before $\\overline{WE}$ transitions low-to-high.\n- Write pulse width: $\\overline{WE}$ low time $t_{WP}\\geq 40\\ \\text{ns}$.\n\nTimeline of the attempted write:\n- Initially, the address bus is 0xABCC.\n- At $t=0$, the microcontroller changes the address to 0xABCD and puts data 0x55 on the data bus.\n- At $t=12\\ \\text{ns}$, $\\overline{WE}$ goes low.\n- At $t=62\\ \\text{ns}$, $\\overline{WE}$ goes high (pulse width $50\\ \\text{ns}$).\n\nCheck each timing:\n1) Address setup to $\\overline{WE}$ low:\n- Requirement: stable for $20\\ \\text{ns}$ before the falling edge at $t=12\\ \\text{ns}$; i.e., valid and unchanged throughout the interval $[t-20\\ \\text{ns}, t]=[-8\\ \\text{ns},12\\ \\text{ns}]$.\n- Actual: the address changed at $t=0$ from 0xABCC to 0xABCD. Therefore the new address 0xABCD has been stable only from $t=0$ to $t=12\\ \\text{ns}$, which is $12\\ \\text{ns}<20\\ \\text{ns}$. Thus $t_{AS}$ is violated for the intended address 0xABCD.\n2) Data setup to $\\overline{WE}$ high:\n- Requirement: data stable for $15\\ \\text{ns}$ before $t=62\\ \\text{ns}$; i.e., valid during $[47\\ \\text{ns},62\\ \\text{ns}]$.\n- Actual: data 0x55 was placed at $t=0$ and remains; hence the requirement is met.\n3) Address hold after $\\overline{WE}$ high:\n- Requirement: address stable for $5\\ \\text{ns}$ after $t=62\\ \\text{ns}$.\n- Assumed met by the problem statement.\n4) Write pulse width:\n- Actual low time is $50\\ \\text{ns}\\geq 40\\ \\text{ns}$, so met.\n\nConsequences of the $t_{AS}$ violation:\n- The purpose of $t_{AS}$ is to ensure the internal address decoder has settled to the correct wordline before $\\overline{WE}$ goes low, so that the correct memory cell is selected at the start of the write pulse. Because the address was changed only $12\\ \\text{ns}$ before the falling edge, the decoder may not have fully switched to 0xABCD when $\\overline{WE}$ went low. In practice, with this violation, the device can select the previously addressed location (0xABCC) when the write is initiated.\n- All other timing (data setup to the rising edge, address hold after the rising edge, and pulse width) is satisfied, so the write operation proceeds and completes reliably once initiated.\n\nTherefore, the byte 0x55 is written to the old address 0xABCC, while the intended address 0xABCD remains unchanged at its prior value 0xFF.\n\nHence, after the faulty write, the stored data are (0x55 at 0xABCC, 0xFF at 0xABCD), which corresponds to option C.", "answer": "$$\\boxed{C}$$"}, {"introduction": "Individual memory operations are just one piece of the puzzle; ensuring the long-term reliability of a storage system presents a greater challenge. EEPROM and similar non-volatile memories have a limited number of write cycles, a constraint that must be managed at the system level. This advanced problem [@problem_id:1932023] puts you in the role of a controller designer, tasked with implementing a wear-leveling strategy to maximize the device's lifespan, revealing the sophisticated techniques used in modern storage solutions.", "id": "1932023", "problem": "A memory controller is being designed for a high-reliability storage system based on an Electrically Erasable Programmable Read-Only Memory (EEPROM) array. The controller must implement two key features: a predictive wear-leveling scheme and data integrity verification using a Single-Error Correction, Double-Error Detection (SECDED) code.\n\nThe system's specifications are as follows:\n*   The logical address space available to the user is 4 Mebibytes (MiB), where 1 MiB = $2^{20}$ bytes.\n*   The EEPROM array has a physical capacity that is 25% larger than the logical address space to facilitate wear-leveling (this is known as over-provisioning).\n*   The memory, both logical and physical, is organized into blocks of 4 Kibibytes (KiB), where 1 KiB = $2^{10}$ bytes. Data is written and erased in these block units.\n*   The EEPROM cells have an endurance of 100,000 write/erase cycles per physical block.\n*   For data integrity, the controller applies a SECDED code to the data. This code is calculated for every 64-bit word of data stored within a block. The resulting parity bits are stored alongside the data words in the EEPROM.\n\nTo manage wear-leveling, the controller uses dynamic address remapping. This requires two data structures, which are maintained in a dedicated, high-speed Static Random-Access Memory (SRAM) integrated within the controller:\n1.  A Logical-to-Physical (L2P) Mapping Table: This table translates each logical block address from the user's perspective into a physical block address in the EEPROM array.\n2.  A Write-Count Tracker: This structure stores an integer counter for each physical block, tracking the number of times it has been written to.\n\nAssuming the controller uses the minimum amount of SRAM necessary to implement these two wear-leveling data structures, calculate the total size of this dedicated SRAM. Express your answer in bits.\n\n", "solution": "The problem asks for the total minimum size of the dedicated Static Random-Access Memory (SRAM) used to store the wear-leveling metadata. This metadata consists of two parts: the Logical-to-Physical (L2P) Mapping Table and the Write-Count Tracker. We will calculate the size required for each part and then sum them.\n\nFirst, let's determine the number of logical and physical blocks in the system. The total logical address space is given as $S_{log} = 4 \\text{ MiB}$ and the block size is $S_{block} = 4 \\text{ KiB}$. We convert these to bytes using the provided definitions (1 MiB = $2^{20}$ bytes, 1 KiB = $2^{10}$ bytes).\nThe number of logical blocks, $L$, is the ratio of the total logical size to the block size:\n$$L = \\frac{S_{log}}{S_{block}} = \\frac{4 \\times 2^{20} \\text{ bytes}}{4 \\times 2^{10} \\text{ bytes}} = 2^{10} = 1024$$\nSo, there are 1024 logical blocks.\n\nThe physical capacity is 25% larger than the logical capacity. The number of physical blocks, $P$, is therefore 25% larger than the number of logical blocks:\n$$P = L \\times (1 + 0.25) = 1024 \\times 1.25 = 1280$$\nSo, there are 1280 physical blocks in the EEPROM array.\n\nNext, we calculate the size of the L2P Mapping Table. This table needs an entry for each logical block to store its corresponding physical block address.\n*   Number of entries in the table = Number of logical blocks = $L = 1024$.\n*   Each entry must store a pointer to one of the 1280 physical blocks. The number of bits required to uniquely address $P$ items is $\\lceil \\log_{2}(P) \\rceil$.\n*   Size of each entry = $\\lceil \\log_{2}(1280) \\rceil$.\nSince $2^{10} = 1024$ and $2^{11} = 2048$, we require 11 bits to address any of the 1280 physical blocks.\n*   Size of each entry = 11 bits.\nThe total size of the L2P Mapping Table, $M_{L2P}$, is the product of the number of entries and the size of each entry:\n$$M_{L2P} = 1024 \\times 11 \\text{ bits} = 11264 \\text{ bits}$$\n\nNow, we calculate the size of the Write-Count Tracker. This structure must maintain a counter for each physical block.\n*   Number of counters = Number of physical blocks = $P = 1280$.\n*   Each counter must be able to count up to the maximum endurance of the EEPROM, which is $W_{max} = 100,000$ cycles. The number of bits required to store a count of $W_{max}$ is $\\lceil \\log_{2}(W_{max} + 1) \\rceil$ or more simply $\\lceil \\log_{2}(W_{max}) \\rceil$ if we count from 0 to $W_{max}-1$. For large $W_{max}$, they are usually the same. Let's use $\\lceil \\log_{2}(W_{max}) \\rceil$.\n*   Size of each counter = $\\lceil \\log_{2}(100,000) \\rceil$.\nWe can calculate $\\log_{2}(10^5) = 5 \\log_{2}(10) \\approx 5 \\times 3.3219 = 16.6096$.\nThe ceiling of this value is $\\lceil 16.6096 \\rceil = 17$. So, each counter requires 17 bits.\n*   Size of each counter = 17 bits.\nThe total size of the Write-Count Tracker, $M_{WC}$, is the product of the number of counters and the size of each counter:\n$$M_{WC} = 1280 \\times 17 \\text{ bits} = 21760 \\text{ bits}$$\n\nFinally, the total minimum size of the dedicated SRAM, $M_{SRAM}$, is the sum of the sizes of the two data structures.\n$$M_{SRAM} = M_{L2P} + M_{WC} = 11264 \\text{ bits} + 21760 \\text{ bits} = 33024 \\text{ bits}$$\n\nNote that the information about the Single-Error Correction, Double-Error Detection (SECDED) code and the 64-bit word size is not needed for this calculation. The SECDED parity bits are stored within the main EEPROM array along with the data they protect, not in the dedicated SRAM used for a wear-leveling management. This information describes part of the controller's functionality but does not impact the size of the mapping and tracking structures.", "answer": "$$\\boxed{33024}$$"}]}