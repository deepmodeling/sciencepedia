{"hands_on_practices": [{"introduction": "At its core, any combinational logic circuit is a function that maps a set of inputs to a corresponding set of outputs. Read-Only Memory (ROM) provides a direct and powerful way to implement such functions by storing the output for every possible input combination. This first practice challenges you to determine the fundamental storage capacity required for a ROM to replace a given logic circuit, reinforcing the core relationship between the number of inputs ($n$), outputs ($m$), and total memory size ($2^n \\times m$ bits) [@problem_id:1956906].", "problem": "In the design of a custom microcontroller for an Internet of Things (IoT) device, a crucial component is the instruction decoder. This decoder, which functions as a combinational logic circuit, is responsible for interpreting the operation to be performed. The decoder receives a 4-bit opcode from the instruction register as its set of inputs. Based on this opcode, it generates 3 distinct control signals that are sent to the microcontroller's Arithmetic Logic Unit (ALU).\n\nTo simplify the hardware design and allow for potential modifications through firmware updates, an engineer decides to implement this entire decoder logic using a single Read-Only Memory (ROM).\n\nDetermine the minimum total storage capacity of this ROM required to fully implement the described decoder functionality. Express your answer in bits.", "solution": "A Read-Only Memory used to implement a combinational decoder stores, for every possible input combination, the corresponding output word. If the input has width $n$ bits and the output has width $m$ bits, then the number of addresses is $2^{n}$ and each address stores $m$ bits, so the total storage capacity in bits is\n$$C=2^{n}\\cdot m.$$\nHere, the opcode width is $n=4$ and the number of control signals is $m=3$, hence\n$$C=2^{4}\\cdot 3=16\\cdot 3=48\\ \\text{bits}.$$\nTherefore, the minimum total storage capacity required is $48$ bits.", "answer": "$$\\boxed{48}$$", "id": "1956906"}, {"introduction": "Once the size of a ROM is determined, the next step is to define its contents to perform a specific task. This hands-on exercise takes you through the process of 'programming' a ROM by translating a desired logical function—in this case, a prime number detector—into the precise binary data stored at each memory address [@problem_id:1956845]. By doing so, you will gain a concrete understanding of how a ROM acts as a universal logic element, capable of realizing any truth table.", "problem": "A digital systems engineer is tasked with programming a small, specialized logic device. The device is a 16x1 Read-Only Memory (ROM), which has 4 address lines and a single data output line. The 4 address lines accept a 4-bit unsigned integer, which we can denote as $N$, corresponding to the decimal values 0 through 15. The ROM is to be programmed to function as a prime number detector. The single data line should output a logic '1' if the input integer $N$ is a prime number, and a logic '0' otherwise. By standard mathematical definition, the integers 0 and 1 are not considered prime numbers.\n\nYour task is to determine the complete 16-bit data content that must be stored in this ROM to achieve the desired functionality. Present your final answer as a single 16-bit binary string, where the leftmost bit corresponds to the data stored at address 0, the next bit to address 1, and so on, up to the rightmost bit which corresponds to the data at address 15.", "solution": "The ROM has addresses labeled by $N \\in \\{0,1,\\dots,15\\}$. The output bit is $1$ if and only if $N$ is prime. By definition, an integer is prime if it is greater than $1$ and has no positive divisors other than $1$ and itself. Therefore $0$ and $1$ are not prime, so $b_{0}=0$ and $b_{1}=0$.\n\nFor $N \\geq 2$, test divisibility by integers from $2$ to $\\lfloor \\sqrt{N} \\rfloor$:\n- $N=2$: no integer in $[2,\\lfloor \\sqrt{2} \\rfloor]$, so prime $\\Rightarrow b_{2}=1$.\n- $N=3$: no integer in $[2,\\lfloor \\sqrt{3} \\rfloor]$, so prime $\\Rightarrow b_{3}=1$.\n- $N=4$: divisible by $2$, composite $\\Rightarrow b_{4}=0$.\n- $N=5$: not divisible by $2$, prime $\\Rightarrow b_{5}=1$.\n- $N=6$: divisible by $2$, composite $\\Rightarrow b_{6}=0$.\n- $N=7$: not divisible by $2$ or $3$, prime $\\Rightarrow b_{7}=1$.\n- $N=8$: divisible by $2$, composite $\\Rightarrow b_{8}=0$.\n- $N=9$: divisible by $3$, composite $\\Rightarrow b_{9}=0$.\n- $N=10$: divisible by $2$, composite $\\Rightarrow b_{10}=0$.\n- $N=11$: not divisible by $2$ or $3$, prime $\\Rightarrow b_{11}=1$.\n- $N=12$: divisible by $2$, composite $\\Rightarrow b_{12}=0$.\n- $N=13$: not divisible by $2$ or $3$, prime $\\Rightarrow b_{13}=1$.\n- $N=14$: divisible by $2$, composite $\\Rightarrow b_{14}=0$.\n- $N=15$: divisible by $3$ (and $5$), composite $\\Rightarrow b_{15}=0$.\n\nThus the set of primes in $\\{0,1,\\dots,15\\}$ is $\\{2,3,5,7,11,13\\}$, and the mapping is\n$$\nb_{N}=\\begin{cases}\n1, & N \\in \\{2,3,5,7,11,13\\},\\\\\n0, & \\text{otherwise}.\n\\end{cases}\n$$\nListing bits from address $0$ (leftmost) to address $15$ (rightmost) gives\n$$\nb_{0}b_{1}b_{2}b_{3}b_{4}b_{5}b_{6}b_{7}b_{8}b_{9}b_{10}b_{11}b_{12}b_{13}b_{14}b_{15}\n=0011010100010100.\n$$", "answer": "$$\\boxed{0011010100010100}$$", "id": "1956845"}, {"introduction": "Our abstract models of digital logic often assume signals change instantaneously, but in the physical world, timing delays are inevitable. This practice delves into the practical issue of 'glitches'—unwanted, transient pulses at a ROM's output caused by timing misalignments in the address inputs. By analyzing a parity generator circuit [@problem_id:1956894], you will learn to identify conditions that lead to such hazards and explore a standard engineering technique used in synchronous systems to ensure reliable and glitch-free operation.", "problem": "A 16x1 Read-Only Memory (ROM) is utilized in a digital system. This ROM has four address input lines, denoted as $A_3, A_2, A_1, A_0$, and a single data output line, $D_0$. The ROM has been programmed to function as a 4-input even parity generator. The output $D_0$ is logic '0' if the address input has an even number of '1's, and logic '1' if the address input has an odd number of '1's.\n\nIn the physical implementation, the address signals arriving at the ROM's internal decoders do not change at the exact same instant. This timing skew means that during a transition from one address to another, one or more incorrect intermediate addresses might be momentarily selected, potentially causing a spurious, short-lived pulse, known as a glitch, on the output line $D_0$. The risk of a glitch occurring is highest for address transitions where a large number of address bits change simultaneously, but the ideal output state should remain constant.\n\nGiven this scenario, which of the following options correctly identifies an address transition with a high likelihood of producing an output glitch and also proposes an effective, standard system-level technique to mitigate such glitches in a synchronous digital system?\n\nA. Transition: 0001 to 0011; Fix: Add a high-current buffer to the ROM output $D_0$.\n\nB. Transition: 0101 to 1010; Fix: Replace the ROM with one that has a faster access time.\n\nC. Transition: 0111 to 1000; Fix: Latch the ROM output $D_0$ using a register clocked to sample the data after it has stabilized.\n\nD. Transition: 0011 to 0110; Fix: Redesign the parity generation logic using discrete XOR gates instead of a ROM.\n\nE. Transition: 0000 to 1111; Fix: Require that all input address sequences follow a Gray code pattern.", "solution": "We model the programmed ROM as implementing the 4-input parity function\n$$\nD_{0}=A_{3}\\oplus A_{2}\\oplus A_{1}\\oplus A_{0},\n$$\nwhere $D_{0}=0$ for an even number of input ones and $D_{0}=1$ for an odd number. A glitch can occur during a transition between two address vectors if the address lines do not switch simultaneously, because intermediate, momentarily selected addresses can have parity different from the intended final parity. The risk is greatest when the ideal output should remain constant while many address bits change at once, since the probability of passing through intermediate addresses of differing parity increases with the Hamming distance of the transition.\n\nDefine the Hamming distance between two address vectors $\\mathbf{a}$ and $\\mathbf{b}$ as\n$$\nd_{H}(\\mathbf{a},\\mathbf{b})=\\sum_{i=0}^{3}\\left|a_{i}-b_{i}\\right|,\n$$\nwhich counts the number of bits that change. For highest glitch likelihood, we want $D_{0}(\\mathbf{a})=D_{0}(\\mathbf{b})$ (ideal output constant) and $d_{H}$ as large as possible.\n\nEvaluate each option:\n\nA. Transition 0001 to 0011. Parities: $0001$ has one one, so odd, hence $D_{0}=1$; $0011$ has two ones, so even, hence $D_{0}=0$. The ideal output changes, and only one bit changes ($d_{H}=1$). This is not a high-likelihood spurious glitch case. The proposed fix, adding a high-current buffer, does not address logic hazards because it does not remove intermediate-address decoding or internal races.\n\nB. Transition 0101 to 1010. Parities: $0101$ has two ones, so even, $D_{0}=0$; $1010$ has two ones, so even, $D_{0}=0$. The ideal output is constant, and all four bits change ($d_{H}=4$), which is indeed a high-likelihood glitch scenario. However, replacing the ROM with a faster one does not guarantee elimination of hazards caused by unequal input arrival times and internal decoder races; it may only shorten the glitch but not ensure correct synchronous behavior at the system level.\n\nC. Transition 0111 to 1000. Parities: $0111$ has three ones, so odd, $D_{0}=1$; $1000$ has one one, so odd, $D_{0}=1$. The ideal output is constant, and all four bits change ($d_{H}=4$), yielding a high likelihood of glitches. The proposed fix is to latch $D_{0}$ in a register clocked to sample after the ROM output has stabilized. In a synchronous system, this is the standard technique: choose the clock such that the register samples $D_{0}$ after the ROM and its address inputs meet setup and hold constraints, thereby filtering any transient glitches.\n\nD. Transition 0011 to 0110. Parities: $0011$ has two ones, even, $D_{0}=0$; $0110$ has two ones, even, $D_{0}=0$. The ideal output is constant, but only two bits change ($d_{H}=2$), which is a lower but still possible hazard case. Redesigning with XOR gates does not inherently eliminate hazards unless the logic is explicitly hazard-free and still does not constitute a standard system-level mitigation compared to registering the output.\n\nE. Transition 0000 to 1111. Parities: $0000$ has zero ones, even, $D_{0}=0$; $1111$ has four ones, even, $D_{0}=0$. The ideal output is constant and all four bits change ($d_{H}=4$), so the transition is high-likelihood for glitches. Requiring Gray code sequencing can reduce glitches by ensuring single-bit transitions, but it is not generally a standard or universally applicable system-level mitigation for arbitrary addresses in synchronous systems; it imposes constraints on the address producer and is less broadly applicable than registering the output.\n\nAmong the options that identify a high-likelihood transition, both B, C, and E have $d_{H}=4$ with constant ideal output, but only C proposes the effective, standard synchronous-system remedy of registering the ROM output to sample after stabilization. Therefore, the correct choice is C.", "answer": "$$\\boxed{C}$$", "id": "1956894"}]}