{"hands_on_practices": [{"introduction": "The heart of an FPGA's reconfigurable fabric is the Look-Up Table, or LUT. This exercise provides a foundational understanding of how a simple combinational logic function is physically implemented in an FPGA. By translating the requirements of a 3-input majority function into a specific 8-bit configuration string, you will gain hands-on experience with the direct relationship between a truth table and the memory bits that define a LUT's behavior [@problem_id:1938016].", "problem": "In the design of modern digital systems, Field-Programmable Gate Arrays (FPGAs) are commonly used for their flexibility. The fundamental building block of an FPGA is the configurable logic block, which often contains several Look-Up Tables (LUTs). A $k$-input LUT is a small memory that can be configured to implement any Boolean function of $k$ variables. For a 3-input LUT, this memory stores $2^3 = 8$ bits of data, forming an 8-bit \"configuration string.\" When the three inputs to the LUT are applied, they are treated as an address to this memory, and the bit stored at that address becomes the output of the LUT.\n\nConsider a simple fault-tolerant system that uses three redundant sensors to monitor a critical condition. Let the binary outputs of these sensors be $A$, $B$, and $C$. To generate a reliable signal, a \"3-input majority\" function is required. This function outputs a `1` if and only if two or more of its inputs are `1`; otherwise, it outputs a `0`.\n\nYou are tasked with implementing this 3-input majority function using a single 3-input LUT. The inputs to the LUT are $A$, $B$, and $C$. These inputs are interpreted as a 3-bit binary number, $CBA$, to form an address, where $C$ is the most significant bit (MSB) and $A$ is the least significant bit (LSB). The 8-bit configuration string is defined as the sequence of memory values from address 7 down to address 0. That is, the string is `{mem[7], mem[6], mem[5], mem[4], mem[3], mem[2], mem[1], mem[0]}`.\n\nWhich of the following represents the correct 8-bit configuration string required to implement the 3-input majority function?\n\nA. 00010111\n\nB. 11101000\n\nC. 10000000\n\nD. 11111110\n\nE. 10010110", "solution": "To solve this problem, we need to determine the 8-bit configuration string for a 3-input Look-Up Table (LUT) that implements a 3-input majority function. Let the inputs be $A$, $B$, and $C$, and the output be $F(A, B, C)$.\n\nThe first step is to construct the truth table for the 3-input majority function. The function's output is 1 if two or more inputs are 1, and 0 otherwise. The inputs $C$, $B$, and $A$ also form the address for the LUT's memory, where $C$ is the most significant bit (MSB) and $A$ is the least significant bit (LSB). The integer value of the binary number $CBA$ corresponds to the memory address.\n\nLet's build the truth table, including the decimal address corresponding to each input combination.\n\n| Address (Decimal) | Input $C$ | Input $B$ | Input $A$ | Number of '1's | Output $F$ |\n|-------------------|-----------|-----------|-----------|----------------|------------|\n| 0                 | 0         | 0         | 0         | 0              | 0          |\n| 1                 | 0         | 0         | 1         | 1              | 0          |\n| 2                 | 0         | 1         | 0         | 1              | 0          |\n| 3                 | 0         | 1         | 1         | 2              | 1          |\n| 4                 | 1         | 0         | 0         | 1              | 0          |\n| 5                 | 1         | 0         | 1         | 2              | 1          |\n| 6                 | 1         | 1         | 0         | 2              | 1          |\n| 7                 | 1         | 1         | 1         | 3              | 1          |\n\nThe output column $F$ represents the bit that should be stored at each corresponding memory address in the LUT. So, we have:\n- `mem[0]` = 0\n- `mem[1]` = 0\n- `mem[2]` = 0\n- `mem[3]` = 1\n- `mem[4]` = 0\n- `mem[5]` = 1\n- `mem[6]` = 1\n- `mem[7]` = 1\n\nThe problem specifies that the configuration string is the sequence of memory values from address 7 down to address 0. This means the string is formed by concatenating the memory bits in the order `mem[7] mem[6] mem[5] mem[4] mem[3] mem[2] mem[1] mem[0]`.\n\nUsing the values we derived from the truth table:\n- `mem[7]` = 1\n- `mem[6]` = 1\n- `mem[5]` = 1\n- `mem[4]` = 0\n- `mem[3]` = 1\n- `mem[2]` = 0\n- `mem[1]` = 0\n- `mem[0]` = 0\n\nAssembling these bits in the specified order gives the 8-bit configuration string: `11101000`.\n\nComparing this result with the given options:\nA. 00010111 (This is the reverse order, from address 0 to 7. A common mistake.)\nB. 11101000 (This matches our derived string.)\nC. 10000000 (This would implement a 3-input AND gate.)\nD. 11111110 (This would implement a 3-input OR gate.)\nE. 10010110 (This would implement a 3-input XOR gate.)\n\nThus, the correct configuration string is `11101000`, which corresponds to option B.", "answer": "$$\\boxed{B}$$", "id": "1938016"}, {"introduction": "Having explored the single LUT, we now scale up to the next level of the FPGA hierarchy: the Configurable Logic Block (CLB). A CLB groups LUTs with other essential resources like flip-flops and multiplexers to create a versatile logic-building unit. This practice problem challenges you to quantify the \"programmability\" of a simplified CLB by calculating the total number of configuration bits needed, revealing the memory footprint required to define its function [@problem_id:1937997].", "problem": "An engineer is designing a custom Field-Programmable Gate Array (FPGA). The fundamental building block of this FPGA is a simplified Configurable Logic Block (CLB). Each CLB contains two identical and independent 'Logic Slices'.\n\nA single Logic Slice is composed of the following elements:\n1.  One 4-input Look-Up Table (LUT), which can be programmed to implement any arbitrary 4-input Boolean function.\n2.  One D-type flip-flop (DFF) for registered operations.\n3.  A 2-to-1 multiplexer, MUX_OUT, which selects the final output of the Logic Slice. The inputs to MUX_OUT are the output from the LUT (for a combinational path) and the Q output from the DFF (for a registered path). The select line of this multiplexer is controlled by a configuration bit.\n4.  A 2-to-1 multiplexer, MUX_DFF, which determines the input to the DFF. The inputs to MUX_DFF are the output from the LUT and a dedicated bypass input to the slice. The select line of this multiplexer is also controlled by a configuration bit.\n5.  The DFF itself has a single configuration bit that determines its clocking behavior, allowing a selection between rising-edge or falling-edge triggering.\n\nConfiguration bits are special memory cells that hold their value after the FPGA is programmed and do not change during normal operation. Calculate the total number of configuration bits required to fully program one complete CLB. Your calculation should only include the bits necessary for the components within the slices as described, ignoring any bits associated with the external routing interconnects.\n\nProvide your answer as a single integer.", "solution": "A 4-input LUT must store the output value for each possible input combination. With 4 inputs, there are $2^{4}$ input combinations, so the LUT requires $2^{4}$ configuration bits.\n\nEach 2-to-1 multiplexer controlled by configuration needs one configuration bit for its select line. There are two such multiplexers: MUX_OUT and MUX_DFF, contributing $1 + 1$ bits.\n\nThe DFF has a single configuration bit to select rising-edge or falling-edge triggering, contributing $1$ bit.\n\nTherefore, the total number of configuration bits per Logic Slice is\n$$B_{\\text{slice}} = 2^{4} + 1 + 1 + 1 = 16 + 3 = 19.$$\n\nSince one CLB contains two identical and independent Logic Slices, the total number of configuration bits per CLB is\n$$B_{\\text{CLB}} = 2 \\times B_{\\text{slice}} = 2 \\times 19 = 38.$$", "answer": "$$\\boxed{38}$$", "id": "1937997"}, {"introduction": "The true power of FPGAs lies in their ability to implement not just combinational logic, but also complex sequential systems that have memory and state. This is achieved by combining the LUT with a D-type flip-flop (DFF) within a single logic element. In this final practice, you will configure a LUT to create the necessary input logic that transforms a standard DFF into a T-type flip-flop with a synchronous enable, demonstrating how these components work in concert to build stateful circuits [@problem_id:1938061].", "problem": "A specialized Logic Element (LE) within a Field-Programmable Gate Array (FPGA) is designed to be highly flexible. This particular LE consists of a single three-input Look-Up Table (LUT) and one D-type flip-flop (DFF). The output of the LUT directly feeds the $D$ input of the DFF. The registered output of the DFF, denoted as $Q$, is available as an output of the LE and can also be used as a feedback input to the LUT.\n\nYour task is to configure this LE to function as a T-type flip-flop (T-FF) with a synchronous, active-high clock enable signal, $CE$. The three inputs available to the LUT are the toggle signal $T$, the clock enable signal $CE$, and the current state of the flip-flop, $Q$.\n\nThe LUT must be programmed to implement a specific Boolean function, $D = F(CE, T, Q)$, that makes the entire LE behave as a T-FF with synchronous enable. This means:\n1.  When $CE$ is low (0), the flip-flop must hold its current state $Q$ on the next active clock edge.\n2.  When $CE$ is high (1), the flip-flop must behave as a standard T-FF on the next active clock edge (i.e., hold its state if $T=0$ and toggle its state if $T=1$).\n\nWhich of the following Boolean expressions for $D$ correctly implement this functionality? Select all that apply. In the options below, $\\land$ denotes the logical AND operation, $\\lor$ denotes the logical OR operation, $\\neg$ denotes the logical NOT operation, and $\\oplus$ denotes the logical XOR operation.\n\nA. $D = (CE \\land (T \\oplus Q)) \\lor (\\neg CE \\land Q)$\n\nB. $D = (CE \\land T) \\oplus Q$\n\nC. $D = CE \\land (T \\oplus Q)$\n\nD. $D = (\\neg CE \\land Q) \\lor (CE \\land T)$\n\nE. $D = \\neg ( (\\neg CE \\land Q) \\lor (CE \\land (T \\oplus Q)) )$", "solution": "Let $Q^{+}$ denote the next registered state, so the LUT must implement $D=Q^{+}$ as a function of $(CE,T,Q)$ with the required behavior:\n- If $CE=0$, then $Q^{+}=Q$ (hold).\n- If $CE=1$, then $Q^{+}=Q \\oplus T$ (T flip-flop behavior).\n\nThis conditional behavior can be written as the Boolean multiplexer form\n$$\nD \\;=\\; (\\neg CE \\land Q)\\; \\lor\\; \\big(CE \\land (Q \\oplus T)\\big).\n$$\nThis matches option A exactly, so A is correct.\n\nNow show that option B implements the same function. Consider\n$$\nD \\;=\\; (CE \\land T) \\oplus Q.\n$$\nBy case analysis on $CE$:\n- If $CE=0$, then $D=(0 \\land T)\\oplus Q=0\\oplus Q=Q$, which matches the required hold.\n- If $CE=1$, then $D=(1 \\land T)\\oplus Q=T\\oplus Q=Q\\oplus T$, which matches the required T-FF behavior.\nHence B is correct.\n\nFor completeness, we can also prove algebraic equivalence between A and B. Starting from A:\n$$\nD \\;=\\; CE\\land(Q \\oplus T)\\; \\lor\\; \\neg CE \\land Q\n\\;=\\; CE\\big(\\neg Q \\land T \\;\\lor\\; Q \\land \\neg T\\big)\\; \\lor\\; \\neg CE \\land Q\n$$\n$$\n=\\; CE \\land \\neg Q \\land T \\;\\lor\\; CE \\land Q \\land \\neg T \\;\\lor\\; \\neg CE \\land Q\n$$\nGroup the terms containing $Q$:\n$$\n=\\; CE \\land \\neg Q \\land T \\;\\lor\\; Q\\big(CE \\land \\neg T \\;\\lor\\; \\neg CE\\big).\n$$\nUse $\\neg CE \\lor (CE \\land \\neg T) = (\\neg CE \\lor CE)\\land(\\neg CE \\lor \\neg T)=1\\land(\\neg CE \\lor \\neg T)=\\neg CE \\lor \\neg T$ to get\n$$\nD \\;=\\; CE \\land \\neg Q \\land T \\;\\lor\\; Q(\\neg CE \\lor \\neg T)\n\\;=\\; CE \\land T \\land \\neg Q \\;\\lor\\; \\neg CE \\land Q \\;\\lor\\; \\neg T \\land Q.\n$$\nRecognize this as the standard XOR form:\n$$\nD \\;=\\; \\big(\\neg(CE\\land T)\\land Q\\big) \\;\\lor\\; \\big(CE\\land T \\land \\neg Q\\big)\n\\;=\\; (CE\\land T)\\oplus Q,\n$$\nwhich is option B.\n\nNow test the remaining options against the required behavior:\n\nOption C: $D=CE \\land (T \\oplus Q)$. If $CE=0$, then $D=0$, which in general is not equal to $Q$; thus C is incorrect.\n\nOption D: $D=(\\neg CE \\land Q)\\lor(CE \\land T)$. If $CE=1$, then $D=T$, but the required behavior is $Q \\oplus T$. For example, with $Q=1$ and $T=0$, the required next state is $1$, but $D$ evaluates to $0$; thus D is incorrect.\n\nOption E: $D=\\neg\\big((\\neg CE \\land Q)\\lor(CE \\land (T \\oplus Q))\\big)$ is the logical negation of A, so it inverts the required behavior. For example, with $CE=0$ and $Q=1$, the required next state is $1$, but $D=\\neg(1)=0$; thus E is incorrect.\n\nTherefore, the correct options are A and B.", "answer": "$$\\boxed{\\text{AB}}$$", "id": "1938061"}]}