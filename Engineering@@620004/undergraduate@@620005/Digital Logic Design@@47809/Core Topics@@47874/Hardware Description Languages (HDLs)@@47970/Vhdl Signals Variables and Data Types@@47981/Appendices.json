{"hands_on_practices": [{"introduction": "In VHDL, strict type checking is a core feature that prevents many common design errors. However, it means you cannot directly perform arithmetic between different data types, such as adding an `integer` to a `std_logic_vector`. This foundational exercise [@problem_id:1976718] walks you through the essential skill of type casting, using the standard `ieee.numeric_std` library to correctly perform mixed-type arithmetic, a task you will encounter constantly in digital design.", "problem": "You are designing a simple digital signal processor in VHDL. A part of this processor needs to take an 8-bit unsigned sensor reading and add a fixed integer offset to it.\n\nConsider a VHDL entity defined as follows:\n```vhdl\nlibrary ieee;\nuse ieee.std_logic_1164.all;\nuse ieee.numeric_std.all;\n\nentity DataCalibrator is\n    port (\n        clk      : in  std_logic;\n        data_in  : in  std_logic_vector(7 downto 0);\n        data_out : out std_logic_vector(7 downto 0)\n    );\nend entity DataCalibrator;\n```\n\nWithin the architecture of `DataCalibrator`, a clocked process is required. This process must, on the rising edge of the `clk` signal, read the `data_in` vector, add the integer literal `17` to its value, and assign the 8-bit result to the `data_out` signal. The result should correctly handle overflow by wrapping around (e.g., if `data_in` is `250`, adding `17` should result in `11`, as `(250+17) mod 256 = 11`).\n\nWhich of the following code snippets correctly implements the required process?\n\nA.\n```vhdl\nprocess(clk)\nbegin\n    if rising_edge(clk) then\n        data_out <= std_logic_vector(to_unsigned(to_integer(unsigned(data_in)) + 17, 8));\n    end if;\nend process;\n```\n\nB.\n```vhdl\nprocess(clk)\nbegin\n    if rising_edge(clk) then\n        data_out <= data_in + 17;\n    end if;\nend process;\n```\n\nC.\n```vhdl\nprocess(clk)\nbegin\n    if rising_edge(clk) then\n        data_out <= data_in + \"00010001\";\n    end if;\nend process;\n```\n\nD.\n```vhdl\nprocess(clk)\nbegin\n    if rising_edge(clk) then\n        data_out <= conv_std_logic_vector(conv_integer(data_in) + 17, 8);\n    end if;\nend process;\n```", "solution": "The goal is to add an `integer` literal to a `std_logic_vector` signal and assign the `std_logic_vector` result to an output. VHDL is a strongly-typed language, meaning that operations can only be performed on compatible data types. The `+` operator is not defined by default for mixing `std_logic_vector` and `integer` types. Therefore, explicit type conversion is necessary. The problem specifies the use of the `ieee.numeric_std` library, which is the industry standard for such operations.\n\nLet's analyze the required steps for the conversion and calculation:\n1.  The input signal `data_in` is of type `std_logic_vector`. To perform arithmetic, it must be converted to a numeric type. The `numeric_std` library provides the `unsigned` type for this purpose. Since the sensor reading is stated to be unsigned, this is the correct choice. The `std_logic_vector` must first be cast to `unsigned`: `unsigned(data_in)`.\n2.  The addition involves an operand of type `integer` (the literal `17`). The `+` operator in `numeric_std` is defined for `unsigned` + `integer`, which returns an `unsigned` result. It is also defined for `integer` + `integer`. For clarity and robustness, it's common to convert the `unsigned` vector to an `integer` before the addition. The function `to_integer()` from `numeric_std` achieves this: `to_integer(unsigned(data_in))`.\n3.  Now the addition can be performed between two integers: `to_integer(unsigned(data_in)) + 17`. The result of this operation is an `integer`.\n4.  The output port `data_out` is an 8-bit `std_logic_vector`. The integer result from the addition must be converted back to this type. First, we convert the integer to an `unsigned` vector of the correct size (8 bits). The `to_unsigned()` function does this: `to_unsigned(integer_result, 8)`. This function correctly handles the wrap-around behavior (modulo arithmetic) required by the problem.\n5.  Finally, the `unsigned` vector is cast back to `std_logic_vector` to match the type of the output signal: `std_logic_vector(unsigned_result)`.\n\nCombining all these steps into a single line gives the expression:\n`data_out <= std_logic_vector(to_unsigned(to_integer(unsigned(data_in)) + 17, 8));`\n\nNow, let's evaluate the given options:\n\n**A.**\n```vhdl\nprocess(clk)\nbegin\n    if rising_edge(clk) then\n        data_out <= std_logic_vector(to_unsigned(to_integer(unsigned(data_in)) + 17, 8));\n    end if;\nend process;\n```\nThis option perfectly matches the derivation above. It correctly casts `data_in` to `unsigned`, converts it to `integer`, performs the addition, converts the integer result back to an 8-bit `unsigned` vector, and finally casts it to `std_logic_vector`. This is the correct implementation.\n\n**B.**\n```vhdl\nprocess(clk)\nbegin\n    if rising_edge(clk) then\n        data_out <= data_in + 17;\n    end if;\nend process;\n```\nThis option attempts to directly add a `std_logic_vector` and an `integer`. This will cause a type mismatch error during compilation because the `+` operator is not defined for these types in the standard libraries.\n\n**C.**\n```vhdl\nprocess(clk)\nbegin\n    if rising_edge(clk) then\n        data_out <= data_in + \"00010001\";\n    end if;\nend process;\n```\nThis option attempts to add two `std_logic_vector`s. The `+` operator is not defined for the `std_logic_vector` type in `ieee.std_logic_1164` or `ieee.numeric_std`. Arithmetic addition is defined for `unsigned` and `signed` types, but not directly for `std_logic_vector`. This will also result in a compilation error.\n\n**D.**\n```vhdl\nprocess(clk)\nbegin\n    if rising_edge(clk) then\n        data_out <= conv_std_logic_vector(conv_integer(data_in) + 17, 8);\n    end if;\nend process;\n```\nThis option uses the functions `conv_integer` and `conv_std_logic_vector`. These functions are not part of the standard `ieee.numeric_std` library. They belong to non-standard, vendor-specific, or deprecated libraries like `std_logic_arith` (from Synopsys). Using them is incorrect when the standard `ieee.numeric_std` is specified and is considered poor modern VHDL practice.\n\nTherefore, Option A is the only correct and standard-compliant solution.", "answer": "$$\\boxed{A}$$", "id": "1976718"}, {"introduction": "Understanding the fundamental difference between `signals` and `variables` is critical to mastering VHDL, especially their behavior in concurrent processes. This practice problem [@problem_id:1976697] presents a a hypothetical scenario involving a `shared variable` being updated by two processes simultaneously to illustrate the concept of a \"race condition\". By analyzing the potential outcomes, you will gain insight into the VHDL simulation model and understand why shared variables are a source of non-determinism and are typically avoided in synthesizable designs.", "problem": "An engineer is designing a digital system to count events detected by two independent, synchronized sensors. A VHDL model is created to simulate the behavior of the event counter. The design uses two concurrent processes, one for each sensor, which are intended to increment a shared counter on every rising edge of a common clock signal `clk`. The simulation is controlled by a third process that enables the counting for a fixed number of clock cycles, `N_CYCLES`, after an initial `reset`.\n\nConsider the following VHDL code snippet for the `race_condition_eval` entity.\n\n```vhdl\nlibrary ieee;\nuse ieee.std_logic_1164.all;\nuse ieee.numeric_std.all;\n\nentity race_condition_eval is\n    port (\n        clk   : in  std_logic;\n        reset : in  std_logic;\n        final_count : out integer\n    );\nend entity race_condition_eval;\n\narchitecture behavioral of race_condition_eval is\n    signal stop_sim : boolean := false;\n    shared variable event_counter : integer := 0;\n    \n    constant N_CYCLES : integer := 80;\n\nbegin\n\n    process_A: process(clk)\n    begin\n        if rising_edge(clk) then\n            if not stop_sim then\n                event_counter := event_counter + 1;\n            end if;\n        end if;\n    end process process_A;\n\n    process_B: process(clk)\n    begin\n        if rising_edge(clk) then\n            if not stop_sim then\n                event_counter := event_counter + 1;\n            end if;\n        end if;\n    end process process_B;\n\n    control_proc: process\n    begin\n        -- Wait for reset to be applied and then de-asserted\n        wait until reset = '1';\n        wait until reset = '0';\n        \n        event_counter := 0;\n        stop_sim <= false;\n        \n        for i in 1 to N_CYCLES loop\n            wait until rising_edge(clk);\n        end loop;\n        \n        stop_sim <= true;\n        \n        -- Allow one final delta cycle for processes to stop\n        wait for 0 ns; \n        \n        final_count <= event_counter;\n        \n        wait; -- Halt the control process\n    end process control_proc;\n\nend architecture behavioral;\n```\n\nAssume a VHDL simulator executes this code. Due to the properties of shared variables in concurrent processes, the final value of `event_counter`, reported on the `final_count` output port, is non-deterministic.\n\nDetermine the minimum possible value and the maximum possible value for `final_count` after the simulation completes. Calculate the sum of this minimum and maximum possible value.", "solution": "We analyze the execution per rising edge of the common clock. Both `process_A` and `process_B` are sensitive to `rising_edge(clk)` and, when `stop_sim` is false, each executes a read-modify-write on the shared variable: `event_counter := event_counter + 1`.\n\nIn VHDL, shared variable updates are immediate, but concurrent processes resume in an unspecified order within the same delta cycle. Therefore, on a given rising edge:\n- If both processes read the same old value $x$ before either writes, they each compute $x+1$ and then write $x+1$, resulting in a single net increment. \n- If one process completes its increment before the other reads, the second reads $x+1$ and writes $x+2$, resulting in two net increments.\n\nThus, for each enabled rising edge $k$, the net increment $m_{k}$ satisfies $m_{k} \\in \\{1,2\\}$ and no other outcomes are possible.\n\nThe control process performs:\n1) It waits for `reset` to assert and then de-assert, then executes `event_counter := 0` and `stop_sim <= false`. The assignment to `event_counter` ensures prior activity is cleared; the subsequent loop counts exactly the next `N_CYCLES` rising edges.\n2) It then waits for exactly `N_CYCLES` rising edges using a `for` loop that contains `wait until rising_edge(clk);`. During these `N_CYCLES` edges, `stop_sim` remains false as the assignment `stop_sim <= true` occurs only after the loop and takes effect on the next delta cycle, so both processes are enabled at each of these edges.\n3) After the loop, it executes `stop_sim <= true` and then `wait for 0 ns` to allow one delta cycle for the clocked processes to observe `stop_sim = true` and cease further increments before assigning `final_count <= event_counter`.\n\nLet $N := N_CYCLES$. Starting from `event_counter = 0` at the beginning of the counting window, after $N$ enabled rising edges the final shared variable value is\n$$\nevent\\_counter = \\sum_{k=1}^{N} m_{k}, \\quad \\text{with } m_{k} \\in \\{1,2\\}.\n$$\nTherefore, the minimum possible value is attained when every cycle loses one increment:\n$$\nevent\\_counter_{\\min} = \\sum_{k=1}^{N} 1 = N,\n$$\nand the maximum possible value is attained when both increments are preserved in every cycle:\n$$\nevent\\_counter_{\\max} = \\sum_{k=1}^{N} 2 = 2N.\n$$\nThe requested sum is\n$$\nevent\\_counter_{\\min} + event\\_counter_{\\max} = N + 2N = 3N.\n$$\nWith $N\\_CYCLES = 80$, we obtain\n$$\n3N = 3 \\times 80 = 240.\n$$", "answer": "$$\\boxed{240}$$", "id": "1976697"}, {"introduction": "Beyond simple bit vectors, VHDL's powerful type system allows for the creation of sophisticated data types that can elegantly model complex hardware behaviors. This advanced practice explores the concept of a resolved signal, where VHDL uses a special \"resolution function\" to determine the value of a wire driven by multiple sources [@problem_id:1976728]. By designing a custom logic type that implements an inherent priority scheme, you will learn how to model a multi-master bus that arbitrates access without needing a separate arbiter circuit, showcasing a truly powerful and abstract design technique.", "problem": "In digital systems design, a shared bus allows multiple components (masters) to communicate over a common set of wires. Managing access to this bus to prevent conflicts is crucial and is typically handled by an arbiter circuit. This problem explores a novel bus architecture that eliminates the need for an explicit arbiter by embedding the arbitration logic directly into the data type of the bus signals using features of the Very High-Speed Integrated Circuit Hardware Description Language (VHDL).\n\nConsider a custom VHDL logic type named `priority_logic`, defined as an enumerated type with the following possible values: `'U'` (Uninitialized), `'X'` (Unknown/Conflict), `'1'` (Logic High), `'0'` (Logic Low), and `'Z'` (High-Impedance).\n\nWhen multiple masters drive a single signal of this type simultaneously, a special resolution function determines the signal's final value. This function operates based on a strict priority scheme, where the value with the highest priority among all driving values \"wins\". The priority order is defined as:\n`'U' > 'X' > '1' > '0' > 'Z'`\n\nFor example, if three drivers attempt to place `'0'`, `'Z'`, and `'1'` on the line, the resolved value will be `'1'` because it has the highest priority of the three. If the drivers provide `'1'` and `'X'`, the resolved value will be `'X'`. If all drivers are `'Z'`, the line remains in the high-impedance state `'Z'`.\n\nNow, consider a 4-bit shared bus, `DATA_BUS`, where each bit is an independent signal of the resolved `priority_logic` type. This means each of the four bits is resolved independently according to the priority rule described above. Three masters, `M1`, `M2`, and `M3`, are connected to this bus. The system behaves according to the following sequence of events:\n\n1.  For all time `t < 10 ns`, the masters are driving the `DATA_BUS` with the following constant 4-bit values (from bit 3 down to bit 0):\n    *   `M1` drives `\"0Z1Z\"`\n    *   `M2` drives `\"ZZ01\"`\n    *   `M3` drives `\"ZZZZ\"`\n\n2.  At `t = 10 ns`, master `M3` changes its output and begins driving the value `\"X10X\"`.\n\n3.  At `t = 20 ns`, master `M1` changes its output and begins driving the value `\"Z110\"`.\n\nAssuming all signal changes are instantaneous, determine the 4-bit state of `DATA_BUS` at time `t = 25 ns`. Express your answer as a 4-character string representing the value of the bus from bit 3 down to bit 0.", "solution": "The bus uses a resolved type whose resolution function selects, for each bit independently, the highest-priority driven value according to the strict order $\\text{'U'}>\\text{'X'}>\\text{'1'}>\\text{'0'}>\\text{'Z'}$. Signal changes are instantaneous, so at $t=25\\,\\text{ns}$ the active drive values are those in effect after the last event at $t=20\\,\\text{ns}$. Thus the masters drive:\n- $M1$: \"Z110\" (changed at $t=20\\,\\text{ns}$),\n- $M2$: \"ZZ01\" (unchanged throughout),\n- $M3$: \"X10X\" (changed at $t=10\\,\\text{ns}$).\n\nResolve each bit from most significant (bit $3$) to least significant (bit $0$):\n- Bit $3$: $M1=\\text{'Z'}$, $M2=\\text{'Z'}$, $M3=\\text{'X'}$; the highest priority present is $\\text{'X'}$, so bit $3=\\text{'X'}$.\n- Bit $2$: $M1=\\text{'1'}$, $M2=\\text{'Z'}$, $M3=\\text{'1'}$; the highest priority present is $\\text{'1'}$, so bit $2=\\text{'1'}$.\n- Bit $1$: $M1=\\text{'1'}$, $M2=\\text{'0'}$, $M3=\\text{'0'}$; the highest priority present is $\\text{'1'}$, so bit $1=\\text{'1'}$.\n- Bit $0$: $M1=\\text{'0'}$, $M2=\\text{'1'}$, $M3=\\text{'X'}$; the highest priority present is $\\text{'X'}$, so bit $0=\\text{'X'}$.\n\nTherefore, the resolved 4-bit bus value at $t=25\\,\\text{ns}$ from bit $3$ to bit $0$ is \"X11X\".", "answer": "$$\\boxed{X11X}$$", "id": "1976728"}]}