{"hands_on_practices": [{"introduction": "Before building complex state machines, it is essential to master how VHDL processes can describe pure combinational logic. This practice [@problem_id:1976114] challenges you to implement a parity checker using a `for` loop, a common structure for iterative operations. Successfully solving this requires a deep understanding of the fundamental difference between `variable` and `signal` assignments within a process, a concept that is critical for writing efficient and correct hardware descriptions.", "problem": "In the context of Very High-Speed Integrated Circuit (VHSIC) Hardware Description Language (VHDL), you are tasked with designing a combinatorial logic circuit that computes the odd parity of a 16-bit data bus. The entity for this circuit is defined as follows:\n\n```vhdl\nLIBRARY ieee;\nUSE ieee.std_logic_1164.ALL;\n\nENTITY parity_checker IS\n    PORT (\n        data_in        : IN  STD_LOGIC_VECTOR(15 DOWNTO 0);\n        odd_parity_out : OUT STD_LOGIC\n    );\nEND ENTITY parity_checker;\n```\n\nThe output `odd_parity_out` should be '1' if the number of '1's in the input `data_in` is odd, and '0' otherwise. The implementation must use a sequential process containing a `FOR` loop to iterate through the bits of the input bus.\n\nBelow are five potential architectures for the `parity_checker`. Which of the following VHDL code snippets correctly and robustly implements the desired odd parity generator?\n\n**A.**\n```vhdl\nARCHITECTURE behavioral_A OF parity_checker IS\nBEGIN\n    process(data_in)\n        variable temp_parity : std_logic;\n    begin\n        temp_parity := '0';\n        for i in 0 to 15 loop\n            temp_parity := temp_parity xor data_in(i);\n        end loop;\n        odd_parity_out <= temp_parity;\n    end process;\nEND ARCHITECTURE behavioral_A;\n```\n\n**B.**\n```vhdl\nARCHITECTURE behavioral_B OF parity_checker IS\n    signal temp_parity : std_logic;\nBEGIN\n    process(data_in)\n    begin\n        temp_parity <= '0';\n        for i in 0 to 15 loop\n            temp_parity <= temp_parity xor data_in(i);\n        end loop;\n        odd_parity_out <= temp_parity;\n    end process;\nEND ARCHITECTURE behavioral_B;\n```\n\n**C.**\n```vhdl\nARCHITECTURE behavioral_C OF parity_checker IS\nBEGIN\n    process(data_in)\n        variable temp_parity : std_logic;\n    begin\n        for i in 0 to 15 loop\n            temp_parity := temp_parity xor data_in(i);\n        end loop;\n        odd_parity_out <= temp_parity;\n    end process;\nEND ARCHITECTURE behavioral_C;\n```\n\n**D.**\n```vhdl\nARCHITECTURE behavioral_D OF parity_checker IS\nBEGIN\n    process(data_in)\n        variable temp_parity : std_logic;\n    begin\n        temp_parity := '1';\n        for i in 0 to 15 loop\n            temp_parity := temp_parity xor data_in(i);\n        end loop;\n        odd_parity_out <= temp_parity;\n    end process;\nEND ARCHITECTURE behavioral_D;\n```\n\n**E.**\n```vhdl\nARCHITECTURE behavioral_E OF parity_checker IS\nBEGIN\n    process(data_in)\n        variable temp_parity : std_logic;\n    begin\n        temp_parity := '0';\n        for i in 0 to 15 loop\n            temp_parity := temp_parity xor data_in(i);\n            odd_parity_out <= temp_parity;\n        end loop;\n    end process;\nEND ARCHITECTURE behavioral_E;\n```", "solution": "We need a combinational odd-parity generator over a 16-bit vector. By definition, odd parity is the XOR reduction of all bits, starting from an initial neutral element '0'. In symbolic terms, the required output is\n$$\n\\text{odd\\_parity\\_out} = \\bigoplus_{i=0}^{15} \\text{data\\_in}(i),\n$$\nwhere XOR of an even number of '1's yields '0' and of an odd number yields '1'.\n\nIn VHDL, within a combinational process:\n- A variable updates immediately on assignment inside the process and therefore can be safely used to accumulate over a loop, provided it is initialized at the start of the process.\n- A signal assignment inside the process does not take effect until the process suspends; thus, reading that signal within the same process activation yields its old value. Using a signal as an accumulator in a loop will not work as intended.\n- Failing to initialize a variable used as an accumulator leads to an undefined ('U') value propagating through XOR operations.\n- Initializing the accumulator to '1' inverts the parity result (producing even parity instead of odd).\n- Assigning the output repeatedly inside the loop is functionally redundant and less robust style; although the last assignment will determine the final value after the process suspends, robust practice is to assign the output once after producing the final accumulated value.\n\nEvaluate each option:\n\nA. Uses a process sensitive to data_in, a variable accumulator initialized to '0', XORs all bits in a for loop, and assigns the result to the output after the loop. This matches\n$ \\text{temp\\_parity} := '0';\\quad \\text{temp\\_parity} := \\text{temp\\_parity} \\oplus \\text{data\\_in}(i)\\ \\forall i;\\quad \\text{odd\\_parity\\_out} \\leftarrow \\text{temp\\_parity} $,\nwhich implements the desired XOR reduction correctly and robustly. Correct.\n\nB. Uses a signal as an accumulator inside the process. Because signal reads return the old value during the process activation and updates are scheduled for after suspension, each loop iteration uses the same stale value, and the final scheduled value effectively depends only on the last iteration. This does not compute the XOR reduction. Incorrect.\n\nC. Uses a variable accumulator but does not initialize it. The initial value is 'U', and XOR with 'U' remains 'U' under std_logic_1164, so the result is undefined. Incorrect.\n\nD. Initializes the variable to '1' and then XORs all bits, which yields the logical complement of the desired odd parity:\n$$ '1' \\oplus \\bigoplus_{i=0}^{15} \\text{data\\_in}(i), $$\nwhich is the even parity indicator. Incorrect.\n\nE. Initializes the variable to '0', accumulates XOR in a loop, but assigns the output inside the loop on every iteration. While the final value after the process suspends will match the last assigned temp_parity (i.e., the correct parity), this practice is less robust and not idiomatic; robust combinational coding assigns outputs once after computing the final value to avoid potential maintenance hazards if loop bounds or conditions change. Compared to A, A is the clean, canonical, and robust implementation.\n\nTherefore, the correctly and robustly implemented architecture is A.", "answer": "$$\\boxed{A}$$", "id": "1976114"}, {"introduction": "Most digital systems are built around sequential circuits that change state on a clock edge. This exercise [@problem_id:1976148] guides you through the design of a versatile synchronous counter with parallel load and reset capabilities. The key skill you will practice is implementing a priority-based control structure using `if-elsif` statements, ensuring that critical operations like reset are always handled correctly before other actions.", "problem": "You are tasked with designing a digital counter component using VHSIC Hardware Description Language (VHDL). The component must function as an 8-bit synchronous up-counter with a synchronous parallel load and a synchronous reset.\n\nThe entity for this component is defined as follows:\n```vhdl\nENTITY counter_8bit IS\n  PORT (\n    CLK   : IN  STD_LOGIC;                      -- System Clock\n    RST   : IN  STD_LOGIC;                      -- Synchronous Reset, active-high\n    LOAD  : IN  STD_LOGIC;                      -- Synchronous Load Enable, active-high\n    D_IN  : IN  STD_LOGIC_VECTOR(7 DOWNTO 0);   -- 8-bit data input for parallel load\n    Q_OUT : OUT STD_LOGIC_VECTOR(7 DOWNTO 0)    -- 8-bit counter output\n  );\nEND ENTITY counter_8bit;\n```\n\nThe behavior of the counter must adhere to the following priority on the rising edge of the clock `CLK`:\n1.  **Reset:** If `RST` is high ('1'), the counter output `Q_OUT` must be set to all zeros (`\"00000000\"`).\n2.  **Load:** If `RST` is low ('0') and `LOAD` is high ('1'), the counter output `Q_OUT` must be loaded with the value from the parallel data input `D_IN`.\n3.  **Count:** If both `RST` and `LOAD` are low ('0'), the counter output `Q_OUT` must increment its current value by one.\n4.  **Hold:** If none of the active conditions are met, the counter should implicitly hold its value until the next rising clock edge.\n\nAll necessary libraries (`ieee.std_logic_1164.all` and `ieee.numeric_std.all`) are assumed to be included.\n\nWhich of the following VHDL architecture implementations correctly describes the specified behavior?\n\n**A.**\n```vhdl\nARCHITECTURE behavioral OF counter_8bit IS\nBEGIN\n  PROCESS(CLK)\n  BEGIN\n    IF rising_edge(CLK) THEN\n      IF LOAD = '1' THEN\n        Q_OUT <= D_IN;\n      ELSIF RST = '1' THEN\n        Q_OUT <= (OTHERS => '0');\n      ELSE\n        Q_OUT <= STD_LOGIC_VECTOR(UNSIGNED(Q_OUT) + 1);\n      END IF;\n    END IF;\n  END PROCESS;\nEND ARCHITECTURE behavioral;\n```\n\n**B.**\n```vhdl\nARCHITECTURE behavioral OF counter_8bit IS\nBEGIN\n  PROCESS(CLK)\n  BEGIN\n    IF rising_edge(CLK) THEN\n      IF RST = '1' THEN\n        Q_OUT <= (OTHERS => '0');\n      ELSIF LOAD = '1' THEN\n        Q_OUT <= D_IN;\n      ELSE\n        Q_OUT <= Q_OUT + 1;\n      END IF;\n    END IF;\n  END PROCESS;\nEND ARCHITECTURE behavioral;\n```\n\n**C.**\n```vhdl\nARCHITECTURE behavioral OF counter_8bit IS\nBEGIN\n  PROCESS(CLK)\n  BEGIN\n    IF rising_edge(CLK) THEN\n      IF RST = '1' THEN\n        Q_OUT <= (OTHERS => '0');\n      ELSIF LOAD = '1' THEN\n        Q_OUT <= D_IN;\n      ELSE\n        Q_OUT <= STD_LOGIC_VECTOR(UNSIGNED(Q_OUT) + 1);\n      END IF;\n    END IF;\n  END PROCESS;\nEND ARCHITECTURE behavioral;\n```\n\n**D.**\n```vhdl\nARCHITECTURE behavioral OF counter_8bit IS\nBEGIN\n  PROCESS(CLK, RST)\n  BEGIN\n    IF RST = '1' THEN\n      Q_OUT <= (OTHERS => '0');\n    ELSIF rising_edge(CLK) THEN\n      IF LOAD = '1' THEN\n        Q_OUT <= D_IN;\n      ELSE\n        Q_OUT <= STD_LOGIC_VECTOR(UNSIGNED(Q_OUT) + 1);\n      END IF;\n    END IF;\n  END PROCESS;\nEND ARCHITECTURE behavioral;\n```", "solution": "We formalize the required synchronous behavior on the rising edge of $CLK$ as a next-state function for the $8$-bit output vector $Q_{\\text{OUT}}$:\n$$\nQ^{+} =\n\\begin{cases}\n(0,0,0,0,0,0,0,0) & \\text{if } RST = '1', \\\\\nD_{\\text{IN}} & \\text{if } RST = '0' \\text{ and } LOAD = '1', \\\\\n\\text{STD\\_LOGIC\\_VECTOR}\\big(\\text{UNSIGNED}(Q_{\\text{OUT}}) + 1\\big) & \\text{if } RST = '0' \\text{ and } LOAD = '0'.\n\\end{cases}\n$$\nBetween rising edges, the register implicitly holds its value. The priority is $RST$ over $LOAD$, and both are synchronous, meaning they must be evaluated inside the $rising\\_edge(CLK)$ branch. The increment operation must use numeric\\_std types, i.e., convert $Q_{\\text{OUT}}$ to $\\text{UNSIGNED}$ for addition and cast back to $\\text{STD\\_LOGIC\\_VECTOR}$.\n\nEvaluate each option:\n\n- Option A checks $LOAD$ before $RST$ inside $rising\\_edge(CLK)$. If $RST = '1'$ and $LOAD = '1'$, it loads $D_{\\text{IN}}$ instead of resetting, violating the specified priority where $RST$ must dominate. Therefore A is incorrect.\n\n- Option B evaluates priority correctly ($RST$ then $LOAD$), but the count branch uses `$Q_{\\text{OUT}} \\leftarrow Q_{\\text{OUT}} + 1$` with $Q_{\\text{OUT}}$ of type $\\text{STD\\_LOGIC\\_VECTOR}$. Under $\\text{ieee.numeric\\_std.all}$, the operator $+$ is not defined for $\\text{STD\\_LOGIC\\_VECTOR}$; it requires $\\text{UNSIGNED}$ or $\\text{SIGNED}$. Hence this code is not valid as written and does not conform to the given library assumptions. Therefore B is incorrect.\n\n- Option C evaluates $RST$ first, then $LOAD$, matching the priority, and performs the increment as $\\text{STD\\_LOGIC\\_VECTOR}(\\text{UNSIGNED}(Q_{\\text{OUT}}) + 1)$, which is correct under $\\text{numeric\\_std}$. The process is sensitive only to $CLK$, so both reset and load are synchronous. Therefore C correctly implements the specified behavior.\n\n- Option D places $RST$ in the sensitivity list and applies it outside the $rising\\_edge(CLK)$ check, making the reset asynchronous. The requirement is a synchronous reset, so D is incorrect.\n\nThus, the only architecture that matches all specified requirements is Option C.", "answer": "$$\\boxed{C}$$", "id": "1976148"}, {"introduction": "Writing VHDL that works in simulation is only half the battle; the code must also synthesize into a functional physical circuit. This thought-provoking problem [@problem_id:1976132] presents a seemingly simple piece of code that contains a hazardous combinational loop. By analyzing its behavior, you will uncover the critical disconnect between event-driven simulation and hardware synthesis, a lesson that is indispensable for debugging and writing robust, real-world designs.", "problem": "An engineer is designing a simple fault detection module in a system using the VHSIC Hardware Description Language (VHDL). The module has an input `system_ok` which is '1' during normal operation and '0' when a fault is detected. The module has an output `alarm_active`. The design intent is that when a fault occurs (`system_ok` = '0'), the `alarm_active` signal should begin to toggle, presumably to flash a status light-emitting diode (LED). If the system returns to normal (`system_ok` = '1'), the alarm should be reset to '0'.\n\nThe engineer has written the following VHDL code. Analyze the `p_alarm_logic` process, specifically the behavior that occurs when the `system_ok` input is held at a constant value of '0'.\n\n```vhdl\nlibrary ieee;\nuse ieee.std_logic_1164.all;\n\nentity fault_detector is\n    port (\n        system_ok    : in  std_logic;\n        alarm_active : out std_logic\n    );\nend entity fault_detector;\n\narchitecture behavioral of fault_detector is\n    signal internal_alarm : std_logic := '0';\nbegin\n\n    -- Process to control the alarm state\n    p_alarm_logic : process(system_ok, internal_alarm)\n    begin\n        if system_ok = '1' then\n            internal_alarm <= '0';\n        else\n            -- When system is not okay, toggle the alarm\n            internal_alarm <= not internal_alarm;\n        end if;\n    end process p_alarm_logic;\n\n    -- Assign internal state to the output port\n    alarm_active <= internal_alarm;\n\nend architecture behavioral;\n```\n\nWhich of the following options most accurately describes the discrepancy between the behavior of this code in a standard event-driven VHDL simulator and the behavior of the physical circuit produced by a typical RTL synthesis tool when `system_ok` is held at '0'?\n\nA. **Simulation:** The signal `internal_alarm` will be stably latched to a value of '1'. **Synthesis:** A transparent latch is created that holds the value '1' as long as `system_ok` is '0'.\nB. **Simulation:** The simulator reports a stable state for `internal_alarm` after a single logic inversion from its previous value. **Synthesis:** A simple inverter is created whose input is tied to ground and whose output drives `alarm_active`.\nC. **Simulation:** The simulator is likely to halt and report an error due to exceeding an iteration limit in a zero-delay infinite loop. **Synthesis:** A free-running asynchronous oscillator is created.\nD. **Simulation:** The signal `internal_alarm` toggles its value exactly once per a predefined simulation time step (e.g., 1 ns). **Synthesis:** A T-type flip-flop is incorrectly inferred, which is then flagged as an error due to a missing clock signal.\nE. **Simulation:** The code simulates without error, showing `internal_alarm` toggling at a very high, simulator-dependent frequency. **Synthesis:** The code is considered fundamentally non-synthesizable and will be rejected by the synthesis tool with a fatal error.", "solution": "We analyze the process semantics and the synthesized hardware separately under the condition that the input is held at the constant value $system\\_ok = '0'$.\n\nFirst, express the process behavior symbolically. Let $s$ denote $system\\_ok$, $i$ denote the current value of $internal\\_alarm$, and $i^{+}$ denote the value of $internal\\_alarm$ scheduled by the process (the next value after the current delta cycle). The process implements the Boolean mapping\n$$\ni^{+} =\n\\begin{cases}\n0, & s = '1' \\\\\n\\lnot i, & s = '0'\n\\end{cases}\n$$\nand the process is sensitive to both $s$ and $i$.\n\nEvent-driven simulation behavior for $s = '0'$:\n1. With $s = '0'$ held constant, the process mapping reduces to $i^{+} = \\lnot i$.\n2. In VHDL signal assignment within a process with a sensitivity list is scheduled to take effect after the process suspends, i.e., on the next delta cycle at the same simulation time. Therefore, after the process computes $i^{+} = \\lnot i$, the simulator updates $i \\leftarrow i^{+}$ on the next delta cycle without advancing simulation time.\n3. Because the process sensitivity list includes $internal\\_alarm$, this update to $i$ is an event that immediately re-triggers the process in the same simulation time. The condition $s = '0'$ still holds, so the process computes $i^{+} = \\lnot i$ again.\n4. The result is an infinite sequence of delta cycles at the same simulation time with $i$ toggling each delta: $i \\mapsto \\lnot i \\mapsto \\lnot(\\lnot i) \\mapsto \\cdots$, which never converges in zero delay. Standard event-driven simulators detect this as a zero-delay non-convergent oscillation and terminate with an error such as an iteration limit exceeded or non-convergence at a given time.\n\nSynthesis and physical circuit behavior for $s = '0'$:\n1. RTL synthesis maps the process to combinational logic. The logic is equivalent to a 2-to-1 multiplexer whose select is $s$, output is $i^{+}$, data inputs are constant $0$ and $\\lnot i$, with $i$ fed back to form the $\\lnot i$ input:\n   - If $s = '1'$: the multiplexer selects constant $0$, so $i$ is driven to $0$.\n   - If $s = '0'$: the multiplexer selects $\\lnot i$, closing a combinational loop that enforces $i = \\lnot i$ through the propagation delay of the logic.\n2. In actual hardware, this combinational feedback with an odd inversion constitutes a ring oscillator. Due to real, nonzero gate and routing delays, the node $i$ will asynchronously oscillate at a frequency determined by the physical delays. Synthesis tools typically warn about a combinational loop but still produce a netlist that implements this feedback; it is not a latch or a clocked element and is not rejected solely for lacking a clock.\n\nComparing with the options, this matches option C precisely and contradicts the alternatives (no stable latch at '1', no single-time-step toggling, no T flip-flop inference, and not generally rejected as non-synthesizable).", "answer": "$$\\boxed{C}$$", "id": "1976132"}]}