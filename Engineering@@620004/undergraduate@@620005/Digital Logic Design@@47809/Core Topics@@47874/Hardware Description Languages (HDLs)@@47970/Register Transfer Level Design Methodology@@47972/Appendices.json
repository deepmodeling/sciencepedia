{"hands_on_practices": [{"introduction": "Every complex digital system is built upon a fundamental memory element: the register. Before we can design intricate processors or custom hardware, we must master how to control these registers reliably. This first practice [@problem_id:1957805] focuses on the essential control logic for a counter, challenging you to correctly model the interplay between a synchronous enable and an asynchronous reset, a cornerstone concept in stable digital design.", "problem": "A digital system requires a 16-bit up-counter. The counter is implemented as a register named `C`. The system has the following signals:\n\n*   `clk`: A system clock input.\n*   `reset`: An active-high, asynchronous reset input.\n*   `en`: An active-high, synchronous enable input.\n\nThe behavior of the counter is defined as follows:\n1.  At any time, if the `reset` signal is asserted (logic high), the counter `C` must be immediately and unconditionally cleared to 0.\n2.  If the `reset` signal is not asserted, then on each positive edge of the `clk` signal, the counter's behavior is determined by the `en` signal.\n3.  If `en` is asserted (logic high) at the positive clock edge, the counter `C` is incremented by 1.\n4.  If `en` is de-asserted (logic low) at the positive clock edge, the counter `C` holds its current value.\n\nYou are asked to select the correct Register Transfer Level (RTL) pseudo-code description that accurately models this behavior. The pseudo-code uses a syntax similar to the Verilog Hardware Description Language (HDL), where processes are triggered by a sensitivity list, and `=` denotes a non-blocking assignment for registers.\n\nWhich of the following RTL descriptions correctly implements the specified 16-bit counter?\n\nA.\n```\nalways @ (posedge clk or posedge reset)\nbegin\n  if (reset)\n    C = 0;\n  else if (en)\n    C = C + 1;\nend\n```\n\nB.\n```\nalways @ (posedge clk)\nbegin\n  if (reset)\n    C = 0;\n  else if (en)\n    C = C + 1;\nend\n```\n\nC.\n```\nalways @ (posedge clk)\nbegin\n  if (en)\n    C = C + 1;\n  else if (reset)\n    C = 0;\nend\n```\n\nD.\n```\nalways @ (posedge clk or posedge reset)\nbegin\n  if (en)\n    C = C + 1;\n  else if (reset)\n    C = 0;\nend\n```\n\nE.\n```\nalways @ (posedge clk or posedge reset)\nbegin\n  if (reset)\n    C = 0;\n  else if (en)\n    C = C + 1;\nend\n```", "solution": "The problem asks for the correct Register Transfer Level (RTL) description of a 16-bit counter with specific behaviors for reset, clock, and enable signals. To solve this, we must correctly interpret the distinction between asynchronous and synchronous events and standard RTL coding practices.\n\n1.  **Analyze the Asynchronous Reset Requirement:** The problem states that the `reset` is \"asynchronous\" and \"active-high\".\n    *   **Asynchronous:** This means the reset action (clearing the counter `C` to 0) must happen whenever the `reset` signal is high, regardless of the `clk` signal's state. In RTL processes like Verilog's `always` block, this is modeled by including the reset signal in the sensitivity list. Since the reset is active-high, the block should be sensitive to the rising edge (or positive level change) of the reset signal. Therefore, the sensitivity list must be `always @ (posedge clk or posedge reset)`.\n    *   **Unconditional Priority:** The reset is also \"unconditional\". This implies it has the highest priority. In an `if-else if-else` structure, the highest priority condition must be checked first. Thus, the `if (reset)` check must appear before any other logic within the `always` block.\n\n2.  **Analyze the Synchronous Behavior:** The increment and hold actions are \"synchronous\".\n    *   **Clock-Triggered:** These actions only occur on the positive edge of the clock. This logic must be conditioned on the clock event. The `always @ (posedge clk ...)` sensitivity list handles this.\n    *   **Conditional on Reset:** The synchronous logic should only execute when the system is *not* in a reset state. This means all synchronous logic must be placed in the `else` part of the primary `if (reset)` statement.\n    *   **Enable Logic:** Within the synchronous part, the counter increments (`C = C + 1`) only if `en` is high. If `en` is low, `C` holds its value. In RTL, a register holds its value if no new value is assigned to it under a given condition. Therefore, we only need to specify the logic for the increment: `if (en) C = C + 1;`. This will be placed inside the `else` block corresponding to `if (reset)`.\n\n3.  **Choose the Correct Assignment Operator:** For modeling sequential logic (registers, flip-flops, counters), the non-blocking assignment operator (`=`) is the standard convention. It schedules the value update to occur at the end of the current simulation time step, which accurately mimics the behavior of all flip-flops in a synchronous system capturing their new values simultaneously on the clock edge. The blocking assignment (`=`) can lead to race conditions and simulation results that do not match the synthesized hardware.\n\nWith these principles, let's evaluate the options:\n\n*   **A:** The sensitivity list is `(posedge clk or posedge reset)`, which correctly models an asynchronous reset triggered by a clock or a reset event. The logic `if (reset)` is checked first, giving it the highest priority. The synchronous logic `else if (en) C = C + 1;` is correctly placed and only executes on a clock edge when reset is inactive. It uses the non-blocking assignment (`=`). This option correctly implements all requirements.\n\n*   **B:** The sensitivity list is `(posedge clk)`. The block is only sensitive to the clock edge. Therefore, the `reset` signal would only be checked on a positive clock edge, making it a **synchronous** reset. This violates the \"asynchronous\" requirement.\n\n*   **C:** This is also a synchronous reset due to the sensitivity list `(posedge clk)`. Furthermore, the internal logic is flawed: it checks `if (en)` before `if (reset)`, giving the enable signal higher priority than the reset, which is incorrect.\n\n*   **D:** The sensitivity list `(posedge clk or posedge reset)` is correct for an asynchronous reset. However, the internal logic incorrectly checks `if (en)` before `if (reset)`. This would cause the counter to increment if both `en` and `reset` were high, which violates the requirement that the reset is unconditional.\n\n*   **E:** The sensitivity list and the logical structure are correct. However, it uses blocking assignments (`C = ...`). As explained earlier, this is the incorrect assignment type for modeling sequential logic in RTL and is considered a poor and often erroneous coding practice.\n\nBased on this analysis, Option A is the only one that correctly models all aspects of the specified counter.", "answer": "$$\\boxed{A}$$", "id": "1957805"}, {"introduction": "Digital systems excel at executing well-defined algorithms, a process often achieved by partitioning the design into a 'datapath' that holds and processes data, and a 'control unit' that directs the operations. In this exercise [@problem_id:1957789], you will trace the execution of a floating-point normalization algorithm, seeing firsthand how control signals orchestrate a sequence of register transfers over multiple clock cycles to achieve a computational goal. This problem illuminates the powerful synergy between a Finite State Machine (FSM) and the datapath it governs.", "problem": "A specialized digital circuit is designed to perform the normalization of an 8-bit unnormalized floating-point number. The circuit's datapath consists of two 8-bit registers: an exponent register `E` and a mantissa register `M`. The system is controlled by a synchronous finite state machine (FSM) that orchestrates the normalization process.\n\nThe datapath has the following components and control signals:\n- `E`, `M`: 8-bit registers.\n- `E_{in}`, `M_{in}`: 8-bit input buses.\n- `start`: A 1-bit input signal to begin the operation.\n- `done`: A 1-bit output signal, asserted high (`1`) when normalization is complete.\n- `E_{load}`: A control signal that, when asserted, loads `E` from `E_{in}` on the next rising clock edge.\n- `M_{load}`: A control signal that, when asserted, loads `M` from `M_{in}` on the next rising clock edge.\n- `E_{dec}`: A control signal that, when asserted, decrements `E` by one (`E \\leftarrow E - 1`) on the next rising clock edge.\n- `M_{shiftL}`: A control signal that, when asserted, performs a logical left shift on `M` (`M \\leftarrow M \\ll 1`, shifting in a `0`) on the next rising clock edge.\n\nThe FSM follows this operational sequence, with all state transitions and register updates occurring on the rising edge of a common clock:\n\n1.  **IDLE State**: The FSM is initially in an IDLE state. It remains here as long as the `start` signal is low (`0`). During this time, `done` is low.\n2.  **LOAD State**: Upon detecting `start = 1` at a rising clock edge, the FSM transitions to a LOAD state for one clock cycle. In this state, it asserts `E_{load}` and `M_{load}` to capture the input values.\n3.  **NORMALIZE State**: After the LOAD state, the FSM enters the NORMALIZE state. In each clock cycle within this state, it checks the most significant bit of the mantissa, `M[7]`.\n    - If `M[7] = 1` or if the entire mantissa is zero (`M = 00000000_2`), the number is considered normalized. The FSM transitions to the DONE state.\n    - If `M[7] = 0` and `M` is not zero, the FSM asserts the `E_{dec}` and `M_{shiftL}` signals and remains in the NORMALIZE state for the next cycle.\n4.  **DONE State**: In this state, the FSM asserts the `done` signal to `1` and holds the final values in `E` and `M`.\n\nAssume the system is powered on and is in the IDLE state. At the rising edge of clock cycle 1, the inputs are set to `E_{in} = 10110110_2` and `M_{in} = 00001101_2`, and the `start` signal is asserted high. The `start` signal is held high for only that single clock cycle.\n\nWhat are the final 8-bit binary values stored in registers `E` and `M`, respectively, at the end of the clock cycle when the `done` signal is first asserted high? Present your answer as a row matrix containing the two 8-bit binary strings for E and M.", "solution": "All state changes and register updates occur on rising clock edges, and register operations triggered by control signals asserted during a clock cycle take effect at the next rising edge. The FSM starts in IDLE with $done=0$.\n\nAt the rising edge of clock cycle $1$, $start=1$ is observed, so the FSM transitions into LOAD for the next cycle. During the LOAD cycle, it asserts $E_{load}=1$ and $M_{load}=1$, so that at the next rising edge the inputs are latched.\n\nAt the rising edge of clock cycle $2$, the LOAD controls take effect:\n$$E \\leftarrow E_{in} = 10110110,\\quad M \\leftarrow M_{in} = 00001101.$$\nThe FSM transitions to NORMALIZE. In each NORMALIZE cycle, it checks $M[7]$ and, if $M[7]=0$ and $M \\neq 0$, asserts $E_{dec}=1$ and $M_{shiftL}=1$ so that at the next rising edge $E \\leftarrow E-1$ and $M \\leftarrow M \\ll 1$; otherwise it transitions to DONE without asserting those controls.\n\nWe iterate until $M[7]=1$:\n- During the cycle after the rising edge $2$, $M=00001101$ has $M[7]=0$ and $M \\neq 0$, so at the rising edge $3$:\n$$E \\leftarrow 10110110 - 00000001 = 10110101,\\quad M \\leftarrow 00001101 \\ll 1 = 00011010.$$\n- During the cycle after the rising edge $3$, $M=00011010$ still has $M[7]=0$, so at the rising edge $4$:\n$$E \\leftarrow 10110101 - 00000001 = 10110100,\\quad M \\leftarrow 00011010 \\ll 1 = 00110100.$$\n- During the cycle after the rising edge $4$, $M=00110100$ still has $M[7]=0$, so at the rising edge $5$:\n$$E \\leftarrow 10110100 - 00000001 = 10110011,\\quad M \\leftarrow 00110100 \\ll 1 = 01101000.$$\n- During the cycle after the rising edge $5$, $M=01101000$ still has $M[7]=0$, so at the rising edge $6$:\n$$E \\leftarrow 10110011 - 00000001 = 10110010,\\quad M \\leftarrow 01101000 \\ll 1 = 11010000.$$\n\nDuring the cycle after the rising edge $6$, $M=11010000$ has $M[7]=1$, so the FSM asserts no further datapath controls and transitions to DONE at the next rising edge. At the rising edge $7$, the FSM enters DONE, $done$ is first asserted high, and the registers hold:\n$$E = 10110010,\\quad M = 11010000.$$\nIn DONE, the registers are held constant, so at the end of the clock cycle when $done$ is first high, the values remain $E=10110010$ and $M=11010000$.\n\nEquivalently, counting leading zeros in $M_{in}=00001101$ gives $4$ shifts required, so $M_{final}=M_{in} \\ll 4 = 11010000$ and $E_{final}=E_{in}-4=10110010$, consistent with the step-by-step timing above.\n\nTherefore, the final contents are the row matrix with $E$ and $M$ as $8$-bit binary strings.", "answer": "$$\\boxed{\\begin{pmatrix}10110010  11010000\\end{pmatrix}}$$", "id": "1957789"}, {"introduction": "While sequential logic is powerful for step-by-step tasks, many critical operations in a microprocessor must be performed as fast as possible. This practice [@problem_id:1957816] explores the design of a barrel shifter, a high-performance combinational circuit that shifts data by any number of bits in a single pass. By understanding its staged structure, you will grasp how complex logical functions can be efficiently implemented without sequential controllers, a key principle in designing fast datapaths.", "problem": "A crucial component in modern microprocessors is the barrel shifter, a combinational logic circuit that can shift a data word by a variable number of bits in a single clock cycle. Consider the design of a synchronous digital system that implements an 8-bit logical right barrel shifter.\n\nThe system has the following components:\n- `R_in`: An 8-bit input data register, with bits indexed from `R_in[7]` (Most Significant Bit, MSB) down to `R_in[0]` (Least Significant Bit, LSB).\n- `S_amt`: A 3-bit register holding the shift amount, with bits `S_amt[2]`, `S_amt[1]`, and `S_amt[0]`. The value of this register determines how many positions the data in `R_in` should be shifted to the right.\n- `R_out`: An 8-bit output register to store the final shifted result.\n\nThe shifting operation is a logical right shift, meaning that for each position shifted, a '0' is introduced at the MSB position, and the LSB is discarded. The shifter is implemented using a three-stage combinational logic design, where the output of one stage becomes the input to the next. The design uses two 8-bit intermediate storage locations, `R_1` and `R_2`, to hold the results between stages.\n\nThe operational flow is as follows:\n- Stage 1 takes `R_in` as its input and produces an intermediate result in `R_1`. This stage is controlled by `S_amt[2]`.\n- Stage 2 takes `R_1` as its input and produces an intermediate result in `R_2`. This stage is controlled by `S_amt[1]`.\n- Stage 3 takes `R_2` as its input and produces the final result in `R_out`. This stage is controlled by `S_amt[0]`.\n\nUsing the standard Register Transfer Level (RTL) notation provided below, identify the set of conditional statements that correctly describes the complete operation of this three-stage barrel shifter.\n\nRTL Notation Rules:\n- `A ← B`: The contents of `B` are transferred to register `A`.\n- `{A, B}`: Concatenation. The bit vector `A` is concatenated with the bit vector `B`. For example, if `A` is `10` and `B` is `11`, `{A, B}` is `1011`.\n- `R[i:j]`: A slice of register `R` from bit `i` down to bit `j` (inclusive).\n- `N'b...`: A constant binary value of `N` bits. For example, `4'b0000` is the 4-bit value `0000`.\n- `N{bit}`: The bit is replicated `N` times. For example, `4{R[7]}` means the bit `R[7]` is replicated 4 times.\n\nWhich of the following sets of RTL statements is correct?\n\nA.\nIf `S_amt[0]=1` then `R_1 ← {1'b0, R_in[7:1]}` else `R_1 ← R_in`\nIf `S_amt[1]=1` then `R_2 ← {2'b00, R_1[7:2]}` else `R_2 ← R_1`\nIf `S_amt[2]=1` then `R_out ← {4'b0000, R_2[7:4]}` else `R_out ← R_2`\n\nB.\nIf `S_amt[2]=1` then `R_1 ← {R_in[3:0], 4'b0000}` else `R_1 ← R_in`\nIf `S_amt[1]=1` then `R_2 ← {R_1[5:0], 2'b00}` else `R_2 ← R_1`\nIf `S_amt[0]=1` then `R_out ← {R_2[6:0], 1'b0}` else `R_out ← R_2`\n\nC.\nIf `S_amt[2]=1` then `R_1 ← {4'b0000, R_in[7:4]}` else `R_1 ← R_in`\nIf `S_amt[1]=1` then `R_2 ← {2'b00, R_1[7:2]}` else `R_2 ← R_1`\nIf `S_amt[0]=1` then `R_out ← {1'b0, R_2[7:1]}` else `R_out ← R_2`\n\nD.\nIf `S_amt[2]=1` then `R_1 ← {4'b0000, R_in[7:4]}` else `R_1 ← R_in`\nIf `S_amt[1]=1` then `R_2 ← {2'b00, R_in[7:2]}` else `R_2 ← R_in`\nIf `S_amt[0]=1` then `R_out ← {1'b0, R_in[7:1]}` else `R_out ← R_in`\n\nE.\nIf `S_amt[2]=1` then `R_1 ← {4{R_in[7]}, R_in[7:4]}` else `R_1 ← R_in`\nIf `S_amt[1]=1` then `R_2 ← {2{R_1[7]}, R_1[7:2]}` else `R_2 ← R_1`\nIf `S_amt[0]=1` then `R_out ← {1{R_2[7]}, R_2[7:1]}` else `R_out ← R_2`", "solution": "A logical right shift by a nonnegative integer $k$ on an 8-bit vector introduces $k$ zeros at the MSB side and drops the $k$ least significant bits. In RTL concatenation form, applying a right shift by $k$ to an input $X$ yields the vector {k zeros, $X[7:k]$}.\n\nA three-stage barrel shifter implements shifts by powers of two at each stage, controlled by individual bits of the shift amount. Specifically, with stages controlled by $S\\_amt[2]$, $S\\_amt[1]$, and $S\\_amt[0]$ in that order, the stages must implement conditional shifts of $4$, $2$, and $1$ bit(s), respectively, each stage passing through its input unchanged when its control bit is zero, and otherwise right-shifting by the stage’s amount:\n\n- Stage 1 (controlled by $S\\_amt[2]$) must, when $S\\_amt[2]=1$, perform a right shift by $4$ on $R\\_{in}$, which is expressed as R\\_1 ← {4'b0000, R\\_in[7:4]}; otherwise, R\\_1 ← R\\_{in}.\n- Stage 2 (controlled by $S\\_amt[1]$) must, when $S\\_amt[1]=1$, perform a right shift by $2$ on R\\_1, which is expressed as R\\_2 ← {2'b00, R\\_1[7:2]}; otherwise, R\\_2 ← R\\_1.\n- Stage 3 (controlled by $S\\_amt[0]$) must, when $S\\_amt[0]=1$, perform a right shift by $1$ on R\\_2, which is expressed as R\\_out ← {1'b0, R\\_2[7:1]}; otherwise, R\\_out ← R\\_2.\n\nThese three conditionals exactly match option C and satisfy both the logical-right semantics (zero-fill) and the prescribed stage ordering and dataflow (R\\_in → R\\_1 → R\\_2 → R\\_out).\n\nBy contrast:\n- Option A assigns the control bits to the wrong stages (reversing the intended mapping).\n- Option B performs left shifts (zeros appended at LSB side).\n- Option D incorrectly feeds each stage directly from R\\_in, breaking the cascaded composition for multi-bit shifts.\n- Option E uses sign-extension, which corresponds to arithmetic right shift, not logical right shift.\n\nTherefore, the correct set of RTL statements is option C.", "answer": "$$\\boxed{C}$$", "id": "1957816"}]}