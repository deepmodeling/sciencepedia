{"hands_on_practices": [{"introduction": "A Verilog module's port declaration is its contract with the outside world, defining how signals flow in and out. An incorrect port direction, such as labeling an output as an input, is a fundamental error that prevents a design from compiling correctly. This exercise [@problem_id:1975461] simulates a realistic debugging scenario, challenging you to identify a port direction error that creates a \"multiple driver\" conflict, a common issue faced by digital designers.", "problem": "A junior digital design engineer is tasked with debugging a simple 4-bit Arithmetic Logic Unit (ALU) implemented in Verilog. The module is intended to perform either addition or subtraction on two 4-bit inputs, `A` and `B`, based on a control signal `sub`. When `sub` is 0, it should compute `A + B`. When `sub` is 1, it should compute `A - B`. The results are a 4-bit sum/difference `S` and a single-bit carry-out/borrow-out `C_out`.\n\nDuring compilation, an error is reported, indicating that a net cannot be driven by more than one source. The engineer suspects an error in the module's port direction declarations. Identify the incorrect port declaration in the Verilog code provided below.\n\n```verilog\nmodule adder_subtractor(\n  input  [3:0] A, B,\n  input  sub,\n  input  [3:0] S,\n  output C_out\n);\n\n  // Perform addition or subtraction based on the 'sub' signal\n  assign {C_out, S} = sub ? (A - B) : (A + B);\n\nendmodule\n```\n\nWhich of the following lines contains the incorrect port declaration?\n\nA. `input  [3:0] A, B,`\n\nB. `input  sub,`\n\nC. `input  [3:0] S,`\n\nD. `output C_out`", "solution": "We analyze the port directions in relation to the continuous assignment statement.\n\n- In Verilog, an input port is driven from outside the module and must not be driven by internal assignments. A continuous assignment using the assign keyword drives the net on its left-hand side from within the module.\n- The line `assign {C_out, S} = sub ? (A - B) : (A + B);` drives both `C_out` and `S` internally because they appear on the left-hand side of the assignment.\n- Therefore, any signal on the left-hand side must be declared as an output (or `inout`), not as an input.\n- In the given declarations:\n  - `A` and `B` are used only as sources in the expression; declaring them as inputs is correct.\n  - `sub` is used only as a control input; declaring it as an input is correct.\n  - `C_out` appears on the left-hand side and is declared as `output`; this is correct.\n  - `S` appears on the left-hand side but is incorrectly declared as `input`. This causes a multiple-driver error because an input net would be driven both by the external environment and by the internal `assign` statement.\n\nHence, the incorrect port declaration is the line declaring `S` as `input`, which corresponds to option C.", "answer": "$$\\boxed{C}$$", "id": "1975461"}, {"introduction": "Complex digital systems are rarely built from scratch; they are assembled from smaller, reusable modules. This hierarchical approach, known as instantiation, is like building with digital LEGO blocks. This practice [@problem_id:1975499] focuses on using \"named port connections\" to instantiate a module, a robust method that enhances code readability and reduces connection errors by explicitly linking ports by name rather than by their order in the list.", "problem": "In a digital logic design project, you are tasked with creating a top-level module, named `eight_bit_alu_section`, which utilizes a pre-existing 4-bit adder component. The Verilog module declaration for this adder is provided as follows:\n\n```verilog\nmodule four_bit_adder (\n    input [3:0] a,\n    input [3:0] b,\n    input cin,\n    output reg [3:0] sum,\n    output reg cout\n);\n// Internal logic for the 4-bit adder is defined here.\n// You do not need to know the internal logic to solve this problem.\nendmodule\n```\n\nYour `eight_bit_alu_section` module must instantiate one instance of the `four_bit_adder`. The Arithmetic Logic Unit (ALU) section has its own set of ports, which must be connected to the adder instance. The module definition for your design is:\n\n```verilog\nmodule eight_bit_alu_section (\n    input [3:0] operand_X,\n    input [3:0] operand_Y,\n    input initial_carry,\n    output [3:0] result_bus,\n    output final_carry\n);\n// You must place the instantiation code here.\nendmodule\n```\n\nYour task is to instantiate the `four_bit_adder` module within the `eight_bit_alu_section` module. The instance name must be `U1_adder`. The instantiation must use **named port connections** exclusively.\n\nWhich of the following code snippets correctly performs this instantiation?\n\nA.\n```verilog\nfour_bit_adder U1_adder (\n    operand_X,\n    operand_Y,\n    initial_carry,\n    result_bus,\n    final_carry\n);\n```\n\nB.\n```verilog\nfour_bit_adder U1_adder (\n    .operand_X(a),\n    .operand_Y(b),\n    .initial_carry(cin),\n    .result_bus(sum),\n    .final_carry(cout)\n);\n```\n\nC.\n```verilog\nfour_bit_adder U1_adder (\n    .cout(final_carry),\n    .sum(result_bus),\n    .cin(initial_carry),\n    .b(operand_Y),\n    .a(operand_X)\n);\n```\n\nD.\n```verilog\nfour_bit_adder U1_adder (\n    .a(operand_X),\n    .b(operand_Y),\n    .cin(initial_carry),\n    .sum(result_bus)\n);\n```", "solution": "We are given a pre-defined module `four_bit_adder` with formal port names `a`, `b`, `cin`, `sum`, and `cout`. We must instantiate it inside `eight_bit_alu_section` using named port connections, with instance name `U1_adder`, and connect the ALU section’s ports to the adder’s ports as follows:\n- The adder input `a` must connect to `operand_X`.\n- The adder input `b` must connect to `operand_Y`.\n- The adder input `cin` must connect to `initial_carry`.\n- The adder output `sum` must connect to `result_bus`.\n- The adder output `cout` must connect to `final_carry`.\n\nIn Verilog named port association, the left-hand side of each connection is the formal port name of the instantiated module, and the right-hand side is the signal in the enclosing module. Order does not matter when using named connections, but all required ports should be connected to satisfy the intended design.\n\nEvaluate the options:\n- Option A uses positional connections rather than named connections, violating the requirement to use named port connections exclusively. Therefore, A is incorrect.\n- Option B uses named associations but incorrectly uses the enclosing module’s port names on the left-hand side (e.g., `.operand_X(a)`), which is invalid because the left-hand side must be the formal port names of `four_bit_adder` (`a`, `b`, `cin`, `sum`, `cout`). Additionally, the right-hand side identifiers like `a`, `b`, etc., are not defined in `eight_bit_alu_section`. Therefore, B is incorrect.\n- Option C uses named associations with the correct formal port names on the left-hand side and correctly maps them to the enclosing module’s signals: `.cout(final_carry)`, `.sum(result_bus)`, `.cin(initial_carry)`, `.b(operand_Y)`, `.a(operand_X)`. Order is irrelevant for named connections, and all ports are connected. Therefore, C is correct.\n- Option D omits the connection for `cout` (does not connect `final_carry`), leaving an essential output unconnected, which does not satisfy the requirement to connect the module’s ports to the adder instance. Therefore, D is incorrect.\n\nHence, the only correct instantiation is given in option C.", "answer": "$$\\boxed{C}$$", "id": "1975499"}, {"introduction": "As programming languages evolve, so do their syntax and rules. Modern Verilog (Verilog-2001 and later SystemVerilog) introduced the ANSI-style port declaration to make module headers more compact and readable. This practice [@problem_id:1975469] addresses a common pitfall associated with this style: the illegal redeclaration of a port inside the module body. Understanding this rule is essential for writing clean, error-free code using contemporary hardware description language standards.", "problem": "A digital design engineer is writing a simple Verilog module using the ANSI-style port declaration syntax introduced in Verilog-2001. The module, named `data_selector`, is intended to pass an input bus `data_a` to the output `data_out` when a selector signal `sel` is high, and pass `data_b` otherwise.\n\nConsider the following Verilog code for the `data_selector` module:\n\n```verilog\nmodule data_selector (\n    input             sel,\n    input      [15:0] data_a,\n    input      [15:0] data_b,\n    output logic [15:0] data_out\n);\n\n    wire [15:0] data_a; // Potentially problematic line\n\n    assign data_out = sel ? data_a : data_b;\n\nendmodule\n```\n\nWhen an attempt is made to compile this code, the compiler reports an error and fails. The error is specifically related to the line `wire [15:0] data_a;`. From the choices below, select the option that most accurately and fundamentally describes the rule violation in the Verilog language standard that causes this compilation error.\n\nA. An `input` port cannot be of type `wire`; it must be connected to an external signal.\n\nB. The identifier `data_a` is illegally used in a continuous assignment (`assign`) because it is declared as an internal `wire`.\n\nC. The identifier `data_a` is declared more than once within the same module scope.\n\nD. The port `data_b` is missing a required internal `wire` declaration.\n\nE. The use of an `output logic` type for `data_out` is incompatible with a continuous `assign` statement.", "solution": "In ANSI-style port declaration (introduced in Verilog-2001), declaring a port in the module header, such as `input [15:0] data_a`, also declares the identifier `data_a` within the module's scope. By default, an `input` is a net of type `wire`. Therefore, the line `wire [15:0] data_a;` inside the module body attempts to declare the same identifier a second time. Verilog prohibits redeclaring an identifier within the same scope, causing a compilation error. For this reason, option C is correct. Options A and B are incorrect as they describe standard, legal Verilog usage. Option D is incorrect because `data_b`, like `data_a`, is already declared in the port list. Option E is also incorrect because in SystemVerilog, a continuous `assign` can legally drive an `output logic` port. Therefore, the rule violation causing the compilation error is the multiple declarations of the identifier `data_a` in the same scope.", "answer": "$$\\boxed{C}$$", "id": "1975469"}]}