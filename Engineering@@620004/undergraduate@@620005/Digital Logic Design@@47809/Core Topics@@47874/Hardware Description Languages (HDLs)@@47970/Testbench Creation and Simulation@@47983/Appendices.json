{"hands_on_practices": [{"introduction": "Effective testbench design begins with a solid understanding of the logic values used in simulation. Beyond the binary $0$ and $1$, hardware description languages use $X$ for an unknown state and $Z$ for high-impedance to accurately model physical circuits. This fundamental exercise [@problem_id:1966489] challenges you to predict the output of a simple OR gate when one of its inputs is in a high-impedance state, revealing how simulators resolve ambiguity and propagate non-binary values.", "problem": "In the context of digital logic simulation, you are tasked with writing a testbench for a primitive 3-input OR gate. The gate has three inputs, designated `A`, `B`, and `C`, and a single output, `Y`. During a specific test case in your simulation, the inputs are driven with the following values: input `A` is set to logic `0`, input `B` is also set to logic `0`, and input `C` is intentionally not driven, placing it in a high-impedance state, which is represented by the value `'Z'`.\n\nAssuming the simulation environment adheres to the standard four-value logic system (`0` for logic low, `1` for logic high, `Z` for high-impedance, and `X` for an unknown or unresolved state), what is the expected logic value observed at the output `Y`?\n\nA: `0` (Logic Low)\n\nB: `1` (Logic High)\n\nC: `Z` (High-Impedance)\n\nD: `X` (Unknown)", "solution": "We evaluate a 3-input OR gate under four-valued logic. Let $A,B,C \\in \\{0,1,Z,X\\}$ and $Y=A \\lor B \\lor C$. The standard evaluation rules for a primitive OR gate in four-valued logic are:\n- If any input equals $1$, then $Y=1$ (the controlling value dominates).\n- Else, if all inputs equal $0$, then $Y=0$.\n- Else, if there is at least one input in $\\{X,Z\\}$ and no input equals $1$, then the output cannot be resolved and $Y=X$.\n- A primitive logic gate output is driven and therefore cannot be $Z$; only tri-state primitives can produce $Z$.\n\nGiven the test case $A=0$, $B=0$, $C=Z$, compute:\n$$\nY \\;=\\; A \\lor B \\lor C \\;=\\; 0 \\lor 0 \\lor Z \\;=\\; 0 \\lor Z.\n$$\nSince $Z$ denotes a high-impedance input that could correspond to either logical $0$ or $1$, and there is no controlling $1$ present to force the OR result, the outcome is unresolved:\n$$\n0 \\lor Z \\;=\\; X.\n$$\nTherefore, the expected output is the unknown state, corresponding to option D.", "answer": "$$\\boxed{D}$$", "id": "1966489"}, {"introduction": "Verifying sequential elements like registers requires testing every possible behavior, including loading data, holding data, and resetting. A common pitfall for new designers is creating a testbench that fails to cover all these cases, leaving potential bugs hidden. This practice [@problem_id:1966472] puts you in the role of a verification engineer, tasking you with analyzing an existing testbench for a synchronous register to identify which critical functionality it fails to test.", "problem": "An engineer is designing a testbench for a 4-bit synchronous register. The register, which is the Device Under Test (DUT), has the following characteristics:\n- It has a 4-bit data input `d_in`, a 4-bit data output `q_out`, a clock input `clk`, an active-low synchronous reset input `rst_n`, and a parallel load enable input `load_en`.\n- On the positive edge of the clock `clk`:\n    1. If `rst_n` is logic `0`, the output `q_out` is reset to `4'b0000`.\n    2. If `rst_n` is logic `1` and `load_en` is logic `1`, the output `q_out` takes the value of the input `d_in`.\n    3. If `rst_n` is logic `1` and `load_en` is logic `0`, the output `q_out` retains its current value.\n\nThe engineer has written the following Verilog testbench code to verify the register's functionality. Analyze the testbench and determine which specific behavior of the register is **not** verified by this simulation sequence.\n\n```verilog\n// DUT module (provided for context, not to be modified)\nmodule register_4bit (\n    input clk,\n    input rst_n,\n    input load_en,\n    input [3:0] d_in,\n    output reg [3:0] q_out\n);\n    always @(posedge clk) begin\n        if (!rst_n) begin\n            q_out <= 4'b0000;\n        end else if (load_en) begin\n            q_out <= d_in;\n        end\n    end\nendmodule\n\n// Testbench module\nmodule tb_register_4bit;\n    // Signal declarations\n    reg clk;\n    reg rst_n;\n    reg load_en;\n    reg [3:0] d_in;\n    wire [3:0] q_out;\n\n    // Instantiate the DUT\n    register_4bit dut (\n        .clk(clk),\n        .rst_n(rst_n),\n        .load_en(load_en),\n        .d_in(d_in),\n        .q_out(q_out)\n    );\n\n    // Clock generation\n    initial begin\n        clk = 0;\n        forever #5 clk = ~clk; // 10-unit period clock\n    end\n\n    // Test sequence\n    initial begin\n        // Initial state\n        rst_n = 1;\n        load_en = 0;\n        d_in = 4'b0000;\n\n        // Apply reset\n        #10;\n        rst_n = 0;\n\n        // Release reset\n        #10;\n        rst_n = 1;\n\n        // Load first value\n        #10;\n        load_en = 1;\n        d_in = 4'b1010;\n\n        // Load second value\n        #10;\n        d_in = 4'b0101;\n\n        // End simulation\n        #10;\n        $finish;\n    end\nendmodule\n```\n\nWhich of the following behaviors is **NOT** tested by the provided `tb_register_4bit` module?\n\nA. The register correctly resets to all zeros when the active-low reset is asserted.\n\nB. The register holds its previous value when the load enable signal is low.\n\nC. The register loads new data from the input on the rising edge of the clock when the load enable is high.\n\nD. Multiple consecutive data loads are performed correctly.", "solution": "Identify the relevant DUT behavior from the always block: on each positive edge of $clk$, if $rst\\_n=0$ then $q\\_out \\leftarrow 4'b0000$; else if $load\\_en=1$ then $q\\_out \\leftarrow d\\_in$; else there is no assignment to $q\\_out$, so the register holds its previous value. The testbench drives the following timeline with a clock of period $10$ units and positive edges at $t=5,15,25,35,45,\\dots$.\n\nAt $t=0$, the initial conditions are $clk=0$, $rst\\_n=1$, $load\\_en=0$, and $d\\_in=4'b0000$. The first positive edge occurs at $t=5$ with $rst\\_n=1$ and $load\\_en=0$, so by the DUT logic there is no assignment and the register holds its (unknown) power-up value.\n\nAt $t=10$, the testbench asserts reset: $rst\\_n \\leftarrow 0$. The next positive edge at $t=15$ satisfies $!rst\\_n=1$, so the DUT sets $q\\_out \\leftarrow 4'b0000$. This exercises the reset behavior, thereby testing option A.\n\nAt $t=20$, the testbench deasserts reset: $rst\\_n \\leftarrow 1$. The next positive edge at $t=25$ has $rst\\_n=1$ and $load\\_en=0$, so there is no assignment and the register holds its current value, which is $4'b0000$. Although this cycle is consistent with hold behavior, it does not demonstrate that the register resists new data changes when $load\\_en=0$ because $d\\_in$ has not been changed to create a potential difference between $d\\_in$ and $q\\_out$. Thus, there is no explicit verification that the register holds a nonzero or previously loaded value when $load\\_en=0$, and no test where $d\\_in$ changes under $load\\_en=0$.\n\nAt $t=30$, the testbench sets $load\\_en \\leftarrow 1$ and $d\\_in \\leftarrow 4'b1010$. The next positive edge at $t=35$ has $rst\\_n=1$ and $load\\_en=1$, so the DUT loads $q\\_out \\leftarrow 4'b1010$, verifying that new data is loaded on the rising edge when enabled, thereby testing option C.\n\nAt $t=40$, the testbench changes $d\\_in \\leftarrow 4'b0101$ while keeping $load\\_en=1$. The next positive edge at $t=45$ again has $rst\\_n=1$ and $load\\_en=1$, so the DUT loads $q\\_out \\leftarrow 4'b0101$. This demonstrates two consecutive loads on successive rising edges with $load\\_en$ held high, thereby testing option D.\n\nSummarizing which behaviors are truly exercised:\n- A is tested at $t=15$.\n- C is tested at $t=35$.\n- D is tested at $t=45$ following the load at $t=35$.\n- B is not explicitly tested, because after any nonzero or nonreset value is present, the testbench never sets $load\\_en=0$ and observes a clock edge while varying $d\\_in$ to confirm that $q\\_out$ holds. The only cycle with $load\\_en=0$ under $rst\\_n=1$ is at $t=25$, immediately after reset, where $q\\_out$ remains $4'b0000$ regardless, offering no distinct verification of the hold behavior for an arbitrary stored value.\n\nTherefore, the behavior not tested is that the register holds its previous value when $load\\_en$ is low.", "answer": "$$\\boxed{B}$$", "id": "1966472"}, {"introduction": "As digital systems grow in complexity, so must our verification strategies. Verifying components like a First-In, First-Out (FIFO) memory requires more than simple input vectors; it demands a stimulus that tests boundary conditions such as the `full` and `empty` states. This advanced practice [@problem_id:1966501] simulates a realistic scenario where you must trace the behavior of a FIFO under a sustained burst of read and write operations, sharpening your ability to track system state and analyze interactions over many clock cycles.", "problem": "A digital system includes a synchronous First-In, First-Out (FIFO) memory designed to buffer data. You are tasked with analyzing the behavior of this FIFO under a specific testbench stimulus protocol.\n\nThe FIFO has the following characteristics:\n- It has a fixed storage capacity, or depth, of $D = 32$ words.\n- It is controlled by a clock `clk`, a write enable signal `wr_en`, and a read enable signal `rd_en`.\n- It provides two status flags: `full` (asserted high when the FIFO contains $D$ words) and `empty` (asserted high when the FIFO contains 0 words).\n- All state updates for the FIFO and the testbench occur on the positive edge of `clk`.\n- The `full` and `empty` flags update combinatorially based on the FIFO's internal word count and are available for use within the same clock cycle that the count changes.\n- A write operation is successful if `wr_en` is high and the `full` flag is low at a positive clock edge. A successful write increments the FIFO's internal word count. If `wr_en` is high but `full` is also high, the write operation is ignored.\n- A read operation is successful if `rd_en` is high and the `empty` flag is low at a positive clock edge. A successful read decrements the FIFO's internal word count. If `rd_en` is high but `empty` is also high, the read operation is ignored.\n\nThe testbench operates a state machine that generates stimulus according to the following rules:\n- The system is reset at time $t=0$. At the first positive clock edge (cycle 1), the testbench enters the `WRITE_BURST` state.\n- The testbench uses a fixed sequence of integers, $L = [40, 35, 20, 50, 15]$, to determine the duration of each burst. The integers are consumed sequentially from the list.\n- In the `WRITE_BURST` state, the testbench consumes the next integer, $N_w$, from list $L$. It then asserts `wr_en` high and `rd_en` low for exactly $N_w$ consecutive clock cycles. After these $N_w$ cycles, it transitions to the `READ_BURST` state.\n- In the `READ_BURST` state, the testbench consumes the next integer, $N_r$, from list $L$. It then asserts `rd_en` high and `wr_en` low for exactly $N_r$ consecutive clock cycles. After these $N_r$ cycles, it transitions to the `WRITE_BURST` state.\n- The testbench logic does not check the `full` or `empty` flags to decide its own state transitions or signal assertions; it purely follows the cycle counts determined by the sequence $L$.\n\nCalculate the total number of data words successfully written into the FIFO after exactly 100 clock cycles have elapsed. The first clock cycle is cycle 1.", "solution": "Let the FIFO depth be $D=32$. Define $C(n)$ as the FIFO word count immediately after clock cycle $n$, and $W(n)$ as the cumulative number of successful writes up to and including cycle $n$. The initial conditions are\n$$\nC(0)=0,\\quad W(0)=0.\n$$\nUpdate rules at each positive edge:\n- If $wr\\_en=1$ and $C(n-1)<D$, then a write succeeds: $C(n)=C(n-1)+1$ and $W(n)=W(n-1)+1$. If $C(n-1)=D$, the write is ignored: $C(n)=D$ and $W(n)=W(n-1)$.\n- If $rd\\_en=1$ and $C(n-1)>0$, then a read succeeds: $C(n)=C(n-1)-1$. If $C(n-1)=0$, the read is ignored: $C(n)=0$. During read bursts $wr\\_en=0$, so $W(n)$ does not change.\n\nThe burst schedule over cycles $1$ to $100$ is determined by $L=[40,35,20,50,15]$:\n- Cycles $1$ to $40$: WRITE\\_BURST of length $40$.\n- Cycles $41$ to $75$: READ\\_BURST of length $35$.\n- Cycles $76$ to $95$: WRITE\\_BURST of length $20$.\n- Cycles $96$ to $100$: first $5$ cycles of the next READ\\_BURST.\n\nPhase 1 (cycles $1$ to $40$, writes only): Starting from $C(0)=0$, the number of successful writes is limited by $D$. Thus, in $40$ write-attempt cycles,\n$$\n\\text{writes}=\\min(40,D)=32,\\quad C(40)=32,\\quad W(40)=32.\n$$\nPhase 2 (cycles $41$ to $75$, reads only): Starting from $C(40)=32$, $32$ reads succeed over cycles $41$ to $72$, emptying the FIFO. Remaining cycles $73$ to $75$ are ignored. Therefore,\n$$\nC(75)=0,\\quad W(75)=W(40)=32.\n$$\nPhase 3 (cycles $76$ to $95$, writes only): From empty, all $20$ write attempts succeed since $20<D$,\n$$\n\\text{writes}=20,\\quad C(95)=20,\\quad W(95)=32+20=52.\n$$\nPhase 4 (cycles $96$ to $100$, reads only): No writes occur, so\n$$\nW(100)=W(95)=52.\n$$\nHence, the total number of data words successfully written into the FIFO after exactly $100$ clock cycles is $52$.", "answer": "$$\\boxed{52}$$", "id": "1966501"}]}