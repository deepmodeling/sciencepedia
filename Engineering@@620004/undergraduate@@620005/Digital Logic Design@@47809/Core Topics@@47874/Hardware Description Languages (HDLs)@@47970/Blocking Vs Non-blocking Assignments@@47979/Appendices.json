{"hands_on_practices": [{"introduction": "To master synchronous circuit design, understanding the parallel nature of non-blocking assignments (`<=`) is essential. This first exercise [@problem_id:1915845] provides a foundational scenario where multiple non-blocking assignments target the same register within a single clock cycle. By tracing the signal values, you will directly observe the core rule of Verilog simulation: all right-hand-side expressions are evaluated first, using the pre-clock-edge values, before any register is updated, which is the key to correctly modeling the behavior of flip-flops.", "problem": "In a digital circuit design specified using the Verilog Hardware Description Language (HDL), a 4-bit register named `vec` is declared as `reg [3:0] vec;`. At time `t = 0`, the register holds the initial value `4'b0010`. The logic for updating this register is implemented within a clocked process sensitive to the positive edge of a clock signal `clk`, as shown in the code snippet below:\n\n```verilog\nalways @(posedge clk) begin\n  vec[1:0] <= 2'b11;\n  vec[3:2] <= vec[1:0];\nend\n```\n\nAssuming the system starts with the given initial value and the first positive clock edge occurs at time `t_1 > 0`, determine the binary value of the register `vec` immediately after this first clock edge.\n\nA. `4'b0010`\nB. `4'b0011`\nC. `4'b1011`\nD. `4'b1111`", "solution": "We are given a 4-bit register with initial value vec = 0010, i.e., $vec[3:0] = (0,0,1,0)$, so $vec[1:0] = (1,0)$ and $vec[3:2] = (0,0)$ at $t=0$.\n\nOn the first positive edge of clk at time $t_{1}$, the process executes two non-blocking assignments. The semantics of non-blocking assignments (`<=`) are:\n- All right-hand sides are evaluated using the pre-edge (old) values.\n- All left-hand sides are updated concurrently after the evaluations are complete.\n\nThus, at the posedge:\n1) The right-hand side of the first assignment is a constant, so it schedules $vec[1:0] \\gets (1,1)$.\n2) The right-hand side of the second assignment is the old value of $vec[1:0]$, which is $(1,0)$, so it schedules $vec[3:2] \\gets (1,0)$.\n\nAfter both scheduled updates take effect concurrently, the new register value is $vec[3:0] = (1,0,1,1)$, which is the binary value 1011, i.e., option C.", "answer": "$$\\boxed{C}$$", "id": "1915845"}, {"introduction": "In contrast to sequential logic, combinational circuits must produce outputs that change immediately in response to their inputs. This practice [@problem_id:1915902] challenges you to identify the correct implementation of a priority encoder, a classic combinational component, from several common but flawed attempts. The key takeaway is understanding why blocking assignments (`=`) are the standard for level-sensitive `always @(*)` blocks, as they model a cascading chain of logic gates and prevent the inference of unwanted latches.", "problem": "A junior digital design engineer is tasked with creating a 4-to-2 priority encoder in Verilog. The encoder has a 4-bit data input `d[3:0]`, a 2-bit encoded output `y[1:0]`, and a 1-bit valid output `v`. The circuit should function as follows:\n\n-   The output `y` should represent the binary index of the most significant bit (MSB) that is high in the input `d`. The priority is from MSB to LSB, meaning `d[3]` has the highest priority and `d[0]` has the lowest.\n-   If `d[3]` is high, `y` should be `2'b11`.\n-   If `d[3]` is low but `d[2]` is high, `y` should be `2'b10`.\n-   If `d[3]` and `d[2]` are low but `d[1]` is high, `y` should be `2'b01`.\n-   If `d[3]`, `d[2]`, and `d[1]` are low but `d[0]` is high, `y` should be `2'b00`.\n-   The valid bit `v` should be high if at least one bit in `d` is high. If `d` is `4'b0000`, then `v` should be low and the value of `y` is irrelevant (don't care).\n\nThe engineer wrote an initial implementation using a single combinational `always @(*)` block. However, during simulation, the outputs `y` and `v` do not update correctly within the same simulation time step as the input `d`, leading to functional failures when integrated into a larger system.\n\nYour task is to identify the correct implementation from the options below that describes a purely combinational priority encoder and will reliably produce the correct outputs in simulation and synthesis.\n\nA.\n```verilog\nalways @(*) begin\n  if (d[0]) begin\n    y = 2'b00;\n    v = 1'b1;\n  end else if (d[1]) begin\n    y = 2'b01;\n    v = 1'b1;\n  end else if (d[2]) begin\n    y = 2'b10;\n    v = 1'b1;\n  end else if (d[3]) begin\n    y = 2'b11;\n    v = 1'b1;\n  end else begin\n    y = 2'b00; // a 'don't care' value\n    v = 1'b0;\n  end\nend\n```\n\nB.\n```verilog\nalways @(*) begin\n  if (d[3]) begin\n    y <= 2'b11;\n    v <= 1'b1;\n  end else if (d[2]) begin\n    y <= 2'b10;\n    v <= 1'b1;\n  end else if (d[1]) begin\n    y <= 2'b01;\n    v <= 1'b1;\n  end else if (d[0]) begin\n    y <= 2'b00;\n    v <= 1'b1;\n  end else begin\n    y <= 2'b00; // a 'don't care' value\n    v <= 1'b0;\n  end\nend\n```\n\nC.\n```verilog\nalways @(*) begin\n  if (d[3]) begin\n    y = 2'b11;\n    v = 1'b1;\n  end else if (d[2]) begin\n    y = 2'b10;\n    v = 1'b1;\n  end else if (d[1]) begin\n    y = 2'b01;\n    v = 1'b1;\n  end else if (d[0]) begin\n    y = 2'b00;\n    v = 1'b1;\n  end else begin\n    y = 2'b00; // a 'don't care' value\n    v = 1'b0;\n  end\nend\n```\n\nD.\n```verilog\nalways @(*) begin\n  casex (d)\n    4'b1xxx: y = 2'b11;\n    4'b01xx: y = 2'b10;\n    4'b001x: y = 2'b01;\n    4'b0001: y = 2'b00;\n    default: y = 2'b00; // a 'don't care' value\n  endcase\n  \n  if (d != 4'b0) begin\n    v = 1'b1;\n  end else begin\n    v = 1'b0;\n  end\nend\n```\n\nE.\n```verilog\nalways @(*) begin\n  y = 2'b00; // Default assignment\n  v = 1'b0;  // Default assignment\n  if (d[3]) begin\n    y <= 2'b11;\n    v <= 1'b1;\n  end else if (d[2]) begin\n    y <= 2'b10;\n    v <= 1'b1;\n  end else if (d[1]) begin\n    y <= 2'b01;\n    v <= 1'b1;\n  end else if (d[0]) {v, y} <= {1'b1, 2'b00};\nend\n```", "solution": "We require a purely combinational priority encoder that:\n- Gives MSB-first priority: check $d[3]$, then $d[2]$, then $d[1]$, then $d[0]$.\n- Drives both outputs in all branches to avoid latches.\n- Uses blocking assignments in a combinational always block so that outputs reflect input changes within the same simulation time step (delta cycle). Using nonblocking assignments in combinational logic can defer updates, creating the very simulation issue described.\n\nEvaluate each option:\n\nA. This uses blocking assignments in a combinational block, but it checks from LSB to MSB. If multiple bits are high, it will incorrectly prioritize $d[0]$ over $d[3]$, violating the required MSB-first priority. Therefore, A is incorrect.\n\nB. This uses nonblocking assignments in a combinational always block. Nonblocking defers updates until the end of the time step, which can cause the outputs not to update as expected within the same simulation time step when integrated with other logic. This matches the reported failure mode, so B is not the correct fix.\n\nC. This uses blocking assignments in a combinational always block with the correct MSB-to-LSB priority ordering. All outputs are assigned in all branches, so no latches are inferred. This is the standard, reliable style for a combinational priority encoder in both simulation and synthesis.\n\nD. This uses casex for prioritization and a separate conditional for the valid bit. While combinational and synthesizable, casex can introduce simulation-synthesis mismatches and mask unknowns, and the separate valid computation using a four-state comparison can behave unexpectedly in the presence of unknowns. The problem asks for a reliably correct implementation; this style is generally discouraged compared to a straightforward if-else chain with blocking assignments.\n\nE. This mixes blocking (defaults) and nonblocking (conditional updates) assignments within the same combinational always block, which is a known bad practice leading to race conditions and the same simulation timing issues. Therefore, E is incorrect.\n\nHence, the correct implementation is C.", "answer": "$$\\boxed{C}$$", "id": "1915902"}, {"introduction": "One of the most common sources of bugs in HDL code is the improper mixing of blocking and non-blocking assignments within a single clocked `always` block. This final exercise [@problem_id:1915859] explores a seemingly simple but treacherous code snippet that falls into this trap. Analyzing this code will reveal how the interaction between the two assignment types creates subtle and often unintended timing delays, underscoring the critical importance of adhering to coding guidelines for predictable and synthesizable hardware.", "problem": "In digital logic design using Verilog, the distinction between blocking (`=`) and non-blocking (`<=`) assignments within a clocked procedural block is critical for describing the intended hardware. Consider the following Verilog module snippet:\n\n```verilog\nmodule mixed_assignments (\n  input  wire       clk,\n  input  wire       rst_n, // active-low asynchronous reset\n  input  wire       data_in,\n  output reg        data_out\n);\n\n  reg temp;\n\n  always @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n      temp <= 1'b0;\n      data_out <= 1'b0;\n    end else begin\n      temp <= data_in;\n      data_out = temp;\n    end\n  end\n\nendmodule\n```\n\nA sequence of events is applied to the inputs of this module. The clock signal `clk` has a period of 20 ns, with its rising edges occurring at `t = 10, 30, 50, 70, ...` ns. The reset signal `rst_n` is asserted (low) for `t < 5` ns and de-asserted (high) for `t \\ge 5` ns. The input `data_in` is held at 0, except for a single pulse where it is 1 for the duration $25 \\text{ ns} \\le t  45 \\text{ ns}$.\n\nWhat are the values of the output signal `data_out` at times `t = 40` ns, `t = 60` ns, and `t = 80` ns, respectively?\n\nA. 1, 0, 0\nB. 0, 1, 0\nC. 0, 0, 1\nD. 1, 1, 0\nE. 0, 0, 0", "solution": "To solve this problem, we must trace the values of the registers `temp` and `data_out` through several clock cycles, paying close attention to the rules of blocking (`=`) and non-blocking (`=`) assignments within the `always` block.\n\nThe `always` block is sensitive to the rising edge of `clk` and the falling edge of `rst_n`. The reset `rst_n` is de-asserted for all `t \\ge 5` ns, so for all relevant clock edges, the `else` block will execute.\n\nThe `else` block contains two statements:\n1. `temp = data_in;` (Non-blocking assignment)\n2. `data_out = temp;` (Blocking assignment)\n\nVerilog simulation proceeds in time steps. At a clock edge, the statements inside the `always` block are executed.\n- For a non-blocking assignment (`=`), the right-hand side (RHS) is evaluated, and the update to the left-hand side (LHS) is scheduled to occur at the end of the current simulation time step, after all blocking assignments are completed.\n- For a blocking assignment (`=`), the RHS is evaluated, and the LHS is updated immediately, blocking the execution of any subsequent statements until it is done.\n\nLet's trace the signals cycle by cycle.\nInitial State (due to reset for `t  5` ns):\nAt `t=0`, `rst_n` is low. The reset condition `if (!rst_n)` is met.\n`temp` is set to 0. `data_out` is set to 0. Both are non-blocking, so they take effect at the end of the reset event.\nState before the first clock edge at `t=10` ns: `temp = 0`, `data_out = 0`.\n\nInput `data_in` waveform analysis:\n- At `t=10` ns, `data_in = 0`.\n- At `t=30` ns, `data_in = 1` (since `25 \\le 30  45`).\n- At `t=50` ns, `data_in = 0` (since `t \\ge 45`).\n- At `t=70` ns, `data_in = 0`.\n\n**Cycle 1: `posedge clk` at `t = 10` ns**\n- The value of `data_in` is 0.\n- The value of `temp` at the beginning of this time step is 0.\n- `temp = data_in;`: The RHS `data_in` is 0. The assignment `temp = 0` is scheduled for the end of the time step.\n- `data_out = temp;`: The RHS `temp` is evaluated. Its current value is 0 (the value from before this clock edge). `data_out` is immediately updated to 0.\n- At the end of the time step, the scheduled non-blocking assignment completes: `temp` is updated to 0.\n- **State after `t=10` ns:** `temp = 0`, `data_out = 0`.\n\n**Cycle 2: `posedge clk` at `t = 30` ns**\n- The value of `data_in` is 1.\n- The value of `temp` at the beginning of this time step is 0.\n- `temp = data_in;`: The RHS `data_in` is 1. The assignment `temp = 1` is scheduled.\n- `data_out = temp;`: The RHS `temp` is evaluated. Its current value is 0. `data_out` is immediately updated to 0.\n- At the end of the time step, the scheduled assignment completes: `temp` is updated to 1.\n- **State after `t=30` ns:** `temp = 1`, `data_out = 0`.\n\n**Evaluation at `t = 40` ns:**\nThe value of `data_out` is determined by the last assignment, which occurred at `t=30` ns. At `t=40` ns, `data_out` is **0**.\n\n**Cycle 3: `posedge clk` at `t = 50` ns**\n- The value of `data_in` is 0.\n- The value of `temp` at the beginning of this time step is 1.\n- `temp = data_in;`: The RHS `data_in` is 0. The assignment `temp = 0` is scheduled.\n- `data_out = temp;`: The RHS `temp` is evaluated. Its current value is 1. `data_out` is immediately updated to 1.\n- At the end of the time step, the scheduled assignment completes: `temp` is updated to 0.\n- **State after `t=50` ns:** `temp = 0`, `data_out = 1`.\n\n**Evaluation at `t = 60` ns:**\nThe value of `data_out` is the one set at `t=50` ns. At `t=60` ns, `data_out` is **1**.\n\n**Cycle 4: `posedge clk` at `t = 70` ns**\n- The value of `data_in` is 0.\n- The value of `temp` at the beginning of this time step is 0.\n- `temp = data_in;`: The RHS `data_in` is 0. The assignment `temp = 0` is scheduled.\n- `data_out = temp;`: The RHS `temp` is evaluated. Its current value is 0. `data_out` is immediately updated to 0.\n- At the end of the time step, the scheduled assignment completes: `temp` is updated to 0.\n- **State after `t=70` ns:** `temp = 0`, `data_out = 0`.\n\n**Evaluation at `t = 80` ns:**\nThe value of `data_out` is the one set at `t=70` ns. At `t=80` ns, `data_out` is **0**.\n\nCombining the results, the values of `data_out` at `t = 40, 60, 80` ns are (0, 1, 0). This corresponds to option B.\n\nThe behavior can be summarized as follows: at each clock edge `N`, `data_out` takes the value that `temp` had at the beginning of the cycle. This `temp` value was set by `data_in` from the previous clock edge, `N-1`. This creates a two-stage pipeline where the first stage (`temp`) is read by the second stage (`data_out`) using a blocking assignment. The effective result is that `data_out` lags `data_in` by two clock cycles. Let's re-verify the analysis logically. `data_out(N) = temp(N,begin) = temp(N-1,end)`. However, `temp(N-1,end)` was not read out by `data_out` at cycle `N-1`. The `data_out` at cycle `N-1` read `temp(N-1,begin)`. So `data_out` gets the value of `temp` from one cycle ago, and `temp` gets the value of `data_in` from one cycle ago. This means `data_out(N) = temp(N-1) = data_in(N-2)`. A 2-cycle delay.\nLet's check the trace against a 2-cycle delay model. `out_N = in_{N-2}`.\n- `out(30) = in(-10) = 0`.\n- `out(50) = in(10) = 0`.\n- `out(70) = in(30) = 1`.\nThe sequence `(out(30), out(50), out(70))` would be `(0, 0, 1)`. This corresponds to option C.\n\nLet's re-examine the logic. The mistake is subtle.\nAt `posedge clk` cycle `N`:\n1. `temp = data_in(N)`: The value `data_in(N)` is sampled. `temp` will be updated to this value at end of the time step.\n2. `data_out = temp`: `data_out` is *immediately* updated with the value of `temp` that existed *at the beginning* of cycle `N`. This is `temp_at_begin(N)`.\n\nNow, what is `temp_at_begin(N)`? It's the value that `temp` held after the previous clock cycle, `N-1`, finished.\nAt cycle `N-1`, the assignment `temp = data_in(N-1)` occurred. This means at the end of cycle `N-1`, `temp` was updated to `data_in(N-1)`.\nSo, `temp_at_begin(N) = data_in(N-1)`.\n\nSubstituting this back into the expression for `data_out`:\n`data_out(N) = temp_at_begin(N) = data_in(N-1)`.\nThis is a one-cycle delay.\n\nLet's re-do the trace based on the one-cycle delay model `out_N = in_{N-1}`.\n- `in` vector at edges 10, 30, 50, 70: `(0, 1, 0, 0)`\n- `out` at edge `N` will be `in` at `N-1`.\n- `out(10) = in(t10) = 0`.\n- `out(30) = in(10) = 0`.\n- `out(50) = in(30) = 1`.\n- `out(70) = in(50) = 0`.\nThe sequence of `data_out` values set at the rising edges `10, 30, 50, 70` are `0, 0, 1, 0`.\n- At `t=40`, `data_out` holds the value set at `t=30`, which is 0.\n- At `t=60`, `data_out` holds the value set at `t=50`, which is 1.\n- At `t=80`, `data_out` holds the value set at `t=70`, which is 0.\nThe final sequence is (0, 1, 0). The trace was correct after all, but the logical reasoning was initially confused, which is the point of the problem.\n\nFinal values:\n- `data_out` at `t=40` ns is 0.\n- `data_out` at `t=60` ns is 1.\n- `data_out` at `t=80` ns is 0.\nThe sequence is (0, 1, 0).", "answer": "$$\\boxed{B}$$", "id": "1915859"}]}