{"hands_on_practices": [{"introduction": "Behavioral Verilog allows us to describe a circuit's function at a high level of abstraction. A common task is to implement purely combinational logic directly from a set of Boolean equations. This first practice explores this principle by building a (7,4) Hamming code generator, a fundamental circuit in data transmission and storage for error detection and correction [@problem_id:1912766]. By translating parity-check equations into Verilog, you will see how high-level descriptions map to efficient gate-level logic.", "problem": "You are tasked with designing a purely combinational (7,4) Hamming code generator circuit in Verilog. The circuit takes a 4-bit data word as input and produces a 7-bit codeword as output.\n\nThe input is a 4-bit vector named `data_in[3:0]`. These four bits correspond to the data portions of the Hamming code, which we will denote as $d_4, d_3, d_2, d_1$, according to the following mapping:\n- $d_4 = \\text{data\\_in}[3]$\n- $d_3 = \\text{data\\_in}[2]$\n- $d_2 = \\text{data\\_in}[1]$\n- $d_1 = \\text{data\\_in}[0]$\n\nThe circuit must calculate three even-parity bits, $p_4, p_2, p_1$, based on the following standard parity-check equations, where $\\oplus$ denotes the bitwise XOR operation:\n- $p_1 = d_1 \\oplus d_2 \\oplus d_4$\n- $p_2 = d_1 \\oplus d_3 \\oplus d_4$\n- $p_4 = d_2 \\oplus d_3 \\oplus d_4$\n\nThe final 7-bit output, `hamming_out[6:0]`, must be assembled by arranging the data bits and the calculated parity bits in specific positions as follows:\n- `hamming_out[6]` = $d_4$\n- `hamming_out[5]` = $d_3$\n- `hamming_out[4]` = $d_2$\n- `hamming_out[3]` = $p_4$\n- `hamming_out[2]` = $d_1$\n- `hamming_out[1]` = $p_2$\n- `hamming_out[0]` = $p_1$\n\nGiven these specifications, identify which of the following Verilog modules correctly implements the behavioral model for this Hamming code generator.\n\nA.\n```verilog\nmodule hamming_encoder(\n    input [3:0] data_in,\n    output reg [6:0] hamming_out\n);\n    always @* begin\n        // Parity bits\n        hamming_out[0] = data_in[0] ^ data_in[1] ^ data_in[3];\n        hamming_out[1] = data_in[0] ^ data_in[2] ^ data_in[3];\n        hamming_out[3] = data_in[1] ^ data_in[2] ^ data_in[3];\n        // Data bits\n        hamming_out[2] = data_in[0];\n        hamming_out[4] = data_in[1];\n        hamming_out[5] = data_in[2];\n        hamming_out[6] = data_in[3];\n    end\nendmodule\n```\n\nB.\n```verilog\nmodule hamming_encoder(\n    input [3:0] data_in,\n    output reg [6:0] hamming_out\n);\n    always @(data_in[1], data_in[2]) begin\n        hamming_out[0] = data_in[0] ^ data_in[1] ^ data_in[3];\n        hamming_out[1] = data_in[0] ^ data_in[2] ^ data_in[3];\n        hamming_out[3] = data_in[1] ^ data_in[2] ^ data_in[3];\n        hamming_out[2] = data_in[0];\n        hamming_out[4] = data_in[1];\n        hamming_out[5] = data_in[2];\n        hamming_out[6] = data_in[3];\n    end\nendmodule\n```\n\nC.\n```verilog\nmodule hamming_encoder(\n    input [3:0] data_in,\n    output reg [6:0] hamming_out\n);\n    always @* begin\n        hamming_out[0] = data_in[0] ^ data_in[1] ^ data_in[3];\n        hamming_out[1] = data_in[0] ^ data_in[2] ^ data_in[3];\n        hamming_out[3] = data_in[1] & data_in[2] & data_in[3];\n        hamming_out[2] = data_in[0];\n        hamming_out[4] = data_in[1];\n        hamming_out[5] = data_in[2];\n        hamming_out[6] = data_in[3];\n    end\nendmodule\n```\n\nD.\n```verilog\nmodule hamming_encoder(\n    input [3:0] data_in,\n    output [6:0] hamming_out\n);\n    always @* begin\n        hamming_out[0] = data_in[0] ^ data_in[1] ^ data_in[3];\n        hamming_out[1] = data_in[0] ^ data_in[2] ^ data_in[3];\n        hamming_out[3] = data_in[1] ^ data_in[2] ^ data_in[3];\n        hamming_out[2] = data_in[0];\n        hamming_out[4] = data_in[1];\n        hamming_out[5] = data_in[2];\n        hamming_out[6] = data_in[3];\n    end\nendmodule\n```\n\nE.\n```verilog\nmodule hamming_encoder(\n    input [3:0] data_in,\n    output reg [6:0] hamming_out\n);\n    always @* begin\n        // Incorrect mapping of data bits to output\n        hamming_out[0] = data_in[0] ^ data_in[1] ^ data_in[3];\n        hamming_out[1] = data_in[0] ^ data_in[2] ^ data_in[3];\n        hamming_out[3] = data_in[1] ^ data_in[2] ^ data_in[3];\n        hamming_out[2] = data_in[0];\n        hamming_out[4] = data_in[2]; // Wrong\n        hamming_out[5] = data_in[1]; // Wrong\n        hamming_out[6] = data_in[3];\n    end\nendmodule\n```", "solution": "We are given the data-to-symbol mapping $d_{4}=\\text{data\\_in}[3]$, $d_{3}=\\text{data\\_in}[2]$, $d_{2}=\\text{data\\_in}[1]$, $d_{1}=\\text{data\\_in}[0]$ and the even-parity equations\n$$\np_{1}=d_{1}\\oplus d_{2}\\oplus d_{4},\\quad\np_{2}=d_{1}\\oplus d_{3}\\oplus d_{4},\\quad\np_{4}=d_{2}\\oplus d_{3}\\oplus d_{4}.\n$$\nIn terms of `data_in` indexing, these become\n$$\np_{1}=\\text{data\\_in}[0]\\oplus \\text{data\\_in}[1]\\oplus \\text{data\\_in}[3],\\quad\np_{2}=\\text{data\\_in}[0]\\oplus \\text{data\\_in}[2]\\oplus \\text{data\\_in}[3],\\quad\np_{4}=\\text{data\\_in}[1]\\oplus \\text{data\\_in}[2]\\oplus \\text{data\\_in}[3].\n$$\nThe required output mapping is\n$$\n\\text{hamming\\_out}[6]=d_{4}=\\text{data\\_in}[3],\\;\n\\text{hamming\\_out}[5]=d_{3}=\\text{data\\_in}[2],\\;\n\\text{hamming\\_out}[4]=d_{2}=\\text{data\\_in}[1],\\;\n\\text{hamming\\_out}[3]=p_{4},\\;\n\\text{hamming\\_out}[2]=d_{1}=\\text{data\\_in}[0],\\;\n\\text{hamming\\_out}[1]=p_{2},\\;\n\\text{hamming\\_out}[0]=p_{1}.\n$$\nNow check each option:\n\n- Option A uses `always @*` (combinational), computes $p_{1}$, $p_{2}$, $p_{4}$ exactly as above with the XOR operator, and assigns data bits to indices $[2],[4],[5],[6]$ exactly as required. This matches both the parity equations and the bit placement, and is purely combinational. Therefore A is correct.\n\n- Option B uses an incomplete sensitivity list `always @(data_in[1], data_in[2])`. This omits `data_in[0]` and `data_in[3]`, so it does not model a correct purely combinational behavior in simulation, even though the assignments themselves match the equations. Therefore B is not correct as a behavioral model.\n\n- Option C incorrectly computes $p_{4}$ using the bitwise AND operator instead of XOR. Therefore C is incorrect.\n\n- Option D declares the output as a `wire` (implicit) but assigns it within an `always` block, which requires a `reg` type in Verilog. This is not a correct Verilog behavioral description. Therefore D is incorrect.\n\n- Option E swaps `hamming_out[4]` and `hamming_out[5]` for the data bits, contradicting the required mapping. Therefore E is incorrect.\n\nHence the only correct module is A.", "answer": "$$\\boxed{A}$$", "id": "1912766"}, {"introduction": "While `for` loops in software programming imply sequential execution, in hardware description languages they can be a powerful tool for generating highly parallel structures. This exercise demonstrates this key concept through the design of a parameterized barrel shifter, a circuit capable of shifting a data word by any amount in a fixed amount of time [@problem_id:1912762]. Analyzing this implementation will deepen your understanding of how synthesis tools interpret procedural code to create efficient, high-performance hardware.", "problem": "Consider the following parameterized Verilog module, `barrel_shifter`, which is intended to perform a left shift on an input data vector. The module uses a `for` loop within a combinational `always` block to describe its behavior. The width of the data bus, `N`, is a parameter, and the width of the `shift_amount` input is determined by the system function `$clog2(N)`, which computes the ceiling of the base-2 logarithm of `N`.\n\n```verilog\nmodule barrel_shifter #(parameter N = 8) (\n    input  [N-1:0] data_in,\n    input  [$clog2(N)-1:0] shift_amount,\n    output reg [N-1:0] data_out\n);\n\n    integer i;\n    // Array to hold intermediate values for each stage of the shift\n    reg [N-1:0] stage_out [0:$clog2(N)];\n\n    always @(*) begin\n        stage_out[0] = data_in;\n        for (i = 0; i < $clog2(N); i = i + 1) begin\n            if (shift_amount[i]) begin\n                stage_out[i+1] = stage_out[i] << (2**i);\n            end else begin\n                stage_out[i+1] = stage_out[i];\n            end\n        end\n        data_out = stage_out[$clog2(N)];\n    end\n\nendmodule\n```\n\nAn instance of this module is created with the parameter `N` set to 16. At a particular moment in time, the inputs to this instantiated module have the following steady-state values:\n- `data_in` = `16'b1011_0100_1110_1001`\n- `shift_amount` = `4'b1011`\n\nWhat is the resulting steady-state binary value of the output signal `data_out`?\n\nA. `16'b0000_0000_0000_0000`\nB. `16'b0000_0000_0001_0110`\nC. `16'b0100_1000_0000_0000`\nD. `16'b0010_0000_0000_0000`\nE. `16'b1110_1001_0000_0000`", "solution": "For parameter $N=16$, the shift network has $\\text{\\$clog2}(N)=4$ stages, indexed by $i=0,1,2,3$. The combinational loop implements a staged logical left shift where, at stage $i$, if `shift_amount[i]==1` the current value is shifted left by $2^{i}$. Therefore, the overall transformation is equivalent to a logical left shift by\n$$\ns=\\sum_{i=0}^{3} \\text{shift\\_amount}[i] \\cdot 2^{i}.\n$$\nGiven `shift_amount=4'b1011`, its bits by index are `shift_amount[3]=1`, `shift_amount[2]=0`, `shift_amount[1]=1`, `shift_amount[0]=1`, hence\n$$\ns=1\\cdot 2^{3}+0\\cdot 2^{2}+1\\cdot 2^{1}+1\\cdot 2^{0}=8+0+2+1=11.\n$$\nThus,\n$$\n\\text{data\\_out} = \\text{data\\_in} \\ll 11.\n$$\nA $16$-bit logical left shift by $11$ fills the lower $11$ bits with zeros and places the lower five bits of `data_in` into the upper five positions:\n$$\n\\text{data\\_out}[15:11]=\\text{data\\_in}[4:0], \\quad \\text{data\\_out}[10:0]=0.\n$$\nWith $\\text{data\\_in}=16\\text{'b}1011\\_0100\\_1110\\_1001$, we have $\\text{data\\_in}[4:0]=\\text{'b}01001$. Therefore,\n$$\n\\text{data\\_out} = 16\\text{'b}0100\\_1000\\_0000\\_0000,\n$$\nwhich corresponds to option C.", "answer": "$$\\boxed{C}$$", "id": "1912762"}, {"introduction": "Many digital systems must respond to events over time, requiring the use of sequential logic and memory. This final practice moves from combinational logic to the design of a stateful system by tackling the classic real-world problem of debouncing a mechanical push-button [@problem_id:1912819]. You will analyze a Finite State Machine (FSM) that uses a counter and state transitions to filter a noisy input, illustrating one of the most fundamental and practical design patterns in digital engineering.", "problem": "In digital systems, mechanical push-buttons and switches are common user inputs. However, they suffer from a physical phenomenon known as \"contact bounce\" or \"chatter,\" where a single press or release action generates a rapid series of noisy, invalid transitions between logic high and low before settling to a stable state. To use such a button as a reliable digital input, a \"debouncer\" circuit is required.\n\nYour task is to analyze Verilog implementations of a push-button debouncer. The debouncer should operate based on a Finite State Machine (FSM) and a counter. The specifications for the debouncer module are as follows:\n\n**Module Interface:**\n-   `clk`: System clock input.\n-   `reset_n`: Active-low asynchronous reset input.\n-   `button_in`: The noisy input from a push-button. It is normally high (logic 1) and goes low (logic 0) when pressed.\n-   `pulse_out`: The clean, debounced output.\n\n**Functional Behavior:**\n1.  The circuit should detect when the `button_in` signal is pressed (goes to 0).\n2.  After detection, it must wait to confirm that `button_in` remains stable at logic 0 for exactly 16 consecutive clock cycles.\n3.  If the signal is stable for the required duration, the module must generate a clean, single-cycle high pulse on `pulse_out`.\n4.  After the pulse is generated, the circuit must wait for the `button_in` to be released (return to 1) before it is ready to detect another press. This prevents multiple pulses if the button is held down for a long time.\n5.  If at any point during the 16-cycle stability check the `button_in` signal bounces back to 1, the check fails, the timer must be reset, and the circuit should return to its initial state.\n6.  The asynchronous `reset_n` signal, when asserted (low), must immediately return the FSM to its initial state, reset any counters, and ensure `pulse_out` is low.\n\n**FSM and Implementation Details:**\nThe FSM uses four states defined by parameters:\n`parameter IDLE = 2'b00, WAIT_STABLE = 2'b01, PULSE = 2'b10, WAIT_RELEASE = 2'b11;`\nIt also uses a parameter for the stability duration and a counter register:\n`parameter STABLE_CYCLES = 16;`\n`reg [3:0] counter;`\n\nYou are given four different Verilog code snippets, each claiming to implement the logic inside an `always @(posedge clk or negedge reset_n)` block for this debouncer. Only one of them correctly implements all the specified behaviors. Identify the correct implementation.\n\nA.\n```verilog\nalways @(posedge clk or negedge reset_n) begin\n    if (!reset_n) begin\n        state <= IDLE;\n        counter <= 4'd0;\n        pulse_out <= 1'b0;\n    end else begin\n        case (state)\n            IDLE: begin\n                pulse_out <= 1'b0;\n                if (!button_in) begin\n                    state <= WAIT_STABLE;\n                    counter <= 4'd0;\n                end\n            end\n            WAIT_STABLE: begin\n                pulse_out <= 1'b0;\n                if (!button_in) begin\n                    if (counter == STABLE_CYCLES - 1) begin\n                        state <= PULSE;\n                    end else begin\n                        counter <= counter + 1;\n                    end\n                end else begin\n                    state <= IDLE;\n                end\n            end\n            PULSE: begin\n                pulse_out <= 1'b1;\n                state <= WAIT_RELEASE;\n                counter <= 4'd0;\n            end\n            WAIT_RELEASE: begin\n                pulse_out <= 1'b0;\n                if (button_in) begin\n                    state <= IDLE;\n                end\n            end\n        endcase\n    end\nend\n```\n\nB.\n```verilog\nalways @(posedge clk or negedge reset_n) begin\n    if (!reset_n) begin\n        state <= IDLE;\n        counter <= 4'd0;\n        pulse_out <= 1'b0;\n    end else begin\n        case (state)\n            IDLE: begin\n                pulse_out <= 1'b0;\n                if (!button_in) begin\n                    state <= WAIT_STABLE;\n                    counter <= 4'd0;\n                end\n            end\n            WAIT_STABLE: begin\n                pulse_out <= 1'b0;\n                if (!button_in) begin\n                    if (counter == STABLE_CYCLES - 1) begin\n                        state <= PULSE;\n                    end else begin\n                        counter <= counter + 1;\n                    end\n                end else begin\n                    state <= IDLE;\n                end\n            end\n            PULSE: begin\n                pulse_out <= 1'b1;\n                state <= IDLE; // Transition to IDLE\n                counter <= 4'd0;\n            end\n            WAIT_RELEASE: begin // Unused state\n                pulse_out <= 1'b0;\n                state <= IDLE;\n            end\n        endcase\n    end\nend\n```\n\nC.\n```verilog\nalways @(posedge clk or negedge reset_n) begin\n    if (!reset_n) begin\n        state <= IDLE;\n        counter <= 4'd0;\n        pulse_out <= 1'b0;\n    end else begin\n        case (state)\n            IDLE: begin\n                pulse_out <= 1'b0;\n                if (!button_in) begin\n                    state <= WAIT_STABLE;\n                    counter <= 4'd0;\n                end\n            end\n            WAIT_STABLE: begin\n                pulse_out <= 1'b0;\n                if (!button_in) begin\n                    if (counter == STABLE_CYCLES - 1) begin\n                        state <= PULSE;\n                    end else begin\n                        counter <= counter + 1;\n                    end\n                end else begin\n                    state <= IDLE;\n                end\n            end\n            PULSE: begin\n                pulse_out <= 1'b1;\n                state <= WAIT_RELEASE;\n                counter <= 4'd0;\n            end\n            WAIT_RELEASE: begin\n                // pulse_out is not assigned here\n                if (button_in) begin\n                    state <= IDLE;\n                    pulse_out <= 1'b0;\n                end\n            end\n        endcase\n    end\nend\n```\n\nD.\n```verilog\nalways @(posedge clk or negedge reset_n) begin\n    if (!reset_n) begin\n        state <= IDLE;\n        counter <= 4'd0;\n        pulse_out <= 1'b0;\n    end else begin\n        case (state)\n            IDLE: begin\n                pulse_out <= 1'b0;\n                if (!button_in) begin\n                    state <= WAIT_STABLE;\n                    // Counter not reset here\n                end\n            end\n            WAIT_STABLE: begin\n                pulse_out <= 1'b0;\n                if (!button_in) begin\n                    if (counter == STABLE_CYCLES - 1) begin\n                        state <= PULSE;\n                    end else begin\n                        counter <= counter + 1;\n                    end\n                end else begin\n                    state <= IDLE;\n                end\n            end\n            PULSE: begin\n                pulse_out <= 1'b1;\n                state <= WAIT_RELEASE;\n                counter <= 4'd0; // Counter is reset here\n            end\n            WAIT_RELEASE: begin\n                pulse_out <= 1'b0;\n                if (button_in) begin\n                    state <= IDLE;\n                end\n            end\n        endcase\n    end\nend\n```", "solution": "We restate the required FSM behavior as constraints to verify against each implementation:\n- On asynchronous reset assertion, the FSM must go to `IDLE`, the `counter` to 0, and `pulse_out` to 0 immediately.\n- From `IDLE`, upon detecting a press (`` `button_in` == 0 ``), the FSM must go to `WAIT_STABLE` and reset the `counter` to 0.\n- In `WAIT_STABLE`, while `` `button_in` == 0 ``, it must count consecutive stable low cycles and, upon exactly `STABLE_CYCLES` (16) such cycles, transition to `PULSE`. If `button_in` returns to 1 at any time before reaching 16, the check fails, the timer must be reset, and it must return to `IDLE`.\n- In `PULSE`, it must assert `pulse_out` to 1 for exactly one clock cycle, then transition to `WAIT_RELEASE` and ensure the `counter` is reset.\n- In `WAIT_RELEASE`, it must deassert `pulse_out` and wait until release (`` `button_in` == 1 ``) to return to `IDLE`, thereby preventing multiple pulses if the button remains pressed.\n\nWe now analyze the correctness of the cycle-counting mechanism used: entering `WAIT_STABLE` with `counter` at 0, the logic checks the condition `` `counter == STABLE_CYCLES - 1` `` (which is 15). With nonblocking assignments, at each rising clock edge in `WAIT_STABLE` while `` `button_in` == 0 ``:\n- For the first stable cycle after entry, the old `counter` is 0, which is not 15, so it increments to 1.\n- After $k$ stable cycles, the old `counter` is $k-1$; it increments to $k$ if $k-1 \\neq 15$.\n- On the 16th stable cycle, the old `counter` is 15, which satisfies the `` `counter == 15` `` condition, so the FSM transitions to `PULSE` at that clock. Therefore, the `PULSE` state is reached exactly after 16 consecutive stable low cycles have been observed, satisfying the specification.\n\nCheck option A:\n- `IDLE`: on press, transitions to `WAIT_STABLE` and resets `counter` to 0; `pulse_out` is set to 0.\n- `WAIT_STABLE`: while `button_in` is 0, it increments `counter` and transitions to `PULSE` when `counter` reaches 15, giving exactly 16 cycles as shown above. If `button_in` returns to 1, it transitions to `IDLE`. Although it does not explicitly reset `counter` on this bounce, the counter is reset upon the next entry into `WAIT_STABLE` from `IDLE`, so the timer is effectively reset before any new stability check begins, meeting the functional requirement.\n- `PULSE`: asserts `pulse_out` to 1 and transitions to `WAIT_RELEASE` on the next clock; `counter` is reset, guaranteeing a single-cycle pulse.\n- `WAIT_RELEASE`: forces `pulse_out` to 0 and waits for release (`button_in` is 1) before returning to `IDLE`, preventing multiple pulses while the button remains held.\n- Reset behavior is correct. Therefore, A satisfies all requirements.\n\nCheck option B:\n- `PULSE` transitions directly to `IDLE`, bypassing `WAIT_RELEASE`. If the button remains pressed, `IDLE` will immediately detect `button_in` is 0 and start a new `WAIT_STABLE` period, allowing repeated pulses every 16 cycles while the button is held. This violates the requirement to wait for release after the pulse. Hence B is incorrect.\n\nCheck option C:\n- In `WAIT_RELEASE`, `pulse_out` is not driven low unless `button_in` is 1. Coming from `PULSE` with `pulse_out` at 1, if the button remains held (`button_in` is 0), `pulse_out` retains its previous value of 1, producing a multi-cycle pulse. This violates the single-cycle pulse requirement. Hence C is incorrect.\n\nCheck option D:\n- In `IDLE`, on detecting a press, it does not reset the counter before entering `WAIT_STABLE`. Thus the wait length depends on a potentially stale counter value from a previous attempt, which can shorten the required 16-cycle confirmation and violates the requirement that the timer be reset when starting a new detection. It also fails to reset the timer upon bounce back to `IDLE` until later in `PULSE`, which is too late. Hence D is incorrect.\n\nTherefore, only option A correctly implements all specified behaviors.", "answer": "$$\\boxed{A}$$", "id": "1912819"}]}