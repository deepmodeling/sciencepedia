{"hands_on_practices": [{"introduction": "Dataflow modeling in Verilog provides concise ways to describe complex hardware operations. A prime example is the use of reduction operators, which apply a bitwise operation across all bits of a vector to produce a single-bit result. This practice will guide you through implementing an even parity checker, a fundamental circuit in data transmission and error detection, using the power of the reduction XNOR operator [@problem_id:1926027].", "problem": "A digital circuit is designed to perform a special check on an 8-bit data bus. The circuit has one 8-bit input vector, declared as `wire [7:0] data_in;`, and one 1-bit output, `wire even_parity;`. The circuit's function is to set the `even_parity` output to '1' if the number of bits with the value '1' in `data_in` is even (including the case of zero '1's), and to '0' otherwise.\n\nWhich of the following single-line Verilog dataflow statements correctly implements this behavior?\n\nA. `assign even_parity = ^data_in;`\n\nB. `assign even_parity = `\n\nC. `assign even_parity = |data_in;`\n\nD. `assign even_parity = ~^data_in;`\n\nE. `assign even_parity = ~`", "solution": "Let the 8-bit input be denoted as $data\\_in = (d_{7}, d_{6}, \\ldots, d_{0})$ with $d_{i} \\in \\{0,1\\}$. The parity function can be expressed using XOR as\n$$\np = d_{7} \\oplus d_{6} \\oplus \\cdots \\oplus d_{0} = \\left(\\sum_{i=0}^{7} d_{i}\\right) \\bmod 2.\n$$\nThis $p$ equals $1$ when the number of ones is odd and equals $0$ when the number of ones is even. Therefore, the desired even parity output is the logical negation of $p$:\n$$\n\\overline{p} = \\overline{d_{7} \\oplus d_{6} \\oplus \\cdots \\oplus d_{0}}.\n$$\nIn Verilog, the reduction XOR operator is written as the unary operator `^`, so `^data_in` computes $p$. The reduction XNOR operator is written as the unary operator `~^`, so `~^data_in` computes $\\overline{p}$, which is $1$ exactly when the number of ones is even (including zero). Hence the correct single-line statement is `assign even_parity = ~^data_in;`.\n\nFor completeness, the other options implement different reductions:\n- `` computes $\\prod_{i=0}^{7} d_{i}$, which is $1$ only if all bits are $1$.\n- `|data_in` computes $\\max(d_{0},\\ldots,d_{7})$, which is $1$ if any bit is $1$.\n- `^data_in` computes odd parity.\n- `~` is the negation of reduction AND, which is $1$ unless all bits are $1$.\n\nOnly the reduction XNOR matches even parity.", "answer": "$$\\boxed{D}$$", "id": "1926027"}, {"introduction": "Beyond simple operators, dataflow modeling excels at translating clever algorithms directly into hardware. This practice challenges you to design a \"power-of-two detector,\" a useful circuit in tasks like memory address decoding [@problem_id:1926002]. You will explore a classic bitwise trick that combines arithmetic and logical operations to perform this check with remarkable efficiency.", "problem": "You are tasked with designing a small combinational logic circuit in Verilog using dataflow modeling. The circuit receives an 8-bit unsigned input vector, `A`, and produces a single-bit output, `y`.\n\nThe functionality of the circuit is to act as a \"power-of-two detector\". The output `y` must be logic '1' if the decimal value of `A` is a power of two (e.g., 1, 2, 4, 8, ...). For all other input values, including zero, the output `y` must be logic '0'.\n\nYour implementation must be written as a single continuous assignment statement. Furthermore, your solution must be synthesizable and must not use any system tasks or built-in functions (i.e., any identifier starting with a `$` character).\n\nFrom the options below, select the one continuous assignment statement that correctly and completely implements this logic for the output `y`.\n\nA. `assign y = ($countones(A) == 1);`\n\nB. `assign y = (A > 0)  ((A  (A - 1)) == 0);`\n\nC. `assign y = ((A  (A - 1)) == 0);`\n\nD. `assign y = (A == 1) || (A == 2) || (A == 4) || (A == 8) || (A == 16) || (A == 32) || (A == 64);`\n\nE. `assign y = ((A  -A) == A);`", "solution": "We need a single continuous assignment that yields logical 1 exactly when the unsigned 8-bit input $A$ is a power of two, and yields logical 0 otherwise, including for $A=0$. A standard bitwise characterization for unsigned integers is:\n$$\nA \\text{ is a power of two} \\iff A \\neq 0 \\text{ and } (A \\ \\\\ (A-1)) = 0.\n$$\nExplanation: If $A=2^{k}$ for some integer $k \\geq 0$, then $A$ has exactly one bit set. Subtracting one produces a word with all less significant bits set and the $k$th bit cleared, so $(A \\ \\\\ (A-1))=0$. Conversely, if $A$ has more than one set bit, then $(A \\ \\\\ (A-1)) \\neq 0$. The exception $A=0$ also satisfies $(A \\ \\\\ (A-1))=0$ due to wrap-around, so we must additionally require $A \\neq 0$.\n\nNow evaluate the options against the requirements and constraints:\n- Option A uses the system function $countones$, which is disallowed by the problem (no identifiers starting with $). Hence A is invalid despite expressing the intended property.\n- Option B implements the exact predicate above in synthesizable dataflow form: $(A  0)$ enforces $A \\neq 0$, and $((A \\ \\\\ (A - 1)) == 0)$ enforces the single-bit condition. This meets all requirements and correctly handles $A=0$.\n- Option C omits the nonzero check. For $A=0$, $(A \\ \\\\ (A - 1)) == 0$ evaluates true, incorrectly producing 1. Hence C is incorrect.\n- Option D enumerates powers of two up to $64$, but omits $128$, which is representable in 8 bits. Hence D is incomplete and incorrect.\n- Option E uses the identity $(A \\ \\\\ (-A)) = A$, which holds for nonzero powers of two but also holds for $A=0$ since $0 \\ \\\\ 0 = 0$, thus incorrectly producing 1 for zero. Hence E is incorrect.\n\nTherefore, the only correct and allowed choice is B.", "answer": "$$\\boxed{B}$$", "id": "1926002"}, {"introduction": "The pinnacle of dataflow modeling is writing code that is not only functionally correct but also maps efficiently to hardware. This exercise puts that principle into practice by having you build a controllable negator, a core component of an Arithmetic Logic Unit (ALU) [@problem_id:1925996]. You will implement two's complement negation using an idiomatic Verilog pattern that elegantly models a reconfigurable datapath, revealing the power of combining bitwise and arithmetic operations.", "problem": "You are tasked with designing a controllable 8-bit negator using dataflow Verilog. This circuit is a key component of an adder/subtractor unit within a larger Arithmetic Logic Unit (ALU).\n\nThe standard hardware implementation of an N-bit adder/subtractor that computes either `A+B` or `A-B` is based on the two's complement identity `-B = ~B + 1`. The subtraction `A-B` is performed by computing `A + ~B + 1`. This is efficiently realized in hardware by using N XOR gates to conditionally invert the bits of `B` based on a `subtract` control signal, and then feeding this same `subtract` signal into the carry-in of the N-bit adder.\n\nYour task is to implement a specialized version of this circuit that computes either `Y = X` or `Y = -X`. This is functionally equivalent to computing `0+X` or `0-X`. The Verilog module for this \"Sign Control Unit\" has the following interface:\n- A signed 8-bit input: `input signed [7:0] X`\n- A single-bit control signal: `input negate`\n- A signed 8-bit output: `output [7:0] Y`\n\nThe required behavior is as follows:\n- If the `negate` signal is `1'b0`, the output `Y` must be equal to the input `X`.\n- If the `negate` signal is `1'b1`, the output `Y` must be the two's complement negation of `X`.\n\nFollowing the specific adder/subtractor hardware principle described above, which of the following single-line dataflow Verilog `assign` statements correctly and idiomatically implements this function?\n\nA. `assign Y = (X ^ {8{negate}}) + negate;`\n\nB. `assign Y = negate ? (~X + 1) : X;`\n\nC. `assign Y = (X  {8{negate}}) + negate;`\n\nD. `assign Y = ~X + negate;`\n\nE. `assign Y = (X ~^ {8{negate}}) + negate;`", "solution": "The goal is to create a Verilog `assign` statement that implements a conditional two's complement negation based on a control bit `negate`. The problem specifically asks for the implementation that models the standard adder/subtractor hardware principle.\n\nThe required functionality is:\n1.  If `negate = 0`, then `Y = X`.\n2.  If `negate = 1`, then `Y = -X`.\n\nIn two's complement representation, the negation of a number `X` is given by the formula `-X = ~X + 1`, where `~X` is the bitwise NOT (one's complement) of `X`.\n\nLet's combine the two conditions into a single, unified expression that aligns with the adder/subtractor principle. This principle uses XOR gates for conditional inversion and the control signal as the carry-in for the addition.\n\nLet's analyze the expression `(X ^ S) + S`, where `S` is a single control bit that is broadcast or extended as needed.\n\n**Case 1: `negate = 0`**\n\nThe expression becomes `(X ^ {8{1'b0}}) + 1'b0`.\n- The term `{8{negate}}` becomes `8'b00000000`.\n- `X ^ 8'b00000000` evaluates to `X`, as XORing any bit with 0 leaves the bit unchanged.\n- The addition `+ negate` becomes `+ 0`. In Verilog, when adding operands of different bit widths, the smaller operand is zero-extended to match the larger one. So, `1'b0` becomes `8'b00000000`.\n- The full expression is `X + 0`, which results in `X`.\nThis matches the requirement for `negate = 0`.\n\n**Case 2: `negate = 1`**\n\nThe expression becomes `(X ^ {8{1'b1}}) + 1'b1`.\n- The term `{8{negate}}` becomes `8'b11111111`.\n- `X ^ 8'b11111111` evaluates to `~X` (the bitwise NOT or one's complement), as XORing any bit with 1 flips the bit.\n- The addition `+ negate` becomes `+ 1`. The `1'b1` is zero-extended to `8'b00000001`.\n- The full expression is `~X + 1`.\nThis is the precise formula for two's complement negation. It matches the requirement for `negate = 1`.\n\nTherefore, the statement `assign Y = (X ^ {8{negate}}) + negate;` correctly implements the desired functionality and maps directly to the hardware principle of using XOR gates for conditional inversion (`X ^ {8{negate}}`) and using the control signal `negate` as the value to be added (which serves the role of the carry-in for the `+1`).\n\nNow, let's examine why the other options are incorrect:\n\n- **B. `assign Y = negate ? (~X + 1) : X;`**: This statement is functionally correct. It uses the ternary conditional operator (`?:`) to select between `X` and `-X`. However, it models a multiplexer that chooses between two separately computed values. It does not model the single, reconfigurable datapath (XOR-bank feeding an adder) described in the problem's background, which is what `(X ^ S) + S` represents. The problem asks for the implementation based on that specific principle.\n\n- **C. `assign Y = (X  {8{negate}}) + negate;`**: This uses bitwise AND (``).\n    - If `negate = 0`, it becomes `(X  8'b0) + 0`, which results in `0`. This is incorrect, as the output should be `X`.\n    - If `negate = 1`, it becomes `(X  8'b11111111) + 1`, which is `X + 1`. This is also incorrect.\n\n- **D. `assign Y = ~X + negate;`**:\n    - If `negate = 0`, it becomes `~X + 0`, which results in `~X`. This is incorrect, as the output should be `X`.\n    - If `negate = 1`, it becomes `~X + 1`, which is correct for this case. However, since it fails for `negate = 0`, the entire expression is wrong.\n\n- **E. `assign Y = (X ~^ {8{negate}}) + negate;`**: This uses bitwise XNOR (`~^`). `A ~^ B` is equivalent to `~(A ^ B)`.\n    - If `negate = 1`, it becomes `(X ~^ 8'b1) + 1`, which is `~(X ^ 8'b1) + 1`.\n    - `X ^ 8'b1` is `~X`.\n    - So the expression is `~(~X) + 1`, which simplifies to `X + 1`. This is incorrect.\n\nBased on this analysis, Option A is the only one that is both functionally correct for all cases and directly models the specific hardware implementation principle described in the problem statement.", "answer": "$$\\boxed{A}$$", "id": "1925996"}]}