{"hands_on_practices": [{"introduction": "Before constructing complex digital systems, we must master the fundamental building blocks of Verilog. This practice focuses on the most critical distinction: the difference between `reg` and `wire` data types. Understanding when and where to use each is paramount, as a `reg` is designed to hold a value within procedural blocks (`initial`, `always`), while a `wire` represents a physical connection driven continuously [@problem_id:1975222].", "problem": "In the context of the Verilog Hardware Description Language (HDL), consider the following simple module designed to initialize two signals at the beginning of a simulation.\n\n```verilog\nmodule simple_init;\n\n  reg  a;\n  wire b;\n\n  initial begin\n    a = 1'b0;\n    b = 1'b1;\n  end\n\nendmodule\n```\n\nThis code contains a fundamental error that will prevent it from compiling and simulating correctly. Which one of the following changes is the necessary and correct modification to fix the error in the provided module?\n\nA. Change the declaration of `b` from `wire b;` to `reg b;`\n\nB. Change the declaration of `a` from `reg a;` to `wire a;`\n\nC. Add an `always @(*)` block around the assignments to `a` and `b`.\n\nD. Replace the `initial` block with two continuous assignment statements: `assign a = 1'b0;` and `assign b = 1'b1;`", "solution": "Verilog distinguishes between net types (such as `wire`) and variable types (such as `reg`). The fundamental rule is that procedural assignments within an `initial` or `always` block can only assign to variables (e.g., `reg`), not to nets (e.g., `wire`). Continuous assignments using the `assign` keyword drive nets, not `reg`s.\n\nIn the given module, the `initial` block assigns to both `a` and `b`. The declaration of `a` as a `reg` is correct for a procedural assignment. However, `b` is declared as a `wire`, which cannot be assigned in a procedural block. This is the compilation error.\n\nEvaluate the options:\n- Option A changes `b` from `wire` to `reg`. This makes both `a` and `b` variables that can legally be assigned within the `initial` block. This directly fixes the error without altering behavior.\n- Option B changes `a` from `reg` to `wire`, which would make the procedural assignment to `a` illegal, introducing another error.\n- Option C wraps the assignments in an `always @(*)` block, which remains a procedural context; assigning to `wire` `b` would still be illegal, so this does not fix the error.\n- Option D replaces the procedural `initial` block with continuous assignments. Continuous assignments require nets; since `a` is declared as `reg`, `assign a = 1'b0;` would be illegal unless `a` were also changed to a net type. Because the option does not change the declaration of `a`, this is not a correct fix as stated.\n\nTherefore, the necessary and correct modification is to declare `b` as a `reg`, which is Option A.", "answer": "$$\\boxed{A}$$", "id": "1975222"}, {"introduction": "Modern digital circuits operate on buses—groups of signals that carry multi-bit data. A key skill for any hardware designer is the ability to isolate and manipulate specific portions of these data buses. This exercise provides hands-on practice with Verilog's vector part-select syntax, a crucial tool for routing signals and implementing data processing logic with precision [@problem_id:1975211].", "problem": "In a digital system being designed using Verilog, a register is declared to hold an 8-bit data value from a sensor. This register is defined as:\n\n`reg [7:0] data_bus;`\n\nFor a specific processing unit, only the two least significant bits (LSBs) of `data_bus` are required. Which of the following expressions correctly selects these two bits?\n\nA. `data_bus[0:1]`\n\nB. `data_bus[2:1]`\n\nC. `data_bus[1:0]`\n\nD. `data_bus(1:0)`\n\nE. `data_bus[7:6]`\n\nF. `data_bus[0,1]`", "solution": "A Verilog declaration `reg [7:0] data_bus;` defines an 8-bit vector with indices from the most significant bit (MSB) at index 7 down to the least significant bit (LSB) at index 0. In Verilog, a part-select uses square brackets with a descending range specified as $[ \\text{msb} : \\text{lsb} ]$, where the left index must be greater than or equal to the right index.\n\nThe two least significant bits are bit 1 and bit 0. Therefore, the correct part-select for the two LSBs is `[1:0]`.\n\nEvaluating the options:\n- A. `data_bus[0:1]` uses an ascending range, which is invalid in standard Verilog part-select syntax.\n- B. `data_bus[2:1]` selects bits 2 and 1, not the two LSBs.\n- C. `data_bus[1:0]` correctly selects bits 1 and 0, the two LSBs.\n- D. `data_bus(1:0)` uses parentheses, which is invalid syntax; Verilog requires square brackets for indexing.\n- E. `data_bus[7:6]` selects the two MSBs, not the LSBs.\n- F. `data_bus[0,1]` is invalid syntax; multiple bit selection would require concatenation like `{data_bus[1], data_bus[0]}`, not a comma within brackets.\n\nTherefore, only option C is correct.", "answer": "$$\\boxed{C}$$", "id": "1975211"}, {"introduction": "As designs grow in complexity, integrating multiple modules introduces new challenges, where subtle language features can lead to significant bugs. This problem explores the perilous behavior of 'implicit nets' in Verilog, a common pitfall for even experienced engineers. By analyzing a system where a connection was accidentally omitted, you will uncover how Verilog handles undeclared signals and learn why explicit declarations are essential for creating robust and predictable hardware [@problem_id:1975238].", "problem": "In a digital system designed using Verilog, a top-level module, `system_controller`, integrates a `data_source` submodule and a `data_sink` submodule. The `data_source` module generates an 8-bit value. This value is intended to be passed to the `data_sink` module for processing. However, the engineer forgot to explicitly declare the wire connecting the output of the `data_source` instance to the input of the `data_sink` instance within the `system_controller`.\n\nYou are given the Verilog descriptions for all three modules. Your task is to analyze this design and determine the final, stable decimal value of the `system_output` port of the `system_controller`. Assume the simulation runs long enough for all initial values to propagate and all combinational logic to settle.\n\n**Module `data_source`:**\n```verilog\nmodule data_source (\n  output reg [7:0] source_out\n);\n\n  initial begin\n    source_out = 8'hA9; // Hexadecimal A9\n  end\n\nendmodule\n```\n\n**Module `data_sink`:**\n```verilog\nmodule data_sink (\n  input [3:0] sink_in,\n  output [7:0] sink_out\n);\n\n  // Re-arrange and combine input bits to form the output\n  assign sink_out = {sink_in[3:2], 2'b11, sink_in[1:0], 2'b01};\n\nendmodule\n```\n\n**Module `system_controller`:**\n```verilog\nmodule system_controller (\n  output [7:0] system_output\n);\n\n  // Instantiation of submodules\n  data_source source_inst (\n    .source_out(internal_connection)\n  );\n\n  data_sink sink_inst (\n    .sink_in(internal_connection),\n    .sink_out(system_output)\n  );\n\n  // NOTE: The wire 'internal_connection' is intentionally NOT declared.\n\nendmodule\n```\n\nWhat is the final decimal value of the `system_output`?", "solution": "The undeclared identifier `internal_connection` in Verilog, absent a `default_nettype` override, is implicitly declared as a 1-bit net of type `wire` by the language’s implicit net rule.\n\nIn module `data_source`, the output is assigned in an `initial` block:\n$$\\text{source\\_out} = 8'hA9 = 8'b10101001.$$\n\nIn `system_controller`, the port connection `.source_out(internal_connection)` connects an 8-bit formal port to a 1-bit actual. Under Verilog’s width-mismatch rules, when driving a narrower net from a wider vector, the value is truncated to the least significant bits. Therefore,\n$$\\text{internal\\_connection} = \\text{source\\_out}[0] = 1.$$\n\nNext, the connection `.sink_in(internal_connection)` connects a 4-bit input formal to a 1-bit actual. For a wider formal receiving a narrower actual (unsigned), the value is zero-extended on the most significant side. Thus,\n$$\\text{sink\\_in} = 4'b0001.$$\n\nThe `data_sink` computes its output with the combinational assignment:\n$$\\text{sink\\_out} = \\{\\text{sink\\_in}[3:2],\\ 2'b11,\\ \\text{sink\\_in}[1:0],\\ 2'b01\\}.$$\nSubstituting $\\text{sink\\_in} = 4'b0001$ gives:\n$$\\text{sink\\_in}[3:2] = 2'b00, \\quad \\text{sink\\_in}[1:0] = 2'b01.$$\nso,\n$$\\text{sink\\_out} = \\{2'b00,\\ 2'b11,\\ 2'b01,\\ 2'b01\\} = 8'b00110101.$$\n\nTherefore, in `system_controller`,\n$$\\text{system\\_output} = 8'b00110101 = 8'h35,$$\nwhich in decimal is $53$. All signals are combinational after initialization, so this is the final stable value.", "answer": "$$\\boxed{53}$$", "id": "1975238"}]}