{"hands_on_practices": [{"introduction": "Mastering Verilog operators begins with a solid grasp of the fundamentals, including how numbers are represented and manipulated. This first exercise challenges you to think about 2's complement negation not just as an algorithm (invert and add one), but through its fundamental mathematical definition. By using only subtraction, you will reinforce your understanding of how Verilog handles fixed-width arithmetic and the deep connection between negation and subtracting from zero.", "problem": "In digital logic design, calculating the 2's complement of a binary number is a fundamental operation, often used to represent negative numbers or perform subtraction. Given a 4-bit Verilog variable declared as `reg [3:0] x;`, you are tasked with finding an expression to compute its 2's complement.\n\nYour implementation must adhere to a specific design constraint: the expression can *only* use the binary subtraction operator (`-`) and a single Verilog integer literal. Other arithmetic or bitwise operators like addition (`+`), bitwise NOT (`~`), etc., are strictly forbidden.\n\nWhich of the following Verilog expressions correctly implements this operation under the given constraint?\n\nA. `4'hF - x`\n\nB. `1'b1 - x`\n\nC. `x - 1'b1`\n\nD. `4'h0 - x`\n\nE. `~x`", "solution": "The goal is to find the 2's complement of a 4-bit number `x` using only the subtraction operator and a constant.\n\nLet's first recall the two common ways to define the 2's complement of an N-bit number `x`.\n\n1.  **Inversion and Addition:** The 2's complement is found by inverting all the bits of `x` (which gives the 1's complement) and then adding 1. In Verilog, this is expressed as `~x + 1'b1`. This method is explicitly forbidden by the problem's constraint against using the `~` and `+` operators.\n\n2.  **Mathematical Definition:** For an N-bit number `x`, its 2's complement is defined as $(2^N) - x$. For our 4-bit variable (`N=4`), this formula becomes $(2^4) - x = 16 - x$. However, this is for non-zero `x`. For `x=0`, the 2's complement is 0. The formula $(2^4)-0 = 16$ gives `10000` in binary, and in a 4-bit system, the most significant bit is an overflow that is discarded, leaving `0000`. So the formula works for `x=0` as well under modulo-$2^N$ arithmetic.\n\nNow, we need to translate this mathematical concept into a valid Verilog expression using only the subtraction operator and a constant.\n\nIn 2's complement arithmetic, the operation of negation (finding `-x`) is performed by taking the 2's complement. Therefore, the expression for the 2's complement of `x` is equivalent to the expression for `0 - x`.\n\nLet's analyze this with an example. Let `x = 4'b0011` (decimal 3).\nThe subtraction `0 - 3` in 4-bit 2's complement arithmetic proceeds as follows:\n`0 - 3` is equivalent to `0 + (-3)`.\nThe 4-bit representation of `0` is `4'b0000`.\nThe 4-bit representation of `-3` is the 2's complement of `3` (`4'b0011`).\n2's complement of `4'b0011` is `~4'b0011 + 1'b1 = 4'b1100 + 1'b1 = 4'b1101`.\nSo, `0 - 3` should result in `4'b1101`.\n\nLet's see if the Verilog expression `4'h0 - x` achieves this.\nLet `x = 4'b0011`.\nThe expression is `4'h0 - 4'b0011`, which is `4'b0000 - 4'b0011`.\nPerforming binary subtraction:\n```\n  (Borrow)\n  1 0 0 0 0\n-   0 0 1 1\n-----------\n    1 1 0 1\n```\nThe result is `4'b1101`, which is the correct 2's complement of `4'b0011`. The borrow from the most significant bit is discarded in fixed-width unsigned arithmetic, which is how Verilog's `-` operator behaves in this context, effectively performing modulo-$2^4$ arithmetic.\n\nTherefore, the expression `4'h0 - x` correctly computes the 2's complement of `x` while satisfying the problem's constraints. The constant used is `4'h0` (or `4'd0`, or simply `0`).\n\nLet's review the options:\nA. `4'hF - x`: This is `15 - x`, which calculates the 1's complement of `x`. For `x=3`, this gives `15-3=12` (`4'b1100`), which is the bitwise inverse, not the 2's complement.\nB. `1'b1 - x`: This is `1 - x`. For `x=3`, this is `1 - 3 = -2`. The 4-bit representation of `-2` is `4'b1110`. This is not the 2's complement of `x` (`4'b1101`).\nC. `x - 1'b1`: This simply decrements `x`.\nD. `4'h0 - x`: As derived, this correctly calculates the 2's complement of `x`. It uses only the subtraction operator and a constant `4'h0`.\nE. `~x`: This calculates the 1's complement and is explicitly forbidden as it uses the `~` operator.\n\nThus, option D is the correct answer.", "answer": "$$\\boxed{D}$$", "id": "1975734"}, {"introduction": "Beyond simple arithmetic, a hardware designer's daily work involves shuffling, routing, and structuring data at the bit level. This next practice focuses on two of Verilog's most powerful tools for these tasks: the concatenation operator `{...}` and the part-select operator `[msb:lsb]`. You will construct a new data word by rearranging parts of an input byte, a common operation in everything from network packet formatting to CPU instruction decoding.", "problem": "In the design of a specialized data packet-former for a communication protocol, you are tasked with creating a Verilog module that transforms an 8-bit input data byte into a 16-bit output word.\n\nThe module has one 8-bit input port, `val[7:0]`, and one 16-bit output port, `result[15:0]`. The transformation rule is as follows:\n1.  The most-significant byte of the output `result` (i.e., bits `[15:8]`) must be identical to the input byte `val`.\n2.  The least-significant byte of the output `result` (i.e., bits `[7:0]`) must be a modified version of the input byte `val`, where its upper 4-bit nibble (bits `[7:4]`) and its lower 4-bit nibble (bits `[3:0]`) are swapped.\n\nBelow are five different Verilog `assign` statements proposed for a continuous assignment to the output `result`. Which of the following statements correctly implements the specified logic?\n\nA. `assign result = {val, val[3:0], val[7:4]};`\n\nB. `assign result = {{val[3:0], val[7:4]}, val};`\n\nC. `assign result = {val, {val[7:4], val[3:0]}};`\n\nD. `assign result = {val, (val[3:0] << 4) | (val[7:4] >> 4)};`\n\nE. `assign result = {val[7:0], val[4:7], val[0:3]};`", "solution": "The problem requires constructing a 16-bit vector `result` from an 8-bit vector `val` based on a specific set of rules. Let's break down the construction of `result[15:0]` and analyze the provided options.\n\n**Step 1: Deconstruct the Problem Statement**\nThe 16-bit output `result` is composed of two 8-bit parts:\n- **Most-Significant Byte (MSB):** `result[15:8]` should be equal to the 8-bit input `val`.\n- **Least-Significant Byte (LSB):** `result[7:0]` should be a nibble-swapped version of `val`.\n\n**Step 2: Formulate the Nibble-Swapped Byte**\nThe input `val` is an 8-bit vector, `val[7:0]`.\n- Its upper nibble is the part-select `val[7:4]`.\n- Its lower nibble is the part-select `val[3:0]`.\n\nTo swap the nibbles, the new upper nibble should be the old lower nibble, and the new lower nibble should be the old upper nibble. We can construct this new 8-bit byte using the Verilog concatenation operator `{...}`.\n- New 8-bit byte = `{ old_lower_nibble, old_upper_nibble }`\n- In Verilog syntax, this is: `{val[3:0], val[7:4]}`.\n\n**Step 3: Formulate the Final 16-bit Result**\nThe final `result` is the concatenation of its MSB and LSB.\n- `result` = `{ MSB, LSB }`\n- Substituting the components we've defined:\n  `result` = `{ val, {val[3:0], val[7:4]} }`\n\nVerilog allows for nested concatenations to be flattened. Therefore, the expression is equivalent to:\n`result = {val, val[3:0], val[7:4]}`\n\nThis expression ascribes an (8 + 4 + 4) = 16-bit value to the 16-bit `result` wire, which is dimensionally correct. The bits are assigned as follows:\n- `result[15:8]` gets `val` (8 bits).\n- `result[7:4]` gets `val[3:0]` (4 bits).\n- `result[3:0]` gets `val[7:4]` (4 bits).\nThis matches the problem description perfectly. `result[15:8]` is the original `val`, and `result[7:0]` is the nibble-swapped version of `val`.\n\n**Step 4: Analyze the Multiple-Choice Options**\n\n*   **A. `assign result = {val, val[3:0], val[7:4]};`**\n    As derived above, this statement correctly constructs the 16-bit `result`. The MSB is `val`, and the LSB is `{val[3:0], val[7:4]}`, which is the nibble-swapped version of `val`. This is the correct answer.\n\n*   **B. `assign result = {{val[3:0], val[7:4]}, val};`**\n    This statement concatenates the nibble-swapped version of `val` first, followed by the original `val`. This would assign the swapped byte to `result[15:8]` and the original byte to `result[7:0]`. This is the reverse of what the problem specifies.\n\n*   **C. `assign result = {val, {val[7:4], val[3:0]}};`**\n    The expression `{val[7:4], val[3:0]}` concatenates the upper nibble and lower nibble of `val` in their original order, which simply reconstructs the original `val`. Therefore, this statement is equivalent to `assign result = {val, val};`. It concatenates `val` with itself, not with a nibble-swapped version.\n\n*   **D. `assign result = {val, (val[3:0] << 4) | (val[7:4] >> 4)};`**\n    This option attempts to perform the nibble swap using bitwise shift operators. However, it applies the operators to 4-bit operands. In Verilog, the result of a shift operation has the same width as its left operand.\n    - `val[3:0]` is a 4-bit value. `val[3:0] << 4` shifts this 4-bit value left by 4 positions. All original bits are shifted out, resulting in `4'b0000`.\n    - `val[7:4]` is a 4-bit value. `val[7:4] >> 4` shifts this 4-bit value right by 4 positions. All original bits are shifted out, also resulting in `4'b0000`.\n    - The bitwise OR `(4'b0000 | 4'b0000)` results in `4'b0000`. This 4-bit value would be zero-extended to 8 bits in the context of the concatenation. Thus, the statement is effectively `assign result = {val, 8'b00000000};`, which is incorrect.\n\n*   **E. `assign result = {val[7:0], val[4:7], val[0:3]};`**\n    The standard Verilog syntax for a part-select requires the bit indices to be in the form `[msb_index : lsb_index]`. The expressions `val[4:7]` and `val[0:3]` violate this rule, as the index on the left of the colon is smaller than the index on the right. This statement would cause a syntax error during compilation and is not valid Verilog code.\n\nBased on this analysis, only option A correctly and validly implements the required logic.", "answer": "$$\\boxed{A}$$", "id": "1975749"}, {"introduction": "The true power of hardware description languages comes alive when you combine operators in elegant and efficient ways to solve complex problems with simple expressions. This advanced exercise introduces a classic 'bit-twiddling hack' used to design high-speed logic like priority arbiters. Your task is to find an expression that isolates the lowest-priority active request from a set of inputs, a challenge that reveals a beautiful interaction between two's complement arithmetic and bitwise logic.", "problem": "In the design of a low-latency priority arbiter for a custom System-on-Chip (SoC), you are tasked with creating a specific Verilog hardware module. The arbiter receives an `N`-bit input vector named `requests`, where `reg [N-1:0] requests;`. Each bit `requests[i]` indicates a request from device `i`. Your goal is to generate an `N`-bit output vector, `grant`, that acknowledges only the lowest-indexed (i.e., least significant) active request. For example, if `requests` is `8'b01011000`, the `grant` output should be `8'b00001000`.\n\nTo meet strict timing constraints, the entire logic must be implemented in a single Verilog continuous assignment of the form `assign grant = <expression>;`. The expression on the right-hand side must adhere to two critical rules:\n1. It must use exactly one bitwise operator chosen from the set: `&` (bitwise AND), `|` (bitwise OR), `^` (bitwise XOR), `~` (bitwise NOT).\n2. It must use exactly one arithmetic operator chosen from the set: `+` (addition), `-` (subtraction/negation).\n\nYou can assume that the input `requests` vector is always non-zero. Which of the following expressions correctly implements the desired logic for the `grant` vector?\n\nA. `requests & -requests`\n\nB. `requests ^ (requests - 1)`\n\nC. `requests & (requests + 1)`\n\nD. `requests & (requests - 1)`\n\nE. `requests | -requests`", "solution": "The problem requires us to find a Verilog expression that isolates the least significant set bit (LSB) of a non-zero input vector, `requests`, using exactly one bitwise and one arithmetic operator. Let's denote the input vector as `x` for simplicity. The goal is to compute an output `y` that has a single '1' at the position of the LSB of `x`, and '0's everywhere else.\n\nThe solution relies on the properties of two's complement representation, which is how Verilog handles signed arithmetic. The two's complement negation of a number `x`, which is `-x`, is mathematically equivalent to `~x + 1`.\n\nLet's analyze the structure of a non-zero binary number `x`. We can represent `x` as a concatenation of three parts: a higher-order bit string `A`, the least significant '1' bit, and a trailing string of `k` zeros, `B`.\nSo, `x = A1B`, where `B = 00...0` (`k` times).\n\nFor example, if `x = 12` (binary `...001100`), then `A = ...001`, the LSB is the '1' at the $2^2$ position, and `B = 00` ($k=2$).\n\nNow, let's compute `-x` using the two's complement formula, `-x = ~x + 1`.\n1.  First, we compute `~x` (bitwise NOT):\n    `~x = ~(A1B) = (~A)0(~B)`.\n    Since `B` is a string of `k` zeros, `~B` is a string of `k` ones.\n    So, `~x = (~A)0(11...1)`, where there are `k` ones.\n\n2.  Next, we add 1 to `~x`:\n    `~x + 1 = (~A)0(11...1) + 1`.\n    The addition of 1 to a string of `k` ones (`11...1`) results in a carry that propagates through all the ones, flipping them to zeros, until it reaches the rightmost '0'. This '0' flips to a '1', and the carry stops.\n    The result is `1` followed by `k` zeros (`100...0`).\n    So, `-x = (~A)1(00...0) = (~A)1B`.\n\nNow we have expressions for `x` and `-x`:\n`x  = A1B`\n`-x = (~A)1B`\n\nThe final step is to apply a bitwise operator. Let's try the bitwise AND (`&`) operator as required by the problem's constraints.\n`y = x & (-x) = (A1B) & ((~A)1B)`\n\nWe can perform the AND operation on the parts:\n- The higher-order bits: `A & (~A)`. For any bit string `A`, this operation always results in all zeros.\n- The LSB position: `1 & 1 = 1`.\n- The trailing zero bits: `B & B = (00...0) & (00...0) = 00...0`.\n\nCombining these results, we get:\n`y = (0...0)1(0...0)`.\nThis is a number with a single '1' at the exact position of the least significant set bit of the original number `x`.\n\nThis matches the expression in option A: `requests & -requests`. This expression uses one bitwise operator (`&`) and one arithmetic operator (`-`), satisfying all the given constraints.\n\nLet's quickly check the other options with an example, `x = 6` (`...0110`):\n- `x = ...0110`\n- `-x = ~x + 1 = (...1001) + 1 = ...1010`\n- `x-1 = 5 = ...0101`\n- `x+1 = 7 = ...0111`\n\nB. `requests ^ (requests - 1)` -> `...0110 ^ ...0101 = ...0011`. Incorrect.\nC. `requests & (requests + 1)` -> `...0110 & ...0111 = ...0110`. Incorrect, no change to original value.\nD. `requests & (requests - 1)` -> `...0110 & ...0101 = ...0100`. This *clears* the LSB, not isolates it. Incorrect.\nE. `requests | -requests` -> `...0110 | ...1010 = ...1110`. Incorrect.\n\nTherefore, the only correct expression is `requests & -requests`.", "answer": "$$\\boxed{A}$$", "id": "1975721"}]}