{"hands_on_practices": [{"introduction": "Understanding the theory of two's complement is one thing, but watching it unfold at the gate level provides a much deeper insight. This first hands-on exercise guides you through the inner workings of an adder-subtractor, requiring you to trace the bit-by-bit calculation for a subtraction operation. By manually computing the sum and carry at each full-adder stage, you will see precisely how the inverted operand and the initial carry-in signal combine to produce the correct result, demystifying the elegant identity $A - B = A + \\bar{B} + 1$ [@problem_id:1907532].", "problem": "A 4-bit adder-subtractor circuit is a fundamental component in a simple Arithmetic Logic Unit (ALU). It is designed to perform either addition or subtraction on two 4-bit binary numbers, $A = A_3A_2A_1A_0$ and $B = B_3B_2B_1B_0$. The operation is controlled by a single mode-select bit, $M$.\n\nThe circuit is constructed using four full-adder stages. For each stage $i$ (from 0 for the Least Significant Bit to 3 for the Most Significant Bit), a full-adder takes three inputs: $A_i$, a second operand bit, and a carry-in bit $C_i$. It produces a sum bit $S_i$ and a carry-out bit $C_{i+1}$.\n\nThe circuit's functionality is as follows:\n- To perform addition ($A+B$), the control bit $M$ is set to 0. In this mode, the bits of $B$ are passed directly to the full-adders, and the initial carry-in to the first stage, $C_0$, is 0.\n- To perform subtraction ($A-B$), the control bit $M$ is set to 1. The circuit calculates the subtraction by finding the 2's complement of $B$ and adding it to $A$. This is implemented in hardware by inverting each bit of $B$ before it enters the adder and setting the initial carry-in to the first stage, $C_0$, to 1.\n\nConsider the case where the circuit is performing the subtraction of $B = 0011$ from $A = 0101$. Determine the 4-bit binary sum $S = S_3S_2S_1S_0$ and the sequence of carry-out bits $C_1C_2C_3C_4$ generated from the full-adder stages 0, 1, 2, and 3, respectively.\n\nWhich of the following options correctly represents the final sum and the sequence of internal carries?\n\nA. Sum $S = 0010$ and Carries $C_{1}C_{2}C_{3}C_{4} = 1011$\n\nB. Sum $S = 0001$ and Carries $C_{1}C_{2}C_{3}C_{4} = 0111$\n\nC. Sum $S = 1001$ and Carries $C_{1}C_{2}C_{3}C_{4} = 1110$\n\nD. Sum $S = 1000$ and Carries $C_{1}C_{2}C_{3}C_{4} = 1110$\n\nE. Sum $S = 0010$ and Carries $C_{1}C_{2}C_{3}C_{4} = 0101$", "solution": "For a 4-bit adder-subtractor using two’s complement, the mode bit $M$ controls inversion of $B$ and the initial carry: when performing $A-B$, we set $M=1$, take $B_{i}'=B_{i}\\oplus M=\\overline{B_{i}}$, and $C_{0}=M=1$. Each full-adder stage satisfies\n$$\nS_{i}=A_{i}\\oplus B_{i}'\\oplus C_{i},\\qquad C_{i+1}=A_{i}B_{i}'+A_{i}C_{i}+B_{i}'C_{i}.\n$$\nGiven $A=0101$ with bits $(A_{3},A_{2},A_{1},A_{0})=(0,1,0,1)$ and $B=0011$ with $(B_{3},B_{2},B_{1},B_{0})=(0,0,1,1)$, for subtraction ($M=1$) we have $B'=\\overline{B}=1100$, so $(B_{3}',B_{2}',B_{1}',B_{0}')=(1,1,0,0)$ and $C_{0}=1$.\n\nStage $i=0$:\n$$\nS_{0}=A_{0}\\oplus B_{0}'\\oplus C_{0}=1\\oplus 0\\oplus 1=0,\n$$\n$$\nC_{1}=A_{0}B_{0}'+A_{0}C_{0}+B_{0}'C_{0}=(1)(0)+(1)(1)+(0)(1)=1.\n$$\n\nStage $i=1$:\n$$\nS_{1}=A_{1}\\oplus B_{1}'\\oplus C_{1}=0\\oplus 0\\oplus 1=1,\n$$\n$$\nC_{2}=A_{1}B_{1}'+A_{1}C_{1}+B_{1}'C_{1}=(0)(0)+(0)(1)+(0)(1)=0.\n$$\n\nStage $i=2$:\n$$\nS_{2}=A_{2}\\oplus B_{2}'\\oplus C_{2}=1\\oplus 1\\oplus 0=0,\n$$\n$$\nC_{3}=A_{2}B_{2}'+A_{2}C_{2}+B_{2}'C_{2}=(1)(1)+(1)(0)+(1)(0)=1.\n$$\n\nStage $i=3$:\n$$\nS_{3}=A_{3}\\oplus B_{3}'\\oplus C_{3}=0\\oplus 1\\oplus 1=0,\n$$\n$$\nC_{4}=A_{3}B_{3}'+A_{3}C_{3}+B_{3}'C_{3}=(0)(1)+(0)(1)+(1)(1)=1.\n$$\n\nThus the sum is $S_{3}S_{2}S_{1}S_{0}=0010$ and the carry sequence is $C_{1}C_{2}C_{3}C_{4}=1011$, which corresponds to option A.", "answer": "$$\\boxed{A}$$", "id": "1907532"}, {"introduction": "Digital circuits operate with a fixed number of bits, a physical constraint that leads to the critical concept of overflow—when an arithmetic result is too large or too small to be represented. This practice challenges you to analyze an arithmetic operation from two different perspectives: as an operation on unsigned numbers and as one on signed two's complement numbers [@problem_id:1907528]. By learning to identify the distinct conditions that cause an overflow in each system, you will develop a fundamental skill required for designing robust and reliable arithmetic logic units (ALUs).", "problem": "An engineer is designing a simple 4-bit Arithmetic Logic Unit (ALU). The ALU takes two 4-bit binary inputs, $A$ and $B$, and a 1-bit control signal, $S$. The ALU performs one of two operations based on the value of $S$:\n- If $S=0$, the ALU computes the sum $F = A + B$.\n- If $S=1$, the ALU computes the difference $F = A - B$. The subtraction is implemented by adding the two's complement of $B$ to $A$.\n\nThe circuit produces a 4-bit result, $F$. An overflow occurs if the true mathematical result of the operation cannot be represented within the 4-bit output, for a given number representation. For unsigned numbers, the valid range is $[0, 15]$. For signed two's complement numbers, the valid range is $[-8, 7]$.\n\nConsider the inputs $A = 0101_2$ and $B = 0110_2$. The ALU's behavior is analyzed under both unsigned and signed two's complement interpretations. Which of the following statements is true?\n\nA. For the addition operation ($S=0$), an overflow occurs under the signed interpretation, but not under the unsigned interpretation.\n\nB. For the addition operation ($S=0$), an overflow occurs under both the signed and unsigned interpretations.\n\nC. For the subtraction operation ($S=1$), an overflow occurs under the signed interpretation, but not under the unsigned interpretation.\n\nD. For the subtraction operation ($S=1$), an overflow occurs under both the signed and unsigned interpretations.\n\nE. An overflow occurs for the addition operation under the unsigned interpretation and for the subtraction operation under the signed interpretation.", "solution": "Given $A=0101_{2}$ and $B=0110_{2}$.\n\nAddition case ($S=0$):\nCompute the 4-bit sum:\n$$F=A+B=0101_{2}+0110_{2}=1011_{2}.$$\n- Unsigned interpretation: $0101_{2}=5$, $0110_{2}=6$, so the true result is $5+6=11$. Since $11\\in[0,15]$, there is no unsigned overflow. Equivalently, the carry out of the most significant bit is $0$, so unsigned overflow does not occur.\n- Signed two’s complement interpretation: $0101_{2}=+5$, $0110_{2}=+6$, so the true result is $+11$, but the representable range is $[-8,7]$, hence $+11\\notin[-8,7]$ and signed overflow occurs. Consistently, adding two positives produced $1011_{2}$ (a negative), indicating signed overflow.\n\nSubtraction case ($S=1$):\nImplemented as $F=A+(\\text{two’s complement of }B)$.\nCompute the two’s complement of $B$: invert bits and add $1$,\n$$\\overline{0110_{2}}=1001_{2},\\quad 1001_{2}+0001_{2}=1010_{2}.$$\nThen\n$$F=A+(-B)=0101_{2}+1010_{2}=1111_{2}.$$\n- Unsigned interpretation: The true result is $5-6=-1$, and since $-1\\notin[0,15]$, unsigned overflow occurs (the wrapped result $1111_{2}=15$ does not reflect the true result).\n- Signed two’s complement interpretation: The true result is $+5-+6=-1$, which lies in $[-8,7]$, and $1111_{2}$ indeed represents $-1$, so no signed overflow occurs.\n\nTherefore, for addition there is overflow under the signed interpretation but not under the unsigned interpretation, which matches option A, and for subtraction the opposite does not occur.\n\nHence the correct statement is A.", "answer": "$$\\boxed{A}$$", "id": "1907528"}, {"introduction": "A powerful method for mastering a circuit's design is to reason about its potential failure modes. This final practice presents you with a diagnostic puzzle: an adder-subtractor circuit is producing a consistent error, but only when set to subtraction mode [@problem_id:1907564]. Your task is to act as a digital detective, using the observed faulty behavior to deduce the precise single-point failure in the hardware. This exercise sharpens your problem-solving skills and reinforces the distinct functional roles of the operand-inverting XOR gates and the initial carry-in signal $C_0$.", "problem": "A 4-bit binary adder-subtractor circuit is constructed using four full-adder (FA) stages. The circuit is designed to compute the sum or difference of two 4-bit unsigned binary numbers, $A = A_3A_2A_1A_0$ and $B = B_3B_2B_1B_0$. A single control input, $M$, dictates the operation: addition ($A+B$) is performed when $M=0$, and subtraction ($A-B$) is performed when $M=1$.\n\nThe circuit is implemented as follows:\n- For each bit position $i$ (from 0 to 3), the input $B_i$ is fed into a 2-input XOR gate along with the control signal $M$. The output of this XOR gate, let's call it $B'_i$, is then used as one of the inputs to the $i$-th full-adder.\n- The other input to the $i$-th full-adder is $A_i$.\n- The carry-in to the first full-adder (the one for the least significant bits, LSBs), denoted as $C_0$, is connected directly to the control signal $M$.\n- The sum output of the circuit is $S = S_3S_2S_1S_0$. Subtraction is achieved by calculating the 2's complement of $B$ and adding it to $A$.\n\nDuring testing, a malfunction is discovered. The circuit performs addition correctly when $M=0$. However, when $M=1$ to perform subtraction, the circuit is found to be computing the operation $S = A + \\bar{B}$, where $\\bar{B}$ represents the bitwise 1's complement (NOT) of $B$.\n\nWhich of the following single, permanent faults would explain this precise erroneous behavior?\n\nA. The output of the XOR gate connected to input $B_3$ (the most significant bit of B) is stuck-at-0.\n\nB. The carry-out, $C_4$, from the most significant bit full-adder is stuck-at-0.\n\nC. The carry-in, $C_0$, to the least significant bit full-adder is stuck-at-1.\n\nD. The control input line $M$ is stuck-at-0 at the input to all four XOR gates, but functions correctly at the $C_0$ input.\n\nE. The carry-in, $C_0$, to the least significant bit full-adder is stuck-at-0.", "solution": "Define the intended behavior using the standard adder-subtractor construction:\n- For each bit $i$, the modified input is $B_{i}'=B_{i}\\oplus M$.\n- The least significant carry-in is $C_{0}=M$.\n- The 4-bit ripple adder computes the arithmetic sum\n$$\nS=A+B'+C_{0}.\n$$\n\nHence, in the fault-free design:\n- For $M=0$: $B'=B$, $C_{0}=0$, so $S=A+B$.\n- For $M=1$: $B'=\\bar{B}$, $C_{0}=1$, so $S=A+\\bar{B}+1=A- B$ (two’s complement subtraction).\n\nObserved malfunction:\n- Addition ($M=0$) works correctly, so behavior must remain $S=A+B$.\n- Subtraction attempt ($M=1$) yields $S=A+\\bar{B}$, which equals the intended $A+\\bar{B}+1$ with the $+1$ missing. This indicates that for $M=1$, $B'$ is correctly inverted but the carry-in $C_{0}$ is not asserted to $1$; instead it behaves as $0$.\n\nTherefore, the single fault that exactly produces this is $C_{0}$ stuck-at-$0$:\n- For $M=0$: $B'=B$, $C_{0}=0$ (stuck-at-$0$ matches intended), so $S=A+B$ remains correct.\n- For $M=1$: $B'=\\bar{B}$, $C_{0}=0$ (should have been $1$), so $S=A+\\bar{B}$, exactly the observed error.\n\nEliminating other options:\n- A: XOR output for $B_{3}$ stuck-at-$0$ corrupts $B_{3}'$ for both $M=0$ and $M=1$, breaking correct addition. Contradicts “addition is correct.”\n- B: $C_{4}$ stuck-at-$0$ only affects the final carry-out flag, not the computed $S$, so it cannot produce $S=A+\\bar{B}$ instead of $A+\\bar{B}+1$.\n- C: $C_{0}$ stuck-at-$1$ would make addition ($M=0$) compute $A+B+1$, contradicting “addition is correct.”\n- D: $M$ stuck-at-$0$ at XORs but correct at $C_{0}$ gives, for $M=1$, $B'=B$ and $C_{0}=1$, yielding $S=A+B+1$, not $A+\\bar{B}$.\n\nThus, only $C_{0}$ stuck-at-$0$ (option E) matches all observations.", "answer": "$$\\boxed{E}$$", "id": "1907564"}]}