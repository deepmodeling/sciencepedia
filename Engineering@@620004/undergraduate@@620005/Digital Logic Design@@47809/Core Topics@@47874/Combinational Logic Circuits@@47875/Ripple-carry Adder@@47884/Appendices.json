{"hands_on_practices": [{"introduction": "To truly understand the \"ripple\" in a ripple-carry adder, it's essential to trace the signal flow step-by-step. This first exercise guides you through the process of calculating the intermediate carry bits for a specific addition. By manually computing how the carry-out from one stage becomes the carry-in for the next, you'll gain a concrete understanding of the sequential nature of this circuit [@problem_id:1958696].", "problem": "A 5-bit ripple-carry adder is a digital circuit that adds two 5-bit binary numbers, which we denote as $A = A_4A_3A_2A_1A_0$ and $B = B_4B_3B_2B_1B_0$. The adder is composed of a chain of full adders, where the stage for bit position $i$ receives inputs $A_i$, $B_i$, and a carry-in from the previous stage, $C_i$, to produce a sum bit $S_i$ and a carry-out bit $C_{i+1}$. For the least significant bit (position 0), the carry-in $C_0$ is provided externally.\n\nYou are given the two input numbers $A = 11011_2$ and $B = 01110_2$. The initial carry-in to the adder is $C_0 = 0$.\n\nDetermine the values of the intermediate carry bits $C_1, C_2, C_3,$ and $C_4$ produced during the operation.", "solution": "We use the full-adder carry-out relation at bit position $i$:\n$$\nC_{i+1}=A_{i}B_{i}+(A_{i}\\oplus B_{i})C_{i},\n$$\nwhere $+$ denotes Boolean OR, juxtaposition denotes Boolean AND, and $\\oplus$ denotes XOR. The bits are $A=11011_{2}$, so $A_{4}=1$, $A_{3}=1$, $A_{2}=0$, $A_{1}=1$, $A_{0}=1$, and $B=01110_{2}$, so $B_{4}=0$, $B_{3}=1$, $B_{2}=1$, $B_{1}=1$, $B_{0}=0$, with $C_{0}=0$.\n\nFor $i=0$: $A_{0}=1$, $B_{0}=0$, $C_{0}=0$.\n$$\nA_{0}B_{0}=0,\\quad A_{0}\\oplus B_{0}=1,\\quad C_{1}=0+(1)\\cdot 0=0.\n$$\n\nFor $i=1$: $A_{1}=1$, $B_{1}=1$, $C_{1}=0$.\n$$\nA_{1}B_{1}=1,\\quad A_{1}\\oplus B_{1}=0,\\quad C_{2}=1+(0)\\cdot 0=1.\n$$\n\nFor $i=2$: $A_{2}=0$, $B_{2}=1$, $C_{2}=1$.\n$$\nA_{2}B_{2}=0,\\quad A_{2}\\oplus B_{2}=1,\\quad C_{3}=0+(1)\\cdot 1=1.\n$$\n\nFor $i=3$: $A_{3}=1$, $B_{3}=1$, $C_{3}=1$.\n$$\nA_{3}B_{3}=1,\\quad A_{3}\\oplus B_{3}=0,\\quad C_{4}=1+(0)\\cdot 1=1.\n$$\n\nThus the intermediate carry bits are $C_{1}=0$, $C_{2}=1$, $C_{3}=1$, $C_{4}=1$.", "answer": "$$\\boxed{\\begin{pmatrix}0 & 1 & 1 & 1\\end{pmatrix}}$$", "id": "1958696"}, {"introduction": "The sequential nature of the ripple-carry adder, while simple, introduces a significant performance bottleneck: carry propagation delay. The total time for an addition is determined by the longest possible path a carry signal must travel. This next problem challenges you to identify the specific input conditions that create this worst-case scenario, highlighting the critical link between input data and circuit performance [@problem_id:1958659].", "problem": "A 4-bit ripple-carry adder is used to calculate the sum $S = A + B$. The inputs are two 4-bit unsigned binary numbers, $A = A_3A_2A_1A_0$ and $B = B_3B_2B_1B_0$. This adder is built by cascading four identical Full-Adder (FA) modules. For each stage $i$ (from 0 to 3), the FA module computes the sum bit $S_i$ and the carry-out bit $C_{i+1}$ based on its inputs $A_i$, $B_i$, and the carry-in $C_i$. The carry-out of one stage is connected to the carry-in of the next, and the initial carry-in to the first stage, $C_0$, is fixed at 0.\n\nThe time it takes for any output bit of an FA to stabilize is its propagation delay. The total time for the addition is determined by the longest signal path from the primary inputs ($A, B, C_0$) to the final outputs ($S, C_4$). This worst-case scenario occurs when a change in the least significant input bits causes a carry that \"ripples\" through every single FA module to affect the final sum and carry-out.\n\nYour task is to identify which of the following input pairs $(A, B)$ creates this longest possible carry propagation chain.\n\nA. $A = 1111_2, B = 0001_2$\n\nB. $A = 1010_2, B = 0101_2$\n\nC. $A = 1111_2, B = 1111_2$\n\nD. $A = 0000_2, B = 0001_2$\n\nE. $A = 1000_2, B = 1000_2$", "solution": "In a ripple-carry adder, each full adder obeys\n$$S_{i} = A_{i} \\oplus B_{i} \\oplus C_{i}, \\quad C_{i+1} = A_{i}B_{i} + (A_{i} \\oplus B_{i})C_{i}.$$\nDefine generate and propagate signals:\n$$G_{i} = A_{i}B_{i}, \\quad P_{i} = A_{i} \\oplus B_{i}, \\quad \\text{so } C_{i+1} = G_{i} + P_{i}C_{i}.$$\nWith $C_{0}=0$, the longest carry propagation chain from least significant bit to most significant bit requires:\n- At $i=0$: a generated carry, i.e., $G_{0}=1 \\Rightarrow A_{0}=1$ and $B_{0}=1$, so that $C_{1}=1$ despite $C_{0}=0$.\n- For $i=1,2,3$: pure propagation without generate or kill, i.e., $P_{i}=1$ and $G_{i}=0$, which requires $A_{i} \\neq B_{i}$ (complementary bits).\n\nCheck the options:\n- A: $A=1111_{2}, B=0001_{2}$. Bitwise:\n  - $i=0$: $(A_{0},B_{0})=(1,1) \\Rightarrow G_{0}=1$ generates $C_{1}$.\n  - $i=1,2,3$: $(1,0)$ each, so $P_{i}=1$, $G_{i}=0$ propagate the carry through all stages. This yields the full ripple to $C_{4}$.\n- B: $A_{0}=0$, $B_{0}=1 \\Rightarrow G_{0}=0$ and with $C_{0}=0$ no initial carry is produced; no ripple chain starts.\n- C: All bits have $G_{i}=1$, so $C_{i+1}=1$ independent of $C_{i}$; the dependency on the initial carry is cut, so no long ripple chain.\n- D: $A_{0}=0$, $B_{0}=1 \\Rightarrow G_{0}=0$; no initial carry.\n- E: $A_{0}=0$, $B_{0}=0 \\Rightarrow G_{0}=0$; no initial carry.\n\nTherefore only option A creates the longest possible carry propagation chain.", "answer": "$$\\boxed{A}$$", "id": "1958659"}, {"introduction": "Beyond simple addition, the ripple-carry adder is a versatile building block for more complex arithmetic operations. By combining it with some control logic, we can construct an adder-subtractor circuit, a cornerstone of computer arithmetic units. This final practice asks you to configure such a circuit to perform subtraction, demonstrating how the same hardware can be adapted for different functions by manipulating its inputs [@problem_id:1958663].", "problem": "A 4-bit digital circuit is designed to function as an adder-subtractor for two 4-bit unsigned integers, denoted as $A = A_3A_2A_1A_0$ and $B = B_3B_2B_1B_0$. The specific operation is selected by a single-bit control input $M$. When the control input $M$ is set to 0, the circuit computes the sum $S = A + B$. When $M$ is set to 1, the circuit computes the difference $D = A - B$ by calculating the two's complement of $B$ and adding it to $A$.\n\nDetermine the binary values for each of the nine individual input bits ($A_3, A_2, A_1, A_0, B_3, B_2, B_1, B_0$, and $M$) that must be supplied to the circuit to perform the calculation $7 - 5$.\n\nPresent your answer as a single row matrix containing nine binary digits, with the bits ordered from left to right as $A_3, A_2, A_1, A_0, B_3, B_2, B_1, B_0, M$.", "solution": "We use the standard two's-complement adder-subtractor principle: to compute $A-B$ with a single adder, set the mode bit $M=1$, bitwise invert $B$ (denoted $\\overline{B}$), and add $1$ as the carry-in, so that\n$$\nA-B = A + \\overline{B} + 1.\n$$\nA 4-bit unsigned $7$ is represented as $(0111)_{2}$, so with $A=A_{3}A_{2}A_{1}A_{0}$ we have\n$$\nA_{3}=0,\\quad A_{2}=1,\\quad A_{1}=1,\\quad A_{0}=1.\n$$\nA 4-bit unsigned $5$ is represented as $(0101)_{2}$, so with $B=B_{3}B_{2}B_{1}B_{0}$ we have\n$$\nB_{3}=0,\\quad B_{2}=1,\\quad B_{1}=0,\\quad B_{0}=1.\n$$\nTo perform subtraction, set the control input $M=1$.\n\nOptional check of correctness via two's complement addition:\n$$\n\\overline{B} = 1010,\\quad \\overline{B}+1 = 1011,\\quad A + (\\overline{B}+1) = 0111 + 1011 = 10010,\n$$\nwhose lower $4$ bits are $0010$, i.e., $(2)_{10}$, consistent with $7-5=2$.\n\nTherefore, the required input row (ordered as $A_{3},A_{2},A_{1},A_{0},B_{3},B_{2},B_{1},B_{0},M$) is\n$$\n\\begin{pmatrix}\n0 & 1 & 1 & 1 & 0 & 1 & 0 & 1 & 1\n\\end{pmatrix}.\n$$", "answer": "$$\\boxed{\\begin{pmatrix}0 & 1 & 1 & 1 & 0 & 1 & 0 & 1 & 1\\end{pmatrix}}$$", "id": "1958663"}]}