{"hands_on_practices": [{"introduction": "This practice reveals a clever and efficient way to design a 1-bit magnitude comparator by repurposing a common arithmetic component: the full adder. By understanding that comparing two numbers, $A$ and $B$, is equivalent to checking the sign of their difference, $A-B$, you can use a full adder to perform subtraction and derive the comparison results. This exercise sharpens your ability to see the underlying connections between different digital logic functions and design circuits with minimal resources [@problem_id:1945479].", "problem": "A digital systems engineer is tasked with creating a 1-bit magnitude comparator using a 1-bit full adder as a primary component to minimize the logic gate count. The comparator takes two single-bit inputs, $A$ and $B$, and produces three mutually exclusive outputs: $G$ (HIGH when $A>B$), $E$ (HIGH when $A=B$), and $L$ (HIGH when $A<B$).\n\nThe engineer uses a standard 1-bit full adder, which has three inputs ($X, Y, C_{in}$) and two outputs: the sum bit $S$ and the carry-out bit $C_{out}$. The full adder is configured as follows to perform a comparison between $A$ and $B$: its inputs are set to $X=A$, $Y=\\bar{B}$ (the logical NOT of $B$), and $C_{in}=1$.\n\nYour task is to determine the correct set of Boolean expressions for the comparator outputs $G$, $E$, and $L$ in terms of the full adder's outputs, $S$ and $C_{out}$. Which of the following options correctly implements the 1-bit magnitude comparator?\n\nA. $G = S \\cdot C_{out}$, $E = \\bar{S}$, $L = \\overline{C_{out}}$\n\nB. $G = \\bar{S} \\cdot C_{out}$, $E = S$, $L = \\bar{S} \\cdot \\overline{C_{out}}$\n\nC. $G = C_{out}$, $E = \\bar{S}$, $L = \\overline{C_{out}}$\n\nD. $G = S$, $E = S \\oplus C_{out}$, $L = C_{out}$\n\nE. $G = S \\cdot \\overline{C_{out}}$, $E = \\overline{S \\oplus C_{out}}$, $L = \\bar{S} \\cdot C_{out}$", "solution": "A standard full adder has\n$$S = X \\oplus Y \\oplus C_{in}, \\quad C_{out} = XY + X C_{in} + Y C_{in}.$$\nWith $X=A$, $Y=\\bar{B}$, and $C_{in}=1$,\n$$S = A \\oplus \\bar{B} \\oplus 1.$$\nUsing $Z \\oplus 1 = \\bar{Z}$ and $A \\oplus \\bar{B} = \\overline{A \\oplus B}$,\n$$S = \\overline{A \\oplus \\bar{B}} = \\overline{\\overline{A \\oplus B}} = A \\oplus B.$$\nFor the carry,\n$$C_{out} = A\\bar{B} + A\\cdot 1 + \\bar{B}\\cdot 1 = A\\bar{B} + A + \\bar{B} = A + \\bar{B},$$\nusing $A + A\\bar{B} = A$.\n\nA 1-bit comparator requires\n$$G = A\\bar{B}, \\quad E = \\overline{A \\oplus B}, \\quad L = \\bar{A}B.$$\nFrom the relations found,\n- Since $S = A \\oplus B$, we have $E = \\bar{S}$.\n- $C_{out} = A + \\bar{B}$ equals $0$ only when $A=0$ and $B=1$, i.e., exactly the $A<B$ case ($\\bar{A}B$), hence $L = \\overline{C_{out}}$.\n- When $S=1$ (inputs unequal), $C_{out}=1$ precisely in the $A=1, B=0$ case, so $G = S \\cdot C_{out}$.\n\nThus the correct implementation is\n$$G = S \\cdot C_{out}, \\quad E = \\bar{S}, \\quad L = \\overline{C_{out}},$$\nwhich matches option A.", "answer": "$$\\boxed{A}$$", "id": "1945479"}, {"introduction": "Designing a comparator for large binary numbers bit-by-bit is impractical; instead, we link smaller, standard comparator modules together in a cascade. This exercise demonstrates the principle of a ripple-comparator, where the overall decision depends on the most significant bits that differ. You will trace the comparison of two 8-bit numbers through a two-stage 4-bit comparator system, gaining hands-on insight into how information \"ripples\" from the least significant stage to the most significant one to determine the final outcome [@problem_id:1919784].", "problem": "An 8-bit digital magnitude comparator is constructed by cascading two identical 4-bit magnitude comparator modules. Let's label the modules as Stage 0 (for the lower-order bits) and Stage 1 (for the higher-order bits).\n\nEach 4-bit comparator module has the following inputs and outputs:\n- Two 4-bit numbers to compare: $A_{\\text{in}} = A_3A_2A_1A_0$ and $B_{\\text{in}} = B_3B_2B_1B_0$.\n- Three cascading inputs from a lower-order stage: $I_{A>B}$, $I_{A=B}$, and $I_{A<B}$.\n- Three outputs that determine the comparison result: $O_{A>B}$, $O_{A=B}$, and $O_{A<B}$.\n\nThe logic for each 4-bit module is as follows:\n- If the local 4-bit input $A_{\\text{in}}$ is greater than $B_{\\text{in}}$, the outputs are $(O_{A>B}, O_{A=B}, O_{A<B}) = (1, 0, 0)$.\n- If the local 4-bit input $A_{\\text{in}}$ is less than $B_{\\text{in}}$, the outputs are $(O_{A>B}, O_{A=B}, O_{A<B}) = (0, 0, 1)$.\n- If the local 4-bit input $A_{\\text{in}}$ is equal to $B_{\\text{in}}$, the outputs are determined by the cascading inputs: $(O_{A>B}, O_{A=B}, O_{A<B}) = (I_{A>B}, I_{A=B}, I_{A<B})$.\n\nTo build the 8-bit comparator, the outputs of Stage 0 ($O_{A>B}^{(0)}, O_{A=B}^{(0)}, O_{A<B}^{(0)}$) are connected to the corresponding cascading inputs of Stage 1 ($I_{A>B}^{(1)}, I_{A=B}^{(1)}, I_{A<B}^{(1)}$). Stage 0 is the least significant stage, so its cascading inputs are hardwired to represent an initial equality condition: $(I_{A>B}^{(0)}, I_{A=B}^{(0)}, I_{A<B}^{(0)}) = (0, 1, 0)$.\n\nLet the two 8-bit numbers to be compared be $A = 10110101_2$ and $B = 10111001_2$. The final output of the 8-bit comparator is given by the outputs of Stage 1, $(O_{A>B}^{(1)}, O_{A=B}^{(1)}, O_{A<B}^{(1)})$.\n\nWhat are the logic levels of the final output tuple $(O_{A>B}^{(1)}, O_{A=B}^{(1)}, O_{A<B}^{(1)})$?\n\nA. $(0, 0, 1)$\n\nB. $(0, 1, 0)$\n\nC. $(1, 0, 0)$\n\nD. $(1, 1, 0)$\n\nE. $(0, 1, 1)$", "solution": "We split the 8-bit words into high and low nibbles for the two cascaded 4-bit stages. Let $A=A_{7}A_{6}A_{5}A_{4}A_{3}A_{2}A_{1}A_{0}$ and $B=B_{7}B_{6}B_{5}B_{4}B_{3}B_{2}B_{1}B_{0}$.\n\nStage 0 (lower 4 bits) compares\n$$A_{\\text{in}}^{(0)}=A_{3}A_{2}A_{1}A_{0},\\quad B_{\\text{in}}^{(0)}=B_{3}B_{2}B_{1}B_{0}.$$\nFrom $A=10110101_{2}$ and $B=10111001_{2}$, we have\n$$A_{\\text{in}}^{(0)}=0101_{2},\\quad B_{\\text{in}}^{(0)}=1001_{2}.$$\nSince $0101_{2}<1001_{2}$, by the module logic,\n$$(O_{A>B}^{(0)},O_{A=B}^{(0)},O_{A<B}^{(0)})=(0,0,1),$$\nindependent of the Stage 0 cascading inputs $(I_{A>B}^{(0)},I_{A=B}^{(0)},I_{A<B}^{(0)})=(0,1,0)$.\n\nThese become the cascading inputs to Stage 1:\n$$(I_{A>B}^{(1)},I_{A=B}^{(1)},I_{A<B}^{(1)})=(0,0,1).$$\n\nStage 1 (upper 4 bits) compares\n$$A_{\\text{in}}^{(1)}=A_{7}A_{6}A_{5}A_{4},\\quad B_{\\text{in}}^{(1)}=B_{7}B_{6}B_{5}B_{4}.$$\nFrom the given numbers,\n$$A_{\\text{in}}^{(1)}=1011_{2},\\quad B_{\\text{in}}^{(1)}=1011_{2},$$\nso $A_{\\text{in}}^{(1)}=B_{\\text{in}}^{(1)}$. By the module logic for equality, the outputs of Stage 1 equal its cascading inputs:\n$$(O_{A>B}^{(1)},O_{A=B}^{(1)},O_{A<B}^{(1)})=(I_{A>B}^{(1)},I_{A=B}^{(1)},I_{A<B}^{(1)})=(0,0,1).$$\n\nTherefore the final 8-bit comparison indicates $A<B$, corresponding to option A.", "answer": "$$\\boxed{A}$$", "id": "1919784"}, {"introduction": "In the real world, digital circuits can fail. This practice moves beyond ideal design to the crucial skill of troubleshooting and fault analysis. You will investigate a cascaded 8-bit comparator where a critical connection between stages is faulty, a \"stuck-at-1\" error. By determining which pair of distinct numbers would be incorrectly evaluated as equal, you will learn how a single point of failure can corrupt the logic of an entire system and why robust testing is essential in digital engineering [@problem_id:1919756].", "problem": "An 8-bit unsigned magnitude comparator is constructed by cascading two 4-bit magnitude comparators, labeled Stage 0 and Stage 1. The 8-bit input numbers are denoted as $A = A_7A_6A_5A_4A_3A_2A_1A_0$ and $B = B_7B_6B_5B_4B_3B_2B_1B_0$.\n\nStage 0 compares the least significant nibbles (LSNs), which are $A_{LSN} = A_3A_2A_1A_0$ and $B_{LSN} = B_3B_2B_1B_0$. Stage 1 compares the most significant nibbles (MSNs), which are $A_{MSN} = A_7A_6A_5A_4$ and $B_{MSN} = B_7B_6B_5B_4$.\n\nThe outputs of Stage 0 serve as the cascade inputs for Stage 1. The overall comparison results for the 8-bit numbers are the final outputs from Stage 1. The logic for the final equality output, $(A=B)_{OUT}$, is given by the standard cascading formula:\n$$ (A=B)_{OUT} = (A_{MSN} = B_{MSN}) \\land I_{A=B} $$\nwhere $(A_{MSN} = B_{MSN})$ is the local equality comparison result from Stage 1, $I_{A=B}$ is the cascade input from Stage 0, and $\\land$ represents the logical AND operation.\n\nDue to a manufacturing defect, the cascade input line $I_{A=B}$ is permanently connected to a logic '1' voltage, a condition known as a \"stuck-at-1\" fault.\n\nWhich of the following pairs of distinct 8-bit numbers, $A$ and $B$, would be incorrectly evaluated as equal by this faulty comparator?\n\nA. $A = 11110000_2$, $B = 11110000_2$\n\nB. $A = 01101001_2$, $B = 01101101_2$\n\nC. $A = 01011100_2$, $B = 10101100_2$\n\nD. $A = 10000001_2$, $B = 01111110_2$", "solution": "The final equality output of a correctly cascaded 8-bit comparator is determined by the most significant stage (Stage 1), based on its local comparison and the equality signal cascaded from the lower stage (Stage 0). The formula is:\n$$ (A=B)_{OUT} = (A_{MSN} = B_{MSN}) \\land I_{A=B} $$\nIn a fault-free design, the cascade input $I_{A=B}$ would be the result of the LSN comparison, i.e., $I_{A=B} = (A_{LSN} = B_{LSN})$.\n\nThe problem states there is a stuck-at-1 fault on the cascade input line, so for the faulty comparator:\n$$ I_{A=B} = 1 $$\nTherefore, the faulty equality output logic simplifies to:\n$$ (A=B)_{OUT}^{faulty} = (A_{MSN} = B_{MSN}) \\land 1 = (A_{MSN} = B_{MSN}) $$\nThis means the faulty comparator will declare two numbers equal if and only if their most significant nibbles (MSNs) are identical, completely ignoring the least significant nibbles (LSNs).\n\nAn incorrect equality evaluation occurs when two numbers are actually different ($A \\ne B$) but are reported as equal. Based on the faulty logic, this happens precisely when:\n$$ (A_{MSN} = B_{MSN}) \\land (A_{LSN} \\ne B_{LSN}) $$\nWe now evaluate each option by splitting the numbers into their MSNs and LSNs:\n\nA. $A = 11110000_2$, $B = 11110000_2$. These numbers are not distinct. They would be correctly evaluated as equal.\n\nB. $A = 0110\\,1001_2$, $B = 0110\\,1101_2$.\n- $A_{MSN} = 0110_2$, $B_{MSN} = 0110_2$. They are equal.\n- $A_{LSN} = 1001_2$, $B_{LSN} = 1101_2$. They are not equal.\nThis pair satisfies the condition for an incorrect equality. The faulty comparator will output 'equal', while the correct result is 'not equal'.\n\nC. $A = 0101\\,1100_2$, $B = 1010\\,1100_2$.\n- $A_{MSN} = 0101_2$, $B_{MSN} = 1010_2$. They are not equal.\nThe faulty comparator will output 'not equal', which is the correct result.\n\nD. $A = 1000\\,0001_2$, $B = 0111\\,1110_2$.\n- $A_{MSN} = 1000_2$, $B_{MSN} = 0111_2$. They are not equal.\nThe faulty comparator will output 'not equal', which is the correct result.\n\nTherefore, the pair in option B would be incorrectly evaluated as equal.", "answer": "$$\\boxed{B}$$", "id": "1919756"}]}