{"hands_on_practices": [{"introduction": "The fundamental purpose of a D flip-flop is to capture and store a single bit of data. This capture occurs at a precise moment, synchronized with a clock signal. This first practice builds upon that core principle by placing the flip-flop within a simple circuit that includes feedback. By working through this problem, you will develop the essential skill of tracing the state of a system, step-by-step, as it evolves with each clock pulse. This methodical analysis is foundational to understanding all sequential logic circuits. [@problem_id:1931277]", "problem": "A sequential logic circuit is designed using a single positive-edge-triggered D-type flip-flop and an Exclusive OR (XOR) gate. The circuit has one external serial data input, denoted by $S$, and a clock signal. The data input $D$ of the flip-flop is driven by the output of the XOR gate. The two inputs to this XOR gate are the external serial data line $S$ and the flip-flop's own output, $Q$.\n\nInitially, before the application of any clock pulses, the output $Q$ of the flip-flop is in a logic low state (0).\n\nThe external serial data input $S$ is fed the 5-bit sequence '10110'. The bits of $S$ are synchronized with the clock, meaning that for each of the five consecutive rising clock edges, a new bit from the sequence is stable at the $S$ input. The first bit ('1') is present at the first rising clock edge, the second bit ('0') at the second, and so on.\n\nWhat is the resulting 5-bit sequence of states at the output $Q$ after each of the five consecutive rising clock edges? The sequence should be read from the state after the first clock edge to the state after the fifth.\n\nA. 10110\n\nB. 11011\n\nC. 01011\n\nD. 01110\n\nE. 11100", "solution": "A positive-edge-triggered D flip-flop updates its state on each rising edge according to $Q^{+}=D$. Here, $D=S \\oplus Q$, where $\\oplus$ denotes XOR. With initial condition $Q_{0}=0$ and input bits $S_{1}=1$, $S_{2}=0$, $S_{3}=1$, $S_{4}=1$, $S_{5}=0$, the state updates are given recursively by\n$$\nQ_{i}=S_{i} \\oplus Q_{i-1}, \\quad i=1,\\dots,5.\n$$\nCompute step by step:\n$$\nQ_{1}=1 \\oplus 0=1,\\quad\nQ_{2}=0 \\oplus 1=1,\\quad\nQ_{3}=1 \\oplus 1=0,\\quad\nQ_{4}=1 \\oplus 0=1,\\quad\nQ_{5}=0 \\oplus 1=1.\n$$\nThus the output sequence after each rising edge is $11011$, which corresponds to option B.", "answer": "$$\\boxed{B}$$", "id": "1931277"}, {"introduction": "While our initial models of flip-flops are often ideal, real-world components have critical timing requirements that must be met for reliable operation. Two of the most important are the setup time ($t_{setup}$) and hold time ($t_{hold}$), which define a window around the active clock edge during which the data input a must be stable. This exercise will challenge you to analyze a detailed timing diagram and identify a setup time violation, a practical skill that is indispensable for debugging and designing high-speed digital systems. [@problem_id:1931286] [@problem_id:1931256]", "problem": "A digital circuit uses a single positive edge-triggered D-type flip-flop to sample a data signal. The flip-flop has a setup time requirement of $t_{setup} = 3 \\text{ ns}$ and a hold time requirement of $t_{hold} = 2 \\text{ ns}$.\n\nThe data input (D) and clock input (CLK) signals are initially at logic 0. The following is a chronological list of all signal transitions that occur over an 85 ns interval. A transition \"from X to Y\" means the signal was stable at level X before the specified time and stable at level Y after the specified time.\n\n- At $t = 10 \\text{ ns}$, the D signal transitions from 0 to 1.\n- At $t = 20 \\text{ ns}$, the CLK signal transitions from 0 to 1.\n- At $t = 25 \\text{ ns}$, the CLK signal transitions from 1 to 0.\n- At $t = 38 \\text{ ns}$, the D signal transitions from 1 to 0.\n- At $t = 40 \\text{ ns}$, the CLK signal transitions from 0 to 1.\n- At $t = 45 \\text{ ns}$, the CLK signal transitions from 1 to 0.\n- At $t = 50 \\text{ ns}$, the D signal transitions from 0 to 1.\n- At $t = 60 \\text{ ns}$, the CLK signal transitions from 0 to 1.\n- At $t = 65 \\text{ ns}$, the CLK signal transitions from 1 to 0.\n- At $t = 70 \\text{ ns}$, the D signal transitions from 1 to 0.\n- At $t = 80 \\text{ ns}$, the CLK signal transitions from 0 to 1.\n- At $t = 85 \\text{ ns}$, the CLK signal transitions from 1 to 0.\n\nGiven this sequence of events, which of the following rising clock edges results in a setup time violation for the D flip-flop?\n\nA. The rising edge at $t = 20 \\text{ ns}$.\n\nB. The rising edge at $t = 40 \\text{ ns}$.\n\nC. The rising edge at $t = 60 \\text{ ns}$.\n\nD. The rising edge at $t = 80 \\text{ ns}$.\n\nE. No setup time violations occur at any of the rising edges.", "solution": "The problem asks us to identify which rising clock edge causes a setup time violation for a D flip-flop with a setup time $t_{setup} = 3 \\text{ ns}$.\n\nA setup time violation occurs if the data input (D) changes within the setup time window immediately preceding the active (in this case, rising) edge of the clock (CLK). For a rising clock edge at time $t_{clk}$, the data signal D must be stable during the time interval $[t_{clk} - t_{setup}, t_{clk}]$.\n\nWe need to analyze the state of the D signal before each of the four rising clock edges described in the problem. The rising edges occur at $t = 20 \\text{ ns}$, $t = 40 \\text{ ns}$, $t = 60 \\text{ ns}$, and $t = 80 \\text{ ns}$.\n\n**Analysis of the rising edge at $t = 20 \\text{ ns}$:**\nThe clock edge occurs at $t_{clk,1} = 20 \\text{ ns}$.\nThe required setup time is $t_{setup} = 3 \\text{ ns}$.\nThe setup time window is $[20 - 3, 20] \\text{ ns} = [17, 20] \\text{ ns}$.\nWe must check if the D signal is stable during this interval.\nAccording to the problem description, the last transition of the D signal before this clock edge occurred at $t = 10 \\text{ ns}$ (from 0 to 1).\nThe D signal is stable at logic 1 from $t = 10 \\text{ ns}$ until its next change at $t = 38 \\text{ ns}$.\nSince the interval $[10, 38]$ ns completely contains the setup window $[17, 20]$ ns, the D signal is stable during the setup window.\nTherefore, no setup time violation occurs at $t = 20 \\text{ ns}$.\n\n**Analysis of the rising edge at $t = 40 \\text{ ns}$:**\nThe clock edge occurs at $t_{clk,2} = 40 \\text{ ns}$.\nThe required setup time is $t_{setup} = 3 \\text{ ns}$.\nThe setup time window is $[40 - 3, 40] \\text{ ns} = [37, 40] \\text{ ns}$.\nWe must check if the D signal is stable during this interval.\nThe last transition of the D signal before this clock edge occurred at $t = 38 \\text{ ns}$ (from 1 to 0).\nThis transition at $t = 38 \\text{ ns}$ falls *inside* the setup window $[37, 40]$ ns.\nAlternatively, we can calculate the time duration for which the data was stable before the clock edge: $\\Delta t = t_{clk,2} - t_{D\\_change} = 40 \\text{ ns} - 38 \\text{ ns} = 2 \\text{ ns}$.\nSince this duration $\\Delta t = 2 \\text{ ns}$ is less than the required setup time $t_{setup} = 3 \\text{ ns}$, a setup time violation occurs.\nTherefore, a setup time violation occurs at $t = 40 \\text{ ns}$.\n\n**Analysis of the rising edge at $t = 60 \\text{ ns}$:**\nThe clock edge occurs at $t_{clk,3} = 60 \\text{ ns}$.\nThe required setup time is $t_{setup} = 3 \\text{ ns}$.\nThe setup time window is $[60 - 3, 60] \\text{ ns} = [57, 60] \\text{ ns}$.\nThe last transition of the D signal before this clock edge occurred at $t = 50 \\text{ ns}$ (from 0 to 1).\nThe D signal is stable at logic 1 from $t = 50 \\text{ ns}$ until its next change at $t = 70 \\text{ ns}$.\nSince the interval $[50, 70]$ ns completely contains the setup window $[57, 60]$ ns, the D signal is stable during the setup window.\nTherefore, no setup time violation occurs at $t = 60 \\text{ ns}$.\n\n**Analysis of the rising edge at $t = 80 \\text{ ns}$:**\nThe clock edge occurs at $t_{clk,4} = 80 \\text{ ns}$.\nThe required setup time is $t_{setup} = 3 \\text{ ns}$.\nThe setup time window is $[80 - 3, 80] \\text{ ns} = [77, 80] \\text{ ns}$.\nThe last transition of the D signal before this clock edge occurred at $t = 70 \\text{ ns}$ (from 1 to 0).\nThe D signal is stable at logic 0 from $t = 70 \\text{ ns}$ onwards for the duration specified.\nSince the D signal does not change in the interval $[77, 80]$ ns, the setup condition is met.\nTherefore, no setup time violation occurs at $t = 80 \\text{ ns}$.\n\nBased on the analysis, only the rising clock edge at $t = 40 \\text{ ns}$ results in a setup time violation. This corresponds to option B.", "answer": "$$\\boxed{B}$$", "id": "1931286"}, {"introduction": "Moving from theoretical analysis to practical implementation, modern digital circuits are not built with individual gates but are described using a Hardware Description Language (HDL) like Verilog. This practice focuses on translating a functional specification into a behavioral Verilog model for a more complex D flip-flop. The design includes an asynchronous clear and a synchronous clock enable, two features commonly found in real-world applications. Mastering this task will hone your ability to write precise, synthesizable code that correctly distinguishes between synchronous and asynchronous events. [@problem_id:1931239]", "problem": "You are tasked with designing a behavioral model for a specialized D-type flip-flop using the Verilog Hardware Description Language (HDL). The flip-flop has the following input and output ports: a clock `clk`, data input `d`, an active-high synchronous enable `en`, an active-low asynchronous clear `clr_n`, and an output `q`. The output `q` should be declared as a `reg` or `logic` type.\n\nThe required behavior of the flip-flop is as follows:\n1.  **Asynchronous Clear**: Whenever the `clr_n` input is low (logic 0), the output `q` must be immediately and unconditionally forced to 0. This action must have the highest priority and must occur regardless of the state of `clk` or `en`.\n2.  **Synchronous Operation**: When `clr_n` is high (logic 1), the flip-flop's behavior is synchronized to the positive edge of the `clk` input.\n3.  **Clock Enable**: On a positive edge of `clk` (and while `clr_n` is high), if the `en` input is high (logic 1), the output `q` should be updated to the value of the data input `d`.\n4.  **Hold State**: On a positive edge of `clk` (and while `clr_n` is high), if the `en` input is low (logic 0), the output `q` must retain its previous value.\n\nWhich of the following Verilog `always` blocks correctly implements the described flip-flop?\n\nA.\n```verilog\nalways @(posedge clk) begin\n    if (!clr_n) begin\n        q <= 1'b0;\n    end else if (en) begin\n        q <= d;\n    end\nend\n```\n\nB.\n```verilog\nalways @(posedge clk, negedge clr_n) begin\n    if (!clr_n) begin\n        q = 1'b0;\n    end else if (en) begin\n        q = d;\n    end\nend\n```\n\nC.\n```verilog\nalways @(posedge clk, negedge clr_n) begin\n    if (!clr_n) begin\n        q <= 1'b0;\n    end else if (en) begin\n        q <= d;\n    end\nend\n```\n\nD.\n```verilog\nalways @(posedge clk, negedge clr_n) begin\n    if (en) begin\n        if (!clr_n) begin\n            q <= 1'b0;\n        end else begin\n            q <= d;\n        end\n    end\nend\n```\n\nE.\n```verilog\nalways @(posedge clk or negedge clr_n) begin\n    if (clr_n == 1'b0)\n        q <= 1'b0;\n    else if (clk == 1'b1 && en == 1'b1)\n        q <= d;\nend\n```", "solution": "We interpret the specification:\n\n- Active-low asynchronous clear with highest priority requires the always block to be sensitive to the negative edge of the clear signal and to force $q$ to $0$ immediately, independent of $clk$ or $en$. This implies an event control of the form ``@(posedge clk or negedge clr_n)`` (or the comma equivalent), and an if branch testing ``!clr_n`` that assigns $q \\leftarrow 0$ with nonblocking assignment.\n\n- Synchronous behavior on the positive edge of $clk$ when $clr_n$ is high means updates to $q$ occur only on posedge $clk$ and only when $clr_n=1$; otherwise, the asynchronous branch handles $clr_n=0$.\n\n- Clock enable means that on posedge $clk$ with $clr_n=1$, if $en=1$ then $q$ should sample $d$; if $en=0$, $q$ should hold. In a sequential always block, omitting an assignment in the $en=0$ case correctly infers hold.\n\nEvaluate each option:\n\n- A uses ``always @(posedge clk)`` and thus cannot perform an asynchronous clear that is immediate with respect to $clr_n$. Therefore it violates the asynchronous clear requirement.\n\n- B uses ``always @(posedge clk, negedge clr_n)`` and correct prioritization, but uses blocking assignments (``=``) in a sequential block. While some tools may simulate or even synthesize it, correct flip-flop modeling requires nonblocking assignments (``=``) to avoid race conditions and unintended behavior; hence it is not the correct implementation.\n\n- C uses ``always @(posedge clk, negedge clr_n)`` with nonblocking assignments and correct priority: if ``(!clr_n)`` then $q \\leftarrow 0$ asynchronously; else if ``(en)`` then $q \\leftarrow d$ on posedge $clk$; otherwise hold. This matches all specified behaviors.\n\n- D nests the clear under the enable. On ``negedge clr_n`` with ``en`` low, the clear would not execute, violating the requirement that clear has highest priority and must act regardless of en.\n\n- E includes an explicit test on ``clk`` inside the clocked always block. Although functionally redundant at posedge clk, referencing clk in the conditional is nonstandard and may not synthesize as intended; moreover, the correct template does not require nor recommend checking clk inside the if. This is not the canonical nor reliably synthesizable form compared to C.\n\nTherefore, the correct choice that unambiguously and portably implements the specified flip-flop is C.", "answer": "$$\\boxed{C}$$", "id": "1931239"}]}