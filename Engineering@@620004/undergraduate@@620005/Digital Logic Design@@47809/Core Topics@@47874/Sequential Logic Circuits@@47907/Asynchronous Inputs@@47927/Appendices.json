{"hands_on_practices": [{"introduction": "The first line of defense when introducing an external, asynchronous signal into a synchronous system is a synchronizer, often a simple D-type flip-flop. However, this defense is not absolute. This exercise explores the critical timing window defined by the flip-flop's setup ($t_{su}$) and hold ($t_{h}$) times, within which a signal transition can cause the synchronizer to enter a metastable state. By analyzing specific transition timings, you will gain a concrete understanding of when and why an asynchronous input can lead to unpredictable system behavior [@problem_id:1910774].", "problem": "A digital system uses a synchronous 8-bit binary counter designed to increment on each rising edge of a system clock, provided its Count Enable (`CEN`) input is asserted (logic '1'). The system clock has a period of $T_\\text{CLK} = 20 \\text{ ns}$. The `CEN` input is not driven directly by an external signal. Instead, to mitigate synchronization issues, an external asynchronous signal `ASYNC_ENABLE` is first passed through a D-type flip-flop (DFF) clocked by the system clock. The output of this DFF serves as the `CEN` signal for the counter.\n\nThe DFF used for synchronization has a setup time of $t_{su} = 2.0 \\text{ ns}$ and a hold time of $t_{h} = 1.0 \\text{ ns}$ relative to the rising edge of the system clock. The propagation delay of the DFF can be considered negligible for this problem.\n\nInitially, both the `ASYNC_ENABLE` signal and the resulting `CEN` signal are stable at logic '0'. At some point, the `ASYNC_ENABLE` signal transitions from '0' to '1'. We are interested in the behavior of the counter at the very next rising clock edge after this transition begins.\n\nSeveral possible timings for the `ASYNC_ENABLE` signal's low-to-high transition are given below, relative to a rising clock edge occurring at time $t=0$. For which of these scenarios is the state of the `CEN` signal immediately following the clock edge at $t=0$ unpredictable, potentially causing the counter to miss an increment or enter an incorrect state due to metastability? Select all options that apply.\n\nA. The transition occurs at $t = -3.0 \\text{ ns}$.\n\nB. The transition occurs at $t = -1.5 \\text{ ns}$.\n\nC. The transition occurs at $t = 0.5 \\text{ ns}$.\n\nD. The transition occurs at $t = 2.0 \\text{ ns}$.", "solution": "The D-type flip-flop samples its input $D$ at the rising edge of the clock, which occurs at $t=0$. For correct sampling without metastability, the input must satisfy the setup and hold constraints. This means the input signal must be stable throughout the critical time window around the sampling edge. A transition during this window violates the timing requirement.\n\nThe critical window, or timing aperture, where a transition can cause metastability is defined by the interval $(-t_{su}, t_{h})$. Any transition occurring at a time $t_{tr}$ such that $-t_{su}  t_{tr}  t_{h}$ can render the output $Q$ (the `CEN` signal) unpredictable.\n\nGiven the device parameters $t_{su} = 2.0 \\text{ ns}$ and $t_h = 1.0 \\text{ ns}$, the unsafe window for a transition is:\n$$-2.0 \\text{ ns}  t_{tr}  1.0 \\text{ ns}$$\n\nWe evaluate each option against this interval:\n- A. The transition at $t_{tr} = -3.0 \\text{ ns}$ is before the setup window begins (since $-3.0 \\le -2.0$). The input is stable during the critical window. The timing is met, and the output is predictable (it will capture the new '1' value).\n- B. The transition at $t_{tr} = -1.5 \\text{ ns}$ falls within the interval $(-2.0 \\text{ ns}, 1.0 \\text{ ns})$. This violates the setup time requirement. The output is unpredictable.\n- C. The transition at $t_{tr} = 0.5 \\text{ ns}$ falls within the interval $(-2.0 \\text{ ns}, 1.0 \\text{ ns})$. This violates the hold time requirement. The output is unpredictable.\n- D. The transition at $t_{tr} = 2.0 \\text{ ns}$ is after the hold window ends (since $2.0 \\ge 1.0$). The input is stable during the critical window. The timing is met, and the output is predictable (it will capture the old '0' value).\n\nTherefore, the scenarios where the `CEN` signal's state is unpredictable immediately after the clock edge at $t=0$ are B and C.", "answer": "$$\\boxed{BC}$$", "id": "1910774"}, {"introduction": "The dangers of asynchronicity are not limited to system inputs; they can also arise from the internal architecture of a circuit. This practice problem uses a classic asynchronous ripple counter to demonstrate how cumulative propagation delays create race conditions between state bits. You will analyze how these timing discrepancies produce a transient, invalid state that causes a combinational decoder to generate a spurious output pulse, commonly known as a glitch, highlighting a critical flaw of asynchronous logic structures [@problem_id:1910781].", "problem": "Consider a digital system composed of a 2-bit asynchronous ripple counter connected to a 2-to-4 active-high decoder. The counter is constructed from two falling-edge-triggered T flip-flops, FF0 and FF1, with their T inputs held high, causing them to toggle their output on each valid clock trigger. FF0 generates the Least Significant Bit (LSB), $Q_0$, and FF1 generates the Most Significant Bit (MSB), $Q_1$. The system clock is connected to the clock input of FF0, and the output $Q_0$ of FF0 is connected to the clock input of FF1. Each flip-flop has an identical propagation delay, $t_{pd}$, from its clock input's falling edge to its output changing state.\n\nThe counter outputs $Q_1$ and $Q_0$ are directly connected to the decoder's address inputs $A_1$ and $A_0$, respectively. The decoder has four outputs: $Y_0, Y_1, Y_2, Y_3$, where the output $Y_i$ is active (logic high) if and only if the binary input $\\langle A_1 A_0 \\rangle$ corresponds to the integer $i$. For simplicity, assume the decoder itself is ideal and its outputs respond instantaneously to any changes at its inputs.\n\nThe counter is initially stable in the state $Q_1Q_0 = 01$ (representing the integer 1). At time $t=0$, a falling edge occurs on the system clock, initiating the transition to the next count state, $Q_1Q_0 = 10$ (representing the integer 2). Due to the ripple effect and the propagation delays of the flip-flops, the system passes through a transient, unintended state before settling.\n\nDuring this entire transition sequence from the stable state '1' (`01`) to the final stable state '2' (`10`), which of the decoder output lines will generate a spurious, transient high pulse, often called a glitch?\n\nA. $Y_0$\nB. $Y_3$\nC. Both $Y_0$ and $Y_3$\nD. No spurious pulse will be generated.\nE. It is impossible to determine without the numerical value of $t_{pd}$.", "solution": "The problem asks to identify which decoder output line experiences a spurious pulse (glitch) during the state transition of a 2-bit asynchronous counter from state `01` to `10`. To solve this, we must analyze the sequence of states at the counter's outputs, paying close attention to the propagation delays.\n\n1.  **Initial State (for $t  0$):**\n    The counter is in the stable state $Q_1Q_0 = 01$. These outputs are connected to the decoder inputs, so $A_1=0$ and $A_0=1$. For the input `01` (representing integer 1), the decoder output $Y_1$ is high. All other outputs ($Y_0, Y_2, Y_3$) are low.\n\n2.  **First Event (at $t=0$):**\n    A falling edge of the system clock arrives at the clock input of the first flip-flop, FF0. Since it is a falling-edge-triggered T flip-flop with its T input held high, it is set to toggle its output, $Q_0$.\n\n3.  **First Propagation Delay and Transient State:**\n    The change in $Q_0$ does not happen instantaneously. It occurs after the propagation delay $t_{pd}$. Therefore, at time $t=t_{pd}$, the output $Q_0$ toggles from 1 to 0.\n    At this moment, the second flip-flop, FF1, has not yet acted. Its clock input is the output of FF0, $Q_0$, which has just changed. So, $Q_1$ remains at its initial value of 0.\n    For the duration starting at $t=t_{pd}$ and before the second flip-flop reacts, the state of the counter's outputs is $Q_1Q_0 = 00$.\n    This `00` state is a transient, unintended intermediate state.\n\n4.  **Decoder's Response to the Transient State:**\n    Since the decoder is ideal, it responds instantly to the new inputs $A_1=0, A_0=0$. This input corresponds to the integer 0. Consequently, the decoder deactivates $Y_1$ and activates the output $Y_0$. The output $Y_0$ goes high. This activation of $Y_0$ is the beginning of the spurious pulse, or glitch.\n\n5.  **Second Event (at $t=t_{pd}$):**\n    The output $Q_0$ changing from 1 to 0 constitutes a falling edge at the clock input of the second flip-flop, FF1.\n\n6.  **Second Propagation Delay and Final State:**\n    FF1 is also a falling-edge-triggered T flip-flop, so it will toggle its output, $Q_1$, after its propagation delay, $t_{pd}$. This state change occurs at a time $t_{pd}$ after its clock trigger, so at time $t = t_{pd} + t_{pd} = 2t_{pd}$.\n    At $t=2t_{pd}$, $Q_1$ toggles from 0 to 1. The output $Q_0$ has been 0 since $t=t_{pd}$, so it remains 0.\n    Therefore, for all time $t \\ge 2t_{pd}$, the counter outputs are stable at the new state $Q_1Q_0 = 10$. This is the correct, intended next state for the counter.\n\n7.  **Decoder's Response to the Final State:**\n    With the stable inputs $A_1=1, A_0=0$ (representing the integer 2), the decoder deactivates the transient output $Y_0$ and activates the final correct output $Y_2$.\n\n8.  **Summary of Decoder Output Behavior:**\n    - For $t  t_{pd}$, the counter state is `01`, and $Y_1$ is high.\n    - For $t_{pd} \\le t  2t_{pd}$, the transient counter state is `00`. $Y_1$ goes low, and $Y_0$ goes high. This is the glitch.\n    - For $t \\ge 2t_{pd}$, the final counter state is `10`. $Y_0$ goes low, and $Y_2$ goes high.\n\nThe decoder output $Y_0$ was not meant to be active during the transition from state 1 to state 2, but it briefly went high for a duration of $t_{pd}$ (from $t=t_{pd}$ to $t=2t_{pd}$). This constitutes a spurious pulse on the $Y_0$ line. The final answer does not depend on the specific value of $t_{pd}$, only that it is non-zero.", "answer": "$$\\boxed{A}$$", "id": "1910781"}, {"introduction": "Once an asynchronous signal has been successfully synchronized, it can be safely used by the rest of the digital system. This problem moves from analyzing hazards to a constructive design task: measuring the duration of an input pulse. You will design the necessary control logic for a counter and register to accurately capture the pulse's width in clock cycles, providing practical experience in handling timed events within a synchronous framework [@problem_id:1910750].", "problem": "You are tasked with designing a digital logic circuit to measure the duration of a single, high-going asynchronous input pulse, `PULSE_IN`. The duration must be measured in terms of the number of cycles of a synchronous system clock, `CLK`. The final count should be held in an output register until the next measurement is initiated.\n\nThe circuit must be built using the following predefined components:\n- An N-bit synchronous up-counter. It has a clock input `CLK`, a synchronous active-high reset `RESET`, and a synchronous active-high count enable `COUNT_EN`. If `RESET` is asserted (high), the counter's output is forced to zero on the next rising edge of `CLK`. If `RESET` is de-asserted (low) and `COUNT_EN` is asserted, the counter increments on the next rising edge of `CLK`. The `RESET` signal has priority over `COUNT_EN`.\n- An N-bit parallel-load register. It has a clock input `CLK` and a synchronous active-high load enable `LOAD`. When `LOAD` is asserted, the register captures its parallel data input on the next rising edge of `CLK`.\n- D-type flip-flops (D-FFs) and standard logic gates (AND, OR, NOT).\n\nFor the purpose of this problem, assume that the asynchronous input `PULSE_IN` has already been passed through a two-stage synchronizer to produce a signal `PULSE_SYNC` which is synchronous with `CLK`. You also have access to `PULSE_SYNC_D`, which is the `PULSE_SYNC` signal delayed by one `CLK` cycle (i.e., the output of a D-FF whose input is `PULSE_SYNC`).\n\nThe counter's data output is connected to the parallel-load register's data input. Your task is to determine the correct Boolean logic expressions for the control signals `RESET` (counter), `COUNT_EN` (counter), and `LOAD` (register) to correctly measure the pulse duration.\n\nWhich of the following sets of logic equations correctly implements the desired functionality?\n\nA.\n`COUNT_EN = PULSE_SYNC`\n`RESET = NOT(PULSE_SYNC)`\n`LOAD = PULSE_SYNC_D AND NOT(PULSE_SYNC)`\n\nB.\n`COUNT_EN = PULSE_SYNC`\n`RESET = PULSE_SYNC_D AND NOT(PULSE_SYNC)`\n`LOAD = NOT(PULSE_SYNC)`\n\nC.\n`COUNT_EN = PULSE_SYNC AND NOT(PULSE_SYNC_D)`\n`RESET = NOT(PULSE_SYNC)`\n`LOAD = PULSE_SYNC_D AND NOT(PULSE_SYNC)`\n\nD.\n`COUNT_EN = PULSE_SYNC`\n`RESET = NOT(PULSE_SYNC_D)`\n`LOAD = PULSE_SYNC`\n\nE.\n`COUNT_EN = PULSE_SYNC`\n`RESET = NOT(PULSE_SYNC)`\n`LOAD = NOT(PULSE_SYNC_D) AND PULSE_SYNC`", "solution": "We want the counter to measure the number of rising edges of `CLK` during which `PULSE_SYNC` is high, and then have the parallel-load register capture that count exactly once at the falling edge of `PULSE_SYNC`, holding it until the next measurement. Let the one-cycle delayed signal be `PULSE_SYNC_D`.\n\nWe can define synchronous edge detectors using the provided signals. The rising edge of the synchronized pulse is detected by $E_{r}=\\text{PULSE\\_SYNC}\\land\\lnot\\text{PULSE\\_SYNC\\_D}$, and the falling edge is detected by $E_{f}=\\text{PULSE\\_SYNC\\_D}\\land\\lnot\\text{PULSE\\_SYNC}$.\n\nA correct scheme must satisfy the following conditions:\n1.  While `PULSE_SYNC` is 1, the counter must increment every cycle. This requires the count enable logic to be $\\text{COUNT\\_EN}=\\text{PULSE\\_SYNC}$. Any gating with $\\lnot\\text{PULSE\\_SYNC\\_D}$ would only count on the first high cycle and thus undercount for multi-cycle pulses.\n\n2.  The counter must be zero at the instant counting begins. With a synchronous reset of higher priority than count enable, the robust way is to keep the counter synchronously cleared during the low time, then release the reset as soon as `PULSE_SYNC` goes high so that counting starts immediately on the first high cycle. This yields the logic $\\text{RESET}=\\lnot\\text{PULSE\\_SYNC}$. With this choice, on the rising-edge cycle (`PULSE_SYNC`=1, `PULSE_SYNC_D`=0), `RESET`=0 and `COUNT_EN`=1, so the counter increments from 0 to 1 on that very edge, correctly counting the first high cycle. During low cycles, `RESET`=1 keeps the counter at zero in preparation for the next measurement.\n\n3.  The register must capture the final count exactly at the falling edge of `PULSE_SYNC` and only then. The synchronous falling edge is characterized by (`PULSE_SYNC_D`, `PULSE_SYNC`) = (1,0). The correct load logic is therefore $\\text{LOAD}=E_{f}=\\text{PULSE\\_SYNC\\_D}\\land\\lnot\\text{PULSE\\_SYNC}$. On that clock edge, `COUNT_EN`=0 and `RESET`=1. Because both the counter and the register are edge-triggered, the register samples the counter’s pre-edge output (the correct final count), while the counter’s synchronous reset takes effect after the edge, clearing it for the next measurement without corrupting the loaded value.\n\nVerifying the cycle-by-cycle behavior:\n- Rising-edge cycle: (`PULSE_SYNC`, `PULSE_SYNC_D`) = (1,0) gives `COUNT_EN`=1, `RESET`=0, `LOAD`=0. The counter increments from 0 to 1.\n- High interior cycles: (1,1) gives `COUNT_EN`=1, `RESET`=0, `LOAD`=0. The counter continues incrementing once per cycle.\n- Falling-edge cycle: (0,1) gives `COUNT_EN`=0, `RESET`=1, `LOAD`=1. The register loads the final count; the counter is reset after the edge.\n- Low cycles after: (0,0) gives `COUNT_EN`=0, `RESET`=1, `LOAD`=0. The counter remains at zero; the register holds its value.\n\nAmong the options, only option A matches these derived equations:\n`COUNT_EN = PULSE_SYNC`\n`RESET = NOT(PULSE_SYNC)`\n`LOAD = PULSE_SYNC_D AND NOT(PULSE_SYNC)`\n\nOptions B, D, and E have incorrect `LOAD` timing. Option C has incorrect `COUNT_EN` logic which would disable counting after the first high cycle, producing an undercount.", "answer": "$$\\boxed{A}$$", "id": "1910750"}]}