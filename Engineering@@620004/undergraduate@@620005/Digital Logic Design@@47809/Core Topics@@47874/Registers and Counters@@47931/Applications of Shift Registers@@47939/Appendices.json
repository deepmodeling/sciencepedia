{"hands_on_practices": [{"introduction": "Understanding shift registers begins with mastering their fundamental operations. This exercise focuses on the meticulous, step-by-step process of tracking data movement within a bi-directional register over several clock cycles. By manually calculating the state changes based on defined shift rules and state-dependent inputs, you will build a solid intuition for how these versatile components manipulate data at the bit level [@problem_id:1958084].", "problem": "A specialized 4-bit synchronous bi-directional shift register is designed for a signal processing application. The register's bits are denoted as $Q_3, Q_2, Q_1, Q_0$, where $Q_3$ is the Most Significant Bit (MSB) and $Q_0$ is the Least Significant Bit (LSB). The register is initially loaded in parallel with the binary value `1100`.\n\nThe register's behavior is governed by the following rules for each clock cycle:\n\n1.  **Shift Right Operation**: The content of the register shifts one position to the right. The bit $Q_3$ is replaced by a serial input $SI_R$, $Q_2$ is replaced by the old $Q_3$, $Q_1$ is replaced by the old $Q_2$, and $Q_0$ is replaced by the old $Q_1$. The serial input for the right shift, $SI_R$, is determined by the state of the register *before* the shift, according to the logical expression $SI_R = Q_2 \\oplus Q_1$, where $\\oplus$ denotes the XOR operation.\n\n2.  **Shift Left Operation**: The content of the register shifts one position to the left. The bit $Q_0$ is replaced by a serial input $SI_L$, $Q_1$ is replaced by the old $Q_0$, $Q_2$ is replaced by the old $Q_1$, and $Q_3$ is replaced by the old $Q_2$. The serial input for the left shift, $SI_L$, is determined by the state of the register *before* the shift, according to the logical expression $SI_L = \\neg Q_3$, where $\\neg$ denotes the logical NOT operation.\n\nA sequence of operations is applied to the register, with each operation corresponding to one clock pulse. The sequence is:\n- Clock Pulse 1: Shift Right\n- Clock Pulse 2: Shift Right\n- Clock Pulse 3: Shift Left\n\nWhat is the final binary content of the register, expressed as the sequence $Q_3Q_2Q_1Q_0$, after the third clock pulse?\n\nA. `0011`\n\nB. `0110`\n\nC. `1100`\n\nD. `1110`\n\nE. `1111`", "solution": "The 4-bit register has bits $Q_{3}$ (MSB) through $Q_{0}$ (LSB) and is initially loaded as $Q_{3}Q_{2}Q_{1}Q_{0}=1100$, so $Q_{3}=1$, $Q_{2}=1$, $Q_{1}=0$, $Q_{0}=0$.\n\nClock Pulse 1 (Shift Right): The serial input is computed from the pre-shift state as $SI_{R}=Q_{2}\\oplus Q_{1}$. With the initial state, $SI_{R}=1\\oplus 0=1$. The shift-right update rules give\n$$\nQ_{3}\\leftarrow SI_{R}=1,\\quad Q_{2}\\leftarrow \\text{old }Q_{3}=1,\\quad Q_{1}\\leftarrow \\text{old }Q_{2}=1,\\quad Q_{0}\\leftarrow \\text{old }Q_{1}=0,\n$$\nso after this pulse $Q_{3}Q_{2}Q_{1}Q_{0}=1110$.\n\nClock Pulse 2 (Shift Right): Now compute $SI_{R}$ from the current state $1110$ as $SI_{R}=Q_{2}\\oplus Q_{1}=1\\oplus 1=0$. Apply the shift-right update:\n$$\nQ_{3}\\leftarrow 0,\\quad Q_{2}\\leftarrow \\text{old }Q_{3}=1,\\quad Q_{1}\\leftarrow \\text{old }Q_{2}=1,\\quad Q_{0}\\leftarrow \\text{old }Q_{1}=1,\n$$\nyielding $Q_{3}Q_{2}Q_{1}Q_{0}=0111$.\n\nClock Pulse 3 (Shift Left): The serial input is $SI_{L}=\\neg Q_{3}$ computed from the pre-shift state $0111$, so $SI_{L}=\\neg 0=1$. Apply the shift-left update:\n$$\nQ_{3}\\leftarrow \\text{old }Q_{2}=1,\\quad Q_{2}\\leftarrow \\text{old }Q_{1}=1,\\quad Q_{1}\\leftarrow \\text{old }Q_{0}=1,\\quad Q_{0}\\leftarrow SI_{L}=1,\n$$\ngiving the final state $Q_{3}Q_{2}Q_{1}Q_{0}=1111$, which corresponds to option E.", "answer": "$$\\boxed{E}$$", "id": "1958084"}, {"introduction": "Shift registers are more than just data movers; they are fundamental components in computational circuits. This problem demonstrates a classic application: implementing binary multiplication using the \"add-and-shift\" algorithm, a method at the heart of many processors' arithmetic logic units (ALUs). Working through this example reveals how a sequence of simple shift and addition operations, orchestrated over several clock cycles, can perform complex arithmetic tasks [@problem_id:1908895].", "problem": "Consider a digital circuit designed to multiply two 4-bit unsigned binary numbers. The multiplier uses an add-and-shift algorithm implemented with the following components:\n- Register `M`: A 4-bit register that holds the constant multiplicand.\n- Register `A`: A 4-bit accumulator, initialized to `0000`.\n- Register `Q`: A 4-bit shift register that is initially loaded with the multiplier.\n- Register `C`: A 1-bit carry register, initialized to `0`.\n\nThe multiplication process is synchronous and controlled by a clock. At each clock cycle, the following sequence of micro-operations occurs:\n1.  The least significant bit of register `Q`, denoted `$Q_0$`, is examined.\n2.  If `$Q_0$` is `1`, the multiplicand `M` is added to the accumulator `A`. The 4-bit result is stored back in `A`, and the carry-out of the addition is stored in the carry register `C`. If `$Q_0$` is `0`, `A` and `C` are unchanged.\n3.  The combined 9-bit register formed by `C`, `A`, and `Q` (in the order `C:A:Q`) is shifted one bit to the right. The bit from `C` shifts into the most significant bit of `A` (`$A_3$`), the least significant bit of `A` (`$A_0$`) shifts into the most significant bit of `Q` (`$Q_3$`), and the least significant bit of `Q` (`$Q_0$`) is discarded.\n4.  After the shift, the carry register `C` is reset to `0` to prepare for the next cycle's potential addition.\n\nSuppose the multiplicand register `M` is loaded with the value `1101` and the multiplier register `Q` is loaded with `1011`. The system is initialized with `A = 0000` and `C = 0` before the first clock cycle.\n\nDetermine the contents of registers `A` and `Q` after the system has completed exactly three full clock cycles. Present your answer as a single 8-bit binary string, representing the concatenation of the contents of register `A` followed by the contents of register `Q`. For example, if at some point `A = 0001` and `Q = 1010`, the corresponding string would be `00011010`.", "solution": "We simulate the specified add-and-shift multiplication for three cycles with $M=1101$, initial $A=0000$, $Q=1011$, and $C=0$. At each cycle:\n- If $Q_{0}=1$, compute the 4-bit sum $A \\leftarrow A+M$ with carry-out to $C$; if $Q_{0}=0$, leave $A$ and $C$ unchanged.\n- Perform a right shift of the 9-bit $C:A:Q$:\n  $$A_{3} \\leftarrow C,\\quad A_{2} \\leftarrow A_{3},\\quad A_{1} \\leftarrow A_{2},\\quad A_{0} \\leftarrow A_{1},$$\n  $$Q_{3} \\leftarrow A_{0}\\ \\text{(old)},\\quad Q_{2} \\leftarrow Q_{3},\\quad Q_{1} \\leftarrow Q_{2},\\quad Q_{0} \\leftarrow Q_{1},$$\n  then reset $C \\leftarrow 0$.\n\nCycle 1:\n- $Q_{0}=1$, so add $M$ to $A$:\n  $$A \\leftarrow 0000+1101=1101,\\quad C \\leftarrow 0.$$\n- Shift right $C:A:Q = 0:1101:1011$:\n  $$A \\leftarrow 0110,\\quad Q \\leftarrow 1101,\\quad C \\leftarrow 0.$$\n\nCycle 2:\n- $Q_{0}=1$, so add $M$ to $A$:\n  $$A \\leftarrow 0110+1101=0011,\\quad C \\leftarrow 1.$$\n- Shift right $C:A:Q = 1:0011:1101$:\n  $$A \\leftarrow 1001,\\quad Q \\leftarrow 1110,\\quad C \\leftarrow 0.$$\n\nCycle 3:\n- $Q_{0}=0$, so no addition:\n  $$A \\leftarrow 1001,\\quad C \\leftarrow 0.$$\n- Shift right $C:A:Q = 0:1001:1110$:\n  $$A \\leftarrow 0100,\\quad Q \\leftarrow 1111,\\quad C \\leftarrow 0.$$\n\nAfter exactly three full clock cycles, the contents are $A=0100$ and $Q=1111$, so the requested 8-bit string (concatenation $A$ followed by $Q$) is $01001111$.", "answer": "$$\\boxed{01001111}$$", "id": "1908895"}, {"introduction": "A correct conceptual design is only as good as its implementation, and in digital design, the details of the Hardware Description Language (HDL) are critical. This practice problem highlights a common and significant pitfall when translating a shift register design into Verilog code: the misuse of blocking (`=`) versus non-blocking (`<=`) assignments. Analyzing the behavior of this flawed code will provide invaluable insight into how sequential logic is synthesized and why precise coding practices are essential for creating functional hardware [@problem_id:1915890].", "problem": "A junior engineer is designing a 4-bit register as part of a larger digital system using a Hardware Description Language (HDL), specifically Verilog. The register has a synchronous reset, a parallel load capability, and a serial shift-right function. The engineer produced the following code snippet, which contains a subtle but critical flaw.\n\nThe relevant signals and registers are declared as follows:\n- `clk`: The master clock signal.\n- `rst`: A synchronous, active-high reset signal.\n- `load`: A control signal that, when high, enables parallel loading of data.\n- `p_in`: A 4-bit input `[3:0]` for parallel loading.\n- `s_in`: A 1-bit serial input for the shift operation.\n- `q3`, `q2`, `q1`, `q0`: Four 1-bit registers that form the 4-bit state of the system.\n\nThe sequential logic is described by the following `always` block:\n```verilog\nalways @(posedge clk) begin\n    if (rst) begin\n        q3 = 1'b0;\n        q2 = 1'b0;\n        q1 = 1'b0;\n        q0 = 1'b0;\n    end else if (load) begin\n        q3 = p_in[3];\n        q2 = p_in[2];\n        q1 = p_in[1];\n        q0 = p_in[0];\n    end else begin\n        // Intended shift-right operation\n        q3 = s_in;\n        q2 = q3;\n        q1 = q2;\n        q0 = q1;\n    end\nend\n```\nThe state of the register is represented by the concatenated value `{q3, q2, q1, q0}`, where `q3` is the most significant bit (MSB). Initially, the state of the registers is unknown. The system is then subjected to the following input sequence, which is sampled at the positive edge of `clk`:\n\n- At the 1st positive clock edge: `rst = 1'b1`.\n- At the 2nd positive clock edge: `rst = 1'b0`, `load = 1'b1`, `p_in = 4'b1011`.\n- At the 3rd positive clock edge: `rst = 1'b0`, `load = 1'b0`, `s_in = 1'b1`.\n\nWhat is the decimal value of the register, interpreted as `{q3, q2, q1, q0}`, immediately after the 3rd positive clock edge?\n\nA. 11\n\nB. 13\n\nC. 14\n\nD. 15\n\nE. 8", "solution": "The problem requires us to trace the state of the four 1-bit registers (`q3`, `q2`, `q1`, `q0`) through three consecutive positive clock edges, based on a given Verilog code snippet. The key to solving this problem is to correctly interpret the behavior of the blocking assignments, denoted by the `=` operator, within the sequential `always` block.\n\n**Initial State:** Before the first clock edge, the values of `q3, q2, q1, q0` are unknown (`xxxx`).\n\n**1st Positive Clock Edge:**\nAt the first `posedge clk`, the inputs are sampled. The `rst` signal is high (`1'b1`).\nThe `if (rst)` condition in the `always` block is true.\nThe code executes the reset block:\n```verilog\nq3 = 1'b0;\nq2 = 1'b0;\nq1 = 1'b0;\nq0 = 1'b0;\n```\nAll four registers are assigned the value `0`.\nThe state of the register `{q3, q2, q1, q0}` becomes `4'b0000`.\n\n**2nd Positive Clock Edge:**\nAt the second `posedge clk`, the inputs `rst = 1'b0`, `load = 1'b1`, and `p_in = 4'b1011` are sampled.\n- The `if (rst)` condition is false.\n- The `else if (load)` condition is true.\nThe code executes the parallel load block:\n```verilog\nq3 = p_in[3]; // q3 = 1'b1\nq2 = p_in[2]; // q2 = 1'b0\nq1 = p_in[1]; // q1 = 1'b1\nq0 = p_in[0]; // q0 = 1'b1\n```\nThe registers are loaded with the parallel input data. Even though these are blocking assignments, there are no dependencies between the statements in this block (the value of `q3` is not used to determine `q2`, etc.), so the behavior is straightforward.\nThe state of the register `{q3, q2, q1, q0}` becomes `4'b1011`.\n\n**3rd Positive Clock Edge:**\nThis is the critical step for analysis. At the third `posedge clk`, the inputs `rst = 1'b0`, `load = 1'b0`, and `s_in = 1'b1` are sampled. The state of the register just before this clock edge is `4'b1011`.\n- The `if (rst)` condition is false.\n- The `else if (load)` condition is false.\nThe code executes the final `else` block, which contains the faulty shift implementation:\n```verilog\nq3 = s_in;\nq2 = q3;\nq1 = q2;\nq0 = q1;\n```\nBecause these are blocking assignments (`=`), each statement is executed sequentially, and the result of one assignment is immediately visible to the next statement within the same simulation time step. Let's trace the execution:\n1.  `q3 = s_in;`\n    The value of `s_in` is `1'b1`. The register `q3` is updated to `1`. The value of `q3` is now `1` for the subsequent statements in this block.\n\n2.  `q2 = q3;`\n    This statement reads the *new* value of `q3`, which was just set to `1`. Therefore, `q2` is updated to `1`. The value of `q2` is now `1` for the subsequent statements.\n\n3.  `q1 = q2;`\n    This statement reads the *new* value of `q2`, which was just set to `1`. Therefore, `q1` is updated to `1`. The value of `q1` is now `1` for the subsequent statements.\n\n4.  `q0 = q1;`\n    This statement reads the *new* value of `q1`, which was just set to `1`. Therefore, `q0` is updated to `1`.\n\nAfter all statements in the block have been executed, the final state of the registers is updated. The result is that the value of `s_in` (`1'b1`) has propagated through the entire chain of registers in a single clock cycle.\nThe state of the register `{q3, q2, q1, q0}` becomes `4'b1111`.\n\nThis behavior is incorrect for a shift register, which should shift the contents by one position per clock cycle. A correct implementation would use non-blocking assignments (`<=`), which schedule all updates to occur simultaneously at the end of the time step, using the values of the variables as they were at the beginning of the time step.\n\nFinally, we convert the binary result to decimal:\nThe binary value `1111_2` is calculated as $1 \\times 2^{3} + 1 \\times 2^{2} + 1 \\times 2^{1} + 1 \\times 2^{0} = 8 + 4 + 2 + 1 = 15$.\n\nTherefore, the decimal value of the register after the 3rd clock edge is 15. This corresponds to option D.\nThe common incorrect answer is 13, which would result from assuming the code implements a correct shift-right operation (yielding `{s_in, q3, q2, q1}` = `{1, 1, 0, 1}` = `4'b1101`) or from misinterpreting the blocking assignments as non-blocking.", "answer": "$$\\boxed{D}$$", "id": "1915890"}]}