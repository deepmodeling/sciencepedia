{"hands_on_practices": [{"introduction": "This first practice lays the groundwork for register design by tackling a common scenario: how to build a register that can choose its input from multiple data sources. By designing the input logic for a single bit-slice [@problem_id:1958039], you will see how a multiplexer serves as a \"gatekeeper\" for a D flip-flop. This is a fundamental concept for constructing register files and managing data pathways within a processor.", "problem": "In the design of a processor's register file, a common requirement is to create a register that can be loaded with data from one of several sources. Consider a single bit-slice of such a register, which is implemented using one D-type flip-flop. The flip-flop captures its data input $D$ and holds it at its output $Q$ upon the rising edge of a clock signal `CLK`.\n\nThis particular register stage must be able to load its data from one of two 1-bit input buses, $A$ or $B$. A selection line, $S$, controls which source is used. The behavior is specified as follows:\n- If the selection line $S$ is logic 0, the flip-flop should load the value from input $A$ on the next rising clock edge.\n- If the selection line $S$ is logic 1, the flip-flop should load the value from input $B$ on the next rising clock edge.\n\nUsing standard Boolean algebra notation where addition ($+$) represents the OR operation, multiplication (implicit by concatenation) represents the AND operation, and a prime symbol (e.g., $S'$) represents the NOT operation, which of the following expressions correctly defines the logic for the data input $D$ of the D-flip-flop?\n\nA. $D = SA + S'B$\n\nB. $D = S'A + SB$\n\nC. $D = A \\oplus B$\n\nD. $D = (S+A)(S+B)$\n\nE. $D = AB + S$", "solution": "The D-type flip-flop captures the value present at its data input $D$ on the rising edge of $CLK$. The register must choose its $D$ input from either $A$ or $B$ depending on the selection line $S$, with the specified behavior:\n- If $S=0$, then $D$ must equal $A$.\n- If $S=1$, then $D$ must equal $B$.\n\nA standard Boolean construction that selects $X$ when $Z=0$ and $Y$ when $Z=1$ is given by:\n$$\nf(X,Y,Z)=XZ' + YZ.\n$$\nTo verify:\n- If $Z=0$, then $f=X(1)+Y(0)=X$.\n- If $Z=1$, then $f=X(0)+Y(1)=Y$.\n\nApplying this with $X=A$, $Y=B$, and $Z=S$, the required data input is:\n$$\nD = AS' + BS = S'A + SB.\n$$\nCheck against the given behavior:\n- For $S=0$: $D = A(1) + B(0) = A$.\n- For $S=1$: $D = A(0) + B(1) = B$.\nThus this expression meets the specification.\n\nFor completeness, the other options are incorrect:\n- $SA + S'B$ would give $D=B$ when $S=0$, which contradicts the requirement.\n- $A \\oplus B$ ignores $S$ entirely.\n- $(S+A)(S+B)$ simplifies to $S + AB$, which does not implement selection by $S$.\n- $AB + S$ is also $S + AB$, not a selector.\n\nTherefore, the correct choice is $D = S'A + SB$.", "answer": "$$\\boxed{B}$$", "id": "1958039"}, {"introduction": "Moving beyond simple data selection, this exercise explores how to integrate control functions into a register's design. You will determine the logic required for a register that can either perform a parallel load from an input bus or execute a synchronous clear, forcing its state to all zeros [@problem_id:1958102]. This demonstrates the versatility of using selection logic to implement essential operations like system resets and initializations.", "problem": "A 4-bit synchronous digital register is to be designed. The register has a 4-bit parallel data input bus, $I[3:0]$, a single control input $M$, and a clock input `CLK`. The output of the register is the 4-bit stored value, $Q[3:0]$. The register is constructed using positive-edge-triggered D flip-flops, one for each bit.\n\nThe behavior of the register is determined by the control input $M$ at the rising edge of the clock signal `CLK`, as follows:\n- If $M = 0$, the register performs a parallel load operation, capturing the value from the input bus $I$.\n- If $M = 1$, the register is cleared, meaning its state is reset to `0000`.\n\nWhich of the following Boolean expressions correctly represents the logic required for the data input of the D flip-flop corresponding to bit 2, denoted as $D_{in,2}$? In the options below, $I_2$ is the second bit of the input bus, $Q_2$ is the second bit of the output, multiplication ($\\cdot$) represents logical AND, addition ($+$) represents logical OR, $\\oplus$ represents logical XOR, and $\\overline{M}$ represents the logical NOT of $M$.\n\nA. $D_{in,2} = M \\cdot I_2$\n\nB. $D_{in,2} = \\overline{M} \\cdot I_2 + M \\cdot Q_2$\n\nC. $D_{in,2} = \\overline{M} \\cdot I_2$\n\nD. $D_{in,2} = M \\oplus I_2$\n\nE. $D_{in,2} = \\overline{M} \\cdot I_2 + M$", "solution": "We consider the positive-edge-triggered D flip-flop that stores bit 2. The specified synchronous behavior at each rising edge of $CLK$ is:\n- If $M=0$, perform a parallel load: $Q_{2}^{+}=I_{2}$.\n- If $M=1$, clear: $Q_{2}^{+}=0$.\n\nSince a D flip-flop takes its next state directly from its input, we require the combinational input $D_{in,2}$ to implement the function\n$$\nD_{in,2} =\n\\begin{cases}\nI_{2}, & M=0,\\\\\n0, & M=1.\n\\end{cases}\n$$\nThis is a 2-to-1 multiplexer controlled by $M$, selecting between $I_{2}$ (when $M=0$) and $0$ (when $M=1$). The standard Boolean realization is\n$$\nD_{in,2}=\\overline{M}\\cdot I_{2}+M\\cdot 0=\\overline{M}\\cdot I_{2}.\n$$\nNow verify against the options:\n- A: $M\\cdot I_{2}$ gives $0$ when $M=0$, not $I_{2}$; incorrect.\n- B: $\\overline{M}\\cdot I_{2}+M\\cdot Q_{2}$ holds the previous state when $M=1$, not clearing to $0$; incorrect.\n- C: $\\overline{M}\\cdot I_{2}$ matches the derived expression; correct.\n- D: $M\\oplus I_{2}$ toggles based on $M$, unrelated to load/clear; incorrect.\n- E: $\\overline{M}\\cdot I_{2}+M$ yields $1$ when $M=1$, which sets, not clears; incorrect.\n\nTherefore, the correct choice is C.", "answer": "$$\\boxed{C}$$", "id": "1958102"}, {"introduction": "This final practice challenges you with a more advanced and practical design: a register that allows for selective, bit-by-bit updates using a \"mask\" input. You will trace the register's state over several clock cycles to understand how its contents evolve based on a sequence of data and mask inputs [@problem_id:1958064]. This exercise solidifies your understanding of synchronous operation and illustrates a powerful technique used in graphics processing, networking hardware, and other high-performance computing applications.", "problem": "A special-purpose 4-bit synchronous register, known as a Selective Update Register, is being analyzed. This register has a 4-bit data input $D[3:0]$, a 4-bit mask input $M[3:0]$, and a clock input `CLK`. The bits are indexed from right to left, so `D[0]` is the least significant bit. The register's state is represented by $Q[3:0]$.\n\nThe register updates its state on the rising edge of the `CLK` signal according to the following rules for each bit `i` from 0 to 3:\n- If the mask bit $M[i]$ is '1', the corresponding state bit $Q[i]$ is updated with the value of the data input bit $D[i]$.\n- If the mask bit $M[i]$ is '0', the corresponding state bit $Q[i]$ holds its previous value, ignoring the data input bit $D[i]$.\n\nInitially, at time $t=0$, the register holds the binary value `1010`. Over the next three consecutive clock cycles, the following data and mask inputs are applied:\n- At the 1st rising clock edge: $D = 1100$, $M = 0101$\n- At the 2nd rising clock edge: $D = 0111$, $M = 1100$\n- At the 3rd rising clock edge: $D = 1001$, $M = 1010$\n\nDetermine the value stored in the register $Q$ immediately after the 3rd rising clock edge. Provide your answer as the decimal equivalent of the final 4-bit binary value.", "solution": "We model the selective update per bit using the rule: for each bit index $i \\in \\{0,1,2,3\\}$ at a rising edge,\n$$\nQ^{+}[i] = \n\\begin{cases}\nD[i], & \\text{if } M[i] = 1,\\\\\nQ[i], & \\text{if } M[i] = 0.\n\\end{cases}\n$$\nEquivalently, in Boolean algebra with binary values,\n$$\nQ^{+}[i] = M[i]\\cdot D[i] + \\left(1 - M[i]\\right)\\cdot Q[i].\n$$\nInitial state at $t=0$: $Q=1010$ so $(Q[3],Q[2],Q[1],Q[0])=(1,0,1,0)$.\n\nFirst rising edge with $D=1100$ and $M=0101$:\n- $i=3$: $M[3]=0 \\Rightarrow Q^{+}[3]=Q[3]=1$.\n- $i=2$: $M[2]=1 \\Rightarrow Q^{+}[2]=D[2]=1$.\n- $i=1$: $M[1]=0 \\Rightarrow Q^{+}[1]=Q[1]=1$.\n- $i=0$: $M[0]=1 \\Rightarrow Q^{+}[0]=D[0]=0$.\nThus after the 1st edge: $Q=1110$.\n\nSecond rising edge with $D=0111$ and $M=1100$, starting from $Q=1110$:\n- $i=3$: $M[3]=1 \\Rightarrow Q^{+}[3]=D[3]=0$.\n- $i=2$: $M[2]=1 \\Rightarrow Q^{+}[2]=D[2]=1$.\n- $i=1$: $M[1]=0 \\Rightarrow Q^{+}[1]=Q[1]=1$.\n- $i=0$: $M[0]=0 \\Rightarrow Q^{+}[0]=Q[0]=0$.\nThus after the 2nd edge: $Q=0110$.\n\nThird rising edge with $D=1001$ and $M=1010$, starting from $Q=0110$:\n- $i=3$: $M[3]=1 \\Rightarrow Q^{+}[3]=D[3]=1$.\n- $i=2$: $M[2]=0 \\Rightarrow Q^{+}[2]=Q[2]=1$.\n- $i=1$: $M[1]=1 \\Rightarrow Q^{+}[1]=D[1]=0$.\n- $i=0$: $M[0]=0 \\Rightarrow Q^{+}[0]=Q[0]=0$.\nThus after the 3rd edge: $Q=1100$.\n\nThe final 4-bit value $1100$ equals $1\\cdot 2^{3} + 1\\cdot 2^{2} + 0\\cdot 2^{1} + 0\\cdot 2^{0} = 8 + 4 = 12$ in decimal.", "answer": "$$\\boxed{12}$$", "id": "1958064"}]}