{"hands_on_practices": [{"introduction": "Before designing complex digital systems, it's crucial to master the fundamentals. This first practice focuses on the core behavior of a synchronous counter with parallel load capability [@problem_id:1925182]. By tracing the counter's state through a sequence of operations, you will build a solid intuition for how the `Load` signal directly controls whether the circuit loads a new value or increments its current one, a key principle in creating programmable state machines.", "id": "1925182", "problem": "A digital system incorporates a 2-bit synchronous binary up-counter with parallel load capability. The counter's state is represented by the outputs $Q_1Q_0$. The counter has two data inputs, $D_1$ and $D_0$, and an active-high synchronous load enable signal, `Load`. The behavior of the counter is determined by the `Load` signal just before the rising edge of the system clock signal, `CLK`:\n\n- If `Load` is high (logic 1), on the next rising edge of `CLK`, the counter loads the values from the data inputs, such that the new state becomes $Q_1Q_0 = D_1D_0$.\n- If `Load` is low (logic 0), on the next rising edge of `CLK`, the counter increments its current value by one. The count sequence is 00, 01, 10, 11, and then it wraps around back to 00.\n\nThe counter is initially in the state $Q_1Q_0 = 00$. The system experiences a sequence of six rising clock edges. The values of the `Load` signal and the data inputs $D_1D_0$ are held stable just before each corresponding clock edge as follows:\n\n- Before clock edge 1: `Load` = 1, $D_1D_0$ = 10\n- Before clock edge 2: `Load` = 0\n- Before clock edge 3: `Load` = 0\n- Before clock edge 4: `Load` = 1, $D_1D_0$ = 01\n- Before clock edge 5: `Load` = 0\n- Before clock edge 6: `Load` = 0\n\nWhat is the binary state of the counter, $Q_1Q_0$, immediately after the 6th rising clock edge?\n\nA. 00\nB. 01\nC. 10\nD. 11\n\n", "solution": "Define the synchronous update rule on each rising edge of the clock:\n$$\n(Q_1Q_0)^{+} =\n\\begin{cases}\nD_1D_0, & \\text{if Load}=1,\\\\\n(Q_1Q_0)+1 \\pmod{4}, & \\text{if Load}=0,\n\\end{cases}\n$$\nwhere $(Q_1Q_0)$ is interpreted as a 2-bit binary number and the result is written as a 2-bit binary state.\n\nThe initial state is $Q_1Q_0=00$.\n\nClock edge 1: Load $=1$, $D_1D_0=10$. Therefore,\n$$\n(Q_1Q_0)^{+} = D_1D_0 = 10.\n$$\nNew state: $10$.\n\nClock edge 2: Load $=0$. Therefore,\n$$\n10 \\to 11.\n$$\nNew state: $11$.\n\nClock edge 3: Load $=0$. Therefore,\n$$\n11 \\to 00 \\quad (\\text{wrap around}).\n$$\nNew state: $00$.\n\nClock edge 4: Load $=1$, $D_1D_0=01$. Therefore,\n$$\n(Q_1Q_0)^{+} = D_1D_0 = 01.\n$$\nNew state: $01$.\n\nClock edge 5: Load $=0$. Therefore,\n$$\n01 \\to 10.\n$$\nNew state: $10$.\n\nClock edge 6: Load $=0$. Therefore,\n$$\n10 \\to 11.\n$$\nNew state after the sixth edge: $11$, which corresponds to option D.", "answer": "$$\\boxed{D}$$"}, {"introduction": "Digital circuits can fail, and a key engineering skill is diagnosing the problem from its symptoms. This practice moves beyond ideal operation into the practical realm of troubleshooting [@problem_id:1925179]. You are presented with a counter that shows faulty behavior only during its parallel load operation, forcing you to deduce the specific single-gate fault by analyzing how the internal logic must be failing.", "id": "1925179", "problem": "A custom-built 4-bit synchronous binary up-counter is exhibiting faulty behavior. The counter is designed using D-type flip-flops (D-FFs) for the state registers $Q_3, Q_2, Q_1, Q_0$. It includes a parallel load feature controlled by an active-high signal, `LOAD`. When `LOAD` is high, the data from parallel inputs $D_3, D_2, D_1, D_0$ should be loaded into the flip-flops on the next active clock edge. When `LOAD` is low, the counter should increment its value.\n\nThe internal logic for the input of each D-FF, denoted $FF_i$, is implemented using a standard 2-to-1 multiplexer structure described by the Boolean equation:\n$$FF_i = (\\text{CountInput}_i \\cdot \\overline{\\text{LOAD}}) + (D_i \\cdot \\text{LOAD})$$\nwhere $\\text{CountInput}_i$ represents the logic for the next state value during a count operation. The term $(D_i \\cdot \\text{LOAD})$ is implemented using a dedicated 2-input AND gate for each bit $i$.\n\nA technician runs a series of diagnostics and records the following observations:\n1.  With the `LOAD` signal held low, the counter functions perfectly, correctly cycling through all 16 states from $0000_2$ to $1111_2$.\n2.  When the `LOAD` signal is asserted (set to high) and the parallel data inputs are set to $D_3D_2D_1D_0 = 1010_2$, the value that gets loaded into the counter on the next clock edge is observed to be $Q_3Q_2Q_1Q_0 = 1000_2$.\n3.  As a follow-up test, with the `LOAD` signal asserted and the parallel data inputs set to $D_3D_2D_1D_0 = 0101_2$, the value loaded into the counter is observed to be $Q_3Q_2Q_1Q_0 = 0101_2$.\n\nAssuming there is only a single gate fault in the entire circuit (i.e., the output of one specific gate is permanently stuck-at-0 or stuck-at-1), which of the following options is the most likely cause of the observed behavior?\n\nA. The output of the AND gate implementing the term $(D_1 \\cdot \\text{LOAD})$ is stuck-at-0.\nB. The output of the AND gate implementing the term $(D_1 \\cdot \\text{LOAD})$ is stuck-at-1.\nC. The `LOAD` input to the logic circuitry for the $Q_1$ flip-flop is stuck-at-0.\nD. The output of the final OR gate that combines the two terms for the $FF_1$ input is stuck-at-0.\nE. The output of the final OR gate that combines the two terms for the $FF_1$ input is stuck-at-1.\n\n", "solution": "Let the control signal be denoted by $L=\\mathrm{LOAD}$ and define $C_{i}=\\mathrm{CountInput}_{i}$. The intended input to each flip-flop is\n$$FF_{i}=(C_{i}\\cdot \\overline{L})+(D_{i}\\cdot L).$$\nObservation 1 states that with $L=0$ the counter counts perfectly through all $16$ states. Substituting $L=0$ gives\n$$FF_{i}=(C_{i}\\cdot 1)+(D_{i}\\cdot 0)=C_{i}.$$\nTherefore, any fault that would force $FF_{1}$ to a constant $0$ or $1$ when $L=0$ is impossible, because that would break counting. Immediately:\n- If the output of the AND gate $(D_{1}\\cdot L)$ were stuck-at-$1$ (option B), then $FF_{1}=(C_{1}\\cdot \\overline{L})+1=1$ for all $L$, contradicting Observation 1.\n- If the final OR output for $FF_{1}$ were stuck-at-$0$ (option D), then $FF_{1}=0$ always; counting would fail. Contradiction.\n- If the final OR output for $FF_{1}$ were stuck-at-$1$ (option E), then $FF_{1}=1$ always; counting would fail. Contradiction.\n\nNow consider loading with $L=1$. Ideally,\n$$FF_{1}=(C_{1}\\cdot 0)+(D_{1}\\cdot 1)=D_{1}.$$\nObservation 2 sets $D_{3}D_{2}D_{1}D_{0}=1010$ and the loaded result is $1000$. Only bit $1$ fails: $D_{1}=1$ but $Q_{1}=0$. Observation 3 sets $D_{3}D_{2}D_{1}D_{0}=0101$ and the loaded result is $0101$, so $D_{1}=0$ yields $Q_{1}=0$ correctly. These two observations together imply that, when $L=1$, the function feeding $FF_{1}$ evaluates to $0$ regardless of $D_{1}$.\n\nIf the output of the AND gate implementing $(D_{1}\\cdot L)$ is stuck-at-$0$ (option A), then\n$$FF_{1}=(C_{1}\\cdot \\overline{L})+0.$$\nThus:\n- For $L=0$, $FF_{1}=C_{1}$, so counting works, matching Observation 1.\n- For $L=1$, $FF_{1}=0$ regardless of $D_{1}$, so a requested load of $D_{1}=1$ yields $Q_{1}=0$ (Observation 2), and a requested load of $D_{1}=0$ yields $Q_{1}=0$ (Observation 3). Other bits load correctly because their gates are not faulty, matching the recorded patterns.\n\nConsider option C (the $L$ input to the $Q_{1}$ logic stuck-at-$0$). In that case the local logic sees $L=0$ always and produces\n$$FF_{1}=(C_{1}\\cdot 1)+(D_{1}\\cdot 0)=C_{1}$$\neven when $L=1$. This would make $Q_{1}$ depend on $C_{1}$ (the counter’s next-state function) rather than on $D_{1}$ during a load, so the outcomes in Observations 2 and 3 would depend on the prior state and need not match the specific pattern observed. In contrast, a stuck-at-$0$ at $(D_{1}\\cdot L)$ deterministically produces the exact outcomes seen, independent of prior state.\n\nTherefore, the single stuck-at fault that is fully consistent with all observations is the output of the AND gate implementing $(D_{1}\\cdot \\mathrm{LOAD})$ being stuck-at-$0$.", "answer": "$$\\boxed{A}$$"}, {"introduction": "Having mastered operation and analysis, the final step is synthesis and design. This exercise [@problem_id:1925209] challenges you to create a versatile, programmable counter by designing the input logic for one of its state bits. You will integrate multiple control signals—for loading, holding, and counting up or down—based on a specified priority, translating a functional description into a concrete Boolean expression.", "id": "1925209", "problem": "You are tasked with designing the control logic for a custom 4-bit synchronous counter. The counter's state is represented by four bits, $Q_3, Q_2, Q_1, Q_0$, where $Q_0$ is the least significant bit. The counter is constructed from D-type flip-flops, meaning the value of each bit $Q_i$ on the next clock cycle is determined by the logic level at the corresponding input, $D_i$.\n\nThe counter must support several operations determined by three active-high control signals: `L` (Load), `E` (Enable), and `U` (Up/Down direction). The operations are prioritized as follows:\n\n1.  **Parallel Load (Highest Priority):** If `L` is high (1), the counter ignores all other control signals. On the next active clock edge, the counter's state $Q_3Q_2Q_1Q_0$ is loaded with the values from four parallel data inputs, $P_3, P_2, P_1, P_0$.\n2.  **Hold State:** If `L` is low (0) and `E` is low (0), the counter holds its current state.\n3.  **Count (Lowest Priority):** If `L` is low (0) and `E` is high (1), the counter performs a count operation. The direction is determined by the `U` signal:\n    *   If `U=1`, the counter increments its value (counts up). For example, a state of `0101` becomes `0110`.\n    *   If `U=0`, the counter decrements its value (counts down). For example, a state of `0101` becomes `0100`.\n    The counting operation includes wrap-around behavior (e.g., when counting up from `1111`, the next state is `0000`; when counting down from `0000`, the next state is `1111`).\n\nYour task is to derive the complete Boolean logic expression for the input $D_2$ of the flip-flop corresponding to the state bit $Q_2$. Present your answer as a sum-of-products expression. The expression should be formulated in terms of the state bits $Q_2, Q_1, Q_0$, the parallel input $P_2$, and the control signals $L, E, U$.\n\n", "solution": "Let $D_{2}$ denote the next-state input of the flip-flop producing $Q_{2}$. The prioritized control behavior is:\n1) If $L=1$, parallel load overrides all else, so $D_{2}=P_{2}$.\n2) If $L=0$ and $E=0$, the counter holds its state, so $D_{2}=Q_{2}$.\n3) If $L=0$ and $E=1$, the counter counts. For counting up, bit $Q_{2}$ toggles when there is a carry from the lower bits, i.e., when $Q_{1}Q_{0}=1$. Thus for up-counting,\n$$\nD_{2}=\\;Q_{2}\\oplus(Q_{1}Q_{0}) \\;=\\; Q_{2}\\overline{Q_{1}Q_{0}}+\\overline{Q_{2}}\\,Q_{1}Q_{0}\n\\;=\\; Q_{2}\\overline{Q_{1}}+Q_{2}\\overline{Q_{0}}+\\overline{Q_{2}}\\,Q_{1}Q_{0}.\n$$\nFor counting down, bit $Q_{2}$ toggles when there is a borrow from the lower bits, i.e., when $\\overline{Q_{1}}\\overline{Q_{0}}=1$. Thus for down-counting,\n$$\nD_{2}=\\;Q_{2}\\oplus(\\overline{Q_{1}}\\overline{Q_{0}}) \\;=\\; Q_{2}\\,\\overline{\\overline{Q_{1}}\\overline{Q_{0}}}+\\overline{Q_{2}}\\,\\overline{Q_{1}}\\overline{Q_{0}}\n\\;=\\; Q_{2}(Q_{1}+Q_{0})+\\overline{Q_{2}}\\,\\overline{Q_{1}}\\overline{Q_{0}}\n\\;=\\; Q_{2}Q_{1}+Q_{2}Q_{0}+\\overline{Q_{2}}\\,\\overline{Q_{1}}\\overline{Q_{0}}.\n$$\nUsing $U$ to select the direction when $L=0$ and $E=1$, and incorporating the priority of $L$, the complete logic is\n$$\nD_{2}=L\\,P_{2}+\\overline{L}\\,\\overline{E}\\,Q_{2}+\\overline{L}\\,E\\Big[U\\big(Q_{2}\\overline{Q_{1}}+Q_{2}\\overline{Q_{0}}+\\overline{Q_{2}}\\,Q_{1}Q_{0}\\big)+\\overline{U}\\big(Q_{2}Q_{1}+Q_{2}Q_{0}+\\overline{Q_{2}}\\,\\overline{Q_{1}}\\overline{Q_{0}}\\big)\\Big].\n$$\nExpanding to an explicit sum-of-products yields\n$$\nD_{2}\n= L P_{2}\n+ \\overline{L}\\,\\overline{E}\\,Q_{2}\n+ \\overline{L}\\,E\\,U\\,Q_{2}\\,\\overline{Q_{1}}\n+ \\overline{L}\\,E\\,U\\,Q_{2}\\,\\overline{Q_{0}}\n+ \\overline{L}\\,E\\,U\\,\\overline{Q_{2}}\\,Q_{1}\\,Q_{0}\n+ \\overline{L}\\,E\\,\\overline{U}\\,Q_{2}\\,Q_{1}\n+ \\overline{L}\\,E\\,\\overline{U}\\,Q_{2}\\,Q_{0}\n+ \\overline{L}\\,E\\,\\overline{U}\\,\\overline{Q_{2}}\\,\\overline{Q_{1}}\\,\\overline{Q_{0}}.\n$$\nThis is the required sum-of-products expression in terms of $Q_{2},Q_{1},Q_{0},P_{2},L,E,U$ with the correct priority behavior.", "answer": "$$\\boxed{L P_{2}+\\overline{L}\\,\\overline{E}\\,Q_{2}+\\overline{L}\\,E\\,U\\,Q_{2}\\,\\overline{Q_{1}}+\\overline{L}\\,E\\,U\\,Q_{2}\\,\\overline{Q_{0}}+\\overline{L}\\,E\\,U\\,\\overline{Q_{2}}\\,Q_{1}\\,Q_{0}+\\overline{L}\\,E\\,\\overline{U}\\,Q_{2}\\,Q_{1}+\\overline{L}\\,E\\,\\overline{U}\\,Q_{2}\\,Q_{0}+\\overline{L}\\,E\\,\\overline{U}\\,\\overline{Q_{2}}\\,\\overline{Q_{1}}\\,\\overline{Q_{0}}}$$"}]}