{"hands_on_practices": [{"introduction": "This first practice exercise grounds our understanding of rigid body kinematics in its most fundamental principle: the invariance of distance between material points. By analyzing the instantaneous velocities of just two points on a rigid body, we can fully characterize its planar motion. This problem guides you through using this principle to compute the body's angular velocity and the translational velocity of its center of mass.", "problem": "In a fixed inertial frame with an orthonormal basis in the plane, a uniform rigid bar lies in the plane at an instant with two labeled material points $P$ and $Q$ serving as its endpoints. The instantaneous position vectors (from the inertial origin) of these points at that instant are\n$$\n\\mathbf{r}_P=\\begin{pmatrix}1\\\\2\\end{pmatrix}\\,\\mathrm{m},\\qquad \\mathbf{r}_Q=\\begin{pmatrix}5\\\\-1\\end{pmatrix}\\,\\mathrm{m}.\n$$\nAt the same instant, their measured velocities in the inertial frame are\n$$\n\\mathbf{v}_P=\\begin{pmatrix}3\\\\7\\end{pmatrix}\\,\\mathrm{\\tfrac{m}{s}},\\qquad \\mathbf{v}_Q=\\begin{pmatrix}9\\\\15\\end{pmatrix}\\,\\mathrm{\\tfrac{m}{s}}.\n$$\nTreat the motion as a general plane motion of a rigid body. Using only the defining property of rigidity that the distance between any two material points remains invariant in time, first derive the general instantaneous relationship between the velocities of two points on a rigid body moving in a plane and compute the instantaneous relative velocity of $Q$ with respect to $P$ at the given instant. Then deduce the scalar angular velocity $\\omega$ of the bar (take the out-of-plane unit vector $\\hat{\\mathbf{k}}$ as positive when angular velocity is counterclockwise) and the translational velocity of the center of mass (COM) of the bar at that instant.\n\nExpress the angular velocity in radians per second and the COM velocity in meters per second. Provide your final result as a single row matrix $\\begin{pmatrix}\\omega  v_{\\mathrm{COM},x}  v_{\\mathrm{COM},y}\\end{pmatrix}$. No rounding is required; provide exact values.", "solution": "First, we derive the general velocity relationship for a rigid body. Let $P$ and $Q$ be two points on the body with position vectors $\\mathbf{r}_P$ and $\\mathbf{r}_Q$. The relative position vector is $\\mathbf{r}_{QP} = \\mathbf{r}_Q - \\mathbf{r}_P$. The defining property of rigidity is that the distance between $P$ and $Q$, $L = |\\mathbf{r}_{QP}|$, is constant. Thus, its square $L^2 = \\mathbf{r}_{QP} \\cdot \\mathbf{r}_{QP}$ is also constant. Differentiating with respect to time $t$:\n$$ \\frac{d}{dt} (L^2) = \\frac{d}{dt} (\\mathbf{r}_{QP} \\cdot \\mathbf{r}_{QP}) = 2 \\mathbf{r}_{QP} \\cdot \\frac{d\\mathbf{r}_{QP}}{dt} = 0 $$\nThe term $\\frac{d\\mathbf{r}_{QP}}{dt}$ is the relative velocity $\\mathbf{v}_{QP} = \\mathbf{v}_Q - \\mathbf{v}_P$. The relation $\\mathbf{r}_{QP} \\cdot \\mathbf{v}_{QP} = 0$ signifies that the relative velocity is always perpendicular to the vector connecting the two points. This motion is a pure rotation of point $Q$ about point $P$ (in a frame translating with $P$). Such motion is described by the cross product with an angular velocity vector $\\boldsymbol{\\omega}$:\n$$ \\mathbf{v}_{QP} = \\boldsymbol{\\omega} \\times \\mathbf{r}_{QP} $$\nThis yields the fundamental relationship for the velocities of two points on a rigid body:\n$$ \\mathbf{v}_Q = \\mathbf{v}_P + \\boldsymbol{\\omega} \\times (\\mathbf{r}_Q - \\mathbf{r}_P) $$\nFor plane motion in the $xy$-plane, $\\boldsymbol{\\omega} = \\omega \\hat{\\mathbf{k}}$, where $\\hat{\\mathbf{k}}$ is the unit vector normal to the plane. If $\\mathbf{r}_{QP} = \\Delta x \\hat{\\mathbf{i}} + \\Delta y \\hat{\\mathbf{j}}$, the cross product becomes:\n$$ \\boldsymbol{\\omega} \\times \\mathbf{r}_{QP} = (\\omega \\hat{\\mathbf{k}}) \\times (\\Delta x \\hat{\\mathbf{i}} + \\Delta y \\hat{\\mathbf{j}}) = \\omega \\Delta x (\\hat{\\mathbf{k}} \\times \\hat{\\mathbf{i}}) + \\omega \\Delta y (\\hat{\\mathbf{k}} \\times \\hat{\\mathbf{j}}) = \\omega \\Delta x \\hat{\\mathbf{j}} - \\omega \\Delta y \\hat{\\mathbf{i}} $$\nIn column vector form, this is $\\mathbf{v}_{QP} = \\begin{pmatrix} -\\omega \\Delta y \\\\ \\omega \\Delta x \\end{pmatrix}$.\n\nSecond, we compute the instantaneous relative velocity of $Q$ with respect to $P$, $\\mathbf{v}_{Q/P} = \\mathbf{v}_{QP}$. Using the provided data:\n$$ \\mathbf{v}_{QP} = \\mathbf{v}_Q - \\mathbf{v}_P = \\begin{pmatrix}9\\\\15\\end{pmatrix} - \\begin{pmatrix}3\\\\7\\end{pmatrix} = \\begin{pmatrix}6\\\\8\\end{pmatrix}\\,\\mathrm{\\tfrac{m}{s}} $$\n\nThird, we deduce the scalar angular velocity $\\omega$. The relative position vector is:\n$$ \\mathbf{r}_{QP} = \\mathbf{r}_Q - \\mathbf{r}_P = \\begin{pmatrix}5\\\\-1\\end{pmatrix} - \\begin{pmatrix}1\\\\2\\end{pmatrix} = \\begin{pmatrix}4\\\\-3\\end{pmatrix}\\,\\mathrm{m} $$\nSo, $\\Delta x = 4$ and $\\Delta y = -3$. Substituting into the expression for $\\mathbf{v}_{QP}$:\n$$ \\begin{pmatrix}6\\\\8\\end{pmatrix} = \\begin{pmatrix} -\\omega (-3) \\\\ \\omega (4) \\end{pmatrix} = \\begin{pmatrix} 3\\omega \\\\ 4\\omega \\end{pmatrix} $$\nThis gives two consistent equations for $\\omega$:\nFrom the $x$-component: $6 = 3\\omega \\implies \\omega = 2\\,\\mathrm{rad/s}$.\nFrom the $y$-component: $8 = 4\\omega \\implies \\omega = 2\\,\\mathrm{rad/s}$.\nThe angular velocity is positive, which by convention corresponds to counter-clockwise rotation. Thus, $\\omega = 2$.\n\nFourth, we determine the velocity of the center of mass (COM). Since the bar is uniform, its COM is located at the midpoint of its endpoints $P$ and $Q$. The position of the COM is:\n$$ \\mathbf{r}_{\\mathrm{COM}} = \\frac{\\mathbf{r}_P + \\mathbf{r}_Q}{2} = \\frac{1}{2}\\left(\\begin{pmatrix}1\\\\2\\end{pmatrix} + \\begin{pmatrix}5\\\\-1\\end{pmatrix}\\right) = \\frac{1}{2}\\begin{pmatrix}6\\\\1\\end{pmatrix} = \\begin{pmatrix}3\\\\0.5\\end{pmatrix}\\,\\mathrm{m} $$\nThe velocity of the COM is obtained by differentiating its position with respect to time:\n$$ \\mathbf{v}_{\\mathrm{COM}} = \\frac{d\\mathbf{r}_{\\mathrm{COM}}}{dt} = \\frac{1}{2} \\left( \\frac{d\\mathbf{r}_P}{dt} + \\frac{d\\mathbf{r}_Q}{dt} \\right) = \\frac{\\mathbf{v}_P + \\mathbf{v}_Q}{2} $$\nThis simple averaging is valid specifically because the COM is the geometric midpoint. Substituting the given velocities:\n$$ \\mathbf{v}_{\\mathrm{COM}} = \\frac{1}{2} \\left( \\begin{pmatrix}3\\\\7\\end{pmatrix} + \\begin{pmatrix}9\\\\15\\end{pmatrix} \\right) = \\frac{1}{2} \\begin{pmatrix}12\\\\22\\end{pmatrix} = \\begin{pmatrix}6\\\\11\\end{pmatrix}\\,\\mathrm{\\tfrac{m}{s}} $$\nSo, the components of the COM velocity are $v_{\\mathrm{COM},x} = 6\\,\\mathrm{\\tfrac{m}{s}}$ and $v_{\\mathrm{COM},y} = 11\\,\\mathrm{\\tfrac{m}{s}}$.\n\nFinally, the required result is the row matrix $\\begin{pmatrix}\\omega  v_{\\mathrm{COM},x}  v_{\\mathrm{COM},y}\\end{pmatrix}$:\n$$ \\begin{pmatrix}2  6  11\\end{pmatrix} $$", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n2  6  11\n\\end{pmatrix}\n}\n$$", "id": "2914505"}, {"introduction": "Effective computational mechanics relies on robust numerical representations of rotation, where unit quaternions offer an efficient alternative to matrices. This practice challenges you to derive and implement a numerically sound algorithm for converting a direction cosine matrix to a unit quaternion. You will learn to handle the singularities that arise near $\\pi$ radian rotations, a critical skill for developing stable simulations.", "problem": "You are given the task of converting a direction cosine matrix (also called a rotation matrix) to a unit quaternion for use in rigid body motion kinematics in materials mechanics. A direction cosine matrix is a real $3 \\times 3$ matrix $Q$ that is orthogonal and has determinant $+1$, that is, $Q \\in \\mathrm{SO}(3)$, satisfying $Q^{\\mathsf{T}} Q = I$ and $\\det(Q) = 1$. A unit quaternion representing a rotation is a vector $q = [q_0, q_1, q_2, q_3]$ with $q_0 \\in \\mathbb{R}$ the scalar part and $[q_1, q_2, q_3]^{\\mathsf{T}} \\in \\mathbb{R}^3$ the vector part, such that $\\|q\\|_2 = 1$. The mapping between unit quaternions and rotation matrices is two-to-one, so $q$ and $-q$ represent the same physical rotation.\n\nYour goals are:\n- Starting from fundamental definitions of rigid body rotation, derive a numerically robust algorithm to compute a unit quaternion $q$ from a given $Q \\in \\mathrm{SO}(3)$. The derivation must begin with the definition of a rotation acting on a vector via a quaternion sandwich operation and the orthogonality properties of $Q$, not from a pre-stated target formula.\n- Address the numerical issues that arise when $\\mathrm{tr}(Q)$ is near $-1$, which corresponds to a rotation angle near $\\pi$ radians; derive how to avoid catastrophic cancellation in this case by choosing stable expressions.\n- Specify and implement a canonical sign convention to make the quaternion unique: enforce $q_0 \\ge 0$. In the degenerate case $q_0 = 0$ (within a numerical tolerance), enforce that the component among $q_1$, $q_2$, $q_3$ with largest magnitude is nonnegative; if there is a tie, resolve it in the order $q_1$, then $q_2$, then $q_3$.\n\nYour program must:\n- Implement the derived algorithm in double-precision arithmetic.\n- Normalize the quaternion to unit length after computation to mitigate roundoff.\n- Apply the canonical sign rule described above.\n- Round each quaternion component to $10$ decimal places in the final output.\n- Produce a single line of output containing a list of the computed quaternions for the test suite below, formatted as a comma-separated list enclosed in square brackets, with each quaternion itself a bracketed comma-separated list in the order $[q_0,q_1,q_2,q_3]$.\n\nNo physical units are involved; all quantities are dimensionless. Angles, when used for constructing matrices in the test suite, are in radians.\n\nTest suite (each case is a $3 \\times 3$ matrix $Q$ to be converted to a quaternion):\n- Case $1$ (identity rotation):\n  $$Q_1 = \\begin{bmatrix} 1  0  0 \\\\ 0  1  0 \\\\ 0  0  1 \\end{bmatrix}.$$\n- Case $2$ (rotation by $\\pi$ about the $x$-axis; $\\mathrm{tr}(Q) = -1$):\n  $$Q_2 = \\begin{bmatrix} 1  0  0 \\\\ 0  -1  0 \\\\ 0  0  -1 \\end{bmatrix}.$$\n- Case $3$ (rotation by $\\pi$ about the unit axis $a = \\frac{1}{\\sqrt{2}}[1,1,0]^{\\mathsf{T}}$; $\\mathrm{tr}(Q) = -1$). Using $Q = -I + 2 a a^{\\mathsf{T}}$ at angle $\\pi$:\n  $$Q_3 = \\begin{bmatrix} 0  1  0 \\\\ 1  0  0 \\\\ 0  0  -1 \\end{bmatrix}.$$\n- Case $4$ (rotation by $\\theta = \\pi - 10^{-9}$ about the $z$-axis; $\\mathrm{tr}(Q) \\approx -1$):\n  $$Q_4 = \\begin{bmatrix} \\cos\\theta  -\\sin\\theta  0 \\\\ \\sin\\theta  \\cos\\theta  0 \\\\ 0  0  1 \\end{bmatrix}, \\quad \\theta = \\pi - 10^{-9}.$$\n- Case $5$ (generic rotation by $\\theta = 1.23456789$ about the unit axis $a = \\frac{1}{\\sqrt{14}}[1,2,3]^{\\mathsf{T}}$). Using Rodrigues’ formula $Q = I + \\sin\\theta [a]_\\times + (1 - \\cos\\theta)[a]_\\times^2$, where $[a]_\\times$ is the skew-symmetric matrix of $a$:\n  $$[a]_\\times = \\begin{bmatrix} 0  -a_3  a_2 \\\\ a_3  0  -a_1 \\\\ -a_2  a_1  0 \\end{bmatrix}, \\quad a = \\frac{1}{\\sqrt{14}}\\begin{bmatrix} 1 \\\\ 2 \\\\ 3 \\end{bmatrix}, \\quad \\theta = 1.23456789.$$\n\nFinal output format requirement:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each entry is a bracketed comma-separated list of the rounded quaternion components for $Q_1$ through $Q_5$ in order. For example, the format is like $[[\\cdot,\\cdot,\\cdot,\\cdot],[\\cdot,\\cdot,\\cdot,\\cdot],\\ldots]$ where each $\\cdot$ is a floating-point number rounded to $10$ decimal places.", "solution": "The problem requires the derivation of a numerically robust algorithm to convert a direction cosine matrix $Q \\in \\mathrm{SO}(3)$ into a unit quaternion $q$, and to implement this algorithm. The derivation must originate from fundamental principles, address numerical stability, and implement a specific canonical sign convention for uniqueness.\n\n**1. Fundamental Derivation of Rotation Matrix from Quaternion**\n\nA rotation of a vector $\\mathbf{x} \\in \\mathbb{R}^3$ to a vector $\\mathbf{x}' \\in \\mathbb{R}^3$ can be represented by a unit quaternion $q = [q_0, \\mathbf{v}]$, where $q_0 \\in \\mathbb{R}$ is the scalar part, $\\mathbf{v} = [q_1, q_2, q_3]^{\\mathsf{T}} \\in \\mathbb{R}^3$ is the vector part, and the unit norm constraint $q_0^2 + q_1^2 + q_2^2 + q_3^2 = 1$ is satisfied. The vectors $\\mathbf{x}$ and $\\mathbf{x}'$ are represented as pure quaternions $x_{quat} = [0, \\mathbf{x}]$ and $x'_{quat} = [0, \\mathbf{x}']$. The rotation is performed via the sandwich product:\n$$ x'_{quat} = q x_{quat} q^* $$\nwhere $q^* = [q_0, -\\mathbf{v}]$ is the conjugate of $q$, which is also its inverse $q^{-1}$ for a unit quaternion. The product of two quaternions $a = [a_0, \\mathbf{a}]$ and $b = [b_0, \\mathbf{b}]$ is given by $ab = [a_0 b_0 - \\mathbf{a} \\cdot \\mathbf{b}, a_0 \\mathbf{b} + b_0 \\mathbf{a} + \\mathbf{a} \\times \\mathbf{b}]$.\n\nExpanding the sandwich product, we first compute $q x_{quat}$:\n$$ q x_{quat} = [q_0, \\mathbf{v}] [0, \\mathbf{x}] = [-\\mathbf{v} \\cdot \\mathbf{x}, q_0 \\mathbf{x} + \\mathbf{v} \\times \\mathbf{x}] $$\nThen, we multiply by $q^*$:\n$$ x'_{quat} = [-\\mathbf{v} \\cdot \\mathbf{x}, q_0 \\mathbf{x} + \\mathbf{v} \\times \\mathbf{x}] [q_0, -\\mathbf{v}] $$\nThe scalar part of the result is $(-\\mathbf{v} \\cdot \\mathbf{x})q_0 - (q_0 \\mathbf{x} + \\mathbf{v} \\times \\mathbf{x}) \\cdot (-\\mathbf{v}) = 0$, confirming $x'_{quat}$ is a pure quaternion. The vector part, which corresponds to $\\mathbf{x}'$, is:\n$$ \\mathbf{x}' = (-\\mathbf{v} \\cdot \\mathbf{x})(-\\mathbf{v}) + q_0(q_0 \\mathbf{x} + \\mathbf{v} \\times \\mathbf{x}) + (q_0 \\mathbf{x} + \\mathbf{v} \\times \\mathbf{x}) \\times (-\\mathbf{v}) $$\nUsing vector identities $\\mathbf{a} \\times \\mathbf{b} = - \\mathbf{b} \\times \\mathbf{a}$ and $\\mathbf{a} \\times (\\mathbf{b} \\times \\mathbf{c}) = (\\mathbf{a} \\cdot \\mathbf{c})\\mathbf{b} - (\\mathbf{a} \\cdot \\mathbf{b})\\mathbf{c}$, this simplifies to:\n$$ \\mathbf{x}' = (q_0^2 - \\mathbf{v} \\cdot \\mathbf{v})\\mathbf{x} + 2(\\mathbf{v} \\cdot \\mathbf{x})\\mathbf{v} + 2q_0(\\mathbf{v} \\times \\mathbf{x}) $$\nSubstituting the unit norm constraint $q_0^2 + \\mathbf{v} \\cdot \\mathbf{v} = 1$, we get $\\mathbf{v} \\cdot \\mathbf{v} = 1 - q_0^2$, which leads to:\n$$ \\mathbf{x}' = (2q_0^2 - 1)\\mathbf{x} + 2\\mathbf{v}\\mathbf{v}^{\\mathsf{T}}\\mathbf{x} + 2q_0 [\\mathbf{v}]_{\\times}\\mathbf{x} $$\nwhere $[\\mathbf{v}]_{\\times}$ is the skew-symmetric matrix corresponding to the cross product with $\\mathbf{v}$. The rotation matrix $Q$ is therefore:\n$$ Q = (2q_0^2 - 1)I + 2\\mathbf{v}\\mathbf{v}^{\\mathsf{T}} + 2q_0 [\\mathbf{v}]_{\\times} $$\nExpanding this expression gives the matrix elements $Q_{ij}$ in terms of $q_k$:\n$$\nQ = \\begin{bmatrix}\nq_0^2 + q_1^2 - q_2^2 - q_3^2  2(q_1 q_2 - q_0 q_3)  2(q_1 q_3 + q_0 q_2) \\\\\n2(q_1 q_2 + q_0 q_3)  q_0^2 - q_1^2 + q_2^2 - q_3^2  2(q_2 q_3 - q_0 q_1) \\\\\n2(q_1 q_3 - q_0 q_2)  2(q_2 q_3 + q_0 q_1)  q_0^2 - q_1^2 - q_2^2 + q_3^2\n\\end{bmatrix}\n$$\n\n**2. Derivation of the Inverse Mapping (Q to q)**\n\nTo find the quaternion components from $Q$, we manipulate the expressions for $Q_{ij}$. The trace of $Q$ provides the most direct path to $q_0$:\n$$ \\mathrm{tr}(Q) = Q_{11} + Q_{22} + Q_{33} = (3q_0^2 - q_1^2 - q_2^2 - q_3^2) = 3q_0^2 - (1-q_0^2) = 4q_0^2 - 1 $$\nThis yields:\n$$ 4q_0^2 = \\mathrm{tr}(Q) + 1 $$\nThe vector components can be found from differences of off-diagonal elements:\n$$ Q_{32} - Q_{23} = 4q_0 q_1 $$\n$$ Q_{13} - Q_{31} = 4q_0 q_2 $$\n$$ Q_{21} - Q_{12} = 4q_0 q_3 $$\nWhen $\\mathrm{tr}(Q)$ is not close to $-1$, $q_0$ is not close to $0$. We can then compute the quaternion as:\n$$ q_0 = \\frac{1}{2}\\sqrt{\\mathrm{tr}(Q) + 1} $$\n$$ q_1 = \\frac{Q_{32} - Q_{23}}{4q_0}, \\quad q_2 = \\frac{Q_{13} - Q_{31}}{4q_0}, \\quad q_3 = \\frac{Q_{21} - Q_{12}}{4q_0} $$\nThe sign of $q_0$ is chosen to be non-negative as per the problem's canonicalization requirement.\n\n**3. Addressing Numerical Instability**\n\nWhen $\\mathrm{tr}(Q) \\to -1$, which corresponds to a rotation angle $\\theta \\to \\pi$, $q_0 \\to \\cos(\\pi/2) = 0$. The above formulae become numerically unstable due to division by a number close to zero. To overcome this, we derive alternative expressions from the diagonal elements of $Q$:\n$$ Q_{11} = q_0^2 + q_1^2 - q_2^2 - q_3^2 = 2q_0^2 + 2q_1^2 - 1 \\implies 4q_1^2 = 2Q_{11} + 2 - 4q_0^2 $$\nSubstituting $4q_0^2 = \\mathrm{tr}(Q)+1$:\n$$ 4q_1^2 = 2Q_{11} + 2 - (\\mathrm{tr}(Q)+1) = 2Q_{11} + 1 - (Q_{11} + Q_{22} + Q_{33}) = 1 + Q_{11} - Q_{22} - Q_{33} $$\nSimilarly, by cyclic permutation:\n$$ 4q_2^2 = 1 - Q_{11} + Q_{22} - Q_{33} $$\n$$ 4q_3^2 = 1 - Q_{11} - Q_{22} + Q_{33} $$\nThese allow calculation of the squares of the vector components without finding $q_0$ first. If $q_1$ is the largest component, for instance, we can calculate it from $q_1^2$ and then find other components using sums of off-diagonal elements, which do not involve $q_0$:\n$$ Q_{21} + Q_{12} = 4q_1 q_2 $$\n$$ Q_{31} + Q_{13} = 4q_1 q_3 $$\n$$ Q_{32} - Q_{23} = 4q_0 q_1 $$\n\n**4. Numerically Robust Algorithm**\n\nA robust algorithm selects the largest component to compute first, thus avoiding division by small numbers. We identify the largest of the following four quantities:\n$$ v_0 = 4q_0^2 = 1 + Q_{11} + Q_{22} + Q_{33} $$\n$$ v_1 = 4q_1^2 = 1 + Q_{11} - Q_{22} - Q_{33} $$\n$$ v_2 = 4q_2^2 = 1 - Q_{11} + Q_{22} - Q_{33} $$\n$$ v_3 = 4q_3^2 = 1 - Q_{11} - Q_{22} + Q_{33} $$\nThe algorithm proceeds based on which of these is the maximum:\n- If $v_0$ is largest: $q_0 = \\frac{1}{2}\\sqrt{v_0}$, $q_1 = \\frac{Q_{32}-Q_{23}}{4q_0}$, $q_2 = \\frac{Q_{13}-Q_{31}}{4q_0}$, $q_3 = \\frac{Q_{21}-Q_{12}}{4q_0}$.\n- If $v_1$ is largest: $q_1 = \\frac{1}{2}\\sqrt{v_1}$, $q_0 = \\frac{Q_{32}-Q_{23}}{4q_1}$, $q_2 = \\frac{Q_{12}+Q_{21}}{4q_1}$, $q_3 = \\frac{Q_{13}+Q_{31}}{4q_1}$.\n- If $v_2$ is largest: $q_2 = \\frac{1}{2}\\sqrt{v_2}$, $q_0 = \\frac{Q_{13}-Q_{31}}{4q_2}$, $q_1 = \\frac{Q_{12}+Q_{21}}{4q_2}$, $q_3 = \\frac{Q_{23}+Q_{32}}{4q_2}$.\n- If $v_3$ is largest: $q_3 = \\frac{1}{2}\\sqrt{v_3}$, $q_0 = \\frac{Q_{21}-Q_{12}}{4q_3}$, $q_1 = \\frac{Q_{13}+Q_{31}}{4q_3}$, $q_2 = \\frac{Q_{23}+Q_{32}}{4q_3}$.\nThis ensures we take the square root of the largest available positive number and divide by the largest available component, maximizing precision.\n\n**5. Canonical Sign Convention**\n\nThe computed quaternion must be made unique. The problem specifies a hierarchical sign convention.\n1. Primary Rule: Enforce $q_0 \\ge 0$. If the initially computed $q_0$ is negative, the entire quaternion must be negated: $q \\leftarrow -q$.\n2. Secondary Rule: For the degenerate case where $q_0$ is zero (within a numerical tolerance), a remaining sign ambiguity ($[0, \\mathbf{v}]$ vs $[0, -\\mathbf{v}]$) is resolved. The component of the vector part $[q_1, q_2, q_3]$ with the largest magnitude must be non-negative. If there is a tie for largest magnitude, the first such component in the order $q_1, q_2, q_3$ is used for the sign check. If this chosen component is negative, the entire quaternion is negated. After this potential negation, $q_0$ might become a small negative number. It must be set to exactly $0.0$ to strictly enforce the primary rule in this degenerate case.\n\nFinally, the quaternion is normalized to unit length to correct for any accumulated floating-point errors.\n\nThis completes the principled derivation of a robust and canonical conversion algorithm. The implementation will follow these steps precisely.", "answer": "```python\nimport numpy as np\n\ndef matrix_to_quaternion(Q):\n    \"\"\"\n    Converts a 3x3 direction cosine matrix to a unit quaternion with a canonical sign convention.\n\n    The algorithm is numerically robust, handling the case of rotations near 180 degrees.\n    The canonical convention is:\n    1. q0 = 0\n    2. If q0 is zero (within tolerance), the vector component with the largest magnitude\n       is made non-negative, with tie-breaking for q1, then q2, then q3.\n    \"\"\"\n    \n    # Pre-calculate matrix elements for readability\n    Q11, Q12, Q13 = Q[0, 0], Q[0, 1], Q[0, 2]\n    Q21, Q22, Q23 = Q[1, 0], Q[1, 1], Q[1, 2]\n    Q31, Q32, Q33 = Q[2, 0], Q[2, 1], Q[2, 2]\n\n    # The four candidate values for 4*q^2, from which we select the largest\n    # to maintain numerical stability.\n    v = np.zeros(4)\n    v[0] = 1 + Q11 + Q22 + Q33  # 4 * q0^2\n    v[1] = 1 + Q11 - Q22 - Q33  # 4 * q1^2\n    v[2] = 1 - Q11 + Q22 - Q33  # 4 * q2^2\n    v[3] = 1 - Q11 - Q22 + Q33  # 4 * q3^2\n    \n    # We must ensure we take the sqrt of a non-negative number\n    v[v  0] = 0\n\n    # Find the index of the largest component\n    max_idx = np.argmax(v)\n    \n    q_raw = np.zeros(4)\n    \n    if max_idx == 0:\n        q_raw[0] = 0.5 * np.sqrt(v[0])\n        scale = 0.25 / q_raw[0]\n        q_raw[1] = (Q32 - Q23) * scale\n        q_raw[2] = (Q13 - Q31) * scale\n        q_raw[3] = (Q21 - Q12) * scale\n    elif max_idx == 1:\n        q_raw[1] = 0.5 * np.sqrt(v[1])\n        scale = 0.25 / q_raw[1]\n        q_raw[0] = (Q32 - Q23) * scale\n        q_raw[2] = (Q12 + Q21) * scale\n        q_raw[3] = (Q13 + Q31) * scale\n    elif max_idx == 2:\n        q_raw[2] = 0.5 * np.sqrt(v[2])\n        scale = 0.25 / q_raw[2]\n        q_raw[0] = (Q13 - Q31) * scale\n        q_raw[1] = (Q12 + Q21) * scale\n        q_raw[3] = (Q23 + Q32) * scale\n    else: # max_idx == 3\n        q_raw[3] = 0.5 * np.sqrt(v[3])\n        scale = 0.25 / q_raw[3]\n        q_raw[0] = (Q21 - Q12) * scale\n        q_raw[1] = (Q13 + Q31) * scale\n        q_raw[2] = (Q23 + Q32) * scale\n\n    #--- Apply Canonical Sign Convention ---\n    \n    # Initial normalization\n    norm = np.linalg.norm(q_raw)\n    if norm  0:\n        q = q_raw / norm\n    else:\n        q = np.array([1.0, 0.0, 0.0, 0.0]) # Should not happen for valid SO(3)\n\n    # 1. Primary rule: q0 must be non-negative.\n    if q[0]  0.0:\n        q = -q\n\n    # 2. Secondary rule: If q0 is near zero (degenerate case ~180 deg rotation),\n    #    make the largest magnitude vector component non-negative.\n    q0_tolerance = 1e-9\n    if q[0]  q0_tolerance:\n        vec_part = q[1:]\n        magnitudes = np.abs(vec_part)\n\n        # Determine index of the first component with max magnitude, respecting priority\n        k = -1\n        if magnitudes[0] = magnitudes[1] and magnitudes[0] = magnitudes[2]:\n            k = 0\n        elif magnitudes[1] = magnitudes[2]:\n            k = 1\n        else:\n            k = 2\n        \n        # If that component is negative, flip the sign of the entire quaternion\n        if vec_part[k]  0.0:\n            q = -q\n\n        # Strictly enforce q0 = 0 by setting it to 0 in this degenerate case.\n        # This is because the flip might have made q[0] slightly negative.\n        q[0] = 0.0\n\n    # Final normalization to correct for any floating point inaccuracies and the q[0]=0 step.\n    final_norm = np.linalg.norm(q)\n    if final_norm  0:\n        q_final = q / final_norm\n    else:\n        # Fallback for zero vector case, return identity\n        q_final = np.array([1.0, 0.0, 0.0, 0.0])\n        \n    return q_final\n\ndef solve():\n    # Define test cases\n    Q1 = np.array([\n        [1, 0, 0],\n        [0, 1, 0],\n        [0, 0, 1]\n    ])\n    \n    Q2 = np.array([\n        [1, 0, 0],\n        [0, -1, 0],\n        [0, 0, -1]\n    ])\n    \n    Q3 = np.array([\n        [0, 1, 0],\n        [1, 0, 0],\n        [0, 0, -1]\n    ])\n\n    theta4 = np.pi - 1e-9\n    c4, s4 = np.cos(theta4), np.sin(theta4)\n    Q4 = np.array([\n        [c4, -s4, 0],\n        [s4,  c4, 0],\n        [0,   0, 1]\n    ])\n\n    theta5 = 1.23456789\n    a5 = np.array([1, 2, 3]) / np.sqrt(14)\n    a_x_mat = np.array([\n        [0, -a5[2], a5[1]],\n        [a5[2], 0, -a5[0]],\n        [-a5[1], a5[0], 0]\n    ])\n    Q5 = np.identity(3) + np.sin(theta5) * a_x_mat + (1 - np.cos(theta5)) * (a_x_mat @ a_x_mat)\n\n    test_cases = [Q1, Q2, Q3, Q4, Q5]\n    \n    results = []\n    for Q in test_cases:\n        q = matrix_to_quaternion(Q)\n        # Round each component to 10 decimal places\n        q_rounded = np.round(q, 10).tolist()\n        # Correct for negative zero\n        q_rounded_str = [f\"{x:.10f}\" for x in q_rounded]\n        results.append(f\"[{','.join(q_rounded_str)}]\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n\n```", "id": "2914523"}, {"introduction": "In both experimental and computational settings, measured displacements often contain a mixture of true deformation and a superfluous rigid body motion. This final practice tackles the essential task of separating these components by finding the 'best-fit' rigid transformation. You will derive and implement this powerful least-squares method, a cornerstone algorithm for accurately analyzing strain and material response from raw displacement data.", "problem": "You are given a set of material points (nodes) with known reference positions and measured displacements that are contaminated by an unknown rigid body motion. Your task is to derive, implement, and evaluate a least-squares procedure that identifies the best-fit rigid motion and removes it from the measured displacement field, leaving only the corrected (non-rigid) displacement. Work entirely within the kinematics of rigid body motion in materials mechanics, and derive all necessary computations from fundamental principles.\n\nStarting point and definitions (fundamental base):\n- A rigid body motion in spatial dimension $d$ is described by a rotation matrix $\\mathbf{R} \\in \\mathrm{SO}(d)$ (the special orthogonal group, so $\\mathbf{R}^\\mathsf{T}\\mathbf{R} = \\mathbf{I}$ and $\\det \\mathbf{R} = 1$) and a translation vector $\\mathbf{t} \\in \\mathbb{R}^d$.\n- For a reference point $\\mathbf{x}_i \\in \\mathbb{R}^d$, the rigidly moved position is $\\mathbf{R}\\mathbf{x}_i + \\mathbf{t}$, and the corresponding rigid displacement is $\\left(\\mathbf{R} - \\mathbf{I}\\right)\\mathbf{x}_i + \\mathbf{t}$.\n- The measured displacement at node $i$ is $\\mathbf{u}_i^{\\mathrm{meas}} \\in \\mathbb{R}^d$, and the measured deformed position is $\\mathbf{y}_i = \\mathbf{x}_i + \\mathbf{u}_i^{\\mathrm{meas}}$.\n\nProblem requirement:\n- From first principles, pose and solve the constrained least-squares problem that identifies the best-fit $(\\mathbf{R}, \\mathbf{t})$ by minimizing the sum of squared residuals between the measured deformed positions $\\mathbf{y}_i$ and the rigidly transformed reference positions $\\mathbf{R}\\mathbf{x}_i + \\mathbf{t}$, subject to $\\mathbf{R} \\in \\mathrm{SO}(d)$.\n- Derive the translation $\\mathbf{t}$ in terms of the centroids of $\\{\\mathbf{x}_i\\}$ and $\\{\\mathbf{y}_i\\}$ for fixed $\\mathbf{R}$, and derive the optimal $\\mathbf{R}$ using only the orthogonality constraints and least-squares optimality (no shortcut formulas may be assumed in the problem statement).\n- After identifying $(\\mathbf{R}, \\mathbf{t})$, compute the rigid part of the displacement at each node as $\\mathbf{u}_i^{\\mathrm{rigid}} = \\left(\\mathbf{R} - \\mathbf{I}\\right)\\mathbf{x}_i + \\mathbf{t}$, and obtain the corrected displacement as $\\mathbf{u}_i^{\\mathrm{corr}} = \\mathbf{u}_i^{\\mathrm{meas}} - \\mathbf{u}_i^{\\mathrm{rigid}}$.\n- Quantify the residual by the root-mean-square (RMS) norm of the corrected displacements, i.e., $\\sqrt{\\frac{1}{N}\\sum_{i=1}^N \\lVert \\mathbf{u}_i^{\\mathrm{corr}} \\rVert_2^2}$.\n- Report the principal rotation angle associated with $\\mathbf{R}$:\n  - For $d=2$, report the unique angle $\\theta \\in [0,\\pi]$ such that $\\mathbf{R} = \\begin{bmatrix}\\cos\\theta  -\\sin\\theta \\\\ \\sin\\theta  \\cos\\theta\\end{bmatrix}$.\n  - For $d=3$, report $\\theta \\in [0,\\pi]$ defined by $\\cos\\theta = \\frac{\\mathrm{tr}(\\mathbf{R}) - 1}{2}$.\n- Physical units: All lengths must be treated in meters $\\mathrm{m}$ and the reported RMS residual must be in meters $\\mathrm{m}$. All angles must be reported in radians $\\mathrm{rad}$.\n\nEdge-case policy:\n- If the data are degenerate (e.g., all centered points coincide so that the covariance has deficient rank), you must still return a valid $\\mathbf{R} \\in \\mathrm{SO}(d)$ and $\\mathbf{t} \\in \\mathbb{R}^d$ that minimize the least-squares objective. In the completely uninformative case where all centered reference points are zero, it is acceptable to return $\\mathbf{R} = \\mathbf{I}$ and $\\mathbf{t}$ equal to the centroid difference.\n\nTest suite:\nFor each test case below, synthesize the measured displacements using the provided parameters, then estimate $(\\mathbf{R}, \\mathbf{t})$ from the synthesized measurements only (do not use the contamination parameters directly in the estimation), correct the displacements, and report the outputs as specified.\n\n- Test case $1$ (two-dimensional, general rigid motion with a small non-rigid component):\n  - Dimension $d = 2$.\n  - Reference nodes in meters $\\mathrm{m}$: $\\mathbf{x}_1 = (0, 0)$, $\\mathbf{x}_2 = (1, 0)$, $\\mathbf{x}_3 = (1, 1)$, $\\mathbf{x}_4 = (0, 1)$.\n  - Rigid motion parameters: rotation angle $\\theta = 0.2$ radians $\\mathrm{rad}$ about the out-of-plane axis, translation $\\mathbf{t} = (0.05, -0.03)$ meters $\\mathrm{m}$.\n  - Small non-rigid mapping: $\\mathbf{u}^{\\mathrm{true}}(\\mathbf{x}) = \\mathbf{B}\\mathbf{x}$ with $\\mathbf{B} = \\mathrm{diag}(0.001, -0.0005)$ (unitless).\n  - Measured displacement: $\\mathbf{u}_i^{\\mathrm{meas}} = \\left(\\mathbf{R}(\\theta)-\\mathbf{I}\\right)\\mathbf{x}_i + \\mathbf{t} + \\mathbf{B}\\mathbf{x}_i$.\n\n- Test case $2$ (three-dimensional, general axis-angle rigid motion with a small non-rigid component):\n  - Dimension $d = 3$.\n  - Reference nodes in meters $\\mathrm{m}$: $\\mathbf{x}_1 = (0, 0, 0)$, $\\mathbf{x}_2 = (1, 0, 0)$, $\\mathbf{x}_3 = (0, 1, 0)$, $\\mathbf{x}_4 = (0, 0, 1)$, $\\mathbf{x}_5 = (1, 1, 1)$.\n  - Rigid motion parameters: axis $\\mathbf{a} = \\frac{1}{\\sqrt{14}}(1, 2, 3)$ (unitless), angle $\\theta = 0.3$ radians $\\mathrm{rad}$, translation $\\mathbf{t} = (-0.02, 0.04, 0.03)$ meters $\\mathrm{m}$.\n  - Rotation via Rodrigues' formula: $\\mathbf{R} = \\cos\\theta\\,\\mathbf{I} + \\sin\\theta\\,[\\mathbf{a}]_\\times + (1-\\cos\\theta)\\,\\mathbf{a}\\mathbf{a}^\\mathsf{T}$, where $[\\mathbf{a}]_\\times$ is the skew-symmetric matrix such that $[\\mathbf{a}]_\\times \\mathbf{v} = \\mathbf{a} \\times \\mathbf{v}$.\n  - Small non-rigid mapping: $\\mathbf{u}^{\\mathrm{true}}(\\mathbf{x}) = \\mathbf{B}\\mathbf{x}$ with $\\mathbf{B} = \\mathrm{diag}(0.0008, -0.0006, 0.0004)$ (unitless).\n  - Measured displacement: $\\mathbf{u}_i^{\\mathrm{meas}} = \\left(\\mathbf{R}-\\mathbf{I}\\right)\\mathbf{x}_i + \\mathbf{t} + \\mathbf{B}\\mathbf{x}_i$.\n\n- Test case $3$ (two-dimensional, pure translation):\n  - Dimension $d = 2$.\n  - Reference nodes in meters $\\mathrm{m}$: $\\mathbf{x}_1 = (0, 0)$, $\\mathbf{x}_2 = (2, 0)$, $\\mathbf{x}_3 = (0, 2)$.\n  - Rigid motion parameters: rotation angle $\\theta = 0$ radians $\\mathrm{rad}$, translation $\\mathbf{t} = (0.1, -0.05)$ meters $\\mathrm{m}$.\n  - Non-rigid mapping: $\\mathbf{B} = \\mathbf{0}$.\n  - Measured displacement: $\\mathbf{u}_i^{\\mathrm{meas}} = \\left(\\mathbf{R}(\\theta)-\\mathbf{I}\\right)\\mathbf{x}_i + \\mathbf{t}$.\n\n- Test case $4$ (three-dimensional, degenerate geometry: all nodes coincident):\n  - Dimension $d = 3$.\n  - Reference nodes in meters $\\mathrm{m}$: $\\mathbf{x}_1 = (2, 2, 2)$, $\\mathbf{x}_2 = (2, 2, 2)$, $\\mathbf{x}_3 = (2, 2, 2)$, $\\mathbf{x}_4 = (2, 2, 2)$.\n  - Rigid motion parameters: choose any rotation (it is unidentifiable here); translation $\\mathbf{t} = (0.01, 0.02, -0.03)$ meters $\\mathrm{m}$.\n  - Non-rigid mapping: $\\mathbf{B} = \\mathbf{0}$.\n  - Measured displacement: $\\mathbf{u}_i^{\\mathrm{meas}} = \\mathbf{t}$.\n\nRequired outputs:\n- For each test case $k \\in \\{1,2,3,4\\}$, compute and return a pair of floats:\n  - The principal rotation angle magnitude $\\theta_k$ in radians $\\mathrm{rad}$, as defined above.\n  - The RMS norm of the corrected displacements in meters $\\mathrm{m}$, i.e., $\\sqrt{\\frac{1}{N}\\sum_{i=1}^N \\lVert \\mathbf{u}_i^{\\mathrm{corr}} \\rVert_2^2}$.\n- Final output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Concatenate the results for all test cases in order, flattening the list, e.g., $[\\theta_1,\\mathrm{RMS}_1,\\theta_2,\\mathrm{RMS}_2,\\theta_3,\\mathrm{RMS}_3,\\theta_4,\\mathrm{RMS}_4]$. All angles must be in radians $\\mathrm{rad}$ and all RMS values must be in meters $\\mathrm{m}$.", "solution": "The problem requires the derivation and implementation of a least-squares procedure to determine the rigid body motion component within a measured displacement field. The solution must be derived from first principles of rigid body kinematics and optimization.\n\nLet the set of $N$ reference positions be $\\{\\mathbf{x}_i \\in \\mathbb{R}^d\\}_{i=1}^N$ and the corresponding measured deformed positions be $\\{\\mathbf{y}_i \\in \\mathbb{R}^d\\}_{i=1}^N$, where $d$ is the spatial dimension. A rigid body motion is defined by a rotation matrix $\\mathbf{R} \\in \\mathrm{SO}(d)$ and a translation vector $\\mathbf{t} \\in \\mathbb{R}^d$. The special orthogonal group $\\mathrm{SO}(d)$ consists of matrices satisfying $\\mathbf{R}^\\mathsf{T}\\mathbf{R} = \\mathbf{I}$ and $\\det(\\mathbf{R}) = 1$. The objective is to find the pair $(\\mathbf{R}, \\mathbf{t})$ that minimizes the sum of squared Euclidean distances between the measured positions $\\mathbf{y}_i$ and the rigidly transformed reference positions $\\mathbf{R}\\mathbf{x}_i + \\mathbf{t}$. This defines the constrained least-squares problem:\n$$ \\underset{\\mathbf{R} \\in \\mathrm{SO}(d), \\mathbf{t} \\in \\mathbb{R}^d}{\\text{minimize}} \\quad S(\\mathbf{R}, \\mathbf{t}) = \\sum_{i=1}^{N} \\lVert \\mathbf{y}_i - (\\mathbf{R}\\mathbf{x}_i + \\mathbf{t}) \\rVert_2^2 $$\n\nFirst, we solve for the optimal translation vector $\\mathbf{t}$ for a fixed rotation matrix $\\mathbf{R}$. The minimum of the quadratic function $S$ with respect to $\\mathbf{t}$ is found by setting its gradient to zero:\n$$ \\frac{\\partial S}{\\partial \\mathbf{t}} = \\sum_{i=1}^{N} \\frac{\\partial}{\\partial \\mathbf{t}} \\left( (\\mathbf{y}_i - \\mathbf{R}\\mathbf{x}_i - \\mathbf{t})^\\mathsf{T} (\\mathbf{y}_i - \\mathbf{R}\\mathbf{x}_i - \\mathbf{t}) \\right) = \\sum_{i=1}^{N} -2(\\mathbf{y}_i - \\mathbf{R}\\mathbf{x}_i - \\mathbf{t}) = \\mathbf{0} $$\nThis simplifies to:\n$$ \\sum_{i=1}^{N} \\mathbf{y}_i - \\mathbf{R}\\sum_{i=1}^{N} \\mathbf{x}_i - N\\mathbf{t} = \\mathbf{0} $$\nLet us define the centroids of the reference and deformed point clouds as $\\bar{\\mathbf{x}} = \\frac{1}{N}\\sum_{i=1}^{N} \\mathbf{x}_i$ and $\\bar{\\mathbf{y}} = \\frac{1}{N}\\sum_{i=1}^{N} \\mathbf{y}_i$. Substituting these into the equation yields:\n$$ N\\bar{\\mathbf{y}} - N\\mathbf{R}\\bar{\\mathbf{x}} - N\\mathbf{t} = \\mathbf{0} $$\n$$ \\mathbf{t} = \\bar{\\mathbf{y}} - \\mathbf{R}\\bar{\\mathbf{x}} $$\nThis demonstrates that the optimal translation vector $\\mathbf{t}^*$ maps the centroid of the rotated reference configuration to the centroid of the deformed configuration.\n\nNext, we substitute $\\mathbf{t}^*$ back into the objective function $S$. Let us define the centered coordinate vectors as $\\mathbf{x}'_i = \\mathbf{x}_i - \\bar{\\mathbf{x}}$ and $\\mathbf{y}'_i = \\mathbf{y}_i - \\bar{\\mathbf{y}}$. The term inside the norm becomes:\n$$ \\mathbf{y}_i - (\\mathbf{R}\\mathbf{x}_i + \\mathbf{t}^*) = (\\mathbf{y}_i - \\bar{\\mathbf{y}}) - \\mathbf{R}(\\mathbf{x}_i - \\bar{\\mathbf{x}}) = \\mathbf{y}'_i - \\mathbf{R}\\mathbf{x}'_i $$\nThe minimization problem is now reduced to finding the optimal rotation $\\mathbf{R}$:\n$$ \\underset{\\mathbf{R} \\in \\mathrm{SO}(d)}{\\text{minimize}} \\quad S(\\mathbf{R}) = \\sum_{i=1}^N \\lVert \\mathbf{y}'_i - \\mathbf{R}\\mathbf{x}'_i \\rVert_2^2 $$\nWe expand the squared norm:\n$$ \\lVert \\mathbf{y}'_i - \\mathbf{R}\\mathbf{x}'_i \\rVert_2^2 = (\\mathbf{y}'_i)^\\mathsf{T}\\mathbf{y}'_i - 2(\\mathbf{y}'_i)^\\mathsf{T}\\mathbf{R}\\mathbf{x}'_i + (\\mathbf{x}'_i)^\\mathsf{T}\\mathbf{R}^\\mathsf{T}\\mathbf{R}\\mathbf{x}'_i = \\lVert \\mathbf{y}'_i \\rVert_2^2 - 2(\\mathbf{y}'_i)^\\mathsf{T}\\mathbf{R}\\mathbf{x}'_i + \\lVert \\mathbf{x}'_i \\rVert_2^2 $$\nwhere we used the property $\\mathbf{R}^\\mathsf{T}\\mathbf{R} = \\mathbf{I}$. Summing over all points, the objective function becomes:\n$$ S(\\mathbf{R}) = \\sum_{i=1}^N \\lVert \\mathbf{y}'_i \\rVert_2^2 + \\sum_{i=1}^N \\lVert \\mathbf{x}'_i \\rVert_2^2 - 2 \\sum_{i=1}^N (\\mathbf{y}'_i)^\\mathsf{T}\\mathbf{R}\\mathbf{x}'_i $$\nThe first two terms are constant with respect to $\\mathbf{R}$. Therefore, minimizing $S(\\mathbf{R})$ is equivalent to maximizing the term $\\sum_{i=1}^N (\\mathbf{y}'_i)^\\mathsf{T}\\mathbf{R}\\mathbf{x}'_i$. Using the cyclic property of the trace operator, we can rewrite this as:\n$$ \\sum_{i=1}^N \\text{tr}((\\mathbf{y}'_i)^\\mathsf{T}\\mathbf{R}\\mathbf{x}'_i) = \\sum_{i=1}^N \\text{tr}(\\mathbf{R}\\mathbf{x}'_i(\\mathbf{y}'_i)^\\mathsf{T}) = \\text{tr} \\left( \\mathbf{R} \\sum_{i=1}^N \\mathbf{x}'_i(\\mathbf{y}'_i)^\\mathsf{T} \\right) $$\nLet us define the $d \\times d$ covariance matrix $\\mathbf{H} = \\sum_{i=1}^N \\mathbf{x}'_i(\\mathbf{y}'_i)^\\mathsf{T}$. The problem is now to find $\\mathbf{R} \\in \\mathrm{SO}(d)$ that maximizes $\\text{tr}(\\mathbf{R}\\mathbf{H})$.\n\nTo solve this constrained maximization problem, we employ the Singular Value Decomposition (SVD) of $\\mathbf{H}$, which is $\\mathbf{H} = \\mathbf{U}\\boldsymbol{\\Sigma}\\mathbf{V}^\\mathsf{T}$, where $\\mathbf{U}$ and $\\mathbf{V}$ are orthogonal matrices and $\\boldsymbol{\\Sigma}$ is a diagonal matrix of non-negative singular values.\n$$ \\text{tr}(\\mathbf{R}\\mathbf{H}) = \\text{tr}(\\mathbf{R}\\mathbf{U}\\boldsymbol{\\Sigma}\\mathbf{V}^\\mathsf{T}) = \\text{tr}(\\mathbf{V}^\\mathsf{T}\\mathbf{R}\\mathbf{U}\\boldsymbol{\\Sigma}) $$\nLet $\\mathbf{Z} = \\mathbf{V}^\\mathsf{T}\\mathbf{R}\\mathbf{U}$. Since $\\mathbf{U}$, $\\mathbf{V}$, and $\\mathbf{R}$ are orthogonal, $\\mathbf{Z}$ is also an orthogonal matrix. The objective becomes maximizing $\\text{tr}(\\mathbf{Z}\\boldsymbol{\\Sigma}) = \\sum_{j=1}^d Z_{jj}\\sigma_j$. Since $\\mathbf{Z}$ is orthogonal, $|Z_{jj}| \\le 1$, and singular values $\\sigma_j \\ge 0$. The maximum value is obtained when $Z_{jj}$ are as large as possible, which is $Z_{jj}=1$. This is achieved if $\\mathbf{Z}=\\mathbf{I}$.\nFrom $\\mathbf{Z}=\\mathbf{I}$, we find the optimal rotation in the orthogonal group $\\mathrm{O}(d)$:\n$$ \\mathbf{V}^\\mathsf{T}\\mathbf{R}\\mathbf{U} = \\mathbf{I} \\implies \\mathbf{R} = \\mathbf{V}\\mathbf{I}\\mathbf{U}^\\mathsf{T} = \\mathbf{V}\\mathbf{U}^\\mathsf{T} $$\nWe must ensure that $\\mathbf{R} \\in \\mathrm{SO}(d)$, i.e., $\\det(\\mathbf{R})=1$. We have $\\det(\\mathbf{R}) = \\det(\\mathbf{V}\\mathbf{U}^\\mathsf{T}) = \\det(\\mathbf{V})\\det(\\mathbf{U}^\\mathsf{T}) = \\det(\\mathbf{V})\\det(\\mathbf{U})$. SVD algorithms may yield $\\mathbf{U}$ and $\\mathbf{V}$ with determinants of either $+1$ or $-1$.\nIf $\\det(\\mathbf{V}\\mathbf{U}^\\mathsf{T}) = 1$, then $\\mathbf{R} = \\mathbf{V}\\mathbf{U}^\\mathsf{T}$ is the correct solution.\nIf $\\det(\\mathbf{V}\\mathbf{U}^\\mathsf{T}) = -1$, the solution corresponds to a reflection. The closest proper rotation is found by modifying $\\mathbf{R}$ to invert its determinant while minimally reducing the trace value $\\text{tr}(\\mathbf{R}\\mathbf{H})$. This is achieved by flipping the sign of the component associated with the smallest singular value. Assuming $\\sigma_d$ is the smallest singular value, the optimal solution in $\\mathrm{SO}(d)$ is:\n$$ \\mathbf{R} = \\mathbf{V} \\mathbf{S} \\mathbf{U}^\\mathsf{T}, \\quad \\text{where} \\quad \\mathbf{S} = \\text{diag}(1, 1, \\dots, 1, \\det(\\mathbf{V}\\mathbf{U}^\\mathsf{T})) $$\nThis ensures $\\det(\\mathbf{R}) = \\det(\\mathbf{V})\\det(\\mathbf{S})\\det(\\mathbf{U}^\\mathsf{T}) = \\det(\\mathbf{V}\\mathbf{U}^\\mathsf{T})\\det(\\mathbf{S}) = (-1)(-1) = 1$ in the problematic case.\n\nOnce the optimal $(\\mathbf{R}, \\mathbf{t})$ are found, the rigid displacement at node $i$ is $\\mathbf{u}_i^{\\mathrm{rigid}} = (\\mathbf{R} - \\mathbf{I})\\mathbf{x}_i + \\mathbf{t}$. The corrected (non-rigid) displacement is the difference between the measured and rigid displacements:\n$$ \\mathbf{u}_i^{\\mathrm{corr}} = \\mathbf{u}_i^{\\mathrm{meas}} - \\mathbf{u}_i^{\\mathrm{rigid}} = (\\mathbf{y}_i - \\mathbf{x}_i) - ((\\mathbf{R} - \\mathbf{I})\\mathbf{x}_i + \\mathbf{t}) = \\mathbf{y}_i - (\\mathbf{R}\\mathbf{x}_i + \\mathbf{t}) $$\nThe residual error is quantified by the Root-Mean-Square (RMS) norm of these corrected displacements:\n$$ \\text{RMS} = \\sqrt{\\frac{1}{N}\\sum_{i=1}^N \\lVert \\mathbf{u}_i^{\\mathrm{corr}} \\rVert_2^2} $$\nThe principal rotation angle $\\theta \\in [0, \\pi]$ is computed from the trace of the estimated rotation matrix $\\mathbf{R}$. For $d=2$, $\\theta = \\arccos(\\frac{\\mathrm{tr}(\\mathbf{R})}{2})$. For $d=3$, $\\theta = \\arccos(\\frac{\\mathrm{tr}(\\mathbf{R}) - 1}{2})$. In the degenerate case where all centered reference points are zero, the covariance matrix $\\mathbf{H}$ is the zero matrix. Its SVD is not unique, but a standard implementation will typically yield $\\mathbf{U}=\\mathbf{V}=\\mathbf{I}$, which leads to $\\mathbf{R}=\\mathbf{I}$ and $\\theta=0$, satisfying the problem's edge-case policy.", "answer": "```python\nimport numpy as np\n\ndef estimate_rigid_motion(X, Y):\n    \"\"\"\n    Estimates the rigid body motion (R, t) that best aligns point set X to Y.\n    \n    Args:\n        X (np.ndarray): Reference points, shape (d, N).\n        Y (np.ndarray): Deformed points, shape (d, N).\n\n    Returns:\n        tuple[np.ndarray, np.ndarray]: Estimated rotation matrix R and translation vector t.\n    \"\"\"\n    d, N = X.shape\n    \n    # 1. Compute centroids\n    x_bar = np.mean(X, axis=1, keepdims=True)\n    y_bar = np.mean(Y, axis=1, keepdims=True)\n    \n    # 2. Compute centered coordinates\n    X_prime = X - x_bar\n    Y_prime = Y - y_bar\n    \n    # 3. Compute covariance matrix H\n    H = X_prime @ Y_prime.T\n    \n    # 4. Compute SVD of H\n    U, s, Vt = np.linalg.svd(H)\n    \n    # 5. Compute optimal rotation R\n    R = Vt.T @ U.T\n    \n    # 6. Check for reflection and correct if necessary\n    if np.linalg.det(R)  0:\n        S = np.identity(d)\n        S[d-1, d-1] = -1\n        R = Vt.T @ S @ U.T\n\n    # 7. Compute optimal translation t\n    t = y_bar - R @ x_bar\n    \n    return R, t.flatten()\n\ndef solve():\n    \"\"\"\n    Solves the problem for all specified test cases.\n    \"\"\"\n    test_cases = [\n        # Test case 1 (d=2)\n        {\n            \"d\": 2,\n            \"x\": np.array([[0, 0], [1, 0], [1, 1], [0, 1]], dtype=float),\n            \"rot_params\": {\"theta\": 0.2},\n            \"t_true\": np.array([0.05, -0.03], dtype=float),\n            \"B\": np.diag([0.001, -0.0005])\n        },\n        # Test case 2 (d=3)\n        {\n            \"d\": 3,\n            \"x\": np.array([[0, 0, 0], [1, 0, 0], [0, 1, 0], [0, 0, 1], [1, 1, 1]], dtype=float),\n            \"rot_params\": {\"axis\": np.array([1, 2, 3]) / np.sqrt(14), \"theta\": 0.3},\n            \"t_true\": np.array([-0.02, 0.04, 0.03], dtype=float),\n            \"B\": np.diag([0.0008, -0.0006, 0.0004])\n        },\n        # Test case 3 (d=2, pure translation)\n        {\n            \"d\": 2,\n            \"x\": np.array([[0, 0], [2, 0], [0, 2]], dtype=float),\n            \"rot_params\": {\"theta\": 0.0},\n            \"t_true\": np.array([0.1, -0.05], dtype=float),\n            \"B\": np.zeros((2, 2))\n        },\n        # Test case 4 (d=3, degenerate geometry)\n        {\n            \"d\": 3,\n            \"x\": np.array([[2, 2, 2], [2, 2, 2], [2, 2, 2], [2, 2, 2]], dtype=float),\n            \"rot_params\": {\"axis\": np.array([1, 0, 0]), \"theta\": 0.1}, # Axis/angle irrelevant\n            \"t_true\": np.array([0.01, 0.02, -0.03], dtype=float),\n            \"B\": np.zeros((3, 3))\n        }\n    ]\n    \n    results = []\n    \n    for case in test_cases:\n        d = case[\"d\"]\n        X = case[\"x\"].T # Transpose to get shape (d, N)\n        N = X.shape[1]\n        t_true = case[\"t_true\"]\n        B = case[\"B\"]\n        \n        # Generate true rotation matrix\n        if d == 2:\n            theta_true = case[\"rot_params\"][\"theta\"]\n            c, s = np.cos(theta_true), np.sin(theta_true)\n            R_true = np.array([[c, -s], [s, c]])\n        else: # d == 3\n            theta_true = case[\"rot_params\"][\"theta\"]\n            axis = case[\"rot_params\"][\"axis\"]\n            c, s = np.cos(theta_true), np.sin(theta_true)\n            ax = axis[0]\n            ay = axis[1]\n            az = axis[2]\n            # Skew-symmetric matrix\n            a_cross = np.array([[0, -az, ay], [az, 0, -ax], [-ay, ax, 0]])\n            # Rodrigues' formula\n            R_true = c * np.identity(3) + s * a_cross + (1 - c) * np.outer(axis, axis)\n        \n        # Synthesize measured displacements and deformed positions\n        u_rigid = (R_true - np.identity(d)) @ X\n        u_non_rigid = B @ X\n        U_meas = u_rigid + u_non_rigid + t_true.reshape(d, 1)\n        u_meas = U_meas.T\n        Y = X + U_meas\n        \n        # Estimate rigid motion\n        R_est, t_est = estimate_rigid_motion(X, Y)\n        \n        # Compute corrected displacements\n        U_rigid_est = (R_est - np.identity(d)) @ X + t_est.reshape(d, 1)\n        U_corr = U_meas - U_rigid_est\n        \n        # Compute RMS of corrected displacements\n        rms_corr = np.sqrt(np.mean(np.sum(U_corr**2, axis=0)))\n        \n        # Compute principal rotation angle\n        # Clip argument to arccos to handle potential floating point inaccuracies\n        if d == 2:\n            trace_R = np.trace(R_est)\n            cos_theta = np.clip(trace_R / 2.0, -1.0, 1.0)\n            theta_est = np.arccos(cos_theta)\n        else: # d == 3\n            trace_R = np.trace(R_est)\n            cos_theta = np.clip((trace_R - 1.0) / 2.0, -1.0, 1.0)\n            theta_est = np.arccos(cos_theta)\n            \n        results.extend([theta_est, rms_corr])\n        \n    # Final print statement in the exact required format\n    print(f\"[{','.join(f'{r:.8f}' for r in results)}]\")\n\nsolve()\n```", "id": "2914458"}]}