{"hands_on_practices": [{"introduction": "Many engineering materials, like concrete or composites, exhibit a \"unilateral\" damage response: their stiffness degrades in tension due to micro-cracking, but these cracks can close under compression, restoring stiffness. This practice challenges you to model this behavior using a thermodynamically consistent framework based on a specified Helmholtz free energy function, $\\psi$. By tracking the evolution of a damage variable, $d$, through a compression-unloading-tension cycle, you will gain hands-on experience with history-dependent constitutive laws and the practical implementation of unilateral damage models [@problem_id:2895542].", "problem": "Consider a small-strain, uniaxial bar made of a brittle quasibrittle solid modeled by an isotropic scalar damage variable $d \\in [0,1]$ with a unilateral effect (damage affects only the tensile response). Let the Helmholtz free energy per unit reference volume be\n$$\n\\psi(\\epsilon,d) = \\tfrac{1}{2} E \\left[(1-d)\\langle \\epsilon \\rangle_{+}^{2} + \\langle \\epsilon \\rangle_{-}^{2}\\right],\n$$\nwhere $E$ is the Young’s modulus, $\\epsilon$ is the longitudinal strain, and $\\langle \\epsilon \\rangle_{+} = \\max(\\epsilon,0)$, $\\langle \\epsilon \\rangle_{-} = \\min(\\epsilon,0)$ denote the tensile and compressive parts of the strain, respectively. The Cauchy stress is defined by thermodynamics as $\\sigma = \\partial \\psi/\\partial \\epsilon$. The damage driving force is $Y = -\\partial \\psi/\\partial d$, and damage evolves irreversibly in tension according to a history variable $\\kappa(t) = \\max_{\\tau \\in [0,t]} \\langle \\epsilon(\\tau) \\rangle_{+}$ enforced by standard Kuhn–Tucker (KT) conditions. Assume that the damage evolution is given by the well-tested exponential softening law\n$$\nd(\\kappa) =\n\\begin{cases}\n0, & \\kappa \\le \\kappa_{0},\\\\[4pt]\n1 - \\dfrac{\\kappa_{0}}{\\kappa}\\,\\exp\\!\\big(-B(\\kappa - \\kappa_{0})\\big), & \\kappa > \\kappa_{0},\n\\end{cases}\n$$\nwith $\\kappa_{0} > 0$ the tensile damage onset strain and $B > 0$ a material parameter controlling post-onset softening.\n\nA uniaxial loading path is applied in three stages:\n- Stage A (monotonic compression): from $\\epsilon = 0$ to $\\epsilon_{A} = -0.002$.\n- Stage B (unloading): from $\\epsilon_{A}$ back to zero stress.\n- Stage C (monotonic tension): from the end of Stage B up to $\\epsilon_{C} = 0.0018$.\n\nMaterial parameters are $E = 70\\,\\text{GPa}$, $\\kappa_{0} = 0.001$, and $B = 100$. Take the material initially undamaged with $d(0) = 0$.\n\nTasks:\n1. Starting from the given free energy and definitions, derive the piecewise uniaxial stress–strain relation $\\sigma(\\epsilon)$ that captures the unilateral effect, and identify the unloading path in Stage B and the initial reloading stiffness in Stage C.\n2. Using your derived relations, compute the nominal stress at the end of Stage C, that is, $\\sigma(\\epsilon_{C})$.\n\nExpress the final nominal stress in $\\text{MPa}$ and round your answer to three significant figures. Provide only the final numeric value (no units) in your final answer.", "solution": "The problem as stated is scientifically grounded, well-posed, and complete. It represents a standard exercise in continuum damage mechanics. We shall proceed with the derivation and solution.\n\nFirst, we must derive the constitutive relation for the Cauchy stress, $\\sigma$, from the given Helmholtz free energy per unit volume, $\\psi$. The stress is defined by the thermodynamic relation $\\sigma = \\frac{\\partial \\psi}{\\partial \\epsilon}$. The free energy is given as:\n$$\n\\psi(\\epsilon,d) = \\frac{1}{2} E \\left[(1-d)\\langle \\epsilon \\rangle_{+}^{2} + \\langle \\epsilon \\rangle_{-}^{2}\\right]\n$$\nwhere $\\langle \\epsilon \\rangle_{+} = \\max(\\epsilon,0)$ and $\\langle \\epsilon \\rangle_{-} = \\min(\\epsilon,0)$. To compute the derivative, we must consider two cases based on the sign of the strain $\\epsilon$.\n\nCase 1: Tension ($\\epsilon > 0$).\nIn this case, $\\langle \\epsilon \\rangle_{+} = \\epsilon$ and $\\langle \\epsilon \\rangle_{-} = 0$. The free energy expression simplifies to:\n$$\n\\psi(\\epsilon > 0, d) = \\frac{1}{2} E (1-d) \\epsilon^2\n$$\nThe stress is then:\n$$\n\\sigma = \\frac{\\partial}{\\partial \\epsilon} \\left( \\frac{1}{2} E (1-d) \\epsilon^2 \\right) = E(1-d)\\epsilon\n$$\nThe effective Young's modulus in tension is $E_{\\text{eff}} = E(1-d)$, which degrades as damage $d$ accumulates.\n\nCase 2: Compression ($\\epsilon < 0$).\nIn this case, $\\langle \\epsilon \\rangle_{+} = 0$ and $\\langle \\epsilon \\rangle_{-} = \\epsilon$. The free energy expression becomes:\n$$\n\\psi(\\epsilon < 0, d) = \\frac{1}{2} E \\epsilon^2\n$$\nThe stress is then:\n$$\n\\sigma = \\frac{\\partial}{\\partial \\epsilon} \\left( \\frac{1}{2} E \\epsilon^2 \\right) = E\\epsilon\n$$\nIn compression, the response is linear elastic with the initial, undamaged Young's modulus $E$, irrespective of the value of the damage variable $d$. This is the meaning of a unilateral damage effect.\n\nFor completeness, at $\\epsilon=0$, both expressions yield $\\sigma=0$, ensuring continuity. Combining these results gives the piecewise stress-strain relation:\n$$\n\\sigma(\\epsilon) =\n\\begin{cases}\nE(1-d)\\epsilon, & \\epsilon \\ge 0 \\\\\nE\\epsilon, & \\epsilon < 0\n\\end{cases}\n$$\nThis is the uniaxial stress-strain relation required by the first task. The damage variable $d$ is a function of the history variable $\\kappa(t) = \\max_{\\tau \\in [0,t]} \\langle \\epsilon(\\tau) \\rangle_{+}$.\n\nNext, we analyze the prescribed three-stage loading path, tracking the state variables $(\\epsilon, \\sigma, \\kappa, d)$. The initial state is $\\epsilon(0)=0$, $\\sigma(0)=0$, and from the problem statement, $d(0)=0$. This implies $\\kappa(0) = \\langle\\epsilon(0)\\rangle_+ = 0$.\n\nStage A (Monotonic Compression): The strain is driven from $\\epsilon=0$ to $\\epsilon_A = -0.002$.\nThroughout this stage, the strain $\\epsilon(\\tau)$ is non-positive. Therefore, the tensile part of the strain is always zero: $\\langle \\epsilon(\\tau) \\rangle_{+} = 0$.\nThe history variable remains at its initial value:\n$$\n\\kappa(\\tau) = \\max_{s \\in [0, \\tau]} \\langle \\epsilon(s) \\rangle_{+} = 0\n$$\nSince $\\kappa = 0 \\le \\kappa_0 = 0.001$, the damage variable does not evolve and remains at its initial value, $d(\\kappa)=d(0)=0$.\nThe stress-strain response follows the compressive branch: $\\sigma(\\epsilon) = E\\epsilon$.\nAt the end of Stage A, we have $\\epsilon_A = -0.002$, $\\kappa_A = 0$, and $d_A=0$.\n\nStage B (Unloading to Zero Stress): The strain is driven from $\\epsilon_A = -0.002$ until $\\sigma=0$.\nSince the response in the compressive regime is linear elastic, unloading follows the same path as loading. The stress becomes zero when the strain returns to zero. The path is $\\sigma=E\\epsilon$ for $\\epsilon \\in [-0.002, 0]$. This is the unloading path in Stage B.\nDuring this stage, the strain remains non-positive, so $\\kappa$ and $d$ do not change.\nAt the end of Stage B, the state is: $\\epsilon_B=0$, $\\sigma_B=0$, $\\kappa_B=0$, and $d_B=0$.\n\nStage C (Monotonic Tension): The strain is driven from $\\epsilon=0$ to $\\epsilon_C = 0.0018$.\nThe material is now subjected to tensile strain, $\\epsilon \\ge 0$. The stress-strain relation is $\\sigma(\\epsilon) = E(1-d)\\epsilon$.\nBecause the loading is monotonic from $\\epsilon=0$, the history variable is equal to the current strain: $\\kappa(\\epsilon) = \\epsilon$. Damage evolution is now active and depends directly on strain, $d=d(\\kappa)=d(\\epsilon)$.\nWe must consider the damage threshold $\\kappa_0 = 0.001$.\n\n- For $0 \\le \\epsilon \\le \\kappa_0$:\nIn this range, $\\kappa=\\epsilon \\le \\kappa_0$, so the damage law gives $d(\\kappa) = 0$.\nThe stress-strain relation is $\\sigma(\\epsilon) = E(1-0)\\epsilon = E\\epsilon$. The response is linear elastic. The initial reloading stiffness in Stage C is therefore the undamaged Young's modulus, $E$. This completes the first task.\n\n- For $\\epsilon > \\kappa_0$:\nDamage initiates and evolves according to the specified law:\n$$\nd(\\epsilon) = 1 - \\frac{\\kappa_{0}}{\\epsilon}\\,\\exp(-B(\\epsilon - \\kappa_{0}))\n$$\nSubstituting this into the tensile stress-strain relation:\n$$\n\\sigma(\\epsilon) = E\\left(1 - \\left[1 - \\frac{\\kappa_{0}}{\\epsilon}\\,\\exp(-B(\\epsilon - \\kappa_{0}))\\right]\\right)\\epsilon\n$$\nThis simplifies to the post-peak softening response:\n$$\n\\sigma(\\epsilon) = E\\kappa_0\\exp(-B(\\epsilon - \\kappa_0))\n$$\n\nNow, we perform the second task: compute the stress at the end of Stage C, $\\sigma(\\epsilon_C)$, where $\\epsilon_C = 0.0018$.\nThe material parameters are given as $E = 70\\,\\text{GPa} = 70 \\times 10^9\\,\\text{Pa}$, $\\kappa_0 = 0.001$, and $B=100$.\nSince $\\epsilon_C = 0.0018 > \\kappa_0 = 0.001$, we must use the softening stress relation.\n$$\n\\sigma(\\epsilon_C) = E \\kappa_0 \\exp(-B(\\epsilon_C - \\kappa_0))\n$$\nSubstitute the numerical values:\n$$\n\\sigma(0.0018) = (70 \\times 10^9\\,\\text{Pa}) \\times (0.001) \\times \\exp(-100 \\times (0.0018 - 0.001))\n$$\n$$\n\\sigma(0.0018) = (70 \\times 10^6\\,\\text{Pa}) \\times \\exp(-100 \\times 0.0008)\n$$\n$$\n\\sigma(0.0018) = 70 \\times 10^6 \\times \\exp(-0.08)\\,\\text{Pa}\n$$\nThe stress is required in MPa, where $1\\,\\text{MPa} = 10^6\\,\\text{Pa}$.\n$$\n\\sigma(0.0018) = 70 \\times \\exp(-0.08)\\,\\text{MPa}\n$$\nCalculating the value:\n$$\n\\exp(-0.08) \\approx 0.923116\n$$\n$$\n\\sigma(0.0018) \\approx 70 \\times 0.923116\\,\\text{MPa} \\approx 64.6181\\,\\text{MPa}\n$$\nRounding to three significant figures as requested, we obtain $\\sigma(\\epsilon_C) \\approx 64.6\\,\\text{MPa}$.", "answer": "$$\n\\boxed{64.6}\n$$", "id": "2895542"}, {"introduction": "Extending a one-dimensional damage model to a full three-dimensional description requires defining a scalar \"equivalent strain\" that serves as the driver for isotropic damage evolution. This choice is a critical modeling decision, as different definitions can predict vastly different material behaviors under multiaxial stress. This exercise guides you through a direct comparison of two common equivalent strain formulations, calibrated in uniaxial tension, to reveal their differing responses in pure shear, providing crucial insight into the art and science of constitutive modeling [@problem_id:2895669].", "problem": "Consider a small-strain, initially isotropic linear elastic solid in three-dimensional (3D) space with Young’s modulus $E$ and Poisson’s ratio $\\nu$. Two scalar damage-driving variables are under consideration: (i) $\\kappa_{1}=\\|\\varepsilon\\|$, the Frobenius norm of the small-strain tensor $\\varepsilon$, and (ii) $\\kappa_{2}=\\sqrt{2W/E_{0}}$, where $W$ is the elastic strain energy density and $E_{0}$ is a positive elastic modulus scale. Take $E_{0}=E$. Define for each $\\kappa_{i}$ a multiaxial equivalent strain $\\tilde{\\varepsilon}^{(i)}$ by calibrating it in uniaxial tension so that for a uniaxial tensile state with traction-free lateral faces and axial engineering strain $e>0$, one has $\\tilde{\\varepsilon}^{(i)}=e$. Starting only from the definitions of small strain, isotropic linear elasticity, and elastic strain energy density, perform the following steps:\n\n- For uniaxial tension with traction-free lateral faces, write the strain tensor and determine the value of $\\kappa_{1}$ and $\\kappa_{2}$ in terms of $e$, $E$, and $\\nu$.\n- For pure shear with engineering shear strain $\\gamma$ (that is, $\\varepsilon_{12}=\\varepsilon_{21}=\\gamma/2$ and all other components zero), determine the value of $\\kappa_{1}$ and $\\kappa_{2}$ in terms of $\\gamma$, $E$, and $\\nu$.\n- Using the uniaxial calibration $\\tilde{\\varepsilon}^{(i)}=e$, determine $\\tilde{\\varepsilon}^{(i)}$ for the pure shear state as functions of $\\gamma$, $E$, and $\\nu$.\n- Compare the two by forming the ratio $\\rho(\\nu)=\\tilde{\\varepsilon}^{(2)}_{\\mathrm{ps}}/\\tilde{\\varepsilon}^{(1)}_{\\mathrm{ps}}$ for the pure shear state.\n\nProvide your final answer as a single simplified analytic expression for $\\rho(\\nu)$ in terms of $\\nu$ only. Do not include units in your final answer. No numerical rounding is required.", "solution": "The problem requires the comparison of two different scalar measures of multiaxial strain, known as equivalent strains, which are derived from two distinct damage-driving variables, $\\kappa_{1}$ and $\\kappa_{2}$. The comparison is to be performed for a state of pure shear after calibrating both measures using a uniaxial tension state. The material is a small-strain, initially isotropic linear elastic solid.\n\nFirst, we state the necessary constitutive relations. For an isotropic linear elastic material, the stress tensor $\\sigma$ is related to the small strain tensor $\\varepsilon$ by the generalized Hooke's law:\n$$ \\sigma_{ij} = \\lambda \\delta_{ij} \\varepsilon_{kk} + 2\\mu \\varepsilon_{ij} $$\nwhere $\\lambda$ and $\\mu$ are the Lamé parameters, and $\\delta_{ij}$ is the Kronecker delta. The parameter $\\mu$ is the shear modulus, often denoted by $G$, and it relates to Young's modulus $E$ and Poisson's ratio $\\nu$ by $\\mu = \\frac{E}{2(1+\\nu)}$. The elastic strain energy density $W$ is given by:\n$$ W = \\frac{1}{2} \\sigma_{ij} \\varepsilon_{ij} $$\nThe two damage-driving variables are $\\kappa_{1} = \\|\\varepsilon\\| = \\sqrt{\\varepsilon_{ij}\\varepsilon_{ij}}$ and $\\kappa_{2} = \\sqrt{2W/E}$, since $E_0=E$ is given.\n\nThe procedure is as follows:\n1.  Analyze the uniaxial tension state to find $\\kappa_1$ and $\\kappa_2$.\n2.  Calibrate the equivalent strains $\\tilde{\\varepsilon}^{(i)}$ such that $\\tilde{\\varepsilon}^{(i)}=e$ for uniaxial tension.\n3.  Analyze the pure shear state to find $\\kappa_1$ and $\\kappa_2$.\n4.  Calculate the equivalent strains $\\tilde{\\varepsilon}^{(i)}$ for pure shear using the calibrated forms.\n5.  Compute the ratio $\\rho(\\nu) = \\tilde{\\varepsilon}^{(2)}_{\\mathrm{ps}}/\\tilde{\\varepsilon}^{(1)}_{\\mathrm{ps}}$.\n\n**Step 1: Uniaxial Tension Analysis**\nConsider a state of uniaxial tension along the $x_1$-axis with axial engineering strain $e > 0$. The strain in this direction is $\\varepsilon_{11} = e$. The lateral faces are traction-free, which implies a uniaxial stress state: $\\sigma_{11} \\neq 0$ and all other stress components are zero ($\\sigma_{22} = \\sigma_{33} = \\sigma_{ij}|_{i \\neq j} = 0$).\nFrom Hooke's law in terms of $E$ and $\\nu$:\n$$ \\varepsilon_{11} = \\frac{1}{E} \\sigma_{11} \\implies e = \\frac{\\sigma_{11}}{E} \\implies \\sigma_{11} = Ee $$\nThe lateral strains are:\n$$ \\varepsilon_{22} = -\\frac{\\nu}{E} \\sigma_{11} = -\\nu e $$\n$$ \\varepsilon_{33} = -\\frac{\\nu}{E} \\sigma_{11} = -\\nu e $$\nAll shear strains are zero. The strain tensor is:\n$$ \\varepsilon_{\\text{ut}} = \\begin{pmatrix} e & 0 & 0 \\\\ 0 & -\\nu e & 0 \\\\ 0 & 0 & -\\nu e \\end{pmatrix} $$\nNow we compute $\\kappa_{1}$ for this state (denoted $\\kappa_{1, \\text{ut}}$):\n$$ \\kappa_{1, \\text{ut}} = \\|\\varepsilon_{\\text{ut}}\\| = \\sqrt{\\varepsilon_{ij}\\varepsilon_{ij}} = \\sqrt{\\varepsilon_{11}^2 + \\varepsilon_{22}^2 + \\varepsilon_{33}^2} = \\sqrt{e^2 + (-\\nu e)^2 + (-\\nu e)^2} = \\sqrt{e^2(1 + 2\\nu^2)} $$\nSince $e>0$, we have $\\kappa_{1, \\text{ut}} = e\\sqrt{1 + 2\\nu^2}$.\n\nNext, we compute the strain energy density $W_{\\text{ut}}$:\n$$ W_{\\text{ut}} = \\frac{1}{2}\\sigma_{ij}\\varepsilon_{ij} = \\frac{1}{2} \\sigma_{11}\\varepsilon_{11} = \\frac{1}{2}(Ee)(e) = \\frac{1}{2}Ee^2 $$\nNow we compute $\\kappa_{2, \\text{ut}}$:\n$$ \\kappa_{2, \\text{ut}} = \\sqrt{\\frac{2W_{\\text{ut}}}{E}} = \\sqrt{\\frac{2(\\frac{1}{2}Ee^2)}{E}} = \\sqrt{e^2} = e $$\n\n**Step 2: Calibration of Equivalent Strains**\nThe problem defines the equivalent strains $\\tilde{\\varepsilon}^{(i)}$ by the condition that $\\tilde{\\varepsilon}^{(i)} = e$ in the uniaxial tension state described above. We assume a simple proportional relationship, $\\tilde{\\varepsilon}^{(i)} = C_i \\kappa_i$, where $C_i$ are calibration constants.\n\nFor $i=1$:\n$$ \\tilde{\\varepsilon}^{(1)}_{\\text{ut}} = C_1 \\kappa_{1, \\text{ut}} \\implies e = C_1 (e\\sqrt{1 + 2\\nu^2}) \\implies C_1 = \\frac{1}{\\sqrt{1 + 2\\nu^2}} $$\nThus, the first equivalent strain is defined as $\\tilde{\\varepsilon}^{(1)} = \\frac{\\kappa_1}{\\sqrt{1+2\\nu^2}} = \\frac{\\|\\varepsilon\\|}{\\sqrt{1+2\\nu^2}}$.\n\nFor $i=2$:\n$$ \\tilde{\\varepsilon}^{(2)}_{\\text{ut}} = C_2 \\kappa_{2, \\text{ut}} \\implies e = C_2 e \\implies C_2 = 1 $$\nThus, the second equivalent strain is defined as $\\tilde{\\varepsilon}^{(2)} = \\kappa_2 = \\sqrt{\\frac{2W}{E}}$.\n\n**Step 3: Pure Shear Analysis**\nConsider a state of pure shear with engineering shear strain $\\gamma$. The strain tensor components are given as $\\varepsilon_{12} = \\varepsilon_{21} = \\gamma/2$, and all other components are zero.\n$$ \\varepsilon_{\\text{ps}} = \\begin{pmatrix} 0 & \\gamma/2 & 0 \\\\ \\gamma/2 & 0 & 0 \\\\ 0 & 0 & 0 \\end{pmatrix} $$\nFirst, we compute $\\kappa_{1}$ for this state (denoted $\\kappa_{1, \\text{ps}}$), assuming $\\gamma > 0$ without loss of generality:\n$$ \\kappa_{1, \\text{ps}} = \\|\\varepsilon_{\\text{ps}}\\| = \\sqrt{\\varepsilon_{ij}\\varepsilon_{ij}} = \\sqrt{(\\gamma/2)^2 + (\\gamma/2)^2} = \\sqrt{\\frac{2\\gamma^2}{4}} = \\frac{\\gamma}{\\sqrt{2}} $$\nNext, we compute the stress tensor and strain energy density. The trace of the strain tensor is $\\text{tr}(\\varepsilon_{\\text{ps}}) = 0$. So, Hooke's law simplifies to $\\sigma_{ij} = 2\\mu\\varepsilon_{ij}$.\nThe only non-zero stress component is $\\sigma_{12} = \\sigma_{21} = 2\\mu\\varepsilon_{12} = 2\\mu(\\gamma/2) = \\mu\\gamma$.\nThe strain energy density $W_{\\text{ps}}$ is:\n$$ W_{\\text{ps}} = \\frac{1}{2}\\sigma_{ij}\\varepsilon_{ij} = \\frac{1}{2}(\\sigma_{12}\\varepsilon_{12} + \\sigma_{21}\\varepsilon_{21}) = \\sigma_{12}\\varepsilon_{12} = (\\mu\\gamma)(\\gamma/2) = \\frac{1}{2}\\mu\\gamma^2 $$\nSubstituting $\\mu = \\frac{E}{2(1+\\nu)}$:\n$$ W_{\\text{ps}} = \\frac{1}{2} \\left(\\frac{E}{2(1+\\nu)}\\right) \\gamma^2 = \\frac{E\\gamma^2}{4(1+\\nu)} $$\nNow we compute $\\kappa_{2, \\text{ps}}$:\n$$ \\kappa_{2, \\text{ps}} = \\sqrt{\\frac{2W_{\\text{ps}}}{E}} = \\sqrt{\\frac{2}{E} \\left(\\frac{E\\gamma^2}{4(1+\\nu)}\\right)} = \\sqrt{\\frac{\\gamma^2}{2(1+\\nu)}} = \\frac{\\gamma}{\\sqrt{2(1+\\nu)}} $$\n\n**Step 4: Equivalent Strains for Pure Shear**\nUsing the calibrated functions from Step 2 and the values from Step 3, we find the equivalent strains for the pure shear state, $\\tilde{\\varepsilon}^{(1)}_{\\mathrm{ps}}$ and $\\tilde{\\varepsilon}^{(2)}_{\\mathrm{ps}}$.\n\n$$ \\tilde{\\varepsilon}^{(1)}_{\\mathrm{ps}} = C_1 \\kappa_{1, \\text{ps}} = \\frac{1}{\\sqrt{1+2\\nu^2}} \\cdot \\frac{\\gamma}{\\sqrt{2}} = \\frac{\\gamma}{\\sqrt{2(1+2\\nu^2)}} $$\n$$ \\tilde{\\varepsilon}^{(2)}_{\\mathrm{ps}} = C_2 \\kappa_{2, \\text{ps}} = 1 \\cdot \\frac{\\gamma}{\\sqrt{2(1+\\nu)}} = \\frac{\\gamma}{\\sqrt{2(1+\\nu)}} $$\n\n**Step 5: The Ratio $\\rho(\\nu)$**\nFinally, we form the ratio $\\rho(\\nu) = \\tilde{\\varepsilon}^{(2)}_{\\mathrm{ps}}/\\tilde{\\varepsilon}^{(1)}_{\\mathrm{ps}}$.\n$$ \\rho(\\nu) = \\frac{\\tilde{\\varepsilon}^{(2)}_{\\mathrm{ps}}}{\\tilde{\\varepsilon}^{(1)}_{\\mathrm{ps}}} = \\frac{\\frac{\\gamma}{\\sqrt{2(1+\\nu)}}}{\\frac{\\gamma}{\\sqrt{2(1+2\\nu^2)}}} = \\frac{\\sqrt{2(1+2\\nu^2)}}{\\sqrt{2(1+\\nu)}} = \\sqrt{\\frac{2(1+2\\nu^2)}{2(1+\\nu)}} = \\sqrt{\\frac{1+2\\nu^2}{1+\\nu}} $$\nThe final expression depends only on the Poisson's ratio $\\nu$, as required.", "answer": "$$\n\\boxed{\\sqrt{\\frac{1+2\\nu^2}{1+\\nu}}}\n$$", "id": "2895669"}, {"introduction": "To capture damage that is inherently directional, such as the behavior of oriented micro-cracks, we need more advanced tools than a single scalar variable. The spectral decomposition of the strain tensor, $\\varepsilon$, provides an elegant framework for modeling such phenomena by defining operators like $\\varepsilon^{+}$ and $\\varepsilon^{-}$ based on its eigenvalues. This advanced computational practice involves implementing this unilateral spectral split and, crucially, deriving its derivative to formulate a consistent tangent operator, a cornerstone for building robust and efficient finite element simulations of complex material failure [@problem_id:2895592].", "problem": "You are asked to design and implement a robust algorithm for the spectral unilateral split used in damage mechanics, and to verify its Fréchet derivatives needed for a consistent tangent operator. Work in small strain, where the strain tensor is symmetric. Your task combines a derivation from first principles and an implementation that is numerically robust for distinct and repeated principal strains, including the non-differentiability at zero.\n\nStarting point and definitions to use:\n- The spectral theorem for real symmetric tensors: any symmetric tensor $\\varepsilon \\in \\mathbb{R}^{3 \\times 3}$ admits a decomposition $\\varepsilon = \\sum_{i=1}^{3} \\lambda_i \\, \\mathbf{P}_i$, where $\\lambda_i \\in \\mathbb{R}$ are eigenvalues and $\\mathbf{P}_i = \\mathbf{n}_i \\otimes \\mathbf{n}_i$ are orthogonal rank-$1$ projectors built from orthonormal eigenvectors $\\mathbf{n}_i$.\n- The Macaulay positive and negative parts of a scalar $x$ are $\\langle x \\rangle = \\max(x,0)$ and $x^{-} = \\min(x,0)$.\n- The unilateral spectral split of the strain tensor is defined by\n  $\\varepsilon^{+} = \\sum_{i=1}^{3} \\langle \\lambda_i \\rangle \\, \\mathbf{P}_i$ and $\\varepsilon^{-} = \\sum_{i=1}^{3} \\lambda_i^{-} \\, \\mathbf{P}_i$.\n- The Fréchet derivative of a tensor function $f(\\varepsilon)$ at $\\varepsilon$ in direction $\\mathbf{H}$ is the linear map $Df(\\varepsilon)[\\mathbf{H}]$ such that $f(\\varepsilon+\\delta \\mathbf{H}) = f(\\varepsilon) + \\delta \\, Df(\\varepsilon)[\\mathbf{H}] + o(\\delta)$ as $\\delta \\to 0$.\n\nTask:\n1. Starting from the spectral theorem and the definition of a spectral tensor function via eigenvalue mapping, derive the algorithm to compute $\\varepsilon^{+}$ and $\\varepsilon^{-}$ for a given symmetric $\\varepsilon$.\n2. From the same fundamental base, derive the Fréchet derivatives $D\\varepsilon^{+}(\\varepsilon)[\\mathbf{H}]$ and $D\\varepsilon^{-}(\\varepsilon)[\\mathbf{H}]$ needed for the consistent tangent. Your derivation must explicitly address:\n   - The contribution from the variation of eigenvalues and eigenprojectors, starting from the general form of the derivative of a spectral function;\n   - The piecewise linearity of the Macaulay mappings and the implications for $f'(\\lambda_i)$ when $\\lambda_i$ is positive, negative, or zero;\n   - The handling of repeated eigenvalues (eigenvalue multiplicity) and the limit of the cross-mode coefficients when $\\lambda_i \\to \\lambda_j$;\n   - A clear and implementable convention at $\\lambda_i = 0$ for the unilateral split, specifying a choice for the Heaviside-like value at zero (take it as $0$).\n3. Implement the algorithm in a program that, for each provided test case, computes:\n   - $\\varepsilon^{+}$ and $\\varepsilon^{-}$,\n   - The directional derivative actions $D\\varepsilon^{+}(\\varepsilon)[\\mathbf{H}]$ and $D\\varepsilon^{-}(\\varepsilon)[\\mathbf{H}]$ for a given symmetric direction $\\mathbf{H}$,\n   - A finite-difference approximation of the directional derivatives using a centered difference with step $h = 10^{-7}$,\n   - The Frobenius-norm errors between the analytical directional derivatives and the finite-difference approximations.\n4. Design your implementation to be robust in the presence of distinct and repeated eigenvalues, with a grouping tolerance $\\tau_{\\text{equal}} = 10^{-8}$ for comparing eigenvalues and a zero-detection tolerance $\\tau_{0} = 10^{-12}$ to decide the sign region and the value of the generalized derivative at zero. Use the convention that at zero the derivative of the positive part is $0$ and the derivative of the negative part is $0$.\n5. No physical units are required because strain is dimensionless.\n6. Angles must be treated in radians.\n\nTest suite to be used in your program:\n- Construct the following symmetric strain tensors from given principal values and rotations, using $\\varepsilon = \\mathbf{R} \\, \\mathrm{diag}(\\lambda_1,\\lambda_2,\\lambda_3) \\, \\mathbf{R}^{\\top}$, where $\\mathbf{R}$ is a rotation matrix built from elementary rotations about coordinate axes. For rotation angles, use radians, and matrix multiplications are in the given order.\n  - Case $1$ (mixed signs, distinct): $\\lambda = [0.012,\\,-0.018,\\,0.006]$, $\\mathbf{R} = \\mathbf{R}_z(0.3)\\,\\mathbf{R}_y(-0.4)$.\n  - Case $2$ (pure tension): $\\lambda = [0.010,\\,0.020,\\,0.015]$, $\\mathbf{R} = \\mathbf{R}_z(0.1)\\,\\mathbf{R}_x(-0.2)$.\n  - Case $3$ (pure compression): $\\lambda = [-0.010,\\,-0.005,\\,-0.020]$, $\\mathbf{R} = \\mathbf{R}_y(0.5)\\,\\mathbf{R}_z(-0.7)$.\n  - Case $4$ (repeated eigenvalues): $\\lambda = [0.010,\\,0.010,\\,-0.002]$, $\\mathbf{R} = \\mathbf{R}_x(0.35)\\,\\mathbf{R}_z(0.21)$.\n  - Case $5$ (boundary with zero): $\\lambda = [0.000,\\,0.010,\\,-0.005]$, $\\mathbf{R} = \\mathbf{R}_y(-0.31)\\,\\mathbf{R}_x(0.27)$.\n- For each case $k \\in \\{1,2,3,4,5\\}$, use the following symmetric direction tensors $\\mathbf{H}_k$ (each is to be normalized to unit Frobenius norm before use):\n  - $\\mathbf{H}_1 = \\begin{bmatrix} 0.2 & -0.1 & 0.05 \\\\ -0.1 & 0.3 & 0.04 \\\\ 0.05 & 0.04 & -0.1 \\end{bmatrix}$,\n  - $\\mathbf{H}_2 = \\begin{bmatrix} 0.05 & 0.02 & -0.01 \\\\ 0.02 & -0.06 & 0.03 \\\\ -0.01 & 0.03 & 0.04 \\end{bmatrix}$,\n  - $\\mathbf{H}_3 = \\begin{bmatrix} -0.1 & 0.02 & 0.01 \\\\ 0.02 & 0.05 & -0.03 \\\\ 0.01 & -0.03 & 0.02 \\end{bmatrix}$,\n  - $\\mathbf{H}_4 = \\begin{bmatrix} 0.0 & 0.1 & -0.05 \\\\ 0.1 & 0.0 & 0.02 \\\\ -0.05 & 0.02 & 0.0 \\end{bmatrix}$,\n  - $\\mathbf{H}_5 = \\begin{bmatrix} 0.03 & -0.02 & 0.04 \\\\ -0.02 & 0.01 & -0.03 \\\\ 0.04 & -0.03 & -0.02 \\end{bmatrix}$.\n- Let the centered-difference step be $h = 10^{-7}$.\n\nRequired final output format for your program:\n- For each case $k$, compute two errors: $e^{+}_k = \\lVert D\\varepsilon^{+}(\\varepsilon_k)[\\mathbf{H}_k] - \\frac{\\varepsilon^{+}(\\varepsilon_k + h \\mathbf{H}_k) - \\varepsilon^{+}(\\varepsilon_k - h \\mathbf{H}_k)}{2h} \\rVert_F$ and $e^{-}_k$ defined analogously for the negative split. Aggregate the results for all five cases into a single Python-style list of $10$ floating-point numbers ordered as $[e^{+}_1, e^{-}_1, e^{+}_2, e^{-}_2, \\dots, e^{+}_5, e^{-}_5]$.\n- Your program should produce a single line of output containing this list, with the numbers comma-separated and enclosed in square brackets, for example, $[a_1,a_2,a_3,\\dots,a_{10}]$.", "solution": "The problem presented is a standard yet non-trivial task in computational continuum mechanics, specifically concerning the constitutive modeling of materials with damage. It requires the computation of the spectral unilateral split of a symmetric strain tensor and, critically, the Fréchet derivative of this split operator. The latter is essential for developing implicit numerical schemes, which require a consistent tangent operator for robust convergence. The problem is well-posed, scientifically grounded, and contains all necessary information for a complete and verifiable solution. We proceed with the derivation and subsequent implementation.\n\nThe solution is structured as follows: First, we present the algorithm for computing the positive and negative parts, $\\varepsilon^{+}$ and $\\varepsilon^{-}$, of a given symmetric tensor $\\varepsilon$. Second, we derive the expression for the Fréchet derivative of the split operators. This derivation gives special attention to the cases of repeated eigenvalues and non-differentiability, which are the main challenges of this problem.\n\nAn arbitrary symmetric second-order tensor $\\varepsilon \\in \\text{Sym}(3)$, where $\\text{Sym}(3)$ is the space of symmetric $3 \\times 3$ real matrices, admits a spectral decomposition:\n$$\n\\varepsilon = \\sum_{i=1}^{3} \\lambda_i \\mathbf{P}_i\n$$\nwhere $\\lambda_i$ are the real eigenvalues of $\\varepsilon$, and $\\mathbf{P}_i = \\mathbf{n}_i \\otimes \\mathbf{n}_i$ are the corresponding rank-one orthogonal projectors. The set of eigenvectors $\\{\\mathbf{n}_i\\}_{i=1}^3$ forms an orthonormal basis. A tensor function $f(\\varepsilon)$ is defined spectrally by applying a scalar function $f$ to its eigenvalues:\n$$\nf(\\varepsilon) = \\sum_{i=1}^{3} f(\\lambda_i) \\mathbf{P}_i\n$$\n\nThe unilateral split of the strain tensor, $\\varepsilon = \\varepsilon^{+} + \\varepsilon^{-}$, is defined using this principle with the scalar positive part function (Macaulay bracket) $f(\\lambda) = \\langle \\lambda \\rangle = \\max(\\lambda, 0)$ and the negative part function $g(\\lambda) = \\lambda^{-} = \\min(\\lambda, 0)$. Thus, the positive and negative parts of the tensor $\\varepsilon$ are given by:\n$$\n\\varepsilon^{+} = \\sum_{i=1}^{3} \\langle \\lambda_i \\rangle \\mathbf{P}_i \\quad \\text{and} \\quad \\varepsilon^{-} = \\sum_{i=1}^{3} \\lambda_i^{-} \\mathbf{P}_i\n$$\n\nThe algorithm to compute $\\varepsilon^{+}$ and $\\varepsilon^{-}$ is a direct application of this definition:\n1.  For a given symmetric tensor $\\varepsilon$, solve the eigenvalue problem to find its eigenvalues $\\lambda_1, \\lambda_2, \\lambda_3$ and a corresponding orthonormal set of eigenvectors $\\mathbf{n}_1, \\mathbf{n}_2, \\mathbf{n}_3$.\n2.  Compute the scalar positive and negative parts of each eigenvalue: $\\lambda_i^{+} = \\langle \\lambda_i \\rangle$ and $\\lambda_i^{-} = \\lambda_i^{-}$.\n3.  Reconstruct the tensor parts using the spectral decomposition formula:\n    $$\n    \\varepsilon^{+} = \\sum_{i=1}^{3} \\lambda_i^{+} (\\mathbf{n}_i \\otimes \\mathbf{n}_i) \\quad \\text{and} \\quad \\varepsilon^{-} = \\sum_{i=1}^{3} \\lambda_i^{-} (\\mathbf{n}_i \\otimes \\mathbf{n}_i)\n    $$\nThis procedure is unambiguous and computationally straightforward.\n\nThe more complex task is the derivation of the Fréchet derivative, or directional derivative, $Df(\\varepsilon)[\\mathbf{H}]$, where $\\mathbf{H}$ is a symmetric tensor representing the direction of perturbation. The general formula for the derivative of a spectral tensor function $f(\\varepsilon)$ is known from tensor analysis and perturbation theory. It is given by:\n$$\nDf(\\varepsilon)[\\mathbf{H}] = \\sum_{i=1}^{3} \\sum_{j=1}^{3} c_{ij} \\, (\\mathbf{P}_i : \\mathbf{H}) \\, \\mathbf{P}_j\n$$\nThis is not the most convenient form. A more practical representation is:\n$$\nDf(\\varepsilon)[\\mathbf{H}] = \\sum_{i=1}^{3} \\sum_{j=1}^{3} c_{ij} \\, \\mathbf{P}_i \\mathbf{H} \\mathbf{P}_j\n$$\nwhere the coefficients $c_{ij}$ are the first-order divided differences of the scalar function $f(\\lambda)$:\n$$\nc_{ij} = f[\\lambda_i, \\lambda_j] = \\begin{cases}\n\\dfrac{f(\\lambda_i) - f(\\lambda_j)}{\\lambda_i - \\lambda_j} & \\text{if } \\lambda_i \\neq \\lambda_j \\\\\nf'(\\lambda_i) & \\text{if } \\lambda_i = \\lambda_j\n\\end{cases}\n$$\nThis formulation correctly handles both distinct and repeated eigenvalues by taking the limit as $\\lambda_j \\to \\lambda_i$, which recovers the derivative $f'(\\lambda_i)$.\n\nWe now apply this general formula to our specific functions, $f^+(\\lambda) = \\langle \\lambda \\rangle$ and $f^-(\\lambda) = \\lambda^-$. The derivatives of these functions are non-standard due to the kinks at $\\lambda=0$. The problem specifies a convention for the generalized derivative at $\\lambda=0$.\nFor the positive part, $f^+(\\lambda) = \\langle \\lambda \\rangle$:\n$$\nf^{+'}(\\lambda) = \\begin{cases}\n1 & \\text{if } \\lambda > 0 \\\\\n0 & \\text{if } \\lambda < 0 \\\\\n0 & \\text{if } \\lambda = 0 \\quad \\text{(by convention)}\n\\end{cases}\n$$\nFor the negative part, $f^-(\\lambda) = \\min(\\lambda, 0)$:\n$$\nf^{-'}(\\lambda) = \\begin{cases}\n0 & \\text{if } \\lambda > 0 \\\\\n1 & \\text{if } \\lambda < 0 \\\\\n0 & \\text{if } \\lambda = 0 \\quad \\text{(by convention)}\n\\end{cases}\n$$\nNotably, with this convention, $f^{+'}(0) + f^{-'}(0) = 0 \\neq 1$, which implies that if an eigenvalue is zero, $D\\varepsilon^{+}[\\mathbf{H}] + D\\varepsilon^{-}[\\mathbf{H}] \\neq \\mathbf{H}$. This is an expected consequence of choosing a specific subgradient at a point of non-differentiability.\n\nThe computational algorithm for the derivative $D\\varepsilon^{+}[\\mathbf{H}]$ (and analogously for $D\\varepsilon^{-}[\\mathbf{H}]$) is as follows:\n1.  Given symmetric tensors $\\varepsilon$ and $\\mathbf{H}$, compute the eigenpairs $(\\lambda_i, \\mathbf{n}_i)$ of $\\varepsilon$. Let $\\mathbf{N}$ be the matrix whose columns are the eigenvectors $\\mathbf{n}_i$.\n2.  Define the scalar functions $f^+(\\lambda) = \\langle \\lambda \\rangle$ and its generalized derivative $f^{+'}(\\lambda)$ according to the specified convention and the zero tolerance $\\tau_0$. Specifically, $f^{+'}(\\lambda) = 1$ if $\\lambda > \\tau_0$ and $0$ otherwise.\n3.  Construct the $3 \\times 3$ coefficient matrix $\\mathbf{C}^{+}$ whose entries are $C^{+}_{ij}$. For each pair $(i, j)$:\n    - If $|\\lambda_i - \\lambda_j| < \\tau_{\\text{equal}}$, set $C^{+}_{ij} = f^{+'}(\\lambda_i)$. This handles both diagonal terms $(i=j)$ and off-diagonal terms for numerically repeated eigenvalues.\n    - If $|\\lambda_i - \\lambda_j| \\ge \\tau_{\\text{equal}}$, set $C^{+}_{ij} = \\frac{\\langle \\lambda_i \\rangle - \\langle \\lambda_j \\rangle}{\\lambda_i - \\lambda_j}$.\n4.  Transform the direction tensor $\\mathbf{H}$ into the eigenbasis of $\\varepsilon$: $\\mathbf{H}' = \\mathbf{N}^{\\top} \\mathbf{H} \\mathbf{N}$. The elements of $\\mathbf{H}'$ are $H'_{ij} = \\mathbf{n}_i \\cdot (\\mathbf{H} \\mathbf{n}_j)$.\n5.  Compute the Hadamard (element-wise) product of the coefficient matrix and the transformed direction matrix: $\\mathbf{M}^{+} = \\mathbf{C}^{+} \\circ \\mathbf{H}'$.\n6.  Transform the result back to the original Cartesian basis: $D\\varepsilon^{+}[\\mathbf{H}] = \\mathbf{N} \\mathbf{M}^{+} \\mathbf{N}^{\\top}$.\n7.  Repeat steps 2-6 for the negative part, using $f^-(\\lambda) = \\min(\\lambda, 0)$ and its corresponding derivative $f^{-'}(\\lambda)$ ($1$ if $\\lambda < -\\tau_0$, $0$ otherwise) to compute $\\mathbf{C}^{-}$ and subsequently $D\\varepsilon^{-}[\\mathbf{H}]$.\n\nThis algorithm is robust for distinct and repeated eigenvalues and adheres to the specified conventions. The verification against a centered finite-difference scheme,\n$$\nD\\varepsilon^{+}(\\varepsilon)[\\mathbf{H}] \\approx \\frac{\\varepsilon^{+}(\\varepsilon + h \\mathbf{H}) - \\varepsilon^{+}(\\varepsilon - h \\mathbf{H})}{2h}\n$$\nprovides a necessary check on the correctness of the derivation and implementation. It must be noted that for the case where an eigenvalue is zero (Case 5), the specified analytical derivative (a subgradient choice of $0$) will differ from the result of the centered difference, which naturally approximates the symmetric derivative (a value of $1/2$ times a projection of $\\mathbf{H}$). This anticipated discrepancy is not a flaw but a feature of non-smooth analysis, and the resulting numerical error will reflect the difference between these two valid definitions of a \"derivative\" at a kink.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function to perform the analysis for all test cases.\n    \"\"\"\n    \n    # Tolerances and constants from the problem description\n    TAU_EQUAL = 1e-8\n    TAU_ZERO = 1e-12\n    FD_STEP = 1e-7\n\n    def rotation_matrix_x(angle):\n        c, s = np.cos(angle), np.sin(angle)\n        return np.array([[1, 0, 0], [0, c, -s], [0, s, c]])\n\n    def rotation_matrix_y(angle):\n        c, s = np.cos(angle), np.sin(angle)\n        return np.array([[c, 0, s], [0, 1, 0], [-s, 0, c]])\n\n    def rotation_matrix_z(angle):\n        c, s = np.cos(angle), np.sin(angle)\n        return np.array([[c, -s, 0], [s, c, 0], [0, 0, 1]])\n\n    def compute_split_and_derivs(epsilon, H):\n        \"\"\"\n        Computes the unilateral split and its analytical Fréchet derivatives.\n        \"\"\"\n        # 1. Eigendecomposition of the strain tensor\n        try:\n            lambdas, n_matrix = np.linalg.eigh(epsilon)\n        except np.linalg.LinAlgError:\n            # Fallback for ill-conditioned matrices, though not expected in test cases\n            return (np.full((3, 3), np.nan),) * 4\n\n        # 2. Scalar functions and their derivatives\n        l_pos = np.maximum(lambdas, 0)\n        l_neg = np.minimum(lambdas, 0)\n        \n        # Derivatives with convention f'(0)=0, using zero tolerance\n        df_pos_dl = np.where(lambdas > TAU_ZERO, 1.0, 0.0)\n        df_neg_dl = np.where(lambdas  -TAU_ZERO, 1.0, 0.0)\n\n        # 3. Compute tensor splits\n        eps_pos = n_matrix @ np.diag(l_pos) @ n_matrix.T\n        eps_neg = n_matrix @ np.diag(l_neg) @ n_matrix.T\n        \n        # 4. Construct coefficient matrices C+ and C-\n        C_pos = np.zeros((3, 3))\n        C_neg = np.zeros((3, 3))\n\n        for i in range(3):\n            for j in range(3):\n                if abs(lambdas[i] - lambdas[j])  TAU_EQUAL:\n                    # Case of equal or nearly equal eigenvalues\n                    C_pos[i, j] = df_pos_dl[i]\n                    C_neg[i, j] = df_neg_dl[i]\n                else:\n                    # Case of distinct eigenvalues\n                    C_pos[i, j] = (l_pos[i] - l_pos[j]) / (lambdas[i] - lambdas[j])\n                    C_neg[i, j] = (l_neg[i] - l_neg[j]) / (lambdas[i] - lambdas[j])\n\n        # 5. Transform H to eigenbasis\n        H_prime = n_matrix.T @ H @ n_matrix\n        \n        # 6. Hadamard product\n        M_pos = C_pos * H_prime\n        M_neg = C_neg * H_prime\n        \n        # 7. Transform back to original basis\n        D_eps_pos = n_matrix @ M_pos @ n_matrix.T\n        D_eps_neg = n_matrix @ M_neg @ n_matrix.T\n        \n        return eps_pos, eps_neg, D_eps_pos, D_eps_neg\n\n    def get_split_only(epsilon):\n        \"\"\"\n        A simplified version to only compute the split for finite difference.\n        \"\"\"\n        try:\n            lambdas, n_matrix = np.linalg.eigh(epsilon)\n        except np.linalg.LinAlgError:\n            return np.full((3, 3), np.nan), np.full((3, 3), np.nan)\n        \n        l_pos = np.maximum(lambdas, 0)\n        l_neg = np.minimum(lambdas, 0)\n\n        eps_pos = n_matrix @ np.diag(l_pos) @ n_matrix.T\n        eps_neg = n_matrix @ np.diag(l_neg) @ n_matrix.T\n        \n        return eps_pos, eps_neg\n\n\n    test_cases = [\n        {\n            \"lambdas\": [0.012, -0.018, 0.006],\n            \"R\": rotation_matrix_z(0.3) @ rotation_matrix_y(-0.4),\n            \"H\": np.array([[0.2, -0.1, 0.05], [-0.1, 0.3, 0.04], [0.05, 0.04, -0.1]]),\n        },\n        {\n            \"lambdas\": [0.010, 0.020, 0.015],\n            \"R\": rotation_matrix_z(0.1) @ rotation_matrix_x(-0.2),\n            \"H\": np.array([[0.05, 0.02, -0.01], [0.02, -0.06, 0.03], [-0.01, 0.03, 0.04]]),\n        },\n        {\n            \"lambdas\": [-0.010, -0.005, -0.020],\n            \"R\": rotation_matrix_y(0.5) @ rotation_matrix_z(-0.7),\n            \"H\": np.array([[-0.1, 0.02, 0.01], [0.02, 0.05, -0.03], [0.01, -0.03, 0.02]]),\n        },\n        {\n            \"lambdas\": [0.010, 0.010, -0.002],\n            \"R\": rotation_matrix_x(0.35) @ rotation_matrix_z(0.21),\n            \"H\": np.array([[0.0, 0.1, -0.05], [0.1, 0.0, 0.02], [-0.05, 0.02, 0.0]]),\n        },\n        {\n            \"lambdas\": [0.000, 0.010, -0.005],\n            \"R\": rotation_matrix_y(-0.31) @ rotation_matrix_x(0.27),\n            \"H\": np.array([[0.03, -0.02, 0.04], [-0.02, 0.01, -0.03], [0.04, -0.03, -0.02]]),\n        },\n    ]\n\n    errors = []\n\n    for case in test_cases:\n        # Construct strain tensor\n        epsilon = case[\"R\"] @ np.diag(case[\"lambdas\"]) @ case[\"R\"].T\n        \n        # Normalize direction tensor H\n        H_raw = case[\"H\"]\n        H = H_raw / np.linalg.norm(H_raw, 'fro')\n\n        # Analytical derivatives\n        _, _, D_eps_pos_ana, D_eps_neg_ana = compute_split_and_derivs(epsilon, H)\n\n        # Finite difference approximation\n        eps_p_h = epsilon + FD_STEP * H\n        eps_m_h = epsilon - FD_STEP * H\n        \n        eps_pos_p, eps_neg_p = get_split_only(eps_p_h)\n        eps_pos_m, eps_neg_m = get_split_only(eps_m_h)\n\n        D_eps_pos_fd = (eps_pos_p - eps_pos_m) / (2 * FD_STEP)\n        D_eps_neg_fd = (eps_neg_p - eps_neg_m) / (2 * FD_STEP)\n        \n        # Compute Frobenius norm of the errors\n        error_pos = np.linalg.norm(D_eps_pos_ana - D_eps_pos_fd, 'fro')\n        error_neg = np.linalg.norm(D_eps_neg_ana - D_eps_neg_fd, 'fro')\n\n        errors.extend([error_pos, error_neg])\n\n    print(f\"[{','.join(f'{e:.12e}' for e in errors)}]\")\n\nsolve()\n```", "id": "2895592"}]}