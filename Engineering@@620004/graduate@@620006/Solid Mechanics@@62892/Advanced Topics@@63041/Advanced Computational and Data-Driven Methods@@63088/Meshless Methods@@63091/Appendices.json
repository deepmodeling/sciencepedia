{"hands_on_practices": [{"introduction": "The cornerstone of a reliable numerical approximation is its ability to exactly reproduce the functions within its own basis set. This is known as the reproduction property, a fundamental measure of an approximation's consistency. This first exercise [@problem_id:2662008] guides you through a numerical experiment to verify this essential property for a 2D Moving Least Squares (MLS) approximation with a linear basis. By confirming that your implementation can exactly replicate an arbitrary linear field, you build confidence in the foundational block of any meshless solver you will develop.", "problem": "You are asked to verify, through a fully reproducible numerical experiment, the linear reproduction property of Moving Least Squares (MLS) meshless shape functions in two dimensions. Consider a set of nodes $\\{\\mathbf{x}_I\\}_{I=1}^N \\subset \\mathbb{R}^2$ and a weight function $w(\\|\\mathbf{x}-\\mathbf{x}_I\\|;h)$ with smoothing length $h>0$. Use a linear polynomial basis $\\boldsymbol{p}(\\mathbf{x}) = [1, x, y]^{\\mathsf{T}}$. The MLS approximant of a scalar field $u(\\mathbf{x})$ is $\\widehat{u}(\\mathbf{x}) = \\sum_{I=1}^N \\phi_I(\\mathbf{x}) u_I$, where $u_I = u(\\mathbf{x}_I)$. The linear reproduction property states that, if $u(\\mathbf{x})$ is any linear function $u(\\mathbf{x}) = a + \\mathbf{b}\\cdot \\mathbf{x}$ with $a \\in \\mathbb{R}$ and $\\mathbf{b} \\in \\mathbb{R}^2$, then $\\widehat{u}(\\mathbf{x}) = u(\\mathbf{x})$ for all $\\mathbf{x}$ where the moment matrix is invertible.\n\nYour program must implement the MLS shape functions with the Gaussian weight\n$$\nw(r;h) = \\exp\\!\\left(-\\left(\\frac{r}{h}\\right)^2\\right),\n$$\nwhere $r=\\|\\mathbf{x}-\\mathbf{x}_I\\|_2$ and $h>0$ is the smoothing length. Let $P \\in \\mathbb{R}^{N\\times 3}$ be the matrix with rows $\\boldsymbol{p}(\\mathbf{x}_I)^{\\mathsf{T}}$, and $W(\\mathbf{x}) \\in \\mathbb{R}^{N\\times N}$ be the diagonal matrix with entries $w(\\|\\mathbf{x}-\\mathbf{x}_I\\|;h)$. Define the moment matrix $A(\\mathbf{x}) = P^{\\mathsf{T}} W(\\mathbf{x}) P \\in \\mathbb{R}^{3\\times 3}$. The MLS shape function row vector at $\\mathbf{x}$ is\n$$\n\\boldsymbol{\\phi}(\\mathbf{x})^{\\mathsf{T}} = G(\\mathbf{x})^{\\mathsf{T}} \\boldsymbol{p}(\\mathbf{x}), \\quad \\text{where } G(\\mathbf{x}) = A(\\mathbf{x})^{-1} P^{\\mathsf{T}} W(\\mathbf{x}) \\in \\mathbb{R}^{3\\times N}.\n$$\nEquivalently, for each node $I$, the scalar shape function is $\\phi_I(\\mathbf{x}) = \\boldsymbol{p}(\\mathbf{x})^{\\mathsf{T}} A(\\mathbf{x})^{-1} w(\\|\\mathbf{x}-\\mathbf{x}_I\\|;h) \\boldsymbol{p}(\\mathbf{x}_I)$.\n\nWrite a program that, for specified node sets, smoothing lengths, and test points, evaluates the two sums\n$$\nS_0(\\mathbf{x}) = \\sum_{I=1}^N \\phi_I(\\mathbf{x})\\, a,\\qquad S_1(\\mathbf{x}) = \\sum_{I=1}^N \\phi_I(\\mathbf{x})\\, \\mathbf{b}\\cdot \\mathbf{x}_I,\n$$\nand compares $S_0(\\mathbf{x}) + S_1(\\mathbf{x})$ against the exact linear value $a + \\mathbf{b}\\cdot \\mathbf{x}$. For each test, report whether the maximum absolute error over the specified set of evaluation points is below a tolerance $\\varepsilon=10^{-10}$.\n\nImplement the following four tests. All coordinates are in $\\mathbb{R}$ and dimensionless, so no physical units are required. Angles do not appear. The program must be deterministic; use the provided random seeds.\n\n- Test $1$ (regular grid, moderate smoothing, interior points):\n  - Nodes: a regular $5\\times 5$ tensor grid on $[0,1]\\times[0,1]$, i.e., $\\mathbf{x}_{i,j} = \\left(\\frac{i}{4}, \\frac{j}{4}\\right)$ for $i,j\\in\\{0,1,2,3,4\\}$, so $N=25$.\n  - Smoothing length: $h=0.30$.\n  - Linear function parameters: $a=1.2345$, $\\mathbf{b} = (-0.5,\\, 2.2)$.\n  - Evaluation points: $M=200$ points uniformly random in $[0,1]^2$, generated with seed $11$.\n  - Output: a boolean indicating whether $\\max_{\\mathbf{x}} |(S_0(\\mathbf{x})+S_1(\\mathbf{x}))-(a+\\mathbf{b}\\cdot \\mathbf{x})| \\le \\varepsilon$.\n\n- Test $2$ (regular grid, small smoothing, interior points):\n  - Nodes: same $5\\times 5$ grid as Test $1$.\n  - Smoothing length: $h=0.12$.\n  - Linear function parameters: $a=-0.9$, $\\mathbf{b}=(2.0,\\,1.5)$.\n  - Evaluation points: $M=200$ points uniformly random in $[0,1]^2$, generated with seed $22$.\n  - Output: a boolean as in Test $1$.\n\n- Test $3$ (jittered grid, moderate smoothing, interior points):\n  - Nodes: start from a $6\\times 6$ grid $\\mathbf{x}_{i,j}=\\left(\\frac{i}{5},\\frac{j}{5}\\right)$ for $i,j\\in\\{0,1,2,3,4,5\\}$, then add independent uniform jitter in $[-0.04,0.04]$ to each coordinate; clip to $[0,1]$. Use jitter seed $333$.\n  - Smoothing length: $h=0.25$.\n  - Linear function parameters: $a=0.0$, $\\mathbf{b}=(1.0,\\,-1.0)$.\n  - Evaluation points: $M=400$ points uniformly random in $[0,1]^2$, generated with seed $33$.\n  - Output: a boolean as in Test $1$.\n\n- Test $4$ (regular grid, boundary-focused points):\n  - Nodes: same $5\\times 5$ grid as Test $1$.\n  - Smoothing length: $h=0.20$.\n  - Linear function parameters: $a=0.3$, $\\mathbf{b}=(0.2,\\,-0.4)$.\n  - Evaluation points: the nine points $\\{(0,0),(1,0),(0,1),(1,1),(0.5,0),(0.5,1),(0,0.5),(1,0.5),(0.5,0.5)\\}$.\n  - Output: a boolean as in Test $1$.\n\nYour program should produce a single line of output containing the four boolean results as a comma-separated list enclosed in square brackets (e.g., \"[True,True,True,True]\"). The booleans must appear in the order of Tests $1$ through $4$ exactly, and each boolean must be computed by comparing the maximum absolute error against $\\varepsilon=10^{-10}$ for that test.", "solution": "The problem statement is parsed and validated.\n\n**1. Givens Extraction**\n\n- **Method**: Moving Least Squares (MLS) in two dimensions, $\\mathbb{R}^2$.\n- **Property to Verify**: Linear reproduction for an approximant $\\widehat{u}(\\mathbf{x}) = \\sum_{I=1}^N \\phi_I(\\mathbf{x}) u_I$ of a linear scalar field $u(\\mathbf{x}) = a + \\mathbf{b}\\cdot \\mathbf{x}$.\n- **Nodes**: A set of $N$ points $\\{\\mathbf{x}_I\\}_{I=1}^N \\subset \\mathbb{R}^2$.\n- **Basis**: Linear polynomial basis $\\boldsymbol{p}(\\mathbf{x}) = [1, x, y]^{\\mathsf{T}}$.\n- **Weight Function**: Gaussian, $w(r;h) = \\exp(-(r/h)^2)$, where $r=\\|\\mathbf{x}-\\mathbf{x}_I\\|_2$ and $h$ is the smoothing length.\n- **Moment Matrix**: $A(\\mathbf{x}) = P^{\\mathsf{T}} W(\\mathbf{x}) P$, where $P$ is the $N\\times 3$ matrix of basis functions evaluated at nodes, and $W(\\mathbf{x})$ is the $N\\times N$ diagonal matrix of weights.\n- **Shape Functions**: The vector of shape functions is $\\boldsymbol{\\phi}(\\mathbf{x})^{\\mathsf{T}} = \\boldsymbol{p}(\\mathbf{x})^{\\mathsf{T}} A(\\mathbf{x})^{-1} P^{\\mathsf{T}} W(\\mathbf{x})$.\n- **Verification Task**: For four specified tests, calculate the maximum absolute error $|\\left(\\sum_I \\phi_I(\\mathbf{x}) u_I\\right) - u(\\mathbf{x})|$ over a set of evaluation points and determine if this maximum error is less than or equal to a tolerance $\\varepsilon=10^{-10}$.\n- **Test $1$**: $5\\times 5$ regular grid, $h=0.30$, $a=1.2345$, $\\mathbf{b} = (-0.5, 2.2)$, $200$ random evaluation points (seed $11$).\n- **Test $2$**: $5\\times 5$ regular grid, $h=0.12$, $a=-0.9$, $\\mathbf{b}=(2.0, 1.5)$, $200$ random evaluation points (seed $22$).\n- **Test $3$**: $6\\times 6$ jittered grid (seed $333$), $h=0.25$, $a=0.0$, $\\mathbf{b}=(1.0, -1.0)$, $400$ random evaluation points (seed $33$).\n- **Test $4$**: $5\\times 5$ regular grid, $h=0.20$, $a=0.3$, $\\mathbf{b}=(0.2, -0.4)$, $9$ specific boundary and interior evaluation points.\n\n**2. Validation**\n\nThe problem statement is scientifically sound and computationally verifiable. It describes a standard numerical experiment in the field of computational mechanics to validate a correct implementation of the Moving Least Squares method. All definitions and formulas are standard and correct. All test cases are well-defined with all necessary parameters, data, and random seeds for reproducibility. The problem is self-contained, consistent, and free of any logical or scientific flaws.\n\n**3. Verdict**\n\nThe problem is **valid**. I will proceed with a complete solution.\n\n**Solution Derivation**\n\nThe objective is to numerically verify the linear reproduction property of Moving Least Squares (MLS) shape functions. This property dictates that if the function being approximated, $u(\\mathbf{x})$, is a member of the polynomial basis used to construct the approximation, the MLS approximant $\\widehat{u}(\\mathbf{x})$ must be identical to $u(\\mathbf{x})$.\n\nThe MLS approximation $\\widehat{u}(\\mathbf{x})$ is constructed as $\\widehat{u}(\\mathbf{x}) = \\boldsymbol{p}(\\mathbf{x})^{\\mathsf{T}} \\boldsymbol{\\alpha}(\\mathbf{x})$, where $\\boldsymbol{p}(\\mathbf{x}) = [1, x, y]^{\\mathsf{T}}$ is the linear basis and $\\boldsymbol{\\alpha}(\\mathbf{x})$ is a vector of coefficients determined by minimizing a weighted least-squares functional. This minimization leads to the expression $\\boldsymbol{\\alpha}(\\mathbf{x}) = A(\\mathbf{x})^{-1} P^{\\mathsf{T}} W(\\mathbf{x}) \\mathbf{u}$, where $\\mathbf{u}$ is the vector of nodal values $u_I = u(\\mathbf{x}_I)$.\n\nLet us consider a general linear function, $u(\\mathbf{x}) = a + \\mathbf{b}\\cdot \\mathbf{x} = a + b_x x + b_y y$. This function is an element of the space spanned by the basis $\\boldsymbol{p}(\\mathbf{x})$. We can write it as $u(\\mathbf{x}) = \\boldsymbol{p}(\\mathbf{x})^{\\mathsf{T}} \\boldsymbol{c}$, where the coefficient vector is $\\boldsymbol{c} = [a, b_x, b_y]^{\\mathsf{T}}$. The value of this function at node $I$ is $u_I = u(\\mathbf{x}_I) = \\boldsymbol{p}(\\mathbf{x}_I)^{\\mathsf{T}} \\boldsymbol{c}$. The vector of all nodal values is thus $\\mathbf{u} = P\\boldsymbol{c}$.\n\nSubstituting this expression for $\\mathbf{u}$ into the formula for $\\boldsymbol{\\alpha}(\\mathbf{x})$ yields:\n$$\n\\boldsymbol{\\alpha}(\\mathbf{x}) = A(\\mathbf{x})^{-1} P^{\\mathsf{T}} W(\\mathbf{x}) (P\\boldsymbol{c})\n$$\nBy definition, the moment matrix is $A(\\mathbf{x}) = P^{\\mathsf{T}} W(\\mathbf{x}) P$. Substituting this into the equation gives:\n$$\n\\boldsymbol{\\alpha}(\\mathbf{x}) = (P^{\\mathsf{T}} W(\\mathbf{x}) P)^{-1} (P^{\\mathsf{T}} W(\\mathbf{x}) P) \\boldsymbol{c} = A(\\mathbf{x})^{-1} A(\\mathbf{x}) \\boldsymbol{c} = \\boldsymbol{c}\n$$\nThis holds if and only if the moment matrix $A(\\mathbf{x})$ is invertible. The result shows that the coefficient vector $\\boldsymbol{\\alpha}(\\mathbf{x})$ is constant and equal to $\\boldsymbol{c}$. The MLS approximant is then:\n$$\n\\widehat{u}(\\mathbf{x}) = \\boldsymbol{p}(\\mathbf{x})^{\\mathsf{T}} \\boldsymbol{\\alpha}(\\mathbf{x}) = \\boldsymbol{p}(\\mathbf{x})^{\\mathsf{T}} \\boldsymbol{c} = u(\\mathbf{x})\n$$\nThis confirms theoretically that $\\widehat{u}(\\mathbf{x}) = u(\\mathbf{x})$. The numerical experiment must verify that the computational error $|\\widehat{u}(\\mathbf{x}) - u(\\mathbf{x})|$ is on the order of machine precision, here bounded by the tolerance $\\varepsilon = 10^{-10}$.\n\nThe numerical implementation will proceed as follows for each test case.\nFirst, the required node set $\\{\\mathbf{x}_I\\}$, evaluation point set $\\{\\mathbf{x}_{\\text{eval}}\\}$, smoothing length $h$, and linear function parameters $a$ and $\\mathbf{b}$ are generated. The constant $N \\times 3$ matrix $P$ is constructed, with row $I$ being $[1, x_I, y_I]$. The vector of nodal values $\\mathbf{u}$ is computed, with entry $I$ being $u_I = a + \\mathbf{b}\\cdot\\mathbf{x}_I$.\n\nThen, for each evaluation point $\\mathbf{x}_{\\text{eval}}$:\n$1$. The distances $r_I = \\|\\mathbf{x}_{\\text{eval}} - \\mathbf{x}_I\\|$ are computed for all nodes $I=1, \\dots, N$.\n$2$. The corresponding weights $w_I = \\exp(-(r_I/h)^2)$ are calculated. These form the diagonal of the matrix $W(\\mathbf{x}_{\\text{eval}})$.\n$3$. The $3\\times 3$ moment matrix $A(\\mathbf{x}_{\\text{eval}}) = P^{\\mathsf{T}} W(\\mathbf{x}_{\\text{eval}}) P$ is assembled. This is efficiently computed as $\\sum_{I=1}^N w_I \\boldsymbol{p}(\\mathbf{x}_I) \\boldsymbol{p}(\\mathbf{x}_I)^{\\mathsf{T}}$.\n$4$. The coefficient vector $\\boldsymbol{\\alpha}(\\mathbf{x}_{\\text{eval}})$ is computed by solving the linear system $A(\\mathbf{x}_{\\text{eval}}) \\boldsymbol{\\alpha} = P^{\\mathsf{T}} W(\\mathbf{x}_{\\text{eval}}) \\mathbf{u}$. This is equivalent to calculating $\\boldsymbol{\\alpha} = A(\\mathbf{x}_{\\text{eval}})^{-1} (P^{\\mathsf{T}} (W(\\mathbf{x}_{\\text{eval}})\\mathbf{u}))$.\n$5$. The MLS approximant is calculated as $\\widehat{u}(\\mathbf{x}_{\\text{eval}}) = \\boldsymbol{p}(\\mathbf{x}_{\\text{eval}})^{\\mathsf{T}} \\boldsymbol{\\alpha}(\\mathbf{x}_{\\text{eval}})$.\n$6$. The exact value $u(\\mathbf{x}_{\\text{eval}}) = a + \\mathbf{b}\\cdot\\mathbf{x}_{\\text{eval}}$ is determined.\n$7$. The absolute error $|\\widehat{u}(\\mathbf{x}_{\\text{eval}}) - u(\\mathbf{x}_{\\text{eval}})|$ is computed.\n\nAfter iterating through all evaluation points, the maximum absolute error is found and compared against the tolerance $\\varepsilon=10^{-10}$. The boolean result of this comparison is reported for each of the four tests.", "answer": "```python\nimport numpy as np\n\ndef run_mls_reproduction_test(nodes, h, a, b_vec, eval_points, tol):\n    \"\"\"\n    Performs a numerical test of the MLS linear reproduction property.\n\n    Args:\n        nodes (np.ndarray): N-by-2 array of node coordinates.\n        h (float): Smoothing length for the Gaussian weight function.\n        a (float): Constant term of the linear function u(x) = a + b.x.\n        b_vec (np.ndarray): 2-element array for the linear term of u(x).\n        eval_points (np.ndarray): M-by-2 array of evaluation point coordinates.\n        tol (float): Error tolerance for the verification.\n\n    Returns:\n        bool: True if the max absolute error is within the tolerance, False otherwise.\n    \"\"\"\n    N = nodes.shape[0]\n\n    # Construct the P matrix (N x 3) where row I is [1, x_I, y_I]\n    P = np.hstack([np.ones((N, 1)), nodes])\n\n    # Pre-compute nodal values of the linear function u_I = a + b . x_I\n    u_nodes = a + nodes @ b_vec\n\n    max_error = 0.0\n\n    for x_eval in eval_points:\n        # Calculate distances from the evaluation point to all nodes\n        dists = np.linalg.norm(x_eval - nodes, axis=1)\n        \n        # Calculate Gaussian weights\n        weights = np.exp(-(dists / h)**2)\n\n        # Assemble the moment matrix A(x) = P^T W(x) P\n        # W is a diagonal matrix, so W*P is equivalent to scaling rows of P by weights.\n        # A more efficient way is P.T @ (weights_as_column * P)\n        A = P.T @ (weights[:, np.newaxis] * P)\n\n        # The problem setup ensures A is invertible. For robustness, one\n        # might check the determinant or condition number.\n        # If det(A) is close to zero, numerical issues may arise.\n        if np.linalg.det(A) < 1e-30:\n            # This indicates a potential singularity; the reproduction would fail.\n            # We set a large error to ensure the test fails.\n            max_error = np.inf\n            break\n            \n        # Invert the moment matrix\n        A_inv = np.linalg.inv(A)\n\n        # Calculate the coefficient vector alpha(x) = A(x)^-1 * P^T * W(x) * u\n        # The term W(x) * u is an element-wise product of weights and nodal values\n        pT_W_u = P.T @ (weights * u_nodes)\n        alpha = A_inv @ pT_W_u\n\n        # Calculate the MLS approximation at x_eval\n        # p_eval is the basis vector [1, x, y] at the evaluation point\n        p_eval = np.array([1.0, x_eval[0], x_eval[1]])\n        u_hat = p_eval @ alpha\n\n        # Calculate the exact value of the linear function\n        u_exact = a + x_eval @ b_vec\n\n        # Compute the absolute error and update the maximum\n        error = np.abs(u_hat - u_exact)\n        if error > max_error:\n            max_error = error\n\n    return max_error <= tol\n\ndef solve():\n    \"\"\"\n    Sets up and runs the four test cases specified in the problem,\n    and prints the results in the required format.\n    \"\"\"\n    TOLERANCE = 1e-10\n\n    # --- Test Case Data Generation ---\n\n    # Nodes for Tests 1, 2, 4: Regular 5x5 grid\n    grid_pts_5x5 = np.linspace(0.0, 1.0, 5)\n    X5, Y5 = np.meshgrid(grid_pts_5x5, grid_pts_5x5)\n    nodes_5x5 = np.vstack([X5.ravel(), Y5.ravel()]).T\n\n    # Nodes for Test 3: Jittered 6x6 grid\n    grid_pts_6x6 = np.linspace(0.0, 1.0, 6)\n    X6, Y6 = np.meshgrid(grid_pts_6x6, grid_pts_6x6)\n    nodes_6x6_base = np.vstack([X6.ravel(), Y6.ravel()]).T\n    rng_jitter = np.random.default_rng(333)\n    jitter = rng_jitter.uniform(-0.04, 0.04, size=nodes_6x6_base.shape)\n    nodes_6x6_jittered = np.clip(nodes_6x6_base + jitter, 0.0, 1.0)\n    \n    # Evaluation points for Test 4\n    eval_pts_test4 = np.array([\n        [0.0, 0.0], [1.0, 0.0], [0.0, 1.0], [1.0, 1.0],\n        [0.5, 0.0], [0.5, 1.0], [0.0, 0.5], [1.0, 0.5],\n        [0.5, 0.5]\n    ])\n\n    test_cases_params = [\n        {\n            \"nodes\": nodes_5x5,\n            \"h\": 0.30,\n            \"a\": 1.2345,\n            \"b\": np.array([-0.5, 2.2]),\n            \"eval_points\": np.random.default_rng(11).uniform(0.0, 1.0, size=(200, 2))\n        },\n        {\n            \"nodes\": nodes_5x5,\n            \"h\": 0.12,\n            \"a\": -0.9,\n            \"b\": np.array([2.0, 1.5]),\n            \"eval_points\": np.random.default_rng(22).uniform(0.0, 1.0, size=(200, 2))\n        },\n        {\n            \"nodes\": nodes_6x6_jittered,\n            \"h\": 0.25,\n            \"a\": 0.0,\n            \"b\": np.array([1.0, -1.0]),\n            \"eval_points\": np.random.default_rng(33).uniform(0.0, 1.0, size=(400, 2))\n        },\n        {\n            \"nodes\": nodes_5x5,\n            \"h\": 0.20,\n            \"a\": 0.3,\n            \"b\": np.array([0.2, -0.4]),\n            \"eval_points\": eval_pts_test4\n        }\n    ]\n\n    results = []\n    for params in test_cases_params:\n        result = run_mls_reproduction_test(\n            params[\"nodes\"],\n            params[\"h\"],\n            params[\"a\"],\n            params[\"b\"],\n            params[\"eval_points\"],\n            TOLERANCE\n        )\n        results.append(result)\n\n    # Print the final output in the specified format\n    print(f\"[{','.join(map(str, results))}]\")\n\n# Execute the solution\nsolve()\n\n```", "id": "2662008"}, {"introduction": "While meshless methods and the Finite Element Method (FEM) are often presented as distinct approaches, they share deep mathematical connections. This exercise [@problem_id:2662032] illuminates one such connection by demonstrating that, under specific conditions of nodal spacing, weight function support, and numerical integration, a 1D meshless Galerkin method exactly reproduces the stiffness matrix of the standard linear FEM. This powerful insight helps demystify the behavior of meshless methods and grounds them in the familiar context of finite elements, revealing them not as a complete departure, but as a powerful generalization.", "problem": "Consider a one-dimensional elastic bar of length $L$ and constant cross-sectional area $A$, with uniform Young's modulus $E$. The domain is $\\Omega = [0,L]$. The bar is discretized by $n+1$ uniformly spaced nodes $\\{x_{i}\\}_{i=0}^{n}$ with $x_{i} = i\\,h$ and $h = L/n$. Assume essential boundary condition $u(0)=0$ and a prescribed traction $t=L$ at $x=L$; body forces are absent.\n\nUse a meshless Galerkin formulation based on moving least squares (MLS) shape functions built from a linear basis $\\{1, x\\}$ and a symmetric compactly supported weight function whose support radius equals the nodal spacing $h$, so that for any $x \\in (x_{i},x_{i+1})$ only nodes $i$ and $i+1$ have nonzero weight. For numerical integration, employ a background partition of $\\Omega$ into the $n$ subcells $[x_{i},x_{i+1}]$ and use one-point Gaussian quadrature per subcell.\n\nStarting from the principle of virtual work and the definition of MLS approximation spaces, perform the following:\n\n1. Derive the discrete equilibrium equations in the form $\\mathbf{K}_{\\mathrm{ml}} \\mathbf{u} = \\mathbf{f}$, identifying the expression for the entries $K_{\\mathrm{ml},ab}$ obtained by background Gaussian quadrature.\n\n2. Compute the $2 \\times 2$ contribution to $\\mathbf{K}_{\\mathrm{ml}}$ from a single subcell $[x_{i},x_{i+1}]$ and assemble the global pattern for interior nodes.\n\n3. For the same nodal spacing $h$ and background partition, consider the standard linear finite element method (FEM) with linear shape functions on each subcell. Compare the assembled nearest-neighbor stiffness coefficient between nodes $i$ and $i+1$ obtained by the meshless Galerkin method to that of linear FEM.\n\nReport as your final answer the dimensionless ratio $r$ of the meshless nearest-neighbor stiffness coefficient to the FEM nearest-neighbor stiffness coefficient. Provide $r$ as a single real number. No rounding is required, and no units should be included in the final answer.", "solution": "The problem will be validated and then, if valid, solved.\n\nProblem Validation:\n\nStep 1: Extract Givens.\n- System: One-dimensional elastic bar, length $L$, constant cross-sectional area $A$, uniform Young's modulus $E$.\n- Domain: $\\Omega = [0,L]$.\n- Discretization: $n+1$ uniformly spaced nodes $\\{x_{i}\\}_{i=0}^{n}$, with $x_{i} = i\\,h$ and $h = L/n$.\n- Boundary Conditions: Essential boundary condition $u(0)=0$. Prescribed traction $t=L$ at $x=L$.\n- Body Forces: Absent.\n- Method: Meshless Galerkin formulation with Moving Least Squares (MLS) shape functions.\n- MLS Basis: Linear basis $\\{1, x\\}$.\n- MLS Weight Function: Symmetric, compactly supported with support radius equal to nodal spacing $h$. For any point $x \\in (x_{i},x_{i+1})$, only nodes $i$ and $i+1$ have nonzero weight.\n- Numerical Integration: Background partition into $n$ subcells $[x_{i},x_{i+1}]$ using one-point Gaussian quadrature per subcell.\n- Tasks:\n  1. Derive discrete equilibrium equations $\\mathbf{K}_{\\mathrm{ml}} \\mathbf{u} = \\mathbf{f}$ and the expression for $K_{\\mathrm{ml},ab}$.\n  2. Compute the $2 \\times 2$ stiffness contribution from a subcell $[x_{i},x_{i+1}]$.\n  3. Compare the assembled nearest-neighbor stiffness coefficient with that of the linear Finite Element Method (FEM).\n- Final Answer: Report the dimensionless ratio $r$ of the meshless nearest-neighbor coefficient to the FEM nearest-neighbor coefficient.\n\nStep 2: Validate Using Extracted Givens.\nThe problem statement is scientifically grounded within the fields of continuum mechanics and numerical analysis. It describes a standard boundary value problem and its discretization using two well-established methods, MLS and FEM. The terminology is precise and objective. The problem is well-posed; the given information is sufficient to derive the quantities requested. The MLS formulation is specified with sufficient detail (linear basis, support radius of weight function, integration scheme) to permit a unique derivation. The supposed dimensional inconsistency \"traction $t=L$\" is irrelevant to the calculation of the stiffness matrix and the final ratio, which depend only on the left-hand side of the weak form. The problem is a standard exercise in comparing numerical methods and is neither trivial nor ill-posed.\n\nStep 3: Verdict and Action.\nThe problem is deemed valid. A complete, reasoned solution will be provided.\n\nSolution:\n\nThe governing weak form for the one-dimensional elasticity problem, derived from the principle of virtual work and in the absence of body forces, is:\n$$\n\\int_{0}^{L} E A \\frac{du}{dx} \\frac{d(\\delta u)}{dx} dx = \\left[ \\delta u(x) F(x) \\right]_{0}^{L}\n$$\nwhere $u$ is the displacement field, $\\delta u$ is a kinematically admissible virtual displacement, and $F(x)$ represents the external point forces. The stiffness matrix is derived from the left-hand side of this equation.\n\nThe displacement field $u(x)$ is approximated by a linear combination of shape functions $\\Phi_a(x)$ and nodal parameters $u_a$:\n$$\nu(x) \\approx u^h(x) = \\sum_{a=0}^{n} \\Phi_a(x) u_a\n$$\nThe virtual displacement is $\\delta u(x) = \\sum_{b=0}^{n} \\Phi_b(x) \\delta u_b$. Substituting these approximations into the weak form yields the discrete system $\\mathbf{K} \\mathbf{u} = \\mathbf{f}$, where the entries of the global stiffness matrix $\\mathbf{K}$ are given by:\n$$\nK_{ab} = \\int_{0}^{L} E A \\frac{d\\Phi_a}{dx}(x) \\frac{d\\Phi_b}{dx}(x) dx\n$$\nThe problem asks to evaluate the contribution to this matrix from a single subcell $[x_{i}, x_{i+1}]$ using one-point Gaussian quadrature. The Gauss point for this interval is $x_g = x_i + \\frac{h}{2}$, and the quadrature weight is $h$. The contribution to the stiffness matrix from this subcell, denoted $\\mathbf{K}^{(i)}$, has entries:\n$$\nK_{ab}^{(i)} \\approx E A h \\left( \\frac{d\\Phi_a}{dx}(x_g) \\frac{d\\Phi_b}{dx}(x_g) \\right)\n$$\nWe must determine the derivatives of the MLS shape functions, $\\frac{d\\Phi_a}{dx}$, at the point $x_g$.\n\nThe MLS shape functions with a linear basis $\\mathbf{p}(x) = [1, x]^T$ must satisfy the linear reproduction property:\n$$\n\\sum_{I} \\Phi_I(x) p_k(x_I) = p_k(x) \\quad \\text{for } k=1,2\n$$\nDifferentiating this property with respect to $x$ gives a consistency condition for the derivatives of the shape functions:\n$$\n\\sum_{I} \\frac{d\\Phi_I}{dx}(x) \\mathbf{p}(x_I) = \\frac{d\\mathbf{p}}{dx}(x)\n$$\nFor our basis, $\\frac{d\\mathbf{p}}{dx}(x) = [0, 1]^T$. The problem states that for any point $x$ in the interval $(x_i, x_{i+1})$, the support of the weight function ensures that only nodes $i$ and $i+1$ have non-zero shape functions. Therefore, for any $x \\in (x_i, x_{i+1})$, the sum is restricted to $I \\in \\{i, i+1\\}$:\n$$\n\\frac{d\\Phi_i}{dx}(x) \\mathbf{p}(x_i) + \\frac{d\\Phi_{i+1}}{dx}(x) \\mathbf{p}(x_{i+1}) = \\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix}\n$$\nThis is a system of two linear equations for the two unknown derivatives $\\frac{d\\Phi_i}{dx}(x)$ and $\\frac{d\\Phi_{i+1}}{dx}(x)$:\n$$\n\\begin{pmatrix} 1 & 1 \\\\ x_i & x_{i+1} \\end{pmatrix} \\begin{pmatrix} \\frac{d\\Phi_i}{dx}(x) \\\\ \\frac{d\\Phi_{i+1}}{dx}(x) \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix}\n$$\nSubstituting $x_i = ih$ and $x_{i+1}=(i+1)h$:\n$$\n\\begin{pmatrix} 1 & 1 \\\\ ih & (i+1)h \\end{pmatrix} \\begin{pmatrix} \\frac{d\\Phi_i}{dx}(x) \\\\ \\frac{d\\Phi_{i+1}}{dx}(x) \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix}\n$$\nThe determinant of the matrix is $(i+1)h - ih = h$. Solving the system by matrix inversion yields:\n$$\n\\begin{pmatrix} \\frac{d\\Phi_i}{dx}(x) \\\\ \\frac{d\\Phi_{i+1}}{dx}(x) \\end{pmatrix} = \\frac{1}{h} \\begin{pmatrix} (i+1)h & -1 \\\\ -ih & 1 \\end{pmatrix} \\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix} = \\frac{1}{h} \\begin{pmatrix} -1 \\\\ 1 \\end{pmatrix} = \\begin{pmatrix} -\\frac{1}{h} \\\\ \\frac{1}{h} \\end{pmatrix}\n$$\nCrucially, these derivatives are constant for any $x \\in (x_i, x_{i+1})$ and are independent of the specific form of the weight function. Thus, at the Gauss point $x_g$, we have $\\frac{d\\Phi_i}{dx}(x_g) = -1/h$ and $\\frac{d\\Phi_{i+1}}{dx}(x_g) = 1/h$.\n\nUsing these derivatives, we compute the $2 \\times 2$ stiffness matrix contribution from the subcell $[x_i, x_{i+1}]$ for the meshless method:\n$K_{\\mathrm{ml},ii}^{(i)} = E A h \\left( -\\frac{1}{h} \\right)^2 = \\frac{EA}{h}$\n$K_{\\mathrm{ml},i,i+1}^{(i)} = E A h \\left( -\\frac{1}{h} \\right) \\left( \\frac{1}{h} \\right) = -\\frac{EA}{h}$\n$K_{\\mathrm{ml},i+1,i}^{(i)} = E A h \\left( \\frac{1}{h} \\right) \\left( -\\frac{1}{h} \\right) = -\\frac{EA}{h}$\n$K_{\\mathrm{ml},i+1,i+1}^{(i)} = E A h \\left( \\frac{1}{h} \\right)^2 = \\frac{EA}{h}$\nThe MLS subcell stiffness matrix is:\n$$\n\\mathbf{K}_{\\mathrm{ml}}^{(i)} = \\frac{EA}{h} \\begin{pmatrix} 1 & -1 \\\\ -1 & 1 \\end{pmatrix}\n$$\nThe assembled nearest-neighbor stiffness coefficient between nodes $i$ and $i+1$ in a 1D problem comes solely from the contribution of the subcell $[x_i, x_{i+1}]$. Thus, the meshless coefficient is $K_{\\mathrm{ml,global},i,i+1} = K_{\\mathrm{ml},i,i+1}^{(i)} = -\\frac{EA}{h}$.\n\nNow, we derive the same quantity for the standard linear Finite Element Method (FEM). For a linear element on $[x_i, x_{i+1}]$, the standard Lagrangian shape functions are $N_i(x) = \\frac{x_{i+1}-x}{h}$ and $N_{i+1}(x) = \\frac{x-x_i}{h}$. Their derivatives with respect to $x$ are constant over the element:\n$$\n\\frac{dN_i}{dx} = -\\frac{1}{h} \\quad \\text{and} \\quad \\frac{dN_{i+1}}{dx} = \\frac{1}{h}\n$$\nThe FEM element stiffness matrix entries are calculated by exact integration:\n$K_{\\mathrm{fem},ab}^{(i)} = \\int_{x_i}^{x_{i+1}} E A \\frac{dN_a}{dx} \\frac{dN_b}{dx} dx$\n$K_{\\mathrm{fem},ii}^{(i)} = \\int_{x_i}^{x_{i+1}} E A \\left(-\\frac{1}{h}\\right)^2 dx = \\frac{EA}{h^2} \\int_{x_i}^{x_{i+1}} dx = \\frac{EA}{h}$\n$K_{\\mathrm{fem},i,i+1}^{(i)} = \\int_{x_i}^{x_{i+1}} E A \\left(-\\frac{1}{h}\\right)\\left(\\frac{1}{h}\\right) dx = -\\frac{EA}{h^2} \\int_{x_i}^{x_{i+1}} dx = -\\frac{EA}{h}$\nThe resulting FEM element stiffness matrix is:\n$$\n\\mathbf{K}_{\\mathrm{fem}}^{(i)} = \\frac{EA}{h} \\begin{pmatrix} 1 & -1 \\\\ -1 & 1 \\end{pmatrix}\n$$\nThe assembled FEM nearest-neighbor stiffness coefficient is $K_{\\mathrm{fem,global},i,i+1} = K_{\\mathrm{fem},i,i+1}^{(i)} = -\\frac{EA}{h}$.\n\nThe meshless stiffness coefficient is $-\\frac{EA}{h}$ and the FEM stiffness coefficient is $-\\frac{EA}{h}$. The problem asks for the ratio $r$ of the meshless coefficient to the FEM coefficient.\n$$\nr = \\frac{K_{\\mathrm{ml,global},i,i+1}}{K_{\\mathrm{fem,global},i,i+1}} = \\frac{-EA/h}{-EA/h} = 1\n$$\nThis result demonstrates that for a linear basis, a support radius equal to the nodal spacing, and one-point quadrature, the meshless Galerkin method reproduces the stiffness matrix of the linear finite element method exactly.", "answer": "$$\n\\boxed{1}\n$$", "id": "2662032"}, {"introduction": "Moving from theoretical properties to practical application, the \"patch test\" stands as a crucial gateway for any numerical method in solid mechanics. It is a fundamental test of a method's ability to converge to the correct solution by verifying that it can exactly represent a simple, constant state of strain over an arbitrary \"patch\" of elements or nodes. In this final practice [@problem_id:2661977], you will implement an Element-Free Galerkin (EFG) method to perform a 2D constant strain patch test, a standard and essential validation for any elasticity solver.", "problem": "Design and execute a two-dimensional constant strain patch test using the Element-Free Galerkin (EFG) method with a linear Moving Least Squares (MLS) basis. Your program must assemble and solve the linear elasticity problem on a rectangular domain using a meshless discretization, and then verify the patch test by measuring the error in the recovered strain field. The following requirements must be satisfied.\n\nPhysical setting and governing equations:\n- Consider small-strain, static, linear elasticity in plane stress on a rectangular domain $\\Omega = [0,L_x] \\times [0,L_y]$ with $L_x = L_y = 1\\,\\mathrm{m}$.\n- Use Young’s modulus $E = 1.0\\times 10^{5}\\,\\mathrm{Pa}$ and Poisson’s ratio $\\nu = 0.25$.\n- The weak form arises from balance of linear momentum with no body force: find the displacement field $\\boldsymbol{u}$ such that $\\int_{\\Omega} \\boldsymbol{\\varepsilon}(\\boldsymbol{v})^{T} \\boldsymbol{C} \\,\\boldsymbol{\\varepsilon}(\\boldsymbol{u})\\,\\mathrm{d}\\Omega = \\int_{\\partial\\Omega_t} \\boldsymbol{v}^{T} \\bar{\\boldsymbol{t}}\\,\\mathrm{d}\\Gamma$ for all admissible test functions $\\boldsymbol{v}$, where $\\boldsymbol{C}$ is the plane-stress elasticity matrix and $\\boldsymbol{\\varepsilon}$ is the symmetric small-strain tensor. In the patch test, enforce essential (Dirichlet) boundary conditions $\\boldsymbol{u} = \\boldsymbol{u}^{\\mathrm{exact}}$ on the entire boundary $\\partial\\Omega$ and set $\\bar{\\boldsymbol{t}} = \\boldsymbol{0}$.\n- Use the exact linear displacement field that produces constant strain:\n  - Choose constant target strains $\\varepsilon_{xx}^{\\star} = 1.25\\times 10^{-3}$, $\\varepsilon_{yy}^{\\star} = -7.5\\times 10^{-4}$, and $\\varepsilon_{xy}^{\\star} = 5.0\\times 10^{-4}$.\n  - Impose the exact displacement field $\\boldsymbol{u}^{\\mathrm{exact}}(x,y) = \\begin{bmatrix} u_x \\\\ u_y \\end{bmatrix} = \\begin{bmatrix} \\varepsilon_{xx}^{\\star}\\,x + \\varepsilon_{xy}^{\\star}\\,y \\\\ \\varepsilon_{xy}^{\\star}\\,x + \\varepsilon_{yy}^{\\star}\\,y \\end{bmatrix}$ in meters, so that $\\varepsilon_{xx} = \\varepsilon_{xx}^{\\star}$, $\\varepsilon_{yy} = \\varepsilon_{yy}^{\\star}$, and $\\varepsilon_{xy} = \\varepsilon_{xy}^{\\star}$ are constant.\n\nDiscretization by Element-Free Galerkin (EFG):\n- Use a uniform rectangular nodal layout with $N_x \\times N_y$ nodes, with coordinates at $(x_i,y_j)$ where $x_i = i\\,h_x$, $y_j = j\\,h_y$, $h_x = L_x/(N_x-1)$, $h_y = L_y/(N_y-1)$, and $i \\in \\{0,\\dots,N_x-1\\}$, $j \\in \\{0,\\dots,N_y-1\\}$.\n- Construct trial and test spaces using Moving Least Squares (MLS) with a linear basis $\\boldsymbol{p}(x,y) = [\\,1,\\;x,\\;y\\,]^{T}$.\n- Use a radial, compactly supported weight function with nodal support radii $d_k = \\alpha_s \\max(h_x,h_y)$ for node $k$ and a Wendland $C^2$ weight $w(q) = (1-q)^4(1+4q)$ for $0 \\le q \\le 1$ and $w(q)=0$ otherwise, where $q = r/d_k$ and $r$ is the Euclidean distance from the evaluation point to the node. The derivative is $w'(q) = -20\\,q\\,(1-q)^3$ for $0 \\le q \\le 1$.\n- For each evaluation point $(x,y)$, define the moment matrix $\\boldsymbol{A}(x,y) = \\sum_k w_k(x,y)\\,\\boldsymbol{p}_k \\boldsymbol{p}_k^{T}$ with $\\boldsymbol{p}_k = [\\,1,\\;x_k,\\;y_k\\,]^{T}$. The MLS shape function for node $k$ is $\\phi_k(x,y) = \\boldsymbol{p}(x,y)^{T}\\,\\boldsymbol{A}(x,y)^{-1}\\,w_k(x,y)\\,\\boldsymbol{p}_k$, and its gradient is obtained by differentiating $\\phi_k$ with respect to $x$ and $y$ using the product rule and $\\partial \\boldsymbol{A}^{-1}/\\partial x = -\\boldsymbol{A}^{-1} (\\partial \\boldsymbol{A}/\\partial x) \\boldsymbol{A}^{-1}$, and similarly for $y$.\n- Assemble the global stiffness matrix $\\boldsymbol{K} = \\int_{\\Omega} \\boldsymbol{B}^{T}\\,\\boldsymbol{C}\\,\\boldsymbol{B}\\,\\mathrm{d}\\Omega$ with $\\boldsymbol{B}$ constructed from shape function gradients: for node $k$, $\\boldsymbol{B}_k = \\begin{bmatrix} \\partial\\phi_k/\\partial x & 0 \\\\ 0 & \\partial\\phi_k/\\partial y \\\\ \\partial\\phi_k/\\partial y & \\partial\\phi_k/\\partial x \\end{bmatrix}$, and $\\boldsymbol{B} = [\\boldsymbol{B}_1\\;\\boldsymbol{B}_2\\;\\dots]$. Use a structured background cell integration with tensor-product Gauss quadrature of order $n_g \\times n_g$ on each rectangular cell, mapping from the reference square to the physical cell with the appropriate Jacobian factor.\n- Enforce essential boundary conditions $\\boldsymbol{u} = \\boldsymbol{u}^{\\mathrm{exact}}$ on all nodes lying on $\\partial\\Omega$ using a penalty method: add a penalty $\\alpha_p$ to the corresponding diagonal entries of $\\boldsymbol{K}$ and add $\\alpha_p\\,u^{\\mathrm{exact}}$ to the corresponding entries of the right-hand side. Use $\\alpha_p = \\beta\\,E$ with a user-specified nondimensional factor $\\beta > 0$.\n\nPatch-test verification:\n- After solving the linear system for the nodal unknowns, evaluate the strain field reconstructed from the numerical solution at a set of sample points (use the same background quadrature points), where the numerical strain is $\\varepsilon_{xx}^{h} = \\sum_k (\\partial\\phi_k/\\partial x)\\,u_{x,k}$, $\\varepsilon_{yy}^{h} = \\sum_k (\\partial\\phi_k/\\partial y)\\,u_{y,k}$, and $\\varepsilon_{xy}^{h} = \\frac{1}{2}\\left(\\sum_k (\\partial\\phi_k/\\partial y)\\,u_{x,k} + \\sum_k (\\partial\\phi_k/\\partial x)\\,u_{y,k}\\right)$. Compute the maximum absolute error over all sample points,\n  $$e_{\\max} = \\max_{\\text{samples}} \\left( \\max\\left( \\left| \\varepsilon_{xx}^{h} - \\varepsilon_{xx}^{\\star} \\right|,\\; \\left| \\varepsilon_{yy}^{h} - \\varepsilon_{yy}^{\\star} \\right|,\\; \\left| \\varepsilon_{xy}^{h} - \\varepsilon_{xy}^{\\star} \\right| \\right) \\right),$$\n  which is dimensionless.\n- Define pass/fail by comparing $e_{\\max}$ against a tolerance $\\tau$: the test passes if $e_{\\max} \\le \\tau$ and fails otherwise.\n\nIntegration scheme and numerical details:\n- Use plane stress with elasticity matrix $\\boldsymbol{C} = \\dfrac{E}{1-\\nu^2}\\begin{bmatrix} 1 & \\nu & 0 \\\\ \\nu & 1 & 0 \\\\ 0 & 0 & \\dfrac{1-\\nu}{2} \\end{bmatrix}$.\n- All distances are in $\\mathrm{m}$, displacements in $\\mathrm{m}$, stiffness in $\\mathrm{N/m}$, stress in $\\mathrm{Pa}$, and strains are dimensionless. The error $e_{\\max}$ is dimensionless.\n- Angles are not used in this problem.\n\nTest suite and required outputs:\n- Implement the following three test cases, each with $(N_x,N_y,\\alpha_s,n_g,\\beta,\\tau)$:\n  - Case A (happy path): $(N_x,N_y) = (5,5)$, $\\alpha_s = 2.5$, $n_g = 2$, $\\beta = 10^{6}$, and $\\tau = 1.0\\times 10^{-4}$.\n  - Case B (coarser nodal grid): $(N_x,N_y) = (3,3)$, $\\alpha_s = 2.0$, $n_g = 2$, $\\beta = 10^{5}$, and $\\tau = 2.0\\times 10^{-4}$.\n  - Case C (denser grid, higher quadrature): $(N_x,N_y) = (6,6)$, $\\alpha_s = 2.0$, $n_g = 3$, $\\beta = 10^{6}$, and $\\tau = 5.0\\times 10^{-5}$.\n- For each case, compute $e_{\\max}$ and then a boolean result indicating pass ($\\mathrm{True}$) if $e_{\\max} \\le \\tau$ and fail ($\\mathrm{False}$) otherwise.\n- Final output format: Your program should produce a single line of output containing the boolean pass/fail results for the three cases as a comma-separated list enclosed in square brackets (e.g., $[\\,\\mathrm{True},\\mathrm{False},\\mathrm{True}\\,]$). No additional text should be printed.\n\nYour program must be a single, complete, runnable script that constructs the MLS shape functions with a linear basis, assembles the EFG stiffness matrix with the specified background integration, applies the penalty boundary conditions, solves for the nodal displacements, evaluates the strain error metric, and reports the pass/fail results. Ensure numerical stability by handling the singularity of $\\boldsymbol{A}(x,y)$ robustly (e.g., by adding a small multiple of the identity matrix before inversion), and ensure that all evaluations observe the specified physical units. Express all final strains and errors as dimensionless quantities; displacements must be in $\\mathrm{m}$ if any intermediate values are inspected, but the program’s final output consists only of booleans. The code must not require user input. The numerical algorithm must be implemented from first principles as described above, without relying on prebuilt meshless packages.", "solution": "The problem requires the design and implementation of a two-dimensional patch test for the Element-Free Galerkin (EFG) method to verify its ability to reproduce a state of constant strain. The problem is scientifically grounded, well-posed, and complete. All necessary physical parameters, numerical settings, and verification criteria are provided. We proceed with the solution.\n\nThe fundamental principle being tested is that a numerical method for solid mechanics must be able to exactly represent, up to numerical precision, a constant strain state. For an approximation built upon a linear polynomial basis, this is equivalent to being able to exactly reproduce any arbitrary linear displacement field. The EFG method with a linear Moving Least Squares (MLS) basis is expected to pass this test.\n\nThe solution is constructed in the following steps:\n1.  Definition of the governing equations for linear elasticity in plane stress.\n2.  Discretization of the domain and approximation of the displacement field using the MLS scheme.\n3.  Derivation of the EFG system of equations from the weak form using a background-cell Gauss quadrature for numerical integration.\n4.  Application of essential boundary conditions using a penalty method.\n5.  Solution of the resulting linear system and computation of strains from the numerical displacement field.\n6.  Verification by comparing the computed strains to the exact constant target strains.\n\n**1. Governing Equations and Weak Form**\n\nFor a linear elastic body occupying a domain $\\Omega$, under static equilibrium and with no body forces, the balance of linear momentum is expressed as $\\nabla \\cdot \\boldsymbol{\\sigma} = \\boldsymbol{0}$, where $\\boldsymbol{\\sigma}$ is the Cauchy stress tensor. The constitutive relation for plane stress is $\\boldsymbol{\\sigma} = \\boldsymbol{C} \\boldsymbol{\\varepsilon}$, where $\\boldsymbol{\\varepsilon}$ is the small strain tensor. The strain-displacement relation is $\\boldsymbol{\\varepsilon}(\\boldsymbol{u}) = \\frac{1}{2}(\\nabla\\boldsymbol{u} + (\\nabla\\boldsymbol{u})^T)$. The material stiffness matrix $\\boldsymbol{C}$ in Voigt notation for plane stress is:\n$$\n\\boldsymbol{C} = \\frac{E}{1-\\nu^2}\n\\begin{bmatrix}\n1 & \\nu & 0 \\\\\n\\nu & 1 & 0 \\\\\n0 & 0 & \\frac{1-\\nu}{2}\n\\end{bmatrix}\n$$\nwhere $E$ is Young's modulus and $\\nu$ is Poisson's ratio. The strain and stress vectors are used in an engineering strain formulation where $\\boldsymbol{\\varepsilon} = [\\varepsilon_{xx}, \\varepsilon_{yy}, \\gamma_{xy}]^T$ and $\\boldsymbol{\\sigma} = [\\sigma_{xx}, \\sigma_{yy}, \\sigma_{xy}]^T$. The target engineering shear strain is $\\gamma_{xy}^\\star = 2\\varepsilon_{xy}^\\star$.\n\nThe weak form of the equilibrium equation is obtained via the principle of virtual work. For a virtual displacement field $\\boldsymbol{v}$, we have:\n$$\n\\int_{\\Omega} \\boldsymbol{\\varepsilon}(\\boldsymbol{v})^{T} \\boldsymbol{C} \\,\\boldsymbol{\\varepsilon}(\\boldsymbol{u})\\,\\mathrm{d}\\Omega = \\int_{\\partial\\Omega_t} \\boldsymbol{v}^{T} \\bar{\\boldsymbol{t}}\\,\\mathrm{d}\\Gamma\n$$\nFor this problem, essential boundary conditions $\\boldsymbol{u} = \\boldsymbol{u}^{\\mathrm{exact}}$ are prescribed on the entire boundary $\\partial\\Omega$, so the traction boundary $\\partial\\Omega_t$ is empty and the right-hand side integral is zero. The exact displacement field is linear, $\\boldsymbol{u}^{\\mathrm{exact}}(x,y) = [\\varepsilon_{xx}^{\\star}x + \\varepsilon_{xy}^{\\star}y, \\varepsilon_{xy}^{\\star}x + \\varepsilon_{yy}^{\\star}y]^T$, which produces a constant strain field $\\varepsilon_{xx}=\\varepsilon_{xx}^{\\star}$, $\\varepsilon_{yy}=\\varepsilon_{yy}^{\\star}$, and $\\varepsilon_{xy}=\\varepsilon_{xy}^{\\star}$ (or $\\gamma_{xy}=2\\varepsilon_{xy}^{\\star}$).\n\n**2. EFG Discretization and MLS Approximation**\n\nIn the EFG method, the displacement field $\\boldsymbol{u}(x,y)$ is approximated by a linear combination of shape functions $\\phi_k(x,y)$ and nodal displacement parameters $\\boldsymbol{d}_k=[u_{x,k}, u_{y,k}]^T$:\n$$\n\\boldsymbol{u}^h(x,y) = \\sum_{k=1}^{N} \\phi_k(x,y) \\boldsymbol{d}_k\n$$\nThe shape functions $\\phi_k(x,y)$ are constructed using the Moving Least Squares (MLS) method. For any point $\\boldsymbol{x}=(x,y)$, the approximation is constructed by finding coefficients $\\boldsymbol{a}(\\boldsymbol{x})$ that minimize a weighted, discrete $L_2$ norm of the error between the approximation and the nodal parameters:\n$$\nJ = \\sum_{k=1}^{N} w_k(\\boldsymbol{x}) \\left( \\boldsymbol{p}(\\boldsymbol{x}_k)^T \\boldsymbol{a}(\\boldsymbol{x}) - d_k \\right)^2\n$$\nwhere $\\boldsymbol{p}(\\boldsymbol{x}) = [1, x, y]^T$ is the linear basis, $w_k(\\boldsymbol{x})$ is a weight function with compact support centered at node $\\boldsymbol{x}_k$, and $d_k$ is a scalar nodal parameter. The minimization leads to the MLS shape function for node $k$:\n$$\n\\phi_k(\\boldsymbol{x}) = \\boldsymbol{p}(\\boldsymbol{x})^T \\boldsymbol{A}(\\boldsymbol{x})^{-1} w_k(\\boldsymbol{x}) \\boldsymbol{p}(\\boldsymbol{x}_k)\n$$\nwhere the moment matrix $\\boldsymbol{A}(\\boldsymbol{x})$ is defined as:\n$$\n\\boldsymbol{A}(\\boldsymbol{x}) = \\sum_{j=1}^{N} w_j(\\boldsymbol{x}) \\boldsymbol{p}(\\boldsymbol{x}_j) \\boldsymbol{p}(\\boldsymbol{x}_j)^T\n$$\nThe weight function is the specified Wendland $C^2$ function: $w(q) = (1-q)^4(1+4q)$ for $q = \\|\\boldsymbol{x}-\\boldsymbol{x}_k\\|/d_k \\le 1$.\n\nThe gradients of the shape functions are required for computing strains. They are obtained by differentiating $\\phi_k(\\boldsymbol{x})$ with respect to the spatial coordinates using the product and chain rules:\n$$\n\\frac{\\partial \\phi_k}{\\partial x} = \\frac{\\partial \\boldsymbol{p}^T}{\\partial x} \\boldsymbol{A}^{-1} w_k \\boldsymbol{p}_k + \\boldsymbol{p}^T \\frac{\\partial \\boldsymbol{A}^{-1}}{\\partial x} w_k \\boldsymbol{p}_k + \\boldsymbol{p}^T \\boldsymbol{A}^{-1} \\frac{\\partial w_k}{\\partial x} \\boldsymbol{p}_k\n$$\nwhere $\\frac{\\partial\\boldsymbol{p}^T}{\\partial x} = [0, 1, 0]$, $\\frac{\\partial w_k}{\\partial x} = w'(q_k)\\frac{\\partial q_k}{\\partial x}$, and $\\frac{\\partial \\boldsymbol{A}^{-1}}{\\partial x} = -\\boldsymbol{A}^{-1} \\frac{\\partial \\boldsymbol{A}}{\\partial x} \\boldsymbol{A}^{-1}$ with $\\frac{\\partial \\boldsymbol{A}}{\\partial x} = \\sum_{j=1}^{N} \\frac{\\partial w_j}{\\partial x} \\boldsymbol{p}_j \\boldsymbol{p}_j^T$. A similar expression holds for the derivative with respect to $y$.\n\n**3. System Assembly via Numerical Integration**\n\nSubstituting the discrete approximation for $\\boldsymbol{u}$ and the virtual displacement $\\boldsymbol{v}$ (using the same shape functions, per Galerkin's method) into the weak form leads to the linear system $\\boldsymbol{K}\\boldsymbol{d}=\\boldsymbol{F}$. The global stiffness matrix $\\boldsymbol{K}$ is an assembly of nodal contributions:\n$$\n\\boldsymbol{K} = \\sum_{k=1}^N \\sum_{l=1}^N \\boldsymbol{K}_{kl}, \\quad \\text{where} \\quad \\boldsymbol{K}_{kl} = \\int_{\\Omega} \\boldsymbol{B}_k^T \\boldsymbol{C} \\boldsymbol{B}_l \\, \\mathrm{d}\\Omega\n$$\nHere, $\\boldsymbol{d}$ is the global vector of nodal displacements, and $\\boldsymbol{B}_k$ is the strain-displacement matrix for node $k$:\n$$\n\\boldsymbol{B}_k =\n\\begin{bmatrix}\n\\frac{\\partial\\phi_k}{\\partial x} & 0 \\\\\n0 & \\frac{\\partial\\phi_k}{\\partial y} \\\\\n\\frac{\\partial\\phi_k}{\\partial y} & \\frac{\\partial\\phi_k}{\\partial x}\n\\end{bmatrix}\n$$\nThe integral for $\\boldsymbol{K}$ is evaluated numerically using Gauss quadrature over a background grid of integration cells. For a rectangular cell, a tensor product of one-dimensional Gauss-Legendre rules is used. The integral over the domain $\\Omega$ is the sum of integrals over all cells:\n$$\n\\int_{\\Omega} f(\\boldsymbol{x})\\, \\mathrm{d}\\Omega = \\sum_{e=1}^{N_{cells}} \\int_{\\Omega_e} f(\\boldsymbol{x})\\, \\mathrm{d}\\Omega_e \\approx \\sum_{e=1}^{N_{cells}} \\sum_{q=1}^{n_g^2} f(\\boldsymbol{x}_q) w_q J_e\n$$\nwhere $\\boldsymbol{x}_q$ and $w_q$ are the quadrature points and weights in the physical cell, and $J_e$ is the Jacobian of the mapping from the reference square $[-1,1]^2$ to the physical cell $\\Omega_e$.\n\n**4. Boundary Conditions**\n\nEssential boundary conditions are enforced on all nodes on $\\partial\\Omega$ using the penalty method. For a degree of freedom $i$ corresponding to a boundary node, the stiffness matrix $\\boldsymbol{K}$ and force vector $\\boldsymbol{F}$ are modified as follows:\n$$\nK_{ii} \\leftarrow K_{ii} + \\alpha_p\n$$\n$$\nF_i \\leftarrow F_i + \\alpha_p u^{\\mathrm{exact}}_i\n$$\nwhere $\\alpha_p$ is a large penalty parameter (here, $\\alpha_p = \\beta E$) and $u^{\\mathrm{exact}}_i$ is the prescribed exact displacement for that degree of freedom. Since the original force vector $\\boldsymbol{F}$ from the weak form is zero, the final force vector only contains contributions from the penalty terms.\n\n**5. Solution and Verification**\n\nAfter assembling $\\boldsymbol{K}$ and $\\boldsymbol{F}$, the linear system $\\boldsymbol{K}\\boldsymbol{d} = \\boldsymbol{F}$ is solved for the global displacement vector $\\boldsymbol{d}$.\n\nThe patch test is passed if the numerical solution reproduces the constant strain field exactly. We evaluate the strains from the computed nodal displacements $\\boldsymbol{d}$ at a set of interior sample points (the Gauss quadrature points are used for this). The numerically computed strain components are:\n$$\n\\varepsilon_{xx}^h(\\boldsymbol{x}) = \\sum_{k=1}^N \\frac{\\partial\\phi_k(\\boldsymbol{x})}{\\partial x} u_{x,k}\n$$\n$$\n\\varepsilon_{yy}^h(\\boldsymbol{x}) = \\sum_{k=1}^N \\frac{\\partial\\phi_k(\\boldsymbol{x})}{\\partial y} u_{y,k}\n$$\n$$\n\\varepsilon_{xy}^h(\\boldsymbol{x}) = \\frac{1}{2} \\sum_{k=1}^N \\left( \\frac{\\partial\\phi_k(\\boldsymbol{x})}{\\partial y} u_{x,k} + \\frac{\\partial\\phi_k(\\boldsymbol{x})}{\\partial x} u_{y,k} \\right)\n$$\nThe maximum absolute error over all sample points is computed as:\n$$\ne_{\\max} = \\max_{\\text{samples}} \\left( \\max\\left( \\left| \\varepsilon_{xx}^{h} - \\varepsilon_{xx}^{\\star} \\right|,\\; \\left| \\varepsilon_{yy}^{h} - \\varepsilon_{yy}^{\\star} \\right|,\\; \\left| \\varepsilon_{xy}^{h} - \\varepsilon_{xy}^{\\star} \\right| \\right) \\right)\n$$\nThe test passes if $e_{\\max} \\le \\tau$, where $\\tau$ is a specified tolerance. A passing result indicates that the EFG implementation correctly incorporates the linear basis, allowing for the exact reproduction of constant strain fields, which is a fundamental requirement for a valid numerical method in continuum mechanics.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the EFG patch test for all specified cases.\n    \"\"\"\n\n    # --- Constants and Exact Solution ---\n    E = 1.0e5  # Young's modulus in Pa\n    NU = 0.25  # Poisson's ratio\n    LX, LY = 1.0, 1.0  # Domain dimensions in m\n\n    # Target constant strains (dimensionless)\n    EPS_XX_STAR = 1.25e-3\n    EPS_YY_STAR = -7.5e-4\n    EPS_XY_STAR = 5.0e-4 # Tensor component\n    \n    # Plane stress elasticity matrix C for [exx, eyy, gxy]^T\n    C_mat = (E / (1.0 - NU**2)) * np.array([\n        [1.0, NU, 0.0],\n        [NU, 1.0, 0.0],\n        [0.0, 0.0, (1.0 - NU) / 2.0]\n    ])\n\n    # Exact displacement field function\n    def u_exact(x, y):\n        ux = EPS_XX_STAR * x + EPS_XY_STAR * y\n        uy = EPS_XY_STAR * x + EPS_YY_STAR * y\n        return np.array([ux, uy])\n\n    # --- Test Cases ---\n    test_cases = [\n        # (Nx, Ny, alpha_s, n_g, beta, tau), Case A\n        (5, 5, 2.5, 2, 1.0e6, 1.0e-4),\n        # Case B\n        (3, 3, 2.0, 2, 1.0e5, 2.0e-4),\n        # Case C\n        (6, 6, 2.0, 3, 1.0e6, 5.0e-5),\n    ]\n\n    results = []\n    for case in test_cases:\n        Nx, Ny, alpha_s, n_g, beta, tau = case\n        e_max = run_patch_test(\n            Nx, Ny, alpha_s, n_g, beta,\n            LX, LY, E, C_mat, u_exact,\n            EPS_XX_STAR, EPS_YY_STAR, EPS_XY_STAR\n        )\n        results.append(e_max <= tau)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\n\ndef run_patch_test(Nx, Ny, alpha_s, n_g, beta, Lx, Ly, E, C, u_exact_func,\n                   eps_xx_star, eps_yy_star, eps_xy_star):\n    \"\"\"\n    Executes a single EFG patch test case.\n    \"\"\"\n\n    # --- Nodal and Grid Setup ---\n    hx = Lx / (Nx - 1)\n    hy = Ly / (Ny - 1)\n    nodes = np.array([(i * hx, j * hy) for j in range(Ny) for i in range(Nx)])\n    num_nodes = Nx * Ny\n    num_dofs = 2 * num_nodes\n    support_radius = alpha_s * max(hx, hy)\n\n    # --- Background Integration Grid ---\n    num_cells_x = Nx - 1\n    num_cells_y = Ny - 1\n    gauss_pts, gauss_wts_1d = np.polynomial.legendre.leggauss(n_g)\n    \n    K = np.zeros((num_dofs, num_dofs))\n    F = np.zeros(num_dofs)\n\n    # --- Assembly ---\n    for j in range(num_cells_y):\n        for i in range(num_cells_x):\n            x_min, y_min = i * hx, j * hy\n            jac_det = (hx * hy) / 4.0\n\n            for id_eta, eta in enumerate(gauss_pts):\n                for id_xi, xi in enumerate(gauss_pts):\n                    # Map from reference to physical coordinates\n                    gx = x_min + (1.0 + xi) * hx / 2.0\n                    gy = y_min + (1.0 + eta) * hy / 2.0\n                    \n                    # Get MLS shape functions and derivatives at this Gauss point\n                    phi, dphidx, dphidy = mls_shape_derivatives(gx, gy, nodes, support_radius)\n                    \n                    influencing_nodes_idx = np.where(phi != 0)[0]\n                    \n                    # Assemble stiffness matrix contributions\n                    for k_idx in influencing_nodes_idx:\n                        Bk = np.array([\n                            [dphidx[k_idx], 0],\n                            [0, dphidy[k_idx]],\n                            [dphidy[k_idx], dphidx[k_idx]]\n                        ])\n                        \n                        for l_idx in influencing_nodes_idx:\n                            Bl = np.array([\n                                [dphidx[l_idx], 0],\n                                [0, dphidy[l_idx]],\n                                [dphidy[l_idx], dphidx[l_idx]]\n                            ])\n                            \n                            integrand = Bk.T @ C @ Bl\n                            k_sub = integrand * jac_det * gauss_wts_1d[id_xi] * gauss_wts_1d[id_eta]\n                            \n                            # Add to global K\n                            dof_xk, dof_yk = 2 * k_idx, 2 * k_idx + 1\n                            dof_xl, dof_yl = 2 * l_idx, 2 * l_idx + 1\n                            K[dof_xk, dof_xl] += k_sub[0, 0]\n                            K[dof_xk, dof_yl] += k_sub[0, 1]\n                            K[dof_yk, dof_xl] += k_sub[1, 0]\n                            K[dof_yk, dof_yl] += k_sub[1, 1]\n\n    # --- Apply Penalty Boundary Conditions ---\n    alpha_p = beta * E\n    boundary_nodes_mask = (np.isclose(nodes[:, 0], 0)) | (np.isclose(nodes[:, 0], Lx)) | \\\n                          (np.isclose(nodes[:, 1], 0)) | (np.isclose(nodes[:, 1], Ly))\n    boundary_nodes_idx = np.where(boundary_nodes_mask)[0]\n\n    for node_idx in boundary_nodes_idx:\n        x_node, y_node = nodes[node_idx]\n        u_ex = u_exact_func(x_node, y_node)\n        \n        dof_x, dof_y = 2 * node_idx, 2 * node_idx + 1\n        \n        K[dof_x, dof_x] += alpha_p\n        K[dof_y, dof_y] += alpha_p\n        \n        F[dof_x] += alpha_p * u_ex[0]\n        F[dof_y] += alpha_p * u_ex[1]\n\n    # --- Solve Linear System ---\n    try:\n        displacements = np.linalg.solve(K, F)\n    except np.linalg.LinAlgError:\n        return np.inf # Return infinite error if system is singular\n\n    # --- Verification ---\n    max_error = 0.0\n    for j in range(num_cells_y):\n        for i in range(num_cells_x):\n            x_min, y_min = i * hx, j * hy\n\n            for eta in gauss_pts:\n                for xi in gauss_pts:\n                    gx = x_min + (1.0 + xi) * hx / 2.0\n                    gy = y_min + (1.0 + eta) * hy / 2.0\n\n                    phi, dphidx, dphidy = mls_shape_derivatives(gx, gy, nodes, support_radius)\n                    influencing_nodes_idx = np.where(phi != 0)[0]\n                    \n                    eps_xx_h, eps_yy_h, gamma_xy_h = 0.0, 0.0, 0.0\n                    for k_idx in influencing_nodes_idx:\n                        ux_k = displacements[2 * k_idx]\n                        uy_k = displacements[2 * k_idx + 1]\n                        \n                        eps_xx_h += dphidx[k_idx] * ux_k\n                        eps_yy_h += dphidy[k_idx] * uy_k\n                        gamma_xy_h += dphidy[k_idx] * ux_k + dphidx[k_idx] * uy_k\n                    \n                    eps_xy_h = 0.5 * gamma_xy_h\n\n                    error = max(\n                        abs(eps_xx_h - eps_xx_star),\n                        abs(eps_yy_h - eps_yy_star),\n                        abs(eps_xy_h - eps_xy_star)\n                    )\n                    if error > max_error:\n                        max_error = error\n\n    return max_error\n\n\ndef mls_shape_derivatives(x, y, nodes, support_radius):\n    \"\"\"\n    Computes MLS shape functions and their gradients at a point (x, y).\n    \"\"\"\n    num_nodes = len(nodes)\n    p_basis = np.array([1.0, x, y])\n    dp_dx = np.array([0.0, 1.0, 0.0])\n    dp_dy = np.array([0.0, 0.0, 1.0])\n\n    distances = np.linalg.norm(nodes - np.array([x, y]), axis=1)\n    q = distances / support_radius\n    \n    influencing_mask = q  1.0\n    influencing_indices = np.where(influencing_mask)[0]\n\n    A = np.zeros((3, 3))\n    dA_dx = np.zeros((3, 3))\n    dA_dy = np.zeros((3, 3))\n\n    weights = np.zeros(num_nodes)\n    dwd_x = np.zeros(num_nodes)\n    dwd_y = np.zeros(num_nodes)\n    \n    for i in influencing_indices:\n        qi = q[i]\n        weights[i] = (1 - qi)**4 * (1 + 4 * qi)\n        \n        # Derivative of weight w.r.t q\n        dw_dq = -20.0 * qi * (1 - qi)**3\n        \n        # Derivatives of q w.r.t x, y\n        if distances[i]  1e-15:\n            dr_dx, dr_dy = 0.0, 0.0\n        else:\n            dr_dx = (x - nodes[i, 0]) / distances[i]\n            dr_dy = (y - nodes[i, 1]) / distances[i]\n\n        dq_dx = dr_dx / support_radius\n        dq_dy = dr_dy / support_radius\n\n        dwd_x[i] = dw_dq * dq_dx\n        dwd_y[i] = dw_dq * dq_dy\n\n        p_node = np.array([1.0, nodes[i, 0], nodes[i, 1]])\n        p_outer_p = np.outer(p_node, p_node)\n        \n        A += weights[i] * p_outer_p\n        dA_dx += dwd_x[i] * p_outer_p\n        dA_dy += dwd_y[i] * p_outer_p\n    \n    try:\n        A_inv = np.linalg.inv(A)\n    except np.linalg.LinAlgError:\n        return np.zeros(num_nodes), np.zeros(num_nodes), np.zeros(num_nodes)\n\n    dA_inv_dx = -A_inv @ dA_dx @ A_inv\n    dA_inv_dy = -A_inv @ dA_dy @ A_inv\n\n    phi = np.zeros(num_nodes)\n    dphi_dx = np.zeros(num_nodes)\n    dphi_dy = np.zeros(num_nodes)\n\n    for i in influencing_indices:\n        p_node = np.array([1.0, nodes[i, 0], nodes[i, 1]])\n        \n        term1 = p_basis @ A_inv\n        term2 = weights[i] * p_node\n        phi[i] = term1 @ term2\n\n        dterm1_dx = dp_dx @ A_inv + p_basis @ dA_inv_dx\n        dterm1_dy = dp_dy @ A_inv + p_basis @ dA_inv_dy\n        \n        dphi_dx[i] = dterm1_dx @ term2 + term1 @ (dwd_x[i] * p_node)\n        dphi_dy[i] = dterm1_dy @ term2 + term1 @ (dwd_y[i] * p_node)\n\n    return phi, dphi_dx, dphi_dy\n\nif __name__ == \"__main__\":\n    solve()\n\n```", "id": "2661977"}]}