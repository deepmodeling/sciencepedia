{"hands_on_practices": [{"introduction": "The Material Point Method builds upon a grid to solve continuum mechanics equations, sharing deep connections with the Finite Element Method (FEM). Understanding this relationship is crucial for developing an intuition for MPM's behavior, particularly in how it discretizes and solves the governing equations. This exercise guides you through a foundational derivation that illuminates this link, demonstrating how the particle-to-grid mapping of forces in MPM reduces to the familiar lumped-mass formulation of FEM under specific conditions [@problem_id:2657718].", "problem": "Consider a straight, one-dimensional bar of uniform mass density $\\rho$ and constant cross-sectional area $A$, occupying the reference domain $\\Omega = [0,L]$. Assume the bar is stress-free initially and is subjected to a spatially uniform body force per unit mass $b$ (for example, gravitational acceleration), with no applied tractions on the boundary. Use the Material Point Method (MPM), with linear finite element shape functions defined on a uniform background grid of nodes at positions $x_j = j\\,\\Delta x$ for integer $j$, where $\\Delta x$ is the uniform cell size.\n\nYou are to start from the balance of linear momentum in weak form and the definition of the Galerkin projection. Then, make the following modeling choices consistent with a standard MPM implementation:\n- Use linear (piecewise affine) hat functions $N_j(x)$ as trial and test functions on the background grid.\n- Approximate domain integrals by particle quadrature with one particle per cell, located at the cell center. Each material point (particle) carries mass $m_p = \\rho\\,A\\,\\Delta x$ and volume $V_p = A\\,\\Delta x$.\n\nAssume that at the instant of interest the Cauchy stress is zero everywhere (so that only inertia and body force contribute). For any interior node $i$ (i.e., a node that has exactly two adjacent cells), derive from first principles how the weak form reduces to a nodal equation identical to that obtained by a lumped-mass finite element discretization. In particular, determine the closed-form expression for the body-force-induced nodal right-hand side at node $i$, which in the absence of internal force equals the inertial term $m_i\\,a_i$.\n\nProvide your final answer as a single symbolic expression. Do not substitute numerical values. No units are required in the boxed answer.", "solution": "The problem as stated is scientifically grounded, well-posed, and self-contained. It presents a standard derivation in the field of computational solid mechanics, specifically concerning the Material Point Method (MPM). No inconsistencies or fallacies are present. Therefore, we proceed with the solution.\n\nThe starting point is the balance of linear momentum in weak form, also known as the principle of virtual work. For a one-dimensional continuum occupying the domain $\\Omega$, with Cauchy stress $\\sigma$ and body force per unit mass $b$, this principle states:\n$$\n\\int_{\\Omega} \\rho a \\delta u \\, dV + \\int_{\\Omega} \\sigma \\frac{d(\\delta u)}{dx} \\, dV = \\int_{\\Omega} \\rho b \\delta u \\, dV + \\left[ T \\delta u \\right]_{\\partial\\Omega}\n$$\nwhere $a$ is the acceleration, $\\delta u$ is an arbitrary virtual displacement (the test function), $\\rho$ is the mass density, $dV = A dx$ is the differential volume element with cross-sectional area $A$, and $T = \\sigma A$ is the traction force on the boundary $\\partial\\Omega$.\n\nThe problem specifies that the bar is initially stress-free and that the Cauchy stress is zero everywhere at the instant of interest, so $\\sigma = 0$. It also states there are no applied tractions on the boundary, so the boundary term $\\left[ T \\delta u \\right]_{\\partial\\Omega}$ is zero. The weak form thus simplifies significantly to:\n$$\n\\int_{\\Omega} \\rho a \\delta u \\, dV = \\int_{\\Omega} \\rho b \\delta u \\, dV\n$$\nWe now apply the Galerkin method on the background grid. The continuous acceleration field $a(x)$ is approximated by a linear combination of nodal accelerations $a_j$ and grid-based shape functions $N_j(x)$:\n$$\na(x) \\approx \\sum_{j} a_j N_j(x)\n$$\nThe test function $\\delta u$ is chosen from the same basis of shape functions. To find the equation for a specific node $i$, we set $\\delta u(x) = N_i(x)$. Substituting these into the simplified weak form gives:\n$$\n\\int_{\\Omega} \\rho \\left( \\sum_{j} a_j N_j(x) \\right) N_i(x) \\, dV = \\int_{\\Omega} \\rho b N_i(x) \\, dV\n$$\nIn the Material Point Method, continuum integrals are approximated by a sum over a set of material points (particles), indexed by $p$. The integral of a quantity $f(x)$ is approximated as $\\int_{\\Omega} f(x) \\, dV \\approx \\sum_p f(x_p) V_p$, where $x_p$ is the position of particle $p$ and $V_p$ is its volume. Applying this quadrature rule to both sides of the equation yields:\n$$\n\\sum_p \\rho_p \\left( \\sum_{j} a_j N_j(x_p) \\right) N_i(x_p) V_p = \\sum_p \\rho_p b N_i(x_p) V_p\n$$\nUsing the definition of particle mass, $m_p = \\rho_p V_p$, and recognizing that the body force $b$ is uniform, we can write:\n$$\n\\sum_j \\left( \\sum_p m_p N_i(x_p) N_j(x_p) \\right) a_j = b \\sum_p m_p N_i(x_p)\n$$\nThis is the discretized equation of motion. The term on the right-hand side is the body-force-induced nodal force at node $i$, which we denote as $F_i^{\\text{body}}$. The problem asks for the explicit expression for this term.\n$$\nF_i^{\\text{body}} = b \\sum_p m_p N_i(x_p)\n$$\nThe problem specifies that we have one particle per cell, located at the cell center, and that each particle has a mass $m_p = \\rho A \\Delta x$. The grid nodes are at $x_j = j \\Delta x$. The linear \"hat\" shape function $N_i(x)$ for an interior node $i$ is non-zero only over the domain $[x_{i-1}, x_{i+1}]$. Its explicit form is:\n$$\nN_i(x) = \\begin{cases}\n\\frac{x - x_{i-1}}{\\Delta x} & \\text{if } x \\in [x_{i-1}, x_{i}] \\\\\n\\frac{x_{i+1} - x}{\\Delta x} & \\text{if } x \\in [x_{i}, x_{i+1}] \\\\\n0 & \\text{otherwise}\n\\end{cases}\n$$\nSince the support of $N_i(x)$ is the interval $[(i-1)\\Delta x, (i+1)\\Delta x]$, only particles located within this interval will contribute to the sum for $F_i^{\\text{body}}$. With one particle per cell at the cell center, the relevant particles are:\n$1$. The particle in cell $i-1$, which spans $[x_{i-1}, x_i]$. Its position is $x_{p,i-1} = x_{i-1} + \\frac{\\Delta x}{2} = (i-1)\\Delta x + \\frac{\\Delta x}{2} = (i - \\frac{1}{2})\\Delta x$.\n$2$. The particle in cell $i$, which spans $[x_i, x_{i+1}]$. Its position is $x_{p,i} = x_i + \\frac{\\Delta x}{2} = i\\Delta x + \\frac{\\Delta x}{2} = (i + \\frac{1}{2})\\Delta x$.\n\nWe evaluate the shape function $N_i(x)$ at these two particle positions:\nFor the particle at $x_{p,i-1}$, which is in the domain $[x_{i-1}, x_i]$:\n$$\nN_i(x_{p,i-1}) = \\frac{(i - \\frac{1}{2})\\Delta x - (i-1)\\Delta x}{\\Delta x} = \\frac{\\frac{1}{2}\\Delta x}{\\Delta x} = \\frac{1}{2}\n$$\nFor the particle at $x_{p,i}$, which is in the domain $[x_i, x_{i+1}]$:\n$$\nN_i(x_{p,i}) = \\frac{(i+1)\\Delta x - (i + \\frac{1}{2})\\Delta x}{\\Delta x} = \\frac{\\frac{1}{2}\\Delta x}{\\Delta x} = \\frac{1}{2}\n$$\nNow we compute the nodal force $F_i^{\\text{body}}$ by summing the contributions from these two particles. All other particles lie outside the support of $N_i(x)$ and contribute zero.\n$$\nF_i^{\\text{body}} = b \\left( m_p N_i(x_{p,i-1}) + m_p N_i(x_{p,i}) \\right)\n$$\n$$\nF_i^{\\text{body}} = b \\left( m_p \\cdot \\frac{1}{2} + m_p \\cdot \\frac{1}{2} \\right) = b \\, m_p\n$$\nSubstituting the given expression for the particle mass, $m_p = \\rho A \\Delta x$, we obtain the final expression for the nodal body force:\n$$\nF_i^{\\text{body}} = \\rho b A \\Delta x\n$$\nThis expression is indeed identical to the nodal force obtained in a standard lumped-mass finite element method. In that context, the lumped mass at an interior node $i$ is $m_i = \\rho A \\Delta x$ (half the mass from each of the two adjacent elements), and the consistent nodal body force is $\\int \\rho b N_i(x) dV = \\rho b A \\int_{x_{i-1}}^{x_{i+1}} N_i(x) dx = \\rho b A \\Delta x$. The MPM formulation with one particle per cell center exactly reproduces the lumped-mass FEM result. The equation of motion for the node, in the absence of internal forces, is $m_i a_i = F_i^{\\text{body}}$, which becomes $(\\rho A \\Delta x) a_i = \\rho b A \\Delta x$, correctly yielding $a_i=b$. The requested quantity is the expression for the right-hand side.", "answer": "$$\n\\boxed{\\rho b A \\Delta x}\n$$", "id": "2657718"}, {"introduction": "A defining feature of MPM is the two-way transfer of information between material points and a computational grid. The choice of how to update particle velocities from the grid (the G2P step) has profound consequences for the simulation's accuracy and conservation properties, with the Particle-In-Cell (PIC) and Fluid-Implicit-Particle (FLIP) schemes being the two classical choices. This hands-on coding practice challenges you to implement and compare these two schemes directly, allowing you to gain a quantitative understanding of numerical diffusion—a critical concept for assessing the fidelity of any MPM simulation [@problem_id:2657769].", "problem": "You are asked to quantitatively compare the Particle-In-Cell (PIC) and Fluid-Implicit Particle (FLIP) grid-to-particle (G2P) velocity updates used in the Material Point Method (MPM) for a two-dimensional incompressible vortex, by measuring their numerical diffusion through the change in total kinetic energy after one transfer cycle. The comparison must be performed in a setting with no external forces and no grid-based time integration, so that any change in kinetic energy arises solely from the transfer scheme.\n\nStart from the following fundamental base and core definitions in solid mechanics and numerical methods for continuum mechanics:\n- Newton’s second law and conservation of linear momentum.\n- Mass lumping and mass-weighted averaging on a grid.\n- Partition of unity of linear finite element shape functions on a structured grid.\n- Definition of kinetic energy.\n\nConsider a square periodic domain of side length $L$ discretized by a uniform Cartesian nodal grid of $N \\times N$ nodes with spacing $h = L/N$. Let particles carry mass $m_p$, position $\\mathbf{x}_p \\in [0,L)^2$, and velocity $\\mathbf{v}_p$. Use bilinear (tensor-product) piecewise-linear hat functions as shape functions for particle-to-grid (P2G) and grid-to-particle (G2P) transfers. In one dimension, the hat function is $\\phi(r) = \\max(1 - |r|, 0)$, and in two dimensions the weight from particle $p$ to node $i$ at position $\\mathbf{x}_i$ is $w_{ip} = \\phi\\!\\left(\\frac{x_i - x_p}{h}\\right)\\phi\\!\\left(\\frac{y_i - y_p}{h}\\right)$. Assume periodic wrapping for all grid indexing.\n\nImplement the following P2G and G2P transfers:\n1) P2G mass and momentum:\n- Nodal mass $m_i = \\sum_{p} m_p w_{ip}$.\n- Nodal momentum $\\mathbf{p}_i = \\sum_{p} m_p w_{ip} \\mathbf{v}_p$.\n- Nodal velocity $\\mathbf{v}_i = \\mathbf{p}_i / m_i$ for nodes with $m_i > 0$, and $\\mathbf{v}_i = \\mathbf{0}$ otherwise.\n\n2) G2P velocity update for PIC:\n- $\\mathbf{v}_p^{\\text{PIC}} = \\sum_{i} w_{ip} \\mathbf{v}_i$.\n\n3) G2P velocity update for FLIP with no grid update (no forces, no time integration):\n- Let $\\mathbf{v}_i^{n}$ be the nodal velocity obtained by P2G from $\\mathbf{v}_p^{n}$.\n- Assume $\\mathbf{v}_i^{n+1} = \\mathbf{v}_i^{n}$ (no change on grid).\n- Then the FLIP update is $\\mathbf{v}_p^{\\text{FLIP}} = \\mathbf{v}_p^{n} + \\sum_{i} w_{ip}(\\mathbf{v}_i^{n+1} - \\mathbf{v}_i^{n})$, which reduces to $\\mathbf{v}_p^{\\text{FLIP}} = \\mathbf{v}_p^{n}$.\n\nDefine the initial particle velocity by a solid-body rotation (simple vortex) about the domain center $\\mathbf{c} = (L/2,L/2)$:\n- $\\mathbf{v}(\\mathbf{x}) = \\omega \\begin{bmatrix} -(y - c_y) \\\\ x - c_x \\end{bmatrix}$,\nwhere $\\omega$ is a specified scalar angular speed. This field is divergence-free and has spatially linear components.\n\nFor each test case, compute the total kinetic energy before and after one P2G+G2P cycle for PIC and FLIP:\n- $E_{\\text{before}} = \\tfrac{1}{2}\\sum_{p} m_p \\|\\mathbf{v}_p\\|^2$,\n- $E_{\\text{after}}^{\\text{PIC}} = \\tfrac{1}{2}\\sum_{p} m_p \\|\\mathbf{v}_p^{\\text{PIC}}\\|^2$,\n- $E_{\\text{after}}^{\\text{FLIP}} = \\tfrac{1}{2}\\sum_{p} m_p \\|\\mathbf{v}_p^{\\text{FLIP}}\\|^2$.\nReport the energy ratios $r_{\\text{PIC}} = E_{\\text{after}}^{\\text{PIC}}/E_{\\text{before}}$ and $r_{\\text{FLIP}} = E_{\\text{after}}^{\\text{FLIP}}/E_{\\text{before}}$ as dimensionless quantities (no physical units are required).\n\nYour program must implement the above transfers exactly and evaluate the following test suite. For all tests, use the domain $[0,L)^2$ with $L = 1.0$ and periodic boundaries, bilinear hat functions, and no grid solve (i.e., $\\mathbf{v}_i^{n+1} = \\mathbf{v}_i^{n}$).\n\nTest suite:\n- Test $1$ (happy path): $N = 32$, $\\omega = 10.0$. Use $4$ particles per cell, placed by jittered sampling within each cell using a fixed random seed of $123$. All particles have equal mass $m_p = 1.0$.\n- Test $2$ (boundary case: single particle): $N = 16$, $\\omega = 5.0$. Use a single particle at position $(x,y) = (0.321, 0.654)$ with mass $m_p = 1.0$.\n- Test $3$ (coarse grid with structured sampling): $N = 8$, $\\omega = 20.0$. Use one particle placed at each cell center, all with mass $m_p = 1.0$.\n- Test $4$ (cancellation-prone configuration): $N = 16$, $\\omega = 15.0$. Use two particles with equal mass $m_p = 1.0$ at positions $(x,y) = (0.3, 0.5)$ and $(x,y) = (0.7, 0.5)$.\n\nFor each test, compute $r_{\\text{PIC}}$ and $r_{\\text{FLIP}}$ after one P2G+G2P cycle. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets in the order\n$[r_{\\text{PIC}}^{(1)}, r_{\\text{FLIP}}^{(1)}, r_{\\text{PIC}}^{(2)}, r_{\\text{FLIP}}^{(2)}, r_{\\text{PIC}}^{(3)}, r_{\\text{FLIP}}^{(3)}, r_{\\text{PIC}}^{(4)}, r_{\\text{FLIP}}^{(4)}]$.", "solution": "The problem statement has been subjected to rigorous validation and is found to be well-posed, scientifically grounded, and internally consistent. It presents a clear, quantitative task based on established principles of computational mechanics. No flaws, ambiguities, or contradictions were identified. The problem is therefore deemed valid, and the solution proceeds as follows.\n\nThe core of the problem is to compare the numerical dissipation characteristics of two common grid-to-particle (G2P) velocity update schemes in the Material Point Method (MPM): the Particle-In-Cell (PIC) and Fluid-Implicit Particle (FLIP) methods. The comparison is performed under simplified conditions—no external forces and no time integration of grid quantities—to isolate the energy change resulting purely from the particle-grid-particle transfer cycle.\n\nThe fundamental transfers are defined as follows. Given a set of particles $p$, each with mass $m_p$, position $\\mathbf{x}_p$, and velocity $\\mathbf{v}_p$, on a grid of nodes $i$ with positions $\\mathbf{x}_i$ and shape functions $w_{ip} = w_i(\\mathbf{x}_p)$, the procedures are:\n\n$1$. Particle-to-Grid (P2G) Transfer:\nNodal mass $m_i$ and momentum $\\mathbf{p}_i$ are computed by lumping particle contributions.\n$$m_i = \\sum_{p} m_p w_{ip}$$\n$$\\mathbf{p}_i = \\sum_{p} m_p w_{ip} \\mathbf{v}_p$$\nThe nodal velocity $\\mathbf{v}_i$ is then found as a mass-weighted average.\n$$\\mathbf{v}_i = \\begin{cases} \\mathbf{p}_i / m_i & \\text{if } m_i > 0 \\\\ \\mathbf{0} & \\text{if } m_i = 0 \\end{cases}$$\n\n$2$. Grid-to-Particle (G2P) Transfer:\nThe new particle velocity is computed by interpolating from the grid.\nFor PIC, the new velocity is an absolute interpolation of the grid velocity field:\n$$\\mathbf{v}_p^{\\text{PIC}} = \\sum_{i} w_{ip} \\mathbf{v}_i$$\nFor FLIP, the update is incremental. Given the problem-specified condition that there is no grid solve, the grid velocity at the end of the step, $\\mathbf{v}_i^{n+1}$, is identical to the grid velocity at the beginning of the step, $\\mathbf{v}_i^{n}$.\n$$\\mathbf{v}_p^{\\text{FLIP}} = \\mathbf{v}_p^{n} + \\sum_{i} w_{ip} (\\mathbf{v}_i^{n+1} - \\mathbf{v}_i^{n}) = \\mathbf{v}_p^{n} + \\sum_{i} w_{ip} (\\mathbf{v}_i^{n} - \\mathbf{v}_i^{n}) = \\mathbf{v}_p^{n}$$\nThis simplification is a direct logical consequence of the problem's constraints. It reveals a fundamental property of the FLIP scheme: in the absence of grid-level updates, particle velocities are unchanged.\n\nThe analysis of kinetic energy change, measured by the ratios $r_{\\text{PIC}} = E_{\\text{after}}^{\\text{PIC}}/E_{\\text{before}}$ and $r_{\\text{FLIP}} = E_{\\text{after}}^{\\text{FLIP}}/E_{\\text{before}}$, proceeds from these definitions.\n\nFor the FLIP update, since $\\mathbf{v}_p^{\\text{FLIP}} = \\mathbf{v}_p^{n}$, the kinetic energy is perfectly conserved by construction in this scenario.\n$$E_{\\text{after}}^{\\text{FLIP}} = \\frac{1}{2}\\sum_{p} m_p \\|\\mathbf{v}_p^{\\text{FLIP}}\\|^2 = \\frac{1}{2}\\sum_{p} m_p \\|\\mathbf{v}_p^{n}\\|^2 = E_{\\text{before}}$$\nTherefore, for all test cases, $r_{\\text{FLIP}} = 1.0$.\n\nFor the PIC update, the analysis depends on the particle configuration and the nature of the velocity field. The two-step P2G-G2P process amounts to a smoothing operation. A particle's velocity is first projected onto the grid, where it is averaged with contributions from neighboring particles. This averaged grid velocity field is then interpolated back to the particle's position. This round trip, $\\mathbf{v}_p \\to \\{\\mathbf{v}_i\\} \\to \\mathbf{v}_p^{\\text{PIC}}$, is generally not an identity operation and is known to be numerically diffusive.\nThe new particle velocity can be expressed as:\n$$\\mathbf{v}_p^{\\text{PIC}} = \\sum_{i} w_{ip} \\left( \\frac{\\sum_q m_q w_{iq} \\mathbf{v}_q}{\\sum_r m_r w_{ir}} \\right)$$\n\nWe analyze the four specified test cases:\n\nTest $1$: Jittered particle sampling ($4$ particles per cell). The particle positions are irregular. The initial velocity field, $\\mathbf{v}(\\mathbf{x}) = \\omega [-(y - c_y), x - c_x]^T$, is linear. However, the P2G mass-weighted averaging of this linear field over irregularly placed particles will not, in general, result in grid velocities $\\mathbf{v}_i$ that are exactly $\\mathbf{v}(\\mathbf{x}_i)$. Subsequent G2P interpolation will introduce further error. This loss of information through averaging results in numerical diffusion, and we expect $r_{\\text{PIC}} < 1.0$. This case requires full numerical evaluation.\n\nTest $2$: A single particle. The grid receives mass and momentum from only this one particle. At any influenced node $i$, the nodal velocity becomes $\\mathbf{v}_i = (m_p w_{ip} \\mathbf{v}_p) / (m_p w_{ip}) = \\mathbf{v}_p$. The G2P update then gives $\\mathbf{v}_p^{\\text{PIC}} = \\sum_i w_{ip} \\mathbf{v}_i = (\\sum_i w_{ip}) \\mathbf{v}_p$. Due to the partition of unity property of the shape functions ($\\sum_i w_{ip} = 1$), this simplifies to $\\mathbf{v}_p^{\\text{PIC}} = \\mathbf{v}_p$. Kinetic energy is conserved. Thus, $r_{\\text{PIC}} = 1.0$.\n\nTest $3$: One particle at each cell center. This highly structured arrangement interacts with the linear velocity field in a predictable way. The P2G transfer to any node $i$ involves averaging the velocities of the particles at the centers of the four adjacent cells. Due to the linearity of $\\mathbf{v}(\\mathbf{x})$ and the symmetry of the particle positions around the node, the resulting nodal velocity is exactly the velocity field evaluated at the node's position: $\\mathbf{v}_i = \\mathbf{v}(\\mathbf{x}_i)$. Subsequently, the G2P transfer interpolates these exact nodal velocities back to a particle's position (a cell center). Again, due to linearity and symmetry, this interpolation is exact: $\\mathbf{v}_p^{\\text{PIC}} = \\mathbf{v}(\\mathbf{x}_p) = \\mathbf{v}_p$. The P2G-G2P cycle is an identity operation, and kinetic energy is conserved. Thus, $r_{\\text{PIC}} = 1.0$.\n\nTest $4$: Two particles at positions $\\mathbf{x}_{p1}=(0.3, 0.5)$ and $\\mathbf{x}_{p2}=(0.7, 0.5)$ on a grid with $N=16$ and $h=1/16=0.0625$. The normalized x-coordinates are $x_{p1}/h = 4.8$ and $x_{p2}/h = 11.2$. The first particle influences nodes with x-indices $4$ and $5$. The second particle influences nodes with x-indices $11$ and $12$. The sets of influenced grid nodes are disjoint. Consequently, there is no interaction between the particles via the grid. Each particle's information is transferred to its local grid neighborhood and then transferred back independently. As in Test $2$, this results in $\\mathbf{v}_p^{\\text{PIC}} = \\mathbf{v}_p$ for each particle. Kinetic energy is conserved, and $r_{\\text{PIC}} = 1.0$.\n\nThe implementation proceeds by first generating the particle positions for each test case. Then, for each case, initial velocities and kinetic energy are computed. The P2G transfer is performed by iterating over all particles and accumulating their contributions to the mass and momentum on a $N \\times N$ grid, with periodic boundary conditions on node indices. Nodal velocities are then calculated. The G2P transfer for PIC is executed by iterating over particles again, interpolating nodal velocities to find the new particle velocities. Finally, the resulting kinetic energy is computed and divided by the initial value to obtain $r_{\\text{PIC}}$. The value of $r_{\\text{FLIP}}$ is always $1.0$. The results are collected and formatted as specified.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_simulation(N, omega, particle_positions, m_p):\n    \"\"\"\n    Performs one P2G-G2P cycle and computes kinetic energy ratios.\n    \"\"\"\n    L = 1.0\n    h = L / N\n    c = np.array([L / 2.0, L / 2.0])\n\n    num_particles = particle_positions.shape[0]\n    if num_particles == 0:\n        return 1.0, 1.0\n\n    particle_masses = np.full(num_particles, m_p)\n\n    # 1. Initial velocities and kinetic energy\n    rel_pos = particle_positions - c\n    particle_velocities = omega * np.stack([-rel_pos[:, 1], rel_pos[:, 0]], axis=1)\n\n    ke_before = 0.5 * np.sum(particle_masses * np.sum(particle_velocities**2, axis=1))\n\n    if ke_before  1e-15:\n        # If initial energy is zero, any after energy is also zero. Ratio is 1.\n        return 1.0, 1.0\n\n    # 2. P2G Transfer (Particle to Grid)\n    grid_mass = np.zeros((N, N))\n    grid_momentum = np.zeros((N, N, 2))\n\n    for p in range(num_particles):\n        pos = particle_positions[p]\n        vel = particle_velocities[p]\n        mass = particle_masses[p]\n\n        grid_coord = pos / h\n        base_node_idx = np.floor(grid_coord).astype(int)\n        frac_coord = grid_coord - base_node_idx\n        fx, fy = frac_coord[0], frac_coord[1]\n\n        # Iterate over 2x2 stencil of nodes\n        for i_off in range(2):\n            for j_off in range(2):\n                node_idx = (\n                    (base_node_idx[0] + i_off) % N,\n                    (base_node_idx[1] + j_off) % N,\n                )\n\n                if i_off == 0 and j_off == 0: weight = (1.0 - fx) * (1.0 - fy)\n                elif i_off == 1 and j_off == 0: weight = fx * (1.0 - fy)\n                elif i_off == 0 and j_off == 1: weight = (1.0 - fx) * fy\n                else: weight = fx * fy\n\n                grid_mass[node_idx[1], node_idx[0]] += mass * weight\n                grid_momentum[node_idx[1], node_idx[0], :] += mass * weight * vel\n    \n    # 3. Compute nodal velocities\n    grid_velocity = np.zeros((N, N, 2))\n    valid_nodes_mask = grid_mass > 1e-15\n    grid_velocity[valid_nodes_mask] = grid_momentum[valid_nodes_mask] / grid_mass[valid_nodes_mask, np.newaxis]\n\n    # 4. G2P Transfer (Grid to Particle - PIC)\n    new_particle_velocities_pic = np.zeros_like(particle_velocities)\n\n    for p in range(num_particles):\n        pos = particle_positions[p]\n        \n        grid_coord = pos / h\n        base_node_idx = np.floor(grid_coord).astype(int)\n        frac_coord = grid_coord - base_node_idx\n        fx, fy = frac_coord[0], frac_coord[1]\n\n        # Iterate over 2x2 stencil\n        for i_off in range(2):\n            for j_off in range(2):\n                node_idx = (\n                    (base_node_idx[0] + i_off) % N,\n                    (base_node_idx[1] + j_off) % N,\n                )\n                \n                if i_off == 0 and j_off == 0: weight = (1.0 - fx) * (1.0 - fy)\n                elif i_off == 1 and j_off == 0: weight = fx * (1.0 - fy)\n                elif i_off == 0 and j_off == 1: weight = (1.0 - fx) * fy\n                else: weight = fx * fy\n                \n                vel_i = grid_velocity[node_idx[1], node_idx[0], :]\n                new_particle_velocities_pic[p, :] += weight * vel_i\n    \n    # 5. Final kinetic energy (PIC)\n    ke_after_pic = 0.5 * np.sum(particle_masses * np.sum(new_particle_velocities_pic**2, axis=1))\n    \n    # 6. Ratios\n    r_pic = ke_after_pic / ke_before\n    # As derived from the problem statement, FLIP is perfectly conservative here\n    r_flip = 1.0\n    \n    return r_pic, r_flip\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_params = [\n        # (N, omega, m_p)\n        (32, 10.0, 1.0), # Test 1\n        (16, 5.0, 1.0),  # Test 2\n        (8, 20.0, 1.0),   # Test 3\n        (16, 15.0, 1.0)  # Test 4\n    ]\n\n    # ---- Generate particle positions for each test case ----\n\n    # Test 1: Jittered sampling\n    N1 = test_params[0][0]\n    h1 = 1.0 / N1\n    rng = np.random.default_rng(123)\n    positions1 = []\n    for i in range(N1):\n        for j in range(N1):\n            random_offsets = rng.random((4, 2))\n            for k in range(4):\n                px = (i + random_offsets[k, 0]) * h1\n                py = (j + random_offsets[k, 1]) * h1\n                positions1.append([px, py])\n    positions1 = np.array(positions1)\n\n    # Test 2: Single particle\n    positions2 = np.array([[0.321, 0.654]])\n\n    # Test 3: Structured sampling (cell centers)\n    N3 = test_params[2][0]\n    h3 = 1.0 / N3\n    grid_i, grid_j = np.meshgrid(np.arange(N3), np.arange(N3))\n    positions3 = (np.stack([grid_i.ravel(), grid_j.ravel()], axis=1) + 0.5) * h3\n\n    # Test 4: Two symmetric particles\n    positions4 = np.array([[0.3, 0.5], [0.7, 0.5]])\n\n    all_positions = [positions1, positions2, positions3, positions4]\n\n    # ---- Run simulations and collect results ----\n    results = []\n    for i, params in enumerate(test_params):\n        N, omega, m_p = params\n        particle_positions = all_positions[i]\n        \n        r_pic, r_flip = run_simulation(N, omega, particle_positions, m_p)\n        \n        results.append(r_pic)\n        results.append(r_flip)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.8f}' for r in results)}]\")\n\nsolve()\n```", "id": "2657769"}, {"introduction": "While MPM excels at problems involving large deformations and contact, implementing non-smooth physics like Coulomb friction presents significant numerical challenges. A naive explicit update often leads to \"numerical chatter,\" a high-frequency, non-physical oscillation between sticking and slipping states that can compromise a simulation's validity. This practical exercise tasks you with analyzing and resolving this common numerical pathology, guiding you to implement a regularized friction model that ensures stable and realistic results in contact simulations [@problem_id:2657740].", "problem": "Consider a single material point representing a rigid block of mass $m$ sliding on a rigid horizontal plane under gravity acceleration $g$, with Coulomb friction coefficient $\\mu$. Let the block have tangential velocity $v(t)$ along the plane and be subject to a prescribed external tangential force $f_{\\mathrm{ext}}(t)$, while the normal reaction is $N = m g$. Assume the Material Point Method (MPM) contact update is performed in a velocity-impulse manner on a uniform time grid with step $\\Delta t$, using an explicit update of the external force followed by a frictional correction at each time step. All physical quantities must be expressed in the International System of Units (meter, kilogram, second). The requested outputs (transition counts) are integers and thus unitless.\n\nStarting from the second law of dynamics (Newton's law) and the definition of Coulomb friction, do the following:\n\n1) Derive, from first principles, a discrete-time explicit contact update that models ideal Coulomb stick-slip at the velocity-impulse level. Let $t_n = n \\Delta t$ and $v_n \\equiv v(t_n)$. Define a velocity prediction without friction by $v_n^{\\star} = v_n + \\frac{f_{\\mathrm{ext}}(t_n)}{m} \\Delta t$. Use the fact that an admissible friction impulse magnitude is at most $\\mu N \\Delta t = \\mu m g \\Delta t$. Show that the ideal Coulomb decision at each time step $n$ can be formulated as a comparison between the impulse required to stop slip, $J_{\\mathrm{req}} = m \\lvert v_n^{\\star}\\rvert$, and the maximum admissible friction impulse $J_{\\max} = \\mu m g \\Delta t$. If $J_{\\max} \\ge J_{\\mathrm{req}}$ the update enforces sticking ($v_{n+1} = 0$ with a friction force that exactly cancels motion over the step); otherwise sliding occurs with $v_{n+1} = v_n^{\\star} - \\operatorname{sign}(v_n^{\\star})\\, \\mu g \\Delta t$. Provide a clear derivation of these conditions starting from $m \\frac{dv}{dt} = f_{\\mathrm{ext}}(t) + f_{\\mathrm{fr}}(t)$ and Coulomb friction $\\lvert f_{\\mathrm{fr}} \\rvert \\le \\mu N$, with $f_{\\mathrm{fr}} = -\\mu N\\, \\operatorname{sign}(v)$ in slip.\n\n2) Analyze why numerical chatter (high-frequency stick-slip toggling) can occur near the stick-slip transition in this explicit decision model when the external force magnitude is close to the Coulomb threshold $\\mu N$. Your analysis must reason from the discontinuity implied by the Coulomb law and the discrete-time decision $J_{\\max} \\gtrless J_{\\mathrm{req}}$, without invoking any empirical fix.\n\n3) Propose and justify a smooth regularization that mitigates chatter by making the tangential traction a smooth function of slip rate. One acceptable choice is a rate-regularized Coulomb model:\n$$\nf_{\\mathrm{fr}}^{\\mathrm{reg}}(v) \\;=\\; -\\, \\mu\\, m\\, g \\; \\tanh\\!\\left(\\frac{\\lvert v \\rvert}{v_0}\\right)\\, \\operatorname{sign}(v),\n$$\nwhere $v_0  0$ is a small regularization speed. Derive the corresponding explicit update that first applies the external-force step and then applies the regularized friction force, starting from $m \\frac{dv}{dt} = f_{\\mathrm{ext}}(t) + f_{\\mathrm{fr}}^{\\mathrm{reg}}(v)$ and using explicit time stepping. Define a binary “slip-like” state for the regularized model as $s_n^{\\mathrm{reg}} = 1$ if $\\lvert f_{\\mathrm{fr}}^{\\mathrm{reg}}\\rvert \\ge \\gamma \\, \\mu m g$ and $s_n^{\\mathrm{reg}} = 0$ otherwise, for a fixed threshold factor $\\gamma \\in (0,1)$, and explain how this provides a consistent basis to count state transitions under regularization.\n\n4) Implement both the ideal Coulomb and the regularized updates as a program that simulates the block over a time horizon $T$, with initial condition $v(0) = 0$. For each time step, classify the state as “stick” ($s_n = 0$) or “slip” ($s_n = 1$) for the ideal Coulomb model according to the derived impulse comparison, and as “stick-like” or “slip-like” for the regularized model using the derived threshold criterion with a specified $\\gamma$. Count the total number of state transitions for each model over the simulation, where a transition is a change between $0$ and $1$ in consecutive time steps.\n\nYour program must implement the following test suite. In each test, use the external forcing\n$$\nf_{\\mathrm{ext}}(t) \\;=\\; A \\, \\sin\\!\\left(2\\pi f\\, t\\right) \\;+\\; \\varepsilon \\, \\sin\\!\\left(2\\pi f_h\\, t\\right),\n$$\nwith $A = \\alpha \\, \\mu m g$ and $\\varepsilon = \\eta \\, \\mu m g$. For all tests, set $m = 1.0$ kilogram, $\\mu = 0.4$ (dimensionless), $g = 9.81$ meter per second squared, $f = 5.0$ hertz, $f_h = 400.0$ hertz, and $\\gamma = 0.95$. The time horizon is $T$ seconds and the time step is $\\Delta t$ seconds as specified per test. The regularization speed is $v_0$ meters per second as specified per test. Initial velocity is $v(0) = 0$ meter per second.\n\n- Test $1$ (near-threshold with small high-frequency perturbation, moderate time step): $\\alpha = 1.0$, $\\eta = 0.02$, $\\Delta t = 0.001$, $T = 0.5$, $v_0 = 0.02$.\n\n- Test $2$ (above-threshold, no perturbation, fine time step): $\\alpha = 1.1$, $\\eta = 0.0$, $\\Delta t = 0.0005$, $T = 0.5$, $v_0 = 0.02$.\n\n- Test $3$ (near-threshold with stronger high-frequency perturbation, coarse time step): $\\alpha = 1.0$, $\\eta = 0.05$, $\\Delta t = 0.002$, $T = 0.5$, $v_0 = 0.02$.\n\nFor each test, the program must output a list of two integers $[n_{\\mathrm{Coulomb}}, n_{\\mathrm{reg}}]$, where $n_{\\mathrm{Coulomb}}$ is the total number of stick-slip transitions under the ideal Coulomb decision model, and $n_{\\mathrm{reg}}$ is the total number of stick-like/slip-like transitions under the regularized model with the chosen $\\gamma$. Your program should produce a single line of output containing the results for all three tests as a comma-separated list enclosed in square brackets, for example, $[[x_1,y_1],[x_2,y_2],[x_3,y_3]]$, where each $x_i$ and $y_i$ are integers. No additional text should be printed.", "solution": "The problem statement is scientifically sound, well-posed, and contains all necessary information for a complete solution. It poses a standard, non-trivial problem in computational mechanics concerning the numerical treatment of friction. Therefore, the problem is valid.\n\nThe solution is presented in four parts as requested by the problem statement.\n\n**1) Derivation of the Ideal Coulomb Contact Update**\n\nThe motion of the material point is governed by Newton's second law in one dimension:\n$$\nm \\frac{dv}{dt} = f_{\\mathrm{ext}}(t) + f_{\\mathrm{fr}}(t)\n$$\nwhere $m$ is the mass, $v(t)$ is the velocity, $f_{\\mathrm{ext}}(t)$ is the external tangential force, and $f_{\\mathrm{fr}}(t)$ is the friction force. The Coulomb friction model provides the constitutive law for $f_{\\mathrm{fr}}$. It states that the magnitude of the friction force is bounded by the maximum static friction, $\\lvert f_{\\mathrm{fr}} \\rvert \\le \\mu N$, where $\\mu$ is the friction coefficient and $N$ is the normal force. For a block on a horizontal plane, $N = m g$.\n\nThe model distinguishes between two states:\n-   **Stick**: If the block is not moving ($v = 0$) and the magnitude of the required friction force to prevent motion is less than or equal to the maximum static friction, i.e., $\\lvert f_{\\mathrm{ext}} \\rvert \\le \\mu N$. In this case, the friction force exactly balances the external force, $f_{\\mathrm{fr}} = -f_{\\mathrm{ext}}$, resulting in zero net force and continued zero velocity.\n-   **Slip**: If the block is moving ($v \\neq 0$), the friction force becomes kinetic, opposing the motion with its maximum possible magnitude: $f_{\\mathrm{fr}} = - \\mu N \\operatorname{sign}(v)$.\n\nWe are asked to derive a discrete-time explicit update using a velocity-impulse formulation. Let us discretize time with a step $\\Delta t$, with $t_n = n \\Delta t$ and $v_n = v(t_n)$. We use an operator-splitting approach where the external force and friction are applied sequentially.\n\nFirst, we calculate a predictor velocity, $v_n^{\\star}$, by integrating the effect of only the external force over the time step $[t_n, t_{n+1}]$. Using an explicit (forward Euler) integration:\n$$\nm(v_n^{\\star} - v_n) = \\int_{t_n}^{t_{n+1}} f_{\\mathrm{ext}}(t) dt \\approx f_{\\mathrm{ext}}(t_n) \\Delta t\n$$\nThis gives the prescribed predictor velocity:\n$$\nv_n^{\\star} = v_n + \\frac{f_{\\mathrm{ext}}(t_n)}{m} \\Delta t\n$$\nThis velocity $v_n^{\\star}$ represents the velocity the point would have at time $t_{n+1}$ in the absence of friction.\n\nNext, we apply a frictional correction as an impulse, $J_{\\mathrm{fr}}$, to obtain the final velocity $v_{n+1}$:\n$$\nv_{n+1} = v_n^{\\star} + \\frac{J_{\\mathrm{fr}}}{m}\n$$\nTo determine $J_{\\mathrm{fr}}$, we enforce the Coulomb conditions at the impulse level. The ideal scenario is to stick, meaning $v_{n+1} = 0$. The impulse required to achieve this is found by setting $v_{n+1}=0$ in the equation above:\n$$\n0 = v_n^{\\star} + \\frac{J_{\\mathrm{req}}}{m} \\implies J_{\\mathrm{req}} = -m v_n^{\\star}\n$$\nThe magnitude of this required impulse is $J_{\\mathrm{req}} = \\lvert -m v_n^{\\star} \\rvert = m \\lvert v_n^{\\star} \\rvert$.\n\nHowever, the friction impulse is limited. The maximum magnitude of the friction force is $\\mu N = \\mu m g$. Over a time step $\\Delta t$, the maximum available friction impulse magnitude is:\n$$\nJ_{\\max} = (\\mu N) \\Delta t = \\mu m g \\Delta t\n$$\nThe decision logic follows from comparing the required impulse to the available impulse:\n\n-   **Stick Condition**: If the required impulse magnitude is less than or equal to the maximum available impulse ($J_{\\mathrm{req}} \\le J_{\\max}$), the surface can provide the necessary impulse to enforce sticking.\n    $$\n    m \\lvert v_n^{\\star} \\rvert \\le \\mu m g \\Delta t\n    $$\n    In this case, the friction impulse is exactly what is required to stop the motion, $J_{\\mathrm{fr}} = J_{\\mathrm{req}} = -m v_n^{\\star}$, and the final velocity is $v_{n+1} = 0$.\n\n-   **Slip Condition**: If the required impulse magnitude exceeds the maximum available impulse ($J_{\\mathrm{req}}  J_{\\max}$), the surface cannot prevent slip.\n    $$\n    m \\lvert v_n^{\\star} \\rvert  \\mu m g \\Delta t\n    $$\n    In this case, friction acts at its maximum capacity, opposing the predicted motion. The direction of the predicted motion is given by $\\operatorname{sign}(v_n^{\\star})$. The friction impulse is therefore:\n    $$\n    J_{\\mathrm{fr}} = -J_{\\max} \\operatorname{sign}(v_n^{\\star}) = - \\mu m g \\Delta t \\operatorname{sign}(v_n^{\\star})\n    $$\n    The final velocity is then:\n    $$\n    v_{n+1} = v_n^{\\star} + \\frac{J_{\\mathrm{fr}}}{m} = v_n^{\\star} - \\frac{\\mu m g \\Delta t \\operatorname{sign}(v_n^{\\star})}{m} = v_n^{\\star} - \\mu g \\Delta t \\operatorname{sign}(v_n^{\\star})\n    $$\nThis completes the derivation of the specified discrete-time explicit contact update.\n\n**2) Analysis of Numerical Chatter**\n\nNumerical chatter is the non-physical, high-frequency oscillation between stick and slip states that can occur in numerical simulations of friction. Its origin in the derived explicit model lies in the combination of time discretization and the discontinuous nature of the ideal Coulomb friction law.\n\nThe decision rule, $J_{\\mathrm{req}} \\gtrless J_{\\max}$, is a sharp, binary switch. Let's analyze the behavior when the external force magnitude is close to the static friction limit, $\\lvert f_{\\mathrm{ext}} \\rvert \\approx \\mu m g$.\nConsider the system in a stick state at time $t_n$, so $v_n = 0$. The predictor velocity is $v_n^{\\star} = \\frac{f_{\\mathrm{ext}}(t_n)}{m} \\Delta t$. The stick condition $m \\lvert v_n^{\\star} \\rvert \\le \\mu m g \\Delta t$ simplifies to $\\lvert f_{\\mathrm{ext}}(t_n) \\rvert \\le \\mu m g$.\n\nNow, suppose the external force slightly exceeds this threshold: $\\lvert f_{\\mathrm{ext}}(t_n) \\rvert = \\mu m g + \\delta$, where $\\delta  0$ is a small quantity. The stick condition is violated, and the system transitions to a slip step:\n$$\nv_{n+1} = v_n^{\\star} - \\mu g \\Delta t \\operatorname{sign}(v_n^{\\star}) = \\frac{f_{\\mathrm{ext}}(t_n)}{m}\\Delta t - \\mu g \\Delta t \\operatorname{sign}\\left(\\frac{f_{\\mathrm{ext}}(t_n)}{m}\\Delta t\\right)\n$$\nSince $\\operatorname{sign}(f_{\\mathrm{ext}}(t_n)) = \\operatorname{sign}(v_n^{\\star})$, this becomes:\n$$\nv_{n+1} = \\left( \\frac{\\lvert f_{\\mathrm{ext}}(t_n) \\rvert}{m} - \\mu g \\right) \\Delta t \\operatorname{sign}(v_n^{\\star}) = \\frac{\\delta}{m} \\Delta t \\operatorname{sign}(v_n^{\\star})\n$$\nThe velocity $v_{n+1}$ is small but non-zero.\n\nAt the next step, $t_{n+1}$, let's assume the external force $f_{\\mathrm{ext}}(t_{n+1})$ is still close to the threshold and may even have changed sign or magnitude due to its oscillatory nature. We compute the new predictor velocity:\n$$\nv_{n+1}^{\\star} = v_{n+1} + \\frac{f_{\\mathrm{ext}}(t_{n+1})}{m} \\Delta t\n$$\nThe explicit update applies the full kinetic friction impulse for the entire duration $\\Delta t$. This can lead to an \"overshoot\". For example, if $f_{\\mathrm{ext}}$ returns to a value slightly below the threshold, the kinetic friction impulse applied in the previous step might be too large, causing $v_{n+1}$ to \"overshoot\" zero. The new predictor $v_{n+1}^{\\star}$ could then become very small or even switch sign. If it becomes small enough such that $m \\lvert v_{n+1}^{\\star} \\rvert \\le \\mu m g \\Delta t$, the algorithm will decide to stick again, setting $v_{n+2} = 0$.\n\nThis sequence—stick $\\to$ slip $\\to$ stick—over a few time steps is numerical chatter. The core issue is the hard switch from a static friction condition to a full kinetic friction force. The explicit numerical scheme cannot resolve the transition smoothly and overcorrects, being driven back and forth across the discontinuity by the discrete decision logic. The presence of a high-frequency component in $f_{\\mathrm{ext}}(t)$ exacerbates this by causing the net force to rapidly cross the stability threshold $\\mu m g$, continuously triggering the unstable dynamics of the numerical switch.\n\n**3) Smooth Regularization**\n\nTo mitigate chatter, we can replace the discontinuous Coulomb law with a smooth, regularized model. The proposed rate-regularized model is:\n$$\nf_{\\mathrm{fr}}^{\\mathrm{reg}}(v) \\;=\\; -\\, \\mu\\, m\\, g \\; \\tanh\\!\\left(\\frac{\\lvert v \\rvert}{v_0}\\right)\\, \\operatorname{sign}(v)\n$$\nwhere $v_0  0$ is a small regularization speed.\nThis function is continuous and smooth. For small slip rates ($\\lvert v \\rvert \\ll v_0$), we have $\\tanh(x) \\approx x$, so $f_{\\mathrm{fr}}^{\\mathrm{reg}}(v) \\approx -\\frac{\\mu m g}{v_0} v$, which is a form of viscous damping. For large slip rates ($\\lvert v \\rvert \\gg v_0$), $\\tanh(\\dots) \\to 1$, and we recover the ideal kinetic friction, $f_{\\mathrm{fr}}^{\\mathrm{reg}}(v) \\to - \\mu m g \\operatorname{sign}(v)$. The parameter $v_0$ controls the steepness of the transition between the stick-like (viscous) and slip-like (saturated) regimes. By removing the discontinuity at $v=0$, the model eliminates the source of the numerical instability.\n\nThe corresponding explicit update is derived from $m \\frac{dv}{dt} = f_{\\mathrm{ext}}(t) + f_{\\mathrm{fr}}^{\\mathrm{reg}}(v)$. Using the same operator-splitting scheme as before:\n1. Predictor step (external force):\n   $$\n   v_n^{\\star} = v_n + \\frac{f_{\\mathrm{ext}}(t_n)}{m} \\Delta t\n   $$\n2. Corrector step (regularized friction): The frictional impulse is calculated using the updated velocity $v_n^{\\star}$ to define the friction force for the interval.\n   $$\n   J_{\\mathrm{fr}}^{\\mathrm{reg}} = f_{\\mathrm{fr}}^{\\mathrm{reg}}(v_n^{\\star}) \\Delta t = - \\mu m g \\tanh\\left(\\frac{\\lvert v_n^{\\star} \\rvert}{v_0}\\right) \\operatorname{sign}(v_n^{\\star}) \\Delta t\n   $$\n   The final velocity is:\n   $$\n   v_{n+1} = v_n^{\\star} + \\frac{J_{\\mathrm{fr}}^{\\mathrm{reg}}}{m} = v_n^{\\star} - \\mu g \\Delta t \\tanh\\left(\\frac{\\lvert v_n^{\\star} \\rvert}{v_0}\\right) \\operatorname{sign}(v_n^{\\star})\n   $$\nIn the regularized model, the velocity is rarely exactly zero. To create a comparable metric for stick/slip states, we define a \"slip-like\" state based on how close the friction force is to its saturation value, $\\mu m g$. A slip-like state $s_n^{\\mathrm{reg}} = 1$ is declared if the magnitude of the friction force at time $t_n$ reaches a significant fraction $\\gamma$ of its maximum:\n$$\n\\lvert f_{\\mathrm{fr}}^{\\mathrm{reg}}(v_n) \\rvert \\ge \\gamma \\mu m g\n$$\nSubstituting the definition of the force and simplifying gives the condition on velocity $v_n$:\n$$\n\\mu m g \\tanh\\left(\\frac{\\lvert v_n \\rvert}{v_0}\\right) \\ge \\gamma \\mu m g \\implies \\tanh\\left(\\frac{\\lvert v_n \\rvert}{v_0}\\right) \\ge \\gamma\n$$\nIf this condition is met, $s_n^{\\mathrm{reg}} = 1$; otherwise, the state is \"stick-like\", $s_n^{\\mathrm{reg}} = 0$. This provides a consistent basis for counting transitions because it maps the continuous velocity space onto a binary state classification that mirrors the physics: \"stick-like\" corresponds to the steep, viscous part of the friction curve, while \"slip-like\" corresponds to the saturated, Coulomb-like part.\n\n**4) Program Implementation**\n\nThe logic derived in the previous sections is implemented in the Python code provided in the final answer. The program simulates both the ideal Coulomb and regularized models for the three specified test cases, counts the state transitions for each, and outputs the results in the required format.", "answer": "```python\nimport numpy as np\n\ndef simulate(m, mu, g, alpha, eta, f, f_h, T, dt, v0, gamma):\n    \"\"\"\n    Simulates the sliding block problem for both ideal Coulomb and regularized models.\n    \"\"\"\n    num_steps = int(T / dt)\n    \n    # Pre-calculate force constants\n    mu_m_g = mu * m * g\n    A = alpha * mu_m_g\n    epsilon = eta * mu_m_g\n    \n    # Initialize velocities\n    v_coulomb = 0.0\n    v_reg = 0.0\n    \n    # Store state sequences (0 for stick/stick-like, 1 for slip/slip-like)\n    coulomb_states = []\n    reg_states = []\n\n    for n in range(num_steps):\n        t_n = n * dt\n        f_ext = A * np.sin(2 * np.pi * f * t_n) + epsilon * np.sin(2 * np.pi * f_h * t_n)\n\n        # ---- Ideal Coulomb Model ----\n        v_star_coulomb = v_coulomb + (f_ext / m) * dt\n        j_req = m * abs(v_star_coulomb)\n        j_max = mu_m_g * dt\n        \n        current_coulomb_state = 0\n        if j_req = j_max:\n            # Stick step\n            v_next_coulomb = 0.0\n            current_coulomb_state = 0\n        else:\n            # Slip step\n            v_next_coulomb = v_star_coulomb - np.sign(v_star_coulomb) * mu * g * dt\n            current_coulomb_state = 1\n        \n        coulomb_states.append(current_coulomb_state)\n        v_coulomb = v_next_coulomb\n\n        # ---- Regularized Model ----\n        # State is determined based on velocity at the start of the step\n        current_reg_state = 0\n        if v0 > 0:\n            if np.tanh(abs(v_reg) / v0) >= gamma:\n                current_reg_state = 1\n            else:\n                current_reg_state = 0\n        reg_states.append(current_reg_state)\n        \n        # Update velocity for the next step\n        v_star_reg = v_reg + (f_ext / m) * dt\n        if v0 > 0:\n            friction_term = mu * g * dt * np.tanh(abs(v_star_reg) / v0) * np.sign(v_star_reg)\n        else: # Handle v0=0 case to avoid division by zero, though not used in tests\n            friction_term = mu * g * dt * np.sign(v_star_reg)\n\n        v_next_reg = v_star_reg - friction_term\n        v_reg = v_next_reg\n\n    # Count transitions\n    n_coulomb = 0\n    for i in range(len(coulomb_states) - 1):\n        if coulomb_states[i] != coulomb_states[i+1]:\n            n_coulomb += 1\n            \n    n_reg = 0\n    for i in range(len(reg_states) - 1):\n        if reg_states[i] != reg_states[i+1]:\n            n_reg += 1\n    \n    return [n_coulomb, n_reg]\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Common parameters for all tests\n    m = 1.0     # kg\n    mu = 0.4    # dimensionless\n    g = 9.81    # m/s^2\n    f = 5.0     # Hz\n    f_h = 400.0 # Hz\n    gamma = 0.95 # dimensionless\n\n    test_cases = [\n        # (alpha, eta, dt, T, v0)\n        # Test 1: Near-threshold with small high-frequency perturbation, moderate time step\n        (1.0, 0.02, 0.001, 0.5, 0.02),\n        # Test 2: Above-threshold, no perturbation, fine time step\n        (1.1, 0.0, 0.0005, 0.5, 0.02),\n        # Test 3: Near-threshold with stronger high-frequency perturbation, coarse time step\n        (1.0, 0.05, 0.002, 0.5, 0.02),\n    ]\n\n    results = []\n    for case in test_cases:\n        alpha, eta, dt, T, v0 = case\n        result = simulate(m, mu, g, alpha, eta, f, f_h, T, dt, v0, gamma)\n        results.append(result)\n\n    # Format output as specified: [[x1,y1],[x2,y2],[x3,y3]]\n    print(str(results).replace(\" \", \"\"))\n\nsolve()\n```", "id": "2657740"}]}