{"hands_on_practices": [{"introduction": "The heart of the Finite Element Method (FEM) lies in its ability to build a model of a complex structure from simple, well-understood components. This first exercise guides you through the foundational process of assembling a global stiffness matrix from individual element matrices. By manually combining the contributions of two simple one-dimensional elements, you will gain a concrete understanding of how local stiffness properties are superimposed to describe the behavior of the entire system [@problem_id:2115177]. This \"direct stiffness\" method is the cornerstone of virtually all FEM software.", "problem": "Consider a one-dimensional mechanical system modeled with two distinct elements and three nodes, labeled 1, 2, and 3 in order.\n- Element (1) connects Node 1 and Node 2. Its behavior is described by a 2x2 element stiffness matrix, $k^{(1)}$, which relates the forces and displacements at its two nodes.\n- Element (2) connects Node 2 and Node 3. Its behavior is described by a 2x2 element stiffness matrix, $k^{(2)}$.\n\nThe given element stiffness matrices are:\n$$ k^{(1)} = \\begin{pmatrix} k_1 & -k_1 \\\\ -k_1 & k_1 \\end{pmatrix} \\quad \\text{and} \\quad k^{(2)} = \\begin{pmatrix} k_2 & -k_2 \\\\ -k_2 & k_2 \\end{pmatrix} $$\nHere, $k_1$ and $k_2$ are positive real constants representing the stiffness of each element.\n\nAssemble the 3x3 global stiffness matrix, $K$, for the entire three-node system. The global matrix relates the vector of global nodal forces, $F = (F_1, F_2, F_3)^T$, to the vector of global nodal displacements, $U = (u_1, u_2, u_3)^T$, through the equation $F = KU$.\n\nExpress your answer as a 3x3 matrix in terms of $k_1$ and $k_2$.", "solution": "We assemble the global stiffness matrix by superposition of element contributions using the standard finite element assembly principle. Let the global displacement vector be $U = (u_{1}, u_{2}, u_{3})^{T}$ and the global force vector be $F = (F_{1}, F_{2}, F_{3})^{T}$. For each element $(e)$ with local displacement vector $U^{(e)}$ and element stiffness matrix $k^{(e)}$, the contribution to the global stiffness matrix is formed via connectivity matrices $A^{(e)}$ such that $U^{(e)} = A^{(e)} U$ and\n$$\nK = \\sum_{e} A^{(e) T} k^{(e)} A^{(e)}.\n$$\n\nFor element $(1)$ connecting nodes $1$ and $2$, the connectivity matrix is\n$$\nA^{(1)} = \\begin{pmatrix} 1 & 0 & 0 \\\\ 0 & 1 & 0 \\end{pmatrix}, \\quad k^{(1)} = \\begin{pmatrix} k_{1} & -k_{1} \\\\ -k_{1} & k_{1} \\end{pmatrix}.\n$$\nCompute\n$$\nk^{(1)} A^{(1)} = \\begin{pmatrix} k_{1} & -k_{1} \\\\ -k_{1} & k_{1} \\end{pmatrix} \\begin{pmatrix} 1 & 0 & 0 \\\\ 0 & 1 & 0 \\end{pmatrix} = \\begin{pmatrix} k_{1} & -k_{1} & 0 \\\\ -k_{1} & k_{1} & 0 \\end{pmatrix},\n$$\nthen\n$$\nK^{(1)} = A^{(1) T} \\left(k^{(1)} A^{(1)}\\right) = \\begin{pmatrix} 1 & 0 \\\\ 0 & 1 \\\\ 0 & 0 \\end{pmatrix} \\begin{pmatrix} k_{1} & -k_{1} & 0 \\\\ -k_{1} & k_{1} & 0 \\end{pmatrix} = \\begin{pmatrix} k_{1} & -k_{1} & 0 \\\\ -k_{1} & k_{1} & 0 \\\\ 0 & 0 & 0 \\end{pmatrix}.\n$$\n\nFor element $(2)$ connecting nodes $2$ and $3$, the connectivity matrix is\n$$\nA^{(2)} = \\begin{pmatrix} 0 & 1 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix}, \\quad k^{(2)} = \\begin{pmatrix} k_{2} & -k_{2} \\\\ -k_{2} & k_{2} \\end{pmatrix}.\n$$\nCompute\n$$\nk^{(2)} A^{(2)} = \\begin{pmatrix} k_{2} & -k_{2} \\\\ -k_{2} & k_{2} \\end{pmatrix} \\begin{pmatrix} 0 & 1 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix} = \\begin{pmatrix} 0 & k_{2} & -k_{2} \\\\ 0 & -k_{2} & k_{2} \\end{pmatrix},\n$$\nthen\n$$\nK^{(2)} = A^{(2) T} \\left(k^{(2)} A^{(2)}\\right) = \\begin{pmatrix} 0 & 0 \\\\ 1 & 0 \\\\ 0 & 1 \\end{pmatrix} \\begin{pmatrix} 0 & k_{2} & -k_{2} \\\\ 0 & -k_{2} & k_{2} \\end{pmatrix} = \\begin{pmatrix} 0 & 0 & 0 \\\\ 0 & k_{2} & -k_{2} \\\\ 0 & -k_{2} & k_{2} \\end{pmatrix}.\n$$\n\nSumming the element contributions gives the global stiffness matrix\n$$\nK = K^{(1)} + K^{(2)} = \\begin{pmatrix} k_{1} & -k_{1} & 0 \\\\ -k_{1} & k_{1} + k_{2} & -k_{2} \\\\ 0 & -k_{2} & k_{2} \\end{pmatrix}.\n$$\nThis $K$ satisfies $F = K U$ for the three-node system.", "answer": "$$\\boxed{\\begin{pmatrix} k_{1} & -k_{1} & 0 \\\\ -k_{1} & k_{1}+k_{2} & -k_{2} \\\\ 0 & -k_{2} & k_{2} \\end{pmatrix}}$$", "id": "2115177"}, {"introduction": "After assembling a global stiffness matrix, a crucial question arises: what does this matrix tell us about the physical system? This practice explores a fundamental property of the matrix for any structure that is not held in place. Through a conceptual thought experiment, you will connect the mathematical concept of a singular matrix to the physical reality of rigid-body motion [@problem_id:2172618]. Understanding this connection is vital, as it explains why applying displacement boundary conditions is a physical necessity for solving static problems and obtaining a unique, stable solution.", "problem": "An engineering student is writing a program to perform structural analysis using the Finite Element Method (FEM). The program's goal is to solve the static equilibrium equation $\\mathbf{K}\\mathbf{u} = \\mathbf{f}$, where $\\mathbf{K}$ is the global stiffness matrix, $\\mathbf{u}$ is the vector of nodal displacements, and $\\mathbf{f}$ is the vector of applied nodal forces. The student first assembles the global stiffness matrix $\\mathbf{K}$ for a free-floating elastic beam in three-dimensional space but has not yet applied any supports or displacement boundary conditions. When they test their code by attempting to find the inverse of $\\mathbf{K}$, the program fails, correctly identifying the matrix as singular.\n\nWhich of the following statements provides the correct physical explanation for why the global stiffness matrix $\\mathbf{K}$ of an unconstrained structure must be singular?\n\nA. The structure can undergo rigid-body motion (translation and rotation) without developing any internal stresses or strains.\n\nB. Numerical round-off errors accumulated during the matrix assembly process cause its determinant to become exactly zero.\n\nC. The external force vector $\\mathbf{f}$ is currently a zero vector, and a linear system with a zero right-hand side always has a singular matrix.\n\nD. The material properties, such as Young's modulus and Poisson's ratio, have not yet been specified, leaving the matrix elements undefined.\n\nE. The discretization of the continuous beam into a finite number of elements is an approximation that introduces an inherent singularity into the model.", "solution": "We start from the linear elastic finite element equilibrium equation $\\mathbf{K}\\mathbf{u}=\\mathbf{f}$, where the global stiffness matrix $\\mathbf{K}$ is assembled from element contributions. In standard small-strain linear elasticity, the stiffness is derived from the strain energy. The strain induced by nodal displacements $\\mathbf{u}$ is $\\boldsymbol{\\epsilon}=\\mathbf{B}\\mathbf{u}$, and the stress is $\\boldsymbol{\\sigma}=\\mathbf{D}\\boldsymbol{\\epsilon}$, where $\\mathbf{B}$ is the strain-displacement matrix and $\\mathbf{D}$ is the constitutive (material) matrix.\n\nFor any rigid-body motion in three-dimensional space, the displacement field produces no strain by definition. If $\\mathbf{u}_{\\mathrm{rb}}$ corresponds to a rigid-body translation or rotation of the entire unconstrained structure, then the resulting strain is zero:\n$$\n\\boldsymbol{\\epsilon} = \\mathbf{B}\\mathbf{u}_{\\mathrm{rb}} = \\mathbf{0}\n\\quad \\Rightarrow \\quad\n\\boldsymbol{\\sigma} = \\mathbf{D}\\boldsymbol{\\epsilon} = \\mathbf{0}.\n$$\nThis means that rigid-body motion induces no stress. The action of the stiffness matrix on this displacement vector, which represents the nodal forces required to sustain the displacement, must also be zero:\n$$\n\\mathbf{K}\\mathbf{u}_{\\mathrm{rb}} = \\mathbf{0}.\n$$\nHence, every nontrivial rigid-body mode $\\mathbf{u}_{\\mathrm{rb}}\\neq\\mathbf{0}$ lies in the null space of $\\mathbf{K}$. Equivalently, the strain energy\n$$\nU(\\mathbf{u}) = \\tfrac{1}{2}\\mathbf{u}^{T}\\mathbf{K}\\mathbf{u} = \\tfrac{1}{2}\\int_{\\Omega} \\boldsymbol{\\epsilon}^{T}\\mathbf{D}\\boldsymbol{\\epsilon}\\,d\\Omega\n$$\nvanishes for rigid-body motions, so they are zero-energy modes. The existence of at least one nonzero vector in the null space implies that $\\mathbf{K}$ is singular. For a free 3D body, there are six independent rigid-body modes (three translations and three rotations), so the nullity of $\\mathbf{K}$ is at least six.\n\nTherefore, the correct physical explanation is that an unconstrained structure admits rigid-body motions that do not induce strain or stress, yielding zero-energy modes and thus a singular stiffness matrix.\n\nWhy the other options are incorrect:\n- B: Round-off errors do not systematically produce an exactly zero determinant; singularity is a physical property due to zero-energy modes, not a numerical accident.\n- C: A zero right-hand side $\\mathbf{f}=\\mathbf{0}$ does not imply $\\mathbf{K}$ is singular; many nonsingular systems have the unique homogeneous solution $\\mathbf{u}=\\mathbf{0}$.\n- D: While missing material properties would prevent forming $\\mathbf{K}$, once the material matrix $\\mathbf{D}$ is defined, singularity arises from the lack of boundary conditions, not from undefined entries.\n- E: Discretization does not inherently cause singularity; with appropriate displacement boundary conditions, the assembled matrix $\\mathbf{K}$ becomes positive definite (and thus invertible) after proper constraint handling.", "answer": "$$\\boxed{A}$$", "id": "2172618"}, {"introduction": "While manual assembly is insightful for small systems, real-world engineering problems require automation. This hands-on coding practice challenges you to generalize the assembly logic into a programmable algorithm [@problem_id:2378075]. By writing a program that systematically maps local element degrees of freedom to their correct positions in the global stiffness matrix, you will bridge the gap between theoretical concepts and practical computational implementation. This exercise solidifies your understanding of the assembly process and is a key step towards building your own finite element analysis tools.", "problem": "You are asked to implement a complete, runnable program that assembles the global stiffness matrix for linear elasticity from given element stiffness matrices and a connectivity array. The assembly must follow first principles of computational solid mechanics and linear elasticity and reflect how discrete equilibrium equations are constructed from contributions of each finite element.\n\nYour implementation must be based on the following fundamental base only:\n- The principle of virtual work, which, upon spatial discretization with suitable shape functions, leads to a linear system of the form $K u = f$, where $K$ is the global stiffness matrix, $u$ is the global displacement vector, and $f$ is the global force vector.\n- The definition of degrees of freedom (DOFs) per node, and the notion that each element contributes a local stiffness matrix that couples only the DOFs of its own nodes.\n\nDo not use any pre-derived assembly \"shortcut\" formula in the problem statement. Instead, infer from the above foundational principles that the global stiffness matrix emerges by summing, at the correct global DOF positions, all element contributions that act on the same global DOFs.\n\nYour program must:\n- Accept, as hard-coded data inside the program, a list of test cases. Each test case specifies:\n  - The number of nodes $N_{\\text{nodes}}$.\n  - The number of degrees of freedom per node $n_{\\text{dof}}$.\n  - A connectivity array listing, for each element, the global node indices that it connects. Node indices are zero-based.\n  - A list of element stiffness matrices $K_e$ of appropriate size, one per element, given in the International System of Units (SI) as newtons per meter ($\\mathrm{N/m}$). The global stiffness matrix must also be in $\\mathrm{N/m}$, but you must output the entries as pure numbers without printing units.\n- Map element-level DOFs to global DOFs using the definition that the $d$-th DOF ($d \\in \\{0,\\dots,n_{\\text{dof}}-1\\}$) of node $n$ corresponds to the global index $g = n \\cdot n_{\\text{dof}} + d$.\n- Assemble the global stiffness matrix by adding each elementâ€™s local stiffness matrix entries into their corresponding positions in the global matrix according to the connectivity mapping.\n- Produce, for each test case, the full assembled global stiffness matrix, flattened row-major into a single list of numbers.\n\nTest Suite (all stiffness values are in $\\mathrm{N/m}$; print raw numbers without the unit):\n\n- Test Case $1$ (one-dimensional bar elements, \"happy path\"):\n  - $N_{\\text{nodes}} = 3$, $n_{\\text{dof}} = 1$.\n  - Connectivity: two elements with node pairs $\\big(0,1\\big)$ and $\\big(1,2\\big)$.\n  - Element stiffness matrices:\n    - For element $\\big(0,1\\big)$: $K_e^{(1)} = 10 \\begin{bmatrix} 1 & -1 \\\\ -1 & 1 \\end{bmatrix}$.\n    - For element $\\big(1,2\\big)$: $K_e^{(2)} = 20 \\begin{bmatrix} 1 & -1 \\\\ -1 & 1 \\end{bmatrix}$.\n  - The global stiffness matrix has size $3 \\times 3$ and should be output as $9$ numbers.\n\n- Test Case $2$ (two-dimensional, two degrees of freedom per node, block-structured assembly):\n  - $N_{\\text{nodes}} = 3$, $n_{\\text{dof}} = 2$.\n  - Connectivity: two elements with node pairs $\\big(0,1\\big)$ and $\\big(1,2\\big)$.\n  - Element stiffness matrices (each $4 \\times 4$) of the form $k \\begin{bmatrix} I & -I \\\\ -I & I \\end{bmatrix}$, where $I$ is the $2 \\times 2$ identity:\n    - For element $\\big(0,1\\big)$: $k = 3$.\n    - For element $\\big(1,2\\big)$: $k = 5$.\n  - The global stiffness matrix has size $6 \\times 6$ and should be output as $36$ numbers.\n\n- Test Case $3$ (one-dimensional bar chain, interior accumulation, boundary condition edge behavior):\n  - $N_{\\text{nodes}} = 4$, $n_{\\text{dof}} = 1$.\n  - Connectivity: three elements with node pairs $\\big(0,1\\big)$, $\\big(1,2\\big)$, and $\\big(2,3\\big)$.\n  - Element stiffness matrices:\n    - $K_e^{(1)} = 2 \\begin{bmatrix} 1 & -1 \\\\ -1 & 1 \\end{bmatrix}$,\n    - $K_e^{(2)} = 4 \\begin{bmatrix} 1 & -1 \\\\ -1 & 1 \\end{bmatrix}$,\n    - $K_e^{(3)} = 6 \\begin{bmatrix} 1 & -1 \\\\ -1 & 1 \\end{bmatrix}$.\n  - The global stiffness matrix has size $4 \\times 4$ and should be output as $16$ numbers.\n\n- Test Case $4$ (nonconsecutive node indices and a $3$-node element):\n  - $N_{\\text{nodes}} = 4$, $n_{\\text{dof}} = 1$.\n  - Connectivity: one element with node triple $\\big(0,2,3\\big)$.\n  - Element stiffness matrix (a symmetric $3 \\times 3$ matrix):\n    - $K_e^{(1)} = \\begin{bmatrix} 2 & -1 & -1 \\\\ -1 & 2 & -1 \\\\ -1 & -1 & 2 \\end{bmatrix}$.\n  - The global stiffness matrix has size $4 \\times 4$ and should be output as $16$ numbers.\n\nFinal Output Format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each item corresponds to one test case and is itself a list of the flattened global stiffness matrix entries in row-major order. For example, a line of the form $\\big[$ list for Test Case $1$, list for Test Case $2$, list for Test Case $3$, list for Test Case $4$ $\\big]$.\n- All numeric outputs must be printed as pure numbers representing $\\mathrm{N/m}$; do not print units, do not round or format in scientific notation unless necessary by the programming language defaults.", "solution": "The problem presented is to construct a global stiffness matrix, a fundamental procedure in the Finite Element Method (FEM) for linear elasticity. This task is not merely an exercise in programming but a direct implementation of the physical principle of superposition within a discretized continuum. The process is rigorously derived from the principle of virtual work, which culminates in a system of linear algebraic equations, $K u = f$.\n\nThe global stiffness matrix, denoted by $K$, relates the vector of global nodal displacements, $u$, to the vector of global nodal forces, $f$. The matrix $K$ encapsulates the stiffness properties of the entire discretized structure. It is formed by the systematic superposition of the stiffness contributions from each individual finite element. The total internal virtual work of a system is the sum of the internal virtual works of its constituent elements. This additivity principle directly translates to the assembly of the global stiffness matrix:\n$$\nK = \\sum_{e} \\mathcal{L}_e^T K_e \\mathcal{L}_e\n$$\nHere, $K_e$ is the stiffness matrix of element $e$ in its own local coordinate system, and $\\mathcal{L}_e$ is a Boolean locator matrix that maps the local degrees of freedom (DOFs) of element $e$ to their corresponding positions in the global system of DOFs. In computational practice, the explicit construction of $\\mathcal{L}_e$ is bypassed in favor of a more efficient direct stiffness assembly algorithm, which is what we will formalize.\n\nThe total number of degrees of freedom, $N_{DOF}$, in the system is the product of the number of nodes, $N_{\\text{nodes}}$, and the number of degrees of freedom per node, $n_{\\text{dof}}$. That is, $N_{DOF} = N_{\\text{nodes}} \\cdot n_{\\text{dof}}$. Consequently, the global stiffness matrix $K$ is a square matrix of size $N_{DOF} \\times N_{DOF}$. We begin by initializing $K$ as a zero matrix of this dimension.\n\nThe core of the assembly algorithm lies in the mapping from an element's local DOF indices to the system's global DOF indices. This mapping is governed by two pieces of information: the element's connectivity array and the defined ordering of DOFs at each node. The problem specifies a standard mapping: the $d$-th DOF (where $d$ is a zero-based index from $0$ to $n_{\\text{dof}}-1$) of global node $n$ corresponds to the global DOF index $g = n \\cdot n_{\\text{dof}} + d$.\n\nLet us consider a single element, $e$, which connects a set of $m$ nodes with global indices $\\{N_1, N_2, \\dots, N_m\\}$. The element stiffness matrix $K_e$ is of size $(m \\cdot n_{\\text{dof}}) \\times (m \\cdot n_{\\text{dof}})$. An entry $K_e[i, j]$ of this matrix represents the coupling between the $i$-th and $j$-th local DOFs of the element. Our objective is to add this contribution to the correct location in the global matrix $K$.\n\nThe local row index $i$ (from $0$ to $m \\cdot n_{\\text{dof}}-1$) corresponds to a specific DOF on a specific node of the element. We can decompose this index into a local node index, $a$, and a local DOF index, $p$, at that node. This is achieved through integer division and the modulo operation:\n- Local node index: $a = \\lfloor i / n_{\\text{dof}} \\rfloor$. Here, $a \\in \\{0, 1, \\dots, m-1\\}$.\n- Local DOF index at the node: $p = i \\pmod{n_{\\text{dof}}}$. Here, $p \\in \\{0, 1, \\dots, n_{\\text{dof}}-1\\}$.\n\nThe connectivity array for element $e$ provides the global node index corresponding to the local node index $a$. Let the connectivity be given as a tuple $(N_1, N_2, \\dots, N_m)$. The global node index, $N_a$, is the $(a+1)$-th entry in this tuple (using 1-based indexing for description, while computation uses 0-based).\n\nUsing the provided global DOF mapping rule, the global row index, $g_r$, corresponding to the local row index $i$ is:\n$$\ng_r = N_a \\cdot n_{\\text{dof}} + p\n$$\nSimilarly, for a local column index $j$, we determine the corresponding global column index, $g_c$:\n- Local node index: $b = \\lfloor j / n_{\\text{dof}} \\rfloor$.\n- Local DOF index: $q = j \\pmod{n_{\\text{dof}}}$.\n- Global node index: $N_b$.\n- Global column index: $g_c = N_b \\cdot n_{\\text{dof}} + q$.\n\nThe assembly rule is therefore the summation of contributions into the global matrix. For each element $e$, and for every entry $K_e[i, j]$ in its local stiffness matrix, we update the global stiffness matrix as follows:\n$$\nK[g_r, g_c] \\leftarrow K[g_r, g_c] + K_e[i, j]\n$$\nThis procedure is repeated for all elements in the mesh. The resulting matrix $K$ correctly represents the combined stiffness of the entire assembly, respecting the connectivity and shared degrees of freedom between elements. Nodes that share an element will have their corresponding entries in $K$ receive contributions from that element's stiffness matrix, correctly coupling their behavior. If a node is part of multiple elements, its diagonal term in the global stiffness matrix accumulates the stiffness contributions from all connected elements, which is a physical necessity.\n\nThe algorithm to be implemented is a direct translation of this logic:\n1.  Determine the total number of degrees of freedom, $N_{DOF} = N_{\\text{nodes}} \\cdot n_{\\text{dof}}$, and initialize the global stiffness matrix $K$ as a zero matrix of size $N_{DOF} \\times N_{DOF}$.\n2.  Iterate through each element $e$ provided in the input.\n3.  For each element, retrieve its connectivity array (the global indices of its nodes) and its element stiffness matrix $K_e$.\n4.  Iterate through each row $i$ and column $j$ of the element stiffness matrix $K_e$.\n5.  For each pair $(i, j)$, calculate the corresponding global row index $g_r$ and global column index $g_c$ using the mapping logic described above.\n6.  Add the value $K_e[i, j]$ to the entry $K[g_r, g_c]$ of the global stiffness matrix.\n7.  After iterating through all elements, the matrix $K$ is fully assembled. The final step is to flatten this matrix into a one-dimensional list in row-major order for output.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef assemble_stiffness(n_nodes, n_dof, connectivity, element_stiffness_matrices):\n    \"\"\"\n    Assembles the global stiffness matrix from element stiffness matrices.\n\n    Args:\n        n_nodes (int): The total number of nodes in the mesh.\n        n_dof (int): The number of degrees of freedom per node.\n        connectivity (list of tuples): A list where each tuple contains the \n                                       zero-based global node indices for an element.\n        element_stiffness_matrices (list of numpy.ndarray): A list of element \n                                                            stiffness matrices.\n\n    Returns:\n        numpy.ndarray: The assembled global stiffness matrix.\n    \"\"\"\n    total_dofs = n_nodes * n_dof\n    K_global = np.zeros((total_dofs, total_dofs), dtype=float)\n\n    # Iterate over each element to assemble its contribution to the global matrix\n    for elem_idx, elem_nodes in enumerate(connectivity):\n        K_e = element_stiffness_matrices[elem_idx]\n        num_elem_nodes = len(elem_nodes)\n        elem_dofs = num_elem_nodes * n_dof\n\n        # Map local DOFs to global DOFs and add stiffness contribution\n        for i in range(elem_dofs):\n            for j in range(elem_dofs):\n                # Decompose local DOF index 'i' into local node and local DOF type\n                local_node_row = i // n_dof\n                local_dof_row = i % n_dof\n                # Get the global node index from the connectivity array\n                global_node_row = elem_nodes[local_node_row]\n                # Calculate the global DOF index\n                global_dof_row = global_node_row * n_dof + local_dof_row\n\n                # Repeat for the column index 'j'\n                local_node_col = j // n_dof\n                local_dof_col = j % n_dof\n                global_node_col = elem_nodes[local_node_col]\n                global_dof_col = global_node_col * n_dof + local_dof_col\n\n                # Add the element's stiffness contribution to the global matrix\n                K_global[global_dof_row, global_dof_col] += K_e[i, j]\n                \n    return K_global\n\ndef solve():\n    \"\"\"\n    Defines and runs the test cases for global stiffness matrix assembly.\n    \"\"\"\n    I2 = np.identity(2)\n    test_cases = [\n        # Test Case 1: 1D bar elements\n        {\n            \"n_nodes\": 3,\n            \"n_dof\": 1,\n            \"connectivity\": [(0, 1), (1, 2)],\n            \"element_stiffness_matrices\": [\n                10.0 * np.array([[1, -1], [-1, 1]]),\n                20.0 * np.array([[1, -1], [-1, 1]]),\n            ],\n        },\n        # Test Case 2: 2D elements with 2 DOFs/node\n        {\n            \"n_nodes\": 3,\n            \"n_dof\": 2,\n            \"connectivity\": [(0, 1), (1, 2)],\n            \"element_stiffness_matrices\": [\n                3.0 * np.block([[I2, -I2], [-I2, I2]]),\n                5.0 * np.block([[I2, -I2], [-I2, I2]]),\n            ],\n        },\n        # Test Case 3: 1D bar chain\n        {\n            \"n_nodes\": 4,\n            \"n_dof\": 1,\n            \"connectivity\": [(0, 1), (1, 2), (2, 3)],\n            \"element_stiffness_matrices\": [\n                2.0 * np.array([[1, -1], [-1, 1]]),\n                4.0 * np.array([[1, -1], [-1, 1]]),\n                6.0 * np.array([[1, -1], [-1, 1]]),\n            ],\n        },\n        # Test Case 4: Nonconsecutive nodes, 3-node element\n        {\n            \"n_nodes\": 4,\n            \"n_dof\": 1,\n            \"connectivity\": [(0, 2, 3)],\n            \"element_stiffness_matrices\": [\n                np.array([[2, -1, -1], [-1, 2, -1], [-1, -1, 2]]),\n            ],\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        K_global = assemble_stiffness(\n            case[\"n_nodes\"],\n            case[\"n_dof\"],\n            case[\"connectivity\"],\n            case[\"element_stiffness_matrices\"],\n        )\n        # Flatten the matrix in row-major order and convert to a list of floats\n        flattened_list = K_global.flatten().tolist()\n        results.append(flattened_list)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2378075"}]}