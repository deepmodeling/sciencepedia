{"hands_on_practices": [{"introduction": "Our journey into the practical application of finite element theory begins with the simplest two-dimensional element: the 3-node linear triangle, often called the Constant Strain Triangle (CST). This foundational exercise guides you through the process of deriving the crucial strain-displacement matrix, $\\mathbf{B}$, directly from kinematic principles [@problem_id:2639920]. Mastering this derivation is essential, as it not only illuminates the core mechanics of displacement-based elements but also reveals why the element's linear formulation leads to constant strain, a property with direct consequences for its accuracy and performance on the indispensable patch test.", "problem": "Consider a $2$-dimensional, small-strain, displacement-based Finite Element Method (FEM) discretization of linear elasticity over a single $3$-node triangular element with straight sides. Let the physical coordinates of the triangle be given by node $1$ at $(0,0)$, node $2$ at $(4,0)$, and node $3$ at $(1,3)$, with all coordinates in $\\mathrm{m}$. Denote the nodal displacement vector by\n$$\n\\mathbf{d}_{e}=\\begin{bmatrix}u_{1}  v_{1}  u_{2}  v_{2}  u_{3}  v_{3}\\end{bmatrix}^{\\mathsf{T}},\n$$\nwhere $u_{i}$ and $v_{i}$ are the Cartesian displacement components at node $i$. The small-strain tensor is defined by\n$$\n\\boldsymbol{\\varepsilon}=\\frac{1}{2}\\left(\\nabla \\mathbf{u} + \\left(\\nabla \\mathbf{u}\\right)^{\\mathsf{T}}\\right),\n$$\nand the element employs linear shape functions in the physical $(x,y)$-plane.\n\nTasks:\n$1.$ Starting only from the kinematic definition of small strain and the linear interpolation of displacement using the element’s shape functions, derive the explicit expression for the element strain–displacement matrix $\\mathbf{B}$ such that $\\boldsymbol{\\varepsilon}=\\mathbf{B}\\,\\mathbf{d}_{e}$ for this triangle. Your derivation must make clear how $\\mathbf{B}$ depends on the nodal coordinates.\n\n$2.$ Prove that the strains produced by this element are constant over the element domain and explain the geometric reason for this fact. Then, using polynomial completeness and equilibrium arguments, deduce what this implies for the element’s performance on the Irons–Razzaque patch test: state precisely which order of displacement or stress fields are exactly reproduced and which are not.\n\n$3.$ For the given triangle, define the scalar\n$$\nS=\\|\\mathbf{B}\\|_{F}^{2}=\\sum_{i=1}^{3}\\sum_{j=1}^{6}\\left(B_{ij}\\right)^{2},\n$$\nthe squared Frobenius norm of $\\mathbf{B}$. Compute $S$ exactly. Express the final value of $S$ in $\\mathrm{m}^{-2}$, and do not round; provide an exact value.\n\nAnswer specification: The final answer must be a single real number (no units in the boxed answer). If you perform any intermediate numerical operations, do not round; carry exact arithmetic to the end.", "solution": "The problem as stated is scientifically grounded, well-posed, and objective. It is a standard problem in the study of the Finite Element Method for solid mechanics, specifically concerning the properties of the $3$-node linear triangular element, often referred to as the Constant Strain Triangle (CST) or T3 element. All necessary information is provided, and the tasks are well-defined. Therefore, the problem is valid and a solution will be provided.\n\nThe analysis begins with the fundamental principles of displacement-based finite element formulation.\n\n**Task 1: Derivation of the Strain-Displacement Matrix $\\mathbf{B}$**\n\nThe displacement field, $\\mathbf{u}(x,y) = \\begin{pmatrix} u(x,y)  v(x,y) \\end{pmatrix}^{\\mathsf{T}}$, within the element is interpolated from the nodal displacements $\\mathbf{d}_e$ using linear shape functions $N_i(x,y)$.\n$$\nu(x,y) = \\sum_{i=1}^{3} N_i(x,y) u_i\n$$\n$$\nv(x,y) = \\sum_{i=1}^{3} N_i(x,y) v_i\n$$\nThis can be written in matrix form as $\\mathbf{u} = \\mathbf{N} \\mathbf{d}_e$, where $\\mathbf{N}$ is the matrix of shape functions:\n$$\n\\mathbf{N} = \\begin{pmatrix} N_1  0  N_2  0  N_3  0 \\\\ 0  N_1  0  N_2  0  N_3 \\end{pmatrix}\n$$\nThe linear shape function for node $i$ has the form $N_i(x,y) = \\alpha_i + \\beta_i x + \\gamma_i y$. The coefficients are determined by the property $N_i(x_j, y_j) = \\delta_{ij}$, where $\\delta_{ij}$ is the Kronecker delta. A direct formula for the spatial derivatives of the shape functions exists, which is more convenient for deriving the strain-displacement matrix. These derivatives depend on the nodal coordinates $(x_i, y_i)$ and the area of the element, $A$.\nThe area $A$ of the triangle with vertices $(x_1, y_1)$, $(x_2, y_2)$, and $(x_3, y_3)$ is given by:\n$$\nA = \\frac{1}{2} \\det \\begin{pmatrix} 1  x_1  y_1 \\\\ 1  x_2  y_2 \\\\ 1  x_3  y_3 \\end{pmatrix} = \\frac{1}{2} \\left[ x_1(y_2 - y_3) + x_2(y_3 - y_1) + x_3(y_1 - y_2) \\right]\n$$\nThe spatial derivatives of the shape functions are constant and given by:\n$$\n\\frac{\\partial N_i}{\\partial x} = \\beta_i = \\frac{1}{2A}(y_j - y_k)\n$$\n$$\n\\frac{\\partial N_i}{\\partial y} = \\gamma_i = \\frac{1}{2A}(x_k - x_j)\n$$\nwhere the indices $(i, j, k)$ are cyclic permutations of $(1, 2, 3)$.\n\nThe small-strain tensor components in Voigt notation for a $2$-dimensional problem are $\\boldsymbol{\\varepsilon} = \\begin{pmatrix} \\varepsilon_{xx}  \\varepsilon_{yy}  \\gamma_{xy} \\end{pmatrix}^{\\mathsf{T}}$, where $\\varepsilon_{xx} = \\frac{\\partial u}{\\partial x}$, $\\varepsilon_{yy} = \\frac{\\partial v}{\\partial y}$, and $\\gamma_{xy} = \\frac{\\partial u}{\\partial y} + \\frac{\\partial v}{\\partial x}$.\n\nSubstituting the displacement interpolations:\n$$\n\\varepsilon_{xx} = \\frac{\\partial}{\\partial x} \\sum_{i=1}^{3} N_i u_i = \\sum_{i=1}^{3} \\frac{\\partial N_i}{\\partial x} u_i = \\beta_1 u_1 + \\beta_2 u_2 + \\beta_3 u_3\n$$\n$$\n\\varepsilon_{yy} = \\frac{\\partial}{\\partial y} \\sum_{i=1}^{3} N_i v_i = \\sum_{i=1}^{3} \\frac{\\partial N_i}{\\partial y} v_i = \\gamma_1 v_1 + \\gamma_2 v_2 + \\gamma_3 v_3\n$$\n$$\n\\gamma_{xy} = \\frac{\\partial}{\\partial y} \\sum_{i=1}^{3} N_i u_i + \\frac{\\partial}{\\partial x} \\sum_{i=1}^{3} N_i v_i = \\sum_{i=1}^{3} \\left( \\frac{\\partial N_i}{\\partial y} u_i + \\frac{\\partial N_i}{\\partial x} v_i \\right) = \\sum_{i=1}^{3} (\\gamma_i u_i + \\beta_i v_i)\n$$\nWe assemble these relationships into the matrix equation $\\boldsymbol{\\varepsilon} = \\mathbf{B} \\mathbf{d}_e$:\n$$\n\\begin{pmatrix} \\varepsilon_{xx} \\\\ \\varepsilon_{yy} \\\\ \\gamma_{xy} \\end{pmatrix} = \\begin{pmatrix}\n\\beta_1  0  \\beta_2  0  \\beta_3  0 \\\\\n0  \\gamma_1  0  \\gamma_2  0  \\gamma_3 \\\\\n\\gamma_1  \\beta_1  \\gamma_2  \\beta_2  \\gamma_3  \\beta_3\n\\end{pmatrix}\n\\begin{pmatrix} u_1 \\\\ v_1 \\\\ u_2 \\\\ v_2 \\\\ u_3 \\\\ v_3 \\end{pmatrix}\n$$\nThus, the strain-displacement matrix $\\mathbf{B}$ is:\n$$\n\\mathbf{B} = \\begin{pmatrix}\n\\beta_1  0  \\beta_2  0  \\beta_3  0 \\\\\n0  \\gamma_1  0  \\gamma_2  0  \\gamma_3 \\\\\n\\gamma_1  \\beta_1  \\gamma_2  \\beta_2  \\gamma_3  \\beta_3\n\\end{pmatrix}\n$$\nSubstituting the expressions for $\\beta_i$ and $\\gamma_i$ and defining $y_{ij} = y_i - y_j$ and $x_{ij} = x_i - x_j$:\n$$\n\\mathbf{B} = \\frac{1}{2A} \\begin{pmatrix}\ny_{2}-y_{3}  0  y_{3}-y_{1}  0  y_{1}-y_{2}  0 \\\\\n0  x_{3}-x_{2}  0  x_{1}-x_{3}  0  x_{2}-x_{1} \\\\\nx_{3}-x_{2}  y_{2}-y_{3}  x_{1}-x_{3}  y_{3}-y_{1}  x_{2}-x_{1}  y_{1}-y_{2}\n\\end{pmatrix}\n$$\nThis expression demonstrates explicitly how $\\mathbf{B}$ depends on the nodal coordinates.\n\n**Task 2: Constant Strain and Patch Test Implications**\n\nThe displacement field is interpolated by functions that are linear in the spatial coordinates $x$ and $y$. The strain components are defined by the first spatial derivatives of the displacement components. The derivative of a linear function is a constant. Consequently, $\\varepsilon_{xx}$, $\\varepsilon_{yy}$, and $\\gamma_{xy}$ are constant throughout the element's domain.\n\nGeometrically, the linear shape functions define an affine mapping from a master element (e.g., a right triangle in a reference $(\\xi, \\eta)$ coordinate system) to the physical element in the $(x,y)$ plane. The Jacobian of this mapping is constant. Since the derivatives of the shape functions with respect to the reference coordinates are constants, and the Jacobian is constant, the derivatives with respect to the physical coordinates are also constant. This is the fundamental reason for the constant strain behavior of the T3 element.\n\nThis property has direct implications for the element's performance, as evaluated by the patch test. The patch test is a necessary condition for convergence.\nThe polynomial completeness of the T3 element's shape functions means it can exactly represent any displacement field that is a linear polynomial in $x$ and $y$, i.e., $u(x,y)=a_0+a_1 x+a_2 y$ and $v(x,y)=b_0+b_1 x+b_2 y$. Such a displacement field corresponds to a state of constant strain, where $\\varepsilon_{xx}=a_1$, $\\varepsilon_{yy}=b_2$, and $\\gamma_{xy}=a_2+b_1$. For a homogeneous linear elastic material, a constant strain state implies a constant stress state. In the absence of body forces, a constant stress field $\\boldsymbol{\\sigma}$ trivially satisfies the equilibrium equation $\\nabla \\cdot \\boldsymbol{\\sigma} = \\mathbf{0}$. Therefore, a patch of T3 elements can exactly reproduce a constant stress field when the appropriate linear displacement field is applied to the boundary nodes. The element passes the constant stress patch test.\n\nHowever, the element cannot represent higher-order displacement fields exactly. For example, a quadratic displacement field, which would produce a linearly varying strain field (as in pure bending), cannot be captured. The element will approximate a linear strain field with a piecewise-constant strain field, which is a poor approximation. Thus, the T3 element fails the patch test for linear strain fields.\nIn summary, the T3 element exactly reproduces constant displacement gradients, corresponding to constant strain and stress fields. It does not exactly reproduce any fields of higher order.\n\n**Task 3: Computation of $S = \\|\\mathbf{B}\\|_{F}^{2}$**\n\nThe nodal coordinates are given as $1: (0,0)$, $2: (4,0)$, and $3: (1,3)$, with units in meters.\nFirst, we compute the area $A$ of the triangle.\n$$\n2A = x_1(y_2 - y_3) + x_2(y_3 - y_1) + x_3(y_1 - y_2) = 0(0 - 3) + 4(3 - 0) + 1(0 - 0) = 12 \\, \\mathrm{m}^2\n$$\nSo, $A = 6 \\, \\mathrm{m}^2$.\n\nNext, we compute the coordinate differences needed for the $\\mathbf{B}$ matrix:\n$y_{23} = y_2 - y_3 = 0 - 3 = -3$\n$y_{31} = y_3 - y_1 = 3 - 0 = 3$\n$y_{12} = y_1 - y_2 = 0 - 0 = 0$\n$x_{32} = x_3 - x_2 = 1 - 4 = -3$\n$x_{13} = x_1 - x_3 = 0 - 1 = -1$\n$x_{21} = x_2 - x_1 = 4 - 0 = 4$\n\nNow we construct the $\\mathbf{B}$ matrix:\n$$\n\\mathbf{B} = \\frac{1}{2A} \\begin{pmatrix} y_{23}  0  y_{31}  0  y_{12}  0 \\\\ 0  x_{32}  0  x_{13}  0  x_{21} \\\\ x_{32}  y_{23}  x_{13}  y_{31}  x_{21}  y_{12} \\end{pmatrix} = \\frac{1}{12} \\begin{pmatrix} -3  0  3  0  0  0 \\\\ 0  -3  0  -1  0  4 \\\\ -3  -3  -1  3  4  0 \\end{pmatrix}\n$$\nThe squared Frobenius norm is the sum of the squares of all elements: $S = \\sum_{i,j} (B_{ij})^2$.\n$$\nS = \\left(\\frac{1}{12}\\right)^{2} \\left[ (-3)^2 + 3^2 + (-3)^2 + (-1)^2 + 4^2 + (-3)^2 + (-3)^2 + (-1)^2 + 3^2 + 4^2 \\right]\n$$\nSumming the squares of the integer matrix elements:\nSum = $(9+9) + (9+1+16) + (9+9+1+9+16)$\nSum = $18 + 26 + 44 = 88$\nTherefore,\n$$\nS = \\frac{1}{144} \\times 88 = \\frac{88}{144}\n$$\nThis fraction can be simplified by dividing the numerator and denominator by their greatest common divisor, which is $8$.\n$$\nS = \\frac{88 \\div 8}{144 \\div 8} = \\frac{11}{18}\n$$\nThe units of the coefficients $\\beta_i$ and $\\gamma_i$ are $\\mathrm{m}^{-1}$. The quantity $S$ is a sum of squares of these coefficients, so its units are $\\mathrm{m}^{-2}$. The problem asks for a final numeric value.", "answer": "$$\\boxed{\\frac{11}{18}}$$", "id": "2639920"}, {"introduction": "While the CST element is simple, most real-world problems utilize more versatile elements like the 4-node bilinear quadrilateral (Q4), which relies on the powerful isoparametric mapping concept to handle general shapes. This practice provides a hands-on numerical experiment to investigate a critical practical reality: the impact of element distortion on solution quality [@problem_id:2639836]. By quantifying how a skewed element shape affects the Jacobian of the mapping and the accuracy of numerical integration, you will gain a concrete understanding of why maintaining good element quality is paramount for reliable FEA results.", "problem": "Consider a single isoparametric bilinear quadrilateral finite element used in the Finite Element Method (FEM). Let the reference square be $\\{(\\xi,\\eta)\\mid \\xi\\in[-1,1],\\ \\eta\\in[-1,1]\\}$. The isoparametric mapping from reference to physical coordinates is defined by $x(\\xi,\\eta)=\\sum_{i=1}^{4}N_i(\\xi,\\eta)X_i$ and $y(\\xi,\\eta)=\\sum_{i=1}^{4}N_i(\\xi,\\eta)Y_i$, where the bilinear shape functions are $N_1(\\xi,\\eta)=\\tfrac{1}{4}(1-\\xi)(1-\\eta)$, $N_2(\\xi,\\eta)=\\tfrac{1}{4}(1+\\xi)(1-\\eta)$, $N_3(\\xi,\\eta)=\\tfrac{1}{4}(1+\\xi)(1+\\eta)$, and $N_4(\\xi,\\eta)=\\tfrac{1}{4}(1-\\xi)(1+\\eta)$. The Jacobian matrix of the mapping is $J(\\xi,\\eta)=\\begin{bmatrix}\\partial x/\\partial \\xi  \\partial x/\\partial \\eta\\\\ \\partial y/\\partial \\xi  \\partial y/\\partial \\eta\\end{bmatrix}$. The condition number in the matrix $2$-norm is $\\kappa_2(J)=\\sigma_{\\max}(J)/\\sigma_{\\min}(J)$, where $\\sigma_{\\max}$ and $\\sigma_{\\min}$ are the largest and smallest singular values of $J$.\n\nYou will analyze how element distortion induced by perturbing two nodes affects the variation of $\\kappa_2(J)$ across the element and how that, in turn, influences numerical integration error for a smooth but non-polynomial-in-$\\xi,\\eta$ integrand (after mapping). Use the following universal base facts: the mapping and shape functions as defined above; the definition of $J(\\xi,\\eta)$ from partial derivatives; singular values and the matrix $2$-norm; and standard Gauss–Legendre quadrature rules for numerical integration.\n\nElement geometry and perturbation model: start from an axis-aligned rectangle of width $L$ and height $H$ with node numbering in counterclockwise order: $X_1=(0,0)$, $X_2=(L,0)$, $X_3=(L,H)$, $X_4=(0,H)$, where all coordinates are in meters. Introduce distortion by perturbing the two right-side nodes horizontally by scalars $\\delta_2$ and $\\delta_3$ (in meters): set $X_2=(L+\\delta_2,0)$ and $X_3=(L+\\delta_3,H)$, keeping $X_1$ and $X_4$ fixed. Assume $J(\\xi,\\eta)$ remains nonsingular over the element for the chosen perturbations.\n\nDefine the scalar function $g(x,y)=x^3+y^3$ to be integrated over the physical element. The exact integral is the reference integral $\\int_{-1}^{1}\\int_{-1}^{1} g(x(\\xi,\\eta),y(\\xi,\\eta))\\,\\det J(\\xi,\\eta)\\,d\\xi\\,d\\eta$. Approximate this integral in two ways: (i) a “reference truth” $I_{\\text{true}}$ computed by tensor-product Gauss–Legendre quadrature of order $p_{\\text{true}}=8$ in each direction, and (ii) a “standard element” approximation $I_{2\\times 2}$ computed by tensor-product Gauss–Legendre quadrature of order $p=2$ in each direction. Quantify the integration error by the relative error $e=\\lvert I_{2\\times 2}-I_{\\text{true}}\\rvert/\\lvert I_{\\text{true}}\\rvert$ (dimensionless). To quantify distortion severity, approximate the variation of $\\kappa_2(J)$ across the element by sampling a uniform grid of $n\\times n$ points in $(\\xi,\\eta)$ with $n=41$ over $[-1,1]\\times [-1,1]$, and compute both the sample maximum $\\kappa_{\\max}$ and the sample mean $\\overline{\\kappa}$.\n\nTasks to implement in a complete, runnable program:\n- For each specified test case below, construct the perturbed node coordinates, build $x(\\xi,\\eta)$ and $y(\\xi,\\eta)$, compute $J(\\xi,\\eta)$ on the specified grid, and report $\\kappa_{\\max}$ and $\\overline{\\kappa}$ from the grid sampling.\n- Compute $I_{\\text{true}}$ using $p_{\\text{true}}=8$ and $I_{2\\times 2}$ using $p=2$, then compute the relative error $e$.\n- Return results for all test cases as a single line string representing a list of lists, where each inner list corresponds to one test case and contains three floating-point numbers in the order $[\\kappa_{\\max},\\overline{\\kappa},e]$, each rounded to six digits after the decimal point.\n\nTest suite (all lengths in meters):\n- Case A (baseline, no distortion): $L=2$, $H=1$, $\\delta_2=0$, $\\delta_3=0$.\n- Case B (mild skew): $L=2$, $H=1$, $\\delta_2=0.3$, $\\delta_3=-0.3$.\n- Case C (severe skew, still nondegenerate): $L=2$, $H=1$, $\\delta_2=1.2$, $\\delta_3=-1.2$.\n\nAngle units do not apply. The outputs $\\kappa_{\\max}$, $\\overline{\\kappa}$, and $e$ are dimensionless. Your program should produce a single line of output containing the results as a comma-separated list of the three-number lists for the three cases, with no spaces, enclosed in square brackets; for example, the format must be exactly like $[[a_1,b_1,c_1],[a_2,b_2,c_2],[a_3,b_3,c_3]]$ where each $a_i$, $b_i$, and $c_i$ is a floating-point number rounded to six decimals as specified.", "solution": "The problem statement is critically assessed and deemed valid for a computational solution, as it presents a well-posed numerical experiment within the established principles of the Finite Element Method. All required data, parameters, and procedures are specified unambiguously. However, it must be noted with academic rigor that the problem contains a factual imprecision. The statement asserts that the integrand $g(x(\\xi,\\eta),y(\\xi,\\eta))\\,\\det J(\\xi,\\eta)$ is \"non-polynomial-in-$\\xi,\\eta$\". For the chosen bilinear element and the polynomial function $g(x,y)=x^3+y^3$, a direct derivation reveals that the transformed integrand is, in fact, a polynomial in $\\xi$ and $\\eta$. This inconsistency does not invalidate the task, as the specified lower-order quadrature rule ($2 \\times 2$) is indeed insufficient for exact integration of the resulting polynomial in distorted cases, thereby generating the non-zero error the problem intends to study. The solution will proceed based on the correctly derived polynomial nature of the integrand.\n\nThe core of the problem is to quantify the effect of element distortion on the condition number of the isoparametric mapping's Jacobian and on the accuracy of numerical integration.\n\nFirst, we define the mathematical framework. The isoparametric mapping from the reference coordinates $(\\xi, \\eta)$ to the physical coordinates $(x,y)$ is given by:\n$$ x(\\xi,\\eta)=\\sum_{i=1}^{4}N_i(\\xi,\\eta)X_i \\quad \\text{and} \\quad y(\\xi,\\eta)=\\sum_{i=1}^{4}N_i(\\xi,\\eta)Y_i $$\nwhere $(X_i, Y_i)$ are the coordinates of the $i$-th node, and $N_i(\\xi, \\eta)$ are the bilinear shape functions.\nThe Jacobian matrix of this transformation is:\n$$ J(\\xi,\\eta) = \\begin{bmatrix} \\frac{\\partial x}{\\partial \\xi}  \\frac{\\partial x}{\\partial \\eta} \\\\ \\frac{\\partial y}{\\partial \\xi}  \\frac{\\partial y}{\\partial \\eta} \\end{bmatrix} $$\nThe components of $J$ are found by differentiating the mapping equations:\n$$ \\frac{\\partial x}{\\partial \\xi} = \\sum_{i=1}^{4}\\frac{\\partial N_i}{\\partial \\xi}X_i, \\quad \\frac{\\partial x}{\\partial \\eta} = \\sum_{i=1}^{4}\\frac{\\partial N_i}{\\partial \\eta}X_i, \\quad \\text{etc.} $$\nSubstituting the derivatives of the shape functions leads to a general expression for the Jacobian components. For example:\n$$ J_{11} = \\frac{\\partial x}{\\partial \\xi} = \\frac{1}{4} \\left[ (1-\\eta)(X_2-X_1) + (1+\\eta)(X_3-X_4) \\right] $$\n$$ J_{12} = \\frac{\\partial x}{\\partial \\eta} = \\frac{1}{4} \\left[ (1-\\xi)(X_4-X_1) + (1+\\xi)(X_3-X_2) \\right] $$\n$$ J_{21} = \\frac{\\partial y}{\\partial \\xi} = \\frac{1}{4} \\left[ (1-\\eta)(Y_2-Y_1) + (1+\\eta)(Y_3-Y_4) \\right] $$\n$$ J_{22} = \\frac{\\partial y}{\\partial \\eta} = \\frac{1}{4} \\left[ (1-\\xi)(Y_4-Y_1) + (1+\\xi)(Y_3-Y_2) \\right] $$\n\nFor the specific geometry given, the nodal coordinates are $X_1=(0,0)$, $X_2=(L+\\delta_2,0)$, $X_3=(L+\\delta_3,H)$, and $X_4=(0,H)$. Substituting these into the Jacobian component equations yields:\n$J_{11} = \\frac{1}{4} \\left[ (1-\\eta)(L+\\delta_2) + (1+\\eta)(L+\\delta_3) \\right] = \\frac{1}{4} \\left[ 2L + \\delta_2+\\delta_3 + \\eta(\\delta_3-\\delta_2) \\right]$\n$J_{12} = \\frac{1}{4} \\left[ (1-\\xi)(0) + (1+\\xi)(L+\\delta_3 - (L+\\delta_2)) \\right] = \\frac{1}{4} (1+\\xi)(\\delta_3-\\delta_2)$\n$J_{21} = \\frac{1}{4} \\left[ (1-\\eta)(0) + (1+\\eta)(H-H) \\right] = 0$\n$J_{22} = \\frac{1}{4} \\left[ (1-\\xi)(H-0) + (1+\\xi)(H-0) \\right] = \\frac{H}{4} [(1-\\xi)+(1+\\xi)] = \\frac{H}{2}$\n\nThus, the Jacobian matrix for this specific problem is upper triangular:\n$$ J(\\xi, \\eta) = \\begin{bmatrix} \\frac{1}{4} [2L+\\delta_2+\\delta_3+\\eta(\\delta_3-\\delta_2)]  \\frac{1}{4} (1+\\xi)(\\delta_3-\\delta_2) \\\\ 0  \\frac{H}{2} \\end{bmatrix} $$\nThe condition number in the $2$-norm, $\\kappa_2(J)$, is the ratio of the largest to the smallest singular value of $J$, $\\kappa_2(J) = \\sigma_{\\max}/\\sigma_{\\min}$. The singular values are computed for $J(\\xi, \\eta)$ at each point on a uniform $41 \\times 41$ grid in the $(\\xi, \\eta)$ domain $[-1,1] \\times [-1,1]$. The sample maximum $\\kappa_{\\max}$ and sample mean $\\overline{\\kappa}$ of these values are then computed to quantify element distortion.\n\nNext, we address the numerical integration. The integral of a function $g(x,y)$ over the physical element area $\\Omega_e$ is transformed to the reference element:\n$$ I = \\int_{\\Omega_e} g(x,y) \\,dA = \\int_{-1}^{1}\\int_{-1}^{1} g(x(\\xi,\\eta),y(\\xi,\\eta)) \\det(J(\\xi,\\eta)) \\,d\\xi\\,d\\eta $$\nThe determinant of the derived Jacobian is $\\det(J) = J_{11}J_{22} = \\frac{H}{8}[2L+\\delta_2+\\delta_3+\\eta(\\delta_3-\\delta_2)]$.\nThe physical coordinates $x$ and $y$ are expressed in terms of $\\xi$ and $\\eta$ using the mapping:\n$x(\\xi,\\eta) = \\frac{1+\\xi}{4}[2L+\\delta_2+\\delta_3+\\eta(\\delta_3-\\delta_2)]$\n$y(\\xi,\\eta) = \\frac{1+\\eta}{2}H$\nThe function to integrate is $g(x,y) = x^3+y^3$. The full integrand in the reference domain is:\n$$ F(\\xi,\\eta) = \\left( \\left(\\frac{1+\\xi}{4}[2L+\\delta_2+\\delta_3+\\eta(\\delta_3-\\delta_2)]\\right)^3 + \\left(\\frac{1+\\eta}{2}H\\right)^3 \\right) \\frac{H}{8}[2L+\\delta_2+\\delta_3+\\eta(\\delta_3-\\delta_2)] $$\nAnalysis of this expression shows that $F(\\xi,\\eta)$ is a polynomial of degree $3$ in $\\xi$. The degree in $\\eta$ depends on the distortion. For the baseline case ($\\delta_2=\\delta_3=0$), the degree in $\\eta$ is $3$. For distorted cases ($\\delta_2 \\neq 0$ or $\\delta_3 \\neq 0$), the degree in $\\eta$ becomes $4$.\n\nA tensor-product Gauss-Legendre quadrature rule with $p$ points in each direction,\n$$ \\int_{-1}^{1}\\int_{-1}^{1} F(\\xi,\\eta) \\,d\\xi\\,d\\eta \\approx \\sum_{i=1}^{p} \\sum_{j=1}^{p} w_i w_j F(\\xi_i, \\eta_j) $$\nintegrates polynomials of degree up to $2p-1$ exactly.\n- The \"standard\" $2 \\times 2$ rule ($p=2$) is exact for polynomials up to degree $2(2)-1=3$.\n- The \"truth\" $8 \\times 8$ rule ($p_{\\text{true}}=8$) is exact for polynomials up to degree $2(8)-1=15$.\n\nFor the baseline case (degree $3$ in $\\xi$, $3$ in $\\eta$), the $2 \\times 2$ rule is exact, so $I_{2\\times2} = I_{\\text{true}}$ and the error $e=0$.\nFor the distorted cases (degree $3$ in $\\xi$, $4$ in $\\eta$), the $2 \\times 2$ rule is not exact for the $\\eta$ integration. The $8 \\times 8$ rule is exact. Therefore, $I_{2\\times2} \\neq I_{\\text{true}}$, and a non-zero error $e = \\lvert I_{2\\times 2} - I_{\\text{true}} \\rvert / \\lvert I_{\\text{true}} \\rvert$ will arise.\n\nThe algorithm for each test case is as follows:\n1.  Define the nodal coordinates based on $L, H, \\delta_2, \\delta_3$.\n2.  Define a $41 \\times 41$ grid of $(\\xi,\\eta)$ points over $[-1,1] \\times [-1,1]$.\n3.  For each grid point, calculate $J(\\xi,\\eta)$ and its condition number $\\kappa_2(J)$. Store these values.\n4.  Compute the maximum $\\kappa_{\\max}$ and mean $\\overline{\\kappa}$ from the stored condition numbers.\n5.  Numerically compute the integral $I_{\\text{true}}$ using an $8 \\times 8$ Gauss-Legendre quadrature.\n6.  Numerically compute the integral $I_{2 \\times 2}$ using a $2 \\times 2$ Gauss-Legendre quadrature.\n7.  Calculate the relative integration error $e$.\n8.  Collect and format the results $[\\kappa_{\\max}, \\overline{\\kappa}, e]$.\n\nThis procedure is systematically applied to all specified test cases to generate the final output.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the FEM element distortion problem for the given test cases.\n    \"\"\"\n\n    def get_jacobian_and_coords(xi, eta, L, H, delta_2, delta_3):\n        \"\"\"\n        Calculates the Jacobian matrix J and physical coordinates (x, y) \n        for given reference coordinates (xi, eta) and element geometry.\n        \"\"\"\n        # Jacobian components\n        # J11 = 0.25 * (2*L + delta_2 + delta_3 + eta * (delta_3 - delta_2))\n        # J12 = 0.25 * (1 + xi) * (delta_3 - delta_2)\n        # J21 = 0\n        # J22 = 0.5 * H\n        \n        d3_minus_d2 = delta_3 - delta_2\n        j11 = 0.25 * (2 * L + delta_2 + delta_3 + eta * d3_minus_d2)\n        j12 = 0.25 * (1 + xi) * d3_minus_d2\n        j21 = 0.0\n        j22 = 0.5 * H\n        \n        J = np.array([[j11, j12], [j21, j22]])\n        \n        # Physical coordinates\n        # x = (1+xi) * J11\n        # y = H/2 * (1+eta)\n        x = (1 + xi) * j11\n        y = 0.5 * H * (1 + eta)\n        \n        return J, x, y\n\n    def calculate_integration(p, L, H, delta_2, delta_3):\n        \"\"\"\n        Performs 2D Gauss-Legendre quadrature of order p x p.\n        \"\"\"\n        points, weights = np.polynomial.legendre.leggauss(p)\n        integral_sum = 0.0\n        \n        for i in range(p):\n            for j in range(p):\n                xi = points[i]\n                eta = points[j]\n                wi = weights[i]\n                wj = weights[j]\n                \n                J, x, y = get_jacobian_and_coords(xi, eta, L, H, delta_2, delta_3)\n                \n                det_J = np.linalg.det(J)\n                \n                g_val = x**3 + y**3\n                \n                integrand_val = g_val * det_J\n                \n                integral_sum += wi * wj * integrand_val\n        \n        return integral_sum\n\n    def analyze_case(L, H, delta_2, delta_3):\n        \"\"\"\n        Analyzes a single element geometry case.\n        \"\"\"\n        # Part 1: Condition number analysis\n        n_grid = 41\n        xi_eta_vals = np.linspace(-1.0, 1.0, n_grid)\n        condition_numbers = []\n        \n        for xi in xi_eta_vals:\n            for eta in xi_eta_vals:\n                J, _, _ = get_jacobian_and_coords(xi, eta, L, H, delta_2, delta_3)\n                \n                # Singular Value Decomposition\n                # The problem assumes non-singular J, so sigma_min will not be zero.\n                singular_values = np.linalg.svd(J, compute_uv=False)\n                \n                # np.linalg.svd returns sorted singular values\n                sigma_max = singular_values[0]\n                sigma_min = singular_values[-1]\n                \n                kappa = sigma_max / sigma_min if sigma_min > 1e-12 else np.inf\n                condition_numbers.append(kappa)\n\n        kappa_max = np.max(condition_numbers)\n        kappa_mean = np.mean(condition_numbers)\n\n        # Part 2: Integration error analysis\n        p_true = 8\n        p_approx = 2\n        \n        i_true = calculate_integration(p_true, L, H, delta_2, delta_3)\n        i_approx = calculate_integration(p_approx, L, H, delta_2, delta_3)\n        \n        # Relative error\n        if abs(i_true)  1e-12:\n            # Handle case where true integral is zero.\n            # For Case A, both are exact so error is 0.\n            # For other cases, i_true will be non-zero.\n            relative_error = 0.0 if abs(i_approx)  1e-12 else np.inf\n        else:\n            relative_error = np.abs(i_approx - i_true) / np.abs(i_true)\n            \n        return kappa_max, kappa_mean, relative_error\n\n    test_cases = [\n        # Case A: L=2, H=1, delta_2=0, delta_3=0\n        (2.0, 1.0, 0.0, 0.0),\n        # Case B: L=2, H=1, delta_2=0.3, delta_3=-0.3\n        (2.0, 1.0, 0.3, -0.3),\n        # Case C: L=2, H=1, delta_2=1.2, delta_3=-1.2\n        (2.0, 1.0, 1.2, -1.2)\n    ]\n\n    all_results = []\n    for case in test_cases:\n        L, H, delta_2, delta_3 = case\n        k_max, k_mean, err = analyze_case(L, H, delta_2, delta_3)\n        all_results.append([k_max, k_mean, err])\n    \n    # Format output string\n    output_parts = []\n    for res in all_results:\n        formatted_res = [f\"{v:.6f}\" for v in res]\n        output_parts.append(f\"[{','.join(formatted_res)}]\")\n    \n    final_output = f\"[{','.join(output_parts)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "2639836"}, {"introduction": "In our final practice, we synthesize the preceding concepts by developing and validating a small-scale solver for a classic problem in solid mechanics. You will implement an axisymmetric solver using Q4 elements to model a pressurized thick-walled cylinder, a crucial benchmark for which an analytical solution exists [@problem_id:2639858]. This comprehensive exercise will not only solidify your understanding of assembling global matrices from element contributions but also allow you to perform a validation study, comparing your numerical results to theory and observing important numerical phenomena like volumetric locking.", "problem": "Implement a small, self-contained axisymmetric Finite Element Method (FEM) solver using four-node bilinear quadrilateral (Q4) elements to approximate the radial displacement in a long, pressurized thick-walled cylinder under plane strain conditions. The goal is to compute the radial displacement field and compare it against the analytical solution derived from the fundamental equations of equilibrium and linear elasticity. The comparison must be quantified by a relative $L^{2}$-type error norm over the cross-sectional domain.\n\nConsider a long cylinder with inner radius $a$ and outer radius $b$, made of a homogeneous, isotropic, linear elastic material with Young’s modulus $E$ and Poisson’s ratio $\\nu$. The loading consists of a uniform internal pressure $p_{i}$ applied on the inner cylindrical surface $r=a$ and a uniform external pressure $p_{o}$ applied on the outer cylindrical surface $r=b$. Assume small strains and plane strain in the axial direction, i.e., the axial strain $\\varepsilon_{z}=0$. Use an axisymmetric formulation in cylindrical coordinates with the cross-section in the $(r,z)$-plane, where $r\\in[a,b]$ and $z\\in[0,L]$ with $L=1$. Enforce plane strain by constraining the axial displacement $u_{z}=0$ everywhere.\n\nDiscretization requirements:\n- Use isoparametric Q4 elements with standard bilinear shape functions on the reference square. Use $2\\times 2$ Gaussian quadrature for element stiffness and volume terms, and $2$-point Gauss quadrature for boundary traction integrals.\n- Use the axisymmetric weak form, where all integrals are weighted by the radius $r$ and include the circumferential factor $2\\pi$. Specifically, the element stiffness must be assembled from\n$$\n\\mathbf{K}_{e}=\\int_{\\Omega_{e}} \\left(\\mathbf{B}^{T}\\mathbf{D}\\mathbf{B}\\right)\\, 2\\pi r \\, \\mathrm{d}A,\n$$\nwhere $\\mathbf{B}$ is the strain-displacement matrix for axisymmetry with strain components $\\varepsilon_{r}$, $\\varepsilon_{z}$, $\\varepsilon_{\\theta}$, $\\gamma_{rz}$, and $\\mathbf{D}$ is the isotropic elasticity matrix in axisymmetric form using Lamé parameters $\\lambda$ and $\\mu$ with $\\mu= \\dfrac{E}{2(1+\\nu)}$ and $\\lambda=\\dfrac{E\\nu}{(1+\\nu)(1-2\\nu)}$.\n- Apply the Neumann boundary conditions on $r=a$ and $r=b$ via consistent boundary integrals of the form\n$$\n\\mathbf{f}_{e}^{(\\text{traction})}=\\int_{\\Gamma_{e}} \\mathbf{N}^{T}\\,\\mathbf{t}\\, 2\\pi r\\, \\mathrm{d}\\ell,\n$$\nwith $\\mathbf{t}=\\left[+p_{i},\\,0\\right]^{T}$ on $r=a$ and $\\mathbf{t}=\\left[-p_{o},\\,0\\right]^{T}$ on $r=b$. Here $\\mathbf{N}$ is the matrix of shape functions mapping nodal displacements to the displacement field, and $\\mathrm{d}\\ell$ is the line element along the boundary edge in the $(r,z)$-plane.\n\nAnalytical target:\n- Starting from the axisymmetric radial equilibrium equation, the strain-displacement relations, and Hooke’s law (do not assume any target formula), derive the analytical expression for the radial displacement $u_{\\text{an}}(r)$ under plane strain for given $(a,b,p_{i},p_{o},E,\\nu)$.\n\nError metric:\n- Define the relative $L^{2}$-type error over the cross-section by\n$$\n\\varepsilon_{\\text{rel}}=\\frac{\\left(\\int_{\\Omega} \\left(u_{h}(r,z)-u_{\\text{an}}(r)\\right)^{2}\\, 2\\pi r \\,\\mathrm{d}A\\right)^{1/2}}{\\left(\\int_{\\Omega} \\left(u_{\\text{an}}(r)\\right)^{2}\\, 2\\pi r \\,\\mathrm{d}A\\right)^{1/2}},\n$$\nwhere $u_{h}$ is the FEM radial displacement solution and $u_{\\text{an}}$ is the analytical radial displacement. Use $2\\times 2$ Gaussian quadrature per element to approximate these integrals numerically. The error $\\varepsilon_{\\text{rel}}$ is dimensionless.\n\nBoundary conditions and constraints:\n- Enforce plane strain by prescribing $u_{z}=0$ at all nodes.\n- No additional displacement constraints in the radial direction are to be imposed.\n\nTest suite:\nRun your solver for the following four test cases, using the specified units (all in the International System of Units). The axial length is $L=1$ in meters for all cases. For each case, discretize the domain with $N_{r}$ elements in the radial direction and $N_{z}$ elements in the axial direction.\n\n$1.$ Case A (happy path, moderate mesh):\n- $a = 0.3\\,\\text{m}$, $b=1.0\\,\\text{m}$, $p_{i}=1.25\\times 10^{6}\\,\\text{Pa}$, $p_{o}=0.0\\,\\text{Pa}$, $E=200\\times 10^{9}\\,\\text{Pa}$, $\\nu=0.30$, $N_{r}=8$, $N_{z}=3$.\n\n$2.$ Case B (coarse mesh edge case):\n- $a = 0.3\\,\\text{m}$, $b=1.0\\,\\text{m}$, $p_{i}=1.25\\times 10^{6}\\,\\text{Pa}$, $p_{o}=0.0\\,\\text{Pa}$, $E=200\\times 10^{9}\\,\\text{Pa}$, $\\nu=0.30$, $N_{r}=1$, $N_{z}=1$.\n\n$3.$ Case C (nonzero external pressure):\n- $a = 0.3\\,\\text{m}$, $b=1.0\\,\\text{m}$, $p_{i}=1.25\\times 10^{6}\\,\\text{Pa}$, $p_{o}=0.60\\times 10^{6}\\,\\text{Pa}$, $E=200\\times 10^{9}\\,\\text{Pa}$, $\\nu=0.30$, $N_{r}=6$, $N_{z}=2$.\n\n$4.$ Case D (near-incompressible material to expose locking in plane strain with Q4):\n- $a = 0.3\\,\\text{m}$, $b=1.0\\,\\text{m}$, $p_{i}=1.25\\times 10^{6}\\,\\text{Pa}$, $p_{o}=0.0\\,\\text{Pa}$, $E=200\\times 10^{9}\\,\\text{Pa}$, $\\nu=0.49$, $N_{r}=8$, $N_{z}=2$.\n\nFinal output format:\nYour program must produce a single line of output containing the four relative errors for Cases A–D as a comma-separated list enclosed in square brackets, for example\n$[\\varepsilon_{A},\\varepsilon_{B},\\varepsilon_{C},\\varepsilon_{D}]$,\nwith each entry formatted as a decimal number rounded to exactly six digits after the decimal point. The relative error is dimensionless, so no physical units are required in the output. There must be no other output.\n\nNotes:\n- Angles are not used in the input or output, so no angle unit is required.\n- All inputs use the International System of Units, but the requested outputs are dimensionless numbers as specified.", "solution": "The user requires the development of an axisymmetric Finite Element Method (FEM) solver for a thick-walled pressurized cylinder under plane strain conditions. The problem is well-posed and scientifically sound, representing a classic problem in linear elasticity. The process involves two main stages: first, the derivation of the analytical solution for validation, and second, the formulation and implementation of the FEM solver.\n\nFirst, we derive the analytical solution for the radial displacement $u_r(r)$. The problem is axisymmetric, so displacements and stresses do not vary with the circumferential coordinate $\\theta$. The cylinder is assumed to be long, and plane strain conditions are imposed, meaning the axial strain $\\varepsilon_z = 0$. Due to uniform loading along the length, the radial displacement $u_r$ depends only on the radial coordinate $r$, so $u_r = u_r(r)$.\n\nThe radial and circumferential strains are given by:\n$$\n\\varepsilon_r = \\frac{du_r}{dr}, \\quad \\varepsilon_\\theta = \\frac{u_r}{r}\n$$\nThe axial strain is $\\varepsilon_z = 0$. The shear strain $\\gamma_{rz}$ is also zero due to axial symmetry and uniform loading.\n\nThe governing equation is the radial equilibrium equation in cylindrical coordinates, which simplifies to:\n$$\n\\frac{d\\sigma_r}{dr} + \\frac{\\sigma_r - \\sigma_\\theta}{r} = 0\n$$\nwhere $\\sigma_r$ and $\\sigma_\\theta$ are the radial and circumferential (hoop) stresses.\n\nUnder plane strain conditions ($\\varepsilon_z=0$), Hooke's law relating stresses and strains for an isotropic material is:\n$$\n\\sigma_r = \\frac{E}{(1+\\nu)(1-2\\nu)} \\left[ (1-\\nu)\\varepsilon_r + \\nu\\varepsilon_\\theta \\right] = (\\lambda + 2\\mu)\\varepsilon_r + \\lambda\\varepsilon_\\theta \\\\\n\\sigma_\\theta = \\frac{E}{(1+\\nu)(1-2\\nu)} \\left[ \\nu\\varepsilon_r + (1-\\nu)\\varepsilon_\\theta \\right] = \\lambda\\varepsilon_r + (\\lambda + 2\\mu)\\varepsilon_\\theta \\\\\n\\sigma_z = \\nu(\\sigma_r + \\sigma_\\theta) = \\lambda(\\varepsilon_r + \\varepsilon_\\theta)\n$$\nwhere $E$ is Young's modulus, $\\nu$ is Poisson's ratio, and $\\lambda = \\frac{E\\nu}{(1+\\nu)(1-2\\nu)}$ and $\\mu = \\frac{E}{2(1+\\nu)}$ are Lamé's parameters.\n\nSubstituting the strain-displacement relations into the stress expressions, and then into the equilibrium equation, yields a second-order ordinary differential equation for $u_r(r)$:\n$$\n\\frac{d^2u_r}{dr^2} + \\frac{1}{r}\\frac{du_r}{dr} - \\frac{u_r}{r^2} = 0\n$$\nThis is a Cauchy-Euler equation with the general solution of the form:\n$$\nu_r(r) = C_1 r + \\frac{C_2}{r}\n$$\nThe constants of integration, $C_1$ and $C_2$, are determined from the boundary conditions on the radial stress:\n$$\n\\sigma_r(r=a) = -p_i, \\quad \\sigma_r(r=b) = -p_o\n$$\nSubstituting the general solution for $u_r(r)$ into the expression for $\\sigma_r$ gives:\n$$\n\\sigma_r(r) = 2(\\lambda+\\mu)C_1 - \\frac{2\\mu C_2}{r^2}\n$$\nApplying the boundary conditions yields a system of two linear equations for $C_1$ and $C_2$:\n$$\n-p_i = 2(\\lambda+\\mu)C_1 - \\frac{2\\mu C_2}{a^2} \\\\\n-p_o = 2(\\lambda+\\mu)C_1 - \\frac{2\\mu C_2}{b^2}\n$$\nSolving this system gives:\n$$\nC_1 = \\frac{p_ia^2 - p_ob^2}{2(\\lambda+\\mu)(b^2-a^2)} = \\frac{(1+\\nu)(1-2\\nu)}{E} \\frac{p_ia^2-p_ob^2}{b^2-a^2} \\\\\nC_2 = \\frac{(p_i-p_o)a^2b^2}{2\\mu(b^2-a^2)} = \\frac{1+\\nu}{E} \\frac{(p_i-p_o)a^2b^2}{b^2-a^2}\n$$\nFinally, the analytical solution for the radial displacement is:\n$$\nu_{\\text{an}}(r) = \\frac{1+\\nu}{E(b^2-a^2)} \\left[ (1-2\\nu)(p_ia^2-p_ob^2)r + (p_i-p_o)\\frac{a^2b^2}{r} \\right]\n$$\n\nNext, we establish the Finite Element formulation. The domain is discretized using four-node bilinear quadrilateral (Q4) elements. The displacement field within an element is interpolated from the nodal displacements $\\mathbf{d}^e$ using shape functions $\\mathbf{N}$:\n$$\n\\mathbf{u}(r,z) = \\begin{Bmatrix} u_r \\\\ u_z \\end{Bmatrix} = \\mathbf{N}\\mathbf{d}^e = \\sum_{i=1}^{4} \\mathbf{N}_i \\mathbf{d}_i\n$$\nwhere $\\mathbf{N}_i = \\begin{bmatrix} N_i  0 \\\\ 0  N_i \\end{bmatrix}$ and $\\mathbf{d}_i=\\begin{Bmatrix} u_r^i \\\\ u_z^i \\end{Bmatrix}$. The shape functions $N_i(\\xi, \\eta)$ are defined on the reference square $[-1,1] \\times [-1,1]$.\n\nThe axisymmetric strain vector is $\\boldsymbol{\\varepsilon} = [\\varepsilon_r, \\varepsilon_z, \\varepsilon_\\theta, \\gamma_{rz}]^T$. The strains are related to nodal displacements via the strain-displacement matrix $\\mathbf{B}$: $\\boldsymbol{\\varepsilon} = \\mathbf{B}\\mathbf{d}^e$. For node $i$, the matrix $\\mathbf{B}_i$ is:\n$$\n\\mathbf{B}_i = \\begin{bmatrix} \\frac{\\partial N_i}{\\partial r}  0 \\\\ 0  \\frac{\\partial N_i}{\\partial z} \\\\ \\frac{N_i}{r}  0 \\\\ \\frac{\\partial N_i}{\\partial z}  \\frac{\\partial N_i}{\\partial r} \\end{bmatrix}\n$$\nThe derivatives of the shape functions with respect to global coordinates $(r,z)$ are obtained from derivatives with respect to local coordinates $(\\xi,\\eta)$ using the Jacobian of the isoparametric mapping: $\\begin{Bmatrix} \\partial/\\partial r \\\\ \\partial/\\partial z \\end{Bmatrix} = \\mathbf{J}^{-1} \\begin{Bmatrix} \\partial/\\partial \\xi \\\\ \\partial/\\partial \\eta \\end{Bmatrix}$.\n\nThe constitutive matrix $\\mathbf{D}$ relates the stress vector $\\boldsymbol{\\sigma} = [\\sigma_r, \\sigma_z, \\sigma_\\theta, \\tau_{rz}]^T$ to the strain vector $\\boldsymbol{\\varepsilon}$ via $\\boldsymbol{\\sigma} = \\mathbf{D}\\boldsymbol{\\varepsilon}$. For an isotropic material, this matrix is:\n$$\n\\mathbf{D} = \\begin{bmatrix}\n\\lambda+2\\mu  \\lambda  \\lambda  0 \\\\\n\\lambda  \\lambda+2\\mu  \\lambda  0 \\\\\n\\lambda  \\lambda  \\lambda+2\\mu  0 \\\\\n0  0  0  \\mu\n\\end{bmatrix}\n$$\nThe element stiffness matrix $\\mathbf{K}_e$ is computed by integrating over the element volume in cylindrical coordinates:\n$$\n\\mathbf{K}_{e} = \\int_{\\Omega_{e}} \\mathbf{B}^{T}\\mathbf{D}\\mathbf{B} \\, 2\\pi r \\, dA = \\int_{-1}^{1}\\int_{-1}^{1} \\mathbf{B}^{T}\\mathbf{D}\\mathbf{B} \\, 2\\pi r(\\xi,\\eta) \\, |\\det(\\mathbf{J})| \\, d\\xi d\\eta\n$$\nThis integral is evaluated numerically using $2 \\times 2$ Gaussian quadrature.\n\nThe external pressures are applied as Neumann boundary conditions. The consistent nodal force vector for an element edge $\\Gamma_e$ is:\n$$\n\\mathbf{f}_{e}^{(\\text{traction})} = \\int_{\\Gamma_{e}} \\mathbf{N}^{T} \\mathbf{t} \\, 2\\pi r \\, d\\ell\n$$\nFor an edge on the inner boundary $r=a$, the traction is $\\mathbf{t} = [p_i, 0]^T$. For the outer boundary $r=b$, $\\mathbf{t} = [-p_o, 0]^T$. These line integrals are evaluated using $2$-point Gaussian quadrature.\n\nAfter assembling the global stiffness matrix $\\mathbf{K}$ and force vector $\\mathbf{F}$, the system $\\mathbf{K}\\mathbf{U} = \\mathbf{F}$ is solved for the global displacement vector $\\mathbf{U}$. The plane strain condition is enforced by constraining the axial displacements $u_z=0$ for all nodes. This is achieved by modifying the global system of equations before solving.\n\nFinally, the relative error between the FEM solution $u_h$ and the analytical solution $u_{\\text{an}}$ is calculated using the specified $L^2$-type norm:\n$$\n\\varepsilon_{\\text{rel}} = \\frac{\\|u_h - u_{\\text{an}}\\|_{L^2(\\Omega)}}{\\|u_{\\text{an}}\\|_{L^2(\\Omega)}} = \\frac{\\left(\\int_{\\Omega} \\left(u_{h}(r,z)-u_{\\text{an}}(r)\\right)^{2}\\, 2\\pi r \\,\\mathrm{d}A\\right)^{1/2}}{\\left(\\int_{\\Omega} \\left(u_{\\text{an}}(r)\\right)^{2}\\, 2\\pi r \\,\\mathrm{d}A\\right)^{1/2}}\n$$\nThe integrals for the error norm are also computed numerically using $2 \\times 2$ Gaussian quadrature over each element.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function to run all test cases and print results.\n    \"\"\"\n\n    # Gauss quadrature points and weights\n    # 2x2 for area integrals\n    gauss_pts_2d = np.array([-1/np.sqrt(3), 1/np.sqrt(3)])\n    gauss_wts_2d = np.array([1.0, 1.0])\n    # 2-point for line integrals\n    gauss_pts_1d = np.array([-1/np.sqrt(3), 1/np.sqrt(3)])\n    gauss_wts_1d = np.array([1.0, 1.0])\n\n    def analytical_displacement(r, a, b, pi, po, E, nu):\n        \"\"\"Calculates the analytical radial displacement for plane strain.\"\"\"\n        if abs(b**2 - a**2)  1e-12:\n            return np.zeros_like(r)\n        \n        # Coefficients from derivation\n        C1_num = pi * a**2 - po * b**2\n        C1_den = b**2 - a**2\n        C1_factor = (1 + nu) * (1 - 2 * nu) / E\n        C1 = C1_factor * C1_num / C1_den\n\n        C2_num = (pi - po) * a**2 * b**2\n        C2_den = b**2 - a**2\n        C2_factor = (1 + nu) / E\n        C2 = C2_factor * C2_num / C2_den\n        \n        return C1 * r + C2 / r\n\n    def shape_functions(xi, eta):\n        \"\"\"Computes Q4 shape functions and their derivatives in local coordinates.\"\"\"\n        N = 0.25 * np.array([(1-xi)*(1-eta), (1+xi)*(1-eta), (1+xi)*(1+eta), (1-xi)*(1+eta)])\n        dNdxi = 0.25 * np.array([-(1-eta), (1-eta), (1+eta), -(1+eta)])\n        dNdeta = 0.25 * np.array([-(1-xi), -(1+xi), (1+xi), (1-xi)])\n        return N, dNdxi, dNdeta\n\n    def run_fem_case(a, b, L, pi, po, E, nu, Nr, Nz):\n        \"\"\"Runs a single FEM simulation case.\"\"\"\n        \n        # Material properties\n        lame_lambda = E * nu / ((1 + nu) * (1 - 2 * nu))\n        lame_mu = E / (2 * (1 + nu))\n\n        D = np.array([\n            [lame_lambda + 2*lame_mu, lame_lambda, lame_lambda, 0],\n            [lame_lambda, lame_lambda + 2*lame_mu, lame_lambda, 0],\n            [lame_lambda, lame_lambda, lame_lambda + 2*lame_mu, 0],\n            [0, 0, 0, lame_mu]\n        ])\n\n        # Mesh generation\n        num_nodes = (Nr + 1) * (Nz + 1)\n        num_elements = Nr * Nz\n        node_coords = np.zeros((num_nodes, 2))\n        r_nodes = np.linspace(a, b, Nr + 1)\n        z_nodes = np.linspace(0, L, Nz + 1)\n        \n        for i in range(Nr + 1):\n            for j in range(Nz + 1):\n                node_idx = i * (Nz + 1) + j\n                node_coords[node_idx] = [r_nodes[i], z_nodes[j]]\n\n        elements = np.zeros((num_elements, 4), dtype=int)\n        for i in range(Nr):\n            for j in range(Nz):\n                el_idx = i * Nz + j\n                n1 = i * (Nz + 1) + j\n                n2 = (i + 1) * (Nz + 1) + j\n                n3 = (i + 1) * (Nz + 1) + (j + 1)\n                n4 = i * (Nz + 1) + (j + 1)\n                elements[el_idx] = [n1, n2, n3, n4]\n        \n        # Assembly\n        num_dofs = 2 * num_nodes\n        K_global = np.zeros((num_dofs, num_dofs))\n        F_global = np.zeros(num_dofs)\n\n        # Element loop for stiffness matrix\n        for el_nodes in elements:\n            el_coords = node_coords[el_nodes]\n            Ke = np.zeros((8, 8))\n            \n            for gp_xi in gauss_pts_2d:\n                for gp_eta in gauss_pts_2d:\n                    N_vec, dNdxi_vec, dNdeta_vec = shape_functions(gp_xi, gp_eta)\n                    \n                    J = np.zeros((2, 2))\n                    J[0, 0] = np.dot(dNdxi_vec, el_coords[:, 0]) # dr/dxi\n                    J[0, 1] = np.dot(dNdxi_vec, el_coords[:, 1]) # dz/dxi\n                    J[1, 0] = np.dot(dNdeta_vec, el_coords[:, 0])# dr/deta\n                    J[1, 1] = np.dot(dNdeta_vec, el_coords[:, 1])# dz/deta\n\n                    detJ = np.linalg.det(J)\n                    invJ = np.linalg.inv(J)\n                    \n                    dN_drz = invJ @ np.vstack([dNdxi_vec, dNdeta_vec])\n                    dNdr_vec = dN_drz[0, :]\n                    dNdz_vec = dN_drz[1, :]\n                    \n                    r_gp = np.dot(N_vec, el_coords[:, 0])\n\n                    B = np.zeros((4, 8))\n                    for i in range(4):\n                        B[0, 2*i] = dNdr_vec[i]\n                        B[1, 2*i+1] = dNdz_vec[i]\n                        B[2, 2*i] = N_vec[i] / r_gp\n                        B[3, 2*i] = dNdz_vec[i]\n                        B[3, 2*i+1] = dNdr_vec[i]\n                    \n                    Ke += B.T @ D @ B * (2 * np.pi * r_gp) * detJ * 1.0 * 1.0 # weights are 1.0\n\n            # Assemble Ke into K_global\n            dof_indices = np.array([[2*n, 2*n+1] for n in el_nodes]).flatten()\n            K_global[np.ix_(dof_indices, dof_indices)] += Ke\n\n        # Boundary conditions (Traction)\n        # Inner pressure on r = a\n        if pi > 0:\n            for i in range(Nz):\n                el_idx = i\n                el_nodes = elements[el_idx] # these are elements [0, i]\n                # Edge is between node 1 (local) and 4 (local) i.e. xi = -1\n                edge_nodes = [el_nodes[0], el_nodes[3]]\n                edge_coords = node_coords[edge_nodes]\n                \n                Fe_trac = np.zeros(8)\n                t = np.array([pi, 0])\n                \n                dz_deta = (edge_coords[1, 1] - edge_coords[0, 1]) / 2.0\n                dl = np.sqrt(dz_deta**2)\n\n                for gp_eta in gauss_pts_1d:\n                    eta_local_edge = gp_eta\n                    xi_local_edge = -1.0\n                    N_vec, _, _ = shape_functions(xi_local_edge, eta_local_edge)\n                    r_gp = np.dot(N_vec, node_coords[el_nodes, 0])\n                    \n                    for i_node in range(4):\n                        Fe_trac[2*i_node:2*i_node+2] += N_vec[i_node] * t * (2*np.pi*r_gp) * dl * 1.0\n\n                dof_indices = np.array([[2*n, 2*n+1] for n in el_nodes]).flatten()\n                F_global[dof_indices] += Fe_trac\n\n        # Outer pressure on r = b\n        if po > 0:\n            for i in range(Nz):\n                el_idx = (Nr - 1) * Nz + i\n                el_nodes = elements[el_idx]\n                # Edge is between node 2 and 3 i.e. xi = 1\n                edge_nodes = [el_nodes[1], el_nodes[2]]\n                edge_coords = node_coords[edge_nodes]\n                \n                Fe_trac = np.zeros(8)\n                t = np.array([-po, 0])\n                \n                dz_deta = (edge_coords[1, 1] - edge_coords[0, 1]) / 2.0\n                dl = np.sqrt(dz_deta**2)\n                \n                for gp_eta in gauss_pts_1d:\n                    eta_local_edge = gp_eta\n                    xi_local_edge = 1.0\n                    N_vec, _, _ = shape_functions(xi_local_edge, eta_local_edge)\n                    r_gp = np.dot(N_vec, node_coords[el_nodes, 0])\n                    \n                    for i_node in range(4):\n                        Fe_trac[2*i_node:2*i_node+2] += N_vec[i_node] * t * (2*np.pi*r_gp) * dl * 1.0\n\n                dof_indices = np.array([[2*n, 2*n+1] for n in el_nodes]).flatten()\n                F_global[dof_indices] += Fe_trac\n        \n        # Enforce u_z = 0 for all nodes\n        for i in range(num_nodes):\n            dof = 2 * i + 1\n            K_global[dof, :] = 0\n            K_global[:, dof] = 0\n            K_global[dof, dof] = 1.0\n            F_global[dof] = 0\n        \n        # Solve system\n        U = np.linalg.solve(K_global, F_global)\n\n        # Error calculation\n        err_num_sq = 0.0\n        err_den_sq = 0.0\n        \n        for el_nodes in elements:\n            el_coords = node_coords[el_nodes]\n            el_dofs = np.array([[2*n, 2*n+1] for n in el_nodes]).flatten()\n            el_U = U[el_dofs]\n            el_Ur = el_U[::2]\n\n            for gp_xi in gauss_pts_2d:\n                for gp_eta in gauss_pts_2d:\n                    N_vec, dNdxi_vec, dNdeta_vec = shape_functions(gp_xi, gp_eta)\n                    \n                    J = np.zeros((2, 2))\n                    J[0, 0] = np.dot(dNdxi_vec, el_coords[:, 0])\n                    J[0, 1] = np.dot(dNdxi_vec, el_coords[:, 1])\n                    J[1, 0] = np.dot(dNdeta_vec, el_coords[:, 0])\n                    J[1, 1] = np.dot(dNdeta_vec, el_coords[:, 1])\n                    detJ = np.linalg.det(J)\n                    \n                    r_gp = np.dot(N_vec, el_coords[:, 0])\n                    \n                    u_h = np.dot(N_vec, el_Ur)\n                    u_an = analytical_displacement(r_gp, a, b, pi, po, E, nu)\n                    \n                    integrand_factor = 2 * np.pi * r_gp * detJ * 1.0 * 1.0\n\n                    err_num_sq += (u_h - u_an)**2 * integrand_factor\n                    err_den_sq += u_an**2 * integrand_factor\n\n        if err_den_sq  1e-30:\n            return 0.0\n            \n        return np.sqrt(err_num_sq / err_den_sq)\n\n\n    # Test cases\n    test_cases = [\n        # Case A\n        {'a': 0.3, 'b': 1.0, 'pi': 1.25e6, 'po': 0.0, 'E': 200e9, 'nu': 0.30, 'Nr': 8, 'Nz': 3, 'L': 1.0},\n        # Case B\n        {'a': 0.3, 'b': 1.0, 'pi': 1.25e6, 'po': 0.0, 'E': 200e9, 'nu': 0.30, 'Nr': 1, 'Nz': 1, 'L': 1.0},\n        # Case C\n        {'a': 0.3, 'b': 1.0, 'pi': 1.25e6, 'po': 0.60e6, 'E': 200e9, 'nu': 0.30, 'Nr': 6, 'Nz': 2, 'L': 1.0},\n        # Case D\n        {'a': 0.3, 'b': 1.0, 'pi': 1.25e6, 'po': 0.0, 'E': 200e9, 'nu': 0.49, 'Nr': 8, 'Nz': 2, 'L': 1.0}\n    ]\n\n    results = []\n    for case in test_cases:\n        error = run_fem_case(**case)\n        results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join([f'{r:.6f}' for r in results])}]\")\n\nsolve()\n\n```", "id": "2639858"}]}