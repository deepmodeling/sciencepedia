{"hands_on_practices": [{"introduction": "The direct calculation of displacements in structures with complex geometries or material variations can be challenging. This exercise introduces a powerful problem-solving strategy based on Betti's reciprocal theorem, where applying a simple, known auxiliary loading state to the structure allows for an elegant determination of a displacement of interest under a more complex real loading [@problem_id:2618422]. This practice hones your ability to leverage reciprocity as a practical analytical tool, a key skill in engineering diagnostics and analysis.", "problem": "A slender, prismatic, linearly elastic bar occupies the one-dimensional domain $x \\in [0,L]$. The axial displacement is $u(x)$, the axial force is $N(x)$, the Young’s modulus is $E$, and the cross-sectional area is $A$, all constant except in a symmetric notch neighborhood around a sensor at $x=a$, where the local axial stiffness is reduced. Specifically, in the interval $x \\in [a-c,\\,a+c]$, the effective product is $E A \\to \\eta E A$ with $0  \\eta  1$, while outside this interval the stiffness is $E A$. Assume $0  c  \\min\\{a,L-a\\}$ so that the notch lies strictly inside the bar. The left end is clamped, $u(0)=0$, and the right end is traction-free, $N(L)=0$. The bar is subjected to a uniform axial body force density $b_0$ (force per unit length) directed along $+x$ over the entire span $[0,L]$. No other external forces are applied.\n\nA displacement sensor at $x=a$ records the axial displacement $u(a)$. You are asked to determine $u(a)$ by employing Betti’s reciprocal theorem, using as an auxiliary state the response of the same notched bar to a unit axial point force applied at $x=a$ along $+x$. Begin from the fundamental statements of one-dimensional linear elasticity and equilibrium (including the definitions $N(x)=E A(x)\\,u'(x)$ and $N'(x) + b(x) = 0$), and use Clapeyron’s theorem of total strain energy to justify the reciprocity needed for the Betti identity. Derive the auxiliary displacement field $u^{(2)}(x)$ without quoting pre-tabulated influence functions, and evaluate the Betti relation to extract $u(a)$ for the real loading.\n\nProvide your final answer as a single closed-form analytic expression in terms of $L$, $a$, $c$, $\\eta$, $E$, $A$, and $b_0$. Express the displacement in meters. Do not substitute numerical values.", "solution": "The problem, as stated, is found to be a well-posed inquiry within the framework of one-dimensional linear elasticity. It is self-contained, consistent, and scientifically grounded. It does not violate any fundamental principles and contains all necessary information for a unique solution. Therefore, a solution will be furnished.\n\nThe problem requires the displacement at a point $x=a$ in a non-uniform bar due to a body force, to be found using Betti's reciprocal theorem. This requires defining two states of loading and response for the same elastic body.\n\nFirst, the theoretical foundation of Betti's theorem is established as requested, using Clapeyron's theorem. Consider two independent loading systems, denoted by superscript $(1)$ and $(2)$, applied to the same linearly elastic body. The body is defined by its stiffness distribution $K(x) = E A(x)$. Each loading system consists of body forces $b(x)$ and boundary tractions, resulting in displacement fields $u(x)$, strain fields $\\epsilon(x) = u'(x)$, and stress fields $N(x) = K(x)\\epsilon(x)$.\n\nThe total strain energy for a superposed state $(1+2)$ is $U_{1+2} = \\frac{1}{2}\\int_0^L N^{(1+2)}\\epsilon^{(1+2)} dx$. Due to linearity, $N^{(1+2)} = N^{(1)} + N^{(2)}$ and $\\epsilon^{(1+2)} = \\epsilon^{(1)} + \\epsilon^{(2)}$.\nExpanding the energy expression gives:\n$$U_{1+2} = \\frac{1}{2}\\int_0^L (N^{(1)} + N^{(2)})(\\epsilon^{(1)} + \\epsilon^{(2)}) dx = U_1 + U_2 + \\int_0^L N^{(1)}\\epsilon^{(2)} dx$$\nwhere $U_1 = \\frac{1}{2}\\int_0^L N^{(1)}\\epsilon^{(1)} dx$ and $U_2 = \\frac{1}{2}\\int_0^L N^{(2)}\\epsilon^{(2)} dx$ are the strain energies of the individual states. The interaction energy term is $U_{12} = \\int_0^L N^{(1)}\\epsilon^{(2)} dx$. Because the constitutive relation is linear, $N^{(1)} = K(x)\\epsilon^{(1)}$, the interaction energy can be written as $\\int_0^L K(x)\\epsilon^{(1)}\\epsilon^{(2)} dx$. The symmetry of this form implies $\\int_0^L N^{(1)}\\epsilon^{(2)} dx = \\int_0^L N^{(2)}\\epsilon^{(1)} dx$.\n\nThe work done by external forces is $W_{ext}$. For the superposed state, $W_{ext}^{(1+2)} = W_{ext}^{(1)} + W_{ext}^{(2)} + W_{12} + W_{21}$, where $W_{12}$ is the work of forces of state $(1)$ on the displacements of state $(2)$, and $W_{21}$ is the work of forces of state $(2)$ on the displacements of state $(1)$.\nClapeyron's theorem states $W_{ext} = 2U$. Applying this to states $(1)$, $(2)$, and $(1+2)$:\n$W_{ext}^{(1)} = 2U_1$, $W_{ext}^{(2)} = 2U_2$, and $W_{ext}^{(1+2)} = 2U_{1+2}$.\nSubstituting these into the expanded work expression:\n$$2U_1 + 2U_2 + W_{12} + W_{21} = 2(U_1 + U_2 + \\int_0^L N^{(1)}\\epsilon^{(2)} dx)$$\nThis simplifies to $W_{12} + W_{21} = 2 \\int_0^L N^{(1)}\\epsilon^{(2)} dx$.\nThe principle of virtual work states that the external work is equal to the internal work (strain energy change). Thus, $W_{12} = \\int_0^L N^{(1)}\\epsilon^{(2)} dx$.\nSubstituting this result leads to $W_{12} + W_{21} = 2 W_{12}$, which yields Betti's reciprocal theorem: $W_{12} = W_{21}$.\n\nWe define the two states for this problem:\n**State 1 (Real State):**\n- Loading: uniform body force $b^{(1)}(x) = b_0$.\n- Boundary conditions: $u^{(1)}(0) = 0$, $N^{(1)}(L) = 0$.\n- Resulting fields: $u^{(1)}(x)$, $N^{(1)}(x)$. The quantity to be found is $u^{(1)}(a)$.\n\n**State 2 (Auxiliary State):**\n- Loading: unit point force at $x=a$, represented by a body force $b^{(2)}(x) = \\delta(x-a)$, where $\\delta$ is the Dirac delta function.\n- Boundary conditions: $u^{(2)}(0) = 0$, $N^{(2)}(L) = 0$.\n- Resulting fields: $u^{(2)}(x)$, $N^{(2)}(x)$.\n\nThe work expressions are:\n$W_{12} = \\int_0^L b^{(1)}(x) u^{(2)}(x) dx + [N^{(1)}(x) u^{(2)}(x)]_0^L$\n$W_{21} = \\int_0^L b^{(2)}(x) u^{(1)}(x) dx + [N^{(2)}(x) u^{(1)}(x)]_0^L$\n\nEvaluating these terms with the specified conditions:\nFor $W_{12}$: $[N^{(1)}(x) u^{(2)}(x)]_0^L = N^{(1)}(L)u^{(2)}(L) - N^{(1)}(0)u^{(2)}(0) = (0)u^{(2)}(L) - N^{(1)}(0)(0) = 0$.\nThus, $W_{12} = \\int_0^L b_0 u^{(2)}(x) dx = b_0 \\int_0^L u^{(2)}(x) dx$.\n\nFor $W_{21}$: $\\int_0^L b^{(2)}(x) u^{(1)}(x) dx = \\int_0^L \\delta(x-a) u^{(1)}(x) dx = u^{(1)}(a)$.\nThe boundary term is $[N^{(2)}(x) u^{(1)}(x)]_0^L = N^{(2)}(L)u^{(1)}(L) - N^{(2)}(0)u^{(1)}(0) = (0)u^{(1)}(L) - N^{(2)}(0)(0) = 0$.\nThus, $W_{21} = u^{(1)}(a)$.\n\nEquating $W_{12} = W_{21}$ gives the central relation:\n$$u^{(1)}(a) = b_0 \\int_0^L u^{(2)}(x) dx$$\n\nThe problem is now reduced to finding the auxiliary displacement field $u^{(2)}(x)$ and integrating it over the domain.\nFor State 2, the equilibrium equation for the axial force $N^{(2)}(x)$ is $N^{(2)'}(x) + b^{(2)}(x) = 0$, which is $N^{(2)'}(x) = -\\delta(x-a)$.\nIntegrating from $x$ to $L$: $\\int_x^L N^{(2)'}(\\xi) d\\xi = -\\int_x^L \\delta(\\xi-a) d\\xi$.\n$N^{(2)}(L) - N^{(2)}(x) = -1$ if $x  a  L$, and $0$ if $a  x  L$.\nWith $N^{(2)}(L)=0$, we get $N^{(2)}(x) = 1$ for $xa$ and $N^{(2)}(x)=0$ for $xa$.\n\nThe displacement $u^{(2)}(x)$ is found by integrating the strain, $u^{(2)'}(x) = N^{(2)}(x)/K(x)$, with the boundary condition $u^{(2)}(0)=0$. The stiffness $K(x)$ is piecewise:\n$$K(x) = \\begin{cases} EA  0 \\le x  a-c \\\\ \\eta EA  a-c \\le x  a+c \\\\ EA  a+c \\le x \\le L \\end{cases}$$\nWe integrate $u^{(2)'}(x)$ piecewise:\n- For $0 \\le x  a-c$: $u^{(2)'}(x) = \\frac{1}{EA}$. $u^{(2)}(x) = \\frac{x}{EA}$.\n- For $a-c \\le x  a$: $u^{(2)'}(x) = \\frac{1}{\\eta EA}$. $u^{(2)}(x) = u^{(2)}(a-c) + \\int_{a-c}^x \\frac{d\\xi}{\\eta EA} = \\frac{a-c}{EA} + \\frac{x-(a-c)}{\\eta EA}$.\n- For $a \\le x \\le L$: $u^{(2)'}(x) = \\frac{0}{K(x)} = 0$. $u^{(2)}(x)$ is constant for $x \\ge a$. Its value is $u^{(2)}(a)$.\n$u^{(2)}(a) = u^{(2)}_{x \\to a^-} = \\frac{a-c}{EA} + \\frac{a-(a-c)}{\\eta EA} = \\frac{1}{EA}\\left(a-c + \\frac{c}{\\eta}\\right)$. Thus, for $x \\ge a$, $u^{(2)}(x) = \\frac{1}{EA}\\left(a-c+\\frac{c}{\\eta}\\right)$.\n\nThe required integral $I = \\int_0^L u^{(2)}(x) dx$ is calculated by superposition. Let $u^{(2)}(x) = u^{(2)}_{unif}(x) + \\Delta u^{(2)}(x)$, where $u^{(2)}_{unif}(x)$ is the solution for a uniform bar ($\\eta=1, c=0$), and $\\Delta u^{(2)}(x)$ is the additional displacement due to the notch.\nFor a uniform bar, $u^{(2)}_{unif}(x) = \\frac{1}{EA}\\min(x,a)$. The integral is:\n$I_{unif} = \\int_0^L u^{(2)}_{unif}(x) dx = \\int_0^a \\frac{x}{EA} dx + \\int_a^L \\frac{a}{EA} dx = \\frac{1}{EA}\\left[\\frac{a^2}{2} + a(L-a) \\right] = \\frac{a(2L-a)}{2EA}$.\n\nThe additional displacement $\\Delta u^{(2)}(x)$ is non-zero only for $x > a-c$:\n- For $a-c \\le x  a$: $\\Delta u^{(2)}(x) = u^{(2)}(x) - u^{(2)}_{unif}(x) = \\frac{1}{EA}\\left(a-c+\\frac{x-a+c}{\\eta} - x\\right) = \\frac{x-a+c}{EA}\\left(\\frac{1}{\\eta}-1\\right)$.\n- For $x \\ge a$: $\\Delta u^{(2)}(x) = u^{(2)}(x) - u^{(2)}_{unif}(x) = \\frac{1}{EA}\\left(a-c+\\frac{c}{\\eta} - a\\right) = \\frac{c}{EA}\\left(\\frac{1}{\\eta}-1\\right)$.\n\nThe integral of the additional displacement is:\n$\\Delta I = \\int_{a-c}^a \\frac{x-a+c}{EA}\\left(\\frac{1}{\\eta}-1\\right) dx + \\int_a^L \\frac{c}{EA}\\left(\\frac{1}{\\eta}-1\\right) dx$\n$\\Delta I = \\frac{1}{EA}\\left(\\frac{1}{\\eta}-1\\right) \\left[ \\int_{a-c}^a (x-a+c) dx + \\int_a^L c \\,dx \\right]$\n$\\Delta I = \\frac{1}{EA}\\left(\\frac{1}{\\eta}-1\\right) \\left[ \\left[\\frac{(x-a+c)^2}{2}\\right]_{a-c}^a + [cx]_a^L \\right]$\n$\\Delta I = \\frac{1}{EA}\\left(\\frac{1}{\\eta}-1\\right) \\left[ \\frac{c^2}{2} + c(L-a) \\right] = \\frac{c}{EA}\\left(\\frac{1}{\\eta}-1\\right)\\left(L-a+\\frac{c}{2}\\right)$.\n\nThe total integral is $I = I_{unif} + \\Delta I$:\n$$I = \\frac{1}{EA}\\left[ \\frac{a(2L-a)}{2} + c\\left(\\frac{1}{\\eta}-1\\right)\\left(L-a+\\frac{c}{2}\\right) \\right]$$\n\nFinally, the displacement at the sensor is $u^{(1)}(a) = u(a) = b_0 I$. The units of the expression are dimensionally correct for length, which will be expressed in meters if all input quantities are in consistent SI units.\n$$u(a) = \\frac{b_0}{EA}\\left[ \\frac{a(2L-a)}{2} + c\\left(\\frac{1}{\\eta}-1\\right)\\left(L-a+\\frac{c}{2}\\right) \\right]$$", "answer": "$$\\boxed{\\frac{b_0}{EA} \\left[ \\frac{a(2L-a)}{2} + c \\left( \\frac{1}{\\eta} - 1 \\right) \\left( L - a + \\frac{c}{2} \\right) \\right]}$$", "id": "2618422"}, {"introduction": "The abstract elegance of Clapeyron's and Betti's theorems finds concrete expression in the computational methods that dominate modern structural analysis, primarily the Finite Element Method (FEM). This exercise involves building an FEM model to numerically verify that for a linear elastic system, the path-independent strain energy $U$ is equal to $\\frac{1}{2}\\mathbf{P}\\cdot\\mathbf{u}$ and that the reciprocal work terms between different load cases are equal [@problem_id:2618428]. This computational practice bridges theory and application, building confidence in both the underlying principles and the numerical methods used to implement them.", "problem": "You are to write a complete, runnable program that performs a numerical experiment on a linear finite element model of a planar truss to compare the total strain energy computed from element strains, denoted $U$, against the scalar quantity $\\tfrac{1}{2}\\,\\mathbf{P}\\cdot\\mathbf{u}$ evaluated at the final load state under multiple loading paths. The goal is to assess the equivalence predicted by Clapeyron's theorem in small-strain linear elasticity and to check Betti's reciprocal theorem by comparing mixed work terms between two distinct loadings.\n\nThe program must be self-contained and must build and analyze a specific two-dimensional truss using the following foundational modeling assumptions only: static equilibrium in the absence of inertia and damping, small displacements and small strains, linear elastic material with Young's modulus $E$ and cross-sectional area $A$, and standard two-node bar (truss) elements that carry only axial force. Use the finite element method to assemble the global stiffness matrix $\\mathbf{K}$ and to solve for nodal displacements $\\mathbf{u}$ from $\\mathbf{K}\\mathbf{u}=\\mathbf{P}$ after imposing essential (Dirichlet) boundary conditions. Compute element strains from nodal displacements through the axial deformation and direction cosines, and compute $U$ by integrating the strain energy density over the element volumes.\n\nGeometry, material, and units:\n- Nodes are in the plane with coordinates in meters. There are four nodes with labels and coordinates\n  - Node $1$: $(0,0)$,\n  - Node $2$: $(1,0)$,\n  - Node $3$: $(1,1)$,\n  - Node $4$: $(0,1)$.\n- Elements connect the following node pairs: $(1,2)$, $(2,3)$, $(3,4)$, $(4,1)$, $(1,3)$, $(2,4)$.\n- Material and section properties: Young's modulus $E = 210\\times 10^9$ $\\mathrm{Pa}$, cross-sectional area $A=1\\times 10^{-4}$ $\\mathrm{m}^2$.\n- Degrees of freedom are ordered as $[u_{1x},u_{1y},u_{2x},u_{2y},u_{3x},u_{3y},u_{4x},u_{4y}]$ in meters.\n- Boundary conditions: enforce $u_{1x}=0$, $u_{1y}=0$, and $u_{4x}=0$.\n\nLoads and paths (forces in Newtons, displacements in meters, energy to be expressed in Joules):\n- Define two final load vectors $\\mathbf{P}^{(A)}$ and $\\mathbf{P}^{(B)}$ in the stated degree-of-freedom order, with all unspecified components equal to zero:\n  - $\\mathbf{P}^{(A)}$ has a horizontal force at node $2$ of $+5000$ $\\mathrm{N}$ and a vertical force at node $3$ of $-10000$ $\\mathrm{N}$, i.e., the only nonzero entries are $P^{(A)}_{3}=5000$ and $P^{(A)}_{6}=-10000$.\n  - $\\mathbf{P}^{(B)}$ has a horizontal force at node $3$ of $+8000$ $\\mathrm{N}$ and a vertical force at node $2$ of $-6000$ $\\mathrm{N}$, i.e., the only nonzero entries are $P^{(B)}_{5}=8000$ and $P^{(B)}_{4}=-6000$.\n- Consider the following load paths, each path being a sequence of load-vector endpoints from the zero vector to the final vector. Within each increment, the load is taken to vary linearly between its endpoints:\n  - Path $\\mathcal{P}_1$ (proportional for $\\mathbf{P}^{(A)}$): a single increment from $\\mathbf{0}$ to $\\mathbf{P}^{(A)}$.\n  - Path $\\mathcal{P}_2$ (two-step nonproportional for $\\mathbf{P}^{(A)}$): increment $1$ from $\\mathbf{0}$ to $\\mathbf{q}_1$, with $\\mathbf{q}_1$ equal to $\\mathbf{P}^{(A)}$ but with only the vertical load at node $3$ active, i.e., $q_{1,6}=-10000$; increment $2$ from $\\mathbf{q}_1$ to $\\mathbf{P}^{(A)}$ by activating the horizontal load at node $2$.\n  - Path $\\mathcal{P}_3$ (reverse two-step nonproportional for $\\mathbf{P}^{(A)}$): increment $1$ from $\\mathbf{0}$ to $\\mathbf{r}_1$, with $\\mathbf{r}_1$ equal to $\\mathbf{P}^{(A)}$ but with only the horizontal load at node $2$ active, i.e., $r_{1,3}=5000$; increment $2$ from $\\mathbf{r}_1$ to $\\mathbf{P}^{(A)}$ by activating the vertical load at node $3$.\n  - Path $\\mathcal{P}_4$ (edge case zero load): a single increment from $\\mathbf{0}$ to $\\mathbf{0}$.\n  - Path $\\mathcal{P}_5$ (three-step nonproportional for $\\mathbf{P}^{(B)}$): increment $1$ from $\\mathbf{0}$ to $\\mathbf{s}_1$ with only the horizontal load at node $3$ active, $s_{1,5}=8000$; increment $2$ from $\\mathbf{s}_1$ to $\\mathbf{s}_2$ where $\\mathbf{s}_2$ adds half the vertical load at node $2$, $s_{2,4}=-3000$; increment $3$ from $\\mathbf{s}_2$ to $\\mathbf{P}^{(B)}$ by adding the remaining half, reaching $s_{3,4}=-6000$.\n- For Betti's reciprocal theorem (two load cases), use $\\mathbf{P}^{(A)}$ and $\\mathbf{P}^{(B)}$ as defined above.\n\nComputations to perform:\n- Assemble the global stiffness matrix $\\mathbf{K}$ from element contributions using standard two-dimensional truss element stiffness with direction cosines. Impose boundary conditions by eliminating constrained degrees of freedom.\n- For each path $\\mathcal{P}_k$, compute the final displacement $\\mathbf{u}_f$ at the final load of the path by solving $\\mathbf{K}\\mathbf{u}_f=\\mathbf{P}_f$ with the above boundary conditions enforced. From $\\mathbf{u}_f$, compute the total internal strain energy $U$ by summing, over all elements, the expression\n  $$U_e = \\tfrac{1}{2}\\,\\dfrac{E A}{L_e}\\,\\Delta_e^2,$$\n  where $L_e$ is the element length and $\\Delta_e$ is the axial extension of element $e$ extracted from the nodal displacements along the element axis. Then compute the scalar $\\tfrac{1}{2}\\,\\mathbf{P}_f\\cdot\\mathbf{u}_f$. Report the absolute difference $|U - \\tfrac{1}{2}\\,\\mathbf{P}_f\\cdot\\mathbf{u}_f|$ in Joules as the test result for that path.\n- For Betti's reciprocal theorem, solve $\\mathbf{K}\\mathbf{u}^{(A)}=\\mathbf{P}^{(A)}$ and $\\mathbf{K}\\mathbf{u}^{(B)}=\\mathbf{P}^{(B)}$ under the same boundary conditions, and report the absolute difference $|\\mathbf{P}^{(A)}\\cdot\\mathbf{u}^{(B)} - \\mathbf{P}^{(B)}\\cdot\\mathbf{u}^{(A)}|$ in Joules.\n\nTest suite:\n- The program must compute and return the following six results as floating-point numbers in Joules, in this order:\n  1) $|U - \\tfrac{1}{2}\\,\\mathbf{P}^{(A)}\\cdot\\mathbf{u}_f|$ for path $\\mathcal{P}_1$,\n  2) $|U - \\tfrac{1}{2}\\,\\mathbf{P}^{(A)}\\cdot\\mathbf{u}_f|$ for path $\\mathcal{P}_2$,\n  3) $|U - \\tfrac{1}{2}\\,\\mathbf{P}^{(A)}\\cdot\\mathbf{u}_f|$ for path $\\mathcal{P}_3$,\n  4) $|U - \\tfrac{1}{2}\\,\\mathbf{0}\\cdot\\mathbf{0}|$ for path $\\mathcal{P}_4$,\n  5) $|U - \\tfrac{1}{2}\\,\\mathbf{P}^{(B)}\\cdot\\mathbf{u}_f|$ for path $\\mathcal{P}_5$,\n  6) $|\\mathbf{P}^{(A)}\\cdot\\mathbf{u}^{(B)} - \\mathbf{P}^{(B)}\\cdot\\mathbf{u}^{(A)}|$.\n\nAll energies and work quantities must be expressed in Joules.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the precise order given above, for example, \"[$r_1,r_2,r_3,r_4,r_5,r_6$]\". Values must be decimal floating-point numbers in Joules. No other text should be printed.", "solution": "The problem requires the numerical verification of two fundamental theorems of linear elastostatics—Clapeyron's theorem and Betti's reciprocal theorem—using a finite element model of a planar truss. The validation of the problem statement finds it to be scientifically sound, well-posed, objective, and complete. All necessary data for building and analyzing the specified truss structure are provided. The problem is a valid and instructive exercise in computational mechanics. We proceed with the solution.\n\nThe theoretical foundation is the principle of linear elastostatics, which assumes a linear relationship between applied forces and resulting displacements, expressed as $\\mathbf{K}\\mathbf{u} = \\mathbf{P}$. Here, $\\mathbf{P}$ is the vector of nodal forces, $\\mathbf{u}$ is the vector of nodal displacements, and $\\mathbf{K}$ is the global stiffness matrix of the structure, which is constant for a given geometry and material. This system is assumed to be conservative, meaning the work done by internal forces (stresses) is stored as recoverable strain energy, $U$.\n\nFor a two-dimensional truss element $e$ connecting nodes $i$ and $j$, with Young's modulus $E$, cross-sectional area $A$, and length $L_e$, the element stiffness matrix $\\mathbf{k}_e$ in the global coordinate system is a $4 \\times 4$ matrix relating the nodal forces and displacements at its ends. Its components are determined by $E$, $A$, $L_e$, and the direction cosines $c = \\cos\\theta$ and $s = \\sin\\theta$, where $\\theta$ is the angle of the element axis with the global x-axis. The matrix is given by:\n$$\n\\mathbf{k}_e = \\frac{EA}{L_e}\n\\begin{bmatrix}\nc^2  cs  -c^2  -cs \\\\\ncs  s^2  -cs  -s^2 \\\\\n-c^2  -cs  c^2  cs \\\\\n-cs  -s^2  cs  s^2\n\\end{bmatrix}\n$$\nThe global stiffness matrix $\\mathbf{K}$ for the entire truss is an $8 \\times 8$ matrix, as there are $4$ nodes each with $2$ degrees of freedom (DOFs), $[u_{1x}, u_{1y}, u_{2x}, u_{2y}, u_{3x}, u_{3y}, u_{4x}, u_{4y}]$. It is assembled by summing the contributions of each element stiffness matrix $\\mathbf{k}_e$ into the appropriate locations corresponding to the DOFs of the nodes it connects.\n\nThe specified boundary conditions are $u_{1x}=0$, $u_{1y}=0$, and $u_{4x}=0$. These correspond to DOFs with indices $0$, $1$, and $6$ (using $0$-based indexing). To solve for the unknown displacements, the system $\\mathbf{K}\\mathbf{u}=\\mathbf{P}$ is partitioned into free and constrained DOFs. Since the constrained displacements are zero, the system reduces to $\\mathbf{K}_{ff}\\mathbf{u}_f = \\mathbf{P}_f$, where the subscript $f$ denotes the sub-matrices and sub-vectors corresponding to the free DOFs. This reduced linear system is non-singular for a stable structure and can be solved for the unknown displacements $\\mathbf{u}_f$.\n\nClapeyron's theorem states that for a linear elastic system, the total strain energy $U$ stored in the body is equal to one-half the work done by the external forces $\\mathbf{P}$ applied proportionally from zero to their final values, which is $W_{ext} = \\tfrac{1}{2}\\,\\mathbf{P} \\cdot \\mathbf{u}$. Mathematically, $U = \\tfrac{1}{2}\\,\\mathbf{P} \\cdot \\mathbf{u}$. A key property of a conservative system is that the strain energy $U$ is a state function, depending only on the final displacement configuration $\\mathbf{u}$, not on the load path taken to reach it. The problem requires computing $U$ by summing the element strain energies:\n$$\nU = \\sum_{e} U_e = \\sum_{e} \\frac{1}{2} \\frac{EA}{L_e} \\Delta_e^2\n$$\nwhere $\\Delta_e$ is the axial elongation of element $e$, calculated from the nodal displacements as $\\Delta_e = (u_{jx}-u_{ix})c + (u_{jy}-u_{iy})s$. The problem tests the theorem by comparing this path-independent quantity $U$ with the value $\\tfrac{1}{2}\\,\\mathbf{P}_f \\cdot \\mathbf{u}_f$ for several load paths. For paths $\\mathcal{P}_1$, $\\mathcal{P}_2$, and $\\mathcal{P}_3$, the final load is $\\mathbf{P}^{(A)}$. Since the final state is identical, the final displacement $\\mathbf{u}^{(A)}$ and strain energy $U^{(A)}$ must be identical. Therefore, the quantity $|U - \\tfrac{1}{2}\\mathbf{P}^{(A)}\\cdot\\mathbf{u}^{(A)}|$ will be the same for the first three test cases, and should be zero within numerical precision. The case with zero load is trivial, resulting in zero energy and work.\n\nBetti's reciprocal theorem compares two independent equilibrium states of the same linear elastic body. Let state (A) be defined by forces $\\mathbf{P}^{(A)}$ and resulting displacements $\\mathbf{u}^{(A)}$, and state (B) by forces $\\mathbf{P}^{(B)}$ and displacements $\\mathbf{u}^{(B)}$. The theorem states that the work done by the first set of forces acting through the displacements of the second set is equal to the work done by the second set of forces acting through the displacements of the first set. That is:\n$$\n\\mathbf{P}^{(A)} \\cdot \\mathbf{u}^{(B)} = \\mathbf{P}^{(B)} \\cdot \\mathbf{u}^{(A)}\n$$\nThe final computation verifies this identity by calculating the absolute difference between these two mixed work terms.\n\nThe solution proceeds as follows:\n1. Define the geometry, material properties ($E=210 \\times 10^9\\,\\mathrm{Pa}$, $A=1 \\times 10^{-4}\\,\\mathrm{m}^2$), and element connectivity.\n2. Construct the $8 \\times 8$ global stiffness matrix $\\mathbf{K}$ by iterating through the six elements, calculating each $\\mathbf{k}_e$, and adding it to $\\mathbf{K}$.\n3. Identify the indices of the constrained DOFs ($0, 1, 6$) and the free DOFs ($2, 3, 4, 5, 7$).\n4. Partition $\\mathbf{K}$ to obtain the $5 \\times 5$ reduced stiffness matrix $\\mathbf{K}_{ff}$.\n5. Define the full $8 \\times 1$ load vectors $\\mathbf{P}^{(A)}$ and $\\mathbf{P}^{(B)}$ and extract the corresponding $5 \\times 1$ vectors of forces on the free DOFs, $\\mathbf{P}^{(A)}_f$ and $\\mathbf{P}^{(B)}_f$.\n6. Solve the linear systems $\\mathbf{K}_{ff}\\mathbf{u}^{(A)}_f = \\mathbf{P}^{(A)}_f$ and $\\mathbf{K}_{ff}\\mathbf{u}^{(B)}_f = \\mathbf{P}^{(B)}_f$ to obtain the unknown displacement components.\n7. Reconstruct the full displacement vectors $\\mathbf{u}^{(A)}$ and $\\mathbf{u}^{(B)}$ by filling in the known zero values for the constrained DOFs.\n8. For load case (A), calculate the total strain energy $U^{(A)}$ by summing element contributions and the work term $W^{(A)}_{ext} = \\tfrac{1}{2}\\,\\mathbf{P}^{(A)}\\cdot\\mathbf{u}^{(A)}$. The absolute difference gives the result for the first three test cases.\n9. For the zero-load case, the result is trivially $0$.\n10. For load case (B), calculate $U^{(B)}$ and $W_{ext}^{(B)} = \\tfrac{1}{2}\\,\\mathbf{P}^{(B)}\\cdot\\mathbf{u}^{(B)}$. The absolute difference is the fifth result.\n11. Finally, compute the mixed work terms $\\mathbf{P}^{(A)}\\cdot\\mathbf{u}^{(B)}$ and $\\mathbf{P}^{(B)}\\cdot\\mathbf{u}^{(A)}$ and their absolute difference for the sixth result. All calculated differences are expected to be nearly zero.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Performs a numerical experiment on a planar truss to verify Clapeyron's\n    and Betti's theorems using the finite element method.\n    \"\"\"\n    # 1. Define constants, geometry, and material properties\n    E = 210e9  # Young's modulus in Pa\n    A = 1e-4   # Cross-sectional area in m^2\n\n    # Node coordinates in meters. Node labels are 1-based, indices are 0-based.\n    nodes = np.array([\n        [0.0, 0.0],  # Node 1\n        [1.0, 0.0],  # Node 2\n        [1.0, 1.0],  # Node 3\n        [0.0, 1.0],  # Node 4\n    ])\n\n    # Element connectivity using 0-based node indices.\n    elements = np.array([\n        [0, 1],  # Element 1-2\n        [1, 2],  # Element 2-3\n        [2, 3],  # Element 3-4\n        [3, 0],  # Element 4-1\n        [0, 2],  # Element 1-3 (diagonal)\n        [1, 3],  # Element 2-4 (diagonal)\n    ])\n\n    # 2. Assemble the global stiffness matrix K\n    num_nodes = nodes.shape[0]\n    num_dofs = 2 * num_nodes\n    K = np.zeros((num_dofs, num_dofs))\n\n    # Store element properties (L, c, s) for later strain energy calculation\n    element_props = []\n\n    for node1_idx, node2_idx in elements:\n        # Get nodal coordinates\n        n1_coords = nodes[node1_idx]\n        n2_coords = nodes[node2_idx]\n        \n        # Calculate element length and direction cosines\n        dx = n2_coords[0] - n1_coords[0]\n        dy = n2_coords[1] - n1_coords[1]\n        L = np.sqrt(dx**2 + dy**2)\n        c = dx / L\n        s = dy / L\n        element_props.append({'L': L, 'c': c, 's': s})\n\n        # Element stiffness matrix in global coordinates\n        c2 = c * c\n        s2 = s * s\n        cs = c * s\n        k_e_factor = E * A / L\n        k_e = k_e_factor * np.array([\n            [ c2,  cs, -c2, -cs],\n            [ cs,  s2, -cs, -s2],\n            [-c2, -cs,  c2,  cs],\n            [-cs, -s2,  cs,  s2]\n        ])\n\n        # Assemble k_e into global K\n        dof_indices = [2*node1_idx, 2*node1_idx + 1, 2*node2_idx, 2*node2_idx + 1]\n        for i_local in range(4):\n            for j_local in range(4):\n                i_global = dof_indices[i_local]\n                j_global = dof_indices[j_local]\n                K[i_global, j_global] += k_e[i_local, j_local]\n\n    # 3. Apply boundary conditions by partitioning the system\n    # Constrained DOFs: u_1x (idx 0), u_1y (idx 1), u_4x (idx 6)\n    constrained_dofs = [0, 1, 6]\n    all_dofs = list(range(num_dofs))\n    free_dofs = [dof for dof in all_dofs if dof not in constrained_dofs]\n\n    # Extract the submatrix K_ff for free DOFs\n    K_ff = K[np.ix_(free_dofs, free_dofs)]\n\n    # 4. Define load vectors\n    P_A_full = np.zeros(num_dofs)\n    P_A_full[2] = 5000.0   # u_2x component\n    P_A_full[5] = -10000.0 # u_3y component\n\n    P_B_full = np.zeros(num_dofs)\n    P_B_full[4] = 8000.0   # u_3x component\n    P_B_full[3] = -6000.0  # u_2y component\n    \n    # Extract forces applied to free DOFs\n    P_A_free = P_A_full[free_dofs]\n    P_B_free = P_B_full[free_dofs]\n\n    # 5. Solve for displacements\n    u_A_free = np.linalg.solve(K_ff, P_A_free)\n    u_B_free = np.linalg.solve(K_ff, P_B_free)\n\n    # Reconstruct full displacement vectors\n    u_A_full = np.zeros(num_dofs)\n    u_A_full[free_dofs] = u_A_free\n\n    u_B_full = np.zeros(num_dofs)\n    u_B_full[free_dofs] = u_B_free\n\n    # 6. Perform computations for the test suite\n    \n    def calculate_strain_energy(u_full, elem_list, elem_prop_list):\n        total_U = 0.0\n        for i, (node1_idx, node2_idx) in enumerate(elem_list):\n            props = elem_prop_list[i]\n            L, c, s = props['L'], props['c'], props['s']\n            \n            u1x, u1y = u_full[2 * node1_idx], u_full[2 * node1_idx + 1]\n            u2x, u2y = u_full[2 * node2_idx], u_full[2 * node2_idx + 1]\n            \n            # Element elongation\n            delta_e = (u2x - u1x) * c + (u2y - u1y) * s\n            \n            # Element strain energy\n            U_e = 0.5 * (E * A / L) * delta_e**2\n            total_U += U_e\n        return total_U\n\n    # Test cases 1, 2, 3: Clapeyron's theorem for Load Case A\n    # All paths P1, P2, P3 lead to the same final state (P_A, u_A).\n    U_A = calculate_strain_energy(u_A_full, elements, element_props)\n    W_ext_A = 0.5 * np.dot(P_A_full, u_A_full)\n    clapeyron_diff_A = abs(U_A - W_ext_A)\n\n    # Test case 4: Zero load\n    clapeyron_diff_zero = 0.0\n\n    # Test case 5: Clapeyron's theorem for Load Case B\n    U_B = calculate_strain_energy(u_B_full, elements, element_props)\n    W_ext_B = 0.5 * np.dot(P_B_full, u_B_full)\n    clapeyron_diff_B = abs(U_B - W_ext_B)\n\n    # Test case 6: Betti's reciprocal theorem\n    work_AB = np.dot(P_A_full, u_B_full)\n    work_BA = np.dot(P_B_full, u_A_full)\n    betti_diff = abs(work_AB - work_BA)\n\n    results = [\n        clapeyron_diff_A,       # Result 1 (Path P1)\n        clapeyron_diff_A,       # Result 2 (Path P2)\n        clapeyron_diff_A,       # Result 3 (Path P3)\n        clapeyron_diff_zero,    # Result 4 (Path P4)\n        clapeyron_diff_B,       # Result 5 (Path P5)\n        betti_diff              # Result 6 (Betti's Theorem)\n    ]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2618428"}, {"introduction": "While Betti's theorem is a cornerstone of linear elastic analysis, its applicability has clear boundaries defined by the system's constitutive behavior. This advanced computational practice explores one such boundary: material inelasticity [@problem_id:2618402]. By simulating the response of an elastoplastic bar, you will investigate how path-dependent plastic deformation and associated energy dissipation cause a quantitative breakdown of reciprocity. This exercise provides a profound insight into the physical reasons for the theorem's limitations and highlights the importance of critically evaluating the assumptions behind our analytical tools.", "problem": "Consider a small-strain, one-dimensional, axially loaded bar discretized into $2$ linear axial elements and $3$ nodes indexed by $i \\in \\{0,1,2\\}$. Node $i=0$ is fixed (essential boundary condition $u_0=0$), and nodes $i=1,2$ are free. Let element $e=1$ connect nodes $(0,1)$ and element $e=2$ connect nodes $(1,2)$. The bar has spatially piecewise-constant properties per element: length $L_e$, cross-sectional area $A_e$, Young’s modulus $E_e$, initial yield stress $\\sigma_{y0,e}$, and linear isotropic hardening modulus $H_e$. Assume small strains, quasi-static evolution, and a rate-independent, bilinear elastoplastic constitutive law with linear isotropic hardening. The strain in element $e$ is $\\varepsilon_e = (u_j - u_i)/L_e$, where $(i,j)$ are the end nodes of element $e$. The Cauchy stress $\\sigma_e$ follows the additive decomposition $\\varepsilon_e = \\varepsilon_{e}^e + \\varepsilon_{e}^p$ with linear elasticity $\\sigma_e = E_e \\varepsilon_{e}^e$ and the standard one-dimensional $J_2$-type yield condition $f_e = |\\sigma_e| - (\\sigma_{y0,e} + H_e \\alpha_e) \\le 0$, where $\\alpha_e$ is the accumulated plastic strain. At each load increment, enforce global equilibrium of internal and external nodal forces (Principle of Virtual Work) and perform a consistent return-mapping integration of the local constitutive equations to update $(\\sigma_e,\\varepsilon_{e}^p,\\alpha_e)$ while satisfying the Karush–Kuhn–Tucker conditions. Use a Newton-type iteration with the element algorithmic tangent to solve the nonlinear equilibrium equations at each load step.\n\nBetti’s reciprocal theorem states that for a linear elastic system with symmetric stiffness, for any two statically admissible loadings $\\mathbf{P}^{(1)}$ and $\\mathbf{P}^{(2)}$ applied to the same structure, the equality $\\mathbf{P}^{(1)} \\cdot \\mathbf{u}^{(2)} = \\mathbf{P}^{(2)} \\cdot \\mathbf{u}^{(1)}$ holds, where $\\mathbf{u}^{(k)}$ is the displacement field caused by $\\mathbf{P}^{(k)}$. In elastoplastic systems with path-dependent internal variables, reciprocity can break down.\n\nDesign and implement a computational test that, given two independent load cases (histories) applied to the same virgin bar, computes the final displacement vectors $\\mathbf{u}^{(1)}$ and $\\mathbf{u}^{(2)}$, and evaluates the scalar quantities $\\mathbf{P}^{(1)} \\cdot \\mathbf{u}^{(2)}$ and $\\mathbf{P}^{(2)} \\cdot \\mathbf{u}^{(1)}$ at the final step of each load case. Here, the dot product is taken over free nodal degrees of freedom ($i=1,2$). Report the difference $\\Delta = \\mathbf{P}^{(1)} \\cdot \\mathbf{u}^{(2)} - \\mathbf{P}^{(2)} \\cdot \\mathbf{u}^{(1)}$ for each test instance to quantify reciprocity breakdown.\n\nFundamental base to use:\n- Balance of linear momentum in quasi-static form (sum of internal nodal forces equals external nodal forces at each step).\n- Compatibility of axial strains: $\\varepsilon_e = (u_j - u_i)/L_e$.\n- Linear elasticity in the elastic range: $\\sigma_e = E_e (\\varepsilon_e - \\varepsilon_{e}^p)$ with $\\varepsilon_{e}^p$ the plastic strain.\n- Standard one-dimensional elastoplasticity with linear isotropic hardening, yield condition $f_e \\le 0$, consistency, and return mapping at each increment.\n- Principle of Virtual Work for assembling internal forces and algorithmic tangent stiffness: element internal nodal forces equal $\\int_0^{L_e} \\mathbf{B}_e^\\top \\sigma_e A_e \\, dx$ with $\\mathbf{B}_e = [-1/L_e, 1/L_e]$, and element tangent equals $\\int_0^{L_e} \\mathbf{B}_e^\\top E_{t,e} A_e \\mathbf{B}_e \\, dx$ where $E_{t,e}$ is the algorithmic tangent modulus given by the local constitutive update.\n\nRequired units and output:\n- All inputs are in SI units: length in $\\mathrm{m}$, area in $\\mathrm{m}^2$, force in $\\mathrm{N}$, stress in $\\mathrm{Pa}$, modulus in $\\mathrm{Pa}$.\n- Displacements must be computed in $\\mathrm{m}$.\n- The reported differences $\\Delta$ must be expressed in $\\mathrm{N}\\cdot\\mathrm{m}$ (Joules).\n- Your program must print a single line with a list of the three $\\Delta$ values for the test suite below, rounded to six decimal places, in the exact format: $[\\Delta_1,\\Delta_2,\\Delta_3]$.\n\nTest suite:\n- Geometry and material for all tests:\n  - Element $e=1$: $L_1 = 0.6\\,\\mathrm{m}$, $A_1 = 1.0\\times 10^{-3}\\,\\mathrm{m}^2$, $E_1 = 210\\times 10^{9}\\,\\mathrm{Pa}$, $\\sigma_{y0,1} = 300\\times 10^{6}\\,\\mathrm{Pa}$, $H_1 = 1.0\\times 10^{9}\\,\\mathrm{Pa}$.\n  - Element $e=2$: $L_2 = 0.4\\,\\mathrm{m}$, $A_2 = 0.5\\times 10^{-3}\\,\\mathrm{m}^2$, $E_2 = 210\\times 10^{9}\\,\\mathrm{Pa}$, $\\sigma_{y0,2} = 250\\times 10^{6}\\,\\mathrm{Pa}$, $H_2 = 1.0\\times 10^{9}\\,\\mathrm{Pa}$.\n- External nodal forces are specified per step as the vector $\\mathbf{P} = [P_0, P_1, P_2]$ (in $\\mathrm{N}$), where $P_0$ corresponds to node $i=0$ (always $0$ here), $P_1$ to node $i=1$, and $P_2$ to node $i=2$. Each test contains two independent load cases applied to a virgin bar:\n  - Test $1$ (predominantly elastic unloading–reloading):\n    - Load case $(1)$: force history at node $i=2$ only, steps $\\mathbf{P}^{(1)}(t)$:\n      - $[0, 0, 0] \\to [0, 0, 10{,}000] \\to [0, 0, 30{,}000] \\to [0, 0, 40{,}000] \\to [0, 0, 20{,}000] \\to [0, 0, 30{,}000]$.\n    - Load case $(2)$: force history at node $i=1$ only, steps $\\mathbf{P}^{(2)}(t)$:\n      - $[0, 0, 0] \\to [0, 5{,}000, 0] \\to [0, 15{,}000, 0] \\to [0, 20{,}000, 0] \\to [0, 10{,}000, 0] \\to [0, 15{,}000, 0]$.\n  - Test $2$ (monotonic plastic):\n    - Load case $(1)$: node $i=2$ only,\n      - $[0, 0, 0] \\to [0, 0, 80{,}000] \\to [0, 0, 140{,}000] \\to [0, 0, 160{,}000]$.\n    - Load case $(2)$: node $i=1$ only,\n      - $[0, 150{,}000, 0] \\to [0, 300{,}000, 0] \\to [0, 320{,}000, 0]$.\n  - Test $3$ (elastoplastic unloading–reloading):\n    - Load case $(1)$: node $i=2$ only,\n      - $[0, 0, 0] \\to [0, 0, 100{,}000] \\to [0, 0, 180{,}000] \\to [0, 0, 120{,}000] \\to [0, 0, 150{,}000]$.\n    - Load case $(2)$: node $i=1$ only,\n      - $[0, 0, 0] \\to [0, 120{,}000, 0] \\to [0, 220{,}000, 0] \\to [0, 80{,}000, 0] \\to [0, 180{,}000, 0]$.\n\nFor each test:\n- Starting from the virgin state ($\\varepsilon_{e}^p = 0$, $\\alpha_e = 0$, $\\mathbf{u} = \\mathbf{0}$), integrate each load case independently through its full step history, enforcing equilibrium at each step using a Newton-type method with the element algorithmic tangent from the local constitutive update. At the final step of each load case $k \\in \\{1,2\\}$, record the free-node displacement vector $\\mathbf{u}_\\mathrm{free}^{(k)} = [u_1^{(k)}, u_2^{(k)}]$ and the corresponding external nodal force vector $\\mathbf{P}_\\mathrm{free}^{(k)} = [P_1^{(k)}, P_2^{(k)}]$.\n- Compute $\\Delta = \\mathbf{P}^{(1)}_\\mathrm{free} \\cdot \\mathbf{u}^{(2)}_\\mathrm{free} - \\mathbf{P}^{(2)}_\\mathrm{free} \\cdot \\mathbf{u}^{(1)}_\\mathrm{free}$ in $\\mathrm{N}\\cdot\\mathrm{m}$, rounded to six decimal places.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[x_1,x_2,x_3]$), where each $x_i$ is the $\\Delta$ value (in $\\mathrm{N}\\cdot\\mathrm{m}$) for Test $i$, rounded to six decimal places.", "solution": "The problem presented is a well-posed and standard exercise in computational solid mechanics, specifically in the domain of nonlinear finite element analysis. It requires the implementation of a numerical procedure to simulate the behavior of a one-dimensional bar subject to axial loading, accounting for material nonlinearity in the form of elastoplasticity with linear isotropic hardening. The ultimate goal is to computationally investigate the breakdown of Betti's reciprocal theorem in the presence of path-dependent plastic deformation. The problem is valid and will be solved as stated.\n\nThe solution is constructed based on the finite element method (FEM) for a quasi-static, small-strain elastoplastic problem. The core components are the formulation of equilibrium equations, the constitutive integration via a return-mapping algorithm, and a Newton-Raphson scheme to solve the resulting nonlinear system at each load increment.\n\n**1. System Discretization and Kinematics**\n\nThe system consists of three nodes, indexed $i=0,1,2$, and two elements. Node $0$ is fixed, so its displacement $u_0 = 0$. The free degrees of freedom (DOFs) are the displacements of nodes $1$ and $2$, denoted by the vector $\\mathbf{u} = [u_1, u_2]^T$.\n\nThe axial strain $\\varepsilon_e$ in each element $e$ is defined by the nodal displacements. For the two-element system:\n- Element $1$ (nodes $0, 1$): $\\varepsilon_1 = (u_1 - u_0) / L_1 = u_1 / L_1$\n- Element $2$ (nodes $1, 2$): $\\varepsilon_2 = (u_2 - u_1) / L_2$\n\n**2. Principle of Virtual Work and Equilibrium**\n\nThe static equilibrium of the system is governed by the principle of virtual work, which states that the internal work done by stresses must equal the external work done by applied forces for any kinematically admissible virtual displacement field $\\delta\\mathbf{u} = [\\delta u_1, \\delta u_2]^T$.\n\nThe virtual internal work is:\n$$ \\delta W_{\\text{int}} = \\sum_{e=1}^{2} \\int_{V_e} \\sigma_e \\delta\\varepsilon_e \\, dV_e = (A_1 \\sigma_1) \\delta u_1 + (A_2 \\sigma_2)(\\delta u_2 - \\delta u_1) $$\nRearranging terms by virtual displacements:\n$$ \\delta W_{\\text{int}} = (A_1 \\sigma_1 - A_2 \\sigma_2) \\delta u_1 + (A_2 \\sigma_2) \\delta u_2 $$\nThe virtual external work is $\\delta W_{\\text{ext}} = \\mathbf{P}^T \\delta\\mathbf{u} = P_1 \\delta u_1 + P_2 \\delta u_2$, where $\\mathbf{P} = [P_1, P_2]^T$ is the vector of external forces at the free nodes.\n\nEquating $\\delta W_{\\text{int}} = \\delta W_{\\text{ext}}$ for arbitrary $\\delta\\mathbf{u}$ yields the system of equilibrium equations $\\mathbf{F}_{\\text{int}}(\\mathbf{u}) = \\mathbf{P}$, where the internal force vector $\\mathbf{F}_{\\text{int}}$ is:\n$$ \\mathbf{F}_{\\text{int}}(\\mathbf{u}) = \\begin{pmatrix} A_1 \\sigma_1 - A_2 \\sigma_2 \\\\ A_2 \\sigma_2 \\end{pmatrix} $$\nThe stresses $\\sigma_1$ and $\\sigma_2$ are themselves nonlinear functions of the displacements $u_1$ and $u_2$ through the material's constitutive law.\n\n**3. Constitutive Model: Elastoplasticity with Return Mapping**\n\nThe material follows a rate-independent, one-dimensional bilinear elastoplastic model with linear isotropic hardening. At each load step from time $t_n$ to $t_{n+1}$, the constitutive equations must be integrated to find the stress $\\sigma_{n+1}$ corresponding to a given total strain $\\varepsilon_{n+1}$. This is achieved using a standard implicit elastic-predictor/plastic-corrector scheme (return mapping). For each element $e$:\n\n- **State variables**: The state at the previously converged step $n$ is known: stress $\\sigma_n$, plastic strain $\\varepsilon^p_n$, and accumulated plastic strain $\\alpha_n$.\n- **Elastic Predictor**: A trial stress, $\\sigma^{\\text{trial}}$, is computed assuming the entire strain increment is elastic:\n$$ \\sigma^{\\text{trial}} = E (\\varepsilon_{n+1} - \\varepsilon^p_n) $$\n- **Yield Condition Check**: The trial state is checked against the yield criterion:\n$$ f^{\\text{trial}} = |\\sigma^{\\text{trial}}| - (\\sigma_{y0} + H \\alpha_n) $$\n- **Constitutive Update**:\n    - If $f^{\\text{trial}} \\le 0$, the step is elastic. The state is updated as:\n    $$ \\sigma_{n+1} = \\sigma^{\\text{trial}}, \\quad \\varepsilon^p_{n+1} = \\varepsilon^p_n, \\quad \\alpha_{n+1} = \\alpha_n $$\n    The material response is governed by Young's modulus, so the algorithmic tangent modulus is $E_t = E$.\n    - If $f^{\\text{trial}}  0$, plastic flow occurs. The state must be \"returned\" to the yield surface. The plastic consistency multiplier, $\\Delta\\gamma$, is found by enforcing the consistency condition $f_{n+1}=0$:\n    $$ \\Delta\\gamma = \\frac{f^{\\text{trial}}}{E + H} $$\n    The state variables are then updated (corrected):\n    $$ \\alpha_{n+1} = \\alpha_n + \\Delta\\gamma $$\n    $$ \\varepsilon^p_{n+1} = \\varepsilon^p_n + \\Delta\\gamma \\cdot \\text{sign}(\\sigma^{\\text{trial}}) $$\n    $$ \\sigma_{n+1} = E (\\varepsilon_{n+1} - \\varepsilon^p_{n+1}) = \\sigma^{\\text{trial}} - E \\cdot \\Delta\\gamma \\cdot \\text{sign}(\\sigma^{\\text{trial}}) $$\n    The consistent algorithmic tangent modulus for this plastic step is:\n    $$ E_t = \\frac{d\\sigma_{n+1}}{d\\varepsilon_{n+1}} = \\frac{EH}{E+H} $$\n\n**4. Nonlinear Solver: Newton-Raphson Method**\n\nAt each load step $t_{n+1}$, the goal is to find the displacement vector $\\mathbf{u}_{n+1}$ that satisfies the nonlinear equilibrium equation:\n$$ \\mathbf{R}(\\mathbf{u}_{n+1}) = \\mathbf{P}_{n+1} - \\mathbf{F}_{\\text{int}}(\\mathbf{u}_{n+1}) = \\mathbf{0} $$\nThis is solved iteratively using the Newton-Raphson method. Starting with an initial guess $\\mathbf{u}^{(0)} = \\mathbf{u}_n$, the system is linearized at each iteration $k$:\n$$ \\mathbf{K}_T^{(k)} \\Delta\\mathbf{u}^{(k)} = \\mathbf{R}^{(k)} $$\nwhere $\\mathbf{R}^{(k)} = \\mathbf{P}_{n+1} - \\mathbf{F}_{\\text{int}}(\\mathbf{u}^{(k)})$ is the residual force vector and $\\mathbf{K}_T^{(k)}$ is the global tangent stiffness matrix at iteration $k$. The displacement is updated: $\\mathbf{u}^{(k+1)} = \\mathbf{u}^{(k)} + \\Delta\\mathbf{u}^{(k)}$. This process repeats until the norm of the residual is below a specified tolerance.\n\nThe tangent stiffness matrix is the derivative of the internal force vector with respect to displacements, $\\mathbf{K}_T = \\partial\\mathbf{F}_{\\text{int}}/\\partial\\mathbf{u}$. For our system:\n$$ \\mathbf{K}_T = \\begin{pmatrix} A_1 \\frac{\\partial\\sigma_1}{\\partial u_1} - A_2 \\frac{\\partial\\sigma_2}{\\partial u_1}  A_1 \\frac{\\partial\\sigma_1}{\\partial u_2} - A_2 \\frac{\\partial\\sigma_2}{\\partial u_2} \\\\ A_2 \\frac{\\partial\\sigma_2}{\\partial u_1}  A_2 \\frac{\\partial\\sigma_2}{\\partial u_2} \\end{pmatrix} $$\nUsing the chain rule and the element kinematics:\n$\\frac{\\partial\\sigma_1}{\\partial u_1} = \\frac{d\\sigma_1}{d\\varepsilon_1} \\frac{\\partial\\varepsilon_1}{\\partial u_1} = E_{t,1} \\frac{1}{L_1}$, $\\frac{\\partial\\sigma_1}{\\partial u_2} = 0$.\n$\\frac{\\partial\\sigma_2}{\\partial u_1} = \\frac{d\\sigma_2}{d\\varepsilon_2} \\frac{\\partial\\varepsilon_2}{\\partial u_1} = E_{t,2} \\frac{-1}{L_2}$, $\\frac{\\partial\\sigma_2}{\\partial u_2} = \\frac{d\\sigma_2}{d\\varepsilon_2} \\frac{\\partial\\varepsilon_2}{\\partial u_2} = E_{t,2} \\frac{1}{L_2}$.\nSubstituting these yields the global tangent stiffness matrix:\n$$ \\mathbf{K}_T = \\begin{pmatrix} \\frac{A_1 E_{t,1}}{L_1} + \\frac{A_2 E_{t,2}}{L_2}  -\\frac{A_2 E_{t,2}}{L_2} \\\\ -\\frac{A_2 E_{t,2}}{L_2}  \\frac{A_2 E_{t,2}}{L_2} \\end{pmatrix} $$\nwhere $E_{t,e}$ is the algorithmic tangent modulus for element $e$, determined from the constitutive update at the current iteration.\n\n**5. Computational Test for Reciprocity**\n\nThe program implements the described solver. For each of the three tests, it performs two independent simulations, one for each load case, starting from a virgin (stress-free, undeformed) state. At the conclusion of each load history, the final external force vector $\\mathbf{P}_{\\text{free}}^{(k)}$ and the final displacement vector $\\mathbf{u}_{\\text{free}}^{(k)}$ (for $k=1,2$) are recorded. The quantity $\\Delta$ is then computed as specified:\n$$ \\Delta = \\mathbf{P}_{\\text{free}}^{(1)} \\cdot \\mathbf{u}_{\\text{free}}^{(2)} - \\mathbf{P}_{\\text{free}}^{(2)} \\cdot \\mathbf{u}_{\\text{free}}^{(1)} $$\nFor Test 1, where both load paths remain entirely within the elastic domain, the system behaves linearly. The stiffness matrix is symmetric and constant, which is the condition for Betti's theorem to hold. Therefore, $\\Delta$ is expected to be zero, up to numerical precision. For Tests 2 and 3, plastic deformation occurs in at least one of the load paths. This path-dependent, dissipative behavior breaks the assumptions of Betti's theorem, and hence a non-zero $\\Delta$ is expected, quantifying the breakdown of reciprocity.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the computational mechanics problem to test Betti's reciprocal theorem\n    for an elastoplastic bar.\n    \"\"\"\n\n    class Element:\n        \"\"\"Represents a 1D axial element with bilinear elastoplastic material behavior.\"\"\"\n        def __init__(self, L, A, E, sig_y0, H):\n            self.L = L\n            self.A = A\n            self.E = E\n            self.sig_y0 = sig_y0\n            self.H = H\n            self.reset()\n\n        def reset(self):\n            \"\"\"Resets the element to a virgin state.\"\"\"\n            self.sigma = 0.0      # Stress\n            self.epsilon_p = 0.0  # Plastic strain\n            self.alpha = 0.0      # Accumulated plastic strain\n\n    def run_load_case(elements, load_history, max_iter=30, tol=1e-8):\n        \"\"\"\n        Simulates the response of the bar for a given load history using a\n        Newton-Raphson solver.\n        \n        Args:\n            elements (list): A list containing the two Element objects.\n            load_history (list): A sequence of external force vectors [P1, P2].\n            max_iter (int): Maximum number of Newton-Raphson iterations per step.\n            tol (float): Convergence tolerance for the residual norm.\n\n        Returns:\n            numpy.ndarray: The final displacement vector [u1, u2].\n        \"\"\"\n        el1, el2 = elements\n        \n        # Reset elements to virgin state before starting the simulation\n        el1.reset()\n        el2.reset()\n        \n        u_free = np.zeros(2) # [u1, u2]\n\n        for p_target in load_history[1:]: # Start from the first non-zero load step\n            P_ext = np.array(p_target, dtype=float)\n            \n            # Newton-Raphson iterations to find equilibrium at P_ext\n            u_iter = u_free.copy()\n            \n            # State at the beginning of the load increment (converged state from previous step)\n            initial_states = {\n                'el1': {'ep': el1.epsilon_p, 'alpha': el1.alpha},\n                'el2': {'ep': el2.epsilon_p, 'alpha': el2.alpha}\n            }\n\n            for i in range(max_iter):\n                # 1. Calculate trial state based on current displacement guess u_iter\n                eps1_k = u_iter[0] / el1.L\n                eps2_k = (u_iter[1] - u_iter[0]) / el2.L\n\n                # --- Element 1 properties at iteration k ---\n                sig1_trial = el1.E * (eps1_k - initial_states['el1']['ep'])\n                f1_trial = abs(sig1_trial) - (el1.sig_y0 + el1.H * initial_states['el1']['alpha'])\n                \n                if f1_trial = 0.0: # Elastic\n                    sig1_k = sig1_trial\n                    Et1_k = el1.E\n                else: # Plastic\n                    d_gamma1 = f1_trial / (el1.E + el1.H)\n                    sig1_k = sig1_trial - el1.E * d_gamma1 * np.sign(sig1_trial)\n                    Et1_k = (el1.E * el1.H) / (el1.E + el1.H)\n\n                # --- Element 2 properties at iteration k ---\n                sig2_trial = el2.E * (eps2_k - initial_states['el2']['ep'])\n                f2_trial = abs(sig2_trial) - (el2.sig_y0 + el2.H * initial_states['el2']['alpha'])\n\n                if f2_trial = 0.0: # Elastic\n                    sig2_k = sig2_trial\n                    Et2_k = el2.E\n                else: # Plastic\n                    d_gamma2 = f2_trial / (el2.E + el2.H)\n                    sig2_k = sig2_trial - el2.E * d_gamma2 * np.sign(sig2_trial)\n                    Et2_k = (el2.E * el2.H) / (el2.E + el2.H)\n                \n                # 2. Assemble internal force vector and calculate residual\n                F_int = np.array([el1.A * sig1_k - el2.A * sig2_k, el2.A * sig2_k])\n                R = P_ext - F_int\n\n                # 3. Check for convergence\n                norm_R = np.linalg.norm(R)\n                if norm_R  tol:\n                    break\n                if i == max_iter - 1:\n                    print(\"Warning: Newton-Raphson did not converge.\")\n\n                # 4. Assemble tangent stiffness matrix\n                k1 = el1.A * Et1_k / el1.L\n                k2 = el2.A * Et2_k / el2.L\n                K_T = np.array([[k1 + k2, -k2], [-k2, k2]])\n                \n                # 5. Solve for displacement increment and update\n                delta_u = np.linalg.solve(K_T, R)\n                u_iter += delta_u\n            \n            # After convergence, update permanent state for the next load step\n            u_free = u_iter.copy()\n            \n            # --- Update element 1 final state for this step ---\n            eps1_final = u_free[0] / el1.L\n            sig1_trial = el1.E * (eps1_final - initial_states['el1']['ep'])\n            f1_trial = abs(sig1_trial) - (el1.sig_y0 + el1.H * initial_states['el1']['alpha'])\n            if f1_trial  0.0:\n                d_gamma1 = f1_trial / (el1.E + el1.H)\n                el1.alpha = initial_states['el1']['alpha'] + d_gamma1\n                el1.epsilon_p = initial_states['el1']['ep'] + d_gamma1 * np.sign(sig1_trial)\n            el1.sigma = el1.E * (eps1_final - el1.epsilon_p)\n\n            # --- Update element 2 final state for this step ---\n            eps2_final = (u_free[1] - u_free[0]) / el2.L\n            sig2_trial = el2.E * (eps2_final - initial_states['el2']['ep'])\n            f2_trial = abs(sig2_trial) - (el2.sig_y0 + el2.H * initial_states['el2']['alpha'])\n            if f2_trial  0.0:\n                d_gamma2 = f2_trial / (el2.E + el2.H)\n                el2.alpha = initial_states['el2']['alpha'] + d_gamma2\n                el2.epsilon_p = initial_states['el2']['ep'] + d_gamma2 * np.sign(sig2_trial)\n            el2.sigma = el2.E * (eps2_final - el2.epsilon_p)\n            \n        return u_free\n\n    # Define common material and geometric properties\n    props1 = {'L': 0.6, 'A': 1.0e-3, 'E': 210e9, 'sig_y0': 300e6, 'H': 1.0e9}\n    props2 = {'L': 0.4, 'A': 0.5e-3, 'E': 210e9, 'sig_y0': 250e6, 'H': 1.0e9}\n\n    # Problem statement gives loads as [P0, P1, P2]. We only need free DOFs [P1, P2].\n    test_cases = [\n        # Test 1 (predominantly elastic unloading–reloading)\n        {\n            'P1_hist': [[0, 0], [0, 10000], [0, 30000], [0, 40000], [0, 20000], [0, 30000]],\n            'P2_hist': [[0, 0], [5000, 0], [15000, 0], [20000, 0], [10000, 0], [15000, 0]]\n        },\n        # Test 2 (monotonic plastic)\n        {\n            'P1_hist': [[0, 0], [0, 80000], [0, 140000], [0, 160000]],\n            'P2_hist': [[0, 0], [150000, 0], [300000, 0], [320000, 0]]\n        },\n        # Test 3 (elastoplastic unloading–reloading)\n        {\n            'P1_hist': [[0, 0], [0, 100000], [0, 180000], [0, 120000], [0, 150000]],\n            'P2_hist': [[0, 0], [120000, 0], [220000, 0], [80000, 0], [180000, 0]]\n        }\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        # Instantiate elements for the current test\n        element1 = Element(**props1)\n        element2 = Element(**props2)\n        elements = [element1, element2]\n\n        # Simulate Load Case 1\n        u_final_1 = run_load_case(elements, case['P1_hist'])\n        P_final_1 = np.array(case['P1_hist'][-1])\n\n        # Simulate Load Case 2\n        u_final_2 = run_load_case(elements, case['P2_hist'])\n        P_final_2 = np.array(case['P2_hist'][-1])\n        \n        # Compute Delta to quantify reciprocity breakdown\n        delta = P_final_1 @ u_final_2 - P_final_2 @ u_final_1\n        \n        # The problem asks for rounding to six decimal places, not just formatting\n        results.append(f\"{delta:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2618402"}]}