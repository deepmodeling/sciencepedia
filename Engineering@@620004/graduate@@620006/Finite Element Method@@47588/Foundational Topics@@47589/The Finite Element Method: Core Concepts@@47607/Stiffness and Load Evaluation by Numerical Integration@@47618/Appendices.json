{"hands_on_practices": [{"introduction": "To effectively apply numerical integration, we must first understand the nature of the function we are integrating. This first exercise provides a foundational analysis for the workhorse of 2D analysis: the bilinear quadrilateral element under ideal, affine mapping. By determining the exact polynomial degree of the stiffness integrand, you will see precisely why a specific, low-order Gauss quadrature rule is often sufficient for this common element type. [@problem_id:2599447]", "problem": "Consider a two-dimensional isoparametric bilinear quadrilateral finite element defined over the parent square in the coordinates $(\\xi,\\eta)\\in[-1,1]\\times[-1,1]$ with the standard bilinear shape functions $N_{i}(\\xi,\\eta)$ for $i=1,2,3,4$. Assume an affine isoparametric mapping from the parent domain to the physical domain so that $x(\\xi,\\eta)=a_{0}+a_{1}\\,\\xi+a_{2}\\,\\eta$ and $y(\\xi,\\eta)=b_{0}+b_{1}\\,\\xi+b_{2}\\,\\eta$ with constants $a_{k}$ and $b_{k}$ such that the Jacobian matrix $\\mathbf{J}=\\partial(x,y)/\\partial(\\xi,\\eta)$ is constant and nonsingular. Let the constitutive (material) matrix $\\mathbf{D}$ be constant (e.g., plane stress or plane strain with constant coefficients). Denote by $\\mathbf{B}$ the usual $3\\times 8$ strain–displacement matrix for this element, whose entries are linear combinations of $\\partial N_{i}/\\partial x$ and $\\partial N_{i}/\\partial y$. In the element stiffness integrand $\\mathbf{B}^{T} \\mathbf{D} \\mathbf{B}$ expressed as a function of the parent coordinates $(\\xi,\\eta)$, determine the polynomial degree (in $\\xi$ and $\\eta$) of each entry of the matrix $\\mathbf{B}^{T} \\mathbf{D} \\mathbf{B}$ for a generic, nondegenerate affine mapping and constant $\\mathbf{D}$. Provide your answer as a single integer with no units.", "solution": "The problem statement is validated as scientifically grounded, self-contained, and objective. It presents a specialized but well-posed question within the domain of the finite element method. We proceed to the solution.\n\nThe analysis hinges on determining the polynomial character of the terms constituting the matrix product $\\mathbf{B}^{T} \\mathbf{D} \\mathbf{B}$ as functions of the parent coordinates $(\\xi, \\eta)$.\n\n$1$. Shape Functions and Their Derivatives:\nFor a bilinear quadrilateral element, the shape functions $N_{i}(\\xi,\\eta)$ for $i=1, 2, 3, 4$ are bilinear polynomials in $\\xi$ and $\\eta$. A generic shape function is of the form:\n$$ N_{i}(\\xi,\\eta) = c_{i0} + c_{i1}\\xi + c_{i2}\\eta + c_{i3}\\xi\\eta $$\nwhere $c_{ij}$ are constants. For example, $N_{1}(\\xi,\\eta) = \\frac{1}{4}(1-\\xi)(1-\\eta)$.\nThe partial derivatives with respect to the parent coordinates are:\n$$ \\frac{\\partial N_{i}}{\\partial \\xi} = c_{i1} + c_{i3}\\eta $$\n$$ \\frac{\\partial N_{i}}{\\partial \\eta} = c_{i2} + c_{i3}\\xi $$\nThese derivatives are linear polynomials, i.e., polynomials of degree $1$, in $\\eta$ and $\\xi$ respectively.\n\n$2$. Isoparametric Mapping and the Jacobian Matrix:\nThe problem specifies an affine isoparametric mapping:\n$$ x(\\xi,\\eta) = a_{0}+a_{1}\\xi+a_{2}\\eta $$\n$$ y(\\xi,\\eta) = b_{0}+b_{1}\\xi+b_{2}\\eta $$\nThe Jacobian matrix of this transformation, $\\mathbf{J}$, relates the parent coordinate system to the physical coordinate system. Its components are given by:\n$$ \\mathbf{J} = \\begin{pmatrix} \\frac{\\partial x}{\\partial \\xi} & \\frac{\\partial y}{\\partial \\xi} \\\\ \\frac{\\partial x}{\\partial \\eta} & \\frac{\\partial y}{\\partial \\eta} \\end{pmatrix} = \\begin{pmatrix} a_{1} & b_{1} \\\\ a_{2} & b_{2} \\end{pmatrix} $$\nAs the coefficients $a_{k}$ and $b_{k}$ are constants, the Jacobian matrix $\\mathbf{J}$ is a constant matrix. The problem states it is nonsingular, so its determinant $\\det(\\mathbf{J}) = a_{1}b_{2} - a_{2}b_{1} \\neq 0$.\n\n$3$. Derivatives in Physical Coordinates:\nThe chain rule for differentiation connects derivatives in the physical domain $(x, y)$ to those in the parent domain $(\\xi, \\eta)$:\n$$ \\begin{pmatrix} \\frac{\\partial N_i}{\\partial \\xi} \\\\ \\frac{\\partial N_i}{\\partial \\eta} \\end{pmatrix} = \\mathbf{J}^{T} \\begin{pmatrix} \\frac{\\partial N_i}{\\partial x} \\\\ \\frac{\\partial N_i}{\\partial y} \\end{pmatrix} $$\nTo find the derivatives with respect to physical coordinates, we invert this relationship:\n$$ \\begin{pmatrix} \\frac{\\partial N_i}{\\partial x} \\\\ \\frac{\\partial N_i}{\\partial y} \\end{pmatrix} = (\\mathbf{J}^{T})^{-1} \\begin{pmatrix} \\frac{\\partial N_i}{\\partial \\xi} \\\\ \\frac{\\partial N_i}{\\partial \\eta} \\end{pmatrix} $$\nSince $\\mathbf{J}$ is a constant, nonsingular matrix, its inverse transpose $(\\mathbf{J}^{T})^{-1}$ is also a constant, nonsingular matrix. Let $(\\mathbf{J}^{T})^{-1} = \\hat{\\mathbf{J}}$, a matrix of constants. The physical derivatives are therefore constant linear combinations of the parent-coordinate derivatives:\n$$ \\frac{\\partial N_{i}}{\\partial x} = \\hat{J}_{11} \\frac{\\partial N_{i}}{\\partial \\xi} + \\hat{J}_{12} \\frac{\\partial N_{i}}{\\partial \\eta} $$\n$$ \\frac{\\partial N_{i}}{\\partial y} = \\hat{J}_{21} \\frac{\\partial N_{i}}{\\partial \\xi} + \\hat{J}_{22} \\frac{\\partial N_{i}}{\\partial \\eta} $$\nSince $\\frac{\\partial N_{i}}{\\partial \\xi}$ and $\\frac{\\partial N_{i}}{\\partial \\eta}$ are polynomials of degree $1$ in $(\\xi, \\eta)$, and the coefficients $\\hat{J}_{kl}$ are constants, the derivatives $\\frac{\\partial N_{i}}{\\partial x}$ and $\\frac{\\partial N_{i}}{\\partial y}$ are also polynomials of degree $1$ in $(\\xi, \\eta)$. For a generic, nondegenerate mapping, these will not reduce to constants.\n\n$4$. Strain-Displacement Matrix $\\mathbf{B}$:\nThe strain-displacement matrix $\\mathbf{B}$ is a $3 \\times 8$ matrix, structured as $\\mathbf{B} = [\\mathbf{B}_1, \\mathbf{B}_2, \\mathbf{B}_3, \\mathbf{B}_4]$, where each block $\\mathbf{B}_i$ is a $3 \\times 2$ matrix given by:\n$$ \\mathbf{B}_{i} = \\begin{pmatrix} \\frac{\\partial N_{i}}{\\partial x} & 0 \\\\ 0 & \\frac{\\partial N_{i}}{\\partial y} \\\\ \\frac{\\partial N_{i}}{\\partial y} & \\frac{\\partial N_{i}}{\\partial x} \\end{pmatrix} $$\nFrom the analysis above, every non-zero entry of each $\\mathbf{B}_i$ block is a polynomial of degree $1$ in $(\\xi, \\eta)$.\n\n$5$. Stiffness Integrand $\\mathbf{B}^{T} \\mathbf{D} \\mathbf{B}$:\nThe element stiffness matrix is computed by integrating the stiffness kernel over the parent domain. We are interested in the polynomial degree of the integrand matrix $\\mathbf{B}^{T} \\mathbf{D} \\mathbf{B}$.\n- $\\mathbf{B}$ is a $3 \\times 8$ matrix whose entries are polynomials of degree $1$.\n- $\\mathbf{B}^{T}$ is an $8 \\times 3$ matrix whose entries are also polynomials of degree $1$.\n- $\\mathbf{D}$ is a constant $3 \\times 3$ matrix, whose entries are polynomials of degree $0$.\n\nLet us examine a generic entry $(\\mathbf{B}^{T} \\mathbf{D} \\mathbf{B})_{jk}$ of the resulting $8 \\times 8$ matrix. It is computed as:\n$$ (\\mathbf{B}^{T} \\mathbf{D} \\mathbf{B})_{jk} = \\sum_{m=1}^{3} \\sum_{n=1}^{3} (\\mathbf{B}^{T})_{jm} D_{mn} B_{nk} $$\nHere, $(\\mathbf{B}^{T})_{jm}$ is an entry from the $j$-th row of $\\mathbf{B}^{T}$ (i.e., the $j$-th column of $\\mathbf{B}$), and $B_{nk}$ is an entry from the $n$-th row and $k$-th column of $\\mathbf{B}$. Both are polynomials of degree $1$. $D_{mn}$ is a constant.\nThe product $(\\mathbf{B}^{T})_{jm} D_{mn} B_{nk}$ is therefore a product of two degree-$1$ polynomials and a degree-$0$ polynomial (a constant). The result is a polynomial of degree $1+0+1=2$.\nThe final entry $(\\mathbf{B}^{T} \\mathbf{D} \\mathbf{B})_{jk}$ is a sum of such degree-$2$ polynomials. The sum of polynomials of degree $2$ is a polynomial of degree at most $2$.\nFor a generic, nondegenerate mapping and a non-trivial material matrix $\\mathbf{D}$, the coefficients of the second-degree terms will not systematically cancel to zero. For example, a typical term contributing to the integrand, such as $d_{11} (\\frac{\\partial N_i}{\\partial x}) (\\frac{\\partial N_j}{\\partial x})$, is a product of two degree-$1$ polynomials and is thus of degree $2$. There is no physical or mathematical reason for a complete cancellation of all second-degree terms across the sum for a general problem setup.\n\nTherefore, each entry of the matrix $\\mathbf{B}^{T} \\mathbf{D} \\mathbf{B}$ is a polynomial function of $\\xi$ and $\\eta$ of degree $2$.", "answer": "$$\\boxed{2}$$", "id": "2599447"}, {"introduction": "While standard quadrature rules are efficient, their reliance on a few discrete points can be a significant vulnerability, especially with distorted elements. This practice presents a thought experiment involving a geometrically inverted element, where the Jacobian determinant $\\det \\mathbf{J}$ becomes negative. You will explore analytically how a standard Gauss quadrature scheme can completely fail to detect this fatal flaw, leading to incorrect results without any warning. [@problem_id:2599488]", "problem": "Consider a trilinear isoparametric hexahedral element used in the Finite Element Method (FEM), defined on the parent domain $\\hat{\\Omega}=[-1,1]^{3}$ with parent coordinates $(\\xi,\\eta,\\zeta)$. Suppose the geometry mapping from $\\hat{\\Omega}$ to the physical element is such that the Jacobian determinant is\n$$\n\\det \\mathbf{J}(\\xi,\\eta,\\zeta)=1-\\frac{1}{2}\\left(\\xi+\\eta+\\zeta\\right).\n$$\nThis situation models a distorted element with an inverted physical corner near the parent-space corner $(\\xi,\\eta,\\zeta)=(1,1,1)$, where the mapping locally folds. The stiffness matrix and load vector of the element are to be evaluated by Gauss–Legendre tensor-product quadrature.\n\nUsing only the core definitions of isoparametric mapping, the meaning of the Jacobian determinant in change of variables for integration, and the basic properties of Gauss–Legendre quadrature, do the following:\n\n1) Determine the locus in $\\hat{\\Omega}$ where $\\det \\mathbf{J}(\\xi,\\eta,\\zeta)$ changes sign, and identify geometrically the region where $\\det \\mathbf{J}(\\xi,\\eta,\\zeta)<0$.\n\n2) Compute exactly the fraction of the parent-domain volume $|\\hat{\\Omega}|$ for which $\\det \\mathbf{J}(\\xi,\\eta,\\zeta)<0$. Express your final answer as a reduced fraction.\n\n3) Explain, by evaluating $\\det \\mathbf{J}$ at the tensor-product Gauss points for the $2\\times 2\\times 2$ rule, why standard quadrature may fail to detect the inversion when assembling stiffness and load integrals.\n\nYour final reported answer must be only the result of Task $2$ as a single reduced fraction (dimensionless). No rounding is required.", "solution": "The problem statement is subjected to validation.\n\n**Step 1: Extract Givens**\n- Element type: Trilinear isoparametric hexahedral element.\n- Parent domain: $\\hat{\\Omega}=[-1,1]^{3}$.\n- Parent coordinates: $(\\xi,\\eta,\\zeta)$.\n- Jacobian determinant: $\\det \\mathbf{J}(\\xi,\\eta,\\zeta)=1-\\frac{1}{2}\\left(\\xi+\\eta+\\zeta\\right)$.\n- Task 1: Determine the locus where $\\det \\mathbf{J}(\\xi,\\eta,\\zeta)$ changes sign and identify the region where $\\det \\mathbf{J}(\\xi,\\eta,\\zeta)<0$.\n- Task 2: Compute the fraction of the parent-domain volume $|\\hat{\\Omega}|$ where $\\det \\mathbf{J}(\\xi,\\eta,\\zeta)<0$.\n- Task 3: Explain why $2\\times 2\\times 2$ Gauss–Legendre quadrature may fail to detect the inversion.\n\n**Step 2: Validate Using Extracted Givens**\n- **Scientifically Grounded:** The problem is based on fundamental concepts of the Finite Element Method (FEM), specifically isoparametric mapping, the role of the Jacobian determinant in integration, element inversion ($\\det \\mathbf{J} < 0$), and numerical quadrature. These are standard topics in computational mechanics and applied mathematics.\n- **Well-Posed:** The problem is clearly stated with all necessary information. The function for the Jacobian determinant is given, the domain is specified, and the tasks are unambiguous mathematical exercises that lead to a unique, stable, and meaningful solution.\n- **Objective:** The language is formal and precise, free of subjectivity or ambiguity.\n\n**Step 3: Verdict and Action**\nThe problem is valid. It is a well-posed, scientifically grounded problem in the field of FEM. A solution will be provided.\n\nThe problem investigates the properties of a distorted element characterized by a given Jacobian determinant, $\\det \\mathbf{J}$, within the parent domain $\\hat{\\Omega} = [-1,1]^{3}$.\n\n**1) Locus of Sign Change and Region of Inversion**\n\nThe sign of the Jacobian determinant, $\\det \\mathbf{J}(\\xi,\\eta,\\zeta)$, indicates whether the mapping from parent to physical coordinates preserves or reverses local orientation. A negative determinant signifies an \"inverted\" or \"folded\" element, which is physically nonsensical and computationally problematic.\n\nThe locus where $\\det \\mathbf{J}$ changes sign is the set of points where the determinant is zero. We set the given expression to zero:\n$$\n\\det \\mathbf{J}(\\xi,\\eta,\\zeta) = 1-\\frac{1}{2}\\left(\\xi+\\eta+\\zeta\\right) = 0\n$$\nSolving for the sum of coordinates gives:\n$$\n\\xi+\\eta+\\zeta = 2\n$$\nThis equation defines a plane in the $(\\xi,\\eta,\\zeta)$ coordinate space. This plane is the locus where the mapping is singular.\n\nThe region where the element is inverted is where $\\det \\mathbf{J}(\\xi,\\eta,\\zeta) < 0$. This corresponds to the inequality:\n$$\n1-\\frac{1}{2}\\left(\\xi+\\eta+\\zeta\\right) < 0\n$$\nwhich simplifies to:\n$$\n\\xi+\\eta+\\zeta > 2\n$$\nGeometrically, this inequality describes the half-space on the side of the plane $\\xi+\\eta+\\zeta = 2$ that does not contain the origin. We are interested in the portion of this half-space that lies within the parent domain cube $\\hat{\\Omega} = [-1,1]^{3}$. The region of inversion, which we denote $V_{\\text{neg}}$, is a small tetrahedron cut from the corner $(1,1,1)$ of the cube, bounded by the planes $\\xi=1$, $\\eta=1$, $\\zeta=1$ from the cube boundary, and the plane $\\xi+\\eta+\\zeta = 2$.\n\n**2) Fraction of Inverted Volume**\n\nThe total volume of the parent domain, $|\\hat{\\Omega}|$, is the volume of a cube with side length $1 - (-1) = 2$. Thus:\n$$\n|\\hat{\\Omega}| = 2^{3} = 8\n$$\nTo find the volume of the inverted region, $|V_{\\text{neg}}|$, we must calculate the volume of the tetrahedron identified in part $1$. The vertices of this tetrahedron are the corner of the cube $(1,1,1)$ and the points where the plane $\\xi+\\eta+\\zeta=2$ intersects the cube edges connected to this corner.\n- Intersection with edge $(\\xi,1,1)$: $\\xi+1+1=2 \\implies \\xi=0$. Point: $(0,1,1)$.\n- Intersection with edge $(1,\\eta,1)$: $1+\\eta+1=2 \\implies \\eta=0$. Point: $(1,0,1)$.\n- Intersection with edge $(1,1,\\zeta)$: $1+1+\\zeta=2 \\implies \\zeta=0$. Point: $(1,1,0)$.\nSo, the four vertices of the tetrahedron are $A=(1,1,1)$, $B=(0,1,1)$, $C=(1,0,1)$, and $D=(1,1,0)$.\n\nThe volume of a tetrahedron with vertices $A$, $B$, $C$, $D$ is given by $|V| = \\frac{1}{6} |\\det(\\vec{AB}, \\vec{AC}, \\vec{AD})|$. We compute the vectors originating from vertex $A$:\n$$\n\\vec{AB} = (0-1, 1-1, 1-1) = (-1, 0, 0)\n$$\n$$\n\\vec{AC} = (1-1, 0-1, 1-1) = (0, -1, 0)\n$$\n$$\n\\vec{AD} = (1-1, 1-1, 0-1) = (0, 0, -1)\n$$\nThe volume is:\n$$\n|V_{\\text{neg}}| = \\frac{1}{6} \\left| \\det \\begin{pmatrix} -1 & 0 & 0 \\\\ 0 & -1 & 0 \\\\ 0 & 0 & -1 \\end{pmatrix} \\right| = \\frac{1}{6} |(-1)(-1)(-1)| = \\frac{1}{6} |-1| = \\frac{1}{6}\n$$\nAlternatively, this volume can be computed via integration:\n$$\n|V_{\\text{neg}}| = \\int_{0}^{1} \\int_{1-\\xi}^{1} \\int_{2-\\xi-\\eta}^{1} d\\zeta d\\eta d\\xi = \\frac{1}{6}\n$$\nThe fraction of the parent-domain volume for which $\\det \\mathbf{J}(\\xi,\\eta,\\zeta)<0$ is:\n$$\n\\frac{|V_{\\text{neg}}|}{|\\hat{\\Omega}|} = \\frac{1/6}{8} = \\frac{1}{48}\n$$\n\n**3) Failure of $2\\times 2\\times 2$ Gauss Quadrature**\n\nThe standard $2\\times 2\\times 2$ Gauss-Legendre quadrature rule for the domain $[-1,1]^{3}$ uses $8$ integration points (Gauss points). These points are the tensor product of the $1D$ $2$-point Gauss rule, whose points are at $\\pm\\frac{1}{\\sqrt{3}}$. Thus, the coordinates of the $8$ points are $(\\xi_i, \\eta_j, \\zeta_k)$ where $\\xi_i, \\eta_j, \\zeta_k \\in \\{-\\frac{1}{\\sqrt{3}}, +\\frac{1}{\\sqrt{3}}\\}$.\n\nNumerical integration methods, such as Gauss quadrature, approximate an integral by a weighted sum of the integrand's values at these discrete points. For element stiffness and load vector assembly, the integrand includes a factor of $\\det \\mathbf{J}$. The method will fail to detect element inversion if $\\det \\mathbf{J}$ is positive at all Gauss points, even if it is negative elsewhere in the domain.\n\nLet's evaluate $\\det \\mathbf{J}$ at these points. This requires evaluating the sum $S = \\xi+\\eta+\\zeta$. The maximum value of this sum occurs when all coordinates are positive:\n$$\nS_{\\text{max}} = \\frac{1}{\\sqrt{3}} + \\frac{1}{\\sqrt{3}} + \\frac{1}{\\sqrt{3}} = \\frac{3}{\\sqrt{3}} = \\sqrt{3}\n$$\nThe minimum value occurs when all are negative: $S_{\\text{min}} = -\\sqrt{3}$. All other combinations of signs yield sums of $\\pm \\frac{1}{\\sqrt{3}}$. Therefore, for any $2\\times 2\\times 2$ Gauss point, the sum $S = \\xi+\\eta+\\zeta$ is bounded by $|S| \\le \\sqrt{3}$.\n\nThe condition for element inversion is $\\xi+\\eta+\\zeta > 2$.\nHowever, the maximum sum at any Gauss point is $\\sqrt{3} \\approx 1.732$. Since $\\sqrt{3} < 2$, we have:\n$$\n(\\xi+\\eta+\\zeta)_{\\text{Gauss pt}} \\le \\sqrt{3} < 2\n$$\nThis proves that none of the $2\\times 2\\times 2$ Gauss points fall within the region of inversion $V_{\\text{neg}}$. At every Gauss point, the sum $\\xi+\\eta+\\zeta$ is less than $2$, which means the value of $\\det \\mathbf{J} = 1 - \\frac{1}{2}(\\xi+\\eta+\\zeta)$ will be positive at all sample points.\nSpecifically, the minimum value of $\\det \\mathbf{J}$ at a Gauss point occurs when $S=S_{\\text{max}}=\\sqrt{3}$:\n$$\n\\det \\mathbf{J}_{\\min} = 1 - \\frac{\\sqrt{3}}{2} \\approx 1 - 0.866 = 0.134 > 0\n$$\nBecause the quadrature scheme only samples the integrand where $\\det \\mathbf{J} > 0$, it fails entirely to detect the existence of the inverted region. The numerical calculation will proceed as if the element geometry were valid everywhere, leading to a physically and mathematically incorrect stiffness matrix and load vector.", "answer": "$$ \\boxed{\\frac{1}{48}} $$", "id": "2599488"}, {"introduction": "Real-world problems often feature complex geometries and spatially varying material properties, making the integrand for the stiffness matrix too complicated for a fixed, pre-determined quadrature rule. This hands-on coding exercise challenges you to implement a more robust solution: an adaptive quadrature scheme. Your algorithm will automatically refine the integration precision until a desired accuracy is met, providing a powerful tool for reliable finite element analysis. [@problem_id:2599445]", "problem": "Design and implement an adaptive numerical integration procedure to evaluate the element stiffness matrix for a two-dimensional, four-node, isoparametric bilinear quadrilateral in the Finite Element Method (FEM). The goal is to automatically refine the Gauss–Legendre quadrature order within a single element until the change in the element stiffness matrix is below a prescribed tolerance.\n\nStart from the fundamental weak form for linear elasticity: Given a displacement field $\\mathbf{u}$ and a virtual displacement field $\\mathbf{v}$, the internal virtual work in an element domain $\\Omega_e$ is\n$$\n\\delta W_{\\text{int}} = \\int_{\\Omega_e} \\varepsilon(\\mathbf{u})^{\\mathsf T} \\, \\mathbf{C}(x,y) \\, \\varepsilon(\\mathbf{v}) \\, \\mathrm{d}\\Omega,\n$$\nwhere $\\varepsilon(\\cdot)$ is the small-strain operator and $\\mathbf{C}(x,y)$ is the spatially varying constitutive matrix. The consistent element stiffness matrix is defined by the bilinear form\n$$\n\\mathbf{K}_e = \\int_{\\Omega_e} \\mathbf{B}(x,y)^{\\mathsf T} \\, \\mathbf{D}(x,y) \\, \\mathbf{B}(x,y) \\, \\mathrm{d}\\Omega,\n$$\nwhere $\\mathbf{B}$ is the linearized strain–displacement matrix and $\\mathbf{D}(x,y)$ is the constitutive matrix in the stress–strain relation $\\sigma = \\mathbf{D} \\, \\varepsilon$. Consider plane stress with Poisson’s ratio $\\nu$ and Young’s modulus field $E(x,y)$ so that\n$$\n\\mathbf{D}(x,y) = \\frac{E(x,y)}{1-\\nu^2}\\begin{bmatrix} 1 & \\nu & 0 \\\\ \\nu & 1 & 0 \\\\ 0 & 0 & \\tfrac{1-\\nu}{2} \\end{bmatrix}.\n$$\n\nMap the element from the parent square $\\hat{\\Omega} = [-1,1]\\times[-1,1]$ with local coordinates $(\\xi,\\eta)$ to the physical domain $(x,y)$ using bilinear shape functions $\\{N_i(\\xi,\\eta)\\}_{i=1}^4$ associated with the element’s nodal coordinates $\\{(x_i,y_i)\\}_{i=1}^4$. Use the standard bilinear shape functions\n$$\n\\begin{aligned}\nN_1(\\xi,\\eta) &= \\tfrac{1}{4}(1-\\xi)(1-\\eta), \\\\\nN_2(\\xi,\\eta) &= \\tfrac{1}{4}(1+\\xi)(1-\\eta), \\\\\nN_3(\\xi,\\eta) &= \\tfrac{1}{4}(1+\\xi)(1+\\eta), \\\\\nN_4(\\xi,\\eta) &= \\tfrac{1}{4}(1-\\xi)(1+\\eta).\n\\end{aligned}\n$$\nFrom these, construct the Jacobian $\\mathbf{J}(\\xi,\\eta)$, its determinant $\\det\\mathbf{J}(\\xi,\\eta)$, and the derivatives of shape functions with respect to $(x,y)$ to form $\\mathbf{B}(\\xi,\\eta)$. The integral for $\\mathbf{K}_e$ is to be computed by tensor-product Gauss–Legendre quadrature of order $p$ in each parent-coordinate direction:\n$$\n\\mathbf{K}_e^{(p)} = \\sum_{i=1}^{p}\\sum_{j=1}^{p} \\mathbf{B}(\\xi_i,\\eta_j)^{\\mathsf T}\\,\\mathbf{D}(x(\\xi_i,\\eta_j),y(\\xi_i,\\eta_j))\\,\\mathbf{B}(\\xi_i,\\eta_j)\\,\\det\\mathbf{J}(\\xi_i,\\eta_j)\\,w_i\\,w_j,\n$$\nwhere $\\{(\\xi_i,w_i)\\}_{i=1}^p$ and $\\{(\\eta_j,w_j)\\}_{j=1}^p$ are the Gauss–Legendre nodes and weights on $[-1,1]$.\n\nDesign an adaptive refinement strategy in which the quadrature order starts at $p=p_0$ and is increased by $1$ at each step. At each refinement step, compare successive approximations using the Frobenius norm. Accept order $p^\\star$ if\n$$\n\\frac{\\lVert \\mathbf{K}_e^{(p^\\star)} - \\mathbf{K}_e^{(p^\\star-1)} \\rVert_F}{\\max\\big(\\lVert \\mathbf{K}_e^{(p^\\star)} \\rVert_F, \\varepsilon_{\\text{safe}}\\big)} \\le \\varepsilon_{\\text{tol}},\n$$\nwith a small safety floor $\\varepsilon_{\\text{safe}}$ to avoid division by zero. If the tolerance is not met by $p=p_{\\max}$, accept $p^\\star=p_{\\max}$.\n\nImplement this for plane stress with a spatially varying modulus\n$$\nE(x,y) = E_0\\left[1 + \\alpha \\sin(\\pi x)\\cos(\\pi y)\\right],\n$$\nwhere $E_0>0$ is a base Young’s modulus and $\\alpha \\in \\mathbb{R}$ controls heterogeneity. For $\\alpha=0$, the material is homogeneous.\n\nTest suite. Use the following four test cases, each defined by nodal coordinates in counterclockwise order $\\big((x_1,y_1),(x_2,y_2),(x_3,y_3),(x_4,y_4)\\big)$, Poisson’s ratio $\\nu$, base modulus $E_0$, heterogeneity parameter $\\alpha$, tolerance $\\varepsilon_{\\text{tol}}$, initial order $p_0$, and maximum order $p_{\\max}$:\n- Case A (affine rectangle, homogeneous): nodes $((0,0),(2,0),(2,1),(0,1))$, $\\nu=0.3$, $E_0=1.0$, $\\alpha=0.0$, $\\varepsilon_{\\text{tol}}=10^{-12}$, $p_0=1$, $p_{\\max}=12$.\n- Case B (distorted quadrilateral, homogeneous): nodes $((0,0),(1.2,0.1),(1.0,0.9),(-0.1,1.1))$, $\\nu=0.25$, $E_0=1.0$, $\\alpha=0.0$, $\\varepsilon_{\\text{tol}}=10^{-8}$, $p_0=1$, $p_{\\max}=12$.\n- Case C (affine square, heterogeneous): nodes $((0,0),(1,0),(1,1),(0,1))$, $\\nu=0.3$, $E_0=1.0$, $\\alpha=0.5$, $\\varepsilon_{\\text{tol}}=10^{-6}$, $p_0=1$, $p_{\\max}=12$.\n- Case D (distorted quadrilateral, heterogeneous, tight tolerance): nodes $((0.0,0.0),(1.1,-0.1),(1.0,1.0),(-0.2,1.1))$, $\\nu=0.28$, $E_0=1.0$, $\\alpha=0.8$, $\\varepsilon_{\\text{tol}}=10^{-10}$, $p_0=1$, $p_{\\max}=12$.\n\nAngle units are radians for the trigonometric functions in $E(x,y)$.\n\nYour program must:\n- For each case, run the adaptive procedure and return the smallest accepted quadrature order $p^\\star$ and the Frobenius norm $\\lVert \\mathbf{K}_e^{(p^\\star)} \\rVert_F$.\n- Report the Frobenius norm rounded to $8$ decimal places.\n- Produce a single line of output containing the results for all cases as a comma-separated list of lists with no spaces, in the exact format\n$[\\![p^\\star_A,\\lVert \\mathbf{K}_e^{(p^\\star_A)} \\rVert_F],[p^\\star_B,\\lVert \\mathbf{K}_e^{(p^\\star_B)} \\rVert_F],[p^\\star_C,\\lVert \\mathbf{K}_e^{(p^\\star_C)} \\rVert_F],[p^\\star_D,\\lVert \\mathbf{K}_e^{(p^\\star_D)} \\rVert_F]]$,\nfor example $[[3,0.12345678],[5,0.23456789],[4,0.34567890],[6,0.45678901]]$.\n\nYour final answer must be a complete, runnable program that implements the above and prints exactly one line in the specified format. No user input is required. The answer must be dimensionless; do not include any physical units in the output.", "solution": "The problem posed is the design and implementation of an adaptive numerical integration procedure for computing the element stiffness matrix of a four-node isoparametric quadrilateral element under plane stress conditions. The material properties, specifically Young's modulus, are permitted to vary spatially. This problem is scientifically sound and well-posed. We shall proceed with a systematic derivation followed by the implementation.\n\nThe element stiffness matrix $\\mathbf{K}_e$ is defined by the integral over the element's domain $\\Omega_e$:\n$$\n\\mathbf{K}_e = \\int_{\\Omega_e} \\mathbf{B}(x,y)^{\\mathsf T} \\, \\mathbf{D}(x,y) \\, \\mathbf{B}(x,y) \\, \\mathrm{d}\\Omega\n$$\nwhere $\\mathbf{B}$ is the strain-displacement matrix and $\\mathbf{D}$ is the constitutive matrix.\n\n**1. Isoparametric Mapping**\n\nThe core of the isoparametric formulation is to use the same shape functions to interpolate both the element's geometry and its displacement field. The physical coordinates $(x, y)$ of any point within the element are mapped from a master square element $\\hat{\\Omega} = [-1,1]\\times[-1,1]$ with local coordinates $(\\xi, \\eta)$.\n\nThe mapping is given by:\n$$\nx(\\xi,\\eta) = \\sum_{i=1}^{4} N_i(\\xi,\\eta) x_i\n$$\n$$\ny(\\xi,\\eta) = \\sum_{i=1}^{4} N_i(\\xi,\\eta) y_i\n$$\nwhere $(x_i, y_i)$ are the coordinates of the four element nodes and $N_i(\\xi,\\eta)$ are the bilinear shape functions provided.\n\n**2. Jacobian of the Transformation**\n\nTo evaluate spatial derivatives and transform the integral, we require the Jacobian matrix $\\mathbf{J}$ of the mapping:\n$$\n\\mathbf{J}(\\xi,\\eta) = \\begin{bmatrix} \\frac{\\partial x}{\\partial \\xi} & \\frac{\\partial y}{\\partial \\xi} \\\\ \\frac{\\partial x}{\\partial \\eta} & \\frac{\\partial y}{\\partial \\eta} \\end{bmatrix}\n$$\nThe entries of the Jacobian are computed by differentiating the mapping equations:\n$$\n\\frac{\\partial x}{\\partial \\xi} = \\sum_{i=1}^{4} \\frac{\\partial N_i}{\\partial \\xi} x_i, \\quad \\frac{\\partial y}{\\partial \\xi} = \\sum_{i=1}^{4} \\frac{\\partial N_i}{\\partial \\xi} y_i, \\quad \\text{etc.}\n$$\nThe differential area element transforms as $\\mathrm{d}\\Omega = \\mathrm{d}x \\mathrm{d}y = \\det(\\mathbf{J}) \\mathrm{d}\\xi \\mathrm{d}\\eta$. A valid mapping requires $\\det(\\mathbf{J}) > 0$ throughout the element.\n\n**3. Strain-Displacement Matrix ($\\mathbf{B}$-matrix)**\n\nThe displacement field within the element is interpolated from the nodal displacements $\\mathbf{u}_e = \\{u_{1x}, u_{1y}, \\dots, u_{4x}, u_{4y}\\}^\\mathsf{T}$. The strain vector for plane stress is $\\varepsilon = \\{\\varepsilon_{xx}, \\varepsilon_{yy}, \\gamma_{xy}\\}^\\mathsf{T}$, where $\\varepsilon_{xx} = \\partial u/\\partial x$, $\\varepsilon_{yy} = \\partial v/\\partial y$, and $\\gamma_{xy} = \\partial u/\\partial y + \\partial v/\\partial x$.\n\nThe strains are related to nodal displacements via the strain-displacement matrix $\\mathbf{B}$ as $\\varepsilon = \\mathbf{B} \\mathbf{u}_e$. The $\\mathbf{B}$ matrix is an $3 \\times 8$ matrix constructed from derivatives of the shape functions with respect to the physical coordinates $(x,y)$:\n$$\n\\mathbf{B} = [\\mathbf{B}_1, \\mathbf{B}_2, \\mathbf{B}_3, \\mathbf{B}_4], \\quad \\text{where} \\quad \\mathbf{B}_i = \\begin{bmatrix} \\frac{\\partial N_i}{\\partial x} & 0 \\\\ 0 & \\frac{\\partial N_i}{\\partial y} \\\\ \\frac{\\partial N_i}{\\partial y} & \\frac{\\partial N_i}{\\partial x} \\end{bmatrix}\n$$\nThe chain rule is used to find these derivatives:\n$$\n\\begin{pmatrix} \\frac{\\partial N_i}{\\partial x} \\\\ \\frac{\\partial N_i}{\\partial y} \\end{pmatrix} = \\mathbf{J}^{-1} \\begin{pmatrix} \\frac{\\partial N_i}{\\partial \\xi} \\\\ \\frac{\\partial N_i}{\\partial \\eta} \\end{pmatrix}\n$$\nNote that $\\mathbf{J}$ and thus $\\mathbf{B}$ are generally functions of $(\\xi,\\eta)$.\n\n**4. Constitutive Matrix ($\\mathbf{D}$-matrix)**\n\nFor an isotropic material under plane stress conditions, the constitutive matrix relates stress $\\sigma$ to strain $\\varepsilon$ ($\\sigma = \\mathbf{D} \\varepsilon$). It is given by:\n$$\n\\mathbf{D}(x,y) = \\frac{E(x,y)}{1-\\nu^2}\\begin{bmatrix} 1 & \\nu & 0 \\\\ \\nu & 1 & 0 \\\\ 0 & 0 & \\tfrac{1-\\nu}{2} \\end{bmatrix}\n$$\nIn this problem, Young's modulus $E$ is a function of physical coordinates $(x,y)$:\n$$\nE(x,y) = E_0\\left[1 + \\alpha \\sin(\\pi x)\\cos(\\pi y)\\right]\n$$\nDuring integration in the parent domain, this becomes $E(x(\\xi,\\eta), y(\\xi,\\eta))$.\n\n**5. Numerical Integration and Adaptive Scheme**\n\nThe integral for the stiffness matrix is transformed to the parent domain:\n$$\n\\mathbf{K}_e = \\int_{-1}^{1}\\int_{-1}^{1} \\mathbf{B}(\\xi,\\eta)^{\\mathsf T} \\mathbf{D}(x(\\xi,\\eta), y(\\xi,\\eta)) \\mathbf{B}(\\xi,\\eta) \\det(\\mathbf{J}(\\xi,\\eta)) \\, \\mathrm{d}\\xi \\mathrm{d}\\eta\n$$\nThis integral is approximated using a $p \\times p$ tensor-product Gauss-Legendre quadrature rule:\n$$\n\\mathbf{K}_e^{(p)} = \\sum_{i=1}^{p}\\sum_{j=1}^{p} w_i w_j \\left[ \\mathbf{B}(\\xi_i,\\eta_j)^{\\mathsf T} \\mathbf{D}(\\xi_i,\\eta_j) \\mathbf{B}(\\xi_i,\\eta_j) \\det(\\mathbf{J}(\\xi_i,\\eta_j)) \\right]\n$$\nwhere $(\\xi_i, w_i)$ and $(\\eta_j, w_j)$ are the Gauss-Legendre quadrature points and weights on $[-1,1]$.\n\nThe adaptive procedure is as follows:\n1. Start with an initial quadrature order $p = p_0$. Compute the stiffness matrix for this order, $\\mathbf{K}_{\\text{prev}} = \\mathbf{K}_e^{(p_0)}$.\n2. Iterate by incrementing the order, $p = p_0+1, p_0+2, \\dots, p_{\\max}$.\n3. In each iteration, compute the current stiffness matrix, $\\mathbf{K}_{\\text{curr}} = \\mathbf{K}_e^{(p)}$.\n4. Calculate the relative change using the Frobenius norm:\n$$\n\\text{error} = \\frac{\\lVert \\mathbf{K}_{\\text{curr}} - \\mathbf{K}_{\\text{prev}} \\rVert_F}{\\max\\big(\\lVert \\mathbf{K}_{\\text{curr}} \\rVert_F, \\varepsilon_{\\text{safe}}\\big)}\n$$\n5. If $\\text{error} \\le \\varepsilon_{\\text{tol}}$, the quadrature order $p$ is deemed sufficient. Set the final accepted order $p^\\star = p$ and terminate the process.\n6. If the condition is not met, update $\\mathbf{K}_{\\text{prev}} = \\mathbf{K}_{\\text{curr}}$ and proceed to the next order $p+1$.\n7. If the loop completes up to $p_{\\max}$ without convergence, the accepted order is a-priori set to $p^\\star = p_{\\max}$.\n\nThis procedure ensures that the quadrature order is automatically increased until the integral for the stiffness matrix is computed to the desired precision, adapting to the complexity of the integrand which depends on both element geometry and material heterogeneity. The implementation will systematically construct the necessary matrices at each Gauss point and execute the described adaptive loop.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import roots_legendre\n\ndef solve():\n    \"\"\"\n    Main solver function to run the adaptive quadrature for all test cases.\n    \"\"\"\n    # Safety floor for the relative error denominator to prevent division by zero.\n    EPS_SAFE = 1e-16\n\n    # Test cases defined in the problem statement.\n    test_cases = [\n        # Case A: affine rectangle, homogeneous\n        {'nodes': np.array([[0,0],[2,0],[2,1],[0,1]]), 'nu': 0.3, 'E0': 1.0, 'alpha': 0.0, 'tol': 1e-12, 'p0': 1, 'p_max': 12},\n        # Case B: distorted quadrilateral, homogeneous\n        {'nodes': np.array([[0,0],[1.2,0.1],[1.0,0.9],[-0.1,1.1]]), 'nu': 0.25, 'E0': 1.0, 'alpha': 0.0, 'tol': 1e-8, 'p0': 1, 'p_max': 12},\n        # Case C: affine square, heterogeneous\n        {'nodes': np.array([[0,0],[1,0],[1,1],[0,1]]), 'nu': 0.3, 'E0': 1.0, 'alpha': 0.5, 'tol': 1e-6, 'p0': 1, 'p_max': 12},\n        # Case D: distorted quadrilateral, heterogeneous\n        {'nodes': np.array([[0.0,0.0],[1.1,-0.1],[1.0,1.0],[-0.2,1.1]]), 'nu': 0.28, 'E0': 1.0, 'alpha': 0.8, 'tol': 1e-10, 'p0': 1, 'p_max': 12},\n    ]\n\n    # Cache for Gauss points and weights to avoid re-computation.\n    gauss_cache = {}\n\n    def get_gauss_points(p):\n        \"\"\"\n        Retrieves Gauss-Legendre quadrature points and weights for order p.\n        \"\"\"\n        if p not in gauss_cache:\n            points, weights = roots_legendre(p)\n            gauss_cache[p] = (points, weights)\n        return gauss_cache[p]\n\n    def get_shape_functions_and_derivs(xi, eta):\n        \"\"\"\n        Computes shape functions N and their derivatives w.r.t. (xi, eta) at a point.\n        \"\"\"\n        N = 0.25 * np.array([\n            (1 - xi) * (1 - eta),\n            (1 + xi) * (1 - eta),\n            (1 + xi) * (1 + eta),\n            (1 - xi) * (1 + eta)\n        ])\n        \n        # dN/dxi and dN/deta for each of the 4 shape functions\n        dN_dxi = 0.25 * np.array([\n            -(1 - eta),\n             (1 - eta),\n             (1 + eta),\n            -(1 + eta)\n        ])\n        dN_deta = 0.25 * np.array([\n            -(1 - xi),\n            -(1 + xi),\n             (1 + xi),\n             (1 - xi)\n        ])\n\n        return N, dN_dxi, dN_deta\n\n    def compute_stiffness_matrix(p, nodes, nu, E0, alpha):\n        \"\"\"\n        Computes the element stiffness matrix for a given quadrature order p.\n        \"\"\"\n        k_e = np.zeros((8, 8))\n        xi_pts, w_xi = get_gauss_points(p)\n        eta_pts, w_eta = get_gauss_points(p)\n\n        # Constitutive matrix D (constant part)\n        D_const = E0 / (1 - nu**2) * np.array([\n            [1, nu, 0],\n            [nu, 1, 0],\n            [0, 0, (1 - nu) / 2]\n        ])\n\n        for i in range(p):\n            for j in range(p):\n                xi, eta = xi_pts[i], eta_pts[j]\n                \n                N, dN_dxi, dN_deta = get_shape_functions_and_derivs(xi, eta)\n\n                # Jacobian matrix J\n                # J = [dx/dxi, dy/dxi; dx/deta, dy/deta]\n                J = np.zeros((2, 2))\n                J[0, 0] = np.dot(dN_dxi, nodes[:, 0])\n                J[0, 1] = np.dot(dN_dxi, nodes[:, 1])\n                J[1, 0] = np.dot(dN_deta, nodes[:, 0])\n                J[1, 1] = np.dot(dN_deta, nodes[:, 1])\n\n                detJ = np.linalg.det(J)\n                if detJ <= 0:\n                    raise ValueError(\"Jacobian determinant is non-positive.\")\n                invJ = np.linalg.inv(J)\n\n                # Derivatives of N w.r.t (x, y)\n                dN_dx_dy = np.vstack((dN_dxi, dN_deta))\n                dN_dxy = invJ @ dN_dx_dy\n                dN_dx = dN_dxy[0, :]\n                dN_dy = dN_dxy[1, :]\n\n                # Strain-displacement matrix B\n                B = np.zeros((3, 8))\n                for k in range(4):\n                    B[0, 2 * k] = dN_dx[k]\n                    B[1, 2 * k + 1] = dN_dy[k]\n                    B[2, 2 * k] = dN_dy[k]\n                    B[2, 2 * k + 1] = dN_dx[k]\n                \n                # Material properties at Gauss point\n                x_gp = np.dot(N, nodes[:, 0])\n                y_gp = np.dot(N, nodes[:, 1])\n                E_factor = 1.0 + alpha * np.sin(np.pi * x_gp) * np.cos(np.pi * y_gp)\n                D = D_const * E_factor\n\n                # Add contribution to stiffness matrix\n                integrand = B.T @ D @ B\n                k_e += integrand * detJ * w_xi[i] * w_eta[j]\n        \n        return k_e\n\n    results = []\n    for case in test_cases:\n        p0 = case['p0']\n        p_max = case['p_max']\n        tol = case['tol']\n        \n        p = p0\n        k_prev = compute_stiffness_matrix(p, case['nodes'], case['nu'], case['E0'], case['alpha'])\n        \n        p_star = p  # Initialize in case loop doesn't run\n        k_final = k_prev\n        \n        if p0 == p_max: # Special case if only one order is allowed\n            p_star = p_max\n            k_final = k_prev\n        else:\n            for p in range(p0 + 1, p_max + 1):\n                k_curr = compute_stiffness_matrix(p, case['nodes'], case['nu'], case['E0'], case['alpha'])\n                \n                norm_diff = np.linalg.norm(k_curr - k_prev, ord='fro')\n                norm_curr = np.linalg.norm(k_curr, ord='fro')\n                \n                error = norm_diff / max(norm_curr, EPS_SAFE)\n                \n                if error <= tol:\n                    p_star = p\n                    k_final = k_curr\n                    break # Convergence achieved\n                \n                k_prev = k_curr\n                p_star = p # Update p_star in case we hit p_max\n                k_final = k_curr\n        \n        final_norm = np.linalg.norm(k_final, ord='fro')\n        results.append(f\"[{p_star},{final_norm:.8f}]\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2599445"}]}