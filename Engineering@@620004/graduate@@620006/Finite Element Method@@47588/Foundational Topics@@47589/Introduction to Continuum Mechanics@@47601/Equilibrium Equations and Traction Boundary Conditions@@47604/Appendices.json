{"hands_on_practices": [{"introduction": "The weak form of the equilibrium equations translates boundary tractions into an integral term that contributes to the system's load vector. Accurately evaluating this boundary integral is paramount for a correct solution, and in the Finite Element Method, this is achieved through numerical quadrature. This first practice [@problem_id:2556076] challenges you to determine the precise requirements for these quadrature rules, connecting the polynomial degree of shape functions and traction fields to the minimum number of integration points needed for exactness. Mastering this ensures your implementation is not only correct but also computationally efficient.", "problem": "Consider the equilibrium of a deformable body governed by the Cauchy momentum balance in the absence of inertia, where the strong form is given by the divergence of the Cauchy stress tensor plus the body force field equal to zero inside the domain, and a traction boundary condition that prescribes the surface traction vector on a portion of the boundary. Denote the domain by $\\Omega$, the boundary with prescribed traction by $\\Gamma_{t}$, the Cauchy stress tensor by $\\boldsymbol{\\sigma}$, the outward unit normal by $\\boldsymbol{n}$, the body force per unit volume by $\\boldsymbol{b}$, and the prescribed traction vector by $\\boldsymbol{t}$. The fundamental laws are: $\\nabla \\cdot \\boldsymbol{\\sigma} + \\boldsymbol{b} = \\boldsymbol{0}$ in $\\Omega$, and $\\boldsymbol{\\sigma} \\boldsymbol{n} = \\boldsymbol{t}$ on $\\Gamma_{t}$. Using the principle of virtual work and test (virtual displacement) field $\\boldsymbol{v}$ with appropriate essential boundary conditions, the weak form contains the boundary integral $\\int_{\\Gamma_{t}} \\boldsymbol{v} \\cdot \\boldsymbol{t} \\,\\mathrm{d}\\Gamma$. In the finite element method (FEM), with shape functions $N_{i}$, the contribution to the global load vector for node $i$ from $\\Gamma_{t}$ is $\\int_{\\Gamma_{t}} N_{i} \\, \\boldsymbol{t} \\cdot \\boldsymbol{e} \\,\\mathrm{d}\\Gamma$, where $\\boldsymbol{e}$ is a standard basis vector selecting a displacement component.\n\nAssume isoparametric elements with an affine (linear) geometric mapping on each element so that boundary edges and faces map affinely from reference edges and faces, making the boundary Jacobian factor constant over each edge or face, and ensuring that a polynomial traction field on the physical edge or face becomes a polynomial of the same total degree in the reference coordinates. Consider polynomial Lagrange shape functions of degree $r \\in \\mathbb{N}$ restricted to edges or faces, and a traction field on that edge or face that is a polynomial of degree $q \\in \\mathbb{N}_{0}$ in the corresponding reference coordinates. Under these assumptions, the integrand of the boundary term on an edge or face is a polynomial whose degree is determined by the product $N_{i}$ times the traction, scaled by a constant boundary Jacobian factor.\n\nYour task is to implement numerical quadrature rules appropriate for boundary integrals and determine, for each given case, the minimal number of quadrature points required to integrate the boundary traction term exactly:\n- On edges: implement Gauss–Legendre quadrature on the reference interval $[-1,1]$ for any positive integer number of points $n$, and determine the minimal $n$ that guarantees exact integration of the polynomial integrand on an affine edge.\n- On triangular faces: implement symmetric quadrature rules on the reference triangle (for example, Dunavant-type rules) that are exact for polynomials up to a specified total degree $s$, for $s \\in \\{1,2,3,4,5\\}$, and determine the minimal number of quadrature points that guarantees exact integration of the polynomial integrand on an affine triangular face.\n\nWork from first principles: start from the strong form and traction boundary condition, derive the weak form boundary term, identify the polynomial degree of the integrand for the boundary traction contribution in terms of $r$ and $q$ under the affine mapping assumption, and deduce the associated quadrature exactness requirements. Then, implement the corresponding quadrature rules and compute the minimal number of points needed in each test case below.\n\nTest Suite (each item specifies the entity type and the pair $(r,q)$):\n- Edge: $(r,q) = (1,1)$.\n- Edge: $(r,q) = (2,0)$.\n- Edge: $(r,q) = (3,2)$.\n- Edge: $(r,q) = (1,0)$.\n- Triangular face: $(r,q) = (1,1)$.\n- Triangular face: $(r,q) = (2,2)$.\n- Triangular face: $(r,q) = (3,1)$.\n- Triangular face: $(r,q) = (1,0)$.\n\nYour program must:\n- Implement Gauss–Legendre quadrature on $[-1,1]$ for arbitrary positive integer $n$.\n- Implement triangular quadrature rules that are exact for total polynomial degree $s \\in \\{1,2,3,4,5\\}$.\n- For each test case, compute the minimal number of quadrature points ensuring exact evaluation of the boundary traction integral under the stated assumptions.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list of integers enclosed in square brackets (for example, $[a,b,c]$), where each integer is the minimal number of quadrature points for the corresponding test case in the order listed above.", "solution": "We begin from balance of linear momentum in the absence of inertia and quasi-static conditions, given by $\\nabla \\cdot \\boldsymbol{\\sigma} + \\boldsymbol{b} = \\boldsymbol{0}$ in $\\Omega$, supplemented with traction boundary conditions $\\boldsymbol{\\sigma}\\boldsymbol{n} = \\boldsymbol{t}$ on $\\Gamma_{t}$. Let $\\boldsymbol{v}$ be an admissible virtual displacement field. The principle of virtual work yields\n$$\n\\int_{\\Omega} \\boldsymbol{\\varepsilon}(\\boldsymbol{v}) : \\boldsymbol{\\sigma} \\,\\mathrm{d}\\Omega = \\int_{\\Omega} \\boldsymbol{v}\\cdot \\boldsymbol{b} \\,\\mathrm{d}\\Omega + \\int_{\\Gamma_{t}} \\boldsymbol{v}\\cdot \\boldsymbol{t} \\,\\mathrm{d}\\Gamma,\n$$\nwhere $\\boldsymbol{\\varepsilon}(\\boldsymbol{v})$ is the small-strain tensor. In a finite element method (FEM) discretization with shape functions $N_{i}$ and nodal virtual displacements $\\delta \\boldsymbol{u}_{i}$, we take $\\boldsymbol{v} \\approx \\sum_{i} N_{i} \\,\\delta \\boldsymbol{u}_{i}$. The traction boundary contribution to the discrete load vector component associated with node $i$ and a given displacement component direction is\n$$\nf_{i}^{\\Gamma} = \\int_{\\Gamma_{t}} N_{i} \\, t \\, \\mathrm{d}\\Gamma,\n$$\nwhere $t$ denotes the corresponding component of the traction vector. This scalar boundary integral is evaluated over element boundary segments: in two dimensions on edges (one-dimensional manifolds) and in three dimensions on faces (two-dimensional manifolds).\n\nWe assume an isoparametric formulation with affine (linear) geometric mapping on each element. For an edge integral, the mapping from the reference interval $[-1,1]$ to the physical edge is affine. The boundary Jacobian factor $J_{\\Gamma}$, which converts a reference integral to a physical one, is constant on each affine edge, so the integrand’s polynomial character is unaffected except for a multiplicative constant. Let the shape functions on the edge be polynomials of degree $r \\in \\mathbb{N}$ when restricted to the edge, and let the traction component $t$ be a polynomial of degree $q \\in \\mathbb{N}_{0}$ along that edge. Then the integrand $N_{i} \\, t$ on the edge is a one-dimensional polynomial of degree $r+q$ in the reference coordinate. To integrate this exactly by Gauss–Legendre quadrature with $n$ points on $[-1,1]$, we use the established result that an $n$-point Gauss–Legendre rule is exact for all polynomials up to degree $2n-1$. Therefore, exactness requires\n$$\n2n - 1 \\ge r + q \\quad \\Longrightarrow \\quad n \\ge \\left\\lceil \\frac{r+q+1}{2} \\right\\rceil,\n$$\nso the minimal number of Gauss–Legendre points on an affine edge is $n_{\\text{edge}} = \\left\\lceil \\frac{r+q+1}{2} \\right\\rceil$.\n\nFor a triangular face of a tetrahedral element, the mapping from the reference triangle to the physical face is affine. The boundary area Jacobian $J_{\\Gamma}$ is constant on each face, and the restriction of the shape function $N_{i}$ of degree $r$ to the face is a bivariate polynomial of total degree $r$ in the reference triangle coordinates. If the traction component $t$ is a bivariate polynomial of total degree $q$ on the face, then the product $N_{i}\\, t$ is a bivariate polynomial of total degree $r+q$. A symmetric triangle quadrature rule that is exact for all polynomials up to total degree $s$ will integrate this exactly if $s \\ge r+q$. Minimal-point rules with guaranteed exactness degrees $s$ are widely tabulated. One convenient set is the Dunavant rules, which provide, for example:\n- Degree $s \\le 1$: $1$ point (centroid rule).\n- Degree $s \\le 2$: $3$ points.\n- Degree $s \\le 3$: $4$ points.\n- Degree $s \\le 4$: $6$ points.\n- Degree $s \\le 5$: $7$ points.\n\nThus, for a triangular face under the stated assumptions, the minimal number of quadrature points is obtained by selecting the smallest available rule with $s \\ge r+q$ and reporting its number of points.\n\nAlgorithmic design:\n- Implement Gauss–Legendre quadrature on $[-1,1]$ using orthogonal polynomial machinery to obtain nodes and weights for arbitrary $n$. The exactness degree is $2n-1$, so the minimal required $n$ is $n_{\\text{edge}} = \\left\\lceil \\frac{r+q+1}{2} \\right\\rceil$.\n- Implement triangular quadrature rules for exactness degrees $s \\in \\{1,2,3,4,5\\}$ with their nodes and weights (e.g., Dunavant rules). For a given $(r,q)$, compute $m = r+q$, pick the smallest $s \\in \\{1,2,3,4,5\\}$ such that $s \\ge m$, and return the number of points of that rule.\n- Apply these to the test suite in the order specified and output the minimal numbers as integers.\n\nApplying the formulas to the test suite yields:\n- Edge $(r,q)=(1,1)$: $n_{\\text{edge}}=\\left\\lceil \\frac{1+1+1}{2} \\right\\rceil = \\left\\lceil \\frac{3}{2} \\right\\rceil = 2$.\n- Edge $(r,q)=(2,0)$: $n_{\\text{edge}}=\\left\\lceil \\frac{2+0+1}{2} \\right\\rceil = \\left\\lceil \\frac{3}{2} \\right\\rceil = 2$.\n- Edge $(r,q)=(3,2)$: $n_{\\text{edge}}=\\left\\lceil \\frac{3+2+1}{2} \\right\\rceil = \\left\\lceil \\frac{6}{2} \\right\\rceil = 3$.\n- Edge $(r,q)=(1,0)$: $n_{\\text{edge}}=\\left\\lceil \\frac{1+0+1}{2} \\right\\rceil = \\left\\lceil \\frac{2}{2} \\right\\rceil = 1$.\n- Face $(r,q)=(1,1)$: $m=1+1=2 \\Rightarrow s=2$ suffices $\\Rightarrow 3$ points.\n- Face $(r,q)=(2,2)$: $m=2+2=4 \\Rightarrow s=4$ suffices $\\Rightarrow 6$ points.\n- Face $(r,q)=(3,1)$: $m=3+1=4 \\Rightarrow s=4$ suffices $\\Rightarrow 6$ points.\n- Face $(r,q)=(1,0)$: $m=1+0=1 \\Rightarrow s=1$ suffices $\\Rightarrow 1$ point.\n\nTherefore, the required outputs, in order, are the integers $[2,2,3,1,3,6,6,1]$, and the program will compute them using the implemented quadrature rule logic.", "answer": "```python\nimport numpy as np\n\n# Implement Gauss-Legendre quadrature on [-1, 1]\ndef gauss_legendre_rule(n):\n    # Returns nodes and weights for n-point Gauss-Legendre\n    # Using numpy's leggauss for robustness\n    from numpy.polynomial.legendre import leggauss\n    nodes, weights = leggauss(n)\n    return nodes, weights\n\n# Implement Dunavant-type symmetric triangle quadrature rules\n# providing exactness up to degrees 1..5. Returns (points, weights, degree, n_points).\n# Points are given in barycentric coordinates (L1,L2,L3) with L1+L2+L3=1, L_i >= 0.\ndef triangle_rule_by_degree_exactness(s_required):\n    # Select the minimal rule with exactness >= s_required from available set.\n    # Data from standard Dunavant rules.\n    rules = [\n        # degree, points (barycentric), weights\n        (1,\n         np.array([[1/3, 1/3, 1/3]]),\n         np.array([1.0])),\n        (2,\n         np.array([\n             [2/3, 1/6, 1/6],\n             [1/6, 2/3, 1/6],\n             [1/6, 1/6, 2/3],\n         ]),\n         np.array([1/3, 1/3, 1/3])),\n        (3,\n         np.array([\n             [1/3, 1/3, 1/3],\n             [0.6, 0.2, 0.2],\n             [0.2, 0.6, 0.2],\n             [0.2, 0.2, 0.6],\n         ]),\n         np.array([-27/48, 25/48, 25/48, 25/48])),\n        (4,\n         np.array([\n             [0.445948490915965, 0.445948490915965, 0.108103018168070],\n             [0.445948490915965, 0.108103018168070, 0.445948490915965],\n             [0.108103018168070, 0.445948490915965, 0.445948490915965],\n             [0.091576213509771, 0.091576213509771, 0.816847572980458],\n             [0.091576213509771, 0.816847572980458, 0.091576213509771],\n             [0.816847572980458, 0.091576213509771, 0.091576213509771],\n         ]),\n         np.array([\n             0.223381589678011,\n             0.223381589678011,\n             0.223381589678011,\n             0.109951743655322,\n             0.109951743655322,\n             0.109951743655322,\n         ])),\n        (5,\n         np.array([\n             [1/3, 1/3, 1/3],\n             [0.059715871789770, 0.470142064105115, 0.470142064105115],\n             [0.470142064105115, 0.059715871789770, 0.470142064105115],\n             [0.470142064105115, 0.470142064105115, 0.059715871789770],\n             [0.797426985353087, 0.101286507323456, 0.101286507323456],\n             [0.101286507323456, 0.797426985353087, 0.101286507323456],\n             [0.101286507323456, 0.101286507323456, 0.797426985353087],\n         ]),\n         np.array([\n             0.225000000000000,\n             0.132394152788506,\n             0.132394152788506,\n             0.132394152788506,\n             0.125939180544827,\n             0.125939180544827,\n             0.125939180544827,\n         ])),\n    ]\n    # Choose smallest rule with degree >= s_required\n    for degree, pts, wts in rules:\n        if degree >= s_required:\n            return pts, wts, degree, pts.shape[0]\n    # If higher degree requested than available, raise error\n    raise ValueError(\"Requested triangle quadrature exactness degree exceeds available rules (max 5).\")\n\n# Compute minimal number of Gauss-Legendre points for edge integrals\ndef minimal_edge_points(r, q):\n    # n such that 2n-1 >= r+q -> n >= ceil((r+q+1)/2)\n    return int(np.ceil((r + q + 1) / 2.0))\n\n# Compute minimal number of triangle quadrature points for face integrals\ndef minimal_triangle_face_points(r, q):\n    m = r + q  # required total degree exactness\n    _, _, _, npts = triangle_rule_by_degree_exactness(m)\n    return npts\n\ndef solve():\n    # Define the test suite in the specified order\n    # Each tuple: (entity_type, r, q)\n    test_cases = [\n        (\"edge\", 1, 1),\n        (\"edge\", 2, 0),\n        (\"edge\", 3, 2),\n        (\"edge\", 1, 0),\n        (\"face_triangle\", 1, 1),\n        (\"face_triangle\", 2, 2),\n        (\"face_triangle\", 3, 1),\n        (\"face_triangle\", 1, 0),\n    ]\n\n    results = []\n    for entity, r, q in test_cases:\n        if entity == \"edge\":\n            # implement rule (nodes, weights) though only count is needed\n            n = minimal_edge_points(r, q)\n            _nodes, _weights = gauss_legendre_rule(n)\n            results.append(n)\n        elif entity == \"face_triangle\":\n            npts = minimal_triangle_face_points(r, q)\n            # also obtain nodes and weights (unused in result)\n            _pts, _wts, _deg, _ = triangle_rule_by_degree_exactness(r + q)\n            results.append(npts)\n        else:\n            raise ValueError(\"Unknown entity type in test cases.\")\n\n    # Final output format: single line with comma-separated list enclosed in brackets\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2556076"}, {"introduction": "While introductory examples often feature domains with straight edges, realistic engineering problems almost always involve curved boundaries. Accurately capturing these geometries and the associated boundary conditions is a hallmark of a robust finite element code. This exercise [@problem_id:2556094] delves into the essential procedures for handling traction integrals on higher-order, curved elements, forcing you to consider how the non-constant normal vector $\\boldsymbol{n}$ and differential line or area element $d\\Gamma$ must be calculated from the geometric mapping.", "problem": "Consider a linear elastostatic boundary value problem on a domain $\\Omega \\subset \\mathbb{R}^2$ with Cauchy stress tensor $\\boldsymbol{\\sigma}(\\mathbf{x})$ and body force density $\\mathbf{b}(\\mathbf{x})$. The strong form is $\\nabla \\cdot \\boldsymbol{\\sigma} + \\mathbf{b} = \\mathbf{0}$ in $\\Omega$, with essential boundary $\\Gamma_u$ where $\\mathbf{u} = \\bar{\\mathbf{u}}$ and traction boundary $\\Gamma_t$ where $\\boldsymbol{\\sigma} \\, \\mathbf{n} = \\bar{\\mathbf{t}}$. In the weak form used by the Finite Element Method (FEM), the traction boundary condition enters as the boundary integral $\\int_{\\Gamma_t} \\mathbf{v} \\cdot \\bar{\\mathbf{t}} \\, d\\Gamma$, where $\\mathbf{v}$ is a kinematically admissible virtual displacement.\n\nFocus on a single boundary edge (in $2$D) or boundary patch (in $3$D) of an isoparametric/superparametric element whose geometry is represented by higher-order geometry shape functions of polynomial degree $p_g \\ge 2$. Let $\\Gamma_e \\subset \\Gamma_t$ be a curved boundary segment that is the image of a reference edge under a smooth geometry mapping. The element employs displacement shape functions of polynomial degree $p_u \\ge 1$ (not necessarily equal to $p_g$). The element traction force vector is assembled from $\\int_{\\Gamma_e} \\mathbf{N}^\\top \\bar{\\mathbf{t}} \\, d\\Gamma$, where $\\mathbf{N}$ collects the displacement shape functions evaluated on $\\Gamma_e$.\n\nStarting only from (i) the definition of traction as $\\boldsymbol{\\sigma} \\, \\mathbf{n}$ on $\\Gamma_t$, (ii) the definition of the weak form boundary term, and (iii) the geometric definition of tangents, normals, and induced measures from a parametrization, determine how the use of higher-order geometry shape functions on $\\Gamma_e$ affects the computation of unit normals and traction integrals.\n\nWhich of the following statements are correct?\n\nA. For a $2$D curved boundary edge parameterized by the higher-order geometry mapping $\\mathbf{x}(\\xi)$, $\\xi \\in [-1,1]$, the unit normal at a point is obtained by normalizing a vector perpendicular to the physical tangent $\\boldsymbol{\\tau}(\\xi) = \\dfrac{d\\mathbf{x}}{d\\xi}$, e.g., $\\mathbf{n}(\\xi) = \\pm \\dfrac{[\\tau_2(\\xi), -\\tau_1(\\xi)]^\\top}{\\|\\boldsymbol{\\tau}(\\xi)\\|}$ with the sign chosen to be outward, and the line element is $d\\Gamma = \\|\\boldsymbol{\\tau}(\\xi)\\| \\, d\\xi$. Therefore the element traction integral becomes $\\int_{-1}^{1} \\mathbf{N}(\\xi)^\\top \\, \\bar{\\mathbf{t}}(\\mathbf{x}(\\xi)) \\, \\|\\boldsymbol{\\tau}(\\xi)\\| \\, d\\xi$.\n\nB. Since the geometry edge is of higher order, the normal can be taken constant per element equal to the normal of the straight chord between the edge endpoints, while the line element is approximated by the length of that chord, without affecting the convergence order of the boundary traction contribution.\n\nC. In $3$D, for a boundary surface patch parameterized by the higher-order geometry mapping $\\mathbf{x}(\\xi,\\eta)$, the correct surface measure is $d\\Gamma = \\left\\|\\dfrac{\\partial \\mathbf{x}}{\\partial \\xi} \\times \\dfrac{\\partial \\mathbf{x}}{\\partial \\eta}\\right\\| \\, d\\xi \\, d\\eta$, and the outward unit normal is $\\mathbf{n} = \\dfrac{\\dfrac{\\partial \\mathbf{x}}{\\partial \\xi} \\times \\dfrac{\\partial \\mathbf{x}}{\\partial \\eta}}{\\left\\|\\dfrac{\\partial \\mathbf{x}}{\\partial \\xi} \\times \\dfrac{\\partial \\mathbf{x}}{\\partial \\eta}\\right\\|}$, both evaluated pointwise using the higher-order geometry mapping.\n\nD. The traction vector to impose in the integrand must be transformed to reference coordinates using the inverse transpose of the Jacobian of the parent-to-physical volume mapping, i.e., use $\\hat{\\mathbf{t}} = \\mathbf{J}^{-T} \\, \\bar{\\mathbf{t}}$ and integrate $\\hat{\\mathbf{t}}$ against the reference shape functions on the reference edge with unit weight.\n\nE. When $p_g > p_u$ (superparametric geometry), it is consistent to evaluate the test function matrix $\\mathbf{N}(\\xi)$ built from the displacement shape functions of order $p_u$ and the geometry derivatives from the higher-order mapping of order $p_g$ at the same quadrature points on the reference edge; the resulting pullback integral correctly captures curvature-induced variations in both $\\mathbf{n}(\\xi)$ and $d\\Gamma$ without modifying $\\mathbf{N}(\\xi)$.\n\nSelect all that apply.", "solution": "The fundamental task is the evaluation of the element traction force vector, which arises from the weak form:\n$$\n\\mathbf{f}_t^e = \\int_{\\Gamma_e} \\mathbf{N}^\\top \\bar{\\mathbf{t}} \\, d\\Gamma\n$$\nHere, $\\mathbf{N}$ is the matrix of displacement shape functions, and $\\bar{\\mathbf{t}}$ is the prescribed traction vector on the element boundary $\\Gamma_e$. Since $\\Gamma_e$ is a curved boundary defined by a mapping from a reference domain, the integral must be transformed to this reference domain for numerical evaluation (e.g., using Gaussian quadrature). This transformation, or pullback, requires expressing the geometric quantities—the differential measure $d\\Gamma$ and the unit normal vector $\\mathbf{n}$ (if $\\bar{\\mathbf{t}}$ depends on it)—in terms of reference coordinates. The use of higher-order geometry ($p_g \\ge 2$) means these geometric quantities will not be constant over the element boundary.\n\nLet us analyze the situation in $2$D and $3$D.\n\nIn $2$D, a curved boundary edge $\\Gamma_e$ is parameterized by a mapping $\\mathbf{x}(\\xi): [-1, 1] \\to \\mathbb{R}^2$. The physical coordinates $\\mathbf{x}$ are given by the geometry shape functions of degree $p_g$. The tangent vector to the curve in the physical domain is:\n$$\n\\boldsymbol{\\tau}(\\xi) = \\frac{d\\mathbf{x}}{d\\xi}\n$$\nThe differential arc length element $d\\Gamma$ is related to the differential reference element $d\\xi$ by the magnitude of this tangent vector, which is the Jacobian of the $1$D-to-$2$D mapping:\n$$\nd\\Gamma = \\left\\| \\frac{d\\mathbf{x}}{d\\xi} \\right\\| d\\xi = \\|\\boldsymbol{\\tau}(\\xi)\\| \\, d\\xi\n$$\nThe outward unit normal vector $\\mathbf{n}(\\xi)$ is perpendicular to the tangent vector $\\boldsymbol{\\tau}(\\xi)$ and has unit length. For a tangent $\\boldsymbol{\\tau} = [\\tau_1, \\tau_2]^\\top$, a perpendicular vector is $[-\\tau_2, \\tau_1]^\\top$. Normalizing gives:\n$$\n\\mathbf{n}(\\xi) = \\pm\\frac{1}{\\|\\boldsymbol{\\tau}(\\xi)\\|} \\begin{bmatrix} -\\tau_2(\\xi) \\\\ \\tau_1(\\xi) \\end{bmatrix} \\quad (\\text{sign chosen to be outward})\n$$\nThe traction force integral is then pulled back to the reference domain:\n$$\n\\mathbf{f}_t^e = \\int_{-1}^{1} \\mathbf{N}(\\xi)^\\top \\, \\bar{\\mathbf{t}}(\\mathbf{x}(\\xi)) \\, \\|\\boldsymbol{\\tau}(\\xi)\\| \\, d\\xi\n$$\nSince $p_g \\ge 2$, $\\mathbf{x}(\\xi)$ is nonlinear, and its derivative $\\boldsymbol{\\tau}(\\xi)$ is a vector of polynomials of degree up to $p_g-1$. The term $\\|\\boldsymbol{\\tau}(\\xi)\\|$ is therefore a non-constant, non-polynomial function of $\\xi$ that must be evaluated pointwise during numerical integration.\n\nIn $3$D, a curved boundary patch $\\Gamma_e$ is parameterized by a mapping $\\mathbf{x}(\\xi, \\eta)$ from a reference domain (e.g., a square $[-1,1]^2$). The two tangent vectors on the surface are:\n$$\n\\boldsymbol{\\tau}_\\xi = \\frac{\\partial \\mathbf{x}}{\\partial \\xi}, \\quad \\boldsymbol{\\tau}_\\eta = \\frac{\\partial \\mathbf{x}}{\\partial \\eta}\n$$\nA vector normal to the surface is given by their cross product. The differential surface area element $d\\Gamma$ is the magnitude of this cross product multiplied by the reference area element $d\\xi d\\eta$:\n$$\nd\\Gamma = \\left\\| \\frac{\\partial \\mathbf{x}}{\\partial \\xi} \\times \\frac{\\partial \\mathbf{x}}{\\partial \\eta} \\right\\| d\\xi d\\eta\n$$\nThe outward unit normal vector $\\mathbf{n}(\\xi, \\eta)$ is the normalized cross product:\n$$\n\\mathbf{n}(\\xi, \\eta) = \\frac{\\frac{\\partial \\mathbf{x}}{\\partial \\xi} \\times \\frac{\\partial \\mathbf{x}}{\\partial \\eta}}{\\left\\| \\frac{\\partial \\mathbf{x}}{\\partial \\xi} \\times \\frac{\\partial \\mathbf{x}}{\\partial \\eta} \\right\\|}\n$$\nAgain, since $p_g \\ge 2$, these geometric quantities are non-constant functions of $(\\xi, \\eta)$ and must be calculated pointwise.\n\nNow, we evaluate each option.\n\nA. For a $2$D curved boundary edge parameterized by the higher-order geometry mapping $\\mathbf{x}(\\xi)$, $\\xi \\in [-1,1]$, the unit normal at a point is obtained by normalizing a vector perpendicular to the physical tangent $\\boldsymbol{\\tau}(\\xi) = \\dfrac{d\\mathbf{x}}{d\\xi}$, e.g., $\\mathbf{n}(\\xi) = \\pm \\dfrac{[\\tau_2(\\xi), -\\tau_1(\\xi)]^\\top}{\\|\\boldsymbol{\\tau}(\\xi)\\|}$ with the sign chosen to be outward, and the line element is $d\\Gamma = \\|\\boldsymbol{\\tau}(\\xi)\\| \\, d\\xi$. Therefore the element traction integral becomes $\\int_{-1}^{1} \\mathbf{N}(\\xi)^\\top \\, \\bar{\\mathbf{t}}(\\mathbf{x}(\\xi)) \\, \\|\\boldsymbol{\\tau}(\\xi)\\| \\, d\\xi$.\nThis statement accurately presents the standard procedure derived from first principles of calculus for a parameterized curve. The definition of the tangent vector, the unit normal, the differential line element (arc length), and the resulting pullback of the specified integral are all correct.\nVerdict: **Correct**.\n\nB. Since the geometry edge is of higher order, the normal can be taken constant per element equal to the normal of the straight chord between the edge endpoints, while the line element is approximated by the length of that chord, without affecting the convergence order of the boundary traction contribution.\nThis statement proposes a gross simplification. Using a constant normal and a straight-line length for a curved element defined by higher-order functions discards the very geometric accuracy that these functions are intended to provide. Such an inconsistent approximation of the domain boundary introduces a geometric error that does not decrease at an optimal rate with mesh refinement. This is a form of \"variational crime\" that is known to degrade the convergence order of the finite element solution. The claim that this does not affect the convergence order is false.\nVerdict: **Incorrect**.\n\nC. In $3$D, for a boundary surface patch parameterized by the higher-order geometry mapping $\\mathbf{x}(\\xi,\\eta)$, the correct surface measure is $d\\Gamma = \\left\\|\\dfrac{\\partial \\mathbf{x}}{\\partial \\xi} \\times \\dfrac{\\partial \\mathbf{x}}{\\partial \\eta}\\right\\| \\, d\\xi \\, d\\eta$, and the outward unit normal is $\\mathbf{n} = \\dfrac{\\dfrac{\\partial \\mathbf{x}}{\\partial \\xi} \\times \\dfrac{\\partial \\mathbf{x}}{\\partial \\eta}}{\\left\\|\\dfrac{\\partial \\mathbf{x}}{\\partial \\xi} \\times \\dfrac{\\partial \\mathbf{x}}{\\partial \\eta}\\right\\|}$, both evaluated pointwise using the higher-order geometry mapping.\nThis statement correctly identifies the fundamental formulas from differential geometry for the surface area element and the unit normal vector of a parameterized surface. It correctly emphasizes that for a higher-order mapping, these quantities are not constant and must be evaluated pointwise (i.e., at each quadrature point). This is the correct procedure for handling curved surfaces in $3$D FEM.\nVerdict: **Correct**.\n\nD. The traction vector to impose in the integrand must be transformed to reference coordinates using the inverse transpose of the Jacobian of the parent-to-physical volume mapping, i.e., use $\\hat{\\mathbf{t}} = \\mathbf{J}^{-T} \\, \\bar{\\mathbf{t}}$ and integrate $\\hat{\\mathbf{t}}$ against the reference shape functions on the reference edge with unit weight.\nThis statement is incorrect. It confuses the transformation of a flux vector in the context of the divergence theorem (the Piola transform) with the evaluation of a boundary integral. The traction vector $\\bar{\\mathbf{t}}$ is a force per unit *physical* area, defined in the physical coordinate system. There is no need to transform its components to a reference system. The correct procedure is to evaluate the physical vectors $\\mathbf{v}$ (represented by $\\mathbf{N}$) and $\\bar{\\mathbf{t}}$ in the physical coordinate system and correctly transform the integration measure $d\\Gamma$, as described in options A and C. Furthermore, it incorrectly refers to the Jacobian of the *volume* mapping for a *boundary* integral.\nVerdict: **Incorrect**.\n\nE. When $p_g > p_u$ (superparametric geometry), it is consistent to evaluate the test function matrix $\\mathbf{N}(\\xi)$ built from the displacement shape functions of order $p_u$ and the geometry derivatives from the higher-order mapping of order $p_g$ at the same quadrature points on the reference edge; the resulting pullback integral correctly captures curvature-induced variations in both $\\mathbf{n}(\\xi)$ and $d\\Gamma$ without modifying $\\mathbf{N}(\\xi)$.\nThis statement correctly describes the numerical integration process for superparametric (and isoparametric) elements. The integrand, for example $\\mathbf{N}(\\xi)^\\top \\bar{\\mathbf{t}}(\\mathbf{x}(\\xi)) \\|\\boldsymbol{\\tau}(\\xi)\\|$, is a single, composite function of the reference coordinate $\\xi$. To integrate it numerically, all its constituent parts—$\\mathbf{N}(\\xi)$ from the $p_u$ approximation, and the geometric terms like $\\mathbf{x}(\\xi)$ and $\\boldsymbol{\\tau}(\\xi)$ from the $p_g$ approximation—must be evaluated at the same quadrature points. This process correctly couples the lower-order displacement field with the higher-order geometry. The curvature effects are embedded in the geometric terms ($\\mathbf{n}(\\xi)$ and the Jacobian $\\|\\boldsymbol{\\tau}(\\xi)\\|$) which are computed from the $p_g$ mapping. The displacement shape function matrix $\\mathbf{N}(\\xi)$ itself remains unmodified. The procedure is consistent and standard.\nVerdict: **Correct**.", "answer": "$$\\boxed{ACE}$$", "id": "2556094"}, {"introduction": "After mastering the components of implementing traction boundary conditions, the ultimate test is verifying that your complete solver works as expected. The Method of Manufactured Solutions provides a rigorous framework for this, where a known analytical solution is used to generate a problem for which the exact answer is known. This capstone practice [@problem_id:2556099] guides you through a full verification exercise, starting from an Airy stress function to define a problem with non-trivial traction boundary conditions, and culminating in the implementation of an FEM solver to validate its accuracy against the exact solution.", "problem": "Consider two-dimensional, small-strain, linear elastostatics in plane stress on a rectangular domain $\\Omega = [0,L_x] \\times [0,L_y]$. Let the material be homogeneous and isotropic with Young's modulus $E$ and Poisson's ratio $\\nu$. The unknown displacement field is $\\mathbf{u}(x,y) = (u_x(x,y), u_y(x,y))$. There are no body forces. Tractions are prescribed on the entire boundary $\\partial \\Omega$.\n\nTo guarantee exact satisfaction of the strong-form equilibrium equations with zero body force, use an Airy stress function $F(x,y)$ and define the stress tensor by\n$$\n\\sigma_{xx} = \\frac{\\partial^2 F}{\\partial y^2}, \\quad\n\\sigma_{yy} = \\frac{\\partial^2 F}{\\partial x^2}, \\quad\n\\sigma_{xy} = -\\frac{\\partial^2 F}{\\partial x \\partial y}.\n$$\nChoose the cubic Airy stress function\n$$\nF(x,y) = a\\,x\\,y^3 + b\\,x^3\\,y + c\\,x^2\\,y + d\\,x\\,y^2,\n$$\nwhere $a$, $b$, $c$, and $d$ are given constants. Because $F$ is a polynomial of degree at most $3$, it is biharmonic, so the resulting stress field satisfies compatibility for zero body forces in linear elasticity.\n\nThe boundary traction is defined as $\\mathbf{t} = \\boldsymbol{\\sigma}\\,\\mathbf{n}$ on $\\partial \\Omega$, where $\\mathbf{n}$ is the outward unit normal. On the four edges of the rectangle, the outward unit normals are constant:\n- on $x=0$: $\\mathbf{n} = (-1,0)$,\n- on $x=L_x$: $\\mathbf{n} = (1,0)$,\n- on $y=0$: $\\mathbf{n} = (0,-1)$,\n- on $y=L_y$: $\\mathbf{n} = (0,1)$.\n\nLet the constitutive law for plane stress relate stresses to engineering strains $\\boldsymbol{\\varepsilon}_{\\text{eng}} = (\\varepsilon_{xx}, \\varepsilon_{yy}, \\gamma_{xy})^T$ by\n$$\n\\boldsymbol{\\sigma} = \\mathbf{D}\\,\\boldsymbol{\\varepsilon}_{\\text{eng}}, \\quad\n\\mathbf{D} = \\frac{E}{1-\\nu^2}\n\\begin{bmatrix}\n1 & \\nu & 0 \\\\\n\\nu & 1 & 0 \\\\\n0 & 0 & \\frac{1-\\nu}{2}\n\\end{bmatrix},\n$$\nand the compliance relation $\\boldsymbol{\\varepsilon}_{\\text{eng}} = \\mathbf{S}\\,\\boldsymbol{\\sigma}$, with\n$$\n\\mathbf{S} =\n\\begin{bmatrix}\n\\frac{1}{E} & -\\frac{\\nu}{E} & 0 \\\\\n-\\frac{\\nu}{E} & \\frac{1}{E} & 0 \\\\\n0 & 0 & \\frac{2(1+\\nu)}{E}\n\\end{bmatrix}.\n$$\nThe engineering shear is $\\gamma_{xy} = \\partial u_x/\\partial y + \\partial u_y/\\partial x$. With zero body forces and only traction boundary conditions, the weak form is: find $\\mathbf{u} \\in V$ such that for all virtual displacements $\\mathbf{v} \\in V_0$,\n$$\n\\int_{\\Omega} \\boldsymbol{\\varepsilon}_{\\text{eng}}(\\mathbf{v})^T \\mathbf{D}\\, \\boldsymbol{\\varepsilon}_{\\text{eng}}(\\mathbf{u}) \\, d\\Omega\n=\n\\int_{\\partial \\Omega} \\mathbf{v} \\cdot \\mathbf{t} \\, d\\Gamma.\n$$\nTo remove rigid body modes uniquely, impose the minimal essential constraints\n$$\nu_x(0,0) = 0,\\quad u_y(0,0) = 0,\\quad u_y(L_x,0)=0.\n$$\n\nTask. Implement a conforming finite element method (FEM) with bilinear isoparametric quadrilateral elements on a uniform grid of $N_x \\times N_y$ elements to solve the above weak form with the traction field induced by the Airy stress function. Assemble the global stiffness matrix and the consistent Neumann load vector by performing Gaussian quadrature:\n- use $2 \\times 2$ Gauss integration for element stiffness,\n- use $2$-point Gauss integration along each boundary edge for traction loads.\n\nConstruct an exact displacement field $(u_x^\\star, u_y^\\star)$ by integrating the strain field obtained from the Airy-induced stress via the plane-stress compliance. Define\n$$\n\\sigma_{xx} = 6 a\\, x y + 2 d\\, x,\\quad\n\\sigma_{yy} = 6 b\\, x y + 2 c\\, y,\\quad\n\\tau_{xy} = -3 a\\, y^2 - 3 b\\, x^2 - 2 c\\, x - 2 d\\, y.\n$$\nThe engineering strains are\n$$\n\\varepsilon_{xx} = \\frac{1}{E}\\left(\\sigma_{xx} - \\nu \\sigma_{yy}\\right),\\quad\n\\varepsilon_{yy} = \\frac{1}{E}\\left(\\sigma_{yy} - \\nu \\sigma_{xx}\\right),\\quad\n\\gamma_{xy} = \\frac{2(1+\\nu)}{E}\\,\\tau_{xy}.\n$$\nIntegrate $\\partial u_x/\\partial x = \\varepsilon_{xx}$ and $\\partial u_y/\\partial y = \\varepsilon_{yy}$ and determine the missing functions of a single variable by enforcing $\\gamma_{xy} = \\partial u_x/\\partial y + \\partial u_y/\\partial x$. A particular polynomial solution (up to rigid body motions) is\n$$\nu_x^{\\text{base}}(x,y) = \\frac{1}{E}\\left( \\frac{6a-6\\nu b}{2}\\, x^2 y + d\\, x^2 - 2 \\nu c\\, x y \\right)\n-\\frac{1}{E}\\left( \\frac{(6+3\\nu)a + 3 b}{3}\\, y^3 + \\frac{4+2\\nu}{2}\\, d\\, y^2 \\right),\n$$\n$$\nu_y^{\\text{base}}(x,y) = \\frac{1}{E}\\left( \\frac{6b-6\\nu a}{2}\\, x y^2 + c\\, y^2 - 2 \\nu d\\, x y \\right)\n-\\frac{1}{E}\\left( \\frac{3 a + (6+3\\nu) b}{3}\\, x^3 + \\frac{4+2\\nu}{2}\\, c\\, x^2 \\right).\n$$\nTo satisfy the three essential constraints without altering the strain field, augment by a rigid rotation with scalar angle parameter $\\theta$:\n$$\nu_x^\\star(x,y) = u_x^{\\text{base}}(x,y) - \\theta\\, y, \\quad\nu_y^\\star(x,y) = u_y^{\\text{base}}(x,y) + \\theta\\, x.\n$$\nChoose $\\theta$ to enforce $u_y^\\star(L_x,0)=0$. Using $u_y^{\\text{base}}(x,0) = -\\frac{1}{E}\\left( \\frac{3 a + (6+3\\nu) b}{3}\\, x^3 + \\frac{4+2\\nu}{2}\\, c\\, x^2 \\right)$, one gets\n$$\n\\theta = -\\frac{u_y^{\\text{base}}(L_x,0)}{L_x}\n= \\frac{1}{E}\\left[\\left(a+(2+\\nu)b\\right)L_x^2 + (2+\\nu)\\, c\\, L_x \\right].\n$$\n\nNumerical verification. Compare the FEM solution $\\mathbf{u}_h$ to the exact $\\mathbf{u}^\\star$ at the mesh nodes using a discrete $L^2$-like norm with vertex-patch weights. For each node $i$, define a weight $w_i$ as the sum of one quarter of the area of each adjacent element. Compute the relative error\n$$\n\\eta = \\frac{\\left(\\sum_i w_i \\left[ (u_{x,h}(\\mathbf{x}_i) - u_x^\\star(\\mathbf{x}_i))^2 + (u_{y,h}(\\mathbf{x}_i) - u_y^\\star(\\mathbf{x}_i))^2 \\right]\\right)^{1/2}}{\\left(\\sum_i w_i \\left[ (u_x^\\star(\\mathbf{x}_i))^2 + (u_y^\\star(\\mathbf{x}_i))^2 \\right]\\right)^{1/2}},\n$$\nand define $\\eta = 0$ if the denominator is zero.\n\nTest suite. Your program must evaluate the following three cases and output the relative error $\\eta$ for each:\n\n- Case $1$ (nontrivial, moderate $\\nu$):\n  - $L_x=1.0$, $L_y=0.8$, $N_x=10$, $N_y=8$, $E=1000.0$, $\\nu=0.3$,\n  - $a=0.7$, $b=-0.4$, $c=0.5$, $d=-0.2$.\n\n- Case $2$ (trivial, zero traction edge case):\n  - $L_x=1.0$, $L_y=1.0$, $N_x=4$, $N_y=4$, $E=500.0$, $\\nu=0.25$,\n  - $a=0.0$, $b=0.0$, $c=0.0$, $d=0.0$.\n\n- Case $3$ (near-incompressible in plane stress):\n  - $L_x=2.0$, $L_y=1.0$, $N_x=16$, $N_y=8$, $E=2000.0$, $\\nu=0.49$,\n  - $a=0.2$, $b=0.3$, $c=-0.1$, $d=0.15$.\n\nFinal output format. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3]\"), where each item is the relative error $\\eta$ (a floating-point number) for the corresponding test case in the order listed above. No other output is permitted. All quantities are non-dimensional; no physical units are required.", "solution": "The solution is implemented using a standard Finite Element Method (FEM) procedure for bilinear quadrilateral elements on a uniform rectangular mesh. The key steps are:\n\n1.  **Mesh Generation**: A uniform grid of $N_x \\times N_y$ elements is created, defining node coordinates and element connectivity.\n2.  **Element-Level Calculations and Assembly**: For each bilinear quadrilateral element, the $8 \\times 8$ element stiffness matrix $k^e$ is computed by numerically integrating $\\int_{\\Omega_e} B^T D B \\, d\\Omega$ using $2 \\times 2$ Gaussian quadrature. These element matrices are then assembled into the global stiffness matrix $K$.\n3.  **Load Vector Calculation**: The global force vector $F$ is assembled by integrating the prescribed traction vector over the domain boundary. For each of the four boundary edges, the traction integral is computed using a $2$-point Gauss-Legendre quadrature rule.\n4.  **Application of Boundary Conditions**: The global system $K\\mathbf{d} = F$ is singular due to the pure Neumann conditions. The essential constraints $u_x(0,0)=0$, $u_y(0,0)=0$, and $u_y(L_x,0)=0$ are enforced by modifying the matrix $K$ and vector $F$ to make the system non-singular and yield a unique solution.\n5.  **Solution and Error Computation**: The modified linear system is solved for the nodal displacement vector $\\mathbf{d}$. The numerical solution $\\mathbf{u}_h$ is then compared against the exact analytical solution $\\mathbf{u}^\\star$ at each node, and the relative error $\\eta$ is computed using the specified discrete weighted $L^2$ norm.\n\nThis procedure is systematically applied to each of the three test cases.", "answer": "```python\nimport numpy as np\nfrom scipy import linalg\n\ndef solve():\n    \"\"\"\n    Main solver function that runs the test suite and prints the results.\n    \"\"\"\n\n    def solve_case(Lx, Ly, Nx, Ny, E, nu, a, b, c, d):\n        \"\"\"\n        Solves a single instance of the 2D elastostatics problem using FEM.\n        \"\"\"\n        # 1. MESH GENERATION\n        hx = Lx / Nx\n        hy = Ly / Ny\n        n_nodes_x = Nx + 1\n        n_nodes_y = Ny + 1\n        num_nodes = n_nodes_x * n_nodes_y\n        num_elements = Nx * Ny\n        num_dofs = 2 * num_nodes\n\n        nodes = np.zeros((num_nodes, 2))\n        for j in range(n_nodes_y):\n            for i in range(n_nodes_x):\n                node_idx = j * n_nodes_x + i\n                nodes[node_idx, 0] = i * hx\n                nodes[node_idx, 1] = j * hy\n\n        elements = np.zeros((num_elements, 4), dtype=int)\n        for j in range(Ny):\n            for i in range(Nx):\n                el_idx = j * Nx + i\n                n1 = j * n_nodes_x + i\n                n2 = j * n_nodes_x + i + 1\n                n3 = (j + 1) * n_nodes_x + i + 1\n                n4 = (j + 1) * n_nodes_x + i\n                elements[el_idx] = [n1, n2, n3, n4]\n\n        # 2. ELEMENT-LEVEL CALCULATIONS & ASSEMBLY\n        D = (E / (1 - nu**2)) * np.array([\n            [1, nu, 0],\n            [nu, 1, 0],\n            [0, 0, (1 - nu) / 2]\n        ])\n\n        gp_loc = 1.0 / np.sqrt(3.0)\n        gauss_points_1d = np.array([-gp_loc, gp_loc])\n        gauss_weights_1d = np.array([1.0, 1.0])\n        \n        K = np.zeros((num_dofs, num_dofs))\n\n        detJ = hx * hy / 4.0\n\n        for el_idx in range(num_elements):\n            k_e = np.zeros((8, 8))\n            for i_gp, xi in enumerate(gauss_points_1d):\n                w_xi = gauss_weights_1d[i_gp]\n                for j_gp, eta in enumerate(gauss_points_1d):\n                    w_eta = gauss_weights_1d[j_gp]\n                    \n                    dNdxi = 0.25 * np.array([-(1 - eta), (1 - eta), (1 + eta), -(1 + eta)])\n                    dNdeta = 0.25 * np.array([-(1 - xi), -(1 + xi), (1 + xi), (1 - xi)])\n                    \n                    dNdx = dNdxi * (2.0 / hx)\n                    dNdy = dNdeta * (2.0 / hy)\n                    \n                    B = np.zeros((3, 8))\n                    for i in range(4):\n                        B[0, 2*i] = dNdx[i]\n                        B[1, 2*i+1] = dNdy[i]\n                        B[2, 2*i] = dNdy[i]\n                        B[2, 2*i+1] = dNdx[i]\n                    \n                    k_e += B.T @ D @ B * w_xi * w_eta * detJ\n            \n            node_indices = elements[el_idx]\n            dof_indices = [idx for i in node_indices for idx in (2*i, 2*i+1)]\n            K[np.ix_(dof_indices, dof_indices)] += k_e\n\n        # 3. LOAD VECTOR CALCULATION\n        F = np.zeros(num_dofs)\n\n        def get_stress(x, y):\n            s_xx = 6 * a * x * y + 2 * d * x\n            s_yy = 6 * b * x * y + 2 * c * y\n            s_xy = -3 * a * y**2 - 3 * b * x**2 - 2 * c * x - 2 * d * y\n            return s_xx, s_yy, s_xy\n\n        # Boundary loop (bottom, right, top, left)\n        boundary_edges = []\n        for i in range(Nx): boundary_edges.append(((i, 0), (i + 1, 0))) # Bottom\n        for j in range(Ny): boundary_edges.append(((Nx, j), (Nx, j + 1))) # Right\n        for i in range(Nx): boundary_edges.append(((Nx - i, Ny), (Nx - i - 1, Ny))) # Top\n        for j in range(Ny): boundary_edges.append(((0, Ny - j), (0, Ny - j - 1))) # Left\n\n        normals = [np.array([0, -1]), np.array([1, 0]), np.array([0, 1]), np.array([-1, 0])]\n\n        edge_idx_offset = 0\n        for side_idx in range(4):\n            normal = normals[side_idx]\n            num_side_elements = Nx if side_idx % 2 == 0 else Ny\n            \n            for i in range(num_side_elements):\n                n_start_idx = edge_idx_offset + i\n                start_node_coords, end_node_coords = boundary_edges[n_start_idx]\n                \n                n1 = start_node_coords[1] * n_nodes_x + start_node_coords[0]\n                n2 = end_node_coords[1] * n_nodes_x + end_node_coords[0]\n\n                edge_vec = nodes[n2] - nodes[n1]\n                edge_len = np.linalg.norm(edge_vec)\n                detJ_1d = edge_len / 2.0\n                \n                f_e = np.zeros(4)\n                for i_gp, s in enumerate(gauss_points_1d):\n                    w = gauss_weights_1d[i_gp]\n                    gp_coord = (nodes[n1] + nodes[n2]) / 2.0 + s * detJ_1d * (edge_vec / edge_len)\n                    \n                    s_xx, s_yy, s_xy = get_stress(gp_coord[0], gp_coord[1])\n                    sigma = np.array([[s_xx, s_xy], [s_xy, s_yy]])\n                    t = sigma @ normal\n                    \n                    N_1d = np.array([(1-s)/2.0, (1+s)/2.0])\n                    f_e[0] += N_1d[0] * t[0] * w * detJ_1d\n                    f_e[1] += N_1d[0] * t[1] * w * detJ_1d\n                    f_e[2] += N_1d[1] * t[0] * w * detJ_1d\n                    f_e[3] += N_1d[1] * t[1] * w * detJ_1d\n\n                dofs = [2*n1, 2*n1+1, 2*n2, 2*n2+1]\n                F[dofs] += f_e\n            edge_idx_offset += num_side_elements\n\n        # 4. APPLY BOUNDARY CONDITIONS\n        bc_dofs = [0, 1, 2 * Nx + 1]\n        for dof in bc_dofs:\n            K[dof, :] = 0\n            K[:, dof] = 0\n            K[dof, dof] = 1.0\n            F[dof] = 0.0\n        \n        # 5. SOLVE LINEAR SYSTEM\n        u_h_vec = linalg.solve(K, F)\n        u_h = u_h_vec.reshape((num_nodes, 2))\n        \n        # 6. ERROR COMPUTATION\n        def u_base_x(x, y):\n            term1 = (1/E) * ( (3*a - 3*nu*b) * x**2 * y + d*x**2 - 2*nu*c*x*y )\n            term2 = (1/E) * ( ((2+nu)*a + b) * y**3 + (2+nu)*d*y**2 )\n            return term1 - term2\n        \n        def u_base_y(x, y):\n            term1 = (1/E) * ( (3*b - 3*nu*a) * x*y**2 + c*y**2 - 2*nu*d*x*y )\n            term2 = (1/E) * ( (a + (2+nu)*b) * x**3 + (2+nu)*c*x**2 )\n            return term1 - term2\n\n        theta = (1/E) * ( (a + (2+nu)*b)*Lx**2 + (2+nu)*c*Lx )\n\n        def u_star_x(x, y): return u_base_x(x, y) - theta * y\n        def u_star_y(x, y): return u_base_y(x, y) + theta * x\n\n        u_exact = np.array([[u_star_x(x, y), u_star_y(x, y)] for x, y in nodes])\n            \n        weights = np.zeros(num_nodes)\n        el_area = hx * hy\n        for el_idx in range(num_elements):\n            weights[elements[el_idx]] += el_area / 4.0\n\n        err_num_sq = np.sum(weights * np.sum((u_h - u_exact)**2, axis=1))\n        norm_den_sq = np.sum(weights * np.sum(u_exact**2, axis=1))\n\n        if norm_den_sq < 1e-25: return 0.0\n        \n        return np.sqrt(err_num_sq / norm_den_sq)\n\n    test_cases = [\n        {'Lx': 1.0, 'Ly': 0.8, 'Nx': 10, 'Ny': 8, 'E': 1000.0, 'nu': 0.3,\n         'a': 0.7, 'b': -0.4, 'c': 0.5, 'd': -0.2},\n        {'Lx': 1.0, 'Ly': 1.0, 'Nx': 4, 'Ny': 4, 'E': 500.0, 'nu': 0.25,\n         'a': 0.0, 'b': 0.0, 'c': 0.0, 'd': 0.0},\n        {'Lx': 2.0, 'Ly': 1.0, 'Nx': 16, 'Ny': 8, 'E': 2000.0, 'nu': 0.49,\n         'a': 0.2, 'b': 0.3, 'c': -0.1, 'd': 0.15},\n    ]\n\n    results = [solve_case(**case) for case in test_cases]\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2556099"}]}