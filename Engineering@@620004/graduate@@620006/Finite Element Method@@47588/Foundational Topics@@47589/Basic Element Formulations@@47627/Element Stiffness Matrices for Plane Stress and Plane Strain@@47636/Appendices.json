{"hands_on_practices": [{"introduction": "The foundation of many powerful finite elements is the isoparametric mapping, which transforms a simple \"parent\" element into a more complex shape in the physical domain. The integrity of this mapping is governed by the Jacobian matrix, $\\mathbf{J}$. This hands-on calculation challenges you to compute the determinant of the Jacobian, $\\det \\mathbf{J}$, at the Gauss integration points for a specific quadrilateral element. Evaluating the sign of $\\det \\mathbf{J}$ is a critical step in any finite element analysis, as it directly tells us whether the element is geometrically valid or \"inverted,\" a condition that renders the element unusable [@problem_id:2554541].", "problem": "In the context of computing the element stiffness matrix for a two-dimensional linear elastic analysis under plane stress or plane strain within the Finite Element Method (FEM), consider a $4$-node isoparametric quadrilateral element with the standard natural (parent) coordinates assigned to nodes as follows: node $1 \\equiv (\\xi,\\eta)=(-1,-1)$, node $2 \\equiv (1,-1)$, node $3 \\equiv (1,1)$, node $4 \\equiv (-1,1)$. The corresponding physical coordinates of the elementâ€™s nodes (in meters) are:\n- node $1$: $(x_{1},y_{1})=(0,-1)$,\n- node $2$: $(x_{2},y_{2})=(3.5,-1)$,\n- node $3$: $(x_{3},y_{3})=(-1.5,1)$,\n- node $4$: $(x_{4},y_{4})=(0,1)$.\n\nStarting only from the definitions of the bilinear isoparametric mapping $x(\\xi,\\eta)=\\sum_{i=1}^{4}N_{i}(\\xi,\\eta)\\,x_{i}$, $y(\\xi,\\eta)=\\sum_{i=1}^{4}N_{i}(\\xi,\\eta)\\,y_{i}$ with the standard bilinear shape functions $N_{i}(\\xi,\\eta)$, and the Jacobian matrix $J(\\xi,\\eta)=\\begin{bmatrix}\\partial x/\\partial \\xi & \\partial x/\\partial \\eta \\\\ \\partial y/\\partial \\xi & \\partial y/\\partial \\eta \\end{bmatrix}$ whose determinant is $\\det J(\\xi,\\eta)$, do the following:\n\n- Derive $\\det J$ at each of the standard $2\\times 2$ Gauss points $(\\xi,\\eta)\\in\\{(\\pm 1/\\sqrt{3},\\pm 1/\\sqrt{3})\\}$.\n- Use these values to assess whether the element is inverted (i.e., whether there exists at least one Gauss point where $\\det J<0$).\n- Report, as your final numerical result, the minimum value of $\\det J$ among the four Gauss points.\n\nRound your final reported minimum determinant to four significant figures and express it in square meters. Provide only that single real number as your final answer.", "solution": "The problem statement has been subjected to rigorous validation and is deemed valid. It is scientifically grounded in the principles of continuum mechanics and the finite element method, is well-posed with all necessary information provided, and is expressed with objective, precise language. We may therefore proceed with the solution.\n\nThe problem requires the calculation of the determinant of the Jacobian matrix, $\\det J$, for a given $4$-node isoparametric quadrilateral element at four specific Gauss quadrature points. The mapping from the parent element coordinates $(\\xi, \\eta)$ to the physical coordinates $(x, y)$ is given by the isoparametric formulation:\n$$\nx(\\xi,\\eta)=\\sum_{i=1}^{4}N_{i}(\\xi,\\eta)\\,x_{i}\n$$\n$$\ny(\\xi,\\eta)=\\sum_{i=1}^{4}N_{i}(\\xi,\\eta)\\,y_{i}\n$$\nwhere $(x_i, y_i)$ are the physical coordinates of node $i$, and $N_i(\\xi, \\eta)$ are the bilinear shape functions. For the standard $4$-node quadrilateral, these are:\n$$\nN_{1}(\\xi,\\eta) = \\frac{1}{4}(1-\\xi)(1-\\eta)\n$$\n$$\nN_{2}(\\xi,\\eta) = \\frac{1}{4}(1+\\xi)(1-\\eta)\n$$\n$$\nN_{3}(\\xi,\\eta) = \\frac{1}{4}(1+\\xi)(1+\\eta)\n$$\n$$\nN_{4}(\\xi,\\eta) = \\frac{1}{4}(1-\\xi)(1+\\eta)\n$$\nThe Jacobian matrix $J$ relates the derivatives in the physical coordinate system to those in the parent coordinate system:\n$$\n\\begin{pmatrix} \\partial/\\partial \\xi \\\\ \\partial/\\partial \\eta \\end{pmatrix} = \\begin{bmatrix} \\partial x / \\partial \\xi & \\partial y / \\partial \\xi \\\\ \\partial x / \\partial \\eta & \\partial y / \\partial \\eta \\end{bmatrix} \\begin{pmatrix} \\partial/\\partial x \\\\ \\partial/\\partial y \\end{pmatrix}\n$$\nThe problem defines $J$ as the transpose of the matrix shown above, which is a common convention in some literature. We will adhere strictly to the problem's definition:\n$$\nJ(\\xi,\\eta)=\\begin{bmatrix} \\partial x/\\partial \\xi & \\partial x/\\partial \\eta \\\\ \\partial y/\\partial \\xi & \\partial y/\\partial \\eta \\end{bmatrix}\n$$\nThe components of $J$ are found by differentiating the mapping equations:\n$$\n\\frac{\\partial x}{\\partial \\xi} = \\sum_{i=1}^{4}\\frac{\\partial N_{i}}{\\partial \\xi}x_{i}, \\quad \\frac{\\partial x}{\\partial \\eta} = \\sum_{i=1}^{4}\\frac{\\partial N_{i}}{\\partial \\eta}x_{i}\n$$\n$$\n\\frac{\\partial y}{\\partial \\xi} = \\sum_{i=1}^{4}\\frac{\\partial N_{i}}{\\partial \\xi}y_{i}, \\quad \\frac{\\partial y}{\\partial \\eta} = \\sum_{i=1}^{4}\\frac{\\partial N_{i}}{\\partial \\eta}y_{i}\n$$\nThe partial derivatives of the shape functions are:\n$$\n\\frac{\\partial N_{1}}{\\partial \\xi} = -\\frac{1}{4}(1-\\eta), \\quad \\frac{\\partial N_{2}}{\\partial \\xi} = \\frac{1}{4}(1-\\eta), \\quad \\frac{\\partial N_{3}}{\\partial \\xi} = \\frac{1}{4}(1+\\eta), \\quad \\frac{\\partial N_{4}}{\\partial \\xi} = -\\frac{1}{4}(1+\\eta)\n$$\n$$\n\\frac{\\partial N_{1}}{\\partial \\eta} = -\\frac{1}{4}(1-\\xi), \\quad \\frac{\\partial N_{2}}{\\partial \\eta} = -\\frac{1}{4}(1+\\xi), \\quad \\frac{\\partial N_{3}}{\\partial \\eta} = \\frac{1}{4}(1+\\xi), \\quad \\frac{\\partial N_{4}}{\\partial \\eta} = \\frac{1}{4}(1-\\xi)\n$$\nThe nodal coordinates are given as: $(x_1, y_1)=(0, -1)$, $(x_2, y_2)=(3.5, -1)$, $(x_3, y_3)=(-1.5, 1)$, and $(x_4, y_4)=(0, 1)$. We substitute these values into the expressions for the Jacobian components.\n\nFor $J_{11} = \\partial x/\\partial \\xi$:\n$$\n\\frac{\\partial x}{\\partial \\xi} = \\frac{1}{4}[-x_1(1-\\eta) + x_2(1-\\eta) + x_3(1+\\eta) - x_4(1+\\eta)]\n$$\n$$\n\\frac{\\partial x}{\\partial \\xi} = \\frac{1}{4}[-(0)(1-\\eta) + (3.5)(1-\\eta) + (-1.5)(1+\\eta) - (0)(1+\\eta)] = \\frac{1}{4}[3.5 - 3.5\\eta - 1.5 - 1.5\\eta] = \\frac{1}{4}(2 - 5\\eta)\n$$\nFor $J_{12} = \\partial x/\\partial \\eta$:\n$$\n\\frac{\\partial x}{\\partial \\eta} = \\frac{1}{4}[-x_1(1-\\xi) - x_2(1+\\xi) + x_3(1+\\xi) + x_4(1-\\xi)]\n$$\n$$\n\\frac{\\partial x}{\\partial \\eta} = \\frac{1}{4}[-(0)(1-\\xi) - (3.5)(1+\\xi) + (-1.5)(1+\\xi) + (0)(1-\\xi)] = \\frac{1}{4}[-3.5 - 3.5\\xi - 1.5 - 1.5\\xi] = \\frac{1}{4}(-5 - 5\\xi) = -\\frac{5}{4}(1+\\xi)\n$$\nFor $J_{21} = \\partial y/\\partial \\xi$:\n$$\n\\frac{\\partial y}{\\partial \\xi} = \\frac{1}{4}[-y_1(1-\\eta) + y_2(1-\\eta) + y_3(1+\\eta) - y_4(1+\\eta)]\n$$\n$$\n\\frac{\\partial y}{\\partial \\xi} = \\frac{1}{4}[-(-1)(1-\\eta) + (-1)(1-\\eta) + (1)(1+\\eta) - (1)(1+\\eta)] = \\frac{1}{4}[ (1-\\eta) - (1-\\eta) + (1+\\eta) - (1+\\eta) ] = 0\n$$\nFor $J_{22} = \\partial y/\\partial \\eta$:\n$$\n\\frac{\\partial y}{\\partial \\eta} = \\frac{1}{4}[-y_1(1-\\xi) - y_2(1+\\xi) + y_3(1+\\xi) + y_4(1-\\xi)]\n$$\n$$\n\\frac{\\partial y}{\\partial \\eta} = \\frac{1}{4}[-(-1)(1-\\xi) - (-1)(1+\\xi) + (1)(1+\\xi) + (1)(1-\\xi)] = \\frac{1}{4}[1-\\xi + 1+\\xi + 1+\\xi + 1-\\xi] = \\frac{4}{4} = 1\n$$\nThe Jacobian matrix is therefore:\n$$\nJ(\\xi,\\eta) = \\begin{bmatrix} \\frac{1}{4}(2 - 5\\eta) & -\\frac{5}{4}(1+\\xi) \\\\ 0 & 1 \\end{bmatrix}\n$$\nThe determinant of the Jacobian is:\n$$\n\\det J(\\xi,\\eta) = \\left(\\frac{1}{4}(2 - 5\\eta)\\right)(1) - \\left(-\\frac{5}{4}(1+\\xi)\\right)(0) = \\frac{1}{4}(2 - 5\\eta)\n$$\nWe must evaluate $\\det J$ at the four standard $2 \\times 2$ Gauss points, which are $(\\xi_i, \\eta_j)$ where $\\xi_i, \\eta_j \\in \\{-1/\\sqrt{3}, 1/\\sqrt{3}\\}$. Let $a = 1/\\sqrt{3}$. The four points are $(-a, -a)$, $(a, -a)$, $(a, a)$, and $(-a, a)$. Notice that $\\det J$ depends only on $\\eta$.\n\n1. For the two Gauss points with $\\eta = -1/\\sqrt{3}$:\n   $$\n   \\det J = \\frac{1}{4}\\left(2 - 5\\left(-\\frac{1}{\\sqrt{3}}\\right)\\right) = \\frac{1}{4}\\left(2 + \\frac{5}{\\sqrt{3}}\\right)\n   $$\n   Numerically, $\\det J = \\frac{1}{4}(2 + 2.88675...) = \\frac{4.88675...}{4} = 1.22168...\n   $$\n\n2. For the two Gauss points with $\\eta = 1/\\sqrt{3}$:\n   $$\n   \\det J = \\frac{1}{4}\\left(2 - 5\\left(\\frac{1}{\\sqrt{3}}\\right)\\right) = \\frac{1}{4}\\left(2 - \\frac{5}{\\sqrt{3}}\\right)\n   $$\n   Numerically, $\\det J = \\frac{1}{4}(2 - 2.88675...) = \\frac{-0.88675...}{4} = -0.22168...\n   $$\n\nThe four values of the determinant at the Gauss points are $\\{1.22168..., 1.22168..., -0.22168..., -0.22168...\\}$.\nThe existence of at least one Gauss point where $\\det J < 0$ indicates that the element mapping is inverted. In this case, two of the four Gauss points exhibit a negative Jacobian determinant. Such an element is geometrically invalid and would cause failure in a finite element analysis.\n\nThe minimum value of $\\det J$ among the four Gauss points is the negative value.\n$$\n\\min(\\det J) = -0.22168...\n$$\nThe problem specifies that the nodal coordinates are in meters, therefore the determinant of the Jacobian has units of square meters. The final result must be rounded to four significant figures.\n$$\n\\min(\\det J) \\approx -0.2217\n$$", "answer": "$$ \\boxed{-0.2217} $$", "id": "2554541"}, {"introduction": "Once an element's geometric validity is confirmed, the next step is to assemble its stiffness matrix, $\\mathbf{K}_e$, which encodes the element's resistance to deformation. The properties of this matrix are paramount for a stable and reliable analysis. This coding exercise guides you through the process of implementing the stiffness matrix for both Constant-Strain Triangle (CST) and Four-Node Quadrilateral (Q4) elements, and then performing an eigenanalysis to investigate their fundamental properties [@problem_id:2554569]. By counting the zero-energy modes, you will learn to distinguish the three necessary rigid-body modes from spurious \"hourglass\" mechanisms that can arise from numerical shortcuts like reduced integration.", "problem": "Construct a program that, starting from the principle of virtual work and the definition of isoparametric interpolation, assembles element stiffness matrices and performs an eigenanalysis to identify rigid body modes and any spurious zero-energy mechanisms in two-dimensional elasticity. Specifically, consider the Constant-Strain Triangle (CST) and the Four-Node Quadrilateral (Q4) elements under both plane stress and plane strain assumptions. Starting from the fundamental identity that the element stiffness matrix is given by the bilinear form\n$$\n\\mathbf{K}_e \\;=\\; \\int_{\\Omega_e} \\mathbf{B}^\\mathsf{T} \\, \\mathbf{D} \\, \\mathbf{B} \\; t \\; \\mathrm{d}\\Omega,\n$$\nwhere $t$ is the thickness, $\\mathbf{D}$ is the isotropic elasticity matrix corresponding to either plane stress or plane strain, and $\\mathbf{B}$ is the strain-displacement matrix obtained from the spatial derivatives of the interpolation functions, implement:\n- For the Constant-Strain Triangle (CST): a constant $\\mathbf{B}$ over the element domain with exact area integration.\n- For the Four-Node Quadrilateral (Q4): isoparametric bilinear interpolation with numerical quadrature. Use a $2 \\times 2$ Gauss rule for full integration and a $1 \\times 1$ Gauss rule (single central point) for reduced integration.\n\nPerform an eigenanalysis of each element stiffness matrix $\\mathbf{K}_e$ and count the number of eigenvalues that are numerically zero, interpreted as the number of zero-energy modes. The expectation based on mechanics is that there should be exactly three rigid body modes in two spatial dimensions (two translations and one in-plane rotation). Any additional numerically zero eigenvalues indicate spurious mechanisms.\n\nYour program must implement the isotropic elasticity matrix $\\mathbf{D}$ for plane stress and plane strain using standard linear elasticity:\n- Plane stress:\n$$\n\\mathbf{D}_{\\text{ps}} \\;=\\; \\frac{E}{1-\\nu^2}\\begin{bmatrix}\n1 & \\nu & 0\\\\\n\\nu & 1 & 0\\\\\n0 & 0 & \\frac{1-\\nu}{2}\n\\end{bmatrix},\n$$\n- Plane strain:\n$$\n\\mathbf{D}_{\\text{pe}} \\;=\\; \\frac{E}{(1+\\nu)(1-2\\nu)}\\begin{bmatrix}\n1-\\nu & \\nu & 0\\\\\n\\nu & 1-\\nu & 0\\\\\n0 & 0 & \\frac{1-2\\nu}{2}\n\\end{bmatrix}.\n$$\n\nFor the Q4 element, use the standard bilinear isoparametric shape functions on the parent domain with local coordinates $(\\xi,\\eta)\\in[-1,1]\\times[-1,1]$, compute the Jacobian $\\mathbf{J}$ and its determinant at the quadrature points, and transform derivatives to physical coordinates via $\\mathbf{J}^{-1}$. For full integration, use four Gauss points at $(\\pm 1/\\sqrt{3}, \\pm 1/\\sqrt{3})$ each with weight $1$, and for reduced integration, use the single point $(0,0)$ with total weight $4$.\n\nNumerically detect the number of zero eigenvalues by comparing the absolute value of each eigenvalue to a tolerance proportional to the largest eigenvalue magnitude for that case. Use a relative tolerance of $10^{-8}$ on the spectral radius with a small absolute floor so that the final count is an integer.\n\nTest suite. Your program must run the following five test cases and return the number of near-zero eigenvalues for each, in order:\n\n1. CST, plane stress. Nodes at $(x_1,y_1)=(0,0)$, $(x_2,y_2)=(1,0)$, $(x_3,y_3)=(0,1)$, with thickness $t=0.05\\,\\mathrm{m}$, Youngâ€™s modulus $E=210\\times 10^9\\,\\mathrm{Pa}$, Poissonâ€™s ratio $\\nu=0.29$.\n\n2. Q4, plane stress, full integration. Nodes at $(x_1,y_1)=(0,0)$, $(x_2,y_2)=(1,0)$, $(x_3,y_3)=(1,1)$, $(x_4,y_4)=(0,1)$, with thickness $t=0.05\\,\\mathrm{m}$, Youngâ€™s modulus $E=210\\times 10^9\\,\\mathrm{Pa}$, Poissonâ€™s ratio $\\nu=0.29$.\n\n3. Q4, plane stress, reduced integration. Same geometry and material as Case $2$, but use $1\\times 1$ Gauss rule at $(\\xi,\\eta)=(0,0)$.\n\n4. Q4, plane stress, reduced integration on a distorted element. Nodes at $(x_1,y_1)=(0,0)$, $(x_2,y_2)=(2,0.2)$, $(x_3,y_3)=(2.2,1.8)$, $(x_4,y_4)=(0,1)$, with thickness $t=0.1\\,\\mathrm{m}$, Youngâ€™s modulus $E=70\\times 10^9\\,\\mathrm{Pa}$, Poissonâ€™s ratio $\\nu=0.25$.\n\n5. Q4, plane strain, full integration. Nodes at $(x_1,y_1)=(0,0)$, $(x_2,y_2)=(2,0)$, $(x_3,y_3)=(2,1)$, $(x_4,y_4)=(0,1)$, with thickness $t=0.1\\,\\mathrm{m}$, Youngâ€™s modulus $E=1\\times 10^6\\,\\mathrm{Pa}$, Poissonâ€™s ratio $\\nu=0.49$.\n\nFor each case, compute the integer count of near-zero eigenvalues of the element stiffness matrix. The final output of your program must be a single line containing a Python-style list of the five integers in the same order as the test suite cases, with no units (integers are unitless). Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[3,3,5,5,3]$).", "solution": "The problem is well-posed and grounded in the established principles of computational solid mechanics. It requires the implementation and analysis of fundamental element types in the finite element method. We shall proceed with the derivation and solution.\n\nThe foundation for the element stiffness matrix $\\mathbf{K}_e$ is the principle of virtual work, which equates the internal virtual work to the external virtual work. For a linear elastic continuum, this leads to the expression for the potential energy, whose stationarity yields the equilibrium equations. The element stiffness matrix is derived from the strain energy term, given by the volume integral of the strain energy density. For an element $\\Omega_e$ with uniform thickness $t$, this is:\n$$\n\\mathbf{K}_e = \\int_{\\Omega_e} \\mathbf{B}^\\mathsf{T} \\mathbf{D} \\mathbf{B} \\, t \\, \\mathrm{d}\\Omega\n$$\nHere, $\\mathbf{B}$ is the strain-displacement matrix, which relates the vector of engineering strains $\\boldsymbol{\\epsilon} = [\\epsilon_x, \\epsilon_y, \\gamma_{xy}]^\\mathsf{T}$ to the vector of nodal displacements $\\mathbf{d}_e$. The matrix $\\mathbf{D}$ is the material constitutive matrix relating stresses $\\boldsymbol{\\sigma}$ to strains $\\boldsymbol{\\epsilon}$ via $\\boldsymbol{\\sigma} = \\mathbf{D}\\boldsymbol{\\epsilon}$.\n\nThe displacement field within an element is interpolated from the nodal displacements $\\mathbf{d}_e$ using shape functions $\\mathbf{N}$:\n$$\n\\mathbf{u}(x,y) = \\mathbf{N}(x,y) \\mathbf{d}_e\n$$\nThe strains are obtained by applying the kinematic differential operator $\\mathcal{L}$ to the displacement field:\n$$\n\\boldsymbol{\\epsilon} = \\mathcal{L} \\mathbf{u} = \\mathcal{L} (\\mathbf{N} \\mathbf{d}_e) = (\\mathcal{L} \\mathbf{N}) \\mathbf{d}_e\n$$\nFrom this, the strain-displacement matrix is identified as $\\mathbf{B} = \\mathcal{L}\\mathbf{N}$. For two-dimensional problems, the operator is:\n$$\n\\mathcal{L} = \\begin{bmatrix} \\frac{\\partial}{\\partial x} & 0 \\\\ 0 & \\frac{\\partial}{\\partial y} \\\\ \\frac{\\partial}{\\partial y} & \\frac{\\partial}{\\partial x} \\end{bmatrix}\n$$\n\nThe material behavior is described by the isotropic elasticity matrix $\\mathbf{D}$. For the two-dimensional states specified:\n-   Plane Stress ($\\sigma_z = 0$): Applicable to thin structures. The matrix is:\n    $$\n    \\mathbf{D}_{\\text{ps}} = \\frac{E}{1-\\nu^2}\\begin{bmatrix}\n    1 & \\nu & 0 \\\\\n    \\nu & 1 & 0 \\\\\n    0 & 0 & \\frac{1-\\nu}{2}\n    \\end{bmatrix}\n    $$\n-   Plane Strain ($\\epsilon_z = 0$): Applicable to thick structures where out-of-plane deformation is constrained. The matrix is:\n    $$\n    \\mathbf{D}_{\\text{pe}} = \\frac{E}{(1+\\nu)(1-2\\nu)}\\begin{bmatrix}\n    1-\\nu & \\nu & 0 \\\\\n    \\nu & 1-\\nu & 0 \\\\\n    0 & 0 & \\frac{1-2\\nu}{2}\n    \\end{bmatrix}\n    $$\nwhere $E$ is Young's modulus and $\\nu$ is Poisson's ratio.\n\nWe will now formulate the stiffness matrix for each element type.\n\n**Constant-Strain Triangle (CST) Element**\n\nThe CST is a $3$-node triangular element with $2$ degrees of freedom (DOF) per node, for a total of $6$ DOF. The displacement field is interpolated linearly:\n$$\nu(x,y) = N_1 u_1 + N_2 u_2 + N_3 u_3 \\quad \\text{and} \\quad v(x,y) = N_1 v_1 + N_2 v_2 + N_3 v_3\n$$\nThe linear shape functions $N_i(x,y)$ have constant first derivatives. Consequently, the strain components $\\epsilon_x = \\partial u/\\partial x$, $\\epsilon_y = \\partial v/\\partial y$, and $\\gamma_{xy} = \\partial u/\\partial y + \\partial v/\\partial x$ are constant throughout the element, which gives the element its name. The strain-displacement matrix $\\mathbf{B}$ is a constant $3 \\times 6$ matrix.\nFor a triangle with nodes $(x_1, y_1)$, $(x_2, y_2)$, and $(x_3, y_3)$ ordered counter-clockwise, the $\\mathbf{B}$ matrix is given by:\n$$\n\\mathbf{B} = \\frac{1}{2A} \\begin{bmatrix}\ny_2 - y_3 & 0 & y_3 - y_1 & 0 & y_1 - y_2 & 0 \\\\\n0 & x_3 - x_2 & 0 & x_1 - x_3 & 0 & x_2 - x_1 \\\\\nx_3 - x_2 & y_2 - y_3 & x_1 - x_3 & y_3 - y_1 & x_2 - x_1 & y_1 - y_2\n\\end{bmatrix}\n$$\nwhere $A$ is the area of the triangle. Since $\\mathbf{B}$, $\\mathbf{D}$, and $t$ are constant, the stiffness matrix integral simplifies to a direct product:\n$$\n\\mathbf{K}_e = \\mathbf{B}^\\mathsf{T} \\mathbf{D} \\mathbf{B} \\, (A \\cdot t)\n$$\n\n**Four-Node Quadrilateral (Q4) Element**\n\nThe Q$4$ element is a $4$-node element with $8$ total DOF. The formulation is isoparametric, meaning the same shape functions are used to interpolate both the geometry and the displacement field. We use a standard parent element domain defined by local coordinates $(\\xi, \\eta) \\in [-1, 1] \\times [-1, 1]$. The bilinear shape functions are:\n$$\nN_i(\\xi, \\eta) = \\frac{1}{4}(1 + \\xi_i \\xi)(1 + \\eta_i \\eta)\n$$\nwhere $(\\xi_i, \\eta_i)$ are the coordinates of node $i$ in the parent domain: $(-1,-1)$, $(1,-1)$, $(1,1)$, $(-1,1)$ for nodes $1, 2, 3, 4$.\n\nThe physical coordinates $(x,y)$ are mapped from the parent coordinates:\n$$\nx(\\xi, \\eta) = \\sum_{i=1}^{4} N_i(\\xi, \\eta) x_i \\quad \\text{and} \\quad y(\\xi, \\eta) = \\sum_{i=1}^{4} N_i(\\xi, \\eta) y_i\n$$\nThe strain-displacement matrix $\\mathbf{B}$ requires derivatives with respect to physical coordinates $(x,y)$, which are obtained from derivatives with respect to parent coordinates $(\\xi, \\eta)$ via the chain rule, involving the Jacobian matrix $\\mathbf{J}$:\n$$\n\\begin{Bmatrix} \\frac{\\partial}{\\partial x} \\\\ \\frac{\\partial}{\\partial y} \\end{Bmatrix} = \\mathbf{J}^{-1} \\begin{Bmatrix} \\frac{\\partial}{\\partial \\xi} \\\\ \\frac{\\partial}{\\partial \\eta} \\end{Bmatrix} \\quad \\text{where} \\quad \\mathbf{J} = \\begin{bmatrix} \\frac{\\partial x}{\\partial \\xi} & \\frac{\\partial y}{\\partial \\xi} \\\\ \\frac{\\partial x}{\\partial \\eta} & \\frac{\\partial y}{\\partial \\eta} \\end{bmatrix}\n$$\nThe $\\mathbf{B}$ matrix is now a function of $(\\xi, \\eta)$. The stiffness matrix integral is transformed to the parent domain:\n$$\n\\mathbf{K}_e = \\int_{-1}^{1} \\int_{-1}^{1} \\mathbf{B}(\\xi, \\eta)^\\mathsf{T} \\mathbf{D} \\mathbf{B}(\\xi, \\eta) \\, \\det(\\mathbf{J}) \\, t \\, \\mathrm{d}\\xi \\, \\mathrm{d}\\eta\n$$\nThis integral is evaluated numerically using Gauss quadrature:\n$$\n\\mathbf{K}_e \\approx t \\sum_{i=1}^{n_p} \\sum_{j=1}^{n_p} w_i w_j \\left( \\mathbf{B}(\\xi_i, \\eta_j)^\\mathsf{T} \\mathbf{D} \\mathbf{B}(\\xi_i, \\eta_j) \\det(\\mathbf{J}(\\xi_i, \\eta_j)) \\right)\n$$\nwhere $(\\xi_i, \\eta_j)$ are the Gauss points and $w_i, w_j$ are the corresponding weights.\n-   **Full Integration:** A $2 \\times 2$ rule ($n_p=2$) is used. The points are $(\\pm 1/\\sqrt{3}, \\pm 1/\\sqrt{3})$ and all weights are $1$. This rule can integrate polynomials up to degree $3$ exactly, which is sufficient to exactly integrate the stiffness matrix of a rectangular Q$4$ element.\n-   **Reduced Integration:** A $1 \\times 1$ rule ($n_p=1$) is used. The single point is at the center $(\\xi, \\eta) = (0,0)$ with weight $w_1 \\cdot w_1 = 4$. This method is computationally efficient but can introduce spurious zero-energy modes, known as hourglassing.\n\n**Eigenanalysis of the Stiffness Matrix**\n\nThe eigenvalues of $\\mathbf{K}_e$ represent the energetic cost of its corresponding eigenmodes (deformation shapes). A zero eigenvalue corresponds to a zero-energy mode, a deformation that produces no strain and thus no stress. For any unconstrained element in $2$D space, there must be exactly $3$ such modes: $2$ rigid body translations and $1$ in-plane rigid body rotation. These are physically correct.\n\nAny additional zero-energy modes are spurious, non-physical artifacts of the element formulation. They are known as \"hourglass modes\" and indicate that the element can deform in a pattern without storing any strain energy, rendering it unstable. The task is to perform an eigenanalysis on each computed $\\mathbf{K}_e$ and count the number of numerically zero eigenvalues. An eigenvalue $\\lambda$ is considered zero if its absolute value is smaller than a tolerance relative to the spectral radius (maximum absolute eigenvalue) $\\lambda_{\\text{max}}$:\n$$\n|\\lambda| < 10^{-8} \\cdot \\lambda_{\\text{max}}\n$$\nThis count reveals the number of rigid body modes plus any spurious mechanisms for each element configuration.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef get_D(E, nu, analysis_type):\n    \"\"\"\n    Computes the isotropic elasticity matrix D for plane stress or plane strain.\n    \"\"\"\n    if analysis_type == \"plane_stress\":\n        if abs(1.0 - nu**2) < 1e-12:\n            raise ValueError(\"Invalid Poisson's ratio for plane stress: 1 - nu^2 is zero.\")\n        factor = E / (1.0 - nu**2)\n        D = factor * np.array([\n            [1.0, nu, 0.0],\n            [nu, 1.0, 0.0],\n            [0.0, 0.0, (1.0 - nu) / 2.0]\n        ])\n    elif analysis_type == \"plane_strain\":\n        denom = (1.0 + nu) * (1.0 - 2.0 * nu)\n        if abs(denom) < 1e-12:\n            raise ValueError(\"Invalid Poisson's ratio for plane strain: (1+nu)(1-2*nu) is zero.\")\n        factor = E / denom\n        D = factor * np.array([\n            [1.0 - nu, nu, 0.0],\n            [nu, 1.0 - nu, 0.0],\n            [0.0, 0.0, (1.0 - 2.0 * nu) / 2.0]\n        ])\n    else:\n        raise ValueError(f\"Invalid analysis type: {analysis_type}\")\n    return D\n\ndef stiffness_cst(nodes, t, E, nu, analysis_type):\n    \"\"\"\n    Computes the stiffness matrix for a Constant Strain Triangle (CST) element.\n    \"\"\"\n    # Nodal coordinates\n    x1, y1 = nodes[0]\n    x2, y2 = nodes[1]\n    x3, y3 = nodes[2]\n\n    # Area of the triangle\n    A = 0.5 * np.linalg.det(np.array([[1.0, x1, y1], [1.0, x2, y2], [1.0, x3, y3]]))\n    if A <= 1e-12:\n        raise ValueError(\"Degenerate or inverted triangle element.\")\n\n    # Components for the constant B matrix\n    b1 = y2 - y3\n    b2 = y3 - y1\n    b3 = y1 - y2\n    c1 = x3 - x2\n    c2 = x1 - x3\n    c3 = x2 - x1\n\n    # B matrix (strain-displacement matrix)\n    B = (1.0 / (2.0 * A)) * np.array([\n        [b1, 0.0, b2, 0.0, b3, 0.0],\n        [0.0, c1, 0.0, c2, 0.0, c3],\n        [c1, b1, c2, b2, c3, b3]\n    ])\n\n    D = get_D(E, nu, analysis_type)\n    \n    Ke = B.T @ D @ B * A * t\n    return Ke\n\ndef stiffness_q4(nodes, t, E, nu, analysis_type, integration_rule):\n    \"\"\"\n    Computes the stiffness matrix for a 4-node quadrilateral (Q4) element.\n    \"\"\"\n    D = get_D(E, nu, analysis_type)\n\n    if integration_rule == \"full\":  # 2x2\n        gauss_points_1d = [-1.0/np.sqrt(3.0), 1.0/np.sqrt(3.0)]\n        gauss_weights_1d = [1.0, 1.0]\n    elif integration_rule == \"reduced\":  # 1x1\n        gauss_points_1d = [0.0]\n        gauss_weights_1d = [2.0]\n    else:\n        raise ValueError(f\"Invalid integration rule: {integration_rule}\")\n\n    Ke = np.zeros((8, 8))\n\n    for xi in gauss_points_1d:\n        for eta in gauss_points_1d:\n            weight = gauss_weights_1d[gauss_points_1d.index(xi)] * \\\n                     gauss_weights_1d[gauss_points_1d.index(eta)]\n\n            # Derivatives of shape functions w.r.t. parent coordinates (xi, eta)\n            # N_derivs_parent[0, i] = dN_i/d_xi, N_derivs_parent[1, i] = dN_i/d_eta\n            N_derivs_parent = 0.25 * np.array([\n                [-(1.0 - eta), (1.0 - eta), (1.0 + eta), -(1.0 + eta)],\n                [-(1.0 - xi), -(1.0 + xi), (1.0 + xi), (1.0 - xi)]\n            ])\n\n            # Jacobian matrix\n            J = N_derivs_parent @ nodes\n            detJ = np.linalg.det(J)\n            if detJ <= 1e-12:\n                raise ValueError(\"Jacobian determinant is non-positive. Check element geometry or node ordering.\")\n\n            # Derivatives of shape functions w.r.t. physical coordinates (x, y)\n            J_inv = np.linalg.inv(J)\n            N_derivs_physical = J_inv @ N_derivs_parent\n\n            # B matrix assembly\n            B = np.zeros((3, 8))\n            for k in range(4):\n                dNdX_k = N_derivs_physical[0, k]\n                dNdY_k = N_derivs_physical[1, k]\n                B[0, 2*k]      = dNdX_k\n                B[1, 2*k + 1]  = dNdY_k\n                B[2, 2*k]      = dNdY_k\n                B[2, 2*k + 1]  = dNdX_k\n\n            Ke += B.T @ D @ B * detJ * weight * t\n            \n    return Ke\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        {'type': 'CST', 'nodes': np.array([[0,0],[1,0],[0,1]]), 't': 0.05, 'E': 210e9, 'nu': 0.29, 'analysis': 'plane_stress', 'integration': None},\n        {'type': 'Q4',  'nodes': np.array([[0,0],[1,0],[1,1],[0,1]]), 't': 0.05, 'E': 210e9, 'nu': 0.29, 'analysis': 'plane_stress', 'integration': 'full'},\n        {'type': 'Q4',  'nodes': np.array([[0,0],[1,0],[1,1],[0,1]]), 't': 0.05, 'E': 210e9, 'nu': 0.29, 'analysis': 'plane_stress', 'integration': 'reduced'},\n        {'type': 'Q4',  'nodes': np.array([[0,0],[2,0.2],[2.2,1.8],[0,1]]), 't': 0.1, 'E': 70e9, 'nu': 0.25, 'analysis': 'plane_stress', 'integration': 'reduced'},\n        {'type': 'Q4',  'nodes': np.array([[0,0],[2,0],[2,1],[0,1]]), 't': 0.1, 'E': 1e6, 'nu': 0.49, 'analysis': 'plane_strain', 'integration': 'full'},\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        if case['type'] == 'CST':\n            Ke = stiffness_cst(case['nodes'], case['t'], case['E'], case['nu'], case['analysis'])\n        elif case['type'] == 'Q4':\n            Ke = stiffness_q4(case['nodes'], case['t'], case['E'], case['nu'], case['analysis'], case['integration'])\n        else:\n            raise ValueError(f\"Unknown element type specified in test case: {case['type']}\")\n            \n        # Eigenanalysis\n        # Stiffness matrix is real and symmetric, so use eigvalsh for efficiency.\n        eigenvalues = np.linalg.eigvalsh(Ke)\n        \n        # Count near-zero eigenvalues based on relative tolerance\n        max_eig_abs = np.max(np.abs(eigenvalues))\n        \n        zero_eig_count = 0\n        if max_eig_abs < 1e-9: # Safeguard for a nearly zero matrix\n            # If all eigenvalues are effectively zero, all are zero modes\n            zero_eig_count = len(eigenvalues)\n        else:\n            rel_tolerance = 1e-8 * max_eig_abs\n            zero_eig_count = np.sum(np.abs(eigenvalues) < rel_tolerance)\n            \n        results.append(int(zero_eig_count))\n        \n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == '__main__':\n    solve()\n```", "id": "2554569"}, {"introduction": "A stable element is essential, but its ultimate value lies in its accuracy. This practice introduces a powerful verification technique, the Method of Manufactured Solutions, to quantitatively assess element performance. You will write a program to compare the stress field computed by CST and Q4 elements against a known, exact solution derived from a manufactured quadratic displacement field [@problem_id:2554580]. By calculating the relative error norm, $\\eta$, this exercise provides direct, numerical insight into how an element's underlying interpolation order dictates its accuracy and convergence behavior when modeling complex strain gradients.", "problem": "Write a program that constructs and compares element-wise stress approximation errors for two-dimensional linear elasticity under both plane stress and plane strain assumptions, using two standard finite element interpolations: the constant-strain triangle (CST) and the bilinear quadrilateral (Q4). The comparison must be driven by a known, quadratic displacement field so that the exact strain and stress fields are analytically available.\n\nThe task is to work entirely from the following principles and core definitions:\n- Kinematics: the small-strain tensor is the symmetric gradient of displacement. With the engineering shear strain convention, the in-plane strain vector is\n$$\n\\boldsymbol{\\varepsilon}(x,y) = \\begin{bmatrix}\\varepsilon_{xx}(x,y) \\\\ \\varepsilon_{yy}(x,y) \\\\ \\gamma_{xy}(x,y)\\end{bmatrix}\n= \\begin{bmatrix}\\dfrac{\\partial u_x}{\\partial x} \\\\ \\dfrac{\\partial u_y}{\\partial y} \\\\ \\dfrac{\\partial u_x}{\\partial y} + \\dfrac{\\partial u_y}{\\partial x}\\end{bmatrix}.\n$$\n- Constitutive law: under linear elasticity, the Cauchy stress vector is\n$$\n\\boldsymbol{\\sigma}(x,y) = \\mathbf{D} \\, \\boldsymbol{\\varepsilon}(x,y),\n$$\nwhere the constitutive matrix for plane stress is\n$$\n\\mathbf{D}_{\\mathrm{ps}} = \\frac{E}{1-\\nu^2}\n\\begin{bmatrix}\n1 & \\nu & 0 \\\\\n\\nu & 1 & 0 \\\\\n0 & 0 & \\dfrac{1-\\nu}{2}\n\\end{bmatrix},\n$$\nand for plane strain is\n$$\n\\mathbf{D}_{\\mathrm{pe}} = \\frac{E}{(1+\\nu)(1-2\\nu)}\n\\begin{bmatrix}\n1-\\nu & \\nu & 0 \\\\\n\\nu & 1-\\nu & 0 \\\\\n0 & 0 & \\dfrac{1-2\\nu}{2}\n\\end{bmatrix}.\n$$\n- Interpolation: a finite element displacement field is constructed by interpolating nodal displacements via shape functions. For CST, the shape functions are linear over each triangle, producing a piecewise constant strain. For Q4 on an affine, axis-aligned rectangular mesh, the shape functions are bilinear over each quadrilateral, producing a piecewise linear strain.\n\nUse the unit square domain $[0,1]\\times[0,1]$ discretized by a uniform $N\\times N$ mesh of axis-aligned squares. For the CST approximation, split each square into two triangles along the bottom-left to top-right diagonal. For the Q4 approximation, use the bilinear shape functions on each square. Do not assemble any global system; instead, for each element, set the element nodal displacements by sampling the exact displacement field at the element nodes, interpolate the displacement field within the element using the elementâ€™s shape functions, differentiate to obtain the approximate strain $\\boldsymbol{\\varepsilon}^h$, and compute the approximate stress $\\boldsymbol{\\sigma}^h = \\mathbf{D}\\boldsymbol{\\varepsilon}^h$.\n\nAdopt the exact displacement field\n$$\nu_x(x,y) = a_1 x^2 + a_2 x y + a_3 y^2 + a_4 x + a_5 y + a_6,\\quad\nu_y(x,y) = b_1 x^2 + b_2 x y + b_3 y^2 + b_4 x + b_5 y + b_6,\n$$\nwith the fixed coefficients\n$$\na_1=1,\\; a_2=\\tfrac{1}{2},\\; a_3=\\tfrac{1}{5},\\; a_4=\\tfrac{1}{10},\\; a_5=\\tfrac{1}{20},\\; a_6=\\tfrac{1}{100},\\\\\nb_1=-\\tfrac{3}{10},\\; b_2=\\tfrac{2}{5},\\; b_3=\\tfrac{9}{10},\\; b_4=\\tfrac{1}{5},\\; b_5=-\\tfrac{1}{10},\\; b_6=-\\tfrac{1}{50}.\n$$\nFrom this, compute the exact strain $\\boldsymbol{\\varepsilon}(x,y)$ by differentiation and the exact stress $\\boldsymbol{\\sigma}(x,y) = \\mathbf{D}\\boldsymbol{\\varepsilon}(x,y)$.\n\nFor error measurement, use the relative $L^2$-type stress error norm\n$$\n\\eta = \\left(\\frac{\\int_{\\Omega} \\lVert \\boldsymbol{\\sigma}(x,y) - \\boldsymbol{\\sigma}^h(x,y) \\rVert_2^2 \\, \\mathrm{d}\\Omega}{\\int_{\\Omega} \\lVert \\boldsymbol{\\sigma}(x,y) \\rVert_2^2 \\, \\mathrm{d}\\Omega}\\right)^{1/2},\n$$\nwhich is dimensionless. Numerically approximate the integrals by exact or sufficiently accurate Gaussian quadrature on each element:\n- For CST triangles, use a degree-$2$ exact quadrature rule on triangles (three points with equal weights).\n- For Q4 quadrilaterals on rectangles, use a tensor product $2\\times 2$ Gaussian quadrature in the natural coordinates.\n\nYour program must:\n- Implement both plane stress and plane strain via $\\mathbf{D}_{\\mathrm{ps}}$ and $\\mathbf{D}_{\\mathrm{pe}}$.\n- Implement both CST and Q4 element kinematics as described.\n- For each test case, compute two numbers: the CST relative error $\\eta_{\\mathrm{CST}}$ and the Q4 relative error $\\eta_{\\mathrm{Q4}}$.\n\nUse the following test suite of parameter sets, where $E$ is Youngâ€™s modulus in pascals and $\\nu$ is Poissonâ€™s ratio. All outputs must be reported as dimensionless decimal numbers (no physical units):\n- Test $1$: plane stress, $E=200\\times 10^9$, $\\nu=0.3$, $N=1$.\n- Test $2$: plane stress, $E=200\\times 10^9$, $\\nu=0.3$, $N=4$.\n- Test $3$: plane strain, $E=70\\times 10^9$, $\\nu=0.25$, $N=2$.\n- Test $4$: plane strain, $E=70\\times 10^9$, $\\nu=0$, $N=3$.\n\nFinal output format:\n- Your program should produce a single line of output containing the $8$ results as a comma-separated list enclosed in square brackets, ordered as\n$$\n[\\eta_{\\mathrm{CST}}^{(1)},\\eta_{\\mathrm{Q4}}^{(1)},\\eta_{\\mathrm{CST}}^{(2)},\\eta_{\\mathrm{Q4}}^{(2)},\\eta_{\\mathrm{CST}}^{(3)},\\eta_{\\mathrm{Q4}}^{(3)},\\eta_{\\mathrm{CST}}^{(4)},\\eta_{\\mathrm{Q4}}^{(4)}].\n$$", "solution": "We begin from the kinematic and constitutive foundations. The displacement field is prescribed as a quadratic polynomial in $x$ and $y$, so the exact strain field $\\boldsymbol{\\varepsilon}(x,y)$, obtained by differentiation,\n$$\n\\varepsilon_{xx} = \\frac{\\partial u_x}{\\partial x},\\quad\n\\varepsilon_{yy} = \\frac{\\partial u_y}{\\partial y},\\quad\n\\gamma_{xy} = \\frac{\\partial u_x}{\\partial y} + \\frac{\\partial u_y}{\\partial x},\n$$\nis linear in $(x,y)$. The exact stress field follows from the linear elastic constitutive matrix $\\mathbf{D}$:\n$$\n\\boldsymbol{\\sigma}(x,y) = \\mathbf{D} \\, \\boldsymbol{\\varepsilon}(x,y).\n$$\nWe compute the relative $L^2$-type stress error\n$$\n\\eta = \\left(\\frac{\\int_{\\Omega} \\lVert \\boldsymbol{\\sigma} - \\boldsymbol{\\sigma}^h \\rVert_2^2 \\, \\mathrm{d}\\Omega}{\\int_{\\Omega} \\lVert \\boldsymbol{\\sigma} \\rVert_2^2 \\, \\mathrm{d}\\Omega}\\right)^{1/2},\n$$\nwhere $\\boldsymbol{\\sigma}^h$ denotes the finite element stress derived from interpolating the exact nodal displacements and differentiating within the element. This setup isolates interpolation error without solving equilibrium.\n\nFor the constant-strain triangle (CST), the element shape functions are linear in $(x,y)$, hence the displacement interpolation is linear and the gradient, and thus the strain $\\boldsymbol{\\varepsilon}^h$, is constant within each triangle. The strain-displacement matrix $\\mathbf{B}$ for a triangle with nodes $\\left(x_i,y_i\\right)$, $i\\in\\{1,2,3\\}$, is\n$$\n\\mathbf{B} = \\frac{1}{2A}\n\\begin{bmatrix}\nb_1 & 0 & b_2 & 0 & b_3 & 0 \\\\\n0 & c_1 & 0 & c_2 & 0 & c_3 \\\\\nc_1 & b_1 & c_2 & b_2 & c_3 & b_3\n\\end{bmatrix},\n$$\nwhere $A$ is the triangle area and $(b_i,c_i)$ are the geometric coefficients\n$$\nb_1 = y_2 - y_3,\\quad b_2 = y_3 - y_1,\\quad b_3 = y_1 - y_2; \\quad\nc_1 = x_3 - x_2,\\quad c_2 = x_1 - x_3,\\quad c_3 = x_2 - x_1.\n$$\nGiven the nodal displacement vector $\\mathbf{d}_e = [u_1,v_1,u_2,v_2,u_3,v_3]^\\top$ (populated by sampling the exact displacement at the triangleâ€™s nodes), the element strain is $\\boldsymbol{\\varepsilon}^h = \\mathbf{B}\\mathbf{d}_e$ and the element stress is $\\boldsymbol{\\sigma}^h = \\mathbf{D}\\boldsymbol{\\varepsilon}^h$, both constant over the triangle. Since the exact stress is linear in $(x,y)$ while the CST stress is constant, their difference is linear; its squared norm is a quadratic polynomial. We integrate it exactly over each triangle using a degree-$2$ three-point Gaussian quadrature with barycentric points $(\\tfrac{2}{3},\\tfrac{1}{6},\\tfrac{1}{6})$ and its permutations, each with weight $\\tfrac{1}{3}$, scaled by the triangle area.\n\nFor the bilinear quadrilateral (Q4) on an axis-aligned rectangular element, the isoparametric mapping from natural coordinates $(\\xi,\\eta)\\in[-1,1]^2$ employs bilinear shape functions\n$$\nN_1=\\tfrac{1}{4}(1-\\xi)(1-\\eta),\\;\nN_2=\\tfrac{1}{4}(1+\\xi)(1-\\eta),\\;\nN_3=\\tfrac{1}{4}(1+\\xi)(1+\\eta),\\;\nN_4=\\tfrac{1}{4}(1-\\xi)(1+\\eta).\n$$\nThe displacement interpolation is\n$$\n\\mathbf{u}^h(\\xi,\\eta) = \\sum_{a=1}^4 N_a(\\xi,\\eta)\\,\\mathbf{u}_a,\n$$\nwhere $\\mathbf{u}_a$ are the exact nodal displacements at the quadrilateralâ€™s vertices. The strain follows from differentiating $\\mathbf{u}^h$ with respect to physical coordinates. Using the Jacobian $\\mathbf{J}=\\frac{\\partial(x,y)}{\\partial(\\xi,\\eta)}$ and the chain rule,\n$$\n\\begin{bmatrix}\n\\frac{\\partial N_a}{\\partial x} \\\\ \\frac{\\partial N_a}{\\partial y}\n\\end{bmatrix}\n= \\mathbf{J}^{-1}\n\\begin{bmatrix}\n\\frac{\\partial N_a}{\\partial \\xi} \\\\ \\frac{\\partial N_a}{\\partial \\eta}\n\\end{bmatrix},\n$$\nwe assemble the standard $\\mathbf{B}$ matrix for Q4 at each quadrature point, compute $\\boldsymbol{\\varepsilon}^h = \\mathbf{B}\\mathbf{d}_e$ with $\\mathbf{d}_e=[u_1,v_1,u_2,v_2,u_3,v_3,u_4,v_4]^\\top$, and then $\\boldsymbol{\\sigma}^h=\\mathbf{D}\\boldsymbol{\\varepsilon}^h$. Because both the exact and Q4 stresses are linear in $(x,y)$ on an affine-mapped rectangle, their difference is also linear and its squared norm is quadratic. We integrate it exactly by a tensor-product $2\\times 2$ Gaussian quadrature in $(\\xi,\\eta)$ with points at $\\xi,\\eta=\\pm 1/\\sqrt{3}$ and unit weights, scaled by $\\det\\mathbf{J}$.\n\nFor both element types, we accumulate the numerator\n$$\n\\int_{\\Omega} \\lVert \\boldsymbol{\\sigma}-\\boldsymbol{\\sigma}^h\\rVert_2^2 \\,\\mathrm{d}\\Omega\n$$\nand denominator\n$$\n\\int_{\\Omega} \\lVert \\boldsymbol{\\sigma}\\rVert_2^2 \\,\\mathrm{d}\\Omega\n$$\nelementwise via quadrature to obtain the relative error $\\eta$.\n\nWhy Q4 differs from CST for a quadratic displacement field:\n- The exact strain is linear in $(x,y)$ because the displacement is quadratic. The CST strain is constant per triangle, which is the best constant approximation to a linear field on that region, leading to a first-order ($\\mathcal{O}(h)$) gradient error with a relatively large constant.\n- The Q4 strain is linear per rectangle (on an affine mesh), matching the exact linear variation more closely. Although bilinear displacement cannot reproduce pure $x^2$ or $y^2$ terms exactly, its derivatives are linear, yielding a first-order ($\\mathcal{O}(h)$) gradient error with a smaller constant due to partial reproduction of mixed terms and better local fit.\n- Consequently, for the same mesh, we expect $\\eta_{\\mathrm{Q4}}<\\eta_{\\mathrm{CST}}$, and both to decrease as $N$ increases (mesh refinement).\n\nThe program implements:\n- Exact strains by analytic differentiation of the given quadratic polynomials.\n- Exact stresses via $\\mathbf{D}_{\\mathrm{ps}}$ and $\\mathbf{D}_{\\mathrm{pe}}$.\n- CST: elementwise constant $\\boldsymbol{\\sigma}^h$ via the triangle $\\mathbf{B}$ matrix and degree-$2$ triangle quadrature for error integration.\n- Q4: pointwise $\\boldsymbol{\\sigma}^h(\\xi,\\eta)$ via isoparametric differentiation and $2\\times 2$ Gauss quadrature.\n- Aggregation of the relative errors for the four specified tests. The output is a single line with the eight dimensionless numbers in the required order.\n\nThis design respects the fundamental kinematics and constitutive laws, isolates interpolation effects without global equilibrium, and uses quadrature rules that are exact for the polynomial degrees encountered in the error integrands.", "answer": "```python\nimport numpy as np\n\n# Finite Element interpolation error comparison for CST vs Q4\n# under plane stress / plane strain, using a known quadratic displacement field.\n\ndef constitutive_matrix(E, nu, mode):\n    if mode == 'plane_stress':\n        fac = E / (1.0 - nu**2)\n        D = fac * np.array([\n            [1.0, nu, 0.0],\n            [nu, 1.0, 0.0],\n            [0.0, 0.0, (1.0 - nu) / 2.0]\n        ])\n    elif mode == 'plane_strain':\n        fac = E / ((1.0 + nu) * (1.0 - 2.0 * nu))\n        D = fac * np.array([\n            [1.0 - nu, nu, 0.0],\n            [nu, 1.0 - nu, 0.0],\n            [0.0, 0.0, (1.0 - 2.0 * nu) / 2.0]\n        ])\n    else:\n        raise ValueError(\"Unknown mode\")\n    return D\n\n# Quadratic displacement coefficients\na1, a2, a3, a4, a5, a6 = 1.0, 0.5, 0.2, 0.1, 0.05, 0.01\nb1, b2, b3, b4, b5, b6 = -0.3, 0.4, 0.9, 0.2, -0.1, -0.02\n\ndef exact_u(x, y):\n    ux = a1*x*x + a2*x*y + a3*y*y + a4*x + a5*y + a6\n    uy = b1*x*x + b2*x*y + b3*y*y + b4*x + b5*y + b6\n    return ux, uy\n\ndef exact_strain(x, y):\n    dux_dx = 2.0*a1*x + a2*y + a4\n    dux_dy = a2*x + 2.0*a3*y + a5\n    duy_dx = 2.0*b1*x + b2*y + b4\n    duy_dy = b2*x + 2.0*b3*y + b5\n    exx = dux_dx\n    eyy = duy_dy\n    gxy = dux_dy + duy_dx\n    return np.array([exx, eyy, gxy])\n\ndef exact_sigma(x, y, D):\n    return D @ exact_strain(x, y)\n\n# Triangle area\ndef tri_area(coords):\n    x1, y1 = coords[0]\n    x2, y2 = coords[1]\n    x3, y3 = coords[2]\n    return 0.5 * ((x2 - x1)*(y3 - y1) - (x3 - x1)*(y2 - y1))\n\ndef B_matrix_CST(coords):\n    x1, y1 = coords[0]\n    x2, y2 = coords[1]\n    x3, y3 = coords[2]\n    A2 = (x2 - x1)*(y3 - y1) - (x3 - x1)*(y2 - y1)  # 2*A\n    b1 = y2 - y3\n    b2 = y3 - y1\n    b3 = y1 - y2\n    c1 = x3 - x2\n    c2 = x1 - x3\n    c3 = x2 - x1\n    B = np.array([\n        [b1, 0.0, b2, 0.0, b3, 0.0],\n        [0.0, c1, 0.0, c2, 0.0, c3],\n        [c1, b1, c2, b2, c3, b3]\n    ]) / A2\n    A = 0.5 * A2\n    return B, A\n\n# Triangle quadrature: degree-2 exact (three points)\ntri_qw = np.array([1.0/3.0, 1.0/3.0, 1.0/3.0])\ntri_qL = np.array([\n    [2.0/3.0, 1.0/6.0, 1.0/6.0],\n    [1.0/6.0, 2.0/3.0, 1.0/6.0],\n    [1.0/6.0, 1.0/6.0, 2.0/3.0]\n])\n\n# Q4 shape functions and derivatives\ndef q4_shape_funcs(xi, eta):\n    N = np.array([\n        0.25*(1 - xi)*(1 - eta),\n        0.25*(1 + xi)*(1 - eta),\n        0.25*(1 + xi)*(1 + eta),\n        0.25*(1 - xi)*(1 + eta)\n    ])\n    dN_dxi = np.array([\n        -0.25*(1 - eta),\n        0.25*(1 - eta),\n        0.25*(1 + eta),\n        -0.25*(1 + eta)\n    ])\n    dN_deta = np.array([\n        -0.25*(1 - xi),\n        -0.25*(1 + xi),\n        0.25*(1 + xi),\n        0.25*(1 - xi)\n    ])\n    return N, dN_dxi, dN_deta\n\ngauss_pts = [-1.0/np.sqrt(3.0), 1.0/np.sqrt(3.0)]\ngauss_wts = [1.0, 1.0]\n\ndef compute_errors(Ndiv, E, nu, mode):\n    D = constitutive_matrix(E, nu, mode)\n    # Build mesh node coordinates along x and y\n    xs = np.linspace(0.0, 1.0, Ndiv+1)\n    ys = np.linspace(0.0, 1.0, Ndiv+1)\n    # CST accumulators\n    num_cst = 0.0\n    den_cst = 0.0\n    # Q4 accumulators\n    num_q4 = 0.0\n    den_q4 = 0.0\n\n    for i in range(Ndiv):\n        for j in range(Ndiv):\n            # four corners of the square (Q4)\n            x0, y0 = xs[i], ys[j]\n            x1, y1 = xs[i+1], ys[j]\n            x2, y2 = xs[i+1], ys[j+1]\n            x3, y3 = xs[i], ys[j+1]\n            quad_coords = np.array([[x0,y0],[x1,y1],[x2,y2],[x3,y3]])\n\n            # Q4 contribution\n            # Nodal displacements for Q4 element\n            de_q4 = []\n            for (x, y) in quad_coords:\n                ux, uy = exact_u(x, y)\n                de_q4.extend([ux, uy])\n            de_q4 = np.array(de_q4)\n\n            # 2x2 gauss integration\n            for w_xi, xi in zip(gauss_wts, gauss_pts):\n                for w_eta, eta in zip(gauss_wts, gauss_pts):\n                    N, dN_dxi, dN_deta = q4_shape_funcs(xi, eta)\n                    # Map to physical\n                    x = np.dot(N, quad_coords[:,0])\n                    y = np.dot(N, quad_coords[:,1])\n                    # Jacobian\n                    J = np.zeros((2,2))\n                    J[0,0] = np.dot(dN_dxi, quad_coords[:,0])    # dx/dxi\n                    J[0,1] = np.dot(dN_dxi, quad_coords[:,1])    # dy/dxi\n                    J[1,0] = np.dot(dN_deta, quad_coords[:,0])   # dx/deta\n                    J[1,1] = np.dot(dN_deta, quad_coords[:,1])   # dy/deta\n                    detJ = np.linalg.det(J)\n                    invJ = np.linalg.inv(J)\n                    # Derivatives w.r.t x,y\n                    grads = np.zeros((4,2))\n                    for a in range(4):\n                        dN_nat = np.array([dN_dxi[a], dN_deta[a]])\n                        dN_xy = invJ @ dN_nat\n                        grads[a,0] = dN_xy[0]\n                        grads[a,1] = dN_xy[1]\n                    # Build B matrix 3x8\n                    B = np.zeros((3, 8))\n                    for a in range(4):\n                        dNx = grads[a,0]\n                        dNy = grads[a,1]\n                        B[0, 2*a]   = dNx\n                        B[1, 2*a+1] = dNy\n                        B[2, 2*a]   = dNy\n                        B[2, 2*a+1] = dNx\n                    eps_h = B @ de_q4\n                    sig_h = D @ eps_h\n                    sig_ex = exact_sigma(x, y, D)\n                    diff = sig_ex - sig_h\n                    w = w_xi * w_eta * detJ\n                    num_q4 += np.dot(diff, diff) * w\n                    den_q4 += np.dot(sig_ex, sig_ex) * w\n\n            # CST contribution: split into two triangles (0-1-2) and (0-2-3)\n            tris = [\n                np.array([quad_coords[0], quad_coords[1], quad_coords[2]]),\n                np.array([quad_coords[0], quad_coords[2], quad_coords[3]])\n            ]\n            for tri in tris:\n                Bc, A = B_matrix_CST(tri)\n                # nodal displacement vector de: [u1,v1,u2,v2,u3,v3]\n                de_tri = []\n                for (x, y) in tri:\n                    ux, uy = exact_u(x, y)\n                    de_tri.extend([ux, uy])\n                de_tri = np.array(de_tri)\n                eps_h = Bc @ de_tri\n                sig_h = D @ eps_h\n                # Triangular quadrature (3 points)\n                for (wL, L) in zip(tri_qw, tri_qL):\n                    # barycentric to Cartesian\n                    x = L[0]*tri[0,0] + L[1]*tri[1,0] + L[2]*tri[2,0]\n                    y = L[0]*tri[0,1] + L[1]*tri[1,1] + L[2]*tri[2,1]\n                    sig_ex = exact_sigma(x, y, D)\n                    diff = sig_ex - sig_h\n                    num_cst += np.dot(diff, diff) * (A * wL)\n                    den_cst += np.dot(sig_ex, sig_ex) * (A * wL)\n\n    eta_cst = np.sqrt(num_cst / den_cst) if den_cst > 0 else 0.0\n    eta_q4  = np.sqrt(num_q4  / den_q4)  if den_q4  > 0 else 0.0\n    return eta_cst, eta_q4\n\ndef solve():\n    test_cases = [\n        # (N, E, nu, mode)\n        (1, 200e9, 0.3, 'plane_stress'),\n        (4, 200e9, 0.3, 'plane_stress'),\n        (2, 70e9, 0.25, 'plane_strain'),\n        (3, 70e9, 0.0, 'plane_strain')\n    ]\n    results = []\n    for (N, E, nu, mode) in test_cases:\n        eta_cst, eta_q4 = compute_errors(N, E, nu, mode)\n        results.append(eta_cst)\n        results.append(eta_q4)\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2554580"}]}