{"hands_on_practices": [{"introduction": "The first step in developing reliable nonlinear simulation code is robust verification. This practice introduces the \"tangent check,\" a fundamental technique for ensuring your analytically derived consistent tangent stiffness matrix is correctly implemented [@problem_id:2547569]. By comparing the analytical tangent to one computed numerically via finite differences, you can gain confidence in your code and debug potential errors, a crucial skill for any computational mechanician.", "problem": "Consider a single two-node bar element in the Total Lagrangian formulation within the Finite Element Method (FEM). Let the reference coordinate be denoted by $X \\in [0,L_0]$, and let the nodal displacements in the reference configuration be $u_1$ and $u_2$. Assume linear shape functions over the element so that the displacement field is $u(X) = N_1(X) u_1 + N_2(X) u_2$ with constant derivatives with respect to the reference coordinate. The deformation gradient is $F = 1 + \\frac{\\partial u}{\\partial X}$. The cross-sectional area is $A$, and all quantities may be treated as nondimensional for this problem.\n\nThe bar is made of a compressible hyperelastic material with a stored energy density per unit reference volume given by\n$$\n\\Psi(F) = \\frac{\\mu}{2} \\left( F^2 - 1 - 2 \\ln F \\right) + \\frac{\\lambda}{2} \\left( \\ln F \\right)^2,\n$$\nwhere $F > 0$, and $\\lambda$ and $\\mu$ are the Lamé parameters. The first Piola–Kirchhoff stress is defined by $P(F) = \\frac{\\partial \\Psi}{\\partial F}$. The weak form of equilibrium in the Total Lagrangian setting for this element yields the internal force vector and, upon linearization, the consistent algorithmic tangent stiffness matrix that must be used in a Newton–Raphson (NR) iteration for quadratic convergence in nonlinear analysis.\n\nYour tasks are:\n1. Starting from the principle of virtual work and the definition of the first Piola–Kirchhoff stress, derive the $2 \\times 1$ internal force vector $f_{\\text{int}}(u_1,u_2)$ for the element in terms of $A$, $L_0$, and $P(F)$.\n2. Using the chain rule and the definition $F = 1 + \\frac{u_2 - u_1}{L_0}$, derive the $2 \\times 2$ consistent tangent stiffness matrix $K_{\\text{cons}}(u_1,u_2)$ as the exact Jacobian $\\frac{\\partial f_{\\text{int}}}{\\partial [u_1,u_2]}$, expressed in terms of $A$, $L_0$, and $\\frac{dP}{dF}$ evaluated at the current $F$.\n3. Implement a numerical differentiation procedure to compute a finite-difference Jacobian $K_{\\text{num}}$ of the internal force. Use a symmetric central difference with a small perturbation on each nodal displacement component. Use a perturbation step that scales with $L_0$ to maintain numerical stability across different element sizes.\n4. For each test case specified below, compute the relative Frobenius-norm error between the consistent tangent and the numerical Jacobian,\n$$\ne = \\frac{\\| K_{\\text{cons}} - K_{\\text{num}} \\|_F}{\\max\\left(1, \\| K_{\\text{num}} \\|_F \\right)}.\n$$\nReport this error as a floating-point number.\n\nYou must implement a complete program that, for each parameter set in the test suite below, computes the error $e$ and outputs the list of errors as a single line. Angles are not involved. No physical units are required; treat all quantities as nondimensional. Your program must produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each error must be printed in scientific notation with eight digits after the decimal point.\n\nTest suite (each case is $(A, L_0, \\lambda, \\mu, u_1, u_2)$):\n- Case 1 (moderate extension): $(2.0,\\; 1.0,\\; 120.0,\\; 80.0,\\; 0.0,\\; 0.2)$.\n- Case 2 (zero average strain): $(1.0,\\; 3.0,\\; 200.0,\\; 50.0,\\; 0.01,\\; 0.01)$.\n- Case 3 (significant compression but admissible $F$): $(1.5,\\; 2.0,\\; 500.0,\\; 30.0,\\; 0.2,\\; -0.5)$.\n- Case 4 (nearly incompressible response with compression): $(0.8,\\; 1.0,\\; 1000.0,\\; 10.0,\\; 0.0,\\; -0.3)$.\n\nFinal output format:\nYour program should produce a single line of output containing the errors for the four cases as a comma-separated list enclosed in square brackets, in scientific notation with eight digits after the decimal point. For example: \"[1.23456789e-06,9.87654321e-07, ...]\".", "solution": "The problem presented is a standard, well-posed exercise in the field of nonlinear computational solid mechanics, specifically concerning the Finite Element Method (FEM) for hyperelastic materials. It is scientifically grounded and contains all necessary information for a unique solution. Therefore, we may proceed with the derivation and implementation.\n\nThe analysis is based on a single two-node bar element in a Total Lagrangian framework. The element's reference length is $L_0$, its constant cross-sectional area is $A$, and its nodal displacements are denoted by the vector $\\mathbf{u} = [u_1, u_2]^T$.\n\nFirst, we establish the kinematic relations. The displacement field $u(X)$ is interpolated from the nodal displacements using linear shape functions $N_1(X) = 1 - X/L_0$ and $N_2(X) = X/L_0$. The displacement gradient is then:\n$$\n\\frac{\\partial u}{\\partial X} = \\frac{\\partial}{\\partial X} (N_1(X) u_1 + N_2(X) u_2) = \\frac{\\partial N_1}{\\partial X} u_1 + \\frac{\\partial N_2}{\\partial X} u_2 = -\\frac{1}{L_0} u_1 + \\frac{1}{L_0} u_2 = \\frac{u_2 - u_1}{L_0}\n$$\nThis quantity is constant throughout the element. The deformation gradient $F$ is defined as $F = 1 + \\partial u / \\partial X$, which gives:\n$$\nF = 1 + \\frac{u_2 - u_1}{L_0}\n$$\nSince the displacement gradient is constant, $F$ is also constant over the element domain $X \\in [0, L_0]$.\n\nThe material behavior is described by the provided stored energy density function $\\Psi(F)$:\n$$\n\\Psi(F) = \\frac{\\mu}{2} \\left( F^2 - 1 - 2 \\ln F \\right) + \\frac{\\lambda}{2} \\left( \\ln F \\right)^2\n$$\nThe first Piola-Kirchhoff (PK$1$) stress $P$ is the derivative of $\\Psi$ with respect to $F$:\n$$\nP(F) = \\frac{\\partial \\Psi}{\\partial F} = \\frac{\\mu}{2} \\left( 2F - \\frac{2}{F} \\right) + \\frac{\\lambda}{2} \\left( 2 (\\ln F) \\cdot \\frac{1}{F} \\right) = \\mu \\left( F - \\frac{1}{F} \\right) + \\frac{\\lambda \\ln F}{F}\n$$\n\n**Task 1: Derivation of the Internal Force Vector**\n\nThe internal force vector $\\mathbf{f}_{\\text{int}}$ is derived from the principle of virtual work. The internal virtual work $\\delta W_{\\text{int}}$ is given by the integral of the PK$1$ stress contracted with the variation of the deformation gradient over the reference volume $V_0$. For a $1$D bar, this simplifies to:\n$$\n\\delta W_{\\text{int}} = \\int_{V_0} P \\, \\delta F \\, dV_0 = \\int_0^{L_0} P \\, \\delta F \\, A \\, dX\n$$\nThe variation of the deformation gradient $\\delta F$ is:\n$$\n\\delta F = \\delta \\left( 1 + \\frac{u_2 - u_1}{L_0} \\right) = \\frac{\\delta u_2 - \\delta u_1}{L_0}\n$$\nSince $P$, $A$, and $\\delta F$ are all constant over the element, the integral becomes trivial:\n$$\n\\delta W_{\\text{int}} = A P \\left( \\frac{\\delta u_2 - \\delta u_1}{L_0} \\right) \\int_0^{L_0} dX = A P L_0 \\left( \\frac{\\delta u_2 - \\delta u_1}{L_0} \\right) = A P (\\delta u_2 - \\delta u_1)\n$$\nWe can write this in matrix form as:\n$$\n\\delta W_{\\text{int}} = [-\\delta u_1, \\delta u_2] \\begin{bmatrix} A P \\\\ A P \\end{bmatrix} \\text{ (This is incorrect, let us be precise)} \\quad \\delta W_{\\text{int}} = (-A P) \\delta u_1 + (A P) \\delta u_2 = [\\delta u_1, \\delta u_2] \\begin{bmatrix} -A P \\\\ A P \\end{bmatrix}\n$$\nBy definition, $\\delta W_{\\text{int}} = \\delta \\mathbf{u}^T \\mathbf{f}_{\\text{int}}$. Comparing the two expressions, we identify the internal force vector as:\n$$\n\\mathbf{f}_{\\text{int}}(u_1, u_2) = \\begin{bmatrix} f_{\\text{int},1} \\\\ f_{\\text{int},2} \\end{bmatrix} = \\begin{bmatrix} -A P(F) \\\\ A P(F) \\end{bmatrix} = A P(F) \\begin{bmatrix} -1 \\\\ 1 \\end{bmatrix}\n$$\nThis result is consistent with mechanical equilibrium, where the internal forces at the two nodes of a bar under uniform tension or compression must be equal and opposite.\n\n**Task 2: Derivation of the Consistent Tangent Stiffness Matrix**\n\nThe consistent tangent stiffness matrix $\\mathbf{K}_{\\text{cons}}$ is the exact Jacobian of the internal force vector with respect to the nodal displacement vector $\\mathbf{u} = [u_1, u_2]^T$.\n$$\n\\mathbf{K}_{\\text{cons}} = \\frac{\\partial \\mathbf{f}_{\\text{int}}}{\\partial \\mathbf{u}} = \\begin{bmatrix} \\frac{\\partial f_{\\text{int},1}}{\\partial u_1} & \\frac{\\partial f_{\\text{int},1}}{\\partial u_2} \\\\ \\frac{\\partial f_{\\text{int},2}}{\\partial u_1} & \\frac{\\partial f_{\\text{int},2}}{\\partial u_2} \\end{bmatrix}\n$$\nWe apply the chain rule, as $\\mathbf{f}_{\\text{int}}$ depends on $\\mathbf{u}$ through $F$. The required partial derivatives of $F$ are:\n$$\n\\frac{\\partial F}{\\partial u_1} = -\\frac{1}{L_0}, \\quad \\frac{\\partial F}{\\partial u_2} = \\frac{1}{L_0}\n$$\nNow we compute the components of $\\mathbf{K}_{\\text{cons}}$:\n$$\nK_{11} = \\frac{\\partial (-A P(F))}{\\partial u_1} = -A \\frac{dP}{dF} \\frac{\\partial F}{\\partial u_1} = -A \\frac{dP}{dF} \\left(-\\frac{1}{L_0}\\right) = \\frac{A}{L_0} \\frac{dP}{dF}\n$$\n$$\nK_{12} = \\frac{\\partial (-A P(F))}{\\partial u_2} = -A \\frac{dP}{dF} \\frac{\\partial F}{\\partial u_2} = -A \\frac{dP}{dF} \\left(\\frac{1}{L_0}\\right) = -\\frac{A}{L_0} \\frac{dP}{dF}\n$$\n$$\nK_{21} = \\frac{\\partial (A P(F))}{\\partial u_1} = A \\frac{dP}{dF} \\frac{\\partial F}{\\partial u_1} = A \\frac{dP}{dF} \\left(-\\frac{1}{L_0}\\right) = -\\frac{A}{L_0} \\frac{dP}{dF}\n$$\n$$\nK_{22} = \\frac{\\partial (A P(F))}{\\partial u_2} = A \\frac{dP}{dF} \\frac{\\partial F}{\\partial u_2} = A \\frac{dP}{dF} \\left(\\frac{1}{L_0}\\right) = \\frac{A}{L_0} \\frac{dP}{dF}\n$$\nAssembling these components yields the matrix:\n$$\n\\mathbf{K}_{\\text{cons}} = \\frac{A}{L_0} \\frac{dP}{dF} \\begin{bmatrix} 1 & -1 \\\\ -1 & 1 \\end{bmatrix}\n$$\nThe term $c = dP/dF$ is the algorithmic tangent modulus. We must compute its explicit form:\n$$\n\\frac{dP}{dF} = \\frac{d}{dF} \\left( \\mu F - \\mu F^{-1} + \\lambda F^{-1} \\ln F \\right) \\\\\n= \\mu - \\mu(-1)F^{-2} + \\lambda \\left[ (-1)F^{-2} \\ln F + F^{-1} (F^{-1}) \\right] \\\\\n= \\mu + \\frac{\\mu}{F^2} - \\frac{\\lambda \\ln F}{F^2} + \\frac{\\lambda}{F^2} \\\\\n= \\mu \\left( 1 + \\frac{1}{F^2} \\right) + \\frac{\\lambda}{F^2} (1 - \\ln F)\n$$\nThis completes the analytical derivations. The consistent tangent matrix, being the exact Jacobian, is crucial for achieving the quadratic convergence rate of the Newton-Raphson method in nonlinear simulations.\n\n**Task 3 & 4: Numerical Implementation and Error Calculation**\n\nWe will implement the derived analytical expressions for $\\mathbf{f}_{\\text{int}}$ and $\\mathbf{K}_{\\text{cons}}$. A numerical Jacobian, $\\mathbf{K}_{\\text{num}}$, will be computed using a symmetric central finite difference scheme. The $j$-th column of $\\mathbf{K}_{\\text{num}}$ is approximated by:\n$$\n(\\mathbf{K}_{\\text{num}})_{:,j} \\approx \\frac{\\mathbf{f}_{\\text{int}}(\\mathbf{u} + h \\mathbf{e}_j) - \\mathbf{f}_{\\text{int}}(\\mathbf{u} - h \\mathbf{e}_j)}{2h}\n$$\nwhere $\\mathbf{e}_j$ is the $j$-th standard basis vector and $h$ is a small perturbation. As required, $h$ will be scaled with the element length $L_0$, using a value of $h = 10^{-7} L_0$ to balance truncation and round-off errors.\n\nFinally, the relative error between the analytical and numerical Jacobians is computed using the Frobenius norm:\n$$\ne = \\frac{\\|\\mathbf{K}_{\\text{cons}} - \\mathbf{K}_{\\text{num}}\\|_F}{\\max(1, \\|\\mathbf{K}_{\\text{num}}\\|_F)}\n$$\nThe normalization factor $\\max(1, \\|\\mathbf{K}_{\\text{num}}\\|_F)$ ensures numerical stability, particularly for cases where the stiffness matrix norm may be small. The program below executes these calculations for the provided test suite.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the relative error between the consistent tangent stiffness matrix and a\n    numerically computed Jacobian for a hyperelastic bar element.\n    \"\"\"\n    # Test suite: (A, L0, lambda, mu, u1, u2)\n    test_cases = [\n        # Case 1 (moderate extension)\n        (2.0, 1.0, 120.0, 80.0, 0.0, 0.2),\n        # Case 2 (zero average strain)\n        (1.0, 3.0, 200.0, 50.0, 0.01, 0.01),\n        # Case 3 (significant compression but admissible F)\n        (1.5, 2.0, 500.0, 30.0, 0.2, -0.5),\n        # Case 4 (nearly incompressible response with compression)\n        (0.8, 1.0, 1000.0, 10.0, 0.0, -0.3),\n    ]\n\n    results = []\n    for case in test_cases:\n        A, L0, lam, mu, u1_val, u2_val = case\n        u = np.array([u1_val, u2_val])\n\n        # Define kinematic and constitutive functions\n        def get_F(disp_vector):\n            \"\"\"Computes the deformation gradient F from a displacement vector.\"\"\"\n            return 1.0 + (disp_vector[1] - disp_vector[0]) / L0\n\n        def get_P(F_val):\n            \"\"\"Computes the First Piola-Kirchhoff stress P from F.\"\"\"\n            if F_val <= 0:\n                raise ValueError(\"Deformation gradient F must be positive.\")\n            # P(F) = mu * (F - 1/F) + lambda * ln(F) / F\n            return mu * (F_val - 1.0 / F_val) + lam * np.log(F_val) / F_val\n\n        def get_dP_dF(F_val):\n            \"\"\"Computes the tangent modulus dP/dF from F.\"\"\"\n            if F_val <= 0:\n                raise ValueError(\"Deformation gradient F must be positive.\")\n            # dP/dF = mu * (1 + 1/F^2) + lambda * (1 - ln(F)) / F^2\n            F_sq = F_val**2\n            return mu * (1.0 + 1.0 / F_sq) + lam * (1.0 - np.log(F_val)) / F_sq\n\n        def get_f_int(disp_vector):\n            \"\"\"Computes the internal force vector for a given displacement vector.\"\"\"\n            F_val = get_F(disp_vector)\n            P_val = get_P(F_val)\n            # f_int = A * P * [-1, 1]^T\n            return A * P_val * np.array([-1.0, 1.0])\n\n        # Task 2: Compute the consistent tangent stiffness matrix K_cons\n        F_current = get_F(u)\n        dP_dF_current = get_dP_dF(F_current)\n        # K_cons = (A/L0) * dP/dF * [[1, -1], [-1, 1]]\n        K_cons = (A / L0) * dP_dF_current * np.array([[1.0, -1.0], [-1.0, 1.0]])\n\n        # Task 3: Compute the numerical Jacobian K_num using central differences\n        h = L0 * 1e-7  # Perturbation step size, scaled with element length\n        K_num = np.zeros((2, 2))\n        \n        # Column 1: Perturb u1\n        u_p1 = u + np.array([h, 0.0])\n        u_m1 = u - np.array([h, 0.0])\n        f_p1 = get_f_int(u_p1)\n        f_m1 = get_f_int(u_m1)\n        col1 = (f_p1 - f_m1) / (2.0 * h)\n        \n        # Column 2: Perturb u2\n        u_p2 = u + np.array([0.0, h])\n        u_m2 = u - np.array([0.0, h])\n        f_p2 = get_f_int(u_p2)\n        f_m2 = get_f_int(u_m2)\n        col2 = (f_p2 - f_m2) / (2.0 * h)\n        \n        K_num[:, 0] = col1\n        K_num[:, 1] = col2\n        \n        # Task 4: Compute the relative Frobenius norm error\n        diff_norm = np.linalg.norm(K_cons - K_num, 'fro')\n        K_num_norm = np.linalg.norm(K_num, 'fro')\n        \n        error = diff_norm / max(1.0, K_num_norm)\n        results.append(error)\n\n    # Format and print the final output as a single line\n    formatted_results = [f\"{res:.8e}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2547569"}, {"introduction": "With a verified tangent, we can now explore its practical benefit. Why is the \"consistent\" tangent so important for efficiency? This practice demonstrates the answer by comparing the convergence of the standard Newton-Raphson method, which uses the consistent tangent, against a simpler quasi-Newton (secant) method [@problem_id:2547604]. You will witness firsthand the rapid, quadratic convergence that a consistent tangent provides, dramatically reducing the number of iterations required to solve a nonlinear problem.", "problem": "Consider a one-dimensional bar of undeformed length $L$ and cross-sectional area $A$, fixed at the left end and subjected to a concentrated axial force $P$ at the right end. Assume small strain kinematics so that the axial strain is $\\varepsilon = u/L$, where $u$ is the axial displacement at the loaded end. The material exhibits a nonlinear stress-strain law given by $\\sigma(\\varepsilon) = E\\,\\varepsilon + \\beta\\,\\varepsilon^{3}$, where $E$ is the Young’s modulus and $\\beta \\ge 0$ is a material nonlinearity parameter. The internal axial force is $f_{\\text{int}}(u) = A\\,\\sigma(\\varepsilon(u))$. Static equilibrium requires $f_{\\text{int}}(u) - P = 0$.\n\nYour task is to compare the convergence behavior of two iterative solution strategies for solving the scalar nonlinear equilibrium equation $r(u) = f_{\\text{int}}(u) - P = 0$:\n- Method $\\mathsf{CT}$ (“with Consistent Tangent”): the standard Newton–Raphson method using the consistent tangent stiffness, defined as the exact derivative of the residual with respect to the displacement, $k_{\\text{tan}}(u) = \\dfrac{d r(u)}{d u}$.\n- Method $\\mathsf{SEC}$ (“without Consistent Tangent”): a secant-stiffness quasi-Newton method that uses, at iteration $n \\ge 1$, the slope $s_{n} = \\dfrac{r(u_{n}) - r(u_{n-1})}{u_{n} - u_{n-1}}$ in place of the consistent tangent. For the very first update from an initial guess $u_{0}$, use the initial linear stiffness $K_{0} = \\left.\\dfrac{d r}{d u}\\right|_{u=0}$ to form a single-step prediction $u_{1} = u_{0} - r(u_{0})/K_{0}$.\n\nStart your derivation from the fundamental equilibrium statement (internal force equals external force), the given constitutive law, and the chain rule for differentiation. Do not assume any specialized formula beyond these bases. Derive:\n- The residual $r(u)$ in terms of $A$, $E$, $\\beta$, $L$, $u$, and $P$.\n- The consistent tangent stiffness $k_{\\text{tan}}(u)$ as the exact derivative $\\dfrac{d r}{d u}$.\n\nAdopt the following algorithmic definitions for both methods:\n- Initialization: use $u_{0} = 0$.\n- Convergence test: declare convergence when the absolute residual magnitude satisfies $\\lvert r(u_{n}) \\rvert \\le \\mathrm{tol}$, where $\\mathrm{tol} = 10^{-12}$.\n- Maximum number of iterations per method: $N_{\\max} = 50$. If the method has not converged within $N_{\\max}$ updates, report non-convergence.\n- Iteration counts: report the number of updates actually performed until convergence (or until reaching $N_{\\max}$). If the initial guess already satisfies the residual tolerance, the iteration count is $0$.\n\nThere are no physical units in this problem; treat all quantities as nondimensional.\n\nImplement a complete program that, for each test case, computes and returns:\n- The iteration count for method $\\mathsf{CT}$ (an integer).\n- The iteration count for method $\\mathsf{SEC}$ (an integer).\n- A boolean flag for method $\\mathsf{CT}$ indicating whether it converged within $N_{\\max}$.\n- A boolean flag for method $\\mathsf{SEC}$ indicating whether it converged within $N_{\\max}$.\n\nYour program must process the following test suite of parameter sets $(E, \\beta, A, L, P)$:\n- Test $1$: $(E, \\beta, A, L, P) = (1000, 0, 1, 1, 100)$.\n- Test $2$: $(E, \\beta, A, L, P) = (1000, 10^{5}, 1, 1, 100)$.\n- Test $3$: $(E, \\beta, A, L, P) = (1000, 10^{6}, 1, 1, 100)$.\n- Test $4$: $(E, \\beta, A, L, P) = (1000, 10^{6}, 1, 1, 0)$.\n\nYour program should produce a single line of output containing the aggregated results across all tests, formatted as a comma-separated list enclosed in square brackets. The results must be ordered by test case, and within each test case ordered as: $[\\text{iters}_{\\mathsf{CT}}, \\text{iters}_{\\mathsf{SEC}}, \\text{converged}_{\\mathsf{CT}}, \\text{converged}_{\\mathsf{SEC}}]$. Therefore, the final output should be a flat list:\n$[\\text{iters}_{\\mathsf{CT}}^{(1)}, \\text{iters}_{\\mathsf{SEC}}^{(1)}, \\text{converged}_{\\mathsf{CT}}^{(1)}, \\text{converged}_{\\mathsf{SEC}}^{(1)}, \\dots, \\text{iters}_{\\mathsf{CT}}^{(4)}, \\text{iters}_{\\mathsf{SEC}}^{(4)}, \\text{converged}_{\\mathsf{CT}}^{(4)}, \\text{converged}_{\\mathsf{SEC}}^{(4)}]$.\n\nYour output must exactly match this single-line format, with no extra spaces or text.", "solution": "The problem is valid. It is a well-defined exercise in computational mechanics, comparing the convergence of the standard Newton-Raphson method with a quasi-Newton (secant) method for a one-dimensional nonlinear problem. All necessary parameters, equations, and algorithmic definitions are provided, and the problem is scientifically sound.\n\nFirst, we derive the required mathematical expressions based on the problem statement.\n\nThe axial strain $\\varepsilon$ is related to the end displacement $u$ and the bar length $L$ by:\n$$ \\varepsilon(u) = \\frac{u}{L} $$\nThe material's stress-strain law is given as:\n$$ \\sigma(\\varepsilon) = E\\,\\varepsilon + \\beta\\,\\varepsilon^{3} $$\nwhere $E$ is the Young's modulus and $\\beta \\ge 0$ is a nonlinearity parameter.\n\nThe internal force $f_{\\text{int}}$ is the stress multiplied by the cross-sectional area $A$:\n$$ f_{\\text{int}}(u) = A\\,\\sigma(\\varepsilon(u)) $$\nBy substituting the expressions for strain and stress, we can express the internal force as a function of the displacement $u$:\n$$ f_{\\text{int}}(u) = A \\left[ E\\left(\\frac{u}{L}\\right) + \\beta\\left(\\frac{u}{L}\\right)^{3} \\right] = \\frac{AE}{L}u + \\frac{A\\beta}{L^3}u^3 $$\n\nThe residual function $r(u)$ represents the imbalance between the internal force and the externally applied force $P$. Static equilibrium requires $r(u) = 0$.\n$$ r(u) = f_{\\text{int}}(u) - P $$\nSubstituting the expression for $f_{\\text{int}}(u)$, we obtain the full expression for the residual:\n$$ r(u) = \\frac{AE}{L}u + \\frac{A\\beta}{L^3}u^3 - P $$\n\nNext, we derive the consistent tangent stiffness, $k_{\\text{tan}}(u)$, which is the exact derivative of the residual function with respect to the displacement $u$. This is required for the standard Newton-Raphson method (Method $\\mathsf{CT}$).\n$$ k_{\\text{tan}}(u) = \\frac{d r(u)}{d u} = \\frac{d}{du}\\left(\\frac{AE}{L}u + \\frac{A\\beta}{L^3}u^3 - P\\right) $$\nApplying the rules of differentiation, we find:\n$$ k_{\\text{an}}(u) = \\frac{AE}{L} \\cdot \\frac{d(u)}{du} + \\frac{A\\beta}{L^3} \\cdot \\frac{d(u^3)}{du} - \\frac{d(P)}{du} $$\nSince $P$ is a constant applied load, its derivative is zero.\n$$ k_{\\text{tan}}(u) = \\frac{AE}{L} + \\frac{A\\beta}{L^3}(3u^2) = \\frac{AE}{L} + \\frac{3A\\beta}{L^3}u^2 $$\nGiven that $A > 0$, $E > 0$, $L > 0$, and $\\beta \\ge 0$, the tangent stiffness $k_{\\text{tan}}(u)$ is always positive.\n\nNow, we outline the iterative algorithms. Both methods start with an initial guess $u_0 = 0$ and iterate until the residual magnitude is less than or equal to a tolerance, $\\lvert r(u_n) \\rvert \\le \\mathrm{tol} = 10^{-12}$, or until a maximum of $N_{\\max} = 50$ iterations is reached.\n\n**Method $\\mathsf{CT}$ (Newton-Raphson):**\nThe update rule for the displacement at iteration $n$ is:\n$$ u_{n+1} = u_n - \\frac{r(u_n)}{k_{\\text{tan}}(u_n)} $$\n1. Initialize $u_0 = 0$.\n2. Check if $\\lvert r(u_0) \\rvert \\le \\mathrm{tol}$. If so, stop (iterations = $0$).\n3. For $n = 0, 1, \\dots, N_{\\max}-1$:\n   a. Compute the update $\\Delta u_n = -r(u_n)/k_{\\text{tan}}(u_n)$.\n   b. Update the displacement: $u_{n+1} = u_n + \\Delta u_n$.\n   c. Check if $\\lvert r(u_{n+1}) \\rvert \\le \\mathrm{tol}$. If so, stop. The iteration count is $n+1$.\n4. If the loop completes without convergence, the method has failed.\n\n**Method $\\mathsf{SEC}$ (Secant Quasi-Newton):**\nThe update rule uses a secant stiffness $s_n$.\n$$ u_{n+1} = u_n - \\frac{r(u_n)}{s_n} $$\nwhere for $n \\ge 1$:\n$$ s_n = \\frac{r(u_n) - r(u_{n-1})}{u_n - u_{n-1}} $$\n1. Initialize $u_0 = 0$.\n2. Check if $\\lvert r(u_0) \\rvert \\le \\mathrm{tol}$. If so, stop (iterations = $0$).\n3. **First step (n=1):** The problem specifies using the initial linear stiffness for the first prediction. This is $K_0 = k_{\\text{tan}}(u_0) = k_{\\text{tan}}(0) = AE/L$.\n   $$ u_1 = u_0 - \\frac{r(u_0)}{K_0} $$\n   Check if $\\lvert r(u_1) \\rvert \\le \\mathrm{tol}$. If so, stop (iterations = $1$).\n4. **Subsequent steps (n > 1):** For $n = 1, 2, \\dots, N_{\\max}-2$:\n   a. Compute the secant stiffness $s_n$.\n   b. Compute the update $\\Delta u_n = -r(u_n)/s_n$.\n   c. Update displacement: $u_{n+1} = u_n + \\Delta u_n$.\n   d. Check if $\\lvert r(u_{n+1}) \\rvert \\le \\mathrm{tol}$. If so, stop. The iteration count is $n+1$.\n5. If the loop completes, the method has failed.\n\nA specific case to note is Test $4$, where the applied force is $P=0$. The equilibrium equation is $r(u) = (AE/L)u + (A\\beta/L^3)u^3 = 0$. The initial guess is $u_0 = 0$. Evaluating the residual at the initial guess gives $r(0) = 0$. Since $\\lvert r(0) \\rvert \\le \\mathrm{tol}$, both algorithms should terminate immediately with an iteration count of $0$, reporting convergence.\n\nThe implementation will follow these derivations and algorithmic steps to compute the required results for each test case.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Global constants as defined in the problem\nTOL = 1e-12\nN_MAX = 50\n\ndef solve_ct(params):\n    \"\"\"\n    Solves the nonlinear equilibrium equation using the standard Newton-Raphson \n    method with the consistent tangent stiffness (Method CT).\n\n    Args:\n        params (tuple): A tuple of floats (E, beta, A, L, P).\n\n    Returns:\n        tuple: A tuple containing the number of iterations (int) and a\n               convergence flag (bool).\n    \"\"\"\n    E, beta, A, L, P = params\n    \n    # Pre-calculate constants for efficiency\n    ae_l = A * E / L\n    ab_l3 = A * beta / (L**3)\n    a3b_l3 = 3.0 * A * beta / (L**3)\n\n    def residual(u):\n        return ae_l * u + ab_l3 * u**3 - P\n\n    def tangent_stiffness(u):\n        return ae_l + a3b_l3 * u**2\n\n    u = 0.0\n    res = residual(u)\n    \n    # Check if initial guess is already a solution\n    if abs(res) <= TOL:\n        return 0, True\n\n    for n in range(1, N_MAX + 1):\n        k_tan = tangent_stiffness(u)\n        \n        # k_tan is guaranteed to be positive for the given problem constraints\n        u = u - res / k_tan\n        res = residual(u)\n        \n        if abs(res) <= TOL:\n            return n, True\n            \n    return N_MAX, False\n\ndef solve_sec(params):\n    \"\"\"\n    Solves the nonlinear equilibrium equation using a secant-stiffness\n    quasi-Newton method (Method SEC).\n\n    Args:\n        params (tuple): A tuple of floats (E, beta, A, L, P).\n\n    Returns:\n        tuple: A tuple containing the number of iterations (int) and a\n               convergence flag (bool).\n    \"\"\"\n    E, beta, A, L, P = params\n\n    # Pre-calculate constants\n    ae_l = A * E / L\n    ab_l3 = A * beta / (L**3)\n    \n    def residual(u):\n        return ae_l * u + ab_l3 * u**3 - P\n\n    u_prev = 0.0\n    res_prev = residual(u_prev)\n\n    # Check if initial guess is already a solution\n    if abs(res_prev) <= TOL:\n        return 0, True\n\n    # First step (n=1) uses the initial linear stiffness K0\n    k0 = ae_l\n    if abs(k0) < 1e-15: # Protection against division by zero (not expected here)\n        return N_MAX, False\n        \n    u_curr = u_prev - res_prev / k0\n    res_curr = residual(u_curr)\n    \n    if abs(res_curr) <= TOL:\n        return 1, True\n\n    for n in range(2, N_MAX + 1):\n        du = u_curr - u_prev\n        \n        # Check for stagnation or division by zero\n        if abs(du) < 1e-15:\n            return n - 1, False # Stalled\n\n        s = (res_curr - res_prev) / du\n\n        if abs(s) < 1e-15:\n            return n - 1, False # Divergence or stall likely\n\n        u_next = u_curr - res_curr / s\n\n        # Update values for next iteration\n        u_prev, res_prev = u_curr, res_curr\n        u_curr = u_next\n        res_curr = residual(u_curr)\n\n        if abs(res_curr) <= TOL:\n            return n, True\n            \n    return N_MAX, False\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final result.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (E, beta, A, L, P)\n    test_cases = [\n        (1000.0, 0.0, 1.0, 1.0, 100.0),\n        (1000.0, 1e5, 1.0, 1.0, 100.0),\n        (1000.0, 1e6, 1.0, 1.0, 100.0),\n        (1000.0, 1e6, 1.0, 1.0, 0.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        iters_ct, conv_ct = solve_ct(case)\n        iters_sec, conv_sec = solve_sec(case)\n        \n        # Append results in the specified order\n        results.extend([iters_ct, iters_sec, conv_ct, conv_sec])\n\n    # Convert boolean to string 'True'/'False' as required for output\n    formatted_results = [str(r) for r in results]\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2547604"}, {"introduction": "The consistent tangent concept extends beyond hyperelasticity to history-dependent materials like those in plasticity. Here, the tangent is not merely the derivative of a potential but the exact linearization of the discrete, algorithmic update procedure for the material's internal state variables. This exercise guides you through the first-principles derivation of the \"algorithmic tangent modulus\" for a classic one-dimensional plasticity model, revealing the interplay between the elastic modulus $E$ and the hardening modulus $H$ [@problem_id:2547573].", "problem": "Consider a one-dimensional small-strain rate-independent elastoplastic material with linear isotropic hardening, to be used as the constitutive model in a two-node bar element within the Finite Element Method (FEM). The elastic law is given by Hooke’s law $\\,\\sigma = E(\\varepsilon - \\varepsilon^{p})\\,$, where $\\,\\sigma\\,$ is the Cauchy stress, $\\,\\varepsilon\\,$ is the total strain, $\\,\\varepsilon^{p}\\,$ is the plastic strain, and $\\,E\\,$ is the Young’s modulus. The yield function adopts the von Mises form specialized to one dimension as $\\,f(\\sigma,\\kappa) = |\\sigma| - \\big(\\sigma_{y0} + H\\,\\kappa\\big)\\le 0\\,$, where $\\,\\sigma_{y0}\\,$ is the initial yield stress, $\\,H\\,$ is the (constant) isotropic hardening modulus, and $\\,\\kappa\\,$ is the accumulated plastic strain. The flow rule is associative and the hardening law is $\\,\\dot{\\kappa} = \\dot{\\gamma}\\,$, with the standard Kuhn–Tucker conditions for the plastic multiplier $\\,\\dot{\\gamma}\\,$.\n\nA backward Euler time discretization is used over the increment from step $\\,n\\,$ to step $\\,n+1\\,$ with known state $\\,(\\varepsilon^{p}_{n},\\kappa_{n})\\,$ and given total strain $\\,\\varepsilon_{n+1}\\,$. Assume a monotonic tensile loading over the increment so that $\\,\\sigma_{n+1} > 0\\,$, $\\,\\Delta\\gamma > 0\\,$ and $\\,f_{n+1}=0\\,$ (a plastic step).\n\nStarting strictly from the above constitutive definitions and the backward Euler discretization (no other specialized formulas may be assumed), derive the algorithmic consistent tangent modulus to be used in a Newton method, i.e., the quantity\n$$\n\\mathbb{C}_{\\text{alg}} := \\frac{\\partial \\sigma_{n+1}}{\\partial \\varepsilon_{n+1}} \\, ,\n$$\nfor this plastic step. Express your final answer solely in terms of $\\,E\\,$ and $\\,H\\,$. Provide the final expression (no case distinctions). Do not include units in the final boxed answer.", "solution": "The problem posed is valid, as it is a standard and well-defined exercise in the field of computational plasticity. It is scientifically grounded, internally consistent, and requires the derivation of a key quantity for the numerical solution of nonlinear solid mechanics problems. We proceed to the solution.\n\nThe objective is to derive the algorithmic consistent tangent modulus, defined as $\\mathbb{C}_{\\text{alg}} := \\frac{\\partial \\sigma_{n+1}}{\\partial \\varepsilon_{n+1}}$, for a one-dimensional elastoplastic model with linear isotropic hardening subjected to a plastic loading step. The derivation must start from the fundamental constitutive equations discretized using the backward Euler method.\n\nThe state at the end of the time increment, step $n+1$, is determined by the total strain $\\varepsilon_{n+1}$ and the known state at the beginning of the increment, $(\\varepsilon^{p}_{n}, \\kappa_{n})$. The problem assumes a plastic step under tensile loading, which implies the plastic multiplier increment $\\Delta\\gamma > 0$ and the yield condition is satisfied, $f_{n+1}=0$. The governing equations, integrated over the time step using a backward Euler scheme, form a system of nonlinear algebraic equations:\n\n$1$. Elastic stress-strain relation:\n$$\n\\sigma_{n+1} = E (\\varepsilon_{n+1} - \\varepsilon^{p}_{n+1})\n$$\n\n$2$. Plastic strain evolution (integrated flow rule): The flow rule is $\\dot{\\varepsilon}^{p} = \\dot{\\gamma} \\frac{\\partial f}{\\partial \\sigma}$. For the given yield function $f(\\sigma, \\kappa) = |\\sigma| - (\\sigma_{y0} + H\\kappa)$, the gradient is $\\frac{\\partial f}{\\partial \\sigma} = \\text{sgn}(\\sigma)$. Given the assumption of tensile loading, $\\sigma_{n+1} > 0$, so $\\text{sgn}(\\sigma_{n+1}) = 1$. The integrated flow rule becomes:\n$$\n\\varepsilon^{p}_{n+1} = \\varepsilon^{p}_{n} + \\Delta\\gamma \\, \\text{sgn}(\\sigma_{n+1}) = \\varepsilon^{p}_{n} + \\Delta\\gamma\n$$\n\n$3$. Hardening law evolution: The law is $\\dot{\\kappa} = \\dot{\\gamma}$. Its integrated form is:\n$$\n\\kappa_{n+1} = \\kappa_{n} + \\Delta\\gamma\n$$\n\n$4$. Yield (consistency) condition: $f_{n+1}=0$. With $\\sigma_{n+1}>0$, this is:\n$$\n|\\sigma_{n+1}| - (\\sigma_{y0} + H \\kappa_{n+1}) = \\sigma_{n+1} - (\\sigma_{y0} + H \\kappa_{n+1}) = 0\n$$\n\nThis system of four equations implicitly defines the final state variables $(\\sigma_{n+1}, \\varepsilon^{p}_{n+1}, \\kappa_{n+1}, \\Delta\\gamma)$ as functions of the driving variable $\\varepsilon_{n+1}$. The consistent tangent modulus is found by taking the total derivative of these equations with respect to $\\varepsilon_{n+1}$, recognizing that the variables at step $n$ are constants in this context.\n\nLet us differentiate the system of equations with respect to $\\varepsilon_{n+1}$:\n\n$1'$. From the elastic law:\n$$\n\\frac{\\partial \\sigma_{n+1}}{\\partial \\varepsilon_{n+1}} = E \\left( \\frac{\\partial \\varepsilon_{n+1}}{\\partial \\varepsilon_{n+1}} - \\frac{\\partial \\varepsilon^{p}_{n+1}}{\\partial \\varepsilon_{n+1}} \\right) = E \\left( 1 - \\frac{\\partial \\varepsilon^{p}_{n+1}}{\\partial \\varepsilon_{n+1}} \\right)\n$$\n\n$2'$. From the plastic strain evolution:\n$$\n\\frac{\\partial \\varepsilon^{p}_{n+1}}{\\partial \\varepsilon_{n+1}} = \\frac{\\partial}{\\partial \\varepsilon_{n+1}}(\\varepsilon^{p}_{n} + \\Delta\\gamma) = \\frac{\\partial (\\Delta\\gamma)}{\\partial \\varepsilon_{n+1}}\n$$\n\n$3'$. From the hardening law (this step is not strictly necessary for the final result but completes the system's linearization):\n$$\n\\frac{\\partial \\kappa_{n+1}}{\\partial \\varepsilon_{n+1}} = \\frac{\\partial}{\\partial \\varepsilon_{n+1}}(\\kappa_{n} + \\Delta\\gamma) = \\frac{\\partial (\\Delta\\gamma)}{\\partial \\varepsilon_{n+1}}\n$$\n\n$4'$. From the yield condition:\n$$\n\\frac{\\partial}{\\partial \\varepsilon_{n+1}} \\left( \\sigma_{n+1} - \\sigma_{y0} - H \\kappa_{n+1} \\right) = 0\n$$\nSubstituting the expression for $\\kappa_{n+1}$:\n$$\n\\frac{\\partial}{\\partial \\varepsilon_{n+1}} \\left( \\sigma_{n+1} - \\sigma_{y0} - H (\\kappa_{n} + \\Delta\\gamma) \\right) = 0\n$$\nPerforming the differentiation:\n$$\n\\frac{\\partial \\sigma_{n+1}}{\\partial \\varepsilon_{n+1}} - H \\frac{\\partial (\\Delta\\gamma)}{\\partial \\varepsilon_{n+1}} = 0\n$$\nThis last equation provides a direct relationship between the derivative of stress and the derivative of the plastic multiplier increment. We can write:\n$$\n\\frac{\\partial (\\Delta\\gamma)}{\\partial \\varepsilon_{n+1}} = \\frac{1}{H} \\frac{\\partial \\sigma_{n+1}}{\\partial \\varepsilon_{n+1}}\n$$\nNow, we construct a solvable system for $\\mathbb{C}_{\\text{alg}} = \\frac{\\partial \\sigma_{n+1}}{\\partial \\varepsilon_{n+1}}$.\nFrom equation $(2')$, we have $\\frac{\\partial \\varepsilon^{p}_{n+1}}{\\partial \\varepsilon_{n+1}} = \\frac{\\partial (\\Delta\\gamma)}{\\partial \\varepsilon_{n+1}}$. Substituting this into equation $(1')$ yields:\n$$\n\\frac{\\partial \\sigma_{n+1}}{\\partial \\varepsilon_{n+1}} = E \\left( 1 - \\frac{\\partial (\\Delta\\gamma)}{\\partial \\varepsilon_{n+1}} \\right)\n$$\nNext, substitute the expression for $\\frac{\\partial (\\Delta\\gamma)}{\\partial \\varepsilon_{n+1}}$ from the differentiated yield condition into this equation:\n$$\n\\frac{\\partial \\sigma_{n+1}}{\\partial \\varepsilon_{n+1}} = E \\left( 1 - \\frac{1}{H} \\frac{\\partial \\sigma_{n+1}}{\\partial \\varepsilon_{n+1}} \\right)\n$$\nWe now have a single equation for the unknown tangent modulus $\\mathbb{C}_{\\text{alg}} = \\frac{\\partial \\sigma_{n+1}}{\\partial \\varepsilon_{n+1}}$. Let us solve for it.\n$$\n\\mathbb{C}_{\\text{alg}} = E - \\frac{E}{H} \\mathbb{C}_{\\text{alg}}\n$$\n$$\n\\mathbb{C}_{\\text{alg}} + \\frac{E}{H} \\mathbb{C}_{\\text{alg}} = E\n$$\n$$\n\\mathbb{C}_{\\text{alg}} \\left( 1 + \\frac{E}{H} \\right) = E\n$$\n$$\n\\mathbb{C}_{\\text{alg}} \\left( \\frac{H+E}{H} \\right) = E\n$$\n$$\n\\mathbb{C}_{\\text{alg}} = E \\left( \\frac{H}{E+H} \\right)\n$$\nThus, the consistent tangent modulus for a plastic step is:\n$$\n\\mathbb{C}_{\\text{alg}} = \\frac{E H}{E+H}\n$$\nThis result is also known as the elastoplastic tangent modulus for this one-dimensional case. It correctly reflects the reduced stiffness of the material after yielding, as it is a harmonic mean of the elastic modulus $E$ and the hardening modulus $H$. For perfect plasticity ($H=0$), $\\mathbb{C}_{\\text{alg}}=0$, and for purely elastic behavior ($H \\to \\infty$ or no yielding), $\\mathbb{C}_{\\text{alg}} \\to E$.", "answer": "$$\n\\boxed{\\frac{E H}{E+H}}\n$$", "id": "2547573"}]}