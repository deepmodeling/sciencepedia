{"hands_on_practices": [{"introduction": "When deformations are large, the choice of reference configuration becomes critical. This practice explores two fundamental strain measures: the Green-Lagrange tensor $\\boldsymbol{E}$, defined on the initial (material) configuration, and the Euler-Almansi tensor $\\boldsymbol{e}$, defined on the final (spatial) configuration. By calculating both for a finite simple shear deformation, you will gain a concrete understanding of why these measures differ and how they relate, a crucial concept for interpreting results from nonlinear analyses [@problem_id:2573040].", "problem": "A two-dimensional continuum undergoes a homogeneous finite simple shear deformation described in the reference configuration by the mapping $\\boldsymbol{\\varphi}:\\mathbb{R}^{2}\\to\\mathbb{R}^{2}$, given by $x_{1}=X_{1}+\\gamma X_{2}$ and $x_{2}=X_{2}$, where $\\gamma\\in\\mathbb{R}$ is the shear parameter, $X_{i}$ are the material (reference) coordinates, and $x_{i}$ are the spatial (current) coordinates. Using the fundamental definitions of finite deformation kinematics, compute exactly the Green–Lagrange strain tensor $\\boldsymbol{E}$ and the Euler–Almansi strain tensor $\\boldsymbol{e}$ for this deformation. Then, starting from first principles, explain why these two strain measures differ for finite $\\gamma$, and show that they agree to first order in $\\gamma$ when linearized about $\\gamma=0$. Report your final result as the six independent entries $(E_{11},E_{12},E_{22},e_{11},e_{12},e_{22})$ collected into a single row matrix. No rounding is required, and no units are needed. Express the final answer as exact functions of $\\gamma$.", "solution": "The problem is subjected to rigorous validation.\n\nGivens are extracted verbatim:\n1.  Deformation mapping: $x_{1}=X_{1}+\\gamma X_{2}$ and $x_{2}=X_{2}$.\n2.  The mapping is $\\boldsymbol{\\varphi}:\\mathbb{R}^{2}\\to\\mathbb{R}^{2}$.\n3.  $\\gamma\\in\\mathbb{R}$ is the shear parameter.\n4.  $X_{i}$ are material (reference) coordinates.\n5.  $x_{i}$ are spatial (current) coordinates.\n6.  Objective 1: Compute the Green–Lagrange strain tensor $\\boldsymbol{E}$.\n7.  Objective 2: Compute the Euler–Almansi strain tensor $\\boldsymbol{e}$.\n8.  Objective 3: Explain why $\\boldsymbol{E}$ and $\\boldsymbol{e}$ differ for finite $\\gamma$.\n9.  Objective 4: Show that they agree to first order in $\\gamma$ when linearized about $\\gamma=0$.\n10. Reporting format: The six independent entries $(E_{11},E_{12},E_{22},e_{11},e_{12},e_{22})$ as a single row matrix.\n\nValidation assessment:\nThe problem is valid. It is a standard, fundamental exercise in finite deformation continuum mechanics. The premises are scientifically sound and mathematically consistent. The objectives are clear, and the problem is well-posed, admitting a unique solution derivable from first principles. It is free of ambiguity, subjective claims, or factual inaccuracies. The topic is directly relevant to large displacement and rotation kinematics.\n\nWe now proceed with the solution.\n\nThe fundamental quantity describing the local deformation is the deformation gradient tensor $\\boldsymbol{F}$, defined by its components $F_{ij} = \\frac{\\partial x_i}{\\partial X_j}$. Using the provided mapping $\\boldsymbol{\\varphi}$, we compute the components of $\\boldsymbol{F}$:\n$F_{11} = \\frac{\\partial x_{1}}{\\partial X_{1}} = \\frac{\\partial}{\\partial X_{1}}(X_{1} + \\gamma X_{2}) = 1$\n$F_{12} = \\frac{\\partial x_{1}}{\\partial X_{2}} = \\frac{\\partial}{\\partial X_{2}}(X_{1} + \\gamma X_{2}) = \\gamma$\n$F_{21} = \\frac{\\partial x_{2}}{\\partial X_{1}} = \\frac{\\partial}{\\partial X_{1}}(X_{2}) = 0$\n$F_{22} = \\frac{\\partial x_{2}}{\\partial X_{2}} = \\frac{\\partial}{\\partial X_{2}}(X_{2}) = 1$\n\nIn matrix form, the deformation gradient is:\n$$ \\boldsymbol{F} = \\begin{pmatrix} 1  \\gamma \\\\ 0  1 \\end{pmatrix} $$\n\nFirst, we compute the Green–Lagrange strain tensor $\\boldsymbol{E}$. This is a material strain measure, defined with respect to the reference configuration. Its definition is $\\boldsymbol{E} = \\frac{1}{2}(\\boldsymbol{C} - \\boldsymbol{I})$, where $\\boldsymbol{C} = \\boldsymbol{F}^T \\boldsymbol{F}$ is the right Cauchy–Green deformation tensor and $\\boldsymbol{I}$ is the identity tensor.\n\nWe compute $\\boldsymbol{C}$:\n$$ \\boldsymbol{C} = \\boldsymbol{F}^T \\boldsymbol{F} = \\begin{pmatrix} 1  0 \\\\ \\gamma  1 \\end{pmatrix} \\begin{pmatrix} 1  \\gamma \\\\ 0  1 \\end{pmatrix} = \\begin{pmatrix} 1  \\gamma \\\\ \\gamma  1 + \\gamma^{2} \\end{pmatrix} $$\nNow, we compute $\\boldsymbol{E}$:\n$$ \\boldsymbol{E} = \\frac{1}{2} (\\boldsymbol{C} - \\boldsymbol{I}) = \\frac{1}{2} \\left( \\begin{pmatrix} 1  \\gamma \\\\ \\gamma  1 + \\gamma^{2} \\end{pmatrix} - \\begin{pmatrix} 1  0 \\\\ 0  1 \\end{pmatrix} \\right) = \\frac{1}{2} \\begin{pmatrix} 0  \\gamma \\\\ \\gamma  \\gamma^{2} \\end{pmatrix} $$\nThe components of the Green–Lagrange strain tensor are:\n$E_{11} = 0$, $E_{12} = E_{21} = \\frac{\\gamma}{2}$, $E_{22} = \\frac{\\gamma^{2}}{2}$.\n\nNext, we compute the Euler–Almansi strain tensor $\\boldsymbol{e}$. This is a spatial strain measure, defined with respect to the current configuration. Its definition is $\\boldsymbol{e} = \\frac{1}{2}(\\boldsymbol{I} - \\boldsymbol{b}^{-1})$, where $\\boldsymbol{b} = \\boldsymbol{F} \\boldsymbol{F}^T$ is the left Cauchy–Green (or Finger) deformation tensor.\n\nWe compute $\\boldsymbol{b}$:\n$$ \\boldsymbol{b} = \\boldsymbol{F} \\boldsymbol{F}^T = \\begin{pmatrix} 1  \\gamma \\\\ 0  1 \\end{pmatrix} \\begin{pmatrix} 1  0 \\\\ \\gamma  1 \\end{pmatrix} = \\begin{pmatrix} 1 + \\gamma^{2}  \\gamma \\\\ \\gamma  1 \\end{pmatrix} $$\nTo find $\\boldsymbol{b}^{-1}$, we first compute the determinant: $\\det(\\boldsymbol{b}) = (1 + \\gamma^{2})(1) - (\\gamma)(\\gamma) = 1$. The inverse is:\n$$ \\boldsymbol{b}^{-1} = \\frac{1}{\\det(\\boldsymbol{b})} \\begin{pmatrix} 1  -\\gamma \\\\ -\\gamma  1 + \\gamma^{2} \\end{pmatrix} = \\begin{pmatrix} 1  -\\gamma \\\\ -\\gamma  1 + \\gamma^{2} \\end{pmatrix} $$\nNow, we compute $\\boldsymbol{e}$:\n$$ \\boldsymbol{e} = \\frac{1}{2} (\\boldsymbol{I} - \\boldsymbol{b}^{-1}) = \\frac{1}{2} \\left( \\begin{pmatrix} 1  0 \\\\ 0  1 \\end{pmatrix} - \\begin{pmatrix} 1  -\\gamma \\\\ -\\gamma  1 + \\gamma^{2} \\end{pmatrix} \\right) = \\frac{1}{2} \\begin{pmatrix} 0  \\gamma \\\\ \\gamma  -\\gamma^{2} \\end{pmatrix} $$\nThe components of the Euler–Almansi strain tensor are:\n$e_{11} = 0$, $e_{12} = e_{21} = \\frac{\\gamma}{2}$, $e_{22} = -\\frac{\\gamma^{2}}{2}$.\n\nThe reason for the difference between $\\boldsymbol{E}$ and $\\boldsymbol{e}$ for finite $\\gamma$ is fundamental to their definitions. $\\boldsymbol{E}$ is a Lagrangian quantity. It quantifies the change in squared length of a material line element $d\\boldsymbol{X}$ in the reference configuration: $ds^{2} - dS^{2} = 2 d\\boldsymbol{X}^T \\boldsymbol{E} d\\boldsymbol{X}$. In contrast, $\\boldsymbol{e}$ is an Eulerian quantity. It quantifies the same change in squared length, but with respect to the corresponding spatial line element $d\\boldsymbol{x}$ in the current configuration: $ds^{2} - dS^{2} = 2 d\\boldsymbol{x}^T \\boldsymbol{e} d\\boldsymbol{x}$. For finite deformations, the reference and current configurations are different, and mapping between them involves both stretching and rotation. The two tensors are related by the push-forward operation $\\boldsymbol{e} = (\\boldsymbol{F}^{-1})^T \\boldsymbol{E} \\boldsymbol{F}^{-1}$ or the pull-back operation $\\boldsymbol{E} = \\boldsymbol{F}^T \\boldsymbol{e} \\boldsymbol{F}$. As our calculation shows, for finite $\\gamma$, $\\boldsymbol{e} \\neq \\boldsymbol{E}$. Specifically, the components $E_{22}$ and $e_{22}$ differ by a sign and contain a term quadratic in $\\gamma$, which is a signature of finite strain effects. This term arises from the large displacement gradient components and represents the influence of rotational components of the deformation on the strain measure.\n\nFinally, we must show that $\\boldsymbol{E}$ and $\\boldsymbol{e}$ agree to first order in $\\gamma$ when linearized about $\\gamma=0$. This is equivalent to considering the case of infinitesimal strain, where $\\gamma \\ll 1$.\nThe Green–Lagrange strain tensor is:\n$$ \\boldsymbol{E} = \\begin{pmatrix} 0  \\frac{\\gamma}{2} \\\\ \\frac{\\gamma}{2}  \\frac{\\gamma^{2}}{2} \\end{pmatrix} $$\nLinearizing this by neglecting terms of order $\\mathcal{O}(\\gamma^{2})$ and higher gives:\n$$ \\boldsymbol{E}_{\\text{lin}} = \\begin{pmatrix} 0  \\frac{\\gamma}{2} \\\\ \\frac{\\gamma}{2}  0 \\end{pmatrix} $$\nThe Euler–Almansi strain tensor is:\n$$ \\boldsymbol{e} = \\begin{pmatrix} 0  \\frac{\\gamma}{2} \\\\ \\frac{\\gamma}{2}  -\\frac{\\gamma^{2}}{2} \\end{pmatrix} $$\nSimilarly, linearizing this by neglecting terms of order $\\mathcal{O}(\\gamma^{2})$ and higher gives:\n$$ \\boldsymbol{e}_{\\text{lin}} = \\begin{pmatrix} 0  \\frac{\\gamma}{2} \\\\ \\frac{\\gamma}{2}  0 \\end{pmatrix} $$\nBoth tensors reduce to the same expression, which is the classical infinitesimal strain tensor $\\boldsymbol{\\epsilon}$. This is a general principle: for infinitesimal deformations, the distinction between the Lagrangian and Eulerian descriptions vanishes, and all valid strain measures converge to the unique infinitesimal strain tensor. Our results confirm this principle for the specific case of simple shear.\n\nThe six requested independent entries $(E_{11}, E_{12}, E_{22}, e_{11}, e_{12}, e_{22})$ are collected into a single row matrix.\n$E_{11} = 0$\n$E_{12} = \\frac{\\gamma}{2}$\n$E_{22} = \\frac{\\gamma^{2}}{2}$\n$e_{11} = 0$\n$e_{12} = \\frac{\\gamma}{2}$\n$e_{22} = -\\frac{\\gamma^{2}}{2}$\nThe resulting matrix is presented in the final answer.", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n0  \\frac{\\gamma}{2}  \\frac{\\gamma^{2}}{2}  0  \\frac{\\gamma}{2}  -\\frac{\\gamma^{2}}{2}\n\\end{pmatrix}\n}\n$$", "id": "2573040"}, {"introduction": "A general deformation consists of both stretching and a rigid rotation, and separating these two effects is a cornerstone of continuum mechanics. The polar decomposition theorem provides the mathematical tool to do this, expressing the deformation gradient $\\boldsymbol{F}$ as a product of a rotation tensor $\\boldsymbol{R}$ and a stretch tensor $\\boldsymbol{U}$. This exercise will guide you through the decomposition for a simple shear case, revealing the non-intuitive rigid rotation that accompanies this seemingly pure shear motion [@problem_id:2573030].", "problem": "Consider a planar simple shear deformation of a continuous body described by the motion $\\boldsymbol{\\varphi}:\\mathbb{R}^{2}\\to\\mathbb{R}^{2}$ given in Cartesian coordinates by\n$$\nx_{1} = X_{1} + \\gamma X_{2}, \\quad x_{2} = X_{2},\n$$\nwhere $\\gamma \\in \\mathbb{R}$ is a prescribed shear parameter, $\\boldsymbol{X} = (X_{1},X_{2})$ are the reference coordinates, and $\\boldsymbol{x} = (x_{1},x_{2})$ are the current coordinates. Let $\\boldsymbol{F} = \\nabla_{\\! \\boldsymbol{X}} \\boldsymbol{\\varphi}$ be the deformation gradient. Use the right polar decomposition to write $\\boldsymbol{F} = \\boldsymbol{R}\\boldsymbol{U}$, where $\\boldsymbol{R}$ is a proper orthogonal rotation tensor and $\\boldsymbol{U}$ is a symmetric positive-definite right stretch tensor. Starting only from the kinematic definitions $\\boldsymbol{F} = \\partial \\boldsymbol{\\varphi}/\\partial \\boldsymbol{X}$ and $\\boldsymbol{C} = \\boldsymbol{F}^{\\mathsf{T}}\\boldsymbol{F} = \\boldsymbol{U}^{2}$, derive explicit closed-form expressions for $\\boldsymbol{R}$ and $\\boldsymbol{U}$ in terms of $\\gamma$, and identify the shear-induced rigid-body rotation angle $\\phi$ associated with $\\boldsymbol{R}$. Assume the physically relevant branch in which $\\phi(\\gamma)$ varies continuously with $\\phi(0) = 0$. Provide as your final answer the rotation angle $\\phi(\\gamma)$ in radians as a function of $\\gamma$. Do not include units in your final boxed answer.", "solution": "The problem as stated is scientifically grounded, well-posed, objective, and contains all necessary information for a unique solution. It is a standard problem in finite deformation kinematics. Therefore, I will proceed with the derivation.\n\nThe motion is given by the mapping $\\boldsymbol{\\varphi}(\\boldsymbol{X}) = \\boldsymbol{x}$, with components:\n$$\nx_{1} = X_{1} + \\gamma X_{2}\n$$\n$$\nx_{2} = X_{2}\n$$\nThe deformation gradient tensor $\\boldsymbol{F}$ is defined as $\\boldsymbol{F} = \\frac{\\partial \\boldsymbol{x}}{\\partial \\boldsymbol{X}}$, with components $F_{ij} = \\frac{\\partial x_{i}}{\\partial X_{j}}$. We compute the components of $\\boldsymbol{F}$:\n$$\nF_{11} = \\frac{\\partial x_{1}}{\\partial X_{1}} = \\frac{\\partial}{\\partial X_{1}}(X_{1} + \\gamma X_{2}) = 1\n$$\n$$\nF_{12} = \\frac{\\partial x_{1}}{\\partial X_{2}} = \\frac{\\partial}{\\partial X_{2}}(X_{1} + \\gamma X_{2}) = \\gamma\n$$\n$$\nF_{21} = \\frac{\\partial x_{2}}{\\partial X_{1}} = \\frac{\\partial}{\\partial X_{1}}(X_{2}) = 0\n$$\n$$\nF_{22} = \\frac{\\partial x_{2}}{\\partial X_{2}} = \\frac{\\partial}{\\partial X_{2}}(X_{2}) = 1\n$$\nIn matrix form, the deformation gradient is:\n$$\n\\boldsymbol{F} = \\begin{pmatrix} 1  \\gamma \\\\ 0  1 \\end{pmatrix}\n$$\nThe right Cauchy-Green deformation tensor $\\boldsymbol{C}$ is defined as $\\boldsymbol{C} = \\boldsymbol{F}^{\\mathsf{T}}\\boldsymbol{F}$. We calculate $\\boldsymbol{C}$:\n$$\n\\boldsymbol{C} = \\begin{pmatrix} 1  0 \\\\ \\gamma  1 \\end{pmatrix} \\begin{pmatrix} 1  \\gamma \\\\ 0  1 \\end{pmatrix} = \\begin{pmatrix} (1)(1)+(0)(0)  (1)(\\gamma)+(0)(1) \\\\ (\\gamma)(1)+(1)(0)  (\\gamma)(\\gamma)+(1)(1) \\end{pmatrix} = \\begin{pmatrix} 1  \\gamma \\\\ \\gamma  1+\\gamma^{2} \\end{pmatrix}\n$$\nThe right polar decomposition is $\\boldsymbol{F} = \\boldsymbol{R}\\boldsymbol{U}$, where $\\boldsymbol{U}$ is the right stretch tensor, given by the unique positive-definite square root of $\\boldsymbol{C}$, i.e., $\\boldsymbol{U} = \\sqrt{\\boldsymbol{C}}$. For a $2 \\times 2$ symmetric positive-definite matrix $\\boldsymbol{A}$, its square root is given by the formula:\n$$\n\\sqrt{\\boldsymbol{A}} = \\frac{1}{\\sqrt{\\operatorname{tr}(\\boldsymbol{A}) + 2\\sqrt{\\det(\\boldsymbol{A})}}} (\\boldsymbol{A} + \\sqrt{\\det(\\boldsymbol{A})}\\boldsymbol{I})\n$$\nFor our tensor $\\boldsymbol{C}$, we have $\\operatorname{tr}(\\boldsymbol{C}) = 1 + (1+\\gamma^{2}) = 2+\\gamma^{2}$ and $\\det(\\boldsymbol{C}) = (1)(1+\\gamma^{2}) - (\\gamma)(\\gamma) = 1$.\nSubstituting these into the formula for $\\boldsymbol{U} = \\sqrt{\\boldsymbol{C}}$:\n$$\n\\boldsymbol{U} = \\frac{1}{\\sqrt{(2+\\gamma^{2}) + 2\\sqrt{1}}} \\left( \\boldsymbol{C} + \\sqrt{1}\\boldsymbol{I} \\right) = \\frac{1}{\\sqrt{4+\\gamma^{2}}} (\\boldsymbol{C} + \\boldsymbol{I})\n$$\n$$\n\\boldsymbol{U} = \\frac{1}{\\sqrt{4+\\gamma^{2}}} \\left( \\begin{pmatrix} 1  \\gamma \\\\ \\gamma  1+\\gamma^{2} \\end{pmatrix} + \\begin{pmatrix} 1  0 \\\\ 0  1 \\end{pmatrix} \\right) = \\frac{1}{\\sqrt{4+\\gamma^{2}}} \\begin{pmatrix} 2  \\gamma \\\\ \\gamma  2+\\gamma^{2} \\end{pmatrix}\n$$\nThis is the explicit expression for the right stretch tensor $\\boldsymbol{U}$.\n\nNext, we find the rotation tensor $\\boldsymbol{R}$ from the relation $\\boldsymbol{R} = \\boldsymbol{F}\\boldsymbol{U}^{-1}$. First, we compute the inverse of $\\boldsymbol{U}$. Since $\\det(\\boldsymbol{U}) = \\det(\\sqrt{\\boldsymbol{C}}) = \\sqrt{\\det(\\boldsymbol{C})} = 1$, we can use the formula for the inverse of a $2 \\times 2$ matrix with determinant $1$:\n$$\n\\boldsymbol{U}^{-1} = \\frac{1}{\\sqrt{4+\\gamma^{2}}} \\begin{pmatrix} 2+\\gamma^{2}  -\\gamma \\\\ -\\gamma  2 \\end{pmatrix}\n$$\nNow we compute $\\boldsymbol{R}$:\n$$\n\\boldsymbol{R} = \\boldsymbol{F}\\boldsymbol{U}^{-1} = \\begin{pmatrix} 1  \\gamma \\\\ 0  1 \\end{pmatrix} \\frac{1}{\\sqrt{4+\\gamma^{2}}} \\begin{pmatrix} 2+\\gamma^{2}  -\\gamma \\\\ -\\gamma  2 \\end{pmatrix}\n$$\n$$\n\\boldsymbol{R} = \\frac{1}{\\sqrt{4+\\gamma^{2}}} \\begin{pmatrix} (1)(2+\\gamma^{2})+(\\gamma)(-\\gamma)  (1)(-\\gamma)+(\\gamma)(2) \\\\ (0)(2+\\gamma^{2})+(1)(-\\gamma)  (0)(-\\gamma)+(1)(2) \\end{pmatrix}\n$$\n$$\n\\boldsymbol{R} = \\frac{1}{\\sqrt{4+\\gamma^{2}}} \\begin{pmatrix} 2+\\gamma^{2}-\\gamma^{2}  -\\gamma+2\\gamma \\\\ -\\gamma  2 \\end{pmatrix} = \\frac{1}{\\sqrt{4+\\gamma^{2}}} \\begin{pmatrix} 2  \\gamma \\\\ -\\gamma  2 \\end{pmatrix}\n$$\nThis is the explicit expression for the proper orthogonal rotation tensor $\\boldsymbol{R}$.\nA general 2D counter-clockwise rotation by an angle $\\phi$ is represented by the matrix:\n$$\n\\boldsymbol{R}(\\phi) = \\begin{pmatrix} \\cos\\phi  -\\sin\\phi \\\\ \\sin\\phi  \\cos\\phi \\end{pmatrix}\n$$\nBy comparing the components of our computed $\\boldsymbol{R}$ with this standard form, we can identify $\\phi$:\n$$\n\\cos\\phi = \\frac{2}{\\sqrt{4+\\gamma^{2}}}\n$$\n$$\n\\sin\\phi = \\frac{-\\gamma}{\\sqrt{4+\\gamma^{2}}}\n$$\nTo find $\\phi$, we can compute the tangent:\n$$\n\\tan\\phi = \\frac{\\sin\\phi}{\\cos\\phi} = \\frac{-\\gamma/\\sqrt{4+\\gamma^{2}}}{2/\\sqrt{4+\\gamma^{2}}} = -\\frac{\\gamma}{2}\n$$\nThis gives the rotation angle $\\phi$ as a function of the shear parameter $\\gamma$:\n$$\n\\phi(\\gamma) = \\arctan\\left(-\\frac{\\gamma}{2}\\right)\n$$\nUsing the property that $\\arctan(-x) = -\\arctan(x)$, we can write this as:\n$$\n\\phi(\\gamma) = -\\arctan\\left(\\frac{\\gamma}{2}\\right)\n$$\nWe must verify this solution against the given physical constraint that $\\phi(\\gamma)$ varies continuously with $\\phi(0) = 0$. The function $\\phi(\\gamma) = -\\arctan(\\gamma/2)$ is continuous for all $\\gamma \\in \\mathbb{R}$. At $\\gamma=0$, we have $\\phi(0) = -\\arctan(0) = 0$. The condition is satisfied. This expression thus represents the physically relevant rotation angle. The negative sign indicates that for a positive shear $\\gamma > 0$, the induced rigid-body rotation is clockwise.", "answer": "$$\\boxed{-\\arctan\\left(\\frac{\\gamma}{2}\\right)}$$", "id": "2573030"}, {"introduction": "Moving from static kinematics to dynamic simulations requires robustly tracking rotations over many time steps. Direct multiplication of incremental rotation matrices can lead to numerical drift, where the accumulated matrix no longer represents a pure rotation. This computational practice challenges you to implement and compare two popular rotational update schemes—one based on unit quaternions and another on matrix exponentials—to investigate their long-term stability and accuracy. This exercise highlights the practical numerical considerations essential for developing reliable finite element codes for large rotation problems [@problem_id:2573012].", "problem": "Implement a program that compares two rotation update schemes for large displacement and rotation kinematics in three dimensions. The two schemes are: (i) a unit-quaternion composition update with per-step re-normalization, and (ii) a rotation-matrix update using the matrix exponential of the per-step rotation vector without any re-orthonormalization during accumulation. The aim is to evaluate numerical stability and accuracy of both schemes over many incremental updates.\n\nYou must start from the following fundamental bases:\n- The rigid rotation kinematics is represented by a proper orthogonal matrix $R \\in \\mathrm{SO}(3)$ with $R^{\\mathsf{T}} R = I$ and $\\det(R) = 1$.\n- A small incremental rotation can be represented by a rotation vector $\\boldsymbol{\\varphi} \\in \\mathbb{R}^3$ whose norm is the rotation angle in radians, and whose direction is the rotation axis.\n- The matrix exponential of the skew-symmetric matrix $[\\boldsymbol{\\varphi}]_{\\times}$ maps the rotation vector $\\boldsymbol{\\varphi}$ to $R = \\exp\\left([\\boldsymbol{\\varphi}]_{\\times}\\right)$.\n- A unit quaternion $q \\in \\mathbb{R}^4$ with unit norm represents a rotation in $\\mathrm{SO}(3)$, and quaternion multiplication composes rotations; normalization of $q$ maintains unit length.\n\nTask requirements:\n1. Implement a function that, given a per-step rotation vector $\\boldsymbol{\\varphi}_k$ in radians, constructs the associated unit quaternion increment and composes it with the current quaternion. After each composition, re-normalize the quaternion. Initialize with the identity quaternion. At the end, convert the quaternion to a rotation matrix $R_{\\mathrm{quat}}$.\n2. Implement a function that, given the same per-step rotation vector $\\boldsymbol{\\varphi}_k$, constructs the corresponding incremental rotation matrix using the matrix exponential $\\exp\\left([\\boldsymbol{\\varphi}_k]_{\\times}\\right)$ (use a numerically stable formulation for small angles), and left-multiplies it to the current rotation matrix without any re-orthonormalization. Initialize with the identity matrix. At the end, denote the accumulated matrix as $R_{\\mathrm{mat}}$.\n3. For each test case specified below, compute the following quantitative diagnostics:\n   - Orthogonality error for each method: $e_{\\mathrm{orth}}(R) = \\left\\|R^{\\mathsf{T}} R - I\\right\\|_F$.\n   - Determinant deviation for each method: $e_{\\det}(R) = \\left|\\det(R) - 1\\right|$.\n   - Rotation angle error with respect to a reference rotation matrix $R_{\\mathrm{ref}}$: $e_{\\angle}(R, R_{\\mathrm{ref}}) = \\arccos\\!\\left(\\mathrm{clip}\\left(\\dfrac{\\mathrm{tr}\\left(R^{\\mathsf{T}} R_{\\mathrm{ref}}\\right) - 1}{2}, -1, 1\\right)\\right)$, expressed in radians.\n4. Reference rotation $R_{\\mathrm{ref}}$:\n   - For test cases where the per-step rotation vector is constant, the exact reference is $R_{\\mathrm{ref}} = \\exp\\left([\\boldsymbol{\\varphi}_{\\text{step}}]_{\\times} \\, N\\right)$, since the exponentials commute when the incremental rotation vector is constant. Here, $N$ is the number of steps.\n   - For test cases where the per-step rotation vector varies with the step index, define $R_{\\mathrm{ref}}$ as the orthogonal projection onto $\\mathrm{SO}(3)$ (via the polar decomposition using singular value decomposition) of the exact product $\\prod_{k=1}^{N} \\exp\\left([\\boldsymbol{\\varphi}_k]_{\\times}\\right)$ computed in finite precision. This defines a stable reference without in-step re-orthonormalization.\n\nAngle unit requirement:\n- All angles and rotation vectors must be treated in radians. All reported angle errors must be expressed in radians.\n\nTest suite:\nUse the following four test cases. For each case, the per-step rotation vector is given in radians, and $N$ is the number of steps.\n- Test $1$ (constant increments, multi-axis):\n  - $\\boldsymbol{\\varphi}_{\\text{step}} = [\\,0.001,\\,-0.002,\\,0.0015\\,]$, $N = 10000$.\n  - Reference: $R_{\\mathrm{ref}} = \\exp\\left([\\boldsymbol{\\varphi}_{\\text{step}}]_{\\times} \\, N\\right)$.\n- Test $2$ (constant increments, single-axis, moderate step size):\n  - $\\boldsymbol{\\varphi}_{\\text{step}} = [\\,0.01,\\,0.0,\\,0.0\\,]$, $N = 3000$.\n  - Reference: $R_{\\mathrm{ref}} = \\exp\\left([\\boldsymbol{\\varphi}_{\\text{step}}]_{\\times} \\, N\\right)$.\n- Test $3$ (time-varying increments, non-commutative accumulation):\n  - For $k = 0,1,\\dots,N-1$ with $N=8000$, define $\\boldsymbol{\\varphi}_k = s \\,[\\,\\cos(\\alpha k),\\, \\sin(\\alpha k),\\, 0.5\\,]$ with $s = 0.002$ and $\\alpha = 0.005$.\n  - Reference: Let $\\widehat{R} = \\prod_{k=0}^{N-1} \\exp\\left([\\boldsymbol{\\varphi}_k]_{\\times}\\right)$ and define $R_{\\mathrm{ref}}$ as the closest rotation via polar decomposition of $\\widehat{R}$.\n- Test $4$ (near-zero increments, extreme small-angle robustness):\n  - $\\boldsymbol{\\varphi}_{\\text{step}} = [\\,10^{-12},\\, -2\\times 10^{-12},\\, 3\\times 10^{-12}\\,]$, $N = 1000$.\n  - Reference: $R_{\\mathrm{ref}} = \\exp\\left([\\boldsymbol{\\varphi}_{\\text{step}}]_{\\times} \\, N\\right)$.\n\nYour program must:\n- Implement numerically stable small-angle formulas for both quaternion increments and matrix exponentials to avoid division by zero for $\\|\\boldsymbol{\\varphi}\\| \\to 0$.\n- Produce for each test case the six diagnostics in the following order as floating-point numbers:\n  1. $e_{\\mathrm{orth}}(R_{\\mathrm{quat}})$\n  2. $e_{\\mathrm{orth}}(R_{\\mathrm{mat}})$\n  3. $e_{\\det}(R_{\\mathrm{quat}})$\n  4. $e_{\\det}(R_{\\mathrm{mat}})$\n  5. $e_{\\angle}(R_{\\mathrm{quat}}, R_{\\mathrm{ref}})$ in radians\n  6. $e_{\\angle}(R_{\\mathrm{mat}}, R_{\\mathrm{ref}})$ in radians\n\nFinal output format:\n- Your program should produce a single line of output containing the concatenated results for all four test cases as a comma-separated list enclosed in square brackets. The list must contain $24$ floating-point numbers in the order specified per test case and in the order of the tests $1$ through $4$ (for example, $[r_1,r_2,\\dots,r_{24}]$). No additional text must be printed.", "solution": "We base the construction on rigid rotation kinematics and the exponential map between the Lie algebra of skew-symmetric matrices and the Lie group of rotation matrices. A rotation matrix $R \\in \\mathrm{SO}(3)$ satisfies $R^{\\mathsf{T}}R = I$ and $\\det(R) = 1$. A rotation vector $\\boldsymbol{\\varphi} \\in \\mathbb{R}^3$ encodes a rotation by angle $\\theta = \\|\\boldsymbol{\\varphi}\\|$ about the unit axis $\\boldsymbol{u} = \\boldsymbol{\\varphi}/\\theta$ when $\\theta \\neq 0$. The associated skew-symmetric matrix is $[\\boldsymbol{\\varphi}]_{\\times}$, defined for $\\boldsymbol{\\varphi} = [\\varphi_1,\\varphi_2,\\varphi_3]^{\\mathsf{T}}$ by\n$$\n[\\boldsymbol{\\varphi}]_{\\times} =\n\\begin{bmatrix}\n0  -\\varphi_3  \\varphi_2\\\\\n\\varphi_3  0  -\\varphi_1\\\\\n-\\varphi_2  \\varphi_1  0\n\\end{bmatrix}.\n$$\nThe matrix exponential provides the update for a per-step rotation vector $\\boldsymbol{\\varphi}$ via\n$$\nR_{\\mathrm{inc}} = \\exp\\left([\\boldsymbol{\\varphi}]_{\\times}\\right)\n= I + \\frac{\\sin \\theta}{\\theta}[\\boldsymbol{\\varphi}]_{\\times}\n+ \\frac{1 - \\cos \\theta}{\\theta^2}[\\boldsymbol{\\varphi}]_{\\times}^2,\n$$\nwhere $I$ is the identity matrix and $\\theta = \\|\\boldsymbol{\\varphi}\\|$. This representation follows from Rodrigues' rotation formula. For small $\\theta$, we use series expansions to avoid division by zero:\n$$\n\\frac{\\sin \\theta}{\\theta} = 1 - \\frac{\\theta^2}{6} + \\frac{\\theta^4}{120} + \\mathcal{O}(\\theta^6), \\quad\n\\frac{1 - \\cos \\theta}{\\theta^2} = \\frac{1}{2} - \\frac{\\theta^2}{24} + \\frac{\\theta^4}{720} + \\mathcal{O}(\\theta^6).\n$$\nThe matrix-based accumulation without re-orthonormalization is then\n$$\nR_{k+1}^{\\mathrm{mat}} = R_{\\mathrm{inc}}(\\boldsymbol{\\varphi}_k) \\, R_k^{\\mathrm{mat}}, \\quad R_0^{\\mathrm{mat}} = I.\n$$\nDue to floating-point errors, repeated multiplication can drift away from $\\mathrm{SO}(3)$, causing $R^{\\mathsf{T}}R \\neq I$ and $\\det(R) \\neq 1$.\n\nAlternatively, a unit quaternion $q = [q_0,q_1,q_2,q_3]^{\\mathsf{T}}$ represents the same rotation with the constraint $\\|q\\|=1$, mapping to a rotation matrix through a smooth homomorphism. The quaternion increment associated with rotation vector $\\boldsymbol{\\varphi}$ is\n$$\nq_{\\mathrm{inc}} = \\begin{bmatrix}\n\\cos(\\theta/2)\\\\\n\\boldsymbol{u} \\, \\sin(\\theta/2)\n\\end{bmatrix}, \\quad \\theta = \\|\\boldsymbol{\\varphi}\\|, \\ \\boldsymbol{u} = \n\\begin{cases}\n\\boldsymbol{\\varphi}/\\theta,  \\theta \\neq 0,\\\\\n[0,0,0]^{\\mathsf{T}},  \\theta = 0,\n\\end{cases}\n$$\nwith the small-angle stabilization\n$$\n\\frac{\\sin(\\theta/2)}{\\theta} = \\frac{1}{2} - \\frac{\\theta^2}{48} + \\frac{\\theta^4}{3840} + \\mathcal{O}(\\theta^6).\n$$\nQuaternion composition of rotations corresponds to quaternion multiplication $\\otimes$. Accumulation proceeds as\n$$\nq_{k+1} = q_{\\mathrm{inc}}(\\boldsymbol{\\varphi}_k) \\otimes q_k, \\quad q_0 = [1,0,0,0]^{\\mathsf{T}},\n$$\nwith explicit normalization\n$$\nq_{k+1} \\leftarrow \\frac{q_{k+1}}{\\|q_{k+1}\\|},\n$$\nto mitigate floating-point drift. The final rotation matrix is $R_{\\mathrm{quat}} = \\mathcal{R}(q_N)$ where $\\mathcal{R}(\\cdot)$ is the quaternion-to-rotation mapping, which preserves orthogonality when $q$ is unit length.\n\nFor validation and stability assessment, we define the following diagnostics for any $3\\times 3$ matrix $R$:\n- Orthogonality error $e_{\\mathrm{orth}}(R) = \\|R^{\\mathsf{T}}R - I\\|_F$ (Frobenius norm).\n- Determinant deviation $e_{\\det}(R) = |\\det(R) - 1|$.\n- Rotation angle error relative to a reference $R_{\\mathrm{ref}}$:\n$$\ne_{\\angle}(R, R_{\\mathrm{ref}}) = \\arccos\\!\\left(\\mathrm{clip}\\left(\\frac{\\operatorname{tr}(R^{\\mathsf{T}} R_{\\mathrm{ref}}) - 1}{2}, \\,-1,\\, 1\\right)\\right),\n$$\nwhich yields the principal angle in radians of the relative rotation $\\Delta R = R^{\\mathsf{T}} R_{\\mathrm{ref}}$. Clipping ensures numerical robustness against round-off violating the domain of the inverse cosine.\n\nFor constant per-step increments $\\boldsymbol{\\varphi}_{\\text{step}}$, the exact reference is\n$$\nR_{\\mathrm{ref}} = \\exp\\left([\\boldsymbol{\\varphi}_{\\text{step}}]_{\\times} \\, N\\right),\n$$\nbecause $[\\boldsymbol{\\varphi}_{\\text{step}}]_{\\times}$ commutes with itself, and hence $\\left(\\exp\\left([\\boldsymbol{\\varphi}_{\\text{step}}]_{\\times}\\right)\\right)^N = \\exp\\left(N \\,[\\boldsymbol{\\varphi}_{\\text{step}}]_{\\times}\\right)$. For time-varying increments $\\boldsymbol{\\varphi}_k$, non-commutativity prevents a closed form. We therefore compute the product\n$$\n\\widehat{R} = \\prod_{k=0}^{N-1} \\exp\\left([\\boldsymbol{\\varphi}_k]_{\\times}\\right),\n$$\nand project it onto $\\mathrm{SO}(3)$ via the polar decomposition. Let $\\widehat{R} = U \\Sigma V^{\\mathsf{T}}$ be the singular value decomposition, then the closest rotation (in the Frobenius norm) is\n$$\nR_{\\mathrm{ref}} = U \\, \\operatorname{diag}(1,1,\\operatorname{sign}(\\det(UV^{\\mathsf{T}}))) \\, V^{\\mathsf{T}}.\n$$\n\nAlgorithmic design:\n1. Implement a robust function to map $\\boldsymbol{\\varphi}$ to $R_{\\mathrm{inc}}$ using the series expansions for $\\sin\\theta/\\theta$ and $(1-\\cos\\theta)/\\theta^2$ for small $\\theta$.\n2. Implement quaternion increment mapping using a robust evaluation of $\\sin(\\theta/2)/\\theta$ for small $\\theta$ and compose by quaternion multiplication, with normalization after each step.\n3. Simulate both accumulations for each test case to obtain $R_{\\mathrm{quat}}$ and $R_{\\mathrm{mat}}$.\n4. Build the reference $R_{\\mathrm{ref}}$:\n   - For constant cases: as a single exponential at $N \\boldsymbol{\\varphi}_{\\text{step}}$.\n   - For the varying case: as the polar factor of the direct product of exponentials.\n5. Compute the diagnostics $e_{\\mathrm{orth}}$, $e_{\\det}$, and $e_{\\angle}$ for both $R_{\\mathrm{quat}}$ and $R_{\\mathrm{mat}}$.\n6. Output the $24$ floating-point results in the specified order:\n   - For each test $i \\in \\{1,2,3,4\\}$, output\n     $[\\,e_{\\mathrm{orth}}(R_{\\mathrm{quat}}^{(i)}),\\ e_{\\mathrm{orth}}(R_{\\mathrm{mat}}^{(i)}),\\ e_{\\det}(R_{\\mathrm{quat}}^{(i)}),\\ e_{\\det}(R_{\\mathrm{mat}}^{(i)}),\\ e_{\\angle}(R_{\\mathrm{quat}}^{(i)}, R_{\\mathrm{ref}}^{(i)}),\\ e_{\\angle}(R_{\\mathrm{mat}}^{(i)}, R_{\\mathrm{ref}}^{(i)})\\,]$.\n   Concatenate the four sublists into a single list and print as a single line.\n\nExpected qualitative outcomes:\n- The quaternion method with per-step normalization should maintain $e_{\\mathrm{orth}}$ and $e_{\\det}$ near machine precision across all tests, demonstrating high numerical stability.\n- The matrix exponential accumulation without re-orthonormalization is expected to exhibit increasing $e_{\\mathrm{orth}}$ and $e_{\\det}$ with the number of steps, indicating drift from $\\mathrm{SO}(3)$.\n- The angle errors $e_{\\angle}$ for the quaternion method should generally be smaller or comparable to the matrix method across tests; differences become more pronounced with many steps or near singular configurations, such as long sequences or extremely small angles where stable series expansions are essential.\n\nAll angles must be expressed in radians. No physical units are involved besides the angle unit. The program must print exactly one line: a single list of $24$ floating-point numbers as specified, with no additional text.", "answer": "```python\nimport numpy as np\n\ndef skew(v):\n    \"\"\"Return the 3x3 skew-symmetric matrix of a 3-vector v.\"\"\"\n    vx, vy, vz = v\n    return np.array([[0.0, -vz,  vy],\n                     [vz,  0.0, -vx],\n                     [-vy, vx,  0.0]], dtype=float)\n\ndef safe_sinc(x):\n    \"\"\"Return sin(x)/x with a stable series near x=0.\"\"\"\n    ax = abs(x)\n    if ax  1e-8:\n        x2 = x*x\n        # 1 - x^2/6 + x^4/120\n        return 1.0 - x2/6.0 + x2*x2/120.0\n    return np.sin(x)/x\n\ndef safe_one_minus_cos_over_x2(x):\n    \"\"\"Return (1-cos(x))/x^2 with a stable series near x=0.\"\"\"\n    ax = abs(x)\n    if ax  1e-8:\n        x2 = x*x\n        # 1/2 - x^2/24 + x^4/720\n        return 0.5 - x2/24.0 + x2*x2/720.0\n    return (1.0 - np.cos(x))/(x*x)\n\ndef exp_rotvec(phi):\n    \"\"\"\n    Compute rotation matrix R = exp([phi]_x) using Rodrigues' formula with\n    stable small-angle handling.\n    \"\"\"\n    theta = np.linalg.norm(phi)\n    A = skew(phi)\n    if theta  1e-16:\n        # Very small, R ~ I + A\n        return np.eye(3) + A\n    a = safe_sinc(theta)\n    b = safe_one_minus_cos_over_x2(theta)\n    return np.eye(3) + a * A + b * (A @ A)\n\ndef quat_mul(p, q):\n    \"\"\"Hamilton product p ⊗ q for quaternions p=[w,x,y,z], q=[w,x,y,z].\"\"\"\n    pw, px, py, pz = p\n    qw, qx, qy, qz = q\n    w = pw*qw - px*qx - py*qy - pz*qz\n    x = pw*qx + px*qw + py*qz - pz*qy\n    y = pw*qy - px*qz + py*qw + pz*qx\n    z = pw*qz + px*qy - py*qx + pz*qw\n    return np.array([w, x, y, z], dtype=float)\n\ndef quat_normalize(q):\n    n = np.linalg.norm(q)\n    if n == 0.0:\n        return np.array([1.0, 0.0, 0.0, 0.0], dtype=float)\n    return q / n\n\ndef rotvec_to_quat(phi):\n    \"\"\"Map rotation vector phi to unit quaternion q = [w, x, y, z].\"\"\"\n    theta = np.linalg.norm(phi)\n    if theta  1e-16:\n        # q ≈ [1, 0.5*phi]\n        return quat_normalize(np.array([1.0, 0.5*phi[0], 0.5*phi[1], 0.5*phi[2]], dtype=float))\n    half = 0.5 * theta\n    # sin(half)/theta stabilized\n    s = np.sin(half)\n    c = np.cos(half)\n    scale = s / theta\n    q = np.array([c, scale*phi[0], scale*phi[1], scale*phi[2]], dtype=float)\n    return quat_normalize(q)\n\ndef quat_to_R(q):\n    \"\"\"Convert unit quaternion q=[w,x,y,z] to rotation matrix.\"\"\"\n    w, x, y, z = q\n    # Normalize to avoid drift\n    n = w*w + x*x + y*y + z*z\n    if n == 0.0:\n        w, x, y, z = 1.0, 0.0, 0.0, 0.0\n        n = 1.0\n    s = 2.0 / n\n    wx, wy, wz = s*w*x, s*w*y, s*w*z\n    xx, xy, xz = s*x*x, s*x*y, s*x*z\n    yy, yz, zz = s*y*y, s*y*z, s*z*z\n    R = np.array([\n        [1.0 - (yy + zz), xy - wz,       xz + wy      ],\n        [xy + wz,         1.0 - (xx + zz), yz - wx     ],\n        [xz - wy,         yz + wx,       1.0 - (xx + yy)]\n    ], dtype=float)\n    return R\n\ndef orthogonality_error(R):\n    E = R.T @ R - np.eye(3)\n    return float(np.linalg.norm(E, ord='fro'))\n\ndef det_deviation(R):\n    return float(abs(np.linalg.det(R) - 1.0))\n\ndef angle_error(R, Rref):\n    RtR = R.T @ Rref\n    tr = (np.trace(RtR) - 1.0) / 2.0\n    tr = max(-1.0, min(1.0, tr))\n    return float(np.arccos(tr))\n\ndef project_to_SO3(R):\n    \"\"\"Project a matrix to the nearest rotation matrix via SVD-based polar decomposition.\"\"\"\n    U, S, Vt = np.linalg.svd(R)\n    M = U @ Vt\n    if np.linalg.det(M)  0.0:\n        # Fix reflection\n        D = np.diag([1.0, 1.0, -1.0])\n        M = U @ D @ Vt\n    return M\n\ndef accumulate_quaternion(increments):\n    q = np.array([1.0, 0.0, 0.0, 0.0], dtype=float)\n    for phi in increments:\n        q_inc = rotvec_to_quat(phi)\n        q = quat_mul(q_inc, q)\n        q = quat_normalize(q)\n    return quat_to_R(q)\n\ndef accumulate_matrix(increments):\n    R = np.eye(3)\n    for phi in increments:\n        R = exp_rotvec(phi) @ R\n    return R\n\ndef reference_constant(phi_step, N):\n    phi_tot = phi_step * N\n    return exp_rotvec(phi_tot)\n\ndef reference_varying(increments):\n    R = np.eye(3)\n    for phi in increments:\n        R = exp_rotvec(phi) @ R\n    return project_to_SO3(R)\n\ndef build_test_cases():\n    tests = []\n\n    # Test 1: constant increments, multi-axis\n    phi_step1 = np.array([0.001, -0.002, 0.0015], dtype=float)\n    N1 = 10000\n    inc1 = [phi_step1 for _ in range(N1)]\n    Rref1 = reference_constant(phi_step1, N1)\n    tests.append((inc1, Rref1))\n\n    # Test 2: constant increments, single-axis\n    phi_step2 = np.array([0.01, 0.0, 0.0], dtype=float)\n    N2 = 3000\n    inc2 = [phi_step2 for _ in range(N2)]\n    Rref2 = reference_constant(phi_step2, N2)\n    tests.append((inc2, Rref2))\n\n    # Test 3: varying increments\n    N3 = 8000\n    s = 0.002\n    alpha = 0.005\n    inc3 = []\n    for k in range(N3):\n        vk = np.array([np.cos(alpha * k), np.sin(alpha * k), 0.5], dtype=float)\n        inc3.append(s * vk)\n    Rref3 = reference_varying(inc3)\n    tests.append((inc3, Rref3))\n\n    # Test 4: near-zero increments\n    phi_step4 = np.array([1e-12, -2e-12, 3e-12], dtype=float)\n    N4 = 1000\n    inc4 = [phi_step4 for _ in range(N4)]\n    Rref4 = reference_constant(phi_step4, N4)\n    tests.append((inc4, Rref4))\n\n    return tests\n\ndef solve():\n    tests = build_test_cases()\n    results = []\n    for increments, Rref in tests:\n        Rq = accumulate_quaternion(increments)\n        Rm = accumulate_matrix(increments)\n\n        e_orth_q = orthogonality_error(Rq)\n        e_orth_m = orthogonality_error(Rm)\n        e_det_q = det_deviation(Rq)\n        e_det_m = det_deviation(Rm)\n        e_ang_q = angle_error(Rq, Rref)\n        e_ang_m = angle_error(Rm, Rref)\n\n        results.extend([e_orth_q, e_orth_m, e_det_q, e_det_m, e_ang_q, e_ang_m])\n\n    # Print as a single line list, comma-separated, no spaces\n    # Format floats with scientific notation for consistency\n    formatted = \",\".join(f\"{x:.12e}\" for x in results)\n    print(f\"[{formatted}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2573012"}]}