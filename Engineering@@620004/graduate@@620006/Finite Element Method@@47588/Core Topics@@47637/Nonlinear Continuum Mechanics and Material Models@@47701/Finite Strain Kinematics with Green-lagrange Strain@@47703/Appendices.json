{"hands_on_practices": [{"introduction": "The analysis of simple shear provides a classic, foundational exercise in continuum mechanics. While the deformation itself appears straightforward, its description within finite strain theory reveals non-intuitive but crucial physical effects. This practice guides you through a step-by-step derivation of the kinematic tensors, starting from the deformation map to find the deformation gradient $\\mathbf{F}$, the right Cauchy-Green tensor $\\mathbf{C}$, and finally the Green-Lagrange strain tensor $\\mathbf{E}$, directly applying their fundamental definitions [@problem_id:2558923]. The goal is to uncover the nonlinear relationship between shear and normal strains that distinguishes finite strain from infinitesimal strain theories.", "problem": "Consider a homogeneous simple shear motion in a continuum body from a reference configuration with material coordinates $\\mathbf{X} = (X_{1}, X_{2}, X_{3})$ to a current configuration with spatial coordinates $\\mathbf{x} = (x_{1}, x_{2}, x_{3})$ given by the mapping\n$$\nx_{1} = X_{1} + \\kappa X_{2}, \\quad x_{2} = X_{2}, \\quad x_{3} = X_{3},\n$$\nwhere $\\kappa$ is a constant shear parameter. Starting strictly from the kinematic definitions of the deformation gradient, the right Cauchy–Green deformation tensor, and the Green–Lagrange strain tensor, derive the deformation gradient, then compute the right Cauchy–Green tensor $\\mathbf{C}$ and the Green–Lagrange strain tensor $\\mathbf{E}$. Identify the shear component $E_{12}$ and the normal components $E_{11}$, $E_{22}$, and $E_{33}$ of $\\mathbf{E}$ in terms of $\\kappa$.\n\nProvide your final answer as a single row vector containing the ordered entries\n$$\n\\big[C_{11},\\; C_{12},\\; C_{22},\\; C_{33},\\; E_{11},\\; E_{12},\\; E_{22},\\; E_{33}\\big],\n$$\nexpressed symbolically in terms of $\\kappa$. No numerical approximation is required, and no units are associated with these kinematic quantities.", "solution": "The problem statement will be validated before any attempt at a solution is made.\n\nFirst, I extract the givens:\n- Material coordinates: $\\mathbf{X} = (X_{1}, X_{2}, X_{3})$.\n- Spatial coordinates: $\\mathbf{x} = (x_{1}, x_{2}, x_{3})$.\n- Deformation mapping: $x_{1} = X_{1} + \\kappa X_{2}$, $x_{2} = X_{2}$, $x_{3} = X_{3}$.\n- The parameter $\\kappa$ is a constant.\n- The task is to derive the deformation gradient $\\mathbf{F}$, the right Cauchy–Green deformation tensor $\\mathbf{C}$, and the Green–Lagrange strain tensor $\\mathbf{E}$.\n- The final output must be a row vector of specific components: $\\big[C_{11},\\; C_{12},\\; C_{22},\\; C_{33},\\; E_{11},\\; E_{12},\\; E_{22},\\; E_{33}\\big]$.\n\nNext, I validate the problem.\nThe problem describes a homogeneous simple shear deformation, a standard and fundamental concept in finite strain continuum mechanics. The definitions requested for the deformation gradient $\\mathbf{F}$, the right Cauchy–Green tensor $\\mathbf{C}$, and the Green–Lagrange strain tensor $\\mathbf{E}$ are standard kinematic quantities. The problem is self-contained, mathematically consistent, scientifically grounded, and well-posed. It does not violate any physical laws, is free of ambiguity, and contains all necessary information for a unique solution. The problem is therefore deemed **valid**.\n\nThe solution proceeds by applying the definitions of the required kinematic tensors step-by-step.\n\nThe deformation gradient tensor $\\mathbf{F}$ relates an infinitesimal vector in the reference configuration, $d\\mathbf{X}$, to its corresponding vector in the current configuration, $d\\mathbf{x}$, through the relation $d\\mathbf{x} = \\mathbf{F} d\\mathbf{X}$. The components of $\\mathbf{F}$ are defined as $F_{ij} = \\frac{\\partial x_{i}}{\\partial X_{j}}$.\nUsing the given mapping, the components are calculated as follows for $i,j \\in \\{1, 2, 3\\}$:\n$F_{11} = \\frac{\\partial x_{1}}{\\partial X_{1}} = \\frac{\\partial}{\\partial X_{1}} (X_{1} + \\kappa X_{2}) = 1$\n$F_{12} = \\frac{\\partial x_{1}}{\\partial X_{2}} = \\frac{\\partial}{\\partial X_{2}} (X_{1} + \\kappa X_{2}) = \\kappa$\n$F_{13} = \\frac{\\partial x_{1}}{\\partial X_{3}} = \\frac{\\partial}{\\partial X_{3}} (X_{1} + \\kappa X_{2}) = 0$\n$F_{21} = \\frac{\\partial x_{2}}{\\partial X_{1}} = \\frac{\\partial}{\\partial X_{1}} (X_{2}) = 0$\n$F_{22} = \\frac{\\partial x_{2}}{\\partial X_{2}} = \\frac{\\partial}{\\partial X_{2}} (X_{2}) = 1$\n$F_{23} = \\frac{\\partial x_{2}}{\\partial X_{3}} = \\frac{\\partial}{\\partial X_{3}} (X_{2}) = 0$\n$F_{31} = \\frac{\\partial x_{3}}{\\partial X_{1}} = \\frac{\\partial}{\\partial X_{1}} (X_{3}) = 0$\n$F_{32} = \\frac{\\partial x_{3}}{\\partial X_{2}} = \\frac{\\partial}{\\partial X_{2}} (X_{3}) = 0$\n$F_{33} = \\frac{\\partial x_{3}}{\\partial X_{3}} = \\frac{\\partial}{\\partial X_{3}} (X_{3}) = 1$\n\nThe deformation gradient tensor in matrix form is:\n$$\n\\mathbf{F} = \\begin{pmatrix} 1 & \\kappa & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix}\n$$\n\nNext, the right Cauchy–Green deformation tensor $\\mathbf{C}$ is computed. It is defined as $\\mathbf{C} = \\mathbf{F}^{\\mathsf{T}}\\mathbf{F}$, where $\\mathbf{F}^{\\mathsf{T}}$ is the transpose of $\\mathbf{F}$.\n$$\n\\mathbf{F}^{\\mathsf{T}} = \\begin{pmatrix} 1 & 0 & 0 \\\\ \\kappa & 1 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix}\n$$\nPerforming the matrix multiplication:\n$$\n\\mathbf{C} = \\mathbf{F}^{\\mathsf{T}}\\mathbf{F} = \\begin{pmatrix} 1 & 0 & 0 \\\\ \\kappa & 1 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix} \\begin{pmatrix} 1 & \\kappa & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix} = \\begin{pmatrix} (1)(1) + (0)(0) + (0)(0) & (1)(\\kappa) + (0)(1) + (0)(0) & (1)(0) + (0)(0) + (0)(1) \\\\ (\\kappa)(1) + (1)(0) + (0)(0) & (\\kappa)(\\kappa) + (1)(1) + (0)(0) & (\\kappa)(0) + (1)(0) + (0)(1) \\\\ (0)(1) + (0)(0) + (1)(0) & (0)(\\kappa) + (0)(1) + (1)(0) & (0)(0) + (0)(0) + (1)(1) \\end{pmatrix}\n$$\n$$\n\\mathbf{C} = \\begin{pmatrix} 1 & \\kappa & 0 \\\\ \\kappa & 1 + \\kappa^{2} & 0 \\\\ 0 & 0 & 1 \\end{pmatrix}\n$$\nFrom this matrix, we identify the required components:\n$C_{11} = 1$\n$C_{12} = \\kappa$\n$C_{22} = 1 + \\kappa^{2}$\n$C_{33} = 1$\n\nFinally, the Green–Lagrange strain tensor $\\mathbf{E}$ is derived. It is defined as $\\mathbf{E} = \\frac{1}{2}(\\mathbf{C} - \\mathbf{I})$, where $\\mathbf{I}$ is the second-order identity tensor.\n$$\n\\mathbf{E} = \\frac{1}{2} \\left( \\begin{pmatrix} 1 & \\kappa & 0 \\\\ \\kappa & 1 + \\kappa^{2} & 0 \\\\ 0 & 0 & 1 \\end{pmatrix} - \\begin{pmatrix} 1 & 0 & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix} \\right) = \\frac{1}{2} \\begin{pmatrix} 0 & \\kappa & 0 \\\\ \\kappa & \\kappa^{2} & 0 \\\\ 0 & 0 & 0 \\end{pmatrix}\n$$\n$$\n\\mathbf{E} = \\begin{pmatrix} 0 & \\frac{\\kappa}{2} & 0 \\\\ \\frac{\\kappa}{2} & \\frac{\\kappa^{2}}{2} & 0 \\\\ 0 & 0 & 0 \\end{pmatrix}\n$$\nThe components of $\\mathbf{E}$ are:\n$E_{11} = 0$\n$E_{12} = \\frac{\\kappa}{2}$\n$E_{22} = \\frac{\\kappa^{2}}{2}$\n$E_{33} = 0$\n\nObserve that the simple shear deformation induces a non-zero normal strain component $E_{22} = \\frac{\\kappa^{2}}{2}$. This is a characteristic feature of finite strain theory, distinguishing it from infinitesimal strain theory where such second-order effects are neglected.\n\nThe final answer is constructed by assembling the required components into the specified row vector format.\nThe components are:\n$C_{11} = 1$\n$C_{12} = \\kappa$\n$C_{22} = 1 + \\kappa^{2}$\n$C_{33} = 1$\n$E_{11} = 0$\n$E_{12} = \\frac{\\kappa}{2}$\n$E_{22} = \\frac{\\kappa^{2}}{2}$\n$E_{33} = 0$\nThe row vector is $\\big[1,\\; \\kappa,\\; 1+\\kappa^{2},\\; 1,\\; 0,\\; \\frac{\\kappa}{2},\\; \\frac{\\kappa^{2}}{2},\\; 0\\big]$.", "answer": "$$\n\\boxed{\\begin{pmatrix} 1 & \\kappa & 1+\\kappa^{2} & 1 & 0 & \\frac{\\kappa}{2} & \\frac{\\kappa^{2}}{2} & 0 \\end{pmatrix}}\n$$", "id": "2558923"}, {"introduction": "In engineering practice, the simplified \"infinitesimal\" or \"linearized\" strain tensor $\\boldsymbol{\\varepsilon}$ is often used. This raises a critical question: when is this simplification valid, and how large is the error when it is not? This practice addresses that question by quantitatively comparing the full Green-Lagrange strain tensor $\\mathbf{E}$ with its linearized counterpart $\\boldsymbol{\\varepsilon}$ for a simple shear deformation [@problem_id:2558928]. By calculating the difference for both small and large shear parameters, you will develop a concrete understanding of why finite strain measures are indispensable for accurately modeling problems involving large deformations.", "problem": "In the context of the Finite Element Method (FEM), consider a homogeneous planar deformation characterized by the deformation gradient $\\mathbf{F} \\in \\mathbb{R}^{2 \\times 2}$ given by\n$$\n\\mathbf{F} = \\begin{bmatrix} 1 & \\kappa \\\\ 0 & 1 \\end{bmatrix},\n$$\nwhere $\\kappa \\in \\mathbb{R}$ is a constant shear parameter. Using only fundamental definitions from finite strain kinematics, do the following:\n\n1. Starting from the right Cauchy–Green deformation tensor definition $\\mathbf{C} = \\mathbf{F}^{\\mathsf{T}} \\mathbf{F}$ and the Green–Lagrange strain definition $\\mathbf{E} = \\tfrac{1}{2}(\\mathbf{C} - \\mathbf{I})$, derive $\\mathbf{E}$ explicitly as a function of $\\kappa$.\n\n2. For the same mapping, define the displacement field by $\\mathbf{x} = \\mathbf{F} \\mathbf{X}$ so that the displacement gradient is $\\nabla_{\\mathbf{X}} \\mathbf{u} = \\mathbf{F} - \\mathbf{I}$. Using the linearized small-strain definition $\\boldsymbol{\\varepsilon} = \\tfrac{1}{2}(\\nabla_{\\mathbf{X}} \\mathbf{u} + (\\nabla_{\\mathbf{X}} \\mathbf{u})^{\\mathsf{T}})$, derive $\\boldsymbol{\\varepsilon}$ explicitly as a function of $\\kappa$.\n\n3. To quantify the difference between the finite-strain and linearized kinematics, let the comparison measure be the Frobenius norm of the difference,\n$$\ns(\\kappa) := \\| \\mathbf{E} - \\boldsymbol{\\varepsilon} \\|_F.\n$$\nEvaluate $s(\\kappa)$ for $\\kappa = 0.2$ and $\\kappa = 1$. Strain is dimensionless, so report the two values as dimensionless numbers.\n\nProvide your final answer as a single row matrix in the form $\\begin{pmatrix} s(0.2) & s(1) \\end{pmatrix}$. Do not include units. No rounding is required; give exact decimal values.", "solution": "We begin from the fundamental kinematic definitions in finite strain theory.\n\n1. Compute the Green–Lagrange strain $\\mathbf{E}$.\n- The right Cauchy–Green deformation tensor is defined by $\\mathbf{C} = \\mathbf{F}^{\\mathsf{T}} \\mathbf{F}$. For\n$$\n\\mathbf{F} = \\begin{bmatrix} 1 & \\kappa \\\\ 0 & 1 \\end{bmatrix},\n$$\nwe have\n$$\n\\mathbf{F}^{\\mathsf{T}} = \\begin{bmatrix} 1 & 0 \\\\ \\kappa & 1 \\end{bmatrix},\n\\quad\n\\mathbf{C} = \\mathbf{F}^{\\mathsf{T}} \\mathbf{F} = \\begin{bmatrix} 1 & 0 \\\\ \\kappa & 1 \\end{bmatrix} \\begin{bmatrix} 1 & \\kappa \\\\ 0 & 1 \\end{bmatrix}\n= \\begin{bmatrix} 1 & \\kappa \\\\ \\kappa & \\kappa^{2} + 1 \\end{bmatrix}.\n$$\n- The Green–Lagrange strain is $\\mathbf{E} = \\tfrac{1}{2}(\\mathbf{C} - \\mathbf{I})$, hence\n$$\n\\mathbf{E} = \\tfrac{1}{2} \\left( \\begin{bmatrix} 1 & \\kappa \\\\ \\kappa & \\kappa^{2} + 1 \\end{bmatrix} - \\begin{bmatrix} 1 & 0 \\\\ 0 & 1 \\end{bmatrix} \\right)\n= \\tfrac{1}{2} \\begin{bmatrix} 0 & \\kappa \\\\ \\kappa & \\kappa^{2} \\end{bmatrix}.\n$$\n\n2. Compute the linearized small strain $\\boldsymbol{\\varepsilon}$.\n- For a homogeneous deformation $\\mathbf{x} = \\mathbf{F} \\mathbf{X}$, the displacement is $\\mathbf{u} = \\mathbf{x} - \\mathbf{X} = (\\mathbf{F} - \\mathbf{I}) \\mathbf{X}$, so the displacement gradient with respect to the reference configuration is $\\nabla_{\\mathbf{X}} \\mathbf{u} = \\mathbf{F} - \\mathbf{I}$.\n- With $\\mathbf{F} = \\begin{bmatrix} 1 & \\kappa \\\\ 0 & 1 \\end{bmatrix}$, we have\n$$\n\\nabla_{\\mathbf{X}} \\mathbf{u} = \\mathbf{F} - \\mathbf{I} = \\begin{bmatrix} 0 & \\kappa \\\\ 0 & 0 \\end{bmatrix}.\n$$\n- The linearized small strain tensor is $\\boldsymbol{\\varepsilon} = \\tfrac{1}{2}(\\nabla_{\\mathbf{X}} \\mathbf{u} + (\\nabla_{\\mathbf{X}} \\mathbf{u})^{\\mathsf{T}})$, so\n$$\n\\boldsymbol{\\varepsilon} = \\tfrac{1}{2} \\left( \\begin{bmatrix} 0 & \\kappa \\\\ 0 & 0 \\end{bmatrix} + \\begin{bmatrix} 0 & 0 \\\\ \\kappa & 0 \\end{bmatrix} \\right)\n= \\tfrac{1}{2} \\begin{bmatrix} 0 & \\kappa \\\\ \\kappa & 0 \\end{bmatrix}.\n$$\n\n3. Define and evaluate the comparison measure.\n- The Frobenius norm of a matrix $A$ is $\\|A\\|_F = \\sqrt{\\sum_{i,j} A_{ij}^{2}}$.\n- Consider the difference\n$$\n\\mathbf{E} - \\boldsymbol{\\varepsilon} = \\tfrac{1}{2} \\begin{bmatrix} 0 & \\kappa \\\\ \\kappa & \\kappa^{2} \\end{bmatrix} - \\tfrac{1}{2} \\begin{bmatrix} 0 & \\kappa \\\\ \\kappa & 0 \\end{bmatrix}\n= \\tfrac{1}{2} \\begin{bmatrix} 0 & 0 \\\\ 0 & \\kappa^{2} \\end{bmatrix}.\n$$\n- Therefore,\n$$\ns(\\kappa) = \\|\\mathbf{E} - \\boldsymbol{\\varepsilon}\\|_F = \\left\\| \\tfrac{1}{2} \\begin{bmatrix} 0 & 0 \\\\ 0 & \\kappa^{2} \\end{bmatrix} \\right\\|_F\n= \\tfrac{1}{2} \\sqrt{0^{2} + 0^{2} + 0^{2} + (\\kappa^{2})^{2}}\n= \\tfrac{1}{2} \\kappa^{2}.\n$$\n- Evaluating at the specified values:\n$$\ns(0.2) = \\tfrac{1}{2} (0.2)^{2} = \\tfrac{1}{2} \\cdot 0.04 = 0.02,\n\\quad\ns(1) = \\tfrac{1}{2} (1)^{2} = 0.5.\n$$\n\nThe requested final answer is the row matrix $\\begin{pmatrix} s(0.2) & s(1) \\end{pmatrix}$ with exact decimal values.", "answer": "$$\\boxed{\\begin{pmatrix}0.02 & 0.5\\end{pmatrix}}$$", "id": "2558928"}, {"introduction": "A crucial step in mastering computational mechanics is bridging the gap between analytical theory and its numerical implementation. A fundamental principle of mechanics is that a rigid body motion—a pure rotation and/or translation—should not induce any internal strain in a material. The Green-Lagrange strain tensor is specifically designed to satisfy this property of objectivity. This computational exercise challenges you to verify this principle within a Finite Element Method (FEM) framework, where you will numerically compute the strain tensor $\\mathbf{E}$ for various elements undergoing rigid motions and confirm that it remains zero to within machine precision [@problem_id:2558930]. Successfully completing this task is equivalent to performing a fundamental verification test for any nonlinear solid mechanics code.", "problem": "Consider the kinematics of finite strain within the finite element method under a rigid body motion. Let the reference configuration be parameterized by material coordinates $\\mathbf{X}$ and the current configuration by spatial coordinates $\\mathbf{x}$. The deformation gradient is defined by $\\mathbf{F} = \\dfrac{\\partial \\mathbf{x}}{\\partial \\mathbf{X}}$. The right Cauchy-Green tensor is $\\mathbf{C} = \\mathbf{F}^{\\mathsf{T}} \\mathbf{F}$ and the Green-Lagrange strain is $\\mathbf{E} = \\dfrac{1}{2}\\left(\\mathbf{C} - \\mathbf{I}\\right)$. Under a pure rigid rotation, the Green-Lagrange strain must be identically zero.\n\nYour task is to write a program that numerically verifies this invariance for several finite element meshes subjected to pure rotations (possibly with translations). The verification must proceed from first principles: start from the definitions of $\\mathbf{F}$ and $\\mathbf{E}$, and use the chain rule to construct element-level mappings. Avoid introducing any unmotivated shortcut formulas.\n\nImplement the following steps for each test case:\n- Construct a rotation mapping $\\mathbf{R}$ (in two or three dimensions) from the specified parameters and define a rigid motion $\\mathbf{x}(\\mathbf{X}) = \\mathbf{R}\\,\\mathbf{X} + \\mathbf{c}$, where $\\mathbf{c}$ is a constant translation vector. Angles must be interpreted in radians.\n- For each element, evaluate the deformation gradient $\\mathbf{F}$ at the appropriate quadrature points using the isoparametric concept and the chain rule. Specifically:\n  - For linear simplicial elements (linear triangle in two dimensions and linear tetrahedron in three dimensions), recognize that the interpolation is affine in $\\mathbf{X}$ and hence $\\mathbf{F}$ is constant within the element; compute it consistently from the discrete mapping implied by the nodal values.\n  - For bilinear quadrilateral elements in two dimensions, evaluate $\\mathbf{F}$ at a set of Gauss points by composing the mapping from the parent coordinates to $\\mathbf{X}$ and to $\\mathbf{x}$, using the chain rule to obtain $\\dfrac{\\partial \\mathbf{x}}{\\partial \\mathbf{X}}$.\n- For each quadrature point, compute $\\mathbf{C} = \\mathbf{F}^{\\mathsf{T}}\\mathbf{F}$ and $\\mathbf{E} = \\dfrac{1}{2}\\left(\\mathbf{C}-\\mathbf{I}\\right)$, and then take the maximum absolute value of the components of $\\mathbf{E}$ over all quadrature points and all tensor components in the element.\n- Compare this maximum to a prescribed tolerance $\\tau = 10^{-12}$. The result for a test case is $\\mathrm{True}$ if the value is less than or equal to $\\tau$ and $\\mathrm{False}$ otherwise.\n\nUse the following test suite. In each case, the program must internally generate the current nodal coordinates by applying the specified rigid motion to the given reference nodal coordinates. All angles are given in radians, and the output must be dimensionless booleans.\n\n- Test case $1$ (two-dimensional linear triangle):\n  - Reference nodes $\\mathbf{X}_1 = [0,0]$, $\\mathbf{X}_2 = [1,0]$, $\\mathbf{X}_3 = [0.2,0.8]$.\n  - Rotation angle $\\alpha = 0.7$ about the origin, translation $\\mathbf{c} = [0.3,-0.4]$.\n- Test case $2$ (two-dimensional bilinear quadrilateral evaluated at a $2 \\times 2$ Gaussian quadrature):\n  - Reference nodes in order $\\mathbf{X}_1 = [0.0,0.0]$, $\\mathbf{X}_2 = [2.0,0.5]$, $\\mathbf{X}_3 = [2.1,1.8]$, $\\mathbf{X}_4 = [-0.2,1.5]$.\n  - Rotation angle $\\alpha = 0.3$, translation $\\mathbf{c} = [-0.1,0.2]$.\n- Test case $3$ (three-dimensional linear tetrahedron):\n  - Reference nodes $\\mathbf{X}_1 = [0.0,0.0,0.0]$, $\\mathbf{X}_2 = [1.0,0.1,0.0]$, $\\mathbf{X}_3 = [0.2,1.1,0.3]$, $\\mathbf{X}_4 = [0.1,0.2,1.2]$.\n  - Rotation about axis $\\mathbf{u} = [1,2,3]$ by angle $\\theta = 0.9$, translation $\\mathbf{c} = [0.5,-0.4,0.3]$.\n- Test case $4$ (two-dimensional bilinear quadrilateral evaluated at a $2 \\times 2$ Gaussian quadrature, edge case of half-turn):\n  - Reference nodes in order $\\mathbf{X}_1 = [-1.0,0.0]$, $\\mathbf{X}_2 = [1.0,0.2]$, $\\mathbf{X}_3 = [1.5,1.3]$, $\\mathbf{X}_4 = [-0.5,1.0]$.\n  - Rotation angle $\\alpha = \\pi$, translation $\\mathbf{c} = [1.0,-2.0]$.\n- Test case $5$ (two-dimensional linear triangle, identity rotation):\n  - Reference nodes $\\mathbf{X}_1 = [0.0,0.0]$, $\\mathbf{X}_2 = [2.0,0.0]$, $\\mathbf{X}_3 = [0.0,1.0]$.\n  - Rotation angle $\\alpha = 0.0$, translation $\\mathbf{c} = [10.0,10.0]$.\n- Test case $6$ (three-dimensional linear tetrahedron, full turn):\n  - Reference nodes $\\mathbf{X}_1 = [0.0,0.0,0.0]$, $\\mathbf{X}_2 = [0.8,0.1,0.0]$, $\\mathbf{X}_3 = [0.2,0.9,0.4]$, $\\mathbf{X}_4 = [0.1,0.3,1.1]$.\n  - Rotation about axis $\\mathbf{u} = [0.0,1.0,1.0]$ by angle $\\theta = 2\\pi$, translation $\\mathbf{c} = [-0.3,0.2,-0.1]$.\n\nYour program must:\n- Construct the current configuration for each test by applying the specified rigid motion to the reference nodes.\n- Compute the deformation gradient and Green-Lagrange strain as described.\n- For each test, return a boolean indicating whether the maximum absolute component of $\\mathbf{E}$ over that test is less than or equal to $\\tau = 10^{-12}$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $\\left[\\mathrm{True},\\mathrm{False},\\mathrm{True}\\right]$). The list must contain exactly $6$ booleans, one per test case, in the order given above.", "solution": "The problem statement poses a numerical verification task rooted in the fundamental principles of continuum mechanics and the finite element method. Before providing a solution, its validity must be rigorously established.\n\nThe problem is scientifically grounded. It concerns the kinematics of finite strain, a cornerstone of continuum mechanics. The definitions provided for the deformation gradient $\\mathbf{F} = \\frac{\\partial \\mathbf{x}}{\\partial \\mathbf{X}}$, the right Cauchy-Green tensor $\\mathbf{C} = \\mathbf{F}^{\\mathsf{T}} \\mathbf{F}$, and the Green-Lagrange strain tensor $\\mathbf{E} = \\frac{1}{2}(\\mathbf{C} - \\mathbf{I})$ are standard and correct. The central premise, that $\\mathbf{E}$ must be identically zero for a pure rigid body motion, is a fundamental and provable fact. A rigid body motion is described by the mapping $\\mathbf{x}(\\mathbf{X}) = \\mathbf{R}\\mathbf{X} + \\mathbf{c}$, where $\\mathbf{R}$ is a constant rotation tensor satisfying $\\mathbf{R}^{\\mathsf{T}}\\mathbf{R} = \\mathbf{I}$ and $\\mathbf{c}$ is a constant translation vector. The deformation gradient is thus $\\mathbf{F} = \\frac{\\partial}{\\partial \\mathbf{X}}(\\mathbf{R}\\mathbf{X} + \\mathbf{c}) = \\mathbf{R}$. Consequently, $\\mathbf{C} = \\mathbf{R}^{\\mathsf{T}}\\mathbf{R} = \\mathbf{I}$, which leads to $\\mathbf{E} = \\frac{1}{2}(\\mathbf{I} - \\mathbf{I}) = \\mathbf{0}$. The problem asks for a numerical verification of this analytical result using finite element constructs, which is a standard and meaningful procedure for code validation in computational mechanics.\n\nThe problem is well-posed and self-contained. It provides all necessary information for each test case: element type, reference nodal coordinates, and parameters for the rigid motion. The computational procedure is specified in sufficient detail, including the use of the isoparametric formulation, the chain rule for the deformation gradient, and the specific quadrature rule for quadrilateral elements. A clear, objective criterion for success is given by comparing the maximum absolute value of the computed strain components against a specified tolerance $\\tau = 10^{-12}$. There are no internal contradictions, ambiguities, or missing data. All scientific and mathematical premises are sound.\n\nTherefore, the problem is deemed valid. A solution will now be presented.\n\nThe solution methodology proceeds as follows. For each test case, we first compute the current nodal coordinates $\\mathbf{x}_i$ by applying the prescribed rigid motion $\\mathbf{x}_i = \\mathbf{R}\\mathbf{X}_i + \\mathbf{c}$ to the reference nodal coordinates $\\mathbf{X}_i$. The rotation matrix $\\mathbf{R}$ and translation vector $\\mathbf{c}$ are constructed from the given parameters. The core of the task is then to compute the deformation gradient $\\mathbf{F}$ within the finite element framework.\n\nThe isoparametric formulation maps a simple parent element in parent coordinates $\\boldsymbol{\\xi}$ to the physical element in both the reference configuration $\\mathbf{X}(\\boldsymbol{\\xi})$ and the current configuration $\\mathbf{x}(\\boldsymbol{\\xi})$. The mappings are interpolated from nodal values using shape functions $N_i(\\boldsymbol{\\xi})$:\n$$ \\mathbf{X}(\\boldsymbol{\\xi}) = \\sum_{i} N_i(\\boldsymbol{\\xi}) \\mathbf{X}_i \\quad \\text{and} \\quad \\mathbf{x}(\\boldsymbol{\\xi}) = \\sum_{i} N_i(\\boldsymbol{\\xi}) \\mathbf{x}_i $$\nThe deformation gradient $\\mathbf{F} = \\frac{\\partial \\mathbf{x}}{\\partial \\mathbf{X}}$ is computed using the chain rule:\n$$ \\mathbf{F} = \\frac{\\partial \\mathbf{x}}{\\partial \\boldsymbol{\\xi}} \\left( \\frac{\\partial \\mathbf{X}}{\\partial \\boldsymbol{\\xi}} \\right)^{-1} $$\nHere, $\\frac{\\partial \\mathbf{X}}{\\partial \\boldsymbol{\\xi}} = \\mathbf{J}_X$ is the Jacobian of the mapping from parent to reference coordinates, and $\\frac{\\partial \\mathbf{x}}{\\partial \\boldsymbol{\\xi}} = \\mathbf{J}_x$ is the Jacobian of the mapping from parent to current coordinates. Thus, $\\mathbf{F} = \\mathbf{J}_x \\mathbf{J}_X^{-1}$. The problem correctly demands that this computation be performed from first principles, rather than using the analytical shortcut $\\mathbf{F}=\\mathbf{R}$, to verify the correctness of the numerical implementation itself.\n\nFor linear simplicial elements (triangle in 2D, tetrahedron in 3D), the shape functions are linear, and thus the Jacobians $\\mathbf{J}_X$ and $\\mathbf{J}_x$ are constant throughout the element. For a simplex with nodes $1, 2, \\ldots, d+1$ in $d$ dimensions, the Jacobian matrix can be constructed directly from the vectors forming the edges from a common node, say node $1$:\n$$ \\mathbf{J}_X = [ \\mathbf{X}_2 - \\mathbf{X}_1, \\ldots, \\mathbf{X}_{d+1} - \\mathbf{X}_1 ] $$\nand similarly for $\\mathbf{J}_x$. The deformation gradient $\\mathbf{F}$ is then constant within the element.\n\nFor bilinear quadrilateral elements, the mapping is not affine, and $\\mathbf{F}$ is not constant. It must be evaluated at specific quadrature points. For a $2 \\times 2$ Gauss quadrature, we evaluate $\\mathbf{F}$ at the four points $(\\xi_k, \\eta_k) = (\\pm 1/\\sqrt{3}, \\pm 1/\\sqrt{3})$. At each point, the Jacobians are computed using the gradients of the shape functions:\n$$ \\mathbf{J}_X(\\xi_k, \\eta_k) = \\begin{bmatrix} \\sum_i \\frac{\\partial N_i}{\\partial \\xi} X_{i,1} & \\sum_i \\frac{\\partial N_i}{\\partial \\eta} X_{i,1} \\\\ \\sum_i \\frac{\\partial N_i}{\\partial \\xi} X_{i,2} & \\sum_i \\frac{\\partial N_i}{\\partial \\eta} X_{i,2} \\end{bmatrix} $$\nwhere the derivatives are evaluated at $(\\xi_k, \\eta_k)$. $\\mathbf{J}_x$ is computed analogously.\n\nThe rotation matrices are constructed as follows:\nIn two dimensions, for a counter-clockwise rotation by an angle $\\alpha$:\n$$ \\mathbf{R} = \\begin{bmatrix} \\cos\\alpha & -\\sin\\alpha \\\\ \\sin\\alpha & \\cos\\alpha \\end{bmatrix} $$\nIn three dimensions, for a rotation by an angle $\\theta$ about a unit axis $\\hat{\\mathbf{u}}$, Rodrigues' formula gives:\n$$ \\mathbf{R} = \\cos\\theta \\, \\mathbf{I} + \\sin\\theta \\, [\\hat{\\mathbf{u}}]_\\times + (1-\\cos\\theta) \\, (\\hat{\\mathbf{u}} \\otimes \\hat{\\mathbf{u}}) $$\nwhere $[\\hat{\\mathbf{u}}]_\\times$ is the cross-product matrix of $\\hat{\\mathbf{u}}$.\n\nAfter computing $\\mathbf{F}$ at each required point (the element centroid for simplices, or each Gauss point for quadrilaterals), the corresponding Green-Lagrange strain tensor $\\mathbf{E} = \\frac{1}{2}(\\mathbf{F}^{\\mathsf{T}}\\mathbf{F} - \\mathbf{I})$ is calculated. The maximum absolute value of all components of all computed $\\mathbf{E}$ tensors for a given test case is then compared against the tolerance $\\tau=10^{-12}$. The result is $\\mathrm{True}$ if this maximum is less than or equal to $\\tau$, and $\\mathrm{False}$ otherwise. This procedure is implemented for each of the six specified test cases.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef get_rotation_matrix_2d(angle):\n    \"\"\"Constructs a 2D rotation matrix.\"\"\"\n    return np.array([\n        [np.cos(angle), -np.sin(angle)],\n        [np.sin(angle), np.cos(angle)]\n    ])\n\ndef get_rotation_matrix_3d(axis, angle):\n    \"\"\"Constructs a 3D rotation matrix using Rodrigues' formula.\"\"\"\n    u = np.asarray(axis)\n    u = u / np.linalg.norm(u)\n    \n    I = np.eye(3)\n    u_cross = np.array([\n        [0, -u[2], u[1]],\n        [u[2], 0, -u[0]],\n        [-u[1], u[0], 0]\n    ])\n    u_outer = np.outer(u, u)\n    \n    R = np.cos(angle) * I + np.sin(angle) * u_cross + (1 - np.cos(angle)) * u_outer\n    return R\n\ndef verify_triangle_2d(X_nodes, angle, trans_vec):\n    \"\"\"Verifies Green-Lagrange strain for a 2D linear triangle.\"\"\"\n    R = get_rotation_matrix_2d(angle)\n    x_nodes = (R @ X_nodes.T).T + trans_vec\n\n    # For linear triangles, F is constant.\n    # Jx = [x2-x1, x3-x1] as columns\n    J_X = (X_nodes[1:] - X_nodes[0]).T\n    J_x = (x_nodes[1:] - x_nodes[0]).T\n\n    F = J_x @ np.linalg.inv(J_X)\n    C = F.T @ F\n    I = np.eye(2)\n    E = 0.5 * (C - I)\n    \n    return np.max(np.abs(E))\n\ndef verify_quad_2d(X_nodes, angle, trans_vec):\n    \"\"\"Verifies Green-Lagrange strain for a 2D bilinear quadrilateral.\"\"\"\n    R = get_rotation_matrix_2d(angle)\n    x_nodes = (R @ X_nodes.T).T + trans_vec\n\n    # 2x2 Gauss quadrature points\n    gp = 1.0 / np.sqrt(3.0)\n    gauss_points = [(-gp, -gp), (gp, -gp), (gp, gp), (-gp, gp)]\n    \n    # Parent coordinates of nodes\n    node_coords_parent = [(-1, -1), (1, -1), (1, 1), (-1, -1)]\n\n    max_E_abs = 0.0\n\n    for xi, eta in gauss_points:\n        # Shape function derivatives w.r.t. parent coordinates (xi, eta)\n        # N_i(xi, eta) = 0.25 * (1 + xi_i*xi) * (1 + eta_i*eta)\n        # d(N_i)/d(xi) = 0.25 * xi_i * (1 + eta_i*eta)\n        # d(N_i)/d(eta) = 0.25 * eta_i * (1 + xi_i*xi)\n        dN_dxi = np.array([\n            -0.25 * (1 - eta),\n             0.25 * (1 - eta),\n             0.25 * (1 + eta),\n            -0.25 * (1 + eta)\n        ])\n        dN_deta = np.array([\n            -0.25 * (1 - xi),\n            -0.25 * (1 + xi),\n             0.25 * (1 + xi),\n             0.25 * (1 - xi)\n        ])\n        \n        # Jacobian from parent to reference and current configurations\n        J_X = np.zeros((2, 2))\n        J_X[0, 0] = np.dot(dN_dxi, X_nodes[:, 0])\n        J_X[0, 1] = np.dot(dN_deta, X_nodes[:, 0])\n        J_X[1, 0] = np.dot(dN_dxi, X_nodes[:, 1])\n        J_X[1, 1] = np.dot(dN_deta, X_nodes[:, 1])\n        \n        J_x = np.zeros((2, 2))\n        J_x[0, 0] = np.dot(dN_dxi, x_nodes[:, 0])\n        J_x[0, 1] = np.dot(dN_deta, x_nodes[:, 0])\n        J_x[1, 0] = np.dot(dN_dxi, x_nodes[:, 1])\n        J_x[1, 1] = np.dot(dN_deta, x_nodes[:, 1])\n        \n        F = J_x @ np.linalg.inv(J_X)\n        C = F.T @ F\n        I = np.eye(2)\n        E = 0.5 * (C - I)\n        \n        max_E_abs = max(max_E_abs, np.max(np.abs(E)))\n        \n    return max_E_abs\n\ndef verify_tetrahedron_3d(X_nodes, axis, angle, trans_vec):\n    \"\"\"Verifies Green-Lagrange strain for a 3D linear tetrahedron.\"\"\"\n    R = get_rotation_matrix_3d(axis, angle)\n    x_nodes = (R @ X_nodes.T).T + trans_vec\n\n    # For linear tetrahedra, F is constant.\n    J_X = (X_nodes[1:] - X_nodes[0]).T\n    J_x = (x_nodes[1:] - x_nodes[0]).T\n    \n    F = J_x @ np.linalg.inv(J_X)\n    C = F.T @ F\n    I = np.eye(3)\n    E = 0.5 * (C - I)\n    \n    return np.max(np.abs(E))\n\ndef solve():\n    \"\"\"Main function to run all test cases and print results.\"\"\"\n    tolerance = 1e-12\n\n    test_cases = [\n        # Test case 1\n        {\n            'type': 'tri2d', \n            'params': {\n                'X_nodes': np.array([[0.0, 0.0], [1.0, 0.0], [0.2, 0.8]]),\n                'angle': 0.7, \n                'trans_vec': np.array([0.3, -0.4])\n            }\n        },\n        # Test case 2\n        {\n            'type': 'quad2d', \n            'params': {\n                'X_nodes': np.array([[0.0, 0.0], [2.0, 0.5], [2.1, 1.8], [-0.2, 1.5]]),\n                'angle': 0.3, \n                'trans_vec': np.array([-0.1, 0.2])\n            }\n        },\n        # Test case 3\n        {\n            'type': 'tet3d', \n            'params': {\n                'X_nodes': np.array([[0.0, 0.0, 0.0], [1.0, 0.1, 0.0], [0.2, 1.1, 0.3], [0.1, 0.2, 1.2]]),\n                'axis': np.array([1, 2, 3]), \n                'angle': 0.9, \n                'trans_vec': np.array([0.5, -0.4, 0.3])\n            }\n        },\n        # Test case 4\n        {\n            'type': 'quad2d', \n            'params': {\n                'X_nodes': np.array([[-1.0, 0.0], [1.0, 0.2], [1.5, 1.3], [-0.5, 1.0]]),\n                'angle': np.pi, \n                'trans_vec': np.array([1.0, -2.0])\n            }\n        },\n        # Test case 5\n        {\n            'type': 'tri2d', \n            'params': {\n                'X_nodes': np.array([[0.0, 0.0], [2.0, 0.0], [0.0, 1.0]]),\n                'angle': 0.0, \n                'trans_vec': np.array([10.0, 10.0])\n            }\n        },\n        # Test case 6\n        {\n            'type': 'tet3d', \n            'params': {\n                'X_nodes': np.array([[0.0, 0.0, 0.0], [0.8, 0.1, 0.0], [0.2, 0.9, 0.4], [0.1, 0.3, 1.1]]),\n                'axis': np.array([0.0, 1.0, 1.0]), \n                'angle': 2 * np.pi, \n                'trans_vec': np.array([-0.3, 0.2, -0.1])\n            }\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        max_E = 0.0\n        if case['type'] == 'tri2d':\n            max_E = verify_triangle_2d(**case['params'])\n        elif case['type'] == 'quad2d':\n            max_E = verify_quad_2d(**case['params'])\n        elif case['type'] == 'tet3d':\n            max_E = verify_tetrahedron_3d(**case['params'])\n        \n        results.append(max_E = tolerance)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "2558930"}]}