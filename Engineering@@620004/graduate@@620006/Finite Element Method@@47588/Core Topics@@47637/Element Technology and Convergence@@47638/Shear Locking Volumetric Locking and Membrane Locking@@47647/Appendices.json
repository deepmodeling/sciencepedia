{"hands_on_practices": [{"introduction": "This first exercise provides a classic entry point into the world of numerical locking by examining shear locking in Timoshenko beam elements. You will implement a finite element model for a cantilever beam and conduct a numerical experiment to see how standard linear elements behave as the beam becomes very thin [@problem_id:2595579]. This hands-on practice is invaluable for developing a concrete intuition for how an element's kinematic assumptions can lead to an overly stiff response, a critical skill for any computational analyst.", "problem": "Consider the Timoshenko beam model for a prismatic, rectangular cross-section cantilever beam of length $L$ subjected to a transverse point load $P$ at the free end. The cross-section has unit width $b=1$ and thickness $t$. The material has Young's modulus $E$ and shear modulus $G$. The Timoshenko kinematics use the transverse displacement field $w(x)$ and the rotation of the cross-section $\\varphi(x)$. The bending curvature is $\\kappa_b(x)=\\frac{d\\varphi}{dx}$ and the shear strain is $\\gamma(x)=\\frac{dw}{dx}-\\varphi(x)$. The strain energy over an interval is the sum of bending and shear contributions. The bending rigidity is $E I$ with $I=\\frac{b t^3}{12}$, and the shear rigidity is $\\kappa_s G A$ with $A=b\\,t$ and shear correction factor $\\kappa_s=\\frac{5}{6}$ for a rectangular section. The exact Timoshenko tip deflection for a cantilever under an end load $P$ is given by the sum of a bending part and a shear part. All quantities in this problem are nondimensional, so no physical units are required in the answer.\n\nYou will implement a finite element model using linear two-node Timoshenko beam elements on a uniform mesh. Each node has two degrees of freedom: transverse displacement $w$ and rotation $\\varphi$. Use the principle of minimum potential energy and the standard finite element assembly procedure. For a single element of length $\\ell_e$, approximate $w(x)$ and $\\varphi(x)$ by linear shape functions $N_1(x)=1-\\frac{x}{\\ell_e}$ and $N_2(x)=\\frac{x}{\\ell_e}$, i.e.,\n$$\nw(x)=N_1(x)\\,w_1+N_2(x)\\,w_2,\\quad \\varphi(x)=N_1(x)\\,\\varphi_1+N_2(x)\\,\\varphi_2.\n$$\nStarting from the definitions $\\kappa_b(x)=\\frac{d\\varphi}{dx}$ and $\\gamma(x)=\\frac{dw}{dx}-\\varphi(x)$, derive the element stiffness matrix by integrating the quadratic form of the strain energy density over the element. Assemble the global stiffness matrix for a cantilever with clamped end at $x=0$ (impose $w(0)=0$ and $\\varphi(0)=0$) and a tip load $P$ applied at $x=L$ in the transverse direction only. Solve the linear system for the nodal unknowns and extract the finite element approximation of the tip displacement, $w_{\\mathrm{FE}}$, at $x=L$.\n\nDesign a numerical experiment to quantify the convergence of the tip displacement and to diagnose shear locking. Use the following parameters:\n- $L=10$, $E=1$, $G=1$, $\\kappa_s=\\frac{5}{6}$, $b=1$, $P=1$, and $t\\in\\{1,0.1,0.01\\}$.\n- For each thickness $t$, compute $w_{\\mathrm{FE}}$ on uniform meshes with number of elements $n_e\\in\\{1,2,4,8,16,32\\}$.\n- For each case, also compute the exact Timoshenko tip deflection\n$$\nw_{\\mathrm{exact}}=\\frac{P\\,L^3}{3\\,E\\,I}+\\frac{P\\,L}{\\kappa_s\\,G\\,A}.\n$$\nQuantify the convergence by the ratio $r(n_e,t)=\\frac{w_{\\mathrm{FE}}(n_e,t)}{w_{\\mathrm{exact}}(t)}$ for each $n_e$ and $t$. Your program must output these ratios for all meshes and all three thicknesses.\n\nTest suite and required final output format:\n- The test suite is the Cartesian product of $t\\in\\{1,0.1,0.01\\}$ and $n_e\\in\\{1,2,4,8,16,32\\}$.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where the outer list contains three inner lists, one per thickness value in the order $t=1$, $t=0.1$, $t=0.01$. Each inner list must contain six floating-point ratios $r(n_e,t)$ in the order $n_e=1,2,4,8,16,32$. For example, an output with placeholder values would look like\n$$\n[[r_{1,1},r_{2,1},r_{4,1},r_{8,1},r_{16,1},r_{32,1}],[r_{1,0.1},r_{2,0.1},r_{4,0.1},r_{8,0.1},r_{16,0.1},r_{32,0.1}],[r_{1,0.01},r_{2,0.01},r_{4,0.01},r_{8,0.01},r_{16,0.01},r_{32,0.01}]].\n$$\nDo not print any other text. The values must be computed by assembling and solving the finite element systems as described above.\n\nYour task:\n- Implement the finite element assembly for linear Timoshenko elements from the fundamental kinematic definitions and energy expressions.\n- Compute $w_{\\mathrm{FE}}$ and $r(n_e,t)$ for the specified test suite.\n- Produce the final output in the exact format specified above, containing only the nested list of ratios.\n- After running the program, interpret the trend in $r(n_e,t)$ across $n_e$ and $t$ as evidence of shear locking: a persistent underestimation, i.e., $r(n_e,t)<1$ that improves slowly with mesh refinement as $t$ decreases, is characteristic of shear locking. You do not need to print this interpretation; it is required for the analytical solution write-up below.", "solution": "The problem posed is a standard exercise in computational mechanics for demonstrating the numerical artifact known as shear locking in the finite element analysis of Timoshenko beams. It is scientifically grounded, well-posed, and complete. I will proceed with the derivation and solution.\n\nThe foundation of the finite element method is the principle of minimum potential energy. The total potential energy $\\Pi$ of the beam is the sum of the internal strain energy $U$ minus the work done by external forces $W_e$. For our problem,\n$$ \\Pi = U - W_e = \\frac{1}{2} \\int_0^L \\left( EI (\\kappa_b(x))^2 + \\kappa_s G A (\\gamma(x))^2 \\right) dx - P w(L) $$\nwhere $L$ is the beam length, $E$ is Young's modulus, $I$ is the second moment of area, $G$ is the shear modulus, $A$ is the cross-sectional area, $\\kappa_s$ is the shear correction factor, and $P$ is the point load at the free end $x=L$. The kinematic variables are the transverse displacement $w(x)$ and the cross-section rotation $\\varphi(x)$. The bending curvature is $\\kappa_b(x) = \\frac{d\\varphi}{dx}$ and the shear strain is $\\gamma(x) = \\frac{dw}{dx} - \\varphi(x)$.\n\nWe discretize the beam into $n_e$ finite elements. For a single two-node element of length $\\ell_e$, with local coordinate $\\bar{x} \\in [0, \\ell_e]$, the fields $w(\\bar{x})$ and $\\varphi(\\bar{x})$ are interpolated from the nodal degrees of freedom. The nodal displacement vector for the element is $\\mathbf{d}_e = [w_1, \\varphi_1, w_2, \\varphi_2]^T$. We use the specified linear shape functions $N_1(\\bar{x}) = 1 - \\frac{\\bar{x}}{\\ell_e}$ and $N_2(\\bar{x}) = \\frac{\\bar{x}}{\\ell_e}$.\n$$ w(\\bar{x}) = N_1(\\bar{x}) w_1 + N_2(\\bar{x}) w_2 $$\n$$ \\varphi(\\bar{x}) = N_1(\\bar{x}) \\varphi_1 + N_2(\\bar{x}) \\varphi_2 $$\nThe derivatives with respect to $\\bar{x}$ are:\n$$ \\frac{dw}{d\\bar{x}} = \\frac{d N_1}{d\\bar{x}} w_1 + \\frac{d N_2}{d\\bar{x}} w_2 = -\\frac{1}{\\ell_e} w_1 + \\frac{1}{\\ell_e} w_2 $$\n$$ \\frac{d\\varphi}{d\\bar{x}} = \\frac{d N_1}{d\\bar{x}} \\varphi_1 + \\frac{d N_2}{d\\bar{x}} \\varphi_2 = -\\frac{1}{\\ell_e} \\varphi_1 + \\frac{1}{\\ell_e} \\varphi_2 $$\nThe bending curvature $\\kappa_b$ is constant within the element:\n$$ \\kappa_b(\\bar{x}) = \\frac{d\\varphi}{d\\bar{x}} = \\frac{1}{\\ell_e} (-\\varphi_1 + \\varphi_2) = \\begin{bmatrix} 0 & -\\frac{1}{\\ell_e} & 0 & \\frac{1}{\\ell_e} \\end{bmatrix} \\mathbf{d}_e = \\mathbf{B}_b \\mathbf{d}_e $$\nThe shear strain $\\gamma$ is linear within the element:\n$$ \\gamma(\\bar{x}) = \\frac{dw}{d\\bar{x}} - \\varphi(\\bar{x}) = \\left( -\\frac{1}{\\ell_e} w_1 + \\frac{1}{\\ell_e} w_2 \\right) - \\left( (1-\\frac{\\bar{x}}{\\ell_e}) \\varphi_1 + \\frac{\\bar{x}}{\\ell_e} \\varphi_2 \\right) $$\n$$ \\gamma(\\bar{x}) = \\begin{bmatrix} -\\frac{1}{\\ell_e} & -(1-\\frac{\\bar{x}}{\\ell_e}) & \\frac{1}{\\ell_e} & -\\frac{\\bar{x}}{\\ell_e} \\end{bmatrix} \\mathbf{d}_e = \\mathbf{B}_s(\\bar{x}) \\mathbf{d}_e $$\nThe element strain energy $U_e$ is given by $U_e = \\frac{1}{2} \\mathbf{d}_e^T \\mathbf{K}_e \\mathbf{d}_e$, where the element stiffness matrix $\\mathbf{K}_e$ is the sum of the bending stiffness $\\mathbf{K}_b$ and shear stiffness $\\mathbf{K}_s$:\n$$ \\mathbf{K}_e = \\mathbf{K}_b + \\mathbf{K}_s = \\int_0^{\\ell_e} \\mathbf{B}_b^T E I \\mathbf{B}_b d\\bar{x} + \\int_0^{\\ell_e} \\mathbf{B}_s(\\bar{x})^T \\kappa_s G A \\mathbf{B}_s(\\bar{x}) d\\bar{x} $$\nThe bending stiffness matrix is computed as:\n$$ \\mathbf{K}_b = E I \\int_0^{\\ell_e} \\frac{1}{\\ell_e^2} \\begin{bmatrix} 0 & 0 & 0 & 0 \\\\ 0 & 1 & 0 & -1 \\\\ 0 & 0 & 0 & 0 \\\\ 0 & -1 & 0 & 1 \\end{bmatrix} d\\bar{x} = \\frac{EI}{\\ell_e} \\begin{bmatrix} 0 & 0 & 0 & 0 \\\\ 0 & 1 & 0 & -1 \\\\ 0 & 0 & 0 & 0 \\\\ 0 & -1 & 0 & 1 \\end{bmatrix} $$\nThe shear stiffness matrix requires integrating the quadratic form of $\\mathbf{B}_s(\\bar{x})$:\n$$ \\mathbf{K}_s = \\kappa_s G A \\int_0^{\\ell_e} \\mathbf{B}_s(\\bar{x})^T \\mathbf{B}_s(\\bar{x}) d\\bar{x} $$\nPerforming the term-by-term integrations results in:\n$$ \\mathbf{K}_s = \\kappa_s G A \\begin{bmatrix} 1/\\ell_e & 1/2 & -1/\\ell_e & 1/2 \\\\ 1/2 & \\ell_e/3 & -1/2 & \\ell_e/6 \\\\ -1/\\ell_e & -1/2 & 1/\\ell_e & -1/2 \\\\ 1/2 & \\ell_e/6 & -1/2 & \\ell_e/3 \\end{bmatrix} $$\nThe total element stiffness matrix $\\mathbf{K}_e = \\mathbf{K}_b + \\mathbf{K}_s$ is then assembled into a global stiffness matrix $\\mathbf{K}$ for the entire beam, which consists of $n_e$ elements and $n_e+1$ nodes. The global system of equations is $\\mathbf{K}\\mathbf{D} = \\mathbf{F}$, where $\\mathbf{D}$ is the vector of all nodal displacements and rotations, and $\\mathbf{F}$ is the global force vector.\n\nFor a cantilever beam clamped at $x=0$, the boundary conditions are $w(0)=0$ and $\\varphi(0)=0$. These correspond to the first two degrees of freedom in the global system, $D_0$ and $D_1$. We enforce these constraints by modifying the system matrix and vector, typically by setting the corresponding rows and columns to zero (except for a $1$ on the diagonal) and the corresponding force components to zero. A transverse point load $P$ is applied at the free end, $x=L$. This corresponds to the last node, $n_e$. The force $P$ is added to the component of $\\mathbf{F}$ associated with the transverse displacement at this node.\n\nAfter solving the modified linear system for $\\mathbf{D}$, we extract the finite element approximation of the tip displacement, $w_{\\mathrm{FE}}$, which is the component of $\\mathbf{D}$ corresponding to the transverse displacement at node $n_e$.\n\nThis solution is compared to the exact Timoshenko solution:\n$$ w_{\\mathrm{exact}}=\\frac{P L^3}{3 E I}+\\frac{P L}{\\kappa_s G A} $$\nThe ratio $r(n_e, t) = w_{\\mathrm{FE}}(n_e, t) / w_{\\mathrm{exact}}(t)$ is used to quantify convergence. The parameter $t$ is the beam thickness, which enters via $A=bt$ and $I=bt^3/12$. For this problem, $b=1$, so $A=t$ and $I=t^3/12$.\n\nThe phenomenon of shear locking arises when the beam becomes thin (i.e., the aspect ratio $L/t$ is large). In the thin beam limit, the true shear strain $\\gamma = dw/dx - \\varphi$ should approach zero. However, our finite element formulation with linear interpolation for both $w$ and $\\varphi$ forces $\\gamma$ to be a linear function of $\\bar{x}$, while a bending-dominated state requires $\\varphi$ to vary linearly, thus $dw/dx$ to vary quadratically. The linear element cannot represent this correctly. To minimize the large shear energy term (proportional to $\\kappa_s G A \\sim t$), the element's degrees of freedom are spuriously constrained, forcing $\\gamma(\\bar{x})$ toward zero everywhere. This forces $\\varphi$ to be nearly constant across the element, locking it and preventing it from bending properly. This results in an artificially stiff response and a computed displacement $w_{\\mathrm{FE}}$ that is significantly underestimated.\n\nThe numerical results will demonstrate this. For the thick beam ($t=1$), convergence will be rapid ($r \\to 1$ quickly). For the thin beams ($t=0.1$ and especially $t=0.01$), the ratio $r$ will be very small for coarse meshes ($n_e$ is small) and will only slowly approach $1$ as the mesh is refined. This poor convergence for thin structures is the hallmark of shear locking. The implementation below will quantify this behavior precisely.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Timoshenko beam problem using FEM and analyzes shear locking.\n    \"\"\"\n    # Problem Constants\n    L = 10.0\n    E = 1.0\n    G = 1.0\n    ks = 5.0 / 6.0\n    b = 1.0\n    P = 1.0\n\n    # Test Suite Parameters\n    thicknesses = [1.0, 0.1, 0.01]\n    n_elements_list = [1, 2, 4, 8, 16, 32]\n\n    results = []\n\n    for t in thicknesses:\n        # Geometric and Material Properties for the current thickness\n        A = b * t\n        I = b * t**3 / 12.0\n        \n        # Calculate the exact Timoshenko tip deflection\n        # Bending part + Shear part\n        w_exact = (P * L**3) / (3.0 * E * I) + (P * L) / (ks * G * A)\n\n        ratios_for_t = []\n        for ne in n_elements_list:\n            le = L / ne\n            num_nodes = ne + 1\n            num_dofs = 2 * num_nodes\n\n            # Calculate element stiffness matrix Ke = Kb + Ks\n            # Bending stiffness matrix Kb\n            Kb = (E * I / le) * np.array([\n                [0, 0, 0, 0],\n                [0, 1, 0, -1],\n                [0, 0, 0, 0],\n                [0, -1, 0, 1]\n            ])\n\n            # Shear stiffness matrix Ks\n            Ks_factor = ks * G * A\n            Ks_geom = np.array([\n                [1.0/le, 0.5, -1.0/le, 0.5],\n                [0.5, le/3.0, -0.5, le/6.0],\n                [-1.0/le, -0.5, 1.0/le, -0.5],\n                [0.5, le/6.0, -0.5, le/3.0]\n            ])\n            Ks = Ks_factor * Ks_geom\n            \n            Ke = Kb + Ks\n\n            # Assemble global stiffness matrix K and force vector F\n            K_global = np.zeros((num_dofs, num_dofs))\n            F_global = np.zeros(num_dofs)\n\n            for i in range(ne):\n                # Global DOFs for element i (nodes i and i+1)\n                dof_map = [2*i, 2*i + 1, 2*(i+1), 2*(i+1) + 1]\n                for row_loc in range(4):\n                    for col_loc in range(4):\n                        row_glob = dof_map[row_loc]\n                        col_glob = dof_map[col_loc]\n                        K_global[row_glob, col_glob] += Ke[row_loc, col_loc]\n\n            # Apply point load P at the free end (node ne)\n            # The DOF is for transverse displacement 'w' at the last node.\n            F_global[2*ne] = P\n\n            # Apply boundary conditions (clamped at x=0, node 0)\n            # w(0) = 0 and phi(0) = 0\n            # This corresponds to DOFs 0 and 1.\n            K_global[0, :] = 0.0\n            K_global[:, 0] = 0.0\n            K_global[0, 0] = 1.0\n            F_global[0] = 0.0\n\n            K_global[1, :] = 0.0\n            K_global[:, 1] = 0.0\n            K_global[1, 1] = 1.0\n            F_global[1] = 0.0\n            \n            # Solve the linear system KU=F\n            D = np.linalg.solve(K_global, F_global)\n\n            # Extract tip displacement w_FE at x=L (node ne)\n            w_fe = D[2*ne]\n\n            # Calculate the ratio\n            ratio = w_fe / w_exact\n            ratios_for_t.append(ratio)\n        \n        results.append(ratios_for_t)\n\n    # Format the output string as specified\n    output_str = \"[\"\n    for i, t_results in enumerate(results):\n        output_str += f\"[{','.join(map(str, t_results))}]\"\n        if i < len(results) - 1:\n            output_str += \",\"\n    output_str += \"]\"\n    \n    print(output_str)\n\nsolve()\n```", "id": "2595579"}, {"introduction": "This practice advances from shear locking to the more complex issue of volumetric locking in two dimensions, using the rigorous Method of Manufactured Solutions for verification. By implementing both a standard displacement element and a mixed-formulation element, you will quantitatively compare their performance and directly witness the effectiveness of the mixed method in restoring accuracy [@problem_id:2595504]. This coding exercise builds sophisticated skills in implementing advanced element technology and performing formal code verification.", "problem": "Consider the two-dimensional linear elasticity boundary value problem on the unit square domain $\\Omega=[0,1]\\times[0,1]$ in plane strain with a manufactured smooth displacement solution. Let the displacement be defined by $u_x(x,y)=\\sin(\\pi x)\\sin(\\pi y)$ and $u_y(x,y)=\\cos(\\pi x)\\sin(\\pi y)$. Let the material be nearly incompressible with Young’s modulus $E=1$ and Poisson’s ratio $\\nu=0.4999$. Denote the Lamé parameters by $\\lambda=\\frac{E\\nu}{(1+\\nu)(1-2\\nu)}$ and $\\mu=\\frac{E}{2(1+\\nu)}$. Define the exact pressure by $p_{\\text{exact}}(x,y)=-\\lambda\\,\\nabla\\cdot u(x,y)$. Let the body force be $f(x,y)=-\\nabla\\cdot\\sigma(x,y)$ with Cauchy stress $\\sigma=2\\mu\\,\\varepsilon(u)+\\lambda\\,\\text{tr}(\\varepsilon(u))I=2\\mu\\,\\varepsilon(u)-p_{\\text{exact}} I$, where $\\varepsilon(u)$ is the small-strain tensor. Impose Dirichlet boundary conditions by prescribing the exact displacement on the entire boundary $\\partial\\Omega$.\n\nYour task is to quantify volumetric locking by comparing the $L^2$ error of displacement and pressure for:\n- a standard displacement-based bilinear quadrilateral element (Q4) discretization with the full linear elastic stiffness (susceptible to volumetric locking),\n- a mixed displacement-pressure formulation with Q4 displacement and piecewise constant pressure per element (Q4/Q0) based on the Herrmann formulation, in which the deviatoric part is handled by $2\\mu\\,\\varepsilon(u):\\varepsilon(v)$ and the pressure $p$ is an independent unknown enforcing $p+\\lambda\\,\\nabla\\cdot u=0$ in a weak sense.\n\nStart from the following foundational principles:\n- The weak form of linear elasticity in plane strain, the definition of Lamé parameters, the definition of the small-strain tensor, and the concept of Cauchy stress in linear elasticity.\n- The Herrmann mixed formulation for near-incompressible elasticity with independent pressure unknown $p$.\n- Numerical quadrature for isoparametric bilinear quadrilateral elements (use tensor-product Gauss rules).\n- The definition of the $L^2$ norm on $\\Omega$.\n\nProceed as follows, using only these bases and no shortcut formulas beyond these principles:\n- Derive the body force $f$ from the manufactured displacement $u$ and pressure $p_{\\text{exact}}$.\n- For the displacement-only Q4 method, assemble the global system from the bilinear form $\\int_{\\Omega} \\varepsilon(v)^T D\\,\\varepsilon(u)\\,\\mathrm{d}\\Omega$ with plane-strain constitutive tensor $D$, and the linear functional $\\int_{\\Omega} v\\cdot f\\,\\mathrm{d}\\Omega$. Enforce Dirichlet conditions strongly using the exact boundary displacement.\n- For the mixed Q4/Q0 method (Herrmann), assemble the block system for $(u,p)$ from the bilinear forms\n  - $a(u,v)=\\int_{\\Omega} 2\\mu\\,\\varepsilon(u):\\varepsilon(v)\\,\\mathrm{d}\\Omega$,\n  - $b(v,p)=-\\int_{\\Omega} p\\,\\nabla\\cdot v\\,\\mathrm{d}\\Omega$ and $b(u,q)=-\\int_{\\Omega} q\\,\\nabla\\cdot u\\,\\mathrm{d}\\Omega$,\n  - $c(p,q)=-\\int_{\\Omega}\\frac{1}{\\lambda}\\,pq\\,\\mathrm{d}\\Omega$,\n  and the linear functional $\\int_{\\Omega} v\\cdot f\\,\\mathrm{d}\\Omega$. Use one pressure degree of freedom per element (constant per element). Enforce Dirichlet conditions strongly on $u$ as above.\n- For the displacement-only Q4 method, define the computed pressure field as $p_h=-\\lambda\\,\\nabla\\cdot u_h$ evaluated at quadrature points.\n- Compute the $L^2$ error of displacement $e_u=\\left(\\int_{\\Omega}\\|u_h-u_{\\text{exact}}\\|^2\\,\\mathrm{d}\\Omega\\right)^{1/2}$ and the $L^2$ error of pressure $e_p=\\left(\\int_{\\Omega}\\left(p_h-p_{\\text{exact}}\\right)^2\\,\\mathrm{d}\\Omega\\right)^{1/2}$ using appropriate Gaussian quadrature. For the mixed Q4/Q0 method, $p_h$ is piecewise constant, so evaluate its error by quadrature within each element.\n\nUse a structured grid of $N\\times N$ bilinear quadrilateral elements on $\\Omega$ with nodes at uniform spacing. Implement isoparametric mapping and use a $2\\times 2$ Gaussian quadrature rule for all element integrals. Enforce all boundary conditions exactly via the manufactured solution.\n\nTest suite:\n- Use three meshes with $N\\in\\{2,4,8\\}$.\n- For each $N$, compute four floats: the displacement $L^2$ error for Q4, the pressure $L^2$ error for Q4 (with $p_h=-\\lambda\\,\\nabla\\cdot u_h$), the displacement $L^2$ error for mixed Q4/Q0, and the pressure $L^2$ error for mixed Q4/Q0.\n\nFinal output specification:\n- Your program should produce a single line of output containing the results as a comma-separated list of lists, where each inner list corresponds to one mesh in the order $N=2$, $N=4$, $N=8$ and contains the four floats in the order described above. Express all floats in scientific notation with six digits after the decimal point. For example, the format must be exactly like:\n  $[ [a_{11},a_{12},a_{13},a_{14}], [a_{21},a_{22},a_{23},a_{24}], [a_{31},a_{32},a_{33},a_{34}] ]$\nThere are no physical units in this problem.", "solution": "The problem as stated is a well-posed exercise in computational mechanics, specifically the finite element analysis of nearly incompressible linear elasticity. It is scientifically grounded, self-contained, and free of contradictions. Its purpose is to demonstrate the phenomenon of volumetric locking in low-order displacement-based elements and its remedy using a mixed formulation. All necessary components—domain, boundary conditions, governing equations, material properties, and analysis methods—are provided. The problem is therefore valid. We proceed with the solution.\n\nThe analysis is based on the principles of linear elasticity in plane strain. The governing equilibrium equation is $\\nabla \\cdot \\sigma + f = 0$, where $\\sigma$ is the Cauchy stress tensor and $f$ is the body force per unit volume.\n\nFirst, we establish the expressions for the manufactured solution and its derivatives, which are essential for defining the problem and evaluating the accuracy of the numerical solutions.\n\nThe displacement field is given as:\n$$ u_x(x,y) = \\sin(\\pi x)\\sin(\\pi y) $$\n$$ u_y(x,y) = \\cos(\\pi x)\\sin(\\pi y) $$\nThe components of the small-strain tensor $\\varepsilon(u) = \\frac{1}{2}(\\nabla u + (\\nabla u)^T)$ are:\n$$ \\varepsilon_{xx} = \\frac{\\partial u_x}{\\partial x} = \\pi \\cos(\\pi x)\\sin(\\pi y) $$\n$$ \\varepsilon_{yy} = \\frac{\\partial u_y}{\\partial y} = \\pi \\cos(\\pi x)\\cos(\\pi y) $$\n$$ \\varepsilon_{xy} = \\frac{1}{2}\\left(\\frac{\\partial u_x}{\\partial y} + \\frac{\\partial u_y}{\\partial x}\\right) = \\frac{1}{2}\\left(\\pi \\sin(\\pi x)\\cos(\\pi y) - \\pi \\sin(\\pi x)\\sin(\\pi y)\\right) = \\frac{\\pi}{2} \\sin(\\pi x)(\\cos(\\pi y) - \\sin(\\pi y)) $$\nFor plane strain, $\\varepsilon_{zz} = 0$.\n\nThe divergence of the displacement field is the trace of the strain tensor:\n$$ \\nabla \\cdot u = \\varepsilon_{xx} + \\varepsilon_{yy} = \\pi \\cos(\\pi x)(\\sin(\\pi y) + \\cos(\\pi y)) $$\nThe exact pressure is defined as $p_{\\text{exact}} = -\\lambda \\, \\text{tr}(\\varepsilon(u)) = -\\lambda (\\nabla \\cdot u)$:\n$$ p_{\\text{exact}}(x,y) = -\\lambda \\pi \\cos(\\pi x)(\\sin(\\pi y) + \\cos(\\pi y)) $$\n\nThe body force $f$ is derived to ensure that the manufactured displacement field is the exact solution to the boundary value problem. From the Navier-Cauchy equations of elasticity, $f$ is given by:\n$$ f = - \\nabla \\cdot \\sigma = - \\nabla \\cdot (2\\mu\\varepsilon + \\lambda(\\nabla \\cdot u)I) = -\\mu \\nabla^2 u - (\\mu+\\lambda)\\nabla(\\nabla \\cdot u) $$\nWe compute the necessary terms:\n$$ \\nabla^2 u_x = \\frac{\\partial^2 u_x}{\\partial x^2} + \\frac{\\partial^2 u_x}{\\partial y^2} = -2\\pi^2 \\sin(\\pi x)\\sin(\\pi y) = -2\\pi^2 u_x $$\n$$ \\nabla^2 u_y = \\frac{\\partial^2 u_y}{\\partial x^2} + \\frac{\\partial^2 u_y}{\\partial y^2} = -2\\pi^2 \\cos(\\pi x)\\sin(\\pi y) = -2\\pi^2 u_y $$\n$$ \\nabla(\\nabla \\cdot u) = \\begin{pmatrix} \\frac{\\partial}{\\partial x}(\\nabla \\cdot u) \\\\ \\frac{\\partial}{\\partial y}(\\nabla \\cdot u) \\end{pmatrix} = \\begin{pmatrix} -\\pi^2 \\sin(\\pi x)(\\sin(\\pi y) + \\cos(\\pi y)) \\\\ \\pi^2 \\cos(\\pi x)(\\cos(\\pi y) - \\sin(\\pi y)) \\end{pmatrix} $$\nSubstituting these into the expression for $f$ yields the components of the body force:\n$$ f_x(x,y) = 2\\mu\\pi^2 u_x + (\\mu+\\lambda)\\pi^2 \\sin(\\pi x)(\\sin(\\pi y) + \\cos(\\pi y)) = \\pi^2 \\sin(\\pi x) \\left( (3\\mu+\\lambda)\\sin(\\pi y) + (\\mu+\\lambda)\\cos(\\pi y) \\right) $$\n$$ f_y(x,y) = 2\\mu\\pi^2 u_y - (\\mu+\\lambda)\\pi^2 \\cos(\\pi x)(\\cos(\\pi y) - \\sin(\\pi y)) = \\pi^2 \\cos(\\pi x) \\left( (3\\mu+\\lambda)\\sin(\\pi y) - (\\mu+\\lambda)\\cos(\\pi y) \\right) $$\n\nThe problem is discretized using a structured grid of $N \\times N$ bilinear quadrilateral elements (Q4). For an element defined on the parent domain $[-1,1]\\times[-1,1]$, the isoparametric mapping and displacement interpolation are given by:\n$$ x(\\xi, \\eta) = \\sum_{a=1}^4 N_a(\\xi, \\eta) x_a, \\quad u_h(\\xi, \\eta) = \\sum_{a=1}^4 N_a(\\xi, \\eta) d_a $$\nwhere $N_a(\\xi, \\eta) = \\frac{1}{4}(1+\\xi_a\\xi)(1+\\eta_a\\eta)$ are the shape functions, $x_a$ are nodal coordinates, and $d_a$ are nodal displacement vectors. The strain-displacement matrix $B$ relates the strain vector $\\varepsilon_V = (\\varepsilon_{xx}, \\varepsilon_{yy}, \\gamma_{xy})^T$ to the vector of nodal displacements $d$: $\\varepsilon_V = B d$.\n\n**Method 1: Standard Displacement-Based Q4 Formulation**\n\nThe weak form is $\\int_{\\Omega} \\varepsilon(v)^T D\\,\\varepsilon(u)\\,\\mathrm{d}\\Omega = \\int_{\\Omega} v\\cdot f\\,\\mathrm{d}\\Omega$. This leads to a linear system $K d = F$. The element stiffness matrix $K^e$ and force vector $F^e$ are:\n$$ K^e = \\int_{\\Omega_e} B^T D B \\, \\mathrm{d}\\Omega, \\quad F^e = \\int_{\\Omega_e} N^T f \\, \\mathrm{d}\\Omega $$\nThe plane-strain constitutive matrix $D$ is:\n$$ D = \\frac{E}{(1+\\nu)(1-2\\nu)} \\begin{pmatrix} 1-\\nu & \\nu & 0 \\\\ \\nu & 1-\\nu & 0 \\\\ 0 & 0 & (1-2\\nu)/2 \\end{pmatrix} = \\begin{pmatrix} \\lambda+2\\mu & \\lambda & 0 \\\\ \\lambda & \\lambda+2\\mu & 0 \\\\ 0 & 0 & \\mu \\end{pmatrix} $$\nIntegrals are computed using a $2 \\times 2$ Gauss quadrature rule. After assembling the global system, Dirichlet boundary conditions are strongly enforced by partitioning the system and solving for the unknown internal degrees of freedom. The numerical pressure field is post-processed from the computed displacement field $u_h$ as $p_h = -\\lambda (\\nabla \\cdot u_h)$. This calculation is performed at the quadrature points.\n\n**Method 2: Mixed Displacement-Pressure Q4/Q0 Formulation (Herrmann)**\n\nThis formulation treats pressure $p$ as an independent variable, constant over each element, to overcome locking. The weak form is a saddle-point system:\n$$ \\int_{\\Omega} 2\\mu\\,\\varepsilon(u):\\varepsilon(v)\\,\\mathrm{d}\\Omega - \\int_{\\Omega} p\\,\\nabla\\cdot v\\,\\mathrm{d}\\Omega = \\int_{\\Omega} v\\cdot f\\,\\mathrm{d}\\Omega $$\n$$ -\\int_{\\Omega} q\\,\\nabla\\cdot u\\,\\mathrm{d}\\Omega - \\int_{\\Omega}\\frac{1}{\\lambda}\\,pq\\,\\mathrm{d}\\Omega = 0 $$\nThis leads to a block matrix system:\n$$ \\begin{pmatrix} A & B^T \\\\ B & C \\end{pmatrix} \\begin{pmatrix} d \\\\ p \\end{pmatrix} = \\begin{pmatrix} F \\\\ 0 \\end{pmatrix} $$\nThe element-level matrices are:\n - $A^e = \\int_{\\Omega_e} B^T D_{dev} B \\, \\mathrm{d}\\Omega$, with $D_{dev} = \\text{diag}(2\\mu, 2\\mu, \\mu)$. This represents the deviatoric part of the stiffness.\n - $B^e$ is a $1 \\times 8$ matrix coupling the element's single pressure degree of freedom to its $8$ displacement degrees of freedom: $B^e = -\\int_{\\Omega_e} [1, 1, 0]B \\, \\mathrm{d}\\Omega$.\n - $C^e$ is a $1 \\times 1$ matrix for the pressure term: $C^e = -\\int_{\\Omega_e} \\frac{1}{\\lambda} \\, \\mathrm{d}\\Omega = -\\frac{\\text{Area}(e)}{\\lambda}$.\n - $F^e$ is the same body force vector as in the Q4 method.\nThe global system is assembled from these element matrices. The matrix $C$ is diagonal. The boundary conditions are applied to the displacement DOFs in the same manner as for the Q4 method. The solution of this system yields both the displacement field $u_h$ and the piecewise constant pressure field $p_h$.\n\n**Error Calculation**\n\nFor both methods, the $L^2$ errors in displacement and pressure are computed to quantify accuracy. The errors are defined as:\n$$ e_u = \\left(\\int_{\\Omega}\\|u_h-u_{\\text{exact}}\\|^2\\,\\mathrm{d}\\Omega\\right)^{1/2} $$\n$$ e_p = \\left(\\int_{\\Omega}\\left(p_h-p_{\\text{exact}}\\right)^2\\,\\mathrm{d}\\Omega\\right)^{1/2} $$\nThese integrals are computed numerically using the same $2 \\times 2$ Gauss quadrature rule over each element, summing the contributions to obtain the total error. For the Q4/Q0 method, $p_h$ is the piecewise constant value computed for each element, while for the Q4 method, $p_h$ is calculated from the displacement derivatives at each quadrature point.\n\nThe following Python implementation carries out these procedures for the specified mesh sizes.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 2D linear elasticity problem with a manufactured solution\n    to demonstrate volumetric locking and its mitigation with a mixed method.\n    \"\"\"\n\n    # Material properties and constants\n    E = 1.0\n    nu = 0.4999\n    \n    # Lamé parameters\n    lmbda = (E * nu) / ((1.0 + nu) * (1.0 - 2.0 * nu))\n    mu = E / (2.0 * (1.0 + nu))\n    \n    # Constitutive matrix for plane strain (Q4 method)\n    D = np.array([\n        [lmbda + 2 * mu, lmbda, 0],\n        [lmbda, lmbda + 2 * mu, 0],\n        [0, 0, mu]\n    ])\n    \n    # Deviatoric part for Q4/Q0 method\n    D_dev = np.diag([2 * mu, 2 * mu, mu])\n    \n    # Manufactured solution and its derivatives\n    pi = np.pi\n    u_exact_fn = lambda x, y: (np.sin(pi * x) * np.sin(pi * y), np.cos(pi * x) * np.sin(pi * y))\n    p_exact_fn = lambda x, y: -lmbda * pi * np.cos(pi * x) * (np.sin(pi * y) + np.cos(pi * y))\n\n    # Body force from manufactured solution\n    # f_x = pi**2 * sin(pi*x) * ((3*mu+lmbda)*sin(pi*y) + (mu+lmbda)*cos(pi*y))\n    # f_y = pi**2 * cos(pi*x) * ((3*mu+lmbda)*sin(pi*y) - (mu+lmbda)*cos(pi*y))\n    c1 = 3 * mu + lmbda\n    c2 = mu + lmbda\n    f_fn = lambda x, y: (\n        pi**2 * np.sin(pi * x) * (c1 * np.sin(pi * y) + c2 * np.cos(pi * y)),\n        pi**2 * np.cos(pi * x) * (c1 * np.sin(pi * y) - c2 * np.cos(pi * y))\n    )\n\n    # Gaussian quadrature points and weights for 2x2 rule\n    gauss_pts = [-1.0 / np.sqrt(3.0), 1.0 / np.sqrt(3.0)]\n    gauss_w = [1.0, 1.0]\n\n    def get_shape_functions_and_derivs(xi, eta):\n        # Shape functions N(xi, eta)\n        N = 0.25 * np.array([\n            (1 - xi) * (1 - eta),\n            (1 + xi) * (1 - eta),\n            (1 + xi) * (1 + eta),\n            (1 - xi) * (1 + eta)\n        ])\n        \n        # Derivatives of N w.r.t. xi, eta\n        dN_dxi = 0.25 * np.array([-(1 - eta), (1 - eta), (1 + eta), -(1 + eta)])\n        dN_deta = 0.25 * np.array([-(1 - xi), -(1 + xi), (1 + xi), (1 - xi)])\n        \n        return N, dN_dxi, dN_deta\n\n    def solve_fem(N, method):\n        # Mesh parameters\n        h = 1.0 / N\n        num_nodes = (N + 1)**2\n        num_elems = N**2\n        num_disp_dofs = 2 * num_nodes\n        \n        nodes = np.array([[i * h, j * h] for j in range(N + 1) for i in range(N + 1)])\n        elements = np.array([\n            [j * (N + 1) + i, j * (N + 1) + i + 1, (j + 1) * (N + 1) + i + 1, (j + 1) * (N + 1) + i]\n            for j in range(N) for i in range(N)\n        ])\n        elem_map = {(j, i): j * N + i for j in range(N) for i in range(N)}\n        \n        if method == 'Q4':\n            K = np.zeros((num_disp_dofs, num_disp_dofs))\n            F = np.zeros(num_disp_dofs)\n        elif method == 'Q4Q0':\n            num_pressure_dofs = num_elems\n            dof_total = num_disp_dofs + num_pressure_dofs\n            K_saddle = np.zeros((dof_total, dof_total))\n            F_saddle = np.zeros(dof_total)\n            A_mat = K_saddle[:num_disp_dofs, :num_disp_dofs]\n            B_mat = K_saddle[num_disp_dofs:, :num_disp_dofs] # B\n            C_mat = K_saddle[num_disp_dofs:, num_disp_dofs:]\n            F_disp = F_saddle[:num_disp_dofs]\n            \n            # Pressure matrix is diagonal\n            np.fill_diagonal(C_mat, -h**2 / lmbda)\n\n        # Assemble matrices\n        for j in range(N):\n            for i in range(N):\n                elem_idx = elem_map[(j, i)]\n                elem_nodes = elements[elem_idx]\n                elem_coords = nodes[elem_nodes]\n\n                # Element matrices\n                Ke = np.zeros((8, 8))\n                Fe = np.zeros(8)\n                if method == 'Q4Q0':\n                    Be_row = np.zeros(8)\n                \n                detJ = (h / 2.0)**2\n                \n                for gp_eta in gauss_pts:\n                    for gp_xi in gauss_pts:\n                        N_vals, dN_dxi, dN_deta = get_shape_functions_and_derivs(gp_xi, gp_eta)\n                        \n                        # Jacobian is constant for structured grid\n                        dN_dx = dN_dxi * (2.0 / h)\n                        dN_dy = dN_deta * (2.0 / h)\n                        \n                        B = np.zeros((3, 8))\n                        for k in range(4):\n                            B[0, 2*k] = dN_dx[k]\n                            B[1, 2*k+1] = dN_dy[k]\n                            B[2, 2*k] = dN_dy[k]\n                            B[2, 2*k+1] = dN_dx[k]\n\n                        D_eff = D if method == 'Q4' else D_dev\n                        Ke += B.T @ D_eff @ B * detJ\n                        \n                        x_gp, y_gp = elem_coords.T @ N_vals\n                        f_vec = f_fn(x_gp, y_gp)\n                        \n                        N_matrix = np.zeros((2, 8))\n                        N_matrix[0, 0::2] = N_vals\n                        N_matrix[1, 1::2] = N_vals\n                        \n                        Fe += N_matrix.T @ np.array(f_vec) * detJ\n                        \n                        if method == 'Q4Q0':\n                            G_transpose = np.array([1, 1, 0]) @ B\n                            Be_row -= G_transpose * detJ\n\n                # Assemble into global system\n                dofs = np.ravel([[2 * n, 2 * n + 1] for n in elem_nodes])\n                if method == 'Q4':\n                    K[np.ix_(dofs, dofs)] += Ke\n                    F[dofs] += Fe\n                elif method == 'Q4Q0':\n                    A_mat[np.ix_(dofs, dofs)] += Ke\n                    F_disp[dofs] += Fe\n                    B_mat[elem_idx, dofs] += Be_row\n\n        if method == 'Q4Q0':\n            # Transpose B to get B.T\n            K_saddle[:num_disp_dofs, num_disp_dofs:] = B_mat.T\n        \n        # Apply boundary conditions\n        boundary_nodes = set()\n        for i in range(N + 1):\n            boundary_nodes.add(i)  # bottom\n            boundary_nodes.add(N * (N + 1) + i) # top\n            boundary_nodes.add(i * (N + 1)) # left\n            boundary_nodes.add(i * (N + 1) + N) # right\n        \n        boundary_dofs = []\n        for n in sorted(list(boundary_nodes)):\n            boundary_dofs.extend([2 * n, 2 * n + 1])\n        \n        all_dofs = np.arange(num_disp_dofs)\n        internal_dofs = np.setdiff1d(all_dofs, boundary_dofs)\n        \n        u_h_full = np.zeros(num_disp_dofs)\n        boundary_coords = nodes[sorted(list(boundary_nodes))]\n        u_exact_b = np.array([u_exact_fn(c[0], c[1]) for c in boundary_coords]).ravel()\n        u_h_full[boundary_dofs] = u_exact_b\n        \n        if method == 'Q4':\n            K_II = K[np.ix_(internal_dofs, internal_dofs)]\n            K_IB = K[np.ix_(internal_dofs, boundary_dofs)]\n            F_I = F[internal_dofs]\n            F_eff = F_I - K_IB @ u_exact_b\n            u_I = np.linalg.solve(K_II, F_eff)\n            u_h_full[internal_dofs] = u_I\n            u_h = u_h_full\n            p_h = None\n        \n        elif method == 'Q4Q0':\n            dof_total = num_disp_dofs + num_pressure_dofs\n            all_saddle_dofs = np.arange(dof_total)\n            pressure_dofs_global = np.arange(num_disp_dofs, dof_total)\n            internal_saddle_dofs = np.concatenate([internal_dofs, pressure_dofs_global])\n            \n            K_saddle_II = K_saddle[np.ix_(internal_saddle_dofs, internal_saddle_dofs)]\n            K_saddle_IB = K_saddle[np.ix_(internal_saddle_dofs, boundary_dofs)]\n            F_saddle_I = F_saddle[internal_saddle_dofs]\n            F_saddle_eff = F_saddle_I - K_saddle_IB @ u_exact_b\n            \n            sol_I = np.linalg.solve(K_saddle_II, F_saddle_eff)\n            u_h_full[internal_dofs] = sol_I[:len(internal_dofs)]\n            u_h = u_h_full\n            p_h = sol_I[len(internal_dofs):]\n\n        # Error computation\n        u_err_sq, p_err_sq = 0.0, 0.0\n        for j in range(N):\n            for i in range(N):\n                elem_idx = elem_map[(j, i)]\n                elem_nodes = elements[elem_idx]\n                elem_coords = nodes[elem_nodes]\n                \n                detJ = (h / 2.0)**2\n                \n                for gp_eta in gauss_pts:\n                    for gp_xi in gauss_pts:\n                        N_vals, dN_dxi, dN_deta = get_shape_functions_and_derivs(gp_xi, gp_eta)\n                        x_gp, y_gp = elem_coords.T @ N_vals\n                        \n                        u_exact_gp = np.array(u_exact_fn(x_gp, y_gp))\n                        p_exact_gp = p_exact_fn(x_gp, y_gp)\n                        \n                        dofs = np.ravel([[2 * n, 2 * n + 1] for n in elem_nodes])\n                        u_nodal = u_h[dofs]\n                        \n                        N_matrix = np.zeros((2, 8))\n                        N_matrix[0, 0::2] = N_vals\n                        N_matrix[1, 1::2] = N_vals\n                        \n                        u_h_gp = N_matrix @ u_nodal\n                        u_err_sq += np.sum((u_h_gp - u_exact_gp)**2) * detJ\n\n                        if method == 'Q4':\n                            dN_dx = dN_dxi * (2.0 / h)\n                            dN_dy = dN_deta * (2.0 / h)\n                            B = np.zeros((3, 8))\n                            for k in range(4):\n                                B[0, 2*k] = dN_dx[k]\n                                B[1, 2*k+1] = dN_dy[k]\n                            div_u_h = (B[0, :] + B[1, :]) @ u_nodal\n                            p_h_gp = -lmbda * div_u_h\n                        elif method == 'Q4Q0':\n                            p_h_gp = p_h[elem_idx]\n\n                        p_err_sq += (p_h_gp - p_exact_gp)**2 * detJ\n                        \n        return np.sqrt(u_err_sq), np.sqrt(p_err_sq)\n\n\n    test_cases = [2, 4, 8]\n    results = []\n    \n    for n in test_cases:\n        case_results = []\n        \n        # Q4 analysis\n        err_u_q4, err_p_q4 = solve_fem(n, 'Q4')\n        case_results.extend([err_u_q4, err_p_q4])\n        \n        # Q4/Q0 analysis\n        err_u_q4q0, err_p_q4q0 = solve_fem(n, 'Q4Q0')\n        case_results.extend([err_u_q4q0, err_p_q4q0])\n        \n        results.append(case_results)\n\n    # Final print statement in the exact required format.\n    formatted_results = [\n        \"[\" + \", \".join(f\"{val:.6e}\" for val in case) + \"]\"\n        for case in results\n    ]\n    print(f\"[{', '.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2595504"}, {"introduction": "After observing locking phenomena in practice, this final exercise moves to the theoretical foundation of element validation by asking you to define a volumetric patch test. This thought experiment challenges you to articulate the precise conditions an element must satisfy to be considered consistent and free from locking, regardless of mesh distortion [@problem_id:2595541]. Mastering this concept is crucial for evaluating and developing reliable finite element formulations.", "problem": "Consider a patch of isoparametric bilinear quadrilateral elements (four-node quadrilaterals) assembled into a distorted mesh that covers a convex domain in the plane. The geometry mapping within each element is bilinear and not necessarily affine, but the Jacobian determinant is strictly positive everywhere so that the mapping is invertible. The material is linear elastic under small strains, with the Cauchy stress decomposition\n$$\n\\boldsymbol{\\sigma} = 2\\mu\\,\\boldsymbol{\\varepsilon}_{\\mathrm{dev}} + K\\,\\operatorname{tr}(\\boldsymbol{\\varepsilon})\\,\\mathbf{I},\n$$\nwhere $\\mu>0$ is the shear modulus, $K>0$ is the bulk modulus, $\\mathbf{I}$ is the second-order identity tensor, and $\\boldsymbol{\\varepsilon}=\\tfrac{1}{2}(\\nabla\\mathbf{u} + \\nabla\\mathbf{u}^{\\mathsf{T}})$ is the small-strain tensor with volumetric strain $\\operatorname{tr}(\\boldsymbol{\\varepsilon})$. There are no body forces. You wish to design a volumetric patch test that isolates potential volumetric locking on the distorted quadrilateral mesh by prescribing a linear displacement field that produces exactly zero volumetric strain everywhere in the continuum.\n\nYou choose a linear field\n$$\n\\mathbf{u}(\\mathbf{x}) = \\mathbf{a} + \\mathbf{A}\\,\\mathbf{x}, \\qquad \\mathbf{a}\\in\\mathbb{R}^{2},\\ \\mathbf{A}\\in\\mathbb{R}^{2\\times 2},\n$$\nsuch that\n$$\n\\operatorname{tr}(\\mathbf{A}) = 0,\n$$\nso that $\\operatorname{tr}(\\boldsymbol{\\varepsilon})=\\operatorname{tr}\\big(\\tfrac{1}{2}(\\mathbf{A}+\\mathbf{A}^{\\mathsf{T}})\\big)=\\operatorname{tr}(\\mathbf{A})=0$ in the exact (continuum) solution. On the finite element patch, you enforce Dirichlet boundary conditions by prescribing the nodal boundary displacements to be the exact values of $\\mathbf{u}(\\mathbf{x})$ at those boundary nodes. No tractions are applied. The finite element formulation is the standard displacement-based formulation with isoparametric interpolation; alternatively, in a mixed displacement–pressure formulation, the pressure $p$ enters as a Lagrange multiplier enforcing incompressibility with $p=-K\\,\\operatorname{tr}(\\boldsymbol{\\varepsilon})$.\n\nWhich statement precisely and completely specifies the necessary and sufficient pass conditions for this volumetric patch test on the distorted quadrilateral mesh?\n\nA. For any invertible bilinear geometric mapping (strictly positive Jacobian) and exact numerical integration of the element matrices and vectors, prescribing $\\mathbf{u}(\\mathbf{x})=\\mathbf{a}+\\mathbf{A}\\mathbf{x}$ with $\\operatorname{tr}(\\mathbf{A})=0$ at the patch boundary nodes must produce, to machine precision: (i) reproduction of $\\mathbf{u}(\\mathbf{x})$ pointwise within every element (hence constant deviatoric strain and $\\operatorname{tr}(\\boldsymbol{\\varepsilon})\\equiv 0$ at all quadrature points), (ii) zero element-level internal force residual at all interior nodes, and boundary reaction forces equal to those obtained from the continuum deviatoric stress field, and (iii) in a mixed displacement–pressure formulation, a discrete pressure field that is constant and can be taken identically zero over the patch (up to an arbitrary additive constant), with no spurious pressure modes. These conditions must hold independently of element distortion as long as the Jacobian remains positive.\n\nB. Because of geometric distortion, isoparametric bilinear elements cannot reproduce linear fields exactly in physical coordinates; therefore, the patch test should only require that the element-average volumetric strain $\\int_{\\Omega_{e}}\\operatorname{tr}(\\boldsymbol{\\varepsilon})\\,\\mathrm{d}\\Omega$ vanishes in each element, while nonzero pointwise $\\operatorname{tr}(\\boldsymbol{\\varepsilon})$ and a nonzero element-average pressure are acceptable provided global equilibrium of reactions is satisfied.\n\nC. To avoid rigid body modes, a uniform body force must be applied in addition to the prescribed boundary displacements. The element passes the volumetric patch test if the patch-average pressure is zero and the net reaction force vanishes; piecewise constant pressure fields with local variations and nonconstant deviatoric stress are acceptable on a distorted mesh.\n\nD. On a distorted isoparametric quadrilateral mesh, passing the volumetric patch test with a zero volumetric strain linear field is impossible in general; the correct requirement is only that the finite element solution converges to zero volumetric strain in the limit of mesh refinement, even if the patch test fails on a fixed distorted patch.\n\nE. For displacement-based quadrilateral elements, the volumetric patch test can be passed on distorted meshes only if one-point (selective) reduced integration is used for both the volumetric and deviatoric terms; using exact or higher-order quadrature will generally cause shear or volumetric locking and failure of the test.\n\nSelect all statements that are correct and complete.", "solution": "The problem statement is scientifically sound and well-posed. It presents a standard, albeit advanced, topic in the theory of the finite element method (FEM): the formulation of a patch test to diagnose volumetric locking in isoparametric elements. All terminology, equations, and concepts are standard and rigorously defined within the field of computational mechanics. I shall therefore proceed with the solution.\n\nThe core of the problem is to define the necessary and sufficient conditions for a finite element formulation to pass a \"volumetric patch test\". The patch test, introduced by B. M. Irons, is a fundamental test of consistency for a finite element. A formulation is consistent if it can exactly reproduce the exact solution when that solution lies within a specific class of functions (e.g., polynomials of a certain degree). Passing the patch test is a necessary condition for ensuring optimal-order convergence as the mesh is refined.\n\nThe problem specifies a linear displacement field, $\\mathbf{u}(\\mathbf{x}) = \\mathbf{a} + \\mathbf{A}\\,\\mathbf{x}$, as the exact solution. The corresponding strain tensor is constant throughout the continuum:\n$$ \\boldsymbol{\\varepsilon} = \\frac{1}{2}\\left(\\nabla\\mathbf{u} + (\\nabla\\mathbf{u})^{\\mathsf{T}}\\right) = \\frac{1}{2}\\left(\\mathbf{A} + \\mathbf{A}^{\\mathsf{T}}\\right) = \\text{constant} $$\nThe problem further specifies that this is a test for volumetric behavior by imposing $\\operatorname{tr}(\\mathbf{A}) = 0$, which implies that the exact volumetric strain is zero everywhere:\n$$ \\operatorname{tr}(\\boldsymbol{\\varepsilon}) = \\operatorname{tr}\\left(\\frac{1}{2}\\left(\\mathbf{A} + \\mathbf{A}^{\\mathsf{T}}\\right)\\right) = \\operatorname{tr}(\\mathbf{A}) = 0 $$\nConsequently, the exact Cauchy stress tensor is purely deviatoric:\n$$ \\boldsymbol{\\sigma} = 2\\mu\\,\\boldsymbol{\\varepsilon}_{\\mathrm{dev}} + K\\,\\operatorname{tr}(\\boldsymbol{\\varepsilon})\\,\\mathbf{I} = 2\\mu\\,\\boldsymbol{\\varepsilon} $$\nSince $\\boldsymbol{\\varepsilon}$ is constant, the stress $\\boldsymbol{\\sigma}$ is also constant. A constant stress field automatically satisfies the equilibrium equation with no body forces, $\\nabla \\cdot \\boldsymbol{\\sigma} = \\mathbf{0}$.\n\nThe finite element patch test works as follows: boundary nodal displacements are prescribed using the exact field, $\\mathbf{u}_i = \\mathbf{u}(\\mathbf{x}_i)$. The finite element method then solves for the internal state. For the formulation to \"pass\" the patch test, it must reproduce the exact solution state within the patch. This means:\n1.  The discrete displacement field $\\mathbf{u}^h(\\mathbf{x})$ must be identical to the exact field $\\mathbf{u}(\\mathbf{x})$ at all points within every element.\n2.  As a direct consequence of (1), the computed strain field $\\boldsymbol{\\varepsilon}^h$ must be identical to the exact constant strain $\\boldsymbol{\\varepsilon}$ at all points, which for this problem means $\\boldsymbol{\\varepsilon}^h$ must be constant and satisfy $\\operatorname{tr}(\\boldsymbol{\\varepsilon}^h) = 0$. This must hold at all quadrature points used for numerical integration.\n3.  The computed stress field $\\boldsymbol{\\sigma}^h$ must be identical to the exact constant stress $\\boldsymbol{\\sigma}$.\n4.  The discrete equilibrium equations must be satisfied exactly without any fictitious body forces. This manifests as the sum of internal force vectors at any interior node of the patch being zero.\n5.  The reaction forces at the boundary nodes must be consistent with the tractions derived from the exact continuum stress field, $\\mathbf{t} = \\boldsymbol{\\sigma}\\mathbf{n}$.\n\nA critical aspect of the problem is the use of a \"distorted\" isoparametric bilinear quadrilateral mesh. For a $4$-node quadrilateral, the isoparametric mapping from the parent square $(\\xi, \\eta)$ to physical coordinates $(x, y)$ is bilinear. If the element is not a parallelogram (i.e., it is distorted), this mapping is not affine. A known result in FEM theory is that a general linear function in physical coordinates, $\\mathbf{u}(\\mathbf{x})$, cannot be represented exactly by the bilinear shape functions on a distorted physical element. Many standard element formulations (e.g., a fully integrated $4$-node quadrilateral) will therefore fail this patch test. However, the question asks for the *definition* of the passing conditions, not whether a specific element passes. The pass conditions represent the required benchmark for a consistent formulation.\n\nWith these principles established, we evaluate each option.\n\n**A. For any invertible bilinear geometric mapping (strictly positive Jacobian) and exact numerical integration of the element matrices and vectors, prescribing $\\mathbf{u}(\\mathbf{x})=\\mathbf{a}+\\mathbf{A}\\mathbf{x}$ with $\\operatorname{tr}(\\mathbf{A})=0$ at the patch boundary nodes must produce, to machine precision: (i) reproduction of $\\mathbf{u}(\\mathbf{x})$ pointwise within every element (hence constant deviatoric strain and $\\operatorname{tr}(\\boldsymbol{\\varepsilon})\\equiv 0$ at all quadrature points), (ii) zero element-level internal force residual at all interior nodes, and boundary reaction forces equal to those obtained from the continuum deviatoric stress field, and (iii) in a mixed displacement–pressure formulation, a discrete pressure field that is constant and can be taken identically zero over the patch (up to an arbitrary additive constant), with no spurious pressure modes. These conditions must hold independently of element distortion as long as the Jacobian remains positive.**\n\nThis statement is a rigorous and complete enumeration of the pass conditions for the patch test, as outlined in the principles above.\n-   Condition (i) correctly states the requirement of pointwise reproduction of the displacement field, which leads to exact reproduction of the constant strain state ($\\operatorname{tr}(\\boldsymbol{\\varepsilon}^h) = 0$ everywhere).\n-   Condition (ii) correctly states the requirement of satisfying discrete equilibrium at interior nodes and producing correct boundary reactions.\n-   Condition (iii) correctly specifies the requirements for a mixed formulation, where the pressure field must be free of spurious oscillations (a symptom of locking) and consistent with the exact pressure (which is zero, or constant).\n-   The final clause, \"independently of element distortion,\" is the crucial requirement for the robustness of an element, which is the very purpose of the patch test.\nThis option correctly and precisely defines what it means to pass the test.\nVerdict: **Correct**.\n\n**B. Because of geometric distortion, isoparametric bilinear elements cannot reproduce linear fields exactly in physical coordinates; therefore, the patch test should only require that the element-average volumetric strain $\\int_{\\Omega_{e}}\\operatorname{tr}(\\boldsymbol{\\varepsilon})\\,\\mathrm{d}\\Omega$ vanishes in each element, while nonzero pointwise $\\operatorname{tr}(\\boldsymbol{\\varepsilon})$ and a nonzero element-average pressure are acceptable provided global equilibrium of reactions is satisfied.**\n\nThis statement correctly observes that standard bilinear elements fail to reproduce linear fields on distorted meshes. However, its conclusion is fundamentally flawed. It proposes to weaken the criteria of the patch test to accommodate the failure of a specific element type. The formal patch test requires pointwise satisfaction of the solution, not just in an average sense. Allowing nonzero pointwise volumetric strain ($\\operatorname{tr}(\\boldsymbol{\\varepsilon}^h) \\neq 0$) means the element is \"locking\"—it develops spurious volumetric stress and energy—which is precisely what the test is designed to detect and fail. Accepting this would render the test meaningless as a diagnostic for locking.\nVerdict: **Incorrect**.\n\n**C. To avoid rigid body modes, a uniform body force must be applied in addition to the prescribed boundary displacements. The element passes the volumetric patch test if the patch-average pressure is zero and the net reaction force vanishes; piecewise constant pressure fields with local variations and nonconstant deviatoric stress are acceptable on a distorted mesh.**\n\nThis statement contains multiple errors. First, applying Dirichlet boundary conditions on the patch boundary, as specified in the problem, is sufficient to restrain rigid body modes, provided the field $\\mathbf{A}\\mathbf{x}$ is not a pure rotation. Adding a body force changes the problem; the exact solution would no longer have constant stress, contradicting the test's premise. Second, the proposed pass criteria (patch-average pressure is zero, net reaction force is zero) are far too weak. Local pressure variations (\"checkerboarding\") can exist even if the average is zero, indicating locking. A non-constant deviatoric stress is a direct failure to reproduce the exact solution. The patch test is a very strict test, not a check of global averages.\nVerdict: **Incorrect**.\n\n**D. On a distorted isoparametric quadrilateral mesh, passing the volumetric patch test with a zero volumetric strain linear field is impossible in general; the correct requirement is only that the finite element solution converges to zero volumetric strain in the limit of mesh refinement, even if the patch test fails on a fixed distorted patch.**\n\nThis option confuses consistency (verified by the patch test) with convergence. The patch test is a specific procedure performed on a finite-sized patch to check for consistency. An element formulation that passes the patch test is guaranteed to converge at the optimal theoretical rate. An element that fails may still converge, but often at a suboptimal rate, or it may not converge to the correct solution at all under certain conditions (like locking). The question asks for the pass conditions *of the patch test itself*. To redefine the requirement as simply \"convergence in the limit\" is to abandon the patch test as a useful tool for element validation.\nVerdict: **Incorrect**.\n\n**E. For displacement-based quadrilateral elements, the volumetric patch test can be passed on distorted meshes only if one-point (selective) reduced integration is used for both the volumetric and deviatoric terms; using exact or higher-order quadrature will generally cause shear or volumetric locking and failure of the test.**\n\nThis option describes a particular element technology, not the fundamental pass conditions of the test. While using reduced integration is a common strategy to pass patch tests and alleviate locking, this statement is flawed. Stating this is the *only* way (\"only if\") is false; other methods exist, such as B-bar (enhanced strain) formulations. Furthermore, using one-point integration for *both* volumetric and deviatoric terms (uniform reduced integration) is known to introduce spurious zero-energy modes (hourglassing), which is another type of failure. Selective reduced integration (different rules for deviatoric and volumetric parts) is a different, more stable strategy. This option confuses a potential solution with the problem definition and is factually incomplete.\nVerdict: **Incorrect**.", "answer": "$$\\boxed{A}$$", "id": "2595541"}]}