{"hands_on_practices": [{"introduction": "The ability of a finite element to pass a patch test of a certain order is fundamentally linked to the completeness of the polynomial basis used in its formulation. To exactly reproduce a quadratic displacement field, for instance, the element's shape functions must span the complete space of quadratic polynomials. This exercise provides a direct, hands-on opportunity to diagnose an incomplete polynomial basis and identify the precise term needed to satisfy the requirements for a higher-order patch test [@problem_id:2605451].", "problem": "Consider a two-dimensional, small-strain, linear-elasticity problem discretized by a displacement-based, continuous ($C^0$) finite element method on a patch of straight-sided triangular elements. Each element mapping from the reference triangle to the physical coordinates is affine, so the physical coordinates $(x,y)$ depend linearly on the reference coordinates.\n\nYou plan to use the same scalar polynomial approximation for each displacement component $u(x,y)$ and $v(x,y)$, namely a basis built from monomials in $(x,y)$. Specifically, your current choice of basis for each component is\n$$\n\\mathcal{B}=\\{1,\\, x,\\, y,\\, x^{2},\\, y^{2}\\}.\n$$\n\nFor the purpose of convergence verification by the patch test, you require that the element pass the quadratic patch test, meaning that the element must be able to reproduce exactly any quadratic displacement field on each element when assembled on a patch with zero body forces and boundary tractions consistent with that quadratic field. Under the conditions stated (affine mapping and displacement-based formulation), this requirement is equivalent to the scalar approximation space for each component containing the complete space of bivariate polynomials up to total degree $2$ in $(x,y)$.\n\nDetermine the unique monomial of minimal total degree that must be added to the basis $\\mathcal{B}$ so that the resulting scalar approximation space contains all quadratic polynomials in $(x,y)$ and therefore the element passes the quadratic patch test. Report your answer as that single monomial in terms of $x$ and $y$.", "solution": "The problem statement has been validated and is deemed scientifically sound, well-posed, and objective. It presents a standard question in the theory of the finite element method. I will now proceed with the solution.\n\nThe problem requires determining the specific monomial that must be added to a given basis to ensure an element formulation passes the quadratic patch test. The problem explicitly states that for the given conditions (displacement-based $C^0$ formulation, straight-sided triangular elements with affine mapping), passing the quadratic patch test is equivalent to the scalar approximation space for each displacement component containing the complete space of bivariate polynomials of total degree up to $2$. Let this space be denoted by $\\mathcal{P}_2(x,y)$.\n\nA polynomial space is said to be \"complete\" up to degree $k$ if it contains all monomials whose total degree is less than or equal to $k$. The total degree of a monomial $x^a y^b$ is defined as the sum of its exponents, $a+b$.\n\nThe space $\\mathcal{P}_2(x,y)$ is the set of all polynomials $p(x,y)$ such that:\n$$\np(x,y) = \\sum_{i+j \\le 2} c_{ij} x^i y^j\n$$\nwhere $c_{ij}$ are constant coefficients. To form a basis for this space, we must include all monomials $x^i y^j$ for which the non-negative integers $i$ and $j$ satisfy $i+j \\le 2$. Let us systematically enumerate these monomials:\n\n1.  Total degree $0$: $i+j=0$. The only possibility is $i=0, j=0$, which corresponds to the monomial $x^0 y^0 = 1$.\n2.  Total degree $1$: $i+j=1$. The possibilities are $(i,j) = (1,0)$ and $(i,j) = (0,1)$, which correspond to the monomials $x^1 y^0 = x$ and $x^0 y^1 = y$.\n3.  Total degree $2$: $i+j=2$. The possibilities are $(i,j) = (2,0)$, $(i,j) = (1,1)$, and $(i,j) = (0,2)$, which correspond to the monomials $x^2 y^0 = x^2$, $x^1 y^1 = xy$, and $x^0 y^2 = y^2$.\n\nCombining these, a complete monomial basis for the space $\\mathcal{P}_2(x,y)$ is given by the set:\n$$\n\\mathcal{B}_{\\text{complete}} = \\{1, x, y, x^2, y^2, xy\\}\n$$\nThis space has a dimension of $6$.\n\nThe problem provides the current, incomplete basis being used for the element formulation:\n$$\n\\mathcal{B} = \\{1, x, y, x^2, y^2\\}\n$$\nThe space spanned by $\\mathcal{B}$ is a subspace of $\\mathcal{P}_2(x,y)$, but it is not the complete space. To satisfy the patch test condition, the basis must be augmented to span all of $\\mathcal{P}_2(x,y)$.\n\nA direct comparison of the set $\\mathcal{B}_{\\text{complete}}$ with the given basis $\\mathcal{B}$ reveals the missing term. The monomial present in $\\mathcal{B}_{\\text{complete}}$ but absent from $\\mathcal{B}$ is precisely the mixed or coupling term, $xy$.\n\nThe problem asks for the unique monomial of minimal total degree that must be added. The monomial to be added is $xy$. Its total degree is $1+1=2$. All monomials of lower total degree ($1, x, y$) are already present in $\\mathcal{B}$. The only other monomials of total degree $2$ are $x^2$ and $y^2$, which are also already present. Therefore, $xy$ is the *only* monomial of total degree $2$ or less that is missing. It is thus the unique monomial that must be added to achieve completeness up to degree $2$. Its addition is both necessary and sufficient to complete the basis.\n\nBy adding the monomial $xy$ to the basis $\\mathcal{B}$, we obtain the new basis $\\mathcal{B}' = \\{1, x, y, x^2, y^2, xy\\}$, which is identical to $\\mathcal{B}_{\\text{complete}}$. The span of $\\mathcal{B}'$ is $\\mathcal{P}_2(x,y)$, and the requirement for passing the quadratic patch test is satisfied. The element represented by this choice of basis is of the Serendipity family, which is known to be incomplete, whereas the element with the completed basis is a Lagrangian element. Incompleteness is the fundamental reason for failing patch tests.", "answer": "$$\\boxed{xy}$$", "id": "2605451"}, {"introduction": "Beyond the algebraic properties of its basis functions, a finite element's performance depends critically on its geometric validity. Severely distorted or non-convex element shapes can lead to a singular isoparametric mapping, rendering the element numerically useless. This practice delves into the mathematical mechanism behind this failure—the Jacobian determinant of the mapping—and challenges you to calculate the precise geometric limit at which an element becomes invalid [@problem_id:2605481]. This skill is essential for developing robust meshing algorithms and understanding a common source of errors in finite element simulations.", "problem": "Consider a two-dimensional plane-stress patch test on a non-convex two-element patch constructed from isoparametric bilinear quadrilateral elements. The outer boundary of the patch is prescribed with the exact linear displacement field $u(x,y)=x$ and $v(x,y)=0$, where $u$ and $v$ are the Cartesian displacement components. The material is homogeneous, isotropic, and linearly elastic with Young’s modulus $E$ and Poisson’s ratio $\\nu$, but no specific values of $E$ or $\\nu$ are needed. The finite element formulation uses standard isoparametric bilinear shape functions and standard Gauss quadrature with $2 \\times 2$ integration points at $(\\xi,\\eta) \\in \\{(\\pm 1/\\sqrt{3}, \\pm 1/\\sqrt{3})\\}$.\n\nFocus on one element in the patch that becomes non-convex as a parameter $\\epsilon$ varies. In the physical Cartesian plane, its nodes are located at\n- node 1: $(x_1,y_1)=(0,0)$,\n- node 2: $(x_2,y_2)=(1,0)$,\n- node 3: $(x_3,y_3)=(1,\\epsilon)$,\n- node 4: $(x_4,y_4)=(0,1)$,\n\nwith the usual reference-node association $(\\xi,\\eta)=(-1,-1),(1,-1),(1,1),(-1,1)$ for nodes 1,2,3,4, respectively. The isoparametric mapping is given by $(x(\\xi,\\eta),y(\\xi,\\eta))=\\sum_{i=1}^{4}N_i(\\xi,\\eta)(x_i,y_i)$ with the standard bilinear shape functions $N_i$. A necessary condition for passing the linear patch test is that the mapping is locally invertible at all Gauss points, that is, $\\det J(\\xi,\\eta)>0$ at all four $2 \\times 2$ Gauss points, where $J(\\xi,\\eta)$ is the Jacobian of the isoparametric mapping.\n\nTreating $\\epsilon$ as a real parameter, determine the critical value $\\epsilon_{\\text{crit}}$ (in exact analytic form) at which the mapping first becomes singular at the Gauss point $(\\xi,\\eta)=(1/\\sqrt{3},1/\\sqrt{3})$, i.e., the smallest value of $\\epsilon$ (in the sense of crossing from admissible to inadmissible at that specific Gauss point) such that $\\det J(1/\\sqrt{3},1/\\sqrt{3})=0$. No rounding is required, and no units are needed. Your final answer must be a single closed-form expression for $\\epsilon_{\\text{crit}}$.", "solution": "The problem is well-posed and contains sufficient information for a unique solution. We proceed directly to the derivation.\n\nThe core of the problem lies in the analysis of the isoparametric mapping from a reference element to a physical element. The mapping is defined by the standard bilinear shape functions $N_i(\\xi, \\eta)$ and the nodal coordinates of the physical element $(x_i, y_i)$.\n\nThe mapping is expressed as:\n$$\nx(\\xi, \\eta) = \\sum_{i=1}^{4} N_i(\\xi, \\eta) x_i\n$$\n$$\ny(\\xi, \\eta) = \\sum_{i=1}^{4} N_i(\\xi, \\eta) y_i\n$$\nwhere $(\\xi, \\eta) \\in [-1, 1] \\times [-1, 1]$ are the coordinates in the reference domain. The standard bilinear shape functions are:\n$$\nN_1(\\xi, \\eta) = \\frac{1}{4}(1-\\xi)(1-\\eta)\n$$\n$$\nN_2(\\xi, \\eta) = \\frac{1}{4}(1+\\xi)(1-\\eta)\n$$\n$$\nN_3(\\xi, \\eta) = \\frac{1}{4}(1+\\xi)(1+\\eta)\n$$\n$$\nN_4(\\xi, \\eta) = \\frac{1}{4}(1-\\xi)(1+\\eta)\n$$\nThe problem provides the nodal coordinates in the physical $(x, y)$ plane:\nNode 1: $(x_1, y_1) = (0, 0)$\nNode 2: $(x_2, y_2) = (1, 0)$\nNode 3: $(x_3, y_3) = (1, \\epsilon)$\nNode 4: $(x_4, y_4) = (0, 1)$\n\nSubstituting these coordinates into the mapping equations:\nFor the $x$-coordinate mapping:\n$$\nx(\\xi, \\eta) = N_2(\\xi, \\eta) + N_3(\\xi, \\eta) = \\frac{1}{4}(1+\\xi)(1-\\eta) + \\frac{1}{4}(1+\\xi)(1+\\eta) = \\frac{1}{4}(1+\\xi)[(1-\\eta)+(1+\\eta)] = \\frac{1}{2}(1+\\xi)\n$$\nFor the $y$-coordinate mapping:\n$$\ny(\\xi, \\eta) = \\epsilon N_3(\\xi, \\eta) + N_4(\\xi, \\eta) = \\epsilon \\frac{1}{4}(1+\\xi)(1+\\eta) + \\frac{1}{4}(1-\\xi)(1+\\eta) = \\frac{1}{4}(1+\\eta)[\\epsilon(1+\\xi) + (1-\\xi)]\n$$\n$$\ny(\\xi, \\eta) = \\frac{1}{4}(1+\\eta)[1+\\epsilon + (\\epsilon-1)\\xi]\n$$\nThe Jacobian matrix of this transformation is defined as:\n$$\nJ(\\xi, \\eta) = \\begin{pmatrix} \\frac{\\partial x}{\\partial \\xi} & \\frac{\\partial x}{\\partial \\eta} \\\\ \\frac{\\partial y}{\\partial \\xi} & \\frac{\\partial y}{\\partial \\eta} \\end{pmatrix}\n$$\nWe compute the necessary partial derivatives:\n$$\n\\frac{\\partial x}{\\partial \\xi} = \\frac{\\partial}{\\partial \\xi} \\left[ \\frac{1}{2}(1+\\xi) \\right] = \\frac{1}{2}\n$$\n$$\n\\frac{\\partial x}{\\partial \\eta} = \\frac{\\partial}{\\partial \\eta} \\left[ \\frac{1}{2}(1+\\xi) \\right] = 0\n$$\n$$\n\\frac{\\partial y}{\\partial \\xi} = \\frac{\\partial}{\\partial \\xi} \\left[ \\frac{1}{4}(1+\\eta)(1+\\epsilon + (\\epsilon-1)\\xi) \\right] = \\frac{1}{4}(1+\\eta)(\\epsilon-1)\n$$\n$$\n\\frac{\\partial y}{\\partial \\eta} = \\frac{\\partial}{\\partial \\eta} \\left[ \\frac{1}{4}(1+\\eta)(1+\\epsilon + (\\epsilon-1)\\xi) \\right] = \\frac{1}{4}(1+\\epsilon + (\\epsilon-1)\\xi)\n$$\nAssembling the Jacobian matrix:\n$$\nJ(\\xi, \\eta) = \\begin{pmatrix} \\frac{1}{2} & 0 \\\\ \\frac{1}{4}(1+\\eta)(\\epsilon-1) & \\frac{1}{4}(1+\\epsilon + (\\epsilon-1)\\xi) \\end{pmatrix}\n$$\nThe determinant of the Jacobian, $\\det J$, must be positive everywhere in the element for the mapping to be locally invertible. A singular mapping occurs when $\\det J = 0$.\n$$\n\\det J(\\xi, \\eta) = \\left(\\frac{1}{2}\\right) \\left( \\frac{1}{4}(1+\\epsilon + (\\epsilon-1)\\xi) \\right) - (0) \\left( \\frac{1}{4}(1+\\eta)(\\epsilon-1) \\right)\n$$\n$$\n\\det J(\\xi, \\eta) = \\frac{1}{8}(1+\\epsilon + (\\epsilon-1)\\xi)\n$$\nThe problem requires finding the critical value $\\epsilon_{\\text{crit}}$ for which the mapping becomes singular at the specified Gauss point $(\\xi, \\eta) = (1/\\sqrt{3}, 1/\\sqrt{3})$. We set the determinant to zero at this point. Note that the determinant is independent of $\\eta$, so we only substitute $\\xi = 1/\\sqrt{3}$:\n$$\n\\det J\\left(\\frac{1}{\\sqrt{3}}, \\frac{1}{\\sqrt{3}}\\right) = \\frac{1}{8}\\left(1+\\epsilon_{\\text{crit}} + (\\epsilon_{\\text{crit}}-1)\\frac{1}{\\sqrt{3}}\\right) = 0\n$$\nThis gives the condition:\n$$\n1+\\epsilon_{\\text{crit}} + (\\epsilon_{\\text{crit}}-1)\\frac{1}{\\sqrt{3}} = 0\n$$\nTo solve for $\\epsilon_{\\text{crit}}$, we multiply the entire equation by $\\sqrt{3}$ to clear the fraction:\n$$\n\\sqrt{3}(1+\\epsilon_{\\text{crit}}) + (\\epsilon_{\\text{crit}}-1) = 0\n$$\n$$\n\\sqrt{3} + \\sqrt{3}\\epsilon_{\\text{crit}} + \\epsilon_{\\text{crit}} - 1 = 0\n$$\nGroup the terms containing $\\epsilon_{\\text{crit}}$:\n$$\n\\epsilon_{\\text{crit}}(\\sqrt{3}+1) = 1 - \\sqrt{3}\n$$\nIsolating $\\epsilon_{\\text{crit}}$ yields:\n$$\n\\epsilon_{\\text{crit}} = \\frac{1 - \\sqrt{3}}{1 + \\sqrt{3}}\n$$\nTo obtain the final simplified analytical form, we rationalize the denominator by multiplying the numerator and denominator by the conjugate of the denominator, which is $(1 - \\sqrt{3})$:\n$$\n\\epsilon_{\\text{crit}} = \\frac{1 - \\sqrt{3}}{1 + \\sqrt{3}} \\cdot \\frac{1 - \\sqrt{3}}{1 - \\sqrt{3}} = \\frac{(1 - \\sqrt{3})^2}{1^2 - (\\sqrt{3})^2}\n$$\n$$\n\\epsilon_{\\text{crit}} = \\frac{1 - 2\\sqrt{3} + (\\sqrt{3})^2}{1 - 3} = \\frac{1 - 2\\sqrt{3} + 3}{-2} = \\frac{4 - 2\\sqrt{3}}{-2}\n$$\n$$\n\\epsilon_{\\text{crit}} = -2 + \\sqrt{3}\n$$\nThis is the exact critical value of the parameter $\\epsilon$. For admissibility at this specific Gauss point, it is required that $\\epsilon > \\sqrt{3}-2$. Thus, $\\epsilon_{\\text{crit}} = \\sqrt{3}-2$ represents the boundary where the mapping transitions from admissible to inadmissible.", "answer": "$$\n\\boxed{\\sqrt{3}-2}\n$$", "id": "2605481"}, {"introduction": "The ultimate confirmation of an element's correctness comes from implementing a full patch test. This capstone exercise guides you in translating theoretical knowledge into a practical, automated verification tool for linear elasticity [@problem_id:2605421]. By building a framework to test various element types and displacement fields—including a negative case to ensure the test's selectivity—you will engage in a process that mirrors the rigorous quality assurance required in the development of professional finite element software.", "problem": "Design and implement an automated patch test framework for two-dimensional small-strain linear elasticity within the Finite Element Method (FEM). The framework must verify the linear patch test for convergence verification on rectangular patches using both bilinear quadrilateral elements and linear triangular elements. The objective is to assess whether a given mesh and element formulation can exactly reproduce prescribed polynomial displacement fields when those fields lie within the discrete trial space, and to report a boolean result for each test case.\n\nStart from the following fundamental base:\n\n- The governing model is small-strain linear elasticity on a rectangular domain $\\Omega = [0,L_x] \\times [0,L_y]$, with displacement field $\\mathbf{u} = (u_x,u_y)$.\n- The small-strain tensor is $\\boldsymbol{\\varepsilon}(\\mathbf{u}) = \\frac{1}{2}\\left(\\nabla \\mathbf{u} + (\\nabla \\mathbf{u})^{T}\\right)$.\n- The constitutive relation for an isotropic material under plane stress is $\\boldsymbol{\\sigma} = \\mathbf{D} \\, \\boldsymbol{\\varepsilon}$, where $\\mathbf{D}$ depends on Young’s modulus $E$ and Poisson’s ratio $\\nu$ and is positive definite for $E > 0$ and $-1 < \\nu < 0.5$.\n- The weak form with essential (Dirichlet) boundary conditions $\\mathbf{u} = \\mathbf{g}$ on $\\partial \\Omega$ and zero body force is: find $\\mathbf{u} \\in \\mathcal{V}$ with $\\mathbf{u}|_{\\partial \\Omega} = \\mathbf{g}$ such that\n$$\n\\int_{\\Omega} \\boldsymbol{\\varepsilon}(\\mathbf{v})^{T} \\mathbf{D} \\, \\boldsymbol{\\varepsilon}(\\mathbf{u}) \\, \\mathrm{d}\\Omega = 0 \\quad \\text{for all } \\mathbf{v} \\in \\mathcal{V}_0.\n$$\n\nYour automated patch test must implement the following procedure:\n\n- Mesh generation on $\\Omega$ using either:\n  - Bilinear quadrilateral elements (denoted $Q4$) on a uniform $n_x \\times n_y$ grid of rectangles, or\n  - Linear triangular elements (denoted $T3$) obtained by splitting each rectangle into two triangles.\n- Conforming finite element discretization with standard isoparametric interpolation for $Q4$ and affine interpolation for $T3$.\n- Full Dirichlet boundary conditions on $\\partial \\Omega$ defined by a prescribed displacement field $\\mathbf{u}^{\\star}(x,y)$ that is either linear in $x$ and $y$ or quadratic in $x$ and $y$. The body force is zero.\n- Assemble the global stiffness matrix and enforce the Dirichlet boundary conditions by elimination.\n- Solve the resulting linear system for the unknown displacement degrees of freedom.\n- Evaluate the discrete solution $\\mathbf{u}_h$ at interior sampling points:\n  - For $Q4$ elements: use the standard $2 \\times 2$ Gauss points in the reference square, mapped to each physical element.\n  - For $T3$ elements: use the centroid of each triangle.\n- Compute the maximum absolute error over all sample points,\n$$\ne_{\\max} = \\max_{\\text{samples}} \\max\\left( \\left| u_{x,h} - u^{\\star}_x \\right|, \\left| u_{y,h} - u^{\\star}_y \\right| \\right).\n$$\n- Declare that a test case passes if $e_{\\max} \\le \\tau$, where $\\tau$ is a specified tolerance.\n\nYour program must implement element-level matrices based on the above definitions and exact numerical integration rules standard for each element type:\n- For $Q4$, use tensor-product Gauss integration with $2 \\times 2$ points.\n- For $T3$, exploit that the strain-displacement matrix is constant over an affine triangle and integrate exactly over the area.\n\nUse the following test suite. Each test provides $(\\text{element type}, n_x, n_y, L_x, L_y, E, \\nu, \\text{field type}, \\text{coefficients or None}, \\tau)$, where:\n- For a linear field, $\\mathbf{u}^{\\star}(x,y)$ is given by\n$$\nu_x(x,y) = a_0 + a_1 x + a_2 y, \\quad u_y(x,y) = b_0 + b_1 x + b_2 y,\n$$\nwith coefficients $(a_0,a_1,a_2,b_0,b_1,b_2)$ provided in the test case.\n- For the quadratic field case, use\n$$\nu_x(x,y) = x^2 + y, \\quad u_y(x,y) = x + y^2.\n$$\n- The material parameters are $E$ and $\\nu$, the tolerance is $\\tau$, and the domain is $\\Omega = [0,L_x]\\times[0,L_y]$.\n\nTest suite to implement:\n\n- Case $1$ (happy path, $Q4$, linear field):\n  - $(\\text{element type} = Q4, n_x = 2, n_y = 2, L_x = 1.0, L_y = 1.0, E = 1.0, \\nu = 0.25, \\text{field type} = \\text{linear}, \\text{coefficients} = (0.1, 0.2, -0.3, -0.05, 0.4, 0.25), \\tau = 10^{-10})$.\n- Case $2$ (coverage on $T3$, linear field):\n  - $(\\text{element type} = T3, n_x = 2, n_y = 2, L_x = 1.0, L_y = 1.0, E = 1.0, \\nu = 0.25, \\text{field type} = \\text{linear}, \\text{coefficients} = (0.1, 0.2, -0.3, -0.05, 0.4, 0.25), \\tau = 10^{-10})$.\n- Case $3$ (negative case to ensure discrimination, $Q4$, quadratic field):\n  - $(\\text{element type} = Q4, n_x = 2, n_y = 2, L_x = 1.0, L_y = 1.0, E = 1.0, \\nu = 0.25, \\text{field type} = \\text{quadratic}, \\text{coefficients} = \\text{None}, \\tau = 10^{-10})$.\n- Case $4$ (edge case: single element patch, $Q4$, linear field):\n  - $(\\text{element type} = Q4, n_x = 1, n_y = 1, L_x = 1.0, L_y = 1.0, E = 1.0, \\nu = 0.25, \\text{field type} = \\text{linear}, \\text{coefficients} = (0.0, 1.0, 0.0, 0.2, -0.1, 0.0), \\tau = 10^{-10})$.\n\nScientific realism requirements:\n\n- Assume all computations are non-dimensional; no physical units are required.\n- Angles do not appear in the input or output and need not be specified.\n\nYour program must output a single line containing the pass/fail boolean results for the above four cases as a comma-separated list enclosed in square brackets, for example $[r_1,r_2,r_3,r_4]$, where each $r_i$ is either $\\text{True}$ or $\\text{False}$. No other output is permitted.", "solution": "The problem requires the design and implementation of a patch test framework for two-dimensional linear elasticity. The patch test is a fundamental necessary condition for the convergence of a finite element formulation. It ascertains whether the element can exactly represent a constant strain state, which corresponds to a linear displacement field. A conforming element that passes the linear patch test is guaranteed to converge to the correct solution as the mesh is refined.\n\nThe governing equations are those of linear elastostatics. The displacement field is denoted by $\\mathbf{u} = (u_x, u_y)^T$. The strain-displacement relationship is given by the symmetric gradient operator, yielding the small strain tensor $\\boldsymbol{\\varepsilon}$:\n$$ \\boldsymbol{\\varepsilon} = \\begin{pmatrix} \\varepsilon_{xx} \\\\ \\varepsilon_{yy} \\\\ \\gamma_{xy} \\end{pmatrix} = \\begin{pmatrix} \\partial u_x / \\partial x \\\\ \\partial u_y / \\partial y \\\\ \\partial u_x / \\partial y + \\partial u_y / \\partial x \\end{pmatrix} $$\nFor a linear isotropic material under plane stress conditions, the stress tensor $\\boldsymbol{\\sigma}$ is related to the strain tensor via the constitutive matrix $\\mathbf{D}$:\n$$ \\boldsymbol{\\sigma} = \\mathbf{D} \\boldsymbol{\\varepsilon} $$\nwhere the matrix $\\mathbf{D}$ for plane stress is defined in terms of Young's modulus $E$ and Poisson's ratio $\\nu$ as:\n$$ \\mathbf{D} = \\frac{E}{1 - \\nu^2} \\begin{pmatrix} 1 & \\nu & 0 \\\\ \\nu & 1 & 0 \\\\ 0 & 0 & \\frac{1 - \\nu}{2} \\end{pmatrix} $$\n\nThe finite element method provides an approximate solution to the problem's weak form. The domain $\\Omega$ is discretized into elements. Within each element $e$, the displacement field $\\mathbf{u}_h$ is interpolated from nodal displacements $\\mathbf{d}_e$ using shape functions $\\mathbf{N}$:\n$$ \\mathbf{u}_h(x, y) = \\mathbf{N}(x, y) \\mathbf{d}_e $$\nThe strain field is then obtained by differentiating the shape functions:\n$$ \\boldsymbol{\\varepsilon}_h(x, y) = \\mathbf{B}(x, y) \\mathbf{d}_e $$\nThe matrix $\\mathbf{B}$ is the strain-displacement matrix, which connects nodal displacements to element strains.\n\nThe element stiffness matrix $\\mathbf{k}_e$ relates the nodal displacements to nodal forces for an element and is computed by integrating over the element's domain $\\Omega_e$:\n$$ \\mathbf{k}_e = \\int_{\\Omega_e} \\mathbf{B}^T \\mathbf{D} \\mathbf{B} \\, \\mathrm{d}\\Omega $$\nThese element matrices are assembled into a global stiffness matrix $\\mathbf{K}$. The resulting system of linear equations is $\\mathbf{K} \\mathbf{U} = \\mathbf{F}$. For the patch test, boundary conditions are prescribed from an exact polynomial displacement field $\\mathbf{u}^\\star$. The system is solved for the unknown interior nodal displacements.\n\nThe test passes if the computed numerical solution $\\mathbf{u}_h$ is identical to the exact solution $\\mathbf{u}^\\star$ within the domain, to within machine precision. We verify this by comparing the solutions at specific interior sampling points. The maximum error is calculated:\n$$ e_{\\max} = \\max_{\\text{samples}} \\| \\mathbf{u}_h(\\mathbf{x}_{\\text{sample}}) - \\mathbf{u}^\\star(\\mathbf{x}_{\\text{sample}}) \\|_{\\infty} $$\nThe test is passed if $e_{\\max} \\le \\tau$, where $\\tau$ is a small tolerance.\n\nTwo element types are considered:\n1.  Bilinear Quadrilateral ($Q4$): The shape functions are bilinear, of the form $N_i(\\xi, \\eta) = c_0 + c_1 \\xi + c_2 \\eta + c_3 \\xi \\eta$ in the reference element coordinate system $(\\xi, \\eta)$. This basis includes all linear polynomials. The integral for $\\mathbf{k}_e$ is evaluated using $2 \\times 2$ Gauss quadrature, which is exact for polynomials of degree up to $3$ in $\\xi$ and $\\eta$. For a rectangular element and a linear displacement field, the integrand is quadratic, so this rule is sufficient. The check is performed at the same Gauss quadrature points inside each element.\n\n2.  Linear Triangular ($T3$): The shape functions are linear, $N_i(x, y) = c_0 + c_1 x + c_2 y$. This basis also contains all linear polynomials. For this element, the strain-displacement matrix $\\mathbf{B}$ is constant. The integral for $\\mathbf{k}_e$ becomes trivial: $\\mathbf{k}_e = \\mathbf{B}^T \\mathbf{D} \\mathbf{B} \\cdot A_e$, where $A_e$ is the element area. The check is performed at the element centroid.\n\nThe logic of the patch test cases is as follows:\n- A linear displacement field corresponds to a constant strain state. Both $Q4$ and $T3$ elements must be able to reproduce this state exactly. Cases $1$, $2$, and $4$ test this fundamental property.\n- A quadratic displacement field is not, in general, representable by the $Q4$ element basis. The bilinear shape functions cannot exactly capture terms like $x^2$ or $y^2$. Therefore, the $Q4$ element is expected to fail the patch test for a general quadratic field. Case $3$ tests this discrimination capability, which is essential for a valid test framework.\n\nThe implementation procedure is:\n1.  A mesh generator creates the nodal coordinates and element connectivity for a given $n_x \\times n_y$ grid. For $T3$ elements, each rectangle is consistently divided into two triangles.\n2.  The global stiffness matrix $\\mathbf{K}$ is assembled by iterating over all elements and adding their respective $\\mathbf{k}_e$ to the correct global degrees of freedom (DOFs).\n3.  Dirichlet boundary conditions are identified for all nodes on the boundary $\\partial\\Omega$. The known displacements are computed from the analytical field $\\mathbf{u}^\\star$.\n4.  The linear system is partitioned into free and fixed DOFs and solved via elimination: $\\mathbf{K}_{ff} \\mathbf{U}_f = -\\mathbf{K}_{fd} \\mathbf{U}_d$.\n5.  After solving for the unknown displacements $\\mathbf{U}_f$, the full solution vector $\\mathbf{U}$ is reconstructed.\n6.  The maximum error $e_{\\max}$ is computed by iterating over all elements and their specified sampling points, comparing the interpolated FEM solution $\\mathbf{u}_h$ to the exact solution $\\mathbf{u}^\\star$.\n7.  Finally, the result is reported as `True` if $e_{\\max} \\le \\tau$, and `False` otherwise. This structured approach ensures a rigorous and verifiable implementation of the patch test.", "answer": "```python\nimport numpy as np\n\ndef perform_test(element_type, nx, ny, Lx, Ly, E, nu, field_type, coeffs, tau):\n    \"\"\"Performs a single patch test case.\"\"\"\n\n    # 1. Mesh Generation\n    dx = Lx / nx\n    dy = Ly / ny\n    num_nodes = (nx + 1) * (ny + 1)\n    nodes = np.zeros((num_nodes, 2))\n    for i in range(nx + 1):\n        for j in range(ny + 1):\n            node_idx = i * (ny + 1) + j\n            nodes[node_idx] = [i * dx, j * dy]\n\n    elements = []\n    if element_type == 'Q4':\n        for i in range(nx):\n            for j in range(ny):\n                n1 = i * (ny + 1) + j\n                n2 = (i + 1) * (ny + 1) + j\n                n3 = (i + 1) * (ny + 1) + (j + 1)\n                n4 = i * (ny + 1) + (j + 1)\n                elements.append([n1, n2, n3, n4])\n    elif element_type == 'T3':\n        for i in range(nx):\n            for j in range(ny):\n                n1 = i * (ny + 1) + j\n                n2 = (i + 1) * (ny + 1) + j\n                n3 = (i + 1) * (ny + 1) + (j + 1)\n                n4 = i * (ny + 1) + (j + 1)\n                # Consistent split: n1-n3 diagonal\n                elements.append([n1, n2, n3])\n                elements.append([n1, n3, n4])\n    \n    # 2. Define Exact Solution\n    if field_type == 'linear':\n        a0, a1, a2, b0, b1, b2 = coeffs\n        u_star = lambda x, y: np.array([a0 + a1 * x + a2 * y, b0 + b1 * x + b2 * y])\n    elif field_type == 'quadratic':\n        u_star = lambda x, y: np.array([x**2 + y, x + y**2])\n    else:\n        raise ValueError(\"Unknown field type\")\n\n    # 3. FEM Assembly\n    # Constitutive matrix for Plane Stress\n    D = (E / (1 - nu**2)) * np.array([[1, nu, 0],\n                                     [nu, 1, 0],\n                                     [0, 0, (1 - nu) / 2]])\n    \n    K = np.zeros((2 * num_nodes, 2 * num_nodes))\n\n    if element_type == 'Q4':\n        gauss_points = 1 / np.sqrt(3) * np.array([[-1, -1], [1, -1], [-1, 1], [1, 1]])\n        gauss_weights = [1, 1, 1, 1]\n\n        for el_nodes_idx in elements:\n            k_e = np.zeros((8, 8))\n            el_nodes_coords = nodes[el_nodes_idx]\n            \n            for gp, w in zip(gauss_points, gauss_weights):\n                xi, eta = gp\n                # Derivatives of shape functions w.r.t. ref coords\n                dN_dxi_eta = 0.25 * np.array([\n                    [-(1-eta),  (1-eta), (1+eta), -(1+eta)],\n                    [-(1-xi), -(1+xi),  (1+xi),  (1-xi)]\n                ])\n                \n                # Jacobian matrix\n                J = dN_dxi_eta @ el_nodes_coords\n                detJ = np.linalg.det(J)\n                invJ = np.linalg.inv(J)\n                \n                # Derivatives of shape functions w.r.t. physical coords\n                dN_dxy = invJ @ dN_dxi_eta\n                \n                # B matrix\n                B = np.zeros((3, 8))\n                for i in range(4):\n                    B[0, 2*i] = dN_dxy[0, i]\n                    B[1, 2*i+1] = dN_dxy[1, i]\n                    B[2, 2*i] = dN_dxy[1, i]\n                    B[2, 2*i+1] = dN_dxy[0, i]\n                \n                k_e += B.T @ D @ B * detJ * w\n                \n            # Assembly\n            dof_map = np.array([[2*i, 2*i+1] for i in el_nodes_idx]).flatten()\n            K[np.ix_(dof_map, dof_map)] += k_e\n\n    elif element_type == 'T3':\n        for el_nodes_idx in elements:\n            el_nodes_coords = nodes[el_nodes_idx]\n            x1, y1 = el_nodes_coords[0]\n            x2, y2 = el_nodes_coords[1]\n            x3, y3 = el_nodes_coords[2]\n\n            area = 0.5 * np.abs(x1*(y2-y3) + x2*(y3-y1) + x3*(y1-y2))\n            \n            # B matrix (constant for T3)\n            B = (1 / (2 * area)) * np.array([\n                [y2-y3, 0,     y3-y1, 0,     y1-y2, 0    ],\n                [0,     x3-x2, 0,     x1-x3, 0,     x2-x1],\n                [x3-x2, y2-y3, x1-x3, y3-y1, x2-x1, y1-y2]\n            ])\n            \n            k_e = B.T @ D @ B * area\n            \n            # Assembly\n            dof_map = np.array([[2*i, 2*i+1] for i in el_nodes_idx]).flatten()\n            K[np.ix_(dof_map, dof_map)] += k_e\n\n    # 4. Apply Boundary Conditions by Elimination\n    is_boundary_node = np.array([\n        np.isclose(n[0], 0.0) or np.isclose(n[0], Lx) or\n        np.isclose(n[1], 0.0) or np.isclose(n[1], Ly)\n        for n in nodes\n    ])\n    \n    fixed_dofs = np.where(np.repeat(is_boundary_node, 2))[0]\n    free_dofs = np.where(~np.repeat(is_boundary_node, 2))[0]\n    \n    U = np.zeros(2 * num_nodes)\n    for node_idx in np.where(is_boundary_node)[0]:\n        x, y = nodes[node_idx]\n        U[2*node_idx : 2*node_idx+2] = u_star(x, y)\n        \n    U_d = U[fixed_dofs]\n    K_ff = K[np.ix_(free_dofs, free_dofs)]\n    K_fd = K[np.ix_(free_dofs, fixed_dofs)]\n    \n    F_eff = -K_fd @ U_d\n    \n    if free_dofs.size > 0:\n        U_f = np.linalg.solve(K_ff, F_eff)\n        U[free_dofs] = U_f\n\n    # 5. Error Evaluation\n    max_error = 0.0\n    if element_type == 'Q4':\n        for el_nodes_idx in elements:\n            el_nodes_coords = nodes[el_nodes_idx]\n            el_dofs = np.array([[2*i, 2*i+1] for i in el_nodes_idx]).flatten()\n            el_U = U[el_dofs]\n\n            for gp in gauss_points:\n                xi, eta = gp\n                # Shape functions at GP\n                N = 0.25 * np.array([\n                    (1-xi)*(1-eta), (1+xi)*(1-eta), \n                    (1+xi)*(1+eta), (1-xi)*(1+eta)\n                ])\n                # Physical coordinates of GP\n                xy_gp = N @ el_nodes_coords\n                # FEM solution at GP\n                u_h = np.array([N @ el_U[0::2], N @ el_U[1::2]])\n                # Exact solution at GP\n                u_exact = u_star(xy_gp[0], xy_gp[1])\n                \n                max_error = max(max_error, np.max(np.abs(u_h - u_exact)))\n\n    elif element_type == 'T3':\n        for el_nodes_idx in elements:\n            el_nodes_coords = nodes[el_nodes_idx]\n            el_dofs = np.array([[2*i, 2*i+1] for i in el_nodes_idx]).flatten()\n            el_U = U[el_dofs]\n            \n            # Centroid coordinates\n            xy_c = np.mean(el_nodes_coords, axis=0)\n            \n            # For linear triangle, interpolated value at centroid is average of nodal values\n            u_h = np.mean(el_U.reshape(-1, 2), axis=0)\n            u_exact = u_star(xy_c[0], xy_c[1])\n            \n            max_error = max(max_error, np.max(np.abs(u_h - u_exact)))\n\n    return max_error <= tau\n\ndef solve():\n    \"\"\"\n    Main function to run the suite of patch tests.\n    \"\"\"\n    test_suite = [\n        # Case 1: Q4, linear field (should pass)\n        ('Q4', 2, 2, 1.0, 1.0, 1.0, 0.25, 'linear', (0.1, 0.2, -0.3, -0.05, 0.4, 0.25), 1e-10),\n        # Case 2: T3, linear field (should pass)\n        ('T3', 2, 2, 1.0, 1.0, 1.0, 0.25, 'linear', (0.1, 0.2, -0.3, -0.05, 0.4, 0.25), 1e-10),\n        # Case 3: Q4, quadratic field (should fail)\n        ('Q4', 2, 2, 1.0, 1.0, 1.0, 0.25, 'quadratic', None, 1e-10),\n        # Case 4: Single element Q4, linear field (should pass)\n        ('Q4', 1, 1, 1.0, 1.0, 1.0, 0.25, 'linear', (0.0, 1.0, 0.0, 0.2, -0.1, 0.0), 1e-10),\n    ]\n\n    results = []\n    for params in test_suite:\n        result = perform_test(*params)\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2605421"}]}